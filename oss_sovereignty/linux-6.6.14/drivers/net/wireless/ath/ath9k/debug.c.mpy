{
  "module_name": "debug.c",
  "hash_id": "5beb1ce9523f800ca334764bd4e9a1c7d8b94cefa60b0d7f305c4492765e8b9e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath9k/debug.c",
  "human_readable_source": " \n\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <asm/unaligned.h>\n\n#include \"ath9k.h\"\n\n#define REG_WRITE_D(_ah, _reg, _val) \\\n\tath9k_hw_common(_ah)->ops->write((_ah), (_val), (_reg))\n#define REG_READ_D(_ah, _reg) \\\n\tath9k_hw_common(_ah)->ops->read((_ah), (_reg))\n\nvoid ath9k_debug_sync_cause(struct ath_softc *sc, u32 sync_cause)\n{\n\tif (sync_cause)\n\t\tsc->debug.stats.istats.sync_cause_all++;\n\tif (sync_cause & AR_INTR_SYNC_RTC_IRQ)\n\t\tsc->debug.stats.istats.sync_rtc_irq++;\n\tif (sync_cause & AR_INTR_SYNC_MAC_IRQ)\n\t\tsc->debug.stats.istats.sync_mac_irq++;\n\tif (sync_cause & AR_INTR_SYNC_EEPROM_ILLEGAL_ACCESS)\n\t\tsc->debug.stats.istats.eeprom_illegal_access++;\n\tif (sync_cause & AR_INTR_SYNC_APB_TIMEOUT)\n\t\tsc->debug.stats.istats.apb_timeout++;\n\tif (sync_cause & AR_INTR_SYNC_PCI_MODE_CONFLICT)\n\t\tsc->debug.stats.istats.pci_mode_conflict++;\n\tif (sync_cause & AR_INTR_SYNC_HOST1_FATAL)\n\t\tsc->debug.stats.istats.host1_fatal++;\n\tif (sync_cause & AR_INTR_SYNC_HOST1_PERR)\n\t\tsc->debug.stats.istats.host1_perr++;\n\tif (sync_cause & AR_INTR_SYNC_TRCV_FIFO_PERR)\n\t\tsc->debug.stats.istats.trcv_fifo_perr++;\n\tif (sync_cause & AR_INTR_SYNC_RADM_CPL_EP)\n\t\tsc->debug.stats.istats.radm_cpl_ep++;\n\tif (sync_cause & AR_INTR_SYNC_RADM_CPL_DLLP_ABORT)\n\t\tsc->debug.stats.istats.radm_cpl_dllp_abort++;\n\tif (sync_cause & AR_INTR_SYNC_RADM_CPL_TLP_ABORT)\n\t\tsc->debug.stats.istats.radm_cpl_tlp_abort++;\n\tif (sync_cause & AR_INTR_SYNC_RADM_CPL_ECRC_ERR)\n\t\tsc->debug.stats.istats.radm_cpl_ecrc_err++;\n\tif (sync_cause & AR_INTR_SYNC_RADM_CPL_TIMEOUT)\n\t\tsc->debug.stats.istats.radm_cpl_timeout++;\n\tif (sync_cause & AR_INTR_SYNC_LOCAL_TIMEOUT)\n\t\tsc->debug.stats.istats.local_timeout++;\n\tif (sync_cause & AR_INTR_SYNC_PM_ACCESS)\n\t\tsc->debug.stats.istats.pm_access++;\n\tif (sync_cause & AR_INTR_SYNC_MAC_AWAKE)\n\t\tsc->debug.stats.istats.mac_awake++;\n\tif (sync_cause & AR_INTR_SYNC_MAC_ASLEEP)\n\t\tsc->debug.stats.istats.mac_asleep++;\n\tif (sync_cause & AR_INTR_SYNC_MAC_SLEEP_ACCESS)\n\t\tsc->debug.stats.istats.mac_sleep_access++;\n}\n\nstatic ssize_t ath9k_debugfs_read_buf(struct file *file, char __user *user_buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tu8 *buf = file->private_data;\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, strlen(buf));\n}\n\nstatic int ath9k_debugfs_release_buf(struct inode *inode, struct file *file)\n{\n\tvfree(file->private_data);\n\treturn 0;\n}\n\n#ifdef CONFIG_ATH_DEBUG\n\nstatic ssize_t read_file_debug(struct file *file, char __user *user_buf,\n\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct ath_softc *sc = file->private_data;\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tchar buf[32];\n\tunsigned int len;\n\n\tlen = sprintf(buf, \"0x%08x\\n\", common->debug_mask);\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic ssize_t write_file_debug(struct file *file, const char __user *user_buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct ath_softc *sc = file->private_data;\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tunsigned long mask;\n\tssize_t ret;\n\n\tret = kstrtoul_from_user(user_buf, count, 0, &mask);\n\tif (ret)\n\t\treturn ret;\n\n\tcommon->debug_mask = mask;\n\treturn count;\n}\n\nstatic const struct file_operations fops_debug = {\n\t.read = read_file_debug,\n\t.write = write_file_debug,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\n#endif\n\n#define DMA_BUF_LEN 1024\n\n\nstatic ssize_t read_file_ani(struct file *file, char __user *user_buf,\n\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct ath_softc *sc = file->private_data;\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ath_hw *ah = sc->sc_ah;\n\tunsigned int len = 0;\n\tconst unsigned int size = 1024;\n\tssize_t retval = 0;\n\tchar *buf;\n\tint i;\n\tstruct {\n\t\tconst char *name;\n\t\tunsigned int val;\n\t} ani_info[] = {\n\t\t{ \"ANI RESET\", ah->stats.ast_ani_reset },\n\t\t{ \"OFDM LEVEL\", ah->ani.ofdmNoiseImmunityLevel },\n\t\t{ \"CCK LEVEL\", ah->ani.cckNoiseImmunityLevel },\n\t\t{ \"SPUR UP\", ah->stats.ast_ani_spurup },\n\t\t{ \"SPUR DOWN\", ah->stats.ast_ani_spurdown },\n\t\t{ \"OFDM WS-DET ON\", ah->stats.ast_ani_ofdmon },\n\t\t{ \"OFDM WS-DET OFF\", ah->stats.ast_ani_ofdmoff },\n\t\t{ \"MRC-CCK ON\", ah->stats.ast_ani_ccklow },\n\t\t{ \"MRC-CCK OFF\", ah->stats.ast_ani_cckhigh },\n\t\t{ \"FIR-STEP UP\", ah->stats.ast_ani_stepup },\n\t\t{ \"FIR-STEP DOWN\", ah->stats.ast_ani_stepdown },\n\t\t{ \"INV LISTENTIME\", ah->stats.ast_ani_lneg_or_lzero },\n\t\t{ \"OFDM ERRORS\", ah->stats.ast_ani_ofdmerrs },\n\t\t{ \"CCK ERRORS\", ah->stats.ast_ani_cckerrs },\n\t};\n\n\tbuf = kzalloc(size, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\tlen += scnprintf(buf + len, size - len, \"%15s: %s\\n\", \"ANI\",\n\t\t\t common->disable_ani ? \"DISABLED\" : \"ENABLED\");\n\n\tif (common->disable_ani)\n\t\tgoto exit;\n\n\tfor (i = 0; i < ARRAY_SIZE(ani_info); i++)\n\t\tlen += scnprintf(buf + len, size - len, \"%15s: %u\\n\",\n\t\t\t\t ani_info[i].name, ani_info[i].val);\n\nexit:\n\tif (len > size)\n\t\tlen = size;\n\n\tretval = simple_read_from_buffer(user_buf, count, ppos, buf, len);\n\tkfree(buf);\n\n\treturn retval;\n}\n\nstatic ssize_t write_file_ani(struct file *file,\n\t\t\t      const char __user *user_buf,\n\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct ath_softc *sc = file->private_data;\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tunsigned long ani;\n\tssize_t ret;\n\n\tret = kstrtoul_from_user(user_buf, count, 0, &ani);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ani > 1)\n\t\treturn -EINVAL;\n\n\tcommon->disable_ani = !ani;\n\n\tif (common->disable_ani) {\n\t\tclear_bit(ATH_OP_ANI_RUN, &common->op_flags);\n\t\tath_stop_ani(sc);\n\t} else {\n\t\tath_check_ani(sc);\n\t}\n\n\treturn count;\n}\n\nstatic const struct file_operations fops_ani = {\n\t.read = read_file_ani,\n\t.write = write_file_ani,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\n#ifdef CONFIG_ATH9K_BTCOEX_SUPPORT\n\nstatic ssize_t read_file_bt_ant_diversity(struct file *file,\n\t\t\t\t\t  char __user *user_buf,\n\t\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct ath_softc *sc = file->private_data;\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tchar buf[32];\n\tunsigned int len;\n\n\tlen = sprintf(buf, \"%d\\n\", common->bt_ant_diversity);\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic ssize_t write_file_bt_ant_diversity(struct file *file,\n\t\t\t\t\t   const char __user *user_buf,\n\t\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct ath_softc *sc = file->private_data;\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ath9k_hw_capabilities *pCap = &sc->sc_ah->caps;\n\tunsigned long bt_ant_diversity;\n\tssize_t ret;\n\n\tret = kstrtoul_from_user(user_buf, count, 0, &bt_ant_diversity);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!(pCap->hw_caps & ATH9K_HW_CAP_BT_ANT_DIV))\n\t\tgoto exit;\n\n\tcommon->bt_ant_diversity = !!bt_ant_diversity;\n\tath9k_ps_wakeup(sc);\n\tath9k_hw_set_bt_ant_diversity(sc->sc_ah, common->bt_ant_diversity);\n\tath_dbg(common, CONFIG, \"Enable WLAN/BT RX Antenna diversity: %d\\n\",\n\t\tcommon->bt_ant_diversity);\n\tath9k_ps_restore(sc);\nexit:\n\treturn count;\n}\n\nstatic const struct file_operations fops_bt_ant_diversity = {\n\t.read = read_file_bt_ant_diversity,\n\t.write = write_file_bt_ant_diversity,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\n#endif\n\nvoid ath9k_debug_stat_ant(struct ath_softc *sc,\n\t\t\t  struct ath_hw_antcomb_conf *div_ant_conf,\n\t\t\t  int main_rssi_avg, int alt_rssi_avg)\n{\n\tstruct ath_antenna_stats *as_main = &sc->debug.stats.ant_stats[ANT_MAIN];\n\tstruct ath_antenna_stats *as_alt = &sc->debug.stats.ant_stats[ANT_ALT];\n\n\tas_main->lna_attempt_cnt[div_ant_conf->main_lna_conf]++;\n\tas_alt->lna_attempt_cnt[div_ant_conf->alt_lna_conf]++;\n\n\tas_main->rssi_avg = main_rssi_avg;\n\tas_alt->rssi_avg = alt_rssi_avg;\n}\n\nstatic ssize_t read_file_antenna_diversity(struct file *file,\n\t\t\t\t\t   char __user *user_buf,\n\t\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct ath_softc *sc = file->private_data;\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath9k_hw_capabilities *pCap = &ah->caps;\n\tstruct ath_antenna_stats *as_main = &sc->debug.stats.ant_stats[ANT_MAIN];\n\tstruct ath_antenna_stats *as_alt = &sc->debug.stats.ant_stats[ANT_ALT];\n\tstruct ath_hw_antcomb_conf div_ant_conf;\n\tunsigned int len = 0;\n\tconst unsigned int size = 1024;\n\tssize_t retval = 0;\n\tchar *buf;\n\tstatic const char *lna_conf_str[4] = {\n\t\t\"LNA1_MINUS_LNA2\", \"LNA2\", \"LNA1\", \"LNA1_PLUS_LNA2\"\n\t};\n\n\tbuf = kzalloc(size, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\tif (!(pCap->hw_caps & ATH9K_HW_CAP_ANT_DIV_COMB)) {\n\t\tlen += scnprintf(buf + len, size - len, \"%s\\n\",\n\t\t\t\t \"Antenna Diversity Combining is disabled\");\n\t\tgoto exit;\n\t}\n\n\tath9k_ps_wakeup(sc);\n\tath9k_hw_antdiv_comb_conf_get(ah, &div_ant_conf);\n\tlen += scnprintf(buf + len, size - len, \"Current MAIN config : %s\\n\",\n\t\t\t lna_conf_str[div_ant_conf.main_lna_conf]);\n\tlen += scnprintf(buf + len, size - len, \"Current ALT config  : %s\\n\",\n\t\t\t lna_conf_str[div_ant_conf.alt_lna_conf]);\n\tlen += scnprintf(buf + len, size - len, \"Average MAIN RSSI   : %d\\n\",\n\t\t\t as_main->rssi_avg);\n\tlen += scnprintf(buf + len, size - len, \"Average ALT RSSI    : %d\\n\\n\",\n\t\t\t as_alt->rssi_avg);\n\tath9k_ps_restore(sc);\n\n\tlen += scnprintf(buf + len, size - len, \"Packet Receive Cnt:\\n\");\n\tlen += scnprintf(buf + len, size - len, \"-------------------\\n\");\n\n\tlen += scnprintf(buf + len, size - len, \"%30s%15s\\n\",\n\t\t\t \"MAIN\", \"ALT\");\n\tlen += scnprintf(buf + len, size - len, \"%-14s:%15d%15d\\n\",\n\t\t\t \"TOTAL COUNT\",\n\t\t\t as_main->recv_cnt,\n\t\t\t as_alt->recv_cnt);\n\tlen += scnprintf(buf + len, size - len, \"%-14s:%15d%15d\\n\",\n\t\t\t \"LNA1\",\n\t\t\t as_main->lna_recv_cnt[ATH_ANT_DIV_COMB_LNA1],\n\t\t\t as_alt->lna_recv_cnt[ATH_ANT_DIV_COMB_LNA1]);\n\tlen += scnprintf(buf + len, size - len, \"%-14s:%15d%15d\\n\",\n\t\t\t \"LNA2\",\n\t\t\t as_main->lna_recv_cnt[ATH_ANT_DIV_COMB_LNA2],\n\t\t\t as_alt->lna_recv_cnt[ATH_ANT_DIV_COMB_LNA2]);\n\tlen += scnprintf(buf + len, size - len, \"%-14s:%15d%15d\\n\",\n\t\t\t \"LNA1 + LNA2\",\n\t\t\t as_main->lna_recv_cnt[ATH_ANT_DIV_COMB_LNA1_PLUS_LNA2],\n\t\t\t as_alt->lna_recv_cnt[ATH_ANT_DIV_COMB_LNA1_PLUS_LNA2]);\n\tlen += scnprintf(buf + len, size - len, \"%-14s:%15d%15d\\n\",\n\t\t\t \"LNA1 - LNA2\",\n\t\t\t as_main->lna_recv_cnt[ATH_ANT_DIV_COMB_LNA1_MINUS_LNA2],\n\t\t\t as_alt->lna_recv_cnt[ATH_ANT_DIV_COMB_LNA1_MINUS_LNA2]);\n\n\tlen += scnprintf(buf + len, size - len, \"\\nLNA Config Attempts:\\n\");\n\tlen += scnprintf(buf + len, size - len, \"--------------------\\n\");\n\n\tlen += scnprintf(buf + len, size - len, \"%30s%15s\\n\",\n\t\t\t \"MAIN\", \"ALT\");\n\tlen += scnprintf(buf + len, size - len, \"%-14s:%15d%15d\\n\",\n\t\t\t \"LNA1\",\n\t\t\t as_main->lna_attempt_cnt[ATH_ANT_DIV_COMB_LNA1],\n\t\t\t as_alt->lna_attempt_cnt[ATH_ANT_DIV_COMB_LNA1]);\n\tlen += scnprintf(buf + len, size - len, \"%-14s:%15d%15d\\n\",\n\t\t\t \"LNA2\",\n\t\t\t as_main->lna_attempt_cnt[ATH_ANT_DIV_COMB_LNA2],\n\t\t\t as_alt->lna_attempt_cnt[ATH_ANT_DIV_COMB_LNA2]);\n\tlen += scnprintf(buf + len, size - len, \"%-14s:%15d%15d\\n\",\n\t\t\t \"LNA1 + LNA2\",\n\t\t\t as_main->lna_attempt_cnt[ATH_ANT_DIV_COMB_LNA1_PLUS_LNA2],\n\t\t\t as_alt->lna_attempt_cnt[ATH_ANT_DIV_COMB_LNA1_PLUS_LNA2]);\n\tlen += scnprintf(buf + len, size - len, \"%-14s:%15d%15d\\n\",\n\t\t\t \"LNA1 - LNA2\",\n\t\t\t as_main->lna_attempt_cnt[ATH_ANT_DIV_COMB_LNA1_MINUS_LNA2],\n\t\t\t as_alt->lna_attempt_cnt[ATH_ANT_DIV_COMB_LNA1_MINUS_LNA2]);\n\nexit:\n\tif (len > size)\n\t\tlen = size;\n\n\tretval = simple_read_from_buffer(user_buf, count, ppos, buf, len);\n\tkfree(buf);\n\n\treturn retval;\n}\n\nstatic const struct file_operations fops_antenna_diversity = {\n\t.read = read_file_antenna_diversity,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic int read_file_dma(struct seq_file *file, void *data)\n{\n\tstruct ieee80211_hw *hw = dev_get_drvdata(file->private);\n\tstruct ath_softc *sc = hw->priv;\n\tstruct ath_hw *ah = sc->sc_ah;\n\tu32 val[ATH9K_NUM_DMA_DEBUG_REGS];\n\tint i, qcuOffset = 0, dcuOffset = 0;\n\tu32 *qcuBase = &val[0], *dcuBase = &val[4];\n\n\tath9k_ps_wakeup(sc);\n\n\tREG_WRITE_D(ah, AR_MACMISC,\n\t\t  ((AR_MACMISC_DMA_OBS_LINE_8 << AR_MACMISC_DMA_OBS_S) |\n\t\t   (AR_MACMISC_MISC_OBS_BUS_1 <<\n\t\t    AR_MACMISC_MISC_OBS_BUS_MSB_S)));\n\n\tseq_puts(file, \"Raw DMA Debug values:\\n\");\n\n\tfor (i = 0; i < ATH9K_NUM_DMA_DEBUG_REGS; i++) {\n\t\tif (i % 4 == 0)\n\t\t\tseq_puts(file, \"\\n\");\n\n\t\tval[i] = REG_READ_D(ah, AR_DMADBG_0 + (i * sizeof(u32)));\n\t\tseq_printf(file, \"%d: %08x \", i, val[i]);\n\t}\n\n\tseq_puts(file, \"\\n\\n\");\n\tseq_puts(file, \"Num QCU: chain_st fsp_ok fsp_st DCU: chain_st\\n\");\n\n\tfor (i = 0; i < ATH9K_NUM_QUEUES; i++, qcuOffset += 4, dcuOffset += 5) {\n\t\tif (i == 8) {\n\t\t\tqcuOffset = 0;\n\t\t\tqcuBase++;\n\t\t}\n\n\t\tif (i == 6) {\n\t\t\tdcuOffset = 0;\n\t\t\tdcuBase++;\n\t\t}\n\n\t\tseq_printf(file, \"%2d          %2x      %1x     %2x           %2x\\n\",\n\t\t\t   i, (*qcuBase & (0x7 << qcuOffset)) >> qcuOffset,\n\t\t\t   (*qcuBase & (0x8 << qcuOffset)) >> (qcuOffset + 3),\n\t\t\t   (val[2] & (0x7 << (i * 3))) >> (i * 3),\n\t\t\t   (*dcuBase & (0x1f << dcuOffset)) >> dcuOffset);\n\t}\n\n\tseq_puts(file, \"\\n\");\n\n\tseq_printf(file, \"qcu_stitch state:   %2x    qcu_fetch state:        %2x\\n\",\n\t\t   (val[3] & 0x003c0000) >> 18, (val[3] & 0x03c00000) >> 22);\n\tseq_printf(file, \"qcu_complete state: %2x    dcu_complete state:     %2x\\n\",\n\t\t   (val[3] & 0x1c000000) >> 26, (val[6] & 0x3));\n\tseq_printf(file, \"dcu_arb state:      %2x    dcu_fp state:           %2x\\n\",\n\t\t   (val[5] & 0x06000000) >> 25, (val[5] & 0x38000000) >> 27);\n\tseq_printf(file, \"chan_idle_dur:     %3d    chan_idle_dur_valid:     %1d\\n\",\n\t\t   (val[6] & 0x000003fc) >> 2, (val[6] & 0x00000400) >> 10);\n\tseq_printf(file, \"txfifo_valid_0:      %1d    txfifo_valid_1:          %1d\\n\",\n\t\t   (val[6] & 0x00000800) >> 11, (val[6] & 0x00001000) >> 12);\n\tseq_printf(file, \"txfifo_dcu_num_0:   %2d    txfifo_dcu_num_1:       %2d\\n\",\n\t\t   (val[6] & 0x0001e000) >> 13, (val[6] & 0x001e0000) >> 17);\n\n\tseq_printf(file, \"pcu observe: 0x%x\\n\", REG_READ_D(ah, AR_OBS_BUS_1));\n\tseq_printf(file, \"AR_CR: 0x%x\\n\", REG_READ_D(ah, AR_CR));\n\n\tath9k_ps_restore(sc);\n\n\treturn 0;\n}\n\nvoid ath_debug_stat_interrupt(struct ath_softc *sc, enum ath9k_int status)\n{\n\tif (status)\n\t\tsc->debug.stats.istats.total++;\n\tif (sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_EDMA) {\n\t\tif (status & ATH9K_INT_RXLP)\n\t\t\tsc->debug.stats.istats.rxlp++;\n\t\tif (status & ATH9K_INT_RXHP)\n\t\t\tsc->debug.stats.istats.rxhp++;\n\t\tif (status & ATH9K_INT_BB_WATCHDOG)\n\t\t\tsc->debug.stats.istats.bb_watchdog++;\n\t} else {\n\t\tif (status & ATH9K_INT_RX)\n\t\t\tsc->debug.stats.istats.rxok++;\n\t}\n\tif (status & ATH9K_INT_RXEOL)\n\t\tsc->debug.stats.istats.rxeol++;\n\tif (status & ATH9K_INT_RXORN)\n\t\tsc->debug.stats.istats.rxorn++;\n\tif (status & ATH9K_INT_TX)\n\t\tsc->debug.stats.istats.txok++;\n\tif (status & ATH9K_INT_TXURN)\n\t\tsc->debug.stats.istats.txurn++;\n\tif (status & ATH9K_INT_RXPHY)\n\t\tsc->debug.stats.istats.rxphyerr++;\n\tif (status & ATH9K_INT_RXKCM)\n\t\tsc->debug.stats.istats.rx_keycache_miss++;\n\tif (status & ATH9K_INT_SWBA)\n\t\tsc->debug.stats.istats.swba++;\n\tif (status & ATH9K_INT_BMISS)\n\t\tsc->debug.stats.istats.bmiss++;\n\tif (status & ATH9K_INT_BNR)\n\t\tsc->debug.stats.istats.bnr++;\n\tif (status & ATH9K_INT_CST)\n\t\tsc->debug.stats.istats.cst++;\n\tif (status & ATH9K_INT_GTT)\n\t\tsc->debug.stats.istats.gtt++;\n\tif (status & ATH9K_INT_TIM)\n\t\tsc->debug.stats.istats.tim++;\n\tif (status & ATH9K_INT_CABEND)\n\t\tsc->debug.stats.istats.cabend++;\n\tif (status & ATH9K_INT_DTIMSYNC)\n\t\tsc->debug.stats.istats.dtimsync++;\n\tif (status & ATH9K_INT_DTIM)\n\t\tsc->debug.stats.istats.dtim++;\n\tif (status & ATH9K_INT_TSFOOR)\n\t\tsc->debug.stats.istats.tsfoor++;\n\tif (status & ATH9K_INT_MCI)\n\t\tsc->debug.stats.istats.mci++;\n\tif (status & ATH9K_INT_GENTIMER)\n\t\tsc->debug.stats.istats.gen_timer++;\n}\n\nstatic int read_file_interrupt(struct seq_file *file, void *data)\n{\n\tstruct ieee80211_hw *hw = dev_get_drvdata(file->private);\n\tstruct ath_softc *sc = hw->priv;\n\n#define PR_IS(a, s)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tseq_printf(file, \"%21s: %10u\\n\", a,\t\t\\\n\t\t\t   sc->debug.stats.istats.s);\t\t\\\n\t} while (0)\n\n\tif (sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_EDMA) {\n\t\tPR_IS(\"RXLP\", rxlp);\n\t\tPR_IS(\"RXHP\", rxhp);\n\t\tPR_IS(\"WATCHDOG\", bb_watchdog);\n\t} else {\n\t\tPR_IS(\"RX\", rxok);\n\t}\n\tPR_IS(\"RXEOL\", rxeol);\n\tPR_IS(\"RXORN\", rxorn);\n\tPR_IS(\"TX\", txok);\n\tPR_IS(\"TXURN\", txurn);\n\tPR_IS(\"MIB\", mib);\n\tPR_IS(\"RXPHY\", rxphyerr);\n\tPR_IS(\"RXKCM\", rx_keycache_miss);\n\tPR_IS(\"SWBA\", swba);\n\tPR_IS(\"BMISS\", bmiss);\n\tPR_IS(\"BNR\", bnr);\n\tPR_IS(\"CST\", cst);\n\tPR_IS(\"GTT\", gtt);\n\tPR_IS(\"TIM\", tim);\n\tPR_IS(\"CABEND\", cabend);\n\tPR_IS(\"DTIMSYNC\", dtimsync);\n\tPR_IS(\"DTIM\", dtim);\n\tPR_IS(\"TSFOOR\", tsfoor);\n\tPR_IS(\"MCI\", mci);\n\tPR_IS(\"GENTIMER\", gen_timer);\n\tPR_IS(\"TOTAL\", total);\n\n\tseq_puts(file, \"SYNC_CAUSE stats:\\n\");\n\n\tPR_IS(\"Sync-All\", sync_cause_all);\n\tPR_IS(\"RTC-IRQ\", sync_rtc_irq);\n\tPR_IS(\"MAC-IRQ\", sync_mac_irq);\n\tPR_IS(\"EEPROM-Illegal-Access\", eeprom_illegal_access);\n\tPR_IS(\"APB-Timeout\", apb_timeout);\n\tPR_IS(\"PCI-Mode-Conflict\", pci_mode_conflict);\n\tPR_IS(\"HOST1-Fatal\", host1_fatal);\n\tPR_IS(\"HOST1-Perr\", host1_perr);\n\tPR_IS(\"TRCV-FIFO-Perr\", trcv_fifo_perr);\n\tPR_IS(\"RADM-CPL-EP\", radm_cpl_ep);\n\tPR_IS(\"RADM-CPL-DLLP-Abort\", radm_cpl_dllp_abort);\n\tPR_IS(\"RADM-CPL-TLP-Abort\", radm_cpl_tlp_abort);\n\tPR_IS(\"RADM-CPL-ECRC-Err\", radm_cpl_ecrc_err);\n\tPR_IS(\"RADM-CPL-Timeout\", radm_cpl_timeout);\n\tPR_IS(\"Local-Bus-Timeout\", local_timeout);\n\tPR_IS(\"PM-Access\", pm_access);\n\tPR_IS(\"MAC-Awake\", mac_awake);\n\tPR_IS(\"MAC-Asleep\", mac_asleep);\n\tPR_IS(\"MAC-Sleep-Access\", mac_sleep_access);\n\n\treturn 0;\n}\n\nstatic int read_file_xmit(struct seq_file *file, void *data)\n{\n\tstruct ieee80211_hw *hw = dev_get_drvdata(file->private);\n\tstruct ath_softc *sc = hw->priv;\n\n\tseq_printf(file, \"%30s %10s%10s%10s\\n\\n\", \"BE\", \"BK\", \"VI\", \"VO\");\n\n\tPR(\"MPDUs Queued:    \", queued);\n\tPR(\"MPDUs Completed: \", completed);\n\tPR(\"MPDUs XRetried:  \", xretries);\n\tPR(\"Aggregates:      \", a_aggr);\n\tPR(\"AMPDUs Queued HW:\", a_queued_hw);\n\tPR(\"AMPDUs Completed:\", a_completed);\n\tPR(\"AMPDUs Retried:  \", a_retries);\n\tPR(\"AMPDUs XRetried: \", a_xretries);\n\tPR(\"TXERR Filtered:  \", txerr_filtered);\n\tPR(\"FIFO Underrun:   \", fifo_underrun);\n\tPR(\"TXOP Exceeded:   \", xtxop);\n\tPR(\"TXTIMER Expiry:  \", timer_exp);\n\tPR(\"DESC CFG Error:  \", desc_cfg_err);\n\tPR(\"DATA Underrun:   \", data_underrun);\n\tPR(\"DELIM Underrun:  \", delim_underrun);\n\tPR(\"TX-Pkts-All:     \", tx_pkts_all);\n\tPR(\"TX-Bytes-All:    \", tx_bytes_all);\n\tPR(\"HW-put-tx-buf:   \", puttxbuf);\n\tPR(\"HW-tx-start:     \", txstart);\n\tPR(\"HW-tx-proc-desc: \", txprocdesc);\n\tPR(\"TX-Failed:       \", txfailed);\n\n\treturn 0;\n}\n\nstatic void print_queue(struct ath_softc *sc, struct ath_txq *txq,\n\t\t\tstruct seq_file *file)\n{\n\tath_txq_lock(sc, txq);\n\n\tseq_printf(file, \"%s: %d \", \"qnum\", txq->axq_qnum);\n\tseq_printf(file, \"%s: %2d \", \"qdepth\", txq->axq_depth);\n\tseq_printf(file, \"%s: %2d \", \"ampdu-depth\", txq->axq_ampdu_depth);\n\tseq_printf(file, \"%s: %3d\\n\", \"pending\", txq->pending_frames);\n\n\tath_txq_unlock(sc, txq);\n}\n\nstatic int read_file_queues(struct seq_file *file, void *data)\n{\n\tstruct ieee80211_hw *hw = dev_get_drvdata(file->private);\n\tstruct ath_softc *sc = hw->priv;\n\tstruct ath_txq *txq;\n\tint i;\n\tstatic const char *qname[4] = {\n\t\t\"VO\", \"VI\", \"BE\", \"BK\"\n\t};\n\n\tfor (i = 0; i < IEEE80211_NUM_ACS; i++) {\n\t\ttxq = sc->tx.txq_map[i];\n\t\tseq_printf(file, \"(%s):  \", qname[i]);\n\t\tprint_queue(sc, txq, file);\n\t}\n\n\tseq_puts(file, \"(CAB): \");\n\tprint_queue(sc, sc->beacon.cabq, file);\n\n\treturn 0;\n}\n\nstatic int read_file_misc(struct seq_file *file, void *data)\n{\n\tstruct ieee80211_hw *hw = dev_get_drvdata(file->private);\n\tstruct ath_softc *sc = hw->priv;\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ath9k_vif_iter_data iter_data;\n\tstruct ath_chanctx *ctx;\n\tunsigned int reg;\n\tu32 rxfilter, i;\n\n\tseq_printf(file, \"BSSID: %pM\\n\", common->curbssid);\n\tseq_printf(file, \"BSSID-MASK: %pM\\n\", common->bssidmask);\n\tseq_printf(file, \"OPMODE: %s\\n\",\n\t\t   ath_opmode_to_string(sc->sc_ah->opmode));\n\n\tath9k_ps_wakeup(sc);\n\trxfilter = ath9k_hw_getrxfilter(sc->sc_ah);\n\tath9k_ps_restore(sc);\n\n\tseq_printf(file, \"RXFILTER: 0x%x\", rxfilter);\n\n\tif (rxfilter & ATH9K_RX_FILTER_UCAST)\n\t\tseq_puts(file, \" UCAST\");\n\tif (rxfilter & ATH9K_RX_FILTER_MCAST)\n\t\tseq_puts(file, \" MCAST\");\n\tif (rxfilter & ATH9K_RX_FILTER_BCAST)\n\t\tseq_puts(file, \" BCAST\");\n\tif (rxfilter & ATH9K_RX_FILTER_CONTROL)\n\t\tseq_puts(file, \" CONTROL\");\n\tif (rxfilter & ATH9K_RX_FILTER_BEACON)\n\t\tseq_puts(file, \" BEACON\");\n\tif (rxfilter & ATH9K_RX_FILTER_PROM)\n\t\tseq_puts(file, \" PROM\");\n\tif (rxfilter & ATH9K_RX_FILTER_PROBEREQ)\n\t\tseq_puts(file, \" PROBEREQ\");\n\tif (rxfilter & ATH9K_RX_FILTER_PHYERR)\n\t\tseq_puts(file, \" PHYERR\");\n\tif (rxfilter & ATH9K_RX_FILTER_MYBEACON)\n\t\tseq_puts(file, \" MYBEACON\");\n\tif (rxfilter & ATH9K_RX_FILTER_COMP_BAR)\n\t\tseq_puts(file, \" COMP_BAR\");\n\tif (rxfilter & ATH9K_RX_FILTER_PSPOLL)\n\t\tseq_puts(file, \" PSPOLL\");\n\tif (rxfilter & ATH9K_RX_FILTER_PHYRADAR)\n\t\tseq_puts(file, \" PHYRADAR\");\n\tif (rxfilter & ATH9K_RX_FILTER_MCAST_BCAST_ALL)\n\t\tseq_puts(file, \" MCAST_BCAST_ALL\");\n\tif (rxfilter & ATH9K_RX_FILTER_CONTROL_WRAPPER)\n\t\tseq_puts(file, \" CONTROL_WRAPPER\");\n\n\tseq_puts(file, \"\\n\");\n\n\treg = sc->sc_ah->imask;\n\n\tseq_printf(file, \"INTERRUPT-MASK: 0x%x\", reg);\n\n\tif (reg & ATH9K_INT_SWBA)\n\t\tseq_puts(file, \" SWBA\");\n\tif (reg & ATH9K_INT_BMISS)\n\t\tseq_puts(file, \" BMISS\");\n\tif (reg & ATH9K_INT_CST)\n\t\tseq_puts(file, \" CST\");\n\tif (reg & ATH9K_INT_RX)\n\t\tseq_puts(file, \" RX\");\n\tif (reg & ATH9K_INT_RXHP)\n\t\tseq_puts(file, \" RXHP\");\n\tif (reg & ATH9K_INT_RXLP)\n\t\tseq_puts(file, \" RXLP\");\n\tif (reg & ATH9K_INT_BB_WATCHDOG)\n\t\tseq_puts(file, \" BB_WATCHDOG\");\n\n\tseq_puts(file, \"\\n\");\n\n\ti = 0;\n\tath_for_each_chanctx(sc, ctx) {\n\t\tif (list_empty(&ctx->vifs))\n\t\t\tcontinue;\n\t\tath9k_calculate_iter_data(sc, ctx, &iter_data);\n\n\t\tseq_printf(file,\n\t\t\t   \"VIFS: CTX %i(%i) AP: %i STA: %i MESH: %i\",\n\t\t\t   i++, (int)(ctx->assigned), iter_data.naps,\n\t\t\t   iter_data.nstations,\n\t\t\t   iter_data.nmeshes);\n\t\tseq_printf(file, \" ADHOC: %i OCB: %i TOTAL: %hi BEACON-VIF: %hi\\n\",\n\t\t\t   iter_data.nadhocs, iter_data.nocbs, sc->cur_chan->nvifs,\n\t\t\t   sc->nbcnvifs);\n\t}\n\n\treturn 0;\n}\n\nstatic int read_file_reset(struct seq_file *file, void *data)\n{\n\tstruct ath_softc *sc = file->private;\n\tstatic const char * const reset_cause[__RESET_TYPE_MAX] = {\n\t\t[RESET_TYPE_USER] = \"User reset\",\n\t\t[RESET_TYPE_BB_HANG] = \"Baseband Hang\",\n\t\t[RESET_TYPE_BB_WATCHDOG] = \"Baseband Watchdog\",\n\t\t[RESET_TYPE_FATAL_INT] = \"Fatal HW Error\",\n\t\t[RESET_TYPE_TX_ERROR] = \"TX HW error\",\n\t\t[RESET_TYPE_TX_GTT] = \"Transmit timeout\",\n\t\t[RESET_TYPE_TX_HANG] = \"TX Path Hang\",\n\t\t[RESET_TYPE_PLL_HANG] = \"PLL RX Hang\",\n\t\t[RESET_TYPE_MAC_HANG] = \"MAC Hang\",\n\t\t[RESET_TYPE_BEACON_STUCK] = \"Stuck Beacon\",\n\t\t[RESET_TYPE_MCI] = \"MCI Reset\",\n\t\t[RESET_TYPE_CALIBRATION] = \"Calibration error\",\n\t\t[RESET_TX_DMA_ERROR] = \"Tx DMA stop error\",\n\t\t[RESET_RX_DMA_ERROR] = \"Rx DMA stop error\",\n\t};\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(reset_cause); i++) {\n\t\tif (!reset_cause[i])\n\t\t    continue;\n\n\t\tseq_printf(file, \"%17s: %2d\\n\", reset_cause[i],\n\t\t\t   sc->debug.stats.reset[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic int open_file_reset(struct inode *inode, struct file *f)\n{\n\treturn single_open(f, read_file_reset, inode->i_private);\n}\n\nstatic ssize_t write_file_reset(struct file *file,\n\t\t\t\tconst char __user *user_buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct ath_softc *sc = file_inode(file)->i_private;\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tunsigned long val;\n\tssize_t ret;\n\n\tret = kstrtoul_from_user(user_buf, count, 0, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val != 1)\n\t\treturn -EINVAL;\n\n\t \n\tmutex_lock(&sc->mutex);\n\tif (test_bit(ATH_OP_INVALID, &common->op_flags)) {\n\t\tmutex_unlock(&sc->mutex);\n\t\treturn -EBUSY;\n\t}\n\n\tath9k_queue_reset(sc, RESET_TYPE_USER);\n\tmutex_unlock(&sc->mutex);\n\n\treturn count;\n}\n\nstatic const struct file_operations fops_reset = {\n\t.read = seq_read,\n\t.write = write_file_reset,\n\t.open = open_file_reset,\n\t.owner = THIS_MODULE,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n};\n\nvoid ath_debug_stat_tx(struct ath_softc *sc, struct ath_buf *bf,\n\t\t       struct ath_tx_status *ts, struct ath_txq *txq,\n\t\t       unsigned int flags)\n{\n\tint qnum = txq->axq_qnum;\n\n\tTX_STAT_INC(sc, qnum, tx_pkts_all);\n\tsc->debug.stats.txstats[qnum].tx_bytes_all += bf->bf_mpdu->len;\n\n\tif (bf_isampdu(bf)) {\n\t\tif (flags & ATH_TX_ERROR)\n\t\t\tTX_STAT_INC(sc, qnum, a_xretries);\n\t\telse\n\t\t\tTX_STAT_INC(sc, qnum, a_completed);\n\t} else {\n\t\tif (ts->ts_status & ATH9K_TXERR_XRETRY)\n\t\t\tTX_STAT_INC(sc, qnum, xretries);\n\t\telse\n\t\t\tTX_STAT_INC(sc, qnum, completed);\n\t}\n\n\tif (ts->ts_status & ATH9K_TXERR_FILT)\n\t\tTX_STAT_INC(sc, qnum, txerr_filtered);\n\tif (ts->ts_status & ATH9K_TXERR_FIFO)\n\t\tTX_STAT_INC(sc, qnum, fifo_underrun);\n\tif (ts->ts_status & ATH9K_TXERR_XTXOP)\n\t\tTX_STAT_INC(sc, qnum, xtxop);\n\tif (ts->ts_status & ATH9K_TXERR_TIMER_EXPIRED)\n\t\tTX_STAT_INC(sc, qnum, timer_exp);\n\tif (ts->ts_flags & ATH9K_TX_DESC_CFG_ERR)\n\t\tTX_STAT_INC(sc, qnum, desc_cfg_err);\n\tif (ts->ts_flags & ATH9K_TX_DATA_UNDERRUN)\n\t\tTX_STAT_INC(sc, qnum, data_underrun);\n\tif (ts->ts_flags & ATH9K_TX_DELIM_UNDERRUN)\n\t\tTX_STAT_INC(sc, qnum, delim_underrun);\n}\n\nvoid ath_debug_stat_rx(struct ath_softc *sc, struct ath_rx_status *rs)\n{\n\tath9k_cmn_debug_stat_rx(&sc->debug.stats.rxstats, rs);\n}\n\nstatic ssize_t read_file_regidx(struct file *file, char __user *user_buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct ath_softc *sc = file->private_data;\n\tchar buf[32];\n\tunsigned int len;\n\n\tlen = sprintf(buf, \"0x%08x\\n\", sc->debug.regidx);\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic ssize_t write_file_regidx(struct file *file, const char __user *user_buf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct ath_softc *sc = file->private_data;\n\tunsigned long regidx;\n\tssize_t ret;\n\n\tret = kstrtoul_from_user(user_buf, count, 0, &regidx);\n\tif (ret)\n\t\treturn ret;\n\n\tsc->debug.regidx = regidx;\n\treturn count;\n}\n\nstatic const struct file_operations fops_regidx = {\n\t.read = read_file_regidx,\n\t.write = write_file_regidx,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t read_file_regval(struct file *file, char __user *user_buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct ath_softc *sc = file->private_data;\n\tstruct ath_hw *ah = sc->sc_ah;\n\tchar buf[32];\n\tunsigned int len;\n\tu32 regval;\n\n\tath9k_ps_wakeup(sc);\n\tregval = REG_READ_D(ah, sc->debug.regidx);\n\tath9k_ps_restore(sc);\n\tlen = sprintf(buf, \"0x%08x\\n\", regval);\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic ssize_t write_file_regval(struct file *file, const char __user *user_buf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct ath_softc *sc = file->private_data;\n\tstruct ath_hw *ah = sc->sc_ah;\n\tunsigned long regval;\n\tssize_t ret;\n\n\tret = kstrtoul_from_user(user_buf, count, 0, &regval);\n\tif (ret)\n\t\treturn ret;\n\n\tath9k_ps_wakeup(sc);\n\tREG_WRITE_D(ah, sc->debug.regidx, regval);\n\tath9k_ps_restore(sc);\n\treturn count;\n}\n\nstatic const struct file_operations fops_regval = {\n\t.read = read_file_regval,\n\t.write = write_file_regval,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\n#define REGDUMP_LINE_SIZE\t20\n\nstatic int open_file_regdump(struct inode *inode, struct file *file)\n{\n\tstruct ath_softc *sc = inode->i_private;\n\tunsigned int len = 0;\n\tu8 *buf;\n\tint i, j = 0;\n\tunsigned long num_regs, regdump_len, max_reg_offset;\n\tstatic const struct reg_hole {\n\t\tu32 start;\n\t\tu32 end;\n\t} reg_hole_list[] = {\n\t\t{0x0200, 0x07fc},\n\t\t{0x0c00, 0x0ffc},\n\t\t{0x2000, 0x3ffc},\n\t\t{0x4100, 0x6ffc},\n\t\t{0x705c, 0x7ffc},\n\t\t{0x0000, 0x0000}\n\t};\n\n\tmax_reg_offset = AR_SREV_9300_20_OR_LATER(sc->sc_ah) ? 0x8800 : 0xb500;\n\tnum_regs = max_reg_offset / 4 + 1;\n\tregdump_len = num_regs * REGDUMP_LINE_SIZE + 1;\n\tbuf = vmalloc(regdump_len);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tath9k_ps_wakeup(sc);\n\tfor (i = 0; i < num_regs; i++) {\n\t\tif (reg_hole_list[j].start == i << 2) {\n\t\t\ti = reg_hole_list[j].end >> 2;\n\t\t\tj++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlen += scnprintf(buf + len, regdump_len - len,\n\t\t\t\"0x%06x 0x%08x\\n\", i << 2, REG_READ(sc->sc_ah, i << 2));\n\t}\n\tath9k_ps_restore(sc);\n\n\tfile->private_data = buf;\n\n\treturn 0;\n}\n\nstatic const struct file_operations fops_regdump = {\n\t.open = open_file_regdump,\n\t.read = ath9k_debugfs_read_buf,\n\t.release = ath9k_debugfs_release_buf,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek, \n};\n\nstatic int read_file_dump_nfcal(struct seq_file *file, void *data)\n{\n\tstruct ieee80211_hw *hw = dev_get_drvdata(file->private);\n\tstruct ath_softc *sc = hw->priv;\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath9k_nfcal_hist *h = sc->cur_chan->caldata.nfCalHist;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ieee80211_conf *conf = &common->hw->conf;\n\tu32 i, j;\n\tu8 chainmask = (ah->rxchainmask << 3) | ah->rxchainmask;\n\tu8 nread;\n\n\tseq_printf(file, \"Channel Noise Floor : %d\\n\", ah->noise);\n\tseq_puts(file, \"Chain | privNF | # Readings | NF Readings\\n\");\n\tfor (i = 0; i < NUM_NF_READINGS; i++) {\n\t\tif (!(chainmask & (1 << i)) ||\n\t\t    ((i >= AR5416_MAX_CHAINS) && !conf_is_ht40(conf)))\n\t\t\tcontinue;\n\n\t\tnread = AR_PHY_CCA_FILTERWINDOW_LENGTH - h[i].invalidNFcount;\n\t\tseq_printf(file, \" %d\\t %d\\t %d\\t\\t\", i, h[i].privNF, nread);\n\t\tfor (j = 0; j < nread; j++)\n\t\t\tseq_printf(file, \" %d\", h[i].nfCalBuffer[j]);\n\t\tseq_puts(file, \"\\n\");\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_ATH9K_BTCOEX_SUPPORT\nstatic ssize_t read_file_btcoex(struct file *file, char __user *user_buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct ath_softc *sc = file->private_data;\n\tu32 len = 0, size = 1500;\n\tchar *buf;\n\tsize_t retval;\n\n\tbuf = kzalloc(size, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\tif (!sc->sc_ah->common.btcoex_enabled) {\n\t\tlen = scnprintf(buf, size, \"%s\\n\",\n\t\t\t\t\"BTCOEX is disabled\");\n\t\tgoto exit;\n\t}\n\n\tlen = ath9k_dump_btcoex(sc, buf, size);\nexit:\n\tretval = simple_read_from_buffer(user_buf, count, ppos, buf, len);\n\tkfree(buf);\n\n\treturn retval;\n}\n\nstatic const struct file_operations fops_btcoex = {\n\t.read = read_file_btcoex,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n#endif\n\n#ifdef CONFIG_ATH9K_DYNACK\nstatic ssize_t read_file_ackto(struct file *file, char __user *user_buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct ath_softc *sc = file->private_data;\n\tstruct ath_hw *ah = sc->sc_ah;\n\tchar buf[32];\n\tunsigned int len;\n\n\tlen = sprintf(buf, \"%u %c\\n\", ah->dynack.ackto,\n\t\t      (ah->dynack.enabled) ? 'A' : 'S');\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic const struct file_operations fops_ackto = {\n\t.read = read_file_ackto,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n#endif\n\n#ifdef CONFIG_ATH9K_WOW\n\nstatic ssize_t read_file_wow(struct file *file, char __user *user_buf,\n\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct ath_softc *sc = file->private_data;\n\tunsigned int len = 0, size = 32;\n\tssize_t retval;\n\tchar *buf;\n\n\tbuf = kzalloc(size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tlen += scnprintf(buf + len, size - len, \"WOW: %s\\n\",\n\t\t\t sc->force_wow ? \"ENABLED\" : \"DISABLED\");\n\n\tif (len > size)\n\t\tlen = size;\n\n\tretval = simple_read_from_buffer(user_buf, count, ppos, buf, len);\n\tkfree(buf);\n\n\treturn retval;\n}\n\nstatic ssize_t write_file_wow(struct file *file, const char __user *user_buf,\n\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct ath_softc *sc = file->private_data;\n\tunsigned long val;\n\tssize_t ret;\n\n\tret = kstrtoul_from_user(user_buf, count, 0, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val != 1)\n\t\treturn -EINVAL;\n\n\tif (!sc->force_wow) {\n\t\tsc->force_wow = true;\n\t\tath9k_init_wow(sc->hw);\n\t}\n\n\treturn count;\n}\n\nstatic const struct file_operations fops_wow = {\n\t.read = read_file_wow,\n\t.write = write_file_wow,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\n#endif\n\nstatic ssize_t read_file_tpc(struct file *file, char __user *user_buf,\n\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct ath_softc *sc = file->private_data;\n\tstruct ath_hw *ah = sc->sc_ah;\n\tunsigned int len = 0, size = 32;\n\tssize_t retval;\n\tchar *buf;\n\n\tbuf = kzalloc(size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tlen += scnprintf(buf + len, size - len, \"%s\\n\",\n\t\t\t ah->tpc_enabled ? \"ENABLED\" : \"DISABLED\");\n\n\tif (len > size)\n\t\tlen = size;\n\n\tretval = simple_read_from_buffer(user_buf, count, ppos, buf, len);\n\tkfree(buf);\n\n\treturn retval;\n}\n\nstatic ssize_t write_file_tpc(struct file *file, const char __user *user_buf,\n\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct ath_softc *sc = file->private_data;\n\tstruct ath_hw *ah = sc->sc_ah;\n\tunsigned long val;\n\tssize_t ret;\n\tbool tpc_enabled;\n\n\tret = kstrtoul_from_user(user_buf, count, 0, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val > 1)\n\t\treturn -EINVAL;\n\n\ttpc_enabled = !!val;\n\n\tif (tpc_enabled != ah->tpc_enabled) {\n\t\tah->tpc_enabled = tpc_enabled;\n\n\t\tmutex_lock(&sc->mutex);\n\t\tath9k_set_txpower(sc, NULL);\n\t\tmutex_unlock(&sc->mutex);\n\t}\n\n\treturn count;\n}\n\nstatic const struct file_operations fops_tpc = {\n\t.read = read_file_tpc,\n\t.write = write_file_tpc,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t read_file_nf_override(struct file *file,\n\t\t\t\t     char __user *user_buf,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct ath_softc *sc = file->private_data;\n\tstruct ath_hw *ah = sc->sc_ah;\n\tchar buf[32];\n\tunsigned int len;\n\n\tif (ah->nf_override == 0)\n\t\tlen = sprintf(buf, \"off\\n\");\n\telse\n\t\tlen = sprintf(buf, \"%d\\n\", ah->nf_override);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic ssize_t write_file_nf_override(struct file *file,\n\t\t\t\t      const char __user *user_buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct ath_softc *sc = file->private_data;\n\tstruct ath_hw *ah = sc->sc_ah;\n\tlong val;\n\tchar buf[32];\n\tssize_t len;\n\n\tlen = min(count, sizeof(buf) - 1);\n\tif (copy_from_user(buf, user_buf, len))\n\t\treturn -EFAULT;\n\n\tbuf[len] = '\\0';\n\tif (strncmp(\"off\", buf, 3) == 0)\n\t\tval = 0;\n\telse if (kstrtol(buf, 0, &val))\n\t\treturn -EINVAL;\n\n\tif (val > 0)\n\t\treturn -EINVAL;\n\n\tif (val < -120)\n\t\treturn -EINVAL;\n\n\tah->nf_override = val;\n\n\tif (ah->curchan) {\n\t\tath9k_ps_wakeup(sc);\n\t\tath9k_hw_loadnf(ah, ah->curchan);\n\t\tath9k_ps_restore(sc);\n\t}\n\n\treturn count;\n}\n\nstatic const struct file_operations fops_nf_override = {\n\t.read = read_file_nf_override,\n\t.write = write_file_nf_override,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\n \n\n#define AMKSTR(nm) #nm \"_BE\", #nm \"_BK\", #nm \"_VI\", #nm \"_VO\"\nstatic const char ath9k_gstrings_stats[][ETH_GSTRING_LEN] = {\n\t\"tx_pkts_nic\",\n\t\"tx_bytes_nic\",\n\t\"rx_pkts_nic\",\n\t\"rx_bytes_nic\",\n\tAMKSTR(d_tx_pkts),\n\tAMKSTR(d_tx_bytes),\n\tAMKSTR(d_tx_mpdus_queued),\n\tAMKSTR(d_tx_mpdus_completed),\n\tAMKSTR(d_tx_mpdu_xretries),\n\tAMKSTR(d_tx_aggregates),\n\tAMKSTR(d_tx_ampdus_queued_hw),\n\tAMKSTR(d_tx_ampdus_completed),\n\tAMKSTR(d_tx_ampdu_retries),\n\tAMKSTR(d_tx_ampdu_xretries),\n\tAMKSTR(d_tx_fifo_underrun),\n\tAMKSTR(d_tx_op_exceeded),\n\tAMKSTR(d_tx_timer_expiry),\n\tAMKSTR(d_tx_desc_cfg_err),\n\tAMKSTR(d_tx_data_underrun),\n\tAMKSTR(d_tx_delim_underrun),\n\t\"d_rx_crc_err\",\n\t\"d_rx_decrypt_crc_err\",\n\t\"d_rx_phy_err\",\n\t\"d_rx_mic_err\",\n\t\"d_rx_pre_delim_crc_err\",\n\t\"d_rx_post_delim_crc_err\",\n\t\"d_rx_decrypt_busy_err\",\n\n\t\"d_rx_phyerr_radar\",\n\t\"d_rx_phyerr_ofdm_timing\",\n\t\"d_rx_phyerr_cck_timing\",\n\n};\n#define ATH9K_SSTATS_LEN ARRAY_SIZE(ath9k_gstrings_stats)\n\nvoid ath9k_get_et_strings(struct ieee80211_hw *hw,\n\t\t\t  struct ieee80211_vif *vif,\n\t\t\t  u32 sset, u8 *data)\n{\n\tif (sset == ETH_SS_STATS)\n\t\tmemcpy(data, ath9k_gstrings_stats,\n\t\t       sizeof(ath9k_gstrings_stats));\n}\n\nint ath9k_get_et_sset_count(struct ieee80211_hw *hw,\n\t\t\t    struct ieee80211_vif *vif, int sset)\n{\n\tif (sset == ETH_SS_STATS)\n\t\treturn ATH9K_SSTATS_LEN;\n\treturn 0;\n}\n\n#define AWDATA(elem)\t\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tdata[i++] = sc->debug.stats.txstats[PR_QNUM(IEEE80211_AC_BE)].elem; \\\n\t\tdata[i++] = sc->debug.stats.txstats[PR_QNUM(IEEE80211_AC_BK)].elem; \\\n\t\tdata[i++] = sc->debug.stats.txstats[PR_QNUM(IEEE80211_AC_VI)].elem; \\\n\t\tdata[i++] = sc->debug.stats.txstats[PR_QNUM(IEEE80211_AC_VO)].elem; \\\n\t} while (0)\n\n#define AWDATA_RX(elem)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tdata[i++] = sc->debug.stats.rxstats.elem;\t\\\n\t} while (0)\n\nvoid ath9k_get_et_stats(struct ieee80211_hw *hw,\n\t\t\tstruct ieee80211_vif *vif,\n\t\t\tstruct ethtool_stats *stats, u64 *data)\n{\n\tstruct ath_softc *sc = hw->priv;\n\tint i = 0;\n\n\tdata[i++] = (sc->debug.stats.txstats[PR_QNUM(IEEE80211_AC_BE)].tx_pkts_all +\n\t\t     sc->debug.stats.txstats[PR_QNUM(IEEE80211_AC_BK)].tx_pkts_all +\n\t\t     sc->debug.stats.txstats[PR_QNUM(IEEE80211_AC_VI)].tx_pkts_all +\n\t\t     sc->debug.stats.txstats[PR_QNUM(IEEE80211_AC_VO)].tx_pkts_all);\n\tdata[i++] = (sc->debug.stats.txstats[PR_QNUM(IEEE80211_AC_BE)].tx_bytes_all +\n\t\t     sc->debug.stats.txstats[PR_QNUM(IEEE80211_AC_BK)].tx_bytes_all +\n\t\t     sc->debug.stats.txstats[PR_QNUM(IEEE80211_AC_VI)].tx_bytes_all +\n\t\t     sc->debug.stats.txstats[PR_QNUM(IEEE80211_AC_VO)].tx_bytes_all);\n\tAWDATA_RX(rx_pkts_all);\n\tAWDATA_RX(rx_bytes_all);\n\n\tAWDATA(tx_pkts_all);\n\tAWDATA(tx_bytes_all);\n\tAWDATA(queued);\n\tAWDATA(completed);\n\tAWDATA(xretries);\n\tAWDATA(a_aggr);\n\tAWDATA(a_queued_hw);\n\tAWDATA(a_completed);\n\tAWDATA(a_retries);\n\tAWDATA(a_xretries);\n\tAWDATA(fifo_underrun);\n\tAWDATA(xtxop);\n\tAWDATA(timer_exp);\n\tAWDATA(desc_cfg_err);\n\tAWDATA(data_underrun);\n\tAWDATA(delim_underrun);\n\n\tAWDATA_RX(crc_err);\n\tAWDATA_RX(decrypt_crc_err);\n\tAWDATA_RX(phy_err);\n\tAWDATA_RX(mic_err);\n\tAWDATA_RX(pre_delim_crc_err);\n\tAWDATA_RX(post_delim_crc_err);\n\tAWDATA_RX(decrypt_busy_err);\n\n\tAWDATA_RX(phy_err_stats[ATH9K_PHYERR_RADAR]);\n\tAWDATA_RX(phy_err_stats[ATH9K_PHYERR_OFDM_TIMING]);\n\tAWDATA_RX(phy_err_stats[ATH9K_PHYERR_CCK_TIMING]);\n\n\tWARN_ON(i != ATH9K_SSTATS_LEN);\n}\n\nvoid ath9k_deinit_debug(struct ath_softc *sc)\n{\n\tath9k_cmn_spectral_deinit_debug(&sc->spec_priv);\n}\n\nint ath9k_init_debug(struct ath_hw *ah)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath_softc *sc = (struct ath_softc *) common->priv;\n\n\tsc->debug.debugfs_phy = debugfs_create_dir(\"ath9k\",\n\t\t\t\t\t\t   sc->hw->wiphy->debugfsdir);\n\tif (IS_ERR(sc->debug.debugfs_phy))\n\t\treturn -ENOMEM;\n\n#ifdef CONFIG_ATH_DEBUG\n\tdebugfs_create_file(\"debug\", 0600, sc->debug.debugfs_phy,\n\t\t\t    sc, &fops_debug);\n#endif\n\n\tath9k_dfs_init_debug(sc);\n\tath9k_tx99_init_debug(sc);\n\tath9k_cmn_spectral_init_debug(&sc->spec_priv, sc->debug.debugfs_phy);\n\n\tdebugfs_create_devm_seqfile(sc->dev, \"dma\", sc->debug.debugfs_phy,\n\t\t\t\t    read_file_dma);\n\tdebugfs_create_devm_seqfile(sc->dev, \"interrupt\", sc->debug.debugfs_phy,\n\t\t\t\t    read_file_interrupt);\n\tdebugfs_create_devm_seqfile(sc->dev, \"xmit\", sc->debug.debugfs_phy,\n\t\t\t\t    read_file_xmit);\n\tdebugfs_create_devm_seqfile(sc->dev, \"queues\", sc->debug.debugfs_phy,\n\t\t\t\t    read_file_queues);\n\tdebugfs_create_devm_seqfile(sc->dev, \"misc\", sc->debug.debugfs_phy,\n\t\t\t\t    read_file_misc);\n\tdebugfs_create_file(\"reset\", 0600, sc->debug.debugfs_phy,\n\t\t\t    sc, &fops_reset);\n\n\tath9k_cmn_debug_recv(sc->debug.debugfs_phy, &sc->debug.stats.rxstats);\n\tath9k_cmn_debug_phy_err(sc->debug.debugfs_phy, &sc->debug.stats.rxstats);\n\n\tdebugfs_create_u8(\"rx_chainmask\", 0400, sc->debug.debugfs_phy,\n\t\t\t  &ah->rxchainmask);\n\tdebugfs_create_u8(\"tx_chainmask\", 0400, sc->debug.debugfs_phy,\n\t\t\t  &ah->txchainmask);\n\tdebugfs_create_file(\"ani\", 0600,\n\t\t\t    sc->debug.debugfs_phy, sc, &fops_ani);\n\tdebugfs_create_bool(\"paprd\", 0600, sc->debug.debugfs_phy,\n\t\t\t    &sc->sc_ah->config.enable_paprd);\n\tdebugfs_create_file(\"regidx\", 0600, sc->debug.debugfs_phy,\n\t\t\t    sc, &fops_regidx);\n\tdebugfs_create_file(\"regval\", 0600, sc->debug.debugfs_phy,\n\t\t\t    sc, &fops_regval);\n\tdebugfs_create_bool(\"ignore_extcca\", 0600,\n\t\t\t    sc->debug.debugfs_phy,\n\t\t\t    &ah->config.cwm_ignore_extcca);\n\tdebugfs_create_file(\"regdump\", 0400, sc->debug.debugfs_phy, sc,\n\t\t\t    &fops_regdump);\n\tdebugfs_create_devm_seqfile(sc->dev, \"dump_nfcal\",\n\t\t\t\t    sc->debug.debugfs_phy,\n\t\t\t\t    read_file_dump_nfcal);\n\n\tath9k_cmn_debug_base_eeprom(sc->debug.debugfs_phy, sc->sc_ah);\n\tath9k_cmn_debug_modal_eeprom(sc->debug.debugfs_phy, sc->sc_ah);\n\n\tdebugfs_create_u32(\"gpio_mask\", 0600,\n\t\t\t   sc->debug.debugfs_phy, &sc->sc_ah->gpio_mask);\n\tdebugfs_create_u32(\"gpio_val\", 0600,\n\t\t\t   sc->debug.debugfs_phy, &sc->sc_ah->gpio_val);\n\tdebugfs_create_file(\"antenna_diversity\", 0400,\n\t\t\t    sc->debug.debugfs_phy, sc, &fops_antenna_diversity);\n#ifdef CONFIG_ATH9K_BTCOEX_SUPPORT\n\tdebugfs_create_file(\"bt_ant_diversity\", 0600,\n\t\t\t    sc->debug.debugfs_phy, sc, &fops_bt_ant_diversity);\n\tdebugfs_create_file(\"btcoex\", 0400, sc->debug.debugfs_phy, sc,\n\t\t\t    &fops_btcoex);\n#endif\n\n#ifdef CONFIG_ATH9K_WOW\n\tdebugfs_create_file(\"wow\", 0600, sc->debug.debugfs_phy, sc, &fops_wow);\n#endif\n\n#ifdef CONFIG_ATH9K_DYNACK\n\tdebugfs_create_file(\"ack_to\", 0400, sc->debug.debugfs_phy,\n\t\t\t    sc, &fops_ackto);\n#endif\n\tdebugfs_create_file(\"tpc\", 0600, sc->debug.debugfs_phy, sc, &fops_tpc);\n\n\tdebugfs_create_file(\"nf_override\", 0600,\n\t\t\t    sc->debug.debugfs_phy, sc, &fops_nf_override);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}