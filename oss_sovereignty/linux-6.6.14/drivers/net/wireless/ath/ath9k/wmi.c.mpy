{
  "module_name": "wmi.c",
  "hash_id": "2a2394b552dd0f576fedb9596d14ec3b0aa0f75ba03b7d8e7201518998781cfd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath9k/wmi.c",
  "human_readable_source": " \n\n#include \"htc.h\"\n\nstatic const char *wmi_cmd_to_name(enum wmi_cmd_id wmi_cmd)\n{\n\tswitch (wmi_cmd) {\n\tcase WMI_ECHO_CMDID:\n\t\treturn \"WMI_ECHO_CMDID\";\n\tcase WMI_ACCESS_MEMORY_CMDID:\n\t\treturn \"WMI_ACCESS_MEMORY_CMDID\";\n\tcase WMI_GET_FW_VERSION:\n\t\treturn \"WMI_GET_FW_VERSION\";\n\tcase WMI_DISABLE_INTR_CMDID:\n\t\treturn \"WMI_DISABLE_INTR_CMDID\";\n\tcase WMI_ENABLE_INTR_CMDID:\n\t\treturn \"WMI_ENABLE_INTR_CMDID\";\n\tcase WMI_ATH_INIT_CMDID:\n\t\treturn \"WMI_ATH_INIT_CMDID\";\n\tcase WMI_ABORT_TXQ_CMDID:\n\t\treturn \"WMI_ABORT_TXQ_CMDID\";\n\tcase WMI_STOP_TX_DMA_CMDID:\n\t\treturn \"WMI_STOP_TX_DMA_CMDID\";\n\tcase WMI_ABORT_TX_DMA_CMDID:\n\t\treturn \"WMI_ABORT_TX_DMA_CMDID\";\n\tcase WMI_DRAIN_TXQ_CMDID:\n\t\treturn \"WMI_DRAIN_TXQ_CMDID\";\n\tcase WMI_DRAIN_TXQ_ALL_CMDID:\n\t\treturn \"WMI_DRAIN_TXQ_ALL_CMDID\";\n\tcase WMI_START_RECV_CMDID:\n\t\treturn \"WMI_START_RECV_CMDID\";\n\tcase WMI_STOP_RECV_CMDID:\n\t\treturn \"WMI_STOP_RECV_CMDID\";\n\tcase WMI_FLUSH_RECV_CMDID:\n\t\treturn \"WMI_FLUSH_RECV_CMDID\";\n\tcase WMI_SET_MODE_CMDID:\n\t\treturn \"WMI_SET_MODE_CMDID\";\n\tcase WMI_NODE_CREATE_CMDID:\n\t\treturn \"WMI_NODE_CREATE_CMDID\";\n\tcase WMI_NODE_REMOVE_CMDID:\n\t\treturn \"WMI_NODE_REMOVE_CMDID\";\n\tcase WMI_VAP_REMOVE_CMDID:\n\t\treturn \"WMI_VAP_REMOVE_CMDID\";\n\tcase WMI_VAP_CREATE_CMDID:\n\t\treturn \"WMI_VAP_CREATE_CMDID\";\n\tcase WMI_REG_READ_CMDID:\n\t\treturn \"WMI_REG_READ_CMDID\";\n\tcase WMI_REG_WRITE_CMDID:\n\t\treturn \"WMI_REG_WRITE_CMDID\";\n\tcase WMI_REG_RMW_CMDID:\n\t\treturn \"WMI_REG_RMW_CMDID\";\n\tcase WMI_RC_STATE_CHANGE_CMDID:\n\t\treturn \"WMI_RC_STATE_CHANGE_CMDID\";\n\tcase WMI_RC_RATE_UPDATE_CMDID:\n\t\treturn \"WMI_RC_RATE_UPDATE_CMDID\";\n\tcase WMI_TARGET_IC_UPDATE_CMDID:\n\t\treturn \"WMI_TARGET_IC_UPDATE_CMDID\";\n\tcase WMI_TX_AGGR_ENABLE_CMDID:\n\t\treturn \"WMI_TX_AGGR_ENABLE_CMDID\";\n\tcase WMI_TGT_DETACH_CMDID:\n\t\treturn \"WMI_TGT_DETACH_CMDID\";\n\tcase WMI_NODE_UPDATE_CMDID:\n\t\treturn \"WMI_NODE_UPDATE_CMDID\";\n\tcase WMI_INT_STATS_CMDID:\n\t\treturn \"WMI_INT_STATS_CMDID\";\n\tcase WMI_TX_STATS_CMDID:\n\t\treturn \"WMI_TX_STATS_CMDID\";\n\tcase WMI_RX_STATS_CMDID:\n\t\treturn \"WMI_RX_STATS_CMDID\";\n\tcase WMI_BITRATE_MASK_CMDID:\n\t\treturn \"WMI_BITRATE_MASK_CMDID\";\n\t}\n\n\treturn \"Bogus\";\n}\n\nstruct wmi *ath9k_init_wmi(struct ath9k_htc_priv *priv)\n{\n\tstruct wmi *wmi;\n\n\twmi = kzalloc(sizeof(struct wmi), GFP_KERNEL);\n\tif (!wmi)\n\t\treturn NULL;\n\n\twmi->drv_priv = priv;\n\twmi->stopped = false;\n\tskb_queue_head_init(&wmi->wmi_event_queue);\n\tspin_lock_init(&wmi->wmi_lock);\n\tspin_lock_init(&wmi->event_lock);\n\tmutex_init(&wmi->op_mutex);\n\tmutex_init(&wmi->multi_write_mutex);\n\tmutex_init(&wmi->multi_rmw_mutex);\n\tinit_completion(&wmi->cmd_wait);\n\tINIT_LIST_HEAD(&wmi->pending_tx_events);\n\ttasklet_setup(&wmi->wmi_event_tasklet, ath9k_wmi_event_tasklet);\n\n\treturn wmi;\n}\n\nvoid ath9k_stop_wmi(struct ath9k_htc_priv *priv)\n{\n\tstruct wmi *wmi = priv->wmi;\n\n\tmutex_lock(&wmi->op_mutex);\n\twmi->stopped = true;\n\tmutex_unlock(&wmi->op_mutex);\n}\n\nvoid ath9k_destroy_wmi(struct ath9k_htc_priv *priv)\n{\n\tkfree(priv->wmi);\n}\n\nvoid ath9k_wmi_event_drain(struct ath9k_htc_priv *priv)\n{\n\tunsigned long flags;\n\n\ttasklet_kill(&priv->wmi->wmi_event_tasklet);\n\tspin_lock_irqsave(&priv->wmi->wmi_lock, flags);\n\t__skb_queue_purge(&priv->wmi->wmi_event_queue);\n\tspin_unlock_irqrestore(&priv->wmi->wmi_lock, flags);\n}\n\nvoid ath9k_wmi_event_tasklet(struct tasklet_struct *t)\n{\n\tstruct wmi *wmi = from_tasklet(wmi, t, wmi_event_tasklet);\n\tstruct ath9k_htc_priv *priv = wmi->drv_priv;\n\tstruct wmi_cmd_hdr *hdr;\n\tvoid *wmi_event;\n\tstruct wmi_event_swba *swba;\n\tstruct sk_buff *skb = NULL;\n\tunsigned long flags;\n\tu16 cmd_id;\n\n\tdo {\n\t\tspin_lock_irqsave(&wmi->wmi_lock, flags);\n\t\tskb = __skb_dequeue(&wmi->wmi_event_queue);\n\t\tif (!skb) {\n\t\t\tspin_unlock_irqrestore(&wmi->wmi_lock, flags);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock_irqrestore(&wmi->wmi_lock, flags);\n\n\t\thdr = (struct wmi_cmd_hdr *) skb->data;\n\t\tcmd_id = be16_to_cpu(hdr->command_id);\n\t\twmi_event = skb_pull(skb, sizeof(struct wmi_cmd_hdr));\n\n\t\tswitch (cmd_id) {\n\t\tcase WMI_SWBA_EVENTID:\n\t\t\tswba = wmi_event;\n\t\t\tath9k_htc_swba(priv, swba);\n\t\t\tbreak;\n\t\tcase WMI_FATAL_EVENTID:\n\t\t\tieee80211_queue_work(wmi->drv_priv->hw,\n\t\t\t\t\t     &wmi->drv_priv->fatal_work);\n\t\t\tbreak;\n\t\tcase WMI_TXSTATUS_EVENTID:\n\t\t\t \n\t\t\tif (!data_race(priv->tx.initialized))\n\t\t\t\tbreak;\n\n\t\t\tspin_lock_bh(&priv->tx.tx_lock);\n\t\t\tif (priv->tx.flags & ATH9K_HTC_OP_TX_DRAIN) {\n\t\t\t\tspin_unlock_bh(&priv->tx.tx_lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tspin_unlock_bh(&priv->tx.tx_lock);\n\n\t\t\tath9k_htc_txstatus(priv, wmi_event);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tkfree_skb(skb);\n\t} while (1);\n}\n\nvoid ath9k_fatal_work(struct work_struct *work)\n{\n\tstruct ath9k_htc_priv *priv = container_of(work, struct ath9k_htc_priv,\n\t\t\t\t\t\t   fatal_work);\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\n\tath_dbg(common, FATAL, \"FATAL Event received, resetting device\\n\");\n\tath9k_htc_reset(priv);\n}\n\nstatic void ath9k_wmi_rsp_callback(struct wmi *wmi, struct sk_buff *skb)\n{\n\tskb_pull(skb, sizeof(struct wmi_cmd_hdr));\n\n\tif (wmi->cmd_rsp_buf != NULL && wmi->cmd_rsp_len != 0)\n\t\tmemcpy(wmi->cmd_rsp_buf, skb->data, wmi->cmd_rsp_len);\n\n\tcomplete(&wmi->cmd_wait);\n}\n\nstatic void ath9k_wmi_ctrl_rx(void *priv, struct sk_buff *skb,\n\t\t\t      enum htc_endpoint_id epid)\n{\n\tstruct wmi *wmi = priv;\n\tstruct wmi_cmd_hdr *hdr;\n\tunsigned long flags;\n\tu16 cmd_id;\n\n\tif (unlikely(wmi->stopped))\n\t\tgoto free_skb;\n\n\t \n\tif (unlikely(skb->len < sizeof(struct wmi_cmd_hdr)))\n\t\tgoto free_skb;\n\n\thdr = (struct wmi_cmd_hdr *) skb->data;\n\tcmd_id = be16_to_cpu(hdr->command_id);\n\n\tif (cmd_id & 0x1000) {\n\t\tspin_lock_irqsave(&wmi->wmi_lock, flags);\n\t\t__skb_queue_tail(&wmi->wmi_event_queue, skb);\n\t\tspin_unlock_irqrestore(&wmi->wmi_lock, flags);\n\t\ttasklet_schedule(&wmi->wmi_event_tasklet);\n\t\treturn;\n\t}\n\n\t \n\tspin_lock_irqsave(&wmi->wmi_lock, flags);\n\tif (be16_to_cpu(hdr->seq_no) != wmi->last_seq_id) {\n\t\tspin_unlock_irqrestore(&wmi->wmi_lock, flags);\n\t\tgoto free_skb;\n\t}\n\n\t \n\tath9k_wmi_rsp_callback(wmi, skb);\n\tspin_unlock_irqrestore(&wmi->wmi_lock, flags);\n\nfree_skb:\n\tkfree_skb(skb);\n}\n\nstatic void ath9k_wmi_ctrl_tx(void *priv, struct sk_buff *skb,\n\t\t\t      enum htc_endpoint_id epid, bool txok)\n{\n\tkfree_skb(skb);\n}\n\nint ath9k_wmi_connect(struct htc_target *htc, struct wmi *wmi,\n\t\t      enum htc_endpoint_id *wmi_ctrl_epid)\n{\n\tstruct htc_service_connreq connect;\n\tint ret;\n\n\twmi->htc = htc;\n\n\tmemset(&connect, 0, sizeof(connect));\n\n\tconnect.ep_callbacks.priv = wmi;\n\tconnect.ep_callbacks.tx = ath9k_wmi_ctrl_tx;\n\tconnect.ep_callbacks.rx = ath9k_wmi_ctrl_rx;\n\tconnect.service_id = WMI_CONTROL_SVC;\n\n\tret = htc_connect_service(htc, &connect, &wmi->ctrl_epid);\n\tif (ret)\n\t\treturn ret;\n\n\t*wmi_ctrl_epid = wmi->ctrl_epid;\n\n\treturn 0;\n}\n\nstatic int ath9k_wmi_cmd_issue(struct wmi *wmi,\n\t\t\t       struct sk_buff *skb,\n\t\t\t       enum wmi_cmd_id cmd, u16 len,\n\t\t\t       u8 *rsp_buf, u32 rsp_len)\n{\n\tstruct wmi_cmd_hdr *hdr;\n\tunsigned long flags;\n\n\thdr = skb_push(skb, sizeof(struct wmi_cmd_hdr));\n\thdr->command_id = cpu_to_be16(cmd);\n\thdr->seq_no = cpu_to_be16(++wmi->tx_seq_id);\n\n\tspin_lock_irqsave(&wmi->wmi_lock, flags);\n\n\t \n\twmi->cmd_rsp_buf = rsp_buf;\n\twmi->cmd_rsp_len = rsp_len;\n\n\twmi->last_seq_id = wmi->tx_seq_id;\n\tspin_unlock_irqrestore(&wmi->wmi_lock, flags);\n\n\treturn htc_send_epid(wmi->htc, skb, wmi->ctrl_epid);\n}\n\nint ath9k_wmi_cmd(struct wmi *wmi, enum wmi_cmd_id cmd_id,\n\t\t  u8 *cmd_buf, u32 cmd_len,\n\t\t  u8 *rsp_buf, u32 rsp_len,\n\t\t  u32 timeout)\n{\n\tstruct ath_hw *ah = wmi->drv_priv->ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tu16 headroom = sizeof(struct htc_frame_hdr) +\n\t\t       sizeof(struct wmi_cmd_hdr);\n\tunsigned long time_left, flags;\n\tstruct sk_buff *skb;\n\tint ret = 0;\n\n\tif (ah->ah_flags & AH_UNPLUGGED)\n\t\treturn 0;\n\n\tskb = alloc_skb(headroom + cmd_len, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_reserve(skb, headroom);\n\n\tif (cmd_len != 0 && cmd_buf != NULL) {\n\t\tskb_put_data(skb, cmd_buf, cmd_len);\n\t}\n\n\tmutex_lock(&wmi->op_mutex);\n\n\t \n\tif (unlikely(wmi->stopped)) {\n\t\tret = -EPROTO;\n\t\tgoto out;\n\t}\n\n\tret = ath9k_wmi_cmd_issue(wmi, skb, cmd_id, cmd_len, rsp_buf, rsp_len);\n\tif (ret)\n\t\tgoto out;\n\n\ttime_left = wait_for_completion_timeout(&wmi->cmd_wait, timeout);\n\tif (!time_left) {\n\t\tath_dbg(common, WMI, \"Timeout waiting for WMI command: %s\\n\",\n\t\t\twmi_cmd_to_name(cmd_id));\n\t\tspin_lock_irqsave(&wmi->wmi_lock, flags);\n\t\twmi->last_seq_id = 0;\n\t\tspin_unlock_irqrestore(&wmi->wmi_lock, flags);\n\t\tmutex_unlock(&wmi->op_mutex);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tmutex_unlock(&wmi->op_mutex);\n\n\treturn 0;\n\nout:\n\tath_dbg(common, WMI, \"WMI failure for: %s\\n\", wmi_cmd_to_name(cmd_id));\n\tmutex_unlock(&wmi->op_mutex);\n\tkfree_skb(skb);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}