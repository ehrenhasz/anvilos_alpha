{
  "module_name": "ath9k.h",
  "hash_id": "5c8e560323a8e909a40710e49c135828e1124c634bb1414929486a3e1dc37f55",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath9k/ath9k.h",
  "human_readable_source": " \n\n#ifndef ATH9K_H\n#define ATH9K_H\n\n#include <linux/etherdevice.h>\n#include <linux/device.h>\n#include <linux/interrupt.h>\n#include <linux/kstrtox.h>\n#include <linux/leds.h>\n#include <linux/completion.h>\n#include <linux/time.h>\n#include <linux/hw_random.h>\n\n#include \"common.h\"\n#include \"debug.h\"\n#include \"mci.h\"\n#include \"dfs.h\"\n\nstruct ath_node;\nstruct ath_vif;\n\nextern struct ieee80211_ops ath9k_ops;\nextern int ath9k_modparam_nohwcrypt;\nextern int ath9k_led_blink;\nextern bool is_ath9k_unloaded;\nextern int ath9k_use_chanctx;\n\n \n \n \n\n#define ATH_TXSTATUS_RING_SIZE 512\n\n \n#define\tito64(x) (sizeof(x) == 1) ?\t\t\t\\\n\t(((unsigned long long int)(x)) & (0xff)) :\t\\\n\t(sizeof(x) == 2) ?\t\t\t\t\\\n\t(((unsigned long long int)(x)) & 0xffff) :\t\\\n\t((sizeof(x) == 4) ?\t\t\t\t\\\n\t (((unsigned long long int)(x)) & 0xffffffff) : \\\n\t (unsigned long long int)(x))\n\n#define ATH_TXBUF_RESET(_bf) do {\t\t\t\t\\\n\t\t(_bf)->bf_lastbf = NULL;\t\t\t\\\n\t\t(_bf)->bf_next = NULL;\t\t\t\t\\\n\t\tmemset(&((_bf)->bf_state), 0,\t\t\t\\\n\t\t       sizeof(struct ath_buf_state));\t\t\\\n\t} while (0)\n\n#define\tDS2PHYS(_dd, _ds)\t\t\t\t\t\t\\\n\t((_dd)->dd_desc_paddr + ((caddr_t)(_ds) - (caddr_t)(_dd)->dd_desc))\n#define ATH_DESC_4KB_BOUND_CHECK(_daddr) ((((_daddr) & 0xFFF) > 0xF7F) ? 1 : 0)\n#define ATH_DESC_4KB_BOUND_NUM_SKIPPED(_len) ((_len) / 4096)\n\nstruct ath_descdma {\n\tvoid *dd_desc;\n\tdma_addr_t dd_desc_paddr;\n\tu32 dd_desc_len;\n};\n\nint ath_descdma_setup(struct ath_softc *sc, struct ath_descdma *dd,\n\t\t      struct list_head *head, const char *name,\n\t\t      int nbuf, int ndesc, bool is_tx);\n\n \n \n \n\n#define\tATH_TXQ_SETUP(sc, i) ((sc)->tx.txqsetup & (1<<i))\n\n \n#define INCR(_l, _sz)   do {\t\t\t\\\n\t\t(_l)++;\t\t\t\t\\\n\t\t(_l) &= ((_sz) - 1);\t\t\\\n\t} while (0)\n\n#define ATH_RXBUF               512\n#define ATH_TXBUF               512\n#define ATH_TXBUF_RESERVE       5\n#define ATH_TXMAXTRY            13\n#define ATH_MAX_SW_RETRIES      30\n\n#define TID_TO_WME_AC(_tid)\t\t\t\t\\\n\t((((_tid) == 0) || ((_tid) == 3)) ? IEEE80211_AC_BE :\t\\\n\t (((_tid) == 1) || ((_tid) == 2)) ? IEEE80211_AC_BK :\t\\\n\t (((_tid) == 4) || ((_tid) == 5)) ? IEEE80211_AC_VI :\t\\\n\t IEEE80211_AC_VO)\n\n#define ATH_AGGR_DELIM_SZ          4\n#define ATH_AGGR_MINPLEN           256  \n \n#define ATH_AGGR_ENCRYPTDELIM      10\n \n#define ATH_AGGR_MIN_QDEPTH        2\n \n#define ATH_NON_AGGR_MIN_QDEPTH    8\n#define ATH_HW_CHECK_POLL_INT      1000\n#define ATH_TXFIFO_DEPTH           8\n#define ATH_TX_ERROR               0x01\n\n \n#define ATH_P2P_PS_STOP_TIME       1000\n\n#define IEEE80211_SEQ_SEQ_SHIFT    4\n#define IEEE80211_SEQ_MAX          4096\n#define IEEE80211_WEP_IVLEN        3\n#define IEEE80211_WEP_KIDLEN       1\n#define IEEE80211_WEP_CRCLEN       4\n#define IEEE80211_MAX_MPDU_LEN     (3840 + FCS_LEN +\t\t\\\n\t\t\t\t    (IEEE80211_WEP_IVLEN +\t\\\n\t\t\t\t     IEEE80211_WEP_KIDLEN +\t\\\n\t\t\t\t     IEEE80211_WEP_CRCLEN))\n\n \n#define ATH_BA_ISSET(_bm, _n)  (((_n) < (WME_BA_BMP_SIZE)) &&\t\t\\\n\t\t\t\t((_bm)[(_n) >> 5] & (1 << ((_n) & 31))))\n\n \n#define ATH_BA_INDEX(_st, _seq) (((_seq) - (_st)) & (IEEE80211_SEQ_MAX - 1))\n\n \n#define ATH_BA_INDEX2SEQ(_seq, _offset) (((_seq) + (_offset)) & (IEEE80211_SEQ_MAX - 1))\n\n \n#define ATH_AGGR_GET_NDELIM(_len)\t\t\t\t\t\\\n       (((_len) >= ATH_AGGR_MINPLEN) ? 0 :                             \\\n        DIV_ROUND_UP(ATH_AGGR_MINPLEN - (_len), ATH_AGGR_DELIM_SZ))\n\n#define BAW_WITHIN(_start, _bawsz, _seqno) \\\n\t((((_seqno) - (_start)) & 4095) < (_bawsz))\n\n#define ATH_AN_2_TID(_an, _tidno) ath_node_to_tid(_an, _tidno)\n\n#define IS_HT_RATE(rate)   (rate & 0x80)\n#define IS_CCK_RATE(rate)  ((rate >= 0x18) && (rate <= 0x1e))\n#define IS_OFDM_RATE(rate) ((rate >= 0x8) && (rate <= 0xf))\n\nenum {\n       WLAN_RC_PHY_OFDM,\n       WLAN_RC_PHY_CCK,\n};\n\nstruct ath_txq {\n\tint mac80211_qnum;  \n\tu32 axq_qnum;  \n\tvoid *axq_link;\n\tstruct list_head axq_q;\n\tspinlock_t axq_lock;\n\tu32 axq_depth;\n\tu32 axq_ampdu_depth;\n\tbool axq_tx_inprogress;\n\tstruct list_head txq_fifo[ATH_TXFIFO_DEPTH];\n\tu8 txq_headidx;\n\tu8 txq_tailidx;\n\tint pending_frames;\n\tstruct sk_buff_head complete_q;\n};\n\nstruct ath_frame_info {\n\tstruct ath_buf *bf;\n\tu16 framelen;\n\ts8 txq;\n\tu8 keyix;\n\tu8 rtscts_rate;\n\tu8 retries : 6;\n\tu8 dyn_smps : 1;\n\tu8 baw_tracked : 1;\n\tu8 tx_power;\n\tenum ath9k_key_type keytype:2;\n};\n\nstruct ath_rxbuf {\n\tstruct list_head list;\n\tstruct sk_buff *bf_mpdu;\n\tvoid *bf_desc;\n\tdma_addr_t bf_daddr;\n\tdma_addr_t bf_buf_addr;\n};\n\n \nenum buffer_type {\n\tBUF_AMPDU\t\t= BIT(0),\n\tBUF_AGGR\t\t= BIT(1),\n};\n\n#define bf_isampdu(bf)\t\t(bf->bf_state.bf_type & BUF_AMPDU)\n#define bf_isaggr(bf)\t\t(bf->bf_state.bf_type & BUF_AGGR)\n\nstruct ath_buf_state {\n\tu8 bf_type;\n\tu8 bfs_paprd;\n\tu8 ndelim;\n\tbool stale;\n\tu16 seqno;\n\tunsigned long bfs_paprd_timestamp;\n};\n\nstruct ath_buf {\n\tstruct list_head list;\n\tstruct ath_buf *bf_lastbf;\t \n\tstruct ath_buf *bf_next;\t \n\tstruct sk_buff *bf_mpdu;\t \n\tvoid *bf_desc;\t\t\t \n\tdma_addr_t bf_daddr;\t\t \n\tdma_addr_t bf_buf_addr;\t \n\tstruct ieee80211_tx_rate rates[4];\n\tstruct ath_buf_state bf_state;\n};\n\nstruct ath_atx_tid {\n\tstruct list_head list;\n\tstruct sk_buff_head retry_q;\n\tstruct ath_node *an;\n\tstruct ath_txq *txq;\n\tunsigned long tx_buf[BITS_TO_LONGS(ATH_TID_MAX_BUFS)];\n\tu16 seq_start;\n\tu16 seq_next;\n\tu16 baw_size;\n\tu8 tidno;\n\tint baw_head;    \n\tint baw_tail;    \n\n\ts8 bar_index;\n\tbool active;\n\tbool clear_ps_filter;\n};\n\nvoid ath_tx_queue_tid(struct ath_softc *sc, struct ath_atx_tid *tid);\n\nstruct ath_node {\n\tstruct ath_softc *sc;\n\tstruct ieee80211_sta *sta;  \n\tstruct ieee80211_vif *vif;  \n\n\tu16 maxampdu;\n\tu8 mpdudensity;\n\ts8 ps_key;\n\n\tbool sleeping;\n\tbool no_ps_filter;\n\n#ifdef CONFIG_ATH9K_STATION_STATISTICS\n\tstruct ath_rx_rate_stats rx_rate_stats;\n#endif\n\tu8 key_idx[4];\n\n\tint ackto;\n\tstruct list_head list;\n};\n\nstruct ath_tx_control {\n\tstruct ath_txq *txq;\n\tstruct ath_node *an;\n\tstruct ieee80211_sta *sta;\n\tu8 paprd;\n};\n\n\n \nstruct ath_tx {\n\tu32 txqsetup;\n\tspinlock_t txbuflock;\n\tstruct list_head txbuf;\n\tstruct ath_txq txq[ATH9K_NUM_TX_QUEUES];\n\tstruct ath_descdma txdma;\n\tstruct ath_txq *txq_map[IEEE80211_NUM_ACS];\n\tstruct ath_txq *uapsdq;\n\tu16 max_aggr_framelen[IEEE80211_NUM_ACS][4][32];\n};\n\nstruct ath_rx_edma {\n\tstruct sk_buff_head rx_fifo;\n\tu32 rx_fifo_hwsize;\n};\n\nstruct ath_rx {\n\tu8 defant;\n\tu8 rxotherant;\n\tbool discard_next;\n\tu32 *rxlink;\n\tu32 num_pkts;\n\tstruct list_head rxbuf;\n\tstruct ath_descdma rxdma;\n\tstruct ath_rx_edma rx_edma[ATH9K_RX_QUEUE_MAX];\n\n\tstruct ath_rxbuf *buf_hold;\n\tstruct sk_buff *frag;\n\n\tu32 ampdu_ref;\n};\n\n \n \n \n\nstruct ath_acq {\n\tstruct list_head acq_new;\n\tstruct list_head acq_old;\n\tspinlock_t lock;\n};\n\nstruct ath_chanctx {\n\tstruct cfg80211_chan_def chandef;\n\tstruct list_head vifs;\n\tstruct ath_acq acq[IEEE80211_NUM_ACS];\n\tint hw_queue_base;\n\n\t \n\tstruct ieee80211_vif *primary_sta;\n\n\tstruct ath_beacon_config beacon;\n\tstruct ath9k_hw_cal_data caldata;\n\tstruct timespec64 tsf_ts;\n\tu64 tsf_val;\n\tu32 last_beacon;\n\n\tint flush_timeout;\n\tu16 txpower;\n\tu16 cur_txpower;\n\tbool offchannel;\n\tbool stopped;\n\tbool active;\n\tbool assigned;\n\tbool switch_after_beacon;\n\n\tshort nvifs;\n\tshort nvifs_assigned;\n\tunsigned int rxfilter;\n};\n\nenum ath_chanctx_event {\n\tATH_CHANCTX_EVENT_BEACON_PREPARE,\n\tATH_CHANCTX_EVENT_BEACON_SENT,\n\tATH_CHANCTX_EVENT_TSF_TIMER,\n\tATH_CHANCTX_EVENT_BEACON_RECEIVED,\n\tATH_CHANCTX_EVENT_AUTHORIZED,\n\tATH_CHANCTX_EVENT_SWITCH,\n\tATH_CHANCTX_EVENT_ASSIGN,\n\tATH_CHANCTX_EVENT_UNASSIGN,\n\tATH_CHANCTX_EVENT_CHANGE,\n\tATH_CHANCTX_EVENT_ENABLE_MULTICHANNEL,\n};\n\nenum ath_chanctx_state {\n\tATH_CHANCTX_STATE_IDLE,\n\tATH_CHANCTX_STATE_WAIT_FOR_BEACON,\n\tATH_CHANCTX_STATE_WAIT_FOR_TIMER,\n\tATH_CHANCTX_STATE_SWITCH,\n\tATH_CHANCTX_STATE_FORCE_ACTIVE,\n};\n\nstruct ath_chanctx_sched {\n\tbool beacon_pending;\n\tbool beacon_adjust;\n\tbool offchannel_pending;\n\tbool wait_switch;\n\tbool force_noa_update;\n\tbool extend_absence;\n\tbool mgd_prepare_tx;\n\tenum ath_chanctx_state state;\n\tu8 beacon_miss;\n\n\tu32 next_tbtt;\n\tu32 switch_start_time;\n\tunsigned int offchannel_duration;\n\tunsigned int channel_switch_time;\n\n\t \n\tstruct timer_list timer;\n};\n\nenum ath_offchannel_state {\n\tATH_OFFCHANNEL_IDLE,\n\tATH_OFFCHANNEL_PROBE_SEND,\n\tATH_OFFCHANNEL_PROBE_WAIT,\n\tATH_OFFCHANNEL_SUSPEND,\n\tATH_OFFCHANNEL_ROC_START,\n\tATH_OFFCHANNEL_ROC_WAIT,\n\tATH_OFFCHANNEL_ROC_DONE,\n};\n\nenum ath_roc_complete_reason {\n\tATH_ROC_COMPLETE_EXPIRE,\n\tATH_ROC_COMPLETE_ABORT,\n\tATH_ROC_COMPLETE_CANCEL,\n};\n\nstruct ath_offchannel {\n\tstruct ath_chanctx chan;\n\tstruct timer_list timer;\n\tstruct cfg80211_scan_request *scan_req;\n\tstruct ieee80211_vif *scan_vif;\n\tint scan_idx;\n\tenum ath_offchannel_state state;\n\tstruct ieee80211_channel *roc_chan;\n\tstruct ieee80211_vif *roc_vif;\n\tint roc_duration;\n\tint duration;\n};\n\nstatic inline struct ath_atx_tid *\nath_node_to_tid(struct ath_node *an, u8 tidno)\n{\n\tstruct ieee80211_sta *sta = an->sta;\n\tstruct ieee80211_vif *vif = an->vif;\n\tstruct ieee80211_txq *txq;\n\n\tBUG_ON(!vif);\n\tif (sta)\n\t\ttxq = sta->txq[tidno % ARRAY_SIZE(sta->txq)];\n\telse\n\t\ttxq = vif->txq;\n\n\treturn (struct ath_atx_tid *) txq->drv_priv;\n}\n\n#define case_rtn_string(val) case val: return #val\n\n#define ath_for_each_chanctx(_sc, _ctx)                             \\\n\tfor (ctx = &sc->chanctx[0];                                 \\\n\t     ctx <= &sc->chanctx[ARRAY_SIZE(sc->chanctx) - 1];      \\\n\t     ctx++)\n\nvoid ath_chanctx_init(struct ath_softc *sc);\nvoid ath_chanctx_set_channel(struct ath_softc *sc, struct ath_chanctx *ctx,\n\t\t\t     struct cfg80211_chan_def *chandef);\n\n#ifdef CONFIG_ATH9K_CHANNEL_CONTEXT\n\nstatic inline struct ath_chanctx *\nath_chanctx_get(struct ieee80211_chanctx_conf *ctx)\n{\n\tstruct ath_chanctx **ptr = (void *) ctx->drv_priv;\n\treturn *ptr;\n}\n\nbool ath9k_is_chanctx_enabled(void);\nvoid ath9k_fill_chanctx_ops(void);\nvoid ath9k_init_channel_context(struct ath_softc *sc);\nvoid ath9k_offchannel_init(struct ath_softc *sc);\nvoid ath9k_deinit_channel_context(struct ath_softc *sc);\nint ath9k_init_p2p(struct ath_softc *sc);\nvoid ath9k_deinit_p2p(struct ath_softc *sc);\nvoid ath9k_p2p_remove_vif(struct ath_softc *sc,\n\t\t\t  struct ieee80211_vif *vif);\nvoid ath9k_p2p_beacon_sync(struct ath_softc *sc);\nvoid ath9k_p2p_bss_info_changed(struct ath_softc *sc,\n\t\t\t\tstruct ieee80211_vif *vif);\nvoid ath9k_beacon_add_noa(struct ath_softc *sc, struct ath_vif *avp,\n\t\t\t  struct sk_buff *skb);\nvoid ath9k_p2p_ps_timer(void *priv);\nvoid ath9k_chanctx_wake_queues(struct ath_softc *sc, struct ath_chanctx *ctx);\nvoid ath9k_chanctx_stop_queues(struct ath_softc *sc, struct ath_chanctx *ctx);\nvoid ath_chanctx_check_active(struct ath_softc *sc, struct ath_chanctx *ctx);\n\nvoid ath_chanctx_beacon_recv_ev(struct ath_softc *sc,\n\t\t\t\tenum ath_chanctx_event ev);\nvoid ath_chanctx_beacon_sent_ev(struct ath_softc *sc,\n\t\t\t\tenum ath_chanctx_event ev);\nvoid ath_chanctx_event(struct ath_softc *sc, struct ieee80211_vif *vif,\n\t\t       enum ath_chanctx_event ev);\nvoid ath_chanctx_set_next(struct ath_softc *sc, bool force);\nvoid ath_offchannel_next(struct ath_softc *sc);\nvoid ath_scan_complete(struct ath_softc *sc, bool abort);\nvoid ath_roc_complete(struct ath_softc *sc,\n\t\t      enum ath_roc_complete_reason reason);\nstruct ath_chanctx* ath_is_go_chanctx_present(struct ath_softc *sc);\n\n#else\n\nstatic inline bool ath9k_is_chanctx_enabled(void)\n{\n\treturn false;\n}\nstatic inline void ath9k_fill_chanctx_ops(void)\n{\n}\nstatic inline void ath9k_init_channel_context(struct ath_softc *sc)\n{\n}\nstatic inline void ath9k_offchannel_init(struct ath_softc *sc)\n{\n}\nstatic inline void ath9k_deinit_channel_context(struct ath_softc *sc)\n{\n}\nstatic inline void ath_chanctx_beacon_recv_ev(struct ath_softc *sc,\n\t\t\t\t\t      enum ath_chanctx_event ev)\n{\n}\nstatic inline void ath_chanctx_beacon_sent_ev(struct ath_softc *sc,\n\t\t\t\t\t      enum ath_chanctx_event ev)\n{\n}\nstatic inline void ath_chanctx_event(struct ath_softc *sc,\n\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t     enum ath_chanctx_event ev)\n{\n}\nstatic inline int ath9k_init_p2p(struct ath_softc *sc)\n{\n\treturn 0;\n}\nstatic inline void ath9k_deinit_p2p(struct ath_softc *sc)\n{\n}\nstatic inline void ath9k_p2p_remove_vif(struct ath_softc *sc,\n\t\t\t\t\tstruct ieee80211_vif *vif)\n{\n}\nstatic inline void ath9k_p2p_beacon_sync(struct ath_softc *sc)\n{\n}\nstatic inline void ath9k_p2p_bss_info_changed(struct ath_softc *sc,\n\t\t\t\t\t      struct ieee80211_vif *vif)\n{\n}\nstatic inline void ath9k_beacon_add_noa(struct ath_softc *sc, struct ath_vif *avp,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n}\nstatic inline void ath9k_p2p_ps_timer(struct ath_softc *sc)\n{\n}\nstatic inline void ath9k_chanctx_wake_queues(struct ath_softc *sc,\n\t\t\t\t\t     struct ath_chanctx *ctx)\n{\n}\nstatic inline void ath9k_chanctx_stop_queues(struct ath_softc *sc,\n\t\t\t\t\t     struct ath_chanctx *ctx)\n{\n}\nstatic inline void ath_chanctx_check_active(struct ath_softc *sc,\n\t\t\t\t\t    struct ath_chanctx *ctx)\n{\n}\n\n#endif  \n\nstatic inline void ath_txq_lock(struct ath_softc *sc, struct ath_txq *txq)\n{\n\tspin_lock_bh(&txq->axq_lock);\n}\nstatic inline void ath_txq_unlock(struct ath_softc *sc, struct ath_txq *txq)\n{\n\tspin_unlock_bh(&txq->axq_lock);\n}\n\nvoid ath_startrecv(struct ath_softc *sc);\nbool ath_stoprecv(struct ath_softc *sc);\nu32 ath_calcrxfilter(struct ath_softc *sc);\nint ath_rx_init(struct ath_softc *sc, int nbufs);\nvoid ath_rx_cleanup(struct ath_softc *sc);\nint ath_rx_tasklet(struct ath_softc *sc, int flush, bool hp);\nstruct ath_txq *ath_txq_setup(struct ath_softc *sc, int qtype, int subtype);\nvoid ath_txq_unlock_complete(struct ath_softc *sc, struct ath_txq *txq);\nvoid ath_tx_cleanupq(struct ath_softc *sc, struct ath_txq *txq);\nbool ath_drain_all_txq(struct ath_softc *sc);\nvoid ath_draintxq(struct ath_softc *sc, struct ath_txq *txq);\nvoid ath_tx_node_init(struct ath_softc *sc, struct ath_node *an);\nvoid ath_tx_node_cleanup(struct ath_softc *sc, struct ath_node *an);\nvoid ath_txq_schedule(struct ath_softc *sc, struct ath_txq *txq);\nvoid ath_txq_schedule_all(struct ath_softc *sc);\nint ath_tx_init(struct ath_softc *sc, int nbufs);\nint ath_txq_update(struct ath_softc *sc, int qnum,\n\t\t   struct ath9k_tx_queue_info *q);\nu32 ath_pkt_duration(struct ath_softc *sc, u8 rix, int pktlen,\n\t\t     int width, int half_gi, bool shortPreamble);\nvoid ath_update_max_aggr_framelen(struct ath_softc *sc, int queue, int txop);\nvoid ath_assign_seq(struct ath_common *common, struct sk_buff *skb);\nint ath_tx_start(struct ieee80211_hw *hw, struct sk_buff *skb,\n\t\t struct ath_tx_control *txctl);\nvoid ath_tx_cabq(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t struct sk_buff *skb);\nvoid ath_tx_tasklet(struct ath_softc *sc);\nvoid ath_tx_edma_tasklet(struct ath_softc *sc);\nint ath_tx_aggr_start(struct ath_softc *sc, struct ieee80211_sta *sta,\n\t\t      u16 tid, u16 *ssn);\nvoid ath_tx_aggr_stop(struct ath_softc *sc, struct ieee80211_sta *sta, u16 tid);\n\nvoid ath_tx_aggr_wakeup(struct ath_softc *sc, struct ath_node *an);\nvoid ath_tx_aggr_sleep(struct ieee80211_sta *sta, struct ath_softc *sc,\n\t\t       struct ath_node *an);\nvoid ath9k_release_buffered_frames(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_sta *sta,\n\t\t\t\t   u16 tids, int nframes,\n\t\t\t\t   enum ieee80211_frame_release_type reason,\n\t\t\t\t   bool more_data);\nvoid ath9k_wake_tx_queue(struct ieee80211_hw *hw, struct ieee80211_txq *queue);\n\n \n \n \n\n#define P2P_DEFAULT_CTWIN 10\n\nstruct ath_vif {\n\tstruct list_head list;\n\n\tu16 seq_no;\n\n\t \n\tu8 bssid[ETH_ALEN] __aligned(2);\n\tu16 aid;\n\tbool assoc;\n\n\tstruct ieee80211_vif *vif;\n\tstruct ath_node mcast_node;\n\tint av_bslot;\n\t__le64 tsf_adjust;  \n\tstruct ath_buf *av_bcbuf;\n\tstruct ath_chanctx *chanctx;\n\n\t \n\tstruct ieee80211_noa_data noa;\n\n\t \n\tu8 noa_index;\n\tu32 offchannel_start;\n\tu32 offchannel_duration;\n\n\t \n\tu32 noa_start;\n\tu32 noa_duration;\n\tbool periodic_noa;\n\tbool oneshot_noa;\n};\n\nstruct ath9k_vif_iter_data {\n\tu8 hw_macaddr[ETH_ALEN];  \n\tu8 mask[ETH_ALEN];  \n\tbool has_hw_macaddr;\n\tu8 slottime;\n\tbool beacons;\n\n\tint naps;       \n\tint nmeshes;    \n\tint nstations;  \n\tint nadhocs;    \n\tint nocbs;      \n\tint nbcnvifs;   \n\tstruct ieee80211_vif *primary_beacon_vif;\n\tstruct ieee80211_vif *primary_sta;\n};\n\nvoid ath9k_calculate_iter_data(struct ath_softc *sc,\n\t\t\t       struct ath_chanctx *ctx,\n\t\t\t       struct ath9k_vif_iter_data *iter_data);\nvoid ath9k_calculate_summary_state(struct ath_softc *sc,\n\t\t\t\t   struct ath_chanctx *ctx);\nvoid ath9k_set_txpower(struct ath_softc *sc, struct ieee80211_vif *vif);\n\n \n \n \n\n \n#define BSTUCK_THRESH           \t9\n#define\tATH_BCBUF               \t8\n#define ATH_DEFAULT_BINTVAL     \t100  \n#define ATH_DEFAULT_BMISS_LIMIT \t10\n\n#define TSF_TO_TU(_h,_l) \\\n\t((((u32)(_h)) << 22) | (((u32)(_l)) >> 10))\n\nstruct ath_beacon {\n\tenum {\n\t\tOK,\t\t \n\t\tUPDATE,\t\t \n\t\tCOMMIT\t\t \n\t} updateslot;\t\t \n\n\tu32 beaconq;\n\tu32 bmisscnt;\n\tstruct ieee80211_vif *bslot[ATH_BCBUF];\n\tint slottime;\n\tint slotupdate;\n\tstruct ath_descdma bdma;\n\tstruct ath_txq *cabq;\n\tstruct list_head bbuf;\n\n\tbool tx_processed;\n\tbool tx_last;\n};\n\nvoid ath9k_beacon_tasklet(struct tasklet_struct *t);\nvoid ath9k_beacon_config(struct ath_softc *sc, struct ieee80211_vif *main_vif,\n\t\t\t bool beacons);\nvoid ath9k_beacon_assign_slot(struct ath_softc *sc, struct ieee80211_vif *vif);\nvoid ath9k_beacon_remove_slot(struct ath_softc *sc, struct ieee80211_vif *vif);\nvoid ath9k_beacon_ensure_primary_slot(struct ath_softc *sc);\nvoid ath9k_set_beacon(struct ath_softc *sc);\nbool ath9k_csa_is_finished(struct ath_softc *sc, struct ieee80211_vif *vif);\nvoid ath9k_csa_update(struct ath_softc *sc);\n\n \n \n \n\n#define ATH_STA_SHORT_CALINTERVAL 1000     \n#define ATH_AP_SHORT_CALINTERVAL  100      \n#define ATH_ANI_POLLINTERVAL_OLD  100      \n#define ATH_ANI_POLLINTERVAL_NEW  1000     \n#define ATH_LONG_CALINTERVAL_INT  1000     \n#define ATH_LONG_CALINTERVAL      30000    \n#define ATH_RESTART_CALINTERVAL   1200000  \n#define ATH_ANI_MAX_SKIP_COUNT    10\n#define ATH_PAPRD_TIMEOUT         100  \n#define ATH_PLL_WORK_INTERVAL     100\n\nvoid ath_hw_check_work(struct work_struct *work);\nvoid ath_reset_work(struct work_struct *work);\nbool ath_hw_check(struct ath_softc *sc);\nvoid ath_hw_pll_work(struct work_struct *work);\nvoid ath_paprd_calibrate(struct work_struct *work);\nvoid ath_ani_calibrate(struct timer_list *t);\nvoid ath_start_ani(struct ath_softc *sc);\nvoid ath_stop_ani(struct ath_softc *sc);\nvoid ath_check_ani(struct ath_softc *sc);\nint ath_update_survey_stats(struct ath_softc *sc);\nvoid ath_update_survey_nf(struct ath_softc *sc, int channel);\nvoid ath9k_queue_reset(struct ath_softc *sc, enum ath_reset_type type);\nvoid ath_ps_full_sleep(struct timer_list *t);\nvoid __ath9k_flush(struct ieee80211_hw *hw, u32 queues, bool drop,\n\t\t   bool sw_pending, bool timeout_override);\n\n \n \n \n\n#define ATH_DUMP_BTCOEX(_s, _val)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tlen += scnprintf(buf + len, size - len,\t\t\\\n\t\t\t\t \"%20s : %10d\\n\", _s, (_val));\t\\\n\t} while (0)\n\nenum bt_op_flags {\n\tBT_OP_PRIORITY_DETECTED,\n\tBT_OP_SCAN,\n};\n\nstruct ath_btcoex {\n\tspinlock_t btcoex_lock;\n\tstruct timer_list period_timer;  \n\tstruct timer_list no_stomp_timer;\n\tu32 bt_priority_cnt;\n\tunsigned long bt_priority_time;\n\tunsigned long op_flags;\n\tint bt_stomp_type;  \n\tu32 btcoex_no_stomp;  \n\tu32 btcoex_period;  \n\tu32 btscan_no_stomp;  \n\tu32 duty_cycle;\n\tu32 bt_wait_time;\n\tint rssi_count;\n\tstruct ath_mci_profile mci;\n\tu8 stomp_audio;\n};\n\n#ifdef CONFIG_ATH9K_BTCOEX_SUPPORT\nint ath9k_init_btcoex(struct ath_softc *sc);\nvoid ath9k_deinit_btcoex(struct ath_softc *sc);\nvoid ath9k_start_btcoex(struct ath_softc *sc);\nvoid ath9k_stop_btcoex(struct ath_softc *sc);\nvoid ath9k_btcoex_timer_resume(struct ath_softc *sc);\nvoid ath9k_btcoex_timer_pause(struct ath_softc *sc);\nvoid ath9k_btcoex_handle_interrupt(struct ath_softc *sc, u32 status);\nu16 ath9k_btcoex_aggr_limit(struct ath_softc *sc, u32 max_4ms_framelen);\nvoid ath9k_btcoex_stop_gen_timer(struct ath_softc *sc);\nint ath9k_dump_btcoex(struct ath_softc *sc, u8 *buf, u32 size);\n#else\nstatic inline int ath9k_init_btcoex(struct ath_softc *sc)\n{\n\treturn 0;\n}\nstatic inline void ath9k_deinit_btcoex(struct ath_softc *sc)\n{\n}\nstatic inline void ath9k_start_btcoex(struct ath_softc *sc)\n{\n}\nstatic inline void ath9k_stop_btcoex(struct ath_softc *sc)\n{\n}\nstatic inline void ath9k_btcoex_handle_interrupt(struct ath_softc *sc,\n\t\t\t\t\t\t u32 status)\n{\n}\nstatic inline u16 ath9k_btcoex_aggr_limit(struct ath_softc *sc,\n\t\t\t\t\t  u32 max_4ms_framelen)\n{\n\treturn 0;\n}\nstatic inline void ath9k_btcoex_stop_gen_timer(struct ath_softc *sc)\n{\n}\nstatic inline int ath9k_dump_btcoex(struct ath_softc *sc, u8 *buf, u32 size)\n{\n\treturn 0;\n}\n#endif  \n\n \n \n \n\n#define ATH_LED_PIN_DEF \t\t1\n#define ATH_LED_PIN_9287\t\t8\n#define ATH_LED_PIN_9300\t\t10\n#define ATH_LED_PIN_9485\t\t6\n#define ATH_LED_PIN_9462\t\t4\n\n#ifdef CONFIG_MAC80211_LEDS\nvoid ath_init_leds(struct ath_softc *sc);\nvoid ath_deinit_leds(struct ath_softc *sc);\n#else\nstatic inline void ath_init_leds(struct ath_softc *sc)\n{\n}\n\nstatic inline void ath_deinit_leds(struct ath_softc *sc)\n{\n}\n#endif\n\n \n \n \n\n#ifdef CONFIG_ATH9K_WOW\nvoid ath9k_init_wow(struct ieee80211_hw *hw);\nvoid ath9k_deinit_wow(struct ieee80211_hw *hw);\nint ath9k_suspend(struct ieee80211_hw *hw,\n\t\t  struct cfg80211_wowlan *wowlan);\nint ath9k_resume(struct ieee80211_hw *hw);\nvoid ath9k_set_wakeup(struct ieee80211_hw *hw, bool enabled);\n#else\nstatic inline void ath9k_init_wow(struct ieee80211_hw *hw)\n{\n}\nstatic inline void ath9k_deinit_wow(struct ieee80211_hw *hw)\n{\n}\nstatic inline int ath9k_suspend(struct ieee80211_hw *hw,\n\t\t\t\tstruct cfg80211_wowlan *wowlan)\n{\n\treturn 0;\n}\nstatic inline int ath9k_resume(struct ieee80211_hw *hw)\n{\n\treturn 0;\n}\nstatic inline void ath9k_set_wakeup(struct ieee80211_hw *hw, bool enabled)\n{\n}\n#endif  \n\n \n \n \n\n#define ATH_ANT_RX_CURRENT_SHIFT 4\n#define ATH_ANT_RX_MAIN_SHIFT 2\n#define ATH_ANT_RX_MASK 0x3\n\n#define ATH_ANT_DIV_COMB_SHORT_SCAN_INTR 50\n#define ATH_ANT_DIV_COMB_SHORT_SCAN_PKTCOUNT 0x100\n#define ATH_ANT_DIV_COMB_MAX_PKTCOUNT 0x200\n#define ATH_ANT_DIV_COMB_INIT_COUNT 95\n#define ATH_ANT_DIV_COMB_MAX_COUNT 100\n#define ATH_ANT_DIV_COMB_ALT_ANT_RATIO 30\n#define ATH_ANT_DIV_COMB_ALT_ANT_RATIO2 20\n#define ATH_ANT_DIV_COMB_ALT_ANT_RATIO_LOW_RSSI 50\n#define ATH_ANT_DIV_COMB_ALT_ANT_RATIO2_LOW_RSSI 50\n\n#define ATH_ANT_DIV_COMB_LNA1_DELTA_HI -4\n#define ATH_ANT_DIV_COMB_LNA1_DELTA_MID -2\n#define ATH_ANT_DIV_COMB_LNA1_DELTA_LOW 2\n\nstruct ath_ant_comb {\n\tu16 count;\n\tu16 total_pkt_count;\n\tbool scan;\n\tbool scan_not_start;\n\tint main_total_rssi;\n\tint alt_total_rssi;\n\tint alt_recv_cnt;\n\tint main_recv_cnt;\n\tint rssi_lna1;\n\tint rssi_lna2;\n\tint rssi_add;\n\tint rssi_sub;\n\tint rssi_first;\n\tint rssi_second;\n\tint rssi_third;\n\tint ant_ratio;\n\tint ant_ratio2;\n\tbool alt_good;\n\tint quick_scan_cnt;\n\tenum ath9k_ant_div_comb_lna_conf main_conf;\n\tenum ath9k_ant_div_comb_lna_conf first_quick_scan_conf;\n\tenum ath9k_ant_div_comb_lna_conf second_quick_scan_conf;\n\tbool first_ratio;\n\tbool second_ratio;\n\tunsigned long scan_start_time;\n\n\t \n\tint low_rssi_thresh;\n\tint fast_div_bias;\n};\n\nvoid ath_ant_comb_scan(struct ath_softc *sc, struct ath_rx_status *rs);\n\n \n \n \n\n#define ATH9K_PCI_CUS198          0x0001\n#define ATH9K_PCI_CUS230          0x0002\n#define ATH9K_PCI_CUS217          0x0004\n#define ATH9K_PCI_CUS252          0x0008\n#define ATH9K_PCI_WOW             0x0010\n#define ATH9K_PCI_BT_ANT_DIV      0x0020\n#define ATH9K_PCI_D3_L1_WAR       0x0040\n#define ATH9K_PCI_AR9565_1ANT     0x0080\n#define ATH9K_PCI_AR9565_2ANT     0x0100\n#define ATH9K_PCI_NO_PLL_PWRSAVE  0x0200\n#define ATH9K_PCI_KILLER          0x0400\n#define ATH9K_PCI_LED_ACT_HI      0x0800\n\n \n#define DEFAULT_CACHELINE       32\n#define ATH_CABQ_READY_TIME     80       \n#define ATH_TXPOWER_MAX         100      \n#define MAX_GTT_CNT             5\n\n \n#define PS_WAIT_FOR_BEACON        BIT(0)\n#define PS_WAIT_FOR_CAB           BIT(1)\n#define PS_WAIT_FOR_PSPOLL_DATA   BIT(2)\n#define PS_WAIT_FOR_TX_ACK        BIT(3)\n#define PS_BEACON_SYNC            BIT(4)\n#define PS_WAIT_FOR_ANI           BIT(5)\n\n#define ATH9K_NUM_CHANCTX  2  \n\nstruct ath_softc {\n\tstruct ieee80211_hw *hw;\n\tstruct device *dev;\n\n\tstruct survey_info *cur_survey;\n\tstruct survey_info survey[ATH9K_NUM_CHANNELS];\n\n\tspinlock_t intr_lock;\n\tstruct tasklet_struct intr_tq;\n\tstruct tasklet_struct bcon_tasklet;\n\tstruct ath_hw *sc_ah;\n\tvoid __iomem *mem;\n\tint irq;\n\tspinlock_t sc_serial_rw;\n\tspinlock_t sc_pm_lock;\n\tspinlock_t sc_pcu_lock;\n\tstruct mutex mutex;\n\tstruct work_struct paprd_work;\n\tstruct work_struct hw_reset_work;\n\tstruct completion paprd_complete;\n\twait_queue_head_t tx_wait;\n\n#ifdef CONFIG_ATH9K_CHANNEL_CONTEXT\n\tstruct work_struct chanctx_work;\n\tstruct ath_gen_timer *p2p_ps_timer;\n\tstruct ath_vif *p2p_ps_vif;\n\tstruct ath_chanctx_sched sched;\n\tstruct ath_offchannel offchannel;\n\tstruct ath_chanctx *next_chan;\n\tstruct completion go_beacon;\n\tstruct timespec64 last_event_time;\n#endif\n\n\tunsigned long driver_data;\n\n\tu8 gtt_cnt;\n\tu32 intrstatus;\n\tu16 ps_flags;  \n\tbool ps_enabled;\n\tbool ps_idle;\n\tshort nbcnvifs;\n\tunsigned long ps_usecount;\n\n\tstruct ath_rx rx;\n\tstruct ath_tx tx;\n\tstruct ath_beacon beacon;\n\n\tstruct cfg80211_chan_def cur_chandef;\n\tstruct ath_chanctx chanctx[ATH9K_NUM_CHANCTX];\n\tstruct ath_chanctx *cur_chan;\n\tspinlock_t chan_lock;\n\n#ifdef CONFIG_MAC80211_LEDS\n\tbool led_registered;\n\tchar led_name[32];\n\tstruct led_classdev led_cdev;\n#endif\n\n#ifdef CONFIG_ATH9K_DEBUGFS\n\tstruct ath9k_debug debug;\n#endif\n\tstruct delayed_work hw_check_work;\n\tstruct delayed_work hw_pll_work;\n\tstruct timer_list sleep_timer;\n\n#ifdef CONFIG_ATH9K_BTCOEX_SUPPORT\n\tstruct ath_btcoex btcoex;\n\tstruct ath_mci_coex mci_coex;\n\tstruct work_struct mci_work;\n#endif\n\n\tstruct ath_descdma txsdma;\n\n\tstruct ath_ant_comb ant_comb;\n\tu8 ant_tx, ant_rx;\n\tstruct dfs_pattern_detector *dfs_detector;\n\tu64 dfs_prev_pulse_ts;\n\tu32 wow_enabled;\n\n\tstruct ath_spec_scan_priv spec_priv;\n\n\tstruct ieee80211_vif *tx99_vif;\n\tstruct sk_buff *tx99_skb;\n\tbool tx99_state;\n\ts16 tx99_power;\n\n#ifdef CONFIG_ATH9K_WOW\n\tu32 wow_intr_before_sleep;\n\tbool force_wow;\n#endif\n\n#ifdef CONFIG_ATH9K_HWRNG\n\tstruct hwrng rng_ops;\n\tu32 rng_last;\n\tchar rng_name[sizeof(\"ath9k_65535\")];\n#endif\n};\n\n \n \n \n\n#ifdef CONFIG_ATH9K_TX99\nvoid ath9k_tx99_init_debug(struct ath_softc *sc);\nint ath9k_tx99_send(struct ath_softc *sc, struct sk_buff *skb,\n\t\t    struct ath_tx_control *txctl);\n#else\nstatic inline void ath9k_tx99_init_debug(struct ath_softc *sc)\n{\n}\nstatic inline int ath9k_tx99_send(struct ath_softc *sc,\n\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t  struct ath_tx_control *txctl)\n{\n\treturn 0;\n}\n#endif  \n\n \n \n \n#ifdef CONFIG_ATH9K_HWRNG\nvoid ath9k_rng_start(struct ath_softc *sc);\nvoid ath9k_rng_stop(struct ath_softc *sc);\n#else\nstatic inline void ath9k_rng_start(struct ath_softc *sc)\n{\n}\n\nstatic inline void ath9k_rng_stop(struct ath_softc *sc)\n{\n}\n#endif\n\nstatic inline void ath_read_cachesize(struct ath_common *common, int *csz)\n{\n\tcommon->bus_ops->read_cachesize(common, csz);\n}\n\nvoid ath9k_tasklet(struct tasklet_struct *t);\nint ath_cabq_update(struct ath_softc *);\nu8 ath9k_parse_mpdudensity(u8 mpdudensity);\nirqreturn_t ath_isr(int irq, void *dev);\nint ath_reset(struct ath_softc *sc, struct ath9k_channel *hchan);\nvoid ath_cancel_work(struct ath_softc *sc);\nvoid ath_restart_work(struct ath_softc *sc);\nint ath9k_init_device(u16 devid, struct ath_softc *sc,\n\t\t    const struct ath_bus_ops *bus_ops);\nvoid ath9k_deinit_device(struct ath_softc *sc);\nu8 ath_txchainmask_reduction(struct ath_softc *sc, u8 chainmask, u32 rate);\nvoid ath_start_rfkill_poll(struct ath_softc *sc);\nvoid ath9k_rfkill_poll_state(struct ieee80211_hw *hw);\nvoid ath9k_ps_wakeup(struct ath_softc *sc);\nvoid ath9k_ps_restore(struct ath_softc *sc);\n\n#ifdef CONFIG_ATH9K_PCI\nint ath_pci_init(void);\nvoid ath_pci_exit(void);\n#else\nstatic inline int ath_pci_init(void) { return 0; };\nstatic inline void ath_pci_exit(void) {};\n#endif\n\n#ifdef CONFIG_ATH9K_AHB\nint ath_ahb_init(void);\nvoid ath_ahb_exit(void);\n#else\nstatic inline int ath_ahb_init(void) { return 0; };\nstatic inline void ath_ahb_exit(void) {};\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}