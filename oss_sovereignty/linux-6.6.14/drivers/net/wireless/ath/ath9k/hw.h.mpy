{
  "module_name": "hw.h",
  "hash_id": "d6e20b265da5aaa1e9d99a8d8a15b189f4ff58cbbbf4b512f411beb1aac534de",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath9k/hw.h",
  "human_readable_source": " \n\n#ifndef HW_H\n#define HW_H\n\n#include <linux/if_ether.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/firmware.h>\n\n#include \"mac.h\"\n#include \"ani.h\"\n#include \"eeprom.h\"\n#include \"calib.h\"\n#include \"reg.h\"\n#include \"reg_mci.h\"\n#include \"phy.h\"\n#include \"btcoex.h\"\n#include \"dynack.h\"\n\n#include \"../regd.h\"\n\n#define ATHEROS_VENDOR_ID\t0x168c\n\n#define AR5416_DEVID_PCI\t0x0023\n#define AR5416_DEVID_PCIE\t0x0024\n#define AR9160_DEVID_PCI\t0x0027\n#define AR9280_DEVID_PCI\t0x0029\n#define AR9280_DEVID_PCIE\t0x002a\n#define AR9285_DEVID_PCIE\t0x002b\n#define AR2427_DEVID_PCIE\t0x002c\n#define AR9287_DEVID_PCI\t0x002d\n#define AR9287_DEVID_PCIE\t0x002e\n#define AR9300_DEVID_PCIE\t0x0030\n#define AR9300_DEVID_AR9340\t0x0031\n#define AR9300_DEVID_AR9485_PCIE 0x0032\n#define AR9300_DEVID_AR9580\t0x0033\n#define AR9300_DEVID_AR9462\t0x0034\n#define AR9300_DEVID_AR9330\t0x0035\n#define AR9300_DEVID_QCA955X\t0x0038\n#define AR9485_DEVID_AR1111\t0x0037\n#define AR9300_DEVID_AR9565     0x0036\n#define AR9300_DEVID_AR953X     0x003d\n#define AR9300_DEVID_QCA956X    0x003f\n\n#define AR5416_AR9100_DEVID\t0x000b\n\n#define\tAR_SUBVENDOR_ID_NOG\t0x0e11\n#define AR_SUBVENDOR_ID_NEW_A\t0x7065\n#define AR5416_MAGIC\t\t0x19641014\n\n#define AR9280_COEX2WIRE_SUBSYSID\t0x309b\n#define AT9285_COEX3WIRE_SA_SUBSYSID\t0x30aa\n#define AT9285_COEX3WIRE_DA_SUBSYSID\t0x30ab\n\n#define ATH_AMPDU_LIMIT_MAX        (64 * 1024 - 1)\n\n#define\tATH_DEFAULT_NOISE_FLOOR -95\n\n#define ATH9K_RSSI_BAD\t\t\t-128\n\n#define ATH9K_NUM_CHANNELS\t38\n\n \n#define REG_WRITE(_ah, _reg, _val) \\\n\t(_ah)->reg_ops.write((_ah), (_val), (_reg))\n\n#define REG_READ(_ah, _reg) \\\n\t(_ah)->reg_ops.read((_ah), (_reg))\n\n#define REG_READ_MULTI(_ah, _addr, _val, _cnt)\t\t\\\n\t(_ah)->reg_ops.multi_read((_ah), (_addr), (_val), (_cnt))\n\n#define REG_RMW(_ah, _reg, _set, _clr) \\\n\t(_ah)->reg_ops.rmw((_ah), (_reg), (_set), (_clr))\n\n#define ENABLE_REGWRITE_BUFFER(_ah)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif ((_ah)->reg_ops.enable_write_buffer)\t\\\n\t\t\t(_ah)->reg_ops.enable_write_buffer((_ah)); \\\n\t} while (0)\n\n#define REGWRITE_BUFFER_FLUSH(_ah)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif ((_ah)->reg_ops.write_flush)\t\t\\\n\t\t\t(_ah)->reg_ops.write_flush((_ah));\t\\\n\t} while (0)\n\n#define ENABLE_REG_RMW_BUFFER(_ah)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif ((_ah)->reg_ops.enable_rmw_buffer)\t\\\n\t\t\t(_ah)->reg_ops.enable_rmw_buffer((_ah)); \\\n\t} while (0)\n\n#define REG_RMW_BUFFER_FLUSH(_ah)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif ((_ah)->reg_ops.rmw_flush)\t\t\\\n\t\t\t(_ah)->reg_ops.rmw_flush((_ah));\t\\\n\t} while (0)\n\n#define PR_EEP(_s, _val)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tlen += scnprintf(buf + len, size - len, \"%20s : %10d\\n\",\\\n\t\t\t\t _s, (_val));\t\t\t\t\\\n\t} while (0)\n\n#define SM(_v, _f)  (((_v) << _f##_S) & _f)\n#define MS(_v, _f)  (((_v) & _f) >> _f##_S)\n#define REG_RMW_FIELD(_a, _r, _f, _v) \\\n\tREG_RMW(_a, _r, (((_v) << _f##_S) & _f), (_f))\n#define REG_READ_FIELD(_a, _r, _f) \\\n\t(((REG_READ(_a, _r) & _f) >> _f##_S))\n#define REG_SET_BIT(_a, _r, _f) \\\n\tREG_RMW(_a, _r, (_f), 0)\n#define REG_CLR_BIT(_a, _r, _f) \\\n\tREG_RMW(_a, _r, 0, (_f))\n\n#define DO_DELAY(x) do {\t\t\t\t\t\\\n\t\tif (((++(x) % 64) == 0) &&\t\t\t\\\n\t\t    (ath9k_hw_common(ah)->bus_ops->ath_bus_type\t\\\n\t\t\t!= ATH_USB))\t\t\t\t\\\n\t\t\tudelay(1);\t\t\t\t\\\n\t} while (0)\n\n#define REG_WRITE_ARRAY(iniarray, column, regWr) \\\n\tath9k_hw_write_array(ah, iniarray, column, &(regWr))\n#define REG_READ_ARRAY(ah, array, size) \\\n\tath9k_hw_read_array(ah, array, size)\n\n#define AR_GPIO_OUTPUT_MUX_AS_OUTPUT             0\n#define AR_GPIO_OUTPUT_MUX_AS_PCIE_ATTENTION_LED 1\n#define AR_GPIO_OUTPUT_MUX_AS_PCIE_POWER_LED     2\n#define AR_GPIO_OUTPUT_MUX_AS_TX_FRAME           3\n#define AR_GPIO_OUTPUT_MUX_AS_RX_CLEAR_EXTERNAL  4\n#define AR_GPIO_OUTPUT_MUX_AS_MAC_NETWORK_LED    5\n#define AR_GPIO_OUTPUT_MUX_AS_MAC_POWER_LED      6\n#define AR_GPIO_OUTPUT_MUX_AS_MCI_WLAN_DATA      0x16\n#define AR_GPIO_OUTPUT_MUX_AS_MCI_WLAN_CLK       0x17\n#define AR_GPIO_OUTPUT_MUX_AS_MCI_BT_DATA        0x18\n#define AR_GPIO_OUTPUT_MUX_AS_MCI_BT_CLK         0x19\n#define AR_GPIO_OUTPUT_MUX_AS_WL_IN_TX           0x14\n#define AR_GPIO_OUTPUT_MUX_AS_WL_IN_RX           0x13\n#define AR_GPIO_OUTPUT_MUX_AS_BT_IN_TX           9\n#define AR_GPIO_OUTPUT_MUX_AS_BT_IN_RX           8\n#define AR_GPIO_OUTPUT_MUX_AS_RUCKUS_STROBE      0x1d\n#define AR_GPIO_OUTPUT_MUX_AS_RUCKUS_DATA        0x1e\n\n#define AR_GPIOD_MASK               0x00001FFF\n\n#define BASE_ACTIVATE_DELAY         100\n#define RTC_PLL_SETTLE_DELAY        (AR_SREV_9340(ah) ? 1000 : 100)\n#define COEF_SCALE_S                24\n#define HT40_CHANNEL_CENTER_SHIFT   10\n\n#define ATH9K_ANTENNA0_CHAINMASK    0x1\n#define ATH9K_ANTENNA1_CHAINMASK    0x2\n\n#define ATH9K_NUM_DMA_DEBUG_REGS    8\n#define ATH9K_NUM_QUEUES            10\n\n#define MAX_RATE_POWER              63\n#define MAX_COMBINED_POWER          254  \n#define AH_WAIT_TIMEOUT             100000  \n#define AH_TSF_WRITE_TIMEOUT        100     \n#define AH_TIME_QUANTUM             10\n#define AR_KEYTABLE_SIZE            128\n#define POWER_UP_TIME               10000\n#define SPUR_RSSI_THRESH            40\n#define UPPER_5G_SUB_BAND_START\t\t5700\n#define MID_5G_SUB_BAND_START\t\t5400\n\n#define CAB_TIMEOUT_VAL             10\n#define BEACON_TIMEOUT_VAL          10\n#define MIN_BEACON_TIMEOUT_VAL      1\n#define SLEEP_SLOP                  TU_TO_USEC(3)\n\n#define INIT_CONFIG_STATUS          0x00000000\n#define INIT_RSSI_THR               0x00000700\n#define INIT_BCON_CNTRL_REG         0x00000000\n\n#define TU_TO_USEC(_tu)             ((_tu) << 10)\n\n#define ATH9K_HW_RX_HP_QDEPTH\t16\n#define ATH9K_HW_RX_LP_QDEPTH\t128\n\n#define PAPRD_GAIN_TABLE_ENTRIES\t32\n#define PAPRD_TABLE_SZ\t\t\t24\n#define PAPRD_IDEAL_AGC2_PWR_RANGE\t0xe0\n\n \n\n \n#define KAL_FRAME_LEN\t\t28\n#define KAL_FRAME_TYPE\t\t0x2\t \n#define KAL_FRAME_SUB_TYPE\t0x4\t \n#define KAL_DURATION_ID\t\t0x3d\n#define KAL_NUM_DATA_WORDS\t6\n#define KAL_NUM_DESC_WORDS\t12\n#define KAL_ANTENNA_MODE\t1\n#define KAL_TO_DS\t\t1\n#define KAL_DELAY\t\t4\t \n#define KAL_TIMEOUT\t\t900\n\n#define MAX_PATTERN_SIZE\t\t256\n#define MAX_PATTERN_MASK_SIZE\t\t32\n#define MAX_NUM_PATTERN\t\t\t16\n#define MAX_NUM_PATTERN_LEGACY\t\t8\n#define MAX_NUM_USER_PATTERN\t\t6  \n\n \n\n#define AH_WOW_USER_PATTERN_EN\t\tBIT(0)\n#define AH_WOW_MAGIC_PATTERN_EN\t\tBIT(1)\n#define AH_WOW_LINK_CHANGE\t\tBIT(2)\n#define AH_WOW_BEACON_MISS\t\tBIT(3)\n\nenum ath_hw_txq_subtype {\n\tATH_TXQ_AC_BK = 0,\n\tATH_TXQ_AC_BE = 1,\n\tATH_TXQ_AC_VI = 2,\n\tATH_TXQ_AC_VO = 3,\n};\n\nenum ath_ini_subsys {\n\tATH_INI_PRE = 0,\n\tATH_INI_CORE,\n\tATH_INI_POST,\n\tATH_INI_NUM_SPLIT,\n};\n\nenum ath9k_hw_caps {\n\tATH9K_HW_CAP_HT                         = BIT(0),\n\tATH9K_HW_CAP_RFSILENT                   = BIT(1),\n\tATH9K_HW_CAP_AUTOSLEEP                  = BIT(2),\n\tATH9K_HW_CAP_4KB_SPLITTRANS             = BIT(3),\n\tATH9K_HW_CAP_EDMA\t\t\t= BIT(4),\n\tATH9K_HW_CAP_RAC_SUPPORTED\t\t= BIT(5),\n\tATH9K_HW_CAP_LDPC\t\t\t= BIT(6),\n\tATH9K_HW_CAP_FASTCLOCK\t\t\t= BIT(7),\n\tATH9K_HW_CAP_SGI_20\t\t\t= BIT(8),\n\tATH9K_HW_CAP_ANT_DIV_COMB\t\t= BIT(10),\n\tATH9K_HW_CAP_2GHZ\t\t\t= BIT(11),\n\tATH9K_HW_CAP_5GHZ\t\t\t= BIT(12),\n\tATH9K_HW_CAP_APM\t\t\t= BIT(13),\n#ifdef CONFIG_ATH9K_PCOEM\n\tATH9K_HW_CAP_RTT\t\t\t= BIT(14),\n\tATH9K_HW_CAP_MCI\t\t\t= BIT(15),\n\tATH9K_HW_CAP_BT_ANT_DIV\t\t\t= BIT(17),\n#else\n\tATH9K_HW_CAP_RTT\t\t\t= 0,\n\tATH9K_HW_CAP_MCI\t\t\t= 0,\n\tATH9K_HW_CAP_BT_ANT_DIV\t\t\t= 0,\n#endif\n\tATH9K_HW_CAP_DFS\t\t\t= BIT(18),\n\tATH9K_HW_CAP_PAPRD\t\t\t= BIT(19),\n\tATH9K_HW_CAP_FCC_BAND_SWITCH\t\t= BIT(20),\n};\n\n \n\nstruct ath9k_hw_wow {\n\tu32 wow_event_mask;\n\tu32 wow_event_mask2;\n\tu8 max_patterns;\n};\n\nstruct ath9k_hw_capabilities {\n\tu32 hw_caps;  \n\tu16 rts_aggr_limit;\n\tu8 tx_chainmask;\n\tu8 rx_chainmask;\n\tu8 chip_chainmask;\n\tu8 max_txchains;\n\tu8 max_rxchains;\n\tu8 num_gpio_pins;\n\tu32 gpio_mask;\n\tu32 gpio_requested;\n\tu8 rx_hp_qdepth;\n\tu8 rx_lp_qdepth;\n\tu8 rx_status_len;\n\tu8 tx_desc_len;\n\tu8 txs_len;\n};\n\n#define AR_NO_SPUR      \t0x8000\n#define AR_BASE_FREQ_2GHZ   \t2300\n#define AR_BASE_FREQ_5GHZ   \t4900\n#define AR_SPUR_FEEQ_BOUND_HT40 19\n#define AR_SPUR_FEEQ_BOUND_HT20 10\n\nenum ath9k_hw_hang_checks {\n\tHW_BB_WATCHDOG            = BIT(0),\n\tHW_PHYRESTART_CLC_WAR     = BIT(1),\n\tHW_BB_RIFS_HANG           = BIT(2),\n\tHW_BB_DFS_HANG            = BIT(3),\n\tHW_BB_RX_CLEAR_STUCK_HANG = BIT(4),\n\tHW_MAC_HANG               = BIT(5),\n};\n\n#define AR_PCIE_PLL_PWRSAVE_CONTROL BIT(0)\n#define AR_PCIE_PLL_PWRSAVE_ON_D3   BIT(1)\n#define AR_PCIE_PLL_PWRSAVE_ON_D0   BIT(2)\n#define AR_PCIE_CDR_PWRSAVE_ON_D3   BIT(3)\n#define AR_PCIE_CDR_PWRSAVE_ON_D0   BIT(4)\n\nstruct ath9k_ops_config {\n\tint dma_beacon_response_time;\n\tint sw_beacon_response_time;\n\tbool cwm_ignore_extcca;\n\tu32 pcie_waen;\n\tu8 analog_shiftreg;\n\tu32 ofdm_trig_low;\n\tu32 ofdm_trig_high;\n\tu32 cck_trig_high;\n\tu32 cck_trig_low;\n\tbool enable_paprd;\n\tint serialize_regmode;\n\tbool rx_intr_mitigation;\n\tbool tx_intr_mitigation;\n\tu8 max_txtrig_level;\n\tu16 ani_poll_interval;  \n\tu16 hw_hang_checks;\n\tu16 rimt_first;\n\tu16 rimt_last;\n\n\t \n\tu32 aspm_l1_fix;\n\tu32 xlna_gpio;\n\tu32 ant_ctrl_comm2g_switch_enable;\n\tbool xatten_margin_cfg;\n\tbool alt_mingainidx;\n\tu8 pll_pwrsave;\n\tbool tx_gain_buffalo;\n\tbool led_active_high;\n};\n\nenum ath9k_int {\n\tATH9K_INT_RX = 0x00000001,\n\tATH9K_INT_RXDESC = 0x00000002,\n\tATH9K_INT_RXHP = 0x00000001,\n\tATH9K_INT_RXLP = 0x00000002,\n\tATH9K_INT_RXNOFRM = 0x00000008,\n\tATH9K_INT_RXEOL = 0x00000010,\n\tATH9K_INT_RXORN = 0x00000020,\n\tATH9K_INT_TX = 0x00000040,\n\tATH9K_INT_TXDESC = 0x00000080,\n\tATH9K_INT_TIM_TIMER = 0x00000100,\n\tATH9K_INT_MCI = 0x00000200,\n\tATH9K_INT_BB_WATCHDOG = 0x00000400,\n\tATH9K_INT_TXURN = 0x00000800,\n\tATH9K_INT_MIB = 0x00001000,\n\tATH9K_INT_RXPHY = 0x00004000,\n\tATH9K_INT_RXKCM = 0x00008000,\n\tATH9K_INT_SWBA = 0x00010000,\n\tATH9K_INT_BMISS = 0x00040000,\n\tATH9K_INT_BNR = 0x00100000,\n\tATH9K_INT_TIM = 0x00200000,\n\tATH9K_INT_DTIM = 0x00400000,\n\tATH9K_INT_DTIMSYNC = 0x00800000,\n\tATH9K_INT_GPIO = 0x01000000,\n\tATH9K_INT_CABEND = 0x02000000,\n\tATH9K_INT_TSFOOR = 0x04000000,\n\tATH9K_INT_GENTIMER = 0x08000000,\n\tATH9K_INT_CST = 0x10000000,\n\tATH9K_INT_GTT = 0x20000000,\n\tATH9K_INT_FATAL = 0x40000000,\n\tATH9K_INT_GLOBAL = 0x80000000,\n\tATH9K_INT_BMISC = ATH9K_INT_TIM |\n\t\tATH9K_INT_DTIM |\n\t\tATH9K_INT_DTIMSYNC |\n\t\tATH9K_INT_TSFOOR |\n\t\tATH9K_INT_CABEND,\n\tATH9K_INT_COMMON = ATH9K_INT_RXNOFRM |\n\t\tATH9K_INT_RXDESC |\n\t\tATH9K_INT_RXEOL |\n\t\tATH9K_INT_RXORN |\n\t\tATH9K_INT_TXURN |\n\t\tATH9K_INT_TXDESC |\n\t\tATH9K_INT_MIB |\n\t\tATH9K_INT_RXPHY |\n\t\tATH9K_INT_RXKCM |\n\t\tATH9K_INT_SWBA |\n\t\tATH9K_INT_BMISS |\n\t\tATH9K_INT_GPIO,\n\tATH9K_INT_NOCARD = 0xffffffff\n};\n\n#define MAX_RTT_TABLE_ENTRY     6\n#define MAX_IQCAL_MEASUREMENT\t8\n#define MAX_CL_TAB_ENTRY\t16\n#define CL_TAB_ENTRY(reg_base)\t(reg_base + (4 * j))\n\nenum ath9k_cal_flags {\n\tRTT_DONE,\n\tPAPRD_PACKET_SENT,\n\tPAPRD_DONE,\n\tNFCAL_PENDING,\n\tNFCAL_INTF,\n\tTXIQCAL_DONE,\n\tTXCLCAL_DONE,\n\tSW_PKDET_DONE,\n\tLONGCAL_PENDING,\n};\n\nstruct ath9k_hw_cal_data {\n\tu16 channel;\n\tu16 channelFlags;\n\tunsigned long cal_flags;\n\tint32_t CalValid;\n\tint8_t iCoff;\n\tint8_t qCoff;\n\tu8 caldac[2];\n\tu16 small_signal_gain[AR9300_MAX_CHAINS];\n\tu32 pa_table[AR9300_MAX_CHAINS][PAPRD_TABLE_SZ];\n\tu32 num_measures[AR9300_MAX_CHAINS];\n\tint tx_corr_coeff[MAX_IQCAL_MEASUREMENT][AR9300_MAX_CHAINS];\n\tu32 tx_clcal[AR9300_MAX_CHAINS][MAX_CL_TAB_ENTRY];\n\tu32 rtt_table[AR9300_MAX_CHAINS][MAX_RTT_TABLE_ENTRY];\n\tstruct ath9k_nfcal_hist nfCalHist[NUM_NF_READINGS];\n};\n\nstruct ath9k_channel {\n\tstruct ieee80211_channel *chan;\n\tu16 channel;\n\tu16 channelFlags;\n\ts16 noisefloor;\n};\n\n#define CHANNEL_5GHZ\t\tBIT(0)\n#define CHANNEL_HALF\t\tBIT(1)\n#define CHANNEL_QUARTER\t\tBIT(2)\n#define CHANNEL_HT\t\tBIT(3)\n#define CHANNEL_HT40PLUS\tBIT(4)\n#define CHANNEL_HT40MINUS\tBIT(5)\n\n#define IS_CHAN_5GHZ(_c) (!!((_c)->channelFlags & CHANNEL_5GHZ))\n#define IS_CHAN_2GHZ(_c) (!IS_CHAN_5GHZ(_c))\n\n#define IS_CHAN_HALF_RATE(_c) (!!((_c)->channelFlags & CHANNEL_HALF))\n#define IS_CHAN_QUARTER_RATE(_c) (!!((_c)->channelFlags & CHANNEL_QUARTER))\n#define IS_CHAN_A_FAST_CLOCK(_ah, _c)\t\t\t\\\n\t(IS_CHAN_5GHZ(_c) && ((_ah)->caps.hw_caps & ATH9K_HW_CAP_FASTCLOCK))\n\n#define IS_CHAN_HT(_c) ((_c)->channelFlags & CHANNEL_HT)\n\n#define IS_CHAN_HT20(_c) (IS_CHAN_HT(_c) && !IS_CHAN_HT40(_c))\n\n#define IS_CHAN_HT40(_c) \\\n\t(!!((_c)->channelFlags & (CHANNEL_HT40PLUS | CHANNEL_HT40MINUS)))\n\n#define IS_CHAN_HT40PLUS(_c) ((_c)->channelFlags & CHANNEL_HT40PLUS)\n#define IS_CHAN_HT40MINUS(_c) ((_c)->channelFlags & CHANNEL_HT40MINUS)\n\nenum ath9k_power_mode {\n\tATH9K_PM_AWAKE = 0,\n\tATH9K_PM_FULL_SLEEP,\n\tATH9K_PM_NETWORK_SLEEP,\n\tATH9K_PM_UNDEFINED\n};\n\nenum ser_reg_mode {\n\tSER_REG_MODE_OFF = 0,\n\tSER_REG_MODE_ON = 1,\n\tSER_REG_MODE_AUTO = 2,\n};\n\nenum ath9k_rx_qtype {\n\tATH9K_RX_QUEUE_HP,\n\tATH9K_RX_QUEUE_LP,\n\tATH9K_RX_QUEUE_MAX,\n};\n\nstruct ath9k_beacon_state {\n\tu32 bs_nexttbtt;\n\tu32 bs_nextdtim;\n\tu32 bs_intval;\n#define ATH9K_TSFOOR_THRESHOLD    0x00004240  \n\tu32 bs_dtimperiod;\n\tu16 bs_bmissthreshold;\n\tu32 bs_sleepduration;\n\tu32 bs_tsfoor_threshold;\n};\n\nstruct chan_centers {\n\tu16 synth_center;\n\tu16 ctl_center;\n\tu16 ext_center;\n};\n\nenum {\n\tATH9K_RESET_POWER_ON,\n\tATH9K_RESET_WARM,\n\tATH9K_RESET_COLD,\n};\n\nstruct ath9k_hw_version {\n\tu32 magic;\n\tu16 devid;\n\tu16 subvendorid;\n\tu32 macVersion;\n\tu16 macRev;\n\tu16 phyRev;\n\tu16 analog5GhzRev;\n\tu16 analog2GhzRev;\n\tenum ath_usb_dev usbdev;\n};\n\n \n\n#define ATH_MAX_GEN_TIMER\t16\n\n#define AR_GENTMR_BIT(_index)\t(1 << (_index))\n\nstruct ath_gen_timer_configuration {\n\tu32 next_addr;\n\tu32 period_addr;\n\tu32 mode_addr;\n\tu32 mode_mask;\n};\n\nstruct ath_gen_timer {\n\tvoid (*trigger)(void *arg);\n\tvoid (*overflow)(void *arg);\n\tvoid *arg;\n\tu8 index;\n};\n\nstruct ath_gen_timer_table {\n\tstruct ath_gen_timer *timers[ATH_MAX_GEN_TIMER];\n\tu16 timer_mask;\n\tbool tsf2_enabled;\n};\n\nstruct ath_hw_antcomb_conf {\n\tu8 main_lna_conf;\n\tu8 alt_lna_conf;\n\tu8 fast_div_bias;\n\tu8 main_gaintb;\n\tu8 alt_gaintb;\n\tint lna1_lna2_delta;\n\tint lna1_lna2_switch_delta;\n\tu8 div_group;\n};\n\n \nstruct ath_hw_radar_conf {\n\tunsigned int pulse_inband;\n\tunsigned int pulse_inband_step;\n\tunsigned int pulse_height;\n\tunsigned int pulse_rssi;\n\tunsigned int pulse_maxlen;\n\n\tunsigned int radar_rssi;\n\tunsigned int radar_inband;\n\tint fir_power;\n\n\tbool ext_channel;\n};\n\n \nstruct ath_hw_private_ops {\n\tvoid (*init_hang_checks)(struct ath_hw *ah);\n\tbool (*detect_mac_hang)(struct ath_hw *ah);\n\tbool (*detect_bb_hang)(struct ath_hw *ah);\n\n\t \n\tvoid (*init_cal_settings)(struct ath_hw *ah);\n\tbool (*init_cal)(struct ath_hw *ah, struct ath9k_channel *chan);\n\n\tvoid (*init_mode_gain_regs)(struct ath_hw *ah);\n\tvoid (*setup_calibration)(struct ath_hw *ah,\n\t\t\t\t  struct ath9k_cal_list *currCal);\n\n\t \n\tint (*rf_set_freq)(struct ath_hw *ah,\n\t\t\t   struct ath9k_channel *chan);\n\tvoid (*spur_mitigate_freq)(struct ath_hw *ah,\n\t\t\t\t   struct ath9k_channel *chan);\n\tbool (*set_rf_regs)(struct ath_hw *ah,\n\t\t\t    struct ath9k_channel *chan,\n\t\t\t    u16 modesIndex);\n\tvoid (*set_channel_regs)(struct ath_hw *ah, struct ath9k_channel *chan);\n\tvoid (*init_bb)(struct ath_hw *ah,\n\t\t\tstruct ath9k_channel *chan);\n\tint (*process_ini)(struct ath_hw *ah, struct ath9k_channel *chan);\n\tvoid (*olc_init)(struct ath_hw *ah);\n\tvoid (*set_rfmode)(struct ath_hw *ah, struct ath9k_channel *chan);\n\tvoid (*mark_phy_inactive)(struct ath_hw *ah);\n\tvoid (*set_delta_slope)(struct ath_hw *ah, struct ath9k_channel *chan);\n\tbool (*rfbus_req)(struct ath_hw *ah);\n\tvoid (*rfbus_done)(struct ath_hw *ah);\n\tvoid (*restore_chainmask)(struct ath_hw *ah);\n\tu32 (*compute_pll_control)(struct ath_hw *ah,\n\t\t\t\t   struct ath9k_channel *chan);\n\tbool (*ani_control)(struct ath_hw *ah, enum ath9k_ani_cmd cmd,\n\t\t\t    int param);\n\tvoid (*do_getnf)(struct ath_hw *ah, int16_t nfarray[NUM_NF_READINGS]);\n\tvoid (*set_radar_params)(struct ath_hw *ah,\n\t\t\t\t struct ath_hw_radar_conf *conf);\n\tint (*fast_chan_change)(struct ath_hw *ah, struct ath9k_channel *chan,\n\t\t\t\tu8 *ini_reloaded);\n\n\t \n\tvoid (*ani_cache_ini_regs)(struct ath_hw *ah);\n\n#ifdef CONFIG_ATH9K_BTCOEX_SUPPORT\n\tbool (*is_aic_enabled)(struct ath_hw *ah);\n#endif  \n};\n\n \nstruct ath_spec_scan {\n\tbool enabled;\n\tbool short_repeat;\n\tbool endless;\n\tu8 count;\n\tu8 period;\n\tu8 fft_period;\n};\n\n \nstruct ath_hw_ops {\n\tvoid (*config_pci_powersave)(struct ath_hw *ah,\n\t\t\t\t     bool power_off);\n\tvoid (*rx_enable)(struct ath_hw *ah);\n\tvoid (*set_desc_link)(void *ds, u32 link);\n\tint (*calibrate)(struct ath_hw *ah, struct ath9k_channel *chan,\n\t\t\t u8 rxchainmask, bool longcal);\n\tbool (*get_isr)(struct ath_hw *ah, enum ath9k_int *masked,\n\t\t\tu32 *sync_cause_p);\n\tvoid (*set_txdesc)(struct ath_hw *ah, void *ds,\n\t\t\t   struct ath_tx_info *i);\n\tint (*proc_txdesc)(struct ath_hw *ah, void *ds,\n\t\t\t   struct ath_tx_status *ts);\n\tint (*get_duration)(struct ath_hw *ah, const void *ds, int index);\n\tvoid (*antdiv_comb_conf_get)(struct ath_hw *ah,\n\t\t\tstruct ath_hw_antcomb_conf *antconf);\n\tvoid (*antdiv_comb_conf_set)(struct ath_hw *ah,\n\t\t\tstruct ath_hw_antcomb_conf *antconf);\n\tvoid (*spectral_scan_config)(struct ath_hw *ah,\n\t\t\t\t     struct ath_spec_scan *param);\n\tvoid (*spectral_scan_trigger)(struct ath_hw *ah);\n\tvoid (*spectral_scan_wait)(struct ath_hw *ah);\n\n\tvoid (*tx99_start)(struct ath_hw *ah, u32 qnum);\n\tvoid (*tx99_stop)(struct ath_hw *ah);\n\tvoid (*tx99_set_txpower)(struct ath_hw *ah, u8 power);\n\n#ifdef CONFIG_ATH9K_BTCOEX_SUPPORT\n\tvoid (*set_bt_ant_diversity)(struct ath_hw *hw, bool enable);\n#endif\n};\n\nstruct ath_nf_limits {\n\ts16 max;\n\ts16 min;\n\ts16 nominal;\n\ts16 cal[AR5416_MAX_CHAINS];\n\ts16 pwr[AR5416_MAX_CHAINS];\n};\n\nenum ath_cal_list {\n\tTX_IQ_CAL         =\tBIT(0),\n\tTX_IQ_ON_AGC_CAL  =\tBIT(1),\n\tTX_CL_CAL         =\tBIT(2),\n};\n\n \n#define AH_USE_EEPROM   0x1\n#define AH_UNPLUGGED    0x2  \n#define AH_FASTCC       0x4\n#define AH_NO_EEP_SWAP  0x8  \n\nstruct ath_hw {\n\tstruct ath_ops reg_ops;\n\n\tstruct device *dev;\n\tstruct ieee80211_hw *hw;\n\tstruct ath_common common;\n\tstruct ath9k_hw_version hw_version;\n\tstruct ath9k_ops_config config;\n\tstruct ath9k_hw_capabilities caps;\n\tstruct ath9k_channel channels[ATH9K_NUM_CHANNELS];\n\tstruct ath9k_channel *curchan;\n\n\tunion {\n\t\tstruct ar5416_eeprom_def def;\n\t\tstruct ar5416_eeprom_4k map4k;\n\t\tstruct ar9287_eeprom map9287;\n\t\tstruct ar9300_eeprom ar9300_eep;\n\t} eeprom;\n\tconst struct eeprom_ops *eep_ops;\n\n\tbool sw_mgmt_crypto_tx;\n\tbool sw_mgmt_crypto_rx;\n\tbool is_pciexpress;\n\tbool aspm_enabled;\n\tbool is_monitoring;\n\tbool need_an_top2_fixup;\n\tu16 tx_trig_level;\n\n\tu32 nf_regs[6];\n\tstruct ath_nf_limits nf_2g;\n\tstruct ath_nf_limits nf_5g;\n\tu16 rfsilent;\n\tu32 rfkill_gpio;\n\tu32 rfkill_polarity;\n\tu32 ah_flags;\n\ts16 nf_override;\n\n\tbool reset_power_on;\n\tbool htc_reset_init;\n\n\tenum nl80211_iftype opmode;\n\tenum ath9k_power_mode power_mode;\n\n\ts8 noise;\n\tstruct ath9k_hw_cal_data *caldata;\n\tstruct ath9k_pacal_info pacal_info;\n\tstruct ar5416Stats stats;\n\tstruct ath9k_tx_queue_info txq[ATH9K_NUM_TX_QUEUES];\n\tDECLARE_BITMAP(pending_del_keymap, ATH_KEYMAX);\n\n\tenum ath9k_int imask;\n\tu32 imrs2_reg;\n\tu32 txok_interrupt_mask;\n\tu32 txerr_interrupt_mask;\n\tu32 txdesc_interrupt_mask;\n\tu32 txeol_interrupt_mask;\n\tu32 txurn_interrupt_mask;\n\tatomic_t intr_ref_cnt;\n\tbool chip_fullsleep;\n\tu32 modes_index;\n\n\t \n\tu32 supp_cals;\n\tunsigned long cal_start_time;\n\tstruct ath9k_cal_list iq_caldata;\n\tstruct ath9k_cal_list adcgain_caldata;\n\tstruct ath9k_cal_list adcdc_caldata;\n\tstruct ath9k_cal_list *cal_list;\n\tstruct ath9k_cal_list *cal_list_last;\n\tstruct ath9k_cal_list *cal_list_curr;\n#define totalPowerMeasI meas0.unsign\n#define totalPowerMeasQ meas1.unsign\n#define totalIqCorrMeas meas2.sign\n#define totalAdcIOddPhase  meas0.unsign\n#define totalAdcIEvenPhase meas1.unsign\n#define totalAdcQOddPhase  meas2.unsign\n#define totalAdcQEvenPhase meas3.unsign\n#define totalAdcDcOffsetIOddPhase  meas0.sign\n#define totalAdcDcOffsetIEvenPhase meas1.sign\n#define totalAdcDcOffsetQOddPhase  meas2.sign\n#define totalAdcDcOffsetQEvenPhase meas3.sign\n\tunion {\n\t\tu32 unsign[AR5416_MAX_CHAINS];\n\t\tint32_t sign[AR5416_MAX_CHAINS];\n\t} meas0;\n\tunion {\n\t\tu32 unsign[AR5416_MAX_CHAINS];\n\t\tint32_t sign[AR5416_MAX_CHAINS];\n\t} meas1;\n\tunion {\n\t\tu32 unsign[AR5416_MAX_CHAINS];\n\t\tint32_t sign[AR5416_MAX_CHAINS];\n\t} meas2;\n\tunion {\n\t\tu32 unsign[AR5416_MAX_CHAINS];\n\t\tint32_t sign[AR5416_MAX_CHAINS];\n\t} meas3;\n\tu16 cal_samples;\n\tu8 enabled_cals;\n\n\tu32 sta_id1_defaults;\n\tu32 misc_mode;\n\n\t \n\tstruct ath_hw_private_ops private_ops;\n\t \n\tstruct ath_hw_ops ops;\n\n\t \n\tu32 *analogBank6Data;\n\n\tint coverage_class;\n\tu32 slottime;\n\tu32 globaltxtimeout;\n\n\t \n\tu32 aniperiod;\n\tenum ath9k_ani_cmd ani_function;\n\tu32 ani_skip_count;\n\tstruct ar5416AniState ani;\n\n#ifdef CONFIG_ATH9K_BTCOEX_SUPPORT\n\tstruct ath_btcoex_hw btcoex_hw;\n#endif\n\n\tu32 intr_txqs;\n\tu8 txchainmask;\n\tu8 rxchainmask;\n\n\tstruct ath_hw_radar_conf radar_conf;\n\n\tu32 originalGain[22];\n\tint initPDADC;\n\tint PDADCdelta;\n\tint led_pin;\n\tu32 gpio_mask;\n\tu32 gpio_val;\n\n\tstruct ar5416IniArray ini_dfs;\n\tstruct ar5416IniArray iniModes;\n\tstruct ar5416IniArray iniCommon;\n\tstruct ar5416IniArray iniBB_RfGain;\n\tstruct ar5416IniArray iniBank6;\n\tstruct ar5416IniArray iniAddac;\n\tstruct ar5416IniArray iniPcieSerdes;\n\tstruct ar5416IniArray iniPcieSerdesLowPower;\n\tstruct ar5416IniArray iniModesFastClock;\n\tstruct ar5416IniArray iniAdditional;\n\tstruct ar5416IniArray iniModesRxGain;\n\tstruct ar5416IniArray ini_modes_rx_gain_bounds;\n\tstruct ar5416IniArray iniModesTxGain;\n\tstruct ar5416IniArray iniCckfirNormal;\n\tstruct ar5416IniArray iniCckfirJapan2484;\n\tstruct ar5416IniArray iniModes_9271_ANI_reg;\n\tstruct ar5416IniArray ini_radio_post_sys2ant;\n\tstruct ar5416IniArray ini_modes_rxgain_xlna;\n\tstruct ar5416IniArray ini_modes_rxgain_bb_core;\n\tstruct ar5416IniArray ini_modes_rxgain_bb_postamble;\n\n\tstruct ar5416IniArray iniMac[ATH_INI_NUM_SPLIT];\n\tstruct ar5416IniArray iniBB[ATH_INI_NUM_SPLIT];\n\tstruct ar5416IniArray iniRadio[ATH_INI_NUM_SPLIT];\n\tstruct ar5416IniArray iniSOC[ATH_INI_NUM_SPLIT];\n\n\tu32 intr_gen_timer_trigger;\n\tu32 intr_gen_timer_thresh;\n\tstruct ath_gen_timer_table hw_gen_timers;\n\n\tstruct ar9003_txs *ts_ring;\n\tu32 ts_paddr_start;\n\tu32 ts_paddr_end;\n\tu16 ts_tail;\n\tu16 ts_size;\n\n\tu32 bb_watchdog_last_status;\n\tu32 bb_watchdog_timeout_ms;  \n\tu8 bb_hang_rx_ofdm;  \n\n\tunsigned int paprd_target_power;\n\tunsigned int paprd_training_power;\n\tunsigned int paprd_ratemask;\n\tunsigned int paprd_ratemask_ht40;\n\tbool paprd_table_write_done;\n\tu32 paprd_gain_table_entries[PAPRD_GAIN_TABLE_ENTRIES];\n\tu8 paprd_gain_table_index[PAPRD_GAIN_TABLE_ENTRIES];\n\t \n\tu32 WARegVal;\n\n\t \n\tu32 ent_mode;\n\n#ifdef CONFIG_ATH9K_WOW\n\tstruct ath9k_hw_wow wow;\n#endif\n\tbool is_clk_25mhz;\n\tint (*get_mac_revision)(void);\n\tint (*external_reset)(void);\n\tbool disable_2ghz;\n\tbool disable_5ghz;\n\n\tconst struct firmware *eeprom_blob;\n\tu16 *nvmem_blob;\t \n\tsize_t nvmem_blob_len;\n\n\tstruct ath_dynack dynack;\n\n\tbool tpc_enabled;\n\tu8 tx_power[Ar5416RateSize];\n\tu8 tx_power_stbc[Ar5416RateSize];\n\tbool msi_enabled;\n\tu32 msi_mask;\n\tu32 msi_reg;\n};\n\nstruct ath_bus_ops {\n\tenum ath_bus_type ath_bus_type;\n\tvoid (*read_cachesize)(struct ath_common *common, int *csz);\n\tbool (*eeprom_read)(struct ath_common *common, u32 off, u16 *data);\n\tvoid (*bt_coex_prep)(struct ath_common *common);\n\tvoid (*aspm_init)(struct ath_common *common);\n};\n\nstatic inline struct ath_common *ath9k_hw_common(struct ath_hw *ah)\n{\n\treturn &ah->common;\n}\n\nstatic inline struct ath_regulatory *ath9k_hw_regulatory(struct ath_hw *ah)\n{\n\treturn &(ath9k_hw_common(ah)->regulatory);\n}\n\nstatic inline struct ath_hw_private_ops *ath9k_hw_private_ops(struct ath_hw *ah)\n{\n\treturn &ah->private_ops;\n}\n\nstatic inline struct ath_hw_ops *ath9k_hw_ops(struct ath_hw *ah)\n{\n\treturn &ah->ops;\n}\n\nstatic inline u8 get_streams(int mask)\n{\n\treturn !!(mask & BIT(0)) + !!(mask & BIT(1)) + !!(mask & BIT(2));\n}\n\n \nvoid ath9k_hw_deinit(struct ath_hw *ah);\nint ath9k_hw_init(struct ath_hw *ah);\nint ath9k_hw_reset(struct ath_hw *ah, struct ath9k_channel *chan,\n\t\t   struct ath9k_hw_cal_data *caldata, bool fastcc);\nint ath9k_hw_fill_cap_info(struct ath_hw *ah);\nu32 ath9k_regd_get_ctl(struct ath_regulatory *reg, struct ath9k_channel *chan);\n\n \nvoid ath9k_hw_gpio_request_in(struct ath_hw *ah, u32 gpio, const char *label);\nvoid ath9k_hw_gpio_request_out(struct ath_hw *ah, u32 gpio, const char *label,\n\t\t\t       u32 ah_signal_type);\nvoid ath9k_hw_gpio_free(struct ath_hw *ah, u32 gpio);\nu32 ath9k_hw_gpio_get(struct ath_hw *ah, u32 gpio);\nvoid ath9k_hw_set_gpio(struct ath_hw *ah, u32 gpio, u32 val);\nvoid ath9k_hw_setantenna(struct ath_hw *ah, u32 antenna);\n\n \nvoid ath9k_hw_synth_delay(struct ath_hw *ah, struct ath9k_channel *chan,\n\t\t\t  int hw_delay);\nbool ath9k_hw_wait(struct ath_hw *ah, u32 reg, u32 mask, u32 val, u32 timeout);\nvoid ath9k_hw_write_array(struct ath_hw *ah, const struct ar5416IniArray *array,\n\t\t\t  int column, unsigned int *writecnt);\nvoid ath9k_hw_read_array(struct ath_hw *ah, u32 array[][2], int size);\nu32 ath9k_hw_reverse_bits(u32 val, u32 n);\nu16 ath9k_hw_computetxtime(struct ath_hw *ah,\n\t\t\t   u8 phy, int kbps,\n\t\t\t   u32 frameLen, u16 rateix, bool shortPreamble);\nvoid ath9k_hw_get_channel_centers(struct ath_hw *ah,\n\t\t\t\t  struct ath9k_channel *chan,\n\t\t\t\t  struct chan_centers *centers);\nu32 ath9k_hw_getrxfilter(struct ath_hw *ah);\nvoid ath9k_hw_setrxfilter(struct ath_hw *ah, u32 bits);\nbool ath9k_hw_phy_disable(struct ath_hw *ah);\nbool ath9k_hw_disable(struct ath_hw *ah);\nvoid ath9k_hw_set_txpowerlimit(struct ath_hw *ah, u32 limit, bool test);\nvoid ath9k_hw_setopmode(struct ath_hw *ah);\nvoid ath9k_hw_setmcastfilter(struct ath_hw *ah, u32 filter0, u32 filter1);\nvoid ath9k_hw_write_associd(struct ath_hw *ah);\nu32 ath9k_hw_gettsf32(struct ath_hw *ah);\nu64 ath9k_hw_gettsf64(struct ath_hw *ah);\nvoid ath9k_hw_settsf64(struct ath_hw *ah, u64 tsf64);\nvoid ath9k_hw_reset_tsf(struct ath_hw *ah);\nu32 ath9k_hw_get_tsf_offset(struct timespec64 *last, struct timespec64 *cur);\nvoid ath9k_hw_set_tsfadjust(struct ath_hw *ah, bool set);\nvoid ath9k_hw_init_global_settings(struct ath_hw *ah);\nu32 ar9003_get_pll_sqsum_dvc(struct ath_hw *ah);\nvoid ath9k_hw_set11nmac2040(struct ath_hw *ah, struct ath9k_channel *chan);\nvoid ath9k_hw_beaconinit(struct ath_hw *ah, u32 next_beacon, u32 beacon_period);\nvoid ath9k_hw_set_sta_beacon_timers(struct ath_hw *ah,\n\t\t\t\t    const struct ath9k_beacon_state *bs);\nvoid ath9k_hw_check_nav(struct ath_hw *ah);\nbool ath9k_hw_check_alive(struct ath_hw *ah);\n\nbool ath9k_hw_setpower(struct ath_hw *ah, enum ath9k_power_mode mode);\n\n \nstruct ath_gen_timer *ath_gen_timer_alloc(struct ath_hw *ah,\n\t\t\t\t\t  void (*trigger)(void *),\n\t\t\t\t\t  void (*overflow)(void *),\n\t\t\t\t\t  void *arg,\n\t\t\t\t\t  u8 timer_index);\nvoid ath9k_hw_gen_timer_start(struct ath_hw *ah,\n\t\t\t      struct ath_gen_timer *timer,\n\t\t\t      u32 timer_next,\n\t\t\t      u32 timer_period);\nvoid ath9k_hw_gen_timer_start_tsf2(struct ath_hw *ah);\nvoid ath9k_hw_gen_timer_stop(struct ath_hw *ah, struct ath_gen_timer *timer);\n\nvoid ath_gen_timer_free(struct ath_hw *ah, struct ath_gen_timer *timer);\nvoid ath_gen_timer_isr(struct ath_hw *hw);\n\nvoid ath9k_hw_name(struct ath_hw *ah, char *hw_name, size_t len);\n\n \nvoid ath9k_hw_get_delta_slope_vals(struct ath_hw *ah, u32 coef_scaled,\n\t\t\t\t   u32 *coef_mantissa, u32 *coef_exponent);\nvoid ath9k_hw_apply_txpower(struct ath_hw *ah, struct ath9k_channel *chan,\n\t\t\t    bool test);\n\n \nint ar9002_hw_rf_claim(struct ath_hw *ah);\nvoid ar9002_hw_enable_async_fifo(struct ath_hw *ah);\n\n \nbool ar9003_hw_bb_watchdog_check(struct ath_hw *ah);\nvoid ar9003_hw_bb_watchdog_config(struct ath_hw *ah);\nvoid ar9003_hw_bb_watchdog_read(struct ath_hw *ah);\nvoid ar9003_hw_bb_watchdog_dbg_info(struct ath_hw *ah);\nvoid ar9003_hw_disable_phy_restart(struct ath_hw *ah);\nvoid ar9003_paprd_enable(struct ath_hw *ah, bool val);\nvoid ar9003_paprd_populate_single_table(struct ath_hw *ah,\n\t\t\t\t\tstruct ath9k_hw_cal_data *caldata,\n\t\t\t\t\tint chain);\nint ar9003_paprd_create_curve(struct ath_hw *ah,\n\t\t\t      struct ath9k_hw_cal_data *caldata, int chain);\nvoid ar9003_paprd_setup_gain_table(struct ath_hw *ah, int chain);\nint ar9003_paprd_init_table(struct ath_hw *ah);\nbool ar9003_paprd_is_done(struct ath_hw *ah);\nbool ar9003_is_paprd_enabled(struct ath_hw *ah);\nvoid ar9003_hw_set_chain_masks(struct ath_hw *ah, u8 rx, u8 tx);\nvoid ar9003_hw_init_rate_txpower(struct ath_hw *ah, u8 *rate_array,\n\t\t\t\t struct ath9k_channel *chan);\nvoid ar5008_hw_cmn_spur_mitigate(struct ath_hw *ah,\n\t\t\t\t struct ath9k_channel *chan, int bin);\nvoid ar5008_hw_init_rate_txpower(struct ath_hw *ah, int16_t *rate_array,\n\t\t\t\t struct ath9k_channel *chan, int ht40_delta);\n\n \nint ar5008_hw_attach_phy_ops(struct ath_hw *ah);\nvoid ar9002_hw_attach_phy_ops(struct ath_hw *ah);\nvoid ar9003_hw_attach_phy_ops(struct ath_hw *ah);\n\nvoid ar9002_hw_attach_calib_ops(struct ath_hw *ah);\nvoid ar9003_hw_attach_calib_ops(struct ath_hw *ah);\n\nint ar9002_hw_attach_ops(struct ath_hw *ah);\nvoid ar9003_hw_attach_ops(struct ath_hw *ah);\n\nvoid ar9002_hw_load_ani_reg(struct ath_hw *ah, struct ath9k_channel *chan);\n\nvoid ath9k_ani_reset(struct ath_hw *ah, bool is_scanning);\nvoid ath9k_hw_ani_monitor(struct ath_hw *ah, struct ath9k_channel *chan);\n\nvoid ath9k_hw_set_ack_timeout(struct ath_hw *ah, u32 us);\nvoid ath9k_hw_set_cts_timeout(struct ath_hw *ah, u32 us);\nvoid ath9k_hw_setslottime(struct ath_hw *ah, u32 us);\n\n#ifdef CONFIG_ATH9K_BTCOEX_SUPPORT\nvoid ar9003_hw_attach_aic_ops(struct ath_hw *ah);\nstatic inline bool ath9k_hw_btcoex_is_enabled(struct ath_hw *ah)\n{\n\treturn ah->btcoex_hw.enabled;\n}\nstatic inline bool ath9k_hw_mci_is_enabled(struct ath_hw *ah)\n{\n\treturn ah->common.btcoex_enabled &&\n\t       (ah->caps.hw_caps & ATH9K_HW_CAP_MCI);\n\n}\nvoid ath9k_hw_btcoex_enable(struct ath_hw *ah);\nstatic inline enum ath_btcoex_scheme\nath9k_hw_get_btcoex_scheme(struct ath_hw *ah)\n{\n\treturn ah->btcoex_hw.scheme;\n}\n#else\nstatic inline void ar9003_hw_attach_aic_ops(struct ath_hw *ah)\n{\n}\nstatic inline bool ath9k_hw_btcoex_is_enabled(struct ath_hw *ah)\n{\n\treturn false;\n}\nstatic inline bool ath9k_hw_mci_is_enabled(struct ath_hw *ah)\n{\n\treturn false;\n}\nstatic inline void ath9k_hw_btcoex_enable(struct ath_hw *ah)\n{\n}\nstatic inline enum ath_btcoex_scheme\nath9k_hw_get_btcoex_scheme(struct ath_hw *ah)\n{\n\treturn ATH_BTCOEX_CFG_NONE;\n}\n#endif  \n\n\n#ifdef CONFIG_ATH9K_WOW\nint ath9k_hw_wow_apply_pattern(struct ath_hw *ah, u8 *user_pattern,\n\t\t\t       u8 *user_mask, int pattern_count,\n\t\t\t       int pattern_len);\nu32 ath9k_hw_wow_wakeup(struct ath_hw *ah);\nvoid ath9k_hw_wow_enable(struct ath_hw *ah, u32 pattern_enable);\n#else\nstatic inline int ath9k_hw_wow_apply_pattern(struct ath_hw *ah,\n\t\t\t\t\t     u8 *user_pattern,\n\t\t\t\t\t     u8 *user_mask,\n\t\t\t\t\t     int pattern_count,\n\t\t\t\t\t     int pattern_len)\n{\n\treturn 0;\n}\nstatic inline u32 ath9k_hw_wow_wakeup(struct ath_hw *ah)\n{\n\treturn 0;\n}\nstatic inline void ath9k_hw_wow_enable(struct ath_hw *ah, u32 pattern_enable)\n{\n}\n#endif\n\n#define ATH9K_CLOCK_RATE_CCK\t\t22\n#define ATH9K_CLOCK_RATE_5GHZ_OFDM\t40\n#define ATH9K_CLOCK_RATE_2GHZ_OFDM\t44\n#define ATH9K_CLOCK_FAST_RATE_5GHZ_OFDM 44\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}