{
  "module_name": "dynack.c",
  "hash_id": "c35dc7fc0d4cb203af41ccfc6debb67895ad92b633b7632a63e3280d91bcbf1a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath9k/dynack.c",
  "human_readable_source": " \n\n#include \"ath9k.h\"\n#include \"hw.h\"\n#include \"dynack.h\"\n\n#define COMPUTE_TO\t\t(5 * HZ)\n#define LATEACK_DELAY\t\t(10 * HZ)\n#define EWMA_LEVEL\t\t96\n#define EWMA_DIV\t\t128\n\n \nstatic u32 ath_dynack_get_max_to(struct ath_hw *ah)\n{\n\tconst struct ath9k_channel *chan = ah->curchan;\n\n\tif (!chan)\n\t\treturn 300;\n\n\tif (IS_CHAN_HT40(chan))\n\t\treturn 300;\n\tif (IS_CHAN_HALF_RATE(chan))\n\t\treturn 750;\n\tif (IS_CHAN_QUARTER_RATE(chan))\n\t\treturn 1500;\n\treturn 600;\n}\n\n \nstatic inline int ath_dynack_ewma(int old, int new)\n{\n\tif (old > 0)\n\t\treturn (new * (EWMA_DIV - EWMA_LEVEL) +\n\t\t\told * EWMA_LEVEL) / EWMA_DIV;\n\telse\n\t\treturn new;\n}\n\n \nstatic inline u32 ath_dynack_get_sifs(struct ath_hw *ah, int phy)\n{\n\tu32 sifs = CCK_SIFS_TIME;\n\n\tif (phy == WLAN_RC_PHY_OFDM) {\n\t\tif (IS_CHAN_QUARTER_RATE(ah->curchan))\n\t\t\tsifs = OFDM_SIFS_TIME_QUARTER;\n\t\telse if (IS_CHAN_HALF_RATE(ah->curchan))\n\t\t\tsifs = OFDM_SIFS_TIME_HALF;\n\t\telse\n\t\t\tsifs = OFDM_SIFS_TIME;\n\t}\n\treturn sifs;\n}\n\n \nstatic inline bool ath_dynack_bssidmask(struct ath_hw *ah, const u8 *mac)\n{\n\tint i;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\n\tfor (i = 0; i < ETH_ALEN; i++) {\n\t\tif ((common->macaddr[i] & common->bssidmask[i]) !=\n\t\t    (mac[i] & common->bssidmask[i]))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic void ath_dynack_set_timeout(struct ath_hw *ah, int to)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tint slottime = (to - 3) / 2;\n\n\tath_dbg(common, DYNACK, \"ACK timeout %u slottime %u\\n\",\n\t\tto, slottime);\n\tath9k_hw_setslottime(ah, slottime);\n\tath9k_hw_set_ack_timeout(ah, to);\n\tath9k_hw_set_cts_timeout(ah, to);\n}\n\n \nstatic void ath_dynack_compute_ackto(struct ath_hw *ah)\n{\n\tstruct ath_dynack *da = &ah->dynack;\n\tstruct ath_node *an;\n\tint to = 0;\n\n\tlist_for_each_entry(an, &da->nodes, list)\n\t\tif (an->ackto > to)\n\t\t\tto = an->ackto;\n\n\tif (to && da->ackto != to) {\n\t\tath_dynack_set_timeout(ah, to);\n\t\tda->ackto = to;\n\t}\n}\n\n \nstatic void ath_dynack_compute_to(struct ath_hw *ah)\n{\n\tstruct ath_dynack *da = &ah->dynack;\n\tu32 ackto, ack_ts, max_to;\n\tstruct ieee80211_sta *sta;\n\tstruct ts_info *st_ts;\n\tstruct ath_node *an;\n\tu8 *dst, *src;\n\n\trcu_read_lock();\n\n\tmax_to = ath_dynack_get_max_to(ah);\n\twhile (da->st_rbf.h_rb != da->st_rbf.t_rb &&\n\t       da->ack_rbf.h_rb != da->ack_rbf.t_rb) {\n\t\tack_ts = da->ack_rbf.tstamp[da->ack_rbf.h_rb];\n\t\tst_ts = &da->st_rbf.ts[da->st_rbf.h_rb];\n\t\tdst = da->st_rbf.addr[da->st_rbf.h_rb].h_dest;\n\t\tsrc = da->st_rbf.addr[da->st_rbf.h_rb].h_src;\n\n\t\tath_dbg(ath9k_hw_common(ah), DYNACK,\n\t\t\t\"ack_ts %u st_ts %u st_dur %u [%u-%u]\\n\",\n\t\t\tack_ts, st_ts->tstamp, st_ts->dur,\n\t\t\tda->ack_rbf.h_rb, da->st_rbf.h_rb);\n\n\t\tif (ack_ts > st_ts->tstamp + st_ts->dur) {\n\t\t\tackto = ack_ts - st_ts->tstamp - st_ts->dur;\n\n\t\t\tif (ackto < max_to) {\n\t\t\t\tsta = ieee80211_find_sta_by_ifaddr(ah->hw, dst,\n\t\t\t\t\t\t\t\t   src);\n\t\t\t\tif (sta) {\n\t\t\t\t\tan = (struct ath_node *)sta->drv_priv;\n\t\t\t\t\tan->ackto = ath_dynack_ewma(an->ackto,\n\t\t\t\t\t\t\t\t    ackto);\n\t\t\t\t\tath_dbg(ath9k_hw_common(ah), DYNACK,\n\t\t\t\t\t\t\"%pM to %d [%u]\\n\", dst,\n\t\t\t\t\t\tan->ackto, ackto);\n\t\t\t\t\tif (time_is_before_jiffies(da->lto)) {\n\t\t\t\t\t\tath_dynack_compute_ackto(ah);\n\t\t\t\t\t\tda->lto = jiffies + COMPUTE_TO;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tINCR(da->ack_rbf.h_rb, ATH_DYN_BUF);\n\t\t\t}\n\t\t\tINCR(da->st_rbf.h_rb, ATH_DYN_BUF);\n\t\t} else {\n\t\t\tINCR(da->ack_rbf.h_rb, ATH_DYN_BUF);\n\t\t}\n\t}\n\n\trcu_read_unlock();\n}\n\n \nvoid ath_dynack_sample_tx_ts(struct ath_hw *ah, struct sk_buff *skb,\n\t\t\t     struct ath_tx_status *ts,\n\t\t\t     struct ieee80211_sta *sta)\n{\n\tstruct ieee80211_hdr *hdr;\n\tstruct ath_dynack *da = &ah->dynack;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tu32 dur = ts->duration;\n\tu8 ridx;\n\n\tif (!da->enabled || (info->flags & IEEE80211_TX_CTL_NO_ACK))\n\t\treturn;\n\n\tspin_lock_bh(&da->qlock);\n\n\thdr = (struct ieee80211_hdr *)skb->data;\n\n\t \n\tif (ts->ts_status & ATH9K_TXERR_XRETRY) {\n\t\tif (ieee80211_is_assoc_req(hdr->frame_control) ||\n\t\t    ieee80211_is_assoc_resp(hdr->frame_control) ||\n\t\t    ieee80211_is_auth(hdr->frame_control)) {\n\t\t\tu32 max_to = ath_dynack_get_max_to(ah);\n\n\t\t\tath_dbg(common, DYNACK, \"late ack\\n\");\n\t\t\tath_dynack_set_timeout(ah, max_to);\n\t\t\tif (sta) {\n\t\t\t\tstruct ath_node *an;\n\n\t\t\t\tan = (struct ath_node *)sta->drv_priv;\n\t\t\t\tan->ackto = -1;\n\t\t\t}\n\t\t\tda->lto = jiffies + LATEACK_DELAY;\n\t\t}\n\n\t\tspin_unlock_bh(&da->qlock);\n\t\treturn;\n\t}\n\n\tridx = ts->ts_rateindex;\n\n\tda->st_rbf.ts[da->st_rbf.t_rb].tstamp = ts->ts_tstamp;\n\n\t \n\tmemcpy(da->st_rbf.addr[da->st_rbf.t_rb].h_dest, hdr->addr1, ETH_ALEN);\n\tmemcpy(da->st_rbf.addr[da->st_rbf.t_rb].h_src, hdr->addr2, ETH_ALEN);\n\n\tif (!(info->status.rates[ridx].flags & IEEE80211_TX_RC_MCS)) {\n\t\tconst struct ieee80211_rate *rate;\n\t\tstruct ieee80211_tx_rate *rates = info->status.rates;\n\t\tu32 phy;\n\n\t\trate = &common->sbands[info->band].bitrates[rates[ridx].idx];\n\t\tif (info->band == NL80211_BAND_2GHZ &&\n\t\t    !(rate->flags & IEEE80211_RATE_ERP_G))\n\t\t\tphy = WLAN_RC_PHY_CCK;\n\t\telse\n\t\t\tphy = WLAN_RC_PHY_OFDM;\n\n\t\tdur -= ath_dynack_get_sifs(ah, phy);\n\t}\n\tda->st_rbf.ts[da->st_rbf.t_rb].dur = dur;\n\n\tINCR(da->st_rbf.t_rb, ATH_DYN_BUF);\n\tif (da->st_rbf.t_rb == da->st_rbf.h_rb)\n\t\tINCR(da->st_rbf.h_rb, ATH_DYN_BUF);\n\n\tath_dbg(common, DYNACK, \"{%pM} tx sample %u [dur %u][h %u-t %u]\\n\",\n\t\thdr->addr1, ts->ts_tstamp, dur, da->st_rbf.h_rb,\n\t\tda->st_rbf.t_rb);\n\n\tath_dynack_compute_to(ah);\n\n\tspin_unlock_bh(&da->qlock);\n}\nEXPORT_SYMBOL(ath_dynack_sample_tx_ts);\n\n \nvoid ath_dynack_sample_ack_ts(struct ath_hw *ah, struct sk_buff *skb,\n\t\t\t      u32 ts)\n{\n\tstruct ath_dynack *da = &ah->dynack;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\n\tif (!da->enabled || !ath_dynack_bssidmask(ah, hdr->addr1))\n\t\treturn;\n\n\tspin_lock_bh(&da->qlock);\n\tda->ack_rbf.tstamp[da->ack_rbf.t_rb] = ts;\n\n\tINCR(da->ack_rbf.t_rb, ATH_DYN_BUF);\n\tif (da->ack_rbf.t_rb == da->ack_rbf.h_rb)\n\t\tINCR(da->ack_rbf.h_rb, ATH_DYN_BUF);\n\n\tath_dbg(common, DYNACK, \"rx sample %u [h %u-t %u]\\n\",\n\t\tts, da->ack_rbf.h_rb, da->ack_rbf.t_rb);\n\n\tath_dynack_compute_to(ah);\n\n\tspin_unlock_bh(&da->qlock);\n}\nEXPORT_SYMBOL(ath_dynack_sample_ack_ts);\n\n \nvoid ath_dynack_node_init(struct ath_hw *ah, struct ath_node *an)\n{\n\tstruct ath_dynack *da = &ah->dynack;\n\n\tan->ackto = da->ackto;\n\n\tspin_lock_bh(&da->qlock);\n\tlist_add_tail(&an->list, &da->nodes);\n\tspin_unlock_bh(&da->qlock);\n}\nEXPORT_SYMBOL(ath_dynack_node_init);\n\n \nvoid ath_dynack_node_deinit(struct ath_hw *ah, struct ath_node *an)\n{\n\tstruct ath_dynack *da = &ah->dynack;\n\n\tspin_lock_bh(&da->qlock);\n\tlist_del(&an->list);\n\tspin_unlock_bh(&da->qlock);\n}\nEXPORT_SYMBOL(ath_dynack_node_deinit);\n\n \nvoid ath_dynack_reset(struct ath_hw *ah)\n{\n\tstruct ath_dynack *da = &ah->dynack;\n\tstruct ath_node *an;\n\n\tspin_lock_bh(&da->qlock);\n\n\tda->lto = jiffies + COMPUTE_TO;\n\n\tda->st_rbf.t_rb = 0;\n\tda->st_rbf.h_rb = 0;\n\tda->ack_rbf.t_rb = 0;\n\tda->ack_rbf.h_rb = 0;\n\n\tda->ackto = ath_dynack_get_max_to(ah);\n\tlist_for_each_entry(an, &da->nodes, list)\n\t\tan->ackto = da->ackto;\n\n\t \n\tath_dynack_set_timeout(ah, da->ackto);\n\n\tspin_unlock_bh(&da->qlock);\n}\nEXPORT_SYMBOL(ath_dynack_reset);\n\n \nvoid ath_dynack_init(struct ath_hw *ah)\n{\n\tstruct ath_dynack *da = &ah->dynack;\n\n\tmemset(da, 0, sizeof(struct ath_dynack));\n\n\tspin_lock_init(&da->qlock);\n\tINIT_LIST_HEAD(&da->nodes);\n\t \n\tda->ackto = 9 + 16 + 64;\n\n\tah->hw->wiphy->features |= NL80211_FEATURE_ACKTO_ESTIMATION;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}