{
  "module_name": "common-beacon.c",
  "hash_id": "eb5ab1527fa279393f704a1bba324675d8c7cecfdc3ea3e5925e61924e0a19c3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath9k/common-beacon.c",
  "human_readable_source": " \n\n#include \"common.h\"\n\n#define FUDGE 2\n\nstatic u32 ath9k_get_next_tbtt(struct ath_hw *ah, u64 tsf,\n\t\t\t       unsigned int interval)\n{\n\tunsigned int offset, divisor;\n\n\ttsf += TU_TO_USEC(FUDGE + ah->config.sw_beacon_response_time);\n\tdivisor = TU_TO_USEC(interval);\n\tdiv_u64_rem(tsf, divisor, &offset);\n\n\treturn (u32) tsf + divisor - offset;\n}\n\n \nint ath9k_cmn_beacon_config_sta(struct ath_hw *ah,\n\t\t\t\t struct ath_beacon_config *conf,\n\t\t\t\t struct ath9k_beacon_state *bs)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tint dtim_intval;\n\tu64 tsf;\n\n\t \n\tif (!test_bit(ATH_OP_PRIM_STA_VIF, &common->op_flags)) {\n\t\tath_dbg(common, BEACON,\n\t\t\t\"STA is not yet associated..skipping beacon config\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tmemset(bs, 0, sizeof(*bs));\n\tconf->intval = conf->beacon_interval;\n\n\t \n\tdtim_intval = conf->intval * conf->dtim_period;\n\n\t \n\ttsf = ath9k_hw_gettsf64(ah);\n\tconf->nexttbtt = ath9k_get_next_tbtt(ah, tsf, conf->intval);\n\n\tbs->bs_intval = TU_TO_USEC(conf->intval);\n\tbs->bs_dtimperiod = conf->dtim_period * bs->bs_intval;\n\tbs->bs_nexttbtt = conf->nexttbtt;\n\tbs->bs_nextdtim = conf->nexttbtt;\n\tif (conf->dtim_period > 1)\n\t\tbs->bs_nextdtim = ath9k_get_next_tbtt(ah, tsf, dtim_intval);\n\n\t \n\tbs->bs_bmissthreshold = DIV_ROUND_UP(conf->bmiss_timeout, conf->intval);\n\tif (bs->bs_bmissthreshold > 15)\n\t\tbs->bs_bmissthreshold = 15;\n\telse if (bs->bs_bmissthreshold <= 0)\n\t\tbs->bs_bmissthreshold = 1;\n\n\t \n\n\tbs->bs_sleepduration = TU_TO_USEC(roundup(IEEE80211_MS_TO_TU(100),\n\t\t\t\t\t\t  conf->intval));\n\tif (bs->bs_sleepduration > bs->bs_dtimperiod)\n\t\tbs->bs_sleepduration = bs->bs_dtimperiod;\n\n\t \n\tbs->bs_tsfoor_threshold = ATH9K_TSFOOR_THRESHOLD;\n\n\tath_dbg(common, BEACON, \"bmiss: %u sleep: %u\\n\",\n\t\tbs->bs_bmissthreshold, bs->bs_sleepduration);\n\treturn 0;\n}\nEXPORT_SYMBOL(ath9k_cmn_beacon_config_sta);\n\nvoid ath9k_cmn_beacon_config_adhoc(struct ath_hw *ah,\n\t\t\t\t   struct ath_beacon_config *conf)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\n\tconf->intval = TU_TO_USEC(conf->beacon_interval);\n\n\tif (conf->ibss_creator)\n\t\tconf->nexttbtt = conf->intval;\n\telse\n\t\tconf->nexttbtt = ath9k_get_next_tbtt(ah, ath9k_hw_gettsf64(ah),\n\t\t\t\t\t       conf->beacon_interval);\n\n\tif (conf->enable_beacon)\n\t\tah->imask |= ATH9K_INT_SWBA;\n\telse\n\t\tah->imask &= ~ATH9K_INT_SWBA;\n\n\tath_dbg(common, BEACON,\n\t\t\"IBSS (%s) nexttbtt: %u intval: %u conf_intval: %u\\n\",\n\t\t(conf->enable_beacon) ? \"Enable\" : \"Disable\",\n\t\tconf->nexttbtt, conf->intval, conf->beacon_interval);\n}\nEXPORT_SYMBOL(ath9k_cmn_beacon_config_adhoc);\n\n \nvoid ath9k_cmn_beacon_config_ap(struct ath_hw *ah,\n\t\t\t\tstruct ath_beacon_config *conf,\n\t\t\t\tunsigned int bc_buf)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\n\t \n\tconf->intval = TU_TO_USEC(conf->beacon_interval);\n\tconf->intval /= bc_buf;\n\tconf->nexttbtt = ath9k_get_next_tbtt(ah, ath9k_hw_gettsf64(ah),\n\t\t\t\t       conf->beacon_interval);\n\n\tif (conf->enable_beacon)\n\t\tah->imask |= ATH9K_INT_SWBA;\n\telse\n\t\tah->imask &= ~ATH9K_INT_SWBA;\n\n\tath_dbg(common, BEACON,\n\t\t\"AP (%s) nexttbtt: %u intval: %u conf_intval: %u\\n\",\n\t\t(conf->enable_beacon) ? \"Enable\" : \"Disable\",\n\t\tconf->nexttbtt, conf->intval, conf->beacon_interval);\n}\nEXPORT_SYMBOL(ath9k_cmn_beacon_config_ap);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}