{
  "module_name": "mci.c",
  "hash_id": "233dcdd33ab4957d110cb6af3a1d60aa297c494d1f2ef972342ee571812128d7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath9k/mci.c",
  "human_readable_source": " \n\n#include <linux/dma-mapping.h>\n#include <linux/slab.h>\n\n#include \"ath9k.h\"\n#include \"mci.h\"\n\nstatic const u8 ath_mci_duty_cycle[] = { 55, 50, 60, 70, 80, 85, 90, 95, 98 };\n\nstatic struct ath_mci_profile_info*\nath_mci_find_profile(struct ath_mci_profile *mci,\n\t\t     struct ath_mci_profile_info *info)\n{\n\tstruct ath_mci_profile_info *entry;\n\n\tif (list_empty(&mci->info))\n\t\treturn NULL;\n\n\tlist_for_each_entry(entry, &mci->info, list) {\n\t\tif (entry->conn_handle == info->conn_handle)\n\t\t\treturn entry;\n\t}\n\treturn NULL;\n}\n\nstatic bool ath_mci_add_profile(struct ath_common *common,\n\t\t\t\tstruct ath_mci_profile *mci,\n\t\t\t\tstruct ath_mci_profile_info *info)\n{\n\tstruct ath_mci_profile_info *entry;\n\tstatic const u8 voice_priority[] = { 110, 110, 110, 112, 110, 110, 114, 116, 118 };\n\n\tif ((mci->num_sco == ATH_MCI_MAX_SCO_PROFILE) &&\n\t    (info->type == MCI_GPM_COEX_PROFILE_VOICE))\n\t\treturn false;\n\n\tif (((NUM_PROF(mci) - mci->num_sco) == ATH_MCI_MAX_ACL_PROFILE) &&\n\t    (info->type != MCI_GPM_COEX_PROFILE_VOICE))\n\t\treturn false;\n\n\tentry = kzalloc(sizeof(*entry), GFP_ATOMIC);\n\tif (!entry)\n\t\treturn false;\n\n\tmemcpy(entry, info, 10);\n\tINC_PROF(mci, info);\n\tlist_add_tail(&entry->list, &mci->info);\n\tif (info->type == MCI_GPM_COEX_PROFILE_VOICE) {\n\t\tif (info->voice_type < sizeof(voice_priority))\n\t\t\tmci->voice_priority = voice_priority[info->voice_type];\n\t\telse\n\t\t\tmci->voice_priority = 110;\n\t}\n\n\treturn true;\n}\n\nstatic void ath_mci_del_profile(struct ath_common *common,\n\t\t\t\tstruct ath_mci_profile *mci,\n\t\t\t\tstruct ath_mci_profile_info *entry)\n{\n\tif (!entry)\n\t\treturn;\n\n\tDEC_PROF(mci, entry);\n\tlist_del(&entry->list);\n\tkfree(entry);\n}\n\nvoid ath_mci_flush_profile(struct ath_mci_profile *mci)\n{\n\tstruct ath_mci_profile_info *info, *tinfo;\n\n\tmci->aggr_limit = 0;\n\tmci->num_mgmt = 0;\n\n\tif (list_empty(&mci->info))\n\t\treturn;\n\n\tlist_for_each_entry_safe(info, tinfo, &mci->info, list) {\n\t\tlist_del(&info->list);\n\t\tDEC_PROF(mci, info);\n\t\tkfree(info);\n\t}\n}\n\nstatic void ath_mci_adjust_aggr_limit(struct ath_btcoex *btcoex)\n{\n\tstruct ath_mci_profile *mci = &btcoex->mci;\n\tu32 wlan_airtime = btcoex->btcoex_period *\n\t\t\t\t(100 - btcoex->duty_cycle) / 100;\n\n\t \n\tif ((wlan_airtime <= 4) &&\n\t    (!mci->aggr_limit || (mci->aggr_limit > (2 * wlan_airtime))))\n\t\tmci->aggr_limit = 2 * wlan_airtime;\n}\n\nstatic void ath_mci_update_scheme(struct ath_softc *sc)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ath_btcoex *btcoex = &sc->btcoex;\n\tstruct ath_mci_profile *mci = &btcoex->mci;\n\tstruct ath9k_hw_mci *mci_hw = &sc->sc_ah->btcoex_hw.mci;\n\tstruct ath_mci_profile_info *info;\n\tu32 num_profile = NUM_PROF(mci);\n\n\tif (mci_hw->config & ATH_MCI_CONFIG_DISABLE_TUNING)\n\t\tgoto skip_tuning;\n\n\tmci->aggr_limit = 0;\n\tbtcoex->duty_cycle = ath_mci_duty_cycle[num_profile];\n\tbtcoex->btcoex_period = ATH_MCI_DEF_BT_PERIOD;\n\tif (NUM_PROF(mci))\n\t\tbtcoex->bt_stomp_type = ATH_BTCOEX_STOMP_LOW;\n\telse\n\t\tbtcoex->bt_stomp_type = mci->num_mgmt ? ATH_BTCOEX_STOMP_ALL :\n\t\t\t\t\t\t\tATH_BTCOEX_STOMP_LOW;\n\n\tif (num_profile == 1) {\n\t\tinfo = list_first_entry(&mci->info,\n\t\t\t\t\tstruct ath_mci_profile_info,\n\t\t\t\t\tlist);\n\t\tif (mci->num_sco) {\n\t\t\tif (info->T == 12)\n\t\t\t\tmci->aggr_limit = 8;\n\t\t\telse if (info->T == 6) {\n\t\t\t\tmci->aggr_limit = 6;\n\t\t\t\tbtcoex->duty_cycle = 30;\n\t\t\t} else\n\t\t\t\tmci->aggr_limit = 6;\n\t\t\tath_dbg(common, MCI,\n\t\t\t\t\"Single SCO, aggregation limit %d 1/4 ms\\n\",\n\t\t\t\tmci->aggr_limit);\n\t\t} else if (mci->num_pan || mci->num_other_acl) {\n\t\t\t \n\t\t\tbtcoex->duty_cycle = AR_SREV_9565(sc->sc_ah) ? 40 : 35;\n\t\t\tbtcoex->btcoex_period = 53;\n\t\t\tath_dbg(common, MCI,\n\t\t\t\t\"Single PAN/FTP bt period %d ms dutycycle %d\\n\",\n\t\t\t\tbtcoex->duty_cycle, btcoex->btcoex_period);\n\t\t} else if (mci->num_hid) {\n\t\t\tbtcoex->duty_cycle = 30;\n\t\t\tmci->aggr_limit = 6;\n\t\t\tath_dbg(common, MCI,\n\t\t\t\t\"Multiple attempt/timeout single HID \"\n\t\t\t\t\"aggregation limit 1.5 ms dutycycle 30%%\\n\");\n\t\t}\n\t} else if (num_profile == 2) {\n\t\tif (mci->num_hid == 2)\n\t\t\tbtcoex->duty_cycle = 30;\n\t\tmci->aggr_limit = 6;\n\t\tath_dbg(common, MCI,\n\t\t\t\"Two BT profiles aggr limit 1.5 ms dutycycle %d%%\\n\",\n\t\t\tbtcoex->duty_cycle);\n\t} else if (num_profile >= 3) {\n\t\tmci->aggr_limit = 4;\n\t\tath_dbg(common, MCI,\n\t\t\t\"Three or more profiles aggregation limit 1 ms\\n\");\n\t}\n\nskip_tuning:\n\tif (IS_CHAN_2GHZ(sc->sc_ah->curchan)) {\n\t\tif (IS_CHAN_HT(sc->sc_ah->curchan))\n\t\t\tath_mci_adjust_aggr_limit(btcoex);\n\t\telse\n\t\t\tbtcoex->btcoex_period >>= 1;\n\t}\n\n\tath9k_btcoex_timer_pause(sc);\n\tath9k_hw_btcoex_disable(sc->sc_ah);\n\n\tif (IS_CHAN_5GHZ(sc->sc_ah->curchan))\n\t\treturn;\n\n\tbtcoex->duty_cycle += (mci->num_bdr ? ATH_MCI_BDR_DUTY_CYCLE : 0);\n\tif (btcoex->duty_cycle > ATH_MCI_MAX_DUTY_CYCLE)\n\t\tbtcoex->duty_cycle = ATH_MCI_MAX_DUTY_CYCLE;\n\n\tbtcoex->btcoex_no_stomp =  btcoex->btcoex_period *\n\t\t(100 - btcoex->duty_cycle) / 100;\n\n\tath9k_hw_btcoex_enable(sc->sc_ah);\n\tath9k_btcoex_timer_resume(sc);\n}\n\nstatic void ath_mci_cal_msg(struct ath_softc *sc, u8 opcode, u8 *rx_payload)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath9k_hw_mci *mci_hw = &ah->btcoex_hw.mci;\n\tu32 payload[4] = {0, 0, 0, 0};\n\n\tswitch (opcode) {\n\tcase MCI_GPM_BT_CAL_REQ:\n\t\tif (mci_hw->bt_state == MCI_BT_AWAKE) {\n\t\t\tmci_hw->bt_state = MCI_BT_CAL_START;\n\t\t\tath9k_queue_reset(sc, RESET_TYPE_MCI);\n\t\t}\n\t\tath_dbg(common, MCI, \"MCI State : %d\\n\", mci_hw->bt_state);\n\t\tbreak;\n\tcase MCI_GPM_BT_CAL_GRANT:\n\t\tMCI_GPM_SET_CAL_TYPE(payload, MCI_GPM_WLAN_CAL_DONE);\n\t\tar9003_mci_send_message(sc->sc_ah, MCI_GPM, 0, payload,\n\t\t\t\t\t16, false, true);\n\t\tbreak;\n\tdefault:\n\t\tath_dbg(common, MCI, \"Unknown GPM CAL message\\n\");\n\t\tbreak;\n\t}\n}\n\nstatic void ath9k_mci_work(struct work_struct *work)\n{\n\tstruct ath_softc *sc = container_of(work, struct ath_softc, mci_work);\n\n\tath_mci_update_scheme(sc);\n}\n\nstatic void ath_mci_update_stomp_txprio(u8 cur_txprio, u8 *stomp_prio)\n{\n\tif (cur_txprio < stomp_prio[ATH_BTCOEX_STOMP_NONE])\n\t\tstomp_prio[ATH_BTCOEX_STOMP_NONE] = cur_txprio;\n\n\tif (cur_txprio > stomp_prio[ATH_BTCOEX_STOMP_ALL])\n\t\tstomp_prio[ATH_BTCOEX_STOMP_ALL] = cur_txprio;\n\n\tif ((cur_txprio > ATH_MCI_HI_PRIO) &&\n\t    (cur_txprio < stomp_prio[ATH_BTCOEX_STOMP_LOW]))\n\t\tstomp_prio[ATH_BTCOEX_STOMP_LOW] = cur_txprio;\n}\n\nstatic void ath_mci_set_concur_txprio(struct ath_softc *sc)\n{\n\tstruct ath_btcoex *btcoex = &sc->btcoex;\n\tstruct ath_mci_profile *mci = &btcoex->mci;\n\tu8 stomp_txprio[ATH_BTCOEX_STOMP_MAX];\n\n\tmemset(stomp_txprio, 0, sizeof(stomp_txprio));\n\tif (mci->num_mgmt) {\n\t\tstomp_txprio[ATH_BTCOEX_STOMP_ALL] = ATH_MCI_INQUIRY_PRIO;\n\t\tif (!mci->num_pan && !mci->num_other_acl)\n\t\t\tstomp_txprio[ATH_BTCOEX_STOMP_NONE] =\n\t\t\t\tATH_MCI_INQUIRY_PRIO;\n\t} else {\n\t\tstatic const u8 prof_prio[] = {\n\t\t\t50, 90, 94, 52\n\t\t};  \n\n\t\tstomp_txprio[ATH_BTCOEX_STOMP_LOW] =\n\t\tstomp_txprio[ATH_BTCOEX_STOMP_NONE] = 0xff;\n\n\t\tif (mci->num_sco)\n\t\t\tath_mci_update_stomp_txprio(mci->voice_priority,\n\t\t\t\t\t\t    stomp_txprio);\n\t\tif (mci->num_other_acl)\n\t\t\tath_mci_update_stomp_txprio(prof_prio[0], stomp_txprio);\n\t\tif (mci->num_a2dp)\n\t\t\tath_mci_update_stomp_txprio(prof_prio[1], stomp_txprio);\n\t\tif (mci->num_hid)\n\t\t\tath_mci_update_stomp_txprio(prof_prio[2], stomp_txprio);\n\t\tif (mci->num_pan)\n\t\t\tath_mci_update_stomp_txprio(prof_prio[3], stomp_txprio);\n\n\t\tif (stomp_txprio[ATH_BTCOEX_STOMP_NONE] == 0xff)\n\t\t\tstomp_txprio[ATH_BTCOEX_STOMP_NONE] = 0;\n\n\t\tif (stomp_txprio[ATH_BTCOEX_STOMP_LOW] == 0xff)\n\t\t\tstomp_txprio[ATH_BTCOEX_STOMP_LOW] = 0;\n\t}\n\tath9k_hw_btcoex_set_concur_txprio(sc->sc_ah, stomp_txprio);\n}\n\nstatic u8 ath_mci_process_profile(struct ath_softc *sc,\n\t\t\t\t  struct ath_mci_profile_info *info)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ath_btcoex *btcoex = &sc->btcoex;\n\tstruct ath_mci_profile *mci = &btcoex->mci;\n\tstruct ath_mci_profile_info *entry = NULL;\n\n\tentry = ath_mci_find_profile(mci, info);\n\tif (entry) {\n\t\t \n\t\tif (entry->type != info->type) {\n\t\t\tDEC_PROF(mci, entry);\n\t\t\tINC_PROF(mci, info);\n\t\t}\n\t\tmemcpy(entry, info, 10);\n\t}\n\n\tif (info->start) {\n\t\tif (!entry && !ath_mci_add_profile(common, mci, info))\n\t\t\treturn 0;\n\t} else\n\t\tath_mci_del_profile(common, mci, entry);\n\n\tath_mci_set_concur_txprio(sc);\n\treturn 1;\n}\n\nstatic u8 ath_mci_process_status(struct ath_softc *sc,\n\t\t\t\t struct ath_mci_profile_status *status)\n{\n\tstruct ath_btcoex *btcoex = &sc->btcoex;\n\tstruct ath_mci_profile *mci = &btcoex->mci;\n\tstruct ath_mci_profile_info info;\n\tint i = 0, old_num_mgmt = mci->num_mgmt;\n\n\t \n\tif (status->is_link)\n\t\treturn 0;\n\n\tinfo.conn_handle = status->conn_handle;\n\tif (ath_mci_find_profile(mci, &info))\n\t\treturn 0;\n\n\tif (status->conn_handle >= ATH_MCI_MAX_PROFILE)\n\t\treturn 0;\n\n\tif (status->is_critical)\n\t\t__set_bit(status->conn_handle, mci->status);\n\telse\n\t\t__clear_bit(status->conn_handle, mci->status);\n\n\tmci->num_mgmt = 0;\n\tdo {\n\t\tif (test_bit(i, mci->status))\n\t\t\tmci->num_mgmt++;\n\t} while (++i < ATH_MCI_MAX_PROFILE);\n\n\tath_mci_set_concur_txprio(sc);\n\tif (old_num_mgmt != mci->num_mgmt)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void ath_mci_msg(struct ath_softc *sc, u8 opcode, u8 *rx_payload)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_mci_profile_info profile_info;\n\tstruct ath_mci_profile_status profile_status;\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tu8 major, minor, update_scheme = 0;\n\tu32 seq_num;\n\n\tif (ar9003_mci_state(ah, MCI_STATE_NEED_FLUSH_BT_INFO) &&\n\t    ar9003_mci_state(ah, MCI_STATE_ENABLE)) {\n\t\tath_dbg(common, MCI, \"(MCI) Need to flush BT profiles\\n\");\n\t\tath_mci_flush_profile(&sc->btcoex.mci);\n\t\tar9003_mci_state(ah, MCI_STATE_SEND_STATUS_QUERY);\n\t}\n\n\tswitch (opcode) {\n\tcase MCI_GPM_COEX_VERSION_QUERY:\n\t\tar9003_mci_state(ah, MCI_STATE_SEND_WLAN_COEX_VERSION);\n\t\tbreak;\n\tcase MCI_GPM_COEX_VERSION_RESPONSE:\n\t\tmajor = *(rx_payload + MCI_GPM_COEX_B_MAJOR_VERSION);\n\t\tminor = *(rx_payload + MCI_GPM_COEX_B_MINOR_VERSION);\n\t\tar9003_mci_set_bt_version(ah, major, minor);\n\t\tbreak;\n\tcase MCI_GPM_COEX_STATUS_QUERY:\n\t\tar9003_mci_send_wlan_channels(ah);\n\t\tbreak;\n\tcase MCI_GPM_COEX_BT_PROFILE_INFO:\n\t\tmemcpy(&profile_info,\n\t\t       (rx_payload + MCI_GPM_COEX_B_PROFILE_TYPE), 10);\n\n\t\tif ((profile_info.type == MCI_GPM_COEX_PROFILE_UNKNOWN) ||\n\t\t    (profile_info.type >= MCI_GPM_COEX_PROFILE_MAX)) {\n\t\t\tath_dbg(common, MCI,\n\t\t\t\t\"Illegal profile type = %d, state = %d\\n\",\n\t\t\t\tprofile_info.type,\n\t\t\t\tprofile_info.start);\n\t\t\tbreak;\n\t\t}\n\n\t\tupdate_scheme += ath_mci_process_profile(sc, &profile_info);\n\t\tbreak;\n\tcase MCI_GPM_COEX_BT_STATUS_UPDATE:\n\t\tprofile_status.is_link = *(rx_payload +\n\t\t\t\t\t   MCI_GPM_COEX_B_STATUS_TYPE);\n\t\tprofile_status.conn_handle = *(rx_payload +\n\t\t\t\t\t       MCI_GPM_COEX_B_STATUS_LINKID);\n\t\tprofile_status.is_critical = *(rx_payload +\n\t\t\t\t\t       MCI_GPM_COEX_B_STATUS_STATE);\n\n\t\tseq_num = *((u32 *)(rx_payload + 12));\n\t\tath_dbg(common, MCI,\n\t\t\t\"BT_Status_Update: is_link=%d, linkId=%d, state=%d, SEQ=%u\\n\",\n\t\t\tprofile_status.is_link, profile_status.conn_handle,\n\t\t\tprofile_status.is_critical, seq_num);\n\n\t\tupdate_scheme += ath_mci_process_status(sc, &profile_status);\n\t\tbreak;\n\tdefault:\n\t\tath_dbg(common, MCI, \"Unknown GPM COEX message = 0x%02x\\n\", opcode);\n\t\tbreak;\n\t}\n\tif (update_scheme)\n\t\tieee80211_queue_work(sc->hw, &sc->mci_work);\n}\n\nint ath_mci_setup(struct ath_softc *sc)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ath_mci_coex *mci = &sc->mci_coex;\n\tstruct ath_mci_buf *buf = &mci->sched_buf;\n\tint ret;\n\n\tbuf->bf_addr = dmam_alloc_coherent(sc->dev,\n\t\t\t\t  ATH_MCI_SCHED_BUF_SIZE + ATH_MCI_GPM_BUF_SIZE,\n\t\t\t\t  &buf->bf_paddr, GFP_KERNEL);\n\n\tif (buf->bf_addr == NULL) {\n\t\tath_dbg(common, FATAL, \"MCI buffer alloc failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(buf->bf_addr, MCI_GPM_RSVD_PATTERN,\n\t       ATH_MCI_SCHED_BUF_SIZE + ATH_MCI_GPM_BUF_SIZE);\n\n\tmci->sched_buf.bf_len = ATH_MCI_SCHED_BUF_SIZE;\n\n\tmci->gpm_buf.bf_len = ATH_MCI_GPM_BUF_SIZE;\n\tmci->gpm_buf.bf_addr = mci->sched_buf.bf_addr + mci->sched_buf.bf_len;\n\tmci->gpm_buf.bf_paddr = mci->sched_buf.bf_paddr + mci->sched_buf.bf_len;\n\n\tret = ar9003_mci_setup(sc->sc_ah, mci->gpm_buf.bf_paddr,\n\t\t\t       mci->gpm_buf.bf_addr, (mci->gpm_buf.bf_len >> 4),\n\t\t\t       mci->sched_buf.bf_paddr);\n\tif (ret) {\n\t\tath_err(common, \"Failed to initialize MCI\\n\");\n\t\treturn ret;\n\t}\n\n\tINIT_WORK(&sc->mci_work, ath9k_mci_work);\n\tath_dbg(common, MCI, \"MCI Initialized\\n\");\n\n\treturn 0;\n}\n\nvoid ath_mci_cleanup(struct ath_softc *sc)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ath_hw *ah = sc->sc_ah;\n\n\tar9003_mci_cleanup(ah);\n\n\tath_dbg(common, MCI, \"MCI De-Initialized\\n\");\n}\n\nvoid ath_mci_intr(struct ath_softc *sc)\n{\n\tstruct ath_mci_coex *mci = &sc->mci_coex;\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath9k_hw_mci *mci_hw = &ah->btcoex_hw.mci;\n\tu32 mci_int, mci_int_rxmsg;\n\tu32 offset, subtype, opcode;\n\tu32 *pgpm;\n\tu32 more_data = MCI_GPM_MORE;\n\tbool skip_gpm = false;\n\n\tar9003_mci_get_interrupt(sc->sc_ah, &mci_int, &mci_int_rxmsg);\n\n\tif (ar9003_mci_state(ah, MCI_STATE_ENABLE) == 0) {\n\t\tar9003_mci_state(ah, MCI_STATE_INIT_GPM_OFFSET);\n\t\treturn;\n\t}\n\n\tif (mci_int_rxmsg & AR_MCI_INTERRUPT_RX_MSG_REQ_WAKE) {\n\t\tu32 payload[4] = { 0xffffffff, 0xffffffff,\n\t\t\t\t   0xffffffff, 0xffffff00};\n\n\t\t \n\t\tar9003_mci_send_message(ah, MCI_REMOTE_RESET, 0,\n\t\t\t\t\tpayload, 16, true, false);\n\t\tar9003_mci_send_message(ah, MCI_SYS_WAKING, 0,\n\t\t\t\t\tNULL, 0, true, false);\n\n\t\tmci_int_rxmsg &= ~AR_MCI_INTERRUPT_RX_MSG_REQ_WAKE;\n\t\tar9003_mci_state(ah, MCI_STATE_RESET_REQ_WAKE);\n\n\t\t \n\t\tar9003_mci_state(ah, MCI_STATE_SET_BT_AWAKE);\n\t}\n\n\tif (mci_int_rxmsg & AR_MCI_INTERRUPT_RX_MSG_SYS_WAKING) {\n\t\tmci_int_rxmsg &= ~AR_MCI_INTERRUPT_RX_MSG_SYS_WAKING;\n\n\t\tif ((mci_hw->bt_state == MCI_BT_SLEEP) &&\n\t\t    (ar9003_mci_state(ah, MCI_STATE_REMOTE_SLEEP) !=\n\t\t     MCI_BT_SLEEP))\n\t\t\tar9003_mci_state(ah, MCI_STATE_SET_BT_AWAKE);\n\t}\n\n\tif (mci_int_rxmsg & AR_MCI_INTERRUPT_RX_MSG_SYS_SLEEPING) {\n\t\tmci_int_rxmsg &= ~AR_MCI_INTERRUPT_RX_MSG_SYS_SLEEPING;\n\n\t\tif ((mci_hw->bt_state == MCI_BT_AWAKE) &&\n\t\t    (ar9003_mci_state(ah, MCI_STATE_REMOTE_SLEEP) !=\n\t\t     MCI_BT_AWAKE))\n\t\t\tmci_hw->bt_state = MCI_BT_SLEEP;\n\t}\n\n\tif ((mci_int & AR_MCI_INTERRUPT_RX_INVALID_HDR) ||\n\t    (mci_int & AR_MCI_INTERRUPT_CONT_INFO_TIMEOUT)) {\n\t\tar9003_mci_state(ah, MCI_STATE_RECOVER_RX);\n\t\tskip_gpm = true;\n\t}\n\n\tif (mci_int_rxmsg & AR_MCI_INTERRUPT_RX_MSG_SCHD_INFO) {\n\t\tmci_int_rxmsg &= ~AR_MCI_INTERRUPT_RX_MSG_SCHD_INFO;\n\t\tar9003_mci_state(ah, MCI_STATE_LAST_SCHD_MSG_OFFSET);\n\t}\n\n\tif (mci_int_rxmsg & AR_MCI_INTERRUPT_RX_MSG_GPM) {\n\t\tmci_int_rxmsg &= ~AR_MCI_INTERRUPT_RX_MSG_GPM;\n\n\t\twhile (more_data == MCI_GPM_MORE) {\n\t\t\tif (test_bit(ATH_OP_HW_RESET, &common->op_flags))\n\t\t\t\treturn;\n\n\t\t\tpgpm = mci->gpm_buf.bf_addr;\n\t\t\toffset = ar9003_mci_get_next_gpm_offset(ah, &more_data);\n\n\t\t\tif (offset == MCI_GPM_INVALID)\n\t\t\t\tbreak;\n\n\t\t\tpgpm += (offset >> 2);\n\n\t\t\t \n\t\t\tsubtype = MCI_GPM_TYPE(pgpm);\n\t\t\topcode = MCI_GPM_OPCODE(pgpm);\n\n\t\t\tif (skip_gpm)\n\t\t\t\tgoto recycle;\n\n\t\t\tif (MCI_GPM_IS_CAL_TYPE(subtype)) {\n\t\t\t\tath_mci_cal_msg(sc, subtype, (u8 *)pgpm);\n\t\t\t} else {\n\t\t\t\tswitch (subtype) {\n\t\t\t\tcase MCI_GPM_COEX_AGENT:\n\t\t\t\t\tath_mci_msg(sc, opcode, (u8 *)pgpm);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\trecycle:\n\t\t\tMCI_GPM_RECYCLE(pgpm);\n\t\t}\n\t}\n\n\tif (mci_int_rxmsg & AR_MCI_INTERRUPT_RX_HW_MSG_MASK) {\n\t\tif (mci_int_rxmsg & AR_MCI_INTERRUPT_RX_MSG_LNA_CONTROL)\n\t\t\tmci_int_rxmsg &= ~AR_MCI_INTERRUPT_RX_MSG_LNA_CONTROL;\n\n\t\tif (mci_int_rxmsg & AR_MCI_INTERRUPT_RX_MSG_LNA_INFO)\n\t\t\tmci_int_rxmsg &= ~AR_MCI_INTERRUPT_RX_MSG_LNA_INFO;\n\n\t\tif (mci_int_rxmsg & AR_MCI_INTERRUPT_RX_MSG_CONT_INFO) {\n\t\t\tint value_dbm = MS(mci_hw->cont_status,\n\t\t\t\t\t   AR_MCI_CONT_RSSI_POWER);\n\n\t\t\tmci_int_rxmsg &= ~AR_MCI_INTERRUPT_RX_MSG_CONT_INFO;\n\n\t\t\tath_dbg(common, MCI,\n\t\t\t\t\"MCI CONT_INFO: (%s) pri = %d pwr = %d dBm\\n\",\n\t\t\t\tMS(mci_hw->cont_status, AR_MCI_CONT_TXRX) ?\n\t\t\t\t\"tx\" : \"rx\",\n\t\t\t\tMS(mci_hw->cont_status, AR_MCI_CONT_PRIORITY),\n\t\t\t\tvalue_dbm);\n\t\t}\n\n\t\tif (mci_int_rxmsg & AR_MCI_INTERRUPT_RX_MSG_CONT_NACK)\n\t\t\tmci_int_rxmsg &= ~AR_MCI_INTERRUPT_RX_MSG_CONT_NACK;\n\n\t\tif (mci_int_rxmsg & AR_MCI_INTERRUPT_RX_MSG_CONT_RST)\n\t\t\tmci_int_rxmsg &= ~AR_MCI_INTERRUPT_RX_MSG_CONT_RST;\n\t}\n\n\tif ((mci_int & AR_MCI_INTERRUPT_RX_INVALID_HDR) ||\n\t    (mci_int & AR_MCI_INTERRUPT_CONT_INFO_TIMEOUT)) {\n\t\tmci_int &= ~(AR_MCI_INTERRUPT_RX_INVALID_HDR |\n\t\t\t     AR_MCI_INTERRUPT_CONT_INFO_TIMEOUT);\n\t\tath_mci_msg(sc, MCI_GPM_COEX_NOOP, NULL);\n\t}\n}\n\nvoid ath_mci_enable(struct ath_softc *sc)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\n\tif (!common->btcoex_enabled)\n\t\treturn;\n\n\tif (sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_MCI)\n\t\tsc->sc_ah->imask |= ATH9K_INT_MCI;\n}\n\nvoid ath9k_mci_update_wlan_channels(struct ath_softc *sc, bool allow_all)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;\n\tstruct ath9k_channel *chan = ah->curchan;\n\tu32 channelmap[] = {0x00000000, 0xffff0000, 0xffffffff, 0x7fffffff};\n\tint i;\n\ts16 chan_start, chan_end;\n\tu16 wlan_chan;\n\n\tif (!chan || !IS_CHAN_2GHZ(chan))\n\t\treturn;\n\n\tif (allow_all)\n\t\tgoto send_wlan_chan;\n\n\twlan_chan = chan->channel - 2402;\n\n\tchan_start = wlan_chan - 10;\n\tchan_end = wlan_chan + 10;\n\n\tif (IS_CHAN_HT40PLUS(chan))\n\t\tchan_end += 20;\n\telse if (IS_CHAN_HT40MINUS(chan))\n\t\tchan_start -= 20;\n\n\t \n\tchan_start -= 7;\n\tchan_end += 7;\n\n\tif (chan_start <= 0)\n\t\tchan_start = 0;\n\tif (chan_end >= ATH_MCI_NUM_BT_CHANNELS)\n\t\tchan_end = ATH_MCI_NUM_BT_CHANNELS - 1;\n\n\tath_dbg(ath9k_hw_common(ah), MCI,\n\t\t\"WLAN current channel %d mask BT channel %d - %d\\n\",\n\t\twlan_chan, chan_start, chan_end);\n\n\tfor (i = chan_start; i < chan_end; i++)\n\t\tMCI_GPM_CLR_CHANNEL_BIT(&channelmap, i);\n\nsend_wlan_chan:\n\t \n\tfor (i = 0; i < 4; i++)\n\t\tmci->wlan_channels[i] = channelmap[i];\n\tar9003_mci_send_wlan_channels(ah);\n\tar9003_mci_state(ah, MCI_STATE_SEND_VERSION_QUERY);\n}\n\nvoid ath9k_mci_set_txpower(struct ath_softc *sc, bool setchannel,\n\t\t\t   bool concur_tx)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath9k_hw_mci *mci_hw = &sc->sc_ah->btcoex_hw.mci;\n\tbool old_concur_tx = mci_hw->concur_tx;\n\n\tif (!(mci_hw->config & ATH_MCI_CONFIG_CONCUR_TX)) {\n\t\tmci_hw->concur_tx = false;\n\t\treturn;\n\t}\n\n\tif (!IS_CHAN_2GHZ(ah->curchan))\n\t\treturn;\n\n\tif (setchannel) {\n\t\tstruct ath9k_hw_cal_data *caldata = &sc->cur_chan->caldata;\n\t\tif (IS_CHAN_HT40PLUS(ah->curchan) &&\n\t\t    (ah->curchan->channel > caldata->channel) &&\n\t\t    (ah->curchan->channel <= caldata->channel + 20))\n\t\t\treturn;\n\t\tif (IS_CHAN_HT40MINUS(ah->curchan) &&\n\t\t    (ah->curchan->channel < caldata->channel) &&\n\t\t    (ah->curchan->channel >= caldata->channel - 20))\n\t\t\treturn;\n\t\tmci_hw->concur_tx = false;\n\t} else\n\t\tmci_hw->concur_tx = concur_tx;\n\n\tif (old_concur_tx != mci_hw->concur_tx)\n\t\tath9k_hw_set_txpowerlimit(ah, sc->cur_chan->txpower, false);\n}\n\nstatic void ath9k_mci_stomp_audio(struct ath_softc *sc)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_btcoex *btcoex = &sc->btcoex;\n\tstruct ath_mci_profile *mci = &btcoex->mci;\n\n\tif (!mci->num_sco && !mci->num_a2dp)\n\t\treturn;\n\n\tif (ah->stats.avgbrssi > 25) {\n\t\tbtcoex->stomp_audio = 0;\n\t\treturn;\n\t}\n\n\tbtcoex->stomp_audio++;\n}\nvoid ath9k_mci_update_rssi(struct ath_softc *sc)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_btcoex *btcoex = &sc->btcoex;\n\tstruct ath9k_hw_mci *mci_hw = &sc->sc_ah->btcoex_hw.mci;\n\n\tath9k_mci_stomp_audio(sc);\n\n\tif (!(mci_hw->config & ATH_MCI_CONFIG_CONCUR_TX))\n\t\treturn;\n\n\tif (ah->stats.avgbrssi >= 40) {\n\t\tif (btcoex->rssi_count < 0)\n\t\t\tbtcoex->rssi_count = 0;\n\t\tif (++btcoex->rssi_count >= ATH_MCI_CONCUR_TX_SWITCH) {\n\t\t\tbtcoex->rssi_count = 0;\n\t\t\tath9k_mci_set_txpower(sc, false, true);\n\t\t}\n\t} else {\n\t\tif (btcoex->rssi_count > 0)\n\t\t\tbtcoex->rssi_count = 0;\n\t\tif (--btcoex->rssi_count <= -ATH_MCI_CONCUR_TX_SWITCH) {\n\t\t\tbtcoex->rssi_count = 0;\n\t\t\tath9k_mci_set_txpower(sc, false, false);\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}