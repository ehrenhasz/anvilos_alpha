{
  "module_name": "htc_drv_main.c",
  "hash_id": "dc164f9808e3f915bd36ac284ab381048fab26626cb8f1bf47a2bcf3bf7df8e1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath9k/htc_drv_main.c",
  "human_readable_source": " \n\n#include \"htc.h\"\n\n \n \n \n\n \nstatic enum htc_phymode ath9k_htc_get_curmode(struct ath9k_htc_priv *priv,\n\t\t\t\t\t      struct ath9k_channel *ichan)\n{\n\tif (IS_CHAN_5GHZ(ichan))\n\t\treturn HTC_MODE_11NA;\n\n\treturn HTC_MODE_11NG;\n}\n\nbool ath9k_htc_setpower(struct ath9k_htc_priv *priv,\n\t\t\tenum ath9k_power_mode mode)\n{\n\tbool ret;\n\n\tmutex_lock(&priv->htc_pm_lock);\n\tret = ath9k_hw_setpower(priv->ah, mode);\n\tmutex_unlock(&priv->htc_pm_lock);\n\n\treturn ret;\n}\n\nvoid ath9k_htc_ps_wakeup(struct ath9k_htc_priv *priv)\n{\n\tmutex_lock(&priv->htc_pm_lock);\n\tif (++priv->ps_usecount != 1)\n\t\tgoto unlock;\n\tath9k_hw_setpower(priv->ah, ATH9K_PM_AWAKE);\n\nunlock:\n\tmutex_unlock(&priv->htc_pm_lock);\n}\n\nvoid ath9k_htc_ps_restore(struct ath9k_htc_priv *priv)\n{\n\tbool reset;\n\n\tmutex_lock(&priv->htc_pm_lock);\n\tif (--priv->ps_usecount != 0)\n\t\tgoto unlock;\n\n\tif (priv->ps_idle) {\n\t\tath9k_hw_setrxabort(priv->ah, true);\n\t\tath9k_hw_stopdmarecv(priv->ah, &reset);\n\t\tath9k_hw_setpower(priv->ah, ATH9K_PM_FULL_SLEEP);\n\t} else if (priv->ps_enabled) {\n\t\tath9k_hw_setpower(priv->ah, ATH9K_PM_NETWORK_SLEEP);\n\t}\n\nunlock:\n\tmutex_unlock(&priv->htc_pm_lock);\n}\n\nvoid ath9k_ps_work(struct work_struct *work)\n{\n\tstruct ath9k_htc_priv *priv =\n\t\tcontainer_of(work, struct ath9k_htc_priv,\n\t\t\t     ps_work);\n\tath9k_htc_setpower(priv, ATH9K_PM_AWAKE);\n\n\t \n\tath9k_htc_setpower(priv, ATH9K_PM_NETWORK_SLEEP);\n}\n\nstatic void ath9k_htc_vif_iter(void *data, u8 *mac, struct ieee80211_vif *vif)\n{\n\tstruct ath9k_htc_priv *priv = data;\n\tstruct ieee80211_bss_conf *bss_conf = &vif->bss_conf;\n\n\tif ((vif->type == NL80211_IFTYPE_AP ||\n\t     vif->type == NL80211_IFTYPE_MESH_POINT) &&\n\t    bss_conf->enable_beacon) {\n\t\tpriv->reconfig_beacon = true;\n\t\tpriv->rearm_ani = true;\n\t}\n\n\tif (vif->cfg.assoc) {\n\t\tpriv->rearm_ani = true;\n\t\tpriv->reconfig_beacon = true;\n\t}\n}\n\nstatic void ath9k_htc_vif_reconfig(struct ath9k_htc_priv *priv)\n{\n\tpriv->rearm_ani = false;\n\tpriv->reconfig_beacon = false;\n\n\tieee80211_iterate_active_interfaces_atomic(\n\t\tpriv->hw, IEEE80211_IFACE_ITER_RESUME_ALL,\n\t\tath9k_htc_vif_iter, priv);\n\tif (priv->rearm_ani)\n\t\tath9k_htc_start_ani(priv);\n\n\tif (priv->reconfig_beacon) {\n\t\tath9k_htc_ps_wakeup(priv);\n\t\tath9k_htc_beacon_reconfig(priv);\n\t\tath9k_htc_ps_restore(priv);\n\t}\n}\n\nstatic void ath9k_htc_bssid_iter(void *data, u8 *mac, struct ieee80211_vif *vif)\n{\n\tstruct ath9k_vif_iter_data *iter_data = data;\n\tint i;\n\n\tif (iter_data->hw_macaddr != NULL) {\n\t\tfor (i = 0; i < ETH_ALEN; i++)\n\t\t\titer_data->mask[i] &= ~(iter_data->hw_macaddr[i] ^ mac[i]);\n\t} else {\n\t\titer_data->hw_macaddr = mac;\n\t}\n}\n\nstatic void ath9k_htc_set_mac_bssid_mask(struct ath9k_htc_priv *priv,\n\t\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\tstruct ath9k_vif_iter_data iter_data;\n\n\t \n\titer_data.hw_macaddr = NULL;\n\teth_broadcast_addr(iter_data.mask);\n\n\tif (vif)\n\t\tath9k_htc_bssid_iter(&iter_data, vif->addr, vif);\n\n\t \n\tieee80211_iterate_active_interfaces_atomic(\n\t\tpriv->hw, IEEE80211_IFACE_ITER_RESUME_ALL,\n\t\tath9k_htc_bssid_iter, &iter_data);\n\n\tmemcpy(common->bssidmask, iter_data.mask, ETH_ALEN);\n\n\tif (iter_data.hw_macaddr)\n\t\tmemcpy(common->macaddr, iter_data.hw_macaddr, ETH_ALEN);\n\n\tath_hw_setbssidmask(common);\n}\n\nstatic void ath9k_htc_set_opmode(struct ath9k_htc_priv *priv)\n{\n\tif (priv->num_ibss_vif)\n\t\tpriv->ah->opmode = NL80211_IFTYPE_ADHOC;\n\telse if (priv->num_ap_vif)\n\t\tpriv->ah->opmode = NL80211_IFTYPE_AP;\n\telse if (priv->num_mbss_vif)\n\t\tpriv->ah->opmode = NL80211_IFTYPE_MESH_POINT;\n\telse\n\t\tpriv->ah->opmode = NL80211_IFTYPE_STATION;\n\n\tath9k_hw_setopmode(priv->ah);\n}\n\nvoid ath9k_htc_reset(struct ath9k_htc_priv *priv)\n{\n\tstruct ath_hw *ah = priv->ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ieee80211_channel *channel = priv->hw->conf.chandef.chan;\n\tstruct ath9k_hw_cal_data *caldata = NULL;\n\tenum htc_phymode mode;\n\t__be16 htc_mode;\n\tu8 cmd_rsp;\n\tint ret;\n\n\tmutex_lock(&priv->mutex);\n\tath9k_htc_ps_wakeup(priv);\n\n\tath9k_htc_stop_ani(priv);\n\tieee80211_stop_queues(priv->hw);\n\n\tdel_timer_sync(&priv->tx.cleanup_timer);\n\tath9k_htc_tx_drain(priv);\n\n\tWMI_CMD(WMI_DISABLE_INTR_CMDID);\n\tWMI_CMD(WMI_DRAIN_TXQ_ALL_CMDID);\n\tWMI_CMD(WMI_STOP_RECV_CMDID);\n\n\tath9k_wmi_event_drain(priv);\n\n\tcaldata = &priv->caldata;\n\tret = ath9k_hw_reset(ah, ah->curchan, caldata, false);\n\tif (ret) {\n\t\tath_err(common,\n\t\t\t\"Unable to reset device (%u Mhz) reset status %d\\n\",\n\t\t\tchannel->center_freq, ret);\n\t}\n\n\tath9k_cmn_update_txpow(ah, priv->curtxpow, priv->txpowlimit,\n\t\t\t       &priv->curtxpow);\n\n\tWMI_CMD(WMI_START_RECV_CMDID);\n\tath9k_host_rx_init(priv);\n\n\tmode = ath9k_htc_get_curmode(priv, ah->curchan);\n\thtc_mode = cpu_to_be16(mode);\n\tWMI_CMD_BUF(WMI_SET_MODE_CMDID, &htc_mode);\n\n\tWMI_CMD(WMI_ENABLE_INTR_CMDID);\n\thtc_start(priv->htc);\n\tath9k_htc_vif_reconfig(priv);\n\tieee80211_wake_queues(priv->hw);\n\n\tmod_timer(&priv->tx.cleanup_timer,\n\t\t  jiffies + msecs_to_jiffies(ATH9K_HTC_TX_CLEANUP_INTERVAL));\n\n\tath9k_htc_ps_restore(priv);\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic int ath9k_htc_set_channel(struct ath9k_htc_priv *priv,\n\t\t\t\t struct ieee80211_hw *hw,\n\t\t\t\t struct ath9k_channel *hchan)\n{\n\tstruct ath_hw *ah = priv->ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ieee80211_conf *conf = &common->hw->conf;\n\tbool fastcc;\n\tstruct ieee80211_channel *channel = hw->conf.chandef.chan;\n\tstruct ath9k_hw_cal_data *caldata;\n\tenum htc_phymode mode;\n\t__be16 htc_mode;\n\tu8 cmd_rsp;\n\tint ret;\n\n\tif (test_bit(ATH_OP_INVALID, &common->op_flags))\n\t\treturn -EIO;\n\n\tfastcc = !!(hw->conf.flags & IEEE80211_CONF_OFFCHANNEL);\n\n\tath9k_htc_ps_wakeup(priv);\n\n\tath9k_htc_stop_ani(priv);\n\tdel_timer_sync(&priv->tx.cleanup_timer);\n\tath9k_htc_tx_drain(priv);\n\n\tWMI_CMD(WMI_DISABLE_INTR_CMDID);\n\tWMI_CMD(WMI_DRAIN_TXQ_ALL_CMDID);\n\tWMI_CMD(WMI_STOP_RECV_CMDID);\n\n\tath9k_wmi_event_drain(priv);\n\n\tath_dbg(common, CONFIG,\n\t\t\"(%u MHz) -> (%u MHz), HT: %d, HT40: %d fastcc: %d\\n\",\n\t\tpriv->ah->curchan->channel,\n\t\tchannel->center_freq, conf_is_ht(conf), conf_is_ht40(conf),\n\t\tfastcc);\n\tcaldata = fastcc ? NULL : &priv->caldata;\n\tret = ath9k_hw_reset(ah, hchan, caldata, fastcc);\n\tif (ret) {\n\t\tath_err(common,\n\t\t\t\"Unable to reset channel (%u Mhz) reset status %d\\n\",\n\t\t\tchannel->center_freq, ret);\n\t\tgoto err;\n\t}\n\n\tath9k_cmn_update_txpow(ah, priv->curtxpow, priv->txpowlimit,\n\t\t\t       &priv->curtxpow);\n\n\tWMI_CMD(WMI_START_RECV_CMDID);\n\tif (ret)\n\t\tgoto err;\n\n\tath9k_host_rx_init(priv);\n\n\tmode = ath9k_htc_get_curmode(priv, hchan);\n\thtc_mode = cpu_to_be16(mode);\n\tWMI_CMD_BUF(WMI_SET_MODE_CMDID, &htc_mode);\n\tif (ret)\n\t\tgoto err;\n\n\tWMI_CMD(WMI_ENABLE_INTR_CMDID);\n\tif (ret)\n\t\tgoto err;\n\n\thtc_start(priv->htc);\n\n\tif (!test_bit(ATH_OP_SCANNING, &common->op_flags) &&\n\t    !(hw->conf.flags & IEEE80211_CONF_OFFCHANNEL))\n\t\tath9k_htc_vif_reconfig(priv);\n\n\tmod_timer(&priv->tx.cleanup_timer,\n\t\t  jiffies + msecs_to_jiffies(ATH9K_HTC_TX_CLEANUP_INTERVAL));\n\n\t \n\tif (test_bit(ATH_OP_SCANNING, &common->op_flags) &&\n\t\t     priv->spec_priv.spectral_mode == SPECTRAL_CHANSCAN)\n\t\tath9k_cmn_spectral_scan_trigger(common, &priv->spec_priv);\nerr:\n\tath9k_htc_ps_restore(priv);\n\treturn ret;\n}\n\n \nstatic void __ath9k_htc_remove_monitor_interface(struct ath9k_htc_priv *priv)\n{\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\tstruct ath9k_htc_target_vif hvif;\n\tint ret = 0;\n\tu8 cmd_rsp;\n\n\tmemset(&hvif, 0, sizeof(struct ath9k_htc_target_vif));\n\tmemcpy(&hvif.myaddr, common->macaddr, ETH_ALEN);\n\thvif.index = priv->mon_vif_idx;\n\tWMI_CMD_BUF(WMI_VAP_REMOVE_CMDID, &hvif);\n\tif (ret) {\n\t\tath_err(common, \"Unable to remove monitor interface at idx: %d\\n\",\n\t\t\tpriv->mon_vif_idx);\n\t}\n\n\tpriv->nvifs--;\n\tpriv->vif_slot &= ~(1 << priv->mon_vif_idx);\n}\n\nstatic int ath9k_htc_add_monitor_interface(struct ath9k_htc_priv *priv)\n{\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\tstruct ath9k_htc_target_vif hvif;\n\tstruct ath9k_htc_target_sta tsta;\n\tint ret = 0, sta_idx;\n\tu8 cmd_rsp;\n\n\tif ((priv->nvifs >= ATH9K_HTC_MAX_VIF) ||\n\t    (priv->nstations >= ATH9K_HTC_MAX_STA)) {\n\t\tret = -ENOBUFS;\n\t\tgoto err_vif;\n\t}\n\n\tsta_idx = ffz(priv->sta_slot);\n\tif ((sta_idx < 0) || (sta_idx > ATH9K_HTC_MAX_STA)) {\n\t\tret = -ENOBUFS;\n\t\tgoto err_vif;\n\t}\n\n\t \n\tmemset(&hvif, 0, sizeof(struct ath9k_htc_target_vif));\n\tmemcpy(&hvif.myaddr, common->macaddr, ETH_ALEN);\n\n\thvif.opmode = HTC_M_MONITOR;\n\thvif.index = ffz(priv->vif_slot);\n\n\tWMI_CMD_BUF(WMI_VAP_CREATE_CMDID, &hvif);\n\tif (ret)\n\t\tgoto err_vif;\n\n\t \n\tpriv->mon_vif_idx = hvif.index;\n\tpriv->vif_slot |= (1 << hvif.index);\n\n\t \n\tif (!priv->nvifs)\n\t\tpriv->ah->opmode = NL80211_IFTYPE_MONITOR;\n\n\tpriv->nvifs++;\n\n\t \n\tmemset(&tsta, 0, sizeof(struct ath9k_htc_target_sta));\n\n\tmemcpy(&tsta.macaddr, common->macaddr, ETH_ALEN);\n\n\ttsta.is_vif_sta = 1;\n\ttsta.sta_index = sta_idx;\n\ttsta.vif_index = hvif.index;\n\ttsta.maxampdu = cpu_to_be16(0xffff);\n\n\tWMI_CMD_BUF(WMI_NODE_CREATE_CMDID, &tsta);\n\tif (ret) {\n\t\tath_err(common, \"Unable to add station entry for monitor mode\\n\");\n\t\tgoto err_sta;\n\t}\n\n\tpriv->sta_slot |= (1 << sta_idx);\n\tpriv->nstations++;\n\tpriv->vif_sta_pos[priv->mon_vif_idx] = sta_idx;\n\tpriv->ah->is_monitoring = true;\n\n\tath_dbg(common, CONFIG,\n\t\t\"Attached a monitor interface at idx: %d, sta idx: %d\\n\",\n\t\tpriv->mon_vif_idx, sta_idx);\n\n\treturn 0;\n\nerr_sta:\n\t \n\t__ath9k_htc_remove_monitor_interface(priv);\nerr_vif:\n\tath_dbg(common, FATAL, \"Unable to attach a monitor interface\\n\");\n\n\treturn ret;\n}\n\nstatic int ath9k_htc_remove_monitor_interface(struct ath9k_htc_priv *priv)\n{\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\tint ret = 0;\n\tu8 cmd_rsp, sta_idx;\n\n\t__ath9k_htc_remove_monitor_interface(priv);\n\n\tsta_idx = priv->vif_sta_pos[priv->mon_vif_idx];\n\n\tWMI_CMD_BUF(WMI_NODE_REMOVE_CMDID, &sta_idx);\n\tif (ret) {\n\t\tath_err(common, \"Unable to remove station entry for monitor mode\\n\");\n\t\treturn ret;\n\t}\n\n\tpriv->sta_slot &= ~(1 << sta_idx);\n\tpriv->nstations--;\n\tpriv->ah->is_monitoring = false;\n\n\tath_dbg(common, CONFIG,\n\t\t\"Removed a monitor interface at idx: %d, sta idx: %d\\n\",\n\t\tpriv->mon_vif_idx, sta_idx);\n\n\treturn 0;\n}\n\nstatic int ath9k_htc_add_station(struct ath9k_htc_priv *priv,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_sta *sta)\n{\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\tstruct ath9k_htc_target_sta tsta;\n\tstruct ath9k_htc_vif *avp = (struct ath9k_htc_vif *) vif->drv_priv;\n\tstruct ath9k_htc_sta *ista;\n\tint ret, sta_idx;\n\tu8 cmd_rsp;\n\tu16 maxampdu;\n\n\tif (priv->nstations >= ATH9K_HTC_MAX_STA)\n\t\treturn -ENOBUFS;\n\n\tsta_idx = ffz(priv->sta_slot);\n\tif ((sta_idx < 0) || (sta_idx > ATH9K_HTC_MAX_STA))\n\t\treturn -ENOBUFS;\n\n\tmemset(&tsta, 0, sizeof(struct ath9k_htc_target_sta));\n\n\tif (sta) {\n\t\tista = (struct ath9k_htc_sta *) sta->drv_priv;\n\t\tmemcpy(&tsta.macaddr, sta->addr, ETH_ALEN);\n\t\tmemcpy(&tsta.bssid, common->curbssid, ETH_ALEN);\n\t\tista->index = sta_idx;\n\t\ttsta.is_vif_sta = 0;\n\t\tmaxampdu = 1 << (IEEE80211_HT_MAX_AMPDU_FACTOR +\n\t\t\t\t sta->deflink.ht_cap.ampdu_factor);\n\t\ttsta.maxampdu = cpu_to_be16(maxampdu);\n\t} else {\n\t\tmemcpy(&tsta.macaddr, vif->addr, ETH_ALEN);\n\t\ttsta.is_vif_sta = 1;\n\t\ttsta.maxampdu = cpu_to_be16(0xffff);\n\t}\n\n\ttsta.sta_index = sta_idx;\n\ttsta.vif_index = avp->index;\n\n\tWMI_CMD_BUF(WMI_NODE_CREATE_CMDID, &tsta);\n\tif (ret) {\n\t\tif (sta)\n\t\t\tath_err(common,\n\t\t\t\t\"Unable to add station entry for: %pM\\n\",\n\t\t\t\tsta->addr);\n\t\treturn ret;\n\t}\n\n\tif (sta) {\n\t\tath_dbg(common, CONFIG,\n\t\t\t\"Added a station entry for: %pM (idx: %d)\\n\",\n\t\t\tsta->addr, tsta.sta_index);\n\t} else {\n\t\tath_dbg(common, CONFIG,\n\t\t\t\"Added a station entry for VIF %d (idx: %d)\\n\",\n\t\t\tavp->index, tsta.sta_index);\n\t}\n\n\tpriv->sta_slot |= (1 << sta_idx);\n\tpriv->nstations++;\n\tif (!sta)\n\t\tpriv->vif_sta_pos[avp->index] = sta_idx;\n\n\treturn 0;\n}\n\nstatic int ath9k_htc_remove_station(struct ath9k_htc_priv *priv,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct ieee80211_sta *sta)\n{\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\tstruct ath9k_htc_vif *avp = (struct ath9k_htc_vif *) vif->drv_priv;\n\tstruct ath9k_htc_sta *ista;\n\tint ret;\n\tu8 cmd_rsp, sta_idx;\n\n\tif (sta) {\n\t\tista = (struct ath9k_htc_sta *) sta->drv_priv;\n\t\tsta_idx = ista->index;\n\t} else {\n\t\tsta_idx = priv->vif_sta_pos[avp->index];\n\t}\n\n\tWMI_CMD_BUF(WMI_NODE_REMOVE_CMDID, &sta_idx);\n\tif (ret) {\n\t\tif (sta)\n\t\t\tath_err(common,\n\t\t\t\t\"Unable to remove station entry for: %pM\\n\",\n\t\t\t\tsta->addr);\n\t\treturn ret;\n\t}\n\n\tif (sta) {\n\t\tath_dbg(common, CONFIG,\n\t\t\t\"Removed a station entry for: %pM (idx: %d)\\n\",\n\t\t\tsta->addr, sta_idx);\n\t} else {\n\t\tath_dbg(common, CONFIG,\n\t\t\t\"Removed a station entry for VIF %d (idx: %d)\\n\",\n\t\t\tavp->index, sta_idx);\n\t}\n\n\tpriv->sta_slot &= ~(1 << sta_idx);\n\tpriv->nstations--;\n\n\treturn 0;\n}\n\nint ath9k_htc_update_cap_target(struct ath9k_htc_priv *priv,\n\t\t\t\tu8 enable_coex)\n{\n\tstruct ath9k_htc_cap_target tcap;\n\tint ret;\n\tu8 cmd_rsp;\n\n\tmemset(&tcap, 0, sizeof(struct ath9k_htc_cap_target));\n\n\ttcap.ampdu_limit = cpu_to_be32(0xffff);\n\ttcap.ampdu_subframes = 0xff;\n\ttcap.enable_coex = enable_coex;\n\ttcap.tx_chainmask = priv->ah->caps.tx_chainmask;\n\n\tWMI_CMD_BUF(WMI_TARGET_IC_UPDATE_CMDID, &tcap);\n\n\treturn ret;\n}\n\nstatic void ath9k_htc_setup_rate(struct ath9k_htc_priv *priv,\n\t\t\t\t struct ieee80211_sta *sta,\n\t\t\t\t struct ath9k_htc_target_rate *trate)\n{\n\tstruct ath9k_htc_sta *ista = (struct ath9k_htc_sta *) sta->drv_priv;\n\tstruct ieee80211_supported_band *sband;\n\tu32 caps = 0;\n\tint i, j;\n\n\tsband = priv->hw->wiphy->bands[priv->hw->conf.chandef.chan->band];\n\n\tfor (i = 0, j = 0; i < sband->n_bitrates; i++) {\n\t\tif (sta->deflink.supp_rates[sband->band] & BIT(i)) {\n\t\t\ttrate->rates.legacy_rates.rs_rates[j]\n\t\t\t\t= (sband->bitrates[i].bitrate * 2) / 10;\n\t\t\tj++;\n\t\t}\n\t}\n\ttrate->rates.legacy_rates.rs_nrates = j;\n\n\tif (sta->deflink.ht_cap.ht_supported) {\n\t\tfor (i = 0, j = 0; i < 77; i++) {\n\t\t\tif (sta->deflink.ht_cap.mcs.rx_mask[i/8] & (1<<(i%8)))\n\t\t\t\ttrate->rates.ht_rates.rs_rates[j++] = i;\n\t\t\tif (j == ATH_HTC_RATE_MAX)\n\t\t\t\tbreak;\n\t\t}\n\t\ttrate->rates.ht_rates.rs_nrates = j;\n\n\t\tcaps = WLAN_RC_HT_FLAG;\n\t\tif (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_RX_STBC)\n\t\t\tcaps |= ATH_RC_TX_STBC_FLAG;\n\t\tif (sta->deflink.ht_cap.mcs.rx_mask[1])\n\t\t\tcaps |= WLAN_RC_DS_FLAG;\n\t\tif ((sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40) &&\n\t\t    (conf_is_ht40(&priv->hw->conf)))\n\t\t\tcaps |= WLAN_RC_40_FLAG;\n\t\tif (conf_is_ht40(&priv->hw->conf) &&\n\t\t    (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_SGI_40))\n\t\t\tcaps |= WLAN_RC_SGI_FLAG;\n\t\telse if (conf_is_ht20(&priv->hw->conf) &&\n\t\t\t (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_SGI_20))\n\t\t\tcaps |= WLAN_RC_SGI_FLAG;\n\t}\n\n\ttrate->sta_index = ista->index;\n\ttrate->isnew = 1;\n\ttrate->capflags = cpu_to_be32(caps);\n}\n\nstatic int ath9k_htc_send_rate_cmd(struct ath9k_htc_priv *priv,\n\t\t\t\t    struct ath9k_htc_target_rate *trate)\n{\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\tint ret;\n\tu8 cmd_rsp;\n\n\tWMI_CMD_BUF(WMI_RC_RATE_UPDATE_CMDID, trate);\n\tif (ret) {\n\t\tath_err(common,\n\t\t\t\"Unable to initialize Rate information on target\\n\");\n\t}\n\n\treturn ret;\n}\n\nstatic void ath9k_htc_init_rate(struct ath9k_htc_priv *priv,\n\t\t\t\tstruct ieee80211_sta *sta)\n{\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\tstruct ath9k_htc_target_rate trate;\n\tint ret;\n\n\tmemset(&trate, 0, sizeof(struct ath9k_htc_target_rate));\n\tath9k_htc_setup_rate(priv, sta, &trate);\n\tret = ath9k_htc_send_rate_cmd(priv, &trate);\n\tif (!ret)\n\t\tath_dbg(common, CONFIG,\n\t\t\t\"Updated target sta: %pM, rate caps: 0x%X\\n\",\n\t\t\tsta->addr, be32_to_cpu(trate.capflags));\n}\n\nstatic void ath9k_htc_update_rate(struct ath9k_htc_priv *priv,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  struct ieee80211_bss_conf *bss_conf)\n{\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\tstruct ath9k_htc_target_rate trate;\n\tstruct ieee80211_sta *sta;\n\tint ret;\n\n\tmemset(&trate, 0, sizeof(struct ath9k_htc_target_rate));\n\n\trcu_read_lock();\n\tsta = ieee80211_find_sta(vif, bss_conf->bssid);\n\tif (!sta) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\tath9k_htc_setup_rate(priv, sta, &trate);\n\trcu_read_unlock();\n\n\tret = ath9k_htc_send_rate_cmd(priv, &trate);\n\tif (!ret)\n\t\tath_dbg(common, CONFIG,\n\t\t\t\"Updated target sta: %pM, rate caps: 0x%X\\n\",\n\t\t\tbss_conf->bssid, be32_to_cpu(trate.capflags));\n}\n\nstatic int ath9k_htc_tx_aggr_oper(struct ath9k_htc_priv *priv,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  struct ieee80211_sta *sta,\n\t\t\t\t  enum ieee80211_ampdu_mlme_action action,\n\t\t\t\t  u16 tid)\n{\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\tstruct ath9k_htc_target_aggr aggr;\n\tstruct ath9k_htc_sta *ista;\n\tint ret = 0;\n\tu8 cmd_rsp;\n\n\tif (tid >= ATH9K_HTC_MAX_TID)\n\t\treturn -EINVAL;\n\n\tmemset(&aggr, 0, sizeof(struct ath9k_htc_target_aggr));\n\tista = (struct ath9k_htc_sta *) sta->drv_priv;\n\n\taggr.sta_index = ista->index;\n\taggr.tidno = tid & 0xf;\n\taggr.aggr_enable = action == IEEE80211_AMPDU_TX_START;\n\n\tWMI_CMD_BUF(WMI_TX_AGGR_ENABLE_CMDID, &aggr);\n\tif (ret)\n\t\tath_dbg(common, CONFIG,\n\t\t\t\"Unable to %s TX aggregation for (%pM, %d)\\n\",\n\t\t\t(aggr.aggr_enable) ? \"start\" : \"stop\", sta->addr, tid);\n\telse\n\t\tath_dbg(common, CONFIG,\n\t\t\t\"%s TX aggregation for (%pM, %d)\\n\",\n\t\t\t(aggr.aggr_enable) ? \"Starting\" : \"Stopping\",\n\t\t\tsta->addr, tid);\n\n\tspin_lock_bh(&priv->tx.tx_lock);\n\tista->tid_state[tid] = (aggr.aggr_enable && !ret) ? AGGR_START : AGGR_STOP;\n\tspin_unlock_bh(&priv->tx.tx_lock);\n\n\treturn ret;\n}\n\n \n \n \n\nvoid ath9k_htc_start_ani(struct ath9k_htc_priv *priv)\n{\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\tunsigned long timestamp = jiffies_to_msecs(jiffies);\n\n\tcommon->ani.longcal_timer = timestamp;\n\tcommon->ani.shortcal_timer = timestamp;\n\tcommon->ani.checkani_timer = timestamp;\n\n\tset_bit(ATH_OP_ANI_RUN, &common->op_flags);\n\n\tieee80211_queue_delayed_work(common->hw, &priv->ani_work,\n\t\t\t\t     msecs_to_jiffies(ATH_ANI_POLLINTERVAL));\n}\n\nvoid ath9k_htc_stop_ani(struct ath9k_htc_priv *priv)\n{\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\tcancel_delayed_work_sync(&priv->ani_work);\n\tclear_bit(ATH_OP_ANI_RUN, &common->op_flags);\n}\n\nvoid ath9k_htc_ani_work(struct work_struct *work)\n{\n\tstruct ath9k_htc_priv *priv =\n\t\tcontainer_of(work, struct ath9k_htc_priv, ani_work.work);\n\tstruct ath_hw *ah = priv->ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tbool longcal = false;\n\tbool shortcal = false;\n\tbool aniflag = false;\n\tunsigned int timestamp = jiffies_to_msecs(jiffies);\n\tu32 cal_interval, short_cal_interval;\n\n\tshort_cal_interval = (ah->opmode == NL80211_IFTYPE_AP) ?\n\t\tATH_AP_SHORT_CALINTERVAL : ATH_STA_SHORT_CALINTERVAL;\n\n\t \n\tif (ah->power_mode != ATH9K_PM_AWAKE)\n\t\tgoto set_timer;\n\n\t \n\tif ((timestamp - common->ani.longcal_timer) >= ATH_LONG_CALINTERVAL) {\n\t\tlongcal = true;\n\t\tath_dbg(common, ANI, \"longcal @%lu\\n\", jiffies);\n\t\tcommon->ani.longcal_timer = timestamp;\n\t}\n\n\t \n\tif (common->ani.caldone <= 0) {\n\t\tif ((timestamp - common->ani.shortcal_timer) >=\n\t\t    short_cal_interval) {\n\t\t\tshortcal = true;\n\t\t\tath_dbg(common, ANI, \"shortcal @%lu\\n\", jiffies);\n\t\t\tcommon->ani.shortcal_timer = timestamp;\n\t\t\tcommon->ani.resetcal_timer = timestamp;\n\t\t}\n\t} else {\n\t\tif ((timestamp - common->ani.resetcal_timer) >=\n\t\t    ATH_RESTART_CALINTERVAL) {\n\t\t\tcommon->ani.caldone = ath9k_hw_reset_calvalid(ah);\n\t\t\tif (common->ani.caldone)\n\t\t\t\tcommon->ani.resetcal_timer = timestamp;\n\t\t}\n\t}\n\n\t \n\tif ((timestamp - common->ani.checkani_timer) >= ATH_ANI_POLLINTERVAL) {\n\t\taniflag = true;\n\t\tcommon->ani.checkani_timer = timestamp;\n\t}\n\n\t \n\tif (longcal || shortcal || aniflag) {\n\n\t\tath9k_htc_ps_wakeup(priv);\n\n\t\t \n\t\tif (aniflag)\n\t\t\tath9k_hw_ani_monitor(ah, ah->curchan);\n\n\t\t \n\t\tif (longcal || shortcal)\n\t\t\tcommon->ani.caldone =\n\t\t\t\tath9k_hw_calibrate(ah, ah->curchan,\n\t\t\t\t\t\tah->rxchainmask, longcal) > 0;\n\n\t\tath9k_htc_ps_restore(priv);\n\t}\n\nset_timer:\n\t \n\tcal_interval = ATH_LONG_CALINTERVAL;\n\tcal_interval = min(cal_interval, (u32)ATH_ANI_POLLINTERVAL);\n\t \n\tif (common->ani.caldone <= 0)\n\t\tcal_interval = min(cal_interval, (u32)short_cal_interval);\n\n\tieee80211_queue_delayed_work(common->hw, &priv->ani_work,\n\t\t\t\t     msecs_to_jiffies(cal_interval));\n}\n\n \n \n \n\nstatic void ath9k_htc_tx(struct ieee80211_hw *hw,\n\t\t\t struct ieee80211_tx_control *control,\n\t\t\t struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr;\n\tstruct ath9k_htc_priv *priv = hw->priv;\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\tint padpos, padsize, ret, slot;\n\n\thdr = (struct ieee80211_hdr *) skb->data;\n\n\t \n\tpadpos = ieee80211_hdrlen(hdr->frame_control);\n\tpadsize = padpos & 3;\n\tif (padsize && skb->len > padpos) {\n\t\tif (skb_headroom(skb) < padsize) {\n\t\t\tath_dbg(common, XMIT, \"No room for padding\\n\");\n\t\t\tgoto fail_tx;\n\t\t}\n\t\tskb_push(skb, padsize);\n\t\tmemmove(skb->data, skb->data + padsize, padpos);\n\t}\n\n\tslot = ath9k_htc_tx_get_slot(priv);\n\tif (slot < 0) {\n\t\tath_dbg(common, XMIT, \"No free TX slot\\n\");\n\t\tgoto fail_tx;\n\t}\n\n\tret = ath9k_htc_tx_start(priv, control->sta, skb, slot, false);\n\tif (ret != 0) {\n\t\tath_dbg(common, XMIT, \"Tx failed\\n\");\n\t\tgoto clear_slot;\n\t}\n\n\tath9k_htc_check_stop_queues(priv);\n\n\treturn;\n\nclear_slot:\n\tath9k_htc_tx_clear_slot(priv, slot);\nfail_tx:\n\tdev_kfree_skb_any(skb);\n}\n\nstatic int ath9k_htc_start(struct ieee80211_hw *hw)\n{\n\tstruct ath9k_htc_priv *priv = hw->priv;\n\tstruct ath_hw *ah = priv->ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ieee80211_channel *curchan = hw->conf.chandef.chan;\n\tstruct ath9k_channel *init_channel;\n\tint ret = 0;\n\tenum htc_phymode mode;\n\t__be16 htc_mode;\n\tu8 cmd_rsp;\n\n\tmutex_lock(&priv->mutex);\n\n\tath_dbg(common, CONFIG,\n\t\t\"Starting driver with initial channel: %d MHz\\n\",\n\t\tcurchan->center_freq);\n\n\t \n\tath9k_htc_setpower(priv, ATH9K_PM_AWAKE);\n\tWMI_CMD(WMI_FLUSH_RECV_CMDID);\n\n\t \n\tinit_channel = ath9k_cmn_get_channel(hw, ah, &hw->conf.chandef);\n\n\tret = ath9k_hw_reset(ah, init_channel, ah->caldata, false);\n\tif (ret) {\n\t\tath_err(common,\n\t\t\t\"Unable to reset hardware; reset status %d (freq %u MHz)\\n\",\n\t\t\tret, curchan->center_freq);\n\t\tmutex_unlock(&priv->mutex);\n\t\treturn ret;\n\t}\n\n\tath9k_cmn_update_txpow(ah, priv->curtxpow, priv->txpowlimit,\n\t\t\t       &priv->curtxpow);\n\n\tmode = ath9k_htc_get_curmode(priv, init_channel);\n\thtc_mode = cpu_to_be16(mode);\n\tWMI_CMD_BUF(WMI_SET_MODE_CMDID, &htc_mode);\n\tWMI_CMD(WMI_ATH_INIT_CMDID);\n\tWMI_CMD(WMI_START_RECV_CMDID);\n\n\tath9k_host_rx_init(priv);\n\n\tret = ath9k_htc_update_cap_target(priv, 0);\n\tif (ret)\n\t\tath_dbg(common, CONFIG,\n\t\t\t\"Failed to update capability in target\\n\");\n\n\tclear_bit(ATH_OP_INVALID, &common->op_flags);\n\thtc_start(priv->htc);\n\n\tspin_lock_bh(&priv->tx.tx_lock);\n\tpriv->tx.flags &= ~ATH9K_HTC_OP_TX_QUEUES_STOP;\n\tspin_unlock_bh(&priv->tx.tx_lock);\n\n\tieee80211_wake_queues(hw);\n\n\tmod_timer(&priv->tx.cleanup_timer,\n\t\t  jiffies + msecs_to_jiffies(ATH9K_HTC_TX_CLEANUP_INTERVAL));\n\n\tath9k_htc_start_btcoex(priv);\n\n\tmutex_unlock(&priv->mutex);\n\n\treturn ret;\n}\n\nstatic void ath9k_htc_stop(struct ieee80211_hw *hw)\n{\n\tstruct ath9k_htc_priv *priv = hw->priv;\n\tstruct ath_hw *ah = priv->ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tint ret __attribute__ ((unused));\n\tu8 cmd_rsp;\n\n\tmutex_lock(&priv->mutex);\n\n\tif (test_bit(ATH_OP_INVALID, &common->op_flags)) {\n\t\tath_dbg(common, ANY, \"Device not present\\n\");\n\t\tmutex_unlock(&priv->mutex);\n\t\treturn;\n\t}\n\n\tath9k_htc_ps_wakeup(priv);\n\n\tWMI_CMD(WMI_DISABLE_INTR_CMDID);\n\tWMI_CMD(WMI_DRAIN_TXQ_ALL_CMDID);\n\tWMI_CMD(WMI_STOP_RECV_CMDID);\n\n\ttasklet_kill(&priv->rx_tasklet);\n\n\tdel_timer_sync(&priv->tx.cleanup_timer);\n\tath9k_htc_tx_drain(priv);\n\tath9k_wmi_event_drain(priv);\n\n\tmutex_unlock(&priv->mutex);\n\n\t \n\tcancel_work_sync(&priv->fatal_work);\n\tcancel_work_sync(&priv->ps_work);\n\n#ifdef CONFIG_MAC80211_LEDS\n\tcancel_work_sync(&priv->led_work);\n#endif\n\tath9k_htc_stop_ani(priv);\n\n\tmutex_lock(&priv->mutex);\n\n\tath9k_htc_stop_btcoex(priv);\n\n\t \n\tif (priv->ah->is_monitoring)\n\t\tath9k_htc_remove_monitor_interface(priv);\n\n\tath9k_hw_phy_disable(ah);\n\tath9k_hw_disable(ah);\n\tath9k_htc_ps_restore(priv);\n\tath9k_htc_setpower(priv, ATH9K_PM_FULL_SLEEP);\n\n\tset_bit(ATH_OP_INVALID, &common->op_flags);\n\n\tath_dbg(common, CONFIG, \"Driver halt\\n\");\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic int ath9k_htc_add_interface(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tstruct ath9k_htc_priv *priv = hw->priv;\n\tstruct ath9k_htc_vif *avp = (void *)vif->drv_priv;\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\tstruct ath9k_htc_target_vif hvif;\n\tint ret = 0;\n\tu8 cmd_rsp;\n\n\tmutex_lock(&priv->mutex);\n\n\tath9k_htc_ps_wakeup(priv);\n\tmemset(&hvif, 0, sizeof(struct ath9k_htc_target_vif));\n\tmemcpy(&hvif.myaddr, vif->addr, ETH_ALEN);\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\thvif.opmode = HTC_M_STA;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\thvif.opmode = HTC_M_IBSS;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\t\thvif.opmode = HTC_M_HOSTAP;\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\thvif.opmode = HTC_M_WDS;\t \n\t\tbreak;\n\tdefault:\n\t\tath_err(common,\n\t\t\t\"Interface type %d not yet supported\\n\", vif->type);\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\t \n\tavp->index = hvif.index = ffz(priv->vif_slot);\n\thvif.rtsthreshold = cpu_to_be16(2304);\n\tWMI_CMD_BUF(WMI_VAP_CREATE_CMDID, &hvif);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = ath9k_htc_add_station(priv, vif, NULL);\n\tif (ret) {\n\t\tWMI_CMD_BUF(WMI_VAP_REMOVE_CMDID, &hvif);\n\t\tgoto out;\n\t}\n\n\tath9k_htc_set_mac_bssid_mask(priv, vif);\n\n\tpriv->vif_slot |= (1 << avp->index);\n\tpriv->nvifs++;\n\n\tINC_VIF(priv, vif->type);\n\n\tif ((vif->type == NL80211_IFTYPE_AP) ||\n\t    (vif->type == NL80211_IFTYPE_MESH_POINT) ||\n\t    (vif->type == NL80211_IFTYPE_ADHOC))\n\t\tath9k_htc_assign_bslot(priv, vif);\n\n\tath9k_htc_set_opmode(priv);\n\n\tif ((priv->ah->opmode == NL80211_IFTYPE_AP) &&\n\t    !test_bit(ATH_OP_ANI_RUN, &common->op_flags)) {\n\t\tath9k_hw_set_tsfadjust(priv->ah, true);\n\t\tath9k_htc_start_ani(priv);\n\t}\n\n\tath_dbg(common, CONFIG, \"Attach a VIF of type: %d at idx: %d\\n\",\n\t\tvif->type, avp->index);\n\nout:\n\tath9k_htc_ps_restore(priv);\n\tmutex_unlock(&priv->mutex);\n\n\treturn ret;\n}\n\nstatic void ath9k_htc_remove_interface(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_vif *vif)\n{\n\tstruct ath9k_htc_priv *priv = hw->priv;\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\tstruct ath9k_htc_vif *avp = (void *)vif->drv_priv;\n\tstruct ath9k_htc_target_vif hvif;\n\tint ret = 0;\n\tu8 cmd_rsp;\n\n\tmutex_lock(&priv->mutex);\n\tath9k_htc_ps_wakeup(priv);\n\n\tmemset(&hvif, 0, sizeof(struct ath9k_htc_target_vif));\n\tmemcpy(&hvif.myaddr, vif->addr, ETH_ALEN);\n\thvif.index = avp->index;\n\tWMI_CMD_BUF(WMI_VAP_REMOVE_CMDID, &hvif);\n\tif (ret) {\n\t\tath_err(common, \"Unable to remove interface at idx: %d\\n\",\n\t\t\tavp->index);\n\t}\n\tpriv->nvifs--;\n\tpriv->vif_slot &= ~(1 << avp->index);\n\n\tif (priv->csa_vif == vif)\n\t\tpriv->csa_vif = NULL;\n\n\tath9k_htc_remove_station(priv, vif, NULL);\n\n\tDEC_VIF(priv, vif->type);\n\n\tif ((vif->type == NL80211_IFTYPE_AP) ||\n\t     vif->type == NL80211_IFTYPE_MESH_POINT ||\n\t    (vif->type == NL80211_IFTYPE_ADHOC))\n\t\tath9k_htc_remove_bslot(priv, vif);\n\n\tath9k_htc_set_opmode(priv);\n\n\tath9k_htc_set_mac_bssid_mask(priv, vif);\n\n\t \n\tif ((vif->type == NL80211_IFTYPE_AP) && (priv->num_ap_vif == 0)) {\n\t\tpriv->rearm_ani = false;\n\t\tieee80211_iterate_active_interfaces_atomic(\n\t\t\tpriv->hw, IEEE80211_IFACE_ITER_RESUME_ALL,\n\t\t\tath9k_htc_vif_iter, priv);\n\t\tif (!priv->rearm_ani)\n\t\t\tath9k_htc_stop_ani(priv);\n\t}\n\n\tath_dbg(common, CONFIG, \"Detach Interface at idx: %d\\n\", avp->index);\n\n\tath9k_htc_ps_restore(priv);\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic int ath9k_htc_config(struct ieee80211_hw *hw, u32 changed)\n{\n\tstruct ath9k_htc_priv *priv = hw->priv;\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\tstruct ieee80211_conf *conf = &hw->conf;\n\tbool chip_reset = false;\n\tint ret = 0;\n\n\tmutex_lock(&priv->mutex);\n\tath9k_htc_ps_wakeup(priv);\n\n\tif (changed & IEEE80211_CONF_CHANGE_IDLE) {\n\t\tmutex_lock(&priv->htc_pm_lock);\n\n\t\tpriv->ps_idle = !!(conf->flags & IEEE80211_CONF_IDLE);\n\t\tif (!priv->ps_idle)\n\t\t\tchip_reset = true;\n\n\t\tmutex_unlock(&priv->htc_pm_lock);\n\t}\n\n\t \n\tif (changed & IEEE80211_CONF_CHANGE_MONITOR) {\n\t\tif ((conf->flags & IEEE80211_CONF_MONITOR) &&\n\t\t    !priv->ah->is_monitoring)\n\t\t\tath9k_htc_add_monitor_interface(priv);\n\t\telse if (priv->ah->is_monitoring)\n\t\t\tath9k_htc_remove_monitor_interface(priv);\n\t}\n\n\tif ((changed & IEEE80211_CONF_CHANGE_CHANNEL) || chip_reset) {\n\t\tstruct ieee80211_channel *curchan = hw->conf.chandef.chan;\n\t\tint pos = curchan->hw_value;\n\n\t\tath_dbg(common, CONFIG, \"Set channel: %d MHz\\n\",\n\t\t\tcurchan->center_freq);\n\n\t\tath9k_cmn_get_channel(hw, priv->ah, &hw->conf.chandef);\n\t\tif (ath9k_htc_set_channel(priv, hw, &priv->ah->channels[pos]) < 0) {\n\t\t\tath_err(common, \"Unable to set channel\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t}\n\n\tif (changed & IEEE80211_CONF_CHANGE_PS) {\n\t\tif (conf->flags & IEEE80211_CONF_PS) {\n\t\t\tath9k_htc_setpower(priv, ATH9K_PM_NETWORK_SLEEP);\n\t\t\tpriv->ps_enabled = true;\n\t\t} else {\n\t\t\tpriv->ps_enabled = false;\n\t\t\tcancel_work_sync(&priv->ps_work);\n\t\t\tath9k_htc_setpower(priv, ATH9K_PM_AWAKE);\n\t\t}\n\t}\n\n\tif (changed & IEEE80211_CONF_CHANGE_POWER) {\n\t\tpriv->txpowlimit = 2 * conf->power_level;\n\t\tath9k_cmn_update_txpow(priv->ah, priv->curtxpow,\n\t\t\t\t       priv->txpowlimit, &priv->curtxpow);\n\t}\n\nout:\n\tath9k_htc_ps_restore(priv);\n\tmutex_unlock(&priv->mutex);\n\treturn ret;\n}\n\n#define SUPPORTED_FILTERS\t\t\t\\\n\t(FIF_ALLMULTI |\t\t\t\t\\\n\tFIF_CONTROL |\t\t\t\t\\\n\tFIF_PSPOLL |\t\t\t\t\\\n\tFIF_OTHER_BSS |\t\t\t\t\\\n\tFIF_BCN_PRBRESP_PROMISC |\t\t\\\n\tFIF_PROBE_REQ |\t\t\t\t\\\n\tFIF_MCAST_ACTION |\t\t\t\\\n\tFIF_FCSFAIL)\n\nstatic void ath9k_htc_configure_filter(struct ieee80211_hw *hw,\n\t\t\t\t       unsigned int changed_flags,\n\t\t\t\t       unsigned int *total_flags,\n\t\t\t\t       u64 multicast)\n{\n\tstruct ath9k_htc_priv *priv = hw->priv;\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\tu32 rfilt;\n\n\tmutex_lock(&priv->mutex);\n\t*total_flags &= SUPPORTED_FILTERS;\n\n\tif (test_bit(ATH_OP_INVALID, &common->op_flags)) {\n\t\tath_dbg(ath9k_hw_common(priv->ah), ANY,\n\t\t\t\"Unable to configure filter on invalid state\\n\");\n\t\tmutex_unlock(&priv->mutex);\n\t\treturn;\n\t}\n\tath9k_htc_ps_wakeup(priv);\n\n\tpriv->rxfilter = *total_flags;\n\trfilt = ath9k_htc_calcrxfilter(priv);\n\tath9k_hw_setrxfilter(priv->ah, rfilt);\n\n\tath_dbg(ath9k_hw_common(priv->ah), CONFIG, \"Set HW RX filter: 0x%x\\n\",\n\t\trfilt);\n\n\tath9k_htc_ps_restore(priv);\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic void ath9k_htc_sta_rc_update_work(struct work_struct *work)\n{\n\tstruct ath9k_htc_sta *ista =\n\t    container_of(work, struct ath9k_htc_sta, rc_update_work);\n\tstruct ieee80211_sta *sta =\n\t    container_of((void *)ista, struct ieee80211_sta, drv_priv);\n\tstruct ath9k_htc_priv *priv = ista->htc_priv;\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\tstruct ath9k_htc_target_rate trate;\n\n\tmutex_lock(&priv->mutex);\n\tath9k_htc_ps_wakeup(priv);\n\n\tmemset(&trate, 0, sizeof(struct ath9k_htc_target_rate));\n\tath9k_htc_setup_rate(priv, sta, &trate);\n\tif (!ath9k_htc_send_rate_cmd(priv, &trate))\n\t\tath_dbg(common, CONFIG,\n\t\t\t\"Supported rates for sta: %pM updated, rate caps: 0x%X\\n\",\n\t\t\tsta->addr, be32_to_cpu(trate.capflags));\n\telse\n\t\tath_dbg(common, CONFIG,\n\t\t\t\"Unable to update supported rates for sta: %pM\\n\",\n\t\t\tsta->addr);\n\n\tath9k_htc_ps_restore(priv);\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic int ath9k_htc_sta_add(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     struct ieee80211_sta *sta)\n{\n\tstruct ath9k_htc_priv *priv = hw->priv;\n\tstruct ath9k_htc_sta *ista = (struct ath9k_htc_sta *) sta->drv_priv;\n\tint ret;\n\n\tmutex_lock(&priv->mutex);\n\tath9k_htc_ps_wakeup(priv);\n\tret = ath9k_htc_add_station(priv, vif, sta);\n\tif (!ret) {\n\t\tINIT_WORK(&ista->rc_update_work, ath9k_htc_sta_rc_update_work);\n\t\tista->htc_priv = priv;\n\t\tath9k_htc_init_rate(priv, sta);\n\t}\n\tath9k_htc_ps_restore(priv);\n\tmutex_unlock(&priv->mutex);\n\n\treturn ret;\n}\n\nstatic int ath9k_htc_sta_remove(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_sta *sta)\n{\n\tstruct ath9k_htc_priv *priv = hw->priv;\n\tstruct ath9k_htc_sta *ista = (struct ath9k_htc_sta *) sta->drv_priv;\n\tint ret;\n\n\tcancel_work_sync(&ista->rc_update_work);\n\n\tmutex_lock(&priv->mutex);\n\tath9k_htc_ps_wakeup(priv);\n\thtc_sta_drain(priv->htc, ista->index);\n\tret = ath9k_htc_remove_station(priv, vif, sta);\n\tath9k_htc_ps_restore(priv);\n\tmutex_unlock(&priv->mutex);\n\n\treturn ret;\n}\n\nstatic void ath9k_htc_sta_rc_update(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct ieee80211_sta *sta, u32 changed)\n{\n\tstruct ath9k_htc_sta *ista = (struct ath9k_htc_sta *) sta->drv_priv;\n\n\tif (!(changed & IEEE80211_RC_SUPP_RATES_CHANGED))\n\t\treturn;\n\n\tschedule_work(&ista->rc_update_work);\n}\n\nstatic int ath9k_htc_conf_tx(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     unsigned int link_id, u16 queue,\n\t\t\t     const struct ieee80211_tx_queue_params *params)\n{\n\tstruct ath9k_htc_priv *priv = hw->priv;\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\tstruct ath9k_tx_queue_info qi;\n\tint ret = 0, qnum;\n\n\tif (queue >= IEEE80211_NUM_ACS)\n\t\treturn 0;\n\n\tmutex_lock(&priv->mutex);\n\tath9k_htc_ps_wakeup(priv);\n\n\tmemset(&qi, 0, sizeof(struct ath9k_tx_queue_info));\n\n\tqi.tqi_aifs = params->aifs;\n\tqi.tqi_cwmin = params->cw_min;\n\tqi.tqi_cwmax = params->cw_max;\n\tqi.tqi_burstTime = params->txop * 32;\n\n\tqnum = get_hw_qnum(queue, priv->hwq_map);\n\n\tath_dbg(common, CONFIG,\n\t\t\"Configure tx [queue/hwq] [%d/%d],  aifs: %d, cw_min: %d, cw_max: %d, txop: %d\\n\",\n\t\tqueue, qnum, params->aifs, params->cw_min,\n\t\tparams->cw_max, params->txop);\n\n\tret = ath_htc_txq_update(priv, qnum, &qi);\n\tif (ret) {\n\t\tath_err(common, \"TXQ Update failed\\n\");\n\t\tgoto out;\n\t}\n\n\tif ((priv->ah->opmode == NL80211_IFTYPE_ADHOC) &&\n\t    (qnum == priv->hwq_map[IEEE80211_AC_BE]))\n\t\t    ath9k_htc_beaconq_config(priv);\nout:\n\tath9k_htc_ps_restore(priv);\n\tmutex_unlock(&priv->mutex);\n\n\treturn ret;\n}\n\nstatic int ath9k_htc_set_key(struct ieee80211_hw *hw,\n\t\t\t     enum set_key_cmd cmd,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     struct ieee80211_sta *sta,\n\t\t\t     struct ieee80211_key_conf *key)\n{\n\tstruct ath9k_htc_priv *priv = hw->priv;\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\tint ret = 0;\n\n\tif (htc_modparam_nohwcrypt)\n\t\treturn -ENOSPC;\n\n\tif ((vif->type == NL80211_IFTYPE_ADHOC ||\n\t     vif->type == NL80211_IFTYPE_MESH_POINT) &&\n\t    (key->cipher == WLAN_CIPHER_SUITE_TKIP ||\n\t     key->cipher == WLAN_CIPHER_SUITE_CCMP) &&\n\t    !(key->flags & IEEE80211_KEY_FLAG_PAIRWISE)) {\n\t\t \n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmutex_lock(&priv->mutex);\n\tath_dbg(common, CONFIG, \"Set HW Key\\n\");\n\tath9k_htc_ps_wakeup(priv);\n\n\tswitch (cmd) {\n\tcase SET_KEY:\n\t\tret = ath_key_config(common, vif, sta, key);\n\t\tif (ret >= 0) {\n\t\t\tkey->hw_key_idx = ret;\n\t\t\t \n\t\t\tkey->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;\n\t\t\tif (key->cipher == WLAN_CIPHER_SUITE_TKIP)\n\t\t\t\tkey->flags |= IEEE80211_KEY_FLAG_GENERATE_MMIC;\n\t\t\tif (priv->ah->sw_mgmt_crypto_tx &&\n\t\t\t    key->cipher == WLAN_CIPHER_SUITE_CCMP)\n\t\t\t\tkey->flags |= IEEE80211_KEY_FLAG_SW_MGMT_TX;\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\tcase DISABLE_KEY:\n\t\tath_key_delete(common, key->hw_key_idx);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tath9k_htc_ps_restore(priv);\n\tmutex_unlock(&priv->mutex);\n\n\treturn ret;\n}\n\nstatic void ath9k_htc_set_bssid(struct ath9k_htc_priv *priv)\n{\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\n\tath9k_hw_write_associd(priv->ah);\n\tath_dbg(common, CONFIG, \"BSSID: %pM aid: 0x%x\\n\",\n\t\tcommon->curbssid, common->curaid);\n}\n\nstatic void ath9k_htc_bss_iter(void *data, u8 *mac, struct ieee80211_vif *vif)\n{\n\tstruct ath9k_htc_priv *priv = data;\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\tstruct ieee80211_bss_conf *bss_conf = &vif->bss_conf;\n\n\tif ((vif->type == NL80211_IFTYPE_STATION) && vif->cfg.assoc) {\n\t\tcommon->curaid = vif->cfg.aid;\n\t\tcommon->last_rssi = ATH_RSSI_DUMMY_MARKER;\n\t\tmemcpy(common->curbssid, bss_conf->bssid, ETH_ALEN);\n\t\tset_bit(ATH_OP_PRIM_STA_VIF, &common->op_flags);\n\t}\n}\n\nstatic void ath9k_htc_choose_set_bssid(struct ath9k_htc_priv *priv)\n{\n\tif (priv->num_sta_assoc_vif == 1) {\n\t\tieee80211_iterate_active_interfaces_atomic(\n\t\t\tpriv->hw, IEEE80211_IFACE_ITER_RESUME_ALL,\n\t\t\tath9k_htc_bss_iter, priv);\n\t\tath9k_htc_set_bssid(priv);\n\t}\n}\n\nstatic void ath9k_htc_bss_info_changed(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       struct ieee80211_bss_conf *bss_conf,\n\t\t\t\t       u64 changed)\n{\n\tstruct ath9k_htc_priv *priv = hw->priv;\n\tstruct ath_hw *ah = priv->ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tint slottime;\n\n\tmutex_lock(&priv->mutex);\n\tath9k_htc_ps_wakeup(priv);\n\n\tif (changed & BSS_CHANGED_ASSOC) {\n\t\tath_dbg(common, CONFIG, \"BSS Changed ASSOC %d\\n\",\n\t\t\tvif->cfg.assoc);\n\n\t\tvif->cfg.assoc ?\n\t\t\tpriv->num_sta_assoc_vif++ : priv->num_sta_assoc_vif--;\n\n\t\tif (!vif->cfg.assoc)\n\t\t\tclear_bit(ATH_OP_PRIM_STA_VIF, &common->op_flags);\n\n\t\tif (priv->ah->opmode == NL80211_IFTYPE_STATION) {\n\t\t\tath9k_htc_choose_set_bssid(priv);\n\t\t\tif (vif->cfg.assoc && (priv->num_sta_assoc_vif == 1))\n\t\t\t\tath9k_htc_start_ani(priv);\n\t\t\telse if (priv->num_sta_assoc_vif == 0)\n\t\t\t\tath9k_htc_stop_ani(priv);\n\t\t}\n\t}\n\n\tif (changed & BSS_CHANGED_IBSS) {\n\t\tif (priv->ah->opmode == NL80211_IFTYPE_ADHOC) {\n\t\t\tcommon->curaid = vif->cfg.aid;\n\t\t\tmemcpy(common->curbssid, bss_conf->bssid, ETH_ALEN);\n\t\t\tath9k_htc_set_bssid(priv);\n\t\t}\n\t}\n\n\tif ((changed & BSS_CHANGED_BEACON_ENABLED) && bss_conf->enable_beacon) {\n\t\tath_dbg(common, CONFIG, \"Beacon enabled for BSS: %pM\\n\",\n\t\t\tbss_conf->bssid);\n\t\tath9k_htc_set_tsfadjust(priv, vif);\n\t\tpriv->cur_beacon_conf.enable_beacon = 1;\n\t\tath9k_htc_beacon_config(priv, vif);\n\t}\n\n\tif ((changed & BSS_CHANGED_BEACON_ENABLED) && !bss_conf->enable_beacon) {\n\t\t \n\t\tif ((priv->num_ap_vif + priv->num_mbss_vif <= 1) ||\n\t\t     priv->num_ibss_vif) {\n\t\t\tath_dbg(common, CONFIG,\n\t\t\t\t\"Beacon disabled for BSS: %pM\\n\",\n\t\t\t\tbss_conf->bssid);\n\t\t\tpriv->cur_beacon_conf.enable_beacon = 0;\n\t\t\tath9k_htc_beacon_config(priv, vif);\n\t\t}\n\t}\n\n\tif (changed & BSS_CHANGED_BEACON_INT) {\n\t\t \n\t\tif (priv->nvifs == 1 &&\n\t\t    ((priv->ah->opmode == NL80211_IFTYPE_AP &&\n\t\t      vif->type == NL80211_IFTYPE_AP &&\n\t\t      priv->num_ap_vif == 1) ||\n\t\t    (priv->ah->opmode == NL80211_IFTYPE_MESH_POINT &&\n\t\t      vif->type == NL80211_IFTYPE_MESH_POINT &&\n\t\t      priv->num_mbss_vif == 1))) {\n\t\t\tset_bit(OP_TSF_RESET, &priv->op_flags);\n\t\t}\n\t\tath_dbg(common, CONFIG,\n\t\t\t\"Beacon interval changed for BSS: %pM\\n\",\n\t\t\tbss_conf->bssid);\n\t\tath9k_htc_beacon_config(priv, vif);\n\t}\n\n\tif (changed & BSS_CHANGED_ERP_SLOT) {\n\t\tif (bss_conf->use_short_slot)\n\t\t\tslottime = 9;\n\t\telse\n\t\t\tslottime = 20;\n\t\tif (vif->type == NL80211_IFTYPE_AP) {\n\t\t\t \n\t\t\tpriv->beacon.slottime = slottime;\n\t\t\tpriv->beacon.updateslot = UPDATE;\n\t\t} else {\n\t\t\tah->slottime = slottime;\n\t\t\tath9k_hw_init_global_settings(ah);\n\t\t}\n\t}\n\n\tif (changed & BSS_CHANGED_HT)\n\t\tath9k_htc_update_rate(priv, vif, bss_conf);\n\n\tath9k_htc_ps_restore(priv);\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic u64 ath9k_htc_get_tsf(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct ath9k_htc_priv *priv = hw->priv;\n\tu64 tsf;\n\n\tmutex_lock(&priv->mutex);\n\tath9k_htc_ps_wakeup(priv);\n\ttsf = ath9k_hw_gettsf64(priv->ah);\n\tath9k_htc_ps_restore(priv);\n\tmutex_unlock(&priv->mutex);\n\n\treturn tsf;\n}\n\nstatic void ath9k_htc_set_tsf(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif, u64 tsf)\n{\n\tstruct ath9k_htc_priv *priv = hw->priv;\n\n\tmutex_lock(&priv->mutex);\n\tath9k_htc_ps_wakeup(priv);\n\tath9k_hw_settsf64(priv->ah, tsf);\n\tath9k_htc_ps_restore(priv);\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic void ath9k_htc_reset_tsf(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif)\n{\n\tstruct ath9k_htc_priv *priv = hw->priv;\n\n\tmutex_lock(&priv->mutex);\n\tath9k_htc_ps_wakeup(priv);\n\tath9k_hw_reset_tsf(priv->ah);\n\tath9k_htc_ps_restore(priv);\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic int ath9k_htc_ampdu_action(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  struct ieee80211_ampdu_params *params)\n{\n\tstruct ath9k_htc_priv *priv = hw->priv;\n\tstruct ath9k_htc_sta *ista;\n\tint ret = 0;\n\tstruct ieee80211_sta *sta = params->sta;\n\tenum ieee80211_ampdu_mlme_action action = params->action;\n\tu16 tid = params->tid;\n\n\tmutex_lock(&priv->mutex);\n\tath9k_htc_ps_wakeup(priv);\n\n\tswitch (action) {\n\tcase IEEE80211_AMPDU_RX_START:\n\t\tbreak;\n\tcase IEEE80211_AMPDU_RX_STOP:\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_START:\n\t\tret = ath9k_htc_tx_aggr_oper(priv, vif, sta, action, tid);\n\t\tif (!ret)\n\t\t\tret = IEEE80211_AMPDU_TX_START_IMMEDIATE;\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_STOP_CONT:\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH:\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH_CONT:\n\t\tath9k_htc_tx_aggr_oper(priv, vif, sta, action, tid);\n\t\tieee80211_stop_tx_ba_cb_irqsafe(vif, sta->addr, tid);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_OPERATIONAL:\n\t\tif (tid >= ATH9K_HTC_MAX_TID) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tista = (struct ath9k_htc_sta *) sta->drv_priv;\n\t\tspin_lock_bh(&priv->tx.tx_lock);\n\t\tista->tid_state[tid] = AGGR_OPERATIONAL;\n\t\tspin_unlock_bh(&priv->tx.tx_lock);\n\t\tbreak;\n\tdefault:\n\t\tath_err(ath9k_hw_common(priv->ah), \"Unknown AMPDU action\\n\");\n\t}\n\n\tath9k_htc_ps_restore(priv);\n\tmutex_unlock(&priv->mutex);\n\n\treturn ret;\n}\n\nstatic void ath9k_htc_sw_scan_start(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    const u8 *mac_addr)\n{\n\tstruct ath9k_htc_priv *priv = hw->priv;\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\n\tmutex_lock(&priv->mutex);\n\tspin_lock_bh(&priv->beacon_lock);\n\tset_bit(ATH_OP_SCANNING, &common->op_flags);\n\tspin_unlock_bh(&priv->beacon_lock);\n\tcancel_work_sync(&priv->ps_work);\n\tath9k_htc_stop_ani(priv);\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic void ath9k_htc_sw_scan_complete(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_vif *vif)\n{\n\tstruct ath9k_htc_priv *priv = hw->priv;\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\n\tmutex_lock(&priv->mutex);\n\tspin_lock_bh(&priv->beacon_lock);\n\tclear_bit(ATH_OP_SCANNING, &common->op_flags);\n\tspin_unlock_bh(&priv->beacon_lock);\n\tath9k_htc_ps_wakeup(priv);\n\tath9k_htc_vif_reconfig(priv);\n\tath9k_htc_ps_restore(priv);\n\tmutex_unlock(&priv->mutex);\n}\n\nstatic int ath9k_htc_set_rts_threshold(struct ieee80211_hw *hw, u32 value)\n{\n\treturn 0;\n}\n\nstatic void ath9k_htc_set_coverage_class(struct ieee80211_hw *hw,\n\t\t\t\t\t s16 coverage_class)\n{\n\tstruct ath9k_htc_priv *priv = hw->priv;\n\n\tmutex_lock(&priv->mutex);\n\tath9k_htc_ps_wakeup(priv);\n\tpriv->ah->coverage_class = coverage_class;\n\tath9k_hw_init_global_settings(priv->ah);\n\tath9k_htc_ps_restore(priv);\n\tmutex_unlock(&priv->mutex);\n}\n\n \nstatic int ath9k_htc_set_bitrate_mask(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      const struct cfg80211_bitrate_mask *mask)\n{\n\tstruct ath9k_htc_priv *priv = hw->priv;\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\tstruct ath9k_htc_target_rate_mask tmask;\n\tstruct ath9k_htc_vif *avp = (void *)vif->drv_priv;\n\tint ret = 0;\n\tu8 cmd_rsp;\n\n\tmemset(&tmask, 0, sizeof(struct ath9k_htc_target_rate_mask));\n\n\ttmask.vif_index = avp->index;\n\ttmask.band = NL80211_BAND_2GHZ;\n\ttmask.mask = cpu_to_be32(mask->control[NL80211_BAND_2GHZ].legacy);\n\n\tWMI_CMD_BUF(WMI_BITRATE_MASK_CMDID, &tmask);\n\tif (ret) {\n\t\tath_err(common,\n\t\t\t\"Unable to set 2G rate mask for \"\n\t\t\t\"interface at idx: %d\\n\", avp->index);\n\t\tgoto out;\n\t}\n\n\ttmask.band = NL80211_BAND_5GHZ;\n\ttmask.mask = cpu_to_be32(mask->control[NL80211_BAND_5GHZ].legacy);\n\n\tWMI_CMD_BUF(WMI_BITRATE_MASK_CMDID, &tmask);\n\tif (ret) {\n\t\tath_err(common,\n\t\t\t\"Unable to set 5G rate mask for \"\n\t\t\t\"interface at idx: %d\\n\", avp->index);\n\t\tgoto out;\n\t}\n\n\tath_dbg(common, CONFIG, \"Set bitrate masks: 0x%x, 0x%x\\n\",\n\t\tmask->control[NL80211_BAND_2GHZ].legacy,\n\t\tmask->control[NL80211_BAND_5GHZ].legacy);\nout:\n\treturn ret;\n}\n\n\nstatic int ath9k_htc_get_stats(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_low_level_stats *stats)\n{\n\tstruct ath9k_htc_priv *priv = hw->priv;\n\tstruct ath_hw *ah = priv->ah;\n\tstruct ath9k_mib_stats *mib_stats = &ah->ah_mibStats;\n\n\tstats->dot11ACKFailureCount = mib_stats->ackrcv_bad;\n\tstats->dot11RTSFailureCount = mib_stats->rts_bad;\n\tstats->dot11FCSErrorCount = mib_stats->fcs_bad;\n\tstats->dot11RTSSuccessCount = mib_stats->rts_good;\n\n\treturn 0;\n}\n\nstruct base_eep_header *ath9k_htc_get_eeprom_base(struct ath9k_htc_priv *priv)\n{\n\tstruct base_eep_header *pBase = NULL;\n\t \n\n\tif (AR_SREV_9271(priv->ah))\n\t\tpBase = (struct base_eep_header *)\n\t\t\t&priv->ah->eeprom.map4k.baseEepHeader;\n\telse if (priv->ah->hw_version.usbdev == AR9280_USB)\n\t\tpBase = (struct base_eep_header *)\n\t\t\t&priv->ah->eeprom.def.baseEepHeader;\n\telse if (priv->ah->hw_version.usbdev == AR9287_USB)\n\t\tpBase = (struct base_eep_header *)\n\t\t\t&priv->ah->eeprom.map9287.baseEepHeader;\n\treturn pBase;\n}\n\n\nstatic int ath9k_htc_get_antenna(struct ieee80211_hw *hw, u32 *tx_ant,\n\t\t\t\t u32 *rx_ant)\n{\n\tstruct ath9k_htc_priv *priv = hw->priv;\n\tstruct base_eep_header *pBase = ath9k_htc_get_eeprom_base(priv);\n\tif (pBase) {\n\t\t*tx_ant = pBase->txMask;\n\t\t*rx_ant = pBase->rxMask;\n\t} else {\n\t\t*tx_ant = 0;\n\t\t*rx_ant = 0;\n\t}\n\treturn 0;\n}\n\nstatic void ath9k_htc_channel_switch_beacon(struct ieee80211_hw *hw,\n\t\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t\t    struct cfg80211_chan_def *chandef)\n{\n\tstruct ath9k_htc_priv *priv = hw->priv;\n\n\t \n\tif (WARN_ON(priv->csa_vif))\n\t\treturn;\n\n\tpriv->csa_vif = vif;\n}\n\nstruct ieee80211_ops ath9k_htc_ops = {\n\t.tx                 = ath9k_htc_tx,\n\t.wake_tx_queue      = ieee80211_handle_wake_tx_queue,\n\t.start              = ath9k_htc_start,\n\t.stop               = ath9k_htc_stop,\n\t.add_interface      = ath9k_htc_add_interface,\n\t.remove_interface   = ath9k_htc_remove_interface,\n\t.config             = ath9k_htc_config,\n\t.configure_filter   = ath9k_htc_configure_filter,\n\t.sta_add            = ath9k_htc_sta_add,\n\t.sta_remove         = ath9k_htc_sta_remove,\n\t.conf_tx            = ath9k_htc_conf_tx,\n\t.sta_rc_update      = ath9k_htc_sta_rc_update,\n\t.bss_info_changed   = ath9k_htc_bss_info_changed,\n\t.set_key            = ath9k_htc_set_key,\n\t.get_tsf            = ath9k_htc_get_tsf,\n\t.set_tsf            = ath9k_htc_set_tsf,\n\t.reset_tsf          = ath9k_htc_reset_tsf,\n\t.ampdu_action       = ath9k_htc_ampdu_action,\n\t.sw_scan_start      = ath9k_htc_sw_scan_start,\n\t.sw_scan_complete   = ath9k_htc_sw_scan_complete,\n\t.set_rts_threshold  = ath9k_htc_set_rts_threshold,\n\t.rfkill_poll        = ath9k_htc_rfkill_poll_state,\n\t.set_coverage_class = ath9k_htc_set_coverage_class,\n\t.set_bitrate_mask   = ath9k_htc_set_bitrate_mask,\n\t.get_stats\t    = ath9k_htc_get_stats,\n\t.get_antenna\t    = ath9k_htc_get_antenna,\n\t.channel_switch_beacon\t= ath9k_htc_channel_switch_beacon,\n\n#ifdef CONFIG_ATH9K_HTC_DEBUGFS\n\t.get_et_sset_count  = ath9k_htc_get_et_sset_count,\n\t.get_et_stats       = ath9k_htc_get_et_stats,\n\t.get_et_strings     = ath9k_htc_get_et_strings,\n#endif\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}