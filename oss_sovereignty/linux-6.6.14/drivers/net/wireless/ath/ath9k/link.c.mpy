{
  "module_name": "link.c",
  "hash_id": "ff345841f82d7e5b1c2c7593493a37950e2508933e8f4de1115986efaf8dc8e9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath9k/link.c",
  "human_readable_source": " \n\n#include \"ath9k.h\"\n\n \nstatic bool ath_tx_complete_check(struct ath_softc *sc)\n{\n\tstruct ath_txq *txq;\n\tint i;\n\n\tif (sc->tx99_state)\n\t\treturn true;\n\n\tfor (i = 0; i < IEEE80211_NUM_ACS; i++) {\n\t\ttxq = sc->tx.txq_map[i];\n\n\t\tath_txq_lock(sc, txq);\n\t\tif (txq->axq_depth) {\n\t\t\tif (txq->axq_tx_inprogress) {\n\t\t\t\tath_txq_unlock(sc, txq);\n\t\t\t\tgoto reset;\n\t\t\t}\n\n\t\t\ttxq->axq_tx_inprogress = true;\n\t\t}\n\t\tath_txq_unlock(sc, txq);\n\t}\n\n\treturn true;\n\nreset:\n\tath_dbg(ath9k_hw_common(sc->sc_ah), RESET,\n\t\t\"tx hung, resetting the chip\\n\");\n\tath9k_queue_reset(sc, RESET_TYPE_TX_HANG);\n\treturn false;\n\n}\n\nvoid ath_hw_check_work(struct work_struct *work)\n{\n\tstruct ath_softc *sc = container_of(work, struct ath_softc,\n\t\t\t\t\t    hw_check_work.work);\n\n\tif (!ath_hw_check(sc) ||\n\t    !ath_tx_complete_check(sc))\n\t\treturn;\n\n\tieee80211_queue_delayed_work(sc->hw, &sc->hw_check_work,\n\t\t\t\t     msecs_to_jiffies(ATH_HW_CHECK_POLL_INT));\n}\n\n \nbool ath_hw_check(struct ath_softc *sc)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tenum ath_reset_type type;\n\tbool is_alive;\n\n\tath9k_ps_wakeup(sc);\n\n\tis_alive = ath9k_hw_check_alive(sc->sc_ah);\n\n\tif (!is_alive) {\n\t\tath_dbg(common, RESET,\n\t\t\t\"HW hang detected, schedule chip reset\\n\");\n\t\ttype = RESET_TYPE_MAC_HANG;\n\t\tath9k_queue_reset(sc, type);\n\t}\n\n\tath9k_ps_restore(sc);\n\n\treturn is_alive;\n}\n\n \nstatic bool ath_hw_pll_rx_hang_check(struct ath_softc *sc, u32 pll_sqsum)\n{\n\tstatic int count;\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\n\tif (pll_sqsum >= 0x40000) {\n\t\tcount++;\n\t\tif (count == 3) {\n\t\t\tath_dbg(common, RESET, \"PLL WAR, resetting the chip\\n\");\n\t\t\tath9k_queue_reset(sc, RESET_TYPE_PLL_HANG);\n\t\t\tcount = 0;\n\t\t\treturn true;\n\t\t}\n\t} else {\n\t\tcount = 0;\n\t}\n\n\treturn false;\n}\n\nvoid ath_hw_pll_work(struct work_struct *work)\n{\n\tu32 pll_sqsum;\n\tstruct ath_softc *sc = container_of(work, struct ath_softc,\n\t\t\t\t\t    hw_pll_work.work);\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\t \n\tif (!test_bit(ATH_OP_BEACONS, &common->op_flags))\n\t\treturn;\n\n\tif (sc->tx99_state)\n\t\treturn;\n\n\tath9k_ps_wakeup(sc);\n\tpll_sqsum = ar9003_get_pll_sqsum_dvc(sc->sc_ah);\n\tath9k_ps_restore(sc);\n\tif (ath_hw_pll_rx_hang_check(sc, pll_sqsum))\n\t\treturn;\n\n\tieee80211_queue_delayed_work(sc->hw, &sc->hw_pll_work,\n\t\t\t\t     msecs_to_jiffies(ATH_PLL_WORK_INTERVAL));\n}\n\n \nstatic void ath_paprd_activate(struct ath_softc *sc)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath9k_hw_cal_data *caldata = ah->caldata;\n\tint chain;\n\n\tif (!caldata || !test_bit(PAPRD_DONE, &caldata->cal_flags)) {\n\t\tath_dbg(common, CALIBRATE, \"Failed to activate PAPRD\\n\");\n\t\treturn;\n\t}\n\n\tar9003_paprd_enable(ah, false);\n\tfor (chain = 0; chain < AR9300_MAX_CHAINS; chain++) {\n\t\tif (!(ah->txchainmask & BIT(chain)))\n\t\t\tcontinue;\n\n\t\tar9003_paprd_populate_single_table(ah, caldata, chain);\n\t}\n\n\tath_dbg(common, CALIBRATE, \"Activating PAPRD\\n\");\n\tar9003_paprd_enable(ah, true);\n}\n\nstatic bool ath_paprd_send_frame(struct ath_softc *sc, struct sk_buff *skb, int chain)\n{\n\tstruct ieee80211_hw *hw = sc->hw;\n\tstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath_tx_control txctl;\n\tunsigned long time_left;\n\n\tmemset(&txctl, 0, sizeof(txctl));\n\ttxctl.txq = sc->tx.txq_map[IEEE80211_AC_BE];\n\n\tmemset(tx_info, 0, sizeof(*tx_info));\n\ttx_info->band = sc->cur_chandef.chan->band;\n\ttx_info->flags |= IEEE80211_TX_CTL_NO_ACK;\n\ttx_info->control.rates[0].idx = 0;\n\ttx_info->control.rates[0].count = 1;\n\ttx_info->control.rates[0].flags = IEEE80211_TX_RC_MCS;\n\ttx_info->control.rates[1].idx = -1;\n\n\tinit_completion(&sc->paprd_complete);\n\ttxctl.paprd = BIT(chain);\n\n\tif (ath_tx_start(hw, skb, &txctl) != 0) {\n\t\tath_dbg(common, CALIBRATE, \"PAPRD TX failed\\n\");\n\t\tdev_kfree_skb_any(skb);\n\t\treturn false;\n\t}\n\n\ttime_left = wait_for_completion_timeout(&sc->paprd_complete,\n\t\t\tmsecs_to_jiffies(ATH_PAPRD_TIMEOUT));\n\n\tif (!time_left)\n\t\tath_dbg(common, CALIBRATE,\n\t\t\t\"Timeout waiting for paprd training on TX chain %d\\n\",\n\t\t\tchain);\n\n\treturn !!time_left;\n}\n\nvoid ath_paprd_calibrate(struct work_struct *work)\n{\n\tstruct ath_softc *sc = container_of(work, struct ath_softc, paprd_work);\n\tstruct ieee80211_hw *hw = sc->hw;\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ieee80211_hdr *hdr;\n\tstruct sk_buff *skb = NULL;\n\tstruct ath9k_hw_cal_data *caldata = ah->caldata;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tint ftype;\n\tint chain_ok = 0;\n\tint chain;\n\tint len = 1800;\n\tint ret;\n\n\tif (!caldata ||\n\t    !test_bit(PAPRD_PACKET_SENT, &caldata->cal_flags) ||\n\t    test_bit(PAPRD_DONE, &caldata->cal_flags)) {\n\t\tath_dbg(common, CALIBRATE, \"Skipping PAPRD calibration\\n\");\n\t\treturn;\n\t}\n\n\tath9k_ps_wakeup(sc);\n\n\tif (ar9003_paprd_init_table(ah) < 0)\n\t\tgoto fail_paprd;\n\n\tskb = alloc_skb(len, GFP_KERNEL);\n\tif (!skb)\n\t\tgoto fail_paprd;\n\n\tskb_put(skb, len);\n\tmemset(skb->data, 0, len);\n\thdr = (struct ieee80211_hdr *)skb->data;\n\tftype = IEEE80211_FTYPE_DATA | IEEE80211_STYPE_NULLFUNC;\n\thdr->frame_control = cpu_to_le16(ftype);\n\thdr->duration_id = cpu_to_le16(10);\n\tmemcpy(hdr->addr1, hw->wiphy->perm_addr, ETH_ALEN);\n\tmemcpy(hdr->addr2, hw->wiphy->perm_addr, ETH_ALEN);\n\tmemcpy(hdr->addr3, hw->wiphy->perm_addr, ETH_ALEN);\n\n\tfor (chain = 0; chain < AR9300_MAX_CHAINS; chain++) {\n\t\tif (!(ah->txchainmask & BIT(chain)))\n\t\t\tcontinue;\n\n\t\tchain_ok = 0;\n\t\tar9003_paprd_setup_gain_table(ah, chain);\n\n\t\tath_dbg(common, CALIBRATE,\n\t\t\t\"Sending PAPRD training frame on chain %d\\n\", chain);\n\t\tif (!ath_paprd_send_frame(sc, skb, chain))\n\t\t\tgoto fail_paprd;\n\n\t\tif (!ar9003_paprd_is_done(ah)) {\n\t\t\tath_dbg(common, CALIBRATE,\n\t\t\t\t\"PAPRD not yet done on chain %d\\n\", chain);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ar9003_paprd_create_curve(ah, caldata, chain);\n\t\tif (ret == -EINPROGRESS) {\n\t\t\tath_dbg(common, CALIBRATE,\n\t\t\t\t\"PAPRD curve on chain %d needs to be re-trained\\n\",\n\t\t\t\tchain);\n\t\t\tbreak;\n\t\t} else if (ret) {\n\t\t\tath_dbg(common, CALIBRATE,\n\t\t\t\t\"PAPRD create curve failed on chain %d\\n\",\n\t\t\t\tchain);\n\t\t\tbreak;\n\t\t}\n\n\t\tchain_ok = 1;\n\t}\n\tkfree_skb(skb);\n\n\tif (chain_ok) {\n\t\tset_bit(PAPRD_DONE, &caldata->cal_flags);\n\t\tath_paprd_activate(sc);\n\t}\n\nfail_paprd:\n\tath9k_ps_restore(sc);\n}\n\n \nvoid ath_ani_calibrate(struct timer_list *t)\n{\n\tstruct ath_common *common = from_timer(common, t, ani.timer);\n\tstruct ath_softc *sc = (struct ath_softc *)common->priv;\n\tstruct ath_hw *ah = sc->sc_ah;\n\tbool longcal = false;\n\tbool shortcal = false;\n\tbool aniflag = false;\n\tunsigned int timestamp = jiffies_to_msecs(jiffies);\n\tu32 cal_interval, short_cal_interval, long_cal_interval;\n\tunsigned long flags;\n\n\tif (ah->caldata && test_bit(NFCAL_INTF, &ah->caldata->cal_flags))\n\t\tlong_cal_interval = ATH_LONG_CALINTERVAL_INT;\n\telse\n\t\tlong_cal_interval = ATH_LONG_CALINTERVAL;\n\n\tshort_cal_interval = (ah->opmode == NL80211_IFTYPE_AP) ?\n\t\tATH_AP_SHORT_CALINTERVAL : ATH_STA_SHORT_CALINTERVAL;\n\n\t \n\tif (sc->sc_ah->power_mode != ATH9K_PM_AWAKE) {\n\t\tif (++ah->ani_skip_count >= ATH_ANI_MAX_SKIP_COUNT) {\n\t\t\tspin_lock_irqsave(&sc->sc_pm_lock, flags);\n\t\t\tsc->ps_flags |= PS_WAIT_FOR_ANI;\n\t\t\tspin_unlock_irqrestore(&sc->sc_pm_lock, flags);\n\t\t}\n\t\tgoto set_timer;\n\t}\n\tah->ani_skip_count = 0;\n\tspin_lock_irqsave(&sc->sc_pm_lock, flags);\n\tsc->ps_flags &= ~PS_WAIT_FOR_ANI;\n\tspin_unlock_irqrestore(&sc->sc_pm_lock, flags);\n\n\tath9k_ps_wakeup(sc);\n\n\t \n\tif ((timestamp - common->ani.longcal_timer) >= long_cal_interval) {\n\t\tlongcal = true;\n\t\tcommon->ani.longcal_timer = timestamp;\n\t}\n\n\t \n\tif (!common->ani.caldone) {\n\t\tif ((timestamp - common->ani.shortcal_timer) >= short_cal_interval) {\n\t\t\tshortcal = true;\n\t\t\tcommon->ani.shortcal_timer = timestamp;\n\t\t\tcommon->ani.resetcal_timer = timestamp;\n\t\t}\n\t} else {\n\t\tif ((timestamp - common->ani.resetcal_timer) >=\n\t\t    ATH_RESTART_CALINTERVAL) {\n\t\t\tcommon->ani.caldone = ath9k_hw_reset_calvalid(ah);\n\t\t\tif (common->ani.caldone)\n\t\t\t\tcommon->ani.resetcal_timer = timestamp;\n\t\t}\n\t}\n\n\t \n\tif ((timestamp - common->ani.checkani_timer) >= ah->config.ani_poll_interval) {\n\t\taniflag = true;\n\t\tcommon->ani.checkani_timer = timestamp;\n\t}\n\n\t \n\tif (aniflag) {\n\t\tspin_lock_irqsave(&common->cc_lock, flags);\n\t\tath9k_hw_ani_monitor(ah, ah->curchan);\n\t\tath_update_survey_stats(sc);\n\t\tspin_unlock_irqrestore(&common->cc_lock, flags);\n\t}\n\n\t \n\tif (longcal || shortcal) {\n\t\tint ret = ath9k_hw_calibrate(ah, ah->curchan, ah->rxchainmask,\n\t\t\t\t\t     longcal);\n\t\tif (ret < 0) {\n\t\t\tcommon->ani.caldone = 0;\n\t\t\tath9k_queue_reset(sc, RESET_TYPE_CALIBRATION);\n\t\t\treturn;\n\t\t}\n\n\t\tcommon->ani.caldone = ret;\n\t}\n\n\tath_dbg(common, ANI,\n\t\t\"Calibration @%lu finished: %s %s %s, caldone: %s\\n\",\n\t\tjiffies,\n\t\tlongcal ? \"long\" : \"\", shortcal ? \"short\" : \"\",\n\t\taniflag ? \"ani\" : \"\", common->ani.caldone ? \"true\" : \"false\");\n\n\tath9k_ps_restore(sc);\n\nset_timer:\n\t \n\tcal_interval = ATH_LONG_CALINTERVAL;\n\tcal_interval = min(cal_interval, (u32)ah->config.ani_poll_interval);\n\tif (!common->ani.caldone)\n\t\tcal_interval = min(cal_interval, (u32)short_cal_interval);\n\n\tmod_timer(&common->ani.timer, jiffies + msecs_to_jiffies(cal_interval));\n\n\tif (ar9003_is_paprd_enabled(ah) && ah->caldata) {\n\t\tif (!test_bit(PAPRD_DONE, &ah->caldata->cal_flags)) {\n\t\t\tieee80211_queue_work(sc->hw, &sc->paprd_work);\n\t\t} else if (!ah->paprd_table_write_done) {\n\t\t\tath9k_ps_wakeup(sc);\n\t\t\tath_paprd_activate(sc);\n\t\t\tath9k_ps_restore(sc);\n\t\t}\n\t}\n}\n\nvoid ath_start_ani(struct ath_softc *sc)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tunsigned long timestamp = jiffies_to_msecs(jiffies);\n\n\tif (common->disable_ani ||\n\t    !test_bit(ATH_OP_ANI_RUN, &common->op_flags) ||\n\t    sc->cur_chan->offchannel)\n\t\treturn;\n\n\tcommon->ani.longcal_timer = timestamp;\n\tcommon->ani.shortcal_timer = timestamp;\n\tcommon->ani.checkani_timer = timestamp;\n\n\tath_dbg(common, ANI, \"Starting ANI\\n\");\n\tmod_timer(&common->ani.timer,\n\t\t  jiffies + msecs_to_jiffies((u32)ah->config.ani_poll_interval));\n}\n\nvoid ath_stop_ani(struct ath_softc *sc)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\n\tath_dbg(common, ANI, \"Stopping ANI\\n\");\n\tdel_timer_sync(&common->ani.timer);\n}\n\nvoid ath_check_ani(struct ath_softc *sc)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ath_beacon_config *cur_conf = &sc->cur_chan->beacon;\n\n\t \n\tif (ah->opmode == NL80211_IFTYPE_ADHOC) {\n\t\tif (!cur_conf->enable_beacon)\n\t\t\tgoto stop_ani;\n\t} else if (ah->opmode == NL80211_IFTYPE_AP) {\n\t\tif (!cur_conf->enable_beacon) {\n\t\t\t \n\t\t\tif (!test_bit(ATH_OP_PRIM_STA_VIF, &common->op_flags))\n\t\t\t\tgoto stop_ani;\n\t\t}\n\t} else if (ah->opmode == NL80211_IFTYPE_STATION) {\n\t\tif (!test_bit(ATH_OP_PRIM_STA_VIF, &common->op_flags))\n\t\t\tgoto stop_ani;\n\t}\n\n\tif (!test_bit(ATH_OP_ANI_RUN, &common->op_flags)) {\n\t\tset_bit(ATH_OP_ANI_RUN, &common->op_flags);\n\t\tath_start_ani(sc);\n\t}\n\n\treturn;\n\nstop_ani:\n\tclear_bit(ATH_OP_ANI_RUN, &common->op_flags);\n\tath_stop_ani(sc);\n}\n\nvoid ath_update_survey_nf(struct ath_softc *sc, int channel)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath9k_channel *chan = &ah->channels[channel];\n\tstruct survey_info *survey = &sc->survey[channel];\n\n\tif (chan->noisefloor) {\n\t\tsurvey->filled |= SURVEY_INFO_NOISE_DBM;\n\t\tsurvey->noise = ath9k_hw_getchan_noise(ah, chan,\n\t\t\t\t\t\t       chan->noisefloor);\n\t}\n}\n\n \nint ath_update_survey_stats(struct ath_softc *sc)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tint pos = ah->curchan - &ah->channels[0];\n\tstruct survey_info *survey = &sc->survey[pos];\n\tstruct ath_cycle_counters *cc = &common->cc_survey;\n\tunsigned int div = common->clockrate * 1000;\n\tint ret = 0;\n\n\tif (!ah->curchan)\n\t\treturn -1;\n\n\tif (ah->power_mode == ATH9K_PM_AWAKE)\n\t\tath_hw_cycle_counters_update(common);\n\n\tif (cc->cycles > 0) {\n\t\tsurvey->filled |= SURVEY_INFO_TIME |\n\t\t\tSURVEY_INFO_TIME_BUSY |\n\t\t\tSURVEY_INFO_TIME_RX |\n\t\t\tSURVEY_INFO_TIME_TX;\n\t\tsurvey->time += cc->cycles / div;\n\t\tsurvey->time_busy += cc->rx_busy / div;\n\t\tsurvey->time_rx += cc->rx_frame / div;\n\t\tsurvey->time_tx += cc->tx_frame / div;\n\t}\n\n\tif (cc->cycles < div)\n\t\treturn -1;\n\n\tif (cc->cycles > 0)\n\t\tret = cc->rx_busy * 100 / cc->cycles;\n\n\tmemset(cc, 0, sizeof(*cc));\n\n\tath_update_survey_nf(sc, pos);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}