{
  "module_name": "ar9002_calib.c",
  "hash_id": "4feffaed73e4001dbc850a0cdf7250d9968db594e92160576990885837a6fae1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath9k/ar9002_calib.c",
  "human_readable_source": " \n\n#include \"hw.h\"\n#include \"hw-ops.h\"\n#include \"ar9002_phy.h\"\n\n#define AR9285_CLCAL_REDO_THRESH    1\n \n#define AR9002_CAL_MAX_TIME\t\t30000\n\nenum ar9002_cal_types {\n\tADC_GAIN_CAL = BIT(0),\n\tADC_DC_CAL = BIT(1),\n\tIQ_MISMATCH_CAL = BIT(2),\n};\n\nstatic bool ar9002_hw_is_cal_supported(struct ath_hw *ah,\n\t\t\t\tstruct ath9k_channel *chan,\n\t\t\t\tenum ar9002_cal_types cal_type)\n{\n\tbool supported = false;\n\tswitch (ah->supp_cals & cal_type) {\n\tcase IQ_MISMATCH_CAL:\n\t\tsupported = true;\n\t\tbreak;\n\tcase ADC_GAIN_CAL:\n\tcase ADC_DC_CAL:\n\t\t \n\t\tif (IS_CHAN_HT40(chan))\n\t\t\tsupported = true;\n\t\tbreak;\n\t}\n\treturn supported;\n}\n\nstatic void ar9002_hw_setup_calibration(struct ath_hw *ah,\n\t\t\t\t\tstruct ath9k_cal_list *currCal)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\n\tREG_RMW_FIELD(ah, AR_PHY_TIMING_CTRL4(0),\n\t\t      AR_PHY_TIMING_CTRL4_IQCAL_LOG_COUNT_MAX,\n\t\t      currCal->calData->calCountMax);\n\n\tswitch (currCal->calData->calType) {\n\tcase IQ_MISMATCH_CAL:\n\t\tREG_WRITE(ah, AR_PHY_CALMODE, AR_PHY_CALMODE_IQ);\n\t\tath_dbg(common, CALIBRATE,\n\t\t\t\"starting IQ Mismatch Calibration\\n\");\n\t\tbreak;\n\tcase ADC_GAIN_CAL:\n\t\tREG_WRITE(ah, AR_PHY_CALMODE, AR_PHY_CALMODE_ADC_GAIN);\n\t\tath_dbg(common, CALIBRATE, \"starting ADC Gain Calibration\\n\");\n\t\tbreak;\n\tcase ADC_DC_CAL:\n\t\tREG_WRITE(ah, AR_PHY_CALMODE, AR_PHY_CALMODE_ADC_DC_PER);\n\t\tath_dbg(common, CALIBRATE, \"starting ADC DC Calibration\\n\");\n\t\tbreak;\n\t}\n\n\tREG_SET_BIT(ah, AR_PHY_TIMING_CTRL4(0),\n\t\t    AR_PHY_TIMING_CTRL4_DO_CAL);\n}\n\nstatic bool ar9002_hw_per_calibration(struct ath_hw *ah,\n\t\t\t\t      struct ath9k_channel *ichan,\n\t\t\t\t      u8 rxchainmask,\n\t\t\t\t      struct ath9k_cal_list *currCal)\n{\n\tstruct ath9k_hw_cal_data *caldata = ah->caldata;\n\tbool iscaldone = false;\n\n\tif (currCal->calState == CAL_RUNNING) {\n\t\tif (!(REG_READ(ah, AR_PHY_TIMING_CTRL4(0)) &\n\t\t      AR_PHY_TIMING_CTRL4_DO_CAL)) {\n\n\t\t\tcurrCal->calData->calCollect(ah);\n\t\t\tah->cal_samples++;\n\n\t\t\tif (ah->cal_samples >=\n\t\t\t    currCal->calData->calNumSamples) {\n\t\t\t\tint i, numChains = 0;\n\t\t\t\tfor (i = 0; i < AR5416_MAX_CHAINS; i++) {\n\t\t\t\t\tif (rxchainmask & (1 << i))\n\t\t\t\t\t\tnumChains++;\n\t\t\t\t}\n\n\t\t\t\tcurrCal->calData->calPostProc(ah, numChains);\n\t\t\t\tcaldata->CalValid |= currCal->calData->calType;\n\t\t\t\tcurrCal->calState = CAL_DONE;\n\t\t\t\tiscaldone = true;\n\t\t\t} else {\n\t\t\t\tar9002_hw_setup_calibration(ah, currCal);\n\t\t\t}\n\t\t} else if (time_after(jiffies, ah->cal_start_time +\n\t\t\t\t      msecs_to_jiffies(AR9002_CAL_MAX_TIME))) {\n\t\t\tREG_CLR_BIT(ah, AR_PHY_TIMING_CTRL4(0),\n\t\t\t\t    AR_PHY_TIMING_CTRL4_DO_CAL);\n\t\t\tath_dbg(ath9k_hw_common(ah), CALIBRATE,\n\t\t\t\t\"calibration timeout\\n\");\n\t\t\tcurrCal->calState = CAL_WAITING;\t \n\t\t\tiscaldone = true;\n\t\t}\n\t} else if (!(caldata->CalValid & currCal->calData->calType)) {\n\t\tath9k_hw_reset_calibration(ah, currCal);\n\t}\n\n\treturn iscaldone;\n}\n\nstatic void ar9002_hw_iqcal_collect(struct ath_hw *ah)\n{\n\tint i;\n\n\tfor (i = 0; i < AR5416_MAX_CHAINS; i++) {\n\t\tah->totalPowerMeasI[i] +=\n\t\t\tREG_READ(ah, AR_PHY_CAL_MEAS_0(i));\n\t\tah->totalPowerMeasQ[i] +=\n\t\t\tREG_READ(ah, AR_PHY_CAL_MEAS_1(i));\n\t\tah->totalIqCorrMeas[i] +=\n\t\t\t(int32_t) REG_READ(ah, AR_PHY_CAL_MEAS_2(i));\n\t\tath_dbg(ath9k_hw_common(ah), CALIBRATE,\n\t\t\t\"%d: Chn %d pmi=0x%08x;pmq=0x%08x;iqcm=0x%08x;\\n\",\n\t\t\tah->cal_samples, i, ah->totalPowerMeasI[i],\n\t\t\tah->totalPowerMeasQ[i],\n\t\t\tah->totalIqCorrMeas[i]);\n\t}\n}\n\nstatic void ar9002_hw_adc_gaincal_collect(struct ath_hw *ah)\n{\n\tint i;\n\n\tfor (i = 0; i < AR5416_MAX_CHAINS; i++) {\n\t\tah->totalAdcIOddPhase[i] +=\n\t\t\tREG_READ(ah, AR_PHY_CAL_MEAS_0(i));\n\t\tah->totalAdcIEvenPhase[i] +=\n\t\t\tREG_READ(ah, AR_PHY_CAL_MEAS_1(i));\n\t\tah->totalAdcQOddPhase[i] +=\n\t\t\tREG_READ(ah, AR_PHY_CAL_MEAS_2(i));\n\t\tah->totalAdcQEvenPhase[i] +=\n\t\t\tREG_READ(ah, AR_PHY_CAL_MEAS_3(i));\n\n\t\tath_dbg(ath9k_hw_common(ah), CALIBRATE,\n\t\t\t\"%d: Chn %d oddi=0x%08x; eveni=0x%08x; oddq=0x%08x; evenq=0x%08x;\\n\",\n\t\t\tah->cal_samples, i,\n\t\t\tah->totalAdcIOddPhase[i],\n\t\t\tah->totalAdcIEvenPhase[i],\n\t\t\tah->totalAdcQOddPhase[i],\n\t\t\tah->totalAdcQEvenPhase[i]);\n\t}\n}\n\nstatic void ar9002_hw_adc_dccal_collect(struct ath_hw *ah)\n{\n\tint i;\n\n\tfor (i = 0; i < AR5416_MAX_CHAINS; i++) {\n\t\tah->totalAdcDcOffsetIOddPhase[i] +=\n\t\t\t(int32_t) REG_READ(ah, AR_PHY_CAL_MEAS_0(i));\n\t\tah->totalAdcDcOffsetIEvenPhase[i] +=\n\t\t\t(int32_t) REG_READ(ah, AR_PHY_CAL_MEAS_1(i));\n\t\tah->totalAdcDcOffsetQOddPhase[i] +=\n\t\t\t(int32_t) REG_READ(ah, AR_PHY_CAL_MEAS_2(i));\n\t\tah->totalAdcDcOffsetQEvenPhase[i] +=\n\t\t\t(int32_t) REG_READ(ah, AR_PHY_CAL_MEAS_3(i));\n\n\t\tath_dbg(ath9k_hw_common(ah), CALIBRATE,\n\t\t\t\"%d: Chn %d oddi=0x%08x; eveni=0x%08x; oddq=0x%08x; evenq=0x%08x;\\n\",\n\t\t\tah->cal_samples, i,\n\t\t\tah->totalAdcDcOffsetIOddPhase[i],\n\t\t\tah->totalAdcDcOffsetIEvenPhase[i],\n\t\t\tah->totalAdcDcOffsetQOddPhase[i],\n\t\t\tah->totalAdcDcOffsetQEvenPhase[i]);\n\t}\n}\n\nstatic void ar9002_hw_iqcalibrate(struct ath_hw *ah, u8 numChains)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tu32 powerMeasQ, powerMeasI, iqCorrMeas;\n\tu32 qCoffDenom, iCoffDenom;\n\tint32_t qCoff, iCoff;\n\tint iqCorrNeg, i;\n\n\tfor (i = 0; i < numChains; i++) {\n\t\tpowerMeasI = ah->totalPowerMeasI[i];\n\t\tpowerMeasQ = ah->totalPowerMeasQ[i];\n\t\tiqCorrMeas = ah->totalIqCorrMeas[i];\n\n\t\tath_dbg(common, CALIBRATE,\n\t\t\t\"Starting IQ Cal and Correction for Chain %d\\n\",\n\t\t\ti);\n\n\t\tath_dbg(common, CALIBRATE,\n\t\t\t\"Original: Chn %d iq_corr_meas = 0x%08x\\n\",\n\t\t\ti, ah->totalIqCorrMeas[i]);\n\n\t\tiqCorrNeg = 0;\n\n\t\tif (iqCorrMeas > 0x80000000) {\n\t\t\tiqCorrMeas = (0xffffffff - iqCorrMeas) + 1;\n\t\t\tiqCorrNeg = 1;\n\t\t}\n\n\t\tath_dbg(common, CALIBRATE, \"Chn %d pwr_meas_i = 0x%08x\\n\",\n\t\t\ti, powerMeasI);\n\t\tath_dbg(common, CALIBRATE, \"Chn %d pwr_meas_q = 0x%08x\\n\",\n\t\t\ti, powerMeasQ);\n\t\tath_dbg(common, CALIBRATE, \"iqCorrNeg is 0x%08x\\n\", iqCorrNeg);\n\n\t\tiCoffDenom = (powerMeasI / 2 + powerMeasQ / 2) / 128;\n\t\tqCoffDenom = powerMeasQ / 64;\n\n\t\tif ((powerMeasQ != 0) && (iCoffDenom != 0) &&\n\t\t    (qCoffDenom != 0)) {\n\t\t\tiCoff = iqCorrMeas / iCoffDenom;\n\t\t\tqCoff = powerMeasI / qCoffDenom - 64;\n\t\t\tath_dbg(common, CALIBRATE, \"Chn %d iCoff = 0x%08x\\n\",\n\t\t\t\ti, iCoff);\n\t\t\tath_dbg(common, CALIBRATE, \"Chn %d qCoff = 0x%08x\\n\",\n\t\t\t\ti, qCoff);\n\n\t\t\tiCoff = iCoff & 0x3f;\n\t\t\tath_dbg(common, CALIBRATE,\n\t\t\t\t\"New: Chn %d iCoff = 0x%08x\\n\", i, iCoff);\n\t\t\tif (iqCorrNeg == 0x0)\n\t\t\t\tiCoff = 0x40 - iCoff;\n\n\t\t\tif (qCoff > 15)\n\t\t\t\tqCoff = 15;\n\t\t\telse if (qCoff <= -16)\n\t\t\t\tqCoff = -16;\n\n\t\t\tath_dbg(common, CALIBRATE,\n\t\t\t\t\"Chn %d : iCoff = 0x%x  qCoff = 0x%x\\n\",\n\t\t\t\ti, iCoff, qCoff);\n\n\t\t\tREG_RMW_FIELD(ah, AR_PHY_TIMING_CTRL4(i),\n\t\t\t\t      AR_PHY_TIMING_CTRL4_IQCORR_Q_I_COFF,\n\t\t\t\t      iCoff);\n\t\t\tREG_RMW_FIELD(ah, AR_PHY_TIMING_CTRL4(i),\n\t\t\t\t      AR_PHY_TIMING_CTRL4_IQCORR_Q_Q_COFF,\n\t\t\t\t      qCoff);\n\t\t\tath_dbg(common, CALIBRATE,\n\t\t\t\t\"IQ Cal and Correction done for Chain %d\\n\",\n\t\t\t\ti);\n\t\t}\n\t}\n\n\tREG_SET_BIT(ah, AR_PHY_TIMING_CTRL4(0),\n\t\t    AR_PHY_TIMING_CTRL4_IQCORR_ENABLE);\n}\n\nstatic void ar9002_hw_adc_gaincal_calibrate(struct ath_hw *ah, u8 numChains)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tu32 iOddMeasOffset, iEvenMeasOffset, qOddMeasOffset, qEvenMeasOffset;\n\tu32 qGainMismatch, iGainMismatch, val, i;\n\n\tfor (i = 0; i < numChains; i++) {\n\t\tiOddMeasOffset = ah->totalAdcIOddPhase[i];\n\t\tiEvenMeasOffset = ah->totalAdcIEvenPhase[i];\n\t\tqOddMeasOffset = ah->totalAdcQOddPhase[i];\n\t\tqEvenMeasOffset = ah->totalAdcQEvenPhase[i];\n\n\t\tath_dbg(common, CALIBRATE,\n\t\t\t\"Starting ADC Gain Cal for Chain %d\\n\", i);\n\n\t\tath_dbg(common, CALIBRATE, \"Chn %d pwr_meas_odd_i = 0x%08x\\n\",\n\t\t\ti, iOddMeasOffset);\n\t\tath_dbg(common, CALIBRATE, \"Chn %d pwr_meas_even_i = 0x%08x\\n\",\n\t\t\ti, iEvenMeasOffset);\n\t\tath_dbg(common, CALIBRATE, \"Chn %d pwr_meas_odd_q = 0x%08x\\n\",\n\t\t\ti, qOddMeasOffset);\n\t\tath_dbg(common, CALIBRATE, \"Chn %d pwr_meas_even_q = 0x%08x\\n\",\n\t\t\ti, qEvenMeasOffset);\n\n\t\tif (iOddMeasOffset != 0 && qEvenMeasOffset != 0) {\n\t\t\tiGainMismatch =\n\t\t\t\t((iEvenMeasOffset * 32) /\n\t\t\t\t iOddMeasOffset) & 0x3f;\n\t\t\tqGainMismatch =\n\t\t\t\t((qOddMeasOffset * 32) /\n\t\t\t\t qEvenMeasOffset) & 0x3f;\n\n\t\t\tath_dbg(common, CALIBRATE,\n\t\t\t\t\"Chn %d gain_mismatch_i = 0x%08x\\n\",\n\t\t\t\ti, iGainMismatch);\n\t\t\tath_dbg(common, CALIBRATE,\n\t\t\t\t\"Chn %d gain_mismatch_q = 0x%08x\\n\",\n\t\t\t\ti, qGainMismatch);\n\n\t\t\tval = REG_READ(ah, AR_PHY_NEW_ADC_DC_GAIN_CORR(i));\n\t\t\tval &= 0xfffff000;\n\t\t\tval |= (qGainMismatch) | (iGainMismatch << 6);\n\t\t\tREG_WRITE(ah, AR_PHY_NEW_ADC_DC_GAIN_CORR(i), val);\n\n\t\t\tath_dbg(common, CALIBRATE,\n\t\t\t\t\"ADC Gain Cal done for Chain %d\\n\", i);\n\t\t}\n\t}\n\n\tREG_WRITE(ah, AR_PHY_NEW_ADC_DC_GAIN_CORR(0),\n\t\t  REG_READ(ah, AR_PHY_NEW_ADC_DC_GAIN_CORR(0)) |\n\t\t  AR_PHY_NEW_ADC_GAIN_CORR_ENABLE);\n}\n\nstatic void ar9002_hw_adc_dccal_calibrate(struct ath_hw *ah, u8 numChains)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tu32 iOddMeasOffset, iEvenMeasOffset, val, i;\n\tint32_t qOddMeasOffset, qEvenMeasOffset, qDcMismatch, iDcMismatch;\n\tconst struct ath9k_percal_data *calData =\n\t\tah->cal_list_curr->calData;\n\tu32 numSamples =\n\t\t(1 << (calData->calCountMax + 5)) * calData->calNumSamples;\n\n\tfor (i = 0; i < numChains; i++) {\n\t\tiOddMeasOffset = ah->totalAdcDcOffsetIOddPhase[i];\n\t\tiEvenMeasOffset = ah->totalAdcDcOffsetIEvenPhase[i];\n\t\tqOddMeasOffset = ah->totalAdcDcOffsetQOddPhase[i];\n\t\tqEvenMeasOffset = ah->totalAdcDcOffsetQEvenPhase[i];\n\n\t\tath_dbg(common, CALIBRATE,\n\t\t\t\"Starting ADC DC Offset Cal for Chain %d\\n\", i);\n\n\t\tath_dbg(common, CALIBRATE, \"Chn %d pwr_meas_odd_i = %d\\n\",\n\t\t\ti, iOddMeasOffset);\n\t\tath_dbg(common, CALIBRATE, \"Chn %d pwr_meas_even_i = %d\\n\",\n\t\t\ti, iEvenMeasOffset);\n\t\tath_dbg(common, CALIBRATE, \"Chn %d pwr_meas_odd_q = %d\\n\",\n\t\t\ti, qOddMeasOffset);\n\t\tath_dbg(common, CALIBRATE, \"Chn %d pwr_meas_even_q = %d\\n\",\n\t\t\ti, qEvenMeasOffset);\n\n\t\tiDcMismatch = (((iEvenMeasOffset - iOddMeasOffset) * 2) /\n\t\t\t       numSamples) & 0x1ff;\n\t\tqDcMismatch = (((qOddMeasOffset - qEvenMeasOffset) * 2) /\n\t\t\t       numSamples) & 0x1ff;\n\n\t\tath_dbg(common, CALIBRATE,\n\t\t\t\"Chn %d dc_offset_mismatch_i = 0x%08x\\n\",\n\t\t\ti, iDcMismatch);\n\t\tath_dbg(common, CALIBRATE,\n\t\t\t\"Chn %d dc_offset_mismatch_q = 0x%08x\\n\",\n\t\t\ti, qDcMismatch);\n\n\t\tval = REG_READ(ah, AR_PHY_NEW_ADC_DC_GAIN_CORR(i));\n\t\tval &= 0xc0000fff;\n\t\tval |= (qDcMismatch << 12) | (iDcMismatch << 21);\n\t\tREG_WRITE(ah, AR_PHY_NEW_ADC_DC_GAIN_CORR(i), val);\n\n\t\tath_dbg(common, CALIBRATE,\n\t\t\t\"ADC DC Offset Cal done for Chain %d\\n\", i);\n\t}\n\n\tREG_WRITE(ah, AR_PHY_NEW_ADC_DC_GAIN_CORR(0),\n\t\t  REG_READ(ah, AR_PHY_NEW_ADC_DC_GAIN_CORR(0)) |\n\t\t  AR_PHY_NEW_ADC_DC_OFFSET_CORR_ENABLE);\n}\n\nstatic void ar9287_hw_olc_temp_compensation(struct ath_hw *ah)\n{\n\tu32 rddata;\n\tint32_t delta, currPDADC, slope;\n\n\trddata = REG_READ(ah, AR_PHY_TX_PWRCTRL4);\n\tcurrPDADC = MS(rddata, AR_PHY_TX_PWRCTRL_PD_AVG_OUT);\n\n\tif (ah->initPDADC == 0 || currPDADC == 0) {\n\t\t \n\t\treturn;\n\t} else {\n\t\tslope = ah->eep_ops->get_eeprom(ah, EEP_TEMPSENSE_SLOPE);\n\n\t\tif (slope == 0) {  \n\t\t\tdelta = 0;\n\t\t} else {\n\t\t\tdelta = ((currPDADC - ah->initPDADC)*4) / slope;\n\t\t}\n\t\tREG_RMW_FIELD(ah, AR_PHY_CH0_TX_PWRCTRL11,\n\t\t\t      AR_PHY_TX_PWRCTRL_OLPC_TEMP_COMP, delta);\n\t\tREG_RMW_FIELD(ah, AR_PHY_CH1_TX_PWRCTRL11,\n\t\t\t      AR_PHY_TX_PWRCTRL_OLPC_TEMP_COMP, delta);\n\t}\n}\n\nstatic void ar9280_hw_olc_temp_compensation(struct ath_hw *ah)\n{\n\tu32 rddata, i;\n\tint delta, currPDADC, regval;\n\n\trddata = REG_READ(ah, AR_PHY_TX_PWRCTRL4);\n\tcurrPDADC = MS(rddata, AR_PHY_TX_PWRCTRL_PD_AVG_OUT);\n\n\tif (ah->initPDADC == 0 || currPDADC == 0)\n\t\treturn;\n\n\tif (ah->eep_ops->get_eeprom(ah, EEP_DAC_HPWR_5G))\n\t\tdelta = (currPDADC - ah->initPDADC + 4) / 8;\n\telse\n\t\tdelta = (currPDADC - ah->initPDADC + 5) / 10;\n\n\tif (delta != ah->PDADCdelta) {\n\t\tah->PDADCdelta = delta;\n\t\tfor (i = 1; i < AR9280_TX_GAIN_TABLE_SIZE; i++) {\n\t\t\tregval = ah->originalGain[i] - delta;\n\t\t\tif (regval < 0)\n\t\t\t\tregval = 0;\n\n\t\t\tREG_RMW_FIELD(ah,\n\t\t\t\t      AR_PHY_TX_GAIN_TBL1 + i * 4,\n\t\t\t\t      AR_PHY_TX_GAIN, regval);\n\t\t}\n\t}\n}\n\nstatic void ar9271_hw_pa_cal(struct ath_hw *ah, bool is_reset)\n{\n\tu32 regVal;\n\tunsigned int i;\n\tu32 regList[][2] = {\n\t\t{ AR9285_AN_TOP3, 0 },\n\t\t{ AR9285_AN_RXTXBB1, 0 },\n\t\t{ AR9285_AN_RF2G1, 0 },\n\t\t{ AR9285_AN_RF2G2, 0 },\n\t\t{ AR9285_AN_TOP2, 0 },\n\t\t{ AR9285_AN_RF2G8, 0 },\n\t\t{ AR9285_AN_RF2G7, 0 },\n\t\t{ AR9285_AN_RF2G3, 0 },\n\t};\n\n\tREG_READ_ARRAY(ah, regList, ARRAY_SIZE(regList));\n\n\tENABLE_REG_RMW_BUFFER(ah);\n\t \n\tREG_CLR_BIT(ah, AR9285_AN_RF2G6, 1 << 0);\n\t \n\tREG_SET_BIT(ah, 0x9808, 1 << 27);\n\t \n\tREG_SET_BIT(ah, AR9285_AN_TOP3, AR9285_AN_TOP3_PWDDAC);\n\t \n\tREG_SET_BIT(ah, AR9285_AN_RXTXBB1, AR9285_AN_RXTXBB1_PDRXTXBB1);\n\t \n\tREG_SET_BIT(ah, AR9285_AN_RXTXBB1, AR9285_AN_RXTXBB1_PDV2I);\n\t \n\tREG_SET_BIT(ah, AR9285_AN_RXTXBB1, AR9285_AN_RXTXBB1_PDDACIF);\n\t \n\tREG_CLR_BIT(ah, AR9285_AN_RF2G2, AR9285_AN_RF2G2_OFFCAL);\n\t \n\tREG_CLR_BIT(ah, AR9285_AN_RF2G7, AR9285_AN_RF2G7_PWDDB);\n\t \n\tREG_CLR_BIT(ah, AR9285_AN_RF2G1, AR9285_AN_RF2G1_ENPACAL);\n\t \n\tREG_CLR_BIT(ah, AR9285_AN_RF2G1, AR9285_AN_RF2G1_PDPADRV1);\n\t \n\tREG_CLR_BIT(ah, AR9285_AN_RF2G1, AR9285_AN_RF2G1_PDPADRV2);\n\t \n\tREG_CLR_BIT(ah, AR9285_AN_RF2G1, AR9285_AN_RF2G1_PDPAOUT);\n\t \n\tREG_RMW_FIELD(ah, AR9285_AN_RF2G8, AR9285_AN_RF2G8_PADRVGN2TAB0, 7);\n\t \n\tREG_RMW_FIELD(ah, AR9285_AN_RF2G7, AR9285_AN_RF2G7_PADRVGN2TAB0, 0);\n\t \n\tREG_RMW_FIELD(ah, AR9285_AN_RF2G3, AR9271_AN_RF2G3_CCOMP, 0xfff);\n\tREG_RMW_BUFFER_FLUSH(ah);\n\n\t \n\tREG_WRITE(ah, AR9285_AN_TOP2, 0xca0358a0);\n\tudelay(30);\n\tREG_RMW_FIELD(ah, AR9285_AN_RF2G6, AR9271_AN_RF2G6_OFFS, 0);\n\n\t \n\tfor (i = 6; i > 0; i--) {\n\t\tregVal = REG_READ(ah, AR9285_AN_RF2G6);\n\t\tregVal |= (1 << (20 + i));\n\t\tREG_WRITE(ah, AR9285_AN_RF2G6, regVal);\n\t\tudelay(1);\n\t\t \n\t\tregVal &= (~(0x1 << (20 + i)));\n\t\tregVal |= (MS(REG_READ(ah, AR9285_AN_RF2G9),\n\t\t\t      AR9285_AN_RXTXBB1_SPARE9)\n\t\t\t    << (20 + i));\n\t\tREG_WRITE(ah, AR9285_AN_RF2G6, regVal);\n\t}\n\n\tregVal = (regVal >> 20) & 0x7f;\n\n\t \n\tif ((!is_reset) && (ah->pacal_info.prev_offset == regVal)) {\n\t\tif (ah->pacal_info.max_skipcount < MAX_PACAL_SKIPCOUNT)\n\t\t\tah->pacal_info.max_skipcount =\n\t\t\t\t2 * ah->pacal_info.max_skipcount;\n\t\tah->pacal_info.skipcount = ah->pacal_info.max_skipcount;\n\t} else {\n\t\tah->pacal_info.max_skipcount = 1;\n\t\tah->pacal_info.skipcount = 0;\n\t\tah->pacal_info.prev_offset = regVal;\n\t}\n\n\n\tENABLE_REG_RMW_BUFFER(ah);\n\t \n\tREG_SET_BIT(ah, AR9285_AN_RF2G6, 1 << 0);\n\t \n\tREG_CLR_BIT(ah, 0x9808, 1 << 27);\n\tREG_RMW_BUFFER_FLUSH(ah);\n\n\tENABLE_REGWRITE_BUFFER(ah);\n\tfor (i = 0; i < ARRAY_SIZE(regList); i++)\n\t\tREG_WRITE(ah, regList[i][0], regList[i][1]);\n\n\tREGWRITE_BUFFER_FLUSH(ah);\n}\n\nstatic inline void ar9285_hw_pa_cal(struct ath_hw *ah, bool is_reset)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tu32 regVal;\n\tint i, offset, offs_6_1, offs_0;\n\tu32 ccomp_org, reg_field;\n\tu32 regList[][2] = {\n\t\t{ 0x786c, 0 },\n\t\t{ 0x7854, 0 },\n\t\t{ 0x7820, 0 },\n\t\t{ 0x7824, 0 },\n\t\t{ 0x7868, 0 },\n\t\t{ 0x783c, 0 },\n\t\t{ 0x7838, 0 },\n\t};\n\n\tath_dbg(common, CALIBRATE, \"Running PA Calibration\\n\");\n\n\t \n\tif (ah->eep_ops->get_eeprom(ah, EEP_TXGAIN_TYPE) ==\n\t    AR5416_EEP_TXGAIN_HIGH_POWER)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(regList); i++)\n\t\tregList[i][1] = REG_READ(ah, regList[i][0]);\n\n\tregVal = REG_READ(ah, 0x7834);\n\tregVal &= (~(0x1));\n\tREG_WRITE(ah, 0x7834, regVal);\n\tregVal = REG_READ(ah, 0x9808);\n\tregVal |= (0x1 << 27);\n\tREG_WRITE(ah, 0x9808, regVal);\n\n\tREG_RMW_FIELD(ah, AR9285_AN_TOP3, AR9285_AN_TOP3_PWDDAC, 1);\n\tREG_RMW_FIELD(ah, AR9285_AN_RXTXBB1, AR9285_AN_RXTXBB1_PDRXTXBB1, 1);\n\tREG_RMW_FIELD(ah, AR9285_AN_RXTXBB1, AR9285_AN_RXTXBB1_PDV2I, 1);\n\tREG_RMW_FIELD(ah, AR9285_AN_RXTXBB1, AR9285_AN_RXTXBB1_PDDACIF, 1);\n\tREG_RMW_FIELD(ah, AR9285_AN_RF2G2, AR9285_AN_RF2G2_OFFCAL, 0);\n\tREG_RMW_FIELD(ah, AR9285_AN_RF2G7, AR9285_AN_RF2G7_PWDDB, 0);\n\tREG_RMW_FIELD(ah, AR9285_AN_RF2G1, AR9285_AN_RF2G1_ENPACAL, 0);\n\tREG_RMW_FIELD(ah, AR9285_AN_RF2G1, AR9285_AN_RF2G1_PDPADRV1, 0);\n\tREG_RMW_FIELD(ah, AR9285_AN_RF2G1, AR9285_AN_RF2G1_PDPADRV2, 0);\n\tREG_RMW_FIELD(ah, AR9285_AN_RF2G1, AR9285_AN_RF2G1_PDPAOUT, 0);\n\tREG_RMW_FIELD(ah, AR9285_AN_RF2G8, AR9285_AN_RF2G8_PADRVGN2TAB0, 7);\n\tREG_RMW_FIELD(ah, AR9285_AN_RF2G7, AR9285_AN_RF2G7_PADRVGN2TAB0, 0);\n\tccomp_org = MS(REG_READ(ah, AR9285_AN_RF2G6), AR9285_AN_RF2G6_CCOMP);\n\tREG_RMW_FIELD(ah, AR9285_AN_RF2G6, AR9285_AN_RF2G6_CCOMP, 0xf);\n\n\tREG_WRITE(ah, AR9285_AN_TOP2, 0xca0358a0);\n\tudelay(30);\n\tREG_RMW_FIELD(ah, AR9285_AN_RF2G6, AR9285_AN_RF2G6_OFFS, 0);\n\tREG_RMW_FIELD(ah, AR9285_AN_RF2G3, AR9285_AN_RF2G3_PDVCCOMP, 0);\n\n\tfor (i = 6; i > 0; i--) {\n\t\tregVal = REG_READ(ah, 0x7834);\n\t\tregVal |= (1 << (19 + i));\n\t\tREG_WRITE(ah, 0x7834, regVal);\n\t\tudelay(1);\n\t\tregVal = REG_READ(ah, 0x7834);\n\t\tregVal &= (~(0x1 << (19 + i)));\n\t\treg_field = MS(REG_READ(ah, 0x7840), AR9285_AN_RXTXBB1_SPARE9);\n\t\tregVal |= (reg_field << (19 + i));\n\t\tREG_WRITE(ah, 0x7834, regVal);\n\t}\n\n\tREG_RMW_FIELD(ah, AR9285_AN_RF2G3, AR9285_AN_RF2G3_PDVCCOMP, 1);\n\tudelay(1);\n\treg_field = MS(REG_READ(ah, AR9285_AN_RF2G9), AR9285_AN_RXTXBB1_SPARE9);\n\tREG_RMW_FIELD(ah, AR9285_AN_RF2G3, AR9285_AN_RF2G3_PDVCCOMP, reg_field);\n\toffs_6_1 = MS(REG_READ(ah, AR9285_AN_RF2G6), AR9285_AN_RF2G6_OFFS);\n\toffs_0   = MS(REG_READ(ah, AR9285_AN_RF2G3), AR9285_AN_RF2G3_PDVCCOMP);\n\n\toffset = (offs_6_1<<1) | offs_0;\n\toffset = offset - 0;\n\toffs_6_1 = offset>>1;\n\toffs_0 = offset & 1;\n\n\tif ((!is_reset) && (ah->pacal_info.prev_offset == offset)) {\n\t\tif (ah->pacal_info.max_skipcount < MAX_PACAL_SKIPCOUNT)\n\t\t\tah->pacal_info.max_skipcount =\n\t\t\t\t2 * ah->pacal_info.max_skipcount;\n\t\tah->pacal_info.skipcount = ah->pacal_info.max_skipcount;\n\t} else {\n\t\tah->pacal_info.max_skipcount = 1;\n\t\tah->pacal_info.skipcount = 0;\n\t\tah->pacal_info.prev_offset = offset;\n\t}\n\n\tREG_RMW_FIELD(ah, AR9285_AN_RF2G6, AR9285_AN_RF2G6_OFFS, offs_6_1);\n\tREG_RMW_FIELD(ah, AR9285_AN_RF2G3, AR9285_AN_RF2G3_PDVCCOMP, offs_0);\n\n\tregVal = REG_READ(ah, 0x7834);\n\tregVal |= 0x1;\n\tREG_WRITE(ah, 0x7834, regVal);\n\tregVal = REG_READ(ah, 0x9808);\n\tregVal &= (~(0x1 << 27));\n\tREG_WRITE(ah, 0x9808, regVal);\n\n\tfor (i = 0; i < ARRAY_SIZE(regList); i++)\n\t\tREG_WRITE(ah, regList[i][0], regList[i][1]);\n\n\tREG_RMW_FIELD(ah, AR9285_AN_RF2G6, AR9285_AN_RF2G6_CCOMP, ccomp_org);\n}\n\nstatic void ar9002_hw_pa_cal(struct ath_hw *ah, bool is_reset)\n{\n\tif (AR_SREV_9271(ah)) {\n\t\tif (is_reset || !ah->pacal_info.skipcount)\n\t\t\tar9271_hw_pa_cal(ah, is_reset);\n\t\telse\n\t\t\tah->pacal_info.skipcount--;\n\t} else if (AR_SREV_9285_12_OR_LATER(ah)) {\n\t\tif (is_reset || !ah->pacal_info.skipcount)\n\t\t\tar9285_hw_pa_cal(ah, is_reset);\n\t\telse\n\t\t\tah->pacal_info.skipcount--;\n\t}\n}\n\nstatic void ar9002_hw_olc_temp_compensation(struct ath_hw *ah)\n{\n\tif (OLC_FOR_AR9287_10_LATER(ah))\n\t\tar9287_hw_olc_temp_compensation(ah);\n\telse if (OLC_FOR_AR9280_20_LATER(ah))\n\t\tar9280_hw_olc_temp_compensation(ah);\n}\n\nstatic int ar9002_hw_calibrate(struct ath_hw *ah, struct ath9k_channel *chan,\n\t\t\t       u8 rxchainmask, bool longcal)\n{\n\tstruct ath9k_cal_list *currCal = ah->cal_list_curr;\n\tbool nfcal, nfcal_pending = false, percal_pending;\n\tint ret;\n\n\tnfcal = !!(REG_READ(ah, AR_PHY_AGC_CONTROL(ah)) & AR_PHY_AGC_CONTROL_NF);\n\tif (ah->caldata) {\n\t\tnfcal_pending = test_bit(NFCAL_PENDING, &ah->caldata->cal_flags);\n\t\tif (longcal)\t\t \n\t\t\tset_bit(LONGCAL_PENDING, &ah->caldata->cal_flags);\n\t\telse if (test_bit(LONGCAL_PENDING, &ah->caldata->cal_flags))\n\t\t\tlongcal = true;\t \n\t}\n\n\tpercal_pending = (currCal &&\n\t\t\t  (currCal->calState == CAL_RUNNING ||\n\t\t\t   currCal->calState == CAL_WAITING));\n\n\tif (percal_pending && !nfcal) {\n\t\tif (!ar9002_hw_per_calibration(ah, chan, rxchainmask, currCal))\n\t\t\treturn 0;\n\n\t\t \n\t\tfor (currCal = currCal->calNext; currCal != ah->cal_list_curr;\n\t\t     currCal = currCal->calNext) {\n\t\t\tif (currCal->calState == CAL_WAITING)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (currCal->calState == CAL_WAITING) {\n\t\t\tpercal_pending = true;\n\t\t\tah->cal_list_curr = currCal;\n\t\t} else {\n\t\t\tpercal_pending = false;\n\t\t\tah->cal_list_curr = ah->cal_list;\n\t\t}\n\t}\n\n\t \n\tif (percal_pending && !nfcal && !longcal) {\n\t\tath9k_hw_reset_calibration(ah, currCal);\n\n\t\treturn 0;\n\t}\n\n\t \n\tif (longcal || nfcal_pending) {\n\t\t \n\t\tif (ath9k_hw_getnf(ah, chan)) {\n\t\t\t \n\t\t\tret = ath9k_hw_loadnf(ah, ah->curchan);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tif (longcal) {\n\t\t\tif (ah->caldata)\n\t\t\t\tclear_bit(LONGCAL_PENDING,\n\t\t\t\t\t  &ah->caldata->cal_flags);\n\t\t\tath9k_hw_start_nfcal(ah, false);\n\t\t\t \n\t\t\tar9002_hw_pa_cal(ah, false);\n\t\t\tar9002_hw_olc_temp_compensation(ah);\n\t\t}\n\t}\n\n\treturn !percal_pending;\n}\n\n \nstatic bool ar9285_hw_cl_cal(struct ath_hw *ah, struct ath9k_channel *chan)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\n\tREG_SET_BIT(ah, AR_PHY_CL_CAL_CTL, AR_PHY_CL_CAL_ENABLE);\n\tif (IS_CHAN_HT20(chan)) {\n\t\tREG_SET_BIT(ah, AR_PHY_CL_CAL_CTL, AR_PHY_PARALLEL_CAL_ENABLE);\n\t\tREG_SET_BIT(ah, AR_PHY_TURBO, AR_PHY_FC_DYN2040_EN);\n\t\tREG_CLR_BIT(ah, AR_PHY_AGC_CONTROL(ah),\n\t\t\t    AR_PHY_AGC_CONTROL_FLTR_CAL);\n\t\tREG_CLR_BIT(ah, AR_PHY_TPCRG1, AR_PHY_TPCRG1_PD_CAL_ENABLE);\n\t\tREG_SET_BIT(ah, AR_PHY_AGC_CONTROL(ah), AR_PHY_AGC_CONTROL_CAL);\n\t\tif (!ath9k_hw_wait(ah, AR_PHY_AGC_CONTROL(ah),\n\t\t\t\t  AR_PHY_AGC_CONTROL_CAL, 0, AH_WAIT_TIMEOUT)) {\n\t\t\tath_dbg(common, CALIBRATE,\n\t\t\t\t\"offset calibration failed to complete in %d ms; noisy environment?\\n\",\n\t\t\t\tAH_WAIT_TIMEOUT / 1000);\n\t\t\treturn false;\n\t\t}\n\t\tREG_CLR_BIT(ah, AR_PHY_TURBO, AR_PHY_FC_DYN2040_EN);\n\t\tREG_CLR_BIT(ah, AR_PHY_CL_CAL_CTL, AR_PHY_PARALLEL_CAL_ENABLE);\n\t\tREG_CLR_BIT(ah, AR_PHY_CL_CAL_CTL, AR_PHY_CL_CAL_ENABLE);\n\t}\n\tREG_CLR_BIT(ah, AR_PHY_ADC_CTL, AR_PHY_ADC_CTL_OFF_PWDADC);\n\tREG_SET_BIT(ah, AR_PHY_AGC_CONTROL(ah), AR_PHY_AGC_CONTROL_FLTR_CAL);\n\tREG_SET_BIT(ah, AR_PHY_TPCRG1, AR_PHY_TPCRG1_PD_CAL_ENABLE);\n\tREG_SET_BIT(ah, AR_PHY_AGC_CONTROL(ah), AR_PHY_AGC_CONTROL_CAL);\n\tif (!ath9k_hw_wait(ah, AR_PHY_AGC_CONTROL(ah), AR_PHY_AGC_CONTROL_CAL,\n\t\t\t  0, AH_WAIT_TIMEOUT)) {\n\t\tath_dbg(common, CALIBRATE,\n\t\t\t\"offset calibration failed to complete in %d ms; noisy environment?\\n\",\n\t\t\tAH_WAIT_TIMEOUT / 1000);\n\t\treturn false;\n\t}\n\n\tREG_SET_BIT(ah, AR_PHY_ADC_CTL, AR_PHY_ADC_CTL_OFF_PWDADC);\n\tREG_CLR_BIT(ah, AR_PHY_CL_CAL_CTL, AR_PHY_CL_CAL_ENABLE);\n\tREG_CLR_BIT(ah, AR_PHY_AGC_CONTROL(ah), AR_PHY_AGC_CONTROL_FLTR_CAL);\n\n\treturn true;\n}\n\nstatic bool ar9285_hw_clc(struct ath_hw *ah, struct ath9k_channel *chan)\n{\n\tint i;\n\tu_int32_t txgain_max;\n\tu_int32_t clc_gain, gain_mask = 0, clc_num = 0;\n\tu_int32_t reg_clc_I0, reg_clc_Q0;\n\tu_int32_t i0_num = 0;\n\tu_int32_t q0_num = 0;\n\tu_int32_t total_num = 0;\n\tu_int32_t reg_rf2g5_org;\n\tbool retv = true;\n\n\tif (!(ar9285_hw_cl_cal(ah, chan)))\n\t\treturn false;\n\n\ttxgain_max = MS(REG_READ(ah, AR_PHY_TX_PWRCTRL7),\n\t\t\tAR_PHY_TX_PWRCTRL_TX_GAIN_TAB_MAX);\n\n\tfor (i = 0; i < (txgain_max+1); i++) {\n\t\tclc_gain = (REG_READ(ah, (AR_PHY_TX_GAIN_TBL1+(i<<2))) &\n\t\t\t   AR_PHY_TX_GAIN_CLC) >> AR_PHY_TX_GAIN_CLC_S;\n\t\tif (!(gain_mask & (1 << clc_gain))) {\n\t\t\tgain_mask |= (1 << clc_gain);\n\t\t\tclc_num++;\n\t\t}\n\t}\n\n\tfor (i = 0; i < clc_num; i++) {\n\t\treg_clc_I0 = (REG_READ(ah, (AR_PHY_CLC_TBL1 + (i << 2)))\n\t\t\t      & AR_PHY_CLC_I0) >> AR_PHY_CLC_I0_S;\n\t\treg_clc_Q0 = (REG_READ(ah, (AR_PHY_CLC_TBL1 + (i << 2)))\n\t\t\t      & AR_PHY_CLC_Q0) >> AR_PHY_CLC_Q0_S;\n\t\tif (reg_clc_I0 == 0)\n\t\t\ti0_num++;\n\n\t\tif (reg_clc_Q0 == 0)\n\t\t\tq0_num++;\n\t}\n\ttotal_num = i0_num + q0_num;\n\tif (total_num > AR9285_CLCAL_REDO_THRESH) {\n\t\treg_rf2g5_org = REG_READ(ah, AR9285_RF2G5);\n\t\tif (AR_SREV_9285E_20(ah)) {\n\t\t\tREG_WRITE(ah, AR9285_RF2G5,\n\t\t\t\t  (reg_rf2g5_org & AR9285_RF2G5_IC50TX) |\n\t\t\t\t  AR9285_RF2G5_IC50TX_XE_SET);\n\t\t} else {\n\t\t\tREG_WRITE(ah, AR9285_RF2G5,\n\t\t\t\t  (reg_rf2g5_org & AR9285_RF2G5_IC50TX) |\n\t\t\t\t  AR9285_RF2G5_IC50TX_SET);\n\t\t}\n\t\tretv = ar9285_hw_cl_cal(ah, chan);\n\t\tREG_WRITE(ah, AR9285_RF2G5, reg_rf2g5_org);\n\t}\n\treturn retv;\n}\n\nstatic bool ar9002_hw_init_cal(struct ath_hw *ah, struct ath9k_channel *chan)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\n\tif (AR_SREV_9271(ah)) {\n\t\tif (!ar9285_hw_cl_cal(ah, chan))\n\t\t\treturn false;\n\t} else if (AR_SREV_9285(ah) && AR_SREV_9285_12_OR_LATER(ah)) {\n\t\tif (!ar9285_hw_clc(ah, chan))\n\t\t\treturn false;\n\t} else {\n\t\tif (AR_SREV_9280_20_OR_LATER(ah)) {\n\t\t\tif (!AR_SREV_9287_11_OR_LATER(ah))\n\t\t\t\tREG_CLR_BIT(ah, AR_PHY_ADC_CTL,\n\t\t\t\t\t    AR_PHY_ADC_CTL_OFF_PWDADC);\n\t\t\tREG_SET_BIT(ah, AR_PHY_AGC_CONTROL(ah),\n\t\t\t\t    AR_PHY_AGC_CONTROL_FLTR_CAL);\n\t\t}\n\n\t\t \n\t\tREG_WRITE(ah, AR_PHY_AGC_CONTROL(ah),\n\t\t\t  REG_READ(ah, AR_PHY_AGC_CONTROL(ah)) |\n\t\t\t  AR_PHY_AGC_CONTROL_CAL);\n\n\t\t \n\t\tif (!ath9k_hw_wait(ah, AR_PHY_AGC_CONTROL(ah),\n\t\t\t\t   AR_PHY_AGC_CONTROL_CAL,\n\t\t\t\t   0, AH_WAIT_TIMEOUT)) {\n\t\t\tath_dbg(common, CALIBRATE,\n\t\t\t\t\"offset calibration failed to complete in %d ms; noisy environment?\\n\",\n\t\t\t\tAH_WAIT_TIMEOUT / 1000);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (AR_SREV_9280_20_OR_LATER(ah)) {\n\t\t\tif (!AR_SREV_9287_11_OR_LATER(ah))\n\t\t\t\tREG_SET_BIT(ah, AR_PHY_ADC_CTL,\n\t\t\t\t\t    AR_PHY_ADC_CTL_OFF_PWDADC);\n\t\t\tREG_CLR_BIT(ah, AR_PHY_AGC_CONTROL(ah),\n\t\t\t\t    AR_PHY_AGC_CONTROL_FLTR_CAL);\n\t\t}\n\t}\n\n\t \n\tar9002_hw_pa_cal(ah, true);\n\tath9k_hw_loadnf(ah, chan);\n\tath9k_hw_start_nfcal(ah, true);\n\n\tah->cal_list = ah->cal_list_last = ah->cal_list_curr = NULL;\n\n\t \n\tif (AR_SREV_9100(ah) || AR_SREV_9160_10_OR_LATER(ah)) {\n\t\tah->supp_cals = IQ_MISMATCH_CAL;\n\n\t\tif (AR_SREV_9160_10_OR_LATER(ah))\n\t\t\tah->supp_cals |= ADC_GAIN_CAL | ADC_DC_CAL;\n\n\t\tif (AR_SREV_9287(ah))\n\t\t\tah->supp_cals &= ~ADC_GAIN_CAL;\n\n\t\tif (ar9002_hw_is_cal_supported(ah, chan, ADC_GAIN_CAL)) {\n\t\t\tINIT_CAL(&ah->adcgain_caldata);\n\t\t\tINSERT_CAL(ah, &ah->adcgain_caldata);\n\t\t\tath_dbg(common, CALIBRATE,\n\t\t\t\t\t\"enabling ADC Gain Calibration\\n\");\n\t\t}\n\n\t\tif (ar9002_hw_is_cal_supported(ah, chan, ADC_DC_CAL)) {\n\t\t\tINIT_CAL(&ah->adcdc_caldata);\n\t\t\tINSERT_CAL(ah, &ah->adcdc_caldata);\n\t\t\tath_dbg(common, CALIBRATE,\n\t\t\t\t\t\"enabling ADC DC Calibration\\n\");\n\t\t}\n\n\t\tif (ar9002_hw_is_cal_supported(ah, chan, IQ_MISMATCH_CAL)) {\n\t\t\tINIT_CAL(&ah->iq_caldata);\n\t\t\tINSERT_CAL(ah, &ah->iq_caldata);\n\t\t\tath_dbg(common, CALIBRATE, \"enabling IQ Calibration\\n\");\n\t\t}\n\n\t\tah->cal_list_curr = ah->cal_list;\n\n\t\tif (ah->cal_list_curr)\n\t\t\tath9k_hw_reset_calibration(ah, ah->cal_list_curr);\n\t}\n\n\tif (ah->caldata)\n\t\tah->caldata->CalValid = 0;\n\n\treturn true;\n}\n\nstatic const struct ath9k_percal_data iq_cal_multi_sample = {\n\tIQ_MISMATCH_CAL,\n\tMAX_CAL_SAMPLES,\n\tPER_MIN_LOG_COUNT,\n\tar9002_hw_iqcal_collect,\n\tar9002_hw_iqcalibrate\n};\nstatic const struct ath9k_percal_data iq_cal_single_sample = {\n\tIQ_MISMATCH_CAL,\n\tMIN_CAL_SAMPLES,\n\tPER_MAX_LOG_COUNT,\n\tar9002_hw_iqcal_collect,\n\tar9002_hw_iqcalibrate\n};\nstatic const struct ath9k_percal_data adc_gain_cal_multi_sample = {\n\tADC_GAIN_CAL,\n\tMAX_CAL_SAMPLES,\n\tPER_MIN_LOG_COUNT,\n\tar9002_hw_adc_gaincal_collect,\n\tar9002_hw_adc_gaincal_calibrate\n};\nstatic const struct ath9k_percal_data adc_gain_cal_single_sample = {\n\tADC_GAIN_CAL,\n\tMIN_CAL_SAMPLES,\n\tPER_MAX_LOG_COUNT,\n\tar9002_hw_adc_gaincal_collect,\n\tar9002_hw_adc_gaincal_calibrate\n};\nstatic const struct ath9k_percal_data adc_dc_cal_multi_sample = {\n\tADC_DC_CAL,\n\tMAX_CAL_SAMPLES,\n\tPER_MIN_LOG_COUNT,\n\tar9002_hw_adc_dccal_collect,\n\tar9002_hw_adc_dccal_calibrate\n};\nstatic const struct ath9k_percal_data adc_dc_cal_single_sample = {\n\tADC_DC_CAL,\n\tMIN_CAL_SAMPLES,\n\tPER_MAX_LOG_COUNT,\n\tar9002_hw_adc_dccal_collect,\n\tar9002_hw_adc_dccal_calibrate\n};\n\nstatic void ar9002_hw_init_cal_settings(struct ath_hw *ah)\n{\n\tif (AR_SREV_9100(ah)) {\n\t\tah->iq_caldata.calData = &iq_cal_multi_sample;\n\t\tah->supp_cals = IQ_MISMATCH_CAL;\n\t\treturn;\n\t}\n\n\tif (AR_SREV_9160_10_OR_LATER(ah)) {\n\t\tif (AR_SREV_9280_20_OR_LATER(ah)) {\n\t\t\tah->iq_caldata.calData = &iq_cal_single_sample;\n\t\t\tah->adcgain_caldata.calData =\n\t\t\t\t&adc_gain_cal_single_sample;\n\t\t\tah->adcdc_caldata.calData =\n\t\t\t\t&adc_dc_cal_single_sample;\n\t\t} else {\n\t\t\tah->iq_caldata.calData = &iq_cal_multi_sample;\n\t\t\tah->adcgain_caldata.calData =\n\t\t\t\t&adc_gain_cal_multi_sample;\n\t\t\tah->adcdc_caldata.calData =\n\t\t\t\t&adc_dc_cal_multi_sample;\n\t\t}\n\t\tah->supp_cals = ADC_GAIN_CAL | ADC_DC_CAL | IQ_MISMATCH_CAL;\n\n\t\tif (AR_SREV_9287(ah))\n\t\t\tah->supp_cals &= ~ADC_GAIN_CAL;\n\t}\n}\n\nvoid ar9002_hw_attach_calib_ops(struct ath_hw *ah)\n{\n\tstruct ath_hw_private_ops *priv_ops = ath9k_hw_private_ops(ah);\n\tstruct ath_hw_ops *ops = ath9k_hw_ops(ah);\n\n\tpriv_ops->init_cal_settings = ar9002_hw_init_cal_settings;\n\tpriv_ops->init_cal = ar9002_hw_init_cal;\n\tpriv_ops->setup_calibration = ar9002_hw_setup_calibration;\n\n\tops->calibrate = ar9002_hw_calibrate;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}