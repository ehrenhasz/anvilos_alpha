{
  "module_name": "hw.c",
  "hash_id": "0296c0826ec32938299958bd1a841d83ef23fc21125c01baa3de6b0d0070ce4c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath9k/hw.c",
  "human_readable_source": " \n\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/time.h>\n#include <linux/bitops.h>\n#include <linux/etherdevice.h>\n#include <linux/gpio.h>\n#include <asm/unaligned.h>\n\n#include \"hw.h\"\n#include \"hw-ops.h\"\n#include \"ar9003_mac.h\"\n#include \"ar9003_mci.h\"\n#include \"ar9003_phy.h\"\n#include \"ath9k.h\"\n\nstatic bool ath9k_hw_set_reset_reg(struct ath_hw *ah, u32 type);\n\nMODULE_AUTHOR(\"Atheros Communications\");\nMODULE_DESCRIPTION(\"Support for Atheros 802.11n wireless LAN cards.\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n\nstatic void ath9k_hw_set_clockrate(struct ath_hw *ah)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath9k_channel *chan = ah->curchan;\n\tunsigned int clockrate;\n\n\t \n\tif (AR_SREV_9287(ah) && AR_SREV_9287_13_OR_LATER(ah))\n\t\tclockrate = 117;\n\telse if (!chan)  \n\t\tclockrate = ATH9K_CLOCK_RATE_CCK;\n\telse if (IS_CHAN_2GHZ(chan))\n\t\tclockrate = ATH9K_CLOCK_RATE_2GHZ_OFDM;\n\telse if (ah->caps.hw_caps & ATH9K_HW_CAP_FASTCLOCK)\n\t\tclockrate = ATH9K_CLOCK_FAST_RATE_5GHZ_OFDM;\n\telse\n\t\tclockrate = ATH9K_CLOCK_RATE_5GHZ_OFDM;\n\n\tif (chan) {\n\t\tif (IS_CHAN_HT40(chan))\n\t\t\tclockrate *= 2;\n\t\tif (IS_CHAN_HALF_RATE(chan))\n\t\t\tclockrate /= 2;\n\t\tif (IS_CHAN_QUARTER_RATE(chan))\n\t\t\tclockrate /= 4;\n\t}\n\n\tcommon->clockrate = clockrate;\n}\n\nstatic u32 ath9k_hw_mac_to_clks(struct ath_hw *ah, u32 usecs)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\n\treturn usecs * common->clockrate;\n}\n\nbool ath9k_hw_wait(struct ath_hw *ah, u32 reg, u32 mask, u32 val, u32 timeout)\n{\n\tint i;\n\n\tBUG_ON(timeout < AH_TIME_QUANTUM);\n\n\tfor (i = 0; i < (timeout / AH_TIME_QUANTUM); i++) {\n\t\tif ((REG_READ(ah, reg) & mask) == val)\n\t\t\treturn true;\n\n\t\tudelay(AH_TIME_QUANTUM);\n\t}\n\n\tath_dbg(ath9k_hw_common(ah), ANY,\n\t\t\"timeout (%d us) on reg 0x%x: 0x%08x & 0x%08x != 0x%08x\\n\",\n\t\ttimeout, reg, REG_READ(ah, reg), mask, val);\n\n\treturn false;\n}\nEXPORT_SYMBOL(ath9k_hw_wait);\n\nvoid ath9k_hw_synth_delay(struct ath_hw *ah, struct ath9k_channel *chan,\n\t\t\t  int hw_delay)\n{\n\thw_delay /= 10;\n\n\tif (IS_CHAN_HALF_RATE(chan))\n\t\thw_delay *= 2;\n\telse if (IS_CHAN_QUARTER_RATE(chan))\n\t\thw_delay *= 4;\n\n\tudelay(hw_delay + BASE_ACTIVATE_DELAY);\n}\n\nvoid ath9k_hw_write_array(struct ath_hw *ah, const struct ar5416IniArray *array,\n\t\t\t  int column, unsigned int *writecnt)\n{\n\tint r;\n\n\tENABLE_REGWRITE_BUFFER(ah);\n\tfor (r = 0; r < array->ia_rows; r++) {\n\t\tREG_WRITE(ah, INI_RA(array, r, 0),\n\t\t\t  INI_RA(array, r, column));\n\t\tDO_DELAY(*writecnt);\n\t}\n\tREGWRITE_BUFFER_FLUSH(ah);\n}\n\nvoid ath9k_hw_read_array(struct ath_hw *ah, u32 array[][2], int size)\n{\n\tu32 *tmp_reg_list, *tmp_data;\n\tint i;\n\n\ttmp_reg_list = kmalloc_array(size, sizeof(u32), GFP_KERNEL);\n\tif (!tmp_reg_list) {\n\t\tdev_err(ah->dev, \"%s: tmp_reg_list: alloc filed\\n\", __func__);\n\t\treturn;\n\t}\n\n\ttmp_data = kmalloc_array(size, sizeof(u32), GFP_KERNEL);\n\tif (!tmp_data) {\n\t\tdev_err(ah->dev, \"%s tmp_data: alloc filed\\n\", __func__);\n\t\tgoto error_tmp_data;\n\t}\n\n\tfor (i = 0; i < size; i++)\n\t\ttmp_reg_list[i] = array[i][0];\n\n\tREG_READ_MULTI(ah, tmp_reg_list, tmp_data, size);\n\n\tfor (i = 0; i < size; i++)\n\t\tarray[i][1] = tmp_data[i];\n\n\tkfree(tmp_data);\nerror_tmp_data:\n\tkfree(tmp_reg_list);\n}\n\nu32 ath9k_hw_reverse_bits(u32 val, u32 n)\n{\n\tu32 retval;\n\tint i;\n\n\tfor (i = 0, retval = 0; i < n; i++) {\n\t\tretval = (retval << 1) | (val & 1);\n\t\tval >>= 1;\n\t}\n\treturn retval;\n}\n\nu16 ath9k_hw_computetxtime(struct ath_hw *ah,\n\t\t\t   u8 phy, int kbps,\n\t\t\t   u32 frameLen, u16 rateix,\n\t\t\t   bool shortPreamble)\n{\n\tu32 bitsPerSymbol, numBits, numSymbols, phyTime, txTime;\n\n\tif (kbps == 0)\n\t\treturn 0;\n\n\tswitch (phy) {\n\tcase WLAN_RC_PHY_CCK:\n\t\tphyTime = CCK_PREAMBLE_BITS + CCK_PLCP_BITS;\n\t\tif (shortPreamble)\n\t\t\tphyTime >>= 1;\n\t\tnumBits = frameLen << 3;\n\t\ttxTime = CCK_SIFS_TIME + phyTime + ((numBits * 1000) / kbps);\n\t\tbreak;\n\tcase WLAN_RC_PHY_OFDM:\n\t\tif (ah->curchan && IS_CHAN_QUARTER_RATE(ah->curchan)) {\n\t\t\tbitsPerSymbol =\n\t\t\t\t((kbps >> 2) * OFDM_SYMBOL_TIME_QUARTER) / 1000;\n\t\t\tnumBits = OFDM_PLCP_BITS + (frameLen << 3);\n\t\t\tnumSymbols = DIV_ROUND_UP(numBits, bitsPerSymbol);\n\t\t\ttxTime = OFDM_SIFS_TIME_QUARTER\n\t\t\t\t+ OFDM_PREAMBLE_TIME_QUARTER\n\t\t\t\t+ (numSymbols * OFDM_SYMBOL_TIME_QUARTER);\n\t\t} else if (ah->curchan &&\n\t\t\t   IS_CHAN_HALF_RATE(ah->curchan)) {\n\t\t\tbitsPerSymbol =\n\t\t\t\t((kbps >> 1) * OFDM_SYMBOL_TIME_HALF) / 1000;\n\t\t\tnumBits = OFDM_PLCP_BITS + (frameLen << 3);\n\t\t\tnumSymbols = DIV_ROUND_UP(numBits, bitsPerSymbol);\n\t\t\ttxTime = OFDM_SIFS_TIME_HALF +\n\t\t\t\tOFDM_PREAMBLE_TIME_HALF\n\t\t\t\t+ (numSymbols * OFDM_SYMBOL_TIME_HALF);\n\t\t} else {\n\t\t\tbitsPerSymbol = (kbps * OFDM_SYMBOL_TIME) / 1000;\n\t\t\tnumBits = OFDM_PLCP_BITS + (frameLen << 3);\n\t\t\tnumSymbols = DIV_ROUND_UP(numBits, bitsPerSymbol);\n\t\t\ttxTime = OFDM_SIFS_TIME + OFDM_PREAMBLE_TIME\n\t\t\t\t+ (numSymbols * OFDM_SYMBOL_TIME);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tath_err(ath9k_hw_common(ah),\n\t\t\t\"Unknown phy %u (rate ix %u)\\n\", phy, rateix);\n\t\ttxTime = 0;\n\t\tbreak;\n\t}\n\n\treturn txTime;\n}\nEXPORT_SYMBOL(ath9k_hw_computetxtime);\n\nvoid ath9k_hw_get_channel_centers(struct ath_hw *ah,\n\t\t\t\t  struct ath9k_channel *chan,\n\t\t\t\t  struct chan_centers *centers)\n{\n\tint8_t extoff;\n\n\tif (!IS_CHAN_HT40(chan)) {\n\t\tcenters->ctl_center = centers->ext_center =\n\t\t\tcenters->synth_center = chan->channel;\n\t\treturn;\n\t}\n\n\tif (IS_CHAN_HT40PLUS(chan)) {\n\t\tcenters->synth_center =\n\t\t\tchan->channel + HT40_CHANNEL_CENTER_SHIFT;\n\t\textoff = 1;\n\t} else {\n\t\tcenters->synth_center =\n\t\t\tchan->channel - HT40_CHANNEL_CENTER_SHIFT;\n\t\textoff = -1;\n\t}\n\n\tcenters->ctl_center =\n\t\tcenters->synth_center - (extoff * HT40_CHANNEL_CENTER_SHIFT);\n\t \n\tcenters->ext_center =\n\t\tcenters->synth_center + (extoff * HT40_CHANNEL_CENTER_SHIFT);\n}\n\n \n \n \n\nstatic bool ath9k_hw_read_revisions(struct ath_hw *ah)\n{\n\tu32 srev;\n\tu32 val;\n\n\tif (ah->get_mac_revision)\n\t\tah->hw_version.macRev = ah->get_mac_revision();\n\n\tswitch (ah->hw_version.devid) {\n\tcase AR5416_AR9100_DEVID:\n\t\tah->hw_version.macVersion = AR_SREV_VERSION_9100;\n\t\tbreak;\n\tcase AR9300_DEVID_AR9330:\n\t\tah->hw_version.macVersion = AR_SREV_VERSION_9330;\n\t\tif (!ah->get_mac_revision) {\n\t\t\tval = REG_READ(ah, AR_SREV(ah));\n\t\t\tah->hw_version.macRev = MS(val, AR_SREV_REVISION2);\n\t\t}\n\t\treturn true;\n\tcase AR9300_DEVID_AR9340:\n\t\tah->hw_version.macVersion = AR_SREV_VERSION_9340;\n\t\treturn true;\n\tcase AR9300_DEVID_QCA955X:\n\t\tah->hw_version.macVersion = AR_SREV_VERSION_9550;\n\t\treturn true;\n\tcase AR9300_DEVID_AR953X:\n\t\tah->hw_version.macVersion = AR_SREV_VERSION_9531;\n\t\treturn true;\n\tcase AR9300_DEVID_QCA956X:\n\t\tah->hw_version.macVersion = AR_SREV_VERSION_9561;\n\t\treturn true;\n\t}\n\n\tsrev = REG_READ(ah, AR_SREV(ah));\n\n\tif (srev == -1) {\n\t\tath_err(ath9k_hw_common(ah),\n\t\t\t\"Failed to read SREV register\");\n\t\treturn false;\n\t}\n\n\tval = srev & AR_SREV_ID(ah);\n\n\tif (val == 0xFF) {\n\t\tval = srev;\n\t\tah->hw_version.macVersion =\n\t\t\t(val & AR_SREV_VERSION2) >> AR_SREV_TYPE2_S;\n\t\tah->hw_version.macRev = MS(val, AR_SREV_REVISION2);\n\n\t\tif (AR_SREV_9462(ah) || AR_SREV_9565(ah))\n\t\t\tah->is_pciexpress = true;\n\t\telse\n\t\t\tah->is_pciexpress = (val &\n\t\t\t\t\t     AR_SREV_TYPE2_HOST_MODE) ? 0 : 1;\n\t} else {\n\t\tif (!AR_SREV_9100(ah))\n\t\t\tah->hw_version.macVersion = MS(val, AR_SREV_VERSION);\n\n\t\tah->hw_version.macRev = val & AR_SREV_REVISION;\n\n\t\tif (ah->hw_version.macVersion == AR_SREV_VERSION_5416_PCIE)\n\t\t\tah->is_pciexpress = true;\n\t}\n\n\treturn true;\n}\n\n \n \n \n\nstatic void ath9k_hw_disablepcie(struct ath_hw *ah)\n{\n\tif (!AR_SREV_5416(ah))\n\t\treturn;\n\n\tREG_WRITE(ah, AR_PCIE_SERDES, 0x9248fc00);\n\tREG_WRITE(ah, AR_PCIE_SERDES, 0x24924924);\n\tREG_WRITE(ah, AR_PCIE_SERDES, 0x28000029);\n\tREG_WRITE(ah, AR_PCIE_SERDES, 0x57160824);\n\tREG_WRITE(ah, AR_PCIE_SERDES, 0x25980579);\n\tREG_WRITE(ah, AR_PCIE_SERDES, 0x00000000);\n\tREG_WRITE(ah, AR_PCIE_SERDES, 0x1aaabe40);\n\tREG_WRITE(ah, AR_PCIE_SERDES, 0xbe105554);\n\tREG_WRITE(ah, AR_PCIE_SERDES, 0x000e1007);\n\n\tREG_WRITE(ah, AR_PCIE_SERDES2, 0x00000000);\n}\n\n \nstatic bool ath9k_hw_chip_test(struct ath_hw *ah)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tu32 regAddr[2] = { AR_STA_ID0 };\n\tu32 regHold[2];\n\tstatic const u32 patternData[4] = {\n\t\t0x55555555, 0xaaaaaaaa, 0x66666666, 0x99999999\n\t};\n\tint i, j, loop_max;\n\n\tif (!AR_SREV_9300_20_OR_LATER(ah)) {\n\t\tloop_max = 2;\n\t\tregAddr[1] = AR_PHY_BASE + (8 << 2);\n\t} else\n\t\tloop_max = 1;\n\n\tfor (i = 0; i < loop_max; i++) {\n\t\tu32 addr = regAddr[i];\n\t\tu32 wrData, rdData;\n\n\t\tregHold[i] = REG_READ(ah, addr);\n\t\tfor (j = 0; j < 0x100; j++) {\n\t\t\twrData = (j << 16) | j;\n\t\t\tREG_WRITE(ah, addr, wrData);\n\t\t\trdData = REG_READ(ah, addr);\n\t\t\tif (rdData != wrData) {\n\t\t\t\tath_err(common,\n\t\t\t\t\t\"address test failed addr: 0x%08x - wr:0x%08x != rd:0x%08x\\n\",\n\t\t\t\t\taddr, wrData, rdData);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tfor (j = 0; j < 4; j++) {\n\t\t\twrData = patternData[j];\n\t\t\tREG_WRITE(ah, addr, wrData);\n\t\t\trdData = REG_READ(ah, addr);\n\t\t\tif (wrData != rdData) {\n\t\t\t\tath_err(common,\n\t\t\t\t\t\"address test failed addr: 0x%08x - wr:0x%08x != rd:0x%08x\\n\",\n\t\t\t\t\taddr, wrData, rdData);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tREG_WRITE(ah, regAddr[i], regHold[i]);\n\t}\n\tudelay(100);\n\n\treturn true;\n}\n\nstatic void ath9k_hw_init_config(struct ath_hw *ah)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\n\tah->config.dma_beacon_response_time = 1;\n\tah->config.sw_beacon_response_time = 6;\n\tah->config.cwm_ignore_extcca = false;\n\tah->config.analog_shiftreg = 1;\n\n\tah->config.rx_intr_mitigation = true;\n\n\tif (AR_SREV_9300_20_OR_LATER(ah)) {\n\t\tah->config.rimt_last = 500;\n\t\tah->config.rimt_first = 2000;\n\t} else {\n\t\tah->config.rimt_last = 250;\n\t\tah->config.rimt_first = 700;\n\t}\n\n\tif (AR_SREV_9462(ah) || AR_SREV_9565(ah))\n\t\tah->config.pll_pwrsave = 7;\n\n\t \n\tif (num_possible_cpus() > 1)\n\t\tah->config.serialize_regmode = SER_REG_MODE_AUTO;\n\n\tif (NR_CPUS > 1 && ah->config.serialize_regmode == SER_REG_MODE_AUTO) {\n\t\tif (ah->hw_version.macVersion == AR_SREV_VERSION_5416_PCI ||\n\t\t    ((AR_SREV_9160(ah) || AR_SREV_9280(ah) || AR_SREV_9287(ah)) &&\n\t\t     !ah->is_pciexpress)) {\n\t\t\tah->config.serialize_regmode = SER_REG_MODE_ON;\n\t\t} else {\n\t\t\tah->config.serialize_regmode = SER_REG_MODE_OFF;\n\t\t}\n\t}\n\n\tath_dbg(common, RESET, \"serialize_regmode is %d\\n\",\n\t\tah->config.serialize_regmode);\n\n\tif (AR_SREV_9285(ah) || AR_SREV_9271(ah))\n\t\tah->config.max_txtrig_level = MAX_TX_FIFO_THRESHOLD >> 1;\n\telse\n\t\tah->config.max_txtrig_level = MAX_TX_FIFO_THRESHOLD;\n}\n\nstatic void ath9k_hw_init_defaults(struct ath_hw *ah)\n{\n\tstruct ath_regulatory *regulatory = ath9k_hw_regulatory(ah);\n\n\tregulatory->country_code = CTRY_DEFAULT;\n\tregulatory->power_limit = MAX_COMBINED_POWER;\n\n\tah->hw_version.magic = AR5416_MAGIC;\n\tah->hw_version.subvendorid = 0;\n\n\tah->sta_id1_defaults = AR_STA_ID1_CRPT_MIC_ENABLE |\n\t\t\t       AR_STA_ID1_MCAST_KSRCH;\n\tif (AR_SREV_9100(ah))\n\t\tah->sta_id1_defaults |= AR_STA_ID1_AR9100_BA_FIX;\n\n\tah->slottime = 9;\n\tah->globaltxtimeout = (u32) -1;\n\tah->power_mode = ATH9K_PM_UNDEFINED;\n\tah->htc_reset_init = true;\n\n\tah->tpc_enabled = false;\n\n\tah->ani_function = ATH9K_ANI_ALL;\n\tif (!AR_SREV_9300_20_OR_LATER(ah))\n\t\tah->ani_function &= ~ATH9K_ANI_MRC_CCK;\n\n\tif (AR_SREV_9285(ah) || AR_SREV_9271(ah))\n\t\tah->tx_trig_level = (AR_FTRIG_256B >> AR_FTRIG_S);\n\telse\n\t\tah->tx_trig_level = (AR_FTRIG_512B >> AR_FTRIG_S);\n}\n\nstatic void ath9k_hw_init_macaddr(struct ath_hw *ah)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tint i;\n\tu16 eeval;\n\tstatic const u32 EEP_MAC[] = { EEP_MAC_LSW, EEP_MAC_MID, EEP_MAC_MSW };\n\n\t \n\tif (is_valid_ether_addr(common->macaddr))\n\t\treturn;\n\n\tfor (i = 0; i < 3; i++) {\n\t\teeval = ah->eep_ops->get_eeprom(ah, EEP_MAC[i]);\n\t\tcommon->macaddr[2 * i] = eeval >> 8;\n\t\tcommon->macaddr[2 * i + 1] = eeval & 0xff;\n\t}\n\n\tif (is_valid_ether_addr(common->macaddr))\n\t\treturn;\n\n\tath_err(common, \"eeprom contains invalid mac address: %pM\\n\",\n\t\tcommon->macaddr);\n\n\teth_random_addr(common->macaddr);\n\tath_err(common, \"random mac address will be used: %pM\\n\",\n\t\tcommon->macaddr);\n\n\treturn;\n}\n\nstatic int ath9k_hw_post_init(struct ath_hw *ah)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tint ecode;\n\n\tif (common->bus_ops->ath_bus_type != ATH_USB) {\n\t\tif (!ath9k_hw_chip_test(ah))\n\t\t\treturn -ENODEV;\n\t}\n\n\tif (!AR_SREV_9300_20_OR_LATER(ah)) {\n\t\tecode = ar9002_hw_rf_claim(ah);\n\t\tif (ecode != 0)\n\t\t\treturn ecode;\n\t}\n\n\tecode = ath9k_hw_eeprom_init(ah);\n\tif (ecode != 0)\n\t\treturn ecode;\n\n\tath_dbg(ath9k_hw_common(ah), CONFIG, \"Eeprom VER: %d, REV: %d\\n\",\n\t\tah->eep_ops->get_eeprom_ver(ah),\n\t\tah->eep_ops->get_eeprom_rev(ah));\n\n\tath9k_hw_ani_init(ah);\n\n\t \n\tif (AR_SREV_9300_20_OR_LATER(ah)) {\n\t\tu16 regdmn = ah->eep_ops->get_eeprom(ah, EEP_REG_0);\n\t\tif ((regdmn & 0xF0) == CTL_FCC) {\n\t\t\tah->nf_2g.max = AR_PHY_CCA_MAX_GOOD_VAL_9300_FCC_2GHZ;\n\t\t\tah->nf_5g.max = AR_PHY_CCA_MAX_GOOD_VAL_9300_FCC_5GHZ;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ath9k_hw_attach_ops(struct ath_hw *ah)\n{\n\tif (!AR_SREV_9300_20_OR_LATER(ah))\n\t\treturn ar9002_hw_attach_ops(ah);\n\n\tar9003_hw_attach_ops(ah);\n\treturn 0;\n}\n\n \nstatic int __ath9k_hw_init(struct ath_hw *ah)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tint r = 0;\n\n\tif (!ath9k_hw_read_revisions(ah)) {\n\t\tath_err(common, \"Could not read hardware revisions\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tswitch (ah->hw_version.macVersion) {\n\tcase AR_SREV_VERSION_5416_PCI:\n\tcase AR_SREV_VERSION_5416_PCIE:\n\tcase AR_SREV_VERSION_9160:\n\tcase AR_SREV_VERSION_9100:\n\tcase AR_SREV_VERSION_9280:\n\tcase AR_SREV_VERSION_9285:\n\tcase AR_SREV_VERSION_9287:\n\tcase AR_SREV_VERSION_9271:\n\tcase AR_SREV_VERSION_9300:\n\tcase AR_SREV_VERSION_9330:\n\tcase AR_SREV_VERSION_9485:\n\tcase AR_SREV_VERSION_9340:\n\tcase AR_SREV_VERSION_9462:\n\tcase AR_SREV_VERSION_9550:\n\tcase AR_SREV_VERSION_9565:\n\tcase AR_SREV_VERSION_9531:\n\tcase AR_SREV_VERSION_9561:\n\t\tbreak;\n\tdefault:\n\t\tath_err(common,\n\t\t\t\"Mac Chip Rev 0x%02x.%x is not supported by this driver\\n\",\n\t\t\tah->hw_version.macVersion, ah->hw_version.macRev);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tif (AR_SREV_9300_20_OR_LATER(ah)) {\n\t\tah->WARegVal = REG_READ(ah, AR_WA(ah));\n\t\tah->WARegVal |= (AR_WA_D3_L1_DISABLE |\n\t\t\t\t AR_WA_ASPM_TIMER_BASED_DISABLE);\n\t}\n\n\tif (!ath9k_hw_set_reset_reg(ah, ATH9K_RESET_POWER_ON)) {\n\t\tath_err(common, \"Couldn't reset chip\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (AR_SREV_9565(ah)) {\n\t\tah->WARegVal |= AR_WA_BIT22;\n\t\tREG_WRITE(ah, AR_WA(ah), ah->WARegVal);\n\t}\n\n\tath9k_hw_init_defaults(ah);\n\tath9k_hw_init_config(ah);\n\n\tr = ath9k_hw_attach_ops(ah);\n\tif (r)\n\t\treturn r;\n\n\tif (!ath9k_hw_setpower(ah, ATH9K_PM_AWAKE)) {\n\t\tath_err(common, \"Couldn't wakeup chip\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (AR_SREV_9271(ah) || AR_SREV_9100(ah) || AR_SREV_9340(ah) ||\n\t    AR_SREV_9330(ah) || AR_SREV_9550(ah))\n\t\tah->is_pciexpress = false;\n\n\tah->hw_version.phyRev = REG_READ(ah, AR_PHY_CHIP_ID);\n\tath9k_hw_init_cal_settings(ah);\n\n\tif (!ah->is_pciexpress)\n\t\tath9k_hw_disablepcie(ah);\n\n\tr = ath9k_hw_post_init(ah);\n\tif (r)\n\t\treturn r;\n\n\tath9k_hw_init_mode_gain_regs(ah);\n\tr = ath9k_hw_fill_cap_info(ah);\n\tif (r)\n\t\treturn r;\n\n\tath9k_hw_init_macaddr(ah);\n\tath9k_hw_init_hang_checks(ah);\n\n\tcommon->state = ATH_HW_INITIALIZED;\n\n\treturn 0;\n}\n\nint ath9k_hw_init(struct ath_hw *ah)\n{\n\tint ret;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\n\t \n\tswitch (ah->hw_version.devid) {\n\tcase AR5416_DEVID_PCI:\n\tcase AR5416_DEVID_PCIE:\n\tcase AR5416_AR9100_DEVID:\n\tcase AR9160_DEVID_PCI:\n\tcase AR9280_DEVID_PCI:\n\tcase AR9280_DEVID_PCIE:\n\tcase AR9285_DEVID_PCIE:\n\tcase AR9287_DEVID_PCI:\n\tcase AR9287_DEVID_PCIE:\n\tcase AR2427_DEVID_PCIE:\n\tcase AR9300_DEVID_PCIE:\n\tcase AR9300_DEVID_AR9485_PCIE:\n\tcase AR9300_DEVID_AR9330:\n\tcase AR9300_DEVID_AR9340:\n\tcase AR9300_DEVID_QCA955X:\n\tcase AR9300_DEVID_AR9580:\n\tcase AR9300_DEVID_AR9462:\n\tcase AR9485_DEVID_AR1111:\n\tcase AR9300_DEVID_AR9565:\n\tcase AR9300_DEVID_AR953X:\n\tcase AR9300_DEVID_QCA956X:\n\t\tbreak;\n\tdefault:\n\t\tif (common->bus_ops->ath_bus_type == ATH_USB)\n\t\t\tbreak;\n\t\tath_err(common, \"Hardware device ID 0x%04x not supported\\n\",\n\t\t\tah->hw_version.devid);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tret = __ath9k_hw_init(ah);\n\tif (ret) {\n\t\tath_err(common,\n\t\t\t\"Unable to initialize hardware; initialization status: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tath_dynack_init(ah);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ath9k_hw_init);\n\nstatic void ath9k_hw_init_qos(struct ath_hw *ah)\n{\n\tENABLE_REGWRITE_BUFFER(ah);\n\n\tREG_WRITE(ah, AR_MIC_QOS_CONTROL, 0x100aa);\n\tREG_WRITE(ah, AR_MIC_QOS_SELECT, 0x3210);\n\n\tREG_WRITE(ah, AR_QOS_NO_ACK,\n\t\t  SM(2, AR_QOS_NO_ACK_TWO_BIT) |\n\t\t  SM(5, AR_QOS_NO_ACK_BIT_OFF) |\n\t\t  SM(0, AR_QOS_NO_ACK_BYTE_OFF));\n\n\tREG_WRITE(ah, AR_TXOP_X, AR_TXOP_X_VAL);\n\tREG_WRITE(ah, AR_TXOP_0_3, 0xFFFFFFFF);\n\tREG_WRITE(ah, AR_TXOP_4_7, 0xFFFFFFFF);\n\tREG_WRITE(ah, AR_TXOP_8_11, 0xFFFFFFFF);\n\tREG_WRITE(ah, AR_TXOP_12_15, 0xFFFFFFFF);\n\n\tREGWRITE_BUFFER_FLUSH(ah);\n}\n\nu32 ar9003_get_pll_sqsum_dvc(struct ath_hw *ah)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tint i = 0;\n\n\tREG_CLR_BIT(ah, PLL3, PLL3_DO_MEAS_MASK);\n\tudelay(100);\n\tREG_SET_BIT(ah, PLL3, PLL3_DO_MEAS_MASK);\n\n\twhile ((REG_READ(ah, PLL4) & PLL4_MEAS_DONE) == 0) {\n\n\t\tudelay(100);\n\n\t\tif (WARN_ON_ONCE(i >= 100)) {\n\t\t\tath_err(common, \"PLL4 measurement not done\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\ti++;\n\t}\n\n\treturn (REG_READ(ah, PLL3) & SQSUM_DVC_MASK) >> 3;\n}\nEXPORT_SYMBOL(ar9003_get_pll_sqsum_dvc);\n\nstatic void ath9k_hw_init_pll(struct ath_hw *ah,\n\t\t\t      struct ath9k_channel *chan)\n{\n\tu32 pll;\n\n\tpll = ath9k_hw_compute_pll_control(ah, chan);\n\n\tif (AR_SREV_9485(ah) || AR_SREV_9565(ah)) {\n\t\t \n\t\tREG_RMW_FIELD(ah, AR_CH0_BB_DPLL2,\n\t\t\t      AR_CH0_BB_DPLL2_PLL_PWD, 0x1);\n\t\tREG_RMW_FIELD(ah, AR_CH0_BB_DPLL2,\n\t\t\t      AR_CH0_DPLL2_KD, 0x40);\n\t\tREG_RMW_FIELD(ah, AR_CH0_BB_DPLL2,\n\t\t\t      AR_CH0_DPLL2_KI, 0x4);\n\n\t\tREG_RMW_FIELD(ah, AR_CH0_BB_DPLL1,\n\t\t\t      AR_CH0_BB_DPLL1_REFDIV, 0x5);\n\t\tREG_RMW_FIELD(ah, AR_CH0_BB_DPLL1,\n\t\t\t      AR_CH0_BB_DPLL1_NINI, 0x58);\n\t\tREG_RMW_FIELD(ah, AR_CH0_BB_DPLL1,\n\t\t\t      AR_CH0_BB_DPLL1_NFRAC, 0x0);\n\n\t\tREG_RMW_FIELD(ah, AR_CH0_BB_DPLL2,\n\t\t\t      AR_CH0_BB_DPLL2_OUTDIV, 0x1);\n\t\tREG_RMW_FIELD(ah, AR_CH0_BB_DPLL2,\n\t\t\t      AR_CH0_BB_DPLL2_LOCAL_PLL, 0x1);\n\t\tREG_RMW_FIELD(ah, AR_CH0_BB_DPLL2,\n\t\t\t      AR_CH0_BB_DPLL2_EN_NEGTRIG, 0x1);\n\n\t\t \n\t\tREG_RMW_FIELD(ah, AR_CH0_BB_DPLL3,\n\t\t\t      AR_CH0_BB_DPLL3_PHASE_SHIFT, 0x6);\n\n\t\tREG_RMW_FIELD(ah, AR_CH0_BB_DPLL2,\n\t\t\t      AR_CH0_BB_DPLL2_PLL_PWD, 0x0);\n\t\tudelay(1000);\n\t} else if (AR_SREV_9330(ah)) {\n\t\tu32 ddr_dpll2, pll_control2, kd;\n\n\t\tif (ah->is_clk_25mhz) {\n\t\t\tddr_dpll2 = 0x18e82f01;\n\t\t\tpll_control2 = 0xe04a3d;\n\t\t\tkd = 0x1d;\n\t\t} else {\n\t\t\tddr_dpll2 = 0x19e82f01;\n\t\t\tpll_control2 = 0x886666;\n\t\t\tkd = 0x3d;\n\t\t}\n\n\t\t \n\t\tREG_WRITE(ah, AR_CH0_DDR_DPLL2, ddr_dpll2);\n\n\t\t \n\t\tREG_RMW_FIELD(ah, AR_CH0_DDR_DPLL3,\n\t\t\t      AR_CH0_DPLL3_PHASE_SHIFT, 0x1);\n\n\t\tREG_WRITE(ah, AR_RTC_PLL_CONTROL(ah),\n\t\t\t  pll | AR_RTC_9300_PLL_BYPASS);\n\t\tudelay(1000);\n\n\t\t \n\t\tREG_WRITE(ah, AR_RTC_PLL_CONTROL2, pll_control2);\n\n\t\t \n\t\tREG_RMW_FIELD(ah, AR_CH0_BB_DPLL2, AR_CH0_DPLL2_KD, kd);\n\t\tREG_RMW_FIELD(ah, AR_CH0_BB_DPLL2, AR_CH0_DPLL2_KI, 0x06);\n\n\t\t \n\t\tREG_RMW_FIELD(ah, AR_CH0_BB_DPLL3,\n\t\t\t      AR_CH0_BB_DPLL3_PHASE_SHIFT, 0x1);\n\t} else if (AR_SREV_9340(ah) || AR_SREV_9550(ah) || AR_SREV_9531(ah) ||\n\t\t   AR_SREV_9561(ah)) {\n\t\tu32 regval, pll2_divint, pll2_divfrac, refdiv;\n\n\t\tREG_WRITE(ah, AR_RTC_PLL_CONTROL(ah),\n\t\t\t  pll | AR_RTC_9300_SOC_PLL_BYPASS);\n\t\tudelay(1000);\n\n\t\tREG_SET_BIT(ah, AR_PHY_PLL_MODE, 0x1 << 16);\n\t\tudelay(100);\n\n\t\tif (ah->is_clk_25mhz) {\n\t\t\tif (AR_SREV_9531(ah) || AR_SREV_9561(ah)) {\n\t\t\t\tpll2_divint = 0x1c;\n\t\t\t\tpll2_divfrac = 0xa3d2;\n\t\t\t\trefdiv = 1;\n\t\t\t} else {\n\t\t\t\tpll2_divint = 0x54;\n\t\t\t\tpll2_divfrac = 0x1eb85;\n\t\t\t\trefdiv = 3;\n\t\t\t}\n\t\t} else {\n\t\t\tif (AR_SREV_9340(ah)) {\n\t\t\t\tpll2_divint = 88;\n\t\t\t\tpll2_divfrac = 0;\n\t\t\t\trefdiv = 5;\n\t\t\t} else {\n\t\t\t\tpll2_divint = 0x11;\n\t\t\t\tpll2_divfrac = (AR_SREV_9531(ah) ||\n\t\t\t\t\t\tAR_SREV_9561(ah)) ?\n\t\t\t\t\t\t0x26665 : 0x26666;\n\t\t\t\trefdiv = 1;\n\t\t\t}\n\t\t}\n\n\t\tregval = REG_READ(ah, AR_PHY_PLL_MODE);\n\t\tif (AR_SREV_9531(ah) || AR_SREV_9561(ah))\n\t\t\tregval |= (0x1 << 22);\n\t\telse\n\t\t\tregval |= (0x1 << 16);\n\t\tREG_WRITE(ah, AR_PHY_PLL_MODE, regval);\n\t\tudelay(100);\n\n\t\tREG_WRITE(ah, AR_PHY_PLL_CONTROL, (refdiv << 27) |\n\t\t\t  (pll2_divint << 18) | pll2_divfrac);\n\t\tudelay(100);\n\n\t\tregval = REG_READ(ah, AR_PHY_PLL_MODE);\n\t\tif (AR_SREV_9340(ah))\n\t\t\tregval = (regval & 0x80071fff) |\n\t\t\t\t(0x1 << 30) |\n\t\t\t\t(0x1 << 13) |\n\t\t\t\t(0x4 << 26) |\n\t\t\t\t(0x18 << 19);\n\t\telse if (AR_SREV_9531(ah) || AR_SREV_9561(ah)) {\n\t\t\tregval = (regval & 0x01c00fff) |\n\t\t\t\t(0x1 << 31) |\n\t\t\t\t(0x2 << 29) |\n\t\t\t\t(0xa << 25) |\n\t\t\t\t(0x1 << 19);\n\n\t\t\tif (AR_SREV_9531(ah))\n\t\t\t\tregval |= (0x6 << 12);\n\t\t} else\n\t\t\tregval = (regval & 0x80071fff) |\n\t\t\t\t(0x3 << 30) |\n\t\t\t\t(0x1 << 13) |\n\t\t\t\t(0x4 << 26) |\n\t\t\t\t(0x60 << 19);\n\t\tREG_WRITE(ah, AR_PHY_PLL_MODE, regval);\n\n\t\tif (AR_SREV_9531(ah) || AR_SREV_9561(ah))\n\t\t\tREG_WRITE(ah, AR_PHY_PLL_MODE,\n\t\t\t\t  REG_READ(ah, AR_PHY_PLL_MODE) & 0xffbfffff);\n\t\telse\n\t\t\tREG_WRITE(ah, AR_PHY_PLL_MODE,\n\t\t\t\t  REG_READ(ah, AR_PHY_PLL_MODE) & 0xfffeffff);\n\n\t\tudelay(1000);\n\t}\n\n\tif (AR_SREV_9565(ah))\n\t\tpll |= 0x40000;\n\tREG_WRITE(ah, AR_RTC_PLL_CONTROL(ah), pll);\n\n\tif (AR_SREV_9485(ah) || AR_SREV_9340(ah) || AR_SREV_9330(ah) ||\n\t    AR_SREV_9550(ah))\n\t\tudelay(1000);\n\n\t \n\tif (AR_SREV_9271(ah)) {\n\t\tudelay(500);\n\t\tREG_WRITE(ah, 0x50040, 0x304);\n\t}\n\n\tudelay(RTC_PLL_SETTLE_DELAY);\n\n\tREG_WRITE(ah, AR_RTC_SLEEP_CLK(ah), AR_RTC_FORCE_DERIVED_CLK);\n}\n\nstatic void ath9k_hw_init_interrupt_masks(struct ath_hw *ah,\n\t\t\t\t\t  enum nl80211_iftype opmode)\n{\n\tu32 sync_default = AR_INTR_SYNC_DEFAULT;\n\tu32 imr_reg = AR_IMR_TXERR |\n\t\tAR_IMR_TXURN |\n\t\tAR_IMR_RXERR |\n\t\tAR_IMR_RXORN |\n\t\tAR_IMR_BCNMISC;\n\tu32 msi_cfg = 0;\n\n\tif (AR_SREV_9340(ah) || AR_SREV_9550(ah) || AR_SREV_9531(ah) ||\n\t    AR_SREV_9561(ah))\n\t\tsync_default &= ~AR_INTR_SYNC_HOST1_FATAL;\n\n\tif (AR_SREV_9300_20_OR_LATER(ah)) {\n\t\timr_reg |= AR_IMR_RXOK_HP;\n\t\tif (ah->config.rx_intr_mitigation) {\n\t\t\timr_reg |= AR_IMR_RXINTM | AR_IMR_RXMINTR;\n\t\t\tmsi_cfg |= AR_INTCFG_MSI_RXINTM | AR_INTCFG_MSI_RXMINTR;\n\t\t} else {\n\t\t\timr_reg |= AR_IMR_RXOK_LP;\n\t\t\tmsi_cfg |= AR_INTCFG_MSI_RXOK;\n\t\t}\n\t} else {\n\t\tif (ah->config.rx_intr_mitigation) {\n\t\t\timr_reg |= AR_IMR_RXINTM | AR_IMR_RXMINTR;\n\t\t\tmsi_cfg |= AR_INTCFG_MSI_RXINTM | AR_INTCFG_MSI_RXMINTR;\n\t\t} else {\n\t\t\timr_reg |= AR_IMR_RXOK;\n\t\t\tmsi_cfg |= AR_INTCFG_MSI_RXOK;\n\t\t}\n\t}\n\n\tif (ah->config.tx_intr_mitigation) {\n\t\timr_reg |= AR_IMR_TXINTM | AR_IMR_TXMINTR;\n\t\tmsi_cfg |= AR_INTCFG_MSI_TXINTM | AR_INTCFG_MSI_TXMINTR;\n\t} else {\n\t\timr_reg |= AR_IMR_TXOK;\n\t\tmsi_cfg |= AR_INTCFG_MSI_TXOK;\n\t}\n\n\tENABLE_REGWRITE_BUFFER(ah);\n\n\tREG_WRITE(ah, AR_IMR, imr_reg);\n\tah->imrs2_reg |= AR_IMR_S2_GTT;\n\tREG_WRITE(ah, AR_IMR_S2, ah->imrs2_reg);\n\n\tif (ah->msi_enabled) {\n\t\tah->msi_reg = REG_READ(ah, AR_PCIE_MSI(ah));\n\t\tah->msi_reg |= AR_PCIE_MSI_HW_DBI_WR_EN;\n\t\tah->msi_reg &= AR_PCIE_MSI_HW_INT_PENDING_ADDR_MSI_64;\n\t\tREG_WRITE(ah, AR_INTCFG, msi_cfg);\n\t\tath_dbg(ath9k_hw_common(ah), ANY,\n\t\t\t\"value of AR_INTCFG=0x%X, msi_cfg=0x%X\\n\",\n\t\t\tREG_READ(ah, AR_INTCFG), msi_cfg);\n\t}\n\n\tif (!AR_SREV_9100(ah)) {\n\t\tREG_WRITE(ah, AR_INTR_SYNC_CAUSE(ah), 0xFFFFFFFF);\n\t\tREG_WRITE(ah, AR_INTR_SYNC_ENABLE(ah), sync_default);\n\t\tREG_WRITE(ah, AR_INTR_SYNC_MASK(ah), 0);\n\t}\n\n\tREGWRITE_BUFFER_FLUSH(ah);\n\n\tif (AR_SREV_9300_20_OR_LATER(ah)) {\n\t\tREG_WRITE(ah, AR_INTR_PRIO_ASYNC_ENABLE(ah), 0);\n\t\tREG_WRITE(ah, AR_INTR_PRIO_ASYNC_MASK(ah), 0);\n\t\tREG_WRITE(ah, AR_INTR_PRIO_SYNC_ENABLE(ah), 0);\n\t\tREG_WRITE(ah, AR_INTR_PRIO_SYNC_MASK(ah), 0);\n\t}\n}\n\nstatic void ath9k_hw_set_sifs_time(struct ath_hw *ah, u32 us)\n{\n\tu32 val = ath9k_hw_mac_to_clks(ah, us - 2);\n\tval = min(val, (u32) 0xFFFF);\n\tREG_WRITE(ah, AR_D_GBL_IFS_SIFS, val);\n}\n\nvoid ath9k_hw_setslottime(struct ath_hw *ah, u32 us)\n{\n\tu32 val = ath9k_hw_mac_to_clks(ah, us);\n\tval = min(val, (u32) 0xFFFF);\n\tREG_WRITE(ah, AR_D_GBL_IFS_SLOT, val);\n}\n\nvoid ath9k_hw_set_ack_timeout(struct ath_hw *ah, u32 us)\n{\n\tu32 val = ath9k_hw_mac_to_clks(ah, us);\n\tval = min(val, (u32) MS(0xFFFFFFFF, AR_TIME_OUT_ACK));\n\tREG_RMW_FIELD(ah, AR_TIME_OUT, AR_TIME_OUT_ACK, val);\n}\n\nvoid ath9k_hw_set_cts_timeout(struct ath_hw *ah, u32 us)\n{\n\tu32 val = ath9k_hw_mac_to_clks(ah, us);\n\tval = min(val, (u32) MS(0xFFFFFFFF, AR_TIME_OUT_CTS));\n\tREG_RMW_FIELD(ah, AR_TIME_OUT, AR_TIME_OUT_CTS, val);\n}\n\nstatic bool ath9k_hw_set_global_txtimeout(struct ath_hw *ah, u32 tu)\n{\n\tif (tu > 0xFFFF) {\n\t\tath_dbg(ath9k_hw_common(ah), XMIT, \"bad global tx timeout %u\\n\",\n\t\t\ttu);\n\t\tah->globaltxtimeout = (u32) -1;\n\t\treturn false;\n\t} else {\n\t\tREG_RMW_FIELD(ah, AR_GTXTO, AR_GTXTO_TIMEOUT_LIMIT, tu);\n\t\tah->globaltxtimeout = tu;\n\t\treturn true;\n\t}\n}\n\nvoid ath9k_hw_init_global_settings(struct ath_hw *ah)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tconst struct ath9k_channel *chan = ah->curchan;\n\tint acktimeout, ctstimeout, ack_offset = 0;\n\tint slottime;\n\tint sifstime;\n\tint rx_lat = 0, tx_lat = 0, eifs = 0, ack_shift = 0;\n\tu32 reg;\n\n\tath_dbg(ath9k_hw_common(ah), RESET, \"ah->misc_mode 0x%x\\n\",\n\t\tah->misc_mode);\n\n\tif (!chan)\n\t\treturn;\n\n\tif (ah->misc_mode != 0)\n\t\tREG_SET_BIT(ah, AR_PCU_MISC, ah->misc_mode);\n\n\tif (IS_CHAN_A_FAST_CLOCK(ah, chan))\n\t\trx_lat = 41;\n\telse\n\t\trx_lat = 37;\n\ttx_lat = 54;\n\n\tif (IS_CHAN_5GHZ(chan))\n\t\tsifstime = 16;\n\telse\n\t\tsifstime = 10;\n\n\tif (IS_CHAN_HALF_RATE(chan)) {\n\t\teifs = 175;\n\t\trx_lat *= 2;\n\t\ttx_lat *= 2;\n\t\tif (IS_CHAN_A_FAST_CLOCK(ah, chan))\n\t\t    tx_lat += 11;\n\n\t\tsifstime = 32;\n\t\tack_offset = 16;\n\t\tack_shift = 3;\n\t\tslottime = 13;\n\t} else if (IS_CHAN_QUARTER_RATE(chan)) {\n\t\teifs = 340;\n\t\trx_lat = (rx_lat * 4) - 1;\n\t\ttx_lat *= 4;\n\t\tif (IS_CHAN_A_FAST_CLOCK(ah, chan))\n\t\t    tx_lat += 22;\n\n\t\tsifstime = 64;\n\t\tack_offset = 32;\n\t\tack_shift = 1;\n\t\tslottime = 21;\n\t} else {\n\t\tif (AR_SREV_9287(ah) && AR_SREV_9287_13_OR_LATER(ah)) {\n\t\t\teifs = AR_D_GBL_IFS_EIFS_ASYNC_FIFO;\n\t\t\treg = AR_USEC_ASYNC_FIFO;\n\t\t} else {\n\t\t\teifs = REG_READ(ah, AR_D_GBL_IFS_EIFS)/\n\t\t\t\tcommon->clockrate;\n\t\t\treg = REG_READ(ah, AR_USEC);\n\t\t}\n\t\trx_lat = MS(reg, AR_USEC_RX_LAT);\n\t\ttx_lat = MS(reg, AR_USEC_TX_LAT);\n\n\t\tslottime = ah->slottime;\n\t}\n\n\t \n\tslottime += 3 * ah->coverage_class;\n\tacktimeout = slottime + sifstime + ack_offset;\n\tctstimeout = acktimeout;\n\n\t \n\tif (IS_CHAN_2GHZ(chan) &&\n\t    !IS_CHAN_HALF_RATE(chan) && !IS_CHAN_QUARTER_RATE(chan)) {\n\t\tacktimeout += 64 - sifstime - ah->slottime;\n\t\tctstimeout += 48 - sifstime - ah->slottime;\n\t}\n\n\tif (ah->dynack.enabled) {\n\t\tacktimeout = ah->dynack.ackto;\n\t\tctstimeout = acktimeout;\n\t\tslottime = (acktimeout - 3) / 2;\n\t} else {\n\t\tah->dynack.ackto = acktimeout;\n\t}\n\n\tath9k_hw_set_sifs_time(ah, sifstime);\n\tath9k_hw_setslottime(ah, slottime);\n\tath9k_hw_set_ack_timeout(ah, acktimeout);\n\tath9k_hw_set_cts_timeout(ah, ctstimeout);\n\tif (ah->globaltxtimeout != (u32) -1)\n\t\tath9k_hw_set_global_txtimeout(ah, ah->globaltxtimeout);\n\n\tREG_WRITE(ah, AR_D_GBL_IFS_EIFS, ath9k_hw_mac_to_clks(ah, eifs));\n\tREG_RMW(ah, AR_USEC,\n\t\t(common->clockrate - 1) |\n\t\tSM(rx_lat, AR_USEC_RX_LAT) |\n\t\tSM(tx_lat, AR_USEC_TX_LAT),\n\t\tAR_USEC_TX_LAT | AR_USEC_RX_LAT | AR_USEC_USEC);\n\n\tif (IS_CHAN_HALF_RATE(chan) || IS_CHAN_QUARTER_RATE(chan))\n\t\tREG_RMW(ah, AR_TXSIFS,\n\t\t\tsifstime | SM(ack_shift, AR_TXSIFS_ACK_SHIFT),\n\t\t\t(AR_TXSIFS_TIME | AR_TXSIFS_ACK_SHIFT));\n}\nEXPORT_SYMBOL(ath9k_hw_init_global_settings);\n\nvoid ath9k_hw_deinit(struct ath_hw *ah)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\n\tif (common->state < ATH_HW_INITIALIZED)\n\t\treturn;\n\n\tath9k_hw_setpower(ah, ATH9K_PM_FULL_SLEEP);\n}\nEXPORT_SYMBOL(ath9k_hw_deinit);\n\n \n \n \n\nu32 ath9k_regd_get_ctl(struct ath_regulatory *reg, struct ath9k_channel *chan)\n{\n\tu32 ctl = ath_regd_get_band_ctl(reg, chan->chan->band);\n\n\tif (IS_CHAN_2GHZ(chan))\n\t\tctl |= CTL_11G;\n\telse\n\t\tctl |= CTL_11A;\n\n\treturn ctl;\n}\n\n \n \n \n\nstatic inline void ath9k_hw_set_dma(struct ath_hw *ah)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tint txbuf_size;\n\n\tENABLE_REGWRITE_BUFFER(ah);\n\n\t \n\tif (!AR_SREV_9300_20_OR_LATER(ah))\n\t\tREG_SET_BIT(ah, AR_AHB_MODE, AR_AHB_PREFETCH_RD_EN);\n\n\t \n\tREG_RMW(ah, AR_TXCFG, AR_TXCFG_DMASZ_128B, AR_TXCFG_DMASZ_MASK);\n\n\tREGWRITE_BUFFER_FLUSH(ah);\n\n\t \n\tif (!AR_SREV_9300_20_OR_LATER(ah))\n\t\tREG_RMW_FIELD(ah, AR_TXCFG, AR_FTRIG, ah->tx_trig_level);\n\n\tENABLE_REGWRITE_BUFFER(ah);\n\n\t \n\tREG_RMW(ah, AR_RXCFG, AR_RXCFG_DMASZ_128B, AR_RXCFG_DMASZ_MASK);\n\n\t \n\tREG_WRITE(ah, AR_RXFIFO_CFG, 0x200);\n\n\tif (AR_SREV_9300_20_OR_LATER(ah)) {\n\t\tREG_RMW_FIELD(ah, AR_RXBP_THRESH, AR_RXBP_THRESH_HP, 0x1);\n\t\tREG_RMW_FIELD(ah, AR_RXBP_THRESH, AR_RXBP_THRESH_LP, 0x1);\n\n\t\tath9k_hw_set_rx_bufsize(ah, common->rx_bufsize -\n\t\t\tah->caps.rx_status_len);\n\t}\n\n\t \n\tif (AR_SREV_9285(ah)) {\n\t\t \n\t\ttxbuf_size = AR_9285_PCU_TXBUF_CTRL_USABLE_SIZE;\n\t} else if (AR_SREV_9340_13_OR_LATER(ah)) {\n\t\t \n\t\ttxbuf_size = AR_9340_PCU_TXBUF_CTRL_USABLE_SIZE;\n\t} else {\n\t\ttxbuf_size = AR_PCU_TXBUF_CTRL_USABLE_SIZE;\n\t}\n\n\tif (!AR_SREV_9271(ah))\n\t\tREG_WRITE(ah, AR_PCU_TXBUF_CTRL, txbuf_size);\n\n\tREGWRITE_BUFFER_FLUSH(ah);\n\n\tif (AR_SREV_9300_20_OR_LATER(ah))\n\t\tath9k_hw_reset_txstatus_ring(ah);\n}\n\nstatic void ath9k_hw_set_operating_mode(struct ath_hw *ah, int opmode)\n{\n\tu32 mask = AR_STA_ID1_STA_AP | AR_STA_ID1_ADHOC;\n\tu32 set = AR_STA_ID1_KSRCH_MODE;\n\n\tENABLE_REG_RMW_BUFFER(ah);\n\tswitch (opmode) {\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tif (!AR_SREV_9340_13(ah)) {\n\t\t\tset |= AR_STA_ID1_ADHOC;\n\t\t\tREG_SET_BIT(ah, AR_CFG, AR_CFG_AP_ADHOC_INDICATION);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase NL80211_IFTYPE_OCB:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\tcase NL80211_IFTYPE_AP:\n\t\tset |= AR_STA_ID1_STA_AP;\n\t\tfallthrough;\n\tcase NL80211_IFTYPE_STATION:\n\t\tREG_CLR_BIT(ah, AR_CFG, AR_CFG_AP_ADHOC_INDICATION);\n\t\tbreak;\n\tdefault:\n\t\tif (!ah->is_monitoring)\n\t\t\tset = 0;\n\t\tbreak;\n\t}\n\tREG_RMW(ah, AR_STA_ID1, set, mask);\n\tREG_RMW_BUFFER_FLUSH(ah);\n}\n\nvoid ath9k_hw_get_delta_slope_vals(struct ath_hw *ah, u32 coef_scaled,\n\t\t\t\t   u32 *coef_mantissa, u32 *coef_exponent)\n{\n\tu32 coef_exp, coef_man;\n\n\tfor (coef_exp = 31; coef_exp > 0; coef_exp--)\n\t\tif ((coef_scaled >> coef_exp) & 0x1)\n\t\t\tbreak;\n\n\tcoef_exp = 14 - (coef_exp - COEF_SCALE_S);\n\n\tcoef_man = coef_scaled + (1 << (COEF_SCALE_S - coef_exp - 1));\n\n\t*coef_mantissa = coef_man >> (COEF_SCALE_S - coef_exp);\n\t*coef_exponent = coef_exp - 16;\n}\n\n \nstatic bool ath9k_hw_ar9330_reset_war(struct ath_hw *ah, int type)\n{\n\tint i, npend = 0;\n\n\tfor (i = 0; i < AR_NUM_QCU; i++) {\n\t\tnpend = ath9k_hw_numtxpending(ah, i);\n\t\tif (npend)\n\t\t\tbreak;\n\t}\n\n\tif (ah->external_reset &&\n\t    (npend || type == ATH9K_RESET_COLD)) {\n\t\tint reset_err = 0;\n\n\t\tath_dbg(ath9k_hw_common(ah), RESET,\n\t\t\t\"reset MAC via external reset\\n\");\n\n\t\treset_err = ah->external_reset();\n\t\tif (reset_err) {\n\t\t\tath_err(ath9k_hw_common(ah),\n\t\t\t\t\"External reset failed, err=%d\\n\",\n\t\t\t\treset_err);\n\t\t\treturn false;\n\t\t}\n\n\t\tREG_WRITE(ah, AR_RTC_RESET(ah), 1);\n\t}\n\n\treturn true;\n}\n\nstatic bool ath9k_hw_set_reset(struct ath_hw *ah, int type)\n{\n\tu32 rst_flags;\n\tu32 tmpReg;\n\n\tif (AR_SREV_9100(ah)) {\n\t\tREG_RMW_FIELD(ah, AR_RTC_DERIVED_CLK(ah),\n\t\t\t      AR_RTC_DERIVED_CLK_PERIOD, 1);\n\t\t(void)REG_READ(ah, AR_RTC_DERIVED_CLK(ah));\n\t}\n\n\tENABLE_REGWRITE_BUFFER(ah);\n\n\tif (AR_SREV_9300_20_OR_LATER(ah)) {\n\t\tREG_WRITE(ah, AR_WA(ah), ah->WARegVal);\n\t\tudelay(10);\n\t}\n\n\tREG_WRITE(ah, AR_RTC_FORCE_WAKE(ah), AR_RTC_FORCE_WAKE_EN |\n\t\t  AR_RTC_FORCE_WAKE_ON_INT);\n\n\tif (AR_SREV_9100(ah)) {\n\t\trst_flags = AR_RTC_RC_MAC_WARM | AR_RTC_RC_MAC_COLD |\n\t\t\tAR_RTC_RC_COLD_RESET | AR_RTC_RC_WARM_RESET;\n\t} else {\n\t\ttmpReg = REG_READ(ah, AR_INTR_SYNC_CAUSE(ah));\n\t\tif (AR_SREV_9340(ah))\n\t\t\ttmpReg &= AR9340_INTR_SYNC_LOCAL_TIMEOUT;\n\t\telse\n\t\t\ttmpReg &= AR_INTR_SYNC_LOCAL_TIMEOUT |\n\t\t\t\t  AR_INTR_SYNC_RADM_CPL_TIMEOUT;\n\n\t\tif (tmpReg) {\n\t\t\tu32 val;\n\t\t\tREG_WRITE(ah, AR_INTR_SYNC_ENABLE(ah), 0);\n\n\t\t\tval = AR_RC_HOSTIF;\n\t\t\tif (!AR_SREV_9300_20_OR_LATER(ah))\n\t\t\t\tval |= AR_RC_AHB;\n\t\t\tREG_WRITE(ah, AR_RC, val);\n\n\t\t} else if (!AR_SREV_9300_20_OR_LATER(ah))\n\t\t\tREG_WRITE(ah, AR_RC, AR_RC_AHB);\n\n\t\trst_flags = AR_RTC_RC_MAC_WARM;\n\t\tif (type == ATH9K_RESET_COLD)\n\t\t\trst_flags |= AR_RTC_RC_MAC_COLD;\n\t}\n\n\tif (AR_SREV_9330(ah)) {\n\t\tif (!ath9k_hw_ar9330_reset_war(ah, type))\n\t\t\treturn false;\n\t}\n\n\tif (ath9k_hw_mci_is_enabled(ah))\n\t\tar9003_mci_check_gpm_offset(ah);\n\n\t \n\tif (AR_SREV_9300(ah) || AR_SREV_9580(ah)) {\n\t\tREG_SET_BIT(ah, AR_CFG, AR_CFG_HALT_REQ);\n\t\tath9k_hw_wait(ah, AR_CFG, AR_CFG_HALT_ACK, AR_CFG_HALT_ACK,\n\t\t\t      20 * AH_WAIT_TIMEOUT);\n\t\tREG_CLR_BIT(ah, AR_CFG, AR_CFG_HALT_REQ);\n\t}\n\n\tREG_WRITE(ah, AR_RTC_RC(ah), rst_flags);\n\n\tREGWRITE_BUFFER_FLUSH(ah);\n\n\tif (AR_SREV_9300_20_OR_LATER(ah))\n\t\tudelay(50);\n\telse if (AR_SREV_9100(ah))\n\t\tmdelay(10);\n\telse\n\t\tudelay(100);\n\n\tREG_WRITE(ah, AR_RTC_RC(ah), 0);\n\tif (!ath9k_hw_wait(ah, AR_RTC_RC(ah), AR_RTC_RC_M, 0, AH_WAIT_TIMEOUT)) {\n\t\tath_dbg(ath9k_hw_common(ah), RESET, \"RTC stuck in MAC reset\\n\");\n\t\treturn false;\n\t}\n\n\tif (!AR_SREV_9100(ah))\n\t\tREG_WRITE(ah, AR_RC, 0);\n\n\tif (AR_SREV_9100(ah))\n\t\tudelay(50);\n\n\treturn true;\n}\n\nstatic bool ath9k_hw_set_reset_power_on(struct ath_hw *ah)\n{\n\tENABLE_REGWRITE_BUFFER(ah);\n\n\tif (AR_SREV_9300_20_OR_LATER(ah)) {\n\t\tREG_WRITE(ah, AR_WA(ah), ah->WARegVal);\n\t\tudelay(10);\n\t}\n\n\tREG_WRITE(ah, AR_RTC_FORCE_WAKE(ah), AR_RTC_FORCE_WAKE_EN |\n\t\t  AR_RTC_FORCE_WAKE_ON_INT);\n\n\tif (!AR_SREV_9100(ah) && !AR_SREV_9300_20_OR_LATER(ah))\n\t\tREG_WRITE(ah, AR_RC, AR_RC_AHB);\n\n\tREG_WRITE(ah, AR_RTC_RESET(ah), 0);\n\n\tREGWRITE_BUFFER_FLUSH(ah);\n\n\tudelay(2);\n\n\tif (!AR_SREV_9100(ah) && !AR_SREV_9300_20_OR_LATER(ah))\n\t\tREG_WRITE(ah, AR_RC, 0);\n\n\tREG_WRITE(ah, AR_RTC_RESET(ah), 1);\n\n\tif (!ath9k_hw_wait(ah,\n\t\t\t   AR_RTC_STATUS(ah),\n\t\t\t   AR_RTC_STATUS_M(ah),\n\t\t\t   AR_RTC_STATUS_ON,\n\t\t\t   AH_WAIT_TIMEOUT)) {\n\t\tath_dbg(ath9k_hw_common(ah), RESET, \"RTC not waking up\\n\");\n\t\treturn false;\n\t}\n\n\treturn ath9k_hw_set_reset(ah, ATH9K_RESET_WARM);\n}\n\nstatic bool ath9k_hw_set_reset_reg(struct ath_hw *ah, u32 type)\n{\n\tbool ret = false;\n\n\tif (AR_SREV_9300_20_OR_LATER(ah)) {\n\t\tREG_WRITE(ah, AR_WA(ah), ah->WARegVal);\n\t\tudelay(10);\n\t}\n\n\tREG_WRITE(ah, AR_RTC_FORCE_WAKE(ah),\n\t\t  AR_RTC_FORCE_WAKE_EN | AR_RTC_FORCE_WAKE_ON_INT);\n\n\tif (!ah->reset_power_on)\n\t\ttype = ATH9K_RESET_POWER_ON;\n\n\tswitch (type) {\n\tcase ATH9K_RESET_POWER_ON:\n\t\tret = ath9k_hw_set_reset_power_on(ah);\n\t\tif (ret)\n\t\t\tah->reset_power_on = true;\n\t\tbreak;\n\tcase ATH9K_RESET_WARM:\n\tcase ATH9K_RESET_COLD:\n\t\tret = ath9k_hw_set_reset(ah, type);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic bool ath9k_hw_chip_reset(struct ath_hw *ah,\n\t\t\t\tstruct ath9k_channel *chan)\n{\n\tint reset_type = ATH9K_RESET_WARM;\n\n\tif (AR_SREV_9280(ah)) {\n\t\tif (ah->eep_ops->get_eeprom(ah, EEP_OL_PWRCTRL))\n\t\t\treset_type = ATH9K_RESET_POWER_ON;\n\t\telse\n\t\t\treset_type = ATH9K_RESET_COLD;\n\t} else if (ah->chip_fullsleep || REG_READ(ah, AR_Q_TXE) ||\n\t\t   (REG_READ(ah, AR_CR) & AR_CR_RXE(ah)))\n\t\treset_type = ATH9K_RESET_COLD;\n\n\tif (!ath9k_hw_set_reset_reg(ah, reset_type))\n\t\treturn false;\n\n\tif (!ath9k_hw_setpower(ah, ATH9K_PM_AWAKE))\n\t\treturn false;\n\n\tah->chip_fullsleep = false;\n\n\tif (AR_SREV_9330(ah))\n\t\tar9003_hw_internal_regulator_apply(ah);\n\tath9k_hw_init_pll(ah, chan);\n\n\treturn true;\n}\n\nstatic bool ath9k_hw_channel_change(struct ath_hw *ah,\n\t\t\t\t    struct ath9k_channel *chan)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath9k_hw_capabilities *pCap = &ah->caps;\n\tbool band_switch = false, mode_diff = false;\n\tu8 ini_reloaded = 0;\n\tu32 qnum;\n\tint r;\n\n\tif (pCap->hw_caps & ATH9K_HW_CAP_FCC_BAND_SWITCH) {\n\t\tu32 flags_diff = chan->channelFlags ^ ah->curchan->channelFlags;\n\t\tband_switch = !!(flags_diff & CHANNEL_5GHZ);\n\t\tmode_diff = !!(flags_diff & ~CHANNEL_HT);\n\t}\n\n\tfor (qnum = 0; qnum < AR_NUM_QCU; qnum++) {\n\t\tif (ath9k_hw_numtxpending(ah, qnum)) {\n\t\t\tath_dbg(common, QUEUE,\n\t\t\t\t\"Transmit frames pending on queue %d\\n\", qnum);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (!ath9k_hw_rfbus_req(ah)) {\n\t\tath_err(common, \"Could not kill baseband RX\\n\");\n\t\treturn false;\n\t}\n\n\tif (band_switch || mode_diff) {\n\t\tath9k_hw_mark_phy_inactive(ah);\n\t\tudelay(5);\n\n\t\tif (band_switch)\n\t\t\tath9k_hw_init_pll(ah, chan);\n\n\t\tif (ath9k_hw_fast_chan_change(ah, chan, &ini_reloaded)) {\n\t\t\tath_err(common, \"Failed to do fast channel change\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tath9k_hw_set_channel_regs(ah, chan);\n\n\tr = ath9k_hw_rf_set_freq(ah, chan);\n\tif (r) {\n\t\tath_err(common, \"Failed to set channel\\n\");\n\t\treturn false;\n\t}\n\tath9k_hw_set_clockrate(ah);\n\tath9k_hw_apply_txpower(ah, chan, false);\n\n\tath9k_hw_set_delta_slope(ah, chan);\n\tath9k_hw_spur_mitigate_freq(ah, chan);\n\n\tif (band_switch || ini_reloaded)\n\t\tah->eep_ops->set_board_values(ah, chan);\n\n\tath9k_hw_init_bb(ah, chan);\n\tath9k_hw_rfbus_done(ah);\n\n\tif (band_switch || ini_reloaded) {\n\t\tah->ah_flags |= AH_FASTCC;\n\t\tath9k_hw_init_cal(ah, chan);\n\t\tah->ah_flags &= ~AH_FASTCC;\n\t}\n\n\treturn true;\n}\n\nstatic void ath9k_hw_apply_gpio_override(struct ath_hw *ah)\n{\n\tu32 gpio_mask = ah->gpio_mask;\n\tint i;\n\n\tfor (i = 0; gpio_mask; i++, gpio_mask >>= 1) {\n\t\tif (!(gpio_mask & 1))\n\t\t\tcontinue;\n\n\t\tath9k_hw_gpio_request_out(ah, i, NULL,\n\t\t\t\t\t  AR_GPIO_OUTPUT_MUX_AS_OUTPUT);\n\t\tath9k_hw_set_gpio(ah, i, !!(ah->gpio_val & BIT(i)));\n\t}\n}\n\nvoid ath9k_hw_check_nav(struct ath_hw *ah)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tu32 val;\n\n\tval = REG_READ(ah, AR_NAV);\n\tif (val != 0xdeadbeef && val > 0x7fff) {\n\t\tath_dbg(common, BSTUCK, \"Abnormal NAV: 0x%x\\n\", val);\n\t\tREG_WRITE(ah, AR_NAV, 0);\n\t}\n}\nEXPORT_SYMBOL(ath9k_hw_check_nav);\n\nbool ath9k_hw_check_alive(struct ath_hw *ah)\n{\n\tint count = 50;\n\tu32 reg, last_val;\n\n\t \n\tif (REG_READ(ah, AR_CFG) == 0xdeadbeef)\n\t\treturn false;\n\n\tif (AR_SREV_9300(ah))\n\t\treturn !ath9k_hw_detect_mac_hang(ah);\n\n\tif (AR_SREV_9285_12_OR_LATER(ah))\n\t\treturn true;\n\n\tlast_val = REG_READ(ah, AR_OBS_BUS_1);\n\tdo {\n\t\treg = REG_READ(ah, AR_OBS_BUS_1);\n\t\tif (reg != last_val)\n\t\t\treturn true;\n\n\t\tudelay(1);\n\t\tlast_val = reg;\n\t\tif ((reg & 0x7E7FFFEF) == 0x00702400)\n\t\t\tcontinue;\n\n\t\tswitch (reg & 0x7E000B00) {\n\t\tcase 0x1E000000:\n\t\tcase 0x52000B00:\n\t\tcase 0x18000B00:\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\treturn true;\n\t\t}\n\t} while (count-- > 0);\n\n\treturn false;\n}\nEXPORT_SYMBOL(ath9k_hw_check_alive);\n\nstatic void ath9k_hw_init_mfp(struct ath_hw *ah)\n{\n\t \n\tif (AR_SREV_9280_20_OR_LATER(ah)) {\n\t\t \n\t\tREG_RMW_FIELD(ah, AR_AES_MUTE_MASK1, AR_AES_MUTE_MASK1_FC_MGMT,\n\t\t\t      0xc7ff);\n\t\tif (AR_SREV_9271(ah) || AR_DEVID_7010(ah))\n\t\t\tah->sw_mgmt_crypto_tx = true;\n\t\telse\n\t\t\tah->sw_mgmt_crypto_tx = false;\n\t\tah->sw_mgmt_crypto_rx = false;\n\t} else if (AR_SREV_9160_10_OR_LATER(ah)) {\n\t\t \n\t\tREG_CLR_BIT(ah, AR_PCU_MISC_MODE2,\n\t\t\t    AR_PCU_MISC_MODE2_MGMT_CRYPTO_ENABLE);\n\t\tREG_SET_BIT(ah, AR_PCU_MISC_MODE2,\n\t\t\t    AR_PCU_MISC_MODE2_NO_CRYPTO_FOR_NON_DATA_PKT);\n\t\tah->sw_mgmt_crypto_tx = true;\n\t\tah->sw_mgmt_crypto_rx = true;\n\t} else {\n\t\tah->sw_mgmt_crypto_tx = true;\n\t\tah->sw_mgmt_crypto_rx = true;\n\t}\n}\n\nstatic void ath9k_hw_reset_opmode(struct ath_hw *ah,\n\t\t\t\t  u32 macStaId1, u32 saveDefAntenna)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\n\tENABLE_REGWRITE_BUFFER(ah);\n\n\tREG_RMW(ah, AR_STA_ID1, macStaId1\n\t\t  | AR_STA_ID1_RTS_USE_DEF\n\t\t  | ah->sta_id1_defaults,\n\t\t  ~AR_STA_ID1_SADH_MASK);\n\tath_hw_setbssidmask(common);\n\tREG_WRITE(ah, AR_DEF_ANTENNA, saveDefAntenna);\n\tath9k_hw_write_associd(ah);\n\tREG_WRITE(ah, AR_ISR, ~0);\n\tREG_WRITE(ah, AR_RSSI_THR, INIT_RSSI_THR);\n\n\tREGWRITE_BUFFER_FLUSH(ah);\n\n\tath9k_hw_set_operating_mode(ah, ah->opmode);\n}\n\nstatic void ath9k_hw_init_queues(struct ath_hw *ah)\n{\n\tint i;\n\n\tENABLE_REGWRITE_BUFFER(ah);\n\n\tfor (i = 0; i < AR_NUM_DCU; i++)\n\t\tREG_WRITE(ah, AR_DQCUMASK(i), 1 << i);\n\n\tREGWRITE_BUFFER_FLUSH(ah);\n\n\tah->intr_txqs = 0;\n\tfor (i = 0; i < ATH9K_NUM_TX_QUEUES; i++)\n\t\tath9k_hw_resettxqueue(ah, i);\n}\n\n \nstatic void ath9k_hw_init_desc(struct ath_hw *ah)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\n\tif (AR_SREV_9100(ah)) {\n\t\tu32 mask;\n\t\tmask = REG_READ(ah, AR_CFG);\n\t\tif (mask & (AR_CFG_SWRB | AR_CFG_SWTB | AR_CFG_SWRG)) {\n\t\t\tath_dbg(common, RESET, \"CFG Byte Swap Set 0x%x\\n\",\n\t\t\t\tmask);\n\t\t} else {\n\t\t\tmask = INIT_CONFIG_STATUS | AR_CFG_SWRB | AR_CFG_SWTB;\n\t\t\tREG_WRITE(ah, AR_CFG, mask);\n\t\t\tath_dbg(common, RESET, \"Setting CFG 0x%x\\n\",\n\t\t\t\tREG_READ(ah, AR_CFG));\n\t\t}\n\t} else {\n\t\tif (common->bus_ops->ath_bus_type == ATH_USB) {\n\t\t\t \n\t\t\tif (AR_SREV_9271(ah))\n\t\t\t\tREG_WRITE(ah, AR_CFG, AR_CFG_SWRB | AR_CFG_SWTB);\n\t\t\telse\n\t\t\t\tREG_WRITE(ah, AR_CFG, AR_CFG_SWTD | AR_CFG_SWRD);\n\t\t}\n#ifdef __BIG_ENDIAN\n\t\telse if (AR_SREV_9330(ah) || AR_SREV_9340(ah) ||\n\t\t\t AR_SREV_9550(ah) || AR_SREV_9531(ah) ||\n\t\t\t AR_SREV_9561(ah))\n\t\t\tREG_RMW(ah, AR_CFG, AR_CFG_SWRB | AR_CFG_SWTB, 0);\n\t\telse\n\t\t\tREG_WRITE(ah, AR_CFG, AR_CFG_SWTD | AR_CFG_SWRD);\n#endif\n\t}\n}\n\n \nstatic int ath9k_hw_do_fastcc(struct ath_hw *ah, struct ath9k_channel *chan)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath9k_hw_capabilities *pCap = &ah->caps;\n\tint ret;\n\n\tif (AR_SREV_9280(ah) && common->bus_ops->ath_bus_type == ATH_PCI)\n\t\tgoto fail;\n\n\tif (ah->chip_fullsleep)\n\t\tgoto fail;\n\n\tif (!ah->curchan)\n\t\tgoto fail;\n\n\tif (chan->channel == ah->curchan->channel)\n\t\tgoto fail;\n\n\tif ((ah->curchan->channelFlags | chan->channelFlags) &\n\t    (CHANNEL_HALF | CHANNEL_QUARTER))\n\t\tgoto fail;\n\n\t \n\tif (!(pCap->hw_caps & ATH9K_HW_CAP_FCC_BAND_SWITCH) &&\n\t    ((chan->channelFlags ^ ah->curchan->channelFlags) & ~CHANNEL_HT))\n\t\tgoto fail;\n\n\tif (!ath9k_hw_check_alive(ah))\n\t\tgoto fail;\n\n\t \n\tif (AR_SREV_9462(ah) && (ah->caldata &&\n\t\t\t\t (!test_bit(TXIQCAL_DONE, &ah->caldata->cal_flags) ||\n\t\t\t\t  !test_bit(TXCLCAL_DONE, &ah->caldata->cal_flags) ||\n\t\t\t\t  !test_bit(RTT_DONE, &ah->caldata->cal_flags))))\n\t\tgoto fail;\n\n\tath_dbg(common, RESET, \"FastChannelChange for %d -> %d\\n\",\n\t\tah->curchan->channel, chan->channel);\n\n\tret = ath9k_hw_channel_change(ah, chan);\n\tif (!ret)\n\t\tgoto fail;\n\n\tif (ath9k_hw_mci_is_enabled(ah))\n\t\tar9003_mci_2g5g_switch(ah, false);\n\n\tath9k_hw_loadnf(ah, ah->curchan);\n\tath9k_hw_start_nfcal(ah, true);\n\n\tif (AR_SREV_9271(ah))\n\t\tar9002_hw_load_ani_reg(ah, chan);\n\n\treturn 0;\nfail:\n\treturn -EINVAL;\n}\n\nu32 ath9k_hw_get_tsf_offset(struct timespec64 *last, struct timespec64 *cur)\n{\n\tstruct timespec64 ts;\n\ts64 usec;\n\n\tif (!cur) {\n\t\tktime_get_raw_ts64(&ts);\n\t\tcur = &ts;\n\t}\n\n\tusec = cur->tv_sec * 1000000ULL + cur->tv_nsec / 1000;\n\tusec -= last->tv_sec * 1000000ULL + last->tv_nsec / 1000;\n\n\treturn (u32) usec;\n}\nEXPORT_SYMBOL(ath9k_hw_get_tsf_offset);\n\nint ath9k_hw_reset(struct ath_hw *ah, struct ath9k_channel *chan,\n\t\t   struct ath9k_hw_cal_data *caldata, bool fastcc)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tu32 saveLedState;\n\tu32 saveDefAntenna;\n\tu32 macStaId1;\n\tstruct timespec64 tsf_ts;\n\tu32 tsf_offset;\n\tu64 tsf = 0;\n\tint r;\n\tbool start_mci_reset = false;\n\tbool save_fullsleep = ah->chip_fullsleep;\n\n\tif (ath9k_hw_mci_is_enabled(ah)) {\n\t\tstart_mci_reset = ar9003_mci_start_reset(ah, chan);\n\t\tif (start_mci_reset)\n\t\t\treturn 0;\n\t}\n\n\tif (!ath9k_hw_setpower(ah, ATH9K_PM_AWAKE))\n\t\treturn -EIO;\n\n\tif (ah->curchan && !ah->chip_fullsleep)\n\t\tath9k_hw_getnf(ah, ah->curchan);\n\n\tah->caldata = caldata;\n\tif (caldata && (chan->channel != caldata->channel ||\n\t\t\tchan->channelFlags != caldata->channelFlags)) {\n\t\t \n\t\tmemset(caldata, 0, sizeof(*caldata));\n\t\tath9k_init_nfcal_hist_buffer(ah, chan);\n\t} else if (caldata) {\n\t\tclear_bit(PAPRD_PACKET_SENT, &caldata->cal_flags);\n\t}\n\tah->noise = ath9k_hw_getchan_noise(ah, chan, chan->noisefloor);\n\n\tif (fastcc) {\n\t\tr = ath9k_hw_do_fastcc(ah, chan);\n\t\tif (!r)\n\t\t\treturn r;\n\t}\n\n\tif (ath9k_hw_mci_is_enabled(ah))\n\t\tar9003_mci_stop_bt(ah, save_fullsleep);\n\n\tsaveDefAntenna = REG_READ(ah, AR_DEF_ANTENNA);\n\tif (saveDefAntenna == 0)\n\t\tsaveDefAntenna = 1;\n\n\tmacStaId1 = REG_READ(ah, AR_STA_ID1) & AR_STA_ID1_BASE_RATE_11B;\n\n\t \n\tktime_get_raw_ts64(&tsf_ts);\n\ttsf = ath9k_hw_gettsf64(ah);\n\n\tsaveLedState = REG_READ(ah, AR_CFG_LED) &\n\t\t(AR_CFG_LED_ASSOC_CTL | AR_CFG_LED_MODE_SEL |\n\t\t AR_CFG_LED_BLINK_THRESH_SEL | AR_CFG_LED_BLINK_SLOW);\n\n\tath9k_hw_mark_phy_inactive(ah);\n\n\tah->paprd_table_write_done = false;\n\n\t \n\tif (AR_SREV_9271(ah) && ah->htc_reset_init) {\n\t\tREG_WRITE(ah,\n\t\t\t  AR9271_RESET_POWER_DOWN_CONTROL,\n\t\t\t  AR9271_RADIO_RF_RST);\n\t\tudelay(50);\n\t}\n\n\tif (!ath9k_hw_chip_reset(ah, chan)) {\n\t\tath_err(common, \"Chip reset failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (AR_SREV_9271(ah) && ah->htc_reset_init) {\n\t\tah->htc_reset_init = false;\n\t\tREG_WRITE(ah,\n\t\t\t  AR9271_RESET_POWER_DOWN_CONTROL,\n\t\t\t  AR9271_GATE_MAC_CTL);\n\t\tudelay(50);\n\t}\n\n\t \n\ttsf_offset = ath9k_hw_get_tsf_offset(&tsf_ts, NULL);\n\tath9k_hw_settsf64(ah, tsf + tsf_offset);\n\n\tif (AR_SREV_9280_20_OR_LATER(ah))\n\t\tREG_SET_BIT(ah, AR_GPIO_INPUT_EN_VAL(ah), AR_GPIO_JTAG_DISABLE);\n\n\tif (!AR_SREV_9300_20_OR_LATER(ah))\n\t\tar9002_hw_enable_async_fifo(ah);\n\n\tr = ath9k_hw_process_ini(ah, chan);\n\tif (r)\n\t\treturn r;\n\n\tath9k_hw_set_rfmode(ah, chan);\n\n\tif (ath9k_hw_mci_is_enabled(ah))\n\t\tar9003_mci_reset(ah, false, IS_CHAN_2GHZ(chan), save_fullsleep);\n\n\t \n\tif (AR_SREV_9100(ah) && (ath9k_hw_gettsf64(ah) < tsf)) {\n\t\ttsf_offset = ath9k_hw_get_tsf_offset(&tsf_ts, NULL);\n\t\tath9k_hw_settsf64(ah, tsf + tsf_offset);\n\t}\n\n\tath9k_hw_init_mfp(ah);\n\n\tath9k_hw_set_delta_slope(ah, chan);\n\tath9k_hw_spur_mitigate_freq(ah, chan);\n\tah->eep_ops->set_board_values(ah, chan);\n\n\tath9k_hw_reset_opmode(ah, macStaId1, saveDefAntenna);\n\n\tr = ath9k_hw_rf_set_freq(ah, chan);\n\tif (r)\n\t\treturn r;\n\n\tath9k_hw_set_clockrate(ah);\n\n\tath9k_hw_init_queues(ah);\n\tath9k_hw_init_interrupt_masks(ah, ah->opmode);\n\tath9k_hw_ani_cache_ini_regs(ah);\n\tath9k_hw_init_qos(ah);\n\n\tif (ah->caps.hw_caps & ATH9K_HW_CAP_RFSILENT)\n\t\tath9k_hw_gpio_request_in(ah, ah->rfkill_gpio, \"ath9k-rfkill\");\n\n\tath9k_hw_init_global_settings(ah);\n\n\tif (AR_SREV_9287(ah) && AR_SREV_9287_13_OR_LATER(ah)) {\n\t\tREG_SET_BIT(ah, AR_MAC_PCU_LOGIC_ANALYZER,\n\t\t\t    AR_MAC_PCU_LOGIC_ANALYZER_DISBUG20768);\n\t\tREG_RMW_FIELD(ah, AR_AHB_MODE, AR_AHB_CUSTOM_BURST_EN,\n\t\t\t      AR_AHB_CUSTOM_BURST_ASYNC_FIFO_VAL);\n\t\tREG_SET_BIT(ah, AR_PCU_MISC_MODE2,\n\t\t\t    AR_PCU_MISC_MODE2_ENABLE_AGGWEP);\n\t}\n\n\tREG_SET_BIT(ah, AR_STA_ID1, AR_STA_ID1_PRESERVE_SEQNUM);\n\n\tath9k_hw_set_dma(ah);\n\n\tif (!ath9k_hw_mci_is_enabled(ah))\n\t\tREG_WRITE(ah, AR_OBS(ah), 8);\n\n\tENABLE_REG_RMW_BUFFER(ah);\n\tif (ah->config.rx_intr_mitigation) {\n\t\tREG_RMW_FIELD(ah, AR_RIMT, AR_RIMT_LAST, ah->config.rimt_last);\n\t\tREG_RMW_FIELD(ah, AR_RIMT, AR_RIMT_FIRST, ah->config.rimt_first);\n\t}\n\n\tif (ah->config.tx_intr_mitigation) {\n\t\tREG_RMW_FIELD(ah, AR_TIMT, AR_TIMT_LAST, 300);\n\t\tREG_RMW_FIELD(ah, AR_TIMT, AR_TIMT_FIRST, 750);\n\t}\n\tREG_RMW_BUFFER_FLUSH(ah);\n\n\tath9k_hw_init_bb(ah, chan);\n\n\tif (caldata) {\n\t\tclear_bit(TXIQCAL_DONE, &caldata->cal_flags);\n\t\tclear_bit(TXCLCAL_DONE, &caldata->cal_flags);\n\t}\n\tif (!ath9k_hw_init_cal(ah, chan))\n\t\treturn -EIO;\n\n\tif (ath9k_hw_mci_is_enabled(ah) && ar9003_mci_end_reset(ah, chan, caldata))\n\t\treturn -EIO;\n\n\tENABLE_REGWRITE_BUFFER(ah);\n\n\tath9k_hw_restore_chainmask(ah);\n\tREG_WRITE(ah, AR_CFG_LED, saveLedState | AR_CFG_SCLK_32KHZ);\n\n\tREGWRITE_BUFFER_FLUSH(ah);\n\n\tath9k_hw_gen_timer_start_tsf2(ah);\n\n\tath9k_hw_init_desc(ah);\n\n\tif (ath9k_hw_btcoex_is_enabled(ah))\n\t\tath9k_hw_btcoex_enable(ah);\n\n\tif (ath9k_hw_mci_is_enabled(ah))\n\t\tar9003_mci_check_bt(ah);\n\n\tif (AR_SREV_9300_20_OR_LATER(ah)) {\n\t\tath9k_hw_loadnf(ah, chan);\n\t\tath9k_hw_start_nfcal(ah, true);\n\t}\n\n\tif (AR_SREV_9300_20_OR_LATER(ah))\n\t\tar9003_hw_bb_watchdog_config(ah);\n\n\tif (ah->config.hw_hang_checks & HW_PHYRESTART_CLC_WAR)\n\t\tar9003_hw_disable_phy_restart(ah);\n\n\tath9k_hw_apply_gpio_override(ah);\n\n\tif (AR_SREV_9565(ah) && common->bt_ant_diversity)\n\t\tREG_SET_BIT(ah, AR_BTCOEX_WL_LNADIV, AR_BTCOEX_WL_LNADIV_FORCE_ON);\n\n\tif (ah->hw->conf.radar_enabled) {\n\t\t \n\t\tah->radar_conf.ext_channel = IS_CHAN_HT40(chan);\n\t\tath9k_hw_set_radar_params(ah);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ath9k_hw_reset);\n\n \n \n \n\n \nstatic void ath9k_set_power_sleep(struct ath_hw *ah)\n{\n\tREG_SET_BIT(ah, AR_STA_ID1, AR_STA_ID1_PWR_SAV);\n\n\tif (AR_SREV_9462(ah) || AR_SREV_9565(ah)) {\n\t\tREG_CLR_BIT(ah, AR_TIMER_MODE, 0xff);\n\t\tREG_CLR_BIT(ah, AR_NDP2_TIMER_MODE, 0xff);\n\t\tREG_CLR_BIT(ah, AR_SLP32_INC, 0xfffff);\n\t\t \n\t\tREG_WRITE(ah, AR_MCI_INTERRUPT_RX_MSG_EN, 0);\n\t\tudelay(100);\n\t}\n\n\t \n\tREG_CLR_BIT(ah, AR_RTC_FORCE_WAKE(ah), AR_RTC_FORCE_WAKE_EN);\n\n\tif (ath9k_hw_mci_is_enabled(ah))\n\t\tudelay(100);\n\n\tif (!AR_SREV_9100(ah) && !AR_SREV_9300_20_OR_LATER(ah))\n\t\tREG_WRITE(ah, AR_RC, AR_RC_AHB | AR_RC_HOSTIF);\n\n\t \n\tif (!AR_SREV_5416(ah) && !AR_SREV_9271(ah)) {\n\t\tREG_CLR_BIT(ah, AR_RTC_RESET(ah), AR_RTC_RESET_EN);\n\t\tudelay(2);\n\t}\n\n\t \n\tif (AR_SREV_9300_20_OR_LATER(ah))\n\t\tREG_WRITE(ah, AR_WA(ah), ah->WARegVal & ~AR_WA_D3_L1_DISABLE);\n}\n\n \nstatic void ath9k_set_power_network_sleep(struct ath_hw *ah)\n{\n\tstruct ath9k_hw_capabilities *pCap = &ah->caps;\n\n\tREG_SET_BIT(ah, AR_STA_ID1, AR_STA_ID1_PWR_SAV);\n\n\tif (!(pCap->hw_caps & ATH9K_HW_CAP_AUTOSLEEP)) {\n\t\t \n\t\tREG_WRITE(ah, AR_RTC_FORCE_WAKE(ah),\n\t\t\t  AR_RTC_FORCE_WAKE_ON_INT);\n\t} else {\n\n\t\t \n\t\tif (ath9k_hw_mci_is_enabled(ah))\n\t\t\tREG_CLR_BIT(ah, AR_MCI_INTERRUPT_RX_MSG_EN,\n\t\t\t\t    AR_MCI_INTERRUPT_RX_HW_MSG_MASK);\n\t\t \n\t\tREG_CLR_BIT(ah, AR_RTC_FORCE_WAKE(ah), AR_RTC_FORCE_WAKE_EN);\n\n\t\tif (ath9k_hw_mci_is_enabled(ah))\n\t\t\tudelay(30);\n\t}\n\n\t \n\tif (AR_SREV_9300_20_OR_LATER(ah))\n\t\tREG_WRITE(ah, AR_WA(ah), ah->WARegVal & ~AR_WA_D3_L1_DISABLE);\n}\n\nstatic bool ath9k_hw_set_power_awake(struct ath_hw *ah)\n{\n\tu32 val;\n\tint i;\n\n\t \n\tif (AR_SREV_9300_20_OR_LATER(ah)) {\n\t\tREG_WRITE(ah, AR_WA(ah), ah->WARegVal);\n\t\tudelay(10);\n\t}\n\n\tif ((REG_READ(ah, AR_RTC_STATUS(ah)) &\n\t     AR_RTC_STATUS_M(ah)) == AR_RTC_STATUS_SHUTDOWN) {\n\t\tif (!ath9k_hw_set_reset_reg(ah, ATH9K_RESET_POWER_ON)) {\n\t\t\treturn false;\n\t\t}\n\t\tif (!AR_SREV_9300_20_OR_LATER(ah))\n\t\t\tath9k_hw_init_pll(ah, NULL);\n\t}\n\tif (AR_SREV_9100(ah))\n\t\tREG_SET_BIT(ah, AR_RTC_RESET(ah),\n\t\t\t    AR_RTC_RESET_EN);\n\n\tREG_SET_BIT(ah, AR_RTC_FORCE_WAKE(ah),\n\t\t    AR_RTC_FORCE_WAKE_EN);\n\tif (AR_SREV_9100(ah))\n\t\tmdelay(10);\n\telse\n\t\tudelay(50);\n\n\tfor (i = POWER_UP_TIME / 50; i > 0; i--) {\n\t\tval = REG_READ(ah, AR_RTC_STATUS(ah)) & AR_RTC_STATUS_M(ah);\n\t\tif (val == AR_RTC_STATUS_ON)\n\t\t\tbreak;\n\t\tudelay(50);\n\t\tREG_SET_BIT(ah, AR_RTC_FORCE_WAKE(ah),\n\t\t\t    AR_RTC_FORCE_WAKE_EN);\n\t}\n\tif (i == 0) {\n\t\tath_err(ath9k_hw_common(ah),\n\t\t\t\"Failed to wakeup in %uus\\n\",\n\t\t\tPOWER_UP_TIME / 20);\n\t\treturn false;\n\t}\n\n\tif (ath9k_hw_mci_is_enabled(ah))\n\t\tar9003_mci_set_power_awake(ah);\n\n\tREG_CLR_BIT(ah, AR_STA_ID1, AR_STA_ID1_PWR_SAV);\n\n\treturn true;\n}\n\nbool ath9k_hw_setpower(struct ath_hw *ah, enum ath9k_power_mode mode)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tint status = true;\n\tstatic const char *modes[] = {\n\t\t\"AWAKE\",\n\t\t\"FULL-SLEEP\",\n\t\t\"NETWORK SLEEP\",\n\t\t\"UNDEFINED\"\n\t};\n\n\tif (ah->power_mode == mode)\n\t\treturn status;\n\n\tath_dbg(common, RESET, \"%s -> %s\\n\",\n\t\tmodes[ah->power_mode], modes[mode]);\n\n\tswitch (mode) {\n\tcase ATH9K_PM_AWAKE:\n\t\tstatus = ath9k_hw_set_power_awake(ah);\n\t\tbreak;\n\tcase ATH9K_PM_FULL_SLEEP:\n\t\tif (ath9k_hw_mci_is_enabled(ah))\n\t\t\tar9003_mci_set_full_sleep(ah);\n\n\t\tath9k_set_power_sleep(ah);\n\t\tah->chip_fullsleep = true;\n\t\tbreak;\n\tcase ATH9K_PM_NETWORK_SLEEP:\n\t\tath9k_set_power_network_sleep(ah);\n\t\tbreak;\n\tdefault:\n\t\tath_err(common, \"Unknown power mode %u\\n\", mode);\n\t\treturn false;\n\t}\n\tah->power_mode = mode;\n\n\t \n\n\tif (!(ah->ah_flags & AH_UNPLUGGED))\n\t\tATH_DBG_WARN_ON_ONCE(!status);\n\n\treturn status;\n}\nEXPORT_SYMBOL(ath9k_hw_setpower);\n\n \n \n \n\nvoid ath9k_hw_beaconinit(struct ath_hw *ah, u32 next_beacon, u32 beacon_period)\n{\n\tint flags = 0;\n\n\tENABLE_REGWRITE_BUFFER(ah);\n\n\tswitch (ah->opmode) {\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tREG_SET_BIT(ah, AR_TXCFG,\n\t\t\t    AR_TXCFG_ADHOC_BEACON_ATIM_TX_POLICY);\n\t\tfallthrough;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\tcase NL80211_IFTYPE_AP:\n\t\tREG_WRITE(ah, AR_NEXT_TBTT_TIMER, next_beacon);\n\t\tREG_WRITE(ah, AR_NEXT_DMA_BEACON_ALERT, next_beacon -\n\t\t\t  TU_TO_USEC(ah->config.dma_beacon_response_time));\n\t\tREG_WRITE(ah, AR_NEXT_SWBA, next_beacon -\n\t\t\t  TU_TO_USEC(ah->config.sw_beacon_response_time));\n\t\tflags |=\n\t\t\tAR_TBTT_TIMER_EN | AR_DBA_TIMER_EN | AR_SWBA_TIMER_EN;\n\t\tbreak;\n\tdefault:\n\t\tath_dbg(ath9k_hw_common(ah), BEACON,\n\t\t\t\"%s: unsupported opmode: %d\\n\", __func__, ah->opmode);\n\t\treturn;\n\t}\n\n\tREG_WRITE(ah, AR_BEACON_PERIOD, beacon_period);\n\tREG_WRITE(ah, AR_DMA_BEACON_PERIOD, beacon_period);\n\tREG_WRITE(ah, AR_SWBA_PERIOD, beacon_period);\n\n\tREGWRITE_BUFFER_FLUSH(ah);\n\n\tREG_SET_BIT(ah, AR_TIMER_MODE, flags);\n}\nEXPORT_SYMBOL(ath9k_hw_beaconinit);\n\nvoid ath9k_hw_set_sta_beacon_timers(struct ath_hw *ah,\n\t\t\t\t    const struct ath9k_beacon_state *bs)\n{\n\tu32 nextTbtt, beaconintval, dtimperiod, beacontimeout;\n\tstruct ath9k_hw_capabilities *pCap = &ah->caps;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\n\tENABLE_REGWRITE_BUFFER(ah);\n\n\tREG_WRITE(ah, AR_NEXT_TBTT_TIMER, bs->bs_nexttbtt);\n\tREG_WRITE(ah, AR_BEACON_PERIOD, bs->bs_intval);\n\tREG_WRITE(ah, AR_DMA_BEACON_PERIOD, bs->bs_intval);\n\n\tREGWRITE_BUFFER_FLUSH(ah);\n\n\tREG_RMW_FIELD(ah, AR_RSSI_THR,\n\t\t      AR_RSSI_THR_BM_THR, bs->bs_bmissthreshold);\n\n\tbeaconintval = bs->bs_intval;\n\n\tif (bs->bs_sleepduration > beaconintval)\n\t\tbeaconintval = bs->bs_sleepduration;\n\n\tdtimperiod = bs->bs_dtimperiod;\n\tif (bs->bs_sleepduration > dtimperiod)\n\t\tdtimperiod = bs->bs_sleepduration;\n\n\tif (beaconintval == dtimperiod)\n\t\tnextTbtt = bs->bs_nextdtim;\n\telse\n\t\tnextTbtt = bs->bs_nexttbtt;\n\n\tath_dbg(common, BEACON, \"next DTIM %u\\n\", bs->bs_nextdtim);\n\tath_dbg(common, BEACON, \"next beacon %u\\n\", nextTbtt);\n\tath_dbg(common, BEACON, \"beacon period %u\\n\", beaconintval);\n\tath_dbg(common, BEACON, \"DTIM period %u\\n\", dtimperiod);\n\n\tENABLE_REGWRITE_BUFFER(ah);\n\n\tREG_WRITE(ah, AR_NEXT_DTIM, bs->bs_nextdtim - SLEEP_SLOP);\n\tREG_WRITE(ah, AR_NEXT_TIM, nextTbtt - SLEEP_SLOP);\n\n\tREG_WRITE(ah, AR_SLEEP1,\n\t\t  SM((CAB_TIMEOUT_VAL << 3), AR_SLEEP1_CAB_TIMEOUT)\n\t\t  | AR_SLEEP1_ASSUME_DTIM);\n\n\tif (pCap->hw_caps & ATH9K_HW_CAP_AUTOSLEEP)\n\t\tbeacontimeout = (BEACON_TIMEOUT_VAL << 3);\n\telse\n\t\tbeacontimeout = MIN_BEACON_TIMEOUT_VAL;\n\n\tREG_WRITE(ah, AR_SLEEP2,\n\t\t  SM(beacontimeout, AR_SLEEP2_BEACON_TIMEOUT));\n\n\tREG_WRITE(ah, AR_TIM_PERIOD, beaconintval);\n\tREG_WRITE(ah, AR_DTIM_PERIOD, dtimperiod);\n\n\tREGWRITE_BUFFER_FLUSH(ah);\n\n\tREG_SET_BIT(ah, AR_TIMER_MODE,\n\t\t    AR_TBTT_TIMER_EN | AR_TIM_TIMER_EN |\n\t\t    AR_DTIM_TIMER_EN);\n\n\t \n\tREG_WRITE(ah, AR_TSFOOR_THRESHOLD, bs->bs_tsfoor_threshold);\n}\nEXPORT_SYMBOL(ath9k_hw_set_sta_beacon_timers);\n\n \n \n \n\nstatic u8 fixup_chainmask(u8 chip_chainmask, u8 eeprom_chainmask)\n{\n\teeprom_chainmask &= chip_chainmask;\n\tif (eeprom_chainmask)\n\t\treturn eeprom_chainmask;\n\telse\n\t\treturn chip_chainmask;\n}\n\n \nstatic bool ath9k_hw_dfs_tested(struct ath_hw *ah)\n{\n\n\tswitch (ah->hw_version.macVersion) {\n\t \n\tcase AR_SREV_VERSION_9280:\n\t \n\tcase AR_SREV_VERSION_9580:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic void ath9k_gpio_cap_init(struct ath_hw *ah)\n{\n\tstruct ath9k_hw_capabilities *pCap = &ah->caps;\n\n\tif (AR_SREV_9271(ah)) {\n\t\tpCap->num_gpio_pins = AR9271_NUM_GPIO;\n\t\tpCap->gpio_mask = AR9271_GPIO_MASK;\n\t} else if (AR_DEVID_7010(ah)) {\n\t\tpCap->num_gpio_pins = AR7010_NUM_GPIO;\n\t\tpCap->gpio_mask = AR7010_GPIO_MASK;\n\t} else if (AR_SREV_9287(ah)) {\n\t\tpCap->num_gpio_pins = AR9287_NUM_GPIO;\n\t\tpCap->gpio_mask = AR9287_GPIO_MASK;\n\t} else if (AR_SREV_9285(ah)) {\n\t\tpCap->num_gpio_pins = AR9285_NUM_GPIO;\n\t\tpCap->gpio_mask = AR9285_GPIO_MASK;\n\t} else if (AR_SREV_9280(ah)) {\n\t\tpCap->num_gpio_pins = AR9280_NUM_GPIO;\n\t\tpCap->gpio_mask = AR9280_GPIO_MASK;\n\t} else if (AR_SREV_9300(ah)) {\n\t\tpCap->num_gpio_pins = AR9300_NUM_GPIO;\n\t\tpCap->gpio_mask = AR9300_GPIO_MASK;\n\t} else if (AR_SREV_9330(ah)) {\n\t\tpCap->num_gpio_pins = AR9330_NUM_GPIO;\n\t\tpCap->gpio_mask = AR9330_GPIO_MASK;\n\t} else if (AR_SREV_9340(ah)) {\n\t\tpCap->num_gpio_pins = AR9340_NUM_GPIO;\n\t\tpCap->gpio_mask = AR9340_GPIO_MASK;\n\t} else if (AR_SREV_9462(ah)) {\n\t\tpCap->num_gpio_pins = AR9462_NUM_GPIO;\n\t\tpCap->gpio_mask = AR9462_GPIO_MASK;\n\t} else if (AR_SREV_9485(ah)) {\n\t\tpCap->num_gpio_pins = AR9485_NUM_GPIO;\n\t\tpCap->gpio_mask = AR9485_GPIO_MASK;\n\t} else if (AR_SREV_9531(ah)) {\n\t\tpCap->num_gpio_pins = AR9531_NUM_GPIO;\n\t\tpCap->gpio_mask = AR9531_GPIO_MASK;\n\t} else if (AR_SREV_9550(ah)) {\n\t\tpCap->num_gpio_pins = AR9550_NUM_GPIO;\n\t\tpCap->gpio_mask = AR9550_GPIO_MASK;\n\t} else if (AR_SREV_9561(ah)) {\n\t\tpCap->num_gpio_pins = AR9561_NUM_GPIO;\n\t\tpCap->gpio_mask = AR9561_GPIO_MASK;\n\t} else if (AR_SREV_9565(ah)) {\n\t\tpCap->num_gpio_pins = AR9565_NUM_GPIO;\n\t\tpCap->gpio_mask = AR9565_GPIO_MASK;\n\t} else if (AR_SREV_9580(ah)) {\n\t\tpCap->num_gpio_pins = AR9580_NUM_GPIO;\n\t\tpCap->gpio_mask = AR9580_GPIO_MASK;\n\t} else {\n\t\tpCap->num_gpio_pins = AR_NUM_GPIO;\n\t\tpCap->gpio_mask = AR_GPIO_MASK;\n\t}\n}\n\nint ath9k_hw_fill_cap_info(struct ath_hw *ah)\n{\n\tstruct ath9k_hw_capabilities *pCap = &ah->caps;\n\tstruct ath_regulatory *regulatory = ath9k_hw_regulatory(ah);\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\n\tu16 eeval;\n\tu8 ant_div_ctl1, tx_chainmask, rx_chainmask;\n\n\teeval = ah->eep_ops->get_eeprom(ah, EEP_REG_0);\n\tregulatory->current_rd = eeval;\n\n\tif (ah->opmode != NL80211_IFTYPE_AP &&\n\t    ah->hw_version.subvendorid == AR_SUBVENDOR_ID_NEW_A) {\n\t\tif (regulatory->current_rd == 0x64 ||\n\t\t    regulatory->current_rd == 0x65)\n\t\t\tregulatory->current_rd += 5;\n\t\telse if (regulatory->current_rd == 0x41)\n\t\t\tregulatory->current_rd = 0x43;\n\t\tath_dbg(common, REGULATORY, \"regdomain mapped to 0x%x\\n\",\n\t\t\tregulatory->current_rd);\n\t}\n\n\teeval = ah->eep_ops->get_eeprom(ah, EEP_OP_MODE);\n\n\tif (eeval & AR5416_OPFLAGS_11A) {\n\t\tif (ah->disable_5ghz)\n\t\t\tath_warn(common, \"disabling 5GHz band\\n\");\n\t\telse\n\t\t\tpCap->hw_caps |= ATH9K_HW_CAP_5GHZ;\n\t}\n\n\tif (eeval & AR5416_OPFLAGS_11G) {\n\t\tif (ah->disable_2ghz)\n\t\t\tath_warn(common, \"disabling 2GHz band\\n\");\n\t\telse\n\t\t\tpCap->hw_caps |= ATH9K_HW_CAP_2GHZ;\n\t}\n\n\tif ((pCap->hw_caps & (ATH9K_HW_CAP_2GHZ | ATH9K_HW_CAP_5GHZ)) == 0) {\n\t\tath_err(common, \"both bands are disabled\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tath9k_gpio_cap_init(ah);\n\n\tif (AR_SREV_9485(ah) ||\n\t    AR_SREV_9285(ah) ||\n\t    AR_SREV_9330(ah) ||\n\t    AR_SREV_9565(ah))\n\t\tpCap->chip_chainmask = 1;\n\telse if (!AR_SREV_9280_20_OR_LATER(ah))\n\t\tpCap->chip_chainmask = 7;\n\telse if (!AR_SREV_9300_20_OR_LATER(ah) ||\n\t\t AR_SREV_9340(ah) ||\n\t\t AR_SREV_9462(ah) ||\n\t\t AR_SREV_9531(ah))\n\t\tpCap->chip_chainmask = 3;\n\telse\n\t\tpCap->chip_chainmask = 7;\n\n\tpCap->tx_chainmask = ah->eep_ops->get_eeprom(ah, EEP_TX_MASK);\n\t \n\tif ((ah->hw_version.devid == AR5416_DEVID_PCI) &&\n\t    !(eeval & AR5416_OPFLAGS_11A) &&\n\t    !(AR_SREV_9271(ah)))\n\t\t \n\t\tpCap->rx_chainmask = ath9k_hw_gpio_get(ah, 0) ? 0x5 : 0x7;\n\telse if (AR_SREV_9100(ah))\n\t\tpCap->rx_chainmask = 0x7;\n\telse\n\t\t \n\t\tpCap->rx_chainmask = ah->eep_ops->get_eeprom(ah, EEP_RX_MASK);\n\n\tpCap->tx_chainmask = fixup_chainmask(pCap->chip_chainmask, pCap->tx_chainmask);\n\tpCap->rx_chainmask = fixup_chainmask(pCap->chip_chainmask, pCap->rx_chainmask);\n\tah->txchainmask = pCap->tx_chainmask;\n\tah->rxchainmask = pCap->rx_chainmask;\n\n\tah->misc_mode |= AR_PCU_MIC_NEW_LOC_ENA;\n\n\t \n\tif (AR_SREV_9300_20_OR_LATER(ah))\n\t\tah->misc_mode |= AR_PCU_ALWAYS_PERFORM_KEYSEARCH;\n\n\tcommon->crypt_caps |= ATH_CRYPT_CAP_CIPHER_AESCCM;\n\n\tif (ah->hw_version.devid != AR2427_DEVID_PCIE)\n\t\tpCap->hw_caps |= ATH9K_HW_CAP_HT;\n\telse\n\t\tpCap->hw_caps &= ~ATH9K_HW_CAP_HT;\n\n\tif (AR_SREV_9160_10_OR_LATER(ah) || AR_SREV_9100(ah))\n\t\tpCap->rts_aggr_limit = ATH_AMPDU_LIMIT_MAX;\n\telse\n\t\tpCap->rts_aggr_limit = (8 * 1024);\n\n#ifdef CONFIG_ATH9K_RFKILL\n\tah->rfsilent = ah->eep_ops->get_eeprom(ah, EEP_RF_SILENT);\n\tif (ah->rfsilent & EEP_RFSILENT_ENABLED) {\n\t\tah->rfkill_gpio =\n\t\t\tMS(ah->rfsilent, EEP_RFSILENT_GPIO_SEL);\n\t\tah->rfkill_polarity =\n\t\t\tMS(ah->rfsilent, EEP_RFSILENT_POLARITY);\n\n\t\tpCap->hw_caps |= ATH9K_HW_CAP_RFSILENT;\n\t}\n#endif\n\tif (AR_SREV_9271(ah) || AR_SREV_9300_20_OR_LATER(ah))\n\t\tpCap->hw_caps |= ATH9K_HW_CAP_AUTOSLEEP;\n\telse\n\t\tpCap->hw_caps &= ~ATH9K_HW_CAP_AUTOSLEEP;\n\n\tif (AR_SREV_9280(ah) || AR_SREV_9285(ah))\n\t\tpCap->hw_caps &= ~ATH9K_HW_CAP_4KB_SPLITTRANS;\n\telse\n\t\tpCap->hw_caps |= ATH9K_HW_CAP_4KB_SPLITTRANS;\n\n\tif (AR_SREV_9300_20_OR_LATER(ah)) {\n\t\tpCap->hw_caps |= ATH9K_HW_CAP_EDMA | ATH9K_HW_CAP_FASTCLOCK;\n\t\tif (!AR_SREV_9330(ah) && !AR_SREV_9485(ah) &&\n\t\t    !AR_SREV_9561(ah) && !AR_SREV_9565(ah))\n\t\t\tpCap->hw_caps |= ATH9K_HW_CAP_LDPC;\n\n\t\tpCap->rx_hp_qdepth = ATH9K_HW_RX_HP_QDEPTH;\n\t\tpCap->rx_lp_qdepth = ATH9K_HW_RX_LP_QDEPTH;\n\t\tpCap->rx_status_len = sizeof(struct ar9003_rxs);\n\t\tpCap->tx_desc_len = sizeof(struct ar9003_txc);\n\t\tpCap->txs_len = sizeof(struct ar9003_txs);\n\t} else {\n\t\tpCap->tx_desc_len = sizeof(struct ath_desc);\n\t\tif (AR_SREV_9280_20(ah))\n\t\t\tpCap->hw_caps |= ATH9K_HW_CAP_FASTCLOCK;\n\t}\n\n\tif (AR_SREV_9300_20_OR_LATER(ah))\n\t\tpCap->hw_caps |= ATH9K_HW_CAP_RAC_SUPPORTED;\n\n\tif (AR_SREV_9561(ah))\n\t\tah->ent_mode = 0x3BDA000;\n\telse if (AR_SREV_9300_20_OR_LATER(ah))\n\t\tah->ent_mode = REG_READ(ah, AR_ENT_OTP);\n\n\tif (AR_SREV_9287_11_OR_LATER(ah) || AR_SREV_9271(ah))\n\t\tpCap->hw_caps |= ATH9K_HW_CAP_SGI_20;\n\n\tif (AR_SREV_9285(ah)) {\n\t\tif (ah->eep_ops->get_eeprom(ah, EEP_MODAL_VER) >= 3) {\n\t\t\tant_div_ctl1 =\n\t\t\t\tah->eep_ops->get_eeprom(ah, EEP_ANT_DIV_CTL1);\n\t\t\tif ((ant_div_ctl1 & 0x1) && ((ant_div_ctl1 >> 3) & 0x1)) {\n\t\t\t\tpCap->hw_caps |= ATH9K_HW_CAP_ANT_DIV_COMB;\n\t\t\t\tath_info(common, \"Enable LNA combining\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\tif (AR_SREV_9300_20_OR_LATER(ah)) {\n\t\tif (ah->eep_ops->get_eeprom(ah, EEP_CHAIN_MASK_REDUCE))\n\t\t\tpCap->hw_caps |= ATH9K_HW_CAP_APM;\n\t}\n\n\tif (AR_SREV_9330(ah) || AR_SREV_9485(ah) || AR_SREV_9565(ah)) {\n\t\tant_div_ctl1 = ah->eep_ops->get_eeprom(ah, EEP_ANT_DIV_CTL1);\n\t\tif ((ant_div_ctl1 >> 0x6) == 0x3) {\n\t\t\tpCap->hw_caps |= ATH9K_HW_CAP_ANT_DIV_COMB;\n\t\t\tath_info(common, \"Enable LNA combining\\n\");\n\t\t}\n\t}\n\n\tif (ath9k_hw_dfs_tested(ah))\n\t\tpCap->hw_caps |= ATH9K_HW_CAP_DFS;\n\n\ttx_chainmask = pCap->tx_chainmask;\n\trx_chainmask = pCap->rx_chainmask;\n\twhile (tx_chainmask || rx_chainmask) {\n\t\tif (tx_chainmask & BIT(0))\n\t\t\tpCap->max_txchains++;\n\t\tif (rx_chainmask & BIT(0))\n\t\t\tpCap->max_rxchains++;\n\n\t\ttx_chainmask >>= 1;\n\t\trx_chainmask >>= 1;\n\t}\n\n\tif (AR_SREV_9462(ah) || AR_SREV_9565(ah)) {\n\t\tif (!(ah->ent_mode & AR_ENT_OTP_49GHZ_DISABLE))\n\t\t\tpCap->hw_caps |= ATH9K_HW_CAP_MCI;\n\n\t\tif (AR_SREV_9462_20_OR_LATER(ah))\n\t\t\tpCap->hw_caps |= ATH9K_HW_CAP_RTT;\n\t}\n\n\tif (AR_SREV_9300_20_OR_LATER(ah) &&\n\t    ah->eep_ops->get_eeprom(ah, EEP_PAPRD))\n\t\t\tpCap->hw_caps |= ATH9K_HW_CAP_PAPRD;\n\n#ifdef CONFIG_ATH9K_WOW\n\tif (AR_SREV_9462_20_OR_LATER(ah) || AR_SREV_9565_11_OR_LATER(ah))\n\t\tah->wow.max_patterns = MAX_NUM_PATTERN;\n\telse\n\t\tah->wow.max_patterns = MAX_NUM_PATTERN_LEGACY;\n#endif\n\n\treturn 0;\n}\n\n \n \n \n\nstatic void ath9k_hw_gpio_cfg_output_mux(struct ath_hw *ah, u32 gpio, u32 type)\n{\n\tint addr;\n\tu32 gpio_shift, tmp;\n\n\tif (gpio > 11)\n\t\taddr = AR_GPIO_OUTPUT_MUX3(ah);\n\telse if (gpio > 5)\n\t\taddr = AR_GPIO_OUTPUT_MUX2(ah);\n\telse\n\t\taddr = AR_GPIO_OUTPUT_MUX1(ah);\n\n\tgpio_shift = (gpio % 6) * 5;\n\n\tif (AR_SREV_9280_20_OR_LATER(ah) ||\n\t    (addr != AR_GPIO_OUTPUT_MUX1(ah))) {\n\t\tREG_RMW(ah, addr, (type << gpio_shift),\n\t\t\t(0x1f << gpio_shift));\n\t} else {\n\t\ttmp = REG_READ(ah, addr);\n\t\ttmp = ((tmp & 0x1F0) << 1) | (tmp & ~0x1F0);\n\t\ttmp &= ~(0x1f << gpio_shift);\n\t\ttmp |= (type << gpio_shift);\n\t\tREG_WRITE(ah, addr, tmp);\n\t}\n}\n\n \nstatic void ath9k_hw_gpio_cfg_soc(struct ath_hw *ah, u32 gpio, bool out,\n\t\t\t\t  const char *label)\n{\n\tint err;\n\n\tif (ah->caps.gpio_requested & BIT(gpio))\n\t\treturn;\n\n\terr = gpio_request_one(gpio, out ? GPIOF_OUT_INIT_LOW : GPIOF_IN, label);\n\tif (err) {\n\t\tath_err(ath9k_hw_common(ah), \"request GPIO%d failed:%d\\n\",\n\t\t\tgpio, err);\n\t\treturn;\n\t}\n\n\tah->caps.gpio_requested |= BIT(gpio);\n}\n\nstatic void ath9k_hw_gpio_cfg_wmac(struct ath_hw *ah, u32 gpio, bool out,\n\t\t\t\t   u32 ah_signal_type)\n{\n\tu32 gpio_set, gpio_shift = gpio;\n\n\tif (AR_DEVID_7010(ah)) {\n\t\tgpio_set = out ?\n\t\t\tAR7010_GPIO_OE_AS_OUTPUT : AR7010_GPIO_OE_AS_INPUT;\n\t\tREG_RMW(ah, AR7010_GPIO_OE, gpio_set << gpio_shift,\n\t\t\tAR7010_GPIO_OE_MASK << gpio_shift);\n\t} else if (AR_SREV_SOC(ah)) {\n\t\tgpio_set = out ? 1 : 0;\n\t\tREG_RMW(ah, AR_GPIO_OE_OUT(ah), gpio_set << gpio_shift,\n\t\t\tgpio_set << gpio_shift);\n\t} else {\n\t\tgpio_shift = gpio << 1;\n\t\tgpio_set = out ?\n\t\t\tAR_GPIO_OE_OUT_DRV_ALL : AR_GPIO_OE_OUT_DRV_NO;\n\t\tREG_RMW(ah, AR_GPIO_OE_OUT(ah), gpio_set << gpio_shift,\n\t\t\tAR_GPIO_OE_OUT_DRV << gpio_shift);\n\n\t\tif (out)\n\t\t\tath9k_hw_gpio_cfg_output_mux(ah, gpio, ah_signal_type);\n\t}\n}\n\nstatic void ath9k_hw_gpio_request(struct ath_hw *ah, u32 gpio, bool out,\n\t\t\t\t  const char *label, u32 ah_signal_type)\n{\n\tWARN_ON(gpio >= ah->caps.num_gpio_pins);\n\n\tif (BIT(gpio) & ah->caps.gpio_mask)\n\t\tath9k_hw_gpio_cfg_wmac(ah, gpio, out, ah_signal_type);\n\telse if (AR_SREV_SOC(ah))\n\t\tath9k_hw_gpio_cfg_soc(ah, gpio, out, label);\n\telse\n\t\tWARN_ON(1);\n}\n\nvoid ath9k_hw_gpio_request_in(struct ath_hw *ah, u32 gpio, const char *label)\n{\n\tath9k_hw_gpio_request(ah, gpio, false, label, 0);\n}\nEXPORT_SYMBOL(ath9k_hw_gpio_request_in);\n\nvoid ath9k_hw_gpio_request_out(struct ath_hw *ah, u32 gpio, const char *label,\n\t\t\t       u32 ah_signal_type)\n{\n\tath9k_hw_gpio_request(ah, gpio, true, label, ah_signal_type);\n}\nEXPORT_SYMBOL(ath9k_hw_gpio_request_out);\n\nvoid ath9k_hw_gpio_free(struct ath_hw *ah, u32 gpio)\n{\n\tif (!AR_SREV_SOC(ah))\n\t\treturn;\n\n\tWARN_ON(gpio >= ah->caps.num_gpio_pins);\n\n\tif (ah->caps.gpio_requested & BIT(gpio)) {\n\t\tgpio_free(gpio);\n\t\tah->caps.gpio_requested &= ~BIT(gpio);\n\t}\n}\nEXPORT_SYMBOL(ath9k_hw_gpio_free);\n\nu32 ath9k_hw_gpio_get(struct ath_hw *ah, u32 gpio)\n{\n\tu32 val = 0xffffffff;\n\n#define MS_REG_READ(x, y) \\\n\t(MS(REG_READ(ah, AR_GPIO_IN_OUT(ah)), x##_GPIO_IN_VAL) & BIT(y))\n\n\tWARN_ON(gpio >= ah->caps.num_gpio_pins);\n\n\tif (BIT(gpio) & ah->caps.gpio_mask) {\n\t\tif (AR_SREV_9271(ah))\n\t\t\tval = MS_REG_READ(AR9271, gpio);\n\t\telse if (AR_SREV_9287(ah))\n\t\t\tval = MS_REG_READ(AR9287, gpio);\n\t\telse if (AR_SREV_9285(ah))\n\t\t\tval = MS_REG_READ(AR9285, gpio);\n\t\telse if (AR_SREV_9280(ah))\n\t\t\tval = MS_REG_READ(AR928X, gpio);\n\t\telse if (AR_DEVID_7010(ah))\n\t\t\tval = REG_READ(ah, AR7010_GPIO_IN) & BIT(gpio);\n\t\telse if (AR_SREV_9300_20_OR_LATER(ah))\n\t\t\tval = REG_READ(ah, AR_GPIO_IN(ah)) & BIT(gpio);\n\t\telse\n\t\t\tval = MS_REG_READ(AR, gpio);\n\t} else if (BIT(gpio) & ah->caps.gpio_requested) {\n\t\tval = gpio_get_value(gpio) & BIT(gpio);\n\t} else {\n\t\tWARN_ON(1);\n\t}\n\n\treturn !!val;\n}\nEXPORT_SYMBOL(ath9k_hw_gpio_get);\n\nvoid ath9k_hw_set_gpio(struct ath_hw *ah, u32 gpio, u32 val)\n{\n\tWARN_ON(gpio >= ah->caps.num_gpio_pins);\n\n\tif (AR_DEVID_7010(ah) || AR_SREV_9271(ah))\n\t\tval = !val;\n\telse\n\t\tval = !!val;\n\n\tif (BIT(gpio) & ah->caps.gpio_mask) {\n\t\tu32 out_addr = AR_DEVID_7010(ah) ?\n\t\t\tAR7010_GPIO_OUT : AR_GPIO_IN_OUT(ah);\n\n\t\tREG_RMW(ah, out_addr, val << gpio, BIT(gpio));\n\t} else if (BIT(gpio) & ah->caps.gpio_requested) {\n\t\tgpio_set_value(gpio, val);\n\t} else {\n\t\tWARN_ON(1);\n\t}\n}\nEXPORT_SYMBOL(ath9k_hw_set_gpio);\n\nvoid ath9k_hw_setantenna(struct ath_hw *ah, u32 antenna)\n{\n\tREG_WRITE(ah, AR_DEF_ANTENNA, (antenna & 0x7));\n}\nEXPORT_SYMBOL(ath9k_hw_setantenna);\n\n \n \n \n\nu32 ath9k_hw_getrxfilter(struct ath_hw *ah)\n{\n\tu32 bits = REG_READ(ah, AR_RX_FILTER);\n\tu32 phybits = REG_READ(ah, AR_PHY_ERR);\n\n\tif (phybits & AR_PHY_ERR_RADAR)\n\t\tbits |= ATH9K_RX_FILTER_PHYRADAR;\n\tif (phybits & (AR_PHY_ERR_OFDM_TIMING | AR_PHY_ERR_CCK_TIMING))\n\t\tbits |= ATH9K_RX_FILTER_PHYERR;\n\n\treturn bits;\n}\nEXPORT_SYMBOL(ath9k_hw_getrxfilter);\n\nvoid ath9k_hw_setrxfilter(struct ath_hw *ah, u32 bits)\n{\n\tu32 phybits;\n\n\tENABLE_REGWRITE_BUFFER(ah);\n\n\tREG_WRITE(ah, AR_RX_FILTER, bits);\n\n\tphybits = 0;\n\tif (bits & ATH9K_RX_FILTER_PHYRADAR)\n\t\tphybits |= AR_PHY_ERR_RADAR;\n\tif (bits & ATH9K_RX_FILTER_PHYERR)\n\t\tphybits |= AR_PHY_ERR_OFDM_TIMING | AR_PHY_ERR_CCK_TIMING;\n\tREG_WRITE(ah, AR_PHY_ERR, phybits);\n\n\tif (phybits)\n\t\tREG_SET_BIT(ah, AR_RXCFG, AR_RXCFG_ZLFDMA);\n\telse\n\t\tREG_CLR_BIT(ah, AR_RXCFG, AR_RXCFG_ZLFDMA);\n\n\tREGWRITE_BUFFER_FLUSH(ah);\n}\nEXPORT_SYMBOL(ath9k_hw_setrxfilter);\n\nbool ath9k_hw_phy_disable(struct ath_hw *ah)\n{\n\tif (ath9k_hw_mci_is_enabled(ah))\n\t\tar9003_mci_bt_gain_ctrl(ah);\n\n\tif (!ath9k_hw_set_reset_reg(ah, ATH9K_RESET_WARM))\n\t\treturn false;\n\n\tath9k_hw_init_pll(ah, NULL);\n\tah->htc_reset_init = true;\n\treturn true;\n}\nEXPORT_SYMBOL(ath9k_hw_phy_disable);\n\nbool ath9k_hw_disable(struct ath_hw *ah)\n{\n\tif (!ath9k_hw_setpower(ah, ATH9K_PM_AWAKE))\n\t\treturn false;\n\n\tif (!ath9k_hw_set_reset_reg(ah, ATH9K_RESET_COLD))\n\t\treturn false;\n\n\tath9k_hw_init_pll(ah, NULL);\n\treturn true;\n}\nEXPORT_SYMBOL(ath9k_hw_disable);\n\nstatic int get_antenna_gain(struct ath_hw *ah, struct ath9k_channel *chan)\n{\n\tenum eeprom_param gain_param;\n\n\tif (IS_CHAN_2GHZ(chan))\n\t\tgain_param = EEP_ANTENNA_GAIN_2G;\n\telse\n\t\tgain_param = EEP_ANTENNA_GAIN_5G;\n\n\treturn ah->eep_ops->get_eeprom(ah, gain_param);\n}\n\nvoid ath9k_hw_apply_txpower(struct ath_hw *ah, struct ath9k_channel *chan,\n\t\t\t    bool test)\n{\n\tstruct ath_regulatory *reg = ath9k_hw_regulatory(ah);\n\tstruct ieee80211_channel *channel;\n\tint chan_pwr, new_pwr;\n\tu16 ctl = NO_CTL;\n\n\tif (!chan)\n\t\treturn;\n\n\tif (!test)\n\t\tctl = ath9k_regd_get_ctl(reg, chan);\n\n\tchannel = chan->chan;\n\tchan_pwr = min_t(int, channel->max_power * 2, MAX_COMBINED_POWER);\n\tnew_pwr = min_t(int, chan_pwr, reg->power_limit);\n\n\tah->eep_ops->set_txpower(ah, chan, ctl,\n\t\t\t\t get_antenna_gain(ah, chan), new_pwr, test);\n}\n\nvoid ath9k_hw_set_txpowerlimit(struct ath_hw *ah, u32 limit, bool test)\n{\n\tstruct ath_regulatory *reg = ath9k_hw_regulatory(ah);\n\tstruct ath9k_channel *chan = ah->curchan;\n\tstruct ieee80211_channel *channel = chan->chan;\n\n\treg->power_limit = min_t(u32, limit, MAX_COMBINED_POWER);\n\tif (test)\n\t\tchannel->max_power = MAX_COMBINED_POWER / 2;\n\n\tath9k_hw_apply_txpower(ah, chan, test);\n\n\tif (test)\n\t\tchannel->max_power = DIV_ROUND_UP(reg->max_power_level, 2);\n}\nEXPORT_SYMBOL(ath9k_hw_set_txpowerlimit);\n\nvoid ath9k_hw_setopmode(struct ath_hw *ah)\n{\n\tath9k_hw_set_operating_mode(ah, ah->opmode);\n}\nEXPORT_SYMBOL(ath9k_hw_setopmode);\n\nvoid ath9k_hw_setmcastfilter(struct ath_hw *ah, u32 filter0, u32 filter1)\n{\n\tREG_WRITE(ah, AR_MCAST_FIL0, filter0);\n\tREG_WRITE(ah, AR_MCAST_FIL1, filter1);\n}\nEXPORT_SYMBOL(ath9k_hw_setmcastfilter);\n\nvoid ath9k_hw_write_associd(struct ath_hw *ah)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\n\tREG_WRITE(ah, AR_BSS_ID0, get_unaligned_le32(common->curbssid));\n\tREG_WRITE(ah, AR_BSS_ID1, get_unaligned_le16(common->curbssid + 4) |\n\t\t  ((common->curaid & 0x3fff) << AR_BSS_ID1_AID_S));\n}\nEXPORT_SYMBOL(ath9k_hw_write_associd);\n\n#define ATH9K_MAX_TSF_READ 10\n\nu64 ath9k_hw_gettsf64(struct ath_hw *ah)\n{\n\tu32 tsf_lower, tsf_upper1, tsf_upper2;\n\tint i;\n\n\ttsf_upper1 = REG_READ(ah, AR_TSF_U32);\n\tfor (i = 0; i < ATH9K_MAX_TSF_READ; i++) {\n\t\ttsf_lower = REG_READ(ah, AR_TSF_L32);\n\t\ttsf_upper2 = REG_READ(ah, AR_TSF_U32);\n\t\tif (tsf_upper2 == tsf_upper1)\n\t\t\tbreak;\n\t\ttsf_upper1 = tsf_upper2;\n\t}\n\n\tWARN_ON( i == ATH9K_MAX_TSF_READ );\n\n\treturn (((u64)tsf_upper1 << 32) | tsf_lower);\n}\nEXPORT_SYMBOL(ath9k_hw_gettsf64);\n\nvoid ath9k_hw_settsf64(struct ath_hw *ah, u64 tsf64)\n{\n\tREG_WRITE(ah, AR_TSF_L32, tsf64 & 0xffffffff);\n\tREG_WRITE(ah, AR_TSF_U32, (tsf64 >> 32) & 0xffffffff);\n}\nEXPORT_SYMBOL(ath9k_hw_settsf64);\n\nvoid ath9k_hw_reset_tsf(struct ath_hw *ah)\n{\n\tif (!ath9k_hw_wait(ah, AR_SLP32_MODE, AR_SLP32_TSF_WRITE_STATUS, 0,\n\t\t\t   AH_TSF_WRITE_TIMEOUT))\n\t\tath_dbg(ath9k_hw_common(ah), RESET,\n\t\t\t\"AR_SLP32_TSF_WRITE_STATUS limit exceeded\\n\");\n\n\tREG_WRITE(ah, AR_RESET_TSF, AR_RESET_TSF_ONCE);\n}\nEXPORT_SYMBOL(ath9k_hw_reset_tsf);\n\nvoid ath9k_hw_set_tsfadjust(struct ath_hw *ah, bool set)\n{\n\tif (set)\n\t\tah->misc_mode |= AR_PCU_TX_ADD_TSF;\n\telse\n\t\tah->misc_mode &= ~AR_PCU_TX_ADD_TSF;\n}\nEXPORT_SYMBOL(ath9k_hw_set_tsfadjust);\n\nvoid ath9k_hw_set11nmac2040(struct ath_hw *ah, struct ath9k_channel *chan)\n{\n\tu32 macmode;\n\n\tif (IS_CHAN_HT40(chan) && !ah->config.cwm_ignore_extcca)\n\t\tmacmode = AR_2040_JOINED_RX_CLEAR;\n\telse\n\t\tmacmode = 0;\n\n\tREG_WRITE(ah, AR_2040_MODE, macmode);\n}\n\n \n\nstatic const struct ath_gen_timer_configuration gen_tmr_configuration[] =\n{\n\t{AR_NEXT_NDP_TIMER, AR_NDP_PERIOD, AR_TIMER_MODE, 0x0080},\n\t{AR_NEXT_NDP_TIMER, AR_NDP_PERIOD, AR_TIMER_MODE, 0x0080},\n\t{AR_NEXT_NDP_TIMER, AR_NDP_PERIOD, AR_TIMER_MODE, 0x0080},\n\t{AR_NEXT_NDP_TIMER, AR_NDP_PERIOD, AR_TIMER_MODE, 0x0080},\n\t{AR_NEXT_NDP_TIMER, AR_NDP_PERIOD, AR_TIMER_MODE, 0x0080},\n\t{AR_NEXT_NDP_TIMER, AR_NDP_PERIOD, AR_TIMER_MODE, 0x0080},\n\t{AR_NEXT_NDP_TIMER, AR_NDP_PERIOD, AR_TIMER_MODE, 0x0080},\n\t{AR_NEXT_NDP_TIMER, AR_NDP_PERIOD, AR_TIMER_MODE, 0x0080},\n\t{AR_NEXT_NDP2_TIMER, AR_NDP2_PERIOD, AR_NDP2_TIMER_MODE, 0x0001},\n\t{AR_NEXT_NDP2_TIMER + 1*4, AR_NDP2_PERIOD + 1*4,\n\t\t\t\tAR_NDP2_TIMER_MODE, 0x0002},\n\t{AR_NEXT_NDP2_TIMER + 2*4, AR_NDP2_PERIOD + 2*4,\n\t\t\t\tAR_NDP2_TIMER_MODE, 0x0004},\n\t{AR_NEXT_NDP2_TIMER + 3*4, AR_NDP2_PERIOD + 3*4,\n\t\t\t\tAR_NDP2_TIMER_MODE, 0x0008},\n\t{AR_NEXT_NDP2_TIMER + 4*4, AR_NDP2_PERIOD + 4*4,\n\t\t\t\tAR_NDP2_TIMER_MODE, 0x0010},\n\t{AR_NEXT_NDP2_TIMER + 5*4, AR_NDP2_PERIOD + 5*4,\n\t\t\t\tAR_NDP2_TIMER_MODE, 0x0020},\n\t{AR_NEXT_NDP2_TIMER + 6*4, AR_NDP2_PERIOD + 6*4,\n\t\t\t\tAR_NDP2_TIMER_MODE, 0x0040},\n\t{AR_NEXT_NDP2_TIMER + 7*4, AR_NDP2_PERIOD + 7*4,\n\t\t\t\tAR_NDP2_TIMER_MODE, 0x0080}\n};\n\n \n\nu32 ath9k_hw_gettsf32(struct ath_hw *ah)\n{\n\treturn REG_READ(ah, AR_TSF_L32);\n}\nEXPORT_SYMBOL(ath9k_hw_gettsf32);\n\nvoid ath9k_hw_gen_timer_start_tsf2(struct ath_hw *ah)\n{\n\tstruct ath_gen_timer_table *timer_table = &ah->hw_gen_timers;\n\n\tif (timer_table->tsf2_enabled) {\n\t\tREG_SET_BIT(ah, AR_DIRECT_CONNECT, AR_DC_AP_STA_EN);\n\t\tREG_SET_BIT(ah, AR_RESET_TSF, AR_RESET_TSF2_ONCE);\n\t}\n}\n\nstruct ath_gen_timer *ath_gen_timer_alloc(struct ath_hw *ah,\n\t\t\t\t\t  void (*trigger)(void *),\n\t\t\t\t\t  void (*overflow)(void *),\n\t\t\t\t\t  void *arg,\n\t\t\t\t\t  u8 timer_index)\n{\n\tstruct ath_gen_timer_table *timer_table = &ah->hw_gen_timers;\n\tstruct ath_gen_timer *timer;\n\n\tif ((timer_index < AR_FIRST_NDP_TIMER) ||\n\t    (timer_index >= ATH_MAX_GEN_TIMER))\n\t\treturn NULL;\n\n\tif ((timer_index > AR_FIRST_NDP_TIMER) &&\n\t    !AR_SREV_9300_20_OR_LATER(ah))\n\t\treturn NULL;\n\n\ttimer = kzalloc(sizeof(struct ath_gen_timer), GFP_KERNEL);\n\tif (timer == NULL)\n\t\treturn NULL;\n\n\t \n\ttimer_table->timers[timer_index] = timer;\n\ttimer->index = timer_index;\n\ttimer->trigger = trigger;\n\ttimer->overflow = overflow;\n\ttimer->arg = arg;\n\n\tif ((timer_index > AR_FIRST_NDP_TIMER) && !timer_table->tsf2_enabled) {\n\t\ttimer_table->tsf2_enabled = true;\n\t\tath9k_hw_gen_timer_start_tsf2(ah);\n\t}\n\n\treturn timer;\n}\nEXPORT_SYMBOL(ath_gen_timer_alloc);\n\nvoid ath9k_hw_gen_timer_start(struct ath_hw *ah,\n\t\t\t      struct ath_gen_timer *timer,\n\t\t\t      u32 timer_next,\n\t\t\t      u32 timer_period)\n{\n\tstruct ath_gen_timer_table *timer_table = &ah->hw_gen_timers;\n\tu32 mask = 0;\n\n\ttimer_table->timer_mask |= BIT(timer->index);\n\n\t \n\tREG_WRITE(ah, gen_tmr_configuration[timer->index].next_addr,\n\t\t timer_next);\n\tREG_WRITE(ah, gen_tmr_configuration[timer->index].period_addr,\n\t\t  timer_period);\n\tREG_SET_BIT(ah, gen_tmr_configuration[timer->index].mode_addr,\n\t\t    gen_tmr_configuration[timer->index].mode_mask);\n\n\tif (AR_SREV_9462(ah) || AR_SREV_9565(ah)) {\n\t\t \n\t\tif ((timer->index < AR_GEN_TIMER_BANK_1_LEN))\n\t\t\tREG_CLR_BIT(ah, AR_MAC_PCU_GEN_TIMER_TSF_SEL,\n\t\t\t\t       (1 << timer->index));\n\t\telse\n\t\t\tREG_SET_BIT(ah, AR_MAC_PCU_GEN_TIMER_TSF_SEL,\n\t\t\t\t       (1 << timer->index));\n\t}\n\n\tif (timer->trigger)\n\t\tmask |= SM(AR_GENTMR_BIT(timer->index),\n\t\t\t   AR_IMR_S5_GENTIMER_TRIG);\n\tif (timer->overflow)\n\t\tmask |= SM(AR_GENTMR_BIT(timer->index),\n\t\t\t   AR_IMR_S5_GENTIMER_THRESH);\n\n\tREG_SET_BIT(ah, AR_IMR_S5, mask);\n\n\tif ((ah->imask & ATH9K_INT_GENTIMER) == 0) {\n\t\tah->imask |= ATH9K_INT_GENTIMER;\n\t\tath9k_hw_set_interrupts(ah);\n\t}\n}\nEXPORT_SYMBOL(ath9k_hw_gen_timer_start);\n\nvoid ath9k_hw_gen_timer_stop(struct ath_hw *ah, struct ath_gen_timer *timer)\n{\n\tstruct ath_gen_timer_table *timer_table = &ah->hw_gen_timers;\n\n\t \n\tREG_CLR_BIT(ah, gen_tmr_configuration[timer->index].mode_addr,\n\t\t\tgen_tmr_configuration[timer->index].mode_mask);\n\n\tif (AR_SREV_9462(ah) || AR_SREV_9565(ah)) {\n\t\t \n\t\tif ((timer->index >= AR_GEN_TIMER_BANK_1_LEN)) {\n\t\t\tREG_CLR_BIT(ah, AR_MAC_PCU_GEN_TIMER_TSF_SEL,\n\t\t\t\t    (1 << timer->index));\n\t\t}\n\t}\n\n\t \n\tREG_CLR_BIT(ah, AR_IMR_S5,\n\t\t(SM(AR_GENTMR_BIT(timer->index), AR_IMR_S5_GENTIMER_THRESH) |\n\t\tSM(AR_GENTMR_BIT(timer->index), AR_IMR_S5_GENTIMER_TRIG)));\n\n\ttimer_table->timer_mask &= ~BIT(timer->index);\n\n\tif (timer_table->timer_mask == 0) {\n\t\tah->imask &= ~ATH9K_INT_GENTIMER;\n\t\tath9k_hw_set_interrupts(ah);\n\t}\n}\nEXPORT_SYMBOL(ath9k_hw_gen_timer_stop);\n\nvoid ath_gen_timer_free(struct ath_hw *ah, struct ath_gen_timer *timer)\n{\n\tstruct ath_gen_timer_table *timer_table = &ah->hw_gen_timers;\n\n\t \n\ttimer_table->timers[timer->index] = NULL;\n\tkfree(timer);\n}\nEXPORT_SYMBOL(ath_gen_timer_free);\n\n \nvoid ath_gen_timer_isr(struct ath_hw *ah)\n{\n\tstruct ath_gen_timer_table *timer_table = &ah->hw_gen_timers;\n\tstruct ath_gen_timer *timer;\n\tunsigned long trigger_mask, thresh_mask;\n\tunsigned int index;\n\n\t \n\ttrigger_mask = ah->intr_gen_timer_trigger;\n\tthresh_mask = ah->intr_gen_timer_thresh;\n\ttrigger_mask &= timer_table->timer_mask;\n\tthresh_mask &= timer_table->timer_mask;\n\n\tfor_each_set_bit(index, &thresh_mask, ARRAY_SIZE(timer_table->timers)) {\n\t\ttimer = timer_table->timers[index];\n\t\tif (!timer)\n\t\t    continue;\n\t\tif (!timer->overflow)\n\t\t    continue;\n\n\t\ttrigger_mask &= ~BIT(index);\n\t\ttimer->overflow(timer->arg);\n\t}\n\n\tfor_each_set_bit(index, &trigger_mask, ARRAY_SIZE(timer_table->timers)) {\n\t\ttimer = timer_table->timers[index];\n\t\tif (!timer)\n\t\t    continue;\n\t\tif (!timer->trigger)\n\t\t    continue;\n\t\ttimer->trigger(timer->arg);\n\t}\n}\nEXPORT_SYMBOL(ath_gen_timer_isr);\n\n \n \n \n\nstatic struct {\n\tu32 version;\n\tconst char * name;\n} ath_mac_bb_names[] = {\n\t \n\t{ AR_SREV_VERSION_5416_PCI,\t\"5416\" },\n\t{ AR_SREV_VERSION_5416_PCIE,\t\"5418\" },\n\t{ AR_SREV_VERSION_9100,\t\t\"9100\" },\n\t{ AR_SREV_VERSION_9160,\t\t\"9160\" },\n\t \n\t{ AR_SREV_VERSION_9280,\t\t\"9280\" },\n\t{ AR_SREV_VERSION_9285,\t\t\"9285\" },\n\t{ AR_SREV_VERSION_9287,         \"9287\" },\n\t{ AR_SREV_VERSION_9271,         \"9271\" },\n\t{ AR_SREV_VERSION_9300,         \"9300\" },\n\t{ AR_SREV_VERSION_9330,         \"9330\" },\n\t{ AR_SREV_VERSION_9340,\t\t\"9340\" },\n\t{ AR_SREV_VERSION_9485,         \"9485\" },\n\t{ AR_SREV_VERSION_9462,         \"9462\" },\n\t{ AR_SREV_VERSION_9550,         \"9550\" },\n\t{ AR_SREV_VERSION_9565,         \"9565\" },\n\t{ AR_SREV_VERSION_9531,         \"9531\" },\n\t{ AR_SREV_VERSION_9561,         \"9561\" },\n};\n\n \nstatic struct {\n\tu16 version;\n\tconst char * name;\n} ath_rf_names[] = {\n\t{ 0,\t\t\t\t\"5133\" },\n\t{ AR_RAD5133_SREV_MAJOR,\t\"5133\" },\n\t{ AR_RAD5122_SREV_MAJOR,\t\"5122\" },\n\t{ AR_RAD2133_SREV_MAJOR,\t\"2133\" },\n\t{ AR_RAD2122_SREV_MAJOR,\t\"2122\" }\n};\n\n \nstatic const char *ath9k_hw_mac_bb_name(u32 mac_bb_version)\n{\n\tint i;\n\n\tfor (i=0; i<ARRAY_SIZE(ath_mac_bb_names); i++) {\n\t\tif (ath_mac_bb_names[i].version == mac_bb_version) {\n\t\t\treturn ath_mac_bb_names[i].name;\n\t\t}\n\t}\n\n\treturn \"????\";\n}\n\n \nstatic const char *ath9k_hw_rf_name(u16 rf_version)\n{\n\tint i;\n\n\tfor (i=0; i<ARRAY_SIZE(ath_rf_names); i++) {\n\t\tif (ath_rf_names[i].version == rf_version) {\n\t\t\treturn ath_rf_names[i].name;\n\t\t}\n\t}\n\n\treturn \"????\";\n}\n\nvoid ath9k_hw_name(struct ath_hw *ah, char *hw_name, size_t len)\n{\n\tint used;\n\n\t \n\tif (AR_SREV_9280_20_OR_LATER(ah)) {\n\t\tused = scnprintf(hw_name, len,\n\t\t\t\t \"Atheros AR%s Rev:%x\",\n\t\t\t\t ath9k_hw_mac_bb_name(ah->hw_version.macVersion),\n\t\t\t\t ah->hw_version.macRev);\n\t}\n\telse {\n\t\tused = scnprintf(hw_name, len,\n\t\t\t\t \"Atheros AR%s MAC/BB Rev:%x AR%s RF Rev:%x\",\n\t\t\t\t ath9k_hw_mac_bb_name(ah->hw_version.macVersion),\n\t\t\t\t ah->hw_version.macRev,\n\t\t\t\t ath9k_hw_rf_name((ah->hw_version.analog5GhzRev\n\t\t\t\t\t\t  & AR_RADIO_SREV_MAJOR)),\n\t\t\t\t ah->hw_version.phyRev);\n\t}\n\n\thw_name[used] = '\\0';\n}\nEXPORT_SYMBOL(ath9k_hw_name);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}