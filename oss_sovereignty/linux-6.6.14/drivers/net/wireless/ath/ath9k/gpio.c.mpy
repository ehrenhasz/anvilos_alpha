{
  "module_name": "gpio.c",
  "hash_id": "e7fa6ea5a60bb4e8a84b7ed1107b61cd806c7d03dc540a0fbc8ecd3ad7ed6829",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath9k/gpio.c",
  "human_readable_source": " \n\n#include \"ath9k.h\"\n\n \n \n \n\n#ifdef CONFIG_MAC80211_LEDS\n\nstatic void ath_fill_led_pin(struct ath_softc *sc)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\n\t \n\tif (ah->led_pin < 0) {\n\t\tif (AR_SREV_9287(ah))\n\t\t\tah->led_pin = ATH_LED_PIN_9287;\n\t\telse if (AR_SREV_9485(ah))\n\t\t\tah->led_pin = ATH_LED_PIN_9485;\n\t\telse if (AR_SREV_9300(ah))\n\t\t\tah->led_pin = ATH_LED_PIN_9300;\n\t\telse if (AR_SREV_9462(ah) || AR_SREV_9565(ah))\n\t\t\tah->led_pin = ATH_LED_PIN_9462;\n\t\telse\n\t\t\tah->led_pin = ATH_LED_PIN_DEF;\n\t}\n\n\t \n\tath9k_hw_gpio_request_out(ah, ah->led_pin, \"ath9k-led\",\n\t\t\t\t  AR_GPIO_OUTPUT_MUX_AS_OUTPUT);\n\n\t \n\tath9k_hw_set_gpio(ah, ah->led_pin, ah->config.led_active_high ? 0 : 1);\n}\n\nstatic void ath_led_brightness(struct led_classdev *led_cdev,\n\t\t\t       enum led_brightness brightness)\n{\n\tstruct ath_softc *sc = container_of(led_cdev, struct ath_softc, led_cdev);\n\tu32 val = (brightness == LED_OFF);\n\n\tif (sc->sc_ah->config.led_active_high)\n\t\tval = !val;\n\n\tath9k_hw_set_gpio(sc->sc_ah, sc->sc_ah->led_pin, val);\n}\n\nvoid ath_deinit_leds(struct ath_softc *sc)\n{\n\tif (!sc->led_registered)\n\t\treturn;\n\n\tath_led_brightness(&sc->led_cdev, LED_OFF);\n\tled_classdev_unregister(&sc->led_cdev);\n\n\tath9k_hw_gpio_free(sc->sc_ah, sc->sc_ah->led_pin);\n}\n\nvoid ath_init_leds(struct ath_softc *sc)\n{\n\tint ret;\n\n\tif (AR_SREV_9100(sc->sc_ah))\n\t\treturn;\n\n\tath_fill_led_pin(sc);\n\n\tif (!ath9k_led_blink)\n\t\tsc->led_cdev.default_trigger =\n\t\t\tieee80211_get_radio_led_name(sc->hw);\n\n\tsnprintf(sc->led_name, sizeof(sc->led_name),\n\t\t\"ath9k-%s\", wiphy_name(sc->hw->wiphy));\n\tsc->led_cdev.name = sc->led_name;\n\tsc->led_cdev.brightness_set = ath_led_brightness;\n\n\tret = led_classdev_register(wiphy_dev(sc->hw->wiphy), &sc->led_cdev);\n\tif (ret < 0)\n\t\treturn;\n\n\tsc->led_registered = true;\n}\n#endif\n\n \n \n \n\nstatic bool ath_is_rfkill_set(struct ath_softc *sc)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tbool is_blocked;\n\n\tath9k_ps_wakeup(sc);\n\tis_blocked = ath9k_hw_gpio_get(ah, ah->rfkill_gpio) ==\n\t\t\t\t  ah->rfkill_polarity;\n\tath9k_ps_restore(sc);\n\n\treturn is_blocked;\n}\n\nvoid ath9k_rfkill_poll_state(struct ieee80211_hw *hw)\n{\n\tstruct ath_softc *sc = hw->priv;\n\tbool blocked = !!ath_is_rfkill_set(sc);\n\n\twiphy_rfkill_set_hw_state(hw->wiphy, blocked);\n}\n\nvoid ath_start_rfkill_poll(struct ath_softc *sc)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\n\tif (ah->caps.hw_caps & ATH9K_HW_CAP_RFSILENT)\n\t\twiphy_rfkill_start_polling(sc->hw->wiphy);\n}\n\n#ifdef CONFIG_ATH9K_BTCOEX_SUPPORT\n\n \n \n \n\n \nstatic void ath_detect_bt_priority(struct ath_softc *sc)\n{\n\tstruct ath_btcoex *btcoex = &sc->btcoex;\n\tstruct ath_hw *ah = sc->sc_ah;\n\n\tif (ath9k_hw_gpio_get(sc->sc_ah, ah->btcoex_hw.btpriority_gpio))\n\t\tbtcoex->bt_priority_cnt++;\n\n\tif (time_after(jiffies, btcoex->bt_priority_time +\n\t\t\tmsecs_to_jiffies(ATH_BT_PRIORITY_TIME_THRESHOLD))) {\n\t\tclear_bit(BT_OP_PRIORITY_DETECTED, &btcoex->op_flags);\n\t\tclear_bit(BT_OP_SCAN, &btcoex->op_flags);\n\t\t \n\t\tif (btcoex->bt_priority_cnt >= ATH_BT_CNT_SCAN_THRESHOLD) {\n\t\t\tath_dbg(ath9k_hw_common(sc->sc_ah), BTCOEX,\n\t\t\t\t\"BT scan detected\\n\");\n\t\t\tset_bit(BT_OP_PRIORITY_DETECTED, &btcoex->op_flags);\n\t\t\tset_bit(BT_OP_SCAN, &btcoex->op_flags);\n\t\t} else if (btcoex->bt_priority_cnt >= ATH_BT_CNT_THRESHOLD) {\n\t\t\tath_dbg(ath9k_hw_common(sc->sc_ah), BTCOEX,\n\t\t\t\t\"BT priority traffic detected\\n\");\n\t\t\tset_bit(BT_OP_PRIORITY_DETECTED, &btcoex->op_flags);\n\t\t}\n\n\t\tbtcoex->bt_priority_cnt = 0;\n\t\tbtcoex->bt_priority_time = jiffies;\n\t}\n}\n\nstatic void ath_mci_ftp_adjust(struct ath_softc *sc)\n{\n\tstruct ath_btcoex *btcoex = &sc->btcoex;\n\tstruct ath_mci_profile *mci = &btcoex->mci;\n\tstruct ath_hw *ah = sc->sc_ah;\n\n\tif (btcoex->bt_wait_time > ATH_BTCOEX_RX_WAIT_TIME) {\n\t\tif (ar9003_mci_state(ah, MCI_STATE_NEED_FTP_STOMP) &&\n\t\t    (mci->num_pan || mci->num_other_acl))\n\t\t\tah->btcoex_hw.mci.stomp_ftp =\n\t\t\t\t(sc->rx.num_pkts < ATH_BTCOEX_STOMP_FTP_THRESH);\n\t\telse\n\t\t\tah->btcoex_hw.mci.stomp_ftp = false;\n\t\tbtcoex->bt_wait_time = 0;\n\t\tsc->rx.num_pkts = 0;\n\t}\n}\n\n \nstatic void ath_btcoex_period_timer(struct timer_list *t)\n{\n\tstruct ath_softc *sc = from_timer(sc, t, btcoex.period_timer);\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_btcoex *btcoex = &sc->btcoex;\n\tenum ath_stomp_type stomp_type;\n\tu32 timer_period;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sc->sc_pm_lock, flags);\n\tif (sc->sc_ah->power_mode == ATH9K_PM_NETWORK_SLEEP) {\n\t\tbtcoex->bt_wait_time += btcoex->btcoex_period;\n\t\tspin_unlock_irqrestore(&sc->sc_pm_lock, flags);\n\t\tgoto skip_hw_wakeup;\n\t}\n\tspin_unlock_irqrestore(&sc->sc_pm_lock, flags);\n\n\tath9k_ps_wakeup(sc);\n\tspin_lock_bh(&btcoex->btcoex_lock);\n\n\tif (ah->caps.hw_caps & ATH9K_HW_CAP_MCI) {\n\t\tath9k_mci_update_rssi(sc);\n\t\tath_mci_ftp_adjust(sc);\n\t}\n\n\tif (!(ah->caps.hw_caps & ATH9K_HW_CAP_MCI))\n\t\tath_detect_bt_priority(sc);\n\n\tstomp_type = btcoex->bt_stomp_type;\n\ttimer_period = btcoex->btcoex_no_stomp;\n\n\tif (!(ah->caps.hw_caps & ATH9K_HW_CAP_MCI)) {\n\t\tif (test_bit(BT_OP_SCAN, &btcoex->op_flags)) {\n\t\t\tstomp_type = ATH_BTCOEX_STOMP_ALL;\n\t\t\ttimer_period = btcoex->btscan_no_stomp;\n\t\t}\n\t} else if (btcoex->stomp_audio >= 5) {\n\t\tstomp_type = ATH_BTCOEX_STOMP_AUDIO;\n\t\tbtcoex->stomp_audio = 0;\n\t}\n\n\tath9k_hw_btcoex_bt_stomp(ah, stomp_type);\n\tath9k_hw_btcoex_enable(ah);\n\n\tspin_unlock_bh(&btcoex->btcoex_lock);\n\n\tif (btcoex->btcoex_period != btcoex->btcoex_no_stomp)\n\t\tmod_timer(&btcoex->no_stomp_timer,\n\t\t\t jiffies + msecs_to_jiffies(timer_period));\n\n\tath9k_ps_restore(sc);\n\nskip_hw_wakeup:\n\tmod_timer(&btcoex->period_timer,\n\t\t  jiffies + msecs_to_jiffies(btcoex->btcoex_period));\n}\n\n \nstatic void ath_btcoex_no_stomp_timer(struct timer_list *t)\n{\n\tstruct ath_softc *sc = from_timer(sc, t, btcoex.no_stomp_timer);\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_btcoex *btcoex = &sc->btcoex;\n\n\tath9k_ps_wakeup(sc);\n\tspin_lock_bh(&btcoex->btcoex_lock);\n\n\tif (btcoex->bt_stomp_type == ATH_BTCOEX_STOMP_LOW ||\n\t    (!(ah->caps.hw_caps & ATH9K_HW_CAP_MCI) &&\n\t     test_bit(BT_OP_SCAN, &btcoex->op_flags)))\n\t\tath9k_hw_btcoex_bt_stomp(ah, ATH_BTCOEX_STOMP_NONE);\n\telse if (btcoex->bt_stomp_type == ATH_BTCOEX_STOMP_ALL)\n\t\tath9k_hw_btcoex_bt_stomp(ah, ATH_BTCOEX_STOMP_LOW);\n\n\tath9k_hw_btcoex_enable(ah);\n\tspin_unlock_bh(&btcoex->btcoex_lock);\n\tath9k_ps_restore(sc);\n}\n\nstatic void ath_init_btcoex_timer(struct ath_softc *sc)\n{\n\tstruct ath_btcoex *btcoex = &sc->btcoex;\n\n\tbtcoex->btcoex_period = ATH_BTCOEX_DEF_BT_PERIOD;\n\tbtcoex->btcoex_no_stomp = (100 - ATH_BTCOEX_DEF_DUTY_CYCLE) *\n\t\tbtcoex->btcoex_period / 100;\n\tbtcoex->btscan_no_stomp = (100 - ATH_BTCOEX_BTSCAN_DUTY_CYCLE) *\n\t\t\t\t   btcoex->btcoex_period / 100;\n\tbtcoex->bt_stomp_type = ATH_BTCOEX_STOMP_LOW;\n\n\ttimer_setup(&btcoex->period_timer, ath_btcoex_period_timer, 0);\n\ttimer_setup(&btcoex->no_stomp_timer, ath_btcoex_no_stomp_timer, 0);\n\n\tspin_lock_init(&btcoex->btcoex_lock);\n}\n\n \nvoid ath9k_btcoex_timer_resume(struct ath_softc *sc)\n{\n\tstruct ath_btcoex *btcoex = &sc->btcoex;\n\tstruct ath_hw *ah = sc->sc_ah;\n\n\tif (ath9k_hw_get_btcoex_scheme(ah) != ATH_BTCOEX_CFG_3WIRE &&\n\t    ath9k_hw_get_btcoex_scheme(ah) != ATH_BTCOEX_CFG_MCI)\n\t\treturn;\n\n\tath_dbg(ath9k_hw_common(ah), BTCOEX, \"Starting btcoex timers\\n\");\n\n\t \n\tdel_timer_sync(&btcoex->no_stomp_timer);\n\n\tbtcoex->bt_priority_cnt = 0;\n\tbtcoex->bt_priority_time = jiffies;\n\tclear_bit(BT_OP_PRIORITY_DETECTED, &btcoex->op_flags);\n\tclear_bit(BT_OP_SCAN, &btcoex->op_flags);\n\n\tmod_timer(&btcoex->period_timer, jiffies);\n}\n\n \nvoid ath9k_btcoex_timer_pause(struct ath_softc *sc)\n{\n\tstruct ath_btcoex *btcoex = &sc->btcoex;\n\tstruct ath_hw *ah = sc->sc_ah;\n\n\tif (ath9k_hw_get_btcoex_scheme(ah) != ATH_BTCOEX_CFG_3WIRE &&\n\t    ath9k_hw_get_btcoex_scheme(ah) != ATH_BTCOEX_CFG_MCI)\n\t\treturn;\n\n\tath_dbg(ath9k_hw_common(ah), BTCOEX, \"Stopping btcoex timers\\n\");\n\n\tdel_timer_sync(&btcoex->period_timer);\n\tdel_timer_sync(&btcoex->no_stomp_timer);\n}\n\nvoid ath9k_btcoex_stop_gen_timer(struct ath_softc *sc)\n{\n\tstruct ath_btcoex *btcoex = &sc->btcoex;\n\n\tdel_timer_sync(&btcoex->no_stomp_timer);\n}\n\nu16 ath9k_btcoex_aggr_limit(struct ath_softc *sc, u32 max_4ms_framelen)\n{\n\tstruct ath_btcoex *btcoex = &sc->btcoex;\n\tstruct ath_mci_profile *mci = &sc->btcoex.mci;\n\tu16 aggr_limit = 0;\n\n\tif ((sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_MCI) && mci->aggr_limit)\n\t\taggr_limit = (max_4ms_framelen * mci->aggr_limit) >> 4;\n\telse if (test_bit(BT_OP_PRIORITY_DETECTED, &btcoex->op_flags))\n\t\taggr_limit = min((max_4ms_framelen * 3) / 8,\n\t\t\t\t (u32)ATH_AMPDU_LIMIT_MAX);\n\n\treturn aggr_limit;\n}\n\nvoid ath9k_btcoex_handle_interrupt(struct ath_softc *sc, u32 status)\n{\n\tif (status & ATH9K_INT_MCI)\n\t\tath_mci_intr(sc);\n}\n\nvoid ath9k_start_btcoex(struct ath_softc *sc)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\n\tif (ah->btcoex_hw.enabled ||\n\t    ath9k_hw_get_btcoex_scheme(ah) == ATH_BTCOEX_CFG_NONE)\n\t\treturn;\n\n\tif (!(ah->caps.hw_caps & ATH9K_HW_CAP_MCI))\n\t\tath9k_hw_btcoex_set_weight(ah, AR_BT_COEX_WGHT,\n\t\t\t\t\t   AR_STOMP_LOW_WLAN_WGHT, 0);\n\telse\n\t\tath9k_hw_btcoex_set_weight(ah, 0, 0,\n\t\t\t\t\t   ATH_BTCOEX_STOMP_NONE);\n\tath9k_hw_btcoex_enable(ah);\n\tath9k_btcoex_timer_resume(sc);\n}\n\nvoid ath9k_stop_btcoex(struct ath_softc *sc)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\n\tif (!ah->btcoex_hw.enabled ||\n\t    ath9k_hw_get_btcoex_scheme(ah) == ATH_BTCOEX_CFG_NONE)\n\t\treturn;\n\n\tath9k_btcoex_timer_pause(sc);\n\tath9k_hw_btcoex_disable(ah);\n\n\tif (ah->caps.hw_caps & ATH9K_HW_CAP_MCI)\n\t\tath_mci_flush_profile(&sc->btcoex.mci);\n}\n\nvoid ath9k_deinit_btcoex(struct ath_softc *sc)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\n\tif (ath9k_hw_mci_is_enabled(ah))\n\t\tath_mci_cleanup(sc);\n\telse {\n\t\tenum ath_btcoex_scheme scheme = ath9k_hw_get_btcoex_scheme(ah);\n\n\t\tif (scheme == ATH_BTCOEX_CFG_2WIRE ||\n\t\t    scheme == ATH_BTCOEX_CFG_3WIRE)\n\t\t\tath9k_hw_btcoex_deinit(sc->sc_ah);\n\t}\n}\n\nint ath9k_init_btcoex(struct ath_softc *sc)\n{\n\tstruct ath_txq *txq;\n\tstruct ath_hw *ah = sc->sc_ah;\n\tint r;\n\n\tath9k_hw_btcoex_init_scheme(ah);\n\n\tswitch (ath9k_hw_get_btcoex_scheme(sc->sc_ah)) {\n\tcase ATH_BTCOEX_CFG_NONE:\n\t\tbreak;\n\tcase ATH_BTCOEX_CFG_2WIRE:\n\t\tath9k_hw_btcoex_init_2wire(sc->sc_ah);\n\t\tbreak;\n\tcase ATH_BTCOEX_CFG_3WIRE:\n\t\tath9k_hw_btcoex_init_3wire(sc->sc_ah);\n\t\tath_init_btcoex_timer(sc);\n\t\ttxq = sc->tx.txq_map[IEEE80211_AC_BE];\n\t\tath9k_hw_init_btcoex_hw(sc->sc_ah, txq->axq_qnum);\n\t\tbreak;\n\tcase ATH_BTCOEX_CFG_MCI:\n\t\tath_init_btcoex_timer(sc);\n\n\t\tsc->btcoex.duty_cycle = ATH_BTCOEX_DEF_DUTY_CYCLE;\n\t\tINIT_LIST_HEAD(&sc->btcoex.mci.info);\n\t\tath9k_hw_btcoex_init_mci(ah);\n\n\t\tr = ath_mci_setup(sc);\n\t\tif (r)\n\t\t\treturn r;\n\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath9k_dump_mci_btcoex(struct ath_softc *sc, u8 *buf, u32 size)\n{\n\tstruct ath_btcoex *btcoex = &sc->btcoex;\n\tstruct ath_mci_profile *mci = &btcoex->mci;\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_btcoex_hw *btcoex_hw = &ah->btcoex_hw;\n\tu32 len = 0;\n\tint i;\n\n\tATH_DUMP_BTCOEX(\"Total BT profiles\", NUM_PROF(mci));\n\tATH_DUMP_BTCOEX(\"MGMT\", mci->num_mgmt);\n\tATH_DUMP_BTCOEX(\"SCO\", mci->num_sco);\n\tATH_DUMP_BTCOEX(\"A2DP\", mci->num_a2dp);\n\tATH_DUMP_BTCOEX(\"HID\", mci->num_hid);\n\tATH_DUMP_BTCOEX(\"PAN\", mci->num_pan);\n\tATH_DUMP_BTCOEX(\"ACL\", mci->num_other_acl);\n\tATH_DUMP_BTCOEX(\"BDR\", mci->num_bdr);\n\tATH_DUMP_BTCOEX(\"Aggr. Limit\", mci->aggr_limit);\n\tATH_DUMP_BTCOEX(\"Stomp Type\", btcoex->bt_stomp_type);\n\tATH_DUMP_BTCOEX(\"BTCoex Period (msec)\", btcoex->btcoex_period);\n\tATH_DUMP_BTCOEX(\"Duty Cycle\", btcoex->duty_cycle);\n\tATH_DUMP_BTCOEX(\"BT Wait time\", btcoex->bt_wait_time);\n\tATH_DUMP_BTCOEX(\"Concurrent Tx\", btcoex_hw->mci.concur_tx);\n\tATH_DUMP_BTCOEX(\"Concurrent RSSI cnt\", btcoex->rssi_count);\n\n\tlen += scnprintf(buf + len, size - len, \"BT Weights: \");\n\tfor (i = 0; i < AR9300_NUM_BT_WEIGHTS; i++)\n\t\tlen += scnprintf(buf + len, size - len, \"%08x \",\n\t\t\t\t btcoex_hw->bt_weight[i]);\n\tlen += scnprintf(buf + len, size - len, \"\\n\");\n\tlen += scnprintf(buf + len, size - len, \"WLAN Weights: \");\n\tfor (i = 0; i < AR9300_NUM_BT_WEIGHTS; i++)\n\t\tlen += scnprintf(buf + len, size - len, \"%08x \",\n\t\t\t\t btcoex_hw->wlan_weight[i]);\n\tlen += scnprintf(buf + len, size - len, \"\\n\");\n\tlen += scnprintf(buf + len, size - len, \"Tx Priorities: \");\n\tfor (i = 0; i < ATH_BTCOEX_STOMP_MAX; i++)\n\t\tlen += scnprintf(buf + len, size - len, \"%08x \",\n\t\t\t\tbtcoex_hw->tx_prio[i]);\n\n\tlen += scnprintf(buf + len, size - len, \"\\n\");\n\n\treturn len;\n}\n\nstatic int ath9k_dump_legacy_btcoex(struct ath_softc *sc, u8 *buf, u32 size)\n{\n\n\tstruct ath_btcoex *btcoex = &sc->btcoex;\n\tu32 len = 0;\n\n\tATH_DUMP_BTCOEX(\"Stomp Type\", btcoex->bt_stomp_type);\n\tATH_DUMP_BTCOEX(\"BTCoex Period (msec)\", btcoex->btcoex_period);\n\tATH_DUMP_BTCOEX(\"Duty Cycle\", btcoex->duty_cycle);\n\tATH_DUMP_BTCOEX(\"BT Wait time\", btcoex->bt_wait_time);\n\n\treturn len;\n}\n\nint ath9k_dump_btcoex(struct ath_softc *sc, u8 *buf, u32 size)\n{\n\tif (ath9k_hw_mci_is_enabled(sc->sc_ah))\n\t\treturn ath9k_dump_mci_btcoex(sc, buf, size);\n\telse\n\t\treturn ath9k_dump_legacy_btcoex(sc, buf, size);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}