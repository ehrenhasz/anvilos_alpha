{
  "module_name": "calib.c",
  "hash_id": "19060e7954bed5aa38dcaeb2c8d5e8153f55da56d9cde8a3e80aa763dfb30efe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath9k/calib.c",
  "human_readable_source": " \n\n#include \"hw.h\"\n#include \"hw-ops.h\"\n#include <linux/export.h>\n\n \n\n\nstatic int16_t ath9k_hw_get_nf_hist_mid(int16_t *nfCalBuffer)\n{\n\tint16_t nfval;\n\tint16_t sort[ATH9K_NF_CAL_HIST_MAX];\n\tint i, j;\n\n\tfor (i = 0; i < ATH9K_NF_CAL_HIST_MAX; i++)\n\t\tsort[i] = nfCalBuffer[i];\n\n\tfor (i = 0; i < ATH9K_NF_CAL_HIST_MAX - 1; i++) {\n\t\tfor (j = 1; j < ATH9K_NF_CAL_HIST_MAX - i; j++) {\n\t\t\tif (sort[j] > sort[j - 1]) {\n\t\t\t\tnfval = sort[j];\n\t\t\t\tsort[j] = sort[j - 1];\n\t\t\t\tsort[j - 1] = nfval;\n\t\t\t}\n\t\t}\n\t}\n\tnfval = sort[(ATH9K_NF_CAL_HIST_MAX - 1) >> 1];\n\n\treturn nfval;\n}\n\nstatic struct ath_nf_limits *ath9k_hw_get_nf_limits(struct ath_hw *ah,\n\t\t\t\t\t\t    struct ath9k_channel *chan)\n{\n\tstruct ath_nf_limits *limit;\n\n\tif (!chan || IS_CHAN_2GHZ(chan))\n\t\tlimit = &ah->nf_2g;\n\telse\n\t\tlimit = &ah->nf_5g;\n\n\treturn limit;\n}\n\nstatic s16 ath9k_hw_get_default_nf(struct ath_hw *ah,\n\t\t\t\t   struct ath9k_channel *chan,\n\t\t\t\t   int chain)\n{\n\ts16 calib_nf = ath9k_hw_get_nf_limits(ah, chan)->cal[chain];\n\n\tif (calib_nf)\n\t\treturn calib_nf;\n\telse\n\t\treturn ath9k_hw_get_nf_limits(ah, chan)->nominal;\n}\n\ns16 ath9k_hw_getchan_noise(struct ath_hw *ah, struct ath9k_channel *chan,\n\t\t\t   s16 nf)\n{\n\ts8 noise = ATH_DEFAULT_NOISE_FLOOR;\n\n\tif (nf) {\n\t\ts8 delta = nf - ATH9K_NF_CAL_NOISE_THRESH -\n\t\t\t   ath9k_hw_get_default_nf(ah, chan, 0);\n\t\tif (delta > 0)\n\t\t\tnoise += delta;\n\t}\n\treturn noise;\n}\nEXPORT_SYMBOL(ath9k_hw_getchan_noise);\n\nstatic void ath9k_hw_update_nfcal_hist_buffer(struct ath_hw *ah,\n\t\t\t\t\t      struct ath9k_hw_cal_data *cal,\n\t\t\t\t\t      int16_t *nfarray)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath_nf_limits *limit;\n\tstruct ath9k_nfcal_hist *h;\n\tbool high_nf_mid = false;\n\tu8 chainmask = (ah->rxchainmask << 3) | ah->rxchainmask;\n\tint i;\n\n\th = cal->nfCalHist;\n\tlimit = ath9k_hw_get_nf_limits(ah, ah->curchan);\n\n\tfor (i = 0; i < NUM_NF_READINGS; i++) {\n\t\tif (!(chainmask & (1 << i)) ||\n\t\t    ((i >= AR5416_MAX_CHAINS) && !IS_CHAN_HT40(ah->curchan)))\n\t\t\tcontinue;\n\n\t\th[i].nfCalBuffer[h[i].currIndex] = nfarray[i];\n\n\t\tif (++h[i].currIndex >= ATH9K_NF_CAL_HIST_MAX)\n\t\t\th[i].currIndex = 0;\n\n\t\tif (h[i].invalidNFcount > 0) {\n\t\t\th[i].invalidNFcount--;\n\t\t\th[i].privNF = nfarray[i];\n\t\t} else {\n\t\t\th[i].privNF =\n\t\t\t\tath9k_hw_get_nf_hist_mid(h[i].nfCalBuffer);\n\t\t}\n\n\t\tif (!h[i].privNF)\n\t\t\tcontinue;\n\n\t\tif (h[i].privNF > limit->max) {\n\t\t\thigh_nf_mid = true;\n\n\t\t\tath_dbg(common, CALIBRATE,\n\t\t\t\t\"NFmid[%d] (%d) > MAX (%d), %s\\n\",\n\t\t\t\ti, h[i].privNF, limit->max,\n\t\t\t\t(test_bit(NFCAL_INTF, &cal->cal_flags) ?\n\t\t\t\t \"not corrected (due to interference)\" :\n\t\t\t\t \"correcting to MAX\"));\n\n\t\t\t \n\t\t\tif (!test_bit(NFCAL_INTF, &cal->cal_flags))\n\t\t\t\th[i].privNF = limit->max;\n\t\t}\n\t}\n\n\t \n\tif (!high_nf_mid)\n\t\tclear_bit(NFCAL_INTF, &cal->cal_flags);\n}\n\nstatic bool ath9k_hw_get_nf_thresh(struct ath_hw *ah,\n\t\t\t\t   enum nl80211_band band,\n\t\t\t\t   int16_t *nft)\n{\n\tswitch (band) {\n\tcase NL80211_BAND_5GHZ:\n\t\t*nft = (int8_t)ah->eep_ops->get_eeprom(ah, EEP_NFTHRESH_5);\n\t\tbreak;\n\tcase NL80211_BAND_2GHZ:\n\t\t*nft = (int8_t)ah->eep_ops->get_eeprom(ah, EEP_NFTHRESH_2);\n\t\tbreak;\n\tdefault:\n\t\tBUG_ON(1);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nvoid ath9k_hw_reset_calibration(struct ath_hw *ah,\n\t\t\t\tstruct ath9k_cal_list *currCal)\n{\n\tint i;\n\n\tath9k_hw_setup_calibration(ah, currCal);\n\n\tah->cal_start_time = jiffies;\n\tcurrCal->calState = CAL_RUNNING;\n\n\tfor (i = 0; i < AR5416_MAX_CHAINS; i++) {\n\t\tah->meas0.sign[i] = 0;\n\t\tah->meas1.sign[i] = 0;\n\t\tah->meas2.sign[i] = 0;\n\t\tah->meas3.sign[i] = 0;\n\t}\n\n\tah->cal_samples = 0;\n}\n\n \nbool ath9k_hw_reset_calvalid(struct ath_hw *ah)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath9k_cal_list *currCal = ah->cal_list_curr;\n\n\tif (!ah->caldata)\n\t\treturn true;\n\n\tif (!AR_SREV_9100(ah) && !AR_SREV_9160_10_OR_LATER(ah))\n\t\treturn true;\n\n\tif (currCal == NULL)\n\t\treturn true;\n\n\tif (currCal->calState != CAL_DONE) {\n\t\tath_dbg(common, CALIBRATE, \"Calibration state incorrect, %d\\n\",\n\t\t\tcurrCal->calState);\n\t\treturn true;\n\t}\n\n\tcurrCal = ah->cal_list;\n\tdo {\n\t\tath_dbg(common, CALIBRATE, \"Resetting Cal %d state for channel %u\\n\",\n\t\t\tcurrCal->calData->calType,\n\t\t\tah->curchan->chan->center_freq);\n\n\t\tah->caldata->CalValid &= ~currCal->calData->calType;\n\t\tcurrCal->calState = CAL_WAITING;\n\n\t\tcurrCal = currCal->calNext;\n\t} while (currCal != ah->cal_list);\n\n\treturn false;\n}\nEXPORT_SYMBOL(ath9k_hw_reset_calvalid);\n\nvoid ath9k_hw_start_nfcal(struct ath_hw *ah, bool update)\n{\n\tif (ah->caldata)\n\t\tset_bit(NFCAL_PENDING, &ah->caldata->cal_flags);\n\n\tREG_SET_BIT(ah, AR_PHY_AGC_CONTROL(ah),\n\t\t    AR_PHY_AGC_CONTROL_ENABLE_NF);\n\n\tif (update)\n\t\tREG_CLR_BIT(ah, AR_PHY_AGC_CONTROL(ah),\n\t\t    AR_PHY_AGC_CONTROL_NO_UPDATE_NF);\n\telse\n\t\tREG_SET_BIT(ah, AR_PHY_AGC_CONTROL(ah),\n\t\t    AR_PHY_AGC_CONTROL_NO_UPDATE_NF);\n\n\tREG_SET_BIT(ah, AR_PHY_AGC_CONTROL(ah), AR_PHY_AGC_CONTROL_NF);\n}\n\nint ath9k_hw_loadnf(struct ath_hw *ah, struct ath9k_channel *chan)\n{\n\tstruct ath9k_nfcal_hist *h = NULL;\n\tunsigned i, j;\n\tu8 chainmask = (ah->rxchainmask << 3) | ah->rxchainmask;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\ts16 default_nf = ath9k_hw_get_nf_limits(ah, chan)->nominal;\n\tu32 bb_agc_ctl = REG_READ(ah, AR_PHY_AGC_CONTROL(ah));\n\n\tif (ah->caldata)\n\t\th = ah->caldata->nfCalHist;\n\n\tENABLE_REG_RMW_BUFFER(ah);\n\tfor (i = 0; i < NUM_NF_READINGS; i++) {\n\t\tif (chainmask & (1 << i)) {\n\t\t\ts16 nfval;\n\n\t\t\tif ((i >= AR5416_MAX_CHAINS) && !IS_CHAN_HT40(chan))\n\t\t\t\tcontinue;\n\n\t\t\tif (ah->nf_override)\n\t\t\t\tnfval = ah->nf_override;\n\t\t\telse if (h)\n\t\t\t\tnfval = h[i].privNF;\n\t\t\telse {\n\t\t\t\t \n\t\t\t\tnfval =\n\t\t\t\t    ath9k_hw_get_nf_limits(ah, chan)->cal[i];\n\t\t\t\tif (nfval > -60 || nfval < -127)\n\t\t\t\t\tnfval = default_nf;\n\t\t\t}\n\n\t\t\tREG_RMW(ah, ah->nf_regs[i],\n\t\t\t\t(((u32) nfval << 1) & 0x1ff), 0x1ff);\n\t\t}\n\t}\n\n\t \n\tif (bb_agc_ctl & AR_PHY_AGC_CONTROL_NF) {\n\t\tREG_CLR_BIT(ah, AR_PHY_AGC_CONTROL(ah), AR_PHY_AGC_CONTROL_NF);\n\t\tREG_RMW_BUFFER_FLUSH(ah);\n\t\tENABLE_REG_RMW_BUFFER(ah);\n\t}\n\n\t \n\tREG_CLR_BIT(ah, AR_PHY_AGC_CONTROL(ah),\n\t\t    AR_PHY_AGC_CONTROL_ENABLE_NF);\n\tREG_CLR_BIT(ah, AR_PHY_AGC_CONTROL(ah),\n\t\t    AR_PHY_AGC_CONTROL_NO_UPDATE_NF);\n\tREG_SET_BIT(ah, AR_PHY_AGC_CONTROL(ah), AR_PHY_AGC_CONTROL_NF);\n\tREG_RMW_BUFFER_FLUSH(ah);\n\n\t \n\tfor (j = 0; j < 22200; j++) {\n\t\tif ((REG_READ(ah, AR_PHY_AGC_CONTROL(ah)) &\n\t\t\t      AR_PHY_AGC_CONTROL_NF) == 0)\n\t\t\tbreak;\n\t\tudelay(10);\n\t}\n\n\t \n\tif (bb_agc_ctl & AR_PHY_AGC_CONTROL_NF) {\n\t\tENABLE_REG_RMW_BUFFER(ah);\n\t\tif (bb_agc_ctl & AR_PHY_AGC_CONTROL_ENABLE_NF)\n\t\t\tREG_SET_BIT(ah, AR_PHY_AGC_CONTROL(ah),\n\t\t\t\t    AR_PHY_AGC_CONTROL_ENABLE_NF);\n\t\tif (bb_agc_ctl & AR_PHY_AGC_CONTROL_NO_UPDATE_NF)\n\t\t\tREG_SET_BIT(ah, AR_PHY_AGC_CONTROL(ah),\n\t\t\t\t    AR_PHY_AGC_CONTROL_NO_UPDATE_NF);\n\t\tREG_SET_BIT(ah, AR_PHY_AGC_CONTROL(ah), AR_PHY_AGC_CONTROL_NF);\n\t\tREG_RMW_BUFFER_FLUSH(ah);\n\t}\n\n\t \n\tif (j == 22200) {\n\t\tath_dbg(common, ANY,\n\t\t\t\"Timeout while waiting for nf to load: AR_PHY_AGC_CONTROL=0x%x\\n\",\n\t\t\tREG_READ(ah, AR_PHY_AGC_CONTROL(ah)));\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\tENABLE_REG_RMW_BUFFER(ah);\n\tfor (i = 0; i < NUM_NF_READINGS; i++) {\n\t\tif (chainmask & (1 << i)) {\n\t\t\tif ((i >= AR5416_MAX_CHAINS) && !IS_CHAN_HT40(chan))\n\t\t\t\tcontinue;\n\n\t\t\tREG_RMW(ah, ah->nf_regs[i],\n\t\t\t\t\t(((u32) (-50) << 1) & 0x1ff), 0x1ff);\n\t\t}\n\t}\n\tREG_RMW_BUFFER_FLUSH(ah);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ath9k_hw_loadnf);\n\n\nstatic void ath9k_hw_nf_sanitize(struct ath_hw *ah, s16 *nf)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath_nf_limits *limit;\n\tint i;\n\n\tif (IS_CHAN_2GHZ(ah->curchan))\n\t\tlimit = &ah->nf_2g;\n\telse\n\t\tlimit = &ah->nf_5g;\n\n\tfor (i = 0; i < NUM_NF_READINGS; i++) {\n\t\tif (!nf[i])\n\t\t\tcontinue;\n\n\t\tath_dbg(common, CALIBRATE,\n\t\t\t\"NF calibrated [%s] [chain %d] is %d\\n\",\n\t\t\t(i >= 3 ? \"ext\" : \"ctl\"), i % 3, nf[i]);\n\n\t\tif (nf[i] > limit->max) {\n\t\t\tath_dbg(common, CALIBRATE,\n\t\t\t\t\"NF[%d] (%d) > MAX (%d), correcting to MAX\\n\",\n\t\t\t\ti, nf[i], limit->max);\n\t\t\tnf[i] = limit->max;\n\t\t} else if (nf[i] < limit->min) {\n\t\t\tath_dbg(common, CALIBRATE,\n\t\t\t\t\"NF[%d] (%d) < MIN (%d), correcting to NOM\\n\",\n\t\t\t\ti, nf[i], limit->min);\n\t\t\tnf[i] = limit->nominal;\n\t\t}\n\t}\n}\n\nbool ath9k_hw_getnf(struct ath_hw *ah, struct ath9k_channel *chan)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tint16_t nf, nfThresh;\n\tint16_t nfarray[NUM_NF_READINGS] = { 0 };\n\tstruct ath9k_nfcal_hist *h;\n\tstruct ieee80211_channel *c = chan->chan;\n\tstruct ath9k_hw_cal_data *caldata = ah->caldata;\n\n\tif (REG_READ(ah, AR_PHY_AGC_CONTROL(ah)) & AR_PHY_AGC_CONTROL_NF) {\n\t\tath_dbg(common, CALIBRATE,\n\t\t\t\"NF did not complete in calibration window\\n\");\n\t\treturn false;\n\t}\n\n\tath9k_hw_do_getnf(ah, nfarray);\n\tath9k_hw_nf_sanitize(ah, nfarray);\n\tnf = nfarray[0];\n\tif (ath9k_hw_get_nf_thresh(ah, c->band, &nfThresh)\n\t    && nf > nfThresh) {\n\t\tath_dbg(common, CALIBRATE,\n\t\t\t\"noise floor failed detected; detected %d, threshold %d\\n\",\n\t\t\tnf, nfThresh);\n\t}\n\n\tif (!caldata) {\n\t\tchan->noisefloor = nf;\n\t\treturn false;\n\t}\n\n\th = caldata->nfCalHist;\n\tclear_bit(NFCAL_PENDING, &caldata->cal_flags);\n\tath9k_hw_update_nfcal_hist_buffer(ah, caldata, nfarray);\n\tchan->noisefloor = h[0].privNF;\n\tah->noise = ath9k_hw_getchan_noise(ah, chan, chan->noisefloor);\n\treturn true;\n}\nEXPORT_SYMBOL(ath9k_hw_getnf);\n\nvoid ath9k_init_nfcal_hist_buffer(struct ath_hw *ah,\n\t\t\t\t  struct ath9k_channel *chan)\n{\n\tstruct ath9k_nfcal_hist *h;\n\tint i, j, k = 0;\n\n\tah->caldata->channel = chan->channel;\n\tah->caldata->channelFlags = chan->channelFlags;\n\th = ah->caldata->nfCalHist;\n\tfor (i = 0; i < NUM_NF_READINGS; i++) {\n\t\th[i].currIndex = 0;\n\t\th[i].privNF = ath9k_hw_get_default_nf(ah, chan, k);\n\t\th[i].invalidNFcount = AR_PHY_CCA_FILTERWINDOW_LENGTH;\n\t\tfor (j = 0; j < ATH9K_NF_CAL_HIST_MAX; j++)\n\t\t\th[i].nfCalBuffer[j] = h[i].privNF;\n\t\tif (++k >= AR5416_MAX_CHAINS)\n\t\t\tk = 0;\n\t}\n}\n\n\nvoid ath9k_hw_bstuck_nfcal(struct ath_hw *ah)\n{\n\tstruct ath9k_hw_cal_data *caldata = ah->caldata;\n\n\tif (unlikely(!caldata))\n\t\treturn;\n\n\t \n\tif (!test_bit(NFCAL_PENDING, &caldata->cal_flags))\n\t\tath9k_hw_start_nfcal(ah, true);\n\telse if (!(REG_READ(ah, AR_PHY_AGC_CONTROL(ah)) & AR_PHY_AGC_CONTROL_NF))\n\t\tath9k_hw_getnf(ah, ah->curchan);\n\n\tset_bit(NFCAL_INTF, &caldata->cal_flags);\n}\nEXPORT_SYMBOL(ath9k_hw_bstuck_nfcal);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}