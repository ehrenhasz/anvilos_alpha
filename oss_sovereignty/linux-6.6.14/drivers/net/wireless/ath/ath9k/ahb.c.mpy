{
  "module_name": "ahb.c",
  "hash_id": "ad6336ccf638b1da846003aa3411de856962e418e78cd7408092399102a755ed",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath9k/ahb.c",
  "human_readable_source": " \n\n#include <linux/nl80211.h>\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include \"ath9k.h\"\n\nstatic const struct platform_device_id ath9k_platform_id_table[] = {\n\t{\n\t\t.name = \"ath9k\",\n\t\t.driver_data = AR5416_AR9100_DEVID,\n\t},\n\t{\n\t\t.name = \"ar933x_wmac\",\n\t\t.driver_data = AR9300_DEVID_AR9330,\n\t},\n\t{\n\t\t.name = \"ar934x_wmac\",\n\t\t.driver_data = AR9300_DEVID_AR9340,\n\t},\n\t{\n\t\t.name = \"qca955x_wmac\",\n\t\t.driver_data = AR9300_DEVID_QCA955X,\n\t},\n\t{\n\t\t.name = \"qca953x_wmac\",\n\t\t.driver_data = AR9300_DEVID_AR953X,\n\t},\n\t{\n\t\t.name = \"qca956x_wmac\",\n\t\t.driver_data = AR9300_DEVID_QCA956X,\n\t},\n\t{},\n};\n\n \nstatic void ath_ahb_read_cachesize(struct ath_common *common, int *csz)\n{\n\t*csz = L1_CACHE_BYTES >> 2;\n}\n\nstatic bool ath_ahb_eeprom_read(struct ath_common *common, u32 off, u16 *data)\n{\n\tath_err(common, \"%s: eeprom data has to be provided externally\\n\",\n\t\t__func__);\n\treturn false;\n}\n\nstatic const struct ath_bus_ops ath_ahb_bus_ops  = {\n\t.ath_bus_type = ATH_AHB,\n\t.read_cachesize = ath_ahb_read_cachesize,\n\t.eeprom_read = ath_ahb_eeprom_read,\n};\n\nstatic int ath_ahb_probe(struct platform_device *pdev)\n{\n\tvoid __iomem *mem;\n\tstruct ath_softc *sc;\n\tstruct ieee80211_hw *hw;\n\tstruct resource *res;\n\tconst struct platform_device_id *id = platform_get_device_id(pdev);\n\tint irq;\n\tint ret = 0;\n\tstruct ath_hw *ah;\n\tchar hw_name[64];\n\n\tif (!dev_get_platdata(&pdev->dev)) {\n\t\tdev_err(&pdev->dev, \"no platform data specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (res == NULL) {\n\t\tdev_err(&pdev->dev, \"no memory resource found\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tmem = devm_ioremap(&pdev->dev, res->start, resource_size(res));\n\tif (mem == NULL) {\n\t\tdev_err(&pdev->dev, \"ioremap failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tath9k_fill_chanctx_ops();\n\thw = ieee80211_alloc_hw(sizeof(struct ath_softc), &ath9k_ops);\n\tif (hw == NULL) {\n\t\tdev_err(&pdev->dev, \"no memory for ieee80211_hw\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tSET_IEEE80211_DEV(hw, &pdev->dev);\n\tplatform_set_drvdata(pdev, hw);\n\n\tsc = hw->priv;\n\tsc->hw = hw;\n\tsc->dev = &pdev->dev;\n\tsc->mem = mem;\n\tsc->irq = irq;\n\n\tret = request_irq(irq, ath_isr, IRQF_SHARED, \"ath9k\", sc);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"request_irq failed\\n\");\n\t\tgoto err_free_hw;\n\t}\n\n\tret = ath9k_init_device(id->driver_data, sc, &ath_ahb_bus_ops);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to initialize device\\n\");\n\t\tgoto err_irq;\n\t}\n\n\tah = sc->sc_ah;\n\tath9k_hw_name(ah, hw_name, sizeof(hw_name));\n\twiphy_info(hw->wiphy, \"%s mem=0x%p, irq=%d\\n\",\n\t\t   hw_name, mem, irq);\n\n\treturn 0;\n\n err_irq:\n\tfree_irq(irq, sc);\n err_free_hw:\n\tieee80211_free_hw(hw);\n\treturn ret;\n}\n\nstatic int ath_ahb_remove(struct platform_device *pdev)\n{\n\tstruct ieee80211_hw *hw = platform_get_drvdata(pdev);\n\n\tif (hw) {\n\t\tstruct ath_softc *sc = hw->priv;\n\n\t\tath9k_deinit_device(sc);\n\t\tfree_irq(sc->irq, sc);\n\t\tieee80211_free_hw(sc->hw);\n\t}\n\n\treturn 0;\n}\n\nstatic struct platform_driver ath_ahb_driver = {\n\t.probe      = ath_ahb_probe,\n\t.remove     = ath_ahb_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"ath9k\",\n\t},\n\t.id_table    = ath9k_platform_id_table,\n};\n\nMODULE_DEVICE_TABLE(platform, ath9k_platform_id_table);\n\nint ath_ahb_init(void)\n{\n\treturn platform_driver_register(&ath_ahb_driver);\n}\n\nvoid ath_ahb_exit(void)\n{\n\tplatform_driver_unregister(&ath_ahb_driver);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}