{
  "module_name": "beacon.c",
  "hash_id": "167be73782d4510a12e9856706ad755058f937fabc233ff9378d22b71cb5023c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath9k/beacon.c",
  "human_readable_source": " \n\n#include <linux/dma-mapping.h>\n#include \"ath9k.h\"\n\n#define FUDGE 2\n\nstatic void ath9k_reset_beacon_status(struct ath_softc *sc)\n{\n\tsc->beacon.tx_processed = false;\n\tsc->beacon.tx_last = false;\n}\n\n \nstatic void ath9k_beaconq_config(struct ath_softc *sc)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath9k_tx_queue_info qi, qi_be;\n\tstruct ath_txq *txq;\n\n\tath9k_hw_get_txq_props(ah, sc->beacon.beaconq, &qi);\n\n\tif (sc->sc_ah->opmode == NL80211_IFTYPE_AP ||\n\t    sc->sc_ah->opmode == NL80211_IFTYPE_MESH_POINT) {\n\t\t \n\t\tqi.tqi_aifs = 1;\n\t\tqi.tqi_cwmin = 0;\n\t\tqi.tqi_cwmax = 0;\n\t} else {\n\t\t \n\t\ttxq = sc->tx.txq_map[IEEE80211_AC_BE];\n\t\tath9k_hw_get_txq_props(ah, txq->axq_qnum, &qi_be);\n\t\tqi.tqi_aifs = qi_be.tqi_aifs;\n\t\tif (ah->slottime == 20)\n\t\t\tqi.tqi_cwmin = 2*qi_be.tqi_cwmin;\n\t\telse\n\t\t\tqi.tqi_cwmin = 4*qi_be.tqi_cwmin;\n\t\tqi.tqi_cwmax = qi_be.tqi_cwmax;\n\t}\n\n\tif (!ath9k_hw_set_txq_props(ah, sc->beacon.beaconq, &qi)) {\n\t\tath_err(common, \"Unable to update h/w beacon queue parameters\\n\");\n\t} else {\n\t\tath9k_hw_resettxqueue(ah, sc->beacon.beaconq);\n\t}\n}\n\n \nstatic void ath9k_beacon_setup(struct ath_softc *sc, struct ieee80211_vif *vif,\n\t\t\t     struct ath_buf *bf, int rateidx)\n{\n\tstruct sk_buff *skb = bf->bf_mpdu;\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath_tx_info info;\n\tstruct ieee80211_supported_band *sband;\n\tu8 chainmask = ah->txchainmask;\n\tu8 i, rate = 0;\n\n\tsband = &common->sbands[sc->cur_chandef.chan->band];\n\trate = sband->bitrates[rateidx].hw_value;\n\tif (vif->bss_conf.use_short_preamble)\n\t\trate |= sband->bitrates[rateidx].hw_value_short;\n\n\tmemset(&info, 0, sizeof(info));\n\tinfo.pkt_len = skb->len + FCS_LEN;\n\tinfo.type = ATH9K_PKT_TYPE_BEACON;\n\tfor (i = 0; i < 4; i++)\n\t\tinfo.txpower[i] = MAX_RATE_POWER;\n\tinfo.keyix = ATH9K_TXKEYIX_INVALID;\n\tinfo.keytype = ATH9K_KEY_TYPE_CLEAR;\n\tinfo.flags = ATH9K_TXDESC_NOACK | ATH9K_TXDESC_CLRDMASK;\n\n\tinfo.buf_addr[0] = bf->bf_buf_addr;\n\tinfo.buf_len[0] = roundup(skb->len, 4);\n\n\tinfo.is_first = true;\n\tinfo.is_last = true;\n\n\tinfo.qcu = sc->beacon.beaconq;\n\n\tinfo.rates[0].Tries = 1;\n\tinfo.rates[0].Rate = rate;\n\tinfo.rates[0].ChSel = ath_txchainmask_reduction(sc, chainmask, rate);\n\n\tath9k_hw_set_txdesc(ah, bf->bf_desc, &info);\n}\n\nstatic struct ath_buf *ath9k_beacon_generate(struct ieee80211_hw *hw,\n\t\t\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct ath_softc *sc = hw->priv;\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ath_buf *bf;\n\tstruct ath_vif *avp = (void *)vif->drv_priv;\n\tstruct sk_buff *skb;\n\tstruct ath_txq *cabq = sc->beacon.cabq;\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211_mgmt *mgmt_hdr;\n\tint cabq_depth;\n\n\tif (avp->av_bcbuf == NULL)\n\t\treturn NULL;\n\n\tbf = avp->av_bcbuf;\n\tskb = bf->bf_mpdu;\n\tif (skb) {\n\t\tdma_unmap_single(sc->dev, bf->bf_buf_addr,\n\t\t\t\t skb->len, DMA_TO_DEVICE);\n\t\tdev_kfree_skb_any(skb);\n\t\tbf->bf_buf_addr = 0;\n\t\tbf->bf_mpdu = NULL;\n\t}\n\n\tskb = ieee80211_beacon_get(hw, vif, 0);\n\tif (skb == NULL)\n\t\treturn NULL;\n\n\tbf->bf_mpdu = skb;\n\n\tmgmt_hdr = (struct ieee80211_mgmt *)skb->data;\n\tmgmt_hdr->u.beacon.timestamp = avp->tsf_adjust;\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\n\tath_assign_seq(common, skb);\n\n\t \n\tif (ath9k_is_chanctx_enabled())\n\t\tath9k_beacon_add_noa(sc, avp, skb);\n\n\tbf->bf_buf_addr = dma_map_single(sc->dev, skb->data,\n\t\t\t\t\t skb->len, DMA_TO_DEVICE);\n\tif (unlikely(dma_mapping_error(sc->dev, bf->bf_buf_addr))) {\n\t\tdev_kfree_skb_any(skb);\n\t\tbf->bf_mpdu = NULL;\n\t\tbf->bf_buf_addr = 0;\n\t\tath_err(common, \"dma_mapping_error on beaconing\\n\");\n\t\treturn NULL;\n\t}\n\n\tskb = ieee80211_get_buffered_bc(hw, vif);\n\n\t \n\tspin_lock_bh(&cabq->axq_lock);\n\tcabq_depth = cabq->axq_depth;\n\tspin_unlock_bh(&cabq->axq_lock);\n\n\tif (skb && cabq_depth) {\n\t\tif (sc->cur_chan->nvifs > 1) {\n\t\t\tath_dbg(common, BEACON,\n\t\t\t\t\"Flushing previous cabq traffic\\n\");\n\t\t\tath_draintxq(sc, cabq);\n\t\t}\n\t}\n\n\tath9k_beacon_setup(sc, vif, bf, info->control.rates[0].idx);\n\n\tif (skb)\n\t\tath_tx_cabq(hw, vif, skb);\n\n\treturn bf;\n}\n\nvoid ath9k_beacon_assign_slot(struct ath_softc *sc, struct ieee80211_vif *vif)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ath_vif *avp = (void *)vif->drv_priv;\n\tint slot;\n\n\tavp->av_bcbuf = list_first_entry(&sc->beacon.bbuf, struct ath_buf, list);\n\tlist_del(&avp->av_bcbuf->list);\n\n\tfor (slot = 0; slot < ATH_BCBUF; slot++) {\n\t\tif (sc->beacon.bslot[slot] == NULL) {\n\t\t\tavp->av_bslot = slot;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tsc->beacon.bslot[avp->av_bslot] = vif;\n\n\tath_dbg(common, CONFIG, \"Added interface at beacon slot: %d\\n\",\n\t\tavp->av_bslot);\n}\n\nvoid ath9k_beacon_remove_slot(struct ath_softc *sc, struct ieee80211_vif *vif)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ath_vif *avp = (void *)vif->drv_priv;\n\tstruct ath_buf *bf = avp->av_bcbuf;\n\n\tath_dbg(common, CONFIG, \"Removing interface at beacon slot: %d\\n\",\n\t\tavp->av_bslot);\n\n\ttasklet_disable(&sc->bcon_tasklet);\n\n\tif (bf && bf->bf_mpdu) {\n\t\tstruct sk_buff *skb = bf->bf_mpdu;\n\t\tdma_unmap_single(sc->dev, bf->bf_buf_addr,\n\t\t\t\t skb->len, DMA_TO_DEVICE);\n\t\tdev_kfree_skb_any(skb);\n\t\tbf->bf_mpdu = NULL;\n\t\tbf->bf_buf_addr = 0;\n\t}\n\n\tavp->av_bcbuf = NULL;\n\tsc->beacon.bslot[avp->av_bslot] = NULL;\n\tlist_add_tail(&bf->list, &sc->beacon.bbuf);\n\n\ttasklet_enable(&sc->bcon_tasklet);\n}\n\nvoid ath9k_beacon_ensure_primary_slot(struct ath_softc *sc)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ieee80211_vif *vif;\n\tstruct ath_vif *avp;\n\ts64 tsfadjust;\n\tu32 offset;\n\tint first_slot = ATH_BCBUF;\n\tint slot;\n\n\ttasklet_disable_in_atomic(&sc->bcon_tasklet);\n\n\t \n\tfor (slot = 0; slot < ATH_BCBUF; slot++) {\n\t\tif (sc->beacon.bslot[slot]) {\n\t\t\tfirst_slot = slot;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (first_slot == 0)\n\t\tgoto out;\n\n\t \n\tfor (slot = 0; slot < ATH_BCBUF; slot++) {\n\t\tif (slot + first_slot < ATH_BCBUF) {\n\t\t\tvif = sc->beacon.bslot[slot + first_slot];\n\t\t\tsc->beacon.bslot[slot] = vif;\n\n\t\t\tif (vif) {\n\t\t\t\tavp = (void *)vif->drv_priv;\n\t\t\t\tavp->av_bslot = slot;\n\t\t\t}\n\t\t} else {\n\t\t\tsc->beacon.bslot[slot] = NULL;\n\t\t}\n\t}\n\n\tvif = sc->beacon.bslot[0];\n\tif (WARN_ON(!vif))\n\t\tgoto out;\n\n\t \n\tavp = (void *)vif->drv_priv;\n\ttsfadjust = le64_to_cpu(avp->tsf_adjust);\n\n\tath_dbg(common, CONFIG,\n\t\t\"Adjusting global TSF after beacon slot reassignment: %lld\\n\",\n\t\t(signed long long)tsfadjust);\n\n\t \n\tavp->chanctx->tsf_val += tsfadjust;\n\tif (sc->cur_chan == avp->chanctx) {\n\t\toffset = ath9k_hw_get_tsf_offset(&avp->chanctx->tsf_ts, NULL);\n\t\tath9k_hw_settsf64(sc->sc_ah, avp->chanctx->tsf_val + offset);\n\t}\n\n\t \n\nout:\n\ttasklet_enable(&sc->bcon_tasklet);\n}\n\nstatic int ath9k_beacon_choose_slot(struct ath_softc *sc)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ath_beacon_config *cur_conf = &sc->cur_chan->beacon;\n\tu16 intval;\n\tu32 tsftu;\n\tu64 tsf;\n\tint slot;\n\n\tif (sc->sc_ah->opmode != NL80211_IFTYPE_AP &&\n\t    sc->sc_ah->opmode != NL80211_IFTYPE_MESH_POINT) {\n\t\tath_dbg(common, BEACON, \"slot 0, tsf: %llu\\n\",\n\t\t\tath9k_hw_gettsf64(sc->sc_ah));\n\t\treturn 0;\n\t}\n\n\tintval = cur_conf->beacon_interval ? : ATH_DEFAULT_BINTVAL;\n\ttsf = ath9k_hw_gettsf64(sc->sc_ah);\n\ttsf += TU_TO_USEC(sc->sc_ah->config.sw_beacon_response_time);\n\ttsftu = TSF_TO_TU((tsf * ATH_BCBUF) >>32, tsf * ATH_BCBUF);\n\tslot = (tsftu % (intval * ATH_BCBUF)) / intval;\n\n\tath_dbg(common, BEACON, \"slot: %d tsf: %llu tsftu: %u\\n\",\n\t\tslot, tsf, tsftu / ATH_BCBUF);\n\n\treturn slot;\n}\n\nstatic void ath9k_set_tsfadjust(struct ath_softc *sc,\n\t\t\t\tstruct ath_beacon_config *cur_conf)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\ts64 tsfadjust;\n\tint slot;\n\n\tfor (slot = 0; slot < ATH_BCBUF; slot++) {\n\t\tstruct ath_vif *avp;\n\n\t\tif (!sc->beacon.bslot[slot])\n\t\t\tcontinue;\n\n\t\tavp = (void *)sc->beacon.bslot[slot]->drv_priv;\n\n\t\t \n\t\ttsfadjust = cur_conf->beacon_interval * avp->av_bslot;\n\t\ttsfadjust = -TU_TO_USEC(tsfadjust) / ATH_BCBUF;\n\t\tavp->tsf_adjust = cpu_to_le64(tsfadjust);\n\n\t\tath_dbg(common, CONFIG, \"tsfadjust is: %lld for bslot: %d\\n\",\n\t\t\t(signed long long)tsfadjust, avp->av_bslot);\n\t}\n}\n\nbool ath9k_csa_is_finished(struct ath_softc *sc, struct ieee80211_vif *vif)\n{\n\tif (!vif || !vif->bss_conf.csa_active)\n\t\treturn false;\n\n\tif (!ieee80211_beacon_cntdwn_is_complete(vif))\n\t\treturn false;\n\n\tieee80211_csa_finish(vif);\n\treturn true;\n}\n\nstatic void ath9k_csa_update_vif(void *data, u8 *mac, struct ieee80211_vif *vif)\n{\n\tstruct ath_softc *sc = data;\n\tath9k_csa_is_finished(sc, vif);\n}\n\nvoid ath9k_csa_update(struct ath_softc *sc)\n{\n\tieee80211_iterate_active_interfaces_atomic(sc->hw,\n\t\t\t\t\t\t   IEEE80211_IFACE_ITER_NORMAL,\n\t\t\t\t\t\t   ath9k_csa_update_vif, sc);\n}\n\nvoid ath9k_beacon_tasklet(struct tasklet_struct *t)\n{\n\tstruct ath_softc *sc = from_tasklet(sc, t, bcon_tasklet);\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath_buf *bf = NULL;\n\tstruct ieee80211_vif *vif;\n\tbool edma = !!(ah->caps.hw_caps & ATH9K_HW_CAP_EDMA);\n\tint slot;\n\n\tif (test_bit(ATH_OP_HW_RESET, &common->op_flags)) {\n\t\tath_dbg(common, RESET,\n\t\t\t\"reset work is pending, skip beaconing now\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (ath9k_hw_numtxpending(ah, sc->beacon.beaconq) != 0) {\n\t\tsc->beacon.bmisscnt++;\n\n\t\tath9k_hw_check_nav(ah);\n\n\t\t \n\t\tif (!ath_hw_check(sc))\n\t\t\treturn;\n\n\t\tif (sc->beacon.bmisscnt < BSTUCK_THRESH * sc->nbcnvifs) {\n\t\t\tath_dbg(common, BSTUCK,\n\t\t\t\t\"missed %u consecutive beacons\\n\",\n\t\t\t\tsc->beacon.bmisscnt);\n\t\t\tath9k_hw_stop_dma_queue(ah, sc->beacon.beaconq);\n\t\t\tif (sc->beacon.bmisscnt > 3)\n\t\t\t\tath9k_hw_bstuck_nfcal(ah);\n\t\t} else if (sc->beacon.bmisscnt >= BSTUCK_THRESH) {\n\t\t\tath_dbg(common, BSTUCK, \"beacon is officially stuck\\n\");\n\t\t\tsc->beacon.bmisscnt = 0;\n\t\t\tath9k_queue_reset(sc, RESET_TYPE_BEACON_STUCK);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tslot = ath9k_beacon_choose_slot(sc);\n\tvif = sc->beacon.bslot[slot];\n\n\t \n\tif (!edma) {\n\t\tif (ath9k_is_chanctx_enabled()) {\n\t\t\tath_chanctx_beacon_sent_ev(sc,\n\t\t\t\t\t  ATH_CHANCTX_EVENT_BEACON_SENT);\n\t\t}\n\n\t\tif (ath9k_csa_is_finished(sc, vif))\n\t\t\treturn;\n\t}\n\n\tif (!vif || !vif->bss_conf.enable_beacon)\n\t\treturn;\n\n\tif (ath9k_is_chanctx_enabled()) {\n\t\tath_chanctx_event(sc, vif, ATH_CHANCTX_EVENT_BEACON_PREPARE);\n\t}\n\n\tbf = ath9k_beacon_generate(sc->hw, vif);\n\n\tif (sc->beacon.bmisscnt != 0) {\n\t\tath_dbg(common, BSTUCK, \"resume beacon xmit after %u misses\\n\",\n\t\t\tsc->beacon.bmisscnt);\n\t\tsc->beacon.bmisscnt = 0;\n\t}\n\n\t \n\tif (sc->beacon.updateslot == UPDATE) {\n\t\tsc->beacon.updateslot = COMMIT;\n\t\tsc->beacon.slotupdate = slot;\n\t} else if (sc->beacon.updateslot == COMMIT &&\n\t\t   sc->beacon.slotupdate == slot) {\n\t\tah->slottime = sc->beacon.slottime;\n\t\tath9k_hw_init_global_settings(ah);\n\t\tsc->beacon.updateslot = OK;\n\t}\n\n\tif (bf) {\n\t\tath9k_reset_beacon_status(sc);\n\n\t\tath_dbg(common, BEACON,\n\t\t\t\"Transmitting beacon for slot: %d\\n\", slot);\n\n\t\t \n\t\tath9k_hw_puttxbuf(ah, sc->beacon.beaconq, bf->bf_daddr);\n\n\t\tif (!edma)\n\t\t\tath9k_hw_txstart(ah, sc->beacon.beaconq);\n\t}\n}\n\n \nstatic void ath9k_beacon_init(struct ath_softc *sc, u32 nexttbtt,\n\t\t\t      u32 intval)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\n\tath9k_hw_disable_interrupts(ah);\n\tath9k_beaconq_config(sc);\n\tath9k_hw_beaconinit(ah, nexttbtt, intval);\n\tah->imask |= ATH9K_INT_SWBA;\n\tsc->beacon.bmisscnt = 0;\n\tath9k_hw_set_interrupts(ah);\n\tath9k_hw_enable_interrupts(ah);\n}\n\nstatic void ath9k_beacon_stop(struct ath_softc *sc)\n{\n\tath9k_hw_disable_interrupts(sc->sc_ah);\n\tsc->sc_ah->imask &= ~(ATH9K_INT_SWBA | ATH9K_INT_BMISS);\n\tsc->beacon.bmisscnt = 0;\n\tath9k_hw_set_interrupts(sc->sc_ah);\n\tath9k_hw_enable_interrupts(sc->sc_ah);\n}\n\n \nstatic void ath9k_beacon_config_ap(struct ath_softc *sc,\n\t\t\t\t   struct ath_beacon_config *conf)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\n\tath9k_cmn_beacon_config_ap(ah, conf, ATH_BCBUF);\n\tath9k_beacon_init(sc, conf->nexttbtt, conf->intval);\n}\n\nstatic void ath9k_beacon_config_sta(struct ath_hw *ah,\n\t\t\t\t    struct ath_beacon_config *conf)\n{\n\tstruct ath9k_beacon_state bs;\n\n\tif (ath9k_cmn_beacon_config_sta(ah, conf, &bs) == -EPERM)\n\t\treturn;\n\n\tath9k_hw_disable_interrupts(ah);\n\tath9k_hw_set_sta_beacon_timers(ah, &bs);\n\tah->imask |= ATH9K_INT_BMISS;\n\n\tath9k_hw_set_interrupts(ah);\n\tath9k_hw_enable_interrupts(ah);\n}\n\nstatic void ath9k_beacon_config_adhoc(struct ath_softc *sc,\n\t\t\t\t      struct ath_beacon_config *conf)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\n\tath9k_reset_beacon_status(sc);\n\n\tath9k_cmn_beacon_config_adhoc(ah, conf);\n\n\tath9k_beacon_init(sc, conf->nexttbtt, conf->intval);\n\n\t \n\tif (!conf->ibss_creator && conf->enable_beacon)\n\t\tset_bit(ATH_OP_BEACONS, &common->op_flags);\n}\n\nstatic void ath9k_cache_beacon_config(struct ath_softc *sc,\n\t\t\t\t      struct ath_chanctx *ctx,\n\t\t\t\t      struct ieee80211_vif *vif)\n{\n\tstruct ieee80211_bss_conf *bss_conf = &vif->bss_conf;\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ath_beacon_config *cur_conf = &ctx->beacon;\n\n\tath_dbg(common, BEACON,\n\t\t\"Caching beacon data for BSS: %pM\\n\", bss_conf->bssid);\n\n\tcur_conf->beacon_interval = bss_conf->beacon_int;\n\tcur_conf->dtim_period = bss_conf->dtim_period;\n\tcur_conf->dtim_count = 1;\n\tcur_conf->ibss_creator = vif->cfg.ibss_creator;\n\n\t \n\tif (cur_conf->beacon_interval == 0)\n\t\tcur_conf->beacon_interval = 100;\n\n\tcur_conf->bmiss_timeout =\n\t\tATH_DEFAULT_BMISS_LIMIT * cur_conf->beacon_interval;\n\n\t \n\tif (cur_conf->dtim_period == 0)\n\t\tcur_conf->dtim_period = 1;\n\n\tath9k_set_tsfadjust(sc, cur_conf);\n}\n\nvoid ath9k_beacon_config(struct ath_softc *sc, struct ieee80211_vif *main_vif,\n\t\t\t bool beacons)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath_vif *avp;\n\tstruct ath_chanctx *ctx;\n\tstruct ath_beacon_config *cur_conf;\n\tunsigned long flags;\n\tbool enabled;\n\tbool skip_beacon = false;\n\n\tif (!beacons) {\n\t\tclear_bit(ATH_OP_BEACONS, &common->op_flags);\n\t\tath9k_beacon_stop(sc);\n\t\treturn;\n\t}\n\n\tif (WARN_ON(!main_vif))\n\t\treturn;\n\n\tavp = (void *)main_vif->drv_priv;\n\tctx = avp->chanctx;\n\tcur_conf = &ctx->beacon;\n\tenabled = cur_conf->enable_beacon;\n\tcur_conf->enable_beacon = beacons;\n\n\tif (sc->sc_ah->opmode == NL80211_IFTYPE_STATION) {\n\t\tath9k_cache_beacon_config(sc, ctx, main_vif);\n\n\t\tath9k_set_beacon(sc);\n\t\tset_bit(ATH_OP_BEACONS, &common->op_flags);\n\t\treturn;\n\t}\n\n\t \n\tath9k_cache_beacon_config(sc, ctx, main_vif);\n\n\t \n\tif (cur_conf->beacon_interval) {\n\t\t \n\t\tif (sc->sc_ah->opmode == NL80211_IFTYPE_ADHOC &&\n\t\t    !enabled && beacons && !main_vif->cfg.ibss_creator) {\n\t\t\tspin_lock_irqsave(&sc->sc_pm_lock, flags);\n\t\t\tsc->ps_flags |= PS_BEACON_SYNC | PS_WAIT_FOR_BEACON;\n\t\t\tspin_unlock_irqrestore(&sc->sc_pm_lock, flags);\n\t\t\tskip_beacon = true;\n\t\t}\n\n\t\t \n\t\tif (beacons && !skip_beacon) {\n\t\t\tset_bit(ATH_OP_BEACONS, &common->op_flags);\n\t\t\tath9k_set_beacon(sc);\n\t\t} else {\n\t\t\tclear_bit(ATH_OP_BEACONS, &common->op_flags);\n\t\t\tath9k_beacon_stop(sc);\n\t\t}\n\t} else {\n\t\tclear_bit(ATH_OP_BEACONS, &common->op_flags);\n\t\tath9k_beacon_stop(sc);\n\t}\n}\n\nvoid ath9k_set_beacon(struct ath_softc *sc)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ath_beacon_config *cur_conf = &sc->cur_chan->beacon;\n\n\tswitch (sc->sc_ah->opmode) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tath9k_beacon_config_ap(sc, cur_conf);\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tath9k_beacon_config_adhoc(sc, cur_conf);\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tath9k_beacon_config_sta(sc->sc_ah, cur_conf);\n\t\tbreak;\n\tdefault:\n\t\tath_dbg(common, CONFIG, \"Unsupported beaconing mode\\n\");\n\t\treturn;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}