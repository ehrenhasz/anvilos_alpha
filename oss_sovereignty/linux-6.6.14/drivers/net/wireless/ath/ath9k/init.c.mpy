{
  "module_name": "init.c",
  "hash_id": "0caaa39bc89af26979292880c548a7e28fd489707bf0a9938e238e47384dd000",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath9k/init.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/dma-mapping.h>\n#include <linux/slab.h>\n#include <linux/ath9k_platform.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_net.h>\n#include <linux/nvmem-consumer.h>\n#include <linux/relay.h>\n#include <linux/dmi.h>\n#include <net/ieee80211_radiotap.h>\n\n#include \"ath9k.h\"\n\nstruct ath9k_eeprom_ctx {\n\tstruct completion complete;\n\tstruct ath_hw *ah;\n};\n\nstatic char *dev_info = \"ath9k\";\n\nMODULE_AUTHOR(\"Atheros Communications\");\nMODULE_DESCRIPTION(\"Support for Atheros 802.11n wireless LAN cards.\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n\nstatic unsigned int ath9k_debug = ATH_DBG_DEFAULT;\nmodule_param_named(debug, ath9k_debug, uint, 0);\nMODULE_PARM_DESC(debug, \"Debugging mask\");\n\nint ath9k_modparam_nohwcrypt;\nmodule_param_named(nohwcrypt, ath9k_modparam_nohwcrypt, int, 0444);\nMODULE_PARM_DESC(nohwcrypt, \"Disable hardware encryption\");\n\nint ath9k_led_blink;\nmodule_param_named(blink, ath9k_led_blink, int, 0444);\nMODULE_PARM_DESC(blink, \"Enable LED blink on activity\");\n\nstatic int ath9k_led_active_high = -1;\nmodule_param_named(led_active_high, ath9k_led_active_high, int, 0444);\nMODULE_PARM_DESC(led_active_high, \"Invert LED polarity\");\n\nstatic int ath9k_btcoex_enable;\nmodule_param_named(btcoex_enable, ath9k_btcoex_enable, int, 0444);\nMODULE_PARM_DESC(btcoex_enable, \"Enable wifi-BT coexistence\");\n\nstatic int ath9k_bt_ant_diversity;\nmodule_param_named(bt_ant_diversity, ath9k_bt_ant_diversity, int, 0444);\nMODULE_PARM_DESC(bt_ant_diversity, \"Enable WLAN/BT RX antenna diversity\");\n\nstatic int ath9k_ps_enable;\nmodule_param_named(ps_enable, ath9k_ps_enable, int, 0444);\nMODULE_PARM_DESC(ps_enable, \"Enable WLAN PowerSave\");\n\n#ifdef CONFIG_ATH9K_CHANNEL_CONTEXT\n\nint ath9k_use_chanctx;\nmodule_param_named(use_chanctx, ath9k_use_chanctx, int, 0444);\nMODULE_PARM_DESC(use_chanctx, \"Enable channel context for concurrency\");\n\n#endif  \n\nint ath9k_use_msi;\nmodule_param_named(use_msi, ath9k_use_msi, int, 0444);\nMODULE_PARM_DESC(use_msi, \"Use MSI instead of INTx if possible\");\n\nbool is_ath9k_unloaded;\n\n#ifdef CONFIG_MAC80211_LEDS\nstatic const struct ieee80211_tpt_blink ath9k_tpt_blink[] = {\n\t{ .throughput = 0 * 1024, .blink_time = 334 },\n\t{ .throughput = 1 * 1024, .blink_time = 260 },\n\t{ .throughput = 5 * 1024, .blink_time = 220 },\n\t{ .throughput = 10 * 1024, .blink_time = 190 },\n\t{ .throughput = 20 * 1024, .blink_time = 170 },\n\t{ .throughput = 50 * 1024, .blink_time = 150 },\n\t{ .throughput = 70 * 1024, .blink_time = 130 },\n\t{ .throughput = 100 * 1024, .blink_time = 110 },\n\t{ .throughput = 200 * 1024, .blink_time = 80 },\n\t{ .throughput = 300 * 1024, .blink_time = 50 },\n};\n#endif\n\nstatic int __init set_use_msi(const struct dmi_system_id *dmi)\n{\n\tath9k_use_msi = 1;\n\treturn 1;\n}\n\nstatic const struct dmi_system_id ath9k_quirks[] __initconst = {\n\t{\n\t\t.callback = set_use_msi,\n\t\t.ident = \"Dell Inspiron 24-3460\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Inspiron 24-3460\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = set_use_msi,\n\t\t.ident = \"Dell Vostro 3262\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Vostro 3262\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = set_use_msi,\n\t\t.ident = \"Dell Inspiron 3472\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Inspiron 3472\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = set_use_msi,\n\t\t.ident = \"Dell Vostro 15-3572\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Vostro 15-3572\"),\n\t\t},\n\t},\n\t{\n\t\t.callback = set_use_msi,\n\t\t.ident = \"Dell Inspiron 14-3473\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Inspiron 14-3473\"),\n\t\t},\n\t},\n\t{}\n};\n\nstatic void ath9k_deinit_softc(struct ath_softc *sc);\n\nstatic void ath9k_op_ps_wakeup(struct ath_common *common)\n{\n\tath9k_ps_wakeup((struct ath_softc *) common->priv);\n}\n\nstatic void ath9k_op_ps_restore(struct ath_common *common)\n{\n\tath9k_ps_restore((struct ath_softc *) common->priv);\n}\n\nstatic const struct ath_ps_ops ath9k_ps_ops = {\n\t.wakeup = ath9k_op_ps_wakeup,\n\t.restore = ath9k_op_ps_restore,\n};\n\n \n\nstatic void ath9k_iowrite32(void *hw_priv, u32 val, u32 reg_offset)\n{\n\tstruct ath_hw *ah = hw_priv;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath_softc *sc = (struct ath_softc *) common->priv;\n\n\tif (NR_CPUS > 1 && ah->config.serialize_regmode == SER_REG_MODE_ON) {\n\t\tunsigned long flags;\n\t\tspin_lock_irqsave(&sc->sc_serial_rw, flags);\n\t\tiowrite32(val, sc->mem + reg_offset);\n\t\tspin_unlock_irqrestore(&sc->sc_serial_rw, flags);\n\t} else\n\t\tiowrite32(val, sc->mem + reg_offset);\n}\n\nstatic unsigned int ath9k_ioread32(void *hw_priv, u32 reg_offset)\n{\n\tstruct ath_hw *ah = hw_priv;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath_softc *sc = (struct ath_softc *) common->priv;\n\tu32 val;\n\n\tif (NR_CPUS > 1 && ah->config.serialize_regmode == SER_REG_MODE_ON) {\n\t\tunsigned long flags;\n\t\tspin_lock_irqsave(&sc->sc_serial_rw, flags);\n\t\tval = ioread32(sc->mem + reg_offset);\n\t\tspin_unlock_irqrestore(&sc->sc_serial_rw, flags);\n\t} else\n\t\tval = ioread32(sc->mem + reg_offset);\n\treturn val;\n}\n\nstatic void ath9k_multi_ioread32(void *hw_priv, u32 *addr,\n                                u32 *val, u16 count)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++)\n\t\tval[i] = ath9k_ioread32(hw_priv, addr[i]);\n}\n\n\nstatic unsigned int __ath9k_reg_rmw(struct ath_softc *sc, u32 reg_offset,\n\t\t\t\t    u32 set, u32 clr)\n{\n\tu32 val;\n\n\tval = ioread32(sc->mem + reg_offset);\n\tval &= ~clr;\n\tval |= set;\n\tiowrite32(val, sc->mem + reg_offset);\n\n\treturn val;\n}\n\nstatic unsigned int ath9k_reg_rmw(void *hw_priv, u32 reg_offset, u32 set, u32 clr)\n{\n\tstruct ath_hw *ah = hw_priv;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath_softc *sc = (struct ath_softc *) common->priv;\n\tunsigned long flags;\n\tu32 val;\n\n\tif (NR_CPUS > 1 && ah->config.serialize_regmode == SER_REG_MODE_ON) {\n\t\tspin_lock_irqsave(&sc->sc_serial_rw, flags);\n\t\tval = __ath9k_reg_rmw(sc, reg_offset, set, clr);\n\t\tspin_unlock_irqrestore(&sc->sc_serial_rw, flags);\n\t} else\n\t\tval = __ath9k_reg_rmw(sc, reg_offset, set, clr);\n\n\treturn val;\n}\n\n \n \n \n\nstatic void ath9k_reg_notifier(struct wiphy *wiphy,\n\t\t\t       struct regulatory_request *request)\n{\n\tstruct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);\n\tstruct ath_softc *sc = hw->priv;\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_regulatory *reg = ath9k_hw_regulatory(ah);\n\n\tath_reg_notifier_apply(wiphy, request, reg);\n\n\t \n\tif (sc->dfs_detector != NULL)\n\t\tsc->dfs_detector->set_dfs_domain(sc->dfs_detector,\n\t\t\t\t\t\t request->dfs_region);\n\n\t \n\tif (!ah->curchan)\n\t\treturn;\n\n\tsc->cur_chan->txpower = 2 * ah->curchan->chan->max_power;\n\tath9k_ps_wakeup(sc);\n\tath9k_hw_set_txpowerlimit(ah, sc->cur_chan->txpower, false);\n\tath9k_cmn_update_txpow(ah, sc->cur_chan->cur_txpower,\n\t\t\t       sc->cur_chan->txpower,\n\t\t\t       &sc->cur_chan->cur_txpower);\n\tath9k_ps_restore(sc);\n}\n\n \nint ath_descdma_setup(struct ath_softc *sc, struct ath_descdma *dd,\n\t\t      struct list_head *head, const char *name,\n\t\t      int nbuf, int ndesc, bool is_tx)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tu8 *ds;\n\tint i, bsize, desc_len;\n\n\tath_dbg(common, CONFIG, \"%s DMA: %u buffers %u desc/buf\\n\",\n\t\tname, nbuf, ndesc);\n\n\tINIT_LIST_HEAD(head);\n\n\tif (is_tx)\n\t\tdesc_len = sc->sc_ah->caps.tx_desc_len;\n\telse\n\t\tdesc_len = sizeof(struct ath_desc);\n\n\t \n\tif ((desc_len % 4) != 0) {\n\t\tath_err(common, \"ath_desc not DWORD aligned\\n\");\n\t\tBUG_ON((desc_len % 4) != 0);\n\t\treturn -ENOMEM;\n\t}\n\n\tdd->dd_desc_len = desc_len * nbuf * ndesc;\n\n\t \n\tif (!(sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_4KB_SPLITTRANS)) {\n\t\tu32 ndesc_skipped =\n\t\t\tATH_DESC_4KB_BOUND_NUM_SKIPPED(dd->dd_desc_len);\n\t\tu32 dma_len;\n\n\t\twhile (ndesc_skipped) {\n\t\t\tdma_len = ndesc_skipped * desc_len;\n\t\t\tdd->dd_desc_len += dma_len;\n\n\t\t\tndesc_skipped = ATH_DESC_4KB_BOUND_NUM_SKIPPED(dma_len);\n\t\t}\n\t}\n\n\t \n\tdd->dd_desc = dmam_alloc_coherent(sc->dev, dd->dd_desc_len,\n\t\t\t\t\t  &dd->dd_desc_paddr, GFP_KERNEL);\n\tif (!dd->dd_desc)\n\t\treturn -ENOMEM;\n\n\tds = dd->dd_desc;\n\tath_dbg(common, CONFIG, \"%s DMA map: %p (%u) -> %llx (%u)\\n\",\n\t\tname, ds, (u32) dd->dd_desc_len,\n\t\tito64(dd->dd_desc_paddr),  (u32) dd->dd_desc_len);\n\n\t \n\tif (is_tx) {\n\t\tstruct ath_buf *bf;\n\n\t\tbsize = sizeof(struct ath_buf) * nbuf;\n\t\tbf = devm_kzalloc(sc->dev, bsize, GFP_KERNEL);\n\t\tif (!bf)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (i = 0; i < nbuf; i++, bf++, ds += (desc_len * ndesc)) {\n\t\t\tbf->bf_desc = ds;\n\t\t\tbf->bf_daddr = DS2PHYS(dd, ds);\n\n\t\t\tif (!(sc->sc_ah->caps.hw_caps &\n\t\t\t\t  ATH9K_HW_CAP_4KB_SPLITTRANS)) {\n\t\t\t\t \n\t\t\t\twhile (ATH_DESC_4KB_BOUND_CHECK(bf->bf_daddr)) {\n\t\t\t\t\tBUG_ON((caddr_t) bf->bf_desc >=\n\t\t\t\t\t\t   ((caddr_t) dd->dd_desc +\n\t\t\t\t\t\tdd->dd_desc_len));\n\n\t\t\t\t\tds += (desc_len * ndesc);\n\t\t\t\t\tbf->bf_desc = ds;\n\t\t\t\t\tbf->bf_daddr = DS2PHYS(dd, ds);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlist_add_tail(&bf->list, head);\n\t\t}\n\t} else {\n\t\tstruct ath_rxbuf *bf;\n\n\t\tbsize = sizeof(struct ath_rxbuf) * nbuf;\n\t\tbf = devm_kzalloc(sc->dev, bsize, GFP_KERNEL);\n\t\tif (!bf)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (i = 0; i < nbuf; i++, bf++, ds += (desc_len * ndesc)) {\n\t\t\tbf->bf_desc = ds;\n\t\t\tbf->bf_daddr = DS2PHYS(dd, ds);\n\n\t\t\tif (!(sc->sc_ah->caps.hw_caps &\n\t\t\t\t  ATH9K_HW_CAP_4KB_SPLITTRANS)) {\n\t\t\t\t \n\t\t\t\twhile (ATH_DESC_4KB_BOUND_CHECK(bf->bf_daddr)) {\n\t\t\t\t\tBUG_ON((caddr_t) bf->bf_desc >=\n\t\t\t\t\t\t   ((caddr_t) dd->dd_desc +\n\t\t\t\t\t\tdd->dd_desc_len));\n\n\t\t\t\t\tds += (desc_len * ndesc);\n\t\t\t\t\tbf->bf_desc = ds;\n\t\t\t\t\tbf->bf_daddr = DS2PHYS(dd, ds);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlist_add_tail(&bf->list, head);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int ath9k_init_queues(struct ath_softc *sc)\n{\n\tint i = 0;\n\n\tsc->beacon.beaconq = ath9k_hw_beaconq_setup(sc->sc_ah);\n\tsc->beacon.cabq = ath_txq_setup(sc, ATH9K_TX_QUEUE_CAB, 0);\n\tath_cabq_update(sc);\n\n\tsc->tx.uapsdq = ath_txq_setup(sc, ATH9K_TX_QUEUE_UAPSD, 0);\n\n\tfor (i = 0; i < IEEE80211_NUM_ACS; i++) {\n\t\tsc->tx.txq_map[i] = ath_txq_setup(sc, ATH9K_TX_QUEUE_DATA, i);\n\t\tsc->tx.txq_map[i]->mac80211_qnum = i;\n\t}\n\treturn 0;\n}\n\nstatic void ath9k_init_misc(struct ath_softc *sc)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tint i = 0;\n\n\ttimer_setup(&common->ani.timer, ath_ani_calibrate, 0);\n\n\tcommon->last_rssi = ATH_RSSI_DUMMY_MARKER;\n\teth_broadcast_addr(common->bssidmask);\n\tsc->beacon.slottime = 9;\n\n\tfor (i = 0; i < ARRAY_SIZE(sc->beacon.bslot); i++)\n\t\tsc->beacon.bslot[i] = NULL;\n\n\tif (sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_ANT_DIV_COMB)\n\t\tsc->ant_comb.count = ATH_ANT_DIV_COMB_INIT_COUNT;\n\n\tsc->spec_priv.ah = sc->sc_ah;\n\tsc->spec_priv.spec_config.enabled = 0;\n\tsc->spec_priv.spec_config.short_repeat = true;\n\tsc->spec_priv.spec_config.count = 8;\n\tsc->spec_priv.spec_config.endless = false;\n\tsc->spec_priv.spec_config.period = 0xFF;\n\tsc->spec_priv.spec_config.fft_period = 0xF;\n}\n\nstatic void ath9k_init_pcoem_platform(struct ath_softc *sc)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath9k_hw_capabilities *pCap = &ah->caps;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\n\tif (!IS_ENABLED(CONFIG_ATH9K_PCOEM))\n\t\treturn;\n\n\tif (common->bus_ops->ath_bus_type != ATH_PCI)\n\t\treturn;\n\n\tif (sc->driver_data & (ATH9K_PCI_CUS198 |\n\t\t\t       ATH9K_PCI_CUS230)) {\n\t\tah->config.xlna_gpio = 9;\n\t\tah->config.xatten_margin_cfg = true;\n\t\tah->config.alt_mingainidx = true;\n\t\tah->config.ant_ctrl_comm2g_switch_enable = 0x000BBB88;\n\t\tsc->ant_comb.low_rssi_thresh = 20;\n\t\tsc->ant_comb.fast_div_bias = 3;\n\n\t\tath_info(common, \"Set parameters for %s\\n\",\n\t\t\t (sc->driver_data & ATH9K_PCI_CUS198) ?\n\t\t\t \"CUS198\" : \"CUS230\");\n\t}\n\n\tif (sc->driver_data & ATH9K_PCI_CUS217)\n\t\tath_info(common, \"CUS217 card detected\\n\");\n\n\tif (sc->driver_data & ATH9K_PCI_CUS252)\n\t\tath_info(common, \"CUS252 card detected\\n\");\n\n\tif (sc->driver_data & ATH9K_PCI_AR9565_1ANT)\n\t\tath_info(common, \"WB335 1-ANT card detected\\n\");\n\n\tif (sc->driver_data & ATH9K_PCI_AR9565_2ANT)\n\t\tath_info(common, \"WB335 2-ANT card detected\\n\");\n\n\tif (sc->driver_data & ATH9K_PCI_KILLER)\n\t\tath_info(common, \"Killer Wireless card detected\\n\");\n\n\t \n\tif (sc->driver_data & (ATH9K_PCI_AR9565_1ANT | ATH9K_PCI_AR9565_2ANT)) {\n\t\tif (!(sc->driver_data & ATH9K_PCI_BT_ANT_DIV))\n\t\t\tpCap->hw_caps &= ~ATH9K_HW_CAP_ANT_DIV_COMB;\n\t}\n\n\tif (sc->driver_data & ATH9K_PCI_BT_ANT_DIV) {\n\t\tpCap->hw_caps |= ATH9K_HW_CAP_BT_ANT_DIV;\n\t\tath_info(common, \"Set BT/WLAN RX diversity capability\\n\");\n\t}\n\n\tif (sc->driver_data & ATH9K_PCI_D3_L1_WAR) {\n\t\tah->config.pcie_waen = 0x0040473b;\n\t\tath_info(common, \"Enable WAR for ASPM D3/L1\\n\");\n\t}\n\n\t \n\tah->config.pll_pwrsave = 1;\n\n\tif (sc->driver_data & ATH9K_PCI_NO_PLL_PWRSAVE) {\n\t\tah->config.pll_pwrsave = 0;\n\t\tath_info(common, \"Disable PLL PowerSave\\n\");\n\t}\n\n\tif (sc->driver_data & ATH9K_PCI_LED_ACT_HI)\n\t\tah->config.led_active_high = true;\n}\n\nstatic void ath9k_eeprom_request_cb(const struct firmware *eeprom_blob,\n\t\t\t\t    void *ctx)\n{\n\tstruct ath9k_eeprom_ctx *ec = ctx;\n\n\tif (eeprom_blob)\n\t\tec->ah->eeprom_blob = eeprom_blob;\n\n\tcomplete(&ec->complete);\n}\n\nstatic int ath9k_eeprom_request(struct ath_softc *sc, const char *name)\n{\n\tstruct ath9k_eeprom_ctx ec;\n\tstruct ath_hw *ah = sc->sc_ah;\n\tint err;\n\n\t \n\tinit_completion(&ec.complete);\n\tec.ah = sc->sc_ah;\n\n\terr = request_firmware_nowait(THIS_MODULE, 1, name, sc->dev, GFP_KERNEL,\n\t\t\t\t      &ec, ath9k_eeprom_request_cb);\n\tif (err < 0) {\n\t\tath_err(ath9k_hw_common(ah),\n\t\t\t\"EEPROM request failed\\n\");\n\t\treturn err;\n\t}\n\n\twait_for_completion(&ec.complete);\n\n\tif (!ah->eeprom_blob) {\n\t\tath_err(ath9k_hw_common(ah),\n\t\t\t\"Unable to load EEPROM file %s\\n\", name);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void ath9k_eeprom_release(struct ath_softc *sc)\n{\n\trelease_firmware(sc->sc_ah->eeprom_blob);\n}\n\nstatic int ath9k_nvmem_request_eeprom(struct ath_softc *sc)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct nvmem_cell *cell;\n\tvoid *buf;\n\tsize_t len;\n\tint err;\n\n\tcell = devm_nvmem_cell_get(sc->dev, \"calibration\");\n\tif (IS_ERR(cell)) {\n\t\terr = PTR_ERR(cell);\n\n\t\t \n\t\tif (err == -ENOENT || err == -EOPNOTSUPP)\n\t\t\treturn 0;\n\n\t\treturn err;\n\t}\n\n\tbuf = nvmem_cell_read(cell, &len);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\t \n\tif ((len & 1) == 1 || len < 512 || len >= AR9300_EEPROM_SIZE) {\n\t\tkfree(buf);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tah->nvmem_blob = (u16 *)devm_kmemdup(sc->dev, buf, len, GFP_KERNEL);\n\tkfree(buf);\n\tif (!ah->nvmem_blob)\n\t\treturn -ENOMEM;\n\n\tah->nvmem_blob_len = len;\n\tah->ah_flags &= ~AH_USE_EEPROM;\n\tah->ah_flags |= AH_NO_EEP_SWAP;\n\n\treturn 0;\n}\n\nstatic int ath9k_init_platform(struct ath_softc *sc)\n{\n\tstruct ath9k_platform_data *pdata = sc->dev->platform_data;\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tint ret;\n\n\tif (!pdata)\n\t\treturn 0;\n\n\tif (!pdata->use_eeprom) {\n\t\tah->ah_flags &= ~AH_USE_EEPROM;\n\t\tah->gpio_mask = pdata->gpio_mask;\n\t\tah->gpio_val = pdata->gpio_val;\n\t\tah->led_pin = pdata->led_pin;\n\t\tah->is_clk_25mhz = pdata->is_clk_25mhz;\n\t\tah->get_mac_revision = pdata->get_mac_revision;\n\t\tah->external_reset = pdata->external_reset;\n\t\tah->disable_2ghz = pdata->disable_2ghz;\n\t\tah->disable_5ghz = pdata->disable_5ghz;\n\n\t\tif (!pdata->endian_check)\n\t\t\tah->ah_flags |= AH_NO_EEP_SWAP;\n\t}\n\n\tif (pdata->eeprom_name) {\n\t\tret = ath9k_eeprom_request(sc, pdata->eeprom_name);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (pdata->led_active_high)\n\t\tah->config.led_active_high = true;\n\n\tif (pdata->tx_gain_buffalo)\n\t\tah->config.tx_gain_buffalo = true;\n\n\tif (pdata->macaddr)\n\t\tether_addr_copy(common->macaddr, pdata->macaddr);\n\n\treturn 0;\n}\n\nstatic int ath9k_of_init(struct ath_softc *sc)\n{\n\tstruct device_node *np = sc->dev->of_node;\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tenum ath_bus_type bus_type = common->bus_ops->ath_bus_type;\n\tchar eeprom_name[100];\n\tint ret;\n\n\tif (!of_device_is_available(np))\n\t\treturn 0;\n\n\tath_dbg(common, CONFIG, \"parsing configuration from OF node\\n\");\n\n\tif (of_property_read_bool(np, \"qca,no-eeprom\")) {\n\t\t \n\t\tscnprintf(eeprom_name, sizeof(eeprom_name),\n\t\t\t  \"ath9k-eeprom-%s-%s.bin\",\n\t\t\t  ath_bus_type_to_string(bus_type), dev_name(ah->dev));\n\n\t\tret = ath9k_eeprom_request(sc, eeprom_name);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tah->ah_flags &= ~AH_USE_EEPROM;\n\t\tah->ah_flags |= AH_NO_EEP_SWAP;\n\t}\n\n\tof_get_mac_address(np, common->macaddr);\n\n\treturn 0;\n}\n\nstatic int ath9k_init_softc(u16 devid, struct ath_softc *sc,\n\t\t\t    const struct ath_bus_ops *bus_ops)\n{\n\tstruct ath_hw *ah = NULL;\n\tstruct ath9k_hw_capabilities *pCap;\n\tstruct ath_common *common;\n\tint ret = 0, i;\n\tint csz = 0;\n\n\tah = devm_kzalloc(sc->dev, sizeof(struct ath_hw), GFP_KERNEL);\n\tif (!ah)\n\t\treturn -ENOMEM;\n\n\tah->dev = sc->dev;\n\tah->hw = sc->hw;\n\tah->hw_version.devid = devid;\n\tah->ah_flags |= AH_USE_EEPROM;\n\tah->led_pin = -1;\n\tah->reg_ops.read = ath9k_ioread32;\n\tah->reg_ops.multi_read = ath9k_multi_ioread32;\n\tah->reg_ops.write = ath9k_iowrite32;\n\tah->reg_ops.rmw = ath9k_reg_rmw;\n\tpCap = &ah->caps;\n\n\tcommon = ath9k_hw_common(ah);\n\n\t \n\tset_bit(ATH_OP_INVALID, &common->op_flags);\n\n\tsc->sc_ah = ah;\n\tsc->dfs_detector = dfs_pattern_detector_init(common, NL80211_DFS_UNSET);\n\tsc->tx99_power = MAX_RATE_POWER + 1;\n\tinit_waitqueue_head(&sc->tx_wait);\n\tsc->cur_chan = &sc->chanctx[0];\n\tif (!ath9k_is_chanctx_enabled())\n\t\tsc->cur_chan->hw_queue_base = 0;\n\n\tcommon->ops = &ah->reg_ops;\n\tcommon->bus_ops = bus_ops;\n\tcommon->ps_ops = &ath9k_ps_ops;\n\tcommon->ah = ah;\n\tcommon->hw = sc->hw;\n\tcommon->priv = sc;\n\tcommon->debug_mask = ath9k_debug;\n\tcommon->btcoex_enabled = ath9k_btcoex_enable == 1;\n\tcommon->disable_ani = false;\n\n\t \n\tath9k_init_pcoem_platform(sc);\n\n\tret = ath9k_init_platform(sc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ath9k_of_init(sc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ath9k_nvmem_request_eeprom(sc);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ath9k_led_active_high != -1)\n\t\tah->config.led_active_high = ath9k_led_active_high == 1;\n\n\t \n\tif (!common->btcoex_enabled && ath9k_bt_ant_diversity &&\n\t    (pCap->hw_caps & ATH9K_HW_CAP_BT_ANT_DIV))\n\t\tcommon->bt_ant_diversity = 1;\n\n\tspin_lock_init(&common->cc_lock);\n\tspin_lock_init(&sc->intr_lock);\n\tspin_lock_init(&sc->sc_serial_rw);\n\tspin_lock_init(&sc->sc_pm_lock);\n\tspin_lock_init(&sc->chan_lock);\n\tmutex_init(&sc->mutex);\n\ttasklet_setup(&sc->intr_tq, ath9k_tasklet);\n\ttasklet_setup(&sc->bcon_tasklet, ath9k_beacon_tasklet);\n\n\ttimer_setup(&sc->sleep_timer, ath_ps_full_sleep, 0);\n\tINIT_WORK(&sc->hw_reset_work, ath_reset_work);\n\tINIT_WORK(&sc->paprd_work, ath_paprd_calibrate);\n\tINIT_DELAYED_WORK(&sc->hw_pll_work, ath_hw_pll_work);\n\tINIT_DELAYED_WORK(&sc->hw_check_work, ath_hw_check_work);\n\n\tath9k_init_channel_context(sc);\n\n\t \n\tath_read_cachesize(common, &csz);\n\tcommon->cachelsz = csz << 2;  \n\n\t \n\tret = ath9k_hw_init(ah);\n\tif (ret)\n\t\tgoto err_hw;\n\n\tret = ath9k_init_queues(sc);\n\tif (ret)\n\t\tgoto err_queues;\n\n\tret =  ath9k_init_btcoex(sc);\n\tif (ret)\n\t\tgoto err_btcoex;\n\n\tret = ath9k_cmn_init_channels_rates(common);\n\tif (ret)\n\t\tgoto err_btcoex;\n\n\tret = ath9k_init_p2p(sc);\n\tif (ret)\n\t\tgoto err_btcoex;\n\n\tath9k_cmn_init_crypto(sc->sc_ah);\n\tath9k_init_misc(sc);\n\tath_chanctx_init(sc);\n\tath9k_offchannel_init(sc);\n\n\tif (common->bus_ops->aspm_init)\n\t\tcommon->bus_ops->aspm_init(common);\n\n\treturn 0;\n\nerr_btcoex:\n\tfor (i = 0; i < ATH9K_NUM_TX_QUEUES; i++)\n\t\tif (ATH_TXQ_SETUP(sc, i))\n\t\t\tath_tx_cleanupq(sc, &sc->tx.txq[i]);\nerr_queues:\n\tath9k_hw_deinit(ah);\nerr_hw:\n\tath9k_eeprom_release(sc);\n\tdev_kfree_skb_any(sc->tx99_skb);\n\treturn ret;\n}\n\nstatic void ath9k_init_band_txpower(struct ath_softc *sc, int band)\n{\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_channel *chan;\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct cfg80211_chan_def chandef;\n\tint i;\n\n\tsband = &common->sbands[band];\n\tfor (i = 0; i < sband->n_channels; i++) {\n\t\tchan = &sband->channels[i];\n\t\tah->curchan = &ah->channels[chan->hw_value];\n\t\tcfg80211_chandef_create(&chandef, chan, NL80211_CHAN_HT20);\n\t\tath9k_cmn_get_channel(sc->hw, ah, &chandef);\n\t\tath9k_hw_set_txpowerlimit(ah, MAX_COMBINED_POWER, true);\n\t}\n}\n\nstatic void ath9k_init_txpower_limits(struct ath_softc *sc)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath9k_channel *curchan = ah->curchan;\n\n\tif (ah->caps.hw_caps & ATH9K_HW_CAP_2GHZ)\n\t\tath9k_init_band_txpower(sc, NL80211_BAND_2GHZ);\n\tif (ah->caps.hw_caps & ATH9K_HW_CAP_5GHZ)\n\t\tath9k_init_band_txpower(sc, NL80211_BAND_5GHZ);\n\n\tah->curchan = curchan;\n}\n\nstatic const struct ieee80211_iface_limit if_limits[] = {\n\t{ .max = 2048,\t.types = BIT(NL80211_IFTYPE_STATION) },\n\t{ .max = 8,\t.types =\n#ifdef CONFIG_MAC80211_MESH\n\t\t\t\t BIT(NL80211_IFTYPE_MESH_POINT) |\n#endif\n\t\t\t\t BIT(NL80211_IFTYPE_AP) },\n\t{ .max = 1,\t.types = BIT(NL80211_IFTYPE_P2P_CLIENT) |\n\t\t\t\t BIT(NL80211_IFTYPE_P2P_GO) },\n};\n\n#ifdef CONFIG_ATH9K_CHANNEL_CONTEXT\n\nstatic const struct ieee80211_iface_limit if_limits_multi[] = {\n\t{ .max = 2,\t.types = BIT(NL80211_IFTYPE_STATION) |\n\t\t\t\t BIT(NL80211_IFTYPE_AP) |\n\t\t\t\t BIT(NL80211_IFTYPE_P2P_CLIENT) |\n\t\t\t\t BIT(NL80211_IFTYPE_P2P_GO) },\n\t{ .max = 1,\t.types = BIT(NL80211_IFTYPE_ADHOC) },\n\t{ .max = 1,\t.types = BIT(NL80211_IFTYPE_P2P_DEVICE) },\n};\n\nstatic const struct ieee80211_iface_combination if_comb_multi[] = {\n\t{\n\t\t.limits = if_limits_multi,\n\t\t.n_limits = ARRAY_SIZE(if_limits_multi),\n\t\t.max_interfaces = 3,\n\t\t.num_different_channels = 2,\n\t\t.beacon_int_infra_match = true,\n\t},\n};\n\n#endif  \n\nstatic const struct ieee80211_iface_combination if_comb[] = {\n\t{\n\t\t.limits = if_limits,\n\t\t.n_limits = ARRAY_SIZE(if_limits),\n\t\t.max_interfaces = 2048,\n\t\t.num_different_channels = 1,\n\t\t.beacon_int_infra_match = true,\n#ifdef CONFIG_ATH9K_DFS_CERTIFIED\n\t\t.radar_detect_widths =\tBIT(NL80211_CHAN_WIDTH_20_NOHT) |\n\t\t\t\t\tBIT(NL80211_CHAN_WIDTH_20) |\n\t\t\t\t\tBIT(NL80211_CHAN_WIDTH_40),\n#endif\n\t},\n};\n\n#ifdef CONFIG_ATH9K_CHANNEL_CONTEXT\nstatic void ath9k_set_mcc_capab(struct ath_softc *sc, struct ieee80211_hw *hw)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\n\tif (!ath9k_is_chanctx_enabled())\n\t\treturn;\n\n\tieee80211_hw_set(hw, QUEUE_CONTROL);\n\thw->queues = ATH9K_NUM_TX_QUEUES;\n\thw->offchannel_tx_hw_queue = hw->queues - 1;\n\thw->wiphy->iface_combinations = if_comb_multi;\n\thw->wiphy->n_iface_combinations = ARRAY_SIZE(if_comb_multi);\n\thw->wiphy->max_scan_ssids = 255;\n\thw->wiphy->max_scan_ie_len = IEEE80211_MAX_DATA_LEN;\n\thw->wiphy->max_remain_on_channel_duration = 10000;\n\thw->chanctx_data_size = sizeof(void *);\n\thw->extra_beacon_tailroom =\n\t\tsizeof(struct ieee80211_p2p_noa_attr) + 9;\n\n\tath_dbg(common, CHAN_CTX, \"Use channel contexts\\n\");\n}\n#endif  \n\nstatic void ath9k_set_hw_capab(struct ath_softc *sc, struct ieee80211_hw *hw)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\n\tieee80211_hw_set(hw, SUPPORTS_HT_CCK_RATES);\n\tieee80211_hw_set(hw, SUPPORTS_RC_TABLE);\n\tieee80211_hw_set(hw, REPORTS_TX_ACK_STATUS);\n\tieee80211_hw_set(hw, SPECTRUM_MGMT);\n\tieee80211_hw_set(hw, PS_NULLFUNC_STACK);\n\tieee80211_hw_set(hw, SIGNAL_DBM);\n\tieee80211_hw_set(hw, RX_INCLUDES_FCS);\n\tieee80211_hw_set(hw, HOST_BROADCAST_PS_BUFFERING);\n\tieee80211_hw_set(hw, SUPPORT_FAST_XMIT);\n\tieee80211_hw_set(hw, SUPPORTS_CLONED_SKBS);\n\n\tif (ath9k_ps_enable)\n\t\tieee80211_hw_set(hw, SUPPORTS_PS);\n\n\tif (sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_HT) {\n\t\tieee80211_hw_set(hw, AMPDU_AGGREGATION);\n\n\t\tif (AR_SREV_9280_20_OR_LATER(ah))\n\t\t\thw->radiotap_mcs_details |=\n\t\t\t\tIEEE80211_RADIOTAP_MCS_HAVE_STBC;\n\t}\n\n\tif (AR_SREV_9160_10_OR_LATER(sc->sc_ah) || ath9k_modparam_nohwcrypt)\n\t\tieee80211_hw_set(hw, MFP_CAPABLE);\n\n\thw->wiphy->features |= NL80211_FEATURE_ACTIVE_MONITOR |\n\t\t\t       NL80211_FEATURE_AP_MODE_CHAN_WIDTH_CHANGE |\n\t\t\t       NL80211_FEATURE_P2P_GO_CTWIN;\n\n\tif (!IS_ENABLED(CONFIG_ATH9K_TX99)) {\n\t\thw->wiphy->interface_modes =\n\t\t\tBIT(NL80211_IFTYPE_P2P_GO) |\n\t\t\tBIT(NL80211_IFTYPE_P2P_CLIENT) |\n\t\t\tBIT(NL80211_IFTYPE_AP) |\n\t\t\tBIT(NL80211_IFTYPE_STATION) |\n\t\t\tBIT(NL80211_IFTYPE_ADHOC) |\n\t\t\tBIT(NL80211_IFTYPE_MESH_POINT) |\n\t\t\tBIT(NL80211_IFTYPE_OCB);\n\n\t\tif (ath9k_is_chanctx_enabled())\n\t\t\thw->wiphy->interface_modes |=\n\t\t\t\t\tBIT(NL80211_IFTYPE_P2P_DEVICE);\n\n\t\thw->wiphy->iface_combinations = if_comb;\n\t\thw->wiphy->n_iface_combinations = ARRAY_SIZE(if_comb);\n\t}\n\n\thw->wiphy->flags &= ~WIPHY_FLAG_PS_ON_BY_DEFAULT;\n\n\thw->wiphy->flags |= WIPHY_FLAG_IBSS_RSN;\n\thw->wiphy->flags |= WIPHY_FLAG_SUPPORTS_TDLS;\n\thw->wiphy->flags |= WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;\n\thw->wiphy->flags |= WIPHY_FLAG_SUPPORTS_5_10_MHZ;\n\thw->wiphy->flags |= WIPHY_FLAG_HAS_CHANNEL_SWITCH;\n\thw->wiphy->flags |= WIPHY_FLAG_AP_UAPSD;\n\n\thw->queues = 4;\n\thw->max_rates = 4;\n\thw->max_listen_interval = 10;\n\thw->max_rate_tries = 10;\n\thw->sta_data_size = sizeof(struct ath_node);\n\thw->vif_data_size = sizeof(struct ath_vif);\n\thw->txq_data_size = sizeof(struct ath_atx_tid);\n\thw->extra_tx_headroom = 4;\n\n\thw->wiphy->available_antennas_rx = BIT(ah->caps.max_rxchains) - 1;\n\thw->wiphy->available_antennas_tx = BIT(ah->caps.max_txchains) - 1;\n\n\t \n\tif (ah->caps.hw_caps & ATH9K_HW_CAP_ANT_DIV_COMB)\n\t\thw->wiphy->available_antennas_rx = BIT(0) | BIT(1);\n\n\tsc->ant_rx = hw->wiphy->available_antennas_rx;\n\tsc->ant_tx = hw->wiphy->available_antennas_tx;\n\n\tif (sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_2GHZ)\n\t\thw->wiphy->bands[NL80211_BAND_2GHZ] =\n\t\t\t&common->sbands[NL80211_BAND_2GHZ];\n\tif (sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_5GHZ)\n\t\thw->wiphy->bands[NL80211_BAND_5GHZ] =\n\t\t\t&common->sbands[NL80211_BAND_5GHZ];\n\n#ifdef CONFIG_ATH9K_CHANNEL_CONTEXT\n\tath9k_set_mcc_capab(sc, hw);\n#endif\n\tath9k_init_wow(hw);\n\tath9k_cmn_reload_chainmask(ah);\n\n\tSET_IEEE80211_PERM_ADDR(hw, common->macaddr);\n\n\twiphy_ext_feature_set(hw->wiphy, NL80211_EXT_FEATURE_CQM_RSSI_LIST);\n\twiphy_ext_feature_set(hw->wiphy, NL80211_EXT_FEATURE_AIRTIME_FAIRNESS);\n\twiphy_ext_feature_set(hw->wiphy,\n\t\t\t      NL80211_EXT_FEATURE_MULTICAST_REGISTRATIONS);\n\twiphy_ext_feature_set(hw->wiphy, NL80211_EXT_FEATURE_CAN_REPLACE_PTK0);\n}\n\nint ath9k_init_device(u16 devid, struct ath_softc *sc,\n\t\t    const struct ath_bus_ops *bus_ops)\n{\n\tstruct ieee80211_hw *hw = sc->hw;\n\tstruct ath_common *common;\n\tstruct ath_hw *ah;\n\tint error = 0;\n\tstruct ath_regulatory *reg;\n\n\t \n\terror = ath9k_init_softc(devid, sc, bus_ops);\n\tif (error)\n\t\treturn error;\n\n\tah = sc->sc_ah;\n\tcommon = ath9k_hw_common(ah);\n\tath9k_set_hw_capab(sc, hw);\n\n\t \n\terror = ath_regd_init(&common->regulatory, sc->hw->wiphy,\n\t\t\t      ath9k_reg_notifier);\n\tif (error)\n\t\tgoto deinit;\n\n\treg = &common->regulatory;\n\n\t \n\terror = ath_tx_init(sc, ATH_TXBUF);\n\tif (error != 0)\n\t\tgoto deinit;\n\n\t \n\terror = ath_rx_init(sc, ATH_RXBUF);\n\tif (error != 0)\n\t\tgoto deinit;\n\n\tath9k_init_txpower_limits(sc);\n\n#ifdef CONFIG_MAC80211_LEDS\n\t \n\tsc->led_cdev.default_trigger = ieee80211_create_tpt_led_trigger(sc->hw,\n\t\tIEEE80211_TPT_LEDTRIG_FL_RADIO, ath9k_tpt_blink,\n\t\tARRAY_SIZE(ath9k_tpt_blink));\n#endif\n\n\twiphy_read_of_freq_limits(hw->wiphy);\n\n\t \n\terror = ieee80211_register_hw(hw);\n\tif (error)\n\t\tgoto rx_cleanup;\n\n\terror = ath9k_init_debug(ah);\n\tif (error) {\n\t\tath_err(common, \"Unable to create debugfs files\\n\");\n\t\tgoto unregister;\n\t}\n\n\t \n\tif (!ath_is_world_regd(reg)) {\n\t\terror = regulatory_hint(hw->wiphy, reg->alpha2);\n\t\tif (error)\n\t\t\tgoto debug_cleanup;\n\t}\n\n\tath_init_leds(sc);\n\tath_start_rfkill_poll(sc);\n\n\treturn 0;\n\ndebug_cleanup:\n\tath9k_deinit_debug(sc);\nunregister:\n\tieee80211_unregister_hw(hw);\nrx_cleanup:\n\tath_rx_cleanup(sc);\ndeinit:\n\tath9k_deinit_softc(sc);\n\treturn error;\n}\n\n \n \n \n\nstatic void ath9k_deinit_softc(struct ath_softc *sc)\n{\n\tint i = 0;\n\n\tath9k_deinit_p2p(sc);\n\tath9k_deinit_btcoex(sc);\n\n\tfor (i = 0; i < ATH9K_NUM_TX_QUEUES; i++)\n\t\tif (ATH_TXQ_SETUP(sc, i))\n\t\t\tath_tx_cleanupq(sc, &sc->tx.txq[i]);\n\n\tdel_timer_sync(&sc->sleep_timer);\n\tath9k_hw_deinit(sc->sc_ah);\n\tif (sc->dfs_detector != NULL)\n\t\tsc->dfs_detector->exit(sc->dfs_detector);\n\n\tath9k_eeprom_release(sc);\n}\n\nvoid ath9k_deinit_device(struct ath_softc *sc)\n{\n\tstruct ieee80211_hw *hw = sc->hw;\n\n\tath9k_ps_wakeup(sc);\n\n\twiphy_rfkill_stop_polling(sc->hw->wiphy);\n\tath_deinit_leds(sc);\n\n\tath9k_ps_restore(sc);\n\n\tath9k_deinit_debug(sc);\n\tath9k_deinit_wow(hw);\n\tieee80211_unregister_hw(hw);\n\tath_rx_cleanup(sc);\n\tath9k_deinit_softc(sc);\n}\n\n \n \n \n\nstatic int __init ath9k_init(void)\n{\n\tint error;\n\n\terror = ath_pci_init();\n\tif (error < 0) {\n\t\tpr_err(\"No PCI devices found, driver not installed\\n\");\n\t\terror = -ENODEV;\n\t\tgoto err_out;\n\t}\n\n\terror = ath_ahb_init();\n\tif (error < 0) {\n\t\terror = -ENODEV;\n\t\tgoto err_pci_exit;\n\t}\n\n\tdmi_check_system(ath9k_quirks);\n\n\treturn 0;\n\n err_pci_exit:\n\tath_pci_exit();\n err_out:\n\treturn error;\n}\nmodule_init(ath9k_init);\n\nstatic void __exit ath9k_exit(void)\n{\n\tis_ath9k_unloaded = true;\n\tath_ahb_exit();\n\tath_pci_exit();\n\tpr_info(\"%s: Driver unloaded\\n\", dev_info);\n}\nmodule_exit(ath9k_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}