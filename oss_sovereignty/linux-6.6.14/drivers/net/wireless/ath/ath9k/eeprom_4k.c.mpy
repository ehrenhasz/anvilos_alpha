{
  "module_name": "eeprom_4k.c",
  "hash_id": "1f23c2bb65f9162dd4eb1901793ac21b746de6306387e2af757bba8560a6d80d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath9k/eeprom_4k.c",
  "human_readable_source": " \n\n#include <asm/unaligned.h>\n#include \"hw.h\"\n#include \"ar9002_phy.h\"\n\nstatic int ath9k_hw_4k_get_eeprom_ver(struct ath_hw *ah)\n{\n\tu16 version = le16_to_cpu(ah->eeprom.map4k.baseEepHeader.version);\n\n\treturn (version & AR5416_EEP_VER_MAJOR_MASK) >>\n\t\tAR5416_EEP_VER_MAJOR_SHIFT;\n}\n\nstatic int ath9k_hw_4k_get_eeprom_rev(struct ath_hw *ah)\n{\n\tu16 version = le16_to_cpu(ah->eeprom.map4k.baseEepHeader.version);\n\n\treturn version & AR5416_EEP_VER_MINOR_MASK;\n}\n\n#define SIZE_EEPROM_4K (sizeof(struct ar5416_eeprom_4k) / sizeof(u16))\n\nstatic bool __ath9k_hw_4k_fill_eeprom(struct ath_hw *ah)\n{\n\tu16 *eep_data = (u16 *)&ah->eeprom.map4k;\n\tint addr, eep_start_loc = 64;\n\n\tfor (addr = 0; addr < SIZE_EEPROM_4K; addr++) {\n\t\tif (!ath9k_hw_nvram_read(ah, addr + eep_start_loc, eep_data))\n\t\t\treturn false;\n\t\teep_data++;\n\t}\n\n\treturn true;\n}\n\nstatic bool __ath9k_hw_usb_4k_fill_eeprom(struct ath_hw *ah)\n{\n\tu16 *eep_data = (u16 *)&ah->eeprom.map4k;\n\n\tath9k_hw_usb_gen_fill_eeprom(ah, eep_data, 64, SIZE_EEPROM_4K);\n\n\treturn true;\n}\n\nstatic bool ath9k_hw_4k_fill_eeprom(struct ath_hw *ah)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\n\tif (!ath9k_hw_use_flash(ah)) {\n\t\tath_dbg(common, EEPROM, \"Reading from EEPROM, not flash\\n\");\n\t}\n\n\tif (common->bus_ops->ath_bus_type == ATH_USB)\n\t\treturn __ath9k_hw_usb_4k_fill_eeprom(ah);\n\telse\n\t\treturn __ath9k_hw_4k_fill_eeprom(ah);\n}\n\n#ifdef CONFIG_ATH9K_COMMON_DEBUG\nstatic u32 ath9k_dump_4k_modal_eeprom(char *buf, u32 len, u32 size,\n\t\t\t\t      struct modal_eep_4k_header *modal_hdr)\n{\n\tPR_EEP(\"Chain0 Ant. Control\", le16_to_cpu(modal_hdr->antCtrlChain[0]));\n\tPR_EEP(\"Ant. Common Control\", le32_to_cpu(modal_hdr->antCtrlCommon));\n\tPR_EEP(\"Chain0 Ant. Gain\", modal_hdr->antennaGainCh[0]);\n\tPR_EEP(\"Switch Settle\", modal_hdr->switchSettling);\n\tPR_EEP(\"Chain0 TxRxAtten\", modal_hdr->txRxAttenCh[0]);\n\tPR_EEP(\"Chain0 RxTxMargin\", modal_hdr->rxTxMarginCh[0]);\n\tPR_EEP(\"ADC Desired size\", modal_hdr->adcDesiredSize);\n\tPR_EEP(\"PGA Desired size\", modal_hdr->pgaDesiredSize);\n\tPR_EEP(\"Chain0 xlna Gain\", modal_hdr->xlnaGainCh[0]);\n\tPR_EEP(\"txEndToXpaOff\", modal_hdr->txEndToXpaOff);\n\tPR_EEP(\"txEndToRxOn\", modal_hdr->txEndToRxOn);\n\tPR_EEP(\"txFrameToXpaOn\", modal_hdr->txFrameToXpaOn);\n\tPR_EEP(\"CCA Threshold)\", modal_hdr->thresh62);\n\tPR_EEP(\"Chain0 NF Threshold\", modal_hdr->noiseFloorThreshCh[0]);\n\tPR_EEP(\"xpdGain\", modal_hdr->xpdGain);\n\tPR_EEP(\"External PD\", modal_hdr->xpd);\n\tPR_EEP(\"Chain0 I Coefficient\", modal_hdr->iqCalICh[0]);\n\tPR_EEP(\"Chain0 Q Coefficient\", modal_hdr->iqCalQCh[0]);\n\tPR_EEP(\"pdGainOverlap\", modal_hdr->pdGainOverlap);\n\tPR_EEP(\"O/D Bias Version\", modal_hdr->version);\n\tPR_EEP(\"CCK OutputBias\", modal_hdr->ob_0);\n\tPR_EEP(\"BPSK OutputBias\", modal_hdr->ob_1);\n\tPR_EEP(\"QPSK OutputBias\", modal_hdr->ob_2);\n\tPR_EEP(\"16QAM OutputBias\", modal_hdr->ob_3);\n\tPR_EEP(\"64QAM OutputBias\", modal_hdr->ob_4);\n\tPR_EEP(\"CCK Driver1_Bias\", modal_hdr->db1_0);\n\tPR_EEP(\"BPSK Driver1_Bias\", modal_hdr->db1_1);\n\tPR_EEP(\"QPSK Driver1_Bias\", modal_hdr->db1_2);\n\tPR_EEP(\"16QAM Driver1_Bias\", modal_hdr->db1_3);\n\tPR_EEP(\"64QAM Driver1_Bias\", modal_hdr->db1_4);\n\tPR_EEP(\"CCK Driver2_Bias\", modal_hdr->db2_0);\n\tPR_EEP(\"BPSK Driver2_Bias\", modal_hdr->db2_1);\n\tPR_EEP(\"QPSK Driver2_Bias\", modal_hdr->db2_2);\n\tPR_EEP(\"16QAM Driver2_Bias\", modal_hdr->db2_3);\n\tPR_EEP(\"64QAM Driver2_Bias\", modal_hdr->db2_4);\n\tPR_EEP(\"xPA Bias Level\", modal_hdr->xpaBiasLvl);\n\tPR_EEP(\"txFrameToDataStart\", modal_hdr->txFrameToDataStart);\n\tPR_EEP(\"txFrameToPaOn\", modal_hdr->txFrameToPaOn);\n\tPR_EEP(\"HT40 Power Inc.\", modal_hdr->ht40PowerIncForPdadc);\n\tPR_EEP(\"Chain0 bswAtten\", modal_hdr->bswAtten[0]);\n\tPR_EEP(\"Chain0 bswMargin\", modal_hdr->bswMargin[0]);\n\tPR_EEP(\"HT40 Switch Settle\", modal_hdr->swSettleHt40);\n\tPR_EEP(\"Chain0 xatten2Db\", modal_hdr->xatten2Db[0]);\n\tPR_EEP(\"Chain0 xatten2Margin\", modal_hdr->xatten2Margin[0]);\n\tPR_EEP(\"Ant. Diversity ctl1\", modal_hdr->antdiv_ctl1);\n\tPR_EEP(\"Ant. Diversity ctl2\", modal_hdr->antdiv_ctl2);\n\tPR_EEP(\"TX Diversity\", modal_hdr->tx_diversity);\n\n\treturn len;\n}\n\nstatic u32 ath9k_hw_4k_dump_eeprom(struct ath_hw *ah, bool dump_base_hdr,\n\t\t\t\t       u8 *buf, u32 len, u32 size)\n{\n\tstruct ar5416_eeprom_4k *eep = &ah->eeprom.map4k;\n\tstruct base_eep_header_4k *pBase = &eep->baseEepHeader;\n\tu32 binBuildNumber = le32_to_cpu(pBase->binBuildNumber);\n\n\tif (!dump_base_hdr) {\n\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t \"%20s :\\n\", \"2GHz modal Header\");\n\t\tlen = ath9k_dump_4k_modal_eeprom(buf, len, size,\n\t\t\t\t\t\t &eep->modalHeader);\n\t\tgoto out;\n\t}\n\n\tPR_EEP(\"Major Version\", ath9k_hw_4k_get_eeprom_ver(ah));\n\tPR_EEP(\"Minor Version\", ath9k_hw_4k_get_eeprom_rev(ah));\n\tPR_EEP(\"Checksum\", le16_to_cpu(pBase->checksum));\n\tPR_EEP(\"Length\", le16_to_cpu(pBase->length));\n\tPR_EEP(\"RegDomain1\", le16_to_cpu(pBase->regDmn[0]));\n\tPR_EEP(\"RegDomain2\", le16_to_cpu(pBase->regDmn[1]));\n\tPR_EEP(\"TX Mask\", pBase->txMask);\n\tPR_EEP(\"RX Mask\", pBase->rxMask);\n\tPR_EEP(\"Allow 5GHz\", !!(pBase->opCapFlags & AR5416_OPFLAGS_11A));\n\tPR_EEP(\"Allow 2GHz\", !!(pBase->opCapFlags & AR5416_OPFLAGS_11G));\n\tPR_EEP(\"Disable 2GHz HT20\", !!(pBase->opCapFlags &\n\t\t\t\t\tAR5416_OPFLAGS_N_2G_HT20));\n\tPR_EEP(\"Disable 2GHz HT40\", !!(pBase->opCapFlags &\n\t\t\t\t\tAR5416_OPFLAGS_N_2G_HT40));\n\tPR_EEP(\"Disable 5Ghz HT20\", !!(pBase->opCapFlags &\n\t\t\t\t\tAR5416_OPFLAGS_N_5G_HT20));\n\tPR_EEP(\"Disable 5Ghz HT40\", !!(pBase->opCapFlags &\n\t\t\t\t\tAR5416_OPFLAGS_N_5G_HT40));\n\tPR_EEP(\"Big Endian\", !!(pBase->eepMisc & AR5416_EEPMISC_BIG_ENDIAN));\n\tPR_EEP(\"Cal Bin Major Ver\", (binBuildNumber >> 24) & 0xFF);\n\tPR_EEP(\"Cal Bin Minor Ver\", (binBuildNumber >> 16) & 0xFF);\n\tPR_EEP(\"Cal Bin Build\", (binBuildNumber >> 8) & 0xFF);\n\tPR_EEP(\"TX Gain type\", pBase->txGainType);\n\n\tlen += scnprintf(buf + len, size - len, \"%20s : %pM\\n\", \"MacAddress\",\n\t\t\t pBase->macAddr);\n\nout:\n\tif (len > size)\n\t\tlen = size;\n\n\treturn len;\n}\n#else\nstatic u32 ath9k_hw_4k_dump_eeprom(struct ath_hw *ah, bool dump_base_hdr,\n\t\t\t\t       u8 *buf, u32 len, u32 size)\n{\n\treturn 0;\n}\n#endif\n\nstatic int ath9k_hw_4k_check_eeprom(struct ath_hw *ah)\n{\n\tstruct ar5416_eeprom_4k *eep = &ah->eeprom.map4k;\n\tu32 el;\n\tbool need_swap;\n\tint i, err;\n\n\terr = ath9k_hw_nvram_swap_data(ah, &need_swap, SIZE_EEPROM_4K);\n\tif (err)\n\t\treturn err;\n\n\tif (need_swap)\n\t\tel = swab16((__force u16)eep->baseEepHeader.length);\n\telse\n\t\tel = le16_to_cpu(eep->baseEepHeader.length);\n\n\tel = min(el / sizeof(u16), SIZE_EEPROM_4K);\n\tif (!ath9k_hw_nvram_validate_checksum(ah, el))\n\t\treturn -EINVAL;\n\n\tif (need_swap) {\n\t\tEEPROM_FIELD_SWAB16(eep->baseEepHeader.length);\n\t\tEEPROM_FIELD_SWAB16(eep->baseEepHeader.checksum);\n\t\tEEPROM_FIELD_SWAB16(eep->baseEepHeader.version);\n\t\tEEPROM_FIELD_SWAB16(eep->baseEepHeader.regDmn[0]);\n\t\tEEPROM_FIELD_SWAB16(eep->baseEepHeader.regDmn[1]);\n\t\tEEPROM_FIELD_SWAB16(eep->baseEepHeader.rfSilent);\n\t\tEEPROM_FIELD_SWAB16(eep->baseEepHeader.blueToothOptions);\n\t\tEEPROM_FIELD_SWAB16(eep->baseEepHeader.deviceCap);\n\t\tEEPROM_FIELD_SWAB32(eep->modalHeader.antCtrlCommon);\n\n\t\tfor (i = 0; i < AR5416_EEP4K_MAX_CHAINS; i++)\n\t\t\tEEPROM_FIELD_SWAB32(eep->modalHeader.antCtrlChain[i]);\n\n\t\tfor (i = 0; i < AR_EEPROM_MODAL_SPURS; i++)\n\t\t\tEEPROM_FIELD_SWAB16(\n\t\t\t\teep->modalHeader.spurChans[i].spurChan);\n\t}\n\n\tif (!ath9k_hw_nvram_check_version(ah, AR5416_EEP_VER,\n\t    AR5416_EEP_NO_BACK_VER))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n#undef SIZE_EEPROM_4K\n\nstatic u32 ath9k_hw_4k_get_eeprom(struct ath_hw *ah,\n\t\t\t\t  enum eeprom_param param)\n{\n\tstruct ar5416_eeprom_4k *eep = &ah->eeprom.map4k;\n\tstruct modal_eep_4k_header *pModal = &eep->modalHeader;\n\tstruct base_eep_header_4k *pBase = &eep->baseEepHeader;\n\n\tswitch (param) {\n\tcase EEP_NFTHRESH_2:\n\t\treturn pModal->noiseFloorThreshCh[0];\n\tcase EEP_MAC_LSW:\n\t\treturn get_unaligned_be16(pBase->macAddr);\n\tcase EEP_MAC_MID:\n\t\treturn get_unaligned_be16(pBase->macAddr + 2);\n\tcase EEP_MAC_MSW:\n\t\treturn get_unaligned_be16(pBase->macAddr + 4);\n\tcase EEP_REG_0:\n\t\treturn le16_to_cpu(pBase->regDmn[0]);\n\tcase EEP_OP_CAP:\n\t\treturn le16_to_cpu(pBase->deviceCap);\n\tcase EEP_OP_MODE:\n\t\treturn pBase->opCapFlags;\n\tcase EEP_RF_SILENT:\n\t\treturn le16_to_cpu(pBase->rfSilent);\n\tcase EEP_OB_2:\n\t\treturn pModal->ob_0;\n\tcase EEP_DB_2:\n\t\treturn pModal->db1_1;\n\tcase EEP_TX_MASK:\n\t\treturn pBase->txMask;\n\tcase EEP_RX_MASK:\n\t\treturn pBase->rxMask;\n\tcase EEP_FRAC_N_5G:\n\t\treturn 0;\n\tcase EEP_PWR_TABLE_OFFSET:\n\t\treturn AR5416_PWR_TABLE_OFFSET_DB;\n\tcase EEP_MODAL_VER:\n\t\treturn pModal->version;\n\tcase EEP_ANT_DIV_CTL1:\n\t\treturn pModal->antdiv_ctl1;\n\tcase EEP_TXGAIN_TYPE:\n\t\treturn pBase->txGainType;\n\tcase EEP_ANTENNA_GAIN_2G:\n\t\treturn pModal->antennaGainCh[0];\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic void ath9k_hw_set_4k_power_cal_table(struct ath_hw *ah,\n\t\t\t\t  struct ath9k_channel *chan)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ar5416_eeprom_4k *pEepData = &ah->eeprom.map4k;\n\tstruct cal_data_per_freq_4k *pRawDataset;\n\tu8 *pCalBChans = NULL;\n\tu16 pdGainOverlap_t2;\n\tstatic u8 pdadcValues[AR5416_NUM_PDADC_VALUES];\n\tu16 gainBoundaries[AR5416_PD_GAINS_IN_MASK];\n\tu16 numPiers, i, j;\n\tu16 numXpdGain, xpdMask;\n\tu16 xpdGainValues[AR5416_EEP4K_NUM_PD_GAINS] = { 0, 0 };\n\tu32 reg32, regOffset, regChainOffset;\n\n\txpdMask = pEepData->modalHeader.xpdGain;\n\n\tif (ath9k_hw_4k_get_eeprom_rev(ah) >= AR5416_EEP_MINOR_VER_2)\n\t\tpdGainOverlap_t2 =\n\t\t\tpEepData->modalHeader.pdGainOverlap;\n\telse\n\t\tpdGainOverlap_t2 = (u16)(MS(REG_READ(ah, AR_PHY_TPCRG5),\n\t\t\t\t\t    AR_PHY_TPCRG5_PD_GAIN_OVERLAP));\n\n\tpCalBChans = pEepData->calFreqPier2G;\n\tnumPiers = AR5416_EEP4K_NUM_2G_CAL_PIERS;\n\n\tnumXpdGain = 0;\n\n\tfor (i = 1; i <= AR5416_PD_GAINS_IN_MASK; i++) {\n\t\tif ((xpdMask >> (AR5416_PD_GAINS_IN_MASK - i)) & 1) {\n\t\t\tif (numXpdGain >= AR5416_EEP4K_NUM_PD_GAINS)\n\t\t\t\tbreak;\n\t\t\txpdGainValues[numXpdGain] =\n\t\t\t\t(u16)(AR5416_PD_GAINS_IN_MASK - i);\n\t\t\tnumXpdGain++;\n\t\t}\n\t}\n\n\tENABLE_REG_RMW_BUFFER(ah);\n\tREG_RMW_FIELD(ah, AR_PHY_TPCRG1, AR_PHY_TPCRG1_NUM_PD_GAIN,\n\t\t      (numXpdGain - 1) & 0x3);\n\tREG_RMW_FIELD(ah, AR_PHY_TPCRG1, AR_PHY_TPCRG1_PD_GAIN_1,\n\t\t      xpdGainValues[0]);\n\tREG_RMW_FIELD(ah, AR_PHY_TPCRG1, AR_PHY_TPCRG1_PD_GAIN_2,\n\t\t      xpdGainValues[1]);\n\tREG_RMW_FIELD(ah, AR_PHY_TPCRG1, AR_PHY_TPCRG1_PD_GAIN_3, 0);\n\tREG_RMW_BUFFER_FLUSH(ah);\n\n\tfor (i = 0; i < AR5416_EEP4K_MAX_CHAINS; i++) {\n\t\tregChainOffset = i * 0x1000;\n\n\t\tif (pEepData->baseEepHeader.txMask & (1 << i)) {\n\t\t\tpRawDataset = pEepData->calPierData2G[i];\n\n\t\t\tath9k_hw_get_gain_boundaries_pdadcs(ah, chan,\n\t\t\t\t\t    pRawDataset, pCalBChans,\n\t\t\t\t\t    numPiers, pdGainOverlap_t2,\n\t\t\t\t\t    gainBoundaries,\n\t\t\t\t\t    pdadcValues, numXpdGain);\n\n\t\t\tENABLE_REGWRITE_BUFFER(ah);\n\n\t\t\tREG_WRITE(ah, AR_PHY_TPCRG5 + regChainOffset,\n\t\t\t\t  SM(pdGainOverlap_t2,\n\t\t\t\t     AR_PHY_TPCRG5_PD_GAIN_OVERLAP)\n\t\t\t\t  | SM(gainBoundaries[0],\n\t\t\t\t       AR_PHY_TPCRG5_PD_GAIN_BOUNDARY_1)\n\t\t\t\t  | SM(gainBoundaries[1],\n\t\t\t\t       AR_PHY_TPCRG5_PD_GAIN_BOUNDARY_2)\n\t\t\t\t  | SM(gainBoundaries[2],\n\t\t\t\t       AR_PHY_TPCRG5_PD_GAIN_BOUNDARY_3)\n\t\t\t\t  | SM(gainBoundaries[3],\n\t\t\t       AR_PHY_TPCRG5_PD_GAIN_BOUNDARY_4));\n\n\t\t\tregOffset = AR_PHY_BASE + (672 << 2) + regChainOffset;\n\t\t\tfor (j = 0; j < 32; j++) {\n\t\t\t\treg32 = get_unaligned_le32(&pdadcValues[4 * j]);\n\t\t\t\tREG_WRITE(ah, regOffset, reg32);\n\n\t\t\t\tath_dbg(common, EEPROM,\n\t\t\t\t\t\"PDADC (%d,%4x): %4.4x %8.8x\\n\",\n\t\t\t\t\ti, regChainOffset, regOffset,\n\t\t\t\t\treg32);\n\t\t\t\tath_dbg(common, EEPROM,\n\t\t\t\t\t\"PDADC: Chain %d | \"\n\t\t\t\t\t\"PDADC %3d Value %3d | \"\n\t\t\t\t\t\"PDADC %3d Value %3d | \"\n\t\t\t\t\t\"PDADC %3d Value %3d | \"\n\t\t\t\t\t\"PDADC %3d Value %3d |\\n\",\n\t\t\t\t\ti, 4 * j, pdadcValues[4 * j],\n\t\t\t\t\t4 * j + 1, pdadcValues[4 * j + 1],\n\t\t\t\t\t4 * j + 2, pdadcValues[4 * j + 2],\n\t\t\t\t\t4 * j + 3, pdadcValues[4 * j + 3]);\n\n\t\t\t\tregOffset += 4;\n\t\t\t}\n\n\t\t\tREGWRITE_BUFFER_FLUSH(ah);\n\t\t}\n\t}\n}\n\nstatic void ath9k_hw_set_4k_power_per_rate_table(struct ath_hw *ah,\n\t\t\t\t\t\t struct ath9k_channel *chan,\n\t\t\t\t\t\t int16_t *ratesArray,\n\t\t\t\t\t\t u16 cfgCtl,\n\t\t\t\t\t\t u16 antenna_reduction,\n\t\t\t\t\t\t u16 powerLimit)\n{\n#define CMP_TEST_GRP \\\n\t(((cfgCtl & ~CTL_MODE_M)| (pCtlMode[ctlMode] & CTL_MODE_M)) ==\t\\\n\t pEepData->ctlIndex[i])\t\t\t\t\t\t\\\n\t|| (((cfgCtl & ~CTL_MODE_M) | (pCtlMode[ctlMode] & CTL_MODE_M)) == \\\n\t    ((pEepData->ctlIndex[i] & CTL_MODE_M) | SD_NO_CTL))\n\n\tint i;\n\tu16 twiceMinEdgePower;\n\tu16 twiceMaxEdgePower;\n\tu16 scaledPower = 0, minCtlPower;\n\tu16 numCtlModes;\n\tconst u16 *pCtlMode;\n\tu16 ctlMode, freq;\n\tstruct chan_centers centers;\n\tstruct cal_ctl_data_4k *rep;\n\tstruct ar5416_eeprom_4k *pEepData = &ah->eeprom.map4k;\n\tstruct cal_target_power_leg targetPowerOfdm, targetPowerCck = {\n\t\t0, { 0, 0, 0, 0}\n\t};\n\tstruct cal_target_power_leg targetPowerOfdmExt = {\n\t\t0, { 0, 0, 0, 0} }, targetPowerCckExt = {\n\t\t0, { 0, 0, 0, 0 }\n\t};\n\tstruct cal_target_power_ht targetPowerHt20, targetPowerHt40 = {\n\t\t0, {0, 0, 0, 0}\n\t};\n\tstatic const u16 ctlModesFor11g[] = {\n\t\tCTL_11B, CTL_11G, CTL_2GHT20,\n\t\tCTL_11B_EXT, CTL_11G_EXT, CTL_2GHT40\n\t};\n\n\tath9k_hw_get_channel_centers(ah, chan, &centers);\n\n\tscaledPower = powerLimit - antenna_reduction;\n\tscaledPower = min_t(u16, scaledPower, MAX_RATE_POWER);\n\tnumCtlModes = ARRAY_SIZE(ctlModesFor11g) - SUB_NUM_CTL_MODES_AT_2G_40;\n\tpCtlMode = ctlModesFor11g;\n\n\tath9k_hw_get_legacy_target_powers(ah, chan,\n\t\t\tpEepData->calTargetPowerCck,\n\t\t\tAR5416_NUM_2G_CCK_TARGET_POWERS,\n\t\t\t&targetPowerCck, 4, false);\n\tath9k_hw_get_legacy_target_powers(ah, chan,\n\t\t\tpEepData->calTargetPower2G,\n\t\t\tAR5416_NUM_2G_20_TARGET_POWERS,\n\t\t\t&targetPowerOfdm, 4, false);\n\tath9k_hw_get_target_powers(ah, chan,\n\t\t\tpEepData->calTargetPower2GHT20,\n\t\t\tAR5416_NUM_2G_20_TARGET_POWERS,\n\t\t\t&targetPowerHt20, 8, false);\n\n\tif (IS_CHAN_HT40(chan)) {\n\t\tnumCtlModes = ARRAY_SIZE(ctlModesFor11g);\n\t\tath9k_hw_get_target_powers(ah, chan,\n\t\t\t\tpEepData->calTargetPower2GHT40,\n\t\t\t\tAR5416_NUM_2G_40_TARGET_POWERS,\n\t\t\t\t&targetPowerHt40, 8, true);\n\t\tath9k_hw_get_legacy_target_powers(ah, chan,\n\t\t\t\tpEepData->calTargetPowerCck,\n\t\t\t\tAR5416_NUM_2G_CCK_TARGET_POWERS,\n\t\t\t\t&targetPowerCckExt, 4, true);\n\t\tath9k_hw_get_legacy_target_powers(ah, chan,\n\t\t\t\tpEepData->calTargetPower2G,\n\t\t\t\tAR5416_NUM_2G_20_TARGET_POWERS,\n\t\t\t\t&targetPowerOfdmExt, 4, true);\n\t}\n\n\tfor (ctlMode = 0; ctlMode < numCtlModes; ctlMode++) {\n\t\tbool isHt40CtlMode = (pCtlMode[ctlMode] == CTL_5GHT40) ||\n\t\t\t(pCtlMode[ctlMode] == CTL_2GHT40);\n\n\t\tif (isHt40CtlMode)\n\t\t\tfreq = centers.synth_center;\n\t\telse if (pCtlMode[ctlMode] & EXT_ADDITIVE)\n\t\t\tfreq = centers.ext_center;\n\t\telse\n\t\t\tfreq = centers.ctl_center;\n\n\t\ttwiceMaxEdgePower = MAX_RATE_POWER;\n\n\t\tfor (i = 0; (i < AR5416_EEP4K_NUM_CTLS) &&\n\t\t\t     pEepData->ctlIndex[i]; i++) {\n\n\t\t\tif (CMP_TEST_GRP) {\n\t\t\t\trep = &(pEepData->ctlData[i]);\n\n\t\t\t\ttwiceMinEdgePower = ath9k_hw_get_max_edge_power(\n\t\t\t\t\tfreq,\n\t\t\t\t\trep->ctlEdges[\n\t\t\t\t\tar5416_get_ntxchains(ah->txchainmask) - 1],\n\t\t\t\t\tIS_CHAN_2GHZ(chan),\n\t\t\t\t\tAR5416_EEP4K_NUM_BAND_EDGES);\n\n\t\t\t\tif ((cfgCtl & ~CTL_MODE_M) == SD_NO_CTL) {\n\t\t\t\t\ttwiceMaxEdgePower =\n\t\t\t\t\t\tmin(twiceMaxEdgePower,\n\t\t\t\t\t\t    twiceMinEdgePower);\n\t\t\t\t} else {\n\t\t\t\t\ttwiceMaxEdgePower = twiceMinEdgePower;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tminCtlPower = (u8)min(twiceMaxEdgePower, scaledPower);\n\n\t\tswitch (pCtlMode[ctlMode]) {\n\t\tcase CTL_11B:\n\t\t\tfor (i = 0; i < ARRAY_SIZE(targetPowerCck.tPow2x); i++) {\n\t\t\t\ttargetPowerCck.tPow2x[i] =\n\t\t\t\t\tmin((u16)targetPowerCck.tPow2x[i],\n\t\t\t\t\t    minCtlPower);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CTL_11G:\n\t\t\tfor (i = 0; i < ARRAY_SIZE(targetPowerOfdm.tPow2x); i++) {\n\t\t\t\ttargetPowerOfdm.tPow2x[i] =\n\t\t\t\t\tmin((u16)targetPowerOfdm.tPow2x[i],\n\t\t\t\t\t    minCtlPower);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CTL_2GHT20:\n\t\t\tfor (i = 0; i < ARRAY_SIZE(targetPowerHt20.tPow2x); i++) {\n\t\t\t\ttargetPowerHt20.tPow2x[i] =\n\t\t\t\t\tmin((u16)targetPowerHt20.tPow2x[i],\n\t\t\t\t\t    minCtlPower);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CTL_11B_EXT:\n\t\t\ttargetPowerCckExt.tPow2x[0] =\n\t\t\t\tmin((u16)targetPowerCckExt.tPow2x[0],\n\t\t\t\t    minCtlPower);\n\t\t\tbreak;\n\t\tcase CTL_11G_EXT:\n\t\t\ttargetPowerOfdmExt.tPow2x[0] =\n\t\t\t\tmin((u16)targetPowerOfdmExt.tPow2x[0],\n\t\t\t\t    minCtlPower);\n\t\t\tbreak;\n\t\tcase CTL_2GHT40:\n\t\t\tfor (i = 0; i < ARRAY_SIZE(targetPowerHt40.tPow2x); i++) {\n\t\t\t\ttargetPowerHt40.tPow2x[i] =\n\t\t\t\t\tmin((u16)targetPowerHt40.tPow2x[i],\n\t\t\t\t\t    minCtlPower);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tratesArray[rate6mb] =\n\tratesArray[rate9mb] =\n\tratesArray[rate12mb] =\n\tratesArray[rate18mb] =\n\tratesArray[rate24mb] =\n\ttargetPowerOfdm.tPow2x[0];\n\n\tratesArray[rate36mb] = targetPowerOfdm.tPow2x[1];\n\tratesArray[rate48mb] = targetPowerOfdm.tPow2x[2];\n\tratesArray[rate54mb] = targetPowerOfdm.tPow2x[3];\n\tratesArray[rateXr] = targetPowerOfdm.tPow2x[0];\n\n\tfor (i = 0; i < ARRAY_SIZE(targetPowerHt20.tPow2x); i++)\n\t\tratesArray[rateHt20_0 + i] = targetPowerHt20.tPow2x[i];\n\n\tratesArray[rate1l] = targetPowerCck.tPow2x[0];\n\tratesArray[rate2s] = ratesArray[rate2l] = targetPowerCck.tPow2x[1];\n\tratesArray[rate5_5s] = ratesArray[rate5_5l] = targetPowerCck.tPow2x[2];\n\tratesArray[rate11s] = ratesArray[rate11l] = targetPowerCck.tPow2x[3];\n\n\tif (IS_CHAN_HT40(chan)) {\n\t\tfor (i = 0; i < ARRAY_SIZE(targetPowerHt40.tPow2x); i++) {\n\t\t\tratesArray[rateHt40_0 + i] =\n\t\t\t\ttargetPowerHt40.tPow2x[i];\n\t\t}\n\t\tratesArray[rateDupOfdm] = targetPowerHt40.tPow2x[0];\n\t\tratesArray[rateDupCck] = targetPowerHt40.tPow2x[0];\n\t\tratesArray[rateExtOfdm] = targetPowerOfdmExt.tPow2x[0];\n\t\tratesArray[rateExtCck] = targetPowerCckExt.tPow2x[0];\n\t}\n\n#undef CMP_TEST_GRP\n}\n\nstatic void ath9k_hw_4k_set_txpower(struct ath_hw *ah,\n\t\t\t\t    struct ath9k_channel *chan,\n\t\t\t\t    u16 cfgCtl,\n\t\t\t\t    u8 twiceAntennaReduction,\n\t\t\t\t    u8 powerLimit, bool test)\n{\n\tstruct ath_regulatory *regulatory = ath9k_hw_regulatory(ah);\n\tstruct ar5416_eeprom_4k *pEepData = &ah->eeprom.map4k;\n\tstruct modal_eep_4k_header *pModal = &pEepData->modalHeader;\n\tint16_t ratesArray[Ar5416RateSize];\n\tu8 ht40PowerIncForPdadc = 2;\n\tint i;\n\n\tmemset(ratesArray, 0, sizeof(ratesArray));\n\n\tif (ath9k_hw_4k_get_eeprom_rev(ah) >= AR5416_EEP_MINOR_VER_2)\n\t\tht40PowerIncForPdadc = pModal->ht40PowerIncForPdadc;\n\n\tath9k_hw_set_4k_power_per_rate_table(ah, chan,\n\t\t\t\t\t     &ratesArray[0], cfgCtl,\n\t\t\t\t\t     twiceAntennaReduction,\n\t\t\t\t\t     powerLimit);\n\n\tath9k_hw_set_4k_power_cal_table(ah, chan);\n\n\tregulatory->max_power_level = 0;\n\tfor (i = 0; i < ARRAY_SIZE(ratesArray); i++) {\n\t\tif (ratesArray[i] > MAX_RATE_POWER)\n\t\t\tratesArray[i] = MAX_RATE_POWER;\n\n\t\tif (ratesArray[i] > regulatory->max_power_level)\n\t\t\tregulatory->max_power_level = ratesArray[i];\n\t}\n\n\tif (test)\n\t    return;\n\n\tfor (i = 0; i < Ar5416RateSize; i++)\n\t\tratesArray[i] -= AR5416_PWR_TABLE_OFFSET_DB * 2;\n\n\tENABLE_REGWRITE_BUFFER(ah);\n\n\t \n\tREG_WRITE(ah, AR_PHY_POWER_TX_RATE1,\n\t\t  ATH9K_POW_SM(ratesArray[rate18mb], 24)\n\t\t  | ATH9K_POW_SM(ratesArray[rate12mb], 16)\n\t\t  | ATH9K_POW_SM(ratesArray[rate9mb], 8)\n\t\t  | ATH9K_POW_SM(ratesArray[rate6mb], 0));\n\tREG_WRITE(ah, AR_PHY_POWER_TX_RATE2,\n\t\t  ATH9K_POW_SM(ratesArray[rate54mb], 24)\n\t\t  | ATH9K_POW_SM(ratesArray[rate48mb], 16)\n\t\t  | ATH9K_POW_SM(ratesArray[rate36mb], 8)\n\t\t  | ATH9K_POW_SM(ratesArray[rate24mb], 0));\n\n\t \n\tREG_WRITE(ah, AR_PHY_POWER_TX_RATE3,\n\t\t  ATH9K_POW_SM(ratesArray[rate2s], 24)\n\t\t  | ATH9K_POW_SM(ratesArray[rate2l], 16)\n\t\t  | ATH9K_POW_SM(ratesArray[rateXr], 8)\n\t\t  | ATH9K_POW_SM(ratesArray[rate1l], 0));\n\tREG_WRITE(ah, AR_PHY_POWER_TX_RATE4,\n\t\t  ATH9K_POW_SM(ratesArray[rate11s], 24)\n\t\t  | ATH9K_POW_SM(ratesArray[rate11l], 16)\n\t\t  | ATH9K_POW_SM(ratesArray[rate5_5s], 8)\n\t\t  | ATH9K_POW_SM(ratesArray[rate5_5l], 0));\n\n\t \n\tREG_WRITE(ah, AR_PHY_POWER_TX_RATE5,\n\t\t  ATH9K_POW_SM(ratesArray[rateHt20_3], 24)\n\t\t  | ATH9K_POW_SM(ratesArray[rateHt20_2], 16)\n\t\t  | ATH9K_POW_SM(ratesArray[rateHt20_1], 8)\n\t\t  | ATH9K_POW_SM(ratesArray[rateHt20_0], 0));\n\tREG_WRITE(ah, AR_PHY_POWER_TX_RATE6,\n\t\t  ATH9K_POW_SM(ratesArray[rateHt20_7], 24)\n\t\t  | ATH9K_POW_SM(ratesArray[rateHt20_6], 16)\n\t\t  | ATH9K_POW_SM(ratesArray[rateHt20_5], 8)\n\t\t  | ATH9K_POW_SM(ratesArray[rateHt20_4], 0));\n\n\t \n\tif (IS_CHAN_HT40(chan)) {\n\t\tREG_WRITE(ah, AR_PHY_POWER_TX_RATE7,\n\t\t\t  ATH9K_POW_SM(ratesArray[rateHt40_3] +\n\t\t\t\t       ht40PowerIncForPdadc, 24)\n\t\t\t  | ATH9K_POW_SM(ratesArray[rateHt40_2] +\n\t\t\t\t\t ht40PowerIncForPdadc, 16)\n\t\t\t  | ATH9K_POW_SM(ratesArray[rateHt40_1] +\n\t\t\t\t\t ht40PowerIncForPdadc, 8)\n\t\t\t  | ATH9K_POW_SM(ratesArray[rateHt40_0] +\n\t\t\t\t\t ht40PowerIncForPdadc, 0));\n\t\tREG_WRITE(ah, AR_PHY_POWER_TX_RATE8,\n\t\t\t  ATH9K_POW_SM(ratesArray[rateHt40_7] +\n\t\t\t\t       ht40PowerIncForPdadc, 24)\n\t\t\t  | ATH9K_POW_SM(ratesArray[rateHt40_6] +\n\t\t\t\t\t ht40PowerIncForPdadc, 16)\n\t\t\t  | ATH9K_POW_SM(ratesArray[rateHt40_5] +\n\t\t\t\t\t ht40PowerIncForPdadc, 8)\n\t\t\t  | ATH9K_POW_SM(ratesArray[rateHt40_4] +\n\t\t\t\t\t ht40PowerIncForPdadc, 0));\n\t\tREG_WRITE(ah, AR_PHY_POWER_TX_RATE9,\n\t\t\t  ATH9K_POW_SM(ratesArray[rateExtOfdm], 24)\n\t\t\t  | ATH9K_POW_SM(ratesArray[rateExtCck], 16)\n\t\t\t  | ATH9K_POW_SM(ratesArray[rateDupOfdm], 8)\n\t\t\t  | ATH9K_POW_SM(ratesArray[rateDupCck], 0));\n\t}\n\n\t \n\tif (ah->tpc_enabled) {\n\t\tint ht40_delta;\n\n\t\tht40_delta = (IS_CHAN_HT40(chan)) ? ht40PowerIncForPdadc : 0;\n\t\tar5008_hw_init_rate_txpower(ah, ratesArray, chan, ht40_delta);\n\t\t \n\t\tREG_WRITE(ah, AR_PHY_POWER_TX_RATE_MAX,\n\t\t\tMAX_RATE_POWER | AR_PHY_POWER_TX_RATE_MAX_TPC_ENABLE);\n\t} else {\n\t\t \n\t\tREG_WRITE(ah, AR_PHY_POWER_TX_RATE_MAX, MAX_RATE_POWER);\n\t}\n\n\tREGWRITE_BUFFER_FLUSH(ah);\n}\n\nstatic void ath9k_hw_4k_set_gain(struct ath_hw *ah,\n\t\t\t\t struct modal_eep_4k_header *pModal,\n\t\t\t\t struct ar5416_eeprom_4k *eep,\n\t\t\t\t u8 txRxAttenLocal)\n{\n\tENABLE_REG_RMW_BUFFER(ah);\n\tREG_RMW(ah, AR_PHY_SWITCH_CHAIN_0,\n\t\tle32_to_cpu(pModal->antCtrlChain[0]), 0);\n\n\tREG_RMW(ah, AR_PHY_TIMING_CTRL4(0),\n\t\tSM(pModal->iqCalICh[0], AR_PHY_TIMING_CTRL4_IQCORR_Q_I_COFF) |\n\t\tSM(pModal->iqCalQCh[0], AR_PHY_TIMING_CTRL4_IQCORR_Q_Q_COFF),\n\t\tAR_PHY_TIMING_CTRL4_IQCORR_Q_Q_COFF | AR_PHY_TIMING_CTRL4_IQCORR_Q_I_COFF);\n\n\tif (ath9k_hw_4k_get_eeprom_rev(ah) >= AR5416_EEP_MINOR_VER_3) {\n\t\ttxRxAttenLocal = pModal->txRxAttenCh[0];\n\n\t\tREG_RMW_FIELD(ah, AR_PHY_GAIN_2GHZ,\n\t\t\t      AR_PHY_GAIN_2GHZ_XATTEN1_MARGIN, pModal->bswMargin[0]);\n\t\tREG_RMW_FIELD(ah, AR_PHY_GAIN_2GHZ,\n\t\t\t      AR_PHY_GAIN_2GHZ_XATTEN1_DB, pModal->bswAtten[0]);\n\t\tREG_RMW_FIELD(ah, AR_PHY_GAIN_2GHZ,\n\t\t\t      AR_PHY_GAIN_2GHZ_XATTEN2_MARGIN,\n\t\t\t      pModal->xatten2Margin[0]);\n\t\tREG_RMW_FIELD(ah, AR_PHY_GAIN_2GHZ,\n\t\t\t      AR_PHY_GAIN_2GHZ_XATTEN2_DB, pModal->xatten2Db[0]);\n\n\t\t \n\t\tREG_RMW_FIELD(ah, AR_PHY_GAIN_2GHZ + 0x1000,\n\t\t\t      AR_PHY_GAIN_2GHZ_XATTEN1_MARGIN,\n\t\t\t      pModal->bswMargin[0]);\n\t\tREG_RMW_FIELD(ah, AR_PHY_GAIN_2GHZ + 0x1000,\n\t\t\t      AR_PHY_GAIN_2GHZ_XATTEN1_DB, pModal->bswAtten[0]);\n\t\tREG_RMW_FIELD(ah, AR_PHY_GAIN_2GHZ + 0x1000,\n\t\t\t      AR_PHY_GAIN_2GHZ_XATTEN2_MARGIN,\n\t\t\t      pModal->xatten2Margin[0]);\n\t\tREG_RMW_FIELD(ah, AR_PHY_GAIN_2GHZ + 0x1000,\n\t\t\t      AR_PHY_GAIN_2GHZ_XATTEN2_DB,\n\t\t\t      pModal->xatten2Db[0]);\n\t}\n\n\tREG_RMW_FIELD(ah, AR_PHY_RXGAIN,\n\t\t      AR9280_PHY_RXGAIN_TXRX_ATTEN, txRxAttenLocal);\n\tREG_RMW_FIELD(ah, AR_PHY_RXGAIN,\n\t\t      AR9280_PHY_RXGAIN_TXRX_MARGIN, pModal->rxTxMarginCh[0]);\n\n\tREG_RMW_FIELD(ah, AR_PHY_RXGAIN + 0x1000,\n\t\t      AR9280_PHY_RXGAIN_TXRX_ATTEN, txRxAttenLocal);\n\tREG_RMW_FIELD(ah, AR_PHY_RXGAIN + 0x1000,\n\t\t      AR9280_PHY_RXGAIN_TXRX_MARGIN, pModal->rxTxMarginCh[0]);\n\tREG_RMW_BUFFER_FLUSH(ah);\n}\n\n \nstatic void ath9k_hw_4k_set_board_values(struct ath_hw *ah,\n\t\t\t\t\t struct ath9k_channel *chan)\n{\n\tstruct ath9k_hw_capabilities *pCap = &ah->caps;\n\tstruct modal_eep_4k_header *pModal;\n\tstruct ar5416_eeprom_4k *eep = &ah->eeprom.map4k;\n\tstruct base_eep_header_4k *pBase = &eep->baseEepHeader;\n\tu8 txRxAttenLocal;\n\tu8 ob[5], db1[5], db2[5];\n\tu8 ant_div_control1, ant_div_control2;\n\tu8 bb_desired_scale;\n\tu32 regVal;\n\n\tpModal = &eep->modalHeader;\n\ttxRxAttenLocal = 23;\n\n\tREG_WRITE(ah, AR_PHY_SWITCH_COM, le32_to_cpu(pModal->antCtrlCommon));\n\n\t \n\tath9k_hw_4k_set_gain(ah, pModal, eep, txRxAttenLocal);\n\n\t \n\tif (pModal->version >= 3) {\n\t\tant_div_control1 = pModal->antdiv_ctl1;\n\t\tant_div_control2 = pModal->antdiv_ctl2;\n\n\t\tregVal = REG_READ(ah, AR_PHY_MULTICHAIN_GAIN_CTL);\n\t\tregVal &= (~(AR_PHY_9285_ANT_DIV_CTL_ALL));\n\n\t\tregVal |= SM(ant_div_control1,\n\t\t\t     AR_PHY_9285_ANT_DIV_CTL);\n\t\tregVal |= SM(ant_div_control2,\n\t\t\t     AR_PHY_9285_ANT_DIV_ALT_LNACONF);\n\t\tregVal |= SM((ant_div_control2 >> 2),\n\t\t\t     AR_PHY_9285_ANT_DIV_MAIN_LNACONF);\n\t\tregVal |= SM((ant_div_control1 >> 1),\n\t\t\t     AR_PHY_9285_ANT_DIV_ALT_GAINTB);\n\t\tregVal |= SM((ant_div_control1 >> 2),\n\t\t\t     AR_PHY_9285_ANT_DIV_MAIN_GAINTB);\n\n\n\t\tREG_WRITE(ah, AR_PHY_MULTICHAIN_GAIN_CTL, regVal);\n\t\tregVal = REG_READ(ah, AR_PHY_MULTICHAIN_GAIN_CTL);\n\t\tregVal = REG_READ(ah, AR_PHY_CCK_DETECT);\n\t\tregVal &= (~AR_PHY_CCK_DETECT_BB_ENABLE_ANT_FAST_DIV);\n\t\tregVal |= SM((ant_div_control1 >> 3),\n\t\t\t     AR_PHY_CCK_DETECT_BB_ENABLE_ANT_FAST_DIV);\n\n\t\tREG_WRITE(ah, AR_PHY_CCK_DETECT, regVal);\n\t\tregVal = REG_READ(ah, AR_PHY_CCK_DETECT);\n\n\t\tif (pCap->hw_caps & ATH9K_HW_CAP_ANT_DIV_COMB) {\n\t\t\t \n\t\t\tregVal = REG_READ(ah, AR_PHY_MULTICHAIN_GAIN_CTL);\n\t\t\tregVal &= (~(AR_PHY_9285_ANT_DIV_MAIN_LNACONF |\n\t\t\t\t     AR_PHY_9285_ANT_DIV_ALT_LNACONF));\n\n\t\t\tregVal |= (ATH_ANT_DIV_COMB_LNA1 <<\n\t\t\t\t   AR_PHY_9285_ANT_DIV_MAIN_LNACONF_S);\n\t\t\tregVal |= (ATH_ANT_DIV_COMB_LNA2 <<\n\t\t\t\t   AR_PHY_9285_ANT_DIV_ALT_LNACONF_S);\n\t\t\tregVal &= (~(AR_PHY_9285_FAST_DIV_BIAS));\n\t\t\tregVal |= (0 << AR_PHY_9285_FAST_DIV_BIAS_S);\n\t\t\tREG_WRITE(ah, AR_PHY_MULTICHAIN_GAIN_CTL, regVal);\n\t\t}\n\t}\n\n\tif (pModal->version >= 2) {\n\t\tob[0] = pModal->ob_0;\n\t\tob[1] = pModal->ob_1;\n\t\tob[2] = pModal->ob_2;\n\t\tob[3] = pModal->ob_3;\n\t\tob[4] = pModal->ob_4;\n\n\t\tdb1[0] = pModal->db1_0;\n\t\tdb1[1] = pModal->db1_1;\n\t\tdb1[2] = pModal->db1_2;\n\t\tdb1[3] = pModal->db1_3;\n\t\tdb1[4] = pModal->db1_4;\n\n\t\tdb2[0] = pModal->db2_0;\n\t\tdb2[1] = pModal->db2_1;\n\t\tdb2[2] = pModal->db2_2;\n\t\tdb2[3] = pModal->db2_3;\n\t\tdb2[4] = pModal->db2_4;\n\t} else if (pModal->version == 1) {\n\t\tob[0] = pModal->ob_0;\n\t\tob[1] = ob[2] = ob[3] = ob[4] = pModal->ob_1;\n\t\tdb1[0] = pModal->db1_0;\n\t\tdb1[1] = db1[2] = db1[3] = db1[4] = pModal->db1_1;\n\t\tdb2[0] = pModal->db2_0;\n\t\tdb2[1] = db2[2] = db2[3] = db2[4] = pModal->db2_1;\n\t} else {\n\t\tint i;\n\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\tob[i] = pModal->ob_0;\n\t\t\tdb1[i] = pModal->db1_0;\n\t\t\tdb2[i] = pModal->db1_0;\n\t\t}\n\t}\n\n\tENABLE_REG_RMW_BUFFER(ah);\n\tif (AR_SREV_9271(ah)) {\n\t\tath9k_hw_analog_shift_rmw(ah,\n\t\t\t\t\t  AR9285_AN_RF2G3,\n\t\t\t\t\t  AR9271_AN_RF2G3_OB_cck,\n\t\t\t\t\t  AR9271_AN_RF2G3_OB_cck_S,\n\t\t\t\t\t  ob[0]);\n\t\tath9k_hw_analog_shift_rmw(ah,\n\t\t\t\t\t  AR9285_AN_RF2G3,\n\t\t\t\t\t  AR9271_AN_RF2G3_OB_psk,\n\t\t\t\t\t  AR9271_AN_RF2G3_OB_psk_S,\n\t\t\t\t\t  ob[1]);\n\t\tath9k_hw_analog_shift_rmw(ah,\n\t\t\t\t\t  AR9285_AN_RF2G3,\n\t\t\t\t\t  AR9271_AN_RF2G3_OB_qam,\n\t\t\t\t\t  AR9271_AN_RF2G3_OB_qam_S,\n\t\t\t\t\t  ob[2]);\n\t\tath9k_hw_analog_shift_rmw(ah,\n\t\t\t\t\t  AR9285_AN_RF2G3,\n\t\t\t\t\t  AR9271_AN_RF2G3_DB_1,\n\t\t\t\t\t  AR9271_AN_RF2G3_DB_1_S,\n\t\t\t\t\t  db1[0]);\n\t\tath9k_hw_analog_shift_rmw(ah,\n\t\t\t\t\t  AR9285_AN_RF2G4,\n\t\t\t\t\t  AR9271_AN_RF2G4_DB_2,\n\t\t\t\t\t  AR9271_AN_RF2G4_DB_2_S,\n\t\t\t\t\t  db2[0]);\n\t} else {\n\t\tath9k_hw_analog_shift_rmw(ah,\n\t\t\t\t\t  AR9285_AN_RF2G3,\n\t\t\t\t\t  AR9285_AN_RF2G3_OB_0,\n\t\t\t\t\t  AR9285_AN_RF2G3_OB_0_S,\n\t\t\t\t\t  ob[0]);\n\t\tath9k_hw_analog_shift_rmw(ah,\n\t\t\t\t\t  AR9285_AN_RF2G3,\n\t\t\t\t\t  AR9285_AN_RF2G3_OB_1,\n\t\t\t\t\t  AR9285_AN_RF2G3_OB_1_S,\n\t\t\t\t\t  ob[1]);\n\t\tath9k_hw_analog_shift_rmw(ah,\n\t\t\t\t\t  AR9285_AN_RF2G3,\n\t\t\t\t\t  AR9285_AN_RF2G3_OB_2,\n\t\t\t\t\t  AR9285_AN_RF2G3_OB_2_S,\n\t\t\t\t\t  ob[2]);\n\t\tath9k_hw_analog_shift_rmw(ah,\n\t\t\t\t\t  AR9285_AN_RF2G3,\n\t\t\t\t\t  AR9285_AN_RF2G3_OB_3,\n\t\t\t\t\t  AR9285_AN_RF2G3_OB_3_S,\n\t\t\t\t\t  ob[3]);\n\t\tath9k_hw_analog_shift_rmw(ah,\n\t\t\t\t\t  AR9285_AN_RF2G3,\n\t\t\t\t\t  AR9285_AN_RF2G3_OB_4,\n\t\t\t\t\t  AR9285_AN_RF2G3_OB_4_S,\n\t\t\t\t\t  ob[4]);\n\n\t\tath9k_hw_analog_shift_rmw(ah,\n\t\t\t\t\t  AR9285_AN_RF2G3,\n\t\t\t\t\t  AR9285_AN_RF2G3_DB1_0,\n\t\t\t\t\t  AR9285_AN_RF2G3_DB1_0_S,\n\t\t\t\t\t  db1[0]);\n\t\tath9k_hw_analog_shift_rmw(ah,\n\t\t\t\t\t  AR9285_AN_RF2G3,\n\t\t\t\t\t  AR9285_AN_RF2G3_DB1_1,\n\t\t\t\t\t  AR9285_AN_RF2G3_DB1_1_S,\n\t\t\t\t\t  db1[1]);\n\t\tath9k_hw_analog_shift_rmw(ah,\n\t\t\t\t\t  AR9285_AN_RF2G3,\n\t\t\t\t\t  AR9285_AN_RF2G3_DB1_2,\n\t\t\t\t\t  AR9285_AN_RF2G3_DB1_2_S,\n\t\t\t\t\t  db1[2]);\n\t\tath9k_hw_analog_shift_rmw(ah,\n\t\t\t\t\t  AR9285_AN_RF2G4,\n\t\t\t\t\t  AR9285_AN_RF2G4_DB1_3,\n\t\t\t\t\t  AR9285_AN_RF2G4_DB1_3_S,\n\t\t\t\t\t  db1[3]);\n\t\tath9k_hw_analog_shift_rmw(ah,\n\t\t\t\t\t  AR9285_AN_RF2G4,\n\t\t\t\t\t  AR9285_AN_RF2G4_DB1_4,\n\t\t\t\t\t  AR9285_AN_RF2G4_DB1_4_S, db1[4]);\n\n\t\tath9k_hw_analog_shift_rmw(ah,\n\t\t\t\t\t  AR9285_AN_RF2G4,\n\t\t\t\t\t  AR9285_AN_RF2G4_DB2_0,\n\t\t\t\t\t  AR9285_AN_RF2G4_DB2_0_S,\n\t\t\t\t\t  db2[0]);\n\t\tath9k_hw_analog_shift_rmw(ah,\n\t\t\t\t\t  AR9285_AN_RF2G4,\n\t\t\t\t\t  AR9285_AN_RF2G4_DB2_1,\n\t\t\t\t\t  AR9285_AN_RF2G4_DB2_1_S,\n\t\t\t\t\t  db2[1]);\n\t\tath9k_hw_analog_shift_rmw(ah,\n\t\t\t\t\t  AR9285_AN_RF2G4,\n\t\t\t\t\t  AR9285_AN_RF2G4_DB2_2,\n\t\t\t\t\t  AR9285_AN_RF2G4_DB2_2_S,\n\t\t\t\t\t  db2[2]);\n\t\tath9k_hw_analog_shift_rmw(ah,\n\t\t\t\t\t  AR9285_AN_RF2G4,\n\t\t\t\t\t  AR9285_AN_RF2G4_DB2_3,\n\t\t\t\t\t  AR9285_AN_RF2G4_DB2_3_S,\n\t\t\t\t\t  db2[3]);\n\t\tath9k_hw_analog_shift_rmw(ah,\n\t\t\t\t\t  AR9285_AN_RF2G4,\n\t\t\t\t\t  AR9285_AN_RF2G4_DB2_4,\n\t\t\t\t\t  AR9285_AN_RF2G4_DB2_4_S,\n\t\t\t\t\t  db2[4]);\n\t}\n\tREG_RMW_BUFFER_FLUSH(ah);\n\n\tENABLE_REG_RMW_BUFFER(ah);\n\tREG_RMW_FIELD(ah, AR_PHY_SETTLING, AR_PHY_SETTLING_SWITCH,\n\t\t      pModal->switchSettling);\n\tREG_RMW_FIELD(ah, AR_PHY_DESIRED_SZ, AR_PHY_DESIRED_SZ_ADC,\n\t\t      pModal->adcDesiredSize);\n\n\tREG_RMW(ah, AR_PHY_RF_CTL4,\n\t\tSM(pModal->txEndToXpaOff, AR_PHY_RF_CTL4_TX_END_XPAA_OFF) |\n\t\tSM(pModal->txEndToXpaOff, AR_PHY_RF_CTL4_TX_END_XPAB_OFF) |\n\t\tSM(pModal->txFrameToXpaOn, AR_PHY_RF_CTL4_FRAME_XPAA_ON)  |\n\t\tSM(pModal->txFrameToXpaOn, AR_PHY_RF_CTL4_FRAME_XPAB_ON), 0);\n\n\tREG_RMW_FIELD(ah, AR_PHY_RF_CTL3, AR_PHY_TX_END_TO_A2_RX_ON,\n\t\t      pModal->txEndToRxOn);\n\n\tif (AR_SREV_9271_10(ah))\n\t\tREG_RMW_FIELD(ah, AR_PHY_RF_CTL3, AR_PHY_TX_END_TO_A2_RX_ON,\n\t\t\t      pModal->txEndToRxOn);\n\tREG_RMW_FIELD(ah, AR_PHY_CCA, AR9280_PHY_CCA_THRESH62,\n\t\t      pModal->thresh62);\n\tREG_RMW_FIELD(ah, AR_PHY_EXT_CCA0, AR_PHY_EXT_CCA0_THRESH62,\n\t\t      pModal->thresh62);\n\n\tif (ath9k_hw_4k_get_eeprom_rev(ah) >= AR5416_EEP_MINOR_VER_2) {\n\t\tREG_RMW_FIELD(ah, AR_PHY_RF_CTL2, AR_PHY_TX_END_DATA_START,\n\t\t\t      pModal->txFrameToDataStart);\n\t\tREG_RMW_FIELD(ah, AR_PHY_RF_CTL2, AR_PHY_TX_END_PA_ON,\n\t\t\t      pModal->txFrameToPaOn);\n\t}\n\n\tif (ath9k_hw_4k_get_eeprom_rev(ah) >= AR5416_EEP_MINOR_VER_3) {\n\t\tif (IS_CHAN_HT40(chan))\n\t\t\tREG_RMW_FIELD(ah, AR_PHY_SETTLING,\n\t\t\t\t      AR_PHY_SETTLING_SWITCH,\n\t\t\t\t      pModal->swSettleHt40);\n\t}\n\n\tREG_RMW_BUFFER_FLUSH(ah);\n\n\tbb_desired_scale = (pModal->bb_scale_smrt_antenna &\n\t\t\tEEP_4K_BB_DESIRED_SCALE_MASK);\n\tif ((pBase->txGainType == 0) && (bb_desired_scale != 0)) {\n\t\tu32 pwrctrl, mask, clr;\n\n\t\tmask = BIT(0)|BIT(5)|BIT(10)|BIT(15)|BIT(20)|BIT(25);\n\t\tpwrctrl = mask * bb_desired_scale;\n\t\tclr = mask * 0x1f;\n\t\tENABLE_REG_RMW_BUFFER(ah);\n\t\tREG_RMW(ah, AR_PHY_TX_PWRCTRL8, pwrctrl, clr);\n\t\tREG_RMW(ah, AR_PHY_TX_PWRCTRL10, pwrctrl, clr);\n\t\tREG_RMW(ah, AR_PHY_CH0_TX_PWRCTRL12, pwrctrl, clr);\n\n\t\tmask = BIT(0)|BIT(5)|BIT(15);\n\t\tpwrctrl = mask * bb_desired_scale;\n\t\tclr = mask * 0x1f;\n\t\tREG_RMW(ah, AR_PHY_TX_PWRCTRL9, pwrctrl, clr);\n\n\t\tmask = BIT(0)|BIT(5);\n\t\tpwrctrl = mask * bb_desired_scale;\n\t\tclr = mask * 0x1f;\n\t\tREG_RMW(ah, AR_PHY_CH0_TX_PWRCTRL11, pwrctrl, clr);\n\t\tREG_RMW(ah, AR_PHY_CH0_TX_PWRCTRL13, pwrctrl, clr);\n\t\tREG_RMW_BUFFER_FLUSH(ah);\n\t}\n}\n\nstatic u16 ath9k_hw_4k_get_spur_channel(struct ath_hw *ah, u16 i, bool is2GHz)\n{\n\treturn le16_to_cpu(ah->eeprom.map4k.modalHeader.spurChans[i].spurChan);\n}\n\nstatic u8 ath9k_hw_4k_get_eepmisc(struct ath_hw *ah)\n{\n\treturn ah->eeprom.map4k.baseEepHeader.eepMisc;\n}\n\nconst struct eeprom_ops eep_4k_ops = {\n\t.check_eeprom\t\t= ath9k_hw_4k_check_eeprom,\n\t.get_eeprom\t\t= ath9k_hw_4k_get_eeprom,\n\t.fill_eeprom\t\t= ath9k_hw_4k_fill_eeprom,\n\t.dump_eeprom\t\t= ath9k_hw_4k_dump_eeprom,\n\t.get_eeprom_ver\t\t= ath9k_hw_4k_get_eeprom_ver,\n\t.get_eeprom_rev\t\t= ath9k_hw_4k_get_eeprom_rev,\n\t.set_board_values\t= ath9k_hw_4k_set_board_values,\n\t.set_txpower\t\t= ath9k_hw_4k_set_txpower,\n\t.get_spur_channel\t= ath9k_hw_4k_get_spur_channel,\n\t.get_eepmisc\t\t= ath9k_hw_4k_get_eepmisc\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}