{
  "module_name": "channel.c",
  "hash_id": "ca4f0466ebb4ec458e2c9a9d7c94c3a0625bc7402fba798836d367e46bd54722",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath9k/channel.c",
  "human_readable_source": " \n\n#include \"ath9k.h\"\n\n \nstatic int ath_set_channel(struct ath_softc *sc)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ieee80211_hw *hw = sc->hw;\n\tstruct ath9k_channel *hchan;\n\tstruct cfg80211_chan_def *chandef = &sc->cur_chan->chandef;\n\tstruct ieee80211_channel *chan = chandef->chan;\n\tint pos = chan->hw_value;\n\tunsigned long flags;\n\tint old_pos = -1;\n\tint r;\n\n\tif (test_bit(ATH_OP_INVALID, &common->op_flags))\n\t\treturn -EIO;\n\n\tif (ah->curchan)\n\t\told_pos = ah->curchan - &ah->channels[0];\n\n\tath_dbg(common, CONFIG, \"Set channel: %d MHz width: %d\\n\",\n\t\tchan->center_freq, chandef->width);\n\n\t \n\tspin_lock_irqsave(&common->cc_lock, flags);\n\tath_update_survey_stats(sc);\n\tspin_unlock_irqrestore(&common->cc_lock, flags);\n\n\tath9k_cmn_get_channel(hw, ah, chandef);\n\n\t \n\tif (!sc->cur_chan->offchannel && sc->cur_survey != &sc->survey[pos]) {\n\t\tif (sc->cur_survey)\n\t\t\tsc->cur_survey->filled &= ~SURVEY_INFO_IN_USE;\n\n\t\tsc->cur_survey = &sc->survey[pos];\n\n\t\tmemset(sc->cur_survey, 0, sizeof(struct survey_info));\n\t\tsc->cur_survey->filled |= SURVEY_INFO_IN_USE;\n\t} else if (!(sc->survey[pos].filled & SURVEY_INFO_IN_USE)) {\n\t\tmemset(&sc->survey[pos], 0, sizeof(struct survey_info));\n\t}\n\n\thchan = &sc->sc_ah->channels[pos];\n\tr = ath_reset(sc, hchan);\n\tif (r)\n\t\treturn r;\n\n\t \n\tif (old_pos >= 0)\n\t\tath_update_survey_nf(sc, old_pos);\n\n\t \n\tif (hw->conf.radar_enabled) {\n\t\tu32 rxfilter;\n\n\t\trxfilter = ath9k_hw_getrxfilter(ah);\n\t\trxfilter |= ATH9K_RX_FILTER_PHYRADAR |\n\t\t\t\tATH9K_RX_FILTER_PHYERR;\n\t\tath9k_hw_setrxfilter(ah, rxfilter);\n\t\tath_dbg(common, DFS, \"DFS enabled at freq %d\\n\",\n\t\t\tchan->center_freq);\n\t} else {\n\t\t \n\t\tif (test_bit(ATH_OP_SCANNING, &common->op_flags) &&\n\t\t\tsc->spec_priv.spectral_mode == SPECTRAL_CHANSCAN)\n\t\t\tath9k_cmn_spectral_scan_trigger(common, &sc->spec_priv);\n\t}\n\n\treturn 0;\n}\n\nvoid ath_chanctx_init(struct ath_softc *sc)\n{\n\tstruct ath_chanctx *ctx;\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_channel *chan;\n\tint i, j;\n\n\tsband = &common->sbands[NL80211_BAND_2GHZ];\n\tif (!sband->n_channels)\n\t\tsband = &common->sbands[NL80211_BAND_5GHZ];\n\n\tchan = &sband->channels[0];\n\tfor (i = 0; i < ATH9K_NUM_CHANCTX; i++) {\n\t\tctx = &sc->chanctx[i];\n\t\tcfg80211_chandef_create(&ctx->chandef, chan, NL80211_CHAN_HT20);\n\t\tINIT_LIST_HEAD(&ctx->vifs);\n\t\tctx->txpower = ATH_TXPOWER_MAX;\n\t\tctx->flush_timeout = HZ / 5;  \n\t\tfor (j = 0; j < ARRAY_SIZE(ctx->acq); j++) {\n\t\t\tINIT_LIST_HEAD(&ctx->acq[j].acq_new);\n\t\t\tINIT_LIST_HEAD(&ctx->acq[j].acq_old);\n\t\t\tspin_lock_init(&ctx->acq[j].lock);\n\t\t}\n\t}\n}\n\nvoid ath_chanctx_set_channel(struct ath_softc *sc, struct ath_chanctx *ctx,\n\t\t\t     struct cfg80211_chan_def *chandef)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tbool cur_chan;\n\n\tspin_lock_bh(&sc->chan_lock);\n\tif (chandef)\n\t\tmemcpy(&ctx->chandef, chandef, sizeof(*chandef));\n\tcur_chan = sc->cur_chan == ctx;\n\tspin_unlock_bh(&sc->chan_lock);\n\n\tif (!cur_chan) {\n\t\tath_dbg(common, CHAN_CTX,\n\t\t\t\"Current context differs from the new context\\n\");\n\t\treturn;\n\t}\n\n\tath_set_channel(sc);\n}\n\n#ifdef CONFIG_ATH9K_CHANNEL_CONTEXT\n\n \n \n \n\nstruct ath_chanctx* ath_is_go_chanctx_present(struct ath_softc *sc)\n{\n\tstruct ath_chanctx *ctx;\n\tstruct ath_vif *avp;\n\tstruct ieee80211_vif *vif;\n\n\tspin_lock_bh(&sc->chan_lock);\n\n\tath_for_each_chanctx(sc, ctx) {\n\t\tif (!ctx->active)\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(avp, &ctx->vifs, list) {\n\t\t\tvif = avp->vif;\n\n\t\t\tif (ieee80211_vif_type_p2p(vif) == NL80211_IFTYPE_P2P_GO) {\n\t\t\t\tspin_unlock_bh(&sc->chan_lock);\n\t\t\t\treturn ctx;\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_unlock_bh(&sc->chan_lock);\n\treturn NULL;\n}\n\n \n \n \n\nstatic const char *offchannel_state_string(enum ath_offchannel_state state)\n{\n\tswitch (state) {\n\t\tcase_rtn_string(ATH_OFFCHANNEL_IDLE);\n\t\tcase_rtn_string(ATH_OFFCHANNEL_PROBE_SEND);\n\t\tcase_rtn_string(ATH_OFFCHANNEL_PROBE_WAIT);\n\t\tcase_rtn_string(ATH_OFFCHANNEL_SUSPEND);\n\t\tcase_rtn_string(ATH_OFFCHANNEL_ROC_START);\n\t\tcase_rtn_string(ATH_OFFCHANNEL_ROC_WAIT);\n\t\tcase_rtn_string(ATH_OFFCHANNEL_ROC_DONE);\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\nstatic const char *chanctx_event_string(enum ath_chanctx_event ev)\n{\n\tswitch (ev) {\n\t\tcase_rtn_string(ATH_CHANCTX_EVENT_BEACON_PREPARE);\n\t\tcase_rtn_string(ATH_CHANCTX_EVENT_BEACON_SENT);\n\t\tcase_rtn_string(ATH_CHANCTX_EVENT_TSF_TIMER);\n\t\tcase_rtn_string(ATH_CHANCTX_EVENT_BEACON_RECEIVED);\n\t\tcase_rtn_string(ATH_CHANCTX_EVENT_AUTHORIZED);\n\t\tcase_rtn_string(ATH_CHANCTX_EVENT_SWITCH);\n\t\tcase_rtn_string(ATH_CHANCTX_EVENT_ASSIGN);\n\t\tcase_rtn_string(ATH_CHANCTX_EVENT_UNASSIGN);\n\t\tcase_rtn_string(ATH_CHANCTX_EVENT_CHANGE);\n\t\tcase_rtn_string(ATH_CHANCTX_EVENT_ENABLE_MULTICHANNEL);\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\nstatic const char *chanctx_state_string(enum ath_chanctx_state state)\n{\n\tswitch (state) {\n\t\tcase_rtn_string(ATH_CHANCTX_STATE_IDLE);\n\t\tcase_rtn_string(ATH_CHANCTX_STATE_WAIT_FOR_BEACON);\n\t\tcase_rtn_string(ATH_CHANCTX_STATE_WAIT_FOR_TIMER);\n\t\tcase_rtn_string(ATH_CHANCTX_STATE_SWITCH);\n\t\tcase_rtn_string(ATH_CHANCTX_STATE_FORCE_ACTIVE);\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\nstatic u32 chanctx_event_delta(struct ath_softc *sc)\n{\n\tu64 ms;\n\tstruct timespec64 ts, *old;\n\n\tktime_get_raw_ts64(&ts);\n\told = &sc->last_event_time;\n\tms = ts.tv_sec * 1000 + ts.tv_nsec / 1000000;\n\tms -= old->tv_sec * 1000 + old->tv_nsec / 1000000;\n\tsc->last_event_time = ts;\n\n\treturn (u32)ms;\n}\n\nvoid ath_chanctx_check_active(struct ath_softc *sc, struct ath_chanctx *ctx)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ath_chanctx *ictx;\n\tstruct ath_vif *avp;\n\tbool active = false;\n\tu8 n_active = 0;\n\n\tif (!ctx)\n\t\treturn;\n\n\tif (ctx == &sc->offchannel.chan) {\n\t\tspin_lock_bh(&sc->chan_lock);\n\n\t\tif (likely(sc->sched.channel_switch_time))\n\t\t\tctx->flush_timeout =\n\t\t\t\tusecs_to_jiffies(sc->sched.channel_switch_time);\n\t\telse\n\t\t\tctx->flush_timeout =\n\t\t\t\tmsecs_to_jiffies(10);\n\n\t\tspin_unlock_bh(&sc->chan_lock);\n\n\t\t \n\t\treturn;\n\t}\n\n\tictx = ctx;\n\n\tlist_for_each_entry(avp, &ctx->vifs, list) {\n\t\tstruct ieee80211_vif *vif = avp->vif;\n\n\t\tswitch (vif->type) {\n\t\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tcase NL80211_IFTYPE_STATION:\n\t\t\tif (avp->assoc)\n\t\t\t\tactive = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tactive = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tctx->active = active;\n\n\tath_for_each_chanctx(sc, ctx) {\n\t\tif (!ctx->assigned || list_empty(&ctx->vifs))\n\t\t\tcontinue;\n\t\tn_active++;\n\t}\n\n\tspin_lock_bh(&sc->chan_lock);\n\n\tif (n_active <= 1) {\n\t\tictx->flush_timeout = HZ / 5;\n\t\tclear_bit(ATH_OP_MULTI_CHANNEL, &common->op_flags);\n\t\tspin_unlock_bh(&sc->chan_lock);\n\t\treturn;\n\t}\n\n\tictx->flush_timeout = usecs_to_jiffies(sc->sched.channel_switch_time);\n\n\tif (test_and_set_bit(ATH_OP_MULTI_CHANNEL, &common->op_flags)) {\n\t\tspin_unlock_bh(&sc->chan_lock);\n\t\treturn;\n\t}\n\n\tspin_unlock_bh(&sc->chan_lock);\n\n\tif (ath9k_is_chanctx_enabled()) {\n\t\tath_chanctx_event(sc, NULL,\n\t\t\t\t  ATH_CHANCTX_EVENT_ENABLE_MULTICHANNEL);\n\t}\n}\n\nstatic struct ath_chanctx *\nath_chanctx_get_next(struct ath_softc *sc, struct ath_chanctx *ctx)\n{\n\tint idx = ctx - &sc->chanctx[0];\n\n\treturn &sc->chanctx[!idx];\n}\n\nstatic void ath_chanctx_adjust_tbtt_delta(struct ath_softc *sc)\n{\n\tstruct ath_chanctx *prev, *cur;\n\tstruct timespec64 ts;\n\tu32 cur_tsf, prev_tsf, beacon_int;\n\ts32 offset;\n\n\tbeacon_int = TU_TO_USEC(sc->cur_chan->beacon.beacon_interval);\n\n\tcur = sc->cur_chan;\n\tprev = ath_chanctx_get_next(sc, cur);\n\n\tif (!prev->switch_after_beacon)\n\t\treturn;\n\n\tktime_get_raw_ts64(&ts);\n\tcur_tsf = (u32) cur->tsf_val +\n\t\t  ath9k_hw_get_tsf_offset(&cur->tsf_ts, &ts);\n\n\tprev_tsf = prev->last_beacon - (u32) prev->tsf_val + cur_tsf;\n\tprev_tsf -= ath9k_hw_get_tsf_offset(&prev->tsf_ts, &ts);\n\n\t \n\toffset = cur_tsf - prev_tsf;\n\n\t \n\tif (offset < 0 || offset > 3 * beacon_int)\n\t\treturn;\n\n\toffset = beacon_int / 2 - (offset % beacon_int);\n\tprev->tsf_val += offset;\n}\n\n \nstatic void ath_chanctx_setup_timer(struct ath_softc *sc, u32 tsf_time)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ath_hw *ah = sc->sc_ah;\n\tunsigned long timeout;\n\n\tath9k_hw_gen_timer_start(ah, sc->p2p_ps_timer, tsf_time, 1000000);\n\ttsf_time -= ath9k_hw_gettsf32(ah);\n\ttimeout = msecs_to_jiffies(tsf_time / 1000) + 1;\n\tmod_timer(&sc->sched.timer, jiffies + timeout);\n\n\tath_dbg(common, CHAN_CTX,\n\t\t\"Setup chanctx timer with timeout: %d (%d) ms\\n\",\n\t\ttsf_time / 1000, jiffies_to_msecs(timeout));\n}\n\nstatic void ath_chanctx_handle_bmiss(struct ath_softc *sc,\n\t\t\t\t     struct ath_chanctx *ctx,\n\t\t\t\t     struct ath_vif *avp)\n{\n\t \n\tif (ctx->active && sc->sched.extend_absence) {\n\t\tavp->noa_duration = 0;\n\t\tsc->sched.extend_absence = false;\n\t}\n\n\t \n\tif (ctx->active && sc->sched.beacon_miss >= 2) {\n\t\tavp->noa_duration = 0;\n\t\tsc->sched.extend_absence = true;\n\t}\n}\n\nstatic void ath_chanctx_offchannel_noa(struct ath_softc *sc,\n\t\t\t\t       struct ath_chanctx *ctx,\n\t\t\t\t       struct ath_vif *avp,\n\t\t\t\t       u32 tsf_time)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\n\tavp->noa_index++;\n\tavp->offchannel_start = tsf_time;\n\tavp->offchannel_duration = sc->sched.offchannel_duration;\n\n\tath_dbg(common, CHAN_CTX,\n\t\t\"offchannel noa_duration: %d, noa_start: %u, noa_index: %d\\n\",\n\t\tavp->offchannel_duration,\n\t\tavp->offchannel_start,\n\t\tavp->noa_index);\n\n\t \n\tif (ctx->active && avp->noa_duration)\n\t\tavp->noa_duration = 0;\n}\n\nstatic void ath_chanctx_set_periodic_noa(struct ath_softc *sc,\n\t\t\t\t\t struct ath_vif *avp,\n\t\t\t\t\t struct ath_beacon_config *cur_conf,\n\t\t\t\t\t u32 tsf_time,\n\t\t\t\t\t u32 beacon_int)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\n\tavp->noa_index++;\n\tavp->noa_start = tsf_time;\n\n\tif (sc->sched.extend_absence)\n\t\tavp->noa_duration = (3 * beacon_int / 2) +\n\t\t\tsc->sched.channel_switch_time;\n\telse\n\t\tavp->noa_duration =\n\t\t\tTU_TO_USEC(cur_conf->beacon_interval) / 2 +\n\t\t\tsc->sched.channel_switch_time;\n\n\tif (test_bit(ATH_OP_SCANNING, &common->op_flags) ||\n\t    sc->sched.extend_absence)\n\t\tavp->periodic_noa = false;\n\telse\n\t\tavp->periodic_noa = true;\n\n\tath_dbg(common, CHAN_CTX,\n\t\t\"noa_duration: %d, noa_start: %u, noa_index: %d, periodic: %d\\n\",\n\t\tavp->noa_duration,\n\t\tavp->noa_start,\n\t\tavp->noa_index,\n\t\tavp->periodic_noa);\n}\n\nstatic void ath_chanctx_set_oneshot_noa(struct ath_softc *sc,\n\t\t\t\t\tstruct ath_vif *avp,\n\t\t\t\t\tu32 tsf_time,\n\t\t\t\t\tu32 duration)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\n\tavp->noa_index++;\n\tavp->noa_start = tsf_time;\n\tavp->periodic_noa = false;\n\tavp->oneshot_noa = true;\n\tavp->noa_duration = duration + sc->sched.channel_switch_time;\n\n\tath_dbg(common, CHAN_CTX,\n\t\t\"oneshot noa_duration: %d, noa_start: %u, noa_index: %d, periodic: %d\\n\",\n\t\tavp->noa_duration,\n\t\tavp->noa_start,\n\t\tavp->noa_index,\n\t\tavp->periodic_noa);\n}\n\nvoid ath_chanctx_event(struct ath_softc *sc, struct ieee80211_vif *vif,\n\t\t       enum ath_chanctx_event ev)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath_beacon_config *cur_conf;\n\tstruct ath_vif *avp = NULL;\n\tstruct ath_chanctx *ctx;\n\tu32 tsf_time;\n\tu32 beacon_int;\n\n\tif (vif)\n\t\tavp = (struct ath_vif *) vif->drv_priv;\n\n\tspin_lock_bh(&sc->chan_lock);\n\n\tath_dbg(common, CHAN_CTX, \"cur_chan: %d MHz, event: %s, state: %s, delta: %u ms\\n\",\n\t\tsc->cur_chan->chandef.center_freq1,\n\t\tchanctx_event_string(ev),\n\t\tchanctx_state_string(sc->sched.state),\n\t\tchanctx_event_delta(sc));\n\n\tswitch (ev) {\n\tcase ATH_CHANCTX_EVENT_BEACON_PREPARE:\n\t\tif (avp->offchannel_duration)\n\t\t\tavp->offchannel_duration = 0;\n\n\t\tif (avp->oneshot_noa) {\n\t\t\tavp->noa_duration = 0;\n\t\t\tavp->oneshot_noa = false;\n\n\t\t\tath_dbg(common, CHAN_CTX,\n\t\t\t\t\"Clearing oneshot NoA\\n\");\n\t\t}\n\n\t\tif (avp->chanctx != sc->cur_chan) {\n\t\t\tath_dbg(common, CHAN_CTX,\n\t\t\t\t\"Contexts differ, not preparing beacon\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sc->sched.offchannel_pending && !sc->sched.wait_switch) {\n\t\t\tsc->sched.offchannel_pending = false;\n\t\t\tsc->next_chan = &sc->offchannel.chan;\n\t\t\tsc->sched.state = ATH_CHANCTX_STATE_WAIT_FOR_BEACON;\n\t\t\tath_dbg(common, CHAN_CTX,\n\t\t\t\t\"Setting offchannel_pending to false\\n\");\n\t\t}\n\n\t\tctx = ath_chanctx_get_next(sc, sc->cur_chan);\n\t\tif (ctx->active && sc->sched.state == ATH_CHANCTX_STATE_IDLE) {\n\t\t\tsc->next_chan = ctx;\n\t\t\tsc->sched.state = ATH_CHANCTX_STATE_WAIT_FOR_BEACON;\n\t\t\tath_dbg(common, CHAN_CTX,\n\t\t\t\t\"Set next context, move chanctx state to WAIT_FOR_BEACON\\n\");\n\t\t}\n\n\t\t \n\t\tif (sc->sched.state == ATH_CHANCTX_STATE_WAIT_FOR_TIMER) {\n\t\t\tsc->sched.state = ATH_CHANCTX_STATE_WAIT_FOR_BEACON;\n\t\t\tath_dbg(common, CHAN_CTX,\n\t\t\t\t\"Move chanctx state from WAIT_FOR_TIMER to WAIT_FOR_BEACON\\n\");\n\t\t}\n\n\t\tif (sc->sched.mgd_prepare_tx)\n\t\t\tsc->sched.state = ATH_CHANCTX_STATE_WAIT_FOR_BEACON;\n\n\t\t \n\t\tif (!ctx->active && avp->noa_duration &&\n\t\t    sc->sched.state != ATH_CHANCTX_STATE_WAIT_FOR_BEACON) {\n\t\t\tavp->noa_duration = 0;\n\t\t\tavp->periodic_noa = false;\n\n\t\t\tath_dbg(common, CHAN_CTX,\n\t\t\t\t\"Clearing NoA schedule\\n\");\n\t\t}\n\n\t\tif (sc->sched.state != ATH_CHANCTX_STATE_WAIT_FOR_BEACON)\n\t\t\tbreak;\n\n\t\tath_dbg(common, CHAN_CTX, \"Preparing beacon for vif: %pM\\n\", vif->addr);\n\n\t\tsc->sched.beacon_pending = true;\n\t\tsc->sched.next_tbtt = REG_READ(ah, AR_NEXT_TBTT_TIMER);\n\n\t\tcur_conf = &sc->cur_chan->beacon;\n\t\tbeacon_int = TU_TO_USEC(cur_conf->beacon_interval);\n\n\t\t \n\t\ttsf_time = sc->sched.next_tbtt + beacon_int / 4;\n\t\tsc->sched.switch_start_time = tsf_time;\n\t\tsc->cur_chan->last_beacon = sc->sched.next_tbtt;\n\n\t\t \n\t\tif (sc->next_chan == &sc->offchannel.chan) {\n\t\t\tath_chanctx_offchannel_noa(sc, ctx, avp, tsf_time);\n\t\t\tbreak;\n\t\t}\n\n\t\tath_chanctx_handle_bmiss(sc, ctx, avp);\n\n\t\t \n\t\tif (sc->sched.mgd_prepare_tx) {\n\t\t\tath_chanctx_set_oneshot_noa(sc, avp, tsf_time,\n\t\t\t\t\t\t    jiffies_to_usecs(HZ / 5));\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (avp->noa_duration && tsf_time - avp->noa_start > BIT(30))\n\t\t\tavp->noa_duration = 0;\n\n\t\t \n\t\tif (ctx->active &&\n\t\t    (!avp->noa_duration || sc->sched.force_noa_update))\n\t\t\tath_chanctx_set_periodic_noa(sc, avp, cur_conf,\n\t\t\t\t\t\t     tsf_time, beacon_int);\n\n\t\tif (ctx->active && sc->sched.force_noa_update)\n\t\t\tsc->sched.force_noa_update = false;\n\n\t\tbreak;\n\tcase ATH_CHANCTX_EVENT_BEACON_SENT:\n\t\tif (!sc->sched.beacon_pending) {\n\t\t\tath_dbg(common, CHAN_CTX,\n\t\t\t\t\"No pending beacon\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tsc->sched.beacon_pending = false;\n\n\t\tif (sc->sched.mgd_prepare_tx) {\n\t\t\tsc->sched.mgd_prepare_tx = false;\n\t\t\tcomplete(&sc->go_beacon);\n\t\t\tath_dbg(common, CHAN_CTX,\n\t\t\t\t\"Beacon sent, complete go_beacon\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sc->sched.state != ATH_CHANCTX_STATE_WAIT_FOR_BEACON)\n\t\t\tbreak;\n\n\t\tath_dbg(common, CHAN_CTX,\n\t\t\t\"Move chanctx state to WAIT_FOR_TIMER\\n\");\n\n\t\tsc->sched.state = ATH_CHANCTX_STATE_WAIT_FOR_TIMER;\n\t\tath_chanctx_setup_timer(sc, sc->sched.switch_start_time);\n\t\tbreak;\n\tcase ATH_CHANCTX_EVENT_TSF_TIMER:\n\t\tif (sc->sched.state != ATH_CHANCTX_STATE_WAIT_FOR_TIMER)\n\t\t\tbreak;\n\n\t\tif (!sc->cur_chan->switch_after_beacon &&\n\t\t    sc->sched.beacon_pending)\n\t\t\tsc->sched.beacon_miss++;\n\n\t\tath_dbg(common, CHAN_CTX,\n\t\t\t\"Move chanctx state to SWITCH\\n\");\n\n\t\tsc->sched.state = ATH_CHANCTX_STATE_SWITCH;\n\t\tieee80211_queue_work(sc->hw, &sc->chanctx_work);\n\t\tbreak;\n\tcase ATH_CHANCTX_EVENT_BEACON_RECEIVED:\n\t\tif (!test_bit(ATH_OP_MULTI_CHANNEL, &common->op_flags) ||\n\t\t    sc->cur_chan == &sc->offchannel.chan)\n\t\t\tbreak;\n\n\t\tsc->sched.beacon_pending = false;\n\t\tsc->sched.beacon_miss = 0;\n\n\t\tif (sc->sched.state == ATH_CHANCTX_STATE_FORCE_ACTIVE ||\n\t\t    !sc->sched.beacon_adjust ||\n\t\t    !sc->cur_chan->tsf_val)\n\t\t\tbreak;\n\n\t\tath_chanctx_adjust_tbtt_delta(sc);\n\n\t\t \n\t\ttsf_time = sc->sched.switch_start_time;\n\t\ttsf_time -= (u32) sc->cur_chan->tsf_val +\n\t\t\tath9k_hw_get_tsf_offset(&sc->cur_chan->tsf_ts, NULL);\n\t\ttsf_time += ath9k_hw_gettsf32(ah);\n\n\t\tsc->sched.beacon_adjust = false;\n\t\tath_chanctx_setup_timer(sc, tsf_time);\n\t\tbreak;\n\tcase ATH_CHANCTX_EVENT_AUTHORIZED:\n\t\tif (sc->sched.state != ATH_CHANCTX_STATE_FORCE_ACTIVE ||\n\t\t    avp->chanctx != sc->cur_chan)\n\t\t\tbreak;\n\n\t\tath_dbg(common, CHAN_CTX,\n\t\t\t\"Move chanctx state from FORCE_ACTIVE to IDLE\\n\");\n\n\t\tsc->sched.state = ATH_CHANCTX_STATE_IDLE;\n\t\tfallthrough;\n\tcase ATH_CHANCTX_EVENT_SWITCH:\n\t\tif (!test_bit(ATH_OP_MULTI_CHANNEL, &common->op_flags) ||\n\t\t    sc->sched.state == ATH_CHANCTX_STATE_FORCE_ACTIVE ||\n\t\t    sc->cur_chan->switch_after_beacon ||\n\t\t    sc->cur_chan == &sc->offchannel.chan)\n\t\t\tbreak;\n\n\t\t \n\t\tsc->next_chan = ath_chanctx_get_next(sc, sc->cur_chan);\n\t\tcur_conf = &sc->cur_chan->beacon;\n\n\t\tath_dbg(common, CHAN_CTX,\n\t\t\t\"Move chanctx state to WAIT_FOR_TIMER (event SWITCH)\\n\");\n\n\t\tsc->sched.state = ATH_CHANCTX_STATE_WAIT_FOR_TIMER;\n\t\tsc->sched.wait_switch = false;\n\n\t\ttsf_time = TU_TO_USEC(cur_conf->beacon_interval) / 2;\n\n\t\tif (sc->sched.extend_absence) {\n\t\t\tsc->sched.beacon_miss = 0;\n\t\t\ttsf_time *= 3;\n\t\t}\n\n\t\ttsf_time -= sc->sched.channel_switch_time;\n\t\ttsf_time += ath9k_hw_gettsf32(sc->sc_ah);\n\t\tsc->sched.switch_start_time = tsf_time;\n\n\t\tath_chanctx_setup_timer(sc, tsf_time);\n\t\tsc->sched.beacon_pending = true;\n\t\tsc->sched.beacon_adjust = true;\n\t\tbreak;\n\tcase ATH_CHANCTX_EVENT_ENABLE_MULTICHANNEL:\n\t\tif (sc->cur_chan == &sc->offchannel.chan ||\n\t\t    sc->cur_chan->switch_after_beacon)\n\t\t\tbreak;\n\n\t\tsc->next_chan = ath_chanctx_get_next(sc, sc->cur_chan);\n\t\tieee80211_queue_work(sc->hw, &sc->chanctx_work);\n\t\tbreak;\n\tcase ATH_CHANCTX_EVENT_UNASSIGN:\n\t\tif (sc->cur_chan->assigned) {\n\t\t\tif (sc->next_chan && !sc->next_chan->assigned &&\n\t\t\t    sc->next_chan != &sc->offchannel.chan)\n\t\t\t\tsc->sched.state = ATH_CHANCTX_STATE_IDLE;\n\t\t\tbreak;\n\t\t}\n\n\t\tctx = ath_chanctx_get_next(sc, sc->cur_chan);\n\t\tsc->sched.state = ATH_CHANCTX_STATE_IDLE;\n\t\tif (!ctx->assigned)\n\t\t\tbreak;\n\n\t\tsc->next_chan = ctx;\n\t\tieee80211_queue_work(sc->hw, &sc->chanctx_work);\n\t\tbreak;\n\tcase ATH_CHANCTX_EVENT_ASSIGN:\n\t\tbreak;\n\tcase ATH_CHANCTX_EVENT_CHANGE:\n\t\tbreak;\n\t}\n\n\tspin_unlock_bh(&sc->chan_lock);\n}\n\nvoid ath_chanctx_beacon_sent_ev(struct ath_softc *sc,\n\t\t\t\tenum ath_chanctx_event ev)\n{\n\tif (sc->sched.beacon_pending)\n\t\tath_chanctx_event(sc, NULL, ev);\n}\n\nvoid ath_chanctx_beacon_recv_ev(struct ath_softc *sc,\n\t\t\t\tenum ath_chanctx_event ev)\n{\n\tath_chanctx_event(sc, NULL, ev);\n}\n\nstatic int ath_scan_channel_duration(struct ath_softc *sc,\n\t\t\t\t     struct ieee80211_channel *chan)\n{\n\tstruct cfg80211_scan_request *req = sc->offchannel.scan_req;\n\n\tif (!req->n_ssids || (chan->flags & IEEE80211_CHAN_NO_IR))\n\t\treturn (HZ / 9);  \n\n\treturn (HZ / 16);  \n}\n\nstatic void ath_chanctx_switch(struct ath_softc *sc, struct ath_chanctx *ctx,\n\t\t\t       struct cfg80211_chan_def *chandef)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\n\tspin_lock_bh(&sc->chan_lock);\n\n\tif (test_bit(ATH_OP_MULTI_CHANNEL, &common->op_flags) &&\n\t    (sc->cur_chan != ctx) && (ctx == &sc->offchannel.chan)) {\n\t\tif (chandef)\n\t\t\tctx->chandef = *chandef;\n\n\t\tsc->sched.offchannel_pending = true;\n\t\tsc->sched.wait_switch = true;\n\t\tsc->sched.offchannel_duration =\n\t\t\tjiffies_to_usecs(sc->offchannel.duration) +\n\t\t\tsc->sched.channel_switch_time;\n\n\t\tspin_unlock_bh(&sc->chan_lock);\n\t\tath_dbg(common, CHAN_CTX,\n\t\t\t\"Set offchannel_pending to true\\n\");\n\t\treturn;\n\t}\n\n\tsc->next_chan = ctx;\n\tif (chandef) {\n\t\tctx->chandef = *chandef;\n\t\tath_dbg(common, CHAN_CTX,\n\t\t\t\"Assigned next_chan to %d MHz\\n\", chandef->center_freq1);\n\t}\n\n\tif (sc->next_chan == &sc->offchannel.chan) {\n\t\tsc->sched.offchannel_duration =\n\t\t\tjiffies_to_usecs(sc->offchannel.duration) +\n\t\t\tsc->sched.channel_switch_time;\n\n\t\tif (chandef) {\n\t\t\tath_dbg(common, CHAN_CTX,\n\t\t\t\t\"Offchannel duration for chan %d MHz : %u\\n\",\n\t\t\t\tchandef->center_freq1,\n\t\t\t\tsc->sched.offchannel_duration);\n\t\t}\n\t}\n\tspin_unlock_bh(&sc->chan_lock);\n\tieee80211_queue_work(sc->hw, &sc->chanctx_work);\n}\n\nstatic void ath_chanctx_offchan_switch(struct ath_softc *sc,\n\t\t\t\t       struct ieee80211_channel *chan)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct cfg80211_chan_def chandef;\n\n\tcfg80211_chandef_create(&chandef, chan, NL80211_CHAN_NO_HT);\n\tath_dbg(common, CHAN_CTX,\n\t\t\"Channel definition created: %d MHz\\n\", chandef.center_freq1);\n\n\tath_chanctx_switch(sc, &sc->offchannel.chan, &chandef);\n}\n\nstatic struct ath_chanctx *ath_chanctx_get_oper_chan(struct ath_softc *sc,\n\t\t\t\t\t\t     bool active)\n{\n\tstruct ath_chanctx *ctx;\n\n\tath_for_each_chanctx(sc, ctx) {\n\t\tif (!ctx->assigned || list_empty(&ctx->vifs))\n\t\t\tcontinue;\n\t\tif (active && !ctx->active)\n\t\t\tcontinue;\n\n\t\tif (ctx->switch_after_beacon)\n\t\t\treturn ctx;\n\t}\n\n\treturn &sc->chanctx[0];\n}\n\nstatic void\nath_scan_next_channel(struct ath_softc *sc)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct cfg80211_scan_request *req = sc->offchannel.scan_req;\n\tstruct ieee80211_channel *chan;\n\n\tif (sc->offchannel.scan_idx >= req->n_channels) {\n\t\tath_dbg(common, CHAN_CTX,\n\t\t\t\"Moving offchannel state to ATH_OFFCHANNEL_IDLE, \"\n\t\t\t\"scan_idx: %d, n_channels: %d\\n\",\n\t\t\tsc->offchannel.scan_idx,\n\t\t\treq->n_channels);\n\n\t\tsc->offchannel.state = ATH_OFFCHANNEL_IDLE;\n\t\tath_chanctx_switch(sc, ath_chanctx_get_oper_chan(sc, false),\n\t\t\t\t   NULL);\n\t\treturn;\n\t}\n\n\tath_dbg(common, CHAN_CTX,\n\t\t\"Moving offchannel state to ATH_OFFCHANNEL_PROBE_SEND, scan_idx: %d\\n\",\n\t\tsc->offchannel.scan_idx);\n\n\tchan = req->channels[sc->offchannel.scan_idx++];\n\tsc->offchannel.duration = ath_scan_channel_duration(sc, chan);\n\tsc->offchannel.state = ATH_OFFCHANNEL_PROBE_SEND;\n\n\tath_chanctx_offchan_switch(sc, chan);\n}\n\nvoid ath_offchannel_next(struct ath_softc *sc)\n{\n\tstruct ieee80211_vif *vif;\n\n\tif (sc->offchannel.scan_req) {\n\t\tvif = sc->offchannel.scan_vif;\n\t\tsc->offchannel.chan.txpower = vif->bss_conf.txpower;\n\t\tath_scan_next_channel(sc);\n\t} else if (sc->offchannel.roc_vif) {\n\t\tvif = sc->offchannel.roc_vif;\n\t\tsc->offchannel.chan.txpower = vif->bss_conf.txpower;\n\t\tsc->offchannel.duration =\n\t\t\tmsecs_to_jiffies(sc->offchannel.roc_duration);\n\t\tsc->offchannel.state = ATH_OFFCHANNEL_ROC_START;\n\t\tath_chanctx_offchan_switch(sc, sc->offchannel.roc_chan);\n\t} else {\n\t\tspin_lock_bh(&sc->chan_lock);\n\t\tsc->sched.offchannel_pending = false;\n\t\tsc->sched.wait_switch = false;\n\t\tspin_unlock_bh(&sc->chan_lock);\n\n\t\tath_chanctx_switch(sc, ath_chanctx_get_oper_chan(sc, false),\n\t\t\t\t   NULL);\n\t\tsc->offchannel.state = ATH_OFFCHANNEL_IDLE;\n\t\tif (sc->ps_idle)\n\t\t\tath_cancel_work(sc);\n\t}\n}\n\nvoid ath_roc_complete(struct ath_softc *sc, enum ath_roc_complete_reason reason)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\n\tsc->offchannel.roc_vif = NULL;\n\tsc->offchannel.roc_chan = NULL;\n\n\tswitch (reason) {\n\tcase ATH_ROC_COMPLETE_ABORT:\n\t\tath_dbg(common, CHAN_CTX, \"RoC aborted\\n\");\n\t\tieee80211_remain_on_channel_expired(sc->hw);\n\t\tbreak;\n\tcase ATH_ROC_COMPLETE_EXPIRE:\n\t\tath_dbg(common, CHAN_CTX, \"RoC expired\\n\");\n\t\tieee80211_remain_on_channel_expired(sc->hw);\n\t\tbreak;\n\tcase ATH_ROC_COMPLETE_CANCEL:\n\t\tath_dbg(common, CHAN_CTX, \"RoC canceled\\n\");\n\t\tbreak;\n\t}\n\n\tath_offchannel_next(sc);\n\tath9k_ps_restore(sc);\n}\n\nvoid ath_scan_complete(struct ath_softc *sc, bool abort)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct cfg80211_scan_info info = {\n\t\t.aborted = abort,\n\t};\n\n\tif (abort)\n\t\tath_dbg(common, CHAN_CTX, \"HW scan aborted\\n\");\n\telse\n\t\tath_dbg(common, CHAN_CTX, \"HW scan complete\\n\");\n\n\tsc->offchannel.scan_req = NULL;\n\tsc->offchannel.scan_vif = NULL;\n\tsc->offchannel.state = ATH_OFFCHANNEL_IDLE;\n\tieee80211_scan_completed(sc->hw, &info);\n\tclear_bit(ATH_OP_SCANNING, &common->op_flags);\n\tspin_lock_bh(&sc->chan_lock);\n\tif (test_bit(ATH_OP_MULTI_CHANNEL, &common->op_flags))\n\t\tsc->sched.force_noa_update = true;\n\tspin_unlock_bh(&sc->chan_lock);\n\tath_offchannel_next(sc);\n\tath9k_ps_restore(sc);\n}\n\nstatic void ath_scan_send_probe(struct ath_softc *sc,\n\t\t\t\tstruct cfg80211_ssid *ssid)\n{\n\tstruct cfg80211_scan_request *req = sc->offchannel.scan_req;\n\tstruct ieee80211_vif *vif = sc->offchannel.scan_vif;\n\tstruct ath_tx_control txctl = {};\n\tstruct sk_buff *skb;\n\tstruct ieee80211_tx_info *info;\n\tint band = sc->offchannel.chan.chandef.chan->band;\n\n\tskb = ieee80211_probereq_get(sc->hw, vif->addr,\n\t\t\tssid->ssid, ssid->ssid_len, req->ie_len);\n\tif (!skb)\n\t\treturn;\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\tif (req->no_cck)\n\t\tinfo->flags |= IEEE80211_TX_CTL_NO_CCK_RATE;\n\n\tif (req->ie_len)\n\t\tskb_put_data(skb, req->ie, req->ie_len);\n\n\tskb_set_queue_mapping(skb, IEEE80211_AC_VO);\n\n\tif (!ieee80211_tx_prepare_skb(sc->hw, vif, skb, band, NULL))\n\t\tgoto error;\n\n\ttxctl.txq = sc->tx.txq_map[IEEE80211_AC_VO];\n\tif (ath_tx_start(sc->hw, skb, &txctl))\n\t\tgoto error;\n\n\treturn;\n\nerror:\n\tieee80211_free_txskb(sc->hw, skb);\n}\n\nstatic void ath_scan_channel_start(struct ath_softc *sc)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct cfg80211_scan_request *req = sc->offchannel.scan_req;\n\tint i;\n\n\tif (!(sc->cur_chan->chandef.chan->flags & IEEE80211_CHAN_NO_IR) &&\n\t    req->n_ssids) {\n\t\tfor (i = 0; i < req->n_ssids; i++)\n\t\t\tath_scan_send_probe(sc, &req->ssids[i]);\n\n\t}\n\n\tath_dbg(common, CHAN_CTX,\n\t\t\"Moving offchannel state to ATH_OFFCHANNEL_PROBE_WAIT\\n\");\n\n\tsc->offchannel.state = ATH_OFFCHANNEL_PROBE_WAIT;\n\tmod_timer(&sc->offchannel.timer, jiffies + sc->offchannel.duration);\n}\n\nstatic void ath_chanctx_timer(struct timer_list *t)\n{\n\tstruct ath_softc *sc = from_timer(sc, t, sched.timer);\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\n\tath_dbg(common, CHAN_CTX,\n\t\t\"Channel context timer invoked\\n\");\n\n\tath_chanctx_event(sc, NULL, ATH_CHANCTX_EVENT_TSF_TIMER);\n}\n\nstatic void ath_offchannel_timer(struct timer_list *t)\n{\n\tstruct ath_softc *sc = from_timer(sc, t, offchannel.timer);\n\tstruct ath_chanctx *ctx;\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\n\tath_dbg(common, CHAN_CTX, \"%s: offchannel state: %s\\n\",\n\t\t__func__, offchannel_state_string(sc->offchannel.state));\n\n\tswitch (sc->offchannel.state) {\n\tcase ATH_OFFCHANNEL_PROBE_WAIT:\n\t\tif (!sc->offchannel.scan_req)\n\t\t\treturn;\n\n\t\t \n\t\tctx = ath_chanctx_get_oper_chan(sc, true);\n\t\tif (ctx->active) {\n\t\t\tath_dbg(common, CHAN_CTX,\n\t\t\t\t\"Switch to oper/active context, \"\n\t\t\t\t\"move offchannel state to ATH_OFFCHANNEL_SUSPEND\\n\");\n\n\t\t\tsc->offchannel.state = ATH_OFFCHANNEL_SUSPEND;\n\t\t\tath_chanctx_switch(sc, ctx, NULL);\n\t\t\tmod_timer(&sc->offchannel.timer, jiffies + HZ / 10);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tcase ATH_OFFCHANNEL_SUSPEND:\n\t\tif (!sc->offchannel.scan_req)\n\t\t\treturn;\n\n\t\tath_scan_next_channel(sc);\n\t\tbreak;\n\tcase ATH_OFFCHANNEL_ROC_START:\n\tcase ATH_OFFCHANNEL_ROC_WAIT:\n\t\tsc->offchannel.state = ATH_OFFCHANNEL_ROC_DONE;\n\t\tath_roc_complete(sc, ATH_ROC_COMPLETE_EXPIRE);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic bool\nath_chanctx_send_vif_ps_frame(struct ath_softc *sc, struct ath_vif *avp,\n\t\t\t      bool powersave)\n{\n\tstruct ieee80211_vif *vif = avp->vif;\n\tstruct ieee80211_sta *sta = NULL;\n\tstruct ieee80211_hdr_3addr *nullfunc;\n\tstruct ath_tx_control txctl;\n\tstruct sk_buff *skb;\n\tint band = sc->cur_chan->chandef.chan->band;\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (!avp->assoc)\n\t\t\treturn false;\n\n\t\tskb = ieee80211_nullfunc_get(sc->hw, vif, -1, false);\n\t\tif (!skb)\n\t\t\treturn false;\n\n\t\tnullfunc = (struct ieee80211_hdr_3addr *) skb->data;\n\t\tif (powersave)\n\t\t\tnullfunc->frame_control |=\n\t\t\t\tcpu_to_le16(IEEE80211_FCTL_PM);\n\n\t\tskb->priority = 7;\n\t\tskb_set_queue_mapping(skb, IEEE80211_AC_VO);\n\t\tif (!ieee80211_tx_prepare_skb(sc->hw, vif, skb, band, &sta)) {\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\tmemset(&txctl, 0, sizeof(txctl));\n\ttxctl.txq = sc->tx.txq_map[IEEE80211_AC_VO];\n\ttxctl.sta = sta;\n\tif (ath_tx_start(sc->hw, skb, &txctl)) {\n\t\tieee80211_free_txskb(sc->hw, skb);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool\nath_chanctx_send_ps_frame(struct ath_softc *sc, bool powersave)\n{\n\tstruct ath_vif *avp;\n\tbool sent = false;\n\n\trcu_read_lock();\n\tlist_for_each_entry(avp, &sc->cur_chan->vifs, list) {\n\t\tif (ath_chanctx_send_vif_ps_frame(sc, avp, powersave))\n\t\t\tsent = true;\n\t}\n\trcu_read_unlock();\n\n\treturn sent;\n}\n\nstatic bool ath_chanctx_defer_switch(struct ath_softc *sc)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\n\tif (sc->cur_chan == &sc->offchannel.chan)\n\t\treturn false;\n\n\tswitch (sc->sched.state) {\n\tcase ATH_CHANCTX_STATE_SWITCH:\n\t\treturn false;\n\tcase ATH_CHANCTX_STATE_IDLE:\n\t\tif (!sc->cur_chan->switch_after_beacon)\n\t\t\treturn false;\n\n\t\tath_dbg(common, CHAN_CTX,\n\t\t\t\"Defer switch, set chanctx state to WAIT_FOR_BEACON\\n\");\n\n\t\tsc->sched.state = ATH_CHANCTX_STATE_WAIT_FOR_BEACON;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn true;\n}\n\nstatic void ath_offchannel_channel_change(struct ath_softc *sc)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\n\tath_dbg(common, CHAN_CTX, \"%s: offchannel state: %s\\n\",\n\t\t__func__, offchannel_state_string(sc->offchannel.state));\n\n\tswitch (sc->offchannel.state) {\n\tcase ATH_OFFCHANNEL_PROBE_SEND:\n\t\tif (!sc->offchannel.scan_req)\n\t\t\treturn;\n\n\t\tif (sc->cur_chan->chandef.chan !=\n\t\t    sc->offchannel.chan.chandef.chan)\n\t\t\treturn;\n\n\t\tath_scan_channel_start(sc);\n\t\tbreak;\n\tcase ATH_OFFCHANNEL_IDLE:\n\t\tif (!sc->offchannel.scan_req)\n\t\t\treturn;\n\n\t\tath_scan_complete(sc, false);\n\t\tbreak;\n\tcase ATH_OFFCHANNEL_ROC_START:\n\t\tif (sc->cur_chan != &sc->offchannel.chan)\n\t\t\tbreak;\n\n\t\tsc->offchannel.state = ATH_OFFCHANNEL_ROC_WAIT;\n\t\tmod_timer(&sc->offchannel.timer,\n\t\t\t  jiffies + sc->offchannel.duration);\n\t\tieee80211_ready_on_channel(sc->hw);\n\t\tbreak;\n\tcase ATH_OFFCHANNEL_ROC_DONE:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid ath_chanctx_set_next(struct ath_softc *sc, bool force)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ath_chanctx *old_ctx;\n\tstruct timespec64 ts;\n\tbool measure_time = false;\n\tbool send_ps = false;\n\tbool queues_stopped = false;\n\n\tspin_lock_bh(&sc->chan_lock);\n\tif (!sc->next_chan) {\n\t\tspin_unlock_bh(&sc->chan_lock);\n\t\treturn;\n\t}\n\n\tif (!force && ath_chanctx_defer_switch(sc)) {\n\t\tspin_unlock_bh(&sc->chan_lock);\n\t\treturn;\n\t}\n\n\tath_dbg(common, CHAN_CTX,\n\t\t\"%s: current: %d MHz, next: %d MHz\\n\",\n\t\t__func__,\n\t\tsc->cur_chan->chandef.center_freq1,\n\t\tsc->next_chan->chandef.center_freq1);\n\n\tif (sc->cur_chan != sc->next_chan) {\n\t\tath_dbg(common, CHAN_CTX,\n\t\t\t\"Stopping current chanctx: %d\\n\",\n\t\t\tsc->cur_chan->chandef.center_freq1);\n\t\tsc->cur_chan->stopped = true;\n\t\tspin_unlock_bh(&sc->chan_lock);\n\n\t\tif (sc->next_chan == &sc->offchannel.chan) {\n\t\t\tktime_get_raw_ts64(&ts);\n\t\t\tmeasure_time = true;\n\t\t}\n\n\t\tath9k_chanctx_stop_queues(sc, sc->cur_chan);\n\t\tqueues_stopped = true;\n\n\t\t__ath9k_flush(sc->hw, ~0, true, false, false);\n\n\t\tif (ath_chanctx_send_ps_frame(sc, true))\n\t\t\t__ath9k_flush(sc->hw, BIT(IEEE80211_AC_VO),\n\t\t\t\t      false, false, false);\n\n\t\tsend_ps = true;\n\t\tspin_lock_bh(&sc->chan_lock);\n\n\t\tif (sc->cur_chan != &sc->offchannel.chan) {\n\t\t\tktime_get_raw_ts64(&sc->cur_chan->tsf_ts);\n\t\t\tsc->cur_chan->tsf_val = ath9k_hw_gettsf64(sc->sc_ah);\n\t\t}\n\t}\n\told_ctx = sc->cur_chan;\n\tsc->cur_chan = sc->next_chan;\n\tsc->cur_chan->stopped = false;\n\tsc->next_chan = NULL;\n\n\tif (!sc->sched.offchannel_pending)\n\t\tsc->sched.offchannel_duration = 0;\n\n\tif (sc->sched.state != ATH_CHANCTX_STATE_FORCE_ACTIVE)\n\t\tsc->sched.state = ATH_CHANCTX_STATE_IDLE;\n\n\tspin_unlock_bh(&sc->chan_lock);\n\n\tif (sc->sc_ah->chip_fullsleep ||\n\t    memcmp(&sc->cur_chandef, &sc->cur_chan->chandef,\n\t\t   sizeof(sc->cur_chandef))) {\n\t\tath_dbg(common, CHAN_CTX,\n\t\t\t\"%s: Set channel %d MHz\\n\",\n\t\t\t__func__, sc->cur_chan->chandef.center_freq1);\n\t\tath_set_channel(sc);\n\t\tif (measure_time)\n\t\t\tsc->sched.channel_switch_time =\n\t\t\t\tath9k_hw_get_tsf_offset(&ts, NULL);\n\t\t \n\t\tgoto out;\n\t}\n\n\tif (queues_stopped)\n\t\tath9k_chanctx_wake_queues(sc, old_ctx);\nout:\n\tif (send_ps)\n\t\tath_chanctx_send_ps_frame(sc, false);\n\n\tath_offchannel_channel_change(sc);\n\tath_chanctx_event(sc, NULL, ATH_CHANCTX_EVENT_SWITCH);\n}\n\nstatic void ath_chanctx_work(struct work_struct *work)\n{\n\tstruct ath_softc *sc = container_of(work, struct ath_softc,\n\t\t\t\t\t    chanctx_work);\n\tmutex_lock(&sc->mutex);\n\tath_chanctx_set_next(sc, false);\n\tmutex_unlock(&sc->mutex);\n}\n\nvoid ath9k_offchannel_init(struct ath_softc *sc)\n{\n\tstruct ath_chanctx *ctx;\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_channel *chan;\n\tint i;\n\n\tsband = &common->sbands[NL80211_BAND_2GHZ];\n\tif (!sband->n_channels)\n\t\tsband = &common->sbands[NL80211_BAND_5GHZ];\n\n\tchan = &sband->channels[0];\n\n\tctx = &sc->offchannel.chan;\n\tINIT_LIST_HEAD(&ctx->vifs);\n\tctx->txpower = ATH_TXPOWER_MAX;\n\tcfg80211_chandef_create(&ctx->chandef, chan, NL80211_CHAN_HT20);\n\n\tfor (i = 0; i < ARRAY_SIZE(ctx->acq); i++) {\n\t\tINIT_LIST_HEAD(&ctx->acq[i].acq_new);\n\t\tINIT_LIST_HEAD(&ctx->acq[i].acq_old);\n\t\tspin_lock_init(&ctx->acq[i].lock);\n\t}\n\n\tsc->offchannel.chan.offchannel = true;\n}\n\nvoid ath9k_init_channel_context(struct ath_softc *sc)\n{\n\tINIT_WORK(&sc->chanctx_work, ath_chanctx_work);\n\n\ttimer_setup(&sc->offchannel.timer, ath_offchannel_timer, 0);\n\ttimer_setup(&sc->sched.timer, ath_chanctx_timer, 0);\n\n\tinit_completion(&sc->go_beacon);\n}\n\nvoid ath9k_deinit_channel_context(struct ath_softc *sc)\n{\n\tcancel_work_sync(&sc->chanctx_work);\n}\n\nbool ath9k_is_chanctx_enabled(void)\n{\n\treturn (ath9k_use_chanctx == 1);\n}\n\n \n \n \n\nvoid ath9k_chanctx_stop_queues(struct ath_softc *sc, struct ath_chanctx *ctx)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tint i;\n\n\tif (ctx == &sc->offchannel.chan) {\n\t\tieee80211_stop_queue(sc->hw,\n\t\t\t\t     sc->hw->offchannel_tx_hw_queue);\n\t} else {\n\t\tfor (i = 0; i < IEEE80211_NUM_ACS; i++)\n\t\t\tieee80211_stop_queue(sc->hw,\n\t\t\t\t\t     ctx->hw_queue_base + i);\n\t}\n\n\tif (ah->opmode == NL80211_IFTYPE_AP)\n\t\tieee80211_stop_queue(sc->hw, sc->hw->queues - 2);\n}\n\n\nvoid ath9k_chanctx_wake_queues(struct ath_softc *sc, struct ath_chanctx *ctx)\n{\n\tstruct ath_hw *ah = sc->sc_ah;\n\tint i;\n\n\tif (ctx == &sc->offchannel.chan) {\n\t\tieee80211_wake_queue(sc->hw,\n\t\t\t\t     sc->hw->offchannel_tx_hw_queue);\n\t} else {\n\t\tfor (i = 0; i < IEEE80211_NUM_ACS; i++)\n\t\t\tieee80211_wake_queue(sc->hw,\n\t\t\t\t\t     ctx->hw_queue_base + i);\n\t}\n\n\tif (ah->opmode == NL80211_IFTYPE_AP)\n\t\tieee80211_wake_queue(sc->hw, sc->hw->queues - 2);\n}\n\n \n \n \n\nstatic void ath9k_update_p2p_ps_timer(struct ath_softc *sc, struct ath_vif *avp)\n{\n\tstruct ath_common *common = ath9k_hw_common(sc->sc_ah);\n\tstruct ath_hw *ah = sc->sc_ah;\n\tu32 tsf, target_tsf;\n\n\tif (!avp || !avp->noa.has_next_tsf)\n\t\treturn;\n\n\tath9k_hw_gen_timer_stop(ah, sc->p2p_ps_timer);\n\n\ttsf = ath9k_hw_gettsf32(sc->sc_ah);\n\n\ttarget_tsf = avp->noa.next_tsf;\n\tif (!avp->noa.absent)\n\t\ttarget_tsf -= ATH_P2P_PS_STOP_TIME;\n\telse\n\t\ttarget_tsf += ATH_P2P_PS_STOP_TIME;\n\n\tif (target_tsf - tsf < ATH_P2P_PS_STOP_TIME)\n\t\ttarget_tsf = tsf + ATH_P2P_PS_STOP_TIME;\n\n\tath_dbg(common, CHAN_CTX, \"%s absent %d tsf 0x%08X next_tsf 0x%08X (%dms)\\n\",\n\t\t__func__, avp->noa.absent, tsf, target_tsf,\n\t\t(target_tsf - tsf) / 1000);\n\n\tath9k_hw_gen_timer_start(ah, sc->p2p_ps_timer, target_tsf, 1000000);\n}\n\nstatic void ath9k_update_p2p_ps(struct ath_softc *sc, struct ieee80211_vif *vif)\n{\n\tstruct ath_vif *avp = (void *)vif->drv_priv;\n\tu32 tsf;\n\n\tif (!sc->p2p_ps_timer)\n\t\treturn;\n\n\tif (vif->type != NL80211_IFTYPE_STATION)\n\t\treturn;\n\n\tsc->p2p_ps_vif = avp;\n\n\tif (sc->ps_flags & PS_BEACON_SYNC)\n\t\treturn;\n\n\ttsf = ath9k_hw_gettsf32(sc->sc_ah);\n\tieee80211_parse_p2p_noa(&vif->bss_conf.p2p_noa_attr, &avp->noa, tsf);\n\tath9k_update_p2p_ps_timer(sc, avp);\n}\n\nstatic u8 ath9k_get_ctwin(struct ath_softc *sc, struct ath_vif *avp)\n{\n\tstruct ath_beacon_config *cur_conf = &sc->cur_chan->beacon;\n\tu8 switch_time, ctwin;\n\n\t \n\tswitch_time = cur_conf->beacon_interval / 4;\n\n\tctwin = avp->vif->bss_conf.p2p_noa_attr.oppps_ctwindow;\n\tif (ctwin && (ctwin < switch_time))\n\t\treturn ctwin;\n\n\tif (switch_time < P2P_DEFAULT_CTWIN)\n\t\treturn 0;\n\n\treturn P2P_DEFAULT_CTWIN;\n}\n\nvoid ath9k_beacon_add_noa(struct ath_softc *sc, struct ath_vif *avp,\n\t\t\t  struct sk_buff *skb)\n{\n\tstatic const u8 noa_ie_hdr[] = {\n\t\tWLAN_EID_VENDOR_SPECIFIC,\t \n\t\t0,\t\t\t\t \n\t\t0x50, 0x6f, 0x9a,\t\t \n\t\t0x09,\t\t\t\t \n\t\t0x0c,\t\t\t\t \n\t\t0x00,\t\t\t\t \n\t\t0x00,\t\t\t\t \n\t};\n\n\tstruct ieee80211_p2p_noa_attr *noa;\n\tint noa_len, noa_desc, i = 0;\n\tu8 *hdr;\n\n\tif (!avp->offchannel_duration && !avp->noa_duration)\n\t\treturn;\n\n\tnoa_desc = !!avp->offchannel_duration + !!avp->noa_duration;\n\tnoa_len = 2 + sizeof(struct ieee80211_p2p_noa_desc) * noa_desc;\n\n\thdr = skb_put_data(skb, noa_ie_hdr, sizeof(noa_ie_hdr));\n\thdr[1] = sizeof(noa_ie_hdr) + noa_len - 2;\n\thdr[7] = noa_len;\n\n\tnoa = skb_put_zero(skb, noa_len);\n\n\tnoa->index = avp->noa_index;\n\tnoa->oppps_ctwindow = ath9k_get_ctwin(sc, avp);\n\tif (noa->oppps_ctwindow)\n\t\tnoa->oppps_ctwindow |= BIT(7);\n\n\tif (avp->noa_duration) {\n\t\tif (avp->periodic_noa) {\n\t\t\tu32 interval = TU_TO_USEC(sc->cur_chan->beacon.beacon_interval);\n\t\t\tnoa->desc[i].count = 255;\n\t\t\tnoa->desc[i].interval = cpu_to_le32(interval);\n\t\t} else {\n\t\t\tnoa->desc[i].count = 1;\n\t\t}\n\n\t\tnoa->desc[i].start_time = cpu_to_le32(avp->noa_start);\n\t\tnoa->desc[i].duration = cpu_to_le32(avp->noa_duration);\n\t\ti++;\n\t}\n\n\tif (avp->offchannel_duration) {\n\t\tnoa->desc[i].count = 1;\n\t\tnoa->desc[i].start_time = cpu_to_le32(avp->offchannel_start);\n\t\tnoa->desc[i].duration = cpu_to_le32(avp->offchannel_duration);\n\t}\n}\n\nvoid ath9k_p2p_ps_timer(void *priv)\n{\n\tstruct ath_softc *sc = priv;\n\tstruct ath_vif *avp = sc->p2p_ps_vif;\n\tstruct ieee80211_vif *vif;\n\tstruct ieee80211_sta *sta;\n\tstruct ath_node *an;\n\tu32 tsf;\n\n\tdel_timer_sync(&sc->sched.timer);\n\tath9k_hw_gen_timer_stop(sc->sc_ah, sc->p2p_ps_timer);\n\tath_chanctx_event(sc, NULL, ATH_CHANCTX_EVENT_TSF_TIMER);\n\n\tif (!avp || avp->chanctx != sc->cur_chan)\n\t\treturn;\n\n\ttsf = ath9k_hw_gettsf32(sc->sc_ah);\n\tif (!avp->noa.absent)\n\t\ttsf += ATH_P2P_PS_STOP_TIME;\n\telse\n\t\ttsf -= ATH_P2P_PS_STOP_TIME;\n\n\tif (!avp->noa.has_next_tsf ||\n\t    avp->noa.next_tsf - tsf > BIT(31))\n\t\tieee80211_update_p2p_noa(&avp->noa, tsf);\n\n\tath9k_update_p2p_ps_timer(sc, avp);\n\n\trcu_read_lock();\n\n\tvif = avp->vif;\n\tsta = ieee80211_find_sta(vif, avp->bssid);\n\tif (!sta)\n\t\tgoto out;\n\n\tan = (void *) sta->drv_priv;\n\tif (an->sleeping == !!avp->noa.absent)\n\t\tgoto out;\n\n\tan->sleeping = avp->noa.absent;\n\tif (an->sleeping)\n\t\tath_tx_aggr_sleep(sta, sc, an);\n\telse\n\t\tath_tx_aggr_wakeup(sc, an);\n\nout:\n\trcu_read_unlock();\n}\n\nvoid ath9k_p2p_bss_info_changed(struct ath_softc *sc,\n\t\t\t\tstruct ieee80211_vif *vif)\n{\n\tunsigned long flags;\n\n\tspin_lock_bh(&sc->sc_pcu_lock);\n\tspin_lock_irqsave(&sc->sc_pm_lock, flags);\n\tath9k_update_p2p_ps(sc, vif);\n\tspin_unlock_irqrestore(&sc->sc_pm_lock, flags);\n\tspin_unlock_bh(&sc->sc_pcu_lock);\n}\n\nvoid ath9k_p2p_beacon_sync(struct ath_softc *sc)\n{\n\tif (sc->p2p_ps_vif)\n\t\tath9k_update_p2p_ps(sc, sc->p2p_ps_vif->vif);\n}\n\nvoid ath9k_p2p_remove_vif(struct ath_softc *sc,\n\t\t\t  struct ieee80211_vif *vif)\n{\n\tstruct ath_vif *avp = (void *)vif->drv_priv;\n\n\tspin_lock_bh(&sc->sc_pcu_lock);\n\tif (avp == sc->p2p_ps_vif) {\n\t\tsc->p2p_ps_vif = NULL;\n\t\tath9k_update_p2p_ps_timer(sc, NULL);\n\t}\n\tspin_unlock_bh(&sc->sc_pcu_lock);\n}\n\nint ath9k_init_p2p(struct ath_softc *sc)\n{\n\tsc->p2p_ps_timer = ath_gen_timer_alloc(sc->sc_ah, ath9k_p2p_ps_timer,\n\t\t\t\t\t       NULL, sc, AR_FIRST_NDP_TIMER);\n\tif (!sc->p2p_ps_timer)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nvoid ath9k_deinit_p2p(struct ath_softc *sc)\n{\n\tif (sc->p2p_ps_timer)\n\t\tath_gen_timer_free(sc->sc_ah, sc->p2p_ps_timer);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}