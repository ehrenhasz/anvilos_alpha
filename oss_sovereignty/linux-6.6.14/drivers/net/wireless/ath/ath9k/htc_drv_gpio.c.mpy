{
  "module_name": "htc_drv_gpio.c",
  "hash_id": "75ad20a10a40a6a22fd03c78b1a753239f08dbbe91902e6b13132af54aff31a7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath9k/htc_drv_gpio.c",
  "human_readable_source": " \n\n#include \"htc.h\"\n\n \n \n \n\n#define ATH_HTC_BTCOEX_PRODUCT_ID \"wb193\"\n\n#ifdef CONFIG_ATH9K_BTCOEX_SUPPORT\n\n \nstatic void ath_detect_bt_priority(struct ath9k_htc_priv *priv)\n{\n\tstruct ath_btcoex *btcoex = &priv->btcoex;\n\tstruct ath_hw *ah = priv->ah;\n\n\tif (ath9k_hw_gpio_get(ah, ah->btcoex_hw.btpriority_gpio))\n\t\tbtcoex->bt_priority_cnt++;\n\n\tif (time_after(jiffies, btcoex->bt_priority_time +\n\t\t\tmsecs_to_jiffies(ATH_BT_PRIORITY_TIME_THRESHOLD))) {\n\t\tclear_bit(OP_BT_PRIORITY_DETECTED, &priv->op_flags);\n\t\tclear_bit(OP_BT_SCAN, &priv->op_flags);\n\t\t \n\t\tif (btcoex->bt_priority_cnt >= ATH_BT_CNT_SCAN_THRESHOLD) {\n\t\t\tath_dbg(ath9k_hw_common(ah), BTCOEX,\n\t\t\t\t\"BT scan detected\\n\");\n\t\t\tset_bit(OP_BT_PRIORITY_DETECTED, &priv->op_flags);\n\t\t\tset_bit(OP_BT_SCAN, &priv->op_flags);\n\t\t} else if (btcoex->bt_priority_cnt >= ATH_BT_CNT_THRESHOLD) {\n\t\t\tath_dbg(ath9k_hw_common(ah), BTCOEX,\n\t\t\t\t\"BT priority traffic detected\\n\");\n\t\t\tset_bit(OP_BT_PRIORITY_DETECTED, &priv->op_flags);\n\t\t}\n\n\t\tbtcoex->bt_priority_cnt = 0;\n\t\tbtcoex->bt_priority_time = jiffies;\n\t}\n}\n\n \nstatic void ath_btcoex_period_work(struct work_struct *work)\n{\n\tstruct ath9k_htc_priv *priv = container_of(work, struct ath9k_htc_priv,\n\t\t\t\t\t\t   coex_period_work.work);\n\tstruct ath_btcoex *btcoex = &priv->btcoex;\n\tstruct ath_common *common = ath9k_hw_common(priv->ah);\n\tu32 timer_period;\n\tint ret;\n\n\tath_detect_bt_priority(priv);\n\n\tret = ath9k_htc_update_cap_target(priv,\n\t\t\t  test_bit(OP_BT_PRIORITY_DETECTED, &priv->op_flags));\n\tif (ret) {\n\t\tath_err(common, \"Unable to set BTCOEX parameters\\n\");\n\t\treturn;\n\t}\n\n\tath9k_hw_btcoex_bt_stomp(priv->ah, test_bit(OP_BT_SCAN, &priv->op_flags) ?\n\t\t\t\t ATH_BTCOEX_STOMP_ALL : btcoex->bt_stomp_type);\n\n\tath9k_hw_btcoex_enable(priv->ah);\n\ttimer_period = test_bit(OP_BT_SCAN, &priv->op_flags) ?\n\t\tbtcoex->btscan_no_stomp : btcoex->btcoex_no_stomp;\n\tieee80211_queue_delayed_work(priv->hw, &priv->duty_cycle_work,\n\t\t\t\t     msecs_to_jiffies(timer_period));\n\tieee80211_queue_delayed_work(priv->hw, &priv->coex_period_work,\n\t\t\t\t     msecs_to_jiffies(btcoex->btcoex_period));\n}\n\n \nstatic void ath_btcoex_duty_cycle_work(struct work_struct *work)\n{\n\tstruct ath9k_htc_priv *priv = container_of(work, struct ath9k_htc_priv,\n\t\t\t\t\t\t   duty_cycle_work.work);\n\tstruct ath_hw *ah = priv->ah;\n\tstruct ath_btcoex *btcoex = &priv->btcoex;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\n\tath_dbg(common, BTCOEX, \"time slice work for bt and wlan\\n\");\n\n\tif (btcoex->bt_stomp_type == ATH_BTCOEX_STOMP_LOW ||\n\t    test_bit(OP_BT_SCAN, &priv->op_flags))\n\t\tath9k_hw_btcoex_bt_stomp(ah, ATH_BTCOEX_STOMP_NONE);\n\telse if (btcoex->bt_stomp_type == ATH_BTCOEX_STOMP_ALL)\n\t\tath9k_hw_btcoex_bt_stomp(ah, ATH_BTCOEX_STOMP_LOW);\n\n\tath9k_hw_btcoex_enable(priv->ah);\n}\n\nstatic void ath_htc_init_btcoex_work(struct ath9k_htc_priv *priv)\n{\n\tstruct ath_btcoex *btcoex = &priv->btcoex;\n\n\tbtcoex->btcoex_period = ATH_BTCOEX_DEF_BT_PERIOD;\n\tbtcoex->btcoex_no_stomp = (100 - ATH_BTCOEX_DEF_DUTY_CYCLE) *\n\t\tbtcoex->btcoex_period / 100;\n\tbtcoex->btscan_no_stomp = (100 - ATH_BTCOEX_BTSCAN_DUTY_CYCLE) *\n\t\t\t\t   btcoex->btcoex_period / 100;\n\tINIT_DELAYED_WORK(&priv->coex_period_work, ath_btcoex_period_work);\n\tINIT_DELAYED_WORK(&priv->duty_cycle_work, ath_btcoex_duty_cycle_work);\n}\n\n \n\nstatic void ath_htc_resume_btcoex_work(struct ath9k_htc_priv *priv)\n{\n\tstruct ath_btcoex *btcoex = &priv->btcoex;\n\tstruct ath_hw *ah = priv->ah;\n\n\tath_dbg(ath9k_hw_common(ah), BTCOEX, \"Starting btcoex work\\n\");\n\n\tbtcoex->bt_priority_cnt = 0;\n\tbtcoex->bt_priority_time = jiffies;\n\tclear_bit(OP_BT_PRIORITY_DETECTED, &priv->op_flags);\n\tclear_bit(OP_BT_SCAN, &priv->op_flags);\n\tieee80211_queue_delayed_work(priv->hw, &priv->coex_period_work, 0);\n}\n\n\n \nstatic void ath_htc_cancel_btcoex_work(struct ath9k_htc_priv *priv)\n{\n\tcancel_delayed_work_sync(&priv->coex_period_work);\n\tcancel_delayed_work_sync(&priv->duty_cycle_work);\n}\n\nvoid ath9k_htc_start_btcoex(struct ath9k_htc_priv *priv)\n{\n\tstruct ath_hw *ah = priv->ah;\n\n\tif (ath9k_hw_get_btcoex_scheme(ah) == ATH_BTCOEX_CFG_3WIRE) {\n\t\tath9k_hw_btcoex_set_weight(ah, AR_BT_COEX_WGHT,\n\t\t\t\t\t   AR_STOMP_LOW_WLAN_WGHT, 0);\n\t\tath9k_hw_btcoex_enable(ah);\n\t\tath_htc_resume_btcoex_work(priv);\n\t}\n}\n\nvoid ath9k_htc_stop_btcoex(struct ath9k_htc_priv *priv)\n{\n\tstruct ath_hw *ah = priv->ah;\n\n\tif (ah->btcoex_hw.enabled &&\n\t    ath9k_hw_get_btcoex_scheme(ah) != ATH_BTCOEX_CFG_NONE) {\n\t\tif (ah->btcoex_hw.scheme == ATH_BTCOEX_CFG_3WIRE)\n\t\t\tath_htc_cancel_btcoex_work(priv);\n\t\tath9k_hw_btcoex_disable(ah);\n\t}\n}\n\nvoid ath9k_htc_init_btcoex(struct ath9k_htc_priv *priv, char *product)\n{\n\tstruct ath_hw *ah = priv->ah;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tint qnum;\n\n\t \n\tif (!common->btcoex_enabled) {\n\t\tah->btcoex_hw.scheme = ATH_BTCOEX_CFG_NONE;\n\t\treturn;\n\t}\n\n\tif (product && strncmp(product, ATH_HTC_BTCOEX_PRODUCT_ID, 5) == 0) {\n\t\tah->btcoex_hw.scheme = ATH_BTCOEX_CFG_3WIRE;\n\t}\n\n\tswitch (ath9k_hw_get_btcoex_scheme(priv->ah)) {\n\tcase ATH_BTCOEX_CFG_NONE:\n\t\tbreak;\n\tcase ATH_BTCOEX_CFG_3WIRE:\n\t\tpriv->ah->btcoex_hw.btactive_gpio = 7;\n\t\tpriv->ah->btcoex_hw.btpriority_gpio = 6;\n\t\tpriv->ah->btcoex_hw.wlanactive_gpio = 8;\n\t\tpriv->btcoex.bt_stomp_type = ATH_BTCOEX_STOMP_LOW;\n\t\tath9k_hw_btcoex_init_3wire(priv->ah);\n\t\tath_htc_init_btcoex_work(priv);\n\t\tqnum = priv->hwq_map[IEEE80211_AC_BE];\n\t\tath9k_hw_init_btcoex_hw(priv->ah, qnum);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n}\n\n#endif  \n\n \n \n \n\n#ifdef CONFIG_MAC80211_LEDS\nvoid ath9k_led_work(struct work_struct *work)\n{\n\tstruct ath9k_htc_priv *priv = container_of(work,\n\t\t\t\t\t\t   struct ath9k_htc_priv,\n\t\t\t\t\t\t   led_work);\n\n\tath9k_hw_set_gpio(priv->ah, priv->ah->led_pin,\n\t\t\t  (priv->brightness == LED_OFF));\n}\n\nstatic void ath9k_led_brightness(struct led_classdev *led_cdev,\n\t\t\t\t enum led_brightness brightness)\n{\n\tstruct ath9k_htc_priv *priv = container_of(led_cdev,\n\t\t\t\t\t\t   struct ath9k_htc_priv,\n\t\t\t\t\t\t   led_cdev);\n\n\t \n\tpriv->brightness = brightness;\n\tieee80211_queue_work(priv->hw, &priv->led_work);\n}\n\nvoid ath9k_deinit_leds(struct ath9k_htc_priv *priv)\n{\n\tif (!priv->led_registered)\n\t\treturn;\n\n\tath9k_led_brightness(&priv->led_cdev, LED_OFF);\n\tled_classdev_unregister(&priv->led_cdev);\n\tcancel_work_sync(&priv->led_work);\n\n\tath9k_hw_gpio_free(priv->ah, priv->ah->led_pin);\n}\n\n\nvoid ath9k_configure_leds(struct ath9k_htc_priv *priv)\n{\n\t \n\tath9k_hw_gpio_request_out(priv->ah, priv->ah->led_pin,\n\t\t\t\t  \"ath9k-led\",\n\t\t\t\t  AR_GPIO_OUTPUT_MUX_AS_OUTPUT);\n\t \n\tath9k_hw_set_gpio(priv->ah, priv->ah->led_pin, 1);\n}\n\nvoid ath9k_init_leds(struct ath9k_htc_priv *priv)\n{\n\tint ret;\n\n\tif (AR_SREV_9287(priv->ah))\n\t\tpriv->ah->led_pin = ATH_LED_PIN_9287;\n\telse if (AR_SREV_9271(priv->ah))\n\t\tpriv->ah->led_pin = ATH_LED_PIN_9271;\n\telse if (AR_DEVID_7010(priv->ah))\n\t\tpriv->ah->led_pin = ATH_LED_PIN_7010;\n\telse\n\t\tpriv->ah->led_pin = ATH_LED_PIN_DEF;\n\n\tif (!ath9k_htc_led_blink)\n\t\tpriv->led_cdev.default_trigger =\n\t\t\tieee80211_get_radio_led_name(priv->hw);\n\n\tath9k_configure_leds(priv);\n\n\tsnprintf(priv->led_name, sizeof(priv->led_name),\n\t\t\"ath9k_htc-%s\", wiphy_name(priv->hw->wiphy));\n\tpriv->led_cdev.name = priv->led_name;\n\tpriv->led_cdev.brightness_set = ath9k_led_brightness;\n\n\tret = led_classdev_register(wiphy_dev(priv->hw->wiphy), &priv->led_cdev);\n\tif (ret < 0)\n\t\treturn;\n\n\tINIT_WORK(&priv->led_work, ath9k_led_work);\n\tpriv->led_registered = true;\n\n\treturn;\n}\n#endif\n\n \n \n \n\nstatic bool ath_is_rfkill_set(struct ath9k_htc_priv *priv)\n{\n\tbool is_blocked;\n\n\tath9k_htc_ps_wakeup(priv);\n\tis_blocked = ath9k_hw_gpio_get(priv->ah, priv->ah->rfkill_gpio) ==\n\t\t\t\t\t\t priv->ah->rfkill_polarity;\n\tath9k_htc_ps_restore(priv);\n\n\treturn is_blocked;\n}\n\nvoid ath9k_htc_rfkill_poll_state(struct ieee80211_hw *hw)\n{\n\tstruct ath9k_htc_priv *priv = hw->priv;\n\tbool blocked = !!ath_is_rfkill_set(priv);\n\n\twiphy_rfkill_set_hw_state(hw->wiphy, blocked);\n}\n\nvoid ath9k_start_rfkill_poll(struct ath9k_htc_priv *priv)\n{\n\tif (priv->ah->caps.hw_caps & ATH9K_HW_CAP_RFSILENT)\n\t\twiphy_rfkill_start_polling(priv->hw->wiphy);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}