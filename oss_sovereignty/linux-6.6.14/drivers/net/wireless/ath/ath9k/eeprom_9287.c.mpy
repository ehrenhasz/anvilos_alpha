{
  "module_name": "eeprom_9287.c",
  "hash_id": "b4e6adfe63a71298849cd8eabe9395f87962c2ddc65bbb80bc7d337ab2cf0413",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath9k/eeprom_9287.c",
  "human_readable_source": " \n\n#include <asm/unaligned.h>\n#include \"hw.h\"\n#include \"ar9002_phy.h\"\n\n#define SIZE_EEPROM_AR9287 (sizeof(struct ar9287_eeprom) / sizeof(u16))\n\nstatic int ath9k_hw_ar9287_get_eeprom_ver(struct ath_hw *ah)\n{\n\tu16 version = le16_to_cpu(ah->eeprom.map9287.baseEepHeader.version);\n\n\treturn (version & AR5416_EEP_VER_MAJOR_MASK) >>\n\t\tAR5416_EEP_VER_MAJOR_SHIFT;\n}\n\nstatic int ath9k_hw_ar9287_get_eeprom_rev(struct ath_hw *ah)\n{\n\tu16 version = le16_to_cpu(ah->eeprom.map9287.baseEepHeader.version);\n\n\treturn version & AR5416_EEP_VER_MINOR_MASK;\n}\n\nstatic bool __ath9k_hw_ar9287_fill_eeprom(struct ath_hw *ah)\n{\n\tstruct ar9287_eeprom *eep = &ah->eeprom.map9287;\n\tu16 *eep_data;\n\tint addr, eep_start_loc = AR9287_EEP_START_LOC;\n\teep_data = (u16 *)eep;\n\n\tfor (addr = 0; addr < SIZE_EEPROM_AR9287; addr++) {\n\t\tif (!ath9k_hw_nvram_read(ah, addr + eep_start_loc, eep_data))\n\t\t\treturn false;\n\t\teep_data++;\n\t}\n\n\treturn true;\n}\n\nstatic bool __ath9k_hw_usb_ar9287_fill_eeprom(struct ath_hw *ah)\n{\n\tu16 *eep_data = (u16 *)&ah->eeprom.map9287;\n\n\tath9k_hw_usb_gen_fill_eeprom(ah, eep_data,\n\t\t\t\t     AR9287_HTC_EEP_START_LOC,\n\t\t\t\t     SIZE_EEPROM_AR9287);\n\treturn true;\n}\n\nstatic bool ath9k_hw_ar9287_fill_eeprom(struct ath_hw *ah)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\n\tif (!ath9k_hw_use_flash(ah)) {\n\t\tath_dbg(common, EEPROM, \"Reading from EEPROM, not flash\\n\");\n\t}\n\n\tif (common->bus_ops->ath_bus_type == ATH_USB)\n\t\treturn __ath9k_hw_usb_ar9287_fill_eeprom(ah);\n\telse\n\t\treturn __ath9k_hw_ar9287_fill_eeprom(ah);\n}\n\n#ifdef CONFIG_ATH9K_COMMON_DEBUG\nstatic u32 ar9287_dump_modal_eeprom(char *buf, u32 len, u32 size,\n\t\t\t\t    struct modal_eep_ar9287_header *modal_hdr)\n{\n\tPR_EEP(\"Chain0 Ant. Control\", le16_to_cpu(modal_hdr->antCtrlChain[0]));\n\tPR_EEP(\"Chain1 Ant. Control\", le16_to_cpu(modal_hdr->antCtrlChain[1]));\n\tPR_EEP(\"Ant. Common Control\", le32_to_cpu(modal_hdr->antCtrlCommon));\n\tPR_EEP(\"Chain0 Ant. Gain\", modal_hdr->antennaGainCh[0]);\n\tPR_EEP(\"Chain1 Ant. Gain\", modal_hdr->antennaGainCh[1]);\n\tPR_EEP(\"Switch Settle\", modal_hdr->switchSettling);\n\tPR_EEP(\"Chain0 TxRxAtten\", modal_hdr->txRxAttenCh[0]);\n\tPR_EEP(\"Chain1 TxRxAtten\", modal_hdr->txRxAttenCh[1]);\n\tPR_EEP(\"Chain0 RxTxMargin\", modal_hdr->rxTxMarginCh[0]);\n\tPR_EEP(\"Chain1 RxTxMargin\", modal_hdr->rxTxMarginCh[1]);\n\tPR_EEP(\"ADC Desired size\", modal_hdr->adcDesiredSize);\n\tPR_EEP(\"txEndToXpaOff\", modal_hdr->txEndToXpaOff);\n\tPR_EEP(\"txEndToRxOn\", modal_hdr->txEndToRxOn);\n\tPR_EEP(\"txFrameToXpaOn\", modal_hdr->txFrameToXpaOn);\n\tPR_EEP(\"CCA Threshold)\", modal_hdr->thresh62);\n\tPR_EEP(\"Chain0 NF Threshold\", modal_hdr->noiseFloorThreshCh[0]);\n\tPR_EEP(\"Chain1 NF Threshold\", modal_hdr->noiseFloorThreshCh[1]);\n\tPR_EEP(\"xpdGain\", modal_hdr->xpdGain);\n\tPR_EEP(\"External PD\", modal_hdr->xpd);\n\tPR_EEP(\"Chain0 I Coefficient\", modal_hdr->iqCalICh[0]);\n\tPR_EEP(\"Chain1 I Coefficient\", modal_hdr->iqCalICh[1]);\n\tPR_EEP(\"Chain0 Q Coefficient\", modal_hdr->iqCalQCh[0]);\n\tPR_EEP(\"Chain1 Q Coefficient\", modal_hdr->iqCalQCh[1]);\n\tPR_EEP(\"pdGainOverlap\", modal_hdr->pdGainOverlap);\n\tPR_EEP(\"xPA Bias Level\", modal_hdr->xpaBiasLvl);\n\tPR_EEP(\"txFrameToDataStart\", modal_hdr->txFrameToDataStart);\n\tPR_EEP(\"txFrameToPaOn\", modal_hdr->txFrameToPaOn);\n\tPR_EEP(\"HT40 Power Inc.\", modal_hdr->ht40PowerIncForPdadc);\n\tPR_EEP(\"Chain0 bswAtten\", modal_hdr->bswAtten[0]);\n\tPR_EEP(\"Chain1 bswAtten\", modal_hdr->bswAtten[1]);\n\tPR_EEP(\"Chain0 bswMargin\", modal_hdr->bswMargin[0]);\n\tPR_EEP(\"Chain1 bswMargin\", modal_hdr->bswMargin[1]);\n\tPR_EEP(\"HT40 Switch Settle\", modal_hdr->swSettleHt40);\n\tPR_EEP(\"AR92x7 Version\", modal_hdr->version);\n\tPR_EEP(\"DriverBias1\", modal_hdr->db1);\n\tPR_EEP(\"DriverBias2\", modal_hdr->db1);\n\tPR_EEP(\"CCK OutputBias\", modal_hdr->ob_cck);\n\tPR_EEP(\"PSK OutputBias\", modal_hdr->ob_psk);\n\tPR_EEP(\"QAM OutputBias\", modal_hdr->ob_qam);\n\tPR_EEP(\"PAL_OFF OutputBias\", modal_hdr->ob_pal_off);\n\n\treturn len;\n}\n\nstatic u32 ath9k_hw_ar9287_dump_eeprom(struct ath_hw *ah, bool dump_base_hdr,\n\t\t\t\t       u8 *buf, u32 len, u32 size)\n{\n\tstruct ar9287_eeprom *eep = &ah->eeprom.map9287;\n\tstruct base_eep_ar9287_header *pBase = &eep->baseEepHeader;\n\tu32 binBuildNumber = le32_to_cpu(pBase->binBuildNumber);\n\n\tif (!dump_base_hdr) {\n\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t \"%20s :\\n\", \"2GHz modal Header\");\n\t\tlen = ar9287_dump_modal_eeprom(buf, len, size,\n\t\t\t\t\t\t&eep->modalHeader);\n\t\tgoto out;\n\t}\n\n\tPR_EEP(\"Major Version\", ath9k_hw_ar9287_get_eeprom_ver(ah));\n\tPR_EEP(\"Minor Version\", ath9k_hw_ar9287_get_eeprom_rev(ah));\n\tPR_EEP(\"Checksum\", le16_to_cpu(pBase->checksum));\n\tPR_EEP(\"Length\", le16_to_cpu(pBase->length));\n\tPR_EEP(\"RegDomain1\", le16_to_cpu(pBase->regDmn[0]));\n\tPR_EEP(\"RegDomain2\", le16_to_cpu(pBase->regDmn[1]));\n\tPR_EEP(\"TX Mask\", pBase->txMask);\n\tPR_EEP(\"RX Mask\", pBase->rxMask);\n\tPR_EEP(\"Allow 5GHz\", !!(pBase->opCapFlags & AR5416_OPFLAGS_11A));\n\tPR_EEP(\"Allow 2GHz\", !!(pBase->opCapFlags & AR5416_OPFLAGS_11G));\n\tPR_EEP(\"Disable 2GHz HT20\", !!(pBase->opCapFlags &\n\t\t\t\t\tAR5416_OPFLAGS_N_2G_HT20));\n\tPR_EEP(\"Disable 2GHz HT40\", !!(pBase->opCapFlags &\n\t\t\t\t\tAR5416_OPFLAGS_N_2G_HT40));\n\tPR_EEP(\"Disable 5Ghz HT20\", !!(pBase->opCapFlags &\n\t\t\t\t\tAR5416_OPFLAGS_N_5G_HT20));\n\tPR_EEP(\"Disable 5Ghz HT40\", !!(pBase->opCapFlags &\n\t\t\t\t\tAR5416_OPFLAGS_N_5G_HT40));\n\tPR_EEP(\"Big Endian\", !!(pBase->eepMisc & AR5416_EEPMISC_BIG_ENDIAN));\n\tPR_EEP(\"Cal Bin Major Ver\", (binBuildNumber >> 24) & 0xFF);\n\tPR_EEP(\"Cal Bin Minor Ver\", (binBuildNumber >> 16) & 0xFF);\n\tPR_EEP(\"Cal Bin Build\", (binBuildNumber >> 8) & 0xFF);\n\tPR_EEP(\"Power Table Offset\", pBase->pwrTableOffset);\n\tPR_EEP(\"OpenLoop Power Ctrl\", pBase->openLoopPwrCntl);\n\n\tlen += scnprintf(buf + len, size - len, \"%20s : %pM\\n\", \"MacAddress\",\n\t\t\t pBase->macAddr);\n\nout:\n\tif (len > size)\n\t\tlen = size;\n\n\treturn len;\n}\n#else\nstatic u32 ath9k_hw_ar9287_dump_eeprom(struct ath_hw *ah, bool dump_base_hdr,\n\t\t\t\t       u8 *buf, u32 len, u32 size)\n{\n\treturn 0;\n}\n#endif\n\n\nstatic int ath9k_hw_ar9287_check_eeprom(struct ath_hw *ah)\n{\n\tu32 el;\n\tint i, err;\n\tbool need_swap;\n\tstruct ar9287_eeprom *eep = &ah->eeprom.map9287;\n\n\terr = ath9k_hw_nvram_swap_data(ah, &need_swap, SIZE_EEPROM_AR9287);\n\tif (err)\n\t\treturn err;\n\n\tif (need_swap)\n\t\tel = swab16((__force u16)eep->baseEepHeader.length);\n\telse\n\t\tel = le16_to_cpu(eep->baseEepHeader.length);\n\n\tel = min(el / sizeof(u16), SIZE_EEPROM_AR9287);\n\tif (!ath9k_hw_nvram_validate_checksum(ah, el))\n\t\treturn -EINVAL;\n\n\tif (need_swap) {\n\t\tEEPROM_FIELD_SWAB16(eep->baseEepHeader.length);\n\t\tEEPROM_FIELD_SWAB16(eep->baseEepHeader.checksum);\n\t\tEEPROM_FIELD_SWAB16(eep->baseEepHeader.version);\n\t\tEEPROM_FIELD_SWAB16(eep->baseEepHeader.regDmn[0]);\n\t\tEEPROM_FIELD_SWAB16(eep->baseEepHeader.regDmn[1]);\n\t\tEEPROM_FIELD_SWAB16(eep->baseEepHeader.rfSilent);\n\t\tEEPROM_FIELD_SWAB16(eep->baseEepHeader.blueToothOptions);\n\t\tEEPROM_FIELD_SWAB16(eep->baseEepHeader.deviceCap);\n\t\tEEPROM_FIELD_SWAB32(eep->modalHeader.antCtrlCommon);\n\n\t\tfor (i = 0; i < AR9287_MAX_CHAINS; i++)\n\t\t\tEEPROM_FIELD_SWAB32(eep->modalHeader.antCtrlChain[i]);\n\n\t\tfor (i = 0; i < AR_EEPROM_MODAL_SPURS; i++)\n\t\t\tEEPROM_FIELD_SWAB16(\n\t\t\t\teep->modalHeader.spurChans[i].spurChan);\n\t}\n\n\tif (!ath9k_hw_nvram_check_version(ah, AR9287_EEP_VER,\n\t    AR5416_EEP_NO_BACK_VER))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n#undef SIZE_EEPROM_AR9287\n\nstatic u32 ath9k_hw_ar9287_get_eeprom(struct ath_hw *ah,\n\t\t\t\t      enum eeprom_param param)\n{\n\tstruct ar9287_eeprom *eep = &ah->eeprom.map9287;\n\tstruct modal_eep_ar9287_header *pModal = &eep->modalHeader;\n\tstruct base_eep_ar9287_header *pBase = &eep->baseEepHeader;\n\tu16 ver_minor = ath9k_hw_ar9287_get_eeprom_rev(ah);\n\n\tswitch (param) {\n\tcase EEP_NFTHRESH_2:\n\t\treturn pModal->noiseFloorThreshCh[0];\n\tcase EEP_MAC_LSW:\n\t\treturn get_unaligned_be16(pBase->macAddr);\n\tcase EEP_MAC_MID:\n\t\treturn get_unaligned_be16(pBase->macAddr + 2);\n\tcase EEP_MAC_MSW:\n\t\treturn get_unaligned_be16(pBase->macAddr + 4);\n\tcase EEP_REG_0:\n\t\treturn le16_to_cpu(pBase->regDmn[0]);\n\tcase EEP_OP_CAP:\n\t\treturn le16_to_cpu(pBase->deviceCap);\n\tcase EEP_OP_MODE:\n\t\treturn pBase->opCapFlags;\n\tcase EEP_RF_SILENT:\n\t\treturn le16_to_cpu(pBase->rfSilent);\n\tcase EEP_TX_MASK:\n\t\treturn pBase->txMask;\n\tcase EEP_RX_MASK:\n\t\treturn pBase->rxMask;\n\tcase EEP_DEV_TYPE:\n\t\treturn pBase->deviceType;\n\tcase EEP_OL_PWRCTRL:\n\t\treturn pBase->openLoopPwrCntl;\n\tcase EEP_TEMPSENSE_SLOPE:\n\t\tif (ver_minor >= AR9287_EEP_MINOR_VER_2)\n\t\t\treturn pBase->tempSensSlope;\n\t\telse\n\t\t\treturn 0;\n\tcase EEP_TEMPSENSE_SLOPE_PAL_ON:\n\t\tif (ver_minor >= AR9287_EEP_MINOR_VER_3)\n\t\t\treturn pBase->tempSensSlopePalOn;\n\t\telse\n\t\t\treturn 0;\n\tcase EEP_ANTENNA_GAIN_2G:\n\t\treturn max_t(u8, pModal->antennaGainCh[0],\n\t\t\t\t pModal->antennaGainCh[1]);\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic void ar9287_eeprom_get_tx_gain_index(struct ath_hw *ah,\n\t\t\t    struct ath9k_channel *chan,\n\t\t\t    struct cal_data_op_loop_ar9287 *pRawDatasetOpLoop,\n\t\t\t    u8 *pCalChans,  u16 availPiers, int8_t *pPwr)\n{\n\tu16 idxL = 0, idxR = 0, numPiers;\n\tbool match;\n\tstruct chan_centers centers;\n\n\tath9k_hw_get_channel_centers(ah, chan, &centers);\n\n\tfor (numPiers = 0; numPiers < availPiers; numPiers++) {\n\t\tif (pCalChans[numPiers] == AR5416_BCHAN_UNUSED)\n\t\t\tbreak;\n\t}\n\n\tmatch = ath9k_hw_get_lower_upper_index(\n\t\t(u8)FREQ2FBIN(centers.synth_center, IS_CHAN_2GHZ(chan)),\n\t\tpCalChans, numPiers, &idxL, &idxR);\n\n\tif (match) {\n\t\t*pPwr = (int8_t) pRawDatasetOpLoop[idxL].pwrPdg[0][0];\n\t} else {\n\t\t*pPwr = ((int8_t) pRawDatasetOpLoop[idxL].pwrPdg[0][0] +\n\t\t\t (int8_t) pRawDatasetOpLoop[idxR].pwrPdg[0][0])/2;\n\t}\n\n}\n\nstatic void ar9287_eeprom_olpc_set_pdadcs(struct ath_hw *ah,\n\t\t\t\t\t  int32_t txPower, u16 chain)\n{\n\tu32 tmpVal;\n\tu32 a;\n\n\t \n\n\ttmpVal = REG_READ(ah, 0xa270);\n\ttmpVal = tmpVal & 0xFCFFFFFF;\n\ttmpVal = tmpVal | (0x3 << 24);\n\tREG_WRITE(ah, 0xa270, tmpVal);\n\n\t \n\n\ttmpVal = REG_READ(ah, 0xb270);\n\ttmpVal = tmpVal & 0xFCFFFFFF;\n\ttmpVal = tmpVal | (0x3 << 24);\n\tREG_WRITE(ah, 0xb270, tmpVal);\n\n\t \n\n\tif (chain == 0) {\n\t\ttmpVal = REG_READ(ah, 0xa398);\n\t\ttmpVal = tmpVal & 0xff00ffff;\n\t\ta = (txPower)&0xff;\n\t\ttmpVal = tmpVal | (a << 16);\n\t\tREG_WRITE(ah, 0xa398, tmpVal);\n\t}\n\n\t \n\n\tif (chain == 1) {\n\t\ttmpVal = REG_READ(ah, 0xb398);\n\t\ttmpVal = tmpVal & 0xff00ffff;\n\t\ta = (txPower)&0xff;\n\t\ttmpVal = tmpVal | (a << 16);\n\t\tREG_WRITE(ah, 0xb398, tmpVal);\n\t}\n}\n\nstatic void ath9k_hw_set_ar9287_power_cal_table(struct ath_hw *ah,\n\t\t\t\t\t\tstruct ath9k_channel *chan)\n{\n\tstruct cal_data_per_freq_ar9287 *pRawDataset;\n\tstruct cal_data_op_loop_ar9287 *pRawDatasetOpenLoop;\n\tu8 *pCalBChans = NULL;\n\tu16 pdGainOverlap_t2;\n\tu8 pdadcValues[AR5416_NUM_PDADC_VALUES];\n\tu16 gainBoundaries[AR5416_PD_GAINS_IN_MASK];\n\tu16 numPiers = 0, i, j;\n\tu16 numXpdGain, xpdMask;\n\tu16 xpdGainValues[AR5416_NUM_PD_GAINS] = {0, 0, 0, 0};\n\tu32 reg32, regOffset, regChainOffset, regval;\n\tint16_t diff = 0;\n\tstruct ar9287_eeprom *pEepData = &ah->eeprom.map9287;\n\n\txpdMask = pEepData->modalHeader.xpdGain;\n\n\tif (ath9k_hw_ar9287_get_eeprom_rev(ah) >= AR9287_EEP_MINOR_VER_2)\n\t\tpdGainOverlap_t2 = pEepData->modalHeader.pdGainOverlap;\n\telse\n\t\tpdGainOverlap_t2 = (u16)(MS(REG_READ(ah, AR_PHY_TPCRG5),\n\t\t\t\t\t    AR_PHY_TPCRG5_PD_GAIN_OVERLAP));\n\n\tif (IS_CHAN_2GHZ(chan)) {\n\t\tpCalBChans = pEepData->calFreqPier2G;\n\t\tnumPiers = AR9287_NUM_2G_CAL_PIERS;\n\t\tif (ath9k_hw_ar9287_get_eeprom(ah, EEP_OL_PWRCTRL)) {\n\t\t\tpRawDatasetOpenLoop =\n\t\t\t(struct cal_data_op_loop_ar9287 *)pEepData->calPierData2G[0];\n\t\t\tah->initPDADC = pRawDatasetOpenLoop->vpdPdg[0][0];\n\t\t}\n\t}\n\n\tnumXpdGain = 0;\n\n\t \n\tfor (i = 1; i <= AR5416_PD_GAINS_IN_MASK; i++) {\n\t\tif ((xpdMask >> (AR5416_PD_GAINS_IN_MASK - i)) & 1) {\n\t\t\tif (numXpdGain >= AR5416_NUM_PD_GAINS)\n\t\t\t\tbreak;\n\t\t\txpdGainValues[numXpdGain] =\n\t\t\t\t(u16)(AR5416_PD_GAINS_IN_MASK-i);\n\t\t\tnumXpdGain++;\n\t\t}\n\t}\n\n\tREG_RMW_FIELD(ah, AR_PHY_TPCRG1, AR_PHY_TPCRG1_NUM_PD_GAIN,\n\t\t      (numXpdGain - 1) & 0x3);\n\tREG_RMW_FIELD(ah, AR_PHY_TPCRG1, AR_PHY_TPCRG1_PD_GAIN_1,\n\t\t      xpdGainValues[0]);\n\tREG_RMW_FIELD(ah, AR_PHY_TPCRG1, AR_PHY_TPCRG1_PD_GAIN_2,\n\t\t      xpdGainValues[1]);\n\tREG_RMW_FIELD(ah, AR_PHY_TPCRG1, AR_PHY_TPCRG1_PD_GAIN_3,\n\t\t      xpdGainValues[2]);\n\n\tfor (i = 0; i < AR9287_MAX_CHAINS; i++)\t{\n\t\tregChainOffset = i * 0x1000;\n\n\t\tif (pEepData->baseEepHeader.txMask & (1 << i)) {\n\t\t\tpRawDatasetOpenLoop =\n\t\t\t(struct cal_data_op_loop_ar9287 *)pEepData->calPierData2G[i];\n\n\t\t\tif (ath9k_hw_ar9287_get_eeprom(ah, EEP_OL_PWRCTRL)) {\n\t\t\t\tint8_t txPower;\n\t\t\t\tar9287_eeprom_get_tx_gain_index(ah, chan,\n\t\t\t\t\t\t\tpRawDatasetOpenLoop,\n\t\t\t\t\t\t\tpCalBChans, numPiers,\n\t\t\t\t\t\t\t&txPower);\n\t\t\t\tar9287_eeprom_olpc_set_pdadcs(ah, txPower, i);\n\t\t\t} else {\n\t\t\t\tpRawDataset =\n\t\t\t\t\t(struct cal_data_per_freq_ar9287 *)\n\t\t\t\t\tpEepData->calPierData2G[i];\n\n\t\t\t\tath9k_hw_get_gain_boundaries_pdadcs(ah, chan,\n\t\t\t\t\t\t\t   pRawDataset,\n\t\t\t\t\t\t\t   pCalBChans, numPiers,\n\t\t\t\t\t\t\t   pdGainOverlap_t2,\n\t\t\t\t\t\t\t   gainBoundaries,\n\t\t\t\t\t\t\t   pdadcValues,\n\t\t\t\t\t\t\t   numXpdGain);\n\t\t\t}\n\n\t\t\tENABLE_REGWRITE_BUFFER(ah);\n\n\t\t\tif (i == 0) {\n\t\t\t\tif (!ath9k_hw_ar9287_get_eeprom(ah,\n\t\t\t\t\t\t\tEEP_OL_PWRCTRL)) {\n\n\t\t\t\t\tregval = SM(pdGainOverlap_t2,\n\t\t\t\t\t\t    AR_PHY_TPCRG5_PD_GAIN_OVERLAP)\n\t\t\t\t\t\t| SM(gainBoundaries[0],\n\t\t\t\t\t\t     AR_PHY_TPCRG5_PD_GAIN_BOUNDARY_1)\n\t\t\t\t\t\t| SM(gainBoundaries[1],\n\t\t\t\t\t\t     AR_PHY_TPCRG5_PD_GAIN_BOUNDARY_2)\n\t\t\t\t\t\t| SM(gainBoundaries[2],\n\t\t\t\t\t\t     AR_PHY_TPCRG5_PD_GAIN_BOUNDARY_3)\n\t\t\t\t\t\t| SM(gainBoundaries[3],\n\t\t\t\t\t\t     AR_PHY_TPCRG5_PD_GAIN_BOUNDARY_4);\n\n\t\t\t\t\tREG_WRITE(ah,\n\t\t\t\t\t\t  AR_PHY_TPCRG5 + regChainOffset,\n\t\t\t\t\t\t  regval);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ((int32_t)AR9287_PWR_TABLE_OFFSET_DB !=\n\t\t\t    pEepData->baseEepHeader.pwrTableOffset) {\n\t\t\t\tdiff = (u16)(pEepData->baseEepHeader.pwrTableOffset -\n\t\t\t\t\t     (int32_t)AR9287_PWR_TABLE_OFFSET_DB);\n\t\t\t\tdiff *= 2;\n\n\t\t\t\tfor (j = 0; j < ((u16)AR5416_NUM_PDADC_VALUES-diff); j++)\n\t\t\t\t\tpdadcValues[j] = pdadcValues[j+diff];\n\n\t\t\t\tfor (j = (u16)(AR5416_NUM_PDADC_VALUES-diff);\n\t\t\t\t     j < AR5416_NUM_PDADC_VALUES; j++)\n\t\t\t\t\tpdadcValues[j] =\n\t\t\t\t\t  pdadcValues[AR5416_NUM_PDADC_VALUES-diff];\n\t\t\t}\n\n\t\t\tif (!ath9k_hw_ar9287_get_eeprom(ah, EEP_OL_PWRCTRL)) {\n\t\t\t\tregOffset = AR_PHY_BASE +\n\t\t\t\t\t(672 << 2) + regChainOffset;\n\n\t\t\t\tfor (j = 0; j < 32; j++) {\n\t\t\t\t\treg32 = get_unaligned_le32(&pdadcValues[4 * j]);\n\n\t\t\t\t\tREG_WRITE(ah, regOffset, reg32);\n\t\t\t\t\tregOffset += 4;\n\t\t\t\t}\n\t\t\t}\n\t\t\tREGWRITE_BUFFER_FLUSH(ah);\n\t\t}\n\t}\n}\n\nstatic void ath9k_hw_set_ar9287_power_per_rate_table(struct ath_hw *ah,\n\t\t\t\t\t\t     struct ath9k_channel *chan,\n\t\t\t\t\t\t     int16_t *ratesArray,\n\t\t\t\t\t\t     u16 cfgCtl,\n\t\t\t\t\t\t     u16 antenna_reduction,\n\t\t\t\t\t\t     u16 powerLimit)\n{\n#define CMP_CTL \\\n\t(((cfgCtl & ~CTL_MODE_M) | (pCtlMode[ctlMode] & CTL_MODE_M)) == \\\n\t pEepData->ctlIndex[i])\n\n#define CMP_NO_CTL \\\n\t(((cfgCtl & ~CTL_MODE_M) | (pCtlMode[ctlMode] & CTL_MODE_M)) == \\\n\t ((pEepData->ctlIndex[i] & CTL_MODE_M) | SD_NO_CTL))\n\n\tu16 twiceMaxEdgePower;\n\tint i;\n\tstruct cal_ctl_data_ar9287 *rep;\n\tstruct cal_target_power_leg targetPowerOfdm = {0, {0, 0, 0, 0} },\n\t\t\t\t    targetPowerCck = {0, {0, 0, 0, 0} };\n\tstruct cal_target_power_leg targetPowerOfdmExt = {0, {0, 0, 0, 0} },\n\t\t\t\t    targetPowerCckExt = {0, {0, 0, 0, 0} };\n\tstruct cal_target_power_ht targetPowerHt20,\n\t\t\t\t    targetPowerHt40 = {0, {0, 0, 0, 0} };\n\tu16 scaledPower = 0, minCtlPower;\n\tstatic const u16 ctlModesFor11g[] = {\n\t\tCTL_11B, CTL_11G, CTL_2GHT20,\n\t\tCTL_11B_EXT, CTL_11G_EXT, CTL_2GHT40\n\t};\n\tu16 numCtlModes = 0;\n\tconst u16 *pCtlMode = NULL;\n\tu16 ctlMode, freq;\n\tstruct chan_centers centers;\n\tint tx_chainmask;\n\tu16 twiceMinEdgePower;\n\tstruct ar9287_eeprom *pEepData = &ah->eeprom.map9287;\n\ttx_chainmask = ah->txchainmask;\n\n\tath9k_hw_get_channel_centers(ah, chan, &centers);\n\tscaledPower = ath9k_hw_get_scaled_power(ah, powerLimit,\n\t\t\t\t\t\tantenna_reduction);\n\n\t \n\tif (IS_CHAN_2GHZ(chan))\t{\n\t\t \n\t\tnumCtlModes =\n\t\t\tARRAY_SIZE(ctlModesFor11g) - SUB_NUM_CTL_MODES_AT_2G_40;\n\n\t\tpCtlMode = ctlModesFor11g;\n\n\t\tath9k_hw_get_legacy_target_powers(ah, chan,\n\t\t\t\t\t\t  pEepData->calTargetPowerCck,\n\t\t\t\t\t\t  AR9287_NUM_2G_CCK_TARGET_POWERS,\n\t\t\t\t\t\t  &targetPowerCck, 4, false);\n\t\tath9k_hw_get_legacy_target_powers(ah, chan,\n\t\t\t\t\t\t  pEepData->calTargetPower2G,\n\t\t\t\t\t\t  AR9287_NUM_2G_20_TARGET_POWERS,\n\t\t\t\t\t\t  &targetPowerOfdm, 4, false);\n\t\tath9k_hw_get_target_powers(ah, chan,\n\t\t\t\t\t   pEepData->calTargetPower2GHT20,\n\t\t\t\t\t   AR9287_NUM_2G_20_TARGET_POWERS,\n\t\t\t\t\t   &targetPowerHt20, 8, false);\n\n\t\tif (IS_CHAN_HT40(chan))\t{\n\t\t\t \n\t\t\tnumCtlModes = ARRAY_SIZE(ctlModesFor11g);\n\t\t\tath9k_hw_get_target_powers(ah, chan,\n\t\t\t\t\t\t   pEepData->calTargetPower2GHT40,\n\t\t\t\t\t\t   AR9287_NUM_2G_40_TARGET_POWERS,\n\t\t\t\t\t\t   &targetPowerHt40, 8, true);\n\t\t\tath9k_hw_get_legacy_target_powers(ah, chan,\n\t\t\t\t\t\t  pEepData->calTargetPowerCck,\n\t\t\t\t\t\t  AR9287_NUM_2G_CCK_TARGET_POWERS,\n\t\t\t\t\t\t  &targetPowerCckExt, 4, true);\n\t\t\tath9k_hw_get_legacy_target_powers(ah, chan,\n\t\t\t\t\t\t  pEepData->calTargetPower2G,\n\t\t\t\t\t\t  AR9287_NUM_2G_20_TARGET_POWERS,\n\t\t\t\t\t\t  &targetPowerOfdmExt, 4, true);\n\t\t}\n\t}\n\n\tfor (ctlMode = 0; ctlMode < numCtlModes; ctlMode++) {\n\t\tbool isHt40CtlMode = pCtlMode[ctlMode] == CTL_2GHT40;\n\n\t\tif (isHt40CtlMode)\n\t\t\tfreq = centers.synth_center;\n\t\telse if (pCtlMode[ctlMode] & EXT_ADDITIVE)\n\t\t\tfreq = centers.ext_center;\n\t\telse\n\t\t\tfreq = centers.ctl_center;\n\n\t\ttwiceMaxEdgePower = MAX_RATE_POWER;\n\t\t \n\t\tfor (i = 0; (i < AR9287_NUM_CTLS) && pEepData->ctlIndex[i]; i++) {\n\t\t\tstruct cal_ctl_edges *pRdEdgesPower;\n\n\t\t\t \n\t\t\tif (CMP_CTL || CMP_NO_CTL) {\n\t\t\t\trep = &(pEepData->ctlData[i]);\n\t\t\t\tpRdEdgesPower =\n\t\t\t\trep->ctlEdges[ar5416_get_ntxchains(tx_chainmask) - 1];\n\n\t\t\t\ttwiceMinEdgePower = ath9k_hw_get_max_edge_power(freq,\n\t\t\t\t\t\t\t\tpRdEdgesPower,\n\t\t\t\t\t\t\t\tIS_CHAN_2GHZ(chan),\n\t\t\t\t\t\t\t\tAR5416_NUM_BAND_EDGES);\n\n\t\t\t\tif ((cfgCtl & ~CTL_MODE_M) == SD_NO_CTL) {\n\t\t\t\t\ttwiceMaxEdgePower = min(twiceMaxEdgePower,\n\t\t\t\t\t\t\t\ttwiceMinEdgePower);\n\t\t\t\t} else {\n\t\t\t\t\ttwiceMaxEdgePower = twiceMinEdgePower;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tminCtlPower = (u8)min(twiceMaxEdgePower, scaledPower);\n\n\t\t \n\t\tswitch (pCtlMode[ctlMode]) {\n\t\tcase CTL_11B:\n\t\t\tfor (i = 0; i < ARRAY_SIZE(targetPowerCck.tPow2x); i++) {\n\t\t\t\ttargetPowerCck.tPow2x[i] =\n\t\t\t\t\t(u8)min((u16)targetPowerCck.tPow2x[i],\n\t\t\t\t\t\tminCtlPower);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CTL_11A:\n\t\tcase CTL_11G:\n\t\t\tfor (i = 0; i < ARRAY_SIZE(targetPowerOfdm.tPow2x); i++) {\n\t\t\t\ttargetPowerOfdm.tPow2x[i] =\n\t\t\t\t\t(u8)min((u16)targetPowerOfdm.tPow2x[i],\n\t\t\t\t\t\tminCtlPower);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CTL_5GHT20:\n\t\tcase CTL_2GHT20:\n\t\t\tfor (i = 0; i < ARRAY_SIZE(targetPowerHt20.tPow2x); i++) {\n\t\t\t\ttargetPowerHt20.tPow2x[i] =\n\t\t\t\t\t(u8)min((u16)targetPowerHt20.tPow2x[i],\n\t\t\t\t\t\tminCtlPower);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CTL_11B_EXT:\n\t\t\ttargetPowerCckExt.tPow2x[0] =\n\t\t\t\t(u8)min((u16)targetPowerCckExt.tPow2x[0],\n\t\t\t\t\tminCtlPower);\n\t\t\tbreak;\n\t\tcase CTL_11A_EXT:\n\t\tcase CTL_11G_EXT:\n\t\t\ttargetPowerOfdmExt.tPow2x[0] =\n\t\t\t\t(u8)min((u16)targetPowerOfdmExt.tPow2x[0],\n\t\t\t\t\tminCtlPower);\n\t\t\tbreak;\n\t\tcase CTL_5GHT40:\n\t\tcase CTL_2GHT40:\n\t\t\tfor (i = 0; i < ARRAY_SIZE(targetPowerHt40.tPow2x); i++) {\n\t\t\t\ttargetPowerHt40.tPow2x[i] =\n\t\t\t\t\t(u8)min((u16)targetPowerHt40.tPow2x[i],\n\t\t\t\t\t\tminCtlPower);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\n\tratesArray[rate6mb] =\n\tratesArray[rate9mb] =\n\tratesArray[rate12mb] =\n\tratesArray[rate18mb] =\n\tratesArray[rate24mb] = targetPowerOfdm.tPow2x[0];\n\n\tratesArray[rate36mb] = targetPowerOfdm.tPow2x[1];\n\tratesArray[rate48mb] = targetPowerOfdm.tPow2x[2];\n\tratesArray[rate54mb] = targetPowerOfdm.tPow2x[3];\n\tratesArray[rateXr] = targetPowerOfdm.tPow2x[0];\n\n\tfor (i = 0; i < ARRAY_SIZE(targetPowerHt20.tPow2x); i++)\n\t\tratesArray[rateHt20_0 + i] = targetPowerHt20.tPow2x[i];\n\n\tif (IS_CHAN_2GHZ(chan))\t{\n\t\tratesArray[rate1l] = targetPowerCck.tPow2x[0];\n\t\tratesArray[rate2s] =\n\t\tratesArray[rate2l] = targetPowerCck.tPow2x[1];\n\t\tratesArray[rate5_5s] =\n\t\tratesArray[rate5_5l] = targetPowerCck.tPow2x[2];\n\t\tratesArray[rate11s] =\n\t\tratesArray[rate11l] = targetPowerCck.tPow2x[3];\n\t}\n\tif (IS_CHAN_HT40(chan))\t{\n\t\tfor (i = 0; i < ARRAY_SIZE(targetPowerHt40.tPow2x); i++)\n\t\t\tratesArray[rateHt40_0 + i] = targetPowerHt40.tPow2x[i];\n\n\t\tratesArray[rateDupOfdm] = targetPowerHt40.tPow2x[0];\n\t\tratesArray[rateDupCck]  = targetPowerHt40.tPow2x[0];\n\t\tratesArray[rateExtOfdm] = targetPowerOfdmExt.tPow2x[0];\n\n\t\tif (IS_CHAN_2GHZ(chan))\n\t\t\tratesArray[rateExtCck] = targetPowerCckExt.tPow2x[0];\n\t}\n\n#undef CMP_CTL\n#undef CMP_NO_CTL\n}\n\nstatic void ath9k_hw_ar9287_set_txpower(struct ath_hw *ah,\n\t\t\t\t\tstruct ath9k_channel *chan, u16 cfgCtl,\n\t\t\t\t\tu8 twiceAntennaReduction,\n\t\t\t\t\tu8 powerLimit, bool test)\n{\n\tstruct ath_regulatory *regulatory = ath9k_hw_regulatory(ah);\n\tstruct ar9287_eeprom *pEepData = &ah->eeprom.map9287;\n\tstruct modal_eep_ar9287_header *pModal = &pEepData->modalHeader;\n\tint16_t ratesArray[Ar5416RateSize];\n\tu8 ht40PowerIncForPdadc = 2;\n\tint i;\n\n\tmemset(ratesArray, 0, sizeof(ratesArray));\n\n\tif (ath9k_hw_ar9287_get_eeprom_rev(ah) >= AR9287_EEP_MINOR_VER_2)\n\t\tht40PowerIncForPdadc = pModal->ht40PowerIncForPdadc;\n\n\tath9k_hw_set_ar9287_power_per_rate_table(ah, chan,\n\t\t\t\t\t\t &ratesArray[0], cfgCtl,\n\t\t\t\t\t\t twiceAntennaReduction,\n\t\t\t\t\t\t powerLimit);\n\n\tath9k_hw_set_ar9287_power_cal_table(ah, chan);\n\n\tregulatory->max_power_level = 0;\n\tfor (i = 0; i < ARRAY_SIZE(ratesArray); i++) {\n\t\tif (ratesArray[i] > MAX_RATE_POWER)\n\t\t\tratesArray[i] = MAX_RATE_POWER;\n\n\t\tif (ratesArray[i] > regulatory->max_power_level)\n\t\t\tregulatory->max_power_level = ratesArray[i];\n\t}\n\n\tath9k_hw_update_regulatory_maxpower(ah);\n\n\tif (test)\n\t\treturn;\n\n\tfor (i = 0; i < Ar5416RateSize; i++)\n\t\tratesArray[i] -= AR9287_PWR_TABLE_OFFSET_DB * 2;\n\n\tENABLE_REGWRITE_BUFFER(ah);\n\n\t \n\tREG_WRITE(ah, AR_PHY_POWER_TX_RATE1,\n\t\t  ATH9K_POW_SM(ratesArray[rate18mb], 24)\n\t\t  | ATH9K_POW_SM(ratesArray[rate12mb], 16)\n\t\t  | ATH9K_POW_SM(ratesArray[rate9mb], 8)\n\t\t  | ATH9K_POW_SM(ratesArray[rate6mb], 0));\n\n\tREG_WRITE(ah, AR_PHY_POWER_TX_RATE2,\n\t\t  ATH9K_POW_SM(ratesArray[rate54mb], 24)\n\t\t  | ATH9K_POW_SM(ratesArray[rate48mb], 16)\n\t\t  | ATH9K_POW_SM(ratesArray[rate36mb], 8)\n\t\t  | ATH9K_POW_SM(ratesArray[rate24mb], 0));\n\n\t \n\tif (IS_CHAN_2GHZ(chan))\t{\n\t\tREG_WRITE(ah, AR_PHY_POWER_TX_RATE3,\n\t\t\t  ATH9K_POW_SM(ratesArray[rate2s], 24)\n\t\t\t  | ATH9K_POW_SM(ratesArray[rate2l], 16)\n\t\t\t  | ATH9K_POW_SM(ratesArray[rateXr], 8)\n\t\t\t  | ATH9K_POW_SM(ratesArray[rate1l], 0));\n\t\tREG_WRITE(ah, AR_PHY_POWER_TX_RATE4,\n\t\t\t  ATH9K_POW_SM(ratesArray[rate11s], 24)\n\t\t\t  | ATH9K_POW_SM(ratesArray[rate11l], 16)\n\t\t\t  | ATH9K_POW_SM(ratesArray[rate5_5s], 8)\n\t\t\t  | ATH9K_POW_SM(ratesArray[rate5_5l], 0));\n\t}\n\n\t \n\tREG_WRITE(ah, AR_PHY_POWER_TX_RATE5,\n\t\t  ATH9K_POW_SM(ratesArray[rateHt20_3], 24)\n\t\t  | ATH9K_POW_SM(ratesArray[rateHt20_2], 16)\n\t\t  | ATH9K_POW_SM(ratesArray[rateHt20_1], 8)\n\t\t  | ATH9K_POW_SM(ratesArray[rateHt20_0], 0));\n\n\tREG_WRITE(ah, AR_PHY_POWER_TX_RATE6,\n\t\t  ATH9K_POW_SM(ratesArray[rateHt20_7], 24)\n\t\t  | ATH9K_POW_SM(ratesArray[rateHt20_6], 16)\n\t\t  | ATH9K_POW_SM(ratesArray[rateHt20_5], 8)\n\t\t  | ATH9K_POW_SM(ratesArray[rateHt20_4], 0));\n\n\t \n\tif (IS_CHAN_HT40(chan))\t{\n\t\tif (ath9k_hw_ar9287_get_eeprom(ah, EEP_OL_PWRCTRL)) {\n\t\t\tREG_WRITE(ah, AR_PHY_POWER_TX_RATE7,\n\t\t\t\t  ATH9K_POW_SM(ratesArray[rateHt40_3], 24)\n\t\t\t\t  | ATH9K_POW_SM(ratesArray[rateHt40_2], 16)\n\t\t\t\t  | ATH9K_POW_SM(ratesArray[rateHt40_1], 8)\n\t\t\t\t  | ATH9K_POW_SM(ratesArray[rateHt40_0], 0));\n\n\t\t\tREG_WRITE(ah, AR_PHY_POWER_TX_RATE8,\n\t\t\t\t  ATH9K_POW_SM(ratesArray[rateHt40_7], 24)\n\t\t\t\t  | ATH9K_POW_SM(ratesArray[rateHt40_6], 16)\n\t\t\t\t  | ATH9K_POW_SM(ratesArray[rateHt40_5], 8)\n\t\t\t\t  | ATH9K_POW_SM(ratesArray[rateHt40_4], 0));\n\t\t} else {\n\t\t\tREG_WRITE(ah, AR_PHY_POWER_TX_RATE7,\n\t\t\t\t  ATH9K_POW_SM(ratesArray[rateHt40_3] +\n\t\t\t\t\t       ht40PowerIncForPdadc, 24)\n\t\t\t\t  | ATH9K_POW_SM(ratesArray[rateHt40_2] +\n\t\t\t\t\t\t ht40PowerIncForPdadc, 16)\n\t\t\t\t  | ATH9K_POW_SM(ratesArray[rateHt40_1] +\n\t\t\t\t\t\t ht40PowerIncForPdadc, 8)\n\t\t\t\t  | ATH9K_POW_SM(ratesArray[rateHt40_0] +\n\t\t\t\t\t\t ht40PowerIncForPdadc, 0));\n\n\t\t\tREG_WRITE(ah, AR_PHY_POWER_TX_RATE8,\n\t\t\t\t  ATH9K_POW_SM(ratesArray[rateHt40_7] +\n\t\t\t\t\t       ht40PowerIncForPdadc, 24)\n\t\t\t\t  | ATH9K_POW_SM(ratesArray[rateHt40_6] +\n\t\t\t\t\t\t ht40PowerIncForPdadc, 16)\n\t\t\t\t  | ATH9K_POW_SM(ratesArray[rateHt40_5] +\n\t\t\t\t\t\t ht40PowerIncForPdadc, 8)\n\t\t\t\t  | ATH9K_POW_SM(ratesArray[rateHt40_4] +\n\t\t\t\t\t\t ht40PowerIncForPdadc, 0));\n\t\t}\n\n\t\t \n\t\tREG_WRITE(ah, AR_PHY_POWER_TX_RATE9,\n\t\t\t  ATH9K_POW_SM(ratesArray[rateExtOfdm], 24)\n\t\t\t  | ATH9K_POW_SM(ratesArray[rateExtCck], 16)\n\t\t\t  | ATH9K_POW_SM(ratesArray[rateDupOfdm], 8)\n\t\t\t  | ATH9K_POW_SM(ratesArray[rateDupCck], 0));\n\t}\n\n\t \n\tif (ah->tpc_enabled) {\n\t\tint ht40_delta;\n\n\t\tht40_delta = (IS_CHAN_HT40(chan)) ? ht40PowerIncForPdadc : 0;\n\t\tar5008_hw_init_rate_txpower(ah, ratesArray, chan, ht40_delta);\n\t\t \n\t\tREG_WRITE(ah, AR_PHY_POWER_TX_RATE_MAX,\n\t\t\tMAX_RATE_POWER | AR_PHY_POWER_TX_RATE_MAX_TPC_ENABLE);\n\t} else {\n\t\t \n\t\tREG_WRITE(ah, AR_PHY_POWER_TX_RATE_MAX, MAX_RATE_POWER);\n\t}\n\n\tREGWRITE_BUFFER_FLUSH(ah);\n}\n\nstatic void ath9k_hw_ar9287_set_board_values(struct ath_hw *ah,\n\t\t\t\t\t     struct ath9k_channel *chan)\n{\n\tstruct ar9287_eeprom *eep = &ah->eeprom.map9287;\n\tstruct modal_eep_ar9287_header *pModal = &eep->modalHeader;\n\tu32 regChainOffset, regval;\n\tu8 txRxAttenLocal;\n\tint i;\n\n\tpModal = &eep->modalHeader;\n\n\tREG_WRITE(ah, AR_PHY_SWITCH_COM, le32_to_cpu(pModal->antCtrlCommon));\n\n\tfor (i = 0; i < AR9287_MAX_CHAINS; i++)\t{\n\t\tregChainOffset = i * 0x1000;\n\n\t\tREG_WRITE(ah, AR_PHY_SWITCH_CHAIN_0 + regChainOffset,\n\t\t\t  le32_to_cpu(pModal->antCtrlChain[i]));\n\n\t\tREG_WRITE(ah, AR_PHY_TIMING_CTRL4(0) + regChainOffset,\n\t\t\t  (REG_READ(ah, AR_PHY_TIMING_CTRL4(0) + regChainOffset)\n\t\t\t   & ~(AR_PHY_TIMING_CTRL4_IQCORR_Q_Q_COFF |\n\t\t\t       AR_PHY_TIMING_CTRL4_IQCORR_Q_I_COFF)) |\n\t\t\t  SM(pModal->iqCalICh[i],\n\t\t\t     AR_PHY_TIMING_CTRL4_IQCORR_Q_I_COFF) |\n\t\t\t  SM(pModal->iqCalQCh[i],\n\t\t\t     AR_PHY_TIMING_CTRL4_IQCORR_Q_Q_COFF));\n\n\t\ttxRxAttenLocal = pModal->txRxAttenCh[i];\n\n\t\tREG_RMW_FIELD(ah, AR_PHY_GAIN_2GHZ + regChainOffset,\n\t\t\t      AR_PHY_GAIN_2GHZ_XATTEN1_MARGIN,\n\t\t\t      pModal->bswMargin[i]);\n\t\tREG_RMW_FIELD(ah, AR_PHY_GAIN_2GHZ + regChainOffset,\n\t\t\t      AR_PHY_GAIN_2GHZ_XATTEN1_DB,\n\t\t\t      pModal->bswAtten[i]);\n\t\tREG_RMW_FIELD(ah, AR_PHY_RXGAIN + regChainOffset,\n\t\t\t      AR9280_PHY_RXGAIN_TXRX_ATTEN,\n\t\t\t      txRxAttenLocal);\n\t\tREG_RMW_FIELD(ah, AR_PHY_RXGAIN + regChainOffset,\n\t\t\t      AR9280_PHY_RXGAIN_TXRX_MARGIN,\n\t\t\t      pModal->rxTxMarginCh[i]);\n\t}\n\n\n\tif (IS_CHAN_HT40(chan))\n\t\tREG_RMW_FIELD(ah, AR_PHY_SETTLING,\n\t\t\t      AR_PHY_SETTLING_SWITCH, pModal->swSettleHt40);\n\telse\n\t\tREG_RMW_FIELD(ah, AR_PHY_SETTLING,\n\t\t\t      AR_PHY_SETTLING_SWITCH, pModal->switchSettling);\n\n\tREG_RMW_FIELD(ah, AR_PHY_DESIRED_SZ,\n\t\t      AR_PHY_DESIRED_SZ_ADC, pModal->adcDesiredSize);\n\n\tREG_WRITE(ah, AR_PHY_RF_CTL4,\n\t\t  SM(pModal->txEndToXpaOff, AR_PHY_RF_CTL4_TX_END_XPAA_OFF)\n\t\t  | SM(pModal->txEndToXpaOff, AR_PHY_RF_CTL4_TX_END_XPAB_OFF)\n\t\t  | SM(pModal->txFrameToXpaOn, AR_PHY_RF_CTL4_FRAME_XPAA_ON)\n\t\t  | SM(pModal->txFrameToXpaOn, AR_PHY_RF_CTL4_FRAME_XPAB_ON));\n\n\tREG_RMW_FIELD(ah, AR_PHY_RF_CTL3,\n\t\t      AR_PHY_TX_END_TO_A2_RX_ON, pModal->txEndToRxOn);\n\n\tREG_RMW_FIELD(ah, AR_PHY_CCA,\n\t\t      AR9280_PHY_CCA_THRESH62, pModal->thresh62);\n\tREG_RMW_FIELD(ah, AR_PHY_EXT_CCA0,\n\t\t      AR_PHY_EXT_CCA0_THRESH62, pModal->thresh62);\n\n\tregval = REG_READ(ah, AR9287_AN_RF2G3_CH0);\n\tregval &= ~(AR9287_AN_RF2G3_DB1 |\n\t\t    AR9287_AN_RF2G3_DB2 |\n\t\t    AR9287_AN_RF2G3_OB_CCK |\n\t\t    AR9287_AN_RF2G3_OB_PSK |\n\t\t    AR9287_AN_RF2G3_OB_QAM |\n\t\t    AR9287_AN_RF2G3_OB_PAL_OFF);\n\tregval |= (SM(pModal->db1, AR9287_AN_RF2G3_DB1) |\n\t\t   SM(pModal->db2, AR9287_AN_RF2G3_DB2) |\n\t\t   SM(pModal->ob_cck, AR9287_AN_RF2G3_OB_CCK) |\n\t\t   SM(pModal->ob_psk, AR9287_AN_RF2G3_OB_PSK) |\n\t\t   SM(pModal->ob_qam, AR9287_AN_RF2G3_OB_QAM) |\n\t\t   SM(pModal->ob_pal_off, AR9287_AN_RF2G3_OB_PAL_OFF));\n\n\tath9k_hw_analog_shift_regwrite(ah, AR9287_AN_RF2G3_CH0, regval);\n\n\tregval = REG_READ(ah, AR9287_AN_RF2G3_CH1);\n\tregval &= ~(AR9287_AN_RF2G3_DB1 |\n\t\t    AR9287_AN_RF2G3_DB2 |\n\t\t    AR9287_AN_RF2G3_OB_CCK |\n\t\t    AR9287_AN_RF2G3_OB_PSK |\n\t\t    AR9287_AN_RF2G3_OB_QAM |\n\t\t    AR9287_AN_RF2G3_OB_PAL_OFF);\n\tregval |= (SM(pModal->db1, AR9287_AN_RF2G3_DB1) |\n\t\t   SM(pModal->db2, AR9287_AN_RF2G3_DB2) |\n\t\t   SM(pModal->ob_cck, AR9287_AN_RF2G3_OB_CCK) |\n\t\t   SM(pModal->ob_psk, AR9287_AN_RF2G3_OB_PSK) |\n\t\t   SM(pModal->ob_qam, AR9287_AN_RF2G3_OB_QAM) |\n\t\t   SM(pModal->ob_pal_off, AR9287_AN_RF2G3_OB_PAL_OFF));\n\n\tath9k_hw_analog_shift_regwrite(ah, AR9287_AN_RF2G3_CH1, regval);\n\n\tREG_RMW_FIELD(ah, AR_PHY_RF_CTL2,\n\t\t      AR_PHY_TX_END_DATA_START, pModal->txFrameToDataStart);\n\tREG_RMW_FIELD(ah, AR_PHY_RF_CTL2,\n\t\t      AR_PHY_TX_END_PA_ON, pModal->txFrameToPaOn);\n\n\tath9k_hw_analog_shift_rmw(ah, AR9287_AN_TOP2,\n\t\t\t\t  AR9287_AN_TOP2_XPABIAS_LVL,\n\t\t\t\t  AR9287_AN_TOP2_XPABIAS_LVL_S,\n\t\t\t\t  pModal->xpaBiasLvl);\n}\n\nstatic u16 ath9k_hw_ar9287_get_spur_channel(struct ath_hw *ah,\n\t\t\t\t\t    u16 i, bool is2GHz)\n{\n\t__le16 spur_ch = ah->eeprom.map9287.modalHeader.spurChans[i].spurChan;\n\n\treturn le16_to_cpu(spur_ch);\n}\n\nstatic u8 ath9k_hw_ar9287_get_eepmisc(struct ath_hw *ah)\n{\n\treturn ah->eeprom.map9287.baseEepHeader.eepMisc;\n}\n\nconst struct eeprom_ops eep_ar9287_ops = {\n\t.check_eeprom\t\t= ath9k_hw_ar9287_check_eeprom,\n\t.get_eeprom\t\t= ath9k_hw_ar9287_get_eeprom,\n\t.fill_eeprom\t\t= ath9k_hw_ar9287_fill_eeprom,\n\t.dump_eeprom\t\t= ath9k_hw_ar9287_dump_eeprom,\n\t.get_eeprom_ver\t\t= ath9k_hw_ar9287_get_eeprom_ver,\n\t.get_eeprom_rev\t\t= ath9k_hw_ar9287_get_eeprom_rev,\n\t.set_board_values\t= ath9k_hw_ar9287_set_board_values,\n\t.set_txpower\t\t= ath9k_hw_ar9287_set_txpower,\n\t.get_spur_channel\t= ath9k_hw_ar9287_get_spur_channel,\n\t.get_eepmisc\t\t= ath9k_hw_ar9287_get_eepmisc\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}