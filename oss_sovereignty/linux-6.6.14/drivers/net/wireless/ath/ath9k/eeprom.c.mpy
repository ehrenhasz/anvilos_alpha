{
  "module_name": "eeprom.c",
  "hash_id": "7cf15554aec3096fefbc6cfe3b0f88b471927b65d52973740bf522d52b4c3f3c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath9k/eeprom.c",
  "human_readable_source": " \n\n#include \"hw.h\"\n#include <linux/ath9k_platform.h>\n\nvoid ath9k_hw_analog_shift_regwrite(struct ath_hw *ah, u32 reg, u32 val)\n{\n        REG_WRITE(ah, reg, val);\n\n        if (ah->config.analog_shiftreg)\n\t\tudelay(100);\n}\n\nvoid ath9k_hw_analog_shift_rmw(struct ath_hw *ah, u32 reg, u32 mask,\n\t\t\t       u32 shift, u32 val)\n{\n\tREG_RMW(ah, reg, ((val << shift) & mask), mask);\n\n\tif (ah->config.analog_shiftreg)\n\t\tudelay(100);\n}\n\nint16_t ath9k_hw_interpolate(u16 target, u16 srcLeft, u16 srcRight,\n\t\t\t     int16_t targetLeft, int16_t targetRight)\n{\n\tint16_t rv;\n\n\tif (srcRight == srcLeft) {\n\t\trv = targetLeft;\n\t} else {\n\t\trv = (int16_t) (((target - srcLeft) * targetRight +\n\t\t\t\t (srcRight - target) * targetLeft) /\n\t\t\t\t(srcRight - srcLeft));\n\t}\n\treturn rv;\n}\n\nbool ath9k_hw_get_lower_upper_index(u8 target, u8 *pList, u16 listSize,\n\t\t\t\t    u16 *indexL, u16 *indexR)\n{\n\tu16 i;\n\n\tif (target <= pList[0]) {\n\t\t*indexL = *indexR = 0;\n\t\treturn true;\n\t}\n\tif (target >= pList[listSize - 1]) {\n\t\t*indexL = *indexR = (u16) (listSize - 1);\n\t\treturn true;\n\t}\n\n\tfor (i = 0; i < listSize - 1; i++) {\n\t\tif (pList[i] == target) {\n\t\t\t*indexL = *indexR = i;\n\t\t\treturn true;\n\t\t}\n\t\tif (target < pList[i + 1]) {\n\t\t\t*indexL = i;\n\t\t\t*indexR = (u16) (i + 1);\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid ath9k_hw_usb_gen_fill_eeprom(struct ath_hw *ah, u16 *eep_data,\n\t\t\t\t  int eep_start_loc, int size)\n{\n\tint i = 0, j, addr;\n\tu32 addrdata[8];\n\tu32 data[8];\n\n\tfor (addr = 0; addr < size; addr++) {\n\t\taddrdata[i] = AR5416_EEPROM_OFFSET +\n\t\t\t((addr + eep_start_loc) << AR5416_EEPROM_S);\n\t\ti++;\n\t\tif (i == 8) {\n\t\t\tREG_READ_MULTI(ah, addrdata, data, i);\n\n\t\t\tfor (j = 0; j < i; j++) {\n\t\t\t\t*eep_data = data[j];\n\t\t\t\teep_data++;\n\t\t\t}\n\t\t\ti = 0;\n\t\t}\n\t}\n\n\tif (i != 0) {\n\t\tREG_READ_MULTI(ah, addrdata, data, i);\n\n\t\tfor (j = 0; j < i; j++) {\n\t\t\t*eep_data = data[j];\n\t\t\teep_data++;\n\t\t}\n\t}\n}\n\nstatic bool ath9k_hw_nvram_read_array(u16 *blob, size_t blob_size,\n\t\t\t\t      off_t offset, u16 *data)\n{\n\tif (offset >= blob_size)\n\t\treturn false;\n\n\t*data =  blob[offset];\n\treturn true;\n}\n\nstatic bool ath9k_hw_nvram_read_pdata(struct ath9k_platform_data *pdata,\n\t\t\t\t      off_t offset, u16 *data)\n{\n\treturn ath9k_hw_nvram_read_array(pdata->eeprom_data,\n\t\t\t\t\t ARRAY_SIZE(pdata->eeprom_data),\n\t\t\t\t\t offset, data);\n}\n\nstatic bool ath9k_hw_nvram_read_firmware(const struct firmware *eeprom_blob,\n\t\t\t\t\t off_t offset, u16 *data)\n{\n\treturn ath9k_hw_nvram_read_array((u16 *) eeprom_blob->data,\n\t\t\t\t\t eeprom_blob->size / sizeof(u16),\n\t\t\t\t\t offset, data);\n}\n\nstatic bool ath9k_hw_nvram_read_nvmem(struct ath_hw *ah, off_t offset,\n\t\t\t\t      u16 *data)\n{\n\treturn ath9k_hw_nvram_read_array(ah->nvmem_blob,\n\t\t\t\t\t ah->nvmem_blob_len / sizeof(u16),\n\t\t\t\t\t offset, data);\n}\n\nbool ath9k_hw_nvram_read(struct ath_hw *ah, u32 off, u16 *data)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath9k_platform_data *pdata = ah->dev->platform_data;\n\tbool ret;\n\n\tif (ah->nvmem_blob)\n\t\tret = ath9k_hw_nvram_read_nvmem(ah, off, data);\n\telse if (ah->eeprom_blob)\n\t\tret = ath9k_hw_nvram_read_firmware(ah->eeprom_blob, off, data);\n\telse if (pdata && !pdata->use_eeprom)\n\t\tret = ath9k_hw_nvram_read_pdata(pdata, off, data);\n\telse\n\t\tret = common->bus_ops->eeprom_read(common, off, data);\n\n\tif (!ret)\n\t\tath_dbg(common, EEPROM,\n\t\t\t\"unable to read eeprom region at offset %u\\n\", off);\n\n\treturn ret;\n}\n\nint ath9k_hw_nvram_swap_data(struct ath_hw *ah, bool *swap_needed, int size)\n{\n\tu16 magic;\n\tu16 *eepdata;\n\tint i;\n\tbool needs_byteswap = false;\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\n\tif (!ath9k_hw_nvram_read(ah, AR5416_EEPROM_MAGIC_OFFSET, &magic)) {\n\t\tath_err(common, \"Reading Magic # failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (swab16(magic) == AR5416_EEPROM_MAGIC) {\n\t\tneeds_byteswap = true;\n\t\tath_dbg(common, EEPROM,\n\t\t\t\"EEPROM needs byte-swapping to correct endianness.\\n\");\n\t} else if (magic != AR5416_EEPROM_MAGIC) {\n\t\tif (ath9k_hw_use_flash(ah)) {\n\t\t\tath_dbg(common, EEPROM,\n\t\t\t\t\"Ignoring invalid EEPROM magic (0x%04x).\\n\",\n\t\t\t\tmagic);\n\t\t} else {\n\t\t\tath_err(common,\n\t\t\t\t\"Invalid EEPROM magic (0x%04x).\\n\", magic);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (needs_byteswap) {\n\t\tif (ah->ah_flags & AH_NO_EEP_SWAP) {\n\t\t\tath_info(common,\n\t\t\t\t \"Ignoring endianness difference in EEPROM magic bytes.\\n\");\n\t\t} else {\n\t\t\teepdata = (u16 *)(&ah->eeprom);\n\n\t\t\tfor (i = 0; i < size; i++)\n\t\t\t\teepdata[i] = swab16(eepdata[i]);\n\t\t}\n\t}\n\n\tif (ah->eep_ops->get_eepmisc(ah) & AR5416_EEPMISC_BIG_ENDIAN) {\n\t\t*swap_needed = true;\n\t\tath_dbg(common, EEPROM,\n\t\t\t\"Big Endian EEPROM detected according to EEPMISC register.\\n\");\n\t} else {\n\t\t*swap_needed = false;\n\t}\n\n\treturn 0;\n}\n\nbool ath9k_hw_nvram_validate_checksum(struct ath_hw *ah, int size)\n{\n\tu32 i, sum = 0;\n\tu16 *eepdata = (u16 *)(&ah->eeprom);\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\n\tfor (i = 0; i < size; i++)\n\t\tsum ^= eepdata[i];\n\n\tif (sum != 0xffff) {\n\t\tath_err(common, \"Bad EEPROM checksum 0x%x\\n\", sum);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nbool ath9k_hw_nvram_check_version(struct ath_hw *ah, int version, int minrev)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\n\tif (ah->eep_ops->get_eeprom_ver(ah) != version ||\n\t    ah->eep_ops->get_eeprom_rev(ah) < minrev) {\n\t\tath_err(common, \"Bad EEPROM VER 0x%04x or REV 0x%04x\\n\",\n\t\t\tah->eep_ops->get_eeprom_ver(ah),\n\t\t\tah->eep_ops->get_eeprom_rev(ah));\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nvoid ath9k_hw_fill_vpd_table(u8 pwrMin, u8 pwrMax, u8 *pPwrList,\n\t\t\t     u8 *pVpdList, u16 numIntercepts,\n\t\t\t     u8 *pRetVpdList)\n{\n\tu16 i, k;\n\tu8 currPwr = pwrMin;\n\tu16 idxL = 0, idxR = 0;\n\n\tfor (i = 0; i <= (pwrMax - pwrMin) / 2; i++) {\n\t\tath9k_hw_get_lower_upper_index(currPwr, pPwrList,\n\t\t\t\t\t       numIntercepts, &(idxL),\n\t\t\t\t\t       &(idxR));\n\t\tif (idxR < 1)\n\t\t\tidxR = 1;\n\t\tif (idxL == numIntercepts - 1)\n\t\t\tidxL = (u16) (numIntercepts - 2);\n\t\tif (pPwrList[idxL] == pPwrList[idxR])\n\t\t\tk = pVpdList[idxL];\n\t\telse\n\t\t\tk = (u16)(((currPwr - pPwrList[idxL]) * pVpdList[idxR] +\n\t\t\t\t   (pPwrList[idxR] - currPwr) * pVpdList[idxL]) /\n\t\t\t\t  (pPwrList[idxR] - pPwrList[idxL]));\n\t\tpRetVpdList[i] = (u8) k;\n\t\tcurrPwr += 2;\n\t}\n}\n\nvoid ath9k_hw_get_legacy_target_powers(struct ath_hw *ah,\n\t\t\t\t       struct ath9k_channel *chan,\n\t\t\t\t       struct cal_target_power_leg *powInfo,\n\t\t\t\t       u16 numChannels,\n\t\t\t\t       struct cal_target_power_leg *pNewPower,\n\t\t\t\t       u16 numRates, bool isExtTarget)\n{\n\tstruct chan_centers centers;\n\tu16 clo, chi;\n\tint i;\n\tint matchIndex = -1, lowIndex = -1;\n\tu16 freq;\n\n\tath9k_hw_get_channel_centers(ah, chan, &centers);\n\tfreq = (isExtTarget) ? centers.ext_center : centers.ctl_center;\n\n\tif (freq <= ath9k_hw_fbin2freq(powInfo[0].bChannel,\n\t\t\t\t       IS_CHAN_2GHZ(chan))) {\n\t\tmatchIndex = 0;\n\t} else {\n\t\tfor (i = 0; (i < numChannels) &&\n\t\t\t     (powInfo[i].bChannel != AR5416_BCHAN_UNUSED); i++) {\n\t\t\tif (freq == ath9k_hw_fbin2freq(powInfo[i].bChannel,\n\t\t\t\t\t\t       IS_CHAN_2GHZ(chan))) {\n\t\t\t\tmatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t} else if (freq < ath9k_hw_fbin2freq(powInfo[i].bChannel,\n\t\t\t\t\t\tIS_CHAN_2GHZ(chan)) && i > 0 &&\n\t\t\t\t   freq > ath9k_hw_fbin2freq(powInfo[i - 1].bChannel,\n\t\t\t\t\t\tIS_CHAN_2GHZ(chan))) {\n\t\t\t\tlowIndex = i - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ((matchIndex == -1) && (lowIndex == -1))\n\t\t\tmatchIndex = i - 1;\n\t}\n\n\tif (matchIndex != -1) {\n\t\t*pNewPower = powInfo[matchIndex];\n\t} else {\n\t\tclo = ath9k_hw_fbin2freq(powInfo[lowIndex].bChannel,\n\t\t\t\t\t IS_CHAN_2GHZ(chan));\n\t\tchi = ath9k_hw_fbin2freq(powInfo[lowIndex + 1].bChannel,\n\t\t\t\t\t IS_CHAN_2GHZ(chan));\n\n\t\tfor (i = 0; i < numRates; i++) {\n\t\t\tpNewPower->tPow2x[i] =\n\t\t\t\t(u8)ath9k_hw_interpolate(freq, clo, chi,\n\t\t\t\t\t\tpowInfo[lowIndex].tPow2x[i],\n\t\t\t\t\t\tpowInfo[lowIndex + 1].tPow2x[i]);\n\t\t}\n\t}\n}\n\nvoid ath9k_hw_get_target_powers(struct ath_hw *ah,\n\t\t\t\tstruct ath9k_channel *chan,\n\t\t\t\tstruct cal_target_power_ht *powInfo,\n\t\t\t\tu16 numChannels,\n\t\t\t\tstruct cal_target_power_ht *pNewPower,\n\t\t\t\tu16 numRates, bool isHt40Target)\n{\n\tstruct chan_centers centers;\n\tu16 clo, chi;\n\tint i;\n\tint matchIndex = -1, lowIndex = -1;\n\tu16 freq;\n\n\tath9k_hw_get_channel_centers(ah, chan, &centers);\n\tfreq = isHt40Target ? centers.synth_center : centers.ctl_center;\n\n\tif (freq <= ath9k_hw_fbin2freq(powInfo[0].bChannel, IS_CHAN_2GHZ(chan))) {\n\t\tmatchIndex = 0;\n\t} else {\n\t\tfor (i = 0; (i < numChannels) &&\n\t\t\t     (powInfo[i].bChannel != AR5416_BCHAN_UNUSED); i++) {\n\t\t\tif (freq == ath9k_hw_fbin2freq(powInfo[i].bChannel,\n\t\t\t\t\t\t       IS_CHAN_2GHZ(chan))) {\n\t\t\t\tmatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\tif (freq < ath9k_hw_fbin2freq(powInfo[i].bChannel,\n\t\t\t\t\t\tIS_CHAN_2GHZ(chan)) && i > 0 &&\n\t\t\t\t    freq > ath9k_hw_fbin2freq(powInfo[i - 1].bChannel,\n\t\t\t\t\t\tIS_CHAN_2GHZ(chan))) {\n\t\t\t\t\tlowIndex = i - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t\tif ((matchIndex == -1) && (lowIndex == -1))\n\t\t\tmatchIndex = i - 1;\n\t}\n\n\tif (matchIndex != -1) {\n\t\t*pNewPower = powInfo[matchIndex];\n\t} else {\n\t\tclo = ath9k_hw_fbin2freq(powInfo[lowIndex].bChannel,\n\t\t\t\t\t IS_CHAN_2GHZ(chan));\n\t\tchi = ath9k_hw_fbin2freq(powInfo[lowIndex + 1].bChannel,\n\t\t\t\t\t IS_CHAN_2GHZ(chan));\n\n\t\tfor (i = 0; i < numRates; i++) {\n\t\t\tpNewPower->tPow2x[i] = (u8)ath9k_hw_interpolate(freq,\n\t\t\t\t\t\tclo, chi,\n\t\t\t\t\t\tpowInfo[lowIndex].tPow2x[i],\n\t\t\t\t\t\tpowInfo[lowIndex + 1].tPow2x[i]);\n\t\t}\n\t}\n}\n\nu16 ath9k_hw_get_max_edge_power(u16 freq, struct cal_ctl_edges *pRdEdgesPower,\n\t\t\t\tbool is2GHz, int num_band_edges)\n{\n\tu16 twiceMaxEdgePower = MAX_RATE_POWER;\n\tint i;\n\n\tfor (i = 0; (i < num_band_edges) &&\n\t\t     (pRdEdgesPower[i].bChannel != AR5416_BCHAN_UNUSED); i++) {\n\t\tif (freq == ath9k_hw_fbin2freq(pRdEdgesPower[i].bChannel, is2GHz)) {\n\t\t\ttwiceMaxEdgePower = CTL_EDGE_TPOWER(pRdEdgesPower[i].ctl);\n\t\t\tbreak;\n\t\t} else if ((i > 0) &&\n\t\t\t   (freq < ath9k_hw_fbin2freq(pRdEdgesPower[i].bChannel,\n\t\t\t\t\t\t      is2GHz))) {\n\t\t\tif (ath9k_hw_fbin2freq(pRdEdgesPower[i - 1].bChannel,\n\t\t\t\t\t       is2GHz) < freq &&\n\t\t\t    CTL_EDGE_FLAGS(pRdEdgesPower[i - 1].ctl)) {\n\t\t\t\ttwiceMaxEdgePower =\n\t\t\t\t\tCTL_EDGE_TPOWER(pRdEdgesPower[i - 1].ctl);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn twiceMaxEdgePower;\n}\n\nu16 ath9k_hw_get_scaled_power(struct ath_hw *ah, u16 power_limit,\n\t\t\t      u8 antenna_reduction)\n{\n\tu16 reduction = antenna_reduction;\n\n\t \n\tswitch (ar5416_get_ntxchains(ah->txchainmask)) {\n\tcase 1:\n\t\tbreak;\n\tcase 2:\n\t\treduction += POWER_CORRECTION_FOR_TWO_CHAIN;\n\t\tbreak;\n\tcase 3:\n\t\treduction += POWER_CORRECTION_FOR_THREE_CHAIN;\n\t\tbreak;\n\t}\n\n\tif (power_limit > reduction)\n\t\tpower_limit -= reduction;\n\telse\n\t\tpower_limit = 0;\n\n\treturn min_t(u16, power_limit, MAX_RATE_POWER);\n}\n\nvoid ath9k_hw_update_regulatory_maxpower(struct ath_hw *ah)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath_regulatory *regulatory = ath9k_hw_regulatory(ah);\n\n\tswitch (ar5416_get_ntxchains(ah->txchainmask)) {\n\tcase 1:\n\t\tbreak;\n\tcase 2:\n\t\tregulatory->max_power_level += POWER_CORRECTION_FOR_TWO_CHAIN;\n\t\tbreak;\n\tcase 3:\n\t\tregulatory->max_power_level += POWER_CORRECTION_FOR_THREE_CHAIN;\n\t\tbreak;\n\tdefault:\n\t\tath_dbg(common, EEPROM, \"Invalid chainmask configuration\\n\");\n\t\tbreak;\n\t}\n}\n\nvoid ath9k_hw_get_gain_boundaries_pdadcs(struct ath_hw *ah,\n\t\t\t\tstruct ath9k_channel *chan,\n\t\t\t\tvoid *pRawDataSet,\n\t\t\t\tu8 *bChans, u16 availPiers,\n\t\t\t\tu16 tPdGainOverlap,\n\t\t\t\tu16 *pPdGainBoundaries, u8 *pPDADCValues,\n\t\t\t\tu16 numXpdGains)\n{\n\tint i, j, k;\n\tint16_t ss;\n\tu16 idxL = 0, idxR = 0, numPiers;\n\tstatic u8 vpdTableL[AR5416_NUM_PD_GAINS]\n\t\t[AR5416_MAX_PWR_RANGE_IN_HALF_DB];\n\tstatic u8 vpdTableR[AR5416_NUM_PD_GAINS]\n\t\t[AR5416_MAX_PWR_RANGE_IN_HALF_DB];\n\tstatic u8 vpdTableI[AR5416_NUM_PD_GAINS]\n\t\t[AR5416_MAX_PWR_RANGE_IN_HALF_DB];\n\n\tu8 *pVpdL, *pVpdR, *pPwrL, *pPwrR;\n\tu8 minPwrT4[AR5416_NUM_PD_GAINS];\n\tu8 maxPwrT4[AR5416_NUM_PD_GAINS];\n\tint16_t vpdStep;\n\tint16_t tmpVal;\n\tu16 sizeCurrVpdTable, maxIndex, tgtIndex;\n\tbool match;\n\tint16_t minDelta = 0;\n\tstruct chan_centers centers;\n\tint pdgain_boundary_default;\n\tstruct cal_data_per_freq *data_def = pRawDataSet;\n\tstruct cal_data_per_freq_4k *data_4k = pRawDataSet;\n\tstruct cal_data_per_freq_ar9287 *data_9287 = pRawDataSet;\n\tbool eeprom_4k = AR_SREV_9285(ah) || AR_SREV_9271(ah);\n\tint intercepts;\n\n\tif (AR_SREV_9287(ah))\n\t\tintercepts = AR9287_PD_GAIN_ICEPTS;\n\telse\n\t\tintercepts = AR5416_PD_GAIN_ICEPTS;\n\n\tmemset(&minPwrT4, 0, AR5416_NUM_PD_GAINS);\n\tath9k_hw_get_channel_centers(ah, chan, &centers);\n\n\tfor (numPiers = 0; numPiers < availPiers; numPiers++) {\n\t\tif (bChans[numPiers] == AR5416_BCHAN_UNUSED)\n\t\t\tbreak;\n\t}\n\n\tmatch = ath9k_hw_get_lower_upper_index((u8)FREQ2FBIN(centers.synth_center,\n\t\t\t\t\t\t\t     IS_CHAN_2GHZ(chan)),\n\t\t\t\t\t       bChans, numPiers, &idxL, &idxR);\n\n\tif (match) {\n\t\tif (AR_SREV_9287(ah)) {\n\t\t\tfor (i = 0; i < numXpdGains; i++) {\n\t\t\t\tminPwrT4[i] = data_9287[idxL].pwrPdg[i][0];\n\t\t\t\tmaxPwrT4[i] = data_9287[idxL].pwrPdg[i][intercepts - 1];\n\t\t\t\tath9k_hw_fill_vpd_table(minPwrT4[i], maxPwrT4[i],\n\t\t\t\t\t\tdata_9287[idxL].pwrPdg[i],\n\t\t\t\t\t\tdata_9287[idxL].vpdPdg[i],\n\t\t\t\t\t\tintercepts,\n\t\t\t\t\t\tvpdTableI[i]);\n\t\t\t}\n\t\t} else if (eeprom_4k) {\n\t\t\tfor (i = 0; i < numXpdGains; i++) {\n\t\t\t\tminPwrT4[i] = data_4k[idxL].pwrPdg[i][0];\n\t\t\t\tmaxPwrT4[i] = data_4k[idxL].pwrPdg[i][intercepts - 1];\n\t\t\t\tath9k_hw_fill_vpd_table(minPwrT4[i], maxPwrT4[i],\n\t\t\t\t\t\tdata_4k[idxL].pwrPdg[i],\n\t\t\t\t\t\tdata_4k[idxL].vpdPdg[i],\n\t\t\t\t\t\tintercepts,\n\t\t\t\t\t\tvpdTableI[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0; i < numXpdGains; i++) {\n\t\t\t\tminPwrT4[i] = data_def[idxL].pwrPdg[i][0];\n\t\t\t\tmaxPwrT4[i] = data_def[idxL].pwrPdg[i][intercepts - 1];\n\t\t\t\tath9k_hw_fill_vpd_table(minPwrT4[i], maxPwrT4[i],\n\t\t\t\t\t\tdata_def[idxL].pwrPdg[i],\n\t\t\t\t\t\tdata_def[idxL].vpdPdg[i],\n\t\t\t\t\t\tintercepts,\n\t\t\t\t\t\tvpdTableI[i]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < numXpdGains; i++) {\n\t\t\tif (AR_SREV_9287(ah)) {\n\t\t\t\tpVpdL = data_9287[idxL].vpdPdg[i];\n\t\t\t\tpPwrL = data_9287[idxL].pwrPdg[i];\n\t\t\t\tpVpdR = data_9287[idxR].vpdPdg[i];\n\t\t\t\tpPwrR = data_9287[idxR].pwrPdg[i];\n\t\t\t} else if (eeprom_4k) {\n\t\t\t\tpVpdL = data_4k[idxL].vpdPdg[i];\n\t\t\t\tpPwrL = data_4k[idxL].pwrPdg[i];\n\t\t\t\tpVpdR = data_4k[idxR].vpdPdg[i];\n\t\t\t\tpPwrR = data_4k[idxR].pwrPdg[i];\n\t\t\t} else {\n\t\t\t\tpVpdL = data_def[idxL].vpdPdg[i];\n\t\t\t\tpPwrL = data_def[idxL].pwrPdg[i];\n\t\t\t\tpVpdR = data_def[idxR].vpdPdg[i];\n\t\t\t\tpPwrR = data_def[idxR].pwrPdg[i];\n\t\t\t}\n\n\t\t\tminPwrT4[i] = max(pPwrL[0], pPwrR[0]);\n\n\t\t\tmaxPwrT4[i] =\n\t\t\t\tmin(pPwrL[intercepts - 1],\n\t\t\t\t    pPwrR[intercepts - 1]);\n\n\n\t\t\tath9k_hw_fill_vpd_table(minPwrT4[i], maxPwrT4[i],\n\t\t\t\t\t\tpPwrL, pVpdL,\n\t\t\t\t\t\tintercepts,\n\t\t\t\t\t\tvpdTableL[i]);\n\t\t\tath9k_hw_fill_vpd_table(minPwrT4[i], maxPwrT4[i],\n\t\t\t\t\t\tpPwrR, pVpdR,\n\t\t\t\t\t\tintercepts,\n\t\t\t\t\t\tvpdTableR[i]);\n\n\t\t\tfor (j = 0; j <= (maxPwrT4[i] - minPwrT4[i]) / 2; j++) {\n\t\t\t\tvpdTableI[i][j] =\n\t\t\t\t\t(u8)(ath9k_hw_interpolate((u16)\n\t\t\t\t\t     FREQ2FBIN(centers.\n\t\t\t\t\t\t       synth_center,\n\t\t\t\t\t\t       IS_CHAN_2GHZ\n\t\t\t\t\t\t       (chan)),\n\t\t\t\t\t     bChans[idxL], bChans[idxR],\n\t\t\t\t\t     vpdTableL[i][j], vpdTableR[i][j]));\n\t\t\t}\n\t\t}\n\t}\n\n\tk = 0;\n\n\tfor (i = 0; i < numXpdGains; i++) {\n\t\tif (i == (numXpdGains - 1))\n\t\t\tpPdGainBoundaries[i] =\n\t\t\t\t(u16)(maxPwrT4[i] / 2);\n\t\telse\n\t\t\tpPdGainBoundaries[i] =\n\t\t\t\t(u16)((maxPwrT4[i] + minPwrT4[i + 1]) / 4);\n\n\t\tpPdGainBoundaries[i] =\n\t\t\tmin((u16)MAX_RATE_POWER, pPdGainBoundaries[i]);\n\n\t\tminDelta = 0;\n\n\t\tif (i == 0) {\n\t\t\tif (AR_SREV_9280_20_OR_LATER(ah))\n\t\t\t\tss = (int16_t)(0 - (minPwrT4[i] / 2));\n\t\t\telse\n\t\t\t\tss = 0;\n\t\t} else {\n\t\t\tss = (int16_t)((pPdGainBoundaries[i - 1] -\n\t\t\t\t\t(minPwrT4[i] / 2)) -\n\t\t\t\t       tPdGainOverlap + 1 + minDelta);\n\t\t}\n\t\tvpdStep = (int16_t)(vpdTableI[i][1] - vpdTableI[i][0]);\n\t\tvpdStep = (int16_t)((vpdStep < 1) ? 1 : vpdStep);\n\n\t\twhile ((ss < 0) && (k < (AR5416_NUM_PDADC_VALUES - 1))) {\n\t\t\ttmpVal = (int16_t)(vpdTableI[i][0] + ss * vpdStep);\n\t\t\tpPDADCValues[k++] = (u8)((tmpVal < 0) ? 0 : tmpVal);\n\t\t\tss++;\n\t\t}\n\n\t\tsizeCurrVpdTable = (u8) ((maxPwrT4[i] - minPwrT4[i]) / 2 + 1);\n\t\ttgtIndex = (u8)(pPdGainBoundaries[i] + tPdGainOverlap -\n\t\t\t\t(minPwrT4[i] / 2));\n\t\tmaxIndex = (tgtIndex < sizeCurrVpdTable) ?\n\t\t\ttgtIndex : sizeCurrVpdTable;\n\n\t\twhile ((ss < maxIndex) && (k < (AR5416_NUM_PDADC_VALUES - 1))) {\n\t\t\tpPDADCValues[k++] = vpdTableI[i][ss++];\n\t\t}\n\n\t\tvpdStep = (int16_t)(vpdTableI[i][sizeCurrVpdTable - 1] -\n\t\t\t\t    vpdTableI[i][sizeCurrVpdTable - 2]);\n\t\tvpdStep = (int16_t)((vpdStep < 1) ? 1 : vpdStep);\n\n\t\tif (tgtIndex >= maxIndex) {\n\t\t\twhile ((ss <= tgtIndex) &&\n\t\t\t       (k < (AR5416_NUM_PDADC_VALUES - 1))) {\n\t\t\t\ttmpVal = (int16_t)((vpdTableI[i][sizeCurrVpdTable - 1] +\n\t\t\t\t\t\t    (ss - maxIndex + 1) * vpdStep));\n\t\t\t\tpPDADCValues[k++] = (u8)((tmpVal > 255) ?\n\t\t\t\t\t\t\t 255 : tmpVal);\n\t\t\t\tss++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (eeprom_4k)\n\t\tpdgain_boundary_default = 58;\n\telse\n\t\tpdgain_boundary_default = pPdGainBoundaries[i - 1];\n\n\twhile (i < AR5416_PD_GAINS_IN_MASK) {\n\t\tpPdGainBoundaries[i] = pdgain_boundary_default;\n\t\ti++;\n\t}\n\n\twhile (k < AR5416_NUM_PDADC_VALUES) {\n\t\tpPDADCValues[k] = pPDADCValues[k - 1];\n\t\tk++;\n\t}\n}\n\nint ath9k_hw_eeprom_init(struct ath_hw *ah)\n{\n\tif (AR_SREV_9300_20_OR_LATER(ah))\n\t\tah->eep_ops = &eep_ar9300_ops;\n\telse if (AR_SREV_9287(ah)) {\n\t\tah->eep_ops = &eep_ar9287_ops;\n\t} else if (AR_SREV_9285(ah) || AR_SREV_9271(ah)) {\n\t\tah->eep_ops = &eep_4k_ops;\n\t} else {\n\t\tah->eep_ops = &eep_def_ops;\n\t}\n\n\tif (!ah->eep_ops->fill_eeprom(ah))\n\t\treturn -EIO;\n\n\treturn ah->eep_ops->check_eeprom(ah);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}