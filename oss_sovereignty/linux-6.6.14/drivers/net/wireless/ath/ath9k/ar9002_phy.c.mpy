{
  "module_name": "ar9002_phy.c",
  "hash_id": "2cccd0c19586699428f6da48d8279fc1eca5430f1817b4225429c3c3c487f5da",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath9k/ar9002_phy.c",
  "human_readable_source": " \n\n \n\n#include \"hw.h\"\n#include \"ar9002_phy.h\"\n\n \nstatic int ar9002_hw_set_channel(struct ath_hw *ah, struct ath9k_channel *chan)\n{\n\tu16 bMode, fracMode, aModeRefSel = 0;\n\tu32 freq, ndiv, channelSel = 0, channelFrac = 0, reg32 = 0;\n\tstruct chan_centers centers;\n\tu32 refDivA = 24;\n\n\tath9k_hw_get_channel_centers(ah, chan, &centers);\n\tfreq = centers.synth_center;\n\n\treg32 = REG_READ(ah, AR_PHY_SYNTH_CONTROL);\n\treg32 &= 0xc0000000;\n\n\tif (freq < 4800) {  \n\t\tu32 txctl;\n\t\tint regWrites = 0;\n\n\t\tbMode = 1;\n\t\tfracMode = 1;\n\t\taModeRefSel = 0;\n\t\tchannelSel = CHANSEL_2G(freq);\n\n\t\tif (AR_SREV_9287_11_OR_LATER(ah)) {\n\t\t\tif (freq == 2484) {\n\t\t\t\t \n\t\t\t\tREG_WRITE_ARRAY(&ah->iniCckfirJapan2484,\n\t\t\t\t\t\t1, regWrites);\n\t\t\t} else {\n\t\t\t\tREG_WRITE_ARRAY(&ah->iniCckfirNormal,\n\t\t\t\t\t\t1, regWrites);\n\t\t\t}\n\t\t} else {\n\t\t\ttxctl = REG_READ(ah, AR_PHY_CCK_TX_CTRL);\n\t\t\tif (freq == 2484) {\n\t\t\t\t \n\t\t\t\tREG_WRITE(ah, AR_PHY_CCK_TX_CTRL,\n\t\t\t\t\t  txctl | AR_PHY_CCK_TX_CTRL_JAPAN);\n\t\t\t} else {\n\t\t\t\tREG_WRITE(ah, AR_PHY_CCK_TX_CTRL,\n\t\t\t\t\t  txctl & ~AR_PHY_CCK_TX_CTRL_JAPAN);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tbMode = 0;\n\t\tfracMode = 0;\n\n\t\tswitch (ah->eep_ops->get_eeprom(ah, EEP_FRAC_N_5G)) {\n\t\tcase 0:\n\t\t\tif (IS_CHAN_HALF_RATE(chan) || IS_CHAN_QUARTER_RATE(chan))\n\t\t\t\taModeRefSel = 0;\n\t\t\telse if ((freq % 20) == 0)\n\t\t\t\taModeRefSel = 3;\n\t\t\telse if ((freq % 10) == 0)\n\t\t\t\taModeRefSel = 2;\n\t\t\tif (aModeRefSel)\n\t\t\t\tbreak;\n\t\t\tfallthrough;\n\t\tcase 1:\n\t\tdefault:\n\t\t\taModeRefSel = 0;\n\t\t\t \n\t\t\tfracMode = 1;\n\t\t\trefDivA = 1;\n\t\t\tchannelSel = CHANSEL_5G(freq);\n\n\t\t\t \n\t\t\tath9k_hw_analog_shift_rmw(ah, AR_AN_SYNTH9,\n\t\t\t\t      AR_AN_SYNTH9_REFDIVA,\n\t\t\t\t      AR_AN_SYNTH9_REFDIVA_S, refDivA);\n\n\t\t}\n\n\t\tif (!fracMode) {\n\t\t\tndiv = (freq * (refDivA >> aModeRefSel)) / 60;\n\t\t\tchannelSel = ndiv & 0x1ff;\n\t\t\tchannelFrac = (ndiv & 0xfffffe00) * 2;\n\t\t\tchannelSel = (channelSel << 17) | channelFrac;\n\t\t}\n\t}\n\n\treg32 = reg32 |\n\t    (bMode << 29) |\n\t    (fracMode << 28) | (aModeRefSel << 26) | (channelSel);\n\n\tREG_WRITE(ah, AR_PHY_SYNTH_CONTROL, reg32);\n\n\tah->curchan = chan;\n\n\treturn 0;\n}\n\n \nstatic void ar9002_hw_spur_mitigate(struct ath_hw *ah,\n\t\t\t\t    struct ath9k_channel *chan)\n{\n\tint bb_spur = AR_NO_SPUR;\n\tint freq;\n\tint bin;\n\tint bb_spur_off, spur_subchannel_sd;\n\tint spur_freq_sd;\n\tint spur_delta_phase;\n\tint denominator;\n\tint tmp, newVal;\n\tint i;\n\tstruct chan_centers centers;\n\n\tint cur_bb_spur;\n\tbool is2GHz = IS_CHAN_2GHZ(chan);\n\n\tath9k_hw_get_channel_centers(ah, chan, &centers);\n\tfreq = centers.synth_center;\n\n\tfor (i = 0; i < AR_EEPROM_MODAL_SPURS; i++) {\n\t\tcur_bb_spur = ah->eep_ops->get_spur_channel(ah, i, is2GHz);\n\n\t\tif (AR_NO_SPUR == cur_bb_spur)\n\t\t\tbreak;\n\n\t\tif (is2GHz)\n\t\t\tcur_bb_spur = (cur_bb_spur / 10) + AR_BASE_FREQ_2GHZ;\n\t\telse\n\t\t\tcur_bb_spur = (cur_bb_spur / 10) + AR_BASE_FREQ_5GHZ;\n\n\t\tcur_bb_spur = cur_bb_spur - freq;\n\n\t\tif (IS_CHAN_HT40(chan)) {\n\t\t\tif ((cur_bb_spur > -AR_SPUR_FEEQ_BOUND_HT40) &&\n\t\t\t    (cur_bb_spur < AR_SPUR_FEEQ_BOUND_HT40)) {\n\t\t\t\tbb_spur = cur_bb_spur;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if ((cur_bb_spur > -AR_SPUR_FEEQ_BOUND_HT20) &&\n\t\t\t   (cur_bb_spur < AR_SPUR_FEEQ_BOUND_HT20)) {\n\t\t\tbb_spur = cur_bb_spur;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (AR_NO_SPUR == bb_spur) {\n\t\tREG_CLR_BIT(ah, AR_PHY_FORCE_CLKEN_CCK,\n\t\t\t    AR_PHY_FORCE_CLKEN_CCK_MRC_MUX);\n\t\treturn;\n\t} else {\n\t\tREG_CLR_BIT(ah, AR_PHY_FORCE_CLKEN_CCK,\n\t\t\t    AR_PHY_FORCE_CLKEN_CCK_MRC_MUX);\n\t}\n\n\tbin = bb_spur * 320;\n\n\ttmp = REG_READ(ah, AR_PHY_TIMING_CTRL4(0));\n\n\tENABLE_REGWRITE_BUFFER(ah);\n\n\tnewVal = tmp | (AR_PHY_TIMING_CTRL4_ENABLE_SPUR_RSSI |\n\t\t\tAR_PHY_TIMING_CTRL4_ENABLE_SPUR_FILTER |\n\t\t\tAR_PHY_TIMING_CTRL4_ENABLE_CHAN_MASK |\n\t\t\tAR_PHY_TIMING_CTRL4_ENABLE_PILOT_MASK);\n\tREG_WRITE(ah, AR_PHY_TIMING_CTRL4(0), newVal);\n\n\tnewVal = (AR_PHY_SPUR_REG_MASK_RATE_CNTL |\n\t\t  AR_PHY_SPUR_REG_ENABLE_MASK_PPM |\n\t\t  AR_PHY_SPUR_REG_MASK_RATE_SELECT |\n\t\t  AR_PHY_SPUR_REG_ENABLE_VIT_SPUR_RSSI |\n\t\t  SM(SPUR_RSSI_THRESH, AR_PHY_SPUR_REG_SPUR_RSSI_THRESH));\n\tREG_WRITE(ah, AR_PHY_SPUR_REG, newVal);\n\n\tif (IS_CHAN_HT40(chan)) {\n\t\tif (bb_spur < 0) {\n\t\t\tspur_subchannel_sd = 1;\n\t\t\tbb_spur_off = bb_spur + 10;\n\t\t} else {\n\t\t\tspur_subchannel_sd = 0;\n\t\t\tbb_spur_off = bb_spur - 10;\n\t\t}\n\t} else {\n\t\tspur_subchannel_sd = 0;\n\t\tbb_spur_off = bb_spur;\n\t}\n\n\tif (IS_CHAN_HT40(chan))\n\t\tspur_delta_phase =\n\t\t\t((bb_spur * 262144) /\n\t\t\t 10) & AR_PHY_TIMING11_SPUR_DELTA_PHASE;\n\telse\n\t\tspur_delta_phase =\n\t\t\t((bb_spur * 524288) /\n\t\t\t 10) & AR_PHY_TIMING11_SPUR_DELTA_PHASE;\n\n\tdenominator = IS_CHAN_2GHZ(chan) ? 44 : 40;\n\tspur_freq_sd = ((bb_spur_off * 2048) / denominator) & 0x3ff;\n\n\tnewVal = (AR_PHY_TIMING11_USE_SPUR_IN_AGC |\n\t\t  SM(spur_freq_sd, AR_PHY_TIMING11_SPUR_FREQ_SD) |\n\t\t  SM(spur_delta_phase, AR_PHY_TIMING11_SPUR_DELTA_PHASE));\n\tREG_WRITE(ah, AR_PHY_TIMING11, newVal);\n\n\tnewVal = spur_subchannel_sd << AR_PHY_SFCORR_SPUR_SUBCHNL_SD_S;\n\tREG_WRITE(ah, AR_PHY_SFCORR_EXT, newVal);\n\n\tar5008_hw_cmn_spur_mitigate(ah, chan, bin);\n\n\tREGWRITE_BUFFER_FLUSH(ah);\n}\n\nstatic void ar9002_olc_init(struct ath_hw *ah)\n{\n\tu32 i;\n\n\tif (!OLC_FOR_AR9280_20_LATER(ah))\n\t\treturn;\n\n\tif (OLC_FOR_AR9287_10_LATER(ah)) {\n\t\tREG_SET_BIT(ah, AR_PHY_TX_PWRCTRL9,\n\t\t\t\tAR_PHY_TX_PWRCTRL9_RES_DC_REMOVAL);\n\t\tath9k_hw_analog_shift_rmw(ah, AR9287_AN_TXPC0,\n\t\t\t\tAR9287_AN_TXPC0_TXPCMODE,\n\t\t\t\tAR9287_AN_TXPC0_TXPCMODE_S,\n\t\t\t\tAR9287_AN_TXPC0_TXPCMODE_TEMPSENSE);\n\t\tudelay(100);\n\t} else {\n\t\tfor (i = 0; i < AR9280_TX_GAIN_TABLE_SIZE; i++)\n\t\t\tah->originalGain[i] =\n\t\t\t\tMS(REG_READ(ah, AR_PHY_TX_GAIN_TBL1 + i * 4),\n\t\t\t\t\t\tAR_PHY_TX_GAIN);\n\t\tah->PDADCdelta = 0;\n\t}\n}\n\nstatic u32 ar9002_hw_compute_pll_control(struct ath_hw *ah,\n\t\t\t\t\t struct ath9k_channel *chan)\n{\n\tint ref_div = 5;\n\tint pll_div = 0x2c;\n\tu32 pll;\n\n\tif (chan && IS_CHAN_5GHZ(chan) && !IS_CHAN_A_FAST_CLOCK(ah, chan)) {\n\t\tif (AR_SREV_9280_20(ah)) {\n\t\t\tref_div = 10;\n\t\t\tpll_div = 0x50;\n\t\t} else {\n\t\t\tpll_div = 0x28;\n\t\t}\n\t}\n\n\tpll = SM(ref_div, AR_RTC_9160_PLL_REFDIV);\n\tpll |= SM(pll_div, AR_RTC_9160_PLL_DIV);\n\n\tif (chan && IS_CHAN_HALF_RATE(chan))\n\t\tpll |= SM(0x1, AR_RTC_9160_PLL_CLKSEL);\n\telse if (chan && IS_CHAN_QUARTER_RATE(chan))\n\t\tpll |= SM(0x2, AR_RTC_9160_PLL_CLKSEL);\n\n\treturn pll;\n}\n\nstatic void ar9002_hw_do_getnf(struct ath_hw *ah,\n\t\t\t      int16_t nfarray[NUM_NF_READINGS])\n{\n\tint16_t nf;\n\n\tnf = MS(REG_READ(ah, AR_PHY_CCA), AR9280_PHY_MINCCA_PWR);\n\tnfarray[0] = sign_extend32(nf, 8);\n\n\tnf = MS(REG_READ(ah, AR_PHY_EXT_CCA), AR9280_PHY_EXT_MINCCA_PWR);\n\tif (IS_CHAN_HT40(ah->curchan))\n\t\tnfarray[3] = sign_extend32(nf, 8);\n\n\tif (!(ah->rxchainmask & BIT(1)))\n\t\treturn;\n\n\tnf = MS(REG_READ(ah, AR_PHY_CH1_CCA), AR9280_PHY_CH1_MINCCA_PWR);\n\tnfarray[1] = sign_extend32(nf, 8);\n\n\tnf = MS(REG_READ(ah, AR_PHY_CH1_EXT_CCA), AR9280_PHY_CH1_EXT_MINCCA_PWR);\n\tif (IS_CHAN_HT40(ah->curchan))\n\t\tnfarray[4] = sign_extend32(nf, 8);\n}\n\nstatic void ar9002_hw_set_nf_limits(struct ath_hw *ah)\n{\n\tif (AR_SREV_9285(ah)) {\n\t\tah->nf_2g.max = AR_PHY_CCA_MAX_GOOD_VAL_9285_2GHZ;\n\t\tah->nf_2g.min = AR_PHY_CCA_MIN_GOOD_VAL_9285_2GHZ;\n\t\tah->nf_2g.nominal = AR_PHY_CCA_NOM_VAL_9285_2GHZ;\n\t} else if (AR_SREV_9287(ah)) {\n\t\tah->nf_2g.max = AR_PHY_CCA_MAX_GOOD_VAL_9287_2GHZ;\n\t\tah->nf_2g.min = AR_PHY_CCA_MIN_GOOD_VAL_9287_2GHZ;\n\t\tah->nf_2g.nominal = AR_PHY_CCA_NOM_VAL_9287_2GHZ;\n\t} else if (AR_SREV_9271(ah)) {\n\t\tah->nf_2g.max = AR_PHY_CCA_MAX_GOOD_VAL_9271_2GHZ;\n\t\tah->nf_2g.min = AR_PHY_CCA_MIN_GOOD_VAL_9271_2GHZ;\n\t\tah->nf_2g.nominal = AR_PHY_CCA_NOM_VAL_9271_2GHZ;\n\t} else {\n\t\tah->nf_2g.max = AR_PHY_CCA_MAX_GOOD_VAL_9280_2GHZ;\n\t\tah->nf_2g.min = AR_PHY_CCA_MIN_GOOD_VAL_9280_2GHZ;\n\t\tah->nf_2g.nominal = AR_PHY_CCA_NOM_VAL_9280_2GHZ;\n\t\tah->nf_5g.max = AR_PHY_CCA_MAX_GOOD_VAL_9280_5GHZ;\n\t\tah->nf_5g.min = AR_PHY_CCA_MIN_GOOD_VAL_9280_5GHZ;\n\t\tah->nf_5g.nominal = AR_PHY_CCA_NOM_VAL_9280_5GHZ;\n\t}\n}\n\nstatic void ar9002_hw_antdiv_comb_conf_get(struct ath_hw *ah,\n\t\t\t\t   struct ath_hw_antcomb_conf *antconf)\n{\n\tu32 regval;\n\n\tregval = REG_READ(ah, AR_PHY_MULTICHAIN_GAIN_CTL);\n\tantconf->main_lna_conf = (regval & AR_PHY_9285_ANT_DIV_MAIN_LNACONF) >>\n\t\t\t\t  AR_PHY_9285_ANT_DIV_MAIN_LNACONF_S;\n\tantconf->alt_lna_conf = (regval & AR_PHY_9285_ANT_DIV_ALT_LNACONF) >>\n\t\t\t\t AR_PHY_9285_ANT_DIV_ALT_LNACONF_S;\n\tantconf->fast_div_bias = (regval & AR_PHY_9285_FAST_DIV_BIAS) >>\n\t\t\t\t  AR_PHY_9285_FAST_DIV_BIAS_S;\n\tantconf->lna1_lna2_switch_delta = -1;\n\tantconf->lna1_lna2_delta = -3;\n\tantconf->div_group = 0;\n}\n\nstatic void ar9002_hw_antdiv_comb_conf_set(struct ath_hw *ah,\n\t\t\t\t   struct ath_hw_antcomb_conf *antconf)\n{\n\tu32 regval;\n\n\tregval = REG_READ(ah, AR_PHY_MULTICHAIN_GAIN_CTL);\n\tregval &= ~(AR_PHY_9285_ANT_DIV_MAIN_LNACONF |\n\t\t    AR_PHY_9285_ANT_DIV_ALT_LNACONF |\n\t\t    AR_PHY_9285_FAST_DIV_BIAS);\n\tregval |= ((antconf->main_lna_conf << AR_PHY_9285_ANT_DIV_MAIN_LNACONF_S)\n\t\t   & AR_PHY_9285_ANT_DIV_MAIN_LNACONF);\n\tregval |= ((antconf->alt_lna_conf << AR_PHY_9285_ANT_DIV_ALT_LNACONF_S)\n\t\t   & AR_PHY_9285_ANT_DIV_ALT_LNACONF);\n\tregval |= ((antconf->fast_div_bias << AR_PHY_9285_FAST_DIV_BIAS_S)\n\t\t   & AR_PHY_9285_FAST_DIV_BIAS);\n\n\tREG_WRITE(ah, AR_PHY_MULTICHAIN_GAIN_CTL, regval);\n}\n\n#ifdef CONFIG_ATH9K_BTCOEX_SUPPORT\n\nstatic void ar9002_hw_set_bt_ant_diversity(struct ath_hw *ah, bool enable)\n{\n\tstruct ath_btcoex_hw *btcoex = &ah->btcoex_hw;\n\tu8 antdiv_ctrl1, antdiv_ctrl2;\n\tu32 regval;\n\n\tif (enable) {\n\t\tantdiv_ctrl1 = ATH_BT_COEX_ANTDIV_CONTROL1_ENABLE;\n\t\tantdiv_ctrl2 = ATH_BT_COEX_ANTDIV_CONTROL2_ENABLE;\n\n\t\t \n\t\tbtcoex->bt_coex_mode2 &= (~(AR_BT_DISABLE_BT_ANT));\n\t\tREG_WRITE(ah, AR_BT_COEX_MODE2, btcoex->bt_coex_mode2);\n\n\t\tREG_WRITE(ah, AR_PHY_SWITCH_COM, ATH_BT_COEX_ANT_DIV_SWITCH_COM);\n\t\tREG_RMW(ah, AR_PHY_SWITCH_CHAIN_0, 0, 0xf0000000);\n\t} else {\n\t\t \n\t\tantdiv_ctrl1 = ATH_BT_COEX_ANTDIV_CONTROL1_FIXED_A;\n\t\tantdiv_ctrl2 = ATH_BT_COEX_ANTDIV_CONTROL2_FIXED_A;\n\n\t\t \n\t\tbtcoex->bt_coex_mode2 |= AR_BT_DISABLE_BT_ANT;\n\t\tREG_WRITE(ah, AR_BT_COEX_MODE2, btcoex->bt_coex_mode2);\n\n\t\t \n\t\tREG_WRITE(ah, AR_PHY_SWITCH_COM, 0);\n\t\tREG_RMW(ah, AR_PHY_SWITCH_CHAIN_0, 0, 0xf0000000);\n\t}\n\n\tregval = REG_READ(ah, AR_PHY_MULTICHAIN_GAIN_CTL);\n\tregval &= (~(AR_PHY_9285_ANT_DIV_CTL_ALL));\n         \n\tregval &= (~(AR_PHY_9285_FAST_DIV_BIAS));\n\tregval |= SM(antdiv_ctrl1, AR_PHY_9285_ANT_DIV_CTL);\n\tregval |= SM(antdiv_ctrl2, AR_PHY_9285_ANT_DIV_ALT_LNACONF);\n\tregval |= SM((antdiv_ctrl2 >> 2), AR_PHY_9285_ANT_DIV_MAIN_LNACONF);\n\tregval |= SM((antdiv_ctrl1 >> 1), AR_PHY_9285_ANT_DIV_ALT_GAINTB);\n\tregval |= SM((antdiv_ctrl1 >> 2), AR_PHY_9285_ANT_DIV_MAIN_GAINTB);\n\tREG_WRITE(ah, AR_PHY_MULTICHAIN_GAIN_CTL, regval);\n\n\tregval = REG_READ(ah, AR_PHY_CCK_DETECT);\n\tregval &= (~AR_PHY_CCK_DETECT_BB_ENABLE_ANT_FAST_DIV);\n\tregval |= SM((antdiv_ctrl1 >> 3), AR_PHY_CCK_DETECT_BB_ENABLE_ANT_FAST_DIV);\n\tREG_WRITE(ah, AR_PHY_CCK_DETECT, regval);\n}\n\n#endif\n\nstatic void ar9002_hw_spectral_scan_config(struct ath_hw *ah,\n\t\t\t\t    struct ath_spec_scan *param)\n{\n\tu32 repeat_bit;\n\tu8 count;\n\n\tif (!param->enabled) {\n\t\tREG_CLR_BIT(ah, AR_PHY_SPECTRAL_SCAN,\n\t\t\t    AR_PHY_SPECTRAL_SCAN_ENABLE);\n\t\treturn;\n\t}\n\tREG_SET_BIT(ah, AR_PHY_RADAR_0, AR_PHY_RADAR_0_FFT_ENA);\n\tREG_SET_BIT(ah, AR_PHY_SPECTRAL_SCAN, AR_PHY_SPECTRAL_SCAN_ENABLE);\n\n\tif (AR_SREV_9280(ah))\n\t\trepeat_bit = AR_PHY_SPECTRAL_SCAN_SHORT_REPEAT;\n\telse\n\t\trepeat_bit = AR_PHY_SPECTRAL_SCAN_SHORT_REPEAT_KIWI;\n\n\tif (param->short_repeat)\n\t\tREG_SET_BIT(ah, AR_PHY_SPECTRAL_SCAN, repeat_bit);\n\telse\n\t\tREG_CLR_BIT(ah, AR_PHY_SPECTRAL_SCAN, repeat_bit);\n\n\t \n\tcount = param->count;\n\tif (param->endless) {\n\t\tif (AR_SREV_9280(ah))\n\t\t\tcount = 0x80;\n\t\telse\n\t\t\tcount = 0;\n\t} else if (count & 0x80)\n\t\tcount = 0x7f;\n\telse if (!count)\n\t\tcount = 1;\n\n\tif (AR_SREV_9280(ah)) {\n\t\tREG_RMW_FIELD(ah, AR_PHY_SPECTRAL_SCAN,\n\t\t\t      AR_PHY_SPECTRAL_SCAN_COUNT, count);\n\t} else {\n\t\tREG_RMW_FIELD(ah, AR_PHY_SPECTRAL_SCAN,\n\t\t\t      AR_PHY_SPECTRAL_SCAN_COUNT_KIWI, count);\n\t\tREG_SET_BIT(ah, AR_PHY_SPECTRAL_SCAN,\n\t\t\t    AR_PHY_SPECTRAL_SCAN_PHYERR_MASK_SELECT);\n\t}\n\n\tREG_RMW_FIELD(ah, AR_PHY_SPECTRAL_SCAN,\n\t\t      AR_PHY_SPECTRAL_SCAN_PERIOD, param->period);\n\tREG_RMW_FIELD(ah, AR_PHY_SPECTRAL_SCAN,\n\t\t      AR_PHY_SPECTRAL_SCAN_FFT_PERIOD, param->fft_period);\n\n\treturn;\n}\n\nstatic void ar9002_hw_spectral_scan_trigger(struct ath_hw *ah)\n{\n\tREG_SET_BIT(ah, AR_PHY_SPECTRAL_SCAN, AR_PHY_SPECTRAL_SCAN_ENABLE);\n\t \n\tREG_SET_BIT(ah, AR_PHY_SPECTRAL_SCAN,\n\t\t    AR_PHY_SPECTRAL_SCAN_ACTIVE);\n}\n\nstatic void ar9002_hw_spectral_scan_wait(struct ath_hw *ah)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\n\t \n\tif (!ath9k_hw_wait(ah, AR_PHY_SPECTRAL_SCAN,\n\t\t\t   AR_PHY_SPECTRAL_SCAN_ACTIVE,\n\t\t\t   0, AH_WAIT_TIMEOUT)) {\n\t\tath_err(common, \"spectral scan wait failed\\n\");\n\t\treturn;\n\t}\n}\n\nstatic void ar9002_hw_tx99_start(struct ath_hw *ah, u32 qnum)\n{\n\tREG_SET_BIT(ah, 0x9864, 0x7f000);\n\tREG_SET_BIT(ah, 0x9924, 0x7f00fe);\n\tREG_CLR_BIT(ah, AR_DIAG_SW, AR_DIAG_RX_DIS);\n\tREG_WRITE(ah, AR_CR, AR_CR_RXD);\n\tREG_WRITE(ah, AR_DLCL_IFS(qnum), 0);\n\tREG_WRITE(ah, AR_D_GBL_IFS_SIFS, 20);\n\tREG_WRITE(ah, AR_D_GBL_IFS_EIFS, 20);\n\tREG_WRITE(ah, AR_D_FPCTL, 0x10|qnum);\n\tREG_WRITE(ah, AR_TIME_OUT, 0x00000400);\n\tREG_WRITE(ah, AR_DRETRY_LIMIT(qnum), 0xffffffff);\n\tREG_SET_BIT(ah, AR_QMISC(qnum), AR_Q_MISC_DCU_EARLY_TERM_REQ);\n}\n\nstatic void ar9002_hw_tx99_stop(struct ath_hw *ah)\n{\n\tREG_SET_BIT(ah, AR_DIAG_SW, AR_DIAG_RX_DIS);\n}\n\nvoid ar9002_hw_attach_phy_ops(struct ath_hw *ah)\n{\n\tstruct ath_hw_private_ops *priv_ops = ath9k_hw_private_ops(ah);\n\tstruct ath_hw_ops *ops = ath9k_hw_ops(ah);\n\n\tpriv_ops->set_rf_regs = NULL;\n\tpriv_ops->rf_set_freq = ar9002_hw_set_channel;\n\tpriv_ops->spur_mitigate_freq = ar9002_hw_spur_mitigate;\n\tpriv_ops->olc_init = ar9002_olc_init;\n\tpriv_ops->compute_pll_control = ar9002_hw_compute_pll_control;\n\tpriv_ops->do_getnf = ar9002_hw_do_getnf;\n\n\tops->antdiv_comb_conf_get = ar9002_hw_antdiv_comb_conf_get;\n\tops->antdiv_comb_conf_set = ar9002_hw_antdiv_comb_conf_set;\n\tops->spectral_scan_config = ar9002_hw_spectral_scan_config;\n\tops->spectral_scan_trigger = ar9002_hw_spectral_scan_trigger;\n\tops->spectral_scan_wait = ar9002_hw_spectral_scan_wait;\n\n#ifdef CONFIG_ATH9K_BTCOEX_SUPPORT\n\tops->set_bt_ant_diversity = ar9002_hw_set_bt_ant_diversity;\n#endif\n\tops->tx99_start = ar9002_hw_tx99_start;\n\tops->tx99_stop = ar9002_hw_tx99_stop;\n\n\tar9002_hw_set_nf_limits(ah);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}