{
  "module_name": "ar9003_aic.c",
  "hash_id": "8c2c978584f7a10040b81d317ee39b155e1c32ff29dbfc9c7d7fa31ab3739d77",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath9k/ar9003_aic.c",
  "human_readable_source": " \n\n#include \"hw.h\"\n#include \"hw-ops.h\"\n#include \"ar9003_mci.h\"\n#include \"ar9003_aic.h\"\n#include \"ar9003_phy.h\"\n#include \"reg_aic.h\"\n\nstatic const u8 com_att_db_table[ATH_AIC_MAX_COM_ATT_DB_TABLE] = {\n\t0, 3, 9, 15, 21, 27\n};\n\nstatic const u16 aic_lin_table[ATH_AIC_MAX_AIC_LIN_TABLE] = {\n\t8191, 7300, 6506, 5799, 5168, 4606, 4105, 3659,\n\t3261, 2906, 2590, 2309, 2057, 1834, 1634, 1457,\n\t1298, 1157, 1031, 919,\t819,  730,  651,  580,\n\t517,  461,  411,  366,\t326,  291,  259,  231,\n\t206,  183,  163,  146,\t130,  116,  103,  92,\n\t82,   73,   65,\t  58,\t52,   46,   41,\t  37,\n\t33,   29,   26,\t  23,\t21,   18,   16,\t  15,\n\t13,   12,   10,\t  9,\t8,    7,    7,\t  6,\n\t5,    5,    4,\t  4,\t3\n};\n\nstatic bool ar9003_hw_is_aic_enabled(struct ath_hw *ah)\n{\n\tstruct ath9k_hw_mci *mci_hw = &ah->btcoex_hw.mci;\n\n\t \n\treturn false;\n\n\tif (mci_hw->config & ATH_MCI_CONFIG_DISABLE_AIC)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int16_t ar9003_aic_find_valid(bool *cal_sram_valid,\n\t\t\t\t     bool dir, u8 index)\n{\n\tint16_t i;\n\n\tif (dir) {\n\t\tfor (i = index + 1; i < ATH_AIC_MAX_BT_CHANNEL; i++) {\n\t\t\tif (cal_sram_valid[i])\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tfor (i = index - 1; i >= 0; i--) {\n\t\t\tif (cal_sram_valid[i])\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ((i >= ATH_AIC_MAX_BT_CHANNEL) || (i < 0))\n\t\ti = -1;\n\n\treturn i;\n}\n\n \nstatic int16_t ar9003_aic_find_index(u8 type, int16_t value)\n{\n\tint16_t i = -1;\n\n\tif (type == 0) {\n\t\tfor (i = ATH_AIC_MAX_AIC_LIN_TABLE - 1; i >= 0; i--) {\n\t\t\tif (aic_lin_table[i] >= value)\n\t\t\t\tbreak;\n\t\t}\n\t} else if (type == 1) {\n\t\tfor (i = 0; i < ATH_AIC_MAX_COM_ATT_DB_TABLE; i++) {\n\t\t\tif (com_att_db_table[i] > value) {\n\t\t\t\ti--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (i >= ATH_AIC_MAX_COM_ATT_DB_TABLE)\n\t\t\ti = -1;\n\t}\n\n\treturn i;\n}\n\nstatic void ar9003_aic_gain_table(struct ath_hw *ah)\n{\n\tu32 aic_atten_word[19], i;\n\n\t \n\tREG_WRITE(ah, AR_PHY_BT_COEX_4, 0x2c200a00);\n\tREG_WRITE(ah, AR_PHY_BT_COEX_5, 0x5c4e4438);\n\n\t \n\taic_atten_word[0] = (0x1 & 0xf) << 14 | (0x1f & 0x1f) << 9 | (0x0 & 0xf) << 5 |\n\t\t(0x1f & 0x1f);  \n\taic_atten_word[1] = (0x3 & 0xf) << 14 | (0x1f & 0x1f) << 9 | (0x2 & 0xf) << 5 |\n\t\t(0x1f & 0x1f);  \n\taic_atten_word[2] = (0x5 & 0xf) << 14 | (0x1f & 0x1f) << 9 | (0x4 & 0xf) << 5 |\n\t\t(0x1f & 0x1f);  \n\taic_atten_word[3] = (0x1 & 0xf) << 14 | (0x1e & 0x1f) << 9 | (0x0 & 0xf) << 5 |\n\t\t(0x1e & 0x1f);  \n\taic_atten_word[4] = (0x3 & 0xf) << 14 | (0x1e & 0x1f) << 9 | (0x2 & 0xf) << 5 |\n\t\t(0x1e & 0x1f);  \n\taic_atten_word[5] = (0x5 & 0xf) << 14 | (0x1e & 0x1f) << 9 | (0x4 & 0xf) << 5 |\n\t\t(0x1e & 0x1f);  \n\taic_atten_word[6] = (0x1 & 0xf) << 14 | (0xf & 0x1f) << 9  | (0x0 & 0xf) << 5 |\n\t\t(0xf & 0x1f);   \n\taic_atten_word[7] = (0x3 & 0xf) << 14 | (0xf & 0x1f) << 9  | (0x2 & 0xf) << 5 |\n\t\t(0xf & 0x1f);   \n\taic_atten_word[8] = (0x5 & 0xf) << 14 | (0xf & 0x1f) << 9  | (0x4 & 0xf) << 5 |\n\t\t(0xf & 0x1f);   \n\taic_atten_word[9] = (0x1 & 0xf) << 14 | (0x7 & 0x1f) << 9  | (0x0 & 0xf) << 5 |\n\t\t(0x7 & 0x1f);   \n\taic_atten_word[10] = (0x3 & 0xf) << 14 | (0x7 & 0x1f) << 9  | (0x2 & 0xf) << 5 |\n\t\t(0x7 & 0x1f);   \n\taic_atten_word[11] = (0x5 & 0xf) << 14 | (0x7 & 0x1f) << 9  | (0x4 & 0xf) << 5 |\n\t\t(0x7 & 0x1f);   \n\taic_atten_word[12] = (0x7 & 0xf) << 14 | (0x7 & 0x1f) << 9  | (0x6 & 0xf) << 5 |\n\t\t(0x7 & 0x1f);   \n\taic_atten_word[13] = (0x3 & 0xf) << 14 | (0x3 & 0x1f) << 9  | (0x2 & 0xf) << 5 |\n\t\t(0x3 & 0x1f);   \n\taic_atten_word[14] = (0x5 & 0xf) << 14 | (0x3 & 0x1f) << 9  | (0x4 & 0xf) << 5 |\n\t\t(0x3 & 0x1f);   \n\taic_atten_word[15] = (0x1 & 0xf) << 14 | (0x1 & 0x1f) << 9  | (0x0 & 0xf) << 5 |\n\t\t(0x1 & 0x1f);   \n\taic_atten_word[16] = (0x3 & 0xf) << 14 | (0x1 & 0x1f) << 9  | (0x2 & 0xf) << 5 |\n\t\t(0x1 & 0x1f);   \n\taic_atten_word[17] = (0x5 & 0xf) << 14 | (0x1 & 0x1f) << 9  | (0x4 & 0xf) << 5 |\n\t\t(0x1 & 0x1f);   \n\taic_atten_word[18] = (0x7 & 0xf) << 14 | (0x1 & 0x1f) << 9  | (0x6 & 0xf) << 5 |\n\t\t(0x1 & 0x1f);   \n\n\t \n\tREG_WRITE(ah, (AR_PHY_AIC_SRAM_ADDR_B0 + 0x3000),\n\t\t  (ATH_AIC_SRAM_AUTO_INCREMENT |\n\t\t   ATH_AIC_SRAM_GAIN_TABLE_OFFSET));\n\n\tfor (i = 0; i < 19; i++) {\n\t\tREG_WRITE(ah, (AR_PHY_AIC_SRAM_DATA_B0 + 0x3000),\n\t\t\t  aic_atten_word[i]);\n\t}\n}\n\nstatic u8 ar9003_aic_cal_start(struct ath_hw *ah, u8 min_valid_count)\n{\n\tstruct ath9k_hw_aic *aic = &ah->btcoex_hw.aic;\n\tint i;\n\n\t \n\tREG_WRITE(ah, (AR_PHY_AIC_SRAM_ADDR_B0 + 0x3000),\n\t\t  (ATH_AIC_SRAM_AUTO_INCREMENT |\n\t\t   ATH_AIC_SRAM_CAL_OFFSET));\n\n\tfor (i = 0; i < ATH_AIC_MAX_BT_CHANNEL; i++) {\n\t\tREG_WRITE(ah, (AR_PHY_AIC_SRAM_DATA_B0 + 0x3000), 0);\n\t\taic->aic_sram[i] = 0;\n\t}\n\n\tREG_WRITE(ah, AR_PHY_AIC_CTRL_0_B0,\n\t\t  (SM(0, AR_PHY_AIC_MON_ENABLE) |\n\t\t   SM(127, AR_PHY_AIC_CAL_MAX_HOP_COUNT) |\n\t\t   SM(min_valid_count, AR_PHY_AIC_CAL_MIN_VALID_COUNT) |\n\t\t   SM(37, AR_PHY_AIC_F_WLAN) |\n\t\t   SM(1, AR_PHY_AIC_CAL_CH_VALID_RESET) |\n\t\t   SM(0, AR_PHY_AIC_CAL_ENABLE) |\n\t\t   SM(0x40, AR_PHY_AIC_BTTX_PWR_THR) |\n\t\t   SM(0, AR_PHY_AIC_ENABLE)));\n\n\tREG_WRITE(ah, AR_PHY_AIC_CTRL_0_B1,\n\t\t  (SM(0, AR_PHY_AIC_MON_ENABLE) |\n\t\t   SM(1, AR_PHY_AIC_CAL_CH_VALID_RESET) |\n\t\t   SM(0, AR_PHY_AIC_CAL_ENABLE) |\n\t\t   SM(0x40, AR_PHY_AIC_BTTX_PWR_THR) |\n\t\t   SM(0, AR_PHY_AIC_ENABLE)));\n\n\tREG_WRITE(ah, AR_PHY_AIC_CTRL_1_B0,\n\t\t  (SM(8, AR_PHY_AIC_CAL_BT_REF_DELAY) |\n\t\t   SM(0, AR_PHY_AIC_BT_IDLE_CFG) |\n\t\t   SM(1, AR_PHY_AIC_STDBY_COND) |\n\t\t   SM(37, AR_PHY_AIC_STDBY_ROT_ATT_DB) |\n\t\t   SM(5, AR_PHY_AIC_STDBY_COM_ATT_DB) |\n\t\t   SM(15, AR_PHY_AIC_RSSI_MAX) |\n\t\t   SM(0, AR_PHY_AIC_RSSI_MIN)));\n\n\tREG_WRITE(ah, AR_PHY_AIC_CTRL_1_B1,\n\t\t  (SM(15, AR_PHY_AIC_RSSI_MAX) |\n\t\t   SM(0, AR_PHY_AIC_RSSI_MIN)));\n\n\tREG_WRITE(ah, AR_PHY_AIC_CTRL_2_B0,\n\t\t  (SM(44, AR_PHY_AIC_RADIO_DELAY) |\n\t\t   SM(8, AR_PHY_AIC_CAL_STEP_SIZE_CORR) |\n\t\t   SM(12, AR_PHY_AIC_CAL_ROT_IDX_CORR) |\n\t\t   SM(2, AR_PHY_AIC_CAL_CONV_CHECK_FACTOR) |\n\t\t   SM(5, AR_PHY_AIC_ROT_IDX_COUNT_MAX) |\n\t\t   SM(0, AR_PHY_AIC_CAL_SYNTH_TOGGLE) |\n\t\t   SM(0, AR_PHY_AIC_CAL_SYNTH_AFTER_BTRX) |\n\t\t   SM(200, AR_PHY_AIC_CAL_SYNTH_SETTLING)));\n\n\tREG_WRITE(ah, AR_PHY_AIC_CTRL_3_B0,\n\t\t  (SM(2, AR_PHY_AIC_MON_MAX_HOP_COUNT) |\n\t\t   SM(1, AR_PHY_AIC_MON_MIN_STALE_COUNT) |\n\t\t   SM(1, AR_PHY_AIC_MON_PWR_EST_LONG) |\n\t\t   SM(2, AR_PHY_AIC_MON_PD_TALLY_SCALING) |\n\t\t   SM(10, AR_PHY_AIC_MON_PERF_THR) |\n\t\t   SM(2, AR_PHY_AIC_CAL_TARGET_MAG_SETTING) |\n\t\t   SM(1, AR_PHY_AIC_CAL_PERF_CHECK_FACTOR) |\n\t\t   SM(1, AR_PHY_AIC_CAL_PWR_EST_LONG)));\n\n\tREG_WRITE(ah, AR_PHY_AIC_CTRL_4_B0,\n\t\t  (SM(2, AR_PHY_AIC_CAL_ROT_ATT_DB_EST_ISO) |\n\t\t   SM(3, AR_PHY_AIC_CAL_COM_ATT_DB_EST_ISO) |\n\t\t   SM(0, AR_PHY_AIC_CAL_ISO_EST_INIT_SETTING) |\n\t\t   SM(2, AR_PHY_AIC_CAL_COM_ATT_DB_BACKOFF) |\n\t\t   SM(1, AR_PHY_AIC_CAL_COM_ATT_DB_FIXED)));\n\n\tREG_WRITE(ah, AR_PHY_AIC_CTRL_4_B1,\n\t\t  (SM(2, AR_PHY_AIC_CAL_ROT_ATT_DB_EST_ISO) |\n\t\t   SM(3, AR_PHY_AIC_CAL_COM_ATT_DB_EST_ISO) |\n\t\t   SM(0, AR_PHY_AIC_CAL_ISO_EST_INIT_SETTING) |\n\t\t   SM(2, AR_PHY_AIC_CAL_COM_ATT_DB_BACKOFF) |\n\t\t   SM(1, AR_PHY_AIC_CAL_COM_ATT_DB_FIXED)));\n\n\tar9003_aic_gain_table(ah);\n\n\t \n\tREG_WRITE(ah, ATH_AIC_BT_JUPITER_CTRL,\n\t\t  (REG_READ(ah, ATH_AIC_BT_JUPITER_CTRL) |\n\t\t   ATH_AIC_BT_AIC_ENABLE));\n\n\taic->aic_cal_start_time = REG_READ(ah, AR_TSF_L32);\n\n\t \n\tREG_CLR_BIT(ah, AR_PHY_AIC_CTRL_0_B1, AR_PHY_AIC_CAL_ENABLE);\n\tREG_SET_BIT(ah, AR_PHY_AIC_CTRL_0_B1, AR_PHY_AIC_CAL_CH_VALID_RESET);\n\tREG_SET_BIT(ah, AR_PHY_AIC_CTRL_0_B1, AR_PHY_AIC_CAL_ENABLE);\n\n\taic->aic_caled_chan = 0;\n\taic->aic_cal_state = AIC_CAL_STATE_STARTED;\n\n\treturn aic->aic_cal_state;\n}\n\nstatic bool ar9003_aic_cal_post_process(struct ath_hw *ah)\n{\n\tstruct ath9k_hw_aic *aic = &ah->btcoex_hw.aic;\n\tbool cal_sram_valid[ATH_AIC_MAX_BT_CHANNEL];\n\tstruct ath_aic_out_info aic_sram[ATH_AIC_MAX_BT_CHANNEL];\n\tu32 dir_path_gain_idx, quad_path_gain_idx, value;\n\tu32 fixed_com_att_db;\n\tint8_t dir_path_sign, quad_path_sign;\n\tint16_t i;\n\tbool ret = true;\n\n\tmemset(&cal_sram_valid, 0, sizeof(cal_sram_valid));\n\tmemset(&aic_sram, 0, sizeof(aic_sram));\n\n\tfor (i = 0; i < ATH_AIC_MAX_BT_CHANNEL; i++) {\n\t\tstruct ath_aic_sram_info sram;\n\t\tvalue = aic->aic_sram[i];\n\n\t\tcal_sram_valid[i] = sram.valid =\n\t\t\tMS(value, AR_PHY_AIC_SRAM_VALID);\n\t\tsram.rot_quad_att_db =\n\t\t\tMS(value, AR_PHY_AIC_SRAM_ROT_QUAD_ATT_DB);\n\t\tsram.vga_quad_sign =\n\t\t\tMS(value, AR_PHY_AIC_SRAM_VGA_QUAD_SIGN);\n\t\tsram.rot_dir_att_db =\n\t\t\tMS(value, AR_PHY_AIC_SRAM_ROT_DIR_ATT_DB);\n\t\tsram.vga_dir_sign =\n\t\t\tMS(value, AR_PHY_AIC_SRAM_VGA_DIR_SIGN);\n\t\tsram.com_att_6db =\n\t\t\tMS(value, AR_PHY_AIC_SRAM_COM_ATT_6DB);\n\n\t\tif (sram.valid) {\n\t\t\tdir_path_gain_idx = sram.rot_dir_att_db +\n\t\t\t\tcom_att_db_table[sram.com_att_6db];\n\t\t\tquad_path_gain_idx = sram.rot_quad_att_db +\n\t\t\t\tcom_att_db_table[sram.com_att_6db];\n\n\t\t\tdir_path_sign = (sram.vga_dir_sign) ? 1 : -1;\n\t\t\tquad_path_sign = (sram.vga_quad_sign) ? 1 : -1;\n\n\t\t\taic_sram[i].dir_path_gain_lin = dir_path_sign *\n\t\t\t\taic_lin_table[dir_path_gain_idx];\n\t\t\taic_sram[i].quad_path_gain_lin = quad_path_sign *\n\t\t\t\taic_lin_table[quad_path_gain_idx];\n\t\t}\n\t}\n\n\tfor (i = 0; i < ATH_AIC_MAX_BT_CHANNEL; i++) {\n\t\tint16_t start_idx, end_idx;\n\n\t\tif (cal_sram_valid[i])\n\t\t\tcontinue;\n\n\t\tstart_idx = ar9003_aic_find_valid(cal_sram_valid, 0, i);\n\t\tend_idx = ar9003_aic_find_valid(cal_sram_valid, 1, i);\n\n\t\tif (start_idx < 0) {\n\t\t\t \n\t\t\tstart_idx = end_idx;\n\t\t\tend_idx = ar9003_aic_find_valid(cal_sram_valid, 1, start_idx);\n\n\t\t\tif (end_idx < 0) {\n\t\t\t\tret = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\taic_sram[i].dir_path_gain_lin =\n\t\t\t\t((aic_sram[start_idx].dir_path_gain_lin -\n\t\t\t\t  aic_sram[end_idx].dir_path_gain_lin) *\n\t\t\t\t (start_idx - i) + ((end_idx - i) >> 1)) /\n\t\t\t\t(end_idx - i) +\n\t\t\t\taic_sram[start_idx].dir_path_gain_lin;\n\t\t\taic_sram[i].quad_path_gain_lin =\n\t\t\t\t((aic_sram[start_idx].quad_path_gain_lin -\n\t\t\t\t  aic_sram[end_idx].quad_path_gain_lin) *\n\t\t\t\t (start_idx - i) + ((end_idx - i) >> 1)) /\n\t\t\t\t(end_idx - i) +\n\t\t\t\taic_sram[start_idx].quad_path_gain_lin;\n\t\t}\n\n\t\tif (end_idx < 0) {\n\t\t\t \n\t\t\tend_idx = ar9003_aic_find_valid(cal_sram_valid, 0, start_idx);\n\n\t\t\tif (end_idx < 0) {\n\t\t\t\tret = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\taic_sram[i].dir_path_gain_lin =\n\t\t\t\t((aic_sram[start_idx].dir_path_gain_lin -\n\t\t\t\t  aic_sram[end_idx].dir_path_gain_lin) *\n\t\t\t\t (i - start_idx) + ((start_idx - end_idx) >> 1)) /\n\t\t\t\t(start_idx - end_idx) +\n\t\t\t\taic_sram[start_idx].dir_path_gain_lin;\n\t\t\taic_sram[i].quad_path_gain_lin =\n\t\t\t\t((aic_sram[start_idx].quad_path_gain_lin -\n\t\t\t\t  aic_sram[end_idx].quad_path_gain_lin) *\n\t\t\t\t (i - start_idx) + ((start_idx - end_idx) >> 1)) /\n\t\t\t\t(start_idx - end_idx) +\n\t\t\t\taic_sram[start_idx].quad_path_gain_lin;\n\n\t\t} else if (start_idx >= 0){\n\t\t\t \n\t\t\taic_sram[i].dir_path_gain_lin =\n\t\t\t\t(((end_idx - i) * aic_sram[start_idx].dir_path_gain_lin) +\n\t\t\t\t ((i - start_idx) * aic_sram[end_idx].dir_path_gain_lin) +\n\t\t\t\t ((end_idx - start_idx) >> 1)) /\n\t\t\t\t(end_idx - start_idx);\n\t\t\taic_sram[i].quad_path_gain_lin =\n\t\t\t\t(((end_idx - i) * aic_sram[start_idx].quad_path_gain_lin) +\n\t\t\t\t ((i - start_idx) * aic_sram[end_idx].quad_path_gain_lin) +\n\t\t\t\t ((end_idx - start_idx) >> 1))/\n\t\t\t\t(end_idx - start_idx);\n\t\t}\n\t}\n\n\t \n\ti = ar9003_aic_find_valid(cal_sram_valid, 1, 0);\n\tif (i < 0) {\n\t\ti = 0;\n\t\tret = false;\n\t}\n\tfixed_com_att_db = com_att_db_table[MS(aic->aic_sram[i],\n\t\t\t\t\t    AR_PHY_AIC_SRAM_COM_ATT_6DB)];\n\n\tfor (i = 0; i < ATH_AIC_MAX_BT_CHANNEL; i++) {\n\t\tint16_t rot_dir_path_att_db, rot_quad_path_att_db;\n\t\tstruct ath_aic_sram_info sram;\n\n\t\tsram.vga_dir_sign =\n\t\t\t(aic_sram[i].dir_path_gain_lin >= 0) ? 1 : 0;\n\t\tsram.vga_quad_sign =\n\t\t\t(aic_sram[i].quad_path_gain_lin >= 0) ? 1 : 0;\n\n\t\trot_dir_path_att_db =\n\t\t\tar9003_aic_find_index(0, abs(aic_sram[i].dir_path_gain_lin)) -\n\t\t\tfixed_com_att_db;\n\t\trot_quad_path_att_db =\n\t\t\tar9003_aic_find_index(0, abs(aic_sram[i].quad_path_gain_lin)) -\n\t\t\tfixed_com_att_db;\n\n\t\tsram.com_att_6db =\n\t\t\tar9003_aic_find_index(1, fixed_com_att_db);\n\n\t\tsram.valid = true;\n\n\t\tsram.rot_dir_att_db =\n\t\t\tmin(max(rot_dir_path_att_db,\n\t\t\t\t(int16_t)ATH_AIC_MIN_ROT_DIR_ATT_DB),\n\t\t\t    ATH_AIC_MAX_ROT_DIR_ATT_DB);\n\t\tsram.rot_quad_att_db =\n\t\t\tmin(max(rot_quad_path_att_db,\n\t\t\t\t(int16_t)ATH_AIC_MIN_ROT_QUAD_ATT_DB),\n\t\t\t    ATH_AIC_MAX_ROT_QUAD_ATT_DB);\n\n\t\taic->aic_sram[i] = (SM(sram.vga_dir_sign,\n\t\t\t\t       AR_PHY_AIC_SRAM_VGA_DIR_SIGN) |\n\t\t\t\t    SM(sram.vga_quad_sign,\n\t\t\t\t       AR_PHY_AIC_SRAM_VGA_QUAD_SIGN) |\n\t\t\t\t    SM(sram.com_att_6db,\n\t\t\t\t       AR_PHY_AIC_SRAM_COM_ATT_6DB) |\n\t\t\t\t    SM(sram.valid,\n\t\t\t\t       AR_PHY_AIC_SRAM_VALID) |\n\t\t\t\t    SM(sram.rot_dir_att_db,\n\t\t\t\t       AR_PHY_AIC_SRAM_ROT_DIR_ATT_DB) |\n\t\t\t\t    SM(sram.rot_quad_att_db,\n\t\t\t\t       AR_PHY_AIC_SRAM_ROT_QUAD_ATT_DB));\n\t}\n\n\treturn ret;\n}\n\nstatic void ar9003_aic_cal_done(struct ath_hw *ah)\n{\n\tstruct ath9k_hw_aic *aic = &ah->btcoex_hw.aic;\n\n\t \n\tREG_WRITE(ah, ATH_AIC_BT_JUPITER_CTRL,\n\t\t  (REG_READ(ah, ATH_AIC_BT_JUPITER_CTRL) &\n\t\t   ~ATH_AIC_BT_AIC_ENABLE));\n\n\tif (ar9003_aic_cal_post_process(ah))\n\t\taic->aic_cal_state = AIC_CAL_STATE_DONE;\n\telse\n\t\taic->aic_cal_state = AIC_CAL_STATE_ERROR;\n}\n\nstatic u8 ar9003_aic_cal_continue(struct ath_hw *ah, bool cal_once)\n{\n\tstruct ath_common *common = ath9k_hw_common(ah);\n\tstruct ath9k_hw_mci *mci_hw = &ah->btcoex_hw.mci;\n\tstruct ath9k_hw_aic *aic = &ah->btcoex_hw.aic;\n\tint i, num_chan;\n\n\tnum_chan = MS(mci_hw->config, ATH_MCI_CONFIG_AIC_CAL_NUM_CHAN);\n\n\tif (!num_chan) {\n\t\taic->aic_cal_state = AIC_CAL_STATE_ERROR;\n\t\treturn aic->aic_cal_state;\n\t}\n\n\tif (cal_once) {\n\t\tfor (i = 0; i < 10000; i++) {\n\t\t\tif ((REG_READ(ah, AR_PHY_AIC_CTRL_0_B1) &\n\t\t\t     AR_PHY_AIC_CAL_ENABLE) == 0)\n\t\t\t\tbreak;\n\n\t\t\tudelay(100);\n\t\t}\n\t}\n\n\t \n\tif ((REG_READ(ah, AR_PHY_AIC_CTRL_0_B1) &\n\t     AR_PHY_AIC_CAL_ENABLE) != 0) {\n\t\tath_dbg(common, MCI, \"AIC cal is not done after 40ms\");\n\t\tgoto exit;\n\t}\n\n\tREG_WRITE(ah, AR_PHY_AIC_SRAM_ADDR_B1,\n\t\t  (ATH_AIC_SRAM_CAL_OFFSET | ATH_AIC_SRAM_AUTO_INCREMENT));\n\n\tfor (i = 0; i < ATH_AIC_MAX_BT_CHANNEL; i++) {\n\t\tu32 value;\n\n\t\tvalue = REG_READ(ah, AR_PHY_AIC_SRAM_DATA_B1);\n\n\t\tif (value & 0x01) {\n\t\t\tif (aic->aic_sram[i] == 0)\n\t\t\t\taic->aic_caled_chan++;\n\n\t\t\taic->aic_sram[i] = value;\n\n\t\t\tif (!cal_once)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ((aic->aic_caled_chan >= num_chan) || cal_once) {\n\t\tar9003_aic_cal_done(ah);\n\t} else {\n\t\t \n\t\tREG_CLR_BIT(ah, AR_PHY_AIC_CTRL_0_B1, AR_PHY_AIC_CAL_ENABLE);\n\t\tREG_SET_BIT(ah, AR_PHY_AIC_CTRL_0_B1,\n\t\t\t    AR_PHY_AIC_CAL_CH_VALID_RESET);\n\t\tREG_SET_BIT(ah, AR_PHY_AIC_CTRL_0_B1, AR_PHY_AIC_CAL_ENABLE);\n\t}\nexit:\n\treturn aic->aic_cal_state;\n\n}\n\nu8 ar9003_aic_calibration(struct ath_hw *ah)\n{\n\tstruct ath9k_hw_aic *aic = &ah->btcoex_hw.aic;\n\tu8 cal_ret = AIC_CAL_STATE_ERROR;\n\n\tswitch (aic->aic_cal_state) {\n\tcase AIC_CAL_STATE_IDLE:\n\t\tcal_ret = ar9003_aic_cal_start(ah, 1);\n\t\tbreak;\n\tcase AIC_CAL_STATE_STARTED:\n\t\tcal_ret = ar9003_aic_cal_continue(ah, false);\n\t\tbreak;\n\tcase AIC_CAL_STATE_DONE:\n\t\tcal_ret = AIC_CAL_STATE_DONE;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn cal_ret;\n}\n\nu8 ar9003_aic_start_normal(struct ath_hw *ah)\n{\n\tstruct ath9k_hw_aic *aic = &ah->btcoex_hw.aic;\n\tint16_t i;\n\n\tif (aic->aic_cal_state != AIC_CAL_STATE_DONE)\n\t\treturn 1;\n\n\tar9003_aic_gain_table(ah);\n\n\tREG_WRITE(ah, AR_PHY_AIC_SRAM_ADDR_B1, ATH_AIC_SRAM_AUTO_INCREMENT);\n\n\tfor (i = 0; i < ATH_AIC_MAX_BT_CHANNEL; i++) {\n\t\tREG_WRITE(ah, AR_PHY_AIC_SRAM_DATA_B1, aic->aic_sram[i]);\n\t}\n\n\t \n\tREG_WRITE(ah, 0xa6b0, 0x80);\n\tREG_WRITE(ah, 0xa6b4, 0x5b2df0);\n\tREG_WRITE(ah, 0xa6b8, 0x10762cc8);\n\tREG_WRITE(ah, 0xa6bc, 0x1219a4b);\n\tREG_WRITE(ah, 0xa6c0, 0x1e01);\n\tREG_WRITE(ah, 0xb6b4, 0xf0);\n\tREG_WRITE(ah, 0xb6c0, 0x1e01);\n\tREG_WRITE(ah, 0xb6b0, 0x81);\n\tREG_WRITE(ah, AR_PHY_65NM_CH1_RXTX4, 0x40000000);\n\n\taic->aic_enabled = true;\n\n\treturn 0;\n}\n\nu8 ar9003_aic_cal_reset(struct ath_hw *ah)\n{\n\tstruct ath9k_hw_aic *aic = &ah->btcoex_hw.aic;\n\n\taic->aic_cal_state = AIC_CAL_STATE_IDLE;\n\treturn aic->aic_cal_state;\n}\n\nu8 ar9003_aic_calibration_single(struct ath_hw *ah)\n{\n\tstruct ath9k_hw_mci *mci_hw = &ah->btcoex_hw.mci;\n\tu8 cal_ret;\n\tint num_chan;\n\n\tnum_chan = MS(mci_hw->config, ATH_MCI_CONFIG_AIC_CAL_NUM_CHAN);\n\n\t(void) ar9003_aic_cal_start(ah, num_chan);\n\tcal_ret = ar9003_aic_cal_continue(ah, true);\n\n\treturn cal_ret;\n}\n\nvoid ar9003_hw_attach_aic_ops(struct ath_hw *ah)\n{\n\tstruct ath_hw_private_ops *priv_ops = ath9k_hw_private_ops(ah);\n\n\tpriv_ops->is_aic_enabled = ar9003_hw_is_aic_enabled;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}