{
  "module_name": "dp_tx.c",
  "hash_id": "134abc3deffaf5492fb386c34162abdf242e4323836cf7277bd4affd02772495",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath12k/dp_tx.c",
  "human_readable_source": "\n \n\n#include \"core.h\"\n#include \"dp_tx.h\"\n#include \"debug.h\"\n#include \"hw.h\"\n\nstatic enum hal_tcl_encap_type\nath12k_dp_tx_get_encap_type(struct ath12k_vif *arvif, struct sk_buff *skb)\n{\n\tstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);\n\tstruct ath12k_base *ab = arvif->ar->ab;\n\n\tif (test_bit(ATH12K_FLAG_RAW_MODE, &ab->dev_flags))\n\t\treturn HAL_TCL_ENCAP_TYPE_RAW;\n\n\tif (tx_info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP)\n\t\treturn HAL_TCL_ENCAP_TYPE_ETHERNET;\n\n\treturn HAL_TCL_ENCAP_TYPE_NATIVE_WIFI;\n}\n\nstatic void ath12k_dp_tx_encap_nwifi(struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\tu8 *qos_ctl;\n\n\tif (!ieee80211_is_data_qos(hdr->frame_control))\n\t\treturn;\n\n\tqos_ctl = ieee80211_get_qos_ctl(hdr);\n\tmemmove(skb->data + IEEE80211_QOS_CTL_LEN,\n\t\tskb->data, (void *)qos_ctl - (void *)skb->data);\n\tskb_pull(skb, IEEE80211_QOS_CTL_LEN);\n\n\thdr = (void *)skb->data;\n\thdr->frame_control &= ~__cpu_to_le16(IEEE80211_STYPE_QOS_DATA);\n}\n\nstatic u8 ath12k_dp_tx_get_tid(struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\tstruct ath12k_skb_cb *cb = ATH12K_SKB_CB(skb);\n\n\tif (cb->flags & ATH12K_SKB_HW_80211_ENCAP)\n\t\treturn skb->priority & IEEE80211_QOS_CTL_TID_MASK;\n\telse if (!ieee80211_is_data_qos(hdr->frame_control))\n\t\treturn HAL_DESC_REO_NON_QOS_TID;\n\telse\n\t\treturn skb->priority & IEEE80211_QOS_CTL_TID_MASK;\n}\n\nenum hal_encrypt_type ath12k_dp_tx_get_encrypt_type(u32 cipher)\n{\n\tswitch (cipher) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\treturn HAL_ENCRYPT_TYPE_WEP_40;\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\treturn HAL_ENCRYPT_TYPE_WEP_104;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\treturn HAL_ENCRYPT_TYPE_TKIP_MIC;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\treturn HAL_ENCRYPT_TYPE_CCMP_128;\n\tcase WLAN_CIPHER_SUITE_CCMP_256:\n\t\treturn HAL_ENCRYPT_TYPE_CCMP_256;\n\tcase WLAN_CIPHER_SUITE_GCMP:\n\t\treturn HAL_ENCRYPT_TYPE_GCMP_128;\n\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\treturn HAL_ENCRYPT_TYPE_AES_GCMP_256;\n\tdefault:\n\t\treturn HAL_ENCRYPT_TYPE_OPEN;\n\t}\n}\n\nstatic void ath12k_dp_tx_release_txbuf(struct ath12k_dp *dp,\n\t\t\t\t       struct ath12k_tx_desc_info *tx_desc,\n\t\t\t\t       u8 pool_id)\n{\n\tspin_lock_bh(&dp->tx_desc_lock[pool_id]);\n\tlist_move_tail(&tx_desc->list, &dp->tx_desc_free_list[pool_id]);\n\tspin_unlock_bh(&dp->tx_desc_lock[pool_id]);\n}\n\nstatic struct ath12k_tx_desc_info *ath12k_dp_tx_assign_buffer(struct ath12k_dp *dp,\n\t\t\t\t\t\t\t      u8 pool_id)\n{\n\tstruct ath12k_tx_desc_info *desc;\n\n\tspin_lock_bh(&dp->tx_desc_lock[pool_id]);\n\tdesc = list_first_entry_or_null(&dp->tx_desc_free_list[pool_id],\n\t\t\t\t\tstruct ath12k_tx_desc_info,\n\t\t\t\t\tlist);\n\tif (!desc) {\n\t\tspin_unlock_bh(&dp->tx_desc_lock[pool_id]);\n\t\tath12k_warn(dp->ab, \"failed to allocate data Tx buffer\\n\");\n\t\treturn NULL;\n\t}\n\n\tlist_move_tail(&desc->list, &dp->tx_desc_used_list[pool_id]);\n\tspin_unlock_bh(&dp->tx_desc_lock[pool_id]);\n\n\treturn desc;\n}\n\nstatic void ath12k_hal_tx_cmd_ext_desc_setup(struct ath12k_base *ab, void *cmd,\n\t\t\t\t\t     struct hal_tx_info *ti)\n{\n\tstruct hal_tx_msdu_ext_desc *tcl_ext_cmd = (struct hal_tx_msdu_ext_desc *)cmd;\n\n\ttcl_ext_cmd->info0 = le32_encode_bits(ti->paddr,\n\t\t\t\t\t      HAL_TX_MSDU_EXT_INFO0_BUF_PTR_LO);\n\ttcl_ext_cmd->info1 = le32_encode_bits(0x0,\n\t\t\t\t\t      HAL_TX_MSDU_EXT_INFO1_BUF_PTR_HI) |\n\t\t\t       le32_encode_bits(ti->data_len,\n\t\t\t\t\t\tHAL_TX_MSDU_EXT_INFO1_BUF_LEN);\n\n\ttcl_ext_cmd->info1 = le32_encode_bits(1, HAL_TX_MSDU_EXT_INFO1_EXTN_OVERRIDE) |\n\t\t\t\tle32_encode_bits(ti->encap_type,\n\t\t\t\t\t\t HAL_TX_MSDU_EXT_INFO1_ENCAP_TYPE) |\n\t\t\t\tle32_encode_bits(ti->encrypt_type,\n\t\t\t\t\t\t HAL_TX_MSDU_EXT_INFO1_ENCRYPT_TYPE);\n}\n\nint ath12k_dp_tx(struct ath12k *ar, struct ath12k_vif *arvif,\n\t\t struct sk_buff *skb)\n{\n\tstruct ath12k_base *ab = ar->ab;\n\tstruct ath12k_dp *dp = &ab->dp;\n\tstruct hal_tx_info ti = {0};\n\tstruct ath12k_tx_desc_info *tx_desc;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ath12k_skb_cb *skb_cb = ATH12K_SKB_CB(skb);\n\tstruct hal_tcl_data_cmd *hal_tcl_desc;\n\tstruct hal_tx_msdu_ext_desc *msg;\n\tstruct sk_buff *skb_ext_desc;\n\tstruct hal_srng *tcl_ring;\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\tstruct dp_tx_ring *tx_ring;\n\tu8 pool_id;\n\tu8 hal_ring_id;\n\tint ret;\n\tu8 ring_selector, ring_map = 0;\n\tbool tcl_ring_retry;\n\tbool msdu_ext_desc = false;\n\n\tif (test_bit(ATH12K_FLAG_CRASH_FLUSH, &ar->ab->dev_flags))\n\t\treturn -ESHUTDOWN;\n\n\tif (!(info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP) &&\n\t    !ieee80211_is_data(hdr->frame_control))\n\t\treturn -ENOTSUPP;\n\n\tpool_id = skb_get_queue_mapping(skb) & (ATH12K_HW_MAX_QUEUES - 1);\n\n\t \n\tring_selector = ab->hw_params->hw_ops->get_ring_selector(skb);\n\ntcl_ring_sel:\n\ttcl_ring_retry = false;\n\tti.ring_id = ring_selector % ab->hw_params->max_tx_ring;\n\n\tring_map |= BIT(ti.ring_id);\n\tti.rbm_id = ab->hw_params->hal_ops->tcl_to_wbm_rbm_map[ti.ring_id].rbm_id;\n\n\ttx_ring = &dp->tx_ring[ti.ring_id];\n\n\ttx_desc = ath12k_dp_tx_assign_buffer(dp, pool_id);\n\tif (!tx_desc)\n\t\treturn -ENOMEM;\n\n\tti.bank_id = arvif->bank_id;\n\tti.meta_data_flags = arvif->tcl_metadata;\n\n\tif (arvif->tx_encap_type == HAL_TCL_ENCAP_TYPE_RAW &&\n\t    test_bit(ATH12K_FLAG_HW_CRYPTO_DISABLED, &ar->ab->dev_flags)) {\n\t\tif (skb_cb->flags & ATH12K_SKB_CIPHER_SET) {\n\t\t\tti.encrypt_type =\n\t\t\t\tath12k_dp_tx_get_encrypt_type(skb_cb->cipher);\n\n\t\t\tif (ieee80211_has_protected(hdr->frame_control))\n\t\t\t\tskb_put(skb, IEEE80211_CCMP_MIC_LEN);\n\t\t} else {\n\t\t\tti.encrypt_type = HAL_ENCRYPT_TYPE_OPEN;\n\t\t}\n\n\t\tmsdu_ext_desc = true;\n\t}\n\n\tti.encap_type = ath12k_dp_tx_get_encap_type(arvif, skb);\n\tti.addr_search_flags = arvif->hal_addr_search_flags;\n\tti.search_type = arvif->search_type;\n\tti.type = HAL_TCL_DESC_TYPE_BUFFER;\n\tti.pkt_offset = 0;\n\tti.lmac_id = ar->lmac_id;\n\tti.vdev_id = arvif->vdev_id;\n\tti.bss_ast_hash = arvif->ast_hash;\n\tti.bss_ast_idx = arvif->ast_idx;\n\tti.dscp_tid_tbl_idx = 0;\n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL &&\n\t    ti.encap_type != HAL_TCL_ENCAP_TYPE_RAW) {\n\t\tti.flags0 |= u32_encode_bits(1, HAL_TCL_DATA_CMD_INFO2_IP4_CKSUM_EN) |\n\t\t\t     u32_encode_bits(1, HAL_TCL_DATA_CMD_INFO2_UDP4_CKSUM_EN) |\n\t\t\t     u32_encode_bits(1, HAL_TCL_DATA_CMD_INFO2_UDP6_CKSUM_EN) |\n\t\t\t     u32_encode_bits(1, HAL_TCL_DATA_CMD_INFO2_TCP4_CKSUM_EN) |\n\t\t\t     u32_encode_bits(1, HAL_TCL_DATA_CMD_INFO2_TCP6_CKSUM_EN);\n\t}\n\n\tti.flags1 |= u32_encode_bits(1, HAL_TCL_DATA_CMD_INFO3_TID_OVERWRITE);\n\n\tti.tid = ath12k_dp_tx_get_tid(skb);\n\n\tswitch (ti.encap_type) {\n\tcase HAL_TCL_ENCAP_TYPE_NATIVE_WIFI:\n\t\tath12k_dp_tx_encap_nwifi(skb);\n\t\tbreak;\n\tcase HAL_TCL_ENCAP_TYPE_RAW:\n\t\tif (!test_bit(ATH12K_FLAG_RAW_MODE, &ab->dev_flags)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto fail_remove_tx_buf;\n\t\t}\n\t\tbreak;\n\tcase HAL_TCL_ENCAP_TYPE_ETHERNET:\n\t\t \n\t\tbreak;\n\tcase HAL_TCL_ENCAP_TYPE_802_3:\n\tdefault:\n\t\t \n\t\tret = -EINVAL;\n\t\tatomic_inc(&ab->soc_stats.tx_err.misc_fail);\n\t\tgoto fail_remove_tx_buf;\n\t}\n\n\tti.paddr = dma_map_single(ab->dev, skb->data, skb->len, DMA_TO_DEVICE);\n\tif (dma_mapping_error(ab->dev, ti.paddr)) {\n\t\tatomic_inc(&ab->soc_stats.tx_err.misc_fail);\n\t\tath12k_warn(ab, \"failed to DMA map data Tx buffer\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto fail_remove_tx_buf;\n\t}\n\n\ttx_desc->skb = skb;\n\ttx_desc->mac_id = ar->pdev_idx;\n\tti.desc_id = tx_desc->desc_id;\n\tti.data_len = skb->len;\n\tskb_cb->paddr = ti.paddr;\n\tskb_cb->vif = arvif->vif;\n\tskb_cb->ar = ar;\n\n\tif (msdu_ext_desc) {\n\t\tskb_ext_desc = dev_alloc_skb(sizeof(struct hal_tx_msdu_ext_desc));\n\t\tif (!skb_ext_desc) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail_unmap_dma;\n\t\t}\n\n\t\tskb_put(skb_ext_desc, sizeof(struct hal_tx_msdu_ext_desc));\n\t\tmemset(skb_ext_desc->data, 0, skb_ext_desc->len);\n\n\t\tmsg = (struct hal_tx_msdu_ext_desc *)skb_ext_desc->data;\n\t\tath12k_hal_tx_cmd_ext_desc_setup(ab, msg, &ti);\n\n\t\tti.paddr = dma_map_single(ab->dev, skb_ext_desc->data,\n\t\t\t\t\t  skb_ext_desc->len, DMA_TO_DEVICE);\n\t\tret = dma_mapping_error(ab->dev, ti.paddr);\n\t\tif (ret) {\n\t\t\tkfree_skb(skb_ext_desc);\n\t\t\tgoto fail_unmap_dma;\n\t\t}\n\n\t\tti.data_len = skb_ext_desc->len;\n\t\tti.type = HAL_TCL_DESC_TYPE_EXT_DESC;\n\n\t\tskb_cb->paddr_ext_desc = ti.paddr;\n\t}\n\n\thal_ring_id = tx_ring->tcl_data_ring.ring_id;\n\ttcl_ring = &ab->hal.srng_list[hal_ring_id];\n\n\tspin_lock_bh(&tcl_ring->lock);\n\n\tath12k_hal_srng_access_begin(ab, tcl_ring);\n\n\thal_tcl_desc = ath12k_hal_srng_src_get_next_entry(ab, tcl_ring);\n\tif (!hal_tcl_desc) {\n\t\t \n\t\tath12k_hal_srng_access_end(ab, tcl_ring);\n\t\tab->soc_stats.tx_err.desc_na[ti.ring_id]++;\n\t\tspin_unlock_bh(&tcl_ring->lock);\n\t\tret = -ENOMEM;\n\n\t\t \n\t\tif (ring_map != (BIT(ab->hw_params->max_tx_ring) - 1) &&\n\t\t    ab->hw_params->tcl_ring_retry) {\n\t\t\ttcl_ring_retry = true;\n\t\t\tring_selector++;\n\t\t}\n\n\t\tgoto fail_unmap_dma;\n\t}\n\n\tath12k_hal_tx_cmd_desc_setup(ab, hal_tcl_desc, &ti);\n\n\tath12k_hal_srng_access_end(ab, tcl_ring);\n\n\tspin_unlock_bh(&tcl_ring->lock);\n\n\tath12k_dbg_dump(ab, ATH12K_DBG_DP_TX, NULL, \"dp tx msdu: \",\n\t\t\tskb->data, skb->len);\n\n\tatomic_inc(&ar->dp.num_tx_pending);\n\n\treturn 0;\n\nfail_unmap_dma:\n\tdma_unmap_single(ab->dev, ti.paddr, ti.data_len, DMA_TO_DEVICE);\n\n\tif (skb_cb->paddr_ext_desc)\n\t\tdma_unmap_single(ab->dev, skb_cb->paddr_ext_desc,\n\t\t\t\t sizeof(struct hal_tx_msdu_ext_desc),\n\t\t\t\t DMA_TO_DEVICE);\n\nfail_remove_tx_buf:\n\tath12k_dp_tx_release_txbuf(dp, tx_desc, pool_id);\n\tif (tcl_ring_retry)\n\t\tgoto tcl_ring_sel;\n\n\treturn ret;\n}\n\nstatic void ath12k_dp_tx_free_txbuf(struct ath12k_base *ab,\n\t\t\t\t    struct sk_buff *msdu, u8 mac_id,\n\t\t\t\t    struct dp_tx_ring *tx_ring)\n{\n\tstruct ath12k *ar;\n\tstruct ath12k_skb_cb *skb_cb;\n\tu8 pdev_id = ath12k_hw_mac_id_to_pdev_id(ab->hw_params, mac_id);\n\n\tskb_cb = ATH12K_SKB_CB(msdu);\n\n\tdma_unmap_single(ab->dev, skb_cb->paddr, msdu->len, DMA_TO_DEVICE);\n\tif (skb_cb->paddr_ext_desc)\n\t\tdma_unmap_single(ab->dev, skb_cb->paddr_ext_desc,\n\t\t\t\t sizeof(struct hal_tx_msdu_ext_desc), DMA_TO_DEVICE);\n\n\tdev_kfree_skb_any(msdu);\n\n\tar = ab->pdevs[pdev_id].ar;\n\tif (atomic_dec_and_test(&ar->dp.num_tx_pending))\n\t\twake_up(&ar->dp.tx_empty_waitq);\n}\n\nstatic void\nath12k_dp_tx_htt_tx_complete_buf(struct ath12k_base *ab,\n\t\t\t\t struct sk_buff *msdu,\n\t\t\t\t struct dp_tx_ring *tx_ring,\n\t\t\t\t struct ath12k_dp_htt_wbm_tx_status *ts)\n{\n\tstruct ieee80211_tx_info *info;\n\tstruct ath12k_skb_cb *skb_cb;\n\tstruct ath12k *ar;\n\n\tskb_cb = ATH12K_SKB_CB(msdu);\n\tinfo = IEEE80211_SKB_CB(msdu);\n\n\tar = skb_cb->ar;\n\n\tif (atomic_dec_and_test(&ar->dp.num_tx_pending))\n\t\twake_up(&ar->dp.tx_empty_waitq);\n\n\tdma_unmap_single(ab->dev, skb_cb->paddr, msdu->len, DMA_TO_DEVICE);\n\tif (skb_cb->paddr_ext_desc)\n\t\tdma_unmap_single(ab->dev, skb_cb->paddr_ext_desc,\n\t\t\t\t sizeof(struct hal_tx_msdu_ext_desc), DMA_TO_DEVICE);\n\n\tmemset(&info->status, 0, sizeof(info->status));\n\n\tif (ts->acked) {\n\t\tif (!(info->flags & IEEE80211_TX_CTL_NO_ACK)) {\n\t\t\tinfo->flags |= IEEE80211_TX_STAT_ACK;\n\t\t\tinfo->status.ack_signal = ATH12K_DEFAULT_NOISE_FLOOR +\n\t\t\t\t\t\t  ts->ack_rssi;\n\t\t\tinfo->status.flags = IEEE80211_TX_STATUS_ACK_SIGNAL_VALID;\n\t\t} else {\n\t\t\tinfo->flags |= IEEE80211_TX_STAT_NOACK_TRANSMITTED;\n\t\t}\n\t}\n\n\tieee80211_tx_status(ar->hw, msdu);\n}\n\nstatic void\nath12k_dp_tx_process_htt_tx_complete(struct ath12k_base *ab,\n\t\t\t\t     void *desc, u8 mac_id,\n\t\t\t\t     struct sk_buff *msdu,\n\t\t\t\t     struct dp_tx_ring *tx_ring)\n{\n\tstruct htt_tx_wbm_completion *status_desc;\n\tstruct ath12k_dp_htt_wbm_tx_status ts = {0};\n\tenum hal_wbm_htt_tx_comp_status wbm_status;\n\n\tstatus_desc = desc + HTT_TX_WBM_COMP_STATUS_OFFSET;\n\n\twbm_status = le32_get_bits(status_desc->info0,\n\t\t\t\t   HTT_TX_WBM_COMP_INFO0_STATUS);\n\n\tswitch (wbm_status) {\n\tcase HAL_WBM_REL_HTT_TX_COMP_STATUS_OK:\n\tcase HAL_WBM_REL_HTT_TX_COMP_STATUS_DROP:\n\tcase HAL_WBM_REL_HTT_TX_COMP_STATUS_TTL:\n\t\tts.acked = (wbm_status == HAL_WBM_REL_HTT_TX_COMP_STATUS_OK);\n\t\tts.ack_rssi = le32_get_bits(status_desc->info2,\n\t\t\t\t\t    HTT_TX_WBM_COMP_INFO2_ACK_RSSI);\n\t\tath12k_dp_tx_htt_tx_complete_buf(ab, msdu, tx_ring, &ts);\n\t\tbreak;\n\tcase HAL_WBM_REL_HTT_TX_COMP_STATUS_REINJ:\n\tcase HAL_WBM_REL_HTT_TX_COMP_STATUS_INSPECT:\n\t\tath12k_dp_tx_free_txbuf(ab, msdu, mac_id, tx_ring);\n\t\tbreak;\n\tcase HAL_WBM_REL_HTT_TX_COMP_STATUS_MEC_NOTIFY:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tath12k_warn(ab, \"Unknown htt tx status %d\\n\", wbm_status);\n\t\tbreak;\n\t}\n}\n\nstatic void ath12k_dp_tx_complete_msdu(struct ath12k *ar,\n\t\t\t\t       struct sk_buff *msdu,\n\t\t\t\t       struct hal_tx_status *ts)\n{\n\tstruct ath12k_base *ab = ar->ab;\n\tstruct ieee80211_tx_info *info;\n\tstruct ath12k_skb_cb *skb_cb;\n\n\tif (WARN_ON_ONCE(ts->buf_rel_source != HAL_WBM_REL_SRC_MODULE_TQM)) {\n\t\t \n\t\treturn;\n\t}\n\n\tskb_cb = ATH12K_SKB_CB(msdu);\n\n\tdma_unmap_single(ab->dev, skb_cb->paddr, msdu->len, DMA_TO_DEVICE);\n\tif (skb_cb->paddr_ext_desc)\n\t\tdma_unmap_single(ab->dev, skb_cb->paddr_ext_desc,\n\t\t\t\t sizeof(struct hal_tx_msdu_ext_desc), DMA_TO_DEVICE);\n\n\trcu_read_lock();\n\n\tif (!rcu_dereference(ab->pdevs_active[ar->pdev_idx])) {\n\t\tdev_kfree_skb_any(msdu);\n\t\tgoto exit;\n\t}\n\n\tif (!skb_cb->vif) {\n\t\tdev_kfree_skb_any(msdu);\n\t\tgoto exit;\n\t}\n\n\tinfo = IEEE80211_SKB_CB(msdu);\n\tmemset(&info->status, 0, sizeof(info->status));\n\n\t \n\tinfo->status.rates[0].idx = -1;\n\n\tif (ts->status == HAL_WBM_TQM_REL_REASON_FRAME_ACKED &&\n\t    !(info->flags & IEEE80211_TX_CTL_NO_ACK)) {\n\t\tinfo->flags |= IEEE80211_TX_STAT_ACK;\n\t\tinfo->status.ack_signal = ATH12K_DEFAULT_NOISE_FLOOR +\n\t\t\t\t\t  ts->ack_rssi;\n\t\tinfo->status.flags = IEEE80211_TX_STATUS_ACK_SIGNAL_VALID;\n\t}\n\n\tif (ts->status == HAL_WBM_TQM_REL_REASON_CMD_REMOVE_TX &&\n\t    (info->flags & IEEE80211_TX_CTL_NO_ACK))\n\t\tinfo->flags |= IEEE80211_TX_STAT_NOACK_TRANSMITTED;\n\n\t \n\n\tieee80211_tx_status(ar->hw, msdu);\n\nexit:\n\trcu_read_unlock();\n}\n\nstatic void ath12k_dp_tx_status_parse(struct ath12k_base *ab,\n\t\t\t\t      struct hal_wbm_completion_ring_tx *desc,\n\t\t\t\t      struct hal_tx_status *ts)\n{\n\tts->buf_rel_source =\n\t\tle32_get_bits(desc->info0, HAL_WBM_COMPL_TX_INFO0_REL_SRC_MODULE);\n\tif (ts->buf_rel_source != HAL_WBM_REL_SRC_MODULE_FW &&\n\t    ts->buf_rel_source != HAL_WBM_REL_SRC_MODULE_TQM)\n\t\treturn;\n\n\tif (ts->buf_rel_source == HAL_WBM_REL_SRC_MODULE_FW)\n\t\treturn;\n\n\tts->status = le32_get_bits(desc->info0,\n\t\t\t\t   HAL_WBM_COMPL_TX_INFO0_TQM_RELEASE_REASON);\n\n\tts->ppdu_id = le32_get_bits(desc->info1,\n\t\t\t\t    HAL_WBM_COMPL_TX_INFO1_TQM_STATUS_NUMBER);\n\tif (le32_to_cpu(desc->rate_stats.info0) & HAL_TX_RATE_STATS_INFO0_VALID)\n\t\tts->rate_stats = le32_to_cpu(desc->rate_stats.info0);\n\telse\n\t\tts->rate_stats = 0;\n}\n\nvoid ath12k_dp_tx_completion_handler(struct ath12k_base *ab, int ring_id)\n{\n\tstruct ath12k *ar;\n\tstruct ath12k_dp *dp = &ab->dp;\n\tint hal_ring_id = dp->tx_ring[ring_id].tcl_comp_ring.ring_id;\n\tstruct hal_srng *status_ring = &ab->hal.srng_list[hal_ring_id];\n\tstruct ath12k_tx_desc_info *tx_desc = NULL;\n\tstruct sk_buff *msdu;\n\tstruct hal_tx_status ts = { 0 };\n\tstruct dp_tx_ring *tx_ring = &dp->tx_ring[ring_id];\n\tstruct hal_wbm_release_ring *desc;\n\tu8 mac_id, pdev_id;\n\tu64 desc_va;\n\n\tspin_lock_bh(&status_ring->lock);\n\n\tath12k_hal_srng_access_begin(ab, status_ring);\n\n\twhile (ATH12K_TX_COMPL_NEXT(tx_ring->tx_status_head) != tx_ring->tx_status_tail) {\n\t\tdesc = ath12k_hal_srng_dst_get_next_entry(ab, status_ring);\n\t\tif (!desc)\n\t\t\tbreak;\n\n\t\tmemcpy(&tx_ring->tx_status[tx_ring->tx_status_head],\n\t\t       desc, sizeof(*desc));\n\t\ttx_ring->tx_status_head =\n\t\t\tATH12K_TX_COMPL_NEXT(tx_ring->tx_status_head);\n\t}\n\n\tif (ath12k_hal_srng_dst_peek(ab, status_ring) &&\n\t    (ATH12K_TX_COMPL_NEXT(tx_ring->tx_status_head) == tx_ring->tx_status_tail)) {\n\t\t \n\t\tath12k_warn(ab, \"Unable to process some of the tx_status ring desc because status_fifo is full\\n\");\n\t}\n\n\tath12k_hal_srng_access_end(ab, status_ring);\n\n\tspin_unlock_bh(&status_ring->lock);\n\n\twhile (ATH12K_TX_COMPL_NEXT(tx_ring->tx_status_tail) != tx_ring->tx_status_head) {\n\t\tstruct hal_wbm_completion_ring_tx *tx_status;\n\t\tu32 desc_id;\n\n\t\ttx_ring->tx_status_tail =\n\t\t\tATH12K_TX_COMPL_NEXT(tx_ring->tx_status_tail);\n\t\ttx_status = &tx_ring->tx_status[tx_ring->tx_status_tail];\n\t\tath12k_dp_tx_status_parse(ab, tx_status, &ts);\n\n\t\tif (le32_get_bits(tx_status->info0, HAL_WBM_COMPL_TX_INFO0_CC_DONE)) {\n\t\t\t \n\t\t\tdesc_va = ((u64)le32_to_cpu(tx_status->buf_va_hi) << 32 |\n\t\t\t\t   le32_to_cpu(tx_status->buf_va_lo));\n\t\t\ttx_desc = (struct ath12k_tx_desc_info *)((unsigned long)desc_va);\n\t\t} else {\n\t\t\t \n\t\t\tdesc_id = le32_get_bits(tx_status->buf_va_hi,\n\t\t\t\t\t\tBUFFER_ADDR_INFO1_SW_COOKIE);\n\n\t\t\ttx_desc = ath12k_dp_get_tx_desc(ab, desc_id);\n\t\t}\n\t\tif (!tx_desc) {\n\t\t\tath12k_warn(ab, \"unable to retrieve tx_desc!\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tmsdu = tx_desc->skb;\n\t\tmac_id = tx_desc->mac_id;\n\n\t\t \n\t\tath12k_dp_tx_release_txbuf(dp, tx_desc, tx_desc->pool_id);\n\t\tif (ts.buf_rel_source == HAL_WBM_REL_SRC_MODULE_FW) {\n\t\t\tath12k_dp_tx_process_htt_tx_complete(ab,\n\t\t\t\t\t\t\t     (void *)tx_status,\n\t\t\t\t\t\t\t     mac_id, msdu,\n\t\t\t\t\t\t\t     tx_ring);\n\t\t\tcontinue;\n\t\t}\n\n\t\tpdev_id = ath12k_hw_mac_id_to_pdev_id(ab->hw_params, mac_id);\n\t\tar = ab->pdevs[pdev_id].ar;\n\n\t\tif (atomic_dec_and_test(&ar->dp.num_tx_pending))\n\t\t\twake_up(&ar->dp.tx_empty_waitq);\n\n\t\tath12k_dp_tx_complete_msdu(ar, msdu, &ts);\n\t}\n}\n\nstatic int\nath12k_dp_tx_get_ring_id_type(struct ath12k_base *ab,\n\t\t\t      int mac_id, u32 ring_id,\n\t\t\t      enum hal_ring_type ring_type,\n\t\t\t      enum htt_srng_ring_type *htt_ring_type,\n\t\t\t      enum htt_srng_ring_id *htt_ring_id)\n{\n\tint ret = 0;\n\n\tswitch (ring_type) {\n\tcase HAL_RXDMA_BUF:\n\t\t \n\t\tif (!ab->hw_params->rx_mac_buf_ring) {\n\t\t\tif (!(ring_id == HAL_SRNG_SW2RXDMA_BUF0 ||\n\t\t\t      ring_id == HAL_SRNG_SW2RXDMA_BUF1)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t}\n\t\t\t*htt_ring_id = HTT_RXDMA_HOST_BUF_RING;\n\t\t\t*htt_ring_type = HTT_SW_TO_HW_RING;\n\t\t} else {\n\t\t\tif (ring_id == HAL_SRNG_SW2RXDMA_BUF0) {\n\t\t\t\t*htt_ring_id = HTT_HOST1_TO_FW_RXBUF_RING;\n\t\t\t\t*htt_ring_type = HTT_SW_TO_SW_RING;\n\t\t\t} else {\n\t\t\t\t*htt_ring_id = HTT_RXDMA_HOST_BUF_RING;\n\t\t\t\t*htt_ring_type = HTT_SW_TO_HW_RING;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase HAL_RXDMA_DST:\n\t\t*htt_ring_id = HTT_RXDMA_NON_MONITOR_DEST_RING;\n\t\t*htt_ring_type = HTT_HW_TO_SW_RING;\n\t\tbreak;\n\tcase HAL_RXDMA_MONITOR_BUF:\n\t\t*htt_ring_id = HTT_RXDMA_MONITOR_BUF_RING;\n\t\t*htt_ring_type = HTT_SW_TO_HW_RING;\n\t\tbreak;\n\tcase HAL_RXDMA_MONITOR_STATUS:\n\t\t*htt_ring_id = HTT_RXDMA_MONITOR_STATUS_RING;\n\t\t*htt_ring_type = HTT_SW_TO_HW_RING;\n\t\tbreak;\n\tcase HAL_RXDMA_MONITOR_DST:\n\t\t*htt_ring_id = HTT_RXDMA_MONITOR_DEST_RING;\n\t\t*htt_ring_type = HTT_HW_TO_SW_RING;\n\t\tbreak;\n\tcase HAL_RXDMA_MONITOR_DESC:\n\t\t*htt_ring_id = HTT_RXDMA_MONITOR_DESC_RING;\n\t\t*htt_ring_type = HTT_SW_TO_HW_RING;\n\t\tbreak;\n\tcase HAL_TX_MONITOR_BUF:\n\t\t*htt_ring_id = HTT_TX_MON_HOST2MON_BUF_RING;\n\t\t*htt_ring_type = HTT_SW_TO_HW_RING;\n\t\tbreak;\n\tcase HAL_TX_MONITOR_DST:\n\t\t*htt_ring_id = HTT_TX_MON_MON2HOST_DEST_RING;\n\t\t*htt_ring_type = HTT_HW_TO_SW_RING;\n\t\tbreak;\n\tdefault:\n\t\tath12k_warn(ab, \"Unsupported ring type in DP :%d\\n\", ring_type);\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}\n\nint ath12k_dp_tx_htt_srng_setup(struct ath12k_base *ab, u32 ring_id,\n\t\t\t\tint mac_id, enum hal_ring_type ring_type)\n{\n\tstruct htt_srng_setup_cmd *cmd;\n\tstruct hal_srng *srng = &ab->hal.srng_list[ring_id];\n\tstruct hal_srng_params params;\n\tstruct sk_buff *skb;\n\tu32 ring_entry_sz;\n\tint len = sizeof(*cmd);\n\tdma_addr_t hp_addr, tp_addr;\n\tenum htt_srng_ring_type htt_ring_type;\n\tenum htt_srng_ring_id htt_ring_id;\n\tint ret;\n\n\tskb = ath12k_htc_alloc_skb(ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tmemset(&params, 0, sizeof(params));\n\tath12k_hal_srng_get_params(ab, srng, &params);\n\n\thp_addr = ath12k_hal_srng_get_hp_addr(ab, srng);\n\ttp_addr = ath12k_hal_srng_get_tp_addr(ab, srng);\n\n\tret = ath12k_dp_tx_get_ring_id_type(ab, mac_id, ring_id,\n\t\t\t\t\t    ring_type, &htt_ring_type,\n\t\t\t\t\t    &htt_ring_id);\n\tif (ret)\n\t\tgoto err_free;\n\n\tskb_put(skb, len);\n\tcmd = (struct htt_srng_setup_cmd *)skb->data;\n\tcmd->info0 = le32_encode_bits(HTT_H2T_MSG_TYPE_SRING_SETUP,\n\t\t\t\t      HTT_SRNG_SETUP_CMD_INFO0_MSG_TYPE);\n\tif (htt_ring_type == HTT_SW_TO_HW_RING ||\n\t    htt_ring_type == HTT_HW_TO_SW_RING)\n\t\tcmd->info0 |= le32_encode_bits(DP_SW2HW_MACID(mac_id),\n\t\t\t\t\t       HTT_SRNG_SETUP_CMD_INFO0_PDEV_ID);\n\telse\n\t\tcmd->info0 |= le32_encode_bits(mac_id,\n\t\t\t\t\t       HTT_SRNG_SETUP_CMD_INFO0_PDEV_ID);\n\tcmd->info0 |= le32_encode_bits(htt_ring_type,\n\t\t\t\t       HTT_SRNG_SETUP_CMD_INFO0_RING_TYPE);\n\tcmd->info0 |= le32_encode_bits(htt_ring_id,\n\t\t\t\t       HTT_SRNG_SETUP_CMD_INFO0_RING_ID);\n\n\tcmd->ring_base_addr_lo = cpu_to_le32(params.ring_base_paddr &\n\t\t\t\t\t     HAL_ADDR_LSB_REG_MASK);\n\n\tcmd->ring_base_addr_hi = cpu_to_le32((u64)params.ring_base_paddr >>\n\t\t\t\t\t     HAL_ADDR_MSB_REG_SHIFT);\n\n\tret = ath12k_hal_srng_get_entrysize(ab, ring_type);\n\tif (ret < 0)\n\t\tgoto err_free;\n\n\tring_entry_sz = ret;\n\n\tring_entry_sz >>= 2;\n\tcmd->info1 = le32_encode_bits(ring_entry_sz,\n\t\t\t\t      HTT_SRNG_SETUP_CMD_INFO1_RING_ENTRY_SIZE);\n\tcmd->info1 |= le32_encode_bits(params.num_entries * ring_entry_sz,\n\t\t\t\t       HTT_SRNG_SETUP_CMD_INFO1_RING_SIZE);\n\tcmd->info1 |= le32_encode_bits(!!(params.flags & HAL_SRNG_FLAGS_MSI_SWAP),\n\t\t\t\t       HTT_SRNG_SETUP_CMD_INFO1_RING_FLAGS_MSI_SWAP);\n\tcmd->info1 |= le32_encode_bits(!!(params.flags & HAL_SRNG_FLAGS_DATA_TLV_SWAP),\n\t\t\t\t       HTT_SRNG_SETUP_CMD_INFO1_RING_FLAGS_TLV_SWAP);\n\tcmd->info1 |= le32_encode_bits(!!(params.flags & HAL_SRNG_FLAGS_RING_PTR_SWAP),\n\t\t\t\t       HTT_SRNG_SETUP_CMD_INFO1_RING_FLAGS_HOST_FW_SWAP);\n\tif (htt_ring_type == HTT_SW_TO_HW_RING)\n\t\tcmd->info1 |= cpu_to_le32(HTT_SRNG_SETUP_CMD_INFO1_RING_LOOP_CNT_DIS);\n\n\tcmd->ring_head_off32_remote_addr_lo = cpu_to_le32(lower_32_bits(hp_addr));\n\tcmd->ring_head_off32_remote_addr_hi = cpu_to_le32(upper_32_bits(hp_addr));\n\n\tcmd->ring_tail_off32_remote_addr_lo = cpu_to_le32(lower_32_bits(tp_addr));\n\tcmd->ring_tail_off32_remote_addr_hi = cpu_to_le32(upper_32_bits(tp_addr));\n\n\tcmd->ring_msi_addr_lo = cpu_to_le32(lower_32_bits(params.msi_addr));\n\tcmd->ring_msi_addr_hi = cpu_to_le32(upper_32_bits(params.msi_addr));\n\tcmd->msi_data = cpu_to_le32(params.msi_data);\n\n\tcmd->intr_info =\n\t\tle32_encode_bits(params.intr_batch_cntr_thres_entries * ring_entry_sz,\n\t\t\t\t HTT_SRNG_SETUP_CMD_INTR_INFO_BATCH_COUNTER_THRESH);\n\tcmd->intr_info |=\n\t\tle32_encode_bits(params.intr_timer_thres_us >> 3,\n\t\t\t\t HTT_SRNG_SETUP_CMD_INTR_INFO_INTR_TIMER_THRESH);\n\n\tcmd->info2 = 0;\n\tif (params.flags & HAL_SRNG_FLAGS_LOW_THRESH_INTR_EN) {\n\t\tcmd->info2 = le32_encode_bits(params.low_threshold,\n\t\t\t\t\t      HTT_SRNG_SETUP_CMD_INFO2_INTR_LOW_THRESH);\n\t}\n\n\tath12k_dbg(ab, ATH12K_DBG_HAL,\n\t\t   \"%s msi_addr_lo:0x%x, msi_addr_hi:0x%x, msi_data:0x%x\\n\",\n\t\t   __func__, cmd->ring_msi_addr_lo, cmd->ring_msi_addr_hi,\n\t\t   cmd->msi_data);\n\n\tath12k_dbg(ab, ATH12K_DBG_HAL,\n\t\t   \"ring_id:%d, ring_type:%d, intr_info:0x%x, flags:0x%x\\n\",\n\t\t   ring_id, ring_type, cmd->intr_info, cmd->info2);\n\n\tret = ath12k_htc_send(&ab->htc, ab->dp.eid, skb);\n\tif (ret)\n\t\tgoto err_free;\n\n\treturn 0;\n\nerr_free:\n\tdev_kfree_skb_any(skb);\n\n\treturn ret;\n}\n\n#define HTT_TARGET_VERSION_TIMEOUT_HZ (3 * HZ)\n\nint ath12k_dp_tx_htt_h2t_ver_req_msg(struct ath12k_base *ab)\n{\n\tstruct ath12k_dp *dp = &ab->dp;\n\tstruct sk_buff *skb;\n\tstruct htt_ver_req_cmd *cmd;\n\tint len = sizeof(*cmd);\n\tint ret;\n\n\tinit_completion(&dp->htt_tgt_version_received);\n\n\tskb = ath12k_htc_alloc_skb(ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put(skb, len);\n\tcmd = (struct htt_ver_req_cmd *)skb->data;\n\tcmd->ver_reg_info = le32_encode_bits(HTT_H2T_MSG_TYPE_VERSION_REQ,\n\t\t\t\t\t     HTT_VER_REQ_INFO_MSG_ID);\n\n\tret = ath12k_htc_send(&ab->htc, dp->eid, skb);\n\tif (ret) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn ret;\n\t}\n\n\tret = wait_for_completion_timeout(&dp->htt_tgt_version_received,\n\t\t\t\t\t  HTT_TARGET_VERSION_TIMEOUT_HZ);\n\tif (ret == 0) {\n\t\tath12k_warn(ab, \"htt target version request timed out\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tif (dp->htt_tgt_ver_major != HTT_TARGET_VERSION_MAJOR) {\n\t\tath12k_err(ab, \"unsupported htt major version %d supported version is %d\\n\",\n\t\t\t   dp->htt_tgt_ver_major, HTT_TARGET_VERSION_MAJOR);\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nint ath12k_dp_tx_htt_h2t_ppdu_stats_req(struct ath12k *ar, u32 mask)\n{\n\tstruct ath12k_base *ab = ar->ab;\n\tstruct ath12k_dp *dp = &ab->dp;\n\tstruct sk_buff *skb;\n\tstruct htt_ppdu_stats_cfg_cmd *cmd;\n\tint len = sizeof(*cmd);\n\tu8 pdev_mask;\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < ab->hw_params->num_rxmda_per_pdev; i++) {\n\t\tskb = ath12k_htc_alloc_skb(ab, len);\n\t\tif (!skb)\n\t\t\treturn -ENOMEM;\n\n\t\tskb_put(skb, len);\n\t\tcmd = (struct htt_ppdu_stats_cfg_cmd *)skb->data;\n\t\tcmd->msg = le32_encode_bits(HTT_H2T_MSG_TYPE_PPDU_STATS_CFG,\n\t\t\t\t\t    HTT_PPDU_STATS_CFG_MSG_TYPE);\n\n\t\tpdev_mask = 1 << (i + 1);\n\t\tcmd->msg |= le32_encode_bits(pdev_mask, HTT_PPDU_STATS_CFG_PDEV_ID);\n\t\tcmd->msg |= le32_encode_bits(mask, HTT_PPDU_STATS_CFG_TLV_TYPE_BITMASK);\n\n\t\tret = ath12k_htc_send(&ab->htc, dp->eid, skb);\n\t\tif (ret) {\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint ath12k_dp_tx_htt_rx_filter_setup(struct ath12k_base *ab, u32 ring_id,\n\t\t\t\t     int mac_id, enum hal_ring_type ring_type,\n\t\t\t\t     int rx_buf_size,\n\t\t\t\t     struct htt_rx_ring_tlv_filter *tlv_filter)\n{\n\tstruct htt_rx_ring_selection_cfg_cmd *cmd;\n\tstruct hal_srng *srng = &ab->hal.srng_list[ring_id];\n\tstruct hal_srng_params params;\n\tstruct sk_buff *skb;\n\tint len = sizeof(*cmd);\n\tenum htt_srng_ring_type htt_ring_type;\n\tenum htt_srng_ring_id htt_ring_id;\n\tint ret;\n\n\tskb = ath12k_htc_alloc_skb(ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tmemset(&params, 0, sizeof(params));\n\tath12k_hal_srng_get_params(ab, srng, &params);\n\n\tret = ath12k_dp_tx_get_ring_id_type(ab, mac_id, ring_id,\n\t\t\t\t\t    ring_type, &htt_ring_type,\n\t\t\t\t\t    &htt_ring_id);\n\tif (ret)\n\t\tgoto err_free;\n\n\tskb_put(skb, len);\n\tcmd = (struct htt_rx_ring_selection_cfg_cmd *)skb->data;\n\tcmd->info0 = le32_encode_bits(HTT_H2T_MSG_TYPE_RX_RING_SELECTION_CFG,\n\t\t\t\t      HTT_RX_RING_SELECTION_CFG_CMD_INFO0_MSG_TYPE);\n\tif (htt_ring_type == HTT_SW_TO_HW_RING ||\n\t    htt_ring_type == HTT_HW_TO_SW_RING)\n\t\tcmd->info0 |=\n\t\t\tle32_encode_bits(DP_SW2HW_MACID(mac_id),\n\t\t\t\t\t HTT_RX_RING_SELECTION_CFG_CMD_INFO0_PDEV_ID);\n\telse\n\t\tcmd->info0 |=\n\t\t\tle32_encode_bits(mac_id,\n\t\t\t\t\t HTT_RX_RING_SELECTION_CFG_CMD_INFO0_PDEV_ID);\n\tcmd->info0 |= le32_encode_bits(htt_ring_id,\n\t\t\t\t       HTT_RX_RING_SELECTION_CFG_CMD_INFO0_RING_ID);\n\tcmd->info0 |= le32_encode_bits(!!(params.flags & HAL_SRNG_FLAGS_MSI_SWAP),\n\t\t\t\t       HTT_RX_RING_SELECTION_CFG_CMD_INFO0_SS);\n\tcmd->info0 |= le32_encode_bits(!!(params.flags & HAL_SRNG_FLAGS_DATA_TLV_SWAP),\n\t\t\t\t       HTT_RX_RING_SELECTION_CFG_CMD_INFO0_PS);\n\tcmd->info0 |= le32_encode_bits(tlv_filter->offset_valid,\n\t\t\t\t       HTT_RX_RING_SELECTION_CFG_CMD_OFFSET_VALID);\n\tcmd->info1 = le32_encode_bits(rx_buf_size,\n\t\t\t\t      HTT_RX_RING_SELECTION_CFG_CMD_INFO1_BUF_SIZE);\n\tcmd->pkt_type_en_flags0 = cpu_to_le32(tlv_filter->pkt_filter_flags0);\n\tcmd->pkt_type_en_flags1 = cpu_to_le32(tlv_filter->pkt_filter_flags1);\n\tcmd->pkt_type_en_flags2 = cpu_to_le32(tlv_filter->pkt_filter_flags2);\n\tcmd->pkt_type_en_flags3 = cpu_to_le32(tlv_filter->pkt_filter_flags3);\n\tcmd->rx_filter_tlv = cpu_to_le32(tlv_filter->rx_filter);\n\n\tif (tlv_filter->offset_valid) {\n\t\tcmd->rx_packet_offset =\n\t\t\tle32_encode_bits(tlv_filter->rx_packet_offset,\n\t\t\t\t\t HTT_RX_RING_SELECTION_CFG_RX_PACKET_OFFSET);\n\n\t\tcmd->rx_packet_offset |=\n\t\t\tle32_encode_bits(tlv_filter->rx_header_offset,\n\t\t\t\t\t HTT_RX_RING_SELECTION_CFG_RX_HEADER_OFFSET);\n\n\t\tcmd->rx_mpdu_offset =\n\t\t\tle32_encode_bits(tlv_filter->rx_mpdu_end_offset,\n\t\t\t\t\t HTT_RX_RING_SELECTION_CFG_RX_MPDU_END_OFFSET);\n\n\t\tcmd->rx_mpdu_offset |=\n\t\t\tle32_encode_bits(tlv_filter->rx_mpdu_start_offset,\n\t\t\t\t\t HTT_RX_RING_SELECTION_CFG_RX_MPDU_START_OFFSET);\n\n\t\tcmd->rx_msdu_offset =\n\t\t\tle32_encode_bits(tlv_filter->rx_msdu_end_offset,\n\t\t\t\t\t HTT_RX_RING_SELECTION_CFG_RX_MSDU_END_OFFSET);\n\n\t\tcmd->rx_msdu_offset |=\n\t\t\tle32_encode_bits(tlv_filter->rx_msdu_start_offset,\n\t\t\t\t\t HTT_RX_RING_SELECTION_CFG_RX_MSDU_START_OFFSET);\n\n\t\tcmd->rx_attn_offset =\n\t\t\tle32_encode_bits(tlv_filter->rx_attn_offset,\n\t\t\t\t\t HTT_RX_RING_SELECTION_CFG_RX_ATTENTION_OFFSET);\n\t}\n\n\tret = ath12k_htc_send(&ab->htc, ab->dp.eid, skb);\n\tif (ret)\n\t\tgoto err_free;\n\n\treturn 0;\n\nerr_free:\n\tdev_kfree_skb_any(skb);\n\n\treturn ret;\n}\n\nint\nath12k_dp_tx_htt_h2t_ext_stats_req(struct ath12k *ar, u8 type,\n\t\t\t\t   struct htt_ext_stats_cfg_params *cfg_params,\n\t\t\t\t   u64 cookie)\n{\n\tstruct ath12k_base *ab = ar->ab;\n\tstruct ath12k_dp *dp = &ab->dp;\n\tstruct sk_buff *skb;\n\tstruct htt_ext_stats_cfg_cmd *cmd;\n\tint len = sizeof(*cmd);\n\tint ret;\n\n\tskb = ath12k_htc_alloc_skb(ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put(skb, len);\n\n\tcmd = (struct htt_ext_stats_cfg_cmd *)skb->data;\n\tmemset(cmd, 0, sizeof(*cmd));\n\tcmd->hdr.msg_type = HTT_H2T_MSG_TYPE_EXT_STATS_CFG;\n\n\tcmd->hdr.pdev_mask = 1 << ar->pdev->pdev_id;\n\n\tcmd->hdr.stats_type = type;\n\tcmd->cfg_param0 = cpu_to_le32(cfg_params->cfg0);\n\tcmd->cfg_param1 = cpu_to_le32(cfg_params->cfg1);\n\tcmd->cfg_param2 = cpu_to_le32(cfg_params->cfg2);\n\tcmd->cfg_param3 = cpu_to_le32(cfg_params->cfg3);\n\tcmd->cookie_lsb = cpu_to_le32(lower_32_bits(cookie));\n\tcmd->cookie_msb = cpu_to_le32(upper_32_bits(cookie));\n\n\tret = ath12k_htc_send(&ab->htc, dp->eid, skb);\n\tif (ret) {\n\t\tath12k_warn(ab, \"failed to send htt type stats request: %d\",\n\t\t\t    ret);\n\t\tdev_kfree_skb_any(skb);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint ath12k_dp_tx_htt_monitor_mode_ring_config(struct ath12k *ar, bool reset)\n{\n\tstruct ath12k_base *ab = ar->ab;\n\tint ret;\n\n\tret = ath12k_dp_tx_htt_tx_monitor_mode_ring_config(ar, reset);\n\tif (ret) {\n\t\tath12k_err(ab, \"failed to setup tx monitor filter %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ath12k_dp_tx_htt_tx_monitor_mode_ring_config(ar, reset);\n\tif (ret) {\n\t\tath12k_err(ab, \"failed to setup rx monitor filter %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint ath12k_dp_tx_htt_rx_monitor_mode_ring_config(struct ath12k *ar, bool reset)\n{\n\tstruct ath12k_base *ab = ar->ab;\n\tstruct ath12k_dp *dp = &ab->dp;\n\tstruct htt_rx_ring_tlv_filter tlv_filter = {0};\n\tint ret, ring_id;\n\n\tring_id = dp->rxdma_mon_buf_ring.refill_buf_ring.ring_id;\n\ttlv_filter.offset_valid = false;\n\n\tif (!reset) {\n\t\ttlv_filter.rx_filter = HTT_RX_MON_FILTER_TLV_FLAGS_MON_BUF_RING;\n\t\ttlv_filter.pkt_filter_flags0 =\n\t\t\t\t\tHTT_RX_MON_FP_MGMT_FILTER_FLAGS0 |\n\t\t\t\t\tHTT_RX_MON_MO_MGMT_FILTER_FLAGS0;\n\t\ttlv_filter.pkt_filter_flags1 =\n\t\t\t\t\tHTT_RX_MON_FP_MGMT_FILTER_FLAGS1 |\n\t\t\t\t\tHTT_RX_MON_MO_MGMT_FILTER_FLAGS1;\n\t\ttlv_filter.pkt_filter_flags2 =\n\t\t\t\t\tHTT_RX_MON_FP_CTRL_FILTER_FLASG2 |\n\t\t\t\t\tHTT_RX_MON_MO_CTRL_FILTER_FLASG2;\n\t\ttlv_filter.pkt_filter_flags3 =\n\t\t\t\t\tHTT_RX_MON_FP_CTRL_FILTER_FLASG3 |\n\t\t\t\t\tHTT_RX_MON_MO_CTRL_FILTER_FLASG3 |\n\t\t\t\t\tHTT_RX_MON_FP_DATA_FILTER_FLASG3 |\n\t\t\t\t\tHTT_RX_MON_MO_DATA_FILTER_FLASG3;\n\t}\n\n\tif (ab->hw_params->rxdma1_enable) {\n\t\tret = ath12k_dp_tx_htt_rx_filter_setup(ar->ab, ring_id, 0,\n\t\t\t\t\t\t       HAL_RXDMA_MONITOR_BUF,\n\t\t\t\t\t\t       DP_RXDMA_REFILL_RING_SIZE,\n\t\t\t\t\t\t       &tlv_filter);\n\t\tif (ret) {\n\t\t\tath12k_err(ab,\n\t\t\t\t   \"failed to setup filter for monitor buf %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint ath12k_dp_tx_htt_tx_filter_setup(struct ath12k_base *ab, u32 ring_id,\n\t\t\t\t     int mac_id, enum hal_ring_type ring_type,\n\t\t\t\t     int tx_buf_size,\n\t\t\t\t     struct htt_tx_ring_tlv_filter *htt_tlv_filter)\n{\n\tstruct htt_tx_ring_selection_cfg_cmd *cmd;\n\tstruct hal_srng *srng = &ab->hal.srng_list[ring_id];\n\tstruct hal_srng_params params;\n\tstruct sk_buff *skb;\n\tint len = sizeof(*cmd);\n\tenum htt_srng_ring_type htt_ring_type;\n\tenum htt_srng_ring_id htt_ring_id;\n\tint ret;\n\n\tskb = ath12k_htc_alloc_skb(ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tmemset(&params, 0, sizeof(params));\n\tath12k_hal_srng_get_params(ab, srng, &params);\n\n\tret = ath12k_dp_tx_get_ring_id_type(ab, mac_id, ring_id,\n\t\t\t\t\t    ring_type, &htt_ring_type,\n\t\t\t\t\t    &htt_ring_id);\n\n\tif (ret)\n\t\tgoto err_free;\n\n\tskb_put(skb, len);\n\tcmd = (struct htt_tx_ring_selection_cfg_cmd *)skb->data;\n\tcmd->info0 = le32_encode_bits(HTT_H2T_MSG_TYPE_TX_MONITOR_CFG,\n\t\t\t\t      HTT_TX_RING_SELECTION_CFG_CMD_INFO0_MSG_TYPE);\n\tif (htt_ring_type == HTT_SW_TO_HW_RING ||\n\t    htt_ring_type == HTT_HW_TO_SW_RING)\n\t\tcmd->info0 |=\n\t\t\tle32_encode_bits(DP_SW2HW_MACID(mac_id),\n\t\t\t\t\t HTT_TX_RING_SELECTION_CFG_CMD_INFO0_PDEV_ID);\n\telse\n\t\tcmd->info0 |=\n\t\t\tle32_encode_bits(mac_id,\n\t\t\t\t\t HTT_TX_RING_SELECTION_CFG_CMD_INFO0_PDEV_ID);\n\tcmd->info0 |= le32_encode_bits(htt_ring_id,\n\t\t\t\t       HTT_TX_RING_SELECTION_CFG_CMD_INFO0_RING_ID);\n\tcmd->info0 |= le32_encode_bits(!!(params.flags & HAL_SRNG_FLAGS_MSI_SWAP),\n\t\t\t\t       HTT_TX_RING_SELECTION_CFG_CMD_INFO0_SS);\n\tcmd->info0 |= le32_encode_bits(!!(params.flags & HAL_SRNG_FLAGS_DATA_TLV_SWAP),\n\t\t\t\t       HTT_TX_RING_SELECTION_CFG_CMD_INFO0_PS);\n\n\tcmd->info1 |=\n\t\tle32_encode_bits(tx_buf_size,\n\t\t\t\t HTT_TX_RING_SELECTION_CFG_CMD_INFO1_RING_BUFF_SIZE);\n\n\tif (htt_tlv_filter->tx_mon_mgmt_filter) {\n\t\tcmd->info1 |=\n\t\t\tle32_encode_bits(HTT_STATS_FRAME_CTRL_TYPE_MGMT,\n\t\t\t\t\t HTT_TX_RING_SELECTION_CFG_CMD_INFO1_PKT_TYPE);\n\t\tcmd->info1 |=\n\t\tle32_encode_bits(htt_tlv_filter->tx_mon_pkt_dma_len,\n\t\t\t\t HTT_TX_RING_SELECTION_CFG_CMD_INFO1_CONF_LEN_MGMT);\n\t\tcmd->info2 |=\n\t\tle32_encode_bits(HTT_STATS_FRAME_CTRL_TYPE_MGMT,\n\t\t\t\t HTT_TX_RING_SELECTION_CFG_CMD_INFO2_PKT_TYPE_EN_FLAG);\n\t}\n\n\tif (htt_tlv_filter->tx_mon_data_filter) {\n\t\tcmd->info1 |=\n\t\t\tle32_encode_bits(HTT_STATS_FRAME_CTRL_TYPE_CTRL,\n\t\t\t\t\t HTT_TX_RING_SELECTION_CFG_CMD_INFO1_PKT_TYPE);\n\t\tcmd->info1 |=\n\t\tle32_encode_bits(htt_tlv_filter->tx_mon_pkt_dma_len,\n\t\t\t\t HTT_TX_RING_SELECTION_CFG_CMD_INFO1_CONF_LEN_CTRL);\n\t\tcmd->info2 |=\n\t\tle32_encode_bits(HTT_STATS_FRAME_CTRL_TYPE_CTRL,\n\t\t\t\t HTT_TX_RING_SELECTION_CFG_CMD_INFO2_PKT_TYPE_EN_FLAG);\n\t}\n\n\tif (htt_tlv_filter->tx_mon_ctrl_filter) {\n\t\tcmd->info1 |=\n\t\t\tle32_encode_bits(HTT_STATS_FRAME_CTRL_TYPE_DATA,\n\t\t\t\t\t HTT_TX_RING_SELECTION_CFG_CMD_INFO1_PKT_TYPE);\n\t\tcmd->info1 |=\n\t\tle32_encode_bits(htt_tlv_filter->tx_mon_pkt_dma_len,\n\t\t\t\t HTT_TX_RING_SELECTION_CFG_CMD_INFO1_CONF_LEN_DATA);\n\t\tcmd->info2 |=\n\t\tle32_encode_bits(HTT_STATS_FRAME_CTRL_TYPE_DATA,\n\t\t\t\t HTT_TX_RING_SELECTION_CFG_CMD_INFO2_PKT_TYPE_EN_FLAG);\n\t}\n\n\tcmd->tlv_filter_mask_in0 =\n\t\tcpu_to_le32(htt_tlv_filter->tx_mon_downstream_tlv_flags);\n\tcmd->tlv_filter_mask_in1 =\n\t\tcpu_to_le32(htt_tlv_filter->tx_mon_upstream_tlv_flags0);\n\tcmd->tlv_filter_mask_in2 =\n\t\tcpu_to_le32(htt_tlv_filter->tx_mon_upstream_tlv_flags1);\n\tcmd->tlv_filter_mask_in3 =\n\t\tcpu_to_le32(htt_tlv_filter->tx_mon_upstream_tlv_flags2);\n\n\tret = ath12k_htc_send(&ab->htc, ab->dp.eid, skb);\n\tif (ret)\n\t\tgoto err_free;\n\n\treturn 0;\n\nerr_free:\n\tdev_kfree_skb_any(skb);\n\treturn ret;\n}\n\nint ath12k_dp_tx_htt_tx_monitor_mode_ring_config(struct ath12k *ar, bool reset)\n{\n\tstruct ath12k_base *ab = ar->ab;\n\tstruct ath12k_dp *dp = &ab->dp;\n\tstruct htt_tx_ring_tlv_filter tlv_filter = {0};\n\tint ret, ring_id;\n\n\tring_id = dp->tx_mon_buf_ring.refill_buf_ring.ring_id;\n\n\t \n\n\tif (ab->hw_params->rxdma1_enable) {\n\t\tret = ath12k_dp_tx_htt_tx_filter_setup(ar->ab, ring_id, 0,\n\t\t\t\t\t\t       HAL_TX_MONITOR_BUF,\n\t\t\t\t\t\t       DP_RXDMA_REFILL_RING_SIZE,\n\t\t\t\t\t\t       &tlv_filter);\n\t\tif (ret) {\n\t\t\tath12k_err(ab,\n\t\t\t\t   \"failed to setup filter for monitor buf %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}