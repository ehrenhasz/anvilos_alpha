{
  "module_name": "ce.c",
  "hash_id": "7df74d9cf099c22afad1591b17b46dc7c2377e5f6cdb5bcc23728dc6fcfce639",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath12k/ce.c",
  "human_readable_source": "\n \n\n#include \"dp_rx.h\"\n#include \"debug.h\"\n#include \"hif.h\"\n\nconst struct ce_attr ath12k_host_ce_config_qcn9274[] = {\n\t \n\t{\n\t\t.flags = CE_ATTR_FLAGS,\n\t\t.src_nentries = 16,\n\t\t.src_sz_max = 2048,\n\t\t.dest_nentries = 0,\n\t},\n\n\t \n\t{\n\t\t.flags = CE_ATTR_FLAGS,\n\t\t.src_nentries = 0,\n\t\t.src_sz_max = 2048,\n\t\t.dest_nentries = 512,\n\t\t.recv_cb = ath12k_htc_rx_completion_handler,\n\t},\n\n\t \n\t{\n\t\t.flags = CE_ATTR_FLAGS,\n\t\t.src_nentries = 0,\n\t\t.src_sz_max = 2048,\n\t\t.dest_nentries = 128,\n\t\t.recv_cb = ath12k_htc_rx_completion_handler,\n\t},\n\n\t \n\t{\n\t\t.flags = CE_ATTR_FLAGS,\n\t\t.src_nentries = 32,\n\t\t.src_sz_max = 2048,\n\t\t.dest_nentries = 0,\n\t},\n\n\t \n\t{\n\t\t.flags = CE_ATTR_FLAGS | CE_ATTR_DIS_INTR,\n\t\t.src_nentries = 2048,\n\t\t.src_sz_max = 256,\n\t\t.dest_nentries = 0,\n\t},\n\n\t \n\t{\n\t\t.flags = CE_ATTR_FLAGS,\n\t\t.src_nentries = 0,\n\t\t.src_sz_max = 2048,\n\t\t.dest_nentries = 512,\n\t\t.recv_cb = ath12k_dp_htt_htc_t2h_msg_handler,\n\t},\n\n\t \n\t{\n\t\t.flags = CE_ATTR_FLAGS | CE_ATTR_DIS_INTR,\n\t\t.src_nentries = 0,\n\t\t.src_sz_max = 0,\n\t\t.dest_nentries = 0,\n\t},\n\n\t \n\t{\n\t\t.flags = CE_ATTR_FLAGS,\n\t\t.src_nentries = 32,\n\t\t.src_sz_max = 2048,\n\t\t.dest_nentries = 0,\n\t},\n\n\t \n\t{\n\t\t.flags = CE_ATTR_FLAGS | CE_ATTR_DIS_INTR,\n\t\t.src_nentries = 0,\n\t\t.src_sz_max = 0,\n\t\t.dest_nentries = 0,\n\t},\n\n\t \n\t{\n\t\t.flags = CE_ATTR_FLAGS | CE_ATTR_DIS_INTR,\n\t\t.src_nentries = 0,\n\t\t.src_sz_max = 0,\n\t\t.dest_nentries = 0,\n\t},\n\n\t \n\t{\n\t\t.flags = CE_ATTR_FLAGS | CE_ATTR_DIS_INTR,\n\t\t.src_nentries = 0,\n\t\t.src_sz_max = 0,\n\t\t.dest_nentries = 0,\n\t},\n\n\t \n\t{\n\t\t.flags = CE_ATTR_FLAGS | CE_ATTR_DIS_INTR,\n\t\t.src_nentries = 0,\n\t\t.src_sz_max = 0,\n\t\t.dest_nentries = 0,\n\t},\n\n\t \n\t{\n\t\t.flags = CE_ATTR_FLAGS | CE_ATTR_DIS_INTR,\n\t\t.src_nentries = 0,\n\t\t.src_sz_max = 0,\n\t\t.dest_nentries = 0,\n\t},\n\n\t \n\t{\n\t\t.flags = CE_ATTR_FLAGS | CE_ATTR_DIS_INTR,\n\t\t.src_nentries = 0,\n\t\t.src_sz_max = 0,\n\t\t.dest_nentries = 0,\n\t},\n\n\t \n\t{\n\t\t.flags = CE_ATTR_FLAGS,\n\t\t.src_nentries = 0,\n\t\t.src_sz_max = 2048,\n\t\t.dest_nentries = 512,\n\t\t.recv_cb = ath12k_htc_rx_completion_handler,\n\t},\n\n\t \n\t{\n\t\t.flags = (CE_ATTR_FLAGS | CE_ATTR_DIS_INTR),\n\t\t.src_nentries = 0,\n\t\t.src_sz_max = 0,\n\t\t.dest_nentries = 0,\n\t},\n};\n\nconst struct ce_attr ath12k_host_ce_config_wcn7850[] = {\n\t \n\t{\n\t\t.flags = CE_ATTR_FLAGS,\n\t\t.src_nentries = 16,\n\t\t.src_sz_max = 2048,\n\t\t.dest_nentries = 0,\n\t},\n\n\t \n\t{\n\t\t.flags = CE_ATTR_FLAGS,\n\t\t.src_nentries = 0,\n\t\t.src_sz_max = 2048,\n\t\t.dest_nentries = 512,\n\t\t.recv_cb = ath12k_htc_rx_completion_handler,\n\t},\n\n\t \n\t{\n\t\t.flags = CE_ATTR_FLAGS,\n\t\t.src_nentries = 0,\n\t\t.src_sz_max = 2048,\n\t\t.dest_nentries = 64,\n\t\t.recv_cb = ath12k_htc_rx_completion_handler,\n\t},\n\n\t \n\t{\n\t\t.flags = CE_ATTR_FLAGS,\n\t\t.src_nentries = 32,\n\t\t.src_sz_max = 2048,\n\t\t.dest_nentries = 0,\n\t},\n\n\t \n\t{\n\t\t.flags = CE_ATTR_FLAGS | CE_ATTR_DIS_INTR,\n\t\t.src_nentries = 2048,\n\t\t.src_sz_max = 256,\n\t\t.dest_nentries = 0,\n\t},\n\n\t \n\t{\n\t\t.flags = CE_ATTR_FLAGS,\n\t\t.src_nentries = 0,\n\t\t.src_sz_max = 0,\n\t\t.dest_nentries = 0,\n\t},\n\n\t \n\t{\n\t\t.flags = CE_ATTR_FLAGS | CE_ATTR_DIS_INTR,\n\t\t.src_nentries = 0,\n\t\t.src_sz_max = 0,\n\t\t.dest_nentries = 0,\n\t},\n\n\t \n\t{\n\t\t.flags = CE_ATTR_FLAGS | CE_ATTR_DIS_INTR,\n\t\t.src_nentries = 0,\n\t\t.src_sz_max = 2048,\n\t\t.dest_nentries = 0,\n\t},\n\n\t \n\t{\n\t\t.flags = CE_ATTR_FLAGS | CE_ATTR_DIS_INTR,\n\t\t.src_nentries = 0,\n\t\t.src_sz_max = 0,\n\t\t.dest_nentries = 0,\n\t},\n\n};\n\nstatic int ath12k_ce_rx_buf_enqueue_pipe(struct ath12k_ce_pipe *pipe,\n\t\t\t\t\t struct sk_buff *skb, dma_addr_t paddr)\n{\n\tstruct ath12k_base *ab = pipe->ab;\n\tstruct ath12k_ce_ring *ring = pipe->dest_ring;\n\tstruct hal_srng *srng;\n\tunsigned int write_index;\n\tunsigned int nentries_mask = ring->nentries_mask;\n\tstruct hal_ce_srng_dest_desc *desc;\n\tint ret;\n\n\tlockdep_assert_held(&ab->ce.ce_lock);\n\n\twrite_index = ring->write_index;\n\n\tsrng = &ab->hal.srng_list[ring->hal_ring_id];\n\n\tspin_lock_bh(&srng->lock);\n\n\tath12k_hal_srng_access_begin(ab, srng);\n\n\tif (unlikely(ath12k_hal_srng_src_num_free(ab, srng, false) < 1)) {\n\t\tret = -ENOSPC;\n\t\tgoto exit;\n\t}\n\n\tdesc = ath12k_hal_srng_src_get_next_entry(ab, srng);\n\tif (!desc) {\n\t\tret = -ENOSPC;\n\t\tgoto exit;\n\t}\n\n\tath12k_hal_ce_dst_set_desc(desc, paddr);\n\n\tring->skb[write_index] = skb;\n\twrite_index = CE_RING_IDX_INCR(nentries_mask, write_index);\n\tring->write_index = write_index;\n\n\tpipe->rx_buf_needed--;\n\n\tret = 0;\nexit:\n\tath12k_hal_srng_access_end(ab, srng);\n\n\tspin_unlock_bh(&srng->lock);\n\n\treturn ret;\n}\n\nstatic int ath12k_ce_rx_post_pipe(struct ath12k_ce_pipe *pipe)\n{\n\tstruct ath12k_base *ab = pipe->ab;\n\tstruct sk_buff *skb;\n\tdma_addr_t paddr;\n\tint ret = 0;\n\n\tif (!(pipe->dest_ring || pipe->status_ring))\n\t\treturn 0;\n\n\tspin_lock_bh(&ab->ce.ce_lock);\n\twhile (pipe->rx_buf_needed) {\n\t\tskb = dev_alloc_skb(pipe->buf_sz);\n\t\tif (!skb) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tWARN_ON_ONCE(!IS_ALIGNED((unsigned long)skb->data, 4));\n\n\t\tpaddr = dma_map_single(ab->dev, skb->data,\n\t\t\t\t       skb->len + skb_tailroom(skb),\n\t\t\t\t       DMA_FROM_DEVICE);\n\t\tif (unlikely(dma_mapping_error(ab->dev, paddr))) {\n\t\t\tath12k_warn(ab, \"failed to dma map ce rx buf\\n\");\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\tret = -EIO;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tATH12K_SKB_RXCB(skb)->paddr = paddr;\n\n\t\tret = ath12k_ce_rx_buf_enqueue_pipe(pipe, skb, paddr);\n\t\tif (ret) {\n\t\t\tath12k_warn(ab, \"failed to enqueue rx buf: %d\\n\", ret);\n\t\t\tdma_unmap_single(ab->dev, paddr,\n\t\t\t\t\t skb->len + skb_tailroom(skb),\n\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\nexit:\n\tspin_unlock_bh(&ab->ce.ce_lock);\n\treturn ret;\n}\n\nstatic int ath12k_ce_completed_recv_next(struct ath12k_ce_pipe *pipe,\n\t\t\t\t\t struct sk_buff **skb, int *nbytes)\n{\n\tstruct ath12k_base *ab = pipe->ab;\n\tstruct hal_ce_srng_dst_status_desc *desc;\n\tstruct hal_srng *srng;\n\tunsigned int sw_index;\n\tunsigned int nentries_mask;\n\tint ret = 0;\n\n\tspin_lock_bh(&ab->ce.ce_lock);\n\n\tsw_index = pipe->dest_ring->sw_index;\n\tnentries_mask = pipe->dest_ring->nentries_mask;\n\n\tsrng = &ab->hal.srng_list[pipe->status_ring->hal_ring_id];\n\n\tspin_lock_bh(&srng->lock);\n\n\tath12k_hal_srng_access_begin(ab, srng);\n\n\tdesc = ath12k_hal_srng_dst_get_next_entry(ab, srng);\n\tif (!desc) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t*nbytes = ath12k_hal_ce_dst_status_get_length(desc);\n\tif (*nbytes == 0) {\n\t\tret = -EIO;\n\t\tgoto err;\n\t}\n\n\t*skb = pipe->dest_ring->skb[sw_index];\n\tpipe->dest_ring->skb[sw_index] = NULL;\n\n\tsw_index = CE_RING_IDX_INCR(nentries_mask, sw_index);\n\tpipe->dest_ring->sw_index = sw_index;\n\n\tpipe->rx_buf_needed++;\nerr:\n\tath12k_hal_srng_access_end(ab, srng);\n\n\tspin_unlock_bh(&srng->lock);\n\n\tspin_unlock_bh(&ab->ce.ce_lock);\n\n\treturn ret;\n}\n\nstatic void ath12k_ce_recv_process_cb(struct ath12k_ce_pipe *pipe)\n{\n\tstruct ath12k_base *ab = pipe->ab;\n\tstruct sk_buff *skb;\n\tstruct sk_buff_head list;\n\tunsigned int nbytes, max_nbytes;\n\tint ret;\n\n\t__skb_queue_head_init(&list);\n\twhile (ath12k_ce_completed_recv_next(pipe, &skb, &nbytes) == 0) {\n\t\tmax_nbytes = skb->len + skb_tailroom(skb);\n\t\tdma_unmap_single(ab->dev, ATH12K_SKB_RXCB(skb)->paddr,\n\t\t\t\t max_nbytes, DMA_FROM_DEVICE);\n\n\t\tif (unlikely(max_nbytes < nbytes)) {\n\t\t\tath12k_warn(ab, \"rxed more than expected (nbytes %d, max %d)\",\n\t\t\t\t    nbytes, max_nbytes);\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tskb_put(skb, nbytes);\n\t\t__skb_queue_tail(&list, skb);\n\t}\n\n\twhile ((skb = __skb_dequeue(&list))) {\n\t\tath12k_dbg(ab, ATH12K_DBG_AHB, \"rx ce pipe %d len %d\\n\",\n\t\t\t   pipe->pipe_num, skb->len);\n\t\tpipe->recv_cb(ab, skb);\n\t}\n\n\tret = ath12k_ce_rx_post_pipe(pipe);\n\tif (ret && ret != -ENOSPC) {\n\t\tath12k_warn(ab, \"failed to post rx buf to pipe: %d err: %d\\n\",\n\t\t\t    pipe->pipe_num, ret);\n\t\tmod_timer(&ab->rx_replenish_retry,\n\t\t\t  jiffies + ATH12K_CE_RX_POST_RETRY_JIFFIES);\n\t}\n}\n\nstatic struct sk_buff *ath12k_ce_completed_send_next(struct ath12k_ce_pipe *pipe)\n{\n\tstruct ath12k_base *ab = pipe->ab;\n\tstruct hal_ce_srng_src_desc *desc;\n\tstruct hal_srng *srng;\n\tunsigned int sw_index;\n\tunsigned int nentries_mask;\n\tstruct sk_buff *skb;\n\n\tspin_lock_bh(&ab->ce.ce_lock);\n\n\tsw_index = pipe->src_ring->sw_index;\n\tnentries_mask = pipe->src_ring->nentries_mask;\n\n\tsrng = &ab->hal.srng_list[pipe->src_ring->hal_ring_id];\n\n\tspin_lock_bh(&srng->lock);\n\n\tath12k_hal_srng_access_begin(ab, srng);\n\n\tdesc = ath12k_hal_srng_src_reap_next(ab, srng);\n\tif (!desc) {\n\t\tskb = ERR_PTR(-EIO);\n\t\tgoto err_unlock;\n\t}\n\n\tskb = pipe->src_ring->skb[sw_index];\n\n\tpipe->src_ring->skb[sw_index] = NULL;\n\n\tsw_index = CE_RING_IDX_INCR(nentries_mask, sw_index);\n\tpipe->src_ring->sw_index = sw_index;\n\nerr_unlock:\n\tspin_unlock_bh(&srng->lock);\n\n\tspin_unlock_bh(&ab->ce.ce_lock);\n\n\treturn skb;\n}\n\nstatic void ath12k_ce_send_done_cb(struct ath12k_ce_pipe *pipe)\n{\n\tstruct ath12k_base *ab = pipe->ab;\n\tstruct sk_buff *skb;\n\n\twhile (!IS_ERR(skb = ath12k_ce_completed_send_next(pipe))) {\n\t\tif (!skb)\n\t\t\tcontinue;\n\n\t\tdma_unmap_single(ab->dev, ATH12K_SKB_CB(skb)->paddr, skb->len,\n\t\t\t\t DMA_TO_DEVICE);\n\t\tdev_kfree_skb_any(skb);\n\t}\n}\n\nstatic void ath12k_ce_srng_msi_ring_params_setup(struct ath12k_base *ab, u32 ce_id,\n\t\t\t\t\t\t struct hal_srng_params *ring_params)\n{\n\tu32 msi_data_start;\n\tu32 msi_data_count, msi_data_idx;\n\tu32 msi_irq_start;\n\tu32 addr_lo;\n\tu32 addr_hi;\n\tint ret;\n\n\tret = ath12k_hif_get_user_msi_vector(ab, \"CE\",\n\t\t\t\t\t     &msi_data_count, &msi_data_start,\n\t\t\t\t\t     &msi_irq_start);\n\n\tif (ret)\n\t\treturn;\n\n\tath12k_hif_get_msi_address(ab, &addr_lo, &addr_hi);\n\tath12k_hif_get_ce_msi_idx(ab, ce_id, &msi_data_idx);\n\n\tring_params->msi_addr = addr_lo;\n\tring_params->msi_addr |= (dma_addr_t)(((uint64_t)addr_hi) << 32);\n\tring_params->msi_data = (msi_data_idx % msi_data_count) + msi_data_start;\n\tring_params->flags |= HAL_SRNG_FLAGS_MSI_INTR;\n}\n\nstatic int ath12k_ce_init_ring(struct ath12k_base *ab,\n\t\t\t       struct ath12k_ce_ring *ce_ring,\n\t\t\t       int ce_id, enum hal_ring_type type)\n{\n\tstruct hal_srng_params params = { 0 };\n\tint ret;\n\n\tparams.ring_base_paddr = ce_ring->base_addr_ce_space;\n\tparams.ring_base_vaddr = ce_ring->base_addr_owner_space;\n\tparams.num_entries = ce_ring->nentries;\n\n\tif (!(CE_ATTR_DIS_INTR & ab->hw_params->host_ce_config[ce_id].flags))\n\t\tath12k_ce_srng_msi_ring_params_setup(ab, ce_id, &params);\n\n\tswitch (type) {\n\tcase HAL_CE_SRC:\n\t\tif (!(CE_ATTR_DIS_INTR & ab->hw_params->host_ce_config[ce_id].flags))\n\t\t\tparams.intr_batch_cntr_thres_entries = 1;\n\t\tbreak;\n\tcase HAL_CE_DST:\n\t\tparams.max_buffer_len = ab->hw_params->host_ce_config[ce_id].src_sz_max;\n\t\tif (!(ab->hw_params->host_ce_config[ce_id].flags & CE_ATTR_DIS_INTR)) {\n\t\t\tparams.intr_timer_thres_us = 1024;\n\t\t\tparams.flags |= HAL_SRNG_FLAGS_LOW_THRESH_INTR_EN;\n\t\t\tparams.low_threshold = ce_ring->nentries - 3;\n\t\t}\n\t\tbreak;\n\tcase HAL_CE_DST_STATUS:\n\t\tif (!(ab->hw_params->host_ce_config[ce_id].flags & CE_ATTR_DIS_INTR)) {\n\t\t\tparams.intr_batch_cntr_thres_entries = 1;\n\t\t\tparams.intr_timer_thres_us = 0x1000;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tath12k_warn(ab, \"Invalid CE ring type %d\\n\", type);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\n\tret = ath12k_hal_srng_setup(ab, type, ce_id, 0, &params);\n\tif (ret < 0) {\n\t\tath12k_warn(ab, \"failed to setup srng: %d ring_id %d\\n\",\n\t\t\t    ret, ce_id);\n\t\treturn ret;\n\t}\n\n\tce_ring->hal_ring_id = ret;\n\n\treturn 0;\n}\n\nstatic struct ath12k_ce_ring *\nath12k_ce_alloc_ring(struct ath12k_base *ab, int nentries, int desc_sz)\n{\n\tstruct ath12k_ce_ring *ce_ring;\n\tdma_addr_t base_addr;\n\n\tce_ring = kzalloc(struct_size(ce_ring, skb, nentries), GFP_KERNEL);\n\tif (!ce_ring)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tce_ring->nentries = nentries;\n\tce_ring->nentries_mask = nentries - 1;\n\n\t \n\tce_ring->base_addr_owner_space_unaligned =\n\t\tdma_alloc_coherent(ab->dev,\n\t\t\t\t   nentries * desc_sz + CE_DESC_RING_ALIGN,\n\t\t\t\t   &base_addr, GFP_KERNEL);\n\tif (!ce_ring->base_addr_owner_space_unaligned) {\n\t\tkfree(ce_ring);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tce_ring->base_addr_ce_space_unaligned = base_addr;\n\n\tce_ring->base_addr_owner_space =\n\t\tPTR_ALIGN(ce_ring->base_addr_owner_space_unaligned,\n\t\t\t  CE_DESC_RING_ALIGN);\n\n\tce_ring->base_addr_ce_space = ALIGN(ce_ring->base_addr_ce_space_unaligned,\n\t\t\t\t\t    CE_DESC_RING_ALIGN);\n\n\treturn ce_ring;\n}\n\nstatic int ath12k_ce_alloc_pipe(struct ath12k_base *ab, int ce_id)\n{\n\tstruct ath12k_ce_pipe *pipe = &ab->ce.ce_pipe[ce_id];\n\tconst struct ce_attr *attr = &ab->hw_params->host_ce_config[ce_id];\n\tstruct ath12k_ce_ring *ring;\n\tint nentries;\n\tint desc_sz;\n\n\tpipe->attr_flags = attr->flags;\n\n\tif (attr->src_nentries) {\n\t\tpipe->send_cb = ath12k_ce_send_done_cb;\n\t\tnentries = roundup_pow_of_two(attr->src_nentries);\n\t\tdesc_sz = ath12k_hal_ce_get_desc_size(HAL_CE_DESC_SRC);\n\t\tring = ath12k_ce_alloc_ring(ab, nentries, desc_sz);\n\t\tif (IS_ERR(ring))\n\t\t\treturn PTR_ERR(ring);\n\t\tpipe->src_ring = ring;\n\t}\n\n\tif (attr->dest_nentries) {\n\t\tpipe->recv_cb = attr->recv_cb;\n\t\tnentries = roundup_pow_of_two(attr->dest_nentries);\n\t\tdesc_sz = ath12k_hal_ce_get_desc_size(HAL_CE_DESC_DST);\n\t\tring = ath12k_ce_alloc_ring(ab, nentries, desc_sz);\n\t\tif (IS_ERR(ring))\n\t\t\treturn PTR_ERR(ring);\n\t\tpipe->dest_ring = ring;\n\n\t\tdesc_sz = ath12k_hal_ce_get_desc_size(HAL_CE_DESC_DST_STATUS);\n\t\tring = ath12k_ce_alloc_ring(ab, nentries, desc_sz);\n\t\tif (IS_ERR(ring))\n\t\t\treturn PTR_ERR(ring);\n\t\tpipe->status_ring = ring;\n\t}\n\n\treturn 0;\n}\n\nvoid ath12k_ce_per_engine_service(struct ath12k_base *ab, u16 ce_id)\n{\n\tstruct ath12k_ce_pipe *pipe = &ab->ce.ce_pipe[ce_id];\n\n\tif (pipe->send_cb)\n\t\tpipe->send_cb(pipe);\n\n\tif (pipe->recv_cb)\n\t\tath12k_ce_recv_process_cb(pipe);\n}\n\nvoid ath12k_ce_poll_send_completed(struct ath12k_base *ab, u8 pipe_id)\n{\n\tstruct ath12k_ce_pipe *pipe = &ab->ce.ce_pipe[pipe_id];\n\n\tif ((pipe->attr_flags & CE_ATTR_DIS_INTR) && pipe->send_cb)\n\t\tpipe->send_cb(pipe);\n}\n\nint ath12k_ce_send(struct ath12k_base *ab, struct sk_buff *skb, u8 pipe_id,\n\t\t   u16 transfer_id)\n{\n\tstruct ath12k_ce_pipe *pipe = &ab->ce.ce_pipe[pipe_id];\n\tstruct hal_ce_srng_src_desc *desc;\n\tstruct hal_srng *srng;\n\tunsigned int write_index, sw_index;\n\tunsigned int nentries_mask;\n\tint ret = 0;\n\tu8 byte_swap_data = 0;\n\tint num_used;\n\n\t \n\tif (pipe->attr_flags & CE_ATTR_DIS_INTR) {\n\t\tspin_lock_bh(&ab->ce.ce_lock);\n\t\twrite_index = pipe->src_ring->write_index;\n\n\t\tsw_index = pipe->src_ring->sw_index;\n\n\t\tif (write_index >= sw_index)\n\t\t\tnum_used = write_index - sw_index;\n\t\telse\n\t\t\tnum_used = pipe->src_ring->nentries - sw_index +\n\t\t\t\t   write_index;\n\n\t\tspin_unlock_bh(&ab->ce.ce_lock);\n\n\t\tif (num_used > ATH12K_CE_USAGE_THRESHOLD)\n\t\t\tath12k_ce_poll_send_completed(ab, pipe->pipe_num);\n\t}\n\n\tif (test_bit(ATH12K_FLAG_CRASH_FLUSH, &ab->dev_flags))\n\t\treturn -ESHUTDOWN;\n\n\tspin_lock_bh(&ab->ce.ce_lock);\n\n\twrite_index = pipe->src_ring->write_index;\n\tnentries_mask = pipe->src_ring->nentries_mask;\n\n\tsrng = &ab->hal.srng_list[pipe->src_ring->hal_ring_id];\n\n\tspin_lock_bh(&srng->lock);\n\n\tath12k_hal_srng_access_begin(ab, srng);\n\n\tif (unlikely(ath12k_hal_srng_src_num_free(ab, srng, false) < 1)) {\n\t\tath12k_hal_srng_access_end(ab, srng);\n\t\tret = -ENOBUFS;\n\t\tgoto unlock;\n\t}\n\n\tdesc = ath12k_hal_srng_src_get_next_reaped(ab, srng);\n\tif (!desc) {\n\t\tath12k_hal_srng_access_end(ab, srng);\n\t\tret = -ENOBUFS;\n\t\tgoto unlock;\n\t}\n\n\tif (pipe->attr_flags & CE_ATTR_BYTE_SWAP_DATA)\n\t\tbyte_swap_data = 1;\n\n\tath12k_hal_ce_src_set_desc(desc, ATH12K_SKB_CB(skb)->paddr,\n\t\t\t\t   skb->len, transfer_id, byte_swap_data);\n\n\tpipe->src_ring->skb[write_index] = skb;\n\tpipe->src_ring->write_index = CE_RING_IDX_INCR(nentries_mask,\n\t\t\t\t\t\t       write_index);\n\n\tath12k_hal_srng_access_end(ab, srng);\n\nunlock:\n\tspin_unlock_bh(&srng->lock);\n\n\tspin_unlock_bh(&ab->ce.ce_lock);\n\n\treturn ret;\n}\n\nstatic void ath12k_ce_rx_pipe_cleanup(struct ath12k_ce_pipe *pipe)\n{\n\tstruct ath12k_base *ab = pipe->ab;\n\tstruct ath12k_ce_ring *ring = pipe->dest_ring;\n\tstruct sk_buff *skb;\n\tint i;\n\n\tif (!(ring && pipe->buf_sz))\n\t\treturn;\n\n\tfor (i = 0; i < ring->nentries; i++) {\n\t\tskb = ring->skb[i];\n\t\tif (!skb)\n\t\t\tcontinue;\n\n\t\tring->skb[i] = NULL;\n\t\tdma_unmap_single(ab->dev, ATH12K_SKB_RXCB(skb)->paddr,\n\t\t\t\t skb->len + skb_tailroom(skb), DMA_FROM_DEVICE);\n\t\tdev_kfree_skb_any(skb);\n\t}\n}\n\nvoid ath12k_ce_cleanup_pipes(struct ath12k_base *ab)\n{\n\tstruct ath12k_ce_pipe *pipe;\n\tint pipe_num;\n\n\tfor (pipe_num = 0; pipe_num < ab->hw_params->ce_count; pipe_num++) {\n\t\tpipe = &ab->ce.ce_pipe[pipe_num];\n\t\tath12k_ce_rx_pipe_cleanup(pipe);\n\n\t\t \n\t\tath12k_ce_poll_send_completed(ab, pipe_num);\n\n\t\t \n\t}\n}\n\nvoid ath12k_ce_rx_post_buf(struct ath12k_base *ab)\n{\n\tstruct ath12k_ce_pipe *pipe;\n\tint i;\n\tint ret;\n\n\tfor (i = 0; i < ab->hw_params->ce_count; i++) {\n\t\tpipe = &ab->ce.ce_pipe[i];\n\t\tret = ath12k_ce_rx_post_pipe(pipe);\n\t\tif (ret) {\n\t\t\tif (ret == -ENOSPC)\n\t\t\t\tcontinue;\n\n\t\t\tath12k_warn(ab, \"failed to post rx buf to pipe: %d err: %d\\n\",\n\t\t\t\t    i, ret);\n\t\t\tmod_timer(&ab->rx_replenish_retry,\n\t\t\t\t  jiffies + ATH12K_CE_RX_POST_RETRY_JIFFIES);\n\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nvoid ath12k_ce_rx_replenish_retry(struct timer_list *t)\n{\n\tstruct ath12k_base *ab = from_timer(ab, t, rx_replenish_retry);\n\n\tath12k_ce_rx_post_buf(ab);\n}\n\nstatic void ath12k_ce_shadow_config(struct ath12k_base *ab)\n{\n\tint i;\n\n\tfor (i = 0; i < ab->hw_params->ce_count; i++) {\n\t\tif (ab->hw_params->host_ce_config[i].src_nentries)\n\t\t\tath12k_hal_srng_update_shadow_config(ab, HAL_CE_SRC, i);\n\n\t\tif (ab->hw_params->host_ce_config[i].dest_nentries) {\n\t\t\tath12k_hal_srng_update_shadow_config(ab, HAL_CE_DST, i);\n\t\t\tath12k_hal_srng_update_shadow_config(ab, HAL_CE_DST_STATUS, i);\n\t\t}\n\t}\n}\n\nvoid ath12k_ce_get_shadow_config(struct ath12k_base *ab,\n\t\t\t\t u32 **shadow_cfg, u32 *shadow_cfg_len)\n{\n\tif (!ab->hw_params->supports_shadow_regs)\n\t\treturn;\n\n\tath12k_hal_srng_get_shadow_config(ab, shadow_cfg, shadow_cfg_len);\n\n\t \n\tif (*shadow_cfg_len)\n\t\treturn;\n\n\t \n\tath12k_hal_srng_shadow_config(ab);\n\tath12k_ce_shadow_config(ab);\n\n\t \n\tath12k_hal_srng_get_shadow_config(ab, shadow_cfg, shadow_cfg_len);\n}\n\nint ath12k_ce_init_pipes(struct ath12k_base *ab)\n{\n\tstruct ath12k_ce_pipe *pipe;\n\tint i;\n\tint ret;\n\n\tath12k_ce_get_shadow_config(ab, &ab->qmi.ce_cfg.shadow_reg_v3,\n\t\t\t\t    &ab->qmi.ce_cfg.shadow_reg_v3_len);\n\n\tfor (i = 0; i < ab->hw_params->ce_count; i++) {\n\t\tpipe = &ab->ce.ce_pipe[i];\n\n\t\tif (pipe->src_ring) {\n\t\t\tret = ath12k_ce_init_ring(ab, pipe->src_ring, i,\n\t\t\t\t\t\t  HAL_CE_SRC);\n\t\t\tif (ret) {\n\t\t\t\tath12k_warn(ab, \"failed to init src ring: %d\\n\",\n\t\t\t\t\t    ret);\n\t\t\t\t \n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tpipe->src_ring->write_index = 0;\n\t\t\tpipe->src_ring->sw_index = 0;\n\t\t}\n\n\t\tif (pipe->dest_ring) {\n\t\t\tret = ath12k_ce_init_ring(ab, pipe->dest_ring, i,\n\t\t\t\t\t\t  HAL_CE_DST);\n\t\t\tif (ret) {\n\t\t\t\tath12k_warn(ab, \"failed to init dest ring: %d\\n\",\n\t\t\t\t\t    ret);\n\t\t\t\t \n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tpipe->rx_buf_needed = pipe->dest_ring->nentries ?\n\t\t\t\t\t      pipe->dest_ring->nentries - 2 : 0;\n\n\t\t\tpipe->dest_ring->write_index = 0;\n\t\t\tpipe->dest_ring->sw_index = 0;\n\t\t}\n\n\t\tif (pipe->status_ring) {\n\t\t\tret = ath12k_ce_init_ring(ab, pipe->status_ring, i,\n\t\t\t\t\t\t  HAL_CE_DST_STATUS);\n\t\t\tif (ret) {\n\t\t\t\tath12k_warn(ab, \"failed to init dest status ing: %d\\n\",\n\t\t\t\t\t    ret);\n\t\t\t\t \n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tpipe->status_ring->write_index = 0;\n\t\t\tpipe->status_ring->sw_index = 0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid ath12k_ce_free_pipes(struct ath12k_base *ab)\n{\n\tstruct ath12k_ce_pipe *pipe;\n\tint desc_sz;\n\tint i;\n\n\tfor (i = 0; i < ab->hw_params->ce_count; i++) {\n\t\tpipe = &ab->ce.ce_pipe[i];\n\n\t\tif (pipe->src_ring) {\n\t\t\tdesc_sz = ath12k_hal_ce_get_desc_size(HAL_CE_DESC_SRC);\n\t\t\tdma_free_coherent(ab->dev,\n\t\t\t\t\t  pipe->src_ring->nentries * desc_sz +\n\t\t\t\t\t  CE_DESC_RING_ALIGN,\n\t\t\t\t\t  pipe->src_ring->base_addr_owner_space,\n\t\t\t\t\t  pipe->src_ring->base_addr_ce_space);\n\t\t\tkfree(pipe->src_ring);\n\t\t\tpipe->src_ring = NULL;\n\t\t}\n\n\t\tif (pipe->dest_ring) {\n\t\t\tdesc_sz = ath12k_hal_ce_get_desc_size(HAL_CE_DESC_DST);\n\t\t\tdma_free_coherent(ab->dev,\n\t\t\t\t\t  pipe->dest_ring->nentries * desc_sz +\n\t\t\t\t\t  CE_DESC_RING_ALIGN,\n\t\t\t\t\t  pipe->dest_ring->base_addr_owner_space,\n\t\t\t\t\t  pipe->dest_ring->base_addr_ce_space);\n\t\t\tkfree(pipe->dest_ring);\n\t\t\tpipe->dest_ring = NULL;\n\t\t}\n\n\t\tif (pipe->status_ring) {\n\t\t\tdesc_sz =\n\t\t\t  ath12k_hal_ce_get_desc_size(HAL_CE_DESC_DST_STATUS);\n\t\t\tdma_free_coherent(ab->dev,\n\t\t\t\t\t  pipe->status_ring->nentries * desc_sz +\n\t\t\t\t\t  CE_DESC_RING_ALIGN,\n\t\t\t\t\t  pipe->status_ring->base_addr_owner_space,\n\t\t\t\t\t  pipe->status_ring->base_addr_ce_space);\n\t\t\tkfree(pipe->status_ring);\n\t\t\tpipe->status_ring = NULL;\n\t\t}\n\t}\n}\n\nint ath12k_ce_alloc_pipes(struct ath12k_base *ab)\n{\n\tstruct ath12k_ce_pipe *pipe;\n\tint i;\n\tint ret;\n\tconst struct ce_attr *attr;\n\n\tspin_lock_init(&ab->ce.ce_lock);\n\n\tfor (i = 0; i < ab->hw_params->ce_count; i++) {\n\t\tattr = &ab->hw_params->host_ce_config[i];\n\t\tpipe = &ab->ce.ce_pipe[i];\n\t\tpipe->pipe_num = i;\n\t\tpipe->ab = ab;\n\t\tpipe->buf_sz = attr->src_sz_max;\n\n\t\tret = ath12k_ce_alloc_pipe(ab, i);\n\t\tif (ret) {\n\t\t\t \n\t\t\tath12k_ce_free_pipes(ab);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint ath12k_ce_get_attr_flags(struct ath12k_base *ab, int ce_id)\n{\n\tif (ce_id >= ab->hw_params->ce_count)\n\t\treturn -EINVAL;\n\n\treturn ab->hw_params->host_ce_config[ce_id].flags;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}