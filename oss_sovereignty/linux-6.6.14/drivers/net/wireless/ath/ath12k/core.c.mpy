{
  "module_name": "core.c",
  "hash_id": "3c3e40e7a45fbe63d178abe7766b73f8980fb9ecbd0122e35a3fd917118508d3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath12k/core.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/remoteproc.h>\n#include <linux/firmware.h>\n#include <linux/of.h>\n#include \"core.h\"\n#include \"dp_tx.h\"\n#include \"dp_rx.h\"\n#include \"debug.h\"\n#include \"hif.h\"\n\nunsigned int ath12k_debug_mask;\nmodule_param_named(debug_mask, ath12k_debug_mask, uint, 0644);\nMODULE_PARM_DESC(debug_mask, \"Debugging mask\");\n\nint ath12k_core_suspend(struct ath12k_base *ab)\n{\n\tint ret;\n\n\tif (!ab->hw_params->supports_suspend)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tmsleep(500);\n\n\tret = ath12k_dp_rx_pktlog_stop(ab, true);\n\tif (ret) {\n\t\tath12k_warn(ab, \"failed to stop dp rx (and timer) pktlog during suspend: %d\\n\",\n\t\t\t    ret);\n\t\treturn ret;\n\t}\n\n\tret = ath12k_dp_rx_pktlog_stop(ab, false);\n\tif (ret) {\n\t\tath12k_warn(ab, \"failed to stop dp rx pktlog during suspend: %d\\n\",\n\t\t\t    ret);\n\t\treturn ret;\n\t}\n\n\tath12k_hif_irq_disable(ab);\n\tath12k_hif_ce_irq_disable(ab);\n\n\tret = ath12k_hif_suspend(ab);\n\tif (ret) {\n\t\tath12k_warn(ab, \"failed to suspend hif: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint ath12k_core_resume(struct ath12k_base *ab)\n{\n\tint ret;\n\n\tif (!ab->hw_params->supports_suspend)\n\t\treturn -EOPNOTSUPP;\n\n\tret = ath12k_hif_resume(ab);\n\tif (ret) {\n\t\tath12k_warn(ab, \"failed to resume hif during resume: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tath12k_hif_ce_irq_enable(ab);\n\tath12k_hif_irq_enable(ab);\n\n\tret = ath12k_dp_rx_pktlog_start(ab);\n\tif (ret) {\n\t\tath12k_warn(ab, \"failed to start rx pktlog during resume: %d\\n\",\n\t\t\t    ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath12k_core_create_board_name(struct ath12k_base *ab, char *name,\n\t\t\t\t\t size_t name_len)\n{\n\t \n\tchar variant[9 + ATH12K_QMI_BDF_EXT_STR_LENGTH] = { 0 };\n\n\tif (ab->qmi.target.bdf_ext[0] != '\\0')\n\t\tscnprintf(variant, sizeof(variant), \",variant=%s\",\n\t\t\t  ab->qmi.target.bdf_ext);\n\n\tscnprintf(name, name_len,\n\t\t  \"bus=%s,qmi-chip-id=%d,qmi-board-id=%d%s\",\n\t\t  ath12k_bus_str(ab->hif.bus),\n\t\t  ab->qmi.target.chip_id,\n\t\t  ab->qmi.target.board_id, variant);\n\n\tath12k_dbg(ab, ATH12K_DBG_BOOT, \"boot using board name '%s'\\n\", name);\n\n\treturn 0;\n}\n\nconst struct firmware *ath12k_core_firmware_request(struct ath12k_base *ab,\n\t\t\t\t\t\t    const char *file)\n{\n\tconst struct firmware *fw;\n\tchar path[100];\n\tint ret;\n\n\tif (!file)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tath12k_core_create_firmware_path(ab, file, path, sizeof(path));\n\n\tret = firmware_request_nowarn(&fw, path, ab->dev);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tath12k_dbg(ab, ATH12K_DBG_BOOT, \"boot firmware request %s size %zu\\n\",\n\t\t   path, fw->size);\n\n\treturn fw;\n}\n\nvoid ath12k_core_free_bdf(struct ath12k_base *ab, struct ath12k_board_data *bd)\n{\n\tif (!IS_ERR(bd->fw))\n\t\trelease_firmware(bd->fw);\n\n\tmemset(bd, 0, sizeof(*bd));\n}\n\nstatic int ath12k_core_parse_bd_ie_board(struct ath12k_base *ab,\n\t\t\t\t\t struct ath12k_board_data *bd,\n\t\t\t\t\t const void *buf, size_t buf_len,\n\t\t\t\t\t const char *boardname,\n\t\t\t\t\t int bd_ie_type)\n{\n\tconst struct ath12k_fw_ie *hdr;\n\tbool name_match_found;\n\tint ret, board_ie_id;\n\tsize_t board_ie_len;\n\tconst void *board_ie_data;\n\n\tname_match_found = false;\n\n\t \n\twhile (buf_len > sizeof(struct ath12k_fw_ie)) {\n\t\thdr = buf;\n\t\tboard_ie_id = le32_to_cpu(hdr->id);\n\t\tboard_ie_len = le32_to_cpu(hdr->len);\n\t\tboard_ie_data = hdr->data;\n\n\t\tbuf_len -= sizeof(*hdr);\n\t\tbuf += sizeof(*hdr);\n\n\t\tif (buf_len < ALIGN(board_ie_len, 4)) {\n\t\t\tath12k_err(ab, \"invalid ATH12K_BD_IE_BOARD length: %zu < %zu\\n\",\n\t\t\t\t   buf_len, ALIGN(board_ie_len, 4));\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tswitch (board_ie_id) {\n\t\tcase ATH12K_BD_IE_BOARD_NAME:\n\t\t\tath12k_dbg_dump(ab, ATH12K_DBG_BOOT, \"board name\", \"\",\n\t\t\t\t\tboard_ie_data, board_ie_len);\n\n\t\t\tif (board_ie_len != strlen(boardname))\n\t\t\t\tbreak;\n\n\t\t\tret = memcmp(board_ie_data, boardname, strlen(boardname));\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\tname_match_found = true;\n\t\t\tath12k_dbg(ab, ATH12K_DBG_BOOT,\n\t\t\t\t   \"boot found match for name '%s'\",\n\t\t\t\t   boardname);\n\t\t\tbreak;\n\t\tcase ATH12K_BD_IE_BOARD_DATA:\n\t\t\tif (!name_match_found)\n\t\t\t\t \n\t\t\t\tbreak;\n\n\t\t\tath12k_dbg(ab, ATH12K_DBG_BOOT,\n\t\t\t\t   \"boot found board data for '%s'\", boardname);\n\n\t\t\tbd->data = board_ie_data;\n\t\t\tbd->len = board_ie_len;\n\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\tath12k_warn(ab, \"unknown ATH12K_BD_IE_BOARD found: %d\\n\",\n\t\t\t\t    board_ie_id);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tboard_ie_len = ALIGN(board_ie_len, 4);\n\n\t\tbuf_len -= board_ie_len;\n\t\tbuf += board_ie_len;\n\t}\n\n\t \n\tret = -ENOENT;\n\nout:\n\treturn ret;\n}\n\nstatic int ath12k_core_fetch_board_data_api_n(struct ath12k_base *ab,\n\t\t\t\t\t      struct ath12k_board_data *bd,\n\t\t\t\t\t      const char *boardname)\n{\n\tsize_t len, magic_len;\n\tconst u8 *data;\n\tchar *filename, filepath[100];\n\tsize_t ie_len;\n\tstruct ath12k_fw_ie *hdr;\n\tint ret, ie_id;\n\n\tfilename = ATH12K_BOARD_API2_FILE;\n\n\tif (!bd->fw)\n\t\tbd->fw = ath12k_core_firmware_request(ab, filename);\n\n\tif (IS_ERR(bd->fw))\n\t\treturn PTR_ERR(bd->fw);\n\n\tdata = bd->fw->data;\n\tlen = bd->fw->size;\n\n\tath12k_core_create_firmware_path(ab, filename,\n\t\t\t\t\t filepath, sizeof(filepath));\n\n\t \n\tmagic_len = strlen(ATH12K_BOARD_MAGIC) + 1;\n\tif (len < magic_len) {\n\t\tath12k_err(ab, \"failed to find magic value in %s, file too short: %zu\\n\",\n\t\t\t   filepath, len);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (memcmp(data, ATH12K_BOARD_MAGIC, magic_len)) {\n\t\tath12k_err(ab, \"found invalid board magic\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t \n\tmagic_len = ALIGN(magic_len, 4);\n\tif (len < magic_len) {\n\t\tath12k_err(ab, \"failed: %s too small to contain board data, len: %zu\\n\",\n\t\t\t   filepath, len);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tdata += magic_len;\n\tlen -= magic_len;\n\n\twhile (len > sizeof(struct ath12k_fw_ie)) {\n\t\thdr = (struct ath12k_fw_ie *)data;\n\t\tie_id = le32_to_cpu(hdr->id);\n\t\tie_len = le32_to_cpu(hdr->len);\n\n\t\tlen -= sizeof(*hdr);\n\t\tdata = hdr->data;\n\n\t\tif (len < ALIGN(ie_len, 4)) {\n\t\t\tath12k_err(ab, \"invalid length for board ie_id %d ie_len %zu len %zu\\n\",\n\t\t\t\t   ie_id, ie_len, len);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tswitch (ie_id) {\n\t\tcase ATH12K_BD_IE_BOARD:\n\t\t\tret = ath12k_core_parse_bd_ie_board(ab, bd, data,\n\t\t\t\t\t\t\t    ie_len,\n\t\t\t\t\t\t\t    boardname,\n\t\t\t\t\t\t\t    ATH12K_BD_IE_BOARD);\n\t\t\tif (ret == -ENOENT)\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\telse if (ret)\n\t\t\t\t \n\t\t\t\tgoto err;\n\t\t\t \n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tie_len = ALIGN(ie_len, 4);\n\n\t\tlen -= ie_len;\n\t\tdata += ie_len;\n\t}\n\nout:\n\tif (!bd->data || !bd->len) {\n\t\tath12k_err(ab,\n\t\t\t   \"failed to fetch board data for %s from %s\\n\",\n\t\t\t   boardname, filepath);\n\t\tret = -ENODATA;\n\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tath12k_core_free_bdf(ab, bd);\n\treturn ret;\n}\n\nint ath12k_core_fetch_board_data_api_1(struct ath12k_base *ab,\n\t\t\t\t       struct ath12k_board_data *bd,\n\t\t\t\t       char *filename)\n{\n\tbd->fw = ath12k_core_firmware_request(ab, filename);\n\tif (IS_ERR(bd->fw))\n\t\treturn PTR_ERR(bd->fw);\n\n\tbd->data = bd->fw->data;\n\tbd->len = bd->fw->size;\n\n\treturn 0;\n}\n\n#define BOARD_NAME_SIZE 100\nint ath12k_core_fetch_bdf(struct ath12k_base *ab, struct ath12k_board_data *bd)\n{\n\tchar boardname[BOARD_NAME_SIZE];\n\tint ret;\n\n\tret = ath12k_core_create_board_name(ab, boardname, BOARD_NAME_SIZE);\n\tif (ret) {\n\t\tath12k_err(ab, \"failed to create board name: %d\", ret);\n\t\treturn ret;\n\t}\n\n\tab->bd_api = 2;\n\tret = ath12k_core_fetch_board_data_api_n(ab, bd, boardname);\n\tif (!ret)\n\t\tgoto success;\n\n\tab->bd_api = 1;\n\tret = ath12k_core_fetch_board_data_api_1(ab, bd, ATH12K_DEFAULT_BOARD_FILE);\n\tif (ret) {\n\t\tath12k_err(ab, \"failed to fetch board-2.bin or board.bin from %s\\n\",\n\t\t\t   ab->hw_params->fw.dir);\n\t\treturn ret;\n\t}\n\nsuccess:\n\tath12k_dbg(ab, ATH12K_DBG_BOOT, \"using board api %d\\n\", ab->bd_api);\n\treturn 0;\n}\n\nstatic void ath12k_core_stop(struct ath12k_base *ab)\n{\n\tif (!test_bit(ATH12K_FLAG_CRASH_FLUSH, &ab->dev_flags))\n\t\tath12k_qmi_firmware_stop(ab);\n\n\tath12k_hif_stop(ab);\n\tath12k_wmi_detach(ab);\n\tath12k_dp_rx_pdev_reo_cleanup(ab);\n\n\t \n}\n\nstatic int ath12k_core_soc_create(struct ath12k_base *ab)\n{\n\tint ret;\n\n\tret = ath12k_qmi_init_service(ab);\n\tif (ret) {\n\t\tath12k_err(ab, \"failed to initialize qmi :%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ath12k_hif_power_up(ab);\n\tif (ret) {\n\t\tath12k_err(ab, \"failed to power up :%d\\n\", ret);\n\t\tgoto err_qmi_deinit;\n\t}\n\n\treturn 0;\n\nerr_qmi_deinit:\n\tath12k_qmi_deinit_service(ab);\n\treturn ret;\n}\n\nstatic void ath12k_core_soc_destroy(struct ath12k_base *ab)\n{\n\tath12k_dp_free(ab);\n\tath12k_reg_free(ab);\n\tath12k_qmi_deinit_service(ab);\n}\n\nstatic int ath12k_core_pdev_create(struct ath12k_base *ab)\n{\n\tint ret;\n\n\tret = ath12k_mac_register(ab);\n\tif (ret) {\n\t\tath12k_err(ab, \"failed register the radio with mac80211: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ath12k_dp_pdev_alloc(ab);\n\tif (ret) {\n\t\tath12k_err(ab, \"failed to attach DP pdev: %d\\n\", ret);\n\t\tgoto err_mac_unregister;\n\t}\n\n\treturn 0;\n\nerr_mac_unregister:\n\tath12k_mac_unregister(ab);\n\n\treturn ret;\n}\n\nstatic void ath12k_core_pdev_destroy(struct ath12k_base *ab)\n{\n\tath12k_mac_unregister(ab);\n\tath12k_hif_irq_disable(ab);\n\tath12k_dp_pdev_free(ab);\n}\n\nstatic int ath12k_core_start(struct ath12k_base *ab,\n\t\t\t     enum ath12k_firmware_mode mode)\n{\n\tint ret;\n\n\tret = ath12k_wmi_attach(ab);\n\tif (ret) {\n\t\tath12k_err(ab, \"failed to attach wmi: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ath12k_htc_init(ab);\n\tif (ret) {\n\t\tath12k_err(ab, \"failed to init htc: %d\\n\", ret);\n\t\tgoto err_wmi_detach;\n\t}\n\n\tret = ath12k_hif_start(ab);\n\tif (ret) {\n\t\tath12k_err(ab, \"failed to start HIF: %d\\n\", ret);\n\t\tgoto err_wmi_detach;\n\t}\n\n\tret = ath12k_htc_wait_target(&ab->htc);\n\tif (ret) {\n\t\tath12k_err(ab, \"failed to connect to HTC: %d\\n\", ret);\n\t\tgoto err_hif_stop;\n\t}\n\n\tret = ath12k_dp_htt_connect(&ab->dp);\n\tif (ret) {\n\t\tath12k_err(ab, \"failed to connect to HTT: %d\\n\", ret);\n\t\tgoto err_hif_stop;\n\t}\n\n\tret = ath12k_wmi_connect(ab);\n\tif (ret) {\n\t\tath12k_err(ab, \"failed to connect wmi: %d\\n\", ret);\n\t\tgoto err_hif_stop;\n\t}\n\n\tret = ath12k_htc_start(&ab->htc);\n\tif (ret) {\n\t\tath12k_err(ab, \"failed to start HTC: %d\\n\", ret);\n\t\tgoto err_hif_stop;\n\t}\n\n\tret = ath12k_wmi_wait_for_service_ready(ab);\n\tif (ret) {\n\t\tath12k_err(ab, \"failed to receive wmi service ready event: %d\\n\",\n\t\t\t   ret);\n\t\tgoto err_hif_stop;\n\t}\n\n\tret = ath12k_mac_allocate(ab);\n\tif (ret) {\n\t\tath12k_err(ab, \"failed to create new hw device with mac80211 :%d\\n\",\n\t\t\t   ret);\n\t\tgoto err_hif_stop;\n\t}\n\n\tath12k_dp_cc_config(ab);\n\n\tath12k_dp_pdev_pre_alloc(ab);\n\n\tret = ath12k_dp_rx_pdev_reo_setup(ab);\n\tif (ret) {\n\t\tath12k_err(ab, \"failed to initialize reo destination rings: %d\\n\", ret);\n\t\tgoto err_mac_destroy;\n\t}\n\n\tret = ath12k_wmi_cmd_init(ab);\n\tif (ret) {\n\t\tath12k_err(ab, \"failed to send wmi init cmd: %d\\n\", ret);\n\t\tgoto err_reo_cleanup;\n\t}\n\n\tret = ath12k_wmi_wait_for_unified_ready(ab);\n\tif (ret) {\n\t\tath12k_err(ab, \"failed to receive wmi unified ready event: %d\\n\",\n\t\t\t   ret);\n\t\tgoto err_reo_cleanup;\n\t}\n\n\t \n\tif (ab->hw_params->single_pdev_only) {\n\t\tret = ath12k_wmi_set_hw_mode(ab, WMI_HOST_HW_MODE_DBS);\n\t\tif (ret) {\n\t\t\tath12k_err(ab, \"failed to send dbs mode: %d\\n\", ret);\n\t\t\tgoto err_reo_cleanup;\n\t\t}\n\t}\n\n\tret = ath12k_dp_tx_htt_h2t_ver_req_msg(ab);\n\tif (ret) {\n\t\tath12k_err(ab, \"failed to send htt version request message: %d\\n\",\n\t\t\t   ret);\n\t\tgoto err_reo_cleanup;\n\t}\n\n\treturn 0;\n\nerr_reo_cleanup:\n\tath12k_dp_rx_pdev_reo_cleanup(ab);\nerr_mac_destroy:\n\tath12k_mac_destroy(ab);\nerr_hif_stop:\n\tath12k_hif_stop(ab);\nerr_wmi_detach:\n\tath12k_wmi_detach(ab);\n\treturn ret;\n}\n\nstatic int ath12k_core_start_firmware(struct ath12k_base *ab,\n\t\t\t\t      enum ath12k_firmware_mode mode)\n{\n\tint ret;\n\n\tath12k_ce_get_shadow_config(ab, &ab->qmi.ce_cfg.shadow_reg_v3,\n\t\t\t\t    &ab->qmi.ce_cfg.shadow_reg_v3_len);\n\n\tret = ath12k_qmi_firmware_start(ab, mode);\n\tif (ret) {\n\t\tath12k_err(ab, \"failed to send firmware start: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nint ath12k_core_qmi_firmware_ready(struct ath12k_base *ab)\n{\n\tint ret;\n\n\tret = ath12k_core_start_firmware(ab, ATH12K_FIRMWARE_MODE_NORMAL);\n\tif (ret) {\n\t\tath12k_err(ab, \"failed to start firmware: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ath12k_ce_init_pipes(ab);\n\tif (ret) {\n\t\tath12k_err(ab, \"failed to initialize CE: %d\\n\", ret);\n\t\tgoto err_firmware_stop;\n\t}\n\n\tret = ath12k_dp_alloc(ab);\n\tif (ret) {\n\t\tath12k_err(ab, \"failed to init DP: %d\\n\", ret);\n\t\tgoto err_firmware_stop;\n\t}\n\n\tmutex_lock(&ab->core_lock);\n\tret = ath12k_core_start(ab, ATH12K_FIRMWARE_MODE_NORMAL);\n\tif (ret) {\n\t\tath12k_err(ab, \"failed to start core: %d\\n\", ret);\n\t\tgoto err_dp_free;\n\t}\n\n\tret = ath12k_core_pdev_create(ab);\n\tif (ret) {\n\t\tath12k_err(ab, \"failed to create pdev core: %d\\n\", ret);\n\t\tgoto err_core_stop;\n\t}\n\tath12k_hif_irq_enable(ab);\n\tmutex_unlock(&ab->core_lock);\n\n\treturn 0;\n\nerr_core_stop:\n\tath12k_core_stop(ab);\n\tath12k_mac_destroy(ab);\nerr_dp_free:\n\tath12k_dp_free(ab);\n\tmutex_unlock(&ab->core_lock);\nerr_firmware_stop:\n\tath12k_qmi_firmware_stop(ab);\n\n\treturn ret;\n}\n\nstatic int ath12k_core_reconfigure_on_crash(struct ath12k_base *ab)\n{\n\tint ret;\n\n\tmutex_lock(&ab->core_lock);\n\tath12k_hif_irq_disable(ab);\n\tath12k_dp_pdev_free(ab);\n\tath12k_hif_stop(ab);\n\tath12k_wmi_detach(ab);\n\tath12k_dp_rx_pdev_reo_cleanup(ab);\n\tmutex_unlock(&ab->core_lock);\n\n\tath12k_dp_free(ab);\n\tath12k_hal_srng_deinit(ab);\n\n\tab->free_vdev_map = (1LL << (ab->num_radios * TARGET_NUM_VDEVS)) - 1;\n\n\tret = ath12k_hal_srng_init(ab);\n\tif (ret)\n\t\treturn ret;\n\n\tclear_bit(ATH12K_FLAG_CRASH_FLUSH, &ab->dev_flags);\n\n\tret = ath12k_core_qmi_firmware_ready(ab);\n\tif (ret)\n\t\tgoto err_hal_srng_deinit;\n\n\tclear_bit(ATH12K_FLAG_RECOVERY, &ab->dev_flags);\n\n\treturn 0;\n\nerr_hal_srng_deinit:\n\tath12k_hal_srng_deinit(ab);\n\treturn ret;\n}\n\nvoid ath12k_core_halt(struct ath12k *ar)\n{\n\tstruct ath12k_base *ab = ar->ab;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tar->num_created_vdevs = 0;\n\tar->allocated_vdev_map = 0;\n\n\tath12k_mac_scan_finish(ar);\n\tath12k_mac_peer_cleanup_all(ar);\n\tcancel_delayed_work_sync(&ar->scan.timeout);\n\tcancel_work_sync(&ar->regd_update_work);\n\n\trcu_assign_pointer(ab->pdevs_active[ar->pdev_idx], NULL);\n\tsynchronize_rcu();\n\tINIT_LIST_HEAD(&ar->arvifs);\n\tidr_init(&ar->txmgmt_idr);\n}\n\nstatic void ath12k_core_pre_reconfigure_recovery(struct ath12k_base *ab)\n{\n\tstruct ath12k *ar;\n\tstruct ath12k_pdev *pdev;\n\tint i;\n\n\tspin_lock_bh(&ab->base_lock);\n\tab->stats.fw_crash_counter++;\n\tspin_unlock_bh(&ab->base_lock);\n\n\tfor (i = 0; i < ab->num_radios; i++) {\n\t\tpdev = &ab->pdevs[i];\n\t\tar = pdev->ar;\n\t\tif (!ar || ar->state == ATH12K_STATE_OFF)\n\t\t\tcontinue;\n\n\t\tieee80211_stop_queues(ar->hw);\n\t\tath12k_mac_drain_tx(ar);\n\t\tcomplete(&ar->scan.started);\n\t\tcomplete(&ar->scan.completed);\n\t\tcomplete(&ar->peer_assoc_done);\n\t\tcomplete(&ar->peer_delete_done);\n\t\tcomplete(&ar->install_key_done);\n\t\tcomplete(&ar->vdev_setup_done);\n\t\tcomplete(&ar->vdev_delete_done);\n\t\tcomplete(&ar->bss_survey_done);\n\n\t\twake_up(&ar->dp.tx_empty_waitq);\n\t\tidr_for_each(&ar->txmgmt_idr,\n\t\t\t     ath12k_mac_tx_mgmt_pending_free, ar);\n\t\tidr_destroy(&ar->txmgmt_idr);\n\t\twake_up(&ar->txmgmt_empty_waitq);\n\t}\n\n\twake_up(&ab->wmi_ab.tx_credits_wq);\n\twake_up(&ab->peer_mapping_wq);\n}\n\nstatic void ath12k_core_post_reconfigure_recovery(struct ath12k_base *ab)\n{\n\tstruct ath12k *ar;\n\tstruct ath12k_pdev *pdev;\n\tint i;\n\n\tfor (i = 0; i < ab->num_radios; i++) {\n\t\tpdev = &ab->pdevs[i];\n\t\tar = pdev->ar;\n\t\tif (!ar || ar->state == ATH12K_STATE_OFF)\n\t\t\tcontinue;\n\n\t\tmutex_lock(&ar->conf_mutex);\n\n\t\tswitch (ar->state) {\n\t\tcase ATH12K_STATE_ON:\n\t\t\tar->state = ATH12K_STATE_RESTARTING;\n\t\t\tath12k_core_halt(ar);\n\t\t\tieee80211_restart_hw(ar->hw);\n\t\t\tbreak;\n\t\tcase ATH12K_STATE_OFF:\n\t\t\tath12k_warn(ab,\n\t\t\t\t    \"cannot restart radio %d that hasn't been started\\n\",\n\t\t\t\t    i);\n\t\t\tbreak;\n\t\tcase ATH12K_STATE_RESTARTING:\n\t\t\tbreak;\n\t\tcase ATH12K_STATE_RESTARTED:\n\t\t\tar->state = ATH12K_STATE_WEDGED;\n\t\t\tfallthrough;\n\t\tcase ATH12K_STATE_WEDGED:\n\t\t\tath12k_warn(ab,\n\t\t\t\t    \"device is wedged, will not restart radio %d\\n\", i);\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&ar->conf_mutex);\n\t}\n\tcomplete(&ab->driver_recovery);\n}\n\nstatic void ath12k_core_restart(struct work_struct *work)\n{\n\tstruct ath12k_base *ab = container_of(work, struct ath12k_base, restart_work);\n\tint ret;\n\n\tif (!ab->is_reset)\n\t\tath12k_core_pre_reconfigure_recovery(ab);\n\n\tret = ath12k_core_reconfigure_on_crash(ab);\n\tif (ret) {\n\t\tath12k_err(ab, \"failed to reconfigure driver on crash recovery\\n\");\n\t\treturn;\n\t}\n\n\tif (ab->is_reset)\n\t\tcomplete_all(&ab->reconfigure_complete);\n\n\tif (!ab->is_reset)\n\t\tath12k_core_post_reconfigure_recovery(ab);\n}\n\nstatic void ath12k_core_reset(struct work_struct *work)\n{\n\tstruct ath12k_base *ab = container_of(work, struct ath12k_base, reset_work);\n\tint reset_count, fail_cont_count;\n\tlong time_left;\n\n\tif (!(test_bit(ATH12K_FLAG_REGISTERED, &ab->dev_flags))) {\n\t\tath12k_warn(ab, \"ignore reset dev flags 0x%lx\\n\", ab->dev_flags);\n\t\treturn;\n\t}\n\n\t \n\tfail_cont_count = atomic_read(&ab->fail_cont_count);\n\n\tif (fail_cont_count >= ATH12K_RESET_MAX_FAIL_COUNT_FINAL)\n\t\treturn;\n\n\tif (fail_cont_count >= ATH12K_RESET_MAX_FAIL_COUNT_FIRST &&\n\t    time_before(jiffies, ab->reset_fail_timeout))\n\t\treturn;\n\n\treset_count = atomic_inc_return(&ab->reset_count);\n\n\tif (reset_count > 1) {\n\t\t \n\t\tath12k_warn(ab, \"already resetting count %d\\n\", reset_count);\n\n\t\treinit_completion(&ab->reset_complete);\n\t\ttime_left = wait_for_completion_timeout(&ab->reset_complete,\n\t\t\t\t\t\t\tATH12K_RESET_TIMEOUT_HZ);\n\t\tif (time_left) {\n\t\t\tath12k_dbg(ab, ATH12K_DBG_BOOT, \"to skip reset\\n\");\n\t\t\tatomic_dec(&ab->reset_count);\n\t\t\treturn;\n\t\t}\n\n\t\tab->reset_fail_timeout = jiffies + ATH12K_RESET_FAIL_TIMEOUT_HZ;\n\t\t \n\t\tfail_cont_count = atomic_inc_return(&ab->fail_cont_count);\n\t}\n\n\tath12k_dbg(ab, ATH12K_DBG_BOOT, \"reset starting\\n\");\n\n\tab->is_reset = true;\n\tatomic_set(&ab->recovery_count, 0);\n\n\tath12k_core_pre_reconfigure_recovery(ab);\n\n\treinit_completion(&ab->reconfigure_complete);\n\tath12k_core_post_reconfigure_recovery(ab);\n\n\treinit_completion(&ab->recovery_start);\n\tatomic_set(&ab->recovery_start_count, 0);\n\n\tath12k_dbg(ab, ATH12K_DBG_BOOT, \"waiting recovery start...\\n\");\n\n\ttime_left = wait_for_completion_timeout(&ab->recovery_start,\n\t\t\t\t\t\tATH12K_RECOVER_START_TIMEOUT_HZ);\n\n\tath12k_hif_power_down(ab);\n\tath12k_hif_power_up(ab);\n\n\tath12k_dbg(ab, ATH12K_DBG_BOOT, \"reset started\\n\");\n}\n\nint ath12k_core_pre_init(struct ath12k_base *ab)\n{\n\tint ret;\n\n\tret = ath12k_hw_init(ab);\n\tif (ret) {\n\t\tath12k_err(ab, \"failed to init hw params: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint ath12k_core_init(struct ath12k_base *ab)\n{\n\tint ret;\n\n\tret = ath12k_core_soc_create(ab);\n\tif (ret) {\n\t\tath12k_err(ab, \"failed to create soc core: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nvoid ath12k_core_deinit(struct ath12k_base *ab)\n{\n\tmutex_lock(&ab->core_lock);\n\n\tath12k_core_pdev_destroy(ab);\n\tath12k_core_stop(ab);\n\n\tmutex_unlock(&ab->core_lock);\n\n\tath12k_hif_power_down(ab);\n\tath12k_mac_destroy(ab);\n\tath12k_core_soc_destroy(ab);\n}\n\nvoid ath12k_core_free(struct ath12k_base *ab)\n{\n\ttimer_delete_sync(&ab->rx_replenish_retry);\n\tdestroy_workqueue(ab->workqueue_aux);\n\tdestroy_workqueue(ab->workqueue);\n\tkfree(ab);\n}\n\nstruct ath12k_base *ath12k_core_alloc(struct device *dev, size_t priv_size,\n\t\t\t\t      enum ath12k_bus bus)\n{\n\tstruct ath12k_base *ab;\n\n\tab = kzalloc(sizeof(*ab) + priv_size, GFP_KERNEL);\n\tif (!ab)\n\t\treturn NULL;\n\n\tinit_completion(&ab->driver_recovery);\n\n\tab->workqueue = create_singlethread_workqueue(\"ath12k_wq\");\n\tif (!ab->workqueue)\n\t\tgoto err_sc_free;\n\n\tab->workqueue_aux = create_singlethread_workqueue(\"ath12k_aux_wq\");\n\tif (!ab->workqueue_aux)\n\t\tgoto err_free_wq;\n\n\tmutex_init(&ab->core_lock);\n\tspin_lock_init(&ab->base_lock);\n\tinit_completion(&ab->reset_complete);\n\tinit_completion(&ab->reconfigure_complete);\n\tinit_completion(&ab->recovery_start);\n\n\tINIT_LIST_HEAD(&ab->peers);\n\tinit_waitqueue_head(&ab->peer_mapping_wq);\n\tinit_waitqueue_head(&ab->wmi_ab.tx_credits_wq);\n\tINIT_WORK(&ab->restart_work, ath12k_core_restart);\n\tINIT_WORK(&ab->reset_work, ath12k_core_reset);\n\ttimer_setup(&ab->rx_replenish_retry, ath12k_ce_rx_replenish_retry, 0);\n\tinit_completion(&ab->htc_suspend);\n\n\tab->dev = dev;\n\tab->hif.bus = bus;\n\n\treturn ab;\n\nerr_free_wq:\n\tdestroy_workqueue(ab->workqueue);\nerr_sc_free:\n\tkfree(ab);\n\treturn NULL;\n}\n\nMODULE_DESCRIPTION(\"Core module for Qualcomm Atheros 802.11be wireless LAN cards.\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}