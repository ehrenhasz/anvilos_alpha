{
  "module_name": "dp_rx.c",
  "hash_id": "e62c30993baa2a7928e978e7f65367e56eb582fe2a807efeff0258b48d30d40f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath12k/dp_rx.c",
  "human_readable_source": "\n \n\n#include <linux/ieee80211.h>\n#include <linux/kernel.h>\n#include <linux/skbuff.h>\n#include <crypto/hash.h>\n#include \"core.h\"\n#include \"debug.h\"\n#include \"hal_desc.h\"\n#include \"hw.h\"\n#include \"dp_rx.h\"\n#include \"hal_rx.h\"\n#include \"dp_tx.h\"\n#include \"peer.h\"\n#include \"dp_mon.h\"\n\n#define ATH12K_DP_RX_FRAGMENT_TIMEOUT_MS (2 * HZ)\n\nstatic enum hal_encrypt_type ath12k_dp_rx_h_enctype(struct ath12k_base *ab,\n\t\t\t\t\t\t    struct hal_rx_desc *desc)\n{\n\tif (!ab->hw_params->hal_ops->rx_desc_encrypt_valid(desc))\n\t\treturn HAL_ENCRYPT_TYPE_OPEN;\n\n\treturn ab->hw_params->hal_ops->rx_desc_get_encrypt_type(desc);\n}\n\nu8 ath12k_dp_rx_h_decap_type(struct ath12k_base *ab,\n\t\t\t     struct hal_rx_desc *desc)\n{\n\treturn ab->hw_params->hal_ops->rx_desc_get_decap_type(desc);\n}\n\nstatic u8 ath12k_dp_rx_h_mesh_ctl_present(struct ath12k_base *ab,\n\t\t\t\t\t  struct hal_rx_desc *desc)\n{\n\treturn ab->hw_params->hal_ops->rx_desc_get_mesh_ctl(desc);\n}\n\nstatic bool ath12k_dp_rx_h_seq_ctrl_valid(struct ath12k_base *ab,\n\t\t\t\t\t  struct hal_rx_desc *desc)\n{\n\treturn ab->hw_params->hal_ops->rx_desc_get_mpdu_seq_ctl_vld(desc);\n}\n\nstatic bool ath12k_dp_rx_h_fc_valid(struct ath12k_base *ab,\n\t\t\t\t    struct hal_rx_desc *desc)\n{\n\treturn ab->hw_params->hal_ops->rx_desc_get_mpdu_fc_valid(desc);\n}\n\nstatic bool ath12k_dp_rx_h_more_frags(struct ath12k_base *ab,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr;\n\n\thdr = (struct ieee80211_hdr *)(skb->data + ab->hw_params->hal_desc_sz);\n\treturn ieee80211_has_morefrags(hdr->frame_control);\n}\n\nstatic u16 ath12k_dp_rx_h_frag_no(struct ath12k_base *ab,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr;\n\n\thdr = (struct ieee80211_hdr *)(skb->data + ab->hw_params->hal_desc_sz);\n\treturn le16_to_cpu(hdr->seq_ctrl) & IEEE80211_SCTL_FRAG;\n}\n\nstatic u16 ath12k_dp_rx_h_seq_no(struct ath12k_base *ab,\n\t\t\t\t struct hal_rx_desc *desc)\n{\n\treturn ab->hw_params->hal_ops->rx_desc_get_mpdu_start_seq_no(desc);\n}\n\nstatic bool ath12k_dp_rx_h_msdu_done(struct ath12k_base *ab,\n\t\t\t\t     struct hal_rx_desc *desc)\n{\n\treturn ab->hw_params->hal_ops->dp_rx_h_msdu_done(desc);\n}\n\nstatic bool ath12k_dp_rx_h_l4_cksum_fail(struct ath12k_base *ab,\n\t\t\t\t\t struct hal_rx_desc *desc)\n{\n\treturn ab->hw_params->hal_ops->dp_rx_h_l4_cksum_fail(desc);\n}\n\nstatic bool ath12k_dp_rx_h_ip_cksum_fail(struct ath12k_base *ab,\n\t\t\t\t\t struct hal_rx_desc *desc)\n{\n\treturn ab->hw_params->hal_ops->dp_rx_h_ip_cksum_fail(desc);\n}\n\nstatic bool ath12k_dp_rx_h_is_decrypted(struct ath12k_base *ab,\n\t\t\t\t\tstruct hal_rx_desc *desc)\n{\n\treturn ab->hw_params->hal_ops->dp_rx_h_is_decrypted(desc);\n}\n\nu32 ath12k_dp_rx_h_mpdu_err(struct ath12k_base *ab,\n\t\t\t    struct hal_rx_desc *desc)\n{\n\treturn ab->hw_params->hal_ops->dp_rx_h_mpdu_err(desc);\n}\n\nstatic u16 ath12k_dp_rx_h_msdu_len(struct ath12k_base *ab,\n\t\t\t\t   struct hal_rx_desc *desc)\n{\n\treturn ab->hw_params->hal_ops->rx_desc_get_msdu_len(desc);\n}\n\nstatic u8 ath12k_dp_rx_h_sgi(struct ath12k_base *ab,\n\t\t\t     struct hal_rx_desc *desc)\n{\n\treturn ab->hw_params->hal_ops->rx_desc_get_msdu_sgi(desc);\n}\n\nstatic u8 ath12k_dp_rx_h_rate_mcs(struct ath12k_base *ab,\n\t\t\t\t  struct hal_rx_desc *desc)\n{\n\treturn ab->hw_params->hal_ops->rx_desc_get_msdu_rate_mcs(desc);\n}\n\nstatic u8 ath12k_dp_rx_h_rx_bw(struct ath12k_base *ab,\n\t\t\t       struct hal_rx_desc *desc)\n{\n\treturn ab->hw_params->hal_ops->rx_desc_get_msdu_rx_bw(desc);\n}\n\nstatic u32 ath12k_dp_rx_h_freq(struct ath12k_base *ab,\n\t\t\t       struct hal_rx_desc *desc)\n{\n\treturn ab->hw_params->hal_ops->rx_desc_get_msdu_freq(desc);\n}\n\nstatic u8 ath12k_dp_rx_h_pkt_type(struct ath12k_base *ab,\n\t\t\t\t  struct hal_rx_desc *desc)\n{\n\treturn ab->hw_params->hal_ops->rx_desc_get_msdu_pkt_type(desc);\n}\n\nstatic u8 ath12k_dp_rx_h_nss(struct ath12k_base *ab,\n\t\t\t     struct hal_rx_desc *desc)\n{\n\treturn hweight8(ab->hw_params->hal_ops->rx_desc_get_msdu_nss(desc));\n}\n\nstatic u8 ath12k_dp_rx_h_tid(struct ath12k_base *ab,\n\t\t\t     struct hal_rx_desc *desc)\n{\n\treturn ab->hw_params->hal_ops->rx_desc_get_mpdu_tid(desc);\n}\n\nstatic u16 ath12k_dp_rx_h_peer_id(struct ath12k_base *ab,\n\t\t\t\t  struct hal_rx_desc *desc)\n{\n\treturn ab->hw_params->hal_ops->rx_desc_get_mpdu_peer_id(desc);\n}\n\nu8 ath12k_dp_rx_h_l3pad(struct ath12k_base *ab,\n\t\t\tstruct hal_rx_desc *desc)\n{\n\treturn ab->hw_params->hal_ops->rx_desc_get_l3_pad_bytes(desc);\n}\n\nstatic bool ath12k_dp_rx_h_first_msdu(struct ath12k_base *ab,\n\t\t\t\t      struct hal_rx_desc *desc)\n{\n\treturn ab->hw_params->hal_ops->rx_desc_get_first_msdu(desc);\n}\n\nstatic bool ath12k_dp_rx_h_last_msdu(struct ath12k_base *ab,\n\t\t\t\t     struct hal_rx_desc *desc)\n{\n\treturn ab->hw_params->hal_ops->rx_desc_get_last_msdu(desc);\n}\n\nstatic void ath12k_dp_rx_desc_end_tlv_copy(struct ath12k_base *ab,\n\t\t\t\t\t   struct hal_rx_desc *fdesc,\n\t\t\t\t\t   struct hal_rx_desc *ldesc)\n{\n\tab->hw_params->hal_ops->rx_desc_copy_end_tlv(fdesc, ldesc);\n}\n\nstatic void ath12k_dp_rxdesc_set_msdu_len(struct ath12k_base *ab,\n\t\t\t\t\t  struct hal_rx_desc *desc,\n\t\t\t\t\t  u16 len)\n{\n\tab->hw_params->hal_ops->rx_desc_set_msdu_len(desc, len);\n}\n\nstatic bool ath12k_dp_rx_h_is_da_mcbc(struct ath12k_base *ab,\n\t\t\t\t      struct hal_rx_desc *desc)\n{\n\treturn (ath12k_dp_rx_h_first_msdu(ab, desc) &&\n\t\tab->hw_params->hal_ops->rx_desc_is_da_mcbc(desc));\n}\n\nstatic bool ath12k_dp_rxdesc_mac_addr2_valid(struct ath12k_base *ab,\n\t\t\t\t\t     struct hal_rx_desc *desc)\n{\n\treturn ab->hw_params->hal_ops->rx_desc_mac_addr2_valid(desc);\n}\n\nstatic u8 *ath12k_dp_rxdesc_get_mpdu_start_addr2(struct ath12k_base *ab,\n\t\t\t\t\t\t struct hal_rx_desc *desc)\n{\n\treturn ab->hw_params->hal_ops->rx_desc_mpdu_start_addr2(desc);\n}\n\nstatic void ath12k_dp_rx_desc_get_dot11_hdr(struct ath12k_base *ab,\n\t\t\t\t\t    struct hal_rx_desc *desc,\n\t\t\t\t\t    struct ieee80211_hdr *hdr)\n{\n\tab->hw_params->hal_ops->rx_desc_get_dot11_hdr(desc, hdr);\n}\n\nstatic void ath12k_dp_rx_desc_get_crypto_header(struct ath12k_base *ab,\n\t\t\t\t\t\tstruct hal_rx_desc *desc,\n\t\t\t\t\t\tu8 *crypto_hdr,\n\t\t\t\t\t\tenum hal_encrypt_type enctype)\n{\n\tab->hw_params->hal_ops->rx_desc_get_crypto_header(desc, crypto_hdr, enctype);\n}\n\nstatic u16 ath12k_dp_rxdesc_get_mpdu_frame_ctrl(struct ath12k_base *ab,\n\t\t\t\t\t\tstruct hal_rx_desc *desc)\n{\n\treturn ab->hw_params->hal_ops->rx_desc_get_mpdu_frame_ctl(desc);\n}\n\nstatic int ath12k_dp_purge_mon_ring(struct ath12k_base *ab)\n{\n\tint i, reaped = 0;\n\tunsigned long timeout = jiffies + msecs_to_jiffies(DP_MON_PURGE_TIMEOUT_MS);\n\n\tdo {\n\t\tfor (i = 0; i < ab->hw_params->num_rxmda_per_pdev; i++)\n\t\t\treaped += ath12k_dp_mon_process_ring(ab, i, NULL,\n\t\t\t\t\t\t\t     DP_MON_SERVICE_BUDGET,\n\t\t\t\t\t\t\t     ATH12K_DP_RX_MONITOR_MODE);\n\n\t\t \n\t\tif (reaped < DP_MON_SERVICE_BUDGET)\n\t\t\treturn 0;\n\n\t} while (time_before(jiffies, timeout));\n\n\tath12k_warn(ab, \"dp mon ring purge timeout\");\n\n\treturn -ETIMEDOUT;\n}\n\n \nint ath12k_dp_rx_bufs_replenish(struct ath12k_base *ab, int mac_id,\n\t\t\t\tstruct dp_rxdma_ring *rx_ring,\n\t\t\t\tint req_entries,\n\t\t\t\tenum hal_rx_buf_return_buf_manager mgr,\n\t\t\t\tbool hw_cc)\n{\n\tstruct ath12k_buffer_addr *desc;\n\tstruct hal_srng *srng;\n\tstruct sk_buff *skb;\n\tint num_free;\n\tint num_remain;\n\tint buf_id;\n\tu32 cookie;\n\tdma_addr_t paddr;\n\tstruct ath12k_dp *dp = &ab->dp;\n\tstruct ath12k_rx_desc_info *rx_desc;\n\n\treq_entries = min(req_entries, rx_ring->bufs_max);\n\n\tsrng = &ab->hal.srng_list[rx_ring->refill_buf_ring.ring_id];\n\n\tspin_lock_bh(&srng->lock);\n\n\tath12k_hal_srng_access_begin(ab, srng);\n\n\tnum_free = ath12k_hal_srng_src_num_free(ab, srng, true);\n\tif (!req_entries && (num_free > (rx_ring->bufs_max * 3) / 4))\n\t\treq_entries = num_free;\n\n\treq_entries = min(num_free, req_entries);\n\tnum_remain = req_entries;\n\n\twhile (num_remain > 0) {\n\t\tskb = dev_alloc_skb(DP_RX_BUFFER_SIZE +\n\t\t\t\t    DP_RX_BUFFER_ALIGN_SIZE);\n\t\tif (!skb)\n\t\t\tbreak;\n\n\t\tif (!IS_ALIGNED((unsigned long)skb->data,\n\t\t\t\tDP_RX_BUFFER_ALIGN_SIZE)) {\n\t\t\tskb_pull(skb,\n\t\t\t\t PTR_ALIGN(skb->data, DP_RX_BUFFER_ALIGN_SIZE) -\n\t\t\t\t skb->data);\n\t\t}\n\n\t\tpaddr = dma_map_single(ab->dev, skb->data,\n\t\t\t\t       skb->len + skb_tailroom(skb),\n\t\t\t\t       DMA_FROM_DEVICE);\n\t\tif (dma_mapping_error(ab->dev, paddr))\n\t\t\tgoto fail_free_skb;\n\n\t\tif (hw_cc) {\n\t\t\tspin_lock_bh(&dp->rx_desc_lock);\n\n\t\t\t \n\t\t\trx_desc = list_first_entry_or_null(&dp->rx_desc_free_list,\n\t\t\t\t\t\t\t   struct ath12k_rx_desc_info,\n\t\t\t\t\t\t\t   list);\n\t\t\tif (!rx_desc) {\n\t\t\t\tspin_unlock_bh(&dp->rx_desc_lock);\n\t\t\t\tgoto fail_dma_unmap;\n\t\t\t}\n\n\t\t\trx_desc->skb = skb;\n\t\t\tcookie = rx_desc->cookie;\n\t\t\tlist_del(&rx_desc->list);\n\t\t\tlist_add_tail(&rx_desc->list, &dp->rx_desc_used_list);\n\n\t\t\tspin_unlock_bh(&dp->rx_desc_lock);\n\t\t} else {\n\t\t\tspin_lock_bh(&rx_ring->idr_lock);\n\t\t\tbuf_id = idr_alloc(&rx_ring->bufs_idr, skb, 0,\n\t\t\t\t\t   rx_ring->bufs_max * 3, GFP_ATOMIC);\n\t\t\tspin_unlock_bh(&rx_ring->idr_lock);\n\t\t\tif (buf_id < 0)\n\t\t\t\tgoto fail_dma_unmap;\n\t\t\tcookie = u32_encode_bits(mac_id,\n\t\t\t\t\t\t DP_RXDMA_BUF_COOKIE_PDEV_ID) |\n\t\t\t\t u32_encode_bits(buf_id,\n\t\t\t\t\t\t DP_RXDMA_BUF_COOKIE_BUF_ID);\n\t\t}\n\n\t\tdesc = ath12k_hal_srng_src_get_next_entry(ab, srng);\n\t\tif (!desc)\n\t\t\tgoto fail_buf_unassign;\n\n\t\tATH12K_SKB_RXCB(skb)->paddr = paddr;\n\n\t\tnum_remain--;\n\n\t\tath12k_hal_rx_buf_addr_info_set(desc, paddr, cookie, mgr);\n\t}\n\n\tath12k_hal_srng_access_end(ab, srng);\n\n\tspin_unlock_bh(&srng->lock);\n\n\treturn req_entries - num_remain;\n\nfail_buf_unassign:\n\tif (hw_cc) {\n\t\tspin_lock_bh(&dp->rx_desc_lock);\n\t\tlist_del(&rx_desc->list);\n\t\tlist_add_tail(&rx_desc->list, &dp->rx_desc_free_list);\n\t\trx_desc->skb = NULL;\n\t\tspin_unlock_bh(&dp->rx_desc_lock);\n\t} else {\n\t\tspin_lock_bh(&rx_ring->idr_lock);\n\t\tidr_remove(&rx_ring->bufs_idr, buf_id);\n\t\tspin_unlock_bh(&rx_ring->idr_lock);\n\t}\nfail_dma_unmap:\n\tdma_unmap_single(ab->dev, paddr, skb->len + skb_tailroom(skb),\n\t\t\t DMA_FROM_DEVICE);\nfail_free_skb:\n\tdev_kfree_skb_any(skb);\n\n\tath12k_hal_srng_access_end(ab, srng);\n\n\tspin_unlock_bh(&srng->lock);\n\n\treturn req_entries - num_remain;\n}\n\nstatic int ath12k_dp_rxdma_buf_ring_free(struct ath12k_base *ab,\n\t\t\t\t\t struct dp_rxdma_ring *rx_ring)\n{\n\tstruct sk_buff *skb;\n\tint buf_id;\n\n\tspin_lock_bh(&rx_ring->idr_lock);\n\tidr_for_each_entry(&rx_ring->bufs_idr, skb, buf_id) {\n\t\tidr_remove(&rx_ring->bufs_idr, buf_id);\n\t\t \n\t\tdma_unmap_single(ab->dev, ATH12K_SKB_RXCB(skb)->paddr,\n\t\t\t\t skb->len + skb_tailroom(skb), DMA_FROM_DEVICE);\n\t\tdev_kfree_skb_any(skb);\n\t}\n\n\tidr_destroy(&rx_ring->bufs_idr);\n\tspin_unlock_bh(&rx_ring->idr_lock);\n\n\treturn 0;\n}\n\nstatic int ath12k_dp_rxdma_buf_free(struct ath12k_base *ab)\n{\n\tstruct ath12k_dp *dp = &ab->dp;\n\tstruct dp_rxdma_ring *rx_ring = &dp->rx_refill_buf_ring;\n\n\tath12k_dp_rxdma_buf_ring_free(ab, rx_ring);\n\n\trx_ring = &dp->rxdma_mon_buf_ring;\n\tath12k_dp_rxdma_buf_ring_free(ab, rx_ring);\n\n\trx_ring = &dp->tx_mon_buf_ring;\n\tath12k_dp_rxdma_buf_ring_free(ab, rx_ring);\n\n\treturn 0;\n}\n\nstatic int ath12k_dp_rxdma_ring_buf_setup(struct ath12k_base *ab,\n\t\t\t\t\t  struct dp_rxdma_ring *rx_ring,\n\t\t\t\t\t  u32 ringtype)\n{\n\tint num_entries;\n\n\tnum_entries = rx_ring->refill_buf_ring.size /\n\t\tath12k_hal_srng_get_entrysize(ab, ringtype);\n\n\trx_ring->bufs_max = num_entries;\n\tif ((ringtype == HAL_RXDMA_MONITOR_BUF) || (ringtype == HAL_TX_MONITOR_BUF))\n\t\tath12k_dp_mon_buf_replenish(ab, rx_ring, num_entries);\n\telse\n\t\tath12k_dp_rx_bufs_replenish(ab, 0, rx_ring, num_entries,\n\t\t\t\t\t    ab->hw_params->hal_params->rx_buf_rbm,\n\t\t\t\t\t    ringtype == HAL_RXDMA_BUF);\n\treturn 0;\n}\n\nstatic int ath12k_dp_rxdma_buf_setup(struct ath12k_base *ab)\n{\n\tstruct ath12k_dp *dp = &ab->dp;\n\tstruct dp_rxdma_ring *rx_ring = &dp->rx_refill_buf_ring;\n\tint ret;\n\n\tret = ath12k_dp_rxdma_ring_buf_setup(ab, rx_ring,\n\t\t\t\t\t     HAL_RXDMA_BUF);\n\tif (ret) {\n\t\tath12k_warn(ab,\n\t\t\t    \"failed to setup HAL_RXDMA_BUF\\n\");\n\t\treturn ret;\n\t}\n\n\tif (ab->hw_params->rxdma1_enable) {\n\t\trx_ring = &dp->rxdma_mon_buf_ring;\n\t\tret = ath12k_dp_rxdma_ring_buf_setup(ab, rx_ring,\n\t\t\t\t\t\t     HAL_RXDMA_MONITOR_BUF);\n\t\tif (ret) {\n\t\t\tath12k_warn(ab,\n\t\t\t\t    \"failed to setup HAL_RXDMA_MONITOR_BUF\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\trx_ring = &dp->tx_mon_buf_ring;\n\t\tret = ath12k_dp_rxdma_ring_buf_setup(ab, rx_ring,\n\t\t\t\t\t\t     HAL_TX_MONITOR_BUF);\n\t\tif (ret) {\n\t\t\tath12k_warn(ab,\n\t\t\t\t    \"failed to setup HAL_TX_MONITOR_BUF\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void ath12k_dp_rx_pdev_srng_free(struct ath12k *ar)\n{\n\tstruct ath12k_pdev_dp *dp = &ar->dp;\n\tstruct ath12k_base *ab = ar->ab;\n\tint i;\n\n\tfor (i = 0; i < ab->hw_params->num_rxmda_per_pdev; i++) {\n\t\tath12k_dp_srng_cleanup(ab, &dp->rxdma_mon_dst_ring[i]);\n\t\tath12k_dp_srng_cleanup(ab, &dp->tx_mon_dst_ring[i]);\n\t}\n}\n\nvoid ath12k_dp_rx_pdev_reo_cleanup(struct ath12k_base *ab)\n{\n\tstruct ath12k_dp *dp = &ab->dp;\n\tint i;\n\n\tfor (i = 0; i < DP_REO_DST_RING_MAX; i++)\n\t\tath12k_dp_srng_cleanup(ab, &dp->reo_dst_ring[i]);\n}\n\nint ath12k_dp_rx_pdev_reo_setup(struct ath12k_base *ab)\n{\n\tstruct ath12k_dp *dp = &ab->dp;\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < DP_REO_DST_RING_MAX; i++) {\n\t\tret = ath12k_dp_srng_setup(ab, &dp->reo_dst_ring[i],\n\t\t\t\t\t   HAL_REO_DST, i, 0,\n\t\t\t\t\t   DP_REO_DST_RING_SIZE);\n\t\tif (ret) {\n\t\t\tath12k_warn(ab, \"failed to setup reo_dst_ring\\n\");\n\t\t\tgoto err_reo_cleanup;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_reo_cleanup:\n\tath12k_dp_rx_pdev_reo_cleanup(ab);\n\n\treturn ret;\n}\n\nstatic int ath12k_dp_rx_pdev_srng_alloc(struct ath12k *ar)\n{\n\tstruct ath12k_pdev_dp *dp = &ar->dp;\n\tstruct ath12k_base *ab = ar->ab;\n\tint i;\n\tint ret;\n\tu32 mac_id = dp->mac_id;\n\n\tfor (i = 0; i < ab->hw_params->num_rxmda_per_pdev; i++) {\n\t\tret = ath12k_dp_srng_setup(ar->ab,\n\t\t\t\t\t   &dp->rxdma_mon_dst_ring[i],\n\t\t\t\t\t   HAL_RXDMA_MONITOR_DST,\n\t\t\t\t\t   0, mac_id + i,\n\t\t\t\t\t   DP_RXDMA_MONITOR_DST_RING_SIZE);\n\t\tif (ret) {\n\t\t\tath12k_warn(ar->ab,\n\t\t\t\t    \"failed to setup HAL_RXDMA_MONITOR_DST\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = ath12k_dp_srng_setup(ar->ab,\n\t\t\t\t\t   &dp->tx_mon_dst_ring[i],\n\t\t\t\t\t   HAL_TX_MONITOR_DST,\n\t\t\t\t\t   0, mac_id + i,\n\t\t\t\t\t   DP_TX_MONITOR_DEST_RING_SIZE);\n\t\tif (ret) {\n\t\t\tath12k_warn(ar->ab,\n\t\t\t\t    \"failed to setup HAL_TX_MONITOR_DST\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid ath12k_dp_rx_reo_cmd_list_cleanup(struct ath12k_base *ab)\n{\n\tstruct ath12k_dp *dp = &ab->dp;\n\tstruct ath12k_dp_rx_reo_cmd *cmd, *tmp;\n\tstruct ath12k_dp_rx_reo_cache_flush_elem *cmd_cache, *tmp_cache;\n\n\tspin_lock_bh(&dp->reo_cmd_lock);\n\tlist_for_each_entry_safe(cmd, tmp, &dp->reo_cmd_list, list) {\n\t\tlist_del(&cmd->list);\n\t\tdma_unmap_single(ab->dev, cmd->data.paddr,\n\t\t\t\t cmd->data.size, DMA_BIDIRECTIONAL);\n\t\tkfree(cmd->data.vaddr);\n\t\tkfree(cmd);\n\t}\n\n\tlist_for_each_entry_safe(cmd_cache, tmp_cache,\n\t\t\t\t &dp->reo_cmd_cache_flush_list, list) {\n\t\tlist_del(&cmd_cache->list);\n\t\tdp->reo_cmd_cache_flush_count--;\n\t\tdma_unmap_single(ab->dev, cmd_cache->data.paddr,\n\t\t\t\t cmd_cache->data.size, DMA_BIDIRECTIONAL);\n\t\tkfree(cmd_cache->data.vaddr);\n\t\tkfree(cmd_cache);\n\t}\n\tspin_unlock_bh(&dp->reo_cmd_lock);\n}\n\nstatic void ath12k_dp_reo_cmd_free(struct ath12k_dp *dp, void *ctx,\n\t\t\t\t   enum hal_reo_cmd_status status)\n{\n\tstruct ath12k_dp_rx_tid *rx_tid = ctx;\n\n\tif (status != HAL_REO_CMD_SUCCESS)\n\t\tath12k_warn(dp->ab, \"failed to flush rx tid hw desc, tid %d status %d\\n\",\n\t\t\t    rx_tid->tid, status);\n\n\tdma_unmap_single(dp->ab->dev, rx_tid->paddr, rx_tid->size,\n\t\t\t DMA_BIDIRECTIONAL);\n\tkfree(rx_tid->vaddr);\n\trx_tid->vaddr = NULL;\n}\n\nstatic int ath12k_dp_reo_cmd_send(struct ath12k_base *ab, struct ath12k_dp_rx_tid *rx_tid,\n\t\t\t\t  enum hal_reo_cmd_type type,\n\t\t\t\t  struct ath12k_hal_reo_cmd *cmd,\n\t\t\t\t  void (*cb)(struct ath12k_dp *dp, void *ctx,\n\t\t\t\t\t     enum hal_reo_cmd_status status))\n{\n\tstruct ath12k_dp *dp = &ab->dp;\n\tstruct ath12k_dp_rx_reo_cmd *dp_cmd;\n\tstruct hal_srng *cmd_ring;\n\tint cmd_num;\n\n\tcmd_ring = &ab->hal.srng_list[dp->reo_cmd_ring.ring_id];\n\tcmd_num = ath12k_hal_reo_cmd_send(ab, cmd_ring, type, cmd);\n\n\t \n\tif (cmd_num < 0)\n\t\treturn cmd_num;\n\n\t \n\tif (cmd_num == 0)\n\t\treturn -EINVAL;\n\n\tif (!cb)\n\t\treturn 0;\n\n\t \n\tdp_cmd = kzalloc(sizeof(*dp_cmd), GFP_ATOMIC);\n\n\tif (!dp_cmd)\n\t\treturn -ENOMEM;\n\n\tmemcpy(&dp_cmd->data, rx_tid, sizeof(*rx_tid));\n\tdp_cmd->cmd_num = cmd_num;\n\tdp_cmd->handler = cb;\n\n\tspin_lock_bh(&dp->reo_cmd_lock);\n\tlist_add_tail(&dp_cmd->list, &dp->reo_cmd_list);\n\tspin_unlock_bh(&dp->reo_cmd_lock);\n\n\treturn 0;\n}\n\nstatic void ath12k_dp_reo_cache_flush(struct ath12k_base *ab,\n\t\t\t\t      struct ath12k_dp_rx_tid *rx_tid)\n{\n\tstruct ath12k_hal_reo_cmd cmd = {0};\n\tunsigned long tot_desc_sz, desc_sz;\n\tint ret;\n\n\ttot_desc_sz = rx_tid->size;\n\tdesc_sz = ath12k_hal_reo_qdesc_size(0, HAL_DESC_REO_NON_QOS_TID);\n\n\twhile (tot_desc_sz > desc_sz) {\n\t\ttot_desc_sz -= desc_sz;\n\t\tcmd.addr_lo = lower_32_bits(rx_tid->paddr + tot_desc_sz);\n\t\tcmd.addr_hi = upper_32_bits(rx_tid->paddr);\n\t\tret = ath12k_dp_reo_cmd_send(ab, rx_tid,\n\t\t\t\t\t     HAL_REO_CMD_FLUSH_CACHE, &cmd,\n\t\t\t\t\t     NULL);\n\t\tif (ret)\n\t\t\tath12k_warn(ab,\n\t\t\t\t    \"failed to send HAL_REO_CMD_FLUSH_CACHE, tid %d (%d)\\n\",\n\t\t\t\t    rx_tid->tid, ret);\n\t}\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.addr_lo = lower_32_bits(rx_tid->paddr);\n\tcmd.addr_hi = upper_32_bits(rx_tid->paddr);\n\tcmd.flag = HAL_REO_CMD_FLG_NEED_STATUS;\n\tret = ath12k_dp_reo_cmd_send(ab, rx_tid,\n\t\t\t\t     HAL_REO_CMD_FLUSH_CACHE,\n\t\t\t\t     &cmd, ath12k_dp_reo_cmd_free);\n\tif (ret) {\n\t\tath12k_err(ab, \"failed to send HAL_REO_CMD_FLUSH_CACHE cmd, tid %d (%d)\\n\",\n\t\t\t   rx_tid->tid, ret);\n\t\tdma_unmap_single(ab->dev, rx_tid->paddr, rx_tid->size,\n\t\t\t\t DMA_BIDIRECTIONAL);\n\t\tkfree(rx_tid->vaddr);\n\t\trx_tid->vaddr = NULL;\n\t}\n}\n\nstatic void ath12k_dp_rx_tid_del_func(struct ath12k_dp *dp, void *ctx,\n\t\t\t\t      enum hal_reo_cmd_status status)\n{\n\tstruct ath12k_base *ab = dp->ab;\n\tstruct ath12k_dp_rx_tid *rx_tid = ctx;\n\tstruct ath12k_dp_rx_reo_cache_flush_elem *elem, *tmp;\n\n\tif (status == HAL_REO_CMD_DRAIN) {\n\t\tgoto free_desc;\n\t} else if (status != HAL_REO_CMD_SUCCESS) {\n\t\t \n\t\tath12k_warn(ab, \"failed to delete rx tid %d hw descriptor %d\\n\",\n\t\t\t    rx_tid->tid, status);\n\t\treturn;\n\t}\n\n\telem = kzalloc(sizeof(*elem), GFP_ATOMIC);\n\tif (!elem)\n\t\tgoto free_desc;\n\n\telem->ts = jiffies;\n\tmemcpy(&elem->data, rx_tid, sizeof(*rx_tid));\n\n\tspin_lock_bh(&dp->reo_cmd_lock);\n\tlist_add_tail(&elem->list, &dp->reo_cmd_cache_flush_list);\n\tdp->reo_cmd_cache_flush_count++;\n\n\t \n\tlist_for_each_entry_safe(elem, tmp, &dp->reo_cmd_cache_flush_list,\n\t\t\t\t list) {\n\t\tif (dp->reo_cmd_cache_flush_count > ATH12K_DP_RX_REO_DESC_FREE_THRES ||\n\t\t    time_after(jiffies, elem->ts +\n\t\t\t       msecs_to_jiffies(ATH12K_DP_RX_REO_DESC_FREE_TIMEOUT_MS))) {\n\t\t\tlist_del(&elem->list);\n\t\t\tdp->reo_cmd_cache_flush_count--;\n\n\t\t\t \n\t\t\tspin_unlock_bh(&dp->reo_cmd_lock);\n\n\t\t\tath12k_dp_reo_cache_flush(ab, &elem->data);\n\t\t\tkfree(elem);\n\t\t\tspin_lock_bh(&dp->reo_cmd_lock);\n\t\t}\n\t}\n\tspin_unlock_bh(&dp->reo_cmd_lock);\n\n\treturn;\nfree_desc:\n\tdma_unmap_single(ab->dev, rx_tid->paddr, rx_tid->size,\n\t\t\t DMA_BIDIRECTIONAL);\n\tkfree(rx_tid->vaddr);\n\trx_tid->vaddr = NULL;\n}\n\nstatic void ath12k_peer_rx_tid_qref_setup(struct ath12k_base *ab, u16 peer_id, u16 tid,\n\t\t\t\t\t  dma_addr_t paddr)\n{\n\tstruct ath12k_reo_queue_ref *qref;\n\tstruct ath12k_dp *dp = &ab->dp;\n\n\tif (!ab->hw_params->reoq_lut_support)\n\t\treturn;\n\n\t \n\tqref = (struct ath12k_reo_queue_ref *)dp->reoq_lut.vaddr +\n\t\t\t(peer_id * (IEEE80211_NUM_TIDS + 1) + tid);\n\n\tqref->info0 = u32_encode_bits(lower_32_bits(paddr),\n\t\t\t\t      BUFFER_ADDR_INFO0_ADDR);\n\tqref->info1 = u32_encode_bits(upper_32_bits(paddr),\n\t\t\t\t      BUFFER_ADDR_INFO1_ADDR) |\n\t\t      u32_encode_bits(tid, DP_REO_QREF_NUM);\n}\n\nstatic void ath12k_peer_rx_tid_qref_reset(struct ath12k_base *ab, u16 peer_id, u16 tid)\n{\n\tstruct ath12k_reo_queue_ref *qref;\n\tstruct ath12k_dp *dp = &ab->dp;\n\n\tif (!ab->hw_params->reoq_lut_support)\n\t\treturn;\n\n\t \n\tqref = (struct ath12k_reo_queue_ref *)dp->reoq_lut.vaddr +\n\t\t\t(peer_id * (IEEE80211_NUM_TIDS + 1) + tid);\n\n\tqref->info0 = u32_encode_bits(0, BUFFER_ADDR_INFO0_ADDR);\n\tqref->info1 = u32_encode_bits(0, BUFFER_ADDR_INFO1_ADDR) |\n\t\t      u32_encode_bits(tid, DP_REO_QREF_NUM);\n}\n\nvoid ath12k_dp_rx_peer_tid_delete(struct ath12k *ar,\n\t\t\t\t  struct ath12k_peer *peer, u8 tid)\n{\n\tstruct ath12k_hal_reo_cmd cmd = {0};\n\tstruct ath12k_dp_rx_tid *rx_tid = &peer->rx_tid[tid];\n\tint ret;\n\n\tif (!rx_tid->active)\n\t\treturn;\n\n\tcmd.flag = HAL_REO_CMD_FLG_NEED_STATUS;\n\tcmd.addr_lo = lower_32_bits(rx_tid->paddr);\n\tcmd.addr_hi = upper_32_bits(rx_tid->paddr);\n\tcmd.upd0 = HAL_REO_CMD_UPD0_VLD;\n\tret = ath12k_dp_reo_cmd_send(ar->ab, rx_tid,\n\t\t\t\t     HAL_REO_CMD_UPDATE_RX_QUEUE, &cmd,\n\t\t\t\t     ath12k_dp_rx_tid_del_func);\n\tif (ret) {\n\t\tath12k_err(ar->ab, \"failed to send HAL_REO_CMD_UPDATE_RX_QUEUE cmd, tid %d (%d)\\n\",\n\t\t\t   tid, ret);\n\t\tdma_unmap_single(ar->ab->dev, rx_tid->paddr, rx_tid->size,\n\t\t\t\t DMA_BIDIRECTIONAL);\n\t\tkfree(rx_tid->vaddr);\n\t\trx_tid->vaddr = NULL;\n\t}\n\n\tath12k_peer_rx_tid_qref_reset(ar->ab, peer->peer_id, tid);\n\n\trx_tid->active = false;\n}\n\n \nstatic int ath12k_dp_rx_link_desc_return(struct ath12k_base *ab,\n\t\t\t\t\t struct hal_reo_dest_ring *ring,\n\t\t\t\t\t enum hal_wbm_rel_bm_act action)\n{\n\tstruct hal_wbm_release_ring *link_desc = (struct hal_wbm_release_ring *)ring;\n\tstruct hal_wbm_release_ring *desc;\n\tstruct ath12k_dp *dp = &ab->dp;\n\tstruct hal_srng *srng;\n\tint ret = 0;\n\n\tsrng = &ab->hal.srng_list[dp->wbm_desc_rel_ring.ring_id];\n\n\tspin_lock_bh(&srng->lock);\n\n\tath12k_hal_srng_access_begin(ab, srng);\n\n\tdesc = ath12k_hal_srng_src_get_next_entry(ab, srng);\n\tif (!desc) {\n\t\tret = -ENOBUFS;\n\t\tgoto exit;\n\t}\n\n\tath12k_hal_rx_msdu_link_desc_set(ab, desc, link_desc, action);\n\nexit:\n\tath12k_hal_srng_access_end(ab, srng);\n\n\tspin_unlock_bh(&srng->lock);\n\n\treturn ret;\n}\n\nstatic void ath12k_dp_rx_frags_cleanup(struct ath12k_dp_rx_tid *rx_tid,\n\t\t\t\t       bool rel_link_desc)\n{\n\tstruct ath12k_base *ab = rx_tid->ab;\n\n\tlockdep_assert_held(&ab->base_lock);\n\n\tif (rx_tid->dst_ring_desc) {\n\t\tif (rel_link_desc)\n\t\t\tath12k_dp_rx_link_desc_return(ab, rx_tid->dst_ring_desc,\n\t\t\t\t\t\t      HAL_WBM_REL_BM_ACT_PUT_IN_IDLE);\n\t\tkfree(rx_tid->dst_ring_desc);\n\t\trx_tid->dst_ring_desc = NULL;\n\t}\n\n\trx_tid->cur_sn = 0;\n\trx_tid->last_frag_no = 0;\n\trx_tid->rx_frag_bitmap = 0;\n\t__skb_queue_purge(&rx_tid->rx_frags);\n}\n\nvoid ath12k_dp_rx_peer_tid_cleanup(struct ath12k *ar, struct ath12k_peer *peer)\n{\n\tstruct ath12k_dp_rx_tid *rx_tid;\n\tint i;\n\n\tlockdep_assert_held(&ar->ab->base_lock);\n\n\tfor (i = 0; i <= IEEE80211_NUM_TIDS; i++) {\n\t\trx_tid = &peer->rx_tid[i];\n\n\t\tath12k_dp_rx_peer_tid_delete(ar, peer, i);\n\t\tath12k_dp_rx_frags_cleanup(rx_tid, true);\n\n\t\tspin_unlock_bh(&ar->ab->base_lock);\n\t\tdel_timer_sync(&rx_tid->frag_timer);\n\t\tspin_lock_bh(&ar->ab->base_lock);\n\t}\n}\n\nstatic int ath12k_peer_rx_tid_reo_update(struct ath12k *ar,\n\t\t\t\t\t struct ath12k_peer *peer,\n\t\t\t\t\t struct ath12k_dp_rx_tid *rx_tid,\n\t\t\t\t\t u32 ba_win_sz, u16 ssn,\n\t\t\t\t\t bool update_ssn)\n{\n\tstruct ath12k_hal_reo_cmd cmd = {0};\n\tint ret;\n\n\tcmd.addr_lo = lower_32_bits(rx_tid->paddr);\n\tcmd.addr_hi = upper_32_bits(rx_tid->paddr);\n\tcmd.flag = HAL_REO_CMD_FLG_NEED_STATUS;\n\tcmd.upd0 = HAL_REO_CMD_UPD0_BA_WINDOW_SIZE;\n\tcmd.ba_window_size = ba_win_sz;\n\n\tif (update_ssn) {\n\t\tcmd.upd0 |= HAL_REO_CMD_UPD0_SSN;\n\t\tcmd.upd2 = u32_encode_bits(ssn, HAL_REO_CMD_UPD2_SSN);\n\t}\n\n\tret = ath12k_dp_reo_cmd_send(ar->ab, rx_tid,\n\t\t\t\t     HAL_REO_CMD_UPDATE_RX_QUEUE, &cmd,\n\t\t\t\t     NULL);\n\tif (ret) {\n\t\tath12k_warn(ar->ab, \"failed to update rx tid queue, tid %d (%d)\\n\",\n\t\t\t    rx_tid->tid, ret);\n\t\treturn ret;\n\t}\n\n\trx_tid->ba_win_sz = ba_win_sz;\n\n\treturn 0;\n}\n\nint ath12k_dp_rx_peer_tid_setup(struct ath12k *ar, const u8 *peer_mac, int vdev_id,\n\t\t\t\tu8 tid, u32 ba_win_sz, u16 ssn,\n\t\t\t\tenum hal_pn_type pn_type)\n{\n\tstruct ath12k_base *ab = ar->ab;\n\tstruct ath12k_dp *dp = &ab->dp;\n\tstruct hal_rx_reo_queue *addr_aligned;\n\tstruct ath12k_peer *peer;\n\tstruct ath12k_dp_rx_tid *rx_tid;\n\tu32 hw_desc_sz;\n\tvoid *vaddr;\n\tdma_addr_t paddr;\n\tint ret;\n\n\tspin_lock_bh(&ab->base_lock);\n\n\tpeer = ath12k_peer_find(ab, vdev_id, peer_mac);\n\tif (!peer) {\n\t\tspin_unlock_bh(&ab->base_lock);\n\t\tath12k_warn(ab, \"failed to find the peer to set up rx tid\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tif (ab->hw_params->reoq_lut_support && !dp->reoq_lut.vaddr) {\n\t\tspin_unlock_bh(&ab->base_lock);\n\t\tath12k_warn(ab, \"reo qref table is not setup\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (peer->peer_id > DP_MAX_PEER_ID || tid > IEEE80211_NUM_TIDS) {\n\t\tath12k_warn(ab, \"peer id of peer %d or tid %d doesn't allow reoq setup\\n\",\n\t\t\t    peer->peer_id, tid);\n\t\tspin_unlock_bh(&ab->base_lock);\n\t\treturn -EINVAL;\n\t}\n\n\trx_tid = &peer->rx_tid[tid];\n\t \n\tif (rx_tid->active) {\n\t\tpaddr = rx_tid->paddr;\n\t\tret = ath12k_peer_rx_tid_reo_update(ar, peer, rx_tid,\n\t\t\t\t\t\t    ba_win_sz, ssn, true);\n\t\tspin_unlock_bh(&ab->base_lock);\n\t\tif (ret) {\n\t\t\tath12k_warn(ab, \"failed to update reo for rx tid %d\\n\", tid);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!ab->hw_params->reoq_lut_support) {\n\t\t\tret = ath12k_wmi_peer_rx_reorder_queue_setup(ar, vdev_id,\n\t\t\t\t\t\t\t\t     peer_mac,\n\t\t\t\t\t\t\t\t     paddr, tid, 1,\n\t\t\t\t\t\t\t\t     ba_win_sz);\n\t\t\tif (ret) {\n\t\t\t\tath12k_warn(ab, \"failed to setup peer rx reorder queuefor tid %d: %d\\n\",\n\t\t\t\t\t    tid, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\trx_tid->tid = tid;\n\n\trx_tid->ba_win_sz = ba_win_sz;\n\n\t \n\tif (tid == HAL_DESC_REO_NON_QOS_TID)\n\t\thw_desc_sz = ath12k_hal_reo_qdesc_size(ba_win_sz, tid);\n\telse\n\t\thw_desc_sz = ath12k_hal_reo_qdesc_size(DP_BA_WIN_SZ_MAX, tid);\n\n\tvaddr = kzalloc(hw_desc_sz + HAL_LINK_DESC_ALIGN - 1, GFP_ATOMIC);\n\tif (!vaddr) {\n\t\tspin_unlock_bh(&ab->base_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\taddr_aligned = PTR_ALIGN(vaddr, HAL_LINK_DESC_ALIGN);\n\n\tath12k_hal_reo_qdesc_setup(addr_aligned, tid, ba_win_sz,\n\t\t\t\t   ssn, pn_type);\n\n\tpaddr = dma_map_single(ab->dev, addr_aligned, hw_desc_sz,\n\t\t\t       DMA_BIDIRECTIONAL);\n\n\tret = dma_mapping_error(ab->dev, paddr);\n\tif (ret) {\n\t\tspin_unlock_bh(&ab->base_lock);\n\t\tgoto err_mem_free;\n\t}\n\n\trx_tid->vaddr = vaddr;\n\trx_tid->paddr = paddr;\n\trx_tid->size = hw_desc_sz;\n\trx_tid->active = true;\n\n\tif (ab->hw_params->reoq_lut_support) {\n\t\t \n\t\tath12k_peer_rx_tid_qref_setup(ab, peer->peer_id, tid, paddr);\n\t\tspin_unlock_bh(&ab->base_lock);\n\t} else {\n\t\tspin_unlock_bh(&ab->base_lock);\n\t\tret = ath12k_wmi_peer_rx_reorder_queue_setup(ar, vdev_id, peer_mac,\n\t\t\t\t\t\t\t     paddr, tid, 1, ba_win_sz);\n\t}\n\n\treturn ret;\n\nerr_mem_free:\n\tkfree(vaddr);\n\n\treturn ret;\n}\n\nint ath12k_dp_rx_ampdu_start(struct ath12k *ar,\n\t\t\t     struct ieee80211_ampdu_params *params)\n{\n\tstruct ath12k_base *ab = ar->ab;\n\tstruct ath12k_sta *arsta = (void *)params->sta->drv_priv;\n\tint vdev_id = arsta->arvif->vdev_id;\n\tint ret;\n\n\tret = ath12k_dp_rx_peer_tid_setup(ar, params->sta->addr, vdev_id,\n\t\t\t\t\t  params->tid, params->buf_size,\n\t\t\t\t\t  params->ssn, arsta->pn_type);\n\tif (ret)\n\t\tath12k_warn(ab, \"failed to setup rx tid %d\\n\", ret);\n\n\treturn ret;\n}\n\nint ath12k_dp_rx_ampdu_stop(struct ath12k *ar,\n\t\t\t    struct ieee80211_ampdu_params *params)\n{\n\tstruct ath12k_base *ab = ar->ab;\n\tstruct ath12k_peer *peer;\n\tstruct ath12k_sta *arsta = (void *)params->sta->drv_priv;\n\tint vdev_id = arsta->arvif->vdev_id;\n\tbool active;\n\tint ret;\n\n\tspin_lock_bh(&ab->base_lock);\n\n\tpeer = ath12k_peer_find(ab, vdev_id, params->sta->addr);\n\tif (!peer) {\n\t\tspin_unlock_bh(&ab->base_lock);\n\t\tath12k_warn(ab, \"failed to find the peer to stop rx aggregation\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tactive = peer->rx_tid[params->tid].active;\n\n\tif (!active) {\n\t\tspin_unlock_bh(&ab->base_lock);\n\t\treturn 0;\n\t}\n\n\tret = ath12k_peer_rx_tid_reo_update(ar, peer, peer->rx_tid, 1, 0, false);\n\tspin_unlock_bh(&ab->base_lock);\n\tif (ret) {\n\t\tath12k_warn(ab, \"failed to update reo for rx tid %d: %d\\n\",\n\t\t\t    params->tid, ret);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nint ath12k_dp_rx_peer_pn_replay_config(struct ath12k_vif *arvif,\n\t\t\t\t       const u8 *peer_addr,\n\t\t\t\t       enum set_key_cmd key_cmd,\n\t\t\t\t       struct ieee80211_key_conf *key)\n{\n\tstruct ath12k *ar = arvif->ar;\n\tstruct ath12k_base *ab = ar->ab;\n\tstruct ath12k_hal_reo_cmd cmd = {0};\n\tstruct ath12k_peer *peer;\n\tstruct ath12k_dp_rx_tid *rx_tid;\n\tu8 tid;\n\tint ret = 0;\n\n\t \n\tif (!(key->flags & IEEE80211_KEY_FLAG_PAIRWISE))\n\t\treturn 0;\n\n\tcmd.flag = HAL_REO_CMD_FLG_NEED_STATUS;\n\tcmd.upd0 = HAL_REO_CMD_UPD0_PN |\n\t\t    HAL_REO_CMD_UPD0_PN_SIZE |\n\t\t    HAL_REO_CMD_UPD0_PN_VALID |\n\t\t    HAL_REO_CMD_UPD0_PN_CHECK |\n\t\t    HAL_REO_CMD_UPD0_SVLD;\n\n\tswitch (key->cipher) {\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\tcase WLAN_CIPHER_SUITE_CCMP_256:\n\tcase WLAN_CIPHER_SUITE_GCMP:\n\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\tif (key_cmd == SET_KEY) {\n\t\t\tcmd.upd1 |= HAL_REO_CMD_UPD1_PN_CHECK;\n\t\t\tcmd.pn_size = 48;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tspin_lock_bh(&ab->base_lock);\n\n\tpeer = ath12k_peer_find(ab, arvif->vdev_id, peer_addr);\n\tif (!peer) {\n\t\tspin_unlock_bh(&ab->base_lock);\n\t\tath12k_warn(ab, \"failed to find the peer %pM to configure pn replay detection\\n\",\n\t\t\t    peer_addr);\n\t\treturn -ENOENT;\n\t}\n\n\tfor (tid = 0; tid <= IEEE80211_NUM_TIDS; tid++) {\n\t\trx_tid = &peer->rx_tid[tid];\n\t\tif (!rx_tid->active)\n\t\t\tcontinue;\n\t\tcmd.addr_lo = lower_32_bits(rx_tid->paddr);\n\t\tcmd.addr_hi = upper_32_bits(rx_tid->paddr);\n\t\tret = ath12k_dp_reo_cmd_send(ab, rx_tid,\n\t\t\t\t\t     HAL_REO_CMD_UPDATE_RX_QUEUE,\n\t\t\t\t\t     &cmd, NULL);\n\t\tif (ret) {\n\t\t\tath12k_warn(ab, \"failed to configure rx tid %d queue of peer %pM for pn replay detection %d\\n\",\n\t\t\t\t    tid, peer_addr, ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_bh(&ab->base_lock);\n\n\treturn ret;\n}\n\nstatic int ath12k_get_ppdu_user_index(struct htt_ppdu_stats *ppdu_stats,\n\t\t\t\t      u16 peer_id)\n{\n\tint i;\n\n\tfor (i = 0; i < HTT_PPDU_STATS_MAX_USERS - 1; i++) {\n\t\tif (ppdu_stats->user_stats[i].is_valid_peer_id) {\n\t\t\tif (peer_id == ppdu_stats->user_stats[i].peer_id)\n\t\t\t\treturn i;\n\t\t} else {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int ath12k_htt_tlv_ppdu_stats_parse(struct ath12k_base *ab,\n\t\t\t\t\t   u16 tag, u16 len, const void *ptr,\n\t\t\t\t\t   void *data)\n{\n\tconst struct htt_ppdu_stats_usr_cmpltn_ack_ba_status *ba_status;\n\tconst struct htt_ppdu_stats_usr_cmpltn_cmn *cmplt_cmn;\n\tconst struct htt_ppdu_stats_user_rate *user_rate;\n\tstruct htt_ppdu_stats_info *ppdu_info;\n\tstruct htt_ppdu_user_stats *user_stats;\n\tint cur_user;\n\tu16 peer_id;\n\n\tppdu_info = data;\n\n\tswitch (tag) {\n\tcase HTT_PPDU_STATS_TAG_COMMON:\n\t\tif (len < sizeof(struct htt_ppdu_stats_common)) {\n\t\t\tath12k_warn(ab, \"Invalid len %d for the tag 0x%x\\n\",\n\t\t\t\t    len, tag);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmemcpy(&ppdu_info->ppdu_stats.common, ptr,\n\t\t       sizeof(struct htt_ppdu_stats_common));\n\t\tbreak;\n\tcase HTT_PPDU_STATS_TAG_USR_RATE:\n\t\tif (len < sizeof(struct htt_ppdu_stats_user_rate)) {\n\t\t\tath12k_warn(ab, \"Invalid len %d for the tag 0x%x\\n\",\n\t\t\t\t    len, tag);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tuser_rate = ptr;\n\t\tpeer_id = le16_to_cpu(user_rate->sw_peer_id);\n\t\tcur_user = ath12k_get_ppdu_user_index(&ppdu_info->ppdu_stats,\n\t\t\t\t\t\t      peer_id);\n\t\tif (cur_user < 0)\n\t\t\treturn -EINVAL;\n\t\tuser_stats = &ppdu_info->ppdu_stats.user_stats[cur_user];\n\t\tuser_stats->peer_id = peer_id;\n\t\tuser_stats->is_valid_peer_id = true;\n\t\tmemcpy(&user_stats->rate, ptr,\n\t\t       sizeof(struct htt_ppdu_stats_user_rate));\n\t\tuser_stats->tlv_flags |= BIT(tag);\n\t\tbreak;\n\tcase HTT_PPDU_STATS_TAG_USR_COMPLTN_COMMON:\n\t\tif (len < sizeof(struct htt_ppdu_stats_usr_cmpltn_cmn)) {\n\t\t\tath12k_warn(ab, \"Invalid len %d for the tag 0x%x\\n\",\n\t\t\t\t    len, tag);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tcmplt_cmn = ptr;\n\t\tpeer_id = le16_to_cpu(cmplt_cmn->sw_peer_id);\n\t\tcur_user = ath12k_get_ppdu_user_index(&ppdu_info->ppdu_stats,\n\t\t\t\t\t\t      peer_id);\n\t\tif (cur_user < 0)\n\t\t\treturn -EINVAL;\n\t\tuser_stats = &ppdu_info->ppdu_stats.user_stats[cur_user];\n\t\tuser_stats->peer_id = peer_id;\n\t\tuser_stats->is_valid_peer_id = true;\n\t\tmemcpy(&user_stats->cmpltn_cmn, ptr,\n\t\t       sizeof(struct htt_ppdu_stats_usr_cmpltn_cmn));\n\t\tuser_stats->tlv_flags |= BIT(tag);\n\t\tbreak;\n\tcase HTT_PPDU_STATS_TAG_USR_COMPLTN_ACK_BA_STATUS:\n\t\tif (len <\n\t\t    sizeof(struct htt_ppdu_stats_usr_cmpltn_ack_ba_status)) {\n\t\t\tath12k_warn(ab, \"Invalid len %d for the tag 0x%x\\n\",\n\t\t\t\t    len, tag);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tba_status = ptr;\n\t\tpeer_id = le16_to_cpu(ba_status->sw_peer_id);\n\t\tcur_user = ath12k_get_ppdu_user_index(&ppdu_info->ppdu_stats,\n\t\t\t\t\t\t      peer_id);\n\t\tif (cur_user < 0)\n\t\t\treturn -EINVAL;\n\t\tuser_stats = &ppdu_info->ppdu_stats.user_stats[cur_user];\n\t\tuser_stats->peer_id = peer_id;\n\t\tuser_stats->is_valid_peer_id = true;\n\t\tmemcpy(&user_stats->ack_ba, ptr,\n\t\t       sizeof(struct htt_ppdu_stats_usr_cmpltn_ack_ba_status));\n\t\tuser_stats->tlv_flags |= BIT(tag);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int ath12k_dp_htt_tlv_iter(struct ath12k_base *ab, const void *ptr, size_t len,\n\t\t\t\t  int (*iter)(struct ath12k_base *ar, u16 tag, u16 len,\n\t\t\t\t\t      const void *ptr, void *data),\n\t\t\t\t  void *data)\n{\n\tconst struct htt_tlv *tlv;\n\tconst void *begin = ptr;\n\tu16 tlv_tag, tlv_len;\n\tint ret = -EINVAL;\n\n\twhile (len > 0) {\n\t\tif (len < sizeof(*tlv)) {\n\t\t\tath12k_err(ab, \"htt tlv parse failure at byte %zd (%zu bytes left, %zu expected)\\n\",\n\t\t\t\t   ptr - begin, len, sizeof(*tlv));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttlv = (struct htt_tlv *)ptr;\n\t\ttlv_tag = le32_get_bits(tlv->header, HTT_TLV_TAG);\n\t\ttlv_len = le32_get_bits(tlv->header, HTT_TLV_LEN);\n\t\tptr += sizeof(*tlv);\n\t\tlen -= sizeof(*tlv);\n\n\t\tif (tlv_len > len) {\n\t\t\tath12k_err(ab, \"htt tlv parse failure of tag %u at byte %zd (%zu bytes left, %u expected)\\n\",\n\t\t\t\t   tlv_tag, ptr - begin, len, tlv_len);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tret = iter(ab, tlv_tag, tlv_len, ptr, data);\n\t\tif (ret == -ENOMEM)\n\t\t\treturn ret;\n\n\t\tptr += tlv_len;\n\t\tlen -= tlv_len;\n\t}\n\treturn 0;\n}\n\nstatic void\nath12k_update_per_peer_tx_stats(struct ath12k *ar,\n\t\t\t\tstruct htt_ppdu_stats *ppdu_stats, u8 user)\n{\n\tstruct ath12k_base *ab = ar->ab;\n\tstruct ath12k_peer *peer;\n\tstruct ieee80211_sta *sta;\n\tstruct ath12k_sta *arsta;\n\tstruct htt_ppdu_stats_user_rate *user_rate;\n\tstruct ath12k_per_peer_tx_stats *peer_stats = &ar->peer_tx_stats;\n\tstruct htt_ppdu_user_stats *usr_stats = &ppdu_stats->user_stats[user];\n\tstruct htt_ppdu_stats_common *common = &ppdu_stats->common;\n\tint ret;\n\tu8 flags, mcs, nss, bw, sgi, dcm, rate_idx = 0;\n\tu32 v, succ_bytes = 0;\n\tu16 tones, rate = 0, succ_pkts = 0;\n\tu32 tx_duration = 0;\n\tu8 tid = HTT_PPDU_STATS_NON_QOS_TID;\n\tbool is_ampdu = false;\n\n\tif (!usr_stats)\n\t\treturn;\n\n\tif (!(usr_stats->tlv_flags & BIT(HTT_PPDU_STATS_TAG_USR_RATE)))\n\t\treturn;\n\n\tif (usr_stats->tlv_flags & BIT(HTT_PPDU_STATS_TAG_USR_COMPLTN_COMMON))\n\t\tis_ampdu =\n\t\t\tHTT_USR_CMPLTN_IS_AMPDU(usr_stats->cmpltn_cmn.flags);\n\n\tif (usr_stats->tlv_flags &\n\t    BIT(HTT_PPDU_STATS_TAG_USR_COMPLTN_ACK_BA_STATUS)) {\n\t\tsucc_bytes = le32_to_cpu(usr_stats->ack_ba.success_bytes);\n\t\tsucc_pkts = le32_get_bits(usr_stats->ack_ba.info,\n\t\t\t\t\t  HTT_PPDU_STATS_ACK_BA_INFO_NUM_MSDU_M);\n\t\ttid = le32_get_bits(usr_stats->ack_ba.info,\n\t\t\t\t    HTT_PPDU_STATS_ACK_BA_INFO_TID_NUM);\n\t}\n\n\tif (common->fes_duration_us)\n\t\ttx_duration = le32_to_cpu(common->fes_duration_us);\n\n\tuser_rate = &usr_stats->rate;\n\tflags = HTT_USR_RATE_PREAMBLE(user_rate->rate_flags);\n\tbw = HTT_USR_RATE_BW(user_rate->rate_flags) - 2;\n\tnss = HTT_USR_RATE_NSS(user_rate->rate_flags) + 1;\n\tmcs = HTT_USR_RATE_MCS(user_rate->rate_flags);\n\tsgi = HTT_USR_RATE_GI(user_rate->rate_flags);\n\tdcm = HTT_USR_RATE_DCM(user_rate->rate_flags);\n\n\t \n\n\tif (flags == WMI_RATE_PREAMBLE_HE && mcs > ATH12K_HE_MCS_MAX) {\n\t\tath12k_warn(ab, \"Invalid HE mcs %d peer stats\",  mcs);\n\t\treturn;\n\t}\n\n\tif (flags == WMI_RATE_PREAMBLE_VHT && mcs > ATH12K_VHT_MCS_MAX) {\n\t\tath12k_warn(ab, \"Invalid VHT mcs %d peer stats\",  mcs);\n\t\treturn;\n\t}\n\n\tif (flags == WMI_RATE_PREAMBLE_HT && (mcs > ATH12K_HT_MCS_MAX || nss < 1)) {\n\t\tath12k_warn(ab, \"Invalid HT mcs %d nss %d peer stats\",\n\t\t\t    mcs, nss);\n\t\treturn;\n\t}\n\n\tif (flags == WMI_RATE_PREAMBLE_CCK || flags == WMI_RATE_PREAMBLE_OFDM) {\n\t\tret = ath12k_mac_hw_ratecode_to_legacy_rate(mcs,\n\t\t\t\t\t\t\t    flags,\n\t\t\t\t\t\t\t    &rate_idx,\n\t\t\t\t\t\t\t    &rate);\n\t\tif (ret < 0)\n\t\t\treturn;\n\t}\n\n\trcu_read_lock();\n\tspin_lock_bh(&ab->base_lock);\n\tpeer = ath12k_peer_find_by_id(ab, usr_stats->peer_id);\n\n\tif (!peer || !peer->sta) {\n\t\tspin_unlock_bh(&ab->base_lock);\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tsta = peer->sta;\n\tarsta = (struct ath12k_sta *)sta->drv_priv;\n\n\tmemset(&arsta->txrate, 0, sizeof(arsta->txrate));\n\n\tswitch (flags) {\n\tcase WMI_RATE_PREAMBLE_OFDM:\n\t\tarsta->txrate.legacy = rate;\n\t\tbreak;\n\tcase WMI_RATE_PREAMBLE_CCK:\n\t\tarsta->txrate.legacy = rate;\n\t\tbreak;\n\tcase WMI_RATE_PREAMBLE_HT:\n\t\tarsta->txrate.mcs = mcs + 8 * (nss - 1);\n\t\tarsta->txrate.flags = RATE_INFO_FLAGS_MCS;\n\t\tif (sgi)\n\t\t\tarsta->txrate.flags |= RATE_INFO_FLAGS_SHORT_GI;\n\t\tbreak;\n\tcase WMI_RATE_PREAMBLE_VHT:\n\t\tarsta->txrate.mcs = mcs;\n\t\tarsta->txrate.flags = RATE_INFO_FLAGS_VHT_MCS;\n\t\tif (sgi)\n\t\t\tarsta->txrate.flags |= RATE_INFO_FLAGS_SHORT_GI;\n\t\tbreak;\n\tcase WMI_RATE_PREAMBLE_HE:\n\t\tarsta->txrate.mcs = mcs;\n\t\tarsta->txrate.flags = RATE_INFO_FLAGS_HE_MCS;\n\t\tarsta->txrate.he_dcm = dcm;\n\t\tarsta->txrate.he_gi = ath12k_he_gi_to_nl80211_he_gi(sgi);\n\t\ttones = le16_to_cpu(user_rate->ru_end) -\n\t\t\tle16_to_cpu(user_rate->ru_start) + 1;\n\t\tv = ath12k_he_ru_tones_to_nl80211_he_ru_alloc(tones);\n\t\tarsta->txrate.he_ru_alloc = v;\n\t\tbreak;\n\t}\n\n\tarsta->txrate.nss = nss;\n\tarsta->txrate.bw = ath12k_mac_bw_to_mac80211_bw(bw);\n\tarsta->tx_duration += tx_duration;\n\tmemcpy(&arsta->last_txrate, &arsta->txrate, sizeof(struct rate_info));\n\n\t \n\tif (tid < HTT_PPDU_STATS_NON_QOS_TID) {\n\t\tmemset(peer_stats, 0, sizeof(*peer_stats));\n\t\tpeer_stats->succ_pkts = succ_pkts;\n\t\tpeer_stats->succ_bytes = succ_bytes;\n\t\tpeer_stats->is_ampdu = is_ampdu;\n\t\tpeer_stats->duration = tx_duration;\n\t\tpeer_stats->ba_fails =\n\t\t\tHTT_USR_CMPLTN_LONG_RETRY(usr_stats->cmpltn_cmn.flags) +\n\t\t\tHTT_USR_CMPLTN_SHORT_RETRY(usr_stats->cmpltn_cmn.flags);\n\t}\n\n\tspin_unlock_bh(&ab->base_lock);\n\trcu_read_unlock();\n}\n\nstatic void ath12k_htt_update_ppdu_stats(struct ath12k *ar,\n\t\t\t\t\t struct htt_ppdu_stats *ppdu_stats)\n{\n\tu8 user;\n\n\tfor (user = 0; user < HTT_PPDU_STATS_MAX_USERS - 1; user++)\n\t\tath12k_update_per_peer_tx_stats(ar, ppdu_stats, user);\n}\n\nstatic\nstruct htt_ppdu_stats_info *ath12k_dp_htt_get_ppdu_desc(struct ath12k *ar,\n\t\t\t\t\t\t\tu32 ppdu_id)\n{\n\tstruct htt_ppdu_stats_info *ppdu_info;\n\n\tlockdep_assert_held(&ar->data_lock);\n\tif (!list_empty(&ar->ppdu_stats_info)) {\n\t\tlist_for_each_entry(ppdu_info, &ar->ppdu_stats_info, list) {\n\t\t\tif (ppdu_info->ppdu_id == ppdu_id)\n\t\t\t\treturn ppdu_info;\n\t\t}\n\n\t\tif (ar->ppdu_stat_list_depth > HTT_PPDU_DESC_MAX_DEPTH) {\n\t\t\tppdu_info = list_first_entry(&ar->ppdu_stats_info,\n\t\t\t\t\t\t     typeof(*ppdu_info), list);\n\t\t\tlist_del(&ppdu_info->list);\n\t\t\tar->ppdu_stat_list_depth--;\n\t\t\tath12k_htt_update_ppdu_stats(ar, &ppdu_info->ppdu_stats);\n\t\t\tkfree(ppdu_info);\n\t\t}\n\t}\n\n\tppdu_info = kzalloc(sizeof(*ppdu_info), GFP_ATOMIC);\n\tif (!ppdu_info)\n\t\treturn NULL;\n\n\tlist_add_tail(&ppdu_info->list, &ar->ppdu_stats_info);\n\tar->ppdu_stat_list_depth++;\n\n\treturn ppdu_info;\n}\n\nstatic void ath12k_copy_to_delay_stats(struct ath12k_peer *peer,\n\t\t\t\t       struct htt_ppdu_user_stats *usr_stats)\n{\n\tpeer->ppdu_stats_delayba.sw_peer_id = le16_to_cpu(usr_stats->rate.sw_peer_id);\n\tpeer->ppdu_stats_delayba.info0 = le32_to_cpu(usr_stats->rate.info0);\n\tpeer->ppdu_stats_delayba.ru_end = le16_to_cpu(usr_stats->rate.ru_end);\n\tpeer->ppdu_stats_delayba.ru_start = le16_to_cpu(usr_stats->rate.ru_start);\n\tpeer->ppdu_stats_delayba.info1 = le32_to_cpu(usr_stats->rate.info1);\n\tpeer->ppdu_stats_delayba.rate_flags = le32_to_cpu(usr_stats->rate.rate_flags);\n\tpeer->ppdu_stats_delayba.resp_rate_flags =\n\t\tle32_to_cpu(usr_stats->rate.resp_rate_flags);\n\n\tpeer->delayba_flag = true;\n}\n\nstatic void ath12k_copy_to_bar(struct ath12k_peer *peer,\n\t\t\t       struct htt_ppdu_user_stats *usr_stats)\n{\n\tusr_stats->rate.sw_peer_id = cpu_to_le16(peer->ppdu_stats_delayba.sw_peer_id);\n\tusr_stats->rate.info0 = cpu_to_le32(peer->ppdu_stats_delayba.info0);\n\tusr_stats->rate.ru_end = cpu_to_le16(peer->ppdu_stats_delayba.ru_end);\n\tusr_stats->rate.ru_start = cpu_to_le16(peer->ppdu_stats_delayba.ru_start);\n\tusr_stats->rate.info1 = cpu_to_le32(peer->ppdu_stats_delayba.info1);\n\tusr_stats->rate.rate_flags = cpu_to_le32(peer->ppdu_stats_delayba.rate_flags);\n\tusr_stats->rate.resp_rate_flags =\n\t\tcpu_to_le32(peer->ppdu_stats_delayba.resp_rate_flags);\n\n\tpeer->delayba_flag = false;\n}\n\nstatic int ath12k_htt_pull_ppdu_stats(struct ath12k_base *ab,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct ath12k_htt_ppdu_stats_msg *msg;\n\tstruct htt_ppdu_stats_info *ppdu_info;\n\tstruct ath12k_peer *peer = NULL;\n\tstruct htt_ppdu_user_stats *usr_stats = NULL;\n\tu32 peer_id = 0;\n\tstruct ath12k *ar;\n\tint ret, i;\n\tu8 pdev_id;\n\tu32 ppdu_id, len;\n\n\tmsg = (struct ath12k_htt_ppdu_stats_msg *)skb->data;\n\tlen = le32_get_bits(msg->info, HTT_T2H_PPDU_STATS_INFO_PAYLOAD_SIZE);\n\tif (len > (skb->len - struct_size(msg, data, 0))) {\n\t\tath12k_warn(ab,\n\t\t\t    \"HTT PPDU STATS event has unexpected payload size %u, should be smaller than %u\\n\",\n\t\t\t    len, skb->len);\n\t\treturn -EINVAL;\n\t}\n\n\tpdev_id = le32_get_bits(msg->info, HTT_T2H_PPDU_STATS_INFO_PDEV_ID);\n\tppdu_id = le32_to_cpu(msg->ppdu_id);\n\n\trcu_read_lock();\n\tar = ath12k_mac_get_ar_by_pdev_id(ab, pdev_id);\n\tif (!ar) {\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tspin_lock_bh(&ar->data_lock);\n\tppdu_info = ath12k_dp_htt_get_ppdu_desc(ar, ppdu_id);\n\tif (!ppdu_info) {\n\t\tspin_unlock_bh(&ar->data_lock);\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tppdu_info->ppdu_id = ppdu_id;\n\tret = ath12k_dp_htt_tlv_iter(ab, msg->data, len,\n\t\t\t\t     ath12k_htt_tlv_ppdu_stats_parse,\n\t\t\t\t     (void *)ppdu_info);\n\tif (ret) {\n\t\tspin_unlock_bh(&ar->data_lock);\n\t\tath12k_warn(ab, \"Failed to parse tlv %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tif (ppdu_info->ppdu_stats.common.num_users >= HTT_PPDU_STATS_MAX_USERS) {\n\t\tspin_unlock_bh(&ar->data_lock);\n\t\tath12k_warn(ab,\n\t\t\t    \"HTT PPDU STATS event has unexpected num_users %u, should be smaller than %u\\n\",\n\t\t\t    ppdu_info->ppdu_stats.common.num_users,\n\t\t\t    HTT_PPDU_STATS_MAX_USERS);\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\t \n\tif (ppdu_info->frame_type == HTT_STATS_PPDU_FTYPE_DATA &&\n\t    (ppdu_info->tlv_bitmap & (1 << HTT_PPDU_STATS_TAG_USR_COMMON)) &&\n\t    ppdu_info->delay_ba) {\n\t\tfor (i = 0; i < ppdu_info->ppdu_stats.common.num_users; i++) {\n\t\t\tpeer_id = ppdu_info->ppdu_stats.user_stats[i].peer_id;\n\t\t\tspin_lock_bh(&ab->base_lock);\n\t\t\tpeer = ath12k_peer_find_by_id(ab, peer_id);\n\t\t\tif (!peer) {\n\t\t\t\tspin_unlock_bh(&ab->base_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tusr_stats = &ppdu_info->ppdu_stats.user_stats[i];\n\t\t\tif (usr_stats->delay_ba)\n\t\t\t\tath12k_copy_to_delay_stats(peer, usr_stats);\n\t\t\tspin_unlock_bh(&ab->base_lock);\n\t\t}\n\t}\n\n\t \n\tif (ppdu_info->frame_type == HTT_STATS_PPDU_FTYPE_BAR &&\n\t    (ppdu_info->tlv_bitmap & (1 << HTT_PPDU_STATS_TAG_USR_COMMON))) {\n\t\tfor (i = 0; i < ppdu_info->bar_num_users; i++) {\n\t\t\tpeer_id = ppdu_info->ppdu_stats.user_stats[i].peer_id;\n\t\t\tspin_lock_bh(&ab->base_lock);\n\t\t\tpeer = ath12k_peer_find_by_id(ab, peer_id);\n\t\t\tif (!peer) {\n\t\t\t\tspin_unlock_bh(&ab->base_lock);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tusr_stats = &ppdu_info->ppdu_stats.user_stats[i];\n\t\t\tif (peer->delayba_flag)\n\t\t\t\tath12k_copy_to_bar(peer, usr_stats);\n\t\t\tspin_unlock_bh(&ab->base_lock);\n\t\t}\n\t}\n\n\tspin_unlock_bh(&ar->data_lock);\n\nexit:\n\trcu_read_unlock();\n\n\treturn ret;\n}\n\nstatic void ath12k_htt_mlo_offset_event_handler(struct ath12k_base *ab,\n\t\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct ath12k_htt_mlo_offset_msg *msg;\n\tstruct ath12k_pdev *pdev;\n\tstruct ath12k *ar;\n\tu8 pdev_id;\n\n\tmsg = (struct ath12k_htt_mlo_offset_msg *)skb->data;\n\tpdev_id = u32_get_bits(__le32_to_cpu(msg->info),\n\t\t\t       HTT_T2H_MLO_OFFSET_INFO_PDEV_ID);\n\n\trcu_read_lock();\n\tar = ath12k_mac_get_ar_by_pdev_id(ab, pdev_id);\n\tif (!ar) {\n\t\tath12k_warn(ab, \"invalid pdev id %d on htt mlo offset\\n\", pdev_id);\n\t\tgoto exit;\n\t}\n\n\tspin_lock_bh(&ar->data_lock);\n\tpdev = ar->pdev;\n\n\tpdev->timestamp.info = __le32_to_cpu(msg->info);\n\tpdev->timestamp.sync_timestamp_lo_us = __le32_to_cpu(msg->sync_timestamp_lo_us);\n\tpdev->timestamp.sync_timestamp_hi_us = __le32_to_cpu(msg->sync_timestamp_hi_us);\n\tpdev->timestamp.mlo_offset_lo = __le32_to_cpu(msg->mlo_offset_lo);\n\tpdev->timestamp.mlo_offset_hi = __le32_to_cpu(msg->mlo_offset_hi);\n\tpdev->timestamp.mlo_offset_clks = __le32_to_cpu(msg->mlo_offset_clks);\n\tpdev->timestamp.mlo_comp_clks = __le32_to_cpu(msg->mlo_comp_clks);\n\tpdev->timestamp.mlo_comp_timer = __le32_to_cpu(msg->mlo_comp_timer);\n\n\tspin_unlock_bh(&ar->data_lock);\nexit:\n\trcu_read_unlock();\n}\n\nvoid ath12k_dp_htt_htc_t2h_msg_handler(struct ath12k_base *ab,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tstruct ath12k_dp *dp = &ab->dp;\n\tstruct htt_resp_msg *resp = (struct htt_resp_msg *)skb->data;\n\tenum htt_t2h_msg_type type;\n\tu16 peer_id;\n\tu8 vdev_id;\n\tu8 mac_addr[ETH_ALEN];\n\tu16 peer_mac_h16;\n\tu16 ast_hash = 0;\n\tu16 hw_peer_id;\n\n\ttype = le32_get_bits(resp->version_msg.version, HTT_T2H_MSG_TYPE);\n\n\tath12k_dbg(ab, ATH12K_DBG_DP_HTT, \"dp_htt rx msg type :0x%0x\\n\", type);\n\n\tswitch (type) {\n\tcase HTT_T2H_MSG_TYPE_VERSION_CONF:\n\t\tdp->htt_tgt_ver_major = le32_get_bits(resp->version_msg.version,\n\t\t\t\t\t\t      HTT_T2H_VERSION_CONF_MAJOR);\n\t\tdp->htt_tgt_ver_minor = le32_get_bits(resp->version_msg.version,\n\t\t\t\t\t\t      HTT_T2H_VERSION_CONF_MINOR);\n\t\tcomplete(&dp->htt_tgt_version_received);\n\t\tbreak;\n\t \n\tcase HTT_T2H_MSG_TYPE_PEER_MAP:\n\t\tvdev_id = le32_get_bits(resp->peer_map_ev.info,\n\t\t\t\t\tHTT_T2H_PEER_MAP_INFO_VDEV_ID);\n\t\tpeer_id = le32_get_bits(resp->peer_map_ev.info,\n\t\t\t\t\tHTT_T2H_PEER_MAP_INFO_PEER_ID);\n\t\tpeer_mac_h16 = le32_get_bits(resp->peer_map_ev.info1,\n\t\t\t\t\t     HTT_T2H_PEER_MAP_INFO1_MAC_ADDR_H16);\n\t\tath12k_dp_get_mac_addr(le32_to_cpu(resp->peer_map_ev.mac_addr_l32),\n\t\t\t\t       peer_mac_h16, mac_addr);\n\t\tath12k_peer_map_event(ab, vdev_id, peer_id, mac_addr, 0, 0);\n\t\tbreak;\n\tcase HTT_T2H_MSG_TYPE_PEER_MAP2:\n\t\tvdev_id = le32_get_bits(resp->peer_map_ev.info,\n\t\t\t\t\tHTT_T2H_PEER_MAP_INFO_VDEV_ID);\n\t\tpeer_id = le32_get_bits(resp->peer_map_ev.info,\n\t\t\t\t\tHTT_T2H_PEER_MAP_INFO_PEER_ID);\n\t\tpeer_mac_h16 = le32_get_bits(resp->peer_map_ev.info1,\n\t\t\t\t\t     HTT_T2H_PEER_MAP_INFO1_MAC_ADDR_H16);\n\t\tath12k_dp_get_mac_addr(le32_to_cpu(resp->peer_map_ev.mac_addr_l32),\n\t\t\t\t       peer_mac_h16, mac_addr);\n\t\tast_hash = le32_get_bits(resp->peer_map_ev.info2,\n\t\t\t\t\t HTT_T2H_PEER_MAP_INFO2_AST_HASH_VAL);\n\t\thw_peer_id = le32_get_bits(resp->peer_map_ev.info1,\n\t\t\t\t\t   HTT_T2H_PEER_MAP_INFO1_HW_PEER_ID);\n\t\tath12k_peer_map_event(ab, vdev_id, peer_id, mac_addr, ast_hash,\n\t\t\t\t      hw_peer_id);\n\t\tbreak;\n\tcase HTT_T2H_MSG_TYPE_PEER_MAP3:\n\t\tvdev_id = le32_get_bits(resp->peer_map_ev.info,\n\t\t\t\t\tHTT_T2H_PEER_MAP_INFO_VDEV_ID);\n\t\tpeer_id = le32_get_bits(resp->peer_map_ev.info,\n\t\t\t\t\tHTT_T2H_PEER_MAP_INFO_PEER_ID);\n\t\tpeer_mac_h16 = le32_get_bits(resp->peer_map_ev.info1,\n\t\t\t\t\t     HTT_T2H_PEER_MAP_INFO1_MAC_ADDR_H16);\n\t\tath12k_dp_get_mac_addr(le32_to_cpu(resp->peer_map_ev.mac_addr_l32),\n\t\t\t\t       peer_mac_h16, mac_addr);\n\t\tath12k_peer_map_event(ab, vdev_id, peer_id, mac_addr, ast_hash,\n\t\t\t\t      peer_id);\n\t\tbreak;\n\tcase HTT_T2H_MSG_TYPE_PEER_UNMAP:\n\tcase HTT_T2H_MSG_TYPE_PEER_UNMAP2:\n\t\tpeer_id = le32_get_bits(resp->peer_unmap_ev.info,\n\t\t\t\t\tHTT_T2H_PEER_UNMAP_INFO_PEER_ID);\n\t\tath12k_peer_unmap_event(ab, peer_id);\n\t\tbreak;\n\tcase HTT_T2H_MSG_TYPE_PPDU_STATS_IND:\n\t\tath12k_htt_pull_ppdu_stats(ab, skb);\n\t\tbreak;\n\tcase HTT_T2H_MSG_TYPE_EXT_STATS_CONF:\n\t\tbreak;\n\tcase HTT_T2H_MSG_TYPE_MLO_TIMESTAMP_OFFSET_IND:\n\t\tath12k_htt_mlo_offset_event_handler(ab, skb);\n\t\tbreak;\n\tdefault:\n\t\tath12k_dbg(ab, ATH12K_DBG_DP_HTT, \"dp_htt event %d not handled\\n\",\n\t\t\t   type);\n\t\tbreak;\n\t}\n\n\tdev_kfree_skb_any(skb);\n}\n\nstatic int ath12k_dp_rx_msdu_coalesce(struct ath12k *ar,\n\t\t\t\t      struct sk_buff_head *msdu_list,\n\t\t\t\t      struct sk_buff *first, struct sk_buff *last,\n\t\t\t\t      u8 l3pad_bytes, int msdu_len)\n{\n\tstruct ath12k_base *ab = ar->ab;\n\tstruct sk_buff *skb;\n\tstruct ath12k_skb_rxcb *rxcb = ATH12K_SKB_RXCB(first);\n\tint buf_first_hdr_len, buf_first_len;\n\tstruct hal_rx_desc *ldesc;\n\tint space_extra, rem_len, buf_len;\n\tu32 hal_rx_desc_sz = ar->ab->hw_params->hal_desc_sz;\n\n\t \n\tbuf_first_hdr_len = hal_rx_desc_sz + l3pad_bytes;\n\tbuf_first_len = DP_RX_BUFFER_SIZE - buf_first_hdr_len;\n\n\tif (WARN_ON_ONCE(msdu_len <= buf_first_len)) {\n\t\tskb_put(first, buf_first_hdr_len + msdu_len);\n\t\tskb_pull(first, buf_first_hdr_len);\n\t\treturn 0;\n\t}\n\n\tldesc = (struct hal_rx_desc *)last->data;\n\trxcb->is_first_msdu = ath12k_dp_rx_h_first_msdu(ab, ldesc);\n\trxcb->is_last_msdu = ath12k_dp_rx_h_last_msdu(ab, ldesc);\n\n\t \n\tskb_put(first, DP_RX_BUFFER_SIZE);\n\tskb_pull(first, buf_first_hdr_len);\n\n\t \n\tath12k_dp_rx_desc_end_tlv_copy(ab, rxcb->rx_desc, ldesc);\n\n\tspace_extra = msdu_len - (buf_first_len + skb_tailroom(first));\n\tif (space_extra > 0 &&\n\t    (pskb_expand_head(first, 0, space_extra, GFP_ATOMIC) < 0)) {\n\t\t \n\t\twhile ((skb = __skb_dequeue(msdu_list)) != NULL) {\n\t\t\trxcb = ATH12K_SKB_RXCB(skb);\n\t\t\tif (!rxcb->is_continuation) {\n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdev_kfree_skb_any(skb);\n\t\t}\n\t\treturn -ENOMEM;\n\t}\n\n\trem_len = msdu_len - buf_first_len;\n\twhile ((skb = __skb_dequeue(msdu_list)) != NULL && rem_len > 0) {\n\t\trxcb = ATH12K_SKB_RXCB(skb);\n\t\tif (rxcb->is_continuation)\n\t\t\tbuf_len = DP_RX_BUFFER_SIZE - hal_rx_desc_sz;\n\t\telse\n\t\t\tbuf_len = rem_len;\n\n\t\tif (buf_len > (DP_RX_BUFFER_SIZE - hal_rx_desc_sz)) {\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tskb_put(skb, buf_len + hal_rx_desc_sz);\n\t\tskb_pull(skb, hal_rx_desc_sz);\n\t\tskb_copy_from_linear_data(skb, skb_put(first, buf_len),\n\t\t\t\t\t  buf_len);\n\t\tdev_kfree_skb_any(skb);\n\n\t\trem_len -= buf_len;\n\t\tif (!rxcb->is_continuation)\n\t\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic struct sk_buff *ath12k_dp_rx_get_msdu_last_buf(struct sk_buff_head *msdu_list,\n\t\t\t\t\t\t      struct sk_buff *first)\n{\n\tstruct sk_buff *skb;\n\tstruct ath12k_skb_rxcb *rxcb = ATH12K_SKB_RXCB(first);\n\n\tif (!rxcb->is_continuation)\n\t\treturn first;\n\n\tskb_queue_walk(msdu_list, skb) {\n\t\trxcb = ATH12K_SKB_RXCB(skb);\n\t\tif (!rxcb->is_continuation)\n\t\t\treturn skb;\n\t}\n\n\treturn NULL;\n}\n\nstatic void ath12k_dp_rx_h_csum_offload(struct ath12k *ar, struct sk_buff *msdu)\n{\n\tstruct ath12k_skb_rxcb *rxcb = ATH12K_SKB_RXCB(msdu);\n\tstruct ath12k_base *ab = ar->ab;\n\tbool ip_csum_fail, l4_csum_fail;\n\n\tip_csum_fail = ath12k_dp_rx_h_ip_cksum_fail(ab, rxcb->rx_desc);\n\tl4_csum_fail = ath12k_dp_rx_h_l4_cksum_fail(ab, rxcb->rx_desc);\n\n\tmsdu->ip_summed = (ip_csum_fail || l4_csum_fail) ?\n\t\t\t  CHECKSUM_NONE : CHECKSUM_UNNECESSARY;\n}\n\nstatic int ath12k_dp_rx_crypto_mic_len(struct ath12k *ar,\n\t\t\t\t       enum hal_encrypt_type enctype)\n{\n\tswitch (enctype) {\n\tcase HAL_ENCRYPT_TYPE_OPEN:\n\tcase HAL_ENCRYPT_TYPE_TKIP_NO_MIC:\n\tcase HAL_ENCRYPT_TYPE_TKIP_MIC:\n\t\treturn 0;\n\tcase HAL_ENCRYPT_TYPE_CCMP_128:\n\t\treturn IEEE80211_CCMP_MIC_LEN;\n\tcase HAL_ENCRYPT_TYPE_CCMP_256:\n\t\treturn IEEE80211_CCMP_256_MIC_LEN;\n\tcase HAL_ENCRYPT_TYPE_GCMP_128:\n\tcase HAL_ENCRYPT_TYPE_AES_GCMP_256:\n\t\treturn IEEE80211_GCMP_MIC_LEN;\n\tcase HAL_ENCRYPT_TYPE_WEP_40:\n\tcase HAL_ENCRYPT_TYPE_WEP_104:\n\tcase HAL_ENCRYPT_TYPE_WEP_128:\n\tcase HAL_ENCRYPT_TYPE_WAPI_GCM_SM4:\n\tcase HAL_ENCRYPT_TYPE_WAPI:\n\t\tbreak;\n\t}\n\n\tath12k_warn(ar->ab, \"unsupported encryption type %d for mic len\\n\", enctype);\n\treturn 0;\n}\n\nstatic int ath12k_dp_rx_crypto_param_len(struct ath12k *ar,\n\t\t\t\t\t enum hal_encrypt_type enctype)\n{\n\tswitch (enctype) {\n\tcase HAL_ENCRYPT_TYPE_OPEN:\n\t\treturn 0;\n\tcase HAL_ENCRYPT_TYPE_TKIP_NO_MIC:\n\tcase HAL_ENCRYPT_TYPE_TKIP_MIC:\n\t\treturn IEEE80211_TKIP_IV_LEN;\n\tcase HAL_ENCRYPT_TYPE_CCMP_128:\n\t\treturn IEEE80211_CCMP_HDR_LEN;\n\tcase HAL_ENCRYPT_TYPE_CCMP_256:\n\t\treturn IEEE80211_CCMP_256_HDR_LEN;\n\tcase HAL_ENCRYPT_TYPE_GCMP_128:\n\tcase HAL_ENCRYPT_TYPE_AES_GCMP_256:\n\t\treturn IEEE80211_GCMP_HDR_LEN;\n\tcase HAL_ENCRYPT_TYPE_WEP_40:\n\tcase HAL_ENCRYPT_TYPE_WEP_104:\n\tcase HAL_ENCRYPT_TYPE_WEP_128:\n\tcase HAL_ENCRYPT_TYPE_WAPI_GCM_SM4:\n\tcase HAL_ENCRYPT_TYPE_WAPI:\n\t\tbreak;\n\t}\n\n\tath12k_warn(ar->ab, \"unsupported encryption type %d\\n\", enctype);\n\treturn 0;\n}\n\nstatic int ath12k_dp_rx_crypto_icv_len(struct ath12k *ar,\n\t\t\t\t       enum hal_encrypt_type enctype)\n{\n\tswitch (enctype) {\n\tcase HAL_ENCRYPT_TYPE_OPEN:\n\tcase HAL_ENCRYPT_TYPE_CCMP_128:\n\tcase HAL_ENCRYPT_TYPE_CCMP_256:\n\tcase HAL_ENCRYPT_TYPE_GCMP_128:\n\tcase HAL_ENCRYPT_TYPE_AES_GCMP_256:\n\t\treturn 0;\n\tcase HAL_ENCRYPT_TYPE_TKIP_NO_MIC:\n\tcase HAL_ENCRYPT_TYPE_TKIP_MIC:\n\t\treturn IEEE80211_TKIP_ICV_LEN;\n\tcase HAL_ENCRYPT_TYPE_WEP_40:\n\tcase HAL_ENCRYPT_TYPE_WEP_104:\n\tcase HAL_ENCRYPT_TYPE_WEP_128:\n\tcase HAL_ENCRYPT_TYPE_WAPI_GCM_SM4:\n\tcase HAL_ENCRYPT_TYPE_WAPI:\n\t\tbreak;\n\t}\n\n\tath12k_warn(ar->ab, \"unsupported encryption type %d\\n\", enctype);\n\treturn 0;\n}\n\nstatic void ath12k_dp_rx_h_undecap_nwifi(struct ath12k *ar,\n\t\t\t\t\t struct sk_buff *msdu,\n\t\t\t\t\t enum hal_encrypt_type enctype,\n\t\t\t\t\t struct ieee80211_rx_status *status)\n{\n\tstruct ath12k_base *ab = ar->ab;\n\tstruct ath12k_skb_rxcb *rxcb = ATH12K_SKB_RXCB(msdu);\n\tu8 decap_hdr[DP_MAX_NWIFI_HDR_LEN];\n\tstruct ieee80211_hdr *hdr;\n\tsize_t hdr_len;\n\tu8 *crypto_hdr;\n\tu16 qos_ctl;\n\n\t \n\thdr = (struct ieee80211_hdr *)msdu->data;\n\thdr_len = ieee80211_hdrlen(hdr->frame_control);\n\tskb_pull(msdu, hdr_len);\n\n\t \n\thdr->frame_control |= __cpu_to_le16(IEEE80211_STYPE_QOS_DATA);\n\n\t \n\thdr->frame_control &= ~(__cpu_to_le16(IEEE80211_FCTL_ORDER));\n\n\tqos_ctl = rxcb->tid;\n\n\tif (ath12k_dp_rx_h_mesh_ctl_present(ab, rxcb->rx_desc))\n\t\tqos_ctl |= IEEE80211_QOS_CTL_MESH_CONTROL_PRESENT;\n\n\t \n\n\t \n\tmemcpy(decap_hdr, hdr, hdr_len);\n\n\t \n\tif (!(status->flag & RX_FLAG_IV_STRIPPED)) {\n\t\tcrypto_hdr = skb_push(msdu, ath12k_dp_rx_crypto_param_len(ar, enctype));\n\t\tath12k_dp_rx_desc_get_crypto_header(ar->ab,\n\t\t\t\t\t\t    rxcb->rx_desc, crypto_hdr,\n\t\t\t\t\t\t    enctype);\n\t}\n\n\tmemcpy(skb_push(msdu,\n\t\t\tIEEE80211_QOS_CTL_LEN), &qos_ctl,\n\t\t\tIEEE80211_QOS_CTL_LEN);\n\tmemcpy(skb_push(msdu, hdr_len), decap_hdr, hdr_len);\n}\n\nstatic void ath12k_dp_rx_h_undecap_raw(struct ath12k *ar, struct sk_buff *msdu,\n\t\t\t\t       enum hal_encrypt_type enctype,\n\t\t\t\t       struct ieee80211_rx_status *status,\n\t\t\t\t       bool decrypted)\n{\n\tstruct ath12k_skb_rxcb *rxcb = ATH12K_SKB_RXCB(msdu);\n\tstruct ieee80211_hdr *hdr;\n\tsize_t hdr_len;\n\tsize_t crypto_len;\n\n\tif (!rxcb->is_first_msdu ||\n\t    !(rxcb->is_first_msdu && rxcb->is_last_msdu)) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\n\tskb_trim(msdu, msdu->len - FCS_LEN);\n\n\tif (!decrypted)\n\t\treturn;\n\n\thdr = (void *)msdu->data;\n\n\t \n\tif (status->flag & RX_FLAG_IV_STRIPPED) {\n\t\tskb_trim(msdu, msdu->len -\n\t\t\t ath12k_dp_rx_crypto_mic_len(ar, enctype));\n\n\t\tskb_trim(msdu, msdu->len -\n\t\t\t ath12k_dp_rx_crypto_icv_len(ar, enctype));\n\t} else {\n\t\t \n\t\tif (status->flag & RX_FLAG_MIC_STRIPPED)\n\t\t\tskb_trim(msdu, msdu->len -\n\t\t\t\t ath12k_dp_rx_crypto_mic_len(ar, enctype));\n\n\t\t \n\t\tif (status->flag & RX_FLAG_ICV_STRIPPED)\n\t\t\tskb_trim(msdu, msdu->len -\n\t\t\t\t ath12k_dp_rx_crypto_icv_len(ar, enctype));\n\t}\n\n\t \n\tif ((status->flag & RX_FLAG_MMIC_STRIPPED) &&\n\t    !ieee80211_has_morefrags(hdr->frame_control) &&\n\t    enctype == HAL_ENCRYPT_TYPE_TKIP_MIC)\n\t\tskb_trim(msdu, msdu->len - IEEE80211_CCMP_MIC_LEN);\n\n\t \n\tif (status->flag & RX_FLAG_IV_STRIPPED) {\n\t\thdr_len = ieee80211_hdrlen(hdr->frame_control);\n\t\tcrypto_len = ath12k_dp_rx_crypto_param_len(ar, enctype);\n\n\t\tmemmove(msdu->data + crypto_len, msdu->data, hdr_len);\n\t\tskb_pull(msdu, crypto_len);\n\t}\n}\n\nstatic void ath12k_get_dot11_hdr_from_rx_desc(struct ath12k *ar,\n\t\t\t\t\t      struct sk_buff *msdu,\n\t\t\t\t\t      struct ath12k_skb_rxcb *rxcb,\n\t\t\t\t\t      struct ieee80211_rx_status *status,\n\t\t\t\t\t      enum hal_encrypt_type enctype)\n{\n\tstruct hal_rx_desc *rx_desc = rxcb->rx_desc;\n\tstruct ath12k_base *ab = ar->ab;\n\tsize_t hdr_len, crypto_len;\n\tstruct ieee80211_hdr *hdr;\n\tu16 qos_ctl;\n\t__le16 fc;\n\tu8 *crypto_hdr;\n\n\tif (!(status->flag & RX_FLAG_IV_STRIPPED)) {\n\t\tcrypto_len = ath12k_dp_rx_crypto_param_len(ar, enctype);\n\t\tcrypto_hdr = skb_push(msdu, crypto_len);\n\t\tath12k_dp_rx_desc_get_crypto_header(ab, rx_desc, crypto_hdr, enctype);\n\t}\n\n\tfc = cpu_to_le16(ath12k_dp_rxdesc_get_mpdu_frame_ctrl(ab, rx_desc));\n\thdr_len = ieee80211_hdrlen(fc);\n\tskb_push(msdu, hdr_len);\n\thdr = (struct ieee80211_hdr *)msdu->data;\n\thdr->frame_control = fc;\n\n\t \n\tath12k_dp_rx_desc_get_dot11_hdr(ab, rx_desc, hdr);\n\n\tif (rxcb->is_mcbc)\n\t\tstatus->flag &= ~RX_FLAG_PN_VALIDATED;\n\n\t \n\tif (ieee80211_is_data_qos(hdr->frame_control)) {\n\t\tqos_ctl = rxcb->tid;\n\t\tif (ath12k_dp_rx_h_mesh_ctl_present(ab, rx_desc))\n\t\t\tqos_ctl |= IEEE80211_QOS_CTL_MESH_CONTROL_PRESENT;\n\n\t\t \n\t\tmemcpy(msdu->data + (hdr_len - IEEE80211_QOS_CTL_LEN),\n\t\t       &qos_ctl, IEEE80211_QOS_CTL_LEN);\n\t}\n}\n\nstatic void ath12k_dp_rx_h_undecap_eth(struct ath12k *ar,\n\t\t\t\t       struct sk_buff *msdu,\n\t\t\t\t       enum hal_encrypt_type enctype,\n\t\t\t\t       struct ieee80211_rx_status *status)\n{\n\tstruct ieee80211_hdr *hdr;\n\tstruct ethhdr *eth;\n\tu8 da[ETH_ALEN];\n\tu8 sa[ETH_ALEN];\n\tstruct ath12k_skb_rxcb *rxcb = ATH12K_SKB_RXCB(msdu);\n\tstruct ath12k_dp_rx_rfc1042_hdr rfc = {0xaa, 0xaa, 0x03, {0x00, 0x00, 0x00}};\n\n\teth = (struct ethhdr *)msdu->data;\n\tether_addr_copy(da, eth->h_dest);\n\tether_addr_copy(sa, eth->h_source);\n\trfc.snap_type = eth->h_proto;\n\tskb_pull(msdu, sizeof(*eth));\n\tmemcpy(skb_push(msdu, sizeof(rfc)), &rfc,\n\t       sizeof(rfc));\n\tath12k_get_dot11_hdr_from_rx_desc(ar, msdu, rxcb, status, enctype);\n\n\t \n\thdr = (struct ieee80211_hdr *)msdu->data;\n\tether_addr_copy(ieee80211_get_DA(hdr), da);\n\tether_addr_copy(ieee80211_get_SA(hdr), sa);\n}\n\nstatic void ath12k_dp_rx_h_undecap(struct ath12k *ar, struct sk_buff *msdu,\n\t\t\t\t   struct hal_rx_desc *rx_desc,\n\t\t\t\t   enum hal_encrypt_type enctype,\n\t\t\t\t   struct ieee80211_rx_status *status,\n\t\t\t\t   bool decrypted)\n{\n\tstruct ath12k_base *ab = ar->ab;\n\tu8 decap;\n\tstruct ethhdr *ehdr;\n\n\tdecap = ath12k_dp_rx_h_decap_type(ab, rx_desc);\n\n\tswitch (decap) {\n\tcase DP_RX_DECAP_TYPE_NATIVE_WIFI:\n\t\tath12k_dp_rx_h_undecap_nwifi(ar, msdu, enctype, status);\n\t\tbreak;\n\tcase DP_RX_DECAP_TYPE_RAW:\n\t\tath12k_dp_rx_h_undecap_raw(ar, msdu, enctype, status,\n\t\t\t\t\t   decrypted);\n\t\tbreak;\n\tcase DP_RX_DECAP_TYPE_ETHERNET2_DIX:\n\t\tehdr = (struct ethhdr *)msdu->data;\n\n\t\t \n\t\tif (ehdr->h_proto == cpu_to_be16(ETH_P_PAE)) {\n\t\t\tATH12K_SKB_RXCB(msdu)->is_eapol = true;\n\t\t\tath12k_dp_rx_h_undecap_eth(ar, msdu, enctype, status);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (ATH12K_SKB_RXCB(msdu)->is_mcbc && decrypted)\n\t\t\tath12k_dp_rx_h_undecap_eth(ar, msdu, enctype, status);\n\t\tbreak;\n\tcase DP_RX_DECAP_TYPE_8023:\n\t\t \n\t\tbreak;\n\t}\n}\n\nstruct ath12k_peer *\nath12k_dp_rx_h_find_peer(struct ath12k_base *ab, struct sk_buff *msdu)\n{\n\tstruct ath12k_skb_rxcb *rxcb = ATH12K_SKB_RXCB(msdu);\n\tstruct hal_rx_desc *rx_desc = rxcb->rx_desc;\n\tstruct ath12k_peer *peer = NULL;\n\n\tlockdep_assert_held(&ab->base_lock);\n\n\tif (rxcb->peer_id)\n\t\tpeer = ath12k_peer_find_by_id(ab, rxcb->peer_id);\n\n\tif (peer)\n\t\treturn peer;\n\n\tif (!rx_desc || !(ath12k_dp_rxdesc_mac_addr2_valid(ab, rx_desc)))\n\t\treturn NULL;\n\n\tpeer = ath12k_peer_find_by_addr(ab,\n\t\t\t\t\tath12k_dp_rxdesc_get_mpdu_start_addr2(ab,\n\t\t\t\t\t\t\t\t\t      rx_desc));\n\treturn peer;\n}\n\nstatic void ath12k_dp_rx_h_mpdu(struct ath12k *ar,\n\t\t\t\tstruct sk_buff *msdu,\n\t\t\t\tstruct hal_rx_desc *rx_desc,\n\t\t\t\tstruct ieee80211_rx_status *rx_status)\n{\n\tbool  fill_crypto_hdr;\n\tstruct ath12k_base *ab = ar->ab;\n\tstruct ath12k_skb_rxcb *rxcb;\n\tenum hal_encrypt_type enctype;\n\tbool is_decrypted = false;\n\tstruct ieee80211_hdr *hdr;\n\tstruct ath12k_peer *peer;\n\tu32 err_bitmap;\n\n\t \n\trxcb = ATH12K_SKB_RXCB(msdu);\n\tfill_crypto_hdr = ath12k_dp_rx_h_is_da_mcbc(ar->ab, rx_desc);\n\trxcb->is_mcbc = fill_crypto_hdr;\n\n\tif (rxcb->is_mcbc)\n\t\trxcb->peer_id = ath12k_dp_rx_h_peer_id(ar->ab, rx_desc);\n\n\tspin_lock_bh(&ar->ab->base_lock);\n\tpeer = ath12k_dp_rx_h_find_peer(ar->ab, msdu);\n\tif (peer) {\n\t\tif (rxcb->is_mcbc)\n\t\t\tenctype = peer->sec_type_grp;\n\t\telse\n\t\t\tenctype = peer->sec_type;\n\t} else {\n\t\tenctype = HAL_ENCRYPT_TYPE_OPEN;\n\t}\n\tspin_unlock_bh(&ar->ab->base_lock);\n\n\terr_bitmap = ath12k_dp_rx_h_mpdu_err(ab, rx_desc);\n\tif (enctype != HAL_ENCRYPT_TYPE_OPEN && !err_bitmap)\n\t\tis_decrypted = ath12k_dp_rx_h_is_decrypted(ab, rx_desc);\n\n\t \n\trx_status->flag &= ~(RX_FLAG_FAILED_FCS_CRC |\n\t\t\t     RX_FLAG_MMIC_ERROR |\n\t\t\t     RX_FLAG_DECRYPTED |\n\t\t\t     RX_FLAG_IV_STRIPPED |\n\t\t\t     RX_FLAG_MMIC_STRIPPED);\n\n\tif (err_bitmap & HAL_RX_MPDU_ERR_FCS)\n\t\trx_status->flag |= RX_FLAG_FAILED_FCS_CRC;\n\tif (err_bitmap & HAL_RX_MPDU_ERR_TKIP_MIC)\n\t\trx_status->flag |= RX_FLAG_MMIC_ERROR;\n\n\tif (is_decrypted) {\n\t\trx_status->flag |= RX_FLAG_DECRYPTED | RX_FLAG_MMIC_STRIPPED;\n\n\t\tif (fill_crypto_hdr)\n\t\t\trx_status->flag |= RX_FLAG_MIC_STRIPPED |\n\t\t\t\t\tRX_FLAG_ICV_STRIPPED;\n\t\telse\n\t\t\trx_status->flag |= RX_FLAG_IV_STRIPPED |\n\t\t\t\t\t   RX_FLAG_PN_VALIDATED;\n\t}\n\n\tath12k_dp_rx_h_csum_offload(ar, msdu);\n\tath12k_dp_rx_h_undecap(ar, msdu, rx_desc,\n\t\t\t       enctype, rx_status, is_decrypted);\n\n\tif (!is_decrypted || fill_crypto_hdr)\n\t\treturn;\n\n\tif (ath12k_dp_rx_h_decap_type(ar->ab, rx_desc) !=\n\t    DP_RX_DECAP_TYPE_ETHERNET2_DIX) {\n\t\thdr = (void *)msdu->data;\n\t\thdr->frame_control &= ~__cpu_to_le16(IEEE80211_FCTL_PROTECTED);\n\t}\n}\n\nstatic void ath12k_dp_rx_h_rate(struct ath12k *ar, struct hal_rx_desc *rx_desc,\n\t\t\t\tstruct ieee80211_rx_status *rx_status)\n{\n\tstruct ath12k_base *ab = ar->ab;\n\tstruct ieee80211_supported_band *sband;\n\tenum rx_msdu_start_pkt_type pkt_type;\n\tu8 bw;\n\tu8 rate_mcs, nss;\n\tu8 sgi;\n\tbool is_cck;\n\n\tpkt_type = ath12k_dp_rx_h_pkt_type(ab, rx_desc);\n\tbw = ath12k_dp_rx_h_rx_bw(ab, rx_desc);\n\trate_mcs = ath12k_dp_rx_h_rate_mcs(ab, rx_desc);\n\tnss = ath12k_dp_rx_h_nss(ab, rx_desc);\n\tsgi = ath12k_dp_rx_h_sgi(ab, rx_desc);\n\n\tswitch (pkt_type) {\n\tcase RX_MSDU_START_PKT_TYPE_11A:\n\tcase RX_MSDU_START_PKT_TYPE_11B:\n\t\tis_cck = (pkt_type == RX_MSDU_START_PKT_TYPE_11B);\n\t\tsband = &ar->mac.sbands[rx_status->band];\n\t\trx_status->rate_idx = ath12k_mac_hw_rate_to_idx(sband, rate_mcs,\n\t\t\t\t\t\t\t\tis_cck);\n\t\tbreak;\n\tcase RX_MSDU_START_PKT_TYPE_11N:\n\t\trx_status->encoding = RX_ENC_HT;\n\t\tif (rate_mcs > ATH12K_HT_MCS_MAX) {\n\t\t\tath12k_warn(ar->ab,\n\t\t\t\t    \"Received with invalid mcs in HT mode %d\\n\",\n\t\t\t\t     rate_mcs);\n\t\t\tbreak;\n\t\t}\n\t\trx_status->rate_idx = rate_mcs + (8 * (nss - 1));\n\t\tif (sgi)\n\t\t\trx_status->enc_flags |= RX_ENC_FLAG_SHORT_GI;\n\t\trx_status->bw = ath12k_mac_bw_to_mac80211_bw(bw);\n\t\tbreak;\n\tcase RX_MSDU_START_PKT_TYPE_11AC:\n\t\trx_status->encoding = RX_ENC_VHT;\n\t\trx_status->rate_idx = rate_mcs;\n\t\tif (rate_mcs > ATH12K_VHT_MCS_MAX) {\n\t\t\tath12k_warn(ar->ab,\n\t\t\t\t    \"Received with invalid mcs in VHT mode %d\\n\",\n\t\t\t\t     rate_mcs);\n\t\t\tbreak;\n\t\t}\n\t\trx_status->nss = nss;\n\t\tif (sgi)\n\t\t\trx_status->enc_flags |= RX_ENC_FLAG_SHORT_GI;\n\t\trx_status->bw = ath12k_mac_bw_to_mac80211_bw(bw);\n\t\tbreak;\n\tcase RX_MSDU_START_PKT_TYPE_11AX:\n\t\trx_status->rate_idx = rate_mcs;\n\t\tif (rate_mcs > ATH12K_HE_MCS_MAX) {\n\t\t\tath12k_warn(ar->ab,\n\t\t\t\t    \"Received with invalid mcs in HE mode %d\\n\",\n\t\t\t\t    rate_mcs);\n\t\t\tbreak;\n\t\t}\n\t\trx_status->encoding = RX_ENC_HE;\n\t\trx_status->nss = nss;\n\t\trx_status->he_gi = ath12k_he_gi_to_nl80211_he_gi(sgi);\n\t\trx_status->bw = ath12k_mac_bw_to_mac80211_bw(bw);\n\t\tbreak;\n\t}\n}\n\nvoid ath12k_dp_rx_h_ppdu(struct ath12k *ar, struct hal_rx_desc *rx_desc,\n\t\t\t struct ieee80211_rx_status *rx_status)\n{\n\tstruct ath12k_base *ab = ar->ab;\n\tu8 channel_num;\n\tu32 center_freq, meta_data;\n\tstruct ieee80211_channel *channel;\n\n\trx_status->freq = 0;\n\trx_status->rate_idx = 0;\n\trx_status->nss = 0;\n\trx_status->encoding = RX_ENC_LEGACY;\n\trx_status->bw = RATE_INFO_BW_20;\n\trx_status->enc_flags = 0;\n\n\trx_status->flag |= RX_FLAG_NO_SIGNAL_VAL;\n\n\tmeta_data = ath12k_dp_rx_h_freq(ab, rx_desc);\n\tchannel_num = meta_data;\n\tcenter_freq = meta_data >> 16;\n\n\tif (center_freq >= 5935 && center_freq <= 7105) {\n\t\trx_status->band = NL80211_BAND_6GHZ;\n\t} else if (channel_num >= 1 && channel_num <= 14) {\n\t\trx_status->band = NL80211_BAND_2GHZ;\n\t} else if (channel_num >= 36 && channel_num <= 173) {\n\t\trx_status->band = NL80211_BAND_5GHZ;\n\t} else {\n\t\tspin_lock_bh(&ar->data_lock);\n\t\tchannel = ar->rx_channel;\n\t\tif (channel) {\n\t\t\trx_status->band = channel->band;\n\t\t\tchannel_num =\n\t\t\t\tieee80211_frequency_to_channel(channel->center_freq);\n\t\t}\n\t\tspin_unlock_bh(&ar->data_lock);\n\t\tath12k_dbg_dump(ar->ab, ATH12K_DBG_DATA, NULL, \"rx_desc: \",\n\t\t\t\trx_desc, sizeof(*rx_desc));\n\t}\n\n\trx_status->freq = ieee80211_channel_to_frequency(channel_num,\n\t\t\t\t\t\t\t rx_status->band);\n\n\tath12k_dp_rx_h_rate(ar, rx_desc, rx_status);\n}\n\nstatic void ath12k_dp_rx_deliver_msdu(struct ath12k *ar, struct napi_struct *napi,\n\t\t\t\t      struct sk_buff *msdu,\n\t\t\t\t      struct ieee80211_rx_status *status)\n{\n\tstruct ath12k_base *ab = ar->ab;\n\tstatic const struct ieee80211_radiotap_he known = {\n\t\t.data1 = cpu_to_le16(IEEE80211_RADIOTAP_HE_DATA1_DATA_MCS_KNOWN |\n\t\t\t\t     IEEE80211_RADIOTAP_HE_DATA1_BW_RU_ALLOC_KNOWN),\n\t\t.data2 = cpu_to_le16(IEEE80211_RADIOTAP_HE_DATA2_GI_KNOWN),\n\t};\n\tstruct ieee80211_radiotap_he *he;\n\tstruct ieee80211_rx_status *rx_status;\n\tstruct ieee80211_sta *pubsta;\n\tstruct ath12k_peer *peer;\n\tstruct ath12k_skb_rxcb *rxcb = ATH12K_SKB_RXCB(msdu);\n\tu8 decap = DP_RX_DECAP_TYPE_RAW;\n\tbool is_mcbc = rxcb->is_mcbc;\n\tbool is_eapol = rxcb->is_eapol;\n\n\tif (status->encoding == RX_ENC_HE && !(status->flag & RX_FLAG_RADIOTAP_HE) &&\n\t    !(status->flag & RX_FLAG_SKIP_MONITOR)) {\n\t\the = skb_push(msdu, sizeof(known));\n\t\tmemcpy(he, &known, sizeof(known));\n\t\tstatus->flag |= RX_FLAG_RADIOTAP_HE;\n\t}\n\n\tif (!(status->flag & RX_FLAG_ONLY_MONITOR))\n\t\tdecap = ath12k_dp_rx_h_decap_type(ab, rxcb->rx_desc);\n\n\tspin_lock_bh(&ab->base_lock);\n\tpeer = ath12k_dp_rx_h_find_peer(ab, msdu);\n\n\tpubsta = peer ? peer->sta : NULL;\n\n\tspin_unlock_bh(&ab->base_lock);\n\n\tath12k_dbg(ab, ATH12K_DBG_DATA,\n\t\t   \"rx skb %pK len %u peer %pM %d %s sn %u %s%s%s%s%s%s%s%s rate_idx %u vht_nss %u freq %u band %u flag 0x%x fcs-err %i mic-err %i amsdu-more %i\\n\",\n\t\t   msdu,\n\t\t   msdu->len,\n\t\t   peer ? peer->addr : NULL,\n\t\t   rxcb->tid,\n\t\t   is_mcbc ? \"mcast\" : \"ucast\",\n\t\t   ath12k_dp_rx_h_seq_no(ab, rxcb->rx_desc),\n\t\t   (status->encoding == RX_ENC_LEGACY) ? \"legacy\" : \"\",\n\t\t   (status->encoding == RX_ENC_HT) ? \"ht\" : \"\",\n\t\t   (status->encoding == RX_ENC_VHT) ? \"vht\" : \"\",\n\t\t   (status->encoding == RX_ENC_HE) ? \"he\" : \"\",\n\t\t   (status->bw == RATE_INFO_BW_40) ? \"40\" : \"\",\n\t\t   (status->bw == RATE_INFO_BW_80) ? \"80\" : \"\",\n\t\t   (status->bw == RATE_INFO_BW_160) ? \"160\" : \"\",\n\t\t   status->enc_flags & RX_ENC_FLAG_SHORT_GI ? \"sgi \" : \"\",\n\t\t   status->rate_idx,\n\t\t   status->nss,\n\t\t   status->freq,\n\t\t   status->band, status->flag,\n\t\t   !!(status->flag & RX_FLAG_FAILED_FCS_CRC),\n\t\t   !!(status->flag & RX_FLAG_MMIC_ERROR),\n\t\t   !!(status->flag & RX_FLAG_AMSDU_MORE));\n\n\tath12k_dbg_dump(ab, ATH12K_DBG_DP_RX, NULL, \"dp rx msdu: \",\n\t\t\tmsdu->data, msdu->len);\n\n\trx_status = IEEE80211_SKB_RXCB(msdu);\n\t*rx_status = *status;\n\n\t \n\n\t \n\tif (decap == DP_RX_DECAP_TYPE_ETHERNET2_DIX && !is_eapol &&\n\t    !(is_mcbc && rx_status->flag & RX_FLAG_DECRYPTED))\n\t\trx_status->flag |= RX_FLAG_8023;\n\n\tieee80211_rx_napi(ar->hw, pubsta, msdu, napi);\n}\n\nstatic int ath12k_dp_rx_process_msdu(struct ath12k *ar,\n\t\t\t\t     struct sk_buff *msdu,\n\t\t\t\t     struct sk_buff_head *msdu_list,\n\t\t\t\t     struct ieee80211_rx_status *rx_status)\n{\n\tstruct ath12k_base *ab = ar->ab;\n\tstruct hal_rx_desc *rx_desc, *lrx_desc;\n\tstruct ath12k_skb_rxcb *rxcb;\n\tstruct sk_buff *last_buf;\n\tu8 l3_pad_bytes;\n\tu16 msdu_len;\n\tint ret;\n\tu32 hal_rx_desc_sz = ar->ab->hw_params->hal_desc_sz;\n\n\tlast_buf = ath12k_dp_rx_get_msdu_last_buf(msdu_list, msdu);\n\tif (!last_buf) {\n\t\tath12k_warn(ab,\n\t\t\t    \"No valid Rx buffer to access MSDU_END tlv\\n\");\n\t\tret = -EIO;\n\t\tgoto free_out;\n\t}\n\n\trx_desc = (struct hal_rx_desc *)msdu->data;\n\tlrx_desc = (struct hal_rx_desc *)last_buf->data;\n\tif (!ath12k_dp_rx_h_msdu_done(ab, lrx_desc)) {\n\t\tath12k_warn(ab, \"msdu_done bit in msdu_end is not set\\n\");\n\t\tret = -EIO;\n\t\tgoto free_out;\n\t}\n\n\trxcb = ATH12K_SKB_RXCB(msdu);\n\trxcb->rx_desc = rx_desc;\n\tmsdu_len = ath12k_dp_rx_h_msdu_len(ab, lrx_desc);\n\tl3_pad_bytes = ath12k_dp_rx_h_l3pad(ab, lrx_desc);\n\n\tif (rxcb->is_frag) {\n\t\tskb_pull(msdu, hal_rx_desc_sz);\n\t} else if (!rxcb->is_continuation) {\n\t\tif ((msdu_len + hal_rx_desc_sz) > DP_RX_BUFFER_SIZE) {\n\t\t\tret = -EINVAL;\n\t\t\tath12k_warn(ab, \"invalid msdu len %u\\n\", msdu_len);\n\t\t\tath12k_dbg_dump(ab, ATH12K_DBG_DATA, NULL, \"\", rx_desc,\n\t\t\t\t\tsizeof(*rx_desc));\n\t\t\tgoto free_out;\n\t\t}\n\t\tskb_put(msdu, hal_rx_desc_sz + l3_pad_bytes + msdu_len);\n\t\tskb_pull(msdu, hal_rx_desc_sz + l3_pad_bytes);\n\t} else {\n\t\tret = ath12k_dp_rx_msdu_coalesce(ar, msdu_list,\n\t\t\t\t\t\t msdu, last_buf,\n\t\t\t\t\t\t l3_pad_bytes, msdu_len);\n\t\tif (ret) {\n\t\t\tath12k_warn(ab,\n\t\t\t\t    \"failed to coalesce msdu rx buffer%d\\n\", ret);\n\t\t\tgoto free_out;\n\t\t}\n\t}\n\n\tath12k_dp_rx_h_ppdu(ar, rx_desc, rx_status);\n\tath12k_dp_rx_h_mpdu(ar, msdu, rx_desc, rx_status);\n\n\trx_status->flag |= RX_FLAG_SKIP_MONITOR | RX_FLAG_DUP_VALIDATED;\n\n\treturn 0;\n\nfree_out:\n\treturn ret;\n}\n\nstatic void ath12k_dp_rx_process_received_packets(struct ath12k_base *ab,\n\t\t\t\t\t\t  struct napi_struct *napi,\n\t\t\t\t\t\t  struct sk_buff_head *msdu_list,\n\t\t\t\t\t\t  int ring_id)\n{\n\tstruct ieee80211_rx_status rx_status = {0};\n\tstruct ath12k_skb_rxcb *rxcb;\n\tstruct sk_buff *msdu;\n\tstruct ath12k *ar;\n\tu8 mac_id, pdev_id;\n\tint ret;\n\n\tif (skb_queue_empty(msdu_list))\n\t\treturn;\n\n\trcu_read_lock();\n\n\twhile ((msdu = __skb_dequeue(msdu_list))) {\n\t\trxcb = ATH12K_SKB_RXCB(msdu);\n\t\tmac_id = rxcb->mac_id;\n\t\tpdev_id = ath12k_hw_mac_id_to_pdev_id(ab->hw_params, mac_id);\n\t\tar = ab->pdevs[pdev_id].ar;\n\t\tif (!rcu_dereference(ab->pdevs_active[pdev_id])) {\n\t\t\tdev_kfree_skb_any(msdu);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (test_bit(ATH12K_CAC_RUNNING, &ar->dev_flags)) {\n\t\t\tdev_kfree_skb_any(msdu);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = ath12k_dp_rx_process_msdu(ar, msdu, msdu_list, &rx_status);\n\t\tif (ret) {\n\t\t\tath12k_dbg(ab, ATH12K_DBG_DATA,\n\t\t\t\t   \"Unable to process msdu %d\", ret);\n\t\t\tdev_kfree_skb_any(msdu);\n\t\t\tcontinue;\n\t\t}\n\n\t\tath12k_dp_rx_deliver_msdu(ar, napi, msdu, &rx_status);\n\t}\n\n\trcu_read_unlock();\n}\n\nint ath12k_dp_rx_process(struct ath12k_base *ab, int ring_id,\n\t\t\t struct napi_struct *napi, int budget)\n{\n\tstruct ath12k_rx_desc_info *desc_info;\n\tstruct ath12k_dp *dp = &ab->dp;\n\tstruct dp_rxdma_ring *rx_ring = &dp->rx_refill_buf_ring;\n\tstruct hal_reo_dest_ring *desc;\n\tint num_buffs_reaped = 0;\n\tstruct sk_buff_head msdu_list;\n\tstruct ath12k_skb_rxcb *rxcb;\n\tint total_msdu_reaped = 0;\n\tstruct hal_srng *srng;\n\tstruct sk_buff *msdu;\n\tbool done = false;\n\tint mac_id;\n\tu64 desc_va;\n\n\t__skb_queue_head_init(&msdu_list);\n\n\tsrng = &ab->hal.srng_list[dp->reo_dst_ring[ring_id].ring_id];\n\n\tspin_lock_bh(&srng->lock);\n\ntry_again:\n\tath12k_hal_srng_access_begin(ab, srng);\n\n\twhile ((desc = ath12k_hal_srng_dst_get_next_entry(ab, srng))) {\n\t\tenum hal_reo_dest_ring_push_reason push_reason;\n\t\tu32 cookie;\n\n\t\tcookie = le32_get_bits(desc->buf_addr_info.info1,\n\t\t\t\t       BUFFER_ADDR_INFO1_SW_COOKIE);\n\n\t\tmac_id = le32_get_bits(desc->info0,\n\t\t\t\t       HAL_REO_DEST_RING_INFO0_SRC_LINK_ID);\n\n\t\tdesc_va = ((u64)le32_to_cpu(desc->buf_va_hi) << 32 |\n\t\t\t   le32_to_cpu(desc->buf_va_lo));\n\t\tdesc_info = (struct ath12k_rx_desc_info *)((unsigned long)desc_va);\n\n\t\t \n\t\tif (!desc_info) {\n\t\t\tdesc_info = ath12k_dp_get_rx_desc(ab, cookie);\n\t\t\tif (!desc_info) {\n\t\t\t\tath12k_warn(ab, \"Invalid cookie in manual desc retrieval\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (desc_info->magic != ATH12K_DP_RX_DESC_MAGIC)\n\t\t\tath12k_warn(ab, \"Check HW CC implementation\");\n\n\t\tmsdu = desc_info->skb;\n\t\tdesc_info->skb = NULL;\n\n\t\tspin_lock_bh(&dp->rx_desc_lock);\n\t\tlist_move_tail(&desc_info->list, &dp->rx_desc_free_list);\n\t\tspin_unlock_bh(&dp->rx_desc_lock);\n\n\t\trxcb = ATH12K_SKB_RXCB(msdu);\n\t\tdma_unmap_single(ab->dev, rxcb->paddr,\n\t\t\t\t msdu->len + skb_tailroom(msdu),\n\t\t\t\t DMA_FROM_DEVICE);\n\n\t\tnum_buffs_reaped++;\n\n\t\tpush_reason = le32_get_bits(desc->info0,\n\t\t\t\t\t    HAL_REO_DEST_RING_INFO0_PUSH_REASON);\n\t\tif (push_reason !=\n\t\t    HAL_REO_DEST_RING_PUSH_REASON_ROUTING_INSTRUCTION) {\n\t\t\tdev_kfree_skb_any(msdu);\n\t\t\tab->soc_stats.hal_reo_error[dp->reo_dst_ring[ring_id].ring_id]++;\n\t\t\tcontinue;\n\t\t}\n\n\t\trxcb->is_first_msdu = !!(le32_to_cpu(desc->rx_msdu_info.info0) &\n\t\t\t\t\t RX_MSDU_DESC_INFO0_FIRST_MSDU_IN_MPDU);\n\t\trxcb->is_last_msdu = !!(le32_to_cpu(desc->rx_msdu_info.info0) &\n\t\t\t\t\tRX_MSDU_DESC_INFO0_LAST_MSDU_IN_MPDU);\n\t\trxcb->is_continuation = !!(le32_to_cpu(desc->rx_msdu_info.info0) &\n\t\t\t\t\t   RX_MSDU_DESC_INFO0_MSDU_CONTINUATION);\n\t\trxcb->mac_id = mac_id;\n\t\trxcb->peer_id = le32_get_bits(desc->rx_mpdu_info.peer_meta_data,\n\t\t\t\t\t      RX_MPDU_DESC_META_DATA_PEER_ID);\n\t\trxcb->tid = le32_get_bits(desc->rx_mpdu_info.info0,\n\t\t\t\t\t  RX_MPDU_DESC_INFO0_TID);\n\n\t\t__skb_queue_tail(&msdu_list, msdu);\n\n\t\tif (!rxcb->is_continuation) {\n\t\t\ttotal_msdu_reaped++;\n\t\t\tdone = true;\n\t\t} else {\n\t\t\tdone = false;\n\t\t}\n\n\t\tif (total_msdu_reaped >= budget)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (!done && ath12k_hal_srng_dst_num_free(ab, srng, true)) {\n\t\tath12k_hal_srng_access_end(ab, srng);\n\t\tgoto try_again;\n\t}\n\n\tath12k_hal_srng_access_end(ab, srng);\n\n\tspin_unlock_bh(&srng->lock);\n\n\tif (!total_msdu_reaped)\n\t\tgoto exit;\n\n\t \n\tath12k_dp_rx_bufs_replenish(ab, 0, rx_ring, num_buffs_reaped,\n\t\t\t\t    ab->hw_params->hal_params->rx_buf_rbm, true);\n\n\tath12k_dp_rx_process_received_packets(ab, napi, &msdu_list,\n\t\t\t\t\t      ring_id);\n\nexit:\n\treturn total_msdu_reaped;\n}\n\nstatic void ath12k_dp_rx_frag_timer(struct timer_list *timer)\n{\n\tstruct ath12k_dp_rx_tid *rx_tid = from_timer(rx_tid, timer, frag_timer);\n\n\tspin_lock_bh(&rx_tid->ab->base_lock);\n\tif (rx_tid->last_frag_no &&\n\t    rx_tid->rx_frag_bitmap == GENMASK(rx_tid->last_frag_no, 0)) {\n\t\tspin_unlock_bh(&rx_tid->ab->base_lock);\n\t\treturn;\n\t}\n\tath12k_dp_rx_frags_cleanup(rx_tid, true);\n\tspin_unlock_bh(&rx_tid->ab->base_lock);\n}\n\nint ath12k_dp_rx_peer_frag_setup(struct ath12k *ar, const u8 *peer_mac, int vdev_id)\n{\n\tstruct ath12k_base *ab = ar->ab;\n\tstruct crypto_shash *tfm;\n\tstruct ath12k_peer *peer;\n\tstruct ath12k_dp_rx_tid *rx_tid;\n\tint i;\n\n\ttfm = crypto_alloc_shash(\"michael_mic\", 0, 0);\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\n\tspin_lock_bh(&ab->base_lock);\n\n\tpeer = ath12k_peer_find(ab, vdev_id, peer_mac);\n\tif (!peer) {\n\t\tspin_unlock_bh(&ab->base_lock);\n\t\tath12k_warn(ab, \"failed to find the peer to set up fragment info\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tfor (i = 0; i <= IEEE80211_NUM_TIDS; i++) {\n\t\trx_tid = &peer->rx_tid[i];\n\t\trx_tid->ab = ab;\n\t\ttimer_setup(&rx_tid->frag_timer, ath12k_dp_rx_frag_timer, 0);\n\t\tskb_queue_head_init(&rx_tid->rx_frags);\n\t}\n\n\tpeer->tfm_mmic = tfm;\n\tpeer->dp_setup_done = true;\n\tspin_unlock_bh(&ab->base_lock);\n\n\treturn 0;\n}\n\nstatic int ath12k_dp_rx_h_michael_mic(struct crypto_shash *tfm, u8 *key,\n\t\t\t\t      struct ieee80211_hdr *hdr, u8 *data,\n\t\t\t\t      size_t data_len, u8 *mic)\n{\n\tSHASH_DESC_ON_STACK(desc, tfm);\n\tu8 mic_hdr[16] = {0};\n\tu8 tid = 0;\n\tint ret;\n\n\tif (!tfm)\n\t\treturn -EINVAL;\n\n\tdesc->tfm = tfm;\n\n\tret = crypto_shash_setkey(tfm, key, 8);\n\tif (ret)\n\t\tgoto out;\n\n\tret = crypto_shash_init(desc);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tmemcpy(mic_hdr, ieee80211_get_DA(hdr), ETH_ALEN);\n\tmemcpy(mic_hdr + ETH_ALEN, ieee80211_get_SA(hdr), ETH_ALEN);\n\tif (ieee80211_is_data_qos(hdr->frame_control))\n\t\ttid = ieee80211_get_tid(hdr);\n\tmic_hdr[12] = tid;\n\n\tret = crypto_shash_update(desc, mic_hdr, 16);\n\tif (ret)\n\t\tgoto out;\n\tret = crypto_shash_update(desc, data, data_len);\n\tif (ret)\n\t\tgoto out;\n\tret = crypto_shash_final(desc, mic);\nout:\n\tshash_desc_zero(desc);\n\treturn ret;\n}\n\nstatic int ath12k_dp_rx_h_verify_tkip_mic(struct ath12k *ar, struct ath12k_peer *peer,\n\t\t\t\t\t  struct sk_buff *msdu)\n{\n\tstruct ath12k_base *ab = ar->ab;\n\tstruct hal_rx_desc *rx_desc = (struct hal_rx_desc *)msdu->data;\n\tstruct ieee80211_rx_status *rxs = IEEE80211_SKB_RXCB(msdu);\n\tstruct ieee80211_key_conf *key_conf;\n\tstruct ieee80211_hdr *hdr;\n\tu8 mic[IEEE80211_CCMP_MIC_LEN];\n\tint head_len, tail_len, ret;\n\tsize_t data_len;\n\tu32 hdr_len, hal_rx_desc_sz = ar->ab->hw_params->hal_desc_sz;\n\tu8 *key, *data;\n\tu8 key_idx;\n\n\tif (ath12k_dp_rx_h_enctype(ab, rx_desc) != HAL_ENCRYPT_TYPE_TKIP_MIC)\n\t\treturn 0;\n\n\thdr = (struct ieee80211_hdr *)(msdu->data + hal_rx_desc_sz);\n\thdr_len = ieee80211_hdrlen(hdr->frame_control);\n\thead_len = hdr_len + hal_rx_desc_sz + IEEE80211_TKIP_IV_LEN;\n\ttail_len = IEEE80211_CCMP_MIC_LEN + IEEE80211_TKIP_ICV_LEN + FCS_LEN;\n\n\tif (!is_multicast_ether_addr(hdr->addr1))\n\t\tkey_idx = peer->ucast_keyidx;\n\telse\n\t\tkey_idx = peer->mcast_keyidx;\n\n\tkey_conf = peer->keys[key_idx];\n\n\tdata = msdu->data + head_len;\n\tdata_len = msdu->len - head_len - tail_len;\n\tkey = &key_conf->key[NL80211_TKIP_DATA_OFFSET_RX_MIC_KEY];\n\n\tret = ath12k_dp_rx_h_michael_mic(peer->tfm_mmic, key, hdr, data, data_len, mic);\n\tif (ret || memcmp(mic, data + data_len, IEEE80211_CCMP_MIC_LEN))\n\t\tgoto mic_fail;\n\n\treturn 0;\n\nmic_fail:\n\t(ATH12K_SKB_RXCB(msdu))->is_first_msdu = true;\n\t(ATH12K_SKB_RXCB(msdu))->is_last_msdu = true;\n\n\trxs->flag |= RX_FLAG_MMIC_ERROR | RX_FLAG_MMIC_STRIPPED |\n\t\t    RX_FLAG_IV_STRIPPED | RX_FLAG_DECRYPTED;\n\tskb_pull(msdu, hal_rx_desc_sz);\n\n\tath12k_dp_rx_h_ppdu(ar, rx_desc, rxs);\n\tath12k_dp_rx_h_undecap(ar, msdu, rx_desc,\n\t\t\t       HAL_ENCRYPT_TYPE_TKIP_MIC, rxs, true);\n\tieee80211_rx(ar->hw, msdu);\n\treturn -EINVAL;\n}\n\nstatic void ath12k_dp_rx_h_undecap_frag(struct ath12k *ar, struct sk_buff *msdu,\n\t\t\t\t\tenum hal_encrypt_type enctype, u32 flags)\n{\n\tstruct ieee80211_hdr *hdr;\n\tsize_t hdr_len;\n\tsize_t crypto_len;\n\tu32 hal_rx_desc_sz = ar->ab->hw_params->hal_desc_sz;\n\n\tif (!flags)\n\t\treturn;\n\n\thdr = (struct ieee80211_hdr *)(msdu->data + hal_rx_desc_sz);\n\n\tif (flags & RX_FLAG_MIC_STRIPPED)\n\t\tskb_trim(msdu, msdu->len -\n\t\t\t ath12k_dp_rx_crypto_mic_len(ar, enctype));\n\n\tif (flags & RX_FLAG_ICV_STRIPPED)\n\t\tskb_trim(msdu, msdu->len -\n\t\t\t ath12k_dp_rx_crypto_icv_len(ar, enctype));\n\n\tif (flags & RX_FLAG_IV_STRIPPED) {\n\t\thdr_len = ieee80211_hdrlen(hdr->frame_control);\n\t\tcrypto_len = ath12k_dp_rx_crypto_param_len(ar, enctype);\n\n\t\tmemmove(msdu->data + hal_rx_desc_sz + crypto_len,\n\t\t\tmsdu->data + hal_rx_desc_sz, hdr_len);\n\t\tskb_pull(msdu, crypto_len);\n\t}\n}\n\nstatic int ath12k_dp_rx_h_defrag(struct ath12k *ar,\n\t\t\t\t struct ath12k_peer *peer,\n\t\t\t\t struct ath12k_dp_rx_tid *rx_tid,\n\t\t\t\t struct sk_buff **defrag_skb)\n{\n\tstruct ath12k_base *ab = ar->ab;\n\tstruct hal_rx_desc *rx_desc;\n\tstruct sk_buff *skb, *first_frag, *last_frag;\n\tstruct ieee80211_hdr *hdr;\n\tenum hal_encrypt_type enctype;\n\tbool is_decrypted = false;\n\tint msdu_len = 0;\n\tint extra_space;\n\tu32 flags, hal_rx_desc_sz = ar->ab->hw_params->hal_desc_sz;\n\n\tfirst_frag = skb_peek(&rx_tid->rx_frags);\n\tlast_frag = skb_peek_tail(&rx_tid->rx_frags);\n\n\tskb_queue_walk(&rx_tid->rx_frags, skb) {\n\t\tflags = 0;\n\t\trx_desc = (struct hal_rx_desc *)skb->data;\n\t\thdr = (struct ieee80211_hdr *)(skb->data + hal_rx_desc_sz);\n\n\t\tenctype = ath12k_dp_rx_h_enctype(ab, rx_desc);\n\t\tif (enctype != HAL_ENCRYPT_TYPE_OPEN)\n\t\t\tis_decrypted = ath12k_dp_rx_h_is_decrypted(ab,\n\t\t\t\t\t\t\t\t   rx_desc);\n\n\t\tif (is_decrypted) {\n\t\t\tif (skb != first_frag)\n\t\t\t\tflags |= RX_FLAG_IV_STRIPPED;\n\t\t\tif (skb != last_frag)\n\t\t\t\tflags |= RX_FLAG_ICV_STRIPPED |\n\t\t\t\t\t RX_FLAG_MIC_STRIPPED;\n\t\t}\n\n\t\t \n\t\tif (skb != last_frag)\n\t\t\tskb_trim(skb, skb->len - FCS_LEN);\n\t\tath12k_dp_rx_h_undecap_frag(ar, skb, enctype, flags);\n\n\t\tif (skb != first_frag)\n\t\t\tskb_pull(skb, hal_rx_desc_sz +\n\t\t\t\t      ieee80211_hdrlen(hdr->frame_control));\n\t\tmsdu_len += skb->len;\n\t}\n\n\textra_space = msdu_len - (DP_RX_BUFFER_SIZE + skb_tailroom(first_frag));\n\tif (extra_space > 0 &&\n\t    (pskb_expand_head(first_frag, 0, extra_space, GFP_ATOMIC) < 0))\n\t\treturn -ENOMEM;\n\n\t__skb_unlink(first_frag, &rx_tid->rx_frags);\n\twhile ((skb = __skb_dequeue(&rx_tid->rx_frags))) {\n\t\tskb_put_data(first_frag, skb->data, skb->len);\n\t\tdev_kfree_skb_any(skb);\n\t}\n\n\thdr = (struct ieee80211_hdr *)(first_frag->data + hal_rx_desc_sz);\n\thdr->frame_control &= ~__cpu_to_le16(IEEE80211_FCTL_MOREFRAGS);\n\tATH12K_SKB_RXCB(first_frag)->is_frag = 1;\n\n\tif (ath12k_dp_rx_h_verify_tkip_mic(ar, peer, first_frag))\n\t\tfirst_frag = NULL;\n\n\t*defrag_skb = first_frag;\n\treturn 0;\n}\n\nstatic int ath12k_dp_rx_h_defrag_reo_reinject(struct ath12k *ar,\n\t\t\t\t\t      struct ath12k_dp_rx_tid *rx_tid,\n\t\t\t\t\t      struct sk_buff *defrag_skb)\n{\n\tstruct ath12k_base *ab = ar->ab;\n\tstruct ath12k_dp *dp = &ab->dp;\n\tstruct hal_rx_desc *rx_desc = (struct hal_rx_desc *)defrag_skb->data;\n\tstruct hal_reo_entrance_ring *reo_ent_ring;\n\tstruct hal_reo_dest_ring *reo_dest_ring;\n\tstruct dp_link_desc_bank *link_desc_banks;\n\tstruct hal_rx_msdu_link *msdu_link;\n\tstruct hal_rx_msdu_details *msdu0;\n\tstruct hal_srng *srng;\n\tdma_addr_t link_paddr, buf_paddr;\n\tu32 desc_bank, msdu_info, msdu_ext_info, mpdu_info;\n\tu32 cookie, hal_rx_desc_sz, dest_ring_info0;\n\tint ret;\n\tstruct ath12k_rx_desc_info *desc_info;\n\tu8 dst_ind;\n\n\thal_rx_desc_sz = ab->hw_params->hal_desc_sz;\n\tlink_desc_banks = dp->link_desc_banks;\n\treo_dest_ring = rx_tid->dst_ring_desc;\n\n\tath12k_hal_rx_reo_ent_paddr_get(ab, &reo_dest_ring->buf_addr_info,\n\t\t\t\t\t&link_paddr, &cookie);\n\tdesc_bank = u32_get_bits(cookie, DP_LINK_DESC_BANK_MASK);\n\n\tmsdu_link = (struct hal_rx_msdu_link *)(link_desc_banks[desc_bank].vaddr +\n\t\t\t(link_paddr - link_desc_banks[desc_bank].paddr));\n\tmsdu0 = &msdu_link->msdu_link[0];\n\tmsdu_ext_info = le32_to_cpu(msdu0->rx_msdu_ext_info.info0);\n\tdst_ind = u32_get_bits(msdu_ext_info, RX_MSDU_EXT_DESC_INFO0_REO_DEST_IND);\n\n\tmemset(msdu0, 0, sizeof(*msdu0));\n\n\tmsdu_info = u32_encode_bits(1, RX_MSDU_DESC_INFO0_FIRST_MSDU_IN_MPDU) |\n\t\t    u32_encode_bits(1, RX_MSDU_DESC_INFO0_LAST_MSDU_IN_MPDU) |\n\t\t    u32_encode_bits(0, RX_MSDU_DESC_INFO0_MSDU_CONTINUATION) |\n\t\t    u32_encode_bits(defrag_skb->len - hal_rx_desc_sz,\n\t\t\t\t    RX_MSDU_DESC_INFO0_MSDU_LENGTH) |\n\t\t    u32_encode_bits(1, RX_MSDU_DESC_INFO0_VALID_SA) |\n\t\t    u32_encode_bits(1, RX_MSDU_DESC_INFO0_VALID_DA);\n\tmsdu0->rx_msdu_info.info0 = cpu_to_le32(msdu_info);\n\tmsdu0->rx_msdu_ext_info.info0 = cpu_to_le32(msdu_ext_info);\n\n\t \n\tath12k_dp_rxdesc_set_msdu_len(ab, rx_desc, defrag_skb->len - hal_rx_desc_sz);\n\n\tbuf_paddr = dma_map_single(ab->dev, defrag_skb->data,\n\t\t\t\t   defrag_skb->len + skb_tailroom(defrag_skb),\n\t\t\t\t   DMA_FROM_DEVICE);\n\tif (dma_mapping_error(ab->dev, buf_paddr))\n\t\treturn -ENOMEM;\n\n\tspin_lock_bh(&dp->rx_desc_lock);\n\tdesc_info = list_first_entry_or_null(&dp->rx_desc_free_list,\n\t\t\t\t\t     struct ath12k_rx_desc_info,\n\t\t\t\t\t     list);\n\tif (!desc_info) {\n\t\tspin_unlock_bh(&dp->rx_desc_lock);\n\t\tath12k_warn(ab, \"failed to find rx desc for reinject\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_unmap_dma;\n\t}\n\n\tdesc_info->skb = defrag_skb;\n\n\tlist_del(&desc_info->list);\n\tlist_add_tail(&desc_info->list, &dp->rx_desc_used_list);\n\tspin_unlock_bh(&dp->rx_desc_lock);\n\n\tATH12K_SKB_RXCB(defrag_skb)->paddr = buf_paddr;\n\n\tath12k_hal_rx_buf_addr_info_set(&msdu0->buf_addr_info, buf_paddr,\n\t\t\t\t\tdesc_info->cookie,\n\t\t\t\t\tHAL_RX_BUF_RBM_SW3_BM);\n\n\t \n\tsrng = &ab->hal.srng_list[dp->reo_reinject_ring.ring_id];\n\n\tspin_lock_bh(&srng->lock);\n\tath12k_hal_srng_access_begin(ab, srng);\n\n\treo_ent_ring = ath12k_hal_srng_src_get_next_entry(ab, srng);\n\tif (!reo_ent_ring) {\n\t\tath12k_hal_srng_access_end(ab, srng);\n\t\tspin_unlock_bh(&srng->lock);\n\t\tret = -ENOSPC;\n\t\tgoto err_free_desc;\n\t}\n\tmemset(reo_ent_ring, 0, sizeof(*reo_ent_ring));\n\n\tath12k_hal_rx_buf_addr_info_set(&reo_ent_ring->buf_addr_info, link_paddr,\n\t\t\t\t\tcookie,\n\t\t\t\t\tHAL_RX_BUF_RBM_WBM_CHIP0_IDLE_DESC_LIST);\n\n\tmpdu_info = u32_encode_bits(1, RX_MPDU_DESC_INFO0_MSDU_COUNT) |\n\t\t    u32_encode_bits(0, RX_MPDU_DESC_INFO0_FRAG_FLAG) |\n\t\t    u32_encode_bits(1, RX_MPDU_DESC_INFO0_RAW_MPDU) |\n\t\t    u32_encode_bits(1, RX_MPDU_DESC_INFO0_VALID_PN) |\n\t\t    u32_encode_bits(rx_tid->tid, RX_MPDU_DESC_INFO0_TID);\n\n\treo_ent_ring->rx_mpdu_info.info0 = cpu_to_le32(mpdu_info);\n\treo_ent_ring->rx_mpdu_info.peer_meta_data =\n\t\treo_dest_ring->rx_mpdu_info.peer_meta_data;\n\n\t \n\treo_ent_ring->queue_addr_lo = reo_dest_ring->rx_mpdu_info.peer_meta_data;\n\treo_ent_ring->info0 = le32_encode_bits(dst_ind,\n\t\t\t\t\t       HAL_REO_ENTR_RING_INFO0_DEST_IND);\n\n\treo_ent_ring->info1 = le32_encode_bits(rx_tid->cur_sn,\n\t\t\t\t\t       HAL_REO_ENTR_RING_INFO1_MPDU_SEQ_NUM);\n\tdest_ring_info0 = le32_get_bits(reo_dest_ring->info0,\n\t\t\t\t\tHAL_REO_DEST_RING_INFO0_SRC_LINK_ID);\n\treo_ent_ring->info2 =\n\t\tcpu_to_le32(u32_get_bits(dest_ring_info0,\n\t\t\t\t\t HAL_REO_ENTR_RING_INFO2_SRC_LINK_ID));\n\n\tath12k_hal_srng_access_end(ab, srng);\n\tspin_unlock_bh(&srng->lock);\n\n\treturn 0;\n\nerr_free_desc:\n\tspin_lock_bh(&dp->rx_desc_lock);\n\tlist_del(&desc_info->list);\n\tlist_add_tail(&desc_info->list, &dp->rx_desc_free_list);\n\tdesc_info->skb = NULL;\n\tspin_unlock_bh(&dp->rx_desc_lock);\nerr_unmap_dma:\n\tdma_unmap_single(ab->dev, buf_paddr, defrag_skb->len + skb_tailroom(defrag_skb),\n\t\t\t DMA_FROM_DEVICE);\n\treturn ret;\n}\n\nstatic int ath12k_dp_rx_h_cmp_frags(struct ath12k_base *ab,\n\t\t\t\t    struct sk_buff *a, struct sk_buff *b)\n{\n\tint frag1, frag2;\n\n\tfrag1 = ath12k_dp_rx_h_frag_no(ab, a);\n\tfrag2 = ath12k_dp_rx_h_frag_no(ab, b);\n\n\treturn frag1 - frag2;\n}\n\nstatic void ath12k_dp_rx_h_sort_frags(struct ath12k_base *ab,\n\t\t\t\t      struct sk_buff_head *frag_list,\n\t\t\t\t      struct sk_buff *cur_frag)\n{\n\tstruct sk_buff *skb;\n\tint cmp;\n\n\tskb_queue_walk(frag_list, skb) {\n\t\tcmp = ath12k_dp_rx_h_cmp_frags(ab, skb, cur_frag);\n\t\tif (cmp < 0)\n\t\t\tcontinue;\n\t\t__skb_queue_before(frag_list, skb, cur_frag);\n\t\treturn;\n\t}\n\t__skb_queue_tail(frag_list, cur_frag);\n}\n\nstatic u64 ath12k_dp_rx_h_get_pn(struct ath12k *ar, struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr;\n\tu64 pn = 0;\n\tu8 *ehdr;\n\tu32 hal_rx_desc_sz = ar->ab->hw_params->hal_desc_sz;\n\n\thdr = (struct ieee80211_hdr *)(skb->data + hal_rx_desc_sz);\n\tehdr = skb->data + hal_rx_desc_sz + ieee80211_hdrlen(hdr->frame_control);\n\n\tpn = ehdr[0];\n\tpn |= (u64)ehdr[1] << 8;\n\tpn |= (u64)ehdr[4] << 16;\n\tpn |= (u64)ehdr[5] << 24;\n\tpn |= (u64)ehdr[6] << 32;\n\tpn |= (u64)ehdr[7] << 40;\n\n\treturn pn;\n}\n\nstatic bool\nath12k_dp_rx_h_defrag_validate_incr_pn(struct ath12k *ar, struct ath12k_dp_rx_tid *rx_tid)\n{\n\tstruct ath12k_base *ab = ar->ab;\n\tenum hal_encrypt_type encrypt_type;\n\tstruct sk_buff *first_frag, *skb;\n\tstruct hal_rx_desc *desc;\n\tu64 last_pn;\n\tu64 cur_pn;\n\n\tfirst_frag = skb_peek(&rx_tid->rx_frags);\n\tdesc = (struct hal_rx_desc *)first_frag->data;\n\n\tencrypt_type = ath12k_dp_rx_h_enctype(ab, desc);\n\tif (encrypt_type != HAL_ENCRYPT_TYPE_CCMP_128 &&\n\t    encrypt_type != HAL_ENCRYPT_TYPE_CCMP_256 &&\n\t    encrypt_type != HAL_ENCRYPT_TYPE_GCMP_128 &&\n\t    encrypt_type != HAL_ENCRYPT_TYPE_AES_GCMP_256)\n\t\treturn true;\n\n\tlast_pn = ath12k_dp_rx_h_get_pn(ar, first_frag);\n\tskb_queue_walk(&rx_tid->rx_frags, skb) {\n\t\tif (skb == first_frag)\n\t\t\tcontinue;\n\n\t\tcur_pn = ath12k_dp_rx_h_get_pn(ar, skb);\n\t\tif (cur_pn != last_pn + 1)\n\t\t\treturn false;\n\t\tlast_pn = cur_pn;\n\t}\n\treturn true;\n}\n\nstatic int ath12k_dp_rx_frag_h_mpdu(struct ath12k *ar,\n\t\t\t\t    struct sk_buff *msdu,\n\t\t\t\t    struct hal_reo_dest_ring *ring_desc)\n{\n\tstruct ath12k_base *ab = ar->ab;\n\tstruct hal_rx_desc *rx_desc;\n\tstruct ath12k_peer *peer;\n\tstruct ath12k_dp_rx_tid *rx_tid;\n\tstruct sk_buff *defrag_skb = NULL;\n\tu32 peer_id;\n\tu16 seqno, frag_no;\n\tu8 tid;\n\tint ret = 0;\n\tbool more_frags;\n\n\trx_desc = (struct hal_rx_desc *)msdu->data;\n\tpeer_id = ath12k_dp_rx_h_peer_id(ab, rx_desc);\n\ttid = ath12k_dp_rx_h_tid(ab, rx_desc);\n\tseqno = ath12k_dp_rx_h_seq_no(ab, rx_desc);\n\tfrag_no = ath12k_dp_rx_h_frag_no(ab, msdu);\n\tmore_frags = ath12k_dp_rx_h_more_frags(ab, msdu);\n\n\tif (!ath12k_dp_rx_h_seq_ctrl_valid(ab, rx_desc) ||\n\t    !ath12k_dp_rx_h_fc_valid(ab, rx_desc) ||\n\t    tid > IEEE80211_NUM_TIDS)\n\t\treturn -EINVAL;\n\n\t \n\tif (WARN_ON_ONCE(!frag_no && !more_frags))\n\t\treturn -EINVAL;\n\n\tspin_lock_bh(&ab->base_lock);\n\tpeer = ath12k_peer_find_by_id(ab, peer_id);\n\tif (!peer) {\n\t\tath12k_warn(ab, \"failed to find the peer to de-fragment received fragment peer_id %d\\n\",\n\t\t\t    peer_id);\n\t\tret = -ENOENT;\n\t\tgoto out_unlock;\n\t}\n\n\tif (!peer->dp_setup_done) {\n\t\tath12k_warn(ab, \"The peer %pM [%d] has uninitialized datapath\\n\",\n\t\t\t    peer->addr, peer_id);\n\t\tret = -ENOENT;\n\t\tgoto out_unlock;\n\t}\n\n\trx_tid = &peer->rx_tid[tid];\n\n\tif ((!skb_queue_empty(&rx_tid->rx_frags) && seqno != rx_tid->cur_sn) ||\n\t    skb_queue_empty(&rx_tid->rx_frags)) {\n\t\t \n\t\tath12k_dp_rx_frags_cleanup(rx_tid, true);\n\t\trx_tid->cur_sn = seqno;\n\t}\n\n\tif (rx_tid->rx_frag_bitmap & BIT(frag_no)) {\n\t\t \n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif ((!rx_tid->rx_frag_bitmap || frag_no > __fls(rx_tid->rx_frag_bitmap)))\n\t\t__skb_queue_tail(&rx_tid->rx_frags, msdu);\n\telse\n\t\tath12k_dp_rx_h_sort_frags(ab, &rx_tid->rx_frags, msdu);\n\n\trx_tid->rx_frag_bitmap |= BIT(frag_no);\n\tif (!more_frags)\n\t\trx_tid->last_frag_no = frag_no;\n\n\tif (frag_no == 0) {\n\t\trx_tid->dst_ring_desc = kmemdup(ring_desc,\n\t\t\t\t\t\tsizeof(*rx_tid->dst_ring_desc),\n\t\t\t\t\t\tGFP_ATOMIC);\n\t\tif (!rx_tid->dst_ring_desc) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else {\n\t\tath12k_dp_rx_link_desc_return(ab, ring_desc,\n\t\t\t\t\t      HAL_WBM_REL_BM_ACT_PUT_IN_IDLE);\n\t}\n\n\tif (!rx_tid->last_frag_no ||\n\t    rx_tid->rx_frag_bitmap != GENMASK(rx_tid->last_frag_no, 0)) {\n\t\tmod_timer(&rx_tid->frag_timer, jiffies +\n\t\t\t\t\t       ATH12K_DP_RX_FRAGMENT_TIMEOUT_MS);\n\t\tgoto out_unlock;\n\t}\n\n\tspin_unlock_bh(&ab->base_lock);\n\tdel_timer_sync(&rx_tid->frag_timer);\n\tspin_lock_bh(&ab->base_lock);\n\n\tpeer = ath12k_peer_find_by_id(ab, peer_id);\n\tif (!peer)\n\t\tgoto err_frags_cleanup;\n\n\tif (!ath12k_dp_rx_h_defrag_validate_incr_pn(ar, rx_tid))\n\t\tgoto err_frags_cleanup;\n\n\tif (ath12k_dp_rx_h_defrag(ar, peer, rx_tid, &defrag_skb))\n\t\tgoto err_frags_cleanup;\n\n\tif (!defrag_skb)\n\t\tgoto err_frags_cleanup;\n\n\tif (ath12k_dp_rx_h_defrag_reo_reinject(ar, rx_tid, defrag_skb))\n\t\tgoto err_frags_cleanup;\n\n\tath12k_dp_rx_frags_cleanup(rx_tid, false);\n\tgoto out_unlock;\n\nerr_frags_cleanup:\n\tdev_kfree_skb_any(defrag_skb);\n\tath12k_dp_rx_frags_cleanup(rx_tid, true);\nout_unlock:\n\tspin_unlock_bh(&ab->base_lock);\n\treturn ret;\n}\n\nstatic int\nath12k_dp_process_rx_err_buf(struct ath12k *ar, struct hal_reo_dest_ring *desc,\n\t\t\t     bool drop, u32 cookie)\n{\n\tstruct ath12k_base *ab = ar->ab;\n\tstruct sk_buff *msdu;\n\tstruct ath12k_skb_rxcb *rxcb;\n\tstruct hal_rx_desc *rx_desc;\n\tu16 msdu_len;\n\tu32 hal_rx_desc_sz = ab->hw_params->hal_desc_sz;\n\tstruct ath12k_rx_desc_info *desc_info;\n\tu64 desc_va;\n\n\tdesc_va = ((u64)le32_to_cpu(desc->buf_va_hi) << 32 |\n\t\t   le32_to_cpu(desc->buf_va_lo));\n\tdesc_info = (struct ath12k_rx_desc_info *)((unsigned long)desc_va);\n\n\t \n\tif (!desc_info) {\n\t\tdesc_info = ath12k_dp_get_rx_desc(ab, cookie);\n\t\tif (!desc_info) {\n\t\t\tath12k_warn(ab, \"Invalid cookie in manual desc retrieval\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (desc_info->magic != ATH12K_DP_RX_DESC_MAGIC)\n\t\tath12k_warn(ab, \" RX Exception, Check HW CC implementation\");\n\n\tmsdu = desc_info->skb;\n\tdesc_info->skb = NULL;\n\tspin_lock_bh(&ab->dp.rx_desc_lock);\n\tlist_move_tail(&desc_info->list, &ab->dp.rx_desc_free_list);\n\tspin_unlock_bh(&ab->dp.rx_desc_lock);\n\n\trxcb = ATH12K_SKB_RXCB(msdu);\n\tdma_unmap_single(ar->ab->dev, rxcb->paddr,\n\t\t\t msdu->len + skb_tailroom(msdu),\n\t\t\t DMA_FROM_DEVICE);\n\n\tif (drop) {\n\t\tdev_kfree_skb_any(msdu);\n\t\treturn 0;\n\t}\n\n\trcu_read_lock();\n\tif (!rcu_dereference(ar->ab->pdevs_active[ar->pdev_idx])) {\n\t\tdev_kfree_skb_any(msdu);\n\t\tgoto exit;\n\t}\n\n\tif (test_bit(ATH12K_CAC_RUNNING, &ar->dev_flags)) {\n\t\tdev_kfree_skb_any(msdu);\n\t\tgoto exit;\n\t}\n\n\trx_desc = (struct hal_rx_desc *)msdu->data;\n\tmsdu_len = ath12k_dp_rx_h_msdu_len(ar->ab, rx_desc);\n\tif ((msdu_len + hal_rx_desc_sz) > DP_RX_BUFFER_SIZE) {\n\t\tath12k_warn(ar->ab, \"invalid msdu leng %u\", msdu_len);\n\t\tath12k_dbg_dump(ar->ab, ATH12K_DBG_DATA, NULL, \"\", rx_desc,\n\t\t\t\tsizeof(*rx_desc));\n\t\tdev_kfree_skb_any(msdu);\n\t\tgoto exit;\n\t}\n\n\tskb_put(msdu, hal_rx_desc_sz + msdu_len);\n\n\tif (ath12k_dp_rx_frag_h_mpdu(ar, msdu, desc)) {\n\t\tdev_kfree_skb_any(msdu);\n\t\tath12k_dp_rx_link_desc_return(ar->ab, desc,\n\t\t\t\t\t      HAL_WBM_REL_BM_ACT_PUT_IN_IDLE);\n\t}\nexit:\n\trcu_read_unlock();\n\treturn 0;\n}\n\nint ath12k_dp_rx_process_err(struct ath12k_base *ab, struct napi_struct *napi,\n\t\t\t     int budget)\n{\n\tu32 msdu_cookies[HAL_NUM_RX_MSDUS_PER_LINK_DESC];\n\tstruct dp_link_desc_bank *link_desc_banks;\n\tenum hal_rx_buf_return_buf_manager rbm;\n\tstruct hal_rx_msdu_link *link_desc_va;\n\tint tot_n_bufs_reaped, quota, ret, i;\n\tstruct hal_reo_dest_ring *reo_desc;\n\tstruct dp_rxdma_ring *rx_ring;\n\tstruct dp_srng *reo_except;\n\tu32 desc_bank, num_msdus;\n\tstruct hal_srng *srng;\n\tstruct ath12k_dp *dp;\n\tint mac_id;\n\tstruct ath12k *ar;\n\tdma_addr_t paddr;\n\tbool is_frag;\n\tbool drop = false;\n\tint pdev_id;\n\n\ttot_n_bufs_reaped = 0;\n\tquota = budget;\n\n\tdp = &ab->dp;\n\treo_except = &dp->reo_except_ring;\n\tlink_desc_banks = dp->link_desc_banks;\n\n\tsrng = &ab->hal.srng_list[reo_except->ring_id];\n\n\tspin_lock_bh(&srng->lock);\n\n\tath12k_hal_srng_access_begin(ab, srng);\n\n\twhile (budget &&\n\t       (reo_desc = ath12k_hal_srng_dst_get_next_entry(ab, srng))) {\n\t\tab->soc_stats.err_ring_pkts++;\n\t\tret = ath12k_hal_desc_reo_parse_err(ab, reo_desc, &paddr,\n\t\t\t\t\t\t    &desc_bank);\n\t\tif (ret) {\n\t\t\tath12k_warn(ab, \"failed to parse error reo desc %d\\n\",\n\t\t\t\t    ret);\n\t\t\tcontinue;\n\t\t}\n\t\tlink_desc_va = link_desc_banks[desc_bank].vaddr +\n\t\t\t       (paddr - link_desc_banks[desc_bank].paddr);\n\t\tath12k_hal_rx_msdu_link_info_get(link_desc_va, &num_msdus, msdu_cookies,\n\t\t\t\t\t\t &rbm);\n\t\tif (rbm != HAL_RX_BUF_RBM_WBM_CHIP0_IDLE_DESC_LIST &&\n\t\t    rbm != HAL_RX_BUF_RBM_SW3_BM &&\n\t\t    rbm != ab->hw_params->hal_params->rx_buf_rbm) {\n\t\t\tab->soc_stats.invalid_rbm++;\n\t\t\tath12k_warn(ab, \"invalid return buffer manager %d\\n\", rbm);\n\t\t\tath12k_dp_rx_link_desc_return(ab, reo_desc,\n\t\t\t\t\t\t      HAL_WBM_REL_BM_ACT_REL_MSDU);\n\t\t\tcontinue;\n\t\t}\n\n\t\tis_frag = !!(le32_to_cpu(reo_desc->rx_mpdu_info.info0) &\n\t\t\t     RX_MPDU_DESC_INFO0_FRAG_FLAG);\n\n\t\t \n\t\tif (!is_frag || num_msdus > 1) {\n\t\t\tdrop = true;\n\t\t\t \n\t\t\tath12k_dp_rx_link_desc_return(ab, reo_desc,\n\t\t\t\t\t\t      HAL_WBM_REL_BM_ACT_PUT_IN_IDLE);\n\t\t}\n\n\t\tfor (i = 0; i < num_msdus; i++) {\n\t\t\tmac_id = le32_get_bits(reo_desc->info0,\n\t\t\t\t\t       HAL_REO_DEST_RING_INFO0_SRC_LINK_ID);\n\n\t\t\tpdev_id = ath12k_hw_mac_id_to_pdev_id(ab->hw_params, mac_id);\n\t\t\tar = ab->pdevs[pdev_id].ar;\n\n\t\t\tif (!ath12k_dp_process_rx_err_buf(ar, reo_desc, drop,\n\t\t\t\t\t\t\t  msdu_cookies[i]))\n\t\t\t\ttot_n_bufs_reaped++;\n\t\t}\n\n\t\tif (tot_n_bufs_reaped >= quota) {\n\t\t\ttot_n_bufs_reaped = quota;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tbudget = quota - tot_n_bufs_reaped;\n\t}\n\nexit:\n\tath12k_hal_srng_access_end(ab, srng);\n\n\tspin_unlock_bh(&srng->lock);\n\n\trx_ring = &dp->rx_refill_buf_ring;\n\n\tath12k_dp_rx_bufs_replenish(ab, 0, rx_ring, tot_n_bufs_reaped,\n\t\t\t\t    ab->hw_params->hal_params->rx_buf_rbm, true);\n\n\treturn tot_n_bufs_reaped;\n}\n\nstatic void ath12k_dp_rx_null_q_desc_sg_drop(struct ath12k *ar,\n\t\t\t\t\t     int msdu_len,\n\t\t\t\t\t     struct sk_buff_head *msdu_list)\n{\n\tstruct sk_buff *skb, *tmp;\n\tstruct ath12k_skb_rxcb *rxcb;\n\tint n_buffs;\n\n\tn_buffs = DIV_ROUND_UP(msdu_len,\n\t\t\t       (DP_RX_BUFFER_SIZE - ar->ab->hw_params->hal_desc_sz));\n\n\tskb_queue_walk_safe(msdu_list, skb, tmp) {\n\t\trxcb = ATH12K_SKB_RXCB(skb);\n\t\tif (rxcb->err_rel_src == HAL_WBM_REL_SRC_MODULE_REO &&\n\t\t    rxcb->err_code == HAL_REO_DEST_RING_ERROR_CODE_DESC_ADDR_ZERO) {\n\t\t\tif (!n_buffs)\n\t\t\t\tbreak;\n\t\t\t__skb_unlink(skb, msdu_list);\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\tn_buffs--;\n\t\t}\n\t}\n}\n\nstatic int ath12k_dp_rx_h_null_q_desc(struct ath12k *ar, struct sk_buff *msdu,\n\t\t\t\t      struct ieee80211_rx_status *status,\n\t\t\t\t      struct sk_buff_head *msdu_list)\n{\n\tstruct ath12k_base *ab = ar->ab;\n\tu16 msdu_len, peer_id;\n\tstruct hal_rx_desc *desc = (struct hal_rx_desc *)msdu->data;\n\tu8 l3pad_bytes;\n\tstruct ath12k_skb_rxcb *rxcb = ATH12K_SKB_RXCB(msdu);\n\tu32 hal_rx_desc_sz = ar->ab->hw_params->hal_desc_sz;\n\n\tmsdu_len = ath12k_dp_rx_h_msdu_len(ab, desc);\n\tpeer_id = ath12k_dp_rx_h_peer_id(ab, desc);\n\n\tspin_lock(&ab->base_lock);\n\tif (!ath12k_peer_find_by_id(ab, peer_id)) {\n\t\tspin_unlock(&ab->base_lock);\n\t\tath12k_dbg(ab, ATH12K_DBG_DATA, \"invalid peer id received in wbm err pkt%d\\n\",\n\t\t\t   peer_id);\n\t\treturn -EINVAL;\n\t}\n\tspin_unlock(&ab->base_lock);\n\n\tif (!rxcb->is_frag && ((msdu_len + hal_rx_desc_sz) > DP_RX_BUFFER_SIZE)) {\n\t\t \n\t\tmsdu_len = msdu_len - (DP_RX_BUFFER_SIZE - hal_rx_desc_sz);\n\t\tath12k_dp_rx_null_q_desc_sg_drop(ar, msdu_len, msdu_list);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (rxcb->is_continuation)\n\t\treturn -EINVAL;\n\n\tif (!ath12k_dp_rx_h_msdu_done(ab, desc)) {\n\t\tath12k_warn(ar->ab,\n\t\t\t    \"msdu_done bit not set in null_q_des processing\\n\");\n\t\t__skb_queue_purge(msdu_list);\n\t\treturn -EIO;\n\t}\n\n\t \n\n\tif (rxcb->is_frag) {\n\t\tskb_pull(msdu, hal_rx_desc_sz);\n\t} else {\n\t\tl3pad_bytes = ath12k_dp_rx_h_l3pad(ab, desc);\n\n\t\tif ((hal_rx_desc_sz + l3pad_bytes + msdu_len) > DP_RX_BUFFER_SIZE)\n\t\t\treturn -EINVAL;\n\n\t\tskb_put(msdu, hal_rx_desc_sz + l3pad_bytes + msdu_len);\n\t\tskb_pull(msdu, hal_rx_desc_sz + l3pad_bytes);\n\t}\n\tath12k_dp_rx_h_ppdu(ar, desc, status);\n\n\tath12k_dp_rx_h_mpdu(ar, msdu, desc, status);\n\n\trxcb->tid = ath12k_dp_rx_h_tid(ab, desc);\n\n\t \n\n\treturn 0;\n}\n\nstatic bool ath12k_dp_rx_h_reo_err(struct ath12k *ar, struct sk_buff *msdu,\n\t\t\t\t   struct ieee80211_rx_status *status,\n\t\t\t\t   struct sk_buff_head *msdu_list)\n{\n\tstruct ath12k_skb_rxcb *rxcb = ATH12K_SKB_RXCB(msdu);\n\tbool drop = false;\n\n\tar->ab->soc_stats.reo_error[rxcb->err_code]++;\n\n\tswitch (rxcb->err_code) {\n\tcase HAL_REO_DEST_RING_ERROR_CODE_DESC_ADDR_ZERO:\n\t\tif (ath12k_dp_rx_h_null_q_desc(ar, msdu, status, msdu_list))\n\t\t\tdrop = true;\n\t\tbreak;\n\tcase HAL_REO_DEST_RING_ERROR_CODE_PN_CHECK_FAILED:\n\t\t \n\t\tfallthrough;\n\tdefault:\n\t\t \n\t\tdrop = true;\n\t\tbreak;\n\t}\n\n\treturn drop;\n}\n\nstatic void ath12k_dp_rx_h_tkip_mic_err(struct ath12k *ar, struct sk_buff *msdu,\n\t\t\t\t\tstruct ieee80211_rx_status *status)\n{\n\tstruct ath12k_base *ab = ar->ab;\n\tu16 msdu_len;\n\tstruct hal_rx_desc *desc = (struct hal_rx_desc *)msdu->data;\n\tu8 l3pad_bytes;\n\tstruct ath12k_skb_rxcb *rxcb = ATH12K_SKB_RXCB(msdu);\n\tu32 hal_rx_desc_sz = ar->ab->hw_params->hal_desc_sz;\n\n\trxcb->is_first_msdu = ath12k_dp_rx_h_first_msdu(ab, desc);\n\trxcb->is_last_msdu = ath12k_dp_rx_h_last_msdu(ab, desc);\n\n\tl3pad_bytes = ath12k_dp_rx_h_l3pad(ab, desc);\n\tmsdu_len = ath12k_dp_rx_h_msdu_len(ab, desc);\n\tskb_put(msdu, hal_rx_desc_sz + l3pad_bytes + msdu_len);\n\tskb_pull(msdu, hal_rx_desc_sz + l3pad_bytes);\n\n\tath12k_dp_rx_h_ppdu(ar, desc, status);\n\n\tstatus->flag |= (RX_FLAG_MMIC_STRIPPED | RX_FLAG_MMIC_ERROR |\n\t\t\t RX_FLAG_DECRYPTED);\n\n\tath12k_dp_rx_h_undecap(ar, msdu, desc,\n\t\t\t       HAL_ENCRYPT_TYPE_TKIP_MIC, status, false);\n}\n\nstatic bool ath12k_dp_rx_h_rxdma_err(struct ath12k *ar,  struct sk_buff *msdu,\n\t\t\t\t     struct ieee80211_rx_status *status)\n{\n\tstruct ath12k_base *ab = ar->ab;\n\tstruct ath12k_skb_rxcb *rxcb = ATH12K_SKB_RXCB(msdu);\n\tstruct hal_rx_desc *rx_desc = (struct hal_rx_desc *)msdu->data;\n\tbool drop = false;\n\tu32 err_bitmap;\n\n\tar->ab->soc_stats.rxdma_error[rxcb->err_code]++;\n\n\tswitch (rxcb->err_code) {\n\tcase HAL_REO_ENTR_RING_RXDMA_ECODE_DECRYPT_ERR:\n\tcase HAL_REO_ENTR_RING_RXDMA_ECODE_TKIP_MIC_ERR:\n\t\terr_bitmap = ath12k_dp_rx_h_mpdu_err(ab, rx_desc);\n\t\tif (err_bitmap & HAL_RX_MPDU_ERR_TKIP_MIC) {\n\t\t\tath12k_dp_rx_h_tkip_mic_err(ar, msdu, status);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\t \n\t\tdrop = true;\n\t\tbreak;\n\t}\n\n\treturn drop;\n}\n\nstatic void ath12k_dp_rx_wbm_err(struct ath12k *ar,\n\t\t\t\t struct napi_struct *napi,\n\t\t\t\t struct sk_buff *msdu,\n\t\t\t\t struct sk_buff_head *msdu_list)\n{\n\tstruct ath12k_skb_rxcb *rxcb = ATH12K_SKB_RXCB(msdu);\n\tstruct ieee80211_rx_status rxs = {0};\n\tbool drop = true;\n\n\tswitch (rxcb->err_rel_src) {\n\tcase HAL_WBM_REL_SRC_MODULE_REO:\n\t\tdrop = ath12k_dp_rx_h_reo_err(ar, msdu, &rxs, msdu_list);\n\t\tbreak;\n\tcase HAL_WBM_REL_SRC_MODULE_RXDMA:\n\t\tdrop = ath12k_dp_rx_h_rxdma_err(ar, msdu, &rxs);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\tif (drop) {\n\t\tdev_kfree_skb_any(msdu);\n\t\treturn;\n\t}\n\n\tath12k_dp_rx_deliver_msdu(ar, napi, msdu, &rxs);\n}\n\nint ath12k_dp_rx_process_wbm_err(struct ath12k_base *ab,\n\t\t\t\t struct napi_struct *napi, int budget)\n{\n\tstruct ath12k *ar;\n\tstruct ath12k_dp *dp = &ab->dp;\n\tstruct dp_rxdma_ring *rx_ring;\n\tstruct hal_rx_wbm_rel_info err_info;\n\tstruct hal_srng *srng;\n\tstruct sk_buff *msdu;\n\tstruct sk_buff_head msdu_list[MAX_RADIOS];\n\tstruct ath12k_skb_rxcb *rxcb;\n\tvoid *rx_desc;\n\tint mac_id;\n\tint num_buffs_reaped = 0;\n\tstruct ath12k_rx_desc_info *desc_info;\n\tint ret, i;\n\n\tfor (i = 0; i < ab->num_radios; i++)\n\t\t__skb_queue_head_init(&msdu_list[i]);\n\n\tsrng = &ab->hal.srng_list[dp->rx_rel_ring.ring_id];\n\trx_ring = &dp->rx_refill_buf_ring;\n\n\tspin_lock_bh(&srng->lock);\n\n\tath12k_hal_srng_access_begin(ab, srng);\n\n\twhile (budget) {\n\t\trx_desc = ath12k_hal_srng_dst_get_next_entry(ab, srng);\n\t\tif (!rx_desc)\n\t\t\tbreak;\n\n\t\tret = ath12k_hal_wbm_desc_parse_err(ab, rx_desc, &err_info);\n\t\tif (ret) {\n\t\t\tath12k_warn(ab,\n\t\t\t\t    \"failed to parse rx error in wbm_rel ring desc %d\\n\",\n\t\t\t\t    ret);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdesc_info = (struct ath12k_rx_desc_info *)err_info.rx_desc;\n\n\t\t \n\t\tif (!desc_info) {\n\t\t\tdesc_info = ath12k_dp_get_rx_desc(ab, err_info.cookie);\n\t\t\tif (!desc_info) {\n\t\t\t\tath12k_warn(ab, \"Invalid cookie in manual desc retrieval\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tmac_id = 0;\n\n\t\tif (desc_info->magic != ATH12K_DP_RX_DESC_MAGIC)\n\t\t\tath12k_warn(ab, \"WBM RX err, Check HW CC implementation\");\n\n\t\tmsdu = desc_info->skb;\n\t\tdesc_info->skb = NULL;\n\n\t\tspin_lock_bh(&dp->rx_desc_lock);\n\t\tlist_move_tail(&desc_info->list, &dp->rx_desc_free_list);\n\t\tspin_unlock_bh(&dp->rx_desc_lock);\n\n\t\trxcb = ATH12K_SKB_RXCB(msdu);\n\t\tdma_unmap_single(ab->dev, rxcb->paddr,\n\t\t\t\t msdu->len + skb_tailroom(msdu),\n\t\t\t\t DMA_FROM_DEVICE);\n\n\t\tnum_buffs_reaped++;\n\n\t\tif (!err_info.continuation)\n\t\t\tbudget--;\n\n\t\tif (err_info.push_reason !=\n\t\t    HAL_REO_DEST_RING_PUSH_REASON_ERR_DETECTED) {\n\t\t\tdev_kfree_skb_any(msdu);\n\t\t\tcontinue;\n\t\t}\n\n\t\trxcb->err_rel_src = err_info.err_rel_src;\n\t\trxcb->err_code = err_info.err_code;\n\t\trxcb->rx_desc = (struct hal_rx_desc *)msdu->data;\n\t\t__skb_queue_tail(&msdu_list[mac_id], msdu);\n\n\t\trxcb->is_first_msdu = err_info.first_msdu;\n\t\trxcb->is_last_msdu = err_info.last_msdu;\n\t\trxcb->is_continuation = err_info.continuation;\n\t}\n\n\tath12k_hal_srng_access_end(ab, srng);\n\n\tspin_unlock_bh(&srng->lock);\n\n\tif (!num_buffs_reaped)\n\t\tgoto done;\n\n\tath12k_dp_rx_bufs_replenish(ab, 0, rx_ring, num_buffs_reaped,\n\t\t\t\t    ab->hw_params->hal_params->rx_buf_rbm, true);\n\n\trcu_read_lock();\n\tfor (i = 0; i <  ab->num_radios; i++) {\n\t\tif (!rcu_dereference(ab->pdevs_active[i])) {\n\t\t\t__skb_queue_purge(&msdu_list[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tar = ab->pdevs[i].ar;\n\n\t\tif (test_bit(ATH12K_CAC_RUNNING, &ar->dev_flags)) {\n\t\t\t__skb_queue_purge(&msdu_list[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\twhile ((msdu = __skb_dequeue(&msdu_list[i])) != NULL)\n\t\t\tath12k_dp_rx_wbm_err(ar, napi, msdu, &msdu_list[i]);\n\t}\n\trcu_read_unlock();\ndone:\n\treturn num_buffs_reaped;\n}\n\nvoid ath12k_dp_rx_process_reo_status(struct ath12k_base *ab)\n{\n\tstruct ath12k_dp *dp = &ab->dp;\n\tstruct hal_tlv_64_hdr *hdr;\n\tstruct hal_srng *srng;\n\tstruct ath12k_dp_rx_reo_cmd *cmd, *tmp;\n\tbool found = false;\n\tu16 tag;\n\tstruct hal_reo_status reo_status;\n\n\tsrng = &ab->hal.srng_list[dp->reo_status_ring.ring_id];\n\n\tmemset(&reo_status, 0, sizeof(reo_status));\n\n\tspin_lock_bh(&srng->lock);\n\n\tath12k_hal_srng_access_begin(ab, srng);\n\n\twhile ((hdr = ath12k_hal_srng_dst_get_next_entry(ab, srng))) {\n\t\ttag = u64_get_bits(hdr->tl, HAL_SRNG_TLV_HDR_TAG);\n\n\t\tswitch (tag) {\n\t\tcase HAL_REO_GET_QUEUE_STATS_STATUS:\n\t\t\tath12k_hal_reo_status_queue_stats(ab, hdr,\n\t\t\t\t\t\t\t  &reo_status);\n\t\t\tbreak;\n\t\tcase HAL_REO_FLUSH_QUEUE_STATUS:\n\t\t\tath12k_hal_reo_flush_queue_status(ab, hdr,\n\t\t\t\t\t\t\t  &reo_status);\n\t\t\tbreak;\n\t\tcase HAL_REO_FLUSH_CACHE_STATUS:\n\t\t\tath12k_hal_reo_flush_cache_status(ab, hdr,\n\t\t\t\t\t\t\t  &reo_status);\n\t\t\tbreak;\n\t\tcase HAL_REO_UNBLOCK_CACHE_STATUS:\n\t\t\tath12k_hal_reo_unblk_cache_status(ab, hdr,\n\t\t\t\t\t\t\t  &reo_status);\n\t\t\tbreak;\n\t\tcase HAL_REO_FLUSH_TIMEOUT_LIST_STATUS:\n\t\t\tath12k_hal_reo_flush_timeout_list_status(ab, hdr,\n\t\t\t\t\t\t\t\t &reo_status);\n\t\t\tbreak;\n\t\tcase HAL_REO_DESCRIPTOR_THRESHOLD_REACHED_STATUS:\n\t\t\tath12k_hal_reo_desc_thresh_reached_status(ab, hdr,\n\t\t\t\t\t\t\t\t  &reo_status);\n\t\t\tbreak;\n\t\tcase HAL_REO_UPDATE_RX_REO_QUEUE_STATUS:\n\t\t\tath12k_hal_reo_update_rx_reo_queue_status(ab, hdr,\n\t\t\t\t\t\t\t\t  &reo_status);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tath12k_warn(ab, \"Unknown reo status type %d\\n\", tag);\n\t\t\tcontinue;\n\t\t}\n\n\t\tspin_lock_bh(&dp->reo_cmd_lock);\n\t\tlist_for_each_entry_safe(cmd, tmp, &dp->reo_cmd_list, list) {\n\t\t\tif (reo_status.uniform_hdr.cmd_num == cmd->cmd_num) {\n\t\t\t\tfound = true;\n\t\t\t\tlist_del(&cmd->list);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_bh(&dp->reo_cmd_lock);\n\n\t\tif (found) {\n\t\t\tcmd->handler(dp, (void *)&cmd->data,\n\t\t\t\t     reo_status.uniform_hdr.cmd_status);\n\t\t\tkfree(cmd);\n\t\t}\n\n\t\tfound = false;\n\t}\n\n\tath12k_hal_srng_access_end(ab, srng);\n\n\tspin_unlock_bh(&srng->lock);\n}\n\nvoid ath12k_dp_rx_free(struct ath12k_base *ab)\n{\n\tstruct ath12k_dp *dp = &ab->dp;\n\tint i;\n\n\tath12k_dp_srng_cleanup(ab, &dp->rx_refill_buf_ring.refill_buf_ring);\n\n\tfor (i = 0; i < ab->hw_params->num_rxmda_per_pdev; i++) {\n\t\tif (ab->hw_params->rx_mac_buf_ring)\n\t\t\tath12k_dp_srng_cleanup(ab, &dp->rx_mac_buf_ring[i]);\n\t}\n\n\tfor (i = 0; i < ab->hw_params->num_rxdma_dst_ring; i++)\n\t\tath12k_dp_srng_cleanup(ab, &dp->rxdma_err_dst_ring[i]);\n\n\tath12k_dp_srng_cleanup(ab, &dp->rxdma_mon_buf_ring.refill_buf_ring);\n\tath12k_dp_srng_cleanup(ab, &dp->tx_mon_buf_ring.refill_buf_ring);\n\n\tath12k_dp_rxdma_buf_free(ab);\n}\n\nvoid ath12k_dp_rx_pdev_free(struct ath12k_base *ab, int mac_id)\n{\n\tstruct ath12k *ar = ab->pdevs[mac_id].ar;\n\n\tath12k_dp_rx_pdev_srng_free(ar);\n}\n\nint ath12k_dp_rxdma_ring_sel_config_qcn9274(struct ath12k_base *ab)\n{\n\tstruct ath12k_dp *dp = &ab->dp;\n\tstruct htt_rx_ring_tlv_filter tlv_filter = {0};\n\tu32 ring_id;\n\tint ret;\n\tu32 hal_rx_desc_sz = ab->hw_params->hal_desc_sz;\n\n\tring_id = dp->rx_refill_buf_ring.refill_buf_ring.ring_id;\n\n\ttlv_filter.rx_filter = HTT_RX_TLV_FLAGS_RXDMA_RING;\n\ttlv_filter.pkt_filter_flags2 = HTT_RX_FP_CTRL_PKT_FILTER_TLV_FLAGS2_BAR;\n\ttlv_filter.pkt_filter_flags3 = HTT_RX_FP_DATA_PKT_FILTER_TLV_FLASG3_MCAST |\n\t\t\t\t\tHTT_RX_FP_DATA_PKT_FILTER_TLV_FLASG3_UCAST |\n\t\t\t\t\tHTT_RX_FP_DATA_PKT_FILTER_TLV_FLASG3_NULL_DATA;\n\ttlv_filter.offset_valid = true;\n\ttlv_filter.rx_packet_offset = hal_rx_desc_sz;\n\n\ttlv_filter.rx_mpdu_start_offset =\n\t\t\tab->hw_params->hal_ops->rx_desc_get_mpdu_start_offset();\n\ttlv_filter.rx_msdu_end_offset =\n\t\tab->hw_params->hal_ops->rx_desc_get_msdu_end_offset();\n\n\t \n\tret = ath12k_dp_tx_htt_rx_filter_setup(ab, ring_id, 0,\n\t\t\t\t\t       HAL_RXDMA_BUF,\n\t\t\t\t\t       DP_RXDMA_REFILL_RING_SIZE,\n\t\t\t\t\t       &tlv_filter);\n\n\treturn ret;\n}\n\nint ath12k_dp_rxdma_ring_sel_config_wcn7850(struct ath12k_base *ab)\n{\n\tstruct ath12k_dp *dp = &ab->dp;\n\tstruct htt_rx_ring_tlv_filter tlv_filter = {0};\n\tu32 ring_id;\n\tint ret;\n\tu32 hal_rx_desc_sz = ab->hw_params->hal_desc_sz;\n\tint i;\n\n\tring_id = dp->rx_refill_buf_ring.refill_buf_ring.ring_id;\n\n\ttlv_filter.rx_filter = HTT_RX_TLV_FLAGS_RXDMA_RING;\n\ttlv_filter.pkt_filter_flags2 = HTT_RX_FP_CTRL_PKT_FILTER_TLV_FLAGS2_BAR;\n\ttlv_filter.pkt_filter_flags3 = HTT_RX_FP_DATA_PKT_FILTER_TLV_FLASG3_MCAST |\n\t\t\t\t\tHTT_RX_FP_DATA_PKT_FILTER_TLV_FLASG3_UCAST |\n\t\t\t\t\tHTT_RX_FP_DATA_PKT_FILTER_TLV_FLASG3_NULL_DATA;\n\ttlv_filter.offset_valid = true;\n\ttlv_filter.rx_packet_offset = hal_rx_desc_sz;\n\n\ttlv_filter.rx_header_offset = offsetof(struct hal_rx_desc_wcn7850, pkt_hdr_tlv);\n\n\ttlv_filter.rx_mpdu_start_offset =\n\t\t\tab->hw_params->hal_ops->rx_desc_get_mpdu_start_offset();\n\ttlv_filter.rx_msdu_end_offset =\n\t\tab->hw_params->hal_ops->rx_desc_get_msdu_end_offset();\n\n\t \n\n\tfor (i = 0; i < ab->hw_params->num_rxmda_per_pdev; i++) {\n\t\tring_id = dp->rx_mac_buf_ring[i].ring_id;\n\t\tret = ath12k_dp_tx_htt_rx_filter_setup(ab, ring_id, i,\n\t\t\t\t\t\t       HAL_RXDMA_BUF,\n\t\t\t\t\t\t       DP_RXDMA_REFILL_RING_SIZE,\n\t\t\t\t\t\t       &tlv_filter);\n\t}\n\n\treturn ret;\n}\n\nint ath12k_dp_rx_htt_setup(struct ath12k_base *ab)\n{\n\tstruct ath12k_dp *dp = &ab->dp;\n\tu32 ring_id;\n\tint i, ret;\n\n\t \n\tring_id = dp->rx_refill_buf_ring.refill_buf_ring.ring_id;\n\tret = ath12k_dp_tx_htt_srng_setup(ab, ring_id, 0, HAL_RXDMA_BUF);\n\tif (ret) {\n\t\tath12k_warn(ab, \"failed to configure rx_refill_buf_ring %d\\n\",\n\t\t\t    ret);\n\t\treturn ret;\n\t}\n\n\tif (ab->hw_params->rx_mac_buf_ring) {\n\t\tfor (i = 0; i < ab->hw_params->num_rxmda_per_pdev; i++) {\n\t\t\tring_id = dp->rx_mac_buf_ring[i].ring_id;\n\t\t\tret = ath12k_dp_tx_htt_srng_setup(ab, ring_id,\n\t\t\t\t\t\t\t  i, HAL_RXDMA_BUF);\n\t\t\tif (ret) {\n\t\t\t\tath12k_warn(ab, \"failed to configure rx_mac_buf_ring%d %d\\n\",\n\t\t\t\t\t    i, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < ab->hw_params->num_rxdma_dst_ring; i++) {\n\t\tring_id = dp->rxdma_err_dst_ring[i].ring_id;\n\t\tret = ath12k_dp_tx_htt_srng_setup(ab, ring_id,\n\t\t\t\t\t\t  i, HAL_RXDMA_DST);\n\t\tif (ret) {\n\t\t\tath12k_warn(ab, \"failed to configure rxdma_err_dest_ring%d %d\\n\",\n\t\t\t\t    i, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (ab->hw_params->rxdma1_enable) {\n\t\tring_id = dp->rxdma_mon_buf_ring.refill_buf_ring.ring_id;\n\t\tret = ath12k_dp_tx_htt_srng_setup(ab, ring_id,\n\t\t\t\t\t\t  0, HAL_RXDMA_MONITOR_BUF);\n\t\tif (ret) {\n\t\t\tath12k_warn(ab, \"failed to configure rxdma_mon_buf_ring %d\\n\",\n\t\t\t\t    ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tring_id = dp->tx_mon_buf_ring.refill_buf_ring.ring_id;\n\t\tret = ath12k_dp_tx_htt_srng_setup(ab, ring_id,\n\t\t\t\t\t\t  0, HAL_TX_MONITOR_BUF);\n\t\tif (ret) {\n\t\t\tath12k_warn(ab, \"failed to configure rxdma_mon_buf_ring %d\\n\",\n\t\t\t\t    ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = ab->hw_params->hw_ops->rxdma_ring_sel_config(ab);\n\tif (ret) {\n\t\tath12k_warn(ab, \"failed to setup rxdma ring selection config\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint ath12k_dp_rx_alloc(struct ath12k_base *ab)\n{\n\tstruct ath12k_dp *dp = &ab->dp;\n\tint i, ret;\n\n\tidr_init(&dp->rx_refill_buf_ring.bufs_idr);\n\tspin_lock_init(&dp->rx_refill_buf_ring.idr_lock);\n\n\tidr_init(&dp->rxdma_mon_buf_ring.bufs_idr);\n\tspin_lock_init(&dp->rxdma_mon_buf_ring.idr_lock);\n\n\tidr_init(&dp->tx_mon_buf_ring.bufs_idr);\n\tspin_lock_init(&dp->tx_mon_buf_ring.idr_lock);\n\n\tret = ath12k_dp_srng_setup(ab,\n\t\t\t\t   &dp->rx_refill_buf_ring.refill_buf_ring,\n\t\t\t\t   HAL_RXDMA_BUF, 0, 0,\n\t\t\t\t   DP_RXDMA_BUF_RING_SIZE);\n\tif (ret) {\n\t\tath12k_warn(ab, \"failed to setup rx_refill_buf_ring\\n\");\n\t\treturn ret;\n\t}\n\n\tif (ab->hw_params->rx_mac_buf_ring) {\n\t\tfor (i = 0; i < ab->hw_params->num_rxmda_per_pdev; i++) {\n\t\t\tret = ath12k_dp_srng_setup(ab,\n\t\t\t\t\t\t   &dp->rx_mac_buf_ring[i],\n\t\t\t\t\t\t   HAL_RXDMA_BUF, 1,\n\t\t\t\t\t\t   i, 1024);\n\t\t\tif (ret) {\n\t\t\t\tath12k_warn(ab, \"failed to setup rx_mac_buf_ring %d\\n\",\n\t\t\t\t\t    i);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < ab->hw_params->num_rxdma_dst_ring; i++) {\n\t\tret = ath12k_dp_srng_setup(ab, &dp->rxdma_err_dst_ring[i],\n\t\t\t\t\t   HAL_RXDMA_DST, 0, i,\n\t\t\t\t\t   DP_RXDMA_ERR_DST_RING_SIZE);\n\t\tif (ret) {\n\t\t\tath12k_warn(ab, \"failed to setup rxdma_err_dst_ring %d\\n\", i);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (ab->hw_params->rxdma1_enable) {\n\t\tret = ath12k_dp_srng_setup(ab,\n\t\t\t\t\t   &dp->rxdma_mon_buf_ring.refill_buf_ring,\n\t\t\t\t\t   HAL_RXDMA_MONITOR_BUF, 0, 0,\n\t\t\t\t\t   DP_RXDMA_MONITOR_BUF_RING_SIZE);\n\t\tif (ret) {\n\t\t\tath12k_warn(ab, \"failed to setup HAL_RXDMA_MONITOR_BUF\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = ath12k_dp_srng_setup(ab,\n\t\t\t\t\t   &dp->tx_mon_buf_ring.refill_buf_ring,\n\t\t\t\t\t   HAL_TX_MONITOR_BUF, 0, 0,\n\t\t\t\t\t   DP_TX_MONITOR_BUF_RING_SIZE);\n\t\tif (ret) {\n\t\t\tath12k_warn(ab, \"failed to setup DP_TX_MONITOR_BUF_RING_SIZE\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = ath12k_dp_rxdma_buf_setup(ab);\n\tif (ret) {\n\t\tath12k_warn(ab, \"failed to setup rxdma ring\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint ath12k_dp_rx_pdev_alloc(struct ath12k_base *ab, int mac_id)\n{\n\tstruct ath12k *ar = ab->pdevs[mac_id].ar;\n\tstruct ath12k_pdev_dp *dp = &ar->dp;\n\tu32 ring_id;\n\tint i;\n\tint ret;\n\n\tif (!ab->hw_params->rxdma1_enable)\n\t\tgoto out;\n\n\tret = ath12k_dp_rx_pdev_srng_alloc(ar);\n\tif (ret) {\n\t\tath12k_warn(ab, \"failed to setup rx srngs\\n\");\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < ab->hw_params->num_rxmda_per_pdev; i++) {\n\t\tring_id = dp->rxdma_mon_dst_ring[i].ring_id;\n\t\tret = ath12k_dp_tx_htt_srng_setup(ab, ring_id,\n\t\t\t\t\t\t  mac_id + i,\n\t\t\t\t\t\t  HAL_RXDMA_MONITOR_DST);\n\t\tif (ret) {\n\t\t\tath12k_warn(ab,\n\t\t\t\t    \"failed to configure rxdma_mon_dst_ring %d %d\\n\",\n\t\t\t\t    i, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tring_id = dp->tx_mon_dst_ring[i].ring_id;\n\t\tret = ath12k_dp_tx_htt_srng_setup(ab, ring_id,\n\t\t\t\t\t\t  mac_id + i,\n\t\t\t\t\t\t  HAL_TX_MONITOR_DST);\n\t\tif (ret) {\n\t\t\tath12k_warn(ab,\n\t\t\t\t    \"failed to configure tx_mon_dst_ring %d %d\\n\",\n\t\t\t\t    i, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\nout:\n\treturn 0;\n}\n\nstatic int ath12k_dp_rx_pdev_mon_status_attach(struct ath12k *ar)\n{\n\tstruct ath12k_pdev_dp *dp = &ar->dp;\n\tstruct ath12k_mon_data *pmon = (struct ath12k_mon_data *)&dp->mon_data;\n\n\tskb_queue_head_init(&pmon->rx_status_q);\n\n\tpmon->mon_ppdu_status = DP_PPDU_STATUS_START;\n\n\tmemset(&pmon->rx_mon_stats, 0,\n\t       sizeof(pmon->rx_mon_stats));\n\treturn 0;\n}\n\nint ath12k_dp_rx_pdev_mon_attach(struct ath12k *ar)\n{\n\tstruct ath12k_pdev_dp *dp = &ar->dp;\n\tstruct ath12k_mon_data *pmon = &dp->mon_data;\n\tint ret = 0;\n\n\tret = ath12k_dp_rx_pdev_mon_status_attach(ar);\n\tif (ret) {\n\t\tath12k_warn(ar->ab, \"pdev_mon_status_attach() failed\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (!ar->ab->hw_params->rxdma1_enable)\n\t\treturn 0;\n\n\tpmon->mon_last_linkdesc_paddr = 0;\n\tpmon->mon_last_buf_cookie = DP_RX_DESC_COOKIE_MAX + 1;\n\tspin_lock_init(&pmon->mon_lock);\n\n\treturn 0;\n}\n\nint ath12k_dp_rx_pktlog_start(struct ath12k_base *ab)\n{\n\t \n\tmod_timer(&ab->mon_reap_timer,\n\t\t  jiffies + msecs_to_jiffies(ATH12K_MON_TIMER_INTERVAL));\n\n\treturn 0;\n}\n\nint ath12k_dp_rx_pktlog_stop(struct ath12k_base *ab, bool stop_timer)\n{\n\tint ret;\n\n\tif (stop_timer)\n\t\tdel_timer_sync(&ab->mon_reap_timer);\n\n\t \n\tret = ath12k_dp_purge_mon_ring(ab);\n\tif (ret) {\n\t\tath12k_warn(ab, \"failed to purge dp mon ring: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}