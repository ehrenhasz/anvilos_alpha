{
  "module_name": "htc.c",
  "hash_id": "aeaef8633e8c5e8ad0540b8f8aac91a26c9b20ddb5ae6981d54b6a7ed254552f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath12k/htc.c",
  "human_readable_source": "\n \n#include <linux/skbuff.h>\n#include <linux/ctype.h>\n\n#include \"debug.h\"\n#include \"hif.h\"\n\nstruct sk_buff *ath12k_htc_alloc_skb(struct ath12k_base *ab, int size)\n{\n\tstruct sk_buff *skb;\n\n\tskb = dev_alloc_skb(size + sizeof(struct ath12k_htc_hdr));\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, sizeof(struct ath12k_htc_hdr));\n\n\t \n\tif (!IS_ALIGNED((unsigned long)skb->data, 4))\n\t\tath12k_warn(ab, \"Unaligned HTC tx skb\\n\");\n\n\treturn skb;\n}\n\nstatic void ath12k_htc_control_tx_complete(struct ath12k_base *ab,\n\t\t\t\t\t   struct sk_buff *skb)\n{\n\tkfree_skb(skb);\n}\n\nstatic struct sk_buff *ath12k_htc_build_tx_ctrl_skb(void)\n{\n\tstruct sk_buff *skb;\n\tstruct ath12k_skb_cb *skb_cb;\n\n\tskb = dev_alloc_skb(ATH12K_HTC_CONTROL_BUFFER_SIZE);\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, sizeof(struct ath12k_htc_hdr));\n\tWARN_ON_ONCE(!IS_ALIGNED((unsigned long)skb->data, 4));\n\n\tskb_cb = ATH12K_SKB_CB(skb);\n\tmemset(skb_cb, 0, sizeof(*skb_cb));\n\n\treturn skb;\n}\n\nstatic void ath12k_htc_prepare_tx_skb(struct ath12k_htc_ep *ep,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct ath12k_htc_hdr *hdr;\n\n\thdr = (struct ath12k_htc_hdr *)skb->data;\n\n\tmemset(hdr, 0, sizeof(*hdr));\n\thdr->htc_info = le32_encode_bits(ep->eid, HTC_HDR_ENDPOINTID) |\n\t\t\tle32_encode_bits((skb->len - sizeof(*hdr)),\n\t\t\t\t\t HTC_HDR_PAYLOADLEN);\n\n\tif (ep->tx_credit_flow_enabled)\n\t\thdr->htc_info |= le32_encode_bits(ATH12K_HTC_FLAG_NEED_CREDIT_UPDATE,\n\t\t\t\t\t\t  HTC_HDR_FLAGS);\n\n\tspin_lock_bh(&ep->htc->tx_lock);\n\thdr->ctrl_info = le32_encode_bits(ep->seq_no++, HTC_HDR_CONTROLBYTES1);\n\tspin_unlock_bh(&ep->htc->tx_lock);\n}\n\nint ath12k_htc_send(struct ath12k_htc *htc,\n\t\t    enum ath12k_htc_ep_id eid,\n\t\t    struct sk_buff *skb)\n{\n\tstruct ath12k_htc_ep *ep = &htc->endpoint[eid];\n\tstruct ath12k_skb_cb *skb_cb = ATH12K_SKB_CB(skb);\n\tstruct device *dev = htc->ab->dev;\n\tstruct ath12k_base *ab = htc->ab;\n\tint credits = 0;\n\tint ret;\n\n\tif (eid >= ATH12K_HTC_EP_COUNT) {\n\t\tath12k_warn(ab, \"Invalid endpoint id: %d\\n\", eid);\n\t\treturn -ENOENT;\n\t}\n\n\tskb_push(skb, sizeof(struct ath12k_htc_hdr));\n\n\tif (ep->tx_credit_flow_enabled) {\n\t\tcredits = DIV_ROUND_UP(skb->len, htc->target_credit_size);\n\t\tspin_lock_bh(&htc->tx_lock);\n\t\tif (ep->tx_credits < credits) {\n\t\t\tath12k_dbg(ab, ATH12K_DBG_HTC,\n\t\t\t\t   \"htc insufficient credits ep %d required %d available %d\\n\",\n\t\t\t\t   eid, credits, ep->tx_credits);\n\t\t\tspin_unlock_bh(&htc->tx_lock);\n\t\t\tret = -EAGAIN;\n\t\t\tgoto err_pull;\n\t\t}\n\t\tep->tx_credits -= credits;\n\t\tath12k_dbg(ab, ATH12K_DBG_HTC,\n\t\t\t   \"htc ep %d consumed %d credits (total %d)\\n\",\n\t\t\t   eid, credits, ep->tx_credits);\n\t\tspin_unlock_bh(&htc->tx_lock);\n\t}\n\n\tath12k_htc_prepare_tx_skb(ep, skb);\n\n\tskb_cb->paddr = dma_map_single(dev, skb->data, skb->len, DMA_TO_DEVICE);\n\tret = dma_mapping_error(dev, skb_cb->paddr);\n\tif (ret) {\n\t\tret = -EIO;\n\t\tgoto err_credits;\n\t}\n\n\tret = ath12k_ce_send(htc->ab, skb, ep->ul_pipe_id, ep->eid);\n\tif (ret)\n\t\tgoto err_unmap;\n\n\treturn 0;\n\nerr_unmap:\n\tdma_unmap_single(dev, skb_cb->paddr, skb->len, DMA_TO_DEVICE);\nerr_credits:\n\tif (ep->tx_credit_flow_enabled) {\n\t\tspin_lock_bh(&htc->tx_lock);\n\t\tep->tx_credits += credits;\n\t\tath12k_dbg(ab, ATH12K_DBG_HTC,\n\t\t\t   \"htc ep %d reverted %d credits back (total %d)\\n\",\n\t\t\t   eid, credits, ep->tx_credits);\n\t\tspin_unlock_bh(&htc->tx_lock);\n\n\t\tif (ep->ep_ops.ep_tx_credits)\n\t\t\tep->ep_ops.ep_tx_credits(htc->ab);\n\t}\nerr_pull:\n\tskb_pull(skb, sizeof(struct ath12k_htc_hdr));\n\treturn ret;\n}\n\nstatic void\nath12k_htc_process_credit_report(struct ath12k_htc *htc,\n\t\t\t\t const struct ath12k_htc_credit_report *report,\n\t\t\t\t int len,\n\t\t\t\t enum ath12k_htc_ep_id eid)\n{\n\tstruct ath12k_base *ab = htc->ab;\n\tstruct ath12k_htc_ep *ep;\n\tint i, n_reports;\n\n\tif (len % sizeof(*report))\n\t\tath12k_warn(ab, \"Uneven credit report len %d\", len);\n\n\tn_reports = len / sizeof(*report);\n\n\tspin_lock_bh(&htc->tx_lock);\n\tfor (i = 0; i < n_reports; i++, report++) {\n\t\tif (report->eid >= ATH12K_HTC_EP_COUNT)\n\t\t\tbreak;\n\n\t\tep = &htc->endpoint[report->eid];\n\t\tep->tx_credits += report->credits;\n\n\t\tath12k_dbg(ab, ATH12K_DBG_HTC, \"htc ep %d got %d credits (total %d)\\n\",\n\t\t\t   report->eid, report->credits, ep->tx_credits);\n\n\t\tif (ep->ep_ops.ep_tx_credits) {\n\t\t\tspin_unlock_bh(&htc->tx_lock);\n\t\t\tep->ep_ops.ep_tx_credits(htc->ab);\n\t\t\tspin_lock_bh(&htc->tx_lock);\n\t\t}\n\t}\n\tspin_unlock_bh(&htc->tx_lock);\n}\n\nstatic int ath12k_htc_process_trailer(struct ath12k_htc *htc,\n\t\t\t\t      u8 *buffer,\n\t\t\t\t      int length,\n\t\t\t\t      enum ath12k_htc_ep_id src_eid)\n{\n\tstruct ath12k_base *ab = htc->ab;\n\tint status = 0;\n\tstruct ath12k_htc_record *record;\n\tsize_t len;\n\n\twhile (length > 0) {\n\t\trecord = (struct ath12k_htc_record *)buffer;\n\n\t\tif (length < sizeof(record->hdr)) {\n\t\t\tstatus = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (record->hdr.len > length) {\n\t\t\t \n\t\t\tath12k_warn(ab, \"Invalid record length: %d\\n\",\n\t\t\t\t    record->hdr.len);\n\t\t\tstatus = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (record->hdr.id) {\n\t\tcase ATH12K_HTC_RECORD_CREDITS:\n\t\t\tlen = sizeof(struct ath12k_htc_credit_report);\n\t\t\tif (record->hdr.len < len) {\n\t\t\t\tath12k_warn(ab, \"Credit report too long\\n\");\n\t\t\t\tstatus = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tath12k_htc_process_credit_report(htc,\n\t\t\t\t\t\t\t record->credit_report,\n\t\t\t\t\t\t\t record->hdr.len,\n\t\t\t\t\t\t\t src_eid);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tath12k_warn(ab, \"Unhandled record: id:%d length:%d\\n\",\n\t\t\t\t    record->hdr.id, record->hdr.len);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (status)\n\t\t\tbreak;\n\n\t\t \n\t\tbuffer += sizeof(record->hdr) + record->hdr.len;\n\t\tlength -= sizeof(record->hdr) + record->hdr.len;\n\t}\n\n\treturn status;\n}\n\nstatic void ath12k_htc_suspend_complete(struct ath12k_base *ab, bool ack)\n{\n\tath12k_dbg(ab, ATH12K_DBG_BOOT, \"boot suspend complete %d\\n\", ack);\n\n\tif (ack)\n\t\tset_bit(ATH12K_FLAG_HTC_SUSPEND_COMPLETE, &ab->dev_flags);\n\telse\n\t\tclear_bit(ATH12K_FLAG_HTC_SUSPEND_COMPLETE, &ab->dev_flags);\n\n\tcomplete(&ab->htc_suspend);\n}\n\nvoid ath12k_htc_rx_completion_handler(struct ath12k_base *ab,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tint status = 0;\n\tstruct ath12k_htc *htc = &ab->htc;\n\tstruct ath12k_htc_hdr *hdr;\n\tstruct ath12k_htc_ep *ep;\n\tu16 payload_len;\n\tu32 trailer_len = 0;\n\tsize_t min_len;\n\tu8 eid;\n\tbool trailer_present;\n\n\thdr = (struct ath12k_htc_hdr *)skb->data;\n\tskb_pull(skb, sizeof(*hdr));\n\n\teid = le32_get_bits(hdr->htc_info, HTC_HDR_ENDPOINTID);\n\n\tif (eid >= ATH12K_HTC_EP_COUNT) {\n\t\tath12k_warn(ab, \"HTC Rx: invalid eid %d\\n\", eid);\n\t\tgoto out;\n\t}\n\n\tep = &htc->endpoint[eid];\n\n\tpayload_len = le32_get_bits(hdr->htc_info, HTC_HDR_PAYLOADLEN);\n\n\tif (payload_len + sizeof(*hdr) > ATH12K_HTC_MAX_LEN) {\n\t\tath12k_warn(ab, \"HTC rx frame too long, len: %zu\\n\",\n\t\t\t    payload_len + sizeof(*hdr));\n\t\tgoto out;\n\t}\n\n\tif (skb->len < payload_len) {\n\t\tath12k_warn(ab, \"HTC Rx: insufficient length, got %d, expected %d\\n\",\n\t\t\t    skb->len, payload_len);\n\t\tgoto out;\n\t}\n\n\t \n\ttrailer_present = le32_get_bits(hdr->htc_info, HTC_HDR_FLAGS) &\n\t\t\t  ATH12K_HTC_FLAG_TRAILER_PRESENT;\n\n\tif (trailer_present) {\n\t\tu8 *trailer;\n\n\t\ttrailer_len = le32_get_bits(hdr->ctrl_info,\n\t\t\t\t\t    HTC_HDR_CONTROLBYTES0);\n\t\tmin_len = sizeof(struct ath12k_htc_record_hdr);\n\n\t\tif ((trailer_len < min_len) ||\n\t\t    (trailer_len > payload_len)) {\n\t\t\tath12k_warn(ab, \"Invalid trailer length: %d\\n\",\n\t\t\t\t    trailer_len);\n\t\t\tgoto out;\n\t\t}\n\n\t\ttrailer = (u8 *)hdr;\n\t\ttrailer += sizeof(*hdr);\n\t\ttrailer += payload_len;\n\t\ttrailer -= trailer_len;\n\t\tstatus = ath12k_htc_process_trailer(htc, trailer,\n\t\t\t\t\t\t    trailer_len, eid);\n\t\tif (status)\n\t\t\tgoto out;\n\n\t\tskb_trim(skb, skb->len - trailer_len);\n\t}\n\n\tif (trailer_len >= payload_len)\n\t\t \n\t\tgoto out;\n\n\tif (eid == ATH12K_HTC_EP_0) {\n\t\tstruct ath12k_htc_msg *msg = (struct ath12k_htc_msg *)skb->data;\n\n\t\tswitch (le32_get_bits(msg->msg_svc_id, HTC_MSG_MESSAGEID)) {\n\t\tcase ATH12K_HTC_MSG_READY_ID:\n\t\tcase ATH12K_HTC_MSG_CONNECT_SERVICE_RESP_ID:\n\t\t\t \n\t\t\tif (completion_done(&htc->ctl_resp)) {\n\t\t\t\t \n\t\t\t\tath12k_warn(ab, \"HTC rx ctrl still processing\\n\");\n\t\t\t\tcomplete(&htc->ctl_resp);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\thtc->control_resp_len =\n\t\t\t\tmin_t(int, skb->len,\n\t\t\t\t      ATH12K_HTC_MAX_CTRL_MSG_LEN);\n\n\t\t\tmemcpy(htc->control_resp_buffer, skb->data,\n\t\t\t       htc->control_resp_len);\n\n\t\t\tcomplete(&htc->ctl_resp);\n\t\t\tbreak;\n\t\tcase ATH12K_HTC_MSG_SEND_SUSPEND_COMPLETE:\n\t\t\tath12k_htc_suspend_complete(ab, true);\n\t\t\tbreak;\n\t\tcase ATH12K_HTC_MSG_NACK_SUSPEND:\n\t\t\tath12k_htc_suspend_complete(ab, false);\n\t\t\tbreak;\n\t\tcase ATH12K_HTC_MSG_WAKEUP_FROM_SUSPEND_ID:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tath12k_warn(ab, \"ignoring unsolicited htc ep0 event %u\\n\",\n\t\t\t\t    le32_get_bits(msg->msg_svc_id, HTC_MSG_MESSAGEID));\n\t\t\tbreak;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tath12k_dbg(ab, ATH12K_DBG_HTC, \"htc rx completion ep %d skb %pK\\n\",\n\t\t   eid, skb);\n\tep->ep_ops.ep_rx_complete(ab, skb);\n\n\t \n\tath12k_ce_poll_send_completed(ab, ep->ul_pipe_id);\n\n\t \n\tskb = NULL;\nout:\n\tkfree_skb(skb);\n}\n\nstatic void ath12k_htc_control_rx_complete(struct ath12k_base *ab,\n\t\t\t\t\t   struct sk_buff *skb)\n{\n\t \n\tath12k_warn(ab, \"unexpected htc rx\\n\");\n\tkfree_skb(skb);\n}\n\nstatic const char *htc_service_name(enum ath12k_htc_svc_id id)\n{\n\tswitch (id) {\n\tcase ATH12K_HTC_SVC_ID_RESERVED:\n\t\treturn \"Reserved\";\n\tcase ATH12K_HTC_SVC_ID_RSVD_CTRL:\n\t\treturn \"Control\";\n\tcase ATH12K_HTC_SVC_ID_WMI_CONTROL:\n\t\treturn \"WMI\";\n\tcase ATH12K_HTC_SVC_ID_WMI_DATA_BE:\n\t\treturn \"DATA BE\";\n\tcase ATH12K_HTC_SVC_ID_WMI_DATA_BK:\n\t\treturn \"DATA BK\";\n\tcase ATH12K_HTC_SVC_ID_WMI_DATA_VI:\n\t\treturn \"DATA VI\";\n\tcase ATH12K_HTC_SVC_ID_WMI_DATA_VO:\n\t\treturn \"DATA VO\";\n\tcase ATH12K_HTC_SVC_ID_WMI_CONTROL_MAC1:\n\t\treturn \"WMI MAC1\";\n\tcase ATH12K_HTC_SVC_ID_WMI_CONTROL_MAC2:\n\t\treturn \"WMI MAC2\";\n\tcase ATH12K_HTC_SVC_ID_NMI_CONTROL:\n\t\treturn \"NMI Control\";\n\tcase ATH12K_HTC_SVC_ID_NMI_DATA:\n\t\treturn \"NMI Data\";\n\tcase ATH12K_HTC_SVC_ID_HTT_DATA_MSG:\n\t\treturn \"HTT Data\";\n\tcase ATH12K_HTC_SVC_ID_TEST_RAW_STREAMS:\n\t\treturn \"RAW\";\n\tcase ATH12K_HTC_SVC_ID_IPA_TX:\n\t\treturn \"IPA TX\";\n\tcase ATH12K_HTC_SVC_ID_PKT_LOG:\n\t\treturn \"PKT LOG\";\n\tcase ATH12K_HTC_SVC_ID_WMI_CONTROL_DIAG:\n\t\treturn \"WMI DIAG\";\n\t}\n\n\treturn \"Unknown\";\n}\n\nstatic void ath12k_htc_reset_endpoint_states(struct ath12k_htc *htc)\n{\n\tstruct ath12k_htc_ep *ep;\n\tint i;\n\n\tfor (i = ATH12K_HTC_EP_0; i < ATH12K_HTC_EP_COUNT; i++) {\n\t\tep = &htc->endpoint[i];\n\t\tep->service_id = ATH12K_HTC_SVC_ID_UNUSED;\n\t\tep->max_ep_message_len = 0;\n\t\tep->max_tx_queue_depth = 0;\n\t\tep->eid = i;\n\t\tep->htc = htc;\n\t\tep->tx_credit_flow_enabled = true;\n\t}\n}\n\nstatic u8 ath12k_htc_get_credit_allocation(struct ath12k_htc *htc,\n\t\t\t\t\t   u16 service_id)\n{\n\tstruct ath12k_htc_svc_tx_credits *serv_entry;\n\tu8 i, allocation = 0;\n\n\tserv_entry = htc->service_alloc_table;\n\n\tfor (i = 0; i < ATH12K_HTC_MAX_SERVICE_ALLOC_ENTRIES; i++) {\n\t\tif (serv_entry[i].service_id == service_id) {\n\t\t\tallocation = serv_entry[i].credit_allocation;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn allocation;\n}\n\nstatic int ath12k_htc_setup_target_buffer_assignments(struct ath12k_htc *htc)\n{\n\tstruct ath12k_htc_svc_tx_credits *serv_entry;\n\tstatic const u32 svc_id[] = {\n\t\t\t\t\tATH12K_HTC_SVC_ID_WMI_CONTROL,\n\t\t\t\t\tATH12K_HTC_SVC_ID_WMI_CONTROL_MAC1,\n\t\t\t\t\tATH12K_HTC_SVC_ID_WMI_CONTROL_MAC2,\n\t\t\t\t};\n\tint i, credits;\n\n\tcredits = htc->total_transmit_credits;\n\tserv_entry = htc->service_alloc_table;\n\n\tif ((htc->wmi_ep_count == 0) ||\n\t    (htc->wmi_ep_count > ARRAY_SIZE(svc_id)))\n\t\treturn -EINVAL;\n\n\t \n\tcredits = credits / htc->wmi_ep_count;\n\tfor (i = 0; i < htc->wmi_ep_count; i++) {\n\t\tserv_entry[i].service_id = svc_id[i];\n\t\tserv_entry[i].credit_allocation = credits;\n\t}\n\n\treturn 0;\n}\n\nint ath12k_htc_wait_target(struct ath12k_htc *htc)\n{\n\tint i, status = 0;\n\tstruct ath12k_base *ab = htc->ab;\n\tunsigned long time_left;\n\tstruct ath12k_htc_ready *ready;\n\tu16 message_id;\n\tu16 credit_count;\n\tu16 credit_size;\n\n\ttime_left = wait_for_completion_timeout(&htc->ctl_resp,\n\t\t\t\t\t\tATH12K_HTC_WAIT_TIMEOUT_HZ);\n\tif (!time_left) {\n\t\tath12k_warn(ab, \"failed to receive control response completion, polling..\\n\");\n\n\t\tfor (i = 0; i < ab->hw_params->ce_count; i++)\n\t\t\tath12k_ce_per_engine_service(htc->ab, i);\n\n\t\ttime_left =\n\t\t\twait_for_completion_timeout(&htc->ctl_resp,\n\t\t\t\t\t\t    ATH12K_HTC_WAIT_TIMEOUT_HZ);\n\n\t\tif (!time_left)\n\t\t\tstatus = -ETIMEDOUT;\n\t}\n\n\tif (status < 0) {\n\t\tath12k_warn(ab, \"ctl_resp never came in (%d)\\n\", status);\n\t\treturn status;\n\t}\n\n\tif (htc->control_resp_len < sizeof(*ready)) {\n\t\tath12k_warn(ab, \"Invalid HTC ready msg len:%d\\n\",\n\t\t\t    htc->control_resp_len);\n\t\treturn -ECOMM;\n\t}\n\n\tready = (struct ath12k_htc_ready *)htc->control_resp_buffer;\n\tmessage_id = le32_get_bits(ready->id_credit_count, HTC_MSG_MESSAGEID);\n\tcredit_count = le32_get_bits(ready->id_credit_count,\n\t\t\t\t     HTC_READY_MSG_CREDITCOUNT);\n\tcredit_size = le32_get_bits(ready->size_ep, HTC_READY_MSG_CREDITSIZE);\n\n\tif (message_id != ATH12K_HTC_MSG_READY_ID) {\n\t\tath12k_warn(ab, \"Invalid HTC ready msg: 0x%x\\n\", message_id);\n\t\treturn -ECOMM;\n\t}\n\n\thtc->total_transmit_credits = credit_count;\n\thtc->target_credit_size = credit_size;\n\n\tath12k_dbg(ab, ATH12K_DBG_HTC,\n\t\t   \"Target ready! transmit resources: %d size:%d\\n\",\n\t\t   htc->total_transmit_credits, htc->target_credit_size);\n\n\tif ((htc->total_transmit_credits == 0) ||\n\t    (htc->target_credit_size == 0)) {\n\t\tath12k_warn(ab, \"Invalid credit size received\\n\");\n\t\treturn -ECOMM;\n\t}\n\n\tath12k_htc_setup_target_buffer_assignments(htc);\n\n\treturn 0;\n}\n\nint ath12k_htc_connect_service(struct ath12k_htc *htc,\n\t\t\t       struct ath12k_htc_svc_conn_req *conn_req,\n\t\t\t       struct ath12k_htc_svc_conn_resp *conn_resp)\n{\n\tstruct ath12k_base *ab = htc->ab;\n\tstruct ath12k_htc_conn_svc *req_msg;\n\tstruct ath12k_htc_conn_svc_resp resp_msg_dummy;\n\tstruct ath12k_htc_conn_svc_resp *resp_msg = &resp_msg_dummy;\n\tenum ath12k_htc_ep_id assigned_eid = ATH12K_HTC_EP_COUNT;\n\tstruct ath12k_htc_ep *ep;\n\tstruct sk_buff *skb;\n\tunsigned int max_msg_size = 0;\n\tint length, status;\n\tunsigned long time_left;\n\tbool disable_credit_flow_ctrl = false;\n\tu16 message_id, service_id, flags = 0;\n\tu8 tx_alloc = 0;\n\n\t \n\tif (conn_req->service_id == ATH12K_HTC_SVC_ID_RSVD_CTRL) {\n\t\tdisable_credit_flow_ctrl = true;\n\t\tassigned_eid = ATH12K_HTC_EP_0;\n\t\tmax_msg_size = ATH12K_HTC_MAX_CTRL_MSG_LEN;\n\t\tmemset(&resp_msg_dummy, 0, sizeof(resp_msg_dummy));\n\t\tgoto setup;\n\t}\n\n\ttx_alloc = ath12k_htc_get_credit_allocation(htc,\n\t\t\t\t\t\t    conn_req->service_id);\n\tif (!tx_alloc)\n\t\tath12k_dbg(ab, ATH12K_DBG_BOOT,\n\t\t\t   \"boot htc service %s does not allocate target credits\\n\",\n\t\t\t   htc_service_name(conn_req->service_id));\n\n\tskb = ath12k_htc_build_tx_ctrl_skb();\n\tif (!skb) {\n\t\tath12k_warn(ab, \"Failed to allocate HTC packet\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tlength = sizeof(*req_msg);\n\tskb_put(skb, length);\n\tmemset(skb->data, 0, length);\n\n\treq_msg = (struct ath12k_htc_conn_svc *)skb->data;\n\treq_msg->msg_svc_id = le32_encode_bits(ATH12K_HTC_MSG_CONNECT_SERVICE_ID,\n\t\t\t\t\t       HTC_MSG_MESSAGEID);\n\n\tflags |= u32_encode_bits(tx_alloc, ATH12K_HTC_CONN_FLAGS_RECV_ALLOC);\n\n\t \n\tif (!(conn_req->service_id == ATH12K_HTC_SVC_ID_WMI_CONTROL ||\n\t      conn_req->service_id == ATH12K_HTC_SVC_ID_WMI_CONTROL_MAC1 ||\n\t      conn_req->service_id == ATH12K_HTC_SVC_ID_WMI_CONTROL_MAC2)) {\n\t\tflags |= ATH12K_HTC_CONN_FLAGS_DISABLE_CREDIT_FLOW_CTRL;\n\t\tdisable_credit_flow_ctrl = true;\n\t}\n\n\treq_msg->flags_len = le32_encode_bits(flags, HTC_SVC_MSG_CONNECTIONFLAGS);\n\treq_msg->msg_svc_id |= le32_encode_bits(conn_req->service_id,\n\t\t\t\t\t\tHTC_SVC_MSG_SERVICE_ID);\n\n\treinit_completion(&htc->ctl_resp);\n\n\tstatus = ath12k_htc_send(htc, ATH12K_HTC_EP_0, skb);\n\tif (status) {\n\t\tkfree_skb(skb);\n\t\treturn status;\n\t}\n\n\t \n\ttime_left = wait_for_completion_timeout(&htc->ctl_resp,\n\t\t\t\t\t\tATH12K_HTC_CONN_SVC_TIMEOUT_HZ);\n\tif (!time_left) {\n\t\tath12k_err(ab, \"Service connect timeout\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\tresp_msg = (struct ath12k_htc_conn_svc_resp *)htc->control_resp_buffer;\n\tmessage_id = le32_get_bits(resp_msg->msg_svc_id, HTC_MSG_MESSAGEID);\n\tservice_id = le32_get_bits(resp_msg->msg_svc_id,\n\t\t\t\t   HTC_SVC_RESP_MSG_SERVICEID);\n\n\tif ((message_id != ATH12K_HTC_MSG_CONNECT_SERVICE_RESP_ID) ||\n\t    (htc->control_resp_len < sizeof(*resp_msg))) {\n\t\tath12k_err(ab, \"Invalid resp message ID 0x%x\", message_id);\n\t\treturn -EPROTO;\n\t}\n\n\tath12k_dbg(ab, ATH12K_DBG_HTC,\n\t\t   \"HTC Service %s connect response: status: %u, assigned ep: %u\\n\",\n\t\t   htc_service_name(service_id),\n\t\t   le32_get_bits(resp_msg->flags_len, HTC_SVC_RESP_MSG_STATUS),\n\t\t   le32_get_bits(resp_msg->flags_len, HTC_SVC_RESP_MSG_ENDPOINTID));\n\n\tconn_resp->connect_resp_code = le32_get_bits(resp_msg->flags_len,\n\t\t\t\t\t\t     HTC_SVC_RESP_MSG_STATUS);\n\n\t \n\tif (conn_resp->connect_resp_code != ATH12K_HTC_CONN_SVC_STATUS_SUCCESS) {\n\t\tath12k_err(ab, \"HTC Service %s connect request failed: 0x%x)\\n\",\n\t\t\t   htc_service_name(service_id),\n\t\t       conn_resp->connect_resp_code);\n\t\treturn -EPROTO;\n\t}\n\n\tassigned_eid = le32_get_bits(resp_msg->flags_len,\n\t\t\t\t     HTC_SVC_RESP_MSG_ENDPOINTID);\n\n\tmax_msg_size = le32_get_bits(resp_msg->flags_len,\n\t\t\t\t     HTC_SVC_RESP_MSG_MAXMSGSIZE);\n\nsetup:\n\n\tif (assigned_eid >= ATH12K_HTC_EP_COUNT)\n\t\treturn -EPROTO;\n\n\tif (max_msg_size == 0)\n\t\treturn -EPROTO;\n\n\tep = &htc->endpoint[assigned_eid];\n\tep->eid = assigned_eid;\n\n\tif (ep->service_id != ATH12K_HTC_SVC_ID_UNUSED)\n\t\treturn -EPROTO;\n\n\t \n\tconn_resp->eid = assigned_eid;\n\tconn_resp->max_msg_len = le32_get_bits(resp_msg->flags_len,\n\t\t\t\t\t       HTC_SVC_RESP_MSG_MAXMSGSIZE);\n\n\t \n\tep->service_id = conn_req->service_id;\n\tep->max_tx_queue_depth = conn_req->max_send_queue_depth;\n\tep->max_ep_message_len = le32_get_bits(resp_msg->flags_len,\n\t\t\t\t\t       HTC_SVC_RESP_MSG_MAXMSGSIZE);\n\tep->tx_credits = tx_alloc;\n\n\t \n\tep->ep_ops = conn_req->ep_ops;\n\n\tstatus = ath12k_hif_map_service_to_pipe(htc->ab,\n\t\t\t\t\t\tep->service_id,\n\t\t\t\t\t\t&ep->ul_pipe_id,\n\t\t\t\t\t\t&ep->dl_pipe_id);\n\tif (status)\n\t\treturn status;\n\n\tath12k_dbg(ab, ATH12K_DBG_BOOT,\n\t\t   \"boot htc service '%s' ul pipe %d dl pipe %d eid %d ready\\n\",\n\t\t   htc_service_name(ep->service_id), ep->ul_pipe_id,\n\t\t   ep->dl_pipe_id, ep->eid);\n\n\tif (disable_credit_flow_ctrl && ep->tx_credit_flow_enabled) {\n\t\tep->tx_credit_flow_enabled = false;\n\t\tath12k_dbg(ab, ATH12K_DBG_BOOT,\n\t\t\t   \"boot htc service '%s' eid %d TX flow control disabled\\n\",\n\t\t\t   htc_service_name(ep->service_id), assigned_eid);\n\t}\n\n\treturn status;\n}\n\nint ath12k_htc_start(struct ath12k_htc *htc)\n{\n\tstruct sk_buff *skb;\n\tint status;\n\tstruct ath12k_base *ab = htc->ab;\n\tstruct ath12k_htc_setup_complete_extended *msg;\n\n\tskb = ath12k_htc_build_tx_ctrl_skb();\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put(skb, sizeof(*msg));\n\tmemset(skb->data, 0, skb->len);\n\n\tmsg = (struct ath12k_htc_setup_complete_extended *)skb->data;\n\tmsg->msg_id = le32_encode_bits(ATH12K_HTC_MSG_SETUP_COMPLETE_EX_ID,\n\t\t\t\t       HTC_MSG_MESSAGEID);\n\n\tath12k_dbg(ab, ATH12K_DBG_HTC, \"HTC is using TX credit flow control\\n\");\n\n\tstatus = ath12k_htc_send(htc, ATH12K_HTC_EP_0, skb);\n\tif (status) {\n\t\tkfree_skb(skb);\n\t\treturn status;\n\t}\n\n\treturn 0;\n}\n\nint ath12k_htc_init(struct ath12k_base *ab)\n{\n\tstruct ath12k_htc *htc = &ab->htc;\n\tstruct ath12k_htc_svc_conn_req conn_req = { };\n\tstruct ath12k_htc_svc_conn_resp conn_resp = { };\n\tint ret;\n\n\tspin_lock_init(&htc->tx_lock);\n\n\tath12k_htc_reset_endpoint_states(htc);\n\n\thtc->ab = ab;\n\n\tswitch (ab->wmi_ab.preferred_hw_mode) {\n\tcase WMI_HOST_HW_MODE_SINGLE:\n\t\thtc->wmi_ep_count = 1;\n\t\tbreak;\n\tcase WMI_HOST_HW_MODE_DBS:\n\tcase WMI_HOST_HW_MODE_DBS_OR_SBS:\n\t\thtc->wmi_ep_count = 2;\n\t\tbreak;\n\tcase WMI_HOST_HW_MODE_DBS_SBS:\n\t\thtc->wmi_ep_count = 3;\n\t\tbreak;\n\tdefault:\n\t\thtc->wmi_ep_count = ab->hw_params->max_radios;\n\t\tbreak;\n\t}\n\n\t \n\tconn_req.ep_ops.ep_tx_complete = ath12k_htc_control_tx_complete;\n\tconn_req.ep_ops.ep_rx_complete = ath12k_htc_control_rx_complete;\n\tconn_req.max_send_queue_depth = ATH12K_NUM_CONTROL_TX_BUFFERS;\n\tconn_req.service_id = ATH12K_HTC_SVC_ID_RSVD_CTRL;\n\n\t \n\tret = ath12k_htc_connect_service(htc, &conn_req, &conn_resp);\n\tif (ret) {\n\t\tath12k_err(ab, \"could not connect to htc service (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tinit_completion(&htc->ctl_resp);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}