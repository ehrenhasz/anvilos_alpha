{
  "module_name": "hal_rx.c",
  "hash_id": "01eda9ff8bd69e55f3086a8ef9ea49e56603ad05e8fcda1f379e8c31e204e614",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath12k/hal_rx.c",
  "human_readable_source": "\n \n\n#include \"debug.h\"\n#include \"hal.h\"\n#include \"hal_tx.h\"\n#include \"hal_rx.h\"\n#include \"hal_desc.h\"\n#include \"hif.h\"\n\nstatic void ath12k_hal_reo_set_desc_hdr(struct hal_desc_header *hdr,\n\t\t\t\t\tu8 owner, u8 buffer_type, u32 magic)\n{\n\thdr->info0 = le32_encode_bits(owner, HAL_DESC_HDR_INFO0_OWNER) |\n\t\t     le32_encode_bits(buffer_type, HAL_DESC_HDR_INFO0_BUF_TYPE);\n\n\t \n\thdr->info0 |= le32_encode_bits(magic, HAL_DESC_HDR_INFO0_DBG_RESERVED);\n}\n\nstatic int ath12k_hal_reo_cmd_queue_stats(struct hal_tlv_64_hdr *tlv,\n\t\t\t\t\t  struct ath12k_hal_reo_cmd *cmd)\n{\n\tstruct hal_reo_get_queue_stats *desc;\n\n\ttlv->tl = u32_encode_bits(HAL_REO_GET_QUEUE_STATS, HAL_TLV_HDR_TAG) |\n\t\t  u32_encode_bits(sizeof(*desc), HAL_TLV_HDR_LEN);\n\n\tdesc = (struct hal_reo_get_queue_stats *)tlv->value;\n\tmemset_startat(desc, 0, queue_addr_lo);\n\n\tdesc->cmd.info0 &= ~cpu_to_le32(HAL_REO_CMD_HDR_INFO0_STATUS_REQUIRED);\n\tif (cmd->flag & HAL_REO_CMD_FLG_NEED_STATUS)\n\t\tdesc->cmd.info0 |= cpu_to_le32(HAL_REO_CMD_HDR_INFO0_STATUS_REQUIRED);\n\n\tdesc->queue_addr_lo = cpu_to_le32(cmd->addr_lo);\n\tdesc->info0 = le32_encode_bits(cmd->addr_hi,\n\t\t\t\t       HAL_REO_GET_QUEUE_STATS_INFO0_QUEUE_ADDR_HI);\n\tif (cmd->flag & HAL_REO_CMD_FLG_STATS_CLEAR)\n\t\tdesc->info0 |= cpu_to_le32(HAL_REO_GET_QUEUE_STATS_INFO0_CLEAR_STATS);\n\n\treturn le32_get_bits(desc->cmd.info0, HAL_REO_CMD_HDR_INFO0_CMD_NUMBER);\n}\n\nstatic int ath12k_hal_reo_cmd_flush_cache(struct ath12k_hal *hal,\n\t\t\t\t\t  struct hal_tlv_64_hdr *tlv,\n\t\t\t\t\t  struct ath12k_hal_reo_cmd *cmd)\n{\n\tstruct hal_reo_flush_cache *desc;\n\tu8 avail_slot = ffz(hal->avail_blk_resource);\n\n\tif (cmd->flag & HAL_REO_CMD_FLG_FLUSH_BLOCK_LATER) {\n\t\tif (avail_slot >= HAL_MAX_AVAIL_BLK_RES)\n\t\t\treturn -ENOSPC;\n\n\t\thal->current_blk_index = avail_slot;\n\t}\n\n\ttlv->tl = u32_encode_bits(HAL_REO_FLUSH_CACHE, HAL_TLV_HDR_TAG) |\n\t\t  u32_encode_bits(sizeof(*desc), HAL_TLV_HDR_LEN);\n\n\tdesc = (struct hal_reo_flush_cache *)tlv->value;\n\tmemset_startat(desc, 0, cache_addr_lo);\n\n\tdesc->cmd.info0 &= ~cpu_to_le32(HAL_REO_CMD_HDR_INFO0_STATUS_REQUIRED);\n\tif (cmd->flag & HAL_REO_CMD_FLG_NEED_STATUS)\n\t\tdesc->cmd.info0 |= cpu_to_le32(HAL_REO_CMD_HDR_INFO0_STATUS_REQUIRED);\n\n\tdesc->cache_addr_lo = cpu_to_le32(cmd->addr_lo);\n\tdesc->info0 = le32_encode_bits(cmd->addr_hi,\n\t\t\t\t       HAL_REO_FLUSH_CACHE_INFO0_CACHE_ADDR_HI);\n\n\tif (cmd->flag & HAL_REO_CMD_FLG_FLUSH_FWD_ALL_MPDUS)\n\t\tdesc->info0 |= cpu_to_le32(HAL_REO_FLUSH_CACHE_INFO0_FWD_ALL_MPDUS);\n\n\tif (cmd->flag & HAL_REO_CMD_FLG_FLUSH_BLOCK_LATER) {\n\t\tdesc->info0 |= cpu_to_le32(HAL_REO_FLUSH_CACHE_INFO0_BLOCK_CACHE_USAGE);\n\t\tdesc->info0 |=\n\t\t\tle32_encode_bits(avail_slot,\n\t\t\t\t\t HAL_REO_FLUSH_CACHE_INFO0_BLOCK_RESRC_IDX);\n\t}\n\n\tif (cmd->flag & HAL_REO_CMD_FLG_FLUSH_NO_INVAL)\n\t\tdesc->info0 |= cpu_to_le32(HAL_REO_FLUSH_CACHE_INFO0_FLUSH_WO_INVALIDATE);\n\n\tif (cmd->flag & HAL_REO_CMD_FLG_FLUSH_ALL)\n\t\tdesc->info0 |= cpu_to_le32(HAL_REO_FLUSH_CACHE_INFO0_FLUSH_ALL);\n\n\treturn le32_get_bits(desc->cmd.info0, HAL_REO_CMD_HDR_INFO0_CMD_NUMBER);\n}\n\nstatic int ath12k_hal_reo_cmd_update_rx_queue(struct hal_tlv_64_hdr *tlv,\n\t\t\t\t\t      struct ath12k_hal_reo_cmd *cmd)\n{\n\tstruct hal_reo_update_rx_queue *desc;\n\n\ttlv->tl = u32_encode_bits(HAL_REO_UPDATE_RX_REO_QUEUE, HAL_TLV_HDR_TAG) |\n\t\t  u32_encode_bits(sizeof(*desc), HAL_TLV_HDR_LEN);\n\n\tdesc = (struct hal_reo_update_rx_queue *)tlv->value;\n\tmemset_startat(desc, 0, queue_addr_lo);\n\n\tdesc->cmd.info0 &= ~cpu_to_le32(HAL_REO_CMD_HDR_INFO0_STATUS_REQUIRED);\n\tif (cmd->flag & HAL_REO_CMD_FLG_NEED_STATUS)\n\t\tdesc->cmd.info0 |= cpu_to_le32(HAL_REO_CMD_HDR_INFO0_STATUS_REQUIRED);\n\n\tdesc->queue_addr_lo = cpu_to_le32(cmd->addr_lo);\n\tdesc->info0 =\n\t\tle32_encode_bits(cmd->addr_hi,\n\t\t\t\t HAL_REO_UPD_RX_QUEUE_INFO0_QUEUE_ADDR_HI) |\n\t\tle32_encode_bits(!!(cmd->upd0 & HAL_REO_CMD_UPD0_RX_QUEUE_NUM),\n\t\t\t\t HAL_REO_UPD_RX_QUEUE_INFO0_UPD_RX_QUEUE_NUM) |\n\t\tle32_encode_bits(!!(cmd->upd0 & HAL_REO_CMD_UPD0_VLD),\n\t\t\t\t HAL_REO_UPD_RX_QUEUE_INFO0_UPD_VLD) |\n\t\tle32_encode_bits(!!(cmd->upd0 & HAL_REO_CMD_UPD0_ALDC),\n\t\t\t\t HAL_REO_UPD_RX_QUEUE_INFO0_UPD_ASSOC_LNK_DESC_CNT) |\n\t\tle32_encode_bits(!!(cmd->upd0 & HAL_REO_CMD_UPD0_DIS_DUP_DETECTION),\n\t\t\t\t HAL_REO_UPD_RX_QUEUE_INFO0_UPD_DIS_DUP_DETECTION) |\n\t\tle32_encode_bits(!!(cmd->upd0 & HAL_REO_CMD_UPD0_SOFT_REORDER_EN),\n\t\t\t\t HAL_REO_UPD_RX_QUEUE_INFO0_UPD_SOFT_REORDER_EN) |\n\t\tle32_encode_bits(!!(cmd->upd0 & HAL_REO_CMD_UPD0_AC),\n\t\t\t\t HAL_REO_UPD_RX_QUEUE_INFO0_UPD_AC) |\n\t\tle32_encode_bits(!!(cmd->upd0 & HAL_REO_CMD_UPD0_BAR),\n\t\t\t\t HAL_REO_UPD_RX_QUEUE_INFO0_UPD_BAR) |\n\t\tle32_encode_bits(!!(cmd->upd0 & HAL_REO_CMD_UPD0_RETRY),\n\t\t\t\t HAL_REO_UPD_RX_QUEUE_INFO0_UPD_RETRY) |\n\t\tle32_encode_bits(!!(cmd->upd0 & HAL_REO_CMD_UPD0_CHECK_2K_MODE),\n\t\t\t\t HAL_REO_UPD_RX_QUEUE_INFO0_UPD_CHECK_2K_MODE) |\n\t\tle32_encode_bits(!!(cmd->upd0 & HAL_REO_CMD_UPD0_OOR_MODE),\n\t\t\t\t HAL_REO_UPD_RX_QUEUE_INFO0_UPD_OOR_MODE) |\n\t\tle32_encode_bits(!!(cmd->upd0 & HAL_REO_CMD_UPD0_BA_WINDOW_SIZE),\n\t\t\t\t HAL_REO_UPD_RX_QUEUE_INFO0_UPD_BA_WINDOW_SIZE) |\n\t\tle32_encode_bits(!!(cmd->upd0 & HAL_REO_CMD_UPD0_PN_CHECK),\n\t\t\t\t HAL_REO_UPD_RX_QUEUE_INFO0_UPD_PN_CHECK) |\n\t\tle32_encode_bits(!!(cmd->upd0 & HAL_REO_CMD_UPD0_EVEN_PN),\n\t\t\t\t HAL_REO_UPD_RX_QUEUE_INFO0_UPD_EVEN_PN) |\n\t\tle32_encode_bits(!!(cmd->upd0 & HAL_REO_CMD_UPD0_UNEVEN_PN),\n\t\t\t\t HAL_REO_UPD_RX_QUEUE_INFO0_UPD_UNEVEN_PN) |\n\t\tle32_encode_bits(!!(cmd->upd0 & HAL_REO_CMD_UPD0_PN_HANDLE_ENABLE),\n\t\t\t\t HAL_REO_UPD_RX_QUEUE_INFO0_UPD_PN_HANDLE_ENABLE) |\n\t\tle32_encode_bits(!!(cmd->upd0 & HAL_REO_CMD_UPD0_PN_SIZE),\n\t\t\t\t HAL_REO_UPD_RX_QUEUE_INFO0_UPD_PN_SIZE) |\n\t\tle32_encode_bits(!!(cmd->upd0 & HAL_REO_CMD_UPD0_IGNORE_AMPDU_FLG),\n\t\t\t\t HAL_REO_UPD_RX_QUEUE_INFO0_UPD_IGNORE_AMPDU_FLG) |\n\t\tle32_encode_bits(!!(cmd->upd0 & HAL_REO_CMD_UPD0_SVLD),\n\t\t\t\t HAL_REO_UPD_RX_QUEUE_INFO0_UPD_SVLD) |\n\t\tle32_encode_bits(!!(cmd->upd0 & HAL_REO_CMD_UPD0_SSN),\n\t\t\t\t HAL_REO_UPD_RX_QUEUE_INFO0_UPD_SSN) |\n\t\tle32_encode_bits(!!(cmd->upd0 & HAL_REO_CMD_UPD0_SEQ_2K_ERR),\n\t\t\t\t HAL_REO_UPD_RX_QUEUE_INFO0_UPD_SEQ_2K_ERR) |\n\t\tle32_encode_bits(!!(cmd->upd0 & HAL_REO_CMD_UPD0_PN_VALID),\n\t\t\t\t HAL_REO_UPD_RX_QUEUE_INFO0_UPD_PN_VALID) |\n\t\tle32_encode_bits(!!(cmd->upd0 & HAL_REO_CMD_UPD0_PN),\n\t\t\t\t HAL_REO_UPD_RX_QUEUE_INFO0_UPD_PN);\n\n\tdesc->info1 =\n\t\tle32_encode_bits(cmd->rx_queue_num,\n\t\t\t\t HAL_REO_UPD_RX_QUEUE_INFO1_RX_QUEUE_NUMBER) |\n\t\tle32_encode_bits(!!(cmd->upd1 & HAL_REO_CMD_UPD1_VLD),\n\t\t\t\t HAL_REO_UPD_RX_QUEUE_INFO1_VLD) |\n\t\tle32_encode_bits(u32_get_bits(cmd->upd1, HAL_REO_CMD_UPD1_ALDC),\n\t\t\t\t HAL_REO_UPD_RX_QUEUE_INFO1_ASSOC_LNK_DESC_COUNTER) |\n\t\tle32_encode_bits(!!(cmd->upd1 & HAL_REO_CMD_UPD1_DIS_DUP_DETECTION),\n\t\t\t\t HAL_REO_UPD_RX_QUEUE_INFO1_DIS_DUP_DETECTION) |\n\t\tle32_encode_bits(!!(cmd->upd1 & HAL_REO_CMD_UPD1_SOFT_REORDER_EN),\n\t\t\t\t HAL_REO_UPD_RX_QUEUE_INFO1_SOFT_REORDER_EN) |\n\t\tle32_encode_bits(u32_get_bits(cmd->upd1, HAL_REO_CMD_UPD1_AC),\n\t\t\t\t HAL_REO_UPD_RX_QUEUE_INFO1_AC) |\n\t\tle32_encode_bits(!!(cmd->upd1 & HAL_REO_CMD_UPD1_BAR),\n\t\t\t\t HAL_REO_UPD_RX_QUEUE_INFO1_BAR) |\n\t\tle32_encode_bits(!!(cmd->upd1 & HAL_REO_CMD_UPD1_CHECK_2K_MODE),\n\t\t\t\t HAL_REO_UPD_RX_QUEUE_INFO1_CHECK_2K_MODE) |\n\t\tle32_encode_bits(!!(cmd->upd1 & HAL_REO_CMD_UPD1_RETRY),\n\t\t\t\t HAL_REO_UPD_RX_QUEUE_INFO1_RETRY) |\n\t\tle32_encode_bits(!!(cmd->upd1 & HAL_REO_CMD_UPD1_OOR_MODE),\n\t\t\t\t HAL_REO_UPD_RX_QUEUE_INFO1_OOR_MODE) |\n\t\tle32_encode_bits(!!(cmd->upd1 & HAL_REO_CMD_UPD1_PN_CHECK),\n\t\t\t\t HAL_REO_UPD_RX_QUEUE_INFO1_PN_CHECK) |\n\t\tle32_encode_bits(!!(cmd->upd1 & HAL_REO_CMD_UPD1_EVEN_PN),\n\t\t\t\t HAL_REO_UPD_RX_QUEUE_INFO1_EVEN_PN) |\n\t\tle32_encode_bits(!!(cmd->upd1 & HAL_REO_CMD_UPD1_UNEVEN_PN),\n\t\t\t\t HAL_REO_UPD_RX_QUEUE_INFO1_UNEVEN_PN) |\n\t\tle32_encode_bits(!!(cmd->upd1 & HAL_REO_CMD_UPD1_PN_HANDLE_ENABLE),\n\t\t\t\t HAL_REO_UPD_RX_QUEUE_INFO1_PN_HANDLE_ENABLE) |\n\t\tle32_encode_bits(!!(cmd->upd1 & HAL_REO_CMD_UPD1_IGNORE_AMPDU_FLG),\n\t\t\t\t HAL_REO_UPD_RX_QUEUE_INFO1_IGNORE_AMPDU_FLG);\n\n\tif (cmd->pn_size == 24)\n\t\tcmd->pn_size = HAL_RX_REO_QUEUE_PN_SIZE_24;\n\telse if (cmd->pn_size == 48)\n\t\tcmd->pn_size = HAL_RX_REO_QUEUE_PN_SIZE_48;\n\telse if (cmd->pn_size == 128)\n\t\tcmd->pn_size = HAL_RX_REO_QUEUE_PN_SIZE_128;\n\n\tif (cmd->ba_window_size < 1)\n\t\tcmd->ba_window_size = 1;\n\n\tif (cmd->ba_window_size == 1)\n\t\tcmd->ba_window_size++;\n\n\tdesc->info2 =\n\t\tle32_encode_bits(cmd->ba_window_size - 1,\n\t\t\t\t HAL_REO_UPD_RX_QUEUE_INFO2_BA_WINDOW_SIZE) |\n\t\tle32_encode_bits(cmd->pn_size, HAL_REO_UPD_RX_QUEUE_INFO2_PN_SIZE) |\n\t\tle32_encode_bits(!!(cmd->upd2 & HAL_REO_CMD_UPD2_SVLD),\n\t\t\t\t HAL_REO_UPD_RX_QUEUE_INFO2_SVLD) |\n\t\tle32_encode_bits(u32_get_bits(cmd->upd2, HAL_REO_CMD_UPD2_SSN),\n\t\t\t\t HAL_REO_UPD_RX_QUEUE_INFO2_SSN) |\n\t\tle32_encode_bits(!!(cmd->upd2 & HAL_REO_CMD_UPD2_SEQ_2K_ERR),\n\t\t\t\t HAL_REO_UPD_RX_QUEUE_INFO2_SEQ_2K_ERR) |\n\t\tle32_encode_bits(!!(cmd->upd2 & HAL_REO_CMD_UPD2_PN_ERR),\n\t\t\t\t HAL_REO_UPD_RX_QUEUE_INFO2_PN_ERR);\n\n\treturn le32_get_bits(desc->cmd.info0, HAL_REO_CMD_HDR_INFO0_CMD_NUMBER);\n}\n\nint ath12k_hal_reo_cmd_send(struct ath12k_base *ab, struct hal_srng *srng,\n\t\t\t    enum hal_reo_cmd_type type,\n\t\t\t    struct ath12k_hal_reo_cmd *cmd)\n{\n\tstruct hal_tlv_64_hdr *reo_desc;\n\tint ret;\n\n\tspin_lock_bh(&srng->lock);\n\n\tath12k_hal_srng_access_begin(ab, srng);\n\treo_desc = ath12k_hal_srng_src_get_next_entry(ab, srng);\n\tif (!reo_desc) {\n\t\tret = -ENOBUFS;\n\t\tgoto out;\n\t}\n\n\tswitch (type) {\n\tcase HAL_REO_CMD_GET_QUEUE_STATS:\n\t\tret = ath12k_hal_reo_cmd_queue_stats(reo_desc, cmd);\n\t\tbreak;\n\tcase HAL_REO_CMD_FLUSH_CACHE:\n\t\tret = ath12k_hal_reo_cmd_flush_cache(&ab->hal, reo_desc, cmd);\n\t\tbreak;\n\tcase HAL_REO_CMD_UPDATE_RX_QUEUE:\n\t\tret = ath12k_hal_reo_cmd_update_rx_queue(reo_desc, cmd);\n\t\tbreak;\n\tcase HAL_REO_CMD_FLUSH_QUEUE:\n\tcase HAL_REO_CMD_UNBLOCK_CACHE:\n\tcase HAL_REO_CMD_FLUSH_TIMEOUT_LIST:\n\t\tath12k_warn(ab, \"Unsupported reo command %d\\n\", type);\n\t\tret = -ENOTSUPP;\n\t\tbreak;\n\tdefault:\n\t\tath12k_warn(ab, \"Unknown reo command %d\\n\", type);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\nout:\n\tath12k_hal_srng_access_end(ab, srng);\n\tspin_unlock_bh(&srng->lock);\n\n\treturn ret;\n}\n\nvoid ath12k_hal_rx_buf_addr_info_set(struct ath12k_buffer_addr *binfo,\n\t\t\t\t     dma_addr_t paddr, u32 cookie, u8 manager)\n{\n\tu32 paddr_lo, paddr_hi;\n\n\tpaddr_lo = lower_32_bits(paddr);\n\tpaddr_hi = upper_32_bits(paddr);\n\tbinfo->info0 = le32_encode_bits(paddr_lo, BUFFER_ADDR_INFO0_ADDR);\n\tbinfo->info1 = le32_encode_bits(paddr_hi, BUFFER_ADDR_INFO1_ADDR) |\n\t\t       le32_encode_bits(cookie, BUFFER_ADDR_INFO1_SW_COOKIE) |\n\t\t       le32_encode_bits(manager, BUFFER_ADDR_INFO1_RET_BUF_MGR);\n}\n\nvoid ath12k_hal_rx_buf_addr_info_get(struct ath12k_buffer_addr *binfo,\n\t\t\t\t     dma_addr_t *paddr,\n\t\t\t\t     u32 *cookie, u8 *rbm)\n{\n\t*paddr = (((u64)le32_get_bits(binfo->info1, BUFFER_ADDR_INFO1_ADDR)) << 32) |\n\t\tle32_get_bits(binfo->info0, BUFFER_ADDR_INFO0_ADDR);\n\t*cookie = le32_get_bits(binfo->info1, BUFFER_ADDR_INFO1_SW_COOKIE);\n\t*rbm = le32_get_bits(binfo->info1, BUFFER_ADDR_INFO1_RET_BUF_MGR);\n}\n\nvoid ath12k_hal_rx_msdu_link_info_get(struct hal_rx_msdu_link *link, u32 *num_msdus,\n\t\t\t\t      u32 *msdu_cookies,\n\t\t\t\t      enum hal_rx_buf_return_buf_manager *rbm)\n{\n\tstruct hal_rx_msdu_details *msdu;\n\tu32 val;\n\tint i;\n\n\t*num_msdus = HAL_NUM_RX_MSDUS_PER_LINK_DESC;\n\n\tmsdu = &link->msdu_link[0];\n\t*rbm = le32_get_bits(msdu->buf_addr_info.info1,\n\t\t\t     BUFFER_ADDR_INFO1_RET_BUF_MGR);\n\n\tfor (i = 0; i < *num_msdus; i++) {\n\t\tmsdu = &link->msdu_link[i];\n\n\t\tval = le32_get_bits(msdu->buf_addr_info.info0,\n\t\t\t\t    BUFFER_ADDR_INFO0_ADDR);\n\t\tif (val == 0) {\n\t\t\t*num_msdus = i;\n\t\t\tbreak;\n\t\t}\n\t\t*msdu_cookies = le32_get_bits(msdu->buf_addr_info.info1,\n\t\t\t\t\t      BUFFER_ADDR_INFO1_SW_COOKIE);\n\t\tmsdu_cookies++;\n\t}\n}\n\nint ath12k_hal_desc_reo_parse_err(struct ath12k_base *ab,\n\t\t\t\t  struct hal_reo_dest_ring *desc,\n\t\t\t\t  dma_addr_t *paddr, u32 *desc_bank)\n{\n\tenum hal_reo_dest_ring_push_reason push_reason;\n\tenum hal_reo_dest_ring_error_code err_code;\n\tu32 cookie, val;\n\n\tpush_reason = le32_get_bits(desc->info0,\n\t\t\t\t    HAL_REO_DEST_RING_INFO0_PUSH_REASON);\n\terr_code = le32_get_bits(desc->info0,\n\t\t\t\t HAL_REO_DEST_RING_INFO0_ERROR_CODE);\n\tab->soc_stats.reo_error[err_code]++;\n\n\tif (push_reason != HAL_REO_DEST_RING_PUSH_REASON_ERR_DETECTED &&\n\t    push_reason != HAL_REO_DEST_RING_PUSH_REASON_ROUTING_INSTRUCTION) {\n\t\tath12k_warn(ab, \"expected error push reason code, received %d\\n\",\n\t\t\t    push_reason);\n\t\treturn -EINVAL;\n\t}\n\n\tval = le32_get_bits(desc->info0, HAL_REO_DEST_RING_INFO0_BUFFER_TYPE);\n\tif (val != HAL_REO_DEST_RING_BUFFER_TYPE_LINK_DESC) {\n\t\tath12k_warn(ab, \"expected buffer type link_desc\");\n\t\treturn -EINVAL;\n\t}\n\n\tath12k_hal_rx_reo_ent_paddr_get(ab, &desc->buf_addr_info, paddr, &cookie);\n\t*desc_bank = u32_get_bits(cookie, DP_LINK_DESC_BANK_MASK);\n\n\treturn 0;\n}\n\nint ath12k_hal_wbm_desc_parse_err(struct ath12k_base *ab, void *desc,\n\t\t\t\t  struct hal_rx_wbm_rel_info *rel_info)\n{\n\tstruct hal_wbm_release_ring *wbm_desc = desc;\n\tstruct hal_wbm_release_ring_cc_rx *wbm_cc_desc = desc;\n\tenum hal_wbm_rel_desc_type type;\n\tenum hal_wbm_rel_src_module rel_src;\n\tbool hw_cc_done;\n\tu64 desc_va;\n\tu32 val;\n\n\ttype = le32_get_bits(wbm_desc->info0, HAL_WBM_RELEASE_INFO0_DESC_TYPE);\n\t \n\tif (type != HAL_WBM_REL_DESC_TYPE_REL_MSDU) {\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\trel_src = le32_get_bits(wbm_desc->info0,\n\t\t\t\tHAL_WBM_RELEASE_INFO0_REL_SRC_MODULE);\n\tif (rel_src != HAL_WBM_REL_SRC_MODULE_RXDMA &&\n\t    rel_src != HAL_WBM_REL_SRC_MODULE_REO)\n\t\treturn -EINVAL;\n\n\t \n\thw_cc_done = le32_get_bits(wbm_desc->info0,\n\t\t\t\t   HAL_WBM_RELEASE_RX_INFO0_CC_STATUS);\n\n\tif (!hw_cc_done) {\n\t\tval = le32_get_bits(wbm_desc->buf_addr_info.info1,\n\t\t\t\t    BUFFER_ADDR_INFO1_RET_BUF_MGR);\n\t\tif (val != HAL_RX_BUF_RBM_SW3_BM) {\n\t\t\tab->soc_stats.invalid_rbm++;\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\trel_info->cookie = le32_get_bits(wbm_desc->buf_addr_info.info1,\n\t\t\t\t\t\t BUFFER_ADDR_INFO1_SW_COOKIE);\n\n\t\trel_info->rx_desc = NULL;\n\t} else {\n\t\tval = le32_get_bits(wbm_cc_desc->info0,\n\t\t\t\t    HAL_WBM_RELEASE_RX_CC_INFO0_RBM);\n\t\tif (val != HAL_RX_BUF_RBM_SW3_BM) {\n\t\t\tab->soc_stats.invalid_rbm++;\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\trel_info->cookie = le32_get_bits(wbm_cc_desc->info1,\n\t\t\t\t\t\t HAL_WBM_RELEASE_RX_CC_INFO1_COOKIE);\n\n\t\tdesc_va = ((u64)le32_to_cpu(wbm_cc_desc->buf_va_hi) << 32 |\n\t\t\t   le32_to_cpu(wbm_cc_desc->buf_va_lo));\n\t\trel_info->rx_desc =\n\t\t\t(struct ath12k_rx_desc_info *)((unsigned long)desc_va);\n\t}\n\n\trel_info->err_rel_src = rel_src;\n\trel_info->hw_cc_done = hw_cc_done;\n\n\trel_info->first_msdu = le32_get_bits(wbm_desc->info3,\n\t\t\t\t\t     HAL_WBM_RELEASE_INFO3_FIRST_MSDU);\n\trel_info->last_msdu = le32_get_bits(wbm_desc->info3,\n\t\t\t\t\t    HAL_WBM_RELEASE_INFO3_LAST_MSDU);\n\trel_info->continuation = le32_get_bits(wbm_desc->info3,\n\t\t\t\t\t       HAL_WBM_RELEASE_INFO3_CONTINUATION);\n\n\tif (rel_info->err_rel_src == HAL_WBM_REL_SRC_MODULE_REO) {\n\t\trel_info->push_reason =\n\t\t\tle32_get_bits(wbm_desc->info0,\n\t\t\t\t      HAL_WBM_RELEASE_INFO0_REO_PUSH_REASON);\n\t\trel_info->err_code =\n\t\t\tle32_get_bits(wbm_desc->info0,\n\t\t\t\t      HAL_WBM_RELEASE_INFO0_REO_ERROR_CODE);\n\t} else {\n\t\trel_info->push_reason =\n\t\t\tle32_get_bits(wbm_desc->info0,\n\t\t\t\t      HAL_WBM_RELEASE_INFO0_RXDMA_PUSH_REASON);\n\t\trel_info->err_code =\n\t\t\tle32_get_bits(wbm_desc->info0,\n\t\t\t\t      HAL_WBM_RELEASE_INFO0_RXDMA_ERROR_CODE);\n\t}\n\n\treturn 0;\n}\n\nvoid ath12k_hal_rx_reo_ent_paddr_get(struct ath12k_base *ab,\n\t\t\t\t     struct ath12k_buffer_addr *buff_addr,\n\t\t\t\t     dma_addr_t *paddr, u32 *cookie)\n{\n\t*paddr = ((u64)(le32_get_bits(buff_addr->info1,\n\t\t\t\t      BUFFER_ADDR_INFO1_ADDR)) << 32) |\n\t\tle32_get_bits(buff_addr->info0, BUFFER_ADDR_INFO0_ADDR);\n\n\t*cookie = le32_get_bits(buff_addr->info1, BUFFER_ADDR_INFO1_SW_COOKIE);\n}\n\nvoid ath12k_hal_rx_msdu_link_desc_set(struct ath12k_base *ab,\n\t\t\t\t      struct hal_wbm_release_ring *dst_desc,\n\t\t\t\t      struct hal_wbm_release_ring *src_desc,\n\t\t\t\t      enum hal_wbm_rel_bm_act action)\n{\n\tdst_desc->buf_addr_info = src_desc->buf_addr_info;\n\tdst_desc->info0 |= le32_encode_bits(HAL_WBM_REL_SRC_MODULE_SW,\n\t\t\t\t\t    HAL_WBM_RELEASE_INFO0_REL_SRC_MODULE) |\n\t\t\t   le32_encode_bits(action, HAL_WBM_RELEASE_INFO0_BM_ACTION) |\n\t\t\t   le32_encode_bits(HAL_WBM_REL_DESC_TYPE_MSDU_LINK,\n\t\t\t\t\t    HAL_WBM_RELEASE_INFO0_DESC_TYPE);\n}\n\nvoid ath12k_hal_reo_status_queue_stats(struct ath12k_base *ab, struct hal_tlv_64_hdr *tlv,\n\t\t\t\t       struct hal_reo_status *status)\n{\n\tstruct hal_reo_get_queue_stats_status *desc =\n\t\t(struct hal_reo_get_queue_stats_status *)tlv->value;\n\n\tstatus->uniform_hdr.cmd_num =\n\t\t\t\tle32_get_bits(desc->hdr.info0,\n\t\t\t\t\t      HAL_REO_STATUS_HDR_INFO0_STATUS_NUM);\n\tstatus->uniform_hdr.cmd_status =\n\t\t\t\tle32_get_bits(desc->hdr.info0,\n\t\t\t\t\t      HAL_REO_STATUS_HDR_INFO0_EXEC_STATUS);\n\n\tath12k_dbg(ab, ATH12K_DBG_HAL, \"Queue stats status:\\n\");\n\tath12k_dbg(ab, ATH12K_DBG_HAL, \"header: cmd_num %d status %d\\n\",\n\t\t   status->uniform_hdr.cmd_num,\n\t\t   status->uniform_hdr.cmd_status);\n\tath12k_dbg(ab, ATH12K_DBG_HAL, \"ssn %u cur_idx %u\\n\",\n\t\t   le32_get_bits(desc->info0,\n\t\t\t\t HAL_REO_GET_QUEUE_STATS_STATUS_INFO0_SSN),\n\t\t   le32_get_bits(desc->info0,\n\t\t\t\t HAL_REO_GET_QUEUE_STATS_STATUS_INFO0_CUR_IDX));\n\tath12k_dbg(ab, ATH12K_DBG_HAL, \"pn = [%08x, %08x, %08x, %08x]\\n\",\n\t\t   desc->pn[0], desc->pn[1], desc->pn[2], desc->pn[3]);\n\tath12k_dbg(ab, ATH12K_DBG_HAL, \"last_rx: enqueue_tstamp %08x dequeue_tstamp %08x\\n\",\n\t\t   desc->last_rx_enqueue_timestamp,\n\t\t   desc->last_rx_dequeue_timestamp);\n\tath12k_dbg(ab, ATH12K_DBG_HAL, \"rx_bitmap [%08x %08x %08x %08x %08x %08x %08x %08x]\\n\",\n\t\t   desc->rx_bitmap[0], desc->rx_bitmap[1], desc->rx_bitmap[2],\n\t\t   desc->rx_bitmap[3], desc->rx_bitmap[4], desc->rx_bitmap[5],\n\t\t   desc->rx_bitmap[6], desc->rx_bitmap[7]);\n\tath12k_dbg(ab, ATH12K_DBG_HAL, \"count: cur_mpdu %u cur_msdu %u\\n\",\n\t\t   le32_get_bits(desc->info1,\n\t\t\t\t HAL_REO_GET_QUEUE_STATS_STATUS_INFO1_MPDU_COUNT),\n\t\t   le32_get_bits(desc->info1,\n\t\t\t\t HAL_REO_GET_QUEUE_STATS_STATUS_INFO1_MSDU_COUNT));\n\tath12k_dbg(ab, ATH12K_DBG_HAL, \"fwd_timeout %u fwd_bar %u dup_count %u\\n\",\n\t\t   le32_get_bits(desc->info2,\n\t\t\t\t HAL_REO_GET_QUEUE_STATS_STATUS_INFO2_TIMEOUT_COUNT),\n\t\t   le32_get_bits(desc->info2,\n\t\t\t\t HAL_REO_GET_QUEUE_STATS_STATUS_INFO2_FDTB_COUNT),\n\t\t   le32_get_bits(desc->info2,\n\t\t\t\t HAL_REO_GET_QUEUE_STATS_STATUS_INFO2_DUPLICATE_COUNT));\n\tath12k_dbg(ab, ATH12K_DBG_HAL, \"frames_in_order %u bar_rcvd %u\\n\",\n\t\t   le32_get_bits(desc->info3,\n\t\t\t\t HAL_REO_GET_QUEUE_STATS_STATUS_INFO3_FIO_COUNT),\n\t\t   le32_get_bits(desc->info3,\n\t\t\t\t HAL_REO_GET_QUEUE_STATS_STATUS_INFO3_BAR_RCVD_CNT));\n\tath12k_dbg(ab, ATH12K_DBG_HAL, \"num_mpdus %d num_msdus %d total_bytes %d\\n\",\n\t\t   desc->num_mpdu_frames, desc->num_msdu_frames,\n\t\t   desc->total_bytes);\n\tath12k_dbg(ab, ATH12K_DBG_HAL, \"late_rcvd %u win_jump_2k %u hole_cnt %u\\n\",\n\t\t   le32_get_bits(desc->info4,\n\t\t\t\t HAL_REO_GET_QUEUE_STATS_STATUS_INFO4_LATE_RX_MPDU),\n\t\t   le32_get_bits(desc->info2,\n\t\t\t\t HAL_REO_GET_QUEUE_STATS_STATUS_INFO2_WINDOW_JMP2K),\n\t\t   le32_get_bits(desc->info4,\n\t\t\t\t HAL_REO_GET_QUEUE_STATS_STATUS_INFO4_HOLE_COUNT));\n\tath12k_dbg(ab, ATH12K_DBG_HAL, \"looping count %u\\n\",\n\t\t   le32_get_bits(desc->info5,\n\t\t\t\t HAL_REO_GET_QUEUE_STATS_STATUS_INFO5_LOOPING_CNT));\n}\n\nvoid ath12k_hal_reo_flush_queue_status(struct ath12k_base *ab, struct hal_tlv_64_hdr *tlv,\n\t\t\t\t       struct hal_reo_status *status)\n{\n\tstruct hal_reo_flush_queue_status *desc =\n\t\t(struct hal_reo_flush_queue_status *)tlv->value;\n\n\tstatus->uniform_hdr.cmd_num =\n\t\t\tle32_get_bits(desc->hdr.info0,\n\t\t\t\t      HAL_REO_STATUS_HDR_INFO0_STATUS_NUM);\n\tstatus->uniform_hdr.cmd_status =\n\t\t\tle32_get_bits(desc->hdr.info0,\n\t\t\t\t      HAL_REO_STATUS_HDR_INFO0_EXEC_STATUS);\n\tstatus->u.flush_queue.err_detected =\n\t\t\tle32_get_bits(desc->info0,\n\t\t\t\t      HAL_REO_FLUSH_QUEUE_INFO0_ERR_DETECTED);\n}\n\nvoid ath12k_hal_reo_flush_cache_status(struct ath12k_base *ab, struct hal_tlv_64_hdr *tlv,\n\t\t\t\t       struct hal_reo_status *status)\n{\n\tstruct ath12k_hal *hal = &ab->hal;\n\tstruct hal_reo_flush_cache_status *desc =\n\t\t(struct hal_reo_flush_cache_status *)tlv->value;\n\n\tstatus->uniform_hdr.cmd_num =\n\t\t\tle32_get_bits(desc->hdr.info0,\n\t\t\t\t      HAL_REO_STATUS_HDR_INFO0_STATUS_NUM);\n\tstatus->uniform_hdr.cmd_status =\n\t\t\tle32_get_bits(desc->hdr.info0,\n\t\t\t\t      HAL_REO_STATUS_HDR_INFO0_EXEC_STATUS);\n\n\tstatus->u.flush_cache.err_detected =\n\t\t\tle32_get_bits(desc->info0,\n\t\t\t\t      HAL_REO_FLUSH_CACHE_STATUS_INFO0_IS_ERR);\n\tstatus->u.flush_cache.err_code =\n\t\tle32_get_bits(desc->info0,\n\t\t\t      HAL_REO_FLUSH_CACHE_STATUS_INFO0_BLOCK_ERR_CODE);\n\tif (!status->u.flush_cache.err_code)\n\t\thal->avail_blk_resource |= BIT(hal->current_blk_index);\n\n\tstatus->u.flush_cache.cache_controller_flush_status_hit =\n\t\tle32_get_bits(desc->info0,\n\t\t\t      HAL_REO_FLUSH_CACHE_STATUS_INFO0_FLUSH_STATUS_HIT);\n\n\tstatus->u.flush_cache.cache_controller_flush_status_desc_type =\n\t\tle32_get_bits(desc->info0,\n\t\t\t      HAL_REO_FLUSH_CACHE_STATUS_INFO0_FLUSH_DESC_TYPE);\n\tstatus->u.flush_cache.cache_controller_flush_status_client_id =\n\t\tle32_get_bits(desc->info0,\n\t\t\t      HAL_REO_FLUSH_CACHE_STATUS_INFO0_FLUSH_CLIENT_ID);\n\tstatus->u.flush_cache.cache_controller_flush_status_err =\n\t\tle32_get_bits(desc->info0,\n\t\t\t      HAL_REO_FLUSH_CACHE_STATUS_INFO0_FLUSH_ERR);\n\tstatus->u.flush_cache.cache_controller_flush_status_cnt =\n\t\tle32_get_bits(desc->info0,\n\t\t\t      HAL_REO_FLUSH_CACHE_STATUS_INFO0_FLUSH_COUNT);\n}\n\nvoid ath12k_hal_reo_unblk_cache_status(struct ath12k_base *ab, struct hal_tlv_64_hdr *tlv,\n\t\t\t\t       struct hal_reo_status *status)\n{\n\tstruct ath12k_hal *hal = &ab->hal;\n\tstruct hal_reo_unblock_cache_status *desc =\n\t\t(struct hal_reo_unblock_cache_status *)tlv->value;\n\n\tstatus->uniform_hdr.cmd_num =\n\t\t\tle32_get_bits(desc->hdr.info0,\n\t\t\t\t      HAL_REO_STATUS_HDR_INFO0_STATUS_NUM);\n\tstatus->uniform_hdr.cmd_status =\n\t\t\tle32_get_bits(desc->hdr.info0,\n\t\t\t\t      HAL_REO_STATUS_HDR_INFO0_EXEC_STATUS);\n\n\tstatus->u.unblock_cache.err_detected =\n\t\t\tle32_get_bits(desc->info0,\n\t\t\t\t      HAL_REO_UNBLOCK_CACHE_STATUS_INFO0_IS_ERR);\n\tstatus->u.unblock_cache.unblock_type =\n\t\t\tle32_get_bits(desc->info0,\n\t\t\t\t      HAL_REO_UNBLOCK_CACHE_STATUS_INFO0_TYPE);\n\n\tif (!status->u.unblock_cache.err_detected &&\n\t    status->u.unblock_cache.unblock_type ==\n\t    HAL_REO_STATUS_UNBLOCK_BLOCKING_RESOURCE)\n\t\thal->avail_blk_resource &= ~BIT(hal->current_blk_index);\n}\n\nvoid ath12k_hal_reo_flush_timeout_list_status(struct ath12k_base *ab,\n\t\t\t\t\t      struct hal_tlv_64_hdr *tlv,\n\t\t\t\t\t      struct hal_reo_status *status)\n{\n\tstruct hal_reo_flush_timeout_list_status *desc =\n\t\t(struct hal_reo_flush_timeout_list_status *)tlv->value;\n\n\tstatus->uniform_hdr.cmd_num =\n\t\t\tle32_get_bits(desc->hdr.info0,\n\t\t\t\t      HAL_REO_STATUS_HDR_INFO0_STATUS_NUM);\n\tstatus->uniform_hdr.cmd_status =\n\t\t\tle32_get_bits(desc->hdr.info0,\n\t\t\t\t      HAL_REO_STATUS_HDR_INFO0_EXEC_STATUS);\n\n\tstatus->u.timeout_list.err_detected =\n\t\t\tle32_get_bits(desc->info0,\n\t\t\t\t      HAL_REO_FLUSH_TIMEOUT_STATUS_INFO0_IS_ERR);\n\tstatus->u.timeout_list.list_empty =\n\t\t\tle32_get_bits(desc->info0,\n\t\t\t\t      HAL_REO_FLUSH_TIMEOUT_STATUS_INFO0_LIST_EMPTY);\n\n\tstatus->u.timeout_list.release_desc_cnt =\n\t\tle32_get_bits(desc->info1,\n\t\t\t      HAL_REO_FLUSH_TIMEOUT_STATUS_INFO1_REL_DESC_COUNT);\n\tstatus->u.timeout_list.fwd_buf_cnt =\n\t\tle32_get_bits(desc->info0,\n\t\t\t      HAL_REO_FLUSH_TIMEOUT_STATUS_INFO1_FWD_BUF_COUNT);\n}\n\nvoid ath12k_hal_reo_desc_thresh_reached_status(struct ath12k_base *ab,\n\t\t\t\t\t       struct hal_tlv_64_hdr *tlv,\n\t\t\t\t\t       struct hal_reo_status *status)\n{\n\tstruct hal_reo_desc_thresh_reached_status *desc =\n\t\t(struct hal_reo_desc_thresh_reached_status *)tlv->value;\n\n\tstatus->uniform_hdr.cmd_num =\n\t\t\tle32_get_bits(desc->hdr.info0,\n\t\t\t\t      HAL_REO_STATUS_HDR_INFO0_STATUS_NUM);\n\tstatus->uniform_hdr.cmd_status =\n\t\t\tle32_get_bits(desc->hdr.info0,\n\t\t\t\t      HAL_REO_STATUS_HDR_INFO0_EXEC_STATUS);\n\n\tstatus->u.desc_thresh_reached.threshold_idx =\n\t\tle32_get_bits(desc->info0,\n\t\t\t      HAL_REO_DESC_THRESH_STATUS_INFO0_THRESH_INDEX);\n\n\tstatus->u.desc_thresh_reached.link_desc_counter0 =\n\t\tle32_get_bits(desc->info1,\n\t\t\t      HAL_REO_DESC_THRESH_STATUS_INFO1_LINK_DESC_COUNTER0);\n\n\tstatus->u.desc_thresh_reached.link_desc_counter1 =\n\t\tle32_get_bits(desc->info2,\n\t\t\t      HAL_REO_DESC_THRESH_STATUS_INFO2_LINK_DESC_COUNTER1);\n\n\tstatus->u.desc_thresh_reached.link_desc_counter2 =\n\t\tle32_get_bits(desc->info3,\n\t\t\t      HAL_REO_DESC_THRESH_STATUS_INFO3_LINK_DESC_COUNTER2);\n\n\tstatus->u.desc_thresh_reached.link_desc_counter_sum =\n\t\tle32_get_bits(desc->info4,\n\t\t\t      HAL_REO_DESC_THRESH_STATUS_INFO4_LINK_DESC_COUNTER_SUM);\n}\n\nvoid ath12k_hal_reo_update_rx_reo_queue_status(struct ath12k_base *ab,\n\t\t\t\t\t       struct hal_tlv_64_hdr *tlv,\n\t\t\t\t\t       struct hal_reo_status *status)\n{\n\tstruct hal_reo_status_hdr *desc =\n\t\t(struct hal_reo_status_hdr *)tlv->value;\n\n\tstatus->uniform_hdr.cmd_num =\n\t\t\tle32_get_bits(desc->info0,\n\t\t\t\t      HAL_REO_STATUS_HDR_INFO0_STATUS_NUM);\n\tstatus->uniform_hdr.cmd_status =\n\t\t\tle32_get_bits(desc->info0,\n\t\t\t\t      HAL_REO_STATUS_HDR_INFO0_EXEC_STATUS);\n}\n\nu32 ath12k_hal_reo_qdesc_size(u32 ba_window_size, u8 tid)\n{\n\tu32 num_ext_desc;\n\n\tif (ba_window_size <= 1) {\n\t\tif (tid != HAL_DESC_REO_NON_QOS_TID)\n\t\t\tnum_ext_desc = 1;\n\t\telse\n\t\t\tnum_ext_desc = 0;\n\t} else if (ba_window_size <= 105) {\n\t\tnum_ext_desc = 1;\n\t} else if (ba_window_size <= 210) {\n\t\tnum_ext_desc = 2;\n\t} else {\n\t\tnum_ext_desc = 3;\n\t}\n\n\treturn sizeof(struct hal_rx_reo_queue) +\n\t\t(num_ext_desc * sizeof(struct hal_rx_reo_queue_ext));\n}\n\nvoid ath12k_hal_reo_qdesc_setup(struct hal_rx_reo_queue *qdesc,\n\t\t\t\tint tid, u32 ba_window_size,\n\t\t\t\tu32 start_seq, enum hal_pn_type type)\n{\n\tstruct hal_rx_reo_queue_ext *ext_desc;\n\n\tmemset(qdesc, 0, sizeof(*qdesc));\n\n\tath12k_hal_reo_set_desc_hdr(&qdesc->desc_hdr, HAL_DESC_REO_OWNED,\n\t\t\t\t    HAL_DESC_REO_QUEUE_DESC,\n\t\t\t\t    REO_QUEUE_DESC_MAGIC_DEBUG_PATTERN_0);\n\n\tqdesc->rx_queue_num = le32_encode_bits(tid, HAL_RX_REO_QUEUE_RX_QUEUE_NUMBER);\n\n\tqdesc->info0 =\n\t\tle32_encode_bits(1, HAL_RX_REO_QUEUE_INFO0_VLD) |\n\t\tle32_encode_bits(1, HAL_RX_REO_QUEUE_INFO0_ASSOC_LNK_DESC_COUNTER) |\n\t\tle32_encode_bits(ath12k_tid_to_ac(tid), HAL_RX_REO_QUEUE_INFO0_AC);\n\n\tif (ba_window_size < 1)\n\t\tba_window_size = 1;\n\n\tif (ba_window_size == 1 && tid != HAL_DESC_REO_NON_QOS_TID)\n\t\tba_window_size++;\n\n\tif (ba_window_size == 1)\n\t\tqdesc->info0 |= le32_encode_bits(1, HAL_RX_REO_QUEUE_INFO0_RETRY);\n\n\tqdesc->info0 |= le32_encode_bits(ba_window_size - 1,\n\t\t\t\t\t HAL_RX_REO_QUEUE_INFO0_BA_WINDOW_SIZE);\n\tswitch (type) {\n\tcase HAL_PN_TYPE_NONE:\n\tcase HAL_PN_TYPE_WAPI_EVEN:\n\tcase HAL_PN_TYPE_WAPI_UNEVEN:\n\t\tbreak;\n\tcase HAL_PN_TYPE_WPA:\n\t\tqdesc->info0 |=\n\t\t\tle32_encode_bits(1, HAL_RX_REO_QUEUE_INFO0_PN_CHECK) |\n\t\t\tle32_encode_bits(HAL_RX_REO_QUEUE_PN_SIZE_48,\n\t\t\t\t\t HAL_RX_REO_QUEUE_INFO0_PN_SIZE);\n\t\tbreak;\n\t}\n\n\t \n\tqdesc->info0 |= le32_encode_bits(1, HAL_RX_REO_QUEUE_INFO0_IGNORE_AMPDU_FLG);\n\n\tqdesc->info1 |= le32_encode_bits(0, HAL_RX_REO_QUEUE_INFO1_SVLD);\n\n\tif (start_seq <= 0xfff)\n\t\tqdesc->info1 = le32_encode_bits(start_seq,\n\t\t\t\t\t\tHAL_RX_REO_QUEUE_INFO1_SSN);\n\n\tif (tid == HAL_DESC_REO_NON_QOS_TID)\n\t\treturn;\n\n\text_desc = qdesc->ext_desc;\n\n\t \n\tmemset(ext_desc, 0, 3 * sizeof(*ext_desc));\n\tath12k_hal_reo_set_desc_hdr(&ext_desc->desc_hdr, HAL_DESC_REO_OWNED,\n\t\t\t\t    HAL_DESC_REO_QUEUE_EXT_DESC,\n\t\t\t\t    REO_QUEUE_DESC_MAGIC_DEBUG_PATTERN_1);\n\text_desc++;\n\tath12k_hal_reo_set_desc_hdr(&ext_desc->desc_hdr, HAL_DESC_REO_OWNED,\n\t\t\t\t    HAL_DESC_REO_QUEUE_EXT_DESC,\n\t\t\t\t    REO_QUEUE_DESC_MAGIC_DEBUG_PATTERN_2);\n\text_desc++;\n\tath12k_hal_reo_set_desc_hdr(&ext_desc->desc_hdr, HAL_DESC_REO_OWNED,\n\t\t\t\t    HAL_DESC_REO_QUEUE_EXT_DESC,\n\t\t\t\t    REO_QUEUE_DESC_MAGIC_DEBUG_PATTERN_3);\n}\n\nvoid ath12k_hal_reo_init_cmd_ring(struct ath12k_base *ab,\n\t\t\t\t  struct hal_srng *srng)\n{\n\tstruct hal_srng_params params;\n\tstruct hal_tlv_64_hdr *tlv;\n\tstruct hal_reo_get_queue_stats *desc;\n\tint i, cmd_num = 1;\n\tint entry_size;\n\tu8 *entry;\n\n\tmemset(&params, 0, sizeof(params));\n\n\tentry_size = ath12k_hal_srng_get_entrysize(ab, HAL_REO_CMD);\n\tath12k_hal_srng_get_params(ab, srng, &params);\n\tentry = (u8 *)params.ring_base_vaddr;\n\n\tfor (i = 0; i < params.num_entries; i++) {\n\t\ttlv = (struct hal_tlv_64_hdr *)entry;\n\t\tdesc = (struct hal_reo_get_queue_stats *)tlv->value;\n\t\tdesc->cmd.info0 = le32_encode_bits(cmd_num++,\n\t\t\t\t\t\t   HAL_REO_CMD_HDR_INFO0_CMD_NUMBER);\n\t\tentry += entry_size;\n\t}\n}\n\nvoid ath12k_hal_reo_hw_setup(struct ath12k_base *ab, u32 ring_hash_map)\n{\n\tu32 reo_base = HAL_SEQ_WCSS_UMAC_REO_REG;\n\tu32 val;\n\n\tval = ath12k_hif_read32(ab, reo_base + HAL_REO1_GEN_ENABLE);\n\n\tval |= u32_encode_bits(1, HAL_REO1_GEN_ENABLE_AGING_LIST_ENABLE) |\n\t       u32_encode_bits(1, HAL_REO1_GEN_ENABLE_AGING_FLUSH_ENABLE);\n\tath12k_hif_write32(ab, reo_base + HAL_REO1_GEN_ENABLE, val);\n\n\tval = ath12k_hif_read32(ab, reo_base + HAL_REO1_MISC_CTRL_ADDR(ab));\n\n\tval &= ~(HAL_REO1_MISC_CTL_FRAG_DST_RING |\n\t\t HAL_REO1_MISC_CTL_BAR_DST_RING);\n\tval |= u32_encode_bits(HAL_SRNG_RING_ID_REO2SW0,\n\t\t\t       HAL_REO1_MISC_CTL_FRAG_DST_RING);\n\tval |= u32_encode_bits(HAL_SRNG_RING_ID_REO2SW0,\n\t\t\t       HAL_REO1_MISC_CTL_BAR_DST_RING);\n\tath12k_hif_write32(ab, reo_base + HAL_REO1_MISC_CTRL_ADDR(ab), val);\n\n\tath12k_hif_write32(ab, reo_base + HAL_REO1_AGING_THRESH_IX_0(ab),\n\t\t\t   HAL_DEFAULT_BE_BK_VI_REO_TIMEOUT_USEC);\n\tath12k_hif_write32(ab, reo_base + HAL_REO1_AGING_THRESH_IX_1(ab),\n\t\t\t   HAL_DEFAULT_BE_BK_VI_REO_TIMEOUT_USEC);\n\tath12k_hif_write32(ab, reo_base + HAL_REO1_AGING_THRESH_IX_2(ab),\n\t\t\t   HAL_DEFAULT_BE_BK_VI_REO_TIMEOUT_USEC);\n\tath12k_hif_write32(ab, reo_base + HAL_REO1_AGING_THRESH_IX_3(ab),\n\t\t\t   HAL_DEFAULT_VO_REO_TIMEOUT_USEC);\n\n\tath12k_hif_write32(ab, reo_base + HAL_REO1_DEST_RING_CTRL_IX_2,\n\t\t\t   ring_hash_map);\n\tath12k_hif_write32(ab, reo_base + HAL_REO1_DEST_RING_CTRL_IX_3,\n\t\t\t   ring_hash_map);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}