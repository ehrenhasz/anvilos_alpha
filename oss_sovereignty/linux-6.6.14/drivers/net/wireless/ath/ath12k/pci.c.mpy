{
  "module_name": "pci.c",
  "hash_id": "0b1451fcbf2c5efc559874bb706b19a7168c99831990caac84bcf7901f7f6975",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath12k/pci.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/pci.h>\n\n#include \"pci.h\"\n#include \"core.h\"\n#include \"hif.h\"\n#include \"mhi.h\"\n#include \"debug.h\"\n\n#define ATH12K_PCI_BAR_NUM\t\t0\n#define ATH12K_PCI_DMA_MASK\t\t32\n\n#define ATH12K_PCI_IRQ_CE0_OFFSET\t\t3\n\n#define WINDOW_ENABLE_BIT\t\t0x40000000\n#define WINDOW_REG_ADDRESS\t\t0x310c\n#define WINDOW_VALUE_MASK\t\tGENMASK(24, 19)\n#define WINDOW_START\t\t\t0x80000\n#define WINDOW_RANGE_MASK\t\tGENMASK(18, 0)\n#define WINDOW_STATIC_MASK\t\tGENMASK(31, 6)\n\n#define TCSR_SOC_HW_VERSION\t\t0x1B00000\n#define TCSR_SOC_HW_VERSION_MAJOR_MASK\tGENMASK(11, 8)\n#define TCSR_SOC_HW_VERSION_MINOR_MASK\tGENMASK(7, 4)\n\n \n#define ACCESS_ALWAYS_OFF 0xFE0\n\n#define QCN9274_DEVICE_ID\t\t0x1109\n#define WCN7850_DEVICE_ID\t\t0x1107\n\nstatic const struct pci_device_id ath12k_pci_id_table[] = {\n\t{ PCI_VDEVICE(QCOM, QCN9274_DEVICE_ID) },\n\t{ PCI_VDEVICE(QCOM, WCN7850_DEVICE_ID) },\n\t{0}\n};\n\nMODULE_DEVICE_TABLE(pci, ath12k_pci_id_table);\n\n \nstatic const struct ath12k_msi_config ath12k_msi_config[] = {\n\t{\n\t\t.total_vectors = 16,\n\t\t.total_users = 3,\n\t\t.users = (struct ath12k_msi_user[]) {\n\t\t\t{ .name = \"MHI\", .num_vectors = 3, .base_vector = 0 },\n\t\t\t{ .name = \"CE\", .num_vectors = 5, .base_vector = 3 },\n\t\t\t{ .name = \"DP\", .num_vectors = 8, .base_vector = 8 },\n\t\t},\n\t},\n};\n\nstatic const char *irq_name[ATH12K_IRQ_NUM_MAX] = {\n\t\"bhi\",\n\t\"mhi-er0\",\n\t\"mhi-er1\",\n\t\"ce0\",\n\t\"ce1\",\n\t\"ce2\",\n\t\"ce3\",\n\t\"ce4\",\n\t\"ce5\",\n\t\"ce6\",\n\t\"ce7\",\n\t\"ce8\",\n\t\"ce9\",\n\t\"ce10\",\n\t\"ce11\",\n\t\"ce12\",\n\t\"ce13\",\n\t\"ce14\",\n\t\"ce15\",\n\t\"host2wbm-desc-feed\",\n\t\"host2reo-re-injection\",\n\t\"host2reo-command\",\n\t\"host2rxdma-monitor-ring3\",\n\t\"host2rxdma-monitor-ring2\",\n\t\"host2rxdma-monitor-ring1\",\n\t\"reo2ost-exception\",\n\t\"wbm2host-rx-release\",\n\t\"reo2host-status\",\n\t\"reo2host-destination-ring4\",\n\t\"reo2host-destination-ring3\",\n\t\"reo2host-destination-ring2\",\n\t\"reo2host-destination-ring1\",\n\t\"rxdma2host-monitor-destination-mac3\",\n\t\"rxdma2host-monitor-destination-mac2\",\n\t\"rxdma2host-monitor-destination-mac1\",\n\t\"ppdu-end-interrupts-mac3\",\n\t\"ppdu-end-interrupts-mac2\",\n\t\"ppdu-end-interrupts-mac1\",\n\t\"rxdma2host-monitor-status-ring-mac3\",\n\t\"rxdma2host-monitor-status-ring-mac2\",\n\t\"rxdma2host-monitor-status-ring-mac1\",\n\t\"host2rxdma-host-buf-ring-mac3\",\n\t\"host2rxdma-host-buf-ring-mac2\",\n\t\"host2rxdma-host-buf-ring-mac1\",\n\t\"rxdma2host-destination-ring-mac3\",\n\t\"rxdma2host-destination-ring-mac2\",\n\t\"rxdma2host-destination-ring-mac1\",\n\t\"host2tcl-input-ring4\",\n\t\"host2tcl-input-ring3\",\n\t\"host2tcl-input-ring2\",\n\t\"host2tcl-input-ring1\",\n\t\"wbm2host-tx-completions-ring4\",\n\t\"wbm2host-tx-completions-ring3\",\n\t\"wbm2host-tx-completions-ring2\",\n\t\"wbm2host-tx-completions-ring1\",\n\t\"tcl2host-status-ring\",\n};\n\nstatic int ath12k_pci_bus_wake_up(struct ath12k_base *ab)\n{\n\tstruct ath12k_pci *ab_pci = ath12k_pci_priv(ab);\n\n\treturn mhi_device_get_sync(ab_pci->mhi_ctrl->mhi_dev);\n}\n\nstatic void ath12k_pci_bus_release(struct ath12k_base *ab)\n{\n\tstruct ath12k_pci *ab_pci = ath12k_pci_priv(ab);\n\n\tmhi_device_put(ab_pci->mhi_ctrl->mhi_dev);\n}\n\nstatic const struct ath12k_pci_ops ath12k_pci_ops_qcn9274 = {\n\t.wakeup = NULL,\n\t.release = NULL,\n};\n\nstatic const struct ath12k_pci_ops ath12k_pci_ops_wcn7850 = {\n\t.wakeup = ath12k_pci_bus_wake_up,\n\t.release = ath12k_pci_bus_release,\n};\n\nstatic void ath12k_pci_select_window(struct ath12k_pci *ab_pci, u32 offset)\n{\n\tstruct ath12k_base *ab = ab_pci->ab;\n\n\tu32 window = u32_get_bits(offset, WINDOW_VALUE_MASK);\n\tu32 static_window;\n\n\tlockdep_assert_held(&ab_pci->window_lock);\n\n\t \n\tstatic_window = ab_pci->register_window & WINDOW_STATIC_MASK;\n\twindow |= static_window;\n\n\tif (window != ab_pci->register_window) {\n\t\tiowrite32(WINDOW_ENABLE_BIT | window,\n\t\t\t  ab->mem + WINDOW_REG_ADDRESS);\n\t\tioread32(ab->mem + WINDOW_REG_ADDRESS);\n\t\tab_pci->register_window = window;\n\t}\n}\n\nstatic void ath12k_pci_select_static_window(struct ath12k_pci *ab_pci)\n{\n\tu32 umac_window = u32_get_bits(HAL_SEQ_WCSS_UMAC_OFFSET, WINDOW_VALUE_MASK);\n\tu32 ce_window = u32_get_bits(HAL_CE_WFSS_CE_REG_BASE, WINDOW_VALUE_MASK);\n\tu32 window;\n\n\twindow = (umac_window << 12) | (ce_window << 6);\n\n\tspin_lock_bh(&ab_pci->window_lock);\n\tab_pci->register_window = window;\n\tspin_unlock_bh(&ab_pci->window_lock);\n\n\tiowrite32(WINDOW_ENABLE_BIT | window, ab_pci->ab->mem + WINDOW_REG_ADDRESS);\n}\n\nstatic u32 ath12k_pci_get_window_start(struct ath12k_base *ab,\n\t\t\t\t       u32 offset)\n{\n\tu32 window_start;\n\n\t \n\tif ((offset ^ HAL_SEQ_WCSS_UMAC_OFFSET) < WINDOW_RANGE_MASK)\n\t\twindow_start = 3 * WINDOW_START;\n\t \n\telse if ((offset ^ HAL_CE_WFSS_CE_REG_BASE) < WINDOW_RANGE_MASK)\n\t\twindow_start = 2 * WINDOW_START;\n\t \n\telse if (((offset ^ PCI_BAR_WINDOW0_BASE) < WINDOW_RANGE_MASK) &&\n\t\t !((offset ^ PCI_SOC_PCI_REG_BASE) < PCI_SOC_RANGE_MASK))\n\t\twindow_start = 0;\n\telse\n\t\twindow_start = WINDOW_START;\n\n\treturn window_start;\n}\n\nstatic void ath12k_pci_soc_global_reset(struct ath12k_base *ab)\n{\n\tu32 val, delay;\n\n\tval = ath12k_pci_read32(ab, PCIE_SOC_GLOBAL_RESET);\n\n\tval |= PCIE_SOC_GLOBAL_RESET_V;\n\n\tath12k_pci_write32(ab, PCIE_SOC_GLOBAL_RESET, val);\n\n\t \n\tdelay = 10;\n\tmdelay(delay);\n\n\t \n\tval &= ~PCIE_SOC_GLOBAL_RESET_V;\n\n\tath12k_pci_write32(ab, PCIE_SOC_GLOBAL_RESET, val);\n\n\tmdelay(delay);\n\n\tval = ath12k_pci_read32(ab, PCIE_SOC_GLOBAL_RESET);\n\tif (val == 0xffffffff)\n\t\tath12k_warn(ab, \"link down error during global reset\\n\");\n}\n\nstatic void ath12k_pci_clear_dbg_registers(struct ath12k_base *ab)\n{\n\tu32 val;\n\n\t \n\tval = ath12k_pci_read32(ab, PCIE_Q6_COOKIE_ADDR);\n\tath12k_dbg(ab, ATH12K_DBG_PCI, \"cookie:0x%x\\n\", val);\n\n\tval = ath12k_pci_read32(ab, WLAON_WARM_SW_ENTRY);\n\tath12k_dbg(ab, ATH12K_DBG_PCI, \"WLAON_WARM_SW_ENTRY 0x%x\\n\", val);\n\n\t \n\tmdelay(10);\n\n\t \n\tath12k_pci_write32(ab, WLAON_WARM_SW_ENTRY, 0);\n\tmdelay(10);\n\n\tval = ath12k_pci_read32(ab, WLAON_WARM_SW_ENTRY);\n\tath12k_dbg(ab, ATH12K_DBG_PCI, \"WLAON_WARM_SW_ENTRY 0x%x\\n\", val);\n\n\t \n\tval = ath12k_pci_read32(ab, WLAON_SOC_RESET_CAUSE_REG);\n\tath12k_dbg(ab, ATH12K_DBG_PCI, \"soc reset cause:%d\\n\", val);\n}\n\nstatic void ath12k_pci_enable_ltssm(struct ath12k_base *ab)\n{\n\tu32 val;\n\tint i;\n\n\tval = ath12k_pci_read32(ab, PCIE_PCIE_PARF_LTSSM);\n\n\t \n\tfor (i = 0; val != PARM_LTSSM_VALUE && i < 5; i++) {\n\t\tif (val == 0xffffffff)\n\t\t\tmdelay(5);\n\n\t\tath12k_pci_write32(ab, PCIE_PCIE_PARF_LTSSM, PARM_LTSSM_VALUE);\n\t\tval = ath12k_pci_read32(ab, PCIE_PCIE_PARF_LTSSM);\n\t}\n\n\tath12k_dbg(ab, ATH12K_DBG_PCI, \"pci ltssm 0x%x\\n\", val);\n\n\tval = ath12k_pci_read32(ab, GCC_GCC_PCIE_HOT_RST);\n\tval |= GCC_GCC_PCIE_HOT_RST_VAL;\n\tath12k_pci_write32(ab, GCC_GCC_PCIE_HOT_RST, val);\n\tval = ath12k_pci_read32(ab, GCC_GCC_PCIE_HOT_RST);\n\n\tath12k_dbg(ab, ATH12K_DBG_PCI, \"pci pcie_hot_rst 0x%x\\n\", val);\n\n\tmdelay(5);\n}\n\nstatic void ath12k_pci_clear_all_intrs(struct ath12k_base *ab)\n{\n\t \n\tath12k_pci_write32(ab, PCIE_PCIE_INT_ALL_CLEAR, PCIE_INT_CLEAR_ALL);\n}\n\nstatic void ath12k_pci_set_wlaon_pwr_ctrl(struct ath12k_base *ab)\n{\n\tu32 val;\n\n\tval = ath12k_pci_read32(ab, WLAON_QFPROM_PWR_CTRL_REG);\n\tval &= ~QFPROM_PWR_CTRL_VDD4BLOW_MASK;\n\tath12k_pci_write32(ab, WLAON_QFPROM_PWR_CTRL_REG, val);\n}\n\nstatic void ath12k_pci_force_wake(struct ath12k_base *ab)\n{\n\tath12k_pci_write32(ab, PCIE_SOC_WAKE_PCIE_LOCAL_REG, 1);\n\tmdelay(5);\n}\n\nstatic void ath12k_pci_sw_reset(struct ath12k_base *ab, bool power_on)\n{\n\tif (power_on) {\n\t\tath12k_pci_enable_ltssm(ab);\n\t\tath12k_pci_clear_all_intrs(ab);\n\t\tath12k_pci_set_wlaon_pwr_ctrl(ab);\n\t}\n\n\tath12k_mhi_clear_vector(ab);\n\tath12k_pci_clear_dbg_registers(ab);\n\tath12k_pci_soc_global_reset(ab);\n\tath12k_mhi_set_mhictrl_reset(ab);\n}\n\nstatic void ath12k_pci_free_ext_irq(struct ath12k_base *ab)\n{\n\tint i, j;\n\n\tfor (i = 0; i < ATH12K_EXT_IRQ_GRP_NUM_MAX; i++) {\n\t\tstruct ath12k_ext_irq_grp *irq_grp = &ab->ext_irq_grp[i];\n\n\t\tfor (j = 0; j < irq_grp->num_irq; j++)\n\t\t\tfree_irq(ab->irq_num[irq_grp->irqs[j]], irq_grp);\n\n\t\tnetif_napi_del(&irq_grp->napi);\n\t}\n}\n\nstatic void ath12k_pci_free_irq(struct ath12k_base *ab)\n{\n\tint i, irq_idx;\n\n\tfor (i = 0; i < ab->hw_params->ce_count; i++) {\n\t\tif (ath12k_ce_get_attr_flags(ab, i) & CE_ATTR_DIS_INTR)\n\t\t\tcontinue;\n\t\tirq_idx = ATH12K_PCI_IRQ_CE0_OFFSET + i;\n\t\tfree_irq(ab->irq_num[irq_idx], &ab->ce.ce_pipe[i]);\n\t}\n\n\tath12k_pci_free_ext_irq(ab);\n}\n\nstatic void ath12k_pci_ce_irq_enable(struct ath12k_base *ab, u16 ce_id)\n{\n\tu32 irq_idx;\n\n\tirq_idx = ATH12K_PCI_IRQ_CE0_OFFSET + ce_id;\n\tenable_irq(ab->irq_num[irq_idx]);\n}\n\nstatic void ath12k_pci_ce_irq_disable(struct ath12k_base *ab, u16 ce_id)\n{\n\tu32 irq_idx;\n\n\tirq_idx = ATH12K_PCI_IRQ_CE0_OFFSET + ce_id;\n\tdisable_irq_nosync(ab->irq_num[irq_idx]);\n}\n\nstatic void ath12k_pci_ce_irqs_disable(struct ath12k_base *ab)\n{\n\tint i;\n\n\tfor (i = 0; i < ab->hw_params->ce_count; i++) {\n\t\tif (ath12k_ce_get_attr_flags(ab, i) & CE_ATTR_DIS_INTR)\n\t\t\tcontinue;\n\t\tath12k_pci_ce_irq_disable(ab, i);\n\t}\n}\n\nstatic void ath12k_pci_sync_ce_irqs(struct ath12k_base *ab)\n{\n\tint i;\n\tint irq_idx;\n\n\tfor (i = 0; i < ab->hw_params->ce_count; i++) {\n\t\tif (ath12k_ce_get_attr_flags(ab, i) & CE_ATTR_DIS_INTR)\n\t\t\tcontinue;\n\n\t\tirq_idx = ATH12K_PCI_IRQ_CE0_OFFSET + i;\n\t\tsynchronize_irq(ab->irq_num[irq_idx]);\n\t}\n}\n\nstatic void ath12k_pci_ce_tasklet(struct tasklet_struct *t)\n{\n\tstruct ath12k_ce_pipe *ce_pipe = from_tasklet(ce_pipe, t, intr_tq);\n\n\tath12k_ce_per_engine_service(ce_pipe->ab, ce_pipe->pipe_num);\n\n\tath12k_pci_ce_irq_enable(ce_pipe->ab, ce_pipe->pipe_num);\n}\n\nstatic irqreturn_t ath12k_pci_ce_interrupt_handler(int irq, void *arg)\n{\n\tstruct ath12k_ce_pipe *ce_pipe = arg;\n\n\t \n\tce_pipe->timestamp = jiffies;\n\n\tath12k_pci_ce_irq_disable(ce_pipe->ab, ce_pipe->pipe_num);\n\ttasklet_schedule(&ce_pipe->intr_tq);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void ath12k_pci_ext_grp_disable(struct ath12k_ext_irq_grp *irq_grp)\n{\n\tint i;\n\n\tfor (i = 0; i < irq_grp->num_irq; i++)\n\t\tdisable_irq_nosync(irq_grp->ab->irq_num[irq_grp->irqs[i]]);\n}\n\nstatic void __ath12k_pci_ext_irq_disable(struct ath12k_base *sc)\n{\n\tint i;\n\n\tfor (i = 0; i < ATH12K_EXT_IRQ_GRP_NUM_MAX; i++) {\n\t\tstruct ath12k_ext_irq_grp *irq_grp = &sc->ext_irq_grp[i];\n\n\t\tath12k_pci_ext_grp_disable(irq_grp);\n\n\t\tnapi_synchronize(&irq_grp->napi);\n\t\tnapi_disable(&irq_grp->napi);\n\t}\n}\n\nstatic void ath12k_pci_ext_grp_enable(struct ath12k_ext_irq_grp *irq_grp)\n{\n\tint i;\n\n\tfor (i = 0; i < irq_grp->num_irq; i++)\n\t\tenable_irq(irq_grp->ab->irq_num[irq_grp->irqs[i]]);\n}\n\nstatic void ath12k_pci_sync_ext_irqs(struct ath12k_base *ab)\n{\n\tint i, j, irq_idx;\n\n\tfor (i = 0; i < ATH12K_EXT_IRQ_GRP_NUM_MAX; i++) {\n\t\tstruct ath12k_ext_irq_grp *irq_grp = &ab->ext_irq_grp[i];\n\n\t\tfor (j = 0; j < irq_grp->num_irq; j++) {\n\t\t\tirq_idx = irq_grp->irqs[j];\n\t\t\tsynchronize_irq(ab->irq_num[irq_idx]);\n\t\t}\n\t}\n}\n\nstatic int ath12k_pci_ext_grp_napi_poll(struct napi_struct *napi, int budget)\n{\n\tstruct ath12k_ext_irq_grp *irq_grp = container_of(napi,\n\t\t\t\t\t\tstruct ath12k_ext_irq_grp,\n\t\t\t\t\t\tnapi);\n\tstruct ath12k_base *ab = irq_grp->ab;\n\tint work_done;\n\n\twork_done = ath12k_dp_service_srng(ab, irq_grp, budget);\n\tif (work_done < budget) {\n\t\tnapi_complete_done(napi, work_done);\n\t\tath12k_pci_ext_grp_enable(irq_grp);\n\t}\n\n\tif (work_done > budget)\n\t\twork_done = budget;\n\n\treturn work_done;\n}\n\nstatic irqreturn_t ath12k_pci_ext_interrupt_handler(int irq, void *arg)\n{\n\tstruct ath12k_ext_irq_grp *irq_grp = arg;\n\n\tath12k_dbg(irq_grp->ab, ATH12K_DBG_PCI, \"ext irq:%d\\n\", irq);\n\n\t \n\tirq_grp->timestamp = jiffies;\n\n\tath12k_pci_ext_grp_disable(irq_grp);\n\n\tnapi_schedule(&irq_grp->napi);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ath12k_pci_ext_irq_config(struct ath12k_base *ab)\n{\n\tint i, j, ret, num_vectors = 0;\n\tu32 user_base_data = 0, base_vector = 0, base_idx;\n\n\tbase_idx = ATH12K_PCI_IRQ_CE0_OFFSET + CE_COUNT_MAX;\n\tret = ath12k_pci_get_user_msi_assignment(ab, \"DP\",\n\t\t\t\t\t\t &num_vectors,\n\t\t\t\t\t\t &user_base_data,\n\t\t\t\t\t\t &base_vector);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < ATH12K_EXT_IRQ_GRP_NUM_MAX; i++) {\n\t\tstruct ath12k_ext_irq_grp *irq_grp = &ab->ext_irq_grp[i];\n\t\tu32 num_irq = 0;\n\n\t\tirq_grp->ab = ab;\n\t\tirq_grp->grp_id = i;\n\t\tinit_dummy_netdev(&irq_grp->napi_ndev);\n\t\tnetif_napi_add(&irq_grp->napi_ndev, &irq_grp->napi,\n\t\t\t       ath12k_pci_ext_grp_napi_poll);\n\n\t\tif (ab->hw_params->ring_mask->tx[i] ||\n\t\t    ab->hw_params->ring_mask->rx[i] ||\n\t\t    ab->hw_params->ring_mask->rx_err[i] ||\n\t\t    ab->hw_params->ring_mask->rx_wbm_rel[i] ||\n\t\t    ab->hw_params->ring_mask->reo_status[i] ||\n\t\t    ab->hw_params->ring_mask->host2rxdma[i] ||\n\t\t    ab->hw_params->ring_mask->rx_mon_dest[i]) {\n\t\t\tnum_irq = 1;\n\t\t}\n\n\t\tirq_grp->num_irq = num_irq;\n\t\tirq_grp->irqs[0] = base_idx + i;\n\n\t\tfor (j = 0; j < irq_grp->num_irq; j++) {\n\t\t\tint irq_idx = irq_grp->irqs[j];\n\t\t\tint vector = (i % num_vectors) + base_vector;\n\t\t\tint irq = ath12k_pci_get_msi_irq(ab->dev, vector);\n\n\t\t\tab->irq_num[irq_idx] = irq;\n\n\t\t\tath12k_dbg(ab, ATH12K_DBG_PCI,\n\t\t\t\t   \"irq:%d group:%d\\n\", irq, i);\n\n\t\t\tirq_set_status_flags(irq, IRQ_DISABLE_UNLAZY);\n\t\t\tret = request_irq(irq, ath12k_pci_ext_interrupt_handler,\n\t\t\t\t\t  IRQF_SHARED,\n\t\t\t\t\t  \"DP_EXT_IRQ\", irq_grp);\n\t\t\tif (ret) {\n\t\t\t\tath12k_err(ab, \"failed request irq %d: %d\\n\",\n\t\t\t\t\t   vector, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tdisable_irq_nosync(ab->irq_num[irq_idx]);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ath12k_pci_config_irq(struct ath12k_base *ab)\n{\n\tstruct ath12k_ce_pipe *ce_pipe;\n\tu32 msi_data_start;\n\tu32 msi_data_count, msi_data_idx;\n\tu32 msi_irq_start;\n\tunsigned int msi_data;\n\tint irq, i, ret, irq_idx;\n\n\tret = ath12k_pci_get_user_msi_assignment(ab,\n\t\t\t\t\t\t \"CE\", &msi_data_count,\n\t\t\t\t\t\t &msi_data_start, &msi_irq_start);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\tfor (i = 0, msi_data_idx = 0; i < ab->hw_params->ce_count; i++) {\n\t\tif (ath12k_ce_get_attr_flags(ab, i) & CE_ATTR_DIS_INTR)\n\t\t\tcontinue;\n\n\t\tmsi_data = (msi_data_idx % msi_data_count) + msi_irq_start;\n\t\tirq = ath12k_pci_get_msi_irq(ab->dev, msi_data);\n\t\tce_pipe = &ab->ce.ce_pipe[i];\n\n\t\tirq_idx = ATH12K_PCI_IRQ_CE0_OFFSET + i;\n\n\t\ttasklet_setup(&ce_pipe->intr_tq, ath12k_pci_ce_tasklet);\n\n\t\tret = request_irq(irq, ath12k_pci_ce_interrupt_handler,\n\t\t\t\t  IRQF_SHARED, irq_name[irq_idx],\n\t\t\t\t  ce_pipe);\n\t\tif (ret) {\n\t\t\tath12k_err(ab, \"failed to request irq %d: %d\\n\",\n\t\t\t\t   irq_idx, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tab->irq_num[irq_idx] = irq;\n\t\tmsi_data_idx++;\n\n\t\tath12k_pci_ce_irq_disable(ab, i);\n\t}\n\n\tret = ath12k_pci_ext_irq_config(ab);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void ath12k_pci_init_qmi_ce_config(struct ath12k_base *ab)\n{\n\tstruct ath12k_qmi_ce_cfg *cfg = &ab->qmi.ce_cfg;\n\n\tcfg->tgt_ce = ab->hw_params->target_ce_config;\n\tcfg->tgt_ce_len = ab->hw_params->target_ce_count;\n\n\tcfg->svc_to_ce_map = ab->hw_params->svc_to_ce_map;\n\tcfg->svc_to_ce_map_len = ab->hw_params->svc_to_ce_map_len;\n\tab->qmi.service_ins_id = ab->hw_params->qmi_service_ins_id;\n}\n\nstatic void ath12k_pci_ce_irqs_enable(struct ath12k_base *ab)\n{\n\tint i;\n\n\tfor (i = 0; i < ab->hw_params->ce_count; i++) {\n\t\tif (ath12k_ce_get_attr_flags(ab, i) & CE_ATTR_DIS_INTR)\n\t\t\tcontinue;\n\t\tath12k_pci_ce_irq_enable(ab, i);\n\t}\n}\n\nstatic void ath12k_pci_msi_config(struct ath12k_pci *ab_pci, bool enable)\n{\n\tstruct pci_dev *dev = ab_pci->pdev;\n\tu16 control;\n\n\tpci_read_config_word(dev, dev->msi_cap + PCI_MSI_FLAGS, &control);\n\n\tif (enable)\n\t\tcontrol |= PCI_MSI_FLAGS_ENABLE;\n\telse\n\t\tcontrol &= ~PCI_MSI_FLAGS_ENABLE;\n\n\tpci_write_config_word(dev, dev->msi_cap + PCI_MSI_FLAGS, control);\n}\n\nstatic void ath12k_pci_msi_enable(struct ath12k_pci *ab_pci)\n{\n\tath12k_pci_msi_config(ab_pci, true);\n}\n\nstatic void ath12k_pci_msi_disable(struct ath12k_pci *ab_pci)\n{\n\tath12k_pci_msi_config(ab_pci, false);\n}\n\nstatic int ath12k_pci_msi_alloc(struct ath12k_pci *ab_pci)\n{\n\tstruct ath12k_base *ab = ab_pci->ab;\n\tconst struct ath12k_msi_config *msi_config = ab_pci->msi_config;\n\tstruct msi_desc *msi_desc;\n\tint num_vectors;\n\tint ret;\n\n\tnum_vectors = pci_alloc_irq_vectors(ab_pci->pdev,\n\t\t\t\t\t    msi_config->total_vectors,\n\t\t\t\t\t    msi_config->total_vectors,\n\t\t\t\t\t    PCI_IRQ_MSI);\n\tif (num_vectors != msi_config->total_vectors) {\n\t\tath12k_err(ab, \"failed to get %d MSI vectors, only %d available\",\n\t\t\t   msi_config->total_vectors, num_vectors);\n\n\t\tif (num_vectors >= 0)\n\t\t\treturn -EINVAL;\n\t\telse\n\t\t\treturn num_vectors;\n\t}\n\n\tath12k_pci_msi_disable(ab_pci);\n\n\tmsi_desc = irq_get_msi_desc(ab_pci->pdev->irq);\n\tif (!msi_desc) {\n\t\tath12k_err(ab, \"msi_desc is NULL!\\n\");\n\t\tret = -EINVAL;\n\t\tgoto free_msi_vector;\n\t}\n\n\tab_pci->msi_ep_base_data = msi_desc->msg.data;\n\tif (msi_desc->pci.msi_attrib.is_64)\n\t\tset_bit(ATH12K_PCI_FLAG_IS_MSI_64, &ab_pci->flags);\n\n\tath12k_dbg(ab, ATH12K_DBG_PCI, \"msi base data is %d\\n\", ab_pci->msi_ep_base_data);\n\n\treturn 0;\n\nfree_msi_vector:\n\tpci_free_irq_vectors(ab_pci->pdev);\n\n\treturn ret;\n}\n\nstatic void ath12k_pci_msi_free(struct ath12k_pci *ab_pci)\n{\n\tpci_free_irq_vectors(ab_pci->pdev);\n}\n\nstatic int ath12k_pci_claim(struct ath12k_pci *ab_pci, struct pci_dev *pdev)\n{\n\tstruct ath12k_base *ab = ab_pci->ab;\n\tu16 device_id;\n\tint ret = 0;\n\n\tpci_read_config_word(pdev, PCI_DEVICE_ID, &device_id);\n\tif (device_id != ab_pci->dev_id)  {\n\t\tath12k_err(ab, \"pci device id mismatch: 0x%x 0x%x\\n\",\n\t\t\t   device_id, ab_pci->dev_id);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tret = pci_assign_resource(pdev, ATH12K_PCI_BAR_NUM);\n\tif (ret) {\n\t\tath12k_err(ab, \"failed to assign pci resource: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = pci_enable_device(pdev);\n\tif (ret) {\n\t\tath12k_err(ab, \"failed to enable pci device: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = pci_request_region(pdev, ATH12K_PCI_BAR_NUM, \"ath12k_pci\");\n\tif (ret) {\n\t\tath12k_err(ab, \"failed to request pci region: %d\\n\", ret);\n\t\tgoto disable_device;\n\t}\n\n\tret = dma_set_mask_and_coherent(&pdev->dev,\n\t\t\t\t\tDMA_BIT_MASK(ATH12K_PCI_DMA_MASK));\n\tif (ret) {\n\t\tath12k_err(ab, \"failed to set pci dma mask to %d: %d\\n\",\n\t\t\t   ATH12K_PCI_DMA_MASK, ret);\n\t\tgoto release_region;\n\t}\n\n\tpci_set_master(pdev);\n\n\tab->mem_len = pci_resource_len(pdev, ATH12K_PCI_BAR_NUM);\n\tab->mem = pci_iomap(pdev, ATH12K_PCI_BAR_NUM, 0);\n\tif (!ab->mem) {\n\t\tath12k_err(ab, \"failed to map pci bar %d\\n\", ATH12K_PCI_BAR_NUM);\n\t\tret = -EIO;\n\t\tgoto release_region;\n\t}\n\n\tath12k_dbg(ab, ATH12K_DBG_BOOT, \"boot pci_mem 0x%pK\\n\", ab->mem);\n\treturn 0;\n\nrelease_region:\n\tpci_release_region(pdev, ATH12K_PCI_BAR_NUM);\ndisable_device:\n\tpci_disable_device(pdev);\nout:\n\treturn ret;\n}\n\nstatic void ath12k_pci_free_region(struct ath12k_pci *ab_pci)\n{\n\tstruct ath12k_base *ab = ab_pci->ab;\n\tstruct pci_dev *pci_dev = ab_pci->pdev;\n\n\tpci_iounmap(pci_dev, ab->mem);\n\tab->mem = NULL;\n\tpci_release_region(pci_dev, ATH12K_PCI_BAR_NUM);\n\tif (pci_is_enabled(pci_dev))\n\t\tpci_disable_device(pci_dev);\n}\n\nstatic void ath12k_pci_aspm_disable(struct ath12k_pci *ab_pci)\n{\n\tstruct ath12k_base *ab = ab_pci->ab;\n\n\tpcie_capability_read_word(ab_pci->pdev, PCI_EXP_LNKCTL,\n\t\t\t\t  &ab_pci->link_ctl);\n\n\tath12k_dbg(ab, ATH12K_DBG_PCI, \"pci link_ctl 0x%04x L0s %d L1 %d\\n\",\n\t\t   ab_pci->link_ctl,\n\t\t   u16_get_bits(ab_pci->link_ctl, PCI_EXP_LNKCTL_ASPM_L0S),\n\t\t   u16_get_bits(ab_pci->link_ctl, PCI_EXP_LNKCTL_ASPM_L1));\n\n\t \n\tpcie_capability_clear_word(ab_pci->pdev, PCI_EXP_LNKCTL,\n\t\t\t\t   PCI_EXP_LNKCTL_ASPMC);\n\n\tset_bit(ATH12K_PCI_ASPM_RESTORE, &ab_pci->flags);\n}\n\nstatic void ath12k_pci_aspm_restore(struct ath12k_pci *ab_pci)\n{\n\tif (test_and_clear_bit(ATH12K_PCI_ASPM_RESTORE, &ab_pci->flags))\n\t\tpcie_capability_clear_and_set_word(ab_pci->pdev, PCI_EXP_LNKCTL,\n\t\t\t\t\t\t   PCI_EXP_LNKCTL_ASPMC,\n\t\t\t\t\t\t   ab_pci->link_ctl &\n\t\t\t\t\t\t   PCI_EXP_LNKCTL_ASPMC);\n}\n\nstatic void ath12k_pci_kill_tasklets(struct ath12k_base *ab)\n{\n\tint i;\n\n\tfor (i = 0; i < ab->hw_params->ce_count; i++) {\n\t\tstruct ath12k_ce_pipe *ce_pipe = &ab->ce.ce_pipe[i];\n\n\t\tif (ath12k_ce_get_attr_flags(ab, i) & CE_ATTR_DIS_INTR)\n\t\t\tcontinue;\n\n\t\ttasklet_kill(&ce_pipe->intr_tq);\n\t}\n}\n\nstatic void ath12k_pci_ce_irq_disable_sync(struct ath12k_base *ab)\n{\n\tath12k_pci_ce_irqs_disable(ab);\n\tath12k_pci_sync_ce_irqs(ab);\n\tath12k_pci_kill_tasklets(ab);\n}\n\nint ath12k_pci_map_service_to_pipe(struct ath12k_base *ab, u16 service_id,\n\t\t\t\t   u8 *ul_pipe, u8 *dl_pipe)\n{\n\tconst struct service_to_pipe *entry;\n\tbool ul_set = false, dl_set = false;\n\tint i;\n\n\tfor (i = 0; i < ab->hw_params->svc_to_ce_map_len; i++) {\n\t\tentry = &ab->hw_params->svc_to_ce_map[i];\n\n\t\tif (__le32_to_cpu(entry->service_id) != service_id)\n\t\t\tcontinue;\n\n\t\tswitch (__le32_to_cpu(entry->pipedir)) {\n\t\tcase PIPEDIR_NONE:\n\t\t\tbreak;\n\t\tcase PIPEDIR_IN:\n\t\t\tWARN_ON(dl_set);\n\t\t\t*dl_pipe = __le32_to_cpu(entry->pipenum);\n\t\t\tdl_set = true;\n\t\t\tbreak;\n\t\tcase PIPEDIR_OUT:\n\t\t\tWARN_ON(ul_set);\n\t\t\t*ul_pipe = __le32_to_cpu(entry->pipenum);\n\t\t\tul_set = true;\n\t\t\tbreak;\n\t\tcase PIPEDIR_INOUT:\n\t\t\tWARN_ON(dl_set);\n\t\t\tWARN_ON(ul_set);\n\t\t\t*dl_pipe = __le32_to_cpu(entry->pipenum);\n\t\t\t*ul_pipe = __le32_to_cpu(entry->pipenum);\n\t\t\tdl_set = true;\n\t\t\tul_set = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (WARN_ON(!ul_set || !dl_set))\n\t\treturn -ENOENT;\n\n\treturn 0;\n}\n\nint ath12k_pci_get_msi_irq(struct device *dev, unsigned int vector)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(dev);\n\n\treturn pci_irq_vector(pci_dev, vector);\n}\n\nint ath12k_pci_get_user_msi_assignment(struct ath12k_base *ab, char *user_name,\n\t\t\t\t       int *num_vectors, u32 *user_base_data,\n\t\t\t\t       u32 *base_vector)\n{\n\tstruct ath12k_pci *ab_pci = ath12k_pci_priv(ab);\n\tconst struct ath12k_msi_config *msi_config = ab_pci->msi_config;\n\tint idx;\n\n\tfor (idx = 0; idx < msi_config->total_users; idx++) {\n\t\tif (strcmp(user_name, msi_config->users[idx].name) == 0) {\n\t\t\t*num_vectors = msi_config->users[idx].num_vectors;\n\t\t\t*user_base_data = msi_config->users[idx].base_vector\n\t\t\t\t+ ab_pci->msi_ep_base_data;\n\t\t\t*base_vector = msi_config->users[idx].base_vector;\n\n\t\t\tath12k_dbg(ab, ATH12K_DBG_PCI, \"Assign MSI to user: %s, num_vectors: %d, user_base_data: %u, base_vector: %u\\n\",\n\t\t\t\t   user_name, *num_vectors, *user_base_data,\n\t\t\t\t   *base_vector);\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tath12k_err(ab, \"Failed to find MSI assignment for %s!\\n\", user_name);\n\n\treturn -EINVAL;\n}\n\nvoid ath12k_pci_get_msi_address(struct ath12k_base *ab, u32 *msi_addr_lo,\n\t\t\t\tu32 *msi_addr_hi)\n{\n\tstruct ath12k_pci *ab_pci = ath12k_pci_priv(ab);\n\tstruct pci_dev *pci_dev = to_pci_dev(ab->dev);\n\n\tpci_read_config_dword(pci_dev, pci_dev->msi_cap + PCI_MSI_ADDRESS_LO,\n\t\t\t      msi_addr_lo);\n\n\tif (test_bit(ATH12K_PCI_FLAG_IS_MSI_64, &ab_pci->flags)) {\n\t\tpci_read_config_dword(pci_dev, pci_dev->msi_cap + PCI_MSI_ADDRESS_HI,\n\t\t\t\t      msi_addr_hi);\n\t} else {\n\t\t*msi_addr_hi = 0;\n\t}\n}\n\nvoid ath12k_pci_get_ce_msi_idx(struct ath12k_base *ab, u32 ce_id,\n\t\t\t       u32 *msi_idx)\n{\n\tu32 i, msi_data_idx;\n\n\tfor (i = 0, msi_data_idx = 0; i < ab->hw_params->ce_count; i++) {\n\t\tif (ath12k_ce_get_attr_flags(ab, i) & CE_ATTR_DIS_INTR)\n\t\t\tcontinue;\n\n\t\tif (ce_id == i)\n\t\t\tbreak;\n\n\t\tmsi_data_idx++;\n\t}\n\t*msi_idx = msi_data_idx;\n}\n\nvoid ath12k_pci_hif_ce_irq_enable(struct ath12k_base *ab)\n{\n\tath12k_pci_ce_irqs_enable(ab);\n}\n\nvoid ath12k_pci_hif_ce_irq_disable(struct ath12k_base *ab)\n{\n\tath12k_pci_ce_irq_disable_sync(ab);\n}\n\nvoid ath12k_pci_ext_irq_enable(struct ath12k_base *ab)\n{\n\tint i;\n\n\tfor (i = 0; i < ATH12K_EXT_IRQ_GRP_NUM_MAX; i++) {\n\t\tstruct ath12k_ext_irq_grp *irq_grp = &ab->ext_irq_grp[i];\n\n\t\tnapi_enable(&irq_grp->napi);\n\t\tath12k_pci_ext_grp_enable(irq_grp);\n\t}\n}\n\nvoid ath12k_pci_ext_irq_disable(struct ath12k_base *ab)\n{\n\t__ath12k_pci_ext_irq_disable(ab);\n\tath12k_pci_sync_ext_irqs(ab);\n}\n\nint ath12k_pci_hif_suspend(struct ath12k_base *ab)\n{\n\tstruct ath12k_pci *ar_pci = ath12k_pci_priv(ab);\n\n\tath12k_mhi_suspend(ar_pci);\n\n\treturn 0;\n}\n\nint ath12k_pci_hif_resume(struct ath12k_base *ab)\n{\n\tstruct ath12k_pci *ar_pci = ath12k_pci_priv(ab);\n\n\tath12k_mhi_resume(ar_pci);\n\n\treturn 0;\n}\n\nvoid ath12k_pci_stop(struct ath12k_base *ab)\n{\n\tath12k_pci_ce_irq_disable_sync(ab);\n\tath12k_ce_cleanup_pipes(ab);\n}\n\nint ath12k_pci_start(struct ath12k_base *ab)\n{\n\tstruct ath12k_pci *ab_pci = ath12k_pci_priv(ab);\n\n\tset_bit(ATH12K_PCI_FLAG_INIT_DONE, &ab_pci->flags);\n\n\tath12k_pci_aspm_restore(ab_pci);\n\n\tath12k_pci_ce_irqs_enable(ab);\n\tath12k_ce_rx_post_buf(ab);\n\n\treturn 0;\n}\n\nu32 ath12k_pci_read32(struct ath12k_base *ab, u32 offset)\n{\n\tstruct ath12k_pci *ab_pci = ath12k_pci_priv(ab);\n\tu32 val, window_start;\n\tint ret = 0;\n\n\t \n\tif (test_bit(ATH12K_PCI_FLAG_INIT_DONE, &ab_pci->flags) &&\n\t    offset >= ACCESS_ALWAYS_OFF && ab_pci->pci_ops->wakeup)\n\t\tret = ab_pci->pci_ops->wakeup(ab);\n\n\tif (offset < WINDOW_START) {\n\t\tval = ioread32(ab->mem + offset);\n\t} else {\n\t\tif (ab->static_window_map)\n\t\t\twindow_start = ath12k_pci_get_window_start(ab, offset);\n\t\telse\n\t\t\twindow_start = WINDOW_START;\n\n\t\tif (window_start == WINDOW_START) {\n\t\t\tspin_lock_bh(&ab_pci->window_lock);\n\t\t\tath12k_pci_select_window(ab_pci, offset);\n\t\t\tval = ioread32(ab->mem + window_start +\n\t\t\t\t       (offset & WINDOW_RANGE_MASK));\n\t\t\tspin_unlock_bh(&ab_pci->window_lock);\n\t\t} else {\n\t\t\tif ((!window_start) &&\n\t\t\t    (offset >= PCI_MHIREGLEN_REG &&\n\t\t\t     offset <= PCI_MHI_REGION_END))\n\t\t\t\toffset = offset - PCI_MHIREGLEN_REG;\n\n\t\t\tval = ioread32(ab->mem + window_start +\n\t\t\t\t       (offset & WINDOW_RANGE_MASK));\n\t\t}\n\t}\n\n\tif (test_bit(ATH12K_PCI_FLAG_INIT_DONE, &ab_pci->flags) &&\n\t    offset >= ACCESS_ALWAYS_OFF && ab_pci->pci_ops->release &&\n\t    !ret)\n\t\tab_pci->pci_ops->release(ab);\n\treturn val;\n}\n\nvoid ath12k_pci_write32(struct ath12k_base *ab, u32 offset, u32 value)\n{\n\tstruct ath12k_pci *ab_pci = ath12k_pci_priv(ab);\n\tu32 window_start;\n\tint ret = 0;\n\n\t \n\tif (test_bit(ATH12K_PCI_FLAG_INIT_DONE, &ab_pci->flags) &&\n\t    offset >= ACCESS_ALWAYS_OFF && ab_pci->pci_ops->wakeup)\n\t\tret = ab_pci->pci_ops->wakeup(ab);\n\n\tif (offset < WINDOW_START) {\n\t\tiowrite32(value, ab->mem + offset);\n\t} else {\n\t\tif (ab->static_window_map)\n\t\t\twindow_start = ath12k_pci_get_window_start(ab, offset);\n\t\telse\n\t\t\twindow_start = WINDOW_START;\n\n\t\tif (window_start == WINDOW_START) {\n\t\t\tspin_lock_bh(&ab_pci->window_lock);\n\t\t\tath12k_pci_select_window(ab_pci, offset);\n\t\t\tiowrite32(value, ab->mem + window_start +\n\t\t\t\t  (offset & WINDOW_RANGE_MASK));\n\t\t\tspin_unlock_bh(&ab_pci->window_lock);\n\t\t} else {\n\t\t\tif ((!window_start) &&\n\t\t\t    (offset >= PCI_MHIREGLEN_REG &&\n\t\t\t     offset <= PCI_MHI_REGION_END))\n\t\t\t\toffset = offset - PCI_MHIREGLEN_REG;\n\n\t\t\tiowrite32(value, ab->mem + window_start +\n\t\t\t\t  (offset & WINDOW_RANGE_MASK));\n\t\t}\n\t}\n\n\tif (test_bit(ATH12K_PCI_FLAG_INIT_DONE, &ab_pci->flags) &&\n\t    offset >= ACCESS_ALWAYS_OFF && ab_pci->pci_ops->release &&\n\t    !ret)\n\t\tab_pci->pci_ops->release(ab);\n}\n\nint ath12k_pci_power_up(struct ath12k_base *ab)\n{\n\tstruct ath12k_pci *ab_pci = ath12k_pci_priv(ab);\n\tint ret;\n\n\tab_pci->register_window = 0;\n\tclear_bit(ATH12K_PCI_FLAG_INIT_DONE, &ab_pci->flags);\n\tath12k_pci_sw_reset(ab_pci->ab, true);\n\n\t \n\tath12k_pci_aspm_disable(ab_pci);\n\n\tath12k_pci_msi_enable(ab_pci);\n\n\tret = ath12k_mhi_start(ab_pci);\n\tif (ret) {\n\t\tath12k_err(ab, \"failed to start mhi: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (ab->static_window_map)\n\t\tath12k_pci_select_static_window(ab_pci);\n\n\treturn 0;\n}\n\nvoid ath12k_pci_power_down(struct ath12k_base *ab)\n{\n\tstruct ath12k_pci *ab_pci = ath12k_pci_priv(ab);\n\n\t \n\tath12k_pci_aspm_restore(ab_pci);\n\n\tath12k_pci_force_wake(ab_pci->ab);\n\tath12k_pci_msi_disable(ab_pci);\n\tath12k_mhi_stop(ab_pci);\n\tclear_bit(ATH12K_PCI_FLAG_INIT_DONE, &ab_pci->flags);\n\tath12k_pci_sw_reset(ab_pci->ab, false);\n}\n\nstatic const struct ath12k_hif_ops ath12k_pci_hif_ops = {\n\t.start = ath12k_pci_start,\n\t.stop = ath12k_pci_stop,\n\t.read32 = ath12k_pci_read32,\n\t.write32 = ath12k_pci_write32,\n\t.power_down = ath12k_pci_power_down,\n\t.power_up = ath12k_pci_power_up,\n\t.suspend = ath12k_pci_hif_suspend,\n\t.resume = ath12k_pci_hif_resume,\n\t.irq_enable = ath12k_pci_ext_irq_enable,\n\t.irq_disable = ath12k_pci_ext_irq_disable,\n\t.get_msi_address = ath12k_pci_get_msi_address,\n\t.get_user_msi_vector = ath12k_pci_get_user_msi_assignment,\n\t.map_service_to_pipe = ath12k_pci_map_service_to_pipe,\n\t.ce_irq_enable = ath12k_pci_hif_ce_irq_enable,\n\t.ce_irq_disable = ath12k_pci_hif_ce_irq_disable,\n\t.get_ce_msi_idx = ath12k_pci_get_ce_msi_idx,\n};\n\nstatic\nvoid ath12k_pci_read_hw_version(struct ath12k_base *ab, u32 *major, u32 *minor)\n{\n\tu32 soc_hw_version;\n\n\tsoc_hw_version = ath12k_pci_read32(ab, TCSR_SOC_HW_VERSION);\n\t*major = FIELD_GET(TCSR_SOC_HW_VERSION_MAJOR_MASK,\n\t\t\t   soc_hw_version);\n\t*minor = FIELD_GET(TCSR_SOC_HW_VERSION_MINOR_MASK,\n\t\t\t   soc_hw_version);\n\n\tath12k_dbg(ab, ATH12K_DBG_PCI,\n\t\t   \"pci tcsr_soc_hw_version major %d minor %d\\n\",\n\t\t    *major, *minor);\n}\n\nstatic int ath12k_pci_probe(struct pci_dev *pdev,\n\t\t\t    const struct pci_device_id *pci_dev)\n{\n\tstruct ath12k_base *ab;\n\tstruct ath12k_pci *ab_pci;\n\tu32 soc_hw_version_major, soc_hw_version_minor;\n\tint ret;\n\n\tab = ath12k_core_alloc(&pdev->dev, sizeof(*ab_pci), ATH12K_BUS_PCI);\n\tif (!ab) {\n\t\tdev_err(&pdev->dev, \"failed to allocate ath12k base\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tab->dev = &pdev->dev;\n\tpci_set_drvdata(pdev, ab);\n\tab_pci = ath12k_pci_priv(ab);\n\tab_pci->dev_id = pci_dev->device;\n\tab_pci->ab = ab;\n\tab_pci->pdev = pdev;\n\tab->hif.ops = &ath12k_pci_hif_ops;\n\tpci_set_drvdata(pdev, ab);\n\tspin_lock_init(&ab_pci->window_lock);\n\n\tret = ath12k_pci_claim(ab_pci, pdev);\n\tif (ret) {\n\t\tath12k_err(ab, \"failed to claim device: %d\\n\", ret);\n\t\tgoto err_free_core;\n\t}\n\n\tswitch (pci_dev->device) {\n\tcase QCN9274_DEVICE_ID:\n\t\tab_pci->msi_config = &ath12k_msi_config[0];\n\t\tab->static_window_map = true;\n\t\tab_pci->pci_ops = &ath12k_pci_ops_qcn9274;\n\t\tath12k_pci_read_hw_version(ab, &soc_hw_version_major,\n\t\t\t\t\t   &soc_hw_version_minor);\n\t\tswitch (soc_hw_version_major) {\n\t\tcase ATH12K_PCI_SOC_HW_VERSION_2:\n\t\t\tab->hw_rev = ATH12K_HW_QCN9274_HW20;\n\t\t\tbreak;\n\t\tcase ATH12K_PCI_SOC_HW_VERSION_1:\n\t\t\tab->hw_rev = ATH12K_HW_QCN9274_HW10;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Unknown hardware version found for QCN9274: 0x%x\\n\",\n\t\t\t\tsoc_hw_version_major);\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto err_pci_free_region;\n\t\t}\n\t\tbreak;\n\tcase WCN7850_DEVICE_ID:\n\t\tab_pci->msi_config = &ath12k_msi_config[0];\n\t\tab->static_window_map = false;\n\t\tab_pci->pci_ops = &ath12k_pci_ops_wcn7850;\n\t\tath12k_pci_read_hw_version(ab, &soc_hw_version_major,\n\t\t\t\t\t   &soc_hw_version_minor);\n\t\tswitch (soc_hw_version_major) {\n\t\tcase ATH12K_PCI_SOC_HW_VERSION_2:\n\t\t\tab->hw_rev = ATH12K_HW_WCN7850_HW20;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Unknown hardware version found for WCN7850: 0x%x\\n\",\n\t\t\t\tsoc_hw_version_major);\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto err_pci_free_region;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&pdev->dev, \"Unknown PCI device found: 0x%x\\n\",\n\t\t\tpci_dev->device);\n\t\tret = -EOPNOTSUPP;\n\t\tgoto err_pci_free_region;\n\t}\n\n\tret = ath12k_pci_msi_alloc(ab_pci);\n\tif (ret) {\n\t\tath12k_err(ab, \"failed to alloc msi: %d\\n\", ret);\n\t\tgoto err_pci_free_region;\n\t}\n\n\tret = ath12k_core_pre_init(ab);\n\tif (ret)\n\t\tgoto err_pci_msi_free;\n\n\tret = ath12k_mhi_register(ab_pci);\n\tif (ret) {\n\t\tath12k_err(ab, \"failed to register mhi: %d\\n\", ret);\n\t\tgoto err_pci_msi_free;\n\t}\n\n\tret = ath12k_hal_srng_init(ab);\n\tif (ret)\n\t\tgoto err_mhi_unregister;\n\n\tret = ath12k_ce_alloc_pipes(ab);\n\tif (ret) {\n\t\tath12k_err(ab, \"failed to allocate ce pipes: %d\\n\", ret);\n\t\tgoto err_hal_srng_deinit;\n\t}\n\n\tath12k_pci_init_qmi_ce_config(ab);\n\n\tret = ath12k_pci_config_irq(ab);\n\tif (ret) {\n\t\tath12k_err(ab, \"failed to config irq: %d\\n\", ret);\n\t\tgoto err_ce_free;\n\t}\n\n\tret = ath12k_core_init(ab);\n\tif (ret) {\n\t\tath12k_err(ab, \"failed to init core: %d\\n\", ret);\n\t\tgoto err_free_irq;\n\t}\n\treturn 0;\n\nerr_free_irq:\n\tath12k_pci_free_irq(ab);\n\nerr_ce_free:\n\tath12k_ce_free_pipes(ab);\n\nerr_hal_srng_deinit:\n\tath12k_hal_srng_deinit(ab);\n\nerr_mhi_unregister:\n\tath12k_mhi_unregister(ab_pci);\n\nerr_pci_msi_free:\n\tath12k_pci_msi_free(ab_pci);\n\nerr_pci_free_region:\n\tath12k_pci_free_region(ab_pci);\n\nerr_free_core:\n\tath12k_core_free(ab);\n\n\treturn ret;\n}\n\nstatic void ath12k_pci_remove(struct pci_dev *pdev)\n{\n\tstruct ath12k_base *ab = pci_get_drvdata(pdev);\n\tstruct ath12k_pci *ab_pci = ath12k_pci_priv(ab);\n\n\tif (test_bit(ATH12K_FLAG_QMI_FAIL, &ab->dev_flags)) {\n\t\tath12k_pci_power_down(ab);\n\t\tath12k_qmi_deinit_service(ab);\n\t\tgoto qmi_fail;\n\t}\n\n\tset_bit(ATH12K_FLAG_UNREGISTERING, &ab->dev_flags);\n\n\tcancel_work_sync(&ab->reset_work);\n\tath12k_core_deinit(ab);\n\nqmi_fail:\n\tath12k_mhi_unregister(ab_pci);\n\n\tath12k_pci_free_irq(ab);\n\tath12k_pci_msi_free(ab_pci);\n\tath12k_pci_free_region(ab_pci);\n\n\tath12k_hal_srng_deinit(ab);\n\tath12k_ce_free_pipes(ab);\n\tath12k_core_free(ab);\n}\n\nstatic void ath12k_pci_shutdown(struct pci_dev *pdev)\n{\n\tstruct ath12k_base *ab = pci_get_drvdata(pdev);\n\n\tath12k_pci_power_down(ab);\n}\n\nstatic __maybe_unused int ath12k_pci_pm_suspend(struct device *dev)\n{\n\tstruct ath12k_base *ab = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = ath12k_core_suspend(ab);\n\tif (ret)\n\t\tath12k_warn(ab, \"failed to suspend core: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic __maybe_unused int ath12k_pci_pm_resume(struct device *dev)\n{\n\tstruct ath12k_base *ab = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = ath12k_core_resume(ab);\n\tif (ret)\n\t\tath12k_warn(ab, \"failed to resume core: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic SIMPLE_DEV_PM_OPS(ath12k_pci_pm_ops,\n\t\t\t ath12k_pci_pm_suspend,\n\t\t\t ath12k_pci_pm_resume);\n\nstatic struct pci_driver ath12k_pci_driver = {\n\t.name = \"ath12k_pci\",\n\t.id_table = ath12k_pci_id_table,\n\t.probe = ath12k_pci_probe,\n\t.remove = ath12k_pci_remove,\n\t.shutdown = ath12k_pci_shutdown,\n\t.driver.pm = &ath12k_pci_pm_ops,\n};\n\nstatic int ath12k_pci_init(void)\n{\n\tint ret;\n\n\tret = pci_register_driver(&ath12k_pci_driver);\n\tif (ret) {\n\t\tpr_err(\"failed to register ath12k pci driver: %d\\n\",\n\t\t       ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nmodule_init(ath12k_pci_init);\n\nstatic void ath12k_pci_exit(void)\n{\n\tpci_unregister_driver(&ath12k_pci_driver);\n}\n\nmodule_exit(ath12k_pci_exit);\n\nMODULE_DESCRIPTION(\"Driver support for Qualcomm Technologies PCIe 802.11be WLAN devices\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}