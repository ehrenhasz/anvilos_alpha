{
  "module_name": "dp.c",
  "hash_id": "bd9d8b22eba85703307cb7e702cb66c8562ec45d7d8449611676bff130f423ca",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath12k/dp.c",
  "human_readable_source": "\n \n\n#include <crypto/hash.h>\n#include \"core.h\"\n#include \"dp_tx.h\"\n#include \"hal_tx.h\"\n#include \"hif.h\"\n#include \"debug.h\"\n#include \"dp_rx.h\"\n#include \"peer.h\"\n#include \"dp_mon.h\"\n\nstatic void ath12k_dp_htt_htc_tx_complete(struct ath12k_base *ab,\n\t\t\t\t\t  struct sk_buff *skb)\n{\n\tdev_kfree_skb_any(skb);\n}\n\nvoid ath12k_dp_peer_cleanup(struct ath12k *ar, int vdev_id, const u8 *addr)\n{\n\tstruct ath12k_base *ab = ar->ab;\n\tstruct ath12k_peer *peer;\n\n\t \n\n\tspin_lock_bh(&ab->base_lock);\n\tpeer = ath12k_peer_find(ab, vdev_id, addr);\n\tif (!peer) {\n\t\tath12k_warn(ab, \"failed to lookup peer %pM on vdev %d\\n\",\n\t\t\t    addr, vdev_id);\n\t\tspin_unlock_bh(&ab->base_lock);\n\t\treturn;\n\t}\n\n\tath12k_dp_rx_peer_tid_cleanup(ar, peer);\n\tcrypto_free_shash(peer->tfm_mmic);\n\tpeer->dp_setup_done = false;\n\tspin_unlock_bh(&ab->base_lock);\n}\n\nint ath12k_dp_peer_setup(struct ath12k *ar, int vdev_id, const u8 *addr)\n{\n\tstruct ath12k_base *ab = ar->ab;\n\tstruct ath12k_peer *peer;\n\tu32 reo_dest;\n\tint ret = 0, tid;\n\n\t \n\treo_dest = ar->dp.mac_id + 1;\n\tret = ath12k_wmi_set_peer_param(ar, addr, vdev_id,\n\t\t\t\t\tWMI_PEER_SET_DEFAULT_ROUTING,\n\t\t\t\t\tDP_RX_HASH_ENABLE | (reo_dest << 1));\n\n\tif (ret) {\n\t\tath12k_warn(ab, \"failed to set default routing %d peer :%pM vdev_id :%d\\n\",\n\t\t\t    ret, addr, vdev_id);\n\t\treturn ret;\n\t}\n\n\tfor (tid = 0; tid <= IEEE80211_NUM_TIDS; tid++) {\n\t\tret = ath12k_dp_rx_peer_tid_setup(ar, addr, vdev_id, tid, 1, 0,\n\t\t\t\t\t\t  HAL_PN_TYPE_NONE);\n\t\tif (ret) {\n\t\t\tath12k_warn(ab, \"failed to setup rxd tid queue for tid %d: %d\\n\",\n\t\t\t\t    tid, ret);\n\t\t\tgoto peer_clean;\n\t\t}\n\t}\n\n\tret = ath12k_dp_rx_peer_frag_setup(ar, addr, vdev_id);\n\tif (ret) {\n\t\tath12k_warn(ab, \"failed to setup rx defrag context\\n\");\n\t\tgoto peer_clean;\n\t}\n\n\t \n\n\treturn 0;\n\npeer_clean:\n\tspin_lock_bh(&ab->base_lock);\n\n\tpeer = ath12k_peer_find(ab, vdev_id, addr);\n\tif (!peer) {\n\t\tath12k_warn(ab, \"failed to find the peer to del rx tid\\n\");\n\t\tspin_unlock_bh(&ab->base_lock);\n\t\treturn -ENOENT;\n\t}\n\n\tfor (; tid >= 0; tid--)\n\t\tath12k_dp_rx_peer_tid_delete(ar, peer, tid);\n\n\tspin_unlock_bh(&ab->base_lock);\n\n\treturn ret;\n}\n\nvoid ath12k_dp_srng_cleanup(struct ath12k_base *ab, struct dp_srng *ring)\n{\n\tif (!ring->vaddr_unaligned)\n\t\treturn;\n\n\tdma_free_coherent(ab->dev, ring->size, ring->vaddr_unaligned,\n\t\t\t  ring->paddr_unaligned);\n\n\tring->vaddr_unaligned = NULL;\n}\n\nstatic int ath12k_dp_srng_find_ring_in_mask(int ring_num, const u8 *grp_mask)\n{\n\tint ext_group_num;\n\tu8 mask = 1 << ring_num;\n\n\tfor (ext_group_num = 0; ext_group_num < ATH12K_EXT_IRQ_GRP_NUM_MAX;\n\t     ext_group_num++) {\n\t\tif (mask & grp_mask[ext_group_num])\n\t\t\treturn ext_group_num;\n\t}\n\n\treturn -ENOENT;\n}\n\nstatic int ath12k_dp_srng_calculate_msi_group(struct ath12k_base *ab,\n\t\t\t\t\t      enum hal_ring_type type, int ring_num)\n{\n\tconst u8 *grp_mask;\n\n\tswitch (type) {\n\tcase HAL_WBM2SW_RELEASE:\n\t\tif (ring_num == HAL_WBM2SW_REL_ERR_RING_NUM) {\n\t\t\tgrp_mask = &ab->hw_params->ring_mask->rx_wbm_rel[0];\n\t\t\tring_num = 0;\n\t\t} else {\n\t\t\tgrp_mask = &ab->hw_params->ring_mask->tx[0];\n\t\t}\n\t\tbreak;\n\tcase HAL_REO_EXCEPTION:\n\t\tgrp_mask = &ab->hw_params->ring_mask->rx_err[0];\n\t\tbreak;\n\tcase HAL_REO_DST:\n\t\tgrp_mask = &ab->hw_params->ring_mask->rx[0];\n\t\tbreak;\n\tcase HAL_REO_STATUS:\n\t\tgrp_mask = &ab->hw_params->ring_mask->reo_status[0];\n\t\tbreak;\n\tcase HAL_RXDMA_MONITOR_STATUS:\n\tcase HAL_RXDMA_MONITOR_DST:\n\t\tgrp_mask = &ab->hw_params->ring_mask->rx_mon_dest[0];\n\t\tbreak;\n\tcase HAL_TX_MONITOR_DST:\n\t\tgrp_mask = &ab->hw_params->ring_mask->tx_mon_dest[0];\n\t\tbreak;\n\tcase HAL_RXDMA_BUF:\n\t\tgrp_mask = &ab->hw_params->ring_mask->host2rxdma[0];\n\t\tbreak;\n\tcase HAL_RXDMA_MONITOR_BUF:\n\tcase HAL_TCL_DATA:\n\tcase HAL_TCL_CMD:\n\tcase HAL_REO_CMD:\n\tcase HAL_SW2WBM_RELEASE:\n\tcase HAL_WBM_IDLE_LINK:\n\tcase HAL_TCL_STATUS:\n\tcase HAL_REO_REINJECT:\n\tcase HAL_CE_SRC:\n\tcase HAL_CE_DST:\n\tcase HAL_CE_DST_STATUS:\n\tdefault:\n\t\treturn -ENOENT;\n\t}\n\n\treturn ath12k_dp_srng_find_ring_in_mask(ring_num, grp_mask);\n}\n\nstatic void ath12k_dp_srng_msi_setup(struct ath12k_base *ab,\n\t\t\t\t     struct hal_srng_params *ring_params,\n\t\t\t\t     enum hal_ring_type type, int ring_num)\n{\n\tint msi_group_number, msi_data_count;\n\tu32 msi_data_start, msi_irq_start, addr_lo, addr_hi;\n\tint ret;\n\n\tret = ath12k_hif_get_user_msi_vector(ab, \"DP\",\n\t\t\t\t\t     &msi_data_count, &msi_data_start,\n\t\t\t\t\t     &msi_irq_start);\n\tif (ret)\n\t\treturn;\n\n\tmsi_group_number = ath12k_dp_srng_calculate_msi_group(ab, type,\n\t\t\t\t\t\t\t      ring_num);\n\tif (msi_group_number < 0) {\n\t\tath12k_dbg(ab, ATH12K_DBG_PCI,\n\t\t\t   \"ring not part of an ext_group; ring_type: %d,ring_num %d\",\n\t\t\t   type, ring_num);\n\t\tring_params->msi_addr = 0;\n\t\tring_params->msi_data = 0;\n\t\treturn;\n\t}\n\n\tif (msi_group_number > msi_data_count) {\n\t\tath12k_dbg(ab, ATH12K_DBG_PCI,\n\t\t\t   \"multiple msi_groups share one msi, msi_group_num %d\",\n\t\t\t   msi_group_number);\n\t}\n\n\tath12k_hif_get_msi_address(ab, &addr_lo, &addr_hi);\n\n\tring_params->msi_addr = addr_lo;\n\tring_params->msi_addr |= (dma_addr_t)(((uint64_t)addr_hi) << 32);\n\tring_params->msi_data = (msi_group_number % msi_data_count)\n\t\t+ msi_data_start;\n\tring_params->flags |= HAL_SRNG_FLAGS_MSI_INTR;\n}\n\nint ath12k_dp_srng_setup(struct ath12k_base *ab, struct dp_srng *ring,\n\t\t\t enum hal_ring_type type, int ring_num,\n\t\t\t int mac_id, int num_entries)\n{\n\tstruct hal_srng_params params = { 0 };\n\tint entry_sz = ath12k_hal_srng_get_entrysize(ab, type);\n\tint max_entries = ath12k_hal_srng_get_max_entries(ab, type);\n\tint ret;\n\n\tif (max_entries < 0 || entry_sz < 0)\n\t\treturn -EINVAL;\n\n\tif (num_entries > max_entries)\n\t\tnum_entries = max_entries;\n\n\tring->size = (num_entries * entry_sz) + HAL_RING_BASE_ALIGN - 1;\n\tring->vaddr_unaligned = dma_alloc_coherent(ab->dev, ring->size,\n\t\t\t\t\t\t   &ring->paddr_unaligned,\n\t\t\t\t\t\t   GFP_KERNEL);\n\tif (!ring->vaddr_unaligned)\n\t\treturn -ENOMEM;\n\n\tring->vaddr = PTR_ALIGN(ring->vaddr_unaligned, HAL_RING_BASE_ALIGN);\n\tring->paddr = ring->paddr_unaligned + ((unsigned long)ring->vaddr -\n\t\t      (unsigned long)ring->vaddr_unaligned);\n\n\tparams.ring_base_vaddr = ring->vaddr;\n\tparams.ring_base_paddr = ring->paddr;\n\tparams.num_entries = num_entries;\n\tath12k_dp_srng_msi_setup(ab, &params, type, ring_num + mac_id);\n\n\tswitch (type) {\n\tcase HAL_REO_DST:\n\t\tparams.intr_batch_cntr_thres_entries =\n\t\t\t\t\tHAL_SRNG_INT_BATCH_THRESHOLD_RX;\n\t\tparams.intr_timer_thres_us = HAL_SRNG_INT_TIMER_THRESHOLD_RX;\n\t\tbreak;\n\tcase HAL_RXDMA_BUF:\n\tcase HAL_RXDMA_MONITOR_BUF:\n\tcase HAL_RXDMA_MONITOR_STATUS:\n\t\tparams.low_threshold = num_entries >> 3;\n\t\tparams.flags |= HAL_SRNG_FLAGS_LOW_THRESH_INTR_EN;\n\t\tparams.intr_batch_cntr_thres_entries = 0;\n\t\tparams.intr_timer_thres_us = HAL_SRNG_INT_TIMER_THRESHOLD_RX;\n\t\tbreak;\n\tcase HAL_TX_MONITOR_DST:\n\t\tparams.low_threshold = DP_TX_MONITOR_BUF_SIZE_MAX >> 3;\n\t\tparams.flags |= HAL_SRNG_FLAGS_LOW_THRESH_INTR_EN;\n\t\tparams.intr_batch_cntr_thres_entries = 0;\n\t\tparams.intr_timer_thres_us = HAL_SRNG_INT_TIMER_THRESHOLD_RX;\n\t\tbreak;\n\tcase HAL_WBM2SW_RELEASE:\n\t\tif (ab->hw_params->hw_ops->dp_srng_is_tx_comp_ring(ring_num)) {\n\t\t\tparams.intr_batch_cntr_thres_entries =\n\t\t\t\t\tHAL_SRNG_INT_BATCH_THRESHOLD_TX;\n\t\t\tparams.intr_timer_thres_us =\n\t\t\t\t\tHAL_SRNG_INT_TIMER_THRESHOLD_TX;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tfallthrough;\n\tcase HAL_REO_EXCEPTION:\n\tcase HAL_REO_REINJECT:\n\tcase HAL_REO_CMD:\n\tcase HAL_REO_STATUS:\n\tcase HAL_TCL_DATA:\n\tcase HAL_TCL_CMD:\n\tcase HAL_TCL_STATUS:\n\tcase HAL_WBM_IDLE_LINK:\n\tcase HAL_SW2WBM_RELEASE:\n\tcase HAL_RXDMA_DST:\n\tcase HAL_RXDMA_MONITOR_DST:\n\tcase HAL_RXDMA_MONITOR_DESC:\n\t\tparams.intr_batch_cntr_thres_entries =\n\t\t\t\t\tHAL_SRNG_INT_BATCH_THRESHOLD_OTHER;\n\t\tparams.intr_timer_thres_us = HAL_SRNG_INT_TIMER_THRESHOLD_OTHER;\n\t\tbreak;\n\tcase HAL_RXDMA_DIR_BUF:\n\t\tbreak;\n\tdefault:\n\t\tath12k_warn(ab, \"Not a valid ring type in dp :%d\\n\", type);\n\t\treturn -EINVAL;\n\t}\n\n\tret = ath12k_hal_srng_setup(ab, type, ring_num, mac_id, &params);\n\tif (ret < 0) {\n\t\tath12k_warn(ab, \"failed to setup srng: %d ring_id %d\\n\",\n\t\t\t    ret, ring_num);\n\t\treturn ret;\n\t}\n\n\tring->ring_id = ret;\n\n\treturn 0;\n}\n\nstatic\nu32 ath12k_dp_tx_get_vdev_bank_config(struct ath12k_base *ab, struct ath12k_vif *arvif)\n{\n\tu32 bank_config = 0;\n\n\t \n\tif (arvif->tx_encap_type == HAL_TCL_ENCAP_TYPE_RAW &&\n\t    test_bit(ATH12K_FLAG_HW_CRYPTO_DISABLED, &ab->dev_flags))\n\t\tbank_config |=\n\t\t\tu32_encode_bits(ath12k_dp_tx_get_encrypt_type(arvif->key_cipher),\n\t\t\t\t\tHAL_TX_BANK_CONFIG_ENCRYPT_TYPE);\n\n\tbank_config |= u32_encode_bits(arvif->tx_encap_type,\n\t\t\t\t\tHAL_TX_BANK_CONFIG_ENCAP_TYPE);\n\tbank_config |= u32_encode_bits(0, HAL_TX_BANK_CONFIG_SRC_BUFFER_SWAP) |\n\t\t\tu32_encode_bits(0, HAL_TX_BANK_CONFIG_LINK_META_SWAP) |\n\t\t\tu32_encode_bits(0, HAL_TX_BANK_CONFIG_EPD);\n\n\t \n\tbank_config |= u32_encode_bits(0, HAL_TX_BANK_CONFIG_INDEX_LOOKUP_EN);\n\n\tbank_config |= u32_encode_bits(arvif->hal_addr_search_flags & HAL_TX_ADDRX_EN,\n\t\t\t\t\tHAL_TX_BANK_CONFIG_ADDRX_EN) |\n\t\t\tu32_encode_bits(!!(arvif->hal_addr_search_flags &\n\t\t\t\t\tHAL_TX_ADDRY_EN),\n\t\t\t\t\tHAL_TX_BANK_CONFIG_ADDRY_EN);\n\n\tbank_config |= u32_encode_bits(ieee80211_vif_is_mesh(arvif->vif) ? 3 : 0,\n\t\t\t\t\tHAL_TX_BANK_CONFIG_MESH_EN) |\n\t\t\tu32_encode_bits(arvif->vdev_id_check_en,\n\t\t\t\t\tHAL_TX_BANK_CONFIG_VDEV_ID_CHECK_EN);\n\n\tbank_config |= u32_encode_bits(0, HAL_TX_BANK_CONFIG_DSCP_TIP_MAP_ID);\n\n\treturn bank_config;\n}\n\nstatic int ath12k_dp_tx_get_bank_profile(struct ath12k_base *ab, struct ath12k_vif *arvif,\n\t\t\t\t\t struct ath12k_dp *dp)\n{\n\tint bank_id = DP_INVALID_BANK_ID;\n\tint i;\n\tu32 bank_config;\n\tbool configure_register = false;\n\n\t \n\tbank_config = ath12k_dp_tx_get_vdev_bank_config(ab, arvif);\n\n\tspin_lock_bh(&dp->tx_bank_lock);\n\t \n\tfor (i = 0; i < dp->num_bank_profiles; i++) {\n\t\tif (dp->bank_profiles[i].is_configured &&\n\t\t    (dp->bank_profiles[i].bank_config ^ bank_config) == 0) {\n\t\t\tbank_id = i;\n\t\t\tgoto inc_ref_and_return;\n\t\t}\n\t\tif (!dp->bank_profiles[i].is_configured ||\n\t\t    !dp->bank_profiles[i].num_users) {\n\t\t\tbank_id = i;\n\t\t\tgoto configure_and_return;\n\t\t}\n\t}\n\n\tif (bank_id == DP_INVALID_BANK_ID) {\n\t\tspin_unlock_bh(&dp->tx_bank_lock);\n\t\tath12k_err(ab, \"unable to find TX bank!\");\n\t\treturn bank_id;\n\t}\n\nconfigure_and_return:\n\tdp->bank_profiles[bank_id].is_configured = true;\n\tdp->bank_profiles[bank_id].bank_config = bank_config;\n\tconfigure_register = true;\ninc_ref_and_return:\n\tdp->bank_profiles[bank_id].num_users++;\n\tspin_unlock_bh(&dp->tx_bank_lock);\n\n\tif (configure_register)\n\t\tath12k_hal_tx_configure_bank_register(ab, bank_config, bank_id);\n\n\tath12k_dbg(ab, ATH12K_DBG_DP_HTT, \"dp_htt tcl bank_id %d input 0x%x match 0x%x num_users %u\",\n\t\t   bank_id, bank_config, dp->bank_profiles[bank_id].bank_config,\n\t\t   dp->bank_profiles[bank_id].num_users);\n\n\treturn bank_id;\n}\n\nvoid ath12k_dp_tx_put_bank_profile(struct ath12k_dp *dp, u8 bank_id)\n{\n\tspin_lock_bh(&dp->tx_bank_lock);\n\tdp->bank_profiles[bank_id].num_users--;\n\tspin_unlock_bh(&dp->tx_bank_lock);\n}\n\nstatic void ath12k_dp_deinit_bank_profiles(struct ath12k_base *ab)\n{\n\tstruct ath12k_dp *dp = &ab->dp;\n\n\tkfree(dp->bank_profiles);\n\tdp->bank_profiles = NULL;\n}\n\nstatic int ath12k_dp_init_bank_profiles(struct ath12k_base *ab)\n{\n\tstruct ath12k_dp *dp = &ab->dp;\n\tu32 num_tcl_banks = ab->hw_params->num_tcl_banks;\n\tint i;\n\n\tdp->num_bank_profiles = num_tcl_banks;\n\tdp->bank_profiles = kmalloc_array(num_tcl_banks,\n\t\t\t\t\t  sizeof(struct ath12k_dp_tx_bank_profile),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!dp->bank_profiles)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&dp->tx_bank_lock);\n\n\tfor (i = 0; i < num_tcl_banks; i++) {\n\t\tdp->bank_profiles[i].is_configured = false;\n\t\tdp->bank_profiles[i].num_users = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic void ath12k_dp_srng_common_cleanup(struct ath12k_base *ab)\n{\n\tstruct ath12k_dp *dp = &ab->dp;\n\tint i;\n\n\tath12k_dp_srng_cleanup(ab, &dp->reo_status_ring);\n\tath12k_dp_srng_cleanup(ab, &dp->reo_cmd_ring);\n\tath12k_dp_srng_cleanup(ab, &dp->reo_except_ring);\n\tath12k_dp_srng_cleanup(ab, &dp->rx_rel_ring);\n\tath12k_dp_srng_cleanup(ab, &dp->reo_reinject_ring);\n\tfor (i = 0; i < ab->hw_params->max_tx_ring; i++) {\n\t\tath12k_dp_srng_cleanup(ab, &dp->tx_ring[i].tcl_comp_ring);\n\t\tath12k_dp_srng_cleanup(ab, &dp->tx_ring[i].tcl_data_ring);\n\t}\n\tath12k_dp_srng_cleanup(ab, &dp->tcl_status_ring);\n\tath12k_dp_srng_cleanup(ab, &dp->tcl_cmd_ring);\n\tath12k_dp_srng_cleanup(ab, &dp->wbm_desc_rel_ring);\n}\n\nstatic int ath12k_dp_srng_common_setup(struct ath12k_base *ab)\n{\n\tstruct ath12k_dp *dp = &ab->dp;\n\tconst struct ath12k_hal_tcl_to_wbm_rbm_map *map;\n\tstruct hal_srng *srng;\n\tint i, ret, tx_comp_ring_num;\n\tu32 ring_hash_map;\n\n\tret = ath12k_dp_srng_setup(ab, &dp->wbm_desc_rel_ring,\n\t\t\t\t   HAL_SW2WBM_RELEASE, 0, 0,\n\t\t\t\t   DP_WBM_RELEASE_RING_SIZE);\n\tif (ret) {\n\t\tath12k_warn(ab, \"failed to set up wbm2sw_release ring :%d\\n\",\n\t\t\t    ret);\n\t\tgoto err;\n\t}\n\n\tret = ath12k_dp_srng_setup(ab, &dp->tcl_cmd_ring, HAL_TCL_CMD, 0, 0,\n\t\t\t\t   DP_TCL_CMD_RING_SIZE);\n\tif (ret) {\n\t\tath12k_warn(ab, \"failed to set up tcl_cmd ring :%d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tret = ath12k_dp_srng_setup(ab, &dp->tcl_status_ring, HAL_TCL_STATUS,\n\t\t\t\t   0, 0, DP_TCL_STATUS_RING_SIZE);\n\tif (ret) {\n\t\tath12k_warn(ab, \"failed to set up tcl_status ring :%d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tfor (i = 0; i < ab->hw_params->max_tx_ring; i++) {\n\t\tmap = ab->hw_params->hal_ops->tcl_to_wbm_rbm_map;\n\t\ttx_comp_ring_num = map[i].wbm_ring_num;\n\n\t\tret = ath12k_dp_srng_setup(ab, &dp->tx_ring[i].tcl_data_ring,\n\t\t\t\t\t   HAL_TCL_DATA, i, 0,\n\t\t\t\t\t   DP_TCL_DATA_RING_SIZE);\n\t\tif (ret) {\n\t\t\tath12k_warn(ab, \"failed to set up tcl_data ring (%d) :%d\\n\",\n\t\t\t\t    i, ret);\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = ath12k_dp_srng_setup(ab, &dp->tx_ring[i].tcl_comp_ring,\n\t\t\t\t\t   HAL_WBM2SW_RELEASE, tx_comp_ring_num, 0,\n\t\t\t\t\t   DP_TX_COMP_RING_SIZE);\n\t\tif (ret) {\n\t\t\tath12k_warn(ab, \"failed to set up tcl_comp ring (%d) :%d\\n\",\n\t\t\t\t    tx_comp_ring_num, ret);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tret = ath12k_dp_srng_setup(ab, &dp->reo_reinject_ring, HAL_REO_REINJECT,\n\t\t\t\t   0, 0, DP_REO_REINJECT_RING_SIZE);\n\tif (ret) {\n\t\tath12k_warn(ab, \"failed to set up reo_reinject ring :%d\\n\",\n\t\t\t    ret);\n\t\tgoto err;\n\t}\n\n\tret = ath12k_dp_srng_setup(ab, &dp->rx_rel_ring, HAL_WBM2SW_RELEASE,\n\t\t\t\t   HAL_WBM2SW_REL_ERR_RING_NUM, 0,\n\t\t\t\t   DP_RX_RELEASE_RING_SIZE);\n\tif (ret) {\n\t\tath12k_warn(ab, \"failed to set up rx_rel ring :%d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tret = ath12k_dp_srng_setup(ab, &dp->reo_except_ring, HAL_REO_EXCEPTION,\n\t\t\t\t   0, 0, DP_REO_EXCEPTION_RING_SIZE);\n\tif (ret) {\n\t\tath12k_warn(ab, \"failed to set up reo_exception ring :%d\\n\",\n\t\t\t    ret);\n\t\tgoto err;\n\t}\n\n\tret = ath12k_dp_srng_setup(ab, &dp->reo_cmd_ring, HAL_REO_CMD,\n\t\t\t\t   0, 0, DP_REO_CMD_RING_SIZE);\n\tif (ret) {\n\t\tath12k_warn(ab, \"failed to set up reo_cmd ring :%d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tsrng = &ab->hal.srng_list[dp->reo_cmd_ring.ring_id];\n\tath12k_hal_reo_init_cmd_ring(ab, srng);\n\n\tret = ath12k_dp_srng_setup(ab, &dp->reo_status_ring, HAL_REO_STATUS,\n\t\t\t\t   0, 0, DP_REO_STATUS_RING_SIZE);\n\tif (ret) {\n\t\tath12k_warn(ab, \"failed to set up reo_status ring :%d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\t \n\tring_hash_map = HAL_HASH_ROUTING_RING_SW1 |\n\t\t\tHAL_HASH_ROUTING_RING_SW2 << 4 |\n\t\t\tHAL_HASH_ROUTING_RING_SW3 << 8 |\n\t\t\tHAL_HASH_ROUTING_RING_SW4 << 12 |\n\t\t\tHAL_HASH_ROUTING_RING_SW1 << 16 |\n\t\t\tHAL_HASH_ROUTING_RING_SW2 << 20 |\n\t\t\tHAL_HASH_ROUTING_RING_SW3 << 24 |\n\t\t\tHAL_HASH_ROUTING_RING_SW4 << 28;\n\n\tath12k_hal_reo_hw_setup(ab, ring_hash_map);\n\n\treturn 0;\n\nerr:\n\tath12k_dp_srng_common_cleanup(ab);\n\n\treturn ret;\n}\n\nstatic void ath12k_dp_scatter_idle_link_desc_cleanup(struct ath12k_base *ab)\n{\n\tstruct ath12k_dp *dp = &ab->dp;\n\tstruct hal_wbm_idle_scatter_list *slist = dp->scatter_list;\n\tint i;\n\n\tfor (i = 0; i < DP_IDLE_SCATTER_BUFS_MAX; i++) {\n\t\tif (!slist[i].vaddr)\n\t\t\tcontinue;\n\n\t\tdma_free_coherent(ab->dev, HAL_WBM_IDLE_SCATTER_BUF_SIZE_MAX,\n\t\t\t\t  slist[i].vaddr, slist[i].paddr);\n\t\tslist[i].vaddr = NULL;\n\t}\n}\n\nstatic int ath12k_dp_scatter_idle_link_desc_setup(struct ath12k_base *ab,\n\t\t\t\t\t\t  int size,\n\t\t\t\t\t\t  u32 n_link_desc_bank,\n\t\t\t\t\t\t  u32 n_link_desc,\n\t\t\t\t\t\t  u32 last_bank_sz)\n{\n\tstruct ath12k_dp *dp = &ab->dp;\n\tstruct dp_link_desc_bank *link_desc_banks = dp->link_desc_banks;\n\tstruct hal_wbm_idle_scatter_list *slist = dp->scatter_list;\n\tu32 n_entries_per_buf;\n\tint num_scatter_buf, scatter_idx;\n\tstruct hal_wbm_link_desc *scatter_buf;\n\tint align_bytes, n_entries;\n\tdma_addr_t paddr;\n\tint rem_entries;\n\tint i;\n\tint ret = 0;\n\tu32 end_offset, cookie;\n\n\tn_entries_per_buf = HAL_WBM_IDLE_SCATTER_BUF_SIZE /\n\t\tath12k_hal_srng_get_entrysize(ab, HAL_WBM_IDLE_LINK);\n\tnum_scatter_buf = DIV_ROUND_UP(size, HAL_WBM_IDLE_SCATTER_BUF_SIZE);\n\n\tif (num_scatter_buf > DP_IDLE_SCATTER_BUFS_MAX)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < num_scatter_buf; i++) {\n\t\tslist[i].vaddr = dma_alloc_coherent(ab->dev,\n\t\t\t\t\t\t    HAL_WBM_IDLE_SCATTER_BUF_SIZE_MAX,\n\t\t\t\t\t\t    &slist[i].paddr, GFP_KERNEL);\n\t\tif (!slist[i].vaddr) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tscatter_idx = 0;\n\tscatter_buf = slist[scatter_idx].vaddr;\n\trem_entries = n_entries_per_buf;\n\n\tfor (i = 0; i < n_link_desc_bank; i++) {\n\t\talign_bytes = link_desc_banks[i].vaddr -\n\t\t\t      link_desc_banks[i].vaddr_unaligned;\n\t\tn_entries = (DP_LINK_DESC_ALLOC_SIZE_THRESH - align_bytes) /\n\t\t\t     HAL_LINK_DESC_SIZE;\n\t\tpaddr = link_desc_banks[i].paddr;\n\t\twhile (n_entries) {\n\t\t\tcookie = DP_LINK_DESC_COOKIE_SET(n_entries, i);\n\t\t\tath12k_hal_set_link_desc_addr(scatter_buf, cookie, paddr);\n\t\t\tn_entries--;\n\t\t\tpaddr += HAL_LINK_DESC_SIZE;\n\t\t\tif (rem_entries) {\n\t\t\t\trem_entries--;\n\t\t\t\tscatter_buf++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\trem_entries = n_entries_per_buf;\n\t\t\tscatter_idx++;\n\t\t\tscatter_buf = slist[scatter_idx].vaddr;\n\t\t}\n\t}\n\n\tend_offset = (scatter_buf - slist[scatter_idx].vaddr) *\n\t\t     sizeof(struct hal_wbm_link_desc);\n\tath12k_hal_setup_link_idle_list(ab, slist, num_scatter_buf,\n\t\t\t\t\tn_link_desc, end_offset);\n\n\treturn 0;\n\nerr:\n\tath12k_dp_scatter_idle_link_desc_cleanup(ab);\n\n\treturn ret;\n}\n\nstatic void\nath12k_dp_link_desc_bank_free(struct ath12k_base *ab,\n\t\t\t      struct dp_link_desc_bank *link_desc_banks)\n{\n\tint i;\n\n\tfor (i = 0; i < DP_LINK_DESC_BANKS_MAX; i++) {\n\t\tif (link_desc_banks[i].vaddr_unaligned) {\n\t\t\tdma_free_coherent(ab->dev,\n\t\t\t\t\t  link_desc_banks[i].size,\n\t\t\t\t\t  link_desc_banks[i].vaddr_unaligned,\n\t\t\t\t\t  link_desc_banks[i].paddr_unaligned);\n\t\t\tlink_desc_banks[i].vaddr_unaligned = NULL;\n\t\t}\n\t}\n}\n\nstatic int ath12k_dp_link_desc_bank_alloc(struct ath12k_base *ab,\n\t\t\t\t\t  struct dp_link_desc_bank *desc_bank,\n\t\t\t\t\t  int n_link_desc_bank,\n\t\t\t\t\t  int last_bank_sz)\n{\n\tstruct ath12k_dp *dp = &ab->dp;\n\tint i;\n\tint ret = 0;\n\tint desc_sz = DP_LINK_DESC_ALLOC_SIZE_THRESH;\n\n\tfor (i = 0; i < n_link_desc_bank; i++) {\n\t\tif (i == (n_link_desc_bank - 1) && last_bank_sz)\n\t\t\tdesc_sz = last_bank_sz;\n\n\t\tdesc_bank[i].vaddr_unaligned =\n\t\t\t\t\tdma_alloc_coherent(ab->dev, desc_sz,\n\t\t\t\t\t\t\t   &desc_bank[i].paddr_unaligned,\n\t\t\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!desc_bank[i].vaddr_unaligned) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tdesc_bank[i].vaddr = PTR_ALIGN(desc_bank[i].vaddr_unaligned,\n\t\t\t\t\t       HAL_LINK_DESC_ALIGN);\n\t\tdesc_bank[i].paddr = desc_bank[i].paddr_unaligned +\n\t\t\t\t     ((unsigned long)desc_bank[i].vaddr -\n\t\t\t\t      (unsigned long)desc_bank[i].vaddr_unaligned);\n\t\tdesc_bank[i].size = desc_sz;\n\t}\n\n\treturn 0;\n\nerr:\n\tath12k_dp_link_desc_bank_free(ab, dp->link_desc_banks);\n\n\treturn ret;\n}\n\nvoid ath12k_dp_link_desc_cleanup(struct ath12k_base *ab,\n\t\t\t\t struct dp_link_desc_bank *desc_bank,\n\t\t\t\t u32 ring_type, struct dp_srng *ring)\n{\n\tath12k_dp_link_desc_bank_free(ab, desc_bank);\n\n\tif (ring_type != HAL_RXDMA_MONITOR_DESC) {\n\t\tath12k_dp_srng_cleanup(ab, ring);\n\t\tath12k_dp_scatter_idle_link_desc_cleanup(ab);\n\t}\n}\n\nstatic int ath12k_wbm_idle_ring_setup(struct ath12k_base *ab, u32 *n_link_desc)\n{\n\tstruct ath12k_dp *dp = &ab->dp;\n\tu32 n_mpdu_link_desc, n_mpdu_queue_desc;\n\tu32 n_tx_msdu_link_desc, n_rx_msdu_link_desc;\n\tint ret = 0;\n\n\tn_mpdu_link_desc = (DP_NUM_TIDS_MAX * DP_AVG_MPDUS_PER_TID_MAX) /\n\t\t\t   HAL_NUM_MPDUS_PER_LINK_DESC;\n\n\tn_mpdu_queue_desc = n_mpdu_link_desc /\n\t\t\t    HAL_NUM_MPDU_LINKS_PER_QUEUE_DESC;\n\n\tn_tx_msdu_link_desc = (DP_NUM_TIDS_MAX * DP_AVG_FLOWS_PER_TID *\n\t\t\t       DP_AVG_MSDUS_PER_FLOW) /\n\t\t\t      HAL_NUM_TX_MSDUS_PER_LINK_DESC;\n\n\tn_rx_msdu_link_desc = (DP_NUM_TIDS_MAX * DP_AVG_MPDUS_PER_TID_MAX *\n\t\t\t       DP_AVG_MSDUS_PER_MPDU) /\n\t\t\t      HAL_NUM_RX_MSDUS_PER_LINK_DESC;\n\n\t*n_link_desc = n_mpdu_link_desc + n_mpdu_queue_desc +\n\t\t      n_tx_msdu_link_desc + n_rx_msdu_link_desc;\n\n\tif (*n_link_desc & (*n_link_desc - 1))\n\t\t*n_link_desc = 1 << fls(*n_link_desc);\n\n\tret = ath12k_dp_srng_setup(ab, &dp->wbm_idle_ring,\n\t\t\t\t   HAL_WBM_IDLE_LINK, 0, 0, *n_link_desc);\n\tif (ret) {\n\t\tath12k_warn(ab, \"failed to setup wbm_idle_ring: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\treturn ret;\n}\n\nint ath12k_dp_link_desc_setup(struct ath12k_base *ab,\n\t\t\t      struct dp_link_desc_bank *link_desc_banks,\n\t\t\t      u32 ring_type, struct hal_srng *srng,\n\t\t\t      u32 n_link_desc)\n{\n\tu32 tot_mem_sz;\n\tu32 n_link_desc_bank, last_bank_sz;\n\tu32 entry_sz, align_bytes, n_entries;\n\tstruct hal_wbm_link_desc *desc;\n\tu32 paddr;\n\tint i, ret;\n\tu32 cookie;\n\n\ttot_mem_sz = n_link_desc * HAL_LINK_DESC_SIZE;\n\ttot_mem_sz += HAL_LINK_DESC_ALIGN;\n\n\tif (tot_mem_sz <= DP_LINK_DESC_ALLOC_SIZE_THRESH) {\n\t\tn_link_desc_bank = 1;\n\t\tlast_bank_sz = tot_mem_sz;\n\t} else {\n\t\tn_link_desc_bank = tot_mem_sz /\n\t\t\t\t   (DP_LINK_DESC_ALLOC_SIZE_THRESH -\n\t\t\t\t    HAL_LINK_DESC_ALIGN);\n\t\tlast_bank_sz = tot_mem_sz %\n\t\t\t       (DP_LINK_DESC_ALLOC_SIZE_THRESH -\n\t\t\t\tHAL_LINK_DESC_ALIGN);\n\n\t\tif (last_bank_sz)\n\t\t\tn_link_desc_bank += 1;\n\t}\n\n\tif (n_link_desc_bank > DP_LINK_DESC_BANKS_MAX)\n\t\treturn -EINVAL;\n\n\tret = ath12k_dp_link_desc_bank_alloc(ab, link_desc_banks,\n\t\t\t\t\t     n_link_desc_bank, last_bank_sz);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tentry_sz = ath12k_hal_srng_get_entrysize(ab, ring_type);\n\ttot_mem_sz = entry_sz * n_link_desc;\n\n\t \n\tif (tot_mem_sz > DP_LINK_DESC_ALLOC_SIZE_THRESH &&\n\t    ring_type != HAL_RXDMA_MONITOR_DESC) {\n\t\tret = ath12k_dp_scatter_idle_link_desc_setup(ab, tot_mem_sz,\n\t\t\t\t\t\t\t     n_link_desc_bank,\n\t\t\t\t\t\t\t     n_link_desc,\n\t\t\t\t\t\t\t     last_bank_sz);\n\t\tif (ret) {\n\t\t\tath12k_warn(ab, \"failed to setup scatting idle list descriptor :%d\\n\",\n\t\t\t\t    ret);\n\t\t\tgoto fail_desc_bank_free;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tspin_lock_bh(&srng->lock);\n\n\tath12k_hal_srng_access_begin(ab, srng);\n\n\tfor (i = 0; i < n_link_desc_bank; i++) {\n\t\talign_bytes = link_desc_banks[i].vaddr -\n\t\t\t      link_desc_banks[i].vaddr_unaligned;\n\t\tn_entries = (link_desc_banks[i].size - align_bytes) /\n\t\t\t    HAL_LINK_DESC_SIZE;\n\t\tpaddr = link_desc_banks[i].paddr;\n\t\twhile (n_entries &&\n\t\t       (desc = ath12k_hal_srng_src_get_next_entry(ab, srng))) {\n\t\t\tcookie = DP_LINK_DESC_COOKIE_SET(n_entries, i);\n\t\t\tath12k_hal_set_link_desc_addr(desc,\n\t\t\t\t\t\t      cookie, paddr);\n\t\t\tn_entries--;\n\t\t\tpaddr += HAL_LINK_DESC_SIZE;\n\t\t}\n\t}\n\n\tath12k_hal_srng_access_end(ab, srng);\n\n\tspin_unlock_bh(&srng->lock);\n\n\treturn 0;\n\nfail_desc_bank_free:\n\tath12k_dp_link_desc_bank_free(ab, link_desc_banks);\n\n\treturn ret;\n}\n\nint ath12k_dp_service_srng(struct ath12k_base *ab,\n\t\t\t   struct ath12k_ext_irq_grp *irq_grp,\n\t\t\t   int budget)\n{\n\tstruct napi_struct *napi = &irq_grp->napi;\n\tint grp_id = irq_grp->grp_id;\n\tint work_done = 0;\n\tint i = 0, j;\n\tint tot_work_done = 0;\n\tenum dp_monitor_mode monitor_mode;\n\tu8 ring_mask;\n\n\twhile (i < ab->hw_params->max_tx_ring) {\n\t\tif (ab->hw_params->ring_mask->tx[grp_id] &\n\t\t\tBIT(ab->hw_params->hal_ops->tcl_to_wbm_rbm_map[i].wbm_ring_num))\n\t\t\tath12k_dp_tx_completion_handler(ab, i);\n\t\ti++;\n\t}\n\n\tif (ab->hw_params->ring_mask->rx_err[grp_id]) {\n\t\twork_done = ath12k_dp_rx_process_err(ab, napi, budget);\n\t\tbudget -= work_done;\n\t\ttot_work_done += work_done;\n\t\tif (budget <= 0)\n\t\t\tgoto done;\n\t}\n\n\tif (ab->hw_params->ring_mask->rx_wbm_rel[grp_id]) {\n\t\twork_done = ath12k_dp_rx_process_wbm_err(ab,\n\t\t\t\t\t\t\t napi,\n\t\t\t\t\t\t\t budget);\n\t\tbudget -= work_done;\n\t\ttot_work_done += work_done;\n\n\t\tif (budget <= 0)\n\t\t\tgoto done;\n\t}\n\n\tif (ab->hw_params->ring_mask->rx[grp_id]) {\n\t\ti = fls(ab->hw_params->ring_mask->rx[grp_id]) - 1;\n\t\twork_done = ath12k_dp_rx_process(ab, i, napi,\n\t\t\t\t\t\t budget);\n\t\tbudget -= work_done;\n\t\ttot_work_done += work_done;\n\t\tif (budget <= 0)\n\t\t\tgoto done;\n\t}\n\n\tif (ab->hw_params->ring_mask->rx_mon_dest[grp_id]) {\n\t\tmonitor_mode = ATH12K_DP_RX_MONITOR_MODE;\n\t\tring_mask = ab->hw_params->ring_mask->rx_mon_dest[grp_id];\n\t\tfor (i = 0; i < ab->num_radios; i++) {\n\t\t\tfor (j = 0; j < ab->hw_params->num_rxmda_per_pdev; j++) {\n\t\t\t\tint id = i * ab->hw_params->num_rxmda_per_pdev + j;\n\n\t\t\t\tif (ring_mask & BIT(id)) {\n\t\t\t\t\twork_done =\n\t\t\t\t\tath12k_dp_mon_process_ring(ab, id, napi, budget,\n\t\t\t\t\t\t\t\t   monitor_mode);\n\t\t\t\t\tbudget -= work_done;\n\t\t\t\t\ttot_work_done += work_done;\n\n\t\t\t\t\tif (budget <= 0)\n\t\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ab->hw_params->ring_mask->tx_mon_dest[grp_id]) {\n\t\tmonitor_mode = ATH12K_DP_TX_MONITOR_MODE;\n\t\tring_mask = ab->hw_params->ring_mask->tx_mon_dest[grp_id];\n\t\tfor (i = 0; i < ab->num_radios; i++) {\n\t\t\tfor (j = 0; j < ab->hw_params->num_rxmda_per_pdev; j++) {\n\t\t\t\tint id = i * ab->hw_params->num_rxmda_per_pdev + j;\n\n\t\t\t\tif (ring_mask & BIT(id)) {\n\t\t\t\t\twork_done =\n\t\t\t\t\tath12k_dp_mon_process_ring(ab, id, napi, budget,\n\t\t\t\t\t\t\t\t   monitor_mode);\n\t\t\t\t\tbudget -= work_done;\n\t\t\t\t\ttot_work_done += work_done;\n\n\t\t\t\t\tif (budget <= 0)\n\t\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ab->hw_params->ring_mask->reo_status[grp_id])\n\t\tath12k_dp_rx_process_reo_status(ab);\n\n\tif (ab->hw_params->ring_mask->host2rxdma[grp_id]) {\n\t\tstruct ath12k_dp *dp = &ab->dp;\n\t\tstruct dp_rxdma_ring *rx_ring = &dp->rx_refill_buf_ring;\n\n\t\tath12k_dp_rx_bufs_replenish(ab, 0, rx_ring, 0,\n\t\t\t\t\t    ab->hw_params->hal_params->rx_buf_rbm,\n\t\t\t\t\t    true);\n\t}\n\n\t \n\ndone:\n\treturn tot_work_done;\n}\n\nvoid ath12k_dp_pdev_free(struct ath12k_base *ab)\n{\n\tint i;\n\n\tdel_timer_sync(&ab->mon_reap_timer);\n\n\tfor (i = 0; i < ab->num_radios; i++)\n\t\tath12k_dp_rx_pdev_free(ab, i);\n}\n\nvoid ath12k_dp_pdev_pre_alloc(struct ath12k_base *ab)\n{\n\tstruct ath12k *ar;\n\tstruct ath12k_pdev_dp *dp;\n\tint i;\n\n\tfor (i = 0; i <  ab->num_radios; i++) {\n\t\tar = ab->pdevs[i].ar;\n\t\tdp = &ar->dp;\n\t\tdp->mac_id = i;\n\t\tatomic_set(&dp->num_tx_pending, 0);\n\t\tinit_waitqueue_head(&dp->tx_empty_waitq);\n\n\t\t \n\t}\n}\n\nstatic void ath12k_dp_service_mon_ring(struct timer_list *t)\n{\n\tstruct ath12k_base *ab = from_timer(ab, t, mon_reap_timer);\n\tint i;\n\n\tfor (i = 0; i < ab->hw_params->num_rxmda_per_pdev; i++)\n\t\tath12k_dp_mon_process_ring(ab, i, NULL, DP_MON_SERVICE_BUDGET,\n\t\t\t\t\t   ATH12K_DP_RX_MONITOR_MODE);\n\n\tmod_timer(&ab->mon_reap_timer, jiffies +\n\t\t  msecs_to_jiffies(ATH12K_MON_TIMER_INTERVAL));\n}\n\nstatic void ath12k_dp_mon_reap_timer_init(struct ath12k_base *ab)\n{\n\tif (ab->hw_params->rxdma1_enable)\n\t\treturn;\n\n\ttimer_setup(&ab->mon_reap_timer, ath12k_dp_service_mon_ring, 0);\n}\n\nint ath12k_dp_pdev_alloc(struct ath12k_base *ab)\n{\n\tstruct ath12k *ar;\n\tint ret;\n\tint i;\n\n\tret = ath12k_dp_rx_htt_setup(ab);\n\tif (ret)\n\t\tgoto out;\n\n\tath12k_dp_mon_reap_timer_init(ab);\n\n\t \n\tfor (i = 0; i < ab->num_radios; i++) {\n\t\tar = ab->pdevs[i].ar;\n\t\tret = ath12k_dp_rx_pdev_alloc(ab, i);\n\t\tif (ret) {\n\t\t\tath12k_warn(ab, \"failed to allocate pdev rx for pdev_id :%d\\n\",\n\t\t\t\t    i);\n\t\t\tgoto err;\n\t\t}\n\t\tret = ath12k_dp_rx_pdev_mon_attach(ar);\n\t\tif (ret) {\n\t\t\tath12k_warn(ab, \"failed to initialize mon pdev %d\\n\", i);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn 0;\nerr:\n\tath12k_dp_pdev_free(ab);\nout:\n\treturn ret;\n}\n\nint ath12k_dp_htt_connect(struct ath12k_dp *dp)\n{\n\tstruct ath12k_htc_svc_conn_req conn_req = {0};\n\tstruct ath12k_htc_svc_conn_resp conn_resp = {0};\n\tint status;\n\n\tconn_req.ep_ops.ep_tx_complete = ath12k_dp_htt_htc_tx_complete;\n\tconn_req.ep_ops.ep_rx_complete = ath12k_dp_htt_htc_t2h_msg_handler;\n\n\t \n\tconn_req.service_id = ATH12K_HTC_SVC_ID_HTT_DATA_MSG;\n\n\tstatus = ath12k_htc_connect_service(&dp->ab->htc, &conn_req,\n\t\t\t\t\t    &conn_resp);\n\n\tif (status)\n\t\treturn status;\n\n\tdp->eid = conn_resp.eid;\n\n\treturn 0;\n}\n\nstatic void ath12k_dp_update_vdev_search(struct ath12k_vif *arvif)\n{\n\tswitch (arvif->vdev_type) {\n\tcase WMI_VDEV_TYPE_STA:\n\t\t \n\t\tarvif->hal_addr_search_flags = HAL_TX_ADDRY_EN;\n\t\tarvif->search_type = HAL_TX_ADDR_SEARCH_DEFAULT;\n\t\tbreak;\n\tcase WMI_VDEV_TYPE_AP:\n\tcase WMI_VDEV_TYPE_IBSS:\n\t\tarvif->hal_addr_search_flags = HAL_TX_ADDRX_EN;\n\t\tarvif->search_type = HAL_TX_ADDR_SEARCH_DEFAULT;\n\t\tbreak;\n\tcase WMI_VDEV_TYPE_MONITOR:\n\tdefault:\n\t\treturn;\n\t}\n}\n\nvoid ath12k_dp_vdev_tx_attach(struct ath12k *ar, struct ath12k_vif *arvif)\n{\n\tstruct ath12k_base *ab = ar->ab;\n\n\tarvif->tcl_metadata |= u32_encode_bits(1, HTT_TCL_META_DATA_TYPE) |\n\t\t\t       u32_encode_bits(arvif->vdev_id,\n\t\t\t\t\t       HTT_TCL_META_DATA_VDEV_ID) |\n\t\t\t       u32_encode_bits(ar->pdev->pdev_id,\n\t\t\t\t\t       HTT_TCL_META_DATA_PDEV_ID);\n\n\t \n\tarvif->tcl_metadata &= ~HTT_TCL_META_DATA_VALID_HTT;\n\n\tath12k_dp_update_vdev_search(arvif);\n\tarvif->vdev_id_check_en = true;\n\tarvif->bank_id = ath12k_dp_tx_get_bank_profile(ab, arvif, &ab->dp);\n\n\t \n\tif (arvif->bank_id == DP_INVALID_BANK_ID) {\n\t\tath12k_err(ar->ab, \"Failed to initialize DP TX Banks\");\n\t\treturn;\n\t}\n}\n\nstatic void ath12k_dp_cc_cleanup(struct ath12k_base *ab)\n{\n\tstruct ath12k_rx_desc_info *desc_info, *tmp;\n\tstruct ath12k_tx_desc_info *tx_desc_info, *tmp1;\n\tstruct ath12k_dp *dp = &ab->dp;\n\tstruct sk_buff *skb;\n\tint i;\n\tu32 pool_id, tx_spt_page;\n\n\tif (!dp->spt_info)\n\t\treturn;\n\n\t \n\tspin_lock_bh(&dp->rx_desc_lock);\n\n\tlist_for_each_entry_safe(desc_info, tmp, &dp->rx_desc_used_list, list) {\n\t\tlist_del(&desc_info->list);\n\t\tskb = desc_info->skb;\n\n\t\tif (!skb)\n\t\t\tcontinue;\n\n\t\tdma_unmap_single(ab->dev, ATH12K_SKB_RXCB(skb)->paddr,\n\t\t\t\t skb->len + skb_tailroom(skb), DMA_FROM_DEVICE);\n\t\tdev_kfree_skb_any(skb);\n\t}\n\n\tfor (i = 0; i < ATH12K_NUM_RX_SPT_PAGES; i++) {\n\t\tif (!dp->spt_info->rxbaddr[i])\n\t\t\tcontinue;\n\n\t\tkfree(dp->spt_info->rxbaddr[i]);\n\t\tdp->spt_info->rxbaddr[i] = NULL;\n\t}\n\n\tspin_unlock_bh(&dp->rx_desc_lock);\n\n\t \n\tfor (i = 0; i < ATH12K_HW_MAX_QUEUES; i++) {\n\t\tspin_lock_bh(&dp->tx_desc_lock[i]);\n\n\t\tlist_for_each_entry_safe(tx_desc_info, tmp1, &dp->tx_desc_used_list[i],\n\t\t\t\t\t list) {\n\t\t\tlist_del(&tx_desc_info->list);\n\t\t\tskb = tx_desc_info->skb;\n\n\t\t\tif (!skb)\n\t\t\t\tcontinue;\n\n\t\t\tdma_unmap_single(ab->dev, ATH12K_SKB_CB(skb)->paddr,\n\t\t\t\t\t skb->len, DMA_TO_DEVICE);\n\t\t\tdev_kfree_skb_any(skb);\n\t\t}\n\n\t\tspin_unlock_bh(&dp->tx_desc_lock[i]);\n\t}\n\n\tfor (pool_id = 0; pool_id < ATH12K_HW_MAX_QUEUES; pool_id++) {\n\t\tspin_lock_bh(&dp->tx_desc_lock[pool_id]);\n\n\t\tfor (i = 0; i < ATH12K_TX_SPT_PAGES_PER_POOL; i++) {\n\t\t\ttx_spt_page = i + pool_id * ATH12K_TX_SPT_PAGES_PER_POOL;\n\t\t\tif (!dp->spt_info->txbaddr[tx_spt_page])\n\t\t\t\tcontinue;\n\n\t\t\tkfree(dp->spt_info->txbaddr[tx_spt_page]);\n\t\t\tdp->spt_info->txbaddr[tx_spt_page] = NULL;\n\t\t}\n\n\t\tspin_unlock_bh(&dp->tx_desc_lock[pool_id]);\n\t}\n\n\t \n\tfor (i = 0; i < dp->num_spt_pages; i++) {\n\t\tif (!dp->spt_info[i].vaddr)\n\t\t\tcontinue;\n\n\t\tdma_free_coherent(ab->dev, ATH12K_PAGE_SIZE,\n\t\t\t\t  dp->spt_info[i].vaddr, dp->spt_info[i].paddr);\n\t\tdp->spt_info[i].vaddr = NULL;\n\t}\n\n\tkfree(dp->spt_info);\n}\n\nstatic void ath12k_dp_reoq_lut_cleanup(struct ath12k_base *ab)\n{\n\tstruct ath12k_dp *dp = &ab->dp;\n\n\tif (!ab->hw_params->reoq_lut_support)\n\t\treturn;\n\n\tif (!dp->reoq_lut.vaddr)\n\t\treturn;\n\n\tdma_free_coherent(ab->dev, DP_REOQ_LUT_SIZE,\n\t\t\t  dp->reoq_lut.vaddr, dp->reoq_lut.paddr);\n\tdp->reoq_lut.vaddr = NULL;\n\n\tath12k_hif_write32(ab,\n\t\t\t   HAL_SEQ_WCSS_UMAC_REO_REG + HAL_REO1_QDESC_LUT_BASE0(ab), 0);\n}\n\nvoid ath12k_dp_free(struct ath12k_base *ab)\n{\n\tstruct ath12k_dp *dp = &ab->dp;\n\tint i;\n\n\tath12k_dp_link_desc_cleanup(ab, dp->link_desc_banks,\n\t\t\t\t    HAL_WBM_IDLE_LINK, &dp->wbm_idle_ring);\n\n\tath12k_dp_cc_cleanup(ab);\n\tath12k_dp_reoq_lut_cleanup(ab);\n\tath12k_dp_deinit_bank_profiles(ab);\n\tath12k_dp_srng_common_cleanup(ab);\n\n\tath12k_dp_rx_reo_cmd_list_cleanup(ab);\n\n\tfor (i = 0; i < ab->hw_params->max_tx_ring; i++)\n\t\tkfree(dp->tx_ring[i].tx_status);\n\n\tath12k_dp_rx_free(ab);\n\t \n}\n\nvoid ath12k_dp_cc_config(struct ath12k_base *ab)\n{\n\tu32 cmem_base = ab->qmi.dev_mem[ATH12K_QMI_DEVMEM_CMEM_INDEX].start;\n\tu32 reo_base = HAL_SEQ_WCSS_UMAC_REO_REG;\n\tu32 wbm_base = HAL_SEQ_WCSS_UMAC_WBM_REG;\n\tu32 val = 0;\n\n\tath12k_hif_write32(ab, reo_base + HAL_REO1_SW_COOKIE_CFG0(ab), cmem_base);\n\n\tval |= u32_encode_bits(ATH12K_CMEM_ADDR_MSB,\n\t\t\t       HAL_REO1_SW_COOKIE_CFG_CMEM_BASE_ADDR_MSB) |\n\t\tu32_encode_bits(ATH12K_CC_PPT_MSB,\n\t\t\t\tHAL_REO1_SW_COOKIE_CFG_COOKIE_PPT_MSB) |\n\t\tu32_encode_bits(ATH12K_CC_SPT_MSB,\n\t\t\t\tHAL_REO1_SW_COOKIE_CFG_COOKIE_SPT_MSB) |\n\t\tu32_encode_bits(1, HAL_REO1_SW_COOKIE_CFG_ALIGN) |\n\t\tu32_encode_bits(1, HAL_REO1_SW_COOKIE_CFG_ENABLE) |\n\t\tu32_encode_bits(1, HAL_REO1_SW_COOKIE_CFG_GLOBAL_ENABLE);\n\n\tath12k_hif_write32(ab, reo_base + HAL_REO1_SW_COOKIE_CFG1(ab), val);\n\n\t \n\tath12k_hif_write32(ab, wbm_base + HAL_WBM_SW_COOKIE_CFG0, cmem_base);\n\n\tval = u32_encode_bits(ATH12K_CMEM_ADDR_MSB,\n\t\t\t      HAL_WBM_SW_COOKIE_CFG_CMEM_BASE_ADDR_MSB) |\n\t\tu32_encode_bits(ATH12K_CC_PPT_MSB,\n\t\t\t\tHAL_WBM_SW_COOKIE_CFG_COOKIE_PPT_MSB) |\n\t\tu32_encode_bits(ATH12K_CC_SPT_MSB,\n\t\t\t\tHAL_WBM_SW_COOKIE_CFG_COOKIE_SPT_MSB) |\n\t\tu32_encode_bits(1, HAL_WBM_SW_COOKIE_CFG_ALIGN);\n\n\tath12k_hif_write32(ab, wbm_base + HAL_WBM_SW_COOKIE_CFG1, val);\n\n\t \n\tval = ath12k_hif_read32(ab, wbm_base + HAL_WBM_SW_COOKIE_CFG2);\n\tval |= u32_encode_bits(1, HAL_WBM_SW_COOKIE_CFG_RELEASE_PATH_EN) |\n\t\tu32_encode_bits(1, HAL_WBM_SW_COOKIE_CFG_ERR_PATH_EN) |\n\t\tu32_encode_bits(1, HAL_WBM_SW_COOKIE_CFG_CONV_IND_EN);\n\n\tath12k_hif_write32(ab, wbm_base + HAL_WBM_SW_COOKIE_CFG2, val);\n\n\t \n\tval = ath12k_hif_read32(ab, wbm_base + HAL_WBM_SW_COOKIE_CONVERT_CFG);\n\tval |= u32_encode_bits(1, HAL_WBM_SW_COOKIE_CONV_CFG_GLOBAL_EN) |\n\t       ab->hw_params->hal_params->wbm2sw_cc_enable;\n\n\tath12k_hif_write32(ab, wbm_base + HAL_WBM_SW_COOKIE_CONVERT_CFG, val);\n}\n\nstatic u32 ath12k_dp_cc_cookie_gen(u16 ppt_idx, u16 spt_idx)\n{\n\treturn (u32)ppt_idx << ATH12K_CC_PPT_SHIFT | spt_idx;\n}\n\nstatic inline void *ath12k_dp_cc_get_desc_addr_ptr(struct ath12k_base *ab,\n\t\t\t\t\t\t   u16 ppt_idx, u16 spt_idx)\n{\n\tstruct ath12k_dp *dp = &ab->dp;\n\n\treturn dp->spt_info[ppt_idx].vaddr + spt_idx;\n}\n\nstruct ath12k_rx_desc_info *ath12k_dp_get_rx_desc(struct ath12k_base *ab,\n\t\t\t\t\t\t  u32 cookie)\n{\n\tstruct ath12k_rx_desc_info **desc_addr_ptr;\n\tu16 ppt_idx, spt_idx;\n\n\tppt_idx = u32_get_bits(cookie, ATH12K_DP_CC_COOKIE_PPT);\n\tspt_idx = u32_get_bits(cookie, ATH12k_DP_CC_COOKIE_SPT);\n\n\tif (ppt_idx > ATH12K_NUM_RX_SPT_PAGES ||\n\t    spt_idx > ATH12K_MAX_SPT_ENTRIES)\n\t\treturn NULL;\n\n\tdesc_addr_ptr = ath12k_dp_cc_get_desc_addr_ptr(ab, ppt_idx, spt_idx);\n\n\treturn *desc_addr_ptr;\n}\n\nstruct ath12k_tx_desc_info *ath12k_dp_get_tx_desc(struct ath12k_base *ab,\n\t\t\t\t\t\t  u32 cookie)\n{\n\tstruct ath12k_tx_desc_info **desc_addr_ptr;\n\tu16 ppt_idx, spt_idx;\n\n\tppt_idx = u32_get_bits(cookie, ATH12K_DP_CC_COOKIE_PPT);\n\tspt_idx = u32_get_bits(cookie, ATH12k_DP_CC_COOKIE_SPT);\n\n\tif (ppt_idx < ATH12K_NUM_RX_SPT_PAGES ||\n\t    ppt_idx > ab->dp.num_spt_pages ||\n\t    spt_idx > ATH12K_MAX_SPT_ENTRIES)\n\t\treturn NULL;\n\n\tdesc_addr_ptr = ath12k_dp_cc_get_desc_addr_ptr(ab, ppt_idx, spt_idx);\n\n\treturn *desc_addr_ptr;\n}\n\nstatic int ath12k_dp_cc_desc_init(struct ath12k_base *ab)\n{\n\tstruct ath12k_dp *dp = &ab->dp;\n\tstruct ath12k_rx_desc_info *rx_descs, **rx_desc_addr;\n\tstruct ath12k_tx_desc_info *tx_descs, **tx_desc_addr;\n\tu32 i, j, pool_id, tx_spt_page;\n\tu32 ppt_idx;\n\n\tspin_lock_bh(&dp->rx_desc_lock);\n\n\t \n\tfor (i = 0; i < ATH12K_NUM_RX_SPT_PAGES; i++) {\n\t\trx_descs = kcalloc(ATH12K_MAX_SPT_ENTRIES, sizeof(*rx_descs),\n\t\t\t\t   GFP_ATOMIC);\n\n\t\tif (!rx_descs) {\n\t\t\tspin_unlock_bh(&dp->rx_desc_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tdp->spt_info->rxbaddr[i] = &rx_descs[0];\n\n\t\tfor (j = 0; j < ATH12K_MAX_SPT_ENTRIES; j++) {\n\t\t\trx_descs[j].cookie = ath12k_dp_cc_cookie_gen(i, j);\n\t\t\trx_descs[j].magic = ATH12K_DP_RX_DESC_MAGIC;\n\t\t\tlist_add_tail(&rx_descs[j].list, &dp->rx_desc_free_list);\n\n\t\t\t \n\t\t\trx_desc_addr = ath12k_dp_cc_get_desc_addr_ptr(ab, i, j);\n\t\t\t*rx_desc_addr = &rx_descs[j];\n\t\t}\n\t}\n\n\tspin_unlock_bh(&dp->rx_desc_lock);\n\n\tfor (pool_id = 0; pool_id < ATH12K_HW_MAX_QUEUES; pool_id++) {\n\t\tspin_lock_bh(&dp->tx_desc_lock[pool_id]);\n\t\tfor (i = 0; i < ATH12K_TX_SPT_PAGES_PER_POOL; i++) {\n\t\t\ttx_descs = kcalloc(ATH12K_MAX_SPT_ENTRIES, sizeof(*tx_descs),\n\t\t\t\t\t   GFP_ATOMIC);\n\n\t\t\tif (!tx_descs) {\n\t\t\t\tspin_unlock_bh(&dp->tx_desc_lock[pool_id]);\n\t\t\t\t \n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\ttx_spt_page = i + pool_id * ATH12K_TX_SPT_PAGES_PER_POOL;\n\t\t\tdp->spt_info->txbaddr[tx_spt_page] = &tx_descs[0];\n\n\t\t\tfor (j = 0; j < ATH12K_MAX_SPT_ENTRIES; j++) {\n\t\t\t\tppt_idx = ATH12K_NUM_RX_SPT_PAGES + tx_spt_page;\n\t\t\t\ttx_descs[j].desc_id = ath12k_dp_cc_cookie_gen(ppt_idx, j);\n\t\t\t\ttx_descs[j].pool_id = pool_id;\n\t\t\t\tlist_add_tail(&tx_descs[j].list,\n\t\t\t\t\t      &dp->tx_desc_free_list[pool_id]);\n\n\t\t\t\t \n\t\t\t\ttx_desc_addr =\n\t\t\t\t\tath12k_dp_cc_get_desc_addr_ptr(ab, ppt_idx, j);\n\t\t\t\t*tx_desc_addr = &tx_descs[j];\n\t\t\t}\n\t\t}\n\t\tspin_unlock_bh(&dp->tx_desc_lock[pool_id]);\n\t}\n\treturn 0;\n}\n\nstatic int ath12k_dp_cc_init(struct ath12k_base *ab)\n{\n\tstruct ath12k_dp *dp = &ab->dp;\n\tint i, ret = 0;\n\tu32 cmem_base;\n\n\tINIT_LIST_HEAD(&dp->rx_desc_free_list);\n\tINIT_LIST_HEAD(&dp->rx_desc_used_list);\n\tspin_lock_init(&dp->rx_desc_lock);\n\n\tfor (i = 0; i < ATH12K_HW_MAX_QUEUES; i++) {\n\t\tINIT_LIST_HEAD(&dp->tx_desc_free_list[i]);\n\t\tINIT_LIST_HEAD(&dp->tx_desc_used_list[i]);\n\t\tspin_lock_init(&dp->tx_desc_lock[i]);\n\t}\n\n\tdp->num_spt_pages = ATH12K_NUM_SPT_PAGES;\n\tif (dp->num_spt_pages > ATH12K_MAX_PPT_ENTRIES)\n\t\tdp->num_spt_pages = ATH12K_MAX_PPT_ENTRIES;\n\n\tdp->spt_info = kcalloc(dp->num_spt_pages, sizeof(struct ath12k_spt_info),\n\t\t\t       GFP_KERNEL);\n\n\tif (!dp->spt_info) {\n\t\tath12k_warn(ab, \"SPT page allocation failure\");\n\t\treturn -ENOMEM;\n\t}\n\n\tcmem_base = ab->qmi.dev_mem[ATH12K_QMI_DEVMEM_CMEM_INDEX].start;\n\n\tfor (i = 0; i < dp->num_spt_pages; i++) {\n\t\tdp->spt_info[i].vaddr = dma_alloc_coherent(ab->dev,\n\t\t\t\t\t\t\t   ATH12K_PAGE_SIZE,\n\t\t\t\t\t\t\t   &dp->spt_info[i].paddr,\n\t\t\t\t\t\t\t   GFP_KERNEL);\n\n\t\tif (!dp->spt_info[i].vaddr) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\n\t\tif (dp->spt_info[i].paddr & ATH12K_SPT_4K_ALIGN_CHECK) {\n\t\t\tath12k_warn(ab, \"SPT allocated memory is not 4K aligned\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto free;\n\t\t}\n\n\t\t \n\t\tath12k_hif_write32(ab, cmem_base + ATH12K_PPT_ADDR_OFFSET(i),\n\t\t\t\t   dp->spt_info[i].paddr >> ATH12K_SPT_4K_ALIGN_OFFSET);\n\t}\n\n\tret = ath12k_dp_cc_desc_init(ab);\n\tif (ret) {\n\t\tath12k_warn(ab, \"HW CC desc init failed %d\", ret);\n\t\tgoto free;\n\t}\n\n\treturn 0;\nfree:\n\tath12k_dp_cc_cleanup(ab);\n\treturn ret;\n}\n\nstatic int ath12k_dp_reoq_lut_setup(struct ath12k_base *ab)\n{\n\tstruct ath12k_dp *dp = &ab->dp;\n\n\tif (!ab->hw_params->reoq_lut_support)\n\t\treturn 0;\n\n\tdp->reoq_lut.vaddr = dma_alloc_coherent(ab->dev,\n\t\t\t\t\t\tDP_REOQ_LUT_SIZE,\n\t\t\t\t\t\t&dp->reoq_lut.paddr,\n\t\t\t\t\t\tGFP_KERNEL | __GFP_ZERO);\n\tif (!dp->reoq_lut.vaddr) {\n\t\tath12k_warn(ab, \"failed to allocate memory for reoq table\");\n\t\treturn -ENOMEM;\n\t}\n\n\tath12k_hif_write32(ab, HAL_SEQ_WCSS_UMAC_REO_REG + HAL_REO1_QDESC_LUT_BASE0(ab),\n\t\t\t   dp->reoq_lut.paddr);\n\treturn 0;\n}\n\nint ath12k_dp_alloc(struct ath12k_base *ab)\n{\n\tstruct ath12k_dp *dp = &ab->dp;\n\tstruct hal_srng *srng = NULL;\n\tsize_t size = 0;\n\tu32 n_link_desc = 0;\n\tint ret;\n\tint i;\n\n\tdp->ab = ab;\n\n\tINIT_LIST_HEAD(&dp->reo_cmd_list);\n\tINIT_LIST_HEAD(&dp->reo_cmd_cache_flush_list);\n\tspin_lock_init(&dp->reo_cmd_lock);\n\n\tdp->reo_cmd_cache_flush_count = 0;\n\n\tret = ath12k_wbm_idle_ring_setup(ab, &n_link_desc);\n\tif (ret) {\n\t\tath12k_warn(ab, \"failed to setup wbm_idle_ring: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tsrng = &ab->hal.srng_list[dp->wbm_idle_ring.ring_id];\n\n\tret = ath12k_dp_link_desc_setup(ab, dp->link_desc_banks,\n\t\t\t\t\tHAL_WBM_IDLE_LINK, srng, n_link_desc);\n\tif (ret) {\n\t\tath12k_warn(ab, \"failed to setup link desc: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ath12k_dp_cc_init(ab);\n\n\tif (ret) {\n\t\tath12k_warn(ab, \"failed to setup cookie converter %d\\n\", ret);\n\t\tgoto fail_link_desc_cleanup;\n\t}\n\tret = ath12k_dp_init_bank_profiles(ab);\n\tif (ret) {\n\t\tath12k_warn(ab, \"failed to setup bank profiles %d\\n\", ret);\n\t\tgoto fail_hw_cc_cleanup;\n\t}\n\n\tret = ath12k_dp_srng_common_setup(ab);\n\tif (ret)\n\t\tgoto fail_dp_bank_profiles_cleanup;\n\n\tsize = sizeof(struct hal_wbm_release_ring_tx) * DP_TX_COMP_RING_SIZE;\n\n\tret = ath12k_dp_reoq_lut_setup(ab);\n\tif (ret) {\n\t\tath12k_warn(ab, \"failed to setup reoq table %d\\n\", ret);\n\t\tgoto fail_cmn_srng_cleanup;\n\t}\n\n\tfor (i = 0; i < ab->hw_params->max_tx_ring; i++) {\n\t\tdp->tx_ring[i].tcl_data_ring_id = i;\n\n\t\tdp->tx_ring[i].tx_status_head = 0;\n\t\tdp->tx_ring[i].tx_status_tail = DP_TX_COMP_RING_SIZE - 1;\n\t\tdp->tx_ring[i].tx_status = kmalloc(size, GFP_KERNEL);\n\t\tif (!dp->tx_ring[i].tx_status) {\n\t\t\tret = -ENOMEM;\n\t\t\t \n\t\t\tgoto fail_cmn_reoq_cleanup;\n\t\t}\n\t}\n\n\tfor (i = 0; i < HAL_DSCP_TID_MAP_TBL_NUM_ENTRIES_MAX; i++)\n\t\tath12k_hal_tx_set_dscp_tid_map(ab, i);\n\n\tret = ath12k_dp_rx_alloc(ab);\n\tif (ret)\n\t\tgoto fail_dp_rx_free;\n\n\t \n\n\treturn 0;\n\nfail_dp_rx_free:\n\tath12k_dp_rx_free(ab);\n\nfail_cmn_reoq_cleanup:\n\tath12k_dp_reoq_lut_cleanup(ab);\n\nfail_cmn_srng_cleanup:\n\tath12k_dp_srng_common_cleanup(ab);\n\nfail_dp_bank_profiles_cleanup:\n\tath12k_dp_deinit_bank_profiles(ab);\n\nfail_hw_cc_cleanup:\n\tath12k_dp_cc_cleanup(ab);\n\nfail_link_desc_cleanup:\n\tath12k_dp_link_desc_cleanup(ab, dp->link_desc_banks,\n\t\t\t\t    HAL_WBM_IDLE_LINK, &dp->wbm_idle_ring);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}