{
  "module_name": "mhi.c",
  "hash_id": "567817b7bca95dacc21f155b85b7e8040d6eaf1f313842c7276cf678fb9e2f65",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath12k/mhi.c",
  "human_readable_source": "\n \n\n#include <linux/msi.h>\n#include <linux/pci.h>\n\n#include \"core.h\"\n#include \"debug.h\"\n#include \"mhi.h\"\n#include \"pci.h\"\n\n#define MHI_TIMEOUT_DEFAULT_MS\t90000\n\nstatic const struct mhi_channel_config ath12k_mhi_channels_qcn9274[] = {\n\t{\n\t\t.num = 0,\n\t\t.name = \"LOOPBACK\",\n\t\t.num_elements = 32,\n\t\t.event_ring = 1,\n\t\t.dir = DMA_TO_DEVICE,\n\t\t.ee_mask = 0x4,\n\t\t.pollcfg = 0,\n\t\t.doorbell = MHI_DB_BRST_DISABLE,\n\t\t.lpm_notify = false,\n\t\t.offload_channel = false,\n\t\t.doorbell_mode_switch = false,\n\t\t.auto_queue = false,\n\t},\n\t{\n\t\t.num = 1,\n\t\t.name = \"LOOPBACK\",\n\t\t.num_elements = 32,\n\t\t.event_ring = 1,\n\t\t.dir = DMA_FROM_DEVICE,\n\t\t.ee_mask = 0x4,\n\t\t.pollcfg = 0,\n\t\t.doorbell = MHI_DB_BRST_DISABLE,\n\t\t.lpm_notify = false,\n\t\t.offload_channel = false,\n\t\t.doorbell_mode_switch = false,\n\t\t.auto_queue = false,\n\t},\n\t{\n\t\t.num = 20,\n\t\t.name = \"IPCR\",\n\t\t.num_elements = 32,\n\t\t.event_ring = 1,\n\t\t.dir = DMA_TO_DEVICE,\n\t\t.ee_mask = 0x4,\n\t\t.pollcfg = 0,\n\t\t.doorbell = MHI_DB_BRST_DISABLE,\n\t\t.lpm_notify = false,\n\t\t.offload_channel = false,\n\t\t.doorbell_mode_switch = false,\n\t\t.auto_queue = false,\n\t},\n\t{\n\t\t.num = 21,\n\t\t.name = \"IPCR\",\n\t\t.num_elements = 32,\n\t\t.event_ring = 1,\n\t\t.dir = DMA_FROM_DEVICE,\n\t\t.ee_mask = 0x4,\n\t\t.pollcfg = 0,\n\t\t.doorbell = MHI_DB_BRST_DISABLE,\n\t\t.lpm_notify = false,\n\t\t.offload_channel = false,\n\t\t.doorbell_mode_switch = false,\n\t\t.auto_queue = true,\n\t},\n};\n\nstatic struct mhi_event_config ath12k_mhi_events_qcn9274[] = {\n\t{\n\t\t.num_elements = 32,\n\t\t.irq_moderation_ms = 0,\n\t\t.irq = 1,\n\t\t.data_type = MHI_ER_CTRL,\n\t\t.mode = MHI_DB_BRST_DISABLE,\n\t\t.hardware_event = false,\n\t\t.client_managed = false,\n\t\t.offload_channel = false,\n\t},\n\t{\n\t\t.num_elements = 256,\n\t\t.irq_moderation_ms = 1,\n\t\t.irq = 2,\n\t\t.mode = MHI_DB_BRST_DISABLE,\n\t\t.priority = 1,\n\t\t.hardware_event = false,\n\t\t.client_managed = false,\n\t\t.offload_channel = false,\n\t},\n};\n\nconst struct mhi_controller_config ath12k_mhi_config_qcn9274 = {\n\t.max_channels = 30,\n\t.timeout_ms = 10000,\n\t.use_bounce_buf = false,\n\t.buf_len = 0,\n\t.num_channels = ARRAY_SIZE(ath12k_mhi_channels_qcn9274),\n\t.ch_cfg = ath12k_mhi_channels_qcn9274,\n\t.num_events = ARRAY_SIZE(ath12k_mhi_events_qcn9274),\n\t.event_cfg = ath12k_mhi_events_qcn9274,\n};\n\nstatic const struct mhi_channel_config ath12k_mhi_channels_wcn7850[] = {\n\t{\n\t\t.num = 0,\n\t\t.name = \"LOOPBACK\",\n\t\t.num_elements = 32,\n\t\t.event_ring = 0,\n\t\t.dir = DMA_TO_DEVICE,\n\t\t.ee_mask = 0x4,\n\t\t.pollcfg = 0,\n\t\t.doorbell = MHI_DB_BRST_DISABLE,\n\t\t.lpm_notify = false,\n\t\t.offload_channel = false,\n\t\t.doorbell_mode_switch = false,\n\t\t.auto_queue = false,\n\t},\n\t{\n\t\t.num = 1,\n\t\t.name = \"LOOPBACK\",\n\t\t.num_elements = 32,\n\t\t.event_ring = 0,\n\t\t.dir = DMA_FROM_DEVICE,\n\t\t.ee_mask = 0x4,\n\t\t.pollcfg = 0,\n\t\t.doorbell = MHI_DB_BRST_DISABLE,\n\t\t.lpm_notify = false,\n\t\t.offload_channel = false,\n\t\t.doorbell_mode_switch = false,\n\t\t.auto_queue = false,\n\t},\n\t{\n\t\t.num = 20,\n\t\t.name = \"IPCR\",\n\t\t.num_elements = 64,\n\t\t.event_ring = 1,\n\t\t.dir = DMA_TO_DEVICE,\n\t\t.ee_mask = 0x4,\n\t\t.pollcfg = 0,\n\t\t.doorbell = MHI_DB_BRST_DISABLE,\n\t\t.lpm_notify = false,\n\t\t.offload_channel = false,\n\t\t.doorbell_mode_switch = false,\n\t\t.auto_queue = false,\n\t},\n\t{\n\t\t.num = 21,\n\t\t.name = \"IPCR\",\n\t\t.num_elements = 64,\n\t\t.event_ring = 1,\n\t\t.dir = DMA_FROM_DEVICE,\n\t\t.ee_mask = 0x4,\n\t\t.pollcfg = 0,\n\t\t.doorbell = MHI_DB_BRST_DISABLE,\n\t\t.lpm_notify = false,\n\t\t.offload_channel = false,\n\t\t.doorbell_mode_switch = false,\n\t\t.auto_queue = true,\n\t},\n};\n\nstatic struct mhi_event_config ath12k_mhi_events_wcn7850[] = {\n\t{\n\t\t.num_elements = 32,\n\t\t.irq_moderation_ms = 0,\n\t\t.irq = 1,\n\t\t.mode = MHI_DB_BRST_DISABLE,\n\t\t.data_type = MHI_ER_CTRL,\n\t\t.hardware_event = false,\n\t\t.client_managed = false,\n\t\t.offload_channel = false,\n\t},\n\t{\n\t\t.num_elements = 256,\n\t\t.irq_moderation_ms = 1,\n\t\t.irq = 2,\n\t\t.mode = MHI_DB_BRST_DISABLE,\n\t\t.priority = 1,\n\t\t.hardware_event = false,\n\t\t.client_managed = false,\n\t\t.offload_channel = false,\n\t},\n};\n\nconst struct mhi_controller_config ath12k_mhi_config_wcn7850 = {\n\t.max_channels = 128,\n\t.timeout_ms = 2000,\n\t.use_bounce_buf = false,\n\t.buf_len = 0,\n\t.num_channels = ARRAY_SIZE(ath12k_mhi_channels_wcn7850),\n\t.ch_cfg = ath12k_mhi_channels_wcn7850,\n\t.num_events = ARRAY_SIZE(ath12k_mhi_events_wcn7850),\n\t.event_cfg = ath12k_mhi_events_wcn7850,\n};\n\nvoid ath12k_mhi_set_mhictrl_reset(struct ath12k_base *ab)\n{\n\tu32 val;\n\n\tval = ath12k_pci_read32(ab, MHISTATUS);\n\n\tath12k_dbg(ab, ATH12K_DBG_PCI, \"MHISTATUS 0x%x\\n\", val);\n\n\t \n\tath12k_pci_write32(ab, MHICTRL, MHICTRL_RESET_MASK);\n\n\tmdelay(10);\n}\n\nstatic void ath12k_mhi_reset_txvecdb(struct ath12k_base *ab)\n{\n\tath12k_pci_write32(ab, PCIE_TXVECDB, 0);\n}\n\nstatic void ath12k_mhi_reset_txvecstatus(struct ath12k_base *ab)\n{\n\tath12k_pci_write32(ab, PCIE_TXVECSTATUS, 0);\n}\n\nstatic void ath12k_mhi_reset_rxvecdb(struct ath12k_base *ab)\n{\n\tath12k_pci_write32(ab, PCIE_RXVECDB, 0);\n}\n\nstatic void ath12k_mhi_reset_rxvecstatus(struct ath12k_base *ab)\n{\n\tath12k_pci_write32(ab, PCIE_RXVECSTATUS, 0);\n}\n\nvoid ath12k_mhi_clear_vector(struct ath12k_base *ab)\n{\n\tath12k_mhi_reset_txvecdb(ab);\n\tath12k_mhi_reset_txvecstatus(ab);\n\tath12k_mhi_reset_rxvecdb(ab);\n\tath12k_mhi_reset_rxvecstatus(ab);\n}\n\nstatic int ath12k_mhi_get_msi(struct ath12k_pci *ab_pci)\n{\n\tstruct ath12k_base *ab = ab_pci->ab;\n\tu32 user_base_data, base_vector;\n\tint ret, num_vectors, i;\n\tint *irq;\n\n\tret = ath12k_pci_get_user_msi_assignment(ab,\n\t\t\t\t\t\t \"MHI\", &num_vectors,\n\t\t\t\t\t\t &user_base_data, &base_vector);\n\tif (ret)\n\t\treturn ret;\n\n\tath12k_dbg(ab, ATH12K_DBG_PCI, \"Number of assigned MSI for MHI is %d, base vector is %d\\n\",\n\t\t   num_vectors, base_vector);\n\n\tirq = kcalloc(num_vectors, sizeof(*irq), GFP_KERNEL);\n\tif (!irq)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num_vectors; i++)\n\t\tirq[i] = ath12k_pci_get_msi_irq(ab->dev,\n\t\t\t\t\t\tbase_vector + i);\n\n\tab_pci->mhi_ctrl->irq = irq;\n\tab_pci->mhi_ctrl->nr_irqs = num_vectors;\n\n\treturn 0;\n}\n\nstatic int ath12k_mhi_op_runtime_get(struct mhi_controller *mhi_cntrl)\n{\n\treturn 0;\n}\n\nstatic void ath12k_mhi_op_runtime_put(struct mhi_controller *mhi_cntrl)\n{\n}\n\nstatic char *ath12k_mhi_op_callback_to_str(enum mhi_callback reason)\n{\n\tswitch (reason) {\n\tcase MHI_CB_IDLE:\n\t\treturn \"MHI_CB_IDLE\";\n\tcase MHI_CB_PENDING_DATA:\n\t\treturn \"MHI_CB_PENDING_DATA\";\n\tcase MHI_CB_LPM_ENTER:\n\t\treturn \"MHI_CB_LPM_ENTER\";\n\tcase MHI_CB_LPM_EXIT:\n\t\treturn \"MHI_CB_LPM_EXIT\";\n\tcase MHI_CB_EE_RDDM:\n\t\treturn \"MHI_CB_EE_RDDM\";\n\tcase MHI_CB_EE_MISSION_MODE:\n\t\treturn \"MHI_CB_EE_MISSION_MODE\";\n\tcase MHI_CB_SYS_ERROR:\n\t\treturn \"MHI_CB_SYS_ERROR\";\n\tcase MHI_CB_FATAL_ERROR:\n\t\treturn \"MHI_CB_FATAL_ERROR\";\n\tcase MHI_CB_BW_REQ:\n\t\treturn \"MHI_CB_BW_REQ\";\n\tdefault:\n\t\treturn \"UNKNOWN\";\n\t}\n}\n\nstatic void ath12k_mhi_op_status_cb(struct mhi_controller *mhi_cntrl,\n\t\t\t\t    enum mhi_callback cb)\n{\n\tstruct ath12k_base *ab = dev_get_drvdata(mhi_cntrl->cntrl_dev);\n\n\tath12k_dbg(ab, ATH12K_DBG_BOOT, \"mhi notify status reason %s\\n\",\n\t\t   ath12k_mhi_op_callback_to_str(cb));\n\n\tswitch (cb) {\n\tcase MHI_CB_SYS_ERROR:\n\t\tath12k_warn(ab, \"firmware crashed: MHI_CB_SYS_ERROR\\n\");\n\t\tbreak;\n\tcase MHI_CB_EE_RDDM:\n\t\tif (!(test_bit(ATH12K_FLAG_UNREGISTERING, &ab->dev_flags)))\n\t\t\tqueue_work(ab->workqueue_aux, &ab->reset_work);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int ath12k_mhi_op_read_reg(struct mhi_controller *mhi_cntrl,\n\t\t\t\t  void __iomem *addr,\n\t\t\t\t  u32 *out)\n{\n\t*out = readl(addr);\n\n\treturn 0;\n}\n\nstatic void ath12k_mhi_op_write_reg(struct mhi_controller *mhi_cntrl,\n\t\t\t\t    void __iomem *addr,\n\t\t\t\t    u32 val)\n{\n\twritel(val, addr);\n}\n\nint ath12k_mhi_register(struct ath12k_pci *ab_pci)\n{\n\tstruct ath12k_base *ab = ab_pci->ab;\n\tstruct mhi_controller *mhi_ctrl;\n\tint ret;\n\n\tmhi_ctrl = mhi_alloc_controller();\n\tif (!mhi_ctrl)\n\t\treturn -ENOMEM;\n\n\tath12k_core_create_firmware_path(ab, ATH12K_AMSS_FILE,\n\t\t\t\t\t ab_pci->amss_path,\n\t\t\t\t\t sizeof(ab_pci->amss_path));\n\n\tab_pci->mhi_ctrl = mhi_ctrl;\n\tmhi_ctrl->cntrl_dev = ab->dev;\n\tmhi_ctrl->fw_image = ab_pci->amss_path;\n\tmhi_ctrl->regs = ab->mem;\n\tmhi_ctrl->reg_len = ab->mem_len;\n\n\tret = ath12k_mhi_get_msi(ab_pci);\n\tif (ret) {\n\t\tath12k_err(ab, \"failed to get msi for mhi\\n\");\n\t\tgoto free_controller;\n\t}\n\n\tmhi_ctrl->iova_start = 0;\n\tmhi_ctrl->iova_stop = 0xffffffff;\n\tmhi_ctrl->sbl_size = SZ_512K;\n\tmhi_ctrl->seg_len = SZ_512K;\n\tmhi_ctrl->fbc_download = true;\n\tmhi_ctrl->runtime_get = ath12k_mhi_op_runtime_get;\n\tmhi_ctrl->runtime_put = ath12k_mhi_op_runtime_put;\n\tmhi_ctrl->status_cb = ath12k_mhi_op_status_cb;\n\tmhi_ctrl->read_reg = ath12k_mhi_op_read_reg;\n\tmhi_ctrl->write_reg = ath12k_mhi_op_write_reg;\n\n\tret = mhi_register_controller(mhi_ctrl, ab->hw_params->mhi_config);\n\tif (ret) {\n\t\tath12k_err(ab, \"failed to register to mhi bus, err = %d\\n\", ret);\n\t\tgoto free_controller;\n\t}\n\n\treturn 0;\n\nfree_controller:\n\tmhi_free_controller(mhi_ctrl);\n\tab_pci->mhi_ctrl = NULL;\n\treturn ret;\n}\n\nvoid ath12k_mhi_unregister(struct ath12k_pci *ab_pci)\n{\n\tstruct mhi_controller *mhi_ctrl = ab_pci->mhi_ctrl;\n\n\tmhi_unregister_controller(mhi_ctrl);\n\tkfree(mhi_ctrl->irq);\n\tmhi_free_controller(mhi_ctrl);\n\tab_pci->mhi_ctrl = NULL;\n}\n\nstatic char *ath12k_mhi_state_to_str(enum ath12k_mhi_state mhi_state)\n{\n\tswitch (mhi_state) {\n\tcase ATH12K_MHI_INIT:\n\t\treturn \"INIT\";\n\tcase ATH12K_MHI_DEINIT:\n\t\treturn \"DEINIT\";\n\tcase ATH12K_MHI_POWER_ON:\n\t\treturn \"POWER_ON\";\n\tcase ATH12K_MHI_POWER_OFF:\n\t\treturn \"POWER_OFF\";\n\tcase ATH12K_MHI_FORCE_POWER_OFF:\n\t\treturn \"FORCE_POWER_OFF\";\n\tcase ATH12K_MHI_SUSPEND:\n\t\treturn \"SUSPEND\";\n\tcase ATH12K_MHI_RESUME:\n\t\treturn \"RESUME\";\n\tcase ATH12K_MHI_TRIGGER_RDDM:\n\t\treturn \"TRIGGER_RDDM\";\n\tcase ATH12K_MHI_RDDM_DONE:\n\t\treturn \"RDDM_DONE\";\n\tdefault:\n\t\treturn \"UNKNOWN\";\n\t}\n};\n\nstatic void ath12k_mhi_set_state_bit(struct ath12k_pci *ab_pci,\n\t\t\t\t     enum ath12k_mhi_state mhi_state)\n{\n\tstruct ath12k_base *ab = ab_pci->ab;\n\n\tswitch (mhi_state) {\n\tcase ATH12K_MHI_INIT:\n\t\tset_bit(ATH12K_MHI_INIT, &ab_pci->mhi_state);\n\t\tbreak;\n\tcase ATH12K_MHI_DEINIT:\n\t\tclear_bit(ATH12K_MHI_INIT, &ab_pci->mhi_state);\n\t\tbreak;\n\tcase ATH12K_MHI_POWER_ON:\n\t\tset_bit(ATH12K_MHI_POWER_ON, &ab_pci->mhi_state);\n\t\tbreak;\n\tcase ATH12K_MHI_POWER_OFF:\n\tcase ATH12K_MHI_FORCE_POWER_OFF:\n\t\tclear_bit(ATH12K_MHI_POWER_ON, &ab_pci->mhi_state);\n\t\tclear_bit(ATH12K_MHI_TRIGGER_RDDM, &ab_pci->mhi_state);\n\t\tclear_bit(ATH12K_MHI_RDDM_DONE, &ab_pci->mhi_state);\n\t\tbreak;\n\tcase ATH12K_MHI_SUSPEND:\n\t\tset_bit(ATH12K_MHI_SUSPEND, &ab_pci->mhi_state);\n\t\tbreak;\n\tcase ATH12K_MHI_RESUME:\n\t\tclear_bit(ATH12K_MHI_SUSPEND, &ab_pci->mhi_state);\n\t\tbreak;\n\tcase ATH12K_MHI_TRIGGER_RDDM:\n\t\tset_bit(ATH12K_MHI_TRIGGER_RDDM, &ab_pci->mhi_state);\n\t\tbreak;\n\tcase ATH12K_MHI_RDDM_DONE:\n\t\tset_bit(ATH12K_MHI_RDDM_DONE, &ab_pci->mhi_state);\n\t\tbreak;\n\tdefault:\n\t\tath12k_err(ab, \"unhandled mhi state (%d)\\n\", mhi_state);\n\t}\n}\n\nstatic int ath12k_mhi_check_state_bit(struct ath12k_pci *ab_pci,\n\t\t\t\t      enum ath12k_mhi_state mhi_state)\n{\n\tstruct ath12k_base *ab = ab_pci->ab;\n\n\tswitch (mhi_state) {\n\tcase ATH12K_MHI_INIT:\n\t\tif (!test_bit(ATH12K_MHI_INIT, &ab_pci->mhi_state))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase ATH12K_MHI_DEINIT:\n\tcase ATH12K_MHI_POWER_ON:\n\t\tif (test_bit(ATH12K_MHI_INIT, &ab_pci->mhi_state) &&\n\t\t    !test_bit(ATH12K_MHI_POWER_ON, &ab_pci->mhi_state))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase ATH12K_MHI_FORCE_POWER_OFF:\n\t\tif (test_bit(ATH12K_MHI_POWER_ON, &ab_pci->mhi_state))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase ATH12K_MHI_POWER_OFF:\n\tcase ATH12K_MHI_SUSPEND:\n\t\tif (test_bit(ATH12K_MHI_POWER_ON, &ab_pci->mhi_state) &&\n\t\t    !test_bit(ATH12K_MHI_SUSPEND, &ab_pci->mhi_state))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase ATH12K_MHI_RESUME:\n\t\tif (test_bit(ATH12K_MHI_SUSPEND, &ab_pci->mhi_state))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase ATH12K_MHI_TRIGGER_RDDM:\n\t\tif (test_bit(ATH12K_MHI_POWER_ON, &ab_pci->mhi_state) &&\n\t\t    !test_bit(ATH12K_MHI_TRIGGER_RDDM, &ab_pci->mhi_state))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase ATH12K_MHI_RDDM_DONE:\n\t\treturn 0;\n\tdefault:\n\t\tath12k_err(ab, \"unhandled mhi state: %s(%d)\\n\",\n\t\t\t   ath12k_mhi_state_to_str(mhi_state), mhi_state);\n\t}\n\n\tath12k_err(ab, \"failed to set mhi state %s(%d) in current mhi state (0x%lx)\\n\",\n\t\t   ath12k_mhi_state_to_str(mhi_state), mhi_state,\n\t\t   ab_pci->mhi_state);\n\n\treturn -EINVAL;\n}\n\nstatic int ath12k_mhi_set_state(struct ath12k_pci *ab_pci,\n\t\t\t\tenum ath12k_mhi_state mhi_state)\n{\n\tstruct ath12k_base *ab = ab_pci->ab;\n\tint ret;\n\n\tret = ath12k_mhi_check_state_bit(ab_pci, mhi_state);\n\tif (ret)\n\t\tgoto out;\n\n\tath12k_dbg(ab, ATH12K_DBG_PCI, \"setting mhi state: %s(%d)\\n\",\n\t\t   ath12k_mhi_state_to_str(mhi_state), mhi_state);\n\n\tswitch (mhi_state) {\n\tcase ATH12K_MHI_INIT:\n\t\tret = mhi_prepare_for_power_up(ab_pci->mhi_ctrl);\n\t\tbreak;\n\tcase ATH12K_MHI_DEINIT:\n\t\tmhi_unprepare_after_power_down(ab_pci->mhi_ctrl);\n\t\tret = 0;\n\t\tbreak;\n\tcase ATH12K_MHI_POWER_ON:\n\t\tret = mhi_async_power_up(ab_pci->mhi_ctrl);\n\t\tbreak;\n\tcase ATH12K_MHI_POWER_OFF:\n\t\tmhi_power_down(ab_pci->mhi_ctrl, true);\n\t\tret = 0;\n\t\tbreak;\n\tcase ATH12K_MHI_FORCE_POWER_OFF:\n\t\tmhi_power_down(ab_pci->mhi_ctrl, false);\n\t\tret = 0;\n\t\tbreak;\n\tcase ATH12K_MHI_SUSPEND:\n\t\tret = mhi_pm_suspend(ab_pci->mhi_ctrl);\n\t\tbreak;\n\tcase ATH12K_MHI_RESUME:\n\t\tret = mhi_pm_resume(ab_pci->mhi_ctrl);\n\t\tbreak;\n\tcase ATH12K_MHI_TRIGGER_RDDM:\n\t\tret = mhi_force_rddm_mode(ab_pci->mhi_ctrl);\n\t\tbreak;\n\tcase ATH12K_MHI_RDDM_DONE:\n\t\tbreak;\n\tdefault:\n\t\tath12k_err(ab, \"unhandled MHI state (%d)\\n\", mhi_state);\n\t\tret = -EINVAL;\n\t}\n\n\tif (ret)\n\t\tgoto out;\n\n\tath12k_mhi_set_state_bit(ab_pci, mhi_state);\n\n\treturn 0;\n\nout:\n\tath12k_err(ab, \"failed to set mhi state: %s(%d)\\n\",\n\t\t   ath12k_mhi_state_to_str(mhi_state), mhi_state);\n\treturn ret;\n}\n\nint ath12k_mhi_start(struct ath12k_pci *ab_pci)\n{\n\tint ret;\n\n\tab_pci->mhi_ctrl->timeout_ms = MHI_TIMEOUT_DEFAULT_MS;\n\n\tret = ath12k_mhi_set_state(ab_pci, ATH12K_MHI_INIT);\n\tif (ret)\n\t\tgoto out;\n\n\tret = ath12k_mhi_set_state(ab_pci, ATH12K_MHI_POWER_ON);\n\tif (ret)\n\t\tgoto out;\n\n\treturn 0;\n\nout:\n\treturn ret;\n}\n\nvoid ath12k_mhi_stop(struct ath12k_pci *ab_pci)\n{\n\tath12k_mhi_set_state(ab_pci, ATH12K_MHI_POWER_OFF);\n\tath12k_mhi_set_state(ab_pci, ATH12K_MHI_DEINIT);\n}\n\nvoid ath12k_mhi_suspend(struct ath12k_pci *ab_pci)\n{\n\tath12k_mhi_set_state(ab_pci, ATH12K_MHI_SUSPEND);\n}\n\nvoid ath12k_mhi_resume(struct ath12k_pci *ab_pci)\n{\n\tath12k_mhi_set_state(ab_pci, ATH12K_MHI_RESUME);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}