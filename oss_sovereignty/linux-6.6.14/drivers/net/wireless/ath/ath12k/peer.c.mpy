{
  "module_name": "peer.c",
  "hash_id": "5895676736b56aa349abb87c9c442c8234ccef9eabb2c6b0c2e4c24541549029",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath12k/peer.c",
  "human_readable_source": "\n \n\n#include \"core.h\"\n#include \"peer.h\"\n#include \"debug.h\"\n\nstruct ath12k_peer *ath12k_peer_find(struct ath12k_base *ab, int vdev_id,\n\t\t\t\t     const u8 *addr)\n{\n\tstruct ath12k_peer *peer;\n\n\tlockdep_assert_held(&ab->base_lock);\n\n\tlist_for_each_entry(peer, &ab->peers, list) {\n\t\tif (peer->vdev_id != vdev_id)\n\t\t\tcontinue;\n\t\tif (!ether_addr_equal(peer->addr, addr))\n\t\t\tcontinue;\n\n\t\treturn peer;\n\t}\n\n\treturn NULL;\n}\n\nstatic struct ath12k_peer *ath12k_peer_find_by_pdev_idx(struct ath12k_base *ab,\n\t\t\t\t\t\t\tu8 pdev_idx, const u8 *addr)\n{\n\tstruct ath12k_peer *peer;\n\n\tlockdep_assert_held(&ab->base_lock);\n\n\tlist_for_each_entry(peer, &ab->peers, list) {\n\t\tif (peer->pdev_idx != pdev_idx)\n\t\t\tcontinue;\n\t\tif (!ether_addr_equal(peer->addr, addr))\n\t\t\tcontinue;\n\n\t\treturn peer;\n\t}\n\n\treturn NULL;\n}\n\nstruct ath12k_peer *ath12k_peer_find_by_addr(struct ath12k_base *ab,\n\t\t\t\t\t     const u8 *addr)\n{\n\tstruct ath12k_peer *peer;\n\n\tlockdep_assert_held(&ab->base_lock);\n\n\tlist_for_each_entry(peer, &ab->peers, list) {\n\t\tif (!ether_addr_equal(peer->addr, addr))\n\t\t\tcontinue;\n\n\t\treturn peer;\n\t}\n\n\treturn NULL;\n}\n\nstruct ath12k_peer *ath12k_peer_find_by_id(struct ath12k_base *ab,\n\t\t\t\t\t   int peer_id)\n{\n\tstruct ath12k_peer *peer;\n\n\tlockdep_assert_held(&ab->base_lock);\n\n\tlist_for_each_entry(peer, &ab->peers, list)\n\t\tif (peer_id == peer->peer_id)\n\t\t\treturn peer;\n\n\treturn NULL;\n}\n\nbool ath12k_peer_exist_by_vdev_id(struct ath12k_base *ab, int vdev_id)\n{\n\tstruct ath12k_peer *peer;\n\n\tspin_lock_bh(&ab->base_lock);\n\n\tlist_for_each_entry(peer, &ab->peers, list) {\n\t\tif (vdev_id == peer->vdev_id) {\n\t\t\tspin_unlock_bh(&ab->base_lock);\n\t\t\treturn true;\n\t\t}\n\t}\n\tspin_unlock_bh(&ab->base_lock);\n\treturn false;\n}\n\nstruct ath12k_peer *ath12k_peer_find_by_ast(struct ath12k_base *ab,\n\t\t\t\t\t    int ast_hash)\n{\n\tstruct ath12k_peer *peer;\n\n\tlockdep_assert_held(&ab->base_lock);\n\n\tlist_for_each_entry(peer, &ab->peers, list)\n\t\tif (ast_hash == peer->ast_hash)\n\t\t\treturn peer;\n\n\treturn NULL;\n}\n\nvoid ath12k_peer_unmap_event(struct ath12k_base *ab, u16 peer_id)\n{\n\tstruct ath12k_peer *peer;\n\n\tspin_lock_bh(&ab->base_lock);\n\n\tpeer = ath12k_peer_find_by_id(ab, peer_id);\n\tif (!peer) {\n\t\tath12k_warn(ab, \"peer-unmap-event: unknown peer id %d\\n\",\n\t\t\t    peer_id);\n\t\tgoto exit;\n\t}\n\n\tath12k_dbg(ab, ATH12K_DBG_DP_HTT, \"htt peer unmap vdev %d peer %pM id %d\\n\",\n\t\t   peer->vdev_id, peer->addr, peer_id);\n\n\tlist_del(&peer->list);\n\tkfree(peer);\n\twake_up(&ab->peer_mapping_wq);\n\nexit:\n\tspin_unlock_bh(&ab->base_lock);\n}\n\nvoid ath12k_peer_map_event(struct ath12k_base *ab, u8 vdev_id, u16 peer_id,\n\t\t\t   u8 *mac_addr, u16 ast_hash, u16 hw_peer_id)\n{\n\tstruct ath12k_peer *peer;\n\n\tspin_lock_bh(&ab->base_lock);\n\tpeer = ath12k_peer_find(ab, vdev_id, mac_addr);\n\tif (!peer) {\n\t\tpeer = kzalloc(sizeof(*peer), GFP_ATOMIC);\n\t\tif (!peer)\n\t\t\tgoto exit;\n\n\t\tpeer->vdev_id = vdev_id;\n\t\tpeer->peer_id = peer_id;\n\t\tpeer->ast_hash = ast_hash;\n\t\tpeer->hw_peer_id = hw_peer_id;\n\t\tether_addr_copy(peer->addr, mac_addr);\n\t\tlist_add(&peer->list, &ab->peers);\n\t\twake_up(&ab->peer_mapping_wq);\n\t}\n\n\tath12k_dbg(ab, ATH12K_DBG_DP_HTT, \"htt peer map vdev %d peer %pM id %d\\n\",\n\t\t   vdev_id, mac_addr, peer_id);\n\nexit:\n\tspin_unlock_bh(&ab->base_lock);\n}\n\nstatic int ath12k_wait_for_peer_common(struct ath12k_base *ab, int vdev_id,\n\t\t\t\t       const u8 *addr, bool expect_mapped)\n{\n\tint ret;\n\n\tret = wait_event_timeout(ab->peer_mapping_wq, ({\n\t\t\t\tbool mapped;\n\n\t\t\t\tspin_lock_bh(&ab->base_lock);\n\t\t\t\tmapped = !!ath12k_peer_find(ab, vdev_id, addr);\n\t\t\t\tspin_unlock_bh(&ab->base_lock);\n\n\t\t\t\t(mapped == expect_mapped ||\n\t\t\t\t test_bit(ATH12K_FLAG_CRASH_FLUSH, &ab->dev_flags));\n\t\t\t\t}), 3 * HZ);\n\n\tif (ret <= 0)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nvoid ath12k_peer_cleanup(struct ath12k *ar, u32 vdev_id)\n{\n\tstruct ath12k_peer *peer, *tmp;\n\tstruct ath12k_base *ab = ar->ab;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tspin_lock_bh(&ab->base_lock);\n\tlist_for_each_entry_safe(peer, tmp, &ab->peers, list) {\n\t\tif (peer->vdev_id != vdev_id)\n\t\t\tcontinue;\n\n\t\tath12k_warn(ab, \"removing stale peer %pM from vdev_id %d\\n\",\n\t\t\t    peer->addr, vdev_id);\n\n\t\tlist_del(&peer->list);\n\t\tkfree(peer);\n\t\tar->num_peers--;\n\t}\n\n\tspin_unlock_bh(&ab->base_lock);\n}\n\nstatic int ath12k_wait_for_peer_deleted(struct ath12k *ar, int vdev_id, const u8 *addr)\n{\n\treturn ath12k_wait_for_peer_common(ar->ab, vdev_id, addr, false);\n}\n\nint ath12k_wait_for_peer_delete_done(struct ath12k *ar, u32 vdev_id,\n\t\t\t\t     const u8 *addr)\n{\n\tint ret;\n\tunsigned long time_left;\n\n\tret = ath12k_wait_for_peer_deleted(ar, vdev_id, addr);\n\tif (ret) {\n\t\tath12k_warn(ar->ab, \"failed wait for peer deleted\");\n\t\treturn ret;\n\t}\n\n\ttime_left = wait_for_completion_timeout(&ar->peer_delete_done,\n\t\t\t\t\t\t3 * HZ);\n\tif (time_left == 0) {\n\t\tath12k_warn(ar->ab, \"Timeout in receiving peer delete response\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nint ath12k_peer_delete(struct ath12k *ar, u32 vdev_id, u8 *addr)\n{\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\treinit_completion(&ar->peer_delete_done);\n\n\tret = ath12k_wmi_send_peer_delete_cmd(ar, addr, vdev_id);\n\tif (ret) {\n\t\tath12k_warn(ar->ab,\n\t\t\t    \"failed to delete peer vdev_id %d addr %pM ret %d\\n\",\n\t\t\t    vdev_id, addr, ret);\n\t\treturn ret;\n\t}\n\n\tret = ath12k_wait_for_peer_delete_done(ar, vdev_id, addr);\n\tif (ret)\n\t\treturn ret;\n\n\tar->num_peers--;\n\n\treturn 0;\n}\n\nstatic int ath12k_wait_for_peer_created(struct ath12k *ar, int vdev_id, const u8 *addr)\n{\n\treturn ath12k_wait_for_peer_common(ar->ab, vdev_id, addr, true);\n}\n\nint ath12k_peer_create(struct ath12k *ar, struct ath12k_vif *arvif,\n\t\t       struct ieee80211_sta *sta,\n\t\t       struct ath12k_wmi_peer_create_arg *arg)\n{\n\tstruct ath12k_peer *peer;\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (ar->num_peers > (ar->max_num_peers - 1)) {\n\t\tath12k_warn(ar->ab,\n\t\t\t    \"failed to create peer due to insufficient peer entry resource in firmware\\n\");\n\t\treturn -ENOBUFS;\n\t}\n\n\tspin_lock_bh(&ar->ab->base_lock);\n\tpeer = ath12k_peer_find_by_pdev_idx(ar->ab, ar->pdev_idx, arg->peer_addr);\n\tif (peer) {\n\t\tspin_unlock_bh(&ar->ab->base_lock);\n\t\treturn -EINVAL;\n\t}\n\tspin_unlock_bh(&ar->ab->base_lock);\n\n\tret = ath12k_wmi_send_peer_create_cmd(ar, arg);\n\tif (ret) {\n\t\tath12k_warn(ar->ab,\n\t\t\t    \"failed to send peer create vdev_id %d ret %d\\n\",\n\t\t\t    arg->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\tret = ath12k_wait_for_peer_created(ar, arg->vdev_id,\n\t\t\t\t\t   arg->peer_addr);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock_bh(&ar->ab->base_lock);\n\n\tpeer = ath12k_peer_find(ar->ab, arg->vdev_id, arg->peer_addr);\n\tif (!peer) {\n\t\tspin_unlock_bh(&ar->ab->base_lock);\n\t\tath12k_warn(ar->ab, \"failed to find peer %pM on vdev %i after creation\\n\",\n\t\t\t    arg->peer_addr, arg->vdev_id);\n\n\t\treinit_completion(&ar->peer_delete_done);\n\n\t\tret = ath12k_wmi_send_peer_delete_cmd(ar, arg->peer_addr,\n\t\t\t\t\t\t      arg->vdev_id);\n\t\tif (ret) {\n\t\t\tath12k_warn(ar->ab, \"failed to delete peer vdev_id %d addr %pM\\n\",\n\t\t\t\t    arg->vdev_id, arg->peer_addr);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = ath12k_wait_for_peer_delete_done(ar, arg->vdev_id,\n\t\t\t\t\t\t       arg->peer_addr);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\treturn -ENOENT;\n\t}\n\n\tpeer->pdev_idx = ar->pdev_idx;\n\tpeer->sta = sta;\n\n\tif (arvif->vif->type == NL80211_IFTYPE_STATION) {\n\t\tarvif->ast_hash = peer->ast_hash;\n\t\tarvif->ast_idx = peer->hw_peer_id;\n\t}\n\n\tpeer->sec_type = HAL_ENCRYPT_TYPE_OPEN;\n\tpeer->sec_type_grp = HAL_ENCRYPT_TYPE_OPEN;\n\n\tar->num_peers++;\n\n\tspin_unlock_bh(&ar->ab->base_lock);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}