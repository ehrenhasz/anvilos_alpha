{
  "module_name": "wmi.c",
  "hash_id": "fac1bc0a793bb272a7cbacd25cbcc2e49a5ad14eb1d5b7be416819ca142d781f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath6kl/wmi.c",
  "human_readable_source": " \n\n#include <linux/ip.h>\n#include <linux/in.h>\n#include \"core.h\"\n#include \"debug.h\"\n#include \"testmode.h\"\n#include \"trace.h\"\n#include \"../regd.h\"\n#include \"../regd_common.h\"\n\nstatic int ath6kl_wmi_sync_point(struct wmi *wmi, u8 if_idx);\n\nstatic const s32 wmi_rate_tbl[][2] = {\n\t \n\t{1000, 1000},\n\t{2000, 2000},\n\t{5500, 5500},\n\t{11000, 11000},\n\t{6000, 6000},\n\t{9000, 9000},\n\t{12000, 12000},\n\t{18000, 18000},\n\t{24000, 24000},\n\t{36000, 36000},\n\t{48000, 48000},\n\t{54000, 54000},\n\t{6500, 7200},\n\t{13000, 14400},\n\t{19500, 21700},\n\t{26000, 28900},\n\t{39000, 43300},\n\t{52000, 57800},\n\t{58500, 65000},\n\t{65000, 72200},\n\t{13500, 15000},\n\t{27000, 30000},\n\t{40500, 45000},\n\t{54000, 60000},\n\t{81000, 90000},\n\t{108000, 120000},\n\t{121500, 135000},\n\t{135000, 150000},\n\t{0, 0}\n};\n\nstatic const s32 wmi_rate_tbl_mcs15[][2] = {\n\t \n\t{1000, 1000},\n\t{2000, 2000},\n\t{5500, 5500},\n\t{11000, 11000},\n\t{6000, 6000},\n\t{9000, 9000},\n\t{12000, 12000},\n\t{18000, 18000},\n\t{24000, 24000},\n\t{36000, 36000},\n\t{48000, 48000},\n\t{54000, 54000},\n\t{6500, 7200},      \n\t{13000, 14400},\n\t{19500, 21700},\n\t{26000, 28900},\n\t{39000, 43300},\n\t{52000, 57800},\n\t{58500, 65000},\n\t{65000, 72200},\n\t{13000, 14400},    \n\t{26000, 28900},\n\t{39000, 43300},\n\t{52000, 57800},\n\t{78000, 86700},\n\t{104000, 115600},\n\t{117000, 130000},\n\t{130000, 144400},  \n\t{13500, 15000},    \n\t{27000, 30000},\n\t{40500, 45000},\n\t{54000, 60000},\n\t{81000, 90000},\n\t{108000, 120000},\n\t{121500, 135000},\n\t{135000, 150000},\n\t{27000, 30000},    \n\t{54000, 60000},\n\t{81000, 90000},\n\t{108000, 120000},\n\t{162000, 180000},\n\t{216000, 240000},\n\t{243000, 270000},\n\t{270000, 300000},  \n\t{0, 0}\n};\n\n \nstatic const u8 up_to_ac[] = {\n\tWMM_AC_BE,\n\tWMM_AC_BK,\n\tWMM_AC_BK,\n\tWMM_AC_BE,\n\tWMM_AC_VI,\n\tWMM_AC_VI,\n\tWMM_AC_VO,\n\tWMM_AC_VO,\n};\n\nvoid ath6kl_wmi_set_control_ep(struct wmi *wmi, enum htc_endpoint_id ep_id)\n{\n\tif (WARN_ON(ep_id == ENDPOINT_UNUSED || ep_id >= ENDPOINT_MAX))\n\t\treturn;\n\n\twmi->ep_id = ep_id;\n}\n\nenum htc_endpoint_id ath6kl_wmi_get_control_ep(struct wmi *wmi)\n{\n\treturn wmi->ep_id;\n}\n\nstruct ath6kl_vif *ath6kl_get_vif_by_index(struct ath6kl *ar, u8 if_idx)\n{\n\tstruct ath6kl_vif *vif, *found = NULL;\n\n\tif (WARN_ON(if_idx > (ar->vif_max - 1)))\n\t\treturn NULL;\n\n\t \n\tspin_lock_bh(&ar->list_lock);\n\tlist_for_each_entry(vif, &ar->vif_list, list) {\n\t\tif (vif->fw_vif_idx == if_idx) {\n\t\t\tfound = vif;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_bh(&ar->list_lock);\n\n\treturn found;\n}\n\n \nint ath6kl_wmi_dix_2_dot3(struct wmi *wmi, struct sk_buff *skb)\n{\n\tstruct ath6kl_llc_snap_hdr *llc_hdr;\n\tstruct ethhdr *eth_hdr;\n\tsize_t new_len;\n\t__be16 type;\n\tu8 *datap;\n\tu16 size;\n\n\tif (WARN_ON(skb == NULL))\n\t\treturn -EINVAL;\n\n\tsize = sizeof(struct ath6kl_llc_snap_hdr) + sizeof(struct wmi_data_hdr);\n\tif (skb_headroom(skb) < size)\n\t\treturn -ENOMEM;\n\n\teth_hdr = (struct ethhdr *) skb->data;\n\ttype = eth_hdr->h_proto;\n\n\tif (!is_ethertype(be16_to_cpu(type))) {\n\t\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t\t   \"%s: pkt is already in 802.3 format\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tnew_len = skb->len - sizeof(*eth_hdr) + sizeof(*llc_hdr);\n\n\tskb_push(skb, sizeof(struct ath6kl_llc_snap_hdr));\n\tdatap = skb->data;\n\n\teth_hdr->h_proto = cpu_to_be16(new_len);\n\n\tmemcpy(datap, eth_hdr, sizeof(*eth_hdr));\n\n\tllc_hdr = (struct ath6kl_llc_snap_hdr *)(datap + sizeof(*eth_hdr));\n\tllc_hdr->dsap = 0xAA;\n\tllc_hdr->ssap = 0xAA;\n\tllc_hdr->cntl = 0x03;\n\tllc_hdr->org_code[0] = 0x0;\n\tllc_hdr->org_code[1] = 0x0;\n\tllc_hdr->org_code[2] = 0x0;\n\tllc_hdr->eth_type = type;\n\n\treturn 0;\n}\n\nstatic int ath6kl_wmi_meta_add(struct wmi *wmi, struct sk_buff *skb,\n\t\t\t       u8 *version, void *tx_meta_info)\n{\n\tstruct wmi_tx_meta_v1 *v1;\n\tstruct wmi_tx_meta_v2 *v2;\n\n\tif (WARN_ON(skb == NULL || version == NULL))\n\t\treturn -EINVAL;\n\n\tswitch (*version) {\n\tcase WMI_META_VERSION_1:\n\t\tskb_push(skb, WMI_MAX_TX_META_SZ);\n\t\tv1 = (struct wmi_tx_meta_v1 *) skb->data;\n\t\tv1->pkt_id = 0;\n\t\tv1->rate_plcy_id = 0;\n\t\t*version = WMI_META_VERSION_1;\n\t\tbreak;\n\tcase WMI_META_VERSION_2:\n\t\tskb_push(skb, WMI_MAX_TX_META_SZ);\n\t\tv2 = (struct wmi_tx_meta_v2 *) skb->data;\n\t\tmemcpy(v2, (struct wmi_tx_meta_v2 *) tx_meta_info,\n\t\t       sizeof(struct wmi_tx_meta_v2));\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nint ath6kl_wmi_data_hdr_add(struct wmi *wmi, struct sk_buff *skb,\n\t\t\t    u8 msg_type, u32 flags,\n\t\t\t    enum wmi_data_hdr_data_type data_type,\n\t\t\t    u8 meta_ver, void *tx_meta_info, u8 if_idx)\n{\n\tstruct wmi_data_hdr *data_hdr;\n\tint ret;\n\n\tif (WARN_ON(skb == NULL || (if_idx > wmi->parent_dev->vif_max - 1)))\n\t\treturn -EINVAL;\n\n\tif (tx_meta_info) {\n\t\tret = ath6kl_wmi_meta_add(wmi, skb, &meta_ver, tx_meta_info);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tskb_push(skb, sizeof(struct wmi_data_hdr));\n\n\tdata_hdr = (struct wmi_data_hdr *)skb->data;\n\tmemset(data_hdr, 0, sizeof(struct wmi_data_hdr));\n\n\tdata_hdr->info = msg_type << WMI_DATA_HDR_MSG_TYPE_SHIFT;\n\tdata_hdr->info |= data_type << WMI_DATA_HDR_DATA_TYPE_SHIFT;\n\n\tif (flags & WMI_DATA_HDR_FLAGS_MORE)\n\t\tdata_hdr->info |= WMI_DATA_HDR_MORE;\n\n\tif (flags & WMI_DATA_HDR_FLAGS_EOSP)\n\t\tdata_hdr->info3 |= cpu_to_le16(WMI_DATA_HDR_EOSP);\n\n\tdata_hdr->info2 |= cpu_to_le16(meta_ver << WMI_DATA_HDR_META_SHIFT);\n\tdata_hdr->info3 |= cpu_to_le16(if_idx & WMI_DATA_HDR_IF_IDX_MASK);\n\n\treturn 0;\n}\n\nu8 ath6kl_wmi_determine_user_priority(u8 *pkt, u32 layer2_pri)\n{\n\tstruct iphdr *ip_hdr = (struct iphdr *) pkt;\n\tu8 ip_pri;\n\n\t \n\tip_pri = ip_hdr->tos >> 5;\n\tip_pri &= 0x7;\n\n\tif ((layer2_pri & 0x7) > ip_pri)\n\t\treturn (u8) layer2_pri & 0x7;\n\telse\n\t\treturn ip_pri;\n}\n\nu8 ath6kl_wmi_get_traffic_class(u8 user_priority)\n{\n\treturn  up_to_ac[user_priority & 0x7];\n}\n\nint ath6kl_wmi_implicit_create_pstream(struct wmi *wmi, u8 if_idx,\n\t\t\t\t       struct sk_buff *skb,\n\t\t\t\t       u32 layer2_priority, bool wmm_enabled,\n\t\t\t\t       u8 *ac)\n{\n\tstruct wmi_data_hdr *data_hdr;\n\tstruct ath6kl_llc_snap_hdr *llc_hdr;\n\tstruct wmi_create_pstream_cmd cmd;\n\tu32 meta_size, hdr_size;\n\tu16 ip_type = IP_ETHERTYPE;\n\tu8 stream_exist, usr_pri;\n\tu8 traffic_class = WMM_AC_BE;\n\tu8 *datap;\n\n\tif (WARN_ON(skb == NULL))\n\t\treturn -EINVAL;\n\n\tdatap = skb->data;\n\tdata_hdr = (struct wmi_data_hdr *) datap;\n\n\tmeta_size = ((le16_to_cpu(data_hdr->info2) >> WMI_DATA_HDR_META_SHIFT) &\n\t\t     WMI_DATA_HDR_META_MASK) ? WMI_MAX_TX_META_SZ : 0;\n\n\tif (!wmm_enabled) {\n\t\t \n\t\tusr_pri = 0;\n\t} else {\n\t\thdr_size = sizeof(struct ethhdr);\n\n\t\tllc_hdr = (struct ath6kl_llc_snap_hdr *)(datap +\n\t\t\t\t\t\t\t sizeof(struct\n\t\t\t\t\t\t\t\twmi_data_hdr) +\n\t\t\t\t\t\t\t meta_size + hdr_size);\n\n\t\tif (llc_hdr->eth_type == htons(ip_type)) {\n\t\t\t \n\t\t\tusr_pri =\n\t\t\t   ath6kl_wmi_determine_user_priority(((u8 *) llc_hdr) +\n\t\t\t\t\tsizeof(struct ath6kl_llc_snap_hdr),\n\t\t\t\t\tlayer2_priority);\n\t\t} else {\n\t\t\tusr_pri = layer2_priority & 0x7;\n\t\t}\n\n\t\t \n\t\tif (skb->protocol == cpu_to_be16(ETH_P_PAE))\n\t\t\tusr_pri = WMI_VOICE_USER_PRIORITY;\n\t}\n\n\t \n\tif ((wmi->traffic_class == WMM_AC_VI) &&\n\t    ((usr_pri == 5) || (usr_pri == 4)))\n\t\tusr_pri = 1;\n\n\t \n\ttraffic_class = up_to_ac[usr_pri & 0x7];\n\n\twmi_data_hdr_set_up(data_hdr, usr_pri);\n\n\tspin_lock_bh(&wmi->lock);\n\tstream_exist = wmi->fat_pipe_exist;\n\tspin_unlock_bh(&wmi->lock);\n\n\tif (!(stream_exist & (1 << traffic_class))) {\n\t\tmemset(&cmd, 0, sizeof(cmd));\n\t\tcmd.traffic_class = traffic_class;\n\t\tcmd.user_pri = usr_pri;\n\t\tcmd.inactivity_int =\n\t\t\tcpu_to_le32(WMI_IMPLICIT_PSTREAM_INACTIVITY_INT);\n\t\t \n\t\tcmd.tsid = WMI_IMPLICIT_PSTREAM;\n\t\tath6kl_wmi_create_pstream_cmd(wmi, if_idx, &cmd);\n\t}\n\n\t*ac = traffic_class;\n\n\treturn 0;\n}\n\nint ath6kl_wmi_dot11_hdr_remove(struct wmi *wmi, struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr_3addr *pwh, wh;\n\tstruct ath6kl_llc_snap_hdr *llc_hdr;\n\tstruct ethhdr eth_hdr;\n\tu32 hdr_size;\n\tu8 *datap;\n\t__le16 sub_type;\n\n\tif (WARN_ON(skb == NULL))\n\t\treturn -EINVAL;\n\n\tdatap = skb->data;\n\tpwh = (struct ieee80211_hdr_3addr *) datap;\n\n\tsub_type = pwh->frame_control & cpu_to_le16(IEEE80211_FCTL_STYPE);\n\n\tmemcpy((u8 *) &wh, datap, sizeof(struct ieee80211_hdr_3addr));\n\n\t \n\tif (sub_type == cpu_to_le16(IEEE80211_STYPE_QOS_DATA)) {\n\t\thdr_size = roundup(sizeof(struct ieee80211_qos_hdr),\n\t\t\t\t   sizeof(u32));\n\t\tskb_pull(skb, hdr_size);\n\t} else if (sub_type == cpu_to_le16(IEEE80211_STYPE_DATA)) {\n\t\tskb_pull(skb, sizeof(struct ieee80211_hdr_3addr));\n\t}\n\n\tdatap = skb->data;\n\tllc_hdr = (struct ath6kl_llc_snap_hdr *)(datap);\n\n\tmemset(&eth_hdr, 0, sizeof(eth_hdr));\n\teth_hdr.h_proto = llc_hdr->eth_type;\n\n\tswitch ((le16_to_cpu(wh.frame_control)) &\n\t\t(IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS)) {\n\tcase IEEE80211_FCTL_TODS:\n\t\tmemcpy(eth_hdr.h_dest, wh.addr3, ETH_ALEN);\n\t\tmemcpy(eth_hdr.h_source, wh.addr2, ETH_ALEN);\n\t\tbreak;\n\tcase IEEE80211_FCTL_FROMDS:\n\t\tmemcpy(eth_hdr.h_dest, wh.addr1, ETH_ALEN);\n\t\tmemcpy(eth_hdr.h_source, wh.addr3, ETH_ALEN);\n\t\tbreak;\n\tcase IEEE80211_FCTL_FROMDS | IEEE80211_FCTL_TODS:\n\t\tbreak;\n\tdefault:\n\t\tmemcpy(eth_hdr.h_dest, wh.addr1, ETH_ALEN);\n\t\tmemcpy(eth_hdr.h_source, wh.addr2, ETH_ALEN);\n\t\tbreak;\n\t}\n\n\tskb_pull(skb, sizeof(struct ath6kl_llc_snap_hdr));\n\tskb_push(skb, sizeof(eth_hdr));\n\n\tdatap = skb->data;\n\n\tmemcpy(datap, &eth_hdr, sizeof(eth_hdr));\n\n\treturn 0;\n}\n\n \nint ath6kl_wmi_dot3_2_dix(struct sk_buff *skb)\n{\n\tstruct ath6kl_llc_snap_hdr *llc_hdr;\n\tstruct ethhdr eth_hdr;\n\tu8 *datap;\n\n\tif (WARN_ON(skb == NULL))\n\t\treturn -EINVAL;\n\n\tdatap = skb->data;\n\n\tmemcpy(&eth_hdr, datap, sizeof(eth_hdr));\n\n\tllc_hdr = (struct ath6kl_llc_snap_hdr *) (datap + sizeof(eth_hdr));\n\teth_hdr.h_proto = llc_hdr->eth_type;\n\n\tskb_pull(skb, sizeof(struct ath6kl_llc_snap_hdr));\n\tdatap = skb->data;\n\n\tmemcpy(datap, &eth_hdr, sizeof(eth_hdr));\n\n\treturn 0;\n}\n\nstatic int ath6kl_wmi_tx_complete_event_rx(u8 *datap, int len)\n{\n\tstruct tx_complete_msg_v1 *msg_v1;\n\tstruct wmi_tx_complete_event *evt;\n\tint index;\n\tu16 size;\n\n\tevt = (struct wmi_tx_complete_event *) datap;\n\n\tath6kl_dbg(ATH6KL_DBG_WMI, \"comp: %d %d %d\\n\",\n\t\t   evt->num_msg, evt->msg_len, evt->msg_type);\n\n\tfor (index = 0; index < evt->num_msg; index++) {\n\t\tsize = sizeof(struct wmi_tx_complete_event) +\n\t\t    (index * sizeof(struct tx_complete_msg_v1));\n\t\tmsg_v1 = (struct tx_complete_msg_v1 *)(datap + size);\n\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"msg: %d %d %d %d\\n\",\n\t\t\t   msg_v1->status, msg_v1->pkt_id,\n\t\t\t   msg_v1->rate_idx, msg_v1->ack_failures);\n\t}\n\n\treturn 0;\n}\n\nstatic int ath6kl_wmi_remain_on_chnl_event_rx(struct wmi *wmi, u8 *datap,\n\t\t\t\t\t      int len, struct ath6kl_vif *vif)\n{\n\tstruct wmi_remain_on_chnl_event *ev;\n\tu32 freq;\n\tu32 dur;\n\tstruct ieee80211_channel *chan;\n\tstruct ath6kl *ar = wmi->parent_dev;\n\tu32 id;\n\n\tif (len < sizeof(*ev))\n\t\treturn -EINVAL;\n\n\tev = (struct wmi_remain_on_chnl_event *) datap;\n\tfreq = le32_to_cpu(ev->freq);\n\tdur = le32_to_cpu(ev->duration);\n\tath6kl_dbg(ATH6KL_DBG_WMI, \"remain_on_chnl: freq=%u dur=%u\\n\",\n\t\t   freq, dur);\n\tchan = ieee80211_get_channel(ar->wiphy, freq);\n\tif (!chan) {\n\t\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t\t   \"remain_on_chnl: Unknown channel (freq=%u)\\n\",\n\t\t\t   freq);\n\t\treturn -EINVAL;\n\t}\n\tid = vif->last_roc_id;\n\tcfg80211_ready_on_channel(&vif->wdev, id, chan,\n\t\t\t\t  dur, GFP_ATOMIC);\n\n\treturn 0;\n}\n\nstatic int ath6kl_wmi_cancel_remain_on_chnl_event_rx(struct wmi *wmi,\n\t\t\t\t\t\t     u8 *datap, int len,\n\t\t\t\t\t\t     struct ath6kl_vif *vif)\n{\n\tstruct wmi_cancel_remain_on_chnl_event *ev;\n\tu32 freq;\n\tu32 dur;\n\tstruct ieee80211_channel *chan;\n\tstruct ath6kl *ar = wmi->parent_dev;\n\tu32 id;\n\n\tif (len < sizeof(*ev))\n\t\treturn -EINVAL;\n\n\tev = (struct wmi_cancel_remain_on_chnl_event *) datap;\n\tfreq = le32_to_cpu(ev->freq);\n\tdur = le32_to_cpu(ev->duration);\n\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t   \"cancel_remain_on_chnl: freq=%u dur=%u status=%u\\n\",\n\t\t   freq, dur, ev->status);\n\tchan = ieee80211_get_channel(ar->wiphy, freq);\n\tif (!chan) {\n\t\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t\t   \"cancel_remain_on_chnl: Unknown channel (freq=%u)\\n\",\n\t\t\t   freq);\n\t\treturn -EINVAL;\n\t}\n\tif (vif->last_cancel_roc_id &&\n\t    vif->last_cancel_roc_id + 1 == vif->last_roc_id)\n\t\tid = vif->last_cancel_roc_id;  \n\telse\n\t\tid = vif->last_roc_id;  \n\tvif->last_cancel_roc_id = 0;\n\tcfg80211_remain_on_channel_expired(&vif->wdev, id, chan, GFP_ATOMIC);\n\n\treturn 0;\n}\n\nstatic int ath6kl_wmi_tx_status_event_rx(struct wmi *wmi, u8 *datap, int len,\n\t\t\t\t\t struct ath6kl_vif *vif)\n{\n\tstruct wmi_tx_status_event *ev;\n\tu32 id;\n\n\tif (len < sizeof(*ev))\n\t\treturn -EINVAL;\n\n\tev = (struct wmi_tx_status_event *) datap;\n\tid = le32_to_cpu(ev->id);\n\tath6kl_dbg(ATH6KL_DBG_WMI, \"tx_status: id=%x ack_status=%u\\n\",\n\t\t   id, ev->ack_status);\n\tif (wmi->last_mgmt_tx_frame) {\n\t\tcfg80211_mgmt_tx_status(&vif->wdev, id,\n\t\t\t\t\twmi->last_mgmt_tx_frame,\n\t\t\t\t\twmi->last_mgmt_tx_frame_len,\n\t\t\t\t\t!!ev->ack_status, GFP_ATOMIC);\n\t\tkfree(wmi->last_mgmt_tx_frame);\n\t\twmi->last_mgmt_tx_frame = NULL;\n\t\twmi->last_mgmt_tx_frame_len = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath6kl_wmi_rx_probe_req_event_rx(struct wmi *wmi, u8 *datap, int len,\n\t\t\t\t\t    struct ath6kl_vif *vif)\n{\n\tstruct wmi_p2p_rx_probe_req_event *ev;\n\tu32 freq;\n\tu16 dlen;\n\n\tif (len < sizeof(*ev))\n\t\treturn -EINVAL;\n\n\tev = (struct wmi_p2p_rx_probe_req_event *) datap;\n\tfreq = le32_to_cpu(ev->freq);\n\tdlen = le16_to_cpu(ev->len);\n\tif (datap + len < ev->data + dlen) {\n\t\tath6kl_err(\"invalid wmi_p2p_rx_probe_req_event: len=%d dlen=%u\\n\",\n\t\t\t   len, dlen);\n\t\treturn -EINVAL;\n\t}\n\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t   \"rx_probe_req: len=%u freq=%u probe_req_report=%d\\n\",\n\t\t   dlen, freq, vif->probe_req_report);\n\n\tif (vif->probe_req_report || vif->nw_type == AP_NETWORK)\n\t\tcfg80211_rx_mgmt(&vif->wdev, freq, 0, ev->data, dlen, 0);\n\n\treturn 0;\n}\n\nstatic int ath6kl_wmi_p2p_capabilities_event_rx(u8 *datap, int len)\n{\n\tstruct wmi_p2p_capabilities_event *ev;\n\tu16 dlen;\n\n\tif (len < sizeof(*ev))\n\t\treturn -EINVAL;\n\n\tev = (struct wmi_p2p_capabilities_event *) datap;\n\tdlen = le16_to_cpu(ev->len);\n\tath6kl_dbg(ATH6KL_DBG_WMI, \"p2p_capab: len=%u\\n\", dlen);\n\n\treturn 0;\n}\n\nstatic int ath6kl_wmi_rx_action_event_rx(struct wmi *wmi, u8 *datap, int len,\n\t\t\t\t\t struct ath6kl_vif *vif)\n{\n\tstruct wmi_rx_action_event *ev;\n\tu32 freq;\n\tu16 dlen;\n\n\tif (len < sizeof(*ev))\n\t\treturn -EINVAL;\n\n\tev = (struct wmi_rx_action_event *) datap;\n\tfreq = le32_to_cpu(ev->freq);\n\tdlen = le16_to_cpu(ev->len);\n\tif (datap + len < ev->data + dlen) {\n\t\tath6kl_err(\"invalid wmi_rx_action_event: len=%d dlen=%u\\n\",\n\t\t\t   len, dlen);\n\t\treturn -EINVAL;\n\t}\n\tath6kl_dbg(ATH6KL_DBG_WMI, \"rx_action: len=%u freq=%u\\n\", dlen, freq);\n\tcfg80211_rx_mgmt(&vif->wdev, freq, 0, ev->data, dlen, 0);\n\n\treturn 0;\n}\n\nstatic int ath6kl_wmi_p2p_info_event_rx(u8 *datap, int len)\n{\n\tstruct wmi_p2p_info_event *ev;\n\tu32 flags;\n\tu16 dlen;\n\n\tif (len < sizeof(*ev))\n\t\treturn -EINVAL;\n\n\tev = (struct wmi_p2p_info_event *) datap;\n\tflags = le32_to_cpu(ev->info_req_flags);\n\tdlen = le16_to_cpu(ev->len);\n\tath6kl_dbg(ATH6KL_DBG_WMI, \"p2p_info: flags=%x len=%d\\n\", flags, dlen);\n\n\tif (flags & P2P_FLAG_CAPABILITIES_REQ) {\n\t\tstruct wmi_p2p_capabilities *cap;\n\t\tif (dlen < sizeof(*cap))\n\t\t\treturn -EINVAL;\n\t\tcap = (struct wmi_p2p_capabilities *) ev->data;\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"p2p_info: GO Power Save = %d\\n\",\n\t\t\t   cap->go_power_save);\n\t}\n\n\tif (flags & P2P_FLAG_MACADDR_REQ) {\n\t\tstruct wmi_p2p_macaddr *mac;\n\t\tif (dlen < sizeof(*mac))\n\t\t\treturn -EINVAL;\n\t\tmac = (struct wmi_p2p_macaddr *) ev->data;\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"p2p_info: MAC Address = %pM\\n\",\n\t\t\t   mac->mac_addr);\n\t}\n\n\tif (flags & P2P_FLAG_HMODEL_REQ) {\n\t\tstruct wmi_p2p_hmodel *mod;\n\t\tif (dlen < sizeof(*mod))\n\t\t\treturn -EINVAL;\n\t\tmod = (struct wmi_p2p_hmodel *) ev->data;\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"p2p_info: P2P Model = %d (%s)\\n\",\n\t\t\t   mod->p2p_model,\n\t\t\t   mod->p2p_model ? \"host\" : \"firmware\");\n\t}\n\treturn 0;\n}\n\nstatic inline struct sk_buff *ath6kl_wmi_get_new_buf(u32 size)\n{\n\tstruct sk_buff *skb;\n\n\tskb = ath6kl_buf_alloc(size);\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_put(skb, size);\n\tif (size)\n\t\tmemset(skb->data, 0, size);\n\n\treturn skb;\n}\n\n \nstatic int ath6kl_wmi_simple_cmd(struct wmi *wmi, u8 if_idx,\n\t\t\t\t enum wmi_cmd_id cmd_id)\n{\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath6kl_wmi_get_new_buf(0);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, cmd_id, NO_SYNC_WMIFLAG);\n\n\treturn ret;\n}\n\nstatic int ath6kl_wmi_ready_event_rx(struct wmi *wmi, u8 *datap, int len)\n{\n\tstruct wmi_ready_event_2 *ev = (struct wmi_ready_event_2 *) datap;\n\n\tif (len < sizeof(struct wmi_ready_event_2))\n\t\treturn -EINVAL;\n\n\tath6kl_ready_event(wmi->parent_dev, ev->mac_addr,\n\t\t\t   le32_to_cpu(ev->sw_version),\n\t\t\t   le32_to_cpu(ev->abi_version), ev->phy_cap);\n\n\treturn 0;\n}\n\n \nint ath6kl_wmi_set_roam_lrssi_cmd(struct wmi *wmi, u8 lrssi)\n{\n\tstruct sk_buff *skb;\n\tstruct roam_ctrl_cmd *cmd;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct roam_ctrl_cmd *) skb->data;\n\n\tcmd->info.params.lrssi_scan_period = cpu_to_le16(DEF_LRSSI_SCAN_PERIOD);\n\tcmd->info.params.lrssi_scan_threshold = a_cpu_to_sle16(lrssi +\n\t\t\t\t\t\t       DEF_SCAN_FOR_ROAM_INTVL);\n\tcmd->info.params.lrssi_roam_threshold = a_cpu_to_sle16(lrssi);\n\tcmd->info.params.roam_rssi_floor = DEF_LRSSI_ROAM_FLOOR;\n\tcmd->roam_ctrl = WMI_SET_LRSSI_SCAN_PARAMS;\n\n\treturn ath6kl_wmi_cmd_send(wmi, 0, skb, WMI_SET_ROAM_CTRL_CMDID,\n\t\t\t    NO_SYNC_WMIFLAG);\n}\n\nint ath6kl_wmi_force_roam_cmd(struct wmi *wmi, const u8 *bssid)\n{\n\tstruct sk_buff *skb;\n\tstruct roam_ctrl_cmd *cmd;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct roam_ctrl_cmd *) skb->data;\n\n\tmemcpy(cmd->info.bssid, bssid, ETH_ALEN);\n\tcmd->roam_ctrl = WMI_FORCE_ROAM;\n\n\tath6kl_dbg(ATH6KL_DBG_WMI, \"force roam to %pM\\n\", bssid);\n\treturn ath6kl_wmi_cmd_send(wmi, 0, skb, WMI_SET_ROAM_CTRL_CMDID,\n\t\t\t\t   NO_SYNC_WMIFLAG);\n}\n\nint ath6kl_wmi_ap_set_beacon_intvl_cmd(struct wmi *wmi, u8 if_idx,\n\t\t\t\t       u32 beacon_intvl)\n{\n\tstruct sk_buff *skb;\n\tstruct set_beacon_int_cmd *cmd;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct set_beacon_int_cmd *) skb->data;\n\n\tcmd->beacon_intvl = cpu_to_le32(beacon_intvl);\n\treturn ath6kl_wmi_cmd_send(wmi, if_idx, skb,\n\t\t\t\t   WMI_SET_BEACON_INT_CMDID, NO_SYNC_WMIFLAG);\n}\n\nint ath6kl_wmi_ap_set_dtim_cmd(struct wmi *wmi, u8 if_idx, u32 dtim_period)\n{\n\tstruct sk_buff *skb;\n\tstruct set_dtim_cmd *cmd;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct set_dtim_cmd *) skb->data;\n\n\tcmd->dtim_period = cpu_to_le32(dtim_period);\n\treturn ath6kl_wmi_cmd_send(wmi, if_idx, skb,\n\t\t\t\t   WMI_AP_SET_DTIM_CMDID, NO_SYNC_WMIFLAG);\n}\n\nint ath6kl_wmi_set_roam_mode_cmd(struct wmi *wmi, enum wmi_roam_mode mode)\n{\n\tstruct sk_buff *skb;\n\tstruct roam_ctrl_cmd *cmd;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct roam_ctrl_cmd *) skb->data;\n\n\tcmd->info.roam_mode = mode;\n\tcmd->roam_ctrl = WMI_SET_ROAM_MODE;\n\n\tath6kl_dbg(ATH6KL_DBG_WMI, \"set roam mode %d\\n\", mode);\n\treturn ath6kl_wmi_cmd_send(wmi, 0, skb, WMI_SET_ROAM_CTRL_CMDID,\n\t\t\t\t   NO_SYNC_WMIFLAG);\n}\n\nstatic int ath6kl_wmi_connect_event_rx(struct wmi *wmi, u8 *datap, int len,\n\t\t\t\t       struct ath6kl_vif *vif)\n{\n\tstruct wmi_connect_event *ev;\n\tu8 *pie, *peie;\n\n\tif (len < sizeof(struct wmi_connect_event))\n\t\treturn -EINVAL;\n\n\tev = (struct wmi_connect_event *) datap;\n\n\tif (vif->nw_type == AP_NETWORK) {\n\t\t \n\t\tstruct net_device *dev = vif->ndev;\n\t\tif (memcmp(dev->dev_addr, ev->u.ap_bss.bssid, ETH_ALEN) == 0) {\n\t\t\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t\t\t   \"%s: freq %d bssid %pM (AP started)\\n\",\n\t\t\t\t   __func__, le16_to_cpu(ev->u.ap_bss.ch),\n\t\t\t\t   ev->u.ap_bss.bssid);\n\t\t\tath6kl_connect_ap_mode_bss(\n\t\t\t\tvif, le16_to_cpu(ev->u.ap_bss.ch));\n\t\t} else {\n\t\t\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t\t\t   \"%s: aid %u mac_addr %pM auth=%u keymgmt=%u cipher=%u apsd_info=%u (STA connected)\\n\",\n\t\t\t\t   __func__, ev->u.ap_sta.aid,\n\t\t\t\t   ev->u.ap_sta.mac_addr,\n\t\t\t\t   ev->u.ap_sta.auth,\n\t\t\t\t   ev->u.ap_sta.keymgmt,\n\t\t\t\t   le16_to_cpu(ev->u.ap_sta.cipher),\n\t\t\t\t   ev->u.ap_sta.apsd_info);\n\n\t\t\tath6kl_connect_ap_mode_sta(\n\t\t\t\tvif, ev->u.ap_sta.aid, ev->u.ap_sta.mac_addr,\n\t\t\t\tev->u.ap_sta.keymgmt,\n\t\t\t\tle16_to_cpu(ev->u.ap_sta.cipher),\n\t\t\t\tev->u.ap_sta.auth, ev->assoc_req_len,\n\t\t\t\tev->assoc_info + ev->beacon_ie_len,\n\t\t\t\tev->u.ap_sta.apsd_info);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t \n\n\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t   \"wmi event connect freq %d bssid %pM listen_intvl %d beacon_intvl %d type %d\\n\",\n\t\t   le16_to_cpu(ev->u.sta.ch), ev->u.sta.bssid,\n\t\t   le16_to_cpu(ev->u.sta.listen_intvl),\n\t\t   le16_to_cpu(ev->u.sta.beacon_intvl),\n\t\t   le32_to_cpu(ev->u.sta.nw_type));\n\n\t \n\tpie = ev->assoc_info + ev->beacon_ie_len +\n\t      ev->assoc_req_len + (sizeof(u16) * 3);  \n\n\t \n\tpeie = ev->assoc_info + ev->beacon_ie_len + ev->assoc_req_len +\n\t    ev->assoc_resp_len;\n\n\twhile (pie < peie) {\n\t\tswitch (*pie) {\n\t\tcase WLAN_EID_VENDOR_SPECIFIC:\n\t\t\tif (pie[1] > 3 && pie[2] == 0x00 && pie[3] == 0x50 &&\n\t\t\t    pie[4] == 0xf2 && pie[5] == WMM_OUI_TYPE) {\n\t\t\t\t \n\t\t\t\tif (pie[1] > 5 &&\n\t\t\t\t    pie[6] == WMM_PARAM_OUI_SUBTYPE)\n\t\t\t\t\twmi->is_wmm_enabled = true;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (wmi->is_wmm_enabled)\n\t\t\tbreak;\n\n\t\tpie += pie[1] + 2;\n\t}\n\n\tath6kl_connect_event(vif, le16_to_cpu(ev->u.sta.ch),\n\t\t\t     ev->u.sta.bssid,\n\t\t\t     le16_to_cpu(ev->u.sta.listen_intvl),\n\t\t\t     le16_to_cpu(ev->u.sta.beacon_intvl),\n\t\t\t     le32_to_cpu(ev->u.sta.nw_type),\n\t\t\t     ev->beacon_ie_len, ev->assoc_req_len,\n\t\t\t     ev->assoc_resp_len, ev->assoc_info);\n\n\treturn 0;\n}\n\nstatic struct country_code_to_enum_rd *\nath6kl_regd_find_country(u16 countryCode)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(allCountries); i++) {\n\t\tif (allCountries[i].countryCode == countryCode)\n\t\t\treturn &allCountries[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic struct reg_dmn_pair_mapping *\nath6kl_get_regpair(u16 regdmn)\n{\n\tint i;\n\n\tif (regdmn == NO_ENUMRD)\n\t\treturn NULL;\n\n\tfor (i = 0; i < ARRAY_SIZE(regDomainPairs); i++) {\n\t\tif (regDomainPairs[i].reg_domain == regdmn)\n\t\t\treturn &regDomainPairs[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic struct country_code_to_enum_rd *\nath6kl_regd_find_country_by_rd(u16 regdmn)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(allCountries); i++) {\n\t\tif (allCountries[i].regDmnEnum == regdmn)\n\t\t\treturn &allCountries[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic void ath6kl_wmi_regdomain_event(struct wmi *wmi, u8 *datap, int len)\n{\n\tstruct ath6kl_wmi_regdomain *ev;\n\tstruct country_code_to_enum_rd *country = NULL;\n\tstruct reg_dmn_pair_mapping *regpair = NULL;\n\tchar alpha2[2];\n\tu32 reg_code;\n\n\tev = (struct ath6kl_wmi_regdomain *) datap;\n\treg_code = le32_to_cpu(ev->reg_code);\n\n\tif ((reg_code >> ATH6KL_COUNTRY_RD_SHIFT) & COUNTRY_ERD_FLAG) {\n\t\tcountry = ath6kl_regd_find_country((u16) reg_code);\n\t} else if (!(((u16) reg_code & WORLD_SKU_MASK) == WORLD_SKU_PREFIX)) {\n\t\tregpair = ath6kl_get_regpair((u16) reg_code);\n\t\tcountry = ath6kl_regd_find_country_by_rd((u16) reg_code);\n\t\tif (regpair)\n\t\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"Regpair used: 0x%0x\\n\",\n\t\t\t\t   regpair->reg_domain);\n\t\telse\n\t\t\tath6kl_warn(\"Regpair not found reg_code 0x%0x\\n\",\n\t\t\t\t    reg_code);\n\t}\n\n\tif (country && wmi->parent_dev->wiphy_registered) {\n\t\talpha2[0] = country->isoName[0];\n\t\talpha2[1] = country->isoName[1];\n\n\t\tregulatory_hint(wmi->parent_dev->wiphy, alpha2);\n\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"Country alpha2 being used: %c%c\\n\",\n\t\t\t   alpha2[0], alpha2[1]);\n\t}\n}\n\nstatic int ath6kl_wmi_disconnect_event_rx(struct wmi *wmi, u8 *datap, int len,\n\t\t\t\t\t  struct ath6kl_vif *vif)\n{\n\tstruct wmi_disconnect_event *ev;\n\twmi->traffic_class = 100;\n\n\tif (len < sizeof(struct wmi_disconnect_event))\n\t\treturn -EINVAL;\n\n\tev = (struct wmi_disconnect_event *) datap;\n\n\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t   \"wmi event disconnect proto_reason %d bssid %pM wmi_reason %d assoc_resp_len %d\\n\",\n\t\t   le16_to_cpu(ev->proto_reason_status), ev->bssid,\n\t\t   ev->disconn_reason, ev->assoc_resp_len);\n\n\twmi->is_wmm_enabled = false;\n\n\tath6kl_disconnect_event(vif, ev->disconn_reason,\n\t\t\t\tev->bssid, ev->assoc_resp_len, ev->assoc_info,\n\t\t\t\tle16_to_cpu(ev->proto_reason_status));\n\n\treturn 0;\n}\n\nstatic int ath6kl_wmi_peer_node_event_rx(struct wmi *wmi, u8 *datap, int len)\n{\n\tstruct wmi_peer_node_event *ev;\n\n\tif (len < sizeof(struct wmi_peer_node_event))\n\t\treturn -EINVAL;\n\n\tev = (struct wmi_peer_node_event *) datap;\n\n\tif (ev->event_code == PEER_NODE_JOIN_EVENT)\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"joined node with mac addr: %pM\\n\",\n\t\t\t   ev->peer_mac_addr);\n\telse if (ev->event_code == PEER_NODE_LEAVE_EVENT)\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"left node with mac addr: %pM\\n\",\n\t\t\t   ev->peer_mac_addr);\n\n\treturn 0;\n}\n\nstatic int ath6kl_wmi_tkip_micerr_event_rx(struct wmi *wmi, u8 *datap, int len,\n\t\t\t\t\t   struct ath6kl_vif *vif)\n{\n\tstruct wmi_tkip_micerr_event *ev;\n\n\tif (len < sizeof(struct wmi_tkip_micerr_event))\n\t\treturn -EINVAL;\n\n\tev = (struct wmi_tkip_micerr_event *) datap;\n\n\tath6kl_tkip_micerr_event(vif, ev->key_id, ev->is_mcast);\n\n\treturn 0;\n}\n\nvoid ath6kl_wmi_sscan_timer(struct timer_list *t)\n{\n\tstruct ath6kl_vif *vif = from_timer(vif, t, sched_scan_timer);\n\n\tcfg80211_sched_scan_results(vif->ar->wiphy, 0);\n}\n\nstatic int ath6kl_wmi_bssinfo_event_rx(struct wmi *wmi, u8 *datap, int len,\n\t\t\t\t       struct ath6kl_vif *vif)\n{\n\tstruct wmi_bss_info_hdr2 *bih;\n\tu8 *buf;\n\tstruct ieee80211_channel *channel;\n\tstruct ath6kl *ar = wmi->parent_dev;\n\tstruct cfg80211_bss *bss;\n\n\tif (len <= sizeof(struct wmi_bss_info_hdr2))\n\t\treturn -EINVAL;\n\n\tbih = (struct wmi_bss_info_hdr2 *) datap;\n\tbuf = datap + sizeof(struct wmi_bss_info_hdr2);\n\tlen -= sizeof(struct wmi_bss_info_hdr2);\n\n\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t   \"bss info evt - ch %u, snr %d, rssi %d, bssid \\\"%pM\\\" \"\n\t\t   \"frame_type=%d\\n\",\n\t\t   bih->ch, bih->snr, bih->snr - 95, bih->bssid,\n\t\t   bih->frame_type);\n\n\tif (bih->frame_type != BEACON_FTYPE &&\n\t    bih->frame_type != PROBERESP_FTYPE)\n\t\treturn 0;  \n\n\tif (bih->frame_type == BEACON_FTYPE &&\n\t    test_bit(CLEAR_BSSFILTER_ON_BEACON, &vif->flags)) {\n\t\tclear_bit(CLEAR_BSSFILTER_ON_BEACON, &vif->flags);\n\t\tath6kl_wmi_bssfilter_cmd(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t\t NONE_BSS_FILTER, 0);\n\t}\n\n\tchannel = ieee80211_get_channel(ar->wiphy, le16_to_cpu(bih->ch));\n\tif (channel == NULL)\n\t\treturn -EINVAL;\n\n\tif (len < 8 + 2 + 2)\n\t\treturn -EINVAL;\n\n\tif (bih->frame_type == BEACON_FTYPE &&\n\t    test_bit(CONNECTED, &vif->flags) &&\n\t    memcmp(bih->bssid, vif->bssid, ETH_ALEN) == 0) {\n\t\tconst u8 *tim;\n\t\ttim = cfg80211_find_ie(WLAN_EID_TIM, buf + 8 + 2 + 2,\n\t\t\t\t       len - 8 - 2 - 2);\n\t\tif (tim && tim[1] >= 2) {\n\t\t\tvif->assoc_bss_dtim_period = tim[3];\n\t\t\tset_bit(DTIM_PERIOD_AVAIL, &vif->flags);\n\t\t}\n\t}\n\n\tbss = cfg80211_inform_bss(ar->wiphy, channel,\n\t\t\t\t  bih->frame_type == BEACON_FTYPE ?\n\t\t\t\t\tCFG80211_BSS_FTYPE_BEACON :\n\t\t\t\t\tCFG80211_BSS_FTYPE_PRESP,\n\t\t\t\t  bih->bssid, get_unaligned_le64((__le64 *)buf),\n\t\t\t\t  get_unaligned_le16(((__le16 *)buf) + 5),\n\t\t\t\t  get_unaligned_le16(((__le16 *)buf) + 4),\n\t\t\t\t  buf + 8 + 2 + 2, len - 8 - 2 - 2,\n\t\t\t\t  (bih->snr - 95) * 100, GFP_ATOMIC);\n\tif (bss == NULL)\n\t\treturn -ENOMEM;\n\tcfg80211_put_bss(ar->wiphy, bss);\n\n\t \n\tif (test_bit(SCHED_SCANNING, &vif->flags) &&\n\t    !timer_pending(&vif->sched_scan_timer)) {\n\t\tmod_timer(&vif->sched_scan_timer, jiffies +\n\t\t\t  msecs_to_jiffies(ATH6KL_SCHED_SCAN_RESULT_DELAY));\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ath6kl_wmi_pstream_timeout_event_rx(struct wmi *wmi, u8 *datap,\n\t\t\t\t\t       int len)\n{\n\tstruct wmi_pstream_timeout_event *ev;\n\n\tif (len < sizeof(struct wmi_pstream_timeout_event))\n\t\treturn -EINVAL;\n\n\tev = (struct wmi_pstream_timeout_event *) datap;\n\tif (ev->traffic_class >= WMM_NUM_AC) {\n\t\tath6kl_err(\"invalid traffic class: %d\\n\", ev->traffic_class);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tspin_lock_bh(&wmi->lock);\n\twmi->stream_exist_for_ac[ev->traffic_class] = 0;\n\twmi->fat_pipe_exist &= ~(1 << ev->traffic_class);\n\tspin_unlock_bh(&wmi->lock);\n\n\t \n\tath6kl_indicate_tx_activity(wmi->parent_dev, ev->traffic_class, false);\n\n\treturn 0;\n}\n\nstatic int ath6kl_wmi_bitrate_reply_rx(struct wmi *wmi, u8 *datap, int len)\n{\n\tstruct wmi_bit_rate_reply *reply;\n\tu32 index;\n\n\tif (len < sizeof(struct wmi_bit_rate_reply))\n\t\treturn -EINVAL;\n\n\treply = (struct wmi_bit_rate_reply *) datap;\n\n\tath6kl_dbg(ATH6KL_DBG_WMI, \"rateindex %d\\n\", reply->rate_index);\n\n\tif (reply->rate_index != (s8) RATE_AUTO) {\n\t\tindex = reply->rate_index & 0x7f;\n\t\tif (WARN_ON_ONCE(index > (RATE_MCS_7_40 + 1)))\n\t\t\treturn -EINVAL;\n\t}\n\n\tath6kl_wakeup_event(wmi->parent_dev);\n\n\treturn 0;\n}\n\nstatic int ath6kl_wmi_test_rx(struct wmi *wmi, u8 *datap, int len)\n{\n\tath6kl_tm_rx_event(wmi->parent_dev, datap, len);\n\n\treturn 0;\n}\n\nstatic int ath6kl_wmi_ratemask_reply_rx(struct wmi *wmi, u8 *datap, int len)\n{\n\tif (len < sizeof(struct wmi_fix_rates_reply))\n\t\treturn -EINVAL;\n\n\tath6kl_wakeup_event(wmi->parent_dev);\n\n\treturn 0;\n}\n\nstatic int ath6kl_wmi_ch_list_reply_rx(struct wmi *wmi, u8 *datap, int len)\n{\n\tif (len < sizeof(struct wmi_channel_list_reply))\n\t\treturn -EINVAL;\n\n\tath6kl_wakeup_event(wmi->parent_dev);\n\n\treturn 0;\n}\n\nstatic int ath6kl_wmi_tx_pwr_reply_rx(struct wmi *wmi, u8 *datap, int len)\n{\n\tstruct wmi_tx_pwr_reply *reply;\n\n\tif (len < sizeof(struct wmi_tx_pwr_reply))\n\t\treturn -EINVAL;\n\n\treply = (struct wmi_tx_pwr_reply *) datap;\n\tath6kl_txpwr_rx_evt(wmi->parent_dev, reply->dbM);\n\n\treturn 0;\n}\n\nstatic int ath6kl_wmi_keepalive_reply_rx(struct wmi *wmi, u8 *datap, int len)\n{\n\tif (len < sizeof(struct wmi_get_keepalive_cmd))\n\t\treturn -EINVAL;\n\n\tath6kl_wakeup_event(wmi->parent_dev);\n\n\treturn 0;\n}\n\nstatic int ath6kl_wmi_scan_complete_rx(struct wmi *wmi, u8 *datap, int len,\n\t\t\t\t       struct ath6kl_vif *vif)\n{\n\tstruct wmi_scan_complete_event *ev;\n\n\tev = (struct wmi_scan_complete_event *) datap;\n\n\tath6kl_scan_complete_evt(vif, a_sle32_to_cpu(ev->status));\n\twmi->is_probe_ssid = false;\n\n\treturn 0;\n}\n\nstatic int ath6kl_wmi_neighbor_report_event_rx(struct wmi *wmi, u8 *datap,\n\t\t\t\t\t       int len, struct ath6kl_vif *vif)\n{\n\tstruct wmi_neighbor_report_event *ev;\n\tu8 i;\n\n\tif (len < sizeof(*ev))\n\t\treturn -EINVAL;\n\tev = (struct wmi_neighbor_report_event *) datap;\n\tif (struct_size(ev, neighbor, ev->num_neighbors) > len) {\n\t\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t\t   \"truncated neighbor event (num=%d len=%d)\\n\",\n\t\t\t   ev->num_neighbors, len);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < ev->num_neighbors; i++) {\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"neighbor %d/%d - %pM 0x%x\\n\",\n\t\t\t   i + 1, ev->num_neighbors, ev->neighbor[i].bssid,\n\t\t\t   ev->neighbor[i].bss_flags);\n\t\tcfg80211_pmksa_candidate_notify(vif->ndev, i,\n\t\t\t\t\t\tev->neighbor[i].bssid,\n\t\t\t\t\t\t!!(ev->neighbor[i].bss_flags &\n\t\t\t\t\t\t   WMI_PREAUTH_CAPABLE_BSS),\n\t\t\t\t\t\tGFP_ATOMIC);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ath6kl_wmi_error_event_rx(struct wmi *wmi, u8 *datap, int len)\n{\n\tconst char *type = \"unknown error\";\n\tstruct wmi_cmd_error_event *ev;\n\tev = (struct wmi_cmd_error_event *) datap;\n\n\tswitch (ev->err_code) {\n\tcase INVALID_PARAM:\n\t\ttype = \"invalid parameter\";\n\t\tbreak;\n\tcase ILLEGAL_STATE:\n\t\ttype = \"invalid state\";\n\t\tbreak;\n\tcase INTERNAL_ERROR:\n\t\ttype = \"internal error\";\n\t\tbreak;\n\t}\n\n\tath6kl_dbg(ATH6KL_DBG_WMI, \"programming error, cmd=%d %s\\n\",\n\t\t   ev->cmd_id, type);\n\n\treturn 0;\n}\n\nstatic int ath6kl_wmi_stats_event_rx(struct wmi *wmi, u8 *datap, int len,\n\t\t\t\t     struct ath6kl_vif *vif)\n{\n\tath6kl_tgt_stats_event(vif, datap, len);\n\n\treturn 0;\n}\n\nstatic u8 ath6kl_wmi_get_upper_threshold(s16 rssi,\n\t\t\t\t\t struct sq_threshold_params *sq_thresh,\n\t\t\t\t\t u32 size)\n{\n\tu32 index;\n\tu8 threshold = (u8) sq_thresh->upper_threshold[size - 1];\n\n\t \n\tfor (index = 0; index < size; index++) {\n\t\tif (rssi < sq_thresh->upper_threshold[index]) {\n\t\t\tthreshold = (u8) sq_thresh->upper_threshold[index];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn threshold;\n}\n\nstatic u8 ath6kl_wmi_get_lower_threshold(s16 rssi,\n\t\t\t\t\t struct sq_threshold_params *sq_thresh,\n\t\t\t\t\t u32 size)\n{\n\tu32 index;\n\tu8 threshold = (u8) sq_thresh->lower_threshold[size - 1];\n\n\t \n\tfor (index = 0; index < size; index++) {\n\t\tif (rssi > sq_thresh->lower_threshold[index]) {\n\t\t\tthreshold = (u8) sq_thresh->lower_threshold[index];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn threshold;\n}\n\nstatic int ath6kl_wmi_send_rssi_threshold_params(struct wmi *wmi,\n\t\t\tstruct wmi_rssi_threshold_params_cmd *rssi_cmd)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_rssi_threshold_params_cmd *cmd;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_rssi_threshold_params_cmd *) skb->data;\n\tmemcpy(cmd, rssi_cmd, sizeof(struct wmi_rssi_threshold_params_cmd));\n\n\treturn ath6kl_wmi_cmd_send(wmi, 0, skb, WMI_RSSI_THRESHOLD_PARAMS_CMDID,\n\t\t\t\t   NO_SYNC_WMIFLAG);\n}\n\nstatic int ath6kl_wmi_rssi_threshold_event_rx(struct wmi *wmi, u8 *datap,\n\t\t\t\t\t      int len)\n{\n\tstruct wmi_rssi_threshold_event *reply;\n\tstruct wmi_rssi_threshold_params_cmd cmd;\n\tstruct sq_threshold_params *sq_thresh;\n\tenum wmi_rssi_threshold_val new_threshold;\n\tu8 upper_rssi_threshold, lower_rssi_threshold;\n\ts16 rssi;\n\tint ret;\n\n\tif (len < sizeof(struct wmi_rssi_threshold_event))\n\t\treturn -EINVAL;\n\n\treply = (struct wmi_rssi_threshold_event *) datap;\n\tnew_threshold = (enum wmi_rssi_threshold_val) reply->range;\n\trssi = a_sle16_to_cpu(reply->rssi);\n\n\tsq_thresh = &wmi->sq_threshld[SIGNAL_QUALITY_METRICS_RSSI];\n\n\t \n\tif (new_threshold) {\n\t\t \n\t\tif (rssi < sq_thresh->upper_threshold[0]) {\n\t\t\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t\t\t   \"spurious upper rssi threshold event: %d\\n\",\n\t\t\t\t   rssi);\n\t\t} else if ((rssi < sq_thresh->upper_threshold[1]) &&\n\t\t\t   (rssi >= sq_thresh->upper_threshold[0])) {\n\t\t\tnew_threshold = WMI_RSSI_THRESHOLD1_ABOVE;\n\t\t} else if ((rssi < sq_thresh->upper_threshold[2]) &&\n\t\t\t   (rssi >= sq_thresh->upper_threshold[1])) {\n\t\t\tnew_threshold = WMI_RSSI_THRESHOLD2_ABOVE;\n\t\t} else if ((rssi < sq_thresh->upper_threshold[3]) &&\n\t\t\t   (rssi >= sq_thresh->upper_threshold[2])) {\n\t\t\tnew_threshold = WMI_RSSI_THRESHOLD3_ABOVE;\n\t\t} else if ((rssi < sq_thresh->upper_threshold[4]) &&\n\t\t\t   (rssi >= sq_thresh->upper_threshold[3])) {\n\t\t\tnew_threshold = WMI_RSSI_THRESHOLD4_ABOVE;\n\t\t} else if ((rssi < sq_thresh->upper_threshold[5]) &&\n\t\t\t   (rssi >= sq_thresh->upper_threshold[4])) {\n\t\t\tnew_threshold = WMI_RSSI_THRESHOLD5_ABOVE;\n\t\t} else if (rssi >= sq_thresh->upper_threshold[5]) {\n\t\t\tnew_threshold = WMI_RSSI_THRESHOLD6_ABOVE;\n\t\t}\n\t} else {\n\t\t \n\t\tif (rssi > sq_thresh->lower_threshold[0]) {\n\t\t\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t\t\t   \"spurious lower rssi threshold event: %d %d\\n\",\n\t\t\t\trssi, sq_thresh->lower_threshold[0]);\n\t\t} else if ((rssi > sq_thresh->lower_threshold[1]) &&\n\t\t\t   (rssi <= sq_thresh->lower_threshold[0])) {\n\t\t\tnew_threshold = WMI_RSSI_THRESHOLD6_BELOW;\n\t\t} else if ((rssi > sq_thresh->lower_threshold[2]) &&\n\t\t\t   (rssi <= sq_thresh->lower_threshold[1])) {\n\t\t\tnew_threshold = WMI_RSSI_THRESHOLD5_BELOW;\n\t\t} else if ((rssi > sq_thresh->lower_threshold[3]) &&\n\t\t\t   (rssi <= sq_thresh->lower_threshold[2])) {\n\t\t\tnew_threshold = WMI_RSSI_THRESHOLD4_BELOW;\n\t\t} else if ((rssi > sq_thresh->lower_threshold[4]) &&\n\t\t\t   (rssi <= sq_thresh->lower_threshold[3])) {\n\t\t\tnew_threshold = WMI_RSSI_THRESHOLD3_BELOW;\n\t\t} else if ((rssi > sq_thresh->lower_threshold[5]) &&\n\t\t\t   (rssi <= sq_thresh->lower_threshold[4])) {\n\t\t\tnew_threshold = WMI_RSSI_THRESHOLD2_BELOW;\n\t\t} else if (rssi <= sq_thresh->lower_threshold[5]) {\n\t\t\tnew_threshold = WMI_RSSI_THRESHOLD1_BELOW;\n\t\t}\n\t}\n\n\t \n\tlower_rssi_threshold = ath6kl_wmi_get_lower_threshold(rssi, sq_thresh,\n\t\t\t\t       sq_thresh->lower_threshold_valid_count);\n\tupper_rssi_threshold = ath6kl_wmi_get_upper_threshold(rssi, sq_thresh,\n\t\t\t\t       sq_thresh->upper_threshold_valid_count);\n\n\t \n\tcmd.thresh_above1_val = a_cpu_to_sle16(upper_rssi_threshold);\n\tcmd.thresh_below1_val = a_cpu_to_sle16(lower_rssi_threshold);\n\tcmd.weight = sq_thresh->weight;\n\tcmd.poll_time = cpu_to_le32(sq_thresh->polling_interval);\n\n\tret = ath6kl_wmi_send_rssi_threshold_params(wmi, &cmd);\n\tif (ret) {\n\t\tath6kl_err(\"unable to configure rssi thresholds\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath6kl_wmi_cac_event_rx(struct wmi *wmi, u8 *datap, int len,\n\t\t\t\t   struct ath6kl_vif *vif)\n{\n\tstruct wmi_cac_event *reply;\n\tstruct ieee80211_tspec_ie *ts;\n\tu16 active_tsids, tsinfo;\n\tu8 tsid, index;\n\tu8 ts_id;\n\n\tif (len < sizeof(struct wmi_cac_event))\n\t\treturn -EINVAL;\n\n\treply = (struct wmi_cac_event *) datap;\n\tif (reply->ac >= WMM_NUM_AC) {\n\t\tath6kl_err(\"invalid AC: %d\\n\", reply->ac);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((reply->cac_indication == CAC_INDICATION_ADMISSION_RESP) &&\n\t    (reply->status_code != IEEE80211_TSPEC_STATUS_ADMISS_ACCEPTED)) {\n\t\tts = (struct ieee80211_tspec_ie *) &(reply->tspec_suggestion);\n\t\ttsinfo = le16_to_cpu(ts->tsinfo);\n\t\ttsid = (tsinfo >> IEEE80211_WMM_IE_TSPEC_TID_SHIFT) &\n\t\t\tIEEE80211_WMM_IE_TSPEC_TID_MASK;\n\n\t\tath6kl_wmi_delete_pstream_cmd(wmi, vif->fw_vif_idx,\n\t\t\t\t\t      reply->ac, tsid);\n\t} else if (reply->cac_indication == CAC_INDICATION_NO_RESP) {\n\t\t \n\t\tspin_lock_bh(&wmi->lock);\n\t\tactive_tsids = wmi->stream_exist_for_ac[reply->ac];\n\t\tspin_unlock_bh(&wmi->lock);\n\n\t\tfor (index = 0; index < sizeof(active_tsids) * 8; index++) {\n\t\t\tif ((active_tsids >> index) & 1)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (index < (sizeof(active_tsids) * 8))\n\t\t\tath6kl_wmi_delete_pstream_cmd(wmi, vif->fw_vif_idx,\n\t\t\t\t\t\t      reply->ac, index);\n\t}\n\n\t \n\telse if (reply->cac_indication == CAC_INDICATION_DELETE) {\n\t\tts = (struct ieee80211_tspec_ie *) &(reply->tspec_suggestion);\n\t\ttsinfo = le16_to_cpu(ts->tsinfo);\n\t\tts_id = ((tsinfo >> IEEE80211_WMM_IE_TSPEC_TID_SHIFT) &\n\t\t\t IEEE80211_WMM_IE_TSPEC_TID_MASK);\n\n\t\tspin_lock_bh(&wmi->lock);\n\t\twmi->stream_exist_for_ac[reply->ac] &= ~(1 << ts_id);\n\t\tactive_tsids = wmi->stream_exist_for_ac[reply->ac];\n\t\tspin_unlock_bh(&wmi->lock);\n\n\t\t \n\t\tif (!active_tsids) {\n\t\t\tath6kl_indicate_tx_activity(wmi->parent_dev, reply->ac,\n\t\t\t\t\t\t    false);\n\t\t\twmi->fat_pipe_exist &= ~(1 << reply->ac);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ath6kl_wmi_txe_notify_event_rx(struct wmi *wmi, u8 *datap, int len,\n\t\t\t\t\t  struct ath6kl_vif *vif)\n{\n\tstruct wmi_txe_notify_event *ev;\n\tu32 rate, pkts;\n\n\tif (len < sizeof(*ev))\n\t\treturn -EINVAL;\n\n\tif (vif->nw_type != INFRA_NETWORK ||\n\t    !test_bit(ATH6KL_FW_CAPABILITY_TX_ERR_NOTIFY,\n\t\t      vif->ar->fw_capabilities))\n\t\treturn -EOPNOTSUPP;\n\n\tif (vif->sme_state != SME_CONNECTED)\n\t\treturn -ENOTCONN;\n\n\tev = (struct wmi_txe_notify_event *) datap;\n\trate = le32_to_cpu(ev->rate);\n\tpkts = le32_to_cpu(ev->pkts);\n\n\tath6kl_dbg(ATH6KL_DBG_WMI, \"TXE notify event: peer %pM rate %d%% pkts %d intvl %ds\\n\",\n\t\t   vif->bssid, rate, pkts, vif->txe_intvl);\n\n\tcfg80211_cqm_txe_notify(vif->ndev, vif->bssid, pkts,\n\t\t\t\trate, vif->txe_intvl, GFP_KERNEL);\n\n\treturn 0;\n}\n\nint ath6kl_wmi_set_txe_notify(struct wmi *wmi, u8 idx,\n\t\t\t      u32 rate, u32 pkts, u32 intvl)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_txe_notify_cmd *cmd;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_txe_notify_cmd *) skb->data;\n\tcmd->rate = cpu_to_le32(rate);\n\tcmd->pkts = cpu_to_le32(pkts);\n\tcmd->intvl = cpu_to_le32(intvl);\n\n\treturn ath6kl_wmi_cmd_send(wmi, idx, skb, WMI_SET_TXE_NOTIFY_CMDID,\n\t\t\t\t   NO_SYNC_WMIFLAG);\n}\n\nint ath6kl_wmi_set_rssi_filter_cmd(struct wmi *wmi, u8 if_idx, s8 rssi)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_set_rssi_filter_cmd *cmd;\n\tint ret;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_set_rssi_filter_cmd *) skb->data;\n\tcmd->rssi = rssi;\n\n\tret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_SET_RSSI_FILTER_CMDID,\n\t\t\t\t  NO_SYNC_WMIFLAG);\n\treturn ret;\n}\n\nstatic int ath6kl_wmi_send_snr_threshold_params(struct wmi *wmi,\n\t\t\tstruct wmi_snr_threshold_params_cmd *snr_cmd)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_snr_threshold_params_cmd *cmd;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_snr_threshold_params_cmd *) skb->data;\n\tmemcpy(cmd, snr_cmd, sizeof(struct wmi_snr_threshold_params_cmd));\n\n\treturn ath6kl_wmi_cmd_send(wmi, 0, skb, WMI_SNR_THRESHOLD_PARAMS_CMDID,\n\t\t\t\t   NO_SYNC_WMIFLAG);\n}\n\nstatic int ath6kl_wmi_snr_threshold_event_rx(struct wmi *wmi, u8 *datap,\n\t\t\t\t\t     int len)\n{\n\tstruct wmi_snr_threshold_event *reply;\n\tstruct sq_threshold_params *sq_thresh;\n\tstruct wmi_snr_threshold_params_cmd cmd;\n\tenum wmi_snr_threshold_val new_threshold;\n\tu8 upper_snr_threshold, lower_snr_threshold;\n\ts16 snr;\n\tint ret;\n\n\tif (len < sizeof(struct wmi_snr_threshold_event))\n\t\treturn -EINVAL;\n\n\treply = (struct wmi_snr_threshold_event *) datap;\n\n\tnew_threshold = (enum wmi_snr_threshold_val) reply->range;\n\tsnr = reply->snr;\n\n\tsq_thresh = &wmi->sq_threshld[SIGNAL_QUALITY_METRICS_SNR];\n\n\t \n\tif (new_threshold) {\n\t\t \n\t\tif (snr < sq_thresh->upper_threshold[0]) {\n\t\t\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t\t\t   \"spurious upper snr threshold event: %d\\n\",\n\t\t\t\t   snr);\n\t\t} else if ((snr < sq_thresh->upper_threshold[1]) &&\n\t\t\t   (snr >= sq_thresh->upper_threshold[0])) {\n\t\t\tnew_threshold = WMI_SNR_THRESHOLD1_ABOVE;\n\t\t} else if ((snr < sq_thresh->upper_threshold[2]) &&\n\t\t\t   (snr >= sq_thresh->upper_threshold[1])) {\n\t\t\tnew_threshold = WMI_SNR_THRESHOLD2_ABOVE;\n\t\t} else if ((snr < sq_thresh->upper_threshold[3]) &&\n\t\t\t   (snr >= sq_thresh->upper_threshold[2])) {\n\t\t\tnew_threshold = WMI_SNR_THRESHOLD3_ABOVE;\n\t\t} else if (snr >= sq_thresh->upper_threshold[3]) {\n\t\t\tnew_threshold = WMI_SNR_THRESHOLD4_ABOVE;\n\t\t}\n\t} else {\n\t\t \n\t\tif (snr > sq_thresh->lower_threshold[0]) {\n\t\t\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t\t\t   \"spurious lower snr threshold event: %d\\n\",\n\t\t\t\t   sq_thresh->lower_threshold[0]);\n\t\t} else if ((snr > sq_thresh->lower_threshold[1]) &&\n\t\t\t   (snr <= sq_thresh->lower_threshold[0])) {\n\t\t\tnew_threshold = WMI_SNR_THRESHOLD4_BELOW;\n\t\t} else if ((snr > sq_thresh->lower_threshold[2]) &&\n\t\t\t   (snr <= sq_thresh->lower_threshold[1])) {\n\t\t\tnew_threshold = WMI_SNR_THRESHOLD3_BELOW;\n\t\t} else if ((snr > sq_thresh->lower_threshold[3]) &&\n\t\t\t   (snr <= sq_thresh->lower_threshold[2])) {\n\t\t\tnew_threshold = WMI_SNR_THRESHOLD2_BELOW;\n\t\t} else if (snr <= sq_thresh->lower_threshold[3]) {\n\t\t\tnew_threshold = WMI_SNR_THRESHOLD1_BELOW;\n\t\t}\n\t}\n\n\t \n\tlower_snr_threshold = ath6kl_wmi_get_lower_threshold(snr, sq_thresh,\n\t\t\t\t       sq_thresh->lower_threshold_valid_count);\n\tupper_snr_threshold = ath6kl_wmi_get_upper_threshold(snr, sq_thresh,\n\t\t\t\t       sq_thresh->upper_threshold_valid_count);\n\n\t \n\tcmd.thresh_above1_val = upper_snr_threshold;\n\tcmd.thresh_below1_val = lower_snr_threshold;\n\tcmd.weight = sq_thresh->weight;\n\tcmd.poll_time = cpu_to_le32(sq_thresh->polling_interval);\n\n\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t   \"snr: %d, threshold: %d, lower: %d, upper: %d\\n\",\n\t\t   snr, new_threshold,\n\t\t   lower_snr_threshold, upper_snr_threshold);\n\n\tret = ath6kl_wmi_send_snr_threshold_params(wmi, &cmd);\n\tif (ret) {\n\t\tath6kl_err(\"unable to configure snr threshold\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath6kl_wmi_aplist_event_rx(struct wmi *wmi, u8 *datap, int len)\n{\n\tstruct wmi_aplist_event *ev = (struct wmi_aplist_event *) datap;\n\tstruct wmi_ap_info_v1 *ap_info_v1;\n\tu8 index;\n\n\tif (len < sizeof(struct wmi_aplist_event) ||\n\t    ev->ap_list_ver != APLIST_VER1)\n\t\treturn -EINVAL;\n\n\tap_info_v1 = (struct wmi_ap_info_v1 *) ev->ap_list;\n\n\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t   \"number of APs in aplist event: %d\\n\", ev->num_ap);\n\n\tif (len < struct_size(ev, ap_list, ev->num_ap))\n\t\treturn -EINVAL;\n\n\t \n\tfor (index = 0; index < ev->num_ap; index++) {\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"AP#%d BSSID %pM Channel %d\\n\",\n\t\t\t   index, ap_info_v1->bssid, ap_info_v1->channel);\n\t\tap_info_v1++;\n\t}\n\n\treturn 0;\n}\n\nint ath6kl_wmi_cmd_send(struct wmi *wmi, u8 if_idx, struct sk_buff *skb,\n\t\t\tenum wmi_cmd_id cmd_id, enum wmi_sync_flag sync_flag)\n{\n\tstruct wmi_cmd_hdr *cmd_hdr;\n\tenum htc_endpoint_id ep_id = wmi->ep_id;\n\tint ret;\n\tu16 info1;\n\n\tif (WARN_ON(skb == NULL ||\n\t\t    (if_idx > (wmi->parent_dev->vif_max - 1)))) {\n\t\tdev_kfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\tath6kl_dbg(ATH6KL_DBG_WMI, \"wmi tx id %d len %d flag %d\\n\",\n\t\t   cmd_id, skb->len, sync_flag);\n\tath6kl_dbg_dump(ATH6KL_DBG_WMI_DUMP, NULL, \"wmi tx \",\n\t\t\tskb->data, skb->len);\n\n\tif (sync_flag >= END_WMIFLAG) {\n\t\tdev_kfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((sync_flag == SYNC_BEFORE_WMIFLAG) ||\n\t    (sync_flag == SYNC_BOTH_WMIFLAG)) {\n\t\t \n\t\tath6kl_wmi_sync_point(wmi, if_idx);\n\t}\n\n\tskb_push(skb, sizeof(struct wmi_cmd_hdr));\n\n\tcmd_hdr = (struct wmi_cmd_hdr *) skb->data;\n\tcmd_hdr->cmd_id = cpu_to_le16(cmd_id);\n\tinfo1 = if_idx & WMI_CMD_HDR_IF_ID_MASK;\n\tcmd_hdr->info1 = cpu_to_le16(info1);\n\n\t \n\tif (cmd_id == WMI_OPT_TX_FRAME_CMDID) {\n\t\tret = ath6kl_wmi_data_hdr_add(wmi, skb, OPT_MSGTYPE, false,\n\t\t\t\tWMI_DATA_HDR_DATA_TYPE_802_3, 0, NULL, if_idx);\n\t\tif (ret) {\n\t\t\tdev_kfree_skb(skb);\n\t\t\treturn ret;\n\t\t}\n\t\tep_id = ath6kl_ac2_endpoint_id(wmi->parent_dev, WMM_AC_BE);\n\t}\n\n\tath6kl_control_tx(wmi->parent_dev, skb, ep_id);\n\n\tif ((sync_flag == SYNC_AFTER_WMIFLAG) ||\n\t    (sync_flag == SYNC_BOTH_WMIFLAG)) {\n\t\t \n\t\tath6kl_wmi_sync_point(wmi, if_idx);\n\t}\n\n\treturn 0;\n}\n\nint ath6kl_wmi_connect_cmd(struct wmi *wmi, u8 if_idx,\n\t\t\t   enum network_type nw_type,\n\t\t\t   enum dot11_auth_mode dot11_auth_mode,\n\t\t\t   enum auth_mode auth_mode,\n\t\t\t   enum ath6kl_crypto_type pairwise_crypto,\n\t\t\t   u8 pairwise_crypto_len,\n\t\t\t   enum ath6kl_crypto_type group_crypto,\n\t\t\t   u8 group_crypto_len, int ssid_len, u8 *ssid,\n\t\t\t   u8 *bssid, u16 channel, u32 ctrl_flags,\n\t\t\t   u8 nw_subtype)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_connect_cmd *cc;\n\tint ret;\n\n\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t   \"wmi connect bssid %pM freq %d flags 0x%x ssid_len %d \"\n\t\t   \"type %d dot11_auth %d auth %d pairwise %d group %d\\n\",\n\t\t   bssid, channel, ctrl_flags, ssid_len, nw_type,\n\t\t   dot11_auth_mode, auth_mode, pairwise_crypto, group_crypto);\n\tath6kl_dbg_dump(ATH6KL_DBG_WMI, NULL, \"ssid \", ssid, ssid_len);\n\n\twmi->traffic_class = 100;\n\n\tif ((pairwise_crypto == NONE_CRYPT) && (group_crypto != NONE_CRYPT))\n\t\treturn -EINVAL;\n\n\tif ((pairwise_crypto != NONE_CRYPT) && (group_crypto == NONE_CRYPT))\n\t\treturn -EINVAL;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(struct wmi_connect_cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcc = (struct wmi_connect_cmd *) skb->data;\n\n\tif (ssid_len)\n\t\tmemcpy(cc->ssid, ssid, ssid_len);\n\n\tcc->ssid_len = ssid_len;\n\tcc->nw_type = nw_type;\n\tcc->dot11_auth_mode = dot11_auth_mode;\n\tcc->auth_mode = auth_mode;\n\tcc->prwise_crypto_type = pairwise_crypto;\n\tcc->prwise_crypto_len = pairwise_crypto_len;\n\tcc->grp_crypto_type = group_crypto;\n\tcc->grp_crypto_len = group_crypto_len;\n\tcc->ch = cpu_to_le16(channel);\n\tcc->ctrl_flags = cpu_to_le32(ctrl_flags);\n\tcc->nw_subtype = nw_subtype;\n\n\tif (bssid != NULL)\n\t\tmemcpy(cc->bssid, bssid, ETH_ALEN);\n\n\tret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_CONNECT_CMDID,\n\t\t\t\t  NO_SYNC_WMIFLAG);\n\n\treturn ret;\n}\n\nint ath6kl_wmi_reconnect_cmd(struct wmi *wmi, u8 if_idx, u8 *bssid,\n\t\t\t     u16 channel)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_reconnect_cmd *cc;\n\tint ret;\n\n\tath6kl_dbg(ATH6KL_DBG_WMI, \"wmi reconnect bssid %pM freq %d\\n\",\n\t\t   bssid, channel);\n\n\twmi->traffic_class = 100;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(struct wmi_reconnect_cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcc = (struct wmi_reconnect_cmd *) skb->data;\n\tcc->channel = cpu_to_le16(channel);\n\n\tif (bssid != NULL)\n\t\tmemcpy(cc->bssid, bssid, ETH_ALEN);\n\n\tret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_RECONNECT_CMDID,\n\t\t\t\t  NO_SYNC_WMIFLAG);\n\n\treturn ret;\n}\n\nint ath6kl_wmi_disconnect_cmd(struct wmi *wmi, u8 if_idx)\n{\n\tint ret;\n\n\tath6kl_dbg(ATH6KL_DBG_WMI, \"wmi disconnect\\n\");\n\n\twmi->traffic_class = 100;\n\n\t \n\tret = ath6kl_wmi_simple_cmd(wmi, if_idx, WMI_DISCONNECT_CMDID);\n\n\treturn ret;\n}\n\n \nstatic int ath6kl_wmi_startscan_cmd(struct wmi *wmi, u8 if_idx,\n\t\t\t\t    enum wmi_scan_type scan_type,\n\t\t\t\t    u32 force_fgscan, u32 is_legacy,\n\t\t\t\t    u32 home_dwell_time,\n\t\t\t\t    u32 force_scan_interval,\n\t\t\t\t    s8 num_chan, u16 *ch_list)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_start_scan_cmd *sc;\n\tint i, ret;\n\n\tif ((scan_type != WMI_LONG_SCAN) && (scan_type != WMI_SHORT_SCAN))\n\t\treturn -EINVAL;\n\n\tif (num_chan > WMI_MAX_CHANNELS)\n\t\treturn -EINVAL;\n\n\tskb = ath6kl_wmi_get_new_buf(struct_size(sc, ch_list, num_chan));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tsc = (struct wmi_start_scan_cmd *) skb->data;\n\tsc->scan_type = scan_type;\n\tsc->force_fg_scan = cpu_to_le32(force_fgscan);\n\tsc->is_legacy = cpu_to_le32(is_legacy);\n\tsc->home_dwell_time = cpu_to_le32(home_dwell_time);\n\tsc->force_scan_intvl = cpu_to_le32(force_scan_interval);\n\tsc->num_ch = num_chan;\n\n\tfor (i = 0; i < num_chan; i++)\n\t\tsc->ch_list[i] = cpu_to_le16(ch_list[i]);\n\n\tret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_START_SCAN_CMDID,\n\t\t\t\t  NO_SYNC_WMIFLAG);\n\n\treturn ret;\n}\n\n \nint ath6kl_wmi_beginscan_cmd(struct wmi *wmi, u8 if_idx,\n\t\t\t     enum wmi_scan_type scan_type,\n\t\t\t     u32 force_fgscan, u32 is_legacy,\n\t\t\t     u32 home_dwell_time, u32 force_scan_interval,\n\t\t\t     s8 num_chan, u16 *ch_list, u32 no_cck, u32 *rates)\n{\n\tstruct ieee80211_supported_band *sband;\n\tstruct sk_buff *skb;\n\tstruct wmi_begin_scan_cmd *sc;\n\ts8 *supp_rates;\n\tint i, band, ret;\n\tstruct ath6kl *ar = wmi->parent_dev;\n\tint num_rates;\n\tu32 ratemask;\n\n\tif (!test_bit(ATH6KL_FW_CAPABILITY_STA_P2PDEV_DUPLEX,\n\t\t      ar->fw_capabilities)) {\n\t\treturn ath6kl_wmi_startscan_cmd(wmi, if_idx,\n\t\t\t\t\t\tscan_type, force_fgscan,\n\t\t\t\t\t\tis_legacy, home_dwell_time,\n\t\t\t\t\t\tforce_scan_interval,\n\t\t\t\t\t\tnum_chan, ch_list);\n\t}\n\n\tif ((scan_type != WMI_LONG_SCAN) && (scan_type != WMI_SHORT_SCAN))\n\t\treturn -EINVAL;\n\n\tif (num_chan > WMI_MAX_CHANNELS)\n\t\treturn -EINVAL;\n\n\tskb = ath6kl_wmi_get_new_buf(struct_size(sc, ch_list, num_chan));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tsc = (struct wmi_begin_scan_cmd *) skb->data;\n\tsc->scan_type = scan_type;\n\tsc->force_fg_scan = cpu_to_le32(force_fgscan);\n\tsc->is_legacy = cpu_to_le32(is_legacy);\n\tsc->home_dwell_time = cpu_to_le32(home_dwell_time);\n\tsc->force_scan_intvl = cpu_to_le32(force_scan_interval);\n\tsc->no_cck = cpu_to_le32(no_cck);\n\tsc->num_ch = num_chan;\n\n\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\tsband = ar->wiphy->bands[band];\n\n\t\tif (!sband)\n\t\t\tcontinue;\n\n\t\tif (WARN_ON(band >= ATH6KL_NUM_BANDS))\n\t\t\tbreak;\n\n\t\tratemask = rates[band];\n\t\tsupp_rates = sc->supp_rates[band].rates;\n\t\tnum_rates = 0;\n\n\t\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\t\tif ((BIT(i) & ratemask) == 0)\n\t\t\t\tcontinue;  \n\t\t\tsupp_rates[num_rates++] =\n\t\t\t    (u8) (sband->bitrates[i].bitrate / 5);\n\t\t}\n\t\tsc->supp_rates[band].nrates = num_rates;\n\t}\n\n\tfor (i = 0; i < num_chan; i++)\n\t\tsc->ch_list[i] = cpu_to_le16(ch_list[i]);\n\n\tret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_BEGIN_SCAN_CMDID,\n\t\t\t\t  NO_SYNC_WMIFLAG);\n\n\treturn ret;\n}\n\nint ath6kl_wmi_enable_sched_scan_cmd(struct wmi *wmi, u8 if_idx, bool enable)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_enable_sched_scan_cmd *sc;\n\tint ret;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*sc));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tath6kl_dbg(ATH6KL_DBG_WMI, \"%s scheduled scan on vif %d\\n\",\n\t\t   enable ? \"enabling\" : \"disabling\", if_idx);\n\tsc = (struct wmi_enable_sched_scan_cmd *) skb->data;\n\tsc->enable = enable ? 1 : 0;\n\n\tret = ath6kl_wmi_cmd_send(wmi, if_idx, skb,\n\t\t\t\t  WMI_ENABLE_SCHED_SCAN_CMDID,\n\t\t\t\t  NO_SYNC_WMIFLAG);\n\treturn ret;\n}\n\nint ath6kl_wmi_scanparams_cmd(struct wmi *wmi, u8 if_idx,\n\t\t\t      u16 fg_start_sec,\n\t\t\t      u16 fg_end_sec, u16 bg_sec,\n\t\t\t      u16 minact_chdw_msec, u16 maxact_chdw_msec,\n\t\t\t      u16 pas_chdw_msec, u8 short_scan_ratio,\n\t\t\t      u8 scan_ctrl_flag, u32 max_dfsch_act_time,\n\t\t\t      u16 maxact_scan_per_ssid)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_scan_params_cmd *sc;\n\tint ret;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*sc));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tsc = (struct wmi_scan_params_cmd *) skb->data;\n\tsc->fg_start_period = cpu_to_le16(fg_start_sec);\n\tsc->fg_end_period = cpu_to_le16(fg_end_sec);\n\tsc->bg_period = cpu_to_le16(bg_sec);\n\tsc->minact_chdwell_time = cpu_to_le16(minact_chdw_msec);\n\tsc->maxact_chdwell_time = cpu_to_le16(maxact_chdw_msec);\n\tsc->pas_chdwell_time = cpu_to_le16(pas_chdw_msec);\n\tsc->short_scan_ratio = short_scan_ratio;\n\tsc->scan_ctrl_flags = scan_ctrl_flag;\n\tsc->max_dfsch_act_time = cpu_to_le32(max_dfsch_act_time);\n\tsc->maxact_scan_per_ssid = cpu_to_le16(maxact_scan_per_ssid);\n\n\tret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_SET_SCAN_PARAMS_CMDID,\n\t\t\t\t  NO_SYNC_WMIFLAG);\n\treturn ret;\n}\n\nint ath6kl_wmi_bssfilter_cmd(struct wmi *wmi, u8 if_idx, u8 filter, u32 ie_mask)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_bss_filter_cmd *cmd;\n\tint ret;\n\n\tif (filter >= LAST_BSS_FILTER)\n\t\treturn -EINVAL;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_bss_filter_cmd *) skb->data;\n\tcmd->bss_filter = filter;\n\tcmd->ie_mask = cpu_to_le32(ie_mask);\n\n\tret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_SET_BSS_FILTER_CMDID,\n\t\t\t\t  NO_SYNC_WMIFLAG);\n\treturn ret;\n}\n\nint ath6kl_wmi_probedssid_cmd(struct wmi *wmi, u8 if_idx, u8 index, u8 flag,\n\t\t\t      u8 ssid_len, u8 *ssid)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_probed_ssid_cmd *cmd;\n\tint ret;\n\n\tif (index >= MAX_PROBED_SSIDS)\n\t\treturn -EINVAL;\n\n\tif (ssid_len > sizeof(cmd->ssid))\n\t\treturn -EINVAL;\n\n\tif ((flag & (DISABLE_SSID_FLAG | ANY_SSID_FLAG)) && (ssid_len > 0))\n\t\treturn -EINVAL;\n\n\tif ((flag & SPECIFIC_SSID_FLAG) && !ssid_len)\n\t\treturn -EINVAL;\n\n\tif (flag & SPECIFIC_SSID_FLAG)\n\t\twmi->is_probe_ssid = true;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_probed_ssid_cmd *) skb->data;\n\tcmd->entry_index = index;\n\tcmd->flag = flag;\n\tcmd->ssid_len = ssid_len;\n\tmemcpy(cmd->ssid, ssid, ssid_len);\n\n\tret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_SET_PROBED_SSID_CMDID,\n\t\t\t\t  NO_SYNC_WMIFLAG);\n\treturn ret;\n}\n\nint ath6kl_wmi_listeninterval_cmd(struct wmi *wmi, u8 if_idx,\n\t\t\t\t  u16 listen_interval,\n\t\t\t\t  u16 listen_beacons)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_listen_int_cmd *cmd;\n\tint ret;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_listen_int_cmd *) skb->data;\n\tcmd->listen_intvl = cpu_to_le16(listen_interval);\n\tcmd->num_beacons = cpu_to_le16(listen_beacons);\n\n\tret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_SET_LISTEN_INT_CMDID,\n\t\t\t\t  NO_SYNC_WMIFLAG);\n\treturn ret;\n}\n\nint ath6kl_wmi_bmisstime_cmd(struct wmi *wmi, u8 if_idx,\n\t\t\t     u16 bmiss_time, u16 num_beacons)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_bmiss_time_cmd *cmd;\n\tint ret;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_bmiss_time_cmd *) skb->data;\n\tcmd->bmiss_time = cpu_to_le16(bmiss_time);\n\tcmd->num_beacons = cpu_to_le16(num_beacons);\n\n\tret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_SET_BMISS_TIME_CMDID,\n\t\t\t\t  NO_SYNC_WMIFLAG);\n\treturn ret;\n}\n\nint ath6kl_wmi_powermode_cmd(struct wmi *wmi, u8 if_idx, u8 pwr_mode)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_power_mode_cmd *cmd;\n\tint ret;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_power_mode_cmd *) skb->data;\n\tcmd->pwr_mode = pwr_mode;\n\twmi->pwr_mode = pwr_mode;\n\n\tret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_SET_POWER_MODE_CMDID,\n\t\t\t\t  NO_SYNC_WMIFLAG);\n\treturn ret;\n}\n\nint ath6kl_wmi_pmparams_cmd(struct wmi *wmi, u8 if_idx, u16 idle_period,\n\t\t\t    u16 ps_poll_num, u16 dtim_policy,\n\t\t\t    u16 tx_wakeup_policy, u16 num_tx_to_wakeup,\n\t\t\t    u16 ps_fail_event_policy)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_power_params_cmd *pm;\n\tint ret;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*pm));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tpm = (struct wmi_power_params_cmd *)skb->data;\n\tpm->idle_period = cpu_to_le16(idle_period);\n\tpm->pspoll_number = cpu_to_le16(ps_poll_num);\n\tpm->dtim_policy = cpu_to_le16(dtim_policy);\n\tpm->tx_wakeup_policy = cpu_to_le16(tx_wakeup_policy);\n\tpm->num_tx_to_wakeup = cpu_to_le16(num_tx_to_wakeup);\n\tpm->ps_fail_event_policy = cpu_to_le16(ps_fail_event_policy);\n\n\tret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_SET_POWER_PARAMS_CMDID,\n\t\t\t\t  NO_SYNC_WMIFLAG);\n\treturn ret;\n}\n\nint ath6kl_wmi_disctimeout_cmd(struct wmi *wmi, u8 if_idx, u8 timeout)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_disc_timeout_cmd *cmd;\n\tint ret;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_disc_timeout_cmd *) skb->data;\n\tcmd->discon_timeout = timeout;\n\n\tret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_SET_DISC_TIMEOUT_CMDID,\n\t\t\t\t  NO_SYNC_WMIFLAG);\n\n\tif (ret == 0)\n\t\tath6kl_debug_set_disconnect_timeout(wmi->parent_dev, timeout);\n\n\treturn ret;\n}\n\nint ath6kl_wmi_addkey_cmd(struct wmi *wmi, u8 if_idx, u8 key_index,\n\t\t\t  enum ath6kl_crypto_type key_type,\n\t\t\t  u8 key_usage, u8 key_len,\n\t\t\t  u8 *key_rsc, unsigned int key_rsc_len,\n\t\t\t  u8 *key_material,\n\t\t\t  u8 key_op_ctrl, u8 *mac_addr,\n\t\t\t  enum wmi_sync_flag sync_flag)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_add_cipher_key_cmd *cmd;\n\tint ret;\n\n\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t   \"addkey cmd: key_index=%u key_type=%d key_usage=%d key_len=%d key_op_ctrl=%d\\n\",\n\t\t   key_index, key_type, key_usage, key_len, key_op_ctrl);\n\n\tif ((key_index > WMI_MAX_KEY_INDEX) || (key_len > WMI_MAX_KEY_LEN) ||\n\t    (key_material == NULL) || key_rsc_len > 8)\n\t\treturn -EINVAL;\n\n\tif ((WEP_CRYPT != key_type) && (NULL == key_rsc))\n\t\treturn -EINVAL;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_add_cipher_key_cmd *) skb->data;\n\tcmd->key_index = key_index;\n\tcmd->key_type = key_type;\n\tcmd->key_usage = key_usage;\n\tcmd->key_len = key_len;\n\tmemcpy(cmd->key, key_material, key_len);\n\n\tif (key_rsc != NULL)\n\t\tmemcpy(cmd->key_rsc, key_rsc, key_rsc_len);\n\n\tcmd->key_op_ctrl = key_op_ctrl;\n\n\tif (mac_addr)\n\t\tmemcpy(cmd->key_mac_addr, mac_addr, ETH_ALEN);\n\n\tret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_ADD_CIPHER_KEY_CMDID,\n\t\t\t\t  sync_flag);\n\n\treturn ret;\n}\n\nint ath6kl_wmi_add_krk_cmd(struct wmi *wmi, u8 if_idx, const u8 *krk)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_add_krk_cmd *cmd;\n\tint ret;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_add_krk_cmd *) skb->data;\n\tmemcpy(cmd->krk, krk, WMI_KRK_LEN);\n\n\tret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_ADD_KRK_CMDID,\n\t\t\t\t  NO_SYNC_WMIFLAG);\n\n\treturn ret;\n}\n\nint ath6kl_wmi_deletekey_cmd(struct wmi *wmi, u8 if_idx, u8 key_index)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_delete_cipher_key_cmd *cmd;\n\tint ret;\n\n\tif (key_index > WMI_MAX_KEY_INDEX)\n\t\treturn -EINVAL;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_delete_cipher_key_cmd *) skb->data;\n\tcmd->key_index = key_index;\n\n\tret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_DELETE_CIPHER_KEY_CMDID,\n\t\t\t\t  NO_SYNC_WMIFLAG);\n\n\treturn ret;\n}\n\nint ath6kl_wmi_setpmkid_cmd(struct wmi *wmi, u8 if_idx, const u8 *bssid,\n\t\t\t    const u8 *pmkid, bool set)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_setpmkid_cmd *cmd;\n\tint ret;\n\n\tif (bssid == NULL)\n\t\treturn -EINVAL;\n\n\tif (set && pmkid == NULL)\n\t\treturn -EINVAL;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_setpmkid_cmd *) skb->data;\n\tmemcpy(cmd->bssid, bssid, ETH_ALEN);\n\tif (set) {\n\t\tmemcpy(cmd->pmkid, pmkid, sizeof(cmd->pmkid));\n\t\tcmd->enable = PMKID_ENABLE;\n\t} else {\n\t\tmemset(cmd->pmkid, 0, sizeof(cmd->pmkid));\n\t\tcmd->enable = PMKID_DISABLE;\n\t}\n\n\tret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_SET_PMKID_CMDID,\n\t\t\t\t  NO_SYNC_WMIFLAG);\n\n\treturn ret;\n}\n\nstatic int ath6kl_wmi_data_sync_send(struct wmi *wmi, struct sk_buff *skb,\n\t\t\t      enum htc_endpoint_id ep_id, u8 if_idx)\n{\n\tstruct wmi_data_hdr *data_hdr;\n\tint ret;\n\n\tif (WARN_ON(skb == NULL || ep_id == wmi->ep_id)) {\n\t\tdev_kfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\tskb_push(skb, sizeof(struct wmi_data_hdr));\n\n\tdata_hdr = (struct wmi_data_hdr *) skb->data;\n\tdata_hdr->info = SYNC_MSGTYPE << WMI_DATA_HDR_MSG_TYPE_SHIFT;\n\tdata_hdr->info3 = cpu_to_le16(if_idx & WMI_DATA_HDR_IF_IDX_MASK);\n\n\tret = ath6kl_control_tx(wmi->parent_dev, skb, ep_id);\n\n\treturn ret;\n}\n\nstatic int ath6kl_wmi_sync_point(struct wmi *wmi, u8 if_idx)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_sync_cmd *cmd;\n\tstruct wmi_data_sync_bufs data_sync_bufs[WMM_NUM_AC];\n\tenum htc_endpoint_id ep_id;\n\tu8 index, num_pri_streams = 0;\n\tint ret = 0;\n\n\tmemset(data_sync_bufs, 0, sizeof(data_sync_bufs));\n\n\tspin_lock_bh(&wmi->lock);\n\n\tfor (index = 0; index < WMM_NUM_AC; index++) {\n\t\tif (wmi->fat_pipe_exist & (1 << index)) {\n\t\t\tnum_pri_streams++;\n\t\t\tdata_sync_bufs[num_pri_streams - 1].traffic_class =\n\t\t\t    index;\n\t\t}\n\t}\n\n\tspin_unlock_bh(&wmi->lock);\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_sync_cmd *) skb->data;\n\n\t \n\tcmd->data_sync_map = wmi->fat_pipe_exist;\n\n\tfor (index = 0; index < num_pri_streams; index++) {\n\t\tdata_sync_bufs[index].skb = ath6kl_buf_alloc(0);\n\t\tif (data_sync_bufs[index].skb == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (ret)\n\t\tgoto free_cmd_skb;\n\n\t \n\tret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_SYNCHRONIZE_CMDID,\n\t\t\t\t  NO_SYNC_WMIFLAG);\n\n\tif (ret)\n\t\tgoto free_data_skb;\n\n\tfor (index = 0; index < num_pri_streams; index++) {\n\t\tif (WARN_ON(!data_sync_bufs[index].skb)) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_data_skb;\n\t\t}\n\n\t\tep_id = ath6kl_ac2_endpoint_id(wmi->parent_dev,\n\t\t\t\t\t       data_sync_bufs[index].\n\t\t\t\t\t       traffic_class);\n\t\tret =\n\t\t    ath6kl_wmi_data_sync_send(wmi, data_sync_bufs[index].skb,\n\t\t\t\t\t      ep_id, if_idx);\n\n\t\tdata_sync_bufs[index].skb = NULL;\n\n\t\tif (ret)\n\t\t\tgoto free_data_skb;\n\t}\n\n\treturn 0;\n\nfree_cmd_skb:\n\t \n\tdev_kfree_skb(skb);\n\nfree_data_skb:\n\tfor (index = 0; index < num_pri_streams; index++)\n\t\tdev_kfree_skb((struct sk_buff *)data_sync_bufs[index].skb);\n\n\treturn ret;\n}\n\nint ath6kl_wmi_create_pstream_cmd(struct wmi *wmi, u8 if_idx,\n\t\t\t\t  struct wmi_create_pstream_cmd *params)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_create_pstream_cmd *cmd;\n\tu8 fatpipe_exist_for_ac = 0;\n\ts32 min_phy = 0;\n\ts32 nominal_phy = 0;\n\tint ret;\n\n\tif (!((params->user_pri <= 0x7) &&\n\t      (up_to_ac[params->user_pri & 0x7] == params->traffic_class) &&\n\t      (params->traffic_direc == UPLINK_TRAFFIC ||\n\t       params->traffic_direc == DNLINK_TRAFFIC ||\n\t       params->traffic_direc == BIDIR_TRAFFIC) &&\n\t      (params->traffic_type == TRAFFIC_TYPE_APERIODIC ||\n\t       params->traffic_type == TRAFFIC_TYPE_PERIODIC) &&\n\t      (params->voice_psc_cap == DISABLE_FOR_THIS_AC ||\n\t       params->voice_psc_cap == ENABLE_FOR_THIS_AC ||\n\t       params->voice_psc_cap == ENABLE_FOR_ALL_AC) &&\n\t      (params->tsid == WMI_IMPLICIT_PSTREAM ||\n\t       params->tsid <= WMI_MAX_THINSTREAM))) {\n\t\treturn -EINVAL;\n\t}\n\n\t \n\n\t \n\tmin_phy = ((le32_to_cpu(params->min_phy_rate) / 1000) / 1000);\n\n\t \n\tif (params->nominal_phy >= min_phy) {\n\t\t \n\t\tnominal_phy = (params->nominal_phy * 1000) / 500;\n\t\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t\t   \"TSRS IE enabled::MinPhy %x->NominalPhy ===> %x\\n\",\n\t\t\t   min_phy, nominal_phy);\n\n\t\tparams->nominal_phy = nominal_phy;\n\t} else {\n\t\tparams->nominal_phy = 0;\n\t}\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t   \"sending create_pstream_cmd: ac=%d  tsid:%d\\n\",\n\t\t   params->traffic_class, params->tsid);\n\n\tcmd = (struct wmi_create_pstream_cmd *) skb->data;\n\tmemcpy(cmd, params, sizeof(*cmd));\n\n\t \n\tif ((u32) params->tsid == (u32) WMI_IMPLICIT_PSTREAM) {\n\t\tspin_lock_bh(&wmi->lock);\n\t\tfatpipe_exist_for_ac = (wmi->fat_pipe_exist &\n\t\t\t\t\t(1 << params->traffic_class));\n\t\twmi->fat_pipe_exist |= (1 << params->traffic_class);\n\t\tspin_unlock_bh(&wmi->lock);\n\t} else {\n\t\t \n\t\tspin_lock_bh(&wmi->lock);\n\t\tfatpipe_exist_for_ac = (wmi->fat_pipe_exist &\n\t\t\t\t\t(1 << params->traffic_class));\n\t\twmi->stream_exist_for_ac[params->traffic_class] |=\n\t\t    (1 << params->tsid);\n\t\t \n\t\twmi->fat_pipe_exist |= (1 << params->traffic_class);\n\t\tspin_unlock_bh(&wmi->lock);\n\t}\n\n\t \n\tif (!fatpipe_exist_for_ac)\n\t\tath6kl_indicate_tx_activity(wmi->parent_dev,\n\t\t\t\t\t    params->traffic_class, true);\n\n\tret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_CREATE_PSTREAM_CMDID,\n\t\t\t\t  NO_SYNC_WMIFLAG);\n\treturn ret;\n}\n\nint ath6kl_wmi_delete_pstream_cmd(struct wmi *wmi, u8 if_idx, u8 traffic_class,\n\t\t\t\t  u8 tsid)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_delete_pstream_cmd *cmd;\n\tu16 active_tsids = 0;\n\tint ret;\n\n\tif (traffic_class >= WMM_NUM_AC) {\n\t\tath6kl_err(\"invalid traffic class: %d\\n\", traffic_class);\n\t\treturn -EINVAL;\n\t}\n\n\tif (tsid >= 16) {\n\t\tath6kl_err(\"invalid tsid: %d\\n\", tsid);\n\t\treturn -EINVAL;\n\t}\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_delete_pstream_cmd *) skb->data;\n\tcmd->traffic_class = traffic_class;\n\tcmd->tsid = tsid;\n\n\tspin_lock_bh(&wmi->lock);\n\tactive_tsids = wmi->stream_exist_for_ac[traffic_class];\n\tspin_unlock_bh(&wmi->lock);\n\n\tif (!(active_tsids & (1 << tsid))) {\n\t\tdev_kfree_skb(skb);\n\t\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t\t   \"TSID %d doesn't exist for traffic class: %d\\n\",\n\t\t\t   tsid, traffic_class);\n\t\treturn -ENODATA;\n\t}\n\n\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t   \"sending delete_pstream_cmd: traffic class: %d tsid=%d\\n\",\n\t\t   traffic_class, tsid);\n\n\tret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_DELETE_PSTREAM_CMDID,\n\t\t\t\t  SYNC_BEFORE_WMIFLAG);\n\n\tspin_lock_bh(&wmi->lock);\n\twmi->stream_exist_for_ac[traffic_class] &= ~(1 << tsid);\n\tactive_tsids = wmi->stream_exist_for_ac[traffic_class];\n\tspin_unlock_bh(&wmi->lock);\n\n\t \n\tif (!active_tsids) {\n\t\tath6kl_indicate_tx_activity(wmi->parent_dev,\n\t\t\t\t\t    traffic_class, false);\n\t\twmi->fat_pipe_exist &= ~(1 << traffic_class);\n\t}\n\n\treturn ret;\n}\n\nint ath6kl_wmi_set_ip_cmd(struct wmi *wmi, u8 if_idx,\n\t\t\t  __be32 ips0, __be32 ips1)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_set_ip_cmd *cmd;\n\tint ret;\n\n\t \n\tif (ipv4_is_multicast(ips0) ||\n\t    ipv4_is_multicast(ips1))\n\t\treturn -EINVAL;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(struct wmi_set_ip_cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_set_ip_cmd *) skb->data;\n\tcmd->ips[0] = ips0;\n\tcmd->ips[1] = ips1;\n\n\tret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_SET_IP_CMDID,\n\t\t\t\t  NO_SYNC_WMIFLAG);\n\treturn ret;\n}\n\nstatic void ath6kl_wmi_relinquish_implicit_pstream_credits(struct wmi *wmi)\n{\n\tu16 active_tsids;\n\tu8 stream_exist;\n\tint i;\n\n\t \n\tspin_lock_bh(&wmi->lock);\n\tstream_exist = wmi->fat_pipe_exist;\n\tspin_unlock_bh(&wmi->lock);\n\n\tfor (i = 0; i < WMM_NUM_AC; i++) {\n\t\tif (stream_exist & (1 << i)) {\n\t\t\t \n\t\t\tspin_lock_bh(&wmi->lock);\n\t\t\tactive_tsids = wmi->stream_exist_for_ac[i];\n\t\t\tspin_unlock_bh(&wmi->lock);\n\n\t\t\t \n\t\t\tif (!active_tsids) {\n\t\t\t\tstream_exist &= ~(1 << i);\n\t\t\t\t \n\t\t\t\tath6kl_indicate_tx_activity(wmi->parent_dev,\n\t\t\t\t\t\t\t    i, false);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tspin_lock_bh(&wmi->lock);\n\twmi->fat_pipe_exist = stream_exist;\n\tspin_unlock_bh(&wmi->lock);\n}\n\nstatic int ath6kl_set_bitrate_mask64(struct wmi *wmi, u8 if_idx,\n\t\t\t\t     const struct cfg80211_bitrate_mask *mask)\n{\n\tstruct sk_buff *skb;\n\tint ret, mode, band;\n\tu64 mcsrate, ratemask[ATH6KL_NUM_BANDS];\n\tstruct wmi_set_tx_select_rates64_cmd *cmd;\n\n\tmemset(&ratemask, 0, sizeof(ratemask));\n\n\t \n\tfor (band = 0; band <= NL80211_BAND_5GHZ; band++) {\n\t\t \n\t\tratemask[band] = mask->control[band].legacy;\n\t\tif (band == NL80211_BAND_5GHZ)\n\t\t\tratemask[band] =\n\t\t\t\tmask->control[band].legacy << 4;\n\n\t\t \n\t\tmcsrate = mask->control[band].ht_mcs[1];\n\t\tmcsrate <<= 8;\n\t\tmcsrate |= mask->control[band].ht_mcs[0];\n\t\tratemask[band] |= mcsrate << 12;\n\t\tratemask[band] |= mcsrate << 28;\n\t}\n\n\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t   \"Ratemask 64 bit: 2.4:%llx 5:%llx\\n\",\n\t\t   ratemask[0], ratemask[1]);\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd) * WMI_RATES_MODE_MAX);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_set_tx_select_rates64_cmd *) skb->data;\n\tfor (mode = 0; mode < WMI_RATES_MODE_MAX; mode++) {\n\t\t \n\t\tif (mode == WMI_RATES_MODE_11A ||\n\t\t    mode == WMI_RATES_MODE_11A_HT20 ||\n\t\t    mode == WMI_RATES_MODE_11A_HT40)\n\t\t\tband = NL80211_BAND_5GHZ;\n\t\telse\n\t\t\tband = NL80211_BAND_2GHZ;\n\t\tcmd->ratemask[mode] = cpu_to_le64(ratemask[band]);\n\t}\n\n\tret = ath6kl_wmi_cmd_send(wmi, if_idx, skb,\n\t\t\t\t  WMI_SET_TX_SELECT_RATES_CMDID,\n\t\t\t\t  NO_SYNC_WMIFLAG);\n\treturn ret;\n}\n\nstatic int ath6kl_set_bitrate_mask32(struct wmi *wmi, u8 if_idx,\n\t\t\t\t     const struct cfg80211_bitrate_mask *mask)\n{\n\tstruct sk_buff *skb;\n\tint ret, mode, band;\n\tu32 mcsrate, ratemask[ATH6KL_NUM_BANDS];\n\tstruct wmi_set_tx_select_rates32_cmd *cmd;\n\n\tmemset(&ratemask, 0, sizeof(ratemask));\n\n\t \n\tfor (band = 0; band <= NL80211_BAND_5GHZ; band++) {\n\t\t \n\t\tratemask[band] = mask->control[band].legacy;\n\t\tif (band == NL80211_BAND_5GHZ)\n\t\t\tratemask[band] =\n\t\t\t\tmask->control[band].legacy << 4;\n\n\t\t \n\t\tmcsrate = mask->control[band].ht_mcs[0];\n\t\tratemask[band] |= mcsrate << 12;\n\t\tratemask[band] |= mcsrate << 20;\n\t}\n\n\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t   \"Ratemask 32 bit: 2.4:%x 5:%x\\n\",\n\t\t   ratemask[0], ratemask[1]);\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd) * WMI_RATES_MODE_MAX);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_set_tx_select_rates32_cmd *) skb->data;\n\tfor (mode = 0; mode < WMI_RATES_MODE_MAX; mode++) {\n\t\t \n\t\tif (mode == WMI_RATES_MODE_11A ||\n\t\t    mode == WMI_RATES_MODE_11A_HT20 ||\n\t\t    mode == WMI_RATES_MODE_11A_HT40)\n\t\t\tband = NL80211_BAND_5GHZ;\n\t\telse\n\t\t\tband = NL80211_BAND_2GHZ;\n\t\tcmd->ratemask[mode] = cpu_to_le32(ratemask[band]);\n\t}\n\n\tret = ath6kl_wmi_cmd_send(wmi, if_idx, skb,\n\t\t\t\t  WMI_SET_TX_SELECT_RATES_CMDID,\n\t\t\t\t  NO_SYNC_WMIFLAG);\n\treturn ret;\n}\n\nint ath6kl_wmi_set_bitrate_mask(struct wmi *wmi, u8 if_idx,\n\t\t\t\tconst struct cfg80211_bitrate_mask *mask)\n{\n\tstruct ath6kl *ar = wmi->parent_dev;\n\n\tif (test_bit(ATH6KL_FW_CAPABILITY_64BIT_RATES,\n\t\t     ar->fw_capabilities))\n\t\treturn ath6kl_set_bitrate_mask64(wmi, if_idx, mask);\n\telse\n\t\treturn ath6kl_set_bitrate_mask32(wmi, if_idx, mask);\n}\n\nint ath6kl_wmi_set_host_sleep_mode_cmd(struct wmi *wmi, u8 if_idx,\n\t\t\t\t       enum ath6kl_host_mode host_mode)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_set_host_sleep_mode_cmd *cmd;\n\tint ret;\n\n\tif ((host_mode != ATH6KL_HOST_MODE_ASLEEP) &&\n\t    (host_mode != ATH6KL_HOST_MODE_AWAKE)) {\n\t\tath6kl_err(\"invalid host sleep mode: %d\\n\", host_mode);\n\t\treturn -EINVAL;\n\t}\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_set_host_sleep_mode_cmd *) skb->data;\n\n\tif (host_mode == ATH6KL_HOST_MODE_ASLEEP) {\n\t\tath6kl_wmi_relinquish_implicit_pstream_credits(wmi);\n\t\tcmd->asleep = cpu_to_le32(1);\n\t} else {\n\t\tcmd->awake = cpu_to_le32(1);\n\t}\n\n\tret = ath6kl_wmi_cmd_send(wmi, if_idx, skb,\n\t\t\t\t  WMI_SET_HOST_SLEEP_MODE_CMDID,\n\t\t\t\t  NO_SYNC_WMIFLAG);\n\treturn ret;\n}\n\n \nstatic int ath6kl_wmi_host_sleep_mode_cmd_prcd_evt_rx(struct wmi *wmi,\n\t\t\t\t\t\t      struct ath6kl_vif *vif)\n{\n\tstruct ath6kl *ar = wmi->parent_dev;\n\n\tset_bit(HOST_SLEEP_MODE_CMD_PROCESSED, &vif->flags);\n\twake_up(&ar->event_wq);\n\n\treturn 0;\n}\n\nint ath6kl_wmi_set_wow_mode_cmd(struct wmi *wmi, u8 if_idx,\n\t\t\t\tenum ath6kl_wow_mode wow_mode,\n\t\t\t\tu32 filter, u16 host_req_delay)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_set_wow_mode_cmd *cmd;\n\tint ret;\n\n\tif ((wow_mode != ATH6KL_WOW_MODE_ENABLE) &&\n\t    wow_mode != ATH6KL_WOW_MODE_DISABLE) {\n\t\tath6kl_err(\"invalid wow mode: %d\\n\", wow_mode);\n\t\treturn -EINVAL;\n\t}\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_set_wow_mode_cmd *) skb->data;\n\tcmd->enable_wow = cpu_to_le32(wow_mode);\n\tcmd->filter = cpu_to_le32(filter);\n\tcmd->host_req_delay = cpu_to_le16(host_req_delay);\n\n\tret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_SET_WOW_MODE_CMDID,\n\t\t\t\t  NO_SYNC_WMIFLAG);\n\treturn ret;\n}\n\nint ath6kl_wmi_add_wow_pattern_cmd(struct wmi *wmi, u8 if_idx,\n\t\t\t\t   u8 list_id, u8 filter_size,\n\t\t\t\t   u8 filter_offset, const u8 *filter,\n\t\t\t\t   const u8 *mask)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_add_wow_pattern_cmd *cmd;\n\tu16 size;\n\tu8 *filter_mask;\n\tint ret;\n\n\t \n\tsize = sizeof(*cmd) + (2 * filter_size);\n\n\tskb = ath6kl_wmi_get_new_buf(size);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_add_wow_pattern_cmd *) skb->data;\n\tcmd->filter_list_id = list_id;\n\tcmd->filter_size = filter_size;\n\tcmd->filter_offset = filter_offset;\n\n\tmemcpy(cmd->filter, filter, filter_size);\n\n\tfilter_mask = (u8 *) (cmd->filter + filter_size);\n\tmemcpy(filter_mask, mask, filter_size);\n\n\tret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_ADD_WOW_PATTERN_CMDID,\n\t\t\t\t  NO_SYNC_WMIFLAG);\n\n\treturn ret;\n}\n\nint ath6kl_wmi_del_wow_pattern_cmd(struct wmi *wmi, u8 if_idx,\n\t\t\t\t   u16 list_id, u16 filter_id)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_del_wow_pattern_cmd *cmd;\n\tint ret;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_del_wow_pattern_cmd *) skb->data;\n\tcmd->filter_list_id = cpu_to_le16(list_id);\n\tcmd->filter_id = cpu_to_le16(filter_id);\n\n\tret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_DEL_WOW_PATTERN_CMDID,\n\t\t\t\t  NO_SYNC_WMIFLAG);\n\treturn ret;\n}\n\nstatic int ath6kl_wmi_cmd_send_xtnd(struct wmi *wmi, struct sk_buff *skb,\n\t\t\t\t    enum wmix_command_id cmd_id,\n\t\t\t\t    enum wmi_sync_flag sync_flag)\n{\n\tstruct wmix_cmd_hdr *cmd_hdr;\n\tint ret;\n\n\tskb_push(skb, sizeof(struct wmix_cmd_hdr));\n\n\tcmd_hdr = (struct wmix_cmd_hdr *) skb->data;\n\tcmd_hdr->cmd_id = cpu_to_le32(cmd_id);\n\n\tret = ath6kl_wmi_cmd_send(wmi, 0, skb, WMI_EXTENSION_CMDID, sync_flag);\n\n\treturn ret;\n}\n\nint ath6kl_wmi_get_challenge_resp_cmd(struct wmi *wmi, u32 cookie, u32 source)\n{\n\tstruct sk_buff *skb;\n\tstruct wmix_hb_challenge_resp_cmd *cmd;\n\tint ret;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmix_hb_challenge_resp_cmd *) skb->data;\n\tcmd->cookie = cpu_to_le32(cookie);\n\tcmd->source = cpu_to_le32(source);\n\n\tret = ath6kl_wmi_cmd_send_xtnd(wmi, skb, WMIX_HB_CHALLENGE_RESP_CMDID,\n\t\t\t\t       NO_SYNC_WMIFLAG);\n\treturn ret;\n}\n\nint ath6kl_wmi_config_debug_module_cmd(struct wmi *wmi, u32 valid, u32 config)\n{\n\tstruct ath6kl_wmix_dbglog_cfg_module_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct ath6kl_wmix_dbglog_cfg_module_cmd *) skb->data;\n\tcmd->valid = cpu_to_le32(valid);\n\tcmd->config = cpu_to_le32(config);\n\n\tret = ath6kl_wmi_cmd_send_xtnd(wmi, skb, WMIX_DBGLOG_CFG_MODULE_CMDID,\n\t\t\t\t       NO_SYNC_WMIFLAG);\n\treturn ret;\n}\n\nint ath6kl_wmi_get_stats_cmd(struct wmi *wmi, u8 if_idx)\n{\n\treturn ath6kl_wmi_simple_cmd(wmi, if_idx, WMI_GET_STATISTICS_CMDID);\n}\n\nint ath6kl_wmi_set_tx_pwr_cmd(struct wmi *wmi, u8 if_idx, u8 dbM)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_set_tx_pwr_cmd *cmd;\n\tint ret;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(struct wmi_set_tx_pwr_cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_set_tx_pwr_cmd *) skb->data;\n\tcmd->dbM = dbM;\n\n\tret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_SET_TX_PWR_CMDID,\n\t\t\t\t  NO_SYNC_WMIFLAG);\n\n\treturn ret;\n}\n\nint ath6kl_wmi_get_tx_pwr_cmd(struct wmi *wmi, u8 if_idx)\n{\n\treturn ath6kl_wmi_simple_cmd(wmi, if_idx, WMI_GET_TX_PWR_CMDID);\n}\n\nint ath6kl_wmi_get_roam_tbl_cmd(struct wmi *wmi)\n{\n\treturn ath6kl_wmi_simple_cmd(wmi, 0, WMI_GET_ROAM_TBL_CMDID);\n}\n\nint ath6kl_wmi_set_lpreamble_cmd(struct wmi *wmi, u8 if_idx, u8 status,\n\t\t\t\t u8 preamble_policy)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_set_lpreamble_cmd *cmd;\n\tint ret;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(struct wmi_set_lpreamble_cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_set_lpreamble_cmd *) skb->data;\n\tcmd->status = status;\n\tcmd->preamble_policy = preamble_policy;\n\n\tret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_SET_LPREAMBLE_CMDID,\n\t\t\t\t  NO_SYNC_WMIFLAG);\n\treturn ret;\n}\n\nint ath6kl_wmi_set_rts_cmd(struct wmi *wmi, u16 threshold)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_set_rts_cmd *cmd;\n\tint ret;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(struct wmi_set_rts_cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_set_rts_cmd *) skb->data;\n\tcmd->threshold = cpu_to_le16(threshold);\n\n\tret = ath6kl_wmi_cmd_send(wmi, 0, skb, WMI_SET_RTS_CMDID,\n\t\t\t\t  NO_SYNC_WMIFLAG);\n\treturn ret;\n}\n\nint ath6kl_wmi_set_wmm_txop(struct wmi *wmi, u8 if_idx, enum wmi_txop_cfg cfg)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_set_wmm_txop_cmd *cmd;\n\tint ret;\n\n\tif (!((cfg == WMI_TXOP_DISABLED) || (cfg == WMI_TXOP_ENABLED)))\n\t\treturn -EINVAL;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(struct wmi_set_wmm_txop_cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_set_wmm_txop_cmd *) skb->data;\n\tcmd->txop_enable = cfg;\n\n\tret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_SET_WMM_TXOP_CMDID,\n\t\t\t\t  NO_SYNC_WMIFLAG);\n\treturn ret;\n}\n\nint ath6kl_wmi_set_keepalive_cmd(struct wmi *wmi, u8 if_idx,\n\t\t\t\t u8 keep_alive_intvl)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_set_keepalive_cmd *cmd;\n\tint ret;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_set_keepalive_cmd *) skb->data;\n\tcmd->keep_alive_intvl = keep_alive_intvl;\n\n\tret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_SET_KEEPALIVE_CMDID,\n\t\t\t\t  NO_SYNC_WMIFLAG);\n\n\tif (ret == 0)\n\t\tath6kl_debug_set_keepalive(wmi->parent_dev, keep_alive_intvl);\n\n\treturn ret;\n}\n\nint ath6kl_wmi_set_htcap_cmd(struct wmi *wmi, u8 if_idx,\n\t\t\t     enum nl80211_band band,\n\t\t\t     struct ath6kl_htcap *htcap)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_set_htcap_cmd *cmd;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_set_htcap_cmd *) skb->data;\n\n\t \n\tcmd->band = band;\n\tcmd->ht_enable = !!htcap->ht_enable;\n\tcmd->ht20_sgi = !!(htcap->cap_info & IEEE80211_HT_CAP_SGI_20);\n\tcmd->ht40_supported =\n\t\t!!(htcap->cap_info & IEEE80211_HT_CAP_SUP_WIDTH_20_40);\n\tcmd->ht40_sgi = !!(htcap->cap_info & IEEE80211_HT_CAP_SGI_40);\n\tcmd->intolerant_40mhz =\n\t\t!!(htcap->cap_info & IEEE80211_HT_CAP_40MHZ_INTOLERANT);\n\tcmd->max_ampdu_len_exp = htcap->ampdu_factor;\n\n\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t   \"Set htcap: band:%d ht_enable:%d 40mhz:%d sgi_20mhz:%d sgi_40mhz:%d 40mhz_intolerant:%d ampdu_len_exp:%d\\n\",\n\t\t   cmd->band, cmd->ht_enable, cmd->ht40_supported,\n\t\t   cmd->ht20_sgi, cmd->ht40_sgi, cmd->intolerant_40mhz,\n\t\t   cmd->max_ampdu_len_exp);\n\treturn ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_SET_HT_CAP_CMDID,\n\t\t\t\t   NO_SYNC_WMIFLAG);\n}\n\nint ath6kl_wmi_test_cmd(struct wmi *wmi, void *buf, size_t len)\n{\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath6kl_wmi_get_new_buf(len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tmemcpy(skb->data, buf, len);\n\n\tret = ath6kl_wmi_cmd_send(wmi, 0, skb, WMI_TEST_CMDID, NO_SYNC_WMIFLAG);\n\n\treturn ret;\n}\n\nint ath6kl_wmi_mcast_filter_cmd(struct wmi *wmi, u8 if_idx, bool mc_all_on)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_mcast_filter_cmd *cmd;\n\tint ret;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_mcast_filter_cmd *) skb->data;\n\tcmd->mcast_all_enable = mc_all_on;\n\n\tret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_MCAST_FILTER_CMDID,\n\t\t\t\t  NO_SYNC_WMIFLAG);\n\treturn ret;\n}\n\nint ath6kl_wmi_add_del_mcast_filter_cmd(struct wmi *wmi, u8 if_idx,\n\t\t\t\t\tu8 *filter, bool add_filter)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_mcast_filter_add_del_cmd *cmd;\n\tint ret;\n\n\tif ((filter[0] != 0x33 || filter[1] != 0x33) &&\n\t    (filter[0] != 0x01 || filter[1] != 0x00 ||\n\t    filter[2] != 0x5e || filter[3] > 0x7f)) {\n\t\tath6kl_warn(\"invalid multicast filter address\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_mcast_filter_add_del_cmd *) skb->data;\n\tmemcpy(cmd->mcast_mac, filter, ATH6KL_MCAST_FILTER_MAC_ADDR_SIZE);\n\tret = ath6kl_wmi_cmd_send(wmi, if_idx, skb,\n\t\t\t\t  add_filter ? WMI_SET_MCAST_FILTER_CMDID :\n\t\t\t\t  WMI_DEL_MCAST_FILTER_CMDID,\n\t\t\t\t  NO_SYNC_WMIFLAG);\n\n\treturn ret;\n}\n\nint ath6kl_wmi_sta_bmiss_enhance_cmd(struct wmi *wmi, u8 if_idx, bool enhance)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_sta_bmiss_enhance_cmd *cmd;\n\tint ret;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_sta_bmiss_enhance_cmd *) skb->data;\n\tcmd->enable = enhance ? 1 : 0;\n\n\tret = ath6kl_wmi_cmd_send(wmi, if_idx, skb,\n\t\t\t\t  WMI_STA_BMISS_ENHANCE_CMDID,\n\t\t\t\t  NO_SYNC_WMIFLAG);\n\treturn ret;\n}\n\nint ath6kl_wmi_set_regdomain_cmd(struct wmi *wmi, const char *alpha2)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_set_regdomain_cmd *cmd;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_set_regdomain_cmd *) skb->data;\n\tmemcpy(cmd->iso_name, alpha2, 2);\n\n\treturn ath6kl_wmi_cmd_send(wmi, 0, skb,\n\t\t\t\t   WMI_SET_REGDOMAIN_CMDID,\n\t\t\t\t   NO_SYNC_WMIFLAG);\n}\n\ns32 ath6kl_wmi_get_rate(struct wmi *wmi, s8 rate_index)\n{\n\tstruct ath6kl *ar = wmi->parent_dev;\n\tu8 sgi = 0;\n\ts32 ret;\n\n\tif (rate_index == RATE_AUTO)\n\t\treturn 0;\n\n\t \n\tif (rate_index & RATE_INDEX_MSB) {\n\t\trate_index &= RATE_INDEX_WITHOUT_SGI_MASK;\n\t\tsgi = 1;\n\t}\n\n\tif (test_bit(ATH6KL_FW_CAPABILITY_RATETABLE_MCS15,\n\t\t     ar->fw_capabilities)) {\n\t\tif (WARN_ON(rate_index >= ARRAY_SIZE(wmi_rate_tbl_mcs15)))\n\t\t\treturn 0;\n\n\t\tret = wmi_rate_tbl_mcs15[(u32) rate_index][sgi];\n\t} else {\n\t\tif (WARN_ON(rate_index >= ARRAY_SIZE(wmi_rate_tbl)))\n\t\t\treturn 0;\n\n\t\tret = wmi_rate_tbl[(u32) rate_index][sgi];\n\t}\n\n\treturn ret;\n}\n\nstatic int ath6kl_wmi_get_pmkid_list_event_rx(struct wmi *wmi, u8 *datap,\n\t\t\t\t\t      u32 len)\n{\n\tstruct wmi_pmkid_list_reply *reply;\n\tu32 expected_len;\n\n\tif (len < sizeof(struct wmi_pmkid_list_reply))\n\t\treturn -EINVAL;\n\n\treply = (struct wmi_pmkid_list_reply *)datap;\n\texpected_len = sizeof(reply->num_pmkid) +\n\t\tle32_to_cpu(reply->num_pmkid) * WMI_PMKID_LEN;\n\n\tif (len < expected_len)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int ath6kl_wmi_addba_req_event_rx(struct wmi *wmi, u8 *datap, int len,\n\t\t\t\t\t struct ath6kl_vif *vif)\n{\n\tstruct wmi_addba_req_event *cmd = (struct wmi_addba_req_event *) datap;\n\n\taggr_recv_addba_req_evt(vif, cmd->tid,\n\t\t\t\tle16_to_cpu(cmd->st_seq_no), cmd->win_sz);\n\n\treturn 0;\n}\n\nstatic int ath6kl_wmi_delba_req_event_rx(struct wmi *wmi, u8 *datap, int len,\n\t\t\t\t\t struct ath6kl_vif *vif)\n{\n\tstruct wmi_delba_event *cmd = (struct wmi_delba_event *) datap;\n\n\taggr_recv_delba_req_evt(vif, cmd->tid);\n\n\treturn 0;\n}\n\n \n\nint ath6kl_wmi_ap_profile_commit(struct wmi *wmip, u8 if_idx,\n\t\t\t\t struct wmi_connect_cmd *p)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_connect_cmd *cm;\n\tint res;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cm));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcm = (struct wmi_connect_cmd *) skb->data;\n\tmemcpy(cm, p, sizeof(*cm));\n\n\tres = ath6kl_wmi_cmd_send(wmip, if_idx, skb, WMI_AP_CONFIG_COMMIT_CMDID,\n\t\t\t\t  NO_SYNC_WMIFLAG);\n\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t   \"%s: nw_type=%u auth_mode=%u ch=%u ctrl_flags=0x%x-> res=%d\\n\",\n\t\t   __func__, p->nw_type, p->auth_mode, le16_to_cpu(p->ch),\n\t\t   le32_to_cpu(p->ctrl_flags), res);\n\treturn res;\n}\n\nint ath6kl_wmi_ap_set_mlme(struct wmi *wmip, u8 if_idx, u8 cmd, const u8 *mac,\n\t\t\t   u16 reason)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_ap_set_mlme_cmd *cm;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cm));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcm = (struct wmi_ap_set_mlme_cmd *) skb->data;\n\tmemcpy(cm->mac, mac, ETH_ALEN);\n\tcm->reason = cpu_to_le16(reason);\n\tcm->cmd = cmd;\n\n\tath6kl_dbg(ATH6KL_DBG_WMI, \"ap_set_mlme: cmd=%d reason=%d\\n\", cm->cmd,\n\t\t   cm->reason);\n\n\treturn ath6kl_wmi_cmd_send(wmip, if_idx, skb, WMI_AP_SET_MLME_CMDID,\n\t\t\t\t   NO_SYNC_WMIFLAG);\n}\n\nint ath6kl_wmi_ap_hidden_ssid(struct wmi *wmi, u8 if_idx, bool enable)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_ap_hidden_ssid_cmd *cmd;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_ap_hidden_ssid_cmd *) skb->data;\n\tcmd->hidden_ssid = enable ? 1 : 0;\n\n\treturn ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_AP_HIDDEN_SSID_CMDID,\n\t\t\t\t   NO_SYNC_WMIFLAG);\n}\n\n \nint ath6kl_wmi_ap_set_apsd(struct wmi *wmi, u8 if_idx, u8 enable)\n{\n\tstruct wmi_ap_set_apsd_cmd *cmd;\n\tstruct sk_buff *skb;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_ap_set_apsd_cmd *)skb->data;\n\tcmd->enable = enable;\n\n\treturn ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_AP_SET_APSD_CMDID,\n\t\t\t\t   NO_SYNC_WMIFLAG);\n}\n\nint ath6kl_wmi_set_apsd_bfrd_traf(struct wmi *wmi, u8 if_idx,\n\t\t\t\t\t     u16 aid, u16 bitmap, u32 flags)\n{\n\tstruct wmi_ap_apsd_buffered_traffic_cmd *cmd;\n\tstruct sk_buff *skb;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_ap_apsd_buffered_traffic_cmd *)skb->data;\n\tcmd->aid = cpu_to_le16(aid);\n\tcmd->bitmap = cpu_to_le16(bitmap);\n\tcmd->flags = cpu_to_le32(flags);\n\n\treturn ath6kl_wmi_cmd_send(wmi, if_idx, skb,\n\t\t\t\t   WMI_AP_APSD_BUFFERED_TRAFFIC_CMDID,\n\t\t\t\t   NO_SYNC_WMIFLAG);\n}\n\nstatic int ath6kl_wmi_pspoll_event_rx(struct wmi *wmi, u8 *datap, int len,\n\t\t\t\t      struct ath6kl_vif *vif)\n{\n\tstruct wmi_pspoll_event *ev;\n\n\tif (len < sizeof(struct wmi_pspoll_event))\n\t\treturn -EINVAL;\n\n\tev = (struct wmi_pspoll_event *) datap;\n\n\tath6kl_pspoll_event(vif, le16_to_cpu(ev->aid));\n\n\treturn 0;\n}\n\nstatic int ath6kl_wmi_dtimexpiry_event_rx(struct wmi *wmi, u8 *datap, int len,\n\t\t\t\t\t  struct ath6kl_vif *vif)\n{\n\tath6kl_dtimexpiry_event(vif);\n\n\treturn 0;\n}\n\nint ath6kl_wmi_set_pvb_cmd(struct wmi *wmi, u8 if_idx, u16 aid,\n\t\t\t   bool flag)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_ap_set_pvb_cmd *cmd;\n\tint ret;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(struct wmi_ap_set_pvb_cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_ap_set_pvb_cmd *) skb->data;\n\tcmd->aid = cpu_to_le16(aid);\n\tcmd->rsvd = cpu_to_le16(0);\n\tcmd->flag = cpu_to_le32(flag);\n\n\tret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_AP_SET_PVB_CMDID,\n\t\t\t\t  NO_SYNC_WMIFLAG);\n\n\treturn ret;\n}\n\nint ath6kl_wmi_set_rx_frame_format_cmd(struct wmi *wmi, u8 if_idx,\n\t\t\t\t       u8 rx_meta_ver,\n\t\t\t\t       bool rx_dot11_hdr, bool defrag_on_host)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_rx_frame_format_cmd *cmd;\n\tint ret;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_rx_frame_format_cmd *) skb->data;\n\tcmd->dot11_hdr = rx_dot11_hdr ? 1 : 0;\n\tcmd->defrag_on_host = defrag_on_host ? 1 : 0;\n\tcmd->meta_ver = rx_meta_ver;\n\n\t \n\tret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_RX_FRAME_FORMAT_CMDID,\n\t\t\t\t  NO_SYNC_WMIFLAG);\n\n\treturn ret;\n}\n\nint ath6kl_wmi_set_appie_cmd(struct wmi *wmi, u8 if_idx, u8 mgmt_frm_type,\n\t\t\t     const u8 *ie, u8 ie_len)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_set_appie_cmd *p;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*p) + ie_len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t   \"set_appie_cmd: mgmt_frm_type=%u ie_len=%u\\n\",\n\t\t   mgmt_frm_type, ie_len);\n\tp = (struct wmi_set_appie_cmd *) skb->data;\n\tp->mgmt_frm_type = mgmt_frm_type;\n\tp->ie_len = ie_len;\n\n\tif (ie != NULL && ie_len > 0)\n\t\tmemcpy(p->ie_info, ie, ie_len);\n\n\treturn ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_SET_APPIE_CMDID,\n\t\t\t\t   NO_SYNC_WMIFLAG);\n}\n\nint ath6kl_wmi_set_ie_cmd(struct wmi *wmi, u8 if_idx, u8 ie_id, u8 ie_field,\n\t\t\t  const u8 *ie_info, u8 ie_len)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_set_ie_cmd *p;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*p) + ie_len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tath6kl_dbg(ATH6KL_DBG_WMI, \"set_ie_cmd: ie_id=%u ie_ie_field=%u ie_len=%u\\n\",\n\t\t   ie_id, ie_field, ie_len);\n\tp = (struct wmi_set_ie_cmd *) skb->data;\n\tp->ie_id = ie_id;\n\tp->ie_field = ie_field;\n\tp->ie_len = ie_len;\n\tif (ie_info && ie_len > 0)\n\t\tmemcpy(p->ie_info, ie_info, ie_len);\n\n\treturn ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_SET_IE_CMDID,\n\t\t\t\t   NO_SYNC_WMIFLAG);\n}\n\nint ath6kl_wmi_disable_11b_rates_cmd(struct wmi *wmi, bool disable)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_disable_11b_rates_cmd *cmd;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tath6kl_dbg(ATH6KL_DBG_WMI, \"disable_11b_rates_cmd: disable=%u\\n\",\n\t\t   disable);\n\tcmd = (struct wmi_disable_11b_rates_cmd *) skb->data;\n\tcmd->disable = disable ? 1 : 0;\n\n\treturn ath6kl_wmi_cmd_send(wmi, 0, skb, WMI_DISABLE_11B_RATES_CMDID,\n\t\t\t\t   NO_SYNC_WMIFLAG);\n}\n\nint ath6kl_wmi_remain_on_chnl_cmd(struct wmi *wmi, u8 if_idx, u32 freq, u32 dur)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_remain_on_chnl_cmd *p;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*p));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tath6kl_dbg(ATH6KL_DBG_WMI, \"remain_on_chnl_cmd: freq=%u dur=%u\\n\",\n\t\t   freq, dur);\n\tp = (struct wmi_remain_on_chnl_cmd *) skb->data;\n\tp->freq = cpu_to_le32(freq);\n\tp->duration = cpu_to_le32(dur);\n\treturn ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_REMAIN_ON_CHNL_CMDID,\n\t\t\t\t   NO_SYNC_WMIFLAG);\n}\n\n \nstatic int ath6kl_wmi_send_action_cmd(struct wmi *wmi, u8 if_idx, u32 id,\n\t\t\t\t      u32 freq, u32 wait, const u8 *data,\n\t\t\t\t      u16 data_len)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_send_action_cmd *p;\n\tu8 *buf;\n\n\tif (wait)\n\t\treturn -EINVAL;  \n\n\tbuf = kmemdup(data, data_len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*p) + data_len);\n\tif (!skb) {\n\t\tkfree(buf);\n\t\treturn -ENOMEM;\n\t}\n\n\tkfree(wmi->last_mgmt_tx_frame);\n\twmi->last_mgmt_tx_frame = buf;\n\twmi->last_mgmt_tx_frame_len = data_len;\n\n\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t   \"send_action_cmd: id=%u freq=%u wait=%u len=%u\\n\",\n\t\t   id, freq, wait, data_len);\n\tp = (struct wmi_send_action_cmd *) skb->data;\n\tp->id = cpu_to_le32(id);\n\tp->freq = cpu_to_le32(freq);\n\tp->wait = cpu_to_le32(wait);\n\tp->len = cpu_to_le16(data_len);\n\tmemcpy(p->data, data, data_len);\n\treturn ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_SEND_ACTION_CMDID,\n\t\t\t\t   NO_SYNC_WMIFLAG);\n}\n\nstatic int __ath6kl_wmi_send_mgmt_cmd(struct wmi *wmi, u8 if_idx, u32 id,\n\t\t\t\t      u32 freq, u32 wait, const u8 *data,\n\t\t\t\t      u16 data_len, u32 no_cck)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_send_mgmt_cmd *p;\n\tu8 *buf;\n\n\tif (wait)\n\t\treturn -EINVAL;  \n\n\tbuf = kmemdup(data, data_len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*p) + data_len);\n\tif (!skb) {\n\t\tkfree(buf);\n\t\treturn -ENOMEM;\n\t}\n\n\tkfree(wmi->last_mgmt_tx_frame);\n\twmi->last_mgmt_tx_frame = buf;\n\twmi->last_mgmt_tx_frame_len = data_len;\n\n\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t   \"send_action_cmd: id=%u freq=%u wait=%u len=%u\\n\",\n\t\t   id, freq, wait, data_len);\n\tp = (struct wmi_send_mgmt_cmd *) skb->data;\n\tp->id = cpu_to_le32(id);\n\tp->freq = cpu_to_le32(freq);\n\tp->wait = cpu_to_le32(wait);\n\tp->no_cck = cpu_to_le32(no_cck);\n\tp->len = cpu_to_le16(data_len);\n\tmemcpy(p->data, data, data_len);\n\treturn ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_SEND_MGMT_CMDID,\n\t\t\t\t   NO_SYNC_WMIFLAG);\n}\n\nint ath6kl_wmi_send_mgmt_cmd(struct wmi *wmi, u8 if_idx, u32 id, u32 freq,\n\t\t\t\tu32 wait, const u8 *data, u16 data_len,\n\t\t\t\tu32 no_cck)\n{\n\tint status;\n\tstruct ath6kl *ar = wmi->parent_dev;\n\n\tif (test_bit(ATH6KL_FW_CAPABILITY_STA_P2PDEV_DUPLEX,\n\t\t     ar->fw_capabilities)) {\n\t\t \n\t\tstatus = __ath6kl_wmi_send_mgmt_cmd(ar->wmi, if_idx, id, freq,\n\t\t\t\t\t\t    wait, data, data_len,\n\t\t\t\t\t\t    no_cck);\n\t} else {\n\t\tstatus = ath6kl_wmi_send_action_cmd(ar->wmi, if_idx, id, freq,\n\t\t\t\t\t\t    wait, data, data_len);\n\t}\n\n\treturn status;\n}\n\nint ath6kl_wmi_send_probe_response_cmd(struct wmi *wmi, u8 if_idx, u32 freq,\n\t\t\t\t       const u8 *dst, const u8 *data,\n\t\t\t\t       u16 data_len)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_p2p_probe_response_cmd *p;\n\tsize_t cmd_len = sizeof(*p) + data_len;\n\n\tif (data_len == 0)\n\t\tcmd_len++;  \n\n\tskb = ath6kl_wmi_get_new_buf(cmd_len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t   \"send_probe_response_cmd: freq=%u dst=%pM len=%u\\n\",\n\t\t   freq, dst, data_len);\n\tp = (struct wmi_p2p_probe_response_cmd *) skb->data;\n\tp->freq = cpu_to_le32(freq);\n\tmemcpy(p->destination_addr, dst, ETH_ALEN);\n\tp->len = cpu_to_le16(data_len);\n\tmemcpy(p->data, data, data_len);\n\treturn ath6kl_wmi_cmd_send(wmi, if_idx, skb,\n\t\t\t\t   WMI_SEND_PROBE_RESPONSE_CMDID,\n\t\t\t\t   NO_SYNC_WMIFLAG);\n}\n\nint ath6kl_wmi_probe_report_req_cmd(struct wmi *wmi, u8 if_idx, bool enable)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_probe_req_report_cmd *p;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*p));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tath6kl_dbg(ATH6KL_DBG_WMI, \"probe_report_req_cmd: enable=%u\\n\",\n\t\t   enable);\n\tp = (struct wmi_probe_req_report_cmd *) skb->data;\n\tp->enable = enable ? 1 : 0;\n\treturn ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_PROBE_REQ_REPORT_CMDID,\n\t\t\t\t   NO_SYNC_WMIFLAG);\n}\n\nint ath6kl_wmi_info_req_cmd(struct wmi *wmi, u8 if_idx, u32 info_req_flags)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_get_p2p_info *p;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*p));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tath6kl_dbg(ATH6KL_DBG_WMI, \"info_req_cmd: flags=%x\\n\",\n\t\t   info_req_flags);\n\tp = (struct wmi_get_p2p_info *) skb->data;\n\tp->info_req_flags = cpu_to_le32(info_req_flags);\n\treturn ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_GET_P2P_INFO_CMDID,\n\t\t\t\t   NO_SYNC_WMIFLAG);\n}\n\nint ath6kl_wmi_cancel_remain_on_chnl_cmd(struct wmi *wmi, u8 if_idx)\n{\n\tath6kl_dbg(ATH6KL_DBG_WMI, \"cancel_remain_on_chnl_cmd\\n\");\n\treturn ath6kl_wmi_simple_cmd(wmi, if_idx,\n\t\t\t\t     WMI_CANCEL_REMAIN_ON_CHNL_CMDID);\n}\n\nint ath6kl_wmi_set_inact_period(struct wmi *wmi, u8 if_idx, int inact_timeout)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_set_inact_period_cmd *cmd;\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_set_inact_period_cmd *) skb->data;\n\tcmd->inact_period = cpu_to_le32(inact_timeout);\n\tcmd->num_null_func = 0;\n\n\treturn ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_AP_CONN_INACT_CMDID,\n\t\t\t\t   NO_SYNC_WMIFLAG);\n}\n\nstatic void ath6kl_wmi_hb_challenge_resp_event(struct wmi *wmi, u8 *datap,\n\t\t\t\t\t       int len)\n{\n\tstruct wmix_hb_challenge_resp_cmd *cmd;\n\n\tif (len < sizeof(struct wmix_hb_challenge_resp_cmd))\n\t\treturn;\n\n\tcmd = (struct wmix_hb_challenge_resp_cmd *) datap;\n\tath6kl_recovery_hb_event(wmi->parent_dev,\n\t\t\t\t le32_to_cpu(cmd->cookie));\n}\n\nstatic int ath6kl_wmi_control_rx_xtnd(struct wmi *wmi, struct sk_buff *skb)\n{\n\tstruct wmix_cmd_hdr *cmd;\n\tu32 len;\n\tu16 id;\n\tu8 *datap;\n\tint ret = 0;\n\n\tif (skb->len < sizeof(struct wmix_cmd_hdr)) {\n\t\tath6kl_err(\"bad packet 1\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcmd = (struct wmix_cmd_hdr *) skb->data;\n\tid = le32_to_cpu(cmd->cmd_id);\n\n\tskb_pull(skb, sizeof(struct wmix_cmd_hdr));\n\n\tdatap = skb->data;\n\tlen = skb->len;\n\n\tswitch (id) {\n\tcase WMIX_HB_CHALLENGE_RESP_EVENTID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"wmi event hb challenge resp\\n\");\n\t\tath6kl_wmi_hb_challenge_resp_event(wmi, datap, len);\n\t\tbreak;\n\tcase WMIX_DBGLOG_EVENTID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"wmi event dbglog len %d\\n\", len);\n\t\tath6kl_debug_fwlog_event(wmi->parent_dev, datap, len);\n\t\tbreak;\n\tdefault:\n\t\tath6kl_warn(\"unknown cmd id 0x%x\\n\", id);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int ath6kl_wmi_roam_tbl_event_rx(struct wmi *wmi, u8 *datap, int len)\n{\n\treturn ath6kl_debug_roam_tbl_event(wmi->parent_dev, datap, len);\n}\n\n \nstatic int ath6kl_wmi_proc_events_vif(struct wmi *wmi, u16 if_idx, u16 cmd_id,\n\t\t\t\t\tu8 *datap, u32 len)\n{\n\tstruct ath6kl_vif *vif;\n\n\tvif = ath6kl_get_vif_by_index(wmi->parent_dev, if_idx);\n\tif (!vif) {\n\t\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t\t   \"Wmi event for unavailable vif, vif_index:%d\\n\",\n\t\t\t    if_idx);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (cmd_id) {\n\tcase WMI_CONNECT_EVENTID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"WMI_CONNECT_EVENTID\\n\");\n\t\treturn ath6kl_wmi_connect_event_rx(wmi, datap, len, vif);\n\tcase WMI_DISCONNECT_EVENTID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"WMI_DISCONNECT_EVENTID\\n\");\n\t\treturn ath6kl_wmi_disconnect_event_rx(wmi, datap, len, vif);\n\tcase WMI_TKIP_MICERR_EVENTID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"WMI_TKIP_MICERR_EVENTID\\n\");\n\t\treturn ath6kl_wmi_tkip_micerr_event_rx(wmi, datap, len, vif);\n\tcase WMI_BSSINFO_EVENTID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"WMI_BSSINFO_EVENTID\\n\");\n\t\treturn ath6kl_wmi_bssinfo_event_rx(wmi, datap, len, vif);\n\tcase WMI_NEIGHBOR_REPORT_EVENTID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"WMI_NEIGHBOR_REPORT_EVENTID\\n\");\n\t\treturn ath6kl_wmi_neighbor_report_event_rx(wmi, datap, len,\n\t\t\t\t\t\t\t   vif);\n\tcase WMI_SCAN_COMPLETE_EVENTID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"WMI_SCAN_COMPLETE_EVENTID\\n\");\n\t\treturn ath6kl_wmi_scan_complete_rx(wmi, datap, len, vif);\n\tcase WMI_REPORT_STATISTICS_EVENTID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"WMI_REPORT_STATISTICS_EVENTID\\n\");\n\t\treturn ath6kl_wmi_stats_event_rx(wmi, datap, len, vif);\n\tcase WMI_CAC_EVENTID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"WMI_CAC_EVENTID\\n\");\n\t\treturn ath6kl_wmi_cac_event_rx(wmi, datap, len, vif);\n\tcase WMI_PSPOLL_EVENTID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"WMI_PSPOLL_EVENTID\\n\");\n\t\treturn ath6kl_wmi_pspoll_event_rx(wmi, datap, len, vif);\n\tcase WMI_DTIMEXPIRY_EVENTID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"WMI_DTIMEXPIRY_EVENTID\\n\");\n\t\treturn ath6kl_wmi_dtimexpiry_event_rx(wmi, datap, len, vif);\n\tcase WMI_ADDBA_REQ_EVENTID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"WMI_ADDBA_REQ_EVENTID\\n\");\n\t\treturn ath6kl_wmi_addba_req_event_rx(wmi, datap, len, vif);\n\tcase WMI_DELBA_REQ_EVENTID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"WMI_DELBA_REQ_EVENTID\\n\");\n\t\treturn ath6kl_wmi_delba_req_event_rx(wmi, datap, len, vif);\n\tcase WMI_SET_HOST_SLEEP_MODE_CMD_PROCESSED_EVENTID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t\t   \"WMI_SET_HOST_SLEEP_MODE_CMD_PROCESSED_EVENTID\");\n\t\treturn ath6kl_wmi_host_sleep_mode_cmd_prcd_evt_rx(wmi, vif);\n\tcase WMI_REMAIN_ON_CHNL_EVENTID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"WMI_REMAIN_ON_CHNL_EVENTID\\n\");\n\t\treturn ath6kl_wmi_remain_on_chnl_event_rx(wmi, datap, len, vif);\n\tcase WMI_CANCEL_REMAIN_ON_CHNL_EVENTID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t\t   \"WMI_CANCEL_REMAIN_ON_CHNL_EVENTID\\n\");\n\t\treturn ath6kl_wmi_cancel_remain_on_chnl_event_rx(wmi, datap,\n\t\t\t\t\t\t\t\t len, vif);\n\tcase WMI_TX_STATUS_EVENTID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"WMI_TX_STATUS_EVENTID\\n\");\n\t\treturn ath6kl_wmi_tx_status_event_rx(wmi, datap, len, vif);\n\tcase WMI_RX_PROBE_REQ_EVENTID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"WMI_RX_PROBE_REQ_EVENTID\\n\");\n\t\treturn ath6kl_wmi_rx_probe_req_event_rx(wmi, datap, len, vif);\n\tcase WMI_RX_ACTION_EVENTID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"WMI_RX_ACTION_EVENTID\\n\");\n\t\treturn ath6kl_wmi_rx_action_event_rx(wmi, datap, len, vif);\n\tcase WMI_TXE_NOTIFY_EVENTID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"WMI_TXE_NOTIFY_EVENTID\\n\");\n\t\treturn ath6kl_wmi_txe_notify_event_rx(wmi, datap, len, vif);\n\tdefault:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"unknown cmd id 0x%x\\n\", cmd_id);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath6kl_wmi_proc_events(struct wmi *wmi, struct sk_buff *skb)\n{\n\tstruct wmi_cmd_hdr *cmd;\n\tint ret = 0;\n\tu32 len;\n\tu16 id;\n\tu8 if_idx;\n\tu8 *datap;\n\n\tcmd = (struct wmi_cmd_hdr *) skb->data;\n\tid = le16_to_cpu(cmd->cmd_id);\n\tif_idx = le16_to_cpu(cmd->info1) & WMI_CMD_HDR_IF_ID_MASK;\n\n\tskb_pull(skb, sizeof(struct wmi_cmd_hdr));\n\tdatap = skb->data;\n\tlen = skb->len;\n\n\tath6kl_dbg(ATH6KL_DBG_WMI, \"wmi rx id %d len %d\\n\", id, len);\n\tath6kl_dbg_dump(ATH6KL_DBG_WMI_DUMP, NULL, \"wmi rx \",\n\t\t\tdatap, len);\n\n\tswitch (id) {\n\tcase WMI_GET_BITRATE_CMDID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"WMI_GET_BITRATE_CMDID\\n\");\n\t\tret = ath6kl_wmi_bitrate_reply_rx(wmi, datap, len);\n\t\tbreak;\n\tcase WMI_GET_CHANNEL_LIST_CMDID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"WMI_GET_CHANNEL_LIST_CMDID\\n\");\n\t\tret = ath6kl_wmi_ch_list_reply_rx(wmi, datap, len);\n\t\tbreak;\n\tcase WMI_GET_TX_PWR_CMDID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"WMI_GET_TX_PWR_CMDID\\n\");\n\t\tret = ath6kl_wmi_tx_pwr_reply_rx(wmi, datap, len);\n\t\tbreak;\n\tcase WMI_READY_EVENTID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"WMI_READY_EVENTID\\n\");\n\t\tret = ath6kl_wmi_ready_event_rx(wmi, datap, len);\n\t\tbreak;\n\tcase WMI_PEER_NODE_EVENTID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"WMI_PEER_NODE_EVENTID\\n\");\n\t\tret = ath6kl_wmi_peer_node_event_rx(wmi, datap, len);\n\t\tbreak;\n\tcase WMI_REGDOMAIN_EVENTID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"WMI_REGDOMAIN_EVENTID\\n\");\n\t\tath6kl_wmi_regdomain_event(wmi, datap, len);\n\t\tbreak;\n\tcase WMI_PSTREAM_TIMEOUT_EVENTID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"WMI_PSTREAM_TIMEOUT_EVENTID\\n\");\n\t\tret = ath6kl_wmi_pstream_timeout_event_rx(wmi, datap, len);\n\t\tbreak;\n\tcase WMI_CMDERROR_EVENTID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"WMI_CMDERROR_EVENTID\\n\");\n\t\tret = ath6kl_wmi_error_event_rx(wmi, datap, len);\n\t\tbreak;\n\tcase WMI_RSSI_THRESHOLD_EVENTID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"WMI_RSSI_THRESHOLD_EVENTID\\n\");\n\t\tret = ath6kl_wmi_rssi_threshold_event_rx(wmi, datap, len);\n\t\tbreak;\n\tcase WMI_ERROR_REPORT_EVENTID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"WMI_ERROR_REPORT_EVENTID\\n\");\n\t\tbreak;\n\tcase WMI_OPT_RX_FRAME_EVENTID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"WMI_OPT_RX_FRAME_EVENTID\\n\");\n\t\t \n\t\tbreak;\n\tcase WMI_REPORT_ROAM_TBL_EVENTID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"WMI_REPORT_ROAM_TBL_EVENTID\\n\");\n\t\tret = ath6kl_wmi_roam_tbl_event_rx(wmi, datap, len);\n\t\tbreak;\n\tcase WMI_EXTENSION_EVENTID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"WMI_EXTENSION_EVENTID\\n\");\n\t\tret = ath6kl_wmi_control_rx_xtnd(wmi, skb);\n\t\tbreak;\n\tcase WMI_CHANNEL_CHANGE_EVENTID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"WMI_CHANNEL_CHANGE_EVENTID\\n\");\n\t\tbreak;\n\tcase WMI_REPORT_ROAM_DATA_EVENTID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"WMI_REPORT_ROAM_DATA_EVENTID\\n\");\n\t\tbreak;\n\tcase WMI_TEST_EVENTID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"WMI_TEST_EVENTID\\n\");\n\t\tret = ath6kl_wmi_test_rx(wmi, datap, len);\n\t\tbreak;\n\tcase WMI_GET_FIXRATES_CMDID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"WMI_GET_FIXRATES_CMDID\\n\");\n\t\tret = ath6kl_wmi_ratemask_reply_rx(wmi, datap, len);\n\t\tbreak;\n\tcase WMI_TX_RETRY_ERR_EVENTID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"WMI_TX_RETRY_ERR_EVENTID\\n\");\n\t\tbreak;\n\tcase WMI_SNR_THRESHOLD_EVENTID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"WMI_SNR_THRESHOLD_EVENTID\\n\");\n\t\tret = ath6kl_wmi_snr_threshold_event_rx(wmi, datap, len);\n\t\tbreak;\n\tcase WMI_LQ_THRESHOLD_EVENTID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"WMI_LQ_THRESHOLD_EVENTID\\n\");\n\t\tbreak;\n\tcase WMI_APLIST_EVENTID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"WMI_APLIST_EVENTID\\n\");\n\t\tret = ath6kl_wmi_aplist_event_rx(wmi, datap, len);\n\t\tbreak;\n\tcase WMI_GET_KEEPALIVE_CMDID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"WMI_GET_KEEPALIVE_CMDID\\n\");\n\t\tret = ath6kl_wmi_keepalive_reply_rx(wmi, datap, len);\n\t\tbreak;\n\tcase WMI_GET_WOW_LIST_EVENTID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"WMI_GET_WOW_LIST_EVENTID\\n\");\n\t\tbreak;\n\tcase WMI_GET_PMKID_LIST_EVENTID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"WMI_GET_PMKID_LIST_EVENTID\\n\");\n\t\tret = ath6kl_wmi_get_pmkid_list_event_rx(wmi, datap, len);\n\t\tbreak;\n\tcase WMI_SET_PARAMS_REPLY_EVENTID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"WMI_SET_PARAMS_REPLY_EVENTID\\n\");\n\t\tbreak;\n\tcase WMI_ADDBA_RESP_EVENTID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"WMI_ADDBA_RESP_EVENTID\\n\");\n\t\tbreak;\n\tcase WMI_REPORT_BTCOEX_CONFIG_EVENTID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t\t   \"WMI_REPORT_BTCOEX_CONFIG_EVENTID\\n\");\n\t\tbreak;\n\tcase WMI_REPORT_BTCOEX_STATS_EVENTID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t\t   \"WMI_REPORT_BTCOEX_STATS_EVENTID\\n\");\n\t\tbreak;\n\tcase WMI_TX_COMPLETE_EVENTID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"WMI_TX_COMPLETE_EVENTID\\n\");\n\t\tret = ath6kl_wmi_tx_complete_event_rx(datap, len);\n\t\tbreak;\n\tcase WMI_P2P_CAPABILITIES_EVENTID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"WMI_P2P_CAPABILITIES_EVENTID\\n\");\n\t\tret = ath6kl_wmi_p2p_capabilities_event_rx(datap, len);\n\t\tbreak;\n\tcase WMI_P2P_INFO_EVENTID:\n\t\tath6kl_dbg(ATH6KL_DBG_WMI, \"WMI_P2P_INFO_EVENTID\\n\");\n\t\tret = ath6kl_wmi_p2p_info_event_rx(datap, len);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tret = ath6kl_wmi_proc_events_vif(wmi, if_idx, id, datap, len);\n\t\tbreak;\n\t}\n\n\tdev_kfree_skb(skb);\n\treturn ret;\n}\n\n \nint ath6kl_wmi_control_rx(struct wmi *wmi, struct sk_buff *skb)\n{\n\tif (WARN_ON(skb == NULL))\n\t\treturn -EINVAL;\n\n\tif (skb->len < sizeof(struct wmi_cmd_hdr)) {\n\t\tath6kl_err(\"bad packet 1\\n\");\n\t\tdev_kfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\ttrace_ath6kl_wmi_event(skb->data, skb->len);\n\n\treturn ath6kl_wmi_proc_events(wmi, skb);\n}\n\nvoid ath6kl_wmi_reset(struct wmi *wmi)\n{\n\tspin_lock_bh(&wmi->lock);\n\n\twmi->fat_pipe_exist = 0;\n\tmemset(wmi->stream_exist_for_ac, 0, sizeof(wmi->stream_exist_for_ac));\n\n\tspin_unlock_bh(&wmi->lock);\n}\n\nvoid *ath6kl_wmi_init(struct ath6kl *dev)\n{\n\tstruct wmi *wmi;\n\n\twmi = kzalloc(sizeof(struct wmi), GFP_KERNEL);\n\tif (!wmi)\n\t\treturn NULL;\n\n\tspin_lock_init(&wmi->lock);\n\n\twmi->parent_dev = dev;\n\n\twmi->pwr_mode = REC_POWER;\n\n\tath6kl_wmi_reset(wmi);\n\n\treturn wmi;\n}\n\nvoid ath6kl_wmi_shutdown(struct wmi *wmi)\n{\n\tif (!wmi)\n\t\treturn;\n\n\tkfree(wmi->last_mgmt_tx_frame);\n\tkfree(wmi);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}