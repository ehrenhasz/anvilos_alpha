{
  "module_name": "sdio.c",
  "hash_id": "8677bdba5bb79bbd9752a6273eaefbe7925b49b8815891a736f7a6139c769f09",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath6kl/sdio.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/mmc/card.h>\n#include <linux/mmc/mmc.h>\n#include <linux/mmc/host.h>\n#include <linux/mmc/sdio_func.h>\n#include <linux/mmc/sdio_ids.h>\n#include <linux/mmc/sdio.h>\n#include <linux/mmc/sd.h>\n#include \"hif.h\"\n#include \"hif-ops.h\"\n#include \"target.h\"\n#include \"debug.h\"\n#include \"cfg80211.h\"\n#include \"trace.h\"\n\nstruct ath6kl_sdio {\n\tstruct sdio_func *func;\n\n\t \n\tspinlock_t lock;\n\n\t \n\tstruct list_head bus_req_freeq;\n\n\t \n\tstruct bus_request bus_req[BUS_REQUEST_MAX_NUM];\n\n\tstruct ath6kl *ar;\n\n\tu8 *dma_buffer;\n\n\t \n\tstruct mutex dma_buffer_mutex;\n\n\t \n\tstruct list_head scat_req;\n\n\tatomic_t irq_handling;\n\twait_queue_head_t irq_wq;\n\n\t \n\tspinlock_t scat_lock;\n\n\tbool scatter_enabled;\n\n\tbool is_disabled;\n\tconst struct sdio_device_id *id;\n\tstruct work_struct wr_async_work;\n\tstruct list_head wr_asyncq;\n\n\t \n\tspinlock_t wr_async_lock;\n};\n\n#define CMD53_ARG_READ          0\n#define CMD53_ARG_WRITE         1\n#define CMD53_ARG_BLOCK_BASIS   1\n#define CMD53_ARG_FIXED_ADDRESS 0\n#define CMD53_ARG_INCR_ADDRESS  1\n\nstatic int ath6kl_sdio_config(struct ath6kl *ar);\n\nstatic inline struct ath6kl_sdio *ath6kl_sdio_priv(struct ath6kl *ar)\n{\n\treturn ar->hif_priv;\n}\n\n \nstatic inline bool buf_needs_bounce(u8 *buf)\n{\n\treturn ((unsigned long) buf & 0x3) || !virt_addr_valid(buf);\n}\n\nstatic void ath6kl_sdio_set_mbox_info(struct ath6kl *ar)\n{\n\tstruct ath6kl_mbox_info *mbox_info = &ar->mbox_info;\n\n\t \n\tmbox_info->htc_addr = HIF_MBOX_BASE_ADDR;\n\tmbox_info->htc_ext_addr = HIF_MBOX0_EXT_BASE_ADDR;\n\tmbox_info->htc_ext_sz = HIF_MBOX0_EXT_WIDTH;\n\tmbox_info->block_size = HIF_MBOX_BLOCK_SIZE;\n\tmbox_info->gmbox_addr = HIF_GMBOX_BASE_ADDR;\n\tmbox_info->gmbox_sz = HIF_GMBOX_WIDTH;\n}\n\nstatic inline void ath6kl_sdio_set_cmd53_arg(u32 *arg, u8 rw, u8 func,\n\t\t\t\t\t     u8 mode, u8 opcode, u32 addr,\n\t\t\t\t\t     u16 blksz)\n{\n\t*arg = (((rw & 1) << 31) |\n\t\t((func & 0x7) << 28) |\n\t\t((mode & 1) << 27) |\n\t\t((opcode & 1) << 26) |\n\t\t((addr & 0x1FFFF) << 9) |\n\t\t(blksz & 0x1FF));\n}\n\nstatic inline void ath6kl_sdio_set_cmd52_arg(u32 *arg, u8 write, u8 raw,\n\t\t\t\t\t     unsigned int address,\n\t\t\t\t\t     unsigned char val)\n{\n\tconst u8 func = 0;\n\n\t*arg = ((write & 1) << 31) |\n\t       ((func & 0x7) << 28) |\n\t       ((raw & 1) << 27) |\n\t       (1 << 26) |\n\t       ((address & 0x1FFFF) << 9) |\n\t       (1 << 8) |\n\t       (val & 0xFF);\n}\n\nstatic int ath6kl_sdio_func0_cmd52_wr_byte(struct mmc_card *card,\n\t\t\t\t\t   unsigned int address,\n\t\t\t\t\t   unsigned char byte)\n{\n\tstruct mmc_command io_cmd;\n\n\tmemset(&io_cmd, 0, sizeof(io_cmd));\n\tath6kl_sdio_set_cmd52_arg(&io_cmd.arg, 1, 0, address, byte);\n\tio_cmd.opcode = SD_IO_RW_DIRECT;\n\tio_cmd.flags = MMC_RSP_R5 | MMC_CMD_AC;\n\n\treturn mmc_wait_for_cmd(card->host, &io_cmd, 0);\n}\n\nstatic int ath6kl_sdio_io(struct sdio_func *func, u32 request, u32 addr,\n\t\t\t  u8 *buf, u32 len)\n{\n\tint ret = 0;\n\n\tsdio_claim_host(func);\n\n\tif (request & HIF_WRITE) {\n\t\t \n\t\tif (addr >= HIF_MBOX_BASE_ADDR &&\n\t\t    addr <= HIF_MBOX_END_ADDR)\n\t\t\taddr += (HIF_MBOX_WIDTH - len);\n\n\t\t \n\t\tif (addr == HIF_MBOX0_EXT_BASE_ADDR)\n\t\t\taddr += HIF_MBOX0_EXT_WIDTH - len;\n\n\t\tif (request & HIF_FIXED_ADDRESS)\n\t\t\tret = sdio_writesb(func, addr, buf, len);\n\t\telse\n\t\t\tret = sdio_memcpy_toio(func, addr, buf, len);\n\t} else {\n\t\tif (request & HIF_FIXED_ADDRESS)\n\t\t\tret = sdio_readsb(func, buf, addr, len);\n\t\telse\n\t\t\tret = sdio_memcpy_fromio(func, buf, addr, len);\n\t}\n\n\tsdio_release_host(func);\n\n\tath6kl_dbg(ATH6KL_DBG_SDIO, \"%s addr 0x%x%s buf 0x%p len %d\\n\",\n\t\t   request & HIF_WRITE ? \"wr\" : \"rd\", addr,\n\t\t   request & HIF_FIXED_ADDRESS ? \" (fixed)\" : \"\", buf, len);\n\tath6kl_dbg_dump(ATH6KL_DBG_SDIO_DUMP, NULL, \"sdio \", buf, len);\n\n\ttrace_ath6kl_sdio(addr, request, buf, len);\n\n\treturn ret;\n}\n\nstatic struct bus_request *ath6kl_sdio_alloc_busreq(struct ath6kl_sdio *ar_sdio)\n{\n\tstruct bus_request *bus_req;\n\n\tspin_lock_bh(&ar_sdio->lock);\n\n\tif (list_empty(&ar_sdio->bus_req_freeq)) {\n\t\tspin_unlock_bh(&ar_sdio->lock);\n\t\treturn NULL;\n\t}\n\n\tbus_req = list_first_entry(&ar_sdio->bus_req_freeq,\n\t\t\t\t   struct bus_request, list);\n\tlist_del(&bus_req->list);\n\n\tspin_unlock_bh(&ar_sdio->lock);\n\tath6kl_dbg(ATH6KL_DBG_SCATTER, \"%s: bus request 0x%p\\n\",\n\t\t   __func__, bus_req);\n\n\treturn bus_req;\n}\n\nstatic void ath6kl_sdio_free_bus_req(struct ath6kl_sdio *ar_sdio,\n\t\t\t\t     struct bus_request *bus_req)\n{\n\tath6kl_dbg(ATH6KL_DBG_SCATTER, \"%s: bus request 0x%p\\n\",\n\t\t   __func__, bus_req);\n\n\tspin_lock_bh(&ar_sdio->lock);\n\tlist_add_tail(&bus_req->list, &ar_sdio->bus_req_freeq);\n\tspin_unlock_bh(&ar_sdio->lock);\n}\n\nstatic void ath6kl_sdio_setup_scat_data(struct hif_scatter_req *scat_req,\n\t\t\t\t\tstruct mmc_data *data)\n{\n\tstruct scatterlist *sg;\n\tint i;\n\n\tdata->blksz = HIF_MBOX_BLOCK_SIZE;\n\tdata->blocks = scat_req->len / HIF_MBOX_BLOCK_SIZE;\n\n\tath6kl_dbg(ATH6KL_DBG_SCATTER,\n\t\t   \"hif-scatter: (%s) addr: 0x%X, (block len: %d, block count: %d) , (tot:%d,sg:%d)\\n\",\n\t\t   (scat_req->req & HIF_WRITE) ? \"WR\" : \"RD\", scat_req->addr,\n\t\t   data->blksz, data->blocks, scat_req->len,\n\t\t   scat_req->scat_entries);\n\n\tdata->flags = (scat_req->req & HIF_WRITE) ? MMC_DATA_WRITE :\n\t\t\t\t\t\t    MMC_DATA_READ;\n\n\t \n\tsg = scat_req->sgentries;\n\tsg_init_table(sg, scat_req->scat_entries);\n\n\t \n\tfor (i = 0; i < scat_req->scat_entries; i++, sg++) {\n\t\tath6kl_dbg(ATH6KL_DBG_SCATTER, \"%d: addr:0x%p, len:%d\\n\",\n\t\t\t   i, scat_req->scat_list[i].buf,\n\t\t\t   scat_req->scat_list[i].len);\n\n\t\tsg_set_buf(sg, scat_req->scat_list[i].buf,\n\t\t\t   scat_req->scat_list[i].len);\n\t}\n\n\t \n\tdata->sg = scat_req->sgentries;\n\tdata->sg_len = scat_req->scat_entries;\n}\n\nstatic int ath6kl_sdio_scat_rw(struct ath6kl_sdio *ar_sdio,\n\t\t\t       struct bus_request *req)\n{\n\tstruct mmc_request mmc_req;\n\tstruct mmc_command cmd;\n\tstruct mmc_data data;\n\tstruct hif_scatter_req *scat_req;\n\tu8 opcode, rw;\n\tint status, len;\n\n\tscat_req = req->scat_req;\n\n\tif (scat_req->virt_scat) {\n\t\tlen = scat_req->len;\n\t\tif (scat_req->req & HIF_BLOCK_BASIS)\n\t\t\tlen = round_down(len, HIF_MBOX_BLOCK_SIZE);\n\n\t\tstatus = ath6kl_sdio_io(ar_sdio->func, scat_req->req,\n\t\t\t\t\tscat_req->addr, scat_req->virt_dma_buf,\n\t\t\t\t\tlen);\n\t\tgoto scat_complete;\n\t}\n\n\tmemset(&mmc_req, 0, sizeof(struct mmc_request));\n\tmemset(&cmd, 0, sizeof(struct mmc_command));\n\tmemset(&data, 0, sizeof(struct mmc_data));\n\n\tath6kl_sdio_setup_scat_data(scat_req, &data);\n\n\topcode = (scat_req->req & HIF_FIXED_ADDRESS) ?\n\t\t  CMD53_ARG_FIXED_ADDRESS : CMD53_ARG_INCR_ADDRESS;\n\n\trw = (scat_req->req & HIF_WRITE) ? CMD53_ARG_WRITE : CMD53_ARG_READ;\n\n\t \n\tif (scat_req->req & HIF_WRITE) {\n\t\tif (scat_req->addr == HIF_MBOX_BASE_ADDR)\n\t\t\tscat_req->addr += HIF_MBOX_WIDTH - scat_req->len;\n\t\telse\n\t\t\t \n\t\t\tscat_req->addr += HIF_MBOX0_EXT_WIDTH - scat_req->len;\n\t}\n\n\t \n\tath6kl_sdio_set_cmd53_arg(&cmd.arg, rw, ar_sdio->func->num,\n\t\t\t\t  CMD53_ARG_BLOCK_BASIS, opcode, scat_req->addr,\n\t\t\t\t  data.blocks);\n\n\tcmd.opcode = SD_IO_RW_EXTENDED;\n\tcmd.flags = MMC_RSP_SPI_R5 | MMC_RSP_R5 | MMC_CMD_ADTC;\n\n\tmmc_req.cmd = &cmd;\n\tmmc_req.data = &data;\n\n\tsdio_claim_host(ar_sdio->func);\n\n\tmmc_set_data_timeout(&data, ar_sdio->func->card);\n\n\ttrace_ath6kl_sdio_scat(scat_req->addr,\n\t\t\t       scat_req->req,\n\t\t\t       scat_req->len,\n\t\t\t       scat_req->scat_entries,\n\t\t\t       scat_req->scat_list);\n\n\t \n\tmmc_wait_for_req(ar_sdio->func->card->host, &mmc_req);\n\n\tsdio_release_host(ar_sdio->func);\n\n\tstatus = cmd.error ? cmd.error : data.error;\n\nscat_complete:\n\tscat_req->status = status;\n\n\tif (scat_req->status)\n\t\tath6kl_err(\"Scatter write request failed:%d\\n\",\n\t\t\t   scat_req->status);\n\n\tif (scat_req->req & HIF_ASYNCHRONOUS)\n\t\tscat_req->complete(ar_sdio->ar->htc_target, scat_req);\n\n\treturn status;\n}\n\nstatic int ath6kl_sdio_alloc_prep_scat_req(struct ath6kl_sdio *ar_sdio,\n\t\t\t\t\t   int n_scat_entry, int n_scat_req,\n\t\t\t\t\t   bool virt_scat)\n{\n\tstruct hif_scatter_req *s_req;\n\tstruct bus_request *bus_req;\n\tint i, scat_req_sz, scat_list_sz, size;\n\tu8 *virt_buf;\n\n\tscat_list_sz = n_scat_entry * sizeof(struct hif_scatter_item);\n\tscat_req_sz = sizeof(*s_req) + scat_list_sz;\n\n\tif (!virt_scat)\n\t\tsize = sizeof(struct scatterlist) * n_scat_entry;\n\telse\n\t\tsize =  2 * L1_CACHE_BYTES +\n\t\t\tATH6KL_MAX_TRANSFER_SIZE_PER_SCATTER;\n\n\tfor (i = 0; i < n_scat_req; i++) {\n\t\t \n\t\ts_req = kzalloc(scat_req_sz, GFP_KERNEL);\n\t\tif (!s_req)\n\t\t\treturn -ENOMEM;\n\n\t\tif (virt_scat) {\n\t\t\tvirt_buf = kzalloc(size, GFP_KERNEL);\n\t\t\tif (!virt_buf) {\n\t\t\t\tkfree(s_req);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\ts_req->virt_dma_buf =\n\t\t\t\t(u8 *)L1_CACHE_ALIGN((unsigned long)virt_buf);\n\t\t} else {\n\t\t\t \n\t\t\ts_req->sgentries = kzalloc(size, GFP_KERNEL);\n\n\t\t\tif (!s_req->sgentries) {\n\t\t\t\tkfree(s_req);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tbus_req = ath6kl_sdio_alloc_busreq(ar_sdio);\n\t\tif (!bus_req) {\n\t\t\tkfree(s_req->sgentries);\n\t\t\tkfree(s_req->virt_dma_buf);\n\t\t\tkfree(s_req);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\t \n\t\tbus_req->scat_req = s_req;\n\t\ts_req->busrequest = bus_req;\n\n\t\ts_req->virt_scat = virt_scat;\n\n\t\t \n\t\thif_scatter_req_add(ar_sdio->ar, s_req);\n\t}\n\n\treturn 0;\n}\n\nstatic int ath6kl_sdio_read_write_sync(struct ath6kl *ar, u32 addr, u8 *buf,\n\t\t\t\t       u32 len, u32 request)\n{\n\tstruct ath6kl_sdio *ar_sdio = ath6kl_sdio_priv(ar);\n\tu8  *tbuf = NULL;\n\tint ret;\n\tbool bounced = false;\n\n\tif (request & HIF_BLOCK_BASIS)\n\t\tlen = round_down(len, HIF_MBOX_BLOCK_SIZE);\n\n\tif (buf_needs_bounce(buf)) {\n\t\tif (!ar_sdio->dma_buffer)\n\t\t\treturn -ENOMEM;\n\t\tmutex_lock(&ar_sdio->dma_buffer_mutex);\n\t\ttbuf = ar_sdio->dma_buffer;\n\n\t\tif (request & HIF_WRITE)\n\t\t\tmemcpy(tbuf, buf, len);\n\n\t\tbounced = true;\n\t} else {\n\t\ttbuf = buf;\n\t}\n\n\tret = ath6kl_sdio_io(ar_sdio->func, request, addr, tbuf, len);\n\tif ((request & HIF_READ) && bounced)\n\t\tmemcpy(buf, tbuf, len);\n\n\tif (bounced)\n\t\tmutex_unlock(&ar_sdio->dma_buffer_mutex);\n\n\treturn ret;\n}\n\nstatic void __ath6kl_sdio_write_async(struct ath6kl_sdio *ar_sdio,\n\t\t\t\t      struct bus_request *req)\n{\n\tif (req->scat_req) {\n\t\tath6kl_sdio_scat_rw(ar_sdio, req);\n\t} else {\n\t\tvoid *context;\n\t\tint status;\n\n\t\tstatus = ath6kl_sdio_read_write_sync(ar_sdio->ar, req->address,\n\t\t\t\t\t\t     req->buffer, req->length,\n\t\t\t\t\t\t     req->request);\n\t\tcontext = req->packet;\n\t\tath6kl_sdio_free_bus_req(ar_sdio, req);\n\t\tath6kl_hif_rw_comp_handler(context, status);\n\t}\n}\n\nstatic void ath6kl_sdio_write_async_work(struct work_struct *work)\n{\n\tstruct ath6kl_sdio *ar_sdio;\n\tstruct bus_request *req, *tmp_req;\n\n\tar_sdio = container_of(work, struct ath6kl_sdio, wr_async_work);\n\n\tspin_lock_bh(&ar_sdio->wr_async_lock);\n\tlist_for_each_entry_safe(req, tmp_req, &ar_sdio->wr_asyncq, list) {\n\t\tlist_del(&req->list);\n\t\tspin_unlock_bh(&ar_sdio->wr_async_lock);\n\t\t__ath6kl_sdio_write_async(ar_sdio, req);\n\t\tspin_lock_bh(&ar_sdio->wr_async_lock);\n\t}\n\tspin_unlock_bh(&ar_sdio->wr_async_lock);\n}\n\nstatic void ath6kl_sdio_irq_handler(struct sdio_func *func)\n{\n\tint status;\n\tstruct ath6kl_sdio *ar_sdio;\n\n\tath6kl_dbg(ATH6KL_DBG_SDIO, \"irq\\n\");\n\n\tar_sdio = sdio_get_drvdata(func);\n\tatomic_set(&ar_sdio->irq_handling, 1);\n\t \n\tsdio_release_host(ar_sdio->func);\n\n\tstatus = ath6kl_hif_intr_bh_handler(ar_sdio->ar);\n\tsdio_claim_host(ar_sdio->func);\n\n\tatomic_set(&ar_sdio->irq_handling, 0);\n\twake_up(&ar_sdio->irq_wq);\n\n\tWARN_ON(status && status != -ECANCELED);\n}\n\nstatic int ath6kl_sdio_power_on(struct ath6kl *ar)\n{\n\tstruct ath6kl_sdio *ar_sdio = ath6kl_sdio_priv(ar);\n\tstruct sdio_func *func = ar_sdio->func;\n\tint ret = 0;\n\n\tif (!ar_sdio->is_disabled)\n\t\treturn 0;\n\n\tath6kl_dbg(ATH6KL_DBG_BOOT, \"sdio power on\\n\");\n\n\tsdio_claim_host(func);\n\n\tret = sdio_enable_func(func);\n\tif (ret) {\n\t\tath6kl_err(\"Unable to enable sdio func: %d)\\n\", ret);\n\t\tsdio_release_host(func);\n\t\treturn ret;\n\t}\n\n\tsdio_release_host(func);\n\n\t \n\tmsleep(10);\n\n\tret = ath6kl_sdio_config(ar);\n\tif (ret) {\n\t\tath6kl_err(\"Failed to config sdio: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tar_sdio->is_disabled = false;\n\nout:\n\treturn ret;\n}\n\nstatic int ath6kl_sdio_power_off(struct ath6kl *ar)\n{\n\tstruct ath6kl_sdio *ar_sdio = ath6kl_sdio_priv(ar);\n\tint ret;\n\n\tif (ar_sdio->is_disabled)\n\t\treturn 0;\n\n\tath6kl_dbg(ATH6KL_DBG_BOOT, \"sdio power off\\n\");\n\n\t \n\tsdio_claim_host(ar_sdio->func);\n\tret = sdio_disable_func(ar_sdio->func);\n\tsdio_release_host(ar_sdio->func);\n\n\tif (ret)\n\t\treturn ret;\n\n\tar_sdio->is_disabled = true;\n\n\treturn ret;\n}\n\nstatic int ath6kl_sdio_write_async(struct ath6kl *ar, u32 address, u8 *buffer,\n\t\t\t\t   u32 length, u32 request,\n\t\t\t\t   struct htc_packet *packet)\n{\n\tstruct ath6kl_sdio *ar_sdio = ath6kl_sdio_priv(ar);\n\tstruct bus_request *bus_req;\n\n\tbus_req = ath6kl_sdio_alloc_busreq(ar_sdio);\n\n\tif (WARN_ON_ONCE(!bus_req))\n\t\treturn -ENOMEM;\n\n\tbus_req->address = address;\n\tbus_req->buffer = buffer;\n\tbus_req->length = length;\n\tbus_req->request = request;\n\tbus_req->packet = packet;\n\n\tspin_lock_bh(&ar_sdio->wr_async_lock);\n\tlist_add_tail(&bus_req->list, &ar_sdio->wr_asyncq);\n\tspin_unlock_bh(&ar_sdio->wr_async_lock);\n\tqueue_work(ar->ath6kl_wq, &ar_sdio->wr_async_work);\n\n\treturn 0;\n}\n\nstatic void ath6kl_sdio_irq_enable(struct ath6kl *ar)\n{\n\tstruct ath6kl_sdio *ar_sdio = ath6kl_sdio_priv(ar);\n\tint ret;\n\n\tsdio_claim_host(ar_sdio->func);\n\n\t \n\tret =  sdio_claim_irq(ar_sdio->func, ath6kl_sdio_irq_handler);\n\tif (ret)\n\t\tath6kl_err(\"Failed to claim sdio irq: %d\\n\", ret);\n\n\tsdio_release_host(ar_sdio->func);\n}\n\nstatic bool ath6kl_sdio_is_on_irq(struct ath6kl *ar)\n{\n\tstruct ath6kl_sdio *ar_sdio = ath6kl_sdio_priv(ar);\n\n\treturn !atomic_read(&ar_sdio->irq_handling);\n}\n\nstatic void ath6kl_sdio_irq_disable(struct ath6kl *ar)\n{\n\tstruct ath6kl_sdio *ar_sdio = ath6kl_sdio_priv(ar);\n\tint ret;\n\n\tsdio_claim_host(ar_sdio->func);\n\n\tif (atomic_read(&ar_sdio->irq_handling)) {\n\t\tsdio_release_host(ar_sdio->func);\n\n\t\tret = wait_event_interruptible(ar_sdio->irq_wq,\n\t\t\t\t\t       ath6kl_sdio_is_on_irq(ar));\n\t\tif (ret)\n\t\t\treturn;\n\n\t\tsdio_claim_host(ar_sdio->func);\n\t}\n\n\tret = sdio_release_irq(ar_sdio->func);\n\tif (ret)\n\t\tath6kl_err(\"Failed to release sdio irq: %d\\n\", ret);\n\n\tsdio_release_host(ar_sdio->func);\n}\n\nstatic struct hif_scatter_req *ath6kl_sdio_scatter_req_get(struct ath6kl *ar)\n{\n\tstruct ath6kl_sdio *ar_sdio = ath6kl_sdio_priv(ar);\n\tstruct hif_scatter_req *node = NULL;\n\n\tspin_lock_bh(&ar_sdio->scat_lock);\n\n\tif (!list_empty(&ar_sdio->scat_req)) {\n\t\tnode = list_first_entry(&ar_sdio->scat_req,\n\t\t\t\t\tstruct hif_scatter_req, list);\n\t\tlist_del(&node->list);\n\n\t\tnode->scat_q_depth = get_queue_depth(&ar_sdio->scat_req);\n\t}\n\n\tspin_unlock_bh(&ar_sdio->scat_lock);\n\n\treturn node;\n}\n\nstatic void ath6kl_sdio_scatter_req_add(struct ath6kl *ar,\n\t\t\t\t\tstruct hif_scatter_req *s_req)\n{\n\tstruct ath6kl_sdio *ar_sdio = ath6kl_sdio_priv(ar);\n\n\tspin_lock_bh(&ar_sdio->scat_lock);\n\n\tlist_add_tail(&s_req->list, &ar_sdio->scat_req);\n\n\tspin_unlock_bh(&ar_sdio->scat_lock);\n}\n\n \nstatic int ath6kl_sdio_async_rw_scatter(struct ath6kl *ar,\n\t\t\t\t\tstruct hif_scatter_req *scat_req)\n{\n\tstruct ath6kl_sdio *ar_sdio = ath6kl_sdio_priv(ar);\n\tu32 request = scat_req->req;\n\tint status = 0;\n\n\tif (!scat_req->len)\n\t\treturn -EINVAL;\n\n\tath6kl_dbg(ATH6KL_DBG_SCATTER,\n\t\t   \"hif-scatter: total len: %d scatter entries: %d\\n\",\n\t\t   scat_req->len, scat_req->scat_entries);\n\n\tif (request & HIF_SYNCHRONOUS) {\n\t\tstatus = ath6kl_sdio_scat_rw(ar_sdio, scat_req->busrequest);\n\t} else {\n\t\tspin_lock_bh(&ar_sdio->wr_async_lock);\n\t\tlist_add_tail(&scat_req->busrequest->list, &ar_sdio->wr_asyncq);\n\t\tspin_unlock_bh(&ar_sdio->wr_async_lock);\n\t\tqueue_work(ar->ath6kl_wq, &ar_sdio->wr_async_work);\n\t}\n\n\treturn status;\n}\n\n \nstatic void ath6kl_sdio_cleanup_scatter(struct ath6kl *ar)\n{\n\tstruct ath6kl_sdio *ar_sdio = ath6kl_sdio_priv(ar);\n\tstruct hif_scatter_req *s_req, *tmp_req;\n\n\t \n\tspin_lock_bh(&ar_sdio->scat_lock);\n\tlist_for_each_entry_safe(s_req, tmp_req, &ar_sdio->scat_req, list) {\n\t\tlist_del(&s_req->list);\n\t\tspin_unlock_bh(&ar_sdio->scat_lock);\n\n\t\t \n\t\tif (s_req->busrequest) {\n\t\t\ts_req->busrequest->scat_req = NULL;\n\t\t\tath6kl_sdio_free_bus_req(ar_sdio, s_req->busrequest);\n\t\t}\n\t\tkfree(s_req->virt_dma_buf);\n\t\tkfree(s_req->sgentries);\n\t\tkfree(s_req);\n\n\t\tspin_lock_bh(&ar_sdio->scat_lock);\n\t}\n\tspin_unlock_bh(&ar_sdio->scat_lock);\n\n\tar_sdio->scatter_enabled = false;\n}\n\n \nstatic int ath6kl_sdio_enable_scatter(struct ath6kl *ar)\n{\n\tstruct ath6kl_sdio *ar_sdio = ath6kl_sdio_priv(ar);\n\tstruct htc_target *target = ar->htc_target;\n\tint ret = 0;\n\tbool virt_scat = false;\n\n\tif (ar_sdio->scatter_enabled)\n\t\treturn 0;\n\n\tar_sdio->scatter_enabled = true;\n\n\t \n\tif (ar_sdio->func->card->host->max_segs < MAX_SCATTER_ENTRIES_PER_REQ) {\n\t\tath6kl_err(\"host only supports scatter of :%d entries, need: %d\\n\",\n\t\t\t   ar_sdio->func->card->host->max_segs,\n\t\t\t   MAX_SCATTER_ENTRIES_PER_REQ);\n\t\tvirt_scat = true;\n\t}\n\n\tif (!virt_scat) {\n\t\tret = ath6kl_sdio_alloc_prep_scat_req(ar_sdio,\n\t\t\t\tMAX_SCATTER_ENTRIES_PER_REQ,\n\t\t\t\tMAX_SCATTER_REQUESTS, virt_scat);\n\n\t\tif (!ret) {\n\t\t\tath6kl_dbg(ATH6KL_DBG_BOOT,\n\t\t\t\t   \"hif-scatter enabled requests %d entries %d\\n\",\n\t\t\t\t   MAX_SCATTER_REQUESTS,\n\t\t\t\t   MAX_SCATTER_ENTRIES_PER_REQ);\n\n\t\t\ttarget->max_scat_entries = MAX_SCATTER_ENTRIES_PER_REQ;\n\t\t\ttarget->max_xfer_szper_scatreq =\n\t\t\t\t\t\tMAX_SCATTER_REQ_TRANSFER_SIZE;\n\t\t} else {\n\t\t\tath6kl_sdio_cleanup_scatter(ar);\n\t\t\tath6kl_warn(\"hif scatter resource setup failed, trying virtual scatter method\\n\");\n\t\t}\n\t}\n\n\tif (virt_scat || ret) {\n\t\tret = ath6kl_sdio_alloc_prep_scat_req(ar_sdio,\n\t\t\t\tATH6KL_SCATTER_ENTRIES_PER_REQ,\n\t\t\t\tATH6KL_SCATTER_REQS, virt_scat);\n\n\t\tif (ret) {\n\t\t\tath6kl_err(\"failed to alloc virtual scatter resources !\\n\");\n\t\t\tath6kl_sdio_cleanup_scatter(ar);\n\t\t\treturn ret;\n\t\t}\n\n\t\tath6kl_dbg(ATH6KL_DBG_BOOT,\n\t\t\t   \"virtual scatter enabled requests %d entries %d\\n\",\n\t\t\t   ATH6KL_SCATTER_REQS, ATH6KL_SCATTER_ENTRIES_PER_REQ);\n\n\t\ttarget->max_scat_entries = ATH6KL_SCATTER_ENTRIES_PER_REQ;\n\t\ttarget->max_xfer_szper_scatreq =\n\t\t\t\t\tATH6KL_MAX_TRANSFER_SIZE_PER_SCATTER;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath6kl_sdio_config(struct ath6kl *ar)\n{\n\tstruct ath6kl_sdio *ar_sdio = ath6kl_sdio_priv(ar);\n\tstruct sdio_func *func = ar_sdio->func;\n\tint ret;\n\n\tsdio_claim_host(func);\n\n\tif (ar_sdio->id->device >= SDIO_DEVICE_ID_ATHEROS_AR6003_00) {\n\t\t \n\t\tret = ath6kl_sdio_func0_cmd52_wr_byte(func->card,\n\t\t\t\t\t\tCCCR_SDIO_IRQ_MODE_REG,\n\t\t\t\t\t\tSDIO_IRQ_MODE_ASYNC_4BIT_IRQ);\n\t\tif (ret) {\n\t\t\tath6kl_err(\"Failed to enable 4-bit async irq mode %d\\n\",\n\t\t\t\t   ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tath6kl_dbg(ATH6KL_DBG_BOOT, \"4-bit async irq mode enabled\\n\");\n\t}\n\n\t \n\tfunc->enable_timeout = 100;\n\n\tret = sdio_set_block_size(func, HIF_MBOX_BLOCK_SIZE);\n\tif (ret) {\n\t\tath6kl_err(\"Set sdio block size %d failed: %d)\\n\",\n\t\t\t   HIF_MBOX_BLOCK_SIZE, ret);\n\t\tgoto out;\n\t}\n\nout:\n\tsdio_release_host(func);\n\n\treturn ret;\n}\n\nstatic int ath6kl_set_sdio_pm_caps(struct ath6kl *ar)\n{\n\tstruct ath6kl_sdio *ar_sdio = ath6kl_sdio_priv(ar);\n\tstruct sdio_func *func = ar_sdio->func;\n\tmmc_pm_flag_t flags;\n\tint ret;\n\n\tflags = sdio_get_host_pm_caps(func);\n\n\tath6kl_dbg(ATH6KL_DBG_SUSPEND, \"sdio suspend pm_caps 0x%x\\n\", flags);\n\n\tif (!(flags & MMC_PM_WAKE_SDIO_IRQ) ||\n\t    !(flags & MMC_PM_KEEP_POWER))\n\t\treturn -EINVAL;\n\n\tret = sdio_set_host_pm_flags(func, MMC_PM_KEEP_POWER);\n\tif (ret) {\n\t\tath6kl_err(\"set sdio keep pwr flag failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = sdio_set_host_pm_flags(func, MMC_PM_WAKE_SDIO_IRQ);\n\tif (ret)\n\t\tath6kl_err(\"set sdio wake irq flag failed: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int ath6kl_sdio_suspend(struct ath6kl *ar, struct cfg80211_wowlan *wow)\n{\n\tstruct ath6kl_sdio *ar_sdio = ath6kl_sdio_priv(ar);\n\tstruct sdio_func *func = ar_sdio->func;\n\tmmc_pm_flag_t flags;\n\tbool try_deepsleep = false;\n\tint ret;\n\n\tif (ar->suspend_mode == WLAN_POWER_STATE_WOW ||\n\t    (!ar->suspend_mode && wow)) {\n\t\tret = ath6kl_set_sdio_pm_caps(ar);\n\t\tif (ret)\n\t\t\tgoto cut_pwr;\n\n\t\tret = ath6kl_cfg80211_suspend(ar, ATH6KL_CFG_SUSPEND_WOW, wow);\n\t\tif (ret && ret != -ENOTCONN)\n\t\t\tath6kl_err(\"wow suspend failed: %d\\n\", ret);\n\n\t\tif (ret &&\n\t\t    (!ar->wow_suspend_mode ||\n\t\t     ar->wow_suspend_mode == WLAN_POWER_STATE_DEEP_SLEEP))\n\t\t\ttry_deepsleep = true;\n\t\telse if (ret &&\n\t\t\t ar->wow_suspend_mode == WLAN_POWER_STATE_CUT_PWR)\n\t\t\tgoto cut_pwr;\n\t\tif (!ret)\n\t\t\treturn 0;\n\t}\n\n\tif (ar->suspend_mode == WLAN_POWER_STATE_DEEP_SLEEP ||\n\t    !ar->suspend_mode || try_deepsleep) {\n\t\tflags = sdio_get_host_pm_caps(func);\n\t\tif (!(flags & MMC_PM_KEEP_POWER))\n\t\t\tgoto cut_pwr;\n\n\t\tret = sdio_set_host_pm_flags(func, MMC_PM_KEEP_POWER);\n\t\tif (ret)\n\t\t\tgoto cut_pwr;\n\n\t\t \n\t\tif ((flags & MMC_PM_WAKE_SDIO_IRQ)) {\n\t\t\tret = sdio_set_host_pm_flags(func,\n\t\t\t\t\t\tMMC_PM_WAKE_SDIO_IRQ);\n\t\t\tif (ret)\n\t\t\t\tgoto cut_pwr;\n\t\t}\n\n\t\tret = ath6kl_cfg80211_suspend(ar, ATH6KL_CFG_SUSPEND_DEEPSLEEP,\n\t\t\t\t\t      NULL);\n\t\tif (ret)\n\t\t\tgoto cut_pwr;\n\n\t\treturn 0;\n\t}\n\ncut_pwr:\n\tif (func->card && func->card->host)\n\t\tfunc->card->host->pm_flags &= ~MMC_PM_KEEP_POWER;\n\n\treturn ath6kl_cfg80211_suspend(ar, ATH6KL_CFG_SUSPEND_CUTPOWER, NULL);\n}\n\nstatic int ath6kl_sdio_resume(struct ath6kl *ar)\n{\n\tswitch (ar->state) {\n\tcase ATH6KL_STATE_OFF:\n\tcase ATH6KL_STATE_CUTPOWER:\n\t\tath6kl_dbg(ATH6KL_DBG_SUSPEND,\n\t\t\t   \"sdio resume configuring sdio\\n\");\n\n\t\t \n\t\tath6kl_sdio_config(ar);\n\t\tbreak;\n\n\tcase ATH6KL_STATE_ON:\n\t\tbreak;\n\n\tcase ATH6KL_STATE_DEEPSLEEP:\n\t\tbreak;\n\n\tcase ATH6KL_STATE_WOW:\n\t\tbreak;\n\n\tcase ATH6KL_STATE_SUSPENDING:\n\t\tbreak;\n\n\tcase ATH6KL_STATE_RESUMING:\n\t\tbreak;\n\n\tcase ATH6KL_STATE_RECOVERY:\n\t\tbreak;\n\t}\n\n\tath6kl_cfg80211_resume(ar);\n\n\treturn 0;\n}\n\n \nstatic int ath6kl_set_addrwin_reg(struct ath6kl *ar, u32 reg_addr, u32 addr)\n{\n\tint status;\n\tu8 addr_val[4];\n\ts32 i;\n\n\t \n\n\tfor (i = 1; i <= 3; i++) {\n\t\t \n\t\tmemset(addr_val, ((u8 *)&addr)[i], 4);\n\n\t\t \n\t\tstatus = ath6kl_sdio_read_write_sync(ar, reg_addr + i, addr_val,\n\t\t\t\t\t     4, HIF_WR_SYNC_BYTE_FIX);\n\t\tif (status)\n\t\t\tbreak;\n\t}\n\n\tif (status) {\n\t\tath6kl_err(\"%s: failed to write initial bytes of 0x%x to window reg: 0x%X\\n\",\n\t\t\t   __func__, addr, reg_addr);\n\t\treturn status;\n\t}\n\n\t \n\tstatus = ath6kl_sdio_read_write_sync(ar, reg_addr, (u8 *)(&addr),\n\t\t\t\t     4, HIF_WR_SYNC_BYTE_INC);\n\n\tif (status) {\n\t\tath6kl_err(\"%s: failed to write 0x%x to window reg: 0x%X\\n\",\n\t\t\t   __func__, addr, reg_addr);\n\t\treturn status;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath6kl_sdio_diag_read32(struct ath6kl *ar, u32 address, u32 *data)\n{\n\tint status;\n\n\t \n\tstatus = ath6kl_set_addrwin_reg(ar, WINDOW_READ_ADDR_ADDRESS,\n\t\t\t\t\taddress);\n\n\tif (status)\n\t\treturn status;\n\n\t \n\tstatus = ath6kl_sdio_read_write_sync(ar, WINDOW_DATA_ADDRESS,\n\t\t\t\t(u8 *)data, sizeof(u32), HIF_RD_SYNC_BYTE_INC);\n\tif (status) {\n\t\tath6kl_err(\"%s: failed to read from window data addr\\n\",\n\t\t\t   __func__);\n\t\treturn status;\n\t}\n\n\treturn status;\n}\n\nstatic int ath6kl_sdio_diag_write32(struct ath6kl *ar, u32 address,\n\t\t\t\t    __le32 data)\n{\n\tint status;\n\tu32 val = (__force u32) data;\n\n\t \n\tstatus = ath6kl_sdio_read_write_sync(ar, WINDOW_DATA_ADDRESS,\n\t\t\t\t(u8 *) &val, sizeof(u32), HIF_WR_SYNC_BYTE_INC);\n\tif (status) {\n\t\tath6kl_err(\"%s: failed to write 0x%x to window data addr\\n\",\n\t\t\t   __func__, data);\n\t\treturn status;\n\t}\n\n\t \n\treturn ath6kl_set_addrwin_reg(ar, WINDOW_WRITE_ADDR_ADDRESS,\n\t\t\t\t      address);\n}\n\nstatic int ath6kl_sdio_bmi_credits(struct ath6kl *ar)\n{\n\tu32 addr;\n\tunsigned long timeout;\n\tint ret;\n\n\tar->bmi.cmd_credits = 0;\n\n\t \n\taddr = COUNT_DEC_ADDRESS + (HTC_MAILBOX_NUM_MAX + ENDPOINT1) * 4;\n\n\ttimeout = jiffies + msecs_to_jiffies(BMI_COMMUNICATION_TIMEOUT);\n\twhile (time_before(jiffies, timeout) && !ar->bmi.cmd_credits) {\n\t\t \n\t\tret = ath6kl_sdio_read_write_sync(ar, addr,\n\t\t\t\t\t (u8 *)&ar->bmi.cmd_credits, 4,\n\t\t\t\t\t HIF_RD_SYNC_BYTE_INC);\n\t\tif (ret) {\n\t\t\tath6kl_err(\"Unable to decrement the command credit count register: %d\\n\",\n\t\t\t\t   ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tar->bmi.cmd_credits &= 0xFF;\n\t}\n\n\tif (!ar->bmi.cmd_credits) {\n\t\tath6kl_err(\"bmi communication timeout\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath6kl_bmi_get_rx_lkahd(struct ath6kl *ar)\n{\n\tunsigned long timeout;\n\tu32 rx_word = 0;\n\tint ret = 0;\n\n\ttimeout = jiffies + msecs_to_jiffies(BMI_COMMUNICATION_TIMEOUT);\n\twhile ((time_before(jiffies, timeout)) && !rx_word) {\n\t\tret = ath6kl_sdio_read_write_sync(ar,\n\t\t\t\t\tRX_LOOKAHEAD_VALID_ADDRESS,\n\t\t\t\t\t(u8 *)&rx_word, sizeof(rx_word),\n\t\t\t\t\tHIF_RD_SYNC_BYTE_INC);\n\t\tif (ret) {\n\t\t\tath6kl_err(\"unable to read RX_LOOKAHEAD_VALID\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t  \n\t\trx_word &= (1 << ENDPOINT1);\n\t}\n\n\tif (!rx_word) {\n\t\tath6kl_err(\"bmi_recv_buf FIFO empty\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int ath6kl_sdio_bmi_write(struct ath6kl *ar, u8 *buf, u32 len)\n{\n\tint ret;\n\tu32 addr;\n\n\tret = ath6kl_sdio_bmi_credits(ar);\n\tif (ret)\n\t\treturn ret;\n\n\taddr = ar->mbox_info.htc_addr;\n\n\tret = ath6kl_sdio_read_write_sync(ar, addr, buf, len,\n\t\t\t\t\t  HIF_WR_SYNC_BYTE_INC);\n\tif (ret) {\n\t\tath6kl_err(\"unable to send the bmi data to the device\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath6kl_sdio_bmi_read(struct ath6kl *ar, u8 *buf, u32 len)\n{\n\tint ret;\n\tu32 addr;\n\n\t \n\tif (len >= 4) {  \n\t\tret = ath6kl_bmi_get_rx_lkahd(ar);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\taddr = ar->mbox_info.htc_addr;\n\tret = ath6kl_sdio_read_write_sync(ar, addr, buf, len,\n\t\t\t\t  HIF_RD_SYNC_BYTE_INC);\n\tif (ret) {\n\t\tath6kl_err(\"Unable to read the bmi data from the device: %d\\n\",\n\t\t\t   ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void ath6kl_sdio_stop(struct ath6kl *ar)\n{\n\tstruct ath6kl_sdio *ar_sdio = ath6kl_sdio_priv(ar);\n\tstruct bus_request *req, *tmp_req;\n\tvoid *context;\n\n\t \n\n\tcancel_work_sync(&ar_sdio->wr_async_work);\n\n\tspin_lock_bh(&ar_sdio->wr_async_lock);\n\n\tlist_for_each_entry_safe(req, tmp_req, &ar_sdio->wr_asyncq, list) {\n\t\tlist_del(&req->list);\n\n\t\tif (req->scat_req) {\n\t\t\t \n\t\t\treq->scat_req->status = -ECANCELED;\n\t\t\treq->scat_req->complete(ar_sdio->ar->htc_target,\n\t\t\t\t\t\treq->scat_req);\n\t\t} else {\n\t\t\tcontext = req->packet;\n\t\t\tath6kl_sdio_free_bus_req(ar_sdio, req);\n\t\t\tath6kl_hif_rw_comp_handler(context, -ECANCELED);\n\t\t}\n\t}\n\n\tspin_unlock_bh(&ar_sdio->wr_async_lock);\n\n\tWARN_ON(get_queue_depth(&ar_sdio->scat_req) != 4);\n}\n\nstatic const struct ath6kl_hif_ops ath6kl_sdio_ops = {\n\t.read_write_sync = ath6kl_sdio_read_write_sync,\n\t.write_async = ath6kl_sdio_write_async,\n\t.irq_enable = ath6kl_sdio_irq_enable,\n\t.irq_disable = ath6kl_sdio_irq_disable,\n\t.scatter_req_get = ath6kl_sdio_scatter_req_get,\n\t.scatter_req_add = ath6kl_sdio_scatter_req_add,\n\t.enable_scatter = ath6kl_sdio_enable_scatter,\n\t.scat_req_rw = ath6kl_sdio_async_rw_scatter,\n\t.cleanup_scatter = ath6kl_sdio_cleanup_scatter,\n\t.suspend = ath6kl_sdio_suspend,\n\t.resume = ath6kl_sdio_resume,\n\t.diag_read32 = ath6kl_sdio_diag_read32,\n\t.diag_write32 = ath6kl_sdio_diag_write32,\n\t.bmi_read = ath6kl_sdio_bmi_read,\n\t.bmi_write = ath6kl_sdio_bmi_write,\n\t.power_on = ath6kl_sdio_power_on,\n\t.power_off = ath6kl_sdio_power_off,\n\t.stop = ath6kl_sdio_stop,\n};\n\n#ifdef CONFIG_PM_SLEEP\n\n \nstatic int ath6kl_sdio_pm_suspend(struct device *device)\n{\n\tath6kl_dbg(ATH6KL_DBG_SUSPEND, \"sdio pm suspend\\n\");\n\n\treturn 0;\n}\n\nstatic int ath6kl_sdio_pm_resume(struct device *device)\n{\n\tath6kl_dbg(ATH6KL_DBG_SUSPEND, \"sdio pm resume\\n\");\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(ath6kl_sdio_pm_ops, ath6kl_sdio_pm_suspend,\n\t\t\t ath6kl_sdio_pm_resume);\n\n#define ATH6KL_SDIO_PM_OPS (&ath6kl_sdio_pm_ops)\n\n#else\n\n#define ATH6KL_SDIO_PM_OPS NULL\n\n#endif  \n\nstatic int ath6kl_sdio_probe(struct sdio_func *func,\n\t\t\t     const struct sdio_device_id *id)\n{\n\tint ret;\n\tstruct ath6kl_sdio *ar_sdio;\n\tstruct ath6kl *ar;\n\tint count;\n\n\tath6kl_dbg(ATH6KL_DBG_BOOT,\n\t\t   \"sdio new func %d vendor 0x%x device 0x%x block 0x%x/0x%x\\n\",\n\t\t   func->num, func->vendor, func->device,\n\t\t   func->max_blksize, func->cur_blksize);\n\n\tar_sdio = kzalloc(sizeof(struct ath6kl_sdio), GFP_KERNEL);\n\tif (!ar_sdio)\n\t\treturn -ENOMEM;\n\n\tar_sdio->dma_buffer = kzalloc(HIF_DMA_BUFFER_SIZE, GFP_KERNEL);\n\tif (!ar_sdio->dma_buffer) {\n\t\tret = -ENOMEM;\n\t\tgoto err_hif;\n\t}\n\n\tar_sdio->func = func;\n\tsdio_set_drvdata(func, ar_sdio);\n\n\tar_sdio->id = id;\n\tar_sdio->is_disabled = true;\n\n\tspin_lock_init(&ar_sdio->lock);\n\tspin_lock_init(&ar_sdio->scat_lock);\n\tspin_lock_init(&ar_sdio->wr_async_lock);\n\tmutex_init(&ar_sdio->dma_buffer_mutex);\n\n\tINIT_LIST_HEAD(&ar_sdio->scat_req);\n\tINIT_LIST_HEAD(&ar_sdio->bus_req_freeq);\n\tINIT_LIST_HEAD(&ar_sdio->wr_asyncq);\n\n\tINIT_WORK(&ar_sdio->wr_async_work, ath6kl_sdio_write_async_work);\n\n\tinit_waitqueue_head(&ar_sdio->irq_wq);\n\n\tfor (count = 0; count < BUS_REQUEST_MAX_NUM; count++)\n\t\tath6kl_sdio_free_bus_req(ar_sdio, &ar_sdio->bus_req[count]);\n\n\tar = ath6kl_core_create(&ar_sdio->func->dev);\n\tif (!ar) {\n\t\tath6kl_err(\"Failed to alloc ath6kl core\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_dma;\n\t}\n\n\tar_sdio->ar = ar;\n\tar->hif_type = ATH6KL_HIF_TYPE_SDIO;\n\tar->hif_priv = ar_sdio;\n\tar->hif_ops = &ath6kl_sdio_ops;\n\tar->bmi.max_data_size = 256;\n\n\tath6kl_sdio_set_mbox_info(ar);\n\n\tret = ath6kl_sdio_config(ar);\n\tif (ret) {\n\t\tath6kl_err(\"Failed to config sdio: %d\\n\", ret);\n\t\tgoto err_core_alloc;\n\t}\n\n\tret = ath6kl_core_init(ar, ATH6KL_HTC_TYPE_MBOX);\n\tif (ret) {\n\t\tath6kl_err(\"Failed to init ath6kl core\\n\");\n\t\tgoto err_core_alloc;\n\t}\n\n\treturn ret;\n\nerr_core_alloc:\n\tath6kl_core_destroy(ar_sdio->ar);\nerr_dma:\n\tkfree(ar_sdio->dma_buffer);\nerr_hif:\n\tkfree(ar_sdio);\n\n\treturn ret;\n}\n\nstatic void ath6kl_sdio_remove(struct sdio_func *func)\n{\n\tstruct ath6kl_sdio *ar_sdio;\n\n\tath6kl_dbg(ATH6KL_DBG_BOOT,\n\t\t   \"sdio removed func %d vendor 0x%x device 0x%x\\n\",\n\t\t   func->num, func->vendor, func->device);\n\n\tar_sdio = sdio_get_drvdata(func);\n\n\tath6kl_stop_txrx(ar_sdio->ar);\n\tcancel_work_sync(&ar_sdio->wr_async_work);\n\n\tath6kl_core_cleanup(ar_sdio->ar);\n\tath6kl_core_destroy(ar_sdio->ar);\n\n\tkfree(ar_sdio->dma_buffer);\n\tkfree(ar_sdio);\n}\n\nstatic const struct sdio_device_id ath6kl_sdio_devices[] = {\n\t{SDIO_DEVICE(SDIO_VENDOR_ID_ATHEROS, SDIO_DEVICE_ID_ATHEROS_AR6003_00)},\n\t{SDIO_DEVICE(SDIO_VENDOR_ID_ATHEROS, SDIO_DEVICE_ID_ATHEROS_AR6003_01)},\n\t{SDIO_DEVICE(SDIO_VENDOR_ID_ATHEROS, SDIO_DEVICE_ID_ATHEROS_AR6004_00)},\n\t{SDIO_DEVICE(SDIO_VENDOR_ID_ATHEROS, SDIO_DEVICE_ID_ATHEROS_AR6004_01)},\n\t{SDIO_DEVICE(SDIO_VENDOR_ID_ATHEROS, SDIO_DEVICE_ID_ATHEROS_AR6004_02)},\n\t{SDIO_DEVICE(SDIO_VENDOR_ID_ATHEROS, SDIO_DEVICE_ID_ATHEROS_AR6004_18)},\n\t{SDIO_DEVICE(SDIO_VENDOR_ID_ATHEROS, SDIO_DEVICE_ID_ATHEROS_AR6004_19)},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(sdio, ath6kl_sdio_devices);\n\nstatic struct sdio_driver ath6kl_sdio_driver = {\n\t.name = \"ath6kl_sdio\",\n\t.id_table = ath6kl_sdio_devices,\n\t.probe = ath6kl_sdio_probe,\n\t.remove = ath6kl_sdio_remove,\n\t.drv.pm = ATH6KL_SDIO_PM_OPS,\n};\n\nstatic int __init ath6kl_sdio_init(void)\n{\n\tint ret;\n\n\tret = sdio_register_driver(&ath6kl_sdio_driver);\n\tif (ret)\n\t\tath6kl_err(\"sdio driver registration failed: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void __exit ath6kl_sdio_exit(void)\n{\n\tsdio_unregister_driver(&ath6kl_sdio_driver);\n}\n\nmodule_init(ath6kl_sdio_init);\nmodule_exit(ath6kl_sdio_exit);\n\nMODULE_AUTHOR(\"Atheros Communications, Inc.\");\nMODULE_DESCRIPTION(\"Driver support for Atheros AR600x SDIO devices\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n\nMODULE_FIRMWARE(AR6003_HW_2_0_FW_DIR \"/\" AR6003_HW_2_0_OTP_FILE);\nMODULE_FIRMWARE(AR6003_HW_2_0_FW_DIR \"/\" AR6003_HW_2_0_FIRMWARE_FILE);\nMODULE_FIRMWARE(AR6003_HW_2_0_FW_DIR \"/\" AR6003_HW_2_0_PATCH_FILE);\nMODULE_FIRMWARE(AR6003_HW_2_0_BOARD_DATA_FILE);\nMODULE_FIRMWARE(AR6003_HW_2_0_DEFAULT_BOARD_DATA_FILE);\nMODULE_FIRMWARE(AR6003_HW_2_1_1_FW_DIR \"/\" AR6003_HW_2_1_1_OTP_FILE);\nMODULE_FIRMWARE(AR6003_HW_2_1_1_FW_DIR \"/\" AR6003_HW_2_1_1_FIRMWARE_FILE);\nMODULE_FIRMWARE(AR6003_HW_2_1_1_FW_DIR \"/\" AR6003_HW_2_1_1_PATCH_FILE);\nMODULE_FIRMWARE(AR6003_HW_2_1_1_BOARD_DATA_FILE);\nMODULE_FIRMWARE(AR6003_HW_2_1_1_DEFAULT_BOARD_DATA_FILE);\nMODULE_FIRMWARE(AR6004_HW_1_0_FW_DIR \"/\" AR6004_HW_1_0_FIRMWARE_FILE);\nMODULE_FIRMWARE(AR6004_HW_1_0_BOARD_DATA_FILE);\nMODULE_FIRMWARE(AR6004_HW_1_0_DEFAULT_BOARD_DATA_FILE);\nMODULE_FIRMWARE(AR6004_HW_1_1_FW_DIR \"/\" AR6004_HW_1_1_FIRMWARE_FILE);\nMODULE_FIRMWARE(AR6004_HW_1_1_BOARD_DATA_FILE);\nMODULE_FIRMWARE(AR6004_HW_1_1_DEFAULT_BOARD_DATA_FILE);\nMODULE_FIRMWARE(AR6004_HW_1_2_FW_DIR \"/\" AR6004_HW_1_2_FIRMWARE_FILE);\nMODULE_FIRMWARE(AR6004_HW_1_2_BOARD_DATA_FILE);\nMODULE_FIRMWARE(AR6004_HW_1_2_DEFAULT_BOARD_DATA_FILE);\nMODULE_FIRMWARE(AR6004_HW_1_3_FW_DIR \"/\" AR6004_HW_1_3_FIRMWARE_FILE);\nMODULE_FIRMWARE(AR6004_HW_1_3_BOARD_DATA_FILE);\nMODULE_FIRMWARE(AR6004_HW_1_3_DEFAULT_BOARD_DATA_FILE);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}