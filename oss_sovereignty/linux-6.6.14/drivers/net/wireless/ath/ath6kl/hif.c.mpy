{
  "module_name": "hif.c",
  "hash_id": "5a0be00e3494e2ff168ecc2e7f64e3d298946ff56e07354c036ef7aab2ff2c4e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath6kl/hif.c",
  "human_readable_source": " \n#include \"hif.h\"\n\n#include <linux/export.h>\n\n#include \"core.h\"\n#include \"target.h\"\n#include \"hif-ops.h\"\n#include \"debug.h\"\n#include \"trace.h\"\n\n#define MAILBOX_FOR_BLOCK_SIZE          1\n\n#define ATH6KL_TIME_QUANTUM\t10   \n\nstatic int ath6kl_hif_cp_scat_dma_buf(struct hif_scatter_req *req,\n\t\t\t\t      bool from_dma)\n{\n\tu8 *buf;\n\tint i;\n\n\tbuf = req->virt_dma_buf;\n\n\tfor (i = 0; i < req->scat_entries; i++) {\n\t\tif (from_dma)\n\t\t\tmemcpy(req->scat_list[i].buf, buf,\n\t\t\t       req->scat_list[i].len);\n\t\telse\n\t\t\tmemcpy(buf, req->scat_list[i].buf,\n\t\t\t       req->scat_list[i].len);\n\n\t\tbuf += req->scat_list[i].len;\n\t}\n\n\treturn 0;\n}\n\nint ath6kl_hif_rw_comp_handler(void *context, int status)\n{\n\tstruct htc_packet *packet = context;\n\n\tath6kl_dbg(ATH6KL_DBG_HIF, \"hif rw completion pkt 0x%p status %d\\n\",\n\t\t   packet, status);\n\n\tpacket->status = status;\n\tpacket->completion(packet->context, packet);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ath6kl_hif_rw_comp_handler);\n\n#define REGISTER_DUMP_COUNT     60\n#define REGISTER_DUMP_LEN_MAX   60\n\nstatic void ath6kl_hif_dump_fw_crash(struct ath6kl *ar)\n{\n\t__le32 regdump_val[REGISTER_DUMP_LEN_MAX];\n\tu32 i, address, regdump_addr = 0;\n\tint ret;\n\n\t \n\taddress = ath6kl_get_hi_item_addr(ar, HI_ITEM(hi_failure_state));\n\taddress = TARG_VTOP(ar->target_type, address);\n\n\t \n\tret = ath6kl_diag_read32(ar, address, &regdump_addr);\n\n\tif (ret || !regdump_addr) {\n\t\tath6kl_warn(\"failed to get ptr to register dump area: %d\\n\",\n\t\t\t    ret);\n\t\treturn;\n\t}\n\n\tath6kl_dbg(ATH6KL_DBG_IRQ, \"register dump data address 0x%x\\n\",\n\t\t   regdump_addr);\n\tregdump_addr = TARG_VTOP(ar->target_type, regdump_addr);\n\n\t \n\tret = ath6kl_diag_read(ar, regdump_addr, (u8 *)&regdump_val[0],\n\t\t\t\t  REGISTER_DUMP_COUNT * (sizeof(u32)));\n\tif (ret) {\n\t\tath6kl_warn(\"failed to get register dump: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tath6kl_info(\"crash dump:\\n\");\n\tath6kl_info(\"hw 0x%x fw %s\\n\", ar->wiphy->hw_version,\n\t\t    ar->wiphy->fw_version);\n\n\tBUILD_BUG_ON(REGISTER_DUMP_COUNT % 4);\n\n\tfor (i = 0; i < REGISTER_DUMP_COUNT; i += 4) {\n\t\tath6kl_info(\"%d: 0x%8.8x 0x%8.8x 0x%8.8x 0x%8.8x\\n\",\n\t\t\t    i,\n\t\t\t    le32_to_cpu(regdump_val[i]),\n\t\t\t    le32_to_cpu(regdump_val[i + 1]),\n\t\t\t    le32_to_cpu(regdump_val[i + 2]),\n\t\t\t    le32_to_cpu(regdump_val[i + 3]));\n\t}\n}\n\nstatic int ath6kl_hif_proc_dbg_intr(struct ath6kl_device *dev)\n{\n\tu32 dummy;\n\tint ret;\n\n\tath6kl_warn(\"firmware crashed\\n\");\n\n\t \n\tret = hif_read_write_sync(dev->ar, COUNT_DEC_ADDRESS,\n\t\t\t\t     (u8 *)&dummy, 4, HIF_RD_SYNC_BYTE_INC);\n\tif (ret)\n\t\tath6kl_warn(\"Failed to clear debug interrupt: %d\\n\", ret);\n\n\tath6kl_hif_dump_fw_crash(dev->ar);\n\tath6kl_read_fwlogs(dev->ar);\n\tath6kl_recovery_err_notify(dev->ar, ATH6KL_FW_ASSERT);\n\n\treturn ret;\n}\n\n \nint ath6kl_hif_poll_mboxmsg_rx(struct ath6kl_device *dev, u32 *lk_ahd,\n\t\t\t      int timeout)\n{\n\tstruct ath6kl_irq_proc_registers *rg;\n\tint status = 0, i;\n\tu8 htc_mbox = 1 << HTC_MAILBOX;\n\n\tfor (i = timeout / ATH6KL_TIME_QUANTUM; i > 0; i--) {\n\t\t \n\t\tstatus = hif_read_write_sync(dev->ar, HOST_INT_STATUS_ADDRESS,\n\t\t\t\t\t     (u8 *) &dev->irq_proc_reg,\n\t\t\t\t\t     sizeof(dev->irq_proc_reg),\n\t\t\t\t\t     HIF_RD_SYNC_BYTE_INC);\n\n\t\tif (status) {\n\t\t\tath6kl_err(\"failed to read reg table\\n\");\n\t\t\treturn status;\n\t\t}\n\n\t\t \n\t\tif (dev->irq_proc_reg.host_int_status & htc_mbox) {\n\t\t\tif (dev->irq_proc_reg.rx_lkahd_valid &\n\t\t\t    htc_mbox) {\n\t\t\t\t \n\t\t\t\trg = &dev->irq_proc_reg;\n\t\t\t\t*lk_ahd =\n\t\t\t\t\tle32_to_cpu(rg->rx_lkahd[HTC_MAILBOX]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tmdelay(ATH6KL_TIME_QUANTUM);\n\t\tath6kl_dbg(ATH6KL_DBG_HIF, \"hif retry mbox poll try %d\\n\", i);\n\t}\n\n\tif (i == 0) {\n\t\tath6kl_err(\"timeout waiting for recv message\\n\");\n\t\tstatus = -ETIME;\n\t\t \n\t\tif (dev->irq_proc_reg.counter_int_status &\n\t\t    ATH6KL_TARGET_DEBUG_INTR_MASK)\n\t\t\t \n\t\t\tath6kl_hif_proc_dbg_intr(dev);\n\t}\n\n\treturn status;\n}\n\n \nint ath6kl_hif_rx_control(struct ath6kl_device *dev, bool enable_rx)\n{\n\tstruct ath6kl_irq_enable_reg regs;\n\tint status = 0;\n\n\tath6kl_dbg(ATH6KL_DBG_HIF, \"hif rx %s\\n\",\n\t\t   enable_rx ? \"enable\" : \"disable\");\n\n\t \n\tspin_lock_bh(&dev->lock);\n\n\tif (enable_rx)\n\t\tdev->irq_en_reg.int_status_en |=\n\t\t\tSM(INT_STATUS_ENABLE_MBOX_DATA, 0x01);\n\telse\n\t\tdev->irq_en_reg.int_status_en &=\n\t\t    ~SM(INT_STATUS_ENABLE_MBOX_DATA, 0x01);\n\n\tmemcpy(&regs, &dev->irq_en_reg, sizeof(regs));\n\n\tspin_unlock_bh(&dev->lock);\n\n\tstatus = hif_read_write_sync(dev->ar, INT_STATUS_ENABLE_ADDRESS,\n\t\t\t\t     &regs.int_status_en,\n\t\t\t\t     sizeof(struct ath6kl_irq_enable_reg),\n\t\t\t\t     HIF_WR_SYNC_BYTE_INC);\n\n\treturn status;\n}\n\nint ath6kl_hif_submit_scat_req(struct ath6kl_device *dev,\n\t\t\t      struct hif_scatter_req *scat_req, bool read)\n{\n\tint status = 0;\n\n\tif (read) {\n\t\tscat_req->req = HIF_RD_SYNC_BLOCK_FIX;\n\t\tscat_req->addr = dev->ar->mbox_info.htc_addr;\n\t} else {\n\t\tscat_req->req = HIF_WR_ASYNC_BLOCK_INC;\n\n\t\tscat_req->addr =\n\t\t\t(scat_req->len > HIF_MBOX_WIDTH) ?\n\t\t\tdev->ar->mbox_info.htc_ext_addr :\n\t\t\tdev->ar->mbox_info.htc_addr;\n\t}\n\n\tath6kl_dbg(ATH6KL_DBG_HIF,\n\t\t   \"hif submit scatter request entries %d len %d mbox 0x%x %s %s\\n\",\n\t\t   scat_req->scat_entries, scat_req->len,\n\t\t   scat_req->addr, !read ? \"async\" : \"sync\",\n\t\t   (read) ? \"rd\" : \"wr\");\n\n\tif (!read && scat_req->virt_scat) {\n\t\tstatus = ath6kl_hif_cp_scat_dma_buf(scat_req, false);\n\t\tif (status) {\n\t\t\tscat_req->status = status;\n\t\t\tscat_req->complete(dev->ar->htc_target, scat_req);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tstatus = ath6kl_hif_scat_req_rw(dev->ar, scat_req);\n\n\tif (read) {\n\t\t \n\t\tscat_req->status = status;\n\t\tif (!status && scat_req->virt_scat)\n\t\t\tscat_req->status =\n\t\t\t\tath6kl_hif_cp_scat_dma_buf(scat_req, true);\n\t}\n\n\treturn status;\n}\n\nstatic int ath6kl_hif_proc_counter_intr(struct ath6kl_device *dev)\n{\n\tu8 counter_int_status;\n\n\tath6kl_dbg(ATH6KL_DBG_IRQ, \"counter interrupt\\n\");\n\n\tcounter_int_status = dev->irq_proc_reg.counter_int_status &\n\t\t\t     dev->irq_en_reg.cntr_int_status_en;\n\n\tath6kl_dbg(ATH6KL_DBG_IRQ,\n\t\t   \"valid interrupt source(s) in COUNTER_INT_STATUS: 0x%x\\n\",\n\t\tcounter_int_status);\n\n\t \n\tif (counter_int_status & ATH6KL_TARGET_DEBUG_INTR_MASK)\n\t\treturn ath6kl_hif_proc_dbg_intr(dev);\n\n\treturn 0;\n}\n\nstatic int ath6kl_hif_proc_err_intr(struct ath6kl_device *dev)\n{\n\tint status;\n\tu8 error_int_status;\n\tu8 reg_buf[4];\n\n\tath6kl_dbg(ATH6KL_DBG_IRQ, \"error interrupt\\n\");\n\n\terror_int_status = dev->irq_proc_reg.error_int_status & 0x0F;\n\tif (!error_int_status) {\n\t\tWARN_ON(1);\n\t\treturn -EIO;\n\t}\n\n\tath6kl_dbg(ATH6KL_DBG_IRQ,\n\t\t   \"valid interrupt source(s) in ERROR_INT_STATUS: 0x%x\\n\",\n\t\t   error_int_status);\n\n\tif (MS(ERROR_INT_STATUS_WAKEUP, error_int_status))\n\t\tath6kl_dbg(ATH6KL_DBG_IRQ, \"error : wakeup\\n\");\n\n\tif (MS(ERROR_INT_STATUS_RX_UNDERFLOW, error_int_status))\n\t\tath6kl_err(\"rx underflow\\n\");\n\n\tif (MS(ERROR_INT_STATUS_TX_OVERFLOW, error_int_status))\n\t\tath6kl_err(\"tx overflow\\n\");\n\n\t \n\tdev->irq_proc_reg.error_int_status &= ~error_int_status;\n\n\t \n\treg_buf[0] = error_int_status;\n\treg_buf[1] = 0;\n\treg_buf[2] = 0;\n\treg_buf[3] = 0;\n\n\tstatus = hif_read_write_sync(dev->ar, ERROR_INT_STATUS_ADDRESS,\n\t\t\t\t     reg_buf, 4, HIF_WR_SYNC_BYTE_FIX);\n\n\tWARN_ON(status);\n\n\treturn status;\n}\n\nstatic int ath6kl_hif_proc_cpu_intr(struct ath6kl_device *dev)\n{\n\tint status;\n\tu8 cpu_int_status;\n\tu8 reg_buf[4];\n\n\tath6kl_dbg(ATH6KL_DBG_IRQ, \"cpu interrupt\\n\");\n\n\tcpu_int_status = dev->irq_proc_reg.cpu_int_status &\n\t\t\t dev->irq_en_reg.cpu_int_status_en;\n\tif (!cpu_int_status) {\n\t\tWARN_ON(1);\n\t\treturn -EIO;\n\t}\n\n\tath6kl_dbg(ATH6KL_DBG_IRQ,\n\t\t   \"valid interrupt source(s) in CPU_INT_STATUS: 0x%x\\n\",\n\t\tcpu_int_status);\n\n\t \n\tdev->irq_proc_reg.cpu_int_status &= ~cpu_int_status;\n\n\t \n\n\t \n\treg_buf[0] = cpu_int_status;\n\t \n\treg_buf[1] = 0;\n\treg_buf[2] = 0;\n\treg_buf[3] = 0;\n\n\tstatus = hif_read_write_sync(dev->ar, CPU_INT_STATUS_ADDRESS,\n\t\t\t\t     reg_buf, 4, HIF_WR_SYNC_BYTE_FIX);\n\n\tWARN_ON(status);\n\n\treturn status;\n}\n\n \nstatic int proc_pending_irqs(struct ath6kl_device *dev, bool *done)\n{\n\tstruct ath6kl_irq_proc_registers *rg;\n\tint status = 0;\n\tu8 host_int_status = 0;\n\tu32 lk_ahd = 0;\n\tu8 htc_mbox = 1 << HTC_MAILBOX;\n\n\tath6kl_dbg(ATH6KL_DBG_IRQ, \"proc_pending_irqs: (dev: 0x%p)\\n\", dev);\n\n\t \n\n\t \n\tif (dev->irq_en_reg.int_status_en) {\n\t\t \n\t\tstatus = hif_read_write_sync(dev->ar, HOST_INT_STATUS_ADDRESS,\n\t\t\t\t\t     (u8 *) &dev->irq_proc_reg,\n\t\t\t\t\t     sizeof(dev->irq_proc_reg),\n\t\t\t\t\t     HIF_RD_SYNC_BYTE_INC);\n\t\tif (status)\n\t\t\tgoto out;\n\n\t\tath6kl_dump_registers(dev, &dev->irq_proc_reg,\n\t\t\t\t      &dev->irq_en_reg);\n\t\ttrace_ath6kl_sdio_irq(&dev->irq_en_reg,\n\t\t\t\t      sizeof(dev->irq_en_reg));\n\n\t\t \n\t\thost_int_status = dev->irq_proc_reg.host_int_status &\n\t\t\t\t  dev->irq_en_reg.int_status_en;\n\n\t\t \n\t\tif (host_int_status & htc_mbox) {\n\t\t\t \n\t\t\thost_int_status &= ~htc_mbox;\n\t\t\tif (dev->irq_proc_reg.rx_lkahd_valid &\n\t\t\t    htc_mbox) {\n\t\t\t\trg = &dev->irq_proc_reg;\n\t\t\t\tlk_ahd = le32_to_cpu(rg->rx_lkahd[HTC_MAILBOX]);\n\t\t\t\tif (!lk_ahd)\n\t\t\t\t\tath6kl_err(\"lookAhead is zero!\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!host_int_status && !lk_ahd) {\n\t\t*done = true;\n\t\tgoto out;\n\t}\n\n\tif (lk_ahd) {\n\t\tint fetched = 0;\n\n\t\tath6kl_dbg(ATH6KL_DBG_IRQ,\n\t\t\t   \"pending mailbox msg, lk_ahd: 0x%X\\n\", lk_ahd);\n\t\t \n\t\tstatus = ath6kl_htc_rxmsg_pending_handler(dev->htc_cnxt,\n\t\t\t\t\t\t\t  lk_ahd, &fetched);\n\t\tif (status)\n\t\t\tgoto out;\n\n\t\tif (!fetched)\n\t\t\t \n\t\t\tdev->htc_cnxt->chk_irq_status_cnt = 0;\n\t}\n\n\t \n\tath6kl_dbg(ATH6KL_DBG_IRQ,\n\t\t   \"valid interrupt source(s) for other interrupts: 0x%x\\n\",\n\t\t   host_int_status);\n\n\tif (MS(HOST_INT_STATUS_CPU, host_int_status)) {\n\t\t \n\t\tstatus = ath6kl_hif_proc_cpu_intr(dev);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tif (MS(HOST_INT_STATUS_ERROR, host_int_status)) {\n\t\t \n\t\tstatus = ath6kl_hif_proc_err_intr(dev);\n\t\tif (status)\n\t\t\tgoto out;\n\t}\n\n\tif (MS(HOST_INT_STATUS_COUNTER, host_int_status))\n\t\t \n\t\tstatus = ath6kl_hif_proc_counter_intr(dev);\n\nout:\n\t \n\n\tath6kl_dbg(ATH6KL_DBG_IRQ,\n\t\t   \"bypassing irq status re-check, forcing done\\n\");\n\n\tif (!dev->htc_cnxt->chk_irq_status_cnt)\n\t\t*done = true;\n\n\tath6kl_dbg(ATH6KL_DBG_IRQ,\n\t\t   \"proc_pending_irqs: (done:%d, status=%d\\n\", *done, status);\n\n\treturn status;\n}\n\n \nint ath6kl_hif_intr_bh_handler(struct ath6kl *ar)\n{\n\tstruct ath6kl_device *dev = ar->htc_target->dev;\n\tunsigned long timeout;\n\tint status = 0;\n\tbool done = false;\n\n\t \n\tdev->htc_cnxt->chk_irq_status_cnt = 0;\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(ATH6KL_HIF_COMMUNICATION_TIMEOUT);\n\twhile (time_before(jiffies, timeout) && !done) {\n\t\tstatus = proc_pending_irqs(dev, &done);\n\t\tif (status)\n\t\t\tbreak;\n\t}\n\n\treturn status;\n}\nEXPORT_SYMBOL(ath6kl_hif_intr_bh_handler);\n\nstatic int ath6kl_hif_enable_intrs(struct ath6kl_device *dev)\n{\n\tstruct ath6kl_irq_enable_reg regs;\n\tint status;\n\n\tspin_lock_bh(&dev->lock);\n\n\t \n\tdev->irq_en_reg.int_status_en =\n\t\t\tSM(INT_STATUS_ENABLE_ERROR, 0x01) |\n\t\t\tSM(INT_STATUS_ENABLE_CPU, 0x01) |\n\t\t\tSM(INT_STATUS_ENABLE_COUNTER, 0x01);\n\n\t \n\tdev->irq_en_reg.int_status_en |= SM(INT_STATUS_ENABLE_MBOX_DATA, 0x01);\n\n\t \n\tdev->irq_en_reg.cpu_int_status_en = 0;\n\n\t \n\tdev->irq_en_reg.err_int_status_en =\n\t\tSM(ERROR_STATUS_ENABLE_RX_UNDERFLOW, 0x01) |\n\t\tSM(ERROR_STATUS_ENABLE_TX_OVERFLOW, 0x1);\n\n\t \n\tdev->irq_en_reg.cntr_int_status_en = SM(COUNTER_INT_STATUS_ENABLE_BIT,\n\t\t\t\t\t\tATH6KL_TARGET_DEBUG_INTR_MASK);\n\tmemcpy(&regs, &dev->irq_en_reg, sizeof(regs));\n\n\tspin_unlock_bh(&dev->lock);\n\n\tstatus = hif_read_write_sync(dev->ar, INT_STATUS_ENABLE_ADDRESS,\n\t\t\t\t     &regs.int_status_en, sizeof(regs),\n\t\t\t\t     HIF_WR_SYNC_BYTE_INC);\n\n\tif (status)\n\t\tath6kl_err(\"failed to update interrupt ctl reg err: %d\\n\",\n\t\t\t   status);\n\n\treturn status;\n}\n\nint ath6kl_hif_disable_intrs(struct ath6kl_device *dev)\n{\n\tstruct ath6kl_irq_enable_reg regs;\n\n\tspin_lock_bh(&dev->lock);\n\t \n\tdev->irq_en_reg.int_status_en = 0;\n\tdev->irq_en_reg.cpu_int_status_en = 0;\n\tdev->irq_en_reg.err_int_status_en = 0;\n\tdev->irq_en_reg.cntr_int_status_en = 0;\n\tmemcpy(&regs, &dev->irq_en_reg, sizeof(regs));\n\tspin_unlock_bh(&dev->lock);\n\n\treturn hif_read_write_sync(dev->ar, INT_STATUS_ENABLE_ADDRESS,\n\t\t\t\t   &regs.int_status_en, sizeof(regs),\n\t\t\t\t   HIF_WR_SYNC_BYTE_INC);\n}\n\n \nint ath6kl_hif_unmask_intrs(struct ath6kl_device *dev)\n{\n\tint status = 0;\n\n\t \n\tath6kl_hif_disable_intrs(dev);\n\n\t \n\tath6kl_hif_irq_enable(dev->ar);\n\tstatus = ath6kl_hif_enable_intrs(dev);\n\n\treturn status;\n}\n\n \nint ath6kl_hif_mask_intrs(struct ath6kl_device *dev)\n{\n\t \n\tath6kl_hif_irq_disable(dev->ar);\n\n\treturn ath6kl_hif_disable_intrs(dev);\n}\n\nint ath6kl_hif_setup(struct ath6kl_device *dev)\n{\n\tint status = 0;\n\n\tspin_lock_init(&dev->lock);\n\n\t \n\tdev->htc_cnxt->block_sz = dev->ar->mbox_info.block_size;\n\n\t \n\tif ((dev->htc_cnxt->block_sz & (dev->htc_cnxt->block_sz - 1)) != 0) {\n\t\tWARN_ON(1);\n\t\tstatus = -EINVAL;\n\t\tgoto fail_setup;\n\t}\n\n\t \n\tdev->htc_cnxt->block_mask = dev->htc_cnxt->block_sz - 1;\n\n\tath6kl_dbg(ATH6KL_DBG_HIF, \"hif block size %d mbox addr 0x%x\\n\",\n\t\t   dev->htc_cnxt->block_sz, dev->ar->mbox_info.htc_addr);\n\n\tstatus = ath6kl_hif_disable_intrs(dev);\n\nfail_setup:\n\treturn status;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}