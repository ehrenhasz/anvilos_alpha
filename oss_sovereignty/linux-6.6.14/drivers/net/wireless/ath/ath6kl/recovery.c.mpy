{
  "module_name": "recovery.c",
  "hash_id": "b8324b053fe81274abe44ce3704dcc4c082541c1e18f7f79189533eb9fbe82db",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath6kl/recovery.c",
  "human_readable_source": " \n\n#include \"core.h\"\n#include \"cfg80211.h\"\n#include \"debug.h\"\n\nstatic void ath6kl_recovery_work(struct work_struct *work)\n{\n\tstruct ath6kl *ar = container_of(work, struct ath6kl,\n\t\t\t\t\t fw_recovery.recovery_work);\n\n\tar->state = ATH6KL_STATE_RECOVERY;\n\n\tdel_timer_sync(&ar->fw_recovery.hb_timer);\n\n\tath6kl_init_hw_restart(ar);\n\n\tar->state = ATH6KL_STATE_ON;\n\tclear_bit(WMI_CTRL_EP_FULL, &ar->flag);\n\n\tar->fw_recovery.err_reason = 0;\n\n\tif (ar->fw_recovery.hb_poll)\n\t\tmod_timer(&ar->fw_recovery.hb_timer, jiffies +\n\t\t\t  msecs_to_jiffies(ar->fw_recovery.hb_poll));\n}\n\nvoid ath6kl_recovery_err_notify(struct ath6kl *ar, enum ath6kl_fw_err reason)\n{\n\tif (!ar->fw_recovery.enable)\n\t\treturn;\n\n\tath6kl_dbg(ATH6KL_DBG_RECOVERY, \"Fw error detected, reason:%d\\n\",\n\t\t   reason);\n\n\tset_bit(reason, &ar->fw_recovery.err_reason);\n\n\tif (!test_bit(RECOVERY_CLEANUP, &ar->flag) &&\n\t    ar->state != ATH6KL_STATE_RECOVERY)\n\t\tqueue_work(ar->ath6kl_wq, &ar->fw_recovery.recovery_work);\n}\n\nvoid ath6kl_recovery_hb_event(struct ath6kl *ar, u32 cookie)\n{\n\tif (cookie == ar->fw_recovery.seq_num)\n\t\tar->fw_recovery.hb_pending = false;\n}\n\nstatic void ath6kl_recovery_hb_timer(struct timer_list *t)\n{\n\tstruct ath6kl *ar = from_timer(ar, t, fw_recovery.hb_timer);\n\tint err;\n\n\tif (test_bit(RECOVERY_CLEANUP, &ar->flag) ||\n\t    (ar->state == ATH6KL_STATE_RECOVERY))\n\t\treturn;\n\n\tif (ar->fw_recovery.hb_pending)\n\t\tar->fw_recovery.hb_misscnt++;\n\telse\n\t\tar->fw_recovery.hb_misscnt = 0;\n\n\tif (ar->fw_recovery.hb_misscnt > ATH6KL_HB_RESP_MISS_THRES) {\n\t\tar->fw_recovery.hb_misscnt = 0;\n\t\tar->fw_recovery.seq_num = 0;\n\t\tar->fw_recovery.hb_pending = false;\n\t\tath6kl_recovery_err_notify(ar, ATH6KL_FW_HB_RESP_FAILURE);\n\t\treturn;\n\t}\n\n\tar->fw_recovery.seq_num++;\n\tar->fw_recovery.hb_pending = true;\n\n\terr = ath6kl_wmi_get_challenge_resp_cmd(ar->wmi,\n\t\t\t\t\t\tar->fw_recovery.seq_num, 0);\n\tif (err)\n\t\tath6kl_warn(\"Failed to send hb challenge request, err:%d\\n\",\n\t\t\t    err);\n\n\tmod_timer(&ar->fw_recovery.hb_timer, jiffies +\n\t\t  msecs_to_jiffies(ar->fw_recovery.hb_poll));\n}\n\nvoid ath6kl_recovery_init(struct ath6kl *ar)\n{\n\tstruct ath6kl_fw_recovery *recovery = &ar->fw_recovery;\n\n\tclear_bit(RECOVERY_CLEANUP, &ar->flag);\n\tINIT_WORK(&recovery->recovery_work, ath6kl_recovery_work);\n\trecovery->seq_num = 0;\n\trecovery->hb_misscnt = 0;\n\tar->fw_recovery.hb_pending = false;\n\ttimer_setup(&ar->fw_recovery.hb_timer, ath6kl_recovery_hb_timer,\n\t\t    TIMER_DEFERRABLE);\n\n\tif (ar->fw_recovery.hb_poll)\n\t\tmod_timer(&ar->fw_recovery.hb_timer, jiffies +\n\t\t\t  msecs_to_jiffies(ar->fw_recovery.hb_poll));\n}\n\nvoid ath6kl_recovery_cleanup(struct ath6kl *ar)\n{\n\tif (!ar->fw_recovery.enable)\n\t\treturn;\n\n\tset_bit(RECOVERY_CLEANUP, &ar->flag);\n\n\tdel_timer_sync(&ar->fw_recovery.hb_timer);\n\tcancel_work_sync(&ar->fw_recovery.recovery_work);\n}\n\nvoid ath6kl_recovery_suspend(struct ath6kl *ar)\n{\n\tif (!ar->fw_recovery.enable)\n\t\treturn;\n\n\tath6kl_recovery_cleanup(ar);\n\n\tif (!ar->fw_recovery.err_reason)\n\t\treturn;\n\n\t \n\tar->fw_recovery.err_reason = 0;\n\tWARN_ON(ar->state != ATH6KL_STATE_ON);\n\tar->state = ATH6KL_STATE_RECOVERY;\n\tath6kl_init_hw_restart(ar);\n\tar->state = ATH6KL_STATE_ON;\n}\n\nvoid ath6kl_recovery_resume(struct ath6kl *ar)\n{\n\tif (!ar->fw_recovery.enable)\n\t\treturn;\n\n\tclear_bit(RECOVERY_CLEANUP, &ar->flag);\n\n\tif (!ar->fw_recovery.hb_poll)\n\t\treturn;\n\n\tar->fw_recovery.hb_pending = false;\n\tar->fw_recovery.seq_num = 0;\n\tar->fw_recovery.hb_misscnt = 0;\n\tmod_timer(&ar->fw_recovery.hb_timer,\n\t\t  jiffies + msecs_to_jiffies(ar->fw_recovery.hb_poll));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}