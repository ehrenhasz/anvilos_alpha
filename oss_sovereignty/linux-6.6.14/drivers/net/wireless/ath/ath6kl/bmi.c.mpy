{
  "module_name": "bmi.c",
  "hash_id": "07db26629e82a9dd81a00e542b80a504993d8ed4963cf4f2658ee6a4d0d765c6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath6kl/bmi.c",
  "human_readable_source": " \n\n#include \"core.h\"\n#include \"hif-ops.h\"\n#include \"target.h\"\n#include \"debug.h\"\n\nint ath6kl_bmi_done(struct ath6kl *ar)\n{\n\tint ret;\n\tu32 cid = BMI_DONE;\n\n\tif (ar->bmi.done_sent) {\n\t\tath6kl_dbg(ATH6KL_DBG_BMI, \"bmi done skipped\\n\");\n\t\treturn 0;\n\t}\n\n\tar->bmi.done_sent = true;\n\n\tret = ath6kl_hif_bmi_write(ar, (u8 *)&cid, sizeof(cid));\n\tif (ret) {\n\t\tath6kl_err(\"Unable to send bmi done: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint ath6kl_bmi_get_target_info(struct ath6kl *ar,\n\t\t\t       struct ath6kl_bmi_target_info *targ_info)\n{\n\tint ret;\n\tu32 cid = BMI_GET_TARGET_INFO;\n\n\tif (ar->bmi.done_sent) {\n\t\tath6kl_err(\"bmi done sent already, cmd %d disallowed\\n\", cid);\n\t\treturn -EACCES;\n\t}\n\n\tret = ath6kl_hif_bmi_write(ar, (u8 *)&cid, sizeof(cid));\n\tif (ret) {\n\t\tath6kl_err(\"Unable to send get target info: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (ar->hif_type == ATH6KL_HIF_TYPE_USB) {\n\t\tret = ath6kl_hif_bmi_read(ar, (u8 *)targ_info,\n\t\t\t\t\t  sizeof(*targ_info));\n\t} else {\n\t\tret = ath6kl_hif_bmi_read(ar, (u8 *)&targ_info->version,\n\t\t\t\tsizeof(targ_info->version));\n\t}\n\n\tif (ret) {\n\t\tath6kl_err(\"Unable to recv target info: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (le32_to_cpu(targ_info->version) == TARGET_VERSION_SENTINAL) {\n\t\t \n\t\tret = ath6kl_hif_bmi_read(ar,\n\t\t\t\t   (u8 *)&targ_info->byte_count,\n\t\t\t\t   sizeof(targ_info->byte_count));\n\t\tif (ret) {\n\t\t\tath6kl_err(\"unable to read target info byte count: %d\\n\",\n\t\t\t\t   ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tif (le32_to_cpu(targ_info->byte_count) != sizeof(*targ_info)) {\n\t\t\tWARN_ON(1);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tret = ath6kl_hif_bmi_read(ar,\n\t\t\t\t   ((u8 *)targ_info) +\n\t\t\t\t   sizeof(targ_info->byte_count),\n\t\t\t\t   sizeof(*targ_info) -\n\t\t\t\t   sizeof(targ_info->byte_count));\n\n\t\tif (ret) {\n\t\t\tath6kl_err(\"Unable to read target info (%d bytes): %d\\n\",\n\t\t\t\t   targ_info->byte_count, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tath6kl_dbg(ATH6KL_DBG_BMI, \"target info (ver: 0x%x type: 0x%x)\\n\",\n\t\t   targ_info->version, targ_info->type);\n\n\treturn 0;\n}\n\nint ath6kl_bmi_read(struct ath6kl *ar, u32 addr, u8 *buf, u32 len)\n{\n\tu32 cid = BMI_READ_MEMORY;\n\tint ret;\n\tu32 offset;\n\tu32 len_remain, rx_len;\n\tu16 size;\n\n\tif (ar->bmi.done_sent) {\n\t\tath6kl_err(\"bmi done sent already, cmd %d disallowed\\n\", cid);\n\t\treturn -EACCES;\n\t}\n\n\tsize = ar->bmi.max_data_size + sizeof(cid) + sizeof(addr) + sizeof(len);\n\tif (size > ar->bmi.max_cmd_size) {\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\tmemset(ar->bmi.cmd_buf, 0, size);\n\n\tath6kl_dbg(ATH6KL_DBG_BMI,\n\t\t   \"bmi read memory: device: addr: 0x%x, len: %d\\n\",\n\t\t   addr, len);\n\n\tlen_remain = len;\n\n\twhile (len_remain) {\n\t\trx_len = (len_remain < ar->bmi.max_data_size) ?\n\t\t\t\t\tlen_remain : ar->bmi.max_data_size;\n\t\toffset = 0;\n\t\tmemcpy(&(ar->bmi.cmd_buf[offset]), &cid, sizeof(cid));\n\t\toffset += sizeof(cid);\n\t\tmemcpy(&(ar->bmi.cmd_buf[offset]), &addr, sizeof(addr));\n\t\toffset += sizeof(addr);\n\t\tmemcpy(&(ar->bmi.cmd_buf[offset]), &rx_len, sizeof(rx_len));\n\t\toffset += sizeof(len);\n\n\t\tret = ath6kl_hif_bmi_write(ar, ar->bmi.cmd_buf, offset);\n\t\tif (ret) {\n\t\t\tath6kl_err(\"Unable to write to the device: %d\\n\",\n\t\t\t\t   ret);\n\t\t\treturn ret;\n\t\t}\n\t\tret = ath6kl_hif_bmi_read(ar, ar->bmi.cmd_buf, rx_len);\n\t\tif (ret) {\n\t\t\tath6kl_err(\"Unable to read from the device: %d\\n\",\n\t\t\t\t   ret);\n\t\t\treturn ret;\n\t\t}\n\t\tmemcpy(&buf[len - len_remain], ar->bmi.cmd_buf, rx_len);\n\t\tlen_remain -= rx_len; addr += rx_len;\n\t}\n\n\treturn 0;\n}\n\nint ath6kl_bmi_write(struct ath6kl *ar, u32 addr, u8 *buf, u32 len)\n{\n\tu32 cid = BMI_WRITE_MEMORY;\n\tint ret;\n\tu32 offset;\n\tu32 len_remain, tx_len;\n\tconst u32 header = sizeof(cid) + sizeof(addr) + sizeof(len);\n\tu8 aligned_buf[400];\n\tu8 *src;\n\n\tif (ar->bmi.done_sent) {\n\t\tath6kl_err(\"bmi done sent already, cmd %d disallowed\\n\", cid);\n\t\treturn -EACCES;\n\t}\n\n\tif ((ar->bmi.max_data_size + header) > ar->bmi.max_cmd_size) {\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\tif (WARN_ON(ar->bmi.max_data_size > sizeof(aligned_buf)))\n\t\treturn -E2BIG;\n\n\tmemset(ar->bmi.cmd_buf, 0, ar->bmi.max_data_size + header);\n\n\tath6kl_dbg(ATH6KL_DBG_BMI,\n\t\t   \"bmi write memory: addr: 0x%x, len: %d\\n\", addr, len);\n\n\tlen_remain = len;\n\twhile (len_remain) {\n\t\tsrc = &buf[len - len_remain];\n\n\t\tif (len_remain < (ar->bmi.max_data_size - header)) {\n\t\t\tif (len_remain & 3) {\n\t\t\t\t \n\t\t\t\tlen_remain = len_remain +\n\t\t\t\t\t     (4 - (len_remain & 3));\n\t\t\t\tmemcpy(aligned_buf, src, len_remain);\n\t\t\t\tsrc = aligned_buf;\n\t\t\t}\n\t\t\ttx_len = len_remain;\n\t\t} else {\n\t\t\ttx_len = (ar->bmi.max_data_size - header);\n\t\t}\n\n\t\toffset = 0;\n\t\tmemcpy(&(ar->bmi.cmd_buf[offset]), &cid, sizeof(cid));\n\t\toffset += sizeof(cid);\n\t\tmemcpy(&(ar->bmi.cmd_buf[offset]), &addr, sizeof(addr));\n\t\toffset += sizeof(addr);\n\t\tmemcpy(&(ar->bmi.cmd_buf[offset]), &tx_len, sizeof(tx_len));\n\t\toffset += sizeof(tx_len);\n\t\tmemcpy(&(ar->bmi.cmd_buf[offset]), src, tx_len);\n\t\toffset += tx_len;\n\n\t\tret = ath6kl_hif_bmi_write(ar, ar->bmi.cmd_buf, offset);\n\t\tif (ret) {\n\t\t\tath6kl_err(\"Unable to write to the device: %d\\n\",\n\t\t\t\t   ret);\n\t\t\treturn ret;\n\t\t}\n\t\tlen_remain -= tx_len; addr += tx_len;\n\t}\n\n\treturn 0;\n}\n\nint ath6kl_bmi_execute(struct ath6kl *ar, u32 addr, u32 *param)\n{\n\tu32 cid = BMI_EXECUTE;\n\tint ret;\n\tu32 offset;\n\tu16 size;\n\n\tif (ar->bmi.done_sent) {\n\t\tath6kl_err(\"bmi done sent already, cmd %d disallowed\\n\", cid);\n\t\treturn -EACCES;\n\t}\n\n\tsize = sizeof(cid) + sizeof(addr) + sizeof(*param);\n\tif (size > ar->bmi.max_cmd_size) {\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\tmemset(ar->bmi.cmd_buf, 0, size);\n\n\tath6kl_dbg(ATH6KL_DBG_BMI, \"bmi execute: addr: 0x%x, param: %d)\\n\",\n\t\t   addr, *param);\n\n\toffset = 0;\n\tmemcpy(&(ar->bmi.cmd_buf[offset]), &cid, sizeof(cid));\n\toffset += sizeof(cid);\n\tmemcpy(&(ar->bmi.cmd_buf[offset]), &addr, sizeof(addr));\n\toffset += sizeof(addr);\n\tmemcpy(&(ar->bmi.cmd_buf[offset]), param, sizeof(*param));\n\toffset += sizeof(*param);\n\n\tret = ath6kl_hif_bmi_write(ar, ar->bmi.cmd_buf, offset);\n\tif (ret) {\n\t\tath6kl_err(\"Unable to write to the device: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ath6kl_hif_bmi_read(ar, ar->bmi.cmd_buf, sizeof(*param));\n\tif (ret) {\n\t\tath6kl_err(\"Unable to read from the device: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmemcpy(param, ar->bmi.cmd_buf, sizeof(*param));\n\n\treturn 0;\n}\n\nint ath6kl_bmi_set_app_start(struct ath6kl *ar, u32 addr)\n{\n\tu32 cid = BMI_SET_APP_START;\n\tint ret;\n\tu32 offset;\n\tu16 size;\n\n\tif (ar->bmi.done_sent) {\n\t\tath6kl_err(\"bmi done sent already, cmd %d disallowed\\n\", cid);\n\t\treturn -EACCES;\n\t}\n\n\tsize = sizeof(cid) + sizeof(addr);\n\tif (size > ar->bmi.max_cmd_size) {\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\tmemset(ar->bmi.cmd_buf, 0, size);\n\n\tath6kl_dbg(ATH6KL_DBG_BMI, \"bmi set app start: addr: 0x%x\\n\", addr);\n\n\toffset = 0;\n\tmemcpy(&(ar->bmi.cmd_buf[offset]), &cid, sizeof(cid));\n\toffset += sizeof(cid);\n\tmemcpy(&(ar->bmi.cmd_buf[offset]), &addr, sizeof(addr));\n\toffset += sizeof(addr);\n\n\tret = ath6kl_hif_bmi_write(ar, ar->bmi.cmd_buf, offset);\n\tif (ret) {\n\t\tath6kl_err(\"Unable to write to the device: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint ath6kl_bmi_reg_read(struct ath6kl *ar, u32 addr, u32 *param)\n{\n\tu32 cid = BMI_READ_SOC_REGISTER;\n\tint ret;\n\tu32 offset;\n\tu16 size;\n\n\tif (ar->bmi.done_sent) {\n\t\tath6kl_err(\"bmi done sent already, cmd %d disallowed\\n\", cid);\n\t\treturn -EACCES;\n\t}\n\n\tsize = sizeof(cid) + sizeof(addr);\n\tif (size > ar->bmi.max_cmd_size) {\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\tmemset(ar->bmi.cmd_buf, 0, size);\n\n\tath6kl_dbg(ATH6KL_DBG_BMI, \"bmi read SOC reg: addr: 0x%x\\n\", addr);\n\n\toffset = 0;\n\tmemcpy(&(ar->bmi.cmd_buf[offset]), &cid, sizeof(cid));\n\toffset += sizeof(cid);\n\tmemcpy(&(ar->bmi.cmd_buf[offset]), &addr, sizeof(addr));\n\toffset += sizeof(addr);\n\n\tret = ath6kl_hif_bmi_write(ar, ar->bmi.cmd_buf, offset);\n\tif (ret) {\n\t\tath6kl_err(\"Unable to write to the device: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ath6kl_hif_bmi_read(ar, ar->bmi.cmd_buf, sizeof(*param));\n\tif (ret) {\n\t\tath6kl_err(\"Unable to read from the device: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tmemcpy(param, ar->bmi.cmd_buf, sizeof(*param));\n\n\treturn 0;\n}\n\nint ath6kl_bmi_reg_write(struct ath6kl *ar, u32 addr, u32 param)\n{\n\tu32 cid = BMI_WRITE_SOC_REGISTER;\n\tint ret;\n\tu32 offset;\n\tu16 size;\n\n\tif (ar->bmi.done_sent) {\n\t\tath6kl_err(\"bmi done sent already, cmd %d disallowed\\n\", cid);\n\t\treturn -EACCES;\n\t}\n\n\tsize = sizeof(cid) + sizeof(addr) + sizeof(param);\n\tif (size > ar->bmi.max_cmd_size) {\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\tmemset(ar->bmi.cmd_buf, 0, size);\n\n\tath6kl_dbg(ATH6KL_DBG_BMI,\n\t\t   \"bmi write SOC reg: addr: 0x%x, param: %d\\n\",\n\t\t    addr, param);\n\n\toffset = 0;\n\tmemcpy(&(ar->bmi.cmd_buf[offset]), &cid, sizeof(cid));\n\toffset += sizeof(cid);\n\tmemcpy(&(ar->bmi.cmd_buf[offset]), &addr, sizeof(addr));\n\toffset += sizeof(addr);\n\tmemcpy(&(ar->bmi.cmd_buf[offset]), &param, sizeof(param));\n\toffset += sizeof(param);\n\n\tret = ath6kl_hif_bmi_write(ar, ar->bmi.cmd_buf, offset);\n\tif (ret) {\n\t\tath6kl_err(\"Unable to write to the device: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint ath6kl_bmi_lz_data(struct ath6kl *ar, u8 *buf, u32 len)\n{\n\tu32 cid = BMI_LZ_DATA;\n\tint ret;\n\tu32 offset;\n\tu32 len_remain, tx_len;\n\tconst u32 header = sizeof(cid) + sizeof(len);\n\tu16 size;\n\n\tif (ar->bmi.done_sent) {\n\t\tath6kl_err(\"bmi done sent already, cmd %d disallowed\\n\", cid);\n\t\treturn -EACCES;\n\t}\n\n\tsize = ar->bmi.max_data_size + header;\n\tif (size > ar->bmi.max_cmd_size) {\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\tmemset(ar->bmi.cmd_buf, 0, size);\n\n\tath6kl_dbg(ATH6KL_DBG_BMI, \"bmi send LZ data: len: %d)\\n\",\n\t\t   len);\n\n\tlen_remain = len;\n\twhile (len_remain) {\n\t\ttx_len = (len_remain < (ar->bmi.max_data_size - header)) ?\n\t\t\t  len_remain : (ar->bmi.max_data_size - header);\n\n\t\toffset = 0;\n\t\tmemcpy(&(ar->bmi.cmd_buf[offset]), &cid, sizeof(cid));\n\t\toffset += sizeof(cid);\n\t\tmemcpy(&(ar->bmi.cmd_buf[offset]), &tx_len, sizeof(tx_len));\n\t\toffset += sizeof(tx_len);\n\t\tmemcpy(&(ar->bmi.cmd_buf[offset]), &buf[len - len_remain],\n\t\t       tx_len);\n\t\toffset += tx_len;\n\n\t\tret = ath6kl_hif_bmi_write(ar, ar->bmi.cmd_buf, offset);\n\t\tif (ret) {\n\t\t\tath6kl_err(\"Unable to write to the device: %d\\n\",\n\t\t\t\t   ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tlen_remain -= tx_len;\n\t}\n\n\treturn 0;\n}\n\nint ath6kl_bmi_lz_stream_start(struct ath6kl *ar, u32 addr)\n{\n\tu32 cid = BMI_LZ_STREAM_START;\n\tint ret;\n\tu32 offset;\n\tu16 size;\n\n\tif (ar->bmi.done_sent) {\n\t\tath6kl_err(\"bmi done sent already, cmd %d disallowed\\n\", cid);\n\t\treturn -EACCES;\n\t}\n\n\tsize = sizeof(cid) + sizeof(addr);\n\tif (size > ar->bmi.max_cmd_size) {\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\tmemset(ar->bmi.cmd_buf, 0, size);\n\n\tath6kl_dbg(ATH6KL_DBG_BMI,\n\t\t   \"bmi LZ stream start: addr: 0x%x)\\n\",\n\t\t    addr);\n\n\toffset = 0;\n\tmemcpy(&(ar->bmi.cmd_buf[offset]), &cid, sizeof(cid));\n\toffset += sizeof(cid);\n\tmemcpy(&(ar->bmi.cmd_buf[offset]), &addr, sizeof(addr));\n\toffset += sizeof(addr);\n\n\tret = ath6kl_hif_bmi_write(ar, ar->bmi.cmd_buf, offset);\n\tif (ret) {\n\t\tath6kl_err(\"Unable to start LZ stream to the device: %d\\n\",\n\t\t\t   ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint ath6kl_bmi_fast_download(struct ath6kl *ar, u32 addr, u8 *buf, u32 len)\n{\n\tint ret;\n\tu32 last_word = 0;\n\tu32 last_word_offset = len & ~0x3;\n\tu32 unaligned_bytes = len & 0x3;\n\n\tret = ath6kl_bmi_lz_stream_start(ar, addr);\n\tif (ret)\n\t\treturn ret;\n\n\tif (unaligned_bytes) {\n\t\t \n\t\tmemcpy(&last_word, &buf[last_word_offset], unaligned_bytes);\n\t}\n\n\tret = ath6kl_bmi_lz_data(ar, buf, last_word_offset);\n\tif (ret)\n\t\treturn ret;\n\n\tif (unaligned_bytes)\n\t\tret = ath6kl_bmi_lz_data(ar, (u8 *)&last_word, 4);\n\n\tif (!ret) {\n\t\t \n\t\tret = ath6kl_bmi_lz_stream_start(ar, 0x00);\n\t}\n\treturn ret;\n}\n\nvoid ath6kl_bmi_reset(struct ath6kl *ar)\n{\n\tar->bmi.done_sent = false;\n}\n\nint ath6kl_bmi_init(struct ath6kl *ar)\n{\n\tif (WARN_ON(ar->bmi.max_data_size == 0))\n\t\treturn -EINVAL;\n\n\t \n\tar->bmi.max_cmd_size = ar->bmi.max_data_size + (sizeof(u32) * 3);\n\n\tar->bmi.cmd_buf = kzalloc(ar->bmi.max_cmd_size, GFP_KERNEL);\n\tif (!ar->bmi.cmd_buf)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nvoid ath6kl_bmi_cleanup(struct ath6kl *ar)\n{\n\tkfree(ar->bmi.cmd_buf);\n\tar->bmi.cmd_buf = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}