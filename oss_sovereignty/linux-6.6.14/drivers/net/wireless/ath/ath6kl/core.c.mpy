{
  "module_name": "core.c",
  "hash_id": "a959a802a535612e75ec56e1baa42d0f1d82883c84d9618c894659010b4ad531",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath6kl/core.c",
  "human_readable_source": " \n\n#include \"core.h\"\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n\n#include \"debug.h\"\n#include \"hif-ops.h\"\n#include \"htc-ops.h\"\n#include \"cfg80211.h\"\n\nunsigned int debug_mask;\nstatic unsigned int suspend_mode;\nstatic unsigned int wow_mode;\nstatic unsigned int uart_debug;\nstatic unsigned int uart_rate = 115200;\nstatic unsigned int ath6kl_p2p;\nstatic unsigned int testmode;\nstatic unsigned int recovery_enable;\nstatic unsigned int heart_beat_poll;\n\nmodule_param(debug_mask, uint, 0644);\nmodule_param(suspend_mode, uint, 0644);\nmodule_param(wow_mode, uint, 0644);\nmodule_param(uart_debug, uint, 0644);\nmodule_param(uart_rate, uint, 0644);\nmodule_param(ath6kl_p2p, uint, 0644);\nmodule_param(testmode, uint, 0644);\nmodule_param(recovery_enable, uint, 0644);\nmodule_param(heart_beat_poll, uint, 0644);\nMODULE_PARM_DESC(recovery_enable, \"Enable recovery from firmware error\");\nMODULE_PARM_DESC(heart_beat_poll,\n\t\t \"Enable fw error detection periodic polling in msecs - Also set recovery_enable for this to be effective\");\n\n\nvoid ath6kl_core_tx_complete(struct ath6kl *ar, struct sk_buff *skb)\n{\n\tath6kl_htc_tx_complete(ar, skb);\n}\nEXPORT_SYMBOL(ath6kl_core_tx_complete);\n\nvoid ath6kl_core_rx_complete(struct ath6kl *ar, struct sk_buff *skb, u8 pipe)\n{\n\tath6kl_htc_rx_complete(ar, skb, pipe);\n}\nEXPORT_SYMBOL(ath6kl_core_rx_complete);\n\nint ath6kl_core_init(struct ath6kl *ar, enum ath6kl_htc_type htc_type)\n{\n\tstruct ath6kl_bmi_target_info targ_info;\n\tstruct wireless_dev *wdev;\n\tint ret = 0, i;\n\n\tswitch (htc_type) {\n\tcase ATH6KL_HTC_TYPE_MBOX:\n\t\tath6kl_htc_mbox_attach(ar);\n\t\tbreak;\n\tcase ATH6KL_HTC_TYPE_PIPE:\n\t\tath6kl_htc_pipe_attach(ar);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -ENOMEM;\n\t}\n\n\tar->ath6kl_wq = create_singlethread_workqueue(\"ath6kl\");\n\tif (!ar->ath6kl_wq)\n\t\treturn -ENOMEM;\n\n\tret = ath6kl_bmi_init(ar);\n\tif (ret)\n\t\tgoto err_wq;\n\n\t \n\tret = ath6kl_hif_power_on(ar);\n\tif (ret)\n\t\tgoto err_bmi_cleanup;\n\n\tret = ath6kl_bmi_get_target_info(ar, &targ_info);\n\tif (ret)\n\t\tgoto err_power_off;\n\n\tar->version.target_ver = le32_to_cpu(targ_info.version);\n\tar->target_type = le32_to_cpu(targ_info.type);\n\tar->wiphy->hw_version = le32_to_cpu(targ_info.version);\n\n\tret = ath6kl_init_hw_params(ar);\n\tif (ret)\n\t\tgoto err_power_off;\n\n\tar->htc_target = ath6kl_htc_create(ar);\n\n\tif (!ar->htc_target) {\n\t\tret = -ENOMEM;\n\t\tgoto err_power_off;\n\t}\n\n\tar->testmode = testmode;\n\n\tret = ath6kl_init_fetch_firmwares(ar);\n\tif (ret)\n\t\tgoto err_htc_cleanup;\n\n\t \n\n\t \n\tif (ar->target_type == TARGET_TYPE_AR6004 &&\n\t    ar->fw_api <= 4) {\n\t\t__set_bit(ATH6KL_FW_CAPABILITY_64BIT_RATES,\n\t\t\t  ar->fw_capabilities);\n\t\t__set_bit(ATH6KL_FW_CAPABILITY_AP_INACTIVITY_MINS,\n\t\t\t  ar->fw_capabilities);\n\n\t\tif (ar->hw.id == AR6004_HW_1_3_VERSION)\n\t\t\t__set_bit(ATH6KL_FW_CAPABILITY_MAP_LP_ENDPOINT,\n\t\t\t\t  ar->fw_capabilities);\n\t}\n\n\t \n\tset_bit(WMI_ENABLED, &ar->flag);\n\tar->wmi = ath6kl_wmi_init(ar);\n\tif (!ar->wmi) {\n\t\tath6kl_err(\"failed to initialize wmi\\n\");\n\t\tret = -EIO;\n\t\tgoto err_htc_cleanup;\n\t}\n\n\tath6kl_dbg(ATH6KL_DBG_TRC, \"%s: got wmi @ 0x%p.\\n\", __func__, ar->wmi);\n\n\t \n\tar->ac_stream_pri_map[WMM_AC_BK] = 0;  \n\tar->ac_stream_pri_map[WMM_AC_BE] = 1;\n\tar->ac_stream_pri_map[WMM_AC_VI] = 2;\n\tar->ac_stream_pri_map[WMM_AC_VO] = 3;  \n\n\t \n\tath6kl_refill_amsdu_rxbufs(ar, ATH6KL_MAX_AMSDU_RX_BUFFERS);\n\n\tath6kl_cookie_init(ar);\n\n\tar->conf_flags = ATH6KL_CONF_IGNORE_ERP_BARKER |\n\t\t\t ATH6KL_CONF_ENABLE_11N | ATH6KL_CONF_ENABLE_TX_BURST;\n\n\tif (suspend_mode &&\n\t    suspend_mode >= WLAN_POWER_STATE_CUT_PWR &&\n\t    suspend_mode <= WLAN_POWER_STATE_WOW)\n\t\tar->suspend_mode = suspend_mode;\n\telse\n\t\tar->suspend_mode = 0;\n\n\tif (suspend_mode == WLAN_POWER_STATE_WOW &&\n\t    (wow_mode == WLAN_POWER_STATE_CUT_PWR ||\n\t     wow_mode == WLAN_POWER_STATE_DEEP_SLEEP))\n\t\tar->wow_suspend_mode = wow_mode;\n\telse\n\t\tar->wow_suspend_mode = 0;\n\n\tif (uart_debug)\n\t\tar->conf_flags |= ATH6KL_CONF_UART_DEBUG;\n\tar->hw.uarttx_rate = uart_rate;\n\n\tset_bit(FIRST_BOOT, &ar->flag);\n\n\tath6kl_debug_init(ar);\n\n\tret = ath6kl_init_hw_start(ar);\n\tif (ret) {\n\t\tath6kl_err(\"Failed to start hardware: %d\\n\", ret);\n\t\tgoto err_rxbuf_cleanup;\n\t}\n\n\t \n\tath6kl_rx_refill(ar->htc_target, ar->ctrl_ep);\n\tath6kl_rx_refill(ar->htc_target, ar->ac2ep_map[WMM_AC_BE]);\n\n\tret = ath6kl_cfg80211_init(ar);\n\tif (ret)\n\t\tgoto err_rxbuf_cleanup;\n\n\tret = ath6kl_debug_init_fs(ar);\n\tif (ret) {\n\t\twiphy_unregister(ar->wiphy);\n\t\tgoto err_rxbuf_cleanup;\n\t}\n\n\tfor (i = 0; i < ar->vif_max; i++)\n\t\tar->avail_idx_map |= BIT(i);\n\n\trtnl_lock();\n\twiphy_lock(ar->wiphy);\n\n\t \n\twdev = ath6kl_interface_add(ar, \"wlan%d\", NET_NAME_ENUM,\n\t\t\t\t    NL80211_IFTYPE_STATION, 0, INFRA_NETWORK);\n\n\twiphy_unlock(ar->wiphy);\n\trtnl_unlock();\n\n\tif (!wdev) {\n\t\tath6kl_err(\"Failed to instantiate a network device\\n\");\n\t\tret = -ENOMEM;\n\t\twiphy_unregister(ar->wiphy);\n\t\tgoto err_rxbuf_cleanup;\n\t}\n\n\tath6kl_dbg(ATH6KL_DBG_TRC, \"%s: name=%s dev=0x%p, ar=0x%p\\n\",\n\t\t   __func__, wdev->netdev->name, wdev->netdev, ar);\n\n\tar->fw_recovery.enable = !!recovery_enable;\n\tif (!ar->fw_recovery.enable)\n\t\treturn ret;\n\n\tif (heart_beat_poll &&\n\t    test_bit(ATH6KL_FW_CAPABILITY_HEART_BEAT_POLL,\n\t\t     ar->fw_capabilities))\n\t\tar->fw_recovery.hb_poll = heart_beat_poll;\n\n\tath6kl_recovery_init(ar);\n\n\treturn ret;\n\nerr_rxbuf_cleanup:\n\tath6kl_debug_cleanup(ar);\n\tath6kl_htc_flush_rx_buf(ar->htc_target);\n\tath6kl_cleanup_amsdu_rxbufs(ar);\n\tath6kl_wmi_shutdown(ar->wmi);\n\tclear_bit(WMI_ENABLED, &ar->flag);\n\tar->wmi = NULL;\nerr_htc_cleanup:\n\tath6kl_htc_cleanup(ar->htc_target);\nerr_power_off:\n\tath6kl_hif_power_off(ar);\nerr_bmi_cleanup:\n\tath6kl_bmi_cleanup(ar);\nerr_wq:\n\tdestroy_workqueue(ar->ath6kl_wq);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(ath6kl_core_init);\n\nstruct ath6kl *ath6kl_core_create(struct device *dev)\n{\n\tstruct ath6kl *ar;\n\tu8 ctr;\n\n\tar = ath6kl_cfg80211_create();\n\tif (!ar)\n\t\treturn NULL;\n\n\tar->p2p = !!ath6kl_p2p;\n\tar->dev = dev;\n\n\tar->vif_max = 1;\n\n\tar->max_norm_iface = 1;\n\n\tspin_lock_init(&ar->lock);\n\tspin_lock_init(&ar->mcastpsq_lock);\n\tspin_lock_init(&ar->list_lock);\n\n\tinit_waitqueue_head(&ar->event_wq);\n\tsema_init(&ar->sem, 1);\n\n\tINIT_LIST_HEAD(&ar->amsdu_rx_buffer_queue);\n\tINIT_LIST_HEAD(&ar->vif_list);\n\n\tclear_bit(WMI_ENABLED, &ar->flag);\n\tclear_bit(SKIP_SCAN, &ar->flag);\n\tclear_bit(DESTROY_IN_PROGRESS, &ar->flag);\n\n\tar->tx_pwr = 0;\n\tar->intra_bss = 1;\n\tar->lrssi_roam_threshold = DEF_LRSSI_ROAM_THRESHOLD;\n\n\tar->state = ATH6KL_STATE_OFF;\n\n\tmemset((u8 *)ar->sta_list, 0,\n\t       AP_MAX_NUM_STA * sizeof(struct ath6kl_sta));\n\n\t \n\tfor (ctr = 0; ctr < AP_MAX_NUM_STA; ctr++) {\n\t\tspin_lock_init(&ar->sta_list[ctr].psq_lock);\n\t\tskb_queue_head_init(&ar->sta_list[ctr].psq);\n\t\tskb_queue_head_init(&ar->sta_list[ctr].apsdq);\n\t\tar->sta_list[ctr].mgmt_psq_len = 0;\n\t\tINIT_LIST_HEAD(&ar->sta_list[ctr].mgmt_psq);\n\t\tar->sta_list[ctr].aggr_conn =\n\t\t\tkzalloc(sizeof(struct aggr_info_conn), GFP_KERNEL);\n\t\tif (!ar->sta_list[ctr].aggr_conn) {\n\t\t\tath6kl_err(\"Failed to allocate memory for sta aggregation information\\n\");\n\t\t\tath6kl_core_destroy(ar);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tskb_queue_head_init(&ar->mcastpsq);\n\n\tmemcpy(ar->ap_country_code, DEF_AP_COUNTRY_CODE, 3);\n\n\treturn ar;\n}\nEXPORT_SYMBOL(ath6kl_core_create);\n\nvoid ath6kl_core_cleanup(struct ath6kl *ar)\n{\n\tath6kl_hif_power_off(ar);\n\n\tath6kl_recovery_cleanup(ar);\n\n\tdestroy_workqueue(ar->ath6kl_wq);\n\n\tif (ar->htc_target)\n\t\tath6kl_htc_cleanup(ar->htc_target);\n\n\tath6kl_cookie_cleanup(ar);\n\n\tath6kl_cleanup_amsdu_rxbufs(ar);\n\n\tath6kl_bmi_cleanup(ar);\n\n\tath6kl_debug_cleanup(ar);\n\n\tkfree(ar->fw_board);\n\tkfree(ar->fw_otp);\n\tvfree(ar->fw);\n\tkfree(ar->fw_patch);\n\tkfree(ar->fw_testscript);\n\n\tath6kl_cfg80211_cleanup(ar);\n}\nEXPORT_SYMBOL(ath6kl_core_cleanup);\n\nvoid ath6kl_core_destroy(struct ath6kl *ar)\n{\n\tath6kl_cfg80211_destroy(ar);\n}\nEXPORT_SYMBOL(ath6kl_core_destroy);\n\nMODULE_AUTHOR(\"Qualcomm Atheros\");\nMODULE_DESCRIPTION(\"Core module for AR600x SDIO and USB devices.\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}