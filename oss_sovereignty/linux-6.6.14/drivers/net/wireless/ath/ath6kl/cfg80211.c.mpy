{
  "module_name": "cfg80211.c",
  "hash_id": "067d1ded7a4855a46bb70cc6b9c903a14b4a97f393088771c4a98a377a446a60",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath6kl/cfg80211.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/moduleparam.h>\n#include <linux/inetdevice.h>\n#include <linux/export.h>\n#include <linux/sched/signal.h>\n\n#include \"core.h\"\n#include \"cfg80211.h\"\n#include \"debug.h\"\n#include \"hif-ops.h\"\n#include \"testmode.h\"\n\n#define RATETAB_ENT(_rate, _rateid, _flags) {   \\\n\t.bitrate    = (_rate),                  \\\n\t.flags      = (_flags),                 \\\n\t.hw_value   = (_rateid),                \\\n}\n\n#define CHAN2G(_channel, _freq, _flags) {   \\\n\t.band           = NL80211_BAND_2GHZ,  \\\n\t.hw_value       = (_channel),           \\\n\t.center_freq    = (_freq),              \\\n\t.flags          = (_flags),             \\\n\t.max_antenna_gain   = 0,                \\\n\t.max_power      = 30,                   \\\n}\n\n#define CHAN5G(_channel, _flags) {\t\t    \\\n\t.band           = NL80211_BAND_5GHZ,      \\\n\t.hw_value       = (_channel),               \\\n\t.center_freq    = 5000 + (5 * (_channel)),  \\\n\t.flags          = (_flags),                 \\\n\t.max_antenna_gain   = 0,                    \\\n\t.max_power      = 30,                       \\\n}\n\n#define DEFAULT_BG_SCAN_PERIOD 60\n\nstruct ath6kl_cfg80211_match_probe_ssid {\n\tstruct cfg80211_ssid ssid;\n\tu8 flag;\n};\n\nstatic struct ieee80211_rate ath6kl_rates[] = {\n\tRATETAB_ENT(10, 0x1, 0),\n\tRATETAB_ENT(20, 0x2, 0),\n\tRATETAB_ENT(55, 0x4, 0),\n\tRATETAB_ENT(110, 0x8, 0),\n\tRATETAB_ENT(60, 0x10, 0),\n\tRATETAB_ENT(90, 0x20, 0),\n\tRATETAB_ENT(120, 0x40, 0),\n\tRATETAB_ENT(180, 0x80, 0),\n\tRATETAB_ENT(240, 0x100, 0),\n\tRATETAB_ENT(360, 0x200, 0),\n\tRATETAB_ENT(480, 0x400, 0),\n\tRATETAB_ENT(540, 0x800, 0),\n};\n\n#define ath6kl_a_rates     (ath6kl_rates + 4)\n#define ath6kl_a_rates_size    8\n#define ath6kl_g_rates     (ath6kl_rates + 0)\n#define ath6kl_g_rates_size    12\n\n#define ath6kl_g_htcap IEEE80211_HT_CAP_SGI_20\n#define ath6kl_a_htcap (IEEE80211_HT_CAP_SUP_WIDTH_20_40 | \\\n\t\t\tIEEE80211_HT_CAP_SGI_20\t\t | \\\n\t\t\tIEEE80211_HT_CAP_SGI_40)\n\nstatic struct ieee80211_channel ath6kl_2ghz_channels[] = {\n\tCHAN2G(1, 2412, 0),\n\tCHAN2G(2, 2417, 0),\n\tCHAN2G(3, 2422, 0),\n\tCHAN2G(4, 2427, 0),\n\tCHAN2G(5, 2432, 0),\n\tCHAN2G(6, 2437, 0),\n\tCHAN2G(7, 2442, 0),\n\tCHAN2G(8, 2447, 0),\n\tCHAN2G(9, 2452, 0),\n\tCHAN2G(10, 2457, 0),\n\tCHAN2G(11, 2462, 0),\n\tCHAN2G(12, 2467, 0),\n\tCHAN2G(13, 2472, 0),\n\tCHAN2G(14, 2484, 0),\n};\n\nstatic struct ieee80211_channel ath6kl_5ghz_a_channels[] = {\n\tCHAN5G(36, 0), CHAN5G(40, 0),\n\tCHAN5G(44, 0), CHAN5G(48, 0),\n\tCHAN5G(52, 0), CHAN5G(56, 0),\n\tCHAN5G(60, 0), CHAN5G(64, 0),\n\tCHAN5G(100, 0), CHAN5G(104, 0),\n\tCHAN5G(108, 0), CHAN5G(112, 0),\n\tCHAN5G(116, 0), CHAN5G(120, 0),\n\tCHAN5G(124, 0), CHAN5G(128, 0),\n\tCHAN5G(132, 0), CHAN5G(136, 0),\n\tCHAN5G(140, 0), CHAN5G(149, 0),\n\tCHAN5G(153, 0), CHAN5G(157, 0),\n\tCHAN5G(161, 0), CHAN5G(165, 0),\n\tCHAN5G(184, 0), CHAN5G(188, 0),\n\tCHAN5G(192, 0), CHAN5G(196, 0),\n\tCHAN5G(200, 0), CHAN5G(204, 0),\n\tCHAN5G(208, 0), CHAN5G(212, 0),\n\tCHAN5G(216, 0),\n};\n\nstatic struct ieee80211_supported_band ath6kl_band_2ghz = {\n\t.n_channels = ARRAY_SIZE(ath6kl_2ghz_channels),\n\t.channels = ath6kl_2ghz_channels,\n\t.n_bitrates = ath6kl_g_rates_size,\n\t.bitrates = ath6kl_g_rates,\n\t.ht_cap.cap = ath6kl_g_htcap,\n\t.ht_cap.ht_supported = true,\n};\n\nstatic struct ieee80211_supported_band ath6kl_band_5ghz = {\n\t.n_channels = ARRAY_SIZE(ath6kl_5ghz_a_channels),\n\t.channels = ath6kl_5ghz_a_channels,\n\t.n_bitrates = ath6kl_a_rates_size,\n\t.bitrates = ath6kl_a_rates,\n\t.ht_cap.cap = ath6kl_a_htcap,\n\t.ht_cap.ht_supported = true,\n};\n\n#define CCKM_KRK_CIPHER_SUITE 0x004096ff  \n\n \nstatic bool __ath6kl_cfg80211_sscan_stop(struct ath6kl_vif *vif)\n{\n\tstruct ath6kl *ar = vif->ar;\n\n\tif (!test_and_clear_bit(SCHED_SCANNING, &vif->flags))\n\t\treturn false;\n\n\tdel_timer_sync(&vif->sched_scan_timer);\n\n\tif (ar->state == ATH6KL_STATE_RECOVERY)\n\t\treturn true;\n\n\tath6kl_wmi_enable_sched_scan_cmd(ar->wmi, vif->fw_vif_idx, false);\n\n\treturn true;\n}\n\nstatic void ath6kl_cfg80211_sscan_disable(struct ath6kl_vif *vif)\n{\n\tstruct ath6kl *ar = vif->ar;\n\tbool stopped;\n\n\tstopped = __ath6kl_cfg80211_sscan_stop(vif);\n\n\tif (!stopped)\n\t\treturn;\n\n\tcfg80211_sched_scan_stopped(ar->wiphy, 0);\n}\n\nstatic int ath6kl_set_wpa_version(struct ath6kl_vif *vif,\n\t\t\t\t  enum nl80211_wpa_versions wpa_version)\n{\n\tath6kl_dbg(ATH6KL_DBG_WLAN_CFG, \"%s: %u\\n\", __func__, wpa_version);\n\n\tif (!wpa_version) {\n\t\tvif->auth_mode = NONE_AUTH;\n\t} else if (wpa_version & NL80211_WPA_VERSION_2) {\n\t\tvif->auth_mode = WPA2_AUTH;\n\t} else if (wpa_version & NL80211_WPA_VERSION_1) {\n\t\tvif->auth_mode = WPA_AUTH;\n\t} else {\n\t\tath6kl_err(\"%s: %u not supported\\n\", __func__, wpa_version);\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath6kl_set_auth_type(struct ath6kl_vif *vif,\n\t\t\t\tenum nl80211_auth_type auth_type)\n{\n\tath6kl_dbg(ATH6KL_DBG_WLAN_CFG, \"%s: 0x%x\\n\", __func__, auth_type);\n\n\tswitch (auth_type) {\n\tcase NL80211_AUTHTYPE_OPEN_SYSTEM:\n\t\tvif->dot11_auth_mode = OPEN_AUTH;\n\t\tbreak;\n\tcase NL80211_AUTHTYPE_SHARED_KEY:\n\t\tvif->dot11_auth_mode = SHARED_AUTH;\n\t\tbreak;\n\tcase NL80211_AUTHTYPE_NETWORK_EAP:\n\t\tvif->dot11_auth_mode = LEAP_AUTH;\n\t\tbreak;\n\n\tcase NL80211_AUTHTYPE_AUTOMATIC:\n\t\tvif->dot11_auth_mode = OPEN_AUTH | SHARED_AUTH;\n\t\tbreak;\n\n\tdefault:\n\t\tath6kl_err(\"%s: 0x%x not supported\\n\", __func__, auth_type);\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath6kl_set_cipher(struct ath6kl_vif *vif, u32 cipher, bool ucast)\n{\n\tu8 *ar_cipher = ucast ? &vif->prwise_crypto : &vif->grp_crypto;\n\tu8 *ar_cipher_len = ucast ? &vif->prwise_crypto_len :\n\t\t&vif->grp_crypto_len;\n\n\tath6kl_dbg(ATH6KL_DBG_WLAN_CFG, \"%s: cipher 0x%x, ucast %u\\n\",\n\t\t   __func__, cipher, ucast);\n\n\tswitch (cipher) {\n\tcase 0:\n\t\t \n\t\t*ar_cipher = NONE_CRYPT;\n\t\t*ar_cipher_len = 0;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\t*ar_cipher = WEP_CRYPT;\n\t\t*ar_cipher_len = 5;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\t*ar_cipher = WEP_CRYPT;\n\t\t*ar_cipher_len = 13;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\t*ar_cipher = TKIP_CRYPT;\n\t\t*ar_cipher_len = 0;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\t*ar_cipher = AES_CRYPT;\n\t\t*ar_cipher_len = 0;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_SMS4:\n\t\t*ar_cipher = WAPI_CRYPT;\n\t\t*ar_cipher_len = 0;\n\t\tbreak;\n\tdefault:\n\t\tath6kl_err(\"cipher 0x%x not supported\\n\", cipher);\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic void ath6kl_set_key_mgmt(struct ath6kl_vif *vif, u32 key_mgmt)\n{\n\tath6kl_dbg(ATH6KL_DBG_WLAN_CFG, \"%s: 0x%x\\n\", __func__, key_mgmt);\n\n\tif (key_mgmt == WLAN_AKM_SUITE_PSK) {\n\t\tif (vif->auth_mode == WPA_AUTH)\n\t\t\tvif->auth_mode = WPA_PSK_AUTH;\n\t\telse if (vif->auth_mode == WPA2_AUTH)\n\t\t\tvif->auth_mode = WPA2_PSK_AUTH;\n\t} else if (key_mgmt == 0x00409600) {\n\t\tif (vif->auth_mode == WPA_AUTH)\n\t\t\tvif->auth_mode = WPA_AUTH_CCKM;\n\t\telse if (vif->auth_mode == WPA2_AUTH)\n\t\t\tvif->auth_mode = WPA2_AUTH_CCKM;\n\t} else if (key_mgmt != WLAN_AKM_SUITE_8021X) {\n\t\tvif->auth_mode = NONE_AUTH;\n\t}\n}\n\nstatic bool ath6kl_cfg80211_ready(struct ath6kl_vif *vif)\n{\n\tstruct ath6kl *ar = vif->ar;\n\n\tif (!test_bit(WMI_READY, &ar->flag)) {\n\t\tath6kl_err(\"wmi is not ready\\n\");\n\t\treturn false;\n\t}\n\n\tif (!test_bit(WLAN_ENABLED, &vif->flags)) {\n\t\tath6kl_dbg(ATH6KL_DBG_WLAN_CFG, \"wlan disabled\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool ath6kl_is_wpa_ie(const u8 *pos)\n{\n\treturn pos[0] == WLAN_EID_VENDOR_SPECIFIC && pos[1] >= 4 &&\n\t\tpos[2] == 0x00 && pos[3] == 0x50 &&\n\t\tpos[4] == 0xf2 && pos[5] == 0x01;\n}\n\nstatic bool ath6kl_is_rsn_ie(const u8 *pos)\n{\n\treturn pos[0] == WLAN_EID_RSN;\n}\n\nstatic bool ath6kl_is_wps_ie(const u8 *pos)\n{\n\treturn (pos[0] == WLAN_EID_VENDOR_SPECIFIC &&\n\t\tpos[1] >= 4 &&\n\t\tpos[2] == 0x00 && pos[3] == 0x50 && pos[4] == 0xf2 &&\n\t\tpos[5] == 0x04);\n}\n\nstatic int ath6kl_set_assoc_req_ies(struct ath6kl_vif *vif, const u8 *ies,\n\t\t\t\t    size_t ies_len)\n{\n\tstruct ath6kl *ar = vif->ar;\n\tconst u8 *pos;\n\tu8 *buf = NULL;\n\tsize_t len = 0;\n\tint ret;\n\n\t \n\n\tar->connect_ctrl_flags &= ~CONNECT_WPS_FLAG;\n\n\t \n\n\tif (ies && ies_len) {\n\t\tbuf = kmalloc(ies_len, GFP_KERNEL);\n\t\tif (buf == NULL)\n\t\t\treturn -ENOMEM;\n\t\tpos = ies;\n\n\t\twhile (pos + 1 < ies + ies_len) {\n\t\t\tif (pos + 2 + pos[1] > ies + ies_len)\n\t\t\t\tbreak;\n\t\t\tif (!(ath6kl_is_wpa_ie(pos) || ath6kl_is_rsn_ie(pos))) {\n\t\t\t\tmemcpy(buf + len, pos, 2 + pos[1]);\n\t\t\t\tlen += 2 + pos[1];\n\t\t\t}\n\n\t\t\tif (ath6kl_is_wps_ie(pos))\n\t\t\t\tar->connect_ctrl_flags |= CONNECT_WPS_FLAG;\n\n\t\t\tpos += 2 + pos[1];\n\t\t}\n\t}\n\n\tret = ath6kl_wmi_set_appie_cmd(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t       WMI_FRAME_ASSOC_REQ, buf, len);\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic int ath6kl_nliftype_to_drv_iftype(enum nl80211_iftype type, u8 *nw_type)\n{\n\tswitch (type) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\t*nw_type = INFRA_NETWORK;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\t*nw_type = ADHOC_NETWORK;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\t*nw_type = AP_NETWORK;\n\t\tbreak;\n\tdefault:\n\t\tath6kl_err(\"invalid interface type %u\\n\", type);\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic bool ath6kl_is_valid_iftype(struct ath6kl *ar, enum nl80211_iftype type,\n\t\t\t\t   u8 *if_idx, u8 *nw_type)\n{\n\tint i;\n\n\tif (ath6kl_nliftype_to_drv_iftype(type, nw_type))\n\t\treturn false;\n\n\tif (ar->ibss_if_active || ((type == NL80211_IFTYPE_ADHOC) &&\n\t\t\t\t   ar->num_vif))\n\t\treturn false;\n\n\tif (type == NL80211_IFTYPE_STATION ||\n\t    type == NL80211_IFTYPE_AP || type == NL80211_IFTYPE_ADHOC) {\n\t\tfor (i = 0; i < ar->vif_max; i++) {\n\t\t\tif ((ar->avail_idx_map) & BIT(i)) {\n\t\t\t\t*if_idx = i;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (type == NL80211_IFTYPE_P2P_CLIENT ||\n\t    type == NL80211_IFTYPE_P2P_GO) {\n\t\tfor (i = ar->max_norm_iface; i < ar->vif_max; i++) {\n\t\t\tif ((ar->avail_idx_map) & BIT(i)) {\n\t\t\t\t*if_idx = i;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic bool ath6kl_is_tx_pending(struct ath6kl *ar)\n{\n\treturn ar->tx_pending[ath6kl_wmi_get_control_ep(ar->wmi)] == 0;\n}\n\nstatic void ath6kl_cfg80211_sta_bmiss_enhance(struct ath6kl_vif *vif,\n\t\t\t\t\t      bool enable)\n{\n\tint err;\n\n\tif (WARN_ON(!test_bit(WMI_READY, &vif->ar->flag)))\n\t\treturn;\n\n\tif (vif->nw_type != INFRA_NETWORK)\n\t\treturn;\n\n\tif (!test_bit(ATH6KL_FW_CAPABILITY_BMISS_ENHANCE,\n\t\t      vif->ar->fw_capabilities))\n\t\treturn;\n\n\tath6kl_dbg(ATH6KL_DBG_WLAN_CFG, \"%s fw bmiss enhance\\n\",\n\t\t   enable ? \"enable\" : \"disable\");\n\n\terr = ath6kl_wmi_sta_bmiss_enhance_cmd(vif->ar->wmi,\n\t\t\t\t\t       vif->fw_vif_idx, enable);\n\tif (err)\n\t\tath6kl_err(\"failed to %s enhanced bmiss detection: %d\\n\",\n\t\t\t   enable ? \"enable\" : \"disable\", err);\n}\n\nstatic int ath6kl_cfg80211_connect(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t   struct cfg80211_connect_params *sme)\n{\n\tstruct ath6kl *ar = ath6kl_priv(dev);\n\tstruct ath6kl_vif *vif = netdev_priv(dev);\n\tint status;\n\tu8 nw_subtype = (ar->p2p) ? SUBTYPE_P2PDEV : SUBTYPE_NONE;\n\tu16 interval;\n\n\tath6kl_cfg80211_sscan_disable(vif);\n\n\tvif->sme_state = SME_CONNECTING;\n\n\tif (!ath6kl_cfg80211_ready(vif))\n\t\treturn -EIO;\n\n\tif (test_bit(DESTROY_IN_PROGRESS, &ar->flag)) {\n\t\tath6kl_err(\"destroy in progress\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (test_bit(SKIP_SCAN, &ar->flag) &&\n\t    ((sme->channel && sme->channel->center_freq == 0) ||\n\t     (sme->bssid && is_zero_ether_addr(sme->bssid)))) {\n\t\tath6kl_err(\"SkipScan: channel or bssid invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (down_interruptible(&ar->sem)) {\n\t\tath6kl_err(\"busy, couldn't get access\\n\");\n\t\treturn -ERESTARTSYS;\n\t}\n\n\tif (test_bit(DESTROY_IN_PROGRESS, &ar->flag)) {\n\t\tath6kl_err(\"busy, destroy in progress\\n\");\n\t\tup(&ar->sem);\n\t\treturn -EBUSY;\n\t}\n\n\tif (ar->tx_pending[ath6kl_wmi_get_control_ep(ar->wmi)]) {\n\t\t \n\t\twait_event_interruptible_timeout(ar->event_wq,\n\t\t\t\t\t\t ath6kl_is_tx_pending(ar),\n\t\t\t\t\t\t WMI_TIMEOUT);\n\t\tif (signal_pending(current)) {\n\t\t\tath6kl_err(\"cmd queue drain timeout\\n\");\n\t\t\tup(&ar->sem);\n\t\t\treturn -EINTR;\n\t\t}\n\t}\n\n\tstatus = ath6kl_set_assoc_req_ies(vif, sme->ie, sme->ie_len);\n\tif (status) {\n\t\tup(&ar->sem);\n\t\treturn status;\n\t}\n\n\tif (sme->ie == NULL || sme->ie_len == 0)\n\t\tar->connect_ctrl_flags &= ~CONNECT_WPS_FLAG;\n\n\tif (test_bit(CONNECTED, &vif->flags) &&\n\t    vif->ssid_len == sme->ssid_len &&\n\t    !memcmp(vif->ssid, sme->ssid, vif->ssid_len)) {\n\t\tvif->reconnect_flag = true;\n\t\tstatus = ath6kl_wmi_reconnect_cmd(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t\t\t  vif->req_bssid,\n\t\t\t\t\t\t  vif->ch_hint);\n\n\t\tup(&ar->sem);\n\t\tif (status) {\n\t\t\tath6kl_err(\"wmi_reconnect_cmd failed\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t\treturn 0;\n\t} else if (vif->ssid_len == sme->ssid_len &&\n\t\t   !memcmp(vif->ssid, sme->ssid, vif->ssid_len)) {\n\t\tath6kl_disconnect(vif);\n\t}\n\n\tmemset(vif->ssid, 0, sizeof(vif->ssid));\n\tvif->ssid_len = sme->ssid_len;\n\tmemcpy(vif->ssid, sme->ssid, sme->ssid_len);\n\n\tif (sme->channel)\n\t\tvif->ch_hint = sme->channel->center_freq;\n\n\tmemset(vif->req_bssid, 0, sizeof(vif->req_bssid));\n\tif (sme->bssid && !is_broadcast_ether_addr(sme->bssid))\n\t\tmemcpy(vif->req_bssid, sme->bssid, sizeof(vif->req_bssid));\n\n\tath6kl_set_wpa_version(vif, sme->crypto.wpa_versions);\n\n\tstatus = ath6kl_set_auth_type(vif, sme->auth_type);\n\tif (status) {\n\t\tup(&ar->sem);\n\t\treturn status;\n\t}\n\n\tif (sme->crypto.n_ciphers_pairwise)\n\t\tath6kl_set_cipher(vif, sme->crypto.ciphers_pairwise[0], true);\n\telse\n\t\tath6kl_set_cipher(vif, 0, true);\n\n\tath6kl_set_cipher(vif, sme->crypto.cipher_group, false);\n\n\tif (sme->crypto.n_akm_suites)\n\t\tath6kl_set_key_mgmt(vif, sme->crypto.akm_suites[0]);\n\n\tif ((sme->key_len) &&\n\t    (vif->auth_mode == NONE_AUTH) &&\n\t    (vif->prwise_crypto == WEP_CRYPT)) {\n\t\tstruct ath6kl_key *key = NULL;\n\n\t\tif (sme->key_idx > WMI_MAX_KEY_INDEX) {\n\t\t\tath6kl_err(\"key index %d out of bounds\\n\",\n\t\t\t\t   sme->key_idx);\n\t\t\tup(&ar->sem);\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tkey = &vif->keys[sme->key_idx];\n\t\tkey->key_len = sme->key_len;\n\t\tmemcpy(key->key, sme->key, key->key_len);\n\t\tkey->cipher = vif->prwise_crypto;\n\t\tvif->def_txkey_index = sme->key_idx;\n\n\t\tath6kl_wmi_addkey_cmd(ar->wmi, vif->fw_vif_idx, sme->key_idx,\n\t\t\t\t      vif->prwise_crypto,\n\t\t\t\t      GROUP_USAGE | TX_USAGE,\n\t\t\t\t      key->key_len,\n\t\t\t\t      NULL, 0,\n\t\t\t\t      key->key, KEY_OP_INIT_VAL, NULL,\n\t\t\t\t      NO_SYNC_WMIFLAG);\n\t}\n\n\tif (!ar->usr_bss_filter) {\n\t\tclear_bit(CLEAR_BSSFILTER_ON_BEACON, &vif->flags);\n\t\tif (ath6kl_wmi_bssfilter_cmd(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t\t     ALL_BSS_FILTER, 0) != 0) {\n\t\t\tath6kl_err(\"couldn't set bss filtering\\n\");\n\t\t\tup(&ar->sem);\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tvif->nw_type = vif->next_mode;\n\n\t \n\tath6kl_cfg80211_sta_bmiss_enhance(vif, true);\n\n\tif (vif->wdev.iftype == NL80211_IFTYPE_P2P_CLIENT)\n\t\tnw_subtype = SUBTYPE_P2PCLIENT;\n\n\tath6kl_dbg(ATH6KL_DBG_WLAN_CFG,\n\t\t   \"%s: connect called with authmode %d dot11 auth %d\"\n\t\t   \" PW crypto %d PW crypto len %d GRP crypto %d\"\n\t\t   \" GRP crypto len %d channel hint %u\\n\",\n\t\t   __func__,\n\t\t   vif->auth_mode, vif->dot11_auth_mode, vif->prwise_crypto,\n\t\t   vif->prwise_crypto_len, vif->grp_crypto,\n\t\t   vif->grp_crypto_len, vif->ch_hint);\n\n\tvif->reconnect_flag = 0;\n\n\tif (vif->nw_type == INFRA_NETWORK) {\n\t\tinterval = max_t(u16, vif->listen_intvl_t,\n\t\t\t\t ATH6KL_MAX_WOW_LISTEN_INTL);\n\t\tstatus = ath6kl_wmi_listeninterval_cmd(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t\t\t       interval,\n\t\t\t\t\t\t       0);\n\t\tif (status) {\n\t\t\tath6kl_err(\"couldn't set listen intervel\\n\");\n\t\t\tup(&ar->sem);\n\t\t\treturn status;\n\t\t}\n\t}\n\n\tstatus = ath6kl_wmi_connect_cmd(ar->wmi, vif->fw_vif_idx, vif->nw_type,\n\t\t\t\t\tvif->dot11_auth_mode, vif->auth_mode,\n\t\t\t\t\tvif->prwise_crypto,\n\t\t\t\t\tvif->prwise_crypto_len,\n\t\t\t\t\tvif->grp_crypto, vif->grp_crypto_len,\n\t\t\t\t\tvif->ssid_len, vif->ssid,\n\t\t\t\t\tvif->req_bssid, vif->ch_hint,\n\t\t\t\t\tar->connect_ctrl_flags, nw_subtype);\n\n\tif (sme->bg_scan_period == 0) {\n\t\t \n\t\tsme->bg_scan_period = 0xffff;\n\t} else if (sme->bg_scan_period == -1) {\n\t\t \n\t\tsme->bg_scan_period = DEFAULT_BG_SCAN_PERIOD;\n\t}\n\n\tath6kl_wmi_scanparams_cmd(ar->wmi, vif->fw_vif_idx, 0, 0,\n\t\t\t\t  sme->bg_scan_period, 0, 0, 0, 3, 0, 0, 0);\n\n\tup(&ar->sem);\n\n\tif (status == -EINVAL) {\n\t\tmemset(vif->ssid, 0, sizeof(vif->ssid));\n\t\tvif->ssid_len = 0;\n\t\tath6kl_err(\"invalid request\\n\");\n\t\treturn -ENOENT;\n\t} else if (status) {\n\t\tath6kl_err(\"ath6kl_wmi_connect_cmd failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif ((!(ar->connect_ctrl_flags & CONNECT_DO_WPA_OFFLOAD)) &&\n\t    ((vif->auth_mode == WPA_PSK_AUTH) ||\n\t     (vif->auth_mode == WPA2_PSK_AUTH))) {\n\t\tmod_timer(&vif->disconnect_timer,\n\t\t\t  jiffies + msecs_to_jiffies(DISCON_TIMER_INTVAL));\n\t}\n\n\tar->connect_ctrl_flags &= ~CONNECT_DO_WPA_OFFLOAD;\n\tset_bit(CONNECT_PEND, &vif->flags);\n\n\treturn 0;\n}\n\nstatic struct cfg80211_bss *\nath6kl_add_bss_if_needed(struct ath6kl_vif *vif,\n\t\t\t enum network_type nw_type,\n\t\t\t const u8 *bssid,\n\t\t\t struct ieee80211_channel *chan,\n\t\t\t const u8 *beacon_ie,\n\t\t\t size_t beacon_ie_len)\n{\n\tstruct ath6kl *ar = vif->ar;\n\tstruct cfg80211_bss *bss;\n\tu16 cap_val;\n\tenum ieee80211_bss_type bss_type;\n\tu8 *ie;\n\n\tif (nw_type & ADHOC_NETWORK) {\n\t\tcap_val = WLAN_CAPABILITY_IBSS;\n\t\tbss_type = IEEE80211_BSS_TYPE_IBSS;\n\t} else {\n\t\tcap_val = WLAN_CAPABILITY_ESS;\n\t\tbss_type = IEEE80211_BSS_TYPE_ESS;\n\t}\n\n\tbss = cfg80211_get_bss(ar->wiphy, chan, bssid,\n\t\t\t       vif->ssid, vif->ssid_len,\n\t\t\t       bss_type, IEEE80211_PRIVACY_ANY);\n\tif (bss == NULL) {\n\t\t \n\t\tie = kmalloc(2 + vif->ssid_len + beacon_ie_len, GFP_KERNEL);\n\t\tif (ie == NULL)\n\t\t\treturn NULL;\n\t\tie[0] = WLAN_EID_SSID;\n\t\tie[1] = vif->ssid_len;\n\t\tmemcpy(ie + 2, vif->ssid, vif->ssid_len);\n\t\tmemcpy(ie + 2 + vif->ssid_len, beacon_ie, beacon_ie_len);\n\t\tbss = cfg80211_inform_bss(ar->wiphy, chan,\n\t\t\t\t\t  CFG80211_BSS_FTYPE_UNKNOWN,\n\t\t\t\t\t  bssid, 0, cap_val, 100,\n\t\t\t\t\t  ie, 2 + vif->ssid_len + beacon_ie_len,\n\t\t\t\t\t  0, GFP_KERNEL);\n\t\tif (bss)\n\t\t\tath6kl_dbg(ATH6KL_DBG_WLAN_CFG,\n\t\t\t\t   \"added bss %pM to cfg80211\\n\", bssid);\n\t\tkfree(ie);\n\t} else {\n\t\tath6kl_dbg(ATH6KL_DBG_WLAN_CFG, \"cfg80211 already has a bss\\n\");\n\t}\n\n\treturn bss;\n}\n\nvoid ath6kl_cfg80211_connect_event(struct ath6kl_vif *vif, u16 channel,\n\t\t\t\t   u8 *bssid, u16 listen_intvl,\n\t\t\t\t   u16 beacon_intvl,\n\t\t\t\t   enum network_type nw_type,\n\t\t\t\t   u8 beacon_ie_len, u8 assoc_req_len,\n\t\t\t\t   u8 assoc_resp_len, u8 *assoc_info)\n{\n\tstruct ieee80211_channel *chan;\n\tstruct ath6kl *ar = vif->ar;\n\tstruct cfg80211_bss *bss;\n\n\t \n\tu8 assoc_req_ie_offset = sizeof(u16) + sizeof(u16);\n\n\t \n\tu8 assoc_resp_ie_offset = sizeof(u16) + sizeof(u16) + sizeof(u16);\n\n\tu8 *assoc_req_ie = assoc_info + beacon_ie_len + assoc_req_ie_offset;\n\tu8 *assoc_resp_ie = assoc_info + beacon_ie_len + assoc_req_len +\n\t    assoc_resp_ie_offset;\n\n\tassoc_req_len -= assoc_req_ie_offset;\n\tassoc_resp_len -= assoc_resp_ie_offset;\n\n\t \n\tvif->assoc_bss_beacon_int = beacon_intvl;\n\tclear_bit(DTIM_PERIOD_AVAIL, &vif->flags);\n\n\tif (nw_type & ADHOC_NETWORK) {\n\t\tif (vif->wdev.iftype != NL80211_IFTYPE_ADHOC) {\n\t\t\tath6kl_dbg(ATH6KL_DBG_WLAN_CFG,\n\t\t\t\t   \"%s: ath6k not in ibss mode\\n\", __func__);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (nw_type & INFRA_NETWORK) {\n\t\tif (vif->wdev.iftype != NL80211_IFTYPE_STATION &&\n\t\t    vif->wdev.iftype != NL80211_IFTYPE_P2P_CLIENT) {\n\t\t\tath6kl_dbg(ATH6KL_DBG_WLAN_CFG,\n\t\t\t\t   \"%s: ath6k not in station mode\\n\", __func__);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tchan = ieee80211_get_channel(ar->wiphy, (int) channel);\n\n\tbss = ath6kl_add_bss_if_needed(vif, nw_type, bssid, chan,\n\t\t\t\t       assoc_info, beacon_ie_len);\n\tif (!bss) {\n\t\tath6kl_err(\"could not add cfg80211 bss entry\\n\");\n\t\treturn;\n\t}\n\n\tif (nw_type & ADHOC_NETWORK) {\n\t\tath6kl_dbg(ATH6KL_DBG_WLAN_CFG, \"ad-hoc %s selected\\n\",\n\t\t\t   nw_type & ADHOC_CREATOR ? \"creator\" : \"joiner\");\n\t\tcfg80211_ibss_joined(vif->ndev, bssid, chan, GFP_KERNEL);\n\t\tcfg80211_put_bss(ar->wiphy, bss);\n\t\treturn;\n\t}\n\n\tif (vif->sme_state == SME_CONNECTING) {\n\t\t \n\t\tvif->sme_state = SME_CONNECTED;\n\t\tcfg80211_connect_result(vif->ndev, bssid,\n\t\t\t\t\tassoc_req_ie, assoc_req_len,\n\t\t\t\t\tassoc_resp_ie, assoc_resp_len,\n\t\t\t\t\tWLAN_STATUS_SUCCESS, GFP_KERNEL);\n\t\tcfg80211_put_bss(ar->wiphy, bss);\n\t} else if (vif->sme_state == SME_CONNECTED) {\n\t\tstruct cfg80211_roam_info roam_info = {\n\t\t\t.links[0].bss = bss,\n\t\t\t.req_ie = assoc_req_ie,\n\t\t\t.req_ie_len = assoc_req_len,\n\t\t\t.resp_ie = assoc_resp_ie,\n\t\t\t.resp_ie_len = assoc_resp_len,\n\t\t};\n\t\t \n\t\tcfg80211_roamed(vif->ndev, &roam_info, GFP_KERNEL);\n\t}\n}\n\nstatic int ath6kl_cfg80211_disconnect(struct wiphy *wiphy,\n\t\t\t\t      struct net_device *dev, u16 reason_code)\n{\n\tstruct ath6kl *ar = ath6kl_priv(dev);\n\tstruct ath6kl_vif *vif = netdev_priv(dev);\n\n\tath6kl_dbg(ATH6KL_DBG_WLAN_CFG, \"%s: reason=%u\\n\", __func__,\n\t\t   reason_code);\n\n\tath6kl_cfg80211_sscan_disable(vif);\n\n\tif (!ath6kl_cfg80211_ready(vif))\n\t\treturn -EIO;\n\n\tif (test_bit(DESTROY_IN_PROGRESS, &ar->flag)) {\n\t\tath6kl_err(\"busy, destroy in progress\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tif (down_interruptible(&ar->sem)) {\n\t\tath6kl_err(\"busy, couldn't get access\\n\");\n\t\treturn -ERESTARTSYS;\n\t}\n\n\tvif->reconnect_flag = 0;\n\tath6kl_disconnect(vif);\n\tmemset(vif->ssid, 0, sizeof(vif->ssid));\n\tvif->ssid_len = 0;\n\n\tif (!test_bit(SKIP_SCAN, &ar->flag))\n\t\tmemset(vif->req_bssid, 0, sizeof(vif->req_bssid));\n\n\tup(&ar->sem);\n\n\treturn 0;\n}\n\nvoid ath6kl_cfg80211_disconnect_event(struct ath6kl_vif *vif, u8 reason,\n\t\t\t\t      u8 *bssid, u8 assoc_resp_len,\n\t\t\t\t      u8 *assoc_info, u16 proto_reason)\n{\n\tstruct ath6kl *ar = vif->ar;\n\n\tif (vif->scan_req) {\n\t\tstruct cfg80211_scan_info info = {\n\t\t\t.aborted = true,\n\t\t};\n\n\t\tcfg80211_scan_done(vif->scan_req, &info);\n\t\tvif->scan_req = NULL;\n\t}\n\n\tif (vif->nw_type & ADHOC_NETWORK) {\n\t\tif (vif->wdev.iftype != NL80211_IFTYPE_ADHOC)\n\t\t\tath6kl_dbg(ATH6KL_DBG_WLAN_CFG,\n\t\t\t\t   \"%s: ath6k not in ibss mode\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (vif->nw_type & INFRA_NETWORK) {\n\t\tif (vif->wdev.iftype != NL80211_IFTYPE_STATION &&\n\t\t    vif->wdev.iftype != NL80211_IFTYPE_P2P_CLIENT) {\n\t\t\tath6kl_dbg(ATH6KL_DBG_WLAN_CFG,\n\t\t\t\t   \"%s: ath6k not in station mode\\n\", __func__);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tclear_bit(CONNECT_PEND, &vif->flags);\n\n\tif (vif->sme_state == SME_CONNECTING) {\n\t\tcfg80211_connect_result(vif->ndev,\n\t\t\t\t\tbssid, NULL, 0,\n\t\t\t\t\tNULL, 0,\n\t\t\t\t\tWLAN_STATUS_UNSPECIFIED_FAILURE,\n\t\t\t\t\tGFP_KERNEL);\n\t} else if (vif->sme_state == SME_CONNECTED) {\n\t\tcfg80211_disconnected(vif->ndev, proto_reason,\n\t\t\t\t      NULL, 0, false, GFP_KERNEL);\n\t}\n\n\tvif->sme_state = SME_DISCONNECTED;\n\n\t \n\tif (reason != DISCONNECT_CMD)\n\t\tath6kl_wmi_disconnect_cmd(ar->wmi, vif->fw_vif_idx);\n}\n\nstatic int ath6kl_set_probed_ssids(struct ath6kl *ar,\n\t\t\t\t   struct ath6kl_vif *vif,\n\t\t\t\t   struct cfg80211_ssid *ssids, int n_ssids,\n\t\t\t\t   struct cfg80211_match_set *match_set,\n\t\t\t\t   int n_match_ssid)\n{\n\tu8 i, j, index_to_add, ssid_found = false;\n\tstruct ath6kl_cfg80211_match_probe_ssid ssid_list[MAX_PROBED_SSIDS];\n\n\tmemset(ssid_list, 0, sizeof(ssid_list));\n\n\tif (n_ssids > MAX_PROBED_SSIDS ||\n\t    n_match_ssid > MAX_PROBED_SSIDS)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < n_ssids; i++) {\n\t\tmemcpy(ssid_list[i].ssid.ssid,\n\t\t       ssids[i].ssid,\n\t\t       ssids[i].ssid_len);\n\t\tssid_list[i].ssid.ssid_len = ssids[i].ssid_len;\n\n\t\tif (ssids[i].ssid_len)\n\t\t\tssid_list[i].flag = SPECIFIC_SSID_FLAG;\n\t\telse\n\t\t\tssid_list[i].flag = ANY_SSID_FLAG;\n\n\t\tif (ar->wiphy->max_match_sets != 0 && n_match_ssid == 0)\n\t\t\tssid_list[i].flag |= MATCH_SSID_FLAG;\n\t}\n\n\tindex_to_add = i;\n\n\tfor (i = 0; i < n_match_ssid; i++) {\n\t\tssid_found = false;\n\n\t\tfor (j = 0; j < n_ssids; j++) {\n\t\t\tif ((match_set[i].ssid.ssid_len ==\n\t\t\t     ssid_list[j].ssid.ssid_len) &&\n\t\t\t    (!memcmp(ssid_list[j].ssid.ssid,\n\t\t\t\t     match_set[i].ssid.ssid,\n\t\t\t\t     match_set[i].ssid.ssid_len))) {\n\t\t\t\tssid_list[j].flag |= MATCH_SSID_FLAG;\n\t\t\t\tssid_found = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ssid_found)\n\t\t\tcontinue;\n\n\t\tif (index_to_add >= MAX_PROBED_SSIDS)\n\t\t\tcontinue;\n\n\t\tssid_list[index_to_add].ssid.ssid_len =\n\t\t\tmatch_set[i].ssid.ssid_len;\n\t\tmemcpy(ssid_list[index_to_add].ssid.ssid,\n\t\t       match_set[i].ssid.ssid,\n\t\t       match_set[i].ssid.ssid_len);\n\t\tssid_list[index_to_add].flag |= MATCH_SSID_FLAG;\n\t\tindex_to_add++;\n\t}\n\n\tfor (i = 0; i < index_to_add; i++) {\n\t\tath6kl_wmi_probedssid_cmd(ar->wmi, vif->fw_vif_idx, i,\n\t\t\t\t\t  ssid_list[i].flag,\n\t\t\t\t\t  ssid_list[i].ssid.ssid_len,\n\t\t\t\t\t  ssid_list[i].ssid.ssid);\n\t}\n\n\t \n\tfor (i = index_to_add; i < MAX_PROBED_SSIDS; i++) {\n\t\tath6kl_wmi_probedssid_cmd(ar->wmi, vif->fw_vif_idx, i,\n\t\t\t\t\t  DISABLE_SSID_FLAG, 0, NULL);\n\t}\n\n\treturn 0;\n}\n\nstatic int ath6kl_cfg80211_scan(struct wiphy *wiphy,\n\t\t\t\tstruct cfg80211_scan_request *request)\n{\n\tstruct ath6kl_vif *vif = ath6kl_vif_from_wdev(request->wdev);\n\tstruct ath6kl *ar = ath6kl_priv(vif->ndev);\n\ts8 n_channels = 0;\n\tu16 *channels = NULL;\n\tint ret = 0;\n\tu32 force_fg_scan = 0;\n\n\tif (!ath6kl_cfg80211_ready(vif))\n\t\treturn -EIO;\n\n\tath6kl_cfg80211_sscan_disable(vif);\n\n\tif (!ar->usr_bss_filter) {\n\t\tclear_bit(CLEAR_BSSFILTER_ON_BEACON, &vif->flags);\n\t\tret = ath6kl_wmi_bssfilter_cmd(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t\t       ALL_BSS_FILTER, 0);\n\t\tif (ret) {\n\t\t\tath6kl_err(\"couldn't set bss filtering\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = ath6kl_set_probed_ssids(ar, vif, request->ssids,\n\t\t\t\t      request->n_ssids, NULL, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = ath6kl_wmi_set_appie_cmd(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t       WMI_FRAME_PROBE_REQ,\n\t\t\t\t       request->ie, request->ie_len);\n\tif (ret) {\n\t\tath6kl_err(\"failed to set Probe Request appie for scan\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (request->n_channels > 0 &&\n\t    request->n_channels <= WMI_MAX_CHANNELS) {\n\t\tu8 i;\n\n\t\tn_channels = request->n_channels;\n\n\t\tchannels = kcalloc(n_channels, sizeof(u16), GFP_KERNEL);\n\t\tif (channels == NULL) {\n\t\t\tath6kl_warn(\"failed to set scan channels, scan all channels\");\n\t\t\tn_channels = 0;\n\t\t}\n\n\t\tfor (i = 0; i < n_channels; i++)\n\t\t\tchannels[i] = request->channels[i]->center_freq;\n\t}\n\n\tif (test_bit(CONNECTED, &vif->flags))\n\t\tforce_fg_scan = 1;\n\n\tvif->scan_req = request;\n\n\tret = ath6kl_wmi_beginscan_cmd(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t       WMI_LONG_SCAN, force_fg_scan,\n\t\t\t\t       false, 0,\n\t\t\t\t       ATH6KL_FG_SCAN_INTERVAL,\n\t\t\t\t       n_channels, channels,\n\t\t\t\t       request->no_cck,\n\t\t\t\t       request->rates);\n\tif (ret) {\n\t\tath6kl_err(\"failed to start scan: %d\\n\", ret);\n\t\tvif->scan_req = NULL;\n\t}\n\n\tkfree(channels);\n\n\treturn ret;\n}\n\nvoid ath6kl_cfg80211_scan_complete_event(struct ath6kl_vif *vif, bool aborted)\n{\n\tstruct ath6kl *ar = vif->ar;\n\tstruct cfg80211_scan_info info = {\n\t\t.aborted = aborted,\n\t};\n\tint i;\n\n\tath6kl_dbg(ATH6KL_DBG_WLAN_CFG, \"%s: status%s\\n\", __func__,\n\t\t   aborted ? \" aborted\" : \"\");\n\n\tif (!vif->scan_req)\n\t\treturn;\n\n\tif (aborted)\n\t\tgoto out;\n\n\tif (vif->scan_req->n_ssids && vif->scan_req->ssids[0].ssid_len) {\n\t\tfor (i = 0; i < vif->scan_req->n_ssids; i++) {\n\t\t\tath6kl_wmi_probedssid_cmd(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t\t\t  i, DISABLE_SSID_FLAG,\n\t\t\t\t\t\t  0, NULL);\n\t\t}\n\t}\n\nout:\n\tcfg80211_scan_done(vif->scan_req, &info);\n\tvif->scan_req = NULL;\n}\n\nvoid ath6kl_cfg80211_ch_switch_notify(struct ath6kl_vif *vif, int freq,\n\t\t\t\t      enum wmi_phy_mode mode)\n{\n\tstruct cfg80211_chan_def chandef;\n\n\tath6kl_dbg(ATH6KL_DBG_WLAN_CFG,\n\t\t   \"channel switch notify nw_type %d freq %d mode %d\\n\",\n\t\t   vif->nw_type, freq, mode);\n\n\tcfg80211_chandef_create(&chandef,\n\t\t\t\tieee80211_get_channel(vif->ar->wiphy, freq),\n\t\t\t\t(mode == WMI_11G_HT20 &&\n\t\t\t\t ath6kl_band_2ghz.ht_cap.ht_supported) ?\n\t\t\t\t\tNL80211_CHAN_HT20 : NL80211_CHAN_NO_HT);\n\n\tmutex_lock(&vif->wdev.mtx);\n\tcfg80211_ch_switch_notify(vif->ndev, &chandef, 0, 0);\n\tmutex_unlock(&vif->wdev.mtx);\n}\n\nstatic int ath6kl_cfg80211_add_key(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\t\t   int link_id, u8 key_index, bool pairwise,\n\t\t\t\t   const u8 *mac_addr,\n\t\t\t\t   struct key_params *params)\n{\n\tstruct ath6kl *ar = ath6kl_priv(ndev);\n\tstruct ath6kl_vif *vif = netdev_priv(ndev);\n\tstruct ath6kl_key *key = NULL;\n\tint seq_len;\n\tu8 key_usage;\n\tu8 key_type;\n\n\tif (!ath6kl_cfg80211_ready(vif))\n\t\treturn -EIO;\n\n\tif (params->cipher == CCKM_KRK_CIPHER_SUITE) {\n\t\tif (params->key_len != WMI_KRK_LEN)\n\t\t\treturn -EINVAL;\n\t\treturn ath6kl_wmi_add_krk_cmd(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t\t      params->key);\n\t}\n\n\tif (key_index > WMI_MAX_KEY_INDEX) {\n\t\tath6kl_dbg(ATH6KL_DBG_WLAN_CFG,\n\t\t\t   \"%s: key index %d out of bounds\\n\", __func__,\n\t\t\t   key_index);\n\t\treturn -ENOENT;\n\t}\n\n\tkey = &vif->keys[key_index];\n\tmemset(key, 0, sizeof(struct ath6kl_key));\n\n\tif (pairwise)\n\t\tkey_usage = PAIRWISE_USAGE;\n\telse\n\t\tkey_usage = GROUP_USAGE;\n\n\tseq_len = params->seq_len;\n\tif (params->cipher == WLAN_CIPHER_SUITE_SMS4 &&\n\t    seq_len > ATH6KL_KEY_SEQ_LEN) {\n\t\t \n\t\tseq_len = ATH6KL_KEY_SEQ_LEN;\n\t}\n\tif (params->key_len > WLAN_MAX_KEY_LEN ||\n\t    seq_len > sizeof(key->seq))\n\t\treturn -EINVAL;\n\n\tkey->key_len = params->key_len;\n\tmemcpy(key->key, params->key, key->key_len);\n\tkey->seq_len = seq_len;\n\tmemcpy(key->seq, params->seq, key->seq_len);\n\tkey->cipher = params->cipher;\n\n\tswitch (key->cipher) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\tkey_type = WEP_CRYPT;\n\t\tbreak;\n\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\tkey_type = TKIP_CRYPT;\n\t\tbreak;\n\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tkey_type = AES_CRYPT;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_SMS4:\n\t\tkey_type = WAPI_CRYPT;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (((vif->auth_mode == WPA_PSK_AUTH) ||\n\t     (vif->auth_mode == WPA2_PSK_AUTH)) &&\n\t    (key_usage & GROUP_USAGE))\n\t\tdel_timer(&vif->disconnect_timer);\n\n\tath6kl_dbg(ATH6KL_DBG_WLAN_CFG,\n\t\t   \"%s: index %d, key_len %d, key_type 0x%x, key_usage 0x%x, seq_len %d\\n\",\n\t\t   __func__, key_index, key->key_len, key_type,\n\t\t   key_usage, key->seq_len);\n\n\tif (vif->nw_type == AP_NETWORK && !pairwise &&\n\t    (key_type == TKIP_CRYPT || key_type == AES_CRYPT ||\n\t     key_type == WAPI_CRYPT)) {\n\t\tar->ap_mode_bkey.valid = true;\n\t\tar->ap_mode_bkey.key_index = key_index;\n\t\tar->ap_mode_bkey.key_type = key_type;\n\t\tar->ap_mode_bkey.key_len = key->key_len;\n\t\tmemcpy(ar->ap_mode_bkey.key, key->key, key->key_len);\n\t\tif (!test_bit(CONNECTED, &vif->flags)) {\n\t\t\tath6kl_dbg(ATH6KL_DBG_WLAN_CFG,\n\t\t\t\t   \"Delay initial group key configuration until AP mode has been started\\n\");\n\t\t\t \n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (vif->next_mode == AP_NETWORK && key_type == WEP_CRYPT &&\n\t    !test_bit(CONNECTED, &vif->flags)) {\n\t\t \n\t\tath6kl_dbg(ATH6KL_DBG_WLAN_CFG,\n\t\t\t   \"Delay WEP key configuration until AP mode has been started\\n\");\n\t\tvif->wep_key_list[key_index].key_len = key->key_len;\n\t\tmemcpy(vif->wep_key_list[key_index].key, key->key,\n\t\t       key->key_len);\n\t\treturn 0;\n\t}\n\n\treturn ath6kl_wmi_addkey_cmd(ar->wmi, vif->fw_vif_idx, key_index,\n\t\t\t\t     key_type, key_usage, key->key_len,\n\t\t\t\t     key->seq, key->seq_len, key->key,\n\t\t\t\t     KEY_OP_INIT_VAL,\n\t\t\t\t     (u8 *) mac_addr, SYNC_BOTH_WMIFLAG);\n}\n\nstatic int ath6kl_cfg80211_del_key(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\t\t   int link_id, u8 key_index, bool pairwise,\n\t\t\t\t   const u8 *mac_addr)\n{\n\tstruct ath6kl *ar = ath6kl_priv(ndev);\n\tstruct ath6kl_vif *vif = netdev_priv(ndev);\n\n\tath6kl_dbg(ATH6KL_DBG_WLAN_CFG, \"%s: index %d\\n\", __func__, key_index);\n\n\tif (!ath6kl_cfg80211_ready(vif))\n\t\treturn -EIO;\n\n\tif (key_index > WMI_MAX_KEY_INDEX) {\n\t\tath6kl_dbg(ATH6KL_DBG_WLAN_CFG,\n\t\t\t   \"%s: key index %d out of bounds\\n\", __func__,\n\t\t\t   key_index);\n\t\treturn -ENOENT;\n\t}\n\n\tif (!vif->keys[key_index].key_len) {\n\t\tath6kl_dbg(ATH6KL_DBG_WLAN_CFG,\n\t\t\t   \"%s: index %d is empty\\n\", __func__, key_index);\n\t\treturn 0;\n\t}\n\n\tvif->keys[key_index].key_len = 0;\n\n\treturn ath6kl_wmi_deletekey_cmd(ar->wmi, vif->fw_vif_idx, key_index);\n}\n\nstatic int ath6kl_cfg80211_get_key(struct wiphy *wiphy, struct net_device *ndev,\n\t\t\t\t   int link_id, u8 key_index, bool pairwise,\n\t\t\t\t   const u8 *mac_addr, void *cookie,\n\t\t\t\t   void (*callback) (void *cookie,\n\t\t\t\t\t\t     struct key_params *))\n{\n\tstruct ath6kl_vif *vif = netdev_priv(ndev);\n\tstruct ath6kl_key *key = NULL;\n\tstruct key_params params;\n\n\tath6kl_dbg(ATH6KL_DBG_WLAN_CFG, \"%s: index %d\\n\", __func__, key_index);\n\n\tif (!ath6kl_cfg80211_ready(vif))\n\t\treturn -EIO;\n\n\tif (key_index > WMI_MAX_KEY_INDEX) {\n\t\tath6kl_dbg(ATH6KL_DBG_WLAN_CFG,\n\t\t\t   \"%s: key index %d out of bounds\\n\", __func__,\n\t\t\t   key_index);\n\t\treturn -ENOENT;\n\t}\n\n\tkey = &vif->keys[key_index];\n\tmemset(&params, 0, sizeof(params));\n\tparams.cipher = key->cipher;\n\tparams.key_len = key->key_len;\n\tparams.seq_len = key->seq_len;\n\tparams.seq = key->seq;\n\tparams.key = key->key;\n\n\tcallback(cookie, &params);\n\n\treturn key->key_len ? 0 : -ENOENT;\n}\n\nstatic int ath6kl_cfg80211_set_default_key(struct wiphy *wiphy,\n\t\t\t\t\t   struct net_device *ndev, int link_id,\n\t\t\t\t\t   u8 key_index, bool unicast,\n\t\t\t\t\t   bool multicast)\n{\n\tstruct ath6kl *ar = ath6kl_priv(ndev);\n\tstruct ath6kl_vif *vif = netdev_priv(ndev);\n\tstruct ath6kl_key *key = NULL;\n\tu8 key_usage;\n\tenum ath6kl_crypto_type key_type = NONE_CRYPT;\n\n\tath6kl_dbg(ATH6KL_DBG_WLAN_CFG, \"%s: index %d\\n\", __func__, key_index);\n\n\tif (!ath6kl_cfg80211_ready(vif))\n\t\treturn -EIO;\n\n\tif (key_index > WMI_MAX_KEY_INDEX) {\n\t\tath6kl_dbg(ATH6KL_DBG_WLAN_CFG,\n\t\t\t   \"%s: key index %d out of bounds\\n\",\n\t\t\t   __func__, key_index);\n\t\treturn -ENOENT;\n\t}\n\n\tif (!vif->keys[key_index].key_len) {\n\t\tath6kl_dbg(ATH6KL_DBG_WLAN_CFG, \"%s: invalid key index %d\\n\",\n\t\t\t   __func__, key_index);\n\t\treturn -EINVAL;\n\t}\n\n\tvif->def_txkey_index = key_index;\n\tkey = &vif->keys[vif->def_txkey_index];\n\tkey_usage = GROUP_USAGE;\n\tif (vif->prwise_crypto == WEP_CRYPT)\n\t\tkey_usage |= TX_USAGE;\n\tif (unicast)\n\t\tkey_type = vif->prwise_crypto;\n\tif (multicast)\n\t\tkey_type = vif->grp_crypto;\n\n\tif (vif->next_mode == AP_NETWORK && !test_bit(CONNECTED, &vif->flags))\n\t\treturn 0;  \n\n\treturn ath6kl_wmi_addkey_cmd(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t     vif->def_txkey_index,\n\t\t\t\t     key_type, key_usage,\n\t\t\t\t     key->key_len, key->seq, key->seq_len,\n\t\t\t\t     key->key,\n\t\t\t\t     KEY_OP_INIT_VAL, NULL,\n\t\t\t\t     SYNC_BOTH_WMIFLAG);\n}\n\nvoid ath6kl_cfg80211_tkip_micerr_event(struct ath6kl_vif *vif, u8 keyid,\n\t\t\t\t       bool ismcast)\n{\n\tath6kl_dbg(ATH6KL_DBG_WLAN_CFG,\n\t\t   \"%s: keyid %d, ismcast %d\\n\", __func__, keyid, ismcast);\n\n\tcfg80211_michael_mic_failure(vif->ndev, vif->bssid,\n\t\t\t\t     (ismcast ? NL80211_KEYTYPE_GROUP :\n\t\t\t\t      NL80211_KEYTYPE_PAIRWISE), keyid, NULL,\n\t\t\t\t     GFP_KERNEL);\n}\n\nstatic int ath6kl_cfg80211_set_wiphy_params(struct wiphy *wiphy, u32 changed)\n{\n\tstruct ath6kl *ar = (struct ath6kl *)wiphy_priv(wiphy);\n\tstruct ath6kl_vif *vif;\n\tint ret;\n\n\tath6kl_dbg(ATH6KL_DBG_WLAN_CFG, \"%s: changed 0x%x\\n\", __func__,\n\t\t   changed);\n\n\tvif = ath6kl_vif_first(ar);\n\tif (!vif)\n\t\treturn -EIO;\n\n\tif (!ath6kl_cfg80211_ready(vif))\n\t\treturn -EIO;\n\n\tif (changed & WIPHY_PARAM_RTS_THRESHOLD) {\n\t\tret = ath6kl_wmi_set_rts_cmd(ar->wmi, wiphy->rts_threshold);\n\t\tif (ret != 0) {\n\t\t\tath6kl_err(\"ath6kl_wmi_set_rts_cmd failed\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ath6kl_cfg80211_set_txpower(struct wiphy *wiphy,\n\t\t\t\t       struct wireless_dev *wdev,\n\t\t\t\t       enum nl80211_tx_power_setting type,\n\t\t\t\t       int mbm)\n{\n\tstruct ath6kl *ar = (struct ath6kl *)wiphy_priv(wiphy);\n\tstruct ath6kl_vif *vif;\n\tint dbm = MBM_TO_DBM(mbm);\n\n\tath6kl_dbg(ATH6KL_DBG_WLAN_CFG, \"%s: type 0x%x, dbm %d\\n\", __func__,\n\t\t   type, dbm);\n\n\tvif = ath6kl_vif_first(ar);\n\tif (!vif)\n\t\treturn -EIO;\n\n\tif (!ath6kl_cfg80211_ready(vif))\n\t\treturn -EIO;\n\n\tswitch (type) {\n\tcase NL80211_TX_POWER_AUTOMATIC:\n\t\treturn 0;\n\tcase NL80211_TX_POWER_LIMITED:\n\t\tar->tx_pwr = dbm;\n\t\tbreak;\n\tdefault:\n\t\tath6kl_dbg(ATH6KL_DBG_WLAN_CFG, \"%s: type 0x%x not supported\\n\",\n\t\t\t   __func__, type);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tath6kl_wmi_set_tx_pwr_cmd(ar->wmi, vif->fw_vif_idx, dbm);\n\n\treturn 0;\n}\n\nstatic int ath6kl_cfg80211_get_txpower(struct wiphy *wiphy,\n\t\t\t\t       struct wireless_dev *wdev,\n\t\t\t\t       int *dbm)\n{\n\tstruct ath6kl *ar = (struct ath6kl *)wiphy_priv(wiphy);\n\tstruct ath6kl_vif *vif;\n\n\tvif = ath6kl_vif_first(ar);\n\tif (!vif)\n\t\treturn -EIO;\n\n\tif (!ath6kl_cfg80211_ready(vif))\n\t\treturn -EIO;\n\n\tif (test_bit(CONNECTED, &vif->flags)) {\n\t\tar->tx_pwr = 255;\n\n\t\tif (ath6kl_wmi_get_tx_pwr_cmd(ar->wmi, vif->fw_vif_idx) != 0) {\n\t\t\tath6kl_err(\"ath6kl_wmi_get_tx_pwr_cmd failed\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\twait_event_interruptible_timeout(ar->event_wq, ar->tx_pwr != 255,\n\t\t\t\t\t\t 5 * HZ);\n\n\t\tif (signal_pending(current)) {\n\t\t\tath6kl_err(\"target did not respond\\n\");\n\t\t\treturn -EINTR;\n\t\t}\n\t}\n\n\t*dbm = ar->tx_pwr;\n\treturn 0;\n}\n\nstatic int ath6kl_cfg80211_set_power_mgmt(struct wiphy *wiphy,\n\t\t\t\t\t  struct net_device *dev,\n\t\t\t\t\t  bool pmgmt, int timeout)\n{\n\tstruct ath6kl *ar = ath6kl_priv(dev);\n\tstruct wmi_power_mode_cmd mode;\n\tstruct ath6kl_vif *vif = netdev_priv(dev);\n\n\tath6kl_dbg(ATH6KL_DBG_WLAN_CFG, \"%s: pmgmt %d, timeout %d\\n\",\n\t\t   __func__, pmgmt, timeout);\n\n\tif (!ath6kl_cfg80211_ready(vif))\n\t\treturn -EIO;\n\n\tif (pmgmt) {\n\t\tath6kl_dbg(ATH6KL_DBG_WLAN_CFG, \"%s: rec power\\n\", __func__);\n\t\tmode.pwr_mode = REC_POWER;\n\t} else {\n\t\tath6kl_dbg(ATH6KL_DBG_WLAN_CFG, \"%s: max perf\\n\", __func__);\n\t\tmode.pwr_mode = MAX_PERF_POWER;\n\t}\n\n\tif (ath6kl_wmi_powermode_cmd(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t     mode.pwr_mode) != 0) {\n\t\tath6kl_err(\"wmi_powermode_cmd failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic struct wireless_dev *ath6kl_cfg80211_add_iface(struct wiphy *wiphy,\n\t\t\t\t\t\t      const char *name,\n\t\t\t\t\t\t      unsigned char name_assign_type,\n\t\t\t\t\t\t      enum nl80211_iftype type,\n\t\t\t\t\t\t      struct vif_params *params)\n{\n\tstruct ath6kl *ar = wiphy_priv(wiphy);\n\tstruct wireless_dev *wdev;\n\tu8 if_idx, nw_type;\n\n\tif (ar->num_vif == ar->vif_max) {\n\t\tath6kl_err(\"Reached maximum number of supported vif\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (!ath6kl_is_valid_iftype(ar, type, &if_idx, &nw_type)) {\n\t\tath6kl_err(\"Not a supported interface type\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\twdev = ath6kl_interface_add(ar, name, name_assign_type, type, if_idx, nw_type);\n\tif (!wdev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tar->num_vif++;\n\n\treturn wdev;\n}\n\nstatic int ath6kl_cfg80211_del_iface(struct wiphy *wiphy,\n\t\t\t\t     struct wireless_dev *wdev)\n{\n\tstruct ath6kl *ar = wiphy_priv(wiphy);\n\tstruct ath6kl_vif *vif = netdev_priv(wdev->netdev);\n\n\tspin_lock_bh(&ar->list_lock);\n\tlist_del(&vif->list);\n\tspin_unlock_bh(&ar->list_lock);\n\n\tath6kl_cfg80211_vif_stop(vif, test_bit(WMI_READY, &ar->flag));\n\n\trtnl_lock();\n\tath6kl_cfg80211_vif_cleanup(vif);\n\trtnl_unlock();\n\n\treturn 0;\n}\n\nstatic int ath6kl_cfg80211_change_iface(struct wiphy *wiphy,\n\t\t\t\t\tstruct net_device *ndev,\n\t\t\t\t\tenum nl80211_iftype type,\n\t\t\t\t\tstruct vif_params *params)\n{\n\tstruct ath6kl_vif *vif = netdev_priv(ndev);\n\tint i;\n\n\tath6kl_dbg(ATH6KL_DBG_WLAN_CFG, \"%s: type %u\\n\", __func__, type);\n\n\t \n\tif (!test_bit(ATH6KL_FW_CAPABILITY_STA_P2PDEV_DUPLEX,\n\t\t      vif->ar->fw_capabilities) &&\n\t    (type == NL80211_IFTYPE_P2P_CLIENT ||\n\t     type == NL80211_IFTYPE_P2P_GO)) {\n\t\tif (vif->ar->vif_max == 1) {\n\t\t\tif (vif->fw_vif_idx != 0)\n\t\t\t\treturn -EINVAL;\n\t\t\telse\n\t\t\t\tgoto set_iface_type;\n\t\t}\n\n\t\tfor (i = vif->ar->max_norm_iface; i < vif->ar->vif_max; i++) {\n\t\t\tif (i == vif->fw_vif_idx)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == vif->ar->vif_max) {\n\t\t\tath6kl_err(\"Invalid interface to bring up P2P\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\t \n\tath6kl_cfg80211_sta_bmiss_enhance(vif, false);\n\nset_iface_type:\n\tswitch (type) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tvif->next_mode = INFRA_NETWORK;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tvif->next_mode = ADHOC_NETWORK;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tvif->next_mode = AP_NETWORK;\n\t\tbreak;\n\tdefault:\n\t\tath6kl_err(\"invalid interface type %u\\n\", type);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tvif->wdev.iftype = type;\n\n\treturn 0;\n}\n\nstatic int ath6kl_cfg80211_join_ibss(struct wiphy *wiphy,\n\t\t\t\t     struct net_device *dev,\n\t\t\t\t     struct cfg80211_ibss_params *ibss_param)\n{\n\tstruct ath6kl *ar = ath6kl_priv(dev);\n\tstruct ath6kl_vif *vif = netdev_priv(dev);\n\tint status;\n\n\tif (!ath6kl_cfg80211_ready(vif))\n\t\treturn -EIO;\n\n\tvif->ssid_len = ibss_param->ssid_len;\n\tmemcpy(vif->ssid, ibss_param->ssid, vif->ssid_len);\n\n\tif (ibss_param->chandef.chan)\n\t\tvif->ch_hint = ibss_param->chandef.chan->center_freq;\n\n\tif (ibss_param->channel_fixed) {\n\t\t \n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmemset(vif->req_bssid, 0, sizeof(vif->req_bssid));\n\tif (ibss_param->bssid && !is_broadcast_ether_addr(ibss_param->bssid))\n\t\tmemcpy(vif->req_bssid, ibss_param->bssid,\n\t\t       sizeof(vif->req_bssid));\n\n\tath6kl_set_wpa_version(vif, 0);\n\n\tstatus = ath6kl_set_auth_type(vif, NL80211_AUTHTYPE_OPEN_SYSTEM);\n\tif (status)\n\t\treturn status;\n\n\tif (ibss_param->privacy) {\n\t\tath6kl_set_cipher(vif, WLAN_CIPHER_SUITE_WEP40, true);\n\t\tath6kl_set_cipher(vif, WLAN_CIPHER_SUITE_WEP40, false);\n\t} else {\n\t\tath6kl_set_cipher(vif, 0, true);\n\t\tath6kl_set_cipher(vif, 0, false);\n\t}\n\n\tvif->nw_type = vif->next_mode;\n\n\tath6kl_dbg(ATH6KL_DBG_WLAN_CFG,\n\t\t   \"%s: connect called with authmode %d dot11 auth %d\"\n\t\t   \" PW crypto %d PW crypto len %d GRP crypto %d\"\n\t\t   \" GRP crypto len %d channel hint %u\\n\",\n\t\t   __func__,\n\t\t   vif->auth_mode, vif->dot11_auth_mode, vif->prwise_crypto,\n\t\t   vif->prwise_crypto_len, vif->grp_crypto,\n\t\t   vif->grp_crypto_len, vif->ch_hint);\n\n\tstatus = ath6kl_wmi_connect_cmd(ar->wmi, vif->fw_vif_idx, vif->nw_type,\n\t\t\t\t\tvif->dot11_auth_mode, vif->auth_mode,\n\t\t\t\t\tvif->prwise_crypto,\n\t\t\t\t\tvif->prwise_crypto_len,\n\t\t\t\t\tvif->grp_crypto, vif->grp_crypto_len,\n\t\t\t\t\tvif->ssid_len, vif->ssid,\n\t\t\t\t\tvif->req_bssid, vif->ch_hint,\n\t\t\t\t\tar->connect_ctrl_flags, SUBTYPE_NONE);\n\tset_bit(CONNECT_PEND, &vif->flags);\n\n\treturn 0;\n}\n\nstatic int ath6kl_cfg80211_leave_ibss(struct wiphy *wiphy,\n\t\t\t\t      struct net_device *dev)\n{\n\tstruct ath6kl_vif *vif = netdev_priv(dev);\n\n\tif (!ath6kl_cfg80211_ready(vif))\n\t\treturn -EIO;\n\n\tath6kl_disconnect(vif);\n\tmemset(vif->ssid, 0, sizeof(vif->ssid));\n\tvif->ssid_len = 0;\n\n\treturn 0;\n}\n\nstatic const u32 cipher_suites[] = {\n\tWLAN_CIPHER_SUITE_WEP40,\n\tWLAN_CIPHER_SUITE_WEP104,\n\tWLAN_CIPHER_SUITE_TKIP,\n\tWLAN_CIPHER_SUITE_CCMP,\n\tCCKM_KRK_CIPHER_SUITE,\n\tWLAN_CIPHER_SUITE_SMS4,\n};\n\nstatic bool is_rate_legacy(s32 rate)\n{\n\tstatic const s32 legacy[] = { 1000, 2000, 5500, 11000,\n\t\t6000, 9000, 12000, 18000, 24000,\n\t\t36000, 48000, 54000\n\t};\n\tu8 i;\n\n\tfor (i = 0; i < ARRAY_SIZE(legacy); i++)\n\t\tif (rate == legacy[i])\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool is_rate_ht20(s32 rate, u8 *mcs, bool *sgi)\n{\n\tstatic const s32 ht20[] = { 6500, 13000, 19500, 26000, 39000,\n\t\t52000, 58500, 65000, 72200\n\t};\n\tu8 i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ht20); i++) {\n\t\tif (rate == ht20[i]) {\n\t\t\tif (i == ARRAY_SIZE(ht20) - 1)\n\t\t\t\t \n\t\t\t\t*sgi = true;\n\t\t\telse\n\t\t\t\t*sgi = false;\n\n\t\t\t*mcs = i;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic bool is_rate_ht40(s32 rate, u8 *mcs, bool *sgi)\n{\n\tstatic const s32 ht40[] = { 13500, 27000, 40500, 54000,\n\t\t81000, 108000, 121500, 135000,\n\t\t150000\n\t};\n\tu8 i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ht40); i++) {\n\t\tif (rate == ht40[i]) {\n\t\t\tif (i == ARRAY_SIZE(ht40) - 1)\n\t\t\t\t \n\t\t\t\t*sgi = true;\n\t\t\telse\n\t\t\t\t*sgi = false;\n\n\t\t\t*mcs = i;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic int ath6kl_get_station(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t      const u8 *mac, struct station_info *sinfo)\n{\n\tstruct ath6kl *ar = ath6kl_priv(dev);\n\tstruct ath6kl_vif *vif = netdev_priv(dev);\n\tlong left;\n\tbool sgi;\n\ts32 rate;\n\tint ret;\n\tu8 mcs;\n\n\tif (memcmp(mac, vif->bssid, ETH_ALEN) != 0)\n\t\treturn -ENOENT;\n\n\tif (down_interruptible(&ar->sem))\n\t\treturn -EBUSY;\n\n\tset_bit(STATS_UPDATE_PEND, &vif->flags);\n\n\tret = ath6kl_wmi_get_stats_cmd(ar->wmi, vif->fw_vif_idx);\n\n\tif (ret != 0) {\n\t\tup(&ar->sem);\n\t\treturn -EIO;\n\t}\n\n\tleft = wait_event_interruptible_timeout(ar->event_wq,\n\t\t\t\t\t\t!test_bit(STATS_UPDATE_PEND,\n\t\t\t\t\t\t\t  &vif->flags),\n\t\t\t\t\t\tWMI_TIMEOUT);\n\n\tup(&ar->sem);\n\n\tif (left == 0)\n\t\treturn -ETIMEDOUT;\n\telse if (left < 0)\n\t\treturn left;\n\n\tif (vif->target_stats.rx_byte) {\n\t\tsinfo->rx_bytes = vif->target_stats.rx_byte;\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_BYTES64);\n\t\tsinfo->rx_packets = vif->target_stats.rx_pkt;\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_PACKETS);\n\t}\n\n\tif (vif->target_stats.tx_byte) {\n\t\tsinfo->tx_bytes = vif->target_stats.tx_byte;\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_BYTES64);\n\t\tsinfo->tx_packets = vif->target_stats.tx_pkt;\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_PACKETS);\n\t}\n\n\tsinfo->signal = vif->target_stats.cs_rssi;\n\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_SIGNAL);\n\n\trate = vif->target_stats.tx_ucast_rate;\n\n\tif (is_rate_legacy(rate)) {\n\t\tsinfo->txrate.legacy = rate / 100;\n\t} else if (is_rate_ht20(rate, &mcs, &sgi)) {\n\t\tif (sgi) {\n\t\t\tsinfo->txrate.flags |= RATE_INFO_FLAGS_SHORT_GI;\n\t\t\tsinfo->txrate.mcs = mcs - 1;\n\t\t} else {\n\t\t\tsinfo->txrate.mcs = mcs;\n\t\t}\n\n\t\tsinfo->txrate.flags |= RATE_INFO_FLAGS_MCS;\n\t\tsinfo->txrate.bw = RATE_INFO_BW_20;\n\t} else if (is_rate_ht40(rate, &mcs, &sgi)) {\n\t\tif (sgi) {\n\t\t\tsinfo->txrate.flags |= RATE_INFO_FLAGS_SHORT_GI;\n\t\t\tsinfo->txrate.mcs = mcs - 1;\n\t\t} else {\n\t\t\tsinfo->txrate.mcs = mcs;\n\t\t}\n\n\t\tsinfo->txrate.bw = RATE_INFO_BW_40;\n\t\tsinfo->txrate.flags |= RATE_INFO_FLAGS_MCS;\n\t} else {\n\t\tath6kl_dbg(ATH6KL_DBG_WLAN_CFG,\n\t\t\t   \"invalid rate from stats: %d\\n\", rate);\n\t\tath6kl_debug_war(ar, ATH6KL_WAR_INVALID_RATE);\n\t\treturn 0;\n\t}\n\n\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_BITRATE);\n\n\tif (test_bit(CONNECTED, &vif->flags) &&\n\t    test_bit(DTIM_PERIOD_AVAIL, &vif->flags) &&\n\t    vif->nw_type == INFRA_NETWORK) {\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_BSS_PARAM);\n\t\tsinfo->bss_param.flags = 0;\n\t\tsinfo->bss_param.dtim_period = vif->assoc_bss_dtim_period;\n\t\tsinfo->bss_param.beacon_interval = vif->assoc_bss_beacon_int;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath6kl_set_pmksa(struct wiphy *wiphy, struct net_device *netdev,\n\t\t\t    struct cfg80211_pmksa *pmksa)\n{\n\tstruct ath6kl *ar = ath6kl_priv(netdev);\n\tstruct ath6kl_vif *vif = netdev_priv(netdev);\n\n\treturn ath6kl_wmi_setpmkid_cmd(ar->wmi, vif->fw_vif_idx, pmksa->bssid,\n\t\t\t\t       pmksa->pmkid, true);\n}\n\nstatic int ath6kl_del_pmksa(struct wiphy *wiphy, struct net_device *netdev,\n\t\t\t    struct cfg80211_pmksa *pmksa)\n{\n\tstruct ath6kl *ar = ath6kl_priv(netdev);\n\tstruct ath6kl_vif *vif = netdev_priv(netdev);\n\n\treturn ath6kl_wmi_setpmkid_cmd(ar->wmi, vif->fw_vif_idx, pmksa->bssid,\n\t\t\t\t       pmksa->pmkid, false);\n}\n\nstatic int ath6kl_flush_pmksa(struct wiphy *wiphy, struct net_device *netdev)\n{\n\tstruct ath6kl *ar = ath6kl_priv(netdev);\n\tstruct ath6kl_vif *vif = netdev_priv(netdev);\n\n\tif (test_bit(CONNECTED, &vif->flags))\n\t\treturn ath6kl_wmi_setpmkid_cmd(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t\t       vif->bssid, NULL, false);\n\treturn 0;\n}\n\nstatic int ath6kl_wow_usr(struct ath6kl *ar, struct ath6kl_vif *vif,\n\t\t\t  struct cfg80211_wowlan *wow, u32 *filter)\n{\n\tint ret, pos;\n\tu8 mask[WOW_PATTERN_SIZE];\n\tu16 i;\n\n\t \n\tfor (i = 0; i < wow->n_patterns; i++) {\n\t\t \n\t\tmemset(&mask, 0, sizeof(mask));\n\t\tfor (pos = 0; pos < wow->patterns[i].pattern_len; pos++) {\n\t\t\tif (wow->patterns[i].mask[pos / 8] & (0x1 << (pos % 8)))\n\t\t\t\tmask[pos] = 0xFF;\n\t\t}\n\t\t \n\t\tret = ath6kl_wmi_add_wow_pattern_cmd(ar->wmi,\n\t\t\t\tvif->fw_vif_idx, WOW_LIST_ID,\n\t\t\t\twow->patterns[i].pattern_len,\n\t\t\t\t0  ,\n\t\t\t\twow->patterns[i].pattern, mask);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (wow->disconnect)\n\t\t*filter |= WOW_FILTER_OPTION_NWK_DISASSOC;\n\n\tif (wow->magic_pkt)\n\t\t*filter |= WOW_FILTER_OPTION_MAGIC_PACKET;\n\n\tif (wow->gtk_rekey_failure)\n\t\t*filter |= WOW_FILTER_OPTION_GTK_ERROR;\n\n\tif (wow->eap_identity_req)\n\t\t*filter |= WOW_FILTER_OPTION_EAP_REQ;\n\n\tif (wow->four_way_handshake)\n\t\t*filter |= WOW_FILTER_OPTION_8021X_4WAYHS;\n\n\treturn 0;\n}\n\nstatic int ath6kl_wow_ap(struct ath6kl *ar, struct ath6kl_vif *vif)\n{\n\tstatic const u8 unicst_pattern[] = { 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x08 };\n\tstatic const u8 unicst_mask[] = { 0x01, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x7f };\n\tu8 unicst_offset = 0;\n\tstatic const u8 arp_pattern[] = { 0x08, 0x06 };\n\tstatic const u8 arp_mask[] = { 0xff, 0xff };\n\tu8 arp_offset = 20;\n\tstatic const u8 discvr_pattern[] = { 0xe0, 0x00, 0x00, 0xf8 };\n\tstatic const u8 discvr_mask[] = { 0xf0, 0x00, 0x00, 0xf8 };\n\tu8 discvr_offset = 38;\n\tstatic const u8 dhcp_pattern[] = { 0xff, 0xff, 0xff, 0xff,\n\t\t0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x43   };\n\tstatic const u8 dhcp_mask[] = { 0xff, 0xff, 0xff, 0xff,\n\t\t0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0x00, 0x00, 0x00, 0x00, 0xff, 0xff   };\n\tu8 dhcp_offset = 0;\n\tint ret;\n\n\t \n\tret = ath6kl_wmi_add_wow_pattern_cmd(ar->wmi,\n\t\t\tvif->fw_vif_idx, WOW_LIST_ID,\n\t\t\tsizeof(unicst_pattern), unicst_offset,\n\t\t\tunicst_pattern, unicst_mask);\n\tif (ret) {\n\t\tath6kl_err(\"failed to add WOW unicast IP pattern\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = ath6kl_wmi_add_wow_pattern_cmd(ar->wmi,\n\t\t\tvif->fw_vif_idx, WOW_LIST_ID,\n\t\t\tsizeof(arp_pattern), arp_offset,\n\t\t\tarp_pattern, arp_mask);\n\tif (ret) {\n\t\tath6kl_err(\"failed to add WOW ARP pattern\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = ath6kl_wmi_add_wow_pattern_cmd(ar->wmi,\n\t\t\tvif->fw_vif_idx, WOW_LIST_ID,\n\t\t\tsizeof(discvr_pattern), discvr_offset,\n\t\t\tdiscvr_pattern, discvr_mask);\n\tif (ret) {\n\t\tath6kl_err(\"failed to add WOW mDNS/SSDP/LLMNR pattern\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = ath6kl_wmi_add_wow_pattern_cmd(ar->wmi,\n\t\t\tvif->fw_vif_idx, WOW_LIST_ID,\n\t\t\tsizeof(dhcp_pattern), dhcp_offset,\n\t\t\tdhcp_pattern, dhcp_mask);\n\tif (ret) {\n\t\tath6kl_err(\"failed to add WOW DHCP broadcast pattern\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath6kl_wow_sta(struct ath6kl *ar, struct ath6kl_vif *vif)\n{\n\tstruct net_device *ndev = vif->ndev;\n\tstatic const u8 discvr_pattern[] = { 0xe0, 0x00, 0x00, 0xf8 };\n\tstatic const u8 discvr_mask[] = { 0xf0, 0x00, 0x00, 0xf8 };\n\tu8 discvr_offset = 38;\n\tu8 mac_mask[ETH_ALEN];\n\tint ret;\n\n\t \n\teth_broadcast_addr(mac_mask);\n\tret = ath6kl_wmi_add_wow_pattern_cmd(ar->wmi,\n\t\t\t\tvif->fw_vif_idx, WOW_LIST_ID,\n\t\t\t\tETH_ALEN, 0, ndev->dev_addr,\n\t\t\t\tmac_mask);\n\tif (ret) {\n\t\tath6kl_err(\"failed to add WOW unicast pattern\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif ((ndev->flags & IFF_ALLMULTI) ||\n\t    (ndev->flags & IFF_MULTICAST && netdev_mc_count(ndev) > 0)) {\n\t\tret = ath6kl_wmi_add_wow_pattern_cmd(ar->wmi,\n\t\t\t\tvif->fw_vif_idx, WOW_LIST_ID,\n\t\t\t\tsizeof(discvr_pattern), discvr_offset,\n\t\t\t\tdiscvr_pattern, discvr_mask);\n\t\tif (ret) {\n\t\t\tath6kl_err(\"failed to add WOW mDNS/SSDP/LLMNR pattern\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int is_hsleep_mode_procsed(struct ath6kl_vif *vif)\n{\n\treturn test_bit(HOST_SLEEP_MODE_CMD_PROCESSED, &vif->flags);\n}\n\nstatic bool is_ctrl_ep_empty(struct ath6kl *ar)\n{\n\treturn !ar->tx_pending[ar->ctrl_ep];\n}\n\nstatic int ath6kl_cfg80211_host_sleep(struct ath6kl *ar, struct ath6kl_vif *vif)\n{\n\tint ret, left;\n\n\tclear_bit(HOST_SLEEP_MODE_CMD_PROCESSED, &vif->flags);\n\n\tret = ath6kl_wmi_set_host_sleep_mode_cmd(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t\t\t ATH6KL_HOST_MODE_ASLEEP);\n\tif (ret)\n\t\treturn ret;\n\n\tleft = wait_event_interruptible_timeout(ar->event_wq,\n\t\t\t\t\t\tis_hsleep_mode_procsed(vif),\n\t\t\t\t\t\tWMI_TIMEOUT);\n\tif (left == 0) {\n\t\tath6kl_warn(\"timeout, didn't get host sleep cmd processed event\\n\");\n\t\tret = -ETIMEDOUT;\n\t} else if (left < 0) {\n\t\tath6kl_warn(\"error while waiting for host sleep cmd processed event %d\\n\",\n\t\t\t    left);\n\t\tret = left;\n\t}\n\n\tif (ar->tx_pending[ar->ctrl_ep]) {\n\t\tleft = wait_event_interruptible_timeout(ar->event_wq,\n\t\t\t\t\t\t\tis_ctrl_ep_empty(ar),\n\t\t\t\t\t\t\tWMI_TIMEOUT);\n\t\tif (left == 0) {\n\t\t\tath6kl_warn(\"clear wmi ctrl data timeout\\n\");\n\t\t\tret = -ETIMEDOUT;\n\t\t} else if (left < 0) {\n\t\t\tath6kl_warn(\"clear wmi ctrl data failed: %d\\n\", left);\n\t\t\tret = left;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int ath6kl_wow_suspend_vif(struct ath6kl_vif *vif,\n\t\t\t\t  struct cfg80211_wowlan *wow, u32 *filter)\n{\n\tstruct ath6kl *ar = vif->ar;\n\tstruct in_device *in_dev;\n\tstruct in_ifaddr *ifa;\n\tint ret;\n\tu16 i, bmiss_time;\n\t__be32 ips[MAX_IP_ADDRS];\n\tu8 index = 0;\n\n\tif (!test_bit(NETDEV_MCAST_ALL_ON, &vif->flags) &&\n\t    test_bit(ATH6KL_FW_CAPABILITY_WOW_MULTICAST_FILTER,\n\t\t     ar->fw_capabilities)) {\n\t\tret = ath6kl_wmi_mcast_filter_cmd(vif->ar->wmi,\n\t\t\t\t\t\tvif->fw_vif_idx, false);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tfor (i = 0; i < WOW_MAX_FILTERS_PER_LIST; i++)\n\t\tath6kl_wmi_del_wow_pattern_cmd(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t\t       WOW_LIST_ID, i);\n\n\t \n\tif (wow)\n\t\tret = ath6kl_wow_usr(ar, vif, wow, filter);\n\telse if (vif->nw_type == AP_NETWORK)\n\t\tret = ath6kl_wow_ap(ar, vif);\n\telse\n\t\tret = ath6kl_wow_sta(ar, vif);\n\n\tif (ret)\n\t\treturn ret;\n\n\tnetif_stop_queue(vif->ndev);\n\n\tif (vif->nw_type != AP_NETWORK) {\n\t\tret = ath6kl_wmi_listeninterval_cmd(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t\t\t    ATH6KL_MAX_WOW_LISTEN_INTL,\n\t\t\t\t\t\t    0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tbmiss_time = ATH6KL_MAX_WOW_LISTEN_INTL * 15;\n\t\tif (bmiss_time > ATH6KL_MAX_BMISS_TIME)\n\t\t\tbmiss_time = ATH6KL_MAX_BMISS_TIME;\n\n\t\tret = ath6kl_wmi_bmisstime_cmd(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t\t       bmiss_time, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ath6kl_wmi_scanparams_cmd(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t\t\t0xFFFF, 0, 0xFFFF, 0, 0, 0,\n\t\t\t\t\t\t0, 0, 0, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tin_dev = __in_dev_get_rtnl(vif->ndev);\n\tif (!in_dev)\n\t\treturn 0;\n\n\tifa = rtnl_dereference(in_dev->ifa_list);\n\tmemset(&ips, 0, sizeof(ips));\n\n\t \n\twhile (index < MAX_IP_ADDRS && ifa) {\n\t\tips[index] = ifa->ifa_local;\n\t\tifa = rtnl_dereference(ifa->ifa_next);\n\t\tindex++;\n\t}\n\n\tif (ifa) {\n\t\tath6kl_err(\"total IP addr count is exceeding fw limit\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = ath6kl_wmi_set_ip_cmd(ar->wmi, vif->fw_vif_idx, ips[0], ips[1]);\n\tif (ret) {\n\t\tath6kl_err(\"fail to setup ip for arp agent\\n\");\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int ath6kl_wow_suspend(struct ath6kl *ar, struct cfg80211_wowlan *wow)\n{\n\tstruct ath6kl_vif *first_vif, *vif;\n\tint ret = 0;\n\tu32 filter = 0;\n\tbool connected = false;\n\n\t \n\tfirst_vif = ath6kl_vif_first(ar);\n\tif (WARN_ON(!first_vif) ||\n\t    !ath6kl_cfg80211_ready(first_vif))\n\t\treturn -EIO;\n\n\tif (wow && (wow->n_patterns > WOW_MAX_FILTERS_PER_LIST))\n\t\treturn -EINVAL;\n\n\t \n\tspin_lock_bh(&ar->list_lock);\n\tlist_for_each_entry(vif, &ar->vif_list, list) {\n\t\tif (!test_bit(CONNECTED, &vif->flags) ||\n\t\t    !ath6kl_cfg80211_ready(vif))\n\t\t\tcontinue;\n\t\tconnected = true;\n\n\t\tret = ath6kl_wow_suspend_vif(vif, wow, &filter);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tspin_unlock_bh(&ar->list_lock);\n\n\tif (!connected)\n\t\treturn -ENOTCONN;\n\telse if (ret)\n\t\treturn ret;\n\n\tar->state = ATH6KL_STATE_SUSPENDING;\n\n\tret = ath6kl_wmi_set_wow_mode_cmd(ar->wmi, first_vif->fw_vif_idx,\n\t\t\t\t\t  ATH6KL_WOW_MODE_ENABLE,\n\t\t\t\t\t  filter,\n\t\t\t\t\t  WOW_HOST_REQ_DELAY);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ath6kl_cfg80211_host_sleep(ar, first_vif);\n}\n\nstatic int ath6kl_wow_resume_vif(struct ath6kl_vif *vif)\n{\n\tstruct ath6kl *ar = vif->ar;\n\tint ret;\n\n\tif (vif->nw_type != AP_NETWORK) {\n\t\tret = ath6kl_wmi_scanparams_cmd(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t\t\t0, 0, 0, 0, 0, 0, 3, 0, 0, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ath6kl_wmi_listeninterval_cmd(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t\t\t    vif->listen_intvl_t, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ath6kl_wmi_bmisstime_cmd(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t\t       vif->bmiss_time_t, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (!test_bit(NETDEV_MCAST_ALL_OFF, &vif->flags) &&\n\t    test_bit(ATH6KL_FW_CAPABILITY_WOW_MULTICAST_FILTER,\n\t\t     ar->fw_capabilities)) {\n\t\tret = ath6kl_wmi_mcast_filter_cmd(vif->ar->wmi,\n\t\t\t\t\t\t  vif->fw_vif_idx, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tnetif_wake_queue(vif->ndev);\n\n\treturn 0;\n}\n\nstatic int ath6kl_wow_resume(struct ath6kl *ar)\n{\n\tstruct ath6kl_vif *vif;\n\tint ret;\n\n\tvif = ath6kl_vif_first(ar);\n\tif (WARN_ON(!vif) ||\n\t    !ath6kl_cfg80211_ready(vif))\n\t\treturn -EIO;\n\n\tar->state = ATH6KL_STATE_RESUMING;\n\n\tret = ath6kl_wmi_set_host_sleep_mode_cmd(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t\t\t ATH6KL_HOST_MODE_AWAKE);\n\tif (ret) {\n\t\tath6kl_warn(\"Failed to configure host sleep mode for wow resume: %d\\n\",\n\t\t\t    ret);\n\t\tgoto cleanup;\n\t}\n\n\tspin_lock_bh(&ar->list_lock);\n\tlist_for_each_entry(vif, &ar->vif_list, list) {\n\t\tif (!test_bit(CONNECTED, &vif->flags) ||\n\t\t    !ath6kl_cfg80211_ready(vif))\n\t\t\tcontinue;\n\t\tret = ath6kl_wow_resume_vif(vif);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tspin_unlock_bh(&ar->list_lock);\n\n\tif (ret)\n\t\tgoto cleanup;\n\n\tar->state = ATH6KL_STATE_ON;\n\treturn 0;\n\ncleanup:\n\tar->state = ATH6KL_STATE_WOW;\n\treturn ret;\n}\n\nstatic int ath6kl_cfg80211_deepsleep_suspend(struct ath6kl *ar)\n{\n\tstruct ath6kl_vif *vif;\n\tint ret;\n\n\tvif = ath6kl_vif_first(ar);\n\tif (!vif)\n\t\treturn -EIO;\n\n\tif (!test_bit(WMI_READY, &ar->flag)) {\n\t\tath6kl_err(\"deepsleep failed as wmi is not ready\\n\");\n\t\treturn -EIO;\n\t}\n\n\tath6kl_cfg80211_stop_all(ar);\n\n\t \n\tar->wmi->saved_pwr_mode = ar->wmi->pwr_mode;\n\n\tret = ath6kl_wmi_powermode_cmd(ar->wmi, 0, REC_POWER);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ath6kl_wmi_set_wow_mode_cmd(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t\t  ATH6KL_WOW_MODE_DISABLE,\n\t\t\t\t\t  0, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tath6kl_tx_data_cleanup(ar);\n\n\tret = ath6kl_cfg80211_host_sleep(ar, vif);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int ath6kl_cfg80211_deepsleep_resume(struct ath6kl *ar)\n{\n\tstruct ath6kl_vif *vif;\n\tint ret;\n\n\tvif = ath6kl_vif_first(ar);\n\n\tif (!vif)\n\t\treturn -EIO;\n\n\tif (ar->wmi->pwr_mode != ar->wmi->saved_pwr_mode) {\n\t\tret = ath6kl_wmi_powermode_cmd(ar->wmi, 0,\n\t\t\t\t\t       ar->wmi->saved_pwr_mode);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = ath6kl_wmi_set_host_sleep_mode_cmd(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t\t\t ATH6KL_HOST_MODE_AWAKE);\n\tif (ret)\n\t\treturn ret;\n\n\tar->state = ATH6KL_STATE_ON;\n\n\t \n\tret = ath6kl_wmi_scanparams_cmd(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t\t0, 0, 0, 0, 0, 0, 3, 0, 0, 0);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nint ath6kl_cfg80211_suspend(struct ath6kl *ar,\n\t\t\t    enum ath6kl_cfg_suspend_mode mode,\n\t\t\t    struct cfg80211_wowlan *wow)\n{\n\tstruct ath6kl_vif *vif;\n\tenum ath6kl_state prev_state;\n\tint ret;\n\n\tswitch (mode) {\n\tcase ATH6KL_CFG_SUSPEND_WOW:\n\n\t\tath6kl_dbg(ATH6KL_DBG_SUSPEND, \"wow mode suspend\\n\");\n\n\t\t \n\t\tath6kl_tx_data_cleanup(ar);\n\n\t\tprev_state = ar->state;\n\n\t\tret = ath6kl_wow_suspend(ar, wow);\n\t\tif (ret) {\n\t\t\tar->state = prev_state;\n\t\t\treturn ret;\n\t\t}\n\n\t\tar->state = ATH6KL_STATE_WOW;\n\t\tbreak;\n\n\tcase ATH6KL_CFG_SUSPEND_DEEPSLEEP:\n\n\t\tath6kl_dbg(ATH6KL_DBG_SUSPEND, \"deep sleep suspend\\n\");\n\n\t\tret = ath6kl_cfg80211_deepsleep_suspend(ar);\n\t\tif (ret) {\n\t\t\tath6kl_err(\"deepsleep suspend failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tar->state = ATH6KL_STATE_DEEPSLEEP;\n\n\t\tbreak;\n\n\tcase ATH6KL_CFG_SUSPEND_CUTPOWER:\n\n\t\tath6kl_cfg80211_stop_all(ar);\n\n\t\tif (ar->state == ATH6KL_STATE_OFF) {\n\t\t\tath6kl_dbg(ATH6KL_DBG_SUSPEND,\n\t\t\t\t   \"suspend hw off, no action for cutpower\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tath6kl_dbg(ATH6KL_DBG_SUSPEND, \"suspend cutting power\\n\");\n\n\t\tret = ath6kl_init_hw_stop(ar);\n\t\tif (ret) {\n\t\t\tath6kl_warn(\"failed to stop hw during suspend: %d\\n\",\n\t\t\t\t    ret);\n\t\t}\n\n\t\tar->state = ATH6KL_STATE_CUTPOWER;\n\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tlist_for_each_entry(vif, &ar->vif_list, list)\n\t\tath6kl_cfg80211_scan_complete_event(vif, true);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ath6kl_cfg80211_suspend);\n\nint ath6kl_cfg80211_resume(struct ath6kl *ar)\n{\n\tint ret;\n\n\tswitch (ar->state) {\n\tcase  ATH6KL_STATE_WOW:\n\t\tath6kl_dbg(ATH6KL_DBG_SUSPEND, \"wow mode resume\\n\");\n\n\t\tret = ath6kl_wow_resume(ar);\n\t\tif (ret) {\n\t\t\tath6kl_warn(\"wow mode resume failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tbreak;\n\n\tcase ATH6KL_STATE_DEEPSLEEP:\n\t\tath6kl_dbg(ATH6KL_DBG_SUSPEND, \"deep sleep resume\\n\");\n\n\t\tret = ath6kl_cfg80211_deepsleep_resume(ar);\n\t\tif (ret) {\n\t\t\tath6kl_warn(\"deep sleep resume failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\n\tcase ATH6KL_STATE_CUTPOWER:\n\t\tath6kl_dbg(ATH6KL_DBG_SUSPEND, \"resume restoring power\\n\");\n\n\t\tret = ath6kl_init_hw_start(ar);\n\t\tif (ret) {\n\t\t\tath6kl_warn(\"Failed to boot hw in resume: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ath6kl_cfg80211_resume);\n\n#ifdef CONFIG_PM\n\n \nstatic int __ath6kl_cfg80211_suspend(struct wiphy *wiphy,\n\t\t\t\t struct cfg80211_wowlan *wow)\n{\n\tstruct ath6kl *ar = wiphy_priv(wiphy);\n\n\tath6kl_recovery_suspend(ar);\n\n\treturn ath6kl_hif_suspend(ar, wow);\n}\n\nstatic int __ath6kl_cfg80211_resume(struct wiphy *wiphy)\n{\n\tstruct ath6kl *ar = wiphy_priv(wiphy);\n\tint err;\n\n\terr = ath6kl_hif_resume(ar);\n\tif (err)\n\t\treturn err;\n\n\tath6kl_recovery_resume(ar);\n\n\treturn 0;\n}\n\n \nvoid ath6kl_check_wow_status(struct ath6kl *ar)\n{\n\tif (ar->state == ATH6KL_STATE_SUSPENDING)\n\t\treturn;\n\n\tif (ar->state == ATH6KL_STATE_WOW)\n\t\tath6kl_cfg80211_resume(ar);\n}\n\n#else\n\nvoid ath6kl_check_wow_status(struct ath6kl *ar)\n{\n}\n#endif\n\nstatic int ath6kl_set_htcap(struct ath6kl_vif *vif, enum nl80211_band band,\n\t\t\t    bool ht_enable)\n{\n\tstruct ath6kl_htcap *htcap = &vif->htcap[band];\n\n\tif (htcap->ht_enable == ht_enable)\n\t\treturn 0;\n\n\tif (ht_enable) {\n\t\t \n\t\thtcap->ht_enable = true;\n\t\thtcap->cap_info = (band == NL80211_BAND_2GHZ) ?\n\t\t\t\t   ath6kl_g_htcap : ath6kl_a_htcap;\n\t\thtcap->ampdu_factor = IEEE80211_HT_MAX_AMPDU_16K;\n\t} else  \n\t\tmemset(htcap, 0, sizeof(*htcap));\n\n\treturn ath6kl_wmi_set_htcap_cmd(vif->ar->wmi, vif->fw_vif_idx,\n\t\t\t\t\tband, htcap);\n}\n\nstatic int ath6kl_restore_htcap(struct ath6kl_vif *vif)\n{\n\tstruct wiphy *wiphy = vif->ar->wiphy;\n\tint band, ret = 0;\n\n\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\tif (!wiphy->bands[band])\n\t\t\tcontinue;\n\n\t\tret = ath6kl_set_htcap(vif, band,\n\t\t\t\twiphy->bands[band]->ht_cap.ht_supported);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic bool ath6kl_is_p2p_ie(const u8 *pos)\n{\n\treturn pos[0] == WLAN_EID_VENDOR_SPECIFIC && pos[1] >= 4 &&\n\t\tpos[2] == 0x50 && pos[3] == 0x6f &&\n\t\tpos[4] == 0x9a && pos[5] == 0x09;\n}\n\nstatic int ath6kl_set_ap_probe_resp_ies(struct ath6kl_vif *vif,\n\t\t\t\t\tconst u8 *ies, size_t ies_len)\n{\n\tstruct ath6kl *ar = vif->ar;\n\tconst u8 *pos;\n\tu8 *buf = NULL;\n\tsize_t len = 0;\n\tint ret;\n\n\t \n\n\tif (ies && ies_len) {\n\t\tbuf = kmalloc(ies_len, GFP_KERNEL);\n\t\tif (buf == NULL)\n\t\t\treturn -ENOMEM;\n\t\tpos = ies;\n\t\twhile (pos + 1 < ies + ies_len) {\n\t\t\tif (pos + 2 + pos[1] > ies + ies_len)\n\t\t\t\tbreak;\n\t\t\tif (!ath6kl_is_p2p_ie(pos)) {\n\t\t\t\tmemcpy(buf + len, pos, 2 + pos[1]);\n\t\t\t\tlen += 2 + pos[1];\n\t\t\t}\n\t\t\tpos += 2 + pos[1];\n\t\t}\n\t}\n\n\tret = ath6kl_wmi_set_appie_cmd(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t       WMI_FRAME_PROBE_RESP, buf, len);\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic int ath6kl_set_ies(struct ath6kl_vif *vif,\n\t\t\t  struct cfg80211_beacon_data *info)\n{\n\tstruct ath6kl *ar = vif->ar;\n\tint res;\n\n\t \n\tres = ath6kl_wmi_set_appie_cmd(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t       WMI_FRAME_BEACON,\n\t\t\t\t       info->beacon_ies,\n\t\t\t\t       info->beacon_ies_len);\n\tif (res)\n\t\treturn res;\n\n\t \n\tres = ath6kl_set_ap_probe_resp_ies(vif, info->proberesp_ies,\n\t\t\t\t\t   info->proberesp_ies_len);\n\tif (res)\n\t\treturn res;\n\n\t \n\tres = ath6kl_wmi_set_appie_cmd(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t       WMI_FRAME_ASSOC_RESP,\n\t\t\t\t       info->assocresp_ies,\n\t\t\t\t       info->assocresp_ies_len);\n\tif (res)\n\t\treturn res;\n\n\treturn 0;\n}\n\nstatic int ath6kl_get_rsn_capab(struct cfg80211_beacon_data *beacon,\n\t\t\t\tu8 *rsn_capab)\n{\n\tconst u8 *rsn_ie;\n\tsize_t rsn_ie_len;\n\tu16 cnt;\n\n\tif (!beacon->tail)\n\t\treturn -EINVAL;\n\n\trsn_ie = cfg80211_find_ie(WLAN_EID_RSN, beacon->tail, beacon->tail_len);\n\tif (!rsn_ie)\n\t\treturn -EINVAL;\n\n\trsn_ie_len = *(rsn_ie + 1);\n\t \n\trsn_ie += 2;\n\n\t \n\tif (rsn_ie_len < 2)\n\t\treturn -EINVAL;\n\trsn_ie +=  2;\n\trsn_ie_len -= 2;\n\n\t \n\tif (rsn_ie_len < 4)\n\t\treturn 0;\n\trsn_ie +=  4;\n\trsn_ie_len -= 4;\n\n\t \n\tif (rsn_ie_len < 2)\n\t\treturn 0;\n\tcnt = get_unaligned_le16(rsn_ie);\n\trsn_ie += (2 + cnt * 4);\n\trsn_ie_len -= (2 + cnt * 4);\n\n\t \n\tif (rsn_ie_len < 2)\n\t\treturn 0;\n\tcnt = get_unaligned_le16(rsn_ie);\n\trsn_ie += (2 + cnt * 4);\n\trsn_ie_len -= (2 + cnt * 4);\n\n\tif (rsn_ie_len < 2)\n\t\treturn 0;\n\n\tmemcpy(rsn_capab, rsn_ie, 2);\n\n\treturn 0;\n}\n\nstatic int ath6kl_start_ap(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t   struct cfg80211_ap_settings *info)\n{\n\tstruct ath6kl *ar = ath6kl_priv(dev);\n\tstruct ath6kl_vif *vif = netdev_priv(dev);\n\tstruct ieee80211_mgmt *mgmt;\n\tbool hidden = false;\n\tu8 *ies;\n\tstruct wmi_connect_cmd p;\n\tint res;\n\tint i, ret;\n\tu16 rsn_capab = 0;\n\tint inactivity_timeout = 0;\n\n\tath6kl_dbg(ATH6KL_DBG_WLAN_CFG, \"%s:\\n\", __func__);\n\n\tif (!ath6kl_cfg80211_ready(vif))\n\t\treturn -EIO;\n\n\tif (vif->next_mode != AP_NETWORK)\n\t\treturn -EOPNOTSUPP;\n\n\tres = ath6kl_set_ies(vif, &info->beacon);\n\n\tar->ap_mode_bkey.valid = false;\n\n\tret = ath6kl_wmi_ap_set_beacon_intvl_cmd(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t\t\t info->beacon_interval);\n\n\tif (ret)\n\t\tath6kl_warn(\"Failed to set beacon interval: %d\\n\", ret);\n\n\tret = ath6kl_wmi_ap_set_dtim_cmd(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t\t info->dtim_period);\n\n\t \n\tif (ret)\n\t\tath6kl_warn(\"Failed to set dtim_period in beacon: %d\\n\", ret);\n\n\tif (info->beacon.head == NULL)\n\t\treturn -EINVAL;\n\tmgmt = (struct ieee80211_mgmt *) info->beacon.head;\n\ties = mgmt->u.beacon.variable;\n\tif (ies > info->beacon.head + info->beacon.head_len)\n\t\treturn -EINVAL;\n\n\tif (info->ssid == NULL)\n\t\treturn -EINVAL;\n\tmemcpy(vif->ssid, info->ssid, info->ssid_len);\n\tvif->ssid_len = info->ssid_len;\n\tif (info->hidden_ssid != NL80211_HIDDEN_SSID_NOT_IN_USE)\n\t\thidden = true;\n\n\tres = ath6kl_wmi_ap_hidden_ssid(ar->wmi, vif->fw_vif_idx, hidden);\n\tif (res)\n\t\treturn res;\n\n\tret = ath6kl_set_auth_type(vif, info->auth_type);\n\tif (ret)\n\t\treturn ret;\n\n\tmemset(&p, 0, sizeof(p));\n\n\tfor (i = 0; i < info->crypto.n_akm_suites; i++) {\n\t\tswitch (info->crypto.akm_suites[i]) {\n\t\tcase WLAN_AKM_SUITE_8021X:\n\t\t\tif (info->crypto.wpa_versions & NL80211_WPA_VERSION_1)\n\t\t\t\tp.auth_mode |= WPA_AUTH;\n\t\t\tif (info->crypto.wpa_versions & NL80211_WPA_VERSION_2)\n\t\t\t\tp.auth_mode |= WPA2_AUTH;\n\t\t\tbreak;\n\t\tcase WLAN_AKM_SUITE_PSK:\n\t\t\tif (info->crypto.wpa_versions & NL80211_WPA_VERSION_1)\n\t\t\t\tp.auth_mode |= WPA_PSK_AUTH;\n\t\t\tif (info->crypto.wpa_versions & NL80211_WPA_VERSION_2)\n\t\t\t\tp.auth_mode |= WPA2_PSK_AUTH;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (p.auth_mode == 0)\n\t\tp.auth_mode = NONE_AUTH;\n\tvif->auth_mode = p.auth_mode;\n\n\tfor (i = 0; i < info->crypto.n_ciphers_pairwise; i++) {\n\t\tswitch (info->crypto.ciphers_pairwise[i]) {\n\t\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\t\tp.prwise_crypto_type |= WEP_CRYPT;\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\t\tp.prwise_crypto_type |= TKIP_CRYPT;\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\t\tp.prwise_crypto_type |= AES_CRYPT;\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_SMS4:\n\t\t\tp.prwise_crypto_type |= WAPI_CRYPT;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (p.prwise_crypto_type == 0) {\n\t\tp.prwise_crypto_type = NONE_CRYPT;\n\t\tath6kl_set_cipher(vif, 0, true);\n\t} else if (info->crypto.n_ciphers_pairwise == 1) {\n\t\tath6kl_set_cipher(vif, info->crypto.ciphers_pairwise[0], true);\n\t}\n\n\tswitch (info->crypto.cipher_group) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\tp.grp_crypto_type = WEP_CRYPT;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\tp.grp_crypto_type = TKIP_CRYPT;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tp.grp_crypto_type = AES_CRYPT;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_SMS4:\n\t\tp.grp_crypto_type = WAPI_CRYPT;\n\t\tbreak;\n\tdefault:\n\t\tp.grp_crypto_type = NONE_CRYPT;\n\t\tbreak;\n\t}\n\tath6kl_set_cipher(vif, info->crypto.cipher_group, false);\n\n\tp.nw_type = AP_NETWORK;\n\tvif->nw_type = vif->next_mode;\n\n\tp.ssid_len = vif->ssid_len;\n\tmemcpy(p.ssid, vif->ssid, vif->ssid_len);\n\tp.dot11_auth_mode = vif->dot11_auth_mode;\n\tp.ch = cpu_to_le16(info->chandef.chan->center_freq);\n\n\t \n\tres = ath6kl_wmi_ap_set_apsd(ar->wmi, vif->fw_vif_idx, true);\n\tif (res < 0)\n\t\treturn res;\n\n\tif (vif->wdev.iftype == NL80211_IFTYPE_P2P_GO) {\n\t\tp.nw_subtype = SUBTYPE_P2PGO;\n\t} else {\n\t\t \n\t\tp.nw_subtype = SUBTYPE_NONE;\n\t}\n\n\tif (info->inactivity_timeout) {\n\t\tinactivity_timeout = info->inactivity_timeout;\n\n\t\tif (test_bit(ATH6KL_FW_CAPABILITY_AP_INACTIVITY_MINS,\n\t\t\t     ar->fw_capabilities))\n\t\t\tinactivity_timeout = DIV_ROUND_UP(inactivity_timeout,\n\t\t\t\t\t\t\t  60);\n\n\t\tres = ath6kl_wmi_set_inact_period(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t\t\t  inactivity_timeout);\n\t\tif (res < 0)\n\t\t\treturn res;\n\t}\n\n\tif (ath6kl_set_htcap(vif, info->chandef.chan->band,\n\t\t\t     cfg80211_get_chandef_type(&info->chandef)\n\t\t\t\t\t!= NL80211_CHAN_NO_HT))\n\t\treturn -EIO;\n\n\t \n\tif (!ath6kl_get_rsn_capab(&info->beacon, (u8 *) &rsn_capab) &&\n\t    test_bit(ATH6KL_FW_CAPABILITY_RSN_CAP_OVERRIDE,\n\t\t     ar->fw_capabilities)) {\n\t\tres = ath6kl_wmi_set_ie_cmd(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t\t    WLAN_EID_RSN, WMI_RSN_IE_CAPB,\n\t\t\t\t\t    (const u8 *) &rsn_capab,\n\t\t\t\t\t    sizeof(rsn_capab));\n\t\tvif->rsn_capab = rsn_capab;\n\t\tif (res < 0)\n\t\t\treturn res;\n\t}\n\n\tmemcpy(&vif->profile, &p, sizeof(p));\n\tres = ath6kl_wmi_ap_profile_commit(ar->wmi, vif->fw_vif_idx, &p);\n\tif (res < 0)\n\t\treturn res;\n\n\treturn 0;\n}\n\nstatic int ath6kl_change_beacon(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\tstruct cfg80211_beacon_data *beacon)\n{\n\tstruct ath6kl_vif *vif = netdev_priv(dev);\n\n\tif (!ath6kl_cfg80211_ready(vif))\n\t\treturn -EIO;\n\n\tif (vif->next_mode != AP_NETWORK)\n\t\treturn -EOPNOTSUPP;\n\n\treturn ath6kl_set_ies(vif, beacon);\n}\n\nstatic int ath6kl_stop_ap(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t  unsigned int link_id)\n{\n\tstruct ath6kl *ar = ath6kl_priv(dev);\n\tstruct ath6kl_vif *vif = netdev_priv(dev);\n\n\tif (vif->nw_type != AP_NETWORK)\n\t\treturn -EOPNOTSUPP;\n\tif (!test_bit(CONNECTED, &vif->flags))\n\t\treturn -ENOTCONN;\n\n\tath6kl_wmi_disconnect_cmd(ar->wmi, vif->fw_vif_idx);\n\tclear_bit(CONNECTED, &vif->flags);\n\tnetif_carrier_off(vif->ndev);\n\n\t \n\treturn ath6kl_restore_htcap(vif);\n}\n\nstatic const u8 bcast_addr[ETH_ALEN] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\n\nstatic int ath6kl_del_station(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t      struct station_del_parameters *params)\n{\n\tstruct ath6kl *ar = ath6kl_priv(dev);\n\tstruct ath6kl_vif *vif = netdev_priv(dev);\n\tconst u8 *addr = params->mac ? params->mac : bcast_addr;\n\n\treturn ath6kl_wmi_ap_set_mlme(ar->wmi, vif->fw_vif_idx, WMI_AP_DEAUTH,\n\t\t\t\t      addr, WLAN_REASON_PREV_AUTH_NOT_VALID);\n}\n\nstatic int ath6kl_change_station(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t const u8 *mac,\n\t\t\t\t struct station_parameters *params)\n{\n\tstruct ath6kl *ar = ath6kl_priv(dev);\n\tstruct ath6kl_vif *vif = netdev_priv(dev);\n\tint err;\n\n\tif (vif->nw_type != AP_NETWORK)\n\t\treturn -EOPNOTSUPP;\n\n\terr = cfg80211_check_station_change(wiphy, params,\n\t\t\t\t\t    CFG80211_STA_AP_MLME_CLIENT);\n\tif (err)\n\t\treturn err;\n\n\tif (params->sta_flags_set & BIT(NL80211_STA_FLAG_AUTHORIZED))\n\t\treturn ath6kl_wmi_ap_set_mlme(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t\t      WMI_AP_MLME_AUTHORIZE, mac, 0);\n\treturn ath6kl_wmi_ap_set_mlme(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t      WMI_AP_MLME_UNAUTHORIZE, mac, 0);\n}\n\nstatic int ath6kl_remain_on_channel(struct wiphy *wiphy,\n\t\t\t\t    struct wireless_dev *wdev,\n\t\t\t\t    struct ieee80211_channel *chan,\n\t\t\t\t    unsigned int duration,\n\t\t\t\t    u64 *cookie)\n{\n\tstruct ath6kl_vif *vif = ath6kl_vif_from_wdev(wdev);\n\tstruct ath6kl *ar = ath6kl_priv(vif->ndev);\n\tu32 id;\n\n\t \n\tid = ++vif->last_roc_id;\n\tif (id == 0) {\n\t\t \n\t\tid = ++vif->last_roc_id;\n\t}\n\t*cookie = id;\n\n\treturn ath6kl_wmi_remain_on_chnl_cmd(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t\t     chan->center_freq, duration);\n}\n\nstatic int ath6kl_cancel_remain_on_channel(struct wiphy *wiphy,\n\t\t\t\t\t   struct wireless_dev *wdev,\n\t\t\t\t\t   u64 cookie)\n{\n\tstruct ath6kl_vif *vif = ath6kl_vif_from_wdev(wdev);\n\tstruct ath6kl *ar = ath6kl_priv(vif->ndev);\n\n\tif (cookie != vif->last_roc_id)\n\t\treturn -ENOENT;\n\tvif->last_cancel_roc_id = cookie;\n\n\treturn ath6kl_wmi_cancel_remain_on_chnl_cmd(ar->wmi, vif->fw_vif_idx);\n}\n\nstatic int ath6kl_send_go_probe_resp(struct ath6kl_vif *vif,\n\t\t\t\t     const u8 *buf, size_t len,\n\t\t\t\t     unsigned int freq)\n{\n\tstruct ath6kl *ar = vif->ar;\n\tconst u8 *pos;\n\tu8 *p2p;\n\tint p2p_len;\n\tint ret;\n\tconst struct ieee80211_mgmt *mgmt;\n\n\tmgmt = (const struct ieee80211_mgmt *) buf;\n\n\t \n\n\tp2p = kmalloc(len, GFP_KERNEL);\n\tif (p2p == NULL)\n\t\treturn -ENOMEM;\n\tp2p_len = 0;\n\n\tpos = mgmt->u.probe_resp.variable;\n\twhile (pos + 1 < buf + len) {\n\t\tif (pos + 2 + pos[1] > buf + len)\n\t\t\tbreak;\n\t\tif (ath6kl_is_p2p_ie(pos)) {\n\t\t\tmemcpy(p2p + p2p_len, pos, 2 + pos[1]);\n\t\t\tp2p_len += 2 + pos[1];\n\t\t}\n\t\tpos += 2 + pos[1];\n\t}\n\n\tret = ath6kl_wmi_send_probe_response_cmd(ar->wmi, vif->fw_vif_idx, freq,\n\t\t\t\t\t\t mgmt->da, p2p, p2p_len);\n\tkfree(p2p);\n\treturn ret;\n}\n\nstatic bool ath6kl_mgmt_powersave_ap(struct ath6kl_vif *vif,\n\t\t\t\t     u32 id,\n\t\t\t\t     u32 freq,\n\t\t\t\t     u32 wait,\n\t\t\t\t     const u8 *buf,\n\t\t\t\t     size_t len,\n\t\t\t\t     bool *more_data,\n\t\t\t\t     bool no_cck)\n{\n\tstruct ieee80211_mgmt *mgmt;\n\tstruct ath6kl_sta *conn;\n\tbool is_psq_empty = false;\n\tstruct ath6kl_mgmt_buff *mgmt_buf;\n\tsize_t mgmt_buf_size;\n\tstruct ath6kl *ar = vif->ar;\n\n\tmgmt = (struct ieee80211_mgmt *) buf;\n\tif (is_multicast_ether_addr(mgmt->da))\n\t\treturn false;\n\n\tconn = ath6kl_find_sta(vif, mgmt->da);\n\tif (!conn)\n\t\treturn false;\n\n\tif (conn->sta_flags & STA_PS_SLEEP) {\n\t\tif (!(conn->sta_flags & STA_PS_POLLED)) {\n\t\t\t \n\t\t\tmgmt_buf_size = len + sizeof(struct ath6kl_mgmt_buff);\n\t\t\tmgmt_buf = kmalloc(mgmt_buf_size, GFP_KERNEL);\n\t\t\tif (!mgmt_buf)\n\t\t\t\treturn false;\n\n\t\t\tINIT_LIST_HEAD(&mgmt_buf->list);\n\t\t\tmgmt_buf->id = id;\n\t\t\tmgmt_buf->freq = freq;\n\t\t\tmgmt_buf->wait = wait;\n\t\t\tmgmt_buf->len = len;\n\t\t\tmgmt_buf->no_cck = no_cck;\n\t\t\tmemcpy(mgmt_buf->buf, buf, len);\n\t\t\tspin_lock_bh(&conn->psq_lock);\n\t\t\tis_psq_empty = skb_queue_empty(&conn->psq) &&\n\t\t\t\t\t(conn->mgmt_psq_len == 0);\n\t\t\tlist_add_tail(&mgmt_buf->list, &conn->mgmt_psq);\n\t\t\tconn->mgmt_psq_len++;\n\t\t\tspin_unlock_bh(&conn->psq_lock);\n\n\t\t\t \n\t\t\tif (is_psq_empty)\n\t\t\t\tath6kl_wmi_set_pvb_cmd(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t\t\t       conn->aid, 1);\n\t\t\treturn true;\n\t\t}\n\n\t\t \n\t\tspin_lock_bh(&conn->psq_lock);\n\t\tif (!skb_queue_empty(&conn->psq) || (conn->mgmt_psq_len != 0))\n\t\t\t*more_data = true;\n\t\tspin_unlock_bh(&conn->psq_lock);\n\t}\n\n\treturn false;\n}\n\n \nstatic bool ath6kl_is_p2p_go_ssid(const u8 *buf, size_t len)\n{\n\tconst struct ieee80211_mgmt *mgmt;\n\tmgmt = (const struct ieee80211_mgmt *) buf;\n\n\t \n\tif (buf + len >= &mgmt->u.probe_resp.variable[1] &&\n\t    (mgmt->u.probe_resp.variable[1] > P2P_WILDCARD_SSID_LEN)) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int ath6kl_mgmt_tx(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t  struct cfg80211_mgmt_tx_params *params, u64 *cookie)\n{\n\tstruct ath6kl_vif *vif = ath6kl_vif_from_wdev(wdev);\n\tstruct ath6kl *ar = ath6kl_priv(vif->ndev);\n\tstruct ieee80211_channel *chan = params->chan;\n\tconst u8 *buf = params->buf;\n\tsize_t len = params->len;\n\tunsigned int wait = params->wait;\n\tbool no_cck = params->no_cck;\n\tu32 id, freq;\n\tconst struct ieee80211_mgmt *mgmt;\n\tbool more_data, queued;\n\n\t \n\tfreq = vif->ch_hint;\n\tif (chan)\n\t\tfreq = chan->center_freq;\n\n\t \n\tif (WARN_ON(freq == 0))\n\t\treturn -EINVAL;\n\n\tmgmt = (const struct ieee80211_mgmt *) buf;\n\tif (vif->nw_type == AP_NETWORK && test_bit(CONNECTED, &vif->flags) &&\n\t    ieee80211_is_probe_resp(mgmt->frame_control) &&\n\t    ath6kl_is_p2p_go_ssid(buf, len)) {\n\t\t \n\t\t*cookie = 0;  \n\t\treturn ath6kl_send_go_probe_resp(vif, buf, len, freq);\n\t}\n\n\tid = vif->send_action_id++;\n\tif (id == 0) {\n\t\t \n\t\tid = vif->send_action_id++;\n\t}\n\n\t*cookie = id;\n\n\t \n\tif (vif->nw_type == AP_NETWORK) {\n\t\tqueued = ath6kl_mgmt_powersave_ap(vif, id, freq, wait, buf, len,\n\t\t\t\t\t\t  &more_data, no_cck);\n\t\tif (queued)\n\t\t\treturn 0;\n\t}\n\n\treturn ath6kl_wmi_send_mgmt_cmd(ar->wmi, vif->fw_vif_idx, id, freq,\n\t\t\t\t\twait, buf, len, no_cck);\n}\n\nstatic int ath6kl_get_antenna(struct wiphy *wiphy,\n\t\t\t      u32 *tx_ant, u32 *rx_ant)\n{\n\tstruct ath6kl *ar = wiphy_priv(wiphy);\n\t*tx_ant = ar->hw.tx_ant;\n\t*rx_ant = ar->hw.rx_ant;\n\treturn 0;\n}\n\nstatic void ath6kl_update_mgmt_frame_registrations(struct wiphy *wiphy,\n\t\t\t\t\t\t   struct wireless_dev *wdev,\n\t\t\t\t\t\t   struct mgmt_frame_regs *upd)\n{\n\tstruct ath6kl_vif *vif = ath6kl_vif_from_wdev(wdev);\n\n\t \n\tvif->probe_req_report =\n\t\tupd->interface_stypes & BIT(IEEE80211_STYPE_PROBE_REQ >> 4);\n}\n\nstatic int ath6kl_cfg80211_sscan_start(struct wiphy *wiphy,\n\t\t\tstruct net_device *dev,\n\t\t\tstruct cfg80211_sched_scan_request *request)\n{\n\tstruct ath6kl *ar = ath6kl_priv(dev);\n\tstruct ath6kl_vif *vif = netdev_priv(dev);\n\tu16 interval;\n\tint ret, rssi_thold;\n\tint n_match_sets = request->n_match_sets;\n\n\t \n\tif (n_match_sets == 1 && !request->match_sets[0].ssid.ssid_len)\n\t\tn_match_sets = 0;\n\n\tif (ar->state != ATH6KL_STATE_ON)\n\t\treturn -EIO;\n\n\tif (vif->sme_state != SME_DISCONNECTED)\n\t\treturn -EBUSY;\n\n\tath6kl_cfg80211_scan_complete_event(vif, true);\n\n\tret = ath6kl_set_probed_ssids(ar, vif, request->ssids,\n\t\t\t\t      request->n_ssids,\n\t\t\t\t      request->match_sets,\n\t\t\t\t      n_match_sets);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!n_match_sets) {\n\t\tret = ath6kl_wmi_bssfilter_cmd(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t\t       ALL_BSS_FILTER, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tret = ath6kl_wmi_bssfilter_cmd(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t\t       MATCHED_SSID_FILTER, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (test_bit(ATH6KL_FW_CAPABILITY_RSSI_SCAN_THOLD,\n\t\t     ar->fw_capabilities)) {\n\t\tif (request->min_rssi_thold <= NL80211_SCAN_RSSI_THOLD_OFF)\n\t\t\trssi_thold = 0;\n\t\telse if (request->min_rssi_thold < -127)\n\t\t\trssi_thold = -127;\n\t\telse\n\t\t\trssi_thold = request->min_rssi_thold;\n\n\t\tret = ath6kl_wmi_set_rssi_filter_cmd(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t\t\t     rssi_thold);\n\t\tif (ret) {\n\t\t\tath6kl_err(\"failed to set RSSI threshold for scan\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tinterval = max_t(u16, 1, request->scan_plans[0].interval);\n\n\tath6kl_wmi_scanparams_cmd(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t  interval, interval,\n\t\t\t\t  vif->bg_scan_period, 0, 0, 0, 3, 0, 0, 0);\n\n\t \n\tret = ath6kl_wmi_set_appie_cmd(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t       WMI_FRAME_PROBE_REQ,\n\t\t\t\t       request->ie, request->ie_len);\n\tif (ret) {\n\t\tath6kl_warn(\"Failed to set probe request IE for scheduled scan: %d\\n\",\n\t\t\t    ret);\n\t\treturn ret;\n\t}\n\n\tret = ath6kl_wmi_enable_sched_scan_cmd(ar->wmi, vif->fw_vif_idx, true);\n\tif (ret)\n\t\treturn ret;\n\n\tset_bit(SCHED_SCANNING, &vif->flags);\n\n\treturn 0;\n}\n\nstatic int ath6kl_cfg80211_sscan_stop(struct wiphy *wiphy,\n\t\t\t\t      struct net_device *dev, u64 reqid)\n{\n\tstruct ath6kl_vif *vif = netdev_priv(dev);\n\tbool stopped;\n\n\tstopped = __ath6kl_cfg80211_sscan_stop(vif);\n\n\tif (!stopped)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int ath6kl_cfg80211_set_bitrate(struct wiphy *wiphy,\n\t\t\t\t       struct net_device *dev,\n\t\t\t\t       unsigned int link_id,\n\t\t\t\t       const u8 *addr,\n\t\t\t\t       const struct cfg80211_bitrate_mask *mask)\n{\n\tstruct ath6kl *ar = ath6kl_priv(dev);\n\tstruct ath6kl_vif *vif = netdev_priv(dev);\n\n\treturn ath6kl_wmi_set_bitrate_mask(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t\t   mask);\n}\n\nstatic int ath6kl_cfg80211_set_txe_config(struct wiphy *wiphy,\n\t\t\t\t\t  struct net_device *dev,\n\t\t\t\t\t  u32 rate, u32 pkts, u32 intvl)\n{\n\tstruct ath6kl *ar = ath6kl_priv(dev);\n\tstruct ath6kl_vif *vif = netdev_priv(dev);\n\n\tif (vif->nw_type != INFRA_NETWORK ||\n\t    !test_bit(ATH6KL_FW_CAPABILITY_TX_ERR_NOTIFY, ar->fw_capabilities))\n\t\treturn -EOPNOTSUPP;\n\n\tif (vif->sme_state != SME_CONNECTED)\n\t\treturn -ENOTCONN;\n\n\t \n\tvif->txe_intvl = intvl;\n\n\treturn ath6kl_wmi_set_txe_notify(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t\t rate, pkts, intvl);\n}\n\nstatic const struct ieee80211_txrx_stypes\nath6kl_mgmt_stypes[NUM_NL80211_IFTYPES] = {\n\t[NL80211_IFTYPE_STATION] = {\n\t\t.tx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\tBIT(IEEE80211_STYPE_PROBE_RESP >> 4),\n\t\t.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\tBIT(IEEE80211_STYPE_PROBE_REQ >> 4)\n\t},\n\t[NL80211_IFTYPE_AP] = {\n\t\t.tx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\tBIT(IEEE80211_STYPE_PROBE_RESP >> 4),\n\t\t.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\tBIT(IEEE80211_STYPE_PROBE_REQ >> 4)\n\t},\n\t[NL80211_IFTYPE_P2P_CLIENT] = {\n\t\t.tx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\tBIT(IEEE80211_STYPE_PROBE_RESP >> 4),\n\t\t.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\tBIT(IEEE80211_STYPE_PROBE_REQ >> 4)\n\t},\n\t[NL80211_IFTYPE_P2P_GO] = {\n\t\t.tx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\tBIT(IEEE80211_STYPE_PROBE_RESP >> 4),\n\t\t.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\tBIT(IEEE80211_STYPE_PROBE_REQ >> 4)\n\t},\n};\n\nstatic struct cfg80211_ops ath6kl_cfg80211_ops = {\n\t.add_virtual_intf = ath6kl_cfg80211_add_iface,\n\t.del_virtual_intf = ath6kl_cfg80211_del_iface,\n\t.change_virtual_intf = ath6kl_cfg80211_change_iface,\n\t.scan = ath6kl_cfg80211_scan,\n\t.connect = ath6kl_cfg80211_connect,\n\t.disconnect = ath6kl_cfg80211_disconnect,\n\t.add_key = ath6kl_cfg80211_add_key,\n\t.get_key = ath6kl_cfg80211_get_key,\n\t.del_key = ath6kl_cfg80211_del_key,\n\t.set_default_key = ath6kl_cfg80211_set_default_key,\n\t.set_wiphy_params = ath6kl_cfg80211_set_wiphy_params,\n\t.set_tx_power = ath6kl_cfg80211_set_txpower,\n\t.get_tx_power = ath6kl_cfg80211_get_txpower,\n\t.set_power_mgmt = ath6kl_cfg80211_set_power_mgmt,\n\t.join_ibss = ath6kl_cfg80211_join_ibss,\n\t.leave_ibss = ath6kl_cfg80211_leave_ibss,\n\t.get_station = ath6kl_get_station,\n\t.set_pmksa = ath6kl_set_pmksa,\n\t.del_pmksa = ath6kl_del_pmksa,\n\t.flush_pmksa = ath6kl_flush_pmksa,\n\tCFG80211_TESTMODE_CMD(ath6kl_tm_cmd)\n#ifdef CONFIG_PM\n\t.suspend = __ath6kl_cfg80211_suspend,\n\t.resume = __ath6kl_cfg80211_resume,\n#endif\n\t.start_ap = ath6kl_start_ap,\n\t.change_beacon = ath6kl_change_beacon,\n\t.stop_ap = ath6kl_stop_ap,\n\t.del_station = ath6kl_del_station,\n\t.change_station = ath6kl_change_station,\n\t.remain_on_channel = ath6kl_remain_on_channel,\n\t.cancel_remain_on_channel = ath6kl_cancel_remain_on_channel,\n\t.mgmt_tx = ath6kl_mgmt_tx,\n\t.update_mgmt_frame_registrations =\n\t\tath6kl_update_mgmt_frame_registrations,\n\t.get_antenna = ath6kl_get_antenna,\n\t.sched_scan_start = ath6kl_cfg80211_sscan_start,\n\t.sched_scan_stop = ath6kl_cfg80211_sscan_stop,\n\t.set_bitrate_mask = ath6kl_cfg80211_set_bitrate,\n\t.set_cqm_txe_config = ath6kl_cfg80211_set_txe_config,\n};\n\nvoid ath6kl_cfg80211_stop(struct ath6kl_vif *vif)\n{\n\tath6kl_cfg80211_sscan_disable(vif);\n\n\tswitch (vif->sme_state) {\n\tcase SME_DISCONNECTED:\n\t\tbreak;\n\tcase SME_CONNECTING:\n\t\tcfg80211_connect_result(vif->ndev, vif->bssid, NULL, 0,\n\t\t\t\t\tNULL, 0,\n\t\t\t\t\tWLAN_STATUS_UNSPECIFIED_FAILURE,\n\t\t\t\t\tGFP_KERNEL);\n\t\tbreak;\n\tcase SME_CONNECTED:\n\t\tcfg80211_disconnected(vif->ndev, 0, NULL, 0, true, GFP_KERNEL);\n\t\tbreak;\n\t}\n\n\tif (vif->ar->state != ATH6KL_STATE_RECOVERY &&\n\t    (test_bit(CONNECTED, &vif->flags) ||\n\t    test_bit(CONNECT_PEND, &vif->flags)))\n\t\tath6kl_wmi_disconnect_cmd(vif->ar->wmi, vif->fw_vif_idx);\n\n\tvif->sme_state = SME_DISCONNECTED;\n\tclear_bit(CONNECTED, &vif->flags);\n\tclear_bit(CONNECT_PEND, &vif->flags);\n\n\t \n\tnetif_stop_queue(vif->ndev);\n\tnetif_carrier_off(vif->ndev);\n\n\t \n\tif (vif->ar->state != ATH6KL_STATE_RECOVERY &&\n\t    ath6kl_wmi_scanparams_cmd(vif->ar->wmi, vif->fw_vif_idx, 0xFFFF,\n\t\t\t\t      0, 0, 0, 0, 0, 0, 0, 0, 0) != 0)\n\t\tath6kl_warn(\"failed to disable scan during stop\\n\");\n\n\tath6kl_cfg80211_scan_complete_event(vif, true);\n}\n\nvoid ath6kl_cfg80211_stop_all(struct ath6kl *ar)\n{\n\tstruct ath6kl_vif *vif;\n\n\tvif = ath6kl_vif_first(ar);\n\tif (!vif && ar->state != ATH6KL_STATE_RECOVERY) {\n\t\t \n\t\tar->wmi->saved_pwr_mode = ar->wmi->pwr_mode;\n\n\t\tif (ath6kl_wmi_powermode_cmd(ar->wmi, 0, REC_POWER) != 0)\n\t\t\tath6kl_warn(\"ath6kl_deep_sleep_enable: wmi_powermode_cmd failed\\n\");\n\t\treturn;\n\t}\n\n\t \n\tlist_for_each_entry(vif, &ar->vif_list, list)\n\t\tath6kl_cfg80211_stop(vif);\n}\n\nstatic void ath6kl_cfg80211_reg_notify(struct wiphy *wiphy,\n\t\t\t\t       struct regulatory_request *request)\n{\n\tstruct ath6kl *ar = wiphy_priv(wiphy);\n\tu32 rates[NUM_NL80211_BANDS];\n\tint ret, i;\n\n\tath6kl_dbg(ATH6KL_DBG_WLAN_CFG,\n\t\t   \"cfg reg_notify %c%c%s%s initiator %d hint_type %d\\n\",\n\t\t   request->alpha2[0], request->alpha2[1],\n\t\t   request->intersect ? \" intersect\" : \"\",\n\t\t   request->processed ? \" processed\" : \"\",\n\t\t   request->initiator, request->user_reg_hint_type);\n\n\tif (request->user_reg_hint_type != NL80211_USER_REG_HINT_CELL_BASE)\n\t\treturn;\n\n\tret = ath6kl_wmi_set_regdomain_cmd(ar->wmi, request->alpha2);\n\tif (ret) {\n\t\tath6kl_err(\"failed to set regdomain: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\t \n\n\tfor (i = 0; i < NUM_NL80211_BANDS; i++)\n\t\tif (wiphy->bands[i])\n\t\t\trates[i] = (1 << wiphy->bands[i]->n_bitrates) - 1;\n\n\n\tret = ath6kl_wmi_beginscan_cmd(ar->wmi, 0, WMI_LONG_SCAN, false,\n\t\t\t\t       false, 0, ATH6KL_FG_SCAN_INTERVAL,\n\t\t\t\t       0, NULL, false, rates);\n\tif (ret) {\n\t\tath6kl_err(\"failed to start scan for a regdomain change: %d\\n\",\n\t\t\t   ret);\n\t\treturn;\n\t}\n}\n\nstatic int ath6kl_cfg80211_vif_init(struct ath6kl_vif *vif)\n{\n\tvif->aggr_cntxt = aggr_init(vif);\n\tif (!vif->aggr_cntxt) {\n\t\tath6kl_err(\"failed to initialize aggr\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\ttimer_setup(&vif->disconnect_timer, disconnect_timer_handler, 0);\n\ttimer_setup(&vif->sched_scan_timer, ath6kl_wmi_sscan_timer, 0);\n\n\tset_bit(WMM_ENABLED, &vif->flags);\n\tspin_lock_init(&vif->if_lock);\n\n\tINIT_LIST_HEAD(&vif->mc_filter);\n\n\treturn 0;\n}\n\nvoid ath6kl_cfg80211_vif_stop(struct ath6kl_vif *vif, bool wmi_ready)\n{\n\tstatic u8 bcast_mac[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\n\tbool discon_issued;\n\n\tnetif_stop_queue(vif->ndev);\n\n\tclear_bit(WLAN_ENABLED, &vif->flags);\n\n\tif (wmi_ready) {\n\t\tdiscon_issued = test_bit(CONNECTED, &vif->flags) ||\n\t\t\t\ttest_bit(CONNECT_PEND, &vif->flags);\n\t\tath6kl_disconnect(vif);\n\t\tdel_timer(&vif->disconnect_timer);\n\n\t\tif (discon_issued)\n\t\t\tath6kl_disconnect_event(vif, DISCONNECT_CMD,\n\t\t\t\t\t\t(vif->nw_type & AP_NETWORK) ?\n\t\t\t\t\t\tbcast_mac : vif->bssid,\n\t\t\t\t\t\t0, NULL, 0);\n\t}\n\n\tif (vif->scan_req) {\n\t\tstruct cfg80211_scan_info info = {\n\t\t\t.aborted = true,\n\t\t};\n\n\t\tcfg80211_scan_done(vif->scan_req, &info);\n\t\tvif->scan_req = NULL;\n\t}\n\n\t \n\tath6kl_cfg80211_sta_bmiss_enhance(vif, false);\n}\n\nvoid ath6kl_cfg80211_vif_cleanup(struct ath6kl_vif *vif)\n{\n\tstruct ath6kl *ar = vif->ar;\n\tstruct ath6kl_mc_filter *mc_filter, *tmp;\n\n\taggr_module_destroy(vif->aggr_cntxt);\n\n\tar->avail_idx_map |= BIT(vif->fw_vif_idx);\n\n\tif (vif->nw_type == ADHOC_NETWORK)\n\t\tar->ibss_if_active = false;\n\n\tlist_for_each_entry_safe(mc_filter, tmp, &vif->mc_filter, list) {\n\t\tlist_del(&mc_filter->list);\n\t\tkfree(mc_filter);\n\t}\n\n\tcfg80211_unregister_netdevice(vif->ndev);\n\n\tar->num_vif--;\n}\n\nstatic const char ath6kl_gstrings_sta_stats[][ETH_GSTRING_LEN] = {\n\t \n\t\"tx_pkts_nic\", \"tx_bytes_nic\", \"rx_pkts_nic\", \"rx_bytes_nic\",\n\n\t \n\t\"d_tx_ucast_pkts\", \"d_tx_bcast_pkts\",\n\t\"d_tx_ucast_bytes\", \"d_tx_bcast_bytes\",\n\t\"d_tx_rts_ok\", \"d_tx_error\", \"d_tx_fail\",\n\t\"d_tx_retry\", \"d_tx_multi_retry\", \"d_tx_rts_fail\",\n\t\"d_tx_tkip_counter_measures\",\n\n\t \n\t\"d_rx_ucast_pkts\", \"d_rx_ucast_rate\", \"d_rx_bcast_pkts\",\n\t\"d_rx_ucast_bytes\", \"d_rx_bcast_bytes\", \"d_rx_frag_pkt\",\n\t\"d_rx_error\", \"d_rx_crc_err\", \"d_rx_keycache_miss\",\n\t\"d_rx_decrypt_crc_err\", \"d_rx_duplicate_frames\",\n\t\"d_rx_mic_err\", \"d_rx_tkip_format_err\", \"d_rx_ccmp_format_err\",\n\t\"d_rx_ccmp_replay_err\",\n\n\t \n\t\"d_beacon_miss\", \"d_num_connects\", \"d_num_disconnects\",\n\t\"d_beacon_avg_rssi\", \"d_arp_received\", \"d_arp_matched\",\n\t\"d_arp_replied\"\n};\n\n#define ATH6KL_STATS_LEN\tARRAY_SIZE(ath6kl_gstrings_sta_stats)\n\nstatic int ath6kl_get_sset_count(struct net_device *dev, int sset)\n{\n\tint rv = 0;\n\n\tif (sset == ETH_SS_STATS)\n\t\trv += ATH6KL_STATS_LEN;\n\n\tif (rv == 0)\n\t\treturn -EOPNOTSUPP;\n\treturn rv;\n}\n\nstatic void ath6kl_get_stats(struct net_device *dev,\n\t\t\t    struct ethtool_stats *stats,\n\t\t\t    u64 *data)\n{\n\tstruct ath6kl_vif *vif = netdev_priv(dev);\n\tstruct ath6kl *ar = vif->ar;\n\tint i = 0;\n\tstruct target_stats *tgt_stats;\n\n\tmemset(data, 0, sizeof(u64) * ATH6KL_STATS_LEN);\n\n\tath6kl_read_tgt_stats(ar, vif);\n\n\ttgt_stats = &vif->target_stats;\n\n\tdata[i++] = tgt_stats->tx_ucast_pkt + tgt_stats->tx_bcast_pkt;\n\tdata[i++] = tgt_stats->tx_ucast_byte + tgt_stats->tx_bcast_byte;\n\tdata[i++] = tgt_stats->rx_ucast_pkt + tgt_stats->rx_bcast_pkt;\n\tdata[i++] = tgt_stats->rx_ucast_byte + tgt_stats->rx_bcast_byte;\n\n\tdata[i++] = tgt_stats->tx_ucast_pkt;\n\tdata[i++] = tgt_stats->tx_bcast_pkt;\n\tdata[i++] = tgt_stats->tx_ucast_byte;\n\tdata[i++] = tgt_stats->tx_bcast_byte;\n\tdata[i++] = tgt_stats->tx_rts_success_cnt;\n\tdata[i++] = tgt_stats->tx_err;\n\tdata[i++] = tgt_stats->tx_fail_cnt;\n\tdata[i++] = tgt_stats->tx_retry_cnt;\n\tdata[i++] = tgt_stats->tx_mult_retry_cnt;\n\tdata[i++] = tgt_stats->tx_rts_fail_cnt;\n\tdata[i++] = tgt_stats->tkip_cnter_measures_invoked;\n\n\tdata[i++] = tgt_stats->rx_ucast_pkt;\n\tdata[i++] = tgt_stats->rx_ucast_rate;\n\tdata[i++] = tgt_stats->rx_bcast_pkt;\n\tdata[i++] = tgt_stats->rx_ucast_byte;\n\tdata[i++] = tgt_stats->rx_bcast_byte;\n\tdata[i++] = tgt_stats->rx_frgment_pkt;\n\tdata[i++] = tgt_stats->rx_err;\n\tdata[i++] = tgt_stats->rx_crc_err;\n\tdata[i++] = tgt_stats->rx_key_cache_miss;\n\tdata[i++] = tgt_stats->rx_decrypt_err;\n\tdata[i++] = tgt_stats->rx_dupl_frame;\n\tdata[i++] = tgt_stats->tkip_local_mic_fail;\n\tdata[i++] = tgt_stats->tkip_fmt_err;\n\tdata[i++] = tgt_stats->ccmp_fmt_err;\n\tdata[i++] = tgt_stats->ccmp_replays;\n\n\tdata[i++] = tgt_stats->cs_bmiss_cnt;\n\tdata[i++] = tgt_stats->cs_connect_cnt;\n\tdata[i++] = tgt_stats->cs_discon_cnt;\n\tdata[i++] = tgt_stats->cs_ave_beacon_rssi;\n\tdata[i++] = tgt_stats->arp_received;\n\tdata[i++] = tgt_stats->arp_matched;\n\tdata[i++] = tgt_stats->arp_replied;\n\n\tif (i !=  ATH6KL_STATS_LEN) {\n\t\tWARN_ON_ONCE(1);\n\t\tath6kl_err(\"ethtool stats error, i: %d  STATS_LEN: %d\\n\",\n\t\t\t   i, (int)ATH6KL_STATS_LEN);\n\t}\n}\n\n \nstatic void ath6kl_get_strings(struct net_device *dev, u32 sset, u8 *data)\n{\n\tint sz_sta_stats = 0;\n\n\tif (sset == ETH_SS_STATS) {\n\t\tsz_sta_stats = sizeof(ath6kl_gstrings_sta_stats);\n\t\tmemcpy(data, ath6kl_gstrings_sta_stats, sz_sta_stats);\n\t}\n}\n\nstatic const struct ethtool_ops ath6kl_ethtool_ops = {\n\t.get_drvinfo = cfg80211_get_drvinfo,\n\t.get_link = ethtool_op_get_link,\n\t.get_strings = ath6kl_get_strings,\n\t.get_ethtool_stats = ath6kl_get_stats,\n\t.get_sset_count = ath6kl_get_sset_count,\n};\n\nstruct wireless_dev *ath6kl_interface_add(struct ath6kl *ar, const char *name,\n\t\t\t\t\t  unsigned char name_assign_type,\n\t\t\t\t\t  enum nl80211_iftype type,\n\t\t\t\t\t  u8 fw_vif_idx, u8 nw_type)\n{\n\tstruct net_device *ndev;\n\tstruct ath6kl_vif *vif;\n\tu8 addr[ETH_ALEN];\n\n\tndev = alloc_netdev(sizeof(*vif), name, name_assign_type, ether_setup);\n\tif (!ndev)\n\t\treturn NULL;\n\n\tvif = netdev_priv(ndev);\n\tndev->ieee80211_ptr = &vif->wdev;\n\tvif->wdev.wiphy = ar->wiphy;\n\tvif->ar = ar;\n\tvif->ndev = ndev;\n\tSET_NETDEV_DEV(ndev, wiphy_dev(vif->wdev.wiphy));\n\tvif->wdev.netdev = ndev;\n\tvif->wdev.iftype = type;\n\tvif->fw_vif_idx = fw_vif_idx;\n\tvif->nw_type = nw_type;\n\tvif->next_mode = nw_type;\n\tvif->listen_intvl_t = ATH6KL_DEFAULT_LISTEN_INTVAL;\n\tvif->bmiss_time_t = ATH6KL_DEFAULT_BMISS_TIME;\n\tvif->bg_scan_period = 0;\n\tvif->htcap[NL80211_BAND_2GHZ].ht_enable = true;\n\tvif->htcap[NL80211_BAND_5GHZ].ht_enable = true;\n\n\tether_addr_copy(addr, ar->mac_addr);\n\tif (fw_vif_idx != 0) {\n\t\taddr[0] = (addr[0] ^ (1 << fw_vif_idx)) | 0x2;\n\t\tif (test_bit(ATH6KL_FW_CAPABILITY_CUSTOM_MAC_ADDR,\n\t\t\t     ar->fw_capabilities))\n\t\t\taddr[4] ^= 0x80;\n\t}\n\teth_hw_addr_set(ndev, addr);\n\n\tinit_netdev(ndev);\n\n\tath6kl_init_control_info(vif);\n\n\tif (ath6kl_cfg80211_vif_init(vif))\n\t\tgoto err;\n\n\tnetdev_set_default_ethtool_ops(ndev, &ath6kl_ethtool_ops);\n\n\tif (cfg80211_register_netdevice(ndev))\n\t\tgoto err;\n\n\tar->avail_idx_map &= ~BIT(fw_vif_idx);\n\tvif->sme_state = SME_DISCONNECTED;\n\tset_bit(WLAN_ENABLED, &vif->flags);\n\tar->wlan_pwr_state = WLAN_POWER_STATE_ON;\n\n\tif (type == NL80211_IFTYPE_ADHOC)\n\t\tar->ibss_if_active = true;\n\n\tspin_lock_bh(&ar->list_lock);\n\tlist_add_tail(&vif->list, &ar->vif_list);\n\tspin_unlock_bh(&ar->list_lock);\n\n\treturn &vif->wdev;\n\nerr:\n\taggr_module_destroy(vif->aggr_cntxt);\n\tfree_netdev(ndev);\n\treturn NULL;\n}\n\n#ifdef CONFIG_PM\nstatic const struct wiphy_wowlan_support ath6kl_wowlan_support = {\n\t.flags = WIPHY_WOWLAN_MAGIC_PKT |\n\t\t WIPHY_WOWLAN_DISCONNECT |\n\t\t WIPHY_WOWLAN_GTK_REKEY_FAILURE  |\n\t\t WIPHY_WOWLAN_SUPPORTS_GTK_REKEY |\n\t\t WIPHY_WOWLAN_EAP_IDENTITY_REQ   |\n\t\t WIPHY_WOWLAN_4WAY_HANDSHAKE,\n\t.n_patterns = WOW_MAX_FILTERS_PER_LIST,\n\t.pattern_min_len = 1,\n\t.pattern_max_len = WOW_PATTERN_SIZE,\n};\n#endif\n\nint ath6kl_cfg80211_init(struct ath6kl *ar)\n{\n\tstruct wiphy *wiphy = ar->wiphy;\n\tbool band_2gig = false, band_5gig = false, ht = false;\n\tint ret;\n\n\twiphy->mgmt_stypes = ath6kl_mgmt_stypes;\n\n\twiphy->max_remain_on_channel_duration = 5000;\n\n\t \n\tset_wiphy_dev(wiphy, ar->dev);\n\n\twiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |\n\t\t\t\t BIT(NL80211_IFTYPE_ADHOC) |\n\t\t\t\t BIT(NL80211_IFTYPE_AP);\n\tif (ar->p2p) {\n\t\twiphy->interface_modes |= BIT(NL80211_IFTYPE_P2P_GO) |\n\t\t\t\t\t  BIT(NL80211_IFTYPE_P2P_CLIENT);\n\t}\n\n\tif (IS_ENABLED(CONFIG_ATH6KL_REGDOMAIN) &&\n\t    test_bit(ATH6KL_FW_CAPABILITY_REGDOMAIN, ar->fw_capabilities)) {\n\t\twiphy->reg_notifier = ath6kl_cfg80211_reg_notify;\n\t\tar->wiphy->features |= NL80211_FEATURE_CELL_BASE_REG_HINTS;\n\t}\n\n\t \n\twiphy->max_scan_ssids = MAX_PROBED_SSIDS;\n\n\t \n\tif (test_bit(ATH6KL_FW_CAPABILITY_SCHED_SCAN_MATCH_LIST,\n\t\t     ar->fw_capabilities))\n\t\twiphy->max_match_sets = MAX_PROBED_SSIDS;\n\n\twiphy->max_scan_ie_len = 1000;  \n\tswitch (ar->hw.cap) {\n\tcase WMI_11AN_CAP:\n\t\tht = true;\n\t\tfallthrough;\n\tcase WMI_11A_CAP:\n\t\tband_5gig = true;\n\t\tbreak;\n\tcase WMI_11GN_CAP:\n\t\tht = true;\n\t\tfallthrough;\n\tcase WMI_11G_CAP:\n\t\tband_2gig = true;\n\t\tbreak;\n\tcase WMI_11AGN_CAP:\n\t\tht = true;\n\t\tfallthrough;\n\tcase WMI_11AG_CAP:\n\t\tband_2gig = true;\n\t\tband_5gig = true;\n\t\tbreak;\n\tdefault:\n\t\tath6kl_err(\"invalid phy capability!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!(ht &&\n\t      test_bit(ATH6KL_FW_CAPABILITY_RSN_CAP_OVERRIDE,\n\t\t       ar->fw_capabilities))) {\n\t\tath6kl_band_2ghz.ht_cap.cap = 0;\n\t\tath6kl_band_2ghz.ht_cap.ht_supported = false;\n\t\tath6kl_band_5ghz.ht_cap.cap = 0;\n\t\tath6kl_band_5ghz.ht_cap.ht_supported = false;\n\n\t\tif (ht)\n\t\t\tath6kl_err(\"Firmware lacks RSN-CAP-OVERRIDE, so HT (802.11n) is disabled.\");\n\t}\n\n\tif (test_bit(ATH6KL_FW_CAPABILITY_64BIT_RATES,\n\t\t     ar->fw_capabilities)) {\n\t\tath6kl_band_2ghz.ht_cap.mcs.rx_mask[0] = 0xff;\n\t\tath6kl_band_5ghz.ht_cap.mcs.rx_mask[0] = 0xff;\n\t\tath6kl_band_2ghz.ht_cap.mcs.rx_mask[1] = 0xff;\n\t\tath6kl_band_5ghz.ht_cap.mcs.rx_mask[1] = 0xff;\n\t\tar->hw.tx_ant = 0x3;  \n\t\tar->hw.rx_ant = 0x3;\n\t} else {\n\t\tath6kl_band_2ghz.ht_cap.mcs.rx_mask[0] = 0xff;\n\t\tath6kl_band_5ghz.ht_cap.mcs.rx_mask[0] = 0xff;\n\t\tar->hw.tx_ant = 1;\n\t\tar->hw.rx_ant = 1;\n\t}\n\n\twiphy->available_antennas_tx = ar->hw.tx_ant;\n\twiphy->available_antennas_rx = ar->hw.rx_ant;\n\n\tif (band_2gig)\n\t\twiphy->bands[NL80211_BAND_2GHZ] = &ath6kl_band_2ghz;\n\tif (band_5gig)\n\t\twiphy->bands[NL80211_BAND_5GHZ] = &ath6kl_band_5ghz;\n\n\twiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;\n\n\twiphy->cipher_suites = cipher_suites;\n\twiphy->n_cipher_suites = ARRAY_SIZE(cipher_suites);\n\n#ifdef CONFIG_PM\n\twiphy->wowlan = &ath6kl_wowlan_support;\n#endif\n\n\twiphy->max_sched_scan_ssids = MAX_PROBED_SSIDS;\n\n\tar->wiphy->flags |= WIPHY_FLAG_SUPPORTS_FW_ROAM |\n\t\t\t    WIPHY_FLAG_HAVE_AP_SME |\n\t\t\t    WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL |\n\t\t\t    WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD;\n\n\tif (test_bit(ATH6KL_FW_CAPABILITY_SCHED_SCAN_V2, ar->fw_capabilities))\n\t\tar->wiphy->max_sched_scan_reqs = 1;\n\n\tif (test_bit(ATH6KL_FW_CAPABILITY_INACTIVITY_TIMEOUT,\n\t\t     ar->fw_capabilities))\n\t\tar->wiphy->features |= NL80211_FEATURE_INACTIVITY_TIMER;\n\n\tar->wiphy->probe_resp_offload =\n\t\tNL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS |\n\t\tNL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS2 |\n\t\tNL80211_PROBE_RESP_OFFLOAD_SUPPORT_P2P;\n\n\tret = wiphy_register(wiphy);\n\tif (ret < 0) {\n\t\tath6kl_err(\"couldn't register wiphy device\\n\");\n\t\treturn ret;\n\t}\n\n\tar->wiphy_registered = true;\n\n\treturn 0;\n}\n\nvoid ath6kl_cfg80211_cleanup(struct ath6kl *ar)\n{\n\twiphy_unregister(ar->wiphy);\n\n\tar->wiphy_registered = false;\n}\n\nstruct ath6kl *ath6kl_cfg80211_create(void)\n{\n\tstruct ath6kl *ar;\n\tstruct wiphy *wiphy;\n\n\t \n\twiphy = wiphy_new(&ath6kl_cfg80211_ops, sizeof(struct ath6kl));\n\n\tif (!wiphy) {\n\t\tath6kl_err(\"couldn't allocate wiphy device\\n\");\n\t\treturn NULL;\n\t}\n\n\tar = wiphy_priv(wiphy);\n\tar->wiphy = wiphy;\n\n\treturn ar;\n}\n\n \nvoid ath6kl_cfg80211_destroy(struct ath6kl *ar)\n{\n\tint i;\n\n\tfor (i = 0; i < AP_MAX_NUM_STA; i++)\n\t\tkfree(ar->sta_list[i].aggr_conn);\n\n\twiphy_free(ar->wiphy);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}