{
  "module_name": "debug.c",
  "hash_id": "f09f67094dac5fc18a7de8d3daeb5a685f06fab155a3f5c31a4975b1e12acc73",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath6kl/debug.c",
  "human_readable_source": " \n\n#include \"core.h\"\n\n#include <linux/skbuff.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n\n#include \"debug.h\"\n#include \"target.h\"\n\nstruct ath6kl_fwlog_slot {\n\t__le32 timestamp;\n\t__le32 length;\n\n\t \n\tu8 payload[];\n};\n\n#define ATH6KL_FWLOG_MAX_ENTRIES 20\n\n#define ATH6KL_FWLOG_VALID_MASK 0x1ffff\n\nvoid ath6kl_printk(const char *level, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sath6kl: %pV\", level, &vaf);\n\n\tva_end(args);\n}\nEXPORT_SYMBOL(ath6kl_printk);\n\nvoid ath6kl_info(const char *fmt, ...)\n{\n\tstruct va_format vaf = {\n\t\t.fmt = fmt,\n\t};\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.va = &args;\n\tath6kl_printk(KERN_INFO, \"%pV\", &vaf);\n\ttrace_ath6kl_log_info(&vaf);\n\tva_end(args);\n}\nEXPORT_SYMBOL(ath6kl_info);\n\nvoid ath6kl_err(const char *fmt, ...)\n{\n\tstruct va_format vaf = {\n\t\t.fmt = fmt,\n\t};\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.va = &args;\n\tath6kl_printk(KERN_ERR, \"%pV\", &vaf);\n\ttrace_ath6kl_log_err(&vaf);\n\tva_end(args);\n}\nEXPORT_SYMBOL(ath6kl_err);\n\nvoid ath6kl_warn(const char *fmt, ...)\n{\n\tstruct va_format vaf = {\n\t\t.fmt = fmt,\n\t};\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.va = &args;\n\tath6kl_printk(KERN_WARNING, \"%pV\", &vaf);\n\ttrace_ath6kl_log_warn(&vaf);\n\tva_end(args);\n}\nEXPORT_SYMBOL(ath6kl_warn);\n\nint ath6kl_read_tgt_stats(struct ath6kl *ar, struct ath6kl_vif *vif)\n{\n\tlong left;\n\n\tif (down_interruptible(&ar->sem))\n\t\treturn -EBUSY;\n\n\tset_bit(STATS_UPDATE_PEND, &vif->flags);\n\n\tif (ath6kl_wmi_get_stats_cmd(ar->wmi, 0)) {\n\t\tup(&ar->sem);\n\t\treturn -EIO;\n\t}\n\n\tleft = wait_event_interruptible_timeout(ar->event_wq,\n\t\t\t\t\t\t!test_bit(STATS_UPDATE_PEND,\n\t\t\t\t\t\t&vif->flags), WMI_TIMEOUT);\n\n\tup(&ar->sem);\n\n\tif (left <= 0)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ath6kl_read_tgt_stats);\n\n#ifdef CONFIG_ATH6KL_DEBUG\n\nvoid ath6kl_dbg(enum ATH6K_DEBUG_MASK mask, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tif (debug_mask & mask)\n\t\tath6kl_printk(KERN_DEBUG, \"%pV\", &vaf);\n\n\ttrace_ath6kl_log_dbg(mask, &vaf);\n\n\tva_end(args);\n}\nEXPORT_SYMBOL(ath6kl_dbg);\n\nvoid ath6kl_dbg_dump(enum ATH6K_DEBUG_MASK mask,\n\t\t     const char *msg, const char *prefix,\n\t\t     const void *buf, size_t len)\n{\n\tif (debug_mask & mask) {\n\t\tif (msg)\n\t\t\tath6kl_dbg(mask, \"%s\\n\", msg);\n\n\t\tprint_hex_dump_bytes(prefix, DUMP_PREFIX_OFFSET, buf, len);\n\t}\n\n\t \n\ttrace_ath6kl_log_dbg_dump(msg ? msg : \"\", prefix ? prefix : \"\",\n\t\t\t\t  buf, len);\n}\nEXPORT_SYMBOL(ath6kl_dbg_dump);\n\n#define REG_OUTPUT_LEN_PER_LINE\t25\n#define REGTYPE_STR_LEN\t\t100\n\nstruct ath6kl_diag_reg_info {\n\tu32 reg_start;\n\tu32 reg_end;\n\tconst char *reg_info;\n};\n\nstatic const struct ath6kl_diag_reg_info diag_reg[] = {\n\t{ 0x20000, 0x200fc, \"General DMA and Rx registers\" },\n\t{ 0x28000, 0x28900, \"MAC PCU register & keycache\" },\n\t{ 0x20800, 0x20a40, \"QCU\" },\n\t{ 0x21000, 0x212f0, \"DCU\" },\n\t{ 0x4000,  0x42e4, \"RTC\" },\n\t{ 0x540000, 0x540000 + (256 * 1024), \"RAM\" },\n\t{ 0x29800, 0x2B210, \"Base Band\" },\n\t{ 0x1C000, 0x1C748, \"Analog\" },\n};\n\nvoid ath6kl_dump_registers(struct ath6kl_device *dev,\n\t\t\t   struct ath6kl_irq_proc_registers *irq_proc_reg,\n\t\t\t   struct ath6kl_irq_enable_reg *irq_enable_reg)\n{\n\tath6kl_dbg(ATH6KL_DBG_IRQ, (\"<------- Register Table -------->\\n\"));\n\n\tif (irq_proc_reg != NULL) {\n\t\tath6kl_dbg(ATH6KL_DBG_IRQ,\n\t\t\t   \"Host Int status:           0x%x\\n\",\n\t\t\t   irq_proc_reg->host_int_status);\n\t\tath6kl_dbg(ATH6KL_DBG_IRQ,\n\t\t\t   \"CPU Int status:            0x%x\\n\",\n\t\t\t   irq_proc_reg->cpu_int_status);\n\t\tath6kl_dbg(ATH6KL_DBG_IRQ,\n\t\t\t   \"Error Int status:          0x%x\\n\",\n\t\t\t   irq_proc_reg->error_int_status);\n\t\tath6kl_dbg(ATH6KL_DBG_IRQ,\n\t\t\t   \"Counter Int status:        0x%x\\n\",\n\t\t\t   irq_proc_reg->counter_int_status);\n\t\tath6kl_dbg(ATH6KL_DBG_IRQ,\n\t\t\t   \"Mbox Frame:                0x%x\\n\",\n\t\t\t   irq_proc_reg->mbox_frame);\n\t\tath6kl_dbg(ATH6KL_DBG_IRQ,\n\t\t\t   \"Rx Lookahead Valid:        0x%x\\n\",\n\t\t\t   irq_proc_reg->rx_lkahd_valid);\n\t\tath6kl_dbg(ATH6KL_DBG_IRQ,\n\t\t\t   \"Rx Lookahead 0:            0x%x\\n\",\n\t\t\t   irq_proc_reg->rx_lkahd[0]);\n\t\tath6kl_dbg(ATH6KL_DBG_IRQ,\n\t\t\t   \"Rx Lookahead 1:            0x%x\\n\",\n\t\t\t   irq_proc_reg->rx_lkahd[1]);\n\n\t\tif (dev->ar->mbox_info.gmbox_addr != 0) {\n\t\t\t \n\t\t\tath6kl_dbg(ATH6KL_DBG_IRQ,\n\t\t\t\t   \"GMBOX Host Int status 2:   0x%x\\n\",\n\t\t\t\t   irq_proc_reg->host_int_status2);\n\t\t\tath6kl_dbg(ATH6KL_DBG_IRQ,\n\t\t\t\t   \"GMBOX RX Avail:            0x%x\\n\",\n\t\t\t\t   irq_proc_reg->gmbox_rx_avail);\n\t\t\tath6kl_dbg(ATH6KL_DBG_IRQ,\n\t\t\t\t   \"GMBOX lookahead alias 0:   0x%x\\n\",\n\t\t\t\t   irq_proc_reg->rx_gmbox_lkahd_alias[0]);\n\t\t\tath6kl_dbg(ATH6KL_DBG_IRQ,\n\t\t\t\t   \"GMBOX lookahead alias 1:   0x%x\\n\",\n\t\t\t\t   irq_proc_reg->rx_gmbox_lkahd_alias[1]);\n\t\t}\n\t}\n\n\tif (irq_enable_reg != NULL) {\n\t\tath6kl_dbg(ATH6KL_DBG_IRQ,\n\t\t\t   \"Int status Enable:         0x%x\\n\",\n\t\t\t   irq_enable_reg->int_status_en);\n\t\tath6kl_dbg(ATH6KL_DBG_IRQ, \"Counter Int status Enable: 0x%x\\n\",\n\t\t\t   irq_enable_reg->cntr_int_status_en);\n\t}\n\tath6kl_dbg(ATH6KL_DBG_IRQ, \"<------------------------------->\\n\");\n}\n\nstatic void dump_cred_dist(struct htc_endpoint_credit_dist *ep_dist)\n{\n\tath6kl_dbg(ATH6KL_DBG_CREDIT,\n\t\t   \"--- endpoint: %d  svc_id: 0x%X ---\\n\",\n\t\t   ep_dist->endpoint, ep_dist->svc_id);\n\tath6kl_dbg(ATH6KL_DBG_CREDIT, \" dist_flags     : 0x%X\\n\",\n\t\t   ep_dist->dist_flags);\n\tath6kl_dbg(ATH6KL_DBG_CREDIT, \" cred_norm      : %d\\n\",\n\t\t   ep_dist->cred_norm);\n\tath6kl_dbg(ATH6KL_DBG_CREDIT, \" cred_min       : %d\\n\",\n\t\t   ep_dist->cred_min);\n\tath6kl_dbg(ATH6KL_DBG_CREDIT, \" credits        : %d\\n\",\n\t\t   ep_dist->credits);\n\tath6kl_dbg(ATH6KL_DBG_CREDIT, \" cred_assngd    : %d\\n\",\n\t\t   ep_dist->cred_assngd);\n\tath6kl_dbg(ATH6KL_DBG_CREDIT, \" seek_cred      : %d\\n\",\n\t\t   ep_dist->seek_cred);\n\tath6kl_dbg(ATH6KL_DBG_CREDIT, \" cred_sz        : %d\\n\",\n\t\t   ep_dist->cred_sz);\n\tath6kl_dbg(ATH6KL_DBG_CREDIT, \" cred_per_msg   : %d\\n\",\n\t\t   ep_dist->cred_per_msg);\n\tath6kl_dbg(ATH6KL_DBG_CREDIT, \" cred_to_dist   : %d\\n\",\n\t\t   ep_dist->cred_to_dist);\n\tath6kl_dbg(ATH6KL_DBG_CREDIT, \" txq_depth      : %d\\n\",\n\t\t   get_queue_depth(&ep_dist->htc_ep->txq));\n\tath6kl_dbg(ATH6KL_DBG_CREDIT,\n\t\t   \"----------------------------------\\n\");\n}\n\n \nvoid dump_cred_dist_stats(struct htc_target *target)\n{\n\tstruct htc_endpoint_credit_dist *ep_list;\n\n\tlist_for_each_entry(ep_list, &target->cred_dist_list, list)\n\t\tdump_cred_dist(ep_list);\n\n\tath6kl_dbg(ATH6KL_DBG_CREDIT,\n\t\t   \"credit distribution total %d free %d\\n\",\n\t\t   target->credit_info->total_avail_credits,\n\t\t   target->credit_info->cur_free_credits);\n}\n\nvoid ath6kl_debug_war(struct ath6kl *ar, enum ath6kl_war war)\n{\n\tswitch (war) {\n\tcase ATH6KL_WAR_INVALID_RATE:\n\t\tar->debug.war_stats.invalid_rate++;\n\t\tbreak;\n\t}\n}\n\nstatic ssize_t read_file_war_stats(struct file *file, char __user *user_buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct ath6kl *ar = file->private_data;\n\tchar *buf;\n\tunsigned int len = 0, buf_len = 1500;\n\tssize_t ret_cnt;\n\n\tbuf = kzalloc(buf_len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tlen += scnprintf(buf + len, buf_len - len, \"\\n\");\n\tlen += scnprintf(buf + len, buf_len - len, \"%25s\\n\",\n\t\t\t \"Workaround stats\");\n\tlen += scnprintf(buf + len, buf_len - len, \"%25s\\n\\n\",\n\t\t\t \"=================\");\n\tlen += scnprintf(buf + len, buf_len - len, \"%20s %10u\\n\",\n\t\t\t \"Invalid rates\", ar->debug.war_stats.invalid_rate);\n\n\tif (WARN_ON(len > buf_len))\n\t\tlen = buf_len;\n\n\tret_cnt = simple_read_from_buffer(user_buf, count, ppos, buf, len);\n\n\tkfree(buf);\n\treturn ret_cnt;\n}\n\nstatic const struct file_operations fops_war_stats = {\n\t.read = read_file_war_stats,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nvoid ath6kl_debug_fwlog_event(struct ath6kl *ar, const void *buf, size_t len)\n{\n\tstruct ath6kl_fwlog_slot *slot;\n\tstruct sk_buff *skb;\n\tsize_t slot_len;\n\n\tif (WARN_ON(len > ATH6KL_FWLOG_PAYLOAD_SIZE))\n\t\treturn;\n\n\tslot_len = sizeof(*slot) + ATH6KL_FWLOG_PAYLOAD_SIZE;\n\n\tskb = alloc_skb(slot_len, GFP_KERNEL);\n\tif (!skb)\n\t\treturn;\n\n\tslot = skb_put(skb, slot_len);\n\tslot->timestamp = cpu_to_le32(jiffies);\n\tslot->length = cpu_to_le32(len);\n\tmemcpy(slot->payload, buf, len);\n\n\t \n\tmemset(slot->payload + len, 0, ATH6KL_FWLOG_PAYLOAD_SIZE - len);\n\n\tspin_lock(&ar->debug.fwlog_queue.lock);\n\n\t__skb_queue_tail(&ar->debug.fwlog_queue, skb);\n\tcomplete(&ar->debug.fwlog_completion);\n\n\t \n\twhile (skb_queue_len(&ar->debug.fwlog_queue) >\n\t       ATH6KL_FWLOG_MAX_ENTRIES) {\n\t\tskb = __skb_dequeue(&ar->debug.fwlog_queue);\n\t\tkfree_skb(skb);\n\t}\n\n\tspin_unlock(&ar->debug.fwlog_queue.lock);\n\n\treturn;\n}\n\nstatic int ath6kl_fwlog_open(struct inode *inode, struct file *file)\n{\n\tstruct ath6kl *ar = inode->i_private;\n\n\tif (ar->debug.fwlog_open)\n\t\treturn -EBUSY;\n\n\tar->debug.fwlog_open = true;\n\n\tfile->private_data = inode->i_private;\n\treturn 0;\n}\n\nstatic int ath6kl_fwlog_release(struct inode *inode, struct file *file)\n{\n\tstruct ath6kl *ar = inode->i_private;\n\n\tar->debug.fwlog_open = false;\n\n\treturn 0;\n}\n\nstatic ssize_t ath6kl_fwlog_read(struct file *file, char __user *user_buf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct ath6kl *ar = file->private_data;\n\tstruct sk_buff *skb;\n\tssize_t ret_cnt;\n\tsize_t len = 0;\n\tchar *buf;\n\n\tbuf = vmalloc(count);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t \n\tath6kl_read_fwlogs(ar);\n\n\tspin_lock(&ar->debug.fwlog_queue.lock);\n\n\twhile ((skb = __skb_dequeue(&ar->debug.fwlog_queue))) {\n\t\tif (skb->len > count - len) {\n\t\t\t \n\t\t\t__skb_queue_head(&ar->debug.fwlog_queue, skb);\n\t\t\tbreak;\n\t\t}\n\n\n\t\tmemcpy(buf + len, skb->data, skb->len);\n\t\tlen += skb->len;\n\n\t\tkfree_skb(skb);\n\t}\n\n\tspin_unlock(&ar->debug.fwlog_queue.lock);\n\n\t \n\n\tret_cnt = simple_read_from_buffer(user_buf, count, ppos, buf, len);\n\n\tvfree(buf);\n\n\treturn ret_cnt;\n}\n\nstatic const struct file_operations fops_fwlog = {\n\t.open = ath6kl_fwlog_open,\n\t.release = ath6kl_fwlog_release,\n\t.read = ath6kl_fwlog_read,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t ath6kl_fwlog_block_read(struct file *file,\n\t\t\t\t       char __user *user_buf,\n\t\t\t\t       size_t count,\n\t\t\t\t       loff_t *ppos)\n{\n\tstruct ath6kl *ar = file->private_data;\n\tstruct sk_buff *skb;\n\tssize_t ret_cnt;\n\tsize_t len = 0, not_copied;\n\tchar *buf;\n\tint ret;\n\n\tbuf = vmalloc(count);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tspin_lock(&ar->debug.fwlog_queue.lock);\n\n\tif (skb_queue_len(&ar->debug.fwlog_queue) == 0) {\n\t\t \n\t\tinit_completion(&ar->debug.fwlog_completion);\n\n\t\tspin_unlock(&ar->debug.fwlog_queue.lock);\n\n\t\tret = wait_for_completion_interruptible(\n\t\t\t&ar->debug.fwlog_completion);\n\t\tif (ret == -ERESTARTSYS) {\n\t\t\tvfree(buf);\n\t\t\treturn ret;\n\t\t}\n\n\t\tspin_lock(&ar->debug.fwlog_queue.lock);\n\t}\n\n\twhile ((skb = __skb_dequeue(&ar->debug.fwlog_queue))) {\n\t\tif (skb->len > count - len) {\n\t\t\t \n\t\t\t__skb_queue_head(&ar->debug.fwlog_queue, skb);\n\t\t\tbreak;\n\t\t}\n\n\n\t\tmemcpy(buf + len, skb->data, skb->len);\n\t\tlen += skb->len;\n\n\t\tkfree_skb(skb);\n\t}\n\n\tspin_unlock(&ar->debug.fwlog_queue.lock);\n\n\t \n\n\tnot_copied = copy_to_user(user_buf, buf, len);\n\tif (not_copied != 0) {\n\t\tret_cnt = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t*ppos = *ppos + len;\n\n\tret_cnt = len;\n\nout:\n\tvfree(buf);\n\n\treturn ret_cnt;\n}\n\nstatic const struct file_operations fops_fwlog_block = {\n\t.open = ath6kl_fwlog_open,\n\t.release = ath6kl_fwlog_release,\n\t.read = ath6kl_fwlog_block_read,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t ath6kl_fwlog_mask_read(struct file *file, char __user *user_buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct ath6kl *ar = file->private_data;\n\tchar buf[16];\n\tint len;\n\n\tlen = snprintf(buf, sizeof(buf), \"0x%x\\n\", ar->debug.fwlog_mask);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic ssize_t ath6kl_fwlog_mask_write(struct file *file,\n\t\t\t\t       const char __user *user_buf,\n\t\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct ath6kl *ar = file->private_data;\n\tint ret;\n\n\tret = kstrtou32_from_user(user_buf, count, 0, &ar->debug.fwlog_mask);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ath6kl_wmi_config_debug_module_cmd(ar->wmi,\n\t\t\t\t\t\t ATH6KL_FWLOG_VALID_MASK,\n\t\t\t\t\t\t ar->debug.fwlog_mask);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic const struct file_operations fops_fwlog_mask = {\n\t.open = simple_open,\n\t.read = ath6kl_fwlog_mask_read,\n\t.write = ath6kl_fwlog_mask_write,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t read_file_tgt_stats(struct file *file, char __user *user_buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct ath6kl *ar = file->private_data;\n\tstruct ath6kl_vif *vif;\n\tstruct target_stats *tgt_stats;\n\tchar *buf;\n\tunsigned int len = 0, buf_len = 1500;\n\tint i;\n\tssize_t ret_cnt;\n\tint rv;\n\n\tvif = ath6kl_vif_first(ar);\n\tif (!vif)\n\t\treturn -EIO;\n\n\tbuf = kzalloc(buf_len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\trv = ath6kl_read_tgt_stats(ar, vif);\n\tif (rv < 0) {\n\t\tkfree(buf);\n\t\treturn rv;\n\t}\n\n\ttgt_stats = &vif->target_stats;\n\n\tlen += scnprintf(buf + len, buf_len - len, \"\\n\");\n\tlen += scnprintf(buf + len, buf_len - len, \"%25s\\n\",\n\t\t\t \"Target Tx stats\");\n\tlen += scnprintf(buf + len, buf_len - len, \"%25s\\n\\n\",\n\t\t\t \"=================\");\n\tlen += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",\n\t\t\t \"Ucast packets\", tgt_stats->tx_ucast_pkt);\n\tlen += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",\n\t\t\t \"Bcast packets\", tgt_stats->tx_bcast_pkt);\n\tlen += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",\n\t\t\t \"Ucast byte\", tgt_stats->tx_ucast_byte);\n\tlen += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",\n\t\t\t \"Bcast byte\", tgt_stats->tx_bcast_byte);\n\tlen += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",\n\t\t\t \"Rts success cnt\", tgt_stats->tx_rts_success_cnt);\n\tfor (i = 0; i < 4; i++)\n\t\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t\t \"%18s %d %10llu\\n\", \"PER on ac\",\n\t\t\t\t i, tgt_stats->tx_pkt_per_ac[i]);\n\tlen += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",\n\t\t\t \"Error\", tgt_stats->tx_err);\n\tlen += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",\n\t\t\t \"Fail count\", tgt_stats->tx_fail_cnt);\n\tlen += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",\n\t\t\t \"Retry count\", tgt_stats->tx_retry_cnt);\n\tlen += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",\n\t\t\t \"Multi retry cnt\", tgt_stats->tx_mult_retry_cnt);\n\tlen += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",\n\t\t\t \"Rts fail cnt\", tgt_stats->tx_rts_fail_cnt);\n\tlen += scnprintf(buf + len, buf_len - len, \"%25s %10llu\\n\\n\",\n\t\t\t \"TKIP counter measure used\",\n\t\t\t tgt_stats->tkip_cnter_measures_invoked);\n\n\tlen += scnprintf(buf + len, buf_len - len, \"%25s\\n\",\n\t\t\t \"Target Rx stats\");\n\tlen += scnprintf(buf + len, buf_len - len, \"%25s\\n\",\n\t\t\t \"=================\");\n\n\tlen += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",\n\t\t\t \"Ucast packets\", tgt_stats->rx_ucast_pkt);\n\tlen += scnprintf(buf + len, buf_len - len, \"%20s %10d\\n\",\n\t\t\t \"Ucast Rate\", tgt_stats->rx_ucast_rate);\n\tlen += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",\n\t\t\t \"Bcast packets\", tgt_stats->rx_bcast_pkt);\n\tlen += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",\n\t\t\t \"Ucast byte\", tgt_stats->rx_ucast_byte);\n\tlen += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",\n\t\t\t \"Bcast byte\", tgt_stats->rx_bcast_byte);\n\tlen += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",\n\t\t\t \"Fragmented pkt\", tgt_stats->rx_frgment_pkt);\n\tlen += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",\n\t\t\t \"Error\", tgt_stats->rx_err);\n\tlen += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",\n\t\t\t \"CRC Err\", tgt_stats->rx_crc_err);\n\tlen += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",\n\t\t\t \"Key cache miss\", tgt_stats->rx_key_cache_miss);\n\tlen += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",\n\t\t\t \"Decrypt Err\", tgt_stats->rx_decrypt_err);\n\tlen += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",\n\t\t\t \"Duplicate frame\", tgt_stats->rx_dupl_frame);\n\tlen += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",\n\t\t\t \"Tkip Mic failure\", tgt_stats->tkip_local_mic_fail);\n\tlen += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",\n\t\t\t \"TKIP format err\", tgt_stats->tkip_fmt_err);\n\tlen += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",\n\t\t\t \"CCMP format Err\", tgt_stats->ccmp_fmt_err);\n\tlen += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\\n\",\n\t\t\t \"CCMP Replay Err\", tgt_stats->ccmp_replays);\n\n\tlen += scnprintf(buf + len, buf_len - len, \"%25s\\n\",\n\t\t\t \"Misc Target stats\");\n\tlen += scnprintf(buf + len, buf_len - len, \"%25s\\n\",\n\t\t\t \"=================\");\n\tlen += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",\n\t\t\t \"Beacon Miss count\", tgt_stats->cs_bmiss_cnt);\n\tlen += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",\n\t\t\t \"Num Connects\", tgt_stats->cs_connect_cnt);\n\tlen += scnprintf(buf + len, buf_len - len, \"%20s %10llu\\n\",\n\t\t\t \"Num disconnects\", tgt_stats->cs_discon_cnt);\n\tlen += scnprintf(buf + len, buf_len - len, \"%20s %10d\\n\",\n\t\t\t \"Beacon avg rssi\", tgt_stats->cs_ave_beacon_rssi);\n\tlen += scnprintf(buf + len, buf_len - len, \"%20s %10d\\n\",\n\t\t\t \"ARP pkt received\", tgt_stats->arp_received);\n\tlen += scnprintf(buf + len, buf_len - len, \"%20s %10d\\n\",\n\t\t\t \"ARP pkt matched\", tgt_stats->arp_matched);\n\tlen += scnprintf(buf + len, buf_len - len, \"%20s %10d\\n\",\n\t\t\t \"ARP pkt replied\", tgt_stats->arp_replied);\n\n\tif (len > buf_len)\n\t\tlen = buf_len;\n\n\tret_cnt = simple_read_from_buffer(user_buf, count, ppos, buf, len);\n\n\tkfree(buf);\n\treturn ret_cnt;\n}\n\nstatic const struct file_operations fops_tgt_stats = {\n\t.read = read_file_tgt_stats,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\n#define print_credit_info(fmt_str, ep_list_field)\t\t\\\n\t(len += scnprintf(buf + len, buf_len - len, fmt_str,\t\\\n\t\t\t ep_list->ep_list_field))\n#define CREDIT_INFO_DISPLAY_STRING_LEN\t200\n#define CREDIT_INFO_LEN\t128\n\nstatic ssize_t read_file_credit_dist_stats(struct file *file,\n\t\t\t\t\t   char __user *user_buf,\n\t\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct ath6kl *ar = file->private_data;\n\tstruct htc_target *target = ar->htc_target;\n\tstruct htc_endpoint_credit_dist *ep_list;\n\tchar *buf;\n\tunsigned int buf_len, len = 0;\n\tssize_t ret_cnt;\n\n\tbuf_len = CREDIT_INFO_DISPLAY_STRING_LEN +\n\t\t  get_queue_depth(&target->cred_dist_list) * CREDIT_INFO_LEN;\n\tbuf = kzalloc(buf_len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tlen += scnprintf(buf + len, buf_len - len, \"%25s%5d\\n\",\n\t\t\t \"Total Avail Credits: \",\n\t\t\t target->credit_info->total_avail_credits);\n\tlen += scnprintf(buf + len, buf_len - len, \"%25s%5d\\n\",\n\t\t\t \"Free credits :\",\n\t\t\t target->credit_info->cur_free_credits);\n\n\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t \" Epid  Flags    Cred_norm  Cred_min  Credits  Cred_assngd\"\n\t\t\t \"  Seek_cred  Cred_sz  Cred_per_msg  Cred_to_dist\"\n\t\t\t \"  qdepth\\n\");\n\n\tlist_for_each_entry(ep_list, &target->cred_dist_list, list) {\n\t\tprint_credit_info(\"  %2d\", endpoint);\n\t\tprint_credit_info(\"%10x\", dist_flags);\n\t\tprint_credit_info(\"%8d\", cred_norm);\n\t\tprint_credit_info(\"%9d\", cred_min);\n\t\tprint_credit_info(\"%9d\", credits);\n\t\tprint_credit_info(\"%10d\", cred_assngd);\n\t\tprint_credit_info(\"%13d\", seek_cred);\n\t\tprint_credit_info(\"%12d\", cred_sz);\n\t\tprint_credit_info(\"%9d\", cred_per_msg);\n\t\tprint_credit_info(\"%14d\", cred_to_dist);\n\t\tlen += scnprintf(buf + len, buf_len - len, \"%12d\\n\",\n\t\t\t\t get_queue_depth(&ep_list->htc_ep->txq));\n\t}\n\n\tif (len > buf_len)\n\t\tlen = buf_len;\n\n\tret_cnt = simple_read_from_buffer(user_buf, count, ppos, buf, len);\n\tkfree(buf);\n\treturn ret_cnt;\n}\n\nstatic const struct file_operations fops_credit_dist_stats = {\n\t.read = read_file_credit_dist_stats,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic unsigned int print_endpoint_stat(struct htc_target *target, char *buf,\n\t\t\t\t\tunsigned int buf_len, unsigned int len,\n\t\t\t\t\tint offset, const char *name)\n{\n\tint i;\n\tstruct htc_endpoint_stats *ep_st;\n\tu32 *counter;\n\n\tlen += scnprintf(buf + len, buf_len - len, \"%s:\", name);\n\tfor (i = 0; i < ENDPOINT_MAX; i++) {\n\t\tep_st = &target->endpoint[i].ep_st;\n\t\tcounter = ((u32 *) ep_st) + (offset / 4);\n\t\tlen += scnprintf(buf + len, buf_len - len, \" %u\", *counter);\n\t}\n\tlen += scnprintf(buf + len, buf_len - len, \"\\n\");\n\n\treturn len;\n}\n\nstatic ssize_t ath6kl_endpoint_stats_read(struct file *file,\n\t\t\t\t\t  char __user *user_buf,\n\t\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct ath6kl *ar = file->private_data;\n\tstruct htc_target *target = ar->htc_target;\n\tchar *buf;\n\tunsigned int buf_len, len = 0;\n\tssize_t ret_cnt;\n\n\tbuf_len = sizeof(struct htc_endpoint_stats) / sizeof(u32) *\n\t\t(25 + ENDPOINT_MAX * 11);\n\tbuf = kmalloc(buf_len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n#define EPSTAT(name)\t\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tlen = print_endpoint_stat(target, buf, buf_len, len,\t\\\n\t\t\t\t\t  offsetof(struct htc_endpoint_stats, \\\n\t\t\t\t\t\t   name),\t\t\\\n\t\t\t\t\t  #name);\t\t\t\\\n\t} while (0)\n\n\tEPSTAT(cred_low_indicate);\n\tEPSTAT(tx_issued);\n\tEPSTAT(tx_pkt_bundled);\n\tEPSTAT(tx_bundles);\n\tEPSTAT(tx_dropped);\n\tEPSTAT(tx_cred_rpt);\n\tEPSTAT(cred_rpt_from_rx);\n\tEPSTAT(cred_rpt_from_other);\n\tEPSTAT(cred_rpt_ep0);\n\tEPSTAT(cred_from_rx);\n\tEPSTAT(cred_from_other);\n\tEPSTAT(cred_from_ep0);\n\tEPSTAT(cred_cosumd);\n\tEPSTAT(cred_retnd);\n\tEPSTAT(rx_pkts);\n\tEPSTAT(rx_lkahds);\n\tEPSTAT(rx_bundl);\n\tEPSTAT(rx_bundle_lkahd);\n\tEPSTAT(rx_bundle_from_hdr);\n\tEPSTAT(rx_alloc_thresh_hit);\n\tEPSTAT(rxalloc_thresh_byte);\n#undef EPSTAT\n\n\tif (len > buf_len)\n\t\tlen = buf_len;\n\n\tret_cnt = simple_read_from_buffer(user_buf, count, ppos, buf, len);\n\tkfree(buf);\n\treturn ret_cnt;\n}\n\nstatic ssize_t ath6kl_endpoint_stats_write(struct file *file,\n\t\t\t\t\t   const char __user *user_buf,\n\t\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct ath6kl *ar = file->private_data;\n\tstruct htc_target *target = ar->htc_target;\n\tint ret, i;\n\tu32 val;\n\tstruct htc_endpoint_stats *ep_st;\n\n\tret = kstrtou32_from_user(user_buf, count, 0, &val);\n\tif (ret)\n\t\treturn ret;\n\tif (val == 0) {\n\t\tfor (i = 0; i < ENDPOINT_MAX; i++) {\n\t\t\tep_st = &target->endpoint[i].ep_st;\n\t\t\tmemset(ep_st, 0, sizeof(*ep_st));\n\t\t}\n\t}\n\n\treturn count;\n}\n\nstatic const struct file_operations fops_endpoint_stats = {\n\t.open = simple_open,\n\t.read = ath6kl_endpoint_stats_read,\n\t.write = ath6kl_endpoint_stats_write,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic unsigned long ath6kl_get_num_reg(void)\n{\n\tint i;\n\tunsigned long n_reg = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(diag_reg); i++)\n\t\tn_reg = n_reg +\n\t\t     (diag_reg[i].reg_end - diag_reg[i].reg_start) / 4 + 1;\n\n\treturn n_reg;\n}\n\nstatic bool ath6kl_dbg_is_diag_reg_valid(u32 reg_addr)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(diag_reg); i++) {\n\t\tif (reg_addr >= diag_reg[i].reg_start &&\n\t\t    reg_addr <= diag_reg[i].reg_end)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic ssize_t ath6kl_regread_read(struct file *file, char __user *user_buf,\n\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct ath6kl *ar = file->private_data;\n\tu8 buf[50];\n\tunsigned int len = 0;\n\n\tif (ar->debug.dbgfs_diag_reg)\n\t\tlen += scnprintf(buf + len, sizeof(buf) - len, \"0x%x\\n\",\n\t\t\t\tar->debug.dbgfs_diag_reg);\n\telse\n\t\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\t\t \"All diag registers\\n\");\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic ssize_t ath6kl_regread_write(struct file *file,\n\t\t\t\t    const char __user *user_buf,\n\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct ath6kl *ar = file->private_data;\n\tunsigned long reg_addr;\n\n\tif (kstrtoul_from_user(user_buf, count, 0, &reg_addr))\n\t\treturn -EINVAL;\n\n\tif ((reg_addr % 4) != 0)\n\t\treturn -EINVAL;\n\n\tif (reg_addr && !ath6kl_dbg_is_diag_reg_valid(reg_addr))\n\t\treturn -EINVAL;\n\n\tar->debug.dbgfs_diag_reg = reg_addr;\n\n\treturn count;\n}\n\nstatic const struct file_operations fops_diag_reg_read = {\n\t.read = ath6kl_regread_read,\n\t.write = ath6kl_regread_write,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic int ath6kl_regdump_open(struct inode *inode, struct file *file)\n{\n\tstruct ath6kl *ar = inode->i_private;\n\tu8 *buf;\n\tunsigned long int reg_len;\n\tunsigned int len = 0, n_reg;\n\tu32 addr;\n\t__le32 reg_val;\n\tint i, status;\n\n\t \n\tif (!ar->debug.dbgfs_diag_reg)\n\t\tn_reg = ath6kl_get_num_reg();\n\telse\n\t\tn_reg = 1;\n\n\treg_len = n_reg * REG_OUTPUT_LEN_PER_LINE;\n\tif (n_reg > 1)\n\t\treg_len += REGTYPE_STR_LEN;\n\n\tbuf = vmalloc(reg_len);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tif (n_reg == 1) {\n\t\taddr = ar->debug.dbgfs_diag_reg;\n\n\t\tstatus = ath6kl_diag_read32(ar,\n\t\t\t\tTARG_VTOP(ar->target_type, addr),\n\t\t\t\t(u32 *)&reg_val);\n\t\tif (status)\n\t\t\tgoto fail_reg_read;\n\n\t\tlen += scnprintf(buf + len, reg_len - len,\n\t\t\t\t \"0x%06x 0x%08x\\n\", addr, le32_to_cpu(reg_val));\n\t\tgoto done;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(diag_reg); i++) {\n\t\tlen += scnprintf(buf + len, reg_len - len,\n\t\t\t\t\"%s\\n\", diag_reg[i].reg_info);\n\t\tfor (addr = diag_reg[i].reg_start;\n\t\t     addr <= diag_reg[i].reg_end; addr += 4) {\n\t\t\tstatus = ath6kl_diag_read32(ar,\n\t\t\t\t\tTARG_VTOP(ar->target_type, addr),\n\t\t\t\t\t(u32 *)&reg_val);\n\t\t\tif (status)\n\t\t\t\tgoto fail_reg_read;\n\n\t\t\tlen += scnprintf(buf + len, reg_len - len,\n\t\t\t\t\t\"0x%06x 0x%08x\\n\",\n\t\t\t\t\taddr, le32_to_cpu(reg_val));\n\t\t}\n\t}\n\ndone:\n\tfile->private_data = buf;\n\treturn 0;\n\nfail_reg_read:\n\tath6kl_warn(\"Unable to read memory:%u\\n\", addr);\n\tvfree(buf);\n\treturn -EIO;\n}\n\nstatic ssize_t ath6kl_regdump_read(struct file *file, char __user *user_buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tu8 *buf = file->private_data;\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, strlen(buf));\n}\n\nstatic int ath6kl_regdump_release(struct inode *inode, struct file *file)\n{\n\tvfree(file->private_data);\n\treturn 0;\n}\n\nstatic const struct file_operations fops_reg_dump = {\n\t.open = ath6kl_regdump_open,\n\t.read = ath6kl_regdump_read,\n\t.release = ath6kl_regdump_release,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t ath6kl_lrssi_roam_write(struct file *file,\n\t\t\t\t       const char __user *user_buf,\n\t\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct ath6kl *ar = file->private_data;\n\tunsigned long lrssi_roam_threshold;\n\tint ret;\n\n\tif (kstrtoul_from_user(user_buf, count, 0, &lrssi_roam_threshold))\n\t\treturn -EINVAL;\n\n\tar->lrssi_roam_threshold = lrssi_roam_threshold;\n\n\tret = ath6kl_wmi_set_roam_lrssi_cmd(ar->wmi, ar->lrssi_roam_threshold);\n\n\tif (ret)\n\t\treturn ret;\n\treturn count;\n}\n\nstatic ssize_t ath6kl_lrssi_roam_read(struct file *file,\n\t\t\t\t      char __user *user_buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct ath6kl *ar = file->private_data;\n\tchar buf[32];\n\tunsigned int len;\n\n\tlen = snprintf(buf, sizeof(buf), \"%u\\n\", ar->lrssi_roam_threshold);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic const struct file_operations fops_lrssi_roam_threshold = {\n\t.read = ath6kl_lrssi_roam_read,\n\t.write = ath6kl_lrssi_roam_write,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t ath6kl_regwrite_read(struct file *file,\n\t\t\t\t    char __user *user_buf,\n\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct ath6kl *ar = file->private_data;\n\tu8 buf[32];\n\tunsigned int len = 0;\n\n\tlen = scnprintf(buf, sizeof(buf), \"Addr: 0x%x Val: 0x%x\\n\",\n\t\t\tar->debug.diag_reg_addr_wr, ar->debug.diag_reg_val_wr);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic ssize_t ath6kl_regwrite_write(struct file *file,\n\t\t\t\t     const char __user *user_buf,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct ath6kl *ar = file->private_data;\n\tchar buf[32];\n\tchar *sptr, *token;\n\tunsigned int len = 0;\n\tu32 reg_addr, reg_val;\n\n\tlen = min(count, sizeof(buf) - 1);\n\tif (copy_from_user(buf, user_buf, len))\n\t\treturn -EFAULT;\n\n\tbuf[len] = '\\0';\n\tsptr = buf;\n\n\ttoken = strsep(&sptr, \"=\");\n\tif (!token)\n\t\treturn -EINVAL;\n\n\tif (kstrtou32(token, 0, &reg_addr))\n\t\treturn -EINVAL;\n\n\tif (!ath6kl_dbg_is_diag_reg_valid(reg_addr))\n\t\treturn -EINVAL;\n\n\tif (kstrtou32(sptr, 0, &reg_val))\n\t\treturn -EINVAL;\n\n\tar->debug.diag_reg_addr_wr = reg_addr;\n\tar->debug.diag_reg_val_wr = reg_val;\n\n\tif (ath6kl_diag_write32(ar, ar->debug.diag_reg_addr_wr,\n\t\t\t\tcpu_to_le32(ar->debug.diag_reg_val_wr)))\n\t\treturn -EIO;\n\n\treturn count;\n}\n\nstatic const struct file_operations fops_diag_reg_write = {\n\t.read = ath6kl_regwrite_read,\n\t.write = ath6kl_regwrite_write,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nint ath6kl_debug_roam_tbl_event(struct ath6kl *ar, const void *buf,\n\t\t\t\tsize_t len)\n{\n\tconst struct wmi_target_roam_tbl *tbl;\n\tu16 num_entries;\n\n\tif (len < sizeof(*tbl))\n\t\treturn -EINVAL;\n\n\ttbl = (const struct wmi_target_roam_tbl *) buf;\n\tnum_entries = le16_to_cpu(tbl->num_entries);\n\tif (struct_size(tbl, info, num_entries) > len)\n\t\treturn -EINVAL;\n\n\tif (ar->debug.roam_tbl == NULL ||\n\t    ar->debug.roam_tbl_len < (unsigned int) len) {\n\t\tkfree(ar->debug.roam_tbl);\n\t\tar->debug.roam_tbl = kmalloc(len, GFP_ATOMIC);\n\t\tif (ar->debug.roam_tbl == NULL)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tmemcpy(ar->debug.roam_tbl, buf, len);\n\tar->debug.roam_tbl_len = len;\n\n\tif (test_bit(ROAM_TBL_PEND, &ar->flag)) {\n\t\tclear_bit(ROAM_TBL_PEND, &ar->flag);\n\t\twake_up(&ar->event_wq);\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t ath6kl_roam_table_read(struct file *file, char __user *user_buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct ath6kl *ar = file->private_data;\n\tint ret;\n\tlong left;\n\tstruct wmi_target_roam_tbl *tbl;\n\tu16 num_entries, i;\n\tchar *buf;\n\tunsigned int len, buf_len;\n\tssize_t ret_cnt;\n\n\tif (down_interruptible(&ar->sem))\n\t\treturn -EBUSY;\n\n\tset_bit(ROAM_TBL_PEND, &ar->flag);\n\n\tret = ath6kl_wmi_get_roam_tbl_cmd(ar->wmi);\n\tif (ret) {\n\t\tup(&ar->sem);\n\t\treturn ret;\n\t}\n\n\tleft = wait_event_interruptible_timeout(\n\t\tar->event_wq, !test_bit(ROAM_TBL_PEND, &ar->flag), WMI_TIMEOUT);\n\tup(&ar->sem);\n\n\tif (left <= 0)\n\t\treturn -ETIMEDOUT;\n\n\tif (ar->debug.roam_tbl == NULL)\n\t\treturn -ENOMEM;\n\n\ttbl = (struct wmi_target_roam_tbl *) ar->debug.roam_tbl;\n\tnum_entries = le16_to_cpu(tbl->num_entries);\n\n\tbuf_len = 100 + num_entries * 100;\n\tbuf = kzalloc(buf_len, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\tlen = 0;\n\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t \"roam_mode=%u\\n\\n\"\n\t\t\t \"# roam_util bssid rssi rssidt last_rssi util bias\\n\",\n\t\t\t le16_to_cpu(tbl->roam_mode));\n\n\tfor (i = 0; i < num_entries; i++) {\n\t\tstruct wmi_bss_roam_info *info = &tbl->info[i];\n\t\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t\t \"%d %pM %d %d %d %d %d\\n\",\n\t\t\t\t a_sle32_to_cpu(info->roam_util), info->bssid,\n\t\t\t\t info->rssi, info->rssidt, info->last_rssi,\n\t\t\t\t info->util, info->bias);\n\t}\n\n\tif (len > buf_len)\n\t\tlen = buf_len;\n\n\tret_cnt = simple_read_from_buffer(user_buf, count, ppos, buf, len);\n\n\tkfree(buf);\n\treturn ret_cnt;\n}\n\nstatic const struct file_operations fops_roam_table = {\n\t.read = ath6kl_roam_table_read,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t ath6kl_force_roam_write(struct file *file,\n\t\t\t\t       const char __user *user_buf,\n\t\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct ath6kl *ar = file->private_data;\n\tint ret;\n\tchar buf[20];\n\tsize_t len;\n\tu8 bssid[ETH_ALEN];\n\n\tlen = min(count, sizeof(buf) - 1);\n\tif (copy_from_user(buf, user_buf, len))\n\t\treturn -EFAULT;\n\tbuf[len] = '\\0';\n\n\tif (!mac_pton(buf, bssid))\n\t\treturn -EINVAL;\n\n\tret = ath6kl_wmi_force_roam_cmd(ar->wmi, bssid);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic const struct file_operations fops_force_roam = {\n\t.write = ath6kl_force_roam_write,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t ath6kl_roam_mode_write(struct file *file,\n\t\t\t\t      const char __user *user_buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct ath6kl *ar = file->private_data;\n\tint ret;\n\tchar buf[20];\n\tsize_t len;\n\tenum wmi_roam_mode mode;\n\n\tlen = min(count, sizeof(buf) - 1);\n\tif (copy_from_user(buf, user_buf, len))\n\t\treturn -EFAULT;\n\tbuf[len] = '\\0';\n\tif (len > 0 && buf[len - 1] == '\\n')\n\t\tbuf[len - 1] = '\\0';\n\n\tif (strcasecmp(buf, \"default\") == 0)\n\t\tmode = WMI_DEFAULT_ROAM_MODE;\n\telse if (strcasecmp(buf, \"bssbias\") == 0)\n\t\tmode = WMI_HOST_BIAS_ROAM_MODE;\n\telse if (strcasecmp(buf, \"lock\") == 0)\n\t\tmode = WMI_LOCK_BSS_MODE;\n\telse\n\t\treturn -EINVAL;\n\n\tret = ath6kl_wmi_set_roam_mode_cmd(ar->wmi, mode);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic const struct file_operations fops_roam_mode = {\n\t.write = ath6kl_roam_mode_write,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nvoid ath6kl_debug_set_keepalive(struct ath6kl *ar, u8 keepalive)\n{\n\tar->debug.keepalive = keepalive;\n}\n\nstatic ssize_t ath6kl_keepalive_read(struct file *file, char __user *user_buf,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct ath6kl *ar = file->private_data;\n\tchar buf[16];\n\tint len;\n\n\tlen = snprintf(buf, sizeof(buf), \"%u\\n\", ar->debug.keepalive);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic ssize_t ath6kl_keepalive_write(struct file *file,\n\t\t\t\t      const char __user *user_buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct ath6kl *ar = file->private_data;\n\tint ret;\n\tu8 val;\n\n\tret = kstrtou8_from_user(user_buf, count, 0, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ath6kl_wmi_set_keepalive_cmd(ar->wmi, 0, val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic const struct file_operations fops_keepalive = {\n\t.open = simple_open,\n\t.read = ath6kl_keepalive_read,\n\t.write = ath6kl_keepalive_write,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nvoid ath6kl_debug_set_disconnect_timeout(struct ath6kl *ar, u8 timeout)\n{\n\tar->debug.disc_timeout = timeout;\n}\n\nstatic ssize_t ath6kl_disconnect_timeout_read(struct file *file,\n\t\t\t\t\t      char __user *user_buf,\n\t\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct ath6kl *ar = file->private_data;\n\tchar buf[16];\n\tint len;\n\n\tlen = snprintf(buf, sizeof(buf), \"%u\\n\", ar->debug.disc_timeout);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic ssize_t ath6kl_disconnect_timeout_write(struct file *file,\n\t\t\t\t\t       const char __user *user_buf,\n\t\t\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct ath6kl *ar = file->private_data;\n\tint ret;\n\tu8 val;\n\n\tret = kstrtou8_from_user(user_buf, count, 0, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ath6kl_wmi_disctimeout_cmd(ar->wmi, 0, val);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic const struct file_operations fops_disconnect_timeout = {\n\t.open = simple_open,\n\t.read = ath6kl_disconnect_timeout_read,\n\t.write = ath6kl_disconnect_timeout_write,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t ath6kl_create_qos_write(struct file *file,\n\t\t\t\t\t\tconst char __user *user_buf,\n\t\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct ath6kl *ar = file->private_data;\n\tstruct ath6kl_vif *vif;\n\tchar buf[200];\n\tssize_t len;\n\tchar *sptr, *token;\n\tstruct wmi_create_pstream_cmd pstream;\n\tu32 val32;\n\tu16 val16;\n\n\tvif = ath6kl_vif_first(ar);\n\tif (!vif)\n\t\treturn -EIO;\n\n\tlen = min(count, sizeof(buf) - 1);\n\tif (copy_from_user(buf, user_buf, len))\n\t\treturn -EFAULT;\n\tbuf[len] = '\\0';\n\tsptr = buf;\n\n\ttoken = strsep(&sptr, \" \");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou8(token, 0, &pstream.user_pri))\n\t\treturn -EINVAL;\n\n\ttoken = strsep(&sptr, \" \");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou8(token, 0, &pstream.traffic_direc))\n\t\treturn -EINVAL;\n\n\ttoken = strsep(&sptr, \" \");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou8(token, 0, &pstream.traffic_class))\n\t\treturn -EINVAL;\n\n\ttoken = strsep(&sptr, \" \");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou8(token, 0, &pstream.traffic_type))\n\t\treturn -EINVAL;\n\n\ttoken = strsep(&sptr, \" \");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou8(token, 0, &pstream.voice_psc_cap))\n\t\treturn -EINVAL;\n\n\ttoken = strsep(&sptr, \" \");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou32(token, 0, &val32))\n\t\treturn -EINVAL;\n\tpstream.min_service_int = cpu_to_le32(val32);\n\n\ttoken = strsep(&sptr, \" \");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou32(token, 0, &val32))\n\t\treturn -EINVAL;\n\tpstream.max_service_int = cpu_to_le32(val32);\n\n\ttoken = strsep(&sptr, \" \");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou32(token, 0, &val32))\n\t\treturn -EINVAL;\n\tpstream.inactivity_int = cpu_to_le32(val32);\n\n\ttoken = strsep(&sptr, \" \");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou32(token, 0, &val32))\n\t\treturn -EINVAL;\n\tpstream.suspension_int = cpu_to_le32(val32);\n\n\ttoken = strsep(&sptr, \" \");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou32(token, 0, &val32))\n\t\treturn -EINVAL;\n\tpstream.service_start_time = cpu_to_le32(val32);\n\n\ttoken = strsep(&sptr, \" \");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou8(token, 0, &pstream.tsid))\n\t\treturn -EINVAL;\n\n\ttoken = strsep(&sptr, \" \");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou16(token, 0, &val16))\n\t\treturn -EINVAL;\n\tpstream.nominal_msdu = cpu_to_le16(val16);\n\n\ttoken = strsep(&sptr, \" \");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou16(token, 0, &val16))\n\t\treturn -EINVAL;\n\tpstream.max_msdu = cpu_to_le16(val16);\n\n\ttoken = strsep(&sptr, \" \");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou32(token, 0, &val32))\n\t\treturn -EINVAL;\n\tpstream.min_data_rate = cpu_to_le32(val32);\n\n\ttoken = strsep(&sptr, \" \");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou32(token, 0, &val32))\n\t\treturn -EINVAL;\n\tpstream.mean_data_rate = cpu_to_le32(val32);\n\n\ttoken = strsep(&sptr, \" \");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou32(token, 0, &val32))\n\t\treturn -EINVAL;\n\tpstream.peak_data_rate = cpu_to_le32(val32);\n\n\ttoken = strsep(&sptr, \" \");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou32(token, 0, &val32))\n\t\treturn -EINVAL;\n\tpstream.max_burst_size = cpu_to_le32(val32);\n\n\ttoken = strsep(&sptr, \" \");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou32(token, 0, &val32))\n\t\treturn -EINVAL;\n\tpstream.delay_bound = cpu_to_le32(val32);\n\n\ttoken = strsep(&sptr, \" \");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou32(token, 0, &val32))\n\t\treturn -EINVAL;\n\tpstream.min_phy_rate = cpu_to_le32(val32);\n\n\ttoken = strsep(&sptr, \" \");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou32(token, 0, &val32))\n\t\treturn -EINVAL;\n\tpstream.sba = cpu_to_le32(val32);\n\n\ttoken = strsep(&sptr, \" \");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou32(token, 0, &val32))\n\t\treturn -EINVAL;\n\tpstream.medium_time = cpu_to_le32(val32);\n\n\tpstream.nominal_phy = le32_to_cpu(pstream.min_phy_rate) / 1000000;\n\n\tath6kl_wmi_create_pstream_cmd(ar->wmi, vif->fw_vif_idx, &pstream);\n\n\treturn count;\n}\n\nstatic const struct file_operations fops_create_qos = {\n\t.write = ath6kl_create_qos_write,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t ath6kl_delete_qos_write(struct file *file,\n\t\t\t\tconst char __user *user_buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct ath6kl *ar = file->private_data;\n\tstruct ath6kl_vif *vif;\n\tchar buf[100];\n\tssize_t len;\n\tchar *sptr, *token;\n\tu8 traffic_class;\n\tu8 tsid;\n\n\tvif = ath6kl_vif_first(ar);\n\tif (!vif)\n\t\treturn -EIO;\n\n\tlen = min(count, sizeof(buf) - 1);\n\tif (copy_from_user(buf, user_buf, len))\n\t\treturn -EFAULT;\n\tbuf[len] = '\\0';\n\tsptr = buf;\n\n\ttoken = strsep(&sptr, \" \");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou8(token, 0, &traffic_class))\n\t\treturn -EINVAL;\n\n\ttoken = strsep(&sptr, \" \");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou8(token, 0, &tsid))\n\t\treturn -EINVAL;\n\n\tath6kl_wmi_delete_pstream_cmd(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t      traffic_class, tsid);\n\n\treturn count;\n}\n\nstatic const struct file_operations fops_delete_qos = {\n\t.write = ath6kl_delete_qos_write,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t ath6kl_bgscan_int_write(struct file *file,\n\t\t\t\tconst char __user *user_buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct ath6kl *ar = file->private_data;\n\tstruct ath6kl_vif *vif;\n\tu16 bgscan_int;\n\tchar buf[32];\n\tssize_t len;\n\n\tvif = ath6kl_vif_first(ar);\n\tif (!vif)\n\t\treturn -EIO;\n\n\tlen = min(count, sizeof(buf) - 1);\n\tif (copy_from_user(buf, user_buf, len))\n\t\treturn -EFAULT;\n\n\tbuf[len] = '\\0';\n\tif (kstrtou16(buf, 0, &bgscan_int))\n\t\treturn -EINVAL;\n\n\tif (bgscan_int == 0)\n\t\tbgscan_int = 0xffff;\n\n\tvif->bg_scan_period = bgscan_int;\n\n\tath6kl_wmi_scanparams_cmd(ar->wmi, 0, 0, 0, bgscan_int, 0, 0, 0, 3,\n\t\t\t\t  0, 0, 0);\n\n\treturn count;\n}\n\nstatic const struct file_operations fops_bgscan_int = {\n\t.write = ath6kl_bgscan_int_write,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t ath6kl_listen_int_write(struct file *file,\n\t\t\t\t       const char __user *user_buf,\n\t\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct ath6kl *ar = file->private_data;\n\tstruct ath6kl_vif *vif;\n\tu16 listen_interval;\n\tchar buf[32];\n\tssize_t len;\n\n\tvif = ath6kl_vif_first(ar);\n\tif (!vif)\n\t\treturn -EIO;\n\n\tlen = min(count, sizeof(buf) - 1);\n\tif (copy_from_user(buf, user_buf, len))\n\t\treturn -EFAULT;\n\n\tbuf[len] = '\\0';\n\tif (kstrtou16(buf, 0, &listen_interval))\n\t\treturn -EINVAL;\n\n\tif ((listen_interval < 15) || (listen_interval > 3000))\n\t\treturn -EINVAL;\n\n\tvif->listen_intvl_t = listen_interval;\n\tath6kl_wmi_listeninterval_cmd(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t      vif->listen_intvl_t, 0);\n\n\treturn count;\n}\n\nstatic ssize_t ath6kl_listen_int_read(struct file *file,\n\t\t\t\t      char __user *user_buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct ath6kl *ar = file->private_data;\n\tstruct ath6kl_vif *vif;\n\tchar buf[32];\n\tint len;\n\n\tvif = ath6kl_vif_first(ar);\n\tif (!vif)\n\t\treturn -EIO;\n\n\tlen = scnprintf(buf, sizeof(buf), \"%u\\n\", vif->listen_intvl_t);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic const struct file_operations fops_listen_int = {\n\t.read = ath6kl_listen_int_read,\n\t.write = ath6kl_listen_int_write,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t ath6kl_power_params_write(struct file *file,\n\t\t\t\t\t\tconst char __user *user_buf,\n\t\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct ath6kl *ar = file->private_data;\n\tu8 buf[100];\n\tunsigned int len = 0;\n\tchar *sptr, *token;\n\tu16 idle_period, ps_poll_num, dtim,\n\t\ttx_wakeup, num_tx;\n\n\tlen = min(count, sizeof(buf) - 1);\n\tif (copy_from_user(buf, user_buf, len))\n\t\treturn -EFAULT;\n\tbuf[len] = '\\0';\n\tsptr = buf;\n\n\ttoken = strsep(&sptr, \" \");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou16(token, 0, &idle_period))\n\t\treturn -EINVAL;\n\n\ttoken = strsep(&sptr, \" \");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou16(token, 0, &ps_poll_num))\n\t\treturn -EINVAL;\n\n\ttoken = strsep(&sptr, \" \");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou16(token, 0, &dtim))\n\t\treturn -EINVAL;\n\n\ttoken = strsep(&sptr, \" \");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou16(token, 0, &tx_wakeup))\n\t\treturn -EINVAL;\n\n\ttoken = strsep(&sptr, \" \");\n\tif (!token)\n\t\treturn -EINVAL;\n\tif (kstrtou16(token, 0, &num_tx))\n\t\treturn -EINVAL;\n\n\tath6kl_wmi_pmparams_cmd(ar->wmi, 0, idle_period, ps_poll_num,\n\t\t\t\tdtim, tx_wakeup, num_tx, 0);\n\n\treturn count;\n}\n\nstatic const struct file_operations fops_power_params = {\n\t.write = ath6kl_power_params_write,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nvoid ath6kl_debug_init(struct ath6kl *ar)\n{\n\tskb_queue_head_init(&ar->debug.fwlog_queue);\n\tinit_completion(&ar->debug.fwlog_completion);\n\n\t \n\tar->debug.fwlog_mask = 0;\n}\n\n \nint ath6kl_debug_init_fs(struct ath6kl *ar)\n{\n\tar->debugfs_phy = debugfs_create_dir(\"ath6kl\",\n\t\t\t\t\t     ar->wiphy->debugfsdir);\n\n\tdebugfs_create_file(\"tgt_stats\", 0400, ar->debugfs_phy, ar,\n\t\t\t    &fops_tgt_stats);\n\n\tif (ar->hif_type == ATH6KL_HIF_TYPE_SDIO)\n\t\tdebugfs_create_file(\"credit_dist_stats\", 0400,\n\t\t\t\t    ar->debugfs_phy, ar,\n\t\t\t\t    &fops_credit_dist_stats);\n\n\tdebugfs_create_file(\"endpoint_stats\", 0600,\n\t\t\t    ar->debugfs_phy, ar, &fops_endpoint_stats);\n\n\tdebugfs_create_file(\"fwlog\", 0400, ar->debugfs_phy, ar, &fops_fwlog);\n\n\tdebugfs_create_file(\"fwlog_block\", 0400, ar->debugfs_phy, ar,\n\t\t\t    &fops_fwlog_block);\n\n\tdebugfs_create_file(\"fwlog_mask\", 0600, ar->debugfs_phy,\n\t\t\t    ar, &fops_fwlog_mask);\n\n\tdebugfs_create_file(\"reg_addr\", 0600, ar->debugfs_phy, ar,\n\t\t\t    &fops_diag_reg_read);\n\n\tdebugfs_create_file(\"reg_dump\", 0400, ar->debugfs_phy, ar,\n\t\t\t    &fops_reg_dump);\n\n\tdebugfs_create_file(\"lrssi_roam_threshold\", 0600,\n\t\t\t    ar->debugfs_phy, ar, &fops_lrssi_roam_threshold);\n\n\tdebugfs_create_file(\"reg_write\", 0600,\n\t\t\t    ar->debugfs_phy, ar, &fops_diag_reg_write);\n\n\tdebugfs_create_file(\"war_stats\", 0400, ar->debugfs_phy, ar,\n\t\t\t    &fops_war_stats);\n\n\tdebugfs_create_file(\"roam_table\", 0400, ar->debugfs_phy, ar,\n\t\t\t    &fops_roam_table);\n\n\tdebugfs_create_file(\"force_roam\", 0200, ar->debugfs_phy, ar,\n\t\t\t    &fops_force_roam);\n\n\tdebugfs_create_file(\"roam_mode\", 0200, ar->debugfs_phy, ar,\n\t\t\t    &fops_roam_mode);\n\n\tdebugfs_create_file(\"keepalive\", 0600, ar->debugfs_phy, ar,\n\t\t\t    &fops_keepalive);\n\n\tdebugfs_create_file(\"disconnect_timeout\", 0600,\n\t\t\t    ar->debugfs_phy, ar, &fops_disconnect_timeout);\n\n\tdebugfs_create_file(\"create_qos\", 0200, ar->debugfs_phy, ar,\n\t\t\t    &fops_create_qos);\n\n\tdebugfs_create_file(\"delete_qos\", 0200, ar->debugfs_phy, ar,\n\t\t\t    &fops_delete_qos);\n\n\tdebugfs_create_file(\"bgscan_interval\", 0200,\n\t\t\t    ar->debugfs_phy, ar, &fops_bgscan_int);\n\n\tdebugfs_create_file(\"listen_interval\", 0600,\n\t\t\t    ar->debugfs_phy, ar, &fops_listen_int);\n\n\tdebugfs_create_file(\"power_params\", 0200, ar->debugfs_phy, ar,\n\t\t\t    &fops_power_params);\n\n\treturn 0;\n}\n\nvoid ath6kl_debug_cleanup(struct ath6kl *ar)\n{\n\tskb_queue_purge(&ar->debug.fwlog_queue);\n\tcomplete(&ar->debug.fwlog_completion);\n\tkfree(ar->debug.roam_tbl);\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}