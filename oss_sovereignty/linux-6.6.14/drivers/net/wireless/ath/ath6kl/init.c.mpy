{
  "module_name": "init.c",
  "hash_id": "f62354744d6802bfbbc593e74a304d34e2e27c7018cd7d730a642839f3d6998f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath6kl/init.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/moduleparam.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n#include <linux/of.h>\n#include <linux/mmc/sdio_func.h>\n#include <linux/vmalloc.h>\n\n#include \"core.h\"\n#include \"cfg80211.h\"\n#include \"target.h\"\n#include \"debug.h\"\n#include \"hif-ops.h\"\n#include \"htc-ops.h\"\n\nstatic const struct ath6kl_hw hw_list[] = {\n\t{\n\t\t.id\t\t\t\t= AR6003_HW_2_0_VERSION,\n\t\t.name\t\t\t\t= \"ar6003 hw 2.0\",\n\t\t.dataset_patch_addr\t\t= 0x57e884,\n\t\t.app_load_addr\t\t\t= 0x543180,\n\t\t.board_ext_data_addr\t\t= 0x57e500,\n\t\t.reserved_ram_size\t\t= 6912,\n\t\t.refclk_hz\t\t\t= 26000000,\n\t\t.uarttx_pin\t\t\t= 8,\n\t\t.flags\t\t\t\t= ATH6KL_HW_SDIO_CRC_ERROR_WAR,\n\n\t\t \n\t\t.app_start_override_addr\t= 0x944C00,\n\n\t\t.fw = {\n\t\t\t.dir\t\t= AR6003_HW_2_0_FW_DIR,\n\t\t\t.otp\t\t= AR6003_HW_2_0_OTP_FILE,\n\t\t\t.fw\t\t= AR6003_HW_2_0_FIRMWARE_FILE,\n\t\t\t.tcmd\t\t= AR6003_HW_2_0_TCMD_FIRMWARE_FILE,\n\t\t\t.patch\t\t= AR6003_HW_2_0_PATCH_FILE,\n\t\t},\n\n\t\t.fw_board\t\t= AR6003_HW_2_0_BOARD_DATA_FILE,\n\t\t.fw_default_board\t= AR6003_HW_2_0_DEFAULT_BOARD_DATA_FILE,\n\t},\n\t{\n\t\t.id\t\t\t\t= AR6003_HW_2_1_1_VERSION,\n\t\t.name\t\t\t\t= \"ar6003 hw 2.1.1\",\n\t\t.dataset_patch_addr\t\t= 0x57ff74,\n\t\t.app_load_addr\t\t\t= 0x1234,\n\t\t.board_ext_data_addr\t\t= 0x542330,\n\t\t.reserved_ram_size\t\t= 512,\n\t\t.refclk_hz\t\t\t= 26000000,\n\t\t.uarttx_pin\t\t\t= 8,\n\t\t.testscript_addr\t\t= 0x57ef74,\n\t\t.flags\t\t\t\t= ATH6KL_HW_SDIO_CRC_ERROR_WAR,\n\n\t\t.fw = {\n\t\t\t.dir\t\t= AR6003_HW_2_1_1_FW_DIR,\n\t\t\t.otp\t\t= AR6003_HW_2_1_1_OTP_FILE,\n\t\t\t.fw\t\t= AR6003_HW_2_1_1_FIRMWARE_FILE,\n\t\t\t.tcmd\t\t= AR6003_HW_2_1_1_TCMD_FIRMWARE_FILE,\n\t\t\t.patch\t\t= AR6003_HW_2_1_1_PATCH_FILE,\n\t\t\t.utf\t\t= AR6003_HW_2_1_1_UTF_FIRMWARE_FILE,\n\t\t\t.testscript\t= AR6003_HW_2_1_1_TESTSCRIPT_FILE,\n\t\t},\n\n\t\t.fw_board\t\t= AR6003_HW_2_1_1_BOARD_DATA_FILE,\n\t\t.fw_default_board = AR6003_HW_2_1_1_DEFAULT_BOARD_DATA_FILE,\n\t},\n\t{\n\t\t.id\t\t\t\t= AR6004_HW_1_0_VERSION,\n\t\t.name\t\t\t\t= \"ar6004 hw 1.0\",\n\t\t.dataset_patch_addr\t\t= 0x57e884,\n\t\t.app_load_addr\t\t\t= 0x1234,\n\t\t.board_ext_data_addr\t\t= 0x437000,\n\t\t.reserved_ram_size\t\t= 19456,\n\t\t.board_addr\t\t\t= 0x433900,\n\t\t.refclk_hz\t\t\t= 26000000,\n\t\t.uarttx_pin\t\t\t= 11,\n\t\t.flags\t\t\t\t= 0,\n\n\t\t.fw = {\n\t\t\t.dir\t\t= AR6004_HW_1_0_FW_DIR,\n\t\t\t.fw\t\t= AR6004_HW_1_0_FIRMWARE_FILE,\n\t\t},\n\n\t\t.fw_board\t\t= AR6004_HW_1_0_BOARD_DATA_FILE,\n\t\t.fw_default_board\t= AR6004_HW_1_0_DEFAULT_BOARD_DATA_FILE,\n\t},\n\t{\n\t\t.id\t\t\t\t= AR6004_HW_1_1_VERSION,\n\t\t.name\t\t\t\t= \"ar6004 hw 1.1\",\n\t\t.dataset_patch_addr\t\t= 0x57e884,\n\t\t.app_load_addr\t\t\t= 0x1234,\n\t\t.board_ext_data_addr\t\t= 0x437000,\n\t\t.reserved_ram_size\t\t= 11264,\n\t\t.board_addr\t\t\t= 0x43d400,\n\t\t.refclk_hz\t\t\t= 40000000,\n\t\t.uarttx_pin\t\t\t= 11,\n\t\t.flags\t\t\t\t= 0,\n\t\t.fw = {\n\t\t\t.dir\t\t= AR6004_HW_1_1_FW_DIR,\n\t\t\t.fw\t\t= AR6004_HW_1_1_FIRMWARE_FILE,\n\t\t},\n\n\t\t.fw_board\t\t= AR6004_HW_1_1_BOARD_DATA_FILE,\n\t\t.fw_default_board\t= AR6004_HW_1_1_DEFAULT_BOARD_DATA_FILE,\n\t},\n\t{\n\t\t.id\t\t\t\t= AR6004_HW_1_2_VERSION,\n\t\t.name\t\t\t\t= \"ar6004 hw 1.2\",\n\t\t.dataset_patch_addr\t\t= 0x436ecc,\n\t\t.app_load_addr\t\t\t= 0x1234,\n\t\t.board_ext_data_addr\t\t= 0x437000,\n\t\t.reserved_ram_size\t\t= 9216,\n\t\t.board_addr\t\t\t= 0x435c00,\n\t\t.refclk_hz\t\t\t= 40000000,\n\t\t.uarttx_pin\t\t\t= 11,\n\t\t.flags\t\t\t\t= 0,\n\n\t\t.fw = {\n\t\t\t.dir\t\t= AR6004_HW_1_2_FW_DIR,\n\t\t\t.fw\t\t= AR6004_HW_1_2_FIRMWARE_FILE,\n\t\t},\n\t\t.fw_board\t\t= AR6004_HW_1_2_BOARD_DATA_FILE,\n\t\t.fw_default_board\t= AR6004_HW_1_2_DEFAULT_BOARD_DATA_FILE,\n\t},\n\t{\n\t\t.id\t\t\t\t= AR6004_HW_1_3_VERSION,\n\t\t.name\t\t\t\t= \"ar6004 hw 1.3\",\n\t\t.dataset_patch_addr\t\t= 0x437860,\n\t\t.app_load_addr\t\t\t= 0x1234,\n\t\t.board_ext_data_addr\t\t= 0x437000,\n\t\t.reserved_ram_size\t\t= 7168,\n\t\t.board_addr\t\t\t= 0x436400,\n\t\t.refclk_hz                      = 0,\n\t\t.uarttx_pin                     = 11,\n\t\t.flags\t\t\t\t= 0,\n\n\t\t.fw = {\n\t\t\t.dir            = AR6004_HW_1_3_FW_DIR,\n\t\t\t.fw             = AR6004_HW_1_3_FIRMWARE_FILE,\n\t\t\t.tcmd\t        = AR6004_HW_1_3_TCMD_FIRMWARE_FILE,\n\t\t\t.utf\t\t= AR6004_HW_1_3_UTF_FIRMWARE_FILE,\n\t\t\t.testscript\t= AR6004_HW_1_3_TESTSCRIPT_FILE,\n\t\t},\n\n\t\t.fw_board               = AR6004_HW_1_3_BOARD_DATA_FILE,\n\t\t.fw_default_board       = AR6004_HW_1_3_DEFAULT_BOARD_DATA_FILE,\n\t},\n\t{\n\t\t.id\t\t\t\t= AR6004_HW_3_0_VERSION,\n\t\t.name\t\t\t\t= \"ar6004 hw 3.0\",\n\t\t.dataset_patch_addr\t\t= 0,\n\t\t.app_load_addr\t\t\t= 0x1234,\n\t\t.board_ext_data_addr\t\t= 0,\n\t\t.reserved_ram_size\t\t= 7168,\n\t\t.board_addr\t\t\t= 0x436400,\n\t\t.testscript_addr\t\t= 0,\n\t\t.uarttx_pin\t\t\t= 11,\n\t\t.flags\t\t\t\t= 0,\n\n\t\t.fw = {\n\t\t\t.dir\t\t= AR6004_HW_3_0_FW_DIR,\n\t\t\t.fw\t\t= AR6004_HW_3_0_FIRMWARE_FILE,\n\t\t\t.tcmd\t        = AR6004_HW_3_0_TCMD_FIRMWARE_FILE,\n\t\t\t.utf\t\t= AR6004_HW_3_0_UTF_FIRMWARE_FILE,\n\t\t\t.testscript\t= AR6004_HW_3_0_TESTSCRIPT_FILE,\n\t\t},\n\n\t\t.fw_board\t\t= AR6004_HW_3_0_BOARD_DATA_FILE,\n\t\t.fw_default_board\t= AR6004_HW_3_0_DEFAULT_BOARD_DATA_FILE,\n\t},\n};\n\n \n\n \n#define WLAN_CONFIG_KEEP_ALIVE_INTERVAL 60\n\n \n#define WLAN_CONFIG_DISCONNECT_TIMEOUT 10\n\n\n#define ATH6KL_DATA_OFFSET    64\nstruct sk_buff *ath6kl_buf_alloc(int size)\n{\n\tstruct sk_buff *skb;\n\tu16 reserved;\n\n\t \n\treserved = roundup((2 * L1_CACHE_BYTES) + ATH6KL_DATA_OFFSET +\n\t\t   sizeof(struct htc_packet) + ATH6KL_HTC_ALIGN_BYTES, 4);\n\tskb = dev_alloc_skb(size + reserved);\n\n\tif (skb)\n\t\tskb_reserve(skb, reserved - L1_CACHE_BYTES);\n\treturn skb;\n}\n\nvoid ath6kl_init_profile_info(struct ath6kl_vif *vif)\n{\n\tvif->ssid_len = 0;\n\tmemset(vif->ssid, 0, sizeof(vif->ssid));\n\n\tvif->dot11_auth_mode = OPEN_AUTH;\n\tvif->auth_mode = NONE_AUTH;\n\tvif->prwise_crypto = NONE_CRYPT;\n\tvif->prwise_crypto_len = 0;\n\tvif->grp_crypto = NONE_CRYPT;\n\tvif->grp_crypto_len = 0;\n\tmemset(vif->wep_key_list, 0, sizeof(vif->wep_key_list));\n\tmemset(vif->req_bssid, 0, sizeof(vif->req_bssid));\n\tmemset(vif->bssid, 0, sizeof(vif->bssid));\n\tvif->bss_ch = 0;\n}\n\nstatic int ath6kl_set_host_app_area(struct ath6kl *ar)\n{\n\tu32 address, data;\n\tstruct host_app_area host_app_area;\n\n\t \n\taddress = ath6kl_get_hi_item_addr(ar, HI_ITEM(hi_app_host_interest));\n\taddress = TARG_VTOP(ar->target_type, address);\n\n\tif (ath6kl_diag_read32(ar, address, &data))\n\t\treturn -EIO;\n\n\taddress = TARG_VTOP(ar->target_type, data);\n\thost_app_area.wmi_protocol_ver = cpu_to_le32(WMI_PROTOCOL_VERSION);\n\tif (ath6kl_diag_write(ar, address, (u8 *) &host_app_area,\n\t\t\t      sizeof(struct host_app_area)))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic inline void set_ac2_ep_map(struct ath6kl *ar,\n\t\t\t\t  u8 ac,\n\t\t\t\t  enum htc_endpoint_id ep)\n{\n\tar->ac2ep_map[ac] = ep;\n\tar->ep2ac_map[ep] = ac;\n}\n\n \nstatic int ath6kl_connectservice(struct ath6kl *ar,\n\t\t\t\t struct htc_service_connect_req  *con_req,\n\t\t\t\t char *desc)\n{\n\tint status;\n\tstruct htc_service_connect_resp response;\n\n\tmemset(&response, 0, sizeof(response));\n\n\tstatus = ath6kl_htc_conn_service(ar->htc_target, con_req, &response);\n\tif (status) {\n\t\tath6kl_err(\"failed to connect to %s service status:%d\\n\",\n\t\t\t   desc, status);\n\t\treturn status;\n\t}\n\n\tswitch (con_req->svc_id) {\n\tcase WMI_CONTROL_SVC:\n\t\tif (test_bit(WMI_ENABLED, &ar->flag))\n\t\t\tath6kl_wmi_set_control_ep(ar->wmi, response.endpoint);\n\t\tar->ctrl_ep = response.endpoint;\n\t\tbreak;\n\tcase WMI_DATA_BE_SVC:\n\t\tset_ac2_ep_map(ar, WMM_AC_BE, response.endpoint);\n\t\tbreak;\n\tcase WMI_DATA_BK_SVC:\n\t\tset_ac2_ep_map(ar, WMM_AC_BK, response.endpoint);\n\t\tbreak;\n\tcase WMI_DATA_VI_SVC:\n\t\tset_ac2_ep_map(ar, WMM_AC_VI, response.endpoint);\n\t\tbreak;\n\tcase WMI_DATA_VO_SVC:\n\t\tset_ac2_ep_map(ar, WMM_AC_VO, response.endpoint);\n\t\tbreak;\n\tdefault:\n\t\tath6kl_err(\"service id is not mapped %d\\n\", con_req->svc_id);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath6kl_init_service_ep(struct ath6kl *ar)\n{\n\tstruct htc_service_connect_req connect;\n\n\tmemset(&connect, 0, sizeof(connect));\n\n\t \n\tconnect.ep_cb.tx_comp_multi = ath6kl_tx_complete;\n\tconnect.ep_cb.rx = ath6kl_rx;\n\tconnect.ep_cb.rx_refill = ath6kl_rx_refill;\n\tconnect.ep_cb.tx_full = ath6kl_tx_queue_full;\n\n\t \n\tconnect.max_txq_depth = MAX_DEFAULT_SEND_QUEUE_DEPTH;\n\tconnect.ep_cb.rx_refill_thresh = ATH6KL_MAX_RX_BUFFERS / 4;\n\tif (!connect.ep_cb.rx_refill_thresh)\n\t\tconnect.ep_cb.rx_refill_thresh++;\n\n\t \n\tconnect.svc_id = WMI_CONTROL_SVC;\n\tif (ath6kl_connectservice(ar, &connect, \"WMI CONTROL\"))\n\t\treturn -EIO;\n\n\tconnect.flags |= HTC_FLGS_TX_BNDL_PAD_EN;\n\n\t \n\tconnect.max_rxmsg_sz = WMI_MAX_TX_DATA_FRAME_LENGTH;\n\n\t \n\tconnect.ep_cb.rx_alloc_thresh = ATH6KL_BUFFER_SIZE;\n\tconnect.ep_cb.rx_allocthresh = ath6kl_alloc_amsdu_rxbuf;\n\n\t \n\tconnect.conn_flags |= HTC_CONN_FLGS_REDUCE_CRED_DRIB;\n\tconnect.conn_flags &= ~HTC_CONN_FLGS_THRESH_MASK;\n\tconnect.conn_flags |= HTC_CONN_FLGS_THRESH_LVL_HALF;\n\n\tconnect.svc_id = WMI_DATA_BE_SVC;\n\n\tif (ath6kl_connectservice(ar, &connect, \"WMI DATA BE\"))\n\t\treturn -EIO;\n\n\t \n\tconnect.svc_id = WMI_DATA_BK_SVC;\n\tif (ath6kl_connectservice(ar, &connect, \"WMI DATA BK\"))\n\t\treturn -EIO;\n\n\t \n\tconnect.svc_id = WMI_DATA_VI_SVC;\n\tif (ath6kl_connectservice(ar, &connect, \"WMI DATA VI\"))\n\t\treturn -EIO;\n\n\t \n\tconnect.svc_id = WMI_DATA_VO_SVC;\n\tif (ath6kl_connectservice(ar, &connect, \"WMI DATA VO\"))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nvoid ath6kl_init_control_info(struct ath6kl_vif *vif)\n{\n\tath6kl_init_profile_info(vif);\n\tvif->def_txkey_index = 0;\n\tmemset(vif->wep_key_list, 0, sizeof(vif->wep_key_list));\n\tvif->ch_hint = 0;\n}\n\n \nstatic int ath6kl_set_htc_params(struct ath6kl *ar, u32 mbox_isr_yield_val,\n\t\t\t\t u8 htc_ctrl_buf)\n{\n\tint status;\n\tu32 blk_size;\n\n\tblk_size = ar->mbox_info.block_size;\n\n\tif (htc_ctrl_buf)\n\t\tblk_size |=  ((u32)htc_ctrl_buf) << 16;\n\n\t \n\tstatus = ath6kl_bmi_write_hi32(ar, hi_mbox_io_block_sz, blk_size);\n\tif (status) {\n\t\tath6kl_err(\"bmi_write_memory for IO block size failed\\n\");\n\t\tgoto out;\n\t}\n\n\tath6kl_dbg(ATH6KL_DBG_TRC, \"block size set: %d (target addr:0x%X)\\n\",\n\t\t   blk_size,\n\t\t   ath6kl_get_hi_item_addr(ar, HI_ITEM(hi_mbox_io_block_sz)));\n\n\tif (mbox_isr_yield_val) {\n\t\t \n\t\tstatus = ath6kl_bmi_write_hi32(ar, hi_mbox_isr_yield_limit,\n\t\t\t\t\t       mbox_isr_yield_val);\n\t\tif (status) {\n\t\t\tath6kl_err(\"bmi_write_memory for yield limit failed\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn status;\n}\n\nstatic int ath6kl_target_config_wlan_params(struct ath6kl *ar, int idx)\n{\n\tint ret;\n\n\t \n\tret = ath6kl_wmi_set_rx_frame_format_cmd(ar->wmi, idx,\n\t\t\t\t\t\t ar->rx_meta_ver, 0, 0);\n\tif (ret) {\n\t\tath6kl_err(\"unable to set the rx frame format: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (ar->conf_flags & ATH6KL_CONF_IGNORE_PS_FAIL_EVT_IN_SCAN) {\n\t\tret = ath6kl_wmi_pmparams_cmd(ar->wmi, idx, 0, 1, 0, 0, 1,\n\t\t\t\t\t      IGNORE_PS_FAIL_DURING_SCAN);\n\t\tif (ret) {\n\t\t\tath6kl_err(\"unable to set power save fail event policy: %d\\n\",\n\t\t\t\t   ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (!(ar->conf_flags & ATH6KL_CONF_IGNORE_ERP_BARKER)) {\n\t\tret = ath6kl_wmi_set_lpreamble_cmd(ar->wmi, idx, 0,\n\t\t\t\t\t\t   WMI_FOLLOW_BARKER_IN_ERP);\n\t\tif (ret) {\n\t\t\tath6kl_err(\"unable to set barker preamble policy: %d\\n\",\n\t\t\t\t   ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = ath6kl_wmi_set_keepalive_cmd(ar->wmi, idx,\n\t\t\t\t\t   WLAN_CONFIG_KEEP_ALIVE_INTERVAL);\n\tif (ret) {\n\t\tath6kl_err(\"unable to set keep alive interval: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ath6kl_wmi_disctimeout_cmd(ar->wmi, idx,\n\t\t\t\t\t WLAN_CONFIG_DISCONNECT_TIMEOUT);\n\tif (ret) {\n\t\tath6kl_err(\"unable to set disconnect timeout: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (!(ar->conf_flags & ATH6KL_CONF_ENABLE_TX_BURST)) {\n\t\tret = ath6kl_wmi_set_wmm_txop(ar->wmi, idx, WMI_TXOP_DISABLED);\n\t\tif (ret) {\n\t\t\tath6kl_err(\"unable to set txop bursting: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (ar->p2p && (ar->vif_max == 1 || idx)) {\n\t\tret = ath6kl_wmi_info_req_cmd(ar->wmi, idx,\n\t\t\t\t\t      P2P_FLAG_CAPABILITIES_REQ |\n\t\t\t\t\t      P2P_FLAG_MACADDR_REQ |\n\t\t\t\t\t      P2P_FLAG_HMODEL_REQ);\n\t\tif (ret) {\n\t\t\tath6kl_dbg(ATH6KL_DBG_TRC,\n\t\t\t\t   \"failed to request P2P capabilities (%d) - assuming P2P not supported\\n\",\n\t\t\t\t   ret);\n\t\t\tar->p2p = false;\n\t\t}\n\t}\n\n\tif (ar->p2p && (ar->vif_max == 1 || idx)) {\n\t\t \n\t\tret = ath6kl_wmi_probe_report_req_cmd(ar->wmi, idx, true);\n\t\tif (ret) {\n\t\t\tath6kl_dbg(ATH6KL_DBG_TRC,\n\t\t\t\t   \"failed to enable Probe Request reporting (%d)\\n\",\n\t\t\t\t   ret);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint ath6kl_configure_target(struct ath6kl *ar)\n{\n\tu32 param, ram_reserved_size;\n\tu8 fw_iftype, fw_mode = 0, fw_submode = 0;\n\tint i, status;\n\n\tparam = !!(ar->conf_flags & ATH6KL_CONF_UART_DEBUG);\n\tif (ath6kl_bmi_write_hi32(ar, hi_serial_enable, param)) {\n\t\tath6kl_err(\"bmi_write_memory for uart debug failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tfw_iftype = HI_OPTION_FW_MODE_BSS_STA;\n\n\tfor (i = 0; i < ar->vif_max; i++)\n\t\tfw_mode |= fw_iftype << (i * HI_OPTION_FW_MODE_BITS);\n\n\t \n\n\tif (test_bit(ATH6KL_FW_CAPABILITY_STA_P2PDEV_DUPLEX,\n\t\t     ar->fw_capabilities)) {\n\t\tfor (i = 0; i < ar->vif_max; i++)\n\t\t\tfw_submode |= HI_OPTION_FW_SUBMODE_P2PDEV <<\n\t\t\t\t(i * HI_OPTION_FW_SUBMODE_BITS);\n\t} else {\n\t\tfor (i = 0; i < ar->max_norm_iface; i++)\n\t\t\tfw_submode |= HI_OPTION_FW_SUBMODE_NONE <<\n\t\t\t\t(i * HI_OPTION_FW_SUBMODE_BITS);\n\n\t\tfor (i = ar->max_norm_iface; i < ar->vif_max; i++)\n\t\t\tfw_submode |= HI_OPTION_FW_SUBMODE_P2PDEV <<\n\t\t\t\t(i * HI_OPTION_FW_SUBMODE_BITS);\n\n\t\tif (ar->p2p && ar->vif_max == 1)\n\t\t\tfw_submode = HI_OPTION_FW_SUBMODE_P2PDEV;\n\t}\n\n\tif (ath6kl_bmi_write_hi32(ar, hi_app_host_interest,\n\t\t\t\t  HTC_PROTOCOL_VERSION) != 0) {\n\t\tath6kl_err(\"bmi_write_memory for htc version failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tparam = 0;\n\n\tif (ath6kl_bmi_read_hi32(ar, hi_option_flag, &param) != 0) {\n\t\tath6kl_err(\"bmi_read_memory for setting fwmode failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tparam |= (ar->vif_max << HI_OPTION_NUM_DEV_SHIFT);\n\tparam |= fw_mode << HI_OPTION_FW_MODE_SHIFT;\n\tparam |= fw_submode << HI_OPTION_FW_SUBMODE_SHIFT;\n\n\tparam |= (0 << HI_OPTION_MAC_ADDR_METHOD_SHIFT);\n\tparam |= (0 << HI_OPTION_FW_BRIDGE_SHIFT);\n\n\tif (ath6kl_bmi_write_hi32(ar, hi_option_flag, param) != 0) {\n\t\tath6kl_err(\"bmi_write_memory for setting fwmode failed\\n\");\n\t\treturn -EIO;\n\t}\n\n\tath6kl_dbg(ATH6KL_DBG_TRC, \"firmware mode set\\n\");\n\n\t \n\n\tif ((ar->target_type == TARGET_TYPE_AR6003) ||\n\t    (ar->version.target_ver == AR6004_HW_1_3_VERSION) ||\n\t    (ar->version.target_ver == AR6004_HW_3_0_VERSION)) {\n\t\tparam = ar->hw.board_ext_data_addr;\n\t\tram_reserved_size = ar->hw.reserved_ram_size;\n\n\t\tif (ath6kl_bmi_write_hi32(ar, hi_board_ext_data, param) != 0) {\n\t\t\tath6kl_err(\"bmi_write_memory for hi_board_ext_data failed\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif (ath6kl_bmi_write_hi32(ar, hi_end_ram_reserve_sz,\n\t\t\t\t\t  ram_reserved_size) != 0) {\n\t\t\tath6kl_err(\"bmi_write_memory for hi_end_ram_reserve_sz failed\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\t \n\tif (ath6kl_set_htc_params(ar, MBOX_YIELD_LIMIT, 0))\n\t\t \n\t\treturn -EIO;\n\n\t \n\tstatus = ath6kl_bmi_write_hi32(ar, hi_dbg_uart_txpin,\n\t\t\t\t       ar->hw.uarttx_pin);\n\tif (status)\n\t\treturn status;\n\n\t \n\tif (ar->conf_flags & ATH6KL_CONF_UART_DEBUG) {\n\t\tstatus = ath6kl_bmi_write_hi32(ar, hi_desired_baud_rate,\n\t\t\t\t\t       ar->hw.uarttx_rate);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\t \n\tif (ar->hw.refclk_hz != 0) {\n\t\tstatus = ath6kl_bmi_write_hi32(ar, hi_refclk_hz,\n\t\t\t\t\t       ar->hw.refclk_hz);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ath6kl_get_fw(struct ath6kl *ar, const char *filename,\n\t\t\t u8 **fw, size_t *fw_len)\n{\n\tconst struct firmware *fw_entry;\n\tint ret;\n\n\tret = request_firmware(&fw_entry, filename, ar->dev);\n\tif (ret)\n\t\treturn ret;\n\n\t*fw_len = fw_entry->size;\n\t*fw = kmemdup(fw_entry->data, fw_entry->size, GFP_KERNEL);\n\n\tif (*fw == NULL)\n\t\tret = -ENOMEM;\n\n\trelease_firmware(fw_entry);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_OF\n \nstatic bool check_device_tree(struct ath6kl *ar)\n{\n\tstatic const char *board_id_prop = \"atheros,board-id\";\n\tstruct device_node *node;\n\tchar board_filename[64];\n\tconst char *board_id;\n\tint ret;\n\n\tfor_each_compatible_node(node, NULL, \"atheros,ath6kl\") {\n\t\tboard_id = of_get_property(node, board_id_prop, NULL);\n\t\tif (board_id == NULL) {\n\t\t\tath6kl_warn(\"No \\\"%s\\\" property on %pOFn node.\\n\",\n\t\t\t\t    board_id_prop, node);\n\t\t\tcontinue;\n\t\t}\n\t\tsnprintf(board_filename, sizeof(board_filename),\n\t\t\t \"%s/bdata.%s.bin\", ar->hw.fw.dir, board_id);\n\n\t\tret = ath6kl_get_fw(ar, board_filename, &ar->fw_board,\n\t\t\t\t    &ar->fw_board_len);\n\t\tif (ret) {\n\t\t\tath6kl_err(\"Failed to get DT board file %s: %d\\n\",\n\t\t\t\t   board_filename, ret);\n\t\t\tcontinue;\n\t\t}\n\t\tof_node_put(node);\n\t\treturn true;\n\t}\n\treturn false;\n}\n#else\nstatic bool check_device_tree(struct ath6kl *ar)\n{\n\treturn false;\n}\n#endif  \n\nstatic int ath6kl_fetch_board_file(struct ath6kl *ar)\n{\n\tconst char *filename;\n\tint ret;\n\n\tif (ar->fw_board != NULL)\n\t\treturn 0;\n\n\tif (WARN_ON(ar->hw.fw_board == NULL))\n\t\treturn -EINVAL;\n\n\tfilename = ar->hw.fw_board;\n\n\tret = ath6kl_get_fw(ar, filename, &ar->fw_board,\n\t\t\t    &ar->fw_board_len);\n\tif (ret == 0) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tif (check_device_tree(ar)) {\n\t\t \n\t\treturn 0;\n\t}\n\n\t \n\tath6kl_warn(\"Failed to get board file %s (%d), trying to find default board file.\\n\",\n\t\t    filename, ret);\n\n\tfilename = ar->hw.fw_default_board;\n\n\tret = ath6kl_get_fw(ar, filename, &ar->fw_board,\n\t\t\t    &ar->fw_board_len);\n\tif (ret) {\n\t\tath6kl_err(\"Failed to get default board file %s: %d\\n\",\n\t\t\t   filename, ret);\n\t\treturn ret;\n\t}\n\n\tath6kl_warn(\"WARNING! No proper board file was not found, instead using a default board file.\\n\");\n\tath6kl_warn(\"Most likely your hardware won't work as specified. Install correct board file!\\n\");\n\n\treturn 0;\n}\n\nstatic int ath6kl_fetch_otp_file(struct ath6kl *ar)\n{\n\tchar filename[100];\n\tint ret;\n\n\tif (ar->fw_otp != NULL)\n\t\treturn 0;\n\n\tif (ar->hw.fw.otp == NULL) {\n\t\tath6kl_dbg(ATH6KL_DBG_BOOT,\n\t\t\t   \"no OTP file configured for this hw\\n\");\n\t\treturn 0;\n\t}\n\n\tsnprintf(filename, sizeof(filename), \"%s/%s\",\n\t\t ar->hw.fw.dir, ar->hw.fw.otp);\n\n\tret = ath6kl_get_fw(ar, filename, &ar->fw_otp,\n\t\t\t    &ar->fw_otp_len);\n\tif (ret) {\n\t\tath6kl_err(\"Failed to get OTP file %s: %d\\n\",\n\t\t\t   filename, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath6kl_fetch_testmode_file(struct ath6kl *ar)\n{\n\tchar filename[100];\n\tint ret;\n\n\tif (ar->testmode == 0)\n\t\treturn 0;\n\n\tath6kl_dbg(ATH6KL_DBG_BOOT, \"testmode %d\\n\", ar->testmode);\n\n\tif (ar->testmode == 2) {\n\t\tif (ar->hw.fw.utf == NULL) {\n\t\t\tath6kl_warn(\"testmode 2 not supported\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tsnprintf(filename, sizeof(filename), \"%s/%s\",\n\t\t\t ar->hw.fw.dir, ar->hw.fw.utf);\n\t} else {\n\t\tif (ar->hw.fw.tcmd == NULL) {\n\t\t\tath6kl_warn(\"testmode 1 not supported\\n\");\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\n\t\tsnprintf(filename, sizeof(filename), \"%s/%s\",\n\t\t\t ar->hw.fw.dir, ar->hw.fw.tcmd);\n\t}\n\n\tset_bit(TESTMODE, &ar->flag);\n\n\tret = ath6kl_get_fw(ar, filename, &ar->fw, &ar->fw_len);\n\tif (ret) {\n\t\tath6kl_err(\"Failed to get testmode %d firmware file %s: %d\\n\",\n\t\t\t   ar->testmode, filename, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath6kl_fetch_fw_file(struct ath6kl *ar)\n{\n\tchar filename[100];\n\tint ret;\n\n\tif (ar->fw != NULL)\n\t\treturn 0;\n\n\t \n\tif (WARN_ON(ar->hw.fw.fw == NULL))\n\t\treturn -EINVAL;\n\n\tsnprintf(filename, sizeof(filename), \"%s/%s\",\n\t\t ar->hw.fw.dir, ar->hw.fw.fw);\n\n\tret = ath6kl_get_fw(ar, filename, &ar->fw, &ar->fw_len);\n\tif (ret) {\n\t\tath6kl_err(\"Failed to get firmware file %s: %d\\n\",\n\t\t\t   filename, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath6kl_fetch_patch_file(struct ath6kl *ar)\n{\n\tchar filename[100];\n\tint ret;\n\n\tif (ar->fw_patch != NULL)\n\t\treturn 0;\n\n\tif (ar->hw.fw.patch == NULL)\n\t\treturn 0;\n\n\tsnprintf(filename, sizeof(filename), \"%s/%s\",\n\t\t ar->hw.fw.dir, ar->hw.fw.patch);\n\n\tret = ath6kl_get_fw(ar, filename, &ar->fw_patch,\n\t\t\t    &ar->fw_patch_len);\n\tif (ret) {\n\t\tath6kl_err(\"Failed to get patch file %s: %d\\n\",\n\t\t\t   filename, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath6kl_fetch_testscript_file(struct ath6kl *ar)\n{\n\tchar filename[100];\n\tint ret;\n\n\tif (ar->testmode != 2)\n\t\treturn 0;\n\n\tif (ar->fw_testscript != NULL)\n\t\treturn 0;\n\n\tif (ar->hw.fw.testscript == NULL)\n\t\treturn 0;\n\n\tsnprintf(filename, sizeof(filename), \"%s/%s\",\n\t\t ar->hw.fw.dir, ar->hw.fw.testscript);\n\n\tret = ath6kl_get_fw(ar, filename, &ar->fw_testscript,\n\t\t\t\t&ar->fw_testscript_len);\n\tif (ret) {\n\t\tath6kl_err(\"Failed to get testscript file %s: %d\\n\",\n\t\t\t   filename, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath6kl_fetch_fw_api1(struct ath6kl *ar)\n{\n\tint ret;\n\n\tret = ath6kl_fetch_otp_file(ar);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ath6kl_fetch_fw_file(ar);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ath6kl_fetch_patch_file(ar);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ath6kl_fetch_testscript_file(ar);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int ath6kl_fetch_fw_apin(struct ath6kl *ar, const char *name)\n{\n\tsize_t magic_len, len, ie_len;\n\tconst struct firmware *fw;\n\tstruct ath6kl_fw_ie *hdr;\n\tchar filename[100];\n\tconst u8 *data;\n\tint ret, ie_id, i, index, bit;\n\t__le32 *val;\n\n\tsnprintf(filename, sizeof(filename), \"%s/%s\", ar->hw.fw.dir, name);\n\n\tret = request_firmware(&fw, filename, ar->dev);\n\tif (ret) {\n\t\tath6kl_err(\"Failed request firmware, rv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdata = fw->data;\n\tlen = fw->size;\n\n\t \n\tmagic_len = strlen(ATH6KL_FIRMWARE_MAGIC) + 1;\n\n\tif (len < magic_len) {\n\t\tath6kl_err(\"Magic length is invalid, len: %zd  magic_len: %zd\\n\",\n\t\t\t   len, magic_len);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (memcmp(data, ATH6KL_FIRMWARE_MAGIC, magic_len) != 0) {\n\t\tath6kl_err(\"Magic is invalid, magic_len: %zd\\n\",\n\t\t\t   magic_len);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlen -= magic_len;\n\tdata += magic_len;\n\n\t \n\twhile (len > sizeof(struct ath6kl_fw_ie)) {\n\t\t \n\t\thdr = (struct ath6kl_fw_ie *) data;\n\n\t\tie_id = le32_to_cpup(&hdr->id);\n\t\tie_len = le32_to_cpup(&hdr->len);\n\n\t\tlen -= sizeof(*hdr);\n\t\tdata += sizeof(*hdr);\n\n\t\tath6kl_dbg(ATH6KL_DBG_BOOT, \"ie-id: %d  len: %zd (0x%zx)\\n\",\n\t\t\t   ie_id, ie_len, ie_len);\n\n\t\tif (len < ie_len) {\n\t\t\tath6kl_err(\"IE len is invalid, len: %zd  ie_len: %zd  ie-id: %d\\n\",\n\t\t\t\t   len, ie_len, ie_id);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tswitch (ie_id) {\n\t\tcase ATH6KL_FW_IE_FW_VERSION:\n\t\t\tstrscpy(ar->wiphy->fw_version, data,\n\t\t\t\tmin(sizeof(ar->wiphy->fw_version), ie_len+1));\n\n\t\t\tath6kl_dbg(ATH6KL_DBG_BOOT,\n\t\t\t\t   \"found fw version %s\\n\",\n\t\t\t\t    ar->wiphy->fw_version);\n\t\t\tbreak;\n\t\tcase ATH6KL_FW_IE_OTP_IMAGE:\n\t\t\tath6kl_dbg(ATH6KL_DBG_BOOT, \"found otp image ie (%zd B)\\n\",\n\t\t\t\t   ie_len);\n\n\t\t\tar->fw_otp = kmemdup(data, ie_len, GFP_KERNEL);\n\n\t\t\tif (ar->fw_otp == NULL) {\n\t\t\t\tath6kl_err(\"fw_otp cannot be allocated\\n\");\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tar->fw_otp_len = ie_len;\n\t\t\tbreak;\n\t\tcase ATH6KL_FW_IE_FW_IMAGE:\n\t\t\tath6kl_dbg(ATH6KL_DBG_BOOT, \"found fw image ie (%zd B)\\n\",\n\t\t\t\t   ie_len);\n\n\t\t\t \n\t\t\tif (ar->fw != NULL)\n\t\t\t\tbreak;\n\n\t\t\tar->fw = vmalloc(ie_len);\n\n\t\t\tif (ar->fw == NULL) {\n\t\t\t\tath6kl_err(\"fw storage cannot be allocated, len: %zd\\n\", ie_len);\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tmemcpy(ar->fw, data, ie_len);\n\t\t\tar->fw_len = ie_len;\n\t\t\tbreak;\n\t\tcase ATH6KL_FW_IE_PATCH_IMAGE:\n\t\t\tath6kl_dbg(ATH6KL_DBG_BOOT, \"found patch image ie (%zd B)\\n\",\n\t\t\t\t   ie_len);\n\n\t\t\tar->fw_patch = kmemdup(data, ie_len, GFP_KERNEL);\n\n\t\t\tif (ar->fw_patch == NULL) {\n\t\t\t\tath6kl_err(\"fw_patch storage cannot be allocated, len: %zd\\n\", ie_len);\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tar->fw_patch_len = ie_len;\n\t\t\tbreak;\n\t\tcase ATH6KL_FW_IE_RESERVED_RAM_SIZE:\n\t\t\tval = (__le32 *) data;\n\t\t\tar->hw.reserved_ram_size = le32_to_cpup(val);\n\n\t\t\tath6kl_dbg(ATH6KL_DBG_BOOT,\n\t\t\t\t   \"found reserved ram size ie %d\\n\",\n\t\t\t\t   ar->hw.reserved_ram_size);\n\t\t\tbreak;\n\t\tcase ATH6KL_FW_IE_CAPABILITIES:\n\t\t\tath6kl_dbg(ATH6KL_DBG_BOOT,\n\t\t\t\t   \"found firmware capabilities ie (%zd B)\\n\",\n\t\t\t\t   ie_len);\n\n\t\t\tfor (i = 0; i < ATH6KL_FW_CAPABILITY_MAX; i++) {\n\t\t\t\tindex = i / 8;\n\t\t\t\tbit = i % 8;\n\n\t\t\t\tif (index == ie_len)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (data[index] & (1 << bit))\n\t\t\t\t\t__set_bit(i, ar->fw_capabilities);\n\t\t\t}\n\n\t\t\tath6kl_dbg_dump(ATH6KL_DBG_BOOT, \"capabilities\", \"\",\n\t\t\t\t\tar->fw_capabilities,\n\t\t\t\t\tsizeof(ar->fw_capabilities));\n\t\t\tbreak;\n\t\tcase ATH6KL_FW_IE_PATCH_ADDR:\n\t\t\tif (ie_len != sizeof(*val))\n\t\t\t\tbreak;\n\n\t\t\tval = (__le32 *) data;\n\t\t\tar->hw.dataset_patch_addr = le32_to_cpup(val);\n\n\t\t\tath6kl_dbg(ATH6KL_DBG_BOOT,\n\t\t\t\t   \"found patch address ie 0x%x\\n\",\n\t\t\t\t   ar->hw.dataset_patch_addr);\n\t\t\tbreak;\n\t\tcase ATH6KL_FW_IE_BOARD_ADDR:\n\t\t\tif (ie_len != sizeof(*val))\n\t\t\t\tbreak;\n\n\t\t\tval = (__le32 *) data;\n\t\t\tar->hw.board_addr = le32_to_cpup(val);\n\n\t\t\tath6kl_dbg(ATH6KL_DBG_BOOT,\n\t\t\t\t   \"found board address ie 0x%x\\n\",\n\t\t\t\t   ar->hw.board_addr);\n\t\t\tbreak;\n\t\tcase ATH6KL_FW_IE_VIF_MAX:\n\t\t\tif (ie_len != sizeof(*val))\n\t\t\t\tbreak;\n\n\t\t\tval = (__le32 *) data;\n\t\t\tar->vif_max = min_t(unsigned int, le32_to_cpup(val),\n\t\t\t\t\t    ATH6KL_VIF_MAX);\n\n\t\t\tif (ar->vif_max > 1 && !ar->p2p)\n\t\t\t\tar->max_norm_iface = 2;\n\n\t\t\tath6kl_dbg(ATH6KL_DBG_BOOT,\n\t\t\t\t   \"found vif max ie %d\\n\", ar->vif_max);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tath6kl_dbg(ATH6KL_DBG_BOOT, \"Unknown fw ie: %u\\n\",\n\t\t\t\t   le32_to_cpup(&hdr->id));\n\t\t\tbreak;\n\t\t}\n\n\t\tlen -= ie_len;\n\t\tdata += ie_len;\n\t}\n\n\tret = 0;\nout:\n\trelease_firmware(fw);\n\n\treturn ret;\n}\n\nint ath6kl_init_fetch_firmwares(struct ath6kl *ar)\n{\n\tint ret;\n\n\tret = ath6kl_fetch_board_file(ar);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ath6kl_fetch_testmode_file(ar);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ath6kl_fetch_fw_apin(ar, ATH6KL_FW_API5_FILE);\n\tif (ret == 0) {\n\t\tar->fw_api = 5;\n\t\tgoto out;\n\t}\n\n\tret = ath6kl_fetch_fw_apin(ar, ATH6KL_FW_API4_FILE);\n\tif (ret == 0) {\n\t\tar->fw_api = 4;\n\t\tgoto out;\n\t}\n\n\tret = ath6kl_fetch_fw_apin(ar, ATH6KL_FW_API3_FILE);\n\tif (ret == 0) {\n\t\tar->fw_api = 3;\n\t\tgoto out;\n\t}\n\n\tret = ath6kl_fetch_fw_apin(ar, ATH6KL_FW_API2_FILE);\n\tif (ret == 0) {\n\t\tar->fw_api = 2;\n\t\tgoto out;\n\t}\n\n\tret = ath6kl_fetch_fw_api1(ar);\n\tif (ret)\n\t\treturn ret;\n\n\tar->fw_api = 1;\n\nout:\n\tath6kl_dbg(ATH6KL_DBG_BOOT, \"using fw api %d\\n\", ar->fw_api);\n\n\treturn 0;\n}\n\nstatic int ath6kl_upload_board_file(struct ath6kl *ar)\n{\n\tu32 board_address, board_ext_address, param;\n\tu32 board_data_size, board_ext_data_size;\n\tint ret;\n\n\tif (WARN_ON(ar->fw_board == NULL))\n\t\treturn -ENOENT;\n\n\t \n\tif (ar->hw.board_addr != 0) {\n\t\tboard_address = ar->hw.board_addr;\n\t\tath6kl_bmi_write_hi32(ar, hi_board_data,\n\t\t\t\t      board_address);\n\t} else {\n\t\tret = ath6kl_bmi_read_hi32(ar, hi_board_data, &board_address);\n\t\tif (ret) {\n\t\t\tath6kl_err(\"Failed to get board file target address.\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tret = ath6kl_bmi_read_hi32(ar, hi_board_ext_data, &board_ext_address);\n\tif (ret) {\n\t\tath6kl_err(\"Failed to get extended board file target address.\\n\");\n\t\treturn ret;\n\t}\n\n\tif (ar->target_type == TARGET_TYPE_AR6003 &&\n\t    board_ext_address == 0) {\n\t\tath6kl_err(\"Failed to get board file target address.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (ar->target_type) {\n\tcase TARGET_TYPE_AR6003:\n\t\tboard_data_size = AR6003_BOARD_DATA_SZ;\n\t\tboard_ext_data_size = AR6003_BOARD_EXT_DATA_SZ;\n\t\tif (ar->fw_board_len > (board_data_size + board_ext_data_size))\n\t\t\tboard_ext_data_size = AR6003_BOARD_EXT_DATA_SZ_V2;\n\t\tbreak;\n\tcase TARGET_TYPE_AR6004:\n\t\tboard_data_size = AR6004_BOARD_DATA_SZ;\n\t\tboard_ext_data_size = AR6004_BOARD_EXT_DATA_SZ;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\tif (board_ext_address &&\n\t    ar->fw_board_len == (board_data_size + board_ext_data_size)) {\n\t\t \n\t\tath6kl_dbg(ATH6KL_DBG_BOOT,\n\t\t\t   \"writing extended board data to 0x%x (%d B)\\n\",\n\t\t\t   board_ext_address, board_ext_data_size);\n\n\t\tret = ath6kl_bmi_write(ar, board_ext_address,\n\t\t\t\t       ar->fw_board + board_data_size,\n\t\t\t\t       board_ext_data_size);\n\t\tif (ret) {\n\t\t\tath6kl_err(\"Failed to write extended board data: %d\\n\",\n\t\t\t\t   ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tparam = (board_ext_data_size << 16) | 1;\n\n\t\tath6kl_bmi_write_hi32(ar, hi_board_ext_data_config, param);\n\t}\n\n\tif (ar->fw_board_len < board_data_size) {\n\t\tath6kl_err(\"Too small board file: %zu\\n\", ar->fw_board_len);\n\t\tret = -EINVAL;\n\t\treturn ret;\n\t}\n\n\tath6kl_dbg(ATH6KL_DBG_BOOT, \"writing board file to 0x%x (%d B)\\n\",\n\t\t   board_address, board_data_size);\n\n\tret = ath6kl_bmi_write(ar, board_address, ar->fw_board,\n\t\t\t       board_data_size);\n\n\tif (ret) {\n\t\tath6kl_err(\"Board file bmi write failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif ((ar->version.target_ver == AR6004_HW_1_3_VERSION) ||\n\t    (ar->version.target_ver == AR6004_HW_3_0_VERSION))\n\t\tparam = board_data_size;\n\telse\n\t\tparam = 1;\n\n\tath6kl_bmi_write_hi32(ar, hi_board_data_initialized, param);\n\n\treturn ret;\n}\n\nstatic int ath6kl_upload_otp(struct ath6kl *ar)\n{\n\tu32 address, param;\n\tbool from_hw = false;\n\tint ret;\n\n\tif (ar->fw_otp == NULL)\n\t\treturn 0;\n\n\taddress = ar->hw.app_load_addr;\n\n\tath6kl_dbg(ATH6KL_DBG_BOOT, \"writing otp to 0x%x (%zd B)\\n\", address,\n\t\t   ar->fw_otp_len);\n\n\tret = ath6kl_bmi_fast_download(ar, address, ar->fw_otp,\n\t\t\t\t       ar->fw_otp_len);\n\tif (ret) {\n\t\tath6kl_err(\"Failed to upload OTP file: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = ath6kl_bmi_read_hi32(ar, hi_app_start, &address);\n\n\tif (ret) {\n\t\tath6kl_err(\"Failed to read hi_app_start: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (ar->hw.app_start_override_addr == 0) {\n\t\tar->hw.app_start_override_addr = address;\n\t\tfrom_hw = true;\n\t}\n\n\tath6kl_dbg(ATH6KL_DBG_BOOT, \"app_start_override_addr%s 0x%x\\n\",\n\t\t   from_hw ? \" (from hw)\" : \"\",\n\t\t   ar->hw.app_start_override_addr);\n\n\t \n\tath6kl_dbg(ATH6KL_DBG_BOOT, \"executing OTP at 0x%x\\n\",\n\t\t   ar->hw.app_start_override_addr);\n\tparam = 0;\n\tath6kl_bmi_execute(ar, ar->hw.app_start_override_addr, &param);\n\n\treturn ret;\n}\n\nstatic int ath6kl_upload_firmware(struct ath6kl *ar)\n{\n\tu32 address;\n\tint ret;\n\n\tif (WARN_ON(ar->fw == NULL))\n\t\treturn 0;\n\n\taddress = ar->hw.app_load_addr;\n\n\tath6kl_dbg(ATH6KL_DBG_BOOT, \"writing firmware to 0x%x (%zd B)\\n\",\n\t\t   address, ar->fw_len);\n\n\tret = ath6kl_bmi_fast_download(ar, address, ar->fw, ar->fw_len);\n\n\tif (ret) {\n\t\tath6kl_err(\"Failed to write firmware: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (ar->target_type != TARGET_TYPE_AR6004) {\n\t\taddress = ar->hw.app_start_override_addr;\n\t\tath6kl_bmi_set_app_start(ar, address);\n\t}\n\treturn ret;\n}\n\nstatic int ath6kl_upload_patch(struct ath6kl *ar)\n{\n\tu32 address;\n\tint ret;\n\n\tif (ar->fw_patch == NULL)\n\t\treturn 0;\n\n\taddress = ar->hw.dataset_patch_addr;\n\n\tath6kl_dbg(ATH6KL_DBG_BOOT, \"writing patch to 0x%x (%zd B)\\n\",\n\t\t   address, ar->fw_patch_len);\n\n\tret = ath6kl_bmi_write(ar, address, ar->fw_patch, ar->fw_patch_len);\n\tif (ret) {\n\t\tath6kl_err(\"Failed to write patch file: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tath6kl_bmi_write_hi32(ar, hi_dset_list_head, address);\n\n\treturn 0;\n}\n\nstatic int ath6kl_upload_testscript(struct ath6kl *ar)\n{\n\tu32 address;\n\tint ret;\n\n\tif (ar->testmode != 2)\n\t\treturn 0;\n\n\tif (ar->fw_testscript == NULL)\n\t\treturn 0;\n\n\taddress = ar->hw.testscript_addr;\n\n\tath6kl_dbg(ATH6KL_DBG_BOOT, \"writing testscript to 0x%x (%zd B)\\n\",\n\t\t   address, ar->fw_testscript_len);\n\n\tret = ath6kl_bmi_write(ar, address, ar->fw_testscript,\n\t\tar->fw_testscript_len);\n\tif (ret) {\n\t\tath6kl_err(\"Failed to write testscript file: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tath6kl_bmi_write_hi32(ar, hi_ota_testscript, address);\n\n\tif ((ar->version.target_ver != AR6004_HW_1_3_VERSION) &&\n\t    (ar->version.target_ver != AR6004_HW_3_0_VERSION))\n\t\tath6kl_bmi_write_hi32(ar, hi_end_ram_reserve_sz, 4096);\n\n\tath6kl_bmi_write_hi32(ar, hi_test_apps_related, 1);\n\n\treturn 0;\n}\n\nstatic int ath6kl_init_upload(struct ath6kl *ar)\n{\n\tu32 param, options, sleep, address;\n\tint status = 0;\n\n\tif (ar->target_type != TARGET_TYPE_AR6003 &&\n\t    ar->target_type != TARGET_TYPE_AR6004)\n\t\treturn -EINVAL;\n\n\t \n\taddress = MBOX_BASE_ADDRESS + LOCAL_SCRATCH_ADDRESS;\n\tstatus = ath6kl_bmi_reg_read(ar, address, &param);\n\tif (status)\n\t\treturn status;\n\n\toptions = param;\n\n\tparam |= ATH6KL_OPTION_SLEEP_DISABLE;\n\tstatus = ath6kl_bmi_reg_write(ar, address, param);\n\tif (status)\n\t\treturn status;\n\n\taddress = RTC_BASE_ADDRESS + SYSTEM_SLEEP_ADDRESS;\n\tstatus = ath6kl_bmi_reg_read(ar, address, &param);\n\tif (status)\n\t\treturn status;\n\n\tsleep = param;\n\n\tparam |= SM(SYSTEM_SLEEP_DISABLE, 1);\n\tstatus = ath6kl_bmi_reg_write(ar, address, param);\n\tif (status)\n\t\treturn status;\n\n\tath6kl_dbg(ATH6KL_DBG_TRC, \"old options: %d, old sleep: %d\\n\",\n\t\t   options, sleep);\n\n\t \n\t \n\tif (ar->target_type != TARGET_TYPE_AR6004) {\n\t\tstatus = ath6kl_bmi_reg_write(ar, ATH6KL_ANALOG_PLL_REGISTER,\n\t\t\t\t\t      0xF9104001);\n\n\t\tif (status)\n\t\t\treturn status;\n\n\t\t \n\t\tparam = SM(CPU_CLOCK_STANDARD, 1);\n\n\t\taddress = RTC_BASE_ADDRESS + CPU_CLOCK_ADDRESS;\n\t\tstatus = ath6kl_bmi_reg_write(ar, address, param);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\tparam = 0;\n\taddress = RTC_BASE_ADDRESS + LPO_CAL_ADDRESS;\n\tparam = SM(LPO_CAL_ENABLE, 1);\n\tstatus = ath6kl_bmi_reg_write(ar, address, param);\n\tif (status)\n\t\treturn status;\n\n\t \n\tif (ar->hw.flags & ATH6KL_HW_SDIO_CRC_ERROR_WAR) {\n\t\tath6kl_err(\"temporary war to avoid sdio crc error\\n\");\n\n\t\tparam = 0x28;\n\t\taddress = GPIO_BASE_ADDRESS + GPIO_PIN9_ADDRESS;\n\t\tstatus = ath6kl_bmi_reg_write(ar, address, param);\n\t\tif (status)\n\t\t\treturn status;\n\n\t\tparam = 0x20;\n\n\t\taddress = GPIO_BASE_ADDRESS + GPIO_PIN10_ADDRESS;\n\t\tstatus = ath6kl_bmi_reg_write(ar, address, param);\n\t\tif (status)\n\t\t\treturn status;\n\n\t\taddress = GPIO_BASE_ADDRESS + GPIO_PIN11_ADDRESS;\n\t\tstatus = ath6kl_bmi_reg_write(ar, address, param);\n\t\tif (status)\n\t\t\treturn status;\n\n\t\taddress = GPIO_BASE_ADDRESS + GPIO_PIN12_ADDRESS;\n\t\tstatus = ath6kl_bmi_reg_write(ar, address, param);\n\t\tif (status)\n\t\t\treturn status;\n\n\t\taddress = GPIO_BASE_ADDRESS + GPIO_PIN13_ADDRESS;\n\t\tstatus = ath6kl_bmi_reg_write(ar, address, param);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\t \n\tstatus = ath6kl_upload_board_file(ar);\n\tif (status)\n\t\treturn status;\n\n\t \n\tstatus = ath6kl_upload_otp(ar);\n\tif (status)\n\t\treturn status;\n\n\t \n\tstatus = ath6kl_upload_firmware(ar);\n\tif (status)\n\t\treturn status;\n\n\tstatus = ath6kl_upload_patch(ar);\n\tif (status)\n\t\treturn status;\n\n\t \n\tstatus = ath6kl_upload_testscript(ar);\n\tif (status)\n\t\treturn status;\n\n\t \n\taddress = RTC_BASE_ADDRESS + SYSTEM_SLEEP_ADDRESS;\n\tstatus = ath6kl_bmi_reg_write(ar, address, sleep);\n\tif (status)\n\t\treturn status;\n\n\taddress = MBOX_BASE_ADDRESS + LOCAL_SCRATCH_ADDRESS;\n\tparam = options | 0x20;\n\tstatus = ath6kl_bmi_reg_write(ar, address, param);\n\tif (status)\n\t\treturn status;\n\n\treturn status;\n}\n\nint ath6kl_init_hw_params(struct ath6kl *ar)\n{\n\tconst struct ath6kl_hw *hw;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(hw_list); i++) {\n\t\thw = &hw_list[i];\n\n\t\tif (hw->id == ar->version.target_ver)\n\t\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(hw_list)) {\n\t\tath6kl_err(\"Unsupported hardware version: 0x%x\\n\",\n\t\t\t   ar->version.target_ver);\n\t\treturn -EINVAL;\n\t}\n\n\tar->hw = *hw;\n\n\tath6kl_dbg(ATH6KL_DBG_BOOT,\n\t\t   \"target_ver 0x%x target_type 0x%x dataset_patch 0x%x app_load_addr 0x%x\\n\",\n\t\t   ar->version.target_ver, ar->target_type,\n\t\t   ar->hw.dataset_patch_addr, ar->hw.app_load_addr);\n\tath6kl_dbg(ATH6KL_DBG_BOOT,\n\t\t   \"app_start_override_addr 0x%x board_ext_data_addr 0x%x reserved_ram_size 0x%x\",\n\t\t   ar->hw.app_start_override_addr, ar->hw.board_ext_data_addr,\n\t\t   ar->hw.reserved_ram_size);\n\tath6kl_dbg(ATH6KL_DBG_BOOT,\n\t\t   \"refclk_hz %d uarttx_pin %d\",\n\t\t   ar->hw.refclk_hz, ar->hw.uarttx_pin);\n\n\treturn 0;\n}\n\nstatic const char *ath6kl_init_get_hif_name(enum ath6kl_hif_type type)\n{\n\tswitch (type) {\n\tcase ATH6KL_HIF_TYPE_SDIO:\n\t\treturn \"sdio\";\n\tcase ATH6KL_HIF_TYPE_USB:\n\t\treturn \"usb\";\n\t}\n\n\treturn NULL;\n}\n\n\nstatic const struct fw_capa_str_map {\n\tint id;\n\tconst char *name;\n} fw_capa_map[] = {\n\t{ ATH6KL_FW_CAPABILITY_HOST_P2P, \"host-p2p\" },\n\t{ ATH6KL_FW_CAPABILITY_SCHED_SCAN, \"sched-scan\" },\n\t{ ATH6KL_FW_CAPABILITY_STA_P2PDEV_DUPLEX, \"sta-p2pdev-duplex\" },\n\t{ ATH6KL_FW_CAPABILITY_INACTIVITY_TIMEOUT, \"inactivity-timeout\" },\n\t{ ATH6KL_FW_CAPABILITY_RSN_CAP_OVERRIDE, \"rsn-cap-override\" },\n\t{ ATH6KL_FW_CAPABILITY_WOW_MULTICAST_FILTER, \"wow-mc-filter\" },\n\t{ ATH6KL_FW_CAPABILITY_BMISS_ENHANCE, \"bmiss-enhance\" },\n\t{ ATH6KL_FW_CAPABILITY_SCHED_SCAN_MATCH_LIST, \"sscan-match-list\" },\n\t{ ATH6KL_FW_CAPABILITY_RSSI_SCAN_THOLD, \"rssi-scan-thold\" },\n\t{ ATH6KL_FW_CAPABILITY_CUSTOM_MAC_ADDR, \"custom-mac-addr\" },\n\t{ ATH6KL_FW_CAPABILITY_TX_ERR_NOTIFY, \"tx-err-notify\" },\n\t{ ATH6KL_FW_CAPABILITY_REGDOMAIN, \"regdomain\" },\n\t{ ATH6KL_FW_CAPABILITY_SCHED_SCAN_V2, \"sched-scan-v2\" },\n\t{ ATH6KL_FW_CAPABILITY_HEART_BEAT_POLL, \"hb-poll\" },\n\t{ ATH6KL_FW_CAPABILITY_64BIT_RATES, \"64bit-rates\" },\n\t{ ATH6KL_FW_CAPABILITY_AP_INACTIVITY_MINS, \"ap-inactivity-mins\" },\n\t{ ATH6KL_FW_CAPABILITY_MAP_LP_ENDPOINT, \"map-lp-endpoint\" },\n\t{ ATH6KL_FW_CAPABILITY_RATETABLE_MCS15, \"ratetable-mcs15\" },\n\t{ ATH6KL_FW_CAPABILITY_NO_IP_CHECKSUM, \"no-ip-checksum\" },\n};\n\nstatic const char *ath6kl_init_get_fw_capa_name(unsigned int id)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(fw_capa_map); i++) {\n\t\tif (fw_capa_map[i].id == id)\n\t\t\treturn fw_capa_map[i].name;\n\t}\n\n\treturn \"<unknown>\";\n}\n\nstatic void ath6kl_init_get_fwcaps(struct ath6kl *ar, char *buf, size_t buf_len)\n{\n\tu8 *data = (u8 *) ar->fw_capabilities;\n\tsize_t trunc_len, len = 0;\n\tint i, index, bit;\n\tchar *trunc = \"...\";\n\n\tfor (i = 0; i < ATH6KL_FW_CAPABILITY_MAX; i++) {\n\t\tindex = i / 8;\n\t\tbit = i % 8;\n\n\t\tif (index >= sizeof(ar->fw_capabilities) * 4)\n\t\t\tbreak;\n\n\t\tif (buf_len - len < 4) {\n\t\t\tath6kl_warn(\"firmware capability buffer too small!\\n\");\n\n\t\t\t \n\t\t\ttrunc_len = strlen(trunc) + 1;\n\t\t\tstrncpy(buf + buf_len - trunc_len, trunc, trunc_len);\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (data[index] & (1 << bit)) {\n\t\t\tlen += scnprintf(buf + len, buf_len - len, \"%s,\",\n\t\t\t\t\t    ath6kl_init_get_fw_capa_name(i));\n\t\t}\n\t}\n\n\t \n\tif (len > 0)\n\t\tlen--;\n\n\tbuf[len] = '\\0';\n}\n\nstatic int ath6kl_init_hw_reset(struct ath6kl *ar)\n{\n\tath6kl_dbg(ATH6KL_DBG_BOOT, \"cold resetting the device\");\n\n\treturn ath6kl_diag_write32(ar, RESET_CONTROL_ADDRESS,\n\t\t\t\t   cpu_to_le32(RESET_CONTROL_COLD_RST));\n}\n\nstatic int __ath6kl_init_hw_start(struct ath6kl *ar)\n{\n\tlong timeleft;\n\tint ret, i;\n\tchar buf[200];\n\n\tath6kl_dbg(ATH6KL_DBG_BOOT, \"hw start\\n\");\n\n\tret = ath6kl_hif_power_on(ar);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ath6kl_configure_target(ar);\n\tif (ret)\n\t\tgoto err_power_off;\n\n\tret = ath6kl_init_upload(ar);\n\tif (ret)\n\t\tgoto err_power_off;\n\n\t \n\tret = ath6kl_bmi_done(ar);\n\tif (ret)\n\t\tgoto err_power_off;\n\n\t \n\tret = ath6kl_htc_wait_target(ar->htc_target);\n\n\tif (ret == -ETIMEDOUT) {\n\t\t \n\t\tath6kl_warn(\"htc wait target timed out, resetting device\\n\");\n\t\tath6kl_init_hw_reset(ar);\n\t\tgoto err_power_off;\n\t} else if (ret) {\n\t\tath6kl_err(\"htc wait target failed: %d\\n\", ret);\n\t\tgoto err_power_off;\n\t}\n\n\tret = ath6kl_init_service_ep(ar);\n\tif (ret) {\n\t\tath6kl_err(\"Endpoint service initialization failed: %d\\n\", ret);\n\t\tgoto err_cleanup_scatter;\n\t}\n\n\t \n\tath6kl_htc_credit_setup(ar->htc_target, &ar->credit_state_info);\n\n\t \n\tret = ath6kl_htc_start(ar->htc_target);\n\tif (ret) {\n\t\t \n\t\tath6kl_cookie_cleanup(ar);\n\t\tgoto err_cleanup_scatter;\n\t}\n\n\t \n\ttimeleft = wait_event_interruptible_timeout(ar->event_wq,\n\t\t\t\t\t\t    test_bit(WMI_READY,\n\t\t\t\t\t\t\t     &ar->flag),\n\t\t\t\t\t\t    WMI_TIMEOUT);\n\tif (timeleft <= 0) {\n\t\tclear_bit(WMI_READY, &ar->flag);\n\t\tath6kl_err(\"wmi is not ready or wait was interrupted: %ld\\n\",\n\t\t\t   timeleft);\n\t\tret = -EIO;\n\t\tgoto err_htc_stop;\n\t}\n\n\tath6kl_dbg(ATH6KL_DBG_BOOT, \"firmware booted\\n\");\n\n\tif (test_and_clear_bit(FIRST_BOOT, &ar->flag)) {\n\t\tath6kl_info(\"%s %s fw %s api %d%s\\n\",\n\t\t\t    ar->hw.name,\n\t\t\t    ath6kl_init_get_hif_name(ar->hif_type),\n\t\t\t    ar->wiphy->fw_version,\n\t\t\t    ar->fw_api,\n\t\t\t    test_bit(TESTMODE, &ar->flag) ? \" testmode\" : \"\");\n\t\tath6kl_init_get_fwcaps(ar, buf, sizeof(buf));\n\t\tath6kl_info(\"firmware supports: %s\\n\", buf);\n\t}\n\n\tif (ar->version.abi_ver != ATH6KL_ABI_VERSION) {\n\t\tath6kl_err(\"abi version mismatch: host(0x%x), target(0x%x)\\n\",\n\t\t\t   ATH6KL_ABI_VERSION, ar->version.abi_ver);\n\t\tret = -EIO;\n\t\tgoto err_htc_stop;\n\t}\n\n\tath6kl_dbg(ATH6KL_DBG_TRC, \"%s: wmi is ready\\n\", __func__);\n\n\t \n\t \n\tif ((ath6kl_set_host_app_area(ar)) != 0)\n\t\tath6kl_err(\"unable to set the host app area\\n\");\n\n\tfor (i = 0; i < ar->vif_max; i++) {\n\t\tret = ath6kl_target_config_wlan_params(ar, i);\n\t\tif (ret)\n\t\t\tgoto err_htc_stop;\n\t}\n\n\treturn 0;\n\nerr_htc_stop:\n\tath6kl_htc_stop(ar->htc_target);\nerr_cleanup_scatter:\n\tath6kl_hif_cleanup_scatter(ar);\nerr_power_off:\n\tath6kl_hif_power_off(ar);\n\n\treturn ret;\n}\n\nint ath6kl_init_hw_start(struct ath6kl *ar)\n{\n\tint err;\n\n\terr = __ath6kl_init_hw_start(ar);\n\tif (err)\n\t\treturn err;\n\tar->state = ATH6KL_STATE_ON;\n\treturn 0;\n}\n\nstatic int __ath6kl_init_hw_stop(struct ath6kl *ar)\n{\n\tint ret;\n\n\tath6kl_dbg(ATH6KL_DBG_BOOT, \"hw stop\\n\");\n\n\tath6kl_htc_stop(ar->htc_target);\n\n\tath6kl_hif_stop(ar);\n\n\tath6kl_bmi_reset(ar);\n\n\tret = ath6kl_hif_power_off(ar);\n\tif (ret)\n\t\tath6kl_warn(\"failed to power off hif: %d\\n\", ret);\n\n\treturn 0;\n}\n\nint ath6kl_init_hw_stop(struct ath6kl *ar)\n{\n\tint err;\n\n\terr = __ath6kl_init_hw_stop(ar);\n\tif (err)\n\t\treturn err;\n\tar->state = ATH6KL_STATE_OFF;\n\treturn 0;\n}\n\nvoid ath6kl_init_hw_restart(struct ath6kl *ar)\n{\n\tclear_bit(WMI_READY, &ar->flag);\n\n\tath6kl_cfg80211_stop_all(ar);\n\n\tif (__ath6kl_init_hw_stop(ar)) {\n\t\tath6kl_dbg(ATH6KL_DBG_RECOVERY, \"Failed to stop during fw error recovery\\n\");\n\t\treturn;\n\t}\n\n\tif (__ath6kl_init_hw_start(ar)) {\n\t\tath6kl_dbg(ATH6KL_DBG_RECOVERY, \"Failed to restart during fw error recovery\\n\");\n\t\treturn;\n\t}\n}\n\nvoid ath6kl_stop_txrx(struct ath6kl *ar)\n{\n\tstruct ath6kl_vif *vif, *tmp_vif;\n\tint i;\n\n\tset_bit(DESTROY_IN_PROGRESS, &ar->flag);\n\n\tif (down_interruptible(&ar->sem)) {\n\t\tath6kl_err(\"down_interruptible failed\\n\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < AP_MAX_NUM_STA; i++)\n\t\taggr_reset_state(ar->sta_list[i].aggr_conn);\n\n\tspin_lock_bh(&ar->list_lock);\n\tlist_for_each_entry_safe(vif, tmp_vif, &ar->vif_list, list) {\n\t\tlist_del(&vif->list);\n\t\tspin_unlock_bh(&ar->list_lock);\n\t\tath6kl_cfg80211_vif_stop(vif, test_bit(WMI_READY, &ar->flag));\n\t\trtnl_lock();\n\t\twiphy_lock(ar->wiphy);\n\t\tath6kl_cfg80211_vif_cleanup(vif);\n\t\twiphy_unlock(ar->wiphy);\n\t\trtnl_unlock();\n\t\tspin_lock_bh(&ar->list_lock);\n\t}\n\tspin_unlock_bh(&ar->list_lock);\n\n\tclear_bit(WMI_READY, &ar->flag);\n\n\tif (ar->fw_recovery.enable)\n\t\tdel_timer_sync(&ar->fw_recovery.hb_timer);\n\n\t \n\tath6kl_wmi_shutdown(ar->wmi);\n\n\tclear_bit(WMI_ENABLED, &ar->flag);\n\tif (ar->htc_target) {\n\t\tath6kl_dbg(ATH6KL_DBG_TRC, \"%s: shut down htc\\n\", __func__);\n\t\tath6kl_htc_stop(ar->htc_target);\n\t}\n\n\t \n\tath6kl_init_hw_reset(ar);\n\n\tup(&ar->sem);\n}\nEXPORT_SYMBOL(ath6kl_stop_txrx);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}