{
  "module_name": "main.c",
  "hash_id": "092107adc0d4762f2389f15b7af88ed06db8df7289155e572c669003a7271776",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath6kl/main.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include \"core.h\"\n#include \"hif-ops.h\"\n#include \"cfg80211.h\"\n#include \"target.h\"\n#include \"debug.h\"\n\nstruct ath6kl_sta *ath6kl_find_sta(struct ath6kl_vif *vif, u8 *node_addr)\n{\n\tstruct ath6kl *ar = vif->ar;\n\tstruct ath6kl_sta *conn = NULL;\n\tu8 i, max_conn;\n\n\tif (is_zero_ether_addr(node_addr))\n\t\treturn NULL;\n\n\tmax_conn = (vif->nw_type == AP_NETWORK) ? AP_MAX_NUM_STA : 0;\n\n\tfor (i = 0; i < max_conn; i++) {\n\t\tif (memcmp(node_addr, ar->sta_list[i].mac, ETH_ALEN) == 0) {\n\t\t\tconn = &ar->sta_list[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn conn;\n}\n\nstruct ath6kl_sta *ath6kl_find_sta_by_aid(struct ath6kl *ar, u8 aid)\n{\n\tstruct ath6kl_sta *conn = NULL;\n\tu8 ctr;\n\n\tfor (ctr = 0; ctr < AP_MAX_NUM_STA; ctr++) {\n\t\tif (ar->sta_list[ctr].aid == aid) {\n\t\t\tconn = &ar->sta_list[ctr];\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn conn;\n}\n\nstatic void ath6kl_add_new_sta(struct ath6kl_vif *vif, u8 *mac, u16 aid,\n\t\t\t       u8 *wpaie, size_t ielen, u8 keymgmt,\n\t\t\t       u8 ucipher, u8 auth, u8 apsd_info)\n{\n\tstruct ath6kl *ar = vif->ar;\n\tstruct ath6kl_sta *sta;\n\tu8 free_slot;\n\n\tfree_slot = aid - 1;\n\n\tsta = &ar->sta_list[free_slot];\n\tmemcpy(sta->mac, mac, ETH_ALEN);\n\tif (ielen <= ATH6KL_MAX_IE)\n\t\tmemcpy(sta->wpa_ie, wpaie, ielen);\n\tsta->aid = aid;\n\tsta->keymgmt = keymgmt;\n\tsta->ucipher = ucipher;\n\tsta->auth = auth;\n\tsta->apsd_info = apsd_info;\n\n\tar->sta_list_index = ar->sta_list_index | (1 << free_slot);\n\tar->ap_stats.sta[free_slot].aid = cpu_to_le32(aid);\n\taggr_conn_init(vif, vif->aggr_cntxt, sta->aggr_conn);\n}\n\nstatic void ath6kl_sta_cleanup(struct ath6kl *ar, u8 i)\n{\n\tstruct ath6kl_sta *sta = &ar->sta_list[i];\n\tstruct ath6kl_mgmt_buff *entry, *tmp;\n\n\t \n\tspin_lock_bh(&sta->psq_lock);\n\tskb_queue_purge(&sta->psq);\n\tskb_queue_purge(&sta->apsdq);\n\n\tif (sta->mgmt_psq_len != 0) {\n\t\tlist_for_each_entry_safe(entry, tmp, &sta->mgmt_psq, list) {\n\t\t\tkfree(entry);\n\t\t}\n\t\tINIT_LIST_HEAD(&sta->mgmt_psq);\n\t\tsta->mgmt_psq_len = 0;\n\t}\n\n\tspin_unlock_bh(&sta->psq_lock);\n\n\tmemset(&ar->ap_stats.sta[sta->aid - 1], 0,\n\t       sizeof(struct wmi_per_sta_stat));\n\teth_zero_addr(sta->mac);\n\tmemset(sta->wpa_ie, 0, ATH6KL_MAX_IE);\n\tsta->aid = 0;\n\tsta->sta_flags = 0;\n\n\tar->sta_list_index = ar->sta_list_index & ~(1 << i);\n\taggr_reset_state(sta->aggr_conn);\n}\n\nstatic u8 ath6kl_remove_sta(struct ath6kl *ar, u8 *mac, u16 reason)\n{\n\tu8 i, removed = 0;\n\n\tif (is_zero_ether_addr(mac))\n\t\treturn removed;\n\n\tif (is_broadcast_ether_addr(mac)) {\n\t\tath6kl_dbg(ATH6KL_DBG_TRC, \"deleting all station\\n\");\n\n\t\tfor (i = 0; i < AP_MAX_NUM_STA; i++) {\n\t\t\tif (!is_zero_ether_addr(ar->sta_list[i].mac)) {\n\t\t\t\tath6kl_sta_cleanup(ar, i);\n\t\t\t\tremoved = 1;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < AP_MAX_NUM_STA; i++) {\n\t\t\tif (memcmp(ar->sta_list[i].mac, mac, ETH_ALEN) == 0) {\n\t\t\t\tath6kl_dbg(ATH6KL_DBG_TRC,\n\t\t\t\t\t   \"deleting station %pM aid=%d reason=%d\\n\",\n\t\t\t\t\t   mac, ar->sta_list[i].aid, reason);\n\t\t\t\tath6kl_sta_cleanup(ar, i);\n\t\t\t\tremoved = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn removed;\n}\n\nenum htc_endpoint_id ath6kl_ac2_endpoint_id(void *devt, u8 ac)\n{\n\tstruct ath6kl *ar = devt;\n\treturn ar->ac2ep_map[ac];\n}\n\nstruct ath6kl_cookie *ath6kl_alloc_cookie(struct ath6kl *ar)\n{\n\tstruct ath6kl_cookie *cookie;\n\n\tcookie = ar->cookie_list;\n\tif (cookie != NULL) {\n\t\tar->cookie_list = cookie->arc_list_next;\n\t\tar->cookie_count--;\n\t}\n\n\treturn cookie;\n}\n\nvoid ath6kl_cookie_init(struct ath6kl *ar)\n{\n\tu32 i;\n\n\tar->cookie_list = NULL;\n\tar->cookie_count = 0;\n\n\tmemset(ar->cookie_mem, 0, sizeof(ar->cookie_mem));\n\n\tfor (i = 0; i < MAX_COOKIE_NUM; i++)\n\t\tath6kl_free_cookie(ar, &ar->cookie_mem[i]);\n}\n\nvoid ath6kl_cookie_cleanup(struct ath6kl *ar)\n{\n\tar->cookie_list = NULL;\n\tar->cookie_count = 0;\n}\n\nvoid ath6kl_free_cookie(struct ath6kl *ar, struct ath6kl_cookie *cookie)\n{\n\t \n\n\tif (!ar || !cookie)\n\t\treturn;\n\n\tcookie->arc_list_next = ar->cookie_list;\n\tar->cookie_list = cookie;\n\tar->cookie_count++;\n}\n\n \nint ath6kl_diag_read32(struct ath6kl *ar, u32 address, u32 *value)\n{\n\tint ret;\n\n\tret = ath6kl_hif_diag_read32(ar, address, value);\n\tif (ret) {\n\t\tath6kl_warn(\"failed to read32 through diagnose window: %d\\n\",\n\t\t\t    ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nint ath6kl_diag_write32(struct ath6kl *ar, u32 address, __le32 value)\n{\n\tint ret;\n\n\tret = ath6kl_hif_diag_write32(ar, address, value);\n\n\tif (ret) {\n\t\tath6kl_err(\"failed to write 0x%x during diagnose window to 0x%x\\n\",\n\t\t\t   address, value);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint ath6kl_diag_read(struct ath6kl *ar, u32 address, void *data, u32 length)\n{\n\tu32 count, *buf = data;\n\tint ret;\n\n\tif (WARN_ON(length % 4))\n\t\treturn -EINVAL;\n\n\tfor (count = 0; count < length / 4; count++, address += 4) {\n\t\tret = ath6kl_diag_read32(ar, address, &buf[count]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint ath6kl_diag_write(struct ath6kl *ar, u32 address, void *data, u32 length)\n{\n\tu32 count;\n\t__le32 *buf = data;\n\tint ret;\n\n\tif (WARN_ON(length % 4))\n\t\treturn -EINVAL;\n\n\tfor (count = 0; count < length / 4; count++, address += 4) {\n\t\tret = ath6kl_diag_write32(ar, address, buf[count]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint ath6kl_read_fwlogs(struct ath6kl *ar)\n{\n\tstruct ath6kl_dbglog_hdr debug_hdr;\n\tstruct ath6kl_dbglog_buf debug_buf;\n\tu32 address, length, firstbuf, debug_hdr_addr;\n\tint ret, loop;\n\tu8 *buf;\n\n\tbuf = kmalloc(ATH6KL_FWLOG_PAYLOAD_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\taddress = TARG_VTOP(ar->target_type,\n\t\t\t    ath6kl_get_hi_item_addr(ar,\n\t\t\t\t\t\t    HI_ITEM(hi_dbglog_hdr)));\n\n\tret = ath6kl_diag_read32(ar, address, &debug_hdr_addr);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tif (debug_hdr_addr == 0) {\n\t\tath6kl_warn(\"Invalid address for debug_hdr_addr\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\taddress = TARG_VTOP(ar->target_type, debug_hdr_addr);\n\tret = ath6kl_diag_read(ar, address, &debug_hdr, sizeof(debug_hdr));\n\tif (ret)\n\t\tgoto out;\n\n\taddress = TARG_VTOP(ar->target_type,\n\t\t\t    le32_to_cpu(debug_hdr.dbuf_addr));\n\tfirstbuf = address;\n\tret = ath6kl_diag_read(ar, address, &debug_buf, sizeof(debug_buf));\n\tif (ret)\n\t\tgoto out;\n\n\tloop = 100;\n\n\tdo {\n\t\taddress = TARG_VTOP(ar->target_type,\n\t\t\t\t    le32_to_cpu(debug_buf.buffer_addr));\n\t\tlength = le32_to_cpu(debug_buf.length);\n\n\t\tif (length != 0 && (le32_to_cpu(debug_buf.length) <=\n\t\t\t\t    le32_to_cpu(debug_buf.bufsize))) {\n\t\t\tlength = ALIGN(length, 4);\n\n\t\t\tret = ath6kl_diag_read(ar, address,\n\t\t\t\t\t       buf, length);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\tath6kl_debug_fwlog_event(ar, buf, length);\n\t\t}\n\n\t\taddress = TARG_VTOP(ar->target_type,\n\t\t\t\t    le32_to_cpu(debug_buf.next));\n\t\tret = ath6kl_diag_read(ar, address, &debug_buf,\n\t\t\t\t       sizeof(debug_buf));\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tloop--;\n\n\t\tif (WARN_ON(loop == 0)) {\n\t\t\tret = -ETIMEDOUT;\n\t\t\tgoto out;\n\t\t}\n\t} while (address != firstbuf);\n\nout:\n\tkfree(buf);\n\n\treturn ret;\n}\n\nstatic void ath6kl_install_static_wep_keys(struct ath6kl_vif *vif)\n{\n\tu8 index;\n\tu8 keyusage;\n\n\tfor (index = 0; index <= WMI_MAX_KEY_INDEX; index++) {\n\t\tif (vif->wep_key_list[index].key_len) {\n\t\t\tkeyusage = GROUP_USAGE;\n\t\t\tif (index == vif->def_txkey_index)\n\t\t\t\tkeyusage |= TX_USAGE;\n\n\t\t\tath6kl_wmi_addkey_cmd(vif->ar->wmi, vif->fw_vif_idx,\n\t\t\t\t\t      index,\n\t\t\t\t\t      WEP_CRYPT,\n\t\t\t\t\t      keyusage,\n\t\t\t\t\t      vif->wep_key_list[index].key_len,\n\t\t\t\t\t      NULL, 0,\n\t\t\t\t\t      vif->wep_key_list[index].key,\n\t\t\t\t\t      KEY_OP_INIT_VAL, NULL,\n\t\t\t\t\t      NO_SYNC_WMIFLAG);\n\t\t}\n\t}\n}\n\nvoid ath6kl_connect_ap_mode_bss(struct ath6kl_vif *vif, u16 channel)\n{\n\tstruct ath6kl *ar = vif->ar;\n\tstruct ath6kl_req_key *ik;\n\tint res;\n\tu8 key_rsc[ATH6KL_KEY_SEQ_LEN];\n\n\tik = &ar->ap_mode_bkey;\n\n\tath6kl_dbg(ATH6KL_DBG_WLAN_CFG, \"AP mode started on %u MHz\\n\", channel);\n\n\tswitch (vif->auth_mode) {\n\tcase NONE_AUTH:\n\t\tif (vif->prwise_crypto == WEP_CRYPT)\n\t\t\tath6kl_install_static_wep_keys(vif);\n\t\tif (!ik->valid || ik->key_type != WAPI_CRYPT)\n\t\t\tbreak;\n\t\t \n\t\tfallthrough;\n\tcase WPA_PSK_AUTH:\n\tcase WPA2_PSK_AUTH:\n\tcase (WPA_PSK_AUTH | WPA2_PSK_AUTH):\n\t\tif (!ik->valid)\n\t\t\tbreak;\n\n\t\tath6kl_dbg(ATH6KL_DBG_WLAN_CFG,\n\t\t\t   \"Delayed addkey for the initial group key for AP mode\\n\");\n\t\tmemset(key_rsc, 0, sizeof(key_rsc));\n\t\tres = ath6kl_wmi_addkey_cmd(\n\t\t\tar->wmi, vif->fw_vif_idx, ik->key_index, ik->key_type,\n\t\t\tGROUP_USAGE, ik->key_len, key_rsc, ATH6KL_KEY_SEQ_LEN,\n\t\t\tik->key,\n\t\t\tKEY_OP_INIT_VAL, NULL, SYNC_BOTH_WMIFLAG);\n\t\tif (res) {\n\t\t\tath6kl_dbg(ATH6KL_DBG_WLAN_CFG,\n\t\t\t\t   \"Delayed addkey failed: %d\\n\", res);\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (ar->last_ch != channel)\n\t\t \n\t\tath6kl_cfg80211_ch_switch_notify(vif, channel, WMI_11G_HT20);\n\n\tath6kl_wmi_bssfilter_cmd(ar->wmi, vif->fw_vif_idx, NONE_BSS_FILTER, 0);\n\tset_bit(CONNECTED, &vif->flags);\n\tnetif_carrier_on(vif->ndev);\n}\n\nvoid ath6kl_connect_ap_mode_sta(struct ath6kl_vif *vif, u16 aid, u8 *mac_addr,\n\t\t\t\tu8 keymgmt, u8 ucipher, u8 auth,\n\t\t\t\tu8 assoc_req_len, u8 *assoc_info, u8 apsd_info)\n{\n\tu8 *ies = NULL, *wpa_ie = NULL, *pos;\n\tsize_t ies_len = 0;\n\tstruct station_info *sinfo;\n\n\tath6kl_dbg(ATH6KL_DBG_TRC, \"new station %pM aid=%d\\n\", mac_addr, aid);\n\n\tif (aid < 1 || aid > AP_MAX_NUM_STA)\n\t\treturn;\n\n\tif (assoc_req_len > sizeof(struct ieee80211_hdr_3addr)) {\n\t\tstruct ieee80211_mgmt *mgmt =\n\t\t\t(struct ieee80211_mgmt *) assoc_info;\n\t\tif (ieee80211_is_assoc_req(mgmt->frame_control) &&\n\t\t    assoc_req_len >= sizeof(struct ieee80211_hdr_3addr) +\n\t\t    sizeof(mgmt->u.assoc_req)) {\n\t\t\ties = mgmt->u.assoc_req.variable;\n\t\t\ties_len = assoc_info + assoc_req_len - ies;\n\t\t} else if (ieee80211_is_reassoc_req(mgmt->frame_control) &&\n\t\t\t   assoc_req_len >= sizeof(struct ieee80211_hdr_3addr)\n\t\t\t   + sizeof(mgmt->u.reassoc_req)) {\n\t\t\ties = mgmt->u.reassoc_req.variable;\n\t\t\ties_len = assoc_info + assoc_req_len - ies;\n\t\t}\n\t}\n\n\tpos = ies;\n\twhile (pos && pos + 1 < ies + ies_len) {\n\t\tif (pos + 2 + pos[1] > ies + ies_len)\n\t\t\tbreak;\n\t\tif (pos[0] == WLAN_EID_RSN)\n\t\t\twpa_ie = pos;  \n\t\telse if (pos[0] == WLAN_EID_VENDOR_SPECIFIC &&\n\t\t\t pos[1] >= 4 &&\n\t\t\t pos[2] == 0x00 && pos[3] == 0x50 && pos[4] == 0xf2) {\n\t\t\tif (pos[5] == 0x01)\n\t\t\t\twpa_ie = pos;  \n\t\t\telse if (pos[5] == 0x04) {\n\t\t\t\twpa_ie = pos;  \n\t\t\t\tbreak;  \n\t\t\t}\n\t\t} else if (pos[0] == 0x44 && wpa_ie == NULL) {\n\t\t\t \n\t\t\twpa_ie = pos;  \n\t\t\tbreak;\n\t\t}\n\t\tpos += 2 + pos[1];\n\t}\n\n\tath6kl_add_new_sta(vif, mac_addr, aid, wpa_ie,\n\t\t\t   wpa_ie ? 2 + wpa_ie[1] : 0,\n\t\t\t   keymgmt, ucipher, auth, apsd_info);\n\n\t \n\tsinfo = kzalloc(sizeof(*sinfo), GFP_KERNEL);\n\tif (!sinfo)\n\t\treturn;\n\n\t \n\n\tsinfo->assoc_req_ies = ies;\n\tsinfo->assoc_req_ies_len = ies_len;\n\n\tcfg80211_new_sta(vif->ndev, mac_addr, sinfo, GFP_KERNEL);\n\n\tnetif_wake_queue(vif->ndev);\n\n\tkfree(sinfo);\n}\n\nvoid disconnect_timer_handler(struct timer_list *t)\n{\n\tstruct ath6kl_vif *vif = from_timer(vif, t, disconnect_timer);\n\n\tath6kl_init_profile_info(vif);\n\tath6kl_disconnect(vif);\n}\n\nvoid ath6kl_disconnect(struct ath6kl_vif *vif)\n{\n\tif (test_bit(CONNECTED, &vif->flags) ||\n\t    test_bit(CONNECT_PEND, &vif->flags)) {\n\t\tath6kl_wmi_disconnect_cmd(vif->ar->wmi, vif->fw_vif_idx);\n\t\t \n\t\tclear_bit(CONNECT_PEND, &vif->flags);\n\t}\n}\n\n \n\nvoid ath6kl_ready_event(void *devt, u8 *datap, u32 sw_ver, u32 abi_ver,\n\t\t\tenum wmi_phy_cap cap)\n{\n\tstruct ath6kl *ar = devt;\n\n\tmemcpy(ar->mac_addr, datap, ETH_ALEN);\n\n\tath6kl_dbg(ATH6KL_DBG_BOOT,\n\t\t   \"ready event mac addr %pM sw_ver 0x%x abi_ver 0x%x cap 0x%x\\n\",\n\t\t   ar->mac_addr, sw_ver, abi_ver, cap);\n\n\tar->version.wlan_ver = sw_ver;\n\tar->version.abi_ver = abi_ver;\n\tar->hw.cap = cap;\n\n\tif (strlen(ar->wiphy->fw_version) == 0) {\n\t\tsnprintf(ar->wiphy->fw_version,\n\t\t\t sizeof(ar->wiphy->fw_version),\n\t\t\t \"%u.%u.%u.%u\",\n\t\t\t (ar->version.wlan_ver & 0xf0000000) >> 28,\n\t\t\t (ar->version.wlan_ver & 0x0f000000) >> 24,\n\t\t\t (ar->version.wlan_ver & 0x00ff0000) >> 16,\n\t\t\t (ar->version.wlan_ver & 0x0000ffff));\n\t}\n\n\t \n\tset_bit(WMI_READY, &ar->flag);\n\twake_up(&ar->event_wq);\n}\n\nvoid ath6kl_scan_complete_evt(struct ath6kl_vif *vif, int status)\n{\n\tstruct ath6kl *ar = vif->ar;\n\tbool aborted = false;\n\n\tif (status != WMI_SCAN_STATUS_SUCCESS)\n\t\taborted = true;\n\n\tath6kl_cfg80211_scan_complete_event(vif, aborted);\n\n\tif (!ar->usr_bss_filter) {\n\t\tclear_bit(CLEAR_BSSFILTER_ON_BEACON, &vif->flags);\n\t\tath6kl_wmi_bssfilter_cmd(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t\t NONE_BSS_FILTER, 0);\n\t}\n\n\tath6kl_dbg(ATH6KL_DBG_WLAN_CFG, \"scan complete: %d\\n\", status);\n}\n\nstatic int ath6kl_commit_ch_switch(struct ath6kl_vif *vif, u16 channel)\n{\n\tstruct ath6kl *ar = vif->ar;\n\n\tvif->profile.ch = cpu_to_le16(channel);\n\n\tswitch (vif->nw_type) {\n\tcase AP_NETWORK:\n\t\t \n\t\tif (vif->rsn_capab &&\n\t\t    test_bit(ATH6KL_FW_CAPABILITY_RSN_CAP_OVERRIDE,\n\t\t\t     ar->fw_capabilities))\n\t\t\tath6kl_wmi_set_ie_cmd(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t\t      WLAN_EID_RSN, WMI_RSN_IE_CAPB,\n\t\t\t\t\t      (const u8 *) &vif->rsn_capab,\n\t\t\t\t\t      sizeof(vif->rsn_capab));\n\n\t\treturn ath6kl_wmi_ap_profile_commit(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t\t\t    &vif->profile);\n\tdefault:\n\t\tath6kl_err(\"won't switch channels nw_type=%d\\n\", vif->nw_type);\n\t\treturn -ENOTSUPP;\n\t}\n}\n\nstatic void ath6kl_check_ch_switch(struct ath6kl *ar, u16 channel)\n{\n\tstruct ath6kl_vif *vif;\n\tint res = 0;\n\n\tif (!ar->want_ch_switch)\n\t\treturn;\n\n\tspin_lock_bh(&ar->list_lock);\n\tlist_for_each_entry(vif, &ar->vif_list, list) {\n\t\tif (ar->want_ch_switch & (1 << vif->fw_vif_idx))\n\t\t\tres = ath6kl_commit_ch_switch(vif, channel);\n\n\t\t \n\t\tar->want_ch_switch &= ~(1 << vif->fw_vif_idx);\n\n\t\tif (res)\n\t\t\tath6kl_err(\"channel switch failed nw_type %d res %d\\n\",\n\t\t\t\t   vif->nw_type, res);\n\t}\n\tspin_unlock_bh(&ar->list_lock);\n}\n\nvoid ath6kl_connect_event(struct ath6kl_vif *vif, u16 channel, u8 *bssid,\n\t\t\t  u16 listen_int, u16 beacon_int,\n\t\t\t  enum network_type net_type, u8 beacon_ie_len,\n\t\t\t  u8 assoc_req_len, u8 assoc_resp_len,\n\t\t\t  u8 *assoc_info)\n{\n\tstruct ath6kl *ar = vif->ar;\n\n\tath6kl_cfg80211_connect_event(vif, channel, bssid,\n\t\t\t\t      listen_int, beacon_int,\n\t\t\t\t      net_type, beacon_ie_len,\n\t\t\t\t      assoc_req_len, assoc_resp_len,\n\t\t\t\t      assoc_info);\n\n\tmemcpy(vif->bssid, bssid, sizeof(vif->bssid));\n\tvif->bss_ch = channel;\n\n\tif (vif->nw_type == INFRA_NETWORK) {\n\t\tath6kl_wmi_listeninterval_cmd(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t\t      vif->listen_intvl_t, 0);\n\t\tath6kl_check_ch_switch(ar, channel);\n\t}\n\n\tnetif_wake_queue(vif->ndev);\n\n\t \n\tspin_lock_bh(&vif->if_lock);\n\tset_bit(CONNECTED, &vif->flags);\n\tclear_bit(CONNECT_PEND, &vif->flags);\n\tnetif_carrier_on(vif->ndev);\n\tspin_unlock_bh(&vif->if_lock);\n\n\taggr_reset_state(vif->aggr_cntxt->aggr_conn);\n\tvif->reconnect_flag = 0;\n\n\tif ((vif->nw_type == ADHOC_NETWORK) && ar->ibss_ps_enable) {\n\t\tmemset(ar->node_map, 0, sizeof(ar->node_map));\n\t\tar->node_num = 0;\n\t\tar->next_ep_id = ENDPOINT_2;\n\t}\n\n\tif (!ar->usr_bss_filter) {\n\t\tset_bit(CLEAR_BSSFILTER_ON_BEACON, &vif->flags);\n\t\tath6kl_wmi_bssfilter_cmd(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t\t CURRENT_BSS_FILTER, 0);\n\t}\n}\n\nvoid ath6kl_tkip_micerr_event(struct ath6kl_vif *vif, u8 keyid, bool ismcast)\n{\n\tstruct ath6kl_sta *sta;\n\tstruct ath6kl *ar = vif->ar;\n\tu8 tsc[6];\n\n\t \n\tif (vif->nw_type == AP_NETWORK) {\n\t\tsta = ath6kl_find_sta_by_aid(ar, (keyid >> 2));\n\t\tif (!sta)\n\t\t\treturn;\n\n\t\tath6kl_dbg(ATH6KL_DBG_TRC,\n\t\t\t   \"ap tkip mic error received from aid=%d\\n\", keyid);\n\n\t\tmemset(tsc, 0, sizeof(tsc));  \n\t\tcfg80211_michael_mic_failure(vif->ndev, sta->mac,\n\t\t\t\t\t     NL80211_KEYTYPE_PAIRWISE, keyid,\n\t\t\t\t\t     tsc, GFP_KERNEL);\n\t} else {\n\t\tath6kl_cfg80211_tkip_micerr_event(vif, keyid, ismcast);\n\t}\n}\n\nstatic void ath6kl_update_target_stats(struct ath6kl_vif *vif, u8 *ptr, u32 len)\n{\n\tstruct wmi_target_stats *tgt_stats =\n\t\t(struct wmi_target_stats *) ptr;\n\tstruct ath6kl *ar = vif->ar;\n\tstruct target_stats *stats = &vif->target_stats;\n\tstruct tkip_ccmp_stats *ccmp_stats;\n\ts32 rate;\n\tu8 ac;\n\n\tif (len < sizeof(*tgt_stats))\n\t\treturn;\n\n\tath6kl_dbg(ATH6KL_DBG_TRC, \"updating target stats\\n\");\n\n\tstats->tx_pkt += le32_to_cpu(tgt_stats->stats.tx.pkt);\n\tstats->tx_byte += le32_to_cpu(tgt_stats->stats.tx.byte);\n\tstats->tx_ucast_pkt += le32_to_cpu(tgt_stats->stats.tx.ucast_pkt);\n\tstats->tx_ucast_byte += le32_to_cpu(tgt_stats->stats.tx.ucast_byte);\n\tstats->tx_mcast_pkt += le32_to_cpu(tgt_stats->stats.tx.mcast_pkt);\n\tstats->tx_mcast_byte += le32_to_cpu(tgt_stats->stats.tx.mcast_byte);\n\tstats->tx_bcast_pkt  += le32_to_cpu(tgt_stats->stats.tx.bcast_pkt);\n\tstats->tx_bcast_byte += le32_to_cpu(tgt_stats->stats.tx.bcast_byte);\n\tstats->tx_rts_success_cnt +=\n\t\tle32_to_cpu(tgt_stats->stats.tx.rts_success_cnt);\n\n\tfor (ac = 0; ac < WMM_NUM_AC; ac++)\n\t\tstats->tx_pkt_per_ac[ac] +=\n\t\t\tle32_to_cpu(tgt_stats->stats.tx.pkt_per_ac[ac]);\n\n\tstats->tx_err += le32_to_cpu(tgt_stats->stats.tx.err);\n\tstats->tx_fail_cnt += le32_to_cpu(tgt_stats->stats.tx.fail_cnt);\n\tstats->tx_retry_cnt += le32_to_cpu(tgt_stats->stats.tx.retry_cnt);\n\tstats->tx_mult_retry_cnt +=\n\t\tle32_to_cpu(tgt_stats->stats.tx.mult_retry_cnt);\n\tstats->tx_rts_fail_cnt +=\n\t\tle32_to_cpu(tgt_stats->stats.tx.rts_fail_cnt);\n\n\trate = a_sle32_to_cpu(tgt_stats->stats.tx.ucast_rate);\n\tstats->tx_ucast_rate = ath6kl_wmi_get_rate(ar->wmi, rate);\n\n\tstats->rx_pkt += le32_to_cpu(tgt_stats->stats.rx.pkt);\n\tstats->rx_byte += le32_to_cpu(tgt_stats->stats.rx.byte);\n\tstats->rx_ucast_pkt += le32_to_cpu(tgt_stats->stats.rx.ucast_pkt);\n\tstats->rx_ucast_byte += le32_to_cpu(tgt_stats->stats.rx.ucast_byte);\n\tstats->rx_mcast_pkt += le32_to_cpu(tgt_stats->stats.rx.mcast_pkt);\n\tstats->rx_mcast_byte += le32_to_cpu(tgt_stats->stats.rx.mcast_byte);\n\tstats->rx_bcast_pkt += le32_to_cpu(tgt_stats->stats.rx.bcast_pkt);\n\tstats->rx_bcast_byte += le32_to_cpu(tgt_stats->stats.rx.bcast_byte);\n\tstats->rx_frgment_pkt += le32_to_cpu(tgt_stats->stats.rx.frgment_pkt);\n\tstats->rx_err += le32_to_cpu(tgt_stats->stats.rx.err);\n\tstats->rx_crc_err += le32_to_cpu(tgt_stats->stats.rx.crc_err);\n\tstats->rx_key_cache_miss +=\n\t\tle32_to_cpu(tgt_stats->stats.rx.key_cache_miss);\n\tstats->rx_decrypt_err += le32_to_cpu(tgt_stats->stats.rx.decrypt_err);\n\tstats->rx_dupl_frame += le32_to_cpu(tgt_stats->stats.rx.dupl_frame);\n\n\trate = a_sle32_to_cpu(tgt_stats->stats.rx.ucast_rate);\n\tstats->rx_ucast_rate = ath6kl_wmi_get_rate(ar->wmi, rate);\n\n\tccmp_stats = &tgt_stats->stats.tkip_ccmp_stats;\n\n\tstats->tkip_local_mic_fail +=\n\t\tle32_to_cpu(ccmp_stats->tkip_local_mic_fail);\n\tstats->tkip_cnter_measures_invoked +=\n\t\tle32_to_cpu(ccmp_stats->tkip_cnter_measures_invoked);\n\tstats->tkip_fmt_err += le32_to_cpu(ccmp_stats->tkip_fmt_err);\n\n\tstats->ccmp_fmt_err += le32_to_cpu(ccmp_stats->ccmp_fmt_err);\n\tstats->ccmp_replays += le32_to_cpu(ccmp_stats->ccmp_replays);\n\n\tstats->pwr_save_fail_cnt +=\n\t\tle32_to_cpu(tgt_stats->pm_stats.pwr_save_failure_cnt);\n\tstats->noise_floor_calib =\n\t\ta_sle32_to_cpu(tgt_stats->noise_floor_calib);\n\n\tstats->cs_bmiss_cnt +=\n\t\tle32_to_cpu(tgt_stats->cserv_stats.cs_bmiss_cnt);\n\tstats->cs_low_rssi_cnt +=\n\t\tle32_to_cpu(tgt_stats->cserv_stats.cs_low_rssi_cnt);\n\tstats->cs_connect_cnt +=\n\t\tle16_to_cpu(tgt_stats->cserv_stats.cs_connect_cnt);\n\tstats->cs_discon_cnt +=\n\t\tle16_to_cpu(tgt_stats->cserv_stats.cs_discon_cnt);\n\n\tstats->cs_ave_beacon_rssi =\n\t\ta_sle16_to_cpu(tgt_stats->cserv_stats.cs_ave_beacon_rssi);\n\n\tstats->cs_last_roam_msec =\n\t\ttgt_stats->cserv_stats.cs_last_roam_msec;\n\tstats->cs_snr = tgt_stats->cserv_stats.cs_snr;\n\tstats->cs_rssi = a_sle16_to_cpu(tgt_stats->cserv_stats.cs_rssi);\n\n\tstats->lq_val = le32_to_cpu(tgt_stats->lq_val);\n\n\tstats->wow_pkt_dropped +=\n\t\tle32_to_cpu(tgt_stats->wow_stats.wow_pkt_dropped);\n\tstats->wow_host_pkt_wakeups +=\n\t\ttgt_stats->wow_stats.wow_host_pkt_wakeups;\n\tstats->wow_host_evt_wakeups +=\n\t\ttgt_stats->wow_stats.wow_host_evt_wakeups;\n\tstats->wow_evt_discarded +=\n\t\tle16_to_cpu(tgt_stats->wow_stats.wow_evt_discarded);\n\n\tstats->arp_received = le32_to_cpu(tgt_stats->arp_stats.arp_received);\n\tstats->arp_replied = le32_to_cpu(tgt_stats->arp_stats.arp_replied);\n\tstats->arp_matched = le32_to_cpu(tgt_stats->arp_stats.arp_matched);\n\n\tif (test_bit(STATS_UPDATE_PEND, &vif->flags)) {\n\t\tclear_bit(STATS_UPDATE_PEND, &vif->flags);\n\t\twake_up(&ar->event_wq);\n\t}\n}\n\nstatic void ath6kl_add_le32(__le32 *var, __le32 val)\n{\n\t*var = cpu_to_le32(le32_to_cpu(*var) + le32_to_cpu(val));\n}\n\nvoid ath6kl_tgt_stats_event(struct ath6kl_vif *vif, u8 *ptr, u32 len)\n{\n\tstruct wmi_ap_mode_stat *p = (struct wmi_ap_mode_stat *) ptr;\n\tstruct ath6kl *ar = vif->ar;\n\tstruct wmi_ap_mode_stat *ap = &ar->ap_stats;\n\tstruct wmi_per_sta_stat *st_ap, *st_p;\n\tu8 ac;\n\n\tif (vif->nw_type == AP_NETWORK) {\n\t\tif (len < sizeof(*p))\n\t\t\treturn;\n\n\t\tfor (ac = 0; ac < AP_MAX_NUM_STA; ac++) {\n\t\t\tst_ap = &ap->sta[ac];\n\t\t\tst_p = &p->sta[ac];\n\n\t\t\tath6kl_add_le32(&st_ap->tx_bytes, st_p->tx_bytes);\n\t\t\tath6kl_add_le32(&st_ap->tx_pkts, st_p->tx_pkts);\n\t\t\tath6kl_add_le32(&st_ap->tx_error, st_p->tx_error);\n\t\t\tath6kl_add_le32(&st_ap->tx_discard, st_p->tx_discard);\n\t\t\tath6kl_add_le32(&st_ap->rx_bytes, st_p->rx_bytes);\n\t\t\tath6kl_add_le32(&st_ap->rx_pkts, st_p->rx_pkts);\n\t\t\tath6kl_add_le32(&st_ap->rx_error, st_p->rx_error);\n\t\t\tath6kl_add_le32(&st_ap->rx_discard, st_p->rx_discard);\n\t\t}\n\n\t} else {\n\t\tath6kl_update_target_stats(vif, ptr, len);\n\t}\n}\n\nvoid ath6kl_wakeup_event(void *dev)\n{\n\tstruct ath6kl *ar = (struct ath6kl *) dev;\n\n\twake_up(&ar->event_wq);\n}\n\nvoid ath6kl_txpwr_rx_evt(void *devt, u8 tx_pwr)\n{\n\tstruct ath6kl *ar = (struct ath6kl *) devt;\n\n\tar->tx_pwr = tx_pwr;\n\twake_up(&ar->event_wq);\n}\n\nvoid ath6kl_pspoll_event(struct ath6kl_vif *vif, u8 aid)\n{\n\tstruct ath6kl_sta *conn;\n\tstruct sk_buff *skb;\n\tbool psq_empty = false;\n\tstruct ath6kl *ar = vif->ar;\n\tstruct ath6kl_mgmt_buff *mgmt_buf;\n\n\tconn = ath6kl_find_sta_by_aid(ar, aid);\n\n\tif (!conn)\n\t\treturn;\n\t \n\tspin_lock_bh(&conn->psq_lock);\n\tpsq_empty  = skb_queue_empty(&conn->psq) && (conn->mgmt_psq_len == 0);\n\tspin_unlock_bh(&conn->psq_lock);\n\n\tif (psq_empty)\n\t\t \n\t\treturn;\n\n\tspin_lock_bh(&conn->psq_lock);\n\tif (conn->mgmt_psq_len > 0) {\n\t\tmgmt_buf = list_first_entry(&conn->mgmt_psq,\n\t\t\t\t\tstruct ath6kl_mgmt_buff, list);\n\t\tlist_del(&mgmt_buf->list);\n\t\tconn->mgmt_psq_len--;\n\t\tspin_unlock_bh(&conn->psq_lock);\n\n\t\tconn->sta_flags |= STA_PS_POLLED;\n\t\tath6kl_wmi_send_mgmt_cmd(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t\t mgmt_buf->id, mgmt_buf->freq,\n\t\t\t\t\t mgmt_buf->wait, mgmt_buf->buf,\n\t\t\t\t\t mgmt_buf->len, mgmt_buf->no_cck);\n\t\tconn->sta_flags &= ~STA_PS_POLLED;\n\t\tkfree(mgmt_buf);\n\t} else {\n\t\tskb = skb_dequeue(&conn->psq);\n\t\tspin_unlock_bh(&conn->psq_lock);\n\n\t\tconn->sta_flags |= STA_PS_POLLED;\n\t\tath6kl_data_tx(skb, vif->ndev);\n\t\tconn->sta_flags &= ~STA_PS_POLLED;\n\t}\n\n\tspin_lock_bh(&conn->psq_lock);\n\tpsq_empty  = skb_queue_empty(&conn->psq) && (conn->mgmt_psq_len == 0);\n\tspin_unlock_bh(&conn->psq_lock);\n\n\tif (psq_empty)\n\t\tath6kl_wmi_set_pvb_cmd(ar->wmi, vif->fw_vif_idx, conn->aid, 0);\n}\n\nvoid ath6kl_dtimexpiry_event(struct ath6kl_vif *vif)\n{\n\tbool mcastq_empty = false;\n\tstruct sk_buff *skb;\n\tstruct ath6kl *ar = vif->ar;\n\n\t \n\tif (!ar->sta_list_index)\n\t\treturn;\n\n\tspin_lock_bh(&ar->mcastpsq_lock);\n\tmcastq_empty = skb_queue_empty(&ar->mcastpsq);\n\tspin_unlock_bh(&ar->mcastpsq_lock);\n\n\tif (mcastq_empty)\n\t\treturn;\n\n\t \n\tset_bit(DTIM_EXPIRED, &vif->flags);\n\n\tspin_lock_bh(&ar->mcastpsq_lock);\n\twhile ((skb = skb_dequeue(&ar->mcastpsq)) != NULL) {\n\t\tspin_unlock_bh(&ar->mcastpsq_lock);\n\n\t\tath6kl_data_tx(skb, vif->ndev);\n\n\t\tspin_lock_bh(&ar->mcastpsq_lock);\n\t}\n\tspin_unlock_bh(&ar->mcastpsq_lock);\n\n\tclear_bit(DTIM_EXPIRED, &vif->flags);\n\n\t \n\tath6kl_wmi_set_pvb_cmd(ar->wmi, vif->fw_vif_idx, MCAST_AID, 0);\n}\n\nvoid ath6kl_disconnect_event(struct ath6kl_vif *vif, u8 reason, u8 *bssid,\n\t\t\t     u8 assoc_resp_len, u8 *assoc_info,\n\t\t\t     u16 prot_reason_status)\n{\n\tstruct ath6kl *ar = vif->ar;\n\n\tif (vif->nw_type == AP_NETWORK) {\n\t\t \n\t\tif (reason == BSS_DISCONNECTED &&\n\t\t    prot_reason_status == WMI_AP_REASON_STA_ROAM) {\n\t\t\tar->want_ch_switch |= 1 << vif->fw_vif_idx;\n\t\t\t \n\t\t\tar->last_ch = le16_to_cpu(vif->profile.ch);\n\t\t}\n\n\t\tif (prot_reason_status == WMI_AP_REASON_MAX_STA) {\n\t\t\t \n\t\t\tcfg80211_conn_failed(vif->ndev, bssid,\n\t\t\t\t\t     NL80211_CONN_FAIL_MAX_CLIENTS,\n\t\t\t\t\t     GFP_KERNEL);\n\t\t}\n\n\t\tif (prot_reason_status == WMI_AP_REASON_ACL) {\n\t\t\t \n\t\t\tcfg80211_conn_failed(vif->ndev, bssid,\n\t\t\t\t\t     NL80211_CONN_FAIL_BLOCKED_CLIENT,\n\t\t\t\t\t     GFP_KERNEL);\n\t\t}\n\n\t\tif (!ath6kl_remove_sta(ar, bssid, prot_reason_status))\n\t\t\treturn;\n\n\t\t \n\t\tif (ar->sta_list_index == 0) {\n\t\t\tspin_lock_bh(&ar->mcastpsq_lock);\n\t\t\tskb_queue_purge(&ar->mcastpsq);\n\t\t\tspin_unlock_bh(&ar->mcastpsq_lock);\n\n\t\t\t \n\t\t\tif (test_bit(WMI_READY, &ar->flag))\n\t\t\t\tath6kl_wmi_set_pvb_cmd(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t\t\t       MCAST_AID, 0);\n\t\t}\n\n\t\tif (!is_broadcast_ether_addr(bssid)) {\n\t\t\t \n\t\t\tcfg80211_del_sta(vif->ndev, bssid, GFP_KERNEL);\n\t\t}\n\n\t\tif (memcmp(vif->ndev->dev_addr, bssid, ETH_ALEN) == 0) {\n\t\t\tmemset(vif->wep_key_list, 0, sizeof(vif->wep_key_list));\n\t\t\tclear_bit(CONNECTED, &vif->flags);\n\t\t}\n\t\treturn;\n\t}\n\n\tath6kl_cfg80211_disconnect_event(vif, reason, bssid,\n\t\t\t\t\t assoc_resp_len, assoc_info,\n\t\t\t\t\t prot_reason_status);\n\n\taggr_reset_state(vif->aggr_cntxt->aggr_conn);\n\n\tdel_timer(&vif->disconnect_timer);\n\n\tath6kl_dbg(ATH6KL_DBG_WLAN_CFG, \"disconnect reason is %d\\n\", reason);\n\n\t \n\tif (reason == DISCONNECT_CMD) {\n\t\tif (!ar->usr_bss_filter && test_bit(WMI_READY, &ar->flag))\n\t\t\tath6kl_wmi_bssfilter_cmd(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t\t\t NONE_BSS_FILTER, 0);\n\t} else {\n\t\tset_bit(CONNECT_PEND, &vif->flags);\n\t\tif (((reason == ASSOC_FAILED) &&\n\t\t     (prot_reason_status == 0x11)) ||\n\t\t    ((reason == ASSOC_FAILED) && (prot_reason_status == 0x0) &&\n\t\t     (vif->reconnect_flag == 1))) {\n\t\t\tset_bit(CONNECTED, &vif->flags);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tath6kl_check_ch_switch(ar, ar->last_ch);\n\n\t \n\tspin_lock_bh(&vif->if_lock);\n\tclear_bit(CONNECTED, &vif->flags);\n\tnetif_carrier_off(vif->ndev);\n\tspin_unlock_bh(&vif->if_lock);\n\n\tif ((reason != CSERV_DISCONNECT) || (vif->reconnect_flag != 1))\n\t\tvif->reconnect_flag = 0;\n\n\tif (reason != CSERV_DISCONNECT)\n\t\tar->user_key_ctrl = 0;\n\n\tnetif_stop_queue(vif->ndev);\n\tmemset(vif->bssid, 0, sizeof(vif->bssid));\n\tvif->bss_ch = 0;\n\n\tath6kl_tx_data_cleanup(ar);\n}\n\nstruct ath6kl_vif *ath6kl_vif_first(struct ath6kl *ar)\n{\n\tstruct ath6kl_vif *vif;\n\n\tspin_lock_bh(&ar->list_lock);\n\tif (list_empty(&ar->vif_list)) {\n\t\tspin_unlock_bh(&ar->list_lock);\n\t\treturn NULL;\n\t}\n\n\tvif = list_first_entry(&ar->vif_list, struct ath6kl_vif, list);\n\n\tspin_unlock_bh(&ar->list_lock);\n\n\treturn vif;\n}\n\nstatic int ath6kl_open(struct net_device *dev)\n{\n\tstruct ath6kl_vif *vif = netdev_priv(dev);\n\n\tset_bit(WLAN_ENABLED, &vif->flags);\n\n\tif (test_bit(CONNECTED, &vif->flags)) {\n\t\tnetif_carrier_on(dev);\n\t\tnetif_wake_queue(dev);\n\t} else {\n\t\tnetif_carrier_off(dev);\n\t}\n\n\treturn 0;\n}\n\nstatic int ath6kl_close(struct net_device *dev)\n{\n\tstruct ath6kl_vif *vif = netdev_priv(dev);\n\n\tnetif_stop_queue(dev);\n\n\tath6kl_cfg80211_stop(vif);\n\n\tclear_bit(WLAN_ENABLED, &vif->flags);\n\n\treturn 0;\n}\n\nstatic int ath6kl_set_features(struct net_device *dev,\n\t\t\t       netdev_features_t features)\n{\n\tstruct ath6kl_vif *vif = netdev_priv(dev);\n\tstruct ath6kl *ar = vif->ar;\n\tint err = 0;\n\n\tif ((features & NETIF_F_RXCSUM) &&\n\t    (ar->rx_meta_ver != WMI_META_VERSION_2)) {\n\t\tar->rx_meta_ver = WMI_META_VERSION_2;\n\t\terr = ath6kl_wmi_set_rx_frame_format_cmd(ar->wmi,\n\t\t\t\t\t\t\t vif->fw_vif_idx,\n\t\t\t\t\t\t\t ar->rx_meta_ver, 0, 0);\n\t\tif (err) {\n\t\t\tdev->features = features & ~NETIF_F_RXCSUM;\n\t\t\treturn err;\n\t\t}\n\t} else if (!(features & NETIF_F_RXCSUM) &&\n\t\t   (ar->rx_meta_ver == WMI_META_VERSION_2)) {\n\t\tar->rx_meta_ver = 0;\n\t\terr = ath6kl_wmi_set_rx_frame_format_cmd(ar->wmi,\n\t\t\t\t\t\t\t vif->fw_vif_idx,\n\t\t\t\t\t\t\t ar->rx_meta_ver, 0, 0);\n\t\tif (err) {\n\t\t\tdev->features = features | NETIF_F_RXCSUM;\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic void ath6kl_set_multicast_list(struct net_device *ndev)\n{\n\tstruct ath6kl_vif *vif = netdev_priv(ndev);\n\tbool mc_all_on = false;\n\tint mc_count = netdev_mc_count(ndev);\n\tstruct netdev_hw_addr *ha;\n\tbool found;\n\tstruct ath6kl_mc_filter *mc_filter, *tmp;\n\tstruct list_head mc_filter_new;\n\tint ret;\n\n\tif (!test_bit(WMI_READY, &vif->ar->flag) ||\n\t    !test_bit(WLAN_ENABLED, &vif->flags))\n\t\treturn;\n\n\t \n\tmc_all_on = !!(ndev->flags & IFF_PROMISC) ||\n\t\t    !!(ndev->flags & IFF_ALLMULTI) ||\n\t\t    !!(mc_count > ATH6K_MAX_MC_FILTERS_PER_LIST);\n\n\tif (mc_all_on)\n\t\tset_bit(NETDEV_MCAST_ALL_ON, &vif->flags);\n\telse\n\t\tclear_bit(NETDEV_MCAST_ALL_ON, &vif->flags);\n\n\tif (test_bit(ATH6KL_FW_CAPABILITY_WOW_MULTICAST_FILTER,\n\t\t     vif->ar->fw_capabilities)) {\n\t\tmc_all_on = mc_all_on || (vif->ar->state == ATH6KL_STATE_ON);\n\t}\n\n\tif (!(ndev->flags & IFF_MULTICAST)) {\n\t\tmc_all_on = false;\n\t\tset_bit(NETDEV_MCAST_ALL_OFF, &vif->flags);\n\t} else {\n\t\tclear_bit(NETDEV_MCAST_ALL_OFF, &vif->flags);\n\t}\n\n\t \n\tath6kl_dbg(ATH6KL_DBG_TRC, \"%s multicast-all filter\\n\",\n\t\t   mc_all_on ? \"enabling\" : \"disabling\");\n\n\tret = ath6kl_wmi_mcast_filter_cmd(vif->ar->wmi, vif->fw_vif_idx,\n\t\t\t\t\t\t  mc_all_on);\n\tif (ret) {\n\t\tath6kl_warn(\"Failed to %s multicast-all receive\\n\",\n\t\t\t    mc_all_on ? \"enable\" : \"disable\");\n\t\treturn;\n\t}\n\n\tif (test_bit(NETDEV_MCAST_ALL_ON, &vif->flags))\n\t\treturn;\n\n\t \n\tlist_for_each_entry_safe(mc_filter, tmp, &vif->mc_filter, list) {\n\t\tfound = false;\n\t\tnetdev_for_each_mc_addr(ha, ndev) {\n\t\t\tif (memcmp(ha->addr, mc_filter->hw_addr,\n\t\t\t\t   ATH6KL_MCAST_FILTER_MAC_ADDR_SIZE) == 0) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!found) {\n\t\t\t \n\t\t\tath6kl_dbg(ATH6KL_DBG_TRC,\n\t\t\t\t   \"Removing %pM from multicast filter\\n\",\n\t\t\t\t   mc_filter->hw_addr);\n\t\t\tret = ath6kl_wmi_add_del_mcast_filter_cmd(vif->ar->wmi,\n\t\t\t\t\tvif->fw_vif_idx, mc_filter->hw_addr,\n\t\t\t\t\tfalse);\n\t\t\tif (ret) {\n\t\t\t\tath6kl_warn(\"Failed to remove multicast filter:%pM\\n\",\n\t\t\t\t\t    mc_filter->hw_addr);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlist_del(&mc_filter->list);\n\t\t\tkfree(mc_filter);\n\t\t}\n\t}\n\n\tINIT_LIST_HEAD(&mc_filter_new);\n\n\tnetdev_for_each_mc_addr(ha, ndev) {\n\t\tfound = false;\n\t\tlist_for_each_entry(mc_filter, &vif->mc_filter, list) {\n\t\t\tif (memcmp(ha->addr, mc_filter->hw_addr,\n\t\t\t\t   ATH6KL_MCAST_FILTER_MAC_ADDR_SIZE) == 0) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!found) {\n\t\t\tmc_filter = kzalloc(sizeof(struct ath6kl_mc_filter),\n\t\t\t\t\t    GFP_ATOMIC);\n\t\t\tif (!mc_filter) {\n\t\t\t\tWARN_ON(1);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tmemcpy(mc_filter->hw_addr, ha->addr,\n\t\t\t       ATH6KL_MCAST_FILTER_MAC_ADDR_SIZE);\n\t\t\t \n\t\t\tath6kl_dbg(ATH6KL_DBG_TRC,\n\t\t\t\t   \"Adding %pM to multicast filter list\\n\",\n\t\t\t\t   mc_filter->hw_addr);\n\t\t\tret = ath6kl_wmi_add_del_mcast_filter_cmd(vif->ar->wmi,\n\t\t\t\t\tvif->fw_vif_idx, mc_filter->hw_addr,\n\t\t\t\t\ttrue);\n\t\t\tif (ret) {\n\t\t\t\tath6kl_warn(\"Failed to add multicast filter :%pM\\n\",\n\t\t\t\t\t    mc_filter->hw_addr);\n\t\t\t\tkfree(mc_filter);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tlist_add_tail(&mc_filter->list, &mc_filter_new);\n\t\t}\n\t}\n\nout:\n\tlist_splice_tail(&mc_filter_new, &vif->mc_filter);\n}\n\nstatic const struct net_device_ops ath6kl_netdev_ops = {\n\t.ndo_open               = ath6kl_open,\n\t.ndo_stop               = ath6kl_close,\n\t.ndo_start_xmit         = ath6kl_data_tx,\n\t.ndo_set_features       = ath6kl_set_features,\n\t.ndo_set_rx_mode\t= ath6kl_set_multicast_list,\n};\n\nvoid init_netdev(struct net_device *dev)\n{\n\tstruct ath6kl *ar = ath6kl_priv(dev);\n\n\tdev->netdev_ops = &ath6kl_netdev_ops;\n\tdev->needs_free_netdev = true;\n\tdev->watchdog_timeo = ATH6KL_TX_TIMEOUT;\n\n\tdev->needed_headroom = ETH_HLEN;\n\tdev->needed_headroom += roundup(sizeof(struct ath6kl_llc_snap_hdr) +\n\t\t\t\t\tsizeof(struct wmi_data_hdr) +\n\t\t\t\t\tHTC_HDR_LENGTH +\n\t\t\t\t\tWMI_MAX_TX_META_SZ +\n\t\t\t\t\tATH6KL_HTC_ALIGN_BYTES, 4);\n\n\tif (!test_bit(ATH6KL_FW_CAPABILITY_NO_IP_CHECKSUM,\n\t\t      ar->fw_capabilities))\n\t\tdev->hw_features |= NETIF_F_IP_CSUM | NETIF_F_RXCSUM;\n\n\treturn;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}