{
  "module_name": "htc_mbox.c",
  "hash_id": "a6e0d6f2547311d1844dd3d7acb95933ff5c230b0b24d092cd38b1adcb109365",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath6kl/htc_mbox.c",
  "human_readable_source": " \n\n#include \"core.h\"\n#include \"hif.h\"\n#include \"debug.h\"\n#include \"hif-ops.h\"\n#include \"trace.h\"\n\n#include <asm/unaligned.h>\n\n#define CALC_TXRX_PADDED_LEN(dev, len)  (__ALIGN_MASK((len), (dev)->block_mask))\n\nstatic void ath6kl_htc_mbox_cleanup(struct htc_target *target);\nstatic void ath6kl_htc_mbox_stop(struct htc_target *target);\nstatic int ath6kl_htc_mbox_add_rxbuf_multiple(struct htc_target *target,\n\t\t\t\t\t      struct list_head *pkt_queue);\nstatic void ath6kl_htc_set_credit_dist(struct htc_target *target,\n\t\t\t\t       struct ath6kl_htc_credit_info *cred_info,\n\t\t\t\t       u16 svc_pri_order[], int len);\n\n \n#define TX_RESUME_BUNDLE_THRESHOLD\t1500\n\n \nstatic void ath6kl_credit_deposit(struct ath6kl_htc_credit_info *cred_info,\n\t\t\t\t  struct htc_endpoint_credit_dist *ep_dist,\n\t\t\t\t  int credits)\n{\n\tath6kl_dbg(ATH6KL_DBG_CREDIT, \"credit deposit ep %d credits %d\\n\",\n\t\t   ep_dist->endpoint, credits);\n\n\tep_dist->credits += credits;\n\tep_dist->cred_assngd += credits;\n\tcred_info->cur_free_credits -= credits;\n}\n\nstatic void ath6kl_credit_init(struct ath6kl_htc_credit_info *cred_info,\n\t\t\t       struct list_head *ep_list,\n\t\t\t       int tot_credits)\n{\n\tstruct htc_endpoint_credit_dist *cur_ep_dist;\n\tint count;\n\n\tath6kl_dbg(ATH6KL_DBG_CREDIT, \"credit init total %d\\n\", tot_credits);\n\n\tcred_info->cur_free_credits = tot_credits;\n\tcred_info->total_avail_credits = tot_credits;\n\n\tlist_for_each_entry(cur_ep_dist, ep_list, list) {\n\t\tif (cur_ep_dist->endpoint == ENDPOINT_0)\n\t\t\tcontinue;\n\n\t\tcur_ep_dist->cred_min = cur_ep_dist->cred_per_msg;\n\n\t\tif (tot_credits > 4) {\n\t\t\tif ((cur_ep_dist->svc_id == WMI_DATA_BK_SVC) ||\n\t\t\t    (cur_ep_dist->svc_id == WMI_DATA_BE_SVC)) {\n\t\t\t\tath6kl_credit_deposit(cred_info,\n\t\t\t\t\t\t      cur_ep_dist,\n\t\t\t\t\t\t      cur_ep_dist->cred_min);\n\t\t\t\tcur_ep_dist->dist_flags |= HTC_EP_ACTIVE;\n\t\t\t}\n\t\t}\n\n\t\tif (cur_ep_dist->svc_id == WMI_CONTROL_SVC) {\n\t\t\tath6kl_credit_deposit(cred_info, cur_ep_dist,\n\t\t\t\t\t      cur_ep_dist->cred_min);\n\t\t\t \n\t\t\tcur_ep_dist->dist_flags |= HTC_EP_ACTIVE;\n\t\t}\n\n\t\t \n\t}\n\n\t \n\tcred_info->lowestpri_ep_dist = cur_ep_dist->list;\n\n\tWARN_ON(cred_info->cur_free_credits <= 0);\n\n\tlist_for_each_entry(cur_ep_dist, ep_list, list) {\n\t\tif (cur_ep_dist->endpoint == ENDPOINT_0)\n\t\t\tcontinue;\n\n\t\tif (cur_ep_dist->svc_id == WMI_CONTROL_SVC) {\n\t\t\tcur_ep_dist->cred_norm = cur_ep_dist->cred_per_msg;\n\t\t} else {\n\t\t\t \n\t\t\tcount = (cred_info->cur_free_credits /\n\t\t\t\t cur_ep_dist->cred_per_msg)\n\t\t\t\t* cur_ep_dist->cred_per_msg;\n\t\t\tcount = (count * 3) >> 2;\n\t\t\tcount = max(count, cur_ep_dist->cred_per_msg);\n\t\t\tcur_ep_dist->cred_norm = count;\n\t\t}\n\n\t\tath6kl_dbg(ATH6KL_DBG_CREDIT,\n\t\t\t   \"credit ep %d svc_id %d credits %d per_msg %d norm %d min %d\\n\",\n\t\t\t   cur_ep_dist->endpoint,\n\t\t\t   cur_ep_dist->svc_id,\n\t\t\t   cur_ep_dist->credits,\n\t\t\t   cur_ep_dist->cred_per_msg,\n\t\t\t   cur_ep_dist->cred_norm,\n\t\t\t   cur_ep_dist->cred_min);\n\t}\n}\n\n \nstatic int ath6kl_htc_mbox_credit_setup(struct htc_target *htc_target,\n\t\t\t       struct ath6kl_htc_credit_info *cred_info)\n{\n\tu16 servicepriority[5];\n\n\tmemset(cred_info, 0, sizeof(struct ath6kl_htc_credit_info));\n\n\tservicepriority[0] = WMI_CONTROL_SVC;   \n\tservicepriority[1] = WMI_DATA_VO_SVC;\n\tservicepriority[2] = WMI_DATA_VI_SVC;\n\tservicepriority[3] = WMI_DATA_BE_SVC;\n\tservicepriority[4] = WMI_DATA_BK_SVC;  \n\n\t \n\tath6kl_htc_set_credit_dist(htc_target, cred_info, servicepriority, 5);\n\n\treturn 0;\n}\n\n \nstatic void ath6kl_credit_reduce(struct ath6kl_htc_credit_info *cred_info,\n\t\t\t\t struct htc_endpoint_credit_dist *ep_dist,\n\t\t\t\t int limit)\n{\n\tint credits;\n\n\tath6kl_dbg(ATH6KL_DBG_CREDIT, \"credit reduce ep %d limit %d\\n\",\n\t\t   ep_dist->endpoint, limit);\n\n\tep_dist->cred_assngd = limit;\n\n\tif (ep_dist->credits <= limit)\n\t\treturn;\n\n\tcredits = ep_dist->credits - limit;\n\tep_dist->credits -= credits;\n\tcred_info->cur_free_credits += credits;\n}\n\nstatic void ath6kl_credit_update(struct ath6kl_htc_credit_info *cred_info,\n\t\t\t\t struct list_head *epdist_list)\n{\n\tstruct htc_endpoint_credit_dist *cur_list;\n\n\tlist_for_each_entry(cur_list, epdist_list, list) {\n\t\tif (cur_list->endpoint == ENDPOINT_0)\n\t\t\tcontinue;\n\n\t\tif (cur_list->cred_to_dist > 0) {\n\t\t\tcur_list->credits += cur_list->cred_to_dist;\n\t\t\tcur_list->cred_to_dist = 0;\n\n\t\t\tif (cur_list->credits > cur_list->cred_assngd)\n\t\t\t\tath6kl_credit_reduce(cred_info,\n\t\t\t\t\t\t     cur_list,\n\t\t\t\t\t\t     cur_list->cred_assngd);\n\n\t\t\tif (cur_list->credits > cur_list->cred_norm)\n\t\t\t\tath6kl_credit_reduce(cred_info, cur_list,\n\t\t\t\t\t\t     cur_list->cred_norm);\n\n\t\t\tif (!(cur_list->dist_flags & HTC_EP_ACTIVE)) {\n\t\t\t\tif (cur_list->txq_depth == 0)\n\t\t\t\t\tath6kl_credit_reduce(cred_info,\n\t\t\t\t\t\t\t     cur_list, 0);\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic void ath6kl_credit_seek(struct ath6kl_htc_credit_info *cred_info,\n\t\t\t\tstruct htc_endpoint_credit_dist *ep_dist)\n{\n\tstruct htc_endpoint_credit_dist *curdist_list;\n\tint credits = 0;\n\tint need;\n\n\tif (ep_dist->svc_id == WMI_CONTROL_SVC)\n\t\tgoto out;\n\n\tif ((ep_dist->svc_id == WMI_DATA_VI_SVC) ||\n\t    (ep_dist->svc_id == WMI_DATA_VO_SVC))\n\t\tif ((ep_dist->cred_assngd >= ep_dist->cred_norm))\n\t\t\tgoto out;\n\n\t \n\n\tcredits = min(cred_info->cur_free_credits, ep_dist->seek_cred);\n\n\tif (credits >= ep_dist->seek_cred)\n\t\tgoto out;\n\n\t \n\n\tlist_for_each_entry_reverse(curdist_list,\n\t\t\t\t    &cred_info->lowestpri_ep_dist,\n\t\t\t\t    list) {\n\t\tif (curdist_list == ep_dist)\n\t\t\tbreak;\n\n\t\tneed = ep_dist->seek_cred - cred_info->cur_free_credits;\n\n\t\tif ((curdist_list->cred_assngd - need) >=\n\t\t     curdist_list->cred_min) {\n\t\t\t \n\t\t\tath6kl_credit_reduce(cred_info, curdist_list,\n\t\t\t\t\t     curdist_list->cred_assngd - need);\n\n\t\t\tif (cred_info->cur_free_credits >=\n\t\t\t    ep_dist->seek_cred)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (curdist_list->endpoint == ENDPOINT_0)\n\t\t\tbreak;\n\t}\n\n\tcredits = min(cred_info->cur_free_credits, ep_dist->seek_cred);\n\nout:\n\t \n\tif (credits)\n\t\tath6kl_credit_deposit(cred_info, ep_dist, credits);\n\n\tep_dist->seek_cred = 0;\n}\n\n \nstatic void ath6kl_credit_redistribute(struct ath6kl_htc_credit_info *info,\n\t\t\t\t       struct list_head *ep_dist_list)\n{\n\tstruct htc_endpoint_credit_dist *curdist_list;\n\n\tlist_for_each_entry(curdist_list, ep_dist_list, list) {\n\t\tif (curdist_list->endpoint == ENDPOINT_0)\n\t\t\tcontinue;\n\n\t\tif ((curdist_list->svc_id == WMI_DATA_BK_SVC)  ||\n\t\t    (curdist_list->svc_id == WMI_DATA_BE_SVC))\n\t\t\tcurdist_list->dist_flags |= HTC_EP_ACTIVE;\n\n\t\tif ((curdist_list->svc_id != WMI_CONTROL_SVC) &&\n\t\t    !(curdist_list->dist_flags & HTC_EP_ACTIVE)) {\n\t\t\tif (curdist_list->txq_depth == 0)\n\t\t\t\tath6kl_credit_reduce(info, curdist_list, 0);\n\t\t\telse\n\t\t\t\tath6kl_credit_reduce(info,\n\t\t\t\t\t\t     curdist_list,\n\t\t\t\t\t\t     curdist_list->cred_min);\n\t\t}\n\t}\n}\n\n \nstatic void ath6kl_credit_distribute(struct ath6kl_htc_credit_info *cred_info,\n\t\t\t\t     struct list_head *ep_dist_list,\n\t\t\t      enum htc_credit_dist_reason reason)\n{\n\tswitch (reason) {\n\tcase HTC_CREDIT_DIST_SEND_COMPLETE:\n\t\tath6kl_credit_update(cred_info, ep_dist_list);\n\t\tbreak;\n\tcase HTC_CREDIT_DIST_ACTIVITY_CHANGE:\n\t\tath6kl_credit_redistribute(cred_info, ep_dist_list);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tWARN_ON(cred_info->cur_free_credits > cred_info->total_avail_credits);\n\tWARN_ON(cred_info->cur_free_credits < 0);\n}\n\nstatic void ath6kl_htc_tx_buf_align(u8 **buf, unsigned long len)\n{\n\tu8 *align_addr;\n\n\tif (!IS_ALIGNED((unsigned long) *buf, 4)) {\n\t\talign_addr = PTR_ALIGN(*buf - 4, 4);\n\t\tmemmove(align_addr, *buf, len);\n\t\t*buf = align_addr;\n\t}\n}\n\nstatic void ath6kl_htc_tx_prep_pkt(struct htc_packet *packet, u8 flags,\n\t\t\t\t   int ctrl0, int ctrl1)\n{\n\tstruct htc_frame_hdr *hdr;\n\n\tpacket->buf -= HTC_HDR_LENGTH;\n\thdr =  (struct htc_frame_hdr *)packet->buf;\n\n\t \n\tput_unaligned((u16)packet->act_len, &hdr->payld_len);\n\thdr->flags = flags;\n\thdr->eid = packet->endpoint;\n\thdr->ctrl[0] = ctrl0;\n\thdr->ctrl[1] = ctrl1;\n}\n\nstatic void htc_reclaim_txctrl_buf(struct htc_target *target,\n\t\t\t\t   struct htc_packet *pkt)\n{\n\tspin_lock_bh(&target->htc_lock);\n\tlist_add_tail(&pkt->list, &target->free_ctrl_txbuf);\n\tspin_unlock_bh(&target->htc_lock);\n}\n\nstatic struct htc_packet *htc_get_control_buf(struct htc_target *target,\n\t\t\t\t\t      bool tx)\n{\n\tstruct htc_packet *packet = NULL;\n\tstruct list_head *buf_list;\n\n\tbuf_list = tx ? &target->free_ctrl_txbuf : &target->free_ctrl_rxbuf;\n\n\tspin_lock_bh(&target->htc_lock);\n\n\tif (list_empty(buf_list)) {\n\t\tspin_unlock_bh(&target->htc_lock);\n\t\treturn NULL;\n\t}\n\n\tpacket = list_first_entry(buf_list, struct htc_packet, list);\n\tlist_del(&packet->list);\n\tspin_unlock_bh(&target->htc_lock);\n\n\tif (tx)\n\t\tpacket->buf = packet->buf_start + HTC_HDR_LENGTH;\n\n\treturn packet;\n}\n\nstatic void htc_tx_comp_update(struct htc_target *target,\n\t\t\t       struct htc_endpoint *endpoint,\n\t\t\t       struct htc_packet *packet)\n{\n\tpacket->completion = NULL;\n\tpacket->buf += HTC_HDR_LENGTH;\n\n\tif (!packet->status)\n\t\treturn;\n\n\tath6kl_err(\"req failed (status:%d, ep:%d, len:%d creds:%d)\\n\",\n\t\t   packet->status, packet->endpoint, packet->act_len,\n\t\t   packet->info.tx.cred_used);\n\n\t \n\tspin_lock_bh(&target->tx_lock);\n\tendpoint->cred_dist.cred_to_dist +=\n\t\t\t\tpacket->info.tx.cred_used;\n\tendpoint->cred_dist.txq_depth = get_queue_depth(&endpoint->txq);\n\n\tath6kl_dbg(ATH6KL_DBG_HTC, \"htc tx ctxt 0x%p dist 0x%p\\n\",\n\t\t   target->credit_info, &target->cred_dist_list);\n\n\tath6kl_credit_distribute(target->credit_info,\n\t\t\t\t &target->cred_dist_list,\n\t\t\t\t HTC_CREDIT_DIST_SEND_COMPLETE);\n\n\tspin_unlock_bh(&target->tx_lock);\n}\n\nstatic void htc_tx_complete(struct htc_endpoint *endpoint,\n\t\t\t    struct list_head *txq)\n{\n\tif (list_empty(txq))\n\t\treturn;\n\n\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t   \"htc tx complete ep %d pkts %d\\n\",\n\t\t   endpoint->eid, get_queue_depth(txq));\n\n\tath6kl_tx_complete(endpoint->target, txq);\n}\n\nstatic void htc_tx_comp_handler(struct htc_target *target,\n\t\t\t\tstruct htc_packet *packet)\n{\n\tstruct htc_endpoint *endpoint = &target->endpoint[packet->endpoint];\n\tstruct list_head container;\n\n\tath6kl_dbg(ATH6KL_DBG_HTC, \"htc tx complete seqno %d\\n\",\n\t\t   packet->info.tx.seqno);\n\n\thtc_tx_comp_update(target, endpoint, packet);\n\tINIT_LIST_HEAD(&container);\n\tlist_add_tail(&packet->list, &container);\n\t \n\thtc_tx_complete(endpoint, &container);\n}\n\nstatic void htc_async_tx_scat_complete(struct htc_target *target,\n\t\t\t\t       struct hif_scatter_req *scat_req)\n{\n\tstruct htc_endpoint *endpoint;\n\tstruct htc_packet *packet;\n\tstruct list_head tx_compq;\n\tint i;\n\n\tINIT_LIST_HEAD(&tx_compq);\n\n\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t   \"htc tx scat complete len %d entries %d\\n\",\n\t\t   scat_req->len, scat_req->scat_entries);\n\n\tif (scat_req->status)\n\t\tath6kl_err(\"send scatter req failed: %d\\n\", scat_req->status);\n\n\tpacket = scat_req->scat_list[0].packet;\n\tendpoint = &target->endpoint[packet->endpoint];\n\n\t \n\tfor (i = 0; i < scat_req->scat_entries; i++) {\n\t\tpacket = scat_req->scat_list[i].packet;\n\t\tif (!packet) {\n\t\t\tWARN_ON(1);\n\t\t\treturn;\n\t\t}\n\n\t\tpacket->status = scat_req->status;\n\t\thtc_tx_comp_update(target, endpoint, packet);\n\t\tlist_add_tail(&packet->list, &tx_compq);\n\t}\n\n\t \n\thif_scatter_req_add(target->dev->ar, scat_req);\n\n\t \n\thtc_tx_complete(endpoint, &tx_compq);\n}\n\nstatic int ath6kl_htc_tx_issue(struct htc_target *target,\n\t\t\t       struct htc_packet *packet)\n{\n\tint status;\n\tbool sync = false;\n\tu32 padded_len, send_len;\n\n\tif (!packet->completion)\n\t\tsync = true;\n\n\tsend_len = packet->act_len + HTC_HDR_LENGTH;\n\n\tpadded_len = CALC_TXRX_PADDED_LEN(target, send_len);\n\n\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t   \"htc tx issue len %d seqno %d padded_len %d mbox 0x%X %s\\n\",\n\t\t   send_len, packet->info.tx.seqno, padded_len,\n\t\t   target->dev->ar->mbox_info.htc_addr,\n\t\t   sync ? \"sync\" : \"async\");\n\n\tif (sync) {\n\t\tstatus = hif_read_write_sync(target->dev->ar,\n\t\t\t\ttarget->dev->ar->mbox_info.htc_addr,\n\t\t\t\t packet->buf, padded_len,\n\t\t\t\t HIF_WR_SYNC_BLOCK_INC);\n\n\t\tpacket->status = status;\n\t\tpacket->buf += HTC_HDR_LENGTH;\n\t} else\n\t\tstatus = hif_write_async(target->dev->ar,\n\t\t\t\ttarget->dev->ar->mbox_info.htc_addr,\n\t\t\t\tpacket->buf, padded_len,\n\t\t\t\tHIF_WR_ASYNC_BLOCK_INC, packet);\n\n\ttrace_ath6kl_htc_tx(status, packet->endpoint, packet->buf, send_len);\n\n\treturn status;\n}\n\nstatic int htc_check_credits(struct htc_target *target,\n\t\t\t     struct htc_endpoint *ep, u8 *flags,\n\t\t\t     enum htc_endpoint_id eid, unsigned int len,\n\t\t\t     int *req_cred)\n{\n\t*req_cred = (len > target->tgt_cred_sz) ?\n\t\t     DIV_ROUND_UP(len, target->tgt_cred_sz) : 1;\n\n\tath6kl_dbg(ATH6KL_DBG_CREDIT, \"credit check need %d got %d\\n\",\n\t\t   *req_cred, ep->cred_dist.credits);\n\n\tif (ep->cred_dist.credits < *req_cred) {\n\t\tif (eid == ENDPOINT_0)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tep->cred_dist.seek_cred = *req_cred - ep->cred_dist.credits;\n\n\t\tath6kl_credit_seek(target->credit_info, &ep->cred_dist);\n\n\t\tep->cred_dist.seek_cred = 0;\n\n\t\tif (ep->cred_dist.credits < *req_cred) {\n\t\t\tath6kl_dbg(ATH6KL_DBG_CREDIT,\n\t\t\t\t   \"credit not found for ep %d\\n\",\n\t\t\t\t   eid);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tep->cred_dist.credits -= *req_cred;\n\tep->ep_st.cred_cosumd += *req_cred;\n\n\t  \n\tif (ep->cred_dist.credits < ep->cred_dist.cred_per_msg) {\n\t\tep->cred_dist.seek_cred =\n\t\tep->cred_dist.cred_per_msg - ep->cred_dist.credits;\n\n\t\tath6kl_credit_seek(target->credit_info, &ep->cred_dist);\n\n\t\t \n\t\tif (ep->cred_dist.credits < ep->cred_dist.cred_per_msg) {\n\t\t\t \n\t\t\t*flags |= HTC_FLAGS_NEED_CREDIT_UPDATE;\n\t\t\tep->ep_st.cred_low_indicate += 1;\n\t\t\tath6kl_dbg(ATH6KL_DBG_CREDIT,\n\t\t\t\t   \"credit we need credits asap\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void ath6kl_htc_tx_pkts_get(struct htc_target *target,\n\t\t\t\t   struct htc_endpoint *endpoint,\n\t\t\t\t   struct list_head *queue)\n{\n\tint req_cred;\n\tu8 flags;\n\tstruct htc_packet *packet;\n\tunsigned int len;\n\n\twhile (true) {\n\t\tflags = 0;\n\n\t\tif (list_empty(&endpoint->txq))\n\t\t\tbreak;\n\t\tpacket = list_first_entry(&endpoint->txq, struct htc_packet,\n\t\t\t\t\t  list);\n\n\t\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t\t   \"htc tx got packet 0x%p queue depth %d\\n\",\n\t\t\t   packet, get_queue_depth(&endpoint->txq));\n\n\t\tlen = CALC_TXRX_PADDED_LEN(target,\n\t\t\t\t\t   packet->act_len + HTC_HDR_LENGTH);\n\n\t\tif (htc_check_credits(target, endpoint, &flags,\n\t\t\t\t      packet->endpoint, len, &req_cred))\n\t\t\tbreak;\n\n\t\t \n\t\tpacket = list_first_entry(&endpoint->txq, struct htc_packet,\n\t\t\t\t\t  list);\n\t\tlist_move_tail(&packet->list, queue);\n\n\t\t \n\t\tpacket->info.tx.cred_used = req_cred;\n\n\t\t \n\t\tpacket->completion = htc_tx_comp_handler;\n\t\tpacket->context = target;\n\t\tendpoint->ep_st.tx_issued += 1;\n\n\t\t \n\t\tpacket->info.tx.flags = flags;\n\t\tpacket->info.tx.seqno = endpoint->seqno;\n\t\tendpoint->seqno++;\n\t}\n}\n\n \nstatic int htc_get_credit_padding(unsigned int cred_sz, int *len,\n\t\t\t\t  struct htc_endpoint *ep)\n{\n\tint rem_cred, cred_pad;\n\n\trem_cred = *len % cred_sz;\n\n\t \n\tif  (!rem_cred)\n\t\treturn 0;\n\n\tif (!(ep->conn_flags & HTC_FLGS_TX_BNDL_PAD_EN))\n\t\treturn -1;\n\n\t \n\tcred_pad = *len < cred_sz ? (cred_sz - *len) : rem_cred;\n\n\tif ((cred_pad > 0) && (cred_pad <= 255))\n\t\t*len += cred_pad;\n\telse\n\t\t \n\t\treturn -1;\n\n\treturn cred_pad;\n}\n\nstatic int ath6kl_htc_tx_setup_scat_list(struct htc_target *target,\n\t\t\t\t\t struct htc_endpoint *endpoint,\n\t\t\t\t\t struct hif_scatter_req *scat_req,\n\t\t\t\t\t int n_scat,\n\t\t\t\t\t struct list_head *queue)\n{\n\tstruct htc_packet *packet;\n\tint i, len, rem_scat, cred_pad;\n\tint status = 0;\n\tu8 flags;\n\n\trem_scat = target->max_tx_bndl_sz;\n\n\tfor (i = 0; i < n_scat; i++) {\n\t\tscat_req->scat_list[i].packet = NULL;\n\n\t\tif (list_empty(queue))\n\t\t\tbreak;\n\n\t\tpacket = list_first_entry(queue, struct htc_packet, list);\n\t\tlen = CALC_TXRX_PADDED_LEN(target,\n\t\t\t\t\t   packet->act_len + HTC_HDR_LENGTH);\n\n\t\tcred_pad = htc_get_credit_padding(target->tgt_cred_sz,\n\t\t\t\t\t\t  &len, endpoint);\n\t\tif (cred_pad < 0 || rem_scat < len) {\n\t\t\tstatus = -ENOSPC;\n\t\t\tbreak;\n\t\t}\n\n\t\trem_scat -= len;\n\t\t \n\t\tlist_del(&packet->list);\n\n\t\tscat_req->scat_list[i].packet = packet;\n\t\t \n\t\tflags = packet->info.tx.flags | HTC_FLAGS_SEND_BUNDLE;\n\t\tath6kl_htc_tx_prep_pkt(packet, flags,\n\t\t\t\t       cred_pad, packet->info.tx.seqno);\n\t\t \n\t\tath6kl_htc_tx_buf_align(&packet->buf,\n\t\t\t\t\tpacket->act_len + HTC_HDR_LENGTH);\n\t\tscat_req->scat_list[i].buf = packet->buf;\n\t\tscat_req->scat_list[i].len = len;\n\n\t\tscat_req->len += len;\n\t\tscat_req->scat_entries++;\n\t\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t\t   \"htc tx adding (%d) pkt 0x%p seqno %d len %d remaining %d\\n\",\n\t\t\t   i, packet, packet->info.tx.seqno, len, rem_scat);\n\t}\n\n\t \n\tif (scat_req->scat_entries < HTC_MIN_HTC_MSGS_TO_BUNDLE) {\n\t\tfor (i = scat_req->scat_entries - 1; i >= 0; i--) {\n\t\t\tpacket = scat_req->scat_list[i].packet;\n\t\t\tif (packet) {\n\t\t\t\tpacket->buf += HTC_HDR_LENGTH;\n\t\t\t\tlist_add(&packet->list, queue);\n\t\t\t}\n\t\t}\n\t\treturn -EAGAIN;\n\t}\n\n\treturn status;\n}\n\n \nstatic void ath6kl_htc_tx_bundle(struct htc_endpoint *endpoint,\n\t\t\t\t struct list_head *queue,\n\t\t\t\t int *sent_bundle, int *n_bundle_pkts)\n{\n\tstruct htc_target *target = endpoint->target;\n\tstruct hif_scatter_req *scat_req = NULL;\n\tint n_scat, n_sent_bundle = 0, tot_pkts_bundle = 0, i;\n\tstruct htc_packet *packet;\n\tint status;\n\tu32 txb_mask;\n\tu8 ac = WMM_NUM_AC;\n\n\tif ((HTC_CTRL_RSVD_SVC != endpoint->svc_id) &&\n\t    (WMI_CONTROL_SVC != endpoint->svc_id))\n\t\tac = target->dev->ar->ep2ac_map[endpoint->eid];\n\n\twhile (true) {\n\t\tstatus = 0;\n\t\tn_scat = get_queue_depth(queue);\n\t\tn_scat = min(n_scat, target->msg_per_bndl_max);\n\n\t\tif (n_scat < HTC_MIN_HTC_MSGS_TO_BUNDLE)\n\t\t\t \n\t\t\tbreak;\n\n\t\tscat_req = hif_scatter_req_get(target->dev->ar);\n\n\t\tif (!scat_req) {\n\t\t\t \n\t\t\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t\t\t   \"htc tx no more scatter resources\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((ac < WMM_NUM_AC) && (ac != WMM_AC_BK)) {\n\t\t\tif (WMM_AC_BE == ac)\n\t\t\t\t \n\t\t\t\ttxb_mask = (1 << WMM_AC_BK);\n\t\t\telse\n\t\t\t\t \n\t\t\t\ttxb_mask = ((1 << ac) - 1);\n\n\t\t\t \n\t\t\tif (scat_req->scat_q_depth < ATH6KL_SCATTER_REQS)\n\t\t\t\ttarget->tx_bndl_mask &= ~txb_mask;\n\t\t\telse\n\t\t\t\ttarget->tx_bndl_mask |= txb_mask;\n\t\t}\n\n\t\tath6kl_dbg(ATH6KL_DBG_HTC, \"htc tx pkts to scatter: %d\\n\",\n\t\t\t   n_scat);\n\n\t\tscat_req->len = 0;\n\t\tscat_req->scat_entries = 0;\n\n\t\tstatus = ath6kl_htc_tx_setup_scat_list(target, endpoint,\n\t\t\t\t\t\t       scat_req, n_scat,\n\t\t\t\t\t\t       queue);\n\t\tif (status == -EAGAIN) {\n\t\t\thif_scatter_req_add(target->dev->ar, scat_req);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tscat_req->complete = htc_async_tx_scat_complete;\n\t\tn_sent_bundle++;\n\t\ttot_pkts_bundle += scat_req->scat_entries;\n\n\t\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t\t   \"htc tx scatter bytes %d entries %d\\n\",\n\t\t\t   scat_req->len, scat_req->scat_entries);\n\n\t\tfor (i = 0; i < scat_req->scat_entries; i++) {\n\t\t\tpacket = scat_req->scat_list[i].packet;\n\t\t\ttrace_ath6kl_htc_tx(packet->status, packet->endpoint,\n\t\t\t\t\t    packet->buf, packet->act_len);\n\t\t}\n\n\t\tath6kl_hif_submit_scat_req(target->dev, scat_req, false);\n\n\t\tif (status)\n\t\t\tbreak;\n\t}\n\n\t*sent_bundle = n_sent_bundle;\n\t*n_bundle_pkts = tot_pkts_bundle;\n\tath6kl_dbg(ATH6KL_DBG_HTC, \"htc tx bundle sent %d pkts\\n\",\n\t\t   n_sent_bundle);\n\n\treturn;\n}\n\nstatic void ath6kl_htc_tx_from_queue(struct htc_target *target,\n\t\t\t\t     struct htc_endpoint *endpoint)\n{\n\tstruct list_head txq;\n\tstruct htc_packet *packet;\n\tint bundle_sent;\n\tint n_pkts_bundle;\n\tu8 ac = WMM_NUM_AC;\n\tint status;\n\n\tspin_lock_bh(&target->tx_lock);\n\n\tendpoint->tx_proc_cnt++;\n\tif (endpoint->tx_proc_cnt > 1) {\n\t\tendpoint->tx_proc_cnt--;\n\t\tspin_unlock_bh(&target->tx_lock);\n\t\tath6kl_dbg(ATH6KL_DBG_HTC, \"htc tx busy\\n\");\n\t\treturn;\n\t}\n\n\t \n\tINIT_LIST_HEAD(&txq);\n\n\tif ((HTC_CTRL_RSVD_SVC != endpoint->svc_id) &&\n\t    (WMI_CONTROL_SVC != endpoint->svc_id))\n\t\tac = target->dev->ar->ep2ac_map[endpoint->eid];\n\n\twhile (true) {\n\t\tif (list_empty(&endpoint->txq))\n\t\t\tbreak;\n\n\t\tath6kl_htc_tx_pkts_get(target, endpoint, &txq);\n\n\t\tif (list_empty(&txq))\n\t\t\tbreak;\n\n\t\tspin_unlock_bh(&target->tx_lock);\n\n\t\tbundle_sent = 0;\n\t\tn_pkts_bundle = 0;\n\n\t\twhile (true) {\n\t\t\t \n\t\t\tif ((target->tx_bndl_mask) &&\n\t\t\t    (get_queue_depth(&txq) >=\n\t\t\t    HTC_MIN_HTC_MSGS_TO_BUNDLE)) {\n\t\t\t\tint temp1 = 0, temp2 = 0;\n\n\t\t\t\t \n\t\t\t\tif (target->tx_bndl_mask & (1 << ac)) {\n\t\t\t\t\tath6kl_htc_tx_bundle(endpoint, &txq,\n\t\t\t\t\t\t\t     &temp1, &temp2);\n\t\t\t\t\tbundle_sent += temp1;\n\t\t\t\t\tn_pkts_bundle += temp2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (list_empty(&txq))\n\t\t\t\tbreak;\n\n\t\t\tpacket = list_first_entry(&txq, struct htc_packet,\n\t\t\t\t\t\t  list);\n\t\t\tlist_del(&packet->list);\n\n\t\t\tath6kl_htc_tx_prep_pkt(packet, packet->info.tx.flags,\n\t\t\t\t\t       0, packet->info.tx.seqno);\n\t\t\tstatus = ath6kl_htc_tx_issue(target, packet);\n\n\t\t\tif (status) {\n\t\t\t\tpacket->status = status;\n\t\t\t\tpacket->completion(packet->context, packet);\n\t\t\t}\n\t\t}\n\n\t\tspin_lock_bh(&target->tx_lock);\n\n\t\tendpoint->ep_st.tx_bundles += bundle_sent;\n\t\tendpoint->ep_st.tx_pkt_bundled += n_pkts_bundle;\n\n\t\t \n\t\tif (!bundle_sent) {\n\t\t\tif (!(target->tx_bndl_mask & (1 << ac)) &&\n\t\t\t    (ac < WMM_NUM_AC)) {\n\t\t\t\tif (++target->ac_tx_count[ac] >=\n\t\t\t\t\tTX_RESUME_BUNDLE_THRESHOLD) {\n\t\t\t\t\ttarget->ac_tx_count[ac] = 0;\n\t\t\t\t\ttarget->tx_bndl_mask |= (1 << ac);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (ac < WMM_NUM_AC)\n\t\t\t\ttarget->ac_tx_count[ac] = 0;\n\t\t}\n\t}\n\n\tendpoint->tx_proc_cnt = 0;\n\tspin_unlock_bh(&target->tx_lock);\n}\n\nstatic bool ath6kl_htc_tx_try(struct htc_target *target,\n\t\t\t      struct htc_endpoint *endpoint,\n\t\t\t      struct htc_packet *tx_pkt)\n{\n\tstruct htc_ep_callbacks ep_cb;\n\tint txq_depth;\n\tbool overflow = false;\n\n\tep_cb = endpoint->ep_cb;\n\n\tspin_lock_bh(&target->tx_lock);\n\ttxq_depth = get_queue_depth(&endpoint->txq);\n\tspin_unlock_bh(&target->tx_lock);\n\n\tif (txq_depth >= endpoint->max_txq_depth)\n\t\toverflow = true;\n\n\tif (overflow)\n\t\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t\t   \"htc tx overflow ep %d depth %d max %d\\n\",\n\t\t\t   endpoint->eid, txq_depth,\n\t\t\t   endpoint->max_txq_depth);\n\n\tif (overflow && ep_cb.tx_full) {\n\t\tif (ep_cb.tx_full(endpoint->target, tx_pkt) ==\n\t\t    HTC_SEND_FULL_DROP) {\n\t\t\tendpoint->ep_st.tx_dropped += 1;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tspin_lock_bh(&target->tx_lock);\n\tlist_add_tail(&tx_pkt->list, &endpoint->txq);\n\tspin_unlock_bh(&target->tx_lock);\n\n\tath6kl_htc_tx_from_queue(target, endpoint);\n\n\treturn true;\n}\n\nstatic void htc_chk_ep_txq(struct htc_target *target)\n{\n\tstruct htc_endpoint *endpoint;\n\tstruct htc_endpoint_credit_dist *cred_dist;\n\n\t \n\tlist_for_each_entry(cred_dist, &target->cred_dist_list, list) {\n\t\tendpoint = cred_dist->htc_ep;\n\n\t\tspin_lock_bh(&target->tx_lock);\n\t\tif (!list_empty(&endpoint->txq)) {\n\t\t\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t\t\t   \"htc creds ep %d credits %d pkts %d\\n\",\n\t\t\t\t   cred_dist->endpoint,\n\t\t\t\t   endpoint->cred_dist.credits,\n\t\t\t\t   get_queue_depth(&endpoint->txq));\n\t\t\tspin_unlock_bh(&target->tx_lock);\n\t\t\t \n\t\t\tath6kl_htc_tx_from_queue(target, endpoint);\n\t\t\tspin_lock_bh(&target->tx_lock);\n\t\t}\n\t\tspin_unlock_bh(&target->tx_lock);\n\t}\n}\n\nstatic int htc_setup_tx_complete(struct htc_target *target)\n{\n\tstruct htc_packet *send_pkt = NULL;\n\tint status;\n\n\tsend_pkt = htc_get_control_buf(target, true);\n\n\tif (!send_pkt)\n\t\treturn -ENOMEM;\n\n\tif (target->htc_tgt_ver >= HTC_VERSION_2P1) {\n\t\tstruct htc_setup_comp_ext_msg *setup_comp_ext;\n\t\tu32 flags = 0;\n\n\t\tsetup_comp_ext =\n\t\t    (struct htc_setup_comp_ext_msg *)send_pkt->buf;\n\t\tmemset(setup_comp_ext, 0, sizeof(*setup_comp_ext));\n\t\tsetup_comp_ext->msg_id =\n\t\t\tcpu_to_le16(HTC_MSG_SETUP_COMPLETE_EX_ID);\n\n\t\tif (target->msg_per_bndl_max > 0) {\n\t\t\t \n\t\t\tflags |= HTC_SETUP_COMP_FLG_RX_BNDL_EN;\n\t\t\tsetup_comp_ext->msg_per_rxbndl =\n\t\t\t\t\t\ttarget->msg_per_bndl_max;\n\t\t}\n\n\t\tmemcpy(&setup_comp_ext->flags, &flags,\n\t\t       sizeof(setup_comp_ext->flags));\n\t\tset_htc_pkt_info(send_pkt, NULL, (u8 *) setup_comp_ext,\n\t\t\t\t sizeof(struct htc_setup_comp_ext_msg),\n\t\t\t\t ENDPOINT_0, HTC_SERVICE_TX_PACKET_TAG);\n\n\t} else {\n\t\tstruct htc_setup_comp_msg *setup_comp;\n\t\tsetup_comp = (struct htc_setup_comp_msg *)send_pkt->buf;\n\t\tmemset(setup_comp, 0, sizeof(struct htc_setup_comp_msg));\n\t\tsetup_comp->msg_id = cpu_to_le16(HTC_MSG_SETUP_COMPLETE_ID);\n\t\tset_htc_pkt_info(send_pkt, NULL, (u8 *) setup_comp,\n\t\t\t\t sizeof(struct htc_setup_comp_msg),\n\t\t\t\t ENDPOINT_0, HTC_SERVICE_TX_PACKET_TAG);\n\t}\n\n\t \n\tsend_pkt->completion = NULL;\n\tath6kl_htc_tx_prep_pkt(send_pkt, 0, 0, 0);\n\tstatus = ath6kl_htc_tx_issue(target, send_pkt);\n\thtc_reclaim_txctrl_buf(target, send_pkt);\n\n\treturn status;\n}\n\nstatic void ath6kl_htc_set_credit_dist(struct htc_target *target,\n\t\t\t\tstruct ath6kl_htc_credit_info *credit_info,\n\t\t\t\tu16 srvc_pri_order[], int list_len)\n{\n\tstruct htc_endpoint *endpoint;\n\tint i, ep;\n\n\ttarget->credit_info = credit_info;\n\n\tlist_add_tail(&target->endpoint[ENDPOINT_0].cred_dist.list,\n\t\t      &target->cred_dist_list);\n\n\tfor (i = 0; i < list_len; i++) {\n\t\tfor (ep = ENDPOINT_1; ep < ENDPOINT_MAX; ep++) {\n\t\t\tendpoint = &target->endpoint[ep];\n\t\t\tif (endpoint->svc_id == srvc_pri_order[i]) {\n\t\t\t\tlist_add_tail(&endpoint->cred_dist.list,\n\t\t\t\t\t      &target->cred_dist_list);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ep >= ENDPOINT_MAX) {\n\t\t\tWARN_ON(1);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic int ath6kl_htc_mbox_tx(struct htc_target *target,\n\t\t\t      struct htc_packet *packet)\n{\n\tstruct htc_endpoint *endpoint;\n\tstruct list_head queue;\n\n\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t   \"htc tx ep id %d buf 0x%p len %d\\n\",\n\t\t   packet->endpoint, packet->buf, packet->act_len);\n\n\tif (packet->endpoint >= ENDPOINT_MAX) {\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\tendpoint = &target->endpoint[packet->endpoint];\n\n\tif (!ath6kl_htc_tx_try(target, endpoint, packet)) {\n\t\tpacket->status = (target->htc_flags & HTC_OP_STATE_STOPPING) ?\n\t\t\t\t -ECANCELED : -ENOSPC;\n\t\tINIT_LIST_HEAD(&queue);\n\t\tlist_add(&packet->list, &queue);\n\t\thtc_tx_complete(endpoint, &queue);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void ath6kl_htc_mbox_flush_txep(struct htc_target *target,\n\t\t\t   enum htc_endpoint_id eid, u16 tag)\n{\n\tstruct htc_packet *packet, *tmp_pkt;\n\tstruct list_head discard_q, container;\n\tstruct htc_endpoint *endpoint = &target->endpoint[eid];\n\n\tif (!endpoint->svc_id) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t \n\tINIT_LIST_HEAD(&discard_q);\n\n\tspin_lock_bh(&target->tx_lock);\n\n\tlist_for_each_entry_safe(packet, tmp_pkt, &endpoint->txq, list) {\n\t\tif ((tag == HTC_TX_PACKET_TAG_ALL) ||\n\t\t    (tag == packet->info.tx.tag))\n\t\t\tlist_move_tail(&packet->list, &discard_q);\n\t}\n\n\tspin_unlock_bh(&target->tx_lock);\n\n\tlist_for_each_entry_safe(packet, tmp_pkt, &discard_q, list) {\n\t\tpacket->status = -ECANCELED;\n\t\tlist_del(&packet->list);\n\t\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t\t   \"htc tx flushing pkt 0x%p len %d  ep %d tag 0x%x\\n\",\n\t\t\t   packet, packet->act_len,\n\t\t\t   packet->endpoint, packet->info.tx.tag);\n\n\t\tINIT_LIST_HEAD(&container);\n\t\tlist_add_tail(&packet->list, &container);\n\t\thtc_tx_complete(endpoint, &container);\n\t}\n}\n\nstatic void ath6kl_htc_flush_txep_all(struct htc_target *target)\n{\n\tstruct htc_endpoint *endpoint;\n\tint i;\n\n\tdump_cred_dist_stats(target);\n\n\tfor (i = ENDPOINT_0; i < ENDPOINT_MAX; i++) {\n\t\tendpoint = &target->endpoint[i];\n\t\tif (endpoint->svc_id == 0)\n\t\t\t \n\t\t\tcontinue;\n\t\tath6kl_htc_mbox_flush_txep(target, i, HTC_TX_PACKET_TAG_ALL);\n\t}\n}\n\nstatic void ath6kl_htc_mbox_activity_changed(struct htc_target *target,\n\t\t\t\t\t     enum htc_endpoint_id eid,\n\t\t\t\t\t     bool active)\n{\n\tstruct htc_endpoint *endpoint = &target->endpoint[eid];\n\tbool dist = false;\n\n\tif (endpoint->svc_id == 0) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\tspin_lock_bh(&target->tx_lock);\n\n\tif (active) {\n\t\tif (!(endpoint->cred_dist.dist_flags & HTC_EP_ACTIVE)) {\n\t\t\tendpoint->cred_dist.dist_flags |= HTC_EP_ACTIVE;\n\t\t\tdist = true;\n\t\t}\n\t} else {\n\t\tif (endpoint->cred_dist.dist_flags & HTC_EP_ACTIVE) {\n\t\t\tendpoint->cred_dist.dist_flags &= ~HTC_EP_ACTIVE;\n\t\t\tdist = true;\n\t\t}\n\t}\n\n\tif (dist) {\n\t\tendpoint->cred_dist.txq_depth =\n\t\t\tget_queue_depth(&endpoint->txq);\n\n\t\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t\t   \"htc tx activity ctxt 0x%p dist 0x%p\\n\",\n\t\t\t   target->credit_info, &target->cred_dist_list);\n\n\t\tath6kl_credit_distribute(target->credit_info,\n\t\t\t\t\t &target->cred_dist_list,\n\t\t\t\t\t HTC_CREDIT_DIST_ACTIVITY_CHANGE);\n\t}\n\n\tspin_unlock_bh(&target->tx_lock);\n\n\tif (dist && !active)\n\t\thtc_chk_ep_txq(target);\n}\n\n \n\nstatic inline void ath6kl_htc_rx_update_stats(struct htc_endpoint *endpoint,\n\t\t\t\t\t      int n_look_ahds)\n{\n\tendpoint->ep_st.rx_pkts++;\n\tif (n_look_ahds == 1)\n\t\tendpoint->ep_st.rx_lkahds++;\n\telse if (n_look_ahds > 1)\n\t\tendpoint->ep_st.rx_bundle_lkahd++;\n}\n\nstatic inline bool htc_valid_rx_frame_len(struct htc_target *target,\n\t\t\t\t\t  enum htc_endpoint_id eid, int len)\n{\n\treturn (eid == target->dev->ar->ctrl_ep) ?\n\t\tlen <= ATH6KL_BUFFER_SIZE : len <= ATH6KL_AMSDU_BUFFER_SIZE;\n}\n\nstatic int htc_add_rxbuf(struct htc_target *target, struct htc_packet *packet)\n{\n\tstruct list_head queue;\n\n\tINIT_LIST_HEAD(&queue);\n\tlist_add_tail(&packet->list, &queue);\n\treturn ath6kl_htc_mbox_add_rxbuf_multiple(target, &queue);\n}\n\nstatic void htc_reclaim_rxbuf(struct htc_target *target,\n\t\t\t      struct htc_packet *packet,\n\t\t\t      struct htc_endpoint *ep)\n{\n\tif (packet->info.rx.rx_flags & HTC_RX_PKT_NO_RECYCLE) {\n\t\thtc_rxpkt_reset(packet);\n\t\tpacket->status = -ECANCELED;\n\t\tep->ep_cb.rx(ep->target, packet);\n\t} else {\n\t\thtc_rxpkt_reset(packet);\n\t\thtc_add_rxbuf((void *)(target), packet);\n\t}\n}\n\nstatic void reclaim_rx_ctrl_buf(struct htc_target *target,\n\t\t\t\tstruct htc_packet *packet)\n{\n\tspin_lock_bh(&target->htc_lock);\n\tlist_add_tail(&packet->list, &target->free_ctrl_rxbuf);\n\tspin_unlock_bh(&target->htc_lock);\n}\n\nstatic int ath6kl_htc_rx_packet(struct htc_target *target,\n\t\t\t\tstruct htc_packet *packet,\n\t\t\t\tu32 rx_len)\n{\n\tstruct ath6kl_device *dev = target->dev;\n\tu32 padded_len;\n\tint status;\n\n\tpadded_len = CALC_TXRX_PADDED_LEN(target, rx_len);\n\n\tif (padded_len > packet->buf_len) {\n\t\tath6kl_err(\"not enough receive space for packet - padlen %d recvlen %d bufferlen %d\\n\",\n\t\t\t   padded_len, rx_len, packet->buf_len);\n\t\treturn -ENOMEM;\n\t}\n\n\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t   \"htc rx 0x%p hdr 0x%x len %d mbox 0x%x\\n\",\n\t\t   packet, packet->info.rx.exp_hdr,\n\t\t   padded_len, dev->ar->mbox_info.htc_addr);\n\n\tstatus = hif_read_write_sync(dev->ar,\n\t\t\t\t     dev->ar->mbox_info.htc_addr,\n\t\t\t\t     packet->buf, padded_len,\n\t\t\t\t     HIF_RD_SYNC_BLOCK_FIX);\n\n\tpacket->status = status;\n\n\treturn status;\n}\n\n \nstatic void ath6kl_htc_rx_set_indicate(u32 lk_ahd,\n\t\t\t\t       struct htc_endpoint *endpoint,\n\t\t\t\t       struct htc_packet *packet)\n{\n\tstruct htc_frame_hdr *htc_hdr = (struct htc_frame_hdr *)&lk_ahd;\n\n\tif (htc_hdr->eid == packet->endpoint) {\n\t\tif (!list_empty(&endpoint->rx_bufq))\n\t\t\tpacket->info.rx.indicat_flags |=\n\t\t\t\t\tHTC_RX_FLAGS_INDICATE_MORE_PKTS;\n\t}\n}\n\nstatic void ath6kl_htc_rx_chk_water_mark(struct htc_endpoint *endpoint)\n{\n\tstruct htc_ep_callbacks ep_cb = endpoint->ep_cb;\n\n\tif (ep_cb.rx_refill_thresh > 0) {\n\t\tspin_lock_bh(&endpoint->target->rx_lock);\n\t\tif (get_queue_depth(&endpoint->rx_bufq)\n\t\t    < ep_cb.rx_refill_thresh) {\n\t\t\tspin_unlock_bh(&endpoint->target->rx_lock);\n\t\t\tep_cb.rx_refill(endpoint->target, endpoint->eid);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock_bh(&endpoint->target->rx_lock);\n\t}\n}\n\n \nstatic int ath6kl_htc_rx_setup(struct htc_target *target,\n\t\t\t       struct htc_endpoint *ep,\n\t\t\t       u32 *lk_ahds, struct list_head *queue, int n_msg)\n{\n\tstruct htc_packet *packet;\n\t \n\tstruct htc_frame_hdr *htc_hdr = (struct htc_frame_hdr *)lk_ahds;\n\tstruct htc_ep_callbacks ep_cb;\n\tint status = 0, j, full_len;\n\tbool no_recycle;\n\n\tfull_len = CALC_TXRX_PADDED_LEN(target,\n\t\t\t\t\tle16_to_cpu(htc_hdr->payld_len) +\n\t\t\t\t\tsizeof(*htc_hdr));\n\n\tif (!htc_valid_rx_frame_len(target, ep->eid, full_len)) {\n\t\tath6kl_warn(\"Rx buffer requested with invalid length htc_hdr:eid %d, flags 0x%x, len %d\\n\",\n\t\t\t    htc_hdr->eid, htc_hdr->flags,\n\t\t\t    le16_to_cpu(htc_hdr->payld_len));\n\t\treturn -EINVAL;\n\t}\n\n\tep_cb = ep->ep_cb;\n\tfor (j = 0; j < n_msg; j++) {\n\t\t \n\t\tno_recycle = false;\n\n\t\tif (ep_cb.rx_allocthresh &&\n\t\t    (full_len > ep_cb.rx_alloc_thresh)) {\n\t\t\tep->ep_st.rx_alloc_thresh_hit += 1;\n\t\t\tep->ep_st.rxalloc_thresh_byte +=\n\t\t\t\tle16_to_cpu(htc_hdr->payld_len);\n\n\t\t\tspin_unlock_bh(&target->rx_lock);\n\t\t\tno_recycle = true;\n\n\t\t\tpacket = ep_cb.rx_allocthresh(ep->target, ep->eid,\n\t\t\t\t\t\t      full_len);\n\t\t\tspin_lock_bh(&target->rx_lock);\n\t\t} else {\n\t\t\t \n\t\t\tif (list_empty(&ep->rx_bufq)) {\n\t\t\t\tif (ep_cb.rx_refill) {\n\t\t\t\t\tspin_unlock_bh(&target->rx_lock);\n\t\t\t\t\tep_cb.rx_refill(ep->target, ep->eid);\n\t\t\t\t\tspin_lock_bh(&target->rx_lock);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (list_empty(&ep->rx_bufq)) {\n\t\t\t\tpacket = NULL;\n\t\t\t} else {\n\t\t\t\tpacket = list_first_entry(&ep->rx_bufq,\n\t\t\t\t\t\tstruct htc_packet, list);\n\t\t\t\tlist_del(&packet->list);\n\t\t\t}\n\t\t}\n\n\t\tif (!packet) {\n\t\t\ttarget->rx_st_flags |= HTC_RECV_WAIT_BUFFERS;\n\t\t\ttarget->ep_waiting = ep->eid;\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\t \n\t\tpacket->info.rx.rx_flags = 0;\n\t\tpacket->info.rx.indicat_flags = 0;\n\t\tpacket->status = 0;\n\n\t\tif (no_recycle)\n\t\t\t \n\t\t\tpacket->info.rx.rx_flags |= HTC_RX_PKT_NO_RECYCLE;\n\n\t\t \n\t\tlist_add_tail(&packet->list, queue);\n\n\t\tif (target->htc_flags & HTC_OP_STATE_STOPPING) {\n\t\t\tstatus = -ECANCELED;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (j) {\n\t\t\tpacket->info.rx.rx_flags |= HTC_RX_PKT_REFRESH_HDR;\n\t\t\tpacket->info.rx.exp_hdr = 0xFFFFFFFF;\n\t\t} else\n\t\t\t \n\t\t\tpacket->info.rx.exp_hdr = *lk_ahds;\n\n\t\tpacket->act_len = le16_to_cpu(htc_hdr->payld_len) +\n\t\t\tHTC_HDR_LENGTH;\n\t}\n\n\treturn status;\n}\n\nstatic int ath6kl_htc_rx_alloc(struct htc_target *target,\n\t\t\t       u32 lk_ahds[], int msg,\n\t\t\t       struct htc_endpoint *endpoint,\n\t\t\t       struct list_head *queue)\n{\n\tint status = 0;\n\tstruct htc_packet *packet, *tmp_pkt;\n\tstruct htc_frame_hdr *htc_hdr;\n\tint i, n_msg;\n\n\tspin_lock_bh(&target->rx_lock);\n\n\tfor (i = 0; i < msg; i++) {\n\t\thtc_hdr = (struct htc_frame_hdr *)&lk_ahds[i];\n\n\t\tif (htc_hdr->eid >= ENDPOINT_MAX) {\n\t\t\tath6kl_err(\"invalid ep in look-ahead: %d\\n\",\n\t\t\t\t   htc_hdr->eid);\n\t\t\tstatus = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (htc_hdr->eid != endpoint->eid) {\n\t\t\tath6kl_err(\"invalid ep in look-ahead: %d should be : %d (index:%d)\\n\",\n\t\t\t\t   htc_hdr->eid, endpoint->eid, i);\n\t\t\tstatus = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (le16_to_cpu(htc_hdr->payld_len) > HTC_MAX_PAYLOAD_LENGTH) {\n\t\t\tath6kl_err(\"payload len %d exceeds max htc : %d !\\n\",\n\t\t\t\t   htc_hdr->payld_len,\n\t\t\t\t   (u32) HTC_MAX_PAYLOAD_LENGTH);\n\t\t\tstatus = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (endpoint->svc_id == 0) {\n\t\t\tath6kl_err(\"ep %d is not connected !\\n\", htc_hdr->eid);\n\t\t\tstatus = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (htc_hdr->flags & HTC_FLG_RX_BNDL_CNT) {\n\t\t\t \n\t\t\tn_msg = (htc_hdr->flags & HTC_FLG_RX_BNDL_CNT) >>\n\t\t\t\tHTC_FLG_RX_BNDL_CNT_S;\n\n\t\t\t \n\t\t\tn_msg++;\n\t\t\tif (n_msg > target->msg_per_bndl_max) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tendpoint->ep_st.rx_bundle_from_hdr += 1;\n\t\t\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t\t\t   \"htc rx bundle pkts %d\\n\",\n\t\t\t\t   n_msg);\n\t\t} else\n\t\t\t \n\t\t\tn_msg = 1;\n\n\t\t \n\t\tstatus = ath6kl_htc_rx_setup(target, endpoint, &lk_ahds[i],\n\t\t\t\t\t     queue, n_msg);\n\n\t\t \n\t\tif (status == -ENOSPC) {\n\t\t\tspin_unlock_bh(&target->rx_lock);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (status)\n\t\t\tbreak;\n\t}\n\n\tspin_unlock_bh(&target->rx_lock);\n\n\tif (status) {\n\t\tlist_for_each_entry_safe(packet, tmp_pkt, queue, list) {\n\t\t\tlist_del(&packet->list);\n\t\t\thtc_reclaim_rxbuf(target, packet,\n\t\t\t\t\t  &target->endpoint[packet->endpoint]);\n\t\t}\n\t}\n\n\treturn status;\n}\n\nstatic void htc_ctrl_rx(struct htc_target *context, struct htc_packet *packets)\n{\n\tif (packets->endpoint != ENDPOINT_0) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\tif (packets->status == -ECANCELED) {\n\t\treclaim_rx_ctrl_buf(context, packets);\n\t\treturn;\n\t}\n\n\tif (packets->act_len > 0) {\n\t\tath6kl_err(\"htc_ctrl_rx, got message with len:%zu\\n\",\n\t\t\t   packets->act_len + HTC_HDR_LENGTH);\n\n\t\tath6kl_dbg_dump(ATH6KL_DBG_HTC,\n\t\t\t\t\"htc rx unexpected endpoint 0 message\", \"\",\n\t\t\t\tpackets->buf - HTC_HDR_LENGTH,\n\t\t\t\tpackets->act_len + HTC_HDR_LENGTH);\n\t}\n\n\thtc_reclaim_rxbuf(context, packets, &context->endpoint[0]);\n}\n\nstatic void htc_proc_cred_rpt(struct htc_target *target,\n\t\t\t      struct htc_credit_report *rpt,\n\t\t\t      int n_entries,\n\t\t\t      enum htc_endpoint_id from_ep)\n{\n\tstruct htc_endpoint *endpoint;\n\tint tot_credits = 0, i;\n\tbool dist = false;\n\n\tspin_lock_bh(&target->tx_lock);\n\n\tfor (i = 0; i < n_entries; i++, rpt++) {\n\t\tif (rpt->eid >= ENDPOINT_MAX) {\n\t\t\tWARN_ON(1);\n\t\t\tspin_unlock_bh(&target->tx_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tendpoint = &target->endpoint[rpt->eid];\n\n\t\tath6kl_dbg(ATH6KL_DBG_CREDIT,\n\t\t\t   \"credit report ep %d credits %d\\n\",\n\t\t\t   rpt->eid, rpt->credits);\n\n\t\tendpoint->ep_st.tx_cred_rpt += 1;\n\t\tendpoint->ep_st.cred_retnd += rpt->credits;\n\n\t\tif (from_ep == rpt->eid) {\n\t\t\t \n\t\t\tendpoint->ep_st.cred_from_rx += rpt->credits;\n\t\t\tendpoint->ep_st.cred_rpt_from_rx += 1;\n\t\t} else if (from_ep == ENDPOINT_0) {\n\t\t\t \n\t\t\tendpoint->ep_st.cred_from_ep0 += rpt->credits;\n\t\t\tendpoint->ep_st.cred_rpt_ep0 += 1;\n\t\t} else {\n\t\t\tendpoint->ep_st.cred_from_other += rpt->credits;\n\t\t\tendpoint->ep_st.cred_rpt_from_other += 1;\n\t\t}\n\n\t\tif (rpt->eid == ENDPOINT_0)\n\t\t\t \n\t\t\tendpoint->cred_dist.credits += rpt->credits;\n\t\telse {\n\t\t\tendpoint->cred_dist.cred_to_dist += rpt->credits;\n\t\t\tdist = true;\n\t\t}\n\n\t\t \n\t\tendpoint->cred_dist.txq_depth =\n\t\t\tget_queue_depth(&endpoint->txq);\n\n\t\ttot_credits += rpt->credits;\n\t}\n\n\tif (dist) {\n\t\t \n\t\tath6kl_credit_distribute(target->credit_info,\n\t\t\t\t\t &target->cred_dist_list,\n\t\t\t\t\t HTC_CREDIT_DIST_SEND_COMPLETE);\n\t}\n\n\tspin_unlock_bh(&target->tx_lock);\n\n\tif (tot_credits)\n\t\thtc_chk_ep_txq(target);\n}\n\nstatic int htc_parse_trailer(struct htc_target *target,\n\t\t\t     struct htc_record_hdr *record,\n\t\t\t     u8 *record_buf, u32 *next_lk_ahds,\n\t\t\t     enum htc_endpoint_id endpoint,\n\t\t\t     int *n_lk_ahds)\n{\n\tstruct htc_bundle_lkahd_rpt *bundle_lkahd_rpt;\n\tstruct htc_lookahead_report *lk_ahd;\n\tint len;\n\n\tswitch (record->rec_id) {\n\tcase HTC_RECORD_CREDITS:\n\t\tlen = record->len / sizeof(struct htc_credit_report);\n\t\tif (!len) {\n\t\t\tWARN_ON(1);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\thtc_proc_cred_rpt(target,\n\t\t\t\t  (struct htc_credit_report *) record_buf,\n\t\t\t\t  len, endpoint);\n\t\tbreak;\n\tcase HTC_RECORD_LOOKAHEAD:\n\t\tlen = record->len / sizeof(*lk_ahd);\n\t\tif (!len) {\n\t\t\tWARN_ON(1);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tlk_ahd = (struct htc_lookahead_report *) record_buf;\n\t\tif ((lk_ahd->pre_valid == ((~lk_ahd->post_valid) & 0xFF)) &&\n\t\t    next_lk_ahds) {\n\t\t\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t\t\t   \"htc rx lk_ahd found pre_valid 0x%x post_valid 0x%x\\n\",\n\t\t\t\t   lk_ahd->pre_valid, lk_ahd->post_valid);\n\n\t\t\t \n\t\t\tmemcpy((u8 *)&next_lk_ahds[0], lk_ahd->lk_ahd, 4);\n\n\t\t\tath6kl_dbg_dump(ATH6KL_DBG_HTC,\n\t\t\t\t\t\"htc rx next look ahead\",\n\t\t\t\t\t\"\", next_lk_ahds, 4);\n\n\t\t\t*n_lk_ahds = 1;\n\t\t}\n\t\tbreak;\n\tcase HTC_RECORD_LOOKAHEAD_BUNDLE:\n\t\tlen = record->len / sizeof(*bundle_lkahd_rpt);\n\t\tif (!len || (len > HTC_HOST_MAX_MSG_PER_BUNDLE)) {\n\t\t\tWARN_ON(1);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (next_lk_ahds) {\n\t\t\tint i;\n\n\t\t\tbundle_lkahd_rpt =\n\t\t\t\t(struct htc_bundle_lkahd_rpt *) record_buf;\n\n\t\t\tath6kl_dbg_dump(ATH6KL_DBG_HTC, \"htc rx bundle lk_ahd\",\n\t\t\t\t\t\"\", record_buf, record->len);\n\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tmemcpy((u8 *)&next_lk_ahds[i],\n\t\t\t\t       bundle_lkahd_rpt->lk_ahd, 4);\n\t\t\t\tbundle_lkahd_rpt++;\n\t\t\t}\n\n\t\t\t*n_lk_ahds = i;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tath6kl_err(\"unhandled record: id:%d len:%d\\n\",\n\t\t\t   record->rec_id, record->len);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int htc_proc_trailer(struct htc_target *target,\n\t\t\t    u8 *buf, int len, u32 *next_lk_ahds,\n\t\t\t    int *n_lk_ahds, enum htc_endpoint_id endpoint)\n{\n\tstruct htc_record_hdr *record;\n\tint orig_len;\n\tint status;\n\tu8 *record_buf;\n\tu8 *orig_buf;\n\n\tath6kl_dbg(ATH6KL_DBG_HTC, \"htc rx trailer len %d\\n\", len);\n\tath6kl_dbg_dump(ATH6KL_DBG_HTC, NULL, \"\", buf, len);\n\n\torig_buf = buf;\n\torig_len = len;\n\tstatus = 0;\n\n\twhile (len > 0) {\n\t\tif (len < sizeof(struct htc_record_hdr)) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\trecord = (struct htc_record_hdr *) buf;\n\t\tlen -= sizeof(struct htc_record_hdr);\n\t\tbuf += sizeof(struct htc_record_hdr);\n\n\t\tif (record->len > len) {\n\t\t\tath6kl_err(\"invalid record len: %d (id:%d) buf has: %d bytes left\\n\",\n\t\t\t\t   record->len, record->rec_id, len);\n\t\t\tstatus = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\trecord_buf = buf;\n\n\t\tstatus = htc_parse_trailer(target, record, record_buf,\n\t\t\t\t\t   next_lk_ahds, endpoint, n_lk_ahds);\n\n\t\tif (status)\n\t\t\tbreak;\n\n\t\t \n\t\tbuf += record->len;\n\t\tlen -= record->len;\n\t}\n\n\tif (status)\n\t\tath6kl_dbg_dump(ATH6KL_DBG_HTC, \"htc rx bad trailer\",\n\t\t\t\t\"\", orig_buf, orig_len);\n\n\treturn status;\n}\n\nstatic int ath6kl_htc_rx_process_hdr(struct htc_target *target,\n\t\t\t\t     struct htc_packet *packet,\n\t\t\t\t     u32 *next_lkahds, int *n_lkahds)\n{\n\tint status = 0;\n\tu16 payload_len;\n\tu32 lk_ahd;\n\tstruct htc_frame_hdr *htc_hdr = (struct htc_frame_hdr *)packet->buf;\n\n\tif (n_lkahds != NULL)\n\t\t*n_lkahds = 0;\n\n\t \n\tpayload_len = le16_to_cpu(get_unaligned(&htc_hdr->payld_len));\n\n\tmemcpy((u8 *)&lk_ahd, packet->buf, sizeof(lk_ahd));\n\n\tif (packet->info.rx.rx_flags & HTC_RX_PKT_REFRESH_HDR) {\n\t\t \n\t\tpacket->info.rx.exp_hdr = lk_ahd;\n\t\tpacket->act_len = payload_len + HTC_HDR_LENGTH;\n\n\t\t \n\t\tif (packet->act_len > packet->buf_len) {\n\t\t\tath6kl_err(\"refreshed hdr payload len (%d) in bundled recv is invalid (hdr: 0x%X)\\n\",\n\t\t\t\t   payload_len, lk_ahd);\n\t\t\t \n\t\t\tpacket->act_len = min(packet->act_len, packet->buf_len);\n\t\t\tstatus = -ENOMEM;\n\t\t\tgoto fail_rx;\n\t\t}\n\n\t\tif (packet->endpoint != htc_hdr->eid) {\n\t\t\tath6kl_err(\"refreshed hdr ep (%d) does not match expected ep (%d)\\n\",\n\t\t\t\t   htc_hdr->eid, packet->endpoint);\n\t\t\tstatus = -ENOMEM;\n\t\t\tgoto fail_rx;\n\t\t}\n\t}\n\n\tif (lk_ahd != packet->info.rx.exp_hdr) {\n\t\tath6kl_err(\"%s(): lk_ahd mismatch! (pPkt:0x%p flags:0x%X)\\n\",\n\t\t\t   __func__, packet, packet->info.rx.rx_flags);\n\t\tath6kl_dbg_dump(ATH6KL_DBG_HTC, \"htc rx expected lk_ahd\",\n\t\t\t\t\"\", &packet->info.rx.exp_hdr, 4);\n\t\tath6kl_dbg_dump(ATH6KL_DBG_HTC, \"htc rx current header\",\n\t\t\t\t\"\", (u8 *)&lk_ahd, sizeof(lk_ahd));\n\t\tstatus = -ENOMEM;\n\t\tgoto fail_rx;\n\t}\n\n\tif (htc_hdr->flags & HTC_FLG_RX_TRAILER) {\n\t\tif (htc_hdr->ctrl[0] < sizeof(struct htc_record_hdr) ||\n\t\t    htc_hdr->ctrl[0] > payload_len) {\n\t\t\tath6kl_err(\"%s(): invalid hdr (payload len should be :%d, CB[0] is:%d)\\n\",\n\t\t\t\t   __func__, payload_len, htc_hdr->ctrl[0]);\n\t\t\tstatus = -ENOMEM;\n\t\t\tgoto fail_rx;\n\t\t}\n\n\t\tif (packet->info.rx.rx_flags & HTC_RX_PKT_IGNORE_LOOKAHEAD) {\n\t\t\tnext_lkahds = NULL;\n\t\t\tn_lkahds = NULL;\n\t\t}\n\n\t\tstatus = htc_proc_trailer(target, packet->buf + HTC_HDR_LENGTH\n\t\t\t\t\t  + payload_len - htc_hdr->ctrl[0],\n\t\t\t\t\t  htc_hdr->ctrl[0], next_lkahds,\n\t\t\t\t\t   n_lkahds, packet->endpoint);\n\n\t\tif (status)\n\t\t\tgoto fail_rx;\n\n\t\tpacket->act_len -= htc_hdr->ctrl[0];\n\t}\n\n\tpacket->buf += HTC_HDR_LENGTH;\n\tpacket->act_len -= HTC_HDR_LENGTH;\n\nfail_rx:\n\tif (status)\n\t\tath6kl_dbg_dump(ATH6KL_DBG_HTC, \"htc rx bad packet\",\n\t\t\t\t\"\", packet->buf, packet->act_len);\n\n\treturn status;\n}\n\nstatic void ath6kl_htc_rx_complete(struct htc_endpoint *endpoint,\n\t\t\t\t   struct htc_packet *packet)\n{\n\t\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t\t   \"htc rx complete ep %d packet 0x%p\\n\",\n\t\t\t   endpoint->eid, packet);\n\n\t\tendpoint->ep_cb.rx(endpoint->target, packet);\n}\n\nstatic int ath6kl_htc_rx_bundle(struct htc_target *target,\n\t\t\t\tstruct list_head *rxq,\n\t\t\t\tstruct list_head *sync_compq,\n\t\t\t\tint *n_pkt_fetched, bool part_bundle)\n{\n\tstruct hif_scatter_req *scat_req;\n\tstruct htc_packet *packet;\n\tint rem_space = target->max_rx_bndl_sz;\n\tint n_scat_pkt, status = 0, i, len;\n\n\tn_scat_pkt = get_queue_depth(rxq);\n\tn_scat_pkt = min(n_scat_pkt, target->msg_per_bndl_max);\n\n\tif ((get_queue_depth(rxq) - n_scat_pkt) > 0) {\n\t\t \n\t\tpart_bundle = true;\n\n\t\t \n\t\tath6kl_warn(\"%s(): partial bundle detected num:%d , %d\\n\",\n\t\t\t    __func__, get_queue_depth(rxq), n_scat_pkt);\n\t}\n\n\tlen = 0;\n\n\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t   \"htc rx bundle depth %d pkts %d\\n\",\n\t\t   get_queue_depth(rxq), n_scat_pkt);\n\n\tscat_req = hif_scatter_req_get(target->dev->ar);\n\n\tif (scat_req == NULL)\n\t\tgoto fail_rx_pkt;\n\n\tfor (i = 0; i < n_scat_pkt; i++) {\n\t\tint pad_len;\n\n\t\tpacket = list_first_entry(rxq, struct htc_packet, list);\n\t\tlist_del(&packet->list);\n\n\t\tpad_len = CALC_TXRX_PADDED_LEN(target,\n\t\t\t\t\t\t   packet->act_len);\n\n\t\tif ((rem_space - pad_len) < 0) {\n\t\t\tlist_add(&packet->list, rxq);\n\t\t\tbreak;\n\t\t}\n\n\t\trem_space -= pad_len;\n\n\t\tif (part_bundle || (i < (n_scat_pkt - 1)))\n\t\t\t \n\t\t\tpacket->info.rx.rx_flags |=\n\t\t\t    HTC_RX_PKT_IGNORE_LOOKAHEAD;\n\n\t\t \n\t\tscat_req->scat_list[i].buf = packet->buf;\n\t\tscat_req->scat_list[i].len = pad_len;\n\n\t\tpacket->info.rx.rx_flags |= HTC_RX_PKT_PART_OF_BUNDLE;\n\n\t\tlist_add_tail(&packet->list, sync_compq);\n\n\t\tWARN_ON(!scat_req->scat_list[i].len);\n\t\tlen += scat_req->scat_list[i].len;\n\t}\n\n\tscat_req->len = len;\n\tscat_req->scat_entries = i;\n\n\tstatus = ath6kl_hif_submit_scat_req(target->dev, scat_req, true);\n\n\tif (!status)\n\t\t*n_pkt_fetched = i;\n\n\t \n\thif_scatter_req_add(target->dev->ar, scat_req);\n\nfail_rx_pkt:\n\n\treturn status;\n}\n\nstatic int ath6kl_htc_rx_process_packets(struct htc_target *target,\n\t\t\t\t\t struct list_head *comp_pktq,\n\t\t\t\t\t u32 lk_ahds[],\n\t\t\t\t\t int *n_lk_ahd)\n{\n\tstruct htc_packet *packet, *tmp_pkt;\n\tstruct htc_endpoint *ep;\n\tint status = 0;\n\n\tlist_for_each_entry_safe(packet, tmp_pkt, comp_pktq, list) {\n\t\tep = &target->endpoint[packet->endpoint];\n\n\t\ttrace_ath6kl_htc_rx(packet->status, packet->endpoint,\n\t\t\t\t    packet->buf, packet->act_len);\n\n\t\t \n\t\tstatus = ath6kl_htc_rx_process_hdr(target, packet, lk_ahds,\n\t\t\t\t\t\t   n_lk_ahd);\n\t\tif (status)\n\t\t\treturn status;\n\n\t\tlist_del(&packet->list);\n\n\t\tif (list_empty(comp_pktq)) {\n\t\t\t \n\t\t\tif (*n_lk_ahd > 0)\n\t\t\t\tath6kl_htc_rx_set_indicate(lk_ahds[0],\n\t\t\t\t\t\t\t   ep, packet);\n\t\t} else\n\t\t\t \n\t\t\tpacket->info.rx.indicat_flags |=\n\t\t\t\tHTC_RX_FLAGS_INDICATE_MORE_PKTS;\n\n\t\tath6kl_htc_rx_update_stats(ep, *n_lk_ahd);\n\n\t\tif (packet->info.rx.rx_flags & HTC_RX_PKT_PART_OF_BUNDLE)\n\t\t\tep->ep_st.rx_bundl += 1;\n\n\t\tath6kl_htc_rx_complete(ep, packet);\n\t}\n\n\treturn status;\n}\n\nstatic int ath6kl_htc_rx_fetch(struct htc_target *target,\n\t\t\t       struct list_head *rx_pktq,\n\t\t\t       struct list_head *comp_pktq)\n{\n\tint fetched_pkts;\n\tbool part_bundle = false;\n\tint status = 0;\n\tstruct list_head tmp_rxq;\n\tstruct htc_packet *packet, *tmp_pkt;\n\n\t \n\twhile (!list_empty(rx_pktq)) {\n\t\tfetched_pkts = 0;\n\n\t\tINIT_LIST_HEAD(&tmp_rxq);\n\n\t\tif (target->rx_bndl_enable && (get_queue_depth(rx_pktq) > 1)) {\n\t\t\t \n\t\t\tstatus = ath6kl_htc_rx_bundle(target, rx_pktq,\n\t\t\t\t\t\t      &tmp_rxq,\n\t\t\t\t\t\t      &fetched_pkts,\n\t\t\t\t\t\t      part_bundle);\n\t\t\tif (status)\n\t\t\t\tgoto fail_rx;\n\n\t\t\tif (!list_empty(rx_pktq))\n\t\t\t\tpart_bundle = true;\n\n\t\t\tlist_splice_tail_init(&tmp_rxq, comp_pktq);\n\t\t}\n\n\t\tif (!fetched_pkts) {\n\t\t\tpacket = list_first_entry(rx_pktq, struct htc_packet,\n\t\t\t\t\t\t   list);\n\n\t\t\t \n\t\t\tpacket->completion = NULL;\n\n\t\t\tif (!list_is_singular(rx_pktq))\n\t\t\t\t \n\t\t\t\tpacket->info.rx.rx_flags |=\n\t\t\t\t\tHTC_RX_PKT_IGNORE_LOOKAHEAD;\n\n\t\t\t \n\t\t\tstatus = ath6kl_htc_rx_packet(target, packet,\n\t\t\t\t\t\t      packet->act_len);\n\n\t\t\tlist_move_tail(&packet->list, &tmp_rxq);\n\n\t\t\tif (status)\n\t\t\t\tgoto fail_rx;\n\n\t\t\tlist_splice_tail_init(&tmp_rxq, comp_pktq);\n\t\t}\n\t}\n\n\treturn 0;\n\nfail_rx:\n\n\t \n\n\tlist_for_each_entry_safe(packet, tmp_pkt, rx_pktq, list) {\n\t\tlist_del(&packet->list);\n\t\thtc_reclaim_rxbuf(target, packet,\n\t\t\t\t  &target->endpoint[packet->endpoint]);\n\t}\n\n\tlist_for_each_entry_safe(packet, tmp_pkt, &tmp_rxq, list) {\n\t\tlist_del(&packet->list);\n\t\thtc_reclaim_rxbuf(target, packet,\n\t\t\t\t  &target->endpoint[packet->endpoint]);\n\t}\n\n\treturn status;\n}\n\nint ath6kl_htc_rxmsg_pending_handler(struct htc_target *target,\n\t\t\t\t     u32 msg_look_ahead, int *num_pkts)\n{\n\tstruct htc_packet *packets, *tmp_pkt;\n\tstruct htc_endpoint *endpoint;\n\tstruct list_head rx_pktq, comp_pktq;\n\tint status = 0;\n\tu32 look_aheads[HTC_HOST_MAX_MSG_PER_BUNDLE];\n\tint num_look_ahead = 1;\n\tenum htc_endpoint_id id;\n\tint n_fetched = 0;\n\n\tINIT_LIST_HEAD(&comp_pktq);\n\t*num_pkts = 0;\n\n\t \n\tlook_aheads[0] = msg_look_ahead;\n\n\twhile (true) {\n\t\t \n\t\tid = ((struct htc_frame_hdr *)&look_aheads[0])->eid;\n\t\tendpoint = &target->endpoint[id];\n\n\t\tif (id >= ENDPOINT_MAX) {\n\t\t\tath6kl_err(\"MsgPend, invalid endpoint in look-ahead: %d\\n\",\n\t\t\t\t   id);\n\t\t\tstatus = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tINIT_LIST_HEAD(&rx_pktq);\n\t\tINIT_LIST_HEAD(&comp_pktq);\n\n\t\t \n\t\tstatus = ath6kl_htc_rx_alloc(target, look_aheads,\n\t\t\t\t\t     num_look_ahead, endpoint,\n\t\t\t\t\t     &rx_pktq);\n\t\tif (status)\n\t\t\tbreak;\n\n\t\tif (get_queue_depth(&rx_pktq) >= 2)\n\t\t\t \n\t\t\ttarget->chk_irq_status_cnt = 1;\n\n\t\tn_fetched += get_queue_depth(&rx_pktq);\n\n\t\tnum_look_ahead = 0;\n\n\t\tstatus = ath6kl_htc_rx_fetch(target, &rx_pktq, &comp_pktq);\n\n\t\tif (!status)\n\t\t\tath6kl_htc_rx_chk_water_mark(endpoint);\n\n\t\t \n\t\tstatus = ath6kl_htc_rx_process_packets(target, &comp_pktq,\n\t\t\t\t\t\t       look_aheads,\n\t\t\t\t\t\t       &num_look_ahead);\n\n\t\tif (!num_look_ahead || status)\n\t\t\tbreak;\n\n\t\t \n\t\ttarget->chk_irq_status_cnt = 1;\n\t}\n\n\tif (status) {\n\t\tif (status != -ECANCELED)\n\t\t\tath6kl_err(\"failed to get pending recv messages: %d\\n\",\n\t\t\t\t   status);\n\n\t\t \n\t\tlist_for_each_entry_safe(packets, tmp_pkt, &comp_pktq, list) {\n\t\t\tlist_del(&packets->list);\n\t\t\thtc_reclaim_rxbuf(target, packets,\n\t\t\t\t\t  &target->endpoint[packets->endpoint]);\n\t\t}\n\n\t\tif (target->htc_flags & HTC_OP_STATE_STOPPING) {\n\t\t\tath6kl_warn(\"host is going to stop blocking receiver for htc_stop\\n\");\n\t\t\tath6kl_hif_rx_control(target->dev, false);\n\t\t}\n\t}\n\n\t \n\tif (target->rx_st_flags & HTC_RECV_WAIT_BUFFERS) {\n\t\tath6kl_warn(\"host has no rx buffers blocking receiver to prevent overrun\\n\");\n\t\tath6kl_hif_rx_control(target->dev, false);\n\t}\n\t*num_pkts = n_fetched;\n\n\treturn status;\n}\n\n \nstatic struct htc_packet *htc_wait_for_ctrl_msg(struct htc_target *target)\n{\n\tstruct htc_packet *packet = NULL;\n\tstruct htc_frame_look_ahead look_ahead;\n\n\tif (ath6kl_hif_poll_mboxmsg_rx(target->dev, &look_ahead.word,\n\t\t\t\t       HTC_TARGET_RESPONSE_TIMEOUT))\n\t\treturn NULL;\n\n\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t   \"htc rx wait ctrl look_ahead 0x%X\\n\", look_ahead.word);\n\n\tif (look_ahead.eid != ENDPOINT_0)\n\t\treturn NULL;\n\n\tpacket = htc_get_control_buf(target, false);\n\n\tif (!packet)\n\t\treturn NULL;\n\n\tpacket->info.rx.rx_flags = 0;\n\tpacket->info.rx.exp_hdr = look_ahead.word;\n\tpacket->act_len = le16_to_cpu(look_ahead.payld_len) + HTC_HDR_LENGTH;\n\n\tif (packet->act_len > packet->buf_len)\n\t\tgoto fail_ctrl_rx;\n\n\t \n\tpacket->completion = NULL;\n\n\t \n\tif (ath6kl_htc_rx_packet(target, packet, packet->act_len))\n\t\tgoto fail_ctrl_rx;\n\n\ttrace_ath6kl_htc_rx(packet->status, packet->endpoint,\n\t\t\t    packet->buf, packet->act_len);\n\n\t \n\tpacket->status = ath6kl_htc_rx_process_hdr(target, packet, NULL, NULL);\n\n\tif (packet->status) {\n\t\tath6kl_err(\"htc_wait_for_ctrl_msg, ath6kl_htc_rx_process_hdr failed (status = %d)\\n\",\n\t\t\t   packet->status);\n\t\tgoto fail_ctrl_rx;\n\t}\n\n\treturn packet;\n\nfail_ctrl_rx:\n\tif (packet != NULL) {\n\t\thtc_rxpkt_reset(packet);\n\t\treclaim_rx_ctrl_buf(target, packet);\n\t}\n\n\treturn NULL;\n}\n\nstatic int ath6kl_htc_mbox_add_rxbuf_multiple(struct htc_target *target,\n\t\t\t\t  struct list_head *pkt_queue)\n{\n\tstruct htc_endpoint *endpoint;\n\tstruct htc_packet *first_pkt;\n\tbool rx_unblock = false;\n\tint status = 0, depth;\n\n\tif (list_empty(pkt_queue))\n\t\treturn -ENOMEM;\n\n\tfirst_pkt = list_first_entry(pkt_queue, struct htc_packet, list);\n\n\tif (first_pkt->endpoint >= ENDPOINT_MAX)\n\t\treturn status;\n\n\tdepth = get_queue_depth(pkt_queue);\n\n\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t   \"htc rx add multiple ep id %d cnt %d len %d\\n\",\n\t\tfirst_pkt->endpoint, depth, first_pkt->buf_len);\n\n\tendpoint = &target->endpoint[first_pkt->endpoint];\n\n\tif (target->htc_flags & HTC_OP_STATE_STOPPING) {\n\t\tstruct htc_packet *packet, *tmp_pkt;\n\n\t\t \n\t\tlist_for_each_entry_safe(packet, tmp_pkt, pkt_queue, list) {\n\t\t\tpacket->status = -ECANCELED;\n\t\t\tlist_del(&packet->list);\n\t\t\tath6kl_htc_rx_complete(endpoint, packet);\n\t\t}\n\n\t\treturn status;\n\t}\n\n\tspin_lock_bh(&target->rx_lock);\n\n\tlist_splice_tail_init(pkt_queue, &endpoint->rx_bufq);\n\n\t \n\tif (target->rx_st_flags & HTC_RECV_WAIT_BUFFERS) {\n\t\tif (target->ep_waiting == first_pkt->endpoint) {\n\t\t\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t\t\t   \"htc rx blocked on ep %d, unblocking\\n\",\n\t\t\t\t   target->ep_waiting);\n\t\t\ttarget->rx_st_flags &= ~HTC_RECV_WAIT_BUFFERS;\n\t\t\ttarget->ep_waiting = ENDPOINT_MAX;\n\t\t\trx_unblock = true;\n\t\t}\n\t}\n\n\tspin_unlock_bh(&target->rx_lock);\n\n\tif (rx_unblock && !(target->htc_flags & HTC_OP_STATE_STOPPING))\n\t\t \n\t\tath6kl_hif_rx_control(target->dev, true);\n\n\treturn status;\n}\n\nstatic void ath6kl_htc_mbox_flush_rx_buf(struct htc_target *target)\n{\n\tstruct htc_endpoint *endpoint;\n\tstruct htc_packet *packet, *tmp_pkt;\n\tint i;\n\n\tfor (i = ENDPOINT_0; i < ENDPOINT_MAX; i++) {\n\t\tendpoint = &target->endpoint[i];\n\t\tif (!endpoint->svc_id)\n\t\t\t \n\t\t\tcontinue;\n\n\t\tspin_lock_bh(&target->rx_lock);\n\t\tlist_for_each_entry_safe(packet, tmp_pkt,\n\t\t\t\t\t &endpoint->rx_bufq, list) {\n\t\t\tlist_del(&packet->list);\n\t\t\tspin_unlock_bh(&target->rx_lock);\n\t\t\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t\t\t   \"htc rx flush pkt 0x%p  len %d  ep %d\\n\",\n\t\t\t\t   packet, packet->buf_len,\n\t\t\t\t   packet->endpoint);\n\t\t\t \n\t\t\tif (packet->endpoint == ENDPOINT_0) {\n\t\t\t\tkfree(packet->buf_start);\n\t\t\t\tkfree(packet);\n\t\t\t} else {\n\t\t\t\tdev_kfree_skb(packet->pkt_cntxt);\n\t\t\t}\n\t\t\tspin_lock_bh(&target->rx_lock);\n\t\t}\n\t\tspin_unlock_bh(&target->rx_lock);\n\t}\n}\n\nstatic int ath6kl_htc_mbox_conn_service(struct htc_target *target,\n\t\t\t    struct htc_service_connect_req *conn_req,\n\t\t\t    struct htc_service_connect_resp *conn_resp)\n{\n\tstruct htc_packet *rx_pkt = NULL;\n\tstruct htc_packet *tx_pkt = NULL;\n\tstruct htc_conn_service_resp *resp_msg;\n\tstruct htc_conn_service_msg *conn_msg;\n\tstruct htc_endpoint *endpoint;\n\tenum htc_endpoint_id assigned_ep = ENDPOINT_MAX;\n\tunsigned int max_msg_sz = 0;\n\tint status = 0;\n\tu16 msg_id;\n\n\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t   \"htc connect service target 0x%p service id 0x%x\\n\",\n\t\t   target, conn_req->svc_id);\n\n\tif (conn_req->svc_id == HTC_CTRL_RSVD_SVC) {\n\t\t \n\t\tassigned_ep = ENDPOINT_0;\n\t\tmax_msg_sz = HTC_MAX_CTRL_MSG_LEN;\n\t} else {\n\t\t \n\t\ttx_pkt = htc_get_control_buf(target, true);\n\n\t\tif (!tx_pkt)\n\t\t\treturn -ENOMEM;\n\n\t\tconn_msg = (struct htc_conn_service_msg *)tx_pkt->buf;\n\t\tmemset(conn_msg, 0, sizeof(*conn_msg));\n\t\tconn_msg->msg_id = cpu_to_le16(HTC_MSG_CONN_SVC_ID);\n\t\tconn_msg->svc_id = cpu_to_le16(conn_req->svc_id);\n\t\tconn_msg->conn_flags = cpu_to_le16(conn_req->conn_flags);\n\n\t\tset_htc_pkt_info(tx_pkt, NULL, (u8 *) conn_msg,\n\t\t\t\t sizeof(*conn_msg) + conn_msg->svc_meta_len,\n\t\t\t\t ENDPOINT_0, HTC_SERVICE_TX_PACKET_TAG);\n\n\t\t \n\t\ttx_pkt->completion = NULL;\n\t\tath6kl_htc_tx_prep_pkt(tx_pkt, 0, 0, 0);\n\t\tstatus = ath6kl_htc_tx_issue(target, tx_pkt);\n\n\t\tif (status)\n\t\t\tgoto fail_tx;\n\n\t\t \n\t\trx_pkt = htc_wait_for_ctrl_msg(target);\n\n\t\tif (!rx_pkt) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tgoto fail_tx;\n\t\t}\n\n\t\tresp_msg = (struct htc_conn_service_resp *)rx_pkt->buf;\n\t\tmsg_id = le16_to_cpu(resp_msg->msg_id);\n\n\t\tif ((msg_id != HTC_MSG_CONN_SVC_RESP_ID) ||\n\t\t    (rx_pkt->act_len < sizeof(*resp_msg))) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tgoto fail_tx;\n\t\t}\n\n\t\tconn_resp->resp_code = resp_msg->status;\n\t\t \n\t\tif (resp_msg->status != HTC_SERVICE_SUCCESS) {\n\t\t\tath6kl_err(\"target failed service 0x%X connect request (status:%d)\\n\",\n\t\t\t\t   resp_msg->svc_id, resp_msg->status);\n\t\t\tstatus = -ENOMEM;\n\t\t\tgoto fail_tx;\n\t\t}\n\n\t\tassigned_ep = (enum htc_endpoint_id)resp_msg->eid;\n\t\tmax_msg_sz = le16_to_cpu(resp_msg->max_msg_sz);\n\t}\n\n\tif (WARN_ON_ONCE(assigned_ep == ENDPOINT_UNUSED ||\n\t\t\t assigned_ep >= ENDPOINT_MAX || !max_msg_sz)) {\n\t\tstatus = -ENOMEM;\n\t\tgoto fail_tx;\n\t}\n\n\tendpoint = &target->endpoint[assigned_ep];\n\tendpoint->eid = assigned_ep;\n\tif (endpoint->svc_id) {\n\t\tstatus = -ENOMEM;\n\t\tgoto fail_tx;\n\t}\n\n\t \n\tconn_resp->endpoint = assigned_ep;\n\tconn_resp->len_max = max_msg_sz;\n\n\t \n\n\t \n\tendpoint->svc_id = conn_req->svc_id;\n\n\tendpoint->max_txq_depth = conn_req->max_txq_depth;\n\tendpoint->len_max = max_msg_sz;\n\tendpoint->ep_cb = conn_req->ep_cb;\n\tendpoint->cred_dist.svc_id = conn_req->svc_id;\n\tendpoint->cred_dist.htc_ep = endpoint;\n\tendpoint->cred_dist.endpoint = assigned_ep;\n\tendpoint->cred_dist.cred_sz = target->tgt_cred_sz;\n\n\tswitch (endpoint->svc_id) {\n\tcase WMI_DATA_BK_SVC:\n\t\tendpoint->tx_drop_packet_threshold = MAX_DEF_COOKIE_NUM / 3;\n\t\tbreak;\n\tdefault:\n\t\tendpoint->tx_drop_packet_threshold = MAX_HI_COOKIE_NUM;\n\t\tbreak;\n\t}\n\n\tif (conn_req->max_rxmsg_sz) {\n\t\t \n\t\tif (conn_req->max_rxmsg_sz > max_msg_sz) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tgoto fail_tx;\n\t\t}\n\t\tendpoint->cred_dist.cred_per_msg =\n\t\t    conn_req->max_rxmsg_sz / target->tgt_cred_sz;\n\t} else\n\t\tendpoint->cred_dist.cred_per_msg =\n\t\t    max_msg_sz / target->tgt_cred_sz;\n\n\tif (!endpoint->cred_dist.cred_per_msg)\n\t\tendpoint->cred_dist.cred_per_msg = 1;\n\n\t \n\tendpoint->conn_flags = conn_req->flags;\n\nfail_tx:\n\tif (tx_pkt)\n\t\thtc_reclaim_txctrl_buf(target, tx_pkt);\n\n\tif (rx_pkt) {\n\t\thtc_rxpkt_reset(rx_pkt);\n\t\treclaim_rx_ctrl_buf(target, rx_pkt);\n\t}\n\n\treturn status;\n}\n\nstatic void reset_ep_state(struct htc_target *target)\n{\n\tstruct htc_endpoint *endpoint;\n\tint i;\n\n\tfor (i = ENDPOINT_0; i < ENDPOINT_MAX; i++) {\n\t\tendpoint = &target->endpoint[i];\n\t\tmemset(&endpoint->cred_dist, 0, sizeof(endpoint->cred_dist));\n\t\tendpoint->svc_id = 0;\n\t\tendpoint->len_max = 0;\n\t\tendpoint->max_txq_depth = 0;\n\t\tmemset(&endpoint->ep_st, 0,\n\t\t       sizeof(endpoint->ep_st));\n\t\tINIT_LIST_HEAD(&endpoint->rx_bufq);\n\t\tINIT_LIST_HEAD(&endpoint->txq);\n\t\tendpoint->target = target;\n\t}\n\n\t \n\t \n\tINIT_LIST_HEAD(&target->cred_dist_list);\n}\n\nstatic int ath6kl_htc_mbox_get_rxbuf_num(struct htc_target *target,\n\t\t\t     enum htc_endpoint_id endpoint)\n{\n\tint num;\n\n\tspin_lock_bh(&target->rx_lock);\n\tnum = get_queue_depth(&(target->endpoint[endpoint].rx_bufq));\n\tspin_unlock_bh(&target->rx_lock);\n\treturn num;\n}\n\nstatic void htc_setup_msg_bndl(struct htc_target *target)\n{\n\t \n\ttarget->msg_per_bndl_max = min(HTC_HOST_MAX_MSG_PER_BUNDLE,\n\t\t\t\t       target->msg_per_bndl_max);\n\n\tif (ath6kl_hif_enable_scatter(target->dev->ar)) {\n\t\ttarget->msg_per_bndl_max = 0;\n\t\treturn;\n\t}\n\n\t \n\ttarget->msg_per_bndl_max = min(target->max_scat_entries,\n\t\t\t\t       target->msg_per_bndl_max);\n\n\tath6kl_dbg(ATH6KL_DBG_BOOT,\n\t\t   \"htc bundling allowed msg_per_bndl_max %d\\n\",\n\t\t   target->msg_per_bndl_max);\n\n\t \n\ttarget->max_rx_bndl_sz = target->max_xfer_szper_scatreq;\n\t \n\ttarget->max_tx_bndl_sz = min(HIF_MBOX0_EXT_WIDTH,\n\t\t\t\t     target->max_xfer_szper_scatreq);\n\n\tath6kl_dbg(ATH6KL_DBG_BOOT, \"htc max_rx_bndl_sz %d max_tx_bndl_sz %d\\n\",\n\t\t   target->max_rx_bndl_sz, target->max_tx_bndl_sz);\n\n\tif (target->max_tx_bndl_sz)\n\t\t \n\t\ttarget->tx_bndl_mask = (1 << WMM_NUM_AC) - 1;\n\n\tif (target->max_rx_bndl_sz)\n\t\ttarget->rx_bndl_enable = true;\n\n\tif ((target->tgt_cred_sz % target->block_sz) != 0) {\n\t\tath6kl_warn(\"credit size: %d is not block aligned! Disabling send bundling\\n\",\n\t\t\t    target->tgt_cred_sz);\n\n\t\t \n\t\ttarget->tx_bndl_mask = 0;\n\t}\n}\n\nstatic int ath6kl_htc_mbox_wait_target(struct htc_target *target)\n{\n\tstruct htc_packet *packet = NULL;\n\tstruct htc_ready_ext_msg *rdy_msg;\n\tstruct htc_service_connect_req connect;\n\tstruct htc_service_connect_resp resp;\n\tint status;\n\n\t \n\tpacket = htc_wait_for_ctrl_msg(target);\n\n\tif (!packet)\n\t\treturn -ENOMEM;\n\n\t \n\trdy_msg = (struct htc_ready_ext_msg *)packet->buf;\n\n\tif ((le16_to_cpu(rdy_msg->ver2_0_info.msg_id) != HTC_MSG_READY_ID) ||\n\t    (packet->act_len < sizeof(struct htc_ready_msg))) {\n\t\tstatus = -ENOMEM;\n\t\tgoto fail_wait_target;\n\t}\n\n\tif (!rdy_msg->ver2_0_info.cred_cnt || !rdy_msg->ver2_0_info.cred_sz) {\n\t\tstatus = -ENOMEM;\n\t\tgoto fail_wait_target;\n\t}\n\n\ttarget->tgt_creds = le16_to_cpu(rdy_msg->ver2_0_info.cred_cnt);\n\ttarget->tgt_cred_sz = le16_to_cpu(rdy_msg->ver2_0_info.cred_sz);\n\n\tath6kl_dbg(ATH6KL_DBG_BOOT,\n\t\t   \"htc target ready credits %d size %d\\n\",\n\t\t   target->tgt_creds, target->tgt_cred_sz);\n\n\t \n\tif (packet->act_len >= sizeof(struct htc_ready_ext_msg)) {\n\t\t \n\t\ttarget->htc_tgt_ver = rdy_msg->htc_ver;\n\t\ttarget->msg_per_bndl_max = rdy_msg->msg_per_htc_bndl;\n\t} else {\n\t\t \n\t\ttarget->htc_tgt_ver = HTC_VERSION_2P0;\n\t\ttarget->msg_per_bndl_max = 0;\n\t}\n\n\tath6kl_dbg(ATH6KL_DBG_BOOT, \"htc using protocol %s (%d)\\n\",\n\t\t   (target->htc_tgt_ver == HTC_VERSION_2P0) ? \"2.0\" : \">= 2.1\",\n\t\t   target->htc_tgt_ver);\n\n\tif (target->msg_per_bndl_max > 0)\n\t\thtc_setup_msg_bndl(target);\n\n\t \n\tmemset(&connect, 0, sizeof(connect));\n\tmemset(&resp, 0, sizeof(resp));\n\tconnect.ep_cb.rx = htc_ctrl_rx;\n\tconnect.ep_cb.rx_refill = NULL;\n\tconnect.ep_cb.tx_full = NULL;\n\tconnect.max_txq_depth = NUM_CONTROL_BUFFERS;\n\tconnect.svc_id = HTC_CTRL_RSVD_SVC;\n\n\t \n\tstatus = ath6kl_htc_mbox_conn_service((void *)target, &connect, &resp);\n\n\tif (status)\n\t\t \n\t\tath6kl_hif_cleanup_scatter(target->dev->ar);\n\nfail_wait_target:\n\tif (packet) {\n\t\thtc_rxpkt_reset(packet);\n\t\treclaim_rx_ctrl_buf(target, packet);\n\t}\n\n\treturn status;\n}\n\n \nstatic int ath6kl_htc_mbox_start(struct htc_target *target)\n{\n\tstruct htc_packet *packet;\n\tint status;\n\n\tmemset(&target->dev->irq_proc_reg, 0,\n\t       sizeof(target->dev->irq_proc_reg));\n\n\t \n\tath6kl_hif_disable_intrs(target->dev);\n\n\ttarget->htc_flags = 0;\n\ttarget->rx_st_flags = 0;\n\n\t \n\twhile ((packet = htc_get_control_buf(target, false)) != NULL) {\n\t\tstatus = htc_add_rxbuf(target, packet);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\t \n\tath6kl_credit_init(target->credit_info, &target->cred_dist_list,\n\t\t\t   target->tgt_creds);\n\n\tdump_cred_dist_stats(target);\n\n\t \n\tstatus = htc_setup_tx_complete(target);\n\n\tif (status)\n\t\treturn status;\n\n\t \n\tstatus = ath6kl_hif_unmask_intrs(target->dev);\n\n\tif (status)\n\t\tath6kl_htc_mbox_stop(target);\n\n\treturn status;\n}\n\nstatic int ath6kl_htc_reset(struct htc_target *target)\n{\n\tu32 block_size, ctrl_bufsz;\n\tstruct htc_packet *packet;\n\tint i;\n\n\treset_ep_state(target);\n\n\tblock_size = target->dev->ar->mbox_info.block_size;\n\n\tctrl_bufsz = (block_size > HTC_MAX_CTRL_MSG_LEN) ?\n\t\t      (block_size + HTC_HDR_LENGTH) :\n\t\t      (HTC_MAX_CTRL_MSG_LEN + HTC_HDR_LENGTH);\n\n\tfor (i = 0; i < NUM_CONTROL_BUFFERS; i++) {\n\t\tpacket = kzalloc(sizeof(*packet), GFP_KERNEL);\n\t\tif (!packet)\n\t\t\treturn -ENOMEM;\n\n\t\tpacket->buf_start = kzalloc(ctrl_bufsz, GFP_KERNEL);\n\t\tif (!packet->buf_start) {\n\t\t\tkfree(packet);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tpacket->buf_len = ctrl_bufsz;\n\t\tif (i < NUM_CONTROL_RX_BUFFERS) {\n\t\t\tpacket->act_len = 0;\n\t\t\tpacket->buf = packet->buf_start;\n\t\t\tpacket->endpoint = ENDPOINT_0;\n\t\t\tlist_add_tail(&packet->list, &target->free_ctrl_rxbuf);\n\t\t} else {\n\t\t\tlist_add_tail(&packet->list, &target->free_ctrl_txbuf);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void ath6kl_htc_mbox_stop(struct htc_target *target)\n{\n\tspin_lock_bh(&target->htc_lock);\n\ttarget->htc_flags |= HTC_OP_STATE_STOPPING;\n\tspin_unlock_bh(&target->htc_lock);\n\n\t \n\tath6kl_hif_mask_intrs(target->dev);\n\n\tath6kl_htc_flush_txep_all(target);\n\n\tath6kl_htc_mbox_flush_rx_buf(target);\n\n\tath6kl_htc_reset(target);\n}\n\nstatic void *ath6kl_htc_mbox_create(struct ath6kl *ar)\n{\n\tstruct htc_target *target = NULL;\n\tint status = 0;\n\n\ttarget = kzalloc(sizeof(*target), GFP_KERNEL);\n\tif (!target) {\n\t\tath6kl_err(\"unable to allocate memory\\n\");\n\t\treturn NULL;\n\t}\n\n\ttarget->dev = kzalloc(sizeof(*target->dev), GFP_KERNEL);\n\tif (!target->dev) {\n\t\tath6kl_err(\"unable to allocate memory\\n\");\n\t\tkfree(target);\n\t\treturn NULL;\n\t}\n\n\tspin_lock_init(&target->htc_lock);\n\tspin_lock_init(&target->rx_lock);\n\tspin_lock_init(&target->tx_lock);\n\n\tINIT_LIST_HEAD(&target->free_ctrl_txbuf);\n\tINIT_LIST_HEAD(&target->free_ctrl_rxbuf);\n\tINIT_LIST_HEAD(&target->cred_dist_list);\n\n\ttarget->dev->ar = ar;\n\ttarget->dev->htc_cnxt = target;\n\ttarget->ep_waiting = ENDPOINT_MAX;\n\n\tstatus = ath6kl_hif_setup(target->dev);\n\tif (status)\n\t\tgoto err_htc_cleanup;\n\n\tstatus = ath6kl_htc_reset(target);\n\tif (status)\n\t\tgoto err_htc_cleanup;\n\n\treturn target;\n\nerr_htc_cleanup:\n\tath6kl_htc_mbox_cleanup(target);\n\n\treturn NULL;\n}\n\n \nstatic void ath6kl_htc_mbox_cleanup(struct htc_target *target)\n{\n\tstruct htc_packet *packet, *tmp_packet;\n\n\tath6kl_hif_cleanup_scatter(target->dev->ar);\n\n\tlist_for_each_entry_safe(packet, tmp_packet,\n\t\t\t\t &target->free_ctrl_txbuf, list) {\n\t\tlist_del(&packet->list);\n\t\tkfree(packet->buf_start);\n\t\tkfree(packet);\n\t}\n\n\tlist_for_each_entry_safe(packet, tmp_packet,\n\t\t\t\t &target->free_ctrl_rxbuf, list) {\n\t\tlist_del(&packet->list);\n\t\tkfree(packet->buf_start);\n\t\tkfree(packet);\n\t}\n\n\tkfree(target->dev);\n\tkfree(target);\n}\n\nstatic const struct ath6kl_htc_ops ath6kl_htc_mbox_ops = {\n\t.create = ath6kl_htc_mbox_create,\n\t.wait_target = ath6kl_htc_mbox_wait_target,\n\t.start = ath6kl_htc_mbox_start,\n\t.conn_service = ath6kl_htc_mbox_conn_service,\n\t.tx = ath6kl_htc_mbox_tx,\n\t.stop = ath6kl_htc_mbox_stop,\n\t.cleanup = ath6kl_htc_mbox_cleanup,\n\t.flush_txep = ath6kl_htc_mbox_flush_txep,\n\t.flush_rx_buf = ath6kl_htc_mbox_flush_rx_buf,\n\t.activity_changed = ath6kl_htc_mbox_activity_changed,\n\t.get_rxbuf_num = ath6kl_htc_mbox_get_rxbuf_num,\n\t.add_rxbuf_multiple = ath6kl_htc_mbox_add_rxbuf_multiple,\n\t.credit_setup = ath6kl_htc_mbox_credit_setup,\n};\n\nvoid ath6kl_htc_mbox_attach(struct ath6kl *ar)\n{\n\tar->htc_ops = &ath6kl_htc_mbox_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}