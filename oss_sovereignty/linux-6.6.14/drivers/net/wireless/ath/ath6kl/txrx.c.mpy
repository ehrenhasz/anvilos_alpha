{
  "module_name": "txrx.c",
  "hash_id": "02c6912eb04601657dbf56302da157cebb3f6ccb898af4dbd2c5384a29370fe5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath6kl/txrx.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include \"core.h\"\n#include \"debug.h\"\n#include \"htc-ops.h\"\n#include \"trace.h\"\n\n \n#define ATH6KL_TID_MASK 0xf\n#define ATH6KL_AID_SHIFT 4\n\nstatic inline u8 ath6kl_get_tid(u8 tid_mux)\n{\n\treturn tid_mux & ATH6KL_TID_MASK;\n}\n\nstatic inline u8 ath6kl_get_aid(u8 tid_mux)\n{\n\treturn tid_mux >> ATH6KL_AID_SHIFT;\n}\n\nstatic u8 ath6kl_ibss_map_epid(struct sk_buff *skb, struct net_device *dev,\n\t\t\t       u32 *map_no)\n{\n\tstruct ath6kl *ar = ath6kl_priv(dev);\n\tstruct ethhdr *eth_hdr;\n\tu32 i, ep_map = -1;\n\tu8 *datap;\n\n\t*map_no = 0;\n\tdatap = skb->data;\n\teth_hdr = (struct ethhdr *) (datap + sizeof(struct wmi_data_hdr));\n\n\tif (is_multicast_ether_addr(eth_hdr->h_dest))\n\t\treturn ENDPOINT_2;\n\n\tfor (i = 0; i < ar->node_num; i++) {\n\t\tif (memcmp(eth_hdr->h_dest, ar->node_map[i].mac_addr,\n\t\t\t   ETH_ALEN) == 0) {\n\t\t\t*map_no = i + 1;\n\t\t\tar->node_map[i].tx_pend++;\n\t\t\treturn ar->node_map[i].ep_id;\n\t\t}\n\n\t\tif ((ep_map == -1) && !ar->node_map[i].tx_pend)\n\t\t\tep_map = i;\n\t}\n\n\tif (ep_map == -1) {\n\t\tep_map = ar->node_num;\n\t\tar->node_num++;\n\t\tif (ar->node_num > MAX_NODE_NUM)\n\t\t\treturn ENDPOINT_UNUSED;\n\t}\n\n\tmemcpy(ar->node_map[ep_map].mac_addr, eth_hdr->h_dest, ETH_ALEN);\n\n\tfor (i = ENDPOINT_2; i <= ENDPOINT_5; i++) {\n\t\tif (!ar->tx_pending[i]) {\n\t\t\tar->node_map[ep_map].ep_id = i;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (i == ENDPOINT_5) {\n\t\t\tar->node_map[ep_map].ep_id = ar->next_ep_id;\n\t\t\tar->next_ep_id++;\n\t\t\tif (ar->next_ep_id > ENDPOINT_5)\n\t\t\t\tar->next_ep_id = ENDPOINT_2;\n\t\t}\n\t}\n\n\t*map_no = ep_map + 1;\n\tar->node_map[ep_map].tx_pend++;\n\n\treturn ar->node_map[ep_map].ep_id;\n}\n\nstatic bool ath6kl_process_uapsdq(struct ath6kl_sta *conn,\n\t\t\t\tstruct ath6kl_vif *vif,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tu32 *flags)\n{\n\tstruct ath6kl *ar = vif->ar;\n\tbool is_apsdq_empty = false;\n\tstruct ethhdr *datap = (struct ethhdr *) skb->data;\n\tu8 up = 0, traffic_class, *ip_hdr;\n\tu16 ether_type;\n\tstruct ath6kl_llc_snap_hdr *llc_hdr;\n\n\tif (conn->sta_flags & STA_PS_APSD_TRIGGER) {\n\t\t \n\t\tspin_lock_bh(&conn->psq_lock);\n\t\tif (!skb_queue_empty(&conn->apsdq))\n\t\t\t*flags |= WMI_DATA_HDR_FLAGS_MORE;\n\t\telse if (conn->sta_flags & STA_PS_APSD_EOSP)\n\t\t\t*flags |= WMI_DATA_HDR_FLAGS_EOSP;\n\t\t*flags |= WMI_DATA_HDR_FLAGS_UAPSD;\n\t\tspin_unlock_bh(&conn->psq_lock);\n\t\treturn false;\n\t} else if (!conn->apsd_info) {\n\t\treturn false;\n\t}\n\n\tif (test_bit(WMM_ENABLED, &vif->flags)) {\n\t\tether_type = be16_to_cpu(datap->h_proto);\n\t\tif (is_ethertype(ether_type)) {\n\t\t\t \n\t\t\tip_hdr = (u8 *)(datap + 1);\n\t\t} else {\n\t\t\t \n\t\t\tllc_hdr = (struct ath6kl_llc_snap_hdr *)\n\t\t\t\t\t\t\t(datap + 1);\n\t\t\tether_type = be16_to_cpu(llc_hdr->eth_type);\n\t\t\tip_hdr = (u8 *)(llc_hdr + 1);\n\t\t}\n\n\t\tif (ether_type == IP_ETHERTYPE)\n\t\t\tup = ath6kl_wmi_determine_user_priority(\n\t\t\t\t\t\t\tip_hdr, 0);\n\t}\n\n\ttraffic_class = ath6kl_wmi_get_traffic_class(up);\n\n\tif ((conn->apsd_info & (1 << traffic_class)) == 0)\n\t\treturn false;\n\n\t \n\tspin_lock_bh(&conn->psq_lock);\n\tis_apsdq_empty = skb_queue_empty(&conn->apsdq);\n\tskb_queue_tail(&conn->apsdq, skb);\n\tspin_unlock_bh(&conn->psq_lock);\n\n\t \n\tif (is_apsdq_empty) {\n\t\tath6kl_wmi_set_apsd_bfrd_traf(ar->wmi,\n\t\t\t\t\t      vif->fw_vif_idx,\n\t\t\t\t\t      conn->aid, 1, 0);\n\t}\n\t*flags |= WMI_DATA_HDR_FLAGS_UAPSD;\n\n\treturn true;\n}\n\nstatic bool ath6kl_process_psq(struct ath6kl_sta *conn,\n\t\t\t\tstruct ath6kl_vif *vif,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tu32 *flags)\n{\n\tbool is_psq_empty = false;\n\tstruct ath6kl *ar = vif->ar;\n\n\tif (conn->sta_flags & STA_PS_POLLED) {\n\t\tspin_lock_bh(&conn->psq_lock);\n\t\tif (!skb_queue_empty(&conn->psq))\n\t\t\t*flags |= WMI_DATA_HDR_FLAGS_MORE;\n\t\tspin_unlock_bh(&conn->psq_lock);\n\t\treturn false;\n\t}\n\n\t \n\tspin_lock_bh(&conn->psq_lock);\n\tis_psq_empty = skb_queue_empty(&conn->psq);\n\tskb_queue_tail(&conn->psq, skb);\n\tspin_unlock_bh(&conn->psq_lock);\n\n\t \n\tif (is_psq_empty)\n\t\tath6kl_wmi_set_pvb_cmd(ar->wmi,\n\t\t\t\t       vif->fw_vif_idx,\n\t\t\t\t       conn->aid, 1);\n\treturn true;\n}\n\nstatic bool ath6kl_powersave_ap(struct ath6kl_vif *vif, struct sk_buff *skb,\n\t\t\t\tu32 *flags)\n{\n\tstruct ethhdr *datap = (struct ethhdr *) skb->data;\n\tstruct ath6kl_sta *conn = NULL;\n\tbool ps_queued = false;\n\tstruct ath6kl *ar = vif->ar;\n\n\tif (is_multicast_ether_addr(datap->h_dest)) {\n\t\tu8 ctr = 0;\n\t\tbool q_mcast = false;\n\n\t\tfor (ctr = 0; ctr < AP_MAX_NUM_STA; ctr++) {\n\t\t\tif (ar->sta_list[ctr].sta_flags & STA_PS_SLEEP) {\n\t\t\t\tq_mcast = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (q_mcast) {\n\t\t\t \n\t\t\tif (!test_bit(DTIM_EXPIRED, &vif->flags)) {\n\t\t\t\tbool is_mcastq_empty = false;\n\n\t\t\t\tspin_lock_bh(&ar->mcastpsq_lock);\n\t\t\t\tis_mcastq_empty =\n\t\t\t\t\tskb_queue_empty(&ar->mcastpsq);\n\t\t\t\tskb_queue_tail(&ar->mcastpsq, skb);\n\t\t\t\tspin_unlock_bh(&ar->mcastpsq_lock);\n\n\t\t\t\t \n\t\t\t\tif (is_mcastq_empty)\n\t\t\t\t\tath6kl_wmi_set_pvb_cmd(ar->wmi,\n\t\t\t\t\t\t\t       vif->fw_vif_idx,\n\t\t\t\t\t\t\t       MCAST_AID, 1);\n\n\t\t\t\tps_queued = true;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tspin_lock_bh(&ar->mcastpsq_lock);\n\t\t\t\tif (!skb_queue_empty(&ar->mcastpsq))\n\t\t\t\t\t*flags |= WMI_DATA_HDR_FLAGS_MORE;\n\t\t\t\tspin_unlock_bh(&ar->mcastpsq_lock);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tconn = ath6kl_find_sta(vif, datap->h_dest);\n\t\tif (!conn) {\n\t\t\tdev_kfree_skb(skb);\n\n\t\t\t \n\t\t\treturn true;\n\t\t}\n\n\t\tif (conn->sta_flags & STA_PS_SLEEP) {\n\t\t\tps_queued = ath6kl_process_uapsdq(conn,\n\t\t\t\t\t\tvif, skb, flags);\n\t\t\tif (!(*flags & WMI_DATA_HDR_FLAGS_UAPSD))\n\t\t\t\tps_queued = ath6kl_process_psq(conn,\n\t\t\t\t\t\tvif, skb, flags);\n\t\t}\n\t}\n\treturn ps_queued;\n}\n\n \n\nint ath6kl_control_tx(void *devt, struct sk_buff *skb,\n\t\t      enum htc_endpoint_id eid)\n{\n\tstruct ath6kl *ar = devt;\n\tint status = 0;\n\tstruct ath6kl_cookie *cookie = NULL;\n\n\ttrace_ath6kl_wmi_cmd(skb->data, skb->len);\n\n\tif (WARN_ON_ONCE(ar->state == ATH6KL_STATE_WOW)) {\n\t\tdev_kfree_skb(skb);\n\t\treturn -EACCES;\n\t}\n\n\tif (WARN_ON_ONCE(eid == ENDPOINT_UNUSED ||\n\t\t\t eid >= ENDPOINT_MAX)) {\n\t\tstatus = -EINVAL;\n\t\tgoto fail_ctrl_tx;\n\t}\n\n\tspin_lock_bh(&ar->lock);\n\n\tath6kl_dbg(ATH6KL_DBG_WLAN_TX,\n\t\t   \"%s: skb=0x%p, len=0x%x eid =%d\\n\", __func__,\n\t\t   skb, skb->len, eid);\n\n\tif (test_bit(WMI_CTRL_EP_FULL, &ar->flag) && (eid == ar->ctrl_ep)) {\n\t\t \n\t\tcookie = NULL;\n\t\tath6kl_err(\"wmi ctrl ep full, dropping pkt : 0x%p, len:%d\\n\",\n\t\t\t   skb, skb->len);\n\t} else {\n\t\tcookie = ath6kl_alloc_cookie(ar);\n\t}\n\n\tif (cookie == NULL) {\n\t\tspin_unlock_bh(&ar->lock);\n\t\tstatus = -ENOMEM;\n\t\tgoto fail_ctrl_tx;\n\t}\n\n\tar->tx_pending[eid]++;\n\n\tif (eid != ar->ctrl_ep)\n\t\tar->total_tx_data_pend++;\n\n\tspin_unlock_bh(&ar->lock);\n\n\tcookie->skb = skb;\n\tcookie->map_no = 0;\n\tset_htc_pkt_info(&cookie->htc_pkt, cookie, skb->data, skb->len,\n\t\t\t eid, ATH6KL_CONTROL_PKT_TAG);\n\tcookie->htc_pkt.skb = skb;\n\n\t \n\tath6kl_htc_tx(ar->htc_target, &cookie->htc_pkt);\n\n\treturn 0;\n\nfail_ctrl_tx:\n\tdev_kfree_skb(skb);\n\treturn status;\n}\n\nnetdev_tx_t ath6kl_data_tx(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct ath6kl *ar = ath6kl_priv(dev);\n\tstruct ath6kl_cookie *cookie = NULL;\n\tenum htc_endpoint_id eid = ENDPOINT_UNUSED;\n\tstruct ath6kl_vif *vif = netdev_priv(dev);\n\tu32 map_no = 0;\n\tu16 htc_tag = ATH6KL_DATA_PKT_TAG;\n\tu8 ac = 99;  \n\tbool chk_adhoc_ps_mapping = false;\n\tint ret;\n\tstruct wmi_tx_meta_v2 meta_v2;\n\tvoid *meta;\n\tu8 csum_start = 0, csum_dest = 0, csum = skb->ip_summed;\n\tu8 meta_ver = 0;\n\tu32 flags = 0;\n\n\tath6kl_dbg(ATH6KL_DBG_WLAN_TX,\n\t\t   \"%s: skb=0x%p, data=0x%p, len=0x%x\\n\", __func__,\n\t\t   skb, skb->data, skb->len);\n\n\t \n\tif (!test_bit(CONNECTED, &vif->flags))\n\t\tgoto fail_tx;\n\n\tif (WARN_ON_ONCE(ar->state != ATH6KL_STATE_ON))\n\t\tgoto fail_tx;\n\n\tif (!test_bit(WMI_READY, &ar->flag))\n\t\tgoto fail_tx;\n\n\t \n\tif (vif->nw_type == AP_NETWORK) {\n\t\tif (ath6kl_powersave_ap(vif, skb, &flags))\n\t\t\treturn 0;\n\t}\n\n\tif (test_bit(WMI_ENABLED, &ar->flag)) {\n\t\tif ((dev->features & NETIF_F_IP_CSUM) &&\n\t\t    (csum == CHECKSUM_PARTIAL)) {\n\t\t\tcsum_start = skb->csum_start -\n\t\t\t\t\t(skb_network_header(skb) - skb->head) +\n\t\t\t\t\tsizeof(struct ath6kl_llc_snap_hdr);\n\t\t\tcsum_dest = skb->csum_offset + csum_start;\n\t\t}\n\n\t\tif (skb_cow_head(skb, dev->needed_headroom)) {\n\t\t\tdev->stats.tx_dropped++;\n\t\t\tkfree_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (ath6kl_wmi_dix_2_dot3(ar->wmi, skb)) {\n\t\t\tath6kl_err(\"ath6kl_wmi_dix_2_dot3 failed\\n\");\n\t\t\tgoto fail_tx;\n\t\t}\n\n\t\tif ((dev->features & NETIF_F_IP_CSUM) &&\n\t\t    (csum == CHECKSUM_PARTIAL)) {\n\t\t\tmeta_v2.csum_start = csum_start;\n\t\t\tmeta_v2.csum_dest = csum_dest;\n\n\t\t\t \n\t\t\tmeta_v2.csum_flags = WMI_META_V2_FLAG_CSUM_OFFLOAD;\n\t\t\tmeta_ver = WMI_META_VERSION_2;\n\t\t\tmeta = &meta_v2;\n\t\t} else {\n\t\t\tmeta_ver = 0;\n\t\t\tmeta = NULL;\n\t\t}\n\n\t\tret = ath6kl_wmi_data_hdr_add(ar->wmi, skb,\n\t\t\t\tDATA_MSGTYPE, flags, 0,\n\t\t\t\tmeta_ver,\n\t\t\t\tmeta, vif->fw_vif_idx);\n\n\t\tif (ret) {\n\t\t\tath6kl_warn(\"failed to add wmi data header:%d\\n\"\n\t\t\t\t, ret);\n\t\t\tgoto fail_tx;\n\t\t}\n\n\t\tif ((vif->nw_type == ADHOC_NETWORK) &&\n\t\t    ar->ibss_ps_enable && test_bit(CONNECTED, &vif->flags))\n\t\t\tchk_adhoc_ps_mapping = true;\n\t\telse {\n\t\t\t \n\t\t\tret = ath6kl_wmi_implicit_create_pstream(ar->wmi,\n\t\t\t\t    vif->fw_vif_idx, skb,\n\t\t\t\t    0, test_bit(WMM_ENABLED, &vif->flags), &ac);\n\t\t\tif (ret)\n\t\t\t\tgoto fail_tx;\n\t\t}\n\t} else {\n\t\tgoto fail_tx;\n\t}\n\n\tspin_lock_bh(&ar->lock);\n\n\tif (chk_adhoc_ps_mapping)\n\t\teid = ath6kl_ibss_map_epid(skb, dev, &map_no);\n\telse\n\t\teid = ar->ac2ep_map[ac];\n\n\tif (eid == 0 || eid == ENDPOINT_UNUSED) {\n\t\tath6kl_err(\"eid %d is not mapped!\\n\", eid);\n\t\tspin_unlock_bh(&ar->lock);\n\t\tgoto fail_tx;\n\t}\n\n\t \n\tcookie = ath6kl_alloc_cookie(ar);\n\n\tif (!cookie) {\n\t\tspin_unlock_bh(&ar->lock);\n\t\tgoto fail_tx;\n\t}\n\n\t \n\tar->tx_pending[eid]++;\n\tar->total_tx_data_pend++;\n\n\tspin_unlock_bh(&ar->lock);\n\n\tif (!IS_ALIGNED((unsigned long) skb->data - HTC_HDR_LENGTH, 4) &&\n\t    skb_cloned(skb)) {\n\t\t \n\t\tstruct sk_buff *nskb;\n\n\t\tnskb = skb_copy_expand(skb, HTC_HDR_LENGTH, 0, GFP_ATOMIC);\n\t\tif (nskb == NULL)\n\t\t\tgoto fail_tx;\n\t\tkfree_skb(skb);\n\t\tskb = nskb;\n\t}\n\n\tcookie->skb = skb;\n\tcookie->map_no = map_no;\n\tset_htc_pkt_info(&cookie->htc_pkt, cookie, skb->data, skb->len,\n\t\t\t eid, htc_tag);\n\tcookie->htc_pkt.skb = skb;\n\n\tath6kl_dbg_dump(ATH6KL_DBG_RAW_BYTES, __func__, \"tx \",\n\t\t\tskb->data, skb->len);\n\n\t \n\tath6kl_htc_tx(ar->htc_target, &cookie->htc_pkt);\n\n\treturn 0;\n\nfail_tx:\n\tdev_kfree_skb(skb);\n\n\tdev->stats.tx_dropped++;\n\tdev->stats.tx_aborted_errors++;\n\n\treturn 0;\n}\n\n \nvoid ath6kl_indicate_tx_activity(void *devt, u8 traffic_class, bool active)\n{\n\tstruct ath6kl *ar = devt;\n\tenum htc_endpoint_id eid;\n\tint i;\n\n\teid = ar->ac2ep_map[traffic_class];\n\n\tif (!test_bit(WMI_ENABLED, &ar->flag))\n\t\tgoto notify_htc;\n\n\tspin_lock_bh(&ar->lock);\n\n\tar->ac_stream_active[traffic_class] = active;\n\n\tif (active) {\n\t\t \n\t\tif (ar->ac_stream_pri_map[traffic_class] >\n\t\t    ar->hiac_stream_active_pri)\n\t\t\t \n\t\t\tar->hiac_stream_active_pri =\n\t\t\t\t\tar->ac_stream_pri_map[traffic_class];\n\n\t} else {\n\t\t \n\t\tif (ar->hiac_stream_active_pri ==\n\t\t\tar->ac_stream_pri_map[traffic_class]) {\n\t\t\t \n\t\t\tar->hiac_stream_active_pri = 0;\n\n\t\t\tfor (i = 0; i < WMM_NUM_AC; i++) {\n\t\t\t\tif (ar->ac_stream_active[i] &&\n\t\t\t\t    (ar->ac_stream_pri_map[i] >\n\t\t\t\t     ar->hiac_stream_active_pri))\n\t\t\t\t\t \n\t\t\t\t\tar->hiac_stream_active_pri =\n\t\t\t\t\t\tar->ac_stream_pri_map[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_unlock_bh(&ar->lock);\n\nnotify_htc:\n\t \n\tath6kl_htc_activity_changed(ar->htc_target, eid, active);\n}\n\nenum htc_send_full_action ath6kl_tx_queue_full(struct htc_target *target,\n\t\t\t\t\t       struct htc_packet *packet)\n{\n\tstruct ath6kl *ar = target->dev->ar;\n\tstruct ath6kl_vif *vif;\n\tenum htc_endpoint_id endpoint = packet->endpoint;\n\tenum htc_send_full_action action = HTC_SEND_FULL_KEEP;\n\n\tif (endpoint == ar->ctrl_ep) {\n\t\t \n\t\tset_bit(WMI_CTRL_EP_FULL, &ar->flag);\n\t\tath6kl_err(\"wmi ctrl ep is full\\n\");\n\t\tath6kl_recovery_err_notify(ar, ATH6KL_FW_EP_FULL);\n\t\treturn action;\n\t}\n\n\tif (packet->info.tx.tag == ATH6KL_CONTROL_PKT_TAG)\n\t\treturn action;\n\n\t \n\tif (ar->ac_stream_pri_map[ar->ep2ac_map[endpoint]] <\n\t    ar->hiac_stream_active_pri &&\n\t    ar->cookie_count <=\n\t\t\ttarget->endpoint[endpoint].tx_drop_packet_threshold)\n\t\t \n\t\taction = HTC_SEND_FULL_DROP;\n\n\t \n\tspin_lock_bh(&ar->list_lock);\n\tlist_for_each_entry(vif, &ar->vif_list, list) {\n\t\tif (vif->nw_type == ADHOC_NETWORK ||\n\t\t    action != HTC_SEND_FULL_DROP) {\n\t\t\tspin_unlock_bh(&ar->list_lock);\n\n\t\t\tset_bit(NETQ_STOPPED, &vif->flags);\n\t\t\tnetif_stop_queue(vif->ndev);\n\n\t\t\treturn action;\n\t\t}\n\t}\n\tspin_unlock_bh(&ar->list_lock);\n\n\treturn action;\n}\n\n \nstatic void ath6kl_tx_clear_node_map(struct ath6kl_vif *vif,\n\t\t\t\t     enum htc_endpoint_id eid, u32 map_no)\n{\n\tstruct ath6kl *ar = vif->ar;\n\tu32 i;\n\n\tif (vif->nw_type != ADHOC_NETWORK)\n\t\treturn;\n\n\tif (!ar->ibss_ps_enable)\n\t\treturn;\n\n\tif (eid == ar->ctrl_ep)\n\t\treturn;\n\n\tif (map_no == 0)\n\t\treturn;\n\n\tmap_no--;\n\tar->node_map[map_no].tx_pend--;\n\n\tif (ar->node_map[map_no].tx_pend)\n\t\treturn;\n\n\tif (map_no != (ar->node_num - 1))\n\t\treturn;\n\n\tfor (i = ar->node_num; i > 0; i--) {\n\t\tif (ar->node_map[i - 1].tx_pend)\n\t\t\tbreak;\n\n\t\tmemset(&ar->node_map[i - 1], 0,\n\t\t       sizeof(struct ath6kl_node_mapping));\n\t\tar->node_num--;\n\t}\n}\n\nvoid ath6kl_tx_complete(struct htc_target *target,\n\t\t\tstruct list_head *packet_queue)\n{\n\tstruct ath6kl *ar = target->dev->ar;\n\tstruct sk_buff_head skb_queue;\n\tstruct htc_packet *packet;\n\tstruct sk_buff *skb;\n\tstruct ath6kl_cookie *ath6kl_cookie;\n\tu32 map_no = 0;\n\tint status;\n\tenum htc_endpoint_id eid;\n\tbool wake_event = false;\n\tbool flushing[ATH6KL_VIF_MAX] = {false};\n\tu8 if_idx;\n\tstruct ath6kl_vif *vif;\n\n\tskb_queue_head_init(&skb_queue);\n\n\t \n\tspin_lock_bh(&ar->lock);\n\n\t \n\twhile (!list_empty(packet_queue)) {\n\t\tpacket = list_first_entry(packet_queue, struct htc_packet,\n\t\t\t\t\t  list);\n\t\tlist_del(&packet->list);\n\n\t\tif (WARN_ON_ONCE(packet->endpoint == ENDPOINT_UNUSED ||\n\t\t\t\t packet->endpoint >= ENDPOINT_MAX))\n\t\t\tcontinue;\n\n\t\tath6kl_cookie = (struct ath6kl_cookie *)packet->pkt_cntxt;\n\t\tif (WARN_ON_ONCE(!ath6kl_cookie))\n\t\t\tcontinue;\n\n\t\tstatus = packet->status;\n\t\tskb = ath6kl_cookie->skb;\n\t\teid = packet->endpoint;\n\t\tmap_no = ath6kl_cookie->map_no;\n\n\t\tif (WARN_ON_ONCE(!skb || !skb->data)) {\n\t\t\tdev_kfree_skb(skb);\n\t\t\tath6kl_free_cookie(ar, ath6kl_cookie);\n\t\t\tcontinue;\n\t\t}\n\n\t\t__skb_queue_tail(&skb_queue, skb);\n\n\t\tif (WARN_ON_ONCE(!status && (packet->act_len != skb->len))) {\n\t\t\tath6kl_free_cookie(ar, ath6kl_cookie);\n\t\t\tcontinue;\n\t\t}\n\n\t\tar->tx_pending[eid]--;\n\n\t\tif (eid != ar->ctrl_ep)\n\t\t\tar->total_tx_data_pend--;\n\n\t\tif (eid == ar->ctrl_ep) {\n\t\t\tif (test_bit(WMI_CTRL_EP_FULL, &ar->flag))\n\t\t\t\tclear_bit(WMI_CTRL_EP_FULL, &ar->flag);\n\n\t\t\tif (ar->tx_pending[eid] == 0)\n\t\t\t\twake_event = true;\n\t\t}\n\n\t\tif (eid == ar->ctrl_ep) {\n\t\t\tif_idx = wmi_cmd_hdr_get_if_idx(\n\t\t\t\t(struct wmi_cmd_hdr *) packet->buf);\n\t\t} else {\n\t\t\tif_idx = wmi_data_hdr_get_if_idx(\n\t\t\t\t(struct wmi_data_hdr *) packet->buf);\n\t\t}\n\n\t\tvif = ath6kl_get_vif_by_index(ar, if_idx);\n\t\tif (!vif) {\n\t\t\tath6kl_free_cookie(ar, ath6kl_cookie);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (status) {\n\t\t\tif (status == -ECANCELED)\n\t\t\t\t \n\t\t\t\tflushing[if_idx] = true;\n\n\t\t\tvif->ndev->stats.tx_errors++;\n\n\t\t\tif (status != -ENOSPC && status != -ECANCELED)\n\t\t\t\tath6kl_warn(\"tx complete error: %d\\n\", status);\n\n\t\t\tath6kl_dbg(ATH6KL_DBG_WLAN_TX,\n\t\t\t\t   \"%s: skb=0x%p data=0x%p len=0x%x eid=%d %s\\n\",\n\t\t\t\t   __func__, skb, packet->buf, packet->act_len,\n\t\t\t\t   eid, \"error!\");\n\t\t} else {\n\t\t\tath6kl_dbg(ATH6KL_DBG_WLAN_TX,\n\t\t\t\t   \"%s: skb=0x%p data=0x%p len=0x%x eid=%d %s\\n\",\n\t\t\t\t   __func__, skb, packet->buf, packet->act_len,\n\t\t\t\t   eid, \"OK\");\n\n\t\t\tflushing[if_idx] = false;\n\t\t\tvif->ndev->stats.tx_packets++;\n\t\t\tvif->ndev->stats.tx_bytes += skb->len;\n\t\t}\n\n\t\tath6kl_tx_clear_node_map(vif, eid, map_no);\n\n\t\tath6kl_free_cookie(ar, ath6kl_cookie);\n\n\t\tif (test_bit(NETQ_STOPPED, &vif->flags))\n\t\t\tclear_bit(NETQ_STOPPED, &vif->flags);\n\t}\n\n\tspin_unlock_bh(&ar->lock);\n\n\t__skb_queue_purge(&skb_queue);\n\n\t \n\tspin_lock_bh(&ar->list_lock);\n\tlist_for_each_entry(vif, &ar->vif_list, list) {\n\t\tif (test_bit(CONNECTED, &vif->flags) &&\n\t\t    !flushing[vif->fw_vif_idx]) {\n\t\t\tspin_unlock_bh(&ar->list_lock);\n\t\t\tnetif_wake_queue(vif->ndev);\n\t\t\tspin_lock_bh(&ar->list_lock);\n\t\t}\n\t}\n\tspin_unlock_bh(&ar->list_lock);\n\n\tif (wake_event)\n\t\twake_up(&ar->event_wq);\n\n\treturn;\n}\n\nvoid ath6kl_tx_data_cleanup(struct ath6kl *ar)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < WMM_NUM_AC; i++)\n\t\tath6kl_htc_flush_txep(ar->htc_target, ar->ac2ep_map[i],\n\t\t\t\t      ATH6KL_DATA_PKT_TAG);\n}\n\n \n\nstatic void ath6kl_deliver_frames_to_nw_stack(struct net_device *dev,\n\t\t\t\t\t      struct sk_buff *skb)\n{\n\tif (!skb)\n\t\treturn;\n\n\tskb->dev = dev;\n\n\tif (!(skb->dev->flags & IFF_UP)) {\n\t\tdev_kfree_skb(skb);\n\t\treturn;\n\t}\n\n\tskb->protocol = eth_type_trans(skb, skb->dev);\n\n\tnetif_rx(skb);\n}\n\nstatic void ath6kl_alloc_netbufs(struct sk_buff_head *q, u16 num)\n{\n\tstruct sk_buff *skb;\n\n\twhile (num) {\n\t\tskb = ath6kl_buf_alloc(ATH6KL_BUFFER_SIZE);\n\t\tif (!skb) {\n\t\t\tath6kl_err(\"netbuf allocation failed\\n\");\n\t\t\treturn;\n\t\t}\n\t\tskb_queue_tail(q, skb);\n\t\tnum--;\n\t}\n}\n\nstatic struct sk_buff *aggr_get_free_skb(struct aggr_info *p_aggr)\n{\n\tstruct sk_buff *skb = NULL;\n\n\tif (skb_queue_len(&p_aggr->rx_amsdu_freeq) <\n\t    (AGGR_NUM_OF_FREE_NETBUFS >> 2))\n\t\tath6kl_alloc_netbufs(&p_aggr->rx_amsdu_freeq,\n\t\t\t\t     AGGR_NUM_OF_FREE_NETBUFS);\n\n\tskb = skb_dequeue(&p_aggr->rx_amsdu_freeq);\n\n\treturn skb;\n}\n\nvoid ath6kl_rx_refill(struct htc_target *target, enum htc_endpoint_id endpoint)\n{\n\tstruct ath6kl *ar = target->dev->ar;\n\tstruct sk_buff *skb;\n\tint rx_buf;\n\tint n_buf_refill;\n\tstruct htc_packet *packet;\n\tstruct list_head queue;\n\n\tn_buf_refill = ATH6KL_MAX_RX_BUFFERS -\n\t\t\t  ath6kl_htc_get_rxbuf_num(ar->htc_target, endpoint);\n\n\tif (n_buf_refill <= 0)\n\t\treturn;\n\n\tINIT_LIST_HEAD(&queue);\n\n\tath6kl_dbg(ATH6KL_DBG_WLAN_RX,\n\t\t   \"%s: providing htc with %d buffers at eid=%d\\n\",\n\t\t   __func__, n_buf_refill, endpoint);\n\n\tfor (rx_buf = 0; rx_buf < n_buf_refill; rx_buf++) {\n\t\tskb = ath6kl_buf_alloc(ATH6KL_BUFFER_SIZE);\n\t\tif (!skb)\n\t\t\tbreak;\n\n\t\tpacket = (struct htc_packet *) skb->head;\n\t\tif (!IS_ALIGNED((unsigned long) skb->data, 4)) {\n\t\t\tsize_t len = skb_headlen(skb);\n\t\t\tskb->data = PTR_ALIGN(skb->data - 4, 4);\n\t\t\tskb_set_tail_pointer(skb, len);\n\t\t}\n\t\tset_htc_rxpkt_info(packet, skb, skb->data,\n\t\t\t\t   ATH6KL_BUFFER_SIZE, endpoint);\n\t\tpacket->skb = skb;\n\t\tlist_add_tail(&packet->list, &queue);\n\t}\n\n\tif (!list_empty(&queue))\n\t\tath6kl_htc_add_rxbuf_multiple(ar->htc_target, &queue);\n}\n\nvoid ath6kl_refill_amsdu_rxbufs(struct ath6kl *ar, int count)\n{\n\tstruct htc_packet *packet;\n\tstruct sk_buff *skb;\n\n\twhile (count) {\n\t\tskb = ath6kl_buf_alloc(ATH6KL_AMSDU_BUFFER_SIZE);\n\t\tif (!skb)\n\t\t\treturn;\n\n\t\tpacket = (struct htc_packet *) skb->head;\n\t\tif (!IS_ALIGNED((unsigned long) skb->data, 4)) {\n\t\t\tsize_t len = skb_headlen(skb);\n\t\t\tskb->data = PTR_ALIGN(skb->data - 4, 4);\n\t\t\tskb_set_tail_pointer(skb, len);\n\t\t}\n\t\tset_htc_rxpkt_info(packet, skb, skb->data,\n\t\t\t\t   ATH6KL_AMSDU_BUFFER_SIZE, 0);\n\t\tpacket->skb = skb;\n\n\t\tspin_lock_bh(&ar->lock);\n\t\tlist_add_tail(&packet->list, &ar->amsdu_rx_buffer_queue);\n\t\tspin_unlock_bh(&ar->lock);\n\t\tcount--;\n\t}\n}\n\n \nstruct htc_packet *ath6kl_alloc_amsdu_rxbuf(struct htc_target *target,\n\t\t\t\t\t    enum htc_endpoint_id endpoint,\n\t\t\t\t\t    int len)\n{\n\tstruct ath6kl *ar = target->dev->ar;\n\tstruct htc_packet *packet = NULL;\n\tstruct list_head *pkt_pos;\n\tint refill_cnt = 0, depth = 0;\n\n\tath6kl_dbg(ATH6KL_DBG_WLAN_RX, \"%s: eid=%d, len:%d\\n\",\n\t\t   __func__, endpoint, len);\n\n\tif ((len <= ATH6KL_BUFFER_SIZE) ||\n\t    (len > ATH6KL_AMSDU_BUFFER_SIZE))\n\t\treturn NULL;\n\n\tspin_lock_bh(&ar->lock);\n\n\tif (list_empty(&ar->amsdu_rx_buffer_queue)) {\n\t\tspin_unlock_bh(&ar->lock);\n\t\trefill_cnt = ATH6KL_MAX_AMSDU_RX_BUFFERS;\n\t\tgoto refill_buf;\n\t}\n\n\tpacket = list_first_entry(&ar->amsdu_rx_buffer_queue,\n\t\t\t\t  struct htc_packet, list);\n\tlist_del(&packet->list);\n\tlist_for_each(pkt_pos, &ar->amsdu_rx_buffer_queue)\n\t\tdepth++;\n\n\trefill_cnt = ATH6KL_MAX_AMSDU_RX_BUFFERS - depth;\n\tspin_unlock_bh(&ar->lock);\n\n\t \n\tpacket->endpoint = endpoint;\n\nrefill_buf:\n\tif (refill_cnt >= ATH6KL_AMSDU_REFILL_THRESHOLD)\n\t\tath6kl_refill_amsdu_rxbufs(ar, refill_cnt);\n\n\treturn packet;\n}\n\nstatic void aggr_slice_amsdu(struct aggr_info *p_aggr,\n\t\t\t     struct rxtid *rxtid, struct sk_buff *skb)\n{\n\tstruct sk_buff *new_skb;\n\tstruct ethhdr *hdr;\n\tu16 frame_8023_len, payload_8023_len, mac_hdr_len, amsdu_len;\n\tu8 *framep;\n\n\tmac_hdr_len = sizeof(struct ethhdr);\n\tframep = skb->data + mac_hdr_len;\n\tamsdu_len = skb->len - mac_hdr_len;\n\n\twhile (amsdu_len > mac_hdr_len) {\n\t\thdr = (struct ethhdr *) framep;\n\t\tpayload_8023_len = be16_to_cpu(hdr->h_proto);\n\n\t\tif (payload_8023_len < MIN_MSDU_SUBFRAME_PAYLOAD_LEN ||\n\t\t    payload_8023_len > MAX_MSDU_SUBFRAME_PAYLOAD_LEN) {\n\t\t\tath6kl_err(\"802.3 AMSDU frame bound check failed. len %d\\n\",\n\t\t\t\t   payload_8023_len);\n\t\t\tbreak;\n\t\t}\n\n\t\tframe_8023_len = payload_8023_len + mac_hdr_len;\n\t\tnew_skb = aggr_get_free_skb(p_aggr);\n\t\tif (!new_skb) {\n\t\t\tath6kl_err(\"no buffer available\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(new_skb->data, framep, frame_8023_len);\n\t\tskb_put(new_skb, frame_8023_len);\n\t\tif (ath6kl_wmi_dot3_2_dix(new_skb)) {\n\t\t\tath6kl_err(\"dot3_2_dix error\\n\");\n\t\t\tdev_kfree_skb(new_skb);\n\t\t\tbreak;\n\t\t}\n\n\t\tskb_queue_tail(&rxtid->q, new_skb);\n\n\t\t \n\t\tif ((amsdu_len - frame_8023_len) == 0)\n\t\t\tbreak;\n\n\t\t \n\t\tframe_8023_len = ALIGN(frame_8023_len, 4);\n\n\t\tframep += frame_8023_len;\n\t\tamsdu_len -= frame_8023_len;\n\t}\n\n\tdev_kfree_skb(skb);\n}\n\nstatic void aggr_deque_frms(struct aggr_info_conn *agg_conn, u8 tid,\n\t\t\t    u16 seq_no, u8 order)\n{\n\tstruct sk_buff *skb;\n\tstruct rxtid *rxtid;\n\tstruct skb_hold_q *node;\n\tu16 idx, idx_end, seq_end;\n\tstruct rxtid_stats *stats;\n\n\trxtid = &agg_conn->rx_tid[tid];\n\tstats = &agg_conn->stat[tid];\n\n\tspin_lock_bh(&rxtid->lock);\n\tidx = AGGR_WIN_IDX(rxtid->seq_next, rxtid->hold_q_sz);\n\n\t \n\tseq_end = seq_no ? seq_no : rxtid->seq_next;\n\tidx_end = AGGR_WIN_IDX(seq_end, rxtid->hold_q_sz);\n\n\tdo {\n\t\tnode = &rxtid->hold_q[idx];\n\t\tif ((order == 1) && (!node->skb))\n\t\t\tbreak;\n\n\t\tif (node->skb) {\n\t\t\tif (node->is_amsdu)\n\t\t\t\taggr_slice_amsdu(agg_conn->aggr_info, rxtid,\n\t\t\t\t\t\t node->skb);\n\t\t\telse\n\t\t\t\tskb_queue_tail(&rxtid->q, node->skb);\n\t\t\tnode->skb = NULL;\n\t\t} else {\n\t\t\tstats->num_hole++;\n\t\t}\n\n\t\trxtid->seq_next = ATH6KL_NEXT_SEQ_NO(rxtid->seq_next);\n\t\tidx = AGGR_WIN_IDX(rxtid->seq_next, rxtid->hold_q_sz);\n\t} while (idx != idx_end);\n\n\tspin_unlock_bh(&rxtid->lock);\n\n\tstats->num_delivered += skb_queue_len(&rxtid->q);\n\n\twhile ((skb = skb_dequeue(&rxtid->q)))\n\t\tath6kl_deliver_frames_to_nw_stack(agg_conn->dev, skb);\n}\n\nstatic bool aggr_process_recv_frm(struct aggr_info_conn *agg_conn, u8 tid,\n\t\t\t\t  u16 seq_no,\n\t\t\t\t  bool is_amsdu, struct sk_buff *frame)\n{\n\tstruct rxtid *rxtid;\n\tstruct rxtid_stats *stats;\n\tstruct sk_buff *skb;\n\tstruct skb_hold_q *node;\n\tu16 idx, st, cur, end;\n\tbool is_queued = false;\n\tu16 extended_end;\n\n\trxtid = &agg_conn->rx_tid[tid];\n\tstats = &agg_conn->stat[tid];\n\n\tstats->num_into_aggr++;\n\n\tif (!rxtid->aggr) {\n\t\tif (is_amsdu) {\n\t\t\taggr_slice_amsdu(agg_conn->aggr_info, rxtid, frame);\n\t\t\tis_queued = true;\n\t\t\tstats->num_amsdu++;\n\t\t\twhile ((skb = skb_dequeue(&rxtid->q)))\n\t\t\t\tath6kl_deliver_frames_to_nw_stack(agg_conn->dev,\n\t\t\t\t\t\t\t\t  skb);\n\t\t}\n\t\treturn is_queued;\n\t}\n\n\t \n\tst = rxtid->seq_next;\n\tcur = seq_no;\n\tend = (st + rxtid->hold_q_sz-1) & ATH6KL_MAX_SEQ_NO;\n\n\tif (((st < end) && (cur < st || cur > end)) ||\n\t    ((st > end) && (cur > end) && (cur < st))) {\n\t\textended_end = (end + rxtid->hold_q_sz - 1) &\n\t\t\tATH6KL_MAX_SEQ_NO;\n\n\t\tif (((end < extended_end) &&\n\t\t     (cur < end || cur > extended_end)) ||\n\t\t    ((end > extended_end) && (cur > extended_end) &&\n\t\t     (cur < end))) {\n\t\t\taggr_deque_frms(agg_conn, tid, 0, 0);\n\t\t\tspin_lock_bh(&rxtid->lock);\n\t\t\tif (cur >= rxtid->hold_q_sz - 1)\n\t\t\t\trxtid->seq_next = cur - (rxtid->hold_q_sz - 1);\n\t\t\telse\n\t\t\t\trxtid->seq_next = ATH6KL_MAX_SEQ_NO -\n\t\t\t\t\t\t  (rxtid->hold_q_sz - 2 - cur);\n\t\t\tspin_unlock_bh(&rxtid->lock);\n\t\t} else {\n\t\t\t \n\t\t\tif (cur >= rxtid->hold_q_sz - 1)\n\t\t\t\tst = cur - (rxtid->hold_q_sz - 1);\n\t\t\telse\n\t\t\t\tst = ATH6KL_MAX_SEQ_NO -\n\t\t\t\t\t(rxtid->hold_q_sz - 2 - cur);\n\n\t\t\taggr_deque_frms(agg_conn, tid, st, 0);\n\t\t}\n\n\t\tstats->num_oow++;\n\t}\n\n\tidx = AGGR_WIN_IDX(seq_no, rxtid->hold_q_sz);\n\n\tnode = &rxtid->hold_q[idx];\n\n\tspin_lock_bh(&rxtid->lock);\n\n\t \n\tdev_kfree_skb(node->skb);\n\tstats->num_dups++;\n\n\tnode->skb = frame;\n\tis_queued = true;\n\tnode->is_amsdu = is_amsdu;\n\tnode->seq_no = seq_no;\n\n\tif (node->is_amsdu)\n\t\tstats->num_amsdu++;\n\telse\n\t\tstats->num_mpdu++;\n\n\tspin_unlock_bh(&rxtid->lock);\n\n\taggr_deque_frms(agg_conn, tid, 0, 1);\n\n\tif (agg_conn->timer_scheduled)\n\t\treturn is_queued;\n\n\tspin_lock_bh(&rxtid->lock);\n\tfor (idx = 0; idx < rxtid->hold_q_sz; idx++) {\n\t\tif (rxtid->hold_q[idx].skb) {\n\t\t\t \n\t\t\tagg_conn->timer_scheduled = true;\n\t\t\tmod_timer(&agg_conn->timer,\n\t\t\t\t  (jiffies + (HZ * AGGR_RX_TIMEOUT) / 1000));\n\t\t\trxtid->timer_mon = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_bh(&rxtid->lock);\n\n\treturn is_queued;\n}\n\nstatic void ath6kl_uapsd_trigger_frame_rx(struct ath6kl_vif *vif,\n\t\t\t\t\t\t struct ath6kl_sta *conn)\n{\n\tstruct ath6kl *ar = vif->ar;\n\tbool is_apsdq_empty, is_apsdq_empty_at_start;\n\tu32 num_frames_to_deliver, flags;\n\tstruct sk_buff *skb = NULL;\n\n\t \n\n\tnum_frames_to_deliver = (conn->apsd_info >> ATH6KL_APSD_NUM_OF_AC) &\n\t\t\t\t\t\t    ATH6KL_APSD_FRAME_MASK;\n\t \n\tif (!num_frames_to_deliver)\n\t\tnum_frames_to_deliver = ATH6KL_APSD_ALL_FRAME;\n\n\tspin_lock_bh(&conn->psq_lock);\n\tis_apsdq_empty = skb_queue_empty(&conn->apsdq);\n\tspin_unlock_bh(&conn->psq_lock);\n\tis_apsdq_empty_at_start = is_apsdq_empty;\n\n\twhile ((!is_apsdq_empty) && (num_frames_to_deliver)) {\n\t\tspin_lock_bh(&conn->psq_lock);\n\t\tskb = skb_dequeue(&conn->apsdq);\n\t\tis_apsdq_empty = skb_queue_empty(&conn->apsdq);\n\t\tspin_unlock_bh(&conn->psq_lock);\n\n\t\t \n\t\tconn->sta_flags |= STA_PS_APSD_TRIGGER;\n\t\tnum_frames_to_deliver--;\n\n\t\t \n\t\tif ((is_apsdq_empty) || (!num_frames_to_deliver))\n\t\t\tconn->sta_flags |= STA_PS_APSD_EOSP;\n\n\t\tath6kl_data_tx(skb, vif->ndev);\n\t\tconn->sta_flags &= ~(STA_PS_APSD_TRIGGER);\n\t\tconn->sta_flags &= ~(STA_PS_APSD_EOSP);\n\t}\n\n\tif (is_apsdq_empty) {\n\t\tif (is_apsdq_empty_at_start)\n\t\t\tflags = WMI_AP_APSD_NO_DELIVERY_FRAMES;\n\t\telse\n\t\t\tflags = 0;\n\n\t\tath6kl_wmi_set_apsd_bfrd_traf(ar->wmi,\n\t\t\t\t\t      vif->fw_vif_idx,\n\t\t\t\t\t      conn->aid, 0, flags);\n\t}\n\n\treturn;\n}\n\nvoid ath6kl_rx(struct htc_target *target, struct htc_packet *packet)\n{\n\tstruct ath6kl *ar = target->dev->ar;\n\tstruct sk_buff *skb = packet->pkt_cntxt;\n\tstruct wmi_rx_meta_v2 *meta;\n\tstruct wmi_data_hdr *dhdr;\n\tint min_hdr_len;\n\tu8 meta_type, dot11_hdr = 0;\n\tu8 pad_before_data_start;\n\tint status = packet->status;\n\tenum htc_endpoint_id ept = packet->endpoint;\n\tbool is_amsdu, prev_ps, ps_state = false;\n\tbool trig_state = false;\n\tstruct ath6kl_sta *conn = NULL;\n\tstruct sk_buff *skb1 = NULL;\n\tstruct ethhdr *datap = NULL;\n\tstruct ath6kl_vif *vif;\n\tstruct aggr_info_conn *aggr_conn;\n\tu16 seq_no, offset;\n\tu8 tid, if_idx;\n\n\tath6kl_dbg(ATH6KL_DBG_WLAN_RX,\n\t\t   \"%s: ar=0x%p eid=%d, skb=0x%p, data=0x%p, len=0x%x status:%d\",\n\t\t   __func__, ar, ept, skb, packet->buf,\n\t\t   packet->act_len, status);\n\n\tif (status || packet->act_len < HTC_HDR_LENGTH) {\n\t\tdev_kfree_skb(skb);\n\t\treturn;\n\t}\n\n\tskb_put(skb, packet->act_len + HTC_HDR_LENGTH);\n\tskb_pull(skb, HTC_HDR_LENGTH);\n\n\tath6kl_dbg_dump(ATH6KL_DBG_RAW_BYTES, __func__, \"rx \",\n\t\t\tskb->data, skb->len);\n\n\tif (ept == ar->ctrl_ep) {\n\t\tif (test_bit(WMI_ENABLED, &ar->flag)) {\n\t\t\tath6kl_check_wow_status(ar);\n\t\t\tath6kl_wmi_control_rx(ar->wmi, skb);\n\t\t\treturn;\n\t\t}\n\t\tif_idx =\n\t\twmi_cmd_hdr_get_if_idx((struct wmi_cmd_hdr *) skb->data);\n\t} else {\n\t\tif_idx =\n\t\twmi_data_hdr_get_if_idx((struct wmi_data_hdr *) skb->data);\n\t}\n\n\tvif = ath6kl_get_vif_by_index(ar, if_idx);\n\tif (!vif) {\n\t\tdev_kfree_skb(skb);\n\t\treturn;\n\t}\n\n\t \n\tspin_lock_bh(&vif->if_lock);\n\n\tvif->ndev->stats.rx_packets++;\n\tvif->ndev->stats.rx_bytes += packet->act_len;\n\n\tspin_unlock_bh(&vif->if_lock);\n\n\tskb->dev = vif->ndev;\n\n\tif (!test_bit(WMI_ENABLED, &ar->flag)) {\n\t\tif (EPPING_ALIGNMENT_PAD > 0)\n\t\t\tskb_pull(skb, EPPING_ALIGNMENT_PAD);\n\t\tath6kl_deliver_frames_to_nw_stack(vif->ndev, skb);\n\t\treturn;\n\t}\n\n\tath6kl_check_wow_status(ar);\n\n\tmin_hdr_len = sizeof(struct ethhdr) + sizeof(struct wmi_data_hdr) +\n\t\t      sizeof(struct ath6kl_llc_snap_hdr);\n\n\tdhdr = (struct wmi_data_hdr *) skb->data;\n\n\t \n\tif (vif->nw_type != AP_NETWORK &&\n\t    ((packet->act_len < min_hdr_len) ||\n\t     (packet->act_len > WMI_MAX_AMSDU_RX_DATA_FRAME_LENGTH))) {\n\t\tath6kl_info(\"frame len is too short or too long\\n\");\n\t\tvif->ndev->stats.rx_errors++;\n\t\tvif->ndev->stats.rx_length_errors++;\n\t\tdev_kfree_skb(skb);\n\t\treturn;\n\t}\n\n\tpad_before_data_start =\n\t\t(le16_to_cpu(dhdr->info3) >> WMI_DATA_HDR_PAD_BEFORE_DATA_SHIFT)\n\t\t\t& WMI_DATA_HDR_PAD_BEFORE_DATA_MASK;\n\n\t \n\tif (vif->nw_type == AP_NETWORK) {\n\t\tmeta_type = wmi_data_hdr_get_meta(dhdr);\n\n\t\tps_state = !!((dhdr->info >> WMI_DATA_HDR_PS_SHIFT) &\n\t\t\t      WMI_DATA_HDR_PS_MASK);\n\n\t\toffset = sizeof(struct wmi_data_hdr) + pad_before_data_start;\n\t\ttrig_state = !!(le16_to_cpu(dhdr->info3) & WMI_DATA_HDR_TRIG);\n\n\t\tswitch (meta_type) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase WMI_META_VERSION_1:\n\t\t\toffset += sizeof(struct wmi_rx_meta_v1);\n\t\t\tbreak;\n\t\tcase WMI_META_VERSION_2:\n\t\t\toffset += sizeof(struct wmi_rx_meta_v2);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tdatap = (struct ethhdr *) (skb->data + offset);\n\t\tconn = ath6kl_find_sta(vif, datap->h_source);\n\n\t\tif (!conn) {\n\t\t\tdev_kfree_skb(skb);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tprev_ps = !!(conn->sta_flags & STA_PS_SLEEP);\n\n\t\tif (ps_state)\n\t\t\tconn->sta_flags |= STA_PS_SLEEP;\n\t\telse\n\t\t\tconn->sta_flags &= ~STA_PS_SLEEP;\n\n\t\t \n\t\tif ((conn->sta_flags & STA_PS_SLEEP) && trig_state)\n\t\t\tath6kl_uapsd_trigger_frame_rx(vif, conn);\n\n\t\tif (prev_ps ^ !!(conn->sta_flags & STA_PS_SLEEP)) {\n\t\t\tif (!(conn->sta_flags & STA_PS_SLEEP)) {\n\t\t\t\tstruct sk_buff *skbuff = NULL;\n\t\t\t\tbool is_apsdq_empty;\n\t\t\t\tstruct ath6kl_mgmt_buff *mgmt;\n\t\t\t\tu8 idx;\n\n\t\t\t\tspin_lock_bh(&conn->psq_lock);\n\t\t\t\twhile (conn->mgmt_psq_len > 0) {\n\t\t\t\t\tmgmt = list_first_entry(\n\t\t\t\t\t\t\t&conn->mgmt_psq,\n\t\t\t\t\t\t\tstruct ath6kl_mgmt_buff,\n\t\t\t\t\t\t\tlist);\n\t\t\t\t\tlist_del(&mgmt->list);\n\t\t\t\t\tconn->mgmt_psq_len--;\n\t\t\t\t\tspin_unlock_bh(&conn->psq_lock);\n\t\t\t\t\tidx = vif->fw_vif_idx;\n\n\t\t\t\t\tath6kl_wmi_send_mgmt_cmd(ar->wmi,\n\t\t\t\t\t\t\t\t idx,\n\t\t\t\t\t\t\t\t mgmt->id,\n\t\t\t\t\t\t\t\t mgmt->freq,\n\t\t\t\t\t\t\t\t mgmt->wait,\n\t\t\t\t\t\t\t\t mgmt->buf,\n\t\t\t\t\t\t\t\t mgmt->len,\n\t\t\t\t\t\t\t\t mgmt->no_cck);\n\n\t\t\t\t\tkfree(mgmt);\n\t\t\t\t\tspin_lock_bh(&conn->psq_lock);\n\t\t\t\t}\n\t\t\t\tconn->mgmt_psq_len = 0;\n\t\t\t\twhile ((skbuff = skb_dequeue(&conn->psq))) {\n\t\t\t\t\tspin_unlock_bh(&conn->psq_lock);\n\t\t\t\t\tath6kl_data_tx(skbuff, vif->ndev);\n\t\t\t\t\tspin_lock_bh(&conn->psq_lock);\n\t\t\t\t}\n\n\t\t\t\tis_apsdq_empty = skb_queue_empty(&conn->apsdq);\n\t\t\t\twhile ((skbuff = skb_dequeue(&conn->apsdq))) {\n\t\t\t\t\tspin_unlock_bh(&conn->psq_lock);\n\t\t\t\t\tath6kl_data_tx(skbuff, vif->ndev);\n\t\t\t\t\tspin_lock_bh(&conn->psq_lock);\n\t\t\t\t}\n\t\t\t\tspin_unlock_bh(&conn->psq_lock);\n\n\t\t\t\tif (!is_apsdq_empty)\n\t\t\t\t\tath6kl_wmi_set_apsd_bfrd_traf(\n\t\t\t\t\t\t\tar->wmi,\n\t\t\t\t\t\t\tvif->fw_vif_idx,\n\t\t\t\t\t\t\tconn->aid, 0, 0);\n\n\t\t\t\t \n\t\t\t\tath6kl_wmi_set_pvb_cmd(ar->wmi, vif->fw_vif_idx,\n\t\t\t\t\t\t       conn->aid, 0);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif ((packet->act_len < min_hdr_len) ||\n\t\t    (packet->act_len >\n\t\t     WMI_MAX_AMSDU_RX_DATA_FRAME_LENGTH)) {\n\t\t\tdev_kfree_skb(skb);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tis_amsdu = wmi_data_hdr_is_amsdu(dhdr) ? true : false;\n\ttid = wmi_data_hdr_get_up(dhdr);\n\tseq_no = wmi_data_hdr_get_seqno(dhdr);\n\tmeta_type = wmi_data_hdr_get_meta(dhdr);\n\tdot11_hdr = wmi_data_hdr_get_dot11(dhdr);\n\n\tskb_pull(skb, sizeof(struct wmi_data_hdr));\n\n\tswitch (meta_type) {\n\tcase WMI_META_VERSION_1:\n\t\tskb_pull(skb, sizeof(struct wmi_rx_meta_v1));\n\t\tbreak;\n\tcase WMI_META_VERSION_2:\n\t\tmeta = (struct wmi_rx_meta_v2 *) skb->data;\n\t\tif (meta->csum_flags & 0x1) {\n\t\t\tskb->ip_summed = CHECKSUM_COMPLETE;\n\t\t\tskb->csum = (__force __wsum) meta->csum;\n\t\t}\n\t\tskb_pull(skb, sizeof(struct wmi_rx_meta_v2));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tskb_pull(skb, pad_before_data_start);\n\n\tif (dot11_hdr)\n\t\tstatus = ath6kl_wmi_dot11_hdr_remove(ar->wmi, skb);\n\telse if (!is_amsdu)\n\t\tstatus = ath6kl_wmi_dot3_2_dix(skb);\n\n\tif (status) {\n\t\t \n\t\tdev_kfree_skb(skb);\n\t\treturn;\n\t}\n\n\tif (!(vif->ndev->flags & IFF_UP)) {\n\t\tdev_kfree_skb(skb);\n\t\treturn;\n\t}\n\n\tif (vif->nw_type == AP_NETWORK) {\n\t\tdatap = (struct ethhdr *) skb->data;\n\t\tif (is_multicast_ether_addr(datap->h_dest))\n\t\t\t \n\t\t\tskb1 = skb_copy(skb, GFP_ATOMIC);\n\t\telse {\n\t\t\t \n\t\t\tconn = ath6kl_find_sta(vif, datap->h_dest);\n\n\t\t\tif (conn && ar->intra_bss) {\n\t\t\t\tskb1 = skb;\n\t\t\t\tskb = NULL;\n\t\t\t} else if (conn && !ar->intra_bss) {\n\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\tskb = NULL;\n\t\t\t}\n\t\t}\n\t\tif (skb1)\n\t\t\tath6kl_data_tx(skb1, vif->ndev);\n\n\t\tif (skb == NULL) {\n\t\t\t \n\t\t\treturn;\n\t\t}\n\t}\n\n\tdatap = (struct ethhdr *) skb->data;\n\n\tif (is_unicast_ether_addr(datap->h_dest)) {\n\t\tif (vif->nw_type == AP_NETWORK) {\n\t\t\tconn = ath6kl_find_sta(vif, datap->h_source);\n\t\t\tif (!conn)\n\t\t\t\treturn;\n\t\t\taggr_conn = conn->aggr_conn;\n\t\t} else {\n\t\t\taggr_conn = vif->aggr_cntxt->aggr_conn;\n\t\t}\n\n\t\tif (aggr_process_recv_frm(aggr_conn, tid, seq_no,\n\t\t\t\t\t  is_amsdu, skb)) {\n\t\t\t \n\t\t\treturn;\n\t\t}\n\t} else if (!is_broadcast_ether_addr(datap->h_dest)) {\n\t\tvif->ndev->stats.multicast++;\n\t}\n\n\tath6kl_deliver_frames_to_nw_stack(vif->ndev, skb);\n}\n\nstatic void aggr_timeout(struct timer_list *t)\n{\n\tu8 i, j;\n\tstruct aggr_info_conn *aggr_conn = from_timer(aggr_conn, t, timer);\n\tstruct rxtid *rxtid;\n\tstruct rxtid_stats *stats;\n\n\tfor (i = 0; i < NUM_OF_TIDS; i++) {\n\t\trxtid = &aggr_conn->rx_tid[i];\n\t\tstats = &aggr_conn->stat[i];\n\n\t\tif (!rxtid->aggr || !rxtid->timer_mon)\n\t\t\tcontinue;\n\n\t\tstats->num_timeouts++;\n\t\tath6kl_dbg(ATH6KL_DBG_AGGR,\n\t\t\t   \"aggr timeout (st %d end %d)\\n\",\n\t\t\t   rxtid->seq_next,\n\t\t\t   ((rxtid->seq_next + rxtid->hold_q_sz-1) &\n\t\t\t    ATH6KL_MAX_SEQ_NO));\n\t\taggr_deque_frms(aggr_conn, i, 0, 0);\n\t}\n\n\taggr_conn->timer_scheduled = false;\n\n\tfor (i = 0; i < NUM_OF_TIDS; i++) {\n\t\trxtid = &aggr_conn->rx_tid[i];\n\n\t\tif (rxtid->aggr && rxtid->hold_q) {\n\t\t\tspin_lock_bh(&rxtid->lock);\n\t\t\tfor (j = 0; j < rxtid->hold_q_sz; j++) {\n\t\t\t\tif (rxtid->hold_q[j].skb) {\n\t\t\t\t\taggr_conn->timer_scheduled = true;\n\t\t\t\t\trxtid->timer_mon = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock_bh(&rxtid->lock);\n\n\t\t\tif (j >= rxtid->hold_q_sz)\n\t\t\t\trxtid->timer_mon = false;\n\t\t}\n\t}\n\n\tif (aggr_conn->timer_scheduled)\n\t\tmod_timer(&aggr_conn->timer,\n\t\t\t  jiffies + msecs_to_jiffies(AGGR_RX_TIMEOUT));\n}\n\nstatic void aggr_delete_tid_state(struct aggr_info_conn *aggr_conn, u8 tid)\n{\n\tstruct rxtid *rxtid;\n\tstruct rxtid_stats *stats;\n\n\tif (!aggr_conn || tid >= NUM_OF_TIDS)\n\t\treturn;\n\n\trxtid = &aggr_conn->rx_tid[tid];\n\tstats = &aggr_conn->stat[tid];\n\n\tif (rxtid->aggr)\n\t\taggr_deque_frms(aggr_conn, tid, 0, 0);\n\n\trxtid->aggr = false;\n\trxtid->timer_mon = false;\n\trxtid->win_sz = 0;\n\trxtid->seq_next = 0;\n\trxtid->hold_q_sz = 0;\n\n\tkfree(rxtid->hold_q);\n\trxtid->hold_q = NULL;\n\n\tmemset(stats, 0, sizeof(struct rxtid_stats));\n}\n\nvoid aggr_recv_addba_req_evt(struct ath6kl_vif *vif, u8 tid_mux, u16 seq_no,\n\t\t\t     u8 win_sz)\n{\n\tstruct ath6kl_sta *sta;\n\tstruct aggr_info_conn *aggr_conn = NULL;\n\tstruct rxtid *rxtid;\n\tu16 hold_q_size;\n\tu8 tid, aid;\n\n\tif (vif->nw_type == AP_NETWORK) {\n\t\taid = ath6kl_get_aid(tid_mux);\n\t\tsta = ath6kl_find_sta_by_aid(vif->ar, aid);\n\t\tif (sta)\n\t\t\taggr_conn = sta->aggr_conn;\n\t} else {\n\t\taggr_conn = vif->aggr_cntxt->aggr_conn;\n\t}\n\n\tif (!aggr_conn)\n\t\treturn;\n\n\ttid = ath6kl_get_tid(tid_mux);\n\tif (tid >= NUM_OF_TIDS)\n\t\treturn;\n\n\trxtid = &aggr_conn->rx_tid[tid];\n\n\tif (win_sz < AGGR_WIN_SZ_MIN || win_sz > AGGR_WIN_SZ_MAX)\n\t\tath6kl_dbg(ATH6KL_DBG_WLAN_RX, \"%s: win_sz %d, tid %d\\n\",\n\t\t\t   __func__, win_sz, tid);\n\n\tif (rxtid->aggr)\n\t\taggr_delete_tid_state(aggr_conn, tid);\n\n\trxtid->seq_next = seq_no;\n\thold_q_size = TID_WINDOW_SZ(win_sz) * sizeof(struct skb_hold_q);\n\trxtid->hold_q = kzalloc(hold_q_size, GFP_KERNEL);\n\tif (!rxtid->hold_q)\n\t\treturn;\n\n\trxtid->win_sz = win_sz;\n\trxtid->hold_q_sz = TID_WINDOW_SZ(win_sz);\n\tif (!skb_queue_empty(&rxtid->q))\n\t\treturn;\n\n\trxtid->aggr = true;\n}\n\nvoid aggr_conn_init(struct ath6kl_vif *vif, struct aggr_info *aggr_info,\n\t\t    struct aggr_info_conn *aggr_conn)\n{\n\tstruct rxtid *rxtid;\n\tu8 i;\n\n\taggr_conn->aggr_sz = AGGR_SZ_DEFAULT;\n\taggr_conn->dev = vif->ndev;\n\ttimer_setup(&aggr_conn->timer, aggr_timeout, 0);\n\taggr_conn->aggr_info = aggr_info;\n\n\taggr_conn->timer_scheduled = false;\n\n\tfor (i = 0; i < NUM_OF_TIDS; i++) {\n\t\trxtid = &aggr_conn->rx_tid[i];\n\t\trxtid->aggr = false;\n\t\trxtid->timer_mon = false;\n\t\tskb_queue_head_init(&rxtid->q);\n\t\tspin_lock_init(&rxtid->lock);\n\t}\n}\n\nstruct aggr_info *aggr_init(struct ath6kl_vif *vif)\n{\n\tstruct aggr_info *p_aggr = NULL;\n\n\tp_aggr = kzalloc(sizeof(struct aggr_info), GFP_KERNEL);\n\tif (!p_aggr) {\n\t\tath6kl_err(\"failed to alloc memory for aggr_node\\n\");\n\t\treturn NULL;\n\t}\n\n\tp_aggr->aggr_conn = kzalloc(sizeof(struct aggr_info_conn), GFP_KERNEL);\n\tif (!p_aggr->aggr_conn) {\n\t\tath6kl_err(\"failed to alloc memory for connection specific aggr info\\n\");\n\t\tkfree(p_aggr);\n\t\treturn NULL;\n\t}\n\n\taggr_conn_init(vif, p_aggr, p_aggr->aggr_conn);\n\n\tskb_queue_head_init(&p_aggr->rx_amsdu_freeq);\n\tath6kl_alloc_netbufs(&p_aggr->rx_amsdu_freeq, AGGR_NUM_OF_FREE_NETBUFS);\n\n\treturn p_aggr;\n}\n\nvoid aggr_recv_delba_req_evt(struct ath6kl_vif *vif, u8 tid_mux)\n{\n\tstruct ath6kl_sta *sta;\n\tstruct rxtid *rxtid;\n\tstruct aggr_info_conn *aggr_conn = NULL;\n\tu8 tid, aid;\n\n\tif (vif->nw_type == AP_NETWORK) {\n\t\taid = ath6kl_get_aid(tid_mux);\n\t\tsta = ath6kl_find_sta_by_aid(vif->ar, aid);\n\t\tif (sta)\n\t\t\taggr_conn = sta->aggr_conn;\n\t} else {\n\t\taggr_conn = vif->aggr_cntxt->aggr_conn;\n\t}\n\n\tif (!aggr_conn)\n\t\treturn;\n\n\ttid = ath6kl_get_tid(tid_mux);\n\tif (tid >= NUM_OF_TIDS)\n\t\treturn;\n\n\trxtid = &aggr_conn->rx_tid[tid];\n\n\tif (rxtid->aggr)\n\t\taggr_delete_tid_state(aggr_conn, tid);\n}\n\nvoid aggr_reset_state(struct aggr_info_conn *aggr_conn)\n{\n\tu8 tid;\n\n\tif (!aggr_conn)\n\t\treturn;\n\n\tif (aggr_conn->timer_scheduled) {\n\t\tdel_timer(&aggr_conn->timer);\n\t\taggr_conn->timer_scheduled = false;\n\t}\n\n\tfor (tid = 0; tid < NUM_OF_TIDS; tid++)\n\t\taggr_delete_tid_state(aggr_conn, tid);\n}\n\n \nvoid ath6kl_cleanup_amsdu_rxbufs(struct ath6kl *ar)\n{\n\tstruct htc_packet *packet, *tmp_pkt;\n\n\tspin_lock_bh(&ar->lock);\n\tif (list_empty(&ar->amsdu_rx_buffer_queue)) {\n\t\tspin_unlock_bh(&ar->lock);\n\t\treturn;\n\t}\n\n\tlist_for_each_entry_safe(packet, tmp_pkt, &ar->amsdu_rx_buffer_queue,\n\t\t\t\t list) {\n\t\tlist_del(&packet->list);\n\t\tspin_unlock_bh(&ar->lock);\n\t\tdev_kfree_skb(packet->pkt_cntxt);\n\t\tspin_lock_bh(&ar->lock);\n\t}\n\n\tspin_unlock_bh(&ar->lock);\n}\n\nvoid aggr_module_destroy(struct aggr_info *aggr_info)\n{\n\tif (!aggr_info)\n\t\treturn;\n\n\taggr_reset_state(aggr_info->aggr_conn);\n\tskb_queue_purge(&aggr_info->rx_amsdu_freeq);\n\tkfree(aggr_info->aggr_conn);\n\tkfree(aggr_info);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}