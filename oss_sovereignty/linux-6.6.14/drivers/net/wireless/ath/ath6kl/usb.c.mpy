{
  "module_name": "usb.c",
  "hash_id": "679679ce874d8bfa1727ac0f7e2e0280c34473e9a710734585a4ef6e552d5802",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath6kl/usb.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/usb.h>\n\n#include \"debug.h\"\n#include \"core.h\"\n\n \n#define TX_URB_COUNT            32\n#define RX_URB_COUNT            32\n#define ATH6KL_USB_RX_BUFFER_SIZE  4096\n\n \nenum ATH6KL_USB_PIPE_ID {\n\tATH6KL_USB_PIPE_TX_CTRL = 0,\n\tATH6KL_USB_PIPE_TX_DATA_LP,\n\tATH6KL_USB_PIPE_TX_DATA_MP,\n\tATH6KL_USB_PIPE_TX_DATA_HP,\n\tATH6KL_USB_PIPE_RX_CTRL,\n\tATH6KL_USB_PIPE_RX_DATA,\n\tATH6KL_USB_PIPE_RX_DATA2,\n\tATH6KL_USB_PIPE_RX_INT,\n\tATH6KL_USB_PIPE_MAX\n};\n\n#define ATH6KL_USB_PIPE_INVALID ATH6KL_USB_PIPE_MAX\n\nstruct ath6kl_usb_pipe {\n\tstruct list_head urb_list_head;\n\tstruct usb_anchor urb_submitted;\n\tu32 urb_alloc;\n\tu32 urb_cnt;\n\tu32 urb_cnt_thresh;\n\tunsigned int usb_pipe_handle;\n\tu32 flags;\n\tu8 ep_address;\n\tu8 logical_pipe_num;\n\tstruct ath6kl_usb *ar_usb;\n\tu16 max_packet_size;\n\tstruct work_struct io_complete_work;\n\tstruct sk_buff_head io_comp_queue;\n\tstruct usb_endpoint_descriptor *ep_desc;\n};\n\n#define ATH6KL_USB_PIPE_FLAG_TX    (1 << 0)\n\n \nstruct ath6kl_usb {\n\t \n\tspinlock_t cs_lock;\n\n\tstruct usb_device *udev;\n\tstruct usb_interface *interface;\n\tstruct ath6kl_usb_pipe pipes[ATH6KL_USB_PIPE_MAX];\n\tu8 *diag_cmd_buffer;\n\tu8 *diag_resp_buffer;\n\tstruct ath6kl *ar;\n\tstruct workqueue_struct *wq;\n};\n\n \nstruct ath6kl_urb_context {\n\tstruct list_head link;\n\tstruct ath6kl_usb_pipe *pipe;\n\tstruct sk_buff *skb;\n\tstruct ath6kl *ar;\n};\n\n \n#define ATH6KL_USB_EP_ADDR_APP_CTRL_IN          0x81\n#define ATH6KL_USB_EP_ADDR_APP_DATA_IN          0x82\n#define ATH6KL_USB_EP_ADDR_APP_DATA2_IN         0x83\n#define ATH6KL_USB_EP_ADDR_APP_INT_IN           0x84\n\n#define ATH6KL_USB_EP_ADDR_APP_CTRL_OUT         0x01\n#define ATH6KL_USB_EP_ADDR_APP_DATA_LP_OUT      0x02\n#define ATH6KL_USB_EP_ADDR_APP_DATA_MP_OUT      0x03\n#define ATH6KL_USB_EP_ADDR_APP_DATA_HP_OUT      0x04\n\n \n#define ATH6KL_USB_CONTROL_REQ_SEND_BMI_CMD        1\n#define ATH6KL_USB_CONTROL_REQ_RECV_BMI_RESP       2\n#define ATH6KL_USB_CONTROL_REQ_DIAG_CMD            3\n#define ATH6KL_USB_CONTROL_REQ_DIAG_RESP           4\n\n#define ATH6KL_USB_CTRL_DIAG_CC_READ               0\n#define ATH6KL_USB_CTRL_DIAG_CC_WRITE              1\n\nstruct ath6kl_usb_ctrl_diag_cmd_write {\n\t__le32 cmd;\n\t__le32 address;\n\t__le32 value;\n\t__le32 _pad[1];\n} __packed;\n\nstruct ath6kl_usb_ctrl_diag_cmd_read {\n\t__le32 cmd;\n\t__le32 address;\n} __packed;\n\nstruct ath6kl_usb_ctrl_diag_resp_read {\n\t__le32 value;\n} __packed;\n\n \nstatic void ath6kl_usb_recv_complete(struct urb *urb);\n\n#define ATH6KL_USB_IS_BULK_EP(attr) (((attr) & 3) == 0x02)\n#define ATH6KL_USB_IS_INT_EP(attr)  (((attr) & 3) == 0x03)\n#define ATH6KL_USB_IS_ISOC_EP(attr)  (((attr) & 3) == 0x01)\n#define ATH6KL_USB_IS_DIR_IN(addr)  ((addr) & 0x80)\n\n \nstatic struct ath6kl_urb_context *\nath6kl_usb_alloc_urb_from_pipe(struct ath6kl_usb_pipe *pipe)\n{\n\tstruct ath6kl_urb_context *urb_context = NULL;\n\tunsigned long flags;\n\n\t \n\tif (!pipe->ar_usb)\n\t\treturn NULL;\n\n\tspin_lock_irqsave(&pipe->ar_usb->cs_lock, flags);\n\tif (!list_empty(&pipe->urb_list_head)) {\n\t\turb_context =\n\t\t    list_first_entry(&pipe->urb_list_head,\n\t\t\t\t     struct ath6kl_urb_context, link);\n\t\tlist_del(&urb_context->link);\n\t\tpipe->urb_cnt--;\n\t}\n\tspin_unlock_irqrestore(&pipe->ar_usb->cs_lock, flags);\n\n\treturn urb_context;\n}\n\nstatic void ath6kl_usb_free_urb_to_pipe(struct ath6kl_usb_pipe *pipe,\n\t\t\t\t\tstruct ath6kl_urb_context *urb_context)\n{\n\tunsigned long flags;\n\n\t \n\tif (!pipe->ar_usb)\n\t\treturn;\n\n\tspin_lock_irqsave(&pipe->ar_usb->cs_lock, flags);\n\tpipe->urb_cnt++;\n\n\tlist_add(&urb_context->link, &pipe->urb_list_head);\n\tspin_unlock_irqrestore(&pipe->ar_usb->cs_lock, flags);\n}\n\nstatic void ath6kl_usb_cleanup_recv_urb(struct ath6kl_urb_context *urb_context)\n{\n\tdev_kfree_skb(urb_context->skb);\n\turb_context->skb = NULL;\n\n\tath6kl_usb_free_urb_to_pipe(urb_context->pipe, urb_context);\n}\n\nstatic inline struct ath6kl_usb *ath6kl_usb_priv(struct ath6kl *ar)\n{\n\treturn ar->hif_priv;\n}\n\n \nstatic int ath6kl_usb_alloc_pipe_resources(struct ath6kl_usb_pipe *pipe,\n\t\t\t\t\t   int urb_cnt)\n{\n\tstruct ath6kl_urb_context *urb_context;\n\tint status = 0, i;\n\n\tINIT_LIST_HEAD(&pipe->urb_list_head);\n\tinit_usb_anchor(&pipe->urb_submitted);\n\n\tfor (i = 0; i < urb_cnt; i++) {\n\t\turb_context = kzalloc(sizeof(struct ath6kl_urb_context),\n\t\t\t\t      GFP_KERNEL);\n\t\tif (urb_context == NULL) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tgoto fail_alloc_pipe_resources;\n\t\t}\n\n\t\turb_context->pipe = pipe;\n\n\t\t \n\t\tpipe->urb_alloc++;\n\t\tath6kl_usb_free_urb_to_pipe(pipe, urb_context);\n\t}\n\n\tath6kl_dbg(ATH6KL_DBG_USB,\n\t\t   \"ath6kl usb: alloc resources lpipe:%d hpipe:0x%X urbs:%d\\n\",\n\t\t   pipe->logical_pipe_num, pipe->usb_pipe_handle,\n\t\t   pipe->urb_alloc);\n\nfail_alloc_pipe_resources:\n\treturn status;\n}\n\nstatic void ath6kl_usb_free_pipe_resources(struct ath6kl_usb_pipe *pipe)\n{\n\tstruct ath6kl_urb_context *urb_context;\n\n\tif (pipe->ar_usb == NULL) {\n\t\t \n\t\treturn;\n\t}\n\n\tath6kl_dbg(ATH6KL_DBG_USB,\n\t\t   \"ath6kl usb: free resources lpipe:%d\"\n\t\t   \"hpipe:0x%X urbs:%d avail:%d\\n\",\n\t\t   pipe->logical_pipe_num, pipe->usb_pipe_handle,\n\t\t   pipe->urb_alloc, pipe->urb_cnt);\n\n\tif (pipe->urb_alloc != pipe->urb_cnt) {\n\t\tath6kl_dbg(ATH6KL_DBG_USB,\n\t\t\t   \"ath6kl usb: urb leak! lpipe:%d\"\n\t\t\t   \"hpipe:0x%X urbs:%d avail:%d\\n\",\n\t\t\t   pipe->logical_pipe_num, pipe->usb_pipe_handle,\n\t\t\t   pipe->urb_alloc, pipe->urb_cnt);\n\t}\n\n\twhile (true) {\n\t\turb_context = ath6kl_usb_alloc_urb_from_pipe(pipe);\n\t\tif (urb_context == NULL)\n\t\t\tbreak;\n\t\tkfree(urb_context);\n\t}\n}\n\nstatic void ath6kl_usb_cleanup_pipe_resources(struct ath6kl_usb *ar_usb)\n{\n\tint i;\n\n\tfor (i = 0; i < ATH6KL_USB_PIPE_MAX; i++)\n\t\tath6kl_usb_free_pipe_resources(&ar_usb->pipes[i]);\n}\n\nstatic u8 ath6kl_usb_get_logical_pipe_num(struct ath6kl_usb *ar_usb,\n\t\t\t\t\t  u8 ep_address, int *urb_count)\n{\n\tu8 pipe_num = ATH6KL_USB_PIPE_INVALID;\n\n\tswitch (ep_address) {\n\tcase ATH6KL_USB_EP_ADDR_APP_CTRL_IN:\n\t\tpipe_num = ATH6KL_USB_PIPE_RX_CTRL;\n\t\t*urb_count = RX_URB_COUNT;\n\t\tbreak;\n\tcase ATH6KL_USB_EP_ADDR_APP_DATA_IN:\n\t\tpipe_num = ATH6KL_USB_PIPE_RX_DATA;\n\t\t*urb_count = RX_URB_COUNT;\n\t\tbreak;\n\tcase ATH6KL_USB_EP_ADDR_APP_INT_IN:\n\t\tpipe_num = ATH6KL_USB_PIPE_RX_INT;\n\t\t*urb_count = RX_URB_COUNT;\n\t\tbreak;\n\tcase ATH6KL_USB_EP_ADDR_APP_DATA2_IN:\n\t\tpipe_num = ATH6KL_USB_PIPE_RX_DATA2;\n\t\t*urb_count = RX_URB_COUNT;\n\t\tbreak;\n\tcase ATH6KL_USB_EP_ADDR_APP_CTRL_OUT:\n\t\tpipe_num = ATH6KL_USB_PIPE_TX_CTRL;\n\t\t*urb_count = TX_URB_COUNT;\n\t\tbreak;\n\tcase ATH6KL_USB_EP_ADDR_APP_DATA_LP_OUT:\n\t\tpipe_num = ATH6KL_USB_PIPE_TX_DATA_LP;\n\t\t*urb_count = TX_URB_COUNT;\n\t\tbreak;\n\tcase ATH6KL_USB_EP_ADDR_APP_DATA_MP_OUT:\n\t\tpipe_num = ATH6KL_USB_PIPE_TX_DATA_MP;\n\t\t*urb_count = TX_URB_COUNT;\n\t\tbreak;\n\tcase ATH6KL_USB_EP_ADDR_APP_DATA_HP_OUT:\n\t\tpipe_num = ATH6KL_USB_PIPE_TX_DATA_HP;\n\t\t*urb_count = TX_URB_COUNT;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\treturn pipe_num;\n}\n\nstatic int ath6kl_usb_setup_pipe_resources(struct ath6kl_usb *ar_usb)\n{\n\tstruct usb_interface *interface = ar_usb->interface;\n\tstruct usb_host_interface *iface_desc = interface->cur_altsetting;\n\tstruct usb_endpoint_descriptor *endpoint;\n\tstruct ath6kl_usb_pipe *pipe;\n\tint i, urbcount, status = 0;\n\tu8 pipe_num;\n\n\tath6kl_dbg(ATH6KL_DBG_USB, \"setting up USB Pipes using interface\\n\");\n\n\t \n\tfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\n\t\tendpoint = &iface_desc->endpoint[i].desc;\n\n\t\tif (ATH6KL_USB_IS_BULK_EP(endpoint->bmAttributes)) {\n\t\t\tath6kl_dbg(ATH6KL_DBG_USB,\n\t\t\t\t   \"%s Bulk Ep:0x%2.2X maxpktsz:%d\\n\",\n\t\t\t\t   ATH6KL_USB_IS_DIR_IN\n\t\t\t\t   (endpoint->bEndpointAddress) ?\n\t\t\t\t   \"RX\" : \"TX\", endpoint->bEndpointAddress,\n\t\t\t\t   le16_to_cpu(endpoint->wMaxPacketSize));\n\t\t} else if (ATH6KL_USB_IS_INT_EP(endpoint->bmAttributes)) {\n\t\t\tath6kl_dbg(ATH6KL_DBG_USB,\n\t\t\t\t   \"%s Int Ep:0x%2.2X maxpktsz:%d interval:%d\\n\",\n\t\t\t\t   ATH6KL_USB_IS_DIR_IN\n\t\t\t\t   (endpoint->bEndpointAddress) ?\n\t\t\t\t   \"RX\" : \"TX\", endpoint->bEndpointAddress,\n\t\t\t\t   le16_to_cpu(endpoint->wMaxPacketSize),\n\t\t\t\t   endpoint->bInterval);\n\t\t} else if (ATH6KL_USB_IS_ISOC_EP(endpoint->bmAttributes)) {\n\t\t\t \n\t\t\tath6kl_dbg(ATH6KL_DBG_USB,\n\t\t\t\t   \"%s ISOC Ep:0x%2.2X maxpktsz:%d interval:%d\\n\",\n\t\t\t\t   ATH6KL_USB_IS_DIR_IN\n\t\t\t\t   (endpoint->bEndpointAddress) ?\n\t\t\t\t   \"RX\" : \"TX\", endpoint->bEndpointAddress,\n\t\t\t\t   le16_to_cpu(endpoint->wMaxPacketSize),\n\t\t\t\t   endpoint->bInterval);\n\t\t}\n\n\t\t \n\t\tif (usb_endpoint_maxp(endpoint) == 0)\n\t\t\tcontinue;\n\n\t\turbcount = 0;\n\n\t\tpipe_num =\n\t\t    ath6kl_usb_get_logical_pipe_num(ar_usb,\n\t\t\t\t\t\t    endpoint->bEndpointAddress,\n\t\t\t\t\t\t    &urbcount);\n\t\tif (pipe_num == ATH6KL_USB_PIPE_INVALID)\n\t\t\tcontinue;\n\n\t\tpipe = &ar_usb->pipes[pipe_num];\n\t\tif (pipe->ar_usb != NULL) {\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\tpipe->ar_usb = ar_usb;\n\t\tpipe->logical_pipe_num = pipe_num;\n\t\tpipe->ep_address = endpoint->bEndpointAddress;\n\t\tpipe->max_packet_size = le16_to_cpu(endpoint->wMaxPacketSize);\n\n\t\tif (ATH6KL_USB_IS_BULK_EP(endpoint->bmAttributes)) {\n\t\t\tif (ATH6KL_USB_IS_DIR_IN(pipe->ep_address)) {\n\t\t\t\tpipe->usb_pipe_handle =\n\t\t\t\t    usb_rcvbulkpipe(ar_usb->udev,\n\t\t\t\t\t\t    pipe->ep_address);\n\t\t\t} else {\n\t\t\t\tpipe->usb_pipe_handle =\n\t\t\t\t    usb_sndbulkpipe(ar_usb->udev,\n\t\t\t\t\t\t    pipe->ep_address);\n\t\t\t}\n\t\t} else if (ATH6KL_USB_IS_INT_EP(endpoint->bmAttributes)) {\n\t\t\tif (ATH6KL_USB_IS_DIR_IN(pipe->ep_address)) {\n\t\t\t\tpipe->usb_pipe_handle =\n\t\t\t\t    usb_rcvintpipe(ar_usb->udev,\n\t\t\t\t\t\t   pipe->ep_address);\n\t\t\t} else {\n\t\t\t\tpipe->usb_pipe_handle =\n\t\t\t\t    usb_sndintpipe(ar_usb->udev,\n\t\t\t\t\t\t   pipe->ep_address);\n\t\t\t}\n\t\t} else if (ATH6KL_USB_IS_ISOC_EP(endpoint->bmAttributes)) {\n\t\t\t \n\t\t\tif (ATH6KL_USB_IS_DIR_IN(pipe->ep_address)) {\n\t\t\t\tpipe->usb_pipe_handle =\n\t\t\t\t    usb_rcvisocpipe(ar_usb->udev,\n\t\t\t\t\t\t    pipe->ep_address);\n\t\t\t} else {\n\t\t\t\tpipe->usb_pipe_handle =\n\t\t\t\t    usb_sndisocpipe(ar_usb->udev,\n\t\t\t\t\t\t    pipe->ep_address);\n\t\t\t}\n\t\t}\n\n\t\tpipe->ep_desc = endpoint;\n\n\t\tif (!ATH6KL_USB_IS_DIR_IN(pipe->ep_address))\n\t\t\tpipe->flags |= ATH6KL_USB_PIPE_FLAG_TX;\n\n\t\tstatus = ath6kl_usb_alloc_pipe_resources(pipe, urbcount);\n\t\tif (status != 0)\n\t\t\tbreak;\n\t}\n\n\treturn status;\n}\n\n \nstatic void ath6kl_usb_post_recv_transfers(struct ath6kl_usb_pipe *recv_pipe,\n\t\t\t\t\t   int buffer_length)\n{\n\tstruct ath6kl_urb_context *urb_context;\n\tstruct urb *urb;\n\tint usb_status;\n\n\twhile (true) {\n\t\turb_context = ath6kl_usb_alloc_urb_from_pipe(recv_pipe);\n\t\tif (urb_context == NULL)\n\t\t\tbreak;\n\n\t\turb_context->skb = dev_alloc_skb(buffer_length);\n\t\tif (urb_context->skb == NULL)\n\t\t\tgoto err_cleanup_urb;\n\n\t\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\t\tif (urb == NULL)\n\t\t\tgoto err_cleanup_urb;\n\n\t\tusb_fill_bulk_urb(urb,\n\t\t\t\t  recv_pipe->ar_usb->udev,\n\t\t\t\t  recv_pipe->usb_pipe_handle,\n\t\t\t\t  urb_context->skb->data,\n\t\t\t\t  buffer_length,\n\t\t\t\t  ath6kl_usb_recv_complete, urb_context);\n\n\t\tath6kl_dbg(ATH6KL_DBG_USB_BULK,\n\t\t\t   \"ath6kl usb: bulk recv submit:%d, 0x%X (ep:0x%2.2X), %d bytes buf:0x%p\\n\",\n\t\t\t   recv_pipe->logical_pipe_num,\n\t\t\t   recv_pipe->usb_pipe_handle, recv_pipe->ep_address,\n\t\t\t   buffer_length, urb_context->skb);\n\n\t\tusb_anchor_urb(urb, &recv_pipe->urb_submitted);\n\t\tusb_status = usb_submit_urb(urb, GFP_ATOMIC);\n\n\t\tif (usb_status) {\n\t\t\tath6kl_dbg(ATH6KL_DBG_USB_BULK,\n\t\t\t\t   \"ath6kl usb : usb bulk recv failed %d\\n\",\n\t\t\t\t   usb_status);\n\t\t\tusb_unanchor_urb(urb);\n\t\t\tusb_free_urb(urb);\n\t\t\tgoto err_cleanup_urb;\n\t\t}\n\t\tusb_free_urb(urb);\n\t}\n\treturn;\n\nerr_cleanup_urb:\n\tath6kl_usb_cleanup_recv_urb(urb_context);\n\treturn;\n}\n\nstatic void ath6kl_usb_flush_all(struct ath6kl_usb *ar_usb)\n{\n\tint i;\n\n\tfor (i = 0; i < ATH6KL_USB_PIPE_MAX; i++) {\n\t\tif (ar_usb->pipes[i].ar_usb != NULL)\n\t\t\tusb_kill_anchored_urbs(&ar_usb->pipes[i].urb_submitted);\n\t}\n\n\t \n\tflush_workqueue(ar_usb->wq);\n}\n\nstatic void ath6kl_usb_start_recv_pipes(struct ath6kl_usb *ar_usb)\n{\n\t \n\n\tar_usb->pipes[ATH6KL_USB_PIPE_RX_DATA].urb_cnt_thresh = 1;\n\n\tath6kl_usb_post_recv_transfers(&ar_usb->pipes[ATH6KL_USB_PIPE_RX_DATA],\n\t\t\t\t       ATH6KL_USB_RX_BUFFER_SIZE);\n}\n\n \nstatic void ath6kl_usb_recv_complete(struct urb *urb)\n{\n\tstruct ath6kl_urb_context *urb_context = urb->context;\n\tstruct ath6kl_usb_pipe *pipe = urb_context->pipe;\n\tstruct sk_buff *skb = NULL;\n\tint status = 0;\n\n\tath6kl_dbg(ATH6KL_DBG_USB_BULK,\n\t\t   \"%s: recv pipe: %d, stat:%d, len:%d urb:0x%p\\n\", __func__,\n\t\t   pipe->logical_pipe_num, urb->status, urb->actual_length,\n\t\t   urb);\n\n\tif (urb->status != 0) {\n\t\tstatus = -EIO;\n\t\tswitch (urb->status) {\n\t\tcase -ECONNRESET:\n\t\tcase -ENOENT:\n\t\tcase -ESHUTDOWN:\n\t\t\t \n\t\t\tstatus = -ECANCELED;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tath6kl_dbg(ATH6KL_DBG_USB_BULK,\n\t\t\t\t   \"%s recv pipe: %d (ep:0x%2.2X), failed:%d\\n\",\n\t\t\t\t   __func__, pipe->logical_pipe_num,\n\t\t\t\t   pipe->ep_address, urb->status);\n\t\t\tbreak;\n\t\t}\n\t\tgoto cleanup_recv_urb;\n\t}\n\n\tif (urb->actual_length == 0)\n\t\tgoto cleanup_recv_urb;\n\n\tskb = urb_context->skb;\n\n\t \n\turb_context->skb = NULL;\n\tskb_put(skb, urb->actual_length);\n\n\t \n\tskb_queue_tail(&pipe->io_comp_queue, skb);\n\tqueue_work(pipe->ar_usb->wq, &pipe->io_complete_work);\n\ncleanup_recv_urb:\n\tath6kl_usb_cleanup_recv_urb(urb_context);\n\n\tif (status == 0 &&\n\t    pipe->urb_cnt >= pipe->urb_cnt_thresh) {\n\t\t \n\t\tath6kl_usb_post_recv_transfers(pipe, ATH6KL_USB_RX_BUFFER_SIZE);\n\t}\n}\n\nstatic void ath6kl_usb_usb_transmit_complete(struct urb *urb)\n{\n\tstruct ath6kl_urb_context *urb_context = urb->context;\n\tstruct ath6kl_usb_pipe *pipe = urb_context->pipe;\n\tstruct sk_buff *skb;\n\n\tath6kl_dbg(ATH6KL_DBG_USB_BULK,\n\t\t   \"%s: pipe: %d, stat:%d, len:%d\\n\",\n\t\t   __func__, pipe->logical_pipe_num, urb->status,\n\t\t   urb->actual_length);\n\n\tif (urb->status != 0) {\n\t\tath6kl_dbg(ATH6KL_DBG_USB_BULK,\n\t\t\t   \"%s:  pipe: %d, failed:%d\\n\",\n\t\t\t   __func__, pipe->logical_pipe_num, urb->status);\n\t}\n\n\tskb = urb_context->skb;\n\turb_context->skb = NULL;\n\tath6kl_usb_free_urb_to_pipe(urb_context->pipe, urb_context);\n\n\t \n\tskb_queue_tail(&pipe->io_comp_queue, skb);\n\tqueue_work(pipe->ar_usb->wq, &pipe->io_complete_work);\n}\n\nstatic void ath6kl_usb_io_comp_work(struct work_struct *work)\n{\n\tstruct ath6kl_usb_pipe *pipe = container_of(work,\n\t\t\t\t\t\t    struct ath6kl_usb_pipe,\n\t\t\t\t\t\t    io_complete_work);\n\tstruct ath6kl_usb *ar_usb;\n\tstruct sk_buff *skb;\n\n\tar_usb = pipe->ar_usb;\n\n\twhile ((skb = skb_dequeue(&pipe->io_comp_queue))) {\n\t\tif (pipe->flags & ATH6KL_USB_PIPE_FLAG_TX) {\n\t\t\tath6kl_dbg(ATH6KL_DBG_USB_BULK,\n\t\t\t\t   \"ath6kl usb xmit callback buf:0x%p\\n\", skb);\n\t\t\tath6kl_core_tx_complete(ar_usb->ar, skb);\n\t\t} else {\n\t\t\tath6kl_dbg(ATH6KL_DBG_USB_BULK,\n\t\t\t\t   \"ath6kl usb recv callback buf:0x%p\\n\", skb);\n\t\t\tath6kl_core_rx_complete(ar_usb->ar, skb,\n\t\t\t\t\t\tpipe->logical_pipe_num);\n\t\t}\n\t}\n}\n\n#define ATH6KL_USB_MAX_DIAG_CMD (sizeof(struct ath6kl_usb_ctrl_diag_cmd_write))\n#define ATH6KL_USB_MAX_DIAG_RESP (sizeof(struct ath6kl_usb_ctrl_diag_resp_read))\n\nstatic void ath6kl_usb_destroy(struct ath6kl_usb *ar_usb)\n{\n\tath6kl_usb_flush_all(ar_usb);\n\n\tath6kl_usb_cleanup_pipe_resources(ar_usb);\n\n\tusb_set_intfdata(ar_usb->interface, NULL);\n\n\tkfree(ar_usb->diag_cmd_buffer);\n\tkfree(ar_usb->diag_resp_buffer);\n\tdestroy_workqueue(ar_usb->wq);\n\n\tkfree(ar_usb);\n}\n\nstatic struct ath6kl_usb *ath6kl_usb_create(struct usb_interface *interface)\n{\n\tstruct usb_device *dev = interface_to_usbdev(interface);\n\tstruct ath6kl_usb *ar_usb;\n\tstruct ath6kl_usb_pipe *pipe;\n\tint status = 0;\n\tint i;\n\n\t \n\tar_usb = kzalloc(sizeof(struct ath6kl_usb), GFP_KERNEL);\n\tif (ar_usb == NULL)\n\t\treturn NULL;\n\tar_usb->wq = alloc_workqueue(\"ath6kl_wq\", 0, 0);\n\tif (!ar_usb->wq) {\n\t\tkfree(ar_usb);\n\t\treturn NULL;\n\t}\n\n\tusb_set_intfdata(interface, ar_usb);\n\tspin_lock_init(&(ar_usb->cs_lock));\n\tar_usb->udev = dev;\n\tar_usb->interface = interface;\n\n\tfor (i = 0; i < ATH6KL_USB_PIPE_MAX; i++) {\n\t\tpipe = &ar_usb->pipes[i];\n\t\tINIT_WORK(&pipe->io_complete_work,\n\t\t\t  ath6kl_usb_io_comp_work);\n\t\tskb_queue_head_init(&pipe->io_comp_queue);\n\t}\n\n\tar_usb->diag_cmd_buffer = kzalloc(ATH6KL_USB_MAX_DIAG_CMD, GFP_KERNEL);\n\tif (ar_usb->diag_cmd_buffer == NULL) {\n\t\tstatus = -ENOMEM;\n\t\tgoto fail_ath6kl_usb_create;\n\t}\n\n\tar_usb->diag_resp_buffer = kzalloc(ATH6KL_USB_MAX_DIAG_RESP,\n\t\t\t\t\t   GFP_KERNEL);\n\tif (ar_usb->diag_resp_buffer == NULL) {\n\t\tstatus = -ENOMEM;\n\t\tgoto fail_ath6kl_usb_create;\n\t}\n\n\tstatus = ath6kl_usb_setup_pipe_resources(ar_usb);\n\nfail_ath6kl_usb_create:\n\tif (status != 0) {\n\t\tath6kl_usb_destroy(ar_usb);\n\t\tar_usb = NULL;\n\t}\n\treturn ar_usb;\n}\n\nstatic void ath6kl_usb_device_detached(struct usb_interface *interface)\n{\n\tstruct ath6kl_usb *ar_usb;\n\n\tar_usb = usb_get_intfdata(interface);\n\tif (ar_usb == NULL)\n\t\treturn;\n\n\tath6kl_stop_txrx(ar_usb->ar);\n\n\t \n\tmdelay(20);\n\tath6kl_core_cleanup(ar_usb->ar);\n\tath6kl_usb_destroy(ar_usb);\n}\n\n \nstatic void hif_start(struct ath6kl *ar)\n{\n\tstruct ath6kl_usb *device = ath6kl_usb_priv(ar);\n\tint i;\n\n\tath6kl_usb_start_recv_pipes(device);\n\n\t \n\tfor (i = ATH6KL_USB_PIPE_TX_CTRL;\n\t     i <= ATH6KL_USB_PIPE_TX_DATA_HP; i++) {\n\t\tdevice->pipes[i].urb_cnt_thresh =\n\t\t    device->pipes[i].urb_alloc / 2;\n\t}\n}\n\nstatic int ath6kl_usb_send(struct ath6kl *ar, u8 PipeID,\n\t\t\t   struct sk_buff *hdr_skb, struct sk_buff *skb)\n{\n\tstruct ath6kl_usb *device = ath6kl_usb_priv(ar);\n\tstruct ath6kl_usb_pipe *pipe = &device->pipes[PipeID];\n\tstruct ath6kl_urb_context *urb_context;\n\tint usb_status, status = 0;\n\tstruct urb *urb;\n\tu8 *data;\n\tu32 len;\n\n\tath6kl_dbg(ATH6KL_DBG_USB_BULK, \"+%s pipe : %d, buf:0x%p\\n\",\n\t\t   __func__, PipeID, skb);\n\n\turb_context = ath6kl_usb_alloc_urb_from_pipe(pipe);\n\n\tif (urb_context == NULL) {\n\t\t \n\t\tath6kl_dbg(ATH6KL_DBG_USB_BULK,\n\t\t\t   \"%s pipe:%d no urbs left. URB Cnt : %d\\n\",\n\t\t\t   __func__, PipeID, pipe->urb_cnt);\n\t\tstatus = -ENOMEM;\n\t\tgoto fail_hif_send;\n\t}\n\n\turb_context->skb = skb;\n\n\tdata = skb->data;\n\tlen = skb->len;\n\n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (urb == NULL) {\n\t\tstatus = -ENOMEM;\n\t\tath6kl_usb_free_urb_to_pipe(urb_context->pipe,\n\t\t\t\t\t    urb_context);\n\t\tgoto fail_hif_send;\n\t}\n\n\tusb_fill_bulk_urb(urb,\n\t\t\t  device->udev,\n\t\t\t  pipe->usb_pipe_handle,\n\t\t\t  data,\n\t\t\t  len,\n\t\t\t  ath6kl_usb_usb_transmit_complete, urb_context);\n\n\tif ((len % pipe->max_packet_size) == 0) {\n\t\t \n\t\turb->transfer_flags |= URB_ZERO_PACKET;\n\t}\n\n\tath6kl_dbg(ATH6KL_DBG_USB_BULK,\n\t\t   \"athusb bulk send submit:%d, 0x%X (ep:0x%2.2X), %d bytes\\n\",\n\t\t   pipe->logical_pipe_num, pipe->usb_pipe_handle,\n\t\t   pipe->ep_address, len);\n\n\tusb_anchor_urb(urb, &pipe->urb_submitted);\n\tusb_status = usb_submit_urb(urb, GFP_ATOMIC);\n\n\tif (usb_status) {\n\t\tath6kl_dbg(ATH6KL_DBG_USB_BULK,\n\t\t\t   \"ath6kl usb : usb bulk transmit failed %d\\n\",\n\t\t\t   usb_status);\n\t\tusb_unanchor_urb(urb);\n\t\tath6kl_usb_free_urb_to_pipe(urb_context->pipe,\n\t\t\t\t\t    urb_context);\n\t\tstatus = -EINVAL;\n\t}\n\tusb_free_urb(urb);\n\nfail_hif_send:\n\treturn status;\n}\n\nstatic void hif_stop(struct ath6kl *ar)\n{\n\tstruct ath6kl_usb *device = ath6kl_usb_priv(ar);\n\n\tath6kl_usb_flush_all(device);\n}\n\nstatic void ath6kl_usb_get_default_pipe(struct ath6kl *ar,\n\t\t\t\t\tu8 *ul_pipe, u8 *dl_pipe)\n{\n\t*ul_pipe = ATH6KL_USB_PIPE_TX_CTRL;\n\t*dl_pipe = ATH6KL_USB_PIPE_RX_CTRL;\n}\n\nstatic int ath6kl_usb_map_service_pipe(struct ath6kl *ar, u16 svc_id,\n\t\t\t\t       u8 *ul_pipe, u8 *dl_pipe)\n{\n\tint status = 0;\n\n\tswitch (svc_id) {\n\tcase HTC_CTRL_RSVD_SVC:\n\tcase WMI_CONTROL_SVC:\n\t\t*ul_pipe = ATH6KL_USB_PIPE_TX_CTRL;\n\t\t \n\t\t*dl_pipe = ATH6KL_USB_PIPE_RX_DATA;\n\t\tbreak;\n\tcase WMI_DATA_BE_SVC:\n\tcase WMI_DATA_BK_SVC:\n\t\t*ul_pipe = ATH6KL_USB_PIPE_TX_DATA_LP;\n\t\t \n\t\t*dl_pipe = ATH6KL_USB_PIPE_RX_DATA;\n\t\tbreak;\n\tcase WMI_DATA_VI_SVC:\n\n\t\tif (test_bit(ATH6KL_FW_CAPABILITY_MAP_LP_ENDPOINT,\n\t\t\t     ar->fw_capabilities))\n\t\t\t*ul_pipe = ATH6KL_USB_PIPE_TX_DATA_LP;\n\t\telse\n\t\t\t*ul_pipe = ATH6KL_USB_PIPE_TX_DATA_MP;\n\t\t \n\t\t*dl_pipe = ATH6KL_USB_PIPE_RX_DATA;\n\t\tbreak;\n\tcase WMI_DATA_VO_SVC:\n\n\t\tif (test_bit(ATH6KL_FW_CAPABILITY_MAP_LP_ENDPOINT,\n\t\t\t     ar->fw_capabilities))\n\t\t\t*ul_pipe = ATH6KL_USB_PIPE_TX_DATA_LP;\n\t\telse\n\t\t\t*ul_pipe = ATH6KL_USB_PIPE_TX_DATA_MP;\n\t\t \n\t\t*dl_pipe = ATH6KL_USB_PIPE_RX_DATA;\n\t\tbreak;\n\tdefault:\n\t\tstatus = -EPERM;\n\t\tbreak;\n\t}\n\n\treturn status;\n}\n\nstatic u16 ath6kl_usb_get_free_queue_number(struct ath6kl *ar, u8 pipe_id)\n{\n\tstruct ath6kl_usb *device = ath6kl_usb_priv(ar);\n\n\treturn device->pipes[pipe_id].urb_cnt;\n}\n\nstatic void hif_detach_htc(struct ath6kl *ar)\n{\n\tstruct ath6kl_usb *device = ath6kl_usb_priv(ar);\n\n\tath6kl_usb_flush_all(device);\n}\n\nstatic int ath6kl_usb_submit_ctrl_out(struct ath6kl_usb *ar_usb,\n\t\t\t\t   u8 req, u16 value, u16 index, void *data,\n\t\t\t\t   u32 size)\n{\n\tu8 *buf = NULL;\n\tint ret;\n\n\tif (size > 0) {\n\t\tbuf = kmemdup(data, size, GFP_KERNEL);\n\t\tif (buf == NULL)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t \n\tret = usb_control_msg(ar_usb->udev,\n\t\t\t      usb_sndctrlpipe(ar_usb->udev, 0),\n\t\t\t      req,\n\t\t\t      USB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, value, index, buf,\n\t\t\t      size, 1000);\n\n\tif (ret < 0) {\n\t\tath6kl_warn(\"Failed to submit usb control message: %d\\n\", ret);\n\t\tkfree(buf);\n\t\treturn ret;\n\t}\n\n\tkfree(buf);\n\n\treturn 0;\n}\n\nstatic int ath6kl_usb_submit_ctrl_in(struct ath6kl_usb *ar_usb,\n\t\t\t\t  u8 req, u16 value, u16 index, void *data,\n\t\t\t\t  u32 size)\n{\n\tu8 *buf = NULL;\n\tint ret;\n\n\tif (size > 0) {\n\t\tbuf = kmalloc(size, GFP_KERNEL);\n\t\tif (buf == NULL)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t \n\tret = usb_control_msg(ar_usb->udev,\n\t\t\t\t usb_rcvctrlpipe(ar_usb->udev, 0),\n\t\t\t\t req,\n\t\t\t\t USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t\t USB_RECIP_DEVICE, value, index, buf,\n\t\t\t\t size, 2000);\n\n\tif (ret < 0) {\n\t\tath6kl_warn(\"Failed to read usb control message: %d\\n\", ret);\n\t\tkfree(buf);\n\t\treturn ret;\n\t}\n\n\tmemcpy((u8 *) data, buf, size);\n\n\tkfree(buf);\n\n\treturn 0;\n}\n\nstatic int ath6kl_usb_ctrl_msg_exchange(struct ath6kl_usb *ar_usb,\n\t\t\t\t     u8 req_val, u8 *req_buf, u32 req_len,\n\t\t\t\t     u8 resp_val, u8 *resp_buf, u32 *resp_len)\n{\n\tint ret;\n\n\t \n\tret = ath6kl_usb_submit_ctrl_out(ar_usb, req_val, 0, 0,\n\t\t\t\t\t req_buf, req_len);\n\n\tif (ret != 0)\n\t\treturn ret;\n\n\tif (resp_buf == NULL) {\n\t\t \n\t\treturn ret;\n\t}\n\n\t \n\tret = ath6kl_usb_submit_ctrl_in(ar_usb, resp_val, 0, 0,\n\t\t\t\t\tresp_buf, *resp_len);\n\n\treturn ret;\n}\n\nstatic int ath6kl_usb_diag_read32(struct ath6kl *ar, u32 address, u32 *data)\n{\n\tstruct ath6kl_usb *ar_usb = ar->hif_priv;\n\tstruct ath6kl_usb_ctrl_diag_resp_read *resp;\n\tstruct ath6kl_usb_ctrl_diag_cmd_read *cmd;\n\tu32 resp_len;\n\tint ret;\n\n\tcmd = (struct ath6kl_usb_ctrl_diag_cmd_read *) ar_usb->diag_cmd_buffer;\n\n\tmemset(cmd, 0, sizeof(*cmd));\n\tcmd->cmd = ATH6KL_USB_CTRL_DIAG_CC_READ;\n\tcmd->address = cpu_to_le32(address);\n\tresp_len = sizeof(*resp);\n\n\tret = ath6kl_usb_ctrl_msg_exchange(ar_usb,\n\t\t\t\tATH6KL_USB_CONTROL_REQ_DIAG_CMD,\n\t\t\t\t(u8 *) cmd,\n\t\t\t\tsizeof(struct ath6kl_usb_ctrl_diag_cmd_write),\n\t\t\t\tATH6KL_USB_CONTROL_REQ_DIAG_RESP,\n\t\t\t\tar_usb->diag_resp_buffer, &resp_len);\n\n\tif (ret) {\n\t\tath6kl_warn(\"diag read32 failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tresp = (struct ath6kl_usb_ctrl_diag_resp_read *)\n\t\tar_usb->diag_resp_buffer;\n\n\t*data = le32_to_cpu(resp->value);\n\n\treturn ret;\n}\n\nstatic int ath6kl_usb_diag_write32(struct ath6kl *ar, u32 address, __le32 data)\n{\n\tstruct ath6kl_usb *ar_usb = ar->hif_priv;\n\tstruct ath6kl_usb_ctrl_diag_cmd_write *cmd;\n\tint ret;\n\n\tcmd = (struct ath6kl_usb_ctrl_diag_cmd_write *) ar_usb->diag_cmd_buffer;\n\n\tmemset(cmd, 0, sizeof(struct ath6kl_usb_ctrl_diag_cmd_write));\n\tcmd->cmd = cpu_to_le32(ATH6KL_USB_CTRL_DIAG_CC_WRITE);\n\tcmd->address = cpu_to_le32(address);\n\tcmd->value = data;\n\n\tret = ath6kl_usb_ctrl_msg_exchange(ar_usb,\n\t\t\t\t\t   ATH6KL_USB_CONTROL_REQ_DIAG_CMD,\n\t\t\t\t\t   (u8 *) cmd,\n\t\t\t\t\t   sizeof(*cmd),\n\t\t\t\t\t   0, NULL, NULL);\n\tif (ret) {\n\t\tath6kl_warn(\"diag_write32 failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath6kl_usb_bmi_read(struct ath6kl *ar, u8 *buf, u32 len)\n{\n\tstruct ath6kl_usb *ar_usb = ar->hif_priv;\n\tint ret;\n\n\t \n\tret = ath6kl_usb_submit_ctrl_in(ar_usb,\n\t\t\t\t\tATH6KL_USB_CONTROL_REQ_RECV_BMI_RESP,\n\t\t\t\t\t0, 0, buf, len);\n\tif (ret) {\n\t\tath6kl_err(\"Unable to read the bmi data from the device: %d\\n\",\n\t\t\t   ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath6kl_usb_bmi_write(struct ath6kl *ar, u8 *buf, u32 len)\n{\n\tstruct ath6kl_usb *ar_usb = ar->hif_priv;\n\tint ret;\n\n\t \n\tret = ath6kl_usb_submit_ctrl_out(ar_usb,\n\t\t\t\t\t ATH6KL_USB_CONTROL_REQ_SEND_BMI_CMD,\n\t\t\t\t\t 0, 0, buf, len);\n\tif (ret) {\n\t\tath6kl_err(\"unable to send the bmi data to the device: %d\\n\",\n\t\t\t   ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath6kl_usb_power_on(struct ath6kl *ar)\n{\n\thif_start(ar);\n\treturn 0;\n}\n\nstatic int ath6kl_usb_power_off(struct ath6kl *ar)\n{\n\thif_detach_htc(ar);\n\treturn 0;\n}\n\nstatic void ath6kl_usb_stop(struct ath6kl *ar)\n{\n\thif_stop(ar);\n}\n\nstatic void ath6kl_usb_cleanup_scatter(struct ath6kl *ar)\n{\n\t \n\treturn;\n}\n\nstatic int ath6kl_usb_suspend(struct ath6kl *ar, struct cfg80211_wowlan *wow)\n{\n\t \n\treturn 0;\n}\n\nstatic int ath6kl_usb_resume(struct ath6kl *ar)\n{\n\t \n\treturn 0;\n}\n\nstatic const struct ath6kl_hif_ops ath6kl_usb_ops = {\n\t.diag_read32 = ath6kl_usb_diag_read32,\n\t.diag_write32 = ath6kl_usb_diag_write32,\n\t.bmi_read = ath6kl_usb_bmi_read,\n\t.bmi_write = ath6kl_usb_bmi_write,\n\t.power_on = ath6kl_usb_power_on,\n\t.power_off = ath6kl_usb_power_off,\n\t.stop = ath6kl_usb_stop,\n\t.pipe_send = ath6kl_usb_send,\n\t.pipe_get_default = ath6kl_usb_get_default_pipe,\n\t.pipe_map_service = ath6kl_usb_map_service_pipe,\n\t.pipe_get_free_queue_number = ath6kl_usb_get_free_queue_number,\n\t.cleanup_scatter = ath6kl_usb_cleanup_scatter,\n\t.suspend = ath6kl_usb_suspend,\n\t.resume = ath6kl_usb_resume,\n};\n\n \nstatic int ath6kl_usb_probe(struct usb_interface *interface,\n\t\t\t    const struct usb_device_id *id)\n{\n\tstruct usb_device *dev = interface_to_usbdev(interface);\n\tstruct ath6kl *ar;\n\tstruct ath6kl_usb *ar_usb = NULL;\n\tint vendor_id, product_id;\n\tint ret = 0;\n\n\tusb_get_dev(dev);\n\n\tvendor_id = le16_to_cpu(dev->descriptor.idVendor);\n\tproduct_id = le16_to_cpu(dev->descriptor.idProduct);\n\n\tath6kl_dbg(ATH6KL_DBG_USB, \"vendor_id = %04x\\n\", vendor_id);\n\tath6kl_dbg(ATH6KL_DBG_USB, \"product_id = %04x\\n\", product_id);\n\n\tif (interface->cur_altsetting)\n\t\tath6kl_dbg(ATH6KL_DBG_USB, \"USB Interface %d\\n\",\n\t\t\t   interface->cur_altsetting->desc.bInterfaceNumber);\n\n\n\tif (dev->speed == USB_SPEED_HIGH)\n\t\tath6kl_dbg(ATH6KL_DBG_USB, \"USB 2.0 Host\\n\");\n\telse\n\t\tath6kl_dbg(ATH6KL_DBG_USB, \"USB 1.1 Host\\n\");\n\n\tar_usb = ath6kl_usb_create(interface);\n\n\tif (ar_usb == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err_usb_put;\n\t}\n\n\tar = ath6kl_core_create(&ar_usb->udev->dev);\n\tif (ar == NULL) {\n\t\tath6kl_err(\"Failed to alloc ath6kl core\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_usb_destroy;\n\t}\n\n\tar->hif_priv = ar_usb;\n\tar->hif_type = ATH6KL_HIF_TYPE_USB;\n\tar->hif_ops = &ath6kl_usb_ops;\n\tar->mbox_info.block_size = 16;\n\tar->bmi.max_data_size = 252;\n\n\tar_usb->ar = ar;\n\n\tret = ath6kl_core_init(ar, ATH6KL_HTC_TYPE_PIPE);\n\tif (ret) {\n\t\tath6kl_err(\"Failed to init ath6kl core: %d\\n\", ret);\n\t\tgoto err_core_free;\n\t}\n\n\treturn ret;\n\nerr_core_free:\n\tath6kl_core_destroy(ar);\nerr_usb_destroy:\n\tath6kl_usb_destroy(ar_usb);\nerr_usb_put:\n\tusb_put_dev(dev);\n\n\treturn ret;\n}\n\nstatic void ath6kl_usb_remove(struct usb_interface *interface)\n{\n\tusb_put_dev(interface_to_usbdev(interface));\n\tath6kl_usb_device_detached(interface);\n}\n\n#ifdef CONFIG_PM\n\nstatic int ath6kl_usb_pm_suspend(struct usb_interface *interface,\n\t\t\t      pm_message_t message)\n{\n\tstruct ath6kl_usb *device;\n\tdevice = usb_get_intfdata(interface);\n\n\tath6kl_usb_flush_all(device);\n\treturn 0;\n}\n\nstatic int ath6kl_usb_pm_resume(struct usb_interface *interface)\n{\n\tstruct ath6kl_usb *device;\n\tdevice = usb_get_intfdata(interface);\n\n\tath6kl_usb_post_recv_transfers(&device->pipes[ATH6KL_USB_PIPE_RX_DATA],\n\t\t\t\t       ATH6KL_USB_RX_BUFFER_SIZE);\n\tath6kl_usb_post_recv_transfers(&device->pipes[ATH6KL_USB_PIPE_RX_DATA2],\n\t\t\t\t       ATH6KL_USB_RX_BUFFER_SIZE);\n\n\treturn 0;\n}\n\n#else\n\n#define ath6kl_usb_pm_suspend NULL\n#define ath6kl_usb_pm_resume NULL\n\n#endif\n\n \nstatic const struct usb_device_id ath6kl_usb_ids[] = {\n\t{USB_DEVICE(0x0cf3, 0x9375)},\n\t{USB_DEVICE(0x0cf3, 0x9374)},\n\t{USB_DEVICE(0x04da, 0x390d)},\n\t{   },\n};\n\nMODULE_DEVICE_TABLE(usb, ath6kl_usb_ids);\n\nstatic struct usb_driver ath6kl_usb_driver = {\n\t.name = \"ath6kl_usb\",\n\t.probe = ath6kl_usb_probe,\n\t.suspend = ath6kl_usb_pm_suspend,\n\t.resume = ath6kl_usb_pm_resume,\n\t.disconnect = ath6kl_usb_remove,\n\t.id_table = ath6kl_usb_ids,\n\t.supports_autosuspend = true,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(ath6kl_usb_driver);\n\nMODULE_AUTHOR(\"Atheros Communications, Inc.\");\nMODULE_DESCRIPTION(\"Driver support for Atheros AR600x USB devices\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_FIRMWARE(AR6004_HW_1_0_FIRMWARE_FILE);\nMODULE_FIRMWARE(AR6004_HW_1_0_BOARD_DATA_FILE);\nMODULE_FIRMWARE(AR6004_HW_1_0_DEFAULT_BOARD_DATA_FILE);\nMODULE_FIRMWARE(AR6004_HW_1_1_FIRMWARE_FILE);\nMODULE_FIRMWARE(AR6004_HW_1_1_BOARD_DATA_FILE);\nMODULE_FIRMWARE(AR6004_HW_1_1_DEFAULT_BOARD_DATA_FILE);\nMODULE_FIRMWARE(AR6004_HW_1_2_FIRMWARE_FILE);\nMODULE_FIRMWARE(AR6004_HW_1_2_BOARD_DATA_FILE);\nMODULE_FIRMWARE(AR6004_HW_1_2_DEFAULT_BOARD_DATA_FILE);\nMODULE_FIRMWARE(AR6004_HW_1_3_FW_DIR \"/\" AR6004_HW_1_3_FIRMWARE_FILE);\nMODULE_FIRMWARE(AR6004_HW_1_3_BOARD_DATA_FILE);\nMODULE_FIRMWARE(AR6004_HW_1_3_DEFAULT_BOARD_DATA_FILE);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}