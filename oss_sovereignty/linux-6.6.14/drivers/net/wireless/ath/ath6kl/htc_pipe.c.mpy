{
  "module_name": "htc_pipe.c",
  "hash_id": "21584036b777090f61a920e66d60926762043c9242b08e09275f13e88f8066f7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath6kl/htc_pipe.c",
  "human_readable_source": " \n\n#include \"core.h\"\n#include \"debug.h\"\n#include \"hif-ops.h\"\n\n#define HTC_PACKET_CONTAINER_ALLOCATION 32\n#define HTC_CONTROL_BUFFER_SIZE (HTC_MAX_CTRL_MSG_LEN + HTC_HDR_LENGTH)\n\nstatic int ath6kl_htc_pipe_tx(struct htc_target *handle,\n\t\t\t      struct htc_packet *packet);\nstatic void ath6kl_htc_pipe_cleanup(struct htc_target *handle);\n\n \nstatic inline void restore_tx_packet(struct htc_packet *packet)\n{\n\tif (packet->info.tx.flags & HTC_FLAGS_TX_FIXUP_NETBUF) {\n\t\tskb_pull(packet->skb, sizeof(struct htc_frame_hdr));\n\t\tpacket->info.tx.flags &= ~HTC_FLAGS_TX_FIXUP_NETBUF;\n\t}\n}\n\nstatic void do_send_completion(struct htc_endpoint *ep,\n\t\t\t       struct list_head *queue_to_indicate)\n{\n\tstruct htc_packet *packet;\n\n\tif (list_empty(queue_to_indicate)) {\n\t\t \n\t\treturn;\n\t}\n\n\tif (ep->ep_cb.tx_comp_multi != NULL) {\n\t\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t\t   \"%s: calling ep %d, send complete multiple callback (%d pkts)\\n\",\n\t\t\t   __func__, ep->eid,\n\t\t\t   get_queue_depth(queue_to_indicate));\n\t\t \n\t\tep->ep_cb.tx_comp_multi(ep->target, queue_to_indicate);\n\t\t \n\t\tINIT_LIST_HEAD(queue_to_indicate);\n\t} else {\n\t\t \n\t\tdo {\n\t\t\tpacket = list_first_entry(queue_to_indicate,\n\t\t\t\t\t\t  struct htc_packet, list);\n\n\t\t\tlist_del(&packet->list);\n\t\t\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t\t\t   \"%s: calling ep %d send complete callback on packet 0x%p\\n\",\n\t\t\t\t   __func__, ep->eid, packet);\n\t\t\tep->ep_cb.tx_complete(ep->target, packet);\n\t\t} while (!list_empty(queue_to_indicate));\n\t}\n}\n\nstatic void send_packet_completion(struct htc_target *target,\n\t\t\t\t   struct htc_packet *packet)\n{\n\tstruct htc_endpoint *ep = &target->endpoint[packet->endpoint];\n\tstruct list_head container;\n\n\trestore_tx_packet(packet);\n\tINIT_LIST_HEAD(&container);\n\tlist_add_tail(&packet->list, &container);\n\n\t \n\tdo_send_completion(ep, &container);\n}\n\nstatic void get_htc_packet_credit_based(struct htc_target *target,\n\t\t\t\t\tstruct htc_endpoint *ep,\n\t\t\t\t\tstruct list_head *queue)\n{\n\tint credits_required;\n\tint remainder;\n\tu8 send_flags;\n\tstruct htc_packet *packet;\n\tunsigned int transfer_len;\n\n\t \n\n\t \n\twhile (true) {\n\t\tsend_flags = 0;\n\t\tif (list_empty(&ep->txq))\n\t\t\tbreak;\n\n\t\t \n\t\tpacket = list_first_entry(&ep->txq, struct htc_packet, list);\n\n\t\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t\t   \"%s: got head packet:0x%p , queue depth: %d\\n\",\n\t\t\t   __func__, packet, get_queue_depth(&ep->txq));\n\n\t\ttransfer_len = packet->act_len + HTC_HDR_LENGTH;\n\n\t\tif (transfer_len <= target->tgt_cred_sz) {\n\t\t\tcredits_required = 1;\n\t\t} else {\n\t\t\t \n\t\t\tcredits_required = transfer_len / target->tgt_cred_sz;\n\t\t\tremainder = transfer_len % target->tgt_cred_sz;\n\n\t\t\tif (remainder)\n\t\t\t\tcredits_required++;\n\t\t}\n\n\t\tath6kl_dbg(ATH6KL_DBG_HTC, \"%s: creds required:%d got:%d\\n\",\n\t\t\t   __func__, credits_required, ep->cred_dist.credits);\n\n\t\tif (ep->eid == ENDPOINT_0) {\n\t\t\t \n\t\t\tcredits_required = 0;\n\n\t\t} else {\n\t\t\tif (ep->cred_dist.credits < credits_required)\n\t\t\t\tbreak;\n\n\t\t\tep->cred_dist.credits -= credits_required;\n\t\t\tep->ep_st.cred_cosumd += credits_required;\n\n\t\t\t \n\t\t\tif (ep->cred_dist.credits <\n\t\t\t\t\tep->cred_dist.cred_per_msg) {\n\t\t\t\t \n\t\t\t\tsend_flags |= HTC_FLAGS_NEED_CREDIT_UPDATE;\n\t\t\t\tep->ep_st.cred_low_indicate += 1;\n\t\t\t\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t\t\t\t   \"%s: host needs credits\\n\",\n\t\t\t\t\t   __func__);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tpacket = list_first_entry(&ep->txq, struct htc_packet, list);\n\n\t\tlist_del(&packet->list);\n\t\t \n\t\tpacket->info.tx.cred_used = credits_required;\n\t\t \n\t\tpacket->info.tx.flags = send_flags;\n\t\tpacket->info.tx.seqno = ep->seqno;\n\t\tep->seqno++;\n\t\t \n\t\tlist_add_tail(&packet->list, queue);\n\t}\n}\n\nstatic void get_htc_packet(struct htc_target *target,\n\t\t\t   struct htc_endpoint *ep,\n\t\t\t   struct list_head *queue, int resources)\n{\n\tstruct htc_packet *packet;\n\n\t \n\n\t \n\twhile (resources) {\n\t\tif (list_empty(&ep->txq))\n\t\t\tbreak;\n\n\t\tpacket = list_first_entry(&ep->txq, struct htc_packet, list);\n\t\tlist_del(&packet->list);\n\n\t\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t\t   \"%s: got packet:0x%p , new queue depth: %d\\n\",\n\t\t\t   __func__, packet, get_queue_depth(&ep->txq));\n\t\tpacket->info.tx.seqno = ep->seqno;\n\t\tpacket->info.tx.flags = 0;\n\t\tpacket->info.tx.cred_used = 0;\n\t\tep->seqno++;\n\n\t\t \n\t\tlist_add_tail(&packet->list, queue);\n\t\tresources--;\n\t}\n}\n\nstatic int htc_issue_packets(struct htc_target *target,\n\t\t\t     struct htc_endpoint *ep,\n\t\t\t     struct list_head *pkt_queue)\n{\n\tint status = 0;\n\tu16 payload_len;\n\tstruct sk_buff *skb;\n\tstruct htc_frame_hdr *htc_hdr;\n\tstruct htc_packet *packet;\n\n\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t   \"%s: queue: 0x%p, pkts %d\\n\", __func__,\n\t\t   pkt_queue, get_queue_depth(pkt_queue));\n\n\twhile (!list_empty(pkt_queue)) {\n\t\tpacket = list_first_entry(pkt_queue, struct htc_packet, list);\n\t\tlist_del(&packet->list);\n\n\t\tskb = packet->skb;\n\t\tif (!skb) {\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tstatus = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tpayload_len = packet->act_len;\n\n\t\t \n\t\thtc_hdr = skb_push(skb, sizeof(*htc_hdr));\n\t\tif (!htc_hdr) {\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tstatus = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tpacket->info.tx.flags |= HTC_FLAGS_TX_FIXUP_NETBUF;\n\n\t\t \n\t\tput_unaligned((u16) payload_len, &htc_hdr->payld_len);\n\t\thtc_hdr->flags = packet->info.tx.flags;\n\t\thtc_hdr->eid = (u8) packet->endpoint;\n\t\thtc_hdr->ctrl[0] = 0;\n\t\thtc_hdr->ctrl[1] = (u8) packet->info.tx.seqno;\n\n\t\tspin_lock_bh(&target->tx_lock);\n\n\t\t \n\t\tlist_add_tail(&packet->list, &ep->pipe.tx_lookup_queue);\n\t\tep->ep_st.tx_issued += 1;\n\t\tspin_unlock_bh(&target->tx_lock);\n\n\t\tstatus = ath6kl_hif_pipe_send(target->dev->ar,\n\t\t\t\t\t      ep->pipe.pipeid_ul, NULL, skb);\n\n\t\tif (status != 0) {\n\t\t\tif (status != -ENOMEM) {\n\t\t\t\t \n\t\t\t\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t\t\t\t   \"%s: failed status:%d\\n\",\n\t\t\t\t\t   __func__, status);\n\t\t\t}\n\t\t\tspin_lock_bh(&target->tx_lock);\n\t\t\tlist_del(&packet->list);\n\n\t\t\t \n\t\t\tep->cred_dist.credits += packet->info.tx.cred_used;\n\t\t\tspin_unlock_bh(&target->tx_lock);\n\n\t\t\t \n\t\t\tlist_add(&packet->list, pkt_queue);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (status != 0) {\n\t\twhile (!list_empty(pkt_queue)) {\n\t\t\tif (status != -ENOMEM) {\n\t\t\t\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t\t\t\t   \"%s: failed pkt:0x%p status:%d\\n\",\n\t\t\t\t\t   __func__, packet, status);\n\t\t\t}\n\n\t\t\tpacket = list_first_entry(pkt_queue,\n\t\t\t\t\t\t  struct htc_packet, list);\n\t\t\tlist_del(&packet->list);\n\t\t\tpacket->status = status;\n\t\t\tsend_packet_completion(target, packet);\n\t\t}\n\t}\n\n\treturn status;\n}\n\nstatic enum htc_send_queue_result htc_try_send(struct htc_target *target,\n\t\t\t\t\t       struct htc_endpoint *ep,\n\t\t\t\t\t       struct list_head *txq)\n{\n\tstruct list_head send_queue;\t \n\tstruct htc_packet *packet, *tmp_pkt;\n\tstruct ath6kl *ar = target->dev->ar;\n\tenum htc_send_full_action action;\n\tint tx_resources, overflow, txqueue_depth, i, good_pkts;\n\tu8 pipeid;\n\n\tath6kl_dbg(ATH6KL_DBG_HTC, \"%s: (queue:0x%p depth:%d)\\n\",\n\t\t   __func__, txq,\n\t\t   (txq == NULL) ? 0 : get_queue_depth(txq));\n\n\t \n\tINIT_LIST_HEAD(&send_queue);\n\n\t \n\tif (txq != NULL) {\n\t\tif (list_empty(txq)) {\n\t\t\t \n\t\t\treturn HTC_SEND_QUEUE_DROP;\n\t\t}\n\n\t\tspin_lock_bh(&target->tx_lock);\n\t\ttxqueue_depth = get_queue_depth(&ep->txq);\n\t\tspin_unlock_bh(&target->tx_lock);\n\n\t\tif (txqueue_depth >= ep->max_txq_depth) {\n\t\t\t \n\t\t\toverflow = get_queue_depth(txq);\n\t\t} else {\n\t\t\t \n\t\t\toverflow = txqueue_depth;\n\t\t\toverflow += get_queue_depth(txq);\n\t\t\t \n\t\t\toverflow -= ep->max_txq_depth;\n\t\t}\n\n\t\t \n\t\tif (overflow > 0) {\n\t\t\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t\t\t   \"%s: Endpoint %d, TX queue will overflow :%d, Tx Depth:%d, Max:%d\\n\",\n\t\t\t\t   __func__, ep->eid, overflow, txqueue_depth,\n\t\t\t\t   ep->max_txq_depth);\n\t\t}\n\t\tif ((overflow <= 0) ||\n\t\t    (ep->ep_cb.tx_full == NULL)) {\n\t\t\t \n\t\t\tlist_splice_tail_init(txq, &send_queue);\n\t\t} else {\n\t\t\tgood_pkts = get_queue_depth(txq) - overflow;\n\t\t\tif (good_pkts < 0) {\n\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\treturn HTC_SEND_QUEUE_DROP;\n\t\t\t}\n\n\t\t\t \n\t\t\t \n\t\t\tfor (i = 0; i < good_pkts; i++) {\n\t\t\t\t \n\t\t\t\tpacket = list_first_entry(txq,\n\t\t\t\t\t\t\t  struct htc_packet,\n\t\t\t\t\t\t\t  list);\n\t\t\t\t \n\t\t\t\tlist_move_tail(&packet->list, &send_queue);\n\t\t\t}\n\n\t\t\t \n\t\t\tlist_for_each_entry_safe(packet, tmp_pkt,\n\t\t\t\t\t\t txq, list) {\n\t\t\t\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t\t\t\t   \"%s: Indicate overflowed TX pkts: %p\\n\",\n\t\t\t\t\t   __func__, packet);\n\t\t\t\taction = ep->ep_cb.tx_full(ep->target, packet);\n\t\t\t\tif (action == HTC_SEND_FULL_DROP) {\n\t\t\t\t\t \n\t\t\t\t\tep->ep_st.tx_dropped += 1;\n\n\t\t\t\t\t \n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tlist_move_tail(&packet->list,\n\t\t\t\t\t\t       &send_queue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (list_empty(&send_queue)) {\n\t\t\t\t \n\t\t\t\treturn HTC_SEND_QUEUE_DROP;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!ep->pipe.tx_credit_flow_enabled) {\n\t\ttx_resources =\n\t\t    ath6kl_hif_pipe_get_free_queue_number(ar,\n\t\t\t\t\t\t\t  ep->pipe.pipeid_ul);\n\t} else {\n\t\ttx_resources = 0;\n\t}\n\n\tspin_lock_bh(&target->tx_lock);\n\tif (!list_empty(&send_queue)) {\n\t\t \n\t\tlist_splice_tail_init(&send_queue, &ep->txq);\n\t\tif (!list_empty(&send_queue)) {\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tspin_unlock_bh(&target->tx_lock);\n\t\t\treturn HTC_SEND_QUEUE_DROP;\n\t\t}\n\t\tINIT_LIST_HEAD(&send_queue);\n\t}\n\n\t \n\tep->tx_proc_cnt++;\n\n\tif (ep->tx_proc_cnt > 1) {\n\t\t \n\t\tep->tx_proc_cnt--;\n\t\tspin_unlock_bh(&target->tx_lock);\n\t\treturn HTC_SEND_QUEUE_OK;\n\t}\n\n\t \n\n\t \n\twhile (true) {\n\t\tif (get_queue_depth(&ep->txq) == 0)\n\t\t\tbreak;\n\n\t\tif (ep->pipe.tx_credit_flow_enabled) {\n\t\t\t \n\t\t\tget_htc_packet_credit_based(target, ep, &send_queue);\n\t\t} else {\n\t\t\t \n\t\t\tget_htc_packet(target, ep, &send_queue, tx_resources);\n\t\t}\n\n\t\tif (get_queue_depth(&send_queue) == 0) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\tspin_unlock_bh(&target->tx_lock);\n\n\t\t \n\t\thtc_issue_packets(target, ep, &send_queue);\n\n\t\tif (!ep->pipe.tx_credit_flow_enabled) {\n\t\t\tpipeid = ep->pipe.pipeid_ul;\n\t\t\ttx_resources =\n\t\t\t    ath6kl_hif_pipe_get_free_queue_number(ar, pipeid);\n\t\t}\n\n\t\tspin_lock_bh(&target->tx_lock);\n\t}\n\n\t \n\tep->tx_proc_cnt = 0;\n\tspin_unlock_bh(&target->tx_lock);\n\n\treturn HTC_SEND_QUEUE_OK;\n}\n\n \nstatic void destroy_htc_txctrl_packet(struct htc_packet *packet)\n{\n\tstruct sk_buff *skb;\n\tskb = packet->skb;\n\tdev_kfree_skb(skb);\n\tkfree(packet);\n}\n\nstatic struct htc_packet *build_htc_txctrl_packet(void)\n{\n\tstruct htc_packet *packet = NULL;\n\tstruct sk_buff *skb;\n\n\tpacket = kzalloc(sizeof(struct htc_packet), GFP_KERNEL);\n\tif (packet == NULL)\n\t\treturn NULL;\n\n\tskb = __dev_alloc_skb(HTC_CONTROL_BUFFER_SIZE, GFP_KERNEL);\n\n\tif (skb == NULL) {\n\t\tkfree(packet);\n\t\treturn NULL;\n\t}\n\tpacket->skb = skb;\n\n\treturn packet;\n}\n\nstatic void htc_free_txctrl_packet(struct htc_target *target,\n\t\t\t\t   struct htc_packet *packet)\n{\n\tdestroy_htc_txctrl_packet(packet);\n}\n\nstatic struct htc_packet *htc_alloc_txctrl_packet(struct htc_target *target)\n{\n\treturn build_htc_txctrl_packet();\n}\n\nstatic void htc_txctrl_complete(struct htc_target *target,\n\t\t\t\tstruct htc_packet *packet)\n{\n\thtc_free_txctrl_packet(target, packet);\n}\n\n#define MAX_MESSAGE_SIZE 1536\n\nstatic int htc_setup_target_buffer_assignments(struct htc_target *target)\n{\n\tint status, credits, credit_per_maxmsg, i;\n\tstruct htc_pipe_txcredit_alloc *entry;\n\tunsigned int hif_usbaudioclass = 0;\n\n\tcredit_per_maxmsg = MAX_MESSAGE_SIZE / target->tgt_cred_sz;\n\tif (MAX_MESSAGE_SIZE % target->tgt_cred_sz)\n\t\tcredit_per_maxmsg++;\n\n\t \n\n\tcredits = target->tgt_creds;\n\tentry = &target->pipe.txcredit_alloc[0];\n\n\tstatus = -ENOMEM;\n\n\t \n\tif (hif_usbaudioclass) {\n\t\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t\t   \"%s: For USB Audio Class- Total:%d\\n\",\n\t\t\t   __func__, credits);\n\t\tentry++;\n\t\tentry++;\n\t\t \n\t\tentry->service_id = WMI_DATA_VO_SVC;\n\t\tentry->credit_alloc = (credits - 6);\n\t\tif (entry->credit_alloc == 0)\n\t\t\tentry->credit_alloc++;\n\n\t\tcredits -= (int) entry->credit_alloc;\n\t\tif (credits <= 0)\n\t\t\treturn status;\n\n\t\tentry++;\n\t\tentry->service_id = WMI_CONTROL_SVC;\n\t\tentry->credit_alloc = credit_per_maxmsg;\n\t\tcredits -= (int) entry->credit_alloc;\n\t\tif (credits <= 0)\n\t\t\treturn status;\n\n\t\t \n\t\tentry++;\n\t\tentry++;\n\t\tentry->service_id = WMI_DATA_BE_SVC;\n\t\tentry->credit_alloc = (u8) credits;\n\t\tstatus = 0;\n\t} else {\n\t\tentry++;\n\t\tentry->service_id = WMI_DATA_VI_SVC;\n\t\tentry->credit_alloc = credits / 4;\n\t\tif (entry->credit_alloc == 0)\n\t\t\tentry->credit_alloc++;\n\n\t\tcredits -= (int) entry->credit_alloc;\n\t\tif (credits <= 0)\n\t\t\treturn status;\n\n\t\tentry++;\n\t\tentry->service_id = WMI_DATA_VO_SVC;\n\t\tentry->credit_alloc = credits / 4;\n\t\tif (entry->credit_alloc == 0)\n\t\t\tentry->credit_alloc++;\n\n\t\tcredits -= (int) entry->credit_alloc;\n\t\tif (credits <= 0)\n\t\t\treturn status;\n\n\t\tentry++;\n\t\tentry->service_id = WMI_CONTROL_SVC;\n\t\tentry->credit_alloc = credit_per_maxmsg;\n\t\tcredits -= (int) entry->credit_alloc;\n\t\tif (credits <= 0)\n\t\t\treturn status;\n\n\t\tentry++;\n\t\tentry->service_id = WMI_DATA_BK_SVC;\n\t\tentry->credit_alloc = credit_per_maxmsg;\n\t\tcredits -= (int) entry->credit_alloc;\n\t\tif (credits <= 0)\n\t\t\treturn status;\n\n\t\t \n\t\tentry++;\n\t\tentry->service_id = WMI_DATA_BE_SVC;\n\t\tentry->credit_alloc = (u8) credits;\n\t\tstatus = 0;\n\t}\n\n\tif (status == 0) {\n\t\tfor (i = 0; i < ENDPOINT_MAX; i++) {\n\t\t\tif (target->pipe.txcredit_alloc[i].service_id != 0) {\n\t\t\t\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t\t\t\t   \"HTC Service Index : %d TX : 0x%2.2X : alloc:%d\\n\",\n\t\t\t\t\t   i,\n\t\t\t\t\t   target->pipe.txcredit_alloc[i].\n\t\t\t\t\t   service_id,\n\t\t\t\t\t   target->pipe.txcredit_alloc[i].\n\t\t\t\t\t   credit_alloc);\n\t\t\t}\n\t\t}\n\t}\n\treturn status;\n}\n\n \nstatic void htc_process_credit_report(struct htc_target *target,\n\t\t\t\t      struct htc_credit_report *rpt,\n\t\t\t\t      int num_entries,\n\t\t\t\t      enum htc_endpoint_id from_ep)\n{\n\tint total_credits = 0, i;\n\tstruct htc_endpoint *ep;\n\n\t \n\tspin_lock_bh(&target->tx_lock);\n\n\tfor (i = 0; i < num_entries; i++, rpt++) {\n\t\tif (rpt->eid >= ENDPOINT_MAX) {\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tspin_unlock_bh(&target->tx_lock);\n\t\t\treturn;\n\t\t}\n\n\t\tep = &target->endpoint[rpt->eid];\n\t\tep->cred_dist.credits += rpt->credits;\n\n\t\tif (ep->cred_dist.credits && get_queue_depth(&ep->txq)) {\n\t\t\tspin_unlock_bh(&target->tx_lock);\n\t\t\thtc_try_send(target, ep, NULL);\n\t\t\tspin_lock_bh(&target->tx_lock);\n\t\t}\n\n\t\ttotal_credits += rpt->credits;\n\t}\n\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t   \"Report indicated %d credits to distribute\\n\",\n\t\t   total_credits);\n\n\tspin_unlock_bh(&target->tx_lock);\n}\n\n \nstatic void htc_flush_tx_endpoint(struct htc_target *target,\n\t\t\t\t  struct htc_endpoint *ep, u16 tag)\n{\n\tstruct htc_packet *packet;\n\n\tspin_lock_bh(&target->tx_lock);\n\twhile (get_queue_depth(&ep->txq)) {\n\t\tpacket = list_first_entry(&ep->txq, struct htc_packet, list);\n\t\tlist_del(&packet->list);\n\t\tpacket->status = 0;\n\t\tsend_packet_completion(target, packet);\n\t}\n\tspin_unlock_bh(&target->tx_lock);\n}\n\n \nstatic struct htc_packet *htc_lookup_tx_packet(struct htc_target *target,\n\t\t\t\t\t       struct htc_endpoint *ep,\n\t\t\t\t\t       struct sk_buff *skb)\n{\n\tstruct htc_packet *packet, *tmp_pkt, *found_packet = NULL;\n\n\tspin_lock_bh(&target->tx_lock);\n\n\t \n\tlist_for_each_entry_safe(packet, tmp_pkt, &ep->pipe.tx_lookup_queue,\n\t\t\t\t list) {\n\t\t \n\t\tif (skb == packet->skb) {\n\t\t\t \n\t\t\tlist_del(&packet->list);\n\t\t\tfound_packet = packet;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_bh(&target->tx_lock);\n\n\treturn found_packet;\n}\n\nstatic int ath6kl_htc_pipe_tx_complete(struct ath6kl *ar, struct sk_buff *skb)\n{\n\tstruct htc_target *target = ar->htc_target;\n\tstruct htc_frame_hdr *htc_hdr;\n\tstruct htc_endpoint *ep;\n\tstruct htc_packet *packet;\n\tu8 ep_id, *netdata;\n\n\tnetdata = skb->data;\n\n\thtc_hdr = (struct htc_frame_hdr *) netdata;\n\n\tep_id = htc_hdr->eid;\n\tep = &target->endpoint[ep_id];\n\n\tpacket = htc_lookup_tx_packet(target, ep, skb);\n\tif (packet == NULL) {\n\t\t \n\t\tath6kl_err(\"HTC TX lookup failed!\\n\");\n\t} else {\n\t\t \n\t\tpacket->status = 0;\n\t\tsend_packet_completion(target, packet);\n\t}\n\tskb = NULL;\n\n\tif (!ep->pipe.tx_credit_flow_enabled) {\n\t\t \n\t\thtc_try_send(target, ep, NULL);\n\t}\n\n\treturn 0;\n}\n\nstatic int htc_send_packets_multiple(struct htc_target *target,\n\t\t\t\t     struct list_head *pkt_queue)\n{\n\tstruct htc_endpoint *ep;\n\tstruct htc_packet *packet, *tmp_pkt;\n\n\tif (list_empty(pkt_queue))\n\t\treturn -EINVAL;\n\n\t \n\tpacket = list_first_entry(pkt_queue, struct htc_packet, list);\n\n\tif (packet->endpoint >= ENDPOINT_MAX) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EINVAL;\n\t}\n\tep = &target->endpoint[packet->endpoint];\n\n\thtc_try_send(target, ep, pkt_queue);\n\n\t \n\tif (!list_empty(pkt_queue)) {\n\t\tlist_for_each_entry_safe(packet, tmp_pkt, pkt_queue, list) {\n\t\t\tpacket->status = -ENOMEM;\n\t\t}\n\n\t\tdo_send_completion(ep, pkt_queue);\n\t}\n\n\treturn 0;\n}\n\n \nstatic struct htc_packet *alloc_htc_packet_container(struct htc_target *target)\n{\n\tstruct htc_packet *packet;\n\tspin_lock_bh(&target->rx_lock);\n\n\tif (target->pipe.htc_packet_pool == NULL) {\n\t\tspin_unlock_bh(&target->rx_lock);\n\t\treturn NULL;\n\t}\n\n\tpacket = target->pipe.htc_packet_pool;\n\ttarget->pipe.htc_packet_pool = (struct htc_packet *) packet->list.next;\n\n\tspin_unlock_bh(&target->rx_lock);\n\n\tpacket->list.next = NULL;\n\treturn packet;\n}\n\nstatic void free_htc_packet_container(struct htc_target *target,\n\t\t\t\t      struct htc_packet *packet)\n{\n\tstruct list_head *lh;\n\n\tspin_lock_bh(&target->rx_lock);\n\n\tif (target->pipe.htc_packet_pool == NULL) {\n\t\ttarget->pipe.htc_packet_pool = packet;\n\t\tpacket->list.next = NULL;\n\t} else {\n\t\tlh = (struct list_head *) target->pipe.htc_packet_pool;\n\t\tpacket->list.next = lh;\n\t\ttarget->pipe.htc_packet_pool = packet;\n\t}\n\n\tspin_unlock_bh(&target->rx_lock);\n}\n\nstatic int htc_process_trailer(struct htc_target *target, u8 *buffer,\n\t\t\t       int len, enum htc_endpoint_id from_ep)\n{\n\tstruct htc_credit_report *report;\n\tstruct htc_record_hdr *record;\n\tu8 *record_buf;\n\tint status = 0;\n\n\twhile (len > 0) {\n\t\tif (len < sizeof(struct htc_record_hdr)) {\n\t\t\tstatus = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\trecord = (struct htc_record_hdr *) buffer;\n\t\tlen -= sizeof(struct htc_record_hdr);\n\t\tbuffer += sizeof(struct htc_record_hdr);\n\n\t\tif (record->len > len) {\n\t\t\t \n\t\t\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t\t\t   \"invalid length: %d (id:%d) buffer has: %d bytes left\\n\",\n\t\t\t\t   record->len, record->rec_id, len);\n\t\t\tstatus = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\trecord_buf = buffer;\n\n\t\tswitch (record->rec_id) {\n\t\tcase HTC_RECORD_CREDITS:\n\t\t\tif (record->len < sizeof(struct htc_credit_report)) {\n\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\treport = (struct htc_credit_report *) record_buf;\n\t\t\thtc_process_credit_report(target, report,\n\t\t\t\t\t\t  record->len / sizeof(*report),\n\t\t\t\t\t\t  from_ep);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t\t\t   \"unhandled record: id:%d length:%d\\n\",\n\t\t\t\t   record->rec_id, record->len);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tbuffer += record->len;\n\t\tlen -= record->len;\n\t}\n\n\treturn status;\n}\n\nstatic void do_recv_completion(struct htc_endpoint *ep,\n\t\t\t       struct list_head *queue_to_indicate)\n{\n\tstruct htc_packet *packet;\n\n\tif (list_empty(queue_to_indicate)) {\n\t\t \n\t\treturn;\n\t}\n\n\t \n\twhile (!list_empty(queue_to_indicate)) {\n\t\tpacket = list_first_entry(queue_to_indicate,\n\t\t\t\t\t  struct htc_packet, list);\n\t\tlist_del(&packet->list);\n\t\tep->ep_cb.rx(ep->target, packet);\n\t}\n\n\treturn;\n}\n\nstatic void recv_packet_completion(struct htc_target *target,\n\t\t\t\t   struct htc_endpoint *ep,\n\t\t\t\t   struct htc_packet *packet)\n{\n\tstruct list_head container;\n\tINIT_LIST_HEAD(&container);\n\tlist_add_tail(&packet->list, &container);\n\n\t \n\tdo_recv_completion(ep, &container);\n}\n\nstatic int ath6kl_htc_pipe_rx_complete(struct ath6kl *ar, struct sk_buff *skb,\n\t\t\t\t       u8 pipeid)\n{\n\tstruct htc_target *target = ar->htc_target;\n\tu8 *netdata, *trailer, hdr_info;\n\tstruct htc_frame_hdr *htc_hdr;\n\tu32 netlen, trailerlen = 0;\n\tstruct htc_packet *packet;\n\tstruct htc_endpoint *ep;\n\tu16 payload_len;\n\tint status = 0;\n\n\t \n\tif (!target) {\n\t\tath6kl_dbg(ATH6KL_DBG_HTC, \"Target not yet initialized\\n\");\n\t\tstatus = -EINVAL;\n\t\tgoto free_skb;\n\t}\n\n\n\tnetdata = skb->data;\n\tnetlen = skb->len;\n\n\thtc_hdr = (struct htc_frame_hdr *) netdata;\n\n\tif (htc_hdr->eid >= ENDPOINT_MAX) {\n\t\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t\t   \"HTC Rx: invalid EndpointID=%d\\n\",\n\t\t\t   htc_hdr->eid);\n\t\tstatus = -EINVAL;\n\t\tgoto free_skb;\n\t}\n\tep = &target->endpoint[htc_hdr->eid];\n\n\tpayload_len = le16_to_cpu(get_unaligned(&htc_hdr->payld_len));\n\n\tif (netlen < (payload_len + HTC_HDR_LENGTH)) {\n\t\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t\t   \"HTC Rx: insufficient length, got:%d expected =%zu\\n\",\n\t\t\t   netlen, payload_len + HTC_HDR_LENGTH);\n\t\tstatus = -EINVAL;\n\t\tgoto free_skb;\n\t}\n\n\t \n\thdr_info = htc_hdr->flags;\n\tif (hdr_info & HTC_FLG_RX_TRAILER) {\n\t\t \n\t\thdr_info = htc_hdr->ctrl[0];\n\t\tif ((hdr_info < sizeof(struct htc_record_hdr)) ||\n\t\t    (hdr_info > payload_len)) {\n\t\t\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t\t\t   \"invalid header: payloadlen should be %d, CB[0]: %d\\n\",\n\t\t\t\t   payload_len, hdr_info);\n\t\t\tstatus = -EINVAL;\n\t\t\tgoto free_skb;\n\t\t}\n\n\t\ttrailerlen = hdr_info;\n\t\t \n\t\ttrailer = (u8 *) htc_hdr + HTC_HDR_LENGTH +\n\t\t\tpayload_len - hdr_info;\n\t\tstatus = htc_process_trailer(target, trailer, hdr_info,\n\t\t\t\t\t     htc_hdr->eid);\n\t\tif (status != 0)\n\t\t\tgoto free_skb;\n\t}\n\n\tif (((int) payload_len - (int) trailerlen) <= 0) {\n\t\t \n\t\tgoto free_skb;\n\t}\n\n\tif (htc_hdr->eid == ENDPOINT_0) {\n\t\t \n\t\tif (target->htc_flags & HTC_OP_STATE_SETUP_COMPLETE) {\n\t\t\t \n\t\t\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t\t\t   \"HTC ignores Rx Ctrl after setup complete\\n\");\n\t\t\tstatus = -EINVAL;\n\t\t\tgoto free_skb;\n\t\t}\n\n\t\t \n\t\tskb_pull(skb, HTC_HDR_LENGTH);\n\n\t\tnetdata = skb->data;\n\t\tnetlen = skb->len;\n\n\t\tspin_lock_bh(&target->rx_lock);\n\n\t\ttarget->pipe.ctrl_response_valid = true;\n\t\ttarget->pipe.ctrl_response_len = min_t(int, netlen,\n\t\t\t\t\t\t       HTC_MAX_CTRL_MSG_LEN);\n\t\tmemcpy(target->pipe.ctrl_response_buf, netdata,\n\t\t       target->pipe.ctrl_response_len);\n\n\t\tspin_unlock_bh(&target->rx_lock);\n\n\t\tdev_kfree_skb(skb);\n\t\tskb = NULL;\n\n\t\tgoto free_skb;\n\t}\n\n\t \n\tpacket = alloc_htc_packet_container(target);\n\tif (packet == NULL) {\n\t\tstatus = -ENOMEM;\n\t\tgoto free_skb;\n\t}\n\n\tpacket->status = 0;\n\tpacket->endpoint = htc_hdr->eid;\n\tpacket->pkt_cntxt = skb;\n\n\t \n\tpacket->buf = skb_push(skb, 0) + HTC_HDR_LENGTH;\n\tpacket->act_len = netlen - HTC_HDR_LENGTH - trailerlen;\n\n\t \n\tskb_trim(skb, 0);\n\n\trecv_packet_completion(target, ep, packet);\n\n\t \n\tfree_htc_packet_container(target, packet);\n\tskb = NULL;\n\nfree_skb:\n\tdev_kfree_skb(skb);\n\n\treturn status;\n}\n\nstatic void htc_flush_rx_queue(struct htc_target *target,\n\t\t\t       struct htc_endpoint *ep)\n{\n\tstruct list_head container;\n\tstruct htc_packet *packet;\n\n\tspin_lock_bh(&target->rx_lock);\n\n\twhile (1) {\n\t\tif (list_empty(&ep->rx_bufq))\n\t\t\tbreak;\n\n\t\tpacket = list_first_entry(&ep->rx_bufq,\n\t\t\t\t\t  struct htc_packet, list);\n\t\tlist_del(&packet->list);\n\n\t\tspin_unlock_bh(&target->rx_lock);\n\t\tpacket->status = -ECANCELED;\n\t\tpacket->act_len = 0;\n\n\t\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t\t   \"Flushing RX packet:0x%p, length:%d, ep:%d\\n\",\n\t\t\t   packet, packet->buf_len,\n\t\t\t   packet->endpoint);\n\n\t\tINIT_LIST_HEAD(&container);\n\t\tlist_add_tail(&packet->list, &container);\n\n\t\t \n\t\tdo_recv_completion(ep, &container);\n\t\tspin_lock_bh(&target->rx_lock);\n\t}\n\n\tspin_unlock_bh(&target->rx_lock);\n}\n\n \nstatic int htc_wait_recv_ctrl_message(struct htc_target *target)\n{\n\tint count = HTC_TARGET_RESPONSE_POLL_COUNT;\n\n\twhile (count > 0) {\n\t\tspin_lock_bh(&target->rx_lock);\n\n\t\tif (target->pipe.ctrl_response_valid) {\n\t\t\ttarget->pipe.ctrl_response_valid = false;\n\t\t\tspin_unlock_bh(&target->rx_lock);\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_unlock_bh(&target->rx_lock);\n\n\t\tcount--;\n\n\t\tmsleep_interruptible(HTC_TARGET_RESPONSE_POLL_WAIT);\n\t}\n\n\tif (count <= 0) {\n\t\tath6kl_warn(\"htc pipe control receive timeout!\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic void htc_rxctrl_complete(struct htc_target *context,\n\t\t\t\tstruct htc_packet *packet)\n{\n\tstruct sk_buff *skb = packet->skb;\n\n\tif (packet->endpoint == ENDPOINT_0 &&\n\t    packet->status == -ECANCELED &&\n\t    skb != NULL)\n\t\tdev_kfree_skb(skb);\n}\n\n \nstatic void reset_endpoint_states(struct htc_target *target)\n{\n\tstruct htc_endpoint *ep;\n\tint i;\n\n\tfor (i = ENDPOINT_0; i < ENDPOINT_MAX; i++) {\n\t\tep = &target->endpoint[i];\n\t\tep->svc_id = 0;\n\t\tep->len_max = 0;\n\t\tep->max_txq_depth = 0;\n\t\tep->eid = i;\n\t\tINIT_LIST_HEAD(&ep->txq);\n\t\tINIT_LIST_HEAD(&ep->pipe.tx_lookup_queue);\n\t\tINIT_LIST_HEAD(&ep->rx_bufq);\n\t\tep->target = target;\n\t\tep->pipe.tx_credit_flow_enabled = true;\n\t}\n}\n\n \nstatic int htc_config_target_hif_pipe(struct htc_target *target)\n{\n\treturn 0;\n}\n\n \nstatic u8 htc_get_credit_alloc(struct htc_target *target, u16 service_id)\n{\n\tu8 allocation = 0;\n\tint i;\n\n\tfor (i = 0; i < ENDPOINT_MAX; i++) {\n\t\tif (target->pipe.txcredit_alloc[i].service_id == service_id)\n\t\t\tallocation =\n\t\t\t\ttarget->pipe.txcredit_alloc[i].credit_alloc;\n\t}\n\n\tif (allocation == 0) {\n\t\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t\t   \"HTC Service TX : 0x%2.2X : allocation is zero!\\n\",\n\t\t\t   service_id);\n\t}\n\n\treturn allocation;\n}\n\nstatic int ath6kl_htc_pipe_conn_service(struct htc_target *target,\n\t\t     struct htc_service_connect_req *conn_req,\n\t\t     struct htc_service_connect_resp *conn_resp)\n{\n\tstruct ath6kl *ar = target->dev->ar;\n\tstruct htc_packet *packet = NULL;\n\tstruct htc_conn_service_resp *resp_msg;\n\tstruct htc_conn_service_msg *conn_msg;\n\tenum htc_endpoint_id assigned_epid = ENDPOINT_MAX;\n\tbool disable_credit_flowctrl = false;\n\tunsigned int max_msg_size = 0;\n\tstruct htc_endpoint *ep;\n\tint length, status = 0;\n\tstruct sk_buff *skb;\n\tu8 tx_alloc;\n\tu16 flags;\n\n\tif (conn_req->svc_id == 0) {\n\t\tWARN_ON_ONCE(1);\n\t\tstatus = -EINVAL;\n\t\tgoto free_packet;\n\t}\n\n\tif (conn_req->svc_id == HTC_CTRL_RSVD_SVC) {\n\t\t \n\t\tassigned_epid = ENDPOINT_0;\n\t\tmax_msg_size = HTC_MAX_CTRL_MSG_LEN;\n\t\ttx_alloc = 0;\n\n\t} else {\n\t\ttx_alloc = htc_get_credit_alloc(target, conn_req->svc_id);\n\t\tif (tx_alloc == 0) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tgoto free_packet;\n\t\t}\n\n\t\t \n\t\tpacket = htc_alloc_txctrl_packet(target);\n\n\t\tif (packet == NULL) {\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tstatus = -ENOMEM;\n\t\t\tgoto free_packet;\n\t\t}\n\n\t\tskb = packet->skb;\n\t\tlength = sizeof(struct htc_conn_service_msg);\n\n\t\t \n\t\tconn_msg = skb_put(skb, length);\n\t\tif (conn_msg == NULL) {\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tstatus = -EINVAL;\n\t\t\tgoto free_packet;\n\t\t}\n\n\t\tmemset(conn_msg, 0,\n\t\t       sizeof(struct htc_conn_service_msg));\n\t\tconn_msg->msg_id = cpu_to_le16(HTC_MSG_CONN_SVC_ID);\n\t\tconn_msg->svc_id = cpu_to_le16(conn_req->svc_id);\n\t\tconn_msg->conn_flags = cpu_to_le16(conn_req->conn_flags &\n\t\t\t\t\t~HTC_CONN_FLGS_SET_RECV_ALLOC_MASK);\n\n\t\t \n\t\tflags = tx_alloc << HTC_CONN_FLGS_SET_RECV_ALLOC_SHIFT;\n\t\tconn_msg->conn_flags |= cpu_to_le16(flags);\n\n\t\tif (conn_req->conn_flags &\n\t\t    HTC_CONN_FLGS_DISABLE_CRED_FLOW_CTRL) {\n\t\t\tdisable_credit_flowctrl = true;\n\t\t}\n\n\t\tset_htc_pkt_info(packet, NULL, (u8 *) conn_msg,\n\t\t\t\t length,\n\t\t\t\t ENDPOINT_0, HTC_SERVICE_TX_PACKET_TAG);\n\n\t\tstatus = ath6kl_htc_pipe_tx(target, packet);\n\n\t\t \n\t\tpacket = NULL;\n\t\tif (status != 0)\n\t\t\tgoto free_packet;\n\n\t\t \n\t\tstatus = htc_wait_recv_ctrl_message(target);\n\t\tif (status != 0)\n\t\t\tgoto free_packet;\n\n\t\t \n\t\tresp_msg = (struct htc_conn_service_resp *)\n\t\t    target->pipe.ctrl_response_buf;\n\n\t\tif (resp_msg->msg_id != cpu_to_le16(HTC_MSG_CONN_SVC_RESP_ID) ||\n\t\t    (target->pipe.ctrl_response_len < sizeof(*resp_msg))) {\n\t\t\t \n\t\t\tWARN_ON_ONCE(1);\n\t\t\tstatus = -EINVAL;\n\t\t\tgoto free_packet;\n\t\t}\n\n\t\tath6kl_dbg(ATH6KL_DBG_TRC,\n\t\t\t   \"%s: service 0x%X conn resp: status: %d ep: %d\\n\",\n\t\t\t   __func__, resp_msg->svc_id, resp_msg->status,\n\t\t\t   resp_msg->eid);\n\n\t\tconn_resp->resp_code = resp_msg->status;\n\t\t \n\t\tif (resp_msg->status != HTC_SERVICE_SUCCESS) {\n\t\t\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t\t\t   \"Target failed service 0x%X connect request (status:%d)\\n\",\n\t\t\t\t   resp_msg->svc_id, resp_msg->status);\n\t\t\tstatus = -EINVAL;\n\t\t\tgoto free_packet;\n\t\t}\n\n\t\tassigned_epid = (enum htc_endpoint_id) resp_msg->eid;\n\t\tmax_msg_size = le16_to_cpu(resp_msg->max_msg_sz);\n\t}\n\n\t \n\tstatus = -EINVAL;\n\n\tif (assigned_epid >= ENDPOINT_MAX) {\n\t\tWARN_ON_ONCE(1);\n\t\tgoto free_packet;\n\t}\n\n\tif (max_msg_size == 0) {\n\t\tWARN_ON_ONCE(1);\n\t\tgoto free_packet;\n\t}\n\n\tep = &target->endpoint[assigned_epid];\n\tep->eid = assigned_epid;\n\tif (ep->svc_id != 0) {\n\t\t \n\t\tWARN_ON_ONCE(1);\n\t\tgoto free_packet;\n\t}\n\n\t \n\tconn_resp->endpoint = assigned_epid;\n\tconn_resp->len_max = max_msg_size;\n\n\t \n\tep->svc_id = conn_req->svc_id;  \n\tep->max_txq_depth = conn_req->max_txq_depth;\n\tep->len_max = max_msg_size;\n\tep->cred_dist.credits = tx_alloc;\n\tep->cred_dist.cred_sz = target->tgt_cred_sz;\n\tep->cred_dist.cred_per_msg = max_msg_size / target->tgt_cred_sz;\n\tif (max_msg_size % target->tgt_cred_sz)\n\t\tep->cred_dist.cred_per_msg++;\n\n\t \n\tep->ep_cb = conn_req->ep_cb;\n\n\t \n\tep->tx_drop_packet_threshold = MAX_HI_COOKIE_NUM;\n\n\tstatus = ath6kl_hif_pipe_map_service(ar, ep->svc_id,\n\t\t\t\t\t     &ep->pipe.pipeid_ul,\n\t\t\t\t\t     &ep->pipe.pipeid_dl);\n\tif (status != 0)\n\t\tgoto free_packet;\n\n\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t   \"SVC Ready: 0x%4.4X: ULpipe:%d DLpipe:%d id:%d\\n\",\n\t\t   ep->svc_id, ep->pipe.pipeid_ul,\n\t\t   ep->pipe.pipeid_dl, ep->eid);\n\n\tif (disable_credit_flowctrl && ep->pipe.tx_credit_flow_enabled) {\n\t\tep->pipe.tx_credit_flow_enabled = false;\n\t\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t\t   \"SVC: 0x%4.4X ep:%d TX flow control off\\n\",\n\t\t\t   ep->svc_id, assigned_epid);\n\t}\n\nfree_packet:\n\tif (packet != NULL)\n\t\thtc_free_txctrl_packet(target, packet);\n\treturn status;\n}\n\n \nstatic void *ath6kl_htc_pipe_create(struct ath6kl *ar)\n{\n\tint status = 0;\n\tstruct htc_endpoint *ep = NULL;\n\tstruct htc_target *target = NULL;\n\tstruct htc_packet *packet;\n\tint i;\n\n\ttarget = kzalloc(sizeof(struct htc_target), GFP_KERNEL);\n\tif (target == NULL) {\n\t\tath6kl_err(\"htc create unable to allocate memory\\n\");\n\t\tstatus = -ENOMEM;\n\t\tgoto fail_htc_create;\n\t}\n\n\tspin_lock_init(&target->htc_lock);\n\tspin_lock_init(&target->rx_lock);\n\tspin_lock_init(&target->tx_lock);\n\n\treset_endpoint_states(target);\n\n\tfor (i = 0; i < HTC_PACKET_CONTAINER_ALLOCATION; i++) {\n\t\tpacket = kzalloc(sizeof(struct htc_packet), GFP_KERNEL);\n\n\t\tif (packet != NULL)\n\t\t\tfree_htc_packet_container(target, packet);\n\t}\n\n\ttarget->dev = kzalloc(sizeof(*target->dev), GFP_KERNEL);\n\tif (!target->dev) {\n\t\tath6kl_err(\"unable to allocate memory\\n\");\n\t\tstatus = -ENOMEM;\n\t\tgoto fail_htc_create;\n\t}\n\ttarget->dev->ar = ar;\n\ttarget->dev->htc_cnxt = target;\n\n\t \n\tep = &target->endpoint[ENDPOINT_0];\n\n\tath6kl_hif_pipe_get_default(ar, &ep->pipe.pipeid_ul,\n\t\t\t\t    &ep->pipe.pipeid_dl);\n\n\treturn target;\n\nfail_htc_create:\n\tif (status != 0) {\n\t\tif (target != NULL)\n\t\t\tath6kl_htc_pipe_cleanup(target);\n\n\t\ttarget = NULL;\n\t}\n\treturn target;\n}\n\n \nstatic void ath6kl_htc_pipe_cleanup(struct htc_target *target)\n{\n\tstruct htc_packet *packet;\n\n\twhile (true) {\n\t\tpacket = alloc_htc_packet_container(target);\n\t\tif (packet == NULL)\n\t\t\tbreak;\n\t\tkfree(packet);\n\t}\n\n\tkfree(target->dev);\n\n\t \n\tkfree(target);\n}\n\nstatic int ath6kl_htc_pipe_start(struct htc_target *target)\n{\n\tstruct sk_buff *skb;\n\tstruct htc_setup_comp_ext_msg *setup;\n\tstruct htc_packet *packet;\n\n\thtc_config_target_hif_pipe(target);\n\n\t \n\tpacket = htc_alloc_txctrl_packet(target);\n\tif (packet == NULL) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn -ENOMEM;\n\t}\n\n\tskb = packet->skb;\n\n\t \n\tsetup = skb_put(skb, sizeof(*setup));\n\tmemset(setup, 0, sizeof(struct htc_setup_comp_ext_msg));\n\tsetup->msg_id = cpu_to_le16(HTC_MSG_SETUP_COMPLETE_EX_ID);\n\n\tath6kl_dbg(ATH6KL_DBG_HTC, \"HTC using TX credit flow control\\n\");\n\n\tset_htc_pkt_info(packet, NULL, (u8 *) setup,\n\t\t\t sizeof(struct htc_setup_comp_ext_msg),\n\t\t\t ENDPOINT_0, HTC_SERVICE_TX_PACKET_TAG);\n\n\ttarget->htc_flags |= HTC_OP_STATE_SETUP_COMPLETE;\n\n\treturn ath6kl_htc_pipe_tx(target, packet);\n}\n\nstatic void ath6kl_htc_pipe_stop(struct htc_target *target)\n{\n\tint i;\n\tstruct htc_endpoint *ep;\n\n\t \n\tfor (i = 0; i < ENDPOINT_MAX; i++) {\n\t\tep = &target->endpoint[i];\n\t\thtc_flush_rx_queue(target, ep);\n\t\thtc_flush_tx_endpoint(target, ep, HTC_TX_PACKET_TAG_ALL);\n\t}\n\n\treset_endpoint_states(target);\n\ttarget->htc_flags &= ~HTC_OP_STATE_SETUP_COMPLETE;\n}\n\nstatic int ath6kl_htc_pipe_get_rxbuf_num(struct htc_target *target,\n\t\t\t\t\t enum htc_endpoint_id endpoint)\n{\n\tint num;\n\n\tspin_lock_bh(&target->rx_lock);\n\tnum = get_queue_depth(&(target->endpoint[endpoint].rx_bufq));\n\tspin_unlock_bh(&target->rx_lock);\n\n\treturn num;\n}\n\nstatic int ath6kl_htc_pipe_tx(struct htc_target *target,\n\t\t\t      struct htc_packet *packet)\n{\n\tstruct list_head queue;\n\n\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t   \"%s: endPointId: %d, buffer: 0x%p, length: %d\\n\",\n\t\t   __func__, packet->endpoint, packet->buf,\n\t\t   packet->act_len);\n\n\tINIT_LIST_HEAD(&queue);\n\tlist_add_tail(&packet->list, &queue);\n\n\treturn htc_send_packets_multiple(target, &queue);\n}\n\nstatic int ath6kl_htc_pipe_wait_target(struct htc_target *target)\n{\n\tstruct htc_ready_ext_msg *ready_msg;\n\tstruct htc_service_connect_req connect;\n\tstruct htc_service_connect_resp resp;\n\tint status = 0;\n\n\tstatus = htc_wait_recv_ctrl_message(target);\n\n\tif (status != 0)\n\t\treturn status;\n\n\tif (target->pipe.ctrl_response_len < sizeof(*ready_msg)) {\n\t\tath6kl_warn(\"invalid htc pipe ready msg len: %d\\n\",\n\t\t\t    target->pipe.ctrl_response_len);\n\t\treturn -ECOMM;\n\t}\n\n\tready_msg = (struct htc_ready_ext_msg *) target->pipe.ctrl_response_buf;\n\n\tif (ready_msg->ver2_0_info.msg_id != cpu_to_le16(HTC_MSG_READY_ID)) {\n\t\tath6kl_warn(\"invalid htc pipe ready msg: 0x%x\\n\",\n\t\t\t    ready_msg->ver2_0_info.msg_id);\n\t\treturn -ECOMM;\n\t}\n\n\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t   \"Target Ready! : transmit resources : %d size:%d\\n\",\n\t\t   ready_msg->ver2_0_info.cred_cnt,\n\t\t   ready_msg->ver2_0_info.cred_sz);\n\n\ttarget->tgt_creds = le16_to_cpu(ready_msg->ver2_0_info.cred_cnt);\n\ttarget->tgt_cred_sz = le16_to_cpu(ready_msg->ver2_0_info.cred_sz);\n\n\tif ((target->tgt_creds == 0) || (target->tgt_cred_sz == 0))\n\t\treturn -ECOMM;\n\n\thtc_setup_target_buffer_assignments(target);\n\n\t \n\tmemset(&connect, 0, sizeof(connect));\n\tmemset(&resp, 0, sizeof(resp));\n\tconnect.ep_cb.tx_complete = htc_txctrl_complete;\n\tconnect.ep_cb.rx = htc_rxctrl_complete;\n\tconnect.max_txq_depth = NUM_CONTROL_TX_BUFFERS;\n\tconnect.svc_id = HTC_CTRL_RSVD_SVC;\n\n\t \n\tstatus = ath6kl_htc_pipe_conn_service(target, &connect, &resp);\n\n\treturn status;\n}\n\nstatic void ath6kl_htc_pipe_flush_txep(struct htc_target *target,\n\t\t\t\t       enum htc_endpoint_id endpoint, u16 tag)\n{\n\tstruct htc_endpoint *ep = &target->endpoint[endpoint];\n\n\tif (ep->svc_id == 0) {\n\t\tWARN_ON_ONCE(1);\n\t\t \n\t\treturn;\n\t}\n\n\thtc_flush_tx_endpoint(target, ep, tag);\n}\n\nstatic int ath6kl_htc_pipe_add_rxbuf_multiple(struct htc_target *target,\n\t\t\t\t\t      struct list_head *pkt_queue)\n{\n\tstruct htc_packet *packet, *tmp_pkt, *first;\n\tstruct htc_endpoint *ep;\n\tint status = 0;\n\n\tif (list_empty(pkt_queue))\n\t\treturn -EINVAL;\n\n\tfirst = list_first_entry(pkt_queue, struct htc_packet, list);\n\n\tif (first->endpoint >= ENDPOINT_MAX) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EINVAL;\n\t}\n\n\tath6kl_dbg(ATH6KL_DBG_HTC, \"%s: epid: %d, cnt:%d, len: %d\\n\",\n\t\t   __func__, first->endpoint, get_queue_depth(pkt_queue),\n\t\t   first->buf_len);\n\n\tep = &target->endpoint[first->endpoint];\n\n\tspin_lock_bh(&target->rx_lock);\n\n\t \n\tlist_splice_tail_init(pkt_queue, &ep->rx_bufq);\n\n\tspin_unlock_bh(&target->rx_lock);\n\n\tif (status != 0) {\n\t\t \n\t\tlist_for_each_entry_safe(packet, tmp_pkt, pkt_queue, list) {\n\t\t\tpacket->status = -ECANCELED;\n\t\t}\n\n\t\tdo_recv_completion(ep, pkt_queue);\n\t}\n\n\treturn status;\n}\n\nstatic void ath6kl_htc_pipe_activity_changed(struct htc_target *target,\n\t\t\t\t\t     enum htc_endpoint_id ep,\n\t\t\t\t\t     bool active)\n{\n\t \n}\n\nstatic void ath6kl_htc_pipe_flush_rx_buf(struct htc_target *target)\n{\n\tstruct htc_endpoint *endpoint;\n\tstruct htc_packet *packet, *tmp_pkt;\n\tint i;\n\n\tfor (i = ENDPOINT_0; i < ENDPOINT_MAX; i++) {\n\t\tendpoint = &target->endpoint[i];\n\n\t\tspin_lock_bh(&target->rx_lock);\n\n\t\tlist_for_each_entry_safe(packet, tmp_pkt,\n\t\t\t\t\t &endpoint->rx_bufq, list) {\n\t\t\tlist_del(&packet->list);\n\t\t\tspin_unlock_bh(&target->rx_lock);\n\t\t\tath6kl_dbg(ATH6KL_DBG_HTC,\n\t\t\t\t   \"htc rx flush pkt 0x%p len %d ep %d\\n\",\n\t\t\t\t   packet, packet->buf_len,\n\t\t\t\t   packet->endpoint);\n\t\t\tdev_kfree_skb(packet->pkt_cntxt);\n\t\t\tspin_lock_bh(&target->rx_lock);\n\t\t}\n\n\t\tspin_unlock_bh(&target->rx_lock);\n\t}\n}\n\nstatic int ath6kl_htc_pipe_credit_setup(struct htc_target *target,\n\t\t\t\t\tstruct ath6kl_htc_credit_info *info)\n{\n\treturn 0;\n}\n\nstatic const struct ath6kl_htc_ops ath6kl_htc_pipe_ops = {\n\t.create = ath6kl_htc_pipe_create,\n\t.wait_target = ath6kl_htc_pipe_wait_target,\n\t.start = ath6kl_htc_pipe_start,\n\t.conn_service = ath6kl_htc_pipe_conn_service,\n\t.tx = ath6kl_htc_pipe_tx,\n\t.stop = ath6kl_htc_pipe_stop,\n\t.cleanup = ath6kl_htc_pipe_cleanup,\n\t.flush_txep = ath6kl_htc_pipe_flush_txep,\n\t.flush_rx_buf = ath6kl_htc_pipe_flush_rx_buf,\n\t.activity_changed = ath6kl_htc_pipe_activity_changed,\n\t.get_rxbuf_num = ath6kl_htc_pipe_get_rxbuf_num,\n\t.add_rxbuf_multiple = ath6kl_htc_pipe_add_rxbuf_multiple,\n\t.credit_setup = ath6kl_htc_pipe_credit_setup,\n\t.tx_complete = ath6kl_htc_pipe_tx_complete,\n\t.rx_complete = ath6kl_htc_pipe_rx_complete,\n};\n\nvoid ath6kl_htc_pipe_attach(struct ath6kl *ar)\n{\n\tar->htc_ops = &ath6kl_htc_pipe_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}