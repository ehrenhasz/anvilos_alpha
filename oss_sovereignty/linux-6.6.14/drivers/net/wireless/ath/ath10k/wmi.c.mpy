{
  "module_name": "wmi.c",
  "hash_id": "41346dff6639435eed92b837ec4de45b402c498b5b4c90fb65942adece899844",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath10k/wmi.c",
  "human_readable_source": "\n \n\n#include <linux/skbuff.h>\n#include <linux/ctype.h>\n\n#include \"core.h\"\n#include \"htc.h\"\n#include \"debug.h\"\n#include \"wmi.h\"\n#include \"wmi-tlv.h\"\n#include \"mac.h\"\n#include \"testmode.h\"\n#include \"wmi-ops.h\"\n#include \"p2p.h\"\n#include \"hw.h\"\n#include \"hif.h\"\n#include \"txrx.h\"\n\n#define ATH10K_WMI_BARRIER_ECHO_ID 0xBA991E9\n#define ATH10K_WMI_BARRIER_TIMEOUT_HZ (3 * HZ)\n#define ATH10K_WMI_DFS_CONF_TIMEOUT_HZ (HZ / 6)\n\n \nstatic struct wmi_cmd_map wmi_cmd_map = {\n\t.init_cmdid = WMI_INIT_CMDID,\n\t.start_scan_cmdid = WMI_START_SCAN_CMDID,\n\t.stop_scan_cmdid = WMI_STOP_SCAN_CMDID,\n\t.scan_chan_list_cmdid = WMI_SCAN_CHAN_LIST_CMDID,\n\t.scan_sch_prio_tbl_cmdid = WMI_SCAN_SCH_PRIO_TBL_CMDID,\n\t.scan_prob_req_oui_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_set_regdomain_cmdid = WMI_PDEV_SET_REGDOMAIN_CMDID,\n\t.pdev_set_channel_cmdid = WMI_PDEV_SET_CHANNEL_CMDID,\n\t.pdev_set_param_cmdid = WMI_PDEV_SET_PARAM_CMDID,\n\t.pdev_pktlog_enable_cmdid = WMI_PDEV_PKTLOG_ENABLE_CMDID,\n\t.pdev_pktlog_disable_cmdid = WMI_PDEV_PKTLOG_DISABLE_CMDID,\n\t.pdev_set_wmm_params_cmdid = WMI_PDEV_SET_WMM_PARAMS_CMDID,\n\t.pdev_set_ht_cap_ie_cmdid = WMI_PDEV_SET_HT_CAP_IE_CMDID,\n\t.pdev_set_vht_cap_ie_cmdid = WMI_PDEV_SET_VHT_CAP_IE_CMDID,\n\t.pdev_set_dscp_tid_map_cmdid = WMI_PDEV_SET_DSCP_TID_MAP_CMDID,\n\t.pdev_set_quiet_mode_cmdid = WMI_PDEV_SET_QUIET_MODE_CMDID,\n\t.pdev_green_ap_ps_enable_cmdid = WMI_PDEV_GREEN_AP_PS_ENABLE_CMDID,\n\t.pdev_get_tpc_config_cmdid = WMI_PDEV_GET_TPC_CONFIG_CMDID,\n\t.pdev_set_base_macaddr_cmdid = WMI_PDEV_SET_BASE_MACADDR_CMDID,\n\t.vdev_create_cmdid = WMI_VDEV_CREATE_CMDID,\n\t.vdev_delete_cmdid = WMI_VDEV_DELETE_CMDID,\n\t.vdev_start_request_cmdid = WMI_VDEV_START_REQUEST_CMDID,\n\t.vdev_restart_request_cmdid = WMI_VDEV_RESTART_REQUEST_CMDID,\n\t.vdev_up_cmdid = WMI_VDEV_UP_CMDID,\n\t.vdev_stop_cmdid = WMI_VDEV_STOP_CMDID,\n\t.vdev_down_cmdid = WMI_VDEV_DOWN_CMDID,\n\t.vdev_set_param_cmdid = WMI_VDEV_SET_PARAM_CMDID,\n\t.vdev_install_key_cmdid = WMI_VDEV_INSTALL_KEY_CMDID,\n\t.peer_create_cmdid = WMI_PEER_CREATE_CMDID,\n\t.peer_delete_cmdid = WMI_PEER_DELETE_CMDID,\n\t.peer_flush_tids_cmdid = WMI_PEER_FLUSH_TIDS_CMDID,\n\t.peer_set_param_cmdid = WMI_PEER_SET_PARAM_CMDID,\n\t.peer_assoc_cmdid = WMI_PEER_ASSOC_CMDID,\n\t.peer_add_wds_entry_cmdid = WMI_PEER_ADD_WDS_ENTRY_CMDID,\n\t.peer_remove_wds_entry_cmdid = WMI_PEER_REMOVE_WDS_ENTRY_CMDID,\n\t.peer_mcast_group_cmdid = WMI_PEER_MCAST_GROUP_CMDID,\n\t.bcn_tx_cmdid = WMI_BCN_TX_CMDID,\n\t.pdev_send_bcn_cmdid = WMI_PDEV_SEND_BCN_CMDID,\n\t.bcn_tmpl_cmdid = WMI_BCN_TMPL_CMDID,\n\t.bcn_filter_rx_cmdid = WMI_BCN_FILTER_RX_CMDID,\n\t.prb_req_filter_rx_cmdid = WMI_PRB_REQ_FILTER_RX_CMDID,\n\t.mgmt_tx_cmdid = WMI_MGMT_TX_CMDID,\n\t.prb_tmpl_cmdid = WMI_PRB_TMPL_CMDID,\n\t.addba_clear_resp_cmdid = WMI_ADDBA_CLEAR_RESP_CMDID,\n\t.addba_send_cmdid = WMI_ADDBA_SEND_CMDID,\n\t.addba_status_cmdid = WMI_ADDBA_STATUS_CMDID,\n\t.delba_send_cmdid = WMI_DELBA_SEND_CMDID,\n\t.addba_set_resp_cmdid = WMI_ADDBA_SET_RESP_CMDID,\n\t.send_singleamsdu_cmdid = WMI_SEND_SINGLEAMSDU_CMDID,\n\t.sta_powersave_mode_cmdid = WMI_STA_POWERSAVE_MODE_CMDID,\n\t.sta_powersave_param_cmdid = WMI_STA_POWERSAVE_PARAM_CMDID,\n\t.sta_mimo_ps_mode_cmdid = WMI_STA_MIMO_PS_MODE_CMDID,\n\t.pdev_dfs_enable_cmdid = WMI_PDEV_DFS_ENABLE_CMDID,\n\t.pdev_dfs_disable_cmdid = WMI_PDEV_DFS_DISABLE_CMDID,\n\t.roam_scan_mode = WMI_ROAM_SCAN_MODE,\n\t.roam_scan_rssi_threshold = WMI_ROAM_SCAN_RSSI_THRESHOLD,\n\t.roam_scan_period = WMI_ROAM_SCAN_PERIOD,\n\t.roam_scan_rssi_change_threshold = WMI_ROAM_SCAN_RSSI_CHANGE_THRESHOLD,\n\t.roam_ap_profile = WMI_ROAM_AP_PROFILE,\n\t.ofl_scan_add_ap_profile = WMI_ROAM_AP_PROFILE,\n\t.ofl_scan_remove_ap_profile = WMI_OFL_SCAN_REMOVE_AP_PROFILE,\n\t.ofl_scan_period = WMI_OFL_SCAN_PERIOD,\n\t.p2p_dev_set_device_info = WMI_P2P_DEV_SET_DEVICE_INFO,\n\t.p2p_dev_set_discoverability = WMI_P2P_DEV_SET_DISCOVERABILITY,\n\t.p2p_go_set_beacon_ie = WMI_P2P_GO_SET_BEACON_IE,\n\t.p2p_go_set_probe_resp_ie = WMI_P2P_GO_SET_PROBE_RESP_IE,\n\t.p2p_set_vendor_ie_data_cmdid = WMI_P2P_SET_VENDOR_IE_DATA_CMDID,\n\t.ap_ps_peer_param_cmdid = WMI_AP_PS_PEER_PARAM_CMDID,\n\t.ap_ps_peer_uapsd_coex_cmdid = WMI_AP_PS_PEER_UAPSD_COEX_CMDID,\n\t.peer_rate_retry_sched_cmdid = WMI_PEER_RATE_RETRY_SCHED_CMDID,\n\t.wlan_profile_trigger_cmdid = WMI_WLAN_PROFILE_TRIGGER_CMDID,\n\t.wlan_profile_set_hist_intvl_cmdid =\n\t\t\t\tWMI_WLAN_PROFILE_SET_HIST_INTVL_CMDID,\n\t.wlan_profile_get_profile_data_cmdid =\n\t\t\t\tWMI_WLAN_PROFILE_GET_PROFILE_DATA_CMDID,\n\t.wlan_profile_enable_profile_id_cmdid =\n\t\t\t\tWMI_WLAN_PROFILE_ENABLE_PROFILE_ID_CMDID,\n\t.wlan_profile_list_profile_id_cmdid =\n\t\t\t\tWMI_WLAN_PROFILE_LIST_PROFILE_ID_CMDID,\n\t.pdev_suspend_cmdid = WMI_PDEV_SUSPEND_CMDID,\n\t.pdev_resume_cmdid = WMI_PDEV_RESUME_CMDID,\n\t.add_bcn_filter_cmdid = WMI_ADD_BCN_FILTER_CMDID,\n\t.rmv_bcn_filter_cmdid = WMI_RMV_BCN_FILTER_CMDID,\n\t.wow_add_wake_pattern_cmdid = WMI_WOW_ADD_WAKE_PATTERN_CMDID,\n\t.wow_del_wake_pattern_cmdid = WMI_WOW_DEL_WAKE_PATTERN_CMDID,\n\t.wow_enable_disable_wake_event_cmdid =\n\t\t\t\tWMI_WOW_ENABLE_DISABLE_WAKE_EVENT_CMDID,\n\t.wow_enable_cmdid = WMI_WOW_ENABLE_CMDID,\n\t.wow_hostwakeup_from_sleep_cmdid = WMI_WOW_HOSTWAKEUP_FROM_SLEEP_CMDID,\n\t.rtt_measreq_cmdid = WMI_RTT_MEASREQ_CMDID,\n\t.rtt_tsf_cmdid = WMI_RTT_TSF_CMDID,\n\t.vdev_spectral_scan_configure_cmdid =\n\t\t\t\tWMI_VDEV_SPECTRAL_SCAN_CONFIGURE_CMDID,\n\t.vdev_spectral_scan_enable_cmdid = WMI_VDEV_SPECTRAL_SCAN_ENABLE_CMDID,\n\t.request_stats_cmdid = WMI_REQUEST_STATS_CMDID,\n\t.set_arp_ns_offload_cmdid = WMI_SET_ARP_NS_OFFLOAD_CMDID,\n\t.network_list_offload_config_cmdid =\n\t\t\t\tWMI_NETWORK_LIST_OFFLOAD_CONFIG_CMDID,\n\t.gtk_offload_cmdid = WMI_GTK_OFFLOAD_CMDID,\n\t.csa_offload_enable_cmdid = WMI_CSA_OFFLOAD_ENABLE_CMDID,\n\t.csa_offload_chanswitch_cmdid = WMI_CSA_OFFLOAD_CHANSWITCH_CMDID,\n\t.chatter_set_mode_cmdid = WMI_CHATTER_SET_MODE_CMDID,\n\t.peer_tid_addba_cmdid = WMI_PEER_TID_ADDBA_CMDID,\n\t.peer_tid_delba_cmdid = WMI_PEER_TID_DELBA_CMDID,\n\t.sta_dtim_ps_method_cmdid = WMI_STA_DTIM_PS_METHOD_CMDID,\n\t.sta_uapsd_auto_trig_cmdid = WMI_STA_UAPSD_AUTO_TRIG_CMDID,\n\t.sta_keepalive_cmd = WMI_STA_KEEPALIVE_CMD,\n\t.echo_cmdid = WMI_ECHO_CMDID,\n\t.pdev_utf_cmdid = WMI_PDEV_UTF_CMDID,\n\t.dbglog_cfg_cmdid = WMI_DBGLOG_CFG_CMDID,\n\t.pdev_qvit_cmdid = WMI_PDEV_QVIT_CMDID,\n\t.pdev_ftm_intg_cmdid = WMI_PDEV_FTM_INTG_CMDID,\n\t.vdev_set_keepalive_cmdid = WMI_VDEV_SET_KEEPALIVE_CMDID,\n\t.vdev_get_keepalive_cmdid = WMI_VDEV_GET_KEEPALIVE_CMDID,\n\t.force_fw_hang_cmdid = WMI_FORCE_FW_HANG_CMDID,\n\t.gpio_config_cmdid = WMI_GPIO_CONFIG_CMDID,\n\t.gpio_output_cmdid = WMI_GPIO_OUTPUT_CMDID,\n\t.pdev_get_temperature_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_enable_adaptive_cca_cmdid = WMI_CMD_UNSUPPORTED,\n\t.scan_update_request_cmdid = WMI_CMD_UNSUPPORTED,\n\t.vdev_standby_response_cmdid = WMI_CMD_UNSUPPORTED,\n\t.vdev_resume_response_cmdid = WMI_CMD_UNSUPPORTED,\n\t.wlan_peer_caching_add_peer_cmdid = WMI_CMD_UNSUPPORTED,\n\t.wlan_peer_caching_evict_peer_cmdid = WMI_CMD_UNSUPPORTED,\n\t.wlan_peer_caching_restore_peer_cmdid = WMI_CMD_UNSUPPORTED,\n\t.wlan_peer_caching_print_all_peers_info_cmdid = WMI_CMD_UNSUPPORTED,\n\t.peer_update_wds_entry_cmdid = WMI_CMD_UNSUPPORTED,\n\t.peer_add_proxy_sta_entry_cmdid = WMI_CMD_UNSUPPORTED,\n\t.rtt_keepalive_cmdid = WMI_CMD_UNSUPPORTED,\n\t.oem_req_cmdid = WMI_CMD_UNSUPPORTED,\n\t.nan_cmdid = WMI_CMD_UNSUPPORTED,\n\t.vdev_ratemask_cmdid = WMI_CMD_UNSUPPORTED,\n\t.qboost_cfg_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_smart_ant_enable_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_smart_ant_set_rx_antenna_cmdid = WMI_CMD_UNSUPPORTED,\n\t.peer_smart_ant_set_tx_antenna_cmdid = WMI_CMD_UNSUPPORTED,\n\t.peer_smart_ant_set_train_info_cmdid = WMI_CMD_UNSUPPORTED,\n\t.peer_smart_ant_set_node_config_ops_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_set_antenna_switch_table_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_set_ctl_table_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_set_mimogain_table_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_ratepwr_table_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_ratepwr_chainmsk_table_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_fips_cmdid = WMI_CMD_UNSUPPORTED,\n\t.tt_set_conf_cmdid = WMI_CMD_UNSUPPORTED,\n\t.fwtest_cmdid = WMI_CMD_UNSUPPORTED,\n\t.vdev_atf_request_cmdid = WMI_CMD_UNSUPPORTED,\n\t.peer_atf_request_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_get_ani_cck_config_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_get_ani_ofdm_config_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_reserve_ast_entry_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_get_nfcal_power_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_get_tpc_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_get_ast_info_cmdid = WMI_CMD_UNSUPPORTED,\n\t.vdev_set_dscp_tid_map_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_get_info_cmdid = WMI_CMD_UNSUPPORTED,\n\t.vdev_get_info_cmdid = WMI_CMD_UNSUPPORTED,\n\t.vdev_filter_neighbor_rx_packets_cmdid = WMI_CMD_UNSUPPORTED,\n\t.mu_cal_start_cmdid = WMI_CMD_UNSUPPORTED,\n\t.set_cca_params_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_bss_chan_info_request_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_get_tpc_table_cmdid = WMI_CMD_UNSUPPORTED,\n\t.radar_found_cmdid = WMI_CMD_UNSUPPORTED,\n};\n\n \nstatic struct wmi_cmd_map wmi_10x_cmd_map = {\n\t.init_cmdid = WMI_10X_INIT_CMDID,\n\t.start_scan_cmdid = WMI_10X_START_SCAN_CMDID,\n\t.stop_scan_cmdid = WMI_10X_STOP_SCAN_CMDID,\n\t.scan_chan_list_cmdid = WMI_10X_SCAN_CHAN_LIST_CMDID,\n\t.scan_sch_prio_tbl_cmdid = WMI_CMD_UNSUPPORTED,\n\t.scan_prob_req_oui_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_set_regdomain_cmdid = WMI_10X_PDEV_SET_REGDOMAIN_CMDID,\n\t.pdev_set_channel_cmdid = WMI_10X_PDEV_SET_CHANNEL_CMDID,\n\t.pdev_set_param_cmdid = WMI_10X_PDEV_SET_PARAM_CMDID,\n\t.pdev_pktlog_enable_cmdid = WMI_10X_PDEV_PKTLOG_ENABLE_CMDID,\n\t.pdev_pktlog_disable_cmdid = WMI_10X_PDEV_PKTLOG_DISABLE_CMDID,\n\t.pdev_set_wmm_params_cmdid = WMI_10X_PDEV_SET_WMM_PARAMS_CMDID,\n\t.pdev_set_ht_cap_ie_cmdid = WMI_10X_PDEV_SET_HT_CAP_IE_CMDID,\n\t.pdev_set_vht_cap_ie_cmdid = WMI_10X_PDEV_SET_VHT_CAP_IE_CMDID,\n\t.pdev_set_dscp_tid_map_cmdid = WMI_10X_PDEV_SET_DSCP_TID_MAP_CMDID,\n\t.pdev_set_quiet_mode_cmdid = WMI_10X_PDEV_SET_QUIET_MODE_CMDID,\n\t.pdev_green_ap_ps_enable_cmdid = WMI_10X_PDEV_GREEN_AP_PS_ENABLE_CMDID,\n\t.pdev_get_tpc_config_cmdid = WMI_10X_PDEV_GET_TPC_CONFIG_CMDID,\n\t.pdev_set_base_macaddr_cmdid = WMI_10X_PDEV_SET_BASE_MACADDR_CMDID,\n\t.vdev_create_cmdid = WMI_10X_VDEV_CREATE_CMDID,\n\t.vdev_delete_cmdid = WMI_10X_VDEV_DELETE_CMDID,\n\t.vdev_start_request_cmdid = WMI_10X_VDEV_START_REQUEST_CMDID,\n\t.vdev_restart_request_cmdid = WMI_10X_VDEV_RESTART_REQUEST_CMDID,\n\t.vdev_up_cmdid = WMI_10X_VDEV_UP_CMDID,\n\t.vdev_stop_cmdid = WMI_10X_VDEV_STOP_CMDID,\n\t.vdev_down_cmdid = WMI_10X_VDEV_DOWN_CMDID,\n\t.vdev_set_param_cmdid = WMI_10X_VDEV_SET_PARAM_CMDID,\n\t.vdev_install_key_cmdid = WMI_10X_VDEV_INSTALL_KEY_CMDID,\n\t.peer_create_cmdid = WMI_10X_PEER_CREATE_CMDID,\n\t.peer_delete_cmdid = WMI_10X_PEER_DELETE_CMDID,\n\t.peer_flush_tids_cmdid = WMI_10X_PEER_FLUSH_TIDS_CMDID,\n\t.peer_set_param_cmdid = WMI_10X_PEER_SET_PARAM_CMDID,\n\t.peer_assoc_cmdid = WMI_10X_PEER_ASSOC_CMDID,\n\t.peer_add_wds_entry_cmdid = WMI_10X_PEER_ADD_WDS_ENTRY_CMDID,\n\t.peer_remove_wds_entry_cmdid = WMI_10X_PEER_REMOVE_WDS_ENTRY_CMDID,\n\t.peer_mcast_group_cmdid = WMI_10X_PEER_MCAST_GROUP_CMDID,\n\t.bcn_tx_cmdid = WMI_10X_BCN_TX_CMDID,\n\t.pdev_send_bcn_cmdid = WMI_10X_PDEV_SEND_BCN_CMDID,\n\t.bcn_tmpl_cmdid = WMI_CMD_UNSUPPORTED,\n\t.bcn_filter_rx_cmdid = WMI_10X_BCN_FILTER_RX_CMDID,\n\t.prb_req_filter_rx_cmdid = WMI_10X_PRB_REQ_FILTER_RX_CMDID,\n\t.mgmt_tx_cmdid = WMI_10X_MGMT_TX_CMDID,\n\t.prb_tmpl_cmdid = WMI_CMD_UNSUPPORTED,\n\t.addba_clear_resp_cmdid = WMI_10X_ADDBA_CLEAR_RESP_CMDID,\n\t.addba_send_cmdid = WMI_10X_ADDBA_SEND_CMDID,\n\t.addba_status_cmdid = WMI_10X_ADDBA_STATUS_CMDID,\n\t.delba_send_cmdid = WMI_10X_DELBA_SEND_CMDID,\n\t.addba_set_resp_cmdid = WMI_10X_ADDBA_SET_RESP_CMDID,\n\t.send_singleamsdu_cmdid = WMI_10X_SEND_SINGLEAMSDU_CMDID,\n\t.sta_powersave_mode_cmdid = WMI_10X_STA_POWERSAVE_MODE_CMDID,\n\t.sta_powersave_param_cmdid = WMI_10X_STA_POWERSAVE_PARAM_CMDID,\n\t.sta_mimo_ps_mode_cmdid = WMI_10X_STA_MIMO_PS_MODE_CMDID,\n\t.pdev_dfs_enable_cmdid = WMI_10X_PDEV_DFS_ENABLE_CMDID,\n\t.pdev_dfs_disable_cmdid = WMI_10X_PDEV_DFS_DISABLE_CMDID,\n\t.roam_scan_mode = WMI_10X_ROAM_SCAN_MODE,\n\t.roam_scan_rssi_threshold = WMI_10X_ROAM_SCAN_RSSI_THRESHOLD,\n\t.roam_scan_period = WMI_10X_ROAM_SCAN_PERIOD,\n\t.roam_scan_rssi_change_threshold =\n\t\t\t\tWMI_10X_ROAM_SCAN_RSSI_CHANGE_THRESHOLD,\n\t.roam_ap_profile = WMI_10X_ROAM_AP_PROFILE,\n\t.ofl_scan_add_ap_profile = WMI_10X_OFL_SCAN_ADD_AP_PROFILE,\n\t.ofl_scan_remove_ap_profile = WMI_10X_OFL_SCAN_REMOVE_AP_PROFILE,\n\t.ofl_scan_period = WMI_10X_OFL_SCAN_PERIOD,\n\t.p2p_dev_set_device_info = WMI_10X_P2P_DEV_SET_DEVICE_INFO,\n\t.p2p_dev_set_discoverability = WMI_10X_P2P_DEV_SET_DISCOVERABILITY,\n\t.p2p_go_set_beacon_ie = WMI_10X_P2P_GO_SET_BEACON_IE,\n\t.p2p_go_set_probe_resp_ie = WMI_10X_P2P_GO_SET_PROBE_RESP_IE,\n\t.p2p_set_vendor_ie_data_cmdid = WMI_CMD_UNSUPPORTED,\n\t.ap_ps_peer_param_cmdid = WMI_10X_AP_PS_PEER_PARAM_CMDID,\n\t.ap_ps_peer_uapsd_coex_cmdid = WMI_CMD_UNSUPPORTED,\n\t.peer_rate_retry_sched_cmdid = WMI_10X_PEER_RATE_RETRY_SCHED_CMDID,\n\t.wlan_profile_trigger_cmdid = WMI_10X_WLAN_PROFILE_TRIGGER_CMDID,\n\t.wlan_profile_set_hist_intvl_cmdid =\n\t\t\t\tWMI_10X_WLAN_PROFILE_SET_HIST_INTVL_CMDID,\n\t.wlan_profile_get_profile_data_cmdid =\n\t\t\t\tWMI_10X_WLAN_PROFILE_GET_PROFILE_DATA_CMDID,\n\t.wlan_profile_enable_profile_id_cmdid =\n\t\t\t\tWMI_10X_WLAN_PROFILE_ENABLE_PROFILE_ID_CMDID,\n\t.wlan_profile_list_profile_id_cmdid =\n\t\t\t\tWMI_10X_WLAN_PROFILE_LIST_PROFILE_ID_CMDID,\n\t.pdev_suspend_cmdid = WMI_10X_PDEV_SUSPEND_CMDID,\n\t.pdev_resume_cmdid = WMI_10X_PDEV_RESUME_CMDID,\n\t.add_bcn_filter_cmdid = WMI_10X_ADD_BCN_FILTER_CMDID,\n\t.rmv_bcn_filter_cmdid = WMI_10X_RMV_BCN_FILTER_CMDID,\n\t.wow_add_wake_pattern_cmdid = WMI_10X_WOW_ADD_WAKE_PATTERN_CMDID,\n\t.wow_del_wake_pattern_cmdid = WMI_10X_WOW_DEL_WAKE_PATTERN_CMDID,\n\t.wow_enable_disable_wake_event_cmdid =\n\t\t\t\tWMI_10X_WOW_ENABLE_DISABLE_WAKE_EVENT_CMDID,\n\t.wow_enable_cmdid = WMI_10X_WOW_ENABLE_CMDID,\n\t.wow_hostwakeup_from_sleep_cmdid =\n\t\t\t\tWMI_10X_WOW_HOSTWAKEUP_FROM_SLEEP_CMDID,\n\t.rtt_measreq_cmdid = WMI_10X_RTT_MEASREQ_CMDID,\n\t.rtt_tsf_cmdid = WMI_10X_RTT_TSF_CMDID,\n\t.vdev_spectral_scan_configure_cmdid =\n\t\t\t\tWMI_10X_VDEV_SPECTRAL_SCAN_CONFIGURE_CMDID,\n\t.vdev_spectral_scan_enable_cmdid =\n\t\t\t\tWMI_10X_VDEV_SPECTRAL_SCAN_ENABLE_CMDID,\n\t.request_stats_cmdid = WMI_10X_REQUEST_STATS_CMDID,\n\t.set_arp_ns_offload_cmdid = WMI_CMD_UNSUPPORTED,\n\t.network_list_offload_config_cmdid = WMI_CMD_UNSUPPORTED,\n\t.gtk_offload_cmdid = WMI_CMD_UNSUPPORTED,\n\t.csa_offload_enable_cmdid = WMI_CMD_UNSUPPORTED,\n\t.csa_offload_chanswitch_cmdid = WMI_CMD_UNSUPPORTED,\n\t.chatter_set_mode_cmdid = WMI_CMD_UNSUPPORTED,\n\t.peer_tid_addba_cmdid = WMI_CMD_UNSUPPORTED,\n\t.peer_tid_delba_cmdid = WMI_CMD_UNSUPPORTED,\n\t.sta_dtim_ps_method_cmdid = WMI_CMD_UNSUPPORTED,\n\t.sta_uapsd_auto_trig_cmdid = WMI_CMD_UNSUPPORTED,\n\t.sta_keepalive_cmd = WMI_CMD_UNSUPPORTED,\n\t.echo_cmdid = WMI_10X_ECHO_CMDID,\n\t.pdev_utf_cmdid = WMI_10X_PDEV_UTF_CMDID,\n\t.dbglog_cfg_cmdid = WMI_10X_DBGLOG_CFG_CMDID,\n\t.pdev_qvit_cmdid = WMI_10X_PDEV_QVIT_CMDID,\n\t.pdev_ftm_intg_cmdid = WMI_CMD_UNSUPPORTED,\n\t.vdev_set_keepalive_cmdid = WMI_CMD_UNSUPPORTED,\n\t.vdev_get_keepalive_cmdid = WMI_CMD_UNSUPPORTED,\n\t.force_fw_hang_cmdid = WMI_CMD_UNSUPPORTED,\n\t.gpio_config_cmdid = WMI_10X_GPIO_CONFIG_CMDID,\n\t.gpio_output_cmdid = WMI_10X_GPIO_OUTPUT_CMDID,\n\t.pdev_get_temperature_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_enable_adaptive_cca_cmdid = WMI_CMD_UNSUPPORTED,\n\t.scan_update_request_cmdid = WMI_CMD_UNSUPPORTED,\n\t.vdev_standby_response_cmdid = WMI_CMD_UNSUPPORTED,\n\t.vdev_resume_response_cmdid = WMI_CMD_UNSUPPORTED,\n\t.wlan_peer_caching_add_peer_cmdid = WMI_CMD_UNSUPPORTED,\n\t.wlan_peer_caching_evict_peer_cmdid = WMI_CMD_UNSUPPORTED,\n\t.wlan_peer_caching_restore_peer_cmdid = WMI_CMD_UNSUPPORTED,\n\t.wlan_peer_caching_print_all_peers_info_cmdid = WMI_CMD_UNSUPPORTED,\n\t.peer_update_wds_entry_cmdid = WMI_CMD_UNSUPPORTED,\n\t.peer_add_proxy_sta_entry_cmdid = WMI_CMD_UNSUPPORTED,\n\t.rtt_keepalive_cmdid = WMI_CMD_UNSUPPORTED,\n\t.oem_req_cmdid = WMI_CMD_UNSUPPORTED,\n\t.nan_cmdid = WMI_CMD_UNSUPPORTED,\n\t.vdev_ratemask_cmdid = WMI_CMD_UNSUPPORTED,\n\t.qboost_cfg_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_smart_ant_enable_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_smart_ant_set_rx_antenna_cmdid = WMI_CMD_UNSUPPORTED,\n\t.peer_smart_ant_set_tx_antenna_cmdid = WMI_CMD_UNSUPPORTED,\n\t.peer_smart_ant_set_train_info_cmdid = WMI_CMD_UNSUPPORTED,\n\t.peer_smart_ant_set_node_config_ops_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_set_antenna_switch_table_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_set_ctl_table_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_set_mimogain_table_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_ratepwr_table_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_ratepwr_chainmsk_table_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_fips_cmdid = WMI_CMD_UNSUPPORTED,\n\t.tt_set_conf_cmdid = WMI_CMD_UNSUPPORTED,\n\t.fwtest_cmdid = WMI_CMD_UNSUPPORTED,\n\t.vdev_atf_request_cmdid = WMI_CMD_UNSUPPORTED,\n\t.peer_atf_request_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_get_ani_cck_config_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_get_ani_ofdm_config_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_reserve_ast_entry_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_get_nfcal_power_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_get_tpc_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_get_ast_info_cmdid = WMI_CMD_UNSUPPORTED,\n\t.vdev_set_dscp_tid_map_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_get_info_cmdid = WMI_CMD_UNSUPPORTED,\n\t.vdev_get_info_cmdid = WMI_CMD_UNSUPPORTED,\n\t.vdev_filter_neighbor_rx_packets_cmdid = WMI_CMD_UNSUPPORTED,\n\t.mu_cal_start_cmdid = WMI_CMD_UNSUPPORTED,\n\t.set_cca_params_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_bss_chan_info_request_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_get_tpc_table_cmdid = WMI_CMD_UNSUPPORTED,\n\t.radar_found_cmdid = WMI_CMD_UNSUPPORTED,\n};\n\n \nstatic struct wmi_cmd_map wmi_10_2_4_cmd_map = {\n\t.init_cmdid = WMI_10_2_INIT_CMDID,\n\t.start_scan_cmdid = WMI_10_2_START_SCAN_CMDID,\n\t.stop_scan_cmdid = WMI_10_2_STOP_SCAN_CMDID,\n\t.scan_chan_list_cmdid = WMI_10_2_SCAN_CHAN_LIST_CMDID,\n\t.scan_sch_prio_tbl_cmdid = WMI_CMD_UNSUPPORTED,\n\t.scan_prob_req_oui_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_set_regdomain_cmdid = WMI_10_2_PDEV_SET_REGDOMAIN_CMDID,\n\t.pdev_set_channel_cmdid = WMI_10_2_PDEV_SET_CHANNEL_CMDID,\n\t.pdev_set_param_cmdid = WMI_10_2_PDEV_SET_PARAM_CMDID,\n\t.pdev_pktlog_enable_cmdid = WMI_10_2_PDEV_PKTLOG_ENABLE_CMDID,\n\t.pdev_pktlog_disable_cmdid = WMI_10_2_PDEV_PKTLOG_DISABLE_CMDID,\n\t.pdev_set_wmm_params_cmdid = WMI_10_2_PDEV_SET_WMM_PARAMS_CMDID,\n\t.pdev_set_ht_cap_ie_cmdid = WMI_10_2_PDEV_SET_HT_CAP_IE_CMDID,\n\t.pdev_set_vht_cap_ie_cmdid = WMI_10_2_PDEV_SET_VHT_CAP_IE_CMDID,\n\t.pdev_set_quiet_mode_cmdid = WMI_10_2_PDEV_SET_QUIET_MODE_CMDID,\n\t.pdev_green_ap_ps_enable_cmdid = WMI_10_2_PDEV_GREEN_AP_PS_ENABLE_CMDID,\n\t.pdev_get_tpc_config_cmdid = WMI_10_2_PDEV_GET_TPC_CONFIG_CMDID,\n\t.pdev_set_base_macaddr_cmdid = WMI_10_2_PDEV_SET_BASE_MACADDR_CMDID,\n\t.vdev_create_cmdid = WMI_10_2_VDEV_CREATE_CMDID,\n\t.vdev_delete_cmdid = WMI_10_2_VDEV_DELETE_CMDID,\n\t.vdev_start_request_cmdid = WMI_10_2_VDEV_START_REQUEST_CMDID,\n\t.vdev_restart_request_cmdid = WMI_10_2_VDEV_RESTART_REQUEST_CMDID,\n\t.vdev_up_cmdid = WMI_10_2_VDEV_UP_CMDID,\n\t.vdev_stop_cmdid = WMI_10_2_VDEV_STOP_CMDID,\n\t.vdev_down_cmdid = WMI_10_2_VDEV_DOWN_CMDID,\n\t.vdev_set_param_cmdid = WMI_10_2_VDEV_SET_PARAM_CMDID,\n\t.vdev_install_key_cmdid = WMI_10_2_VDEV_INSTALL_KEY_CMDID,\n\t.peer_create_cmdid = WMI_10_2_PEER_CREATE_CMDID,\n\t.peer_delete_cmdid = WMI_10_2_PEER_DELETE_CMDID,\n\t.peer_flush_tids_cmdid = WMI_10_2_PEER_FLUSH_TIDS_CMDID,\n\t.peer_set_param_cmdid = WMI_10_2_PEER_SET_PARAM_CMDID,\n\t.peer_assoc_cmdid = WMI_10_2_PEER_ASSOC_CMDID,\n\t.peer_add_wds_entry_cmdid = WMI_10_2_PEER_ADD_WDS_ENTRY_CMDID,\n\t.peer_remove_wds_entry_cmdid = WMI_10_2_PEER_REMOVE_WDS_ENTRY_CMDID,\n\t.peer_mcast_group_cmdid = WMI_10_2_PEER_MCAST_GROUP_CMDID,\n\t.bcn_tx_cmdid = WMI_10_2_BCN_TX_CMDID,\n\t.pdev_send_bcn_cmdid = WMI_10_2_PDEV_SEND_BCN_CMDID,\n\t.bcn_tmpl_cmdid = WMI_CMD_UNSUPPORTED,\n\t.bcn_filter_rx_cmdid = WMI_10_2_BCN_FILTER_RX_CMDID,\n\t.prb_req_filter_rx_cmdid = WMI_10_2_PRB_REQ_FILTER_RX_CMDID,\n\t.mgmt_tx_cmdid = WMI_10_2_MGMT_TX_CMDID,\n\t.prb_tmpl_cmdid = WMI_CMD_UNSUPPORTED,\n\t.addba_clear_resp_cmdid = WMI_10_2_ADDBA_CLEAR_RESP_CMDID,\n\t.addba_send_cmdid = WMI_10_2_ADDBA_SEND_CMDID,\n\t.addba_status_cmdid = WMI_10_2_ADDBA_STATUS_CMDID,\n\t.delba_send_cmdid = WMI_10_2_DELBA_SEND_CMDID,\n\t.addba_set_resp_cmdid = WMI_10_2_ADDBA_SET_RESP_CMDID,\n\t.send_singleamsdu_cmdid = WMI_10_2_SEND_SINGLEAMSDU_CMDID,\n\t.sta_powersave_mode_cmdid = WMI_10_2_STA_POWERSAVE_MODE_CMDID,\n\t.sta_powersave_param_cmdid = WMI_10_2_STA_POWERSAVE_PARAM_CMDID,\n\t.sta_mimo_ps_mode_cmdid = WMI_10_2_STA_MIMO_PS_MODE_CMDID,\n\t.pdev_dfs_enable_cmdid = WMI_10_2_PDEV_DFS_ENABLE_CMDID,\n\t.pdev_dfs_disable_cmdid = WMI_10_2_PDEV_DFS_DISABLE_CMDID,\n\t.roam_scan_mode = WMI_10_2_ROAM_SCAN_MODE,\n\t.roam_scan_rssi_threshold = WMI_10_2_ROAM_SCAN_RSSI_THRESHOLD,\n\t.roam_scan_period = WMI_10_2_ROAM_SCAN_PERIOD,\n\t.roam_scan_rssi_change_threshold =\n\t\t\t\tWMI_10_2_ROAM_SCAN_RSSI_CHANGE_THRESHOLD,\n\t.roam_ap_profile = WMI_10_2_ROAM_AP_PROFILE,\n\t.ofl_scan_add_ap_profile = WMI_10_2_OFL_SCAN_ADD_AP_PROFILE,\n\t.ofl_scan_remove_ap_profile = WMI_10_2_OFL_SCAN_REMOVE_AP_PROFILE,\n\t.ofl_scan_period = WMI_10_2_OFL_SCAN_PERIOD,\n\t.p2p_dev_set_device_info = WMI_10_2_P2P_DEV_SET_DEVICE_INFO,\n\t.p2p_dev_set_discoverability = WMI_10_2_P2P_DEV_SET_DISCOVERABILITY,\n\t.p2p_go_set_beacon_ie = WMI_10_2_P2P_GO_SET_BEACON_IE,\n\t.p2p_go_set_probe_resp_ie = WMI_10_2_P2P_GO_SET_PROBE_RESP_IE,\n\t.p2p_set_vendor_ie_data_cmdid = WMI_CMD_UNSUPPORTED,\n\t.ap_ps_peer_param_cmdid = WMI_10_2_AP_PS_PEER_PARAM_CMDID,\n\t.ap_ps_peer_uapsd_coex_cmdid = WMI_CMD_UNSUPPORTED,\n\t.peer_rate_retry_sched_cmdid = WMI_10_2_PEER_RATE_RETRY_SCHED_CMDID,\n\t.wlan_profile_trigger_cmdid = WMI_10_2_WLAN_PROFILE_TRIGGER_CMDID,\n\t.wlan_profile_set_hist_intvl_cmdid =\n\t\t\t\tWMI_10_2_WLAN_PROFILE_SET_HIST_INTVL_CMDID,\n\t.wlan_profile_get_profile_data_cmdid =\n\t\t\t\tWMI_10_2_WLAN_PROFILE_GET_PROFILE_DATA_CMDID,\n\t.wlan_profile_enable_profile_id_cmdid =\n\t\t\t\tWMI_10_2_WLAN_PROFILE_ENABLE_PROFILE_ID_CMDID,\n\t.wlan_profile_list_profile_id_cmdid =\n\t\t\t\tWMI_10_2_WLAN_PROFILE_LIST_PROFILE_ID_CMDID,\n\t.pdev_suspend_cmdid = WMI_10_2_PDEV_SUSPEND_CMDID,\n\t.pdev_resume_cmdid = WMI_10_2_PDEV_RESUME_CMDID,\n\t.add_bcn_filter_cmdid = WMI_10_2_ADD_BCN_FILTER_CMDID,\n\t.rmv_bcn_filter_cmdid = WMI_10_2_RMV_BCN_FILTER_CMDID,\n\t.wow_add_wake_pattern_cmdid = WMI_10_2_WOW_ADD_WAKE_PATTERN_CMDID,\n\t.wow_del_wake_pattern_cmdid = WMI_10_2_WOW_DEL_WAKE_PATTERN_CMDID,\n\t.wow_enable_disable_wake_event_cmdid =\n\t\t\t\tWMI_10_2_WOW_ENABLE_DISABLE_WAKE_EVENT_CMDID,\n\t.wow_enable_cmdid = WMI_10_2_WOW_ENABLE_CMDID,\n\t.wow_hostwakeup_from_sleep_cmdid =\n\t\t\t\tWMI_10_2_WOW_HOSTWAKEUP_FROM_SLEEP_CMDID,\n\t.rtt_measreq_cmdid = WMI_10_2_RTT_MEASREQ_CMDID,\n\t.rtt_tsf_cmdid = WMI_10_2_RTT_TSF_CMDID,\n\t.vdev_spectral_scan_configure_cmdid =\n\t\t\t\tWMI_10_2_VDEV_SPECTRAL_SCAN_CONFIGURE_CMDID,\n\t.vdev_spectral_scan_enable_cmdid =\n\t\t\t\tWMI_10_2_VDEV_SPECTRAL_SCAN_ENABLE_CMDID,\n\t.request_stats_cmdid = WMI_10_2_REQUEST_STATS_CMDID,\n\t.set_arp_ns_offload_cmdid = WMI_CMD_UNSUPPORTED,\n\t.network_list_offload_config_cmdid = WMI_CMD_UNSUPPORTED,\n\t.gtk_offload_cmdid = WMI_CMD_UNSUPPORTED,\n\t.csa_offload_enable_cmdid = WMI_CMD_UNSUPPORTED,\n\t.csa_offload_chanswitch_cmdid = WMI_CMD_UNSUPPORTED,\n\t.chatter_set_mode_cmdid = WMI_CMD_UNSUPPORTED,\n\t.peer_tid_addba_cmdid = WMI_CMD_UNSUPPORTED,\n\t.peer_tid_delba_cmdid = WMI_CMD_UNSUPPORTED,\n\t.sta_dtim_ps_method_cmdid = WMI_CMD_UNSUPPORTED,\n\t.sta_uapsd_auto_trig_cmdid = WMI_CMD_UNSUPPORTED,\n\t.sta_keepalive_cmd = WMI_CMD_UNSUPPORTED,\n\t.echo_cmdid = WMI_10_2_ECHO_CMDID,\n\t.pdev_utf_cmdid = WMI_10_2_PDEV_UTF_CMDID,\n\t.dbglog_cfg_cmdid = WMI_10_2_DBGLOG_CFG_CMDID,\n\t.pdev_qvit_cmdid = WMI_10_2_PDEV_QVIT_CMDID,\n\t.pdev_ftm_intg_cmdid = WMI_CMD_UNSUPPORTED,\n\t.vdev_set_keepalive_cmdid = WMI_CMD_UNSUPPORTED,\n\t.vdev_get_keepalive_cmdid = WMI_CMD_UNSUPPORTED,\n\t.force_fw_hang_cmdid = WMI_CMD_UNSUPPORTED,\n\t.gpio_config_cmdid = WMI_10_2_GPIO_CONFIG_CMDID,\n\t.gpio_output_cmdid = WMI_10_2_GPIO_OUTPUT_CMDID,\n\t.pdev_get_temperature_cmdid = WMI_10_2_PDEV_GET_TEMPERATURE_CMDID,\n\t.pdev_enable_adaptive_cca_cmdid = WMI_10_2_SET_CCA_PARAMS,\n\t.scan_update_request_cmdid = WMI_CMD_UNSUPPORTED,\n\t.vdev_standby_response_cmdid = WMI_CMD_UNSUPPORTED,\n\t.vdev_resume_response_cmdid = WMI_CMD_UNSUPPORTED,\n\t.wlan_peer_caching_add_peer_cmdid = WMI_CMD_UNSUPPORTED,\n\t.wlan_peer_caching_evict_peer_cmdid = WMI_CMD_UNSUPPORTED,\n\t.wlan_peer_caching_restore_peer_cmdid = WMI_CMD_UNSUPPORTED,\n\t.wlan_peer_caching_print_all_peers_info_cmdid = WMI_CMD_UNSUPPORTED,\n\t.peer_update_wds_entry_cmdid = WMI_CMD_UNSUPPORTED,\n\t.peer_add_proxy_sta_entry_cmdid = WMI_CMD_UNSUPPORTED,\n\t.rtt_keepalive_cmdid = WMI_CMD_UNSUPPORTED,\n\t.oem_req_cmdid = WMI_CMD_UNSUPPORTED,\n\t.nan_cmdid = WMI_CMD_UNSUPPORTED,\n\t.vdev_ratemask_cmdid = WMI_CMD_UNSUPPORTED,\n\t.qboost_cfg_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_smart_ant_enable_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_smart_ant_set_rx_antenna_cmdid = WMI_CMD_UNSUPPORTED,\n\t.peer_smart_ant_set_tx_antenna_cmdid = WMI_CMD_UNSUPPORTED,\n\t.peer_smart_ant_set_train_info_cmdid = WMI_CMD_UNSUPPORTED,\n\t.peer_smart_ant_set_node_config_ops_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_set_antenna_switch_table_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_set_ctl_table_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_set_mimogain_table_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_ratepwr_table_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_ratepwr_chainmsk_table_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_fips_cmdid = WMI_CMD_UNSUPPORTED,\n\t.tt_set_conf_cmdid = WMI_CMD_UNSUPPORTED,\n\t.fwtest_cmdid = WMI_CMD_UNSUPPORTED,\n\t.vdev_atf_request_cmdid = WMI_CMD_UNSUPPORTED,\n\t.peer_atf_request_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_get_ani_cck_config_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_get_ani_ofdm_config_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_reserve_ast_entry_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_get_nfcal_power_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_get_tpc_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_get_ast_info_cmdid = WMI_CMD_UNSUPPORTED,\n\t.vdev_set_dscp_tid_map_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_get_info_cmdid = WMI_CMD_UNSUPPORTED,\n\t.vdev_get_info_cmdid = WMI_CMD_UNSUPPORTED,\n\t.vdev_filter_neighbor_rx_packets_cmdid = WMI_CMD_UNSUPPORTED,\n\t.mu_cal_start_cmdid = WMI_CMD_UNSUPPORTED,\n\t.set_cca_params_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_bss_chan_info_request_cmdid =\n\t\tWMI_10_2_PDEV_BSS_CHAN_INFO_REQUEST_CMDID,\n\t.pdev_get_tpc_table_cmdid = WMI_CMD_UNSUPPORTED,\n\t.radar_found_cmdid = WMI_CMD_UNSUPPORTED,\n\t.set_bb_timing_cmdid = WMI_10_2_PDEV_SET_BB_TIMING_CONFIG_CMDID,\n};\n\n \nstatic struct wmi_cmd_map wmi_10_4_cmd_map = {\n\t.init_cmdid = WMI_10_4_INIT_CMDID,\n\t.start_scan_cmdid = WMI_10_4_START_SCAN_CMDID,\n\t.stop_scan_cmdid = WMI_10_4_STOP_SCAN_CMDID,\n\t.scan_chan_list_cmdid = WMI_10_4_SCAN_CHAN_LIST_CMDID,\n\t.scan_sch_prio_tbl_cmdid = WMI_10_4_SCAN_SCH_PRIO_TBL_CMDID,\n\t.scan_prob_req_oui_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_set_regdomain_cmdid = WMI_10_4_PDEV_SET_REGDOMAIN_CMDID,\n\t.pdev_set_channel_cmdid = WMI_10_4_PDEV_SET_CHANNEL_CMDID,\n\t.pdev_set_param_cmdid = WMI_10_4_PDEV_SET_PARAM_CMDID,\n\t.pdev_pktlog_enable_cmdid = WMI_10_4_PDEV_PKTLOG_ENABLE_CMDID,\n\t.pdev_pktlog_disable_cmdid = WMI_10_4_PDEV_PKTLOG_DISABLE_CMDID,\n\t.pdev_set_wmm_params_cmdid = WMI_10_4_PDEV_SET_WMM_PARAMS_CMDID,\n\t.pdev_set_ht_cap_ie_cmdid = WMI_10_4_PDEV_SET_HT_CAP_IE_CMDID,\n\t.pdev_set_vht_cap_ie_cmdid = WMI_10_4_PDEV_SET_VHT_CAP_IE_CMDID,\n\t.pdev_set_dscp_tid_map_cmdid = WMI_10_4_PDEV_SET_DSCP_TID_MAP_CMDID,\n\t.pdev_set_quiet_mode_cmdid = WMI_10_4_PDEV_SET_QUIET_MODE_CMDID,\n\t.pdev_green_ap_ps_enable_cmdid = WMI_10_4_PDEV_GREEN_AP_PS_ENABLE_CMDID,\n\t.pdev_get_tpc_config_cmdid = WMI_10_4_PDEV_GET_TPC_CONFIG_CMDID,\n\t.pdev_set_base_macaddr_cmdid = WMI_10_4_PDEV_SET_BASE_MACADDR_CMDID,\n\t.vdev_create_cmdid = WMI_10_4_VDEV_CREATE_CMDID,\n\t.vdev_delete_cmdid = WMI_10_4_VDEV_DELETE_CMDID,\n\t.vdev_start_request_cmdid = WMI_10_4_VDEV_START_REQUEST_CMDID,\n\t.vdev_restart_request_cmdid = WMI_10_4_VDEV_RESTART_REQUEST_CMDID,\n\t.vdev_up_cmdid = WMI_10_4_VDEV_UP_CMDID,\n\t.vdev_stop_cmdid = WMI_10_4_VDEV_STOP_CMDID,\n\t.vdev_down_cmdid = WMI_10_4_VDEV_DOWN_CMDID,\n\t.vdev_set_param_cmdid = WMI_10_4_VDEV_SET_PARAM_CMDID,\n\t.vdev_install_key_cmdid = WMI_10_4_VDEV_INSTALL_KEY_CMDID,\n\t.peer_create_cmdid = WMI_10_4_PEER_CREATE_CMDID,\n\t.peer_delete_cmdid = WMI_10_4_PEER_DELETE_CMDID,\n\t.peer_flush_tids_cmdid = WMI_10_4_PEER_FLUSH_TIDS_CMDID,\n\t.peer_set_param_cmdid = WMI_10_4_PEER_SET_PARAM_CMDID,\n\t.peer_assoc_cmdid = WMI_10_4_PEER_ASSOC_CMDID,\n\t.peer_add_wds_entry_cmdid = WMI_10_4_PEER_ADD_WDS_ENTRY_CMDID,\n\t.peer_remove_wds_entry_cmdid = WMI_10_4_PEER_REMOVE_WDS_ENTRY_CMDID,\n\t.peer_mcast_group_cmdid = WMI_10_4_PEER_MCAST_GROUP_CMDID,\n\t.bcn_tx_cmdid = WMI_10_4_BCN_TX_CMDID,\n\t.pdev_send_bcn_cmdid = WMI_10_4_PDEV_SEND_BCN_CMDID,\n\t.bcn_tmpl_cmdid = WMI_10_4_BCN_PRB_TMPL_CMDID,\n\t.bcn_filter_rx_cmdid = WMI_10_4_BCN_FILTER_RX_CMDID,\n\t.prb_req_filter_rx_cmdid = WMI_10_4_PRB_REQ_FILTER_RX_CMDID,\n\t.mgmt_tx_cmdid = WMI_10_4_MGMT_TX_CMDID,\n\t.prb_tmpl_cmdid = WMI_10_4_PRB_TMPL_CMDID,\n\t.addba_clear_resp_cmdid = WMI_10_4_ADDBA_CLEAR_RESP_CMDID,\n\t.addba_send_cmdid = WMI_10_4_ADDBA_SEND_CMDID,\n\t.addba_status_cmdid = WMI_10_4_ADDBA_STATUS_CMDID,\n\t.delba_send_cmdid = WMI_10_4_DELBA_SEND_CMDID,\n\t.addba_set_resp_cmdid = WMI_10_4_ADDBA_SET_RESP_CMDID,\n\t.send_singleamsdu_cmdid = WMI_10_4_SEND_SINGLEAMSDU_CMDID,\n\t.sta_powersave_mode_cmdid = WMI_10_4_STA_POWERSAVE_MODE_CMDID,\n\t.sta_powersave_param_cmdid = WMI_10_4_STA_POWERSAVE_PARAM_CMDID,\n\t.sta_mimo_ps_mode_cmdid = WMI_10_4_STA_MIMO_PS_MODE_CMDID,\n\t.pdev_dfs_enable_cmdid = WMI_10_4_PDEV_DFS_ENABLE_CMDID,\n\t.pdev_dfs_disable_cmdid = WMI_10_4_PDEV_DFS_DISABLE_CMDID,\n\t.roam_scan_mode = WMI_10_4_ROAM_SCAN_MODE,\n\t.roam_scan_rssi_threshold = WMI_10_4_ROAM_SCAN_RSSI_THRESHOLD,\n\t.roam_scan_period = WMI_10_4_ROAM_SCAN_PERIOD,\n\t.roam_scan_rssi_change_threshold =\n\t\t\t\tWMI_10_4_ROAM_SCAN_RSSI_CHANGE_THRESHOLD,\n\t.roam_ap_profile = WMI_10_4_ROAM_AP_PROFILE,\n\t.ofl_scan_add_ap_profile = WMI_10_4_OFL_SCAN_ADD_AP_PROFILE,\n\t.ofl_scan_remove_ap_profile = WMI_10_4_OFL_SCAN_REMOVE_AP_PROFILE,\n\t.ofl_scan_period = WMI_10_4_OFL_SCAN_PERIOD,\n\t.p2p_dev_set_device_info = WMI_10_4_P2P_DEV_SET_DEVICE_INFO,\n\t.p2p_dev_set_discoverability = WMI_10_4_P2P_DEV_SET_DISCOVERABILITY,\n\t.p2p_go_set_beacon_ie = WMI_10_4_P2P_GO_SET_BEACON_IE,\n\t.p2p_go_set_probe_resp_ie = WMI_10_4_P2P_GO_SET_PROBE_RESP_IE,\n\t.p2p_set_vendor_ie_data_cmdid = WMI_10_4_P2P_SET_VENDOR_IE_DATA_CMDID,\n\t.ap_ps_peer_param_cmdid = WMI_10_4_AP_PS_PEER_PARAM_CMDID,\n\t.ap_ps_peer_uapsd_coex_cmdid = WMI_10_4_AP_PS_PEER_UAPSD_COEX_CMDID,\n\t.peer_rate_retry_sched_cmdid = WMI_10_4_PEER_RATE_RETRY_SCHED_CMDID,\n\t.wlan_profile_trigger_cmdid = WMI_10_4_WLAN_PROFILE_TRIGGER_CMDID,\n\t.wlan_profile_set_hist_intvl_cmdid =\n\t\t\t\tWMI_10_4_WLAN_PROFILE_SET_HIST_INTVL_CMDID,\n\t.wlan_profile_get_profile_data_cmdid =\n\t\t\t\tWMI_10_4_WLAN_PROFILE_GET_PROFILE_DATA_CMDID,\n\t.wlan_profile_enable_profile_id_cmdid =\n\t\t\t\tWMI_10_4_WLAN_PROFILE_ENABLE_PROFILE_ID_CMDID,\n\t.wlan_profile_list_profile_id_cmdid =\n\t\t\t\tWMI_10_4_WLAN_PROFILE_LIST_PROFILE_ID_CMDID,\n\t.pdev_suspend_cmdid = WMI_10_4_PDEV_SUSPEND_CMDID,\n\t.pdev_resume_cmdid = WMI_10_4_PDEV_RESUME_CMDID,\n\t.add_bcn_filter_cmdid = WMI_10_4_ADD_BCN_FILTER_CMDID,\n\t.rmv_bcn_filter_cmdid = WMI_10_4_RMV_BCN_FILTER_CMDID,\n\t.wow_add_wake_pattern_cmdid = WMI_10_4_WOW_ADD_WAKE_PATTERN_CMDID,\n\t.wow_del_wake_pattern_cmdid = WMI_10_4_WOW_DEL_WAKE_PATTERN_CMDID,\n\t.wow_enable_disable_wake_event_cmdid =\n\t\t\t\tWMI_10_4_WOW_ENABLE_DISABLE_WAKE_EVENT_CMDID,\n\t.wow_enable_cmdid = WMI_10_4_WOW_ENABLE_CMDID,\n\t.wow_hostwakeup_from_sleep_cmdid =\n\t\t\t\tWMI_10_4_WOW_HOSTWAKEUP_FROM_SLEEP_CMDID,\n\t.rtt_measreq_cmdid = WMI_10_4_RTT_MEASREQ_CMDID,\n\t.rtt_tsf_cmdid = WMI_10_4_RTT_TSF_CMDID,\n\t.vdev_spectral_scan_configure_cmdid =\n\t\t\t\tWMI_10_4_VDEV_SPECTRAL_SCAN_CONFIGURE_CMDID,\n\t.vdev_spectral_scan_enable_cmdid =\n\t\t\t\tWMI_10_4_VDEV_SPECTRAL_SCAN_ENABLE_CMDID,\n\t.request_stats_cmdid = WMI_10_4_REQUEST_STATS_CMDID,\n\t.set_arp_ns_offload_cmdid = WMI_CMD_UNSUPPORTED,\n\t.network_list_offload_config_cmdid = WMI_CMD_UNSUPPORTED,\n\t.gtk_offload_cmdid = WMI_10_4_GTK_OFFLOAD_CMDID,\n\t.csa_offload_enable_cmdid = WMI_10_4_CSA_OFFLOAD_ENABLE_CMDID,\n\t.csa_offload_chanswitch_cmdid = WMI_10_4_CSA_OFFLOAD_CHANSWITCH_CMDID,\n\t.chatter_set_mode_cmdid = WMI_CMD_UNSUPPORTED,\n\t.peer_tid_addba_cmdid = WMI_CMD_UNSUPPORTED,\n\t.peer_tid_delba_cmdid = WMI_CMD_UNSUPPORTED,\n\t.sta_dtim_ps_method_cmdid = WMI_CMD_UNSUPPORTED,\n\t.sta_uapsd_auto_trig_cmdid = WMI_CMD_UNSUPPORTED,\n\t.sta_keepalive_cmd = WMI_CMD_UNSUPPORTED,\n\t.echo_cmdid = WMI_10_4_ECHO_CMDID,\n\t.pdev_utf_cmdid = WMI_10_4_PDEV_UTF_CMDID,\n\t.dbglog_cfg_cmdid = WMI_10_4_DBGLOG_CFG_CMDID,\n\t.pdev_qvit_cmdid = WMI_10_4_PDEV_QVIT_CMDID,\n\t.pdev_ftm_intg_cmdid = WMI_CMD_UNSUPPORTED,\n\t.vdev_set_keepalive_cmdid = WMI_10_4_VDEV_SET_KEEPALIVE_CMDID,\n\t.vdev_get_keepalive_cmdid = WMI_10_4_VDEV_GET_KEEPALIVE_CMDID,\n\t.force_fw_hang_cmdid = WMI_10_4_FORCE_FW_HANG_CMDID,\n\t.gpio_config_cmdid = WMI_10_4_GPIO_CONFIG_CMDID,\n\t.gpio_output_cmdid = WMI_10_4_GPIO_OUTPUT_CMDID,\n\t.pdev_get_temperature_cmdid = WMI_10_4_PDEV_GET_TEMPERATURE_CMDID,\n\t.vdev_set_wmm_params_cmdid = WMI_CMD_UNSUPPORTED,\n\t.adaptive_qcs_cmdid = WMI_CMD_UNSUPPORTED,\n\t.scan_update_request_cmdid = WMI_10_4_SCAN_UPDATE_REQUEST_CMDID,\n\t.vdev_standby_response_cmdid = WMI_10_4_VDEV_STANDBY_RESPONSE_CMDID,\n\t.vdev_resume_response_cmdid = WMI_10_4_VDEV_RESUME_RESPONSE_CMDID,\n\t.wlan_peer_caching_add_peer_cmdid =\n\t\t\tWMI_10_4_WLAN_PEER_CACHING_ADD_PEER_CMDID,\n\t.wlan_peer_caching_evict_peer_cmdid =\n\t\t\tWMI_10_4_WLAN_PEER_CACHING_EVICT_PEER_CMDID,\n\t.wlan_peer_caching_restore_peer_cmdid =\n\t\t\tWMI_10_4_WLAN_PEER_CACHING_RESTORE_PEER_CMDID,\n\t.wlan_peer_caching_print_all_peers_info_cmdid =\n\t\t\tWMI_10_4_WLAN_PEER_CACHING_PRINT_ALL_PEERS_INFO_CMDID,\n\t.peer_update_wds_entry_cmdid = WMI_10_4_PEER_UPDATE_WDS_ENTRY_CMDID,\n\t.peer_add_proxy_sta_entry_cmdid =\n\t\t\tWMI_10_4_PEER_ADD_PROXY_STA_ENTRY_CMDID,\n\t.rtt_keepalive_cmdid = WMI_10_4_RTT_KEEPALIVE_CMDID,\n\t.oem_req_cmdid = WMI_10_4_OEM_REQ_CMDID,\n\t.nan_cmdid = WMI_10_4_NAN_CMDID,\n\t.vdev_ratemask_cmdid = WMI_10_4_VDEV_RATEMASK_CMDID,\n\t.qboost_cfg_cmdid = WMI_10_4_QBOOST_CFG_CMDID,\n\t.pdev_smart_ant_enable_cmdid = WMI_10_4_PDEV_SMART_ANT_ENABLE_CMDID,\n\t.pdev_smart_ant_set_rx_antenna_cmdid =\n\t\t\tWMI_10_4_PDEV_SMART_ANT_SET_RX_ANTENNA_CMDID,\n\t.peer_smart_ant_set_tx_antenna_cmdid =\n\t\t\tWMI_10_4_PEER_SMART_ANT_SET_TX_ANTENNA_CMDID,\n\t.peer_smart_ant_set_train_info_cmdid =\n\t\t\tWMI_10_4_PEER_SMART_ANT_SET_TRAIN_INFO_CMDID,\n\t.peer_smart_ant_set_node_config_ops_cmdid =\n\t\t\tWMI_10_4_PEER_SMART_ANT_SET_NODE_CONFIG_OPS_CMDID,\n\t.pdev_set_antenna_switch_table_cmdid =\n\t\t\tWMI_10_4_PDEV_SET_ANTENNA_SWITCH_TABLE_CMDID,\n\t.pdev_set_ctl_table_cmdid = WMI_10_4_PDEV_SET_CTL_TABLE_CMDID,\n\t.pdev_set_mimogain_table_cmdid = WMI_10_4_PDEV_SET_MIMOGAIN_TABLE_CMDID,\n\t.pdev_ratepwr_table_cmdid = WMI_10_4_PDEV_RATEPWR_TABLE_CMDID,\n\t.pdev_ratepwr_chainmsk_table_cmdid =\n\t\t\tWMI_10_4_PDEV_RATEPWR_CHAINMSK_TABLE_CMDID,\n\t.pdev_fips_cmdid = WMI_10_4_PDEV_FIPS_CMDID,\n\t.tt_set_conf_cmdid = WMI_10_4_TT_SET_CONF_CMDID,\n\t.fwtest_cmdid = WMI_10_4_FWTEST_CMDID,\n\t.vdev_atf_request_cmdid = WMI_10_4_VDEV_ATF_REQUEST_CMDID,\n\t.peer_atf_request_cmdid = WMI_10_4_PEER_ATF_REQUEST_CMDID,\n\t.pdev_get_ani_cck_config_cmdid = WMI_10_4_PDEV_GET_ANI_CCK_CONFIG_CMDID,\n\t.pdev_get_ani_ofdm_config_cmdid =\n\t\t\tWMI_10_4_PDEV_GET_ANI_OFDM_CONFIG_CMDID,\n\t.pdev_reserve_ast_entry_cmdid = WMI_10_4_PDEV_RESERVE_AST_ENTRY_CMDID,\n\t.pdev_get_nfcal_power_cmdid = WMI_10_4_PDEV_GET_NFCAL_POWER_CMDID,\n\t.pdev_get_tpc_cmdid = WMI_10_4_PDEV_GET_TPC_CMDID,\n\t.pdev_get_ast_info_cmdid = WMI_10_4_PDEV_GET_AST_INFO_CMDID,\n\t.vdev_set_dscp_tid_map_cmdid = WMI_10_4_VDEV_SET_DSCP_TID_MAP_CMDID,\n\t.pdev_get_info_cmdid = WMI_10_4_PDEV_GET_INFO_CMDID,\n\t.vdev_get_info_cmdid = WMI_10_4_VDEV_GET_INFO_CMDID,\n\t.vdev_filter_neighbor_rx_packets_cmdid =\n\t\t\tWMI_10_4_VDEV_FILTER_NEIGHBOR_RX_PACKETS_CMDID,\n\t.mu_cal_start_cmdid = WMI_10_4_MU_CAL_START_CMDID,\n\t.set_cca_params_cmdid = WMI_10_4_SET_CCA_PARAMS_CMDID,\n\t.pdev_bss_chan_info_request_cmdid =\n\t\t\tWMI_10_4_PDEV_BSS_CHAN_INFO_REQUEST_CMDID,\n\t.ext_resource_cfg_cmdid = WMI_10_4_EXT_RESOURCE_CFG_CMDID,\n\t.vdev_set_ie_cmdid = WMI_10_4_VDEV_SET_IE_CMDID,\n\t.set_lteu_config_cmdid = WMI_10_4_SET_LTEU_CONFIG_CMDID,\n\t.atf_ssid_grouping_request_cmdid =\n\t\t\tWMI_10_4_ATF_SSID_GROUPING_REQUEST_CMDID,\n\t.peer_atf_ext_request_cmdid = WMI_10_4_PEER_ATF_EXT_REQUEST_CMDID,\n\t.set_periodic_channel_stats_cfg_cmdid =\n\t\t\tWMI_10_4_SET_PERIODIC_CHANNEL_STATS_CONFIG,\n\t.peer_bwf_request_cmdid = WMI_10_4_PEER_BWF_REQUEST_CMDID,\n\t.btcoex_cfg_cmdid = WMI_10_4_BTCOEX_CFG_CMDID,\n\t.peer_tx_mu_txmit_count_cmdid = WMI_10_4_PEER_TX_MU_TXMIT_COUNT_CMDID,\n\t.peer_tx_mu_txmit_rstcnt_cmdid = WMI_10_4_PEER_TX_MU_TXMIT_RSTCNT_CMDID,\n\t.peer_gid_userpos_list_cmdid = WMI_10_4_PEER_GID_USERPOS_LIST_CMDID,\n\t.pdev_check_cal_version_cmdid = WMI_10_4_PDEV_CHECK_CAL_VERSION_CMDID,\n\t.coex_version_cfg_cmid = WMI_10_4_COEX_VERSION_CFG_CMID,\n\t.pdev_get_rx_filter_cmdid = WMI_10_4_PDEV_GET_RX_FILTER_CMDID,\n\t.pdev_extended_nss_cfg_cmdid = WMI_10_4_PDEV_EXTENDED_NSS_CFG_CMDID,\n\t.vdev_set_scan_nac_rssi_cmdid = WMI_10_4_VDEV_SET_SCAN_NAC_RSSI_CMDID,\n\t.prog_gpio_band_select_cmdid = WMI_10_4_PROG_GPIO_BAND_SELECT_CMDID,\n\t.config_smart_logging_cmdid = WMI_10_4_CONFIG_SMART_LOGGING_CMDID,\n\t.debug_fatal_condition_cmdid = WMI_10_4_DEBUG_FATAL_CONDITION_CMDID,\n\t.get_tsf_timer_cmdid = WMI_10_4_GET_TSF_TIMER_CMDID,\n\t.pdev_get_tpc_table_cmdid = WMI_10_4_PDEV_GET_TPC_TABLE_CMDID,\n\t.vdev_sifs_trigger_time_cmdid = WMI_10_4_VDEV_SIFS_TRIGGER_TIME_CMDID,\n\t.pdev_wds_entry_list_cmdid = WMI_10_4_PDEV_WDS_ENTRY_LIST_CMDID,\n\t.tdls_set_state_cmdid = WMI_10_4_TDLS_SET_STATE_CMDID,\n\t.tdls_peer_update_cmdid = WMI_10_4_TDLS_PEER_UPDATE_CMDID,\n\t.tdls_set_offchan_mode_cmdid = WMI_10_4_TDLS_SET_OFFCHAN_MODE_CMDID,\n\t.radar_found_cmdid = WMI_10_4_RADAR_FOUND_CMDID,\n\t.per_peer_per_tid_config_cmdid = WMI_10_4_PER_PEER_PER_TID_CONFIG_CMDID,\n};\n\nstatic struct wmi_peer_param_map wmi_peer_param_map = {\n\t.smps_state = WMI_PEER_SMPS_STATE,\n\t.ampdu = WMI_PEER_AMPDU,\n\t.authorize = WMI_PEER_AUTHORIZE,\n\t.chan_width = WMI_PEER_CHAN_WIDTH,\n\t.nss = WMI_PEER_NSS,\n\t.use_4addr = WMI_PEER_USE_4ADDR,\n\t.use_fixed_power = WMI_PEER_USE_FIXED_PWR,\n\t.debug = WMI_PEER_DEBUG,\n\t.phymode = WMI_PEER_PHYMODE,\n\t.dummy_var = WMI_PEER_DUMMY_VAR,\n};\n\n \nstatic struct wmi_vdev_param_map wmi_vdev_param_map = {\n\t.rts_threshold = WMI_VDEV_PARAM_RTS_THRESHOLD,\n\t.fragmentation_threshold = WMI_VDEV_PARAM_FRAGMENTATION_THRESHOLD,\n\t.beacon_interval = WMI_VDEV_PARAM_BEACON_INTERVAL,\n\t.listen_interval = WMI_VDEV_PARAM_LISTEN_INTERVAL,\n\t.multicast_rate = WMI_VDEV_PARAM_MULTICAST_RATE,\n\t.mgmt_tx_rate = WMI_VDEV_PARAM_MGMT_TX_RATE,\n\t.slot_time = WMI_VDEV_PARAM_SLOT_TIME,\n\t.preamble = WMI_VDEV_PARAM_PREAMBLE,\n\t.swba_time = WMI_VDEV_PARAM_SWBA_TIME,\n\t.wmi_vdev_stats_update_period = WMI_VDEV_STATS_UPDATE_PERIOD,\n\t.wmi_vdev_pwrsave_ageout_time = WMI_VDEV_PWRSAVE_AGEOUT_TIME,\n\t.wmi_vdev_host_swba_interval = WMI_VDEV_HOST_SWBA_INTERVAL,\n\t.dtim_period = WMI_VDEV_PARAM_DTIM_PERIOD,\n\t.wmi_vdev_oc_scheduler_air_time_limit =\n\t\t\t\t\tWMI_VDEV_OC_SCHEDULER_AIR_TIME_LIMIT,\n\t.wds = WMI_VDEV_PARAM_WDS,\n\t.atim_window = WMI_VDEV_PARAM_ATIM_WINDOW,\n\t.bmiss_count_max = WMI_VDEV_PARAM_BMISS_COUNT_MAX,\n\t.bmiss_first_bcnt = WMI_VDEV_PARAM_BMISS_FIRST_BCNT,\n\t.bmiss_final_bcnt = WMI_VDEV_PARAM_BMISS_FINAL_BCNT,\n\t.feature_wmm = WMI_VDEV_PARAM_FEATURE_WMM,\n\t.chwidth = WMI_VDEV_PARAM_CHWIDTH,\n\t.chextoffset = WMI_VDEV_PARAM_CHEXTOFFSET,\n\t.disable_htprotection =\tWMI_VDEV_PARAM_DISABLE_HTPROTECTION,\n\t.sta_quickkickout = WMI_VDEV_PARAM_STA_QUICKKICKOUT,\n\t.mgmt_rate = WMI_VDEV_PARAM_MGMT_RATE,\n\t.protection_mode = WMI_VDEV_PARAM_PROTECTION_MODE,\n\t.fixed_rate = WMI_VDEV_PARAM_FIXED_RATE,\n\t.sgi = WMI_VDEV_PARAM_SGI,\n\t.ldpc = WMI_VDEV_PARAM_LDPC,\n\t.tx_stbc = WMI_VDEV_PARAM_TX_STBC,\n\t.rx_stbc = WMI_VDEV_PARAM_RX_STBC,\n\t.intra_bss_fwd = WMI_VDEV_PARAM_INTRA_BSS_FWD,\n\t.def_keyid = WMI_VDEV_PARAM_DEF_KEYID,\n\t.nss = WMI_VDEV_PARAM_NSS,\n\t.bcast_data_rate = WMI_VDEV_PARAM_BCAST_DATA_RATE,\n\t.mcast_data_rate = WMI_VDEV_PARAM_MCAST_DATA_RATE,\n\t.mcast_indicate = WMI_VDEV_PARAM_MCAST_INDICATE,\n\t.dhcp_indicate = WMI_VDEV_PARAM_DHCP_INDICATE,\n\t.unknown_dest_indicate = WMI_VDEV_PARAM_UNKNOWN_DEST_INDICATE,\n\t.ap_keepalive_min_idle_inactive_time_secs =\n\t\t\tWMI_VDEV_PARAM_AP_KEEPALIVE_MIN_IDLE_INACTIVE_TIME_SECS,\n\t.ap_keepalive_max_idle_inactive_time_secs =\n\t\t\tWMI_VDEV_PARAM_AP_KEEPALIVE_MAX_IDLE_INACTIVE_TIME_SECS,\n\t.ap_keepalive_max_unresponsive_time_secs =\n\t\t\tWMI_VDEV_PARAM_AP_KEEPALIVE_MAX_UNRESPONSIVE_TIME_SECS,\n\t.ap_enable_nawds = WMI_VDEV_PARAM_AP_ENABLE_NAWDS,\n\t.mcast2ucast_set = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.enable_rtscts = WMI_VDEV_PARAM_ENABLE_RTSCTS,\n\t.txbf = WMI_VDEV_PARAM_TXBF,\n\t.packet_powersave = WMI_VDEV_PARAM_PACKET_POWERSAVE,\n\t.drop_unencry = WMI_VDEV_PARAM_DROP_UNENCRY,\n\t.tx_encap_type = WMI_VDEV_PARAM_TX_ENCAP_TYPE,\n\t.ap_detect_out_of_sync_sleeping_sta_time_secs =\n\t\t\t\t\tWMI_VDEV_PARAM_UNSUPPORTED,\n\t.rc_num_retries = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.cabq_maxdur = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.mfptest_set = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.rts_fixed_rate = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.vht_sgimask = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.vht80_ratemask = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.early_rx_adjust_enable = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.early_rx_tgt_bmiss_num = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.early_rx_bmiss_sample_cycle = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.early_rx_slop_step = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.early_rx_init_slop = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.early_rx_adjust_pause = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.proxy_sta = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.meru_vc = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.rx_decap_type = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.bw_nss_ratemask = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.disable_4addr_src_lrn = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.rtt_responder_role = WMI_VDEV_PARAM_UNSUPPORTED,\n};\n\n \nstatic struct wmi_vdev_param_map wmi_10x_vdev_param_map = {\n\t.rts_threshold = WMI_10X_VDEV_PARAM_RTS_THRESHOLD,\n\t.fragmentation_threshold = WMI_10X_VDEV_PARAM_FRAGMENTATION_THRESHOLD,\n\t.beacon_interval = WMI_10X_VDEV_PARAM_BEACON_INTERVAL,\n\t.listen_interval = WMI_10X_VDEV_PARAM_LISTEN_INTERVAL,\n\t.multicast_rate = WMI_10X_VDEV_PARAM_MULTICAST_RATE,\n\t.mgmt_tx_rate = WMI_10X_VDEV_PARAM_MGMT_TX_RATE,\n\t.slot_time = WMI_10X_VDEV_PARAM_SLOT_TIME,\n\t.preamble = WMI_10X_VDEV_PARAM_PREAMBLE,\n\t.swba_time = WMI_10X_VDEV_PARAM_SWBA_TIME,\n\t.wmi_vdev_stats_update_period = WMI_10X_VDEV_STATS_UPDATE_PERIOD,\n\t.wmi_vdev_pwrsave_ageout_time = WMI_10X_VDEV_PWRSAVE_AGEOUT_TIME,\n\t.wmi_vdev_host_swba_interval = WMI_10X_VDEV_HOST_SWBA_INTERVAL,\n\t.dtim_period = WMI_10X_VDEV_PARAM_DTIM_PERIOD,\n\t.wmi_vdev_oc_scheduler_air_time_limit =\n\t\t\t\tWMI_10X_VDEV_OC_SCHEDULER_AIR_TIME_LIMIT,\n\t.wds = WMI_10X_VDEV_PARAM_WDS,\n\t.atim_window = WMI_10X_VDEV_PARAM_ATIM_WINDOW,\n\t.bmiss_count_max = WMI_10X_VDEV_PARAM_BMISS_COUNT_MAX,\n\t.bmiss_first_bcnt = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.bmiss_final_bcnt = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.feature_wmm = WMI_10X_VDEV_PARAM_FEATURE_WMM,\n\t.chwidth = WMI_10X_VDEV_PARAM_CHWIDTH,\n\t.chextoffset = WMI_10X_VDEV_PARAM_CHEXTOFFSET,\n\t.disable_htprotection = WMI_10X_VDEV_PARAM_DISABLE_HTPROTECTION,\n\t.sta_quickkickout = WMI_10X_VDEV_PARAM_STA_QUICKKICKOUT,\n\t.mgmt_rate = WMI_10X_VDEV_PARAM_MGMT_RATE,\n\t.protection_mode = WMI_10X_VDEV_PARAM_PROTECTION_MODE,\n\t.fixed_rate = WMI_10X_VDEV_PARAM_FIXED_RATE,\n\t.sgi = WMI_10X_VDEV_PARAM_SGI,\n\t.ldpc = WMI_10X_VDEV_PARAM_LDPC,\n\t.tx_stbc = WMI_10X_VDEV_PARAM_TX_STBC,\n\t.rx_stbc = WMI_10X_VDEV_PARAM_RX_STBC,\n\t.intra_bss_fwd = WMI_10X_VDEV_PARAM_INTRA_BSS_FWD,\n\t.def_keyid = WMI_10X_VDEV_PARAM_DEF_KEYID,\n\t.nss = WMI_10X_VDEV_PARAM_NSS,\n\t.bcast_data_rate = WMI_10X_VDEV_PARAM_BCAST_DATA_RATE,\n\t.mcast_data_rate = WMI_10X_VDEV_PARAM_MCAST_DATA_RATE,\n\t.mcast_indicate = WMI_10X_VDEV_PARAM_MCAST_INDICATE,\n\t.dhcp_indicate = WMI_10X_VDEV_PARAM_DHCP_INDICATE,\n\t.unknown_dest_indicate = WMI_10X_VDEV_PARAM_UNKNOWN_DEST_INDICATE,\n\t.ap_keepalive_min_idle_inactive_time_secs =\n\t\tWMI_10X_VDEV_PARAM_AP_KEEPALIVE_MIN_IDLE_INACTIVE_TIME_SECS,\n\t.ap_keepalive_max_idle_inactive_time_secs =\n\t\tWMI_10X_VDEV_PARAM_AP_KEEPALIVE_MAX_IDLE_INACTIVE_TIME_SECS,\n\t.ap_keepalive_max_unresponsive_time_secs =\n\t\tWMI_10X_VDEV_PARAM_AP_KEEPALIVE_MAX_UNRESPONSIVE_TIME_SECS,\n\t.ap_enable_nawds = WMI_10X_VDEV_PARAM_AP_ENABLE_NAWDS,\n\t.mcast2ucast_set = WMI_10X_VDEV_PARAM_MCAST2UCAST_SET,\n\t.enable_rtscts = WMI_10X_VDEV_PARAM_ENABLE_RTSCTS,\n\t.txbf = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.packet_powersave = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.drop_unencry = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.tx_encap_type = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.ap_detect_out_of_sync_sleeping_sta_time_secs =\n\t\tWMI_10X_VDEV_PARAM_AP_DETECT_OUT_OF_SYNC_SLEEPING_STA_TIME_SECS,\n\t.rc_num_retries = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.cabq_maxdur = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.mfptest_set = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.rts_fixed_rate = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.vht_sgimask = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.vht80_ratemask = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.early_rx_adjust_enable = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.early_rx_tgt_bmiss_num = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.early_rx_bmiss_sample_cycle = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.early_rx_slop_step = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.early_rx_init_slop = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.early_rx_adjust_pause = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.proxy_sta = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.meru_vc = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.rx_decap_type = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.bw_nss_ratemask = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.disable_4addr_src_lrn = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.rtt_responder_role = WMI_VDEV_PARAM_UNSUPPORTED,\n};\n\nstatic struct wmi_vdev_param_map wmi_10_2_4_vdev_param_map = {\n\t.rts_threshold = WMI_10X_VDEV_PARAM_RTS_THRESHOLD,\n\t.fragmentation_threshold = WMI_10X_VDEV_PARAM_FRAGMENTATION_THRESHOLD,\n\t.beacon_interval = WMI_10X_VDEV_PARAM_BEACON_INTERVAL,\n\t.listen_interval = WMI_10X_VDEV_PARAM_LISTEN_INTERVAL,\n\t.multicast_rate = WMI_10X_VDEV_PARAM_MULTICAST_RATE,\n\t.mgmt_tx_rate = WMI_10X_VDEV_PARAM_MGMT_TX_RATE,\n\t.slot_time = WMI_10X_VDEV_PARAM_SLOT_TIME,\n\t.preamble = WMI_10X_VDEV_PARAM_PREAMBLE,\n\t.swba_time = WMI_10X_VDEV_PARAM_SWBA_TIME,\n\t.wmi_vdev_stats_update_period = WMI_10X_VDEV_STATS_UPDATE_PERIOD,\n\t.wmi_vdev_pwrsave_ageout_time = WMI_10X_VDEV_PWRSAVE_AGEOUT_TIME,\n\t.wmi_vdev_host_swba_interval = WMI_10X_VDEV_HOST_SWBA_INTERVAL,\n\t.dtim_period = WMI_10X_VDEV_PARAM_DTIM_PERIOD,\n\t.wmi_vdev_oc_scheduler_air_time_limit =\n\t\t\t\tWMI_10X_VDEV_OC_SCHEDULER_AIR_TIME_LIMIT,\n\t.wds = WMI_10X_VDEV_PARAM_WDS,\n\t.atim_window = WMI_10X_VDEV_PARAM_ATIM_WINDOW,\n\t.bmiss_count_max = WMI_10X_VDEV_PARAM_BMISS_COUNT_MAX,\n\t.bmiss_first_bcnt = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.bmiss_final_bcnt = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.feature_wmm = WMI_10X_VDEV_PARAM_FEATURE_WMM,\n\t.chwidth = WMI_10X_VDEV_PARAM_CHWIDTH,\n\t.chextoffset = WMI_10X_VDEV_PARAM_CHEXTOFFSET,\n\t.disable_htprotection = WMI_10X_VDEV_PARAM_DISABLE_HTPROTECTION,\n\t.sta_quickkickout = WMI_10X_VDEV_PARAM_STA_QUICKKICKOUT,\n\t.mgmt_rate = WMI_10X_VDEV_PARAM_MGMT_RATE,\n\t.protection_mode = WMI_10X_VDEV_PARAM_PROTECTION_MODE,\n\t.fixed_rate = WMI_10X_VDEV_PARAM_FIXED_RATE,\n\t.sgi = WMI_10X_VDEV_PARAM_SGI,\n\t.ldpc = WMI_10X_VDEV_PARAM_LDPC,\n\t.tx_stbc = WMI_10X_VDEV_PARAM_TX_STBC,\n\t.rx_stbc = WMI_10X_VDEV_PARAM_RX_STBC,\n\t.intra_bss_fwd = WMI_10X_VDEV_PARAM_INTRA_BSS_FWD,\n\t.def_keyid = WMI_10X_VDEV_PARAM_DEF_KEYID,\n\t.nss = WMI_10X_VDEV_PARAM_NSS,\n\t.bcast_data_rate = WMI_10X_VDEV_PARAM_BCAST_DATA_RATE,\n\t.mcast_data_rate = WMI_10X_VDEV_PARAM_MCAST_DATA_RATE,\n\t.mcast_indicate = WMI_10X_VDEV_PARAM_MCAST_INDICATE,\n\t.dhcp_indicate = WMI_10X_VDEV_PARAM_DHCP_INDICATE,\n\t.unknown_dest_indicate = WMI_10X_VDEV_PARAM_UNKNOWN_DEST_INDICATE,\n\t.ap_keepalive_min_idle_inactive_time_secs =\n\t\tWMI_10X_VDEV_PARAM_AP_KEEPALIVE_MIN_IDLE_INACTIVE_TIME_SECS,\n\t.ap_keepalive_max_idle_inactive_time_secs =\n\t\tWMI_10X_VDEV_PARAM_AP_KEEPALIVE_MAX_IDLE_INACTIVE_TIME_SECS,\n\t.ap_keepalive_max_unresponsive_time_secs =\n\t\tWMI_10X_VDEV_PARAM_AP_KEEPALIVE_MAX_UNRESPONSIVE_TIME_SECS,\n\t.ap_enable_nawds = WMI_10X_VDEV_PARAM_AP_ENABLE_NAWDS,\n\t.mcast2ucast_set = WMI_10X_VDEV_PARAM_MCAST2UCAST_SET,\n\t.enable_rtscts = WMI_10X_VDEV_PARAM_ENABLE_RTSCTS,\n\t.txbf = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.packet_powersave = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.drop_unencry = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.tx_encap_type = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.ap_detect_out_of_sync_sleeping_sta_time_secs =\n\t\tWMI_10X_VDEV_PARAM_AP_DETECT_OUT_OF_SYNC_SLEEPING_STA_TIME_SECS,\n\t.rc_num_retries = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.cabq_maxdur = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.mfptest_set = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.rts_fixed_rate = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.vht_sgimask = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.vht80_ratemask = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.early_rx_adjust_enable = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.early_rx_tgt_bmiss_num = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.early_rx_bmiss_sample_cycle = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.early_rx_slop_step = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.early_rx_init_slop = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.early_rx_adjust_pause = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.proxy_sta = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.meru_vc = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.rx_decap_type = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.bw_nss_ratemask = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.disable_4addr_src_lrn = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.rtt_responder_role = WMI_VDEV_PARAM_UNSUPPORTED,\n};\n\nstatic struct wmi_vdev_param_map wmi_10_4_vdev_param_map = {\n\t.rts_threshold = WMI_10_4_VDEV_PARAM_RTS_THRESHOLD,\n\t.fragmentation_threshold = WMI_10_4_VDEV_PARAM_FRAGMENTATION_THRESHOLD,\n\t.beacon_interval = WMI_10_4_VDEV_PARAM_BEACON_INTERVAL,\n\t.listen_interval = WMI_10_4_VDEV_PARAM_LISTEN_INTERVAL,\n\t.multicast_rate = WMI_10_4_VDEV_PARAM_MULTICAST_RATE,\n\t.mgmt_tx_rate = WMI_10_4_VDEV_PARAM_MGMT_TX_RATE,\n\t.slot_time = WMI_10_4_VDEV_PARAM_SLOT_TIME,\n\t.preamble = WMI_10_4_VDEV_PARAM_PREAMBLE,\n\t.swba_time = WMI_10_4_VDEV_PARAM_SWBA_TIME,\n\t.wmi_vdev_stats_update_period = WMI_10_4_VDEV_STATS_UPDATE_PERIOD,\n\t.wmi_vdev_pwrsave_ageout_time = WMI_10_4_VDEV_PWRSAVE_AGEOUT_TIME,\n\t.wmi_vdev_host_swba_interval = WMI_10_4_VDEV_HOST_SWBA_INTERVAL,\n\t.dtim_period = WMI_10_4_VDEV_PARAM_DTIM_PERIOD,\n\t.wmi_vdev_oc_scheduler_air_time_limit =\n\t       WMI_10_4_VDEV_OC_SCHEDULER_AIR_TIME_LIMIT,\n\t.wds = WMI_10_4_VDEV_PARAM_WDS,\n\t.atim_window = WMI_10_4_VDEV_PARAM_ATIM_WINDOW,\n\t.bmiss_count_max = WMI_10_4_VDEV_PARAM_BMISS_COUNT_MAX,\n\t.bmiss_first_bcnt = WMI_10_4_VDEV_PARAM_BMISS_FIRST_BCNT,\n\t.bmiss_final_bcnt = WMI_10_4_VDEV_PARAM_BMISS_FINAL_BCNT,\n\t.feature_wmm = WMI_10_4_VDEV_PARAM_FEATURE_WMM,\n\t.chwidth = WMI_10_4_VDEV_PARAM_CHWIDTH,\n\t.chextoffset = WMI_10_4_VDEV_PARAM_CHEXTOFFSET,\n\t.disable_htprotection = WMI_10_4_VDEV_PARAM_DISABLE_HTPROTECTION,\n\t.sta_quickkickout = WMI_10_4_VDEV_PARAM_STA_QUICKKICKOUT,\n\t.mgmt_rate = WMI_10_4_VDEV_PARAM_MGMT_RATE,\n\t.protection_mode = WMI_10_4_VDEV_PARAM_PROTECTION_MODE,\n\t.fixed_rate = WMI_10_4_VDEV_PARAM_FIXED_RATE,\n\t.sgi = WMI_10_4_VDEV_PARAM_SGI,\n\t.ldpc = WMI_10_4_VDEV_PARAM_LDPC,\n\t.tx_stbc = WMI_10_4_VDEV_PARAM_TX_STBC,\n\t.rx_stbc = WMI_10_4_VDEV_PARAM_RX_STBC,\n\t.intra_bss_fwd = WMI_10_4_VDEV_PARAM_INTRA_BSS_FWD,\n\t.def_keyid = WMI_10_4_VDEV_PARAM_DEF_KEYID,\n\t.nss = WMI_10_4_VDEV_PARAM_NSS,\n\t.bcast_data_rate = WMI_10_4_VDEV_PARAM_BCAST_DATA_RATE,\n\t.mcast_data_rate = WMI_10_4_VDEV_PARAM_MCAST_DATA_RATE,\n\t.mcast_indicate = WMI_10_4_VDEV_PARAM_MCAST_INDICATE,\n\t.dhcp_indicate = WMI_10_4_VDEV_PARAM_DHCP_INDICATE,\n\t.unknown_dest_indicate = WMI_10_4_VDEV_PARAM_UNKNOWN_DEST_INDICATE,\n\t.ap_keepalive_min_idle_inactive_time_secs =\n\t       WMI_10_4_VDEV_PARAM_AP_KEEPALIVE_MIN_IDLE_INACTIVE_TIME_SECS,\n\t.ap_keepalive_max_idle_inactive_time_secs =\n\t       WMI_10_4_VDEV_PARAM_AP_KEEPALIVE_MAX_IDLE_INACTIVE_TIME_SECS,\n\t.ap_keepalive_max_unresponsive_time_secs =\n\t       WMI_10_4_VDEV_PARAM_AP_KEEPALIVE_MAX_UNRESPONSIVE_TIME_SECS,\n\t.ap_enable_nawds = WMI_10_4_VDEV_PARAM_AP_ENABLE_NAWDS,\n\t.mcast2ucast_set = WMI_10_4_VDEV_PARAM_MCAST2UCAST_SET,\n\t.enable_rtscts = WMI_10_4_VDEV_PARAM_ENABLE_RTSCTS,\n\t.txbf = WMI_10_4_VDEV_PARAM_TXBF,\n\t.packet_powersave = WMI_10_4_VDEV_PARAM_PACKET_POWERSAVE,\n\t.drop_unencry = WMI_10_4_VDEV_PARAM_DROP_UNENCRY,\n\t.tx_encap_type = WMI_10_4_VDEV_PARAM_TX_ENCAP_TYPE,\n\t.ap_detect_out_of_sync_sleeping_sta_time_secs =\n\t       WMI_10_4_VDEV_PARAM_AP_DETECT_OUT_OF_SYNC_SLEEPING_STA_TIME_SECS,\n\t.rc_num_retries = WMI_10_4_VDEV_PARAM_RC_NUM_RETRIES,\n\t.cabq_maxdur = WMI_10_4_VDEV_PARAM_CABQ_MAXDUR,\n\t.mfptest_set = WMI_10_4_VDEV_PARAM_MFPTEST_SET,\n\t.rts_fixed_rate = WMI_10_4_VDEV_PARAM_RTS_FIXED_RATE,\n\t.vht_sgimask = WMI_10_4_VDEV_PARAM_VHT_SGIMASK,\n\t.vht80_ratemask = WMI_10_4_VDEV_PARAM_VHT80_RATEMASK,\n\t.early_rx_adjust_enable = WMI_10_4_VDEV_PARAM_EARLY_RX_ADJUST_ENABLE,\n\t.early_rx_tgt_bmiss_num = WMI_10_4_VDEV_PARAM_EARLY_RX_TGT_BMISS_NUM,\n\t.early_rx_bmiss_sample_cycle =\n\t       WMI_10_4_VDEV_PARAM_EARLY_RX_BMISS_SAMPLE_CYCLE,\n\t.early_rx_slop_step = WMI_10_4_VDEV_PARAM_EARLY_RX_SLOP_STEP,\n\t.early_rx_init_slop = WMI_10_4_VDEV_PARAM_EARLY_RX_INIT_SLOP,\n\t.early_rx_adjust_pause = WMI_10_4_VDEV_PARAM_EARLY_RX_ADJUST_PAUSE,\n\t.proxy_sta = WMI_10_4_VDEV_PARAM_PROXY_STA,\n\t.meru_vc = WMI_10_4_VDEV_PARAM_MERU_VC,\n\t.rx_decap_type = WMI_10_4_VDEV_PARAM_RX_DECAP_TYPE,\n\t.bw_nss_ratemask = WMI_10_4_VDEV_PARAM_BW_NSS_RATEMASK,\n\t.inc_tsf = WMI_10_4_VDEV_PARAM_TSF_INCREMENT,\n\t.dec_tsf = WMI_10_4_VDEV_PARAM_TSF_DECREMENT,\n\t.disable_4addr_src_lrn = WMI_10_4_VDEV_PARAM_DISABLE_4_ADDR_SRC_LRN,\n\t.rtt_responder_role = WMI_10_4_VDEV_PARAM_ENABLE_DISABLE_RTT_RESPONDER_ROLE,\n};\n\nstatic struct wmi_pdev_param_map wmi_pdev_param_map = {\n\t.tx_chain_mask = WMI_PDEV_PARAM_TX_CHAIN_MASK,\n\t.rx_chain_mask = WMI_PDEV_PARAM_RX_CHAIN_MASK,\n\t.txpower_limit2g = WMI_PDEV_PARAM_TXPOWER_LIMIT2G,\n\t.txpower_limit5g = WMI_PDEV_PARAM_TXPOWER_LIMIT5G,\n\t.txpower_scale = WMI_PDEV_PARAM_TXPOWER_SCALE,\n\t.beacon_gen_mode = WMI_PDEV_PARAM_BEACON_GEN_MODE,\n\t.beacon_tx_mode = WMI_PDEV_PARAM_BEACON_TX_MODE,\n\t.resmgr_offchan_mode = WMI_PDEV_PARAM_RESMGR_OFFCHAN_MODE,\n\t.protection_mode = WMI_PDEV_PARAM_PROTECTION_MODE,\n\t.dynamic_bw = WMI_PDEV_PARAM_DYNAMIC_BW,\n\t.non_agg_sw_retry_th = WMI_PDEV_PARAM_NON_AGG_SW_RETRY_TH,\n\t.agg_sw_retry_th = WMI_PDEV_PARAM_AGG_SW_RETRY_TH,\n\t.sta_kickout_th = WMI_PDEV_PARAM_STA_KICKOUT_TH,\n\t.ac_aggrsize_scaling = WMI_PDEV_PARAM_AC_AGGRSIZE_SCALING,\n\t.ltr_enable = WMI_PDEV_PARAM_LTR_ENABLE,\n\t.ltr_ac_latency_be = WMI_PDEV_PARAM_LTR_AC_LATENCY_BE,\n\t.ltr_ac_latency_bk = WMI_PDEV_PARAM_LTR_AC_LATENCY_BK,\n\t.ltr_ac_latency_vi = WMI_PDEV_PARAM_LTR_AC_LATENCY_VI,\n\t.ltr_ac_latency_vo = WMI_PDEV_PARAM_LTR_AC_LATENCY_VO,\n\t.ltr_ac_latency_timeout = WMI_PDEV_PARAM_LTR_AC_LATENCY_TIMEOUT,\n\t.ltr_sleep_override = WMI_PDEV_PARAM_LTR_SLEEP_OVERRIDE,\n\t.ltr_rx_override = WMI_PDEV_PARAM_LTR_RX_OVERRIDE,\n\t.ltr_tx_activity_timeout = WMI_PDEV_PARAM_LTR_TX_ACTIVITY_TIMEOUT,\n\t.l1ss_enable = WMI_PDEV_PARAM_L1SS_ENABLE,\n\t.dsleep_enable = WMI_PDEV_PARAM_DSLEEP_ENABLE,\n\t.pcielp_txbuf_flush = WMI_PDEV_PARAM_PCIELP_TXBUF_FLUSH,\n\t.pcielp_txbuf_watermark = WMI_PDEV_PARAM_PCIELP_TXBUF_TMO_EN,\n\t.pcielp_txbuf_tmo_en = WMI_PDEV_PARAM_PCIELP_TXBUF_TMO_EN,\n\t.pcielp_txbuf_tmo_value = WMI_PDEV_PARAM_PCIELP_TXBUF_TMO_VALUE,\n\t.pdev_stats_update_period = WMI_PDEV_PARAM_PDEV_STATS_UPDATE_PERIOD,\n\t.vdev_stats_update_period = WMI_PDEV_PARAM_VDEV_STATS_UPDATE_PERIOD,\n\t.peer_stats_update_period = WMI_PDEV_PARAM_PEER_STATS_UPDATE_PERIOD,\n\t.bcnflt_stats_update_period = WMI_PDEV_PARAM_BCNFLT_STATS_UPDATE_PERIOD,\n\t.pmf_qos = WMI_PDEV_PARAM_PMF_QOS,\n\t.arp_ac_override = WMI_PDEV_PARAM_ARP_AC_OVERRIDE,\n\t.dcs = WMI_PDEV_PARAM_DCS,\n\t.ani_enable = WMI_PDEV_PARAM_ANI_ENABLE,\n\t.ani_poll_period = WMI_PDEV_PARAM_ANI_POLL_PERIOD,\n\t.ani_listen_period = WMI_PDEV_PARAM_ANI_LISTEN_PERIOD,\n\t.ani_ofdm_level = WMI_PDEV_PARAM_ANI_OFDM_LEVEL,\n\t.ani_cck_level = WMI_PDEV_PARAM_ANI_CCK_LEVEL,\n\t.dyntxchain = WMI_PDEV_PARAM_DYNTXCHAIN,\n\t.proxy_sta = WMI_PDEV_PARAM_PROXY_STA,\n\t.idle_ps_config = WMI_PDEV_PARAM_IDLE_PS_CONFIG,\n\t.power_gating_sleep = WMI_PDEV_PARAM_POWER_GATING_SLEEP,\n\t.fast_channel_reset = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.burst_dur = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.burst_enable = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.cal_period = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.aggr_burst = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.rx_decap_mode = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.smart_antenna_default_antenna = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.igmpmld_override = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.igmpmld_tid = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.antenna_gain = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.rx_filter = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.set_mcast_to_ucast_tid = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.proxy_sta_mode = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.set_mcast2ucast_mode = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.set_mcast2ucast_buffer = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.remove_mcast2ucast_buffer = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.peer_sta_ps_statechg_enable = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.igmpmld_ac_override = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.block_interbss = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.set_disable_reset_cmdid = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.set_msdu_ttl_cmdid = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.set_ppdu_duration_cmdid = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.txbf_sound_period_cmdid = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.set_promisc_mode_cmdid = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.set_burst_mode_cmdid = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.en_stats = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.mu_group_policy = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.noise_detection = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.noise_threshold = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.dpd_enable = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.set_mcast_bcast_echo = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.atf_strict_sch = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.atf_sched_duration = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.ant_plzn = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.mgmt_retry_limit = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.sensitivity_level = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.signed_txpower_2g = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.signed_txpower_5g = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.enable_per_tid_amsdu = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.enable_per_tid_ampdu = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.cca_threshold = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.rts_fixed_rate = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.pdev_reset = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.wapi_mbssid_offset = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.arp_srcaddr = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.arp_dstaddr = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.enable_btcoex = WMI_PDEV_PARAM_UNSUPPORTED,\n};\n\nstatic struct wmi_pdev_param_map wmi_10x_pdev_param_map = {\n\t.tx_chain_mask = WMI_10X_PDEV_PARAM_TX_CHAIN_MASK,\n\t.rx_chain_mask = WMI_10X_PDEV_PARAM_RX_CHAIN_MASK,\n\t.txpower_limit2g = WMI_10X_PDEV_PARAM_TXPOWER_LIMIT2G,\n\t.txpower_limit5g = WMI_10X_PDEV_PARAM_TXPOWER_LIMIT5G,\n\t.txpower_scale = WMI_10X_PDEV_PARAM_TXPOWER_SCALE,\n\t.beacon_gen_mode = WMI_10X_PDEV_PARAM_BEACON_GEN_MODE,\n\t.beacon_tx_mode = WMI_10X_PDEV_PARAM_BEACON_TX_MODE,\n\t.resmgr_offchan_mode = WMI_10X_PDEV_PARAM_RESMGR_OFFCHAN_MODE,\n\t.protection_mode = WMI_10X_PDEV_PARAM_PROTECTION_MODE,\n\t.dynamic_bw = WMI_10X_PDEV_PARAM_DYNAMIC_BW,\n\t.non_agg_sw_retry_th = WMI_10X_PDEV_PARAM_NON_AGG_SW_RETRY_TH,\n\t.agg_sw_retry_th = WMI_10X_PDEV_PARAM_AGG_SW_RETRY_TH,\n\t.sta_kickout_th = WMI_10X_PDEV_PARAM_STA_KICKOUT_TH,\n\t.ac_aggrsize_scaling = WMI_10X_PDEV_PARAM_AC_AGGRSIZE_SCALING,\n\t.ltr_enable = WMI_10X_PDEV_PARAM_LTR_ENABLE,\n\t.ltr_ac_latency_be = WMI_10X_PDEV_PARAM_LTR_AC_LATENCY_BE,\n\t.ltr_ac_latency_bk = WMI_10X_PDEV_PARAM_LTR_AC_LATENCY_BK,\n\t.ltr_ac_latency_vi = WMI_10X_PDEV_PARAM_LTR_AC_LATENCY_VI,\n\t.ltr_ac_latency_vo = WMI_10X_PDEV_PARAM_LTR_AC_LATENCY_VO,\n\t.ltr_ac_latency_timeout = WMI_10X_PDEV_PARAM_LTR_AC_LATENCY_TIMEOUT,\n\t.ltr_sleep_override = WMI_10X_PDEV_PARAM_LTR_SLEEP_OVERRIDE,\n\t.ltr_rx_override = WMI_10X_PDEV_PARAM_LTR_RX_OVERRIDE,\n\t.ltr_tx_activity_timeout = WMI_10X_PDEV_PARAM_LTR_TX_ACTIVITY_TIMEOUT,\n\t.l1ss_enable = WMI_10X_PDEV_PARAM_L1SS_ENABLE,\n\t.dsleep_enable = WMI_10X_PDEV_PARAM_DSLEEP_ENABLE,\n\t.pcielp_txbuf_flush = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.pcielp_txbuf_watermark = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.pcielp_txbuf_tmo_en = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.pcielp_txbuf_tmo_value = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.pdev_stats_update_period = WMI_10X_PDEV_PARAM_PDEV_STATS_UPDATE_PERIOD,\n\t.vdev_stats_update_period = WMI_10X_PDEV_PARAM_VDEV_STATS_UPDATE_PERIOD,\n\t.peer_stats_update_period = WMI_10X_PDEV_PARAM_PEER_STATS_UPDATE_PERIOD,\n\t.bcnflt_stats_update_period =\n\t\t\t\tWMI_10X_PDEV_PARAM_BCNFLT_STATS_UPDATE_PERIOD,\n\t.pmf_qos = WMI_10X_PDEV_PARAM_PMF_QOS,\n\t.arp_ac_override = WMI_10X_PDEV_PARAM_ARPDHCP_AC_OVERRIDE,\n\t.dcs = WMI_10X_PDEV_PARAM_DCS,\n\t.ani_enable = WMI_10X_PDEV_PARAM_ANI_ENABLE,\n\t.ani_poll_period = WMI_10X_PDEV_PARAM_ANI_POLL_PERIOD,\n\t.ani_listen_period = WMI_10X_PDEV_PARAM_ANI_LISTEN_PERIOD,\n\t.ani_ofdm_level = WMI_10X_PDEV_PARAM_ANI_OFDM_LEVEL,\n\t.ani_cck_level = WMI_10X_PDEV_PARAM_ANI_CCK_LEVEL,\n\t.dyntxchain = WMI_10X_PDEV_PARAM_DYNTXCHAIN,\n\t.proxy_sta = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.idle_ps_config = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.power_gating_sleep = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.fast_channel_reset = WMI_10X_PDEV_PARAM_FAST_CHANNEL_RESET,\n\t.burst_dur = WMI_10X_PDEV_PARAM_BURST_DUR,\n\t.burst_enable = WMI_10X_PDEV_PARAM_BURST_ENABLE,\n\t.cal_period = WMI_10X_PDEV_PARAM_CAL_PERIOD,\n\t.aggr_burst = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.rx_decap_mode = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.smart_antenna_default_antenna = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.igmpmld_override = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.igmpmld_tid = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.antenna_gain = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.rx_filter = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.set_mcast_to_ucast_tid = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.proxy_sta_mode = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.set_mcast2ucast_mode = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.set_mcast2ucast_buffer = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.remove_mcast2ucast_buffer = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.peer_sta_ps_statechg_enable = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.igmpmld_ac_override = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.block_interbss = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.set_disable_reset_cmdid = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.set_msdu_ttl_cmdid = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.set_ppdu_duration_cmdid = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.txbf_sound_period_cmdid = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.set_promisc_mode_cmdid = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.set_burst_mode_cmdid = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.en_stats = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.mu_group_policy = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.noise_detection = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.noise_threshold = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.dpd_enable = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.set_mcast_bcast_echo = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.atf_strict_sch = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.atf_sched_duration = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.ant_plzn = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.mgmt_retry_limit = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.sensitivity_level = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.signed_txpower_2g = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.signed_txpower_5g = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.enable_per_tid_amsdu = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.enable_per_tid_ampdu = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.cca_threshold = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.rts_fixed_rate = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.pdev_reset = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.wapi_mbssid_offset = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.arp_srcaddr = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.arp_dstaddr = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.enable_btcoex = WMI_PDEV_PARAM_UNSUPPORTED,\n};\n\nstatic struct wmi_pdev_param_map wmi_10_2_4_pdev_param_map = {\n\t.tx_chain_mask = WMI_10X_PDEV_PARAM_TX_CHAIN_MASK,\n\t.rx_chain_mask = WMI_10X_PDEV_PARAM_RX_CHAIN_MASK,\n\t.txpower_limit2g = WMI_10X_PDEV_PARAM_TXPOWER_LIMIT2G,\n\t.txpower_limit5g = WMI_10X_PDEV_PARAM_TXPOWER_LIMIT5G,\n\t.txpower_scale = WMI_10X_PDEV_PARAM_TXPOWER_SCALE,\n\t.beacon_gen_mode = WMI_10X_PDEV_PARAM_BEACON_GEN_MODE,\n\t.beacon_tx_mode = WMI_10X_PDEV_PARAM_BEACON_TX_MODE,\n\t.resmgr_offchan_mode = WMI_10X_PDEV_PARAM_RESMGR_OFFCHAN_MODE,\n\t.protection_mode = WMI_10X_PDEV_PARAM_PROTECTION_MODE,\n\t.dynamic_bw = WMI_10X_PDEV_PARAM_DYNAMIC_BW,\n\t.non_agg_sw_retry_th = WMI_10X_PDEV_PARAM_NON_AGG_SW_RETRY_TH,\n\t.agg_sw_retry_th = WMI_10X_PDEV_PARAM_AGG_SW_RETRY_TH,\n\t.sta_kickout_th = WMI_10X_PDEV_PARAM_STA_KICKOUT_TH,\n\t.ac_aggrsize_scaling = WMI_10X_PDEV_PARAM_AC_AGGRSIZE_SCALING,\n\t.ltr_enable = WMI_10X_PDEV_PARAM_LTR_ENABLE,\n\t.ltr_ac_latency_be = WMI_10X_PDEV_PARAM_LTR_AC_LATENCY_BE,\n\t.ltr_ac_latency_bk = WMI_10X_PDEV_PARAM_LTR_AC_LATENCY_BK,\n\t.ltr_ac_latency_vi = WMI_10X_PDEV_PARAM_LTR_AC_LATENCY_VI,\n\t.ltr_ac_latency_vo = WMI_10X_PDEV_PARAM_LTR_AC_LATENCY_VO,\n\t.ltr_ac_latency_timeout = WMI_10X_PDEV_PARAM_LTR_AC_LATENCY_TIMEOUT,\n\t.ltr_sleep_override = WMI_10X_PDEV_PARAM_LTR_SLEEP_OVERRIDE,\n\t.ltr_rx_override = WMI_10X_PDEV_PARAM_LTR_RX_OVERRIDE,\n\t.ltr_tx_activity_timeout = WMI_10X_PDEV_PARAM_LTR_TX_ACTIVITY_TIMEOUT,\n\t.l1ss_enable = WMI_10X_PDEV_PARAM_L1SS_ENABLE,\n\t.dsleep_enable = WMI_10X_PDEV_PARAM_DSLEEP_ENABLE,\n\t.pcielp_txbuf_flush = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.pcielp_txbuf_watermark = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.pcielp_txbuf_tmo_en = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.pcielp_txbuf_tmo_value = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.pdev_stats_update_period = WMI_10X_PDEV_PARAM_PDEV_STATS_UPDATE_PERIOD,\n\t.vdev_stats_update_period = WMI_10X_PDEV_PARAM_VDEV_STATS_UPDATE_PERIOD,\n\t.peer_stats_update_period = WMI_10X_PDEV_PARAM_PEER_STATS_UPDATE_PERIOD,\n\t.bcnflt_stats_update_period =\n\t\t\t\tWMI_10X_PDEV_PARAM_BCNFLT_STATS_UPDATE_PERIOD,\n\t.pmf_qos = WMI_10X_PDEV_PARAM_PMF_QOS,\n\t.arp_ac_override = WMI_10X_PDEV_PARAM_ARPDHCP_AC_OVERRIDE,\n\t.dcs = WMI_10X_PDEV_PARAM_DCS,\n\t.ani_enable = WMI_10X_PDEV_PARAM_ANI_ENABLE,\n\t.ani_poll_period = WMI_10X_PDEV_PARAM_ANI_POLL_PERIOD,\n\t.ani_listen_period = WMI_10X_PDEV_PARAM_ANI_LISTEN_PERIOD,\n\t.ani_ofdm_level = WMI_10X_PDEV_PARAM_ANI_OFDM_LEVEL,\n\t.ani_cck_level = WMI_10X_PDEV_PARAM_ANI_CCK_LEVEL,\n\t.dyntxchain = WMI_10X_PDEV_PARAM_DYNTXCHAIN,\n\t.proxy_sta = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.idle_ps_config = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.power_gating_sleep = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.fast_channel_reset = WMI_10X_PDEV_PARAM_FAST_CHANNEL_RESET,\n\t.burst_dur = WMI_10X_PDEV_PARAM_BURST_DUR,\n\t.burst_enable = WMI_10X_PDEV_PARAM_BURST_ENABLE,\n\t.cal_period = WMI_10X_PDEV_PARAM_CAL_PERIOD,\n\t.aggr_burst = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.rx_decap_mode = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.smart_antenna_default_antenna = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.igmpmld_override = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.igmpmld_tid = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.antenna_gain = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.rx_filter = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.set_mcast_to_ucast_tid = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.proxy_sta_mode = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.set_mcast2ucast_mode = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.set_mcast2ucast_buffer = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.remove_mcast2ucast_buffer = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.peer_sta_ps_statechg_enable =\n\t\t\t\tWMI_10X_PDEV_PARAM_PEER_STA_PS_STATECHG_ENABLE,\n\t.igmpmld_ac_override = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.block_interbss = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.set_disable_reset_cmdid = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.set_msdu_ttl_cmdid = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.set_ppdu_duration_cmdid = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.txbf_sound_period_cmdid = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.set_promisc_mode_cmdid = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.set_burst_mode_cmdid = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.en_stats = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.mu_group_policy = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.noise_detection = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.noise_threshold = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.dpd_enable = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.set_mcast_bcast_echo = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.atf_strict_sch = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.atf_sched_duration = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.ant_plzn = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.mgmt_retry_limit = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.sensitivity_level = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.signed_txpower_2g = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.signed_txpower_5g = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.enable_per_tid_amsdu = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.enable_per_tid_ampdu = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.cca_threshold = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.rts_fixed_rate = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.pdev_reset = WMI_10X_PDEV_PARAM_PDEV_RESET,\n\t.wapi_mbssid_offset = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.arp_srcaddr = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.arp_dstaddr = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.enable_btcoex = WMI_PDEV_PARAM_UNSUPPORTED,\n};\n\n \nstatic struct wmi_cmd_map wmi_10_2_cmd_map = {\n\t.init_cmdid = WMI_10_2_INIT_CMDID,\n\t.start_scan_cmdid = WMI_10_2_START_SCAN_CMDID,\n\t.stop_scan_cmdid = WMI_10_2_STOP_SCAN_CMDID,\n\t.scan_chan_list_cmdid = WMI_10_2_SCAN_CHAN_LIST_CMDID,\n\t.scan_sch_prio_tbl_cmdid = WMI_CMD_UNSUPPORTED,\n\t.scan_prob_req_oui_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_set_regdomain_cmdid = WMI_10_2_PDEV_SET_REGDOMAIN_CMDID,\n\t.pdev_set_channel_cmdid = WMI_10_2_PDEV_SET_CHANNEL_CMDID,\n\t.pdev_set_param_cmdid = WMI_10_2_PDEV_SET_PARAM_CMDID,\n\t.pdev_pktlog_enable_cmdid = WMI_10_2_PDEV_PKTLOG_ENABLE_CMDID,\n\t.pdev_pktlog_disable_cmdid = WMI_10_2_PDEV_PKTLOG_DISABLE_CMDID,\n\t.pdev_set_wmm_params_cmdid = WMI_10_2_PDEV_SET_WMM_PARAMS_CMDID,\n\t.pdev_set_ht_cap_ie_cmdid = WMI_10_2_PDEV_SET_HT_CAP_IE_CMDID,\n\t.pdev_set_vht_cap_ie_cmdid = WMI_10_2_PDEV_SET_VHT_CAP_IE_CMDID,\n\t.pdev_set_quiet_mode_cmdid = WMI_10_2_PDEV_SET_QUIET_MODE_CMDID,\n\t.pdev_green_ap_ps_enable_cmdid = WMI_10_2_PDEV_GREEN_AP_PS_ENABLE_CMDID,\n\t.pdev_get_tpc_config_cmdid = WMI_10_2_PDEV_GET_TPC_CONFIG_CMDID,\n\t.pdev_set_base_macaddr_cmdid = WMI_10_2_PDEV_SET_BASE_MACADDR_CMDID,\n\t.vdev_create_cmdid = WMI_10_2_VDEV_CREATE_CMDID,\n\t.vdev_delete_cmdid = WMI_10_2_VDEV_DELETE_CMDID,\n\t.vdev_start_request_cmdid = WMI_10_2_VDEV_START_REQUEST_CMDID,\n\t.vdev_restart_request_cmdid = WMI_10_2_VDEV_RESTART_REQUEST_CMDID,\n\t.vdev_up_cmdid = WMI_10_2_VDEV_UP_CMDID,\n\t.vdev_stop_cmdid = WMI_10_2_VDEV_STOP_CMDID,\n\t.vdev_down_cmdid = WMI_10_2_VDEV_DOWN_CMDID,\n\t.vdev_set_param_cmdid = WMI_10_2_VDEV_SET_PARAM_CMDID,\n\t.vdev_install_key_cmdid = WMI_10_2_VDEV_INSTALL_KEY_CMDID,\n\t.peer_create_cmdid = WMI_10_2_PEER_CREATE_CMDID,\n\t.peer_delete_cmdid = WMI_10_2_PEER_DELETE_CMDID,\n\t.peer_flush_tids_cmdid = WMI_10_2_PEER_FLUSH_TIDS_CMDID,\n\t.peer_set_param_cmdid = WMI_10_2_PEER_SET_PARAM_CMDID,\n\t.peer_assoc_cmdid = WMI_10_2_PEER_ASSOC_CMDID,\n\t.peer_add_wds_entry_cmdid = WMI_10_2_PEER_ADD_WDS_ENTRY_CMDID,\n\t.peer_remove_wds_entry_cmdid = WMI_10_2_PEER_REMOVE_WDS_ENTRY_CMDID,\n\t.peer_mcast_group_cmdid = WMI_10_2_PEER_MCAST_GROUP_CMDID,\n\t.bcn_tx_cmdid = WMI_10_2_BCN_TX_CMDID,\n\t.pdev_send_bcn_cmdid = WMI_10_2_PDEV_SEND_BCN_CMDID,\n\t.bcn_tmpl_cmdid = WMI_CMD_UNSUPPORTED,\n\t.bcn_filter_rx_cmdid = WMI_10_2_BCN_FILTER_RX_CMDID,\n\t.prb_req_filter_rx_cmdid = WMI_10_2_PRB_REQ_FILTER_RX_CMDID,\n\t.mgmt_tx_cmdid = WMI_10_2_MGMT_TX_CMDID,\n\t.prb_tmpl_cmdid = WMI_CMD_UNSUPPORTED,\n\t.addba_clear_resp_cmdid = WMI_10_2_ADDBA_CLEAR_RESP_CMDID,\n\t.addba_send_cmdid = WMI_10_2_ADDBA_SEND_CMDID,\n\t.addba_status_cmdid = WMI_10_2_ADDBA_STATUS_CMDID,\n\t.delba_send_cmdid = WMI_10_2_DELBA_SEND_CMDID,\n\t.addba_set_resp_cmdid = WMI_10_2_ADDBA_SET_RESP_CMDID,\n\t.send_singleamsdu_cmdid = WMI_10_2_SEND_SINGLEAMSDU_CMDID,\n\t.sta_powersave_mode_cmdid = WMI_10_2_STA_POWERSAVE_MODE_CMDID,\n\t.sta_powersave_param_cmdid = WMI_10_2_STA_POWERSAVE_PARAM_CMDID,\n\t.sta_mimo_ps_mode_cmdid = WMI_10_2_STA_MIMO_PS_MODE_CMDID,\n\t.pdev_dfs_enable_cmdid = WMI_10_2_PDEV_DFS_ENABLE_CMDID,\n\t.pdev_dfs_disable_cmdid = WMI_10_2_PDEV_DFS_DISABLE_CMDID,\n\t.roam_scan_mode = WMI_10_2_ROAM_SCAN_MODE,\n\t.roam_scan_rssi_threshold = WMI_10_2_ROAM_SCAN_RSSI_THRESHOLD,\n\t.roam_scan_period = WMI_10_2_ROAM_SCAN_PERIOD,\n\t.roam_scan_rssi_change_threshold =\n\t\t\t\tWMI_10_2_ROAM_SCAN_RSSI_CHANGE_THRESHOLD,\n\t.roam_ap_profile = WMI_10_2_ROAM_AP_PROFILE,\n\t.ofl_scan_add_ap_profile = WMI_10_2_OFL_SCAN_ADD_AP_PROFILE,\n\t.ofl_scan_remove_ap_profile = WMI_10_2_OFL_SCAN_REMOVE_AP_PROFILE,\n\t.ofl_scan_period = WMI_10_2_OFL_SCAN_PERIOD,\n\t.p2p_dev_set_device_info = WMI_10_2_P2P_DEV_SET_DEVICE_INFO,\n\t.p2p_dev_set_discoverability = WMI_10_2_P2P_DEV_SET_DISCOVERABILITY,\n\t.p2p_go_set_beacon_ie = WMI_10_2_P2P_GO_SET_BEACON_IE,\n\t.p2p_go_set_probe_resp_ie = WMI_10_2_P2P_GO_SET_PROBE_RESP_IE,\n\t.p2p_set_vendor_ie_data_cmdid = WMI_CMD_UNSUPPORTED,\n\t.ap_ps_peer_param_cmdid = WMI_10_2_AP_PS_PEER_PARAM_CMDID,\n\t.ap_ps_peer_uapsd_coex_cmdid = WMI_CMD_UNSUPPORTED,\n\t.peer_rate_retry_sched_cmdid = WMI_10_2_PEER_RATE_RETRY_SCHED_CMDID,\n\t.wlan_profile_trigger_cmdid = WMI_10_2_WLAN_PROFILE_TRIGGER_CMDID,\n\t.wlan_profile_set_hist_intvl_cmdid =\n\t\t\t\tWMI_10_2_WLAN_PROFILE_SET_HIST_INTVL_CMDID,\n\t.wlan_profile_get_profile_data_cmdid =\n\t\t\t\tWMI_10_2_WLAN_PROFILE_GET_PROFILE_DATA_CMDID,\n\t.wlan_profile_enable_profile_id_cmdid =\n\t\t\t\tWMI_10_2_WLAN_PROFILE_ENABLE_PROFILE_ID_CMDID,\n\t.wlan_profile_list_profile_id_cmdid =\n\t\t\t\tWMI_10_2_WLAN_PROFILE_LIST_PROFILE_ID_CMDID,\n\t.pdev_suspend_cmdid = WMI_10_2_PDEV_SUSPEND_CMDID,\n\t.pdev_resume_cmdid = WMI_10_2_PDEV_RESUME_CMDID,\n\t.add_bcn_filter_cmdid = WMI_10_2_ADD_BCN_FILTER_CMDID,\n\t.rmv_bcn_filter_cmdid = WMI_10_2_RMV_BCN_FILTER_CMDID,\n\t.wow_add_wake_pattern_cmdid = WMI_10_2_WOW_ADD_WAKE_PATTERN_CMDID,\n\t.wow_del_wake_pattern_cmdid = WMI_10_2_WOW_DEL_WAKE_PATTERN_CMDID,\n\t.wow_enable_disable_wake_event_cmdid =\n\t\t\t\tWMI_10_2_WOW_ENABLE_DISABLE_WAKE_EVENT_CMDID,\n\t.wow_enable_cmdid = WMI_10_2_WOW_ENABLE_CMDID,\n\t.wow_hostwakeup_from_sleep_cmdid =\n\t\t\t\tWMI_10_2_WOW_HOSTWAKEUP_FROM_SLEEP_CMDID,\n\t.rtt_measreq_cmdid = WMI_10_2_RTT_MEASREQ_CMDID,\n\t.rtt_tsf_cmdid = WMI_10_2_RTT_TSF_CMDID,\n\t.vdev_spectral_scan_configure_cmdid =\n\t\t\t\tWMI_10_2_VDEV_SPECTRAL_SCAN_CONFIGURE_CMDID,\n\t.vdev_spectral_scan_enable_cmdid =\n\t\t\t\tWMI_10_2_VDEV_SPECTRAL_SCAN_ENABLE_CMDID,\n\t.request_stats_cmdid = WMI_10_2_REQUEST_STATS_CMDID,\n\t.set_arp_ns_offload_cmdid = WMI_CMD_UNSUPPORTED,\n\t.network_list_offload_config_cmdid = WMI_CMD_UNSUPPORTED,\n\t.gtk_offload_cmdid = WMI_CMD_UNSUPPORTED,\n\t.csa_offload_enable_cmdid = WMI_CMD_UNSUPPORTED,\n\t.csa_offload_chanswitch_cmdid = WMI_CMD_UNSUPPORTED,\n\t.chatter_set_mode_cmdid = WMI_CMD_UNSUPPORTED,\n\t.peer_tid_addba_cmdid = WMI_CMD_UNSUPPORTED,\n\t.peer_tid_delba_cmdid = WMI_CMD_UNSUPPORTED,\n\t.sta_dtim_ps_method_cmdid = WMI_CMD_UNSUPPORTED,\n\t.sta_uapsd_auto_trig_cmdid = WMI_CMD_UNSUPPORTED,\n\t.sta_keepalive_cmd = WMI_CMD_UNSUPPORTED,\n\t.echo_cmdid = WMI_10_2_ECHO_CMDID,\n\t.pdev_utf_cmdid = WMI_10_2_PDEV_UTF_CMDID,\n\t.dbglog_cfg_cmdid = WMI_10_2_DBGLOG_CFG_CMDID,\n\t.pdev_qvit_cmdid = WMI_10_2_PDEV_QVIT_CMDID,\n\t.pdev_ftm_intg_cmdid = WMI_CMD_UNSUPPORTED,\n\t.vdev_set_keepalive_cmdid = WMI_CMD_UNSUPPORTED,\n\t.vdev_get_keepalive_cmdid = WMI_CMD_UNSUPPORTED,\n\t.force_fw_hang_cmdid = WMI_CMD_UNSUPPORTED,\n\t.gpio_config_cmdid = WMI_10_2_GPIO_CONFIG_CMDID,\n\t.gpio_output_cmdid = WMI_10_2_GPIO_OUTPUT_CMDID,\n\t.pdev_get_temperature_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_enable_adaptive_cca_cmdid = WMI_CMD_UNSUPPORTED,\n\t.scan_update_request_cmdid = WMI_CMD_UNSUPPORTED,\n\t.vdev_standby_response_cmdid = WMI_CMD_UNSUPPORTED,\n\t.vdev_resume_response_cmdid = WMI_CMD_UNSUPPORTED,\n\t.wlan_peer_caching_add_peer_cmdid = WMI_CMD_UNSUPPORTED,\n\t.wlan_peer_caching_evict_peer_cmdid = WMI_CMD_UNSUPPORTED,\n\t.wlan_peer_caching_restore_peer_cmdid = WMI_CMD_UNSUPPORTED,\n\t.wlan_peer_caching_print_all_peers_info_cmdid = WMI_CMD_UNSUPPORTED,\n\t.peer_update_wds_entry_cmdid = WMI_CMD_UNSUPPORTED,\n\t.peer_add_proxy_sta_entry_cmdid = WMI_CMD_UNSUPPORTED,\n\t.rtt_keepalive_cmdid = WMI_CMD_UNSUPPORTED,\n\t.oem_req_cmdid = WMI_CMD_UNSUPPORTED,\n\t.nan_cmdid = WMI_CMD_UNSUPPORTED,\n\t.vdev_ratemask_cmdid = WMI_CMD_UNSUPPORTED,\n\t.qboost_cfg_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_smart_ant_enable_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_smart_ant_set_rx_antenna_cmdid = WMI_CMD_UNSUPPORTED,\n\t.peer_smart_ant_set_tx_antenna_cmdid = WMI_CMD_UNSUPPORTED,\n\t.peer_smart_ant_set_train_info_cmdid = WMI_CMD_UNSUPPORTED,\n\t.peer_smart_ant_set_node_config_ops_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_set_antenna_switch_table_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_set_ctl_table_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_set_mimogain_table_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_ratepwr_table_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_ratepwr_chainmsk_table_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_fips_cmdid = WMI_CMD_UNSUPPORTED,\n\t.tt_set_conf_cmdid = WMI_CMD_UNSUPPORTED,\n\t.fwtest_cmdid = WMI_CMD_UNSUPPORTED,\n\t.vdev_atf_request_cmdid = WMI_CMD_UNSUPPORTED,\n\t.peer_atf_request_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_get_ani_cck_config_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_get_ani_ofdm_config_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_reserve_ast_entry_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_get_tpc_table_cmdid = WMI_CMD_UNSUPPORTED,\n\t.radar_found_cmdid = WMI_CMD_UNSUPPORTED,\n};\n\nstatic struct wmi_pdev_param_map wmi_10_4_pdev_param_map = {\n\t.tx_chain_mask = WMI_10_4_PDEV_PARAM_TX_CHAIN_MASK,\n\t.rx_chain_mask = WMI_10_4_PDEV_PARAM_RX_CHAIN_MASK,\n\t.txpower_limit2g = WMI_10_4_PDEV_PARAM_TXPOWER_LIMIT2G,\n\t.txpower_limit5g = WMI_10_4_PDEV_PARAM_TXPOWER_LIMIT5G,\n\t.txpower_scale = WMI_10_4_PDEV_PARAM_TXPOWER_SCALE,\n\t.beacon_gen_mode = WMI_10_4_PDEV_PARAM_BEACON_GEN_MODE,\n\t.beacon_tx_mode = WMI_10_4_PDEV_PARAM_BEACON_TX_MODE,\n\t.resmgr_offchan_mode = WMI_10_4_PDEV_PARAM_RESMGR_OFFCHAN_MODE,\n\t.protection_mode = WMI_10_4_PDEV_PARAM_PROTECTION_MODE,\n\t.dynamic_bw = WMI_10_4_PDEV_PARAM_DYNAMIC_BW,\n\t.non_agg_sw_retry_th = WMI_10_4_PDEV_PARAM_NON_AGG_SW_RETRY_TH,\n\t.agg_sw_retry_th = WMI_10_4_PDEV_PARAM_AGG_SW_RETRY_TH,\n\t.sta_kickout_th = WMI_10_4_PDEV_PARAM_STA_KICKOUT_TH,\n\t.ac_aggrsize_scaling = WMI_10_4_PDEV_PARAM_AC_AGGRSIZE_SCALING,\n\t.ltr_enable = WMI_10_4_PDEV_PARAM_LTR_ENABLE,\n\t.ltr_ac_latency_be = WMI_10_4_PDEV_PARAM_LTR_AC_LATENCY_BE,\n\t.ltr_ac_latency_bk = WMI_10_4_PDEV_PARAM_LTR_AC_LATENCY_BK,\n\t.ltr_ac_latency_vi = WMI_10_4_PDEV_PARAM_LTR_AC_LATENCY_VI,\n\t.ltr_ac_latency_vo = WMI_10_4_PDEV_PARAM_LTR_AC_LATENCY_VO,\n\t.ltr_ac_latency_timeout = WMI_10_4_PDEV_PARAM_LTR_AC_LATENCY_TIMEOUT,\n\t.ltr_sleep_override = WMI_10_4_PDEV_PARAM_LTR_SLEEP_OVERRIDE,\n\t.ltr_rx_override = WMI_10_4_PDEV_PARAM_LTR_RX_OVERRIDE,\n\t.ltr_tx_activity_timeout = WMI_10_4_PDEV_PARAM_LTR_TX_ACTIVITY_TIMEOUT,\n\t.l1ss_enable = WMI_10_4_PDEV_PARAM_L1SS_ENABLE,\n\t.dsleep_enable = WMI_10_4_PDEV_PARAM_DSLEEP_ENABLE,\n\t.pcielp_txbuf_flush = WMI_10_4_PDEV_PARAM_PCIELP_TXBUF_FLUSH,\n\t.pcielp_txbuf_watermark = WMI_10_4_PDEV_PARAM_PCIELP_TXBUF_WATERMARK,\n\t.pcielp_txbuf_tmo_en = WMI_10_4_PDEV_PARAM_PCIELP_TXBUF_TMO_EN,\n\t.pcielp_txbuf_tmo_value = WMI_10_4_PDEV_PARAM_PCIELP_TXBUF_TMO_VALUE,\n\t.pdev_stats_update_period =\n\t\t\tWMI_10_4_PDEV_PARAM_PDEV_STATS_UPDATE_PERIOD,\n\t.vdev_stats_update_period =\n\t\t\tWMI_10_4_PDEV_PARAM_VDEV_STATS_UPDATE_PERIOD,\n\t.peer_stats_update_period =\n\t\t\tWMI_10_4_PDEV_PARAM_PEER_STATS_UPDATE_PERIOD,\n\t.bcnflt_stats_update_period =\n\t\t\tWMI_10_4_PDEV_PARAM_BCNFLT_STATS_UPDATE_PERIOD,\n\t.pmf_qos = WMI_10_4_PDEV_PARAM_PMF_QOS,\n\t.arp_ac_override = WMI_10_4_PDEV_PARAM_ARP_AC_OVERRIDE,\n\t.dcs = WMI_10_4_PDEV_PARAM_DCS,\n\t.ani_enable = WMI_10_4_PDEV_PARAM_ANI_ENABLE,\n\t.ani_poll_period = WMI_10_4_PDEV_PARAM_ANI_POLL_PERIOD,\n\t.ani_listen_period = WMI_10_4_PDEV_PARAM_ANI_LISTEN_PERIOD,\n\t.ani_ofdm_level = WMI_10_4_PDEV_PARAM_ANI_OFDM_LEVEL,\n\t.ani_cck_level = WMI_10_4_PDEV_PARAM_ANI_CCK_LEVEL,\n\t.dyntxchain = WMI_10_4_PDEV_PARAM_DYNTXCHAIN,\n\t.proxy_sta = WMI_10_4_PDEV_PARAM_PROXY_STA,\n\t.idle_ps_config = WMI_10_4_PDEV_PARAM_IDLE_PS_CONFIG,\n\t.power_gating_sleep = WMI_10_4_PDEV_PARAM_POWER_GATING_SLEEP,\n\t.fast_channel_reset = WMI_10_4_PDEV_PARAM_FAST_CHANNEL_RESET,\n\t.burst_dur = WMI_10_4_PDEV_PARAM_BURST_DUR,\n\t.burst_enable = WMI_10_4_PDEV_PARAM_BURST_ENABLE,\n\t.cal_period = WMI_10_4_PDEV_PARAM_CAL_PERIOD,\n\t.aggr_burst = WMI_10_4_PDEV_PARAM_AGGR_BURST,\n\t.rx_decap_mode = WMI_10_4_PDEV_PARAM_RX_DECAP_MODE,\n\t.smart_antenna_default_antenna =\n\t\t\tWMI_10_4_PDEV_PARAM_SMART_ANTENNA_DEFAULT_ANTENNA,\n\t.igmpmld_override = WMI_10_4_PDEV_PARAM_IGMPMLD_OVERRIDE,\n\t.igmpmld_tid = WMI_10_4_PDEV_PARAM_IGMPMLD_TID,\n\t.antenna_gain = WMI_10_4_PDEV_PARAM_ANTENNA_GAIN,\n\t.rx_filter = WMI_10_4_PDEV_PARAM_RX_FILTER,\n\t.set_mcast_to_ucast_tid = WMI_10_4_PDEV_SET_MCAST_TO_UCAST_TID,\n\t.proxy_sta_mode = WMI_10_4_PDEV_PARAM_PROXY_STA_MODE,\n\t.set_mcast2ucast_mode = WMI_10_4_PDEV_PARAM_SET_MCAST2UCAST_MODE,\n\t.set_mcast2ucast_buffer = WMI_10_4_PDEV_PARAM_SET_MCAST2UCAST_BUFFER,\n\t.remove_mcast2ucast_buffer =\n\t\t\tWMI_10_4_PDEV_PARAM_REMOVE_MCAST2UCAST_BUFFER,\n\t.peer_sta_ps_statechg_enable =\n\t\t\tWMI_10_4_PDEV_PEER_STA_PS_STATECHG_ENABLE,\n\t.igmpmld_ac_override = WMI_10_4_PDEV_PARAM_IGMPMLD_AC_OVERRIDE,\n\t.block_interbss = WMI_10_4_PDEV_PARAM_BLOCK_INTERBSS,\n\t.set_disable_reset_cmdid = WMI_10_4_PDEV_PARAM_SET_DISABLE_RESET_CMDID,\n\t.set_msdu_ttl_cmdid = WMI_10_4_PDEV_PARAM_SET_MSDU_TTL_CMDID,\n\t.set_ppdu_duration_cmdid = WMI_10_4_PDEV_PARAM_SET_PPDU_DURATION_CMDID,\n\t.txbf_sound_period_cmdid = WMI_10_4_PDEV_PARAM_TXBF_SOUND_PERIOD_CMDID,\n\t.set_promisc_mode_cmdid = WMI_10_4_PDEV_PARAM_SET_PROMISC_MODE_CMDID,\n\t.set_burst_mode_cmdid = WMI_10_4_PDEV_PARAM_SET_BURST_MODE_CMDID,\n\t.en_stats = WMI_10_4_PDEV_PARAM_EN_STATS,\n\t.mu_group_policy = WMI_10_4_PDEV_PARAM_MU_GROUP_POLICY,\n\t.noise_detection = WMI_10_4_PDEV_PARAM_NOISE_DETECTION,\n\t.noise_threshold = WMI_10_4_PDEV_PARAM_NOISE_THRESHOLD,\n\t.dpd_enable = WMI_10_4_PDEV_PARAM_DPD_ENABLE,\n\t.set_mcast_bcast_echo = WMI_10_4_PDEV_PARAM_SET_MCAST_BCAST_ECHO,\n\t.atf_strict_sch = WMI_10_4_PDEV_PARAM_ATF_STRICT_SCH,\n\t.atf_sched_duration = WMI_10_4_PDEV_PARAM_ATF_SCHED_DURATION,\n\t.ant_plzn = WMI_10_4_PDEV_PARAM_ANT_PLZN,\n\t.mgmt_retry_limit = WMI_10_4_PDEV_PARAM_MGMT_RETRY_LIMIT,\n\t.sensitivity_level = WMI_10_4_PDEV_PARAM_SENSITIVITY_LEVEL,\n\t.signed_txpower_2g = WMI_10_4_PDEV_PARAM_SIGNED_TXPOWER_2G,\n\t.signed_txpower_5g = WMI_10_4_PDEV_PARAM_SIGNED_TXPOWER_5G,\n\t.enable_per_tid_amsdu = WMI_10_4_PDEV_PARAM_ENABLE_PER_TID_AMSDU,\n\t.enable_per_tid_ampdu = WMI_10_4_PDEV_PARAM_ENABLE_PER_TID_AMPDU,\n\t.cca_threshold = WMI_10_4_PDEV_PARAM_CCA_THRESHOLD,\n\t.rts_fixed_rate = WMI_10_4_PDEV_PARAM_RTS_FIXED_RATE,\n\t.pdev_reset = WMI_10_4_PDEV_PARAM_PDEV_RESET,\n\t.wapi_mbssid_offset = WMI_10_4_PDEV_PARAM_WAPI_MBSSID_OFFSET,\n\t.arp_srcaddr = WMI_10_4_PDEV_PARAM_ARP_SRCADDR,\n\t.arp_dstaddr = WMI_10_4_PDEV_PARAM_ARP_DSTADDR,\n\t.enable_btcoex = WMI_10_4_PDEV_PARAM_ENABLE_BTCOEX,\n};\n\nstatic const u8 wmi_key_cipher_suites[] = {\n\t[WMI_CIPHER_NONE] = WMI_CIPHER_NONE,\n\t[WMI_CIPHER_WEP] = WMI_CIPHER_WEP,\n\t[WMI_CIPHER_TKIP] = WMI_CIPHER_TKIP,\n\t[WMI_CIPHER_AES_OCB] = WMI_CIPHER_AES_OCB,\n\t[WMI_CIPHER_AES_CCM] = WMI_CIPHER_AES_CCM,\n\t[WMI_CIPHER_WAPI] = WMI_CIPHER_WAPI,\n\t[WMI_CIPHER_CKIP] = WMI_CIPHER_CKIP,\n\t[WMI_CIPHER_AES_CMAC] = WMI_CIPHER_AES_CMAC,\n\t[WMI_CIPHER_AES_GCM] = WMI_CIPHER_AES_GCM,\n};\n\nstatic const u8 wmi_tlv_key_cipher_suites[] = {\n\t[WMI_CIPHER_NONE] = WMI_TLV_CIPHER_NONE,\n\t[WMI_CIPHER_WEP] = WMI_TLV_CIPHER_WEP,\n\t[WMI_CIPHER_TKIP] = WMI_TLV_CIPHER_TKIP,\n\t[WMI_CIPHER_AES_OCB] = WMI_TLV_CIPHER_AES_OCB,\n\t[WMI_CIPHER_AES_CCM] = WMI_TLV_CIPHER_AES_CCM,\n\t[WMI_CIPHER_WAPI] = WMI_TLV_CIPHER_WAPI,\n\t[WMI_CIPHER_CKIP] = WMI_TLV_CIPHER_CKIP,\n\t[WMI_CIPHER_AES_CMAC] = WMI_TLV_CIPHER_AES_CMAC,\n\t[WMI_CIPHER_AES_GCM] = WMI_TLV_CIPHER_AES_GCM,\n};\n\nstatic const struct wmi_peer_flags_map wmi_peer_flags_map = {\n\t.auth = WMI_PEER_AUTH,\n\t.qos = WMI_PEER_QOS,\n\t.need_ptk_4_way = WMI_PEER_NEED_PTK_4_WAY,\n\t.need_gtk_2_way = WMI_PEER_NEED_GTK_2_WAY,\n\t.apsd = WMI_PEER_APSD,\n\t.ht = WMI_PEER_HT,\n\t.bw40 = WMI_PEER_40MHZ,\n\t.stbc = WMI_PEER_STBC,\n\t.ldbc = WMI_PEER_LDPC,\n\t.dyn_mimops = WMI_PEER_DYN_MIMOPS,\n\t.static_mimops = WMI_PEER_STATIC_MIMOPS,\n\t.spatial_mux = WMI_PEER_SPATIAL_MUX,\n\t.vht = WMI_PEER_VHT,\n\t.bw80 = WMI_PEER_80MHZ,\n\t.vht_2g = WMI_PEER_VHT_2G,\n\t.pmf = WMI_PEER_PMF,\n\t.bw160 = WMI_PEER_160MHZ,\n};\n\nstatic const struct wmi_peer_flags_map wmi_10x_peer_flags_map = {\n\t.auth = WMI_10X_PEER_AUTH,\n\t.qos = WMI_10X_PEER_QOS,\n\t.need_ptk_4_way = WMI_10X_PEER_NEED_PTK_4_WAY,\n\t.need_gtk_2_way = WMI_10X_PEER_NEED_GTK_2_WAY,\n\t.apsd = WMI_10X_PEER_APSD,\n\t.ht = WMI_10X_PEER_HT,\n\t.bw40 = WMI_10X_PEER_40MHZ,\n\t.stbc = WMI_10X_PEER_STBC,\n\t.ldbc = WMI_10X_PEER_LDPC,\n\t.dyn_mimops = WMI_10X_PEER_DYN_MIMOPS,\n\t.static_mimops = WMI_10X_PEER_STATIC_MIMOPS,\n\t.spatial_mux = WMI_10X_PEER_SPATIAL_MUX,\n\t.vht = WMI_10X_PEER_VHT,\n\t.bw80 = WMI_10X_PEER_80MHZ,\n\t.bw160 = WMI_10X_PEER_160MHZ,\n};\n\nstatic const struct wmi_peer_flags_map wmi_10_2_peer_flags_map = {\n\t.auth = WMI_10_2_PEER_AUTH,\n\t.qos = WMI_10_2_PEER_QOS,\n\t.need_ptk_4_way = WMI_10_2_PEER_NEED_PTK_4_WAY,\n\t.need_gtk_2_way = WMI_10_2_PEER_NEED_GTK_2_WAY,\n\t.apsd = WMI_10_2_PEER_APSD,\n\t.ht = WMI_10_2_PEER_HT,\n\t.bw40 = WMI_10_2_PEER_40MHZ,\n\t.stbc = WMI_10_2_PEER_STBC,\n\t.ldbc = WMI_10_2_PEER_LDPC,\n\t.dyn_mimops = WMI_10_2_PEER_DYN_MIMOPS,\n\t.static_mimops = WMI_10_2_PEER_STATIC_MIMOPS,\n\t.spatial_mux = WMI_10_2_PEER_SPATIAL_MUX,\n\t.vht = WMI_10_2_PEER_VHT,\n\t.bw80 = WMI_10_2_PEER_80MHZ,\n\t.vht_2g = WMI_10_2_PEER_VHT_2G,\n\t.pmf = WMI_10_2_PEER_PMF,\n\t.bw160 = WMI_10_2_PEER_160MHZ,\n};\n\nvoid ath10k_wmi_put_wmi_channel(struct ath10k *ar, struct wmi_channel *ch,\n\t\t\t\tconst struct wmi_channel_arg *arg)\n{\n\tu32 flags = 0;\n\tstruct ieee80211_channel *chan = NULL;\n\n\tmemset(ch, 0, sizeof(*ch));\n\n\tif (arg->passive)\n\t\tflags |= WMI_CHAN_FLAG_PASSIVE;\n\tif (arg->allow_ibss)\n\t\tflags |= WMI_CHAN_FLAG_ADHOC_ALLOWED;\n\tif (arg->allow_ht)\n\t\tflags |= WMI_CHAN_FLAG_ALLOW_HT;\n\tif (arg->allow_vht)\n\t\tflags |= WMI_CHAN_FLAG_ALLOW_VHT;\n\tif (arg->ht40plus)\n\t\tflags |= WMI_CHAN_FLAG_HT40_PLUS;\n\tif (arg->chan_radar)\n\t\tflags |= WMI_CHAN_FLAG_DFS;\n\n\tch->band_center_freq2 = 0;\n\tch->mhz = __cpu_to_le32(arg->freq);\n\tch->band_center_freq1 = __cpu_to_le32(arg->band_center_freq1);\n\tif (arg->mode == MODE_11AC_VHT80_80) {\n\t\tch->band_center_freq2 = __cpu_to_le32(arg->band_center_freq2);\n\t\tchan = ieee80211_get_channel(ar->hw->wiphy,\n\t\t\t\t\t     arg->band_center_freq2 - 10);\n\t}\n\n\tif (arg->mode == MODE_11AC_VHT160) {\n\t\tu32 band_center_freq1;\n\t\tu32 band_center_freq2;\n\n\t\tif (arg->freq > arg->band_center_freq1) {\n\t\t\tband_center_freq1 = arg->band_center_freq1 + 40;\n\t\t\tband_center_freq2 = arg->band_center_freq1 - 40;\n\t\t} else {\n\t\t\tband_center_freq1 = arg->band_center_freq1 - 40;\n\t\t\tband_center_freq2 = arg->band_center_freq1 + 40;\n\t\t}\n\n\t\tch->band_center_freq1 =\n\t\t\t\t\t__cpu_to_le32(band_center_freq1);\n\t\t \n\t\tchan = ieee80211_get_channel(ar->hw->wiphy,\n\t\t\t\t\t     band_center_freq2 - 10);\n\t\t \n\t\tch->band_center_freq2 = __cpu_to_le32(arg->band_center_freq1);\n\t}\n\n\tif (chan && chan->flags & IEEE80211_CHAN_RADAR)\n\t\tflags |= WMI_CHAN_FLAG_DFS_CFREQ2;\n\n\tch->min_power = arg->min_power;\n\tch->max_power = arg->max_power;\n\tch->reg_power = arg->max_reg_power;\n\tch->antenna_max = arg->max_antenna_gain;\n\tch->max_tx_power = arg->max_power;\n\n\t \n\tch->mode = arg->mode;\n\tch->flags |= __cpu_to_le32(flags);\n}\n\nint ath10k_wmi_wait_for_service_ready(struct ath10k *ar)\n{\n\tunsigned long time_left;\n\n\ttime_left = wait_for_completion_timeout(&ar->wmi.service_ready,\n\t\t\t\t\t\tWMI_SERVICE_READY_TIMEOUT_HZ);\n\tif (!time_left)\n\t\treturn -ETIMEDOUT;\n\treturn 0;\n}\n\nint ath10k_wmi_wait_for_unified_ready(struct ath10k *ar)\n{\n\tunsigned long time_left;\n\n\ttime_left = wait_for_completion_timeout(&ar->wmi.unified_ready,\n\t\t\t\t\t\tWMI_UNIFIED_READY_TIMEOUT_HZ);\n\tif (!time_left)\n\t\treturn -ETIMEDOUT;\n\treturn 0;\n}\n\nstruct sk_buff *ath10k_wmi_alloc_skb(struct ath10k *ar, u32 len)\n{\n\tstruct sk_buff *skb;\n\tu32 round_len = roundup(len, 4);\n\n\tskb = ath10k_htc_alloc_skb(ar, WMI_SKB_HEADROOM + round_len);\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, WMI_SKB_HEADROOM);\n\tif (!IS_ALIGNED((unsigned long)skb->data, 4))\n\t\tath10k_warn(ar, \"Unaligned WMI skb\\n\");\n\n\tskb_put(skb, round_len);\n\tmemset(skb->data, 0, round_len);\n\n\treturn skb;\n}\n\nstatic void ath10k_wmi_htc_tx_complete(struct ath10k *ar, struct sk_buff *skb)\n{\n\tdev_kfree_skb(skb);\n}\n\nint ath10k_wmi_cmd_send_nowait(struct ath10k *ar, struct sk_buff *skb,\n\t\t\t       u32 cmd_id)\n{\n\tstruct ath10k_skb_cb *skb_cb = ATH10K_SKB_CB(skb);\n\tstruct wmi_cmd_hdr *cmd_hdr;\n\tint ret;\n\tu32 cmd = 0;\n\n\tif (skb_push(skb, sizeof(struct wmi_cmd_hdr)) == NULL)\n\t\treturn -ENOMEM;\n\n\tcmd |= SM(cmd_id, WMI_CMD_HDR_CMD_ID);\n\n\tcmd_hdr = (struct wmi_cmd_hdr *)skb->data;\n\tcmd_hdr->cmd_id = __cpu_to_le32(cmd);\n\n\tmemset(skb_cb, 0, sizeof(*skb_cb));\n\ttrace_ath10k_wmi_cmd(ar, cmd_id, skb->data, skb->len);\n\tret = ath10k_htc_send(&ar->htc, ar->wmi.eid, skb);\n\n\tif (ret)\n\t\tgoto err_pull;\n\n\treturn 0;\n\nerr_pull:\n\tskb_pull(skb, sizeof(struct wmi_cmd_hdr));\n\treturn ret;\n}\n\nstatic void ath10k_wmi_tx_beacon_nowait(struct ath10k_vif *arvif)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tstruct ath10k_skb_cb *cb;\n\tstruct sk_buff *bcn;\n\tbool dtim_zero;\n\tbool deliver_cab;\n\tint ret;\n\n\tspin_lock_bh(&ar->data_lock);\n\n\tbcn = arvif->beacon;\n\n\tif (!bcn)\n\t\tgoto unlock;\n\n\tcb = ATH10K_SKB_CB(bcn);\n\n\tswitch (arvif->beacon_state) {\n\tcase ATH10K_BEACON_SENDING:\n\tcase ATH10K_BEACON_SENT:\n\t\tbreak;\n\tcase ATH10K_BEACON_SCHEDULED:\n\t\tarvif->beacon_state = ATH10K_BEACON_SENDING;\n\t\tspin_unlock_bh(&ar->data_lock);\n\n\t\tdtim_zero = !!(cb->flags & ATH10K_SKB_F_DTIM_ZERO);\n\t\tdeliver_cab = !!(cb->flags & ATH10K_SKB_F_DELIVER_CAB);\n\t\tret = ath10k_wmi_beacon_send_ref_nowait(arvif->ar,\n\t\t\t\t\t\t\tarvif->vdev_id,\n\t\t\t\t\t\t\tbcn->data, bcn->len,\n\t\t\t\t\t\t\tcb->paddr,\n\t\t\t\t\t\t\tdtim_zero,\n\t\t\t\t\t\t\tdeliver_cab);\n\n\t\tspin_lock_bh(&ar->data_lock);\n\n\t\tif (ret == 0)\n\t\t\tarvif->beacon_state = ATH10K_BEACON_SENT;\n\t\telse\n\t\t\tarvif->beacon_state = ATH10K_BEACON_SCHEDULED;\n\t}\n\nunlock:\n\tspin_unlock_bh(&ar->data_lock);\n}\n\nstatic void ath10k_wmi_tx_beacons_iter(void *data, u8 *mac,\n\t\t\t\t       struct ieee80211_vif *vif)\n{\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\n\tath10k_wmi_tx_beacon_nowait(arvif);\n}\n\nstatic void ath10k_wmi_tx_beacons_nowait(struct ath10k *ar)\n{\n\tieee80211_iterate_active_interfaces_atomic(ar->hw,\n\t\t\t\t\t\t   ATH10K_ITER_NORMAL_FLAGS,\n\t\t\t\t\t\t   ath10k_wmi_tx_beacons_iter,\n\t\t\t\t\t\t   NULL);\n}\n\nstatic void ath10k_wmi_op_ep_tx_credits(struct ath10k *ar)\n{\n\t \n\tath10k_wmi_tx_beacons_nowait(ar);\n\n\twake_up(&ar->wmi.tx_credits_wq);\n}\n\nint ath10k_wmi_cmd_send(struct ath10k *ar, struct sk_buff *skb, u32 cmd_id)\n{\n\tint ret = -EOPNOTSUPP;\n\n\tmight_sleep();\n\n\tif (cmd_id == WMI_CMD_UNSUPPORTED) {\n\t\tath10k_warn(ar, \"wmi command %d is not supported by firmware\\n\",\n\t\t\t    cmd_id);\n\t\treturn ret;\n\t}\n\n\twait_event_timeout(ar->wmi.tx_credits_wq, ({\n\t\t \n\t\tath10k_wmi_tx_beacons_nowait(ar);\n\n\t\tret = ath10k_wmi_cmd_send_nowait(ar, skb, cmd_id);\n\n\t\tif (ret && test_bit(ATH10K_FLAG_CRASH_FLUSH, &ar->dev_flags))\n\t\t\tret = -ESHUTDOWN;\n\n\t\t(ret != -EAGAIN);\n\t}), 3 * HZ);\n\n\tif (ret)\n\t\tdev_kfree_skb_any(skb);\n\n\tif (ret == -EAGAIN) {\n\t\tath10k_warn(ar, \"wmi command %d timeout, restarting hardware\\n\",\n\t\t\t    cmd_id);\n\t\tath10k_core_start_recovery(ar);\n\t}\n\n\treturn ret;\n}\n\nstatic struct sk_buff *\nath10k_wmi_op_gen_mgmt_tx(struct ath10k *ar, struct sk_buff *msdu)\n{\n\tstruct ath10k_skb_cb *cb = ATH10K_SKB_CB(msdu);\n\tstruct ath10k_vif *arvif;\n\tstruct wmi_mgmt_tx_cmd *cmd;\n\tstruct ieee80211_hdr *hdr;\n\tstruct sk_buff *skb;\n\tint len;\n\tu32 vdev_id;\n\tu32 buf_len = msdu->len;\n\tu16 fc;\n\tconst u8 *peer_addr;\n\n\thdr = (struct ieee80211_hdr *)msdu->data;\n\tfc = le16_to_cpu(hdr->frame_control);\n\n\tif (cb->vif) {\n\t\tarvif = (void *)cb->vif->drv_priv;\n\t\tvdev_id = arvif->vdev_id;\n\t} else {\n\t\tvdev_id = 0;\n\t}\n\n\tif (WARN_ON_ONCE(!ieee80211_is_mgmt(hdr->frame_control)))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tlen = sizeof(cmd->hdr) + msdu->len;\n\n\tif ((ieee80211_is_action(hdr->frame_control) ||\n\t     ieee80211_is_deauth(hdr->frame_control) ||\n\t     ieee80211_is_disassoc(hdr->frame_control)) &&\n\t     ieee80211_has_protected(hdr->frame_control)) {\n\t\tpeer_addr = hdr->addr1;\n\t\tif (is_multicast_ether_addr(peer_addr)) {\n\t\t\tlen += sizeof(struct ieee80211_mmie_16);\n\t\t\tbuf_len += sizeof(struct ieee80211_mmie_16);\n\t\t} else {\n\t\t\tif (cb->ucast_cipher == WLAN_CIPHER_SUITE_GCMP ||\n\t\t\t    cb->ucast_cipher == WLAN_CIPHER_SUITE_GCMP_256) {\n\t\t\t\tlen += IEEE80211_GCMP_MIC_LEN;\n\t\t\t\tbuf_len += IEEE80211_GCMP_MIC_LEN;\n\t\t\t} else {\n\t\t\t\tlen += IEEE80211_CCMP_MIC_LEN;\n\t\t\t\tbuf_len += IEEE80211_CCMP_MIC_LEN;\n\t\t\t}\n\t\t}\n\t}\n\n\tlen = round_up(len, 4);\n\n\tskb = ath10k_wmi_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_mgmt_tx_cmd *)skb->data;\n\n\tcmd->hdr.vdev_id = __cpu_to_le32(vdev_id);\n\tcmd->hdr.tx_rate = 0;\n\tcmd->hdr.tx_power = 0;\n\tcmd->hdr.buf_len = __cpu_to_le32(buf_len);\n\n\tether_addr_copy(cmd->hdr.peer_macaddr.addr, ieee80211_get_DA(hdr));\n\tmemcpy(cmd->buf, msdu->data, msdu->len);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi mgmt tx skb %pK len %d ftype %02x stype %02x\\n\",\n\t\t   msdu, skb->len, fc & IEEE80211_FCTL_FTYPE,\n\t\t   fc & IEEE80211_FCTL_STYPE);\n\ttrace_ath10k_tx_hdr(ar, skb->data, skb->len);\n\ttrace_ath10k_tx_payload(ar, skb->data, skb->len);\n\n\treturn skb;\n}\n\nstatic void ath10k_wmi_event_scan_started(struct ath10k *ar)\n{\n\tlockdep_assert_held(&ar->data_lock);\n\n\tswitch (ar->scan.state) {\n\tcase ATH10K_SCAN_IDLE:\n\tcase ATH10K_SCAN_RUNNING:\n\tcase ATH10K_SCAN_ABORTING:\n\t\tath10k_warn(ar, \"received scan started event in an invalid scan state: %s (%d)\\n\",\n\t\t\t    ath10k_scan_state_str(ar->scan.state),\n\t\t\t    ar->scan.state);\n\t\tbreak;\n\tcase ATH10K_SCAN_STARTING:\n\t\tar->scan.state = ATH10K_SCAN_RUNNING;\n\n\t\tif (ar->scan.is_roc)\n\t\t\tieee80211_ready_on_channel(ar->hw);\n\n\t\tcomplete(&ar->scan.started);\n\t\tbreak;\n\t}\n}\n\nstatic void ath10k_wmi_event_scan_start_failed(struct ath10k *ar)\n{\n\tlockdep_assert_held(&ar->data_lock);\n\n\tswitch (ar->scan.state) {\n\tcase ATH10K_SCAN_IDLE:\n\tcase ATH10K_SCAN_RUNNING:\n\tcase ATH10K_SCAN_ABORTING:\n\t\tath10k_warn(ar, \"received scan start failed event in an invalid scan state: %s (%d)\\n\",\n\t\t\t    ath10k_scan_state_str(ar->scan.state),\n\t\t\t    ar->scan.state);\n\t\tbreak;\n\tcase ATH10K_SCAN_STARTING:\n\t\tcomplete(&ar->scan.started);\n\t\t__ath10k_scan_finish(ar);\n\t\tbreak;\n\t}\n}\n\nstatic void ath10k_wmi_event_scan_completed(struct ath10k *ar)\n{\n\tlockdep_assert_held(&ar->data_lock);\n\n\tswitch (ar->scan.state) {\n\tcase ATH10K_SCAN_IDLE:\n\tcase ATH10K_SCAN_STARTING:\n\t\t \n\t\tath10k_warn(ar, \"received scan completed event in an invalid scan state: %s (%d)\\n\",\n\t\t\t    ath10k_scan_state_str(ar->scan.state),\n\t\t\t    ar->scan.state);\n\t\tbreak;\n\tcase ATH10K_SCAN_RUNNING:\n\tcase ATH10K_SCAN_ABORTING:\n\t\t__ath10k_scan_finish(ar);\n\t\tbreak;\n\t}\n}\n\nstatic void ath10k_wmi_event_scan_bss_chan(struct ath10k *ar)\n{\n\tlockdep_assert_held(&ar->data_lock);\n\n\tswitch (ar->scan.state) {\n\tcase ATH10K_SCAN_IDLE:\n\tcase ATH10K_SCAN_STARTING:\n\t\tath10k_warn(ar, \"received scan bss chan event in an invalid scan state: %s (%d)\\n\",\n\t\t\t    ath10k_scan_state_str(ar->scan.state),\n\t\t\t    ar->scan.state);\n\t\tbreak;\n\tcase ATH10K_SCAN_RUNNING:\n\tcase ATH10K_SCAN_ABORTING:\n\t\tar->scan_channel = NULL;\n\t\tbreak;\n\t}\n}\n\nstatic void ath10k_wmi_event_scan_foreign_chan(struct ath10k *ar, u32 freq)\n{\n\tlockdep_assert_held(&ar->data_lock);\n\n\tswitch (ar->scan.state) {\n\tcase ATH10K_SCAN_IDLE:\n\tcase ATH10K_SCAN_STARTING:\n\t\tath10k_warn(ar, \"received scan foreign chan event in an invalid scan state: %s (%d)\\n\",\n\t\t\t    ath10k_scan_state_str(ar->scan.state),\n\t\t\t    ar->scan.state);\n\t\tbreak;\n\tcase ATH10K_SCAN_RUNNING:\n\tcase ATH10K_SCAN_ABORTING:\n\t\tar->scan_channel = ieee80211_get_channel(ar->hw->wiphy, freq);\n\n\t\tif (ar->scan.is_roc && ar->scan.roc_freq == freq)\n\t\t\tcomplete(&ar->scan.on_channel);\n\t\tbreak;\n\t}\n}\n\nstatic const char *\nath10k_wmi_event_scan_type_str(enum wmi_scan_event_type type,\n\t\t\t       enum wmi_scan_completion_reason reason)\n{\n\tswitch (type) {\n\tcase WMI_SCAN_EVENT_STARTED:\n\t\treturn \"started\";\n\tcase WMI_SCAN_EVENT_COMPLETED:\n\t\tswitch (reason) {\n\t\tcase WMI_SCAN_REASON_COMPLETED:\n\t\t\treturn \"completed\";\n\t\tcase WMI_SCAN_REASON_CANCELLED:\n\t\t\treturn \"completed [cancelled]\";\n\t\tcase WMI_SCAN_REASON_PREEMPTED:\n\t\t\treturn \"completed [preempted]\";\n\t\tcase WMI_SCAN_REASON_TIMEDOUT:\n\t\t\treturn \"completed [timedout]\";\n\t\tcase WMI_SCAN_REASON_INTERNAL_FAILURE:\n\t\t\treturn \"completed [internal err]\";\n\t\tcase WMI_SCAN_REASON_MAX:\n\t\t\tbreak;\n\t\t}\n\t\treturn \"completed [unknown]\";\n\tcase WMI_SCAN_EVENT_BSS_CHANNEL:\n\t\treturn \"bss channel\";\n\tcase WMI_SCAN_EVENT_FOREIGN_CHANNEL:\n\t\treturn \"foreign channel\";\n\tcase WMI_SCAN_EVENT_DEQUEUED:\n\t\treturn \"dequeued\";\n\tcase WMI_SCAN_EVENT_PREEMPTED:\n\t\treturn \"preempted\";\n\tcase WMI_SCAN_EVENT_START_FAILED:\n\t\treturn \"start failed\";\n\tcase WMI_SCAN_EVENT_RESTARTED:\n\t\treturn \"restarted\";\n\tcase WMI_SCAN_EVENT_FOREIGN_CHANNEL_EXIT:\n\t\treturn \"foreign channel exit\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\nstatic int ath10k_wmi_op_pull_scan_ev(struct ath10k *ar, struct sk_buff *skb,\n\t\t\t\t      struct wmi_scan_ev_arg *arg)\n{\n\tstruct wmi_scan_event *ev = (void *)skb->data;\n\n\tif (skb->len < sizeof(*ev))\n\t\treturn -EPROTO;\n\n\tskb_pull(skb, sizeof(*ev));\n\targ->event_type = ev->event_type;\n\targ->reason = ev->reason;\n\targ->channel_freq = ev->channel_freq;\n\targ->scan_req_id = ev->scan_req_id;\n\targ->scan_id = ev->scan_id;\n\targ->vdev_id = ev->vdev_id;\n\n\treturn 0;\n}\n\nint ath10k_wmi_event_scan(struct ath10k *ar, struct sk_buff *skb)\n{\n\tstruct wmi_scan_ev_arg arg = {};\n\tenum wmi_scan_event_type event_type;\n\tenum wmi_scan_completion_reason reason;\n\tu32 freq;\n\tu32 req_id;\n\tu32 scan_id;\n\tu32 vdev_id;\n\tint ret;\n\n\tret = ath10k_wmi_pull_scan(ar, skb, &arg);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to parse scan event: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tevent_type = __le32_to_cpu(arg.event_type);\n\treason = __le32_to_cpu(arg.reason);\n\tfreq = __le32_to_cpu(arg.channel_freq);\n\treq_id = __le32_to_cpu(arg.scan_req_id);\n\tscan_id = __le32_to_cpu(arg.scan_id);\n\tvdev_id = __le32_to_cpu(arg.vdev_id);\n\n\tspin_lock_bh(&ar->data_lock);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"scan event %s type %d reason %d freq %d req_id %d scan_id %d vdev_id %d state %s (%d)\\n\",\n\t\t   ath10k_wmi_event_scan_type_str(event_type, reason),\n\t\t   event_type, reason, freq, req_id, scan_id, vdev_id,\n\t\t   ath10k_scan_state_str(ar->scan.state), ar->scan.state);\n\n\tswitch (event_type) {\n\tcase WMI_SCAN_EVENT_STARTED:\n\t\tath10k_wmi_event_scan_started(ar);\n\t\tbreak;\n\tcase WMI_SCAN_EVENT_COMPLETED:\n\t\tath10k_wmi_event_scan_completed(ar);\n\t\tbreak;\n\tcase WMI_SCAN_EVENT_BSS_CHANNEL:\n\t\tath10k_wmi_event_scan_bss_chan(ar);\n\t\tbreak;\n\tcase WMI_SCAN_EVENT_FOREIGN_CHANNEL:\n\t\tath10k_wmi_event_scan_foreign_chan(ar, freq);\n\t\tbreak;\n\tcase WMI_SCAN_EVENT_START_FAILED:\n\t\tath10k_warn(ar, \"received scan start failure event\\n\");\n\t\tath10k_wmi_event_scan_start_failed(ar);\n\t\tbreak;\n\tcase WMI_SCAN_EVENT_DEQUEUED:\n\tcase WMI_SCAN_EVENT_PREEMPTED:\n\tcase WMI_SCAN_EVENT_RESTARTED:\n\tcase WMI_SCAN_EVENT_FOREIGN_CHANNEL_EXIT:\n\tdefault:\n\t\tbreak;\n\t}\n\n\tspin_unlock_bh(&ar->data_lock);\n\treturn 0;\n}\n\n \nstatic void ath10k_wmi_handle_wep_reauth(struct ath10k *ar,\n\t\t\t\t\t struct sk_buff *skb,\n\t\t\t\t\t struct ieee80211_rx_status *status)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tunsigned int hdrlen;\n\tbool peer_key;\n\tu8 *addr, keyidx;\n\n\tif (!ieee80211_is_auth(hdr->frame_control) ||\n\t    !ieee80211_has_protected(hdr->frame_control))\n\t\treturn;\n\n\thdrlen = ieee80211_hdrlen(hdr->frame_control);\n\tif (skb->len < (hdrlen + IEEE80211_WEP_IV_LEN))\n\t\treturn;\n\n\tkeyidx = skb->data[hdrlen + (IEEE80211_WEP_IV_LEN - 1)] >> WEP_KEYID_SHIFT;\n\taddr = ieee80211_get_SA(hdr);\n\n\tspin_lock_bh(&ar->data_lock);\n\tpeer_key = ath10k_mac_is_peer_wep_key_set(ar, addr, keyidx);\n\tspin_unlock_bh(&ar->data_lock);\n\n\tif (peer_key) {\n\t\tath10k_dbg(ar, ATH10K_DBG_MAC,\n\t\t\t   \"mac wep key present for peer %pM\\n\", addr);\n\t\tstatus->flag |= RX_FLAG_DECRYPTED;\n\t}\n}\n\nstatic int ath10k_wmi_op_pull_mgmt_rx_ev(struct ath10k *ar, struct sk_buff *skb,\n\t\t\t\t\t struct wmi_mgmt_rx_ev_arg *arg)\n{\n\tstruct wmi_mgmt_rx_event_v1 *ev_v1;\n\tstruct wmi_mgmt_rx_event_v2 *ev_v2;\n\tstruct wmi_mgmt_rx_hdr_v1 *ev_hdr;\n\tstruct wmi_mgmt_rx_ext_info *ext_info;\n\tsize_t pull_len;\n\tu32 msdu_len;\n\tu32 len;\n\n\tif (test_bit(ATH10K_FW_FEATURE_EXT_WMI_MGMT_RX,\n\t\t     ar->running_fw->fw_file.fw_features)) {\n\t\tev_v2 = (struct wmi_mgmt_rx_event_v2 *)skb->data;\n\t\tev_hdr = &ev_v2->hdr.v1;\n\t\tpull_len = sizeof(*ev_v2);\n\t} else {\n\t\tev_v1 = (struct wmi_mgmt_rx_event_v1 *)skb->data;\n\t\tev_hdr = &ev_v1->hdr;\n\t\tpull_len = sizeof(*ev_v1);\n\t}\n\n\tif (skb->len < pull_len)\n\t\treturn -EPROTO;\n\n\tskb_pull(skb, pull_len);\n\targ->channel = ev_hdr->channel;\n\targ->buf_len = ev_hdr->buf_len;\n\targ->status = ev_hdr->status;\n\targ->snr = ev_hdr->snr;\n\targ->phy_mode = ev_hdr->phy_mode;\n\targ->rate = ev_hdr->rate;\n\n\tmsdu_len = __le32_to_cpu(arg->buf_len);\n\tif (skb->len < msdu_len)\n\t\treturn -EPROTO;\n\n\tif (le32_to_cpu(arg->status) & WMI_RX_STATUS_EXT_INFO) {\n\t\tlen = ALIGN(le32_to_cpu(arg->buf_len), 4);\n\t\text_info = (struct wmi_mgmt_rx_ext_info *)(skb->data + len);\n\t\tmemcpy(&arg->ext_info, ext_info,\n\t\t       sizeof(struct wmi_mgmt_rx_ext_info));\n\t}\n\t \n\tskb_trim(skb, msdu_len);\n\n\treturn 0;\n}\n\nstatic int ath10k_wmi_10_4_op_pull_mgmt_rx_ev(struct ath10k *ar,\n\t\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t\t      struct wmi_mgmt_rx_ev_arg *arg)\n{\n\tstruct wmi_10_4_mgmt_rx_event *ev;\n\tstruct wmi_10_4_mgmt_rx_hdr *ev_hdr;\n\tsize_t pull_len;\n\tu32 msdu_len;\n\tstruct wmi_mgmt_rx_ext_info *ext_info;\n\tu32 len;\n\n\tev = (struct wmi_10_4_mgmt_rx_event *)skb->data;\n\tev_hdr = &ev->hdr;\n\tpull_len = sizeof(*ev);\n\n\tif (skb->len < pull_len)\n\t\treturn -EPROTO;\n\n\tskb_pull(skb, pull_len);\n\targ->channel = ev_hdr->channel;\n\targ->buf_len = ev_hdr->buf_len;\n\targ->status = ev_hdr->status;\n\targ->snr = ev_hdr->snr;\n\targ->phy_mode = ev_hdr->phy_mode;\n\targ->rate = ev_hdr->rate;\n\n\tmsdu_len = __le32_to_cpu(arg->buf_len);\n\tif (skb->len < msdu_len)\n\t\treturn -EPROTO;\n\n\tif (le32_to_cpu(arg->status) & WMI_RX_STATUS_EXT_INFO) {\n\t\tlen = ALIGN(le32_to_cpu(arg->buf_len), 4);\n\t\text_info = (struct wmi_mgmt_rx_ext_info *)(skb->data + len);\n\t\tmemcpy(&arg->ext_info, ext_info,\n\t\t       sizeof(struct wmi_mgmt_rx_ext_info));\n\t}\n\n\t \n\tskb_trim(skb, msdu_len);\n\n\treturn 0;\n}\n\nstatic bool ath10k_wmi_rx_is_decrypted(struct ath10k *ar,\n\t\t\t\t       struct ieee80211_hdr *hdr)\n{\n\tif (!ieee80211_has_protected(hdr->frame_control))\n\t\treturn false;\n\n\t \n\tif (ieee80211_is_auth(hdr->frame_control))\n\t\treturn false;\n\n\t \n\tif (is_multicast_ether_addr(ieee80211_get_DA(hdr)) &&\n\t    ar->hw_params.sw_decrypt_mcast_mgmt)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int\nwmi_process_mgmt_tx_comp(struct ath10k *ar, struct mgmt_tx_compl_params *param)\n{\n\tstruct ath10k_mgmt_tx_pkt_addr *pkt_addr;\n\tstruct ath10k_wmi *wmi = &ar->wmi;\n\tstruct ieee80211_tx_info *info;\n\tstruct sk_buff *msdu;\n\tint ret;\n\n\tspin_lock_bh(&ar->data_lock);\n\n\tpkt_addr = idr_find(&wmi->mgmt_pending_tx, param->desc_id);\n\tif (!pkt_addr) {\n\t\tath10k_warn(ar, \"received mgmt tx completion for invalid msdu_id: %d\\n\",\n\t\t\t    param->desc_id);\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tmsdu = pkt_addr->vaddr;\n\tdma_unmap_single(ar->dev, pkt_addr->paddr,\n\t\t\t msdu->len, DMA_TO_DEVICE);\n\tinfo = IEEE80211_SKB_CB(msdu);\n\n\tif (param->status) {\n\t\tinfo->flags &= ~IEEE80211_TX_STAT_ACK;\n\t} else {\n\t\tinfo->flags |= IEEE80211_TX_STAT_ACK;\n\t\tinfo->status.ack_signal = ATH10K_DEFAULT_NOISE_FLOOR +\n\t\t\t\t\t  param->ack_rssi;\n\t\tinfo->status.flags |= IEEE80211_TX_STATUS_ACK_SIGNAL_VALID;\n\t}\n\n\tieee80211_tx_status_irqsafe(ar->hw, msdu);\n\n\tret = 0;\n\nout:\n\tidr_remove(&wmi->mgmt_pending_tx, param->desc_id);\n\tspin_unlock_bh(&ar->data_lock);\n\treturn ret;\n}\n\nint ath10k_wmi_event_mgmt_tx_compl(struct ath10k *ar, struct sk_buff *skb)\n{\n\tstruct wmi_tlv_mgmt_tx_compl_ev_arg arg;\n\tstruct mgmt_tx_compl_params param;\n\tint ret;\n\n\tret = ath10k_wmi_pull_mgmt_tx_compl(ar, skb, &arg);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to parse mgmt comp event: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmemset(&param, 0, sizeof(struct mgmt_tx_compl_params));\n\tparam.desc_id = __le32_to_cpu(arg.desc_id);\n\tparam.status = __le32_to_cpu(arg.status);\n\n\tif (test_bit(WMI_SERVICE_TX_DATA_ACK_RSSI, ar->wmi.svc_map))\n\t\tparam.ack_rssi = __le32_to_cpu(arg.ack_rssi);\n\n\twmi_process_mgmt_tx_comp(ar, &param);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv evnt mgmt tx completion\\n\");\n\n\treturn 0;\n}\n\nint ath10k_wmi_event_mgmt_tx_bundle_compl(struct ath10k *ar, struct sk_buff *skb)\n{\n\tstruct wmi_tlv_mgmt_tx_bundle_compl_ev_arg arg;\n\tstruct mgmt_tx_compl_params param;\n\tu32 num_reports;\n\tint i, ret;\n\n\tret = ath10k_wmi_pull_mgmt_tx_bundle_compl(ar, skb, &arg);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to parse bundle mgmt compl event: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tnum_reports = __le32_to_cpu(arg.num_reports);\n\n\tfor (i = 0; i < num_reports; i++) {\n\t\tmemset(&param, 0, sizeof(struct mgmt_tx_compl_params));\n\t\tparam.desc_id = __le32_to_cpu(arg.desc_ids[i]);\n\t\tparam.status = __le32_to_cpu(arg.desc_ids[i]);\n\n\t\tif (test_bit(WMI_SERVICE_TX_DATA_ACK_RSSI, ar->wmi.svc_map))\n\t\t\tparam.ack_rssi = __le32_to_cpu(arg.ack_rssi[i]);\n\t\twmi_process_mgmt_tx_comp(ar, &param);\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv event bundle mgmt tx completion\\n\");\n\n\treturn 0;\n}\n\nint ath10k_wmi_event_mgmt_rx(struct ath10k *ar, struct sk_buff *skb)\n{\n\tstruct wmi_mgmt_rx_ev_arg arg = {};\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\n\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211_supported_band *sband;\n\tu32 rx_status;\n\tu32 channel;\n\tu32 phy_mode;\n\tu32 snr, rssi;\n\tu32 rate;\n\tu16 fc;\n\tint ret, i;\n\n\tret = ath10k_wmi_pull_mgmt_rx(ar, skb, &arg);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to parse mgmt rx event: %d\\n\", ret);\n\t\tdev_kfree_skb(skb);\n\t\treturn ret;\n\t}\n\n\tchannel = __le32_to_cpu(arg.channel);\n\trx_status = __le32_to_cpu(arg.status);\n\tsnr = __le32_to_cpu(arg.snr);\n\tphy_mode = __le32_to_cpu(arg.phy_mode);\n\trate = __le32_to_cpu(arg.rate);\n\n\tmemset(status, 0, sizeof(*status));\n\n\tath10k_dbg(ar, ATH10K_DBG_MGMT,\n\t\t   \"event mgmt rx status %08x\\n\", rx_status);\n\n\tif ((test_bit(ATH10K_CAC_RUNNING, &ar->dev_flags)) ||\n\t    (rx_status & (WMI_RX_STATUS_ERR_DECRYPT |\n\t    WMI_RX_STATUS_ERR_KEY_CACHE_MISS | WMI_RX_STATUS_ERR_CRC))) {\n\t\tdev_kfree_skb(skb);\n\t\treturn 0;\n\t}\n\n\tif (rx_status & WMI_RX_STATUS_ERR_MIC)\n\t\tstatus->flag |= RX_FLAG_MMIC_ERROR;\n\n\tif (rx_status & WMI_RX_STATUS_EXT_INFO) {\n\t\tstatus->mactime =\n\t\t\t__le64_to_cpu(arg.ext_info.rx_mac_timestamp);\n\t\tstatus->flag |= RX_FLAG_MACTIME_END;\n\t}\n\t \n\tif (channel >= 1 && channel <= 14) {\n\t\tstatus->band = NL80211_BAND_2GHZ;\n\t} else if (channel >= 36 && channel <= ATH10K_MAX_5G_CHAN) {\n\t\tstatus->band = NL80211_BAND_5GHZ;\n\t} else {\n\t\t \n\t\tWARN_ON_ONCE(1);\n\t\tdev_kfree_skb(skb);\n\t\treturn 0;\n\t}\n\n\tif (phy_mode == MODE_11B && status->band == NL80211_BAND_5GHZ)\n\t\tath10k_dbg(ar, ATH10K_DBG_MGMT, \"wmi mgmt rx 11b (CCK) on 5GHz\\n\");\n\n\tsband = &ar->mac.sbands[status->band];\n\n\tstatus->freq = ieee80211_channel_to_frequency(channel, status->band);\n\tstatus->signal = snr + ATH10K_DEFAULT_NOISE_FLOOR;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(status->chain_signal) != ARRAY_SIZE(arg.rssi));\n\n\tfor (i = 0; i < ARRAY_SIZE(status->chain_signal); i++) {\n\t\tstatus->chains &= ~BIT(i);\n\t\trssi = __le32_to_cpu(arg.rssi[i]);\n\t\tath10k_dbg(ar, ATH10K_DBG_MGMT, \"mgmt rssi[%d]:%d\\n\", i, arg.rssi[i]);\n\n\t\tif (rssi != ATH10K_INVALID_RSSI && rssi != 0) {\n\t\t\tstatus->chain_signal[i] = ATH10K_DEFAULT_NOISE_FLOOR + rssi;\n\t\t\tstatus->chains |= BIT(i);\n\t\t}\n\t}\n\n\tstatus->rate_idx = ath10k_mac_bitrate_to_idx(sband, rate / 100);\n\n\thdr = (struct ieee80211_hdr *)skb->data;\n\tfc = le16_to_cpu(hdr->frame_control);\n\n\t \n\tstatus->flag |= RX_FLAG_SKIP_MONITOR;\n\n\tath10k_wmi_handle_wep_reauth(ar, skb, status);\n\n\tif (ath10k_wmi_rx_is_decrypted(ar, hdr)) {\n\t\tstatus->flag |= RX_FLAG_DECRYPTED;\n\n\t\tif (!ieee80211_is_action(hdr->frame_control) &&\n\t\t    !ieee80211_is_deauth(hdr->frame_control) &&\n\t\t    !ieee80211_is_disassoc(hdr->frame_control)) {\n\t\t\tstatus->flag |= RX_FLAG_IV_STRIPPED |\n\t\t\t\t\tRX_FLAG_MMIC_STRIPPED;\n\t\t\thdr->frame_control = __cpu_to_le16(fc &\n\t\t\t\t\t~IEEE80211_FCTL_PROTECTED);\n\t\t}\n\t}\n\n\tif (ieee80211_is_beacon(hdr->frame_control))\n\t\tath10k_mac_handle_beacon(ar, skb);\n\n\tif (ieee80211_is_beacon(hdr->frame_control) ||\n\t    ieee80211_is_probe_resp(hdr->frame_control))\n\t\tstatus->boottime_ns = ktime_get_boottime_ns();\n\n\tath10k_dbg(ar, ATH10K_DBG_MGMT,\n\t\t   \"event mgmt rx skb %pK len %d ftype %02x stype %02x\\n\",\n\t\t   skb, skb->len,\n\t\t   fc & IEEE80211_FCTL_FTYPE, fc & IEEE80211_FCTL_STYPE);\n\n\tath10k_dbg(ar, ATH10K_DBG_MGMT,\n\t\t   \"event mgmt rx freq %d band %d snr %d, rate_idx %d\\n\",\n\t\t   status->freq, status->band, status->signal,\n\t\t   status->rate_idx);\n\n\tieee80211_rx_ni(ar->hw, skb);\n\n\treturn 0;\n}\n\nstatic int freq_to_idx(struct ath10k *ar, int freq)\n{\n\tstruct ieee80211_supported_band *sband;\n\tint band, ch, idx = 0;\n\n\tfor (band = NL80211_BAND_2GHZ; band < NUM_NL80211_BANDS; band++) {\n\t\tsband = ar->hw->wiphy->bands[band];\n\t\tif (!sband)\n\t\t\tcontinue;\n\n\t\tfor (ch = 0; ch < sband->n_channels; ch++, idx++)\n\t\t\tif (sband->channels[ch].center_freq == freq)\n\t\t\t\tgoto exit;\n\t}\n\nexit:\n\treturn idx;\n}\n\nstatic int ath10k_wmi_op_pull_ch_info_ev(struct ath10k *ar, struct sk_buff *skb,\n\t\t\t\t\t struct wmi_ch_info_ev_arg *arg)\n{\n\tstruct wmi_chan_info_event *ev = (void *)skb->data;\n\n\tif (skb->len < sizeof(*ev))\n\t\treturn -EPROTO;\n\n\tskb_pull(skb, sizeof(*ev));\n\targ->err_code = ev->err_code;\n\targ->freq = ev->freq;\n\targ->cmd_flags = ev->cmd_flags;\n\targ->noise_floor = ev->noise_floor;\n\targ->rx_clear_count = ev->rx_clear_count;\n\targ->cycle_count = ev->cycle_count;\n\n\treturn 0;\n}\n\nstatic int ath10k_wmi_10_4_op_pull_ch_info_ev(struct ath10k *ar,\n\t\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t\t      struct wmi_ch_info_ev_arg *arg)\n{\n\tstruct wmi_10_4_chan_info_event *ev = (void *)skb->data;\n\n\tif (skb->len < sizeof(*ev))\n\t\treturn -EPROTO;\n\n\tskb_pull(skb, sizeof(*ev));\n\targ->err_code = ev->err_code;\n\targ->freq = ev->freq;\n\targ->cmd_flags = ev->cmd_flags;\n\targ->noise_floor = ev->noise_floor;\n\targ->rx_clear_count = ev->rx_clear_count;\n\targ->cycle_count = ev->cycle_count;\n\targ->chan_tx_pwr_range = ev->chan_tx_pwr_range;\n\targ->chan_tx_pwr_tp = ev->chan_tx_pwr_tp;\n\targ->rx_frame_count = ev->rx_frame_count;\n\n\treturn 0;\n}\n\n \nstatic void ath10k_wmi_event_chan_info_unpaired(struct ath10k *ar,\n\t\t\t\t\t\tstruct chan_info_params *params)\n{\n\tstruct survey_info *survey;\n\tint idx;\n\n\tif (params->cmd_flags & WMI_CHAN_INFO_FLAG_COMPLETE) {\n\t\tath10k_dbg(ar, ATH10K_DBG_WMI, \"chan info report completed\\n\");\n\t\treturn;\n\t}\n\n\tidx = freq_to_idx(ar, params->freq);\n\tif (idx >= ARRAY_SIZE(ar->survey)) {\n\t\tath10k_warn(ar, \"chan info: invalid frequency %d (idx %d out of bounds)\\n\",\n\t\t\t    params->freq, idx);\n\t\treturn;\n\t}\n\n\tsurvey = &ar->survey[idx];\n\n\tif (!params->mac_clk_mhz)\n\t\treturn;\n\n\tmemset(survey, 0, sizeof(*survey));\n\n\tsurvey->noise = params->noise_floor;\n\tsurvey->time = (params->cycle_count / params->mac_clk_mhz) / 1000;\n\tsurvey->time_busy = (params->rx_clear_count / params->mac_clk_mhz) / 1000;\n\tsurvey->filled |= SURVEY_INFO_NOISE_DBM | SURVEY_INFO_TIME |\n\t\t\t  SURVEY_INFO_TIME_BUSY;\n}\n\n \nstatic void ath10k_wmi_event_chan_info_paired(struct ath10k *ar,\n\t\t\t\t\t      struct chan_info_params *params)\n{\n\tstruct survey_info *survey;\n\tint idx;\n\n\tidx = freq_to_idx(ar, params->freq);\n\tif (idx >= ARRAY_SIZE(ar->survey)) {\n\t\tath10k_warn(ar, \"chan info: invalid frequency %d (idx %d out of bounds)\\n\",\n\t\t\t    params->freq, idx);\n\t\treturn;\n\t}\n\n\tif (params->cmd_flags & WMI_CHAN_INFO_FLAG_COMPLETE) {\n\t\tif (ar->ch_info_can_report_survey) {\n\t\t\tsurvey = &ar->survey[idx];\n\t\t\tsurvey->noise = params->noise_floor;\n\t\t\tsurvey->filled = SURVEY_INFO_NOISE_DBM;\n\n\t\t\tath10k_hw_fill_survey_time(ar,\n\t\t\t\t\t\t   survey,\n\t\t\t\t\t\t   params->cycle_count,\n\t\t\t\t\t\t   params->rx_clear_count,\n\t\t\t\t\t\t   ar->survey_last_cycle_count,\n\t\t\t\t\t\t   ar->survey_last_rx_clear_count);\n\t\t}\n\n\t\tar->ch_info_can_report_survey = false;\n\t} else {\n\t\tar->ch_info_can_report_survey = true;\n\t}\n\n\tif (!(params->cmd_flags & WMI_CHAN_INFO_FLAG_PRE_COMPLETE)) {\n\t\tar->survey_last_rx_clear_count = params->rx_clear_count;\n\t\tar->survey_last_cycle_count = params->cycle_count;\n\t}\n}\n\nvoid ath10k_wmi_event_chan_info(struct ath10k *ar, struct sk_buff *skb)\n{\n\tstruct chan_info_params ch_info_param;\n\tstruct wmi_ch_info_ev_arg arg = {};\n\tint ret;\n\n\tret = ath10k_wmi_pull_ch_info(ar, skb, &arg);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to parse chan info event: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tch_info_param.err_code = __le32_to_cpu(arg.err_code);\n\tch_info_param.freq = __le32_to_cpu(arg.freq);\n\tch_info_param.cmd_flags = __le32_to_cpu(arg.cmd_flags);\n\tch_info_param.noise_floor = __le32_to_cpu(arg.noise_floor);\n\tch_info_param.rx_clear_count = __le32_to_cpu(arg.rx_clear_count);\n\tch_info_param.cycle_count = __le32_to_cpu(arg.cycle_count);\n\tch_info_param.mac_clk_mhz = __le32_to_cpu(arg.mac_clk_mhz);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"chan info err_code %d freq %d cmd_flags %d noise_floor %d rx_clear_count %d cycle_count %d\\n\",\n\t\t   ch_info_param.err_code, ch_info_param.freq, ch_info_param.cmd_flags,\n\t\t   ch_info_param.noise_floor, ch_info_param.rx_clear_count,\n\t\t   ch_info_param.cycle_count);\n\n\tspin_lock_bh(&ar->data_lock);\n\n\tswitch (ar->scan.state) {\n\tcase ATH10K_SCAN_IDLE:\n\tcase ATH10K_SCAN_STARTING:\n\t\tath10k_dbg(ar, ATH10K_DBG_WMI, \"received chan info event without a scan request, ignoring\\n\");\n\t\tgoto exit;\n\tcase ATH10K_SCAN_RUNNING:\n\tcase ATH10K_SCAN_ABORTING:\n\t\tbreak;\n\t}\n\n\tif (test_bit(ATH10K_FW_FEATURE_SINGLE_CHAN_INFO_PER_CHANNEL,\n\t\t     ar->running_fw->fw_file.fw_features))\n\t\tath10k_wmi_event_chan_info_unpaired(ar, &ch_info_param);\n\telse\n\t\tath10k_wmi_event_chan_info_paired(ar, &ch_info_param);\n\nexit:\n\tspin_unlock_bh(&ar->data_lock);\n}\n\nvoid ath10k_wmi_event_echo(struct ath10k *ar, struct sk_buff *skb)\n{\n\tstruct wmi_echo_ev_arg arg = {};\n\tint ret;\n\n\tret = ath10k_wmi_pull_echo_ev(ar, skb, &arg);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to parse echo: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi event echo value 0x%08x\\n\",\n\t\t   le32_to_cpu(arg.value));\n\n\tif (le32_to_cpu(arg.value) == ATH10K_WMI_BARRIER_ECHO_ID)\n\t\tcomplete(&ar->wmi.barrier);\n}\n\nint ath10k_wmi_event_debug_mesg(struct ath10k *ar, struct sk_buff *skb)\n{\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi event debug mesg len %d\\n\",\n\t\t   skb->len);\n\n\ttrace_ath10k_wmi_dbglog(ar, skb->data, skb->len);\n\n\treturn 0;\n}\n\nvoid ath10k_wmi_pull_pdev_stats_base(const struct wmi_pdev_stats_base *src,\n\t\t\t\t     struct ath10k_fw_stats_pdev *dst)\n{\n\tdst->ch_noise_floor = __le32_to_cpu(src->chan_nf);\n\tdst->tx_frame_count = __le32_to_cpu(src->tx_frame_count);\n\tdst->rx_frame_count = __le32_to_cpu(src->rx_frame_count);\n\tdst->rx_clear_count = __le32_to_cpu(src->rx_clear_count);\n\tdst->cycle_count = __le32_to_cpu(src->cycle_count);\n\tdst->phy_err_count = __le32_to_cpu(src->phy_err_count);\n\tdst->chan_tx_power = __le32_to_cpu(src->chan_tx_pwr);\n}\n\nvoid ath10k_wmi_pull_pdev_stats_tx(const struct wmi_pdev_stats_tx *src,\n\t\t\t\t   struct ath10k_fw_stats_pdev *dst)\n{\n\tdst->comp_queued = __le32_to_cpu(src->comp_queued);\n\tdst->comp_delivered = __le32_to_cpu(src->comp_delivered);\n\tdst->msdu_enqued = __le32_to_cpu(src->msdu_enqued);\n\tdst->mpdu_enqued = __le32_to_cpu(src->mpdu_enqued);\n\tdst->wmm_drop = __le32_to_cpu(src->wmm_drop);\n\tdst->local_enqued = __le32_to_cpu(src->local_enqued);\n\tdst->local_freed = __le32_to_cpu(src->local_freed);\n\tdst->hw_queued = __le32_to_cpu(src->hw_queued);\n\tdst->hw_reaped = __le32_to_cpu(src->hw_reaped);\n\tdst->underrun = __le32_to_cpu(src->underrun);\n\tdst->tx_abort = __le32_to_cpu(src->tx_abort);\n\tdst->mpdus_requeued = __le32_to_cpu(src->mpdus_requeued);\n\tdst->tx_ko = __le32_to_cpu(src->tx_ko);\n\tdst->data_rc = __le32_to_cpu(src->data_rc);\n\tdst->self_triggers = __le32_to_cpu(src->self_triggers);\n\tdst->sw_retry_failure = __le32_to_cpu(src->sw_retry_failure);\n\tdst->illgl_rate_phy_err = __le32_to_cpu(src->illgl_rate_phy_err);\n\tdst->pdev_cont_xretry = __le32_to_cpu(src->pdev_cont_xretry);\n\tdst->pdev_tx_timeout = __le32_to_cpu(src->pdev_tx_timeout);\n\tdst->pdev_resets = __le32_to_cpu(src->pdev_resets);\n\tdst->phy_underrun = __le32_to_cpu(src->phy_underrun);\n\tdst->txop_ovf = __le32_to_cpu(src->txop_ovf);\n}\n\nstatic void\nath10k_wmi_10_4_pull_pdev_stats_tx(const struct wmi_10_4_pdev_stats_tx *src,\n\t\t\t\t   struct ath10k_fw_stats_pdev *dst)\n{\n\tdst->comp_queued = __le32_to_cpu(src->comp_queued);\n\tdst->comp_delivered = __le32_to_cpu(src->comp_delivered);\n\tdst->msdu_enqued = __le32_to_cpu(src->msdu_enqued);\n\tdst->mpdu_enqued = __le32_to_cpu(src->mpdu_enqued);\n\tdst->wmm_drop = __le32_to_cpu(src->wmm_drop);\n\tdst->local_enqued = __le32_to_cpu(src->local_enqued);\n\tdst->local_freed = __le32_to_cpu(src->local_freed);\n\tdst->hw_queued = __le32_to_cpu(src->hw_queued);\n\tdst->hw_reaped = __le32_to_cpu(src->hw_reaped);\n\tdst->underrun = __le32_to_cpu(src->underrun);\n\tdst->tx_abort = __le32_to_cpu(src->tx_abort);\n\tdst->mpdus_requeued = __le32_to_cpu(src->mpdus_requeued);\n\tdst->tx_ko = __le32_to_cpu(src->tx_ko);\n\tdst->data_rc = __le32_to_cpu(src->data_rc);\n\tdst->self_triggers = __le32_to_cpu(src->self_triggers);\n\tdst->sw_retry_failure = __le32_to_cpu(src->sw_retry_failure);\n\tdst->illgl_rate_phy_err = __le32_to_cpu(src->illgl_rate_phy_err);\n\tdst->pdev_cont_xretry = __le32_to_cpu(src->pdev_cont_xretry);\n\tdst->pdev_tx_timeout = __le32_to_cpu(src->pdev_tx_timeout);\n\tdst->pdev_resets = __le32_to_cpu(src->pdev_resets);\n\tdst->phy_underrun = __le32_to_cpu(src->phy_underrun);\n\tdst->txop_ovf = __le32_to_cpu(src->txop_ovf);\n\tdst->hw_paused = __le32_to_cpu(src->hw_paused);\n\tdst->seq_posted = __le32_to_cpu(src->seq_posted);\n\tdst->seq_failed_queueing =\n\t\t__le32_to_cpu(src->seq_failed_queueing);\n\tdst->seq_completed = __le32_to_cpu(src->seq_completed);\n\tdst->seq_restarted = __le32_to_cpu(src->seq_restarted);\n\tdst->mu_seq_posted = __le32_to_cpu(src->mu_seq_posted);\n\tdst->mpdus_sw_flush = __le32_to_cpu(src->mpdus_sw_flush);\n\tdst->mpdus_hw_filter = __le32_to_cpu(src->mpdus_hw_filter);\n\tdst->mpdus_truncated = __le32_to_cpu(src->mpdus_truncated);\n\tdst->mpdus_ack_failed = __le32_to_cpu(src->mpdus_ack_failed);\n\tdst->mpdus_hw_filter = __le32_to_cpu(src->mpdus_hw_filter);\n\tdst->mpdus_expired = __le32_to_cpu(src->mpdus_expired);\n}\n\nvoid ath10k_wmi_pull_pdev_stats_rx(const struct wmi_pdev_stats_rx *src,\n\t\t\t\t   struct ath10k_fw_stats_pdev *dst)\n{\n\tdst->mid_ppdu_route_change = __le32_to_cpu(src->mid_ppdu_route_change);\n\tdst->status_rcvd = __le32_to_cpu(src->status_rcvd);\n\tdst->r0_frags = __le32_to_cpu(src->r0_frags);\n\tdst->r1_frags = __le32_to_cpu(src->r1_frags);\n\tdst->r2_frags = __le32_to_cpu(src->r2_frags);\n\tdst->r3_frags = __le32_to_cpu(src->r3_frags);\n\tdst->htt_msdus = __le32_to_cpu(src->htt_msdus);\n\tdst->htt_mpdus = __le32_to_cpu(src->htt_mpdus);\n\tdst->loc_msdus = __le32_to_cpu(src->loc_msdus);\n\tdst->loc_mpdus = __le32_to_cpu(src->loc_mpdus);\n\tdst->oversize_amsdu = __le32_to_cpu(src->oversize_amsdu);\n\tdst->phy_errs = __le32_to_cpu(src->phy_errs);\n\tdst->phy_err_drop = __le32_to_cpu(src->phy_err_drop);\n\tdst->mpdu_errs = __le32_to_cpu(src->mpdu_errs);\n}\n\nvoid ath10k_wmi_pull_pdev_stats_extra(const struct wmi_pdev_stats_extra *src,\n\t\t\t\t      struct ath10k_fw_stats_pdev *dst)\n{\n\tdst->ack_rx_bad = __le32_to_cpu(src->ack_rx_bad);\n\tdst->rts_bad = __le32_to_cpu(src->rts_bad);\n\tdst->rts_good = __le32_to_cpu(src->rts_good);\n\tdst->fcs_bad = __le32_to_cpu(src->fcs_bad);\n\tdst->no_beacons = __le32_to_cpu(src->no_beacons);\n\tdst->mib_int_count = __le32_to_cpu(src->mib_int_count);\n}\n\nvoid ath10k_wmi_pull_peer_stats(const struct wmi_peer_stats *src,\n\t\t\t\tstruct ath10k_fw_stats_peer *dst)\n{\n\tether_addr_copy(dst->peer_macaddr, src->peer_macaddr.addr);\n\tdst->peer_rssi = __le32_to_cpu(src->peer_rssi);\n\tdst->peer_tx_rate = __le32_to_cpu(src->peer_tx_rate);\n}\n\nstatic void\nath10k_wmi_10_4_pull_peer_stats(const struct wmi_10_4_peer_stats *src,\n\t\t\t\tstruct ath10k_fw_stats_peer *dst)\n{\n\tether_addr_copy(dst->peer_macaddr, src->peer_macaddr.addr);\n\tdst->peer_rssi = __le32_to_cpu(src->peer_rssi);\n\tdst->peer_tx_rate = __le32_to_cpu(src->peer_tx_rate);\n\tdst->peer_rx_rate = __le32_to_cpu(src->peer_rx_rate);\n}\n\nstatic void\nath10k_wmi_10_4_pull_vdev_stats(const struct wmi_vdev_stats_extd *src,\n\t\t\t\tstruct ath10k_fw_stats_vdev_extd *dst)\n{\n\tdst->vdev_id = __le32_to_cpu(src->vdev_id);\n\tdst->ppdu_aggr_cnt = __le32_to_cpu(src->ppdu_aggr_cnt);\n\tdst->ppdu_noack = __le32_to_cpu(src->ppdu_noack);\n\tdst->mpdu_queued = __le32_to_cpu(src->mpdu_queued);\n\tdst->ppdu_nonaggr_cnt = __le32_to_cpu(src->ppdu_nonaggr_cnt);\n\tdst->mpdu_sw_requeued = __le32_to_cpu(src->mpdu_sw_requeued);\n\tdst->mpdu_suc_retry = __le32_to_cpu(src->mpdu_suc_retry);\n\tdst->mpdu_suc_multitry = __le32_to_cpu(src->mpdu_suc_multitry);\n\tdst->mpdu_fail_retry = __le32_to_cpu(src->mpdu_fail_retry);\n\tdst->tx_ftm_suc = __le32_to_cpu(src->tx_ftm_suc);\n\tdst->tx_ftm_suc_retry = __le32_to_cpu(src->tx_ftm_suc_retry);\n\tdst->tx_ftm_fail = __le32_to_cpu(src->tx_ftm_fail);\n\tdst->rx_ftmr_cnt = __le32_to_cpu(src->rx_ftmr_cnt);\n\tdst->rx_ftmr_dup_cnt = __le32_to_cpu(src->rx_ftmr_dup_cnt);\n\tdst->rx_iftmr_cnt = __le32_to_cpu(src->rx_iftmr_cnt);\n\tdst->rx_iftmr_dup_cnt = __le32_to_cpu(src->rx_iftmr_dup_cnt);\n}\n\nstatic int ath10k_wmi_main_op_pull_fw_stats(struct ath10k *ar,\n\t\t\t\t\t    struct sk_buff *skb,\n\t\t\t\t\t    struct ath10k_fw_stats *stats)\n{\n\tconst struct wmi_stats_event *ev = (void *)skb->data;\n\tu32 num_pdev_stats, num_peer_stats;\n\tint i;\n\n\tif (!skb_pull(skb, sizeof(*ev)))\n\t\treturn -EPROTO;\n\n\tnum_pdev_stats = __le32_to_cpu(ev->num_pdev_stats);\n\tnum_peer_stats = __le32_to_cpu(ev->num_peer_stats);\n\n\tfor (i = 0; i < num_pdev_stats; i++) {\n\t\tconst struct wmi_pdev_stats *src;\n\t\tstruct ath10k_fw_stats_pdev *dst;\n\n\t\tsrc = (void *)skb->data;\n\t\tif (!skb_pull(skb, sizeof(*src)))\n\t\t\treturn -EPROTO;\n\n\t\tdst = kzalloc(sizeof(*dst), GFP_ATOMIC);\n\t\tif (!dst)\n\t\t\tcontinue;\n\n\t\tath10k_wmi_pull_pdev_stats_base(&src->base, dst);\n\t\tath10k_wmi_pull_pdev_stats_tx(&src->tx, dst);\n\t\tath10k_wmi_pull_pdev_stats_rx(&src->rx, dst);\n\n\t\tlist_add_tail(&dst->list, &stats->pdevs);\n\t}\n\n\t \n\n\tfor (i = 0; i < num_peer_stats; i++) {\n\t\tconst struct wmi_peer_stats *src;\n\t\tstruct ath10k_fw_stats_peer *dst;\n\n\t\tsrc = (void *)skb->data;\n\t\tif (!skb_pull(skb, sizeof(*src)))\n\t\t\treturn -EPROTO;\n\n\t\tdst = kzalloc(sizeof(*dst), GFP_ATOMIC);\n\t\tif (!dst)\n\t\t\tcontinue;\n\n\t\tath10k_wmi_pull_peer_stats(src, dst);\n\t\tlist_add_tail(&dst->list, &stats->peers);\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_wmi_10x_op_pull_fw_stats(struct ath10k *ar,\n\t\t\t\t\t   struct sk_buff *skb,\n\t\t\t\t\t   struct ath10k_fw_stats *stats)\n{\n\tconst struct wmi_stats_event *ev = (void *)skb->data;\n\tu32 num_pdev_stats, num_peer_stats;\n\tint i;\n\n\tif (!skb_pull(skb, sizeof(*ev)))\n\t\treturn -EPROTO;\n\n\tnum_pdev_stats = __le32_to_cpu(ev->num_pdev_stats);\n\tnum_peer_stats = __le32_to_cpu(ev->num_peer_stats);\n\n\tfor (i = 0; i < num_pdev_stats; i++) {\n\t\tconst struct wmi_10x_pdev_stats *src;\n\t\tstruct ath10k_fw_stats_pdev *dst;\n\n\t\tsrc = (void *)skb->data;\n\t\tif (!skb_pull(skb, sizeof(*src)))\n\t\t\treturn -EPROTO;\n\n\t\tdst = kzalloc(sizeof(*dst), GFP_ATOMIC);\n\t\tif (!dst)\n\t\t\tcontinue;\n\n\t\tath10k_wmi_pull_pdev_stats_base(&src->base, dst);\n\t\tath10k_wmi_pull_pdev_stats_tx(&src->tx, dst);\n\t\tath10k_wmi_pull_pdev_stats_rx(&src->rx, dst);\n\t\tath10k_wmi_pull_pdev_stats_extra(&src->extra, dst);\n\n\t\tlist_add_tail(&dst->list, &stats->pdevs);\n\t}\n\n\t \n\n\tfor (i = 0; i < num_peer_stats; i++) {\n\t\tconst struct wmi_10x_peer_stats *src;\n\t\tstruct ath10k_fw_stats_peer *dst;\n\n\t\tsrc = (void *)skb->data;\n\t\tif (!skb_pull(skb, sizeof(*src)))\n\t\t\treturn -EPROTO;\n\n\t\tdst = kzalloc(sizeof(*dst), GFP_ATOMIC);\n\t\tif (!dst)\n\t\t\tcontinue;\n\n\t\tath10k_wmi_pull_peer_stats(&src->old, dst);\n\n\t\tdst->peer_rx_rate = __le32_to_cpu(src->peer_rx_rate);\n\n\t\tlist_add_tail(&dst->list, &stats->peers);\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_wmi_10_2_op_pull_fw_stats(struct ath10k *ar,\n\t\t\t\t\t    struct sk_buff *skb,\n\t\t\t\t\t    struct ath10k_fw_stats *stats)\n{\n\tconst struct wmi_10_2_stats_event *ev = (void *)skb->data;\n\tu32 num_pdev_stats;\n\tu32 num_pdev_ext_stats;\n\tu32 num_peer_stats;\n\tint i;\n\n\tif (!skb_pull(skb, sizeof(*ev)))\n\t\treturn -EPROTO;\n\n\tnum_pdev_stats = __le32_to_cpu(ev->num_pdev_stats);\n\tnum_pdev_ext_stats = __le32_to_cpu(ev->num_pdev_ext_stats);\n\tnum_peer_stats = __le32_to_cpu(ev->num_peer_stats);\n\n\tfor (i = 0; i < num_pdev_stats; i++) {\n\t\tconst struct wmi_10_2_pdev_stats *src;\n\t\tstruct ath10k_fw_stats_pdev *dst;\n\n\t\tsrc = (void *)skb->data;\n\t\tif (!skb_pull(skb, sizeof(*src)))\n\t\t\treturn -EPROTO;\n\n\t\tdst = kzalloc(sizeof(*dst), GFP_ATOMIC);\n\t\tif (!dst)\n\t\t\tcontinue;\n\n\t\tath10k_wmi_pull_pdev_stats_base(&src->base, dst);\n\t\tath10k_wmi_pull_pdev_stats_tx(&src->tx, dst);\n\t\tath10k_wmi_pull_pdev_stats_rx(&src->rx, dst);\n\t\tath10k_wmi_pull_pdev_stats_extra(&src->extra, dst);\n\t\t \n\n\t\tlist_add_tail(&dst->list, &stats->pdevs);\n\t}\n\n\tfor (i = 0; i < num_pdev_ext_stats; i++) {\n\t\tconst struct wmi_10_2_pdev_ext_stats *src;\n\n\t\tsrc = (void *)skb->data;\n\t\tif (!skb_pull(skb, sizeof(*src)))\n\t\t\treturn -EPROTO;\n\n\t\t \n\t}\n\n\t \n\n\tfor (i = 0; i < num_peer_stats; i++) {\n\t\tconst struct wmi_10_2_peer_stats *src;\n\t\tstruct ath10k_fw_stats_peer *dst;\n\n\t\tsrc = (void *)skb->data;\n\t\tif (!skb_pull(skb, sizeof(*src)))\n\t\t\treturn -EPROTO;\n\n\t\tdst = kzalloc(sizeof(*dst), GFP_ATOMIC);\n\t\tif (!dst)\n\t\t\tcontinue;\n\n\t\tath10k_wmi_pull_peer_stats(&src->old, dst);\n\n\t\tdst->peer_rx_rate = __le32_to_cpu(src->peer_rx_rate);\n\t\t \n\n\t\tlist_add_tail(&dst->list, &stats->peers);\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_wmi_10_2_4_op_pull_fw_stats(struct ath10k *ar,\n\t\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t\t      struct ath10k_fw_stats *stats)\n{\n\tconst struct wmi_10_2_stats_event *ev = (void *)skb->data;\n\tu32 num_pdev_stats;\n\tu32 num_pdev_ext_stats;\n\tu32 num_peer_stats;\n\tint i;\n\n\tif (!skb_pull(skb, sizeof(*ev)))\n\t\treturn -EPROTO;\n\n\tnum_pdev_stats = __le32_to_cpu(ev->num_pdev_stats);\n\tnum_pdev_ext_stats = __le32_to_cpu(ev->num_pdev_ext_stats);\n\tnum_peer_stats = __le32_to_cpu(ev->num_peer_stats);\n\n\tfor (i = 0; i < num_pdev_stats; i++) {\n\t\tconst struct wmi_10_2_pdev_stats *src;\n\t\tstruct ath10k_fw_stats_pdev *dst;\n\n\t\tsrc = (void *)skb->data;\n\t\tif (!skb_pull(skb, sizeof(*src)))\n\t\t\treturn -EPROTO;\n\n\t\tdst = kzalloc(sizeof(*dst), GFP_ATOMIC);\n\t\tif (!dst)\n\t\t\tcontinue;\n\n\t\tath10k_wmi_pull_pdev_stats_base(&src->base, dst);\n\t\tath10k_wmi_pull_pdev_stats_tx(&src->tx, dst);\n\t\tath10k_wmi_pull_pdev_stats_rx(&src->rx, dst);\n\t\tath10k_wmi_pull_pdev_stats_extra(&src->extra, dst);\n\t\t \n\n\t\tlist_add_tail(&dst->list, &stats->pdevs);\n\t}\n\n\tfor (i = 0; i < num_pdev_ext_stats; i++) {\n\t\tconst struct wmi_10_2_pdev_ext_stats *src;\n\n\t\tsrc = (void *)skb->data;\n\t\tif (!skb_pull(skb, sizeof(*src)))\n\t\t\treturn -EPROTO;\n\n\t\t \n\t}\n\n\t \n\n\tfor (i = 0; i < num_peer_stats; i++) {\n\t\tconst struct wmi_10_2_4_ext_peer_stats *src;\n\t\tstruct ath10k_fw_stats_peer *dst;\n\t\tint stats_len;\n\n\t\tif (test_bit(WMI_SERVICE_PEER_STATS, ar->wmi.svc_map))\n\t\t\tstats_len = sizeof(struct wmi_10_2_4_ext_peer_stats);\n\t\telse\n\t\t\tstats_len = sizeof(struct wmi_10_2_4_peer_stats);\n\n\t\tsrc = (void *)skb->data;\n\t\tif (!skb_pull(skb, stats_len))\n\t\t\treturn -EPROTO;\n\n\t\tdst = kzalloc(sizeof(*dst), GFP_ATOMIC);\n\t\tif (!dst)\n\t\t\tcontinue;\n\n\t\tath10k_wmi_pull_peer_stats(&src->common.old, dst);\n\n\t\tdst->peer_rx_rate = __le32_to_cpu(src->common.peer_rx_rate);\n\n\t\tif (ath10k_peer_stats_enabled(ar))\n\t\t\tdst->rx_duration = __le32_to_cpu(src->rx_duration);\n\t\t \n\n\t\tlist_add_tail(&dst->list, &stats->peers);\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_wmi_10_4_op_pull_fw_stats(struct ath10k *ar,\n\t\t\t\t\t    struct sk_buff *skb,\n\t\t\t\t\t    struct ath10k_fw_stats *stats)\n{\n\tconst struct wmi_10_2_stats_event *ev = (void *)skb->data;\n\tu32 num_pdev_stats;\n\tu32 num_pdev_ext_stats;\n\tu32 num_vdev_stats;\n\tu32 num_peer_stats;\n\tu32 num_bcnflt_stats;\n\tu32 stats_id;\n\tint i;\n\n\tif (!skb_pull(skb, sizeof(*ev)))\n\t\treturn -EPROTO;\n\n\tnum_pdev_stats = __le32_to_cpu(ev->num_pdev_stats);\n\tnum_pdev_ext_stats = __le32_to_cpu(ev->num_pdev_ext_stats);\n\tnum_vdev_stats = __le32_to_cpu(ev->num_vdev_stats);\n\tnum_peer_stats = __le32_to_cpu(ev->num_peer_stats);\n\tnum_bcnflt_stats = __le32_to_cpu(ev->num_bcnflt_stats);\n\tstats_id = __le32_to_cpu(ev->stats_id);\n\n\tfor (i = 0; i < num_pdev_stats; i++) {\n\t\tconst struct wmi_10_4_pdev_stats *src;\n\t\tstruct ath10k_fw_stats_pdev *dst;\n\n\t\tsrc = (void *)skb->data;\n\t\tif (!skb_pull(skb, sizeof(*src)))\n\t\t\treturn -EPROTO;\n\n\t\tdst = kzalloc(sizeof(*dst), GFP_ATOMIC);\n\t\tif (!dst)\n\t\t\tcontinue;\n\n\t\tath10k_wmi_pull_pdev_stats_base(&src->base, dst);\n\t\tath10k_wmi_10_4_pull_pdev_stats_tx(&src->tx, dst);\n\t\tath10k_wmi_pull_pdev_stats_rx(&src->rx, dst);\n\t\tdst->rx_ovfl_errs = __le32_to_cpu(src->rx_ovfl_errs);\n\t\tath10k_wmi_pull_pdev_stats_extra(&src->extra, dst);\n\n\t\tlist_add_tail(&dst->list, &stats->pdevs);\n\t}\n\n\tfor (i = 0; i < num_pdev_ext_stats; i++) {\n\t\tconst struct wmi_10_2_pdev_ext_stats *src;\n\n\t\tsrc = (void *)skb->data;\n\t\tif (!skb_pull(skb, sizeof(*src)))\n\t\t\treturn -EPROTO;\n\n\t\t \n\t}\n\n\tfor (i = 0; i < num_vdev_stats; i++) {\n\t\tconst struct wmi_vdev_stats *src;\n\n\t\t \n\t\tsrc = (void *)skb->data;\n\t\tif (!skb_pull(skb, sizeof(*src)))\n\t\t\treturn -EPROTO;\n\t}\n\n\tfor (i = 0; i < num_peer_stats; i++) {\n\t\tconst struct wmi_10_4_peer_stats *src;\n\t\tstruct ath10k_fw_stats_peer *dst;\n\n\t\tsrc = (void *)skb->data;\n\t\tif (!skb_pull(skb, sizeof(*src)))\n\t\t\treturn -EPROTO;\n\n\t\tdst = kzalloc(sizeof(*dst), GFP_ATOMIC);\n\t\tif (!dst)\n\t\t\tcontinue;\n\n\t\tath10k_wmi_10_4_pull_peer_stats(src, dst);\n\t\tlist_add_tail(&dst->list, &stats->peers);\n\t}\n\n\tfor (i = 0; i < num_bcnflt_stats; i++) {\n\t\tconst struct wmi_10_4_bss_bcn_filter_stats *src;\n\n\t\tsrc = (void *)skb->data;\n\t\tif (!skb_pull(skb, sizeof(*src)))\n\t\t\treturn -EPROTO;\n\n\t\t \n\t}\n\n\tif (stats_id & WMI_10_4_STAT_PEER_EXTD) {\n\t\tstats->extended = true;\n\n\t\tfor (i = 0; i < num_peer_stats; i++) {\n\t\t\tconst struct wmi_10_4_peer_extd_stats *src;\n\t\t\tstruct ath10k_fw_extd_stats_peer *dst;\n\n\t\t\tsrc = (void *)skb->data;\n\t\t\tif (!skb_pull(skb, sizeof(*src)))\n\t\t\t\treturn -EPROTO;\n\n\t\t\tdst = kzalloc(sizeof(*dst), GFP_ATOMIC);\n\t\t\tif (!dst)\n\t\t\t\tcontinue;\n\n\t\t\tether_addr_copy(dst->peer_macaddr,\n\t\t\t\t\tsrc->peer_macaddr.addr);\n\t\t\tdst->rx_duration = __le32_to_cpu(src->rx_duration);\n\t\t\tlist_add_tail(&dst->list, &stats->peers_extd);\n\t\t}\n\t}\n\n\tif (stats_id & WMI_10_4_STAT_VDEV_EXTD) {\n\t\tfor (i = 0; i < num_vdev_stats; i++) {\n\t\t\tconst struct wmi_vdev_stats_extd *src;\n\t\t\tstruct ath10k_fw_stats_vdev_extd *dst;\n\n\t\t\tsrc = (void *)skb->data;\n\t\t\tif (!skb_pull(skb, sizeof(*src)))\n\t\t\t\treturn -EPROTO;\n\n\t\t\tdst = kzalloc(sizeof(*dst), GFP_ATOMIC);\n\t\t\tif (!dst)\n\t\t\t\tcontinue;\n\t\t\tath10k_wmi_10_4_pull_vdev_stats(src, dst);\n\t\t\tlist_add_tail(&dst->list, &stats->vdevs);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid ath10k_wmi_event_update_stats(struct ath10k *ar, struct sk_buff *skb)\n{\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"WMI_UPDATE_STATS_EVENTID\\n\");\n\tath10k_debug_fw_stats_process(ar, skb);\n}\n\nstatic int\nath10k_wmi_op_pull_vdev_start_ev(struct ath10k *ar, struct sk_buff *skb,\n\t\t\t\t struct wmi_vdev_start_ev_arg *arg)\n{\n\tstruct wmi_vdev_start_response_event *ev = (void *)skb->data;\n\n\tif (skb->len < sizeof(*ev))\n\t\treturn -EPROTO;\n\n\tskb_pull(skb, sizeof(*ev));\n\targ->vdev_id = ev->vdev_id;\n\targ->req_id = ev->req_id;\n\targ->resp_type = ev->resp_type;\n\targ->status = ev->status;\n\n\treturn 0;\n}\n\nvoid ath10k_wmi_event_vdev_start_resp(struct ath10k *ar, struct sk_buff *skb)\n{\n\tstruct wmi_vdev_start_ev_arg arg = {};\n\tint ret;\n\tu32 status;\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"WMI_VDEV_START_RESP_EVENTID\\n\");\n\n\tar->last_wmi_vdev_start_status = 0;\n\n\tret = ath10k_wmi_pull_vdev_start(ar, skb, &arg);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to parse vdev start event: %d\\n\", ret);\n\t\tar->last_wmi_vdev_start_status = ret;\n\t\tgoto out;\n\t}\n\n\tstatus = __le32_to_cpu(arg.status);\n\tif (WARN_ON_ONCE(status)) {\n\t\tath10k_warn(ar, \"vdev-start-response reports status error: %d (%s)\\n\",\n\t\t\t    status, (status == WMI_VDEV_START_CHAN_INVALID) ?\n\t\t\t    \"chan-invalid\" : \"unknown\");\n\t\t \n\t\tar->last_wmi_vdev_start_status = -EINVAL;\n\t}\n\nout:\n\tcomplete(&ar->vdev_setup_done);\n}\n\nvoid ath10k_wmi_event_vdev_stopped(struct ath10k *ar, struct sk_buff *skb)\n{\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"WMI_VDEV_STOPPED_EVENTID\\n\");\n\tcomplete(&ar->vdev_setup_done);\n}\n\nstatic int\nath10k_wmi_op_pull_peer_kick_ev(struct ath10k *ar, struct sk_buff *skb,\n\t\t\t\tstruct wmi_peer_kick_ev_arg *arg)\n{\n\tstruct wmi_peer_sta_kickout_event *ev = (void *)skb->data;\n\n\tif (skb->len < sizeof(*ev))\n\t\treturn -EPROTO;\n\n\tskb_pull(skb, sizeof(*ev));\n\targ->mac_addr = ev->peer_macaddr.addr;\n\n\treturn 0;\n}\n\nvoid ath10k_wmi_event_peer_sta_kickout(struct ath10k *ar, struct sk_buff *skb)\n{\n\tstruct wmi_peer_kick_ev_arg arg = {};\n\tstruct ieee80211_sta *sta;\n\tint ret;\n\n\tret = ath10k_wmi_pull_peer_kick(ar, skb, &arg);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to parse peer kickout event: %d\\n\",\n\t\t\t    ret);\n\t\treturn;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_STA, \"wmi event peer sta kickout %pM\\n\",\n\t\t   arg.mac_addr);\n\n\trcu_read_lock();\n\n\tsta = ieee80211_find_sta_by_ifaddr(ar->hw, arg.mac_addr, NULL);\n\tif (!sta) {\n\t\tath10k_warn(ar, \"Spurious quick kickout for STA %pM\\n\",\n\t\t\t    arg.mac_addr);\n\t\tgoto exit;\n\t}\n\n\tieee80211_report_low_ack(sta, 10);\n\nexit:\n\trcu_read_unlock();\n}\n\n \nstatic void ath10k_wmi_update_tim(struct ath10k *ar,\n\t\t\t\t  struct ath10k_vif *arvif,\n\t\t\t\t  struct sk_buff *bcn,\n\t\t\t\t  const struct wmi_tim_info_arg *tim_info)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)bcn->data;\n\tstruct ieee80211_tim_ie *tim;\n\tu8 *ies, *ie;\n\tu8 ie_len, pvm_len;\n\t__le32 t;\n\tu32 v, tim_len;\n\n\t \n\ttim_len = tim_info->tim_len ? __le32_to_cpu(tim_info->tim_len) : 1;\n\n\t \n\tif (__le32_to_cpu(tim_info->tim_changed)) {\n\t\tint i;\n\n\t\tif (sizeof(arvif->u.ap.tim_bitmap) < tim_len) {\n\t\t\tath10k_warn(ar, \"SWBA TIM field is too big (%u), truncated it to %zu\",\n\t\t\t\t    tim_len, sizeof(arvif->u.ap.tim_bitmap));\n\t\t\ttim_len = sizeof(arvif->u.ap.tim_bitmap);\n\t\t}\n\n\t\tfor (i = 0; i < tim_len; i++) {\n\t\t\tt = tim_info->tim_bitmap[i / 4];\n\t\t\tv = __le32_to_cpu(t);\n\t\t\tarvif->u.ap.tim_bitmap[i] = (v >> ((i % 4) * 8)) & 0xFF;\n\t\t}\n\n\t\t \n\t\tarvif->u.ap.tim_len = 0;\n\t\tfor (i = 0; i < tim_len; i++)\n\t\t\tif (arvif->u.ap.tim_bitmap[i])\n\t\t\t\tarvif->u.ap.tim_len = i;\n\n\t\tarvif->u.ap.tim_len++;\n\t}\n\n\ties = bcn->data;\n\ties += ieee80211_hdrlen(hdr->frame_control);\n\ties += 12;  \n\n\tie = (u8 *)cfg80211_find_ie(WLAN_EID_TIM, ies,\n\t\t\t\t    (u8 *)skb_tail_pointer(bcn) - ies);\n\tif (!ie) {\n\t\tif (arvif->vdev_type != WMI_VDEV_TYPE_IBSS)\n\t\t\tath10k_warn(ar, \"no tim ie found;\\n\");\n\t\treturn;\n\t}\n\n\ttim = (void *)ie + 2;\n\tie_len = ie[1];\n\tpvm_len = ie_len - 3;  \n\n\tif (pvm_len < arvif->u.ap.tim_len) {\n\t\tint expand_size = tim_len - pvm_len;\n\t\tint move_size = skb_tail_pointer(bcn) - (ie + 2 + ie_len);\n\t\tvoid *next_ie = ie + 2 + ie_len;\n\n\t\tif (skb_put(bcn, expand_size)) {\n\t\t\tmemmove(next_ie + expand_size, next_ie, move_size);\n\n\t\t\tie[1] += expand_size;\n\t\t\tie_len += expand_size;\n\t\t\tpvm_len += expand_size;\n\t\t} else {\n\t\t\tath10k_warn(ar, \"tim expansion failed\\n\");\n\t\t}\n\t}\n\n\tif (pvm_len > tim_len) {\n\t\tath10k_warn(ar, \"tim pvm length is too great (%d)\\n\", pvm_len);\n\t\treturn;\n\t}\n\n\ttim->bitmap_ctrl = !!__le32_to_cpu(tim_info->tim_mcast);\n\tmemcpy(tim->virtual_map, arvif->u.ap.tim_bitmap, pvm_len);\n\n\tif (tim->dtim_count == 0) {\n\t\tATH10K_SKB_CB(bcn)->flags |= ATH10K_SKB_F_DTIM_ZERO;\n\n\t\tif (__le32_to_cpu(tim_info->tim_mcast) == 1)\n\t\t\tATH10K_SKB_CB(bcn)->flags |= ATH10K_SKB_F_DELIVER_CAB;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_MGMT, \"dtim %d/%d mcast %d pvmlen %d\\n\",\n\t\t   tim->dtim_count, tim->dtim_period,\n\t\t   tim->bitmap_ctrl, pvm_len);\n}\n\nstatic void ath10k_wmi_update_noa(struct ath10k *ar, struct ath10k_vif *arvif,\n\t\t\t\t  struct sk_buff *bcn,\n\t\t\t\t  const struct wmi_p2p_noa_info *noa)\n{\n\tif (!arvif->vif->p2p)\n\t\treturn;\n\n\tath10k_dbg(ar, ATH10K_DBG_MGMT, \"noa changed: %d\\n\", noa->changed);\n\n\tif (noa->changed & WMI_P2P_NOA_CHANGED_BIT)\n\t\tath10k_p2p_noa_update(arvif, noa);\n\n\tif (arvif->u.ap.noa_data)\n\t\tif (!pskb_expand_head(bcn, 0, arvif->u.ap.noa_len, GFP_ATOMIC))\n\t\t\tskb_put_data(bcn, arvif->u.ap.noa_data,\n\t\t\t\t     arvif->u.ap.noa_len);\n}\n\nstatic int ath10k_wmi_op_pull_swba_ev(struct ath10k *ar, struct sk_buff *skb,\n\t\t\t\t      struct wmi_swba_ev_arg *arg)\n{\n\tstruct wmi_host_swba_event *ev = (void *)skb->data;\n\tu32 map;\n\tsize_t i;\n\n\tif (skb->len < sizeof(*ev))\n\t\treturn -EPROTO;\n\n\tskb_pull(skb, sizeof(*ev));\n\targ->vdev_map = ev->vdev_map;\n\n\tfor (i = 0, map = __le32_to_cpu(ev->vdev_map); map; map >>= 1) {\n\t\tif (!(map & BIT(0)))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (WARN_ON_ONCE(i == ARRAY_SIZE(arg->tim_info)))\n\t\t\tbreak;\n\n\t\tif (__le32_to_cpu(ev->bcn_info[i].tim_info.tim_len) >\n\t\t     sizeof(ev->bcn_info[i].tim_info.tim_bitmap)) {\n\t\t\tath10k_warn(ar, \"refusing to parse invalid swba structure\\n\");\n\t\t\treturn -EPROTO;\n\t\t}\n\n\t\targ->tim_info[i].tim_len = ev->bcn_info[i].tim_info.tim_len;\n\t\targ->tim_info[i].tim_mcast = ev->bcn_info[i].tim_info.tim_mcast;\n\t\targ->tim_info[i].tim_bitmap =\n\t\t\t\tev->bcn_info[i].tim_info.tim_bitmap;\n\t\targ->tim_info[i].tim_changed =\n\t\t\t\tev->bcn_info[i].tim_info.tim_changed;\n\t\targ->tim_info[i].tim_num_ps_pending =\n\t\t\t\tev->bcn_info[i].tim_info.tim_num_ps_pending;\n\n\t\targ->noa_info[i] = &ev->bcn_info[i].p2p_noa_info;\n\t\ti++;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_wmi_10_2_4_op_pull_swba_ev(struct ath10k *ar,\n\t\t\t\t\t     struct sk_buff *skb,\n\t\t\t\t\t     struct wmi_swba_ev_arg *arg)\n{\n\tstruct wmi_10_2_4_host_swba_event *ev = (void *)skb->data;\n\tu32 map;\n\tsize_t i;\n\n\tif (skb->len < sizeof(*ev))\n\t\treturn -EPROTO;\n\n\tskb_pull(skb, sizeof(*ev));\n\targ->vdev_map = ev->vdev_map;\n\n\tfor (i = 0, map = __le32_to_cpu(ev->vdev_map); map; map >>= 1) {\n\t\tif (!(map & BIT(0)))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (WARN_ON_ONCE(i == ARRAY_SIZE(arg->tim_info)))\n\t\t\tbreak;\n\n\t\tif (__le32_to_cpu(ev->bcn_info[i].tim_info.tim_len) >\n\t\t     sizeof(ev->bcn_info[i].tim_info.tim_bitmap)) {\n\t\t\tath10k_warn(ar, \"refusing to parse invalid swba structure\\n\");\n\t\t\treturn -EPROTO;\n\t\t}\n\n\t\targ->tim_info[i].tim_len = ev->bcn_info[i].tim_info.tim_len;\n\t\targ->tim_info[i].tim_mcast = ev->bcn_info[i].tim_info.tim_mcast;\n\t\targ->tim_info[i].tim_bitmap =\n\t\t\t\tev->bcn_info[i].tim_info.tim_bitmap;\n\t\targ->tim_info[i].tim_changed =\n\t\t\t\tev->bcn_info[i].tim_info.tim_changed;\n\t\targ->tim_info[i].tim_num_ps_pending =\n\t\t\t\tev->bcn_info[i].tim_info.tim_num_ps_pending;\n\t\ti++;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_wmi_10_4_op_pull_swba_ev(struct ath10k *ar,\n\t\t\t\t\t   struct sk_buff *skb,\n\t\t\t\t\t   struct wmi_swba_ev_arg *arg)\n{\n\tstruct wmi_10_4_host_swba_event *ev = (void *)skb->data;\n\tu32 map, tim_len;\n\tsize_t i;\n\n\tif (skb->len < sizeof(*ev))\n\t\treturn -EPROTO;\n\n\tskb_pull(skb, sizeof(*ev));\n\targ->vdev_map = ev->vdev_map;\n\n\tfor (i = 0, map = __le32_to_cpu(ev->vdev_map); map; map >>= 1) {\n\t\tif (!(map & BIT(0)))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (WARN_ON_ONCE(i == ARRAY_SIZE(arg->tim_info)))\n\t\t\tbreak;\n\n\t\tif (__le32_to_cpu(ev->bcn_info[i].tim_info.tim_len) >\n\t\t      sizeof(ev->bcn_info[i].tim_info.tim_bitmap)) {\n\t\t\tath10k_warn(ar, \"refusing to parse invalid swba structure\\n\");\n\t\t\treturn -EPROTO;\n\t\t}\n\n\t\ttim_len = __le32_to_cpu(ev->bcn_info[i].tim_info.tim_len);\n\t\tif (tim_len) {\n\t\t\t \n\t\t\ttim_len -= 4;\n\t\t\targ->tim_info[i].tim_len = __cpu_to_le32(tim_len);\n\t\t} else {\n\t\t\targ->tim_info[i].tim_len = 0;\n\t\t}\n\n\t\targ->tim_info[i].tim_mcast = ev->bcn_info[i].tim_info.tim_mcast;\n\t\targ->tim_info[i].tim_bitmap =\n\t\t\t\tev->bcn_info[i].tim_info.tim_bitmap;\n\t\targ->tim_info[i].tim_changed =\n\t\t\t\tev->bcn_info[i].tim_info.tim_changed;\n\t\targ->tim_info[i].tim_num_ps_pending =\n\t\t\t\tev->bcn_info[i].tim_info.tim_num_ps_pending;\n\n\t\t \n\n\t\ti++;\n\t}\n\n\treturn 0;\n}\n\nstatic enum wmi_txbf_conf ath10k_wmi_10_4_txbf_conf_scheme(struct ath10k *ar)\n{\n\treturn WMI_TXBF_CONF_BEFORE_ASSOC;\n}\n\nvoid ath10k_wmi_event_host_swba(struct ath10k *ar, struct sk_buff *skb)\n{\n\tstruct wmi_swba_ev_arg arg = {};\n\tu32 map;\n\tint i = -1;\n\tconst struct wmi_tim_info_arg *tim_info;\n\tconst struct wmi_p2p_noa_info *noa_info;\n\tstruct ath10k_vif *arvif;\n\tstruct sk_buff *bcn;\n\tdma_addr_t paddr;\n\tint ret, vdev_id = 0;\n\n\tret = ath10k_wmi_pull_swba(ar, skb, &arg);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to parse swba event: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tmap = __le32_to_cpu(arg.vdev_map);\n\n\tath10k_dbg(ar, ATH10K_DBG_MGMT, \"mgmt swba vdev_map 0x%x\\n\",\n\t\t   map);\n\n\tfor (; map; map >>= 1, vdev_id++) {\n\t\tif (!(map & 0x1))\n\t\t\tcontinue;\n\n\t\ti++;\n\n\t\tif (i >= WMI_MAX_AP_VDEV) {\n\t\t\tath10k_warn(ar, \"swba has corrupted vdev map\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\ttim_info = &arg.tim_info[i];\n\t\tnoa_info = arg.noa_info[i];\n\n\t\tath10k_dbg(ar, ATH10K_DBG_MGMT,\n\t\t\t   \"mgmt event bcn_info %d tim_len %d mcast %d changed %d num_ps_pending %d bitmap 0x%08x%08x%08x%08x\\n\",\n\t\t\t   i,\n\t\t\t   __le32_to_cpu(tim_info->tim_len),\n\t\t\t   __le32_to_cpu(tim_info->tim_mcast),\n\t\t\t   __le32_to_cpu(tim_info->tim_changed),\n\t\t\t   __le32_to_cpu(tim_info->tim_num_ps_pending),\n\t\t\t   __le32_to_cpu(tim_info->tim_bitmap[3]),\n\t\t\t   __le32_to_cpu(tim_info->tim_bitmap[2]),\n\t\t\t   __le32_to_cpu(tim_info->tim_bitmap[1]),\n\t\t\t   __le32_to_cpu(tim_info->tim_bitmap[0]));\n\n\t\t \n\n\t\tarvif = ath10k_get_arvif(ar, vdev_id);\n\t\tif (arvif == NULL) {\n\t\t\tath10k_warn(ar, \"no vif for vdev_id %d found\\n\",\n\t\t\t\t    vdev_id);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (!arvif->is_up)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (arvif->vif->bss_conf.csa_active &&\n\t\t    ieee80211_beacon_cntdwn_is_complete(arvif->vif)) {\n\t\t\tieee80211_csa_finish(arvif->vif);\n\t\t\tcontinue;\n\t\t}\n\n\t\tbcn = ieee80211_beacon_get(ar->hw, arvif->vif, 0);\n\t\tif (!bcn) {\n\t\t\tath10k_warn(ar, \"could not get mac80211 beacon\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tath10k_tx_h_seq_no(arvif->vif, bcn);\n\t\tath10k_wmi_update_tim(ar, arvif, bcn, tim_info);\n\t\tath10k_wmi_update_noa(ar, arvif, bcn, noa_info);\n\n\t\tspin_lock_bh(&ar->data_lock);\n\n\t\tif (arvif->beacon) {\n\t\t\tswitch (arvif->beacon_state) {\n\t\t\tcase ATH10K_BEACON_SENT:\n\t\t\t\tbreak;\n\t\t\tcase ATH10K_BEACON_SCHEDULED:\n\t\t\t\tath10k_warn(ar, \"SWBA overrun on vdev %d, skipped old beacon\\n\",\n\t\t\t\t\t    arvif->vdev_id);\n\t\t\t\tbreak;\n\t\t\tcase ATH10K_BEACON_SENDING:\n\t\t\t\tath10k_warn(ar, \"SWBA overrun on vdev %d, skipped new beacon\\n\",\n\t\t\t\t\t    arvif->vdev_id);\n\t\t\t\tdev_kfree_skb(bcn);\n\t\t\t\tgoto skip;\n\t\t\t}\n\n\t\t\tath10k_mac_vif_beacon_free(arvif);\n\t\t}\n\n\t\tif (!arvif->beacon_buf) {\n\t\t\tpaddr = dma_map_single(arvif->ar->dev, bcn->data,\n\t\t\t\t\t       bcn->len, DMA_TO_DEVICE);\n\t\t\tret = dma_mapping_error(arvif->ar->dev, paddr);\n\t\t\tif (ret) {\n\t\t\t\tath10k_warn(ar, \"failed to map beacon: %d\\n\",\n\t\t\t\t\t    ret);\n\t\t\t\tdev_kfree_skb_any(bcn);\n\t\t\t\tgoto skip;\n\t\t\t}\n\n\t\t\tATH10K_SKB_CB(bcn)->paddr = paddr;\n\t\t} else {\n\t\t\tif (bcn->len > IEEE80211_MAX_FRAME_LEN) {\n\t\t\t\tath10k_warn(ar, \"trimming beacon %d -> %d bytes!\\n\",\n\t\t\t\t\t    bcn->len, IEEE80211_MAX_FRAME_LEN);\n\t\t\t\tskb_trim(bcn, IEEE80211_MAX_FRAME_LEN);\n\t\t\t}\n\t\t\tmemcpy(arvif->beacon_buf, bcn->data, bcn->len);\n\t\t\tATH10K_SKB_CB(bcn)->paddr = arvif->beacon_paddr;\n\t\t}\n\n\t\tarvif->beacon = bcn;\n\t\tarvif->beacon_state = ATH10K_BEACON_SCHEDULED;\n\n\t\ttrace_ath10k_tx_hdr(ar, bcn->data, bcn->len);\n\t\ttrace_ath10k_tx_payload(ar, bcn->data, bcn->len);\n\nskip:\n\t\tspin_unlock_bh(&ar->data_lock);\n\t}\n\n\tath10k_wmi_tx_beacons_nowait(ar);\n}\n\nvoid ath10k_wmi_event_tbttoffset_update(struct ath10k *ar, struct sk_buff *skb)\n{\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"WMI_TBTTOFFSET_UPDATE_EVENTID\\n\");\n}\n\nstatic void ath10k_radar_detected(struct ath10k *ar)\n{\n\tath10k_dbg(ar, ATH10K_DBG_REGULATORY, \"dfs radar detected\\n\");\n\tATH10K_DFS_STAT_INC(ar, radar_detected);\n\n\t \n\tif (ar->dfs_block_radar_events)\n\t\tath10k_info(ar, \"DFS Radar detected, but ignored as requested\\n\");\n\telse\n\t\tieee80211_radar_detected(ar->hw);\n}\n\nstatic void ath10k_radar_confirmation_work(struct work_struct *work)\n{\n\tstruct ath10k *ar = container_of(work, struct ath10k,\n\t\t\t\t\t radar_confirmation_work);\n\tstruct ath10k_radar_found_info radar_info;\n\tint ret, time_left;\n\n\treinit_completion(&ar->wmi.radar_confirm);\n\n\tspin_lock_bh(&ar->data_lock);\n\tmemcpy(&radar_info, &ar->last_radar_info, sizeof(radar_info));\n\tspin_unlock_bh(&ar->data_lock);\n\n\tret = ath10k_wmi_report_radar_found(ar, &radar_info);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to send radar found %d\\n\", ret);\n\t\tgoto wait_complete;\n\t}\n\n\ttime_left = wait_for_completion_timeout(&ar->wmi.radar_confirm,\n\t\t\t\t\t\tATH10K_WMI_DFS_CONF_TIMEOUT_HZ);\n\tif (time_left) {\n\t\t \n\t\tgoto wait_complete;\n\t} else {\n\t\t \n\t\tath10k_dbg(ar, ATH10K_DBG_REGULATORY,\n\t\t\t   \"dfs confirmation not received from fw, considering as radar\\n\");\n\t\tgoto radar_detected;\n\t}\n\nradar_detected:\n\tath10k_radar_detected(ar);\n\n\t \nwait_complete:\n\tspin_lock_bh(&ar->data_lock);\n\tif (ar->radar_conf_state != ATH10K_RADAR_CONFIRMATION_STOPPED)\n\t\tar->radar_conf_state = ATH10K_RADAR_CONFIRMATION_IDLE;\n\tspin_unlock_bh(&ar->data_lock);\n}\n\nstatic void ath10k_dfs_radar_report(struct ath10k *ar,\n\t\t\t\t    struct wmi_phyerr_ev_arg *phyerr,\n\t\t\t\t    const struct phyerr_radar_report *rr,\n\t\t\t\t    u64 tsf)\n{\n\tu32 reg0, reg1, tsf32l;\n\tstruct ieee80211_channel *ch;\n\tstruct pulse_event pe;\n\tstruct radar_detector_specs rs;\n\tu64 tsf64;\n\tu8 rssi, width;\n\tstruct ath10k_radar_found_info *radar_info;\n\n\treg0 = __le32_to_cpu(rr->reg0);\n\treg1 = __le32_to_cpu(rr->reg1);\n\n\tath10k_dbg(ar, ATH10K_DBG_REGULATORY,\n\t\t   \"wmi phyerr radar report chirp %d max_width %d agc_total_gain %d pulse_delta_diff %d\\n\",\n\t\t   MS(reg0, RADAR_REPORT_REG0_PULSE_IS_CHIRP),\n\t\t   MS(reg0, RADAR_REPORT_REG0_PULSE_IS_MAX_WIDTH),\n\t\t   MS(reg0, RADAR_REPORT_REG0_AGC_TOTAL_GAIN),\n\t\t   MS(reg0, RADAR_REPORT_REG0_PULSE_DELTA_DIFF));\n\tath10k_dbg(ar, ATH10K_DBG_REGULATORY,\n\t\t   \"wmi phyerr radar report pulse_delta_pean %d pulse_sidx %d fft_valid %d agc_mb_gain %d subchan_mask %d\\n\",\n\t\t   MS(reg0, RADAR_REPORT_REG0_PULSE_DELTA_PEAK),\n\t\t   MS(reg0, RADAR_REPORT_REG0_PULSE_SIDX),\n\t\t   MS(reg1, RADAR_REPORT_REG1_PULSE_SRCH_FFT_VALID),\n\t\t   MS(reg1, RADAR_REPORT_REG1_PULSE_AGC_MB_GAIN),\n\t\t   MS(reg1, RADAR_REPORT_REG1_PULSE_SUBCHAN_MASK));\n\tath10k_dbg(ar, ATH10K_DBG_REGULATORY,\n\t\t   \"wmi phyerr radar report pulse_tsf_offset 0x%X pulse_dur: %d\\n\",\n\t\t   MS(reg1, RADAR_REPORT_REG1_PULSE_TSF_OFFSET),\n\t\t   MS(reg1, RADAR_REPORT_REG1_PULSE_DUR));\n\n\tif (!ar->dfs_detector)\n\t\treturn;\n\n\tspin_lock_bh(&ar->data_lock);\n\tch = ar->rx_channel;\n\n\t \n\tif (!ch)\n\t\tch = ar->tgt_oper_chan;\n\n\tspin_unlock_bh(&ar->data_lock);\n\n\tif (!ch) {\n\t\tath10k_warn(ar, \"failed to derive channel for radar pulse, treating as radar\\n\");\n\t\tgoto radar_detected;\n\t}\n\n\t \n\ttsf32l = phyerr->tsf_timestamp;\n\ttsf64 = tsf & (~0xFFFFFFFFULL);\n\ttsf64 |= tsf32l;\n\n\twidth = MS(reg1, RADAR_REPORT_REG1_PULSE_DUR);\n\trssi = phyerr->rssi_combined;\n\n\t \n\tif (rssi & 0x80)\n\t\trssi = 0;\n\n\tpe.ts = tsf64;\n\tpe.freq = ch->center_freq;\n\tpe.width = width;\n\tpe.rssi = rssi;\n\tpe.chirp = (MS(reg0, RADAR_REPORT_REG0_PULSE_IS_CHIRP) != 0);\n\tath10k_dbg(ar, ATH10K_DBG_REGULATORY,\n\t\t   \"dfs add pulse freq: %d, width: %d, rssi %d, tsf: %llX\\n\",\n\t\t   pe.freq, pe.width, pe.rssi, pe.ts);\n\n\tATH10K_DFS_STAT_INC(ar, pulses_detected);\n\n\tif (!ar->dfs_detector->add_pulse(ar->dfs_detector, &pe, &rs)) {\n\t\tath10k_dbg(ar, ATH10K_DBG_REGULATORY,\n\t\t\t   \"dfs no pulse pattern detected, yet\\n\");\n\t\treturn;\n\t}\n\n\tif ((test_bit(WMI_SERVICE_HOST_DFS_CHECK_SUPPORT, ar->wmi.svc_map)) &&\n\t    ar->dfs_detector->region == NL80211_DFS_FCC) {\n\t\t \n\t\tspin_lock_bh(&ar->data_lock);\n\t\tif (ar->radar_conf_state != ATH10K_RADAR_CONFIRMATION_IDLE) {\n\t\t\tspin_unlock_bh(&ar->data_lock);\n\t\t\treturn;\n\t\t}\n\t\tar->radar_conf_state = ATH10K_RADAR_CONFIRMATION_INPROGRESS;\n\t\tradar_info = &ar->last_radar_info;\n\n\t\tradar_info->pri_min = rs.pri_min;\n\t\tradar_info->pri_max = rs.pri_max;\n\t\tradar_info->width_min = rs.width_min;\n\t\tradar_info->width_max = rs.width_max;\n\t\t \n\t\tradar_info->sidx_min = MS(reg0, RADAR_REPORT_REG0_PULSE_SIDX);\n\t\tradar_info->sidx_max = MS(reg0, RADAR_REPORT_REG0_PULSE_SIDX);\n\n\t\tath10k_dbg(ar, ATH10K_DBG_REGULATORY,\n\t\t\t   \"sending wmi radar found cmd pri_min %d pri_max %d width_min %d width_max %d sidx_min %d sidx_max %d\\n\",\n\t\t\t   radar_info->pri_min, radar_info->pri_max,\n\t\t\t   radar_info->width_min, radar_info->width_max,\n\t\t\t   radar_info->sidx_min, radar_info->sidx_max);\n\t\tieee80211_queue_work(ar->hw, &ar->radar_confirmation_work);\n\t\tspin_unlock_bh(&ar->data_lock);\n\t\treturn;\n\t}\n\nradar_detected:\n\tath10k_radar_detected(ar);\n}\n\nstatic int ath10k_dfs_fft_report(struct ath10k *ar,\n\t\t\t\t struct wmi_phyerr_ev_arg *phyerr,\n\t\t\t\t const struct phyerr_fft_report *fftr,\n\t\t\t\t u64 tsf)\n{\n\tu32 reg0, reg1;\n\tu8 rssi, peak_mag;\n\n\treg0 = __le32_to_cpu(fftr->reg0);\n\treg1 = __le32_to_cpu(fftr->reg1);\n\trssi = phyerr->rssi_combined;\n\n\tath10k_dbg(ar, ATH10K_DBG_REGULATORY,\n\t\t   \"wmi phyerr fft report total_gain_db %d base_pwr_db %d fft_chn_idx %d peak_sidx %d\\n\",\n\t\t   MS(reg0, SEARCH_FFT_REPORT_REG0_TOTAL_GAIN_DB),\n\t\t   MS(reg0, SEARCH_FFT_REPORT_REG0_BASE_PWR_DB),\n\t\t   MS(reg0, SEARCH_FFT_REPORT_REG0_FFT_CHN_IDX),\n\t\t   MS(reg0, SEARCH_FFT_REPORT_REG0_PEAK_SIDX));\n\tath10k_dbg(ar, ATH10K_DBG_REGULATORY,\n\t\t   \"wmi phyerr fft report rel_pwr_db %d avgpwr_db %d peak_mag %d num_store_bin %d\\n\",\n\t\t   MS(reg1, SEARCH_FFT_REPORT_REG1_RELPWR_DB),\n\t\t   MS(reg1, SEARCH_FFT_REPORT_REG1_AVGPWR_DB),\n\t\t   MS(reg1, SEARCH_FFT_REPORT_REG1_PEAK_MAG),\n\t\t   MS(reg1, SEARCH_FFT_REPORT_REG1_NUM_STR_BINS_IB));\n\n\tpeak_mag = MS(reg1, SEARCH_FFT_REPORT_REG1_PEAK_MAG);\n\n\t \n\tif (rssi == DFS_RSSI_POSSIBLY_FALSE &&\n\t    peak_mag < 2 * DFS_PEAK_MAG_THOLD_POSSIBLY_FALSE) {\n\t\tath10k_dbg(ar, ATH10K_DBG_REGULATORY, \"dfs false pulse detected\\n\");\n\t\tATH10K_DFS_STAT_INC(ar, pulses_discarded);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nvoid ath10k_wmi_event_dfs(struct ath10k *ar,\n\t\t\t  struct wmi_phyerr_ev_arg *phyerr,\n\t\t\t  u64 tsf)\n{\n\tint buf_len, tlv_len, res, i = 0;\n\tconst struct phyerr_tlv *tlv;\n\tconst struct phyerr_radar_report *rr;\n\tconst struct phyerr_fft_report *fftr;\n\tconst u8 *tlv_buf;\n\n\tbuf_len = phyerr->buf_len;\n\tath10k_dbg(ar, ATH10K_DBG_REGULATORY,\n\t\t   \"wmi event dfs err_code %d rssi %d tsfl 0x%X tsf64 0x%llX len %d\\n\",\n\t\t   phyerr->phy_err_code, phyerr->rssi_combined,\n\t\t   phyerr->tsf_timestamp, tsf, buf_len);\n\n\t \n\tif (!IS_ENABLED(CONFIG_ATH10K_DFS_CERTIFIED))\n\t\treturn;\n\n\tATH10K_DFS_STAT_INC(ar, pulses_total);\n\n\twhile (i < buf_len) {\n\t\tif (i + sizeof(*tlv) > buf_len) {\n\t\t\tath10k_warn(ar, \"too short buf for tlv header (%d)\\n\",\n\t\t\t\t    i);\n\t\t\treturn;\n\t\t}\n\n\t\ttlv = (struct phyerr_tlv *)&phyerr->buf[i];\n\t\ttlv_len = __le16_to_cpu(tlv->len);\n\t\ttlv_buf = &phyerr->buf[i + sizeof(*tlv)];\n\t\tath10k_dbg(ar, ATH10K_DBG_REGULATORY,\n\t\t\t   \"wmi event dfs tlv_len %d tlv_tag 0x%02X tlv_sig 0x%02X\\n\",\n\t\t\t   tlv_len, tlv->tag, tlv->sig);\n\n\t\tswitch (tlv->tag) {\n\t\tcase PHYERR_TLV_TAG_RADAR_PULSE_SUMMARY:\n\t\t\tif (i + sizeof(*tlv) + sizeof(*rr) > buf_len) {\n\t\t\t\tath10k_warn(ar, \"too short radar pulse summary (%d)\\n\",\n\t\t\t\t\t    i);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\trr = (struct phyerr_radar_report *)tlv_buf;\n\t\t\tath10k_dfs_radar_report(ar, phyerr, rr, tsf);\n\t\t\tbreak;\n\t\tcase PHYERR_TLV_TAG_SEARCH_FFT_REPORT:\n\t\t\tif (i + sizeof(*tlv) + sizeof(*fftr) > buf_len) {\n\t\t\t\tath10k_warn(ar, \"too short fft report (%d)\\n\",\n\t\t\t\t\t    i);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfftr = (struct phyerr_fft_report *)tlv_buf;\n\t\t\tres = ath10k_dfs_fft_report(ar, phyerr, fftr, tsf);\n\t\t\tif (res)\n\t\t\t\treturn;\n\t\t\tbreak;\n\t\t}\n\n\t\ti += sizeof(*tlv) + tlv_len;\n\t}\n}\n\nvoid ath10k_wmi_event_spectral_scan(struct ath10k *ar,\n\t\t\t\t    struct wmi_phyerr_ev_arg *phyerr,\n\t\t\t\t    u64 tsf)\n{\n\tint buf_len, tlv_len, res, i = 0;\n\tstruct phyerr_tlv *tlv;\n\tconst void *tlv_buf;\n\tconst struct phyerr_fft_report *fftr;\n\tsize_t fftr_len;\n\n\tbuf_len = phyerr->buf_len;\n\n\twhile (i < buf_len) {\n\t\tif (i + sizeof(*tlv) > buf_len) {\n\t\t\tath10k_warn(ar, \"failed to parse phyerr tlv header at byte %d\\n\",\n\t\t\t\t    i);\n\t\t\treturn;\n\t\t}\n\n\t\ttlv = (struct phyerr_tlv *)&phyerr->buf[i];\n\t\ttlv_len = __le16_to_cpu(tlv->len);\n\t\ttlv_buf = &phyerr->buf[i + sizeof(*tlv)];\n\n\t\tif (i + sizeof(*tlv) + tlv_len > buf_len) {\n\t\t\tath10k_warn(ar, \"failed to parse phyerr tlv payload at byte %d\\n\",\n\t\t\t\t    i);\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (tlv->tag) {\n\t\tcase PHYERR_TLV_TAG_SEARCH_FFT_REPORT:\n\t\t\tif (sizeof(*fftr) > tlv_len) {\n\t\t\t\tath10k_warn(ar, \"failed to parse fft report at byte %d\\n\",\n\t\t\t\t\t    i);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfftr_len = tlv_len - sizeof(*fftr);\n\t\t\tfftr = tlv_buf;\n\t\t\tres = ath10k_spectral_process_fft(ar, phyerr,\n\t\t\t\t\t\t\t  fftr, fftr_len,\n\t\t\t\t\t\t\t  tsf);\n\t\t\tif (res < 0) {\n\t\t\t\tath10k_dbg(ar, ATH10K_DBG_WMI, \"failed to process fft report: %d\\n\",\n\t\t\t\t\t   res);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\ti += sizeof(*tlv) + tlv_len;\n\t}\n}\n\nstatic int ath10k_wmi_op_pull_phyerr_ev_hdr(struct ath10k *ar,\n\t\t\t\t\t    struct sk_buff *skb,\n\t\t\t\t\t    struct wmi_phyerr_hdr_arg *arg)\n{\n\tstruct wmi_phyerr_event *ev = (void *)skb->data;\n\n\tif (skb->len < sizeof(*ev))\n\t\treturn -EPROTO;\n\n\targ->num_phyerrs = __le32_to_cpu(ev->num_phyerrs);\n\targ->tsf_l32 = __le32_to_cpu(ev->tsf_l32);\n\targ->tsf_u32 = __le32_to_cpu(ev->tsf_u32);\n\targ->buf_len = skb->len - sizeof(*ev);\n\targ->phyerrs = ev->phyerrs;\n\n\treturn 0;\n}\n\nstatic int ath10k_wmi_10_4_op_pull_phyerr_ev_hdr(struct ath10k *ar,\n\t\t\t\t\t\t struct sk_buff *skb,\n\t\t\t\t\t\t struct wmi_phyerr_hdr_arg *arg)\n{\n\tstruct wmi_10_4_phyerr_event *ev = (void *)skb->data;\n\n\tif (skb->len < sizeof(*ev))\n\t\treturn -EPROTO;\n\n\t \n\targ->num_phyerrs = 1;\n\n\targ->tsf_l32 = __le32_to_cpu(ev->tsf_l32);\n\targ->tsf_u32 = __le32_to_cpu(ev->tsf_u32);\n\targ->buf_len = skb->len;\n\targ->phyerrs = skb->data;\n\n\treturn 0;\n}\n\nint ath10k_wmi_op_pull_phyerr_ev(struct ath10k *ar,\n\t\t\t\t const void *phyerr_buf,\n\t\t\t\t int left_len,\n\t\t\t\t struct wmi_phyerr_ev_arg *arg)\n{\n\tconst struct wmi_phyerr *phyerr = phyerr_buf;\n\tint i;\n\n\tif (left_len < sizeof(*phyerr)) {\n\t\tath10k_warn(ar, \"wrong phyerr event head len %d (need: >=%zd)\\n\",\n\t\t\t    left_len, sizeof(*phyerr));\n\t\treturn -EINVAL;\n\t}\n\n\targ->tsf_timestamp = __le32_to_cpu(phyerr->tsf_timestamp);\n\targ->freq1 = __le16_to_cpu(phyerr->freq1);\n\targ->freq2 = __le16_to_cpu(phyerr->freq2);\n\targ->rssi_combined = phyerr->rssi_combined;\n\targ->chan_width_mhz = phyerr->chan_width_mhz;\n\targ->buf_len = __le32_to_cpu(phyerr->buf_len);\n\targ->buf = phyerr->buf;\n\targ->hdr_len = sizeof(*phyerr);\n\n\tfor (i = 0; i < 4; i++)\n\t\targ->nf_chains[i] = __le16_to_cpu(phyerr->nf_chains[i]);\n\n\tswitch (phyerr->phy_err_code) {\n\tcase PHY_ERROR_GEN_SPECTRAL_SCAN:\n\t\targ->phy_err_code = PHY_ERROR_SPECTRAL_SCAN;\n\t\tbreak;\n\tcase PHY_ERROR_GEN_FALSE_RADAR_EXT:\n\t\targ->phy_err_code = PHY_ERROR_FALSE_RADAR_EXT;\n\t\tbreak;\n\tcase PHY_ERROR_GEN_RADAR:\n\t\targ->phy_err_code = PHY_ERROR_RADAR;\n\t\tbreak;\n\tdefault:\n\t\targ->phy_err_code = PHY_ERROR_UNKNOWN;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_wmi_10_4_op_pull_phyerr_ev(struct ath10k *ar,\n\t\t\t\t\t     const void *phyerr_buf,\n\t\t\t\t\t     int left_len,\n\t\t\t\t\t     struct wmi_phyerr_ev_arg *arg)\n{\n\tconst struct wmi_10_4_phyerr_event *phyerr = phyerr_buf;\n\tu32 phy_err_mask;\n\tint i;\n\n\tif (left_len < sizeof(*phyerr)) {\n\t\tath10k_warn(ar, \"wrong phyerr event head len %d (need: >=%zd)\\n\",\n\t\t\t    left_len, sizeof(*phyerr));\n\t\treturn -EINVAL;\n\t}\n\n\targ->tsf_timestamp = __le32_to_cpu(phyerr->tsf_timestamp);\n\targ->freq1 = __le16_to_cpu(phyerr->freq1);\n\targ->freq2 = __le16_to_cpu(phyerr->freq2);\n\targ->rssi_combined = phyerr->rssi_combined;\n\targ->chan_width_mhz = phyerr->chan_width_mhz;\n\targ->buf_len = __le32_to_cpu(phyerr->buf_len);\n\targ->buf = phyerr->buf;\n\targ->hdr_len = sizeof(*phyerr);\n\n\tfor (i = 0; i < 4; i++)\n\t\targ->nf_chains[i] = __le16_to_cpu(phyerr->nf_chains[i]);\n\n\tphy_err_mask = __le32_to_cpu(phyerr->phy_err_mask[0]);\n\n\tif (phy_err_mask & PHY_ERROR_10_4_SPECTRAL_SCAN_MASK)\n\t\targ->phy_err_code = PHY_ERROR_SPECTRAL_SCAN;\n\telse if (phy_err_mask & PHY_ERROR_10_4_RADAR_MASK)\n\t\targ->phy_err_code = PHY_ERROR_RADAR;\n\telse\n\t\targ->phy_err_code = PHY_ERROR_UNKNOWN;\n\n\treturn 0;\n}\n\nvoid ath10k_wmi_event_phyerr(struct ath10k *ar, struct sk_buff *skb)\n{\n\tstruct wmi_phyerr_hdr_arg hdr_arg = {};\n\tstruct wmi_phyerr_ev_arg phyerr_arg = {};\n\tconst void *phyerr;\n\tu32 count, i, buf_len, phy_err_code;\n\tu64 tsf;\n\tint left_len, ret;\n\n\tATH10K_DFS_STAT_INC(ar, phy_errors);\n\n\tret = ath10k_wmi_pull_phyerr_hdr(ar, skb, &hdr_arg);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to parse phyerr event hdr: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\t \n\tcount = hdr_arg.num_phyerrs;\n\n\tleft_len = hdr_arg.buf_len;\n\n\ttsf = hdr_arg.tsf_u32;\n\ttsf <<= 32;\n\ttsf |= hdr_arg.tsf_l32;\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi event phyerr count %d tsf64 0x%llX\\n\",\n\t\t   count, tsf);\n\n\tphyerr = hdr_arg.phyerrs;\n\tfor (i = 0; i < count; i++) {\n\t\tret = ath10k_wmi_pull_phyerr(ar, phyerr, left_len, &phyerr_arg);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to parse phyerr event (%d)\\n\",\n\t\t\t\t    i);\n\t\t\treturn;\n\t\t}\n\n\t\tleft_len -= phyerr_arg.hdr_len;\n\t\tbuf_len = phyerr_arg.buf_len;\n\t\tphy_err_code = phyerr_arg.phy_err_code;\n\n\t\tif (left_len < buf_len) {\n\t\t\tath10k_warn(ar, \"single event (%d) wrong buf len\\n\", i);\n\t\t\treturn;\n\t\t}\n\n\t\tleft_len -= buf_len;\n\n\t\tswitch (phy_err_code) {\n\t\tcase PHY_ERROR_RADAR:\n\t\t\tath10k_wmi_event_dfs(ar, &phyerr_arg, tsf);\n\t\t\tbreak;\n\t\tcase PHY_ERROR_SPECTRAL_SCAN:\n\t\t\tath10k_wmi_event_spectral_scan(ar, &phyerr_arg, tsf);\n\t\t\tbreak;\n\t\tcase PHY_ERROR_FALSE_RADAR_EXT:\n\t\t\tath10k_wmi_event_dfs(ar, &phyerr_arg, tsf);\n\t\t\tath10k_wmi_event_spectral_scan(ar, &phyerr_arg, tsf);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tphyerr = phyerr + phyerr_arg.hdr_len + buf_len;\n\t}\n}\n\nstatic int\nath10k_wmi_10_4_op_pull_dfs_status_ev(struct ath10k *ar, struct sk_buff *skb,\n\t\t\t\t      struct wmi_dfs_status_ev_arg *arg)\n{\n\tstruct wmi_dfs_status_ev_arg *ev = (void *)skb->data;\n\n\tif (skb->len < sizeof(*ev))\n\t\treturn -EPROTO;\n\n\targ->status = ev->status;\n\n\treturn 0;\n}\n\nstatic void\nath10k_wmi_event_dfs_status_check(struct ath10k *ar, struct sk_buff *skb)\n{\n\tstruct wmi_dfs_status_ev_arg status_arg = {};\n\tint ret;\n\n\tret = ath10k_wmi_pull_dfs_status(ar, skb, &status_arg);\n\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to parse dfs status event: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_REGULATORY,\n\t\t   \"dfs status event received from fw: %d\\n\",\n\t\t   status_arg.status);\n\n\t \n\tif (status_arg.status == WMI_HW_RADAR_DETECTED ||\n\t    status_arg.status == WMI_RADAR_DETECTION_FAIL)\n\t\tath10k_radar_detected(ar);\n\tcomplete(&ar->wmi.radar_confirm);\n}\n\nvoid ath10k_wmi_event_roam(struct ath10k *ar, struct sk_buff *skb)\n{\n\tstruct wmi_roam_ev_arg arg = {};\n\tint ret;\n\tu32 vdev_id;\n\tu32 reason;\n\ts32 rssi;\n\n\tret = ath10k_wmi_pull_roam_ev(ar, skb, &arg);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to parse roam event: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tvdev_id = __le32_to_cpu(arg.vdev_id);\n\treason = __le32_to_cpu(arg.reason);\n\trssi = __le32_to_cpu(arg.rssi);\n\trssi += WMI_SPECTRAL_NOISE_FLOOR_REF_DEFAULT;\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi roam event vdev %u reason 0x%08x rssi %d\\n\",\n\t\t   vdev_id, reason, rssi);\n\n\tif (reason >= WMI_ROAM_REASON_MAX)\n\t\tath10k_warn(ar, \"ignoring unknown roam event reason %d on vdev %i\\n\",\n\t\t\t    reason, vdev_id);\n\n\tswitch (reason) {\n\tcase WMI_ROAM_REASON_BEACON_MISS:\n\t\tath10k_mac_handle_beacon_miss(ar, vdev_id);\n\t\tbreak;\n\tcase WMI_ROAM_REASON_BETTER_AP:\n\tcase WMI_ROAM_REASON_LOW_RSSI:\n\tcase WMI_ROAM_REASON_SUITABLE_AP_FOUND:\n\tcase WMI_ROAM_REASON_HO_FAILED:\n\t\tath10k_warn(ar, \"ignoring not implemented roam event reason %d on vdev %i\\n\",\n\t\t\t    reason, vdev_id);\n\t\tbreak;\n\t}\n}\n\nvoid ath10k_wmi_event_profile_match(struct ath10k *ar, struct sk_buff *skb)\n{\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"WMI_PROFILE_MATCH\\n\");\n}\n\nvoid ath10k_wmi_event_debug_print(struct ath10k *ar, struct sk_buff *skb)\n{\n\tchar buf[101], c;\n\tint i;\n\n\tfor (i = 0; i < sizeof(buf) - 1; i++) {\n\t\tif (i >= skb->len)\n\t\t\tbreak;\n\n\t\tc = skb->data[i];\n\n\t\tif (c == '\\0')\n\t\t\tbreak;\n\n\t\tif (isascii(c) && isprint(c))\n\t\t\tbuf[i] = c;\n\t\telse\n\t\t\tbuf[i] = '.';\n\t}\n\n\tif (i == sizeof(buf) - 1)\n\t\tath10k_warn(ar, \"wmi debug print truncated: %d\\n\", skb->len);\n\n\t \n\tif (skb->data[i - 1] == '\\n')\n\t\ti--;\n\n\t \n\tbuf[i] = '\\0';\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI_PRINT, \"wmi print '%s'\\n\", buf);\n}\n\nvoid ath10k_wmi_event_pdev_qvit(struct ath10k *ar, struct sk_buff *skb)\n{\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"WMI_PDEV_QVIT_EVENTID\\n\");\n}\n\nvoid ath10k_wmi_event_wlan_profile_data(struct ath10k *ar, struct sk_buff *skb)\n{\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"WMI_WLAN_PROFILE_DATA_EVENTID\\n\");\n}\n\nvoid ath10k_wmi_event_rtt_measurement_report(struct ath10k *ar,\n\t\t\t\t\t     struct sk_buff *skb)\n{\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"WMI_RTT_MEASUREMENT_REPORT_EVENTID\\n\");\n}\n\nvoid ath10k_wmi_event_tsf_measurement_report(struct ath10k *ar,\n\t\t\t\t\t     struct sk_buff *skb)\n{\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"WMI_TSF_MEASUREMENT_REPORT_EVENTID\\n\");\n}\n\nvoid ath10k_wmi_event_rtt_error_report(struct ath10k *ar, struct sk_buff *skb)\n{\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"WMI_RTT_ERROR_REPORT_EVENTID\\n\");\n}\n\nvoid ath10k_wmi_event_wow_wakeup_host(struct ath10k *ar, struct sk_buff *skb)\n{\n\tstruct wmi_wow_ev_arg ev = {};\n\tint ret;\n\n\tcomplete(&ar->wow.wakeup_completed);\n\n\tret = ath10k_wmi_pull_wow_event(ar, skb, &ev);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to parse wow wakeup event: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wow wakeup host reason %s\\n\",\n\t\t   wow_reason(ev.wake_reason));\n}\n\nvoid ath10k_wmi_event_dcs_interference(struct ath10k *ar, struct sk_buff *skb)\n{\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"WMI_DCS_INTERFERENCE_EVENTID\\n\");\n}\n\nstatic u8 ath10k_tpc_config_get_rate(struct ath10k *ar,\n\t\t\t\t     struct wmi_pdev_tpc_config_event *ev,\n\t\t\t\t     u32 rate_idx, u32 num_chains,\n\t\t\t\t     u32 rate_code, u8 type)\n{\n\tu8 tpc, num_streams, preamble, ch, stm_idx;\n\n\tnum_streams = ATH10K_HW_NSS(rate_code);\n\tpreamble = ATH10K_HW_PREAMBLE(rate_code);\n\tch = num_chains - 1;\n\n\ttpc = min_t(u8, ev->rates_array[rate_idx], ev->max_reg_allow_pow[ch]);\n\n\tif (__le32_to_cpu(ev->num_tx_chain) <= 1)\n\t\tgoto out;\n\n\tif (preamble == WMI_RATE_PREAMBLE_CCK)\n\t\tgoto out;\n\n\tstm_idx = num_streams - 1;\n\tif (num_chains <= num_streams)\n\t\tgoto out;\n\n\tswitch (type) {\n\tcase WMI_TPC_TABLE_TYPE_STBC:\n\t\ttpc = min_t(u8, tpc,\n\t\t\t    ev->max_reg_allow_pow_agstbc[ch - 1][stm_idx]);\n\t\tbreak;\n\tcase WMI_TPC_TABLE_TYPE_TXBF:\n\t\ttpc = min_t(u8, tpc,\n\t\t\t    ev->max_reg_allow_pow_agtxbf[ch - 1][stm_idx]);\n\t\tbreak;\n\tcase WMI_TPC_TABLE_TYPE_CDD:\n\t\ttpc = min_t(u8, tpc,\n\t\t\t    ev->max_reg_allow_pow_agcdd[ch - 1][stm_idx]);\n\t\tbreak;\n\tdefault:\n\t\tath10k_warn(ar, \"unknown wmi tpc table type: %d\\n\", type);\n\t\ttpc = 0;\n\t\tbreak;\n\t}\n\nout:\n\treturn tpc;\n}\n\nstatic void ath10k_tpc_config_disp_tables(struct ath10k *ar,\n\t\t\t\t\t  struct wmi_pdev_tpc_config_event *ev,\n\t\t\t\t\t  struct ath10k_tpc_stats *tpc_stats,\n\t\t\t\t\t  u8 *rate_code, u16 *pream_table, u8 type)\n{\n\tu32 i, j, pream_idx, flags;\n\tu8 tpc[WMI_TPC_TX_N_CHAIN];\n\tchar tpc_value[WMI_TPC_TX_N_CHAIN * WMI_TPC_BUF_SIZE];\n\tchar buff[WMI_TPC_BUF_SIZE];\n\n\tflags = __le32_to_cpu(ev->flags);\n\n\tswitch (type) {\n\tcase WMI_TPC_TABLE_TYPE_CDD:\n\t\tif (!(flags & WMI_TPC_CONFIG_EVENT_FLAG_TABLE_CDD)) {\n\t\t\tath10k_dbg(ar, ATH10K_DBG_WMI, \"CDD not supported\\n\");\n\t\t\ttpc_stats->flag[type] = ATH10K_TPC_TABLE_TYPE_FLAG;\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase WMI_TPC_TABLE_TYPE_STBC:\n\t\tif (!(flags & WMI_TPC_CONFIG_EVENT_FLAG_TABLE_STBC)) {\n\t\t\tath10k_dbg(ar, ATH10K_DBG_WMI, \"STBC not supported\\n\");\n\t\t\ttpc_stats->flag[type] = ATH10K_TPC_TABLE_TYPE_FLAG;\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase WMI_TPC_TABLE_TYPE_TXBF:\n\t\tif (!(flags & WMI_TPC_CONFIG_EVENT_FLAG_TABLE_TXBF)) {\n\t\t\tath10k_dbg(ar, ATH10K_DBG_WMI, \"TXBF not supported\\n\");\n\t\t\ttpc_stats->flag[type] = ATH10K_TPC_TABLE_TYPE_FLAG;\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t\t   \"invalid table type in wmi tpc event: %d\\n\", type);\n\t\treturn;\n\t}\n\n\tpream_idx = 0;\n\tfor (i = 0; i < tpc_stats->rate_max; i++) {\n\t\tmemset(tpc_value, 0, sizeof(tpc_value));\n\t\tmemset(buff, 0, sizeof(buff));\n\t\tif (i == pream_table[pream_idx])\n\t\t\tpream_idx++;\n\n\t\tfor (j = 0; j < tpc_stats->num_tx_chain; j++) {\n\t\t\ttpc[j] = ath10k_tpc_config_get_rate(ar, ev, i, j + 1,\n\t\t\t\t\t\t\t    rate_code[i],\n\t\t\t\t\t\t\t    type);\n\t\t\tsnprintf(buff, sizeof(buff), \"%8d \", tpc[j]);\n\t\t\tstrlcat(tpc_value, buff, sizeof(tpc_value));\n\t\t}\n\t\ttpc_stats->tpc_table[type].pream_idx[i] = pream_idx;\n\t\ttpc_stats->tpc_table[type].rate_code[i] = rate_code[i];\n\t\tmemcpy(tpc_stats->tpc_table[type].tpc_value[i],\n\t\t       tpc_value, sizeof(tpc_value));\n\t}\n}\n\nvoid ath10k_wmi_tpc_config_get_rate_code(u8 *rate_code, u16 *pream_table,\n\t\t\t\t\t u32 num_tx_chain)\n{\n\tu32 i, j, pream_idx;\n\tu8 rate_idx;\n\n\t \n\trate_idx = 0;\n\tpream_idx = 0;\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\trate_code[rate_idx] =\n\t\t\tATH10K_HW_RATECODE(i, 0, WMI_RATE_PREAMBLE_CCK);\n\t\trate_idx++;\n\t}\n\tpream_table[pream_idx] = rate_idx;\n\tpream_idx++;\n\n\t \n\tfor (i = 0; i < 8; i++) {\n\t\trate_code[rate_idx] =\n\t\t\tATH10K_HW_RATECODE(i, 0, WMI_RATE_PREAMBLE_OFDM);\n\t\trate_idx++;\n\t}\n\tpream_table[pream_idx] = rate_idx;\n\tpream_idx++;\n\n\t \n\tfor (i = 0; i < num_tx_chain; i++) {\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\trate_code[rate_idx] =\n\t\t\tATH10K_HW_RATECODE(j, i, WMI_RATE_PREAMBLE_HT);\n\t\t\trate_idx++;\n\t\t}\n\t}\n\tpream_table[pream_idx] = rate_idx;\n\tpream_idx++;\n\n\t \n\tfor (i = 0; i < num_tx_chain; i++) {\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\trate_code[rate_idx] =\n\t\t\tATH10K_HW_RATECODE(j, i, WMI_RATE_PREAMBLE_HT);\n\t\t\trate_idx++;\n\t\t}\n\t}\n\tpream_table[pream_idx] = rate_idx;\n\tpream_idx++;\n\n\t \n\tfor (i = 0; i < num_tx_chain; i++) {\n\t\tfor (j = 0; j < 10; j++) {\n\t\t\trate_code[rate_idx] =\n\t\t\tATH10K_HW_RATECODE(j, i, WMI_RATE_PREAMBLE_VHT);\n\t\t\trate_idx++;\n\t\t}\n\t}\n\tpream_table[pream_idx] = rate_idx;\n\tpream_idx++;\n\n\t \n\tfor (i = 0; i < num_tx_chain; i++) {\n\t\tfor (j = 0; j < 10; j++) {\n\t\t\trate_code[rate_idx] =\n\t\t\tATH10K_HW_RATECODE(j, i, WMI_RATE_PREAMBLE_VHT);\n\t\t\trate_idx++;\n\t\t}\n\t}\n\tpream_table[pream_idx] = rate_idx;\n\tpream_idx++;\n\n\t \n\tfor (i = 0; i < num_tx_chain; i++) {\n\t\tfor (j = 0; j < 10; j++) {\n\t\t\trate_code[rate_idx] =\n\t\t\tATH10K_HW_RATECODE(j, i, WMI_RATE_PREAMBLE_VHT);\n\t\t\trate_idx++;\n\t\t}\n\t}\n\tpream_table[pream_idx] = rate_idx;\n\tpream_idx++;\n\n\trate_code[rate_idx++] =\n\t\tATH10K_HW_RATECODE(0, 0, WMI_RATE_PREAMBLE_CCK);\n\trate_code[rate_idx++] =\n\t\tATH10K_HW_RATECODE(0, 0, WMI_RATE_PREAMBLE_OFDM);\n\trate_code[rate_idx++] =\n\t\tATH10K_HW_RATECODE(0, 0, WMI_RATE_PREAMBLE_CCK);\n\trate_code[rate_idx++] =\n\t\tATH10K_HW_RATECODE(0, 0, WMI_RATE_PREAMBLE_OFDM);\n\trate_code[rate_idx++] =\n\t\tATH10K_HW_RATECODE(0, 0, WMI_RATE_PREAMBLE_OFDM);\n\n\tpream_table[pream_idx] = ATH10K_TPC_PREAM_TABLE_END;\n}\n\nvoid ath10k_wmi_event_pdev_tpc_config(struct ath10k *ar, struct sk_buff *skb)\n{\n\tu32 num_tx_chain, rate_max;\n\tu8 rate_code[WMI_TPC_RATE_MAX];\n\tu16 pream_table[WMI_TPC_PREAM_TABLE_MAX];\n\tstruct wmi_pdev_tpc_config_event *ev;\n\tstruct ath10k_tpc_stats *tpc_stats;\n\n\tev = (struct wmi_pdev_tpc_config_event *)skb->data;\n\n\tnum_tx_chain = __le32_to_cpu(ev->num_tx_chain);\n\n\tif (num_tx_chain > WMI_TPC_TX_N_CHAIN) {\n\t\tath10k_warn(ar, \"number of tx chain is %d greater than TPC configured tx chain %d\\n\",\n\t\t\t    num_tx_chain, WMI_TPC_TX_N_CHAIN);\n\t\treturn;\n\t}\n\n\trate_max = __le32_to_cpu(ev->rate_max);\n\tif (rate_max > WMI_TPC_RATE_MAX) {\n\t\tath10k_warn(ar, \"number of rate is %d greater than TPC configured rate %d\\n\",\n\t\t\t    rate_max, WMI_TPC_RATE_MAX);\n\t\trate_max = WMI_TPC_RATE_MAX;\n\t}\n\n\ttpc_stats = kzalloc(sizeof(*tpc_stats), GFP_ATOMIC);\n\tif (!tpc_stats)\n\t\treturn;\n\n\tath10k_wmi_tpc_config_get_rate_code(rate_code, pream_table,\n\t\t\t\t\t    num_tx_chain);\n\n\ttpc_stats->chan_freq = __le32_to_cpu(ev->chan_freq);\n\ttpc_stats->phy_mode = __le32_to_cpu(ev->phy_mode);\n\ttpc_stats->ctl = __le32_to_cpu(ev->ctl);\n\ttpc_stats->reg_domain = __le32_to_cpu(ev->reg_domain);\n\ttpc_stats->twice_antenna_gain = a_sle32_to_cpu(ev->twice_antenna_gain);\n\ttpc_stats->twice_antenna_reduction =\n\t\t__le32_to_cpu(ev->twice_antenna_reduction);\n\ttpc_stats->power_limit = __le32_to_cpu(ev->power_limit);\n\ttpc_stats->twice_max_rd_power = __le32_to_cpu(ev->twice_max_rd_power);\n\ttpc_stats->num_tx_chain = num_tx_chain;\n\ttpc_stats->rate_max = rate_max;\n\n\tath10k_tpc_config_disp_tables(ar, ev, tpc_stats,\n\t\t\t\t      rate_code, pream_table,\n\t\t\t\t      WMI_TPC_TABLE_TYPE_CDD);\n\tath10k_tpc_config_disp_tables(ar, ev,  tpc_stats,\n\t\t\t\t      rate_code, pream_table,\n\t\t\t\t      WMI_TPC_TABLE_TYPE_STBC);\n\tath10k_tpc_config_disp_tables(ar, ev, tpc_stats,\n\t\t\t\t      rate_code, pream_table,\n\t\t\t\t      WMI_TPC_TABLE_TYPE_TXBF);\n\n\tath10k_debug_tpc_stats_process(ar, tpc_stats);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi event tpc config channel %d mode %d ctl %d regd %d gain %d %d limit %d max_power %d tx_chanins %d rates %d\\n\",\n\t\t   __le32_to_cpu(ev->chan_freq),\n\t\t   __le32_to_cpu(ev->phy_mode),\n\t\t   __le32_to_cpu(ev->ctl),\n\t\t   __le32_to_cpu(ev->reg_domain),\n\t\t   a_sle32_to_cpu(ev->twice_antenna_gain),\n\t\t   __le32_to_cpu(ev->twice_antenna_reduction),\n\t\t   __le32_to_cpu(ev->power_limit),\n\t\t   __le32_to_cpu(ev->twice_max_rd_power) / 2,\n\t\t   __le32_to_cpu(ev->num_tx_chain),\n\t\t   __le32_to_cpu(ev->rate_max));\n}\n\nstatic u8\nath10k_wmi_tpc_final_get_rate(struct ath10k *ar,\n\t\t\t      struct wmi_pdev_tpc_final_table_event *ev,\n\t\t\t      u32 rate_idx, u32 num_chains,\n\t\t\t      u32 rate_code, u8 type, u32 pream_idx)\n{\n\tu8 tpc, num_streams, preamble, ch, stm_idx;\n\ts8 pow_agcdd, pow_agstbc, pow_agtxbf;\n\tint pream;\n\n\tnum_streams = ATH10K_HW_NSS(rate_code);\n\tpreamble = ATH10K_HW_PREAMBLE(rate_code);\n\tch = num_chains - 1;\n\tstm_idx = num_streams - 1;\n\tpream = -1;\n\n\tif (__le32_to_cpu(ev->chan_freq) <= 2483) {\n\t\tswitch (pream_idx) {\n\t\tcase WMI_TPC_PREAM_2GHZ_CCK:\n\t\t\tpream = 0;\n\t\t\tbreak;\n\t\tcase WMI_TPC_PREAM_2GHZ_OFDM:\n\t\t\tpream = 1;\n\t\t\tbreak;\n\t\tcase WMI_TPC_PREAM_2GHZ_HT20:\n\t\tcase WMI_TPC_PREAM_2GHZ_VHT20:\n\t\t\tpream = 2;\n\t\t\tbreak;\n\t\tcase WMI_TPC_PREAM_2GHZ_HT40:\n\t\tcase WMI_TPC_PREAM_2GHZ_VHT40:\n\t\t\tpream = 3;\n\t\t\tbreak;\n\t\tcase WMI_TPC_PREAM_2GHZ_VHT80:\n\t\t\tpream = 4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpream = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (__le32_to_cpu(ev->chan_freq) >= 5180) {\n\t\tswitch (pream_idx) {\n\t\tcase WMI_TPC_PREAM_5GHZ_OFDM:\n\t\t\tpream = 0;\n\t\t\tbreak;\n\t\tcase WMI_TPC_PREAM_5GHZ_HT20:\n\t\tcase WMI_TPC_PREAM_5GHZ_VHT20:\n\t\t\tpream = 1;\n\t\t\tbreak;\n\t\tcase WMI_TPC_PREAM_5GHZ_HT40:\n\t\tcase WMI_TPC_PREAM_5GHZ_VHT40:\n\t\t\tpream = 2;\n\t\t\tbreak;\n\t\tcase WMI_TPC_PREAM_5GHZ_VHT80:\n\t\t\tpream = 3;\n\t\t\tbreak;\n\t\tcase WMI_TPC_PREAM_5GHZ_HTCUP:\n\t\t\tpream = 4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpream = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (pream == -1) {\n\t\tath10k_warn(ar, \"unknown wmi tpc final index and frequency: %u, %u\\n\",\n\t\t\t    pream_idx, __le32_to_cpu(ev->chan_freq));\n\t\ttpc = 0;\n\t\tgoto out;\n\t}\n\n\tif (pream == 4)\n\t\ttpc = min_t(u8, ev->rates_array[rate_idx],\n\t\t\t    ev->max_reg_allow_pow[ch]);\n\telse\n\t\ttpc = min_t(u8, min_t(u8, ev->rates_array[rate_idx],\n\t\t\t\t      ev->max_reg_allow_pow[ch]),\n\t\t\t    ev->ctl_power_table[0][pream][stm_idx]);\n\n\tif (__le32_to_cpu(ev->num_tx_chain) <= 1)\n\t\tgoto out;\n\n\tif (preamble == WMI_RATE_PREAMBLE_CCK)\n\t\tgoto out;\n\n\tif (num_chains <= num_streams)\n\t\tgoto out;\n\n\tswitch (type) {\n\tcase WMI_TPC_TABLE_TYPE_STBC:\n\t\tpow_agstbc = ev->max_reg_allow_pow_agstbc[ch - 1][stm_idx];\n\t\tif (pream == 4)\n\t\t\ttpc = min_t(u8, tpc, pow_agstbc);\n\t\telse\n\t\t\ttpc = min_t(u8, min_t(u8, tpc, pow_agstbc),\n\t\t\t\t    ev->ctl_power_table[0][pream][stm_idx]);\n\t\tbreak;\n\tcase WMI_TPC_TABLE_TYPE_TXBF:\n\t\tpow_agtxbf = ev->max_reg_allow_pow_agtxbf[ch - 1][stm_idx];\n\t\tif (pream == 4)\n\t\t\ttpc = min_t(u8, tpc, pow_agtxbf);\n\t\telse\n\t\t\ttpc = min_t(u8, min_t(u8, tpc, pow_agtxbf),\n\t\t\t\t    ev->ctl_power_table[1][pream][stm_idx]);\n\t\tbreak;\n\tcase WMI_TPC_TABLE_TYPE_CDD:\n\t\tpow_agcdd = ev->max_reg_allow_pow_agcdd[ch - 1][stm_idx];\n\t\tif (pream == 4)\n\t\t\ttpc = min_t(u8, tpc, pow_agcdd);\n\t\telse\n\t\t\ttpc = min_t(u8, min_t(u8, tpc, pow_agcdd),\n\t\t\t\t    ev->ctl_power_table[0][pream][stm_idx]);\n\t\tbreak;\n\tdefault:\n\t\tath10k_warn(ar, \"unknown wmi tpc final table type: %d\\n\", type);\n\t\ttpc = 0;\n\t\tbreak;\n\t}\n\nout:\n\treturn tpc;\n}\n\nstatic void\nath10k_wmi_tpc_stats_final_disp_tables(struct ath10k *ar,\n\t\t\t\t       struct wmi_pdev_tpc_final_table_event *ev,\n\t\t\t\t       struct ath10k_tpc_stats_final *tpc_stats,\n\t\t\t\t       u8 *rate_code, u16 *pream_table, u8 type)\n{\n\tu32 i, j, pream_idx, flags;\n\tu8 tpc[WMI_TPC_TX_N_CHAIN];\n\tchar tpc_value[WMI_TPC_TX_N_CHAIN * WMI_TPC_BUF_SIZE];\n\tchar buff[WMI_TPC_BUF_SIZE];\n\n\tflags = __le32_to_cpu(ev->flags);\n\n\tswitch (type) {\n\tcase WMI_TPC_TABLE_TYPE_CDD:\n\t\tif (!(flags & WMI_TPC_CONFIG_EVENT_FLAG_TABLE_CDD)) {\n\t\t\tath10k_dbg(ar, ATH10K_DBG_WMI, \"CDD not supported\\n\");\n\t\t\ttpc_stats->flag[type] = ATH10K_TPC_TABLE_TYPE_FLAG;\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase WMI_TPC_TABLE_TYPE_STBC:\n\t\tif (!(flags & WMI_TPC_CONFIG_EVENT_FLAG_TABLE_STBC)) {\n\t\t\tath10k_dbg(ar, ATH10K_DBG_WMI, \"STBC not supported\\n\");\n\t\t\ttpc_stats->flag[type] = ATH10K_TPC_TABLE_TYPE_FLAG;\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tcase WMI_TPC_TABLE_TYPE_TXBF:\n\t\tif (!(flags & WMI_TPC_CONFIG_EVENT_FLAG_TABLE_TXBF)) {\n\t\t\tath10k_dbg(ar, ATH10K_DBG_WMI, \"TXBF not supported\\n\");\n\t\t\ttpc_stats->flag[type] = ATH10K_TPC_TABLE_TYPE_FLAG;\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t\t   \"invalid table type in wmi tpc event: %d\\n\", type);\n\t\treturn;\n\t}\n\n\tpream_idx = 0;\n\tfor (i = 0; i < tpc_stats->rate_max; i++) {\n\t\tmemset(tpc_value, 0, sizeof(tpc_value));\n\t\tmemset(buff, 0, sizeof(buff));\n\t\tif (i == pream_table[pream_idx])\n\t\t\tpream_idx++;\n\n\t\tfor (j = 0; j < tpc_stats->num_tx_chain; j++) {\n\t\t\ttpc[j] = ath10k_wmi_tpc_final_get_rate(ar, ev, i, j + 1,\n\t\t\t\t\t\t\t       rate_code[i],\n\t\t\t\t\t\t\t       type, pream_idx);\n\t\t\tsnprintf(buff, sizeof(buff), \"%8d \", tpc[j]);\n\t\t\tstrlcat(tpc_value, buff, sizeof(tpc_value));\n\t\t}\n\t\ttpc_stats->tpc_table_final[type].pream_idx[i] = pream_idx;\n\t\ttpc_stats->tpc_table_final[type].rate_code[i] = rate_code[i];\n\t\tmemcpy(tpc_stats->tpc_table_final[type].tpc_value[i],\n\t\t       tpc_value, sizeof(tpc_value));\n\t}\n}\n\nvoid ath10k_wmi_event_tpc_final_table(struct ath10k *ar, struct sk_buff *skb)\n{\n\tu32 num_tx_chain, rate_max;\n\tu8 rate_code[WMI_TPC_FINAL_RATE_MAX];\n\tu16 pream_table[WMI_TPC_PREAM_TABLE_MAX];\n\tstruct wmi_pdev_tpc_final_table_event *ev;\n\tstruct ath10k_tpc_stats_final *tpc_stats;\n\n\tev = (struct wmi_pdev_tpc_final_table_event *)skb->data;\n\n\tnum_tx_chain = __le32_to_cpu(ev->num_tx_chain);\n\tif (num_tx_chain > WMI_TPC_TX_N_CHAIN) {\n\t\tath10k_warn(ar, \"number of tx chain is %d greater than TPC final configured tx chain %d\\n\",\n\t\t\t    num_tx_chain, WMI_TPC_TX_N_CHAIN);\n\t\treturn;\n\t}\n\n\trate_max = __le32_to_cpu(ev->rate_max);\n\tif (rate_max > WMI_TPC_FINAL_RATE_MAX) {\n\t\tath10k_warn(ar, \"number of rate is %d greater than TPC final configured rate %d\\n\",\n\t\t\t    rate_max, WMI_TPC_FINAL_RATE_MAX);\n\t\trate_max = WMI_TPC_FINAL_RATE_MAX;\n\t}\n\n\ttpc_stats = kzalloc(sizeof(*tpc_stats), GFP_ATOMIC);\n\tif (!tpc_stats)\n\t\treturn;\n\n\tath10k_wmi_tpc_config_get_rate_code(rate_code, pream_table,\n\t\t\t\t\t    num_tx_chain);\n\n\ttpc_stats->chan_freq = __le32_to_cpu(ev->chan_freq);\n\ttpc_stats->phy_mode = __le32_to_cpu(ev->phy_mode);\n\ttpc_stats->ctl = __le32_to_cpu(ev->ctl);\n\ttpc_stats->reg_domain = __le32_to_cpu(ev->reg_domain);\n\ttpc_stats->twice_antenna_gain = a_sle32_to_cpu(ev->twice_antenna_gain);\n\ttpc_stats->twice_antenna_reduction =\n\t\t__le32_to_cpu(ev->twice_antenna_reduction);\n\ttpc_stats->power_limit = __le32_to_cpu(ev->power_limit);\n\ttpc_stats->twice_max_rd_power = __le32_to_cpu(ev->twice_max_rd_power);\n\ttpc_stats->num_tx_chain = num_tx_chain;\n\ttpc_stats->rate_max = rate_max;\n\n\tath10k_wmi_tpc_stats_final_disp_tables(ar, ev, tpc_stats,\n\t\t\t\t\t       rate_code, pream_table,\n\t\t\t\t\t       WMI_TPC_TABLE_TYPE_CDD);\n\tath10k_wmi_tpc_stats_final_disp_tables(ar, ev,  tpc_stats,\n\t\t\t\t\t       rate_code, pream_table,\n\t\t\t\t\t       WMI_TPC_TABLE_TYPE_STBC);\n\tath10k_wmi_tpc_stats_final_disp_tables(ar, ev, tpc_stats,\n\t\t\t\t\t       rate_code, pream_table,\n\t\t\t\t\t       WMI_TPC_TABLE_TYPE_TXBF);\n\n\tath10k_debug_tpc_stats_final_process(ar, tpc_stats);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi event tpc final table channel %d mode %d ctl %d regd %d gain %d %d limit %d max_power %d tx_chanins %d rates %d\\n\",\n\t\t   __le32_to_cpu(ev->chan_freq),\n\t\t   __le32_to_cpu(ev->phy_mode),\n\t\t   __le32_to_cpu(ev->ctl),\n\t\t   __le32_to_cpu(ev->reg_domain),\n\t\t   a_sle32_to_cpu(ev->twice_antenna_gain),\n\t\t   __le32_to_cpu(ev->twice_antenna_reduction),\n\t\t   __le32_to_cpu(ev->power_limit),\n\t\t   __le32_to_cpu(ev->twice_max_rd_power) / 2,\n\t\t   __le32_to_cpu(ev->num_tx_chain),\n\t\t   __le32_to_cpu(ev->rate_max));\n}\n\nstatic void\nath10k_wmi_handle_tdls_peer_event(struct ath10k *ar, struct sk_buff *skb)\n{\n\tstruct wmi_tdls_peer_event *ev;\n\tstruct ath10k_peer *peer;\n\tstruct ath10k_vif *arvif;\n\tint vdev_id;\n\tint peer_status;\n\tint peer_reason;\n\tu8 reason;\n\n\tif (skb->len < sizeof(*ev)) {\n\t\tath10k_err(ar, \"received tdls peer event with invalid size (%d bytes)\\n\",\n\t\t\t   skb->len);\n\t\treturn;\n\t}\n\n\tev = (struct wmi_tdls_peer_event *)skb->data;\n\tvdev_id = __le32_to_cpu(ev->vdev_id);\n\tpeer_status = __le32_to_cpu(ev->peer_status);\n\tpeer_reason = __le32_to_cpu(ev->peer_reason);\n\n\tspin_lock_bh(&ar->data_lock);\n\tpeer = ath10k_peer_find(ar, vdev_id, ev->peer_macaddr.addr);\n\tspin_unlock_bh(&ar->data_lock);\n\n\tif (!peer) {\n\t\tath10k_warn(ar, \"failed to find peer entry for %pM\\n\",\n\t\t\t    ev->peer_macaddr.addr);\n\t\treturn;\n\t}\n\n\tswitch (peer_status) {\n\tcase WMI_TDLS_SHOULD_TEARDOWN:\n\t\tswitch (peer_reason) {\n\t\tcase WMI_TDLS_TEARDOWN_REASON_PTR_TIMEOUT:\n\t\tcase WMI_TDLS_TEARDOWN_REASON_NO_RESPONSE:\n\t\tcase WMI_TDLS_TEARDOWN_REASON_RSSI:\n\t\t\treason = WLAN_REASON_TDLS_TEARDOWN_UNREACHABLE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treason = WLAN_REASON_TDLS_TEARDOWN_UNSPECIFIED;\n\t\t\tbreak;\n\t\t}\n\n\t\tarvif = ath10k_get_arvif(ar, vdev_id);\n\t\tif (!arvif) {\n\t\t\tath10k_warn(ar, \"received tdls peer event for invalid vdev id %u\\n\",\n\t\t\t\t    vdev_id);\n\t\t\treturn;\n\t\t}\n\n\t\tieee80211_tdls_oper_request(arvif->vif, ev->peer_macaddr.addr,\n\t\t\t\t\t    NL80211_TDLS_TEARDOWN, reason,\n\t\t\t\t\t    GFP_ATOMIC);\n\n\t\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t\t   \"received tdls teardown event for peer %pM reason %u\\n\",\n\t\t\t   ev->peer_macaddr.addr, peer_reason);\n\t\tbreak;\n\tdefault:\n\t\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t\t   \"received unknown tdls peer event %u\\n\",\n\t\t\t   peer_status);\n\t\tbreak;\n\t}\n}\n\nstatic void\nath10k_wmi_event_peer_sta_ps_state_chg(struct ath10k *ar, struct sk_buff *skb)\n{\n\tstruct wmi_peer_sta_ps_state_chg_event *ev;\n\tstruct ieee80211_sta *sta;\n\tstruct ath10k_sta *arsta;\n\tu8 peer_addr[ETH_ALEN];\n\n\tlockdep_assert_held(&ar->data_lock);\n\n\tev = (struct wmi_peer_sta_ps_state_chg_event *)skb->data;\n\tether_addr_copy(peer_addr, ev->peer_macaddr.addr);\n\n\trcu_read_lock();\n\n\tsta = ieee80211_find_sta_by_ifaddr(ar->hw, peer_addr, NULL);\n\n\tif (!sta) {\n\t\tath10k_warn(ar, \"failed to find station entry %pM\\n\",\n\t\t\t    peer_addr);\n\t\tgoto exit;\n\t}\n\n\tarsta = (struct ath10k_sta *)sta->drv_priv;\n\tarsta->peer_ps_state = __le32_to_cpu(ev->peer_ps_state);\n\nexit:\n\trcu_read_unlock();\n}\n\nvoid ath10k_wmi_event_pdev_ftm_intg(struct ath10k *ar, struct sk_buff *skb)\n{\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"WMI_PDEV_FTM_INTG_EVENTID\\n\");\n}\n\nvoid ath10k_wmi_event_gtk_offload_status(struct ath10k *ar, struct sk_buff *skb)\n{\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"WMI_GTK_OFFLOAD_STATUS_EVENTID\\n\");\n}\n\nvoid ath10k_wmi_event_gtk_rekey_fail(struct ath10k *ar, struct sk_buff *skb)\n{\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"WMI_GTK_REKEY_FAIL_EVENTID\\n\");\n}\n\nvoid ath10k_wmi_event_delba_complete(struct ath10k *ar, struct sk_buff *skb)\n{\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"WMI_TX_DELBA_COMPLETE_EVENTID\\n\");\n}\n\nvoid ath10k_wmi_event_addba_complete(struct ath10k *ar, struct sk_buff *skb)\n{\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"WMI_TX_ADDBA_COMPLETE_EVENTID\\n\");\n}\n\nvoid ath10k_wmi_event_vdev_install_key_complete(struct ath10k *ar,\n\t\t\t\t\t\tstruct sk_buff *skb)\n{\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"WMI_VDEV_INSTALL_KEY_COMPLETE_EVENTID\\n\");\n}\n\nvoid ath10k_wmi_event_inst_rssi_stats(struct ath10k *ar, struct sk_buff *skb)\n{\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"WMI_INST_RSSI_STATS_EVENTID\\n\");\n}\n\nvoid ath10k_wmi_event_vdev_standby_req(struct ath10k *ar, struct sk_buff *skb)\n{\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"WMI_VDEV_STANDBY_REQ_EVENTID\\n\");\n}\n\nvoid ath10k_wmi_event_vdev_resume_req(struct ath10k *ar, struct sk_buff *skb)\n{\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"WMI_VDEV_RESUME_REQ_EVENTID\\n\");\n}\n\nstatic int ath10k_wmi_alloc_chunk(struct ath10k *ar, u32 req_id,\n\t\t\t\t  u32 num_units, u32 unit_len)\n{\n\tdma_addr_t paddr;\n\tu32 pool_size;\n\tint idx = ar->wmi.num_mem_chunks;\n\tvoid *vaddr;\n\n\tpool_size = num_units * round_up(unit_len, 4);\n\tvaddr = dma_alloc_coherent(ar->dev, pool_size, &paddr, GFP_KERNEL);\n\n\tif (!vaddr)\n\t\treturn -ENOMEM;\n\n\tar->wmi.mem_chunks[idx].vaddr = vaddr;\n\tar->wmi.mem_chunks[idx].paddr = paddr;\n\tar->wmi.mem_chunks[idx].len = pool_size;\n\tar->wmi.mem_chunks[idx].req_id = req_id;\n\tar->wmi.num_mem_chunks++;\n\n\treturn num_units;\n}\n\nstatic int ath10k_wmi_alloc_host_mem(struct ath10k *ar, u32 req_id,\n\t\t\t\t     u32 num_units, u32 unit_len)\n{\n\tint ret;\n\n\twhile (num_units) {\n\t\tret = ath10k_wmi_alloc_chunk(ar, req_id, num_units, unit_len);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tnum_units -= ret;\n\t}\n\n\treturn 0;\n}\n\nstatic bool\nath10k_wmi_is_host_mem_allocated(struct ath10k *ar,\n\t\t\t\t const struct wlan_host_mem_req **mem_reqs,\n\t\t\t\t u32 num_mem_reqs)\n{\n\tu32 req_id, num_units, unit_size, num_unit_info;\n\tu32 pool_size;\n\tint i, j;\n\tbool found;\n\n\tif (ar->wmi.num_mem_chunks != num_mem_reqs)\n\t\treturn false;\n\n\tfor (i = 0; i < num_mem_reqs; ++i) {\n\t\treq_id = __le32_to_cpu(mem_reqs[i]->req_id);\n\t\tnum_units = __le32_to_cpu(mem_reqs[i]->num_units);\n\t\tunit_size = __le32_to_cpu(mem_reqs[i]->unit_size);\n\t\tnum_unit_info = __le32_to_cpu(mem_reqs[i]->num_unit_info);\n\n\t\tif (num_unit_info & NUM_UNITS_IS_NUM_ACTIVE_PEERS) {\n\t\t\tif (ar->num_active_peers)\n\t\t\t\tnum_units = ar->num_active_peers + 1;\n\t\t\telse\n\t\t\t\tnum_units = ar->max_num_peers + 1;\n\t\t} else if (num_unit_info & NUM_UNITS_IS_NUM_PEERS) {\n\t\t\tnum_units = ar->max_num_peers + 1;\n\t\t} else if (num_unit_info & NUM_UNITS_IS_NUM_VDEVS) {\n\t\t\tnum_units = ar->max_num_vdevs + 1;\n\t\t}\n\n\t\tfound = false;\n\t\tfor (j = 0; j < ar->wmi.num_mem_chunks; j++) {\n\t\t\tif (ar->wmi.mem_chunks[j].req_id == req_id) {\n\t\t\t\tpool_size = num_units * round_up(unit_size, 4);\n\t\t\t\tif (ar->wmi.mem_chunks[j].len == pool_size) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!found)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int\nath10k_wmi_main_op_pull_svc_rdy_ev(struct ath10k *ar, struct sk_buff *skb,\n\t\t\t\t   struct wmi_svc_rdy_ev_arg *arg)\n{\n\tstruct wmi_service_ready_event *ev;\n\tsize_t i, n;\n\n\tif (skb->len < sizeof(*ev))\n\t\treturn -EPROTO;\n\n\tev = (void *)skb->data;\n\tskb_pull(skb, sizeof(*ev));\n\targ->min_tx_power = ev->hw_min_tx_power;\n\targ->max_tx_power = ev->hw_max_tx_power;\n\targ->ht_cap = ev->ht_cap_info;\n\targ->vht_cap = ev->vht_cap_info;\n\targ->vht_supp_mcs = ev->vht_supp_mcs;\n\targ->sw_ver0 = ev->sw_version;\n\targ->sw_ver1 = ev->sw_version_1;\n\targ->phy_capab = ev->phy_capability;\n\targ->num_rf_chains = ev->num_rf_chains;\n\targ->eeprom_rd = ev->hal_reg_capabilities.eeprom_rd;\n\targ->low_2ghz_chan = ev->hal_reg_capabilities.low_2ghz_chan;\n\targ->high_2ghz_chan = ev->hal_reg_capabilities.high_2ghz_chan;\n\targ->low_5ghz_chan = ev->hal_reg_capabilities.low_5ghz_chan;\n\targ->high_5ghz_chan = ev->hal_reg_capabilities.high_5ghz_chan;\n\targ->num_mem_reqs = ev->num_mem_reqs;\n\targ->service_map = ev->wmi_service_bitmap;\n\targ->service_map_len = sizeof(ev->wmi_service_bitmap);\n\n\tn = min_t(size_t, __le32_to_cpu(arg->num_mem_reqs),\n\t\t  ARRAY_SIZE(arg->mem_reqs));\n\tfor (i = 0; i < n; i++)\n\t\targ->mem_reqs[i] = &ev->mem_reqs[i];\n\n\tif (skb->len <\n\t    __le32_to_cpu(arg->num_mem_reqs) * sizeof(arg->mem_reqs[0]))\n\t\treturn -EPROTO;\n\n\treturn 0;\n}\n\nstatic int\nath10k_wmi_10x_op_pull_svc_rdy_ev(struct ath10k *ar, struct sk_buff *skb,\n\t\t\t\t  struct wmi_svc_rdy_ev_arg *arg)\n{\n\tstruct wmi_10x_service_ready_event *ev;\n\tint i, n;\n\n\tif (skb->len < sizeof(*ev))\n\t\treturn -EPROTO;\n\n\tev = (void *)skb->data;\n\tskb_pull(skb, sizeof(*ev));\n\targ->min_tx_power = ev->hw_min_tx_power;\n\targ->max_tx_power = ev->hw_max_tx_power;\n\targ->ht_cap = ev->ht_cap_info;\n\targ->vht_cap = ev->vht_cap_info;\n\targ->vht_supp_mcs = ev->vht_supp_mcs;\n\targ->sw_ver0 = ev->sw_version;\n\targ->phy_capab = ev->phy_capability;\n\targ->num_rf_chains = ev->num_rf_chains;\n\targ->eeprom_rd = ev->hal_reg_capabilities.eeprom_rd;\n\targ->low_2ghz_chan = ev->hal_reg_capabilities.low_2ghz_chan;\n\targ->high_2ghz_chan = ev->hal_reg_capabilities.high_2ghz_chan;\n\targ->low_5ghz_chan = ev->hal_reg_capabilities.low_5ghz_chan;\n\targ->high_5ghz_chan = ev->hal_reg_capabilities.high_5ghz_chan;\n\targ->num_mem_reqs = ev->num_mem_reqs;\n\targ->service_map = ev->wmi_service_bitmap;\n\targ->service_map_len = sizeof(ev->wmi_service_bitmap);\n\n\t \n\n\tn = min_t(size_t, __le32_to_cpu(arg->num_mem_reqs),\n\t\t  ARRAY_SIZE(arg->mem_reqs));\n\tfor (i = 0; i < n; i++)\n\t\targ->mem_reqs[i] = &ev->mem_reqs[i];\n\n\tif (skb->len <\n\t    __le32_to_cpu(arg->num_mem_reqs) * sizeof(arg->mem_reqs[0]))\n\t\treturn -EPROTO;\n\n\treturn 0;\n}\n\nstatic void ath10k_wmi_event_service_ready_work(struct work_struct *work)\n{\n\tstruct ath10k *ar = container_of(work, struct ath10k, svc_rdy_work);\n\tstruct sk_buff *skb = ar->svc_rdy_skb;\n\tstruct wmi_svc_rdy_ev_arg arg = {};\n\tu32 num_units, req_id, unit_size, num_mem_reqs, num_unit_info, i;\n\tint ret;\n\tbool allocated;\n\n\tif (!skb) {\n\t\tath10k_warn(ar, \"invalid service ready event skb\\n\");\n\t\treturn;\n\t}\n\n\tret = ath10k_wmi_pull_svc_rdy(ar, skb, &arg);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to parse service ready: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tath10k_wmi_map_svc(ar, arg.service_map, ar->wmi.svc_map,\n\t\t\t   arg.service_map_len);\n\n\tar->hw_min_tx_power = __le32_to_cpu(arg.min_tx_power);\n\tar->hw_max_tx_power = __le32_to_cpu(arg.max_tx_power);\n\tar->ht_cap_info = __le32_to_cpu(arg.ht_cap);\n\tar->vht_cap_info = __le32_to_cpu(arg.vht_cap);\n\tar->vht_supp_mcs = __le32_to_cpu(arg.vht_supp_mcs);\n\tar->fw_version_major =\n\t\t(__le32_to_cpu(arg.sw_ver0) & 0xff000000) >> 24;\n\tar->fw_version_minor = (__le32_to_cpu(arg.sw_ver0) & 0x00ffffff);\n\tar->fw_version_release =\n\t\t(__le32_to_cpu(arg.sw_ver1) & 0xffff0000) >> 16;\n\tar->fw_version_build = (__le32_to_cpu(arg.sw_ver1) & 0x0000ffff);\n\tar->phy_capability = __le32_to_cpu(arg.phy_capab);\n\tar->num_rf_chains = __le32_to_cpu(arg.num_rf_chains);\n\tar->hw_eeprom_rd = __le32_to_cpu(arg.eeprom_rd);\n\tar->low_2ghz_chan = __le32_to_cpu(arg.low_2ghz_chan);\n\tar->high_2ghz_chan = __le32_to_cpu(arg.high_2ghz_chan);\n\tar->low_5ghz_chan = __le32_to_cpu(arg.low_5ghz_chan);\n\tar->high_5ghz_chan = __le32_to_cpu(arg.high_5ghz_chan);\n\tar->sys_cap_info = __le32_to_cpu(arg.sys_cap_info);\n\n\tath10k_dbg_dump(ar, ATH10K_DBG_WMI, NULL, \"wmi svc: \",\n\t\t\targ.service_map, arg.service_map_len);\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi sys_cap_info 0x%x\\n\",\n\t\t   ar->sys_cap_info);\n\n\tif (ar->num_rf_chains > ar->max_spatial_stream) {\n\t\tath10k_warn(ar, \"hardware advertises support for more spatial streams than it should (%d > %d)\\n\",\n\t\t\t    ar->num_rf_chains, ar->max_spatial_stream);\n\t\tar->num_rf_chains = ar->max_spatial_stream;\n\t}\n\n\tif (!ar->cfg_tx_chainmask) {\n\t\tar->cfg_tx_chainmask = (1 << ar->num_rf_chains) - 1;\n\t\tar->cfg_rx_chainmask = (1 << ar->num_rf_chains) - 1;\n\t}\n\n\tif (strlen(ar->hw->wiphy->fw_version) == 0) {\n\t\tsnprintf(ar->hw->wiphy->fw_version,\n\t\t\t sizeof(ar->hw->wiphy->fw_version),\n\t\t\t \"%u.%u.%u.%u\",\n\t\t\t ar->fw_version_major,\n\t\t\t ar->fw_version_minor,\n\t\t\t ar->fw_version_release,\n\t\t\t ar->fw_version_build);\n\t}\n\n\tnum_mem_reqs = __le32_to_cpu(arg.num_mem_reqs);\n\tif (num_mem_reqs > WMI_MAX_MEM_REQS) {\n\t\tath10k_warn(ar, \"requested memory chunks number (%d) exceeds the limit\\n\",\n\t\t\t    num_mem_reqs);\n\t\treturn;\n\t}\n\n\tif (test_bit(WMI_SERVICE_PEER_CACHING, ar->wmi.svc_map)) {\n\t\tif (test_bit(ATH10K_FW_FEATURE_PEER_FLOW_CONTROL,\n\t\t\t     ar->running_fw->fw_file.fw_features))\n\t\t\tar->num_active_peers = TARGET_10_4_QCACHE_ACTIVE_PEERS_PFC +\n\t\t\t\t\t       ar->max_num_vdevs;\n\t\telse\n\t\t\tar->num_active_peers = TARGET_10_4_QCACHE_ACTIVE_PEERS +\n\t\t\t\t\t       ar->max_num_vdevs;\n\n\t\tar->max_num_peers = TARGET_10_4_NUM_QCACHE_PEERS_MAX +\n\t\t\t\t    ar->max_num_vdevs;\n\t\tar->num_tids = ar->num_active_peers * 2;\n\t\tar->max_num_stations = TARGET_10_4_NUM_QCACHE_PEERS_MAX;\n\t}\n\n\t \n\n\tallocated = ath10k_wmi_is_host_mem_allocated(ar, arg.mem_reqs,\n\t\t\t\t\t\t     num_mem_reqs);\n\tif (allocated)\n\t\tgoto skip_mem_alloc;\n\n\t \n\tath10k_wmi_free_host_mem(ar);\n\n\tfor (i = 0; i < num_mem_reqs; ++i) {\n\t\treq_id = __le32_to_cpu(arg.mem_reqs[i]->req_id);\n\t\tnum_units = __le32_to_cpu(arg.mem_reqs[i]->num_units);\n\t\tunit_size = __le32_to_cpu(arg.mem_reqs[i]->unit_size);\n\t\tnum_unit_info = __le32_to_cpu(arg.mem_reqs[i]->num_unit_info);\n\n\t\tif (num_unit_info & NUM_UNITS_IS_NUM_ACTIVE_PEERS) {\n\t\t\tif (ar->num_active_peers)\n\t\t\t\tnum_units = ar->num_active_peers + 1;\n\t\t\telse\n\t\t\t\tnum_units = ar->max_num_peers + 1;\n\t\t} else if (num_unit_info & NUM_UNITS_IS_NUM_PEERS) {\n\t\t\t \n\t\t\tnum_units = ar->max_num_peers + 1;\n\t\t} else if (num_unit_info & NUM_UNITS_IS_NUM_VDEVS) {\n\t\t\tnum_units = ar->max_num_vdevs + 1;\n\t\t}\n\n\t\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t\t   \"wmi mem_req_id %d num_units %d num_unit_info %d unit size %d actual units %d\\n\",\n\t\t\t   req_id,\n\t\t\t   __le32_to_cpu(arg.mem_reqs[i]->num_units),\n\t\t\t   num_unit_info,\n\t\t\t   unit_size,\n\t\t\t   num_units);\n\n\t\tret = ath10k_wmi_alloc_host_mem(ar, req_id, num_units,\n\t\t\t\t\t\tunit_size);\n\t\tif (ret)\n\t\t\treturn;\n\t}\n\nskip_mem_alloc:\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi event service ready min_tx_power 0x%08x max_tx_power 0x%08x ht_cap 0x%08x vht_cap 0x%08x vht_supp_mcs 0x%08x sw_ver0 0x%08x sw_ver1 0x%08x fw_build 0x%08x phy_capab 0x%08x num_rf_chains 0x%08x eeprom_rd 0x%08x low_2ghz_chan %d high_2ghz_chan %d low_5ghz_chan %d high_5ghz_chan %d num_mem_reqs 0x%08x\\n\",\n\t\t   __le32_to_cpu(arg.min_tx_power),\n\t\t   __le32_to_cpu(arg.max_tx_power),\n\t\t   __le32_to_cpu(arg.ht_cap),\n\t\t   __le32_to_cpu(arg.vht_cap),\n\t\t   __le32_to_cpu(arg.vht_supp_mcs),\n\t\t   __le32_to_cpu(arg.sw_ver0),\n\t\t   __le32_to_cpu(arg.sw_ver1),\n\t\t   __le32_to_cpu(arg.fw_build),\n\t\t   __le32_to_cpu(arg.phy_capab),\n\t\t   __le32_to_cpu(arg.num_rf_chains),\n\t\t   __le32_to_cpu(arg.eeprom_rd),\n\t\t   __le32_to_cpu(arg.low_2ghz_chan),\n\t\t   __le32_to_cpu(arg.high_2ghz_chan),\n\t\t   __le32_to_cpu(arg.low_5ghz_chan),\n\t\t   __le32_to_cpu(arg.high_5ghz_chan),\n\t\t   __le32_to_cpu(arg.num_mem_reqs));\n\n\tdev_kfree_skb(skb);\n\tar->svc_rdy_skb = NULL;\n\tcomplete(&ar->wmi.service_ready);\n}\n\nvoid ath10k_wmi_event_service_ready(struct ath10k *ar, struct sk_buff *skb)\n{\n\tar->svc_rdy_skb = skb;\n\tqueue_work(ar->workqueue_aux, &ar->svc_rdy_work);\n}\n\nstatic int ath10k_wmi_op_pull_rdy_ev(struct ath10k *ar, struct sk_buff *skb,\n\t\t\t\t     struct wmi_rdy_ev_arg *arg)\n{\n\tstruct wmi_ready_event *ev = (void *)skb->data;\n\n\tif (skb->len < sizeof(*ev))\n\t\treturn -EPROTO;\n\n\tskb_pull(skb, sizeof(*ev));\n\targ->sw_version = ev->sw_version;\n\targ->abi_version = ev->abi_version;\n\targ->status = ev->status;\n\targ->mac_addr = ev->mac_addr.addr;\n\n\treturn 0;\n}\n\nstatic int ath10k_wmi_op_pull_roam_ev(struct ath10k *ar, struct sk_buff *skb,\n\t\t\t\t      struct wmi_roam_ev_arg *arg)\n{\n\tstruct wmi_roam_ev *ev = (void *)skb->data;\n\n\tif (skb->len < sizeof(*ev))\n\t\treturn -EPROTO;\n\n\tskb_pull(skb, sizeof(*ev));\n\targ->vdev_id = ev->vdev_id;\n\targ->reason = ev->reason;\n\n\treturn 0;\n}\n\nstatic int ath10k_wmi_op_pull_echo_ev(struct ath10k *ar,\n\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t      struct wmi_echo_ev_arg *arg)\n{\n\tstruct wmi_echo_event *ev = (void *)skb->data;\n\n\targ->value = ev->value;\n\n\treturn 0;\n}\n\nint ath10k_wmi_event_ready(struct ath10k *ar, struct sk_buff *skb)\n{\n\tstruct wmi_rdy_ev_arg arg = {};\n\tint ret;\n\n\tret = ath10k_wmi_pull_rdy(ar, skb, &arg);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to parse ready event: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi event ready sw_version 0x%08x abi_version %u mac_addr %pM status %d\\n\",\n\t\t   __le32_to_cpu(arg.sw_version),\n\t\t   __le32_to_cpu(arg.abi_version),\n\t\t   arg.mac_addr,\n\t\t   __le32_to_cpu(arg.status));\n\n\tif (is_zero_ether_addr(ar->mac_addr))\n\t\tether_addr_copy(ar->mac_addr, arg.mac_addr);\n\tcomplete(&ar->wmi.unified_ready);\n\treturn 0;\n}\n\nvoid ath10k_wmi_event_service_available(struct ath10k *ar, struct sk_buff *skb)\n{\n\tint ret;\n\tstruct wmi_svc_avail_ev_arg arg = {};\n\n\tret = ath10k_wmi_pull_svc_avail(ar, skb, &arg);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to parse service available event: %d\\n\",\n\t\t\t    ret);\n\t}\n\n\t \n\tif (arg.service_map_ext_valid)\n\t\tath10k_wmi_map_svc_ext(ar, arg.service_map_ext, ar->wmi.svc_map,\n\t\t\t\t       __le32_to_cpu(arg.service_map_ext_len));\n}\n\nstatic int ath10k_wmi_event_temperature(struct ath10k *ar, struct sk_buff *skb)\n{\n\tconst struct wmi_pdev_temperature_event *ev;\n\n\tev = (struct wmi_pdev_temperature_event *)skb->data;\n\tif (WARN_ON(skb->len < sizeof(*ev)))\n\t\treturn -EPROTO;\n\n\tath10k_thermal_event_temperature(ar, __le32_to_cpu(ev->temperature));\n\treturn 0;\n}\n\nstatic int ath10k_wmi_event_pdev_bss_chan_info(struct ath10k *ar,\n\t\t\t\t\t       struct sk_buff *skb)\n{\n\tstruct wmi_pdev_bss_chan_info_event *ev;\n\tstruct survey_info *survey;\n\tu64 busy, total, tx, rx, rx_bss;\n\tu32 freq, noise_floor;\n\tu32 cc_freq_hz = ar->hw_params.channel_counters_freq_hz;\n\tint idx;\n\n\tev = (struct wmi_pdev_bss_chan_info_event *)skb->data;\n\tif (WARN_ON(skb->len < sizeof(*ev)))\n\t\treturn -EPROTO;\n\n\tfreq        = __le32_to_cpu(ev->freq);\n\tnoise_floor = __le32_to_cpu(ev->noise_floor);\n\tbusy        = __le64_to_cpu(ev->cycle_busy);\n\ttotal       = __le64_to_cpu(ev->cycle_total);\n\ttx          = __le64_to_cpu(ev->cycle_tx);\n\trx          = __le64_to_cpu(ev->cycle_rx);\n\trx_bss      = __le64_to_cpu(ev->cycle_rx_bss);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi event pdev bss chan info:\\n freq: %d noise: %d cycle: busy %llu total %llu tx %llu rx %llu rx_bss %llu\\n\",\n\t\t   freq, noise_floor, busy, total, tx, rx, rx_bss);\n\n\tspin_lock_bh(&ar->data_lock);\n\tidx = freq_to_idx(ar, freq);\n\tif (idx >= ARRAY_SIZE(ar->survey)) {\n\t\tath10k_warn(ar, \"bss chan info: invalid frequency %d (idx %d out of bounds)\\n\",\n\t\t\t    freq, idx);\n\t\tgoto exit;\n\t}\n\n\tsurvey = &ar->survey[idx];\n\n\tsurvey->noise     = noise_floor;\n\tsurvey->time      = div_u64(total, cc_freq_hz);\n\tsurvey->time_busy = div_u64(busy, cc_freq_hz);\n\tsurvey->time_rx   = div_u64(rx_bss, cc_freq_hz);\n\tsurvey->time_tx   = div_u64(tx, cc_freq_hz);\n\tsurvey->filled   |= (SURVEY_INFO_NOISE_DBM |\n\t\t\t     SURVEY_INFO_TIME |\n\t\t\t     SURVEY_INFO_TIME_BUSY |\n\t\t\t     SURVEY_INFO_TIME_RX |\n\t\t\t     SURVEY_INFO_TIME_TX);\nexit:\n\tspin_unlock_bh(&ar->data_lock);\n\tcomplete(&ar->bss_survey_done);\n\treturn 0;\n}\n\nstatic inline void ath10k_wmi_queue_set_coverage_class_work(struct ath10k *ar)\n{\n\tif (ar->hw_params.hw_ops->set_coverage_class) {\n\t\tspin_lock_bh(&ar->data_lock);\n\n\t\t \n\t\tif (ar->fw_coverage.coverage_class)\n\t\t\tqueue_work(ar->workqueue, &ar->set_coverage_class_work);\n\n\t\tspin_unlock_bh(&ar->data_lock);\n\t}\n}\n\nstatic void ath10k_wmi_op_rx(struct ath10k *ar, struct sk_buff *skb)\n{\n\tstruct wmi_cmd_hdr *cmd_hdr;\n\tenum wmi_event_id id;\n\n\tcmd_hdr = (struct wmi_cmd_hdr *)skb->data;\n\tid = MS(__le32_to_cpu(cmd_hdr->cmd_id), WMI_CMD_HDR_CMD_ID);\n\n\tif (skb_pull(skb, sizeof(struct wmi_cmd_hdr)) == NULL)\n\t\tgoto out;\n\n\ttrace_ath10k_wmi_event(ar, id, skb->data, skb->len);\n\n\tswitch (id) {\n\tcase WMI_MGMT_RX_EVENTID:\n\t\tath10k_wmi_event_mgmt_rx(ar, skb);\n\t\t \n\t\treturn;\n\tcase WMI_SCAN_EVENTID:\n\t\tath10k_wmi_event_scan(ar, skb);\n\t\tath10k_wmi_queue_set_coverage_class_work(ar);\n\t\tbreak;\n\tcase WMI_CHAN_INFO_EVENTID:\n\t\tath10k_wmi_event_chan_info(ar, skb);\n\t\tbreak;\n\tcase WMI_ECHO_EVENTID:\n\t\tath10k_wmi_event_echo(ar, skb);\n\t\tbreak;\n\tcase WMI_DEBUG_MESG_EVENTID:\n\t\tath10k_wmi_event_debug_mesg(ar, skb);\n\t\tath10k_wmi_queue_set_coverage_class_work(ar);\n\t\tbreak;\n\tcase WMI_UPDATE_STATS_EVENTID:\n\t\tath10k_wmi_event_update_stats(ar, skb);\n\t\tbreak;\n\tcase WMI_VDEV_START_RESP_EVENTID:\n\t\tath10k_wmi_event_vdev_start_resp(ar, skb);\n\t\tath10k_wmi_queue_set_coverage_class_work(ar);\n\t\tbreak;\n\tcase WMI_VDEV_STOPPED_EVENTID:\n\t\tath10k_wmi_event_vdev_stopped(ar, skb);\n\t\tath10k_wmi_queue_set_coverage_class_work(ar);\n\t\tbreak;\n\tcase WMI_PEER_STA_KICKOUT_EVENTID:\n\t\tath10k_wmi_event_peer_sta_kickout(ar, skb);\n\t\tbreak;\n\tcase WMI_HOST_SWBA_EVENTID:\n\t\tath10k_wmi_event_host_swba(ar, skb);\n\t\tbreak;\n\tcase WMI_TBTTOFFSET_UPDATE_EVENTID:\n\t\tath10k_wmi_event_tbttoffset_update(ar, skb);\n\t\tbreak;\n\tcase WMI_PHYERR_EVENTID:\n\t\tath10k_wmi_event_phyerr(ar, skb);\n\t\tbreak;\n\tcase WMI_ROAM_EVENTID:\n\t\tath10k_wmi_event_roam(ar, skb);\n\t\tath10k_wmi_queue_set_coverage_class_work(ar);\n\t\tbreak;\n\tcase WMI_PROFILE_MATCH:\n\t\tath10k_wmi_event_profile_match(ar, skb);\n\t\tbreak;\n\tcase WMI_DEBUG_PRINT_EVENTID:\n\t\tath10k_wmi_event_debug_print(ar, skb);\n\t\tath10k_wmi_queue_set_coverage_class_work(ar);\n\t\tbreak;\n\tcase WMI_PDEV_QVIT_EVENTID:\n\t\tath10k_wmi_event_pdev_qvit(ar, skb);\n\t\tbreak;\n\tcase WMI_WLAN_PROFILE_DATA_EVENTID:\n\t\tath10k_wmi_event_wlan_profile_data(ar, skb);\n\t\tbreak;\n\tcase WMI_RTT_MEASUREMENT_REPORT_EVENTID:\n\t\tath10k_wmi_event_rtt_measurement_report(ar, skb);\n\t\tbreak;\n\tcase WMI_TSF_MEASUREMENT_REPORT_EVENTID:\n\t\tath10k_wmi_event_tsf_measurement_report(ar, skb);\n\t\tbreak;\n\tcase WMI_RTT_ERROR_REPORT_EVENTID:\n\t\tath10k_wmi_event_rtt_error_report(ar, skb);\n\t\tbreak;\n\tcase WMI_WOW_WAKEUP_HOST_EVENTID:\n\t\tath10k_wmi_event_wow_wakeup_host(ar, skb);\n\t\tbreak;\n\tcase WMI_DCS_INTERFERENCE_EVENTID:\n\t\tath10k_wmi_event_dcs_interference(ar, skb);\n\t\tbreak;\n\tcase WMI_PDEV_TPC_CONFIG_EVENTID:\n\t\tath10k_wmi_event_pdev_tpc_config(ar, skb);\n\t\tbreak;\n\tcase WMI_PDEV_FTM_INTG_EVENTID:\n\t\tath10k_wmi_event_pdev_ftm_intg(ar, skb);\n\t\tbreak;\n\tcase WMI_GTK_OFFLOAD_STATUS_EVENTID:\n\t\tath10k_wmi_event_gtk_offload_status(ar, skb);\n\t\tbreak;\n\tcase WMI_GTK_REKEY_FAIL_EVENTID:\n\t\tath10k_wmi_event_gtk_rekey_fail(ar, skb);\n\t\tbreak;\n\tcase WMI_TX_DELBA_COMPLETE_EVENTID:\n\t\tath10k_wmi_event_delba_complete(ar, skb);\n\t\tbreak;\n\tcase WMI_TX_ADDBA_COMPLETE_EVENTID:\n\t\tath10k_wmi_event_addba_complete(ar, skb);\n\t\tbreak;\n\tcase WMI_VDEV_INSTALL_KEY_COMPLETE_EVENTID:\n\t\tath10k_wmi_event_vdev_install_key_complete(ar, skb);\n\t\tbreak;\n\tcase WMI_SERVICE_READY_EVENTID:\n\t\tath10k_wmi_event_service_ready(ar, skb);\n\t\treturn;\n\tcase WMI_READY_EVENTID:\n\t\tath10k_wmi_event_ready(ar, skb);\n\t\tath10k_wmi_queue_set_coverage_class_work(ar);\n\t\tbreak;\n\tcase WMI_SERVICE_AVAILABLE_EVENTID:\n\t\tath10k_wmi_event_service_available(ar, skb);\n\t\tbreak;\n\tdefault:\n\t\tath10k_warn(ar, \"Unknown eventid: %d\\n\", id);\n\t\tbreak;\n\t}\n\nout:\n\tdev_kfree_skb(skb);\n}\n\nstatic void ath10k_wmi_10_1_op_rx(struct ath10k *ar, struct sk_buff *skb)\n{\n\tstruct wmi_cmd_hdr *cmd_hdr;\n\tenum wmi_10x_event_id id;\n\tbool consumed;\n\n\tcmd_hdr = (struct wmi_cmd_hdr *)skb->data;\n\tid = MS(__le32_to_cpu(cmd_hdr->cmd_id), WMI_CMD_HDR_CMD_ID);\n\n\tif (skb_pull(skb, sizeof(struct wmi_cmd_hdr)) == NULL)\n\t\tgoto out;\n\n\ttrace_ath10k_wmi_event(ar, id, skb->data, skb->len);\n\n\tconsumed = ath10k_tm_event_wmi(ar, id, skb);\n\n\t \n\tif (consumed && id != WMI_10X_READY_EVENTID) {\n\t\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t\t   \"wmi testmode consumed 0x%x\\n\", id);\n\t\tgoto out;\n\t}\n\n\tswitch (id) {\n\tcase WMI_10X_MGMT_RX_EVENTID:\n\t\tath10k_wmi_event_mgmt_rx(ar, skb);\n\t\t \n\t\treturn;\n\tcase WMI_10X_SCAN_EVENTID:\n\t\tath10k_wmi_event_scan(ar, skb);\n\t\tath10k_wmi_queue_set_coverage_class_work(ar);\n\t\tbreak;\n\tcase WMI_10X_CHAN_INFO_EVENTID:\n\t\tath10k_wmi_event_chan_info(ar, skb);\n\t\tbreak;\n\tcase WMI_10X_ECHO_EVENTID:\n\t\tath10k_wmi_event_echo(ar, skb);\n\t\tbreak;\n\tcase WMI_10X_DEBUG_MESG_EVENTID:\n\t\tath10k_wmi_event_debug_mesg(ar, skb);\n\t\tath10k_wmi_queue_set_coverage_class_work(ar);\n\t\tbreak;\n\tcase WMI_10X_UPDATE_STATS_EVENTID:\n\t\tath10k_wmi_event_update_stats(ar, skb);\n\t\tbreak;\n\tcase WMI_10X_VDEV_START_RESP_EVENTID:\n\t\tath10k_wmi_event_vdev_start_resp(ar, skb);\n\t\tath10k_wmi_queue_set_coverage_class_work(ar);\n\t\tbreak;\n\tcase WMI_10X_VDEV_STOPPED_EVENTID:\n\t\tath10k_wmi_event_vdev_stopped(ar, skb);\n\t\tath10k_wmi_queue_set_coverage_class_work(ar);\n\t\tbreak;\n\tcase WMI_10X_PEER_STA_KICKOUT_EVENTID:\n\t\tath10k_wmi_event_peer_sta_kickout(ar, skb);\n\t\tbreak;\n\tcase WMI_10X_HOST_SWBA_EVENTID:\n\t\tath10k_wmi_event_host_swba(ar, skb);\n\t\tbreak;\n\tcase WMI_10X_TBTTOFFSET_UPDATE_EVENTID:\n\t\tath10k_wmi_event_tbttoffset_update(ar, skb);\n\t\tbreak;\n\tcase WMI_10X_PHYERR_EVENTID:\n\t\tath10k_wmi_event_phyerr(ar, skb);\n\t\tbreak;\n\tcase WMI_10X_ROAM_EVENTID:\n\t\tath10k_wmi_event_roam(ar, skb);\n\t\tath10k_wmi_queue_set_coverage_class_work(ar);\n\t\tbreak;\n\tcase WMI_10X_PROFILE_MATCH:\n\t\tath10k_wmi_event_profile_match(ar, skb);\n\t\tbreak;\n\tcase WMI_10X_DEBUG_PRINT_EVENTID:\n\t\tath10k_wmi_event_debug_print(ar, skb);\n\t\tath10k_wmi_queue_set_coverage_class_work(ar);\n\t\tbreak;\n\tcase WMI_10X_PDEV_QVIT_EVENTID:\n\t\tath10k_wmi_event_pdev_qvit(ar, skb);\n\t\tbreak;\n\tcase WMI_10X_WLAN_PROFILE_DATA_EVENTID:\n\t\tath10k_wmi_event_wlan_profile_data(ar, skb);\n\t\tbreak;\n\tcase WMI_10X_RTT_MEASUREMENT_REPORT_EVENTID:\n\t\tath10k_wmi_event_rtt_measurement_report(ar, skb);\n\t\tbreak;\n\tcase WMI_10X_TSF_MEASUREMENT_REPORT_EVENTID:\n\t\tath10k_wmi_event_tsf_measurement_report(ar, skb);\n\t\tbreak;\n\tcase WMI_10X_RTT_ERROR_REPORT_EVENTID:\n\t\tath10k_wmi_event_rtt_error_report(ar, skb);\n\t\tbreak;\n\tcase WMI_10X_WOW_WAKEUP_HOST_EVENTID:\n\t\tath10k_wmi_event_wow_wakeup_host(ar, skb);\n\t\tbreak;\n\tcase WMI_10X_DCS_INTERFERENCE_EVENTID:\n\t\tath10k_wmi_event_dcs_interference(ar, skb);\n\t\tbreak;\n\tcase WMI_10X_PDEV_TPC_CONFIG_EVENTID:\n\t\tath10k_wmi_event_pdev_tpc_config(ar, skb);\n\t\tbreak;\n\tcase WMI_10X_INST_RSSI_STATS_EVENTID:\n\t\tath10k_wmi_event_inst_rssi_stats(ar, skb);\n\t\tbreak;\n\tcase WMI_10X_VDEV_STANDBY_REQ_EVENTID:\n\t\tath10k_wmi_event_vdev_standby_req(ar, skb);\n\t\tbreak;\n\tcase WMI_10X_VDEV_RESUME_REQ_EVENTID:\n\t\tath10k_wmi_event_vdev_resume_req(ar, skb);\n\t\tbreak;\n\tcase WMI_10X_SERVICE_READY_EVENTID:\n\t\tath10k_wmi_event_service_ready(ar, skb);\n\t\treturn;\n\tcase WMI_10X_READY_EVENTID:\n\t\tath10k_wmi_event_ready(ar, skb);\n\t\tath10k_wmi_queue_set_coverage_class_work(ar);\n\t\tbreak;\n\tcase WMI_10X_PDEV_UTF_EVENTID:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tath10k_warn(ar, \"Unknown eventid: %d\\n\", id);\n\t\tbreak;\n\t}\n\nout:\n\tdev_kfree_skb(skb);\n}\n\nstatic void ath10k_wmi_10_2_op_rx(struct ath10k *ar, struct sk_buff *skb)\n{\n\tstruct wmi_cmd_hdr *cmd_hdr;\n\tenum wmi_10_2_event_id id;\n\tbool consumed;\n\n\tcmd_hdr = (struct wmi_cmd_hdr *)skb->data;\n\tid = MS(__le32_to_cpu(cmd_hdr->cmd_id), WMI_CMD_HDR_CMD_ID);\n\n\tif (skb_pull(skb, sizeof(struct wmi_cmd_hdr)) == NULL)\n\t\tgoto out;\n\n\ttrace_ath10k_wmi_event(ar, id, skb->data, skb->len);\n\n\tconsumed = ath10k_tm_event_wmi(ar, id, skb);\n\n\t \n\tif (consumed && id != WMI_10_2_READY_EVENTID) {\n\t\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t\t   \"wmi testmode consumed 0x%x\\n\", id);\n\t\tgoto out;\n\t}\n\n\tswitch (id) {\n\tcase WMI_10_2_MGMT_RX_EVENTID:\n\t\tath10k_wmi_event_mgmt_rx(ar, skb);\n\t\t \n\t\treturn;\n\tcase WMI_10_2_SCAN_EVENTID:\n\t\tath10k_wmi_event_scan(ar, skb);\n\t\tath10k_wmi_queue_set_coverage_class_work(ar);\n\t\tbreak;\n\tcase WMI_10_2_CHAN_INFO_EVENTID:\n\t\tath10k_wmi_event_chan_info(ar, skb);\n\t\tbreak;\n\tcase WMI_10_2_ECHO_EVENTID:\n\t\tath10k_wmi_event_echo(ar, skb);\n\t\tbreak;\n\tcase WMI_10_2_DEBUG_MESG_EVENTID:\n\t\tath10k_wmi_event_debug_mesg(ar, skb);\n\t\tath10k_wmi_queue_set_coverage_class_work(ar);\n\t\tbreak;\n\tcase WMI_10_2_UPDATE_STATS_EVENTID:\n\t\tath10k_wmi_event_update_stats(ar, skb);\n\t\tbreak;\n\tcase WMI_10_2_VDEV_START_RESP_EVENTID:\n\t\tath10k_wmi_event_vdev_start_resp(ar, skb);\n\t\tath10k_wmi_queue_set_coverage_class_work(ar);\n\t\tbreak;\n\tcase WMI_10_2_VDEV_STOPPED_EVENTID:\n\t\tath10k_wmi_event_vdev_stopped(ar, skb);\n\t\tath10k_wmi_queue_set_coverage_class_work(ar);\n\t\tbreak;\n\tcase WMI_10_2_PEER_STA_KICKOUT_EVENTID:\n\t\tath10k_wmi_event_peer_sta_kickout(ar, skb);\n\t\tbreak;\n\tcase WMI_10_2_HOST_SWBA_EVENTID:\n\t\tath10k_wmi_event_host_swba(ar, skb);\n\t\tbreak;\n\tcase WMI_10_2_TBTTOFFSET_UPDATE_EVENTID:\n\t\tath10k_wmi_event_tbttoffset_update(ar, skb);\n\t\tbreak;\n\tcase WMI_10_2_PHYERR_EVENTID:\n\t\tath10k_wmi_event_phyerr(ar, skb);\n\t\tbreak;\n\tcase WMI_10_2_ROAM_EVENTID:\n\t\tath10k_wmi_event_roam(ar, skb);\n\t\tath10k_wmi_queue_set_coverage_class_work(ar);\n\t\tbreak;\n\tcase WMI_10_2_PROFILE_MATCH:\n\t\tath10k_wmi_event_profile_match(ar, skb);\n\t\tbreak;\n\tcase WMI_10_2_DEBUG_PRINT_EVENTID:\n\t\tath10k_wmi_event_debug_print(ar, skb);\n\t\tath10k_wmi_queue_set_coverage_class_work(ar);\n\t\tbreak;\n\tcase WMI_10_2_PDEV_QVIT_EVENTID:\n\t\tath10k_wmi_event_pdev_qvit(ar, skb);\n\t\tbreak;\n\tcase WMI_10_2_WLAN_PROFILE_DATA_EVENTID:\n\t\tath10k_wmi_event_wlan_profile_data(ar, skb);\n\t\tbreak;\n\tcase WMI_10_2_RTT_MEASUREMENT_REPORT_EVENTID:\n\t\tath10k_wmi_event_rtt_measurement_report(ar, skb);\n\t\tbreak;\n\tcase WMI_10_2_TSF_MEASUREMENT_REPORT_EVENTID:\n\t\tath10k_wmi_event_tsf_measurement_report(ar, skb);\n\t\tbreak;\n\tcase WMI_10_2_RTT_ERROR_REPORT_EVENTID:\n\t\tath10k_wmi_event_rtt_error_report(ar, skb);\n\t\tbreak;\n\tcase WMI_10_2_WOW_WAKEUP_HOST_EVENTID:\n\t\tath10k_wmi_event_wow_wakeup_host(ar, skb);\n\t\tbreak;\n\tcase WMI_10_2_DCS_INTERFERENCE_EVENTID:\n\t\tath10k_wmi_event_dcs_interference(ar, skb);\n\t\tbreak;\n\tcase WMI_10_2_PDEV_TPC_CONFIG_EVENTID:\n\t\tath10k_wmi_event_pdev_tpc_config(ar, skb);\n\t\tbreak;\n\tcase WMI_10_2_INST_RSSI_STATS_EVENTID:\n\t\tath10k_wmi_event_inst_rssi_stats(ar, skb);\n\t\tbreak;\n\tcase WMI_10_2_VDEV_STANDBY_REQ_EVENTID:\n\t\tath10k_wmi_event_vdev_standby_req(ar, skb);\n\t\tath10k_wmi_queue_set_coverage_class_work(ar);\n\t\tbreak;\n\tcase WMI_10_2_VDEV_RESUME_REQ_EVENTID:\n\t\tath10k_wmi_event_vdev_resume_req(ar, skb);\n\t\tath10k_wmi_queue_set_coverage_class_work(ar);\n\t\tbreak;\n\tcase WMI_10_2_SERVICE_READY_EVENTID:\n\t\tath10k_wmi_event_service_ready(ar, skb);\n\t\treturn;\n\tcase WMI_10_2_READY_EVENTID:\n\t\tath10k_wmi_event_ready(ar, skb);\n\t\tath10k_wmi_queue_set_coverage_class_work(ar);\n\t\tbreak;\n\tcase WMI_10_2_PDEV_TEMPERATURE_EVENTID:\n\t\tath10k_wmi_event_temperature(ar, skb);\n\t\tbreak;\n\tcase WMI_10_2_PDEV_BSS_CHAN_INFO_EVENTID:\n\t\tath10k_wmi_event_pdev_bss_chan_info(ar, skb);\n\t\tbreak;\n\tcase WMI_10_2_RTT_KEEPALIVE_EVENTID:\n\tcase WMI_10_2_GPIO_INPUT_EVENTID:\n\tcase WMI_10_2_PEER_RATECODE_LIST_EVENTID:\n\tcase WMI_10_2_GENERIC_BUFFER_EVENTID:\n\tcase WMI_10_2_MCAST_BUF_RELEASE_EVENTID:\n\tcase WMI_10_2_MCAST_LIST_AGEOUT_EVENTID:\n\tcase WMI_10_2_WDS_PEER_EVENTID:\n\t\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t\t   \"received event id %d not implemented\\n\", id);\n\t\tbreak;\n\tcase WMI_10_2_PEER_STA_PS_STATECHG_EVENTID:\n\t\tath10k_wmi_event_peer_sta_ps_state_chg(ar, skb);\n\t\tbreak;\n\tdefault:\n\t\tath10k_warn(ar, \"Unknown eventid: %d\\n\", id);\n\t\tbreak;\n\t}\n\nout:\n\tdev_kfree_skb(skb);\n}\n\nstatic void ath10k_wmi_10_4_op_rx(struct ath10k *ar, struct sk_buff *skb)\n{\n\tstruct wmi_cmd_hdr *cmd_hdr;\n\tenum wmi_10_4_event_id id;\n\tbool consumed;\n\n\tcmd_hdr = (struct wmi_cmd_hdr *)skb->data;\n\tid = MS(__le32_to_cpu(cmd_hdr->cmd_id), WMI_CMD_HDR_CMD_ID);\n\n\tif (!skb_pull(skb, sizeof(struct wmi_cmd_hdr)))\n\t\tgoto out;\n\n\ttrace_ath10k_wmi_event(ar, id, skb->data, skb->len);\n\n\tconsumed = ath10k_tm_event_wmi(ar, id, skb);\n\n\t \n\tif (consumed && id != WMI_10_4_READY_EVENTID) {\n\t\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t\t   \"wmi testmode consumed 0x%x\\n\", id);\n\t\tgoto out;\n\t}\n\n\tswitch (id) {\n\tcase WMI_10_4_MGMT_RX_EVENTID:\n\t\tath10k_wmi_event_mgmt_rx(ar, skb);\n\t\t \n\t\treturn;\n\tcase WMI_10_4_ECHO_EVENTID:\n\t\tath10k_wmi_event_echo(ar, skb);\n\t\tbreak;\n\tcase WMI_10_4_DEBUG_MESG_EVENTID:\n\t\tath10k_wmi_event_debug_mesg(ar, skb);\n\t\tath10k_wmi_queue_set_coverage_class_work(ar);\n\t\tbreak;\n\tcase WMI_10_4_SERVICE_READY_EVENTID:\n\t\tath10k_wmi_event_service_ready(ar, skb);\n\t\treturn;\n\tcase WMI_10_4_SCAN_EVENTID:\n\t\tath10k_wmi_event_scan(ar, skb);\n\t\tath10k_wmi_queue_set_coverage_class_work(ar);\n\t\tbreak;\n\tcase WMI_10_4_CHAN_INFO_EVENTID:\n\t\tath10k_wmi_event_chan_info(ar, skb);\n\t\tbreak;\n\tcase WMI_10_4_PHYERR_EVENTID:\n\t\tath10k_wmi_event_phyerr(ar, skb);\n\t\tbreak;\n\tcase WMI_10_4_READY_EVENTID:\n\t\tath10k_wmi_event_ready(ar, skb);\n\t\tath10k_wmi_queue_set_coverage_class_work(ar);\n\t\tbreak;\n\tcase WMI_10_4_PEER_STA_KICKOUT_EVENTID:\n\t\tath10k_wmi_event_peer_sta_kickout(ar, skb);\n\t\tbreak;\n\tcase WMI_10_4_ROAM_EVENTID:\n\t\tath10k_wmi_event_roam(ar, skb);\n\t\tath10k_wmi_queue_set_coverage_class_work(ar);\n\t\tbreak;\n\tcase WMI_10_4_HOST_SWBA_EVENTID:\n\t\tath10k_wmi_event_host_swba(ar, skb);\n\t\tbreak;\n\tcase WMI_10_4_TBTTOFFSET_UPDATE_EVENTID:\n\t\tath10k_wmi_event_tbttoffset_update(ar, skb);\n\t\tbreak;\n\tcase WMI_10_4_DEBUG_PRINT_EVENTID:\n\t\tath10k_wmi_event_debug_print(ar, skb);\n\t\tath10k_wmi_queue_set_coverage_class_work(ar);\n\t\tbreak;\n\tcase WMI_10_4_VDEV_START_RESP_EVENTID:\n\t\tath10k_wmi_event_vdev_start_resp(ar, skb);\n\t\tath10k_wmi_queue_set_coverage_class_work(ar);\n\t\tbreak;\n\tcase WMI_10_4_VDEV_STOPPED_EVENTID:\n\t\tath10k_wmi_event_vdev_stopped(ar, skb);\n\t\tath10k_wmi_queue_set_coverage_class_work(ar);\n\t\tbreak;\n\tcase WMI_10_4_WOW_WAKEUP_HOST_EVENTID:\n\tcase WMI_10_4_PEER_RATECODE_LIST_EVENTID:\n\tcase WMI_10_4_WDS_PEER_EVENTID:\n\tcase WMI_10_4_DEBUG_FATAL_CONDITION_EVENTID:\n\t\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t\t   \"received event id %d not implemented\\n\", id);\n\t\tbreak;\n\tcase WMI_10_4_UPDATE_STATS_EVENTID:\n\t\tath10k_wmi_event_update_stats(ar, skb);\n\t\tbreak;\n\tcase WMI_10_4_PDEV_TEMPERATURE_EVENTID:\n\t\tath10k_wmi_event_temperature(ar, skb);\n\t\tbreak;\n\tcase WMI_10_4_PDEV_BSS_CHAN_INFO_EVENTID:\n\t\tath10k_wmi_event_pdev_bss_chan_info(ar, skb);\n\t\tbreak;\n\tcase WMI_10_4_PDEV_TPC_CONFIG_EVENTID:\n\t\tath10k_wmi_event_pdev_tpc_config(ar, skb);\n\t\tbreak;\n\tcase WMI_10_4_TDLS_PEER_EVENTID:\n\t\tath10k_wmi_handle_tdls_peer_event(ar, skb);\n\t\tbreak;\n\tcase WMI_10_4_PDEV_TPC_TABLE_EVENTID:\n\t\tath10k_wmi_event_tpc_final_table(ar, skb);\n\t\tbreak;\n\tcase WMI_10_4_DFS_STATUS_CHECK_EVENTID:\n\t\tath10k_wmi_event_dfs_status_check(ar, skb);\n\t\tbreak;\n\tcase WMI_10_4_PEER_STA_PS_STATECHG_EVENTID:\n\t\tath10k_wmi_event_peer_sta_ps_state_chg(ar, skb);\n\t\tbreak;\n\tdefault:\n\t\tath10k_warn(ar, \"Unknown eventid: %d\\n\", id);\n\t\tbreak;\n\t}\n\nout:\n\tdev_kfree_skb(skb);\n}\n\nstatic void ath10k_wmi_process_rx(struct ath10k *ar, struct sk_buff *skb)\n{\n\tint ret;\n\n\tret = ath10k_wmi_rx(ar, skb);\n\tif (ret)\n\t\tath10k_warn(ar, \"failed to process wmi rx: %d\\n\", ret);\n}\n\nint ath10k_wmi_connect(struct ath10k *ar)\n{\n\tint status;\n\tstruct ath10k_htc_svc_conn_req conn_req;\n\tstruct ath10k_htc_svc_conn_resp conn_resp;\n\n\tmemset(&ar->wmi.svc_map, 0, sizeof(ar->wmi.svc_map));\n\n\tmemset(&conn_req, 0, sizeof(conn_req));\n\tmemset(&conn_resp, 0, sizeof(conn_resp));\n\n\t \n\tconn_req.ep_ops.ep_tx_complete = ath10k_wmi_htc_tx_complete;\n\tconn_req.ep_ops.ep_rx_complete = ath10k_wmi_process_rx;\n\tconn_req.ep_ops.ep_tx_credits = ath10k_wmi_op_ep_tx_credits;\n\n\t \n\tconn_req.service_id = ATH10K_HTC_SVC_ID_WMI_CONTROL;\n\n\tstatus = ath10k_htc_connect_service(&ar->htc, &conn_req, &conn_resp);\n\tif (status) {\n\t\tath10k_warn(ar, \"failed to connect to WMI CONTROL service status: %d\\n\",\n\t\t\t    status);\n\t\treturn status;\n\t}\n\n\tar->wmi.eid = conn_resp.eid;\n\treturn 0;\n}\n\nstatic struct sk_buff *\nath10k_wmi_op_gen_pdev_set_base_macaddr(struct ath10k *ar,\n\t\t\t\t\tconst u8 macaddr[ETH_ALEN])\n{\n\tstruct wmi_pdev_set_base_macaddr_cmd *cmd;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_pdev_set_base_macaddr_cmd *)skb->data;\n\tether_addr_copy(cmd->mac_addr.addr, macaddr);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi pdev basemac %pM\\n\", macaddr);\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_op_gen_pdev_set_rd(struct ath10k *ar, u16 rd, u16 rd2g, u16 rd5g,\n\t\t\t      u16 ctl2g, u16 ctl5g,\n\t\t\t      enum wmi_dfs_region dfs_reg)\n{\n\tstruct wmi_pdev_set_regdomain_cmd *cmd;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_pdev_set_regdomain_cmd *)skb->data;\n\tcmd->reg_domain = __cpu_to_le32(rd);\n\tcmd->reg_domain_2G = __cpu_to_le32(rd2g);\n\tcmd->reg_domain_5G = __cpu_to_le32(rd5g);\n\tcmd->conformance_test_limit_2G = __cpu_to_le32(ctl2g);\n\tcmd->conformance_test_limit_5G = __cpu_to_le32(ctl5g);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi pdev regdomain rd %x rd2g %x rd5g %x ctl2g %x ctl5g %x\\n\",\n\t\t   rd, rd2g, rd5g, ctl2g, ctl5g);\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_10x_op_gen_pdev_set_rd(struct ath10k *ar, u16 rd, u16 rd2g, u16\n\t\t\t\t  rd5g, u16 ctl2g, u16 ctl5g,\n\t\t\t\t  enum wmi_dfs_region dfs_reg)\n{\n\tstruct wmi_pdev_set_regdomain_cmd_10x *cmd;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_pdev_set_regdomain_cmd_10x *)skb->data;\n\tcmd->reg_domain = __cpu_to_le32(rd);\n\tcmd->reg_domain_2G = __cpu_to_le32(rd2g);\n\tcmd->reg_domain_5G = __cpu_to_le32(rd5g);\n\tcmd->conformance_test_limit_2G = __cpu_to_le32(ctl2g);\n\tcmd->conformance_test_limit_5G = __cpu_to_le32(ctl5g);\n\tcmd->dfs_domain = __cpu_to_le32(dfs_reg);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi pdev regdomain rd %x rd2g %x rd5g %x ctl2g %x ctl5g %x dfs_region %x\\n\",\n\t\t   rd, rd2g, rd5g, ctl2g, ctl5g, dfs_reg);\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_op_gen_pdev_suspend(struct ath10k *ar, u32 suspend_opt)\n{\n\tstruct wmi_pdev_suspend_cmd *cmd;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_pdev_suspend_cmd *)skb->data;\n\tcmd->suspend_opt = __cpu_to_le32(suspend_opt);\n\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_op_gen_pdev_resume(struct ath10k *ar)\n{\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, 0);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_op_gen_pdev_set_param(struct ath10k *ar, u32 id, u32 value)\n{\n\tstruct wmi_pdev_set_param_cmd *cmd;\n\tstruct sk_buff *skb;\n\n\tif (id == WMI_PDEV_PARAM_UNSUPPORTED) {\n\t\tath10k_warn(ar, \"pdev param %d not supported by firmware\\n\",\n\t\t\t    id);\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t}\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_pdev_set_param_cmd *)skb->data;\n\tcmd->param_id    = __cpu_to_le32(id);\n\tcmd->param_value = __cpu_to_le32(value);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi pdev set param %d value %d\\n\",\n\t\t   id, value);\n\treturn skb;\n}\n\nvoid ath10k_wmi_put_host_mem_chunks(struct ath10k *ar,\n\t\t\t\t    struct wmi_host_mem_chunks *chunks)\n{\n\tstruct host_memory_chunk *chunk;\n\tint i;\n\n\tchunks->count = __cpu_to_le32(ar->wmi.num_mem_chunks);\n\n\tfor (i = 0; i < ar->wmi.num_mem_chunks; i++) {\n\t\tchunk = &chunks->items[i];\n\t\tchunk->ptr = __cpu_to_le32(ar->wmi.mem_chunks[i].paddr);\n\t\tchunk->size = __cpu_to_le32(ar->wmi.mem_chunks[i].len);\n\t\tchunk->req_id = __cpu_to_le32(ar->wmi.mem_chunks[i].req_id);\n\n\t\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t\t   \"wmi chunk %d len %d requested, addr 0x%llx\\n\",\n\t\t\t   i,\n\t\t\t   ar->wmi.mem_chunks[i].len,\n\t\t\t   (unsigned long long)ar->wmi.mem_chunks[i].paddr);\n\t}\n}\n\nstatic struct sk_buff *ath10k_wmi_op_gen_init(struct ath10k *ar)\n{\n\tstruct wmi_init_cmd *cmd;\n\tstruct sk_buff *buf;\n\tstruct wmi_resource_config config = {};\n\tu32 val;\n\n\tconfig.num_vdevs = __cpu_to_le32(TARGET_NUM_VDEVS);\n\tconfig.num_peers = __cpu_to_le32(TARGET_NUM_PEERS);\n\tconfig.num_offload_peers = __cpu_to_le32(TARGET_NUM_OFFLOAD_PEERS);\n\n\tconfig.num_offload_reorder_bufs =\n\t\t__cpu_to_le32(TARGET_NUM_OFFLOAD_REORDER_BUFS);\n\n\tconfig.num_peer_keys = __cpu_to_le32(TARGET_NUM_PEER_KEYS);\n\tconfig.num_tids = __cpu_to_le32(TARGET_NUM_TIDS);\n\tconfig.ast_skid_limit = __cpu_to_le32(TARGET_AST_SKID_LIMIT);\n\tconfig.tx_chain_mask = __cpu_to_le32(TARGET_TX_CHAIN_MASK);\n\tconfig.rx_chain_mask = __cpu_to_le32(TARGET_RX_CHAIN_MASK);\n\tconfig.rx_timeout_pri_vo = __cpu_to_le32(TARGET_RX_TIMEOUT_LO_PRI);\n\tconfig.rx_timeout_pri_vi = __cpu_to_le32(TARGET_RX_TIMEOUT_LO_PRI);\n\tconfig.rx_timeout_pri_be = __cpu_to_le32(TARGET_RX_TIMEOUT_LO_PRI);\n\tconfig.rx_timeout_pri_bk = __cpu_to_le32(TARGET_RX_TIMEOUT_HI_PRI);\n\tconfig.rx_decap_mode = __cpu_to_le32(ar->wmi.rx_decap_mode);\n\tconfig.scan_max_pending_reqs =\n\t\t__cpu_to_le32(TARGET_SCAN_MAX_PENDING_REQS);\n\n\tconfig.bmiss_offload_max_vdev =\n\t\t__cpu_to_le32(TARGET_BMISS_OFFLOAD_MAX_VDEV);\n\n\tconfig.roam_offload_max_vdev =\n\t\t__cpu_to_le32(TARGET_ROAM_OFFLOAD_MAX_VDEV);\n\n\tconfig.roam_offload_max_ap_profiles =\n\t\t__cpu_to_le32(TARGET_ROAM_OFFLOAD_MAX_AP_PROFILES);\n\n\tconfig.num_mcast_groups = __cpu_to_le32(TARGET_NUM_MCAST_GROUPS);\n\tconfig.num_mcast_table_elems =\n\t\t__cpu_to_le32(TARGET_NUM_MCAST_TABLE_ELEMS);\n\n\tconfig.mcast2ucast_mode = __cpu_to_le32(TARGET_MCAST2UCAST_MODE);\n\tconfig.tx_dbg_log_size = __cpu_to_le32(TARGET_TX_DBG_LOG_SIZE);\n\tconfig.num_wds_entries = __cpu_to_le32(TARGET_NUM_WDS_ENTRIES);\n\tconfig.dma_burst_size = __cpu_to_le32(TARGET_DMA_BURST_SIZE);\n\tconfig.mac_aggr_delim = __cpu_to_le32(TARGET_MAC_AGGR_DELIM);\n\n\tval = TARGET_RX_SKIP_DEFRAG_TIMEOUT_DUP_DETECTION_CHECK;\n\tconfig.rx_skip_defrag_timeout_dup_detection_check = __cpu_to_le32(val);\n\n\tconfig.vow_config = __cpu_to_le32(TARGET_VOW_CONFIG);\n\n\tconfig.gtk_offload_max_vdev =\n\t\t__cpu_to_le32(TARGET_GTK_OFFLOAD_MAX_VDEV);\n\n\tconfig.num_msdu_desc = __cpu_to_le32(TARGET_NUM_MSDU_DESC);\n\tconfig.max_frag_entries = __cpu_to_le32(TARGET_MAX_FRAG_ENTRIES);\n\n\tbuf = ath10k_wmi_alloc_skb(ar, struct_size(cmd, mem_chunks.items,\n\t\t\t\t\t\t   ar->wmi.num_mem_chunks));\n\tif (!buf)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_init_cmd *)buf->data;\n\n\tmemcpy(&cmd->resource_config, &config, sizeof(config));\n\tath10k_wmi_put_host_mem_chunks(ar, &cmd->mem_chunks);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi init\\n\");\n\treturn buf;\n}\n\nstatic struct sk_buff *ath10k_wmi_10_1_op_gen_init(struct ath10k *ar)\n{\n\tstruct wmi_init_cmd_10x *cmd;\n\tstruct sk_buff *buf;\n\tstruct wmi_resource_config_10x config = {};\n\tu32 val;\n\n\tconfig.num_vdevs = __cpu_to_le32(TARGET_10X_NUM_VDEVS);\n\tconfig.num_peers = __cpu_to_le32(TARGET_10X_NUM_PEERS);\n\tconfig.num_peer_keys = __cpu_to_le32(TARGET_10X_NUM_PEER_KEYS);\n\tconfig.num_tids = __cpu_to_le32(TARGET_10X_NUM_TIDS);\n\tconfig.ast_skid_limit = __cpu_to_le32(TARGET_10X_AST_SKID_LIMIT);\n\tconfig.tx_chain_mask = __cpu_to_le32(TARGET_10X_TX_CHAIN_MASK);\n\tconfig.rx_chain_mask = __cpu_to_le32(TARGET_10X_RX_CHAIN_MASK);\n\tconfig.rx_timeout_pri_vo = __cpu_to_le32(TARGET_10X_RX_TIMEOUT_LO_PRI);\n\tconfig.rx_timeout_pri_vi = __cpu_to_le32(TARGET_10X_RX_TIMEOUT_LO_PRI);\n\tconfig.rx_timeout_pri_be = __cpu_to_le32(TARGET_10X_RX_TIMEOUT_LO_PRI);\n\tconfig.rx_timeout_pri_bk = __cpu_to_le32(TARGET_10X_RX_TIMEOUT_HI_PRI);\n\tconfig.rx_decap_mode = __cpu_to_le32(ar->wmi.rx_decap_mode);\n\tconfig.scan_max_pending_reqs =\n\t\t__cpu_to_le32(TARGET_10X_SCAN_MAX_PENDING_REQS);\n\n\tconfig.bmiss_offload_max_vdev =\n\t\t__cpu_to_le32(TARGET_10X_BMISS_OFFLOAD_MAX_VDEV);\n\n\tconfig.roam_offload_max_vdev =\n\t\t__cpu_to_le32(TARGET_10X_ROAM_OFFLOAD_MAX_VDEV);\n\n\tconfig.roam_offload_max_ap_profiles =\n\t\t__cpu_to_le32(TARGET_10X_ROAM_OFFLOAD_MAX_AP_PROFILES);\n\n\tconfig.num_mcast_groups = __cpu_to_le32(TARGET_10X_NUM_MCAST_GROUPS);\n\tconfig.num_mcast_table_elems =\n\t\t__cpu_to_le32(TARGET_10X_NUM_MCAST_TABLE_ELEMS);\n\n\tconfig.mcast2ucast_mode = __cpu_to_le32(TARGET_10X_MCAST2UCAST_MODE);\n\tconfig.tx_dbg_log_size = __cpu_to_le32(TARGET_10X_TX_DBG_LOG_SIZE);\n\tconfig.num_wds_entries = __cpu_to_le32(TARGET_10X_NUM_WDS_ENTRIES);\n\tconfig.dma_burst_size = __cpu_to_le32(TARGET_10X_DMA_BURST_SIZE);\n\tconfig.mac_aggr_delim = __cpu_to_le32(TARGET_10X_MAC_AGGR_DELIM);\n\n\tval = TARGET_10X_RX_SKIP_DEFRAG_TIMEOUT_DUP_DETECTION_CHECK;\n\tconfig.rx_skip_defrag_timeout_dup_detection_check = __cpu_to_le32(val);\n\n\tconfig.vow_config = __cpu_to_le32(TARGET_10X_VOW_CONFIG);\n\n\tconfig.num_msdu_desc = __cpu_to_le32(TARGET_10X_NUM_MSDU_DESC);\n\tconfig.max_frag_entries = __cpu_to_le32(TARGET_10X_MAX_FRAG_ENTRIES);\n\n\tbuf = ath10k_wmi_alloc_skb(ar, struct_size(cmd, mem_chunks.items,\n\t\t\t\t\t\t   ar->wmi.num_mem_chunks));\n\tif (!buf)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_init_cmd_10x *)buf->data;\n\n\tmemcpy(&cmd->resource_config, &config, sizeof(config));\n\tath10k_wmi_put_host_mem_chunks(ar, &cmd->mem_chunks);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi init 10x\\n\");\n\treturn buf;\n}\n\nstatic struct sk_buff *ath10k_wmi_10_2_op_gen_init(struct ath10k *ar)\n{\n\tstruct wmi_init_cmd_10_2 *cmd;\n\tstruct sk_buff *buf;\n\tstruct wmi_resource_config_10x config = {};\n\tu32 val, features;\n\n\tconfig.num_vdevs = __cpu_to_le32(TARGET_10X_NUM_VDEVS);\n\tconfig.num_peer_keys = __cpu_to_le32(TARGET_10X_NUM_PEER_KEYS);\n\n\tif (ath10k_peer_stats_enabled(ar)) {\n\t\tconfig.num_peers = __cpu_to_le32(TARGET_10X_TX_STATS_NUM_PEERS);\n\t\tconfig.num_tids = __cpu_to_le32(TARGET_10X_TX_STATS_NUM_TIDS);\n\t} else {\n\t\tconfig.num_peers = __cpu_to_le32(TARGET_10X_NUM_PEERS);\n\t\tconfig.num_tids = __cpu_to_le32(TARGET_10X_NUM_TIDS);\n\t}\n\n\tconfig.ast_skid_limit = __cpu_to_le32(TARGET_10X_AST_SKID_LIMIT);\n\tconfig.tx_chain_mask = __cpu_to_le32(TARGET_10X_TX_CHAIN_MASK);\n\tconfig.rx_chain_mask = __cpu_to_le32(TARGET_10X_RX_CHAIN_MASK);\n\tconfig.rx_timeout_pri_vo = __cpu_to_le32(TARGET_10X_RX_TIMEOUT_LO_PRI);\n\tconfig.rx_timeout_pri_vi = __cpu_to_le32(TARGET_10X_RX_TIMEOUT_LO_PRI);\n\tconfig.rx_timeout_pri_be = __cpu_to_le32(TARGET_10X_RX_TIMEOUT_LO_PRI);\n\tconfig.rx_timeout_pri_bk = __cpu_to_le32(TARGET_10X_RX_TIMEOUT_HI_PRI);\n\tconfig.rx_decap_mode = __cpu_to_le32(ar->wmi.rx_decap_mode);\n\n\tconfig.scan_max_pending_reqs =\n\t\t__cpu_to_le32(TARGET_10X_SCAN_MAX_PENDING_REQS);\n\n\tconfig.bmiss_offload_max_vdev =\n\t\t__cpu_to_le32(TARGET_10X_BMISS_OFFLOAD_MAX_VDEV);\n\n\tconfig.roam_offload_max_vdev =\n\t\t__cpu_to_le32(TARGET_10X_ROAM_OFFLOAD_MAX_VDEV);\n\n\tconfig.roam_offload_max_ap_profiles =\n\t\t__cpu_to_le32(TARGET_10X_ROAM_OFFLOAD_MAX_AP_PROFILES);\n\n\tconfig.num_mcast_groups = __cpu_to_le32(TARGET_10X_NUM_MCAST_GROUPS);\n\tconfig.num_mcast_table_elems =\n\t\t__cpu_to_le32(TARGET_10X_NUM_MCAST_TABLE_ELEMS);\n\n\tconfig.mcast2ucast_mode = __cpu_to_le32(TARGET_10X_MCAST2UCAST_MODE);\n\tconfig.tx_dbg_log_size = __cpu_to_le32(TARGET_10X_TX_DBG_LOG_SIZE);\n\tconfig.num_wds_entries = __cpu_to_le32(TARGET_10X_NUM_WDS_ENTRIES);\n\tconfig.dma_burst_size = __cpu_to_le32(TARGET_10_2_DMA_BURST_SIZE);\n\tconfig.mac_aggr_delim = __cpu_to_le32(TARGET_10X_MAC_AGGR_DELIM);\n\n\tval = TARGET_10X_RX_SKIP_DEFRAG_TIMEOUT_DUP_DETECTION_CHECK;\n\tconfig.rx_skip_defrag_timeout_dup_detection_check = __cpu_to_le32(val);\n\n\tconfig.vow_config = __cpu_to_le32(TARGET_10X_VOW_CONFIG);\n\n\tconfig.num_msdu_desc = __cpu_to_le32(TARGET_10X_NUM_MSDU_DESC);\n\tconfig.max_frag_entries = __cpu_to_le32(TARGET_10X_MAX_FRAG_ENTRIES);\n\n\tbuf = ath10k_wmi_alloc_skb(ar, struct_size(cmd, mem_chunks.items,\n\t\t\t\t\t\t   ar->wmi.num_mem_chunks));\n\tif (!buf)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_init_cmd_10_2 *)buf->data;\n\n\tfeatures = WMI_10_2_RX_BATCH_MODE;\n\n\tif (test_bit(ATH10K_FLAG_BTCOEX, &ar->dev_flags) &&\n\t    test_bit(WMI_SERVICE_COEX_GPIO, ar->wmi.svc_map))\n\t\tfeatures |= WMI_10_2_COEX_GPIO;\n\n\tif (ath10k_peer_stats_enabled(ar))\n\t\tfeatures |= WMI_10_2_PEER_STATS;\n\n\tif (test_bit(WMI_SERVICE_BSS_CHANNEL_INFO_64, ar->wmi.svc_map))\n\t\tfeatures |= WMI_10_2_BSS_CHAN_INFO;\n\n\tcmd->resource_config.feature_mask = __cpu_to_le32(features);\n\n\tmemcpy(&cmd->resource_config.common, &config, sizeof(config));\n\tath10k_wmi_put_host_mem_chunks(ar, &cmd->mem_chunks);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi init 10.2\\n\");\n\treturn buf;\n}\n\nstatic struct sk_buff *ath10k_wmi_10_4_op_gen_init(struct ath10k *ar)\n{\n\tstruct wmi_init_cmd_10_4 *cmd;\n\tstruct sk_buff *buf;\n\tstruct wmi_resource_config_10_4 config = {};\n\n\tconfig.num_vdevs = __cpu_to_le32(ar->max_num_vdevs);\n\tconfig.num_peers = __cpu_to_le32(ar->max_num_peers);\n\tconfig.num_active_peers = __cpu_to_le32(ar->num_active_peers);\n\tconfig.num_tids = __cpu_to_le32(ar->num_tids);\n\n\tconfig.num_offload_peers = __cpu_to_le32(TARGET_10_4_NUM_OFFLOAD_PEERS);\n\tconfig.num_offload_reorder_buffs =\n\t\t\t__cpu_to_le32(TARGET_10_4_NUM_OFFLOAD_REORDER_BUFFS);\n\tconfig.num_peer_keys  = __cpu_to_le32(TARGET_10_4_NUM_PEER_KEYS);\n\tconfig.ast_skid_limit = __cpu_to_le32(TARGET_10_4_AST_SKID_LIMIT);\n\tconfig.tx_chain_mask  = __cpu_to_le32(ar->hw_params.tx_chain_mask);\n\tconfig.rx_chain_mask  = __cpu_to_le32(ar->hw_params.rx_chain_mask);\n\n\tconfig.rx_timeout_pri[0] = __cpu_to_le32(TARGET_10_4_RX_TIMEOUT_LO_PRI);\n\tconfig.rx_timeout_pri[1] = __cpu_to_le32(TARGET_10_4_RX_TIMEOUT_LO_PRI);\n\tconfig.rx_timeout_pri[2] = __cpu_to_le32(TARGET_10_4_RX_TIMEOUT_LO_PRI);\n\tconfig.rx_timeout_pri[3] = __cpu_to_le32(TARGET_10_4_RX_TIMEOUT_HI_PRI);\n\n\tconfig.rx_decap_mode\t    = __cpu_to_le32(ar->wmi.rx_decap_mode);\n\tconfig.scan_max_pending_req = __cpu_to_le32(TARGET_10_4_SCAN_MAX_REQS);\n\tconfig.bmiss_offload_max_vdev =\n\t\t\t__cpu_to_le32(TARGET_10_4_BMISS_OFFLOAD_MAX_VDEV);\n\tconfig.roam_offload_max_vdev  =\n\t\t\t__cpu_to_le32(TARGET_10_4_ROAM_OFFLOAD_MAX_VDEV);\n\tconfig.roam_offload_max_ap_profiles =\n\t\t\t__cpu_to_le32(TARGET_10_4_ROAM_OFFLOAD_MAX_PROFILES);\n\tconfig.num_mcast_groups = __cpu_to_le32(TARGET_10_4_NUM_MCAST_GROUPS);\n\tconfig.num_mcast_table_elems =\n\t\t\t__cpu_to_le32(TARGET_10_4_NUM_MCAST_TABLE_ELEMS);\n\n\tconfig.mcast2ucast_mode = __cpu_to_le32(TARGET_10_4_MCAST2UCAST_MODE);\n\tconfig.tx_dbg_log_size  = __cpu_to_le32(TARGET_10_4_TX_DBG_LOG_SIZE);\n\tconfig.num_wds_entries  = __cpu_to_le32(TARGET_10_4_NUM_WDS_ENTRIES);\n\tconfig.dma_burst_size   = __cpu_to_le32(TARGET_10_4_DMA_BURST_SIZE);\n\tconfig.mac_aggr_delim   = __cpu_to_le32(TARGET_10_4_MAC_AGGR_DELIM);\n\n\tconfig.rx_skip_defrag_timeout_dup_detection_check =\n\t  __cpu_to_le32(TARGET_10_4_RX_SKIP_DEFRAG_TIMEOUT_DUP_DETECTION_CHECK);\n\n\tconfig.vow_config = __cpu_to_le32(TARGET_10_4_VOW_CONFIG);\n\tconfig.gtk_offload_max_vdev =\n\t\t\t__cpu_to_le32(TARGET_10_4_GTK_OFFLOAD_MAX_VDEV);\n\tconfig.num_msdu_desc = __cpu_to_le32(ar->htt.max_num_pending_tx);\n\tconfig.max_frag_entries = __cpu_to_le32(TARGET_10_4_11AC_TX_MAX_FRAGS);\n\tconfig.max_peer_ext_stats =\n\t\t\t__cpu_to_le32(TARGET_10_4_MAX_PEER_EXT_STATS);\n\tconfig.smart_ant_cap = __cpu_to_le32(TARGET_10_4_SMART_ANT_CAP);\n\n\tconfig.bk_minfree = __cpu_to_le32(TARGET_10_4_BK_MIN_FREE);\n\tconfig.be_minfree = __cpu_to_le32(TARGET_10_4_BE_MIN_FREE);\n\tconfig.vi_minfree = __cpu_to_le32(TARGET_10_4_VI_MIN_FREE);\n\tconfig.vo_minfree = __cpu_to_le32(TARGET_10_4_VO_MIN_FREE);\n\n\tconfig.rx_batchmode = __cpu_to_le32(TARGET_10_4_RX_BATCH_MODE);\n\tconfig.tt_support =\n\t\t\t__cpu_to_le32(TARGET_10_4_THERMAL_THROTTLING_CONFIG);\n\tconfig.atf_config = __cpu_to_le32(TARGET_10_4_ATF_CONFIG);\n\tconfig.iphdr_pad_config = __cpu_to_le32(TARGET_10_4_IPHDR_PAD_CONFIG);\n\tconfig.qwrap_config = __cpu_to_le32(TARGET_10_4_QWRAP_CONFIG);\n\n\tbuf = ath10k_wmi_alloc_skb(ar, struct_size(cmd, mem_chunks.items,\n\t\t\t\t\t\t   ar->wmi.num_mem_chunks));\n\tif (!buf)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_init_cmd_10_4 *)buf->data;\n\tmemcpy(&cmd->resource_config, &config, sizeof(config));\n\tath10k_wmi_put_host_mem_chunks(ar, &cmd->mem_chunks);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi init 10.4\\n\");\n\treturn buf;\n}\n\nint ath10k_wmi_start_scan_verify(const struct wmi_start_scan_arg *arg)\n{\n\tif (arg->ie_len > WLAN_SCAN_PARAMS_MAX_IE_LEN)\n\t\treturn -EINVAL;\n\tif (arg->n_channels > ARRAY_SIZE(arg->channels))\n\t\treturn -EINVAL;\n\tif (arg->n_ssids > WLAN_SCAN_PARAMS_MAX_SSID)\n\t\treturn -EINVAL;\n\tif (arg->n_bssids > WLAN_SCAN_PARAMS_MAX_BSSID)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic size_t\nath10k_wmi_start_scan_tlvs_len(const struct wmi_start_scan_arg *arg)\n{\n\tint len = 0;\n\n\tif (arg->ie_len) {\n\t\tlen += sizeof(struct wmi_ie_data);\n\t\tlen += roundup(arg->ie_len, 4);\n\t}\n\n\tif (arg->n_channels) {\n\t\tlen += sizeof(struct wmi_chan_list);\n\t\tlen += sizeof(__le32) * arg->n_channels;\n\t}\n\n\tif (arg->n_ssids) {\n\t\tlen += sizeof(struct wmi_ssid_list);\n\t\tlen += sizeof(struct wmi_ssid) * arg->n_ssids;\n\t}\n\n\tif (arg->n_bssids) {\n\t\tlen += sizeof(struct wmi_bssid_list);\n\t\tlen += sizeof(struct wmi_mac_addr) * arg->n_bssids;\n\t}\n\n\treturn len;\n}\n\nvoid ath10k_wmi_put_start_scan_common(struct wmi_start_scan_common *cmn,\n\t\t\t\t      const struct wmi_start_scan_arg *arg)\n{\n\tu32 scan_id;\n\tu32 scan_req_id;\n\n\tscan_id  = WMI_HOST_SCAN_REQ_ID_PREFIX;\n\tscan_id |= arg->scan_id;\n\n\tscan_req_id  = WMI_HOST_SCAN_REQUESTOR_ID_PREFIX;\n\tscan_req_id |= arg->scan_req_id;\n\n\tcmn->scan_id            = __cpu_to_le32(scan_id);\n\tcmn->scan_req_id        = __cpu_to_le32(scan_req_id);\n\tcmn->vdev_id            = __cpu_to_le32(arg->vdev_id);\n\tcmn->scan_priority      = __cpu_to_le32(arg->scan_priority);\n\tcmn->notify_scan_events = __cpu_to_le32(arg->notify_scan_events);\n\tcmn->dwell_time_active  = __cpu_to_le32(arg->dwell_time_active);\n\tcmn->dwell_time_passive = __cpu_to_le32(arg->dwell_time_passive);\n\tcmn->min_rest_time      = __cpu_to_le32(arg->min_rest_time);\n\tcmn->max_rest_time      = __cpu_to_le32(arg->max_rest_time);\n\tcmn->repeat_probe_time  = __cpu_to_le32(arg->repeat_probe_time);\n\tcmn->probe_spacing_time = __cpu_to_le32(arg->probe_spacing_time);\n\tcmn->idle_time          = __cpu_to_le32(arg->idle_time);\n\tcmn->max_scan_time      = __cpu_to_le32(arg->max_scan_time);\n\tcmn->probe_delay        = __cpu_to_le32(arg->probe_delay);\n\tcmn->scan_ctrl_flags    = __cpu_to_le32(arg->scan_ctrl_flags);\n}\n\nstatic void\nath10k_wmi_put_start_scan_tlvs(struct wmi_start_scan_tlvs *tlvs,\n\t\t\t       const struct wmi_start_scan_arg *arg)\n{\n\tstruct wmi_ie_data *ie;\n\tstruct wmi_chan_list *channels;\n\tstruct wmi_ssid_list *ssids;\n\tstruct wmi_bssid_list *bssids;\n\tvoid *ptr = tlvs->tlvs;\n\tint i;\n\n\tif (arg->n_channels) {\n\t\tchannels = ptr;\n\t\tchannels->tag = __cpu_to_le32(WMI_CHAN_LIST_TAG);\n\t\tchannels->num_chan = __cpu_to_le32(arg->n_channels);\n\n\t\tfor (i = 0; i < arg->n_channels; i++)\n\t\t\tchannels->channel_list[i].freq =\n\t\t\t\t__cpu_to_le16(arg->channels[i]);\n\n\t\tptr += sizeof(*channels);\n\t\tptr += sizeof(__le32) * arg->n_channels;\n\t}\n\n\tif (arg->n_ssids) {\n\t\tssids = ptr;\n\t\tssids->tag = __cpu_to_le32(WMI_SSID_LIST_TAG);\n\t\tssids->num_ssids = __cpu_to_le32(arg->n_ssids);\n\n\t\tfor (i = 0; i < arg->n_ssids; i++) {\n\t\t\tssids->ssids[i].ssid_len =\n\t\t\t\t__cpu_to_le32(arg->ssids[i].len);\n\t\t\tmemcpy(&ssids->ssids[i].ssid,\n\t\t\t       arg->ssids[i].ssid,\n\t\t\t       arg->ssids[i].len);\n\t\t}\n\n\t\tptr += sizeof(*ssids);\n\t\tptr += sizeof(struct wmi_ssid) * arg->n_ssids;\n\t}\n\n\tif (arg->n_bssids) {\n\t\tbssids = ptr;\n\t\tbssids->tag = __cpu_to_le32(WMI_BSSID_LIST_TAG);\n\t\tbssids->num_bssid = __cpu_to_le32(arg->n_bssids);\n\n\t\tfor (i = 0; i < arg->n_bssids; i++)\n\t\t\tether_addr_copy(bssids->bssid_list[i].addr,\n\t\t\t\t\targ->bssids[i].bssid);\n\n\t\tptr += sizeof(*bssids);\n\t\tptr += sizeof(struct wmi_mac_addr) * arg->n_bssids;\n\t}\n\n\tif (arg->ie_len) {\n\t\tie = ptr;\n\t\tie->tag = __cpu_to_le32(WMI_IE_TAG);\n\t\tie->ie_len = __cpu_to_le32(arg->ie_len);\n\t\tmemcpy(ie->ie_data, arg->ie, arg->ie_len);\n\n\t\tptr += sizeof(*ie);\n\t\tptr += roundup(arg->ie_len, 4);\n\t}\n}\n\nstatic struct sk_buff *\nath10k_wmi_op_gen_start_scan(struct ath10k *ar,\n\t\t\t     const struct wmi_start_scan_arg *arg)\n{\n\tstruct wmi_start_scan_cmd *cmd;\n\tstruct sk_buff *skb;\n\tsize_t len;\n\tint ret;\n\n\tret = ath10k_wmi_start_scan_verify(arg);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tlen = sizeof(*cmd) + ath10k_wmi_start_scan_tlvs_len(arg);\n\tskb = ath10k_wmi_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_start_scan_cmd *)skb->data;\n\n\tath10k_wmi_put_start_scan_common(&cmd->common, arg);\n\tath10k_wmi_put_start_scan_tlvs(&cmd->tlvs, arg);\n\n\tcmd->burst_duration_ms = __cpu_to_le32(0);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi start scan\\n\");\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_10x_op_gen_start_scan(struct ath10k *ar,\n\t\t\t\t const struct wmi_start_scan_arg *arg)\n{\n\tstruct wmi_10x_start_scan_cmd *cmd;\n\tstruct sk_buff *skb;\n\tsize_t len;\n\tint ret;\n\n\tret = ath10k_wmi_start_scan_verify(arg);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tlen = sizeof(*cmd) + ath10k_wmi_start_scan_tlvs_len(arg);\n\tskb = ath10k_wmi_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_10x_start_scan_cmd *)skb->data;\n\n\tath10k_wmi_put_start_scan_common(&cmd->common, arg);\n\tath10k_wmi_put_start_scan_tlvs(&cmd->tlvs, arg);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi 10x start scan\\n\");\n\treturn skb;\n}\n\nvoid ath10k_wmi_start_scan_init(struct ath10k *ar,\n\t\t\t\tstruct wmi_start_scan_arg *arg)\n{\n\t \n\targ->scan_req_id = 1;\n\targ->scan_priority = WMI_SCAN_PRIORITY_LOW;\n\targ->dwell_time_active = 50;\n\targ->dwell_time_passive = 150;\n\targ->min_rest_time = 50;\n\targ->max_rest_time = 500;\n\targ->repeat_probe_time = 0;\n\targ->probe_spacing_time = 0;\n\targ->idle_time = 0;\n\targ->max_scan_time = 20000;\n\targ->probe_delay = 5;\n\targ->notify_scan_events = WMI_SCAN_EVENT_STARTED\n\t\t| WMI_SCAN_EVENT_COMPLETED\n\t\t| WMI_SCAN_EVENT_BSS_CHANNEL\n\t\t| WMI_SCAN_EVENT_FOREIGN_CHANNEL\n\t\t| WMI_SCAN_EVENT_FOREIGN_CHANNEL_EXIT\n\t\t| WMI_SCAN_EVENT_DEQUEUED;\n\targ->scan_ctrl_flags |= WMI_SCAN_CHAN_STAT_EVENT;\n\targ->n_bssids = 1;\n\targ->bssids[0].bssid = \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\";\n}\n\nstatic struct sk_buff *\nath10k_wmi_op_gen_stop_scan(struct ath10k *ar,\n\t\t\t    const struct wmi_stop_scan_arg *arg)\n{\n\tstruct wmi_stop_scan_cmd *cmd;\n\tstruct sk_buff *skb;\n\tu32 scan_id;\n\tu32 req_id;\n\n\tif (arg->req_id > 0xFFF)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (arg->req_type == WMI_SCAN_STOP_ONE && arg->u.scan_id > 0xFFF)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tscan_id = arg->u.scan_id;\n\tscan_id |= WMI_HOST_SCAN_REQ_ID_PREFIX;\n\n\treq_id = arg->req_id;\n\treq_id |= WMI_HOST_SCAN_REQUESTOR_ID_PREFIX;\n\n\tcmd = (struct wmi_stop_scan_cmd *)skb->data;\n\tcmd->req_type    = __cpu_to_le32(arg->req_type);\n\tcmd->vdev_id     = __cpu_to_le32(arg->u.vdev_id);\n\tcmd->scan_id     = __cpu_to_le32(scan_id);\n\tcmd->scan_req_id = __cpu_to_le32(req_id);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi stop scan reqid %d req_type %d vdev/scan_id %d\\n\",\n\t\t   arg->req_id, arg->req_type, arg->u.scan_id);\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_op_gen_vdev_create(struct ath10k *ar, u32 vdev_id,\n\t\t\t      enum wmi_vdev_type type,\n\t\t\t      enum wmi_vdev_subtype subtype,\n\t\t\t      const u8 macaddr[ETH_ALEN])\n{\n\tstruct wmi_vdev_create_cmd *cmd;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_vdev_create_cmd *)skb->data;\n\tcmd->vdev_id      = __cpu_to_le32(vdev_id);\n\tcmd->vdev_type    = __cpu_to_le32(type);\n\tcmd->vdev_subtype = __cpu_to_le32(subtype);\n\tether_addr_copy(cmd->vdev_macaddr.addr, macaddr);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"WMI vdev create: id %d type %d subtype %d macaddr %pM\\n\",\n\t\t   vdev_id, type, subtype, macaddr);\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_op_gen_vdev_delete(struct ath10k *ar, u32 vdev_id)\n{\n\tstruct wmi_vdev_delete_cmd *cmd;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_vdev_delete_cmd *)skb->data;\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"WMI vdev delete id %d\\n\", vdev_id);\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_op_gen_vdev_start(struct ath10k *ar,\n\t\t\t     const struct wmi_vdev_start_request_arg *arg,\n\t\t\t     bool restart)\n{\n\tstruct wmi_vdev_start_request_cmd *cmd;\n\tstruct sk_buff *skb;\n\tconst char *cmdname;\n\tu32 flags = 0;\n\n\tif (WARN_ON(arg->hidden_ssid && !arg->ssid))\n\t\treturn ERR_PTR(-EINVAL);\n\tif (WARN_ON(arg->ssid_len > sizeof(cmd->ssid.ssid)))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (restart)\n\t\tcmdname = \"restart\";\n\telse\n\t\tcmdname = \"start\";\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (arg->hidden_ssid)\n\t\tflags |= WMI_VDEV_START_HIDDEN_SSID;\n\tif (arg->pmf_enabled)\n\t\tflags |= WMI_VDEV_START_PMF_ENABLED;\n\n\tcmd = (struct wmi_vdev_start_request_cmd *)skb->data;\n\tcmd->vdev_id         = __cpu_to_le32(arg->vdev_id);\n\tcmd->disable_hw_ack  = __cpu_to_le32(arg->disable_hw_ack);\n\tcmd->beacon_interval = __cpu_to_le32(arg->bcn_intval);\n\tcmd->dtim_period     = __cpu_to_le32(arg->dtim_period);\n\tcmd->flags           = __cpu_to_le32(flags);\n\tcmd->bcn_tx_rate     = __cpu_to_le32(arg->bcn_tx_rate);\n\tcmd->bcn_tx_power    = __cpu_to_le32(arg->bcn_tx_power);\n\n\tif (arg->ssid) {\n\t\tcmd->ssid.ssid_len = __cpu_to_le32(arg->ssid_len);\n\t\tmemcpy(cmd->ssid.ssid, arg->ssid, arg->ssid_len);\n\t}\n\n\tath10k_wmi_put_wmi_channel(ar, &cmd->chan, &arg->channel);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi vdev %s id 0x%x flags: 0x%0X, freq %d, mode %d, ch_flags: 0x%0X, max_power: %d\\n\",\n\t\t   cmdname, arg->vdev_id,\n\t\t   flags, arg->channel.freq, arg->channel.mode,\n\t\t   cmd->chan.flags, arg->channel.max_power);\n\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_op_gen_vdev_stop(struct ath10k *ar, u32 vdev_id)\n{\n\tstruct wmi_vdev_stop_cmd *cmd;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_vdev_stop_cmd *)skb->data;\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi vdev stop id 0x%x\\n\", vdev_id);\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_op_gen_vdev_up(struct ath10k *ar, u32 vdev_id, u32 aid,\n\t\t\t  const u8 *bssid)\n{\n\tstruct wmi_vdev_up_cmd *cmd;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_vdev_up_cmd *)skb->data;\n\tcmd->vdev_id       = __cpu_to_le32(vdev_id);\n\tcmd->vdev_assoc_id = __cpu_to_le32(aid);\n\tether_addr_copy(cmd->vdev_bssid.addr, bssid);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi mgmt vdev up id 0x%x assoc id %d bssid %pM\\n\",\n\t\t   vdev_id, aid, bssid);\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_op_gen_vdev_down(struct ath10k *ar, u32 vdev_id)\n{\n\tstruct wmi_vdev_down_cmd *cmd;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_vdev_down_cmd *)skb->data;\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi mgmt vdev down id 0x%x\\n\", vdev_id);\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_op_gen_vdev_set_param(struct ath10k *ar, u32 vdev_id,\n\t\t\t\t u32 param_id, u32 param_value)\n{\n\tstruct wmi_vdev_set_param_cmd *cmd;\n\tstruct sk_buff *skb;\n\n\tif (param_id == WMI_VDEV_PARAM_UNSUPPORTED) {\n\t\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t\t   \"vdev param %d not supported by firmware\\n\",\n\t\t\t    param_id);\n\t\treturn ERR_PTR(-EOPNOTSUPP);\n\t}\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_vdev_set_param_cmd *)skb->data;\n\tcmd->vdev_id     = __cpu_to_le32(vdev_id);\n\tcmd->param_id    = __cpu_to_le32(param_id);\n\tcmd->param_value = __cpu_to_le32(param_value);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi vdev id 0x%x set param %d value %d\\n\",\n\t\t   vdev_id, param_id, param_value);\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_op_gen_vdev_install_key(struct ath10k *ar,\n\t\t\t\t   const struct wmi_vdev_install_key_arg *arg)\n{\n\tstruct wmi_vdev_install_key_cmd *cmd;\n\tstruct sk_buff *skb;\n\n\tif (arg->key_cipher == WMI_CIPHER_NONE && arg->key_data != NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (arg->key_cipher != WMI_CIPHER_NONE && arg->key_data == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd) + arg->key_len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_vdev_install_key_cmd *)skb->data;\n\tcmd->vdev_id       = __cpu_to_le32(arg->vdev_id);\n\tcmd->key_idx       = __cpu_to_le32(arg->key_idx);\n\tcmd->key_flags     = __cpu_to_le32(arg->key_flags);\n\tcmd->key_cipher    = __cpu_to_le32(arg->key_cipher);\n\tcmd->key_len       = __cpu_to_le32(arg->key_len);\n\tcmd->key_txmic_len = __cpu_to_le32(arg->key_txmic_len);\n\tcmd->key_rxmic_len = __cpu_to_le32(arg->key_rxmic_len);\n\n\tif (arg->macaddr)\n\t\tether_addr_copy(cmd->peer_macaddr.addr, arg->macaddr);\n\tif (arg->key_data)\n\t\tmemcpy(cmd->key_data, arg->key_data, arg->key_len);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi vdev install key idx %d cipher %d len %d\\n\",\n\t\t   arg->key_idx, arg->key_cipher, arg->key_len);\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_op_gen_vdev_spectral_conf(struct ath10k *ar,\n\t\t\t\t     const struct wmi_vdev_spectral_conf_arg *arg)\n{\n\tstruct wmi_vdev_spectral_conf_cmd *cmd;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_vdev_spectral_conf_cmd *)skb->data;\n\tcmd->vdev_id = __cpu_to_le32(arg->vdev_id);\n\tcmd->scan_count = __cpu_to_le32(arg->scan_count);\n\tcmd->scan_period = __cpu_to_le32(arg->scan_period);\n\tcmd->scan_priority = __cpu_to_le32(arg->scan_priority);\n\tcmd->scan_fft_size = __cpu_to_le32(arg->scan_fft_size);\n\tcmd->scan_gc_ena = __cpu_to_le32(arg->scan_gc_ena);\n\tcmd->scan_restart_ena = __cpu_to_le32(arg->scan_restart_ena);\n\tcmd->scan_noise_floor_ref = __cpu_to_le32(arg->scan_noise_floor_ref);\n\tcmd->scan_init_delay = __cpu_to_le32(arg->scan_init_delay);\n\tcmd->scan_nb_tone_thr = __cpu_to_le32(arg->scan_nb_tone_thr);\n\tcmd->scan_str_bin_thr = __cpu_to_le32(arg->scan_str_bin_thr);\n\tcmd->scan_wb_rpt_mode = __cpu_to_le32(arg->scan_wb_rpt_mode);\n\tcmd->scan_rssi_rpt_mode = __cpu_to_le32(arg->scan_rssi_rpt_mode);\n\tcmd->scan_rssi_thr = __cpu_to_le32(arg->scan_rssi_thr);\n\tcmd->scan_pwr_format = __cpu_to_le32(arg->scan_pwr_format);\n\tcmd->scan_rpt_mode = __cpu_to_le32(arg->scan_rpt_mode);\n\tcmd->scan_bin_scale = __cpu_to_le32(arg->scan_bin_scale);\n\tcmd->scan_dbm_adj = __cpu_to_le32(arg->scan_dbm_adj);\n\tcmd->scan_chn_mask = __cpu_to_le32(arg->scan_chn_mask);\n\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_op_gen_vdev_spectral_enable(struct ath10k *ar, u32 vdev_id,\n\t\t\t\t       u32 trigger, u32 enable)\n{\n\tstruct wmi_vdev_spectral_enable_cmd *cmd;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_vdev_spectral_enable_cmd *)skb->data;\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n\tcmd->trigger_cmd = __cpu_to_le32(trigger);\n\tcmd->enable_cmd = __cpu_to_le32(enable);\n\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_op_gen_peer_create(struct ath10k *ar, u32 vdev_id,\n\t\t\t      const u8 peer_addr[ETH_ALEN],\n\t\t\t      enum wmi_peer_type peer_type)\n{\n\tstruct wmi_peer_create_cmd *cmd;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_peer_create_cmd *)skb->data;\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n\tether_addr_copy(cmd->peer_macaddr.addr, peer_addr);\n\tcmd->peer_type = __cpu_to_le32(peer_type);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi peer create vdev_id %d peer_addr %pM\\n\",\n\t\t   vdev_id, peer_addr);\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_op_gen_peer_delete(struct ath10k *ar, u32 vdev_id,\n\t\t\t      const u8 peer_addr[ETH_ALEN])\n{\n\tstruct wmi_peer_delete_cmd *cmd;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_peer_delete_cmd *)skb->data;\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n\tether_addr_copy(cmd->peer_macaddr.addr, peer_addr);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi peer delete vdev_id %d peer_addr %pM\\n\",\n\t\t   vdev_id, peer_addr);\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_op_gen_peer_flush(struct ath10k *ar, u32 vdev_id,\n\t\t\t     const u8 peer_addr[ETH_ALEN], u32 tid_bitmap)\n{\n\tstruct wmi_peer_flush_tids_cmd *cmd;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_peer_flush_tids_cmd *)skb->data;\n\tcmd->vdev_id         = __cpu_to_le32(vdev_id);\n\tcmd->peer_tid_bitmap = __cpu_to_le32(tid_bitmap);\n\tether_addr_copy(cmd->peer_macaddr.addr, peer_addr);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi peer flush vdev_id %d peer_addr %pM tids %08x\\n\",\n\t\t   vdev_id, peer_addr, tid_bitmap);\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_op_gen_peer_set_param(struct ath10k *ar, u32 vdev_id,\n\t\t\t\t const u8 *peer_addr,\n\t\t\t\t enum wmi_peer_param param_id,\n\t\t\t\t u32 param_value)\n{\n\tstruct wmi_peer_set_param_cmd *cmd;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_peer_set_param_cmd *)skb->data;\n\tcmd->vdev_id     = __cpu_to_le32(vdev_id);\n\tcmd->param_id    = __cpu_to_le32(param_id);\n\tcmd->param_value = __cpu_to_le32(param_value);\n\tether_addr_copy(cmd->peer_macaddr.addr, peer_addr);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi vdev %d peer 0x%pM set param %d value %d\\n\",\n\t\t   vdev_id, peer_addr, param_id, param_value);\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_op_gen_set_psmode(struct ath10k *ar, u32 vdev_id,\n\t\t\t     enum wmi_sta_ps_mode psmode)\n{\n\tstruct wmi_sta_powersave_mode_cmd *cmd;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_sta_powersave_mode_cmd *)skb->data;\n\tcmd->vdev_id     = __cpu_to_le32(vdev_id);\n\tcmd->sta_ps_mode = __cpu_to_le32(psmode);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi set powersave id 0x%x mode %d\\n\",\n\t\t   vdev_id, psmode);\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_op_gen_set_sta_ps(struct ath10k *ar, u32 vdev_id,\n\t\t\t     enum wmi_sta_powersave_param param_id,\n\t\t\t     u32 value)\n{\n\tstruct wmi_sta_powersave_param_cmd *cmd;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_sta_powersave_param_cmd *)skb->data;\n\tcmd->vdev_id     = __cpu_to_le32(vdev_id);\n\tcmd->param_id    = __cpu_to_le32(param_id);\n\tcmd->param_value = __cpu_to_le32(value);\n\n\tath10k_dbg(ar, ATH10K_DBG_STA,\n\t\t   \"wmi sta ps param vdev_id 0x%x param %d value %d\\n\",\n\t\t   vdev_id, param_id, value);\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_op_gen_set_ap_ps(struct ath10k *ar, u32 vdev_id, const u8 *mac,\n\t\t\t    enum wmi_ap_ps_peer_param param_id, u32 value)\n{\n\tstruct wmi_ap_ps_peer_cmd *cmd;\n\tstruct sk_buff *skb;\n\n\tif (!mac)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_ap_ps_peer_cmd *)skb->data;\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n\tcmd->param_id = __cpu_to_le32(param_id);\n\tcmd->param_value = __cpu_to_le32(value);\n\tether_addr_copy(cmd->peer_macaddr.addr, mac);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi ap ps param vdev_id 0x%X param %d value %d mac_addr %pM\\n\",\n\t\t   vdev_id, param_id, value, mac);\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_op_gen_scan_chan_list(struct ath10k *ar,\n\t\t\t\t const struct wmi_scan_chan_list_arg *arg)\n{\n\tstruct wmi_scan_chan_list_cmd *cmd;\n\tstruct sk_buff *skb;\n\tstruct wmi_channel_arg *ch;\n\tstruct wmi_channel *ci;\n\tint i;\n\n\tskb = ath10k_wmi_alloc_skb(ar, struct_size(cmd, chan_info, arg->n_channels));\n\tif (!skb)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tcmd = (struct wmi_scan_chan_list_cmd *)skb->data;\n\tcmd->num_scan_chans = __cpu_to_le32(arg->n_channels);\n\n\tfor (i = 0; i < arg->n_channels; i++) {\n\t\tch = &arg->channels[i];\n\t\tci = &cmd->chan_info[i];\n\n\t\tath10k_wmi_put_wmi_channel(ar, ci, ch);\n\t}\n\n\treturn skb;\n}\n\nstatic void\nath10k_wmi_peer_assoc_fill(struct ath10k *ar, void *buf,\n\t\t\t   const struct wmi_peer_assoc_complete_arg *arg)\n{\n\tstruct wmi_common_peer_assoc_complete_cmd *cmd = buf;\n\n\tcmd->vdev_id            = __cpu_to_le32(arg->vdev_id);\n\tcmd->peer_new_assoc     = __cpu_to_le32(arg->peer_reassoc ? 0 : 1);\n\tcmd->peer_associd       = __cpu_to_le32(arg->peer_aid);\n\tcmd->peer_flags         = __cpu_to_le32(arg->peer_flags);\n\tcmd->peer_caps          = __cpu_to_le32(arg->peer_caps);\n\tcmd->peer_listen_intval = __cpu_to_le32(arg->peer_listen_intval);\n\tcmd->peer_ht_caps       = __cpu_to_le32(arg->peer_ht_caps);\n\tcmd->peer_max_mpdu      = __cpu_to_le32(arg->peer_max_mpdu);\n\tcmd->peer_mpdu_density  = __cpu_to_le32(arg->peer_mpdu_density);\n\tcmd->peer_rate_caps     = __cpu_to_le32(arg->peer_rate_caps);\n\tcmd->peer_nss           = __cpu_to_le32(arg->peer_num_spatial_streams);\n\tcmd->peer_vht_caps      = __cpu_to_le32(arg->peer_vht_caps);\n\tcmd->peer_phymode       = __cpu_to_le32(arg->peer_phymode);\n\n\tether_addr_copy(cmd->peer_macaddr.addr, arg->addr);\n\n\tcmd->peer_legacy_rates.num_rates =\n\t\t__cpu_to_le32(arg->peer_legacy_rates.num_rates);\n\tmemcpy(cmd->peer_legacy_rates.rates, arg->peer_legacy_rates.rates,\n\t       arg->peer_legacy_rates.num_rates);\n\n\tcmd->peer_ht_rates.num_rates =\n\t\t__cpu_to_le32(arg->peer_ht_rates.num_rates);\n\tmemcpy(cmd->peer_ht_rates.rates, arg->peer_ht_rates.rates,\n\t       arg->peer_ht_rates.num_rates);\n\n\tcmd->peer_vht_rates.rx_max_rate =\n\t\t__cpu_to_le32(arg->peer_vht_rates.rx_max_rate);\n\tcmd->peer_vht_rates.rx_mcs_set =\n\t\t__cpu_to_le32(arg->peer_vht_rates.rx_mcs_set);\n\tcmd->peer_vht_rates.tx_max_rate =\n\t\t__cpu_to_le32(arg->peer_vht_rates.tx_max_rate);\n\tcmd->peer_vht_rates.tx_mcs_set =\n\t\t__cpu_to_le32(arg->peer_vht_rates.tx_mcs_set);\n}\n\nstatic void\nath10k_wmi_peer_assoc_fill_main(struct ath10k *ar, void *buf,\n\t\t\t\tconst struct wmi_peer_assoc_complete_arg *arg)\n{\n\tstruct wmi_main_peer_assoc_complete_cmd *cmd = buf;\n\n\tath10k_wmi_peer_assoc_fill(ar, buf, arg);\n\tmemset(cmd->peer_ht_info, 0, sizeof(cmd->peer_ht_info));\n}\n\nstatic void\nath10k_wmi_peer_assoc_fill_10_1(struct ath10k *ar, void *buf,\n\t\t\t\tconst struct wmi_peer_assoc_complete_arg *arg)\n{\n\tath10k_wmi_peer_assoc_fill(ar, buf, arg);\n}\n\nstatic void\nath10k_wmi_peer_assoc_fill_10_2(struct ath10k *ar, void *buf,\n\t\t\t\tconst struct wmi_peer_assoc_complete_arg *arg)\n{\n\tstruct wmi_10_2_peer_assoc_complete_cmd *cmd = buf;\n\tint max_mcs, max_nss;\n\tu32 info0;\n\n\t \n\tmax_mcs = 0xf;\n\tmax_nss = 0xf;\n\n\tinfo0 = SM(max_mcs, WMI_PEER_ASSOC_INFO0_MAX_MCS_IDX) |\n\t\tSM(max_nss, WMI_PEER_ASSOC_INFO0_MAX_NSS);\n\n\tath10k_wmi_peer_assoc_fill(ar, buf, arg);\n\tcmd->info0 = __cpu_to_le32(info0);\n}\n\nstatic void\nath10k_wmi_peer_assoc_fill_10_4(struct ath10k *ar, void *buf,\n\t\t\t\tconst struct wmi_peer_assoc_complete_arg *arg)\n{\n\tstruct wmi_10_4_peer_assoc_complete_cmd *cmd = buf;\n\n\tath10k_wmi_peer_assoc_fill_10_2(ar, buf, arg);\n\tcmd->peer_bw_rxnss_override =\n\t\t__cpu_to_le32(arg->peer_bw_rxnss_override);\n}\n\nstatic int\nath10k_wmi_peer_assoc_check_arg(const struct wmi_peer_assoc_complete_arg *arg)\n{\n\tif (arg->peer_mpdu_density > 16)\n\t\treturn -EINVAL;\n\tif (arg->peer_legacy_rates.num_rates > MAX_SUPPORTED_RATES)\n\t\treturn -EINVAL;\n\tif (arg->peer_ht_rates.num_rates > MAX_SUPPORTED_RATES)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic struct sk_buff *\nath10k_wmi_op_gen_peer_assoc(struct ath10k *ar,\n\t\t\t     const struct wmi_peer_assoc_complete_arg *arg)\n{\n\tsize_t len = sizeof(struct wmi_main_peer_assoc_complete_cmd);\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tret = ath10k_wmi_peer_assoc_check_arg(arg);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tskb = ath10k_wmi_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tath10k_wmi_peer_assoc_fill_main(ar, skb->data, arg);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi peer assoc vdev %d addr %pM (%s)\\n\",\n\t\t   arg->vdev_id, arg->addr,\n\t\t   arg->peer_reassoc ? \"reassociate\" : \"new\");\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_10_1_op_gen_peer_assoc(struct ath10k *ar,\n\t\t\t\t  const struct wmi_peer_assoc_complete_arg *arg)\n{\n\tsize_t len = sizeof(struct wmi_10_1_peer_assoc_complete_cmd);\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tret = ath10k_wmi_peer_assoc_check_arg(arg);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tskb = ath10k_wmi_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tath10k_wmi_peer_assoc_fill_10_1(ar, skb->data, arg);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi peer assoc vdev %d addr %pM (%s)\\n\",\n\t\t   arg->vdev_id, arg->addr,\n\t\t   arg->peer_reassoc ? \"reassociate\" : \"new\");\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_10_2_op_gen_peer_assoc(struct ath10k *ar,\n\t\t\t\t  const struct wmi_peer_assoc_complete_arg *arg)\n{\n\tsize_t len = sizeof(struct wmi_10_2_peer_assoc_complete_cmd);\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tret = ath10k_wmi_peer_assoc_check_arg(arg);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tskb = ath10k_wmi_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tath10k_wmi_peer_assoc_fill_10_2(ar, skb->data, arg);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi peer assoc vdev %d addr %pM (%s)\\n\",\n\t\t   arg->vdev_id, arg->addr,\n\t\t   arg->peer_reassoc ? \"reassociate\" : \"new\");\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_10_4_op_gen_peer_assoc(struct ath10k *ar,\n\t\t\t\t  const struct wmi_peer_assoc_complete_arg *arg)\n{\n\tsize_t len = sizeof(struct wmi_10_4_peer_assoc_complete_cmd);\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tret = ath10k_wmi_peer_assoc_check_arg(arg);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tskb = ath10k_wmi_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tath10k_wmi_peer_assoc_fill_10_4(ar, skb->data, arg);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi peer assoc vdev %d addr %pM (%s)\\n\",\n\t\t   arg->vdev_id, arg->addr,\n\t\t   arg->peer_reassoc ? \"reassociate\" : \"new\");\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_10_2_op_gen_pdev_get_temperature(struct ath10k *ar)\n{\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, 0);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi pdev get temperature\\n\");\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_10_2_op_gen_pdev_bss_chan_info(struct ath10k *ar,\n\t\t\t\t\t  enum wmi_bss_survey_req_type type)\n{\n\tstruct wmi_pdev_chan_info_req_cmd *cmd;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_pdev_chan_info_req_cmd *)skb->data;\n\tcmd->type = __cpu_to_le32(type);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi pdev bss info request type %d\\n\", type);\n\n\treturn skb;\n}\n\n \nstatic struct sk_buff *\nath10k_wmi_op_gen_beacon_dma(struct ath10k *ar, u32 vdev_id, const void *bcn,\n\t\t\t     size_t bcn_len, u32 bcn_paddr, bool dtim_zero,\n\t\t\t     bool deliver_cab)\n{\n\tstruct wmi_bcn_tx_ref_cmd *cmd;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_hdr *hdr;\n\tu16 fc;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\thdr = (struct ieee80211_hdr *)bcn;\n\tfc = le16_to_cpu(hdr->frame_control);\n\n\tcmd = (struct wmi_bcn_tx_ref_cmd *)skb->data;\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n\tcmd->data_len = __cpu_to_le32(bcn_len);\n\tcmd->data_ptr = __cpu_to_le32(bcn_paddr);\n\tcmd->msdu_id = 0;\n\tcmd->frame_control = __cpu_to_le32(fc);\n\tcmd->flags = 0;\n\tcmd->antenna_mask = __cpu_to_le32(WMI_BCN_TX_REF_DEF_ANTENNA);\n\n\tif (dtim_zero)\n\t\tcmd->flags |= __cpu_to_le32(WMI_BCN_TX_REF_FLAG_DTIM_ZERO);\n\n\tif (deliver_cab)\n\t\tcmd->flags |= __cpu_to_le32(WMI_BCN_TX_REF_FLAG_DELIVER_CAB);\n\n\treturn skb;\n}\n\nvoid ath10k_wmi_set_wmm_param(struct wmi_wmm_params *params,\n\t\t\t      const struct wmi_wmm_params_arg *arg)\n{\n\tparams->cwmin  = __cpu_to_le32(arg->cwmin);\n\tparams->cwmax  = __cpu_to_le32(arg->cwmax);\n\tparams->aifs   = __cpu_to_le32(arg->aifs);\n\tparams->txop   = __cpu_to_le32(arg->txop);\n\tparams->acm    = __cpu_to_le32(arg->acm);\n\tparams->no_ack = __cpu_to_le32(arg->no_ack);\n}\n\nstatic struct sk_buff *\nath10k_wmi_op_gen_pdev_set_wmm(struct ath10k *ar,\n\t\t\t       const struct wmi_wmm_params_all_arg *arg)\n{\n\tstruct wmi_pdev_set_wmm_params *cmd;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_pdev_set_wmm_params *)skb->data;\n\tath10k_wmi_set_wmm_param(&cmd->ac_be, &arg->ac_be);\n\tath10k_wmi_set_wmm_param(&cmd->ac_bk, &arg->ac_bk);\n\tath10k_wmi_set_wmm_param(&cmd->ac_vi, &arg->ac_vi);\n\tath10k_wmi_set_wmm_param(&cmd->ac_vo, &arg->ac_vo);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi pdev set wmm params\\n\");\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_op_gen_request_stats(struct ath10k *ar, u32 stats_mask)\n{\n\tstruct wmi_request_stats_cmd *cmd;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_request_stats_cmd *)skb->data;\n\tcmd->stats_id = __cpu_to_le32(stats_mask);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi request stats 0x%08x\\n\",\n\t\t   stats_mask);\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_op_gen_force_fw_hang(struct ath10k *ar,\n\t\t\t\tenum wmi_force_fw_hang_type type, u32 delay_ms)\n{\n\tstruct wmi_force_fw_hang_cmd *cmd;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_force_fw_hang_cmd *)skb->data;\n\tcmd->type = __cpu_to_le32(type);\n\tcmd->delay_ms = __cpu_to_le32(delay_ms);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi force fw hang %d delay %d\\n\",\n\t\t   type, delay_ms);\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_op_gen_dbglog_cfg(struct ath10k *ar, u64 module_enable,\n\t\t\t     u32 log_level)\n{\n\tstruct wmi_dbglog_cfg_cmd *cmd;\n\tstruct sk_buff *skb;\n\tu32 cfg;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_dbglog_cfg_cmd *)skb->data;\n\n\tif (module_enable) {\n\t\tcfg = SM(log_level,\n\t\t\t ATH10K_DBGLOG_CFG_LOG_LVL);\n\t} else {\n\t\t \n\t\tcfg = SM(ATH10K_DBGLOG_LEVEL_WARN,\n\t\t\t ATH10K_DBGLOG_CFG_LOG_LVL);\n\t\tmodule_enable = ~0;\n\t}\n\n\tcmd->module_enable = __cpu_to_le32(module_enable);\n\tcmd->module_valid = __cpu_to_le32(~0);\n\tcmd->config_enable = __cpu_to_le32(cfg);\n\tcmd->config_valid = __cpu_to_le32(ATH10K_DBGLOG_CFG_LOG_LVL_MASK);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi dbglog cfg modules %08x %08x config %08x %08x\\n\",\n\t\t   __le32_to_cpu(cmd->module_enable),\n\t\t   __le32_to_cpu(cmd->module_valid),\n\t\t   __le32_to_cpu(cmd->config_enable),\n\t\t   __le32_to_cpu(cmd->config_valid));\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_10_4_op_gen_dbglog_cfg(struct ath10k *ar, u64 module_enable,\n\t\t\t\t  u32 log_level)\n{\n\tstruct wmi_10_4_dbglog_cfg_cmd *cmd;\n\tstruct sk_buff *skb;\n\tu32 cfg;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_10_4_dbglog_cfg_cmd *)skb->data;\n\n\tif (module_enable) {\n\t\tcfg = SM(log_level,\n\t\t\t ATH10K_DBGLOG_CFG_LOG_LVL);\n\t} else {\n\t\t \n\t\tcfg = SM(ATH10K_DBGLOG_LEVEL_WARN,\n\t\t\t ATH10K_DBGLOG_CFG_LOG_LVL);\n\t\tmodule_enable = ~0;\n\t}\n\n\tcmd->module_enable = __cpu_to_le64(module_enable);\n\tcmd->module_valid = __cpu_to_le64(~0);\n\tcmd->config_enable = __cpu_to_le32(cfg);\n\tcmd->config_valid = __cpu_to_le32(ATH10K_DBGLOG_CFG_LOG_LVL_MASK);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi dbglog cfg modules 0x%016llx 0x%016llx config %08x %08x\\n\",\n\t\t   __le64_to_cpu(cmd->module_enable),\n\t\t   __le64_to_cpu(cmd->module_valid),\n\t\t   __le32_to_cpu(cmd->config_enable),\n\t\t   __le32_to_cpu(cmd->config_valid));\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_op_gen_pktlog_enable(struct ath10k *ar, u32 ev_bitmap)\n{\n\tstruct wmi_pdev_pktlog_enable_cmd *cmd;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tev_bitmap &= ATH10K_PKTLOG_ANY;\n\n\tcmd = (struct wmi_pdev_pktlog_enable_cmd *)skb->data;\n\tcmd->ev_bitmap = __cpu_to_le32(ev_bitmap);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi enable pktlog filter 0x%08x\\n\",\n\t\t   ev_bitmap);\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_op_gen_pktlog_disable(struct ath10k *ar)\n{\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, 0);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi disable pktlog\\n\");\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_op_gen_pdev_set_quiet_mode(struct ath10k *ar, u32 period,\n\t\t\t\t      u32 duration, u32 next_offset,\n\t\t\t\t      u32 enabled)\n{\n\tstruct wmi_pdev_set_quiet_cmd *cmd;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_pdev_set_quiet_cmd *)skb->data;\n\tcmd->period = __cpu_to_le32(period);\n\tcmd->duration = __cpu_to_le32(duration);\n\tcmd->next_start = __cpu_to_le32(next_offset);\n\tcmd->enabled = __cpu_to_le32(enabled);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi quiet param: period %u duration %u enabled %d\\n\",\n\t\t   period, duration, enabled);\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_op_gen_addba_clear_resp(struct ath10k *ar, u32 vdev_id,\n\t\t\t\t   const u8 *mac)\n{\n\tstruct wmi_addba_clear_resp_cmd *cmd;\n\tstruct sk_buff *skb;\n\n\tif (!mac)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_addba_clear_resp_cmd *)skb->data;\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n\tether_addr_copy(cmd->peer_macaddr.addr, mac);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi addba clear resp vdev_id 0x%X mac_addr %pM\\n\",\n\t\t   vdev_id, mac);\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_op_gen_addba_send(struct ath10k *ar, u32 vdev_id, const u8 *mac,\n\t\t\t     u32 tid, u32 buf_size)\n{\n\tstruct wmi_addba_send_cmd *cmd;\n\tstruct sk_buff *skb;\n\n\tif (!mac)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_addba_send_cmd *)skb->data;\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n\tether_addr_copy(cmd->peer_macaddr.addr, mac);\n\tcmd->tid = __cpu_to_le32(tid);\n\tcmd->buffersize = __cpu_to_le32(buf_size);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi addba send vdev_id 0x%X mac_addr %pM tid %u bufsize %u\\n\",\n\t\t   vdev_id, mac, tid, buf_size);\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_op_gen_addba_set_resp(struct ath10k *ar, u32 vdev_id, const u8 *mac,\n\t\t\t\t u32 tid, u32 status)\n{\n\tstruct wmi_addba_setresponse_cmd *cmd;\n\tstruct sk_buff *skb;\n\n\tif (!mac)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_addba_setresponse_cmd *)skb->data;\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n\tether_addr_copy(cmd->peer_macaddr.addr, mac);\n\tcmd->tid = __cpu_to_le32(tid);\n\tcmd->statuscode = __cpu_to_le32(status);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi addba set resp vdev_id 0x%X mac_addr %pM tid %u status %u\\n\",\n\t\t   vdev_id, mac, tid, status);\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_op_gen_delba_send(struct ath10k *ar, u32 vdev_id, const u8 *mac,\n\t\t\t     u32 tid, u32 initiator, u32 reason)\n{\n\tstruct wmi_delba_send_cmd *cmd;\n\tstruct sk_buff *skb;\n\n\tif (!mac)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_delba_send_cmd *)skb->data;\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n\tether_addr_copy(cmd->peer_macaddr.addr, mac);\n\tcmd->tid = __cpu_to_le32(tid);\n\tcmd->initiator = __cpu_to_le32(initiator);\n\tcmd->reasoncode = __cpu_to_le32(reason);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi delba send vdev_id 0x%X mac_addr %pM tid %u initiator %u reason %u\\n\",\n\t\t   vdev_id, mac, tid, initiator, reason);\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_10_2_4_op_gen_pdev_get_tpc_config(struct ath10k *ar, u32 param)\n{\n\tstruct wmi_pdev_get_tpc_config_cmd *cmd;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_pdev_get_tpc_config_cmd *)skb->data;\n\tcmd->param = __cpu_to_le32(param);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi pdev get tpc config param %d\\n\", param);\n\treturn skb;\n}\n\nstatic void\nath10k_wmi_fw_pdev_base_stats_fill(const struct ath10k_fw_stats_pdev *pdev,\n\t\t\t\t   char *buf, u32 *length)\n{\n\tu32 len = *length;\n\tu32 buf_len = ATH10K_FW_STATS_BUF_SIZE;\n\n\tlen += scnprintf(buf + len, buf_len - len, \"\\n\");\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s\\n\",\n\t\t\t\"ath10k PDEV stats\");\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s\\n\\n\",\n\t\t\t\"=================\");\n\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t\"Channel noise floor\", pdev->ch_noise_floor);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t\"Channel TX power\", pdev->chan_tx_power);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t\"TX frame count\", pdev->tx_frame_count);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t\"RX frame count\", pdev->rx_frame_count);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t\"RX clear count\", pdev->rx_clear_count);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t\"Cycle count\", pdev->cycle_count);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t\"PHY error count\", pdev->phy_err_count);\n\n\t*length = len;\n}\n\nstatic void\nath10k_wmi_fw_pdev_extra_stats_fill(const struct ath10k_fw_stats_pdev *pdev,\n\t\t\t\t    char *buf, u32 *length)\n{\n\tu32 len = *length;\n\tu32 buf_len = ATH10K_FW_STATS_BUF_SIZE;\n\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t\"RTS bad count\", pdev->rts_bad);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t\"RTS good count\", pdev->rts_good);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t\"FCS bad count\", pdev->fcs_bad);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t\"No beacon count\", pdev->no_beacons);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t\"MIB int count\", pdev->mib_int_count);\n\n\tlen += scnprintf(buf + len, buf_len - len, \"\\n\");\n\t*length = len;\n}\n\nstatic void\nath10k_wmi_fw_pdev_tx_stats_fill(const struct ath10k_fw_stats_pdev *pdev,\n\t\t\t\t char *buf, u32 *length)\n{\n\tu32 len = *length;\n\tu32 buf_len = ATH10K_FW_STATS_BUF_SIZE;\n\n\tlen += scnprintf(buf + len, buf_len - len, \"\\n%30s\\n\",\n\t\t\t \"ath10k PDEV TX stats\");\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s\\n\\n\",\n\t\t\t\t \"=================\");\n\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"HTT cookies queued\", pdev->comp_queued);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"HTT cookies disp.\", pdev->comp_delivered);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"MSDU queued\", pdev->msdu_enqued);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"MPDU queued\", pdev->mpdu_enqued);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"MSDUs dropped\", pdev->wmm_drop);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"Local enqued\", pdev->local_enqued);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"Local freed\", pdev->local_freed);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"HW queued\", pdev->hw_queued);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"PPDUs reaped\", pdev->hw_reaped);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"Num underruns\", pdev->underrun);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"PPDUs cleaned\", pdev->tx_abort);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"MPDUs requeued\", pdev->mpdus_requeued);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"Excessive retries\", pdev->tx_ko);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"HW rate\", pdev->data_rc);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"Sched self triggers\", pdev->self_triggers);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"Dropped due to SW retries\",\n\t\t\t pdev->sw_retry_failure);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"Illegal rate phy errors\",\n\t\t\t pdev->illgl_rate_phy_err);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"Pdev continuous xretry\", pdev->pdev_cont_xretry);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"TX timeout\", pdev->pdev_tx_timeout);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"PDEV resets\", pdev->pdev_resets);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"PHY underrun\", pdev->phy_underrun);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"MPDU is more than txop limit\", pdev->txop_ovf);\n\t*length = len;\n}\n\nstatic void\nath10k_wmi_fw_pdev_rx_stats_fill(const struct ath10k_fw_stats_pdev *pdev,\n\t\t\t\t char *buf, u32 *length)\n{\n\tu32 len = *length;\n\tu32 buf_len = ATH10K_FW_STATS_BUF_SIZE;\n\n\tlen += scnprintf(buf + len, buf_len - len, \"\\n%30s\\n\",\n\t\t\t \"ath10k PDEV RX stats\");\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s\\n\\n\",\n\t\t\t\t \"=================\");\n\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"Mid PPDU route change\",\n\t\t\t pdev->mid_ppdu_route_change);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"Tot. number of statuses\", pdev->status_rcvd);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"Extra frags on rings 0\", pdev->r0_frags);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"Extra frags on rings 1\", pdev->r1_frags);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"Extra frags on rings 2\", pdev->r2_frags);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"Extra frags on rings 3\", pdev->r3_frags);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"MSDUs delivered to HTT\", pdev->htt_msdus);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"MPDUs delivered to HTT\", pdev->htt_mpdus);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"MSDUs delivered to stack\", pdev->loc_msdus);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"MPDUs delivered to stack\", pdev->loc_mpdus);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"Oversized AMSDUs\", pdev->oversize_amsdu);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"PHY errors\", pdev->phy_errs);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"PHY errors drops\", pdev->phy_err_drop);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"MPDU errors (FCS, MIC, ENC)\", pdev->mpdu_errs);\n\t*length = len;\n}\n\nstatic void\nath10k_wmi_fw_vdev_stats_fill(const struct ath10k_fw_stats_vdev *vdev,\n\t\t\t      char *buf, u32 *length)\n{\n\tu32 len = *length;\n\tu32 buf_len = ATH10K_FW_STATS_BUF_SIZE;\n\tint i;\n\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t\"vdev id\", vdev->vdev_id);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t\"beacon snr\", vdev->beacon_snr);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t\"data snr\", vdev->data_snr);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t\"num rx frames\", vdev->num_rx_frames);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t\"num rts fail\", vdev->num_rts_fail);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t\"num rts success\", vdev->num_rts_success);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t\"num rx err\", vdev->num_rx_err);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t\"num rx discard\", vdev->num_rx_discard);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t\"num tx not acked\", vdev->num_tx_not_acked);\n\n\tfor (i = 0 ; i < ARRAY_SIZE(vdev->num_tx_frames); i++)\n\t\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t\t\"%25s [%02d] %u\\n\",\n\t\t\t\t\"num tx frames\", i,\n\t\t\t\tvdev->num_tx_frames[i]);\n\n\tfor (i = 0 ; i < ARRAY_SIZE(vdev->num_tx_frames_retries); i++)\n\t\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t\t\"%25s [%02d] %u\\n\",\n\t\t\t\t\"num tx frames retries\", i,\n\t\t\t\tvdev->num_tx_frames_retries[i]);\n\n\tfor (i = 0 ; i < ARRAY_SIZE(vdev->num_tx_frames_failures); i++)\n\t\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t\t\"%25s [%02d] %u\\n\",\n\t\t\t\t\"num tx frames failures\", i,\n\t\t\t\tvdev->num_tx_frames_failures[i]);\n\n\tfor (i = 0 ; i < ARRAY_SIZE(vdev->tx_rate_history); i++)\n\t\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t\t\"%25s [%02d] 0x%08x\\n\",\n\t\t\t\t\"tx rate history\", i,\n\t\t\t\tvdev->tx_rate_history[i]);\n\n\tfor (i = 0 ; i < ARRAY_SIZE(vdev->beacon_rssi_history); i++)\n\t\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t\t\"%25s [%02d] %u\\n\",\n\t\t\t\t\"beacon rssi history\", i,\n\t\t\t\tvdev->beacon_rssi_history[i]);\n\n\tlen += scnprintf(buf + len, buf_len - len, \"\\n\");\n\t*length = len;\n}\n\nstatic void\nath10k_wmi_fw_peer_stats_fill(const struct ath10k_fw_stats_peer *peer,\n\t\t\t      char *buf, u32 *length, bool extended_peer)\n{\n\tu32 len = *length;\n\tu32 buf_len = ATH10K_FW_STATS_BUF_SIZE;\n\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %pM\\n\",\n\t\t\t\"Peer MAC address\", peer->peer_macaddr);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t\"Peer RSSI\", peer->peer_rssi);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t\"Peer TX rate\", peer->peer_tx_rate);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t\"Peer RX rate\", peer->peer_rx_rate);\n\tif (!extended_peer)\n\t\tlen += scnprintf(buf + len, buf_len - len, \"%30s %llu\\n\",\n\t\t\t\t\"Peer RX duration\", peer->rx_duration);\n\n\tlen += scnprintf(buf + len, buf_len - len, \"\\n\");\n\t*length = len;\n}\n\nstatic void\nath10k_wmi_fw_extd_peer_stats_fill(const struct ath10k_fw_extd_stats_peer *peer,\n\t\t\t\t   char *buf, u32 *length)\n{\n\tu32 len = *length;\n\tu32 buf_len = ATH10K_FW_STATS_BUF_SIZE;\n\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %pM\\n\",\n\t\t\t\"Peer MAC address\", peer->peer_macaddr);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %llu\\n\",\n\t\t\t\"Peer RX duration\", peer->rx_duration);\n}\n\nvoid ath10k_wmi_main_op_fw_stats_fill(struct ath10k *ar,\n\t\t\t\t      struct ath10k_fw_stats *fw_stats,\n\t\t\t\t      char *buf)\n{\n\tu32 len = 0;\n\tu32 buf_len = ATH10K_FW_STATS_BUF_SIZE;\n\tconst struct ath10k_fw_stats_pdev *pdev;\n\tconst struct ath10k_fw_stats_vdev *vdev;\n\tconst struct ath10k_fw_stats_peer *peer;\n\tsize_t num_peers;\n\tsize_t num_vdevs;\n\n\tspin_lock_bh(&ar->data_lock);\n\n\tpdev = list_first_entry_or_null(&fw_stats->pdevs,\n\t\t\t\t\tstruct ath10k_fw_stats_pdev, list);\n\tif (!pdev) {\n\t\tath10k_warn(ar, \"failed to get pdev stats\\n\");\n\t\tgoto unlock;\n\t}\n\n\tnum_peers = list_count_nodes(&fw_stats->peers);\n\tnum_vdevs = list_count_nodes(&fw_stats->vdevs);\n\n\tath10k_wmi_fw_pdev_base_stats_fill(pdev, buf, &len);\n\tath10k_wmi_fw_pdev_tx_stats_fill(pdev, buf, &len);\n\tath10k_wmi_fw_pdev_rx_stats_fill(pdev, buf, &len);\n\n\tlen += scnprintf(buf + len, buf_len - len, \"\\n\");\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s (%zu)\\n\",\n\t\t\t \"ath10k VDEV stats\", num_vdevs);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s\\n\\n\",\n\t\t\t\t \"=================\");\n\n\tlist_for_each_entry(vdev, &fw_stats->vdevs, list) {\n\t\tath10k_wmi_fw_vdev_stats_fill(vdev, buf, &len);\n\t}\n\n\tlen += scnprintf(buf + len, buf_len - len, \"\\n\");\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s (%zu)\\n\",\n\t\t\t \"ath10k PEER stats\", num_peers);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s\\n\\n\",\n\t\t\t\t \"=================\");\n\n\tlist_for_each_entry(peer, &fw_stats->peers, list) {\n\t\tath10k_wmi_fw_peer_stats_fill(peer, buf, &len,\n\t\t\t\t\t      fw_stats->extended);\n\t}\n\nunlock:\n\tspin_unlock_bh(&ar->data_lock);\n\n\tif (len >= buf_len)\n\t\tbuf[len - 1] = 0;\n\telse\n\t\tbuf[len] = 0;\n}\n\nvoid ath10k_wmi_10x_op_fw_stats_fill(struct ath10k *ar,\n\t\t\t\t     struct ath10k_fw_stats *fw_stats,\n\t\t\t\t     char *buf)\n{\n\tunsigned int len = 0;\n\tunsigned int buf_len = ATH10K_FW_STATS_BUF_SIZE;\n\tconst struct ath10k_fw_stats_pdev *pdev;\n\tconst struct ath10k_fw_stats_vdev *vdev;\n\tconst struct ath10k_fw_stats_peer *peer;\n\tsize_t num_peers;\n\tsize_t num_vdevs;\n\n\tspin_lock_bh(&ar->data_lock);\n\n\tpdev = list_first_entry_or_null(&fw_stats->pdevs,\n\t\t\t\t\tstruct ath10k_fw_stats_pdev, list);\n\tif (!pdev) {\n\t\tath10k_warn(ar, \"failed to get pdev stats\\n\");\n\t\tgoto unlock;\n\t}\n\n\tnum_peers = list_count_nodes(&fw_stats->peers);\n\tnum_vdevs = list_count_nodes(&fw_stats->vdevs);\n\n\tath10k_wmi_fw_pdev_base_stats_fill(pdev, buf, &len);\n\tath10k_wmi_fw_pdev_extra_stats_fill(pdev, buf, &len);\n\tath10k_wmi_fw_pdev_tx_stats_fill(pdev, buf, &len);\n\tath10k_wmi_fw_pdev_rx_stats_fill(pdev, buf, &len);\n\n\tlen += scnprintf(buf + len, buf_len - len, \"\\n\");\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s (%zu)\\n\",\n\t\t\t \"ath10k VDEV stats\", num_vdevs);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s\\n\\n\",\n\t\t\t\t \"=================\");\n\n\tlist_for_each_entry(vdev, &fw_stats->vdevs, list) {\n\t\tath10k_wmi_fw_vdev_stats_fill(vdev, buf, &len);\n\t}\n\n\tlen += scnprintf(buf + len, buf_len - len, \"\\n\");\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s (%zu)\\n\",\n\t\t\t \"ath10k PEER stats\", num_peers);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s\\n\\n\",\n\t\t\t\t \"=================\");\n\n\tlist_for_each_entry(peer, &fw_stats->peers, list) {\n\t\tath10k_wmi_fw_peer_stats_fill(peer, buf, &len,\n\t\t\t\t\t      fw_stats->extended);\n\t}\n\nunlock:\n\tspin_unlock_bh(&ar->data_lock);\n\n\tif (len >= buf_len)\n\t\tbuf[len - 1] = 0;\n\telse\n\t\tbuf[len] = 0;\n}\n\nstatic struct sk_buff *\nath10k_wmi_op_gen_pdev_enable_adaptive_cca(struct ath10k *ar, u8 enable,\n\t\t\t\t\t   u32 detect_level, u32 detect_margin)\n{\n\tstruct wmi_pdev_set_adaptive_cca_params *cmd;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_pdev_set_adaptive_cca_params *)skb->data;\n\tcmd->enable = __cpu_to_le32(enable);\n\tcmd->cca_detect_level = __cpu_to_le32(detect_level);\n\tcmd->cca_detect_margin = __cpu_to_le32(detect_margin);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi pdev set adaptive cca params enable:%d detection level:%d detection margin:%d\\n\",\n\t\t   enable, detect_level, detect_margin);\n\treturn skb;\n}\n\nstatic void\nath10k_wmi_fw_vdev_stats_extd_fill(const struct ath10k_fw_stats_vdev_extd *vdev,\n\t\t\t\t   char *buf, u32 *length)\n{\n\tu32 len = *length;\n\tu32 buf_len = ATH10K_FW_STATS_BUF_SIZE;\n\tu32 val;\n\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t \"vdev id\", vdev->vdev_id);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t \"ppdu aggr count\", vdev->ppdu_aggr_cnt);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t \"ppdu noack\", vdev->ppdu_noack);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t \"mpdu queued\", vdev->mpdu_queued);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t \"ppdu nonaggr count\", vdev->ppdu_nonaggr_cnt);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t \"mpdu sw requeued\", vdev->mpdu_sw_requeued);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t \"mpdu success retry\", vdev->mpdu_suc_retry);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t \"mpdu success multitry\", vdev->mpdu_suc_multitry);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t \"mpdu fail retry\", vdev->mpdu_fail_retry);\n\tval = vdev->tx_ftm_suc;\n\tif (val & WMI_VDEV_STATS_FTM_COUNT_VALID)\n\t\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t\t \"tx ftm success\",\n\t\t\t\t MS(val, WMI_VDEV_STATS_FTM_COUNT));\n\tval = vdev->tx_ftm_suc_retry;\n\tif (val & WMI_VDEV_STATS_FTM_COUNT_VALID)\n\t\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t\t \"tx ftm success retry\",\n\t\t\t\t MS(val, WMI_VDEV_STATS_FTM_COUNT));\n\tval = vdev->tx_ftm_fail;\n\tif (val & WMI_VDEV_STATS_FTM_COUNT_VALID)\n\t\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t\t \"tx ftm fail\",\n\t\t\t\t MS(val, WMI_VDEV_STATS_FTM_COUNT));\n\tval = vdev->rx_ftmr_cnt;\n\tif (val & WMI_VDEV_STATS_FTM_COUNT_VALID)\n\t\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t\t \"rx ftm request count\",\n\t\t\t\t MS(val, WMI_VDEV_STATS_FTM_COUNT));\n\tval = vdev->rx_ftmr_dup_cnt;\n\tif (val & WMI_VDEV_STATS_FTM_COUNT_VALID)\n\t\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t\t \"rx ftm request dup count\",\n\t\t\t\t MS(val, WMI_VDEV_STATS_FTM_COUNT));\n\tval = vdev->rx_iftmr_cnt;\n\tif (val & WMI_VDEV_STATS_FTM_COUNT_VALID)\n\t\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t\t \"rx initial ftm req count\",\n\t\t\t\t MS(val, WMI_VDEV_STATS_FTM_COUNT));\n\tval = vdev->rx_iftmr_dup_cnt;\n\tif (val & WMI_VDEV_STATS_FTM_COUNT_VALID)\n\t\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t\t \"rx initial ftm req dup cnt\",\n\t\t\t\t MS(val, WMI_VDEV_STATS_FTM_COUNT));\n\tlen += scnprintf(buf + len, buf_len - len, \"\\n\");\n\n\t*length = len;\n}\n\nvoid ath10k_wmi_10_4_op_fw_stats_fill(struct ath10k *ar,\n\t\t\t\t      struct ath10k_fw_stats *fw_stats,\n\t\t\t\t      char *buf)\n{\n\tu32 len = 0;\n\tu32 buf_len = ATH10K_FW_STATS_BUF_SIZE;\n\tconst struct ath10k_fw_stats_pdev *pdev;\n\tconst struct ath10k_fw_stats_vdev_extd *vdev;\n\tconst struct ath10k_fw_stats_peer *peer;\n\tconst struct ath10k_fw_extd_stats_peer *extd_peer;\n\tsize_t num_peers;\n\tsize_t num_vdevs;\n\n\tspin_lock_bh(&ar->data_lock);\n\n\tpdev = list_first_entry_or_null(&fw_stats->pdevs,\n\t\t\t\t\tstruct ath10k_fw_stats_pdev, list);\n\tif (!pdev) {\n\t\tath10k_warn(ar, \"failed to get pdev stats\\n\");\n\t\tgoto unlock;\n\t}\n\n\tnum_peers = list_count_nodes(&fw_stats->peers);\n\tnum_vdevs = list_count_nodes(&fw_stats->vdevs);\n\n\tath10k_wmi_fw_pdev_base_stats_fill(pdev, buf, &len);\n\tath10k_wmi_fw_pdev_extra_stats_fill(pdev, buf, &len);\n\tath10k_wmi_fw_pdev_tx_stats_fill(pdev, buf, &len);\n\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t\"HW paused\", pdev->hw_paused);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t\"Seqs posted\", pdev->seq_posted);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t\"Seqs failed queueing\", pdev->seq_failed_queueing);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t\"Seqs completed\", pdev->seq_completed);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t\"Seqs restarted\", pdev->seq_restarted);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t\"MU Seqs posted\", pdev->mu_seq_posted);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t\"MPDUs SW flushed\", pdev->mpdus_sw_flush);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t\"MPDUs HW filtered\", pdev->mpdus_hw_filter);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t\"MPDUs truncated\", pdev->mpdus_truncated);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t\"MPDUs receive no ACK\", pdev->mpdus_ack_failed);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t\"MPDUs expired\", pdev->mpdus_expired);\n\n\tath10k_wmi_fw_pdev_rx_stats_fill(pdev, buf, &len);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t\"Num Rx Overflow errors\", pdev->rx_ovfl_errs);\n\n\tlen += scnprintf(buf + len, buf_len - len, \"\\n\");\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s (%zu)\\n\",\n\t\t\t\"ath10k VDEV stats\", num_vdevs);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s\\n\\n\",\n\t\t\t\t\"=================\");\n\tlist_for_each_entry(vdev, &fw_stats->vdevs, list) {\n\t\tath10k_wmi_fw_vdev_stats_extd_fill(vdev, buf, &len);\n\t}\n\n\tlen += scnprintf(buf + len, buf_len - len, \"\\n\");\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s (%zu)\\n\",\n\t\t\t\"ath10k PEER stats\", num_peers);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s\\n\\n\",\n\t\t\t\t\"=================\");\n\n\tlist_for_each_entry(peer, &fw_stats->peers, list) {\n\t\tath10k_wmi_fw_peer_stats_fill(peer, buf, &len,\n\t\t\t\t\t      fw_stats->extended);\n\t}\n\n\tif (fw_stats->extended) {\n\t\tlist_for_each_entry(extd_peer, &fw_stats->peers_extd, list) {\n\t\t\tath10k_wmi_fw_extd_peer_stats_fill(extd_peer, buf,\n\t\t\t\t\t\t\t   &len);\n\t\t}\n\t}\n\nunlock:\n\tspin_unlock_bh(&ar->data_lock);\n\n\tif (len >= buf_len)\n\t\tbuf[len - 1] = 0;\n\telse\n\t\tbuf[len] = 0;\n}\n\nint ath10k_wmi_op_get_vdev_subtype(struct ath10k *ar,\n\t\t\t\t   enum wmi_vdev_subtype subtype)\n{\n\tswitch (subtype) {\n\tcase WMI_VDEV_SUBTYPE_NONE:\n\t\treturn WMI_VDEV_SUBTYPE_LEGACY_NONE;\n\tcase WMI_VDEV_SUBTYPE_P2P_DEVICE:\n\t\treturn WMI_VDEV_SUBTYPE_LEGACY_P2P_DEV;\n\tcase WMI_VDEV_SUBTYPE_P2P_CLIENT:\n\t\treturn WMI_VDEV_SUBTYPE_LEGACY_P2P_CLI;\n\tcase WMI_VDEV_SUBTYPE_P2P_GO:\n\t\treturn WMI_VDEV_SUBTYPE_LEGACY_P2P_GO;\n\tcase WMI_VDEV_SUBTYPE_PROXY_STA:\n\t\treturn WMI_VDEV_SUBTYPE_LEGACY_PROXY_STA;\n\tcase WMI_VDEV_SUBTYPE_MESH_11S:\n\tcase WMI_VDEV_SUBTYPE_MESH_NON_11S:\n\t\treturn -ENOTSUPP;\n\t}\n\treturn -ENOTSUPP;\n}\n\nstatic int ath10k_wmi_10_2_4_op_get_vdev_subtype(struct ath10k *ar,\n\t\t\t\t\t\t enum wmi_vdev_subtype subtype)\n{\n\tswitch (subtype) {\n\tcase WMI_VDEV_SUBTYPE_NONE:\n\t\treturn WMI_VDEV_SUBTYPE_10_2_4_NONE;\n\tcase WMI_VDEV_SUBTYPE_P2P_DEVICE:\n\t\treturn WMI_VDEV_SUBTYPE_10_2_4_P2P_DEV;\n\tcase WMI_VDEV_SUBTYPE_P2P_CLIENT:\n\t\treturn WMI_VDEV_SUBTYPE_10_2_4_P2P_CLI;\n\tcase WMI_VDEV_SUBTYPE_P2P_GO:\n\t\treturn WMI_VDEV_SUBTYPE_10_2_4_P2P_GO;\n\tcase WMI_VDEV_SUBTYPE_PROXY_STA:\n\t\treturn WMI_VDEV_SUBTYPE_10_2_4_PROXY_STA;\n\tcase WMI_VDEV_SUBTYPE_MESH_11S:\n\t\treturn WMI_VDEV_SUBTYPE_10_2_4_MESH_11S;\n\tcase WMI_VDEV_SUBTYPE_MESH_NON_11S:\n\t\treturn -ENOTSUPP;\n\t}\n\treturn -ENOTSUPP;\n}\n\nstatic int ath10k_wmi_10_4_op_get_vdev_subtype(struct ath10k *ar,\n\t\t\t\t\t       enum wmi_vdev_subtype subtype)\n{\n\tswitch (subtype) {\n\tcase WMI_VDEV_SUBTYPE_NONE:\n\t\treturn WMI_VDEV_SUBTYPE_10_4_NONE;\n\tcase WMI_VDEV_SUBTYPE_P2P_DEVICE:\n\t\treturn WMI_VDEV_SUBTYPE_10_4_P2P_DEV;\n\tcase WMI_VDEV_SUBTYPE_P2P_CLIENT:\n\t\treturn WMI_VDEV_SUBTYPE_10_4_P2P_CLI;\n\tcase WMI_VDEV_SUBTYPE_P2P_GO:\n\t\treturn WMI_VDEV_SUBTYPE_10_4_P2P_GO;\n\tcase WMI_VDEV_SUBTYPE_PROXY_STA:\n\t\treturn WMI_VDEV_SUBTYPE_10_4_PROXY_STA;\n\tcase WMI_VDEV_SUBTYPE_MESH_11S:\n\t\treturn WMI_VDEV_SUBTYPE_10_4_MESH_11S;\n\tcase WMI_VDEV_SUBTYPE_MESH_NON_11S:\n\t\treturn WMI_VDEV_SUBTYPE_10_4_MESH_NON_11S;\n\t}\n\treturn -ENOTSUPP;\n}\n\nstatic struct sk_buff *\nath10k_wmi_10_4_ext_resource_config(struct ath10k *ar,\n\t\t\t\t    enum wmi_host_platform_type type,\n\t\t\t\t    u32 fw_feature_bitmap)\n{\n\tstruct wmi_ext_resource_config_10_4_cmd *cmd;\n\tstruct sk_buff *skb;\n\tu32 num_tdls_sleep_sta = 0;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (test_bit(WMI_SERVICE_TDLS_UAPSD_SLEEP_STA, ar->wmi.svc_map))\n\t\tnum_tdls_sleep_sta = TARGET_10_4_NUM_TDLS_SLEEP_STA;\n\n\tcmd = (struct wmi_ext_resource_config_10_4_cmd *)skb->data;\n\tcmd->host_platform_config = __cpu_to_le32(type);\n\tcmd->fw_feature_bitmap = __cpu_to_le32(fw_feature_bitmap);\n\tcmd->wlan_gpio_priority = __cpu_to_le32(ar->coex_gpio_pin);\n\tcmd->coex_version = __cpu_to_le32(WMI_NO_COEX_VERSION_SUPPORT);\n\tcmd->coex_gpio_pin1 = __cpu_to_le32(-1);\n\tcmd->coex_gpio_pin2 = __cpu_to_le32(-1);\n\tcmd->coex_gpio_pin3 = __cpu_to_le32(-1);\n\tcmd->num_tdls_vdevs = __cpu_to_le32(TARGET_10_4_NUM_TDLS_VDEVS);\n\tcmd->num_tdls_conn_table_entries = __cpu_to_le32(20);\n\tcmd->max_tdls_concurrent_sleep_sta = __cpu_to_le32(num_tdls_sleep_sta);\n\tcmd->max_tdls_concurrent_buffer_sta =\n\t\t\t__cpu_to_le32(TARGET_10_4_NUM_TDLS_BUFFER_STA);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi ext resource config host type %d firmware feature bitmap %08x\\n\",\n\t\t   type, fw_feature_bitmap);\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_10_4_gen_update_fw_tdls_state(struct ath10k *ar, u32 vdev_id,\n\t\t\t\t\t enum wmi_tdls_state state)\n{\n\tstruct wmi_10_4_tdls_set_state_cmd *cmd;\n\tstruct sk_buff *skb;\n\tu32 options = 0;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (test_bit(WMI_SERVICE_TDLS_EXPLICIT_MODE_ONLY, ar->wmi.svc_map) &&\n\t    state == WMI_TDLS_ENABLE_ACTIVE)\n\t\tstate = WMI_TDLS_ENABLE_PASSIVE;\n\n\tif (test_bit(WMI_SERVICE_TDLS_UAPSD_BUFFER_STA, ar->wmi.svc_map))\n\t\toptions |= WMI_TDLS_BUFFER_STA_EN;\n\n\tcmd = (struct wmi_10_4_tdls_set_state_cmd *)skb->data;\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n\tcmd->state = __cpu_to_le32(state);\n\tcmd->notification_interval_ms = __cpu_to_le32(5000);\n\tcmd->tx_discovery_threshold = __cpu_to_le32(100);\n\tcmd->tx_teardown_threshold = __cpu_to_le32(5);\n\tcmd->rssi_teardown_threshold = __cpu_to_le32(-75);\n\tcmd->rssi_delta = __cpu_to_le32(-20);\n\tcmd->tdls_options = __cpu_to_le32(options);\n\tcmd->tdls_peer_traffic_ind_window = __cpu_to_le32(2);\n\tcmd->tdls_peer_traffic_response_timeout_ms = __cpu_to_le32(5000);\n\tcmd->tdls_puapsd_mask = __cpu_to_le32(0xf);\n\tcmd->tdls_puapsd_inactivity_time_ms = __cpu_to_le32(0);\n\tcmd->tdls_puapsd_rx_frame_threshold = __cpu_to_le32(10);\n\tcmd->teardown_notification_ms = __cpu_to_le32(10);\n\tcmd->tdls_peer_kickout_threshold = __cpu_to_le32(96);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi update fw tdls state %d for vdev %i\\n\",\n\t\t   state, vdev_id);\n\treturn skb;\n}\n\nstatic u32 ath10k_wmi_prepare_peer_qos(u8 uapsd_queues, u8 sp)\n{\n\tu32 peer_qos = 0;\n\n\tif (uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_VO)\n\t\tpeer_qos |= WMI_TDLS_PEER_QOS_AC_VO;\n\tif (uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_VI)\n\t\tpeer_qos |= WMI_TDLS_PEER_QOS_AC_VI;\n\tif (uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_BK)\n\t\tpeer_qos |= WMI_TDLS_PEER_QOS_AC_BK;\n\tif (uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_BE)\n\t\tpeer_qos |= WMI_TDLS_PEER_QOS_AC_BE;\n\n\tpeer_qos |= SM(sp, WMI_TDLS_PEER_SP);\n\n\treturn peer_qos;\n}\n\nstatic struct sk_buff *\nath10k_wmi_10_4_op_gen_pdev_get_tpc_table_cmdid(struct ath10k *ar, u32 param)\n{\n\tstruct wmi_pdev_get_tpc_table_cmd *cmd;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_pdev_get_tpc_table_cmd *)skb->data;\n\tcmd->param = __cpu_to_le32(param);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi pdev get tpc table param:%d\\n\", param);\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_10_4_gen_tdls_peer_update(struct ath10k *ar,\n\t\t\t\t     const struct wmi_tdls_peer_update_cmd_arg *arg,\n\t\t\t\t     const struct wmi_tdls_peer_capab_arg *cap,\n\t\t\t\t     const struct wmi_channel_arg *chan_arg)\n{\n\tstruct wmi_10_4_tdls_peer_update_cmd *cmd;\n\tstruct wmi_tdls_peer_capabilities *peer_cap;\n\tstruct wmi_channel *chan;\n\tstruct sk_buff *skb;\n\tu32 peer_qos;\n\tint len, chan_len;\n\tint i;\n\n\t \n\tchan_len = cap->peer_chan_len ? (cap->peer_chan_len - 1) : 0;\n\n\tlen = sizeof(*cmd) + chan_len * sizeof(*chan);\n\n\tskb = ath10k_wmi_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmemset(skb->data, 0, sizeof(*cmd));\n\n\tcmd = (struct wmi_10_4_tdls_peer_update_cmd *)skb->data;\n\tcmd->vdev_id = __cpu_to_le32(arg->vdev_id);\n\tether_addr_copy(cmd->peer_macaddr.addr, arg->addr);\n\tcmd->peer_state = __cpu_to_le32(arg->peer_state);\n\n\tpeer_qos = ath10k_wmi_prepare_peer_qos(cap->peer_uapsd_queues,\n\t\t\t\t\t       cap->peer_max_sp);\n\n\tpeer_cap = &cmd->peer_capab;\n\tpeer_cap->peer_qos = __cpu_to_le32(peer_qos);\n\tpeer_cap->buff_sta_support = __cpu_to_le32(cap->buff_sta_support);\n\tpeer_cap->off_chan_support = __cpu_to_le32(cap->off_chan_support);\n\tpeer_cap->peer_curr_operclass = __cpu_to_le32(cap->peer_curr_operclass);\n\tpeer_cap->self_curr_operclass = __cpu_to_le32(cap->self_curr_operclass);\n\tpeer_cap->peer_chan_len = __cpu_to_le32(cap->peer_chan_len);\n\tpeer_cap->peer_operclass_len = __cpu_to_le32(cap->peer_operclass_len);\n\n\tfor (i = 0; i < WMI_TDLS_MAX_SUPP_OPER_CLASSES; i++)\n\t\tpeer_cap->peer_operclass[i] = cap->peer_operclass[i];\n\n\tpeer_cap->is_peer_responder = __cpu_to_le32(cap->is_peer_responder);\n\tpeer_cap->pref_offchan_num = __cpu_to_le32(cap->pref_offchan_num);\n\tpeer_cap->pref_offchan_bw = __cpu_to_le32(cap->pref_offchan_bw);\n\n\tfor (i = 0; i < cap->peer_chan_len; i++) {\n\t\tchan = (struct wmi_channel *)&peer_cap->peer_chan_list[i];\n\t\tath10k_wmi_put_wmi_channel(ar, chan, &chan_arg[i]);\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi tdls peer update vdev %i state %d n_chans %u\\n\",\n\t\t   arg->vdev_id, arg->peer_state, cap->peer_chan_len);\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_10_4_gen_radar_found(struct ath10k *ar,\n\t\t\t\tconst struct ath10k_radar_found_info *arg)\n{\n\tstruct wmi_radar_found_info *cmd;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_radar_found_info *)skb->data;\n\tcmd->pri_min   = __cpu_to_le32(arg->pri_min);\n\tcmd->pri_max   = __cpu_to_le32(arg->pri_max);\n\tcmd->width_min = __cpu_to_le32(arg->width_min);\n\tcmd->width_max = __cpu_to_le32(arg->width_max);\n\tcmd->sidx_min  = __cpu_to_le32(arg->sidx_min);\n\tcmd->sidx_max  = __cpu_to_le32(arg->sidx_max);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi radar found pri_min %d pri_max %d width_min %d width_max %d sidx_min %d sidx_max %d\\n\",\n\t\t   arg->pri_min, arg->pri_max, arg->width_min,\n\t\t   arg->width_max, arg->sidx_min, arg->sidx_max);\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_10_4_gen_per_peer_per_tid_cfg(struct ath10k *ar,\n\t\t\t\t\t const struct wmi_per_peer_per_tid_cfg_arg *arg)\n{\n\tstruct wmi_peer_per_tid_cfg_cmd *cmd;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmemset(skb->data, 0, sizeof(*cmd));\n\n\tcmd = (struct wmi_peer_per_tid_cfg_cmd *)skb->data;\n\tcmd->vdev_id = cpu_to_le32(arg->vdev_id);\n\tether_addr_copy(cmd->peer_macaddr.addr, arg->peer_macaddr.addr);\n\tcmd->tid = cpu_to_le32(arg->tid);\n\tcmd->ack_policy = cpu_to_le32(arg->ack_policy);\n\tcmd->aggr_control = cpu_to_le32(arg->aggr_control);\n\tcmd->rate_control = cpu_to_le32(arg->rate_ctrl);\n\tcmd->retry_count = cpu_to_le32(arg->retry_count);\n\tcmd->rcode_flags = cpu_to_le32(arg->rcode_flags);\n\tcmd->ext_tid_cfg_bitmap = cpu_to_le32(arg->ext_tid_cfg_bitmap);\n\tcmd->rtscts_ctrl = cpu_to_le32(arg->rtscts_ctrl);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi noack tid %d vdev id %d ack_policy %d aggr %u rate_ctrl %u rcflag %u retry_count %d rtscts %d ext_tid_cfg_bitmap %d mac_addr %pM\\n\",\n\t\t   arg->tid, arg->vdev_id, arg->ack_policy, arg->aggr_control,\n\t\t   arg->rate_ctrl, arg->rcode_flags, arg->retry_count,\n\t\t   arg->rtscts_ctrl, arg->ext_tid_cfg_bitmap, arg->peer_macaddr.addr);\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_op_gen_echo(struct ath10k *ar, u32 value)\n{\n\tstruct wmi_echo_cmd *cmd;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_echo_cmd *)skb->data;\n\tcmd->value = cpu_to_le32(value);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi echo value 0x%08x\\n\", value);\n\treturn skb;\n}\n\nint\nath10k_wmi_barrier(struct ath10k *ar)\n{\n\tint ret;\n\tint time_left;\n\n\tspin_lock_bh(&ar->data_lock);\n\treinit_completion(&ar->wmi.barrier);\n\tspin_unlock_bh(&ar->data_lock);\n\n\tret = ath10k_wmi_echo(ar, ATH10K_WMI_BARRIER_ECHO_ID);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to submit wmi echo: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ttime_left = wait_for_completion_timeout(&ar->wmi.barrier,\n\t\t\t\t\t\tATH10K_WMI_BARRIER_TIMEOUT_HZ);\n\tif (!time_left)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic struct sk_buff *\nath10k_wmi_10_2_4_op_gen_bb_timing(struct ath10k *ar,\n\t\t\t\t   const struct wmi_bb_timing_cfg_arg *arg)\n{\n\tstruct wmi_pdev_bb_timing_cfg_cmd *cmd;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_pdev_bb_timing_cfg_cmd *)skb->data;\n\tcmd->bb_tx_timing = __cpu_to_le32(arg->bb_tx_timing);\n\tcmd->bb_xpa_timing = __cpu_to_le32(arg->bb_xpa_timing);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi pdev bb_tx_timing 0x%x bb_xpa_timing 0x%x\\n\",\n\t\t   arg->bb_tx_timing, arg->bb_xpa_timing);\n\treturn skb;\n}\n\nstatic const struct wmi_ops wmi_ops = {\n\t.rx = ath10k_wmi_op_rx,\n\t.map_svc = wmi_main_svc_map,\n\n\t.pull_scan = ath10k_wmi_op_pull_scan_ev,\n\t.pull_mgmt_rx = ath10k_wmi_op_pull_mgmt_rx_ev,\n\t.pull_ch_info = ath10k_wmi_op_pull_ch_info_ev,\n\t.pull_vdev_start = ath10k_wmi_op_pull_vdev_start_ev,\n\t.pull_peer_kick = ath10k_wmi_op_pull_peer_kick_ev,\n\t.pull_swba = ath10k_wmi_op_pull_swba_ev,\n\t.pull_phyerr_hdr = ath10k_wmi_op_pull_phyerr_ev_hdr,\n\t.pull_phyerr = ath10k_wmi_op_pull_phyerr_ev,\n\t.pull_svc_rdy = ath10k_wmi_main_op_pull_svc_rdy_ev,\n\t.pull_rdy = ath10k_wmi_op_pull_rdy_ev,\n\t.pull_fw_stats = ath10k_wmi_main_op_pull_fw_stats,\n\t.pull_roam_ev = ath10k_wmi_op_pull_roam_ev,\n\t.pull_echo_ev = ath10k_wmi_op_pull_echo_ev,\n\n\t.gen_pdev_suspend = ath10k_wmi_op_gen_pdev_suspend,\n\t.gen_pdev_resume = ath10k_wmi_op_gen_pdev_resume,\n\t.gen_pdev_set_rd = ath10k_wmi_op_gen_pdev_set_rd,\n\t.gen_pdev_set_param = ath10k_wmi_op_gen_pdev_set_param,\n\t.gen_init = ath10k_wmi_op_gen_init,\n\t.gen_start_scan = ath10k_wmi_op_gen_start_scan,\n\t.gen_stop_scan = ath10k_wmi_op_gen_stop_scan,\n\t.gen_vdev_create = ath10k_wmi_op_gen_vdev_create,\n\t.gen_vdev_delete = ath10k_wmi_op_gen_vdev_delete,\n\t.gen_vdev_start = ath10k_wmi_op_gen_vdev_start,\n\t.gen_vdev_stop = ath10k_wmi_op_gen_vdev_stop,\n\t.gen_vdev_up = ath10k_wmi_op_gen_vdev_up,\n\t.gen_vdev_down = ath10k_wmi_op_gen_vdev_down,\n\t.gen_vdev_set_param = ath10k_wmi_op_gen_vdev_set_param,\n\t.gen_vdev_install_key = ath10k_wmi_op_gen_vdev_install_key,\n\t.gen_vdev_spectral_conf = ath10k_wmi_op_gen_vdev_spectral_conf,\n\t.gen_vdev_spectral_enable = ath10k_wmi_op_gen_vdev_spectral_enable,\n\t \n\t.gen_peer_create = ath10k_wmi_op_gen_peer_create,\n\t.gen_peer_delete = ath10k_wmi_op_gen_peer_delete,\n\t.gen_peer_flush = ath10k_wmi_op_gen_peer_flush,\n\t.gen_peer_set_param = ath10k_wmi_op_gen_peer_set_param,\n\t.gen_peer_assoc = ath10k_wmi_op_gen_peer_assoc,\n\t.gen_set_psmode = ath10k_wmi_op_gen_set_psmode,\n\t.gen_set_sta_ps = ath10k_wmi_op_gen_set_sta_ps,\n\t.gen_set_ap_ps = ath10k_wmi_op_gen_set_ap_ps,\n\t.gen_scan_chan_list = ath10k_wmi_op_gen_scan_chan_list,\n\t.gen_beacon_dma = ath10k_wmi_op_gen_beacon_dma,\n\t.gen_pdev_set_wmm = ath10k_wmi_op_gen_pdev_set_wmm,\n\t.gen_request_stats = ath10k_wmi_op_gen_request_stats,\n\t.gen_force_fw_hang = ath10k_wmi_op_gen_force_fw_hang,\n\t.gen_mgmt_tx = ath10k_wmi_op_gen_mgmt_tx,\n\t.gen_dbglog_cfg = ath10k_wmi_op_gen_dbglog_cfg,\n\t.gen_pktlog_enable = ath10k_wmi_op_gen_pktlog_enable,\n\t.gen_pktlog_disable = ath10k_wmi_op_gen_pktlog_disable,\n\t.gen_pdev_set_quiet_mode = ath10k_wmi_op_gen_pdev_set_quiet_mode,\n\t \n\t.gen_addba_clear_resp = ath10k_wmi_op_gen_addba_clear_resp,\n\t.gen_addba_send = ath10k_wmi_op_gen_addba_send,\n\t.gen_addba_set_resp = ath10k_wmi_op_gen_addba_set_resp,\n\t.gen_delba_send = ath10k_wmi_op_gen_delba_send,\n\t.fw_stats_fill = ath10k_wmi_main_op_fw_stats_fill,\n\t.get_vdev_subtype = ath10k_wmi_op_get_vdev_subtype,\n\t.gen_echo = ath10k_wmi_op_gen_echo,\n\t \n\t \n\t \n\t \n\t \n};\n\nstatic const struct wmi_ops wmi_10_1_ops = {\n\t.rx = ath10k_wmi_10_1_op_rx,\n\t.map_svc = wmi_10x_svc_map,\n\t.pull_svc_rdy = ath10k_wmi_10x_op_pull_svc_rdy_ev,\n\t.pull_fw_stats = ath10k_wmi_10x_op_pull_fw_stats,\n\t.gen_init = ath10k_wmi_10_1_op_gen_init,\n\t.gen_pdev_set_rd = ath10k_wmi_10x_op_gen_pdev_set_rd,\n\t.gen_start_scan = ath10k_wmi_10x_op_gen_start_scan,\n\t.gen_peer_assoc = ath10k_wmi_10_1_op_gen_peer_assoc,\n\t \n\n\t \n\t.pull_scan = ath10k_wmi_op_pull_scan_ev,\n\t.pull_mgmt_rx = ath10k_wmi_op_pull_mgmt_rx_ev,\n\t.pull_ch_info = ath10k_wmi_op_pull_ch_info_ev,\n\t.pull_vdev_start = ath10k_wmi_op_pull_vdev_start_ev,\n\t.pull_peer_kick = ath10k_wmi_op_pull_peer_kick_ev,\n\t.pull_swba = ath10k_wmi_op_pull_swba_ev,\n\t.pull_phyerr_hdr = ath10k_wmi_op_pull_phyerr_ev_hdr,\n\t.pull_phyerr = ath10k_wmi_op_pull_phyerr_ev,\n\t.pull_rdy = ath10k_wmi_op_pull_rdy_ev,\n\t.pull_roam_ev = ath10k_wmi_op_pull_roam_ev,\n\t.pull_echo_ev = ath10k_wmi_op_pull_echo_ev,\n\n\t.gen_pdev_suspend = ath10k_wmi_op_gen_pdev_suspend,\n\t.gen_pdev_resume = ath10k_wmi_op_gen_pdev_resume,\n\t.gen_pdev_set_param = ath10k_wmi_op_gen_pdev_set_param,\n\t.gen_stop_scan = ath10k_wmi_op_gen_stop_scan,\n\t.gen_vdev_create = ath10k_wmi_op_gen_vdev_create,\n\t.gen_vdev_delete = ath10k_wmi_op_gen_vdev_delete,\n\t.gen_vdev_start = ath10k_wmi_op_gen_vdev_start,\n\t.gen_vdev_stop = ath10k_wmi_op_gen_vdev_stop,\n\t.gen_vdev_up = ath10k_wmi_op_gen_vdev_up,\n\t.gen_vdev_down = ath10k_wmi_op_gen_vdev_down,\n\t.gen_vdev_set_param = ath10k_wmi_op_gen_vdev_set_param,\n\t.gen_vdev_install_key = ath10k_wmi_op_gen_vdev_install_key,\n\t.gen_vdev_spectral_conf = ath10k_wmi_op_gen_vdev_spectral_conf,\n\t.gen_vdev_spectral_enable = ath10k_wmi_op_gen_vdev_spectral_enable,\n\t \n\t.gen_peer_create = ath10k_wmi_op_gen_peer_create,\n\t.gen_peer_delete = ath10k_wmi_op_gen_peer_delete,\n\t.gen_peer_flush = ath10k_wmi_op_gen_peer_flush,\n\t.gen_peer_set_param = ath10k_wmi_op_gen_peer_set_param,\n\t.gen_set_psmode = ath10k_wmi_op_gen_set_psmode,\n\t.gen_set_sta_ps = ath10k_wmi_op_gen_set_sta_ps,\n\t.gen_set_ap_ps = ath10k_wmi_op_gen_set_ap_ps,\n\t.gen_scan_chan_list = ath10k_wmi_op_gen_scan_chan_list,\n\t.gen_beacon_dma = ath10k_wmi_op_gen_beacon_dma,\n\t.gen_pdev_set_wmm = ath10k_wmi_op_gen_pdev_set_wmm,\n\t.gen_request_stats = ath10k_wmi_op_gen_request_stats,\n\t.gen_force_fw_hang = ath10k_wmi_op_gen_force_fw_hang,\n\t.gen_mgmt_tx = ath10k_wmi_op_gen_mgmt_tx,\n\t.gen_dbglog_cfg = ath10k_wmi_op_gen_dbglog_cfg,\n\t.gen_pktlog_enable = ath10k_wmi_op_gen_pktlog_enable,\n\t.gen_pktlog_disable = ath10k_wmi_op_gen_pktlog_disable,\n\t.gen_pdev_set_quiet_mode = ath10k_wmi_op_gen_pdev_set_quiet_mode,\n\t.gen_addba_clear_resp = ath10k_wmi_op_gen_addba_clear_resp,\n\t.gen_addba_send = ath10k_wmi_op_gen_addba_send,\n\t.gen_addba_set_resp = ath10k_wmi_op_gen_addba_set_resp,\n\t.gen_delba_send = ath10k_wmi_op_gen_delba_send,\n\t.fw_stats_fill = ath10k_wmi_10x_op_fw_stats_fill,\n\t.get_vdev_subtype = ath10k_wmi_op_get_vdev_subtype,\n\t.gen_echo = ath10k_wmi_op_gen_echo,\n\t \n\t \n\t \n\t \n\t \n};\n\nstatic const struct wmi_ops wmi_10_2_ops = {\n\t.rx = ath10k_wmi_10_2_op_rx,\n\t.pull_fw_stats = ath10k_wmi_10_2_op_pull_fw_stats,\n\t.gen_init = ath10k_wmi_10_2_op_gen_init,\n\t.gen_peer_assoc = ath10k_wmi_10_2_op_gen_peer_assoc,\n\t \n\n\t \n\t.map_svc = wmi_10x_svc_map,\n\t.pull_svc_rdy = ath10k_wmi_10x_op_pull_svc_rdy_ev,\n\t.gen_pdev_set_rd = ath10k_wmi_10x_op_gen_pdev_set_rd,\n\t.gen_start_scan = ath10k_wmi_10x_op_gen_start_scan,\n\t.gen_echo = ath10k_wmi_op_gen_echo,\n\n\t.pull_scan = ath10k_wmi_op_pull_scan_ev,\n\t.pull_mgmt_rx = ath10k_wmi_op_pull_mgmt_rx_ev,\n\t.pull_ch_info = ath10k_wmi_op_pull_ch_info_ev,\n\t.pull_vdev_start = ath10k_wmi_op_pull_vdev_start_ev,\n\t.pull_peer_kick = ath10k_wmi_op_pull_peer_kick_ev,\n\t.pull_swba = ath10k_wmi_op_pull_swba_ev,\n\t.pull_phyerr_hdr = ath10k_wmi_op_pull_phyerr_ev_hdr,\n\t.pull_phyerr = ath10k_wmi_op_pull_phyerr_ev,\n\t.pull_rdy = ath10k_wmi_op_pull_rdy_ev,\n\t.pull_roam_ev = ath10k_wmi_op_pull_roam_ev,\n\t.pull_echo_ev = ath10k_wmi_op_pull_echo_ev,\n\n\t.gen_pdev_suspend = ath10k_wmi_op_gen_pdev_suspend,\n\t.gen_pdev_resume = ath10k_wmi_op_gen_pdev_resume,\n\t.gen_pdev_set_param = ath10k_wmi_op_gen_pdev_set_param,\n\t.gen_stop_scan = ath10k_wmi_op_gen_stop_scan,\n\t.gen_vdev_create = ath10k_wmi_op_gen_vdev_create,\n\t.gen_vdev_delete = ath10k_wmi_op_gen_vdev_delete,\n\t.gen_vdev_start = ath10k_wmi_op_gen_vdev_start,\n\t.gen_vdev_stop = ath10k_wmi_op_gen_vdev_stop,\n\t.gen_vdev_up = ath10k_wmi_op_gen_vdev_up,\n\t.gen_vdev_down = ath10k_wmi_op_gen_vdev_down,\n\t.gen_vdev_set_param = ath10k_wmi_op_gen_vdev_set_param,\n\t.gen_vdev_install_key = ath10k_wmi_op_gen_vdev_install_key,\n\t.gen_vdev_spectral_conf = ath10k_wmi_op_gen_vdev_spectral_conf,\n\t.gen_vdev_spectral_enable = ath10k_wmi_op_gen_vdev_spectral_enable,\n\t \n\t.gen_peer_create = ath10k_wmi_op_gen_peer_create,\n\t.gen_peer_delete = ath10k_wmi_op_gen_peer_delete,\n\t.gen_peer_flush = ath10k_wmi_op_gen_peer_flush,\n\t.gen_pdev_set_base_macaddr = ath10k_wmi_op_gen_pdev_set_base_macaddr,\n\t.gen_peer_set_param = ath10k_wmi_op_gen_peer_set_param,\n\t.gen_set_psmode = ath10k_wmi_op_gen_set_psmode,\n\t.gen_set_sta_ps = ath10k_wmi_op_gen_set_sta_ps,\n\t.gen_set_ap_ps = ath10k_wmi_op_gen_set_ap_ps,\n\t.gen_scan_chan_list = ath10k_wmi_op_gen_scan_chan_list,\n\t.gen_beacon_dma = ath10k_wmi_op_gen_beacon_dma,\n\t.gen_pdev_set_wmm = ath10k_wmi_op_gen_pdev_set_wmm,\n\t.gen_request_stats = ath10k_wmi_op_gen_request_stats,\n\t.gen_force_fw_hang = ath10k_wmi_op_gen_force_fw_hang,\n\t.gen_mgmt_tx = ath10k_wmi_op_gen_mgmt_tx,\n\t.gen_dbglog_cfg = ath10k_wmi_op_gen_dbglog_cfg,\n\t.gen_pktlog_enable = ath10k_wmi_op_gen_pktlog_enable,\n\t.gen_pktlog_disable = ath10k_wmi_op_gen_pktlog_disable,\n\t.gen_pdev_set_quiet_mode = ath10k_wmi_op_gen_pdev_set_quiet_mode,\n\t.gen_addba_clear_resp = ath10k_wmi_op_gen_addba_clear_resp,\n\t.gen_addba_send = ath10k_wmi_op_gen_addba_send,\n\t.gen_addba_set_resp = ath10k_wmi_op_gen_addba_set_resp,\n\t.gen_delba_send = ath10k_wmi_op_gen_delba_send,\n\t.fw_stats_fill = ath10k_wmi_10x_op_fw_stats_fill,\n\t.get_vdev_subtype = ath10k_wmi_op_get_vdev_subtype,\n\t \n};\n\nstatic const struct wmi_ops wmi_10_2_4_ops = {\n\t.rx = ath10k_wmi_10_2_op_rx,\n\t.pull_fw_stats = ath10k_wmi_10_2_4_op_pull_fw_stats,\n\t.gen_init = ath10k_wmi_10_2_op_gen_init,\n\t.gen_peer_assoc = ath10k_wmi_10_2_op_gen_peer_assoc,\n\t.gen_pdev_get_temperature = ath10k_wmi_10_2_op_gen_pdev_get_temperature,\n\t.gen_pdev_bss_chan_info_req = ath10k_wmi_10_2_op_gen_pdev_bss_chan_info,\n\n\t \n\t.map_svc = wmi_10x_svc_map,\n\t.pull_svc_rdy = ath10k_wmi_10x_op_pull_svc_rdy_ev,\n\t.gen_pdev_set_rd = ath10k_wmi_10x_op_gen_pdev_set_rd,\n\t.gen_start_scan = ath10k_wmi_10x_op_gen_start_scan,\n\t.gen_echo = ath10k_wmi_op_gen_echo,\n\n\t.pull_scan = ath10k_wmi_op_pull_scan_ev,\n\t.pull_mgmt_rx = ath10k_wmi_op_pull_mgmt_rx_ev,\n\t.pull_ch_info = ath10k_wmi_op_pull_ch_info_ev,\n\t.pull_vdev_start = ath10k_wmi_op_pull_vdev_start_ev,\n\t.pull_peer_kick = ath10k_wmi_op_pull_peer_kick_ev,\n\t.pull_swba = ath10k_wmi_10_2_4_op_pull_swba_ev,\n\t.pull_phyerr_hdr = ath10k_wmi_op_pull_phyerr_ev_hdr,\n\t.pull_phyerr = ath10k_wmi_op_pull_phyerr_ev,\n\t.pull_rdy = ath10k_wmi_op_pull_rdy_ev,\n\t.pull_roam_ev = ath10k_wmi_op_pull_roam_ev,\n\t.pull_echo_ev = ath10k_wmi_op_pull_echo_ev,\n\n\t.gen_pdev_suspend = ath10k_wmi_op_gen_pdev_suspend,\n\t.gen_pdev_resume = ath10k_wmi_op_gen_pdev_resume,\n\t.gen_pdev_set_param = ath10k_wmi_op_gen_pdev_set_param,\n\t.gen_stop_scan = ath10k_wmi_op_gen_stop_scan,\n\t.gen_vdev_create = ath10k_wmi_op_gen_vdev_create,\n\t.gen_vdev_delete = ath10k_wmi_op_gen_vdev_delete,\n\t.gen_vdev_start = ath10k_wmi_op_gen_vdev_start,\n\t.gen_vdev_stop = ath10k_wmi_op_gen_vdev_stop,\n\t.gen_vdev_up = ath10k_wmi_op_gen_vdev_up,\n\t.gen_vdev_down = ath10k_wmi_op_gen_vdev_down,\n\t.gen_vdev_set_param = ath10k_wmi_op_gen_vdev_set_param,\n\t.gen_vdev_install_key = ath10k_wmi_op_gen_vdev_install_key,\n\t.gen_vdev_spectral_conf = ath10k_wmi_op_gen_vdev_spectral_conf,\n\t.gen_vdev_spectral_enable = ath10k_wmi_op_gen_vdev_spectral_enable,\n\t.gen_peer_create = ath10k_wmi_op_gen_peer_create,\n\t.gen_peer_delete = ath10k_wmi_op_gen_peer_delete,\n\t.gen_peer_flush = ath10k_wmi_op_gen_peer_flush,\n\t.gen_peer_set_param = ath10k_wmi_op_gen_peer_set_param,\n\t.gen_set_psmode = ath10k_wmi_op_gen_set_psmode,\n\t.gen_set_sta_ps = ath10k_wmi_op_gen_set_sta_ps,\n\t.gen_set_ap_ps = ath10k_wmi_op_gen_set_ap_ps,\n\t.gen_scan_chan_list = ath10k_wmi_op_gen_scan_chan_list,\n\t.gen_beacon_dma = ath10k_wmi_op_gen_beacon_dma,\n\t.gen_pdev_set_wmm = ath10k_wmi_op_gen_pdev_set_wmm,\n\t.gen_request_stats = ath10k_wmi_op_gen_request_stats,\n\t.gen_force_fw_hang = ath10k_wmi_op_gen_force_fw_hang,\n\t.gen_mgmt_tx = ath10k_wmi_op_gen_mgmt_tx,\n\t.gen_dbglog_cfg = ath10k_wmi_op_gen_dbglog_cfg,\n\t.gen_pktlog_enable = ath10k_wmi_op_gen_pktlog_enable,\n\t.gen_pktlog_disable = ath10k_wmi_op_gen_pktlog_disable,\n\t.gen_pdev_set_quiet_mode = ath10k_wmi_op_gen_pdev_set_quiet_mode,\n\t.gen_addba_clear_resp = ath10k_wmi_op_gen_addba_clear_resp,\n\t.gen_addba_send = ath10k_wmi_op_gen_addba_send,\n\t.gen_addba_set_resp = ath10k_wmi_op_gen_addba_set_resp,\n\t.gen_delba_send = ath10k_wmi_op_gen_delba_send,\n\t.gen_pdev_get_tpc_config = ath10k_wmi_10_2_4_op_gen_pdev_get_tpc_config,\n\t.fw_stats_fill = ath10k_wmi_10x_op_fw_stats_fill,\n\t.gen_pdev_enable_adaptive_cca =\n\t\tath10k_wmi_op_gen_pdev_enable_adaptive_cca,\n\t.get_vdev_subtype = ath10k_wmi_10_2_4_op_get_vdev_subtype,\n\t.gen_bb_timing = ath10k_wmi_10_2_4_op_gen_bb_timing,\n\t \n\t \n\t \n\t \n};\n\nstatic const struct wmi_ops wmi_10_4_ops = {\n\t.rx = ath10k_wmi_10_4_op_rx,\n\t.map_svc = wmi_10_4_svc_map,\n\n\t.pull_fw_stats = ath10k_wmi_10_4_op_pull_fw_stats,\n\t.pull_scan = ath10k_wmi_op_pull_scan_ev,\n\t.pull_mgmt_rx = ath10k_wmi_10_4_op_pull_mgmt_rx_ev,\n\t.pull_ch_info = ath10k_wmi_10_4_op_pull_ch_info_ev,\n\t.pull_vdev_start = ath10k_wmi_op_pull_vdev_start_ev,\n\t.pull_peer_kick = ath10k_wmi_op_pull_peer_kick_ev,\n\t.pull_swba = ath10k_wmi_10_4_op_pull_swba_ev,\n\t.pull_phyerr_hdr = ath10k_wmi_10_4_op_pull_phyerr_ev_hdr,\n\t.pull_phyerr = ath10k_wmi_10_4_op_pull_phyerr_ev,\n\t.pull_svc_rdy = ath10k_wmi_main_op_pull_svc_rdy_ev,\n\t.pull_rdy = ath10k_wmi_op_pull_rdy_ev,\n\t.pull_roam_ev = ath10k_wmi_op_pull_roam_ev,\n\t.pull_dfs_status_ev = ath10k_wmi_10_4_op_pull_dfs_status_ev,\n\t.get_txbf_conf_scheme = ath10k_wmi_10_4_txbf_conf_scheme,\n\n\t.gen_pdev_suspend = ath10k_wmi_op_gen_pdev_suspend,\n\t.gen_pdev_resume = ath10k_wmi_op_gen_pdev_resume,\n\t.gen_pdev_set_base_macaddr = ath10k_wmi_op_gen_pdev_set_base_macaddr,\n\t.gen_pdev_set_rd = ath10k_wmi_10x_op_gen_pdev_set_rd,\n\t.gen_pdev_set_param = ath10k_wmi_op_gen_pdev_set_param,\n\t.gen_init = ath10k_wmi_10_4_op_gen_init,\n\t.gen_start_scan = ath10k_wmi_op_gen_start_scan,\n\t.gen_stop_scan = ath10k_wmi_op_gen_stop_scan,\n\t.gen_vdev_create = ath10k_wmi_op_gen_vdev_create,\n\t.gen_vdev_delete = ath10k_wmi_op_gen_vdev_delete,\n\t.gen_vdev_start = ath10k_wmi_op_gen_vdev_start,\n\t.gen_vdev_stop = ath10k_wmi_op_gen_vdev_stop,\n\t.gen_vdev_up = ath10k_wmi_op_gen_vdev_up,\n\t.gen_vdev_down = ath10k_wmi_op_gen_vdev_down,\n\t.gen_vdev_set_param = ath10k_wmi_op_gen_vdev_set_param,\n\t.gen_vdev_install_key = ath10k_wmi_op_gen_vdev_install_key,\n\t.gen_vdev_spectral_conf = ath10k_wmi_op_gen_vdev_spectral_conf,\n\t.gen_vdev_spectral_enable = ath10k_wmi_op_gen_vdev_spectral_enable,\n\t.gen_peer_create = ath10k_wmi_op_gen_peer_create,\n\t.gen_peer_delete = ath10k_wmi_op_gen_peer_delete,\n\t.gen_peer_flush = ath10k_wmi_op_gen_peer_flush,\n\t.gen_peer_set_param = ath10k_wmi_op_gen_peer_set_param,\n\t.gen_peer_assoc = ath10k_wmi_10_4_op_gen_peer_assoc,\n\t.gen_set_psmode = ath10k_wmi_op_gen_set_psmode,\n\t.gen_set_sta_ps = ath10k_wmi_op_gen_set_sta_ps,\n\t.gen_set_ap_ps = ath10k_wmi_op_gen_set_ap_ps,\n\t.gen_scan_chan_list = ath10k_wmi_op_gen_scan_chan_list,\n\t.gen_beacon_dma = ath10k_wmi_op_gen_beacon_dma,\n\t.gen_pdev_set_wmm = ath10k_wmi_op_gen_pdev_set_wmm,\n\t.gen_force_fw_hang = ath10k_wmi_op_gen_force_fw_hang,\n\t.gen_mgmt_tx = ath10k_wmi_op_gen_mgmt_tx,\n\t.gen_dbglog_cfg = ath10k_wmi_10_4_op_gen_dbglog_cfg,\n\t.gen_pktlog_enable = ath10k_wmi_op_gen_pktlog_enable,\n\t.gen_pktlog_disable = ath10k_wmi_op_gen_pktlog_disable,\n\t.gen_pdev_set_quiet_mode = ath10k_wmi_op_gen_pdev_set_quiet_mode,\n\t.gen_addba_clear_resp = ath10k_wmi_op_gen_addba_clear_resp,\n\t.gen_addba_send = ath10k_wmi_op_gen_addba_send,\n\t.gen_addba_set_resp = ath10k_wmi_op_gen_addba_set_resp,\n\t.gen_delba_send = ath10k_wmi_op_gen_delba_send,\n\t.fw_stats_fill = ath10k_wmi_10_4_op_fw_stats_fill,\n\t.ext_resource_config = ath10k_wmi_10_4_ext_resource_config,\n\t.gen_update_fw_tdls_state = ath10k_wmi_10_4_gen_update_fw_tdls_state,\n\t.gen_tdls_peer_update = ath10k_wmi_10_4_gen_tdls_peer_update,\n\t.gen_pdev_get_tpc_table_cmdid =\n\t\t\tath10k_wmi_10_4_op_gen_pdev_get_tpc_table_cmdid,\n\t.gen_radar_found = ath10k_wmi_10_4_gen_radar_found,\n\t.gen_per_peer_per_tid_cfg = ath10k_wmi_10_4_gen_per_peer_per_tid_cfg,\n\n\t \n\t.pull_echo_ev = ath10k_wmi_op_pull_echo_ev,\n\t.gen_request_stats = ath10k_wmi_op_gen_request_stats,\n\t.gen_pdev_get_temperature = ath10k_wmi_10_2_op_gen_pdev_get_temperature,\n\t.get_vdev_subtype = ath10k_wmi_10_4_op_get_vdev_subtype,\n\t.gen_pdev_bss_chan_info_req = ath10k_wmi_10_2_op_gen_pdev_bss_chan_info,\n\t.gen_echo = ath10k_wmi_op_gen_echo,\n\t.gen_pdev_get_tpc_config = ath10k_wmi_10_2_4_op_gen_pdev_get_tpc_config,\n};\n\nint ath10k_wmi_attach(struct ath10k *ar)\n{\n\tswitch (ar->running_fw->fw_file.wmi_op_version) {\n\tcase ATH10K_FW_WMI_OP_VERSION_10_4:\n\t\tar->wmi.ops = &wmi_10_4_ops;\n\t\tar->wmi.cmd = &wmi_10_4_cmd_map;\n\t\tar->wmi.vdev_param = &wmi_10_4_vdev_param_map;\n\t\tar->wmi.pdev_param = &wmi_10_4_pdev_param_map;\n\t\tar->wmi.peer_param = &wmi_peer_param_map;\n\t\tar->wmi.peer_flags = &wmi_10_2_peer_flags_map;\n\t\tar->wmi_key_cipher = wmi_key_cipher_suites;\n\t\tbreak;\n\tcase ATH10K_FW_WMI_OP_VERSION_10_2_4:\n\t\tar->wmi.cmd = &wmi_10_2_4_cmd_map;\n\t\tar->wmi.ops = &wmi_10_2_4_ops;\n\t\tar->wmi.vdev_param = &wmi_10_2_4_vdev_param_map;\n\t\tar->wmi.pdev_param = &wmi_10_2_4_pdev_param_map;\n\t\tar->wmi.peer_param = &wmi_peer_param_map;\n\t\tar->wmi.peer_flags = &wmi_10_2_peer_flags_map;\n\t\tar->wmi_key_cipher = wmi_key_cipher_suites;\n\t\tbreak;\n\tcase ATH10K_FW_WMI_OP_VERSION_10_2:\n\t\tar->wmi.cmd = &wmi_10_2_cmd_map;\n\t\tar->wmi.ops = &wmi_10_2_ops;\n\t\tar->wmi.vdev_param = &wmi_10x_vdev_param_map;\n\t\tar->wmi.pdev_param = &wmi_10x_pdev_param_map;\n\t\tar->wmi.peer_param = &wmi_peer_param_map;\n\t\tar->wmi.peer_flags = &wmi_10_2_peer_flags_map;\n\t\tar->wmi_key_cipher = wmi_key_cipher_suites;\n\t\tbreak;\n\tcase ATH10K_FW_WMI_OP_VERSION_10_1:\n\t\tar->wmi.cmd = &wmi_10x_cmd_map;\n\t\tar->wmi.ops = &wmi_10_1_ops;\n\t\tar->wmi.vdev_param = &wmi_10x_vdev_param_map;\n\t\tar->wmi.pdev_param = &wmi_10x_pdev_param_map;\n\t\tar->wmi.peer_param = &wmi_peer_param_map;\n\t\tar->wmi.peer_flags = &wmi_10x_peer_flags_map;\n\t\tar->wmi_key_cipher = wmi_key_cipher_suites;\n\t\tbreak;\n\tcase ATH10K_FW_WMI_OP_VERSION_MAIN:\n\t\tar->wmi.cmd = &wmi_cmd_map;\n\t\tar->wmi.ops = &wmi_ops;\n\t\tar->wmi.vdev_param = &wmi_vdev_param_map;\n\t\tar->wmi.pdev_param = &wmi_pdev_param_map;\n\t\tar->wmi.peer_param = &wmi_peer_param_map;\n\t\tar->wmi.peer_flags = &wmi_peer_flags_map;\n\t\tar->wmi_key_cipher = wmi_key_cipher_suites;\n\t\tbreak;\n\tcase ATH10K_FW_WMI_OP_VERSION_TLV:\n\t\tath10k_wmi_tlv_attach(ar);\n\t\tar->wmi_key_cipher = wmi_tlv_key_cipher_suites;\n\t\tbreak;\n\tcase ATH10K_FW_WMI_OP_VERSION_UNSET:\n\tcase ATH10K_FW_WMI_OP_VERSION_MAX:\n\t\tath10k_err(ar, \"unsupported WMI op version: %d\\n\",\n\t\t\t   ar->running_fw->fw_file.wmi_op_version);\n\t\treturn -EINVAL;\n\t}\n\n\tinit_completion(&ar->wmi.service_ready);\n\tinit_completion(&ar->wmi.unified_ready);\n\tinit_completion(&ar->wmi.barrier);\n\tinit_completion(&ar->wmi.radar_confirm);\n\n\tINIT_WORK(&ar->svc_rdy_work, ath10k_wmi_event_service_ready_work);\n\tINIT_WORK(&ar->radar_confirmation_work,\n\t\t  ath10k_radar_confirmation_work);\n\n\tif (test_bit(ATH10K_FW_FEATURE_MGMT_TX_BY_REF,\n\t\t     ar->running_fw->fw_file.fw_features)) {\n\t\tidr_init(&ar->wmi.mgmt_pending_tx);\n\t}\n\n\treturn 0;\n}\n\nvoid ath10k_wmi_free_host_mem(struct ath10k *ar)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < ar->wmi.num_mem_chunks; i++) {\n\t\tdma_free_coherent(ar->dev,\n\t\t\t\t  ar->wmi.mem_chunks[i].len,\n\t\t\t\t  ar->wmi.mem_chunks[i].vaddr,\n\t\t\t\t  ar->wmi.mem_chunks[i].paddr);\n\t}\n\n\tar->wmi.num_mem_chunks = 0;\n}\n\nstatic int ath10k_wmi_mgmt_tx_clean_up_pending(int msdu_id, void *ptr,\n\t\t\t\t\t       void *ctx)\n{\n\tstruct ath10k_mgmt_tx_pkt_addr *pkt_addr = ptr;\n\tstruct ath10k *ar = ctx;\n\tstruct sk_buff *msdu;\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"force cleanup mgmt msdu_id %u\\n\", msdu_id);\n\n\tmsdu = pkt_addr->vaddr;\n\tdma_unmap_single(ar->dev, pkt_addr->paddr,\n\t\t\t msdu->len, DMA_TO_DEVICE);\n\tieee80211_free_txskb(ar->hw, msdu);\n\n\treturn 0;\n}\n\nvoid ath10k_wmi_detach(struct ath10k *ar)\n{\n\tif (test_bit(ATH10K_FW_FEATURE_MGMT_TX_BY_REF,\n\t\t     ar->running_fw->fw_file.fw_features)) {\n\t\tspin_lock_bh(&ar->data_lock);\n\t\tidr_for_each(&ar->wmi.mgmt_pending_tx,\n\t\t\t     ath10k_wmi_mgmt_tx_clean_up_pending, ar);\n\t\tidr_destroy(&ar->wmi.mgmt_pending_tx);\n\t\tspin_unlock_bh(&ar->data_lock);\n\t}\n\n\tcancel_work_sync(&ar->svc_rdy_work);\n\tdev_kfree_skb(ar->svc_rdy_skb);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}