{
  "module_name": "txrx.c",
  "hash_id": "9f2a4ce2a5679f46ef4f6d86a23c80314e5cd1e84ea2f80d62f958df367a5d24",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath10k/txrx.c",
  "human_readable_source": "\n \n\n#include \"core.h\"\n#include \"txrx.h\"\n#include \"htt.h\"\n#include \"mac.h\"\n#include \"debug.h\"\n\nstatic void ath10k_report_offchan_tx(struct ath10k *ar, struct sk_buff *skb)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\n\tif (likely(!(info->flags & IEEE80211_TX_CTL_TX_OFFCHAN)))\n\t\treturn;\n\n\tif (ath10k_mac_tx_frm_has_freq(ar))\n\t\treturn;\n\n\t \n\tspin_lock_bh(&ar->data_lock);\n\tif (ar->offchan_tx_skb != skb) {\n\t\tath10k_warn(ar, \"completed old offchannel frame\\n\");\n\t\tgoto out;\n\t}\n\n\tcomplete(&ar->offchan_tx_completed);\n\tar->offchan_tx_skb = NULL;  \n\n\tath10k_dbg(ar, ATH10K_DBG_HTT, \"completed offchannel skb %pK\\n\", skb);\nout:\n\tspin_unlock_bh(&ar->data_lock);\n}\n\nint ath10k_txrx_tx_unref(struct ath10k_htt *htt,\n\t\t\t const struct htt_tx_done *tx_done)\n{\n\tstruct ieee80211_tx_status status;\n\tstruct ath10k *ar = htt->ar;\n\tstruct device *dev = ar->dev;\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211_txq *txq;\n\tstruct ath10k_skb_cb *skb_cb;\n\tstruct ath10k_txq *artxq;\n\tstruct sk_buff *msdu;\n\tu8 flags;\n\n\tath10k_dbg(ar, ATH10K_DBG_HTT,\n\t\t   \"htt tx completion msdu_id %u status %d\\n\",\n\t\t   tx_done->msdu_id, tx_done->status);\n\n\tif (tx_done->msdu_id >= htt->max_num_pending_tx) {\n\t\tath10k_warn(ar, \"warning: msdu_id %d too big, ignoring\\n\",\n\t\t\t    tx_done->msdu_id);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_bh(&htt->tx_lock);\n\tmsdu = idr_find(&htt->pending_tx, tx_done->msdu_id);\n\tif (!msdu) {\n\t\tath10k_warn(ar, \"received tx completion for invalid msdu_id: %d\\n\",\n\t\t\t    tx_done->msdu_id);\n\t\tspin_unlock_bh(&htt->tx_lock);\n\t\treturn -ENOENT;\n\t}\n\n\tskb_cb = ATH10K_SKB_CB(msdu);\n\ttxq = skb_cb->txq;\n\n\tif (txq) {\n\t\tartxq = (void *)txq->drv_priv;\n\t\tartxq->num_fw_queued--;\n\t}\n\n\tflags = skb_cb->flags;\n\tath10k_htt_tx_free_msdu_id(htt, tx_done->msdu_id);\n\tath10k_htt_tx_dec_pending(htt);\n\tspin_unlock_bh(&htt->tx_lock);\n\n\trcu_read_lock();\n\tif (txq && txq->sta && skb_cb->airtime_est)\n\t\tieee80211_sta_register_airtime(txq->sta, txq->tid,\n\t\t\t\t\t       skb_cb->airtime_est, 0);\n\trcu_read_unlock();\n\n\tif (ar->bus_param.dev_type != ATH10K_DEV_TYPE_HL)\n\t\tdma_unmap_single(dev, skb_cb->paddr, msdu->len, DMA_TO_DEVICE);\n\n\tath10k_report_offchan_tx(htt->ar, msdu);\n\n\tinfo = IEEE80211_SKB_CB(msdu);\n\tmemset(&info->status, 0, sizeof(info->status));\n\tinfo->status.rates[0].idx = -1;\n\n\ttrace_ath10k_txrx_tx_unref(ar, tx_done->msdu_id);\n\n\tif (!(info->flags & IEEE80211_TX_CTL_NO_ACK) &&\n\t    !(flags & ATH10K_SKB_F_NOACK_TID))\n\t\tinfo->flags |= IEEE80211_TX_STAT_ACK;\n\n\tif (tx_done->status == HTT_TX_COMPL_STATE_NOACK)\n\t\tinfo->flags &= ~IEEE80211_TX_STAT_ACK;\n\n\tif ((tx_done->status == HTT_TX_COMPL_STATE_ACK) &&\n\t    ((info->flags & IEEE80211_TX_CTL_NO_ACK) ||\n\t    (flags & ATH10K_SKB_F_NOACK_TID)))\n\t\tinfo->flags |= IEEE80211_TX_STAT_NOACK_TRANSMITTED;\n\n\tif (tx_done->status == HTT_TX_COMPL_STATE_DISCARD) {\n\t\tif ((info->flags & IEEE80211_TX_CTL_NO_ACK) ||\n\t\t    (flags & ATH10K_SKB_F_NOACK_TID))\n\t\t\tinfo->flags &= ~IEEE80211_TX_STAT_NOACK_TRANSMITTED;\n\t\telse\n\t\t\tinfo->flags &= ~IEEE80211_TX_STAT_ACK;\n\t}\n\n\tif (tx_done->status == HTT_TX_COMPL_STATE_ACK &&\n\t    tx_done->ack_rssi != ATH10K_INVALID_RSSI) {\n\t\tinfo->status.ack_signal = ATH10K_DEFAULT_NOISE_FLOOR +\n\t\t\t\t\t\ttx_done->ack_rssi;\n\t\tinfo->status.flags |= IEEE80211_TX_STATUS_ACK_SIGNAL_VALID;\n\t}\n\n\tmemset(&status, 0, sizeof(status));\n\tstatus.skb = msdu;\n\tstatus.info = info;\n\n\trcu_read_lock();\n\n\tif (txq)\n\t\tstatus.sta = txq->sta;\n\n\tieee80211_tx_status_ext(htt->ar->hw, &status);\n\n\trcu_read_unlock();\n\n\t \n\n\treturn 0;\n}\n\nstruct ath10k_peer *ath10k_peer_find(struct ath10k *ar, int vdev_id,\n\t\t\t\t     const u8 *addr)\n{\n\tstruct ath10k_peer *peer;\n\n\tlockdep_assert_held(&ar->data_lock);\n\n\tlist_for_each_entry(peer, &ar->peers, list) {\n\t\tif (peer->vdev_id != vdev_id)\n\t\t\tcontinue;\n\t\tif (!ether_addr_equal(peer->addr, addr))\n\t\t\tcontinue;\n\n\t\treturn peer;\n\t}\n\n\treturn NULL;\n}\n\nstruct ath10k_peer *ath10k_peer_find_by_id(struct ath10k *ar, int peer_id)\n{\n\tstruct ath10k_peer *peer;\n\n\tif (peer_id >= BITS_PER_TYPE(peer->peer_ids))\n\t\treturn NULL;\n\n\tlockdep_assert_held(&ar->data_lock);\n\n\tlist_for_each_entry(peer, &ar->peers, list)\n\t\tif (test_bit(peer_id, peer->peer_ids))\n\t\t\treturn peer;\n\n\treturn NULL;\n}\n\nstatic int ath10k_wait_for_peer_common(struct ath10k *ar, int vdev_id,\n\t\t\t\t       const u8 *addr, bool expect_mapped)\n{\n\tlong time_left;\n\n\ttime_left = wait_event_timeout(ar->peer_mapping_wq, ({\n\t\t\tbool mapped;\n\n\t\t\tspin_lock_bh(&ar->data_lock);\n\t\t\tmapped = !!ath10k_peer_find(ar, vdev_id, addr);\n\t\t\tspin_unlock_bh(&ar->data_lock);\n\n\t\t\t(mapped == expect_mapped ||\n\t\t\t test_bit(ATH10K_FLAG_CRASH_FLUSH, &ar->dev_flags));\n\t\t}), 3 * HZ);\n\n\tif (time_left == 0)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nint ath10k_wait_for_peer_created(struct ath10k *ar, int vdev_id, const u8 *addr)\n{\n\treturn ath10k_wait_for_peer_common(ar, vdev_id, addr, true);\n}\n\nint ath10k_wait_for_peer_deleted(struct ath10k *ar, int vdev_id, const u8 *addr)\n{\n\treturn ath10k_wait_for_peer_common(ar, vdev_id, addr, false);\n}\n\nvoid ath10k_peer_map_event(struct ath10k_htt *htt,\n\t\t\t   struct htt_peer_map_event *ev)\n{\n\tstruct ath10k *ar = htt->ar;\n\tstruct ath10k_peer *peer;\n\n\tif (ev->peer_id >= ATH10K_MAX_NUM_PEER_IDS) {\n\t\tath10k_warn(ar,\n\t\t\t    \"received htt peer map event with idx out of bounds: %u\\n\",\n\t\t\t    ev->peer_id);\n\t\treturn;\n\t}\n\n\tspin_lock_bh(&ar->data_lock);\n\tpeer = ath10k_peer_find(ar, ev->vdev_id, ev->addr);\n\tif (!peer) {\n\t\tpeer = kzalloc(sizeof(*peer), GFP_ATOMIC);\n\t\tif (!peer)\n\t\t\tgoto exit;\n\n\t\tpeer->vdev_id = ev->vdev_id;\n\t\tether_addr_copy(peer->addr, ev->addr);\n\t\tlist_add(&peer->list, &ar->peers);\n\t\twake_up(&ar->peer_mapping_wq);\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_HTT, \"htt peer map vdev %d peer %pM id %d\\n\",\n\t\t   ev->vdev_id, ev->addr, ev->peer_id);\n\n\tWARN_ON(ar->peer_map[ev->peer_id] && (ar->peer_map[ev->peer_id] != peer));\n\tar->peer_map[ev->peer_id] = peer;\n\tset_bit(ev->peer_id, peer->peer_ids);\nexit:\n\tspin_unlock_bh(&ar->data_lock);\n}\n\nvoid ath10k_peer_unmap_event(struct ath10k_htt *htt,\n\t\t\t     struct htt_peer_unmap_event *ev)\n{\n\tstruct ath10k *ar = htt->ar;\n\tstruct ath10k_peer *peer;\n\n\tif (ev->peer_id >= ATH10K_MAX_NUM_PEER_IDS) {\n\t\tath10k_warn(ar,\n\t\t\t    \"received htt peer unmap event with idx out of bounds: %u\\n\",\n\t\t\t    ev->peer_id);\n\t\treturn;\n\t}\n\n\tspin_lock_bh(&ar->data_lock);\n\tpeer = ath10k_peer_find_by_id(ar, ev->peer_id);\n\tif (!peer) {\n\t\tath10k_warn(ar, \"peer-unmap-event: unknown peer id %d\\n\",\n\t\t\t    ev->peer_id);\n\t\tgoto exit;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_HTT, \"htt peer unmap vdev %d peer %pM id %d\\n\",\n\t\t   peer->vdev_id, peer->addr, ev->peer_id);\n\n\tar->peer_map[ev->peer_id] = NULL;\n\tclear_bit(ev->peer_id, peer->peer_ids);\n\n\tif (bitmap_empty(peer->peer_ids, ATH10K_MAX_NUM_PEER_IDS)) {\n\t\tlist_del(&peer->list);\n\t\tkfree(peer);\n\t\twake_up(&ar->peer_mapping_wq);\n\t}\n\nexit:\n\tspin_unlock_bh(&ar->data_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}