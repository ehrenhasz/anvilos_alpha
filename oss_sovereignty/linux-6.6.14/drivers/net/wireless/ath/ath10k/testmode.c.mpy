{
  "module_name": "testmode.c",
  "hash_id": "1cc108f26a699041fbb6b0a35541777a88456f2372e9abf593944c8dc8034408",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath10k/testmode.c",
  "human_readable_source": "\n \n\n#include \"testmode.h\"\n\n#include <net/netlink.h>\n#include <linux/firmware.h>\n\n#include \"debug.h\"\n#include \"wmi.h\"\n#include \"hif.h\"\n#include \"hw.h\"\n#include \"core.h\"\n\n#include \"testmode_i.h\"\n\nstatic const struct nla_policy ath10k_tm_policy[ATH10K_TM_ATTR_MAX + 1] = {\n\t[ATH10K_TM_ATTR_CMD]\t\t= { .type = NLA_U32 },\n\t[ATH10K_TM_ATTR_DATA]\t\t= { .type = NLA_BINARY,\n\t\t\t\t\t    .len = ATH10K_TM_DATA_MAX_LEN },\n\t[ATH10K_TM_ATTR_WMI_CMDID]\t= { .type = NLA_U32 },\n\t[ATH10K_TM_ATTR_VERSION_MAJOR]\t= { .type = NLA_U32 },\n\t[ATH10K_TM_ATTR_VERSION_MINOR]\t= { .type = NLA_U32 },\n};\n\n \nbool ath10k_tm_event_wmi(struct ath10k *ar, u32 cmd_id, struct sk_buff *skb)\n{\n\tstruct sk_buff *nl_skb;\n\tbool consumed;\n\tint ret;\n\n\tath10k_dbg(ar, ATH10K_DBG_TESTMODE,\n\t\t   \"testmode event wmi cmd_id %d skb %pK skb->len %d\\n\",\n\t\t   cmd_id, skb, skb->len);\n\n\tath10k_dbg_dump(ar, ATH10K_DBG_TESTMODE, NULL, \"\", skb->data, skb->len);\n\n\tspin_lock_bh(&ar->data_lock);\n\n\tif (!ar->testmode.utf_monitor) {\n\t\tconsumed = false;\n\t\tgoto out;\n\t}\n\n\t \n\tconsumed = true;\n\n\tnl_skb = cfg80211_testmode_alloc_event_skb(ar->hw->wiphy,\n\t\t\t\t\t\t   2 * sizeof(u32) + skb->len,\n\t\t\t\t\t\t   GFP_ATOMIC);\n\tif (!nl_skb) {\n\t\tath10k_warn(ar,\n\t\t\t    \"failed to allocate skb for testmode wmi event\\n\");\n\t\tgoto out;\n\t}\n\n\tret = nla_put_u32(nl_skb, ATH10K_TM_ATTR_CMD, ATH10K_TM_CMD_WMI);\n\tif (ret) {\n\t\tath10k_warn(ar,\n\t\t\t    \"failed to put testmode wmi event cmd attribute: %d\\n\",\n\t\t\t    ret);\n\t\tkfree_skb(nl_skb);\n\t\tgoto out;\n\t}\n\n\tret = nla_put_u32(nl_skb, ATH10K_TM_ATTR_WMI_CMDID, cmd_id);\n\tif (ret) {\n\t\tath10k_warn(ar,\n\t\t\t    \"failed to put testmode wmi event cmd_id: %d\\n\",\n\t\t\t    ret);\n\t\tkfree_skb(nl_skb);\n\t\tgoto out;\n\t}\n\n\tret = nla_put(nl_skb, ATH10K_TM_ATTR_DATA, skb->len, skb->data);\n\tif (ret) {\n\t\tath10k_warn(ar,\n\t\t\t    \"failed to copy skb to testmode wmi event: %d\\n\",\n\t\t\t    ret);\n\t\tkfree_skb(nl_skb);\n\t\tgoto out;\n\t}\n\n\tcfg80211_testmode_event(nl_skb, GFP_ATOMIC);\n\nout:\n\tspin_unlock_bh(&ar->data_lock);\n\n\treturn consumed;\n}\n\nstatic int ath10k_tm_cmd_get_version(struct ath10k *ar, struct nlattr *tb[])\n{\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tath10k_dbg(ar, ATH10K_DBG_TESTMODE,\n\t\t   \"testmode cmd get version_major %d version_minor %d\\n\",\n\t\t   ATH10K_TESTMODE_VERSION_MAJOR,\n\t\t   ATH10K_TESTMODE_VERSION_MINOR);\n\n\tskb = cfg80211_testmode_alloc_reply_skb(ar->hw->wiphy,\n\t\t\t\t\t\tnla_total_size(sizeof(u32)));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tret = nla_put_u32(skb, ATH10K_TM_ATTR_VERSION_MAJOR,\n\t\t\t  ATH10K_TESTMODE_VERSION_MAJOR);\n\tif (ret) {\n\t\tkfree_skb(skb);\n\t\treturn ret;\n\t}\n\n\tret = nla_put_u32(skb, ATH10K_TM_ATTR_VERSION_MINOR,\n\t\t\t  ATH10K_TESTMODE_VERSION_MINOR);\n\tif (ret) {\n\t\tkfree_skb(skb);\n\t\treturn ret;\n\t}\n\n\tret = nla_put_u32(skb, ATH10K_TM_ATTR_WMI_OP_VERSION,\n\t\t\t  ar->normal_mode_fw.fw_file.wmi_op_version);\n\tif (ret) {\n\t\tkfree_skb(skb);\n\t\treturn ret;\n\t}\n\n\treturn cfg80211_testmode_reply(skb);\n}\n\nstatic int ath10k_tm_fetch_utf_firmware_api_1(struct ath10k *ar,\n\t\t\t\t\t      struct ath10k_fw_file *fw_file)\n{\n\tchar filename[100];\n\tint ret;\n\n\tsnprintf(filename, sizeof(filename), \"%s/%s\",\n\t\t ar->hw_params.fw.dir, ATH10K_FW_UTF_FILE);\n\n\t \n\tret = firmware_request_nowarn(&fw_file->firmware, filename, ar->dev);\n\tath10k_dbg(ar, ATH10K_DBG_TESTMODE, \"testmode fw request '%s': %d\\n\",\n\t\t   filename, ret);\n\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to retrieve utf firmware '%s': %d\\n\",\n\t\t\t    filename, ret);\n\t\treturn ret;\n\t}\n\n\t \n\n\tfw_file->wmi_op_version = ATH10K_FW_WMI_OP_VERSION_10_1;\n\tfw_file->htt_op_version = ATH10K_FW_HTT_OP_VERSION_10_1;\n\tfw_file->firmware_data = fw_file->firmware->data;\n\tfw_file->firmware_len = fw_file->firmware->size;\n\n\treturn 0;\n}\n\nstatic int ath10k_tm_fetch_firmware(struct ath10k *ar)\n{\n\tstruct ath10k_fw_components *utf_mode_fw;\n\tint ret;\n\tchar fw_name[100];\n\tint fw_api2 = 2;\n\n\tswitch (ar->hif.bus) {\n\tcase ATH10K_BUS_SDIO:\n\tcase ATH10K_BUS_USB:\n\t\tscnprintf(fw_name, sizeof(fw_name), \"%s-%s-%d.bin\",\n\t\t\t  ATH10K_FW_UTF_FILE_BASE, ath10k_bus_str(ar->hif.bus),\n\t\t\t  fw_api2);\n\t\tbreak;\n\tdefault:\n\t\tscnprintf(fw_name, sizeof(fw_name), \"%s-%d.bin\",\n\t\t\t  ATH10K_FW_UTF_FILE_BASE, fw_api2);\n\t\tbreak;\n\t}\n\n\tret = ath10k_core_fetch_firmware_api_n(ar, fw_name,\n\t\t\t\t\t       &ar->testmode.utf_mode_fw.fw_file);\n\tif (ret == 0) {\n\t\tath10k_dbg(ar, ATH10K_DBG_TESTMODE, \"testmode using fw utf api 2\");\n\t\tgoto out;\n\t}\n\n\tret = ath10k_tm_fetch_utf_firmware_api_1(ar, &ar->testmode.utf_mode_fw.fw_file);\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to fetch utf firmware binary: %d\", ret);\n\t\treturn ret;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_TESTMODE, \"testmode using utf api 1\");\n\nout:\n\tutf_mode_fw = &ar->testmode.utf_mode_fw;\n\n\t \n\tutf_mode_fw->board_data = ar->normal_mode_fw.board_data;\n\tutf_mode_fw->board_len = ar->normal_mode_fw.board_len;\n\n\tif (!utf_mode_fw->fw_file.otp_data) {\n\t\tath10k_info(ar, \"utf.bin didn't contain otp binary, taking it from the normal mode firmware\");\n\t\tutf_mode_fw->fw_file.otp_data = ar->normal_mode_fw.fw_file.otp_data;\n\t\tutf_mode_fw->fw_file.otp_len = ar->normal_mode_fw.fw_file.otp_len;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_tm_cmd_utf_start(struct ath10k *ar, struct nlattr *tb[])\n{\n\tconst char *ver;\n\tint ret;\n\n\tath10k_dbg(ar, ATH10K_DBG_TESTMODE, \"testmode cmd utf start\\n\");\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (ar->state == ATH10K_STATE_UTF) {\n\t\tret = -EALREADY;\n\t\tgoto err;\n\t}\n\n\t \n\tif (ar->state != ATH10K_STATE_OFF) {\n\t\tret = -EBUSY;\n\t\tgoto err;\n\t}\n\n\tif (WARN_ON(ar->testmode.utf_mode_fw.fw_file.firmware != NULL)) {\n\t\t \n\t\tret = -EEXIST;\n\t\tgoto err;\n\t}\n\n\tret = ath10k_tm_fetch_firmware(ar);\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to fetch UTF firmware: %d\", ret);\n\t\tgoto err;\n\t}\n\n\tif (ar->testmode.utf_mode_fw.fw_file.codeswap_data &&\n\t    ar->testmode.utf_mode_fw.fw_file.codeswap_len) {\n\t\tret = ath10k_swap_code_seg_init(ar,\n\t\t\t\t\t\t&ar->testmode.utf_mode_fw.fw_file);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar,\n\t\t\t\t    \"failed to init utf code swap segment: %d\\n\",\n\t\t\t\t    ret);\n\t\t\tgoto err_release_utf_mode_fw;\n\t\t}\n\t}\n\n\tspin_lock_bh(&ar->data_lock);\n\tar->testmode.utf_monitor = true;\n\tspin_unlock_bh(&ar->data_lock);\n\n\tath10k_dbg(ar, ATH10K_DBG_TESTMODE, \"testmode wmi version %d\\n\",\n\t\t   ar->testmode.utf_mode_fw.fw_file.wmi_op_version);\n\n\tret = ath10k_hif_power_up(ar, ATH10K_FIRMWARE_MODE_UTF);\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to power up hif (testmode): %d\\n\", ret);\n\t\tar->state = ATH10K_STATE_OFF;\n\t\tgoto err_release_utf_mode_fw;\n\t}\n\n\tret = ath10k_core_start(ar, ATH10K_FIRMWARE_MODE_UTF,\n\t\t\t\t&ar->testmode.utf_mode_fw);\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to start core (testmode): %d\\n\", ret);\n\t\tar->state = ATH10K_STATE_OFF;\n\t\tgoto err_power_down;\n\t}\n\n\tar->state = ATH10K_STATE_UTF;\n\n\tif (strlen(ar->testmode.utf_mode_fw.fw_file.fw_version) > 0)\n\t\tver = ar->testmode.utf_mode_fw.fw_file.fw_version;\n\telse\n\t\tver = \"API 1\";\n\n\tath10k_info(ar, \"UTF firmware %s started\\n\", ver);\n\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn 0;\n\nerr_power_down:\n\tath10k_hif_power_down(ar);\n\nerr_release_utf_mode_fw:\n\tif (ar->testmode.utf_mode_fw.fw_file.codeswap_data &&\n\t    ar->testmode.utf_mode_fw.fw_file.codeswap_len)\n\t\tath10k_swap_code_seg_release(ar,\n\t\t\t\t\t     &ar->testmode.utf_mode_fw.fw_file);\n\n\trelease_firmware(ar->testmode.utf_mode_fw.fw_file.firmware);\n\tar->testmode.utf_mode_fw.fw_file.firmware = NULL;\n\nerr:\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn ret;\n}\n\nstatic void __ath10k_tm_cmd_utf_stop(struct ath10k *ar)\n{\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tath10k_core_stop(ar);\n\tath10k_hif_power_down(ar);\n\n\tspin_lock_bh(&ar->data_lock);\n\n\tar->testmode.utf_monitor = false;\n\n\tspin_unlock_bh(&ar->data_lock);\n\n\tif (ar->testmode.utf_mode_fw.fw_file.codeswap_data &&\n\t    ar->testmode.utf_mode_fw.fw_file.codeswap_len)\n\t\tath10k_swap_code_seg_release(ar,\n\t\t\t\t\t     &ar->testmode.utf_mode_fw.fw_file);\n\n\trelease_firmware(ar->testmode.utf_mode_fw.fw_file.firmware);\n\tar->testmode.utf_mode_fw.fw_file.firmware = NULL;\n\n\tar->state = ATH10K_STATE_OFF;\n}\n\nstatic int ath10k_tm_cmd_utf_stop(struct ath10k *ar, struct nlattr *tb[])\n{\n\tint ret;\n\n\tath10k_dbg(ar, ATH10K_DBG_TESTMODE, \"testmode cmd utf stop\\n\");\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (ar->state != ATH10K_STATE_UTF) {\n\t\tret = -ENETDOWN;\n\t\tgoto out;\n\t}\n\n\t__ath10k_tm_cmd_utf_stop(ar);\n\n\tret = 0;\n\n\tath10k_info(ar, \"UTF firmware stopped\\n\");\n\nout:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic int ath10k_tm_cmd_wmi(struct ath10k *ar, struct nlattr *tb[])\n{\n\tstruct sk_buff *skb;\n\tint ret, buf_len;\n\tu32 cmd_id;\n\tvoid *buf;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (ar->state != ATH10K_STATE_UTF) {\n\t\tret = -ENETDOWN;\n\t\tgoto out;\n\t}\n\n\tif (!tb[ATH10K_TM_ATTR_DATA]) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!tb[ATH10K_TM_ATTR_WMI_CMDID]) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbuf = nla_data(tb[ATH10K_TM_ATTR_DATA]);\n\tbuf_len = nla_len(tb[ATH10K_TM_ATTR_DATA]);\n\tcmd_id = nla_get_u32(tb[ATH10K_TM_ATTR_WMI_CMDID]);\n\n\tath10k_dbg(ar, ATH10K_DBG_TESTMODE,\n\t\t   \"testmode cmd wmi cmd_id %d buf %pK buf_len %d\\n\",\n\t\t   cmd_id, buf, buf_len);\n\n\tath10k_dbg_dump(ar, ATH10K_DBG_TESTMODE, NULL, \"\", buf, buf_len);\n\n\tskb = ath10k_wmi_alloc_skb(ar, buf_len);\n\tif (!skb) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmemcpy(skb->data, buf, buf_len);\n\n\tret = ath10k_wmi_cmd_send(ar, skb, cmd_id);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to transmit wmi command (testmode): %d\\n\",\n\t\t\t    ret);\n\t\tgoto out;\n\t}\n\n\tret = 0;\n\nout:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nint ath10k_tm_cmd(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t  void *data, int len)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct nlattr *tb[ATH10K_TM_ATTR_MAX + 1];\n\tint ret;\n\n\tret = nla_parse_deprecated(tb, ATH10K_TM_ATTR_MAX, data, len,\n\t\t\t\t   ath10k_tm_policy, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!tb[ATH10K_TM_ATTR_CMD])\n\t\treturn -EINVAL;\n\n\tswitch (nla_get_u32(tb[ATH10K_TM_ATTR_CMD])) {\n\tcase ATH10K_TM_CMD_GET_VERSION:\n\t\treturn ath10k_tm_cmd_get_version(ar, tb);\n\tcase ATH10K_TM_CMD_UTF_START:\n\t\treturn ath10k_tm_cmd_utf_start(ar, tb);\n\tcase ATH10K_TM_CMD_UTF_STOP:\n\t\treturn ath10k_tm_cmd_utf_stop(ar, tb);\n\tcase ATH10K_TM_CMD_WMI:\n\t\treturn ath10k_tm_cmd_wmi(ar, tb);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nvoid ath10k_testmode_destroy(struct ath10k *ar)\n{\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (ar->state != ATH10K_STATE_UTF) {\n\t\t \n\t\tgoto out;\n\t}\n\n\t__ath10k_tm_cmd_utf_stop(ar);\n\nout:\n\tmutex_unlock(&ar->conf_mutex);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}