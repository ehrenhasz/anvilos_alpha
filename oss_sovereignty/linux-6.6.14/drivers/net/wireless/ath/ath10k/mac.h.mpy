{
  "module_name": "mac.h",
  "hash_id": "ed972ba940d6336da93eaee5a54cb4dec7f217ea41bdd52b67de397c20efdbaf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath10k/mac.h",
  "human_readable_source": " \n \n\n#ifndef _MAC_H_\n#define _MAC_H_\n\n#include <net/mac80211.h>\n#include \"core.h\"\n\n#define WEP_KEYID_SHIFT 6\n\nenum wmi_tlv_tx_pause_id;\nenum wmi_tlv_tx_pause_action;\n\nstruct ath10k_generic_iter {\n\tstruct ath10k *ar;\n\tint ret;\n};\n\nstruct rfc1042_hdr {\n\tu8 llc_dsap;\n\tu8 llc_ssap;\n\tu8 llc_ctrl;\n\tu8 snap_oui[3];\n\t__be16 snap_type;\n} __packed;\n\nstruct ath10k *ath10k_mac_create(size_t priv_size);\nvoid ath10k_mac_destroy(struct ath10k *ar);\nint ath10k_mac_register(struct ath10k *ar);\nvoid ath10k_mac_unregister(struct ath10k *ar);\nstruct ath10k_vif *ath10k_get_arvif(struct ath10k *ar, u32 vdev_id);\nvoid __ath10k_scan_finish(struct ath10k *ar);\nvoid ath10k_scan_finish(struct ath10k *ar);\nvoid ath10k_scan_timeout_work(struct work_struct *work);\nvoid ath10k_offchan_tx_purge(struct ath10k *ar);\nvoid ath10k_offchan_tx_work(struct work_struct *work);\nvoid ath10k_mgmt_over_wmi_tx_purge(struct ath10k *ar);\nvoid ath10k_mgmt_over_wmi_tx_work(struct work_struct *work);\nvoid ath10k_halt(struct ath10k *ar);\nvoid ath10k_mac_vif_beacon_free(struct ath10k_vif *arvif);\nvoid ath10k_drain_tx(struct ath10k *ar);\nbool ath10k_mac_is_peer_wep_key_set(struct ath10k *ar, const u8 *addr,\n\t\t\t\t    u8 keyidx);\nint ath10k_mac_vif_chan(struct ieee80211_vif *vif,\n\t\t\tstruct cfg80211_chan_def *def);\n\nvoid ath10k_mac_handle_beacon(struct ath10k *ar, struct sk_buff *skb);\nvoid ath10k_mac_handle_beacon_miss(struct ath10k *ar, u32 vdev_id);\nvoid ath10k_mac_handle_tx_pause_vdev(struct ath10k *ar, u32 vdev_id,\n\t\t\t\t     enum wmi_tlv_tx_pause_id pause_id,\n\t\t\t\t     enum wmi_tlv_tx_pause_action action);\n\nu8 ath10k_mac_hw_rate_to_idx(const struct ieee80211_supported_band *sband,\n\t\t\t     u8 hw_rate, bool cck);\nu8 ath10k_mac_bitrate_to_idx(const struct ieee80211_supported_band *sband,\n\t\t\t     u32 bitrate);\n\nvoid ath10k_mac_tx_lock(struct ath10k *ar, int reason);\nvoid ath10k_mac_tx_unlock(struct ath10k *ar, int reason);\nvoid ath10k_mac_vif_tx_lock(struct ath10k_vif *arvif, int reason);\nvoid ath10k_mac_vif_tx_unlock(struct ath10k_vif *arvif, int reason);\nbool ath10k_mac_tx_frm_has_freq(struct ath10k *ar);\nvoid ath10k_mac_tx_push_pending(struct ath10k *ar);\nint ath10k_mac_tx_push_txq(struct ieee80211_hw *hw,\n\t\t\t   struct ieee80211_txq *txq);\nstruct ieee80211_txq *ath10k_mac_txq_lookup(struct ath10k *ar,\n\t\t\t\t\t    u16 peer_id,\n\t\t\t\t\t    u8 tid);\nint ath10k_mac_ext_resource_config(struct ath10k *ar, u32 val);\nvoid ath10k_mac_wait_tx_complete(struct ath10k *ar);\nint ath10k_mac_rfkill_enable_radio(struct ath10k *ar, bool enable);\n\nstatic inline void ath10k_tx_h_seq_no(struct ieee80211_vif *vif,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\n\tif (info->flags  & IEEE80211_TX_CTL_ASSIGN_SEQ) {\n\t\tif (arvif->tx_seq_no == 0)\n\t\t\tarvif->tx_seq_no = 0x1000;\n\n\t\tif (info->flags & IEEE80211_TX_CTL_FIRST_FRAGMENT)\n\t\t\tarvif->tx_seq_no += 0x10;\n\t\thdr->seq_ctrl &= cpu_to_le16(IEEE80211_SCTL_FRAG);\n\t\thdr->seq_ctrl |= cpu_to_le16(arvif->tx_seq_no);\n\t}\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}