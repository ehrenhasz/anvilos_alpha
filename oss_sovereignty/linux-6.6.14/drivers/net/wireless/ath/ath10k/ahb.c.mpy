{
  "module_name": "ahb.c",
  "hash_id": "ba751f1c98a989b679c22f7eb2ef2ba15c0d0e52a6afc057f7814ce5cacf26a9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath10k/ahb.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/clk.h>\n#include <linux/reset.h>\n#include \"core.h\"\n#include \"debug.h\"\n#include \"pci.h\"\n#include \"ahb.h\"\n\nstatic const struct of_device_id ath10k_ahb_of_match[] = {\n\t{ .compatible = \"qcom,ipq4019-wifi\",\n\t  .data = (void *)ATH10K_HW_QCA4019\n\t},\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(of, ath10k_ahb_of_match);\n\n#define QCA4019_SRAM_ADDR      0x000C0000\n#define QCA4019_SRAM_LEN       0x00040000  \n\nstatic inline struct ath10k_ahb *ath10k_ahb_priv(struct ath10k *ar)\n{\n\treturn &ath10k_pci_priv(ar)->ahb[0];\n}\n\nstatic void ath10k_ahb_write32(struct ath10k *ar, u32 offset, u32 value)\n{\n\tstruct ath10k_ahb *ar_ahb = ath10k_ahb_priv(ar);\n\n\tiowrite32(value, ar_ahb->mem + offset);\n}\n\nstatic u32 ath10k_ahb_read32(struct ath10k *ar, u32 offset)\n{\n\tstruct ath10k_ahb *ar_ahb = ath10k_ahb_priv(ar);\n\n\treturn ioread32(ar_ahb->mem + offset);\n}\n\nstatic u32 ath10k_ahb_gcc_read32(struct ath10k *ar, u32 offset)\n{\n\tstruct ath10k_ahb *ar_ahb = ath10k_ahb_priv(ar);\n\n\treturn ioread32(ar_ahb->gcc_mem + offset);\n}\n\nstatic void ath10k_ahb_tcsr_write32(struct ath10k *ar, u32 offset, u32 value)\n{\n\tstruct ath10k_ahb *ar_ahb = ath10k_ahb_priv(ar);\n\n\tiowrite32(value, ar_ahb->tcsr_mem + offset);\n}\n\nstatic u32 ath10k_ahb_tcsr_read32(struct ath10k *ar, u32 offset)\n{\n\tstruct ath10k_ahb *ar_ahb = ath10k_ahb_priv(ar);\n\n\treturn ioread32(ar_ahb->tcsr_mem + offset);\n}\n\nstatic u32 ath10k_ahb_soc_read32(struct ath10k *ar, u32 addr)\n{\n\treturn ath10k_ahb_read32(ar, RTC_SOC_BASE_ADDRESS + addr);\n}\n\nstatic int ath10k_ahb_get_num_banks(struct ath10k *ar)\n{\n\tif (ar->hw_rev == ATH10K_HW_QCA4019)\n\t\treturn 1;\n\n\tath10k_warn(ar, \"unknown number of banks, assuming 1\\n\");\n\treturn 1;\n}\n\nstatic int ath10k_ahb_clock_init(struct ath10k *ar)\n{\n\tstruct ath10k_ahb *ar_ahb = ath10k_ahb_priv(ar);\n\tstruct device *dev;\n\n\tdev = &ar_ahb->pdev->dev;\n\n\tar_ahb->cmd_clk = devm_clk_get(dev, \"wifi_wcss_cmd\");\n\tif (IS_ERR_OR_NULL(ar_ahb->cmd_clk)) {\n\t\tath10k_err(ar, \"failed to get cmd clk: %ld\\n\",\n\t\t\t   PTR_ERR(ar_ahb->cmd_clk));\n\t\treturn ar_ahb->cmd_clk ? PTR_ERR(ar_ahb->cmd_clk) : -ENODEV;\n\t}\n\n\tar_ahb->ref_clk = devm_clk_get(dev, \"wifi_wcss_ref\");\n\tif (IS_ERR_OR_NULL(ar_ahb->ref_clk)) {\n\t\tath10k_err(ar, \"failed to get ref clk: %ld\\n\",\n\t\t\t   PTR_ERR(ar_ahb->ref_clk));\n\t\treturn ar_ahb->ref_clk ? PTR_ERR(ar_ahb->ref_clk) : -ENODEV;\n\t}\n\n\tar_ahb->rtc_clk = devm_clk_get(dev, \"wifi_wcss_rtc\");\n\tif (IS_ERR_OR_NULL(ar_ahb->rtc_clk)) {\n\t\tath10k_err(ar, \"failed to get rtc clk: %ld\\n\",\n\t\t\t   PTR_ERR(ar_ahb->rtc_clk));\n\t\treturn ar_ahb->rtc_clk ? PTR_ERR(ar_ahb->rtc_clk) : -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic void ath10k_ahb_clock_deinit(struct ath10k *ar)\n{\n\tstruct ath10k_ahb *ar_ahb = ath10k_ahb_priv(ar);\n\n\tar_ahb->cmd_clk = NULL;\n\tar_ahb->ref_clk = NULL;\n\tar_ahb->rtc_clk = NULL;\n}\n\nstatic int ath10k_ahb_clock_enable(struct ath10k *ar)\n{\n\tstruct ath10k_ahb *ar_ahb = ath10k_ahb_priv(ar);\n\tint ret;\n\n\tif (IS_ERR_OR_NULL(ar_ahb->cmd_clk) ||\n\t    IS_ERR_OR_NULL(ar_ahb->ref_clk) ||\n\t    IS_ERR_OR_NULL(ar_ahb->rtc_clk)) {\n\t\tath10k_err(ar, \"clock(s) is/are not initialized\\n\");\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tret = clk_prepare_enable(ar_ahb->cmd_clk);\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to enable cmd clk: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = clk_prepare_enable(ar_ahb->ref_clk);\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to enable ref clk: %d\\n\", ret);\n\t\tgoto err_cmd_clk_disable;\n\t}\n\n\tret = clk_prepare_enable(ar_ahb->rtc_clk);\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to enable rtc clk: %d\\n\", ret);\n\t\tgoto err_ref_clk_disable;\n\t}\n\n\treturn 0;\n\nerr_ref_clk_disable:\n\tclk_disable_unprepare(ar_ahb->ref_clk);\n\nerr_cmd_clk_disable:\n\tclk_disable_unprepare(ar_ahb->cmd_clk);\n\nout:\n\treturn ret;\n}\n\nstatic void ath10k_ahb_clock_disable(struct ath10k *ar)\n{\n\tstruct ath10k_ahb *ar_ahb = ath10k_ahb_priv(ar);\n\n\tclk_disable_unprepare(ar_ahb->cmd_clk);\n\n\tclk_disable_unprepare(ar_ahb->ref_clk);\n\n\tclk_disable_unprepare(ar_ahb->rtc_clk);\n}\n\nstatic int ath10k_ahb_rst_ctrl_init(struct ath10k *ar)\n{\n\tstruct ath10k_ahb *ar_ahb = ath10k_ahb_priv(ar);\n\tstruct device *dev;\n\n\tdev = &ar_ahb->pdev->dev;\n\n\tar_ahb->core_cold_rst = devm_reset_control_get_exclusive(dev,\n\t\t\t\t\t\t\t\t \"wifi_core_cold\");\n\tif (IS_ERR(ar_ahb->core_cold_rst)) {\n\t\tath10k_err(ar, \"failed to get core cold rst ctrl: %ld\\n\",\n\t\t\t   PTR_ERR(ar_ahb->core_cold_rst));\n\t\treturn PTR_ERR(ar_ahb->core_cold_rst);\n\t}\n\n\tar_ahb->radio_cold_rst = devm_reset_control_get_exclusive(dev,\n\t\t\t\t\t\t\t\t  \"wifi_radio_cold\");\n\tif (IS_ERR(ar_ahb->radio_cold_rst)) {\n\t\tath10k_err(ar, \"failed to get radio cold rst ctrl: %ld\\n\",\n\t\t\t   PTR_ERR(ar_ahb->radio_cold_rst));\n\t\treturn PTR_ERR(ar_ahb->radio_cold_rst);\n\t}\n\n\tar_ahb->radio_warm_rst = devm_reset_control_get_exclusive(dev,\n\t\t\t\t\t\t\t\t  \"wifi_radio_warm\");\n\tif (IS_ERR(ar_ahb->radio_warm_rst)) {\n\t\tath10k_err(ar, \"failed to get radio warm rst ctrl: %ld\\n\",\n\t\t\t   PTR_ERR(ar_ahb->radio_warm_rst));\n\t\treturn PTR_ERR(ar_ahb->radio_warm_rst);\n\t}\n\n\tar_ahb->radio_srif_rst = devm_reset_control_get_exclusive(dev,\n\t\t\t\t\t\t\t\t  \"wifi_radio_srif\");\n\tif (IS_ERR(ar_ahb->radio_srif_rst)) {\n\t\tath10k_err(ar, \"failed to get radio srif rst ctrl: %ld\\n\",\n\t\t\t   PTR_ERR(ar_ahb->radio_srif_rst));\n\t\treturn PTR_ERR(ar_ahb->radio_srif_rst);\n\t}\n\n\tar_ahb->cpu_init_rst = devm_reset_control_get_exclusive(dev,\n\t\t\t\t\t\t\t\t\"wifi_cpu_init\");\n\tif (IS_ERR(ar_ahb->cpu_init_rst)) {\n\t\tath10k_err(ar, \"failed to get cpu init rst ctrl: %ld\\n\",\n\t\t\t   PTR_ERR(ar_ahb->cpu_init_rst));\n\t\treturn PTR_ERR(ar_ahb->cpu_init_rst);\n\t}\n\n\treturn 0;\n}\n\nstatic void ath10k_ahb_rst_ctrl_deinit(struct ath10k *ar)\n{\n\tstruct ath10k_ahb *ar_ahb = ath10k_ahb_priv(ar);\n\n\tar_ahb->core_cold_rst = NULL;\n\tar_ahb->radio_cold_rst = NULL;\n\tar_ahb->radio_warm_rst = NULL;\n\tar_ahb->radio_srif_rst = NULL;\n\tar_ahb->cpu_init_rst = NULL;\n}\n\nstatic int ath10k_ahb_release_reset(struct ath10k *ar)\n{\n\tstruct ath10k_ahb *ar_ahb = ath10k_ahb_priv(ar);\n\tint ret;\n\n\tif (IS_ERR_OR_NULL(ar_ahb->radio_cold_rst) ||\n\t    IS_ERR_OR_NULL(ar_ahb->radio_warm_rst) ||\n\t    IS_ERR_OR_NULL(ar_ahb->radio_srif_rst) ||\n\t    IS_ERR_OR_NULL(ar_ahb->cpu_init_rst)) {\n\t\tath10k_err(ar, \"rst ctrl(s) is/are not initialized\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = reset_control_deassert(ar_ahb->radio_cold_rst);\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to deassert radio cold rst: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = reset_control_deassert(ar_ahb->radio_warm_rst);\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to deassert radio warm rst: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = reset_control_deassert(ar_ahb->radio_srif_rst);\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to deassert radio srif rst: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = reset_control_deassert(ar_ahb->cpu_init_rst);\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to deassert cpu init rst: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void ath10k_ahb_halt_axi_bus(struct ath10k *ar, u32 haltreq_reg,\n\t\t\t\t    u32 haltack_reg)\n{\n\tunsigned long timeout;\n\tu32 val;\n\n\t \n\tval = ath10k_ahb_tcsr_read32(ar, haltreq_reg);\n\tval |= AHB_AXI_BUS_HALT_REQ;\n\tath10k_ahb_tcsr_write32(ar, haltreq_reg, val);\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(ATH10K_AHB_AXI_BUS_HALT_TIMEOUT);\n\tdo {\n\t\tval = ath10k_ahb_tcsr_read32(ar, haltack_reg);\n\t\tif (val & AHB_AXI_BUS_HALT_ACK)\n\t\t\tbreak;\n\n\t\tmdelay(1);\n\t} while (time_before(jiffies, timeout));\n\n\tif (!(val & AHB_AXI_BUS_HALT_ACK)) {\n\t\tath10k_err(ar, \"failed to halt axi bus: %d\\n\", val);\n\t\treturn;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_AHB, \"axi bus halted\\n\");\n}\n\nstatic void ath10k_ahb_halt_chip(struct ath10k *ar)\n{\n\tstruct ath10k_ahb *ar_ahb = ath10k_ahb_priv(ar);\n\tu32 core_id, glb_cfg_reg, haltreq_reg, haltack_reg;\n\tu32 val;\n\tint ret;\n\n\tif (IS_ERR_OR_NULL(ar_ahb->core_cold_rst) ||\n\t    IS_ERR_OR_NULL(ar_ahb->radio_cold_rst) ||\n\t    IS_ERR_OR_NULL(ar_ahb->radio_warm_rst) ||\n\t    IS_ERR_OR_NULL(ar_ahb->radio_srif_rst) ||\n\t    IS_ERR_OR_NULL(ar_ahb->cpu_init_rst)) {\n\t\tath10k_err(ar, \"rst ctrl(s) is/are not initialized\\n\");\n\t\treturn;\n\t}\n\n\tcore_id = ath10k_ahb_read32(ar, ATH10K_AHB_WLAN_CORE_ID_REG);\n\n\tswitch (core_id) {\n\tcase 0:\n\t\tglb_cfg_reg = ATH10K_AHB_TCSR_WIFI0_GLB_CFG;\n\t\thaltreq_reg = ATH10K_AHB_TCSR_WCSS0_HALTREQ;\n\t\thaltack_reg = ATH10K_AHB_TCSR_WCSS0_HALTACK;\n\t\tbreak;\n\tcase 1:\n\t\tglb_cfg_reg = ATH10K_AHB_TCSR_WIFI1_GLB_CFG;\n\t\thaltreq_reg = ATH10K_AHB_TCSR_WCSS1_HALTREQ;\n\t\thaltack_reg = ATH10K_AHB_TCSR_WCSS1_HALTACK;\n\t\tbreak;\n\tdefault:\n\t\tath10k_err(ar, \"invalid core id %d found, skipping reset sequence\\n\",\n\t\t\t   core_id);\n\t\treturn;\n\t}\n\n\tath10k_ahb_halt_axi_bus(ar, haltreq_reg, haltack_reg);\n\n\tval = ath10k_ahb_tcsr_read32(ar, glb_cfg_reg);\n\tval |= TCSR_WIFIX_GLB_CFG_DISABLE_CORE_CLK;\n\tath10k_ahb_tcsr_write32(ar, glb_cfg_reg, val);\n\n\tret = reset_control_assert(ar_ahb->core_cold_rst);\n\tif (ret)\n\t\tath10k_err(ar, \"failed to assert core cold rst: %d\\n\", ret);\n\tmsleep(1);\n\n\tret = reset_control_assert(ar_ahb->radio_cold_rst);\n\tif (ret)\n\t\tath10k_err(ar, \"failed to assert radio cold rst: %d\\n\", ret);\n\tmsleep(1);\n\n\tret = reset_control_assert(ar_ahb->radio_warm_rst);\n\tif (ret)\n\t\tath10k_err(ar, \"failed to assert radio warm rst: %d\\n\", ret);\n\tmsleep(1);\n\n\tret = reset_control_assert(ar_ahb->radio_srif_rst);\n\tif (ret)\n\t\tath10k_err(ar, \"failed to assert radio srif rst: %d\\n\", ret);\n\tmsleep(1);\n\n\tret = reset_control_assert(ar_ahb->cpu_init_rst);\n\tif (ret)\n\t\tath10k_err(ar, \"failed to assert cpu init rst: %d\\n\", ret);\n\tmsleep(10);\n\n\t \n\tval = ath10k_ahb_tcsr_read32(ar, haltreq_reg);\n\tval &= ~AHB_AXI_BUS_HALT_REQ;\n\tath10k_ahb_tcsr_write32(ar, haltreq_reg, val);\n\n\tval = ath10k_ahb_tcsr_read32(ar, glb_cfg_reg);\n\tval &= ~TCSR_WIFIX_GLB_CFG_DISABLE_CORE_CLK;\n\tath10k_ahb_tcsr_write32(ar, glb_cfg_reg, val);\n\n\tret = reset_control_deassert(ar_ahb->core_cold_rst);\n\tif (ret)\n\t\tath10k_err(ar, \"failed to deassert core cold rst: %d\\n\", ret);\n\n\tath10k_dbg(ar, ATH10K_DBG_AHB, \"core %d reset done\\n\", core_id);\n}\n\nstatic irqreturn_t ath10k_ahb_interrupt_handler(int irq, void *arg)\n{\n\tstruct ath10k *ar = arg;\n\n\tif (!ath10k_pci_irq_pending(ar))\n\t\treturn IRQ_NONE;\n\n\tath10k_pci_disable_and_clear_legacy_irq(ar);\n\tath10k_pci_irq_msi_fw_mask(ar);\n\tnapi_schedule(&ar->napi);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ath10k_ahb_request_irq_legacy(struct ath10k *ar)\n{\n\tstruct ath10k_pci *ar_pci = ath10k_pci_priv(ar);\n\tstruct ath10k_ahb *ar_ahb = ath10k_ahb_priv(ar);\n\tint ret;\n\n\tret = request_irq(ar_ahb->irq,\n\t\t\t  ath10k_ahb_interrupt_handler,\n\t\t\t  IRQF_SHARED, \"ath10k_ahb\", ar);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to request legacy irq %d: %d\\n\",\n\t\t\t    ar_ahb->irq, ret);\n\t\treturn ret;\n\t}\n\tar_pci->oper_irq_mode = ATH10K_PCI_IRQ_LEGACY;\n\n\treturn 0;\n}\n\nstatic void ath10k_ahb_release_irq_legacy(struct ath10k *ar)\n{\n\tstruct ath10k_ahb *ar_ahb = ath10k_ahb_priv(ar);\n\n\tfree_irq(ar_ahb->irq, ar);\n}\n\nstatic void ath10k_ahb_irq_disable(struct ath10k *ar)\n{\n\tath10k_ce_disable_interrupts(ar);\n\tath10k_pci_disable_and_clear_legacy_irq(ar);\n}\n\nstatic int ath10k_ahb_resource_init(struct ath10k *ar)\n{\n\tstruct ath10k_ahb *ar_ahb = ath10k_ahb_priv(ar);\n\tstruct platform_device *pdev;\n\tstruct resource *res;\n\tint ret;\n\n\tpdev = ar_ahb->pdev;\n\n\tar_ahb->mem = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(ar_ahb->mem)) {\n\t\tath10k_err(ar, \"mem ioremap error\\n\");\n\t\tret = PTR_ERR(ar_ahb->mem);\n\t\tgoto out;\n\t}\n\n\tar_ahb->mem_len = resource_size(res);\n\n\tar_ahb->gcc_mem = ioremap(ATH10K_GCC_REG_BASE,\n\t\t\t\t  ATH10K_GCC_REG_SIZE);\n\tif (!ar_ahb->gcc_mem) {\n\t\tath10k_err(ar, \"gcc mem ioremap error\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_mem_unmap;\n\t}\n\n\tar_ahb->tcsr_mem = ioremap(ATH10K_TCSR_REG_BASE,\n\t\t\t\t   ATH10K_TCSR_REG_SIZE);\n\tif (!ar_ahb->tcsr_mem) {\n\t\tath10k_err(ar, \"tcsr mem ioremap error\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_gcc_mem_unmap;\n\t}\n\n\tret = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to set 32-bit dma mask: %d\\n\", ret);\n\t\tgoto err_tcsr_mem_unmap;\n\t}\n\n\tret = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to set 32-bit consistent dma: %d\\n\",\n\t\t\t   ret);\n\t\tgoto err_tcsr_mem_unmap;\n\t}\n\n\tret = ath10k_ahb_clock_init(ar);\n\tif (ret)\n\t\tgoto err_tcsr_mem_unmap;\n\n\tret = ath10k_ahb_rst_ctrl_init(ar);\n\tif (ret)\n\t\tgoto err_clock_deinit;\n\n\tar_ahb->irq = platform_get_irq_byname(pdev, \"legacy\");\n\tif (ar_ahb->irq < 0) {\n\t\tath10k_err(ar, \"failed to get irq number: %d\\n\", ar_ahb->irq);\n\t\tret = ar_ahb->irq;\n\t\tgoto err_clock_deinit;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_BOOT, \"irq: %d\\n\", ar_ahb->irq);\n\n\tath10k_dbg(ar, ATH10K_DBG_BOOT, \"mem: 0x%pK mem_len: %lu gcc mem: 0x%pK tcsr_mem: 0x%pK\\n\",\n\t\t   ar_ahb->mem, ar_ahb->mem_len,\n\t\t   ar_ahb->gcc_mem, ar_ahb->tcsr_mem);\n\treturn 0;\n\nerr_clock_deinit:\n\tath10k_ahb_clock_deinit(ar);\n\nerr_tcsr_mem_unmap:\n\tiounmap(ar_ahb->tcsr_mem);\n\nerr_gcc_mem_unmap:\n\tar_ahb->tcsr_mem = NULL;\n\tiounmap(ar_ahb->gcc_mem);\n\nerr_mem_unmap:\n\tar_ahb->gcc_mem = NULL;\n\tdevm_iounmap(&pdev->dev, ar_ahb->mem);\n\nout:\n\tar_ahb->mem = NULL;\n\treturn ret;\n}\n\nstatic void ath10k_ahb_resource_deinit(struct ath10k *ar)\n{\n\tstruct ath10k_ahb *ar_ahb = ath10k_ahb_priv(ar);\n\tstruct device *dev;\n\n\tdev = &ar_ahb->pdev->dev;\n\n\tif (ar_ahb->mem)\n\t\tdevm_iounmap(dev, ar_ahb->mem);\n\n\tif (ar_ahb->gcc_mem)\n\t\tiounmap(ar_ahb->gcc_mem);\n\n\tif (ar_ahb->tcsr_mem)\n\t\tiounmap(ar_ahb->tcsr_mem);\n\n\tar_ahb->mem = NULL;\n\tar_ahb->gcc_mem = NULL;\n\tar_ahb->tcsr_mem = NULL;\n\n\tath10k_ahb_clock_deinit(ar);\n\tath10k_ahb_rst_ctrl_deinit(ar);\n}\n\nstatic int ath10k_ahb_prepare_device(struct ath10k *ar)\n{\n\tu32 val;\n\tint ret;\n\n\tret = ath10k_ahb_clock_enable(ar);\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to enable clocks\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tval = ath10k_ahb_gcc_read32(ar, ATH10K_AHB_GCC_FEPLL_PLL_DIV);\n\tath10k_ahb_write32(ar, ATH10K_AHB_WIFI_SCRATCH_5_REG, val);\n\n\tret = ath10k_ahb_release_reset(ar);\n\tif (ret)\n\t\tgoto err_clk_disable;\n\n\tath10k_ahb_irq_disable(ar);\n\n\tath10k_ahb_write32(ar, FW_INDICATOR_ADDRESS, FW_IND_HOST_READY);\n\n\tret = ath10k_pci_wait_for_target_init(ar);\n\tif (ret)\n\t\tgoto err_halt_chip;\n\n\treturn 0;\n\nerr_halt_chip:\n\tath10k_ahb_halt_chip(ar);\n\nerr_clk_disable:\n\tath10k_ahb_clock_disable(ar);\n\n\treturn ret;\n}\n\nstatic int ath10k_ahb_chip_reset(struct ath10k *ar)\n{\n\tint ret;\n\n\tath10k_ahb_halt_chip(ar);\n\tath10k_ahb_clock_disable(ar);\n\n\tret = ath10k_ahb_prepare_device(ar);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int ath10k_ahb_wake_target_cpu(struct ath10k *ar)\n{\n\tu32 addr, val;\n\n\taddr = SOC_CORE_BASE_ADDRESS | CORE_CTRL_ADDRESS;\n\tval = ath10k_ahb_read32(ar, addr);\n\tval |= ATH10K_AHB_CORE_CTRL_CPU_INTR_MASK;\n\tath10k_ahb_write32(ar, addr, val);\n\n\treturn 0;\n}\n\nstatic int ath10k_ahb_hif_start(struct ath10k *ar)\n{\n\tath10k_dbg(ar, ATH10K_DBG_BOOT, \"boot ahb hif start\\n\");\n\n\tath10k_core_napi_enable(ar);\n\tath10k_ce_enable_interrupts(ar);\n\tath10k_pci_enable_legacy_irq(ar);\n\n\tath10k_pci_rx_post(ar);\n\n\treturn 0;\n}\n\nstatic void ath10k_ahb_hif_stop(struct ath10k *ar)\n{\n\tstruct ath10k_ahb *ar_ahb = ath10k_ahb_priv(ar);\n\n\tath10k_dbg(ar, ATH10K_DBG_BOOT, \"boot ahb hif stop\\n\");\n\n\tath10k_ahb_irq_disable(ar);\n\tsynchronize_irq(ar_ahb->irq);\n\n\tath10k_core_napi_sync_disable(ar);\n\n\tath10k_pci_flush(ar);\n}\n\nstatic int ath10k_ahb_hif_power_up(struct ath10k *ar,\n\t\t\t\t   enum ath10k_firmware_mode fw_mode)\n{\n\tint ret;\n\n\tath10k_dbg(ar, ATH10K_DBG_BOOT, \"boot ahb hif power up\\n\");\n\n\tret = ath10k_ahb_chip_reset(ar);\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to reset chip: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = ath10k_pci_init_pipes(ar);\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to initialize CE: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = ath10k_pci_init_config(ar);\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to setup init config: %d\\n\", ret);\n\t\tgoto err_ce_deinit;\n\t}\n\n\tret = ath10k_ahb_wake_target_cpu(ar);\n\tif (ret) {\n\t\tath10k_err(ar, \"could not wake up target CPU: %d\\n\", ret);\n\t\tgoto err_ce_deinit;\n\t}\n\n\treturn 0;\n\nerr_ce_deinit:\n\tath10k_pci_ce_deinit(ar);\nout:\n\treturn ret;\n}\n\nstatic u32 ath10k_ahb_qca4019_targ_cpu_to_ce_addr(struct ath10k *ar, u32 addr)\n{\n\tu32 val = 0, region = addr & 0xfffff;\n\n\tval = ath10k_pci_read32(ar, PCIE_BAR_REG_ADDRESS);\n\n\tif (region >= QCA4019_SRAM_ADDR && region <=\n\t    (QCA4019_SRAM_ADDR + QCA4019_SRAM_LEN)) {\n\t\t \n\t\tval |= region;\n\t} else {\n\t\tval |= 0x100000 | region;\n\t}\n\n\treturn val;\n}\n\nstatic const struct ath10k_hif_ops ath10k_ahb_hif_ops = {\n\t.tx_sg                  = ath10k_pci_hif_tx_sg,\n\t.diag_read              = ath10k_pci_hif_diag_read,\n\t.diag_write             = ath10k_pci_diag_write_mem,\n\t.exchange_bmi_msg       = ath10k_pci_hif_exchange_bmi_msg,\n\t.start                  = ath10k_ahb_hif_start,\n\t.stop                   = ath10k_ahb_hif_stop,\n\t.map_service_to_pipe    = ath10k_pci_hif_map_service_to_pipe,\n\t.get_default_pipe       = ath10k_pci_hif_get_default_pipe,\n\t.send_complete_check    = ath10k_pci_hif_send_complete_check,\n\t.get_free_queue_number  = ath10k_pci_hif_get_free_queue_number,\n\t.power_up               = ath10k_ahb_hif_power_up,\n\t.power_down             = ath10k_pci_hif_power_down,\n\t.read32                 = ath10k_ahb_read32,\n\t.write32                = ath10k_ahb_write32,\n};\n\nstatic const struct ath10k_bus_ops ath10k_ahb_bus_ops = {\n\t.read32\t\t= ath10k_ahb_read32,\n\t.write32\t= ath10k_ahb_write32,\n\t.get_num_banks\t= ath10k_ahb_get_num_banks,\n};\n\nstatic int ath10k_ahb_probe(struct platform_device *pdev)\n{\n\tstruct ath10k *ar;\n\tstruct ath10k_ahb *ar_ahb;\n\tstruct ath10k_pci *ar_pci;\n\tenum ath10k_hw_rev hw_rev;\n\tsize_t size;\n\tint ret;\n\tstruct ath10k_bus_params bus_params = {};\n\n\thw_rev = (uintptr_t)of_device_get_match_data(&pdev->dev);\n\tif (!hw_rev) {\n\t\tdev_err(&pdev->dev, \"OF data missing\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsize = sizeof(*ar_pci) + sizeof(*ar_ahb);\n\tar = ath10k_core_create(size, &pdev->dev, ATH10K_BUS_AHB,\n\t\t\t\thw_rev, &ath10k_ahb_hif_ops);\n\tif (!ar) {\n\t\tdev_err(&pdev->dev, \"failed to allocate core\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_BOOT, \"ahb probe\\n\");\n\n\tar_pci = ath10k_pci_priv(ar);\n\tar_ahb = ath10k_ahb_priv(ar);\n\n\tar_ahb->pdev = pdev;\n\tplatform_set_drvdata(pdev, ar);\n\n\tret = ath10k_ahb_resource_init(ar);\n\tif (ret)\n\t\tgoto err_core_destroy;\n\n\tar->dev_id = 0;\n\tar_pci->mem = ar_ahb->mem;\n\tar_pci->mem_len = ar_ahb->mem_len;\n\tar_pci->ar = ar;\n\tar_pci->ce.bus_ops = &ath10k_ahb_bus_ops;\n\tar_pci->targ_cpu_to_ce_addr = ath10k_ahb_qca4019_targ_cpu_to_ce_addr;\n\tar->ce_priv = &ar_pci->ce;\n\n\tret = ath10k_pci_setup_resource(ar);\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to setup resource: %d\\n\", ret);\n\t\tgoto err_resource_deinit;\n\t}\n\n\tath10k_pci_init_napi(ar);\n\n\tret = ath10k_ahb_request_irq_legacy(ar);\n\tif (ret)\n\t\tgoto err_free_pipes;\n\n\tret = ath10k_ahb_prepare_device(ar);\n\tif (ret)\n\t\tgoto err_free_irq;\n\n\tath10k_pci_ce_deinit(ar);\n\n\tbus_params.dev_type = ATH10K_DEV_TYPE_LL;\n\tbus_params.chip_id = ath10k_ahb_soc_read32(ar, SOC_CHIP_ID_ADDRESS);\n\tif (bus_params.chip_id == 0xffffffff) {\n\t\tath10k_err(ar, \"failed to get chip id\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err_halt_device;\n\t}\n\n\tret = ath10k_core_register(ar, &bus_params);\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to register driver core: %d\\n\", ret);\n\t\tgoto err_halt_device;\n\t}\n\n\treturn 0;\n\nerr_halt_device:\n\tath10k_ahb_halt_chip(ar);\n\tath10k_ahb_clock_disable(ar);\n\nerr_free_irq:\n\tath10k_ahb_release_irq_legacy(ar);\n\nerr_free_pipes:\n\tath10k_pci_release_resource(ar);\n\nerr_resource_deinit:\n\tath10k_ahb_resource_deinit(ar);\n\nerr_core_destroy:\n\tath10k_core_destroy(ar);\n\n\treturn ret;\n}\n\nstatic void ath10k_ahb_remove(struct platform_device *pdev)\n{\n\tstruct ath10k *ar = platform_get_drvdata(pdev);\n\n\tath10k_dbg(ar, ATH10K_DBG_AHB, \"ahb remove\\n\");\n\n\tath10k_core_unregister(ar);\n\tath10k_ahb_irq_disable(ar);\n\tath10k_ahb_release_irq_legacy(ar);\n\tath10k_pci_release_resource(ar);\n\tath10k_ahb_halt_chip(ar);\n\tath10k_ahb_clock_disable(ar);\n\tath10k_ahb_resource_deinit(ar);\n\tath10k_core_destroy(ar);\n}\n\nstatic struct platform_driver ath10k_ahb_driver = {\n\t.driver         = {\n\t\t.name   = \"ath10k_ahb\",\n\t\t.of_match_table = ath10k_ahb_of_match,\n\t},\n\t.probe  = ath10k_ahb_probe,\n\t.remove_new = ath10k_ahb_remove,\n};\n\nint ath10k_ahb_init(void)\n{\n\tint ret;\n\n\tret = platform_driver_register(&ath10k_ahb_driver);\n\tif (ret)\n\t\tprintk(KERN_ERR \"failed to register ath10k ahb driver: %d\\n\",\n\t\t       ret);\n\treturn ret;\n}\n\nvoid ath10k_ahb_exit(void)\n{\n\tplatform_driver_unregister(&ath10k_ahb_driver);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}