{
  "module_name": "mac.c",
  "hash_id": "33c82a4d317b0a91f29e5d84631438098c0f89a455c269a7dc00f8ed4b2b3619",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath10k/mac.c",
  "human_readable_source": "\n \n\n#include \"mac.h\"\n\n#include <net/cfg80211.h>\n#include <net/mac80211.h>\n#include <linux/etherdevice.h>\n#include <linux/acpi.h>\n#include <linux/of.h>\n#include <linux/bitfield.h>\n\n#include \"hif.h\"\n#include \"core.h\"\n#include \"debug.h\"\n#include \"wmi.h\"\n#include \"htt.h\"\n#include \"txrx.h\"\n#include \"testmode.h\"\n#include \"wmi-tlv.h\"\n#include \"wmi-ops.h\"\n#include \"wow.h\"\n\n \n \n \n\nstatic struct ieee80211_rate ath10k_rates[] = {\n\t{ .bitrate = 10,\n\t  .hw_value = ATH10K_HW_RATE_CCK_LP_1M },\n\t{ .bitrate = 20,\n\t  .hw_value = ATH10K_HW_RATE_CCK_LP_2M,\n\t  .hw_value_short = ATH10K_HW_RATE_CCK_SP_2M,\n\t  .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 55,\n\t  .hw_value = ATH10K_HW_RATE_CCK_LP_5_5M,\n\t  .hw_value_short = ATH10K_HW_RATE_CCK_SP_5_5M,\n\t  .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 110,\n\t  .hw_value = ATH10K_HW_RATE_CCK_LP_11M,\n\t  .hw_value_short = ATH10K_HW_RATE_CCK_SP_11M,\n\t  .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\n\t{ .bitrate = 60, .hw_value = ATH10K_HW_RATE_OFDM_6M },\n\t{ .bitrate = 90, .hw_value = ATH10K_HW_RATE_OFDM_9M },\n\t{ .bitrate = 120, .hw_value = ATH10K_HW_RATE_OFDM_12M },\n\t{ .bitrate = 180, .hw_value = ATH10K_HW_RATE_OFDM_18M },\n\t{ .bitrate = 240, .hw_value = ATH10K_HW_RATE_OFDM_24M },\n\t{ .bitrate = 360, .hw_value = ATH10K_HW_RATE_OFDM_36M },\n\t{ .bitrate = 480, .hw_value = ATH10K_HW_RATE_OFDM_48M },\n\t{ .bitrate = 540, .hw_value = ATH10K_HW_RATE_OFDM_54M },\n};\n\nstatic struct ieee80211_rate ath10k_rates_rev2[] = {\n\t{ .bitrate = 10,\n\t  .hw_value = ATH10K_HW_RATE_REV2_CCK_LP_1M },\n\t{ .bitrate = 20,\n\t  .hw_value = ATH10K_HW_RATE_REV2_CCK_LP_2M,\n\t  .hw_value_short = ATH10K_HW_RATE_REV2_CCK_SP_2M,\n\t  .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 55,\n\t  .hw_value = ATH10K_HW_RATE_REV2_CCK_LP_5_5M,\n\t  .hw_value_short = ATH10K_HW_RATE_REV2_CCK_SP_5_5M,\n\t  .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 110,\n\t  .hw_value = ATH10K_HW_RATE_REV2_CCK_LP_11M,\n\t  .hw_value_short = ATH10K_HW_RATE_REV2_CCK_SP_11M,\n\t  .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\n\t{ .bitrate = 60, .hw_value = ATH10K_HW_RATE_OFDM_6M },\n\t{ .bitrate = 90, .hw_value = ATH10K_HW_RATE_OFDM_9M },\n\t{ .bitrate = 120, .hw_value = ATH10K_HW_RATE_OFDM_12M },\n\t{ .bitrate = 180, .hw_value = ATH10K_HW_RATE_OFDM_18M },\n\t{ .bitrate = 240, .hw_value = ATH10K_HW_RATE_OFDM_24M },\n\t{ .bitrate = 360, .hw_value = ATH10K_HW_RATE_OFDM_36M },\n\t{ .bitrate = 480, .hw_value = ATH10K_HW_RATE_OFDM_48M },\n\t{ .bitrate = 540, .hw_value = ATH10K_HW_RATE_OFDM_54M },\n};\n\nstatic const struct cfg80211_sar_freq_ranges ath10k_sar_freq_ranges[] = {\n\t{.start_freq = 2402, .end_freq = 2494 },\n\t{.start_freq = 5170, .end_freq = 5875 },\n};\n\nstatic const struct cfg80211_sar_capa ath10k_sar_capa = {\n\t.type = NL80211_SAR_TYPE_POWER,\n\t.num_freq_ranges = (ARRAY_SIZE(ath10k_sar_freq_ranges)),\n\t.freq_ranges = &ath10k_sar_freq_ranges[0],\n};\n\n#define ATH10K_MAC_FIRST_OFDM_RATE_IDX 4\n\n#define ath10k_a_rates (ath10k_rates + ATH10K_MAC_FIRST_OFDM_RATE_IDX)\n#define ath10k_a_rates_size (ARRAY_SIZE(ath10k_rates) - \\\n\t\t\t     ATH10K_MAC_FIRST_OFDM_RATE_IDX)\n#define ath10k_g_rates (ath10k_rates + 0)\n#define ath10k_g_rates_size (ARRAY_SIZE(ath10k_rates))\n\n#define ath10k_g_rates_rev2 (ath10k_rates_rev2 + 0)\n#define ath10k_g_rates_rev2_size (ARRAY_SIZE(ath10k_rates_rev2))\n\n#define ath10k_wmi_legacy_rates ath10k_rates\n\nstatic bool ath10k_mac_bitrate_is_cck(int bitrate)\n{\n\tswitch (bitrate) {\n\tcase 10:\n\tcase 20:\n\tcase 55:\n\tcase 110:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic u8 ath10k_mac_bitrate_to_rate(int bitrate)\n{\n\treturn DIV_ROUND_UP(bitrate, 5) |\n\t       (ath10k_mac_bitrate_is_cck(bitrate) ? BIT(7) : 0);\n}\n\nu8 ath10k_mac_hw_rate_to_idx(const struct ieee80211_supported_band *sband,\n\t\t\t     u8 hw_rate, bool cck)\n{\n\tconst struct ieee80211_rate *rate;\n\tint i;\n\n\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\trate = &sband->bitrates[i];\n\n\t\tif (ath10k_mac_bitrate_is_cck(rate->bitrate) != cck)\n\t\t\tcontinue;\n\n\t\tif (rate->hw_value == hw_rate)\n\t\t\treturn i;\n\t\telse if (rate->flags & IEEE80211_RATE_SHORT_PREAMBLE &&\n\t\t\t rate->hw_value_short == hw_rate)\n\t\t\treturn i;\n\t}\n\n\treturn 0;\n}\n\nu8 ath10k_mac_bitrate_to_idx(const struct ieee80211_supported_band *sband,\n\t\t\t     u32 bitrate)\n{\n\tint i;\n\n\tfor (i = 0; i < sband->n_bitrates; i++)\n\t\tif (sband->bitrates[i].bitrate == bitrate)\n\t\t\treturn i;\n\n\treturn 0;\n}\n\nstatic int ath10k_mac_get_rate_hw_value(int bitrate)\n{\n\tint i;\n\tu8 hw_value_prefix = 0;\n\n\tif (ath10k_mac_bitrate_is_cck(bitrate))\n\t\thw_value_prefix = WMI_RATE_PREAMBLE_CCK << 6;\n\n\tfor (i = 0; i < ARRAY_SIZE(ath10k_rates); i++) {\n\t\tif (ath10k_rates[i].bitrate == bitrate)\n\t\t\treturn hw_value_prefix | ath10k_rates[i].hw_value;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int ath10k_mac_get_max_vht_mcs_map(u16 mcs_map, int nss)\n{\n\tswitch ((mcs_map >> (2 * nss)) & 0x3) {\n\tcase IEEE80211_VHT_MCS_SUPPORT_0_7: return BIT(8) - 1;\n\tcase IEEE80211_VHT_MCS_SUPPORT_0_8: return BIT(9) - 1;\n\tcase IEEE80211_VHT_MCS_SUPPORT_0_9: return BIT(10) - 1;\n\t}\n\treturn 0;\n}\n\nstatic u32\nath10k_mac_max_ht_nss(const u8 ht_mcs_mask[IEEE80211_HT_MCS_MASK_LEN])\n{\n\tint nss;\n\n\tfor (nss = IEEE80211_HT_MCS_MASK_LEN - 1; nss >= 0; nss--)\n\t\tif (ht_mcs_mask[nss])\n\t\t\treturn nss + 1;\n\n\treturn 1;\n}\n\nstatic u32\nath10k_mac_max_vht_nss(const u16 vht_mcs_mask[NL80211_VHT_NSS_MAX])\n{\n\tint nss;\n\n\tfor (nss = NL80211_VHT_NSS_MAX - 1; nss >= 0; nss--)\n\t\tif (vht_mcs_mask[nss])\n\t\t\treturn nss + 1;\n\n\treturn 1;\n}\n\nint ath10k_mac_ext_resource_config(struct ath10k *ar, u32 val)\n{\n\tenum wmi_host_platform_type platform_type;\n\tint ret;\n\n\tif (test_bit(WMI_SERVICE_TX_MODE_DYNAMIC, ar->wmi.svc_map))\n\t\tplatform_type = WMI_HOST_PLATFORM_LOW_PERF;\n\telse\n\t\tplatform_type = WMI_HOST_PLATFORM_HIGH_PERF;\n\n\tret = ath10k_wmi_ext_resource_config(ar, platform_type, val);\n\n\tif (ret && ret != -EOPNOTSUPP) {\n\t\tath10k_warn(ar, \"failed to configure ext resource: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \n \n \n\nstatic int ath10k_send_key(struct ath10k_vif *arvif,\n\t\t\t   struct ieee80211_key_conf *key,\n\t\t\t   enum set_key_cmd cmd,\n\t\t\t   const u8 *macaddr, u32 flags)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tstruct wmi_vdev_install_key_arg arg = {\n\t\t.vdev_id = arvif->vdev_id,\n\t\t.key_idx = key->keyidx,\n\t\t.key_len = key->keylen,\n\t\t.key_data = key->key,\n\t\t.key_flags = flags,\n\t\t.macaddr = macaddr,\n\t};\n\n\tlockdep_assert_held(&arvif->ar->conf_mutex);\n\n\tswitch (key->cipher) {\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\targ.key_cipher = ar->wmi_key_cipher[WMI_CIPHER_AES_CCM];\n\t\tkey->flags |= IEEE80211_KEY_FLAG_GENERATE_IV_MGMT;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\targ.key_cipher = ar->wmi_key_cipher[WMI_CIPHER_TKIP];\n\t\targ.key_txmic_len = 8;\n\t\targ.key_rxmic_len = 8;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\targ.key_cipher = ar->wmi_key_cipher[WMI_CIPHER_WEP];\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP_256:\n\t\targ.key_cipher = ar->wmi_key_cipher[WMI_CIPHER_AES_CCM];\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_GCMP:\n\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\targ.key_cipher = ar->wmi_key_cipher[WMI_CIPHER_AES_GCM];\n\t\tkey->flags |= IEEE80211_KEY_FLAG_GENERATE_IV_MGMT;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_128:\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_256:\n\tcase WLAN_CIPHER_SUITE_BIP_CMAC_256:\n\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\tdefault:\n\t\tath10k_warn(ar, \"cipher %d is not supported\\n\", key->cipher);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (test_bit(ATH10K_FLAG_RAW_MODE, &ar->dev_flags))\n\t\tkey->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;\n\n\tif (cmd == DISABLE_KEY) {\n\t\targ.key_cipher = ar->wmi_key_cipher[WMI_CIPHER_NONE];\n\t\targ.key_data = NULL;\n\t}\n\n\treturn ath10k_wmi_vdev_install_key(arvif->ar, &arg);\n}\n\nstatic int ath10k_install_key(struct ath10k_vif *arvif,\n\t\t\t      struct ieee80211_key_conf *key,\n\t\t\t      enum set_key_cmd cmd,\n\t\t\t      const u8 *macaddr, u32 flags)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tint ret;\n\tunsigned long time_left;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\treinit_completion(&ar->install_key_done);\n\n\tif (arvif->nohwcrypt)\n\t\treturn 1;\n\n\tret = ath10k_send_key(arvif, key, cmd, macaddr, flags);\n\tif (ret)\n\t\treturn ret;\n\n\ttime_left = wait_for_completion_timeout(&ar->install_key_done, 3 * HZ);\n\tif (time_left == 0)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic int ath10k_install_peer_wep_keys(struct ath10k_vif *arvif,\n\t\t\t\t\tconst u8 *addr)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tstruct ath10k_peer *peer;\n\tint ret;\n\tint i;\n\tu32 flags;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (WARN_ON(arvif->vif->type != NL80211_IFTYPE_AP &&\n\t\t    arvif->vif->type != NL80211_IFTYPE_ADHOC &&\n\t\t    arvif->vif->type != NL80211_IFTYPE_MESH_POINT))\n\t\treturn -EINVAL;\n\n\tspin_lock_bh(&ar->data_lock);\n\tpeer = ath10k_peer_find(ar, arvif->vdev_id, addr);\n\tspin_unlock_bh(&ar->data_lock);\n\n\tif (!peer)\n\t\treturn -ENOENT;\n\n\tfor (i = 0; i < ARRAY_SIZE(arvif->wep_keys); i++) {\n\t\tif (arvif->wep_keys[i] == NULL)\n\t\t\tcontinue;\n\n\t\tswitch (arvif->vif->type) {\n\t\tcase NL80211_IFTYPE_AP:\n\t\t\tflags = WMI_KEY_PAIRWISE;\n\n\t\t\tif (arvif->def_wep_key_idx == i)\n\t\t\t\tflags |= WMI_KEY_TX_USAGE;\n\n\t\t\tret = ath10k_install_key(arvif, arvif->wep_keys[i],\n\t\t\t\t\t\t SET_KEY, addr, flags);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_ADHOC:\n\t\t\tret = ath10k_install_key(arvif, arvif->wep_keys[i],\n\t\t\t\t\t\t SET_KEY, addr,\n\t\t\t\t\t\t WMI_KEY_PAIRWISE);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\n\t\t\tret = ath10k_install_key(arvif, arvif->wep_keys[i],\n\t\t\t\t\t\t SET_KEY, addr, WMI_KEY_GROUP);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tspin_lock_bh(&ar->data_lock);\n\t\tpeer->keys[i] = arvif->wep_keys[i];\n\t\tspin_unlock_bh(&ar->data_lock);\n\t}\n\n\t \n\tif (arvif->vif->type != NL80211_IFTYPE_ADHOC)\n\t\treturn 0;\n\n\tif (arvif->def_wep_key_idx == -1)\n\t\treturn 0;\n\n\tret = ath10k_wmi_vdev_set_param(arvif->ar,\n\t\t\t\t\tarvif->vdev_id,\n\t\t\t\t\tarvif->ar->wmi.vdev_param->def_keyid,\n\t\t\t\t\tarvif->def_wep_key_idx);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to re-set def wpa key idxon vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_clear_peer_keys(struct ath10k_vif *arvif,\n\t\t\t\t  const u8 *addr)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tstruct ath10k_peer *peer;\n\tint first_errno = 0;\n\tint ret;\n\tint i;\n\tu32 flags = 0;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tspin_lock_bh(&ar->data_lock);\n\tpeer = ath10k_peer_find(ar, arvif->vdev_id, addr);\n\tspin_unlock_bh(&ar->data_lock);\n\n\tif (!peer)\n\t\treturn -ENOENT;\n\n\tfor (i = 0; i < ARRAY_SIZE(peer->keys); i++) {\n\t\tif (peer->keys[i] == NULL)\n\t\t\tcontinue;\n\n\t\t \n\t\tret = ath10k_install_key(arvif, peer->keys[i],\n\t\t\t\t\t DISABLE_KEY, addr, flags);\n\t\tif (ret < 0 && first_errno == 0)\n\t\t\tfirst_errno = ret;\n\n\t\tif (ret < 0)\n\t\t\tath10k_warn(ar, \"failed to remove peer wep key %d: %d\\n\",\n\t\t\t\t    i, ret);\n\n\t\tspin_lock_bh(&ar->data_lock);\n\t\tpeer->keys[i] = NULL;\n\t\tspin_unlock_bh(&ar->data_lock);\n\t}\n\n\treturn first_errno;\n}\n\nbool ath10k_mac_is_peer_wep_key_set(struct ath10k *ar, const u8 *addr,\n\t\t\t\t    u8 keyidx)\n{\n\tstruct ath10k_peer *peer;\n\tint i;\n\n\tlockdep_assert_held(&ar->data_lock);\n\n\t \n\tpeer = ath10k_peer_find(ar, 0, addr);\n\tif (!peer)\n\t\treturn false;\n\n\tfor (i = 0; i < ARRAY_SIZE(peer->keys); i++) {\n\t\tif (peer->keys[i] && peer->keys[i]->keyidx == keyidx)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int ath10k_clear_vdev_key(struct ath10k_vif *arvif,\n\t\t\t\t struct ieee80211_key_conf *key)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tstruct ath10k_peer *peer;\n\tu8 addr[ETH_ALEN];\n\tint first_errno = 0;\n\tint ret;\n\tint i;\n\tu32 flags = 0;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tfor (;;) {\n\t\t \n\t\tspin_lock_bh(&ar->data_lock);\n\t\ti = 0;\n\t\tlist_for_each_entry(peer, &ar->peers, list) {\n\t\t\tfor (i = 0; i < ARRAY_SIZE(peer->keys); i++) {\n\t\t\t\tif (peer->keys[i] == key) {\n\t\t\t\t\tether_addr_copy(addr, peer->addr);\n\t\t\t\t\tpeer->keys[i] = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (i < ARRAY_SIZE(peer->keys))\n\t\t\t\tbreak;\n\t\t}\n\t\tspin_unlock_bh(&ar->data_lock);\n\n\t\tif (i == ARRAY_SIZE(peer->keys))\n\t\t\tbreak;\n\t\t \n\t\tret = ath10k_install_key(arvif, key, DISABLE_KEY, addr, flags);\n\t\tif (ret < 0 && first_errno == 0)\n\t\t\tfirst_errno = ret;\n\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to remove key for %pM: %d\\n\",\n\t\t\t\t    addr, ret);\n\t}\n\n\treturn first_errno;\n}\n\nstatic int ath10k_mac_vif_update_wep_key(struct ath10k_vif *arvif,\n\t\t\t\t\t struct ieee80211_key_conf *key)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tstruct ath10k_peer *peer;\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tlist_for_each_entry(peer, &ar->peers, list) {\n\t\tif (ether_addr_equal(peer->addr, arvif->vif->addr))\n\t\t\tcontinue;\n\n\t\tif (ether_addr_equal(peer->addr, arvif->bssid))\n\t\t\tcontinue;\n\n\t\tif (peer->keys[key->keyidx] == key)\n\t\t\tcontinue;\n\n\t\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac vif vdev %i update key %i needs update\\n\",\n\t\t\t   arvif->vdev_id, key->keyidx);\n\n\t\tret = ath10k_install_peer_wep_keys(arvif, peer->addr);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to update wep keys on vdev %i for peer %pM: %d\\n\",\n\t\t\t\t    arvif->vdev_id, peer->addr, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \n \n \n\nstatic inline enum wmi_phy_mode\nchan_to_phymode(const struct cfg80211_chan_def *chandef)\n{\n\tenum wmi_phy_mode phymode = MODE_UNKNOWN;\n\n\tswitch (chandef->chan->band) {\n\tcase NL80211_BAND_2GHZ:\n\t\tswitch (chandef->width) {\n\t\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\t\t\tif (chandef->chan->flags & IEEE80211_CHAN_NO_OFDM)\n\t\t\t\tphymode = MODE_11B;\n\t\t\telse\n\t\t\t\tphymode = MODE_11G;\n\t\t\tbreak;\n\t\tcase NL80211_CHAN_WIDTH_20:\n\t\t\tphymode = MODE_11NG_HT20;\n\t\t\tbreak;\n\t\tcase NL80211_CHAN_WIDTH_40:\n\t\t\tphymode = MODE_11NG_HT40;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tphymode = MODE_UNKNOWN;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase NL80211_BAND_5GHZ:\n\t\tswitch (chandef->width) {\n\t\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\t\t\tphymode = MODE_11A;\n\t\t\tbreak;\n\t\tcase NL80211_CHAN_WIDTH_20:\n\t\t\tphymode = MODE_11NA_HT20;\n\t\t\tbreak;\n\t\tcase NL80211_CHAN_WIDTH_40:\n\t\t\tphymode = MODE_11NA_HT40;\n\t\t\tbreak;\n\t\tcase NL80211_CHAN_WIDTH_80:\n\t\t\tphymode = MODE_11AC_VHT80;\n\t\t\tbreak;\n\t\tcase NL80211_CHAN_WIDTH_160:\n\t\t\tphymode = MODE_11AC_VHT160;\n\t\t\tbreak;\n\t\tcase NL80211_CHAN_WIDTH_80P80:\n\t\t\tphymode = MODE_11AC_VHT80_80;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tphymode = MODE_UNKNOWN;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tWARN_ON(phymode == MODE_UNKNOWN);\n\treturn phymode;\n}\n\nstatic u8 ath10k_parse_mpdudensity(u8 mpdudensity)\n{\n \n\tswitch (mpdudensity) {\n\tcase 0:\n\t\treturn 0;\n\tcase 1:\n\tcase 2:\n\tcase 3:\n\t \n\t\treturn 1;\n\tcase 4:\n\t\treturn 2;\n\tcase 5:\n\t\treturn 4;\n\tcase 6:\n\t\treturn 8;\n\tcase 7:\n\t\treturn 16;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nint ath10k_mac_vif_chan(struct ieee80211_vif *vif,\n\t\t\tstruct cfg80211_chan_def *def)\n{\n\tstruct ieee80211_chanctx_conf *conf;\n\n\trcu_read_lock();\n\tconf = rcu_dereference(vif->bss_conf.chanctx_conf);\n\tif (!conf) {\n\t\trcu_read_unlock();\n\t\treturn -ENOENT;\n\t}\n\n\t*def = conf->def;\n\trcu_read_unlock();\n\n\treturn 0;\n}\n\nstatic void ath10k_mac_num_chanctxs_iter(struct ieee80211_hw *hw,\n\t\t\t\t\t struct ieee80211_chanctx_conf *conf,\n\t\t\t\t\t void *data)\n{\n\tint *num = data;\n\n\t(*num)++;\n}\n\nstatic int ath10k_mac_num_chanctxs(struct ath10k *ar)\n{\n\tint num = 0;\n\n\tieee80211_iter_chan_contexts_atomic(ar->hw,\n\t\t\t\t\t    ath10k_mac_num_chanctxs_iter,\n\t\t\t\t\t    &num);\n\n\treturn num;\n}\n\nstatic void\nath10k_mac_get_any_chandef_iter(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_chanctx_conf *conf,\n\t\t\t\tvoid *data)\n{\n\tstruct cfg80211_chan_def **def = data;\n\n\t*def = &conf->def;\n}\n\nstatic void ath10k_wait_for_peer_delete_done(struct ath10k *ar, u32 vdev_id,\n\t\t\t\t\t     const u8 *addr)\n{\n\tunsigned long time_left;\n\tint ret;\n\n\tif (test_bit(WMI_SERVICE_SYNC_DELETE_CMDS, ar->wmi.svc_map)) {\n\t\tret = ath10k_wait_for_peer_deleted(ar, vdev_id, addr);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed wait for peer deleted\");\n\t\t\treturn;\n\t\t}\n\n\t\ttime_left = wait_for_completion_timeout(&ar->peer_delete_done,\n\t\t\t\t\t\t\t5 * HZ);\n\t\tif (!time_left)\n\t\t\tath10k_warn(ar, \"Timeout in receiving peer delete response\\n\");\n\t}\n}\n\nstatic int ath10k_peer_create(struct ath10k *ar,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      struct ieee80211_sta *sta,\n\t\t\t      u32 vdev_id,\n\t\t\t      const u8 *addr,\n\t\t\t      enum wmi_peer_type peer_type)\n{\n\tstruct ath10k_vif *arvif;\n\tstruct ath10k_peer *peer;\n\tint num_peers = 0;\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tnum_peers = ar->num_peers;\n\n\t \n\tlist_for_each_entry(arvif, &ar->arvifs, list)\n\t\tnum_peers++;\n\n\tif (num_peers >= ar->max_num_peers)\n\t\treturn -ENOBUFS;\n\n\tret = ath10k_wmi_peer_create(ar, vdev_id, addr, peer_type);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to create wmi peer %pM on vdev %i: %i\\n\",\n\t\t\t    addr, vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\tret = ath10k_wait_for_peer_created(ar, vdev_id, addr);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to wait for created wmi peer %pM on vdev %i: %i\\n\",\n\t\t\t    addr, vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\tspin_lock_bh(&ar->data_lock);\n\n\tpeer = ath10k_peer_find(ar, vdev_id, addr);\n\tif (!peer) {\n\t\tspin_unlock_bh(&ar->data_lock);\n\t\tath10k_warn(ar, \"failed to find peer %pM on vdev %i after creation\\n\",\n\t\t\t    addr, vdev_id);\n\t\tath10k_wait_for_peer_delete_done(ar, vdev_id, addr);\n\t\treturn -ENOENT;\n\t}\n\n\tpeer->vif = vif;\n\tpeer->sta = sta;\n\n\tspin_unlock_bh(&ar->data_lock);\n\n\tar->num_peers++;\n\n\treturn 0;\n}\n\nstatic int ath10k_mac_set_kickout(struct ath10k_vif *arvif)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tu32 param;\n\tint ret;\n\n\tparam = ar->wmi.pdev_param->sta_kickout_th;\n\tret = ath10k_wmi_pdev_set_param(ar, param,\n\t\t\t\t\tATH10K_KICKOUT_THRESHOLD);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set kickout threshold on vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\tparam = ar->wmi.vdev_param->ap_keepalive_min_idle_inactive_time_secs;\n\tret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, param,\n\t\t\t\t\tATH10K_KEEPALIVE_MIN_IDLE);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set keepalive minimum idle time on vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\tparam = ar->wmi.vdev_param->ap_keepalive_max_idle_inactive_time_secs;\n\tret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, param,\n\t\t\t\t\tATH10K_KEEPALIVE_MAX_IDLE);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set keepalive maximum idle time on vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\tparam = ar->wmi.vdev_param->ap_keepalive_max_unresponsive_time_secs;\n\tret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, param,\n\t\t\t\t\tATH10K_KEEPALIVE_MAX_UNRESPONSIVE);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set keepalive maximum unresponsive time on vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_mac_set_rts(struct ath10k_vif *arvif, u32 value)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tu32 vdev_param;\n\n\tvdev_param = ar->wmi.vdev_param->rts_threshold;\n\treturn ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, vdev_param, value);\n}\n\nstatic int ath10k_peer_delete(struct ath10k *ar, u32 vdev_id, const u8 *addr)\n{\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tret = ath10k_wmi_peer_delete(ar, vdev_id, addr);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ath10k_wait_for_peer_deleted(ar, vdev_id, addr);\n\tif (ret)\n\t\treturn ret;\n\n\tif (test_bit(WMI_SERVICE_SYNC_DELETE_CMDS, ar->wmi.svc_map)) {\n\t\tunsigned long time_left;\n\n\t\ttime_left = wait_for_completion_timeout\n\t\t\t    (&ar->peer_delete_done, 5 * HZ);\n\n\t\tif (!time_left) {\n\t\t\tath10k_warn(ar, \"Timeout in receiving peer delete response\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t}\n\n\tar->num_peers--;\n\n\treturn 0;\n}\n\nstatic void ath10k_peer_map_cleanup(struct ath10k *ar, struct ath10k_peer *peer)\n{\n\tint peer_id, i;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tfor_each_set_bit(peer_id, peer->peer_ids,\n\t\t\t ATH10K_MAX_NUM_PEER_IDS) {\n\t\tar->peer_map[peer_id] = NULL;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(ar->peer_map); i++) {\n\t\tif (ar->peer_map[i] == peer) {\n\t\t\tath10k_warn(ar, \"removing stale peer_map entry for %pM (ptr %pK idx %d)\\n\",\n\t\t\t\t    peer->addr, peer, i);\n\t\t\tar->peer_map[i] = NULL;\n\t\t}\n\t}\n\n\tlist_del(&peer->list);\n\tkfree(peer);\n\tar->num_peers--;\n}\n\nstatic void ath10k_peer_cleanup(struct ath10k *ar, u32 vdev_id)\n{\n\tstruct ath10k_peer *peer, *tmp;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tspin_lock_bh(&ar->data_lock);\n\tlist_for_each_entry_safe(peer, tmp, &ar->peers, list) {\n\t\tif (peer->vdev_id != vdev_id)\n\t\t\tcontinue;\n\n\t\tath10k_warn(ar, \"removing stale peer %pM from vdev_id %d\\n\",\n\t\t\t    peer->addr, vdev_id);\n\n\t\tath10k_peer_map_cleanup(ar, peer);\n\t}\n\tspin_unlock_bh(&ar->data_lock);\n}\n\nstatic void ath10k_peer_cleanup_all(struct ath10k *ar)\n{\n\tstruct ath10k_peer *peer, *tmp;\n\tint i;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tspin_lock_bh(&ar->data_lock);\n\tlist_for_each_entry_safe(peer, tmp, &ar->peers, list) {\n\t\tlist_del(&peer->list);\n\t\tkfree(peer);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(ar->peer_map); i++)\n\t\tar->peer_map[i] = NULL;\n\n\tspin_unlock_bh(&ar->data_lock);\n\n\tar->num_peers = 0;\n\tar->num_stations = 0;\n}\n\nstatic int ath10k_mac_tdls_peer_update(struct ath10k *ar, u32 vdev_id,\n\t\t\t\t       struct ieee80211_sta *sta,\n\t\t\t\t       enum wmi_tdls_peer_state state)\n{\n\tint ret;\n\tstruct wmi_tdls_peer_update_cmd_arg arg = {};\n\tstruct wmi_tdls_peer_capab_arg cap = {};\n\tstruct wmi_channel_arg chan_arg = {};\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\targ.vdev_id = vdev_id;\n\targ.peer_state = state;\n\tether_addr_copy(arg.addr, sta->addr);\n\n\tcap.peer_max_sp = sta->max_sp;\n\tcap.peer_uapsd_queues = sta->uapsd_queues;\n\n\tif (state == WMI_TDLS_PEER_STATE_CONNECTED &&\n\t    !sta->tdls_initiator)\n\t\tcap.is_peer_responder = 1;\n\n\tret = ath10k_wmi_tdls_peer_update(ar, &arg, &cap, &chan_arg);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to update tdls peer %pM on vdev %i: %i\\n\",\n\t\t\t    arg.addr, vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \n \n \n\nvoid ath10k_mac_vif_beacon_free(struct ath10k_vif *arvif)\n{\n\tstruct ath10k *ar = arvif->ar;\n\n\tlockdep_assert_held(&ar->data_lock);\n\n\tif (!arvif->beacon)\n\t\treturn;\n\n\tif (!arvif->beacon_buf)\n\t\tdma_unmap_single(ar->dev, ATH10K_SKB_CB(arvif->beacon)->paddr,\n\t\t\t\t arvif->beacon->len, DMA_TO_DEVICE);\n\n\tif (WARN_ON(arvif->beacon_state != ATH10K_BEACON_SCHEDULED &&\n\t\t    arvif->beacon_state != ATH10K_BEACON_SENT))\n\t\treturn;\n\n\tdev_kfree_skb_any(arvif->beacon);\n\n\tarvif->beacon = NULL;\n\tarvif->beacon_state = ATH10K_BEACON_SCHEDULED;\n}\n\nstatic void ath10k_mac_vif_beacon_cleanup(struct ath10k_vif *arvif)\n{\n\tstruct ath10k *ar = arvif->ar;\n\n\tlockdep_assert_held(&ar->data_lock);\n\n\tath10k_mac_vif_beacon_free(arvif);\n\n\tif (arvif->beacon_buf) {\n\t\tif (ar->bus_param.dev_type == ATH10K_DEV_TYPE_HL)\n\t\t\tkfree(arvif->beacon_buf);\n\t\telse\n\t\t\tdma_free_coherent(ar->dev, IEEE80211_MAX_FRAME_LEN,\n\t\t\t\t\t  arvif->beacon_buf,\n\t\t\t\t\t  arvif->beacon_paddr);\n\t\tarvif->beacon_buf = NULL;\n\t}\n}\n\nstatic inline int ath10k_vdev_setup_sync(struct ath10k *ar)\n{\n\tunsigned long time_left;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (test_bit(ATH10K_FLAG_CRASH_FLUSH, &ar->dev_flags))\n\t\treturn -ESHUTDOWN;\n\n\ttime_left = wait_for_completion_timeout(&ar->vdev_setup_done,\n\t\t\t\t\t\tATH10K_VDEV_SETUP_TIMEOUT_HZ);\n\tif (time_left == 0)\n\t\treturn -ETIMEDOUT;\n\n\treturn ar->last_wmi_vdev_start_status;\n}\n\nstatic int ath10k_monitor_vdev_start(struct ath10k *ar, int vdev_id)\n{\n\tstruct cfg80211_chan_def *chandef = NULL;\n\tstruct ieee80211_channel *channel = NULL;\n\tstruct wmi_vdev_start_request_arg arg = {};\n\tint ret = 0;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tieee80211_iter_chan_contexts_atomic(ar->hw,\n\t\t\t\t\t    ath10k_mac_get_any_chandef_iter,\n\t\t\t\t\t    &chandef);\n\tif (WARN_ON_ONCE(!chandef))\n\t\treturn -ENOENT;\n\n\tchannel = chandef->chan;\n\n\targ.vdev_id = vdev_id;\n\targ.channel.freq = channel->center_freq;\n\targ.channel.band_center_freq1 = chandef->center_freq1;\n\targ.channel.band_center_freq2 = chandef->center_freq2;\n\n\t \n\targ.channel.mode = chan_to_phymode(chandef);\n\targ.channel.chan_radar =\n\t\t\t!!(channel->flags & IEEE80211_CHAN_RADAR);\n\n\targ.channel.min_power = 0;\n\targ.channel.max_power = channel->max_power * 2;\n\targ.channel.max_reg_power = channel->max_reg_power * 2;\n\targ.channel.max_antenna_gain = channel->max_antenna_gain;\n\n\treinit_completion(&ar->vdev_setup_done);\n\treinit_completion(&ar->vdev_delete_done);\n\n\tret = ath10k_wmi_vdev_start(ar, &arg);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to request monitor vdev %i start: %d\\n\",\n\t\t\t    vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\tret = ath10k_vdev_setup_sync(ar);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to synchronize setup for monitor vdev %i start: %d\\n\",\n\t\t\t    vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\tret = ath10k_wmi_vdev_up(ar, vdev_id, 0, ar->mac_addr);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to put up monitor vdev %i: %d\\n\",\n\t\t\t    vdev_id, ret);\n\t\tgoto vdev_stop;\n\t}\n\n\tar->monitor_vdev_id = vdev_id;\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac monitor vdev %i started\\n\",\n\t\t   ar->monitor_vdev_id);\n\treturn 0;\n\nvdev_stop:\n\tret = ath10k_wmi_vdev_stop(ar, ar->monitor_vdev_id);\n\tif (ret)\n\t\tath10k_warn(ar, \"failed to stop monitor vdev %i after start failure: %d\\n\",\n\t\t\t    ar->monitor_vdev_id, ret);\n\n\treturn ret;\n}\n\nstatic int ath10k_monitor_vdev_stop(struct ath10k *ar)\n{\n\tint ret = 0;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tret = ath10k_wmi_vdev_down(ar, ar->monitor_vdev_id);\n\tif (ret)\n\t\tath10k_warn(ar, \"failed to put down monitor vdev %i: %d\\n\",\n\t\t\t    ar->monitor_vdev_id, ret);\n\n\treinit_completion(&ar->vdev_setup_done);\n\treinit_completion(&ar->vdev_delete_done);\n\n\tret = ath10k_wmi_vdev_stop(ar, ar->monitor_vdev_id);\n\tif (ret)\n\t\tath10k_warn(ar, \"failed to request monitor vdev %i stop: %d\\n\",\n\t\t\t    ar->monitor_vdev_id, ret);\n\n\tret = ath10k_vdev_setup_sync(ar);\n\tif (ret)\n\t\tath10k_warn(ar, \"failed to synchronize monitor vdev %i stop: %d\\n\",\n\t\t\t    ar->monitor_vdev_id, ret);\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac monitor vdev %i stopped\\n\",\n\t\t   ar->monitor_vdev_id);\n\treturn ret;\n}\n\nstatic int ath10k_monitor_vdev_create(struct ath10k *ar)\n{\n\tint bit, ret = 0;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (ar->free_vdev_map == 0) {\n\t\tath10k_warn(ar, \"failed to find free vdev id for monitor vdev\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tbit = __ffs64(ar->free_vdev_map);\n\n\tar->monitor_vdev_id = bit;\n\n\tret = ath10k_wmi_vdev_create(ar, ar->monitor_vdev_id,\n\t\t\t\t     WMI_VDEV_TYPE_MONITOR,\n\t\t\t\t     0, ar->mac_addr);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to request monitor vdev %i creation: %d\\n\",\n\t\t\t    ar->monitor_vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\tar->free_vdev_map &= ~(1LL << ar->monitor_vdev_id);\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac monitor vdev %d created\\n\",\n\t\t   ar->monitor_vdev_id);\n\n\treturn 0;\n}\n\nstatic int ath10k_monitor_vdev_delete(struct ath10k *ar)\n{\n\tint ret = 0;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tret = ath10k_wmi_vdev_delete(ar, ar->monitor_vdev_id);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to request wmi monitor vdev %i removal: %d\\n\",\n\t\t\t    ar->monitor_vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\tar->free_vdev_map |= 1LL << ar->monitor_vdev_id;\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac monitor vdev %d deleted\\n\",\n\t\t   ar->monitor_vdev_id);\n\treturn ret;\n}\n\nstatic int ath10k_monitor_start(struct ath10k *ar)\n{\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tret = ath10k_monitor_vdev_create(ar);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to create monitor vdev: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ath10k_monitor_vdev_start(ar, ar->monitor_vdev_id);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to start monitor vdev: %d\\n\", ret);\n\t\tath10k_monitor_vdev_delete(ar);\n\t\treturn ret;\n\t}\n\n\tar->monitor_started = true;\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac monitor started\\n\");\n\n\treturn 0;\n}\n\nstatic int ath10k_monitor_stop(struct ath10k *ar)\n{\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tret = ath10k_monitor_vdev_stop(ar);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to stop monitor vdev: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ath10k_monitor_vdev_delete(ar);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to delete monitor vdev: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tar->monitor_started = false;\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac monitor stopped\\n\");\n\n\treturn 0;\n}\n\nstatic bool ath10k_mac_monitor_vdev_is_needed(struct ath10k *ar)\n{\n\tint num_ctx;\n\n\t \n\tnum_ctx = ath10k_mac_num_chanctxs(ar);\n\tif (num_ctx == 0)\n\t\treturn false;\n\n\t \n\tif (ar->monitor_arvif)\n\t\treturn false;\n\n\treturn ar->monitor ||\n\t       (!test_bit(ATH10K_FW_FEATURE_ALLOWS_MESH_BCAST,\n\t\t\t  ar->running_fw->fw_file.fw_features) &&\n\t\t(ar->filter_flags & FIF_OTHER_BSS)) ||\n\t       test_bit(ATH10K_CAC_RUNNING, &ar->dev_flags);\n}\n\nstatic bool ath10k_mac_monitor_vdev_is_allowed(struct ath10k *ar)\n{\n\tint num_ctx;\n\n\tnum_ctx = ath10k_mac_num_chanctxs(ar);\n\n\t \n\tif (test_bit(ATH10K_CAC_RUNNING, &ar->dev_flags) && num_ctx > 1)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int ath10k_monitor_recalc(struct ath10k *ar)\n{\n\tbool needed;\n\tbool allowed;\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tneeded = ath10k_mac_monitor_vdev_is_needed(ar);\n\tallowed = ath10k_mac_monitor_vdev_is_allowed(ar);\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC,\n\t\t   \"mac monitor recalc started? %d needed? %d allowed? %d\\n\",\n\t\t   ar->monitor_started, needed, allowed);\n\n\tif (WARN_ON(needed && !allowed)) {\n\t\tif (ar->monitor_started) {\n\t\t\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac monitor stopping disallowed monitor\\n\");\n\n\t\t\tret = ath10k_monitor_stop(ar);\n\t\t\tif (ret)\n\t\t\t\tath10k_warn(ar, \"failed to stop disallowed monitor: %d\\n\",\n\t\t\t\t\t    ret);\n\t\t\t\t \n\t\t}\n\n\t\treturn -EPERM;\n\t}\n\n\tif (needed == ar->monitor_started)\n\t\treturn 0;\n\n\tif (needed)\n\t\treturn ath10k_monitor_start(ar);\n\telse\n\t\treturn ath10k_monitor_stop(ar);\n}\n\nstatic bool ath10k_mac_can_set_cts_prot(struct ath10k_vif *arvif)\n{\n\tstruct ath10k *ar = arvif->ar;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (!arvif->is_started) {\n\t\tath10k_dbg(ar, ATH10K_DBG_MAC, \"defer cts setup, vdev is not ready yet\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int ath10k_mac_set_cts_prot(struct ath10k_vif *arvif)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tu32 vdev_param;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tvdev_param = ar->wmi.vdev_param->protection_mode;\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac vdev %d cts_protection %d\\n\",\n\t\t   arvif->vdev_id, arvif->use_cts_prot);\n\n\treturn ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, vdev_param,\n\t\t\t\t\t arvif->use_cts_prot ? 1 : 0);\n}\n\nstatic int ath10k_recalc_rtscts_prot(struct ath10k_vif *arvif)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tu32 vdev_param, rts_cts = 0;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tvdev_param = ar->wmi.vdev_param->enable_rtscts;\n\n\trts_cts |= SM(WMI_RTSCTS_ENABLED, WMI_RTSCTS_SET);\n\n\tif (arvif->num_legacy_stations > 0)\n\t\trts_cts |= SM(WMI_RTSCTS_ACROSS_SW_RETRIES,\n\t\t\t      WMI_RTSCTS_PROFILE);\n\telse\n\t\trts_cts |= SM(WMI_RTSCTS_FOR_SECOND_RATESERIES,\n\t\t\t      WMI_RTSCTS_PROFILE);\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac vdev %d recalc rts/cts prot %d\\n\",\n\t\t   arvif->vdev_id, rts_cts);\n\n\treturn ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, vdev_param,\n\t\t\t\t\t rts_cts);\n}\n\nstatic int ath10k_start_cac(struct ath10k *ar)\n{\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tset_bit(ATH10K_CAC_RUNNING, &ar->dev_flags);\n\n\tret = ath10k_monitor_recalc(ar);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to start monitor (cac): %d\\n\", ret);\n\t\tclear_bit(ATH10K_CAC_RUNNING, &ar->dev_flags);\n\t\treturn ret;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac cac start monitor vdev %d\\n\",\n\t\t   ar->monitor_vdev_id);\n\n\treturn 0;\n}\n\nstatic int ath10k_stop_cac(struct ath10k *ar)\n{\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\t \n\tif (!test_bit(ATH10K_CAC_RUNNING, &ar->dev_flags))\n\t\treturn 0;\n\n\tclear_bit(ATH10K_CAC_RUNNING, &ar->dev_flags);\n\tath10k_monitor_stop(ar);\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac cac finished\\n\");\n\n\treturn 0;\n}\n\nstatic void ath10k_mac_has_radar_iter(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_chanctx_conf *conf,\n\t\t\t\t      void *data)\n{\n\tbool *ret = data;\n\n\tif (!*ret && conf->radar_enabled)\n\t\t*ret = true;\n}\n\nstatic bool ath10k_mac_has_radar_enabled(struct ath10k *ar)\n{\n\tbool has_radar = false;\n\n\tieee80211_iter_chan_contexts_atomic(ar->hw,\n\t\t\t\t\t    ath10k_mac_has_radar_iter,\n\t\t\t\t\t    &has_radar);\n\n\treturn has_radar;\n}\n\nstatic void ath10k_recalc_radar_detection(struct ath10k *ar)\n{\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tath10k_stop_cac(ar);\n\n\tif (!ath10k_mac_has_radar_enabled(ar))\n\t\treturn;\n\n\tif (ar->num_started_vdevs > 0)\n\t\treturn;\n\n\tret = ath10k_start_cac(ar);\n\tif (ret) {\n\t\t \n\t\tath10k_warn(ar, \"failed to start CAC: %d\\n\", ret);\n\t\tieee80211_radar_detected(ar->hw);\n\t}\n}\n\nstatic int ath10k_vdev_stop(struct ath10k_vif *arvif)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\treinit_completion(&ar->vdev_setup_done);\n\treinit_completion(&ar->vdev_delete_done);\n\n\tret = ath10k_wmi_vdev_stop(ar, arvif->vdev_id);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to stop WMI vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\tret = ath10k_vdev_setup_sync(ar);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to synchronize setup for vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\tWARN_ON(ar->num_started_vdevs == 0);\n\n\tif (ar->num_started_vdevs != 0) {\n\t\tar->num_started_vdevs--;\n\t\tath10k_recalc_radar_detection(ar);\n\t}\n\n\treturn ret;\n}\n\nstatic int ath10k_vdev_start_restart(struct ath10k_vif *arvif,\n\t\t\t\t     const struct cfg80211_chan_def *chandef,\n\t\t\t\t     bool restart)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tstruct wmi_vdev_start_request_arg arg = {};\n\tint ret = 0;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\treinit_completion(&ar->vdev_setup_done);\n\treinit_completion(&ar->vdev_delete_done);\n\n\targ.vdev_id = arvif->vdev_id;\n\targ.dtim_period = arvif->dtim_period;\n\targ.bcn_intval = arvif->beacon_interval;\n\n\targ.channel.freq = chandef->chan->center_freq;\n\targ.channel.band_center_freq1 = chandef->center_freq1;\n\targ.channel.band_center_freq2 = chandef->center_freq2;\n\targ.channel.mode = chan_to_phymode(chandef);\n\n\targ.channel.min_power = 0;\n\targ.channel.max_power = chandef->chan->max_power * 2;\n\targ.channel.max_reg_power = chandef->chan->max_reg_power * 2;\n\targ.channel.max_antenna_gain = chandef->chan->max_antenna_gain;\n\n\tif (arvif->vdev_type == WMI_VDEV_TYPE_AP) {\n\t\targ.ssid = arvif->u.ap.ssid;\n\t\targ.ssid_len = arvif->u.ap.ssid_len;\n\t\targ.hidden_ssid = arvif->u.ap.hidden_ssid;\n\n\t\t \n\t\targ.channel.chan_radar =\n\t\t\t!!(chandef->chan->flags & IEEE80211_CHAN_RADAR);\n\t} else if (arvif->vdev_type == WMI_VDEV_TYPE_IBSS) {\n\t\targ.ssid = arvif->vif->cfg.ssid;\n\t\targ.ssid_len = arvif->vif->cfg.ssid_len;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC,\n\t\t   \"mac vdev %d start center_freq %d phymode %s\\n\",\n\t\t   arg.vdev_id, arg.channel.freq,\n\t\t   ath10k_wmi_phymode_str(arg.channel.mode));\n\n\tif (restart)\n\t\tret = ath10k_wmi_vdev_restart(ar, &arg);\n\telse\n\t\tret = ath10k_wmi_vdev_start(ar, &arg);\n\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to start WMI vdev %i: %d\\n\",\n\t\t\t    arg.vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\tret = ath10k_vdev_setup_sync(ar);\n\tif (ret) {\n\t\tath10k_warn(ar,\n\t\t\t    \"failed to synchronize setup for vdev %i restart %d: %d\\n\",\n\t\t\t    arg.vdev_id, restart, ret);\n\t\treturn ret;\n\t}\n\n\tar->num_started_vdevs++;\n\tath10k_recalc_radar_detection(ar);\n\n\treturn ret;\n}\n\nstatic int ath10k_vdev_start(struct ath10k_vif *arvif,\n\t\t\t     const struct cfg80211_chan_def *def)\n{\n\treturn ath10k_vdev_start_restart(arvif, def, false);\n}\n\nstatic int ath10k_vdev_restart(struct ath10k_vif *arvif,\n\t\t\t       const struct cfg80211_chan_def *def)\n{\n\treturn ath10k_vdev_start_restart(arvif, def, true);\n}\n\nstatic int ath10k_mac_setup_bcn_p2p_ie(struct ath10k_vif *arvif,\n\t\t\t\t       struct sk_buff *bcn)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tstruct ieee80211_mgmt *mgmt;\n\tconst u8 *p2p_ie;\n\tint ret;\n\n\tif (arvif->vif->type != NL80211_IFTYPE_AP || !arvif->vif->p2p)\n\t\treturn 0;\n\n\tmgmt = (void *)bcn->data;\n\tp2p_ie = cfg80211_find_vendor_ie(WLAN_OUI_WFA, WLAN_OUI_TYPE_WFA_P2P,\n\t\t\t\t\t mgmt->u.beacon.variable,\n\t\t\t\t\t bcn->len - (mgmt->u.beacon.variable -\n\t\t\t\t\t\t     bcn->data));\n\tif (!p2p_ie)\n\t\treturn -ENOENT;\n\n\tret = ath10k_wmi_p2p_go_bcn_ie(ar, arvif->vdev_id, p2p_ie);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to submit p2p go bcn ie for vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_mac_remove_vendor_ie(struct sk_buff *skb, unsigned int oui,\n\t\t\t\t       u8 oui_type, size_t ie_offset)\n{\n\tsize_t len;\n\tconst u8 *next;\n\tconst u8 *end;\n\tu8 *ie;\n\n\tif (WARN_ON(skb->len < ie_offset))\n\t\treturn -EINVAL;\n\n\tie = (u8 *)cfg80211_find_vendor_ie(oui, oui_type,\n\t\t\t\t\t   skb->data + ie_offset,\n\t\t\t\t\t   skb->len - ie_offset);\n\tif (!ie)\n\t\treturn -ENOENT;\n\n\tlen = ie[1] + 2;\n\tend = skb->data + skb->len;\n\tnext = ie + len;\n\n\tif (WARN_ON(next > end))\n\t\treturn -EINVAL;\n\n\tmemmove(ie, next, end - next);\n\tskb_trim(skb, skb->len - len);\n\n\treturn 0;\n}\n\nstatic int ath10k_mac_setup_bcn_tmpl(struct ath10k_vif *arvif)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tstruct ieee80211_hw *hw = ar->hw;\n\tstruct ieee80211_vif *vif = arvif->vif;\n\tstruct ieee80211_mutable_offsets offs = {};\n\tstruct sk_buff *bcn;\n\tint ret;\n\n\tif (!test_bit(WMI_SERVICE_BEACON_OFFLOAD, ar->wmi.svc_map))\n\t\treturn 0;\n\n\tif (arvif->vdev_type != WMI_VDEV_TYPE_AP &&\n\t    arvif->vdev_type != WMI_VDEV_TYPE_IBSS)\n\t\treturn 0;\n\n\tbcn = ieee80211_beacon_get_template(hw, vif, &offs, 0);\n\tif (!bcn) {\n\t\tath10k_warn(ar, \"failed to get beacon template from mac80211\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tret = ath10k_mac_setup_bcn_p2p_ie(arvif, bcn);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to setup p2p go bcn ie: %d\\n\", ret);\n\t\tkfree_skb(bcn);\n\t\treturn ret;\n\t}\n\n\t \n\tath10k_mac_remove_vendor_ie(bcn, WLAN_OUI_WFA, WLAN_OUI_TYPE_WFA_P2P,\n\t\t\t\t    offsetof(struct ieee80211_mgmt,\n\t\t\t\t\t     u.beacon.variable));\n\n\tret = ath10k_wmi_bcn_tmpl(ar, arvif->vdev_id, offs.tim_offset, bcn, 0,\n\t\t\t\t  0, NULL, 0);\n\tkfree_skb(bcn);\n\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to submit beacon template command: %d\\n\",\n\t\t\t    ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_mac_setup_prb_tmpl(struct ath10k_vif *arvif)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tstruct ieee80211_hw *hw = ar->hw;\n\tstruct ieee80211_vif *vif = arvif->vif;\n\tstruct sk_buff *prb;\n\tint ret;\n\n\tif (!test_bit(WMI_SERVICE_BEACON_OFFLOAD, ar->wmi.svc_map))\n\t\treturn 0;\n\n\tif (arvif->vdev_type != WMI_VDEV_TYPE_AP)\n\t\treturn 0;\n\n\t  \n\tif (ieee80211_vif_is_mesh(vif))\n\t\treturn 0;\n\n\tprb = ieee80211_proberesp_get(hw, vif);\n\tif (!prb) {\n\t\tath10k_warn(ar, \"failed to get probe resp template from mac80211\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tret = ath10k_wmi_prb_tmpl(ar, arvif->vdev_id, prb);\n\tkfree_skb(prb);\n\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to submit probe resp template command: %d\\n\",\n\t\t\t    ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_mac_vif_fix_hidden_ssid(struct ath10k_vif *arvif)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tstruct cfg80211_chan_def def;\n\tint ret;\n\n\t \n\tif (!test_bit(WMI_SERVICE_BEACON_OFFLOAD, ar->wmi.svc_map))\n\t\treturn 0;\n\n\tif (WARN_ON(!arvif->is_started))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(!arvif->is_up))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(ath10k_mac_vif_chan(arvif->vif, &def)))\n\t\treturn -EINVAL;\n\n\tret = ath10k_wmi_vdev_down(ar, arvif->vdev_id);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to bring down ap vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\t \n\n\tret = ath10k_mac_setup_bcn_tmpl(arvif);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to update beacon template: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ath10k_mac_setup_prb_tmpl(arvif);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to update presp template: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ath10k_vdev_restart(arvif, &def);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to restart ap vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\tret = ath10k_wmi_vdev_up(arvif->ar, arvif->vdev_id, arvif->aid,\n\t\t\t\t arvif->bssid);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to bring up ap vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void ath10k_control_beaconing(struct ath10k_vif *arvif,\n\t\t\t\t     struct ieee80211_bss_conf *info)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tint ret = 0;\n\n\tlockdep_assert_held(&arvif->ar->conf_mutex);\n\n\tif (!info->enable_beacon) {\n\t\tret = ath10k_wmi_vdev_down(ar, arvif->vdev_id);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to down vdev_id %i: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\n\t\tarvif->is_up = false;\n\n\t\tspin_lock_bh(&arvif->ar->data_lock);\n\t\tath10k_mac_vif_beacon_free(arvif);\n\t\tspin_unlock_bh(&arvif->ar->data_lock);\n\n\t\treturn;\n\t}\n\n\tarvif->tx_seq_no = 0x1000;\n\n\tarvif->aid = 0;\n\tether_addr_copy(arvif->bssid, info->bssid);\n\n\tret = ath10k_wmi_vdev_up(arvif->ar, arvif->vdev_id, arvif->aid,\n\t\t\t\t arvif->bssid);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to bring up vdev %d: %i\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn;\n\t}\n\n\tarvif->is_up = true;\n\n\tret = ath10k_mac_vif_fix_hidden_ssid(arvif);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to fix hidden ssid for vdev %i, expect trouble: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac vdev %d up\\n\", arvif->vdev_id);\n}\n\nstatic void ath10k_control_ibss(struct ath10k_vif *arvif,\n\t\t\t\tstruct ieee80211_vif *vif)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tu32 vdev_param;\n\tint ret = 0;\n\n\tlockdep_assert_held(&arvif->ar->conf_mutex);\n\n\tif (!vif->cfg.ibss_joined) {\n\t\tif (is_zero_ether_addr(arvif->bssid))\n\t\t\treturn;\n\n\t\teth_zero_addr(arvif->bssid);\n\n\t\treturn;\n\t}\n\n\tvdev_param = arvif->ar->wmi.vdev_param->atim_window;\n\tret = ath10k_wmi_vdev_set_param(arvif->ar, arvif->vdev_id, vdev_param,\n\t\t\t\t\tATH10K_DEFAULT_ATIM);\n\tif (ret)\n\t\tath10k_warn(ar, \"failed to set IBSS ATIM for vdev %d: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n}\n\nstatic int ath10k_mac_vif_recalc_ps_wake_threshold(struct ath10k_vif *arvif)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tu32 param;\n\tu32 value;\n\tint ret;\n\n\tlockdep_assert_held(&arvif->ar->conf_mutex);\n\n\tif (arvif->u.sta.uapsd)\n\t\tvalue = WMI_STA_PS_TX_WAKE_THRESHOLD_NEVER;\n\telse\n\t\tvalue = WMI_STA_PS_TX_WAKE_THRESHOLD_ALWAYS;\n\n\tparam = WMI_STA_PS_PARAM_TX_WAKE_THRESHOLD;\n\tret = ath10k_wmi_set_sta_ps_param(ar, arvif->vdev_id, param, value);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to submit ps wake threshold %u on vdev %i: %d\\n\",\n\t\t\t    value, arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_mac_vif_recalc_ps_poll_count(struct ath10k_vif *arvif)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tu32 param;\n\tu32 value;\n\tint ret;\n\n\tlockdep_assert_held(&arvif->ar->conf_mutex);\n\n\tif (arvif->u.sta.uapsd)\n\t\tvalue = WMI_STA_PS_PSPOLL_COUNT_UAPSD;\n\telse\n\t\tvalue = WMI_STA_PS_PSPOLL_COUNT_NO_MAX;\n\n\tparam = WMI_STA_PS_PARAM_PSPOLL_COUNT;\n\tret = ath10k_wmi_set_sta_ps_param(ar, arvif->vdev_id,\n\t\t\t\t\t  param, value);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to submit ps poll count %u on vdev %i: %d\\n\",\n\t\t\t    value, arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_mac_num_vifs_started(struct ath10k *ar)\n{\n\tstruct ath10k_vif *arvif;\n\tint num = 0;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tlist_for_each_entry(arvif, &ar->arvifs, list)\n\t\tif (arvif->is_started)\n\t\t\tnum++;\n\n\treturn num;\n}\n\nstatic int ath10k_mac_vif_setup_ps(struct ath10k_vif *arvif)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tstruct ieee80211_vif *vif = arvif->vif;\n\tstruct ieee80211_conf *conf = &ar->hw->conf;\n\tenum wmi_sta_powersave_param param;\n\tenum wmi_sta_ps_mode psmode;\n\tint ret;\n\tint ps_timeout;\n\tbool enable_ps;\n\n\tlockdep_assert_held(&arvif->ar->conf_mutex);\n\n\tif (arvif->vif->type != NL80211_IFTYPE_STATION)\n\t\treturn 0;\n\n\tenable_ps = arvif->ps;\n\n\tif (enable_ps && ath10k_mac_num_vifs_started(ar) > 1 &&\n\t    !test_bit(ATH10K_FW_FEATURE_MULTI_VIF_PS_SUPPORT,\n\t\t      ar->running_fw->fw_file.fw_features)) {\n\t\tath10k_warn(ar, \"refusing to enable ps on vdev %i: not supported by fw\\n\",\n\t\t\t    arvif->vdev_id);\n\t\tenable_ps = false;\n\t}\n\n\tif (!arvif->is_started) {\n\t\t \n\t\tpsmode = WMI_STA_PS_MODE_ENABLED;\n\t} else if (enable_ps) {\n\t\tpsmode = WMI_STA_PS_MODE_ENABLED;\n\t\tparam = WMI_STA_PS_PARAM_INACTIVITY_TIME;\n\n\t\tps_timeout = conf->dynamic_ps_timeout;\n\t\tif (ps_timeout == 0) {\n\t\t\t \n\t\t\tps_timeout = ieee80211_tu_to_usec(\n\t\t\t\tvif->bss_conf.beacon_int) / 1000;\n\t\t}\n\n\t\tret = ath10k_wmi_set_sta_ps_param(ar, arvif->vdev_id, param,\n\t\t\t\t\t\t  ps_timeout);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to set inactivity time for vdev %d: %i\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tpsmode = WMI_STA_PS_MODE_DISABLED;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac vdev %d psmode %s\\n\",\n\t\t   arvif->vdev_id, psmode ? \"enable\" : \"disable\");\n\n\tret = ath10k_wmi_set_psmode(ar, arvif->vdev_id, psmode);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set PS Mode %d for vdev %d: %d\\n\",\n\t\t\t    psmode, arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_mac_vif_disable_keepalive(struct ath10k_vif *arvif)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tstruct wmi_sta_keepalive_arg arg = {};\n\tint ret;\n\n\tlockdep_assert_held(&arvif->ar->conf_mutex);\n\n\tif (arvif->vdev_type != WMI_VDEV_TYPE_STA)\n\t\treturn 0;\n\n\tif (!test_bit(WMI_SERVICE_STA_KEEP_ALIVE, ar->wmi.svc_map))\n\t\treturn 0;\n\n\t \n\targ.vdev_id = arvif->vdev_id;\n\targ.enabled = 1;\n\targ.method = WMI_STA_KEEPALIVE_METHOD_NULL_FRAME;\n\targ.interval = WMI_STA_KEEPALIVE_INTERVAL_DISABLE;\n\n\tret = ath10k_wmi_sta_keepalive(ar, &arg);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to submit keepalive on vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void ath10k_mac_vif_ap_csa_count_down(struct ath10k_vif *arvif)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tstruct ieee80211_vif *vif = arvif->vif;\n\tint ret;\n\n\tlockdep_assert_held(&arvif->ar->conf_mutex);\n\n\tif (WARN_ON(!test_bit(WMI_SERVICE_BEACON_OFFLOAD, ar->wmi.svc_map)))\n\t\treturn;\n\n\tif (arvif->vdev_type != WMI_VDEV_TYPE_AP)\n\t\treturn;\n\n\tif (!vif->bss_conf.csa_active)\n\t\treturn;\n\n\tif (!arvif->is_up)\n\t\treturn;\n\n\tif (!ieee80211_beacon_cntdwn_is_complete(vif)) {\n\t\tieee80211_beacon_update_cntdwn(vif);\n\n\t\tret = ath10k_mac_setup_bcn_tmpl(arvif);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to update bcn tmpl during csa: %d\\n\",\n\t\t\t\t    ret);\n\n\t\tret = ath10k_mac_setup_prb_tmpl(arvif);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to update prb tmpl during csa: %d\\n\",\n\t\t\t\t    ret);\n\t} else {\n\t\tieee80211_csa_finish(vif);\n\t}\n}\n\nstatic void ath10k_mac_vif_ap_csa_work(struct work_struct *work)\n{\n\tstruct ath10k_vif *arvif = container_of(work, struct ath10k_vif,\n\t\t\t\t\t\tap_csa_work);\n\tstruct ath10k *ar = arvif->ar;\n\n\tmutex_lock(&ar->conf_mutex);\n\tath10k_mac_vif_ap_csa_count_down(arvif);\n\tmutex_unlock(&ar->conf_mutex);\n}\n\nstatic void ath10k_mac_handle_beacon_iter(void *data, u8 *mac,\n\t\t\t\t\t  struct ieee80211_vif *vif)\n{\n\tstruct sk_buff *skb = data;\n\tstruct ieee80211_mgmt *mgmt = (void *)skb->data;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\n\tif (vif->type != NL80211_IFTYPE_STATION)\n\t\treturn;\n\n\tif (!ether_addr_equal(mgmt->bssid, vif->bss_conf.bssid))\n\t\treturn;\n\n\tcancel_delayed_work(&arvif->connection_loss_work);\n}\n\nvoid ath10k_mac_handle_beacon(struct ath10k *ar, struct sk_buff *skb)\n{\n\tieee80211_iterate_active_interfaces_atomic(ar->hw,\n\t\t\t\t\t\t   ATH10K_ITER_NORMAL_FLAGS,\n\t\t\t\t\t\t   ath10k_mac_handle_beacon_iter,\n\t\t\t\t\t\t   skb);\n}\n\nstatic void ath10k_mac_handle_beacon_miss_iter(void *data, u8 *mac,\n\t\t\t\t\t       struct ieee80211_vif *vif)\n{\n\tu32 *vdev_id = data;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct ath10k *ar = arvif->ar;\n\tstruct ieee80211_hw *hw = ar->hw;\n\n\tif (arvif->vdev_id != *vdev_id)\n\t\treturn;\n\n\tif (!arvif->is_up)\n\t\treturn;\n\n\tieee80211_beacon_loss(vif);\n\n\t \n\tieee80211_queue_delayed_work(hw, &arvif->connection_loss_work,\n\t\t\t\t     ATH10K_CONNECTION_LOSS_HZ);\n}\n\nvoid ath10k_mac_handle_beacon_miss(struct ath10k *ar, u32 vdev_id)\n{\n\tieee80211_iterate_active_interfaces_atomic(ar->hw,\n\t\t\t\t\t\t   ATH10K_ITER_NORMAL_FLAGS,\n\t\t\t\t\t\t   ath10k_mac_handle_beacon_miss_iter,\n\t\t\t\t\t\t   &vdev_id);\n}\n\nstatic void ath10k_mac_vif_sta_connection_loss_work(struct work_struct *work)\n{\n\tstruct ath10k_vif *arvif = container_of(work, struct ath10k_vif,\n\t\t\t\t\t\tconnection_loss_work.work);\n\tstruct ieee80211_vif *vif = arvif->vif;\n\n\tif (!arvif->is_up)\n\t\treturn;\n\n\tieee80211_connection_loss(vif);\n}\n\n \n \n \n\nstatic u32 ath10k_peer_assoc_h_listen_intval(struct ath10k *ar,\n\t\t\t\t\t     struct ieee80211_vif *vif)\n{\n\t \n\tif (vif->type == NL80211_IFTYPE_STATION)\n\t\treturn 1;\n\n\treturn ar->hw->conf.listen_interval;\n}\n\nstatic void ath10k_peer_assoc_h_basic(struct ath10k *ar,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      struct ieee80211_sta *sta,\n\t\t\t\t      struct wmi_peer_assoc_complete_arg *arg)\n{\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tu32 aid;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (vif->type == NL80211_IFTYPE_STATION)\n\t\taid = vif->cfg.aid;\n\telse\n\t\taid = sta->aid;\n\n\tether_addr_copy(arg->addr, sta->addr);\n\targ->vdev_id = arvif->vdev_id;\n\targ->peer_aid = aid;\n\targ->peer_flags |= arvif->ar->wmi.peer_flags->auth;\n\targ->peer_listen_intval = ath10k_peer_assoc_h_listen_intval(ar, vif);\n\targ->peer_num_spatial_streams = 1;\n\targ->peer_caps = vif->bss_conf.assoc_capability;\n}\n\nstatic void ath10k_peer_assoc_h_crypto(struct ath10k *ar,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       struct ieee80211_sta *sta,\n\t\t\t\t       struct wmi_peer_assoc_complete_arg *arg)\n{\n\tstruct ieee80211_bss_conf *info = &vif->bss_conf;\n\tstruct cfg80211_chan_def def;\n\tstruct cfg80211_bss *bss;\n\tconst u8 *rsnie = NULL;\n\tconst u8 *wpaie = NULL;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (WARN_ON(ath10k_mac_vif_chan(vif, &def)))\n\t\treturn;\n\n\tbss = cfg80211_get_bss(ar->hw->wiphy, def.chan, info->bssid,\n\t\t\t       vif->cfg.ssid_len ? vif->cfg.ssid : NULL,\n\t\t\t       vif->cfg.ssid_len,\n\t\t\t       IEEE80211_BSS_TYPE_ANY, IEEE80211_PRIVACY_ANY);\n\tif (bss) {\n\t\tconst struct cfg80211_bss_ies *ies;\n\n\t\trcu_read_lock();\n\t\trsnie = ieee80211_bss_get_ie(bss, WLAN_EID_RSN);\n\n\t\ties = rcu_dereference(bss->ies);\n\n\t\twpaie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t\tWLAN_OUI_TYPE_MICROSOFT_WPA,\n\t\t\t\t\t\ties->data,\n\t\t\t\t\t\ties->len);\n\t\trcu_read_unlock();\n\t\tcfg80211_put_bss(ar->hw->wiphy, bss);\n\t}\n\n\t \n\tif (rsnie || wpaie) {\n\t\tath10k_dbg(ar, ATH10K_DBG_WMI, \"%s: rsn ie found\\n\", __func__);\n\t\targ->peer_flags |= ar->wmi.peer_flags->need_ptk_4_way;\n\t}\n\n\tif (wpaie) {\n\t\tath10k_dbg(ar, ATH10K_DBG_WMI, \"%s: wpa ie found\\n\", __func__);\n\t\targ->peer_flags |= ar->wmi.peer_flags->need_gtk_2_way;\n\t}\n\n\tif (sta->mfp &&\n\t    test_bit(ATH10K_FW_FEATURE_MFP_SUPPORT,\n\t\t     ar->running_fw->fw_file.fw_features)) {\n\t\targ->peer_flags |= ar->wmi.peer_flags->pmf;\n\t}\n}\n\nstatic void ath10k_peer_assoc_h_rates(struct ath10k *ar,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      struct ieee80211_sta *sta,\n\t\t\t\t      struct wmi_peer_assoc_complete_arg *arg)\n{\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct wmi_rate_set_arg *rateset = &arg->peer_legacy_rates;\n\tstruct cfg80211_chan_def def;\n\tconst struct ieee80211_supported_band *sband;\n\tconst struct ieee80211_rate *rates;\n\tenum nl80211_band band;\n\tu32 ratemask;\n\tu8 rate;\n\tint i;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (WARN_ON(ath10k_mac_vif_chan(vif, &def)))\n\t\treturn;\n\n\tband = def.chan->band;\n\tsband = ar->hw->wiphy->bands[band];\n\tratemask = sta->deflink.supp_rates[band];\n\tratemask &= arvif->bitrate_mask.control[band].legacy;\n\trates = sband->bitrates;\n\n\trateset->num_rates = 0;\n\n\tfor (i = 0; i < 32; i++, ratemask >>= 1, rates++) {\n\t\tif (!(ratemask & 1))\n\t\t\tcontinue;\n\n\t\trate = ath10k_mac_bitrate_to_rate(rates->bitrate);\n\t\trateset->rates[rateset->num_rates] = rate;\n\t\trateset->num_rates++;\n\t}\n}\n\nstatic bool\nath10k_peer_assoc_h_ht_masked(const u8 ht_mcs_mask[IEEE80211_HT_MCS_MASK_LEN])\n{\n\tint nss;\n\n\tfor (nss = 0; nss < IEEE80211_HT_MCS_MASK_LEN; nss++)\n\t\tif (ht_mcs_mask[nss])\n\t\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool\nath10k_peer_assoc_h_vht_masked(const u16 vht_mcs_mask[NL80211_VHT_NSS_MAX])\n{\n\tint nss;\n\n\tfor (nss = 0; nss < NL80211_VHT_NSS_MAX; nss++)\n\t\tif (vht_mcs_mask[nss])\n\t\t\treturn false;\n\n\treturn true;\n}\n\nstatic void ath10k_peer_assoc_h_ht(struct ath10k *ar,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   struct ieee80211_sta *sta,\n\t\t\t\t   struct wmi_peer_assoc_complete_arg *arg)\n{\n\tconst struct ieee80211_sta_ht_cap *ht_cap = &sta->deflink.ht_cap;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct cfg80211_chan_def def;\n\tenum nl80211_band band;\n\tconst u8 *ht_mcs_mask;\n\tconst u16 *vht_mcs_mask;\n\tint i, n;\n\tu8 max_nss;\n\tu32 stbc;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (WARN_ON(ath10k_mac_vif_chan(vif, &def)))\n\t\treturn;\n\n\tif (!ht_cap->ht_supported)\n\t\treturn;\n\n\tband = def.chan->band;\n\tht_mcs_mask = arvif->bitrate_mask.control[band].ht_mcs;\n\tvht_mcs_mask = arvif->bitrate_mask.control[band].vht_mcs;\n\n\tif (ath10k_peer_assoc_h_ht_masked(ht_mcs_mask) &&\n\t    ath10k_peer_assoc_h_vht_masked(vht_mcs_mask))\n\t\treturn;\n\n\targ->peer_flags |= ar->wmi.peer_flags->ht;\n\targ->peer_max_mpdu = (1 << (IEEE80211_HT_MAX_AMPDU_FACTOR +\n\t\t\t\t    ht_cap->ampdu_factor)) - 1;\n\n\targ->peer_mpdu_density =\n\t\tath10k_parse_mpdudensity(ht_cap->ampdu_density);\n\n\targ->peer_ht_caps = ht_cap->cap;\n\targ->peer_rate_caps |= WMI_RC_HT_FLAG;\n\n\tif (ht_cap->cap & IEEE80211_HT_CAP_LDPC_CODING)\n\t\targ->peer_flags |= ar->wmi.peer_flags->ldbc;\n\n\tif (sta->deflink.bandwidth >= IEEE80211_STA_RX_BW_40) {\n\t\targ->peer_flags |= ar->wmi.peer_flags->bw40;\n\t\targ->peer_rate_caps |= WMI_RC_CW40_FLAG;\n\t}\n\n\tif (arvif->bitrate_mask.control[band].gi != NL80211_TXRATE_FORCE_LGI) {\n\t\tif (ht_cap->cap & IEEE80211_HT_CAP_SGI_20)\n\t\t\targ->peer_rate_caps |= WMI_RC_SGI_FLAG;\n\n\t\tif (ht_cap->cap & IEEE80211_HT_CAP_SGI_40)\n\t\t\targ->peer_rate_caps |= WMI_RC_SGI_FLAG;\n\t}\n\n\tif (ht_cap->cap & IEEE80211_HT_CAP_TX_STBC) {\n\t\targ->peer_rate_caps |= WMI_RC_TX_STBC_FLAG;\n\t\targ->peer_flags |= ar->wmi.peer_flags->stbc;\n\t}\n\n\tif (ht_cap->cap & IEEE80211_HT_CAP_RX_STBC) {\n\t\tstbc = ht_cap->cap & IEEE80211_HT_CAP_RX_STBC;\n\t\tstbc = stbc >> IEEE80211_HT_CAP_RX_STBC_SHIFT;\n\t\tstbc = stbc << WMI_RC_RX_STBC_FLAG_S;\n\t\targ->peer_rate_caps |= stbc;\n\t\targ->peer_flags |= ar->wmi.peer_flags->stbc;\n\t}\n\n\tif (ht_cap->mcs.rx_mask[1] && ht_cap->mcs.rx_mask[2])\n\t\targ->peer_rate_caps |= WMI_RC_TS_FLAG;\n\telse if (ht_cap->mcs.rx_mask[1])\n\t\targ->peer_rate_caps |= WMI_RC_DS_FLAG;\n\n\tfor (i = 0, n = 0, max_nss = 0; i < IEEE80211_HT_MCS_MASK_LEN * 8; i++)\n\t\tif ((ht_cap->mcs.rx_mask[i / 8] & BIT(i % 8)) &&\n\t\t    (ht_mcs_mask[i / 8] & BIT(i % 8))) {\n\t\t\tmax_nss = (i / 8) + 1;\n\t\t\targ->peer_ht_rates.rates[n++] = i;\n\t\t}\n\n\t \n\tif (n == 0) {\n\t\targ->peer_ht_rates.num_rates = 8;\n\t\tfor (i = 0; i < arg->peer_ht_rates.num_rates; i++)\n\t\t\targ->peer_ht_rates.rates[i] = i;\n\t} else {\n\t\targ->peer_ht_rates.num_rates = n;\n\t\targ->peer_num_spatial_streams = min(sta->deflink.rx_nss,\n\t\t\t\t\t\t    max_nss);\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac ht peer %pM mcs cnt %d nss %d\\n\",\n\t\t   arg->addr,\n\t\t   arg->peer_ht_rates.num_rates,\n\t\t   arg->peer_num_spatial_streams);\n}\n\nstatic int ath10k_peer_assoc_qos_ap(struct ath10k *ar,\n\t\t\t\t    struct ath10k_vif *arvif,\n\t\t\t\t    struct ieee80211_sta *sta)\n{\n\tu32 uapsd = 0;\n\tu32 max_sp = 0;\n\tint ret = 0;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (sta->wme && sta->uapsd_queues) {\n\t\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac uapsd_queues 0x%x max_sp %d\\n\",\n\t\t\t   sta->uapsd_queues, sta->max_sp);\n\n\t\tif (sta->uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_VO)\n\t\t\tuapsd |= WMI_AP_PS_UAPSD_AC3_DELIVERY_EN |\n\t\t\t\t WMI_AP_PS_UAPSD_AC3_TRIGGER_EN;\n\t\tif (sta->uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_VI)\n\t\t\tuapsd |= WMI_AP_PS_UAPSD_AC2_DELIVERY_EN |\n\t\t\t\t WMI_AP_PS_UAPSD_AC2_TRIGGER_EN;\n\t\tif (sta->uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_BK)\n\t\t\tuapsd |= WMI_AP_PS_UAPSD_AC1_DELIVERY_EN |\n\t\t\t\t WMI_AP_PS_UAPSD_AC1_TRIGGER_EN;\n\t\tif (sta->uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_BE)\n\t\t\tuapsd |= WMI_AP_PS_UAPSD_AC0_DELIVERY_EN |\n\t\t\t\t WMI_AP_PS_UAPSD_AC0_TRIGGER_EN;\n\n\t\tif (sta->max_sp < MAX_WMI_AP_PS_PEER_PARAM_MAX_SP)\n\t\t\tmax_sp = sta->max_sp;\n\n\t\tret = ath10k_wmi_set_ap_ps_param(ar, arvif->vdev_id,\n\t\t\t\t\t\t sta->addr,\n\t\t\t\t\t\t WMI_AP_PS_PEER_PARAM_UAPSD,\n\t\t\t\t\t\t uapsd);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to set ap ps peer param uapsd for vdev %i: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = ath10k_wmi_set_ap_ps_param(ar, arvif->vdev_id,\n\t\t\t\t\t\t sta->addr,\n\t\t\t\t\t\t WMI_AP_PS_PEER_PARAM_MAX_SP,\n\t\t\t\t\t\t max_sp);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to set ap ps peer param max sp for vdev %i: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tret = ath10k_wmi_set_ap_ps_param(ar, arvif->vdev_id, sta->addr,\n\t\t\t\t\t\t WMI_AP_PS_PEER_PARAM_AGEOUT_TIME,\n\t\t\t\t\t\t 10);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to set ap ps peer param ageout time for vdev %i: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic u16\nath10k_peer_assoc_h_vht_limit(u16 tx_mcs_set,\n\t\t\t      const u16 vht_mcs_limit[NL80211_VHT_NSS_MAX])\n{\n\tint idx_limit;\n\tint nss;\n\tu16 mcs_map;\n\tu16 mcs;\n\n\tfor (nss = 0; nss < NL80211_VHT_NSS_MAX; nss++) {\n\t\tmcs_map = ath10k_mac_get_max_vht_mcs_map(tx_mcs_set, nss) &\n\t\t\t  vht_mcs_limit[nss];\n\n\t\tif (mcs_map)\n\t\t\tidx_limit = fls(mcs_map) - 1;\n\t\telse\n\t\t\tidx_limit = -1;\n\n\t\tswitch (idx_limit) {\n\t\tcase 0:\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 3:\n\t\tcase 4:\n\t\tcase 5:\n\t\tcase 6:\n\t\tdefault:\n\t\t\t \n\t\t\tWARN_ON(1);\n\t\t\tfallthrough;\n\t\tcase -1:\n\t\t\tmcs = IEEE80211_VHT_MCS_NOT_SUPPORTED;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tmcs = IEEE80211_VHT_MCS_SUPPORT_0_7;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tmcs = IEEE80211_VHT_MCS_SUPPORT_0_8;\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tmcs = IEEE80211_VHT_MCS_SUPPORT_0_9;\n\t\t\tbreak;\n\t\t}\n\n\t\ttx_mcs_set &= ~(0x3 << (nss * 2));\n\t\ttx_mcs_set |= mcs << (nss * 2);\n\t}\n\n\treturn tx_mcs_set;\n}\n\nstatic u32 get_160mhz_nss_from_maxrate(int rate)\n{\n\tu32 nss;\n\n\tswitch (rate) {\n\tcase 780:\n\t\tnss = 1;\n\t\tbreak;\n\tcase 1560:\n\t\tnss = 2;\n\t\tbreak;\n\tcase 2106:\n\t\tnss = 3;  \n\t\tbreak;\n\tcase 3120:\n\t\tnss = 4;\n\t\tbreak;\n\tdefault:\n\t\t nss = 1;\n\t}\n\n\treturn nss;\n}\n\nstatic void ath10k_peer_assoc_h_vht(struct ath10k *ar,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct ieee80211_sta *sta,\n\t\t\t\t    struct wmi_peer_assoc_complete_arg *arg)\n{\n\tconst struct ieee80211_sta_vht_cap *vht_cap = &sta->deflink.vht_cap;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct ath10k_hw_params *hw = &ar->hw_params;\n\tstruct cfg80211_chan_def def;\n\tenum nl80211_band band;\n\tconst u16 *vht_mcs_mask;\n\tu8 ampdu_factor;\n\tu8 max_nss, vht_mcs;\n\tint i;\n\n\tif (WARN_ON(ath10k_mac_vif_chan(vif, &def)))\n\t\treturn;\n\n\tif (!vht_cap->vht_supported)\n\t\treturn;\n\n\tband = def.chan->band;\n\tvht_mcs_mask = arvif->bitrate_mask.control[band].vht_mcs;\n\n\tif (ath10k_peer_assoc_h_vht_masked(vht_mcs_mask))\n\t\treturn;\n\n\targ->peer_flags |= ar->wmi.peer_flags->vht;\n\n\tif (def.chan->band == NL80211_BAND_2GHZ)\n\t\targ->peer_flags |= ar->wmi.peer_flags->vht_2g;\n\n\targ->peer_vht_caps = vht_cap->cap;\n\n\tampdu_factor = (vht_cap->cap &\n\t\t\tIEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK) >>\n\t\t       IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_SHIFT;\n\n\t \n\targ->peer_max_mpdu = max(arg->peer_max_mpdu,\n\t\t\t\t (1U << (IEEE80211_HT_MAX_AMPDU_FACTOR +\n\t\t\t\t\tampdu_factor)) - 1);\n\n\tif (sta->deflink.bandwidth == IEEE80211_STA_RX_BW_80)\n\t\targ->peer_flags |= ar->wmi.peer_flags->bw80;\n\n\tif (sta->deflink.bandwidth == IEEE80211_STA_RX_BW_160)\n\t\targ->peer_flags |= ar->wmi.peer_flags->bw160;\n\n\t \n\tfor (i = 0, max_nss = 0, vht_mcs = 0; i < NL80211_VHT_NSS_MAX; i++) {\n\t\tvht_mcs = __le16_to_cpu(vht_cap->vht_mcs.rx_mcs_map) >>\n\t\t\t  (2 * i) & 3;\n\n\t\tif ((vht_mcs != IEEE80211_VHT_MCS_NOT_SUPPORTED) &&\n\t\t    vht_mcs_mask[i])\n\t\t\tmax_nss = i + 1;\n\t}\n\targ->peer_num_spatial_streams = min(sta->deflink.rx_nss, max_nss);\n\targ->peer_vht_rates.rx_max_rate =\n\t\t__le16_to_cpu(vht_cap->vht_mcs.rx_highest);\n\targ->peer_vht_rates.rx_mcs_set =\n\t\t__le16_to_cpu(vht_cap->vht_mcs.rx_mcs_map);\n\targ->peer_vht_rates.tx_max_rate =\n\t\t__le16_to_cpu(vht_cap->vht_mcs.tx_highest);\n\targ->peer_vht_rates.tx_mcs_set = ath10k_peer_assoc_h_vht_limit(\n\t\t__le16_to_cpu(vht_cap->vht_mcs.tx_mcs_map), vht_mcs_mask);\n\n\t \n\tif (arg->peer_phymode == MODE_11AC_VHT160 ||\n\t    arg->peer_phymode == MODE_11AC_VHT80_80) {\n\t\tu32 rx_nss;\n\t\tu32 max_rate;\n\n\t\tmax_rate = arg->peer_vht_rates.rx_max_rate;\n\t\trx_nss = get_160mhz_nss_from_maxrate(max_rate);\n\n\t\tif (rx_nss == 0)\n\t\t\trx_nss = arg->peer_num_spatial_streams;\n\t\telse\n\t\t\trx_nss = min(arg->peer_num_spatial_streams, rx_nss);\n\n\t\tmax_rate = hw->vht160_mcs_tx_highest;\n\t\trx_nss = min(rx_nss, get_160mhz_nss_from_maxrate(max_rate));\n\n\t\targ->peer_bw_rxnss_override =\n\t\t\tFIELD_PREP(WMI_PEER_NSS_MAP_ENABLE, 1) |\n\t\t\tFIELD_PREP(WMI_PEER_NSS_160MHZ_MASK, (rx_nss - 1));\n\n\t\tif (arg->peer_phymode == MODE_11AC_VHT80_80) {\n\t\t\targ->peer_bw_rxnss_override |=\n\t\t\tFIELD_PREP(WMI_PEER_NSS_80_80MHZ_MASK, (rx_nss - 1));\n\t\t}\n\t}\n\tath10k_dbg(ar, ATH10K_DBG_MAC,\n\t\t   \"mac vht peer %pM max_mpdu %d flags 0x%x peer_rx_nss_override 0x%x\\n\",\n\t\t   sta->addr, arg->peer_max_mpdu,\n\t\t   arg->peer_flags, arg->peer_bw_rxnss_override);\n}\n\nstatic void ath10k_peer_assoc_h_qos(struct ath10k *ar,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct ieee80211_sta *sta,\n\t\t\t\t    struct wmi_peer_assoc_complete_arg *arg)\n{\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\n\tswitch (arvif->vdev_type) {\n\tcase WMI_VDEV_TYPE_AP:\n\t\tif (sta->wme)\n\t\t\targ->peer_flags |= arvif->ar->wmi.peer_flags->qos;\n\n\t\tif (sta->wme && sta->uapsd_queues) {\n\t\t\targ->peer_flags |= arvif->ar->wmi.peer_flags->apsd;\n\t\t\targ->peer_rate_caps |= WMI_RC_UAPSD_FLAG;\n\t\t}\n\t\tbreak;\n\tcase WMI_VDEV_TYPE_STA:\n\t\tif (sta->wme)\n\t\t\targ->peer_flags |= arvif->ar->wmi.peer_flags->qos;\n\t\tbreak;\n\tcase WMI_VDEV_TYPE_IBSS:\n\t\tif (sta->wme)\n\t\t\targ->peer_flags |= arvif->ar->wmi.peer_flags->qos;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac peer %pM qos %d\\n\",\n\t\t   sta->addr, !!(arg->peer_flags &\n\t\t   arvif->ar->wmi.peer_flags->qos));\n}\n\nstatic bool ath10k_mac_sta_has_ofdm_only(struct ieee80211_sta *sta)\n{\n\treturn sta->deflink.supp_rates[NL80211_BAND_2GHZ] >>\n\t       ATH10K_MAC_FIRST_OFDM_RATE_IDX;\n}\n\nstatic enum wmi_phy_mode ath10k_mac_get_phymode_vht(struct ath10k *ar,\n\t\t\t\t\t\t    struct ieee80211_sta *sta)\n{\n\tstruct ieee80211_sta_vht_cap *vht_cap = &sta->deflink.vht_cap;\n\n\tif (sta->deflink.bandwidth == IEEE80211_STA_RX_BW_160) {\n\t\tswitch (vht_cap->cap & IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK) {\n\t\tcase IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ:\n\t\t\treturn MODE_11AC_VHT160;\n\t\tcase IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ:\n\t\t\treturn MODE_11AC_VHT80_80;\n\t\tdefault:\n\t\t\t \n\t\t\treturn MODE_11AC_VHT160;\n\t\t}\n\t}\n\n\tif (sta->deflink.bandwidth == IEEE80211_STA_RX_BW_80)\n\t\treturn MODE_11AC_VHT80;\n\n\tif (sta->deflink.bandwidth == IEEE80211_STA_RX_BW_40)\n\t\treturn MODE_11AC_VHT40;\n\n\tif (sta->deflink.bandwidth == IEEE80211_STA_RX_BW_20)\n\t\treturn MODE_11AC_VHT20;\n\n\treturn MODE_UNKNOWN;\n}\n\nstatic void ath10k_peer_assoc_h_phymode(struct ath10k *ar,\n\t\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\t\tstruct ieee80211_sta *sta,\n\t\t\t\t\tstruct wmi_peer_assoc_complete_arg *arg)\n{\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct cfg80211_chan_def def;\n\tenum nl80211_band band;\n\tconst u8 *ht_mcs_mask;\n\tconst u16 *vht_mcs_mask;\n\tenum wmi_phy_mode phymode = MODE_UNKNOWN;\n\n\tif (WARN_ON(ath10k_mac_vif_chan(vif, &def)))\n\t\treturn;\n\n\tband = def.chan->band;\n\tht_mcs_mask = arvif->bitrate_mask.control[band].ht_mcs;\n\tvht_mcs_mask = arvif->bitrate_mask.control[band].vht_mcs;\n\n\tswitch (band) {\n\tcase NL80211_BAND_2GHZ:\n\t\tif (sta->deflink.vht_cap.vht_supported &&\n\t\t    !ath10k_peer_assoc_h_vht_masked(vht_mcs_mask)) {\n\t\t\tif (sta->deflink.bandwidth == IEEE80211_STA_RX_BW_40)\n\t\t\t\tphymode = MODE_11AC_VHT40;\n\t\t\telse\n\t\t\t\tphymode = MODE_11AC_VHT20;\n\t\t} else if (sta->deflink.ht_cap.ht_supported &&\n\t\t\t   !ath10k_peer_assoc_h_ht_masked(ht_mcs_mask)) {\n\t\t\tif (sta->deflink.bandwidth == IEEE80211_STA_RX_BW_40)\n\t\t\t\tphymode = MODE_11NG_HT40;\n\t\t\telse\n\t\t\t\tphymode = MODE_11NG_HT20;\n\t\t} else if (ath10k_mac_sta_has_ofdm_only(sta)) {\n\t\t\tphymode = MODE_11G;\n\t\t} else {\n\t\t\tphymode = MODE_11B;\n\t\t}\n\n\t\tbreak;\n\tcase NL80211_BAND_5GHZ:\n\t\t \n\t\tif (sta->deflink.vht_cap.vht_supported &&\n\t\t    !ath10k_peer_assoc_h_vht_masked(vht_mcs_mask)) {\n\t\t\tphymode = ath10k_mac_get_phymode_vht(ar, sta);\n\t\t} else if (sta->deflink.ht_cap.ht_supported &&\n\t\t\t   !ath10k_peer_assoc_h_ht_masked(ht_mcs_mask)) {\n\t\t\tif (sta->deflink.bandwidth >= IEEE80211_STA_RX_BW_40)\n\t\t\t\tphymode = MODE_11NA_HT40;\n\t\t\telse\n\t\t\t\tphymode = MODE_11NA_HT20;\n\t\t} else {\n\t\t\tphymode = MODE_11A;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac peer %pM phymode %s\\n\",\n\t\t   sta->addr, ath10k_wmi_phymode_str(phymode));\n\n\targ->peer_phymode = phymode;\n\tWARN_ON(phymode == MODE_UNKNOWN);\n}\n\nstatic int ath10k_peer_assoc_prepare(struct ath10k *ar,\n\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t     struct ieee80211_sta *sta,\n\t\t\t\t     struct wmi_peer_assoc_complete_arg *arg)\n{\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tmemset(arg, 0, sizeof(*arg));\n\n\tath10k_peer_assoc_h_basic(ar, vif, sta, arg);\n\tath10k_peer_assoc_h_crypto(ar, vif, sta, arg);\n\tath10k_peer_assoc_h_rates(ar, vif, sta, arg);\n\tath10k_peer_assoc_h_ht(ar, vif, sta, arg);\n\tath10k_peer_assoc_h_phymode(ar, vif, sta, arg);\n\tath10k_peer_assoc_h_vht(ar, vif, sta, arg);\n\tath10k_peer_assoc_h_qos(ar, vif, sta, arg);\n\n\treturn 0;\n}\n\nstatic const u32 ath10k_smps_map[] = {\n\t[WLAN_HT_CAP_SM_PS_STATIC] = WMI_PEER_SMPS_STATIC,\n\t[WLAN_HT_CAP_SM_PS_DYNAMIC] = WMI_PEER_SMPS_DYNAMIC,\n\t[WLAN_HT_CAP_SM_PS_INVALID] = WMI_PEER_SMPS_PS_NONE,\n\t[WLAN_HT_CAP_SM_PS_DISABLED] = WMI_PEER_SMPS_PS_NONE,\n};\n\nstatic int ath10k_setup_peer_smps(struct ath10k *ar, struct ath10k_vif *arvif,\n\t\t\t\t  const u8 *addr,\n\t\t\t\t  const struct ieee80211_sta_ht_cap *ht_cap)\n{\n\tint smps;\n\n\tif (!ht_cap->ht_supported)\n\t\treturn 0;\n\n\tsmps = ht_cap->cap & IEEE80211_HT_CAP_SM_PS;\n\tsmps >>= IEEE80211_HT_CAP_SM_PS_SHIFT;\n\n\tif (smps >= ARRAY_SIZE(ath10k_smps_map))\n\t\treturn -EINVAL;\n\n\treturn ath10k_wmi_peer_set_param(ar, arvif->vdev_id, addr,\n\t\t\t\t\t ar->wmi.peer_param->smps_state,\n\t\t\t\t\t ath10k_smps_map[smps]);\n}\n\nstatic int ath10k_mac_vif_recalc_txbf(struct ath10k *ar,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      struct ieee80211_sta_vht_cap vht_cap)\n{\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tint ret;\n\tu32 param;\n\tu32 value;\n\n\tif (ath10k_wmi_get_txbf_conf_scheme(ar) != WMI_TXBF_CONF_AFTER_ASSOC)\n\t\treturn 0;\n\n\tif (!(ar->vht_cap_info &\n\t      (IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE |\n\t       IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE |\n\t       IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE |\n\t       IEEE80211_VHT_CAP_MU_BEAMFORMER_CAPABLE)))\n\t\treturn 0;\n\n\tparam = ar->wmi.vdev_param->txbf;\n\tvalue = 0;\n\n\tif (WARN_ON(param == WMI_VDEV_PARAM_UNSUPPORTED))\n\t\treturn 0;\n\n\t \n\n\tif (ar->vht_cap_info &\n\t    (IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE |\n\t     IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE)) {\n\t\tif (vht_cap.cap & IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE)\n\t\t\tvalue |= WMI_VDEV_PARAM_TXBF_SU_TX_BFEE;\n\n\t\tif (vht_cap.cap & IEEE80211_VHT_CAP_MU_BEAMFORMER_CAPABLE)\n\t\t\tvalue |= WMI_VDEV_PARAM_TXBF_MU_TX_BFEE;\n\t}\n\n\tif (ar->vht_cap_info &\n\t    (IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE |\n\t     IEEE80211_VHT_CAP_MU_BEAMFORMER_CAPABLE)) {\n\t\tif (vht_cap.cap & IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE)\n\t\t\tvalue |= WMI_VDEV_PARAM_TXBF_SU_TX_BFER;\n\n\t\tif (vht_cap.cap & IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE)\n\t\t\tvalue |= WMI_VDEV_PARAM_TXBF_MU_TX_BFER;\n\t}\n\n\tif (value & WMI_VDEV_PARAM_TXBF_MU_TX_BFEE)\n\t\tvalue |= WMI_VDEV_PARAM_TXBF_SU_TX_BFEE;\n\n\tif (value & WMI_VDEV_PARAM_TXBF_MU_TX_BFER)\n\t\tvalue |= WMI_VDEV_PARAM_TXBF_SU_TX_BFER;\n\n\tret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, param, value);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to submit vdev param txbf 0x%x: %d\\n\",\n\t\t\t    value, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic bool ath10k_mac_is_connected(struct ath10k *ar)\n{\n\tstruct ath10k_vif *arvif;\n\n\tlist_for_each_entry(arvif, &ar->arvifs, list) {\n\t\tif (arvif->is_up && arvif->vdev_type == WMI_VDEV_TYPE_STA)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int ath10k_mac_txpower_setup(struct ath10k *ar, int txpower)\n{\n\tint ret;\n\tu32 param;\n\tint tx_power_2g, tx_power_5g;\n\tbool connected;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\t \n\ttx_power_2g = txpower * 2;\n\ttx_power_5g = txpower * 2;\n\n\tconnected = ath10k_mac_is_connected(ar);\n\n\tif (connected && ar->tx_power_2g_limit)\n\t\tif (tx_power_2g > ar->tx_power_2g_limit)\n\t\t\ttx_power_2g = ar->tx_power_2g_limit;\n\n\tif (connected && ar->tx_power_5g_limit)\n\t\tif (tx_power_5g > ar->tx_power_5g_limit)\n\t\t\ttx_power_5g = ar->tx_power_5g_limit;\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac txpower 2g: %d, 5g: %d\\n\",\n\t\t   tx_power_2g, tx_power_5g);\n\n\tparam = ar->wmi.pdev_param->txpower_limit2g;\n\tret = ath10k_wmi_pdev_set_param(ar, param, tx_power_2g);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set 2g txpower %d: %d\\n\",\n\t\t\t    tx_power_2g, ret);\n\t\treturn ret;\n\t}\n\n\tparam = ar->wmi.pdev_param->txpower_limit5g;\n\tret = ath10k_wmi_pdev_set_param(ar, param, tx_power_5g);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set 5g txpower %d: %d\\n\",\n\t\t\t    tx_power_5g, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_mac_txpower_recalc(struct ath10k *ar)\n{\n\tstruct ath10k_vif *arvif;\n\tint ret, txpower = -1;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tlist_for_each_entry(arvif, &ar->arvifs, list) {\n\t\t \n\t\tif (arvif->txpower == INT_MIN)\n\t\t\tcontinue;\n\n\t\tif (txpower == -1)\n\t\t\ttxpower = arvif->txpower;\n\t\telse\n\t\t\ttxpower = min(txpower, arvif->txpower);\n\t}\n\n\tif (txpower == -1)\n\t\treturn 0;\n\n\tret = ath10k_mac_txpower_setup(ar, txpower);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to setup tx power %d: %d\\n\",\n\t\t\t    txpower, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_mac_set_sar_power(struct ath10k *ar)\n{\n\tif (!ar->hw_params.dynamic_sar_support)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!ath10k_mac_is_connected(ar))\n\t\treturn 0;\n\n\t \n\treturn ath10k_mac_txpower_recalc(ar);\n}\n\nstatic int ath10k_mac_set_sar_specs(struct ieee80211_hw *hw,\n\t\t\t\t    const struct cfg80211_sar_specs *sar)\n{\n\tconst struct cfg80211_sar_sub_specs *sub_specs;\n\tstruct ath10k *ar = hw->priv;\n\tu32 i;\n\tint ret;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (!ar->hw_params.dynamic_sar_support) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto err;\n\t}\n\n\tif (!sar || sar->type != NL80211_SAR_TYPE_POWER ||\n\t    sar->num_sub_specs == 0) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tsub_specs = sar->sub_specs;\n\n\t \n\tar->tx_power_2g_limit = 0;\n\tar->tx_power_5g_limit = 0;\n\n\t \n\tfor (i = 0; i < sar->num_sub_specs; i++) {\n\t\tif (sub_specs->freq_range_index == 0)\n\t\t\tar->tx_power_2g_limit = sub_specs->power / 2;\n\t\telse if (sub_specs->freq_range_index == 1)\n\t\t\tar->tx_power_5g_limit = sub_specs->power / 2;\n\n\t\tsub_specs++;\n\t}\n\n\tret = ath10k_mac_set_sar_power(ar);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set sar power: %d\", ret);\n\t\tgoto err;\n\t}\n\nerr:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\n \nstatic void ath10k_bss_assoc(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     struct ieee80211_bss_conf *bss_conf)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct ieee80211_sta_ht_cap ht_cap;\n\tstruct ieee80211_sta_vht_cap vht_cap;\n\tstruct wmi_peer_assoc_complete_arg peer_arg;\n\tstruct ieee80211_sta *ap_sta;\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac vdev %i assoc bssid %pM aid %d\\n\",\n\t\t   arvif->vdev_id, arvif->bssid, arvif->aid);\n\n\trcu_read_lock();\n\n\tap_sta = ieee80211_find_sta(vif, bss_conf->bssid);\n\tif (!ap_sta) {\n\t\tath10k_warn(ar, \"failed to find station entry for bss %pM vdev %i\\n\",\n\t\t\t    bss_conf->bssid, arvif->vdev_id);\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t \n\tht_cap = ap_sta->deflink.ht_cap;\n\tvht_cap = ap_sta->deflink.vht_cap;\n\n\tret = ath10k_peer_assoc_prepare(ar, vif, ap_sta, &peer_arg);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to prepare peer assoc for %pM vdev %i: %d\\n\",\n\t\t\t    bss_conf->bssid, arvif->vdev_id, ret);\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\trcu_read_unlock();\n\n\tret = ath10k_wmi_peer_assoc(ar, &peer_arg);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to run peer assoc for %pM vdev %i: %d\\n\",\n\t\t\t    bss_conf->bssid, arvif->vdev_id, ret);\n\t\treturn;\n\t}\n\n\tret = ath10k_setup_peer_smps(ar, arvif, bss_conf->bssid, &ht_cap);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to setup peer SMPS for vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn;\n\t}\n\n\tret = ath10k_mac_vif_recalc_txbf(ar, vif, vht_cap);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to recalc txbf for vdev %i on bss %pM: %d\\n\",\n\t\t\t    arvif->vdev_id, bss_conf->bssid, ret);\n\t\treturn;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC,\n\t\t   \"mac vdev %d up (associated) bssid %pM aid %d\\n\",\n\t\t   arvif->vdev_id, bss_conf->bssid, vif->cfg.aid);\n\n\tWARN_ON(arvif->is_up);\n\n\tarvif->aid = vif->cfg.aid;\n\tether_addr_copy(arvif->bssid, bss_conf->bssid);\n\n\tret = ath10k_wmi_pdev_set_param(ar,\n\t\t\t\t\tar->wmi.pdev_param->peer_stats_info_enable, 1);\n\tif (ret)\n\t\tath10k_warn(ar, \"failed to enable peer stats info: %d\\n\", ret);\n\n\tret = ath10k_wmi_vdev_up(ar, arvif->vdev_id, arvif->aid, arvif->bssid);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set vdev %d up: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn;\n\t}\n\n\tarvif->is_up = true;\n\n\tath10k_mac_set_sar_power(ar);\n\n\t \n\tret = ath10k_wmi_peer_set_param(ar, arvif->vdev_id, arvif->bssid,\n\t\t\t\t\tar->wmi.peer_param->dummy_var, 1);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to poke peer %pM param for ps workaround on vdev %i: %d\\n\",\n\t\t\t    arvif->bssid, arvif->vdev_id, ret);\n\t\treturn;\n\t}\n}\n\nstatic void ath10k_bss_disassoc(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct ieee80211_sta_vht_cap vht_cap = {};\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac vdev %i disassoc bssid %pM\\n\",\n\t\t   arvif->vdev_id, arvif->bssid);\n\n\tret = ath10k_wmi_vdev_down(ar, arvif->vdev_id);\n\tif (ret)\n\t\tath10k_warn(ar, \"failed to down vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\n\tarvif->def_wep_key_idx = -1;\n\n\tret = ath10k_mac_vif_recalc_txbf(ar, vif, vht_cap);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to recalc txbf for vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn;\n\t}\n\n\tarvif->is_up = false;\n\n\tath10k_mac_txpower_recalc(ar);\n\n\tcancel_delayed_work_sync(&arvif->connection_loss_work);\n}\n\nstatic int ath10k_new_peer_tid_config(struct ath10k *ar,\n\t\t\t\t      struct ieee80211_sta *sta,\n\t\t\t\t      struct ath10k_vif *arvif)\n{\n\tstruct wmi_per_peer_per_tid_cfg_arg arg = {};\n\tstruct ath10k_sta *arsta = (struct ath10k_sta *)sta->drv_priv;\n\tbool config_apply;\n\tint ret, i;\n\n\tfor (i = 0; i < ATH10K_TID_MAX; i++) {\n\t\tconfig_apply = false;\n\t\tif (arvif->retry_long[i] || arvif->ampdu[i] ||\n\t\t    arvif->rate_ctrl[i] || arvif->rtscts[i]) {\n\t\t\tconfig_apply = true;\n\t\t\targ.tid = i;\n\t\t\targ.vdev_id = arvif->vdev_id;\n\t\t\targ.retry_count = arvif->retry_long[i];\n\t\t\targ.aggr_control = arvif->ampdu[i];\n\t\t\targ.rate_ctrl = arvif->rate_ctrl[i];\n\t\t\targ.rcode_flags = arvif->rate_code[i];\n\n\t\t\tif (arvif->rtscts[i])\n\t\t\t\targ.ext_tid_cfg_bitmap =\n\t\t\t\t\tWMI_EXT_TID_RTS_CTS_CONFIG;\n\t\t\telse\n\t\t\t\targ.ext_tid_cfg_bitmap = 0;\n\n\t\t\targ.rtscts_ctrl = arvif->rtscts[i];\n\t\t}\n\n\t\tif (arvif->noack[i]) {\n\t\t\targ.ack_policy = arvif->noack[i];\n\t\t\targ.rate_ctrl = WMI_TID_CONFIG_RATE_CONTROL_DEFAULT_LOWEST_RATE;\n\t\t\targ.aggr_control = WMI_TID_CONFIG_AGGR_CONTROL_DISABLE;\n\t\t\tconfig_apply = true;\n\t\t}\n\n\t\t \n\t\tarsta->retry_long[i] = -1;\n\t\tarsta->noack[i] = -1;\n\t\tarsta->ampdu[i] = -1;\n\n\t\tif (!config_apply)\n\t\t\tcontinue;\n\n\t\tether_addr_copy(arg.peer_macaddr.addr, sta->addr);\n\n\t\tret = ath10k_wmi_set_per_peer_per_tid_cfg(ar, &arg);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to set per tid retry/aggr config for sta %pM: %d\\n\",\n\t\t\t\t    sta->addr, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tmemset(&arg, 0, sizeof(arg));\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_station_assoc(struct ath10k *ar,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_sta *sta,\n\t\t\t\tbool reassoc)\n{\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct wmi_peer_assoc_complete_arg peer_arg;\n\tint ret = 0;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tret = ath10k_peer_assoc_prepare(ar, vif, sta, &peer_arg);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to prepare WMI peer assoc for %pM vdev %i: %i\\n\",\n\t\t\t    sta->addr, arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\tret = ath10k_wmi_peer_assoc(ar, &peer_arg);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to run peer assoc for STA %pM vdev %i: %d\\n\",\n\t\t\t    sta->addr, arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (!reassoc) {\n\t\tret = ath10k_setup_peer_smps(ar, arvif, sta->addr,\n\t\t\t\t\t     &sta->deflink.ht_cap);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to setup peer SMPS for vdev %d: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = ath10k_peer_assoc_qos_ap(ar, arvif, sta);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to set qos params for STA %pM for vdev %i: %d\\n\",\n\t\t\t\t    sta->addr, arvif->vdev_id, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!sta->wme) {\n\t\t\tarvif->num_legacy_stations++;\n\t\t\tret  = ath10k_recalc_rtscts_prot(arvif);\n\t\t\tif (ret) {\n\t\t\t\tath10k_warn(ar, \"failed to recalculate rts/cts prot for vdev %d: %d\\n\",\n\t\t\t\t\t    arvif->vdev_id, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif ((arvif->def_wep_key_idx != -1) && (!sta->tdls)) {\n\t\t\tret = ath10k_install_peer_wep_keys(arvif, sta->addr);\n\t\t\tif (ret) {\n\t\t\t\tath10k_warn(ar, \"failed to install peer wep keys for vdev %i: %d\\n\",\n\t\t\t\t\t    arvif->vdev_id, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!test_bit(WMI_SERVICE_PEER_TID_CONFIGS_SUPPORT, ar->wmi.svc_map))\n\t\treturn ret;\n\n\treturn ath10k_new_peer_tid_config(ar, sta, arvif);\n}\n\nstatic int ath10k_station_disassoc(struct ath10k *ar,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   struct ieee80211_sta *sta)\n{\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tint ret = 0;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (!sta->wme) {\n\t\tarvif->num_legacy_stations--;\n\t\tret = ath10k_recalc_rtscts_prot(arvif);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to recalculate rts/cts prot for vdev %d: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = ath10k_clear_peer_keys(arvif, sta->addr);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to clear all peer wep keys for vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\n \n \n \n\nstatic int ath10k_update_channel_list(struct ath10k *ar)\n{\n\tstruct ieee80211_hw *hw = ar->hw;\n\tstruct ieee80211_supported_band **bands;\n\tenum nl80211_band band;\n\tstruct ieee80211_channel *channel;\n\tstruct wmi_scan_chan_list_arg arg = {0};\n\tstruct wmi_channel_arg *ch;\n\tbool passive;\n\tint len;\n\tint ret;\n\tint i;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tbands = hw->wiphy->bands;\n\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\tif (!bands[band])\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < bands[band]->n_channels; i++) {\n\t\t\tif (bands[band]->channels[i].flags &\n\t\t\t    IEEE80211_CHAN_DISABLED)\n\t\t\t\tcontinue;\n\n\t\t\targ.n_channels++;\n\t\t}\n\t}\n\n\tlen = sizeof(struct wmi_channel_arg) * arg.n_channels;\n\targ.channels = kzalloc(len, GFP_KERNEL);\n\tif (!arg.channels)\n\t\treturn -ENOMEM;\n\n\tch = arg.channels;\n\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\tif (!bands[band])\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < bands[band]->n_channels; i++) {\n\t\t\tchannel = &bands[band]->channels[i];\n\n\t\t\tif (channel->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\tcontinue;\n\n\t\t\tch->allow_ht = true;\n\n\t\t\t \n\t\t\tch->allow_vht = true;\n\n\t\t\tch->allow_ibss =\n\t\t\t\t!(channel->flags & IEEE80211_CHAN_NO_IR);\n\n\t\t\tch->ht40plus =\n\t\t\t\t!(channel->flags & IEEE80211_CHAN_NO_HT40PLUS);\n\n\t\t\tch->chan_radar =\n\t\t\t\t!!(channel->flags & IEEE80211_CHAN_RADAR);\n\n\t\t\tpassive = channel->flags & IEEE80211_CHAN_NO_IR;\n\t\t\tch->passive = passive;\n\n\t\t\t \n\t\t\tch->passive |= ch->chan_radar;\n\n\t\t\tch->freq = channel->center_freq;\n\t\t\tch->band_center_freq1 = channel->center_freq;\n\t\t\tch->min_power = 0;\n\t\t\tch->max_power = channel->max_power * 2;\n\t\t\tch->max_reg_power = channel->max_reg_power * 2;\n\t\t\tch->max_antenna_gain = channel->max_antenna_gain;\n\t\t\tch->reg_class_id = 0;  \n\n\t\t\t \n\t\t\tif (channel->band == NL80211_BAND_2GHZ)\n\t\t\t\tch->mode = MODE_11G;\n\t\t\telse\n\t\t\t\tch->mode = MODE_11A;\n\n\t\t\tif (WARN_ON_ONCE(ch->mode == MODE_UNKNOWN))\n\t\t\t\tcontinue;\n\n\t\t\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t\t\t   \"mac channel [%zd/%d] freq %d maxpower %d regpower %d antenna %d mode %d\\n\",\n\t\t\t\t    ch - arg.channels, arg.n_channels,\n\t\t\t\t   ch->freq, ch->max_power, ch->max_reg_power,\n\t\t\t\t   ch->max_antenna_gain, ch->mode);\n\n\t\t\tch++;\n\t\t}\n\t}\n\n\tret = ath10k_wmi_scan_chan_list(ar, &arg);\n\tkfree(arg.channels);\n\n\treturn ret;\n}\n\nstatic enum wmi_dfs_region\nath10k_mac_get_dfs_region(enum nl80211_dfs_regions dfs_region)\n{\n\tswitch (dfs_region) {\n\tcase NL80211_DFS_UNSET:\n\t\treturn WMI_UNINIT_DFS_DOMAIN;\n\tcase NL80211_DFS_FCC:\n\t\treturn WMI_FCC_DFS_DOMAIN;\n\tcase NL80211_DFS_ETSI:\n\t\treturn WMI_ETSI_DFS_DOMAIN;\n\tcase NL80211_DFS_JP:\n\t\treturn WMI_MKK4_DFS_DOMAIN;\n\t}\n\treturn WMI_UNINIT_DFS_DOMAIN;\n}\n\nstatic void ath10k_regd_update(struct ath10k *ar)\n{\n\tstruct reg_dmn_pair_mapping *regpair;\n\tint ret;\n\tenum wmi_dfs_region wmi_dfs_reg;\n\tenum nl80211_dfs_regions nl_dfs_reg;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tret = ath10k_update_channel_list(ar);\n\tif (ret)\n\t\tath10k_warn(ar, \"failed to update channel list: %d\\n\", ret);\n\n\tregpair = ar->ath_common.regulatory.regpair;\n\n\tif (IS_ENABLED(CONFIG_ATH10K_DFS_CERTIFIED) && ar->dfs_detector) {\n\t\tnl_dfs_reg = ar->dfs_detector->region;\n\t\twmi_dfs_reg = ath10k_mac_get_dfs_region(nl_dfs_reg);\n\t} else {\n\t\twmi_dfs_reg = WMI_UNINIT_DFS_DOMAIN;\n\t}\n\n\t \n\tret = ath10k_wmi_pdev_set_regdomain(ar,\n\t\t\t\t\t    regpair->reg_domain,\n\t\t\t\t\t    regpair->reg_domain,  \n\t\t\t\t\t    regpair->reg_domain,  \n\t\t\t\t\t    regpair->reg_2ghz_ctl,\n\t\t\t\t\t    regpair->reg_5ghz_ctl,\n\t\t\t\t\t    wmi_dfs_reg);\n\tif (ret)\n\t\tath10k_warn(ar, \"failed to set pdev regdomain: %d\\n\", ret);\n}\n\nstatic void ath10k_mac_update_channel_list(struct ath10k *ar,\n\t\t\t\t\t   struct ieee80211_supported_band *band)\n{\n\tint i;\n\n\tif (ar->low_5ghz_chan && ar->high_5ghz_chan) {\n\t\tfor (i = 0; i < band->n_channels; i++) {\n\t\t\tif (band->channels[i].center_freq < ar->low_5ghz_chan ||\n\t\t\t    band->channels[i].center_freq > ar->high_5ghz_chan)\n\t\t\t\tband->channels[i].flags |=\n\t\t\t\t\tIEEE80211_CHAN_DISABLED;\n\t\t}\n\t}\n}\n\nstatic void ath10k_reg_notifier(struct wiphy *wiphy,\n\t\t\t\tstruct regulatory_request *request)\n{\n\tstruct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);\n\tstruct ath10k *ar = hw->priv;\n\tbool result;\n\n\tath_reg_notifier_apply(wiphy, request, &ar->ath_common.regulatory);\n\n\tif (IS_ENABLED(CONFIG_ATH10K_DFS_CERTIFIED) && ar->dfs_detector) {\n\t\tath10k_dbg(ar, ATH10K_DBG_REGULATORY, \"dfs region 0x%x\\n\",\n\t\t\t   request->dfs_region);\n\t\tresult = ar->dfs_detector->set_dfs_domain(ar->dfs_detector,\n\t\t\t\t\t\t\t  request->dfs_region);\n\t\tif (!result)\n\t\t\tath10k_warn(ar, \"DFS region 0x%X not supported, will trigger radar for every pulse\\n\",\n\t\t\t\t    request->dfs_region);\n\t}\n\n\tmutex_lock(&ar->conf_mutex);\n\tif (ar->state == ATH10K_STATE_ON)\n\t\tath10k_regd_update(ar);\n\tmutex_unlock(&ar->conf_mutex);\n\n\tif (ar->phy_capability & WHAL_WLAN_11A_CAPABILITY)\n\t\tath10k_mac_update_channel_list(ar,\n\t\t\t\t\t       ar->hw->wiphy->bands[NL80211_BAND_5GHZ]);\n}\n\nstatic void ath10k_stop_radar_confirmation(struct ath10k *ar)\n{\n\tspin_lock_bh(&ar->data_lock);\n\tar->radar_conf_state = ATH10K_RADAR_CONFIRMATION_STOPPED;\n\tspin_unlock_bh(&ar->data_lock);\n\n\tcancel_work_sync(&ar->radar_confirmation_work);\n}\n\n \n \n \n\nenum ath10k_mac_tx_path {\n\tATH10K_MAC_TX_HTT,\n\tATH10K_MAC_TX_HTT_MGMT,\n\tATH10K_MAC_TX_WMI_MGMT,\n\tATH10K_MAC_TX_UNKNOWN,\n};\n\nvoid ath10k_mac_tx_lock(struct ath10k *ar, int reason)\n{\n\tlockdep_assert_held(&ar->htt.tx_lock);\n\n\tWARN_ON(reason >= ATH10K_TX_PAUSE_MAX);\n\tar->tx_paused |= BIT(reason);\n\tieee80211_stop_queues(ar->hw);\n}\n\nstatic void ath10k_mac_tx_unlock_iter(void *data, u8 *mac,\n\t\t\t\t      struct ieee80211_vif *vif)\n{\n\tstruct ath10k *ar = data;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\n\tif (arvif->tx_paused)\n\t\treturn;\n\n\tieee80211_wake_queue(ar->hw, arvif->vdev_id);\n}\n\nvoid ath10k_mac_tx_unlock(struct ath10k *ar, int reason)\n{\n\tlockdep_assert_held(&ar->htt.tx_lock);\n\n\tWARN_ON(reason >= ATH10K_TX_PAUSE_MAX);\n\tar->tx_paused &= ~BIT(reason);\n\n\tif (ar->tx_paused)\n\t\treturn;\n\n\tieee80211_iterate_active_interfaces_atomic(ar->hw,\n\t\t\t\t\t\t   ATH10K_ITER_RESUME_FLAGS,\n\t\t\t\t\t\t   ath10k_mac_tx_unlock_iter,\n\t\t\t\t\t\t   ar);\n\n\tieee80211_wake_queue(ar->hw, ar->hw->offchannel_tx_hw_queue);\n}\n\nvoid ath10k_mac_vif_tx_lock(struct ath10k_vif *arvif, int reason)\n{\n\tstruct ath10k *ar = arvif->ar;\n\n\tlockdep_assert_held(&ar->htt.tx_lock);\n\n\tWARN_ON(reason >= BITS_PER_LONG);\n\tarvif->tx_paused |= BIT(reason);\n\tieee80211_stop_queue(ar->hw, arvif->vdev_id);\n}\n\nvoid ath10k_mac_vif_tx_unlock(struct ath10k_vif *arvif, int reason)\n{\n\tstruct ath10k *ar = arvif->ar;\n\n\tlockdep_assert_held(&ar->htt.tx_lock);\n\n\tWARN_ON(reason >= BITS_PER_LONG);\n\tarvif->tx_paused &= ~BIT(reason);\n\n\tif (ar->tx_paused)\n\t\treturn;\n\n\tif (arvif->tx_paused)\n\t\treturn;\n\n\tieee80211_wake_queue(ar->hw, arvif->vdev_id);\n}\n\nstatic void ath10k_mac_vif_handle_tx_pause(struct ath10k_vif *arvif,\n\t\t\t\t\t   enum wmi_tlv_tx_pause_id pause_id,\n\t\t\t\t\t   enum wmi_tlv_tx_pause_action action)\n{\n\tstruct ath10k *ar = arvif->ar;\n\n\tlockdep_assert_held(&ar->htt.tx_lock);\n\n\tswitch (action) {\n\tcase WMI_TLV_TX_PAUSE_ACTION_STOP:\n\t\tath10k_mac_vif_tx_lock(arvif, pause_id);\n\t\tbreak;\n\tcase WMI_TLV_TX_PAUSE_ACTION_WAKE:\n\t\tath10k_mac_vif_tx_unlock(arvif, pause_id);\n\t\tbreak;\n\tdefault:\n\t\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t\t   \"received unknown tx pause action %d on vdev %i, ignoring\\n\",\n\t\t\t    action, arvif->vdev_id);\n\t\tbreak;\n\t}\n}\n\nstruct ath10k_mac_tx_pause {\n\tu32 vdev_id;\n\tenum wmi_tlv_tx_pause_id pause_id;\n\tenum wmi_tlv_tx_pause_action action;\n};\n\nstatic void ath10k_mac_handle_tx_pause_iter(void *data, u8 *mac,\n\t\t\t\t\t    struct ieee80211_vif *vif)\n{\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct ath10k_mac_tx_pause *arg = data;\n\n\tif (arvif->vdev_id != arg->vdev_id)\n\t\treturn;\n\n\tath10k_mac_vif_handle_tx_pause(arvif, arg->pause_id, arg->action);\n}\n\nvoid ath10k_mac_handle_tx_pause_vdev(struct ath10k *ar, u32 vdev_id,\n\t\t\t\t     enum wmi_tlv_tx_pause_id pause_id,\n\t\t\t\t     enum wmi_tlv_tx_pause_action action)\n{\n\tstruct ath10k_mac_tx_pause arg = {\n\t\t.vdev_id = vdev_id,\n\t\t.pause_id = pause_id,\n\t\t.action = action,\n\t};\n\n\tspin_lock_bh(&ar->htt.tx_lock);\n\tieee80211_iterate_active_interfaces_atomic(ar->hw,\n\t\t\t\t\t\t   ATH10K_ITER_RESUME_FLAGS,\n\t\t\t\t\t\t   ath10k_mac_handle_tx_pause_iter,\n\t\t\t\t\t\t   &arg);\n\tspin_unlock_bh(&ar->htt.tx_lock);\n}\n\nstatic enum ath10k_hw_txrx_mode\nath10k_mac_tx_h_get_txmode(struct ath10k *ar,\n\t\t\t   struct ieee80211_vif *vif,\n\t\t\t   struct ieee80211_sta *sta,\n\t\t\t   struct sk_buff *skb)\n{\n\tconst struct ieee80211_hdr *hdr = (void *)skb->data;\n\tconst struct ath10k_skb_cb *skb_cb = ATH10K_SKB_CB(skb);\n\t__le16 fc = hdr->frame_control;\n\n\tif (IEEE80211_SKB_CB(skb)->flags & IEEE80211_TX_CTL_HW_80211_ENCAP)\n\t\treturn ATH10K_HW_TXRX_ETHERNET;\n\n\tif (!vif || vif->type == NL80211_IFTYPE_MONITOR)\n\t\treturn ATH10K_HW_TXRX_RAW;\n\n\tif (ieee80211_is_mgmt(fc))\n\t\treturn ATH10K_HW_TXRX_MGMT;\n\n\t \n\tif (ar->htt.target_version_major < 3 &&\n\t    (ieee80211_is_nullfunc(fc) || ieee80211_is_qos_nullfunc(fc)) &&\n\t    !test_bit(ATH10K_FW_FEATURE_HAS_WMI_MGMT_TX,\n\t\t      ar->running_fw->fw_file.fw_features))\n\t\treturn ATH10K_HW_TXRX_MGMT;\n\n\t \n\tif (ieee80211_is_data_present(fc) && sta && sta->tdls)\n\t\treturn ATH10K_HW_TXRX_ETHERNET;\n\n\tif (test_bit(ATH10K_FLAG_RAW_MODE, &ar->dev_flags) ||\n\t    skb_cb->flags & ATH10K_SKB_F_RAW_TX)\n\t\treturn ATH10K_HW_TXRX_RAW;\n\n\treturn ATH10K_HW_TXRX_NATIVE_WIFI;\n}\n\nstatic bool ath10k_tx_h_use_hwcrypto(struct ieee80211_vif *vif,\n\t\t\t\t     struct sk_buff *skb)\n{\n\tconst struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tconst struct ieee80211_hdr *hdr = (void *)skb->data;\n\tconst u32 mask = IEEE80211_TX_INTFL_DONT_ENCRYPT |\n\t\t\t IEEE80211_TX_CTL_INJECTED;\n\n\tif (!ieee80211_has_protected(hdr->frame_control))\n\t\treturn false;\n\n\tif ((info->flags & mask) == mask)\n\t\treturn false;\n\n\tif (vif)\n\t\treturn !((struct ath10k_vif *)vif->drv_priv)->nohwcrypt;\n\n\treturn true;\n}\n\n \nstatic void ath10k_tx_h_nwifi(struct ieee80211_hw *hw, struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\tstruct ath10k_skb_cb *cb = ATH10K_SKB_CB(skb);\n\tu8 *qos_ctl;\n\n\tif (!ieee80211_is_data_qos(hdr->frame_control))\n\t\treturn;\n\n\tqos_ctl = ieee80211_get_qos_ctl(hdr);\n\tmemmove(skb->data + IEEE80211_QOS_CTL_LEN,\n\t\tskb->data, (void *)qos_ctl - (void *)skb->data);\n\tskb_pull(skb, IEEE80211_QOS_CTL_LEN);\n\n\t \n\thdr = (void *)skb->data;\n\tif (ieee80211_is_qos_nullfunc(hdr->frame_control))\n\t\tcb->flags &= ~ATH10K_SKB_F_QOS;\n\n\thdr->frame_control &= ~__cpu_to_le16(IEEE80211_STYPE_QOS_DATA);\n}\n\nstatic void ath10k_tx_h_8023(struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr;\n\tstruct rfc1042_hdr *rfc1042;\n\tstruct ethhdr *eth;\n\tsize_t hdrlen;\n\tu8 da[ETH_ALEN];\n\tu8 sa[ETH_ALEN];\n\t__be16 type;\n\n\thdr = (void *)skb->data;\n\thdrlen = ieee80211_hdrlen(hdr->frame_control);\n\trfc1042 = (void *)skb->data + hdrlen;\n\n\tether_addr_copy(da, ieee80211_get_DA(hdr));\n\tether_addr_copy(sa, ieee80211_get_SA(hdr));\n\ttype = rfc1042->snap_type;\n\n\tskb_pull(skb, hdrlen + sizeof(*rfc1042));\n\tskb_push(skb, sizeof(*eth));\n\n\teth = (void *)skb->data;\n\tether_addr_copy(eth->h_dest, da);\n\tether_addr_copy(eth->h_source, sa);\n\teth->h_proto = type;\n}\n\nstatic void ath10k_tx_h_add_p2p_noa_ie(struct ath10k *ar,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\n\t \n\tif (vif->type != NL80211_IFTYPE_AP || !vif->p2p)\n\t\treturn;\n\n\tif (unlikely(ieee80211_is_probe_resp(hdr->frame_control))) {\n\t\tspin_lock_bh(&ar->data_lock);\n\t\tif (arvif->u.ap.noa_data)\n\t\t\tif (!pskb_expand_head(skb, 0, arvif->u.ap.noa_len,\n\t\t\t\t\t      GFP_ATOMIC))\n\t\t\t\tskb_put_data(skb, arvif->u.ap.noa_data,\n\t\t\t\t\t     arvif->u.ap.noa_len);\n\t\tspin_unlock_bh(&ar->data_lock);\n\t}\n}\n\nstatic void ath10k_mac_tx_h_fill_cb(struct ath10k *ar,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct ieee80211_txq *txq,\n\t\t\t\t    struct ieee80211_sta *sta,\n\t\t\t\t    struct sk_buff *skb, u16 airtime)\n{\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\tstruct ath10k_skb_cb *cb = ATH10K_SKB_CB(skb);\n\tconst struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tbool is_data = ieee80211_is_data(hdr->frame_control) ||\n\t\t\tieee80211_is_data_qos(hdr->frame_control);\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct ath10k_sta *arsta;\n\tu8 tid, *qos_ctl;\n\tbool noack = false;\n\n\tcb->flags = 0;\n\n\tif (info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP) {\n\t\tcb->flags |= ATH10K_SKB_F_QOS;\t \n\t\tgoto finish_cb_fill;\n\t}\n\n\tif (!ath10k_tx_h_use_hwcrypto(vif, skb))\n\t\tcb->flags |= ATH10K_SKB_F_NO_HWCRYPT;\n\n\tif (ieee80211_is_mgmt(hdr->frame_control))\n\t\tcb->flags |= ATH10K_SKB_F_MGMT;\n\n\tif (ieee80211_is_data_qos(hdr->frame_control)) {\n\t\tcb->flags |= ATH10K_SKB_F_QOS;\n\t\tqos_ctl = ieee80211_get_qos_ctl(hdr);\n\t\ttid = (*qos_ctl) & IEEE80211_QOS_CTL_TID_MASK;\n\n\t\tif (arvif->noack[tid] == WMI_PEER_TID_CONFIG_NOACK)\n\t\t\tnoack = true;\n\n\t\tif (sta) {\n\t\t\tarsta = (struct ath10k_sta *)sta->drv_priv;\n\n\t\t\tif (arsta->noack[tid] == WMI_PEER_TID_CONFIG_NOACK)\n\t\t\t\tnoack = true;\n\n\t\t\tif (arsta->noack[tid] == WMI_PEER_TID_CONFIG_ACK)\n\t\t\t\tnoack = false;\n\t\t}\n\n\t\tif (noack)\n\t\t\tcb->flags |= ATH10K_SKB_F_NOACK_TID;\n\t}\n\n\t \n\tif (is_data && ieee80211_has_protected(hdr->frame_control) &&\n\t    !info->control.hw_key) {\n\t\tcb->flags |= ATH10K_SKB_F_NO_HWCRYPT;\n\t\tcb->flags |= ATH10K_SKB_F_RAW_TX;\n\t}\n\nfinish_cb_fill:\n\tcb->vif = vif;\n\tcb->txq = txq;\n\tcb->airtime_est = airtime;\n\tif (sta) {\n\t\tarsta = (struct ath10k_sta *)sta->drv_priv;\n\t\tspin_lock_bh(&ar->data_lock);\n\t\tcb->ucast_cipher = arsta->ucast_cipher;\n\t\tspin_unlock_bh(&ar->data_lock);\n\t}\n}\n\nbool ath10k_mac_tx_frm_has_freq(struct ath10k *ar)\n{\n\t \n\treturn (ar->htt.target_version_major >= 3 &&\n\t\tar->htt.target_version_minor >= 4 &&\n\t\tar->running_fw->fw_file.htt_op_version == ATH10K_FW_HTT_OP_VERSION_TLV);\n}\n\nstatic int ath10k_mac_tx_wmi_mgmt(struct ath10k *ar, struct sk_buff *skb)\n{\n\tstruct sk_buff_head *q = &ar->wmi_mgmt_tx_queue;\n\n\tif (skb_queue_len_lockless(q) >= ATH10K_MAX_NUM_MGMT_PENDING) {\n\t\tath10k_warn(ar, \"wmi mgmt tx queue is full\\n\");\n\t\treturn -ENOSPC;\n\t}\n\n\tskb_queue_tail(q, skb);\n\tieee80211_queue_work(ar->hw, &ar->wmi_mgmt_tx_work);\n\n\treturn 0;\n}\n\nstatic enum ath10k_mac_tx_path\nath10k_mac_tx_h_get_txpath(struct ath10k *ar,\n\t\t\t   struct sk_buff *skb,\n\t\t\t   enum ath10k_hw_txrx_mode txmode)\n{\n\tswitch (txmode) {\n\tcase ATH10K_HW_TXRX_RAW:\n\tcase ATH10K_HW_TXRX_NATIVE_WIFI:\n\tcase ATH10K_HW_TXRX_ETHERNET:\n\t\treturn ATH10K_MAC_TX_HTT;\n\tcase ATH10K_HW_TXRX_MGMT:\n\t\tif (test_bit(ATH10K_FW_FEATURE_HAS_WMI_MGMT_TX,\n\t\t\t     ar->running_fw->fw_file.fw_features) ||\n\t\t\t     test_bit(WMI_SERVICE_MGMT_TX_WMI,\n\t\t\t\t      ar->wmi.svc_map))\n\t\t\treturn ATH10K_MAC_TX_WMI_MGMT;\n\t\telse if (ar->htt.target_version_major >= 3)\n\t\t\treturn ATH10K_MAC_TX_HTT;\n\t\telse\n\t\t\treturn ATH10K_MAC_TX_HTT_MGMT;\n\t}\n\n\treturn ATH10K_MAC_TX_UNKNOWN;\n}\n\nstatic int ath10k_mac_tx_submit(struct ath10k *ar,\n\t\t\t\tenum ath10k_hw_txrx_mode txmode,\n\t\t\t\tenum ath10k_mac_tx_path txpath,\n\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct ath10k_htt *htt = &ar->htt;\n\tint ret = -EINVAL;\n\n\tswitch (txpath) {\n\tcase ATH10K_MAC_TX_HTT:\n\t\tret = ath10k_htt_tx(htt, txmode, skb);\n\t\tbreak;\n\tcase ATH10K_MAC_TX_HTT_MGMT:\n\t\tret = ath10k_htt_mgmt_tx(htt, skb);\n\t\tbreak;\n\tcase ATH10K_MAC_TX_WMI_MGMT:\n\t\tret = ath10k_mac_tx_wmi_mgmt(ar, skb);\n\t\tbreak;\n\tcase ATH10K_MAC_TX_UNKNOWN:\n\t\tWARN_ON_ONCE(1);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to transmit packet, dropping: %d\\n\",\n\t\t\t    ret);\n\t\tieee80211_free_txskb(ar->hw, skb);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int ath10k_mac_tx(struct ath10k *ar,\n\t\t\t struct ieee80211_vif *vif,\n\t\t\t enum ath10k_hw_txrx_mode txmode,\n\t\t\t enum ath10k_mac_tx_path txpath,\n\t\t\t struct sk_buff *skb, bool noque_offchan)\n{\n\tstruct ieee80211_hw *hw = ar->hw;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tconst struct ath10k_skb_cb *skb_cb = ATH10K_SKB_CB(skb);\n\tint ret;\n\n\t \n\tif (info->flags & IEEE80211_TX_CTL_NO_CCK_RATE)\n\t\tath10k_dbg(ar, ATH10K_DBG_MAC, \"IEEE80211_TX_CTL_NO_CCK_RATE\\n\");\n\n\tswitch (txmode) {\n\tcase ATH10K_HW_TXRX_MGMT:\n\tcase ATH10K_HW_TXRX_NATIVE_WIFI:\n\t\tath10k_tx_h_nwifi(hw, skb);\n\t\tath10k_tx_h_add_p2p_noa_ie(ar, vif, skb);\n\t\tath10k_tx_h_seq_no(vif, skb);\n\t\tbreak;\n\tcase ATH10K_HW_TXRX_ETHERNET:\n\t\t \n\t\tif (!(info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP))\n\t\t\tath10k_tx_h_8023(skb);\n\t\tbreak;\n\tcase ATH10K_HW_TXRX_RAW:\n\t\tif (!test_bit(ATH10K_FLAG_RAW_MODE, &ar->dev_flags) &&\n\t\t    !(skb_cb->flags & ATH10K_SKB_F_RAW_TX)) {\n\t\t\tWARN_ON_ONCE(1);\n\t\t\tieee80211_free_txskb(hw, skb);\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t}\n\n\tif (!noque_offchan && info->flags & IEEE80211_TX_CTL_TX_OFFCHAN) {\n\t\tif (!ath10k_mac_tx_frm_has_freq(ar)) {\n\t\t\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac queued offchannel skb %pK len %d\\n\",\n\t\t\t\t   skb, skb->len);\n\n\t\t\tskb_queue_tail(&ar->offchan_tx_queue, skb);\n\t\t\tieee80211_queue_work(hw, &ar->offchan_tx_work);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tret = ath10k_mac_tx_submit(ar, txmode, txpath, skb);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to submit frame: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nvoid ath10k_offchan_tx_purge(struct ath10k *ar)\n{\n\tstruct sk_buff *skb;\n\n\tfor (;;) {\n\t\tskb = skb_dequeue(&ar->offchan_tx_queue);\n\t\tif (!skb)\n\t\t\tbreak;\n\n\t\tieee80211_free_txskb(ar->hw, skb);\n\t}\n}\n\nvoid ath10k_offchan_tx_work(struct work_struct *work)\n{\n\tstruct ath10k *ar = container_of(work, struct ath10k, offchan_tx_work);\n\tstruct ath10k_peer *peer;\n\tstruct ath10k_vif *arvif;\n\tenum ath10k_hw_txrx_mode txmode;\n\tenum ath10k_mac_tx_path txpath;\n\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211_vif *vif;\n\tstruct ieee80211_sta *sta;\n\tstruct sk_buff *skb;\n\tconst u8 *peer_addr;\n\tint vdev_id;\n\tint ret;\n\tunsigned long time_left;\n\tbool tmp_peer_created = false;\n\n\t \n\n\tfor (;;) {\n\t\tskb = skb_dequeue(&ar->offchan_tx_queue);\n\t\tif (!skb)\n\t\t\tbreak;\n\n\t\tmutex_lock(&ar->conf_mutex);\n\n\t\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac offchannel skb %pK len %d\\n\",\n\t\t\t   skb, skb->len);\n\n\t\thdr = (struct ieee80211_hdr *)skb->data;\n\t\tpeer_addr = ieee80211_get_DA(hdr);\n\n\t\tspin_lock_bh(&ar->data_lock);\n\t\tvdev_id = ar->scan.vdev_id;\n\t\tpeer = ath10k_peer_find(ar, vdev_id, peer_addr);\n\t\tspin_unlock_bh(&ar->data_lock);\n\n\t\tif (peer) {\n\t\t\tath10k_warn(ar, \"peer %pM on vdev %d already present\\n\",\n\t\t\t\t    peer_addr, vdev_id);\n\t\t} else {\n\t\t\tret = ath10k_peer_create(ar, NULL, NULL, vdev_id,\n\t\t\t\t\t\t peer_addr,\n\t\t\t\t\t\t WMI_PEER_TYPE_DEFAULT);\n\t\t\tif (ret)\n\t\t\t\tath10k_warn(ar, \"failed to create peer %pM on vdev %d: %d\\n\",\n\t\t\t\t\t    peer_addr, vdev_id, ret);\n\t\t\ttmp_peer_created = (ret == 0);\n\t\t}\n\n\t\tspin_lock_bh(&ar->data_lock);\n\t\treinit_completion(&ar->offchan_tx_completed);\n\t\tar->offchan_tx_skb = skb;\n\t\tspin_unlock_bh(&ar->data_lock);\n\n\t\t \n\t\tarvif = ath10k_get_arvif(ar, vdev_id);\n\t\tif (arvif) {\n\t\t\tvif = arvif->vif;\n\t\t\tsta = ieee80211_find_sta(vif, peer_addr);\n\t\t} else {\n\t\t\tvif = NULL;\n\t\t\tsta = NULL;\n\t\t}\n\n\t\ttxmode = ath10k_mac_tx_h_get_txmode(ar, vif, sta, skb);\n\t\ttxpath = ath10k_mac_tx_h_get_txpath(ar, skb, txmode);\n\n\t\tret = ath10k_mac_tx(ar, vif, txmode, txpath, skb, true);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to transmit offchannel frame: %d\\n\",\n\t\t\t\t    ret);\n\t\t\t \n\t\t}\n\n\t\ttime_left =\n\t\twait_for_completion_timeout(&ar->offchan_tx_completed, 3 * HZ);\n\t\tif (time_left == 0)\n\t\t\tath10k_warn(ar, \"timed out waiting for offchannel skb %pK, len: %d\\n\",\n\t\t\t\t    skb, skb->len);\n\n\t\tif (!peer && tmp_peer_created) {\n\t\t\tret = ath10k_peer_delete(ar, vdev_id, peer_addr);\n\t\t\tif (ret)\n\t\t\t\tath10k_warn(ar, \"failed to delete peer %pM on vdev %d: %d\\n\",\n\t\t\t\t\t    peer_addr, vdev_id, ret);\n\t\t}\n\n\t\tmutex_unlock(&ar->conf_mutex);\n\t}\n}\n\nvoid ath10k_mgmt_over_wmi_tx_purge(struct ath10k *ar)\n{\n\tstruct sk_buff *skb;\n\n\tfor (;;) {\n\t\tskb = skb_dequeue(&ar->wmi_mgmt_tx_queue);\n\t\tif (!skb)\n\t\t\tbreak;\n\n\t\tieee80211_free_txskb(ar->hw, skb);\n\t}\n}\n\nvoid ath10k_mgmt_over_wmi_tx_work(struct work_struct *work)\n{\n\tstruct ath10k *ar = container_of(work, struct ath10k, wmi_mgmt_tx_work);\n\tstruct sk_buff *skb;\n\tdma_addr_t paddr;\n\tint ret;\n\n\tfor (;;) {\n\t\tskb = skb_dequeue(&ar->wmi_mgmt_tx_queue);\n\t\tif (!skb)\n\t\t\tbreak;\n\n\t\tif (test_bit(ATH10K_FW_FEATURE_MGMT_TX_BY_REF,\n\t\t\t     ar->running_fw->fw_file.fw_features)) {\n\t\t\tpaddr = dma_map_single(ar->dev, skb->data,\n\t\t\t\t\t       skb->len, DMA_TO_DEVICE);\n\t\t\tif (dma_mapping_error(ar->dev, paddr)) {\n\t\t\t\tieee80211_free_txskb(ar->hw, skb);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tret = ath10k_wmi_mgmt_tx_send(ar, skb, paddr);\n\t\t\tif (ret) {\n\t\t\t\tath10k_warn(ar, \"failed to transmit management frame by ref via WMI: %d\\n\",\n\t\t\t\t\t    ret);\n\t\t\t\t \n\t\t\t\tath10k_wmi_cleanup_mgmt_tx_send(ar, skb);\n\n\t\t\t\tdma_unmap_single(ar->dev, paddr, skb->len,\n\t\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\t\tieee80211_free_txskb(ar->hw, skb);\n\t\t\t}\n\t\t} else {\n\t\t\tret = ath10k_wmi_mgmt_tx(ar, skb);\n\t\t\tif (ret) {\n\t\t\t\tath10k_warn(ar, \"failed to transmit management frame via WMI: %d\\n\",\n\t\t\t\t\t    ret);\n\t\t\t\tieee80211_free_txskb(ar->hw, skb);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void ath10k_mac_txq_init(struct ieee80211_txq *txq)\n{\n\tstruct ath10k_txq *artxq;\n\n\tif (!txq)\n\t\treturn;\n\n\tartxq = (void *)txq->drv_priv;\n\tINIT_LIST_HEAD(&artxq->list);\n}\n\nstatic void ath10k_mac_txq_unref(struct ath10k *ar, struct ieee80211_txq *txq)\n{\n\tstruct ath10k_skb_cb *cb;\n\tstruct sk_buff *msdu;\n\tint msdu_id;\n\n\tif (!txq)\n\t\treturn;\n\n\tspin_lock_bh(&ar->htt.tx_lock);\n\tidr_for_each_entry(&ar->htt.pending_tx, msdu, msdu_id) {\n\t\tcb = ATH10K_SKB_CB(msdu);\n\t\tif (cb->txq == txq)\n\t\t\tcb->txq = NULL;\n\t}\n\tspin_unlock_bh(&ar->htt.tx_lock);\n}\n\nstruct ieee80211_txq *ath10k_mac_txq_lookup(struct ath10k *ar,\n\t\t\t\t\t    u16 peer_id,\n\t\t\t\t\t    u8 tid)\n{\n\tstruct ath10k_peer *peer;\n\n\tlockdep_assert_held(&ar->data_lock);\n\n\tpeer = ar->peer_map[peer_id];\n\tif (!peer)\n\t\treturn NULL;\n\n\tif (peer->removed)\n\t\treturn NULL;\n\n\tif (peer->sta)\n\t\treturn peer->sta->txq[tid];\n\telse if (peer->vif)\n\t\treturn peer->vif->txq;\n\telse\n\t\treturn NULL;\n}\n\nstatic bool ath10k_mac_tx_can_push(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_txq *txq)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_txq *artxq = (void *)txq->drv_priv;\n\n\t \n\tif (ar->htt.tx_q_state.mode == HTT_TX_MODE_SWITCH_PUSH)\n\t\treturn true;\n\n\tif (ar->htt.num_pending_tx < ar->htt.tx_q_state.num_push_allowed)\n\t\treturn true;\n\n\tif (artxq->num_fw_queued < artxq->num_push_allowed)\n\t\treturn true;\n\n\treturn false;\n}\n\n \n#define IEEE80211_ATF_OVERHEAD\t\t100\t \n#define IEEE80211_ATF_OVERHEAD_IFS\t16\t \nstatic u16 ath10k_mac_update_airtime(struct ath10k *ar,\n\t\t\t\t     struct ieee80211_txq *txq,\n\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct ath10k_sta *arsta;\n\tu32 pktlen;\n\tu16 airtime = 0;\n\n\tif (!txq || !txq->sta)\n\t\treturn airtime;\n\n\tif (test_bit(WMI_SERVICE_REPORT_AIRTIME, ar->wmi.svc_map))\n\t\treturn airtime;\n\n\tspin_lock_bh(&ar->data_lock);\n\tarsta = (struct ath10k_sta *)txq->sta->drv_priv;\n\n\tpktlen = skb->len + 38;  \n\tif (arsta->last_tx_bitrate) {\n\t\t \n\t\tairtime = (pktlen * 8 * (1000 / 100))\n\t\t\t\t/ arsta->last_tx_bitrate;\n\t\t \n\t\tairtime += IEEE80211_ATF_OVERHEAD_IFS;\n\t} else {\n\t\t \n\t\tairtime = (pktlen * 8 * (1000 / 100)) / 60;  \n\t\tairtime += IEEE80211_ATF_OVERHEAD;\n\t}\n\tspin_unlock_bh(&ar->data_lock);\n\n\treturn airtime;\n}\n\nint ath10k_mac_tx_push_txq(struct ieee80211_hw *hw,\n\t\t\t   struct ieee80211_txq *txq)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_htt *htt = &ar->htt;\n\tstruct ath10k_txq *artxq = (void *)txq->drv_priv;\n\tstruct ieee80211_vif *vif = txq->vif;\n\tstruct ieee80211_sta *sta = txq->sta;\n\tenum ath10k_hw_txrx_mode txmode;\n\tenum ath10k_mac_tx_path txpath;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_hdr *hdr;\n\tsize_t skb_len;\n\tbool is_mgmt, is_presp;\n\tint ret;\n\tu16 airtime;\n\n\tspin_lock_bh(&ar->htt.tx_lock);\n\tret = ath10k_htt_tx_inc_pending(htt);\n\tspin_unlock_bh(&ar->htt.tx_lock);\n\n\tif (ret)\n\t\treturn ret;\n\n\tskb = ieee80211_tx_dequeue_ni(hw, txq);\n\tif (!skb) {\n\t\tspin_lock_bh(&ar->htt.tx_lock);\n\t\tath10k_htt_tx_dec_pending(htt);\n\t\tspin_unlock_bh(&ar->htt.tx_lock);\n\n\t\treturn -ENOENT;\n\t}\n\n\tairtime = ath10k_mac_update_airtime(ar, txq, skb);\n\tath10k_mac_tx_h_fill_cb(ar, vif, txq, sta, skb, airtime);\n\n\tskb_len = skb->len;\n\ttxmode = ath10k_mac_tx_h_get_txmode(ar, vif, sta, skb);\n\ttxpath = ath10k_mac_tx_h_get_txpath(ar, skb, txmode);\n\tis_mgmt = (txpath == ATH10K_MAC_TX_HTT_MGMT);\n\n\tif (is_mgmt) {\n\t\thdr = (struct ieee80211_hdr *)skb->data;\n\t\tis_presp = ieee80211_is_probe_resp(hdr->frame_control);\n\n\t\tspin_lock_bh(&ar->htt.tx_lock);\n\t\tret = ath10k_htt_tx_mgmt_inc_pending(htt, is_mgmt, is_presp);\n\n\t\tif (ret) {\n\t\t\tath10k_htt_tx_dec_pending(htt);\n\t\t\tspin_unlock_bh(&ar->htt.tx_lock);\n\t\t\treturn ret;\n\t\t}\n\t\tspin_unlock_bh(&ar->htt.tx_lock);\n\t}\n\n\tret = ath10k_mac_tx(ar, vif, txmode, txpath, skb, false);\n\tif (unlikely(ret)) {\n\t\tath10k_warn(ar, \"failed to push frame: %d\\n\", ret);\n\n\t\tspin_lock_bh(&ar->htt.tx_lock);\n\t\tath10k_htt_tx_dec_pending(htt);\n\t\tif (is_mgmt)\n\t\t\tath10k_htt_tx_mgmt_dec_pending(htt);\n\t\tspin_unlock_bh(&ar->htt.tx_lock);\n\n\t\treturn ret;\n\t}\n\n\tspin_lock_bh(&ar->htt.tx_lock);\n\tartxq->num_fw_queued++;\n\tspin_unlock_bh(&ar->htt.tx_lock);\n\n\treturn skb_len;\n}\n\nstatic int ath10k_mac_schedule_txq(struct ieee80211_hw *hw, u32 ac)\n{\n\tstruct ieee80211_txq *txq;\n\tint ret = 0;\n\n\tieee80211_txq_schedule_start(hw, ac);\n\twhile ((txq = ieee80211_next_txq(hw, ac))) {\n\t\twhile (ath10k_mac_tx_can_push(hw, txq)) {\n\t\t\tret = ath10k_mac_tx_push_txq(hw, txq);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tieee80211_return_txq(hw, txq, false);\n\t\tath10k_htt_tx_txq_update(hw, txq);\n\t\tif (ret == -EBUSY)\n\t\t\tbreak;\n\t}\n\tieee80211_txq_schedule_end(hw, ac);\n\n\treturn ret;\n}\n\nvoid ath10k_mac_tx_push_pending(struct ath10k *ar)\n{\n\tstruct ieee80211_hw *hw = ar->hw;\n\tu32 ac;\n\n\tif (ar->htt.tx_q_state.mode != HTT_TX_MODE_SWITCH_PUSH)\n\t\treturn;\n\n\tif (ar->htt.num_pending_tx >= (ar->htt.max_num_pending_tx / 2))\n\t\treturn;\n\n\trcu_read_lock();\n\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {\n\t\tif (ath10k_mac_schedule_txq(hw, ac) == -EBUSY)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n}\nEXPORT_SYMBOL(ath10k_mac_tx_push_pending);\n\n \n \n \n\nvoid __ath10k_scan_finish(struct ath10k *ar)\n{\n\tlockdep_assert_held(&ar->data_lock);\n\n\tswitch (ar->scan.state) {\n\tcase ATH10K_SCAN_IDLE:\n\t\tbreak;\n\tcase ATH10K_SCAN_RUNNING:\n\tcase ATH10K_SCAN_ABORTING:\n\t\tif (!ar->scan.is_roc) {\n\t\t\tstruct cfg80211_scan_info info = {\n\t\t\t\t.aborted = (ar->scan.state ==\n\t\t\t\t\t    ATH10K_SCAN_ABORTING),\n\t\t\t};\n\n\t\t\tieee80211_scan_completed(ar->hw, &info);\n\t\t} else if (ar->scan.roc_notify) {\n\t\t\tieee80211_remain_on_channel_expired(ar->hw);\n\t\t}\n\t\tfallthrough;\n\tcase ATH10K_SCAN_STARTING:\n\t\tar->scan.state = ATH10K_SCAN_IDLE;\n\t\tar->scan_channel = NULL;\n\t\tar->scan.roc_freq = 0;\n\t\tath10k_offchan_tx_purge(ar);\n\t\tcancel_delayed_work(&ar->scan.timeout);\n\t\tcomplete(&ar->scan.completed);\n\t\tbreak;\n\t}\n}\n\nvoid ath10k_scan_finish(struct ath10k *ar)\n{\n\tspin_lock_bh(&ar->data_lock);\n\t__ath10k_scan_finish(ar);\n\tspin_unlock_bh(&ar->data_lock);\n}\n\nstatic int ath10k_scan_stop(struct ath10k *ar)\n{\n\tstruct wmi_stop_scan_arg arg = {\n\t\t.req_id = 1,  \n\t\t.req_type = WMI_SCAN_STOP_ONE,\n\t\t.u.scan_id = ATH10K_SCAN_ID,\n\t};\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tret = ath10k_wmi_stop_scan(ar, &arg);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to stop wmi scan: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = wait_for_completion_timeout(&ar->scan.completed, 3 * HZ);\n\tif (ret == 0) {\n\t\tath10k_warn(ar, \"failed to receive scan abortion completion: timed out\\n\");\n\t\tret = -ETIMEDOUT;\n\t} else if (ret > 0) {\n\t\tret = 0;\n\t}\n\nout:\n\t \n\tspin_lock_bh(&ar->data_lock);\n\tif (ar->scan.state != ATH10K_SCAN_IDLE)\n\t\t__ath10k_scan_finish(ar);\n\tspin_unlock_bh(&ar->data_lock);\n\n\treturn ret;\n}\n\nstatic void ath10k_scan_abort(struct ath10k *ar)\n{\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tspin_lock_bh(&ar->data_lock);\n\n\tswitch (ar->scan.state) {\n\tcase ATH10K_SCAN_IDLE:\n\t\t \n\t\tbreak;\n\tcase ATH10K_SCAN_STARTING:\n\tcase ATH10K_SCAN_ABORTING:\n\t\tath10k_warn(ar, \"refusing scan abortion due to invalid scan state: %s (%d)\\n\",\n\t\t\t    ath10k_scan_state_str(ar->scan.state),\n\t\t\t    ar->scan.state);\n\t\tbreak;\n\tcase ATH10K_SCAN_RUNNING:\n\t\tar->scan.state = ATH10K_SCAN_ABORTING;\n\t\tspin_unlock_bh(&ar->data_lock);\n\n\t\tret = ath10k_scan_stop(ar);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to abort scan: %d\\n\", ret);\n\n\t\tspin_lock_bh(&ar->data_lock);\n\t\tbreak;\n\t}\n\n\tspin_unlock_bh(&ar->data_lock);\n}\n\nvoid ath10k_scan_timeout_work(struct work_struct *work)\n{\n\tstruct ath10k *ar = container_of(work, struct ath10k,\n\t\t\t\t\t scan.timeout.work);\n\n\tmutex_lock(&ar->conf_mutex);\n\tath10k_scan_abort(ar);\n\tmutex_unlock(&ar->conf_mutex);\n}\n\nstatic int ath10k_start_scan(struct ath10k *ar,\n\t\t\t     const struct wmi_start_scan_arg *arg)\n{\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tret = ath10k_wmi_start_scan(ar, arg);\n\tif (ret)\n\t\treturn ret;\n\n\tret = wait_for_completion_timeout(&ar->scan.started, 1 * HZ);\n\tif (ret == 0) {\n\t\tret = ath10k_scan_stop(ar);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to stop scan: %d\\n\", ret);\n\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\tspin_lock_bh(&ar->data_lock);\n\tif (ar->scan.state == ATH10K_SCAN_IDLE) {\n\t\tspin_unlock_bh(&ar->data_lock);\n\t\treturn -EINVAL;\n\t}\n\tspin_unlock_bh(&ar->data_lock);\n\n\treturn 0;\n}\n\n \n \n \n\nstatic void ath10k_mac_op_tx(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_tx_control *control,\n\t\t\t     struct sk_buff *skb)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_htt *htt = &ar->htt;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_vif *vif = info->control.vif;\n\tstruct ieee80211_sta *sta = control->sta;\n\tstruct ieee80211_txq *txq = NULL;\n\tenum ath10k_hw_txrx_mode txmode;\n\tenum ath10k_mac_tx_path txpath;\n\tbool is_htt;\n\tbool is_mgmt;\n\tint ret;\n\tu16 airtime;\n\n\tairtime = ath10k_mac_update_airtime(ar, txq, skb);\n\tath10k_mac_tx_h_fill_cb(ar, vif, txq, sta, skb, airtime);\n\n\ttxmode = ath10k_mac_tx_h_get_txmode(ar, vif, sta, skb);\n\ttxpath = ath10k_mac_tx_h_get_txpath(ar, skb, txmode);\n\tis_htt = (txpath == ATH10K_MAC_TX_HTT ||\n\t\t  txpath == ATH10K_MAC_TX_HTT_MGMT);\n\tis_mgmt = (txpath == ATH10K_MAC_TX_HTT_MGMT);\n\n\tif (is_htt) {\n\t\tbool is_presp = false;\n\n\t\tspin_lock_bh(&ar->htt.tx_lock);\n\t\tif (!(info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP)) {\n\t\t\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\n\t\t\tis_presp = ieee80211_is_probe_resp(hdr->frame_control);\n\t\t}\n\n\t\tret = ath10k_htt_tx_inc_pending(htt);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to increase tx pending count: %d, dropping\\n\",\n\t\t\t\t    ret);\n\t\t\tspin_unlock_bh(&ar->htt.tx_lock);\n\t\t\tieee80211_free_txskb(ar->hw, skb);\n\t\t\treturn;\n\t\t}\n\n\t\tret = ath10k_htt_tx_mgmt_inc_pending(htt, is_mgmt, is_presp);\n\t\tif (ret) {\n\t\t\tath10k_dbg(ar, ATH10K_DBG_MAC, \"failed to increase tx mgmt pending count: %d, dropping\\n\",\n\t\t\t\t   ret);\n\t\t\tath10k_htt_tx_dec_pending(htt);\n\t\t\tspin_unlock_bh(&ar->htt.tx_lock);\n\t\t\tieee80211_free_txskb(ar->hw, skb);\n\t\t\treturn;\n\t\t}\n\t\tspin_unlock_bh(&ar->htt.tx_lock);\n\t}\n\n\tret = ath10k_mac_tx(ar, vif, txmode, txpath, skb, false);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to transmit frame: %d\\n\", ret);\n\t\tif (is_htt) {\n\t\t\tspin_lock_bh(&ar->htt.tx_lock);\n\t\t\tath10k_htt_tx_dec_pending(htt);\n\t\t\tif (is_mgmt)\n\t\t\t\tath10k_htt_tx_mgmt_dec_pending(htt);\n\t\t\tspin_unlock_bh(&ar->htt.tx_lock);\n\t\t}\n\t\treturn;\n\t}\n}\n\nstatic void ath10k_mac_op_wake_tx_queue(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_txq *txq)\n{\n\tstruct ath10k *ar = hw->priv;\n\tint ret;\n\tu8 ac = txq->ac;\n\n\tath10k_htt_tx_txq_update(hw, txq);\n\tif (ar->htt.tx_q_state.mode != HTT_TX_MODE_SWITCH_PUSH)\n\t\treturn;\n\n\tspin_lock_bh(&ar->queue_lock[ac]);\n\n\tieee80211_txq_schedule_start(hw, ac);\n\ttxq = ieee80211_next_txq(hw, ac);\n\tif (!txq)\n\t\tgoto out;\n\n\twhile (ath10k_mac_tx_can_push(hw, txq)) {\n\t\tret = ath10k_mac_tx_push_txq(hw, txq);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tieee80211_return_txq(hw, txq, false);\n\tath10k_htt_tx_txq_update(hw, txq);\nout:\n\tieee80211_txq_schedule_end(hw, ac);\n\tspin_unlock_bh(&ar->queue_lock[ac]);\n}\n\n \nvoid ath10k_drain_tx(struct ath10k *ar)\n{\n\tlockdep_assert_not_held(&ar->conf_mutex);\n\n\t \n\tsynchronize_net();\n\n\tath10k_offchan_tx_purge(ar);\n\tath10k_mgmt_over_wmi_tx_purge(ar);\n\n\tcancel_work_sync(&ar->offchan_tx_work);\n\tcancel_work_sync(&ar->wmi_mgmt_tx_work);\n}\n\nvoid ath10k_halt(struct ath10k *ar)\n{\n\tstruct ath10k_vif *arvif;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tclear_bit(ATH10K_CAC_RUNNING, &ar->dev_flags);\n\tar->filter_flags = 0;\n\tar->monitor = false;\n\tar->monitor_arvif = NULL;\n\n\tif (ar->monitor_started)\n\t\tath10k_monitor_stop(ar);\n\n\tar->monitor_started = false;\n\tar->tx_paused = 0;\n\n\tath10k_scan_finish(ar);\n\tath10k_peer_cleanup_all(ar);\n\tath10k_stop_radar_confirmation(ar);\n\tath10k_core_stop(ar);\n\tath10k_hif_power_down(ar);\n\n\tspin_lock_bh(&ar->data_lock);\n\tlist_for_each_entry(arvif, &ar->arvifs, list)\n\t\tath10k_mac_vif_beacon_cleanup(arvif);\n\tspin_unlock_bh(&ar->data_lock);\n}\n\nstatic int ath10k_get_antenna(struct ieee80211_hw *hw, u32 *tx_ant, u32 *rx_ant)\n{\n\tstruct ath10k *ar = hw->priv;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\t*tx_ant = ar->cfg_tx_chainmask;\n\t*rx_ant = ar->cfg_rx_chainmask;\n\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn 0;\n}\n\nstatic bool ath10k_check_chain_mask(struct ath10k *ar, u32 cm, const char *dbg)\n{\n\t \n\tif (cm == 15 || cm == 7 || cm == 3 || cm == 1 || cm == 0)\n\t\treturn true;\n\n\tath10k_warn(ar, \"mac %s antenna chainmask is invalid: 0x%x.  Suggested values: 15, 7, 3, 1 or 0.\\n\",\n\t\t    dbg, cm);\n\treturn false;\n}\n\nstatic int ath10k_mac_get_vht_cap_bf_sts(struct ath10k *ar)\n{\n\tint nsts = ar->vht_cap_info;\n\n\tnsts &= IEEE80211_VHT_CAP_BEAMFORMEE_STS_MASK;\n\tnsts >>= IEEE80211_VHT_CAP_BEAMFORMEE_STS_SHIFT;\n\n\t \n\tif (nsts == 0)\n\t\treturn 3;\n\n\treturn nsts;\n}\n\nstatic int ath10k_mac_get_vht_cap_bf_sound_dim(struct ath10k *ar)\n{\n\tint sound_dim = ar->vht_cap_info;\n\n\tsound_dim &= IEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_MASK;\n\tsound_dim >>= IEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_SHIFT;\n\n\t \n\tif (sound_dim == 0)\n\t\treturn 1;\n\n\treturn sound_dim;\n}\n\nstatic struct ieee80211_sta_vht_cap ath10k_create_vht_cap(struct ath10k *ar)\n{\n\tstruct ieee80211_sta_vht_cap vht_cap = {0};\n\tstruct ath10k_hw_params *hw = &ar->hw_params;\n\tu16 mcs_map;\n\tu32 val;\n\tint i;\n\n\tvht_cap.vht_supported = 1;\n\tvht_cap.cap = ar->vht_cap_info;\n\n\tif (ar->vht_cap_info & (IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE |\n\t\t\t\tIEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE)) {\n\t\tval = ath10k_mac_get_vht_cap_bf_sts(ar);\n\t\tval <<= IEEE80211_VHT_CAP_BEAMFORMEE_STS_SHIFT;\n\t\tval &= IEEE80211_VHT_CAP_BEAMFORMEE_STS_MASK;\n\n\t\tvht_cap.cap |= val;\n\t}\n\n\tif (ar->vht_cap_info & (IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE |\n\t\t\t\tIEEE80211_VHT_CAP_MU_BEAMFORMER_CAPABLE)) {\n\t\tval = ath10k_mac_get_vht_cap_bf_sound_dim(ar);\n\t\tval <<= IEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_SHIFT;\n\t\tval &= IEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_MASK;\n\n\t\tvht_cap.cap |= val;\n\t}\n\n\tmcs_map = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\tif ((i < ar->num_rf_chains) && (ar->cfg_tx_chainmask & BIT(i)))\n\t\t\tmcs_map |= IEEE80211_VHT_MCS_SUPPORT_0_9 << (i * 2);\n\t\telse\n\t\t\tmcs_map |= IEEE80211_VHT_MCS_NOT_SUPPORTED << (i * 2);\n\t}\n\n\tif (ar->cfg_tx_chainmask <= 1)\n\t\tvht_cap.cap &= ~IEEE80211_VHT_CAP_TXSTBC;\n\n\tvht_cap.vht_mcs.rx_mcs_map = cpu_to_le16(mcs_map);\n\tvht_cap.vht_mcs.tx_mcs_map = cpu_to_le16(mcs_map);\n\n\t \n\tif ((vht_cap.cap & IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK) &&\n\t    (hw->vht160_mcs_rx_highest != 0 ||\n\t     hw->vht160_mcs_tx_highest != 0)) {\n\t\tvht_cap.vht_mcs.rx_highest = cpu_to_le16(hw->vht160_mcs_rx_highest);\n\t\tvht_cap.vht_mcs.tx_highest = cpu_to_le16(hw->vht160_mcs_tx_highest);\n\t}\n\n\treturn vht_cap;\n}\n\nstatic struct ieee80211_sta_ht_cap ath10k_get_ht_cap(struct ath10k *ar)\n{\n\tint i;\n\tstruct ieee80211_sta_ht_cap ht_cap = {0};\n\n\tif (!(ar->ht_cap_info & WMI_HT_CAP_ENABLED))\n\t\treturn ht_cap;\n\n\tht_cap.ht_supported = 1;\n\tht_cap.ampdu_factor = IEEE80211_HT_MAX_AMPDU_64K;\n\tht_cap.ampdu_density = IEEE80211_HT_MPDU_DENSITY_8;\n\tht_cap.cap |= IEEE80211_HT_CAP_SUP_WIDTH_20_40;\n\tht_cap.cap |= IEEE80211_HT_CAP_DSSSCCK40;\n\tht_cap.cap |=\n\t\tWLAN_HT_CAP_SM_PS_DISABLED << IEEE80211_HT_CAP_SM_PS_SHIFT;\n\n\tif (ar->ht_cap_info & WMI_HT_CAP_HT20_SGI)\n\t\tht_cap.cap |= IEEE80211_HT_CAP_SGI_20;\n\n\tif (ar->ht_cap_info & WMI_HT_CAP_HT40_SGI)\n\t\tht_cap.cap |= IEEE80211_HT_CAP_SGI_40;\n\n\tif (ar->ht_cap_info & WMI_HT_CAP_DYNAMIC_SMPS) {\n\t\tu32 smps;\n\n\t\tsmps   = WLAN_HT_CAP_SM_PS_DYNAMIC;\n\t\tsmps <<= IEEE80211_HT_CAP_SM_PS_SHIFT;\n\n\t\tht_cap.cap |= smps;\n\t}\n\n\tif (ar->ht_cap_info & WMI_HT_CAP_TX_STBC && (ar->cfg_tx_chainmask > 1))\n\t\tht_cap.cap |= IEEE80211_HT_CAP_TX_STBC;\n\n\tif (ar->ht_cap_info & WMI_HT_CAP_RX_STBC) {\n\t\tu32 stbc;\n\n\t\tstbc   = ar->ht_cap_info;\n\t\tstbc  &= WMI_HT_CAP_RX_STBC;\n\t\tstbc >>= WMI_HT_CAP_RX_STBC_MASK_SHIFT;\n\t\tstbc <<= IEEE80211_HT_CAP_RX_STBC_SHIFT;\n\t\tstbc  &= IEEE80211_HT_CAP_RX_STBC;\n\n\t\tht_cap.cap |= stbc;\n\t}\n\n\tif (ar->ht_cap_info & WMI_HT_CAP_LDPC || (ar->ht_cap_info &\n\t    WMI_HT_CAP_RX_LDPC && (ar->ht_cap_info & WMI_HT_CAP_TX_LDPC)))\n\t\tht_cap.cap |= IEEE80211_HT_CAP_LDPC_CODING;\n\n\tif (ar->ht_cap_info & WMI_HT_CAP_L_SIG_TXOP_PROT)\n\t\tht_cap.cap |= IEEE80211_HT_CAP_LSIG_TXOP_PROT;\n\n\t \n\tif (ar->vht_cap_info & WMI_VHT_CAP_MAX_MPDU_LEN_MASK)\n\t\tht_cap.cap |= IEEE80211_HT_CAP_MAX_AMSDU;\n\n\tfor (i = 0; i < ar->num_rf_chains; i++) {\n\t\tif (ar->cfg_rx_chainmask & BIT(i))\n\t\t\tht_cap.mcs.rx_mask[i] = 0xFF;\n\t}\n\n\tht_cap.mcs.tx_params |= IEEE80211_HT_MCS_TX_DEFINED;\n\n\treturn ht_cap;\n}\n\nstatic void ath10k_mac_setup_ht_vht_cap(struct ath10k *ar)\n{\n\tstruct ieee80211_supported_band *band;\n\tstruct ieee80211_sta_vht_cap vht_cap;\n\tstruct ieee80211_sta_ht_cap ht_cap;\n\n\tht_cap = ath10k_get_ht_cap(ar);\n\tvht_cap = ath10k_create_vht_cap(ar);\n\n\tif (ar->phy_capability & WHAL_WLAN_11G_CAPABILITY) {\n\t\tband = &ar->mac.sbands[NL80211_BAND_2GHZ];\n\t\tband->ht_cap = ht_cap;\n\t}\n\tif (ar->phy_capability & WHAL_WLAN_11A_CAPABILITY) {\n\t\tband = &ar->mac.sbands[NL80211_BAND_5GHZ];\n\t\tband->ht_cap = ht_cap;\n\t\tband->vht_cap = vht_cap;\n\t}\n}\n\nstatic int __ath10k_set_antenna(struct ath10k *ar, u32 tx_ant, u32 rx_ant)\n{\n\tint ret;\n\tbool is_valid_tx_chain_mask, is_valid_rx_chain_mask;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tis_valid_tx_chain_mask = ath10k_check_chain_mask(ar, tx_ant, \"tx\");\n\tis_valid_rx_chain_mask = ath10k_check_chain_mask(ar, rx_ant, \"rx\");\n\n\tif (!is_valid_tx_chain_mask || !is_valid_rx_chain_mask)\n\t\treturn -EINVAL;\n\n\tar->cfg_tx_chainmask = tx_ant;\n\tar->cfg_rx_chainmask = rx_ant;\n\n\tif ((ar->state != ATH10K_STATE_ON) &&\n\t    (ar->state != ATH10K_STATE_RESTARTED))\n\t\treturn 0;\n\n\tret = ath10k_wmi_pdev_set_param(ar, ar->wmi.pdev_param->tx_chain_mask,\n\t\t\t\t\ttx_ant);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set tx-chainmask: %d, req 0x%x\\n\",\n\t\t\t    ret, tx_ant);\n\t\treturn ret;\n\t}\n\n\tret = ath10k_wmi_pdev_set_param(ar, ar->wmi.pdev_param->rx_chain_mask,\n\t\t\t\t\trx_ant);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set rx-chainmask: %d, req 0x%x\\n\",\n\t\t\t    ret, rx_ant);\n\t\treturn ret;\n\t}\n\n\t \n\tath10k_mac_setup_ht_vht_cap(ar);\n\n\treturn 0;\n}\n\nstatic int ath10k_set_antenna(struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant)\n{\n\tstruct ath10k *ar = hw->priv;\n\tint ret;\n\n\tmutex_lock(&ar->conf_mutex);\n\tret = __ath10k_set_antenna(ar, tx_ant, rx_ant);\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic int __ath10k_fetch_bb_timing_dt(struct ath10k *ar,\n\t\t\t\t       struct wmi_bb_timing_cfg_arg *bb_timing)\n{\n\tstruct device_node *node;\n\tconst char *fem_name;\n\tint ret;\n\n\tnode = ar->dev->of_node;\n\tif (!node)\n\t\treturn -ENOENT;\n\n\tret = of_property_read_string_index(node, \"ext-fem-name\", 0, &fem_name);\n\tif (ret)\n\t\treturn -ENOENT;\n\n\t \n\tif (!strcmp(\"microsemi-lx5586\", fem_name)) {\n\t\tbb_timing->bb_tx_timing = 0x00;\n\t\tbb_timing->bb_xpa_timing = 0x0101;\n\t} else {\n\t\treturn -ENOENT;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_BOOT, \"boot bb_tx_timing 0x%x bb_xpa_timing 0x%x\\n\",\n\t\t   bb_timing->bb_tx_timing, bb_timing->bb_xpa_timing);\n\treturn 0;\n}\n\nstatic int ath10k_mac_rfkill_config(struct ath10k *ar)\n{\n\tu32 param;\n\tint ret;\n\n\tif (ar->hw_values->rfkill_pin == 0) {\n\t\tath10k_warn(ar, \"ath10k does not support hardware rfkill with this device\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC,\n\t\t   \"mac rfkill_pin %d rfkill_cfg %d rfkill_on_level %d\",\n\t\t   ar->hw_values->rfkill_pin, ar->hw_values->rfkill_cfg,\n\t\t   ar->hw_values->rfkill_on_level);\n\n\tparam = FIELD_PREP(WMI_TLV_RFKILL_CFG_RADIO_LEVEL,\n\t\t\t   ar->hw_values->rfkill_on_level) |\n\t\tFIELD_PREP(WMI_TLV_RFKILL_CFG_GPIO_PIN_NUM,\n\t\t\t   ar->hw_values->rfkill_pin) |\n\t\tFIELD_PREP(WMI_TLV_RFKILL_CFG_PIN_AS_GPIO,\n\t\t\t   ar->hw_values->rfkill_cfg);\n\n\tret = ath10k_wmi_pdev_set_param(ar,\n\t\t\t\t\tar->wmi.pdev_param->rfkill_config,\n\t\t\t\t\tparam);\n\tif (ret) {\n\t\tath10k_warn(ar,\n\t\t\t    \"failed to set rfkill config 0x%x: %d\\n\",\n\t\t\t    param, ret);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nint ath10k_mac_rfkill_enable_radio(struct ath10k *ar, bool enable)\n{\n\tenum wmi_tlv_rfkill_enable_radio param;\n\tint ret;\n\n\tif (enable)\n\t\tparam = WMI_TLV_RFKILL_ENABLE_RADIO_ON;\n\telse\n\t\tparam = WMI_TLV_RFKILL_ENABLE_RADIO_OFF;\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac rfkill enable %d\", param);\n\n\tret = ath10k_wmi_pdev_set_param(ar, ar->wmi.pdev_param->rfkill_enable,\n\t\t\t\t\tparam);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set rfkill enable param %d: %d\\n\",\n\t\t\t    param, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_start(struct ieee80211_hw *hw)\n{\n\tstruct ath10k *ar = hw->priv;\n\tu32 param;\n\tint ret = 0;\n\tstruct wmi_bb_timing_cfg_arg bb_timing = {0};\n\n\t \n\tath10k_drain_tx(ar);\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tswitch (ar->state) {\n\tcase ATH10K_STATE_OFF:\n\t\tar->state = ATH10K_STATE_ON;\n\t\tbreak;\n\tcase ATH10K_STATE_RESTARTING:\n\t\tar->state = ATH10K_STATE_RESTARTED;\n\t\tbreak;\n\tcase ATH10K_STATE_ON:\n\tcase ATH10K_STATE_RESTARTED:\n\tcase ATH10K_STATE_WEDGED:\n\t\tWARN_ON(1);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\tcase ATH10K_STATE_UTF:\n\t\tret = -EBUSY;\n\t\tgoto err;\n\t}\n\n\tspin_lock_bh(&ar->data_lock);\n\n\tif (ar->hw_rfkill_on) {\n\t\tar->hw_rfkill_on = false;\n\t\tspin_unlock_bh(&ar->data_lock);\n\t\tgoto err;\n\t}\n\n\tspin_unlock_bh(&ar->data_lock);\n\n\tret = ath10k_hif_power_up(ar, ATH10K_FIRMWARE_MODE_NORMAL);\n\tif (ret) {\n\t\tath10k_err(ar, \"Could not init hif: %d\\n\", ret);\n\t\tgoto err_off;\n\t}\n\n\tret = ath10k_core_start(ar, ATH10K_FIRMWARE_MODE_NORMAL,\n\t\t\t\t&ar->normal_mode_fw);\n\tif (ret) {\n\t\tath10k_err(ar, \"Could not init core: %d\\n\", ret);\n\t\tgoto err_power_down;\n\t}\n\n\tif (ar->sys_cap_info & WMI_TLV_SYS_CAP_INFO_RFKILL) {\n\t\tret = ath10k_mac_rfkill_config(ar);\n\t\tif (ret && ret != -EOPNOTSUPP) {\n\t\t\tath10k_warn(ar, \"failed to configure rfkill: %d\", ret);\n\t\t\tgoto err_core_stop;\n\t\t}\n\t}\n\n\tparam = ar->wmi.pdev_param->pmf_qos;\n\tret = ath10k_wmi_pdev_set_param(ar, param, 1);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to enable PMF QOS: %d\\n\", ret);\n\t\tgoto err_core_stop;\n\t}\n\n\tparam = ar->wmi.pdev_param->dynamic_bw;\n\tret = ath10k_wmi_pdev_set_param(ar, param, 1);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to enable dynamic BW: %d\\n\", ret);\n\t\tgoto err_core_stop;\n\t}\n\n\tif (test_bit(WMI_SERVICE_SPOOF_MAC_SUPPORT, ar->wmi.svc_map)) {\n\t\tret = ath10k_wmi_scan_prob_req_oui(ar, ar->mac_addr);\n\t\tif (ret) {\n\t\t\tath10k_err(ar, \"failed to set prob req oui: %i\\n\", ret);\n\t\t\tgoto err_core_stop;\n\t\t}\n\t}\n\n\tif (test_bit(WMI_SERVICE_ADAPTIVE_OCS, ar->wmi.svc_map)) {\n\t\tret = ath10k_wmi_adaptive_qcs(ar, true);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to enable adaptive qcs: %d\\n\",\n\t\t\t\t    ret);\n\t\t\tgoto err_core_stop;\n\t\t}\n\t}\n\n\tif (test_bit(WMI_SERVICE_BURST, ar->wmi.svc_map)) {\n\t\tparam = ar->wmi.pdev_param->burst_enable;\n\t\tret = ath10k_wmi_pdev_set_param(ar, param, 0);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to disable burst: %d\\n\", ret);\n\t\t\tgoto err_core_stop;\n\t\t}\n\t}\n\n\tparam = ar->wmi.pdev_param->idle_ps_config;\n\tret = ath10k_wmi_pdev_set_param(ar, param, 1);\n\tif (ret && ret != -EOPNOTSUPP) {\n\t\tath10k_warn(ar, \"failed to enable idle_ps_config: %d\\n\", ret);\n\t\tgoto err_core_stop;\n\t}\n\n\t__ath10k_set_antenna(ar, ar->cfg_tx_chainmask, ar->cfg_rx_chainmask);\n\n\t \n\n\tparam = ar->wmi.pdev_param->arp_ac_override;\n\tret = ath10k_wmi_pdev_set_param(ar, param, 0);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set arp ac override parameter: %d\\n\",\n\t\t\t    ret);\n\t\tgoto err_core_stop;\n\t}\n\n\tif (test_bit(ATH10K_FW_FEATURE_SUPPORTS_ADAPTIVE_CCA,\n\t\t     ar->running_fw->fw_file.fw_features)) {\n\t\tret = ath10k_wmi_pdev_enable_adaptive_cca(ar, 1,\n\t\t\t\t\t\t\t  WMI_CCA_DETECT_LEVEL_AUTO,\n\t\t\t\t\t\t\t  WMI_CCA_DETECT_MARGIN_AUTO);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to enable adaptive cca: %d\\n\",\n\t\t\t\t    ret);\n\t\t\tgoto err_core_stop;\n\t\t}\n\t}\n\n\tparam = ar->wmi.pdev_param->ani_enable;\n\tret = ath10k_wmi_pdev_set_param(ar, param, 1);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to enable ani by default: %d\\n\",\n\t\t\t    ret);\n\t\tgoto err_core_stop;\n\t}\n\n\tar->ani_enabled = true;\n\n\tif (ath10k_peer_stats_enabled(ar)) {\n\t\tparam = ar->wmi.pdev_param->peer_stats_update_period;\n\t\tret = ath10k_wmi_pdev_set_param(ar, param,\n\t\t\t\t\t\tPEER_DEFAULT_STATS_UPDATE_PERIOD);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar,\n\t\t\t\t    \"failed to set peer stats period : %d\\n\",\n\t\t\t\t    ret);\n\t\t\tgoto err_core_stop;\n\t\t}\n\t}\n\n\tparam = ar->wmi.pdev_param->enable_btcoex;\n\tif (test_bit(WMI_SERVICE_COEX_GPIO, ar->wmi.svc_map) &&\n\t    test_bit(ATH10K_FW_FEATURE_BTCOEX_PARAM,\n\t\t     ar->running_fw->fw_file.fw_features) &&\n\t    ar->coex_support) {\n\t\tret = ath10k_wmi_pdev_set_param(ar, param, 0);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar,\n\t\t\t\t    \"failed to set btcoex param: %d\\n\", ret);\n\t\t\tgoto err_core_stop;\n\t\t}\n\t\tclear_bit(ATH10K_FLAG_BTCOEX, &ar->dev_flags);\n\t}\n\n\tif (test_bit(WMI_SERVICE_BB_TIMING_CONFIG_SUPPORT, ar->wmi.svc_map)) {\n\t\tret = __ath10k_fetch_bb_timing_dt(ar, &bb_timing);\n\t\tif (!ret) {\n\t\t\tret = ath10k_wmi_pdev_bb_timing(ar, &bb_timing);\n\t\t\tif (ret) {\n\t\t\t\tath10k_warn(ar,\n\t\t\t\t\t    \"failed to set bb timings: %d\\n\",\n\t\t\t\t\t    ret);\n\t\t\t\tgoto err_core_stop;\n\t\t\t}\n\t\t}\n\t}\n\n\tar->num_started_vdevs = 0;\n\tath10k_regd_update(ar);\n\n\tath10k_spectral_start(ar);\n\tath10k_thermal_set_throttling(ar);\n\n\tar->radar_conf_state = ATH10K_RADAR_CONFIRMATION_IDLE;\n\n\tmutex_unlock(&ar->conf_mutex);\n\treturn 0;\n\nerr_core_stop:\n\tath10k_core_stop(ar);\n\nerr_power_down:\n\tath10k_hif_power_down(ar);\n\nerr_off:\n\tar->state = ATH10K_STATE_OFF;\n\nerr:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic void ath10k_stop(struct ieee80211_hw *hw)\n{\n\tstruct ath10k *ar = hw->priv;\n\tu32 opt;\n\n\tath10k_drain_tx(ar);\n\n\tmutex_lock(&ar->conf_mutex);\n\tif (ar->state != ATH10K_STATE_OFF) {\n\t\tif (!ar->hw_rfkill_on) {\n\t\t\t \n\t\t\tif (ar->state != ATH10K_STATE_RESTARTING) {\n\t\t\t\tath10k_halt(ar);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\topt = WMI_PDEV_SUSPEND_AND_DISABLE_INTR;\n\t\t\t\tath10k_wait_for_suspend(ar, opt);\n\t\t\t}\n\t\t}\n\t\tar->state = ATH10K_STATE_OFF;\n\t}\n\tmutex_unlock(&ar->conf_mutex);\n\n\tcancel_work_sync(&ar->set_coverage_class_work);\n\tcancel_delayed_work_sync(&ar->scan.timeout);\n\tcancel_work_sync(&ar->restart_work);\n}\n\nstatic int ath10k_config_ps(struct ath10k *ar)\n{\n\tstruct ath10k_vif *arvif;\n\tint ret = 0;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tlist_for_each_entry(arvif, &ar->arvifs, list) {\n\t\tret = ath10k_mac_vif_setup_ps(arvif);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to setup powersave: %d\\n\", ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int ath10k_config(struct ieee80211_hw *hw, u32 changed)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ieee80211_conf *conf = &hw->conf;\n\tint ret = 0;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (changed & IEEE80211_CONF_CHANGE_PS)\n\t\tath10k_config_ps(ar);\n\n\tif (changed & IEEE80211_CONF_CHANGE_MONITOR) {\n\t\tar->monitor = conf->flags & IEEE80211_CONF_MONITOR;\n\t\tret = ath10k_monitor_recalc(ar);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to recalc monitor: %d\\n\", ret);\n\t}\n\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic u32 get_nss_from_chainmask(u16 chain_mask)\n{\n\tif ((chain_mask & 0xf) == 0xf)\n\t\treturn 4;\n\telse if ((chain_mask & 0x7) == 0x7)\n\t\treturn 3;\n\telse if ((chain_mask & 0x3) == 0x3)\n\t\treturn 2;\n\treturn 1;\n}\n\nstatic int ath10k_mac_set_txbf_conf(struct ath10k_vif *arvif)\n{\n\tu32 value = 0;\n\tstruct ath10k *ar = arvif->ar;\n\tint nsts;\n\tint sound_dim;\n\n\tif (ath10k_wmi_get_txbf_conf_scheme(ar) != WMI_TXBF_CONF_BEFORE_ASSOC)\n\t\treturn 0;\n\n\tnsts = ath10k_mac_get_vht_cap_bf_sts(ar);\n\tif (ar->vht_cap_info & (IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE |\n\t\t\t\tIEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE))\n\t\tvalue |= SM(nsts, WMI_TXBF_STS_CAP_OFFSET);\n\n\tsound_dim = ath10k_mac_get_vht_cap_bf_sound_dim(ar);\n\tif (ar->vht_cap_info & (IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE |\n\t\t\t\tIEEE80211_VHT_CAP_MU_BEAMFORMER_CAPABLE))\n\t\tvalue |= SM(sound_dim, WMI_BF_SOUND_DIM_OFFSET);\n\n\tif (!value)\n\t\treturn 0;\n\n\tif (ar->vht_cap_info & IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE)\n\t\tvalue |= WMI_VDEV_PARAM_TXBF_SU_TX_BFER;\n\n\tif (ar->vht_cap_info & IEEE80211_VHT_CAP_MU_BEAMFORMER_CAPABLE)\n\t\tvalue |= (WMI_VDEV_PARAM_TXBF_MU_TX_BFER |\n\t\t\t  WMI_VDEV_PARAM_TXBF_SU_TX_BFER);\n\n\tif (ar->vht_cap_info & IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE)\n\t\tvalue |= WMI_VDEV_PARAM_TXBF_SU_TX_BFEE;\n\n\tif (ar->vht_cap_info & IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE)\n\t\tvalue |= (WMI_VDEV_PARAM_TXBF_MU_TX_BFEE |\n\t\t\t  WMI_VDEV_PARAM_TXBF_SU_TX_BFEE);\n\n\treturn ath10k_wmi_vdev_set_param(ar, arvif->vdev_id,\n\t\t\t\t\t ar->wmi.vdev_param->txbf, value);\n}\n\nstatic void ath10k_update_vif_offload(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_vif *vif)\n{\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct ath10k *ar = hw->priv;\n\tu32 vdev_param;\n\tint ret;\n\n\tif (ath10k_frame_mode != ATH10K_HW_TXRX_ETHERNET ||\n\t    ar->wmi.vdev_param->tx_encap_type == WMI_VDEV_PARAM_UNSUPPORTED ||\n\t     (vif->type != NL80211_IFTYPE_STATION &&\n\t      vif->type != NL80211_IFTYPE_AP))\n\t\tvif->offload_flags &= ~IEEE80211_OFFLOAD_ENCAP_ENABLED;\n\n\tvdev_param = ar->wmi.vdev_param->tx_encap_type;\n\tret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, vdev_param,\n\t\t\t\t\tATH10K_HW_TXRX_NATIVE_WIFI);\n\t \n\tif (ret && ret != -EOPNOTSUPP) {\n\t\tath10k_warn(ar, \"failed to set vdev %i TX encapsulation: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t}\n}\n\n \nstatic int ath10k_add_interface(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct ath10k_peer *peer;\n\tenum wmi_sta_powersave_param param;\n\tint ret = 0;\n\tu32 value;\n\tint bit;\n\tint i;\n\tu32 vdev_param;\n\n\tvif->driver_flags |= IEEE80211_VIF_SUPPORTS_UAPSD;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tmemset(arvif, 0, sizeof(*arvif));\n\tath10k_mac_txq_init(vif->txq);\n\n\tarvif->ar = ar;\n\tarvif->vif = vif;\n\n\tINIT_LIST_HEAD(&arvif->list);\n\tINIT_WORK(&arvif->ap_csa_work, ath10k_mac_vif_ap_csa_work);\n\tINIT_DELAYED_WORK(&arvif->connection_loss_work,\n\t\t\t  ath10k_mac_vif_sta_connection_loss_work);\n\n\tfor (i = 0; i < ARRAY_SIZE(arvif->bitrate_mask.control); i++) {\n\t\tarvif->bitrate_mask.control[i].legacy = 0xffffffff;\n\t\tmemset(arvif->bitrate_mask.control[i].ht_mcs, 0xff,\n\t\t       sizeof(arvif->bitrate_mask.control[i].ht_mcs));\n\t\tmemset(arvif->bitrate_mask.control[i].vht_mcs, 0xff,\n\t\t       sizeof(arvif->bitrate_mask.control[i].vht_mcs));\n\t}\n\n\tif (ar->num_peers >= ar->max_num_peers) {\n\t\tath10k_warn(ar, \"refusing vdev creation due to insufficient peer entry resources in firmware\\n\");\n\t\tret = -ENOBUFS;\n\t\tgoto err;\n\t}\n\n\tif (ar->free_vdev_map == 0) {\n\t\tath10k_warn(ar, \"Free vdev map is empty, no more interfaces allowed.\\n\");\n\t\tret = -EBUSY;\n\t\tgoto err;\n\t}\n\tbit = __ffs64(ar->free_vdev_map);\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac create vdev %i map %llx\\n\",\n\t\t   bit, ar->free_vdev_map);\n\n\tarvif->vdev_id = bit;\n\tarvif->vdev_subtype =\n\t\tath10k_wmi_get_vdev_subtype(ar, WMI_VDEV_SUBTYPE_NONE);\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\t\tarvif->vdev_type = WMI_VDEV_TYPE_STA;\n\t\tarvif->vdev_subtype = ath10k_wmi_get_vdev_subtype\n\t\t\t\t\t(ar, WMI_VDEV_SUBTYPE_P2P_DEVICE);\n\t\tbreak;\n\tcase NL80211_IFTYPE_UNSPECIFIED:\n\tcase NL80211_IFTYPE_STATION:\n\t\tarvif->vdev_type = WMI_VDEV_TYPE_STA;\n\t\tif (vif->p2p)\n\t\t\tarvif->vdev_subtype = ath10k_wmi_get_vdev_subtype\n\t\t\t\t\t(ar, WMI_VDEV_SUBTYPE_P2P_CLIENT);\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tarvif->vdev_type = WMI_VDEV_TYPE_IBSS;\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tif (test_bit(WMI_SERVICE_MESH_11S, ar->wmi.svc_map)) {\n\t\t\tarvif->vdev_subtype = ath10k_wmi_get_vdev_subtype\n\t\t\t\t\t\t(ar, WMI_VDEV_SUBTYPE_MESH_11S);\n\t\t} else if (!test_bit(ATH10K_FLAG_RAW_MODE, &ar->dev_flags)) {\n\t\t\tret = -EINVAL;\n\t\t\tath10k_warn(ar, \"must load driver with rawmode=1 to add mesh interfaces\\n\");\n\t\t\tgoto err;\n\t\t}\n\t\tarvif->vdev_type = WMI_VDEV_TYPE_AP;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\t\tarvif->vdev_type = WMI_VDEV_TYPE_AP;\n\n\t\tif (vif->p2p)\n\t\t\tarvif->vdev_subtype = ath10k_wmi_get_vdev_subtype\n\t\t\t\t\t\t(ar, WMI_VDEV_SUBTYPE_P2P_GO);\n\t\tbreak;\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tarvif->vdev_type = WMI_VDEV_TYPE_MONITOR;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\t \n\tvif->cab_queue = arvif->vdev_id % (IEEE80211_MAX_QUEUES - 1);\n\tfor (i = 0; i < ARRAY_SIZE(vif->hw_queue); i++)\n\t\tvif->hw_queue[i] = arvif->vdev_id % (IEEE80211_MAX_QUEUES - 1);\n\n\t \n\tif (vif->type == NL80211_IFTYPE_ADHOC ||\n\t    vif->type == NL80211_IFTYPE_MESH_POINT ||\n\t    vif->type == NL80211_IFTYPE_AP) {\n\t\tif (ar->bus_param.dev_type == ATH10K_DEV_TYPE_HL) {\n\t\t\tarvif->beacon_buf = kmalloc(IEEE80211_MAX_FRAME_LEN,\n\t\t\t\t\t\t    GFP_KERNEL);\n\n\t\t\t \n\t\t\tarvif->beacon_paddr = DMA_MAPPING_ERROR;\n\t\t} else {\n\t\t\tarvif->beacon_buf =\n\t\t\t\tdma_alloc_coherent(ar->dev,\n\t\t\t\t\t\t   IEEE80211_MAX_FRAME_LEN,\n\t\t\t\t\t\t   &arvif->beacon_paddr,\n\t\t\t\t\t\t   GFP_ATOMIC);\n\t\t}\n\t\tif (!arvif->beacon_buf) {\n\t\t\tret = -ENOMEM;\n\t\t\tath10k_warn(ar, \"failed to allocate beacon buffer: %d\\n\",\n\t\t\t\t    ret);\n\t\t\tgoto err;\n\t\t}\n\t}\n\tif (test_bit(ATH10K_FLAG_HW_CRYPTO_DISABLED, &ar->dev_flags))\n\t\tarvif->nohwcrypt = true;\n\n\tif (arvif->nohwcrypt &&\n\t    !test_bit(ATH10K_FLAG_RAW_MODE, &ar->dev_flags)) {\n\t\tret = -EINVAL;\n\t\tath10k_warn(ar, \"cryptmode module param needed for sw crypto\\n\");\n\t\tgoto err;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac vdev create %d (add interface) type %d subtype %d bcnmode %s\\n\",\n\t\t   arvif->vdev_id, arvif->vdev_type, arvif->vdev_subtype,\n\t\t   arvif->beacon_buf ? \"single-buf\" : \"per-skb\");\n\n\tret = ath10k_wmi_vdev_create(ar, arvif->vdev_id, arvif->vdev_type,\n\t\t\t\t     arvif->vdev_subtype, vif->addr);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to create WMI vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\tgoto err;\n\t}\n\n\tif (test_bit(WMI_SERVICE_VDEV_DISABLE_4_ADDR_SRC_LRN_SUPPORT,\n\t\t     ar->wmi.svc_map)) {\n\t\tvdev_param = ar->wmi.vdev_param->disable_4addr_src_lrn;\n\t\tret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, vdev_param,\n\t\t\t\t\t\tWMI_VDEV_DISABLE_4_ADDR_SRC_LRN);\n\t\tif (ret && ret != -EOPNOTSUPP) {\n\t\t\tath10k_warn(ar, \"failed to disable 4addr src lrn vdev %i: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t}\n\t}\n\n\tar->free_vdev_map &= ~(1LL << arvif->vdev_id);\n\tspin_lock_bh(&ar->data_lock);\n\tlist_add(&arvif->list, &ar->arvifs);\n\tspin_unlock_bh(&ar->data_lock);\n\n\t \n\tret = ath10k_mac_vif_disable_keepalive(arvif);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to disable keepalive on vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\tgoto err_vdev_delete;\n\t}\n\n\tarvif->def_wep_key_idx = -1;\n\n\tath10k_update_vif_offload(hw, vif);\n\n\t \n\tif (ar->cfg_tx_chainmask && (vif->type != NL80211_IFTYPE_MONITOR)) {\n\t\tu16 nss = get_nss_from_chainmask(ar->cfg_tx_chainmask);\n\n\t\tvdev_param = ar->wmi.vdev_param->nss;\n\t\tret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, vdev_param,\n\t\t\t\t\t\tnss);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to set vdev %i chainmask 0x%x, nss %i: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ar->cfg_tx_chainmask, nss,\n\t\t\t\t    ret);\n\t\t\tgoto err_vdev_delete;\n\t\t}\n\t}\n\n\tif (arvif->vdev_type == WMI_VDEV_TYPE_AP ||\n\t    arvif->vdev_type == WMI_VDEV_TYPE_IBSS) {\n\t\tret = ath10k_peer_create(ar, vif, NULL, arvif->vdev_id,\n\t\t\t\t\t vif->addr, WMI_PEER_TYPE_DEFAULT);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to create vdev %i peer for AP/IBSS: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\tgoto err_vdev_delete;\n\t\t}\n\n\t\tspin_lock_bh(&ar->data_lock);\n\n\t\tpeer = ath10k_peer_find(ar, arvif->vdev_id, vif->addr);\n\t\tif (!peer) {\n\t\t\tath10k_warn(ar, \"failed to lookup peer %pM on vdev %i\\n\",\n\t\t\t\t    vif->addr, arvif->vdev_id);\n\t\t\tspin_unlock_bh(&ar->data_lock);\n\t\t\tret = -ENOENT;\n\t\t\tgoto err_peer_delete;\n\t\t}\n\n\t\tarvif->peer_id = find_first_bit(peer->peer_ids,\n\t\t\t\t\t\tATH10K_MAX_NUM_PEER_IDS);\n\n\t\tspin_unlock_bh(&ar->data_lock);\n\t} else {\n\t\tarvif->peer_id = HTT_INVALID_PEERID;\n\t}\n\n\tif (arvif->vdev_type == WMI_VDEV_TYPE_AP) {\n\t\tret = ath10k_mac_set_kickout(arvif);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to set vdev %i kickout parameters: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\tgoto err_peer_delete;\n\t\t}\n\t}\n\n\tif (arvif->vdev_type == WMI_VDEV_TYPE_STA) {\n\t\tparam = WMI_STA_PS_PARAM_RX_WAKE_POLICY;\n\t\tvalue = WMI_STA_PS_RX_WAKE_POLICY_WAKE;\n\t\tret = ath10k_wmi_set_sta_ps_param(ar, arvif->vdev_id,\n\t\t\t\t\t\t  param, value);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to set vdev %i RX wake policy: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\tgoto err_peer_delete;\n\t\t}\n\n\t\tret = ath10k_mac_vif_recalc_ps_wake_threshold(arvif);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to recalc ps wake threshold on vdev %i: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\tgoto err_peer_delete;\n\t\t}\n\n\t\tret = ath10k_mac_vif_recalc_ps_poll_count(arvif);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to recalc ps poll count on vdev %i: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\tgoto err_peer_delete;\n\t\t}\n\t}\n\n\tret = ath10k_mac_set_txbf_conf(arvif);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set txbf for vdev %d: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\tgoto err_peer_delete;\n\t}\n\n\tret = ath10k_mac_set_rts(arvif, ar->hw->wiphy->rts_threshold);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set rts threshold for vdev %d: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\tgoto err_peer_delete;\n\t}\n\n\tarvif->txpower = vif->bss_conf.txpower;\n\tret = ath10k_mac_txpower_recalc(ar);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to recalc tx power: %d\\n\", ret);\n\t\tgoto err_peer_delete;\n\t}\n\n\tif (test_bit(WMI_SERVICE_RTT_RESPONDER_ROLE, ar->wmi.svc_map)) {\n\t\tvdev_param = ar->wmi.vdev_param->rtt_responder_role;\n\t\tret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, vdev_param,\n\t\t\t\t\t\tarvif->ftm_responder);\n\n\t\t \n\t\tif (ret && ret != -EOPNOTSUPP)\n\t\t\tath10k_warn(ar, \"failed to set vdev %i FTM Responder: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t}\n\n\tif (vif->type == NL80211_IFTYPE_MONITOR) {\n\t\tar->monitor_arvif = arvif;\n\t\tret = ath10k_monitor_recalc(ar);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to recalc monitor: %d\\n\", ret);\n\t\t\tgoto err_peer_delete;\n\t\t}\n\t}\n\n\tspin_lock_bh(&ar->htt.tx_lock);\n\tif (!ar->tx_paused)\n\t\tieee80211_wake_queue(ar->hw, arvif->vdev_id);\n\tspin_unlock_bh(&ar->htt.tx_lock);\n\n\tmutex_unlock(&ar->conf_mutex);\n\treturn 0;\n\nerr_peer_delete:\n\tif (arvif->vdev_type == WMI_VDEV_TYPE_AP ||\n\t    arvif->vdev_type == WMI_VDEV_TYPE_IBSS) {\n\t\tath10k_wmi_peer_delete(ar, arvif->vdev_id, vif->addr);\n\t\tath10k_wait_for_peer_delete_done(ar, arvif->vdev_id,\n\t\t\t\t\t\t vif->addr);\n\t}\n\nerr_vdev_delete:\n\tath10k_wmi_vdev_delete(ar, arvif->vdev_id);\n\tar->free_vdev_map |= 1LL << arvif->vdev_id;\n\tspin_lock_bh(&ar->data_lock);\n\tlist_del(&arvif->list);\n\tspin_unlock_bh(&ar->data_lock);\n\nerr:\n\tif (arvif->beacon_buf) {\n\t\tif (ar->bus_param.dev_type == ATH10K_DEV_TYPE_HL)\n\t\t\tkfree(arvif->beacon_buf);\n\t\telse\n\t\t\tdma_free_coherent(ar->dev, IEEE80211_MAX_FRAME_LEN,\n\t\t\t\t\t  arvif->beacon_buf,\n\t\t\t\t\t  arvif->beacon_paddr);\n\t\tarvif->beacon_buf = NULL;\n\t}\n\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn ret;\n}\n\nstatic void ath10k_mac_vif_tx_unlock_all(struct ath10k_vif *arvif)\n{\n\tint i;\n\n\tfor (i = 0; i < BITS_PER_LONG; i++)\n\t\tath10k_mac_vif_tx_unlock(arvif, i);\n}\n\nstatic void ath10k_remove_interface(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct ath10k_peer *peer;\n\tunsigned long time_left;\n\tint ret;\n\tint i;\n\n\tcancel_work_sync(&arvif->ap_csa_work);\n\tcancel_delayed_work_sync(&arvif->connection_loss_work);\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tret = ath10k_spectral_vif_stop(arvif);\n\tif (ret)\n\t\tath10k_warn(ar, \"failed to stop spectral for vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\n\tar->free_vdev_map |= 1LL << arvif->vdev_id;\n\tspin_lock_bh(&ar->data_lock);\n\tlist_del(&arvif->list);\n\tspin_unlock_bh(&ar->data_lock);\n\n\tif (arvif->vdev_type == WMI_VDEV_TYPE_AP ||\n\t    arvif->vdev_type == WMI_VDEV_TYPE_IBSS) {\n\t\tret = ath10k_wmi_peer_delete(arvif->ar, arvif->vdev_id,\n\t\t\t\t\t     vif->addr);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to submit AP/IBSS self-peer removal on vdev %i: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\n\t\tath10k_wait_for_peer_delete_done(ar, arvif->vdev_id,\n\t\t\t\t\t\t vif->addr);\n\t\tkfree(arvif->u.ap.noa_data);\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac vdev %i delete (remove interface)\\n\",\n\t\t   arvif->vdev_id);\n\n\tret = ath10k_wmi_vdev_delete(ar, arvif->vdev_id);\n\tif (ret)\n\t\tath10k_warn(ar, \"failed to delete WMI vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\n\tif (test_bit(WMI_SERVICE_SYNC_DELETE_CMDS, ar->wmi.svc_map)) {\n\t\ttime_left = wait_for_completion_timeout(&ar->vdev_delete_done,\n\t\t\t\t\t\t\tATH10K_VDEV_DELETE_TIMEOUT_HZ);\n\t\tif (time_left == 0) {\n\t\t\tath10k_warn(ar, \"Timeout in receiving vdev delete response\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (arvif->vdev_type == WMI_VDEV_TYPE_AP ||\n\t    arvif->vdev_type == WMI_VDEV_TYPE_IBSS) {\n\t\tret = ath10k_wait_for_peer_deleted(ar, arvif->vdev_id,\n\t\t\t\t\t\t   vif->addr);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to remove AP self-peer on vdev %i: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\n\t\tspin_lock_bh(&ar->data_lock);\n\t\tar->num_peers--;\n\t\tspin_unlock_bh(&ar->data_lock);\n\t}\n\n\tspin_lock_bh(&ar->data_lock);\n\tfor (i = 0; i < ARRAY_SIZE(ar->peer_map); i++) {\n\t\tpeer = ar->peer_map[i];\n\t\tif (!peer)\n\t\t\tcontinue;\n\n\t\tif (peer->vif == vif) {\n\t\t\tath10k_warn(ar, \"found vif peer %pM entry on vdev %i after it was supposedly removed\\n\",\n\t\t\t\t    vif->addr, arvif->vdev_id);\n\t\t\tpeer->vif = NULL;\n\t\t}\n\t}\n\n\t \n\tath10k_mac_vif_beacon_cleanup(arvif);\n\tspin_unlock_bh(&ar->data_lock);\n\n\tath10k_peer_cleanup(ar, arvif->vdev_id);\n\tath10k_mac_txq_unref(ar, vif->txq);\n\n\tif (vif->type == NL80211_IFTYPE_MONITOR) {\n\t\tar->monitor_arvif = NULL;\n\t\tret = ath10k_monitor_recalc(ar);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to recalc monitor: %d\\n\", ret);\n\t}\n\n\tret = ath10k_mac_txpower_recalc(ar);\n\tif (ret)\n\t\tath10k_warn(ar, \"failed to recalc tx power: %d\\n\", ret);\n\n\tspin_lock_bh(&ar->htt.tx_lock);\n\tath10k_mac_vif_tx_unlock_all(arvif);\n\tspin_unlock_bh(&ar->htt.tx_lock);\n\n\tath10k_mac_txq_unref(ar, vif->txq);\n\nout:\n\tmutex_unlock(&ar->conf_mutex);\n}\n\n \n#define SUPPORTED_FILTERS\t\t\t\\\n\t(FIF_ALLMULTI |\t\t\t\t\\\n\tFIF_CONTROL |\t\t\t\t\\\n\tFIF_PSPOLL |\t\t\t\t\\\n\tFIF_OTHER_BSS |\t\t\t\t\\\n\tFIF_BCN_PRBRESP_PROMISC |\t\t\\\n\tFIF_PROBE_REQ |\t\t\t\t\\\n\tFIF_FCSFAIL)\n\nstatic void ath10k_configure_filter(struct ieee80211_hw *hw,\n\t\t\t\t    unsigned int changed_flags,\n\t\t\t\t    unsigned int *total_flags,\n\t\t\t\t    u64 multicast)\n{\n\tstruct ath10k *ar = hw->priv;\n\tint ret;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\t*total_flags &= SUPPORTED_FILTERS;\n\tar->filter_flags = *total_flags;\n\n\tret = ath10k_monitor_recalc(ar);\n\tif (ret)\n\t\tath10k_warn(ar, \"failed to recalc monitor: %d\\n\", ret);\n\n\tmutex_unlock(&ar->conf_mutex);\n}\n\nstatic void ath10k_recalculate_mgmt_rate(struct ath10k *ar,\n\t\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t\t struct cfg80211_chan_def *def)\n{\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tconst struct ieee80211_supported_band *sband;\n\tu8 basic_rate_idx;\n\tint hw_rate_code;\n\tu32 vdev_param;\n\tu16 bitrate;\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tsband = ar->hw->wiphy->bands[def->chan->band];\n\tbasic_rate_idx = ffs(vif->bss_conf.basic_rates) - 1;\n\tbitrate = sband->bitrates[basic_rate_idx].bitrate;\n\n\thw_rate_code = ath10k_mac_get_rate_hw_value(bitrate);\n\tif (hw_rate_code < 0) {\n\t\tath10k_warn(ar, \"bitrate not supported %d\\n\", bitrate);\n\t\treturn;\n\t}\n\n\tvdev_param = ar->wmi.vdev_param->mgmt_rate;\n\tret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, vdev_param,\n\t\t\t\t\thw_rate_code);\n\tif (ret)\n\t\tath10k_warn(ar, \"failed to set mgmt tx rate %d\\n\", ret);\n}\n\nstatic void ath10k_bss_info_changed(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct ieee80211_bss_conf *info,\n\t\t\t\t    u64 changed)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct cfg80211_chan_def def;\n\tu32 vdev_param, pdev_param, slottime, preamble;\n\tu16 bitrate, hw_value;\n\tu8 rate, rateidx;\n\tint ret = 0, mcast_rate;\n\tenum nl80211_band band;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (changed & BSS_CHANGED_IBSS)\n\t\tath10k_control_ibss(arvif, vif);\n\n\tif (changed & BSS_CHANGED_BEACON_INT) {\n\t\tarvif->beacon_interval = info->beacon_int;\n\t\tvdev_param = ar->wmi.vdev_param->beacon_interval;\n\t\tret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, vdev_param,\n\t\t\t\t\t\tarvif->beacon_interval);\n\t\tath10k_dbg(ar, ATH10K_DBG_MAC,\n\t\t\t   \"mac vdev %d beacon_interval %d\\n\",\n\t\t\t   arvif->vdev_id, arvif->beacon_interval);\n\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to set beacon interval for vdev %d: %i\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t}\n\n\tif (changed & BSS_CHANGED_BEACON) {\n\t\tath10k_dbg(ar, ATH10K_DBG_MAC,\n\t\t\t   \"vdev %d set beacon tx mode to staggered\\n\",\n\t\t\t   arvif->vdev_id);\n\n\t\tpdev_param = ar->wmi.pdev_param->beacon_tx_mode;\n\t\tret = ath10k_wmi_pdev_set_param(ar, pdev_param,\n\t\t\t\t\t\tWMI_BEACON_STAGGERED_MODE);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to set beacon mode for vdev %d: %i\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\n\t\tret = ath10k_mac_setup_bcn_tmpl(arvif);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to update beacon template: %d\\n\",\n\t\t\t\t    ret);\n\n\t\tif (ieee80211_vif_is_mesh(vif)) {\n\t\t\t \n\t\t\tstrncpy(arvif->u.ap.ssid, \"mesh\",\n\t\t\t\tsizeof(arvif->u.ap.ssid));\n\t\t\tarvif->u.ap.ssid_len = 4;\n\t\t}\n\t}\n\n\tif (changed & BSS_CHANGED_AP_PROBE_RESP) {\n\t\tret = ath10k_mac_setup_prb_tmpl(arvif);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to setup probe resp template on vdev %i: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t}\n\n\tif (changed & (BSS_CHANGED_BEACON_INFO | BSS_CHANGED_BEACON)) {\n\t\tarvif->dtim_period = info->dtim_period;\n\n\t\tath10k_dbg(ar, ATH10K_DBG_MAC,\n\t\t\t   \"mac vdev %d dtim_period %d\\n\",\n\t\t\t   arvif->vdev_id, arvif->dtim_period);\n\n\t\tvdev_param = ar->wmi.vdev_param->dtim_period;\n\t\tret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, vdev_param,\n\t\t\t\t\t\tarvif->dtim_period);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to set dtim period for vdev %d: %i\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t}\n\n\tif (changed & BSS_CHANGED_SSID &&\n\t    vif->type == NL80211_IFTYPE_AP) {\n\t\tarvif->u.ap.ssid_len = vif->cfg.ssid_len;\n\t\tif (vif->cfg.ssid_len)\n\t\t\tmemcpy(arvif->u.ap.ssid, vif->cfg.ssid,\n\t\t\t       vif->cfg.ssid_len);\n\t\tarvif->u.ap.hidden_ssid = info->hidden_ssid;\n\t}\n\n\tif (changed & BSS_CHANGED_BSSID && !is_zero_ether_addr(info->bssid))\n\t\tether_addr_copy(arvif->bssid, info->bssid);\n\n\tif (changed & BSS_CHANGED_FTM_RESPONDER &&\n\t    arvif->ftm_responder != info->ftm_responder &&\n\t    test_bit(WMI_SERVICE_RTT_RESPONDER_ROLE, ar->wmi.svc_map)) {\n\t\tarvif->ftm_responder = info->ftm_responder;\n\n\t\tvdev_param = ar->wmi.vdev_param->rtt_responder_role;\n\t\tret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, vdev_param,\n\t\t\t\t\t\tarvif->ftm_responder);\n\n\t\tath10k_dbg(ar, ATH10K_DBG_MAC,\n\t\t\t   \"mac vdev %d ftm_responder %d:ret %d\\n\",\n\t\t\t   arvif->vdev_id, arvif->ftm_responder, ret);\n\t}\n\n\tif (changed & BSS_CHANGED_BEACON_ENABLED)\n\t\tath10k_control_beaconing(arvif, info);\n\n\tif (changed & BSS_CHANGED_ERP_CTS_PROT) {\n\t\tarvif->use_cts_prot = info->use_cts_prot;\n\n\t\tret = ath10k_recalc_rtscts_prot(arvif);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to recalculate rts/cts prot for vdev %d: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\n\t\tif (ath10k_mac_can_set_cts_prot(arvif)) {\n\t\t\tret = ath10k_mac_set_cts_prot(arvif);\n\t\t\tif (ret)\n\t\t\t\tath10k_warn(ar, \"failed to set cts protection for vdev %d: %d\\n\",\n\t\t\t\t\t    arvif->vdev_id, ret);\n\t\t}\n\t}\n\n\tif (changed & BSS_CHANGED_ERP_SLOT) {\n\t\tif (info->use_short_slot)\n\t\t\tslottime = WMI_VDEV_SLOT_TIME_SHORT;  \n\n\t\telse\n\t\t\tslottime = WMI_VDEV_SLOT_TIME_LONG;  \n\n\t\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac vdev %d slot_time %d\\n\",\n\t\t\t   arvif->vdev_id, slottime);\n\n\t\tvdev_param = ar->wmi.vdev_param->slot_time;\n\t\tret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, vdev_param,\n\t\t\t\t\t\tslottime);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to set erp slot for vdev %d: %i\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t}\n\n\tif (changed & BSS_CHANGED_ERP_PREAMBLE) {\n\t\tif (info->use_short_preamble)\n\t\t\tpreamble = WMI_VDEV_PREAMBLE_SHORT;\n\t\telse\n\t\t\tpreamble = WMI_VDEV_PREAMBLE_LONG;\n\n\t\tath10k_dbg(ar, ATH10K_DBG_MAC,\n\t\t\t   \"mac vdev %d preamble %dn\",\n\t\t\t   arvif->vdev_id, preamble);\n\n\t\tvdev_param = ar->wmi.vdev_param->preamble;\n\t\tret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, vdev_param,\n\t\t\t\t\t\tpreamble);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to set preamble for vdev %d: %i\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t}\n\n\tif (changed & BSS_CHANGED_ASSOC) {\n\t\tif (vif->cfg.assoc) {\n\t\t\t \n\t\t\tif (ar->monitor_started)\n\t\t\t\tath10k_monitor_stop(ar);\n\t\t\tath10k_bss_assoc(hw, vif, info);\n\t\t\tath10k_monitor_recalc(ar);\n\t\t} else {\n\t\t\tath10k_bss_disassoc(hw, vif);\n\t\t}\n\t}\n\n\tif (changed & BSS_CHANGED_TXPOWER) {\n\t\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac vdev_id %i txpower %d\\n\",\n\t\t\t   arvif->vdev_id, info->txpower);\n\n\t\tarvif->txpower = info->txpower;\n\t\tret = ath10k_mac_txpower_recalc(ar);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to recalc tx power: %d\\n\", ret);\n\t}\n\n\tif (changed & BSS_CHANGED_PS) {\n\t\tarvif->ps = vif->cfg.ps;\n\n\t\tret = ath10k_config_ps(ar);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to setup ps on vdev %i: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t}\n\n\tif (changed & BSS_CHANGED_MCAST_RATE &&\n\t    !ath10k_mac_vif_chan(arvif->vif, &def)) {\n\t\tband = def.chan->band;\n\t\tmcast_rate = vif->bss_conf.mcast_rate[band];\n\t\tif (mcast_rate > 0)\n\t\t\trateidx = mcast_rate - 1;\n\t\telse\n\t\t\trateidx = ffs(vif->bss_conf.basic_rates) - 1;\n\n\t\tif (ar->phy_capability & WHAL_WLAN_11A_CAPABILITY)\n\t\t\trateidx += ATH10K_MAC_FIRST_OFDM_RATE_IDX;\n\n\t\tbitrate = ath10k_wmi_legacy_rates[rateidx].bitrate;\n\t\thw_value = ath10k_wmi_legacy_rates[rateidx].hw_value;\n\t\tif (ath10k_mac_bitrate_is_cck(bitrate))\n\t\t\tpreamble = WMI_RATE_PREAMBLE_CCK;\n\t\telse\n\t\t\tpreamble = WMI_RATE_PREAMBLE_OFDM;\n\n\t\trate = ATH10K_HW_RATECODE(hw_value, 0, preamble);\n\n\t\tath10k_dbg(ar, ATH10K_DBG_MAC,\n\t\t\t   \"mac vdev %d mcast_rate %x\\n\",\n\t\t\t   arvif->vdev_id, rate);\n\n\t\tvdev_param = ar->wmi.vdev_param->mcast_data_rate;\n\t\tret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id,\n\t\t\t\t\t\tvdev_param, rate);\n\t\tif (ret)\n\t\t\tath10k_warn(ar,\n\t\t\t\t    \"failed to set mcast rate on vdev %i: %d\\n\",\n\t\t\t\t    arvif->vdev_id,  ret);\n\n\t\tvdev_param = ar->wmi.vdev_param->bcast_data_rate;\n\t\tret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id,\n\t\t\t\t\t\tvdev_param, rate);\n\t\tif (ret)\n\t\t\tath10k_warn(ar,\n\t\t\t\t    \"failed to set bcast rate on vdev %i: %d\\n\",\n\t\t\t\t    arvif->vdev_id,  ret);\n\t}\n\n\tif (changed & BSS_CHANGED_BASIC_RATES &&\n\t    !ath10k_mac_vif_chan(arvif->vif, &def))\n\t\tath10k_recalculate_mgmt_rate(ar, vif, &def);\n\n\tmutex_unlock(&ar->conf_mutex);\n}\n\nstatic void ath10k_mac_op_set_coverage_class(struct ieee80211_hw *hw, s16 value)\n{\n\tstruct ath10k *ar = hw->priv;\n\n\t \n\tif (!ar->hw_params.hw_ops->set_coverage_class) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn;\n\t}\n\tar->hw_params.hw_ops->set_coverage_class(ar, value);\n}\n\nstruct ath10k_mac_tdls_iter_data {\n\tu32 num_tdls_stations;\n\tstruct ieee80211_vif *curr_vif;\n};\n\nstatic void ath10k_mac_tdls_vif_stations_count_iter(void *data,\n\t\t\t\t\t\t    struct ieee80211_sta *sta)\n{\n\tstruct ath10k_mac_tdls_iter_data *iter_data = data;\n\tstruct ath10k_sta *arsta = (struct ath10k_sta *)sta->drv_priv;\n\tstruct ieee80211_vif *sta_vif = arsta->arvif->vif;\n\n\tif (sta->tdls && sta_vif == iter_data->curr_vif)\n\t\titer_data->num_tdls_stations++;\n}\n\nstatic int ath10k_mac_tdls_vif_stations_count(struct ieee80211_hw *hw,\n\t\t\t\t\t      struct ieee80211_vif *vif)\n{\n\tstruct ath10k_mac_tdls_iter_data data = {};\n\n\tdata.curr_vif = vif;\n\n\tieee80211_iterate_stations_atomic(hw,\n\t\t\t\t\t  ath10k_mac_tdls_vif_stations_count_iter,\n\t\t\t\t\t  &data);\n\treturn data.num_tdls_stations;\n}\n\nstatic int ath10k_hw_scan(struct ieee80211_hw *hw,\n\t\t\t  struct ieee80211_vif *vif,\n\t\t\t  struct ieee80211_scan_request *hw_req)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct cfg80211_scan_request *req = &hw_req->req;\n\tstruct wmi_start_scan_arg arg;\n\tint ret = 0;\n\tint i;\n\tu32 scan_timeout;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (ath10k_mac_tdls_vif_stations_count(hw, vif) > 0) {\n\t\tret = -EBUSY;\n\t\tgoto exit;\n\t}\n\n\tspin_lock_bh(&ar->data_lock);\n\tswitch (ar->scan.state) {\n\tcase ATH10K_SCAN_IDLE:\n\t\treinit_completion(&ar->scan.started);\n\t\treinit_completion(&ar->scan.completed);\n\t\tar->scan.state = ATH10K_SCAN_STARTING;\n\t\tar->scan.is_roc = false;\n\t\tar->scan.vdev_id = arvif->vdev_id;\n\t\tret = 0;\n\t\tbreak;\n\tcase ATH10K_SCAN_STARTING:\n\tcase ATH10K_SCAN_RUNNING:\n\tcase ATH10K_SCAN_ABORTING:\n\t\tret = -EBUSY;\n\t\tbreak;\n\t}\n\tspin_unlock_bh(&ar->data_lock);\n\n\tif (ret)\n\t\tgoto exit;\n\n\tmemset(&arg, 0, sizeof(arg));\n\tath10k_wmi_start_scan_init(ar, &arg);\n\targ.vdev_id = arvif->vdev_id;\n\targ.scan_id = ATH10K_SCAN_ID;\n\n\tif (req->ie_len) {\n\t\targ.ie_len = req->ie_len;\n\t\tmemcpy(arg.ie, req->ie, arg.ie_len);\n\t}\n\n\tif (req->n_ssids) {\n\t\targ.n_ssids = req->n_ssids;\n\t\tfor (i = 0; i < arg.n_ssids; i++) {\n\t\t\targ.ssids[i].len  = req->ssids[i].ssid_len;\n\t\t\targ.ssids[i].ssid = req->ssids[i].ssid;\n\t\t}\n\t} else {\n\t\targ.scan_ctrl_flags |= WMI_SCAN_FLAG_PASSIVE;\n\t}\n\n\tif (req->flags & NL80211_SCAN_FLAG_RANDOM_ADDR) {\n\t\targ.scan_ctrl_flags |=  WMI_SCAN_ADD_SPOOFED_MAC_IN_PROBE_REQ;\n\t\tether_addr_copy(arg.mac_addr.addr, req->mac_addr);\n\t\tether_addr_copy(arg.mac_mask.addr, req->mac_addr_mask);\n\t}\n\n\tif (req->n_channels) {\n\t\targ.n_channels = req->n_channels;\n\t\tfor (i = 0; i < arg.n_channels; i++)\n\t\t\targ.channels[i] = req->channels[i]->center_freq;\n\t}\n\n\t \n\tif (req->duration) {\n\t\targ.dwell_time_active = req->duration;\n\t\targ.dwell_time_passive = req->duration;\n\t\targ.burst_duration_ms = req->duration;\n\n\t\tscan_timeout = min_t(u32, arg.max_rest_time *\n\t\t\t\t(arg.n_channels - 1) + (req->duration +\n\t\t\t\tATH10K_SCAN_CHANNEL_SWITCH_WMI_EVT_OVERHEAD) *\n\t\t\t\targ.n_channels, arg.max_scan_time);\n\t} else {\n\t\tscan_timeout = arg.max_scan_time;\n\t}\n\n\t \n\tscan_timeout += 200;\n\n\tret = ath10k_start_scan(ar, &arg);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to start hw scan: %d\\n\", ret);\n\t\tspin_lock_bh(&ar->data_lock);\n\t\tar->scan.state = ATH10K_SCAN_IDLE;\n\t\tspin_unlock_bh(&ar->data_lock);\n\t}\n\n\tieee80211_queue_delayed_work(ar->hw, &ar->scan.timeout,\n\t\t\t\t     msecs_to_jiffies(scan_timeout));\n\nexit:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic void ath10k_cancel_hw_scan(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif)\n{\n\tstruct ath10k *ar = hw->priv;\n\n\tmutex_lock(&ar->conf_mutex);\n\tath10k_scan_abort(ar);\n\tmutex_unlock(&ar->conf_mutex);\n\n\tcancel_delayed_work_sync(&ar->scan.timeout);\n}\n\nstatic void ath10k_set_key_h_def_keyidx(struct ath10k *ar,\n\t\t\t\t\tstruct ath10k_vif *arvif,\n\t\t\t\t\tenum set_key_cmd cmd,\n\t\t\t\t\tstruct ieee80211_key_conf *key)\n{\n\tu32 vdev_param = arvif->ar->wmi.vdev_param->def_keyid;\n\tint ret;\n\n\t \n\n\tif (arvif->vdev_type != WMI_VDEV_TYPE_AP &&\n\t    arvif->vdev_type != WMI_VDEV_TYPE_IBSS)\n\t\treturn;\n\n\tif (key->cipher == WLAN_CIPHER_SUITE_WEP40)\n\t\treturn;\n\n\tif (key->cipher == WLAN_CIPHER_SUITE_WEP104)\n\t\treturn;\n\n\tif (key->flags & IEEE80211_KEY_FLAG_PAIRWISE)\n\t\treturn;\n\n\tif (cmd != SET_KEY)\n\t\treturn;\n\n\tret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, vdev_param,\n\t\t\t\t\tkey->keyidx);\n\tif (ret)\n\t\tath10k_warn(ar, \"failed to set vdev %i group key as default key: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n}\n\nstatic int ath10k_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,\n\t\t\t  struct ieee80211_vif *vif, struct ieee80211_sta *sta,\n\t\t\t  struct ieee80211_key_conf *key)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct ath10k_sta *arsta;\n\tstruct ath10k_peer *peer;\n\tconst u8 *peer_addr;\n\tbool is_wep = key->cipher == WLAN_CIPHER_SUITE_WEP40 ||\n\t\t      key->cipher == WLAN_CIPHER_SUITE_WEP104;\n\tint ret = 0;\n\tint ret2;\n\tu32 flags = 0;\n\tu32 flags2;\n\n\t \n\tif (key->cipher == WLAN_CIPHER_SUITE_AES_CMAC ||\n\t    key->cipher == WLAN_CIPHER_SUITE_BIP_GMAC_128 ||\n\t    key->cipher == WLAN_CIPHER_SUITE_BIP_GMAC_256 ||\n\t    key->cipher == WLAN_CIPHER_SUITE_BIP_CMAC_256)\n\t\treturn 1;\n\n\tif (arvif->nohwcrypt)\n\t\treturn 1;\n\n\tif (key->keyidx > WMI_MAX_KEY_INDEX)\n\t\treturn -ENOSPC;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (sta) {\n\t\tarsta = (struct ath10k_sta *)sta->drv_priv;\n\t\tpeer_addr = sta->addr;\n\t\tspin_lock_bh(&ar->data_lock);\n\t\tarsta->ucast_cipher = key->cipher;\n\t\tspin_unlock_bh(&ar->data_lock);\n\t} else if (arvif->vdev_type == WMI_VDEV_TYPE_STA) {\n\t\tpeer_addr = vif->bss_conf.bssid;\n\t} else {\n\t\tpeer_addr = vif->addr;\n\t}\n\n\tkey->hw_key_idx = key->keyidx;\n\n\tif (is_wep) {\n\t\tif (cmd == SET_KEY)\n\t\t\tarvif->wep_keys[key->keyidx] = key;\n\t\telse\n\t\t\tarvif->wep_keys[key->keyidx] = NULL;\n\t}\n\n\t \n\tspin_lock_bh(&ar->data_lock);\n\tpeer = ath10k_peer_find(ar, arvif->vdev_id, peer_addr);\n\tspin_unlock_bh(&ar->data_lock);\n\n\tif (!peer) {\n\t\tif (cmd == SET_KEY) {\n\t\t\tath10k_warn(ar, \"failed to install key for non-existent peer %pM\\n\",\n\t\t\t\t    peer_addr);\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto exit;\n\t\t} else {\n\t\t\t \n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (key->flags & IEEE80211_KEY_FLAG_PAIRWISE)\n\t\tflags |= WMI_KEY_PAIRWISE;\n\telse\n\t\tflags |= WMI_KEY_GROUP;\n\n\tif (is_wep) {\n\t\tif (cmd == DISABLE_KEY)\n\t\t\tath10k_clear_vdev_key(arvif, key);\n\n\t\t \n\t\tif (vif->type == NL80211_IFTYPE_ADHOC &&\n\t\t    cmd == SET_KEY)\n\t\t\tath10k_mac_vif_update_wep_key(arvif, key);\n\n\t\t \n\t\tif (cmd == SET_KEY && arvif->def_wep_key_idx == -1)\n\t\t\tflags |= WMI_KEY_TX_USAGE;\n\t}\n\n\tret = ath10k_install_key(arvif, key, cmd, peer_addr, flags);\n\tif (ret) {\n\t\tWARN_ON(ret > 0);\n\t\tath10k_warn(ar, \"failed to install key for vdev %i peer %pM: %d\\n\",\n\t\t\t    arvif->vdev_id, peer_addr, ret);\n\t\tgoto exit;\n\t}\n\n\t \n\tif (is_wep && !sta && vif->type == NL80211_IFTYPE_STATION) {\n\t\tflags2 = flags;\n\t\tflags2 &= ~WMI_KEY_GROUP;\n\t\tflags2 |= WMI_KEY_PAIRWISE;\n\n\t\tret = ath10k_install_key(arvif, key, cmd, peer_addr, flags2);\n\t\tif (ret) {\n\t\t\tWARN_ON(ret > 0);\n\t\t\tath10k_warn(ar, \"failed to install (ucast) key for vdev %i peer %pM: %d\\n\",\n\t\t\t\t    arvif->vdev_id, peer_addr, ret);\n\t\t\tret2 = ath10k_install_key(arvif, key, DISABLE_KEY,\n\t\t\t\t\t\t  peer_addr, flags);\n\t\t\tif (ret2) {\n\t\t\t\tWARN_ON(ret2 > 0);\n\t\t\t\tath10k_warn(ar, \"failed to disable (mcast) key for vdev %i peer %pM: %d\\n\",\n\t\t\t\t\t    arvif->vdev_id, peer_addr, ret2);\n\t\t\t}\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tath10k_set_key_h_def_keyidx(ar, arvif, cmd, key);\n\n\tspin_lock_bh(&ar->data_lock);\n\tpeer = ath10k_peer_find(ar, arvif->vdev_id, peer_addr);\n\tif (peer && cmd == SET_KEY)\n\t\tpeer->keys[key->keyidx] = key;\n\telse if (peer && cmd == DISABLE_KEY)\n\t\tpeer->keys[key->keyidx] = NULL;\n\telse if (peer == NULL)\n\t\t \n\t\tath10k_warn(ar, \"Peer %pM disappeared!\\n\", peer_addr);\n\tspin_unlock_bh(&ar->data_lock);\n\n\tif (sta && sta->tdls)\n\t\tath10k_wmi_peer_set_param(ar, arvif->vdev_id, sta->addr,\n\t\t\t\t\t  ar->wmi.peer_param->authorize, 1);\n\telse if (sta && cmd == SET_KEY && (key->flags & IEEE80211_KEY_FLAG_PAIRWISE))\n\t\tath10k_wmi_peer_set_param(ar, arvif->vdev_id, peer_addr,\n\t\t\t\t\t  ar->wmi.peer_param->authorize, 1);\n\nexit:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic void ath10k_set_default_unicast_key(struct ieee80211_hw *hw,\n\t\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t\t   int keyidx)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tint ret;\n\n\tmutex_lock(&arvif->ar->conf_mutex);\n\n\tif (arvif->ar->state != ATH10K_STATE_ON)\n\t\tgoto unlock;\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac vdev %d set keyidx %d\\n\",\n\t\t   arvif->vdev_id, keyidx);\n\n\tret = ath10k_wmi_vdev_set_param(arvif->ar,\n\t\t\t\t\tarvif->vdev_id,\n\t\t\t\t\tarvif->ar->wmi.vdev_param->def_keyid,\n\t\t\t\t\tkeyidx);\n\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to update wep key index for vdev %d: %d\\n\",\n\t\t\t    arvif->vdev_id,\n\t\t\t    ret);\n\t\tgoto unlock;\n\t}\n\n\tarvif->def_wep_key_idx = keyidx;\n\nunlock:\n\tmutex_unlock(&arvif->ar->conf_mutex);\n}\n\nstatic void ath10k_sta_rc_update_wk(struct work_struct *wk)\n{\n\tstruct ath10k *ar;\n\tstruct ath10k_vif *arvif;\n\tstruct ath10k_sta *arsta;\n\tstruct ieee80211_sta *sta;\n\tstruct cfg80211_chan_def def;\n\tenum nl80211_band band;\n\tconst u8 *ht_mcs_mask;\n\tconst u16 *vht_mcs_mask;\n\tu32 changed, bw, nss, smps;\n\tint err;\n\n\tarsta = container_of(wk, struct ath10k_sta, update_wk);\n\tsta = container_of((void *)arsta, struct ieee80211_sta, drv_priv);\n\tarvif = arsta->arvif;\n\tar = arvif->ar;\n\n\tif (WARN_ON(ath10k_mac_vif_chan(arvif->vif, &def)))\n\t\treturn;\n\n\tband = def.chan->band;\n\tht_mcs_mask = arvif->bitrate_mask.control[band].ht_mcs;\n\tvht_mcs_mask = arvif->bitrate_mask.control[band].vht_mcs;\n\n\tspin_lock_bh(&ar->data_lock);\n\n\tchanged = arsta->changed;\n\tarsta->changed = 0;\n\n\tbw = arsta->bw;\n\tnss = arsta->nss;\n\tsmps = arsta->smps;\n\n\tspin_unlock_bh(&ar->data_lock);\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tnss = max_t(u32, 1, nss);\n\tnss = min(nss, max(ath10k_mac_max_ht_nss(ht_mcs_mask),\n\t\t\t   ath10k_mac_max_vht_nss(vht_mcs_mask)));\n\n\tif (changed & IEEE80211_RC_BW_CHANGED) {\n\t\tenum wmi_phy_mode mode;\n\n\t\tmode = chan_to_phymode(&def);\n\t\tath10k_dbg(ar, ATH10K_DBG_STA, \"mac update sta %pM peer bw %d phymode %d\\n\",\n\t\t\t   sta->addr, bw, mode);\n\n\t\terr = ath10k_wmi_peer_set_param(ar, arvif->vdev_id, sta->addr,\n\t\t\t\t\t\tar->wmi.peer_param->phymode, mode);\n\t\tif (err) {\n\t\t\tath10k_warn(ar, \"failed to update STA %pM peer phymode %d: %d\\n\",\n\t\t\t\t    sta->addr, mode, err);\n\t\t\tgoto exit;\n\t\t}\n\n\t\terr = ath10k_wmi_peer_set_param(ar, arvif->vdev_id, sta->addr,\n\t\t\t\t\t\tar->wmi.peer_param->chan_width, bw);\n\t\tif (err)\n\t\t\tath10k_warn(ar, \"failed to update STA %pM peer bw %d: %d\\n\",\n\t\t\t\t    sta->addr, bw, err);\n\t}\n\n\tif (changed & IEEE80211_RC_NSS_CHANGED) {\n\t\tath10k_dbg(ar, ATH10K_DBG_STA, \"mac update sta %pM nss %d\\n\",\n\t\t\t   sta->addr, nss);\n\n\t\terr = ath10k_wmi_peer_set_param(ar, arvif->vdev_id, sta->addr,\n\t\t\t\t\t\tar->wmi.peer_param->nss, nss);\n\t\tif (err)\n\t\t\tath10k_warn(ar, \"failed to update STA %pM nss %d: %d\\n\",\n\t\t\t\t    sta->addr, nss, err);\n\t}\n\n\tif (changed & IEEE80211_RC_SMPS_CHANGED) {\n\t\tath10k_dbg(ar, ATH10K_DBG_STA, \"mac update sta %pM smps %d\\n\",\n\t\t\t   sta->addr, smps);\n\n\t\terr = ath10k_wmi_peer_set_param(ar, arvif->vdev_id, sta->addr,\n\t\t\t\t\t\tar->wmi.peer_param->smps_state, smps);\n\t\tif (err)\n\t\t\tath10k_warn(ar, \"failed to update STA %pM smps %d: %d\\n\",\n\t\t\t\t    sta->addr, smps, err);\n\t}\n\n\tif (changed & IEEE80211_RC_SUPP_RATES_CHANGED) {\n\t\tath10k_dbg(ar, ATH10K_DBG_STA, \"mac update sta %pM supp rates\\n\",\n\t\t\t   sta->addr);\n\n\t\terr = ath10k_station_assoc(ar, arvif->vif, sta, true);\n\t\tif (err)\n\t\t\tath10k_warn(ar, \"failed to reassociate station: %pM\\n\",\n\t\t\t\t    sta->addr);\n\t}\n\nexit:\n\tmutex_unlock(&ar->conf_mutex);\n}\n\nstatic int ath10k_mac_inc_num_stations(struct ath10k_vif *arvif,\n\t\t\t\t       struct ieee80211_sta *sta)\n{\n\tstruct ath10k *ar = arvif->ar;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (arvif->vdev_type == WMI_VDEV_TYPE_STA && !sta->tdls)\n\t\treturn 0;\n\n\tif (ar->num_stations >= ar->max_num_stations)\n\t\treturn -ENOBUFS;\n\n\tar->num_stations++;\n\n\treturn 0;\n}\n\nstatic void ath10k_mac_dec_num_stations(struct ath10k_vif *arvif,\n\t\t\t\t\tstruct ieee80211_sta *sta)\n{\n\tstruct ath10k *ar = arvif->ar;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (arvif->vdev_type == WMI_VDEV_TYPE_STA && !sta->tdls)\n\t\treturn;\n\n\tar->num_stations--;\n}\n\nstatic int ath10k_sta_set_txpwr(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_sta *sta)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tint ret = 0;\n\ts16 txpwr;\n\n\tif (sta->deflink.txpwr.type == NL80211_TX_POWER_AUTOMATIC) {\n\t\ttxpwr = 0;\n\t} else {\n\t\ttxpwr = sta->deflink.txpwr.power;\n\t\tif (!txpwr)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (txpwr > ATH10K_TX_POWER_MAX_VAL || txpwr < ATH10K_TX_POWER_MIN_VAL)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tret = ath10k_wmi_peer_set_param(ar, arvif->vdev_id, sta->addr,\n\t\t\t\t\tar->wmi.peer_param->use_fixed_power, txpwr);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set tx power for station ret: %d\\n\",\n\t\t\t    ret);\n\t\tgoto out;\n\t}\n\nout:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstruct ath10k_mac_iter_tid_conf_data {\n\tstruct ieee80211_vif *curr_vif;\n\tstruct ath10k *ar;\n\tbool reset_config;\n};\n\nstatic bool\nath10k_mac_bitrate_mask_has_single_rate(struct ath10k *ar,\n\t\t\t\t\tenum nl80211_band band,\n\t\t\t\t\tconst struct cfg80211_bitrate_mask *mask,\n\t\t\t\t\tint *vht_num_rates)\n{\n\tint num_rates = 0;\n\tint i, tmp;\n\n\tnum_rates += hweight32(mask->control[band].legacy);\n\n\tfor (i = 0; i < ARRAY_SIZE(mask->control[band].ht_mcs); i++)\n\t\tnum_rates += hweight8(mask->control[band].ht_mcs[i]);\n\n\t*vht_num_rates = 0;\n\tfor (i = 0; i < ARRAY_SIZE(mask->control[band].vht_mcs); i++) {\n\t\ttmp = hweight16(mask->control[band].vht_mcs[i]);\n\t\tnum_rates += tmp;\n\t\t*vht_num_rates += tmp;\n\t}\n\n\treturn num_rates == 1;\n}\n\nstatic int\nath10k_mac_bitrate_mask_get_single_rate(struct ath10k *ar,\n\t\t\t\t\tenum nl80211_band band,\n\t\t\t\t\tconst struct cfg80211_bitrate_mask *mask,\n\t\t\t\t\tu8 *rate, u8 *nss, bool vht_only)\n{\n\tint rate_idx;\n\tint i;\n\tu16 bitrate;\n\tu8 preamble;\n\tu8 hw_rate;\n\n\tif (vht_only)\n\t\tgoto next;\n\n\tif (hweight32(mask->control[band].legacy) == 1) {\n\t\trate_idx = ffs(mask->control[band].legacy) - 1;\n\n\t\tif (ar->phy_capability & WHAL_WLAN_11A_CAPABILITY)\n\t\t\trate_idx += ATH10K_MAC_FIRST_OFDM_RATE_IDX;\n\n\t\thw_rate = ath10k_wmi_legacy_rates[rate_idx].hw_value;\n\t\tbitrate = ath10k_wmi_legacy_rates[rate_idx].bitrate;\n\n\t\tif (ath10k_mac_bitrate_is_cck(bitrate))\n\t\t\tpreamble = WMI_RATE_PREAMBLE_CCK;\n\t\telse\n\t\t\tpreamble = WMI_RATE_PREAMBLE_OFDM;\n\n\t\t*nss = 1;\n\t\t*rate = preamble << 6 |\n\t\t\t(*nss - 1) << 4 |\n\t\t\thw_rate << 0;\n\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(mask->control[band].ht_mcs); i++) {\n\t\tif (hweight8(mask->control[band].ht_mcs[i]) == 1) {\n\t\t\t*nss = i + 1;\n\t\t\t*rate = WMI_RATE_PREAMBLE_HT << 6 |\n\t\t\t\t(*nss - 1) << 4 |\n\t\t\t\t(ffs(mask->control[band].ht_mcs[i]) - 1);\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\nnext:\n\tfor (i = 0; i < ARRAY_SIZE(mask->control[band].vht_mcs); i++) {\n\t\tif (hweight16(mask->control[band].vht_mcs[i]) == 1) {\n\t\t\t*nss = i + 1;\n\t\t\t*rate = WMI_RATE_PREAMBLE_VHT << 6 |\n\t\t\t\t(*nss - 1) << 4 |\n\t\t\t\t(ffs(mask->control[band].vht_mcs[i]) - 1);\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int ath10k_mac_validate_rate_mask(struct ath10k *ar,\n\t\t\t\t\t struct ieee80211_sta *sta,\n\t\t\t\t\t u32 rate_ctrl_flag, u8 nss)\n{\n\tstruct ieee80211_sta_ht_cap *ht_cap = &sta->deflink.ht_cap;\n\tstruct ieee80211_sta_vht_cap *vht_cap = &sta->deflink.vht_cap;\n\n\tif (nss > sta->deflink.rx_nss) {\n\t\tath10k_warn(ar, \"Invalid nss field, configured %u limit %u\\n\",\n\t\t\t    nss, sta->deflink.rx_nss);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ATH10K_HW_PREAMBLE(rate_ctrl_flag) == WMI_RATE_PREAMBLE_VHT) {\n\t\tif (!vht_cap->vht_supported) {\n\t\t\tath10k_warn(ar, \"Invalid VHT rate for sta %pM\\n\",\n\t\t\t\t    sta->addr);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else if (ATH10K_HW_PREAMBLE(rate_ctrl_flag) == WMI_RATE_PREAMBLE_HT) {\n\t\tif (!ht_cap->ht_supported || vht_cap->vht_supported) {\n\t\t\tath10k_warn(ar, \"Invalid HT rate for sta %pM\\n\",\n\t\t\t\t    sta->addr);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tif (ht_cap->ht_supported || vht_cap->vht_supported)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nath10k_mac_tid_bitrate_config(struct ath10k *ar,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      struct ieee80211_sta *sta,\n\t\t\t      u32 *rate_ctrl_flag, u8 *rate_ctrl,\n\t\t\t      enum nl80211_tx_rate_setting txrate_type,\n\t\t\t      const struct cfg80211_bitrate_mask *mask)\n{\n\tstruct cfg80211_chan_def def;\n\tenum nl80211_band band;\n\tu8 nss, rate;\n\tint vht_num_rates, ret;\n\n\tif (WARN_ON(ath10k_mac_vif_chan(vif, &def)))\n\t\treturn -EINVAL;\n\n\tif (txrate_type == NL80211_TX_RATE_AUTOMATIC) {\n\t\t*rate_ctrl = WMI_TID_CONFIG_RATE_CONTROL_AUTO;\n\t\t*rate_ctrl_flag = 0;\n\t\treturn 0;\n\t}\n\n\tband = def.chan->band;\n\n\tif (!ath10k_mac_bitrate_mask_has_single_rate(ar, band, mask,\n\t\t\t\t\t\t     &vht_num_rates)) {\n\t\treturn -EINVAL;\n\t}\n\n\tret = ath10k_mac_bitrate_mask_get_single_rate(ar, band, mask,\n\t\t\t\t\t\t      &rate, &nss, false);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to get single rate: %d\\n\",\n\t\t\t    ret);\n\t\treturn ret;\n\t}\n\n\t*rate_ctrl_flag = rate;\n\n\tif (sta && ath10k_mac_validate_rate_mask(ar, sta, *rate_ctrl_flag, nss))\n\t\treturn -EINVAL;\n\n\tif (txrate_type == NL80211_TX_RATE_FIXED)\n\t\t*rate_ctrl = WMI_TID_CONFIG_RATE_CONTROL_FIXED_RATE;\n\telse if (txrate_type == NL80211_TX_RATE_LIMITED &&\n\t\t (test_bit(WMI_SERVICE_EXT_PEER_TID_CONFIGS_SUPPORT,\n\t\t\t   ar->wmi.svc_map)))\n\t\t*rate_ctrl = WMI_PEER_TID_CONFIG_RATE_UPPER_CAP;\n\telse\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}\n\nstatic int ath10k_mac_set_tid_config(struct ath10k *ar, struct ieee80211_sta *sta,\n\t\t\t\t     struct ieee80211_vif *vif, u32 changed,\n\t\t\t\t     struct wmi_per_peer_per_tid_cfg_arg *arg)\n{\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct ath10k_sta *arsta;\n\tint ret;\n\n\tif (sta) {\n\t\tif (!sta->wme)\n\t\t\treturn -ENOTSUPP;\n\n\t\tarsta = (struct ath10k_sta *)sta->drv_priv;\n\n\t\tif (changed & BIT(NL80211_TID_CONFIG_ATTR_NOACK)) {\n\t\t\tif ((arsta->retry_long[arg->tid] > 0 ||\n\t\t\t     arsta->rate_code[arg->tid] > 0 ||\n\t\t\t     arsta->ampdu[arg->tid] ==\n\t\t\t\t\tWMI_TID_CONFIG_AGGR_CONTROL_ENABLE) &&\n\t\t\t     arg->ack_policy == WMI_PEER_TID_CONFIG_NOACK) {\n\t\t\t\tchanged &= ~BIT(NL80211_TID_CONFIG_ATTR_NOACK);\n\t\t\t\targ->ack_policy = 0;\n\t\t\t\targ->aggr_control = 0;\n\t\t\t\targ->rate_ctrl = 0;\n\t\t\t\targ->rcode_flags = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (changed & BIT(NL80211_TID_CONFIG_ATTR_AMPDU_CTRL)) {\n\t\t\tif (arsta->noack[arg->tid] == WMI_PEER_TID_CONFIG_NOACK ||\n\t\t\t    arvif->noack[arg->tid] == WMI_PEER_TID_CONFIG_NOACK) {\n\t\t\t\targ->aggr_control = 0;\n\t\t\t\tchanged &= ~BIT(NL80211_TID_CONFIG_ATTR_RETRY_LONG);\n\t\t\t}\n\t\t}\n\n\t\tif (changed & (BIT(NL80211_TID_CONFIG_ATTR_TX_RATE) |\n\t\t    BIT(NL80211_TID_CONFIG_ATTR_TX_RATE_TYPE))) {\n\t\t\tif (arsta->noack[arg->tid] == WMI_PEER_TID_CONFIG_NOACK ||\n\t\t\t    arvif->noack[arg->tid] == WMI_PEER_TID_CONFIG_NOACK) {\n\t\t\t\targ->rate_ctrl = 0;\n\t\t\t\targ->rcode_flags = 0;\n\t\t\t}\n\t\t}\n\n\t\tether_addr_copy(arg->peer_macaddr.addr, sta->addr);\n\n\t\tret = ath10k_wmi_set_per_peer_per_tid_cfg(ar, arg);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (changed & BIT(NL80211_TID_CONFIG_ATTR_NOACK)) {\n\t\t\tarsta->noack[arg->tid] = arg->ack_policy;\n\t\t\targ->ack_policy = 0;\n\t\t\targ->aggr_control = 0;\n\t\t\targ->rate_ctrl = 0;\n\t\t\targ->rcode_flags = 0;\n\t\t}\n\n\t\tif (changed & BIT(NL80211_TID_CONFIG_ATTR_RETRY_LONG)) {\n\t\t\tarsta->retry_long[arg->tid] = arg->retry_count;\n\t\t\targ->retry_count = 0;\n\t\t}\n\n\t\tif (changed & BIT(NL80211_TID_CONFIG_ATTR_AMPDU_CTRL)) {\n\t\t\tarsta->ampdu[arg->tid] = arg->aggr_control;\n\t\t\targ->aggr_control = 0;\n\t\t}\n\n\t\tif (changed & (BIT(NL80211_TID_CONFIG_ATTR_TX_RATE) |\n\t\t    BIT(NL80211_TID_CONFIG_ATTR_TX_RATE_TYPE))) {\n\t\t\tarsta->rate_ctrl[arg->tid] = arg->rate_ctrl;\n\t\t\targ->rate_ctrl = 0;\n\t\t\targ->rcode_flags = 0;\n\t\t}\n\n\t\tif (changed & BIT(NL80211_TID_CONFIG_ATTR_RTSCTS_CTRL)) {\n\t\t\tarsta->rtscts[arg->tid] = arg->rtscts_ctrl;\n\t\t\targ->ext_tid_cfg_bitmap = 0;\n\t\t}\n\t} else {\n\t\tif (changed & BIT(NL80211_TID_CONFIG_ATTR_NOACK)) {\n\t\t\tif ((arvif->retry_long[arg->tid] ||\n\t\t\t     arvif->rate_code[arg->tid] ||\n\t\t\t     arvif->ampdu[arg->tid] ==\n\t\t\t\t\tWMI_TID_CONFIG_AGGR_CONTROL_ENABLE) &&\n\t\t\t     arg->ack_policy == WMI_PEER_TID_CONFIG_NOACK) {\n\t\t\t\tchanged &= ~BIT(NL80211_TID_CONFIG_ATTR_NOACK);\n\t\t\t} else {\n\t\t\t\tarvif->noack[arg->tid] = arg->ack_policy;\n\t\t\t\tarvif->ampdu[arg->tid] = arg->aggr_control;\n\t\t\t\tarvif->rate_ctrl[arg->tid] = arg->rate_ctrl;\n\t\t\t}\n\t\t}\n\n\t\tif (changed & BIT(NL80211_TID_CONFIG_ATTR_RETRY_LONG)) {\n\t\t\tif (arvif->noack[arg->tid] == WMI_PEER_TID_CONFIG_NOACK)\n\t\t\t\tchanged &= ~BIT(NL80211_TID_CONFIG_ATTR_RETRY_LONG);\n\t\t\telse\n\t\t\t\tarvif->retry_long[arg->tid] = arg->retry_count;\n\t\t}\n\n\t\tif (changed & BIT(NL80211_TID_CONFIG_ATTR_AMPDU_CTRL)) {\n\t\t\tif (arvif->noack[arg->tid] == WMI_PEER_TID_CONFIG_NOACK)\n\t\t\t\tchanged &= ~BIT(NL80211_TID_CONFIG_ATTR_AMPDU_CTRL);\n\t\t\telse\n\t\t\t\tarvif->ampdu[arg->tid] = arg->aggr_control;\n\t\t}\n\n\t\tif (changed & (BIT(NL80211_TID_CONFIG_ATTR_TX_RATE) |\n\t\t    BIT(NL80211_TID_CONFIG_ATTR_TX_RATE_TYPE))) {\n\t\t\tif (arvif->noack[arg->tid] == WMI_PEER_TID_CONFIG_NOACK) {\n\t\t\t\tchanged &= ~(BIT(NL80211_TID_CONFIG_ATTR_TX_RATE) |\n\t\t\t\t\t     BIT(NL80211_TID_CONFIG_ATTR_TX_RATE_TYPE));\n\t\t\t} else {\n\t\t\t\tarvif->rate_ctrl[arg->tid] = arg->rate_ctrl;\n\t\t\t\tarvif->rate_code[arg->tid] = arg->rcode_flags;\n\t\t\t}\n\t\t}\n\n\t\tif (changed & BIT(NL80211_TID_CONFIG_ATTR_RTSCTS_CTRL)) {\n\t\t\tarvif->rtscts[arg->tid] = arg->rtscts_ctrl;\n\t\t\targ->ext_tid_cfg_bitmap = 0;\n\t\t}\n\n\t\tif (changed)\n\t\t\tarvif->tid_conf_changed[arg->tid] |= changed;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nath10k_mac_parse_tid_config(struct ath10k *ar,\n\t\t\t    struct ieee80211_sta *sta,\n\t\t\t    struct ieee80211_vif *vif,\n\t\t\t    struct cfg80211_tid_cfg *tid_conf,\n\t\t\t    struct wmi_per_peer_per_tid_cfg_arg *arg)\n{\n\tu32 changed = tid_conf->mask;\n\tint ret = 0, i = 0;\n\n\tif (!changed)\n\t\treturn -EINVAL;\n\n\twhile (i < ATH10K_TID_MAX) {\n\t\tif (!(tid_conf->tids & BIT(i))) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\targ->tid = i;\n\n\t\tif (changed & BIT(NL80211_TID_CONFIG_ATTR_NOACK)) {\n\t\t\tif (tid_conf->noack == NL80211_TID_CONFIG_ENABLE) {\n\t\t\t\targ->ack_policy = WMI_PEER_TID_CONFIG_NOACK;\n\t\t\t\targ->rate_ctrl =\n\t\t\t\tWMI_TID_CONFIG_RATE_CONTROL_DEFAULT_LOWEST_RATE;\n\t\t\t\targ->aggr_control =\n\t\t\t\t\tWMI_TID_CONFIG_AGGR_CONTROL_DISABLE;\n\t\t\t} else {\n\t\t\t\targ->ack_policy =\n\t\t\t\t\tWMI_PEER_TID_CONFIG_ACK;\n\t\t\t\targ->rate_ctrl =\n\t\t\t\t\tWMI_TID_CONFIG_RATE_CONTROL_AUTO;\n\t\t\t\targ->aggr_control =\n\t\t\t\t\tWMI_TID_CONFIG_AGGR_CONTROL_ENABLE;\n\t\t\t}\n\t\t}\n\n\t\tif (changed & BIT(NL80211_TID_CONFIG_ATTR_RETRY_LONG))\n\t\t\targ->retry_count = tid_conf->retry_long;\n\n\t\tif (changed & BIT(NL80211_TID_CONFIG_ATTR_AMPDU_CTRL)) {\n\t\t\tif (tid_conf->noack == NL80211_TID_CONFIG_ENABLE)\n\t\t\t\targ->aggr_control = WMI_TID_CONFIG_AGGR_CONTROL_ENABLE;\n\t\t\telse\n\t\t\t\targ->aggr_control = WMI_TID_CONFIG_AGGR_CONTROL_DISABLE;\n\t\t}\n\n\t\tif (changed & (BIT(NL80211_TID_CONFIG_ATTR_TX_RATE) |\n\t\t    BIT(NL80211_TID_CONFIG_ATTR_TX_RATE_TYPE))) {\n\t\t\tret = ath10k_mac_tid_bitrate_config(ar, vif, sta,\n\t\t\t\t\t\t\t    &arg->rcode_flags,\n\t\t\t\t\t\t\t    &arg->rate_ctrl,\n\t\t\t\t\t\t\t    tid_conf->txrate_type,\n\t\t\t\t\t\t\t&tid_conf->txrate_mask);\n\t\t\tif (ret) {\n\t\t\t\tath10k_warn(ar, \"failed to configure bitrate mask %d\\n\",\n\t\t\t\t\t    ret);\n\t\t\t\targ->rcode_flags = 0;\n\t\t\t\targ->rate_ctrl = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (changed & BIT(NL80211_TID_CONFIG_ATTR_RTSCTS_CTRL)) {\n\t\t\tif (tid_conf->rtscts)\n\t\t\t\targ->rtscts_ctrl = tid_conf->rtscts;\n\n\t\t\targ->ext_tid_cfg_bitmap = WMI_EXT_TID_RTS_CTS_CONFIG;\n\t\t}\n\n\t\tret = ath10k_mac_set_tid_config(ar, sta, vif, changed, arg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\ti++;\n\t}\n\n\treturn ret;\n}\n\nstatic int ath10k_mac_reset_tid_config(struct ath10k *ar,\n\t\t\t\t       struct ieee80211_sta *sta,\n\t\t\t\t       struct ath10k_vif *arvif,\n\t\t\t\t       u8 tids)\n{\n\tstruct ath10k_sta *arsta = (struct ath10k_sta *)sta->drv_priv;\n\tstruct wmi_per_peer_per_tid_cfg_arg arg;\n\tint ret = 0, i = 0;\n\n\targ.vdev_id = arvif->vdev_id;\n\twhile (i < ATH10K_TID_MAX) {\n\t\tif (!(tids & BIT(i))) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\n\t\targ.tid = i;\n\t\targ.ack_policy = WMI_PEER_TID_CONFIG_ACK;\n\t\targ.retry_count = ATH10K_MAX_RETRY_COUNT;\n\t\targ.rate_ctrl = WMI_TID_CONFIG_RATE_CONTROL_AUTO;\n\t\targ.aggr_control = WMI_TID_CONFIG_AGGR_CONTROL_ENABLE;\n\t\targ.rtscts_ctrl = WMI_TID_CONFIG_RTSCTS_CONTROL_ENABLE;\n\t\targ.ext_tid_cfg_bitmap = WMI_EXT_TID_RTS_CTS_CONFIG;\n\n\t\tether_addr_copy(arg.peer_macaddr.addr, sta->addr);\n\n\t\tret = ath10k_wmi_set_per_peer_per_tid_cfg(ar, &arg);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (!arvif->tids_rst) {\n\t\t\tarsta->retry_long[i] = -1;\n\t\t\tarsta->noack[i] = -1;\n\t\t\tarsta->ampdu[i] = -1;\n\t\t\tarsta->rate_code[i] = -1;\n\t\t\tarsta->rate_ctrl[i] = 0;\n\t\t\tarsta->rtscts[i] = -1;\n\t\t} else {\n\t\t\tarvif->retry_long[i] = 0;\n\t\t\tarvif->noack[i] = 0;\n\t\t\tarvif->ampdu[i] = 0;\n\t\t\tarvif->rate_code[i] = 0;\n\t\t\tarvif->rate_ctrl[i] = 0;\n\t\t\tarvif->rtscts[i] = 0;\n\t\t}\n\n\t\ti++;\n\t}\n\n\treturn ret;\n}\n\nstatic void ath10k_sta_tid_cfg_wk(struct work_struct *wk)\n{\n\tstruct wmi_per_peer_per_tid_cfg_arg arg = {};\n\tstruct ieee80211_sta *sta;\n\tstruct ath10k_sta *arsta;\n\tstruct ath10k_vif *arvif;\n\tstruct ath10k *ar;\n\tbool config_apply;\n\tint ret, i;\n\tu32 changed;\n\tu8 nss;\n\n\tarsta = container_of(wk, struct ath10k_sta, tid_config_wk);\n\tsta = container_of((void *)arsta, struct ieee80211_sta, drv_priv);\n\tarvif = arsta->arvif;\n\tar = arvif->ar;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (arvif->tids_rst) {\n\t\tret = ath10k_mac_reset_tid_config(ar, sta, arvif,\n\t\t\t\t\t\t  arvif->tids_rst);\n\t\tgoto exit;\n\t}\n\n\tether_addr_copy(arg.peer_macaddr.addr, sta->addr);\n\n\tfor (i = 0; i < ATH10K_TID_MAX; i++) {\n\t\tconfig_apply = false;\n\t\tchanged = arvif->tid_conf_changed[i];\n\n\t\tif (changed & BIT(NL80211_TID_CONFIG_ATTR_NOACK)) {\n\t\t\tif (arsta->noack[i] != -1) {\n\t\t\t\targ.ack_policy  = 0;\n\t\t\t} else {\n\t\t\t\tconfig_apply = true;\n\t\t\t\targ.ack_policy = arvif->noack[i];\n\t\t\t\targ.aggr_control = arvif->ampdu[i];\n\t\t\t\targ.rate_ctrl = arvif->rate_ctrl[i];\n\t\t\t}\n\t\t}\n\n\t\tif (changed & BIT(NL80211_TID_CONFIG_ATTR_RETRY_LONG)) {\n\t\t\tif (arsta->retry_long[i] != -1 ||\n\t\t\t    arsta->noack[i] == WMI_PEER_TID_CONFIG_NOACK ||\n\t\t\t    arvif->noack[i] == WMI_PEER_TID_CONFIG_NOACK) {\n\t\t\t\targ.retry_count = 0;\n\t\t\t} else {\n\t\t\t\targ.retry_count = arvif->retry_long[i];\n\t\t\t\tconfig_apply = true;\n\t\t\t}\n\t\t}\n\n\t\tif (changed & BIT(NL80211_TID_CONFIG_ATTR_AMPDU_CTRL)) {\n\t\t\tif (arsta->ampdu[i] != -1 ||\n\t\t\t    arsta->noack[i] == WMI_PEER_TID_CONFIG_NOACK ||\n\t\t\t    arvif->noack[i] == WMI_PEER_TID_CONFIG_NOACK) {\n\t\t\t\targ.aggr_control = 0;\n\t\t\t} else {\n\t\t\t\targ.aggr_control = arvif->ampdu[i];\n\t\t\t\tconfig_apply = true;\n\t\t\t}\n\t\t}\n\n\t\tif (changed & (BIT(NL80211_TID_CONFIG_ATTR_TX_RATE) |\n\t\t    BIT(NL80211_TID_CONFIG_ATTR_TX_RATE_TYPE))) {\n\t\t\tnss = ATH10K_HW_NSS(arvif->rate_code[i]);\n\t\t\tret = ath10k_mac_validate_rate_mask(ar, sta,\n\t\t\t\t\t\t\t    arvif->rate_code[i],\n\t\t\t\t\t\t\t    nss);\n\t\t\tif (ret &&\n\t\t\t    arvif->rate_ctrl[i] > WMI_TID_CONFIG_RATE_CONTROL_AUTO) {\n\t\t\t\targ.rate_ctrl = 0;\n\t\t\t\targ.rcode_flags = 0;\n\t\t\t}\n\n\t\t\tif (arsta->rate_ctrl[i] >\n\t\t\t    WMI_TID_CONFIG_RATE_CONTROL_AUTO ||\n\t\t\t    arsta->noack[i] == WMI_PEER_TID_CONFIG_NOACK ||\n\t\t\t    arvif->noack[i] == WMI_PEER_TID_CONFIG_NOACK) {\n\t\t\t\targ.rate_ctrl = 0;\n\t\t\t\targ.rcode_flags = 0;\n\t\t\t} else {\n\t\t\t\targ.rate_ctrl = arvif->rate_ctrl[i];\n\t\t\t\targ.rcode_flags = arvif->rate_code[i];\n\t\t\t\tconfig_apply = true;\n\t\t\t}\n\t\t}\n\n\t\tif (changed & BIT(NL80211_TID_CONFIG_ATTR_RTSCTS_CTRL)) {\n\t\t\tif (arsta->rtscts[i]) {\n\t\t\t\targ.rtscts_ctrl = 0;\n\t\t\t\targ.ext_tid_cfg_bitmap = 0;\n\t\t\t} else {\n\t\t\t\targ.rtscts_ctrl = arvif->rtscts[i] - 1;\n\t\t\t\targ.ext_tid_cfg_bitmap =\n\t\t\t\t\tWMI_EXT_TID_RTS_CTS_CONFIG;\n\t\t\t\tconfig_apply = true;\n\t\t\t}\n\t\t}\n\n\t\targ.tid = i;\n\n\t\tif (config_apply) {\n\t\t\tret = ath10k_wmi_set_per_peer_per_tid_cfg(ar, &arg);\n\t\t\tif (ret)\n\t\t\t\tath10k_warn(ar, \"failed to set per tid config for sta %pM: %d\\n\",\n\t\t\t\t\t    sta->addr, ret);\n\t\t}\n\n\t\targ.ack_policy  = 0;\n\t\targ.retry_count  = 0;\n\t\targ.aggr_control  = 0;\n\t\targ.rate_ctrl = 0;\n\t\targ.rcode_flags = 0;\n\t}\n\nexit:\n\tmutex_unlock(&ar->conf_mutex);\n}\n\nstatic void ath10k_mac_vif_stations_tid_conf(void *data,\n\t\t\t\t\t     struct ieee80211_sta *sta)\n{\n\tstruct ath10k_sta *arsta = (struct ath10k_sta *)sta->drv_priv;\n\tstruct ath10k_mac_iter_tid_conf_data *iter_data = data;\n\tstruct ieee80211_vif *sta_vif = arsta->arvif->vif;\n\n\tif (sta_vif != iter_data->curr_vif || !sta->wme)\n\t\treturn;\n\n\tieee80211_queue_work(iter_data->ar->hw, &arsta->tid_config_wk);\n}\n\nstatic int ath10k_sta_state(struct ieee80211_hw *hw,\n\t\t\t    struct ieee80211_vif *vif,\n\t\t\t    struct ieee80211_sta *sta,\n\t\t\t    enum ieee80211_sta_state old_state,\n\t\t\t    enum ieee80211_sta_state new_state)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct ath10k_sta *arsta = (struct ath10k_sta *)sta->drv_priv;\n\tstruct ath10k_peer *peer;\n\tint ret = 0;\n\tint i;\n\n\tif (old_state == IEEE80211_STA_NOTEXIST &&\n\t    new_state == IEEE80211_STA_NONE) {\n\t\tmemset(arsta, 0, sizeof(*arsta));\n\t\tarsta->arvif = arvif;\n\t\tarsta->peer_ps_state = WMI_PEER_PS_STATE_DISABLED;\n\t\tINIT_WORK(&arsta->update_wk, ath10k_sta_rc_update_wk);\n\t\tINIT_WORK(&arsta->tid_config_wk, ath10k_sta_tid_cfg_wk);\n\n\t\tfor (i = 0; i < ARRAY_SIZE(sta->txq); i++)\n\t\t\tath10k_mac_txq_init(sta->txq[i]);\n\t}\n\n\t \n\tif ((old_state == IEEE80211_STA_NONE &&\n\t     new_state == IEEE80211_STA_NOTEXIST)) {\n\t\tcancel_work_sync(&arsta->update_wk);\n\t\tcancel_work_sync(&arsta->tid_config_wk);\n\t}\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (old_state == IEEE80211_STA_NOTEXIST &&\n\t    new_state == IEEE80211_STA_NONE) {\n\t\t \n\t\tenum wmi_peer_type peer_type = WMI_PEER_TYPE_DEFAULT;\n\t\tu32 num_tdls_stations;\n\n\t\tath10k_dbg(ar, ATH10K_DBG_STA,\n\t\t\t   \"mac vdev %d peer create %pM (new sta) sta %d / %d peer %d / %d\\n\",\n\t\t\t   arvif->vdev_id, sta->addr,\n\t\t\t   ar->num_stations + 1, ar->max_num_stations,\n\t\t\t   ar->num_peers + 1, ar->max_num_peers);\n\n\t\tnum_tdls_stations = ath10k_mac_tdls_vif_stations_count(hw, vif);\n\n\t\tif (sta->tdls) {\n\t\t\tif (num_tdls_stations >= ar->max_num_tdls_vdevs) {\n\t\t\t\tath10k_warn(ar, \"vdev %i exceeded maximum number of tdls vdevs %i\\n\",\n\t\t\t\t\t    arvif->vdev_id,\n\t\t\t\t\t    ar->max_num_tdls_vdevs);\n\t\t\t\tret = -ELNRNG;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tpeer_type = WMI_PEER_TYPE_TDLS;\n\t\t}\n\n\t\tret = ath10k_mac_inc_num_stations(arvif, sta);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"refusing to associate station: too many connected already (%d)\\n\",\n\t\t\t\t    ar->max_num_stations);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (ath10k_debug_is_extd_tx_stats_enabled(ar)) {\n\t\t\tarsta->tx_stats = kzalloc(sizeof(*arsta->tx_stats),\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!arsta->tx_stats) {\n\t\t\t\tath10k_mac_dec_num_stations(arvif, sta);\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\n\t\tret = ath10k_peer_create(ar, vif, sta, arvif->vdev_id,\n\t\t\t\t\t sta->addr, peer_type);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to add peer %pM for vdev %d when adding a new sta: %i\\n\",\n\t\t\t\t    sta->addr, arvif->vdev_id, ret);\n\t\t\tath10k_mac_dec_num_stations(arvif, sta);\n\t\t\tkfree(arsta->tx_stats);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tspin_lock_bh(&ar->data_lock);\n\n\t\tpeer = ath10k_peer_find(ar, arvif->vdev_id, sta->addr);\n\t\tif (!peer) {\n\t\t\tath10k_warn(ar, \"failed to lookup peer %pM on vdev %i\\n\",\n\t\t\t\t    vif->addr, arvif->vdev_id);\n\t\t\tspin_unlock_bh(&ar->data_lock);\n\t\t\tath10k_peer_delete(ar, arvif->vdev_id, sta->addr);\n\t\t\tath10k_mac_dec_num_stations(arvif, sta);\n\t\t\tkfree(arsta->tx_stats);\n\t\t\tret = -ENOENT;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tarsta->peer_id = find_first_bit(peer->peer_ids,\n\t\t\t\t\t\tATH10K_MAX_NUM_PEER_IDS);\n\n\t\tspin_unlock_bh(&ar->data_lock);\n\n\t\tif (!sta->tdls)\n\t\t\tgoto exit;\n\n\t\tret = ath10k_wmi_update_fw_tdls_state(ar, arvif->vdev_id,\n\t\t\t\t\t\t      WMI_TDLS_ENABLE_ACTIVE);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to update fw tdls state on vdev %i: %i\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\tath10k_peer_delete(ar, arvif->vdev_id,\n\t\t\t\t\t   sta->addr);\n\t\t\tath10k_mac_dec_num_stations(arvif, sta);\n\t\t\tkfree(arsta->tx_stats);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tret = ath10k_mac_tdls_peer_update(ar, arvif->vdev_id, sta,\n\t\t\t\t\t\t  WMI_TDLS_PEER_STATE_PEERING);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar,\n\t\t\t\t    \"failed to update tdls peer %pM for vdev %d when adding a new sta: %i\\n\",\n\t\t\t\t    sta->addr, arvif->vdev_id, ret);\n\t\t\tath10k_peer_delete(ar, arvif->vdev_id, sta->addr);\n\t\t\tath10k_mac_dec_num_stations(arvif, sta);\n\t\t\tkfree(arsta->tx_stats);\n\n\t\t\tif (num_tdls_stations != 0)\n\t\t\t\tgoto exit;\n\t\t\tath10k_wmi_update_fw_tdls_state(ar, arvif->vdev_id,\n\t\t\t\t\t\t\tWMI_TDLS_DISABLE);\n\t\t}\n\t} else if ((old_state == IEEE80211_STA_NONE &&\n\t\t    new_state == IEEE80211_STA_NOTEXIST)) {\n\t\t \n\t\tath10k_dbg(ar, ATH10K_DBG_STA,\n\t\t\t   \"mac vdev %d peer delete %pM sta %pK (sta gone)\\n\",\n\t\t\t   arvif->vdev_id, sta->addr, sta);\n\n\t\tif (sta->tdls) {\n\t\t\tret = ath10k_mac_tdls_peer_update(ar, arvif->vdev_id,\n\t\t\t\t\t\t\t  sta,\n\t\t\t\t\t\t\t  WMI_TDLS_PEER_STATE_TEARDOWN);\n\t\t\tif (ret)\n\t\t\t\tath10k_warn(ar, \"failed to update tdls peer state for %pM state %d: %i\\n\",\n\t\t\t\t\t    sta->addr,\n\t\t\t\t\t    WMI_TDLS_PEER_STATE_TEARDOWN, ret);\n\t\t}\n\n\t\tret = ath10k_peer_delete(ar, arvif->vdev_id, sta->addr);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to delete peer %pM for vdev %d: %i\\n\",\n\t\t\t\t    sta->addr, arvif->vdev_id, ret);\n\n\t\tath10k_mac_dec_num_stations(arvif, sta);\n\n\t\tspin_lock_bh(&ar->data_lock);\n\t\tfor (i = 0; i < ARRAY_SIZE(ar->peer_map); i++) {\n\t\t\tpeer = ar->peer_map[i];\n\t\t\tif (!peer)\n\t\t\t\tcontinue;\n\n\t\t\tif (peer->sta == sta) {\n\t\t\t\tath10k_warn(ar, \"found sta peer %pM (ptr %pK id %d) entry on vdev %i after it was supposedly removed\\n\",\n\t\t\t\t\t    sta->addr, peer, i, arvif->vdev_id);\n\t\t\t\tpeer->sta = NULL;\n\n\t\t\t\t \n\t\t\t\tath10k_peer_map_cleanup(ar, peer);\n\t\t\t}\n\t\t}\n\t\tspin_unlock_bh(&ar->data_lock);\n\n\t\tif (ath10k_debug_is_extd_tx_stats_enabled(ar)) {\n\t\t\tkfree(arsta->tx_stats);\n\t\t\tarsta->tx_stats = NULL;\n\t\t}\n\n\t\tfor (i = 0; i < ARRAY_SIZE(sta->txq); i++)\n\t\t\tath10k_mac_txq_unref(ar, sta->txq[i]);\n\n\t\tif (!sta->tdls)\n\t\t\tgoto exit;\n\n\t\tif (ath10k_mac_tdls_vif_stations_count(hw, vif))\n\t\t\tgoto exit;\n\n\t\t \n\t\tret = ath10k_wmi_update_fw_tdls_state(ar, arvif->vdev_id,\n\t\t\t\t\t\t      WMI_TDLS_DISABLE);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to update fw tdls state on vdev %i: %i\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t}\n\t} else if (old_state == IEEE80211_STA_AUTH &&\n\t\t   new_state == IEEE80211_STA_ASSOC &&\n\t\t   (vif->type == NL80211_IFTYPE_AP ||\n\t\t    vif->type == NL80211_IFTYPE_MESH_POINT ||\n\t\t    vif->type == NL80211_IFTYPE_ADHOC)) {\n\t\t \n\t\tath10k_dbg(ar, ATH10K_DBG_STA, \"mac sta %pM associated\\n\",\n\t\t\t   sta->addr);\n\n\t\tret = ath10k_station_assoc(ar, vif, sta, false);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to associate station %pM for vdev %i: %i\\n\",\n\t\t\t\t    sta->addr, arvif->vdev_id, ret);\n\t} else if (old_state == IEEE80211_STA_ASSOC &&\n\t\t   new_state == IEEE80211_STA_AUTHORIZED &&\n\t\t   sta->tdls) {\n\t\t \n\t\tath10k_dbg(ar, ATH10K_DBG_STA, \"mac tdls sta %pM authorized\\n\",\n\t\t\t   sta->addr);\n\n\t\tret = ath10k_station_assoc(ar, vif, sta, false);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to associate tdls station %pM for vdev %i: %i\\n\",\n\t\t\t\t    sta->addr, arvif->vdev_id, ret);\n\t\t\tgoto exit;\n\t\t}\n\n\t\tret = ath10k_mac_tdls_peer_update(ar, arvif->vdev_id, sta,\n\t\t\t\t\t\t  WMI_TDLS_PEER_STATE_CONNECTED);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to update tdls peer %pM for vdev %i: %i\\n\",\n\t\t\t\t    sta->addr, arvif->vdev_id, ret);\n\t} else if (old_state == IEEE80211_STA_ASSOC &&\n\t\t    new_state == IEEE80211_STA_AUTH &&\n\t\t    (vif->type == NL80211_IFTYPE_AP ||\n\t\t     vif->type == NL80211_IFTYPE_MESH_POINT ||\n\t\t     vif->type == NL80211_IFTYPE_ADHOC)) {\n\t\t \n\t\tath10k_dbg(ar, ATH10K_DBG_STA, \"mac sta %pM disassociated\\n\",\n\t\t\t   sta->addr);\n\n\t\tret = ath10k_station_disassoc(ar, vif, sta);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to disassociate station: %pM vdev %i: %i\\n\",\n\t\t\t\t    sta->addr, arvif->vdev_id, ret);\n\t}\nexit:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic int ath10k_conf_tx_uapsd(struct ath10k *ar, struct ieee80211_vif *vif,\n\t\t\t\tu16 ac, bool enable)\n{\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct wmi_sta_uapsd_auto_trig_arg arg = {};\n\tu32 prio = 0, acc = 0;\n\tu32 value = 0;\n\tint ret = 0;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (arvif->vdev_type != WMI_VDEV_TYPE_STA)\n\t\treturn 0;\n\n\tswitch (ac) {\n\tcase IEEE80211_AC_VO:\n\t\tvalue = WMI_STA_PS_UAPSD_AC3_DELIVERY_EN |\n\t\t\tWMI_STA_PS_UAPSD_AC3_TRIGGER_EN;\n\t\tprio = 7;\n\t\tacc = 3;\n\t\tbreak;\n\tcase IEEE80211_AC_VI:\n\t\tvalue = WMI_STA_PS_UAPSD_AC2_DELIVERY_EN |\n\t\t\tWMI_STA_PS_UAPSD_AC2_TRIGGER_EN;\n\t\tprio = 5;\n\t\tacc = 2;\n\t\tbreak;\n\tcase IEEE80211_AC_BE:\n\t\tvalue = WMI_STA_PS_UAPSD_AC1_DELIVERY_EN |\n\t\t\tWMI_STA_PS_UAPSD_AC1_TRIGGER_EN;\n\t\tprio = 2;\n\t\tacc = 1;\n\t\tbreak;\n\tcase IEEE80211_AC_BK:\n\t\tvalue = WMI_STA_PS_UAPSD_AC0_DELIVERY_EN |\n\t\t\tWMI_STA_PS_UAPSD_AC0_TRIGGER_EN;\n\t\tprio = 0;\n\t\tacc = 0;\n\t\tbreak;\n\t}\n\n\tif (enable)\n\t\tarvif->u.sta.uapsd |= value;\n\telse\n\t\tarvif->u.sta.uapsd &= ~value;\n\n\tret = ath10k_wmi_set_sta_ps_param(ar, arvif->vdev_id,\n\t\t\t\t\t  WMI_STA_PS_PARAM_UAPSD,\n\t\t\t\t\t  arvif->u.sta.uapsd);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set uapsd params: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tif (arvif->u.sta.uapsd)\n\t\tvalue = WMI_STA_PS_RX_WAKE_POLICY_POLL_UAPSD;\n\telse\n\t\tvalue = WMI_STA_PS_RX_WAKE_POLICY_WAKE;\n\n\tret = ath10k_wmi_set_sta_ps_param(ar, arvif->vdev_id,\n\t\t\t\t\t  WMI_STA_PS_PARAM_RX_WAKE_POLICY,\n\t\t\t\t\t  value);\n\tif (ret)\n\t\tath10k_warn(ar, \"failed to set rx wake param: %d\\n\", ret);\n\n\tret = ath10k_mac_vif_recalc_ps_wake_threshold(arvif);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to recalc ps wake threshold on vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\tret = ath10k_mac_vif_recalc_ps_poll_count(arvif);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to recalc ps poll count on vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\tif (test_bit(WMI_SERVICE_STA_UAPSD_BASIC_AUTO_TRIG, ar->wmi.svc_map) ||\n\t    test_bit(WMI_SERVICE_STA_UAPSD_VAR_AUTO_TRIG, ar->wmi.svc_map)) {\n\t\t \n\n\t\targ.wmm_ac = acc;\n\t\targ.user_priority = prio;\n\t\targ.service_interval = 0;\n\t\targ.suspend_interval = WMI_STA_UAPSD_MAX_INTERVAL_MSEC;\n\t\targ.delay_interval = WMI_STA_UAPSD_MAX_INTERVAL_MSEC;\n\n\t\tret = ath10k_wmi_vdev_sta_uapsd(ar, arvif->vdev_id,\n\t\t\t\t\t\tarvif->bssid, &arg, 1);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to set uapsd auto trigger %d\\n\",\n\t\t\t\t    ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\nexit:\n\treturn ret;\n}\n\nstatic int ath10k_conf_tx(struct ieee80211_hw *hw,\n\t\t\t  struct ieee80211_vif *vif,\n\t\t\t  unsigned int link_id, u16 ac,\n\t\t\t  const struct ieee80211_tx_queue_params *params)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct wmi_wmm_params_arg *p = NULL;\n\tint ret;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tswitch (ac) {\n\tcase IEEE80211_AC_VO:\n\t\tp = &arvif->wmm_params.ac_vo;\n\t\tbreak;\n\tcase IEEE80211_AC_VI:\n\t\tp = &arvif->wmm_params.ac_vi;\n\t\tbreak;\n\tcase IEEE80211_AC_BE:\n\t\tp = &arvif->wmm_params.ac_be;\n\t\tbreak;\n\tcase IEEE80211_AC_BK:\n\t\tp = &arvif->wmm_params.ac_bk;\n\t\tbreak;\n\t}\n\n\tif (WARN_ON(!p)) {\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tp->cwmin = params->cw_min;\n\tp->cwmax = params->cw_max;\n\tp->aifs = params->aifs;\n\n\t \n\tp->txop = params->txop * 32;\n\n\tif (ar->wmi.ops->gen_vdev_wmm_conf) {\n\t\tret = ath10k_wmi_vdev_wmm_conf(ar, arvif->vdev_id,\n\t\t\t\t\t       &arvif->wmm_params);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to set vdev wmm params on vdev %i: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\tgoto exit;\n\t\t}\n\t} else {\n\t\t \n\t\tret = ath10k_wmi_pdev_set_wmm_params(ar, &arvif->wmm_params);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to set wmm params: %d\\n\", ret);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tret = ath10k_conf_tx_uapsd(ar, vif, ac, params->uapsd);\n\tif (ret)\n\t\tath10k_warn(ar, \"failed to set sta uapsd: %d\\n\", ret);\n\nexit:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic int ath10k_remain_on_channel(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct ieee80211_channel *chan,\n\t\t\t\t    int duration,\n\t\t\t\t    enum ieee80211_roc_type type)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct wmi_start_scan_arg arg;\n\tint ret = 0;\n\tu32 scan_time_msec;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (ath10k_mac_tdls_vif_stations_count(hw, vif) > 0) {\n\t\tret = -EBUSY;\n\t\tgoto exit;\n\t}\n\n\tspin_lock_bh(&ar->data_lock);\n\tswitch (ar->scan.state) {\n\tcase ATH10K_SCAN_IDLE:\n\t\treinit_completion(&ar->scan.started);\n\t\treinit_completion(&ar->scan.completed);\n\t\treinit_completion(&ar->scan.on_channel);\n\t\tar->scan.state = ATH10K_SCAN_STARTING;\n\t\tar->scan.is_roc = true;\n\t\tar->scan.vdev_id = arvif->vdev_id;\n\t\tar->scan.roc_freq = chan->center_freq;\n\t\tar->scan.roc_notify = true;\n\t\tret = 0;\n\t\tbreak;\n\tcase ATH10K_SCAN_STARTING:\n\tcase ATH10K_SCAN_RUNNING:\n\tcase ATH10K_SCAN_ABORTING:\n\t\tret = -EBUSY;\n\t\tbreak;\n\t}\n\tspin_unlock_bh(&ar->data_lock);\n\n\tif (ret)\n\t\tgoto exit;\n\n\tscan_time_msec = ar->hw->wiphy->max_remain_on_channel_duration * 2;\n\n\tmemset(&arg, 0, sizeof(arg));\n\tath10k_wmi_start_scan_init(ar, &arg);\n\targ.vdev_id = arvif->vdev_id;\n\targ.scan_id = ATH10K_SCAN_ID;\n\targ.n_channels = 1;\n\targ.channels[0] = chan->center_freq;\n\targ.dwell_time_active = scan_time_msec;\n\targ.dwell_time_passive = scan_time_msec;\n\targ.max_scan_time = scan_time_msec;\n\targ.scan_ctrl_flags |= WMI_SCAN_FLAG_PASSIVE;\n\targ.scan_ctrl_flags |= WMI_SCAN_FILTER_PROBE_REQ;\n\targ.burst_duration_ms = duration;\n\n\tret = ath10k_start_scan(ar, &arg);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to start roc scan: %d\\n\", ret);\n\t\tspin_lock_bh(&ar->data_lock);\n\t\tar->scan.state = ATH10K_SCAN_IDLE;\n\t\tspin_unlock_bh(&ar->data_lock);\n\t\tgoto exit;\n\t}\n\n\tret = wait_for_completion_timeout(&ar->scan.on_channel, 3 * HZ);\n\tif (ret == 0) {\n\t\tath10k_warn(ar, \"failed to switch to channel for roc scan\\n\");\n\n\t\tret = ath10k_scan_stop(ar);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to stop scan: %d\\n\", ret);\n\n\t\tret = -ETIMEDOUT;\n\t\tgoto exit;\n\t}\n\n\tieee80211_queue_delayed_work(ar->hw, &ar->scan.timeout,\n\t\t\t\t     msecs_to_jiffies(duration));\n\n\tret = 0;\nexit:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic int ath10k_cancel_remain_on_channel(struct ieee80211_hw *hw,\n\t\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tstruct ath10k *ar = hw->priv;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tspin_lock_bh(&ar->data_lock);\n\tar->scan.roc_notify = false;\n\tspin_unlock_bh(&ar->data_lock);\n\n\tath10k_scan_abort(ar);\n\n\tmutex_unlock(&ar->conf_mutex);\n\n\tcancel_delayed_work_sync(&ar->scan.timeout);\n\n\treturn 0;\n}\n\n \n\nstatic int ath10k_set_rts_threshold(struct ieee80211_hw *hw, u32 value)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_vif *arvif;\n\tint ret = 0;\n\n\tmutex_lock(&ar->conf_mutex);\n\tlist_for_each_entry(arvif, &ar->arvifs, list) {\n\t\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac vdev %d rts threshold %d\\n\",\n\t\t\t   arvif->vdev_id, value);\n\n\t\tret = ath10k_mac_set_rts(arvif, value);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to set rts threshold for vdev %d: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn ret;\n}\n\nstatic int ath10k_mac_op_set_frag_threshold(struct ieee80211_hw *hw, u32 value)\n{\n\t \n\treturn -EOPNOTSUPP;\n}\n\nvoid ath10k_mac_wait_tx_complete(struct ath10k *ar)\n{\n\tbool skip;\n\tlong time_left;\n\n\t \n\n\tif (ar->state == ATH10K_STATE_WEDGED)\n\t\treturn;\n\n\ttime_left = wait_event_timeout(ar->htt.empty_tx_wq, ({\n\t\t\tbool empty;\n\n\t\t\tspin_lock_bh(&ar->htt.tx_lock);\n\t\t\tempty = (ar->htt.num_pending_tx == 0);\n\t\t\tspin_unlock_bh(&ar->htt.tx_lock);\n\n\t\t\tskip = (ar->state == ATH10K_STATE_WEDGED) ||\n\t\t\t       test_bit(ATH10K_FLAG_CRASH_FLUSH,\n\t\t\t\t\t&ar->dev_flags);\n\n\t\t\t(empty || skip);\n\t\t}), ATH10K_FLUSH_TIMEOUT_HZ);\n\n\tif (time_left == 0 || skip)\n\t\tath10k_warn(ar, \"failed to flush transmit queue (skip %i ar-state %i): %ld\\n\",\n\t\t\t    skip, ar->state, time_left);\n}\n\nstatic void ath10k_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t u32 queues, bool drop)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_vif *arvif;\n\tu32 bitmap;\n\n\tif (drop) {\n\t\tif (vif && vif->type == NL80211_IFTYPE_STATION) {\n\t\t\tbitmap = ~(1 << WMI_MGMT_TID);\n\t\t\tlist_for_each_entry(arvif, &ar->arvifs, list) {\n\t\t\t\tif (arvif->vdev_type == WMI_VDEV_TYPE_STA)\n\t\t\t\t\tath10k_wmi_peer_flush(ar, arvif->vdev_id,\n\t\t\t\t\t\t\t      arvif->bssid, bitmap);\n\t\t\t}\n\t\t\tath10k_htt_flush_tx(&ar->htt);\n\t\t}\n\t\treturn;\n\t}\n\n\tmutex_lock(&ar->conf_mutex);\n\tath10k_mac_wait_tx_complete(ar);\n\tmutex_unlock(&ar->conf_mutex);\n}\n\n \nstatic int ath10k_tx_last_beacon(struct ieee80211_hw *hw)\n{\n\treturn 1;\n}\n\nstatic void ath10k_reconfig_complete(struct ieee80211_hw *hw,\n\t\t\t\t     enum ieee80211_reconfig_type reconfig_type)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_vif *arvif;\n\n\tif (reconfig_type != IEEE80211_RECONFIG_TYPE_RESTART)\n\t\treturn;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\t \n\tif (ar->state == ATH10K_STATE_RESTARTED) {\n\t\tath10k_info(ar, \"device successfully recovered\\n\");\n\t\tar->state = ATH10K_STATE_ON;\n\t\tieee80211_wake_queues(ar->hw);\n\t\tclear_bit(ATH10K_FLAG_RESTARTING, &ar->dev_flags);\n\t\tif (ar->hw_params.hw_restart_disconnect) {\n\t\t\tlist_for_each_entry(arvif, &ar->arvifs, list) {\n\t\t\t\tif (arvif->is_up && arvif->vdev_type == WMI_VDEV_TYPE_STA)\n\t\t\t\t\tieee80211_hw_restart_disconnect(arvif->vif);\n\t\t\t\t}\n\t\t}\n\t}\n\n\tmutex_unlock(&ar->conf_mutex);\n}\n\nstatic void\nath10k_mac_update_bss_chan_survey(struct ath10k *ar,\n\t\t\t\t  struct ieee80211_channel *channel)\n{\n\tint ret;\n\tenum wmi_bss_survey_req_type type = WMI_BSS_SURVEY_REQ_TYPE_READ;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (!test_bit(WMI_SERVICE_BSS_CHANNEL_INFO_64, ar->wmi.svc_map) ||\n\t    (ar->rx_channel != channel))\n\t\treturn;\n\n\tif (ar->scan.state != ATH10K_SCAN_IDLE) {\n\t\tath10k_dbg(ar, ATH10K_DBG_MAC, \"ignoring bss chan info request while scanning..\\n\");\n\t\treturn;\n\t}\n\n\treinit_completion(&ar->bss_survey_done);\n\n\tret = ath10k_wmi_pdev_bss_chan_info_request(ar, type);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to send pdev bss chan info request\\n\");\n\t\treturn;\n\t}\n\n\tret = wait_for_completion_timeout(&ar->bss_survey_done, 3 * HZ);\n\tif (!ret) {\n\t\tath10k_warn(ar, \"bss channel survey timed out\\n\");\n\t\treturn;\n\t}\n}\n\nstatic int ath10k_get_survey(struct ieee80211_hw *hw, int idx,\n\t\t\t     struct survey_info *survey)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ieee80211_supported_band *sband;\n\tstruct survey_info *ar_survey = &ar->survey[idx];\n\tint ret = 0;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tsband = hw->wiphy->bands[NL80211_BAND_2GHZ];\n\tif (sband && idx >= sband->n_channels) {\n\t\tidx -= sband->n_channels;\n\t\tsband = NULL;\n\t}\n\n\tif (!sband)\n\t\tsband = hw->wiphy->bands[NL80211_BAND_5GHZ];\n\n\tif (!sband || idx >= sband->n_channels) {\n\t\tret = -ENOENT;\n\t\tgoto exit;\n\t}\n\n\tath10k_mac_update_bss_chan_survey(ar, &sband->channels[idx]);\n\n\tspin_lock_bh(&ar->data_lock);\n\tmemcpy(survey, ar_survey, sizeof(*survey));\n\tspin_unlock_bh(&ar->data_lock);\n\n\tsurvey->channel = &sband->channels[idx];\n\n\tif (ar->rx_channel == survey->channel)\n\t\tsurvey->filled |= SURVEY_INFO_IN_USE;\n\nexit:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic bool\nath10k_mac_bitrate_mask_get_single_nss(struct ath10k *ar,\n\t\t\t\t       enum nl80211_band band,\n\t\t\t\t       const struct cfg80211_bitrate_mask *mask,\n\t\t\t\t       int *nss)\n{\n\tstruct ieee80211_supported_band *sband = &ar->mac.sbands[band];\n\tu16 vht_mcs_map = le16_to_cpu(sband->vht_cap.vht_mcs.tx_mcs_map);\n\tu8 ht_nss_mask = 0;\n\tu8 vht_nss_mask = 0;\n\tint i;\n\n\tif (mask->control[band].legacy)\n\t\treturn false;\n\n\tfor (i = 0; i < ARRAY_SIZE(mask->control[band].ht_mcs); i++) {\n\t\tif (mask->control[band].ht_mcs[i] == 0)\n\t\t\tcontinue;\n\t\telse if (mask->control[band].ht_mcs[i] ==\n\t\t\t sband->ht_cap.mcs.rx_mask[i])\n\t\t\tht_nss_mask |= BIT(i);\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(mask->control[band].vht_mcs); i++) {\n\t\tif (mask->control[band].vht_mcs[i] == 0)\n\t\t\tcontinue;\n\t\telse if (mask->control[band].vht_mcs[i] ==\n\t\t\t ath10k_mac_get_max_vht_mcs_map(vht_mcs_map, i))\n\t\t\tvht_nss_mask |= BIT(i);\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tif (ht_nss_mask != vht_nss_mask)\n\t\treturn false;\n\n\tif (ht_nss_mask == 0)\n\t\treturn false;\n\n\tif (BIT(fls(ht_nss_mask)) - 1 != ht_nss_mask)\n\t\treturn false;\n\n\t*nss = fls(ht_nss_mask);\n\n\treturn true;\n}\n\nstatic int ath10k_mac_set_fixed_rate_params(struct ath10k_vif *arvif,\n\t\t\t\t\t    u8 rate, u8 nss, u8 sgi, u8 ldpc)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tu32 vdev_param;\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac set fixed rate params vdev %i rate 0x%02x nss %u sgi %u\\n\",\n\t\t   arvif->vdev_id, rate, nss, sgi);\n\n\tvdev_param = ar->wmi.vdev_param->fixed_rate;\n\tret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, vdev_param, rate);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set fixed rate param 0x%02x: %d\\n\",\n\t\t\t    rate, ret);\n\t\treturn ret;\n\t}\n\n\tvdev_param = ar->wmi.vdev_param->nss;\n\tret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, vdev_param, nss);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set nss param %d: %d\\n\", nss, ret);\n\t\treturn ret;\n\t}\n\n\tvdev_param = ar->wmi.vdev_param->sgi;\n\tret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, vdev_param, sgi);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set sgi param %d: %d\\n\", sgi, ret);\n\t\treturn ret;\n\t}\n\n\tvdev_param = ar->wmi.vdev_param->ldpc;\n\tret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id, vdev_param, ldpc);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set ldpc param %d: %d\\n\", ldpc, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic bool\nath10k_mac_can_set_bitrate_mask(struct ath10k *ar,\n\t\t\t\tenum nl80211_band band,\n\t\t\t\tconst struct cfg80211_bitrate_mask *mask,\n\t\t\t\tbool allow_pfr)\n{\n\tint i;\n\tu16 vht_mcs;\n\n\t \n\tfor (i = 0; i < NL80211_VHT_NSS_MAX; i++) {\n\t\tvht_mcs = mask->control[band].vht_mcs[i];\n\n\t\tswitch (vht_mcs) {\n\t\tcase 0:\n\t\tcase BIT(8) - 1:\n\t\tcase BIT(9) - 1:\n\t\tcase BIT(10) - 1:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!allow_pfr)\n\t\t\t\tath10k_warn(ar, \"refusing bitrate mask with missing 0-7 VHT MCS rates\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic bool ath10k_mac_set_vht_bitrate_mask_fixup(struct ath10k *ar,\n\t\t\t\t\t\t  struct ath10k_vif *arvif,\n\t\t\t\t\t\t  struct ieee80211_sta *sta)\n{\n\tint err;\n\tu8 rate = arvif->vht_pfr;\n\n\t \n\tif (!sta->deflink.vht_cap.vht_supported || arvif->vht_num_rates != 1)\n\t\treturn false;\n\n\terr = ath10k_wmi_peer_set_param(ar, arvif->vdev_id, sta->addr,\n\t\t\t\t\tWMI_PEER_PARAM_FIXED_RATE, rate);\n\tif (err)\n\t\tath10k_warn(ar, \"failed to enable STA %pM peer fixed rate: %d\\n\",\n\t\t\t    sta->addr, err);\n\n\treturn true;\n}\n\nstatic void ath10k_mac_set_bitrate_mask_iter(void *data,\n\t\t\t\t\t     struct ieee80211_sta *sta)\n{\n\tstruct ath10k_vif *arvif = data;\n\tstruct ath10k_sta *arsta = (struct ath10k_sta *)sta->drv_priv;\n\tstruct ath10k *ar = arvif->ar;\n\n\tif (arsta->arvif != arvif)\n\t\treturn;\n\n\tif (ath10k_mac_set_vht_bitrate_mask_fixup(ar, arvif, sta))\n\t\treturn;\n\n\tspin_lock_bh(&ar->data_lock);\n\tarsta->changed |= IEEE80211_RC_SUPP_RATES_CHANGED;\n\tspin_unlock_bh(&ar->data_lock);\n\n\tieee80211_queue_work(ar->hw, &arsta->update_wk);\n}\n\nstatic void ath10k_mac_clr_bitrate_mask_iter(void *data,\n\t\t\t\t\t     struct ieee80211_sta *sta)\n{\n\tstruct ath10k_vif *arvif = data;\n\tstruct ath10k_sta *arsta = (struct ath10k_sta *)sta->drv_priv;\n\tstruct ath10k *ar = arvif->ar;\n\tint err;\n\n\t \n\tif (arsta->arvif != arvif || !sta->deflink.vht_cap.vht_supported)\n\t\treturn;\n\n\terr = ath10k_wmi_peer_set_param(ar, arvif->vdev_id, sta->addr,\n\t\t\t\t\tWMI_PEER_PARAM_FIXED_RATE,\n\t\t\t\t\tWMI_FIXED_RATE_NONE);\n\tif (err)\n\t\tath10k_warn(ar, \"failed to clear STA %pM peer fixed rate: %d\\n\",\n\t\t\t    sta->addr, err);\n}\n\nstatic int ath10k_mac_op_set_bitrate_mask(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t\t  const struct cfg80211_bitrate_mask *mask)\n{\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct cfg80211_chan_def def;\n\tstruct ath10k *ar = arvif->ar;\n\tenum nl80211_band band;\n\tconst u8 *ht_mcs_mask;\n\tconst u16 *vht_mcs_mask;\n\tu8 rate;\n\tu8 nss;\n\tu8 sgi;\n\tu8 ldpc;\n\tint single_nss;\n\tint ret;\n\tint vht_num_rates, allow_pfr;\n\tu8 vht_pfr;\n\tbool update_bitrate_mask = true;\n\n\tif (ath10k_mac_vif_chan(vif, &def))\n\t\treturn -EPERM;\n\n\tband = def.chan->band;\n\tht_mcs_mask = mask->control[band].ht_mcs;\n\tvht_mcs_mask = mask->control[band].vht_mcs;\n\tldpc = !!(ar->ht_cap_info & WMI_HT_CAP_LDPC);\n\n\tsgi = mask->control[band].gi;\n\tif (sgi == NL80211_TXRATE_FORCE_LGI)\n\t\treturn -EINVAL;\n\n\tallow_pfr = test_bit(ATH10K_FW_FEATURE_PEER_FIXED_RATE,\n\t\t\t     ar->normal_mode_fw.fw_file.fw_features);\n\tif (allow_pfr) {\n\t\tmutex_lock(&ar->conf_mutex);\n\t\tieee80211_iterate_stations_atomic(ar->hw,\n\t\t\t\t\t\t  ath10k_mac_clr_bitrate_mask_iter,\n\t\t\t\t\t\t  arvif);\n\t\tmutex_unlock(&ar->conf_mutex);\n\t}\n\n\tif (ath10k_mac_bitrate_mask_has_single_rate(ar, band, mask,\n\t\t\t\t\t\t    &vht_num_rates)) {\n\t\tret = ath10k_mac_bitrate_mask_get_single_rate(ar, band, mask,\n\t\t\t\t\t\t\t      &rate, &nss,\n\t\t\t\t\t\t\t      false);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to get single rate for vdev %i: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\treturn ret;\n\t\t}\n\t} else if (ath10k_mac_bitrate_mask_get_single_nss(ar, band, mask,\n\t\t\t\t\t\t\t  &single_nss)) {\n\t\trate = WMI_FIXED_RATE_NONE;\n\t\tnss = single_nss;\n\t} else {\n\t\trate = WMI_FIXED_RATE_NONE;\n\t\tnss = min(ar->num_rf_chains,\n\t\t\t  max(ath10k_mac_max_ht_nss(ht_mcs_mask),\n\t\t\t      ath10k_mac_max_vht_nss(vht_mcs_mask)));\n\n\t\tif (!ath10k_mac_can_set_bitrate_mask(ar, band, mask,\n\t\t\t\t\t\t     allow_pfr)) {\n\t\t\tu8 vht_nss;\n\n\t\t\tif (!allow_pfr || vht_num_rates != 1)\n\t\t\t\treturn -EINVAL;\n\n\t\t\t \n\t\t\tath10k_mac_bitrate_mask_get_single_rate(ar, band, mask,\n\t\t\t\t\t\t\t\t&vht_pfr,\n\t\t\t\t\t\t\t\t&vht_nss,\n\t\t\t\t\t\t\t\ttrue);\n\t\t\tupdate_bitrate_mask = false;\n\t\t} else {\n\t\t\tvht_pfr = 0;\n\t\t}\n\n\t\tmutex_lock(&ar->conf_mutex);\n\n\t\tif (update_bitrate_mask)\n\t\t\tarvif->bitrate_mask = *mask;\n\t\tarvif->vht_num_rates = vht_num_rates;\n\t\tarvif->vht_pfr = vht_pfr;\n\t\tieee80211_iterate_stations_atomic(ar->hw,\n\t\t\t\t\t\t  ath10k_mac_set_bitrate_mask_iter,\n\t\t\t\t\t\t  arvif);\n\n\t\tmutex_unlock(&ar->conf_mutex);\n\t}\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tret = ath10k_mac_set_fixed_rate_params(arvif, rate, nss, sgi, ldpc);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set fixed rate params on vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\tgoto exit;\n\t}\n\nexit:\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn ret;\n}\n\nstatic void ath10k_sta_rc_update(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_sta *sta,\n\t\t\t\t u32 changed)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_sta *arsta = (struct ath10k_sta *)sta->drv_priv;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct ath10k_peer *peer;\n\tu32 bw, smps;\n\n\tspin_lock_bh(&ar->data_lock);\n\n\tpeer = ath10k_peer_find(ar, arvif->vdev_id, sta->addr);\n\tif (!peer) {\n\t\tspin_unlock_bh(&ar->data_lock);\n\t\tath10k_warn(ar, \"mac sta rc update failed to find peer %pM on vdev %i\\n\",\n\t\t\t    sta->addr, arvif->vdev_id);\n\t\treturn;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_STA,\n\t\t   \"mac sta rc update for %pM changed %08x bw %d nss %d smps %d\\n\",\n\t\t   sta->addr, changed, sta->deflink.bandwidth,\n\t\t   sta->deflink.rx_nss,\n\t\t   sta->deflink.smps_mode);\n\n\tif (changed & IEEE80211_RC_BW_CHANGED) {\n\t\tbw = WMI_PEER_CHWIDTH_20MHZ;\n\n\t\tswitch (sta->deflink.bandwidth) {\n\t\tcase IEEE80211_STA_RX_BW_20:\n\t\t\tbw = WMI_PEER_CHWIDTH_20MHZ;\n\t\t\tbreak;\n\t\tcase IEEE80211_STA_RX_BW_40:\n\t\t\tbw = WMI_PEER_CHWIDTH_40MHZ;\n\t\t\tbreak;\n\t\tcase IEEE80211_STA_RX_BW_80:\n\t\t\tbw = WMI_PEER_CHWIDTH_80MHZ;\n\t\t\tbreak;\n\t\tcase IEEE80211_STA_RX_BW_160:\n\t\t\tbw = WMI_PEER_CHWIDTH_160MHZ;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tath10k_warn(ar, \"Invalid bandwidth %d in rc update for %pM\\n\",\n\t\t\t\t    sta->deflink.bandwidth, sta->addr);\n\t\t\tbw = WMI_PEER_CHWIDTH_20MHZ;\n\t\t\tbreak;\n\t\t}\n\n\t\tarsta->bw = bw;\n\t}\n\n\tif (changed & IEEE80211_RC_NSS_CHANGED)\n\t\tarsta->nss = sta->deflink.rx_nss;\n\n\tif (changed & IEEE80211_RC_SMPS_CHANGED) {\n\t\tsmps = WMI_PEER_SMPS_PS_NONE;\n\n\t\tswitch (sta->deflink.smps_mode) {\n\t\tcase IEEE80211_SMPS_AUTOMATIC:\n\t\tcase IEEE80211_SMPS_OFF:\n\t\t\tsmps = WMI_PEER_SMPS_PS_NONE;\n\t\t\tbreak;\n\t\tcase IEEE80211_SMPS_STATIC:\n\t\t\tsmps = WMI_PEER_SMPS_STATIC;\n\t\t\tbreak;\n\t\tcase IEEE80211_SMPS_DYNAMIC:\n\t\t\tsmps = WMI_PEER_SMPS_DYNAMIC;\n\t\t\tbreak;\n\t\tcase IEEE80211_SMPS_NUM_MODES:\n\t\t\tath10k_warn(ar, \"Invalid smps %d in sta rc update for %pM\\n\",\n\t\t\t\t    sta->deflink.smps_mode, sta->addr);\n\t\t\tsmps = WMI_PEER_SMPS_PS_NONE;\n\t\t\tbreak;\n\t\t}\n\n\t\tarsta->smps = smps;\n\t}\n\n\tarsta->changed |= changed;\n\n\tspin_unlock_bh(&ar->data_lock);\n\n\tieee80211_queue_work(hw, &arsta->update_wk);\n}\n\nstatic void ath10k_offset_tsf(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif, s64 tsf_offset)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tu32 offset, vdev_param;\n\tint ret;\n\n\tif (tsf_offset < 0) {\n\t\tvdev_param = ar->wmi.vdev_param->dec_tsf;\n\t\toffset = -tsf_offset;\n\t} else {\n\t\tvdev_param = ar->wmi.vdev_param->inc_tsf;\n\t\toffset = tsf_offset;\n\t}\n\n\tret = ath10k_wmi_vdev_set_param(ar, arvif->vdev_id,\n\t\t\t\t\tvdev_param, offset);\n\n\tif (ret && ret != -EOPNOTSUPP)\n\t\tath10k_warn(ar, \"failed to set tsf offset %d cmd %d: %d\\n\",\n\t\t\t    offset, vdev_param, ret);\n}\n\nstatic int ath10k_ampdu_action(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       struct ieee80211_ampdu_params *params)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct ieee80211_sta *sta = params->sta;\n\tenum ieee80211_ampdu_mlme_action action = params->action;\n\tu16 tid = params->tid;\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac ampdu vdev_id %i sta %pM tid %u action %d\\n\",\n\t\t   arvif->vdev_id, sta->addr, tid, action);\n\n\tswitch (action) {\n\tcase IEEE80211_AMPDU_RX_START:\n\tcase IEEE80211_AMPDU_RX_STOP:\n\t\t \n\t\treturn 0;\n\tcase IEEE80211_AMPDU_TX_START:\n\tcase IEEE80211_AMPDU_TX_STOP_CONT:\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH:\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH_CONT:\n\tcase IEEE80211_AMPDU_TX_OPERATIONAL:\n\t\t \n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic void\nath10k_mac_update_rx_channel(struct ath10k *ar,\n\t\t\t     struct ieee80211_chanctx_conf *ctx,\n\t\t\t     struct ieee80211_vif_chanctx_switch *vifs,\n\t\t\t     int n_vifs)\n{\n\tstruct cfg80211_chan_def *def = NULL;\n\n\t \n\tlockdep_assert_held(&ar->conf_mutex);\n\tlockdep_assert_held(&ar->data_lock);\n\n\tWARN_ON(ctx && vifs);\n\tWARN_ON(vifs && !n_vifs);\n\n\t \n\trcu_read_lock();\n\tif (!ctx && ath10k_mac_num_chanctxs(ar) == 1) {\n\t\tieee80211_iter_chan_contexts_atomic(ar->hw,\n\t\t\t\t\t\t    ath10k_mac_get_any_chandef_iter,\n\t\t\t\t\t\t    &def);\n\n\t\tif (vifs)\n\t\t\tdef = &vifs[0].new_ctx->def;\n\n\t\tar->rx_channel = def->chan;\n\t} else if ((ctx && ath10k_mac_num_chanctxs(ar) == 0) ||\n\t\t   (ctx && (ar->state == ATH10K_STATE_RESTARTED))) {\n\t\t \n\t\tar->rx_channel = ctx->def.chan;\n\t} else {\n\t\tar->rx_channel = NULL;\n\t}\n\trcu_read_unlock();\n}\n\nstatic void\nath10k_mac_update_vif_chan(struct ath10k *ar,\n\t\t\t   struct ieee80211_vif_chanctx_switch *vifs,\n\t\t\t   int n_vifs)\n{\n\tstruct ath10k_vif *arvif;\n\tint ret;\n\tint i;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\t \n\tif (ar->monitor_started)\n\t\tath10k_monitor_stop(ar);\n\n\tfor (i = 0; i < n_vifs; i++) {\n\t\tarvif = (void *)vifs[i].vif->drv_priv;\n\n\t\tath10k_dbg(ar, ATH10K_DBG_MAC,\n\t\t\t   \"mac chanctx switch vdev_id %i freq %u->%u width %d->%d\\n\",\n\t\t\t   arvif->vdev_id,\n\t\t\t   vifs[i].old_ctx->def.chan->center_freq,\n\t\t\t   vifs[i].new_ctx->def.chan->center_freq,\n\t\t\t   vifs[i].old_ctx->def.width,\n\t\t\t   vifs[i].new_ctx->def.width);\n\n\t\tif (WARN_ON(!arvif->is_started))\n\t\t\tcontinue;\n\n\t\tif (WARN_ON(!arvif->is_up))\n\t\t\tcontinue;\n\n\t\tret = ath10k_wmi_vdev_down(ar, arvif->vdev_id);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to down vdev %d: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\t \n\n\tspin_lock_bh(&ar->data_lock);\n\tath10k_mac_update_rx_channel(ar, NULL, vifs, n_vifs);\n\tspin_unlock_bh(&ar->data_lock);\n\n\tfor (i = 0; i < n_vifs; i++) {\n\t\tarvif = (void *)vifs[i].vif->drv_priv;\n\n\t\tif (WARN_ON(!arvif->is_started))\n\t\t\tcontinue;\n\n\t\tif (WARN_ON(!arvif->is_up))\n\t\t\tcontinue;\n\n\t\tret = ath10k_mac_setup_bcn_tmpl(arvif);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to update bcn tmpl during csa: %d\\n\",\n\t\t\t\t    ret);\n\n\t\tret = ath10k_mac_setup_prb_tmpl(arvif);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to update prb tmpl during csa: %d\\n\",\n\t\t\t\t    ret);\n\n\t\tret = ath10k_vdev_restart(arvif, &vifs[i].new_ctx->def);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to restart vdev %d: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = ath10k_wmi_vdev_up(arvif->ar, arvif->vdev_id, arvif->aid,\n\t\t\t\t\t arvif->bssid);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to bring vdev up %d: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tath10k_monitor_recalc(ar);\n}\n\nstatic int\nath10k_mac_op_add_chanctx(struct ieee80211_hw *hw,\n\t\t\t  struct ieee80211_chanctx_conf *ctx)\n{\n\tstruct ath10k *ar = hw->priv;\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC,\n\t\t   \"mac chanctx add freq %u width %d ptr %pK\\n\",\n\t\t   ctx->def.chan->center_freq, ctx->def.width, ctx);\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tspin_lock_bh(&ar->data_lock);\n\tath10k_mac_update_rx_channel(ar, ctx, NULL, 0);\n\tspin_unlock_bh(&ar->data_lock);\n\n\tath10k_recalc_radar_detection(ar);\n\tath10k_monitor_recalc(ar);\n\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn 0;\n}\n\nstatic void\nath10k_mac_op_remove_chanctx(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_chanctx_conf *ctx)\n{\n\tstruct ath10k *ar = hw->priv;\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC,\n\t\t   \"mac chanctx remove freq %u width %d ptr %pK\\n\",\n\t\t   ctx->def.chan->center_freq, ctx->def.width, ctx);\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tspin_lock_bh(&ar->data_lock);\n\tath10k_mac_update_rx_channel(ar, NULL, NULL, 0);\n\tspin_unlock_bh(&ar->data_lock);\n\n\tath10k_recalc_radar_detection(ar);\n\tath10k_monitor_recalc(ar);\n\n\tmutex_unlock(&ar->conf_mutex);\n}\n\nstruct ath10k_mac_change_chanctx_arg {\n\tstruct ieee80211_chanctx_conf *ctx;\n\tstruct ieee80211_vif_chanctx_switch *vifs;\n\tint n_vifs;\n\tint next_vif;\n};\n\nstatic void\nath10k_mac_change_chanctx_cnt_iter(void *data, u8 *mac,\n\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tstruct ath10k_mac_change_chanctx_arg *arg = data;\n\n\tif (rcu_access_pointer(vif->bss_conf.chanctx_conf) != arg->ctx)\n\t\treturn;\n\n\targ->n_vifs++;\n}\n\nstatic void\nath10k_mac_change_chanctx_fill_iter(void *data, u8 *mac,\n\t\t\t\t    struct ieee80211_vif *vif)\n{\n\tstruct ath10k_mac_change_chanctx_arg *arg = data;\n\tstruct ieee80211_chanctx_conf *ctx;\n\n\tctx = rcu_access_pointer(vif->bss_conf.chanctx_conf);\n\tif (ctx != arg->ctx)\n\t\treturn;\n\n\tif (WARN_ON(arg->next_vif == arg->n_vifs))\n\t\treturn;\n\n\targ->vifs[arg->next_vif].vif = vif;\n\targ->vifs[arg->next_vif].old_ctx = ctx;\n\targ->vifs[arg->next_vif].new_ctx = ctx;\n\targ->next_vif++;\n}\n\nstatic void\nath10k_mac_op_change_chanctx(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_chanctx_conf *ctx,\n\t\t\t     u32 changed)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_mac_change_chanctx_arg arg = { .ctx = ctx };\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC,\n\t\t   \"mac chanctx change freq %u width %d ptr %pK changed %x\\n\",\n\t\t   ctx->def.chan->center_freq, ctx->def.width, ctx, changed);\n\n\t \n\tif (WARN_ON(changed & IEEE80211_CHANCTX_CHANGE_CHANNEL))\n\t\tgoto unlock;\n\n\tif (changed & IEEE80211_CHANCTX_CHANGE_WIDTH) {\n\t\tieee80211_iterate_active_interfaces_atomic(\n\t\t\t\t\thw,\n\t\t\t\t\tATH10K_ITER_NORMAL_FLAGS,\n\t\t\t\t\tath10k_mac_change_chanctx_cnt_iter,\n\t\t\t\t\t&arg);\n\t\tif (arg.n_vifs == 0)\n\t\t\tgoto radar;\n\n\t\targ.vifs = kcalloc(arg.n_vifs, sizeof(arg.vifs[0]),\n\t\t\t\t   GFP_KERNEL);\n\t\tif (!arg.vifs)\n\t\t\tgoto radar;\n\n\t\tieee80211_iterate_active_interfaces_atomic(\n\t\t\t\t\thw,\n\t\t\t\t\tATH10K_ITER_NORMAL_FLAGS,\n\t\t\t\t\tath10k_mac_change_chanctx_fill_iter,\n\t\t\t\t\t&arg);\n\t\tath10k_mac_update_vif_chan(ar, arg.vifs, arg.n_vifs);\n\t\tkfree(arg.vifs);\n\t}\n\nradar:\n\tath10k_recalc_radar_detection(ar);\n\n\t \n\n\t \n\nunlock:\n\tmutex_unlock(&ar->conf_mutex);\n}\n\nstatic int\nath10k_mac_op_assign_vif_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_bss_conf *link_conf,\n\t\t\t\t struct ieee80211_chanctx_conf *ctx)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tint ret;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC,\n\t\t   \"mac chanctx assign ptr %pK vdev_id %i\\n\",\n\t\t   ctx, arvif->vdev_id);\n\n\tif (WARN_ON(arvif->is_started)) {\n\t\tmutex_unlock(&ar->conf_mutex);\n\t\treturn -EBUSY;\n\t}\n\n\tret = ath10k_vdev_start(arvif, &ctx->def);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to start vdev %i addr %pM on freq %d: %d\\n\",\n\t\t\t    arvif->vdev_id, vif->addr,\n\t\t\t    ctx->def.chan->center_freq, ret);\n\t\tgoto err;\n\t}\n\n\tarvif->is_started = true;\n\n\tret = ath10k_mac_vif_setup_ps(arvif);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to update vdev %i ps: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\tgoto err_stop;\n\t}\n\n\tif (vif->type == NL80211_IFTYPE_MONITOR) {\n\t\tret = ath10k_wmi_vdev_up(ar, arvif->vdev_id, 0, vif->addr);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to up monitor vdev %i: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\tgoto err_stop;\n\t\t}\n\n\t\tarvif->is_up = true;\n\t}\n\n\tif (ath10k_mac_can_set_cts_prot(arvif)) {\n\t\tret = ath10k_mac_set_cts_prot(arvif);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to set cts protection for vdev %d: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t}\n\n\tif (ath10k_peer_stats_enabled(ar) &&\n\t    ar->hw_params.tx_stats_over_pktlog) {\n\t\tar->pktlog_filter |= ATH10K_PKTLOG_PEER_STATS;\n\t\tret = ath10k_wmi_pdev_pktlog_enable(ar,\n\t\t\t\t\t\t    ar->pktlog_filter);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to enable pktlog %d\\n\", ret);\n\t\t\tgoto err_stop;\n\t\t}\n\t}\n\n\tmutex_unlock(&ar->conf_mutex);\n\treturn 0;\n\nerr_stop:\n\tath10k_vdev_stop(arvif);\n\tarvif->is_started = false;\n\tath10k_mac_vif_setup_ps(arvif);\n\nerr:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic void\nath10k_mac_op_unassign_vif_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   struct ieee80211_bss_conf *link_conf,\n\t\t\t\t   struct ieee80211_chanctx_conf *ctx)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tint ret;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC,\n\t\t   \"mac chanctx unassign ptr %pK vdev_id %i\\n\",\n\t\t   ctx, arvif->vdev_id);\n\n\tWARN_ON(!arvif->is_started);\n\n\tif (vif->type == NL80211_IFTYPE_MONITOR) {\n\t\tWARN_ON(!arvif->is_up);\n\n\t\tret = ath10k_wmi_vdev_down(ar, arvif->vdev_id);\n\t\tif (ret)\n\t\t\tath10k_warn(ar, \"failed to down monitor vdev %i: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\n\t\tarvif->is_up = false;\n\t}\n\n\tret = ath10k_vdev_stop(arvif);\n\tif (ret)\n\t\tath10k_warn(ar, \"failed to stop vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\n\tarvif->is_started = false;\n\n\tmutex_unlock(&ar->conf_mutex);\n}\n\nstatic int\nath10k_mac_op_switch_vif_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif_chanctx_switch *vifs,\n\t\t\t\t int n_vifs,\n\t\t\t\t enum ieee80211_chanctx_switch_mode mode)\n{\n\tstruct ath10k *ar = hw->priv;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC,\n\t\t   \"mac chanctx switch n_vifs %d mode %d\\n\",\n\t\t   n_vifs, mode);\n\tath10k_mac_update_vif_chan(ar, vifs, n_vifs);\n\n\tmutex_unlock(&ar->conf_mutex);\n\treturn 0;\n}\n\nstatic void ath10k_mac_op_sta_pre_rcu_remove(struct ieee80211_hw *hw,\n\t\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t\t     struct ieee80211_sta *sta)\n{\n\tstruct ath10k *ar;\n\tstruct ath10k_peer *peer;\n\n\tar = hw->priv;\n\n\tlist_for_each_entry(peer, &ar->peers, list)\n\t\tif (peer->sta == sta)\n\t\t\tpeer->removed = true;\n}\n\n \nstatic const struct ath10k_index_ht_data_rate_type supported_ht_mcs_rate_nss1[] = {\n\t \n\t{0,  { 65,  135,  72,  150} },\n\t{1,  { 130, 270,  144, 300} },\n\t{2,  { 195, 405,  217, 450} },\n\t{3,  { 260, 540,  289, 600} },\n\t{4,  { 390, 810,  433, 900} },\n\t{5,  { 520, 1080, 578, 1200} },\n\t{6,  { 585, 1215, 650, 1350} },\n\t{7,  { 650, 1350, 722, 1500} }\n};\n\n \nstatic const struct ath10k_index_ht_data_rate_type supported_ht_mcs_rate_nss2[] = {\n\t \n\t{0,  {130,  270,  144,  300} },\n\t{1,  {260,  540,  289,  600} },\n\t{2,  {390,  810,  433,  900} },\n\t{3,  {520,  1080, 578,  1200} },\n\t{4,  {780,  1620, 867,  1800} },\n\t{5,  {1040, 2160, 1156, 2400} },\n\t{6,  {1170, 2430, 1300, 2700} },\n\t{7,  {1300, 2700, 1444, 3000} }\n};\n\n \nstatic const struct ath10k_index_vht_data_rate_type supported_vht_mcs_rate_nss1[] = {\n\t \n\t{0,  {293,  325},  {135,  150},  {65,   72} },\n\t{1,  {585,  650},  {270,  300},  {130,  144} },\n\t{2,  {878,  975},  {405,  450},  {195,  217} },\n\t{3,  {1170, 1300}, {540,  600},  {260,  289} },\n\t{4,  {1755, 1950}, {810,  900},  {390,  433} },\n\t{5,  {2340, 2600}, {1080, 1200}, {520,  578} },\n\t{6,  {2633, 2925}, {1215, 1350}, {585,  650} },\n\t{7,  {2925, 3250}, {1350, 1500}, {650,  722} },\n\t{8,  {3510, 3900}, {1620, 1800}, {780,  867} },\n\t{9,  {3900, 4333}, {1800, 2000}, {780,  867} }\n};\n\n \nstatic const struct ath10k_index_vht_data_rate_type supported_vht_mcs_rate_nss2[] = {\n\t \n\t{0,  {585,  650},  {270,  300},  {130,  144} },\n\t{1,  {1170, 1300}, {540,  600},  {260,  289} },\n\t{2,  {1755, 1950}, {810,  900},  {390,  433} },\n\t{3,  {2340, 2600}, {1080, 1200}, {520,  578} },\n\t{4,  {3510, 3900}, {1620, 1800}, {780,  867} },\n\t{5,  {4680, 5200}, {2160, 2400}, {1040, 1156} },\n\t{6,  {5265, 5850}, {2430, 2700}, {1170, 1300} },\n\t{7,  {5850, 6500}, {2700, 3000}, {1300, 1444} },\n\t{8,  {7020, 7800}, {3240, 3600}, {1560, 1733} },\n\t{9,  {7800, 8667}, {3600, 4000}, {1560, 1733} }\n};\n\nstatic void ath10k_mac_get_rate_flags_ht(struct ath10k *ar, u32 rate, u8 nss, u8 mcs,\n\t\t\t\t\t u8 *flags, u8 *bw)\n{\n\tstruct ath10k_index_ht_data_rate_type *mcs_rate;\n\tu8 index;\n\tsize_t len_nss1 = ARRAY_SIZE(supported_ht_mcs_rate_nss1);\n\tsize_t len_nss2 = ARRAY_SIZE(supported_ht_mcs_rate_nss2);\n\n\tif (mcs >= (len_nss1 + len_nss2)) {\n\t\tath10k_warn(ar, \"not supported mcs %d in current rate table\", mcs);\n\t\treturn;\n\t}\n\n\tmcs_rate = (struct ath10k_index_ht_data_rate_type *)\n\t\t   ((nss == 1) ? &supported_ht_mcs_rate_nss1 :\n\t\t   &supported_ht_mcs_rate_nss2);\n\n\tif (mcs >= len_nss1)\n\t\tindex = mcs - len_nss1;\n\telse\n\t\tindex = mcs;\n\n\tif (rate == mcs_rate[index].supported_rate[0]) {\n\t\t*bw = RATE_INFO_BW_20;\n\t} else if (rate == mcs_rate[index].supported_rate[1]) {\n\t\t*bw |= RATE_INFO_BW_40;\n\t} else if (rate == mcs_rate[index].supported_rate[2]) {\n\t\t*bw |= RATE_INFO_BW_20;\n\t\t*flags |= RATE_INFO_FLAGS_SHORT_GI;\n\t} else if (rate == mcs_rate[index].supported_rate[3]) {\n\t\t*bw |= RATE_INFO_BW_40;\n\t\t*flags |= RATE_INFO_FLAGS_SHORT_GI;\n\t} else {\n\t\tath10k_warn(ar, \"invalid ht params rate %d 100kbps nss %d mcs %d\",\n\t\t\t    rate, nss, mcs);\n\t}\n}\n\nstatic void ath10k_mac_get_rate_flags_vht(struct ath10k *ar, u32 rate, u8 nss, u8 mcs,\n\t\t\t\t\t  u8 *flags, u8 *bw)\n{\n\tstruct ath10k_index_vht_data_rate_type *mcs_rate;\n\n\tmcs_rate = (struct ath10k_index_vht_data_rate_type *)\n\t\t   ((nss == 1) ? &supported_vht_mcs_rate_nss1 :\n\t\t   &supported_vht_mcs_rate_nss2);\n\n\tif (rate == mcs_rate[mcs].supported_VHT80_rate[0]) {\n\t\t*bw = RATE_INFO_BW_80;\n\t} else if (rate == mcs_rate[mcs].supported_VHT80_rate[1]) {\n\t\t*bw = RATE_INFO_BW_80;\n\t\t*flags |= RATE_INFO_FLAGS_SHORT_GI;\n\t} else if (rate == mcs_rate[mcs].supported_VHT40_rate[0]) {\n\t\t*bw = RATE_INFO_BW_40;\n\t} else if (rate == mcs_rate[mcs].supported_VHT40_rate[1]) {\n\t\t*bw = RATE_INFO_BW_40;\n\t\t*flags |= RATE_INFO_FLAGS_SHORT_GI;\n\t} else if (rate == mcs_rate[mcs].supported_VHT20_rate[0]) {\n\t\t*bw = RATE_INFO_BW_20;\n\t} else if (rate == mcs_rate[mcs].supported_VHT20_rate[1]) {\n\t\t*bw = RATE_INFO_BW_20;\n\t\t*flags |= RATE_INFO_FLAGS_SHORT_GI;\n\t} else {\n\t\tath10k_warn(ar, \"invalid vht params rate %d 100kbps nss %d mcs %d\",\n\t\t\t    rate, nss, mcs);\n\t}\n}\n\nstatic void ath10k_mac_get_rate_flags(struct ath10k *ar, u32 rate,\n\t\t\t\t      enum ath10k_phy_mode mode, u8 nss, u8 mcs,\n\t\t\t\t      u8 *flags, u8 *bw)\n{\n\tif (mode == ATH10K_PHY_MODE_HT) {\n\t\t*flags = RATE_INFO_FLAGS_MCS;\n\t\tath10k_mac_get_rate_flags_ht(ar, rate, nss, mcs, flags, bw);\n\t} else if (mode == ATH10K_PHY_MODE_VHT) {\n\t\t*flags = RATE_INFO_FLAGS_VHT_MCS;\n\t\tath10k_mac_get_rate_flags_vht(ar, rate, nss, mcs, flags, bw);\n\t}\n}\n\nstatic void ath10k_mac_parse_bitrate(struct ath10k *ar, u32 rate_code,\n\t\t\t\t     u32 bitrate_kbps, struct rate_info *rate)\n{\n\tenum ath10k_phy_mode mode = ATH10K_PHY_MODE_LEGACY;\n\tenum wmi_rate_preamble preamble = WMI_TLV_GET_HW_RC_PREAM_V1(rate_code);\n\tu8 nss = WMI_TLV_GET_HW_RC_NSS_V1(rate_code) + 1;\n\tu8 mcs = WMI_TLV_GET_HW_RC_RATE_V1(rate_code);\n\tu8 flags = 0, bw = 0;\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC, \"mac parse rate code 0x%x bitrate %d kbps\\n\",\n\t\t   rate_code, bitrate_kbps);\n\n\tif (preamble == WMI_RATE_PREAMBLE_HT)\n\t\tmode = ATH10K_PHY_MODE_HT;\n\telse if (preamble == WMI_RATE_PREAMBLE_VHT)\n\t\tmode = ATH10K_PHY_MODE_VHT;\n\n\tath10k_mac_get_rate_flags(ar, bitrate_kbps / 100, mode, nss, mcs, &flags, &bw);\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC,\n\t\t   \"mac parse bitrate preamble %d mode %d nss %d mcs %d flags %x bw %d\\n\",\n\t\t   preamble, mode, nss, mcs, flags, bw);\n\n\trate->flags = flags;\n\trate->bw = bw;\n\trate->legacy = bitrate_kbps / 100;\n\trate->nss = nss;\n\trate->mcs = mcs;\n}\n\nstatic void ath10k_mac_sta_get_peer_stats_info(struct ath10k *ar,\n\t\t\t\t\t       struct ieee80211_sta *sta,\n\t\t\t\t\t       struct station_info *sinfo)\n{\n\tstruct ath10k_sta *arsta = (struct ath10k_sta *)sta->drv_priv;\n\tstruct ath10k_peer *peer;\n\tunsigned long time_left;\n\tint ret;\n\n\tif (!(ar->hw_params.supports_peer_stats_info &&\n\t      arsta->arvif->vdev_type == WMI_VDEV_TYPE_STA))\n\t\treturn;\n\n\tspin_lock_bh(&ar->data_lock);\n\tpeer = ath10k_peer_find(ar, arsta->arvif->vdev_id, sta->addr);\n\tspin_unlock_bh(&ar->data_lock);\n\tif (!peer)\n\t\treturn;\n\n\treinit_completion(&ar->peer_stats_info_complete);\n\n\tret = ath10k_wmi_request_peer_stats_info(ar,\n\t\t\t\t\t\t arsta->arvif->vdev_id,\n\t\t\t\t\t\t WMI_REQUEST_ONE_PEER_STATS_INFO,\n\t\t\t\t\t\t arsta->arvif->bssid,\n\t\t\t\t\t\t 0);\n\tif (ret && ret != -EOPNOTSUPP) {\n\t\tath10k_warn(ar, \"could not request peer stats info: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\ttime_left = wait_for_completion_timeout(&ar->peer_stats_info_complete, 3 * HZ);\n\tif (time_left == 0) {\n\t\tath10k_warn(ar, \"timed out waiting peer stats info\\n\");\n\t\treturn;\n\t}\n\n\tif (arsta->rx_rate_code != 0 && arsta->rx_bitrate_kbps != 0) {\n\t\tath10k_mac_parse_bitrate(ar, arsta->rx_rate_code,\n\t\t\t\t\t arsta->rx_bitrate_kbps,\n\t\t\t\t\t &sinfo->rxrate);\n\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_BITRATE);\n\t\tarsta->rx_rate_code = 0;\n\t\tarsta->rx_bitrate_kbps = 0;\n\t}\n\n\tif (arsta->tx_rate_code != 0 && arsta->tx_bitrate_kbps != 0) {\n\t\tath10k_mac_parse_bitrate(ar, arsta->tx_rate_code,\n\t\t\t\t\t arsta->tx_bitrate_kbps,\n\t\t\t\t\t &sinfo->txrate);\n\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_BITRATE);\n\t\tarsta->tx_rate_code = 0;\n\t\tarsta->tx_bitrate_kbps = 0;\n\t}\n}\n\nstatic void ath10k_sta_statistics(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  struct ieee80211_sta *sta,\n\t\t\t\t  struct station_info *sinfo)\n{\n\tstruct ath10k_sta *arsta = (struct ath10k_sta *)sta->drv_priv;\n\tstruct ath10k *ar = arsta->arvif->ar;\n\n\tif (!ath10k_peer_stats_enabled(ar))\n\t\treturn;\n\n\tmutex_lock(&ar->conf_mutex);\n\tath10k_debug_fw_stats_request(ar);\n\tmutex_unlock(&ar->conf_mutex);\n\n\tsinfo->rx_duration = arsta->rx_duration;\n\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_DURATION);\n\n\tif (arsta->txrate.legacy || arsta->txrate.nss) {\n\t\tif (arsta->txrate.legacy) {\n\t\t\tsinfo->txrate.legacy = arsta->txrate.legacy;\n\t\t} else {\n\t\t\tsinfo->txrate.mcs = arsta->txrate.mcs;\n\t\t\tsinfo->txrate.nss = arsta->txrate.nss;\n\t\t\tsinfo->txrate.bw = arsta->txrate.bw;\n\t\t}\n\t\tsinfo->txrate.flags = arsta->txrate.flags;\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_BITRATE);\n\t}\n\n\tif (ar->htt.disable_tx_comp) {\n\t\tsinfo->tx_failed = arsta->tx_failed;\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_FAILED);\n\t}\n\n\tsinfo->tx_retries = arsta->tx_retries;\n\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_RETRIES);\n\n\tath10k_mac_sta_get_peer_stats_info(ar, sta, sinfo);\n}\n\nstatic int ath10k_mac_op_set_tid_config(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\t\tstruct ieee80211_sta *sta,\n\t\t\t\t\tstruct cfg80211_tid_config *tid_config)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct ath10k_mac_iter_tid_conf_data data = {};\n\tstruct wmi_per_peer_per_tid_cfg_arg arg = {};\n\tint ret, i;\n\n\tmutex_lock(&ar->conf_mutex);\n\targ.vdev_id = arvif->vdev_id;\n\n\tarvif->tids_rst = 0;\n\tmemset(arvif->tid_conf_changed, 0, sizeof(arvif->tid_conf_changed));\n\n\tfor (i = 0; i < tid_config->n_tid_conf; i++) {\n\t\tret = ath10k_mac_parse_tid_config(ar, sta, vif,\n\t\t\t\t\t\t  &tid_config->tid_conf[i],\n\t\t\t\t\t\t  &arg);\n\t\tif (ret)\n\t\t\tgoto exit;\n\t}\n\n\tret = 0;\n\n\tif (sta)\n\t\tgoto exit;\n\n\tarvif->tids_rst = 0;\n\tdata.curr_vif = vif;\n\tdata.ar = ar;\n\n\tieee80211_iterate_stations_atomic(hw, ath10k_mac_vif_stations_tid_conf,\n\t\t\t\t\t  &data);\n\nexit:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic int ath10k_mac_op_reset_tid_config(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t\t  struct ieee80211_sta *sta,\n\t\t\t\t\t  u8 tids)\n{\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct ath10k_mac_iter_tid_conf_data data = {};\n\tstruct ath10k *ar = hw->priv;\n\tint ret = 0;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (sta) {\n\t\tarvif->tids_rst = 0;\n\t\tret = ath10k_mac_reset_tid_config(ar, sta, arvif, tids);\n\t\tgoto exit;\n\t}\n\n\tarvif->tids_rst = tids;\n\tdata.curr_vif = vif;\n\tdata.ar = ar;\n\tieee80211_iterate_stations_atomic(hw, ath10k_mac_vif_stations_tid_conf,\n\t\t\t\t\t  &data);\n\nexit:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic const struct ieee80211_ops ath10k_ops = {\n\t.tx\t\t\t\t= ath10k_mac_op_tx,\n\t.wake_tx_queue\t\t\t= ath10k_mac_op_wake_tx_queue,\n\t.start\t\t\t\t= ath10k_start,\n\t.stop\t\t\t\t= ath10k_stop,\n\t.config\t\t\t\t= ath10k_config,\n\t.add_interface\t\t\t= ath10k_add_interface,\n\t.update_vif_offload\t\t= ath10k_update_vif_offload,\n\t.remove_interface\t\t= ath10k_remove_interface,\n\t.configure_filter\t\t= ath10k_configure_filter,\n\t.bss_info_changed\t\t= ath10k_bss_info_changed,\n\t.set_coverage_class\t\t= ath10k_mac_op_set_coverage_class,\n\t.hw_scan\t\t\t= ath10k_hw_scan,\n\t.cancel_hw_scan\t\t\t= ath10k_cancel_hw_scan,\n\t.set_key\t\t\t= ath10k_set_key,\n\t.set_default_unicast_key        = ath10k_set_default_unicast_key,\n\t.sta_state\t\t\t= ath10k_sta_state,\n\t.sta_set_txpwr\t\t\t= ath10k_sta_set_txpwr,\n\t.conf_tx\t\t\t= ath10k_conf_tx,\n\t.remain_on_channel\t\t= ath10k_remain_on_channel,\n\t.cancel_remain_on_channel\t= ath10k_cancel_remain_on_channel,\n\t.set_rts_threshold\t\t= ath10k_set_rts_threshold,\n\t.set_frag_threshold\t\t= ath10k_mac_op_set_frag_threshold,\n\t.flush\t\t\t\t= ath10k_flush,\n\t.tx_last_beacon\t\t\t= ath10k_tx_last_beacon,\n\t.set_antenna\t\t\t= ath10k_set_antenna,\n\t.get_antenna\t\t\t= ath10k_get_antenna,\n\t.reconfig_complete\t\t= ath10k_reconfig_complete,\n\t.get_survey\t\t\t= ath10k_get_survey,\n\t.set_bitrate_mask\t\t= ath10k_mac_op_set_bitrate_mask,\n\t.sta_rc_update\t\t\t= ath10k_sta_rc_update,\n\t.offset_tsf\t\t\t= ath10k_offset_tsf,\n\t.ampdu_action\t\t\t= ath10k_ampdu_action,\n\t.get_et_sset_count\t\t= ath10k_debug_get_et_sset_count,\n\t.get_et_stats\t\t\t= ath10k_debug_get_et_stats,\n\t.get_et_strings\t\t\t= ath10k_debug_get_et_strings,\n\t.add_chanctx\t\t\t= ath10k_mac_op_add_chanctx,\n\t.remove_chanctx\t\t\t= ath10k_mac_op_remove_chanctx,\n\t.change_chanctx\t\t\t= ath10k_mac_op_change_chanctx,\n\t.assign_vif_chanctx\t\t= ath10k_mac_op_assign_vif_chanctx,\n\t.unassign_vif_chanctx\t\t= ath10k_mac_op_unassign_vif_chanctx,\n\t.switch_vif_chanctx\t\t= ath10k_mac_op_switch_vif_chanctx,\n\t.sta_pre_rcu_remove\t\t= ath10k_mac_op_sta_pre_rcu_remove,\n\t.sta_statistics\t\t\t= ath10k_sta_statistics,\n\t.set_tid_config\t\t\t= ath10k_mac_op_set_tid_config,\n\t.reset_tid_config\t\t= ath10k_mac_op_reset_tid_config,\n\n\tCFG80211_TESTMODE_CMD(ath10k_tm_cmd)\n\n#ifdef CONFIG_PM\n\t.suspend\t\t\t= ath10k_wow_op_suspend,\n\t.resume\t\t\t\t= ath10k_wow_op_resume,\n\t.set_wakeup\t\t\t= ath10k_wow_op_set_wakeup,\n#endif\n#ifdef CONFIG_MAC80211_DEBUGFS\n\t.sta_add_debugfs\t\t= ath10k_sta_add_debugfs,\n#endif\n\t.set_sar_specs\t\t\t= ath10k_mac_set_sar_specs,\n};\n\n#define CHAN2G(_channel, _freq, _flags) { \\\n\t.band\t\t\t= NL80211_BAND_2GHZ, \\\n\t.hw_value\t\t= (_channel), \\\n\t.center_freq\t\t= (_freq), \\\n\t.flags\t\t\t= (_flags), \\\n\t.max_antenna_gain\t= 0, \\\n\t.max_power\t\t= 30, \\\n}\n\n#define CHAN5G(_channel, _freq, _flags) { \\\n\t.band\t\t\t= NL80211_BAND_5GHZ, \\\n\t.hw_value\t\t= (_channel), \\\n\t.center_freq\t\t= (_freq), \\\n\t.flags\t\t\t= (_flags), \\\n\t.max_antenna_gain\t= 0, \\\n\t.max_power\t\t= 30, \\\n}\n\nstatic const struct ieee80211_channel ath10k_2ghz_channels[] = {\n\tCHAN2G(1, 2412, 0),\n\tCHAN2G(2, 2417, 0),\n\tCHAN2G(3, 2422, 0),\n\tCHAN2G(4, 2427, 0),\n\tCHAN2G(5, 2432, 0),\n\tCHAN2G(6, 2437, 0),\n\tCHAN2G(7, 2442, 0),\n\tCHAN2G(8, 2447, 0),\n\tCHAN2G(9, 2452, 0),\n\tCHAN2G(10, 2457, 0),\n\tCHAN2G(11, 2462, 0),\n\tCHAN2G(12, 2467, 0),\n\tCHAN2G(13, 2472, 0),\n\tCHAN2G(14, 2484, 0),\n};\n\nstatic const struct ieee80211_channel ath10k_5ghz_channels[] = {\n\tCHAN5G(36, 5180, 0),\n\tCHAN5G(40, 5200, 0),\n\tCHAN5G(44, 5220, 0),\n\tCHAN5G(48, 5240, 0),\n\tCHAN5G(52, 5260, 0),\n\tCHAN5G(56, 5280, 0),\n\tCHAN5G(60, 5300, 0),\n\tCHAN5G(64, 5320, 0),\n\tCHAN5G(100, 5500, 0),\n\tCHAN5G(104, 5520, 0),\n\tCHAN5G(108, 5540, 0),\n\tCHAN5G(112, 5560, 0),\n\tCHAN5G(116, 5580, 0),\n\tCHAN5G(120, 5600, 0),\n\tCHAN5G(124, 5620, 0),\n\tCHAN5G(128, 5640, 0),\n\tCHAN5G(132, 5660, 0),\n\tCHAN5G(136, 5680, 0),\n\tCHAN5G(140, 5700, 0),\n\tCHAN5G(144, 5720, 0),\n\tCHAN5G(149, 5745, 0),\n\tCHAN5G(153, 5765, 0),\n\tCHAN5G(157, 5785, 0),\n\tCHAN5G(161, 5805, 0),\n\tCHAN5G(165, 5825, 0),\n\tCHAN5G(169, 5845, 0),\n\tCHAN5G(173, 5865, 0),\n\t \n\t \n};\n\nstruct ath10k *ath10k_mac_create(size_t priv_size)\n{\n\tstruct ieee80211_hw *hw;\n\tstruct ieee80211_ops *ops;\n\tstruct ath10k *ar;\n\n\tops = kmemdup(&ath10k_ops, sizeof(ath10k_ops), GFP_KERNEL);\n\tif (!ops)\n\t\treturn NULL;\n\n\thw = ieee80211_alloc_hw(sizeof(struct ath10k) + priv_size, ops);\n\tif (!hw) {\n\t\tkfree(ops);\n\t\treturn NULL;\n\t}\n\n\tar = hw->priv;\n\tar->hw = hw;\n\tar->ops = ops;\n\n\treturn ar;\n}\n\nvoid ath10k_mac_destroy(struct ath10k *ar)\n{\n\tstruct ieee80211_ops *ops = ar->ops;\n\n\tieee80211_free_hw(ar->hw);\n\tkfree(ops);\n}\n\nstatic const struct ieee80211_iface_limit ath10k_if_limits[] = {\n\t{\n\t\t.max\t= 8,\n\t\t.types\t= BIT(NL80211_IFTYPE_STATION)\n\t\t\t| BIT(NL80211_IFTYPE_P2P_CLIENT)\n\t},\n\t{\n\t\t.max\t= 3,\n\t\t.types\t= BIT(NL80211_IFTYPE_P2P_GO)\n\t},\n\t{\n\t\t.max\t= 1,\n\t\t.types\t= BIT(NL80211_IFTYPE_P2P_DEVICE)\n\t},\n\t{\n\t\t.max\t= 7,\n\t\t.types\t= BIT(NL80211_IFTYPE_AP)\n#ifdef CONFIG_MAC80211_MESH\n\t\t\t| BIT(NL80211_IFTYPE_MESH_POINT)\n#endif\n\t},\n};\n\nstatic const struct ieee80211_iface_limit ath10k_10x_if_limits[] = {\n\t{\n\t\t.max\t= 8,\n\t\t.types\t= BIT(NL80211_IFTYPE_AP)\n#ifdef CONFIG_MAC80211_MESH\n\t\t\t| BIT(NL80211_IFTYPE_MESH_POINT)\n#endif\n\t},\n\t{\n\t\t.max\t= 1,\n\t\t.types\t= BIT(NL80211_IFTYPE_STATION)\n\t},\n};\n\nstatic const struct ieee80211_iface_combination ath10k_if_comb[] = {\n\t{\n\t\t.limits = ath10k_if_limits,\n\t\t.n_limits = ARRAY_SIZE(ath10k_if_limits),\n\t\t.max_interfaces = 8,\n\t\t.num_different_channels = 1,\n\t\t.beacon_int_infra_match = true,\n\t},\n};\n\nstatic const struct ieee80211_iface_combination ath10k_10x_if_comb[] = {\n\t{\n\t\t.limits = ath10k_10x_if_limits,\n\t\t.n_limits = ARRAY_SIZE(ath10k_10x_if_limits),\n\t\t.max_interfaces = 8,\n\t\t.num_different_channels = 1,\n\t\t.beacon_int_infra_match = true,\n\t\t.beacon_int_min_gcd = 1,\n#ifdef CONFIG_ATH10K_DFS_CERTIFIED\n\t\t.radar_detect_widths =\tBIT(NL80211_CHAN_WIDTH_20_NOHT) |\n\t\t\t\t\tBIT(NL80211_CHAN_WIDTH_20) |\n\t\t\t\t\tBIT(NL80211_CHAN_WIDTH_40) |\n\t\t\t\t\tBIT(NL80211_CHAN_WIDTH_80),\n#endif\n\t},\n};\n\nstatic const struct ieee80211_iface_limit ath10k_tlv_if_limit[] = {\n\t{\n\t\t.max = 2,\n\t\t.types = BIT(NL80211_IFTYPE_STATION),\n\t},\n\t{\n\t\t.max = 2,\n\t\t.types = BIT(NL80211_IFTYPE_AP) |\n#ifdef CONFIG_MAC80211_MESH\n\t\t\t BIT(NL80211_IFTYPE_MESH_POINT) |\n#endif\n\t\t\t BIT(NL80211_IFTYPE_P2P_CLIENT) |\n\t\t\t BIT(NL80211_IFTYPE_P2P_GO),\n\t},\n\t{\n\t\t.max = 1,\n\t\t.types = BIT(NL80211_IFTYPE_P2P_DEVICE),\n\t},\n};\n\nstatic const struct ieee80211_iface_limit ath10k_tlv_qcs_if_limit[] = {\n\t{\n\t\t.max = 2,\n\t\t.types = BIT(NL80211_IFTYPE_STATION),\n\t},\n\t{\n\t\t.max = 2,\n\t\t.types = BIT(NL80211_IFTYPE_P2P_CLIENT),\n\t},\n\t{\n\t\t.max = 1,\n\t\t.types = BIT(NL80211_IFTYPE_AP) |\n#ifdef CONFIG_MAC80211_MESH\n\t\t\t BIT(NL80211_IFTYPE_MESH_POINT) |\n#endif\n\t\t\t BIT(NL80211_IFTYPE_P2P_GO),\n\t},\n\t{\n\t\t.max = 1,\n\t\t.types = BIT(NL80211_IFTYPE_P2P_DEVICE),\n\t},\n};\n\nstatic const struct ieee80211_iface_limit ath10k_tlv_if_limit_ibss[] = {\n\t{\n\t\t.max = 1,\n\t\t.types = BIT(NL80211_IFTYPE_STATION),\n\t},\n\t{\n\t\t.max = 1,\n\t\t.types = BIT(NL80211_IFTYPE_ADHOC),\n\t},\n};\n\n \nstatic struct ieee80211_iface_combination ath10k_tlv_if_comb[] = {\n\t{\n\t\t.limits = ath10k_tlv_if_limit,\n\t\t.num_different_channels = 1,\n\t\t.max_interfaces = 4,\n\t\t.n_limits = ARRAY_SIZE(ath10k_tlv_if_limit),\n\t},\n\t{\n\t\t.limits = ath10k_tlv_if_limit_ibss,\n\t\t.num_different_channels = 1,\n\t\t.max_interfaces = 2,\n\t\t.n_limits = ARRAY_SIZE(ath10k_tlv_if_limit_ibss),\n\t},\n};\n\nstatic struct ieee80211_iface_combination ath10k_tlv_qcs_if_comb[] = {\n\t{\n\t\t.limits = ath10k_tlv_if_limit,\n\t\t.num_different_channels = 1,\n\t\t.max_interfaces = 4,\n\t\t.n_limits = ARRAY_SIZE(ath10k_tlv_if_limit),\n\t},\n\t{\n\t\t.limits = ath10k_tlv_qcs_if_limit,\n\t\t.num_different_channels = 2,\n\t\t.max_interfaces = 4,\n\t\t.n_limits = ARRAY_SIZE(ath10k_tlv_qcs_if_limit),\n\t},\n\t{\n\t\t.limits = ath10k_tlv_if_limit_ibss,\n\t\t.num_different_channels = 1,\n\t\t.max_interfaces = 2,\n\t\t.n_limits = ARRAY_SIZE(ath10k_tlv_if_limit_ibss),\n\t},\n};\n\nstatic const struct ieee80211_iface_limit ath10k_10_4_if_limits[] = {\n\t{\n\t\t.max = 1,\n\t\t.types = BIT(NL80211_IFTYPE_STATION),\n\t},\n\t{\n\t\t.max\t= 16,\n\t\t.types\t= BIT(NL80211_IFTYPE_AP)\n#ifdef CONFIG_MAC80211_MESH\n\t\t\t| BIT(NL80211_IFTYPE_MESH_POINT)\n#endif\n\t},\n};\n\nstatic const struct ieee80211_iface_combination ath10k_10_4_if_comb[] = {\n\t{\n\t\t.limits = ath10k_10_4_if_limits,\n\t\t.n_limits = ARRAY_SIZE(ath10k_10_4_if_limits),\n\t\t.max_interfaces = 16,\n\t\t.num_different_channels = 1,\n\t\t.beacon_int_infra_match = true,\n\t\t.beacon_int_min_gcd = 1,\n#ifdef CONFIG_ATH10K_DFS_CERTIFIED\n\t\t.radar_detect_widths =\tBIT(NL80211_CHAN_WIDTH_20_NOHT) |\n\t\t\t\t\tBIT(NL80211_CHAN_WIDTH_20) |\n\t\t\t\t\tBIT(NL80211_CHAN_WIDTH_40) |\n\t\t\t\t\tBIT(NL80211_CHAN_WIDTH_80) |\n\t\t\t\t\tBIT(NL80211_CHAN_WIDTH_80P80) |\n\t\t\t\t\tBIT(NL80211_CHAN_WIDTH_160),\n#endif\n\t},\n};\n\nstatic const struct\nieee80211_iface_combination ath10k_10_4_bcn_int_if_comb[] = {\n\t{\n\t\t.limits = ath10k_10_4_if_limits,\n\t\t.n_limits = ARRAY_SIZE(ath10k_10_4_if_limits),\n\t\t.max_interfaces = 16,\n\t\t.num_different_channels = 1,\n\t\t.beacon_int_infra_match = true,\n\t\t.beacon_int_min_gcd = 100,\n#ifdef CONFIG_ATH10K_DFS_CERTIFIED\n\t\t.radar_detect_widths =  BIT(NL80211_CHAN_WIDTH_20_NOHT) |\n\t\t\t\t\tBIT(NL80211_CHAN_WIDTH_20) |\n\t\t\t\t\tBIT(NL80211_CHAN_WIDTH_40) |\n\t\t\t\t\tBIT(NL80211_CHAN_WIDTH_80) |\n\t\t\t\t\tBIT(NL80211_CHAN_WIDTH_80P80) |\n\t\t\t\t\tBIT(NL80211_CHAN_WIDTH_160),\n#endif\n\t},\n};\n\nstatic void ath10k_get_arvif_iter(void *data, u8 *mac,\n\t\t\t\t  struct ieee80211_vif *vif)\n{\n\tstruct ath10k_vif_iter *arvif_iter = data;\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\n\tif (arvif->vdev_id == arvif_iter->vdev_id)\n\t\tarvif_iter->arvif = arvif;\n}\n\nstruct ath10k_vif *ath10k_get_arvif(struct ath10k *ar, u32 vdev_id)\n{\n\tstruct ath10k_vif_iter arvif_iter;\n\n\tmemset(&arvif_iter, 0, sizeof(struct ath10k_vif_iter));\n\tarvif_iter.vdev_id = vdev_id;\n\n\tieee80211_iterate_active_interfaces_atomic(ar->hw,\n\t\t\t\t\t\t   ATH10K_ITER_RESUME_FLAGS,\n\t\t\t\t\t\t   ath10k_get_arvif_iter,\n\t\t\t\t\t\t   &arvif_iter);\n\tif (!arvif_iter.arvif) {\n\t\tath10k_warn(ar, \"No VIF found for vdev %d\\n\", vdev_id);\n\t\treturn NULL;\n\t}\n\n\treturn arvif_iter.arvif;\n}\n\n#define WRD_METHOD \"WRDD\"\n#define WRDD_WIFI  (0x07)\n\nstatic u32 ath10k_mac_wrdd_get_mcc(struct ath10k *ar, union acpi_object *wrdd)\n{\n\tunion acpi_object *mcc_pkg;\n\tunion acpi_object *domain_type;\n\tunion acpi_object *mcc_value;\n\tu32 i;\n\n\tif (wrdd->type != ACPI_TYPE_PACKAGE ||\n\t    wrdd->package.count < 2 ||\n\t    wrdd->package.elements[0].type != ACPI_TYPE_INTEGER ||\n\t    wrdd->package.elements[0].integer.value != 0) {\n\t\tath10k_warn(ar, \"ignoring malformed/unsupported wrdd structure\\n\");\n\t\treturn 0;\n\t}\n\n\tfor (i = 1; i < wrdd->package.count; ++i) {\n\t\tmcc_pkg = &wrdd->package.elements[i];\n\n\t\tif (mcc_pkg->type != ACPI_TYPE_PACKAGE)\n\t\t\tcontinue;\n\t\tif (mcc_pkg->package.count < 2)\n\t\t\tcontinue;\n\t\tif (mcc_pkg->package.elements[0].type != ACPI_TYPE_INTEGER ||\n\t\t    mcc_pkg->package.elements[1].type != ACPI_TYPE_INTEGER)\n\t\t\tcontinue;\n\n\t\tdomain_type = &mcc_pkg->package.elements[0];\n\t\tif (domain_type->integer.value != WRDD_WIFI)\n\t\t\tcontinue;\n\n\t\tmcc_value = &mcc_pkg->package.elements[1];\n\t\treturn mcc_value->integer.value;\n\t}\n\treturn 0;\n}\n\nstatic int ath10k_mac_get_wrdd_regulatory(struct ath10k *ar, u16 *rd)\n{\n\tacpi_handle root_handle;\n\tacpi_handle handle;\n\tstruct acpi_buffer wrdd = {ACPI_ALLOCATE_BUFFER, NULL};\n\tacpi_status status;\n\tu32 alpha2_code;\n\tchar alpha2[3];\n\n\troot_handle = ACPI_HANDLE(ar->dev);\n\tif (!root_handle)\n\t\treturn -EOPNOTSUPP;\n\n\tstatus = acpi_get_handle(root_handle, (acpi_string)WRD_METHOD, &handle);\n\tif (ACPI_FAILURE(status)) {\n\t\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t\t   \"failed to get wrd method %d\\n\", status);\n\t\treturn -EIO;\n\t}\n\n\tstatus = acpi_evaluate_object(handle, NULL, NULL, &wrdd);\n\tif (ACPI_FAILURE(status)) {\n\t\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t\t   \"failed to call wrdc %d\\n\", status);\n\t\treturn -EIO;\n\t}\n\n\talpha2_code = ath10k_mac_wrdd_get_mcc(ar, wrdd.pointer);\n\tkfree(wrdd.pointer);\n\tif (!alpha2_code)\n\t\treturn -EIO;\n\n\talpha2[0] = (alpha2_code >> 8) & 0xff;\n\talpha2[1] = (alpha2_code >> 0) & 0xff;\n\talpha2[2] = '\\0';\n\n\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t   \"regulatory hint from WRDD (alpha2-code): %s\\n\", alpha2);\n\n\t*rd = ath_regd_find_country_by_name(alpha2);\n\tif (*rd == 0xffff)\n\t\treturn -EIO;\n\n\t*rd |= COUNTRY_ERD_FLAG;\n\treturn 0;\n}\n\nstatic int ath10k_mac_init_rd(struct ath10k *ar)\n{\n\tint ret;\n\tu16 rd;\n\n\tret = ath10k_mac_get_wrdd_regulatory(ar, &rd);\n\tif (ret) {\n\t\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t\t   \"fallback to eeprom programmed regulatory settings\\n\");\n\t\trd = ar->hw_eeprom_rd;\n\t}\n\n\tar->ath_common.regulatory.current_rd = rd;\n\treturn 0;\n}\n\nint ath10k_mac_register(struct ath10k *ar)\n{\n\tstatic const u32 cipher_suites[] = {\n\t\tWLAN_CIPHER_SUITE_WEP40,\n\t\tWLAN_CIPHER_SUITE_WEP104,\n\t\tWLAN_CIPHER_SUITE_TKIP,\n\t\tWLAN_CIPHER_SUITE_CCMP,\n\n\t\t \n\t\tWLAN_CIPHER_SUITE_AES_CMAC,\n\t\tWLAN_CIPHER_SUITE_BIP_CMAC_256,\n\t\tWLAN_CIPHER_SUITE_BIP_GMAC_128,\n\t\tWLAN_CIPHER_SUITE_BIP_GMAC_256,\n\n\t\t \n\t\tWLAN_CIPHER_SUITE_GCMP,\n\t\tWLAN_CIPHER_SUITE_GCMP_256,\n\t\tWLAN_CIPHER_SUITE_CCMP_256,\n\t};\n\tstruct ieee80211_supported_band *band;\n\tvoid *channels;\n\tint ret;\n\n\tif (!is_valid_ether_addr(ar->mac_addr)) {\n\t\tath10k_warn(ar, \"invalid MAC address; choosing random\\n\");\n\t\teth_random_addr(ar->mac_addr);\n\t}\n\tSET_IEEE80211_PERM_ADDR(ar->hw, ar->mac_addr);\n\n\tSET_IEEE80211_DEV(ar->hw, ar->dev);\n\n\tBUILD_BUG_ON((ARRAY_SIZE(ath10k_2ghz_channels) +\n\t\t      ARRAY_SIZE(ath10k_5ghz_channels)) !=\n\t\t     ATH10K_NUM_CHANS);\n\n\tif (ar->phy_capability & WHAL_WLAN_11G_CAPABILITY) {\n\t\tchannels = kmemdup(ath10k_2ghz_channels,\n\t\t\t\t   sizeof(ath10k_2ghz_channels),\n\t\t\t\t   GFP_KERNEL);\n\t\tif (!channels) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tband = &ar->mac.sbands[NL80211_BAND_2GHZ];\n\t\tband->n_channels = ARRAY_SIZE(ath10k_2ghz_channels);\n\t\tband->channels = channels;\n\n\t\tif (ar->hw_params.cck_rate_map_rev2) {\n\t\t\tband->n_bitrates = ath10k_g_rates_rev2_size;\n\t\t\tband->bitrates = ath10k_g_rates_rev2;\n\t\t} else {\n\t\t\tband->n_bitrates = ath10k_g_rates_size;\n\t\t\tband->bitrates = ath10k_g_rates;\n\t\t}\n\n\t\tar->hw->wiphy->bands[NL80211_BAND_2GHZ] = band;\n\t}\n\n\tif (ar->phy_capability & WHAL_WLAN_11A_CAPABILITY) {\n\t\tchannels = kmemdup(ath10k_5ghz_channels,\n\t\t\t\t   sizeof(ath10k_5ghz_channels),\n\t\t\t\t   GFP_KERNEL);\n\t\tif (!channels) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_free;\n\t\t}\n\n\t\tband = &ar->mac.sbands[NL80211_BAND_5GHZ];\n\t\tband->n_channels = ARRAY_SIZE(ath10k_5ghz_channels);\n\t\tband->channels = channels;\n\t\tband->n_bitrates = ath10k_a_rates_size;\n\t\tband->bitrates = ath10k_a_rates;\n\t\tar->hw->wiphy->bands[NL80211_BAND_5GHZ] = band;\n\t}\n\n\twiphy_read_of_freq_limits(ar->hw->wiphy);\n\tath10k_mac_setup_ht_vht_cap(ar);\n\n\tar->hw->wiphy->interface_modes =\n\t\tBIT(NL80211_IFTYPE_STATION) |\n\t\tBIT(NL80211_IFTYPE_AP) |\n\t\tBIT(NL80211_IFTYPE_MESH_POINT);\n\n\tar->hw->wiphy->available_antennas_rx = ar->cfg_rx_chainmask;\n\tar->hw->wiphy->available_antennas_tx = ar->cfg_tx_chainmask;\n\n\tif (!test_bit(ATH10K_FW_FEATURE_NO_P2P, ar->normal_mode_fw.fw_file.fw_features))\n\t\tar->hw->wiphy->interface_modes |=\n\t\t\tBIT(NL80211_IFTYPE_P2P_DEVICE) |\n\t\t\tBIT(NL80211_IFTYPE_P2P_CLIENT) |\n\t\t\tBIT(NL80211_IFTYPE_P2P_GO);\n\n\tieee80211_hw_set(ar->hw, SIGNAL_DBM);\n\n\tif (!test_bit(ATH10K_FW_FEATURE_NO_PS,\n\t\t      ar->running_fw->fw_file.fw_features)) {\n\t\tieee80211_hw_set(ar->hw, SUPPORTS_PS);\n\t\tieee80211_hw_set(ar->hw, SUPPORTS_DYNAMIC_PS);\n\t}\n\n\tieee80211_hw_set(ar->hw, MFP_CAPABLE);\n\tieee80211_hw_set(ar->hw, REPORTS_TX_ACK_STATUS);\n\tieee80211_hw_set(ar->hw, HAS_RATE_CONTROL);\n\tieee80211_hw_set(ar->hw, AP_LINK_PS);\n\tieee80211_hw_set(ar->hw, SPECTRUM_MGMT);\n\tieee80211_hw_set(ar->hw, SUPPORT_FAST_XMIT);\n\tieee80211_hw_set(ar->hw, CONNECTION_MONITOR);\n\tieee80211_hw_set(ar->hw, SUPPORTS_PER_STA_GTK);\n\tieee80211_hw_set(ar->hw, WANT_MONITOR_VIF);\n\tieee80211_hw_set(ar->hw, CHANCTX_STA_CSA);\n\tieee80211_hw_set(ar->hw, QUEUE_CONTROL);\n\tieee80211_hw_set(ar->hw, SUPPORTS_TX_FRAG);\n\tieee80211_hw_set(ar->hw, REPORTS_LOW_ACK);\n\n\tif (!test_bit(ATH10K_FLAG_RAW_MODE, &ar->dev_flags))\n\t\tieee80211_hw_set(ar->hw, SW_CRYPTO_CONTROL);\n\n\tar->hw->wiphy->features |= NL80211_FEATURE_STATIC_SMPS;\n\tar->hw->wiphy->flags |= WIPHY_FLAG_IBSS_RSN;\n\n\tif (ar->ht_cap_info & WMI_HT_CAP_DYNAMIC_SMPS)\n\t\tar->hw->wiphy->features |= NL80211_FEATURE_DYNAMIC_SMPS;\n\n\tif (ar->ht_cap_info & WMI_HT_CAP_ENABLED) {\n\t\tieee80211_hw_set(ar->hw, AMPDU_AGGREGATION);\n\t\tieee80211_hw_set(ar->hw, TX_AMPDU_SETUP_IN_HW);\n\t}\n\n\tar->hw->wiphy->max_scan_ssids = WLAN_SCAN_PARAMS_MAX_SSID;\n\tar->hw->wiphy->max_scan_ie_len = WLAN_SCAN_PARAMS_MAX_IE_LEN;\n\n\tif (test_bit(WMI_SERVICE_NLO, ar->wmi.svc_map)) {\n\t\tar->hw->wiphy->max_sched_scan_ssids = WMI_PNO_MAX_SUPP_NETWORKS;\n\t\tar->hw->wiphy->max_match_sets = WMI_PNO_MAX_SUPP_NETWORKS;\n\t\tar->hw->wiphy->max_sched_scan_ie_len = WMI_PNO_MAX_IE_LENGTH;\n\t\tar->hw->wiphy->max_sched_scan_plans = WMI_PNO_MAX_SCHED_SCAN_PLANS;\n\t\tar->hw->wiphy->max_sched_scan_plan_interval =\n\t\t\tWMI_PNO_MAX_SCHED_SCAN_PLAN_INT;\n\t\tar->hw->wiphy->max_sched_scan_plan_iterations =\n\t\t\tWMI_PNO_MAX_SCHED_SCAN_PLAN_ITRNS;\n\t\tar->hw->wiphy->features |= NL80211_FEATURE_ND_RANDOM_MAC_ADDR;\n\t}\n\n\tar->hw->vif_data_size = sizeof(struct ath10k_vif);\n\tar->hw->sta_data_size = sizeof(struct ath10k_sta);\n\tar->hw->txq_data_size = sizeof(struct ath10k_txq);\n\n\tar->hw->max_listen_interval = ATH10K_MAX_HW_LISTEN_INTERVAL;\n\n\tif (test_bit(WMI_SERVICE_BEACON_OFFLOAD, ar->wmi.svc_map)) {\n\t\tar->hw->wiphy->flags |= WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD;\n\n\t\t \n\t\tar->hw->wiphy->probe_resp_offload |=\n\t\t\tNL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS |\n\t\t\tNL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS2 |\n\t\t\tNL80211_PROBE_RESP_OFFLOAD_SUPPORT_P2P;\n\t}\n\n\tif (test_bit(WMI_SERVICE_TDLS, ar->wmi.svc_map) ||\n\t    test_bit(WMI_SERVICE_TDLS_EXPLICIT_MODE_ONLY, ar->wmi.svc_map)) {\n\t\tar->hw->wiphy->flags |= WIPHY_FLAG_SUPPORTS_TDLS;\n\t\tif (test_bit(WMI_SERVICE_TDLS_WIDER_BANDWIDTH, ar->wmi.svc_map))\n\t\t\tieee80211_hw_set(ar->hw, TDLS_WIDER_BW);\n\t}\n\n\tif (test_bit(WMI_SERVICE_TDLS_UAPSD_BUFFER_STA, ar->wmi.svc_map))\n\t\tieee80211_hw_set(ar->hw, SUPPORTS_TDLS_BUFFER_STA);\n\n\tif (ath10k_frame_mode == ATH10K_HW_TXRX_ETHERNET) {\n\t\tif (ar->wmi.vdev_param->tx_encap_type !=\n\t\t    WMI_VDEV_PARAM_UNSUPPORTED)\n\t\t\tieee80211_hw_set(ar->hw, SUPPORTS_TX_ENCAP_OFFLOAD);\n\t}\n\n\tar->hw->wiphy->flags |= WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;\n\tar->hw->wiphy->flags |= WIPHY_FLAG_HAS_CHANNEL_SWITCH;\n\tar->hw->wiphy->max_remain_on_channel_duration = 5000;\n\n\tar->hw->wiphy->flags |= WIPHY_FLAG_AP_UAPSD;\n\tar->hw->wiphy->features |= NL80211_FEATURE_AP_MODE_CHAN_WIDTH_CHANGE |\n\t\t\t\t   NL80211_FEATURE_AP_SCAN;\n\n\tar->hw->wiphy->max_ap_assoc_sta = ar->max_num_stations;\n\n\tret = ath10k_wow_init(ar);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to init wow: %d\\n\", ret);\n\t\tgoto err_free;\n\t}\n\n\twiphy_ext_feature_set(ar->hw->wiphy, NL80211_EXT_FEATURE_VHT_IBSS);\n\twiphy_ext_feature_set(ar->hw->wiphy,\n\t\t\t      NL80211_EXT_FEATURE_SET_SCAN_DWELL);\n\twiphy_ext_feature_set(ar->hw->wiphy, NL80211_EXT_FEATURE_AQL);\n\n\tif (test_bit(WMI_SERVICE_TX_DATA_ACK_RSSI, ar->wmi.svc_map) ||\n\t    test_bit(WMI_SERVICE_HTT_MGMT_TX_COMP_VALID_FLAGS, ar->wmi.svc_map))\n\t\twiphy_ext_feature_set(ar->hw->wiphy,\n\t\t\t\t      NL80211_EXT_FEATURE_ACK_SIGNAL_SUPPORT);\n\n\tif (ath10k_peer_stats_enabled(ar) ||\n\t    test_bit(WMI_SERVICE_REPORT_AIRTIME, ar->wmi.svc_map))\n\t\twiphy_ext_feature_set(ar->hw->wiphy,\n\t\t\t\t      NL80211_EXT_FEATURE_AIRTIME_FAIRNESS);\n\n\tif (test_bit(WMI_SERVICE_RTT_RESPONDER_ROLE, ar->wmi.svc_map))\n\t\twiphy_ext_feature_set(ar->hw->wiphy,\n\t\t\t\t      NL80211_EXT_FEATURE_ENABLE_FTM_RESPONDER);\n\n\tif (test_bit(WMI_SERVICE_TX_PWR_PER_PEER, ar->wmi.svc_map))\n\t\twiphy_ext_feature_set(ar->hw->wiphy,\n\t\t\t\t      NL80211_EXT_FEATURE_STA_TX_PWR);\n\n\tif (test_bit(WMI_SERVICE_PEER_TID_CONFIGS_SUPPORT, ar->wmi.svc_map)) {\n\t\tar->hw->wiphy->tid_config_support.vif |=\n\t\t\t\tBIT(NL80211_TID_CONFIG_ATTR_NOACK) |\n\t\t\t\tBIT(NL80211_TID_CONFIG_ATTR_RETRY_SHORT) |\n\t\t\t\tBIT(NL80211_TID_CONFIG_ATTR_RETRY_LONG) |\n\t\t\t\tBIT(NL80211_TID_CONFIG_ATTR_AMPDU_CTRL) |\n\t\t\t\tBIT(NL80211_TID_CONFIG_ATTR_TX_RATE) |\n\t\t\t\tBIT(NL80211_TID_CONFIG_ATTR_TX_RATE_TYPE);\n\n\t\tif (test_bit(WMI_SERVICE_EXT_PEER_TID_CONFIGS_SUPPORT,\n\t\t\t     ar->wmi.svc_map)) {\n\t\t\tar->hw->wiphy->tid_config_support.vif |=\n\t\t\t\tBIT(NL80211_TID_CONFIG_ATTR_RTSCTS_CTRL);\n\t\t}\n\n\t\tar->hw->wiphy->tid_config_support.peer =\n\t\t\t\tar->hw->wiphy->tid_config_support.vif;\n\t\tar->hw->wiphy->max_data_retry_count = ATH10K_MAX_RETRY_COUNT;\n\t} else {\n\t\tar->ops->set_tid_config = NULL;\n\t}\n\t \n\tar->hw->queues = IEEE80211_MAX_QUEUES;\n\n\t \n\tar->hw->offchannel_tx_hw_queue = IEEE80211_MAX_QUEUES - 1;\n\n\tswitch (ar->running_fw->fw_file.wmi_op_version) {\n\tcase ATH10K_FW_WMI_OP_VERSION_MAIN:\n\t\tar->hw->wiphy->iface_combinations = ath10k_if_comb;\n\t\tar->hw->wiphy->n_iface_combinations =\n\t\t\tARRAY_SIZE(ath10k_if_comb);\n\t\tar->hw->wiphy->interface_modes |= BIT(NL80211_IFTYPE_ADHOC);\n\t\tbreak;\n\tcase ATH10K_FW_WMI_OP_VERSION_TLV:\n\t\tif (test_bit(WMI_SERVICE_ADAPTIVE_OCS, ar->wmi.svc_map)) {\n\t\t\tar->hw->wiphy->iface_combinations =\n\t\t\t\tath10k_tlv_qcs_if_comb;\n\t\t\tar->hw->wiphy->n_iface_combinations =\n\t\t\t\tARRAY_SIZE(ath10k_tlv_qcs_if_comb);\n\t\t} else {\n\t\t\tar->hw->wiphy->iface_combinations = ath10k_tlv_if_comb;\n\t\t\tar->hw->wiphy->n_iface_combinations =\n\t\t\t\tARRAY_SIZE(ath10k_tlv_if_comb);\n\t\t}\n\t\tar->hw->wiphy->interface_modes |= BIT(NL80211_IFTYPE_ADHOC);\n\t\tbreak;\n\tcase ATH10K_FW_WMI_OP_VERSION_10_1:\n\tcase ATH10K_FW_WMI_OP_VERSION_10_2:\n\tcase ATH10K_FW_WMI_OP_VERSION_10_2_4:\n\t\tar->hw->wiphy->iface_combinations = ath10k_10x_if_comb;\n\t\tar->hw->wiphy->n_iface_combinations =\n\t\t\tARRAY_SIZE(ath10k_10x_if_comb);\n\t\tbreak;\n\tcase ATH10K_FW_WMI_OP_VERSION_10_4:\n\t\tar->hw->wiphy->iface_combinations = ath10k_10_4_if_comb;\n\t\tar->hw->wiphy->n_iface_combinations =\n\t\t\tARRAY_SIZE(ath10k_10_4_if_comb);\n\t\tif (test_bit(WMI_SERVICE_VDEV_DIFFERENT_BEACON_INTERVAL_SUPPORT,\n\t\t\t     ar->wmi.svc_map)) {\n\t\t\tar->hw->wiphy->iface_combinations =\n\t\t\t\tath10k_10_4_bcn_int_if_comb;\n\t\t\tar->hw->wiphy->n_iface_combinations =\n\t\t\t\tARRAY_SIZE(ath10k_10_4_bcn_int_if_comb);\n\t\t}\n\t\tbreak;\n\tcase ATH10K_FW_WMI_OP_VERSION_UNSET:\n\tcase ATH10K_FW_WMI_OP_VERSION_MAX:\n\t\tWARN_ON(1);\n\t\tret = -EINVAL;\n\t\tgoto err_free;\n\t}\n\n\tif (ar->hw_params.dynamic_sar_support)\n\t\tar->hw->wiphy->sar_capa = &ath10k_sar_capa;\n\n\tif (!test_bit(ATH10K_FLAG_RAW_MODE, &ar->dev_flags))\n\t\tar->hw->netdev_features = NETIF_F_HW_CSUM;\n\n\tif (IS_ENABLED(CONFIG_ATH10K_DFS_CERTIFIED)) {\n\t\t \n\t\tar->ath_common.debug_mask = ATH_DBG_DFS;\n\t\tar->dfs_detector = dfs_pattern_detector_init(&ar->ath_common,\n\t\t\t\t\t\t\t     NL80211_DFS_UNSET);\n\n\t\tif (!ar->dfs_detector)\n\t\t\tath10k_warn(ar, \"failed to initialise DFS pattern detector\\n\");\n\t}\n\n\tret = ath10k_mac_init_rd(ar);\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to derive regdom: %d\\n\", ret);\n\t\tgoto err_dfs_detector_exit;\n\t}\n\n\t \n\tif (!ar->hw_params.hw_ops->set_coverage_class)\n\t\tar->ops->set_coverage_class = NULL;\n\n\tret = ath_regd_init(&ar->ath_common.regulatory, ar->hw->wiphy,\n\t\t\t    ath10k_reg_notifier);\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to initialise regulatory: %i\\n\", ret);\n\t\tgoto err_dfs_detector_exit;\n\t}\n\n\tif (test_bit(WMI_SERVICE_SPOOF_MAC_SUPPORT, ar->wmi.svc_map)) {\n\t\tar->hw->wiphy->features |=\n\t\t\tNL80211_FEATURE_SCAN_RANDOM_MAC_ADDR;\n\t}\n\n\tar->hw->wiphy->cipher_suites = cipher_suites;\n\n\t \n\tif (!ar->hw_params.n_cipher_suites ||\n\t    ar->hw_params.n_cipher_suites > ARRAY_SIZE(cipher_suites)) {\n\t\tath10k_err(ar, \"invalid hw_params.n_cipher_suites %d\\n\",\n\t\t\t   ar->hw_params.n_cipher_suites);\n\t\tar->hw_params.n_cipher_suites = 8;\n\t}\n\tar->hw->wiphy->n_cipher_suites = ar->hw_params.n_cipher_suites;\n\n\twiphy_ext_feature_set(ar->hw->wiphy, NL80211_EXT_FEATURE_CQM_RSSI_LIST);\n\n\tar->hw->weight_multiplier = ATH10K_AIRTIME_WEIGHT_MULTIPLIER;\n\n\tret = ieee80211_register_hw(ar->hw);\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to register ieee80211: %d\\n\", ret);\n\t\tgoto err_dfs_detector_exit;\n\t}\n\n\tif (test_bit(WMI_SERVICE_PER_PACKET_SW_ENCRYPT, ar->wmi.svc_map)) {\n\t\tar->hw->wiphy->interface_modes |= BIT(NL80211_IFTYPE_AP_VLAN);\n\t\tar->hw->wiphy->software_iftypes |= BIT(NL80211_IFTYPE_AP_VLAN);\n\t}\n\n\tif (!ath_is_world_regd(&ar->ath_common.reg_world_copy) &&\n\t    !ath_is_world_regd(&ar->ath_common.regulatory)) {\n\t\tret = regulatory_hint(ar->hw->wiphy,\n\t\t\t\t      ar->ath_common.regulatory.alpha2);\n\t\tif (ret)\n\t\t\tgoto err_unregister;\n\t}\n\n\treturn 0;\n\nerr_unregister:\n\tieee80211_unregister_hw(ar->hw);\n\nerr_dfs_detector_exit:\n\tif (IS_ENABLED(CONFIG_ATH10K_DFS_CERTIFIED) && ar->dfs_detector)\n\t\tar->dfs_detector->exit(ar->dfs_detector);\n\nerr_free:\n\tkfree(ar->mac.sbands[NL80211_BAND_2GHZ].channels);\n\tkfree(ar->mac.sbands[NL80211_BAND_5GHZ].channels);\n\n\tSET_IEEE80211_DEV(ar->hw, NULL);\n\treturn ret;\n}\n\nvoid ath10k_mac_unregister(struct ath10k *ar)\n{\n\tieee80211_unregister_hw(ar->hw);\n\n\tif (IS_ENABLED(CONFIG_ATH10K_DFS_CERTIFIED) && ar->dfs_detector)\n\t\tar->dfs_detector->exit(ar->dfs_detector);\n\n\tkfree(ar->mac.sbands[NL80211_BAND_2GHZ].channels);\n\tkfree(ar->mac.sbands[NL80211_BAND_5GHZ].channels);\n\n\tSET_IEEE80211_DEV(ar->hw, NULL);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}