{
  "module_name": "hw.c",
  "hash_id": "72037c811f14a47c16bc6389449be07e722bd19d16d9b49880485f1de375d54d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath10k/hw.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/bitops.h>\n#include <linux/bitfield.h>\n#include \"core.h\"\n#include \"hw.h\"\n#include \"hif.h\"\n#include \"wmi-ops.h\"\n#include \"bmi.h\"\n#include \"rx_desc.h\"\n\nconst struct ath10k_hw_regs qca988x_regs = {\n\t.rtc_soc_base_address\t\t= 0x00004000,\n\t.rtc_wmac_base_address\t\t= 0x00005000,\n\t.soc_core_base_address\t\t= 0x00009000,\n\t.wlan_mac_base_address\t\t= 0x00020000,\n\t.ce_wrapper_base_address\t= 0x00057000,\n\t.ce0_base_address\t\t= 0x00057400,\n\t.ce1_base_address\t\t= 0x00057800,\n\t.ce2_base_address\t\t= 0x00057c00,\n\t.ce3_base_address\t\t= 0x00058000,\n\t.ce4_base_address\t\t= 0x00058400,\n\t.ce5_base_address\t\t= 0x00058800,\n\t.ce6_base_address\t\t= 0x00058c00,\n\t.ce7_base_address\t\t= 0x00059000,\n\t.soc_reset_control_si0_rst_mask\t= 0x00000001,\n\t.soc_reset_control_ce_rst_mask\t= 0x00040000,\n\t.soc_chip_id_address\t\t= 0x000000ec,\n\t.scratch_3_address\t\t= 0x00000030,\n\t.fw_indicator_address\t\t= 0x00009030,\n\t.pcie_local_base_address\t= 0x00080000,\n\t.ce_wrap_intr_sum_host_msi_lsb\t= 0x00000008,\n\t.ce_wrap_intr_sum_host_msi_mask\t= 0x0000ff00,\n\t.pcie_intr_fw_mask\t\t= 0x00000400,\n\t.pcie_intr_ce_mask_all\t\t= 0x0007f800,\n\t.pcie_intr_clr_address\t\t= 0x00000014,\n};\n\nconst struct ath10k_hw_regs qca6174_regs = {\n\t.rtc_soc_base_address\t\t\t= 0x00000800,\n\t.rtc_wmac_base_address\t\t\t= 0x00001000,\n\t.soc_core_base_address\t\t\t= 0x0003a000,\n\t.wlan_mac_base_address\t\t\t= 0x00010000,\n\t.ce_wrapper_base_address\t\t= 0x00034000,\n\t.ce0_base_address\t\t\t= 0x00034400,\n\t.ce1_base_address\t\t\t= 0x00034800,\n\t.ce2_base_address\t\t\t= 0x00034c00,\n\t.ce3_base_address\t\t\t= 0x00035000,\n\t.ce4_base_address\t\t\t= 0x00035400,\n\t.ce5_base_address\t\t\t= 0x00035800,\n\t.ce6_base_address\t\t\t= 0x00035c00,\n\t.ce7_base_address\t\t\t= 0x00036000,\n\t.soc_reset_control_si0_rst_mask\t\t= 0x00000000,\n\t.soc_reset_control_ce_rst_mask\t\t= 0x00000001,\n\t.soc_chip_id_address\t\t\t= 0x000000f0,\n\t.scratch_3_address\t\t\t= 0x00000028,\n\t.fw_indicator_address\t\t\t= 0x0003a028,\n\t.pcie_local_base_address\t\t= 0x00080000,\n\t.ce_wrap_intr_sum_host_msi_lsb\t\t= 0x00000008,\n\t.ce_wrap_intr_sum_host_msi_mask\t\t= 0x0000ff00,\n\t.pcie_intr_fw_mask\t\t\t= 0x00000400,\n\t.pcie_intr_ce_mask_all\t\t\t= 0x0007f800,\n\t.pcie_intr_clr_address\t\t\t= 0x00000014,\n\t.cpu_pll_init_address\t\t\t= 0x00404020,\n\t.cpu_speed_address\t\t\t= 0x00404024,\n\t.core_clk_div_address\t\t\t= 0x00404028,\n};\n\nconst struct ath10k_hw_regs qca99x0_regs = {\n\t.rtc_soc_base_address\t\t\t= 0x00080000,\n\t.rtc_wmac_base_address\t\t\t= 0x00000000,\n\t.soc_core_base_address\t\t\t= 0x00082000,\n\t.wlan_mac_base_address\t\t\t= 0x00030000,\n\t.ce_wrapper_base_address\t\t= 0x0004d000,\n\t.ce0_base_address\t\t\t= 0x0004a000,\n\t.ce1_base_address\t\t\t= 0x0004a400,\n\t.ce2_base_address\t\t\t= 0x0004a800,\n\t.ce3_base_address\t\t\t= 0x0004ac00,\n\t.ce4_base_address\t\t\t= 0x0004b000,\n\t.ce5_base_address\t\t\t= 0x0004b400,\n\t.ce6_base_address\t\t\t= 0x0004b800,\n\t.ce7_base_address\t\t\t= 0x0004bc00,\n\t \n\t.soc_reset_control_si0_rst_mask\t\t= 0x00000001,\n\t.soc_reset_control_ce_rst_mask\t\t= 0x00000100,\n\t.soc_chip_id_address\t\t\t= 0x000000ec,\n\t.scratch_3_address\t\t\t= 0x00040050,\n\t.fw_indicator_address\t\t\t= 0x00040050,\n\t.pcie_local_base_address\t\t= 0x00000000,\n\t.ce_wrap_intr_sum_host_msi_lsb\t\t= 0x0000000c,\n\t.ce_wrap_intr_sum_host_msi_mask\t\t= 0x00fff000,\n\t.pcie_intr_fw_mask\t\t\t= 0x00100000,\n\t.pcie_intr_ce_mask_all\t\t\t= 0x000fff00,\n\t.pcie_intr_clr_address\t\t\t= 0x00000010,\n};\n\nconst struct ath10k_hw_regs qca4019_regs = {\n\t.rtc_soc_base_address                   = 0x00080000,\n\t.soc_core_base_address                  = 0x00082000,\n\t.wlan_mac_base_address                  = 0x00030000,\n\t.ce_wrapper_base_address                = 0x0004d000,\n\t.ce0_base_address                       = 0x0004a000,\n\t.ce1_base_address                       = 0x0004a400,\n\t.ce2_base_address                       = 0x0004a800,\n\t.ce3_base_address                       = 0x0004ac00,\n\t.ce4_base_address                       = 0x0004b000,\n\t.ce5_base_address                       = 0x0004b400,\n\t.ce6_base_address                       = 0x0004b800,\n\t.ce7_base_address                       = 0x0004bc00,\n\t \n\t.soc_reset_control_si0_rst_mask         = 0x00000001,\n\t.soc_reset_control_ce_rst_mask          = 0x00000100,\n\t.soc_chip_id_address                    = 0x000000ec,\n\t.fw_indicator_address                   = 0x0004f00c,\n\t.ce_wrap_intr_sum_host_msi_lsb          = 0x0000000c,\n\t.ce_wrap_intr_sum_host_msi_mask         = 0x00fff000,\n\t.pcie_intr_fw_mask                      = 0x00100000,\n\t.pcie_intr_ce_mask_all                  = 0x000fff00,\n\t.pcie_intr_clr_address                  = 0x00000010,\n};\n\nconst struct ath10k_hw_values qca988x_values = {\n\t.rtc_state_val_on\t\t= 3,\n\t.ce_count\t\t\t= 8,\n\t.msi_assign_ce_max\t\t= 7,\n\t.num_target_ce_config_wlan\t= 7,\n\t.ce_desc_meta_data_mask\t\t= 0xFFFC,\n\t.ce_desc_meta_data_lsb\t\t= 2,\n};\n\nconst struct ath10k_hw_values qca6174_values = {\n\t.rtc_state_val_on\t\t= 3,\n\t.ce_count\t\t\t= 8,\n\t.msi_assign_ce_max\t\t= 7,\n\t.num_target_ce_config_wlan\t= 7,\n\t.ce_desc_meta_data_mask\t\t= 0xFFFC,\n\t.ce_desc_meta_data_lsb\t\t= 2,\n\t.rfkill_pin\t\t\t= 16,\n\t.rfkill_cfg\t\t\t= 0,\n\t.rfkill_on_level\t\t= 1,\n};\n\nconst struct ath10k_hw_values qca99x0_values = {\n\t.rtc_state_val_on\t\t= 7,\n\t.ce_count\t\t\t= 12,\n\t.msi_assign_ce_max\t\t= 12,\n\t.num_target_ce_config_wlan\t= 10,\n\t.ce_desc_meta_data_mask\t\t= 0xFFF0,\n\t.ce_desc_meta_data_lsb\t\t= 4,\n};\n\nconst struct ath10k_hw_values qca9888_values = {\n\t.rtc_state_val_on\t\t= 3,\n\t.ce_count\t\t\t= 12,\n\t.msi_assign_ce_max\t\t= 12,\n\t.num_target_ce_config_wlan\t= 10,\n\t.ce_desc_meta_data_mask\t\t= 0xFFF0,\n\t.ce_desc_meta_data_lsb\t\t= 4,\n};\n\nconst struct ath10k_hw_values qca4019_values = {\n\t.ce_count                       = 12,\n\t.num_target_ce_config_wlan      = 10,\n\t.ce_desc_meta_data_mask         = 0xFFF0,\n\t.ce_desc_meta_data_lsb          = 4,\n};\n\nconst struct ath10k_hw_regs wcn3990_regs = {\n\t.rtc_soc_base_address\t\t\t= 0x00000000,\n\t.rtc_wmac_base_address\t\t\t= 0x00000000,\n\t.soc_core_base_address\t\t\t= 0x00000000,\n\t.ce_wrapper_base_address\t\t= 0x0024C000,\n\t.ce0_base_address\t\t\t= 0x00240000,\n\t.ce1_base_address\t\t\t= 0x00241000,\n\t.ce2_base_address\t\t\t= 0x00242000,\n\t.ce3_base_address\t\t\t= 0x00243000,\n\t.ce4_base_address\t\t\t= 0x00244000,\n\t.ce5_base_address\t\t\t= 0x00245000,\n\t.ce6_base_address\t\t\t= 0x00246000,\n\t.ce7_base_address\t\t\t= 0x00247000,\n\t.ce8_base_address\t\t\t= 0x00248000,\n\t.ce9_base_address\t\t\t= 0x00249000,\n\t.ce10_base_address\t\t\t= 0x0024A000,\n\t.ce11_base_address\t\t\t= 0x0024B000,\n\t.soc_chip_id_address\t\t\t= 0x000000f0,\n\t.soc_reset_control_si0_rst_mask\t\t= 0x00000001,\n\t.soc_reset_control_ce_rst_mask\t\t= 0x00000100,\n\t.ce_wrap_intr_sum_host_msi_lsb\t\t= 0x0000000c,\n\t.ce_wrap_intr_sum_host_msi_mask\t\t= 0x00fff000,\n\t.pcie_intr_fw_mask\t\t\t= 0x00100000,\n};\n\nstatic struct ath10k_hw_ce_regs_addr_map wcn3990_src_ring = {\n\t.msb\t= 0x00000010,\n\t.lsb\t= 0x00000010,\n\t.mask\t= GENMASK(17, 17),\n};\n\nstatic struct ath10k_hw_ce_regs_addr_map wcn3990_dst_ring = {\n\t.msb\t= 0x00000012,\n\t.lsb\t= 0x00000012,\n\t.mask\t= GENMASK(18, 18),\n};\n\nstatic struct ath10k_hw_ce_regs_addr_map wcn3990_dmax = {\n\t.msb\t= 0x00000000,\n\t.lsb\t= 0x00000000,\n\t.mask\t= GENMASK(15, 0),\n};\n\nstatic struct ath10k_hw_ce_ctrl1 wcn3990_ctrl1 = {\n\t.addr\t\t= 0x00000018,\n\t.src_ring\t= &wcn3990_src_ring,\n\t.dst_ring\t= &wcn3990_dst_ring,\n\t.dmax\t\t= &wcn3990_dmax,\n};\n\nstatic struct ath10k_hw_ce_regs_addr_map wcn3990_host_ie_cc = {\n\t.mask\t= GENMASK(0, 0),\n};\n\nstatic struct ath10k_hw_ce_host_ie wcn3990_host_ie = {\n\t.copy_complete\t= &wcn3990_host_ie_cc,\n};\n\nstatic struct ath10k_hw_ce_host_wm_regs wcn3990_wm_reg = {\n\t.dstr_lmask\t= 0x00000010,\n\t.dstr_hmask\t= 0x00000008,\n\t.srcr_lmask\t= 0x00000004,\n\t.srcr_hmask\t= 0x00000002,\n\t.cc_mask\t= 0x00000001,\n\t.wm_mask\t= 0x0000001E,\n\t.addr\t\t= 0x00000030,\n};\n\nstatic struct ath10k_hw_ce_misc_regs wcn3990_misc_reg = {\n\t.axi_err\t= 0x00000100,\n\t.dstr_add_err\t= 0x00000200,\n\t.srcr_len_err\t= 0x00000100,\n\t.dstr_mlen_vio\t= 0x00000080,\n\t.dstr_overflow\t= 0x00000040,\n\t.srcr_overflow\t= 0x00000020,\n\t.err_mask\t= 0x000003E0,\n\t.addr\t\t= 0x00000038,\n};\n\nstatic struct ath10k_hw_ce_regs_addr_map wcn3990_src_wm_low = {\n\t.msb\t= 0x00000000,\n\t.lsb\t= 0x00000010,\n\t.mask\t= GENMASK(31, 16),\n};\n\nstatic struct ath10k_hw_ce_regs_addr_map wcn3990_src_wm_high = {\n\t.msb\t= 0x0000000f,\n\t.lsb\t= 0x00000000,\n\t.mask\t= GENMASK(15, 0),\n};\n\nstatic struct ath10k_hw_ce_dst_src_wm_regs wcn3990_wm_src_ring = {\n\t.addr\t\t= 0x0000004c,\n\t.low_rst\t= 0x00000000,\n\t.high_rst\t= 0x00000000,\n\t.wm_low\t\t= &wcn3990_src_wm_low,\n\t.wm_high\t= &wcn3990_src_wm_high,\n};\n\nstatic struct ath10k_hw_ce_regs_addr_map wcn3990_dst_wm_low = {\n\t.lsb\t= 0x00000010,\n\t.mask\t= GENMASK(31, 16),\n};\n\nstatic struct ath10k_hw_ce_regs_addr_map wcn3990_dst_wm_high = {\n\t.msb\t= 0x0000000f,\n\t.lsb\t= 0x00000000,\n\t.mask\t= GENMASK(15, 0),\n};\n\nstatic struct ath10k_hw_ce_dst_src_wm_regs wcn3990_wm_dst_ring = {\n\t.addr\t\t= 0x00000050,\n\t.low_rst\t= 0x00000000,\n\t.high_rst\t= 0x00000000,\n\t.wm_low\t\t= &wcn3990_dst_wm_low,\n\t.wm_high\t= &wcn3990_dst_wm_high,\n};\n\nstatic struct ath10k_hw_ce_ctrl1_upd wcn3990_ctrl1_upd = {\n\t.shift = 19,\n\t.mask = 0x00080000,\n\t.enable = 0x00000000,\n};\n\nconst struct ath10k_hw_ce_regs wcn3990_ce_regs = {\n\t.sr_base_addr_lo\t= 0x00000000,\n\t.sr_base_addr_hi\t= 0x00000004,\n\t.sr_size_addr\t\t= 0x00000008,\n\t.dr_base_addr_lo\t= 0x0000000c,\n\t.dr_base_addr_hi\t= 0x00000010,\n\t.dr_size_addr\t\t= 0x00000014,\n\t.misc_ie_addr\t\t= 0x00000034,\n\t.sr_wr_index_addr\t= 0x0000003c,\n\t.dst_wr_index_addr\t= 0x00000040,\n\t.current_srri_addr\t= 0x00000044,\n\t.current_drri_addr\t= 0x00000048,\n\t.ce_rri_low\t\t= 0x0024C004,\n\t.ce_rri_high\t\t= 0x0024C008,\n\t.host_ie_addr\t\t= 0x0000002c,\n\t.ctrl1_regs\t\t= &wcn3990_ctrl1,\n\t.host_ie\t\t= &wcn3990_host_ie,\n\t.wm_regs\t\t= &wcn3990_wm_reg,\n\t.misc_regs\t\t= &wcn3990_misc_reg,\n\t.wm_srcr\t\t= &wcn3990_wm_src_ring,\n\t.wm_dstr\t\t= &wcn3990_wm_dst_ring,\n\t.upd\t\t\t= &wcn3990_ctrl1_upd,\n};\n\nconst struct ath10k_hw_values wcn3990_values = {\n\t.rtc_state_val_on\t\t= 5,\n\t.ce_count\t\t\t= 12,\n\t.msi_assign_ce_max\t\t= 12,\n\t.num_target_ce_config_wlan\t= 12,\n\t.ce_desc_meta_data_mask\t\t= 0xFFF0,\n\t.ce_desc_meta_data_lsb\t\t= 4,\n};\n\nstatic struct ath10k_hw_ce_regs_addr_map qcax_src_ring = {\n\t.msb\t= 0x00000010,\n\t.lsb\t= 0x00000010,\n\t.mask\t= GENMASK(16, 16),\n};\n\nstatic struct ath10k_hw_ce_regs_addr_map qcax_dst_ring = {\n\t.msb\t= 0x00000011,\n\t.lsb\t= 0x00000011,\n\t.mask\t= GENMASK(17, 17),\n};\n\nstatic struct ath10k_hw_ce_regs_addr_map qcax_dmax = {\n\t.msb\t= 0x0000000f,\n\t.lsb\t= 0x00000000,\n\t.mask\t= GENMASK(15, 0),\n};\n\nstatic struct ath10k_hw_ce_ctrl1 qcax_ctrl1 = {\n\t.addr\t\t= 0x00000010,\n\t.hw_mask\t= 0x0007ffff,\n\t.sw_mask\t= 0x0007ffff,\n\t.hw_wr_mask\t= 0x00000000,\n\t.sw_wr_mask\t= 0x0007ffff,\n\t.reset_mask\t= 0xffffffff,\n\t.reset\t\t= 0x00000080,\n\t.src_ring\t= &qcax_src_ring,\n\t.dst_ring\t= &qcax_dst_ring,\n\t.dmax\t\t= &qcax_dmax,\n};\n\nstatic struct ath10k_hw_ce_regs_addr_map qcax_cmd_halt_status = {\n\t.msb\t= 0x00000003,\n\t.lsb\t= 0x00000003,\n\t.mask\t= GENMASK(3, 3),\n};\n\nstatic struct ath10k_hw_ce_cmd_halt qcax_cmd_halt = {\n\t.msb\t\t= 0x00000000,\n\t.mask\t\t= GENMASK(0, 0),\n\t.status_reset\t= 0x00000000,\n\t.status\t\t= &qcax_cmd_halt_status,\n};\n\nstatic struct ath10k_hw_ce_regs_addr_map qcax_host_ie_cc = {\n\t.msb\t= 0x00000000,\n\t.lsb\t= 0x00000000,\n\t.mask\t= GENMASK(0, 0),\n};\n\nstatic struct ath10k_hw_ce_host_ie qcax_host_ie = {\n\t.copy_complete_reset\t= 0x00000000,\n\t.copy_complete\t\t= &qcax_host_ie_cc,\n};\n\nstatic struct ath10k_hw_ce_host_wm_regs qcax_wm_reg = {\n\t.dstr_lmask\t= 0x00000010,\n\t.dstr_hmask\t= 0x00000008,\n\t.srcr_lmask\t= 0x00000004,\n\t.srcr_hmask\t= 0x00000002,\n\t.cc_mask\t= 0x00000001,\n\t.wm_mask\t= 0x0000001E,\n\t.addr\t\t= 0x00000030,\n};\n\nstatic struct ath10k_hw_ce_misc_regs qcax_misc_reg = {\n\t.axi_err\t= 0x00000400,\n\t.dstr_add_err\t= 0x00000200,\n\t.srcr_len_err\t= 0x00000100,\n\t.dstr_mlen_vio\t= 0x00000080,\n\t.dstr_overflow\t= 0x00000040,\n\t.srcr_overflow\t= 0x00000020,\n\t.err_mask\t= 0x000007E0,\n\t.addr\t\t= 0x00000038,\n};\n\nstatic struct ath10k_hw_ce_regs_addr_map qcax_src_wm_low = {\n\t.msb    = 0x0000001f,\n\t.lsb\t= 0x00000010,\n\t.mask\t= GENMASK(31, 16),\n};\n\nstatic struct ath10k_hw_ce_regs_addr_map qcax_src_wm_high = {\n\t.msb\t= 0x0000000f,\n\t.lsb\t= 0x00000000,\n\t.mask\t= GENMASK(15, 0),\n};\n\nstatic struct ath10k_hw_ce_dst_src_wm_regs qcax_wm_src_ring = {\n\t.addr\t\t= 0x0000004c,\n\t.low_rst\t= 0x00000000,\n\t.high_rst\t= 0x00000000,\n\t.wm_low\t\t= &qcax_src_wm_low,\n\t.wm_high        = &qcax_src_wm_high,\n};\n\nstatic struct ath10k_hw_ce_regs_addr_map qcax_dst_wm_low = {\n\t.lsb\t= 0x00000010,\n\t.mask\t= GENMASK(31, 16),\n};\n\nstatic struct ath10k_hw_ce_regs_addr_map qcax_dst_wm_high = {\n\t.msb\t= 0x0000000f,\n\t.lsb\t= 0x00000000,\n\t.mask\t= GENMASK(15, 0),\n};\n\nstatic struct ath10k_hw_ce_dst_src_wm_regs qcax_wm_dst_ring = {\n\t.addr\t\t= 0x00000050,\n\t.low_rst\t= 0x00000000,\n\t.high_rst\t= 0x00000000,\n\t.wm_low\t\t= &qcax_dst_wm_low,\n\t.wm_high\t= &qcax_dst_wm_high,\n};\n\nconst struct ath10k_hw_ce_regs qcax_ce_regs = {\n\t.sr_base_addr_lo\t= 0x00000000,\n\t.sr_size_addr\t\t= 0x00000004,\n\t.dr_base_addr_lo\t= 0x00000008,\n\t.dr_size_addr\t\t= 0x0000000c,\n\t.ce_cmd_addr\t\t= 0x00000018,\n\t.misc_ie_addr\t\t= 0x00000034,\n\t.sr_wr_index_addr\t= 0x0000003c,\n\t.dst_wr_index_addr\t= 0x00000040,\n\t.current_srri_addr\t= 0x00000044,\n\t.current_drri_addr\t= 0x00000048,\n\t.host_ie_addr\t\t= 0x0000002c,\n\t.ctrl1_regs\t\t= &qcax_ctrl1,\n\t.cmd_halt\t\t= &qcax_cmd_halt,\n\t.host_ie\t\t= &qcax_host_ie,\n\t.wm_regs\t\t= &qcax_wm_reg,\n\t.misc_regs\t\t= &qcax_misc_reg,\n\t.wm_srcr\t\t= &qcax_wm_src_ring,\n\t.wm_dstr                = &qcax_wm_dst_ring,\n};\n\nconst struct ath10k_hw_clk_params qca6174_clk[ATH10K_HW_REFCLK_COUNT] = {\n\t{\n\t\t.refclk = 48000000,\n\t\t.div = 0xe,\n\t\t.rnfrac = 0x2aaa8,\n\t\t.settle_time = 2400,\n\t\t.refdiv = 0,\n\t\t.outdiv = 1,\n\t},\n\t{\n\t\t.refclk = 19200000,\n\t\t.div = 0x24,\n\t\t.rnfrac = 0x2aaa8,\n\t\t.settle_time = 960,\n\t\t.refdiv = 0,\n\t\t.outdiv = 1,\n\t},\n\t{\n\t\t.refclk = 24000000,\n\t\t.div = 0x1d,\n\t\t.rnfrac = 0x15551,\n\t\t.settle_time = 1200,\n\t\t.refdiv = 0,\n\t\t.outdiv = 1,\n\t},\n\t{\n\t\t.refclk = 26000000,\n\t\t.div = 0x1b,\n\t\t.rnfrac = 0x4ec4,\n\t\t.settle_time = 1300,\n\t\t.refdiv = 0,\n\t\t.outdiv = 1,\n\t},\n\t{\n\t\t.refclk = 37400000,\n\t\t.div = 0x12,\n\t\t.rnfrac = 0x34b49,\n\t\t.settle_time = 1870,\n\t\t.refdiv = 0,\n\t\t.outdiv = 1,\n\t},\n\t{\n\t\t.refclk = 38400000,\n\t\t.div = 0x12,\n\t\t.rnfrac = 0x15551,\n\t\t.settle_time = 1920,\n\t\t.refdiv = 0,\n\t\t.outdiv = 1,\n\t},\n\t{\n\t\t.refclk = 40000000,\n\t\t.div = 0x12,\n\t\t.rnfrac = 0x26665,\n\t\t.settle_time = 2000,\n\t\t.refdiv = 0,\n\t\t.outdiv = 1,\n\t},\n\t{\n\t\t.refclk = 52000000,\n\t\t.div = 0x1b,\n\t\t.rnfrac = 0x4ec4,\n\t\t.settle_time = 2600,\n\t\t.refdiv = 0,\n\t\t.outdiv = 1,\n\t},\n};\n\nvoid ath10k_hw_fill_survey_time(struct ath10k *ar, struct survey_info *survey,\n\t\t\t\tu32 cc, u32 rcc, u32 cc_prev, u32 rcc_prev)\n{\n\tu32 cc_fix = 0;\n\tu32 rcc_fix = 0;\n\tenum ath10k_hw_cc_wraparound_type wraparound_type;\n\n\tsurvey->filled |= SURVEY_INFO_TIME |\n\t\t\t  SURVEY_INFO_TIME_BUSY;\n\n\twraparound_type = ar->hw_params.cc_wraparound_type;\n\n\tif (cc < cc_prev || rcc < rcc_prev) {\n\t\tswitch (wraparound_type) {\n\t\tcase ATH10K_HW_CC_WRAP_SHIFTED_ALL:\n\t\t\tif (cc < cc_prev) {\n\t\t\t\tcc_fix = 0x7fffffff;\n\t\t\t\tsurvey->filled &= ~SURVEY_INFO_TIME_BUSY;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ATH10K_HW_CC_WRAP_SHIFTED_EACH:\n\t\t\tif (cc < cc_prev)\n\t\t\t\tcc_fix = 0x7fffffff;\n\n\t\t\tif (rcc < rcc_prev)\n\t\t\t\trcc_fix = 0x7fffffff;\n\t\t\tbreak;\n\t\tcase ATH10K_HW_CC_WRAP_DISABLED:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcc -= cc_prev - cc_fix;\n\trcc -= rcc_prev - rcc_fix;\n\n\tsurvey->time = CCNT_TO_MSEC(ar, cc);\n\tsurvey->time_busy = CCNT_TO_MSEC(ar, rcc);\n}\n\n \nstatic void ath10k_hw_qca988x_set_coverage_class(struct ath10k *ar,\n\t\t\t\t\t\t s16 value)\n{\n\tu32 slottime_reg;\n\tu32 slottime;\n\tu32 timeout_reg;\n\tu32 ack_timeout;\n\tu32 cts_timeout;\n\tu32 phyclk_reg;\n\tu32 phyclk;\n\tu64 fw_dbglog_mask;\n\tu32 fw_dbglog_level;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\t \n\tif ((ar->state != ATH10K_STATE_ON) &&\n\t    (ar->state != ATH10K_STATE_RESTARTED)) {\n\t\tspin_lock_bh(&ar->data_lock);\n\t\t \n\t\tar->fw_coverage.coverage_class = value;\n\t\tspin_unlock_bh(&ar->data_lock);\n\t\tgoto unlock;\n\t}\n\n\t \n\tslottime_reg = ath10k_hif_read32(ar, WLAN_MAC_BASE_ADDRESS +\n\t\t\t\t\t     WAVE1_PCU_GBL_IFS_SLOT);\n\ttimeout_reg = ath10k_hif_read32(ar, WLAN_MAC_BASE_ADDRESS +\n\t\t\t\t\t    WAVE1_PCU_ACK_CTS_TIMEOUT);\n\tphyclk_reg = ath10k_hif_read32(ar, WLAN_MAC_BASE_ADDRESS +\n\t\t\t\t\t   WAVE1_PHYCLK);\n\tphyclk = MS(phyclk_reg, WAVE1_PHYCLK_USEC) + 1;\n\n\tif (value < 0)\n\t\tvalue = ar->fw_coverage.coverage_class;\n\n\t \n\tif (value == ar->fw_coverage.coverage_class &&\n\t    slottime_reg == ar->fw_coverage.reg_slottime_conf &&\n\t    timeout_reg == ar->fw_coverage.reg_ack_cts_timeout_conf &&\n\t    phyclk_reg == ar->fw_coverage.reg_phyclk)\n\t\tgoto unlock;\n\n\t \n\tif (slottime_reg != ar->fw_coverage.reg_slottime_conf)\n\t\tar->fw_coverage.reg_slottime_orig = slottime_reg;\n\tif (timeout_reg != ar->fw_coverage.reg_ack_cts_timeout_conf)\n\t\tar->fw_coverage.reg_ack_cts_timeout_orig = timeout_reg;\n\tar->fw_coverage.reg_phyclk = phyclk_reg;\n\n\t \n\tslottime_reg = ar->fw_coverage.reg_slottime_orig;\n\ttimeout_reg = ar->fw_coverage.reg_ack_cts_timeout_orig;\n\n\t \n\tif (slottime_reg % phyclk) {\n\t\tath10k_warn(ar,\n\t\t\t    \"failed to set coverage class: expected integer microsecond value in register\\n\");\n\n\t\tgoto store_regs;\n\t}\n\n\tslottime = MS(slottime_reg, WAVE1_PCU_GBL_IFS_SLOT);\n\tslottime = slottime / phyclk;\n\tif (slottime != 9 && slottime != 20) {\n\t\tath10k_warn(ar,\n\t\t\t    \"failed to set coverage class: expected slot time of 9 or 20us in HW register. It is %uus.\\n\",\n\t\t\t    slottime);\n\n\t\tgoto store_regs;\n\t}\n\n\t \n\n\tslottime = MS(slottime_reg, WAVE1_PCU_GBL_IFS_SLOT);\n\tslottime += value * 3 * phyclk;\n\tslottime = min_t(u32, slottime, WAVE1_PCU_GBL_IFS_SLOT_MAX);\n\tslottime = SM(slottime, WAVE1_PCU_GBL_IFS_SLOT);\n\tslottime_reg = (slottime_reg & ~WAVE1_PCU_GBL_IFS_SLOT_MASK) | slottime;\n\n\t \n\tack_timeout = MS(timeout_reg, WAVE1_PCU_ACK_CTS_TIMEOUT_ACK);\n\tack_timeout += 3 * value * phyclk;\n\tack_timeout = min_t(u32, ack_timeout, WAVE1_PCU_ACK_CTS_TIMEOUT_MAX);\n\tack_timeout = SM(ack_timeout, WAVE1_PCU_ACK_CTS_TIMEOUT_ACK);\n\n\t \n\tcts_timeout = MS(timeout_reg, WAVE1_PCU_ACK_CTS_TIMEOUT_CTS);\n\tcts_timeout += 3 * value * phyclk;\n\tcts_timeout = min_t(u32, cts_timeout, WAVE1_PCU_ACK_CTS_TIMEOUT_MAX);\n\tcts_timeout = SM(cts_timeout, WAVE1_PCU_ACK_CTS_TIMEOUT_CTS);\n\n\ttimeout_reg = ack_timeout | cts_timeout;\n\n\tath10k_hif_write32(ar,\n\t\t\t   WLAN_MAC_BASE_ADDRESS + WAVE1_PCU_GBL_IFS_SLOT,\n\t\t\t   slottime_reg);\n\tath10k_hif_write32(ar,\n\t\t\t   WLAN_MAC_BASE_ADDRESS + WAVE1_PCU_ACK_CTS_TIMEOUT,\n\t\t\t   timeout_reg);\n\n\t \n\tfw_dbglog_mask = ath10k_debug_get_fw_dbglog_mask(ar);\n\tfw_dbglog_level = ath10k_debug_get_fw_dbglog_level(ar);\n\n\tif (value > 0) {\n\t\tif (fw_dbglog_level > ATH10K_DBGLOG_LEVEL_WARN)\n\t\t\tfw_dbglog_level = ATH10K_DBGLOG_LEVEL_WARN;\n\t\tfw_dbglog_mask = ~0;\n\t}\n\n\tath10k_wmi_dbglog_cfg(ar, fw_dbglog_mask, fw_dbglog_level);\n\nstore_regs:\n\t \n\tspin_lock_bh(&ar->data_lock);\n\tar->fw_coverage.coverage_class = value;\n\tspin_unlock_bh(&ar->data_lock);\n\n\tar->fw_coverage.reg_slottime_conf = slottime_reg;\n\tar->fw_coverage.reg_ack_cts_timeout_conf = timeout_reg;\n\nunlock:\n\tmutex_unlock(&ar->conf_mutex);\n}\n\n \nstatic int ath10k_hw_qca6174_enable_pll_clock(struct ath10k *ar)\n{\n\tint ret, wait_limit;\n\tu32 clk_div_addr, pll_init_addr, speed_addr;\n\tu32 addr, reg_val, mem_val;\n\tstruct ath10k_hw_params *hw;\n\tconst struct ath10k_hw_clk_params *hw_clk;\n\n\thw = &ar->hw_params;\n\n\tif (ar->regs->core_clk_div_address == 0 ||\n\t    ar->regs->cpu_pll_init_address == 0 ||\n\t    ar->regs->cpu_speed_address == 0)\n\t\treturn -EINVAL;\n\n\tclk_div_addr = ar->regs->core_clk_div_address;\n\tpll_init_addr = ar->regs->cpu_pll_init_address;\n\tspeed_addr = ar->regs->cpu_speed_address;\n\n\t \n\taddr = (RTC_SOC_BASE_ADDRESS | EFUSE_OFFSET);\n\tret = ath10k_bmi_read_soc_reg(ar, addr, &reg_val);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\t \n\tif (MS(reg_val, EFUSE_XTAL_SEL) > ATH10K_HW_REFCLK_COUNT)\n\t\treturn -EINVAL;\n\n\thw_clk = &hw->hw_clk[MS(reg_val, EFUSE_XTAL_SEL)];\n\n\t \n\taddr = (RTC_SOC_BASE_ADDRESS | BB_PLL_CONFIG_OFFSET);\n\tret = ath10k_bmi_read_soc_reg(ar, addr, &reg_val);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\treg_val &= ~(BB_PLL_CONFIG_FRAC_MASK | BB_PLL_CONFIG_OUTDIV_MASK);\n\treg_val |= (SM(hw_clk->rnfrac, BB_PLL_CONFIG_FRAC) |\n\t\t    SM(hw_clk->outdiv, BB_PLL_CONFIG_OUTDIV));\n\tret = ath10k_bmi_write_soc_reg(ar, addr, reg_val);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\t \n\taddr = (RTC_WMAC_BASE_ADDRESS | WLAN_PLL_SETTLE_OFFSET);\n\tret = ath10k_bmi_read_soc_reg(ar, addr, &reg_val);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\treg_val &= ~WLAN_PLL_SETTLE_TIME_MASK;\n\treg_val |= SM(hw_clk->settle_time, WLAN_PLL_SETTLE_TIME);\n\tret = ath10k_bmi_write_soc_reg(ar, addr, reg_val);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\t \n\taddr = (RTC_SOC_BASE_ADDRESS | SOC_CORE_CLK_CTRL_OFFSET);\n\tret = ath10k_bmi_read_soc_reg(ar, addr, &reg_val);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\treg_val &= ~SOC_CORE_CLK_CTRL_DIV_MASK;\n\treg_val |= SM(1, SOC_CORE_CLK_CTRL_DIV);\n\tret = ath10k_bmi_write_soc_reg(ar, addr, reg_val);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\t \n\tmem_val = 1;\n\tret = ath10k_bmi_write_memory(ar, clk_div_addr, &mem_val,\n\t\t\t\t      sizeof(mem_val));\n\tif (ret)\n\t\treturn -EINVAL;\n\n\t \n\taddr = (RTC_WMAC_BASE_ADDRESS | WLAN_PLL_CONTROL_OFFSET);\n\tret = ath10k_bmi_read_soc_reg(ar, addr, &reg_val);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\treg_val |= (SM(hw_clk->refdiv, WLAN_PLL_CONTROL_REFDIV) |\n\t\t    SM(hw_clk->div, WLAN_PLL_CONTROL_DIV) |\n\t\t    SM(1, WLAN_PLL_CONTROL_NOPWD));\n\tret = ath10k_bmi_write_soc_reg(ar, addr, reg_val);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\t \n\twait_limit = 100000;\n\taddr = (RTC_WMAC_BASE_ADDRESS | RTC_SYNC_STATUS_OFFSET);\n\tdo {\n\t\tret = ath10k_bmi_read_soc_reg(ar, addr, &reg_val);\n\t\tif (ret)\n\t\t\treturn -EINVAL;\n\n\t\tif (!MS(reg_val, RTC_SYNC_STATUS_PLL_CHANGING))\n\t\t\tbreak;\n\n\t\twait_limit--;\n\t\tudelay(10);\n\n\t} while (wait_limit > 0);\n\n\tif (MS(reg_val, RTC_SYNC_STATUS_PLL_CHANGING))\n\t\treturn -EINVAL;\n\n\t \n\taddr = (RTC_WMAC_BASE_ADDRESS | WLAN_PLL_CONTROL_OFFSET);\n\tret = ath10k_bmi_read_soc_reg(ar, addr, &reg_val);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\treg_val &= ~WLAN_PLL_CONTROL_BYPASS_MASK;\n\treg_val |= SM(0, WLAN_PLL_CONTROL_BYPASS);\n\tret = ath10k_bmi_write_soc_reg(ar, addr, reg_val);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\t \n\twait_limit = 100000;\n\taddr = (RTC_WMAC_BASE_ADDRESS | RTC_SYNC_STATUS_OFFSET);\n\tdo {\n\t\tret = ath10k_bmi_read_soc_reg(ar, addr, &reg_val);\n\t\tif (ret)\n\t\t\treturn -EINVAL;\n\n\t\tif (!MS(reg_val, RTC_SYNC_STATUS_PLL_CHANGING))\n\t\t\tbreak;\n\n\t\twait_limit--;\n\t\tudelay(10);\n\n\t} while (wait_limit > 0);\n\n\tif (MS(reg_val, RTC_SYNC_STATUS_PLL_CHANGING))\n\t\treturn -EINVAL;\n\n\t \n\taddr = (RTC_SOC_BASE_ADDRESS | SOC_CPU_CLOCK_OFFSET);\n\tret = ath10k_bmi_read_soc_reg(ar, addr, &reg_val);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\treg_val &= ~SOC_CPU_CLOCK_STANDARD_MASK;\n\treg_val |= SM(1, SOC_CPU_CLOCK_STANDARD);\n\tret = ath10k_bmi_write_soc_reg(ar, addr, reg_val);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\t \n\taddr = (RTC_WMAC_BASE_ADDRESS | WLAN_PLL_CONTROL_OFFSET);\n\tret = ath10k_bmi_read_soc_reg(ar, addr, &reg_val);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\treg_val &= ~WLAN_PLL_CONTROL_NOPWD_MASK;\n\tret = ath10k_bmi_write_soc_reg(ar, addr, reg_val);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\t \n\tmem_val = 1;\n\tret = ath10k_bmi_write_memory(ar, pll_init_addr, &mem_val,\n\t\t\t\t      sizeof(mem_val));\n\tif (ret)\n\t\treturn -EINVAL;\n\n\t \n\tret = ath10k_bmi_write_memory(ar, speed_addr, &hw->target_cpu_freq,\n\t\t\t\t      sizeof(hw->target_cpu_freq));\n\tif (ret)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic void ath10k_hw_map_target_mem(struct ath10k *ar, u32 msb)\n{\n\tu32 address = SOC_CORE_BASE_ADDRESS + FW_RAM_CONFIG_ADDRESS;\n\n\tath10k_hif_write32(ar, address, msb);\n}\n\n \nstatic int ath10k_hw_diag_segment_msb_download(struct ath10k *ar,\n\t\t\t\t\t       const void *buffer,\n\t\t\t\t\t       u32 address,\n\t\t\t\t\t       u32 length)\n{\n\tu32 addr = address & REGION_ACCESS_SIZE_MASK;\n\tint ret, remain_size, size;\n\tconst u8 *buf;\n\n\tath10k_hw_map_target_mem(ar, CPU_ADDR_MSB_REGION_VAL(address));\n\n\tif (addr + length > REGION_ACCESS_SIZE_LIMIT) {\n\t\tsize = REGION_ACCESS_SIZE_LIMIT - addr;\n\t\tremain_size = length - size;\n\n\t\tret = ath10k_hif_diag_write(ar, address, buffer, size);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar,\n\t\t\t\t    \"failed to download the first %d bytes segment to address:0x%x: %d\\n\",\n\t\t\t\t    size, address, ret);\n\t\t\tgoto done;\n\t\t}\n\n\t\t \n\t\tath10k_hw_map_target_mem(ar,\n\t\t\t\t\t CPU_ADDR_MSB_REGION_VAL(address) + 1);\n\t\tbuf = buffer +  size;\n\t\tret = ath10k_hif_diag_write(ar,\n\t\t\t\t\t    address & ~REGION_ACCESS_SIZE_MASK,\n\t\t\t\t\t    buf, remain_size);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar,\n\t\t\t\t    \"failed to download the second %d bytes segment to address:0x%x: %d\\n\",\n\t\t\t\t    remain_size,\n\t\t\t\t    address & ~REGION_ACCESS_SIZE_MASK,\n\t\t\t\t    ret);\n\t\t\tgoto done;\n\t\t}\n\t} else {\n\t\tret = ath10k_hif_diag_write(ar, address, buffer, length);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar,\n\t\t\t\t    \"failed to download the only %d bytes segment to address:0x%x: %d\\n\",\n\t\t\t\t    length, address, ret);\n\t\t\tgoto done;\n\t\t}\n\t}\n\ndone:\n\t \n\tath10k_hw_map_target_mem(ar,\n\t\t\t\t CPU_ADDR_MSB_REGION_VAL(DRAM_BASE_ADDRESS));\n\treturn ret;\n}\n\nstatic int ath10k_hw_diag_segment_download(struct ath10k *ar,\n\t\t\t\t\t   const void *buffer,\n\t\t\t\t\t   u32 address,\n\t\t\t\t\t   u32 length)\n{\n\tif (address >= DRAM_BASE_ADDRESS + REGION_ACCESS_SIZE_LIMIT)\n\t\t \n\t\treturn ath10k_hw_diag_segment_msb_download(ar, buffer,\n\t\t\t\t\t\t\t   address, length);\n\telse\n\t\treturn ath10k_hif_diag_write(ar, address, buffer, length);\n}\n\nint ath10k_hw_diag_fast_download(struct ath10k *ar,\n\t\t\t\t u32 address,\n\t\t\t\t const void *buffer,\n\t\t\t\t u32 length)\n{\n\tconst u8 *buf = buffer;\n\tbool sgmt_end = false;\n\tu32 base_addr = 0;\n\tu32 base_len = 0;\n\tu32 left = 0;\n\tstruct bmi_segmented_file_header *hdr;\n\tstruct bmi_segmented_metadata *metadata;\n\tint ret = 0;\n\n\tif (length < sizeof(*hdr))\n\t\treturn -EINVAL;\n\n\t \n\thdr = (struct bmi_segmented_file_header *)buf;\n\tif (__le32_to_cpu(hdr->magic_num) != BMI_SGMTFILE_MAGIC_NUM) {\n\t\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t\t   \"Not a supported firmware, magic_num:0x%x\\n\",\n\t\t\t   hdr->magic_num);\n\t\treturn -EINVAL;\n\t}\n\n\tif (hdr->file_flags != 0) {\n\t\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t\t   \"Not a supported firmware, file_flags:0x%x\\n\",\n\t\t\t   hdr->file_flags);\n\t\treturn -EINVAL;\n\t}\n\n\tmetadata = (struct bmi_segmented_metadata *)hdr->data;\n\tleft = length - sizeof(*hdr);\n\n\twhile (left > 0) {\n\t\tif (left < sizeof(*metadata)) {\n\t\t\tath10k_warn(ar, \"firmware segment is truncated: %d\\n\",\n\t\t\t\t    left);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tbase_addr = __le32_to_cpu(metadata->addr);\n\t\tbase_len = __le32_to_cpu(metadata->length);\n\t\tbuf = metadata->data;\n\t\tleft -= sizeof(*metadata);\n\n\t\tswitch (base_len) {\n\t\tcase BMI_SGMTFILE_BEGINADDR:\n\t\t\t \n\t\t\tret = ath10k_bmi_set_start(ar, base_addr);\n\t\t\tbase_len = 0;\n\t\t\tbreak;\n\t\tcase BMI_SGMTFILE_DONE:\n\t\t\t \n\t\t\tbase_len = 0;\n\t\t\tsgmt_end = true;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\tcase BMI_SGMTFILE_BDDATA:\n\t\tcase BMI_SGMTFILE_EXEC:\n\t\t\tath10k_warn(ar,\n\t\t\t\t    \"firmware has unsupported segment:%d\\n\",\n\t\t\t\t    base_len);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (base_len > left) {\n\t\t\t\t \n\t\t\t\tath10k_warn(ar,\n\t\t\t\t\t    \"firmware has invalid segment length, %d > %d\\n\",\n\t\t\t\t\t    base_len, left);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tret = ath10k_hw_diag_segment_download(ar,\n\t\t\t\t\t\t\t      buf,\n\t\t\t\t\t\t\t      base_addr,\n\t\t\t\t\t\t\t      base_len);\n\n\t\t\tif (ret)\n\t\t\t\tath10k_warn(ar,\n\t\t\t\t\t    \"failed to download firmware via diag interface:%d\\n\",\n\t\t\t\t\t    ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ret || sgmt_end)\n\t\t\tbreak;\n\n\t\tmetadata = (struct bmi_segmented_metadata *)(buf + base_len);\n\t\tleft -= base_len;\n\t}\n\n\tif (ret == 0)\n\t\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t\t   \"boot firmware fast diag download successfully.\\n\");\n\treturn ret;\n}\n\nstatic int ath10k_htt_tx_rssi_enable(struct htt_resp *resp)\n{\n\treturn (resp->data_tx_completion.flags2 & HTT_TX_CMPL_FLAG_DATA_RSSI);\n}\n\nstatic int ath10k_htt_tx_rssi_enable_wcn3990(struct htt_resp *resp)\n{\n\treturn (resp->data_tx_completion.flags2 &\n\t\tHTT_TX_DATA_RSSI_ENABLE_WCN3990);\n}\n\nstatic int ath10k_get_htt_tx_data_rssi_pad(struct htt_resp *resp)\n{\n\tstruct htt_data_tx_completion_ext extd;\n\tint pad_bytes = 0;\n\n\tif (resp->data_tx_completion.flags2 & HTT_TX_DATA_APPEND_RETRIES)\n\t\tpad_bytes += sizeof(extd.a_retries) /\n\t\t\t     sizeof(extd.msdus_rssi[0]);\n\n\tif (resp->data_tx_completion.flags2 & HTT_TX_DATA_APPEND_TIMESTAMP)\n\t\tpad_bytes += sizeof(extd.t_stamp) / sizeof(extd.msdus_rssi[0]);\n\n\treturn pad_bytes;\n}\n\nconst struct ath10k_hw_ops qca988x_ops = {\n\t.set_coverage_class = ath10k_hw_qca988x_set_coverage_class,\n\t.is_rssi_enable = ath10k_htt_tx_rssi_enable,\n};\n\nconst struct ath10k_hw_ops qca99x0_ops = {\n\t.is_rssi_enable = ath10k_htt_tx_rssi_enable,\n};\n\nconst struct ath10k_hw_ops qca6174_ops = {\n\t.set_coverage_class = ath10k_hw_qca988x_set_coverage_class,\n\t.enable_pll_clk = ath10k_hw_qca6174_enable_pll_clock,\n\t.is_rssi_enable = ath10k_htt_tx_rssi_enable,\n};\n\nconst struct ath10k_hw_ops qca6174_sdio_ops = {\n\t.enable_pll_clk = ath10k_hw_qca6174_enable_pll_clock,\n};\n\nconst struct ath10k_hw_ops wcn3990_ops = {\n\t.tx_data_rssi_pad_bytes = ath10k_get_htt_tx_data_rssi_pad,\n\t.is_rssi_enable = ath10k_htt_tx_rssi_enable_wcn3990,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}