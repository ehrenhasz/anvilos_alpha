{
  "module_name": "htc.c",
  "hash_id": "05352a3fb50c917c30f3cfda2ead7fe5245fafbaaab791f39e22ca8b57237231",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath10k/htc.c",
  "human_readable_source": "\n \n\n#include \"core.h\"\n#include \"hif.h\"\n#include \"debug.h\"\n\n \n \n \n\nstatic void ath10k_htc_control_tx_complete(struct ath10k *ar,\n\t\t\t\t\t   struct sk_buff *skb)\n{\n\tkfree_skb(skb);\n}\n\nstatic struct sk_buff *ath10k_htc_build_tx_ctrl_skb(void *ar)\n{\n\tstruct sk_buff *skb;\n\tstruct ath10k_skb_cb *skb_cb;\n\n\tskb = dev_alloc_skb(ATH10K_HTC_CONTROL_BUFFER_SIZE);\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, 20);  \n\tWARN_ONCE((unsigned long)skb->data & 3, \"unaligned skb\");\n\n\tskb_cb = ATH10K_SKB_CB(skb);\n\tmemset(skb_cb, 0, sizeof(*skb_cb));\n\n\tath10k_dbg(ar, ATH10K_DBG_HTC, \"%s: skb %pK\\n\", __func__, skb);\n\treturn skb;\n}\n\nstatic inline void ath10k_htc_restore_tx_skb(struct ath10k_htc *htc,\n\t\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct ath10k_skb_cb *skb_cb = ATH10K_SKB_CB(skb);\n\n\tif (htc->ar->bus_param.dev_type != ATH10K_DEV_TYPE_HL)\n\t\tdma_unmap_single(htc->ar->dev, skb_cb->paddr, skb->len, DMA_TO_DEVICE);\n\tskb_pull(skb, sizeof(struct ath10k_htc_hdr));\n}\n\nvoid ath10k_htc_notify_tx_completion(struct ath10k_htc_ep *ep,\n\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct ath10k *ar = ep->htc->ar;\n\tstruct ath10k_htc_hdr *hdr;\n\n\tath10k_dbg(ar, ATH10K_DBG_HTC, \"%s: ep %d skb %pK\\n\", __func__,\n\t\t   ep->eid, skb);\n\n\t \n\tif (ar->hw_params.delay_unmap_buffer &&\n\t    ep->ul_pipe_id == 3)\n\t\tmdelay(2);\n\n\thdr = (struct ath10k_htc_hdr *)skb->data;\n\tath10k_htc_restore_tx_skb(ep->htc, skb);\n\n\tif (!ep->ep_ops.ep_tx_complete) {\n\t\tath10k_warn(ar, \"no tx handler for eid %d\\n\", ep->eid);\n\t\tdev_kfree_skb_any(skb);\n\t\treturn;\n\t}\n\n\tif (hdr->flags & ATH10K_HTC_FLAG_SEND_BUNDLE) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn;\n\t}\n\n\tep->ep_ops.ep_tx_complete(ep->htc->ar, skb);\n}\nEXPORT_SYMBOL(ath10k_htc_notify_tx_completion);\n\nstatic void ath10k_htc_prepare_tx_skb(struct ath10k_htc_ep *ep,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct ath10k_htc_hdr *hdr;\n\n\thdr = (struct ath10k_htc_hdr *)skb->data;\n\tmemset(hdr, 0, sizeof(struct ath10k_htc_hdr));\n\n\thdr->eid = ep->eid;\n\thdr->len = __cpu_to_le16(skb->len - sizeof(*hdr));\n\thdr->flags = 0;\n\tif (ep->tx_credit_flow_enabled && !ep->bundle_tx)\n\t\thdr->flags |= ATH10K_HTC_FLAG_NEED_CREDIT_UPDATE;\n\n\tspin_lock_bh(&ep->htc->tx_lock);\n\thdr->seq_no = ep->seq_no++;\n\tspin_unlock_bh(&ep->htc->tx_lock);\n}\n\nstatic int ath10k_htc_consume_credit(struct ath10k_htc_ep *ep,\n\t\t\t\t     unsigned int len,\n\t\t\t\t     bool consume)\n{\n\tstruct ath10k_htc *htc = ep->htc;\n\tstruct ath10k *ar = htc->ar;\n\tenum ath10k_htc_ep_id eid = ep->eid;\n\tint credits, ret = 0;\n\n\tif (!ep->tx_credit_flow_enabled)\n\t\treturn 0;\n\n\tcredits = DIV_ROUND_UP(len, ep->tx_credit_size);\n\tspin_lock_bh(&htc->tx_lock);\n\n\tif (ep->tx_credits < credits) {\n\t\tath10k_dbg(ar, ATH10K_DBG_HTC,\n\t\t\t   \"htc insufficient credits ep %d required %d available %d consume %d\\n\",\n\t\t\t   eid, credits, ep->tx_credits, consume);\n\t\tret = -EAGAIN;\n\t\tgoto unlock;\n\t}\n\n\tif (consume) {\n\t\tep->tx_credits -= credits;\n\t\tath10k_dbg(ar, ATH10K_DBG_HTC,\n\t\t\t   \"htc ep %d consumed %d credits total %d\\n\",\n\t\t\t   eid, credits, ep->tx_credits);\n\t}\n\nunlock:\n\tspin_unlock_bh(&htc->tx_lock);\n\treturn ret;\n}\n\nstatic void ath10k_htc_release_credit(struct ath10k_htc_ep *ep, unsigned int len)\n{\n\tstruct ath10k_htc *htc = ep->htc;\n\tstruct ath10k *ar = htc->ar;\n\tenum ath10k_htc_ep_id eid = ep->eid;\n\tint credits;\n\n\tif (!ep->tx_credit_flow_enabled)\n\t\treturn;\n\n\tcredits = DIV_ROUND_UP(len, ep->tx_credit_size);\n\tspin_lock_bh(&htc->tx_lock);\n\tep->tx_credits += credits;\n\tath10k_dbg(ar, ATH10K_DBG_HTC,\n\t\t   \"htc ep %d reverted %d credits back total %d\\n\",\n\t\t   eid, credits, ep->tx_credits);\n\tspin_unlock_bh(&htc->tx_lock);\n\n\tif (ep->ep_ops.ep_tx_credits)\n\t\tep->ep_ops.ep_tx_credits(htc->ar);\n}\n\nint ath10k_htc_send(struct ath10k_htc *htc,\n\t\t    enum ath10k_htc_ep_id eid,\n\t\t    struct sk_buff *skb)\n{\n\tstruct ath10k *ar = htc->ar;\n\tstruct ath10k_htc_ep *ep = &htc->endpoint[eid];\n\tstruct ath10k_skb_cb *skb_cb = ATH10K_SKB_CB(skb);\n\tstruct ath10k_hif_sg_item sg_item;\n\tstruct device *dev = htc->ar->dev;\n\tint ret;\n\tunsigned int skb_len;\n\n\tif (htc->ar->state == ATH10K_STATE_WEDGED)\n\t\treturn -ECOMM;\n\n\tif (eid >= ATH10K_HTC_EP_COUNT) {\n\t\tath10k_warn(ar, \"Invalid endpoint id: %d\\n\", eid);\n\t\treturn -ENOENT;\n\t}\n\n\tskb_push(skb, sizeof(struct ath10k_htc_hdr));\n\n\tskb_len = skb->len;\n\tret = ath10k_htc_consume_credit(ep, skb_len, true);\n\tif (ret)\n\t\tgoto err_pull;\n\n\tath10k_htc_prepare_tx_skb(ep, skb);\n\n\tskb_cb->eid = eid;\n\tif (ar->bus_param.dev_type != ATH10K_DEV_TYPE_HL) {\n\t\tskb_cb->paddr = dma_map_single(dev, skb->data, skb->len,\n\t\t\t\t\t       DMA_TO_DEVICE);\n\t\tret = dma_mapping_error(dev, skb_cb->paddr);\n\t\tif (ret) {\n\t\t\tret = -EIO;\n\t\t\tgoto err_credits;\n\t\t}\n\t}\n\n\tsg_item.transfer_id = ep->eid;\n\tsg_item.transfer_context = skb;\n\tsg_item.vaddr = skb->data;\n\tsg_item.paddr = skb_cb->paddr;\n\tsg_item.len = skb->len;\n\n\tret = ath10k_hif_tx_sg(htc->ar, ep->ul_pipe_id, &sg_item, 1);\n\tif (ret)\n\t\tgoto err_unmap;\n\n\treturn 0;\n\nerr_unmap:\n\tif (ar->bus_param.dev_type != ATH10K_DEV_TYPE_HL)\n\t\tdma_unmap_single(dev, skb_cb->paddr, skb->len, DMA_TO_DEVICE);\nerr_credits:\n\tath10k_htc_release_credit(ep, skb_len);\nerr_pull:\n\tskb_pull(skb, sizeof(struct ath10k_htc_hdr));\n\treturn ret;\n}\n\nvoid ath10k_htc_tx_completion_handler(struct ath10k *ar, struct sk_buff *skb)\n{\n\tstruct ath10k_htc *htc = &ar->htc;\n\tstruct ath10k_skb_cb *skb_cb;\n\tstruct ath10k_htc_ep *ep;\n\n\tif (WARN_ON_ONCE(!skb))\n\t\treturn;\n\n\tskb_cb = ATH10K_SKB_CB(skb);\n\tep = &htc->endpoint[skb_cb->eid];\n\n\tath10k_htc_notify_tx_completion(ep, skb);\n\t \n}\nEXPORT_SYMBOL(ath10k_htc_tx_completion_handler);\n\n \n \n \n\nstatic void\nath10k_htc_process_credit_report(struct ath10k_htc *htc,\n\t\t\t\t const struct ath10k_htc_credit_report *report,\n\t\t\t\t int len,\n\t\t\t\t enum ath10k_htc_ep_id eid)\n{\n\tstruct ath10k *ar = htc->ar;\n\tstruct ath10k_htc_ep *ep;\n\tint i, n_reports;\n\n\tif (len % sizeof(*report))\n\t\tath10k_warn(ar, \"Uneven credit report len %d\", len);\n\n\tn_reports = len / sizeof(*report);\n\n\tspin_lock_bh(&htc->tx_lock);\n\tfor (i = 0; i < n_reports; i++, report++) {\n\t\tif (report->eid >= ATH10K_HTC_EP_COUNT)\n\t\t\tbreak;\n\n\t\tep = &htc->endpoint[report->eid];\n\t\tep->tx_credits += report->credits;\n\n\t\tath10k_dbg(ar, ATH10K_DBG_HTC, \"htc ep %d got %d credits (total %d)\\n\",\n\t\t\t   report->eid, report->credits, ep->tx_credits);\n\n\t\tif (ep->ep_ops.ep_tx_credits) {\n\t\t\tspin_unlock_bh(&htc->tx_lock);\n\t\t\tep->ep_ops.ep_tx_credits(htc->ar);\n\t\t\tspin_lock_bh(&htc->tx_lock);\n\t\t}\n\t}\n\tspin_unlock_bh(&htc->tx_lock);\n}\n\nstatic int\nath10k_htc_process_lookahead(struct ath10k_htc *htc,\n\t\t\t     const struct ath10k_htc_lookahead_report *report,\n\t\t\t     int len,\n\t\t\t     enum ath10k_htc_ep_id eid,\n\t\t\t     void *next_lookaheads,\n\t\t\t     int *next_lookaheads_len)\n{\n\tstruct ath10k *ar = htc->ar;\n\n\t \n\tif (report->pre_valid != ((~report->post_valid) & 0xFF))\n\t\treturn 0;\n\n\tif (next_lookaheads && next_lookaheads_len) {\n\t\tath10k_dbg(ar, ATH10K_DBG_HTC,\n\t\t\t   \"htc rx lookahead found pre_valid 0x%x post_valid 0x%x\\n\",\n\t\t\t   report->pre_valid, report->post_valid);\n\n\t\t \n\t\tmemcpy((u8 *)next_lookaheads, report->lookahead, 4);\n\n\t\t*next_lookaheads_len = 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nath10k_htc_process_lookahead_bundle(struct ath10k_htc *htc,\n\t\t\t\t    const struct ath10k_htc_lookahead_bundle *report,\n\t\t\t\t    int len,\n\t\t\t\t    enum ath10k_htc_ep_id eid,\n\t\t\t\t    void *next_lookaheads,\n\t\t\t\t    int *next_lookaheads_len)\n{\n\tstruct ath10k *ar = htc->ar;\n\tint bundle_cnt = len / sizeof(*report);\n\n\tif (!bundle_cnt || (bundle_cnt > htc->max_msgs_per_htc_bundle)) {\n\t\tath10k_warn(ar, \"Invalid lookahead bundle count: %d\\n\",\n\t\t\t    bundle_cnt);\n\t\treturn -EINVAL;\n\t}\n\n\tif (next_lookaheads && next_lookaheads_len) {\n\t\tint i;\n\n\t\tfor (i = 0; i < bundle_cnt; i++) {\n\t\t\tmemcpy(((u8 *)next_lookaheads) + 4 * i,\n\t\t\t       report->lookahead, 4);\n\t\t\treport++;\n\t\t}\n\n\t\t*next_lookaheads_len = bundle_cnt;\n\t}\n\n\treturn 0;\n}\n\nint ath10k_htc_process_trailer(struct ath10k_htc *htc,\n\t\t\t       u8 *buffer,\n\t\t\t       int length,\n\t\t\t       enum ath10k_htc_ep_id src_eid,\n\t\t\t       void *next_lookaheads,\n\t\t\t       int *next_lookaheads_len)\n{\n\tstruct ath10k_htc_lookahead_bundle *bundle;\n\tstruct ath10k *ar = htc->ar;\n\tint status = 0;\n\tstruct ath10k_htc_record *record;\n\tu8 *orig_buffer;\n\tint orig_length;\n\tsize_t len;\n\n\torig_buffer = buffer;\n\torig_length = length;\n\n\twhile (length > 0) {\n\t\trecord = (struct ath10k_htc_record *)buffer;\n\n\t\tif (length < sizeof(record->hdr)) {\n\t\t\tstatus = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (record->hdr.len > length) {\n\t\t\t \n\t\t\tath10k_warn(ar, \"Invalid record length: %d\\n\",\n\t\t\t\t    record->hdr.len);\n\t\t\tstatus = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (record->hdr.id) {\n\t\tcase ATH10K_HTC_RECORD_CREDITS:\n\t\t\tlen = sizeof(struct ath10k_htc_credit_report);\n\t\t\tif (record->hdr.len < len) {\n\t\t\t\tath10k_warn(ar, \"Credit report too long\\n\");\n\t\t\t\tstatus = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tath10k_htc_process_credit_report(htc,\n\t\t\t\t\t\t\t record->credit_report,\n\t\t\t\t\t\t\t record->hdr.len,\n\t\t\t\t\t\t\t src_eid);\n\t\t\tbreak;\n\t\tcase ATH10K_HTC_RECORD_LOOKAHEAD:\n\t\t\tlen = sizeof(struct ath10k_htc_lookahead_report);\n\t\t\tif (record->hdr.len < len) {\n\t\t\t\tath10k_warn(ar, \"Lookahead report too long\\n\");\n\t\t\t\tstatus = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstatus = ath10k_htc_process_lookahead(htc,\n\t\t\t\t\t\t\t      record->lookahead_report,\n\t\t\t\t\t\t\t      record->hdr.len,\n\t\t\t\t\t\t\t      src_eid,\n\t\t\t\t\t\t\t      next_lookaheads,\n\t\t\t\t\t\t\t      next_lookaheads_len);\n\t\t\tbreak;\n\t\tcase ATH10K_HTC_RECORD_LOOKAHEAD_BUNDLE:\n\t\t\tbundle = record->lookahead_bundle;\n\t\t\tstatus = ath10k_htc_process_lookahead_bundle(htc,\n\t\t\t\t\t\t\t\t     bundle,\n\t\t\t\t\t\t\t\t     record->hdr.len,\n\t\t\t\t\t\t\t\t     src_eid,\n\t\t\t\t\t\t\t\t     next_lookaheads,\n\t\t\t\t\t\t\t\t     next_lookaheads_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tath10k_warn(ar, \"Unhandled record: id:%d length:%d\\n\",\n\t\t\t\t    record->hdr.id, record->hdr.len);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (status)\n\t\t\tbreak;\n\n\t\t \n\t\tbuffer += sizeof(record->hdr) + record->hdr.len;\n\t\tlength -= sizeof(record->hdr) + record->hdr.len;\n\t}\n\n\tif (status)\n\t\tath10k_dbg_dump(ar, ATH10K_DBG_HTC, \"htc rx bad trailer\", \"\",\n\t\t\t\torig_buffer, orig_length);\n\n\treturn status;\n}\nEXPORT_SYMBOL(ath10k_htc_process_trailer);\n\nvoid ath10k_htc_rx_completion_handler(struct ath10k *ar, struct sk_buff *skb)\n{\n\tint status = 0;\n\tstruct ath10k_htc *htc = &ar->htc;\n\tstruct ath10k_htc_hdr *hdr;\n\tstruct ath10k_htc_ep *ep;\n\tu16 payload_len;\n\tu32 trailer_len = 0;\n\tsize_t min_len;\n\tu8 eid;\n\tbool trailer_present;\n\n\thdr = (struct ath10k_htc_hdr *)skb->data;\n\tskb_pull(skb, sizeof(*hdr));\n\n\teid = hdr->eid;\n\n\tif (eid >= ATH10K_HTC_EP_COUNT) {\n\t\tath10k_warn(ar, \"HTC Rx: invalid eid %d\\n\", eid);\n\t\tath10k_dbg_dump(ar, ATH10K_DBG_HTC, \"htc bad header\", \"\",\n\t\t\t\thdr, sizeof(*hdr));\n\t\tgoto out;\n\t}\n\n\tep = &htc->endpoint[eid];\n\tif (ep->service_id == ATH10K_HTC_SVC_ID_UNUSED) {\n\t\tath10k_warn(ar, \"htc rx endpoint %d is not connected\\n\", eid);\n\t\tgoto out;\n\t}\n\n\tpayload_len = __le16_to_cpu(hdr->len);\n\n\tif (payload_len + sizeof(*hdr) > ATH10K_HTC_MAX_LEN) {\n\t\tath10k_warn(ar, \"HTC rx frame too long, len: %zu\\n\",\n\t\t\t    payload_len + sizeof(*hdr));\n\t\tath10k_dbg_dump(ar, ATH10K_DBG_HTC, \"htc bad rx pkt len\", \"\",\n\t\t\t\thdr, sizeof(*hdr));\n\t\tgoto out;\n\t}\n\n\tif (skb->len < payload_len) {\n\t\tath10k_dbg(ar, ATH10K_DBG_HTC,\n\t\t\t   \"HTC Rx: insufficient length, got %d, expected %d\\n\",\n\t\t\t   skb->len, payload_len);\n\t\tath10k_dbg_dump(ar, ATH10K_DBG_HTC, \"htc bad rx pkt len\",\n\t\t\t\t\"\", hdr, sizeof(*hdr));\n\t\tgoto out;\n\t}\n\n\t \n\ttrailer_present = hdr->flags & ATH10K_HTC_FLAG_TRAILER_PRESENT;\n\tif (trailer_present) {\n\t\tu8 *trailer;\n\n\t\ttrailer_len = hdr->trailer_len;\n\t\tmin_len = sizeof(struct ath10k_ath10k_htc_record_hdr);\n\n\t\tif ((trailer_len < min_len) ||\n\t\t    (trailer_len > payload_len)) {\n\t\t\tath10k_warn(ar, \"Invalid trailer length: %d\\n\",\n\t\t\t\t    trailer_len);\n\t\t\tgoto out;\n\t\t}\n\n\t\ttrailer = (u8 *)hdr;\n\t\ttrailer += sizeof(*hdr);\n\t\ttrailer += payload_len;\n\t\ttrailer -= trailer_len;\n\t\tstatus = ath10k_htc_process_trailer(htc, trailer,\n\t\t\t\t\t\t    trailer_len, hdr->eid,\n\t\t\t\t\t\t    NULL, NULL);\n\t\tif (status)\n\t\t\tgoto out;\n\n\t\tskb_trim(skb, skb->len - trailer_len);\n\t}\n\n\tif (((int)payload_len - (int)trailer_len) <= 0)\n\t\t \n\t\tgoto out;\n\n\tath10k_dbg(ar, ATH10K_DBG_HTC, \"htc rx completion ep %d skb %pK\\n\",\n\t\t   eid, skb);\n\tep->ep_ops.ep_rx_complete(ar, skb);\n\n\t \n\tskb = NULL;\nout:\n\tkfree_skb(skb);\n}\nEXPORT_SYMBOL(ath10k_htc_rx_completion_handler);\n\nstatic void ath10k_htc_control_rx_complete(struct ath10k *ar,\n\t\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct ath10k_htc *htc = &ar->htc;\n\tstruct ath10k_htc_msg *msg = (struct ath10k_htc_msg *)skb->data;\n\n\tswitch (__le16_to_cpu(msg->hdr.message_id)) {\n\tcase ATH10K_HTC_MSG_READY_ID:\n\tcase ATH10K_HTC_MSG_CONNECT_SERVICE_RESP_ID:\n\t\t \n\t\tif (completion_done(&htc->ctl_resp)) {\n\t\t\t \n\t\t\tath10k_warn(ar, \"HTC rx ctrl still processing\\n\");\n\t\t\tcomplete(&htc->ctl_resp);\n\t\t\tgoto out;\n\t\t}\n\n\t\thtc->control_resp_len =\n\t\t\tmin_t(int, skb->len,\n\t\t\t      ATH10K_HTC_MAX_CTRL_MSG_LEN);\n\n\t\tmemcpy(htc->control_resp_buffer, skb->data,\n\t\t       htc->control_resp_len);\n\n\t\tcomplete(&htc->ctl_resp);\n\t\tbreak;\n\tcase ATH10K_HTC_MSG_SEND_SUSPEND_COMPLETE:\n\t\thtc->htc_ops.target_send_suspend_complete(ar);\n\t\tbreak;\n\tdefault:\n\t\tath10k_warn(ar, \"ignoring unsolicited htc ep0 event\\n\");\n\t\tbreak;\n\t}\n\nout:\n\tkfree_skb(skb);\n}\n\n \n \n \n\nstatic const char *htc_service_name(enum ath10k_htc_svc_id id)\n{\n\tswitch (id) {\n\tcase ATH10K_HTC_SVC_ID_RESERVED:\n\t\treturn \"Reserved\";\n\tcase ATH10K_HTC_SVC_ID_RSVD_CTRL:\n\t\treturn \"Control\";\n\tcase ATH10K_HTC_SVC_ID_WMI_CONTROL:\n\t\treturn \"WMI\";\n\tcase ATH10K_HTC_SVC_ID_WMI_DATA_BE:\n\t\treturn \"DATA BE\";\n\tcase ATH10K_HTC_SVC_ID_WMI_DATA_BK:\n\t\treturn \"DATA BK\";\n\tcase ATH10K_HTC_SVC_ID_WMI_DATA_VI:\n\t\treturn \"DATA VI\";\n\tcase ATH10K_HTC_SVC_ID_WMI_DATA_VO:\n\t\treturn \"DATA VO\";\n\tcase ATH10K_HTC_SVC_ID_NMI_CONTROL:\n\t\treturn \"NMI Control\";\n\tcase ATH10K_HTC_SVC_ID_NMI_DATA:\n\t\treturn \"NMI Data\";\n\tcase ATH10K_HTC_SVC_ID_HTT_DATA_MSG:\n\t\treturn \"HTT Data\";\n\tcase ATH10K_HTC_SVC_ID_HTT_DATA2_MSG:\n\t\treturn \"HTT Data\";\n\tcase ATH10K_HTC_SVC_ID_HTT_DATA3_MSG:\n\t\treturn \"HTT Data\";\n\tcase ATH10K_HTC_SVC_ID_TEST_RAW_STREAMS:\n\t\treturn \"RAW\";\n\tcase ATH10K_HTC_SVC_ID_HTT_LOG_MSG:\n\t\treturn \"PKTLOG\";\n\t}\n\n\treturn \"Unknown\";\n}\n\nstatic void ath10k_htc_reset_endpoint_states(struct ath10k_htc *htc)\n{\n\tstruct ath10k_htc_ep *ep;\n\tint i;\n\n\tfor (i = ATH10K_HTC_EP_0; i < ATH10K_HTC_EP_COUNT; i++) {\n\t\tep = &htc->endpoint[i];\n\t\tep->service_id = ATH10K_HTC_SVC_ID_UNUSED;\n\t\tep->max_ep_message_len = 0;\n\t\tep->max_tx_queue_depth = 0;\n\t\tep->eid = i;\n\t\tep->htc = htc;\n\t\tep->tx_credit_flow_enabled = true;\n\t}\n}\n\nstatic u8 ath10k_htc_get_credit_allocation(struct ath10k_htc *htc,\n\t\t\t\t\t   u16 service_id)\n{\n\tu8 allocation = 0;\n\n\t \n\tif (service_id == ATH10K_HTC_SVC_ID_WMI_CONTROL)\n\t\tallocation = htc->total_transmit_credits;\n\n\treturn allocation;\n}\n\nstatic int ath10k_htc_send_bundle(struct ath10k_htc_ep *ep,\n\t\t\t\t  struct sk_buff *bundle_skb,\n\t\t\t\t  struct sk_buff_head *tx_save_head)\n{\n\tstruct ath10k_hif_sg_item sg_item;\n\tstruct ath10k_htc *htc = ep->htc;\n\tstruct ath10k *ar = htc->ar;\n\tstruct sk_buff *skb;\n\tint ret, cn = 0;\n\tunsigned int skb_len;\n\n\tath10k_dbg(ar, ATH10K_DBG_HTC, \"bundle skb len %d\\n\", bundle_skb->len);\n\tskb_len = bundle_skb->len;\n\tret = ath10k_htc_consume_credit(ep, skb_len, true);\n\n\tif (!ret) {\n\t\tsg_item.transfer_id = ep->eid;\n\t\tsg_item.transfer_context = bundle_skb;\n\t\tsg_item.vaddr = bundle_skb->data;\n\t\tsg_item.len = bundle_skb->len;\n\n\t\tret = ath10k_hif_tx_sg(htc->ar, ep->ul_pipe_id, &sg_item, 1);\n\t\tif (ret)\n\t\t\tath10k_htc_release_credit(ep, skb_len);\n\t}\n\n\tif (ret)\n\t\tdev_kfree_skb_any(bundle_skb);\n\n\tfor (cn = 0; (skb = skb_dequeue_tail(tx_save_head)); cn++) {\n\t\tif (ret) {\n\t\t\tskb_pull(skb, sizeof(struct ath10k_htc_hdr));\n\t\t\tskb_queue_head(&ep->tx_req_head, skb);\n\t\t} else {\n\t\t\tskb_queue_tail(&ep->tx_complete_head, skb);\n\t\t}\n\t}\n\n\tif (!ret)\n\t\tqueue_work(ar->workqueue_tx_complete, &ar->tx_complete_work);\n\n\tath10k_dbg(ar, ATH10K_DBG_HTC,\n\t\t   \"bundle tx status %d eid %d req count %d count %d len %d\\n\",\n\t\t   ret, ep->eid, skb_queue_len(&ep->tx_req_head), cn, skb_len);\n\treturn ret;\n}\n\nstatic void ath10k_htc_send_one_skb(struct ath10k_htc_ep *ep, struct sk_buff *skb)\n{\n\tstruct ath10k_htc *htc = ep->htc;\n\tstruct ath10k *ar = htc->ar;\n\tint ret;\n\n\tret = ath10k_htc_send(htc, ep->eid, skb);\n\n\tif (ret)\n\t\tskb_queue_head(&ep->tx_req_head, skb);\n\n\tath10k_dbg(ar, ATH10K_DBG_HTC, \"tx one status %d eid %d len %d pending count %d\\n\",\n\t\t   ret, ep->eid, skb->len, skb_queue_len(&ep->tx_req_head));\n}\n\nstatic int ath10k_htc_send_bundle_skbs(struct ath10k_htc_ep *ep)\n{\n\tstruct ath10k_htc *htc = ep->htc;\n\tstruct sk_buff *bundle_skb, *skb;\n\tstruct sk_buff_head tx_save_head;\n\tstruct ath10k_htc_hdr *hdr;\n\tu8 *bundle_buf;\n\tint ret = 0, credit_pad, credit_remainder, trans_len, bundles_left = 0;\n\n\tif (htc->ar->state == ATH10K_STATE_WEDGED)\n\t\treturn -ECOMM;\n\n\tif (ep->tx_credit_flow_enabled &&\n\t    ep->tx_credits < ATH10K_MIN_CREDIT_PER_HTC_TX_BUNDLE)\n\t\treturn 0;\n\n\tbundles_left = ATH10K_MAX_MSG_PER_HTC_TX_BUNDLE * ep->tx_credit_size;\n\tbundle_skb = dev_alloc_skb(bundles_left);\n\n\tif (!bundle_skb)\n\t\treturn -ENOMEM;\n\n\tbundle_buf = bundle_skb->data;\n\tskb_queue_head_init(&tx_save_head);\n\n\twhile (true) {\n\t\tskb = skb_dequeue(&ep->tx_req_head);\n\t\tif (!skb)\n\t\t\tbreak;\n\n\t\tcredit_pad = 0;\n\t\ttrans_len = skb->len + sizeof(*hdr);\n\t\tcredit_remainder = trans_len % ep->tx_credit_size;\n\n\t\tif (credit_remainder != 0) {\n\t\t\tcredit_pad = ep->tx_credit_size - credit_remainder;\n\t\t\ttrans_len += credit_pad;\n\t\t}\n\n\t\tret = ath10k_htc_consume_credit(ep,\n\t\t\t\t\t\tbundle_buf + trans_len - bundle_skb->data,\n\t\t\t\t\t\tfalse);\n\t\tif (ret) {\n\t\t\tskb_queue_head(&ep->tx_req_head, skb);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (bundles_left < trans_len) {\n\t\t\tbundle_skb->len = bundle_buf - bundle_skb->data;\n\t\t\tret = ath10k_htc_send_bundle(ep, bundle_skb, &tx_save_head);\n\n\t\t\tif (ret) {\n\t\t\t\tskb_queue_head(&ep->tx_req_head, skb);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tif (skb_queue_len(&ep->tx_req_head) == 0) {\n\t\t\t\tath10k_htc_send_one_skb(ep, skb);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tif (ep->tx_credit_flow_enabled &&\n\t\t\t    ep->tx_credits < ATH10K_MIN_CREDIT_PER_HTC_TX_BUNDLE) {\n\t\t\t\tskb_queue_head(&ep->tx_req_head, skb);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tbundles_left =\n\t\t\t\tATH10K_MAX_MSG_PER_HTC_TX_BUNDLE * ep->tx_credit_size;\n\t\t\tbundle_skb = dev_alloc_skb(bundles_left);\n\n\t\t\tif (!bundle_skb) {\n\t\t\t\tskb_queue_head(&ep->tx_req_head, skb);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tbundle_buf = bundle_skb->data;\n\t\t\tskb_queue_head_init(&tx_save_head);\n\t\t}\n\n\t\tskb_push(skb, sizeof(struct ath10k_htc_hdr));\n\t\tath10k_htc_prepare_tx_skb(ep, skb);\n\n\t\tmemcpy(bundle_buf, skb->data, skb->len);\n\t\thdr = (struct ath10k_htc_hdr *)bundle_buf;\n\t\thdr->flags |= ATH10K_HTC_FLAG_SEND_BUNDLE;\n\t\thdr->pad_len = __cpu_to_le16(credit_pad);\n\t\tbundle_buf += trans_len;\n\t\tbundles_left -= trans_len;\n\t\tskb_queue_tail(&tx_save_head, skb);\n\t}\n\n\tif (bundle_buf != bundle_skb->data) {\n\t\tbundle_skb->len = bundle_buf - bundle_skb->data;\n\t\tret = ath10k_htc_send_bundle(ep, bundle_skb, &tx_save_head);\n\t} else {\n\t\tdev_kfree_skb_any(bundle_skb);\n\t}\n\n\treturn ret;\n}\n\nstatic void ath10k_htc_bundle_tx_work(struct work_struct *work)\n{\n\tstruct ath10k *ar = container_of(work, struct ath10k, bundle_tx_work);\n\tstruct ath10k_htc_ep *ep;\n\tstruct sk_buff *skb;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ar->htc.endpoint); i++) {\n\t\tep = &ar->htc.endpoint[i];\n\n\t\tif (!ep->bundle_tx)\n\t\t\tcontinue;\n\n\t\tath10k_dbg(ar, ATH10K_DBG_HTC, \"bundle tx work eid %d count %d\\n\",\n\t\t\t   ep->eid, skb_queue_len(&ep->tx_req_head));\n\n\t\tif (skb_queue_len(&ep->tx_req_head) >=\n\t\t    ATH10K_MIN_MSG_PER_HTC_TX_BUNDLE) {\n\t\t\tath10k_htc_send_bundle_skbs(ep);\n\t\t} else {\n\t\t\tskb = skb_dequeue(&ep->tx_req_head);\n\n\t\t\tif (!skb)\n\t\t\t\tcontinue;\n\t\t\tath10k_htc_send_one_skb(ep, skb);\n\t\t}\n\t}\n}\n\nstatic void ath10k_htc_tx_complete_work(struct work_struct *work)\n{\n\tstruct ath10k *ar = container_of(work, struct ath10k, tx_complete_work);\n\tstruct ath10k_htc_ep *ep;\n\tenum ath10k_htc_ep_id eid;\n\tstruct sk_buff *skb;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ar->htc.endpoint); i++) {\n\t\tep = &ar->htc.endpoint[i];\n\t\teid = ep->eid;\n\t\tif (ep->bundle_tx && eid == ar->htt.eid) {\n\t\t\tath10k_dbg(ar, ATH10K_DBG_HTC, \"bundle tx complete eid %d pending complete count%d\\n\",\n\t\t\t\t   ep->eid, skb_queue_len(&ep->tx_complete_head));\n\n\t\t\twhile (true) {\n\t\t\t\tskb = skb_dequeue(&ep->tx_complete_head);\n\t\t\t\tif (!skb)\n\t\t\t\t\tbreak;\n\t\t\t\tath10k_htc_notify_tx_completion(ep, skb);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint ath10k_htc_send_hl(struct ath10k_htc *htc,\n\t\t       enum ath10k_htc_ep_id eid,\n\t\t       struct sk_buff *skb)\n{\n\tstruct ath10k_htc_ep *ep = &htc->endpoint[eid];\n\tstruct ath10k *ar = htc->ar;\n\n\tif (sizeof(struct ath10k_htc_hdr) + skb->len > ep->tx_credit_size) {\n\t\tath10k_dbg(ar, ATH10K_DBG_HTC, \"tx exceed max len %d\\n\", skb->len);\n\t\treturn -ENOMEM;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_HTC, \"htc send hl eid %d bundle %d tx count %d len %d\\n\",\n\t\t   eid, ep->bundle_tx, skb_queue_len(&ep->tx_req_head), skb->len);\n\n\tif (ep->bundle_tx) {\n\t\tskb_queue_tail(&ep->tx_req_head, skb);\n\t\tqueue_work(ar->workqueue, &ar->bundle_tx_work);\n\t\treturn 0;\n\t} else {\n\t\treturn ath10k_htc_send(htc, eid, skb);\n\t}\n}\n\nvoid ath10k_htc_setup_tx_req(struct ath10k_htc_ep *ep)\n{\n\tif (ep->htc->max_msgs_per_htc_bundle >= ATH10K_MIN_MSG_PER_HTC_TX_BUNDLE &&\n\t    !ep->bundle_tx) {\n\t\tep->bundle_tx = true;\n\t\tskb_queue_head_init(&ep->tx_req_head);\n\t\tskb_queue_head_init(&ep->tx_complete_head);\n\t}\n}\n\nvoid ath10k_htc_stop_hl(struct ath10k *ar)\n{\n\tstruct ath10k_htc_ep *ep;\n\tint i;\n\n\tcancel_work_sync(&ar->bundle_tx_work);\n\tcancel_work_sync(&ar->tx_complete_work);\n\n\tfor (i = 0; i < ARRAY_SIZE(ar->htc.endpoint); i++) {\n\t\tep = &ar->htc.endpoint[i];\n\n\t\tif (!ep->bundle_tx)\n\t\t\tcontinue;\n\n\t\tath10k_dbg(ar, ATH10K_DBG_HTC, \"stop tx work eid %d count %d\\n\",\n\t\t\t   ep->eid, skb_queue_len(&ep->tx_req_head));\n\n\t\tskb_queue_purge(&ep->tx_req_head);\n\t}\n}\n\nint ath10k_htc_wait_target(struct ath10k_htc *htc)\n{\n\tstruct ath10k *ar = htc->ar;\n\tint i, status = 0;\n\tunsigned long time_left;\n\tstruct ath10k_htc_msg *msg;\n\tu16 message_id;\n\n\ttime_left = wait_for_completion_timeout(&htc->ctl_resp,\n\t\t\t\t\t\tATH10K_HTC_WAIT_TIMEOUT_HZ);\n\tif (!time_left) {\n\t\t \n\t\tath10k_warn(ar, \"failed to receive control response completion, polling..\\n\");\n\n\t\tfor (i = 0; i < CE_COUNT; i++)\n\t\t\tath10k_hif_send_complete_check(htc->ar, i, 1);\n\n\t\ttime_left =\n\t\twait_for_completion_timeout(&htc->ctl_resp,\n\t\t\t\t\t    ATH10K_HTC_WAIT_TIMEOUT_HZ);\n\n\t\tif (!time_left)\n\t\t\tstatus = -ETIMEDOUT;\n\t}\n\n\tif (status < 0) {\n\t\tath10k_err(ar, \"ctl_resp never came in (%d)\\n\", status);\n\t\treturn status;\n\t}\n\n\tif (htc->control_resp_len < sizeof(msg->hdr) + sizeof(msg->ready)) {\n\t\tath10k_err(ar, \"Invalid HTC ready msg len:%d\\n\",\n\t\t\t   htc->control_resp_len);\n\t\treturn -ECOMM;\n\t}\n\n\tmsg = (struct ath10k_htc_msg *)htc->control_resp_buffer;\n\tmessage_id   = __le16_to_cpu(msg->hdr.message_id);\n\n\tif (message_id != ATH10K_HTC_MSG_READY_ID) {\n\t\tath10k_err(ar, \"Invalid HTC ready msg: 0x%x\\n\", message_id);\n\t\treturn -ECOMM;\n\t}\n\n\tif (ar->hw_params.use_fw_tx_credits)\n\t\thtc->total_transmit_credits = __le16_to_cpu(msg->ready.credit_count);\n\telse\n\t\thtc->total_transmit_credits = 1;\n\n\thtc->target_credit_size = __le16_to_cpu(msg->ready.credit_size);\n\n\tath10k_dbg(ar, ATH10K_DBG_HTC,\n\t\t   \"Target ready! transmit resources: %d size:%d actual credits:%d\\n\",\n\t\t   htc->total_transmit_credits,\n\t\t   htc->target_credit_size,\n\t\t   msg->ready.credit_count);\n\n\tif ((htc->total_transmit_credits == 0) ||\n\t    (htc->target_credit_size == 0)) {\n\t\tath10k_err(ar, \"Invalid credit size received\\n\");\n\t\treturn -ECOMM;\n\t}\n\n\t \n\tif (htc->control_resp_len >=\n\t    sizeof(msg->hdr) + sizeof(msg->ready_ext)) {\n\t\thtc->alt_data_credit_size =\n\t\t\t__le16_to_cpu(msg->ready_ext.reserved) &\n\t\t\tATH10K_HTC_MSG_READY_EXT_ALT_DATA_MASK;\n\t\thtc->max_msgs_per_htc_bundle =\n\t\t\tmin_t(u8, msg->ready_ext.max_msgs_per_htc_bundle,\n\t\t\t      HTC_HOST_MAX_MSG_PER_RX_BUNDLE);\n\t\tath10k_dbg(ar, ATH10K_DBG_HTC,\n\t\t\t   \"Extended ready message RX bundle size %d alt size %d\\n\",\n\t\t\t   htc->max_msgs_per_htc_bundle,\n\t\t\t   htc->alt_data_credit_size);\n\t}\n\n\tINIT_WORK(&ar->bundle_tx_work, ath10k_htc_bundle_tx_work);\n\tINIT_WORK(&ar->tx_complete_work, ath10k_htc_tx_complete_work);\n\n\treturn 0;\n}\n\nvoid ath10k_htc_change_tx_credit_flow(struct ath10k_htc *htc,\n\t\t\t\t      enum ath10k_htc_ep_id eid,\n\t\t\t\t      bool enable)\n{\n\tstruct ath10k *ar = htc->ar;\n\tstruct ath10k_htc_ep *ep = &ar->htc.endpoint[eid];\n\n\tep->tx_credit_flow_enabled = enable;\n}\n\nint ath10k_htc_connect_service(struct ath10k_htc *htc,\n\t\t\t       struct ath10k_htc_svc_conn_req *conn_req,\n\t\t\t       struct ath10k_htc_svc_conn_resp *conn_resp)\n{\n\tstruct ath10k *ar = htc->ar;\n\tstruct ath10k_htc_msg *msg;\n\tstruct ath10k_htc_conn_svc *req_msg;\n\tstruct ath10k_htc_conn_svc_response resp_msg_dummy;\n\tstruct ath10k_htc_conn_svc_response *resp_msg = &resp_msg_dummy;\n\tenum ath10k_htc_ep_id assigned_eid = ATH10K_HTC_EP_COUNT;\n\tstruct ath10k_htc_ep *ep;\n\tstruct sk_buff *skb;\n\tunsigned int max_msg_size = 0;\n\tint length, status;\n\tunsigned long time_left;\n\tbool disable_credit_flow_ctrl = false;\n\tu16 message_id, service_id, flags = 0;\n\tu8 tx_alloc = 0;\n\n\t \n\tif (conn_req->service_id == ATH10K_HTC_SVC_ID_RSVD_CTRL) {\n\t\tdisable_credit_flow_ctrl = true;\n\t\tassigned_eid = ATH10K_HTC_EP_0;\n\t\tmax_msg_size = ATH10K_HTC_MAX_CTRL_MSG_LEN;\n\t\tmemset(&resp_msg_dummy, 0, sizeof(resp_msg_dummy));\n\t\tgoto setup;\n\t}\n\n\ttx_alloc = ath10k_htc_get_credit_allocation(htc,\n\t\t\t\t\t\t    conn_req->service_id);\n\tif (!tx_alloc)\n\t\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t\t   \"boot htc service %s does not allocate target credits\\n\",\n\t\t\t   htc_service_name(conn_req->service_id));\n\n\tskb = ath10k_htc_build_tx_ctrl_skb(htc->ar);\n\tif (!skb) {\n\t\tath10k_err(ar, \"Failed to allocate HTC packet\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tlength = sizeof(msg->hdr) + sizeof(msg->connect_service);\n\tskb_put(skb, length);\n\tmemset(skb->data, 0, length);\n\n\tmsg = (struct ath10k_htc_msg *)skb->data;\n\tmsg->hdr.message_id =\n\t\t__cpu_to_le16(ATH10K_HTC_MSG_CONNECT_SERVICE_ID);\n\n\tflags |= SM(tx_alloc, ATH10K_HTC_CONN_FLAGS_RECV_ALLOC);\n\n\t \n\tif (conn_req->service_id != ATH10K_HTC_SVC_ID_WMI_CONTROL) {\n\t\tflags |= ATH10K_HTC_CONN_FLAGS_DISABLE_CREDIT_FLOW_CTRL;\n\t\tdisable_credit_flow_ctrl = true;\n\t}\n\n\treq_msg = &msg->connect_service;\n\treq_msg->flags = __cpu_to_le16(flags);\n\treq_msg->service_id = __cpu_to_le16(conn_req->service_id);\n\n\treinit_completion(&htc->ctl_resp);\n\n\tstatus = ath10k_htc_send(htc, ATH10K_HTC_EP_0, skb);\n\tif (status) {\n\t\tkfree_skb(skb);\n\t\treturn status;\n\t}\n\n\t \n\ttime_left = wait_for_completion_timeout(&htc->ctl_resp,\n\t\t\t\t\t\tATH10K_HTC_CONN_SVC_TIMEOUT_HZ);\n\tif (!time_left) {\n\t\tath10k_err(ar, \"Service connect timeout\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\tmsg = (struct ath10k_htc_msg *)htc->control_resp_buffer;\n\tresp_msg = &msg->connect_service_response;\n\tmessage_id = __le16_to_cpu(msg->hdr.message_id);\n\tservice_id = __le16_to_cpu(resp_msg->service_id);\n\n\tif ((message_id != ATH10K_HTC_MSG_CONNECT_SERVICE_RESP_ID) ||\n\t    (htc->control_resp_len < sizeof(msg->hdr) +\n\t     sizeof(msg->connect_service_response))) {\n\t\tath10k_err(ar, \"Invalid resp message ID 0x%x\", message_id);\n\t\treturn -EPROTO;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_HTC,\n\t\t   \"HTC Service %s connect response: status: 0x%x, assigned ep: 0x%x\\n\",\n\t\t   htc_service_name(service_id),\n\t\t   resp_msg->status, resp_msg->eid);\n\n\tconn_resp->connect_resp_code = resp_msg->status;\n\n\t \n\tif (resp_msg->status != ATH10K_HTC_CONN_SVC_STATUS_SUCCESS) {\n\t\tath10k_err(ar, \"HTC Service %s connect request failed: 0x%x)\\n\",\n\t\t\t   htc_service_name(service_id),\n\t\t\t   resp_msg->status);\n\t\treturn -EPROTO;\n\t}\n\n\tassigned_eid = (enum ath10k_htc_ep_id)resp_msg->eid;\n\tmax_msg_size = __le16_to_cpu(resp_msg->max_msg_size);\n\nsetup:\n\n\tif (assigned_eid >= ATH10K_HTC_EP_COUNT)\n\t\treturn -EPROTO;\n\n\tif (max_msg_size == 0)\n\t\treturn -EPROTO;\n\n\tep = &htc->endpoint[assigned_eid];\n\tep->eid = assigned_eid;\n\n\tif (ep->service_id != ATH10K_HTC_SVC_ID_UNUSED)\n\t\treturn -EPROTO;\n\n\t \n\tconn_resp->eid = assigned_eid;\n\tconn_resp->max_msg_len = __le16_to_cpu(resp_msg->max_msg_size);\n\n\t \n\tep->service_id = conn_req->service_id;\n\tep->max_tx_queue_depth = conn_req->max_send_queue_depth;\n\tep->max_ep_message_len = __le16_to_cpu(resp_msg->max_msg_size);\n\tep->tx_credits = tx_alloc;\n\tep->tx_credit_size = htc->target_credit_size;\n\n\tif (conn_req->service_id == ATH10K_HTC_SVC_ID_HTT_DATA_MSG &&\n\t    htc->alt_data_credit_size != 0)\n\t\tep->tx_credit_size = htc->alt_data_credit_size;\n\n\t \n\tep->ep_ops = conn_req->ep_ops;\n\n\tstatus = ath10k_hif_map_service_to_pipe(htc->ar,\n\t\t\t\t\t\tep->service_id,\n\t\t\t\t\t\t&ep->ul_pipe_id,\n\t\t\t\t\t\t&ep->dl_pipe_id);\n\tif (status) {\n\t\tath10k_dbg(ar, ATH10K_DBG_BOOT, \"unsupported HTC service id: %d\\n\",\n\t\t\t   ep->service_id);\n\t\treturn status;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t   \"boot htc service '%s' ul pipe %d dl pipe %d eid %d ready\\n\",\n\t\t   htc_service_name(ep->service_id), ep->ul_pipe_id,\n\t\t   ep->dl_pipe_id, ep->eid);\n\n\tif (disable_credit_flow_ctrl && ep->tx_credit_flow_enabled) {\n\t\tep->tx_credit_flow_enabled = false;\n\t\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t\t   \"boot htc service '%s' eid %d TX flow control disabled\\n\",\n\t\t\t   htc_service_name(ep->service_id), assigned_eid);\n\t}\n\n\treturn status;\n}\n\nstruct sk_buff *ath10k_htc_alloc_skb(struct ath10k *ar, int size)\n{\n\tstruct sk_buff *skb;\n\n\tskb = dev_alloc_skb(size + sizeof(struct ath10k_htc_hdr));\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, sizeof(struct ath10k_htc_hdr));\n\n\t \n\tif (!IS_ALIGNED((unsigned long)skb->data, 4))\n\t\tath10k_warn(ar, \"Unaligned HTC tx skb\\n\");\n\n\treturn skb;\n}\n\nstatic void ath10k_htc_pktlog_process_rx(struct ath10k *ar, struct sk_buff *skb)\n{\n\ttrace_ath10k_htt_pktlog(ar, skb->data, skb->len);\n\tdev_kfree_skb_any(skb);\n}\n\nstatic int ath10k_htc_pktlog_connect(struct ath10k *ar)\n{\n\tstruct ath10k_htc_svc_conn_resp conn_resp;\n\tstruct ath10k_htc_svc_conn_req conn_req;\n\tint status;\n\n\tmemset(&conn_req, 0, sizeof(conn_req));\n\tmemset(&conn_resp, 0, sizeof(conn_resp));\n\n\tconn_req.ep_ops.ep_tx_complete = NULL;\n\tconn_req.ep_ops.ep_rx_complete = ath10k_htc_pktlog_process_rx;\n\tconn_req.ep_ops.ep_tx_credits = NULL;\n\n\t \n\tconn_req.service_id = ATH10K_HTC_SVC_ID_HTT_LOG_MSG;\n\tstatus = ath10k_htc_connect_service(&ar->htc, &conn_req, &conn_resp);\n\tif (status) {\n\t\tath10k_warn(ar, \"failed to connect to PKTLOG service: %d\\n\",\n\t\t\t    status);\n\t\treturn status;\n\t}\n\n\treturn 0;\n}\n\nstatic bool ath10k_htc_pktlog_svc_supported(struct ath10k *ar)\n{\n\tu8 ul_pipe_id;\n\tu8 dl_pipe_id;\n\tint status;\n\n\tstatus = ath10k_hif_map_service_to_pipe(ar, ATH10K_HTC_SVC_ID_HTT_LOG_MSG,\n\t\t\t\t\t\t&ul_pipe_id,\n\t\t\t\t\t\t&dl_pipe_id);\n\tif (status) {\n\t\tath10k_dbg(ar, ATH10K_DBG_BOOT, \"unsupported HTC pktlog service id: %d\\n\",\n\t\t\t   ATH10K_HTC_SVC_ID_HTT_LOG_MSG);\n\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nint ath10k_htc_start(struct ath10k_htc *htc)\n{\n\tstruct ath10k *ar = htc->ar;\n\tstruct sk_buff *skb;\n\tint status = 0;\n\tstruct ath10k_htc_msg *msg;\n\n\tskb = ath10k_htc_build_tx_ctrl_skb(htc->ar);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put(skb, sizeof(msg->hdr) + sizeof(msg->setup_complete_ext));\n\tmemset(skb->data, 0, skb->len);\n\n\tmsg = (struct ath10k_htc_msg *)skb->data;\n\tmsg->hdr.message_id =\n\t\t__cpu_to_le16(ATH10K_HTC_MSG_SETUP_COMPLETE_EX_ID);\n\n\tif (ar->hif.bus == ATH10K_BUS_SDIO) {\n\t\t \n\t\tmsg->setup_complete_ext.flags =\n\t\t\t__cpu_to_le32(ATH10K_HTC_SETUP_COMPLETE_FLAGS_RX_BNDL_EN);\n\t\tmsg->setup_complete_ext.max_msgs_per_bundled_recv =\n\t\t\thtc->max_msgs_per_htc_bundle;\n\t}\n\tath10k_dbg(ar, ATH10K_DBG_HTC, \"HTC is using TX credit flow control\\n\");\n\n\tstatus = ath10k_htc_send(htc, ATH10K_HTC_EP_0, skb);\n\tif (status) {\n\t\tkfree_skb(skb);\n\t\treturn status;\n\t}\n\n\tif (ath10k_htc_pktlog_svc_supported(ar)) {\n\t\tstatus = ath10k_htc_pktlog_connect(ar);\n\t\tif (status) {\n\t\t\tath10k_err(ar, \"failed to connect to pktlog: %d\\n\", status);\n\t\t\treturn status;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nint ath10k_htc_init(struct ath10k *ar)\n{\n\tint status;\n\tstruct ath10k_htc *htc = &ar->htc;\n\tstruct ath10k_htc_svc_conn_req conn_req;\n\tstruct ath10k_htc_svc_conn_resp conn_resp;\n\n\tspin_lock_init(&htc->tx_lock);\n\n\tath10k_htc_reset_endpoint_states(htc);\n\n\thtc->ar = ar;\n\n\t \n\tmemset(&conn_req, 0, sizeof(conn_req));\n\tmemset(&conn_resp, 0, sizeof(conn_resp));\n\tconn_req.ep_ops.ep_tx_complete = ath10k_htc_control_tx_complete;\n\tconn_req.ep_ops.ep_rx_complete = ath10k_htc_control_rx_complete;\n\tconn_req.max_send_queue_depth = ATH10K_NUM_CONTROL_TX_BUFFERS;\n\tconn_req.service_id = ATH10K_HTC_SVC_ID_RSVD_CTRL;\n\n\t \n\tstatus = ath10k_htc_connect_service(htc, &conn_req, &conn_resp);\n\tif (status) {\n\t\tath10k_err(ar, \"could not connect to htc service (%d)\\n\",\n\t\t\t   status);\n\t\treturn status;\n\t}\n\n\tinit_completion(&htc->ctl_resp);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}