{
  "module_name": "swap.c",
  "hash_id": "048cebc459ec1aa074f27c3d3f3bfddcd1148987524f5666e81e8f6a47432aca",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath10k/swap.c",
  "human_readable_source": "\n \n\n \n\n#include \"core.h\"\n#include \"bmi.h\"\n#include \"debug.h\"\n\nstatic int ath10k_swap_code_seg_fill(struct ath10k *ar,\n\t\t\t\t     struct ath10k_swap_code_seg_info *seg_info,\n\t\t\t\t     const void *data, size_t data_len)\n{\n\tu8 *virt_addr = seg_info->virt_address[0];\n\tu8 swap_magic[ATH10K_SWAP_CODE_SEG_MAGIC_BYTES_SZ] = {};\n\tconst u8 *fw_data = data;\n\tunion ath10k_swap_code_seg_item *swap_item;\n\tu32 length = 0;\n\tu32 payload_len;\n\tu32 total_payload_len = 0;\n\tu32 size_left = data_len;\n\n\t \n\tseg_info->target_addr = -1;\n\twhile (size_left >= sizeof(*swap_item)) {\n\t\tswap_item = (union ath10k_swap_code_seg_item *)fw_data;\n\t\tpayload_len = __le32_to_cpu(swap_item->tlv.length);\n\t\tif ((payload_len > size_left) ||\n\t\t    (payload_len == 0 &&\n\t\t     size_left != sizeof(struct ath10k_swap_code_seg_tail))) {\n\t\t\tath10k_err(ar, \"refusing to parse invalid tlv length %d\\n\",\n\t\t\t\t   payload_len);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (payload_len == 0) {\n\t\t\tif (memcmp(swap_item->tail.magic_signature, swap_magic,\n\t\t\t\t   ATH10K_SWAP_CODE_SEG_MAGIC_BYTES_SZ)) {\n\t\t\t\tath10k_err(ar, \"refusing an invalid swap file\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tseg_info->target_addr =\n\t\t\t\t__le32_to_cpu(swap_item->tail.bmi_write_addr);\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(virt_addr, swap_item->tlv.data, payload_len);\n\t\tvirt_addr += payload_len;\n\t\tlength = payload_len +  sizeof(struct ath10k_swap_code_seg_tlv);\n\t\tsize_left -= length;\n\t\tfw_data += length;\n\t\ttotal_payload_len += payload_len;\n\t}\n\n\tif (seg_info->target_addr == -1) {\n\t\tath10k_err(ar, \"failed to parse invalid swap file\\n\");\n\t\treturn -EINVAL;\n\t}\n\tseg_info->seg_hw_info.swap_size = __cpu_to_le32(total_payload_len);\n\n\treturn 0;\n}\n\nstatic void\nath10k_swap_code_seg_free(struct ath10k *ar,\n\t\t\t  struct ath10k_swap_code_seg_info *seg_info)\n{\n\tu32 seg_size;\n\n\tif (!seg_info)\n\t\treturn;\n\n\tif (!seg_info->virt_address[0])\n\t\treturn;\n\n\tseg_size = __le32_to_cpu(seg_info->seg_hw_info.size);\n\tdma_free_coherent(ar->dev, seg_size, seg_info->virt_address[0],\n\t\t\t  seg_info->paddr[0]);\n}\n\nstatic struct ath10k_swap_code_seg_info *\nath10k_swap_code_seg_alloc(struct ath10k *ar, size_t swap_bin_len)\n{\n\tstruct ath10k_swap_code_seg_info *seg_info;\n\tvoid *virt_addr;\n\tdma_addr_t paddr;\n\n\tswap_bin_len = roundup(swap_bin_len, 2);\n\tif (swap_bin_len > ATH10K_SWAP_CODE_SEG_BIN_LEN_MAX) {\n\t\tath10k_err(ar, \"refusing code swap bin because it is too big %zu > %d\\n\",\n\t\t\t   swap_bin_len, ATH10K_SWAP_CODE_SEG_BIN_LEN_MAX);\n\t\treturn NULL;\n\t}\n\n\tseg_info = devm_kzalloc(ar->dev, sizeof(*seg_info), GFP_KERNEL);\n\tif (!seg_info)\n\t\treturn NULL;\n\n\tvirt_addr = dma_alloc_coherent(ar->dev, swap_bin_len, &paddr,\n\t\t\t\t       GFP_KERNEL);\n\tif (!virt_addr)\n\t\treturn NULL;\n\n\tseg_info->seg_hw_info.bus_addr[0] = __cpu_to_le32(paddr);\n\tseg_info->seg_hw_info.size = __cpu_to_le32(swap_bin_len);\n\tseg_info->seg_hw_info.swap_size = __cpu_to_le32(swap_bin_len);\n\tseg_info->seg_hw_info.num_segs =\n\t\t\t__cpu_to_le32(ATH10K_SWAP_CODE_SEG_NUM_SUPPORTED);\n\tseg_info->seg_hw_info.size_log2 = __cpu_to_le32(ilog2(swap_bin_len));\n\tseg_info->virt_address[0] = virt_addr;\n\tseg_info->paddr[0] = paddr;\n\n\treturn seg_info;\n}\n\nint ath10k_swap_code_seg_configure(struct ath10k *ar,\n\t\t\t\t   const struct ath10k_fw_file *fw_file)\n{\n\tint ret;\n\tstruct ath10k_swap_code_seg_info *seg_info = NULL;\n\n\tif (!fw_file->firmware_swap_code_seg_info)\n\t\treturn 0;\n\n\tath10k_dbg(ar, ATH10K_DBG_BOOT, \"boot found firmware code swap binary\\n\");\n\n\tseg_info = fw_file->firmware_swap_code_seg_info;\n\n\tret = ath10k_bmi_write_memory(ar, seg_info->target_addr,\n\t\t\t\t      &seg_info->seg_hw_info,\n\t\t\t\t      sizeof(seg_info->seg_hw_info));\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to write Code swap segment information (%d)\\n\",\n\t\t\t   ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nvoid ath10k_swap_code_seg_release(struct ath10k *ar,\n\t\t\t\t  struct ath10k_fw_file *fw_file)\n{\n\tath10k_swap_code_seg_free(ar, fw_file->firmware_swap_code_seg_info);\n\n\t \n\tfw_file->codeswap_data = NULL;\n\tfw_file->codeswap_len = 0;\n\n\tfw_file->firmware_swap_code_seg_info = NULL;\n}\n\nint ath10k_swap_code_seg_init(struct ath10k *ar, struct ath10k_fw_file *fw_file)\n{\n\tint ret;\n\tstruct ath10k_swap_code_seg_info *seg_info;\n\tconst void *codeswap_data;\n\tsize_t codeswap_len;\n\n\tcodeswap_data = fw_file->codeswap_data;\n\tcodeswap_len = fw_file->codeswap_len;\n\n\tif (!codeswap_len || !codeswap_data)\n\t\treturn 0;\n\n\tseg_info = ath10k_swap_code_seg_alloc(ar, codeswap_len);\n\tif (!seg_info) {\n\t\tath10k_err(ar, \"failed to allocate fw code swap segment\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = ath10k_swap_code_seg_fill(ar, seg_info,\n\t\t\t\t\tcodeswap_data, codeswap_len);\n\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to initialize fw code swap segment: %d\\n\",\n\t\t\t    ret);\n\t\tath10k_swap_code_seg_free(ar, seg_info);\n\t\treturn ret;\n\t}\n\n\tfw_file->firmware_swap_code_seg_info = seg_info;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}