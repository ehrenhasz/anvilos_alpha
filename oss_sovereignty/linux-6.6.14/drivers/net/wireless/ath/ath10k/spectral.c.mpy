{
  "module_name": "spectral.c",
  "hash_id": "c15dbd7d55eccdc2db87dcaa9187694189221d176a5abf1693c7fccf27cdf8c6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath10k/spectral.c",
  "human_readable_source": "\n \n\n#include <linux/relay.h>\n#include \"core.h\"\n#include \"debug.h\"\n#include \"wmi-ops.h\"\n\nstatic void send_fft_sample(struct ath10k *ar,\n\t\t\t    const struct fft_sample_tlv *fft_sample_tlv)\n{\n\tint length;\n\n\tif (!ar->spectral.rfs_chan_spec_scan)\n\t\treturn;\n\n\tlength = __be16_to_cpu(fft_sample_tlv->length) +\n\t\t sizeof(*fft_sample_tlv);\n\trelay_write(ar->spectral.rfs_chan_spec_scan, fft_sample_tlv, length);\n}\n\nstatic uint8_t get_max_exp(s8 max_index, u16 max_magnitude, size_t bin_len,\n\t\t\t   u8 *data)\n{\n\tint dc_pos;\n\tu8 max_exp;\n\n\tdc_pos = bin_len / 2;\n\n\t \n\tif (dc_pos < max_index || -dc_pos >= max_index)\n\t\treturn 0;\n\n\tfor (max_exp = 0; max_exp < 8; max_exp++) {\n\t\tif (data[dc_pos + max_index] == (max_magnitude >> max_exp))\n\t\t\tbreak;\n\t}\n\n\t \n\tif (data[dc_pos + max_index] != (max_magnitude >> max_exp))\n\t\treturn 0;\n\n\treturn max_exp;\n}\n\nstatic inline size_t ath10k_spectral_fix_bin_size(struct ath10k *ar,\n\t\t\t\t\t\t  size_t bin_len)\n{\n\t \n\tif (!is_power_of_2(bin_len))\n\t\tbin_len -= ar->hw_params.spectral_bin_discard;\n\n\treturn bin_len;\n}\n\nint ath10k_spectral_process_fft(struct ath10k *ar,\n\t\t\t\tstruct wmi_phyerr_ev_arg *phyerr,\n\t\t\t\tconst struct phyerr_fft_report *fftr,\n\t\t\t\tsize_t bin_len, u64 tsf)\n{\n\tstruct fft_sample_ath10k *fft_sample;\n\tu8 buf[sizeof(*fft_sample) + SPECTRAL_ATH10K_MAX_NUM_BINS];\n\tu16 freq1, freq2, total_gain_db, base_pwr_db, length, peak_mag;\n\tu32 reg0, reg1;\n\tu8 chain_idx, *bins;\n\tint dc_pos;\n\n\tfft_sample = (struct fft_sample_ath10k *)&buf;\n\n\tbin_len = ath10k_spectral_fix_bin_size(ar, bin_len);\n\n\tif (bin_len < 64 || bin_len > SPECTRAL_ATH10K_MAX_NUM_BINS)\n\t\treturn -EINVAL;\n\n\treg0 = __le32_to_cpu(fftr->reg0);\n\treg1 = __le32_to_cpu(fftr->reg1);\n\n\tlength = sizeof(*fft_sample) - sizeof(struct fft_sample_tlv) + bin_len;\n\tfft_sample->tlv.type = ATH_FFT_SAMPLE_ATH10K;\n\tfft_sample->tlv.length = __cpu_to_be16(length);\n\n\t \n\tswitch (phyerr->chan_width_mhz) {\n\tcase 20:\n\t\tfft_sample->chan_width_mhz = 22;\n\t\tbreak;\n\tcase 40:\n\t\tfft_sample->chan_width_mhz = 44;\n\t\tbreak;\n\tcase 80:\n\t\t \n\t\tif (bin_len == 64)\n\t\t\treturn -EINVAL;\n\t\tfft_sample->chan_width_mhz = 88;\n\t\tbreak;\n\tdefault:\n\t\tfft_sample->chan_width_mhz = phyerr->chan_width_mhz;\n\t}\n\n\tfft_sample->relpwr_db = MS(reg1, SEARCH_FFT_REPORT_REG1_RELPWR_DB);\n\tfft_sample->avgpwr_db = MS(reg1, SEARCH_FFT_REPORT_REG1_AVGPWR_DB);\n\n\tpeak_mag = MS(reg1, SEARCH_FFT_REPORT_REG1_PEAK_MAG);\n\tfft_sample->max_magnitude = __cpu_to_be16(peak_mag);\n\tfft_sample->max_index = MS(reg0, SEARCH_FFT_REPORT_REG0_PEAK_SIDX);\n\tfft_sample->rssi = phyerr->rssi_combined;\n\n\ttotal_gain_db = MS(reg0, SEARCH_FFT_REPORT_REG0_TOTAL_GAIN_DB);\n\tbase_pwr_db = MS(reg0, SEARCH_FFT_REPORT_REG0_BASE_PWR_DB);\n\tfft_sample->total_gain_db = __cpu_to_be16(total_gain_db);\n\tfft_sample->base_pwr_db = __cpu_to_be16(base_pwr_db);\n\n\tfreq1 = phyerr->freq1;\n\tfreq2 = phyerr->freq2;\n\tfft_sample->freq1 = __cpu_to_be16(freq1);\n\tfft_sample->freq2 = __cpu_to_be16(freq2);\n\n\tchain_idx = MS(reg0, SEARCH_FFT_REPORT_REG0_FFT_CHN_IDX);\n\n\tfft_sample->noise = __cpu_to_be16(phyerr->nf_chains[chain_idx]);\n\n\tbins = (u8 *)fftr;\n\tbins += sizeof(*fftr) + ar->hw_params.spectral_bin_offset;\n\n\tfft_sample->tsf = __cpu_to_be64(tsf);\n\n\t \n\tfft_sample->max_exp = get_max_exp(fft_sample->max_index, peak_mag,\n\t\t\t\t\t  bin_len, bins);\n\n\tmemcpy(fft_sample->data, bins, bin_len);\n\n\t \n\tdc_pos = bin_len / 2;\n\tfft_sample->data[dc_pos] = (fft_sample->data[dc_pos + 1] +\n\t\t\t\t    fft_sample->data[dc_pos - 1]) / 2;\n\n\tsend_fft_sample(ar, &fft_sample->tlv);\n\n\treturn 0;\n}\n\nstatic struct ath10k_vif *ath10k_get_spectral_vdev(struct ath10k *ar)\n{\n\tstruct ath10k_vif *arvif;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (list_empty(&ar->arvifs))\n\t\treturn NULL;\n\n\t \n\tlist_for_each_entry(arvif, &ar->arvifs, list)\n\t\tif (arvif->spectral_enabled)\n\t\t\treturn arvif;\n\n\t \n\treturn list_first_entry(&ar->arvifs, typeof(*arvif), list);\n}\n\nstatic int ath10k_spectral_scan_trigger(struct ath10k *ar)\n{\n\tstruct ath10k_vif *arvif;\n\tint res;\n\tint vdev_id;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tarvif = ath10k_get_spectral_vdev(ar);\n\tif (!arvif)\n\t\treturn -ENODEV;\n\tvdev_id = arvif->vdev_id;\n\n\tif (ar->spectral.mode == SPECTRAL_DISABLED)\n\t\treturn 0;\n\n\tres = ath10k_wmi_vdev_spectral_enable(ar, vdev_id,\n\t\t\t\t\t      WMI_SPECTRAL_TRIGGER_CMD_CLEAR,\n\t\t\t\t\t      WMI_SPECTRAL_ENABLE_CMD_ENABLE);\n\tif (res < 0)\n\t\treturn res;\n\n\tres = ath10k_wmi_vdev_spectral_enable(ar, vdev_id,\n\t\t\t\t\t      WMI_SPECTRAL_TRIGGER_CMD_TRIGGER,\n\t\t\t\t\t      WMI_SPECTRAL_ENABLE_CMD_ENABLE);\n\tif (res < 0)\n\t\treturn res;\n\n\treturn 0;\n}\n\nstatic int ath10k_spectral_scan_config(struct ath10k *ar,\n\t\t\t\t       enum ath10k_spectral_mode mode)\n{\n\tstruct wmi_vdev_spectral_conf_arg arg;\n\tstruct ath10k_vif *arvif;\n\tint vdev_id, count, res = 0;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tarvif = ath10k_get_spectral_vdev(ar);\n\tif (!arvif)\n\t\treturn -ENODEV;\n\n\tvdev_id = arvif->vdev_id;\n\n\tarvif->spectral_enabled = (mode != SPECTRAL_DISABLED);\n\tar->spectral.mode = mode;\n\n\tres = ath10k_wmi_vdev_spectral_enable(ar, vdev_id,\n\t\t\t\t\t      WMI_SPECTRAL_TRIGGER_CMD_CLEAR,\n\t\t\t\t\t      WMI_SPECTRAL_ENABLE_CMD_DISABLE);\n\tif (res < 0) {\n\t\tath10k_warn(ar, \"failed to enable spectral scan: %d\\n\", res);\n\t\treturn res;\n\t}\n\n\tif (mode == SPECTRAL_DISABLED)\n\t\treturn 0;\n\n\tif (mode == SPECTRAL_BACKGROUND)\n\t\tcount = WMI_SPECTRAL_COUNT_DEFAULT;\n\telse\n\t\tcount = max_t(u8, 1, ar->spectral.config.count);\n\n\targ.vdev_id = vdev_id;\n\targ.scan_count = count;\n\targ.scan_period = WMI_SPECTRAL_PERIOD_DEFAULT;\n\targ.scan_priority = WMI_SPECTRAL_PRIORITY_DEFAULT;\n\targ.scan_fft_size = ar->spectral.config.fft_size;\n\targ.scan_gc_ena = WMI_SPECTRAL_GC_ENA_DEFAULT;\n\targ.scan_restart_ena = WMI_SPECTRAL_RESTART_ENA_DEFAULT;\n\targ.scan_noise_floor_ref = WMI_SPECTRAL_NOISE_FLOOR_REF_DEFAULT;\n\targ.scan_init_delay = WMI_SPECTRAL_INIT_DELAY_DEFAULT;\n\targ.scan_nb_tone_thr = WMI_SPECTRAL_NB_TONE_THR_DEFAULT;\n\targ.scan_str_bin_thr = WMI_SPECTRAL_STR_BIN_THR_DEFAULT;\n\targ.scan_wb_rpt_mode = WMI_SPECTRAL_WB_RPT_MODE_DEFAULT;\n\targ.scan_rssi_rpt_mode = WMI_SPECTRAL_RSSI_RPT_MODE_DEFAULT;\n\targ.scan_rssi_thr = WMI_SPECTRAL_RSSI_THR_DEFAULT;\n\targ.scan_pwr_format = WMI_SPECTRAL_PWR_FORMAT_DEFAULT;\n\targ.scan_rpt_mode = WMI_SPECTRAL_RPT_MODE_DEFAULT;\n\targ.scan_bin_scale = WMI_SPECTRAL_BIN_SCALE_DEFAULT;\n\targ.scan_dbm_adj = WMI_SPECTRAL_DBM_ADJ_DEFAULT;\n\targ.scan_chn_mask = WMI_SPECTRAL_CHN_MASK_DEFAULT;\n\n\tres = ath10k_wmi_vdev_spectral_conf(ar, &arg);\n\tif (res < 0) {\n\t\tath10k_warn(ar, \"failed to configure spectral scan: %d\\n\", res);\n\t\treturn res;\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t read_file_spec_scan_ctl(struct file *file, char __user *user_buf,\n\t\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct ath10k *ar = file->private_data;\n\tchar *mode = \"\";\n\tsize_t len;\n\tenum ath10k_spectral_mode spectral_mode;\n\n\tmutex_lock(&ar->conf_mutex);\n\tspectral_mode = ar->spectral.mode;\n\tmutex_unlock(&ar->conf_mutex);\n\n\tswitch (spectral_mode) {\n\tcase SPECTRAL_DISABLED:\n\t\tmode = \"disable\";\n\t\tbreak;\n\tcase SPECTRAL_BACKGROUND:\n\t\tmode = \"background\";\n\t\tbreak;\n\tcase SPECTRAL_MANUAL:\n\t\tmode = \"manual\";\n\t\tbreak;\n\t}\n\n\tlen = strlen(mode);\n\treturn simple_read_from_buffer(user_buf, count, ppos, mode, len);\n}\n\nstatic ssize_t write_file_spec_scan_ctl(struct file *file,\n\t\t\t\t\tconst char __user *user_buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct ath10k *ar = file->private_data;\n\tchar buf[32];\n\tssize_t len;\n\tint res;\n\n\tlen = min(count, sizeof(buf) - 1);\n\tif (copy_from_user(buf, user_buf, len))\n\t\treturn -EFAULT;\n\n\tbuf[len] = '\\0';\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (strncmp(\"trigger\", buf, 7) == 0) {\n\t\tif (ar->spectral.mode == SPECTRAL_MANUAL ||\n\t\t    ar->spectral.mode == SPECTRAL_BACKGROUND) {\n\t\t\t \n\t\t\tres = ath10k_spectral_scan_config(ar,\n\t\t\t\t\t\t\t  ar->spectral.mode);\n\t\t\tif (res < 0) {\n\t\t\t\tath10k_warn(ar, \"failed to reconfigure spectral scan: %d\\n\",\n\t\t\t\t\t    res);\n\t\t\t}\n\t\t\tres = ath10k_spectral_scan_trigger(ar);\n\t\t\tif (res < 0) {\n\t\t\t\tath10k_warn(ar, \"failed to trigger spectral scan: %d\\n\",\n\t\t\t\t\t    res);\n\t\t\t}\n\t\t} else {\n\t\t\tres = -EINVAL;\n\t\t}\n\t} else if (strncmp(\"background\", buf, 10) == 0) {\n\t\tres = ath10k_spectral_scan_config(ar, SPECTRAL_BACKGROUND);\n\t} else if (strncmp(\"manual\", buf, 6) == 0) {\n\t\tres = ath10k_spectral_scan_config(ar, SPECTRAL_MANUAL);\n\t} else if (strncmp(\"disable\", buf, 7) == 0) {\n\t\tres = ath10k_spectral_scan_config(ar, SPECTRAL_DISABLED);\n\t} else {\n\t\tres = -EINVAL;\n\t}\n\n\tmutex_unlock(&ar->conf_mutex);\n\n\tif (res < 0)\n\t\treturn res;\n\n\treturn count;\n}\n\nstatic const struct file_operations fops_spec_scan_ctl = {\n\t.read = read_file_spec_scan_ctl,\n\t.write = write_file_spec_scan_ctl,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t read_file_spectral_count(struct file *file,\n\t\t\t\t\tchar __user *user_buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct ath10k *ar = file->private_data;\n\tchar buf[32];\n\tsize_t len;\n\tu8 spectral_count;\n\n\tmutex_lock(&ar->conf_mutex);\n\tspectral_count = ar->spectral.config.count;\n\tmutex_unlock(&ar->conf_mutex);\n\n\tlen = sprintf(buf, \"%d\\n\", spectral_count);\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic ssize_t write_file_spectral_count(struct file *file,\n\t\t\t\t\t const char __user *user_buf,\n\t\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct ath10k *ar = file->private_data;\n\tunsigned long val;\n\tchar buf[32];\n\tssize_t len;\n\n\tlen = min(count, sizeof(buf) - 1);\n\tif (copy_from_user(buf, user_buf, len))\n\t\treturn -EFAULT;\n\n\tbuf[len] = '\\0';\n\tif (kstrtoul(buf, 0, &val))\n\t\treturn -EINVAL;\n\n\tif (val > 255)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ar->conf_mutex);\n\tar->spectral.config.count = val;\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn count;\n}\n\nstatic const struct file_operations fops_spectral_count = {\n\t.read = read_file_spectral_count,\n\t.write = write_file_spectral_count,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t read_file_spectral_bins(struct file *file,\n\t\t\t\t       char __user *user_buf,\n\t\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct ath10k *ar = file->private_data;\n\tchar buf[32];\n\tunsigned int bins, fft_size, bin_scale;\n\tsize_t len;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tfft_size = ar->spectral.config.fft_size;\n\tbin_scale = WMI_SPECTRAL_BIN_SCALE_DEFAULT;\n\tbins = 1 << (fft_size - bin_scale);\n\n\tmutex_unlock(&ar->conf_mutex);\n\n\tlen = sprintf(buf, \"%d\\n\", bins);\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic ssize_t write_file_spectral_bins(struct file *file,\n\t\t\t\t\tconst char __user *user_buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct ath10k *ar = file->private_data;\n\tunsigned long val;\n\tchar buf[32];\n\tssize_t len;\n\n\tlen = min(count, sizeof(buf) - 1);\n\tif (copy_from_user(buf, user_buf, len))\n\t\treturn -EFAULT;\n\n\tbuf[len] = '\\0';\n\tif (kstrtoul(buf, 0, &val))\n\t\treturn -EINVAL;\n\n\tif (val < 64 || val > SPECTRAL_ATH10K_MAX_NUM_BINS)\n\t\treturn -EINVAL;\n\n\tif (!is_power_of_2(val))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ar->conf_mutex);\n\tar->spectral.config.fft_size = ilog2(val);\n\tar->spectral.config.fft_size += WMI_SPECTRAL_BIN_SCALE_DEFAULT;\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn count;\n}\n\nstatic const struct file_operations fops_spectral_bins = {\n\t.read = read_file_spectral_bins,\n\t.write = write_file_spectral_bins,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic struct dentry *create_buf_file_handler(const char *filename,\n\t\t\t\t\t      struct dentry *parent,\n\t\t\t\t\t      umode_t mode,\n\t\t\t\t\t      struct rchan_buf *buf,\n\t\t\t\t\t      int *is_global)\n{\n\tstruct dentry *buf_file;\n\n\tbuf_file = debugfs_create_file(filename, mode, parent, buf,\n\t\t\t\t       &relay_file_operations);\n\tif (IS_ERR(buf_file))\n\t\treturn NULL;\n\n\t*is_global = 1;\n\treturn buf_file;\n}\n\nstatic int remove_buf_file_handler(struct dentry *dentry)\n{\n\tdebugfs_remove(dentry);\n\n\treturn 0;\n}\n\nstatic const struct rchan_callbacks rfs_spec_scan_cb = {\n\t.create_buf_file = create_buf_file_handler,\n\t.remove_buf_file = remove_buf_file_handler,\n};\n\nint ath10k_spectral_start(struct ath10k *ar)\n{\n\tstruct ath10k_vif *arvif;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tlist_for_each_entry(arvif, &ar->arvifs, list)\n\t\tarvif->spectral_enabled = 0;\n\n\tar->spectral.mode = SPECTRAL_DISABLED;\n\tar->spectral.config.count = WMI_SPECTRAL_COUNT_DEFAULT;\n\tar->spectral.config.fft_size = WMI_SPECTRAL_FFT_SIZE_DEFAULT;\n\n\treturn 0;\n}\n\nint ath10k_spectral_vif_stop(struct ath10k_vif *arvif)\n{\n\tif (!arvif->spectral_enabled)\n\t\treturn 0;\n\n\treturn ath10k_spectral_scan_config(arvif->ar, SPECTRAL_DISABLED);\n}\n\nint ath10k_spectral_create(struct ath10k *ar)\n{\n\t \n\tar->spectral.rfs_chan_spec_scan = relay_open(\"spectral_scan\",\n\t\t\t\t\t\t     ar->debug.debugfs_phy,\n\t\t\t\t\t\t     1140, 2500,\n\t\t\t\t\t\t     &rfs_spec_scan_cb, NULL);\n\tdebugfs_create_file(\"spectral_scan_ctl\",\n\t\t\t    0600,\n\t\t\t    ar->debug.debugfs_phy, ar,\n\t\t\t    &fops_spec_scan_ctl);\n\tdebugfs_create_file(\"spectral_count\",\n\t\t\t    0600,\n\t\t\t    ar->debug.debugfs_phy, ar,\n\t\t\t    &fops_spectral_count);\n\tdebugfs_create_file(\"spectral_bins\",\n\t\t\t    0600,\n\t\t\t    ar->debug.debugfs_phy, ar,\n\t\t\t    &fops_spectral_bins);\n\n\treturn 0;\n}\n\nvoid ath10k_spectral_destroy(struct ath10k *ar)\n{\n\tif (ar->spectral.rfs_chan_spec_scan) {\n\t\trelay_close(ar->spectral.rfs_chan_spec_scan);\n\t\tar->spectral.rfs_chan_spec_scan = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}