{
  "module_name": "usb.c",
  "hash_id": "6b2e053b6b5e3495a405f25aded18725463fd4f752d4a25bcd97b3b6c5bac571",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath10k/usb.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/usb.h>\n\n#include \"debug.h\"\n#include \"core.h\"\n#include \"bmi.h\"\n#include \"hif.h\"\n#include \"htc.h\"\n#include \"usb.h\"\n\nstatic void ath10k_usb_post_recv_transfers(struct ath10k *ar,\n\t\t\t\t\t   struct ath10k_usb_pipe *recv_pipe);\n\n \n\nstatic inline enum ath10k_htc_ep_id\neid_from_htc_hdr(struct ath10k_htc_hdr *htc_hdr)\n{\n\treturn (enum ath10k_htc_ep_id)htc_hdr->eid;\n}\n\nstatic inline bool is_trailer_only_msg(struct ath10k_htc_hdr *htc_hdr)\n{\n\treturn __le16_to_cpu(htc_hdr->len) == htc_hdr->trailer_len;\n}\n\n \nstatic struct ath10k_urb_context *\nath10k_usb_alloc_urb_from_pipe(struct ath10k_usb_pipe *pipe)\n{\n\tstruct ath10k_urb_context *urb_context = NULL;\n\tunsigned long flags;\n\n\t \n\tif (!pipe->ar_usb)\n\t\treturn NULL;\n\n\tspin_lock_irqsave(&pipe->ar_usb->cs_lock, flags);\n\tif (!list_empty(&pipe->urb_list_head)) {\n\t\turb_context = list_first_entry(&pipe->urb_list_head,\n\t\t\t\t\t       struct ath10k_urb_context, link);\n\t\tlist_del(&urb_context->link);\n\t\tpipe->urb_cnt--;\n\t}\n\tspin_unlock_irqrestore(&pipe->ar_usb->cs_lock, flags);\n\n\treturn urb_context;\n}\n\nstatic void ath10k_usb_free_urb_to_pipe(struct ath10k_usb_pipe *pipe,\n\t\t\t\t\tstruct ath10k_urb_context *urb_context)\n{\n\tunsigned long flags;\n\n\t \n\tif (!pipe->ar_usb)\n\t\treturn;\n\n\tspin_lock_irqsave(&pipe->ar_usb->cs_lock, flags);\n\n\tpipe->urb_cnt++;\n\tlist_add(&urb_context->link, &pipe->urb_list_head);\n\n\tspin_unlock_irqrestore(&pipe->ar_usb->cs_lock, flags);\n}\n\nstatic void ath10k_usb_cleanup_recv_urb(struct ath10k_urb_context *urb_context)\n{\n\tdev_kfree_skb(urb_context->skb);\n\turb_context->skb = NULL;\n\n\tath10k_usb_free_urb_to_pipe(urb_context->pipe, urb_context);\n}\n\nstatic void ath10k_usb_free_pipe_resources(struct ath10k *ar,\n\t\t\t\t\t   struct ath10k_usb_pipe *pipe)\n{\n\tstruct ath10k_urb_context *urb_context;\n\n\tif (!pipe->ar_usb) {\n\t\t \n\t\treturn;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_USB,\n\t\t   \"usb free resources lpipe %d hpipe 0x%x urbs %d avail %d\\n\",\n\t\t   pipe->logical_pipe_num, pipe->usb_pipe_handle,\n\t\t   pipe->urb_alloc, pipe->urb_cnt);\n\n\tif (pipe->urb_alloc != pipe->urb_cnt) {\n\t\tath10k_dbg(ar, ATH10K_DBG_USB,\n\t\t\t   \"usb urb leak lpipe %d hpipe 0x%x urbs %d avail %d\\n\",\n\t\t\t   pipe->logical_pipe_num, pipe->usb_pipe_handle,\n\t\t\t   pipe->urb_alloc, pipe->urb_cnt);\n\t}\n\n\tfor (;;) {\n\t\turb_context = ath10k_usb_alloc_urb_from_pipe(pipe);\n\n\t\tif (!urb_context)\n\t\t\tbreak;\n\n\t\tkfree(urb_context);\n\t}\n}\n\nstatic void ath10k_usb_cleanup_pipe_resources(struct ath10k *ar)\n{\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\tint i;\n\n\tfor (i = 0; i < ATH10K_USB_PIPE_MAX; i++)\n\t\tath10k_usb_free_pipe_resources(ar, &ar_usb->pipes[i]);\n}\n\n \n\nstatic void ath10k_usb_recv_complete(struct urb *urb)\n{\n\tstruct ath10k_urb_context *urb_context = urb->context;\n\tstruct ath10k_usb_pipe *pipe = urb_context->pipe;\n\tstruct ath10k *ar = pipe->ar_usb->ar;\n\tstruct sk_buff *skb;\n\tint status = 0;\n\n\tath10k_dbg(ar, ATH10K_DBG_USB_BULK,\n\t\t   \"usb recv pipe %d stat %d len %d urb 0x%pK\\n\",\n\t\t   pipe->logical_pipe_num, urb->status, urb->actual_length,\n\t\t   urb);\n\n\tif (urb->status != 0) {\n\t\tstatus = -EIO;\n\t\tswitch (urb->status) {\n\t\tcase -ECONNRESET:\n\t\tcase -ENOENT:\n\t\tcase -ESHUTDOWN:\n\t\t\t \n\t\t\tstatus = -ECANCELED;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tath10k_dbg(ar, ATH10K_DBG_USB_BULK,\n\t\t\t\t   \"usb recv pipe %d ep 0x%2.2x failed: %d\\n\",\n\t\t\t\t   pipe->logical_pipe_num,\n\t\t\t\t   pipe->ep_address, urb->status);\n\t\t\tbreak;\n\t\t}\n\t\tgoto cleanup_recv_urb;\n\t}\n\n\tif (urb->actual_length == 0)\n\t\tgoto cleanup_recv_urb;\n\n\tskb = urb_context->skb;\n\n\t \n\turb_context->skb = NULL;\n\tskb_put(skb, urb->actual_length);\n\n\t \n\tskb_queue_tail(&pipe->io_comp_queue, skb);\n\tschedule_work(&pipe->io_complete_work);\n\ncleanup_recv_urb:\n\tath10k_usb_cleanup_recv_urb(urb_context);\n\n\tif (status == 0 &&\n\t    pipe->urb_cnt >= pipe->urb_cnt_thresh) {\n\t\t \n\t\tath10k_usb_post_recv_transfers(ar, pipe);\n\t}\n}\n\nstatic void ath10k_usb_transmit_complete(struct urb *urb)\n{\n\tstruct ath10k_urb_context *urb_context = urb->context;\n\tstruct ath10k_usb_pipe *pipe = urb_context->pipe;\n\tstruct ath10k *ar = pipe->ar_usb->ar;\n\tstruct sk_buff *skb;\n\n\tif (urb->status != 0) {\n\t\tath10k_dbg(ar, ATH10K_DBG_USB_BULK,\n\t\t\t   \"pipe: %d, failed:%d\\n\",\n\t\t\t   pipe->logical_pipe_num, urb->status);\n\t}\n\n\tskb = urb_context->skb;\n\turb_context->skb = NULL;\n\tath10k_usb_free_urb_to_pipe(urb_context->pipe, urb_context);\n\n\t \n\tskb_queue_tail(&pipe->io_comp_queue, skb);\n\tschedule_work(&pipe->io_complete_work);\n}\n\n \nstatic void ath10k_usb_post_recv_transfers(struct ath10k *ar,\n\t\t\t\t\t   struct ath10k_usb_pipe *recv_pipe)\n{\n\tstruct ath10k_urb_context *urb_context;\n\tstruct urb *urb;\n\tint usb_status;\n\n\tfor (;;) {\n\t\turb_context = ath10k_usb_alloc_urb_from_pipe(recv_pipe);\n\t\tif (!urb_context)\n\t\t\tbreak;\n\n\t\turb_context->skb = dev_alloc_skb(ATH10K_USB_RX_BUFFER_SIZE);\n\t\tif (!urb_context->skb)\n\t\t\tgoto err;\n\n\t\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\t\tif (!urb)\n\t\t\tgoto err;\n\n\t\tusb_fill_bulk_urb(urb,\n\t\t\t\t  recv_pipe->ar_usb->udev,\n\t\t\t\t  recv_pipe->usb_pipe_handle,\n\t\t\t\t  urb_context->skb->data,\n\t\t\t\t  ATH10K_USB_RX_BUFFER_SIZE,\n\t\t\t\t  ath10k_usb_recv_complete, urb_context);\n\n\t\tath10k_dbg(ar, ATH10K_DBG_USB_BULK,\n\t\t\t   \"usb bulk recv submit %d 0x%x ep 0x%2.2x len %d buf 0x%pK\\n\",\n\t\t\t   recv_pipe->logical_pipe_num,\n\t\t\t   recv_pipe->usb_pipe_handle, recv_pipe->ep_address,\n\t\t\t   ATH10K_USB_RX_BUFFER_SIZE, urb_context->skb);\n\n\t\tusb_anchor_urb(urb, &recv_pipe->urb_submitted);\n\t\tusb_status = usb_submit_urb(urb, GFP_ATOMIC);\n\n\t\tif (usb_status) {\n\t\t\tath10k_dbg(ar, ATH10K_DBG_USB_BULK,\n\t\t\t\t   \"usb bulk recv failed: %d\\n\",\n\t\t\t\t   usb_status);\n\t\t\tusb_unanchor_urb(urb);\n\t\t\tusb_free_urb(urb);\n\t\t\tgoto err;\n\t\t}\n\t\tusb_free_urb(urb);\n\t}\n\n\treturn;\n\nerr:\n\tath10k_usb_cleanup_recv_urb(urb_context);\n}\n\nstatic void ath10k_usb_flush_all(struct ath10k *ar)\n{\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\tint i;\n\n\tfor (i = 0; i < ATH10K_USB_PIPE_MAX; i++) {\n\t\tif (ar_usb->pipes[i].ar_usb) {\n\t\t\tusb_kill_anchored_urbs(&ar_usb->pipes[i].urb_submitted);\n\t\t\tcancel_work_sync(&ar_usb->pipes[i].io_complete_work);\n\t\t}\n\t}\n}\n\nstatic void ath10k_usb_start_recv_pipes(struct ath10k *ar)\n{\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\n\tar_usb->pipes[ATH10K_USB_PIPE_RX_DATA].urb_cnt_thresh = 1;\n\n\tath10k_usb_post_recv_transfers(ar,\n\t\t\t\t       &ar_usb->pipes[ATH10K_USB_PIPE_RX_DATA]);\n}\n\nstatic void ath10k_usb_tx_complete(struct ath10k *ar, struct sk_buff *skb)\n{\n\tstruct ath10k_htc_hdr *htc_hdr;\n\tstruct ath10k_htc_ep *ep;\n\n\thtc_hdr = (struct ath10k_htc_hdr *)skb->data;\n\tep = &ar->htc.endpoint[htc_hdr->eid];\n\tath10k_htc_notify_tx_completion(ep, skb);\n\t \n}\n\nstatic void ath10k_usb_rx_complete(struct ath10k *ar, struct sk_buff *skb)\n{\n\tstruct ath10k_htc *htc = &ar->htc;\n\tstruct ath10k_htc_hdr *htc_hdr;\n\tenum ath10k_htc_ep_id eid;\n\tstruct ath10k_htc_ep *ep;\n\tu16 payload_len;\n\tu8 *trailer;\n\tint ret;\n\n\thtc_hdr = (struct ath10k_htc_hdr *)skb->data;\n\teid = eid_from_htc_hdr(htc_hdr);\n\tep = &ar->htc.endpoint[eid];\n\n\tif (ep->service_id == 0) {\n\t\tath10k_warn(ar, \"ep %d is not connected\\n\", eid);\n\t\tgoto out_free_skb;\n\t}\n\n\tpayload_len = le16_to_cpu(htc_hdr->len);\n\tif (!payload_len) {\n\t\tath10k_warn(ar, \"zero length frame received, firmware crashed?\\n\");\n\t\tgoto out_free_skb;\n\t}\n\n\tif (payload_len < htc_hdr->trailer_len) {\n\t\tath10k_warn(ar, \"malformed frame received, firmware crashed?\\n\");\n\t\tgoto out_free_skb;\n\t}\n\n\tif (htc_hdr->flags & ATH10K_HTC_FLAG_TRAILER_PRESENT) {\n\t\ttrailer = skb->data + sizeof(*htc_hdr) + payload_len -\n\t\t\t  htc_hdr->trailer_len;\n\n\t\tret = ath10k_htc_process_trailer(htc,\n\t\t\t\t\t\t trailer,\n\t\t\t\t\t\t htc_hdr->trailer_len,\n\t\t\t\t\t\t eid,\n\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t NULL);\n\t\tif (ret)\n\t\t\tgoto out_free_skb;\n\n\t\tif (is_trailer_only_msg(htc_hdr))\n\t\t\tgoto out_free_skb;\n\n\t\t \n\t\tskb_trim(skb, skb->len - htc_hdr->trailer_len);\n\t}\n\n\tskb_pull(skb, sizeof(*htc_hdr));\n\tep->ep_ops.ep_rx_complete(ar, skb);\n\t \n\n\tif (test_bit(ATH10K_FLAG_CORE_REGISTERED, &ar->dev_flags)) {\n\t\tlocal_bh_disable();\n\t\tnapi_schedule(&ar->napi);\n\t\tlocal_bh_enable();\n\t}\n\n\treturn;\n\nout_free_skb:\n\tdev_kfree_skb(skb);\n}\n\nstatic void ath10k_usb_io_comp_work(struct work_struct *work)\n{\n\tstruct ath10k_usb_pipe *pipe = container_of(work,\n\t\t\t\t\t\t    struct ath10k_usb_pipe,\n\t\t\t\t\t\t    io_complete_work);\n\tstruct ath10k *ar = pipe->ar_usb->ar;\n\tstruct sk_buff *skb;\n\n\twhile ((skb = skb_dequeue(&pipe->io_comp_queue))) {\n\t\tif (pipe->flags & ATH10K_USB_PIPE_FLAG_TX)\n\t\t\tath10k_usb_tx_complete(ar, skb);\n\t\telse\n\t\t\tath10k_usb_rx_complete(ar, skb);\n\t}\n}\n\n#define ATH10K_USB_MAX_DIAG_CMD (sizeof(struct ath10k_usb_ctrl_diag_cmd_write))\n#define ATH10K_USB_MAX_DIAG_RESP (sizeof(struct ath10k_usb_ctrl_diag_resp_read))\n\nstatic void ath10k_usb_destroy(struct ath10k *ar)\n{\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\n\tath10k_usb_flush_all(ar);\n\tath10k_usb_cleanup_pipe_resources(ar);\n\tusb_set_intfdata(ar_usb->interface, NULL);\n\n\tkfree(ar_usb->diag_cmd_buffer);\n\tkfree(ar_usb->diag_resp_buffer);\n}\n\nstatic int ath10k_usb_hif_start(struct ath10k *ar)\n{\n\tint i;\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\n\tath10k_core_napi_enable(ar);\n\tath10k_usb_start_recv_pipes(ar);\n\n\t \n\tfor (i = ATH10K_USB_PIPE_TX_CTRL;\n\t     i <= ATH10K_USB_PIPE_TX_DATA_HP; i++) {\n\t\tar_usb->pipes[i].urb_cnt_thresh =\n\t\t    ar_usb->pipes[i].urb_alloc / 2;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_usb_hif_tx_sg(struct ath10k *ar, u8 pipe_id,\n\t\t\t\tstruct ath10k_hif_sg_item *items, int n_items)\n{\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\tstruct ath10k_usb_pipe *pipe = &ar_usb->pipes[pipe_id];\n\tstruct ath10k_urb_context *urb_context;\n\tstruct sk_buff *skb;\n\tstruct urb *urb;\n\tint ret, i;\n\n\tfor (i = 0; i < n_items; i++) {\n\t\turb_context = ath10k_usb_alloc_urb_from_pipe(pipe);\n\t\tif (!urb_context) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tskb = items[i].transfer_context;\n\t\turb_context->skb = skb;\n\n\t\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\t\tif (!urb) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_free_urb_to_pipe;\n\t\t}\n\n\t\tusb_fill_bulk_urb(urb,\n\t\t\t\t  ar_usb->udev,\n\t\t\t\t  pipe->usb_pipe_handle,\n\t\t\t\t  skb->data,\n\t\t\t\t  skb->len,\n\t\t\t\t  ath10k_usb_transmit_complete, urb_context);\n\n\t\tif (!(skb->len % pipe->max_packet_size)) {\n\t\t\t \n\t\t\turb->transfer_flags |= URB_ZERO_PACKET;\n\t\t}\n\n\t\tusb_anchor_urb(urb, &pipe->urb_submitted);\n\t\tret = usb_submit_urb(urb, GFP_ATOMIC);\n\t\tif (ret) {\n\t\t\tath10k_dbg(ar, ATH10K_DBG_USB_BULK,\n\t\t\t\t   \"usb bulk transmit failed: %d\\n\", ret);\n\t\t\tusb_unanchor_urb(urb);\n\t\t\tusb_free_urb(urb);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_free_urb_to_pipe;\n\t\t}\n\n\t\tusb_free_urb(urb);\n\t}\n\n\treturn 0;\n\nerr_free_urb_to_pipe:\n\tath10k_usb_free_urb_to_pipe(urb_context->pipe, urb_context);\nerr:\n\treturn ret;\n}\n\nstatic void ath10k_usb_hif_stop(struct ath10k *ar)\n{\n\tath10k_usb_flush_all(ar);\n\tath10k_core_napi_sync_disable(ar);\n}\n\nstatic u16 ath10k_usb_hif_get_free_queue_number(struct ath10k *ar, u8 pipe_id)\n{\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\n\treturn ar_usb->pipes[pipe_id].urb_cnt;\n}\n\nstatic int ath10k_usb_submit_ctrl_out(struct ath10k *ar,\n\t\t\t\t      u8 req, u16 value, u16 index, void *data,\n\t\t\t\t      u32 size)\n{\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\tu8 *buf = NULL;\n\tint ret;\n\n\tif (size > 0) {\n\t\tbuf = kmemdup(data, size, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t \n\tret = usb_control_msg(ar_usb->udev,\n\t\t\t      usb_sndctrlpipe(ar_usb->udev, 0),\n\t\t\t      req,\n\t\t\t      USB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, value, index, buf,\n\t\t\t      size, 1000);\n\n\tif (ret < 0) {\n\t\tath10k_warn(ar, \"Failed to submit usb control message: %d\\n\",\n\t\t\t    ret);\n\t\tkfree(buf);\n\t\treturn ret;\n\t}\n\n\tkfree(buf);\n\n\treturn 0;\n}\n\nstatic int ath10k_usb_submit_ctrl_in(struct ath10k *ar,\n\t\t\t\t     u8 req, u16 value, u16 index, void *data,\n\t\t\t\t     u32 size)\n{\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\tu8 *buf = NULL;\n\tint ret;\n\n\tif (size > 0) {\n\t\tbuf = kmalloc(size, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t \n\tret = usb_control_msg(ar_usb->udev,\n\t\t\t      usb_rcvctrlpipe(ar_usb->udev, 0),\n\t\t\t      req,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, value, index, buf,\n\t\t\t      size, 2000);\n\n\tif (ret < 0) {\n\t\tath10k_warn(ar, \"Failed to read usb control message: %d\\n\",\n\t\t\t    ret);\n\t\tkfree(buf);\n\t\treturn ret;\n\t}\n\n\tmemcpy((u8 *)data, buf, size);\n\n\tkfree(buf);\n\n\treturn 0;\n}\n\nstatic int ath10k_usb_ctrl_msg_exchange(struct ath10k *ar,\n\t\t\t\t\tu8 req_val, u8 *req_buf, u32 req_len,\n\t\t\t\t\tu8 resp_val, u8 *resp_buf,\n\t\t\t\t\tu32 *resp_len)\n{\n\tint ret;\n\n\t \n\tret = ath10k_usb_submit_ctrl_out(ar, req_val, 0, 0,\n\t\t\t\t\t req_buf, req_len);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tif (resp_buf) {\n\t\tret = ath10k_usb_submit_ctrl_in(ar, resp_val, 0, 0,\n\t\t\t\t\t\tresp_buf, *resp_len);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\treturn ret;\n}\n\nstatic int ath10k_usb_hif_diag_read(struct ath10k *ar, u32 address, void *buf,\n\t\t\t\t    size_t buf_len)\n{\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\tstruct ath10k_usb_ctrl_diag_cmd_read *cmd;\n\tu32 resp_len;\n\tint ret;\n\n\tif (buf_len < sizeof(struct ath10k_usb_ctrl_diag_resp_read))\n\t\treturn -EINVAL;\n\n\tcmd = (struct ath10k_usb_ctrl_diag_cmd_read *)ar_usb->diag_cmd_buffer;\n\tmemset(cmd, 0, sizeof(*cmd));\n\tcmd->cmd = ATH10K_USB_CTRL_DIAG_CC_READ;\n\tcmd->address = cpu_to_le32(address);\n\tresp_len = sizeof(struct ath10k_usb_ctrl_diag_resp_read);\n\n\tret = ath10k_usb_ctrl_msg_exchange(ar,\n\t\t\t\t\t   ATH10K_USB_CONTROL_REQ_DIAG_CMD,\n\t\t\t\t\t   (u8 *)cmd,\n\t\t\t\t\t   sizeof(*cmd),\n\t\t\t\t\t   ATH10K_USB_CONTROL_REQ_DIAG_RESP,\n\t\t\t\t\t   ar_usb->diag_resp_buffer, &resp_len);\n\tif (ret)\n\t\treturn ret;\n\n\tif (resp_len != sizeof(struct ath10k_usb_ctrl_diag_resp_read))\n\t\treturn -EMSGSIZE;\n\n\tmemcpy(buf, ar_usb->diag_resp_buffer,\n\t       sizeof(struct ath10k_usb_ctrl_diag_resp_read));\n\n\treturn 0;\n}\n\nstatic int ath10k_usb_hif_diag_write(struct ath10k *ar, u32 address,\n\t\t\t\t     const void *data, int nbytes)\n{\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\tstruct ath10k_usb_ctrl_diag_cmd_write *cmd;\n\tint ret;\n\n\tif (nbytes != sizeof(cmd->value))\n\t\treturn -EINVAL;\n\n\tcmd = (struct ath10k_usb_ctrl_diag_cmd_write *)ar_usb->diag_cmd_buffer;\n\tmemset(cmd, 0, sizeof(*cmd));\n\tcmd->cmd = cpu_to_le32(ATH10K_USB_CTRL_DIAG_CC_WRITE);\n\tcmd->address = cpu_to_le32(address);\n\tmemcpy(&cmd->value, data, nbytes);\n\n\tret = ath10k_usb_ctrl_msg_exchange(ar,\n\t\t\t\t\t   ATH10K_USB_CONTROL_REQ_DIAG_CMD,\n\t\t\t\t\t   (u8 *)cmd,\n\t\t\t\t\t   sizeof(*cmd),\n\t\t\t\t\t   0, NULL, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int ath10k_usb_bmi_exchange_msg(struct ath10k *ar,\n\t\t\t\t       void *req, u32 req_len,\n\t\t\t\t       void *resp, u32 *resp_len)\n{\n\tint ret;\n\n\tif (req) {\n\t\tret = ath10k_usb_submit_ctrl_out(ar,\n\t\t\t\t\t\t ATH10K_USB_CONTROL_REQ_SEND_BMI_CMD,\n\t\t\t\t\t\t 0, 0, req, req_len);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar,\n\t\t\t\t    \"unable to send the bmi data to the device: %d\\n\",\n\t\t\t\t    ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (resp) {\n\t\tret = ath10k_usb_submit_ctrl_in(ar,\n\t\t\t\t\t\tATH10K_USB_CONTROL_REQ_RECV_BMI_RESP,\n\t\t\t\t\t\t0, 0, resp, *resp_len);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar,\n\t\t\t\t    \"Unable to read the bmi data from the device: %d\\n\",\n\t\t\t\t    ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void ath10k_usb_hif_get_default_pipe(struct ath10k *ar,\n\t\t\t\t\t    u8 *ul_pipe, u8 *dl_pipe)\n{\n\t*ul_pipe = ATH10K_USB_PIPE_TX_CTRL;\n\t*dl_pipe = ATH10K_USB_PIPE_RX_CTRL;\n}\n\nstatic int ath10k_usb_hif_map_service_to_pipe(struct ath10k *ar, u16 svc_id,\n\t\t\t\t\t      u8 *ul_pipe, u8 *dl_pipe)\n{\n\tswitch (svc_id) {\n\tcase ATH10K_HTC_SVC_ID_RSVD_CTRL:\n\tcase ATH10K_HTC_SVC_ID_WMI_CONTROL:\n\t\t*ul_pipe = ATH10K_USB_PIPE_TX_CTRL;\n\t\t \n\t\t*dl_pipe = ATH10K_USB_PIPE_RX_DATA;\n\t\tbreak;\n\tcase ATH10K_HTC_SVC_ID_HTT_DATA_MSG:\n\t\t*ul_pipe = ATH10K_USB_PIPE_TX_DATA_LP;\n\t\t \n\t\t*dl_pipe = ATH10K_USB_PIPE_RX_DATA;\n\t\tbreak;\n\tdefault:\n\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_usb_hif_power_up(struct ath10k *ar,\n\t\t\t\t   enum ath10k_firmware_mode fw_mode)\n{\n\treturn 0;\n}\n\nstatic void ath10k_usb_hif_power_down(struct ath10k *ar)\n{\n\tath10k_usb_flush_all(ar);\n}\n\n#ifdef CONFIG_PM\n\nstatic int ath10k_usb_hif_suspend(struct ath10k *ar)\n{\n\treturn -EOPNOTSUPP;\n}\n\nstatic int ath10k_usb_hif_resume(struct ath10k *ar)\n{\n\treturn -EOPNOTSUPP;\n}\n#endif\n\nstatic const struct ath10k_hif_ops ath10k_usb_hif_ops = {\n\t.tx_sg\t\t\t= ath10k_usb_hif_tx_sg,\n\t.diag_read\t\t= ath10k_usb_hif_diag_read,\n\t.diag_write\t\t= ath10k_usb_hif_diag_write,\n\t.exchange_bmi_msg\t= ath10k_usb_bmi_exchange_msg,\n\t.start\t\t\t= ath10k_usb_hif_start,\n\t.stop\t\t\t= ath10k_usb_hif_stop,\n\t.map_service_to_pipe\t= ath10k_usb_hif_map_service_to_pipe,\n\t.get_default_pipe\t= ath10k_usb_hif_get_default_pipe,\n\t.get_free_queue_number\t= ath10k_usb_hif_get_free_queue_number,\n\t.power_up\t\t= ath10k_usb_hif_power_up,\n\t.power_down\t\t= ath10k_usb_hif_power_down,\n#ifdef CONFIG_PM\n\t.suspend\t\t= ath10k_usb_hif_suspend,\n\t.resume\t\t\t= ath10k_usb_hif_resume,\n#endif\n};\n\nstatic u8 ath10k_usb_get_logical_pipe_num(u8 ep_address, int *urb_count)\n{\n\tu8 pipe_num = ATH10K_USB_PIPE_INVALID;\n\n\tswitch (ep_address) {\n\tcase ATH10K_USB_EP_ADDR_APP_CTRL_IN:\n\t\tpipe_num = ATH10K_USB_PIPE_RX_CTRL;\n\t\t*urb_count = RX_URB_COUNT;\n\t\tbreak;\n\tcase ATH10K_USB_EP_ADDR_APP_DATA_IN:\n\t\tpipe_num = ATH10K_USB_PIPE_RX_DATA;\n\t\t*urb_count = RX_URB_COUNT;\n\t\tbreak;\n\tcase ATH10K_USB_EP_ADDR_APP_INT_IN:\n\t\tpipe_num = ATH10K_USB_PIPE_RX_INT;\n\t\t*urb_count = RX_URB_COUNT;\n\t\tbreak;\n\tcase ATH10K_USB_EP_ADDR_APP_DATA2_IN:\n\t\tpipe_num = ATH10K_USB_PIPE_RX_DATA2;\n\t\t*urb_count = RX_URB_COUNT;\n\t\tbreak;\n\tcase ATH10K_USB_EP_ADDR_APP_CTRL_OUT:\n\t\tpipe_num = ATH10K_USB_PIPE_TX_CTRL;\n\t\t*urb_count = TX_URB_COUNT;\n\t\tbreak;\n\tcase ATH10K_USB_EP_ADDR_APP_DATA_LP_OUT:\n\t\tpipe_num = ATH10K_USB_PIPE_TX_DATA_LP;\n\t\t*urb_count = TX_URB_COUNT;\n\t\tbreak;\n\tcase ATH10K_USB_EP_ADDR_APP_DATA_MP_OUT:\n\t\tpipe_num = ATH10K_USB_PIPE_TX_DATA_MP;\n\t\t*urb_count = TX_URB_COUNT;\n\t\tbreak;\n\tcase ATH10K_USB_EP_ADDR_APP_DATA_HP_OUT:\n\t\tpipe_num = ATH10K_USB_PIPE_TX_DATA_HP;\n\t\t*urb_count = TX_URB_COUNT;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\treturn pipe_num;\n}\n\nstatic int ath10k_usb_alloc_pipe_resources(struct ath10k *ar,\n\t\t\t\t\t   struct ath10k_usb_pipe *pipe,\n\t\t\t\t\t   int urb_cnt)\n{\n\tstruct ath10k_urb_context *urb_context;\n\tint i;\n\n\tINIT_LIST_HEAD(&pipe->urb_list_head);\n\tinit_usb_anchor(&pipe->urb_submitted);\n\n\tfor (i = 0; i < urb_cnt; i++) {\n\t\turb_context = kzalloc(sizeof(*urb_context), GFP_KERNEL);\n\t\tif (!urb_context)\n\t\t\treturn -ENOMEM;\n\n\t\turb_context->pipe = pipe;\n\n\t\t \n\t\tpipe->urb_alloc++;\n\t\tath10k_usb_free_urb_to_pipe(pipe, urb_context);\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_USB,\n\t\t   \"usb alloc resources lpipe %d hpipe 0x%x urbs %d\\n\",\n\t\t   pipe->logical_pipe_num, pipe->usb_pipe_handle,\n\t\t   pipe->urb_alloc);\n\n\treturn 0;\n}\n\nstatic int ath10k_usb_setup_pipe_resources(struct ath10k *ar,\n\t\t\t\t\t   struct usb_interface *interface)\n{\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\tstruct usb_host_interface *iface_desc = interface->cur_altsetting;\n\tstruct usb_endpoint_descriptor *endpoint;\n\tstruct ath10k_usb_pipe *pipe;\n\tint ret, i, urbcount;\n\tu8 pipe_num;\n\n\tath10k_dbg(ar, ATH10K_DBG_USB, \"usb setting up pipes using interface\\n\");\n\n\t \n\tfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\n\t\tendpoint = &iface_desc->endpoint[i].desc;\n\n\t\tif (ATH10K_USB_IS_BULK_EP(endpoint->bmAttributes)) {\n\t\t\tath10k_dbg(ar, ATH10K_DBG_USB,\n\t\t\t\t   \"usb %s bulk ep 0x%2.2x maxpktsz %d\\n\",\n\t\t\t\t   ATH10K_USB_IS_DIR_IN\n\t\t\t\t   (endpoint->bEndpointAddress) ?\n\t\t\t\t   \"rx\" : \"tx\", endpoint->bEndpointAddress,\n\t\t\t\t   le16_to_cpu(endpoint->wMaxPacketSize));\n\t\t} else if (ATH10K_USB_IS_INT_EP(endpoint->bmAttributes)) {\n\t\t\tath10k_dbg(ar, ATH10K_DBG_USB,\n\t\t\t\t   \"usb %s int ep 0x%2.2x maxpktsz %d interval %d\\n\",\n\t\t\t\t   ATH10K_USB_IS_DIR_IN\n\t\t\t\t   (endpoint->bEndpointAddress) ?\n\t\t\t\t   \"rx\" : \"tx\", endpoint->bEndpointAddress,\n\t\t\t\t   le16_to_cpu(endpoint->wMaxPacketSize),\n\t\t\t\t   endpoint->bInterval);\n\t\t} else if (ATH10K_USB_IS_ISOC_EP(endpoint->bmAttributes)) {\n\t\t\t \n\t\t\tath10k_dbg(ar, ATH10K_DBG_USB,\n\t\t\t\t   \"usb %s isoc ep 0x%2.2x maxpktsz %d interval %d\\n\",\n\t\t\t\t   ATH10K_USB_IS_DIR_IN\n\t\t\t\t   (endpoint->bEndpointAddress) ?\n\t\t\t\t   \"rx\" : \"tx\", endpoint->bEndpointAddress,\n\t\t\t\t   le16_to_cpu(endpoint->wMaxPacketSize),\n\t\t\t\t   endpoint->bInterval);\n\t\t}\n\n\t\t \n\t\tif (usb_endpoint_maxp(endpoint) == 0)\n\t\t\tcontinue;\n\n\t\turbcount = 0;\n\n\t\tpipe_num =\n\t\t    ath10k_usb_get_logical_pipe_num(endpoint->bEndpointAddress,\n\t\t\t\t\t\t    &urbcount);\n\t\tif (pipe_num == ATH10K_USB_PIPE_INVALID)\n\t\t\tcontinue;\n\n\t\tpipe = &ar_usb->pipes[pipe_num];\n\t\tif (pipe->ar_usb)\n\t\t\t \n\t\t\tcontinue;\n\n\t\tpipe->ar_usb = ar_usb;\n\t\tpipe->logical_pipe_num = pipe_num;\n\t\tpipe->ep_address = endpoint->bEndpointAddress;\n\t\tpipe->max_packet_size = le16_to_cpu(endpoint->wMaxPacketSize);\n\n\t\tif (ATH10K_USB_IS_BULK_EP(endpoint->bmAttributes)) {\n\t\t\tif (ATH10K_USB_IS_DIR_IN(pipe->ep_address)) {\n\t\t\t\tpipe->usb_pipe_handle =\n\t\t\t\t    usb_rcvbulkpipe(ar_usb->udev,\n\t\t\t\t\t\t    pipe->ep_address);\n\t\t\t} else {\n\t\t\t\tpipe->usb_pipe_handle =\n\t\t\t\t    usb_sndbulkpipe(ar_usb->udev,\n\t\t\t\t\t\t    pipe->ep_address);\n\t\t\t}\n\t\t} else if (ATH10K_USB_IS_INT_EP(endpoint->bmAttributes)) {\n\t\t\tif (ATH10K_USB_IS_DIR_IN(pipe->ep_address)) {\n\t\t\t\tpipe->usb_pipe_handle =\n\t\t\t\t    usb_rcvintpipe(ar_usb->udev,\n\t\t\t\t\t\t   pipe->ep_address);\n\t\t\t} else {\n\t\t\t\tpipe->usb_pipe_handle =\n\t\t\t\t    usb_sndintpipe(ar_usb->udev,\n\t\t\t\t\t\t   pipe->ep_address);\n\t\t\t}\n\t\t} else if (ATH10K_USB_IS_ISOC_EP(endpoint->bmAttributes)) {\n\t\t\t \n\t\t\tif (ATH10K_USB_IS_DIR_IN(pipe->ep_address)) {\n\t\t\t\tpipe->usb_pipe_handle =\n\t\t\t\t    usb_rcvisocpipe(ar_usb->udev,\n\t\t\t\t\t\t    pipe->ep_address);\n\t\t\t} else {\n\t\t\t\tpipe->usb_pipe_handle =\n\t\t\t\t    usb_sndisocpipe(ar_usb->udev,\n\t\t\t\t\t\t    pipe->ep_address);\n\t\t\t}\n\t\t}\n\n\t\tpipe->ep_desc = endpoint;\n\n\t\tif (!ATH10K_USB_IS_DIR_IN(pipe->ep_address))\n\t\t\tpipe->flags |= ATH10K_USB_PIPE_FLAG_TX;\n\n\t\tret = ath10k_usb_alloc_pipe_resources(ar, pipe, urbcount);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_usb_create(struct ath10k *ar,\n\t\t\t     struct usb_interface *interface)\n{\n\tstruct ath10k_usb *ar_usb = ath10k_usb_priv(ar);\n\tstruct usb_device *dev = interface_to_usbdev(interface);\n\tstruct ath10k_usb_pipe *pipe;\n\tint ret, i;\n\n\tusb_set_intfdata(interface, ar_usb);\n\tspin_lock_init(&ar_usb->cs_lock);\n\tar_usb->udev = dev;\n\tar_usb->interface = interface;\n\n\tfor (i = 0; i < ATH10K_USB_PIPE_MAX; i++) {\n\t\tpipe = &ar_usb->pipes[i];\n\t\tINIT_WORK(&pipe->io_complete_work,\n\t\t\t  ath10k_usb_io_comp_work);\n\t\tskb_queue_head_init(&pipe->io_comp_queue);\n\t}\n\n\tar_usb->diag_cmd_buffer = kzalloc(ATH10K_USB_MAX_DIAG_CMD, GFP_KERNEL);\n\tif (!ar_usb->diag_cmd_buffer) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tar_usb->diag_resp_buffer = kzalloc(ATH10K_USB_MAX_DIAG_RESP,\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!ar_usb->diag_resp_buffer) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tret = ath10k_usb_setup_pipe_resources(ar, interface);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tath10k_usb_destroy(ar);\n\treturn ret;\n}\n\nstatic int ath10k_usb_napi_poll(struct napi_struct *ctx, int budget)\n{\n\tstruct ath10k *ar = container_of(ctx, struct ath10k, napi);\n\tint done;\n\n\tdone = ath10k_htt_rx_hl_indication(ar, budget);\n\tath10k_dbg(ar, ATH10K_DBG_USB, \"napi poll: done: %d, budget:%d\\n\", done, budget);\n\n\tif (done < budget)\n\t\tnapi_complete_done(ctx, done);\n\n\treturn done;\n}\n\n \nstatic int ath10k_usb_probe(struct usb_interface *interface,\n\t\t\t    const struct usb_device_id *id)\n{\n\tstruct ath10k *ar;\n\tstruct ath10k_usb *ar_usb;\n\tstruct usb_device *dev = interface_to_usbdev(interface);\n\tint ret, vendor_id, product_id;\n\tenum ath10k_hw_rev hw_rev;\n\tstruct ath10k_bus_params bus_params = {};\n\n\t \n\thw_rev = ATH10K_HW_QCA9377;\n\n\tar = ath10k_core_create(sizeof(*ar_usb), &dev->dev, ATH10K_BUS_USB,\n\t\t\t\thw_rev, &ath10k_usb_hif_ops);\n\tif (!ar) {\n\t\tdev_err(&dev->dev, \"failed to allocate core\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tnetif_napi_add(&ar->napi_dev, &ar->napi, ath10k_usb_napi_poll);\n\n\tusb_get_dev(dev);\n\tvendor_id = le16_to_cpu(dev->descriptor.idVendor);\n\tproduct_id = le16_to_cpu(dev->descriptor.idProduct);\n\n\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t   \"usb new func vendor 0x%04x product 0x%04x\\n\",\n\t\t   vendor_id, product_id);\n\n\tar_usb = ath10k_usb_priv(ar);\n\tret = ath10k_usb_create(ar, interface);\n\tif (ret)\n\t\tgoto err;\n\tar_usb->ar = ar;\n\n\tar->dev_id = product_id;\n\tar->id.vendor = vendor_id;\n\tar->id.device = product_id;\n\n\tbus_params.dev_type = ATH10K_DEV_TYPE_HL;\n\t \n\tbus_params.chip_id = 0;\n\tbus_params.hl_msdu_ids = true;\n\tret = ath10k_core_register(ar, &bus_params);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to register driver core: %d\\n\", ret);\n\t\tgoto err_usb_destroy;\n\t}\n\n\t \n\tath10k_warn(ar, \"Warning: ath10k USB support is incomplete, don't expect anything to work!\\n\");\n\n\treturn 0;\n\nerr_usb_destroy:\n\tath10k_usb_destroy(ar);\n\nerr:\n\tath10k_core_destroy(ar);\n\n\tusb_put_dev(dev);\n\n\treturn ret;\n}\n\nstatic void ath10k_usb_remove(struct usb_interface *interface)\n{\n\tstruct ath10k_usb *ar_usb;\n\n\tar_usb = usb_get_intfdata(interface);\n\tif (!ar_usb)\n\t\treturn;\n\n\tath10k_core_unregister(ar_usb->ar);\n\tnetif_napi_del(&ar_usb->ar->napi);\n\tath10k_usb_destroy(ar_usb->ar);\n\tusb_put_dev(interface_to_usbdev(interface));\n\tath10k_core_destroy(ar_usb->ar);\n}\n\n#ifdef CONFIG_PM\n\nstatic int ath10k_usb_pm_suspend(struct usb_interface *interface,\n\t\t\t\t pm_message_t message)\n{\n\tstruct ath10k_usb *ar_usb = usb_get_intfdata(interface);\n\n\tath10k_usb_flush_all(ar_usb->ar);\n\treturn 0;\n}\n\nstatic int ath10k_usb_pm_resume(struct usb_interface *interface)\n{\n\tstruct ath10k_usb *ar_usb = usb_get_intfdata(interface);\n\tstruct ath10k *ar = ar_usb->ar;\n\n\tath10k_usb_post_recv_transfers(ar,\n\t\t\t\t       &ar_usb->pipes[ATH10K_USB_PIPE_RX_DATA]);\n\n\treturn 0;\n}\n\n#else\n\n#define ath10k_usb_pm_suspend NULL\n#define ath10k_usb_pm_resume NULL\n\n#endif\n\n \nstatic struct usb_device_id ath10k_usb_ids[] = {\n\t{USB_DEVICE(0x13b1, 0x0042)},  \n\t{   },\n};\n\nMODULE_DEVICE_TABLE(usb, ath10k_usb_ids);\n\nstatic struct usb_driver ath10k_usb_driver = {\n\t.name = \"ath10k_usb\",\n\t.probe = ath10k_usb_probe,\n\t.suspend = ath10k_usb_pm_suspend,\n\t.resume = ath10k_usb_pm_resume,\n\t.disconnect = ath10k_usb_remove,\n\t.id_table = ath10k_usb_ids,\n\t.supports_autosuspend = true,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(ath10k_usb_driver);\n\nMODULE_AUTHOR(\"Atheros Communications, Inc.\");\nMODULE_DESCRIPTION(\"Driver support for Qualcomm Atheros USB 802.11ac WLAN devices\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}