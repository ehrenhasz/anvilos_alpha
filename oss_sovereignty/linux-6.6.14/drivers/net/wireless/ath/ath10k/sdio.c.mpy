{
  "module_name": "sdio.c",
  "hash_id": "2acbdfabf087b7c0c5db4f47ab0dfdfbcf71d2ebc3221a1a44b7cafd75207afd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath10k/sdio.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/mmc/card.h>\n#include <linux/mmc/mmc.h>\n#include <linux/mmc/host.h>\n#include <linux/mmc/sdio_func.h>\n#include <linux/mmc/sdio_ids.h>\n#include <linux/mmc/sdio.h>\n#include <linux/mmc/sd.h>\n#include <linux/bitfield.h>\n#include \"core.h\"\n#include \"bmi.h\"\n#include \"debug.h\"\n#include \"hif.h\"\n#include \"htc.h\"\n#include \"mac.h\"\n#include \"targaddrs.h\"\n#include \"trace.h\"\n#include \"sdio.h\"\n#include \"coredump.h\"\n\nvoid ath10k_sdio_fw_crashed_dump(struct ath10k *ar);\n\n#define ATH10K_SDIO_VSG_BUF_SIZE\t(64 * 1024)\n\n \n\nstatic inline int ath10k_sdio_calc_txrx_padded_len(struct ath10k_sdio *ar_sdio,\n\t\t\t\t\t\t   size_t len)\n{\n\treturn __ALIGN_MASK((len), ar_sdio->mbox_info.block_mask);\n}\n\nstatic inline enum ath10k_htc_ep_id pipe_id_to_eid(u8 pipe_id)\n{\n\treturn (enum ath10k_htc_ep_id)pipe_id;\n}\n\nstatic inline void ath10k_sdio_mbox_free_rx_pkt(struct ath10k_sdio_rx_data *pkt)\n{\n\tdev_kfree_skb(pkt->skb);\n\tpkt->skb = NULL;\n\tpkt->alloc_len = 0;\n\tpkt->act_len = 0;\n\tpkt->trailer_only = false;\n}\n\nstatic inline int ath10k_sdio_mbox_alloc_rx_pkt(struct ath10k_sdio_rx_data *pkt,\n\t\t\t\t\t\tsize_t act_len, size_t full_len,\n\t\t\t\t\t\tbool part_of_bundle,\n\t\t\t\t\t\tbool last_in_bundle)\n{\n\tpkt->skb = dev_alloc_skb(full_len);\n\tif (!pkt->skb)\n\t\treturn -ENOMEM;\n\n\tpkt->act_len = act_len;\n\tpkt->alloc_len = full_len;\n\tpkt->part_of_bundle = part_of_bundle;\n\tpkt->last_in_bundle = last_in_bundle;\n\tpkt->trailer_only = false;\n\n\treturn 0;\n}\n\nstatic inline bool is_trailer_only_msg(struct ath10k_sdio_rx_data *pkt)\n{\n\tbool trailer_only = false;\n\tstruct ath10k_htc_hdr *htc_hdr =\n\t\t(struct ath10k_htc_hdr *)pkt->skb->data;\n\tu16 len = __le16_to_cpu(htc_hdr->len);\n\n\tif (len == htc_hdr->trailer_len)\n\t\ttrailer_only = true;\n\n\treturn trailer_only;\n}\n\n \n\nstatic inline void ath10k_sdio_set_cmd52_arg(u32 *arg, u8 write, u8 raw,\n\t\t\t\t\t     unsigned int address,\n\t\t\t\t\t     unsigned char val)\n{\n\t*arg = FIELD_PREP(BIT(31), write) |\n\t       FIELD_PREP(BIT(27), raw) |\n\t       FIELD_PREP(BIT(26), 1) |\n\t       FIELD_PREP(GENMASK(25, 9), address) |\n\t       FIELD_PREP(BIT(8), 1) |\n\t       FIELD_PREP(GENMASK(7, 0), val);\n}\n\nstatic int ath10k_sdio_func0_cmd52_wr_byte(struct mmc_card *card,\n\t\t\t\t\t   unsigned int address,\n\t\t\t\t\t   unsigned char byte)\n{\n\tstruct mmc_command io_cmd;\n\n\tmemset(&io_cmd, 0, sizeof(io_cmd));\n\tath10k_sdio_set_cmd52_arg(&io_cmd.arg, 1, 0, address, byte);\n\tio_cmd.opcode = SD_IO_RW_DIRECT;\n\tio_cmd.flags = MMC_RSP_R5 | MMC_CMD_AC;\n\n\treturn mmc_wait_for_cmd(card->host, &io_cmd, 0);\n}\n\nstatic int ath10k_sdio_func0_cmd52_rd_byte(struct mmc_card *card,\n\t\t\t\t\t   unsigned int address,\n\t\t\t\t\t   unsigned char *byte)\n{\n\tstruct mmc_command io_cmd;\n\tint ret;\n\n\tmemset(&io_cmd, 0, sizeof(io_cmd));\n\tath10k_sdio_set_cmd52_arg(&io_cmd.arg, 0, 0, address, 0);\n\tio_cmd.opcode = SD_IO_RW_DIRECT;\n\tio_cmd.flags = MMC_RSP_R5 | MMC_CMD_AC;\n\n\tret = mmc_wait_for_cmd(card->host, &io_cmd, 0);\n\tif (!ret)\n\t\t*byte = io_cmd.resp[0];\n\n\treturn ret;\n}\n\nstatic int ath10k_sdio_config(struct ath10k *ar)\n{\n\tstruct ath10k_sdio *ar_sdio = ath10k_sdio_priv(ar);\n\tstruct sdio_func *func = ar_sdio->func;\n\tunsigned char byte, asyncintdelay = 2;\n\tint ret;\n\n\tath10k_dbg(ar, ATH10K_DBG_BOOT, \"sdio configuration\\n\");\n\n\tsdio_claim_host(func);\n\n\tbyte = 0;\n\tret = ath10k_sdio_func0_cmd52_rd_byte(func->card,\n\t\t\t\t\t      SDIO_CCCR_DRIVE_STRENGTH,\n\t\t\t\t\t      &byte);\n\n\tbyte &= ~ATH10K_SDIO_DRIVE_DTSX_MASK;\n\tbyte |= FIELD_PREP(ATH10K_SDIO_DRIVE_DTSX_MASK,\n\t\t\t   ATH10K_SDIO_DRIVE_DTSX_TYPE_D);\n\n\tret = ath10k_sdio_func0_cmd52_wr_byte(func->card,\n\t\t\t\t\t      SDIO_CCCR_DRIVE_STRENGTH,\n\t\t\t\t\t      byte);\n\n\tbyte = 0;\n\tret = ath10k_sdio_func0_cmd52_rd_byte(\n\t\tfunc->card,\n\t\tCCCR_SDIO_DRIVER_STRENGTH_ENABLE_ADDR,\n\t\t&byte);\n\n\tbyte |= (CCCR_SDIO_DRIVER_STRENGTH_ENABLE_A |\n\t\t CCCR_SDIO_DRIVER_STRENGTH_ENABLE_C |\n\t\t CCCR_SDIO_DRIVER_STRENGTH_ENABLE_D);\n\n\tret = ath10k_sdio_func0_cmd52_wr_byte(func->card,\n\t\t\t\t\t      CCCR_SDIO_DRIVER_STRENGTH_ENABLE_ADDR,\n\t\t\t\t\t      byte);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to enable driver strength: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tbyte = 0;\n\tret = ath10k_sdio_func0_cmd52_rd_byte(func->card,\n\t\t\t\t\t      CCCR_SDIO_IRQ_MODE_REG_SDIO3,\n\t\t\t\t\t      &byte);\n\n\tbyte |= SDIO_IRQ_MODE_ASYNC_4BIT_IRQ_SDIO3;\n\n\tret = ath10k_sdio_func0_cmd52_wr_byte(func->card,\n\t\t\t\t\t      CCCR_SDIO_IRQ_MODE_REG_SDIO3,\n\t\t\t\t\t      byte);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to enable 4-bit async irq mode: %d\\n\",\n\t\t\t    ret);\n\t\tgoto out;\n\t}\n\n\tbyte = 0;\n\tret = ath10k_sdio_func0_cmd52_rd_byte(func->card,\n\t\t\t\t\t      CCCR_SDIO_ASYNC_INT_DELAY_ADDRESS,\n\t\t\t\t\t      &byte);\n\n\tbyte &= ~CCCR_SDIO_ASYNC_INT_DELAY_MASK;\n\tbyte |= FIELD_PREP(CCCR_SDIO_ASYNC_INT_DELAY_MASK, asyncintdelay);\n\n\tret = ath10k_sdio_func0_cmd52_wr_byte(func->card,\n\t\t\t\t\t      CCCR_SDIO_ASYNC_INT_DELAY_ADDRESS,\n\t\t\t\t\t      byte);\n\n\t \n\tfunc->enable_timeout = 100;\n\n\tret = sdio_set_block_size(func, ar_sdio->mbox_info.block_size);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set sdio block size to %d: %d\\n\",\n\t\t\t    ar_sdio->mbox_info.block_size, ret);\n\t\tgoto out;\n\t}\n\nout:\n\tsdio_release_host(func);\n\treturn ret;\n}\n\nstatic int ath10k_sdio_write32(struct ath10k *ar, u32 addr, u32 val)\n{\n\tstruct ath10k_sdio *ar_sdio = ath10k_sdio_priv(ar);\n\tstruct sdio_func *func = ar_sdio->func;\n\tint ret;\n\n\tsdio_claim_host(func);\n\n\tsdio_writel(func, val, addr, &ret);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to write 0x%x to address 0x%x: %d\\n\",\n\t\t\t    val, addr, ret);\n\t\tgoto out;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_SDIO, \"sdio write32 addr 0x%x val 0x%x\\n\",\n\t\t   addr, val);\n\nout:\n\tsdio_release_host(func);\n\n\treturn ret;\n}\n\nstatic int ath10k_sdio_writesb32(struct ath10k *ar, u32 addr, u32 val)\n{\n\tstruct ath10k_sdio *ar_sdio = ath10k_sdio_priv(ar);\n\tstruct sdio_func *func = ar_sdio->func;\n\t__le32 *buf;\n\tint ret;\n\n\tbuf = kzalloc(sizeof(*buf), GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t*buf = cpu_to_le32(val);\n\n\tsdio_claim_host(func);\n\n\tret = sdio_writesb(func, addr, buf, sizeof(*buf));\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to write value 0x%x to fixed sb address 0x%x: %d\\n\",\n\t\t\t    val, addr, ret);\n\t\tgoto out;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_SDIO, \"sdio writesb32 addr 0x%x val 0x%x\\n\",\n\t\t   addr, val);\n\nout:\n\tsdio_release_host(func);\n\n\tkfree(buf);\n\n\treturn ret;\n}\n\nstatic int ath10k_sdio_read32(struct ath10k *ar, u32 addr, u32 *val)\n{\n\tstruct ath10k_sdio *ar_sdio = ath10k_sdio_priv(ar);\n\tstruct sdio_func *func = ar_sdio->func;\n\tint ret;\n\n\tsdio_claim_host(func);\n\t*val = sdio_readl(func, addr, &ret);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to read from address 0x%x: %d\\n\",\n\t\t\t    addr, ret);\n\t\tgoto out;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_SDIO, \"sdio read32 addr 0x%x val 0x%x\\n\",\n\t\t   addr, *val);\n\nout:\n\tsdio_release_host(func);\n\n\treturn ret;\n}\n\nstatic int ath10k_sdio_read(struct ath10k *ar, u32 addr, void *buf, size_t len)\n{\n\tstruct ath10k_sdio *ar_sdio = ath10k_sdio_priv(ar);\n\tstruct sdio_func *func = ar_sdio->func;\n\tint ret;\n\n\tsdio_claim_host(func);\n\n\tret = sdio_memcpy_fromio(func, buf, addr, len);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to read from address 0x%x: %d\\n\",\n\t\t\t    addr, ret);\n\t\tgoto out;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_SDIO, \"sdio read addr 0x%x buf 0x%p len %zu\\n\",\n\t\t   addr, buf, len);\n\tath10k_dbg_dump(ar, ATH10K_DBG_SDIO_DUMP, NULL, \"sdio read \", buf, len);\n\nout:\n\tsdio_release_host(func);\n\n\treturn ret;\n}\n\nstatic int ath10k_sdio_write(struct ath10k *ar, u32 addr, const void *buf, size_t len)\n{\n\tstruct ath10k_sdio *ar_sdio = ath10k_sdio_priv(ar);\n\tstruct sdio_func *func = ar_sdio->func;\n\tint ret;\n\n\tsdio_claim_host(func);\n\n\t \n\tret = sdio_memcpy_toio(func, addr, (void *)buf, len);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to write to address 0x%x: %d\\n\",\n\t\t\t    addr, ret);\n\t\tgoto out;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_SDIO, \"sdio write addr 0x%x buf 0x%p len %zu\\n\",\n\t\t   addr, buf, len);\n\tath10k_dbg_dump(ar, ATH10K_DBG_SDIO_DUMP, NULL, \"sdio write \", buf, len);\n\nout:\n\tsdio_release_host(func);\n\n\treturn ret;\n}\n\nstatic int ath10k_sdio_readsb(struct ath10k *ar, u32 addr, void *buf, size_t len)\n{\n\tstruct ath10k_sdio *ar_sdio = ath10k_sdio_priv(ar);\n\tstruct sdio_func *func = ar_sdio->func;\n\tint ret;\n\n\tsdio_claim_host(func);\n\n\tlen = round_down(len, ar_sdio->mbox_info.block_size);\n\n\tret = sdio_readsb(func, buf, addr, len);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to read from fixed (sb) address 0x%x: %d\\n\",\n\t\t\t    addr, ret);\n\t\tgoto out;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_SDIO, \"sdio readsb addr 0x%x buf 0x%p len %zu\\n\",\n\t\t   addr, buf, len);\n\tath10k_dbg_dump(ar, ATH10K_DBG_SDIO_DUMP, NULL, \"sdio readsb \", buf, len);\n\nout:\n\tsdio_release_host(func);\n\n\treturn ret;\n}\n\n \n\nstatic int ath10k_sdio_mbox_rx_process_packet(struct ath10k *ar,\n\t\t\t\t\t      struct ath10k_sdio_rx_data *pkt,\n\t\t\t\t\t      u32 *lookaheads,\n\t\t\t\t\t      int *n_lookaheads)\n{\n\tstruct ath10k_htc *htc = &ar->htc;\n\tstruct sk_buff *skb = pkt->skb;\n\tstruct ath10k_htc_hdr *htc_hdr = (struct ath10k_htc_hdr *)skb->data;\n\tbool trailer_present = htc_hdr->flags & ATH10K_HTC_FLAG_TRAILER_PRESENT;\n\tenum ath10k_htc_ep_id eid;\n\tu8 *trailer;\n\tint ret;\n\n\tif (trailer_present) {\n\t\ttrailer = skb->data + skb->len - htc_hdr->trailer_len;\n\n\t\teid = pipe_id_to_eid(htc_hdr->eid);\n\n\t\tret = ath10k_htc_process_trailer(htc,\n\t\t\t\t\t\t trailer,\n\t\t\t\t\t\t htc_hdr->trailer_len,\n\t\t\t\t\t\t eid,\n\t\t\t\t\t\t lookaheads,\n\t\t\t\t\t\t n_lookaheads);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (is_trailer_only_msg(pkt))\n\t\t\tpkt->trailer_only = true;\n\n\t\tskb_trim(skb, skb->len - htc_hdr->trailer_len);\n\t}\n\n\tskb_pull(skb, sizeof(*htc_hdr));\n\n\treturn 0;\n}\n\nstatic int ath10k_sdio_mbox_rx_process_packets(struct ath10k *ar,\n\t\t\t\t\t       u32 lookaheads[],\n\t\t\t\t\t       int *n_lookahead)\n{\n\tstruct ath10k_sdio *ar_sdio = ath10k_sdio_priv(ar);\n\tstruct ath10k_htc *htc = &ar->htc;\n\tstruct ath10k_sdio_rx_data *pkt;\n\tstruct ath10k_htc_ep *ep;\n\tstruct ath10k_skb_rxcb *cb;\n\tenum ath10k_htc_ep_id id;\n\tint ret, i, *n_lookahead_local;\n\tu32 *lookaheads_local;\n\tint lookahead_idx = 0;\n\n\tfor (i = 0; i < ar_sdio->n_rx_pkts; i++) {\n\t\tlookaheads_local = lookaheads;\n\t\tn_lookahead_local = n_lookahead;\n\n\t\tid = ((struct ath10k_htc_hdr *)\n\t\t      &lookaheads[lookahead_idx++])->eid;\n\n\t\tif (id >= ATH10K_HTC_EP_COUNT) {\n\t\t\tath10k_warn(ar, \"invalid endpoint in look-ahead: %d\\n\",\n\t\t\t\t    id);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tep = &htc->endpoint[id];\n\n\t\tif (ep->service_id == 0) {\n\t\t\tath10k_warn(ar, \"ep %d is not connected\\n\", id);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tpkt = &ar_sdio->rx_pkts[i];\n\n\t\tif (pkt->part_of_bundle && !pkt->last_in_bundle) {\n\t\t\t \n\t\t\tlookahead_idx--;\n\t\t\tlookaheads_local = NULL;\n\t\t\tn_lookahead_local = NULL;\n\t\t}\n\n\t\tret = ath10k_sdio_mbox_rx_process_packet(ar,\n\t\t\t\t\t\t\t pkt,\n\t\t\t\t\t\t\t lookaheads_local,\n\t\t\t\t\t\t\t n_lookahead_local);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tif (!pkt->trailer_only) {\n\t\t\tcb = ATH10K_SKB_RXCB(pkt->skb);\n\t\t\tcb->eid = id;\n\n\t\t\tskb_queue_tail(&ar_sdio->rx_head, pkt->skb);\n\t\t\tqueue_work(ar->workqueue_aux,\n\t\t\t\t   &ar_sdio->async_work_rx);\n\t\t} else {\n\t\t\tkfree_skb(pkt->skb);\n\t\t}\n\n\t\t \n\t\tpkt->skb = NULL;\n\t\tpkt->alloc_len = 0;\n\t}\n\n\tret = 0;\n\nout:\n\t \n\tfor (; i < ar_sdio->n_rx_pkts; i++)\n\t\tath10k_sdio_mbox_free_rx_pkt(&ar_sdio->rx_pkts[i]);\n\n\treturn ret;\n}\n\nstatic int ath10k_sdio_mbox_alloc_bundle(struct ath10k *ar,\n\t\t\t\t\t struct ath10k_sdio_rx_data *rx_pkts,\n\t\t\t\t\t struct ath10k_htc_hdr *htc_hdr,\n\t\t\t\t\t size_t full_len, size_t act_len,\n\t\t\t\t\t size_t *bndl_cnt)\n{\n\tint ret, i;\n\tu8 max_msgs = ar->htc.max_msgs_per_htc_bundle;\n\n\t*bndl_cnt = ath10k_htc_get_bundle_count(max_msgs, htc_hdr->flags);\n\n\tif (*bndl_cnt > max_msgs) {\n\t\tath10k_warn(ar,\n\t\t\t    \"HTC bundle length %u exceeds maximum %u\\n\",\n\t\t\t    le16_to_cpu(htc_hdr->len),\n\t\t\t    max_msgs);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tfor (i = 0; i < *bndl_cnt; i++) {\n\t\tret = ath10k_sdio_mbox_alloc_rx_pkt(&rx_pkts[i],\n\t\t\t\t\t\t    act_len,\n\t\t\t\t\t\t    full_len,\n\t\t\t\t\t\t    true,\n\t\t\t\t\t\t    false);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_sdio_mbox_rx_alloc(struct ath10k *ar,\n\t\t\t\t     u32 lookaheads[], int n_lookaheads)\n{\n\tstruct ath10k_sdio *ar_sdio = ath10k_sdio_priv(ar);\n\tstruct ath10k_htc_hdr *htc_hdr;\n\tsize_t full_len, act_len;\n\tbool last_in_bundle;\n\tint ret, i;\n\tint pkt_cnt = 0;\n\n\tif (n_lookaheads > ATH10K_SDIO_MAX_RX_MSGS) {\n\t\tath10k_warn(ar, \"the total number of pkts to be fetched (%u) exceeds maximum %u\\n\",\n\t\t\t    n_lookaheads, ATH10K_SDIO_MAX_RX_MSGS);\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tfor (i = 0; i < n_lookaheads; i++) {\n\t\thtc_hdr = (struct ath10k_htc_hdr *)&lookaheads[i];\n\t\tlast_in_bundle = false;\n\n\t\tif (le16_to_cpu(htc_hdr->len) > ATH10K_HTC_MBOX_MAX_PAYLOAD_LENGTH) {\n\t\t\tath10k_warn(ar, \"payload length %d exceeds max htc length: %zu\\n\",\n\t\t\t\t    le16_to_cpu(htc_hdr->len),\n\t\t\t\t    ATH10K_HTC_MBOX_MAX_PAYLOAD_LENGTH);\n\t\t\tret = -ENOMEM;\n\n\t\t\tath10k_core_start_recovery(ar);\n\t\t\tath10k_warn(ar, \"exceeds length, start recovery\\n\");\n\n\t\t\tgoto err;\n\t\t}\n\n\t\tact_len = le16_to_cpu(htc_hdr->len) + sizeof(*htc_hdr);\n\t\tfull_len = ath10k_sdio_calc_txrx_padded_len(ar_sdio, act_len);\n\n\t\tif (full_len > ATH10K_SDIO_MAX_BUFFER_SIZE) {\n\t\t\tath10k_warn(ar, \"rx buffer requested with invalid htc_hdr length (%d, 0x%x): %d\\n\",\n\t\t\t\t    htc_hdr->eid, htc_hdr->flags,\n\t\t\t\t    le16_to_cpu(htc_hdr->len));\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (ath10k_htc_get_bundle_count(\n\t\t\tar->htc.max_msgs_per_htc_bundle, htc_hdr->flags)) {\n\t\t\t \n\t\t\tsize_t bndl_cnt;\n\n\t\t\tret = ath10k_sdio_mbox_alloc_bundle(ar,\n\t\t\t\t\t\t\t    &ar_sdio->rx_pkts[pkt_cnt],\n\t\t\t\t\t\t\t    htc_hdr,\n\t\t\t\t\t\t\t    full_len,\n\t\t\t\t\t\t\t    act_len,\n\t\t\t\t\t\t\t    &bndl_cnt);\n\n\t\t\tif (ret) {\n\t\t\t\tath10k_warn(ar, \"failed to allocate a bundle: %d\\n\",\n\t\t\t\t\t    ret);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tpkt_cnt += bndl_cnt;\n\n\t\t\t \n\t\t\tlast_in_bundle = true;\n\t\t}\n\n\t\t \n\t\tif (htc_hdr->flags & ATH10K_HTC_FLAGS_RECV_1MORE_BLOCK)\n\t\t\tfull_len += ATH10K_HIF_MBOX_BLOCK_SIZE;\n\n\t\tret = ath10k_sdio_mbox_alloc_rx_pkt(&ar_sdio->rx_pkts[pkt_cnt],\n\t\t\t\t\t\t    act_len,\n\t\t\t\t\t\t    full_len,\n\t\t\t\t\t\t    last_in_bundle,\n\t\t\t\t\t\t    last_in_bundle);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"alloc_rx_pkt error %d\\n\", ret);\n\t\t\tgoto err;\n\t\t}\n\n\t\tpkt_cnt++;\n\t}\n\n\tar_sdio->n_rx_pkts = pkt_cnt;\n\n\treturn 0;\n\nerr:\n\tfor (i = 0; i < ATH10K_SDIO_MAX_RX_MSGS; i++) {\n\t\tif (!ar_sdio->rx_pkts[i].alloc_len)\n\t\t\tbreak;\n\t\tath10k_sdio_mbox_free_rx_pkt(&ar_sdio->rx_pkts[i]);\n\t}\n\n\treturn ret;\n}\n\nstatic int ath10k_sdio_mbox_rx_fetch(struct ath10k *ar)\n{\n\tstruct ath10k_sdio *ar_sdio = ath10k_sdio_priv(ar);\n\tstruct ath10k_sdio_rx_data *pkt = &ar_sdio->rx_pkts[0];\n\tstruct sk_buff *skb = pkt->skb;\n\tstruct ath10k_htc_hdr *htc_hdr;\n\tint ret;\n\n\tret = ath10k_sdio_readsb(ar, ar_sdio->mbox_info.htc_addr,\n\t\t\t\t skb->data, pkt->alloc_len);\n\tif (ret)\n\t\tgoto err;\n\n\thtc_hdr = (struct ath10k_htc_hdr *)skb->data;\n\tpkt->act_len = le16_to_cpu(htc_hdr->len) + sizeof(*htc_hdr);\n\n\tif (pkt->act_len > pkt->alloc_len) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tskb_put(skb, pkt->act_len);\n\treturn 0;\n\nerr:\n\tar_sdio->n_rx_pkts = 0;\n\tath10k_sdio_mbox_free_rx_pkt(pkt);\n\n\treturn ret;\n}\n\nstatic int ath10k_sdio_mbox_rx_fetch_bundle(struct ath10k *ar)\n{\n\tstruct ath10k_sdio *ar_sdio = ath10k_sdio_priv(ar);\n\tstruct ath10k_sdio_rx_data *pkt;\n\tstruct ath10k_htc_hdr *htc_hdr;\n\tint ret, i;\n\tu32 pkt_offset, virt_pkt_len;\n\n\tvirt_pkt_len = 0;\n\tfor (i = 0; i < ar_sdio->n_rx_pkts; i++)\n\t\tvirt_pkt_len += ar_sdio->rx_pkts[i].alloc_len;\n\n\tif (virt_pkt_len > ATH10K_SDIO_VSG_BUF_SIZE) {\n\t\tath10k_warn(ar, \"sdio vsg buffer size limit: %d\\n\", virt_pkt_len);\n\t\tret = -E2BIG;\n\t\tgoto err;\n\t}\n\n\tret = ath10k_sdio_readsb(ar, ar_sdio->mbox_info.htc_addr,\n\t\t\t\t ar_sdio->vsg_buffer, virt_pkt_len);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to read bundle packets: %d\", ret);\n\t\tgoto err;\n\t}\n\n\tpkt_offset = 0;\n\tfor (i = 0; i < ar_sdio->n_rx_pkts; i++) {\n\t\tpkt = &ar_sdio->rx_pkts[i];\n\t\thtc_hdr = (struct ath10k_htc_hdr *)(ar_sdio->vsg_buffer + pkt_offset);\n\t\tpkt->act_len = le16_to_cpu(htc_hdr->len) + sizeof(*htc_hdr);\n\n\t\tif (pkt->act_len > pkt->alloc_len) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tskb_put_data(pkt->skb, htc_hdr, pkt->act_len);\n\t\tpkt_offset += pkt->alloc_len;\n\t}\n\n\treturn 0;\n\nerr:\n\t \n\tfor (i = 0; i < ar_sdio->n_rx_pkts; i++)\n\t\tath10k_sdio_mbox_free_rx_pkt(&ar_sdio->rx_pkts[i]);\n\n\tar_sdio->n_rx_pkts = 0;\n\n\treturn ret;\n}\n\n \n#define SDIO_MBOX_PROCESSING_TIMEOUT_HZ (20 * HZ)\n\nstatic int ath10k_sdio_mbox_rxmsg_pending_handler(struct ath10k *ar,\n\t\t\t\t\t\t  u32 msg_lookahead, bool *done)\n{\n\tstruct ath10k_sdio *ar_sdio = ath10k_sdio_priv(ar);\n\tu32 lookaheads[ATH10K_SDIO_MAX_RX_MSGS];\n\tint n_lookaheads = 1;\n\tunsigned long timeout;\n\tint ret;\n\n\t*done = true;\n\n\t \n\tlookaheads[0] = msg_lookahead;\n\n\ttimeout = jiffies + SDIO_MBOX_PROCESSING_TIMEOUT_HZ;\n\tdo {\n\t\t \n\t\tret = ath10k_sdio_mbox_rx_alloc(ar, lookaheads,\n\t\t\t\t\t\tn_lookaheads);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (ar_sdio->n_rx_pkts >= 2)\n\t\t\t \n\t\t\t*done = false;\n\n\t\tif (ar_sdio->n_rx_pkts > 1)\n\t\t\tret = ath10k_sdio_mbox_rx_fetch_bundle(ar);\n\t\telse\n\t\t\tret = ath10k_sdio_mbox_rx_fetch(ar);\n\n\t\t \n\t\tn_lookaheads = 0;\n\t\tret = ath10k_sdio_mbox_rx_process_packets(ar,\n\t\t\t\t\t\t\t  lookaheads,\n\t\t\t\t\t\t\t  &n_lookaheads);\n\n\t\tif (!n_lookaheads || ret)\n\t\t\tbreak;\n\n\t\t \n\t\t*done = false;\n\t} while (time_before(jiffies, timeout));\n\n\tif (ret && (ret != -ECANCELED))\n\t\tath10k_warn(ar, \"failed to get pending recv messages: %d\\n\",\n\t\t\t    ret);\n\n\treturn ret;\n}\n\nstatic int ath10k_sdio_mbox_proc_dbg_intr(struct ath10k *ar)\n{\n\tu32 val;\n\tint ret;\n\n\t \n\tath10k_warn(ar, \"firmware crashed\\n\");\n\n\t \n\tret = ath10k_sdio_read32(ar, MBOX_COUNT_DEC_ADDRESS, &val);\n\tif (ret)\n\t\tath10k_warn(ar, \"failed to clear debug interrupt: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int ath10k_sdio_mbox_proc_counter_intr(struct ath10k *ar)\n{\n\tstruct ath10k_sdio *ar_sdio = ath10k_sdio_priv(ar);\n\tstruct ath10k_sdio_irq_data *irq_data = &ar_sdio->irq_data;\n\tu8 counter_int_status;\n\tint ret;\n\n\tmutex_lock(&irq_data->mtx);\n\tcounter_int_status = irq_data->irq_proc_reg->counter_int_status &\n\t\t\t     irq_data->irq_en_reg->cntr_int_status_en;\n\n\t \n\tif (counter_int_status & ATH10K_SDIO_TARGET_DEBUG_INTR_MASK)\n\t\tret = ath10k_sdio_mbox_proc_dbg_intr(ar);\n\telse\n\t\tret = 0;\n\n\tmutex_unlock(&irq_data->mtx);\n\n\treturn ret;\n}\n\nstatic int ath10k_sdio_mbox_proc_err_intr(struct ath10k *ar)\n{\n\tstruct ath10k_sdio *ar_sdio = ath10k_sdio_priv(ar);\n\tstruct ath10k_sdio_irq_data *irq_data = &ar_sdio->irq_data;\n\tu8 error_int_status;\n\tint ret;\n\n\tath10k_dbg(ar, ATH10K_DBG_SDIO, \"sdio error interrupt\\n\");\n\n\terror_int_status = irq_data->irq_proc_reg->error_int_status & 0x0F;\n\tif (!error_int_status) {\n\t\tath10k_warn(ar, \"invalid error interrupt status: 0x%x\\n\",\n\t\t\t    error_int_status);\n\t\treturn -EIO;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_SDIO,\n\t\t   \"sdio error_int_status 0x%x\\n\", error_int_status);\n\n\tif (FIELD_GET(MBOX_ERROR_INT_STATUS_WAKEUP_MASK,\n\t\t      error_int_status))\n\t\tath10k_dbg(ar, ATH10K_DBG_SDIO, \"sdio interrupt error wakeup\\n\");\n\n\tif (FIELD_GET(MBOX_ERROR_INT_STATUS_RX_UNDERFLOW_MASK,\n\t\t      error_int_status))\n\t\tath10k_warn(ar, \"rx underflow interrupt error\\n\");\n\n\tif (FIELD_GET(MBOX_ERROR_INT_STATUS_TX_OVERFLOW_MASK,\n\t\t      error_int_status))\n\t\tath10k_warn(ar, \"tx overflow interrupt error\\n\");\n\n\t \n\tirq_data->irq_proc_reg->error_int_status &= ~error_int_status;\n\n\t \n\tret = ath10k_sdio_writesb32(ar, MBOX_ERROR_INT_STATUS_ADDRESS,\n\t\t\t\t    error_int_status);\n\tif (ret) {\n\t\tath10k_warn(ar, \"unable to write to error int status address: %d\\n\",\n\t\t\t    ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_sdio_mbox_proc_cpu_intr(struct ath10k *ar)\n{\n\tstruct ath10k_sdio *ar_sdio = ath10k_sdio_priv(ar);\n\tstruct ath10k_sdio_irq_data *irq_data = &ar_sdio->irq_data;\n\tu8 cpu_int_status;\n\tint ret;\n\n\tmutex_lock(&irq_data->mtx);\n\tcpu_int_status = irq_data->irq_proc_reg->cpu_int_status &\n\t\t\t irq_data->irq_en_reg->cpu_int_status_en;\n\tif (!cpu_int_status) {\n\t\tath10k_warn(ar, \"CPU interrupt status is zero\\n\");\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\tirq_data->irq_proc_reg->cpu_int_status &= ~cpu_int_status;\n\n\t \n\tret = ath10k_sdio_writesb32(ar, MBOX_CPU_INT_STATUS_ADDRESS,\n\t\t\t\t    cpu_int_status);\n\tif (ret) {\n\t\tath10k_warn(ar, \"unable to write to cpu interrupt status address: %d\\n\",\n\t\t\t    ret);\n\t\tgoto out;\n\t}\n\nout:\n\tmutex_unlock(&irq_data->mtx);\n\tif (cpu_int_status & MBOX_CPU_STATUS_ENABLE_ASSERT_MASK)\n\t\tath10k_sdio_fw_crashed_dump(ar);\n\n\treturn ret;\n}\n\nstatic int ath10k_sdio_mbox_read_int_status(struct ath10k *ar,\n\t\t\t\t\t    u8 *host_int_status,\n\t\t\t\t\t    u32 *lookahead)\n{\n\tstruct ath10k_sdio *ar_sdio = ath10k_sdio_priv(ar);\n\tstruct ath10k_sdio_irq_data *irq_data = &ar_sdio->irq_data;\n\tstruct ath10k_sdio_irq_proc_regs *irq_proc_reg = irq_data->irq_proc_reg;\n\tstruct ath10k_sdio_irq_enable_regs *irq_en_reg = irq_data->irq_en_reg;\n\tu8 htc_mbox = FIELD_PREP(ATH10K_HTC_MAILBOX_MASK, 1);\n\tint ret;\n\n\tmutex_lock(&irq_data->mtx);\n\n\t*lookahead = 0;\n\t*host_int_status = 0;\n\n\t \n\tif (!irq_en_reg->int_status_en) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t \n\tret = ath10k_sdio_read(ar, MBOX_HOST_INT_STATUS_ADDRESS,\n\t\t\t       irq_proc_reg, sizeof(*irq_proc_reg));\n\tif (ret) {\n\t\tath10k_core_start_recovery(ar);\n\t\tath10k_warn(ar, \"read int status fail, start recovery\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\t*host_int_status = irq_proc_reg->host_int_status &\n\t\t\t   irq_en_reg->int_status_en;\n\n\t \n\tif (!(*host_int_status & htc_mbox)) {\n\t\t*lookahead = 0;\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\t \n\t*host_int_status &= ~htc_mbox;\n\tif (irq_proc_reg->rx_lookahead_valid & htc_mbox) {\n\t\t*lookahead = le32_to_cpu(\n\t\t\tirq_proc_reg->rx_lookahead[ATH10K_HTC_MAILBOX]);\n\t\tif (!*lookahead)\n\t\t\tath10k_warn(ar, \"sdio mbox lookahead is zero\\n\");\n\t}\n\nout:\n\tmutex_unlock(&irq_data->mtx);\n\treturn ret;\n}\n\nstatic int ath10k_sdio_mbox_proc_pending_irqs(struct ath10k *ar,\n\t\t\t\t\t      bool *done)\n{\n\tu8 host_int_status;\n\tu32 lookahead;\n\tint ret;\n\n\t \n\n\tret = ath10k_sdio_mbox_read_int_status(ar,\n\t\t\t\t\t       &host_int_status,\n\t\t\t\t\t       &lookahead);\n\tif (ret) {\n\t\t*done = true;\n\t\tgoto out;\n\t}\n\n\tif (!host_int_status && !lookahead) {\n\t\tret = 0;\n\t\t*done = true;\n\t\tgoto out;\n\t}\n\n\tif (lookahead) {\n\t\tath10k_dbg(ar, ATH10K_DBG_SDIO,\n\t\t\t   \"sdio pending mailbox msg lookahead 0x%08x\\n\",\n\t\t\t   lookahead);\n\n\t\tret = ath10k_sdio_mbox_rxmsg_pending_handler(ar,\n\t\t\t\t\t\t\t     lookahead,\n\t\t\t\t\t\t\t     done);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\t \n\tath10k_dbg(ar, ATH10K_DBG_SDIO,\n\t\t   \"sdio host_int_status 0x%x\\n\", host_int_status);\n\n\tif (FIELD_GET(MBOX_HOST_INT_STATUS_CPU_MASK, host_int_status)) {\n\t\t \n\t\tret = ath10k_sdio_mbox_proc_cpu_intr(ar);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (FIELD_GET(MBOX_HOST_INT_STATUS_ERROR_MASK, host_int_status)) {\n\t\t \n\t\tret = ath10k_sdio_mbox_proc_err_intr(ar);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (FIELD_GET(MBOX_HOST_INT_STATUS_COUNTER_MASK, host_int_status))\n\t\t \n\t\tret = ath10k_sdio_mbox_proc_counter_intr(ar);\n\n\tret = 0;\n\nout:\n\t \n\n\tath10k_dbg(ar, ATH10K_DBG_SDIO,\n\t\t   \"sdio pending irqs done %d status %d\",\n\t\t   *done, ret);\n\n\treturn ret;\n}\n\nstatic void ath10k_sdio_set_mbox_info(struct ath10k *ar)\n{\n\tstruct ath10k_sdio *ar_sdio = ath10k_sdio_priv(ar);\n\tstruct ath10k_mbox_info *mbox_info = &ar_sdio->mbox_info;\n\tu16 device = ar_sdio->func->device, dev_id_base, dev_id_chiprev;\n\n\tmbox_info->htc_addr = ATH10K_HIF_MBOX_BASE_ADDR;\n\tmbox_info->block_size = ATH10K_HIF_MBOX_BLOCK_SIZE;\n\tmbox_info->block_mask = ATH10K_HIF_MBOX_BLOCK_SIZE - 1;\n\tmbox_info->gmbox_addr = ATH10K_HIF_GMBOX_BASE_ADDR;\n\tmbox_info->gmbox_sz = ATH10K_HIF_GMBOX_WIDTH;\n\n\tmbox_info->ext_info[0].htc_ext_addr = ATH10K_HIF_MBOX0_EXT_BASE_ADDR;\n\n\tdev_id_base = (device & 0x0F00);\n\tdev_id_chiprev = (device & 0x00FF);\n\tswitch (dev_id_base) {\n\tcase (SDIO_DEVICE_ID_ATHEROS_AR6005 & 0x0F00):\n\t\tif (dev_id_chiprev < 4)\n\t\t\tmbox_info->ext_info[0].htc_ext_sz =\n\t\t\t\tATH10K_HIF_MBOX0_EXT_WIDTH;\n\t\telse\n\t\t\t \n\t\t\tmbox_info->ext_info[0].htc_ext_sz =\n\t\t\t\tATH10K_HIF_MBOX0_EXT_WIDTH_ROME_2_0;\n\t\tbreak;\n\tcase (SDIO_DEVICE_ID_ATHEROS_QCA9377 & 0x0F00):\n\t\tmbox_info->ext_info[0].htc_ext_sz =\n\t\t\tATH10K_HIF_MBOX0_EXT_WIDTH_ROME_2_0;\n\t\tbreak;\n\tdefault:\n\t\tmbox_info->ext_info[0].htc_ext_sz =\n\t\t\t\tATH10K_HIF_MBOX0_EXT_WIDTH;\n\t}\n\n\tmbox_info->ext_info[1].htc_ext_addr =\n\t\tmbox_info->ext_info[0].htc_ext_addr +\n\t\tmbox_info->ext_info[0].htc_ext_sz +\n\t\tATH10K_HIF_MBOX_DUMMY_SPACE_SIZE;\n\tmbox_info->ext_info[1].htc_ext_sz = ATH10K_HIF_MBOX1_EXT_WIDTH;\n}\n\n \n\nstatic int ath10k_sdio_bmi_credits(struct ath10k *ar)\n{\n\tu32 addr, cmd_credits;\n\tunsigned long timeout;\n\tint ret;\n\n\t \n\taddr = MBOX_COUNT_DEC_ADDRESS + ATH10K_HIF_MBOX_NUM_MAX * 4;\n\ttimeout = jiffies + BMI_COMMUNICATION_TIMEOUT_HZ;\n\tcmd_credits = 0;\n\n\twhile (time_before(jiffies, timeout) && !cmd_credits) {\n\t\t \n\t\tret = ath10k_sdio_read32(ar, addr, &cmd_credits);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar,\n\t\t\t\t    \"unable to decrement the command credit count register: %d\\n\",\n\t\t\t\t    ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tcmd_credits &= 0xFF;\n\t}\n\n\tif (!cmd_credits) {\n\t\tath10k_warn(ar, \"bmi communication timeout\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_sdio_bmi_get_rx_lookahead(struct ath10k *ar)\n{\n\tunsigned long timeout;\n\tu32 rx_word;\n\tint ret;\n\n\ttimeout = jiffies + BMI_COMMUNICATION_TIMEOUT_HZ;\n\trx_word = 0;\n\n\twhile ((time_before(jiffies, timeout)) && !rx_word) {\n\t\tret = ath10k_sdio_read32(ar,\n\t\t\t\t\t MBOX_HOST_INT_STATUS_ADDRESS,\n\t\t\t\t\t &rx_word);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"unable to read RX_LOOKAHEAD_VALID: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\t  \n\t\trx_word &= 1;\n\t}\n\n\tif (!rx_word) {\n\t\tath10k_warn(ar, \"bmi_recv_buf FIFO empty\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int ath10k_sdio_bmi_exchange_msg(struct ath10k *ar,\n\t\t\t\t\tvoid *req, u32 req_len,\n\t\t\t\t\tvoid *resp, u32 *resp_len)\n{\n\tstruct ath10k_sdio *ar_sdio = ath10k_sdio_priv(ar);\n\tu32 addr;\n\tint ret;\n\n\tif (req) {\n\t\tret = ath10k_sdio_bmi_credits(ar);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\taddr = ar_sdio->mbox_info.htc_addr;\n\n\t\tmemcpy(ar_sdio->bmi_buf, req, req_len);\n\t\tret = ath10k_sdio_write(ar, addr, ar_sdio->bmi_buf, req_len);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar,\n\t\t\t\t    \"unable to send the bmi data to the device: %d\\n\",\n\t\t\t\t    ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (!resp || !resp_len)\n\t\t \n\t\treturn 0;\n\n\t \n\tret = ath10k_sdio_bmi_get_rx_lookahead(ar);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\taddr = ar_sdio->mbox_info.htc_addr;\n\tret = ath10k_sdio_read(ar, addr, ar_sdio->bmi_buf, *resp_len);\n\tif (ret) {\n\t\tath10k_warn(ar,\n\t\t\t    \"unable to read the bmi data from the device: %d\\n\",\n\t\t\t    ret);\n\t\treturn ret;\n\t}\n\n\tmemcpy(resp, ar_sdio->bmi_buf, *resp_len);\n\n\treturn 0;\n}\n\n \n\nstatic struct ath10k_sdio_bus_request\n*ath10k_sdio_alloc_busreq(struct ath10k *ar)\n{\n\tstruct ath10k_sdio *ar_sdio = ath10k_sdio_priv(ar);\n\tstruct ath10k_sdio_bus_request *bus_req;\n\n\tspin_lock_bh(&ar_sdio->lock);\n\n\tif (list_empty(&ar_sdio->bus_req_freeq)) {\n\t\tbus_req = NULL;\n\t\tgoto out;\n\t}\n\n\tbus_req = list_first_entry(&ar_sdio->bus_req_freeq,\n\t\t\t\t   struct ath10k_sdio_bus_request, list);\n\tlist_del(&bus_req->list);\n\nout:\n\tspin_unlock_bh(&ar_sdio->lock);\n\treturn bus_req;\n}\n\nstatic void ath10k_sdio_free_bus_req(struct ath10k *ar,\n\t\t\t\t     struct ath10k_sdio_bus_request *bus_req)\n{\n\tstruct ath10k_sdio *ar_sdio = ath10k_sdio_priv(ar);\n\n\tmemset(bus_req, 0, sizeof(*bus_req));\n\n\tspin_lock_bh(&ar_sdio->lock);\n\tlist_add_tail(&bus_req->list, &ar_sdio->bus_req_freeq);\n\tspin_unlock_bh(&ar_sdio->lock);\n}\n\nstatic void __ath10k_sdio_write_async(struct ath10k *ar,\n\t\t\t\t      struct ath10k_sdio_bus_request *req)\n{\n\tstruct ath10k_htc_ep *ep;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = req->skb;\n\tret = ath10k_sdio_write(ar, req->address, skb->data, skb->len);\n\tif (ret)\n\t\tath10k_warn(ar, \"failed to write skb to 0x%x asynchronously: %d\",\n\t\t\t    req->address, ret);\n\n\tif (req->htc_msg) {\n\t\tep = &ar->htc.endpoint[req->eid];\n\t\tath10k_htc_notify_tx_completion(ep, skb);\n\t} else if (req->comp) {\n\t\tcomplete(req->comp);\n\t}\n\n\tath10k_sdio_free_bus_req(ar, req);\n}\n\n \nstatic void ath10k_rx_indication_async_work(struct work_struct *work)\n{\n\tstruct ath10k_sdio *ar_sdio = container_of(work, struct ath10k_sdio,\n\t\t\t\t\t\t   async_work_rx);\n\tstruct ath10k *ar = ar_sdio->ar;\n\tstruct ath10k_htc_ep *ep;\n\tstruct ath10k_skb_rxcb *cb;\n\tstruct sk_buff *skb;\n\n\twhile (true) {\n\t\tskb = skb_dequeue(&ar_sdio->rx_head);\n\t\tif (!skb)\n\t\t\tbreak;\n\t\tcb = ATH10K_SKB_RXCB(skb);\n\t\tep = &ar->htc.endpoint[cb->eid];\n\t\tep->ep_ops.ep_rx_complete(ar, skb);\n\t}\n\n\tif (test_bit(ATH10K_FLAG_CORE_REGISTERED, &ar->dev_flags)) {\n\t\tlocal_bh_disable();\n\t\tnapi_schedule(&ar->napi);\n\t\tlocal_bh_enable();\n\t}\n}\n\nstatic int ath10k_sdio_read_rtc_state(struct ath10k_sdio *ar_sdio, unsigned char *state)\n{\n\tstruct ath10k *ar = ar_sdio->ar;\n\tunsigned char rtc_state = 0;\n\tint ret = 0;\n\n\trtc_state = sdio_f0_readb(ar_sdio->func, ATH10K_CIS_RTC_STATE_ADDR, &ret);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to read rtc state: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t*state = rtc_state & 0x3;\n\n\treturn ret;\n}\n\nstatic int ath10k_sdio_set_mbox_sleep(struct ath10k *ar, bool enable_sleep)\n{\n\tstruct ath10k_sdio *ar_sdio = ath10k_sdio_priv(ar);\n\tu32 val;\n\tint retry = ATH10K_CIS_READ_RETRY, ret = 0;\n\tunsigned char rtc_state = 0;\n\n\tsdio_claim_host(ar_sdio->func);\n\n\tret = ath10k_sdio_read32(ar, ATH10K_FIFO_TIMEOUT_AND_CHIP_CONTROL, &val);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to read fifo/chip control register: %d\\n\",\n\t\t\t    ret);\n\t\tgoto release;\n\t}\n\n\tif (enable_sleep) {\n\t\tval &= ATH10K_FIFO_TIMEOUT_AND_CHIP_CONTROL_DISABLE_SLEEP_OFF;\n\t\tar_sdio->mbox_state = SDIO_MBOX_SLEEP_STATE;\n\t} else {\n\t\tval |= ATH10K_FIFO_TIMEOUT_AND_CHIP_CONTROL_DISABLE_SLEEP_ON;\n\t\tar_sdio->mbox_state = SDIO_MBOX_AWAKE_STATE;\n\t}\n\n\tret = ath10k_sdio_write32(ar, ATH10K_FIFO_TIMEOUT_AND_CHIP_CONTROL, val);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to write to FIFO_TIMEOUT_AND_CHIP_CONTROL: %d\",\n\t\t\t    ret);\n\t}\n\n\tif (!enable_sleep) {\n\t\tdo {\n\t\t\tudelay(ATH10K_CIS_READ_WAIT_4_RTC_CYCLE_IN_US);\n\t\t\tret = ath10k_sdio_read_rtc_state(ar_sdio, &rtc_state);\n\n\t\t\tif (ret) {\n\t\t\t\tath10k_warn(ar, \"failed to disable mbox sleep: %d\", ret);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tath10k_dbg(ar, ATH10K_DBG_SDIO, \"sdio read rtc state: %d\\n\",\n\t\t\t\t   rtc_state);\n\n\t\t\tif (rtc_state == ATH10K_CIS_RTC_STATE_ON)\n\t\t\t\tbreak;\n\n\t\t\tudelay(ATH10K_CIS_XTAL_SETTLE_DURATION_IN_US);\n\t\t\tretry--;\n\t\t} while (retry > 0);\n\t}\n\nrelease:\n\tsdio_release_host(ar_sdio->func);\n\n\treturn ret;\n}\n\nstatic void ath10k_sdio_sleep_timer_handler(struct timer_list *t)\n{\n\tstruct ath10k_sdio *ar_sdio = from_timer(ar_sdio, t, sleep_timer);\n\n\tar_sdio->mbox_state = SDIO_MBOX_REQUEST_TO_SLEEP_STATE;\n\tqueue_work(ar_sdio->workqueue, &ar_sdio->wr_async_work);\n}\n\nstatic void ath10k_sdio_write_async_work(struct work_struct *work)\n{\n\tstruct ath10k_sdio *ar_sdio = container_of(work, struct ath10k_sdio,\n\t\t\t\t\t\t   wr_async_work);\n\tstruct ath10k *ar = ar_sdio->ar;\n\tstruct ath10k_sdio_bus_request *req, *tmp_req;\n\tstruct ath10k_mbox_info *mbox_info = &ar_sdio->mbox_info;\n\n\tspin_lock_bh(&ar_sdio->wr_async_lock);\n\n\tlist_for_each_entry_safe(req, tmp_req, &ar_sdio->wr_asyncq, list) {\n\t\tlist_del(&req->list);\n\t\tspin_unlock_bh(&ar_sdio->wr_async_lock);\n\n\t\tif (req->address >= mbox_info->htc_addr &&\n\t\t    ar_sdio->mbox_state == SDIO_MBOX_SLEEP_STATE) {\n\t\t\tath10k_sdio_set_mbox_sleep(ar, false);\n\t\t\tmod_timer(&ar_sdio->sleep_timer, jiffies +\n\t\t\t\t  msecs_to_jiffies(ATH10K_MIN_SLEEP_INACTIVITY_TIME_MS));\n\t\t}\n\n\t\t__ath10k_sdio_write_async(ar, req);\n\t\tspin_lock_bh(&ar_sdio->wr_async_lock);\n\t}\n\n\tspin_unlock_bh(&ar_sdio->wr_async_lock);\n\n\tif (ar_sdio->mbox_state == SDIO_MBOX_REQUEST_TO_SLEEP_STATE)\n\t\tath10k_sdio_set_mbox_sleep(ar, true);\n}\n\nstatic int ath10k_sdio_prep_async_req(struct ath10k *ar, u32 addr,\n\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t      struct completion *comp,\n\t\t\t\t      bool htc_msg, enum ath10k_htc_ep_id eid)\n{\n\tstruct ath10k_sdio *ar_sdio = ath10k_sdio_priv(ar);\n\tstruct ath10k_sdio_bus_request *bus_req;\n\n\t \n\tbus_req = ath10k_sdio_alloc_busreq(ar);\n\tif (!bus_req) {\n\t\tath10k_warn(ar,\n\t\t\t    \"unable to allocate bus request for async request\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tbus_req->skb = skb;\n\tbus_req->eid = eid;\n\tbus_req->address = addr;\n\tbus_req->htc_msg = htc_msg;\n\tbus_req->comp = comp;\n\n\tspin_lock_bh(&ar_sdio->wr_async_lock);\n\tlist_add_tail(&bus_req->list, &ar_sdio->wr_asyncq);\n\tspin_unlock_bh(&ar_sdio->wr_async_lock);\n\n\treturn 0;\n}\n\n \n\nstatic void ath10k_sdio_irq_handler(struct sdio_func *func)\n{\n\tstruct ath10k_sdio *ar_sdio = sdio_get_drvdata(func);\n\tstruct ath10k *ar = ar_sdio->ar;\n\tunsigned long timeout;\n\tbool done = false;\n\tint ret;\n\n\t \n\tsdio_release_host(ar_sdio->func);\n\n\ttimeout = jiffies + ATH10K_SDIO_HIF_COMMUNICATION_TIMEOUT_HZ;\n\tdo {\n\t\tret = ath10k_sdio_mbox_proc_pending_irqs(ar, &done);\n\t\tif (ret)\n\t\t\tbreak;\n\t} while (time_before(jiffies, timeout) && !done);\n\n\tath10k_mac_tx_push_pending(ar);\n\n\tsdio_claim_host(ar_sdio->func);\n\n\tif (ret && ret != -ECANCELED)\n\t\tath10k_warn(ar, \"failed to process pending SDIO interrupts: %d\\n\",\n\t\t\t    ret);\n}\n\n \n\nstatic int ath10k_sdio_disable_intrs(struct ath10k *ar)\n{\n\tstruct ath10k_sdio *ar_sdio = ath10k_sdio_priv(ar);\n\tstruct ath10k_sdio_irq_data *irq_data = &ar_sdio->irq_data;\n\tstruct ath10k_sdio_irq_enable_regs *regs = irq_data->irq_en_reg;\n\tint ret;\n\n\tmutex_lock(&irq_data->mtx);\n\n\tmemset(regs, 0, sizeof(*regs));\n\tret = ath10k_sdio_write(ar, MBOX_INT_STATUS_ENABLE_ADDRESS,\n\t\t\t\t&regs->int_status_en, sizeof(*regs));\n\tif (ret)\n\t\tath10k_warn(ar, \"unable to disable sdio interrupts: %d\\n\", ret);\n\n\tmutex_unlock(&irq_data->mtx);\n\n\treturn ret;\n}\n\nstatic int ath10k_sdio_hif_power_up(struct ath10k *ar,\n\t\t\t\t    enum ath10k_firmware_mode fw_mode)\n{\n\tstruct ath10k_sdio *ar_sdio = ath10k_sdio_priv(ar);\n\tstruct sdio_func *func = ar_sdio->func;\n\tint ret;\n\n\tif (!ar_sdio->is_disabled)\n\t\treturn 0;\n\n\tath10k_dbg(ar, ATH10K_DBG_BOOT, \"sdio power on\\n\");\n\n\tret = ath10k_sdio_config(ar);\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to config sdio: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tsdio_claim_host(func);\n\n\tret = sdio_enable_func(func);\n\tif (ret) {\n\t\tath10k_warn(ar, \"unable to enable sdio function: %d)\\n\", ret);\n\t\tsdio_release_host(func);\n\t\treturn ret;\n\t}\n\n\tsdio_release_host(func);\n\n\t \n\tmsleep(20);\n\n\tar_sdio->is_disabled = false;\n\n\tret = ath10k_sdio_disable_intrs(ar);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void ath10k_sdio_hif_power_down(struct ath10k *ar)\n{\n\tstruct ath10k_sdio *ar_sdio = ath10k_sdio_priv(ar);\n\tint ret;\n\n\tif (ar_sdio->is_disabled)\n\t\treturn;\n\n\tath10k_dbg(ar, ATH10K_DBG_BOOT, \"sdio power off\\n\");\n\n\tdel_timer_sync(&ar_sdio->sleep_timer);\n\tath10k_sdio_set_mbox_sleep(ar, true);\n\n\t \n\tsdio_claim_host(ar_sdio->func);\n\n\tret = sdio_disable_func(ar_sdio->func);\n\tif (ret) {\n\t\tath10k_warn(ar, \"unable to disable sdio function: %d\\n\", ret);\n\t\tsdio_release_host(ar_sdio->func);\n\t\treturn;\n\t}\n\n\tret = mmc_hw_reset(ar_sdio->func->card);\n\tif (ret)\n\t\tath10k_warn(ar, \"unable to reset sdio: %d\\n\", ret);\n\n\tsdio_release_host(ar_sdio->func);\n\n\tar_sdio->is_disabled = true;\n}\n\nstatic int ath10k_sdio_hif_tx_sg(struct ath10k *ar, u8 pipe_id,\n\t\t\t\t struct ath10k_hif_sg_item *items, int n_items)\n{\n\tstruct ath10k_sdio *ar_sdio = ath10k_sdio_priv(ar);\n\tenum ath10k_htc_ep_id eid;\n\tstruct sk_buff *skb;\n\tint ret, i;\n\n\teid = pipe_id_to_eid(pipe_id);\n\n\tfor (i = 0; i < n_items; i++) {\n\t\tsize_t padded_len;\n\t\tu32 address;\n\n\t\tskb = items[i].transfer_context;\n\t\tpadded_len = ath10k_sdio_calc_txrx_padded_len(ar_sdio,\n\t\t\t\t\t\t\t      skb->len);\n\t\tskb_trim(skb, padded_len);\n\n\t\t \n\t\taddress = ar_sdio->mbox_addr[eid] + ar_sdio->mbox_size[eid] -\n\t\t\t  skb->len;\n\t\tret = ath10k_sdio_prep_async_req(ar, address, skb,\n\t\t\t\t\t\t NULL, true, eid);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tqueue_work(ar_sdio->workqueue, &ar_sdio->wr_async_work);\n\n\treturn 0;\n}\n\nstatic int ath10k_sdio_enable_intrs(struct ath10k *ar)\n{\n\tstruct ath10k_sdio *ar_sdio = ath10k_sdio_priv(ar);\n\tstruct ath10k_sdio_irq_data *irq_data = &ar_sdio->irq_data;\n\tstruct ath10k_sdio_irq_enable_regs *regs = irq_data->irq_en_reg;\n\tint ret;\n\n\tmutex_lock(&irq_data->mtx);\n\n\t \n\tregs->int_status_en = FIELD_PREP(MBOX_INT_STATUS_ENABLE_ERROR_MASK, 1) |\n\t\t\t      FIELD_PREP(MBOX_INT_STATUS_ENABLE_CPU_MASK, 1) |\n\t\t\t      FIELD_PREP(MBOX_INT_STATUS_ENABLE_COUNTER_MASK, 1);\n\n\t \n\tregs->int_status_en |=\n\t\tFIELD_PREP(MBOX_INT_STATUS_ENABLE_MBOX_DATA_MASK, 1);\n\n\t \n\tregs->cpu_int_status_en = FIELD_PREP(MBOX_CPU_STATUS_ENABLE_ASSERT_MASK, 1);\n\n\t \n\tregs->err_int_status_en =\n\t\tFIELD_PREP(MBOX_ERROR_STATUS_ENABLE_RX_UNDERFLOW_MASK, 1) |\n\t\tFIELD_PREP(MBOX_ERROR_STATUS_ENABLE_TX_OVERFLOW_MASK, 1);\n\n\t \n\tregs->cntr_int_status_en =\n\t\tFIELD_PREP(MBOX_COUNTER_INT_STATUS_ENABLE_BIT_MASK,\n\t\t\t   ATH10K_SDIO_TARGET_DEBUG_INTR_MASK);\n\n\tret = ath10k_sdio_write(ar, MBOX_INT_STATUS_ENABLE_ADDRESS,\n\t\t\t\t&regs->int_status_en, sizeof(*regs));\n\tif (ret)\n\t\tath10k_warn(ar,\n\t\t\t    \"failed to update mbox interrupt status register : %d\\n\",\n\t\t\t    ret);\n\n\tmutex_unlock(&irq_data->mtx);\n\treturn ret;\n}\n\n \n\nstatic int ath10k_sdio_hif_diag_read(struct ath10k *ar, u32 address, void *buf,\n\t\t\t\t     size_t buf_len)\n{\n\tint ret;\n\tvoid *mem;\n\n\tmem = kzalloc(buf_len, GFP_KERNEL);\n\tif (!mem)\n\t\treturn -ENOMEM;\n\n\t \n\tret = ath10k_sdio_write32(ar, MBOX_WINDOW_READ_ADDR_ADDRESS, address);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set mbox window read address: %d\", ret);\n\t\tgoto out;\n\t}\n\n\t \n\tret = ath10k_sdio_read(ar, MBOX_WINDOW_DATA_ADDRESS, mem, buf_len);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to read from mbox window data address: %d\\n\",\n\t\t\t    ret);\n\t\tgoto out;\n\t}\n\n\tmemcpy(buf, mem, buf_len);\n\nout:\n\tkfree(mem);\n\n\treturn ret;\n}\n\nstatic int ath10k_sdio_diag_read32(struct ath10k *ar, u32 address,\n\t\t\t\t   u32 *value)\n{\n\t__le32 *val;\n\tint ret;\n\n\tval = kzalloc(sizeof(*val), GFP_KERNEL);\n\tif (!val)\n\t\treturn -ENOMEM;\n\n\tret = ath10k_sdio_hif_diag_read(ar, address, val, sizeof(*val));\n\tif (ret)\n\t\tgoto out;\n\n\t*value = __le32_to_cpu(*val);\n\nout:\n\tkfree(val);\n\n\treturn ret;\n}\n\nstatic int ath10k_sdio_hif_diag_write_mem(struct ath10k *ar, u32 address,\n\t\t\t\t\t  const void *data, int nbytes)\n{\n\tint ret;\n\n\t \n\tret = ath10k_sdio_write(ar, MBOX_WINDOW_DATA_ADDRESS, data, nbytes);\n\tif (ret) {\n\t\tath10k_warn(ar,\n\t\t\t    \"failed to write 0x%p to mbox window data address: %d\\n\",\n\t\t\t    data, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = ath10k_sdio_write32(ar, MBOX_WINDOW_WRITE_ADDR_ADDRESS, address);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set mbox window write address: %d\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_sdio_hif_start_post(struct ath10k *ar)\n{\n\tstruct ath10k_sdio *ar_sdio = ath10k_sdio_priv(ar);\n\tu32 addr, val;\n\tint ret = 0;\n\n\taddr = host_interest_item_address(HI_ITEM(hi_acs_flags));\n\n\tret = ath10k_sdio_diag_read32(ar, addr, &val);\n\tif (ret) {\n\t\tath10k_warn(ar, \"unable to read hi_acs_flags : %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (val & HI_ACS_FLAGS_SDIO_SWAP_MAILBOX_FW_ACK) {\n\t\tath10k_dbg(ar, ATH10K_DBG_SDIO,\n\t\t\t   \"sdio mailbox swap service enabled\\n\");\n\t\tar_sdio->swap_mbox = true;\n\t} else {\n\t\tath10k_dbg(ar, ATH10K_DBG_SDIO,\n\t\t\t   \"sdio mailbox swap service disabled\\n\");\n\t\tar_sdio->swap_mbox = false;\n\t}\n\n\tath10k_sdio_set_mbox_sleep(ar, true);\n\n\treturn 0;\n}\n\nstatic int ath10k_sdio_get_htt_tx_complete(struct ath10k *ar)\n{\n\tu32 addr, val;\n\tint ret;\n\n\taddr = host_interest_item_address(HI_ITEM(hi_acs_flags));\n\n\tret = ath10k_sdio_diag_read32(ar, addr, &val);\n\tif (ret) {\n\t\tath10k_warn(ar,\n\t\t\t    \"unable to read hi_acs_flags for htt tx comple : %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = (val & HI_ACS_FLAGS_SDIO_REDUCE_TX_COMPL_FW_ACK);\n\n\tath10k_dbg(ar, ATH10K_DBG_SDIO, \"sdio reduce tx complete fw%sack\\n\",\n\t\t   ret ? \" \" : \" not \");\n\n\treturn ret;\n}\n\n \n\nstatic int ath10k_sdio_hif_start(struct ath10k *ar)\n{\n\tstruct ath10k_sdio *ar_sdio = ath10k_sdio_priv(ar);\n\tint ret;\n\n\tath10k_core_napi_enable(ar);\n\n\t \n\tmsleep(20);\n\tret = ath10k_sdio_disable_intrs(ar);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tar_sdio->mbox_addr[0] = ar_sdio->mbox_info.ext_info[0].htc_ext_addr;\n\tar_sdio->mbox_size[0] = ar_sdio->mbox_info.ext_info[0].htc_ext_sz;\n\n\tsdio_claim_host(ar_sdio->func);\n\n\t \n\tret =  sdio_claim_irq(ar_sdio->func, ath10k_sdio_irq_handler);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to claim sdio interrupt: %d\\n\", ret);\n\t\tsdio_release_host(ar_sdio->func);\n\t\treturn ret;\n\t}\n\n\tsdio_release_host(ar_sdio->func);\n\n\tret = ath10k_sdio_enable_intrs(ar);\n\tif (ret)\n\t\tath10k_warn(ar, \"failed to enable sdio interrupts: %d\\n\", ret);\n\n\t \n\tret = ath10k_sdio_set_mbox_sleep(ar, true);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmsleep(20);\n\n\tret = ath10k_sdio_set_mbox_sleep(ar, false);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n#define SDIO_IRQ_DISABLE_TIMEOUT_HZ (3 * HZ)\n\nstatic void ath10k_sdio_irq_disable(struct ath10k *ar)\n{\n\tstruct ath10k_sdio *ar_sdio = ath10k_sdio_priv(ar);\n\tstruct ath10k_sdio_irq_data *irq_data = &ar_sdio->irq_data;\n\tstruct ath10k_sdio_irq_enable_regs *regs = irq_data->irq_en_reg;\n\tstruct sk_buff *skb;\n\tstruct completion irqs_disabled_comp;\n\tint ret;\n\n\tskb = dev_alloc_skb(sizeof(*regs));\n\tif (!skb)\n\t\treturn;\n\n\tmutex_lock(&irq_data->mtx);\n\n\tmemset(regs, 0, sizeof(*regs));  \n\tmemcpy(skb->data, regs, sizeof(*regs));\n\tskb_put(skb, sizeof(*regs));\n\n\tmutex_unlock(&irq_data->mtx);\n\n\tinit_completion(&irqs_disabled_comp);\n\tret = ath10k_sdio_prep_async_req(ar, MBOX_INT_STATUS_ENABLE_ADDRESS,\n\t\t\t\t\t skb, &irqs_disabled_comp, false, 0);\n\tif (ret)\n\t\tgoto out;\n\n\tqueue_work(ar_sdio->workqueue, &ar_sdio->wr_async_work);\n\n\t \n\tret = wait_for_completion_timeout(&irqs_disabled_comp,\n\t\t\t\t\t  SDIO_IRQ_DISABLE_TIMEOUT_HZ);\n\tif (!ret)\n\t\tath10k_warn(ar, \"sdio irq disable request timed out\\n\");\n\n\tsdio_claim_host(ar_sdio->func);\n\n\tret = sdio_release_irq(ar_sdio->func);\n\tif (ret)\n\t\tath10k_warn(ar, \"failed to release sdio interrupt: %d\\n\", ret);\n\n\tsdio_release_host(ar_sdio->func);\n\nout:\n\tkfree_skb(skb);\n}\n\nstatic void ath10k_sdio_hif_stop(struct ath10k *ar)\n{\n\tstruct ath10k_sdio_bus_request *req, *tmp_req;\n\tstruct ath10k_sdio *ar_sdio = ath10k_sdio_priv(ar);\n\tstruct sk_buff *skb;\n\n\tath10k_sdio_irq_disable(ar);\n\n\tcancel_work_sync(&ar_sdio->async_work_rx);\n\n\twhile ((skb = skb_dequeue(&ar_sdio->rx_head)))\n\t\tdev_kfree_skb_any(skb);\n\n\tcancel_work_sync(&ar_sdio->wr_async_work);\n\n\tspin_lock_bh(&ar_sdio->wr_async_lock);\n\n\t \n\tlist_for_each_entry_safe(req, tmp_req, &ar_sdio->wr_asyncq, list) {\n\t\tstruct ath10k_htc_ep *ep;\n\n\t\tlist_del(&req->list);\n\n\t\tif (req->htc_msg) {\n\t\t\tep = &ar->htc.endpoint[req->eid];\n\t\t\tath10k_htc_notify_tx_completion(ep, req->skb);\n\t\t} else if (req->skb) {\n\t\t\tkfree_skb(req->skb);\n\t\t}\n\t\tath10k_sdio_free_bus_req(ar, req);\n\t}\n\n\tspin_unlock_bh(&ar_sdio->wr_async_lock);\n\n\tath10k_core_napi_sync_disable(ar);\n}\n\n#ifdef CONFIG_PM\n\nstatic int ath10k_sdio_hif_suspend(struct ath10k *ar)\n{\n\treturn 0;\n}\n\nstatic int ath10k_sdio_hif_resume(struct ath10k *ar)\n{\n\tswitch (ar->state) {\n\tcase ATH10K_STATE_OFF:\n\t\tath10k_dbg(ar, ATH10K_DBG_SDIO,\n\t\t\t   \"sdio resume configuring sdio\\n\");\n\n\t\t \n\t\tath10k_sdio_config(ar);\n\t\tbreak;\n\n\tcase ATH10K_STATE_ON:\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic int ath10k_sdio_hif_map_service_to_pipe(struct ath10k *ar,\n\t\t\t\t\t       u16 service_id,\n\t\t\t\t\t       u8 *ul_pipe, u8 *dl_pipe)\n{\n\tstruct ath10k_sdio *ar_sdio = ath10k_sdio_priv(ar);\n\tstruct ath10k_htc *htc = &ar->htc;\n\tu32 htt_addr, wmi_addr, htt_mbox_size, wmi_mbox_size;\n\tenum ath10k_htc_ep_id eid;\n\tbool ep_found = false;\n\tint i;\n\n\t \n\tfor (i = 0; i < ATH10K_HTC_EP_COUNT; i++) {\n\t\tif (htc->endpoint[i].service_id == service_id) {\n\t\t\teid = htc->endpoint[i].eid;\n\t\t\tep_found = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!ep_found)\n\t\treturn -EINVAL;\n\n\t \n\t*ul_pipe = *dl_pipe = (u8)eid;\n\n\t \n\tif (ar_sdio->swap_mbox) {\n\t\thtt_addr = ar_sdio->mbox_info.ext_info[0].htc_ext_addr;\n\t\twmi_addr = ar_sdio->mbox_info.ext_info[1].htc_ext_addr;\n\t\thtt_mbox_size = ar_sdio->mbox_info.ext_info[0].htc_ext_sz;\n\t\twmi_mbox_size = ar_sdio->mbox_info.ext_info[1].htc_ext_sz;\n\t} else {\n\t\thtt_addr = ar_sdio->mbox_info.ext_info[1].htc_ext_addr;\n\t\twmi_addr = ar_sdio->mbox_info.ext_info[0].htc_ext_addr;\n\t\thtt_mbox_size = ar_sdio->mbox_info.ext_info[1].htc_ext_sz;\n\t\twmi_mbox_size = ar_sdio->mbox_info.ext_info[0].htc_ext_sz;\n\t}\n\n\tswitch (service_id) {\n\tcase ATH10K_HTC_SVC_ID_RSVD_CTRL:\n\t\t \n\t\tbreak;\n\tcase ATH10K_HTC_SVC_ID_WMI_CONTROL:\n\t\tar_sdio->mbox_addr[eid] = wmi_addr;\n\t\tar_sdio->mbox_size[eid] = wmi_mbox_size;\n\t\tath10k_dbg(ar, ATH10K_DBG_SDIO,\n\t\t\t   \"sdio wmi ctrl mbox_addr 0x%x mbox_size %d\\n\",\n\t\t\t   ar_sdio->mbox_addr[eid], ar_sdio->mbox_size[eid]);\n\t\tbreak;\n\tcase ATH10K_HTC_SVC_ID_HTT_DATA_MSG:\n\t\tar_sdio->mbox_addr[eid] = htt_addr;\n\t\tar_sdio->mbox_size[eid] = htt_mbox_size;\n\t\tath10k_dbg(ar, ATH10K_DBG_SDIO,\n\t\t\t   \"sdio htt data mbox_addr 0x%x mbox_size %d\\n\",\n\t\t\t   ar_sdio->mbox_addr[eid], ar_sdio->mbox_size[eid]);\n\t\tbreak;\n\tdefault:\n\t\tath10k_warn(ar, \"unsupported HTC service id: %d\\n\",\n\t\t\t    service_id);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void ath10k_sdio_hif_get_default_pipe(struct ath10k *ar,\n\t\t\t\t\t     u8 *ul_pipe, u8 *dl_pipe)\n{\n\tath10k_dbg(ar, ATH10K_DBG_SDIO, \"sdio hif get default pipe\\n\");\n\n\t \n\t*ul_pipe = 0;\n\t*dl_pipe = 0;\n}\n\nstatic const struct ath10k_hif_ops ath10k_sdio_hif_ops = {\n\t.tx_sg\t\t\t= ath10k_sdio_hif_tx_sg,\n\t.diag_read\t\t= ath10k_sdio_hif_diag_read,\n\t.diag_write\t\t= ath10k_sdio_hif_diag_write_mem,\n\t.exchange_bmi_msg\t= ath10k_sdio_bmi_exchange_msg,\n\t.start\t\t\t= ath10k_sdio_hif_start,\n\t.stop\t\t\t= ath10k_sdio_hif_stop,\n\t.start_post\t\t= ath10k_sdio_hif_start_post,\n\t.get_htt_tx_complete\t= ath10k_sdio_get_htt_tx_complete,\n\t.map_service_to_pipe\t= ath10k_sdio_hif_map_service_to_pipe,\n\t.get_default_pipe\t= ath10k_sdio_hif_get_default_pipe,\n\t.power_up\t\t= ath10k_sdio_hif_power_up,\n\t.power_down\t\t= ath10k_sdio_hif_power_down,\n#ifdef CONFIG_PM\n\t.suspend\t\t= ath10k_sdio_hif_suspend,\n\t.resume\t\t\t= ath10k_sdio_hif_resume,\n#endif\n};\n\n#ifdef CONFIG_PM_SLEEP\n\n \nstatic int ath10k_sdio_pm_suspend(struct device *device)\n{\n\tstruct sdio_func *func = dev_to_sdio_func(device);\n\tstruct ath10k_sdio *ar_sdio = sdio_get_drvdata(func);\n\tstruct ath10k *ar = ar_sdio->ar;\n\tmmc_pm_flag_t pm_flag, pm_caps;\n\tint ret;\n\n\tif (!device_may_wakeup(ar->dev))\n\t\treturn 0;\n\n\tath10k_sdio_set_mbox_sleep(ar, true);\n\n\tpm_flag = MMC_PM_KEEP_POWER;\n\n\tret = sdio_set_host_pm_flags(func, pm_flag);\n\tif (ret) {\n\t\tpm_caps = sdio_get_host_pm_caps(func);\n\t\tath10k_warn(ar, \"failed to set sdio host pm flags (0x%x, 0x%x): %d\\n\",\n\t\t\t    pm_flag, pm_caps, ret);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int ath10k_sdio_pm_resume(struct device *device)\n{\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(ath10k_sdio_pm_ops, ath10k_sdio_pm_suspend,\n\t\t\t ath10k_sdio_pm_resume);\n\n#define ATH10K_SDIO_PM_OPS (&ath10k_sdio_pm_ops)\n\n#else\n\n#define ATH10K_SDIO_PM_OPS NULL\n\n#endif  \n\nstatic int ath10k_sdio_napi_poll(struct napi_struct *ctx, int budget)\n{\n\tstruct ath10k *ar = container_of(ctx, struct ath10k, napi);\n\tint done;\n\n\tdone = ath10k_htt_rx_hl_indication(ar, budget);\n\tath10k_dbg(ar, ATH10K_DBG_SDIO, \"napi poll: done: %d, budget:%d\\n\", done, budget);\n\n\tif (done < budget)\n\t\tnapi_complete_done(ctx, done);\n\n\treturn done;\n}\n\nstatic int ath10k_sdio_read_host_interest_value(struct ath10k *ar,\n\t\t\t\t\t\tu32 item_offset,\n\t\t\t\t\t\tu32 *val)\n{\n\tu32 addr;\n\tint ret;\n\n\taddr = host_interest_item_address(item_offset);\n\n\tret = ath10k_sdio_diag_read32(ar, addr, val);\n\n\tif (ret)\n\t\tath10k_warn(ar, \"unable to read host interest offset %d value\\n\",\n\t\t\t    item_offset);\n\n\treturn ret;\n}\n\nstatic int ath10k_sdio_read_mem(struct ath10k *ar, u32 address, void *buf,\n\t\t\t\tu32 buf_len)\n{\n\tu32 val;\n\tint i, ret;\n\n\tfor (i = 0; i < buf_len; i += 4) {\n\t\tret = ath10k_sdio_diag_read32(ar, address + i, &val);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"unable to read mem %d value\\n\", address + i);\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy(buf + i, &val, 4);\n\t}\n\n\treturn ret;\n}\n\nstatic bool ath10k_sdio_is_fast_dump_supported(struct ath10k *ar)\n{\n\tu32 param;\n\n\tath10k_sdio_read_host_interest_value(ar, HI_ITEM(hi_option_flag2), &param);\n\n\tath10k_dbg(ar, ATH10K_DBG_SDIO, \"sdio hi_option_flag2 %x\\n\", param);\n\n\treturn !!(param & HI_OPTION_SDIO_CRASH_DUMP_ENHANCEMENT_FW);\n}\n\nstatic void ath10k_sdio_dump_registers(struct ath10k *ar,\n\t\t\t\t       struct ath10k_fw_crash_data *crash_data,\n\t\t\t\t       bool fast_dump)\n{\n\tu32 reg_dump_values[REG_DUMP_COUNT_QCA988X] = {};\n\tint i, ret;\n\tu32 reg_dump_area;\n\n\tret = ath10k_sdio_read_host_interest_value(ar, HI_ITEM(hi_failure_state),\n\t\t\t\t\t\t   &reg_dump_area);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to read firmware dump area: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tif (fast_dump)\n\t\tret = ath10k_bmi_read_memory(ar, reg_dump_area, reg_dump_values,\n\t\t\t\t\t     sizeof(reg_dump_values));\n\telse\n\t\tret = ath10k_sdio_read_mem(ar, reg_dump_area, reg_dump_values,\n\t\t\t\t\t   sizeof(reg_dump_values));\n\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to read firmware dump value: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tath10k_err(ar, \"firmware register dump:\\n\");\n\tfor (i = 0; i < ARRAY_SIZE(reg_dump_values); i += 4)\n\t\tath10k_err(ar, \"[%02d]: 0x%08X 0x%08X 0x%08X 0x%08X\\n\",\n\t\t\t   i,\n\t\t\t   reg_dump_values[i],\n\t\t\t   reg_dump_values[i + 1],\n\t\t\t   reg_dump_values[i + 2],\n\t\t\t   reg_dump_values[i + 3]);\n\n\tif (!crash_data)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(reg_dump_values); i++)\n\t\tcrash_data->registers[i] = __cpu_to_le32(reg_dump_values[i]);\n}\n\nstatic int ath10k_sdio_dump_memory_section(struct ath10k *ar,\n\t\t\t\t\t   const struct ath10k_mem_region *mem_region,\n\t\t\t\t\t   u8 *buf, size_t buf_len)\n{\n\tconst struct ath10k_mem_section *cur_section, *next_section;\n\tunsigned int count, section_size, skip_size;\n\tint ret, i, j;\n\n\tif (!mem_region || !buf)\n\t\treturn 0;\n\n\tcur_section = &mem_region->section_table.sections[0];\n\n\tif (mem_region->start > cur_section->start) {\n\t\tath10k_warn(ar, \"incorrect memdump region 0x%x with section start address 0x%x.\\n\",\n\t\t\t    mem_region->start, cur_section->start);\n\t\treturn 0;\n\t}\n\n\tskip_size = cur_section->start - mem_region->start;\n\n\t \n\tfor (i = 0; i < skip_size; i++) {\n\t\t*buf = ATH10K_MAGIC_NOT_COPIED;\n\t\tbuf++;\n\t}\n\n\tcount = 0;\n\ti = 0;\n\tfor (; cur_section; cur_section = next_section) {\n\t\tsection_size = cur_section->end - cur_section->start;\n\n\t\tif (section_size <= 0) {\n\t\t\tath10k_warn(ar, \"incorrect ramdump format with start address 0x%x and stop address 0x%x\\n\",\n\t\t\t\t    cur_section->start,\n\t\t\t\t    cur_section->end);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (++i == mem_region->section_table.size) {\n\t\t\t \n\t\t\tnext_section = NULL;\n\t\t\tskip_size = 0;\n\t\t} else {\n\t\t\tnext_section = cur_section + 1;\n\n\t\t\tif (cur_section->end > next_section->start) {\n\t\t\t\tath10k_warn(ar, \"next ramdump section 0x%x is smaller than current end address 0x%x\\n\",\n\t\t\t\t\t    next_section->start,\n\t\t\t\t\t    cur_section->end);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tskip_size = next_section->start - cur_section->end;\n\t\t}\n\n\t\tif (buf_len < (skip_size + section_size)) {\n\t\t\tath10k_warn(ar, \"ramdump buffer is too small: %zu\\n\", buf_len);\n\t\t\tbreak;\n\t\t}\n\n\t\tbuf_len -= skip_size + section_size;\n\n\t\t \n\t\tret = ath10k_sdio_read_mem(ar, cur_section->start,\n\t\t\t\t\t   buf, section_size);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to read ramdump from section 0x%x: %d\\n\",\n\t\t\t\t    cur_section->start, ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tbuf += section_size;\n\t\tcount += section_size;\n\n\t\t \n\t\tfor (j = 0; j < skip_size; j++) {\n\t\t\t*buf = ATH10K_MAGIC_NOT_COPIED;\n\t\t\tbuf++;\n\t\t}\n\n\t\tcount += skip_size;\n\t}\n\n\treturn count;\n}\n\n \nstatic int ath10k_sdio_dump_memory_generic(struct ath10k *ar,\n\t\t\t\t\t   const struct ath10k_mem_region *current_region,\n\t\t\t\t\t   u8 *buf,\n\t\t\t\t\t   bool fast_dump)\n{\n\tint ret;\n\n\tif (current_region->section_table.size > 0)\n\t\t \n\t\treturn ath10k_sdio_dump_memory_section(ar,\n\t\t\t\t\t\t      current_region,\n\t\t\t\t\t\t      buf,\n\t\t\t\t\t\t      current_region->len);\n\n\t \n\tif (fast_dump)\n\t\tret = ath10k_bmi_read_memory(ar,\n\t\t\t\t\t     current_region->start,\n\t\t\t\t\t     buf,\n\t\t\t\t\t     current_region->len);\n\telse\n\t\tret = ath10k_sdio_read_mem(ar,\n\t\t\t\t\t   current_region->start,\n\t\t\t\t\t   buf,\n\t\t\t\t\t   current_region->len);\n\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to copy ramdump region %s: %d\\n\",\n\t\t\t    current_region->name, ret);\n\t\treturn ret;\n\t}\n\n\treturn current_region->len;\n}\n\nstatic void ath10k_sdio_dump_memory(struct ath10k *ar,\n\t\t\t\t    struct ath10k_fw_crash_data *crash_data,\n\t\t\t\t    bool fast_dump)\n{\n\tconst struct ath10k_hw_mem_layout *mem_layout;\n\tconst struct ath10k_mem_region *current_region;\n\tstruct ath10k_dump_ram_data_hdr *hdr;\n\tu32 count;\n\tsize_t buf_len;\n\tint ret, i;\n\tu8 *buf;\n\n\tif (!crash_data)\n\t\treturn;\n\n\tmem_layout = ath10k_coredump_get_mem_layout(ar);\n\tif (!mem_layout)\n\t\treturn;\n\n\tcurrent_region = &mem_layout->region_table.regions[0];\n\n\tbuf = crash_data->ramdump_buf;\n\tbuf_len = crash_data->ramdump_buf_len;\n\n\tmemset(buf, 0, buf_len);\n\n\tfor (i = 0; i < mem_layout->region_table.size; i++) {\n\t\tcount = 0;\n\n\t\tif (current_region->len > buf_len) {\n\t\t\tath10k_warn(ar, \"memory region %s size %d is larger that remaining ramdump buffer size %zu\\n\",\n\t\t\t\t    current_region->name,\n\t\t\t\t    current_region->len,\n\t\t\t\t    buf_len);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\thdr = (void *)buf;\n\t\tbuf += sizeof(*hdr);\n\t\tbuf_len -= sizeof(*hdr);\n\n\t\tret = ath10k_sdio_dump_memory_generic(ar, current_region, buf,\n\t\t\t\t\t\t      fast_dump);\n\t\tif (ret >= 0)\n\t\t\tcount = ret;\n\n\t\thdr->region_type = cpu_to_le32(current_region->type);\n\t\thdr->start = cpu_to_le32(current_region->start);\n\t\thdr->length = cpu_to_le32(count);\n\n\t\tif (count == 0)\n\t\t\t \n\t\t\tbreak;\n\n\t\tbuf += count;\n\t\tbuf_len -= count;\n\n\t\tcurrent_region++;\n\t}\n}\n\nvoid ath10k_sdio_fw_crashed_dump(struct ath10k *ar)\n{\n\tstruct ath10k_fw_crash_data *crash_data;\n\tchar guid[UUID_STRING_LEN + 1];\n\tbool fast_dump;\n\n\tfast_dump = ath10k_sdio_is_fast_dump_supported(ar);\n\n\tif (fast_dump)\n\t\tath10k_bmi_start(ar);\n\n\tar->stats.fw_crash_counter++;\n\n\tath10k_sdio_disable_intrs(ar);\n\n\tcrash_data = ath10k_coredump_new(ar);\n\n\tif (crash_data)\n\t\tscnprintf(guid, sizeof(guid), \"%pUl\", &crash_data->guid);\n\telse\n\t\tscnprintf(guid, sizeof(guid), \"n/a\");\n\n\tath10k_err(ar, \"firmware crashed! (guid %s)\\n\", guid);\n\tath10k_print_driver_info(ar);\n\tath10k_sdio_dump_registers(ar, crash_data, fast_dump);\n\tath10k_sdio_dump_memory(ar, crash_data, fast_dump);\n\n\tath10k_sdio_enable_intrs(ar);\n\n\tath10k_core_start_recovery(ar);\n}\n\nstatic int ath10k_sdio_probe(struct sdio_func *func,\n\t\t\t     const struct sdio_device_id *id)\n{\n\tstruct ath10k_sdio *ar_sdio;\n\tstruct ath10k *ar;\n\tenum ath10k_hw_rev hw_rev;\n\tu32 dev_id_base;\n\tstruct ath10k_bus_params bus_params = {};\n\tint ret, i;\n\n\t \n\thw_rev = ATH10K_HW_QCA6174;\n\n\tar = ath10k_core_create(sizeof(*ar_sdio), &func->dev, ATH10K_BUS_SDIO,\n\t\t\t\thw_rev, &ath10k_sdio_hif_ops);\n\tif (!ar) {\n\t\tdev_err(&func->dev, \"failed to allocate core\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tnetif_napi_add(&ar->napi_dev, &ar->napi, ath10k_sdio_napi_poll);\n\n\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t   \"sdio new func %d vendor 0x%x device 0x%x block 0x%x/0x%x\\n\",\n\t\t   func->num, func->vendor, func->device,\n\t\t   func->max_blksize, func->cur_blksize);\n\n\tar_sdio = ath10k_sdio_priv(ar);\n\n\tar_sdio->irq_data.irq_proc_reg =\n\t\tdevm_kzalloc(ar->dev, sizeof(struct ath10k_sdio_irq_proc_regs),\n\t\t\t     GFP_KERNEL);\n\tif (!ar_sdio->irq_data.irq_proc_reg) {\n\t\tret = -ENOMEM;\n\t\tgoto err_core_destroy;\n\t}\n\n\tar_sdio->vsg_buffer = devm_kmalloc(ar->dev, ATH10K_SDIO_VSG_BUF_SIZE, GFP_KERNEL);\n\tif (!ar_sdio->vsg_buffer) {\n\t\tret = -ENOMEM;\n\t\tgoto err_core_destroy;\n\t}\n\n\tar_sdio->irq_data.irq_en_reg =\n\t\tdevm_kzalloc(ar->dev, sizeof(struct ath10k_sdio_irq_enable_regs),\n\t\t\t     GFP_KERNEL);\n\tif (!ar_sdio->irq_data.irq_en_reg) {\n\t\tret = -ENOMEM;\n\t\tgoto err_core_destroy;\n\t}\n\n\tar_sdio->bmi_buf = devm_kzalloc(ar->dev, BMI_MAX_LARGE_CMDBUF_SIZE, GFP_KERNEL);\n\tif (!ar_sdio->bmi_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto err_core_destroy;\n\t}\n\n\tar_sdio->func = func;\n\tsdio_set_drvdata(func, ar_sdio);\n\n\tar_sdio->is_disabled = true;\n\tar_sdio->ar = ar;\n\n\tspin_lock_init(&ar_sdio->lock);\n\tspin_lock_init(&ar_sdio->wr_async_lock);\n\tmutex_init(&ar_sdio->irq_data.mtx);\n\n\tINIT_LIST_HEAD(&ar_sdio->bus_req_freeq);\n\tINIT_LIST_HEAD(&ar_sdio->wr_asyncq);\n\n\tINIT_WORK(&ar_sdio->wr_async_work, ath10k_sdio_write_async_work);\n\tar_sdio->workqueue = create_singlethread_workqueue(\"ath10k_sdio_wq\");\n\tif (!ar_sdio->workqueue) {\n\t\tret = -ENOMEM;\n\t\tgoto err_core_destroy;\n\t}\n\n\tfor (i = 0; i < ATH10K_SDIO_BUS_REQUEST_MAX_NUM; i++)\n\t\tath10k_sdio_free_bus_req(ar, &ar_sdio->bus_req[i]);\n\n\tskb_queue_head_init(&ar_sdio->rx_head);\n\tINIT_WORK(&ar_sdio->async_work_rx, ath10k_rx_indication_async_work);\n\n\tdev_id_base = (id->device & 0x0F00);\n\tif (dev_id_base != (SDIO_DEVICE_ID_ATHEROS_AR6005 & 0x0F00) &&\n\t    dev_id_base != (SDIO_DEVICE_ID_ATHEROS_QCA9377 & 0x0F00)) {\n\t\tret = -ENODEV;\n\t\tath10k_err(ar, \"unsupported device id %u (0x%x)\\n\",\n\t\t\t   dev_id_base, id->device);\n\t\tgoto err_free_wq;\n\t}\n\n\tar->dev_id = QCA9377_1_0_DEVICE_ID;\n\tar->id.vendor = id->vendor;\n\tar->id.device = id->device;\n\n\tath10k_sdio_set_mbox_info(ar);\n\n\tbus_params.dev_type = ATH10K_DEV_TYPE_HL;\n\t \n\tbus_params.chip_id = 0;\n\tbus_params.hl_msdu_ids = true;\n\n\tar->hw->max_mtu = ETH_DATA_LEN;\n\n\tret = ath10k_core_register(ar, &bus_params);\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to register driver core: %d\\n\", ret);\n\t\tgoto err_free_wq;\n\t}\n\n\ttimer_setup(&ar_sdio->sleep_timer, ath10k_sdio_sleep_timer_handler, 0);\n\n\treturn 0;\n\nerr_free_wq:\n\tdestroy_workqueue(ar_sdio->workqueue);\nerr_core_destroy:\n\tath10k_core_destroy(ar);\n\n\treturn ret;\n}\n\nstatic void ath10k_sdio_remove(struct sdio_func *func)\n{\n\tstruct ath10k_sdio *ar_sdio = sdio_get_drvdata(func);\n\tstruct ath10k *ar = ar_sdio->ar;\n\n\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t   \"sdio removed func %d vendor 0x%x device 0x%x\\n\",\n\t\t   func->num, func->vendor, func->device);\n\n\tath10k_core_unregister(ar);\n\n\tnetif_napi_del(&ar->napi);\n\n\tath10k_core_destroy(ar);\n\n\tdestroy_workqueue(ar_sdio->workqueue);\n}\n\nstatic const struct sdio_device_id ath10k_sdio_devices[] = {\n\t{SDIO_DEVICE(SDIO_VENDOR_ID_ATHEROS, SDIO_DEVICE_ID_ATHEROS_AR6005)},\n\t{SDIO_DEVICE(SDIO_VENDOR_ID_ATHEROS, SDIO_DEVICE_ID_ATHEROS_QCA9377)},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(sdio, ath10k_sdio_devices);\n\nstatic struct sdio_driver ath10k_sdio_driver = {\n\t.name = \"ath10k_sdio\",\n\t.id_table = ath10k_sdio_devices,\n\t.probe = ath10k_sdio_probe,\n\t.remove = ath10k_sdio_remove,\n\t.drv = {\n\t\t.owner = THIS_MODULE,\n\t\t.pm = ATH10K_SDIO_PM_OPS,\n\t},\n};\n\nstatic int __init ath10k_sdio_init(void)\n{\n\tint ret;\n\n\tret = sdio_register_driver(&ath10k_sdio_driver);\n\tif (ret)\n\t\tpr_err(\"sdio driver registration failed: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void __exit ath10k_sdio_exit(void)\n{\n\tsdio_unregister_driver(&ath10k_sdio_driver);\n}\n\nmodule_init(ath10k_sdio_init);\nmodule_exit(ath10k_sdio_exit);\n\nMODULE_AUTHOR(\"Qualcomm Atheros\");\nMODULE_DESCRIPTION(\"Driver support for Qualcomm Atheros 802.11ac WLAN SDIO devices\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}