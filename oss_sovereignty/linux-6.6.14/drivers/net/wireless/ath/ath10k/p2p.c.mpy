{
  "module_name": "p2p.c",
  "hash_id": "ed97c774abefbb4675f44349ca5cfe456d0a202f5d247c0764ba5009c3c29528",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath10k/p2p.c",
  "human_readable_source": "\n \n\n#include \"core.h\"\n#include \"wmi.h\"\n#include \"mac.h\"\n#include \"p2p.h\"\n\nstatic void ath10k_p2p_noa_ie_fill(u8 *data, size_t len,\n\t\t\t\t   const struct wmi_p2p_noa_info *noa)\n{\n\tstruct ieee80211_p2p_noa_attr *noa_attr;\n\tu8  ctwindow_oppps = noa->ctwindow_oppps;\n\tu8 ctwindow = ctwindow_oppps >> WMI_P2P_OPPPS_CTWINDOW_OFFSET;\n\tbool oppps = !!(ctwindow_oppps & WMI_P2P_OPPPS_ENABLE_BIT);\n\t__le16 *noa_attr_len;\n\tu16 attr_len;\n\tu8 noa_descriptors = noa->num_descriptors;\n\tint i;\n\n\t \n\tdata[0] = WLAN_EID_VENDOR_SPECIFIC;\n\tdata[1] = len - 2;\n\tdata[2] = (WLAN_OUI_WFA >> 16) & 0xff;\n\tdata[3] = (WLAN_OUI_WFA >> 8) & 0xff;\n\tdata[4] = (WLAN_OUI_WFA >> 0) & 0xff;\n\tdata[5] = WLAN_OUI_TYPE_WFA_P2P;\n\n\t \n\tdata[6] = IEEE80211_P2P_ATTR_ABSENCE_NOTICE;\n\tnoa_attr_len = (__le16 *)&data[7];  \n\tnoa_attr = (struct ieee80211_p2p_noa_attr *)&data[9];\n\n\tnoa_attr->index = noa->index;\n\tnoa_attr->oppps_ctwindow = ctwindow;\n\tif (oppps)\n\t\tnoa_attr->oppps_ctwindow |= IEEE80211_P2P_OPPPS_ENABLE_BIT;\n\n\tfor (i = 0; i < noa_descriptors; i++) {\n\t\tnoa_attr->desc[i].count =\n\t\t\t__le32_to_cpu(noa->descriptors[i].type_count);\n\t\tnoa_attr->desc[i].duration = noa->descriptors[i].duration;\n\t\tnoa_attr->desc[i].interval = noa->descriptors[i].interval;\n\t\tnoa_attr->desc[i].start_time = noa->descriptors[i].start_time;\n\t}\n\n\tattr_len = 2;  \n\tattr_len += noa_descriptors * sizeof(struct ieee80211_p2p_noa_desc);\n\t*noa_attr_len = __cpu_to_le16(attr_len);\n}\n\nstatic size_t ath10k_p2p_noa_ie_len_compute(const struct wmi_p2p_noa_info *noa)\n{\n\tsize_t len = 0;\n\n\tif (!noa->num_descriptors &&\n\t    !(noa->ctwindow_oppps & WMI_P2P_OPPPS_ENABLE_BIT))\n\t\treturn 0;\n\n\tlen += 1 + 1 + 4;  \n\tlen += 1 + 2;  \n\tlen += 1 + 1;  \n\tlen += noa->num_descriptors * sizeof(struct ieee80211_p2p_noa_desc);\n\n\treturn len;\n}\n\nstatic void ath10k_p2p_noa_ie_assign(struct ath10k_vif *arvif, void *ie,\n\t\t\t\t     size_t len)\n{\n\tstruct ath10k *ar = arvif->ar;\n\n\tlockdep_assert_held(&ar->data_lock);\n\n\tkfree(arvif->u.ap.noa_data);\n\n\tarvif->u.ap.noa_data = ie;\n\tarvif->u.ap.noa_len = len;\n}\n\nstatic void __ath10k_p2p_noa_update(struct ath10k_vif *arvif,\n\t\t\t\t    const struct wmi_p2p_noa_info *noa)\n{\n\tstruct ath10k *ar = arvif->ar;\n\tvoid *ie;\n\tsize_t len;\n\n\tlockdep_assert_held(&ar->data_lock);\n\n\tath10k_p2p_noa_ie_assign(arvif, NULL, 0);\n\n\tlen = ath10k_p2p_noa_ie_len_compute(noa);\n\tif (!len)\n\t\treturn;\n\n\tie = kmalloc(len, GFP_ATOMIC);\n\tif (!ie)\n\t\treturn;\n\n\tath10k_p2p_noa_ie_fill(ie, len, noa);\n\tath10k_p2p_noa_ie_assign(arvif, ie, len);\n}\n\nvoid ath10k_p2p_noa_update(struct ath10k_vif *arvif,\n\t\t\t   const struct wmi_p2p_noa_info *noa)\n{\n\tstruct ath10k *ar = arvif->ar;\n\n\tspin_lock_bh(&ar->data_lock);\n\t__ath10k_p2p_noa_update(arvif, noa);\n\tspin_unlock_bh(&ar->data_lock);\n}\n\nstruct ath10k_p2p_noa_arg {\n\tu32 vdev_id;\n\tconst struct wmi_p2p_noa_info *noa;\n};\n\nstatic void ath10k_p2p_noa_update_vdev_iter(void *data, u8 *mac,\n\t\t\t\t\t    struct ieee80211_vif *vif)\n{\n\tstruct ath10k_vif *arvif = (void *)vif->drv_priv;\n\tstruct ath10k_p2p_noa_arg *arg = data;\n\n\tif (arvif->vdev_id != arg->vdev_id)\n\t\treturn;\n\n\tath10k_p2p_noa_update(arvif, arg->noa);\n}\n\nvoid ath10k_p2p_noa_update_by_vdev_id(struct ath10k *ar, u32 vdev_id,\n\t\t\t\t      const struct wmi_p2p_noa_info *noa)\n{\n\tstruct ath10k_p2p_noa_arg arg = {\n\t\t.vdev_id = vdev_id,\n\t\t.noa = noa,\n\t};\n\n\tieee80211_iterate_active_interfaces_atomic(ar->hw,\n\t\t\t\t\t\t   ATH10K_ITER_NORMAL_FLAGS,\n\t\t\t\t\t\t   ath10k_p2p_noa_update_vdev_iter,\n\t\t\t\t\t\t   &arg);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}