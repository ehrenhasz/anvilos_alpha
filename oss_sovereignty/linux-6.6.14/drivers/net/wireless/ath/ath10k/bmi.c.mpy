{
  "module_name": "bmi.c",
  "hash_id": "d1ab6beccbb0548cd6434f642328f408a21ddd19362cdc15926baf64ec6c945f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath10k/bmi.c",
  "human_readable_source": "\n \n\n#include \"bmi.h\"\n#include \"hif.h\"\n#include \"debug.h\"\n#include \"htc.h\"\n#include \"hw.h\"\n\nvoid ath10k_bmi_start(struct ath10k *ar)\n{\n\tath10k_dbg(ar, ATH10K_DBG_BMI, \"bmi start\\n\");\n\n\tar->bmi.done_sent = false;\n}\nEXPORT_SYMBOL(ath10k_bmi_start);\n\nint ath10k_bmi_done(struct ath10k *ar)\n{\n\tstruct bmi_cmd cmd;\n\tu32 cmdlen = sizeof(cmd.id) + sizeof(cmd.done);\n\tint ret;\n\n\tath10k_dbg(ar, ATH10K_DBG_BMI, \"bmi done\\n\");\n\n\tif (ar->bmi.done_sent) {\n\t\tath10k_dbg(ar, ATH10K_DBG_BMI, \"bmi skipped\\n\");\n\t\treturn 0;\n\t}\n\n\tar->bmi.done_sent = true;\n\tcmd.id = __cpu_to_le32(BMI_DONE);\n\n\tret = ath10k_hif_exchange_bmi_msg(ar, &cmd, cmdlen, NULL, NULL);\n\tif (ret) {\n\t\tath10k_warn(ar, \"unable to write to the device: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint ath10k_bmi_get_target_info(struct ath10k *ar,\n\t\t\t       struct bmi_target_info *target_info)\n{\n\tstruct bmi_cmd cmd;\n\tunion bmi_resp resp;\n\tu32 cmdlen = sizeof(cmd.id) + sizeof(cmd.get_target_info);\n\tu32 resplen = sizeof(resp.get_target_info);\n\tint ret;\n\n\tath10k_dbg(ar, ATH10K_DBG_BMI, \"bmi get target info\\n\");\n\n\tif (ar->bmi.done_sent) {\n\t\tath10k_warn(ar, \"BMI Get Target Info Command disallowed\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tcmd.id = __cpu_to_le32(BMI_GET_TARGET_INFO);\n\n\tret = ath10k_hif_exchange_bmi_msg(ar, &cmd, cmdlen, &resp, &resplen);\n\tif (ret) {\n\t\tath10k_warn(ar, \"unable to get target info from device\\n\");\n\t\treturn ret;\n\t}\n\n\tif (resplen < sizeof(resp.get_target_info)) {\n\t\tath10k_warn(ar, \"invalid get_target_info response length (%d)\\n\",\n\t\t\t    resplen);\n\t\treturn -EIO;\n\t}\n\n\ttarget_info->version = __le32_to_cpu(resp.get_target_info.version);\n\ttarget_info->type    = __le32_to_cpu(resp.get_target_info.type);\n\n\treturn 0;\n}\n\n#define TARGET_VERSION_SENTINAL 0xffffffffu\n\nint ath10k_bmi_get_target_info_sdio(struct ath10k *ar,\n\t\t\t\t    struct bmi_target_info *target_info)\n{\n\tstruct bmi_cmd cmd;\n\tunion bmi_resp resp;\n\tu32 cmdlen = sizeof(cmd.id) + sizeof(cmd.get_target_info);\n\tu32 resplen, ver_len;\n\t__le32 tmp;\n\tint ret;\n\n\tath10k_dbg(ar, ATH10K_DBG_BMI, \"bmi get target info SDIO\\n\");\n\n\tif (ar->bmi.done_sent) {\n\t\tath10k_warn(ar, \"BMI Get Target Info Command disallowed\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tcmd.id = __cpu_to_le32(BMI_GET_TARGET_INFO);\n\n\t \n\tresplen = sizeof(u32);\n\tret = ath10k_hif_exchange_bmi_msg(ar, &cmd, cmdlen, &tmp, &resplen);\n\tif (ret) {\n\t\tath10k_warn(ar, \"unable to read from device\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (__le32_to_cpu(tmp) == TARGET_VERSION_SENTINAL) {\n\t\t \n\t\tresplen = sizeof(u32);\n\t\tret = ath10k_hif_exchange_bmi_msg(ar, NULL, 0, &tmp,\n\t\t\t\t\t\t  &resplen);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"unable to read from device\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tver_len = __le32_to_cpu(tmp);\n\n\t \n\tif (ver_len != sizeof(resp.get_target_info)) {\n\t\tath10k_warn(ar, \"Unexpected target info len: %u. Expected: %zu\\n\",\n\t\t\t    ver_len, sizeof(resp.get_target_info));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tresplen = sizeof(resp.get_target_info) - sizeof(u32);\n\tret = ath10k_hif_exchange_bmi_msg(ar, NULL, 0,\n\t\t\t\t\t  &resp.get_target_info.version,\n\t\t\t\t\t  &resplen);\n\tif (ret) {\n\t\tath10k_warn(ar, \"unable to read from device\\n\");\n\t\treturn ret;\n\t}\n\n\ttarget_info->version = __le32_to_cpu(resp.get_target_info.version);\n\ttarget_info->type    = __le32_to_cpu(resp.get_target_info.type);\n\n\treturn 0;\n}\n\nint ath10k_bmi_read_memory(struct ath10k *ar,\n\t\t\t   u32 address, void *buffer, u32 length)\n{\n\tstruct bmi_cmd cmd;\n\tunion bmi_resp resp;\n\tu32 cmdlen = sizeof(cmd.id) + sizeof(cmd.read_mem);\n\tu32 rxlen;\n\tint ret;\n\n\tath10k_dbg(ar, ATH10K_DBG_BMI, \"bmi read address 0x%x length %d\\n\",\n\t\t   address, length);\n\n\tif (ar->bmi.done_sent) {\n\t\tath10k_warn(ar, \"command disallowed\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\twhile (length) {\n\t\trxlen = min_t(u32, length, BMI_MAX_DATA_SIZE);\n\n\t\tcmd.id            = __cpu_to_le32(BMI_READ_MEMORY);\n\t\tcmd.read_mem.addr = __cpu_to_le32(address);\n\t\tcmd.read_mem.len  = __cpu_to_le32(rxlen);\n\n\t\tret = ath10k_hif_exchange_bmi_msg(ar, &cmd, cmdlen,\n\t\t\t\t\t\t  &resp, &rxlen);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"unable to read from the device (%d)\\n\",\n\t\t\t\t    ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tmemcpy(buffer, resp.read_mem.payload, rxlen);\n\t\taddress += rxlen;\n\t\tbuffer  += rxlen;\n\t\tlength  -= rxlen;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ath10k_bmi_read_memory);\n\nint ath10k_bmi_write_soc_reg(struct ath10k *ar, u32 address, u32 reg_val)\n{\n\tstruct bmi_cmd cmd;\n\tu32 cmdlen = sizeof(cmd.id) + sizeof(cmd.write_soc_reg);\n\tint ret;\n\n\tath10k_dbg(ar, ATH10K_DBG_BMI,\n\t\t   \"bmi write soc register 0x%08x val 0x%08x\\n\",\n\t\t   address, reg_val);\n\n\tif (ar->bmi.done_sent) {\n\t\tath10k_warn(ar, \"bmi write soc register command in progress\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tcmd.id = __cpu_to_le32(BMI_WRITE_SOC_REGISTER);\n\tcmd.write_soc_reg.addr = __cpu_to_le32(address);\n\tcmd.write_soc_reg.value = __cpu_to_le32(reg_val);\n\n\tret = ath10k_hif_exchange_bmi_msg(ar, &cmd, cmdlen, NULL, NULL);\n\tif (ret) {\n\t\tath10k_warn(ar, \"Unable to write soc register to device: %d\\n\",\n\t\t\t    ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint ath10k_bmi_read_soc_reg(struct ath10k *ar, u32 address, u32 *reg_val)\n{\n\tstruct bmi_cmd cmd;\n\tunion bmi_resp resp;\n\tu32 cmdlen = sizeof(cmd.id) + sizeof(cmd.read_soc_reg);\n\tu32 resplen = sizeof(resp.read_soc_reg);\n\tint ret;\n\n\tath10k_dbg(ar, ATH10K_DBG_BMI, \"bmi read soc register 0x%08x\\n\",\n\t\t   address);\n\n\tif (ar->bmi.done_sent) {\n\t\tath10k_warn(ar, \"bmi read soc register command in progress\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tcmd.id = __cpu_to_le32(BMI_READ_SOC_REGISTER);\n\tcmd.read_soc_reg.addr = __cpu_to_le32(address);\n\n\tret = ath10k_hif_exchange_bmi_msg(ar, &cmd, cmdlen, &resp, &resplen);\n\tif (ret) {\n\t\tath10k_warn(ar, \"Unable to read soc register from device: %d\\n\",\n\t\t\t    ret);\n\t\treturn ret;\n\t}\n\n\t*reg_val = __le32_to_cpu(resp.read_soc_reg.value);\n\n\tath10k_dbg(ar, ATH10K_DBG_BMI, \"bmi read soc register value 0x%08x\\n\",\n\t\t   *reg_val);\n\n\treturn 0;\n}\n\nint ath10k_bmi_write_memory(struct ath10k *ar,\n\t\t\t    u32 address, const void *buffer, u32 length)\n{\n\tstruct bmi_cmd cmd;\n\tu32 hdrlen = sizeof(cmd.id) + sizeof(cmd.write_mem);\n\tu32 txlen;\n\tint ret;\n\n\tath10k_dbg(ar, ATH10K_DBG_BMI, \"bmi write address 0x%x length %d\\n\",\n\t\t   address, length);\n\n\tif (ar->bmi.done_sent) {\n\t\tath10k_warn(ar, \"command disallowed\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\twhile (length) {\n\t\ttxlen = min(length, BMI_MAX_DATA_SIZE - hdrlen);\n\n\t\t \n\t\tmemcpy(cmd.write_mem.payload, buffer, txlen);\n\t\ttxlen = roundup(txlen, 4);\n\n\t\tcmd.id             = __cpu_to_le32(BMI_WRITE_MEMORY);\n\t\tcmd.write_mem.addr = __cpu_to_le32(address);\n\t\tcmd.write_mem.len  = __cpu_to_le32(txlen);\n\n\t\tret = ath10k_hif_exchange_bmi_msg(ar, &cmd, hdrlen + txlen,\n\t\t\t\t\t\t  NULL, NULL);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"unable to write to the device (%d)\\n\",\n\t\t\t\t    ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\ttxlen = min(txlen, length);\n\n\t\taddress += txlen;\n\t\tbuffer  += txlen;\n\t\tlength  -= txlen;\n\t}\n\n\treturn 0;\n}\n\nint ath10k_bmi_execute(struct ath10k *ar, u32 address, u32 param, u32 *result)\n{\n\tstruct bmi_cmd cmd;\n\tunion bmi_resp resp;\n\tu32 cmdlen = sizeof(cmd.id) + sizeof(cmd.execute);\n\tu32 resplen = sizeof(resp.execute);\n\tint ret;\n\n\tath10k_dbg(ar, ATH10K_DBG_BMI, \"bmi execute address 0x%x param 0x%x\\n\",\n\t\t   address, param);\n\n\tif (ar->bmi.done_sent) {\n\t\tath10k_warn(ar, \"command disallowed\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tcmd.id            = __cpu_to_le32(BMI_EXECUTE);\n\tcmd.execute.addr  = __cpu_to_le32(address);\n\tcmd.execute.param = __cpu_to_le32(param);\n\n\tret = ath10k_hif_exchange_bmi_msg(ar, &cmd, cmdlen, &resp, &resplen);\n\tif (ret) {\n\t\tath10k_warn(ar, \"unable to read from the device\\n\");\n\t\treturn ret;\n\t}\n\n\tif (resplen < sizeof(resp.execute)) {\n\t\tath10k_warn(ar, \"invalid execute response length (%d)\\n\",\n\t\t\t    resplen);\n\t\treturn -EIO;\n\t}\n\n\t*result = __le32_to_cpu(resp.execute.result);\n\n\tath10k_dbg(ar, ATH10K_DBG_BMI, \"bmi execute result 0x%x\\n\", *result);\n\n\treturn 0;\n}\n\nstatic int ath10k_bmi_lz_data_large(struct ath10k *ar, const void *buffer, u32 length)\n{\n\tstruct bmi_cmd *cmd;\n\tu32 hdrlen = sizeof(cmd->id) + sizeof(cmd->lz_data);\n\tu32 txlen;\n\tint ret;\n\tsize_t buf_len;\n\n\tath10k_dbg(ar, ATH10K_DBG_BMI, \"large bmi lz data buffer 0x%pK length %d\\n\",\n\t\t   buffer, length);\n\n\tif (ar->bmi.done_sent) {\n\t\tath10k_warn(ar, \"command disallowed\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tbuf_len = sizeof(*cmd) + BMI_MAX_LARGE_DATA_SIZE - BMI_MAX_DATA_SIZE;\n\tcmd = kzalloc(buf_len, GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\twhile (length) {\n\t\ttxlen = min(length, BMI_MAX_LARGE_DATA_SIZE - hdrlen);\n\n\t\tWARN_ON_ONCE(txlen & 3);\n\n\t\tcmd->id          = __cpu_to_le32(BMI_LZ_DATA);\n\t\tcmd->lz_data.len = __cpu_to_le32(txlen);\n\t\tmemcpy(cmd->lz_data.payload, buffer, txlen);\n\n\t\tret = ath10k_hif_exchange_bmi_msg(ar, cmd, hdrlen + txlen,\n\t\t\t\t\t\t  NULL, NULL);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"unable to write to the device\\n\");\n\t\t\tkfree(cmd);\n\t\t\treturn ret;\n\t\t}\n\n\t\tbuffer += txlen;\n\t\tlength -= txlen;\n\t}\n\n\tkfree(cmd);\n\n\treturn 0;\n}\n\nint ath10k_bmi_lz_data(struct ath10k *ar, const void *buffer, u32 length)\n{\n\tstruct bmi_cmd cmd;\n\tu32 hdrlen = sizeof(cmd.id) + sizeof(cmd.lz_data);\n\tu32 txlen;\n\tint ret;\n\n\tath10k_dbg(ar, ATH10K_DBG_BMI, \"bmi lz data buffer 0x%pK length %d\\n\",\n\t\t   buffer, length);\n\n\tif (ar->bmi.done_sent) {\n\t\tath10k_warn(ar, \"command disallowed\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\twhile (length) {\n\t\ttxlen = min(length, BMI_MAX_DATA_SIZE - hdrlen);\n\n\t\tWARN_ON_ONCE(txlen & 3);\n\n\t\tcmd.id          = __cpu_to_le32(BMI_LZ_DATA);\n\t\tcmd.lz_data.len = __cpu_to_le32(txlen);\n\t\tmemcpy(cmd.lz_data.payload, buffer, txlen);\n\n\t\tret = ath10k_hif_exchange_bmi_msg(ar, &cmd, hdrlen + txlen,\n\t\t\t\t\t\t  NULL, NULL);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"unable to write to the device\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tbuffer += txlen;\n\t\tlength -= txlen;\n\t}\n\n\treturn 0;\n}\n\nint ath10k_bmi_lz_stream_start(struct ath10k *ar, u32 address)\n{\n\tstruct bmi_cmd cmd;\n\tu32 cmdlen = sizeof(cmd.id) + sizeof(cmd.lz_start);\n\tint ret;\n\n\tath10k_dbg(ar, ATH10K_DBG_BMI, \"bmi lz stream start address 0x%x\\n\",\n\t\t   address);\n\n\tif (ar->bmi.done_sent) {\n\t\tath10k_warn(ar, \"command disallowed\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tcmd.id            = __cpu_to_le32(BMI_LZ_STREAM_START);\n\tcmd.lz_start.addr = __cpu_to_le32(address);\n\n\tret = ath10k_hif_exchange_bmi_msg(ar, &cmd, cmdlen, NULL, NULL);\n\tif (ret) {\n\t\tath10k_warn(ar, \"unable to Start LZ Stream to the device\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint ath10k_bmi_fast_download(struct ath10k *ar,\n\t\t\t     u32 address, const void *buffer, u32 length)\n{\n\tu8 trailer[4] = {};\n\tu32 head_len = rounddown(length, 4);\n\tu32 trailer_len = length - head_len;\n\tint ret;\n\n\tath10k_dbg(ar, ATH10K_DBG_BMI,\n\t\t   \"bmi fast download address 0x%x buffer 0x%pK length %d\\n\",\n\t\t   address, buffer, length);\n\n\tret = ath10k_bmi_lz_stream_start(ar, address);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (trailer_len > 0)\n\t\tmemcpy(trailer, buffer + head_len, trailer_len);\n\n\tif (ar->hw_params.bmi_large_size_download)\n\t\tret = ath10k_bmi_lz_data_large(ar, buffer, head_len);\n\telse\n\t\tret = ath10k_bmi_lz_data(ar, buffer, head_len);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (trailer_len > 0)\n\t\tret = ath10k_bmi_lz_data(ar, trailer, 4);\n\n\tif (ret != 0)\n\t\treturn ret;\n\n\t \n\tret = ath10k_bmi_lz_stream_start(ar, 0x00);\n\n\treturn ret;\n}\n\nint ath10k_bmi_set_start(struct ath10k *ar, u32 address)\n{\n\tstruct bmi_cmd cmd;\n\tu32 cmdlen = sizeof(cmd.id) + sizeof(cmd.set_app_start);\n\tint ret;\n\n\tif (ar->bmi.done_sent) {\n\t\tath10k_warn(ar, \"bmi set start command disallowed\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tcmd.id = __cpu_to_le32(BMI_SET_APP_START);\n\tcmd.set_app_start.addr = __cpu_to_le32(address);\n\n\tret = ath10k_hif_exchange_bmi_msg(ar, &cmd, cmdlen, NULL, NULL);\n\tif (ret) {\n\t\tath10k_warn(ar, \"unable to set start to the device:%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}