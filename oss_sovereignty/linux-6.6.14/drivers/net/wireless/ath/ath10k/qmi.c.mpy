{
  "module_name": "qmi.c",
  "hash_id": "a8113f63fd6821ea8775b2146372b63e33c6c8aa79e088609ff1f7147e3b64b7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath10k/qmi.c",
  "human_readable_source": "\n \n\n#include <linux/completion.h>\n#include <linux/device.h>\n#include <linux/debugfs.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/module.h>\n#include <linux/net.h>\n#include <linux/platform_device.h>\n#include <linux/firmware/qcom/qcom_scm.h>\n#include <linux/soc/qcom/smem.h>\n#include <linux/string.h>\n#include <net/sock.h>\n\n#include \"debug.h\"\n#include \"snoc.h\"\n\n#define ATH10K_QMI_CLIENT_ID\t\t0x4b4e454c\n#define ATH10K_QMI_TIMEOUT\t\t30\n#define SMEM_IMAGE_VERSION_TABLE       469\n#define SMEM_IMAGE_TABLE_CNSS_INDEX     13\n#define SMEM_IMAGE_VERSION_ENTRY_SIZE\t128\n#define SMEM_IMAGE_VERSION_NAME_SIZE\t75\n\nstatic int ath10k_qmi_map_msa_permission(struct ath10k_qmi *qmi,\n\t\t\t\t\t struct ath10k_msa_mem_info *mem_info)\n{\n\tstruct qcom_scm_vmperm dst_perms[3];\n\tstruct ath10k *ar = qmi->ar;\n\tu64 src_perms;\n\tu32 perm_count;\n\tint ret;\n\n\tsrc_perms = BIT(QCOM_SCM_VMID_HLOS);\n\n\tdst_perms[0].vmid = QCOM_SCM_VMID_MSS_MSA;\n\tdst_perms[0].perm = QCOM_SCM_PERM_RW;\n\tdst_perms[1].vmid = QCOM_SCM_VMID_WLAN;\n\tdst_perms[1].perm = QCOM_SCM_PERM_RW;\n\n\tif (mem_info->secure) {\n\t\tperm_count = 2;\n\t} else {\n\t\tdst_perms[2].vmid = QCOM_SCM_VMID_WLAN_CE;\n\t\tdst_perms[2].perm = QCOM_SCM_PERM_RW;\n\t\tperm_count = 3;\n\t}\n\n\tret = qcom_scm_assign_mem(mem_info->addr, mem_info->size,\n\t\t\t\t  &src_perms, dst_perms, perm_count);\n\tif (ret < 0)\n\t\tath10k_err(ar, \"failed to assign msa map permissions: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int ath10k_qmi_unmap_msa_permission(struct ath10k_qmi *qmi,\n\t\t\t\t\t   struct ath10k_msa_mem_info *mem_info)\n{\n\tstruct qcom_scm_vmperm dst_perms;\n\tstruct ath10k *ar = qmi->ar;\n\tu64 src_perms;\n\tint ret;\n\n\tsrc_perms = BIT(QCOM_SCM_VMID_MSS_MSA) | BIT(QCOM_SCM_VMID_WLAN);\n\n\tif (!mem_info->secure)\n\t\tsrc_perms |= BIT(QCOM_SCM_VMID_WLAN_CE);\n\n\tdst_perms.vmid = QCOM_SCM_VMID_HLOS;\n\tdst_perms.perm = QCOM_SCM_PERM_RW;\n\n\tret = qcom_scm_assign_mem(mem_info->addr, mem_info->size,\n\t\t\t\t  &src_perms, &dst_perms, 1);\n\tif (ret < 0)\n\t\tath10k_err(ar, \"failed to unmap msa permissions: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int ath10k_qmi_setup_msa_permissions(struct ath10k_qmi *qmi)\n{\n\tint ret;\n\tint i;\n\n\tif (qmi->msa_fixed_perm)\n\t\treturn 0;\n\n\tfor (i = 0; i < qmi->nr_mem_region; i++) {\n\t\tret = ath10k_qmi_map_msa_permission(qmi, &qmi->mem_region[i]);\n\t\tif (ret)\n\t\t\tgoto err_unmap;\n\t}\n\n\treturn 0;\n\nerr_unmap:\n\tfor (i--; i >= 0; i--)\n\t\tath10k_qmi_unmap_msa_permission(qmi, &qmi->mem_region[i]);\n\treturn ret;\n}\n\nstatic void ath10k_qmi_remove_msa_permission(struct ath10k_qmi *qmi)\n{\n\tint i;\n\n\tif (qmi->msa_fixed_perm)\n\t\treturn;\n\n\tfor (i = 0; i < qmi->nr_mem_region; i++)\n\t\tath10k_qmi_unmap_msa_permission(qmi, &qmi->mem_region[i]);\n}\n\nstatic int ath10k_qmi_msa_mem_info_send_sync_msg(struct ath10k_qmi *qmi)\n{\n\tstruct wlfw_msa_info_resp_msg_v01 resp = {};\n\tstruct wlfw_msa_info_req_msg_v01 req = {};\n\tstruct ath10k *ar = qmi->ar;\n\tphys_addr_t max_mapped_addr;\n\tstruct qmi_txn txn;\n\tint ret;\n\tint i;\n\n\treq.msa_addr = ar->msa.paddr;\n\treq.size = ar->msa.mem_size;\n\n\tret = qmi_txn_init(&qmi->qmi_hdl, &txn,\n\t\t\t   wlfw_msa_info_resp_msg_v01_ei, &resp);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = qmi_send_request(&qmi->qmi_hdl, NULL, &txn,\n\t\t\t       QMI_WLFW_MSA_INFO_REQ_V01,\n\t\t\t       WLFW_MSA_INFO_REQ_MSG_V01_MAX_MSG_LEN,\n\t\t\t       wlfw_msa_info_req_msg_v01_ei, &req);\n\tif (ret < 0) {\n\t\tqmi_txn_cancel(&txn);\n\t\tath10k_err(ar, \"failed to send msa mem info req: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = qmi_txn_wait(&txn, ATH10K_QMI_TIMEOUT * HZ);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (resp.resp.result != QMI_RESULT_SUCCESS_V01) {\n\t\tath10k_err(ar, \"msa info req rejected: %d\\n\", resp.resp.error);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (resp.mem_region_info_len > QMI_WLFW_MAX_MEM_REG_V01) {\n\t\tath10k_err(ar, \"invalid memory region length received: %d\\n\",\n\t\t\t   resp.mem_region_info_len);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmax_mapped_addr = ar->msa.paddr + ar->msa.mem_size;\n\tqmi->nr_mem_region = resp.mem_region_info_len;\n\tfor (i = 0; i < resp.mem_region_info_len; i++) {\n\t\tif (resp.mem_region_info[i].size > ar->msa.mem_size ||\n\t\t    resp.mem_region_info[i].region_addr > max_mapped_addr ||\n\t\t    resp.mem_region_info[i].region_addr < ar->msa.paddr ||\n\t\t    resp.mem_region_info[i].size +\n\t\t    resp.mem_region_info[i].region_addr > max_mapped_addr) {\n\t\t\tath10k_err(ar, \"received out of range memory region address 0x%llx with size 0x%x, aborting\\n\",\n\t\t\t\t   resp.mem_region_info[i].region_addr,\n\t\t\t\t   resp.mem_region_info[i].size);\n\t\t\tret = -EINVAL;\n\t\t\tgoto fail_unwind;\n\t\t}\n\t\tqmi->mem_region[i].addr = resp.mem_region_info[i].region_addr;\n\t\tqmi->mem_region[i].size = resp.mem_region_info[i].size;\n\t\tqmi->mem_region[i].secure = resp.mem_region_info[i].secure_flag;\n\t\tath10k_dbg(ar, ATH10K_DBG_QMI,\n\t\t\t   \"qmi msa mem region %d addr 0x%pa size 0x%x flag 0x%08x\\n\",\n\t\t\t   i, &qmi->mem_region[i].addr,\n\t\t\t   qmi->mem_region[i].size,\n\t\t\t   qmi->mem_region[i].secure);\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_QMI, \"qmi msa mem info request completed\\n\");\n\treturn 0;\n\nfail_unwind:\n\tmemset(&qmi->mem_region[0], 0, sizeof(qmi->mem_region[0]) * i);\nout:\n\treturn ret;\n}\n\nstatic int ath10k_qmi_msa_ready_send_sync_msg(struct ath10k_qmi *qmi)\n{\n\tstruct wlfw_msa_ready_resp_msg_v01 resp = {};\n\tstruct wlfw_msa_ready_req_msg_v01 req = {};\n\tstruct ath10k *ar = qmi->ar;\n\tstruct qmi_txn txn;\n\tint ret;\n\n\tret = qmi_txn_init(&qmi->qmi_hdl, &txn,\n\t\t\t   wlfw_msa_ready_resp_msg_v01_ei, &resp);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = qmi_send_request(&qmi->qmi_hdl, NULL, &txn,\n\t\t\t       QMI_WLFW_MSA_READY_REQ_V01,\n\t\t\t       WLFW_MSA_READY_REQ_MSG_V01_MAX_MSG_LEN,\n\t\t\t       wlfw_msa_ready_req_msg_v01_ei, &req);\n\tif (ret < 0) {\n\t\tqmi_txn_cancel(&txn);\n\t\tath10k_err(ar, \"failed to send msa mem ready request: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = qmi_txn_wait(&txn, ATH10K_QMI_TIMEOUT * HZ);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (resp.resp.result != QMI_RESULT_SUCCESS_V01) {\n\t\tath10k_err(ar, \"msa ready request rejected: %d\\n\", resp.resp.error);\n\t\tret = -EINVAL;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_QMI, \"qmi msa mem ready request completed\\n\");\n\treturn 0;\n\nout:\n\treturn ret;\n}\n\nstatic int ath10k_qmi_bdf_dnld_send_sync(struct ath10k_qmi *qmi)\n{\n\tstruct wlfw_bdf_download_resp_msg_v01 resp = {};\n\tstruct wlfw_bdf_download_req_msg_v01 *req;\n\tstruct ath10k *ar = qmi->ar;\n\tunsigned int remaining;\n\tstruct qmi_txn txn;\n\tconst u8 *temp;\n\tint ret;\n\n\treq = kzalloc(sizeof(*req), GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\ttemp = ar->normal_mode_fw.board_data;\n\tremaining = ar->normal_mode_fw.board_len;\n\n\twhile (remaining) {\n\t\treq->valid = 1;\n\t\treq->file_id_valid = 1;\n\t\treq->file_id = 0;\n\t\treq->total_size_valid = 1;\n\t\treq->total_size = ar->normal_mode_fw.board_len;\n\t\treq->seg_id_valid = 1;\n\t\treq->data_valid = 1;\n\t\treq->end_valid = 1;\n\n\t\tif (remaining > QMI_WLFW_MAX_DATA_SIZE_V01) {\n\t\t\treq->data_len = QMI_WLFW_MAX_DATA_SIZE_V01;\n\t\t} else {\n\t\t\treq->data_len = remaining;\n\t\t\treq->end = 1;\n\t\t}\n\n\t\tmemcpy(req->data, temp, req->data_len);\n\n\t\tret = qmi_txn_init(&qmi->qmi_hdl, &txn,\n\t\t\t\t   wlfw_bdf_download_resp_msg_v01_ei,\n\t\t\t\t   &resp);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tret = qmi_send_request(&qmi->qmi_hdl, NULL, &txn,\n\t\t\t\t       QMI_WLFW_BDF_DOWNLOAD_REQ_V01,\n\t\t\t\t       WLFW_BDF_DOWNLOAD_REQ_MSG_V01_MAX_MSG_LEN,\n\t\t\t\t       wlfw_bdf_download_req_msg_v01_ei, req);\n\t\tif (ret < 0) {\n\t\t\tqmi_txn_cancel(&txn);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = qmi_txn_wait(&txn, ATH10K_QMI_TIMEOUT * HZ);\n\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\t \n\t\tif (resp.resp.result != QMI_RESULT_SUCCESS_V01 &&\n\t\t    !(req->end == 1 &&\n\t\t      resp.resp.result == QMI_ERR_MALFORMED_MSG_V01)) {\n\t\t\tath10k_err(ar, \"failed to download board data file: %d\\n\",\n\t\t\t\t   resp.resp.error);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tremaining -= req->data_len;\n\t\ttemp += req->data_len;\n\t\treq->seg_id++;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_QMI, \"qmi bdf download request completed\\n\");\n\n\tkfree(req);\n\treturn 0;\n\nout:\n\tkfree(req);\n\treturn ret;\n}\n\nstatic int ath10k_qmi_send_cal_report_req(struct ath10k_qmi *qmi)\n{\n\tstruct wlfw_cal_report_resp_msg_v01 resp = {};\n\tstruct wlfw_cal_report_req_msg_v01 req = {};\n\tstruct ath10k *ar = qmi->ar;\n\tstruct ath10k_snoc *ar_snoc = ath10k_snoc_priv(ar);\n\tstruct qmi_txn txn;\n\tint i, j = 0;\n\tint ret;\n\n\tif (ar_snoc->xo_cal_supported) {\n\t\treq.xo_cal_data_valid = 1;\n\t\treq.xo_cal_data = ar_snoc->xo_cal_data;\n\t}\n\n\tret = qmi_txn_init(&qmi->qmi_hdl, &txn, wlfw_cal_report_resp_msg_v01_ei,\n\t\t\t   &resp);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tfor (i = 0; i < QMI_WLFW_MAX_NUM_CAL_V01; i++) {\n\t\tif (qmi->cal_data[i].total_size &&\n\t\t    qmi->cal_data[i].data) {\n\t\t\treq.meta_data[j] = qmi->cal_data[i].cal_id;\n\t\t\tj++;\n\t\t}\n\t}\n\treq.meta_data_len = j;\n\n\tret = qmi_send_request(&qmi->qmi_hdl, NULL, &txn,\n\t\t\t       QMI_WLFW_CAL_REPORT_REQ_V01,\n\t\t\t       WLFW_CAL_REPORT_REQ_MSG_V01_MAX_MSG_LEN,\n\t\t\t       wlfw_cal_report_req_msg_v01_ei, &req);\n\tif (ret < 0) {\n\t\tqmi_txn_cancel(&txn);\n\t\tath10k_err(ar, \"failed to send calibration request: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = qmi_txn_wait(&txn, ATH10K_QMI_TIMEOUT * HZ);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (resp.resp.result != QMI_RESULT_SUCCESS_V01) {\n\t\tath10k_err(ar, \"calibration request rejected: %d\\n\", resp.resp.error);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_QMI, \"qmi cal report request completed\\n\");\n\treturn 0;\n\nout:\n\treturn ret;\n}\n\nstatic int\nath10k_qmi_mode_send_sync_msg(struct ath10k *ar, enum wlfw_driver_mode_enum_v01 mode)\n{\n\tstruct ath10k_snoc *ar_snoc = ath10k_snoc_priv(ar);\n\tstruct ath10k_qmi *qmi = ar_snoc->qmi;\n\tstruct wlfw_wlan_mode_resp_msg_v01 resp = {};\n\tstruct wlfw_wlan_mode_req_msg_v01 req = {};\n\tstruct qmi_txn txn;\n\tint ret;\n\n\tret = qmi_txn_init(&qmi->qmi_hdl, &txn,\n\t\t\t   wlfw_wlan_mode_resp_msg_v01_ei,\n\t\t\t   &resp);\n\tif (ret < 0)\n\t\tgoto out;\n\n\treq.mode = mode;\n\treq.hw_debug_valid = 1;\n\treq.hw_debug = 0;\n\n\tret = qmi_send_request(&qmi->qmi_hdl, NULL, &txn,\n\t\t\t       QMI_WLFW_WLAN_MODE_REQ_V01,\n\t\t\t       WLFW_WLAN_MODE_REQ_MSG_V01_MAX_MSG_LEN,\n\t\t\t       wlfw_wlan_mode_req_msg_v01_ei, &req);\n\tif (ret < 0) {\n\t\tqmi_txn_cancel(&txn);\n\t\tath10k_err(ar, \"failed to send wlan mode %d request: %d\\n\", mode, ret);\n\t\tgoto out;\n\t}\n\n\tret = qmi_txn_wait(&txn, ATH10K_QMI_TIMEOUT * HZ);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (resp.resp.result != QMI_RESULT_SUCCESS_V01) {\n\t\tath10k_err(ar, \"more request rejected: %d\\n\", resp.resp.error);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_QMI, \"qmi wlan mode req completed: %d\\n\", mode);\n\treturn 0;\n\nout:\n\treturn ret;\n}\n\nstatic int\nath10k_qmi_cfg_send_sync_msg(struct ath10k *ar,\n\t\t\t     struct ath10k_qmi_wlan_enable_cfg *config,\n\t\t\t     const char *version)\n{\n\tstruct ath10k_snoc *ar_snoc = ath10k_snoc_priv(ar);\n\tstruct ath10k_qmi *qmi = ar_snoc->qmi;\n\tstruct wlfw_wlan_cfg_resp_msg_v01 resp = {};\n\tstruct wlfw_wlan_cfg_req_msg_v01 *req;\n\tstruct qmi_txn txn;\n\tint ret;\n\tu32 i;\n\n\treq = kzalloc(sizeof(*req), GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tret = qmi_txn_init(&qmi->qmi_hdl, &txn,\n\t\t\t   wlfw_wlan_cfg_resp_msg_v01_ei,\n\t\t\t   &resp);\n\tif (ret < 0)\n\t\tgoto out;\n\n\treq->host_version_valid = 0;\n\n\treq->tgt_cfg_valid = 1;\n\tif (config->num_ce_tgt_cfg > QMI_WLFW_MAX_NUM_CE_V01)\n\t\treq->tgt_cfg_len = QMI_WLFW_MAX_NUM_CE_V01;\n\telse\n\t\treq->tgt_cfg_len = config->num_ce_tgt_cfg;\n\tfor (i = 0; i < req->tgt_cfg_len; i++) {\n\t\treq->tgt_cfg[i].pipe_num = config->ce_tgt_cfg[i].pipe_num;\n\t\treq->tgt_cfg[i].pipe_dir = config->ce_tgt_cfg[i].pipe_dir;\n\t\treq->tgt_cfg[i].nentries = config->ce_tgt_cfg[i].nentries;\n\t\treq->tgt_cfg[i].nbytes_max = config->ce_tgt_cfg[i].nbytes_max;\n\t\treq->tgt_cfg[i].flags = config->ce_tgt_cfg[i].flags;\n\t}\n\n\treq->svc_cfg_valid = 1;\n\tif (config->num_ce_svc_pipe_cfg > QMI_WLFW_MAX_NUM_SVC_V01)\n\t\treq->svc_cfg_len = QMI_WLFW_MAX_NUM_SVC_V01;\n\telse\n\t\treq->svc_cfg_len = config->num_ce_svc_pipe_cfg;\n\tfor (i = 0; i < req->svc_cfg_len; i++) {\n\t\treq->svc_cfg[i].service_id = config->ce_svc_cfg[i].service_id;\n\t\treq->svc_cfg[i].pipe_dir = config->ce_svc_cfg[i].pipe_dir;\n\t\treq->svc_cfg[i].pipe_num = config->ce_svc_cfg[i].pipe_num;\n\t}\n\n\treq->shadow_reg_valid = 1;\n\tif (config->num_shadow_reg_cfg >\n\t    QMI_WLFW_MAX_NUM_SHADOW_REG_V01)\n\t\treq->shadow_reg_len = QMI_WLFW_MAX_NUM_SHADOW_REG_V01;\n\telse\n\t\treq->shadow_reg_len = config->num_shadow_reg_cfg;\n\n\tmemcpy(req->shadow_reg, config->shadow_reg_cfg,\n\t       sizeof(struct wlfw_shadow_reg_cfg_s_v01) * req->shadow_reg_len);\n\n\tret = qmi_send_request(&qmi->qmi_hdl, NULL, &txn,\n\t\t\t       QMI_WLFW_WLAN_CFG_REQ_V01,\n\t\t\t       WLFW_WLAN_CFG_REQ_MSG_V01_MAX_MSG_LEN,\n\t\t\t       wlfw_wlan_cfg_req_msg_v01_ei, req);\n\tif (ret < 0) {\n\t\tqmi_txn_cancel(&txn);\n\t\tath10k_err(ar, \"failed to send config request: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = qmi_txn_wait(&txn, ATH10K_QMI_TIMEOUT * HZ);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (resp.resp.result != QMI_RESULT_SUCCESS_V01) {\n\t\tath10k_err(ar, \"config request rejected: %d\\n\", resp.resp.error);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_QMI, \"qmi config request completed\\n\");\n\tkfree(req);\n\treturn 0;\n\nout:\n\tkfree(req);\n\treturn ret;\n}\n\nint ath10k_qmi_wlan_enable(struct ath10k *ar,\n\t\t\t   struct ath10k_qmi_wlan_enable_cfg *config,\n\t\t\t   enum wlfw_driver_mode_enum_v01 mode,\n\t\t\t   const char *version)\n{\n\tint ret;\n\n\tath10k_dbg(ar, ATH10K_DBG_QMI, \"qmi mode %d config %p\\n\",\n\t\t   mode, config);\n\n\tret = ath10k_qmi_cfg_send_sync_msg(ar, config, version);\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to send qmi config: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ath10k_qmi_mode_send_sync_msg(ar, mode);\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to send qmi mode: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint ath10k_qmi_wlan_disable(struct ath10k *ar)\n{\n\treturn ath10k_qmi_mode_send_sync_msg(ar, QMI_WLFW_OFF_V01);\n}\n\nstatic void ath10k_qmi_add_wlan_ver_smem(struct ath10k *ar, const char *fw_build_id)\n{\n\tu8 *table_ptr;\n\tsize_t smem_item_size;\n\tconst u32 smem_img_idx_wlan = SMEM_IMAGE_TABLE_CNSS_INDEX *\n\t\t\t\t      SMEM_IMAGE_VERSION_ENTRY_SIZE;\n\n\ttable_ptr = qcom_smem_get(QCOM_SMEM_HOST_ANY,\n\t\t\t\t  SMEM_IMAGE_VERSION_TABLE,\n\t\t\t\t  &smem_item_size);\n\n\tif (IS_ERR(table_ptr)) {\n\t\tath10k_err(ar, \"smem image version table not found\\n\");\n\t\treturn;\n\t}\n\n\tif (smem_img_idx_wlan + SMEM_IMAGE_VERSION_ENTRY_SIZE >\n\t    smem_item_size) {\n\t\tath10k_err(ar, \"smem block size too small: %zu\\n\",\n\t\t\t   smem_item_size);\n\t\treturn;\n\t}\n\n\tstrscpy(table_ptr + smem_img_idx_wlan, fw_build_id,\n\t\tSMEM_IMAGE_VERSION_NAME_SIZE);\n}\n\nstatic int ath10k_qmi_cap_send_sync_msg(struct ath10k_qmi *qmi)\n{\n\tstruct wlfw_cap_resp_msg_v01 *resp;\n\tstruct wlfw_cap_req_msg_v01 req = {};\n\tstruct ath10k *ar = qmi->ar;\n\tstruct ath10k_snoc *ar_snoc = ath10k_snoc_priv(ar);\n\tstruct qmi_txn txn;\n\tint ret;\n\n\tresp = kzalloc(sizeof(*resp), GFP_KERNEL);\n\tif (!resp)\n\t\treturn -ENOMEM;\n\n\tret = qmi_txn_init(&qmi->qmi_hdl, &txn, wlfw_cap_resp_msg_v01_ei, resp);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = qmi_send_request(&qmi->qmi_hdl, NULL, &txn,\n\t\t\t       QMI_WLFW_CAP_REQ_V01,\n\t\t\t       WLFW_CAP_REQ_MSG_V01_MAX_MSG_LEN,\n\t\t\t       wlfw_cap_req_msg_v01_ei, &req);\n\tif (ret < 0) {\n\t\tqmi_txn_cancel(&txn);\n\t\tath10k_err(ar, \"failed to send capability request: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = qmi_txn_wait(&txn, ATH10K_QMI_TIMEOUT * HZ);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (resp->resp.result != QMI_RESULT_SUCCESS_V01) {\n\t\tath10k_err(ar, \"capability req rejected: %d\\n\", resp->resp.error);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (resp->chip_info_valid) {\n\t\tqmi->chip_info.chip_id = resp->chip_info.chip_id;\n\t\tqmi->chip_info.chip_family = resp->chip_info.chip_family;\n\t} else {\n\t\tqmi->chip_info.chip_id = 0xFF;\n\t}\n\n\tif (resp->board_info_valid)\n\t\tqmi->board_info.board_id = resp->board_info.board_id;\n\telse\n\t\tqmi->board_info.board_id = 0xFF;\n\n\tif (resp->soc_info_valid)\n\t\tqmi->soc_info.soc_id = resp->soc_info.soc_id;\n\n\tif (resp->fw_version_info_valid) {\n\t\tqmi->fw_version = resp->fw_version_info.fw_version;\n\t\tstrscpy(qmi->fw_build_timestamp, resp->fw_version_info.fw_build_timestamp,\n\t\t\tsizeof(qmi->fw_build_timestamp));\n\t}\n\n\tif (resp->fw_build_id_valid)\n\t\tstrscpy(qmi->fw_build_id, resp->fw_build_id,\n\t\t\tMAX_BUILD_ID_LEN + 1);\n\n\tif (!test_bit(ATH10K_SNOC_FLAG_REGISTERED, &ar_snoc->flags)) {\n\t\tath10k_info(ar, \"qmi chip_id 0x%x chip_family 0x%x board_id 0x%x soc_id 0x%x\",\n\t\t\t    qmi->chip_info.chip_id, qmi->chip_info.chip_family,\n\t\t\t    qmi->board_info.board_id, qmi->soc_info.soc_id);\n\t\tath10k_info(ar, \"qmi fw_version 0x%x fw_build_timestamp %s fw_build_id %s\",\n\t\t\t    qmi->fw_version, qmi->fw_build_timestamp, qmi->fw_build_id);\n\t}\n\n\tif (resp->fw_build_id_valid)\n\t\tath10k_qmi_add_wlan_ver_smem(ar, qmi->fw_build_id);\n\n\tkfree(resp);\n\treturn 0;\n\nout:\n\tkfree(resp);\n\treturn ret;\n}\n\nstatic int ath10k_qmi_host_cap_send_sync(struct ath10k_qmi *qmi)\n{\n\tstruct wlfw_host_cap_resp_msg_v01 resp = {};\n\tstruct wlfw_host_cap_req_msg_v01 req = {};\n\tconst struct qmi_elem_info *req_ei;\n\tstruct ath10k *ar = qmi->ar;\n\tstruct ath10k_snoc *ar_snoc = ath10k_snoc_priv(ar);\n\tstruct qmi_txn txn;\n\tint ret;\n\n\treq.daemon_support_valid = 1;\n\treq.daemon_support = 0;\n\n\tret = qmi_txn_init(&qmi->qmi_hdl, &txn, wlfw_host_cap_resp_msg_v01_ei,\n\t\t\t   &resp);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (test_bit(ATH10K_SNOC_FLAG_8BIT_HOST_CAP_QUIRK, &ar_snoc->flags))\n\t\treq_ei = wlfw_host_cap_8bit_req_msg_v01_ei;\n\telse\n\t\treq_ei = wlfw_host_cap_req_msg_v01_ei;\n\n\tret = qmi_send_request(&qmi->qmi_hdl, NULL, &txn,\n\t\t\t       QMI_WLFW_HOST_CAP_REQ_V01,\n\t\t\t       WLFW_HOST_CAP_REQ_MSG_V01_MAX_MSG_LEN,\n\t\t\t       req_ei, &req);\n\tif (ret < 0) {\n\t\tqmi_txn_cancel(&txn);\n\t\tath10k_err(ar, \"failed to send host capability request: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = qmi_txn_wait(&txn, ATH10K_QMI_TIMEOUT * HZ);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tif (resp.resp.result != QMI_RESULT_SUCCESS_V01 &&\n\t    resp.resp.error != QMI_ERR_NOT_SUPPORTED_V01) {\n\t\tath10k_err(ar, \"host capability request rejected: %d\\n\", resp.resp.error);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_QMI, \"qmi host capability request completed\\n\");\n\treturn 0;\n\nout:\n\treturn ret;\n}\n\nint ath10k_qmi_set_fw_log_mode(struct ath10k *ar, u8 fw_log_mode)\n{\n\tstruct ath10k_snoc *ar_snoc = ath10k_snoc_priv(ar);\n\tstruct wlfw_ini_resp_msg_v01 resp = {};\n\tstruct ath10k_qmi *qmi = ar_snoc->qmi;\n\tstruct wlfw_ini_req_msg_v01 req = {};\n\tstruct qmi_txn txn;\n\tint ret;\n\n\treq.enablefwlog_valid = 1;\n\treq.enablefwlog = fw_log_mode;\n\n\tret = qmi_txn_init(&qmi->qmi_hdl, &txn, wlfw_ini_resp_msg_v01_ei,\n\t\t\t   &resp);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = qmi_send_request(&qmi->qmi_hdl, NULL, &txn,\n\t\t\t       QMI_WLFW_INI_REQ_V01,\n\t\t\t       WLFW_INI_REQ_MSG_V01_MAX_MSG_LEN,\n\t\t\t       wlfw_ini_req_msg_v01_ei, &req);\n\tif (ret < 0) {\n\t\tqmi_txn_cancel(&txn);\n\t\tath10k_err(ar, \"failed to send fw log request: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = qmi_txn_wait(&txn, ATH10K_QMI_TIMEOUT * HZ);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (resp.resp.result != QMI_RESULT_SUCCESS_V01) {\n\t\tath10k_err(ar, \"fw log request rejected: %d\\n\",\n\t\t\t   resp.resp.error);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tath10k_dbg(ar, ATH10K_DBG_QMI, \"qmi fw log request completed, mode: %d\\n\",\n\t\t   fw_log_mode);\n\treturn 0;\n\nout:\n\treturn ret;\n}\n\nstatic int\nath10k_qmi_ind_register_send_sync_msg(struct ath10k_qmi *qmi)\n{\n\tstruct wlfw_ind_register_resp_msg_v01 resp = {};\n\tstruct wlfw_ind_register_req_msg_v01 req = {};\n\tstruct ath10k *ar = qmi->ar;\n\tstruct ath10k_snoc *ar_snoc = ath10k_snoc_priv(ar);\n\tstruct qmi_txn txn;\n\tint ret;\n\n\treq.client_id_valid = 1;\n\treq.client_id = ATH10K_QMI_CLIENT_ID;\n\treq.fw_ready_enable_valid = 1;\n\treq.fw_ready_enable = 1;\n\treq.msa_ready_enable_valid = 1;\n\treq.msa_ready_enable = 1;\n\n\tif (ar_snoc->xo_cal_supported) {\n\t\treq.xo_cal_enable_valid = 1;\n\t\treq.xo_cal_enable = 1;\n\t}\n\n\tret = qmi_txn_init(&qmi->qmi_hdl, &txn,\n\t\t\t   wlfw_ind_register_resp_msg_v01_ei, &resp);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = qmi_send_request(&qmi->qmi_hdl, NULL, &txn,\n\t\t\t       QMI_WLFW_IND_REGISTER_REQ_V01,\n\t\t\t       WLFW_IND_REGISTER_REQ_MSG_V01_MAX_MSG_LEN,\n\t\t\t       wlfw_ind_register_req_msg_v01_ei, &req);\n\tif (ret < 0) {\n\t\tqmi_txn_cancel(&txn);\n\t\tath10k_err(ar, \"failed to send indication registered request: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = qmi_txn_wait(&txn, ATH10K_QMI_TIMEOUT * HZ);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (resp.resp.result != QMI_RESULT_SUCCESS_V01) {\n\t\tath10k_err(ar, \"indication request rejected: %d\\n\", resp.resp.error);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (resp.fw_status_valid) {\n\t\tif (resp.fw_status & QMI_WLFW_FW_READY_V01)\n\t\t\tqmi->fw_ready = true;\n\t}\n\tath10k_dbg(ar, ATH10K_DBG_QMI, \"qmi indication register request completed\\n\");\n\treturn 0;\n\nout:\n\treturn ret;\n}\n\nstatic void ath10k_qmi_event_server_arrive(struct ath10k_qmi *qmi)\n{\n\tstruct ath10k *ar = qmi->ar;\n\tint ret;\n\n\tret = ath10k_qmi_ind_register_send_sync_msg(qmi);\n\tif (ret)\n\t\treturn;\n\n\tif (qmi->fw_ready) {\n\t\tath10k_snoc_fw_indication(ar, ATH10K_QMI_EVENT_FW_READY_IND);\n\t\treturn;\n\t}\n\n\tret = ath10k_qmi_host_cap_send_sync(qmi);\n\tif (ret)\n\t\treturn;\n\n\tret = ath10k_qmi_msa_mem_info_send_sync_msg(qmi);\n\tif (ret)\n\t\treturn;\n\n\t \n\tmsleep(20);\n\n\tret = ath10k_qmi_setup_msa_permissions(qmi);\n\tif (ret)\n\t\treturn;\n\n\tret = ath10k_qmi_msa_ready_send_sync_msg(qmi);\n\tif (ret)\n\t\tgoto err_setup_msa;\n\n\tret = ath10k_qmi_cap_send_sync_msg(qmi);\n\tif (ret)\n\t\tgoto err_setup_msa;\n\n\treturn;\n\nerr_setup_msa:\n\tath10k_qmi_remove_msa_permission(qmi);\n}\n\nstatic int ath10k_qmi_fetch_board_file(struct ath10k_qmi *qmi)\n{\n\tstruct ath10k *ar = qmi->ar;\n\tint ret;\n\n\tar->hif.bus = ATH10K_BUS_SNOC;\n\tar->id.qmi_ids_valid = true;\n\tar->id.qmi_board_id = qmi->board_info.board_id;\n\tar->id.qmi_chip_id = qmi->chip_info.chip_id;\n\tar->hw_params.fw.dir = WCN3990_HW_1_0_FW_DIR;\n\n\tret = ath10k_core_check_dt(ar);\n\tif (ret)\n\t\tath10k_dbg(ar, ATH10K_DBG_QMI, \"DT bdf variant name not set.\\n\");\n\n\treturn ath10k_core_fetch_board_file(qmi->ar, ATH10K_BD_IE_BOARD);\n}\n\nstatic int\nath10k_qmi_driver_event_post(struct ath10k_qmi *qmi,\n\t\t\t     enum ath10k_qmi_driver_event_type type,\n\t\t\t     void *data)\n{\n\tstruct ath10k_qmi_driver_event *event;\n\n\tevent = kzalloc(sizeof(*event), GFP_ATOMIC);\n\tif (!event)\n\t\treturn -ENOMEM;\n\n\tevent->type = type;\n\tevent->data = data;\n\n\tspin_lock(&qmi->event_lock);\n\tlist_add_tail(&event->list, &qmi->event_list);\n\tspin_unlock(&qmi->event_lock);\n\n\tqueue_work(qmi->event_wq, &qmi->event_work);\n\n\treturn 0;\n}\n\nstatic void ath10k_qmi_event_server_exit(struct ath10k_qmi *qmi)\n{\n\tstruct ath10k *ar = qmi->ar;\n\tstruct ath10k_snoc *ar_snoc = ath10k_snoc_priv(ar);\n\n\tath10k_qmi_remove_msa_permission(qmi);\n\tath10k_core_free_board_files(ar);\n\tif (!test_bit(ATH10K_SNOC_FLAG_UNREGISTERING, &ar_snoc->flags) &&\n\t    !test_bit(ATH10K_SNOC_FLAG_MODEM_STOPPED, &ar_snoc->flags))\n\t\tath10k_snoc_fw_crashed_dump(ar);\n\n\tath10k_snoc_fw_indication(ar, ATH10K_QMI_EVENT_FW_DOWN_IND);\n\tath10k_dbg(ar, ATH10K_DBG_QMI, \"wifi fw qmi service disconnected\\n\");\n}\n\nstatic void ath10k_qmi_event_msa_ready(struct ath10k_qmi *qmi)\n{\n\tint ret;\n\n\tret = ath10k_qmi_fetch_board_file(qmi);\n\tif (ret)\n\t\tgoto out;\n\n\tret = ath10k_qmi_bdf_dnld_send_sync(qmi);\n\tif (ret)\n\t\tgoto out;\n\n\tret = ath10k_qmi_send_cal_report_req(qmi);\n\nout:\n\treturn;\n}\n\nstatic int ath10k_qmi_event_fw_ready_ind(struct ath10k_qmi *qmi)\n{\n\tstruct ath10k *ar = qmi->ar;\n\n\tath10k_dbg(ar, ATH10K_DBG_QMI, \"wifi fw ready event received\\n\");\n\tath10k_snoc_fw_indication(ar, ATH10K_QMI_EVENT_FW_READY_IND);\n\n\treturn 0;\n}\n\nstatic void ath10k_qmi_fw_ready_ind(struct qmi_handle *qmi_hdl,\n\t\t\t\t    struct sockaddr_qrtr *sq,\n\t\t\t\t    struct qmi_txn *txn, const void *data)\n{\n\tstruct ath10k_qmi *qmi = container_of(qmi_hdl, struct ath10k_qmi, qmi_hdl);\n\n\tath10k_qmi_driver_event_post(qmi, ATH10K_QMI_EVENT_FW_READY_IND, NULL);\n}\n\nstatic void ath10k_qmi_msa_ready_ind(struct qmi_handle *qmi_hdl,\n\t\t\t\t     struct sockaddr_qrtr *sq,\n\t\t\t\t     struct qmi_txn *txn, const void *data)\n{\n\tstruct ath10k_qmi *qmi = container_of(qmi_hdl, struct ath10k_qmi, qmi_hdl);\n\n\tath10k_qmi_driver_event_post(qmi, ATH10K_QMI_EVENT_MSA_READY_IND, NULL);\n}\n\nstatic const struct qmi_msg_handler qmi_msg_handler[] = {\n\t{\n\t\t.type = QMI_INDICATION,\n\t\t.msg_id = QMI_WLFW_FW_READY_IND_V01,\n\t\t.ei = wlfw_fw_ready_ind_msg_v01_ei,\n\t\t.decoded_size = sizeof(struct wlfw_fw_ready_ind_msg_v01),\n\t\t.fn = ath10k_qmi_fw_ready_ind,\n\t},\n\t{\n\t\t.type = QMI_INDICATION,\n\t\t.msg_id = QMI_WLFW_MSA_READY_IND_V01,\n\t\t.ei = wlfw_msa_ready_ind_msg_v01_ei,\n\t\t.decoded_size = sizeof(struct wlfw_msa_ready_ind_msg_v01),\n\t\t.fn = ath10k_qmi_msa_ready_ind,\n\t},\n\t{}\n};\n\nstatic int ath10k_qmi_new_server(struct qmi_handle *qmi_hdl,\n\t\t\t\t struct qmi_service *service)\n{\n\tstruct ath10k_qmi *qmi = container_of(qmi_hdl, struct ath10k_qmi, qmi_hdl);\n\tstruct sockaddr_qrtr *sq = &qmi->sq;\n\tstruct ath10k *ar = qmi->ar;\n\tint ret;\n\n\tsq->sq_family = AF_QIPCRTR;\n\tsq->sq_node = service->node;\n\tsq->sq_port = service->port;\n\n\tath10k_dbg(ar, ATH10K_DBG_QMI, \"wifi fw qmi service found\\n\");\n\n\tret = kernel_connect(qmi_hdl->sock, (struct sockaddr *)&qmi->sq,\n\t\t\t     sizeof(qmi->sq), 0);\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to connect to a remote QMI service port\\n\");\n\t\treturn ret;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_QMI, \"qmi wifi fw qmi service connected\\n\");\n\tath10k_qmi_driver_event_post(qmi, ATH10K_QMI_EVENT_SERVER_ARRIVE, NULL);\n\n\treturn ret;\n}\n\nstatic void ath10k_qmi_del_server(struct qmi_handle *qmi_hdl,\n\t\t\t\t  struct qmi_service *service)\n{\n\tstruct ath10k_qmi *qmi =\n\t\tcontainer_of(qmi_hdl, struct ath10k_qmi, qmi_hdl);\n\n\tqmi->fw_ready = false;\n\n\t \n\tif (qmi->state == ATH10K_QMI_STATE_INIT_DONE)\n\t\tath10k_qmi_driver_event_post(qmi, ATH10K_QMI_EVENT_SERVER_EXIT,\n\t\t\t\t\t     NULL);\n}\n\nstatic const struct qmi_ops ath10k_qmi_ops = {\n\t.new_server = ath10k_qmi_new_server,\n\t.del_server = ath10k_qmi_del_server,\n};\n\nstatic void ath10k_qmi_driver_event_work(struct work_struct *work)\n{\n\tstruct ath10k_qmi *qmi = container_of(work, struct ath10k_qmi,\n\t\t\t\t\t      event_work);\n\tstruct ath10k_qmi_driver_event *event;\n\tstruct ath10k *ar = qmi->ar;\n\n\tspin_lock(&qmi->event_lock);\n\twhile (!list_empty(&qmi->event_list)) {\n\t\tevent = list_first_entry(&qmi->event_list,\n\t\t\t\t\t struct ath10k_qmi_driver_event, list);\n\t\tlist_del(&event->list);\n\t\tspin_unlock(&qmi->event_lock);\n\n\t\tswitch (event->type) {\n\t\tcase ATH10K_QMI_EVENT_SERVER_ARRIVE:\n\t\t\tath10k_qmi_event_server_arrive(qmi);\n\t\t\tbreak;\n\t\tcase ATH10K_QMI_EVENT_SERVER_EXIT:\n\t\t\tath10k_qmi_event_server_exit(qmi);\n\t\t\tbreak;\n\t\tcase ATH10K_QMI_EVENT_FW_READY_IND:\n\t\t\tath10k_qmi_event_fw_ready_ind(qmi);\n\t\t\tbreak;\n\t\tcase ATH10K_QMI_EVENT_MSA_READY_IND:\n\t\t\tath10k_qmi_event_msa_ready(qmi);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tath10k_warn(ar, \"invalid event type: %d\", event->type);\n\t\t\tbreak;\n\t\t}\n\t\tkfree(event);\n\t\tspin_lock(&qmi->event_lock);\n\t}\n\tspin_unlock(&qmi->event_lock);\n}\n\nint ath10k_qmi_init(struct ath10k *ar, u32 msa_size)\n{\n\tstruct ath10k_snoc *ar_snoc = ath10k_snoc_priv(ar);\n\tstruct device *dev = ar->dev;\n\tstruct ath10k_qmi *qmi;\n\tint ret;\n\n\tqmi = kzalloc(sizeof(*qmi), GFP_KERNEL);\n\tif (!qmi)\n\t\treturn -ENOMEM;\n\n\tqmi->ar = ar;\n\tar_snoc->qmi = qmi;\n\n\tif (of_property_read_bool(dev->of_node, \"qcom,msa-fixed-perm\"))\n\t\tqmi->msa_fixed_perm = true;\n\n\tret = qmi_handle_init(&qmi->qmi_hdl,\n\t\t\t      WLFW_BDF_DOWNLOAD_REQ_MSG_V01_MAX_MSG_LEN,\n\t\t\t      &ath10k_qmi_ops, qmi_msg_handler);\n\tif (ret)\n\t\tgoto err;\n\n\tqmi->event_wq = alloc_ordered_workqueue(\"ath10k_qmi_driver_event\", 0);\n\tif (!qmi->event_wq) {\n\t\tath10k_err(ar, \"failed to allocate workqueue\\n\");\n\t\tret = -EFAULT;\n\t\tgoto err_release_qmi_handle;\n\t}\n\n\tINIT_LIST_HEAD(&qmi->event_list);\n\tspin_lock_init(&qmi->event_lock);\n\tINIT_WORK(&qmi->event_work, ath10k_qmi_driver_event_work);\n\n\tret = qmi_add_lookup(&qmi->qmi_hdl, WLFW_SERVICE_ID_V01,\n\t\t\t     WLFW_SERVICE_VERS_V01, 0);\n\tif (ret)\n\t\tgoto err_qmi_lookup;\n\n\tqmi->state = ATH10K_QMI_STATE_INIT_DONE;\n\treturn 0;\n\nerr_qmi_lookup:\n\tdestroy_workqueue(qmi->event_wq);\n\nerr_release_qmi_handle:\n\tqmi_handle_release(&qmi->qmi_hdl);\n\nerr:\n\tkfree(qmi);\n\treturn ret;\n}\n\nint ath10k_qmi_deinit(struct ath10k *ar)\n{\n\tstruct ath10k_snoc *ar_snoc = ath10k_snoc_priv(ar);\n\tstruct ath10k_qmi *qmi = ar_snoc->qmi;\n\n\tqmi->state = ATH10K_QMI_STATE_DEINIT;\n\tqmi_handle_release(&qmi->qmi_hdl);\n\tcancel_work_sync(&qmi->event_work);\n\tdestroy_workqueue(qmi->event_wq);\n\tkfree(qmi);\n\tar_snoc->qmi = NULL;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}