{
  "module_name": "ce.c",
  "hash_id": "c1d1eb9124bf9a188d855dc8bba603d0609f1a7a2dbcf2014adb5d931cfac3cb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath10k/ce.c",
  "human_readable_source": "\n \n\n#include \"hif.h\"\n#include \"ce.h\"\n#include \"debug.h\"\n\n \n\n \n\nstatic inline u32 shadow_sr_wr_ind_addr(struct ath10k *ar,\n\t\t\t\t\tstruct ath10k_ce_pipe *ce_state)\n{\n\tu32 ce_id = ce_state->id;\n\tu32 addr = 0;\n\n\tswitch (ce_id) {\n\tcase 0:\n\t\taddr = 0x00032000;\n\t\tbreak;\n\tcase 3:\n\t\taddr = 0x0003200C;\n\t\tbreak;\n\tcase 4:\n\t\taddr = 0x00032010;\n\t\tbreak;\n\tcase 5:\n\t\taddr = 0x00032014;\n\t\tbreak;\n\tcase 7:\n\t\taddr = 0x0003201C;\n\t\tbreak;\n\tdefault:\n\t\tath10k_warn(ar, \"invalid CE id: %d\", ce_id);\n\t\tbreak;\n\t}\n\treturn addr;\n}\n\nstatic inline unsigned int\nath10k_set_ring_byte(unsigned int offset,\n\t\t     struct ath10k_hw_ce_regs_addr_map *addr_map)\n{\n\treturn ((offset << addr_map->lsb) & addr_map->mask);\n}\n\nstatic inline u32 ath10k_ce_read32(struct ath10k *ar, u32 offset)\n{\n\tstruct ath10k_ce *ce = ath10k_ce_priv(ar);\n\n\treturn ce->bus_ops->read32(ar, offset);\n}\n\nstatic inline void ath10k_ce_write32(struct ath10k *ar, u32 offset, u32 value)\n{\n\tstruct ath10k_ce *ce = ath10k_ce_priv(ar);\n\n\tce->bus_ops->write32(ar, offset, value);\n}\n\nstatic inline void ath10k_ce_dest_ring_write_index_set(struct ath10k *ar,\n\t\t\t\t\t\t       u32 ce_ctrl_addr,\n\t\t\t\t\t\t       unsigned int n)\n{\n\tath10k_ce_write32(ar, ce_ctrl_addr +\n\t\t\t  ar->hw_ce_regs->dst_wr_index_addr, n);\n}\n\nstatic inline u32 ath10k_ce_dest_ring_write_index_get(struct ath10k *ar,\n\t\t\t\t\t\t      u32 ce_ctrl_addr)\n{\n\treturn ath10k_ce_read32(ar, ce_ctrl_addr +\n\t\t\t\tar->hw_ce_regs->dst_wr_index_addr);\n}\n\nstatic inline void ath10k_ce_src_ring_write_index_set(struct ath10k *ar,\n\t\t\t\t\t\t      u32 ce_ctrl_addr,\n\t\t\t\t\t\t      unsigned int n)\n{\n\tath10k_ce_write32(ar, ce_ctrl_addr +\n\t\t\t  ar->hw_ce_regs->sr_wr_index_addr, n);\n}\n\nstatic inline u32 ath10k_ce_src_ring_write_index_get(struct ath10k *ar,\n\t\t\t\t\t\t     u32 ce_ctrl_addr)\n{\n\treturn ath10k_ce_read32(ar, ce_ctrl_addr +\n\t\t\t\tar->hw_ce_regs->sr_wr_index_addr);\n}\n\nstatic inline u32 ath10k_ce_src_ring_read_index_from_ddr(struct ath10k *ar,\n\t\t\t\t\t\t\t u32 ce_id)\n{\n\tstruct ath10k_ce *ce = ath10k_ce_priv(ar);\n\n\treturn ce->vaddr_rri[ce_id] & CE_DDR_RRI_MASK;\n}\n\nstatic inline u32 ath10k_ce_src_ring_read_index_get(struct ath10k *ar,\n\t\t\t\t\t\t    u32 ce_ctrl_addr)\n{\n\tstruct ath10k_ce *ce = ath10k_ce_priv(ar);\n\tu32 ce_id = COPY_ENGINE_ID(ce_ctrl_addr);\n\tstruct ath10k_ce_pipe *ce_state = &ce->ce_states[ce_id];\n\tu32 index;\n\n\tif (ar->hw_params.rri_on_ddr &&\n\t    (ce_state->attr_flags & CE_ATTR_DIS_INTR))\n\t\tindex = ath10k_ce_src_ring_read_index_from_ddr(ar, ce_id);\n\telse\n\t\tindex = ath10k_ce_read32(ar, ce_ctrl_addr +\n\t\t\t\t\t ar->hw_ce_regs->current_srri_addr);\n\n\treturn index;\n}\n\nstatic inline void\nath10k_ce_shadow_src_ring_write_index_set(struct ath10k *ar,\n\t\t\t\t\t  struct ath10k_ce_pipe *ce_state,\n\t\t\t\t\t  unsigned int value)\n{\n\tath10k_ce_write32(ar, shadow_sr_wr_ind_addr(ar, ce_state), value);\n}\n\nstatic inline void ath10k_ce_src_ring_base_addr_set(struct ath10k *ar,\n\t\t\t\t\t\t    u32 ce_id,\n\t\t\t\t\t\t    u64 addr)\n{\n\tstruct ath10k_ce *ce = ath10k_ce_priv(ar);\n\tstruct ath10k_ce_pipe *ce_state = &ce->ce_states[ce_id];\n\tu32 ce_ctrl_addr = ath10k_ce_base_address(ar, ce_id);\n\tu32 addr_lo = lower_32_bits(addr);\n\n\tath10k_ce_write32(ar, ce_ctrl_addr +\n\t\t\t  ar->hw_ce_regs->sr_base_addr_lo, addr_lo);\n\n\tif (ce_state->ops->ce_set_src_ring_base_addr_hi) {\n\t\tce_state->ops->ce_set_src_ring_base_addr_hi(ar, ce_ctrl_addr,\n\t\t\t\t\t\t\t    addr);\n\t}\n}\n\nstatic void ath10k_ce_set_src_ring_base_addr_hi(struct ath10k *ar,\n\t\t\t\t\t\tu32 ce_ctrl_addr,\n\t\t\t\t\t\tu64 addr)\n{\n\tu32 addr_hi = upper_32_bits(addr) & CE_DESC_ADDR_HI_MASK;\n\n\tath10k_ce_write32(ar, ce_ctrl_addr +\n\t\t\t  ar->hw_ce_regs->sr_base_addr_hi, addr_hi);\n}\n\nstatic inline void ath10k_ce_src_ring_size_set(struct ath10k *ar,\n\t\t\t\t\t       u32 ce_ctrl_addr,\n\t\t\t\t\t       unsigned int n)\n{\n\tath10k_ce_write32(ar, ce_ctrl_addr +\n\t\t\t  ar->hw_ce_regs->sr_size_addr, n);\n}\n\nstatic inline void ath10k_ce_src_ring_dmax_set(struct ath10k *ar,\n\t\t\t\t\t       u32 ce_ctrl_addr,\n\t\t\t\t\t       unsigned int n)\n{\n\tstruct ath10k_hw_ce_ctrl1 *ctrl_regs = ar->hw_ce_regs->ctrl1_regs;\n\n\tu32 ctrl1_addr = ath10k_ce_read32(ar, ce_ctrl_addr +\n\t\t\t\t\t  ctrl_regs->addr);\n\n\tath10k_ce_write32(ar, ce_ctrl_addr + ctrl_regs->addr,\n\t\t\t  (ctrl1_addr &  ~(ctrl_regs->dmax->mask)) |\n\t\t\t  ath10k_set_ring_byte(n, ctrl_regs->dmax));\n}\n\nstatic inline void ath10k_ce_src_ring_byte_swap_set(struct ath10k *ar,\n\t\t\t\t\t\t    u32 ce_ctrl_addr,\n\t\t\t\t\t\t    unsigned int n)\n{\n\tstruct ath10k_hw_ce_ctrl1 *ctrl_regs = ar->hw_ce_regs->ctrl1_regs;\n\n\tu32 ctrl1_addr = ath10k_ce_read32(ar, ce_ctrl_addr +\n\t\t\t\t\t  ctrl_regs->addr);\n\n\tath10k_ce_write32(ar, ce_ctrl_addr + ctrl_regs->addr,\n\t\t\t  (ctrl1_addr & ~(ctrl_regs->src_ring->mask)) |\n\t\t\t  ath10k_set_ring_byte(n, ctrl_regs->src_ring));\n}\n\nstatic inline void ath10k_ce_dest_ring_byte_swap_set(struct ath10k *ar,\n\t\t\t\t\t\t     u32 ce_ctrl_addr,\n\t\t\t\t\t\t     unsigned int n)\n{\n\tstruct ath10k_hw_ce_ctrl1 *ctrl_regs = ar->hw_ce_regs->ctrl1_regs;\n\n\tu32 ctrl1_addr = ath10k_ce_read32(ar, ce_ctrl_addr +\n\t\t\t\t\t  ctrl_regs->addr);\n\n\tath10k_ce_write32(ar, ce_ctrl_addr + ctrl_regs->addr,\n\t\t\t  (ctrl1_addr & ~(ctrl_regs->dst_ring->mask)) |\n\t\t\t  ath10k_set_ring_byte(n, ctrl_regs->dst_ring));\n}\n\nstatic inline\n\tu32 ath10k_ce_dest_ring_read_index_from_ddr(struct ath10k *ar, u32 ce_id)\n{\n\tstruct ath10k_ce *ce = ath10k_ce_priv(ar);\n\n\treturn (ce->vaddr_rri[ce_id] >> CE_DDR_DRRI_SHIFT) &\n\t\tCE_DDR_RRI_MASK;\n}\n\nstatic inline u32 ath10k_ce_dest_ring_read_index_get(struct ath10k *ar,\n\t\t\t\t\t\t     u32 ce_ctrl_addr)\n{\n\tstruct ath10k_ce *ce = ath10k_ce_priv(ar);\n\tu32 ce_id = COPY_ENGINE_ID(ce_ctrl_addr);\n\tstruct ath10k_ce_pipe *ce_state = &ce->ce_states[ce_id];\n\tu32 index;\n\n\tif (ar->hw_params.rri_on_ddr &&\n\t    (ce_state->attr_flags & CE_ATTR_DIS_INTR))\n\t\tindex = ath10k_ce_dest_ring_read_index_from_ddr(ar, ce_id);\n\telse\n\t\tindex = ath10k_ce_read32(ar, ce_ctrl_addr +\n\t\t\t\t\t ar->hw_ce_regs->current_drri_addr);\n\n\treturn index;\n}\n\nstatic inline void ath10k_ce_dest_ring_base_addr_set(struct ath10k *ar,\n\t\t\t\t\t\t     u32 ce_id,\n\t\t\t\t\t\t     u64 addr)\n{\n\tstruct ath10k_ce *ce = ath10k_ce_priv(ar);\n\tstruct ath10k_ce_pipe *ce_state = &ce->ce_states[ce_id];\n\tu32 ce_ctrl_addr = ath10k_ce_base_address(ar, ce_id);\n\tu32 addr_lo = lower_32_bits(addr);\n\n\tath10k_ce_write32(ar, ce_ctrl_addr +\n\t\t\t  ar->hw_ce_regs->dr_base_addr_lo, addr_lo);\n\n\tif (ce_state->ops->ce_set_dest_ring_base_addr_hi) {\n\t\tce_state->ops->ce_set_dest_ring_base_addr_hi(ar, ce_ctrl_addr,\n\t\t\t\t\t\t\t     addr);\n\t}\n}\n\nstatic void ath10k_ce_set_dest_ring_base_addr_hi(struct ath10k *ar,\n\t\t\t\t\t\t u32 ce_ctrl_addr,\n\t\t\t\t\t\t u64 addr)\n{\n\tu32 addr_hi = upper_32_bits(addr) & CE_DESC_ADDR_HI_MASK;\n\tu32 reg_value;\n\n\treg_value = ath10k_ce_read32(ar, ce_ctrl_addr +\n\t\t\t\t     ar->hw_ce_regs->dr_base_addr_hi);\n\treg_value &= ~CE_DESC_ADDR_HI_MASK;\n\treg_value |= addr_hi;\n\tath10k_ce_write32(ar, ce_ctrl_addr +\n\t\t\t  ar->hw_ce_regs->dr_base_addr_hi, reg_value);\n}\n\nstatic inline void ath10k_ce_dest_ring_size_set(struct ath10k *ar,\n\t\t\t\t\t\tu32 ce_ctrl_addr,\n\t\t\t\t\t\tunsigned int n)\n{\n\tath10k_ce_write32(ar, ce_ctrl_addr +\n\t\t\t  ar->hw_ce_regs->dr_size_addr, n);\n}\n\nstatic inline void ath10k_ce_src_ring_highmark_set(struct ath10k *ar,\n\t\t\t\t\t\t   u32 ce_ctrl_addr,\n\t\t\t\t\t\t   unsigned int n)\n{\n\tstruct ath10k_hw_ce_dst_src_wm_regs *srcr_wm = ar->hw_ce_regs->wm_srcr;\n\tu32 addr = ath10k_ce_read32(ar, ce_ctrl_addr + srcr_wm->addr);\n\n\tath10k_ce_write32(ar, ce_ctrl_addr + srcr_wm->addr,\n\t\t\t  (addr & ~(srcr_wm->wm_high->mask)) |\n\t\t\t  (ath10k_set_ring_byte(n, srcr_wm->wm_high)));\n}\n\nstatic inline void ath10k_ce_src_ring_lowmark_set(struct ath10k *ar,\n\t\t\t\t\t\t  u32 ce_ctrl_addr,\n\t\t\t\t\t\t  unsigned int n)\n{\n\tstruct ath10k_hw_ce_dst_src_wm_regs *srcr_wm = ar->hw_ce_regs->wm_srcr;\n\tu32 addr = ath10k_ce_read32(ar, ce_ctrl_addr + srcr_wm->addr);\n\n\tath10k_ce_write32(ar, ce_ctrl_addr + srcr_wm->addr,\n\t\t\t  (addr & ~(srcr_wm->wm_low->mask)) |\n\t\t\t  (ath10k_set_ring_byte(n, srcr_wm->wm_low)));\n}\n\nstatic inline void ath10k_ce_dest_ring_highmark_set(struct ath10k *ar,\n\t\t\t\t\t\t    u32 ce_ctrl_addr,\n\t\t\t\t\t\t    unsigned int n)\n{\n\tstruct ath10k_hw_ce_dst_src_wm_regs *dstr_wm = ar->hw_ce_regs->wm_dstr;\n\tu32 addr = ath10k_ce_read32(ar, ce_ctrl_addr + dstr_wm->addr);\n\n\tath10k_ce_write32(ar, ce_ctrl_addr + dstr_wm->addr,\n\t\t\t  (addr & ~(dstr_wm->wm_high->mask)) |\n\t\t\t  (ath10k_set_ring_byte(n, dstr_wm->wm_high)));\n}\n\nstatic inline void ath10k_ce_dest_ring_lowmark_set(struct ath10k *ar,\n\t\t\t\t\t\t   u32 ce_ctrl_addr,\n\t\t\t\t\t\t   unsigned int n)\n{\n\tstruct ath10k_hw_ce_dst_src_wm_regs *dstr_wm = ar->hw_ce_regs->wm_dstr;\n\tu32 addr = ath10k_ce_read32(ar, ce_ctrl_addr + dstr_wm->addr);\n\n\tath10k_ce_write32(ar, ce_ctrl_addr + dstr_wm->addr,\n\t\t\t  (addr & ~(dstr_wm->wm_low->mask)) |\n\t\t\t  (ath10k_set_ring_byte(n, dstr_wm->wm_low)));\n}\n\nstatic inline void ath10k_ce_copy_complete_inter_enable(struct ath10k *ar,\n\t\t\t\t\t\t\tu32 ce_ctrl_addr)\n{\n\tstruct ath10k_hw_ce_host_ie *host_ie = ar->hw_ce_regs->host_ie;\n\n\tu32 host_ie_addr = ath10k_ce_read32(ar, ce_ctrl_addr +\n\t\t\t\t\t    ar->hw_ce_regs->host_ie_addr);\n\n\tath10k_ce_write32(ar, ce_ctrl_addr + ar->hw_ce_regs->host_ie_addr,\n\t\t\t  host_ie_addr | host_ie->copy_complete->mask);\n}\n\nstatic inline void ath10k_ce_copy_complete_intr_disable(struct ath10k *ar,\n\t\t\t\t\t\t\tu32 ce_ctrl_addr)\n{\n\tstruct ath10k_hw_ce_host_ie *host_ie = ar->hw_ce_regs->host_ie;\n\n\tu32 host_ie_addr = ath10k_ce_read32(ar, ce_ctrl_addr +\n\t\t\t\t\t    ar->hw_ce_regs->host_ie_addr);\n\n\tath10k_ce_write32(ar, ce_ctrl_addr + ar->hw_ce_regs->host_ie_addr,\n\t\t\t  host_ie_addr & ~(host_ie->copy_complete->mask));\n}\n\nstatic inline void ath10k_ce_watermark_intr_disable(struct ath10k *ar,\n\t\t\t\t\t\t    u32 ce_ctrl_addr)\n{\n\tstruct ath10k_hw_ce_host_wm_regs *wm_regs = ar->hw_ce_regs->wm_regs;\n\n\tu32 host_ie_addr = ath10k_ce_read32(ar, ce_ctrl_addr +\n\t\t\t\t\t    ar->hw_ce_regs->host_ie_addr);\n\n\tath10k_ce_write32(ar, ce_ctrl_addr + ar->hw_ce_regs->host_ie_addr,\n\t\t\t  host_ie_addr & ~(wm_regs->wm_mask));\n}\n\nstatic inline void ath10k_ce_error_intr_disable(struct ath10k *ar,\n\t\t\t\t\t\tu32 ce_ctrl_addr)\n{\n\tstruct ath10k_hw_ce_misc_regs *misc_regs = ar->hw_ce_regs->misc_regs;\n\n\tu32 misc_ie_addr = ath10k_ce_read32(ar,\n\t\t\tce_ctrl_addr + ar->hw_ce_regs->misc_ie_addr);\n\n\tath10k_ce_write32(ar,\n\t\t\t  ce_ctrl_addr + ar->hw_ce_regs->misc_ie_addr,\n\t\t\t  misc_ie_addr & ~(misc_regs->err_mask));\n}\n\nstatic inline void ath10k_ce_engine_int_status_clear(struct ath10k *ar,\n\t\t\t\t\t\t     u32 ce_ctrl_addr,\n\t\t\t\t\t\t     unsigned int mask)\n{\n\tstruct ath10k_hw_ce_host_wm_regs *wm_regs = ar->hw_ce_regs->wm_regs;\n\n\tath10k_ce_write32(ar, ce_ctrl_addr + wm_regs->addr, mask);\n}\n\n \nstatic int _ath10k_ce_send_nolock(struct ath10k_ce_pipe *ce_state,\n\t\t\t\t  void *per_transfer_context,\n\t\t\t\t  dma_addr_t buffer,\n\t\t\t\t  unsigned int nbytes,\n\t\t\t\t  unsigned int transfer_id,\n\t\t\t\t  unsigned int flags)\n{\n\tstruct ath10k *ar = ce_state->ar;\n\tstruct ath10k_ce_ring *src_ring = ce_state->src_ring;\n\tstruct ce_desc *desc, sdesc;\n\tunsigned int nentries_mask = src_ring->nentries_mask;\n\tunsigned int sw_index = src_ring->sw_index;\n\tunsigned int write_index = src_ring->write_index;\n\tu32 ctrl_addr = ce_state->ctrl_addr;\n\tu32 desc_flags = 0;\n\tint ret = 0;\n\n\tif (nbytes > ce_state->src_sz_max)\n\t\tath10k_warn(ar, \"%s: send more we can (nbytes: %d, max: %d)\\n\",\n\t\t\t    __func__, nbytes, ce_state->src_sz_max);\n\n\tif (unlikely(CE_RING_DELTA(nentries_mask,\n\t\t\t\t   write_index, sw_index - 1) <= 0)) {\n\t\tret = -ENOSR;\n\t\tgoto exit;\n\t}\n\n\tdesc = CE_SRC_RING_TO_DESC(src_ring->base_addr_owner_space,\n\t\t\t\t   write_index);\n\n\tdesc_flags |= SM(transfer_id, CE_DESC_FLAGS_META_DATA);\n\n\tif (flags & CE_SEND_FLAG_GATHER)\n\t\tdesc_flags |= CE_DESC_FLAGS_GATHER;\n\tif (flags & CE_SEND_FLAG_BYTE_SWAP)\n\t\tdesc_flags |= CE_DESC_FLAGS_BYTE_SWAP;\n\n\tsdesc.addr   = __cpu_to_le32(buffer);\n\tsdesc.nbytes = __cpu_to_le16(nbytes);\n\tsdesc.flags  = __cpu_to_le16(desc_flags);\n\n\t*desc = sdesc;\n\n\tsrc_ring->per_transfer_context[write_index] = per_transfer_context;\n\n\t \n\twrite_index = CE_RING_IDX_INCR(nentries_mask, write_index);\n\n\t \n\tif (!(flags & CE_SEND_FLAG_GATHER))\n\t\tath10k_ce_src_ring_write_index_set(ar, ctrl_addr, write_index);\n\n\tsrc_ring->write_index = write_index;\nexit:\n\treturn ret;\n}\n\nstatic int _ath10k_ce_send_nolock_64(struct ath10k_ce_pipe *ce_state,\n\t\t\t\t     void *per_transfer_context,\n\t\t\t\t     dma_addr_t buffer,\n\t\t\t\t     unsigned int nbytes,\n\t\t\t\t     unsigned int transfer_id,\n\t\t\t\t     unsigned int flags)\n{\n\tstruct ath10k *ar = ce_state->ar;\n\tstruct ath10k_ce_ring *src_ring = ce_state->src_ring;\n\tstruct ce_desc_64 *desc, sdesc;\n\tunsigned int nentries_mask = src_ring->nentries_mask;\n\tunsigned int sw_index;\n\tunsigned int write_index = src_ring->write_index;\n\tu32 ctrl_addr = ce_state->ctrl_addr;\n\t__le32 *addr;\n\tu32 desc_flags = 0;\n\tint ret = 0;\n\n\tif (test_bit(ATH10K_FLAG_CRASH_FLUSH, &ar->dev_flags))\n\t\treturn -ESHUTDOWN;\n\n\tif (nbytes > ce_state->src_sz_max)\n\t\tath10k_warn(ar, \"%s: send more we can (nbytes: %d, max: %d)\\n\",\n\t\t\t    __func__, nbytes, ce_state->src_sz_max);\n\n\tif (ar->hw_params.rri_on_ddr)\n\t\tsw_index = ath10k_ce_src_ring_read_index_from_ddr(ar, ce_state->id);\n\telse\n\t\tsw_index = src_ring->sw_index;\n\n\tif (unlikely(CE_RING_DELTA(nentries_mask,\n\t\t\t\t   write_index, sw_index - 1) <= 0)) {\n\t\tret = -ENOSR;\n\t\tgoto exit;\n\t}\n\n\tdesc = CE_SRC_RING_TO_DESC_64(src_ring->base_addr_owner_space,\n\t\t\t\t      write_index);\n\n\tdesc_flags |= SM(transfer_id, CE_DESC_FLAGS_META_DATA);\n\n\tif (flags & CE_SEND_FLAG_GATHER)\n\t\tdesc_flags |= CE_DESC_FLAGS_GATHER;\n\n\tif (flags & CE_SEND_FLAG_BYTE_SWAP)\n\t\tdesc_flags |= CE_DESC_FLAGS_BYTE_SWAP;\n\n\taddr = (__le32 *)&sdesc.addr;\n\n\tflags |= upper_32_bits(buffer) & CE_DESC_ADDR_HI_MASK;\n\taddr[0] = __cpu_to_le32(buffer);\n\taddr[1] = __cpu_to_le32(flags);\n\tif (flags & CE_SEND_FLAG_GATHER)\n\t\taddr[1] |= __cpu_to_le32(CE_WCN3990_DESC_FLAGS_GATHER);\n\telse\n\t\taddr[1] &= ~(__cpu_to_le32(CE_WCN3990_DESC_FLAGS_GATHER));\n\n\tsdesc.nbytes = __cpu_to_le16(nbytes);\n\tsdesc.flags  = __cpu_to_le16(desc_flags);\n\n\t*desc = sdesc;\n\n\tsrc_ring->per_transfer_context[write_index] = per_transfer_context;\n\n\t \n\twrite_index = CE_RING_IDX_INCR(nentries_mask, write_index);\n\n\tif (!(flags & CE_SEND_FLAG_GATHER)) {\n\t\tif (ar->hw_params.shadow_reg_support)\n\t\t\tath10k_ce_shadow_src_ring_write_index_set(ar, ce_state,\n\t\t\t\t\t\t\t\t  write_index);\n\t\telse\n\t\t\tath10k_ce_src_ring_write_index_set(ar, ctrl_addr,\n\t\t\t\t\t\t\t   write_index);\n\t}\n\n\tsrc_ring->write_index = write_index;\nexit:\n\treturn ret;\n}\n\nint ath10k_ce_send_nolock(struct ath10k_ce_pipe *ce_state,\n\t\t\t  void *per_transfer_context,\n\t\t\t  dma_addr_t buffer,\n\t\t\t  unsigned int nbytes,\n\t\t\t  unsigned int transfer_id,\n\t\t\t  unsigned int flags)\n{\n\treturn ce_state->ops->ce_send_nolock(ce_state, per_transfer_context,\n\t\t\t\t    buffer, nbytes, transfer_id, flags);\n}\nEXPORT_SYMBOL(ath10k_ce_send_nolock);\n\nvoid __ath10k_ce_send_revert(struct ath10k_ce_pipe *pipe)\n{\n\tstruct ath10k *ar = pipe->ar;\n\tstruct ath10k_ce *ce = ath10k_ce_priv(ar);\n\tstruct ath10k_ce_ring *src_ring = pipe->src_ring;\n\tu32 ctrl_addr = pipe->ctrl_addr;\n\n\tlockdep_assert_held(&ce->ce_lock);\n\n\t \n\tif (WARN_ON_ONCE(src_ring->write_index == src_ring->sw_index))\n\t\treturn;\n\n\tif (WARN_ON_ONCE(src_ring->write_index ==\n\t\t\t ath10k_ce_src_ring_write_index_get(ar, ctrl_addr)))\n\t\treturn;\n\n\tsrc_ring->write_index--;\n\tsrc_ring->write_index &= src_ring->nentries_mask;\n\n\tsrc_ring->per_transfer_context[src_ring->write_index] = NULL;\n}\nEXPORT_SYMBOL(__ath10k_ce_send_revert);\n\nint ath10k_ce_send(struct ath10k_ce_pipe *ce_state,\n\t\t   void *per_transfer_context,\n\t\t   dma_addr_t buffer,\n\t\t   unsigned int nbytes,\n\t\t   unsigned int transfer_id,\n\t\t   unsigned int flags)\n{\n\tstruct ath10k *ar = ce_state->ar;\n\tstruct ath10k_ce *ce = ath10k_ce_priv(ar);\n\tint ret;\n\n\tspin_lock_bh(&ce->ce_lock);\n\tret = ath10k_ce_send_nolock(ce_state, per_transfer_context,\n\t\t\t\t    buffer, nbytes, transfer_id, flags);\n\tspin_unlock_bh(&ce->ce_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(ath10k_ce_send);\n\nint ath10k_ce_num_free_src_entries(struct ath10k_ce_pipe *pipe)\n{\n\tstruct ath10k *ar = pipe->ar;\n\tstruct ath10k_ce *ce = ath10k_ce_priv(ar);\n\tint delta;\n\n\tspin_lock_bh(&ce->ce_lock);\n\tdelta = CE_RING_DELTA(pipe->src_ring->nentries_mask,\n\t\t\t      pipe->src_ring->write_index,\n\t\t\t      pipe->src_ring->sw_index - 1);\n\tspin_unlock_bh(&ce->ce_lock);\n\n\treturn delta;\n}\nEXPORT_SYMBOL(ath10k_ce_num_free_src_entries);\n\nint __ath10k_ce_rx_num_free_bufs(struct ath10k_ce_pipe *pipe)\n{\n\tstruct ath10k *ar = pipe->ar;\n\tstruct ath10k_ce *ce = ath10k_ce_priv(ar);\n\tstruct ath10k_ce_ring *dest_ring = pipe->dest_ring;\n\tunsigned int nentries_mask = dest_ring->nentries_mask;\n\tunsigned int write_index = dest_ring->write_index;\n\tunsigned int sw_index = dest_ring->sw_index;\n\n\tlockdep_assert_held(&ce->ce_lock);\n\n\treturn CE_RING_DELTA(nentries_mask, write_index, sw_index - 1);\n}\nEXPORT_SYMBOL(__ath10k_ce_rx_num_free_bufs);\n\nstatic int __ath10k_ce_rx_post_buf(struct ath10k_ce_pipe *pipe, void *ctx,\n\t\t\t\t   dma_addr_t paddr)\n{\n\tstruct ath10k *ar = pipe->ar;\n\tstruct ath10k_ce *ce = ath10k_ce_priv(ar);\n\tstruct ath10k_ce_ring *dest_ring = pipe->dest_ring;\n\tunsigned int nentries_mask = dest_ring->nentries_mask;\n\tunsigned int write_index = dest_ring->write_index;\n\tunsigned int sw_index = dest_ring->sw_index;\n\tstruct ce_desc *base = dest_ring->base_addr_owner_space;\n\tstruct ce_desc *desc = CE_DEST_RING_TO_DESC(base, write_index);\n\tu32 ctrl_addr = pipe->ctrl_addr;\n\n\tlockdep_assert_held(&ce->ce_lock);\n\n\tif ((pipe->id != 5) &&\n\t    CE_RING_DELTA(nentries_mask, write_index, sw_index - 1) == 0)\n\t\treturn -ENOSPC;\n\n\tdesc->addr = __cpu_to_le32(paddr);\n\tdesc->nbytes = 0;\n\n\tdest_ring->per_transfer_context[write_index] = ctx;\n\twrite_index = CE_RING_IDX_INCR(nentries_mask, write_index);\n\tath10k_ce_dest_ring_write_index_set(ar, ctrl_addr, write_index);\n\tdest_ring->write_index = write_index;\n\n\treturn 0;\n}\n\nstatic int __ath10k_ce_rx_post_buf_64(struct ath10k_ce_pipe *pipe,\n\t\t\t\t      void *ctx,\n\t\t\t\t      dma_addr_t paddr)\n{\n\tstruct ath10k *ar = pipe->ar;\n\tstruct ath10k_ce *ce = ath10k_ce_priv(ar);\n\tstruct ath10k_ce_ring *dest_ring = pipe->dest_ring;\n\tunsigned int nentries_mask = dest_ring->nentries_mask;\n\tunsigned int write_index = dest_ring->write_index;\n\tunsigned int sw_index = dest_ring->sw_index;\n\tstruct ce_desc_64 *base = dest_ring->base_addr_owner_space;\n\tstruct ce_desc_64 *desc =\n\t\t\tCE_DEST_RING_TO_DESC_64(base, write_index);\n\tu32 ctrl_addr = pipe->ctrl_addr;\n\n\tlockdep_assert_held(&ce->ce_lock);\n\n\tif (CE_RING_DELTA(nentries_mask, write_index, sw_index - 1) == 0)\n\t\treturn -ENOSPC;\n\n\tdesc->addr = __cpu_to_le64(paddr);\n\tdesc->addr &= __cpu_to_le64(CE_DESC_ADDR_MASK);\n\n\tdesc->nbytes = 0;\n\n\tdest_ring->per_transfer_context[write_index] = ctx;\n\twrite_index = CE_RING_IDX_INCR(nentries_mask, write_index);\n\tath10k_ce_dest_ring_write_index_set(ar, ctrl_addr, write_index);\n\tdest_ring->write_index = write_index;\n\n\treturn 0;\n}\n\nvoid ath10k_ce_rx_update_write_idx(struct ath10k_ce_pipe *pipe, u32 nentries)\n{\n\tstruct ath10k *ar = pipe->ar;\n\tstruct ath10k_ce_ring *dest_ring = pipe->dest_ring;\n\tunsigned int nentries_mask = dest_ring->nentries_mask;\n\tunsigned int write_index = dest_ring->write_index;\n\tu32 ctrl_addr = pipe->ctrl_addr;\n\tu32 cur_write_idx = ath10k_ce_dest_ring_write_index_get(ar, ctrl_addr);\n\n\t \n\tif (((cur_write_idx + nentries) & nentries_mask) == dest_ring->sw_index)\n\t\tnentries -= 1;\n\n\twrite_index = CE_RING_IDX_ADD(nentries_mask, write_index, nentries);\n\tath10k_ce_dest_ring_write_index_set(ar, ctrl_addr, write_index);\n\tdest_ring->write_index = write_index;\n}\nEXPORT_SYMBOL(ath10k_ce_rx_update_write_idx);\n\nint ath10k_ce_rx_post_buf(struct ath10k_ce_pipe *pipe, void *ctx,\n\t\t\t  dma_addr_t paddr)\n{\n\tstruct ath10k *ar = pipe->ar;\n\tstruct ath10k_ce *ce = ath10k_ce_priv(ar);\n\tint ret;\n\n\tspin_lock_bh(&ce->ce_lock);\n\tret = pipe->ops->ce_rx_post_buf(pipe, ctx, paddr);\n\tspin_unlock_bh(&ce->ce_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(ath10k_ce_rx_post_buf);\n\n \nstatic int\n\t _ath10k_ce_completed_recv_next_nolock(struct ath10k_ce_pipe *ce_state,\n\t\t\t\t\t       void **per_transfer_contextp,\n\t\t\t\t\t       unsigned int *nbytesp)\n{\n\tstruct ath10k_ce_ring *dest_ring = ce_state->dest_ring;\n\tunsigned int nentries_mask = dest_ring->nentries_mask;\n\tunsigned int sw_index = dest_ring->sw_index;\n\n\tstruct ce_desc *base = dest_ring->base_addr_owner_space;\n\tstruct ce_desc *desc = CE_DEST_RING_TO_DESC(base, sw_index);\n\tstruct ce_desc sdesc;\n\tu16 nbytes;\n\n\t \n\tsdesc = *desc;\n\n\tnbytes = __le16_to_cpu(sdesc.nbytes);\n\tif (nbytes == 0) {\n\t\t \n\t\treturn -EIO;\n\t}\n\n\tdesc->nbytes = 0;\n\n\t \n\t*nbytesp = nbytes;\n\n\tif (per_transfer_contextp)\n\t\t*per_transfer_contextp =\n\t\t\tdest_ring->per_transfer_context[sw_index];\n\n\t \n\tif (ce_state->id != 5)\n\t\tdest_ring->per_transfer_context[sw_index] = NULL;\n\n\t \n\tsw_index = CE_RING_IDX_INCR(nentries_mask, sw_index);\n\tdest_ring->sw_index = sw_index;\n\n\treturn 0;\n}\n\nstatic int\n_ath10k_ce_completed_recv_next_nolock_64(struct ath10k_ce_pipe *ce_state,\n\t\t\t\t\t void **per_transfer_contextp,\n\t\t\t\t\t unsigned int *nbytesp)\n{\n\tstruct ath10k_ce_ring *dest_ring = ce_state->dest_ring;\n\tunsigned int nentries_mask = dest_ring->nentries_mask;\n\tunsigned int sw_index = dest_ring->sw_index;\n\tstruct ce_desc_64 *base = dest_ring->base_addr_owner_space;\n\tstruct ce_desc_64 *desc =\n\t\tCE_DEST_RING_TO_DESC_64(base, sw_index);\n\tstruct ce_desc_64 sdesc;\n\tu16 nbytes;\n\n\t \n\tsdesc = *desc;\n\n\tnbytes = __le16_to_cpu(sdesc.nbytes);\n\tif (nbytes == 0) {\n\t\t \n\t\treturn -EIO;\n\t}\n\n\tdesc->nbytes = 0;\n\n\t \n\t*nbytesp = nbytes;\n\n\tif (per_transfer_contextp)\n\t\t*per_transfer_contextp =\n\t\t\tdest_ring->per_transfer_context[sw_index];\n\n\t \n\tif (ce_state->id != 5)\n\t\tdest_ring->per_transfer_context[sw_index] = NULL;\n\n\t \n\tsw_index = CE_RING_IDX_INCR(nentries_mask, sw_index);\n\tdest_ring->sw_index = sw_index;\n\n\treturn 0;\n}\n\nint ath10k_ce_completed_recv_next_nolock(struct ath10k_ce_pipe *ce_state,\n\t\t\t\t\t void **per_transfer_ctx,\n\t\t\t\t\t unsigned int *nbytesp)\n{\n\treturn ce_state->ops->ce_completed_recv_next_nolock(ce_state,\n\t\t\t\t\t\t\t    per_transfer_ctx,\n\t\t\t\t\t\t\t    nbytesp);\n}\nEXPORT_SYMBOL(ath10k_ce_completed_recv_next_nolock);\n\nint ath10k_ce_completed_recv_next(struct ath10k_ce_pipe *ce_state,\n\t\t\t\t  void **per_transfer_contextp,\n\t\t\t\t  unsigned int *nbytesp)\n{\n\tstruct ath10k *ar = ce_state->ar;\n\tstruct ath10k_ce *ce = ath10k_ce_priv(ar);\n\tint ret;\n\n\tspin_lock_bh(&ce->ce_lock);\n\tret = ce_state->ops->ce_completed_recv_next_nolock(ce_state,\n\t\t\t\t\t\t   per_transfer_contextp,\n\t\t\t\t\t\t   nbytesp);\n\n\tspin_unlock_bh(&ce->ce_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(ath10k_ce_completed_recv_next);\n\nstatic int _ath10k_ce_revoke_recv_next(struct ath10k_ce_pipe *ce_state,\n\t\t\t\t       void **per_transfer_contextp,\n\t\t\t\t       dma_addr_t *bufferp)\n{\n\tstruct ath10k_ce_ring *dest_ring;\n\tunsigned int nentries_mask;\n\tunsigned int sw_index;\n\tunsigned int write_index;\n\tint ret;\n\tstruct ath10k *ar;\n\tstruct ath10k_ce *ce;\n\n\tdest_ring = ce_state->dest_ring;\n\n\tif (!dest_ring)\n\t\treturn -EIO;\n\n\tar = ce_state->ar;\n\tce = ath10k_ce_priv(ar);\n\n\tspin_lock_bh(&ce->ce_lock);\n\n\tnentries_mask = dest_ring->nentries_mask;\n\tsw_index = dest_ring->sw_index;\n\twrite_index = dest_ring->write_index;\n\tif (write_index != sw_index) {\n\t\tstruct ce_desc *base = dest_ring->base_addr_owner_space;\n\t\tstruct ce_desc *desc = CE_DEST_RING_TO_DESC(base, sw_index);\n\n\t\t \n\t\t*bufferp = __le32_to_cpu(desc->addr);\n\n\t\tif (per_transfer_contextp)\n\t\t\t*per_transfer_contextp =\n\t\t\t\tdest_ring->per_transfer_context[sw_index];\n\n\t\t \n\t\tdest_ring->per_transfer_context[sw_index] = NULL;\n\t\tdesc->nbytes = 0;\n\n\t\t \n\t\tsw_index = CE_RING_IDX_INCR(nentries_mask, sw_index);\n\t\tdest_ring->sw_index = sw_index;\n\t\tret = 0;\n\t} else {\n\t\tret = -EIO;\n\t}\n\n\tspin_unlock_bh(&ce->ce_lock);\n\n\treturn ret;\n}\n\nstatic int _ath10k_ce_revoke_recv_next_64(struct ath10k_ce_pipe *ce_state,\n\t\t\t\t\t  void **per_transfer_contextp,\n\t\t\t\t\t  dma_addr_t *bufferp)\n{\n\tstruct ath10k_ce_ring *dest_ring;\n\tunsigned int nentries_mask;\n\tunsigned int sw_index;\n\tunsigned int write_index;\n\tint ret;\n\tstruct ath10k *ar;\n\tstruct ath10k_ce *ce;\n\n\tdest_ring = ce_state->dest_ring;\n\n\tif (!dest_ring)\n\t\treturn -EIO;\n\n\tar = ce_state->ar;\n\tce = ath10k_ce_priv(ar);\n\n\tspin_lock_bh(&ce->ce_lock);\n\n\tnentries_mask = dest_ring->nentries_mask;\n\tsw_index = dest_ring->sw_index;\n\twrite_index = dest_ring->write_index;\n\tif (write_index != sw_index) {\n\t\tstruct ce_desc_64 *base = dest_ring->base_addr_owner_space;\n\t\tstruct ce_desc_64 *desc =\n\t\t\tCE_DEST_RING_TO_DESC_64(base, sw_index);\n\n\t\t \n\t\t*bufferp = __le64_to_cpu(desc->addr);\n\n\t\tif (per_transfer_contextp)\n\t\t\t*per_transfer_contextp =\n\t\t\t\tdest_ring->per_transfer_context[sw_index];\n\n\t\t \n\t\tdest_ring->per_transfer_context[sw_index] = NULL;\n\t\tdesc->nbytes = 0;\n\n\t\t \n\t\tsw_index = CE_RING_IDX_INCR(nentries_mask, sw_index);\n\t\tdest_ring->sw_index = sw_index;\n\t\tret = 0;\n\t} else {\n\t\tret = -EIO;\n\t}\n\n\tspin_unlock_bh(&ce->ce_lock);\n\n\treturn ret;\n}\n\nint ath10k_ce_revoke_recv_next(struct ath10k_ce_pipe *ce_state,\n\t\t\t       void **per_transfer_contextp,\n\t\t\t       dma_addr_t *bufferp)\n{\n\treturn ce_state->ops->ce_revoke_recv_next(ce_state,\n\t\t\t\t\t\t  per_transfer_contextp,\n\t\t\t\t\t\t  bufferp);\n}\nEXPORT_SYMBOL(ath10k_ce_revoke_recv_next);\n\n \nstatic int _ath10k_ce_completed_send_next_nolock(struct ath10k_ce_pipe *ce_state,\n\t\t\t\t\t\t void **per_transfer_contextp)\n{\n\tstruct ath10k_ce_ring *src_ring = ce_state->src_ring;\n\tu32 ctrl_addr = ce_state->ctrl_addr;\n\tstruct ath10k *ar = ce_state->ar;\n\tunsigned int nentries_mask = src_ring->nentries_mask;\n\tunsigned int sw_index = src_ring->sw_index;\n\tunsigned int read_index;\n\tstruct ce_desc *desc;\n\n\tif (src_ring->hw_index == sw_index) {\n\t\t \n\n\t\tread_index = ath10k_ce_src_ring_read_index_get(ar, ctrl_addr);\n\t\tif (read_index == 0xffffffff)\n\t\t\treturn -ENODEV;\n\n\t\tread_index &= nentries_mask;\n\t\tsrc_ring->hw_index = read_index;\n\t}\n\n\tif (ar->hw_params.rri_on_ddr)\n\t\tread_index = ath10k_ce_src_ring_read_index_get(ar, ctrl_addr);\n\telse\n\t\tread_index = src_ring->hw_index;\n\n\tif (read_index == sw_index)\n\t\treturn -EIO;\n\n\tif (per_transfer_contextp)\n\t\t*per_transfer_contextp =\n\t\t\tsrc_ring->per_transfer_context[sw_index];\n\n\t \n\tsrc_ring->per_transfer_context[sw_index] = NULL;\n\tdesc = CE_SRC_RING_TO_DESC(src_ring->base_addr_owner_space,\n\t\t\t\t   sw_index);\n\tdesc->nbytes = 0;\n\n\t \n\tsw_index = CE_RING_IDX_INCR(nentries_mask, sw_index);\n\tsrc_ring->sw_index = sw_index;\n\n\treturn 0;\n}\n\nstatic int _ath10k_ce_completed_send_next_nolock_64(struct ath10k_ce_pipe *ce_state,\n\t\t\t\t\t\t    void **per_transfer_contextp)\n{\n\tstruct ath10k_ce_ring *src_ring = ce_state->src_ring;\n\tu32 ctrl_addr = ce_state->ctrl_addr;\n\tstruct ath10k *ar = ce_state->ar;\n\tunsigned int nentries_mask = src_ring->nentries_mask;\n\tunsigned int sw_index = src_ring->sw_index;\n\tunsigned int read_index;\n\tstruct ce_desc_64 *desc;\n\n\tif (src_ring->hw_index == sw_index) {\n\t\t \n\n\t\tread_index = ath10k_ce_src_ring_read_index_get(ar, ctrl_addr);\n\t\tif (read_index == 0xffffffff)\n\t\t\treturn -ENODEV;\n\n\t\tread_index &= nentries_mask;\n\t\tsrc_ring->hw_index = read_index;\n\t}\n\n\tif (ar->hw_params.rri_on_ddr)\n\t\tread_index = ath10k_ce_src_ring_read_index_get(ar, ctrl_addr);\n\telse\n\t\tread_index = src_ring->hw_index;\n\n\tif (read_index == sw_index)\n\t\treturn -EIO;\n\n\tif (per_transfer_contextp)\n\t\t*per_transfer_contextp =\n\t\t\tsrc_ring->per_transfer_context[sw_index];\n\n\t \n\tsrc_ring->per_transfer_context[sw_index] = NULL;\n\tdesc = CE_SRC_RING_TO_DESC_64(src_ring->base_addr_owner_space,\n\t\t\t\t      sw_index);\n\tdesc->nbytes = 0;\n\n\t \n\tsw_index = CE_RING_IDX_INCR(nentries_mask, sw_index);\n\tsrc_ring->sw_index = sw_index;\n\n\treturn 0;\n}\n\nint ath10k_ce_completed_send_next_nolock(struct ath10k_ce_pipe *ce_state,\n\t\t\t\t\t void **per_transfer_contextp)\n{\n\treturn ce_state->ops->ce_completed_send_next_nolock(ce_state,\n\t\t\t\t\t\t\t    per_transfer_contextp);\n}\nEXPORT_SYMBOL(ath10k_ce_completed_send_next_nolock);\n\nstatic void ath10k_ce_extract_desc_data(struct ath10k *ar,\n\t\t\t\t\tstruct ath10k_ce_ring *src_ring,\n\t\t\t\t\tu32 sw_index,\n\t\t\t\t\tdma_addr_t *bufferp,\n\t\t\t\t\tu32 *nbytesp,\n\t\t\t\t\tu32 *transfer_idp)\n{\n\t\tstruct ce_desc *base = src_ring->base_addr_owner_space;\n\t\tstruct ce_desc *desc = CE_SRC_RING_TO_DESC(base, sw_index);\n\n\t\t \n\t\t*bufferp = __le32_to_cpu(desc->addr);\n\t\t*nbytesp = __le16_to_cpu(desc->nbytes);\n\t\t*transfer_idp = MS(__le16_to_cpu(desc->flags),\n\t\t\t\t   CE_DESC_FLAGS_META_DATA);\n}\n\nstatic void ath10k_ce_extract_desc_data_64(struct ath10k *ar,\n\t\t\t\t\t   struct ath10k_ce_ring *src_ring,\n\t\t\t\t\t   u32 sw_index,\n\t\t\t\t\t   dma_addr_t *bufferp,\n\t\t\t\t\t   u32 *nbytesp,\n\t\t\t\t\t   u32 *transfer_idp)\n{\n\t\tstruct ce_desc_64 *base = src_ring->base_addr_owner_space;\n\t\tstruct ce_desc_64 *desc =\n\t\t\tCE_SRC_RING_TO_DESC_64(base, sw_index);\n\n\t\t \n\t\t*bufferp = __le64_to_cpu(desc->addr);\n\t\t*nbytesp = __le16_to_cpu(desc->nbytes);\n\t\t*transfer_idp = MS(__le16_to_cpu(desc->flags),\n\t\t\t\t   CE_DESC_FLAGS_META_DATA);\n}\n\n \nint ath10k_ce_cancel_send_next(struct ath10k_ce_pipe *ce_state,\n\t\t\t       void **per_transfer_contextp,\n\t\t\t       dma_addr_t *bufferp,\n\t\t\t       unsigned int *nbytesp,\n\t\t\t       unsigned int *transfer_idp)\n{\n\tstruct ath10k_ce_ring *src_ring;\n\tunsigned int nentries_mask;\n\tunsigned int sw_index;\n\tunsigned int write_index;\n\tint ret;\n\tstruct ath10k *ar;\n\tstruct ath10k_ce *ce;\n\n\tsrc_ring = ce_state->src_ring;\n\n\tif (!src_ring)\n\t\treturn -EIO;\n\n\tar = ce_state->ar;\n\tce = ath10k_ce_priv(ar);\n\n\tspin_lock_bh(&ce->ce_lock);\n\n\tnentries_mask = src_ring->nentries_mask;\n\tsw_index = src_ring->sw_index;\n\twrite_index = src_ring->write_index;\n\n\tif (write_index != sw_index) {\n\t\tce_state->ops->ce_extract_desc_data(ar, src_ring, sw_index,\n\t\t\t\t\t\t    bufferp, nbytesp,\n\t\t\t\t\t\t    transfer_idp);\n\n\t\tif (per_transfer_contextp)\n\t\t\t*per_transfer_contextp =\n\t\t\t\tsrc_ring->per_transfer_context[sw_index];\n\n\t\t \n\t\tsrc_ring->per_transfer_context[sw_index] = NULL;\n\n\t\t \n\t\tsw_index = CE_RING_IDX_INCR(nentries_mask, sw_index);\n\t\tsrc_ring->sw_index = sw_index;\n\t\tret = 0;\n\t} else {\n\t\tret = -EIO;\n\t}\n\n\tspin_unlock_bh(&ce->ce_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(ath10k_ce_cancel_send_next);\n\nint ath10k_ce_completed_send_next(struct ath10k_ce_pipe *ce_state,\n\t\t\t\t  void **per_transfer_contextp)\n{\n\tstruct ath10k *ar = ce_state->ar;\n\tstruct ath10k_ce *ce = ath10k_ce_priv(ar);\n\tint ret;\n\n\tspin_lock_bh(&ce->ce_lock);\n\tret = ath10k_ce_completed_send_next_nolock(ce_state,\n\t\t\t\t\t\t   per_transfer_contextp);\n\tspin_unlock_bh(&ce->ce_lock);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(ath10k_ce_completed_send_next);\n\n \nvoid ath10k_ce_per_engine_service(struct ath10k *ar, unsigned int ce_id)\n{\n\tstruct ath10k_ce *ce = ath10k_ce_priv(ar);\n\tstruct ath10k_ce_pipe *ce_state = &ce->ce_states[ce_id];\n\tstruct ath10k_hw_ce_host_wm_regs *wm_regs = ar->hw_ce_regs->wm_regs;\n\tu32 ctrl_addr = ce_state->ctrl_addr;\n\n\t \n\tath10k_ce_engine_int_status_clear(ar, ctrl_addr,\n\t\t\t\t\t  wm_regs->cc_mask | wm_regs->wm_mask);\n\n\tif (ce_state->recv_cb)\n\t\tce_state->recv_cb(ce_state);\n\n\tif (ce_state->send_cb)\n\t\tce_state->send_cb(ce_state);\n}\nEXPORT_SYMBOL(ath10k_ce_per_engine_service);\n\n \n\nvoid ath10k_ce_per_engine_service_any(struct ath10k *ar)\n{\n\tint ce_id;\n\tu32 intr_summary;\n\n\tintr_summary = ath10k_ce_interrupt_summary(ar);\n\n\tfor (ce_id = 0; intr_summary && (ce_id < CE_COUNT); ce_id++) {\n\t\tif (intr_summary & (1 << ce_id))\n\t\t\tintr_summary &= ~(1 << ce_id);\n\t\telse\n\t\t\t \n\t\t\tcontinue;\n\n\t\tath10k_ce_per_engine_service(ar, ce_id);\n\t}\n}\nEXPORT_SYMBOL(ath10k_ce_per_engine_service_any);\n\n \nstatic void ath10k_ce_per_engine_handler_adjust(struct ath10k_ce_pipe *ce_state)\n{\n\tu32 ctrl_addr = ce_state->ctrl_addr;\n\tstruct ath10k *ar = ce_state->ar;\n\tbool disable_copy_compl_intr = ce_state->attr_flags & CE_ATTR_DIS_INTR;\n\n\tif ((!disable_copy_compl_intr) &&\n\t    (ce_state->send_cb || ce_state->recv_cb))\n\t\tath10k_ce_copy_complete_inter_enable(ar, ctrl_addr);\n\telse\n\t\tath10k_ce_copy_complete_intr_disable(ar, ctrl_addr);\n\n\tath10k_ce_watermark_intr_disable(ar, ctrl_addr);\n}\n\nvoid ath10k_ce_disable_interrupt(struct ath10k *ar, int ce_id)\n{\n\tstruct ath10k_ce *ce = ath10k_ce_priv(ar);\n\tstruct ath10k_ce_pipe *ce_state;\n\tu32 ctrl_addr;\n\n\tce_state  = &ce->ce_states[ce_id];\n\tif (ce_state->attr_flags & CE_ATTR_POLL)\n\t\treturn;\n\n\tctrl_addr = ath10k_ce_base_address(ar, ce_id);\n\n\tath10k_ce_copy_complete_intr_disable(ar, ctrl_addr);\n\tath10k_ce_error_intr_disable(ar, ctrl_addr);\n\tath10k_ce_watermark_intr_disable(ar, ctrl_addr);\n}\nEXPORT_SYMBOL(ath10k_ce_disable_interrupt);\n\nvoid ath10k_ce_disable_interrupts(struct ath10k *ar)\n{\n\tint ce_id;\n\n\tfor (ce_id = 0; ce_id < CE_COUNT; ce_id++)\n\t\tath10k_ce_disable_interrupt(ar, ce_id);\n}\nEXPORT_SYMBOL(ath10k_ce_disable_interrupts);\n\nvoid ath10k_ce_enable_interrupt(struct ath10k *ar, int ce_id)\n{\n\tstruct ath10k_ce *ce = ath10k_ce_priv(ar);\n\tstruct ath10k_ce_pipe *ce_state;\n\n\tce_state  = &ce->ce_states[ce_id];\n\tif (ce_state->attr_flags & CE_ATTR_POLL)\n\t\treturn;\n\n\tath10k_ce_per_engine_handler_adjust(ce_state);\n}\nEXPORT_SYMBOL(ath10k_ce_enable_interrupt);\n\nvoid ath10k_ce_enable_interrupts(struct ath10k *ar)\n{\n\tint ce_id;\n\n\t \n\tfor (ce_id = 0; ce_id < CE_COUNT; ce_id++)\n\t\tath10k_ce_enable_interrupt(ar, ce_id);\n}\nEXPORT_SYMBOL(ath10k_ce_enable_interrupts);\n\nstatic int ath10k_ce_init_src_ring(struct ath10k *ar,\n\t\t\t\t   unsigned int ce_id,\n\t\t\t\t   const struct ce_attr *attr)\n{\n\tstruct ath10k_ce *ce = ath10k_ce_priv(ar);\n\tstruct ath10k_ce_pipe *ce_state = &ce->ce_states[ce_id];\n\tstruct ath10k_ce_ring *src_ring = ce_state->src_ring;\n\tu32 nentries, ctrl_addr = ath10k_ce_base_address(ar, ce_id);\n\n\tnentries = roundup_pow_of_two(attr->src_nentries);\n\n\tif (ar->hw_params.target_64bit)\n\t\tmemset(src_ring->base_addr_owner_space, 0,\n\t\t       nentries * sizeof(struct ce_desc_64));\n\telse\n\t\tmemset(src_ring->base_addr_owner_space, 0,\n\t\t       nentries * sizeof(struct ce_desc));\n\n\tsrc_ring->sw_index = ath10k_ce_src_ring_read_index_get(ar, ctrl_addr);\n\tsrc_ring->sw_index &= src_ring->nentries_mask;\n\tsrc_ring->hw_index = src_ring->sw_index;\n\n\tsrc_ring->write_index =\n\t\tath10k_ce_src_ring_write_index_get(ar, ctrl_addr);\n\tsrc_ring->write_index &= src_ring->nentries_mask;\n\n\tath10k_ce_src_ring_base_addr_set(ar, ce_id,\n\t\t\t\t\t src_ring->base_addr_ce_space);\n\tath10k_ce_src_ring_size_set(ar, ctrl_addr, nentries);\n\tath10k_ce_src_ring_dmax_set(ar, ctrl_addr, attr->src_sz_max);\n\tath10k_ce_src_ring_byte_swap_set(ar, ctrl_addr, 0);\n\tath10k_ce_src_ring_lowmark_set(ar, ctrl_addr, 0);\n\tath10k_ce_src_ring_highmark_set(ar, ctrl_addr, nentries);\n\n\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t   \"boot init ce src ring id %d entries %d base_addr %pK\\n\",\n\t\t   ce_id, nentries, src_ring->base_addr_owner_space);\n\n\treturn 0;\n}\n\nstatic int ath10k_ce_init_dest_ring(struct ath10k *ar,\n\t\t\t\t    unsigned int ce_id,\n\t\t\t\t    const struct ce_attr *attr)\n{\n\tstruct ath10k_ce *ce = ath10k_ce_priv(ar);\n\tstruct ath10k_ce_pipe *ce_state = &ce->ce_states[ce_id];\n\tstruct ath10k_ce_ring *dest_ring = ce_state->dest_ring;\n\tu32 nentries, ctrl_addr = ath10k_ce_base_address(ar, ce_id);\n\n\tnentries = roundup_pow_of_two(attr->dest_nentries);\n\n\tif (ar->hw_params.target_64bit)\n\t\tmemset(dest_ring->base_addr_owner_space, 0,\n\t\t       nentries * sizeof(struct ce_desc_64));\n\telse\n\t\tmemset(dest_ring->base_addr_owner_space, 0,\n\t\t       nentries * sizeof(struct ce_desc));\n\n\tdest_ring->sw_index = ath10k_ce_dest_ring_read_index_get(ar, ctrl_addr);\n\tdest_ring->sw_index &= dest_ring->nentries_mask;\n\tdest_ring->write_index =\n\t\tath10k_ce_dest_ring_write_index_get(ar, ctrl_addr);\n\tdest_ring->write_index &= dest_ring->nentries_mask;\n\n\tath10k_ce_dest_ring_base_addr_set(ar, ce_id,\n\t\t\t\t\t  dest_ring->base_addr_ce_space);\n\tath10k_ce_dest_ring_size_set(ar, ctrl_addr, nentries);\n\tath10k_ce_dest_ring_byte_swap_set(ar, ctrl_addr, 0);\n\tath10k_ce_dest_ring_lowmark_set(ar, ctrl_addr, 0);\n\tath10k_ce_dest_ring_highmark_set(ar, ctrl_addr, nentries);\n\n\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t   \"boot ce dest ring id %d entries %d base_addr %pK\\n\",\n\t\t   ce_id, nentries, dest_ring->base_addr_owner_space);\n\n\treturn 0;\n}\n\nstatic int ath10k_ce_alloc_shadow_base(struct ath10k *ar,\n\t\t\t\t       struct ath10k_ce_ring *src_ring,\n\t\t\t\t       u32 nentries)\n{\n\tsrc_ring->shadow_base_unaligned = kcalloc(nentries,\n\t\t\t\t\t\t  sizeof(struct ce_desc_64),\n\t\t\t\t\t\t  GFP_KERNEL);\n\tif (!src_ring->shadow_base_unaligned)\n\t\treturn -ENOMEM;\n\n\tsrc_ring->shadow_base = (struct ce_desc_64 *)\n\t\t\tPTR_ALIGN(src_ring->shadow_base_unaligned,\n\t\t\t\t  CE_DESC_RING_ALIGN);\n\treturn 0;\n}\n\nstatic struct ath10k_ce_ring *\nath10k_ce_alloc_src_ring(struct ath10k *ar, unsigned int ce_id,\n\t\t\t const struct ce_attr *attr)\n{\n\tstruct ath10k_ce_ring *src_ring;\n\tu32 nentries = attr->src_nentries;\n\tdma_addr_t base_addr;\n\tint ret;\n\n\tnentries = roundup_pow_of_two(nentries);\n\n\tsrc_ring = kzalloc(struct_size(src_ring, per_transfer_context,\n\t\t\t\t       nentries), GFP_KERNEL);\n\tif (src_ring == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tsrc_ring->nentries = nentries;\n\tsrc_ring->nentries_mask = nentries - 1;\n\n\t \n\tsrc_ring->base_addr_owner_space_unaligned =\n\t\tdma_alloc_coherent(ar->dev,\n\t\t\t\t   (nentries * sizeof(struct ce_desc) +\n\t\t\t\t    CE_DESC_RING_ALIGN),\n\t\t\t\t   &base_addr, GFP_KERNEL);\n\tif (!src_ring->base_addr_owner_space_unaligned) {\n\t\tkfree(src_ring);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tsrc_ring->base_addr_ce_space_unaligned = base_addr;\n\n\tsrc_ring->base_addr_owner_space =\n\t\t\tPTR_ALIGN(src_ring->base_addr_owner_space_unaligned,\n\t\t\t\t  CE_DESC_RING_ALIGN);\n\tsrc_ring->base_addr_ce_space =\n\t\t\tALIGN(src_ring->base_addr_ce_space_unaligned,\n\t\t\t      CE_DESC_RING_ALIGN);\n\n\tif (ar->hw_params.shadow_reg_support) {\n\t\tret = ath10k_ce_alloc_shadow_base(ar, src_ring, nentries);\n\t\tif (ret) {\n\t\t\tdma_free_coherent(ar->dev,\n\t\t\t\t\t  (nentries * sizeof(struct ce_desc) +\n\t\t\t\t\t   CE_DESC_RING_ALIGN),\n\t\t\t\t\t  src_ring->base_addr_owner_space_unaligned,\n\t\t\t\t\t  base_addr);\n\t\t\tkfree(src_ring);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\n\treturn src_ring;\n}\n\nstatic struct ath10k_ce_ring *\nath10k_ce_alloc_src_ring_64(struct ath10k *ar, unsigned int ce_id,\n\t\t\t    const struct ce_attr *attr)\n{\n\tstruct ath10k_ce_ring *src_ring;\n\tu32 nentries = attr->src_nentries;\n\tdma_addr_t base_addr;\n\tint ret;\n\n\tnentries = roundup_pow_of_two(nentries);\n\n\tsrc_ring = kzalloc(struct_size(src_ring, per_transfer_context,\n\t\t\t\t       nentries), GFP_KERNEL);\n\tif (!src_ring)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tsrc_ring->nentries = nentries;\n\tsrc_ring->nentries_mask = nentries - 1;\n\n\t \n\tsrc_ring->base_addr_owner_space_unaligned =\n\t\tdma_alloc_coherent(ar->dev,\n\t\t\t\t   (nentries * sizeof(struct ce_desc_64) +\n\t\t\t\t    CE_DESC_RING_ALIGN),\n\t\t\t\t   &base_addr, GFP_KERNEL);\n\tif (!src_ring->base_addr_owner_space_unaligned) {\n\t\tkfree(src_ring);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tsrc_ring->base_addr_ce_space_unaligned = base_addr;\n\n\tsrc_ring->base_addr_owner_space =\n\t\t\tPTR_ALIGN(src_ring->base_addr_owner_space_unaligned,\n\t\t\t\t  CE_DESC_RING_ALIGN);\n\tsrc_ring->base_addr_ce_space =\n\t\t\tALIGN(src_ring->base_addr_ce_space_unaligned,\n\t\t\t      CE_DESC_RING_ALIGN);\n\n\tif (ar->hw_params.shadow_reg_support) {\n\t\tret = ath10k_ce_alloc_shadow_base(ar, src_ring, nentries);\n\t\tif (ret) {\n\t\t\tdma_free_coherent(ar->dev,\n\t\t\t\t\t  (nentries * sizeof(struct ce_desc_64) +\n\t\t\t\t\t   CE_DESC_RING_ALIGN),\n\t\t\t\t\t  src_ring->base_addr_owner_space_unaligned,\n\t\t\t\t\t  base_addr);\n\t\t\tkfree(src_ring);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\n\treturn src_ring;\n}\n\nstatic struct ath10k_ce_ring *\nath10k_ce_alloc_dest_ring(struct ath10k *ar, unsigned int ce_id,\n\t\t\t  const struct ce_attr *attr)\n{\n\tstruct ath10k_ce_ring *dest_ring;\n\tu32 nentries;\n\tdma_addr_t base_addr;\n\n\tnentries = roundup_pow_of_two(attr->dest_nentries);\n\n\tdest_ring = kzalloc(struct_size(dest_ring, per_transfer_context,\n\t\t\t\t\tnentries), GFP_KERNEL);\n\tif (dest_ring == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdest_ring->nentries = nentries;\n\tdest_ring->nentries_mask = nentries - 1;\n\n\t \n\tdest_ring->base_addr_owner_space_unaligned =\n\t\tdma_alloc_coherent(ar->dev,\n\t\t\t\t   (nentries * sizeof(struct ce_desc) +\n\t\t\t\t    CE_DESC_RING_ALIGN),\n\t\t\t\t   &base_addr, GFP_KERNEL);\n\tif (!dest_ring->base_addr_owner_space_unaligned) {\n\t\tkfree(dest_ring);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tdest_ring->base_addr_ce_space_unaligned = base_addr;\n\n\tdest_ring->base_addr_owner_space =\n\t\t\tPTR_ALIGN(dest_ring->base_addr_owner_space_unaligned,\n\t\t\t\t  CE_DESC_RING_ALIGN);\n\tdest_ring->base_addr_ce_space =\n\t\t\t\tALIGN(dest_ring->base_addr_ce_space_unaligned,\n\t\t\t\t      CE_DESC_RING_ALIGN);\n\n\treturn dest_ring;\n}\n\nstatic struct ath10k_ce_ring *\nath10k_ce_alloc_dest_ring_64(struct ath10k *ar, unsigned int ce_id,\n\t\t\t     const struct ce_attr *attr)\n{\n\tstruct ath10k_ce_ring *dest_ring;\n\tu32 nentries;\n\tdma_addr_t base_addr;\n\n\tnentries = roundup_pow_of_two(attr->dest_nentries);\n\n\tdest_ring = kzalloc(struct_size(dest_ring, per_transfer_context,\n\t\t\t\t\tnentries), GFP_KERNEL);\n\tif (!dest_ring)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdest_ring->nentries = nentries;\n\tdest_ring->nentries_mask = nentries - 1;\n\n\t \n\tdest_ring->base_addr_owner_space_unaligned =\n\t\tdma_alloc_coherent(ar->dev,\n\t\t\t\t   (nentries * sizeof(struct ce_desc_64) +\n\t\t\t\t    CE_DESC_RING_ALIGN),\n\t\t\t\t   &base_addr, GFP_KERNEL);\n\tif (!dest_ring->base_addr_owner_space_unaligned) {\n\t\tkfree(dest_ring);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tdest_ring->base_addr_ce_space_unaligned = base_addr;\n\n\t \n\tdest_ring->base_addr_owner_space =\n\t\t\tPTR_ALIGN(dest_ring->base_addr_owner_space_unaligned,\n\t\t\t\t  CE_DESC_RING_ALIGN);\n\tdest_ring->base_addr_ce_space =\n\t\t\tALIGN(dest_ring->base_addr_ce_space_unaligned,\n\t\t\t      CE_DESC_RING_ALIGN);\n\n\treturn dest_ring;\n}\n\n \nint ath10k_ce_init_pipe(struct ath10k *ar, unsigned int ce_id,\n\t\t\tconst struct ce_attr *attr)\n{\n\tint ret;\n\n\tif (attr->src_nentries) {\n\t\tret = ath10k_ce_init_src_ring(ar, ce_id, attr);\n\t\tif (ret) {\n\t\t\tath10k_err(ar, \"Failed to initialize CE src ring for ID: %d (%d)\\n\",\n\t\t\t\t   ce_id, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (attr->dest_nentries) {\n\t\tret = ath10k_ce_init_dest_ring(ar, ce_id, attr);\n\t\tif (ret) {\n\t\t\tath10k_err(ar, \"Failed to initialize CE dest ring for ID: %d (%d)\\n\",\n\t\t\t\t   ce_id, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ath10k_ce_init_pipe);\n\nstatic void ath10k_ce_deinit_src_ring(struct ath10k *ar, unsigned int ce_id)\n{\n\tu32 ctrl_addr = ath10k_ce_base_address(ar, ce_id);\n\n\tath10k_ce_src_ring_base_addr_set(ar, ce_id, 0);\n\tath10k_ce_src_ring_size_set(ar, ctrl_addr, 0);\n\tath10k_ce_src_ring_dmax_set(ar, ctrl_addr, 0);\n\tath10k_ce_src_ring_highmark_set(ar, ctrl_addr, 0);\n}\n\nstatic void ath10k_ce_deinit_dest_ring(struct ath10k *ar, unsigned int ce_id)\n{\n\tu32 ctrl_addr = ath10k_ce_base_address(ar, ce_id);\n\n\tath10k_ce_dest_ring_base_addr_set(ar, ce_id, 0);\n\tath10k_ce_dest_ring_size_set(ar, ctrl_addr, 0);\n\tath10k_ce_dest_ring_highmark_set(ar, ctrl_addr, 0);\n}\n\nvoid ath10k_ce_deinit_pipe(struct ath10k *ar, unsigned int ce_id)\n{\n\tath10k_ce_deinit_src_ring(ar, ce_id);\n\tath10k_ce_deinit_dest_ring(ar, ce_id);\n}\nEXPORT_SYMBOL(ath10k_ce_deinit_pipe);\n\nstatic void _ath10k_ce_free_pipe(struct ath10k *ar, int ce_id)\n{\n\tstruct ath10k_ce *ce = ath10k_ce_priv(ar);\n\tstruct ath10k_ce_pipe *ce_state = &ce->ce_states[ce_id];\n\n\tif (ce_state->src_ring) {\n\t\tif (ar->hw_params.shadow_reg_support)\n\t\t\tkfree(ce_state->src_ring->shadow_base_unaligned);\n\t\tdma_free_coherent(ar->dev,\n\t\t\t\t  (ce_state->src_ring->nentries *\n\t\t\t\t   sizeof(struct ce_desc) +\n\t\t\t\t   CE_DESC_RING_ALIGN),\n\t\t\t\t  ce_state->src_ring->base_addr_owner_space,\n\t\t\t\t  ce_state->src_ring->base_addr_ce_space);\n\t\tkfree(ce_state->src_ring);\n\t}\n\n\tif (ce_state->dest_ring) {\n\t\tdma_free_coherent(ar->dev,\n\t\t\t\t  (ce_state->dest_ring->nentries *\n\t\t\t\t   sizeof(struct ce_desc) +\n\t\t\t\t   CE_DESC_RING_ALIGN),\n\t\t\t\t  ce_state->dest_ring->base_addr_owner_space,\n\t\t\t\t  ce_state->dest_ring->base_addr_ce_space);\n\t\tkfree(ce_state->dest_ring);\n\t}\n\n\tce_state->src_ring = NULL;\n\tce_state->dest_ring = NULL;\n}\n\nstatic void _ath10k_ce_free_pipe_64(struct ath10k *ar, int ce_id)\n{\n\tstruct ath10k_ce *ce = ath10k_ce_priv(ar);\n\tstruct ath10k_ce_pipe *ce_state = &ce->ce_states[ce_id];\n\n\tif (ce_state->src_ring) {\n\t\tif (ar->hw_params.shadow_reg_support)\n\t\t\tkfree(ce_state->src_ring->shadow_base_unaligned);\n\t\tdma_free_coherent(ar->dev,\n\t\t\t\t  (ce_state->src_ring->nentries *\n\t\t\t\t   sizeof(struct ce_desc_64) +\n\t\t\t\t   CE_DESC_RING_ALIGN),\n\t\t\t\t  ce_state->src_ring->base_addr_owner_space,\n\t\t\t\t  ce_state->src_ring->base_addr_ce_space);\n\t\tkfree(ce_state->src_ring);\n\t}\n\n\tif (ce_state->dest_ring) {\n\t\tdma_free_coherent(ar->dev,\n\t\t\t\t  (ce_state->dest_ring->nentries *\n\t\t\t\t   sizeof(struct ce_desc_64) +\n\t\t\t\t   CE_DESC_RING_ALIGN),\n\t\t\t\t  ce_state->dest_ring->base_addr_owner_space,\n\t\t\t\t  ce_state->dest_ring->base_addr_ce_space);\n\t\tkfree(ce_state->dest_ring);\n\t}\n\n\tce_state->src_ring = NULL;\n\tce_state->dest_ring = NULL;\n}\n\nvoid ath10k_ce_free_pipe(struct ath10k *ar, int ce_id)\n{\n\tstruct ath10k_ce *ce = ath10k_ce_priv(ar);\n\tstruct ath10k_ce_pipe *ce_state = &ce->ce_states[ce_id];\n\n\tce_state->ops->ce_free_pipe(ar, ce_id);\n}\nEXPORT_SYMBOL(ath10k_ce_free_pipe);\n\nvoid ath10k_ce_dump_registers(struct ath10k *ar,\n\t\t\t      struct ath10k_fw_crash_data *crash_data)\n{\n\tstruct ath10k_ce *ce = ath10k_ce_priv(ar);\n\tstruct ath10k_ce_crash_data ce_data;\n\tu32 addr, id;\n\n\tlockdep_assert_held(&ar->dump_mutex);\n\n\tath10k_err(ar, \"Copy Engine register dump:\\n\");\n\n\tspin_lock_bh(&ce->ce_lock);\n\tfor (id = 0; id < CE_COUNT; id++) {\n\t\taddr = ath10k_ce_base_address(ar, id);\n\t\tce_data.base_addr = cpu_to_le32(addr);\n\n\t\tce_data.src_wr_idx =\n\t\t\tcpu_to_le32(ath10k_ce_src_ring_write_index_get(ar, addr));\n\t\tce_data.src_r_idx =\n\t\t\tcpu_to_le32(ath10k_ce_src_ring_read_index_get(ar, addr));\n\t\tce_data.dst_wr_idx =\n\t\t\tcpu_to_le32(ath10k_ce_dest_ring_write_index_get(ar, addr));\n\t\tce_data.dst_r_idx =\n\t\t\tcpu_to_le32(ath10k_ce_dest_ring_read_index_get(ar, addr));\n\n\t\tif (crash_data)\n\t\t\tcrash_data->ce_crash_data[id] = ce_data;\n\n\t\tath10k_err(ar, \"[%02d]: 0x%08x %3u %3u %3u %3u\", id,\n\t\t\t   le32_to_cpu(ce_data.base_addr),\n\t\t\t   le32_to_cpu(ce_data.src_wr_idx),\n\t\t\t   le32_to_cpu(ce_data.src_r_idx),\n\t\t\t   le32_to_cpu(ce_data.dst_wr_idx),\n\t\t\t   le32_to_cpu(ce_data.dst_r_idx));\n\t}\n\n\tspin_unlock_bh(&ce->ce_lock);\n}\nEXPORT_SYMBOL(ath10k_ce_dump_registers);\n\nstatic const struct ath10k_ce_ops ce_ops = {\n\t.ce_alloc_src_ring = ath10k_ce_alloc_src_ring,\n\t.ce_alloc_dst_ring = ath10k_ce_alloc_dest_ring,\n\t.ce_rx_post_buf = __ath10k_ce_rx_post_buf,\n\t.ce_completed_recv_next_nolock = _ath10k_ce_completed_recv_next_nolock,\n\t.ce_revoke_recv_next = _ath10k_ce_revoke_recv_next,\n\t.ce_extract_desc_data = ath10k_ce_extract_desc_data,\n\t.ce_free_pipe = _ath10k_ce_free_pipe,\n\t.ce_send_nolock = _ath10k_ce_send_nolock,\n\t.ce_set_src_ring_base_addr_hi = NULL,\n\t.ce_set_dest_ring_base_addr_hi = NULL,\n\t.ce_completed_send_next_nolock = _ath10k_ce_completed_send_next_nolock,\n};\n\nstatic const struct ath10k_ce_ops ce_64_ops = {\n\t.ce_alloc_src_ring = ath10k_ce_alloc_src_ring_64,\n\t.ce_alloc_dst_ring = ath10k_ce_alloc_dest_ring_64,\n\t.ce_rx_post_buf = __ath10k_ce_rx_post_buf_64,\n\t.ce_completed_recv_next_nolock =\n\t\t\t\t_ath10k_ce_completed_recv_next_nolock_64,\n\t.ce_revoke_recv_next = _ath10k_ce_revoke_recv_next_64,\n\t.ce_extract_desc_data = ath10k_ce_extract_desc_data_64,\n\t.ce_free_pipe = _ath10k_ce_free_pipe_64,\n\t.ce_send_nolock = _ath10k_ce_send_nolock_64,\n\t.ce_set_src_ring_base_addr_hi = ath10k_ce_set_src_ring_base_addr_hi,\n\t.ce_set_dest_ring_base_addr_hi = ath10k_ce_set_dest_ring_base_addr_hi,\n\t.ce_completed_send_next_nolock = _ath10k_ce_completed_send_next_nolock_64,\n};\n\nstatic void ath10k_ce_set_ops(struct ath10k *ar,\n\t\t\t      struct ath10k_ce_pipe *ce_state)\n{\n\tswitch (ar->hw_rev) {\n\tcase ATH10K_HW_WCN3990:\n\t\tce_state->ops = &ce_64_ops;\n\t\tbreak;\n\tdefault:\n\t\tce_state->ops = &ce_ops;\n\t\tbreak;\n\t}\n}\n\nint ath10k_ce_alloc_pipe(struct ath10k *ar, int ce_id,\n\t\t\t const struct ce_attr *attr)\n{\n\tstruct ath10k_ce *ce = ath10k_ce_priv(ar);\n\tstruct ath10k_ce_pipe *ce_state = &ce->ce_states[ce_id];\n\tint ret;\n\n\tath10k_ce_set_ops(ar, ce_state);\n\t \n\tBUILD_BUG_ON(2 * TARGET_NUM_MSDU_DESC >\n\t\t     (CE_HTT_H2T_MSG_SRC_NENTRIES - 1));\n\tBUILD_BUG_ON(2 * TARGET_10_4_NUM_MSDU_DESC_PFC >\n\t\t     (CE_HTT_H2T_MSG_SRC_NENTRIES - 1));\n\tBUILD_BUG_ON(2 * TARGET_TLV_NUM_MSDU_DESC >\n\t\t     (CE_HTT_H2T_MSG_SRC_NENTRIES - 1));\n\n\tce_state->ar = ar;\n\tce_state->id = ce_id;\n\tce_state->ctrl_addr = ath10k_ce_base_address(ar, ce_id);\n\tce_state->attr_flags = attr->flags;\n\tce_state->src_sz_max = attr->src_sz_max;\n\n\tif (attr->src_nentries)\n\t\tce_state->send_cb = attr->send_cb;\n\n\tif (attr->dest_nentries)\n\t\tce_state->recv_cb = attr->recv_cb;\n\n\tif (attr->src_nentries) {\n\t\tce_state->src_ring =\n\t\t\tce_state->ops->ce_alloc_src_ring(ar, ce_id, attr);\n\t\tif (IS_ERR(ce_state->src_ring)) {\n\t\t\tret = PTR_ERR(ce_state->src_ring);\n\t\t\tath10k_err(ar, \"failed to alloc CE src ring %d: %d\\n\",\n\t\t\t\t   ce_id, ret);\n\t\t\tce_state->src_ring = NULL;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (attr->dest_nentries) {\n\t\tce_state->dest_ring = ce_state->ops->ce_alloc_dst_ring(ar,\n\t\t\t\t\t\t\t\t\tce_id,\n\t\t\t\t\t\t\t\t\tattr);\n\t\tif (IS_ERR(ce_state->dest_ring)) {\n\t\t\tret = PTR_ERR(ce_state->dest_ring);\n\t\t\tath10k_err(ar, \"failed to alloc CE dest ring %d: %d\\n\",\n\t\t\t\t   ce_id, ret);\n\t\t\tce_state->dest_ring = NULL;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ath10k_ce_alloc_pipe);\n\nvoid ath10k_ce_alloc_rri(struct ath10k *ar)\n{\n\tint i;\n\tu32 value;\n\tu32 ctrl1_regs;\n\tu32 ce_base_addr;\n\tstruct ath10k_ce *ce = ath10k_ce_priv(ar);\n\n\tce->vaddr_rri = dma_alloc_coherent(ar->dev,\n\t\t\t\t\t   (CE_COUNT * sizeof(u32)),\n\t\t\t\t\t   &ce->paddr_rri, GFP_KERNEL);\n\n\tif (!ce->vaddr_rri)\n\t\treturn;\n\n\tath10k_ce_write32(ar, ar->hw_ce_regs->ce_rri_low,\n\t\t\t  lower_32_bits(ce->paddr_rri));\n\tath10k_ce_write32(ar, ar->hw_ce_regs->ce_rri_high,\n\t\t\t  (upper_32_bits(ce->paddr_rri) &\n\t\t\t  CE_DESC_ADDR_HI_MASK));\n\n\tfor (i = 0; i < CE_COUNT; i++) {\n\t\tctrl1_regs = ar->hw_ce_regs->ctrl1_regs->addr;\n\t\tce_base_addr = ath10k_ce_base_address(ar, i);\n\t\tvalue = ath10k_ce_read32(ar, ce_base_addr + ctrl1_regs);\n\t\tvalue |= ar->hw_ce_regs->upd->mask;\n\t\tath10k_ce_write32(ar, ce_base_addr + ctrl1_regs, value);\n\t}\n}\nEXPORT_SYMBOL(ath10k_ce_alloc_rri);\n\nvoid ath10k_ce_free_rri(struct ath10k *ar)\n{\n\tstruct ath10k_ce *ce = ath10k_ce_priv(ar);\n\n\tdma_free_coherent(ar->dev, (CE_COUNT * sizeof(u32)),\n\t\t\t  ce->vaddr_rri,\n\t\t\t  ce->paddr_rri);\n}\nEXPORT_SYMBOL(ath10k_ce_free_rri);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}