{
  "module_name": "thermal.c",
  "hash_id": "9d7b71907f0fa14b435e2efb157d6e822d1e428253f561770c6fde3dfec884d6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath10k/thermal.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/sysfs.h>\n#include <linux/thermal.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include \"core.h\"\n#include \"debug.h\"\n#include \"wmi-ops.h\"\n\nstatic int\nath10k_thermal_get_max_throttle_state(struct thermal_cooling_device *cdev,\n\t\t\t\t      unsigned long *state)\n{\n\t*state = ATH10K_THERMAL_THROTTLE_MAX;\n\n\treturn 0;\n}\n\nstatic int\nath10k_thermal_get_cur_throttle_state(struct thermal_cooling_device *cdev,\n\t\t\t\t      unsigned long *state)\n{\n\tstruct ath10k *ar = cdev->devdata;\n\n\tmutex_lock(&ar->conf_mutex);\n\t*state = ar->thermal.throttle_state;\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn 0;\n}\n\nstatic int\nath10k_thermal_set_cur_throttle_state(struct thermal_cooling_device *cdev,\n\t\t\t\t      unsigned long throttle_state)\n{\n\tstruct ath10k *ar = cdev->devdata;\n\n\tif (throttle_state > ATH10K_THERMAL_THROTTLE_MAX) {\n\t\tath10k_warn(ar, \"throttle state %ld is exceeding the limit %d\\n\",\n\t\t\t    throttle_state, ATH10K_THERMAL_THROTTLE_MAX);\n\t\treturn -EINVAL;\n\t}\n\tmutex_lock(&ar->conf_mutex);\n\tar->thermal.throttle_state = throttle_state;\n\tath10k_thermal_set_throttling(ar);\n\tmutex_unlock(&ar->conf_mutex);\n\treturn 0;\n}\n\nstatic const struct thermal_cooling_device_ops ath10k_thermal_ops = {\n\t.get_max_state = ath10k_thermal_get_max_throttle_state,\n\t.get_cur_state = ath10k_thermal_get_cur_throttle_state,\n\t.set_cur_state = ath10k_thermal_set_cur_throttle_state,\n};\n\nstatic ssize_t ath10k_thermal_show_temp(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct ath10k *ar = dev_get_drvdata(dev);\n\tint ret, temperature;\n\tunsigned long time_left;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\t \n\tif (ar->state != ATH10K_STATE_ON) {\n\t\tret = -ENETDOWN;\n\t\tgoto out;\n\t}\n\n\treinit_completion(&ar->thermal.wmi_sync);\n\tret = ath10k_wmi_pdev_get_temperature(ar);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to read temperature %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tif (test_bit(ATH10K_FLAG_CRASH_FLUSH, &ar->dev_flags)) {\n\t\tret = -ESHUTDOWN;\n\t\tgoto out;\n\t}\n\n\ttime_left = wait_for_completion_timeout(&ar->thermal.wmi_sync,\n\t\t\t\t\t\tATH10K_THERMAL_SYNC_TIMEOUT_HZ);\n\tif (!time_left) {\n\t\tath10k_warn(ar, \"failed to synchronize thermal read\\n\");\n\t\tret = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\tspin_lock_bh(&ar->data_lock);\n\ttemperature = ar->thermal.temperature;\n\tspin_unlock_bh(&ar->data_lock);\n\n\t \n\tret = snprintf(buf, PAGE_SIZE, \"%d\\n\", temperature * 1000);\nout:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nvoid ath10k_thermal_event_temperature(struct ath10k *ar, int temperature)\n{\n\tspin_lock_bh(&ar->data_lock);\n\tar->thermal.temperature = temperature;\n\tspin_unlock_bh(&ar->data_lock);\n\tcomplete(&ar->thermal.wmi_sync);\n}\n\nstatic SENSOR_DEVICE_ATTR(temp1_input, 0444, ath10k_thermal_show_temp,\n\t\t\t  NULL, 0);\n\nstatic struct attribute *ath10k_hwmon_attrs[] = {\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(ath10k_hwmon);\n\nvoid ath10k_thermal_set_throttling(struct ath10k *ar)\n{\n\tu32 period, duration, enabled;\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (!test_bit(WMI_SERVICE_THERM_THROT, ar->wmi.svc_map))\n\t\treturn;\n\n\tif (!ar->wmi.ops->gen_pdev_set_quiet_mode)\n\t\treturn;\n\n\tif (ar->state != ATH10K_STATE_ON)\n\t\treturn;\n\n\tperiod = ar->thermal.quiet_period;\n\tduration = (period * ar->thermal.throttle_state) / 100;\n\tenabled = duration ? 1 : 0;\n\n\tret = ath10k_wmi_pdev_set_quiet_mode(ar, period, duration,\n\t\t\t\t\t     ATH10K_QUIET_START_OFFSET,\n\t\t\t\t\t     enabled);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set quiet mode period %u duarion %u enabled %u ret %d\\n\",\n\t\t\t    period, duration, enabled, ret);\n\t}\n}\n\nint ath10k_thermal_register(struct ath10k *ar)\n{\n\tstruct thermal_cooling_device *cdev;\n\tstruct device *hwmon_dev;\n\tint ret;\n\n\tif (!test_bit(WMI_SERVICE_THERM_THROT, ar->wmi.svc_map))\n\t\treturn 0;\n\n\tcdev = thermal_cooling_device_register(\"ath10k_thermal\", ar,\n\t\t\t\t\t       &ath10k_thermal_ops);\n\n\tif (IS_ERR(cdev)) {\n\t\tath10k_err(ar, \"failed to setup thermal device result: %ld\\n\",\n\t\t\t   PTR_ERR(cdev));\n\t\treturn -EINVAL;\n\t}\n\n\tret = sysfs_create_link(&ar->dev->kobj, &cdev->device.kobj,\n\t\t\t\t\"cooling_device\");\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to create cooling device symlink\\n\");\n\t\tgoto err_cooling_destroy;\n\t}\n\n\tar->thermal.cdev = cdev;\n\tar->thermal.quiet_period = ATH10K_QUIET_PERIOD_DEFAULT;\n\n\t \n\tif (!(ar->wmi.ops->gen_pdev_get_temperature))\n\t\treturn 0;\n\n\t \n\tif (!IS_REACHABLE(CONFIG_HWMON))\n\t\treturn 0;\n\n\thwmon_dev = devm_hwmon_device_register_with_groups(ar->dev,\n\t\t\t\t\t\t\t   \"ath10k_hwmon\", ar,\n\t\t\t\t\t\t\t   ath10k_hwmon_groups);\n\tif (IS_ERR(hwmon_dev)) {\n\t\tath10k_err(ar, \"failed to register hwmon device: %ld\\n\",\n\t\t\t   PTR_ERR(hwmon_dev));\n\t\tret = -EINVAL;\n\t\tgoto err_remove_link;\n\t}\n\treturn 0;\n\nerr_remove_link:\n\tsysfs_remove_link(&ar->dev->kobj, \"cooling_device\");\nerr_cooling_destroy:\n\tthermal_cooling_device_unregister(cdev);\n\treturn ret;\n}\n\nvoid ath10k_thermal_unregister(struct ath10k *ar)\n{\n\tif (!test_bit(WMI_SERVICE_THERM_THROT, ar->wmi.svc_map))\n\t\treturn;\n\n\tsysfs_remove_link(&ar->dev->kobj, \"cooling_device\");\n\tthermal_cooling_device_unregister(ar->thermal.cdev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}