{
  "module_name": "core.c",
  "hash_id": "2e622bef77c05f862798803bd7353cc0d6faba67ccf48f5632d21a947748ebb5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath10k/core.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/firmware.h>\n#include <linux/of.h>\n#include <linux/property.h>\n#include <linux/dmi.h>\n#include <linux/ctype.h>\n#include <linux/pm_qos.h>\n#include <linux/nvmem-consumer.h>\n#include <asm/byteorder.h>\n\n#include \"core.h\"\n#include \"mac.h\"\n#include \"htc.h\"\n#include \"hif.h\"\n#include \"wmi.h\"\n#include \"bmi.h\"\n#include \"debug.h\"\n#include \"htt.h\"\n#include \"testmode.h\"\n#include \"wmi-ops.h\"\n#include \"coredump.h\"\n\nunsigned int ath10k_debug_mask;\nEXPORT_SYMBOL(ath10k_debug_mask);\n\nstatic unsigned int ath10k_cryptmode_param;\nstatic bool uart_print;\nstatic bool skip_otp;\nstatic bool fw_diag_log;\n\n \nunsigned int ath10k_frame_mode = ATH10K_HW_TXRX_NATIVE_WIFI;\n\nunsigned long ath10k_coredump_mask = BIT(ATH10K_FW_CRASH_DUMP_REGISTERS) |\n\t\t\t\t     BIT(ATH10K_FW_CRASH_DUMP_CE_DATA);\n\n \nmodule_param_named(debug_mask, ath10k_debug_mask, uint, 0644);\nmodule_param_named(cryptmode, ath10k_cryptmode_param, uint, 0644);\nmodule_param(uart_print, bool, 0644);\nmodule_param(skip_otp, bool, 0644);\nmodule_param(fw_diag_log, bool, 0644);\nmodule_param_named(frame_mode, ath10k_frame_mode, uint, 0644);\nmodule_param_named(coredump_mask, ath10k_coredump_mask, ulong, 0444);\n\nMODULE_PARM_DESC(debug_mask, \"Debugging mask\");\nMODULE_PARM_DESC(uart_print, \"Uart target debugging\");\nMODULE_PARM_DESC(skip_otp, \"Skip otp failure for calibration in testmode\");\nMODULE_PARM_DESC(cryptmode, \"Crypto mode: 0-hardware, 1-software\");\nMODULE_PARM_DESC(frame_mode,\n\t\t \"Datapath frame mode (0: raw, 1: native wifi (default), 2: ethernet)\");\nMODULE_PARM_DESC(coredump_mask, \"Bitfield of what to include in firmware crash file\");\nMODULE_PARM_DESC(fw_diag_log, \"Diag based fw log debugging\");\n\nstatic const struct ath10k_hw_params ath10k_hw_params_list[] = {\n\t{\n\t\t.id = QCA988X_HW_2_0_VERSION,\n\t\t.dev_id = QCA988X_2_0_DEVICE_ID,\n\t\t.bus = ATH10K_BUS_PCI,\n\t\t.name = \"qca988x hw2.0\",\n\t\t.patch_load_addr = QCA988X_HW_2_0_PATCH_LOAD_ADDR,\n\t\t.uart_pin = 7,\n\t\t.cc_wraparound_type = ATH10K_HW_CC_WRAP_SHIFTED_ALL,\n\t\t.otp_exe_param = 0,\n\t\t.channel_counters_freq_hz = 88000,\n\t\t.max_probe_resp_desc_thres = 0,\n\t\t.cal_data_len = 2116,\n\t\t.fw = {\n\t\t\t.dir = QCA988X_HW_2_0_FW_DIR,\n\t\t\t.board = QCA988X_HW_2_0_BOARD_DATA_FILE,\n\t\t\t.board_size = QCA988X_BOARD_DATA_SZ,\n\t\t\t.board_ext_size = QCA988X_BOARD_EXT_DATA_SZ,\n\t\t},\n\t\t.rx_desc_ops = &qca988x_rx_desc_ops,\n\t\t.hw_ops = &qca988x_ops,\n\t\t.decap_align_bytes = 4,\n\t\t.spectral_bin_discard = 0,\n\t\t.spectral_bin_offset = 0,\n\t\t.vht160_mcs_rx_highest = 0,\n\t\t.vht160_mcs_tx_highest = 0,\n\t\t.n_cipher_suites = 8,\n\t\t.ast_skid_limit = 0x10,\n\t\t.num_wds_entries = 0x20,\n\t\t.target_64bit = false,\n\t\t.rx_ring_fill_level = HTT_RX_RING_FILL_LEVEL,\n\t\t.shadow_reg_support = false,\n\t\t.rri_on_ddr = false,\n\t\t.hw_filter_reset_required = true,\n\t\t.fw_diag_ce_download = false,\n\t\t.credit_size_workaround = false,\n\t\t.tx_stats_over_pktlog = true,\n\t\t.dynamic_sar_support = false,\n\t\t.hw_restart_disconnect = false,\n\t\t.use_fw_tx_credits = true,\n\t\t.delay_unmap_buffer = false,\n\t},\n\t{\n\t\t.id = QCA988X_HW_2_0_VERSION,\n\t\t.dev_id = QCA988X_2_0_DEVICE_ID_UBNT,\n\t\t.name = \"qca988x hw2.0 ubiquiti\",\n\t\t.patch_load_addr = QCA988X_HW_2_0_PATCH_LOAD_ADDR,\n\t\t.uart_pin = 7,\n\t\t.cc_wraparound_type = ATH10K_HW_CC_WRAP_SHIFTED_ALL,\n\t\t.otp_exe_param = 0,\n\t\t.channel_counters_freq_hz = 88000,\n\t\t.max_probe_resp_desc_thres = 0,\n\t\t.cal_data_len = 2116,\n\t\t.fw = {\n\t\t\t.dir = QCA988X_HW_2_0_FW_DIR,\n\t\t\t.board = QCA988X_HW_2_0_BOARD_DATA_FILE,\n\t\t\t.board_size = QCA988X_BOARD_DATA_SZ,\n\t\t\t.board_ext_size = QCA988X_BOARD_EXT_DATA_SZ,\n\t\t},\n\t\t.rx_desc_ops = &qca988x_rx_desc_ops,\n\t\t.hw_ops = &qca988x_ops,\n\t\t.decap_align_bytes = 4,\n\t\t.spectral_bin_discard = 0,\n\t\t.spectral_bin_offset = 0,\n\t\t.vht160_mcs_rx_highest = 0,\n\t\t.vht160_mcs_tx_highest = 0,\n\t\t.n_cipher_suites = 8,\n\t\t.ast_skid_limit = 0x10,\n\t\t.num_wds_entries = 0x20,\n\t\t.target_64bit = false,\n\t\t.rx_ring_fill_level = HTT_RX_RING_FILL_LEVEL,\n\t\t.shadow_reg_support = false,\n\t\t.rri_on_ddr = false,\n\t\t.hw_filter_reset_required = true,\n\t\t.fw_diag_ce_download = false,\n\t\t.credit_size_workaround = false,\n\t\t.tx_stats_over_pktlog = true,\n\t\t.dynamic_sar_support = false,\n\t\t.hw_restart_disconnect = false,\n\t\t.use_fw_tx_credits = true,\n\t\t.delay_unmap_buffer = false,\n\t},\n\t{\n\t\t.id = QCA9887_HW_1_0_VERSION,\n\t\t.dev_id = QCA9887_1_0_DEVICE_ID,\n\t\t.bus = ATH10K_BUS_PCI,\n\t\t.name = \"qca9887 hw1.0\",\n\t\t.patch_load_addr = QCA9887_HW_1_0_PATCH_LOAD_ADDR,\n\t\t.uart_pin = 7,\n\t\t.cc_wraparound_type = ATH10K_HW_CC_WRAP_SHIFTED_ALL,\n\t\t.otp_exe_param = 0,\n\t\t.channel_counters_freq_hz = 88000,\n\t\t.max_probe_resp_desc_thres = 0,\n\t\t.cal_data_len = 2116,\n\t\t.fw = {\n\t\t\t.dir = QCA9887_HW_1_0_FW_DIR,\n\t\t\t.board = QCA9887_HW_1_0_BOARD_DATA_FILE,\n\t\t\t.board_size = QCA9887_BOARD_DATA_SZ,\n\t\t\t.board_ext_size = QCA9887_BOARD_EXT_DATA_SZ,\n\t\t},\n\t\t.rx_desc_ops = &qca988x_rx_desc_ops,\n\t\t.hw_ops = &qca988x_ops,\n\t\t.decap_align_bytes = 4,\n\t\t.spectral_bin_discard = 0,\n\t\t.spectral_bin_offset = 0,\n\t\t.vht160_mcs_rx_highest = 0,\n\t\t.vht160_mcs_tx_highest = 0,\n\t\t.n_cipher_suites = 8,\n\t\t.ast_skid_limit = 0x10,\n\t\t.num_wds_entries = 0x20,\n\t\t.target_64bit = false,\n\t\t.rx_ring_fill_level = HTT_RX_RING_FILL_LEVEL,\n\t\t.shadow_reg_support = false,\n\t\t.rri_on_ddr = false,\n\t\t.hw_filter_reset_required = true,\n\t\t.fw_diag_ce_download = false,\n\t\t.credit_size_workaround = false,\n\t\t.tx_stats_over_pktlog = false,\n\t\t.dynamic_sar_support = false,\n\t\t.hw_restart_disconnect = false,\n\t\t.use_fw_tx_credits = true,\n\t\t.delay_unmap_buffer = false,\n\t},\n\t{\n\t\t.id = QCA6174_HW_3_2_VERSION,\n\t\t.dev_id = QCA6174_3_2_DEVICE_ID,\n\t\t.bus = ATH10K_BUS_SDIO,\n\t\t.name = \"qca6174 hw3.2 sdio\",\n\t\t.patch_load_addr = QCA6174_HW_3_0_PATCH_LOAD_ADDR,\n\t\t.uart_pin = 19,\n\t\t.otp_exe_param = 0,\n\t\t.channel_counters_freq_hz = 88000,\n\t\t.max_probe_resp_desc_thres = 0,\n\t\t.cal_data_len = 0,\n\t\t.fw = {\n\t\t\t.dir = QCA6174_HW_3_0_FW_DIR,\n\t\t\t.board = QCA6174_HW_3_0_BOARD_DATA_FILE,\n\t\t\t.board_size = QCA6174_BOARD_DATA_SZ,\n\t\t\t.board_ext_size = QCA6174_BOARD_EXT_DATA_SZ,\n\t\t},\n\t\t.rx_desc_ops = &qca988x_rx_desc_ops,\n\t\t.hw_ops = &qca6174_sdio_ops,\n\t\t.hw_clk = qca6174_clk,\n\t\t.target_cpu_freq = 176000000,\n\t\t.decap_align_bytes = 4,\n\t\t.n_cipher_suites = 8,\n\t\t.num_peers = 10,\n\t\t.ast_skid_limit = 0x10,\n\t\t.num_wds_entries = 0x20,\n\t\t.uart_pin_workaround = true,\n\t\t.tx_stats_over_pktlog = false,\n\t\t.credit_size_workaround = false,\n\t\t.bmi_large_size_download = true,\n\t\t.supports_peer_stats_info = true,\n\t\t.dynamic_sar_support = true,\n\t\t.hw_restart_disconnect = false,\n\t\t.use_fw_tx_credits = true,\n\t\t.delay_unmap_buffer = false,\n\t},\n\t{\n\t\t.id = QCA6174_HW_2_1_VERSION,\n\t\t.dev_id = QCA6164_2_1_DEVICE_ID,\n\t\t.bus = ATH10K_BUS_PCI,\n\t\t.name = \"qca6164 hw2.1\",\n\t\t.patch_load_addr = QCA6174_HW_2_1_PATCH_LOAD_ADDR,\n\t\t.uart_pin = 6,\n\t\t.otp_exe_param = 0,\n\t\t.channel_counters_freq_hz = 88000,\n\t\t.max_probe_resp_desc_thres = 0,\n\t\t.cal_data_len = 8124,\n\t\t.fw = {\n\t\t\t.dir = QCA6174_HW_2_1_FW_DIR,\n\t\t\t.board = QCA6174_HW_2_1_BOARD_DATA_FILE,\n\t\t\t.board_size = QCA6174_BOARD_DATA_SZ,\n\t\t\t.board_ext_size = QCA6174_BOARD_EXT_DATA_SZ,\n\t\t},\n\t\t.rx_desc_ops = &qca988x_rx_desc_ops,\n\t\t.hw_ops = &qca988x_ops,\n\t\t.decap_align_bytes = 4,\n\t\t.spectral_bin_discard = 0,\n\t\t.spectral_bin_offset = 0,\n\t\t.vht160_mcs_rx_highest = 0,\n\t\t.vht160_mcs_tx_highest = 0,\n\t\t.n_cipher_suites = 8,\n\t\t.ast_skid_limit = 0x10,\n\t\t.num_wds_entries = 0x20,\n\t\t.target_64bit = false,\n\t\t.rx_ring_fill_level = HTT_RX_RING_FILL_LEVEL,\n\t\t.shadow_reg_support = false,\n\t\t.rri_on_ddr = false,\n\t\t.hw_filter_reset_required = true,\n\t\t.fw_diag_ce_download = false,\n\t\t.credit_size_workaround = false,\n\t\t.tx_stats_over_pktlog = false,\n\t\t.dynamic_sar_support = false,\n\t\t.hw_restart_disconnect = false,\n\t\t.use_fw_tx_credits = true,\n\t\t.delay_unmap_buffer = false,\n\t},\n\t{\n\t\t.id = QCA6174_HW_2_1_VERSION,\n\t\t.dev_id = QCA6174_2_1_DEVICE_ID,\n\t\t.bus = ATH10K_BUS_PCI,\n\t\t.name = \"qca6174 hw2.1\",\n\t\t.patch_load_addr = QCA6174_HW_2_1_PATCH_LOAD_ADDR,\n\t\t.uart_pin = 6,\n\t\t.otp_exe_param = 0,\n\t\t.channel_counters_freq_hz = 88000,\n\t\t.max_probe_resp_desc_thres = 0,\n\t\t.cal_data_len = 8124,\n\t\t.fw = {\n\t\t\t.dir = QCA6174_HW_2_1_FW_DIR,\n\t\t\t.board = QCA6174_HW_2_1_BOARD_DATA_FILE,\n\t\t\t.board_size = QCA6174_BOARD_DATA_SZ,\n\t\t\t.board_ext_size = QCA6174_BOARD_EXT_DATA_SZ,\n\t\t},\n\t\t.rx_desc_ops = &qca988x_rx_desc_ops,\n\t\t.hw_ops = &qca988x_ops,\n\t\t.decap_align_bytes = 4,\n\t\t.spectral_bin_discard = 0,\n\t\t.spectral_bin_offset = 0,\n\t\t.vht160_mcs_rx_highest = 0,\n\t\t.vht160_mcs_tx_highest = 0,\n\t\t.n_cipher_suites = 8,\n\t\t.ast_skid_limit = 0x10,\n\t\t.num_wds_entries = 0x20,\n\t\t.target_64bit = false,\n\t\t.rx_ring_fill_level = HTT_RX_RING_FILL_LEVEL,\n\t\t.shadow_reg_support = false,\n\t\t.rri_on_ddr = false,\n\t\t.hw_filter_reset_required = true,\n\t\t.fw_diag_ce_download = false,\n\t\t.credit_size_workaround = false,\n\t\t.tx_stats_over_pktlog = false,\n\t\t.dynamic_sar_support = false,\n\t\t.hw_restart_disconnect = false,\n\t\t.use_fw_tx_credits = true,\n\t\t.delay_unmap_buffer = false,\n\t},\n\t{\n\t\t.id = QCA6174_HW_3_0_VERSION,\n\t\t.dev_id = QCA6174_2_1_DEVICE_ID,\n\t\t.bus = ATH10K_BUS_PCI,\n\t\t.name = \"qca6174 hw3.0\",\n\t\t.patch_load_addr = QCA6174_HW_3_0_PATCH_LOAD_ADDR,\n\t\t.uart_pin = 6,\n\t\t.otp_exe_param = 0,\n\t\t.channel_counters_freq_hz = 88000,\n\t\t.max_probe_resp_desc_thres = 0,\n\t\t.cal_data_len = 8124,\n\t\t.fw = {\n\t\t\t.dir = QCA6174_HW_3_0_FW_DIR,\n\t\t\t.board = QCA6174_HW_3_0_BOARD_DATA_FILE,\n\t\t\t.board_size = QCA6174_BOARD_DATA_SZ,\n\t\t\t.board_ext_size = QCA6174_BOARD_EXT_DATA_SZ,\n\t\t},\n\t\t.rx_desc_ops = &qca988x_rx_desc_ops,\n\t\t.hw_ops = &qca988x_ops,\n\t\t.decap_align_bytes = 4,\n\t\t.spectral_bin_discard = 0,\n\t\t.spectral_bin_offset = 0,\n\t\t.vht160_mcs_rx_highest = 0,\n\t\t.vht160_mcs_tx_highest = 0,\n\t\t.n_cipher_suites = 8,\n\t\t.ast_skid_limit = 0x10,\n\t\t.num_wds_entries = 0x20,\n\t\t.target_64bit = false,\n\t\t.rx_ring_fill_level = HTT_RX_RING_FILL_LEVEL,\n\t\t.shadow_reg_support = false,\n\t\t.rri_on_ddr = false,\n\t\t.hw_filter_reset_required = true,\n\t\t.fw_diag_ce_download = false,\n\t\t.credit_size_workaround = false,\n\t\t.tx_stats_over_pktlog = false,\n\t\t.dynamic_sar_support = false,\n\t\t.hw_restart_disconnect = false,\n\t\t.use_fw_tx_credits = true,\n\t\t.delay_unmap_buffer = false,\n\t},\n\t{\n\t\t.id = QCA6174_HW_3_2_VERSION,\n\t\t.dev_id = QCA6174_2_1_DEVICE_ID,\n\t\t.bus = ATH10K_BUS_PCI,\n\t\t.name = \"qca6174 hw3.2\",\n\t\t.patch_load_addr = QCA6174_HW_3_0_PATCH_LOAD_ADDR,\n\t\t.uart_pin = 6,\n\t\t.otp_exe_param = 0,\n\t\t.channel_counters_freq_hz = 88000,\n\t\t.max_probe_resp_desc_thres = 0,\n\t\t.cal_data_len = 8124,\n\t\t.fw = {\n\t\t\t \n\t\t\t.dir = QCA6174_HW_3_0_FW_DIR,\n\t\t\t.board = QCA6174_HW_3_0_BOARD_DATA_FILE,\n\t\t\t.board_size = QCA6174_BOARD_DATA_SZ,\n\t\t\t.board_ext_size = QCA6174_BOARD_EXT_DATA_SZ,\n\t\t},\n\t\t.rx_desc_ops = &qca988x_rx_desc_ops,\n\t\t.hw_ops = &qca6174_ops,\n\t\t.hw_clk = qca6174_clk,\n\t\t.target_cpu_freq = 176000000,\n\t\t.decap_align_bytes = 4,\n\t\t.spectral_bin_discard = 0,\n\t\t.spectral_bin_offset = 0,\n\t\t.vht160_mcs_rx_highest = 0,\n\t\t.vht160_mcs_tx_highest = 0,\n\t\t.n_cipher_suites = 8,\n\t\t.ast_skid_limit = 0x10,\n\t\t.num_wds_entries = 0x20,\n\t\t.target_64bit = false,\n\t\t.rx_ring_fill_level = HTT_RX_RING_FILL_LEVEL,\n\t\t.shadow_reg_support = false,\n\t\t.rri_on_ddr = false,\n\t\t.hw_filter_reset_required = true,\n\t\t.fw_diag_ce_download = true,\n\t\t.credit_size_workaround = false,\n\t\t.tx_stats_over_pktlog = false,\n\t\t.supports_peer_stats_info = true,\n\t\t.dynamic_sar_support = true,\n\t\t.hw_restart_disconnect = false,\n\t\t.use_fw_tx_credits = true,\n\t\t.delay_unmap_buffer = false,\n\t},\n\t{\n\t\t.id = QCA99X0_HW_2_0_DEV_VERSION,\n\t\t.dev_id = QCA99X0_2_0_DEVICE_ID,\n\t\t.bus = ATH10K_BUS_PCI,\n\t\t.name = \"qca99x0 hw2.0\",\n\t\t.patch_load_addr = QCA99X0_HW_2_0_PATCH_LOAD_ADDR,\n\t\t.uart_pin = 7,\n\t\t.otp_exe_param = 0x00000700,\n\t\t.continuous_frag_desc = true,\n\t\t.cck_rate_map_rev2 = true,\n\t\t.channel_counters_freq_hz = 150000,\n\t\t.max_probe_resp_desc_thres = 24,\n\t\t.tx_chain_mask = 0xf,\n\t\t.rx_chain_mask = 0xf,\n\t\t.max_spatial_stream = 4,\n\t\t.cal_data_len = 12064,\n\t\t.fw = {\n\t\t\t.dir = QCA99X0_HW_2_0_FW_DIR,\n\t\t\t.board = QCA99X0_HW_2_0_BOARD_DATA_FILE,\n\t\t\t.board_size = QCA99X0_BOARD_DATA_SZ,\n\t\t\t.board_ext_size = QCA99X0_BOARD_EXT_DATA_SZ,\n\t\t},\n\t\t.sw_decrypt_mcast_mgmt = true,\n\t\t.rx_desc_ops = &qca99x0_rx_desc_ops,\n\t\t.hw_ops = &qca99x0_ops,\n\t\t.decap_align_bytes = 1,\n\t\t.spectral_bin_discard = 4,\n\t\t.spectral_bin_offset = 0,\n\t\t.vht160_mcs_rx_highest = 0,\n\t\t.vht160_mcs_tx_highest = 0,\n\t\t.n_cipher_suites = 11,\n\t\t.ast_skid_limit = 0x10,\n\t\t.num_wds_entries = 0x20,\n\t\t.target_64bit = false,\n\t\t.rx_ring_fill_level = HTT_RX_RING_FILL_LEVEL,\n\t\t.shadow_reg_support = false,\n\t\t.rri_on_ddr = false,\n\t\t.hw_filter_reset_required = true,\n\t\t.fw_diag_ce_download = false,\n\t\t.credit_size_workaround = false,\n\t\t.tx_stats_over_pktlog = false,\n\t\t.dynamic_sar_support = false,\n\t\t.hw_restart_disconnect = false,\n\t\t.use_fw_tx_credits = true,\n\t\t.delay_unmap_buffer = false,\n\t},\n\t{\n\t\t.id = QCA9984_HW_1_0_DEV_VERSION,\n\t\t.dev_id = QCA9984_1_0_DEVICE_ID,\n\t\t.bus = ATH10K_BUS_PCI,\n\t\t.name = \"qca9984/qca9994 hw1.0\",\n\t\t.patch_load_addr = QCA9984_HW_1_0_PATCH_LOAD_ADDR,\n\t\t.uart_pin = 7,\n\t\t.cc_wraparound_type = ATH10K_HW_CC_WRAP_SHIFTED_EACH,\n\t\t.otp_exe_param = 0x00000700,\n\t\t.continuous_frag_desc = true,\n\t\t.cck_rate_map_rev2 = true,\n\t\t.channel_counters_freq_hz = 150000,\n\t\t.max_probe_resp_desc_thres = 24,\n\t\t.tx_chain_mask = 0xf,\n\t\t.rx_chain_mask = 0xf,\n\t\t.max_spatial_stream = 4,\n\t\t.cal_data_len = 12064,\n\t\t.fw = {\n\t\t\t.dir = QCA9984_HW_1_0_FW_DIR,\n\t\t\t.board = QCA9984_HW_1_0_BOARD_DATA_FILE,\n\t\t\t.eboard = QCA9984_HW_1_0_EBOARD_DATA_FILE,\n\t\t\t.board_size = QCA99X0_BOARD_DATA_SZ,\n\t\t\t.board_ext_size = QCA99X0_BOARD_EXT_DATA_SZ,\n\t\t\t.ext_board_size = QCA99X0_EXT_BOARD_DATA_SZ,\n\t\t},\n\t\t.sw_decrypt_mcast_mgmt = true,\n\t\t.rx_desc_ops = &qca99x0_rx_desc_ops,\n\t\t.hw_ops = &qca99x0_ops,\n\t\t.decap_align_bytes = 1,\n\t\t.spectral_bin_discard = 12,\n\t\t.spectral_bin_offset = 8,\n\n\t\t \n\t\t.vht160_mcs_rx_highest = 1560,\n\t\t.vht160_mcs_tx_highest = 1560,\n\t\t.n_cipher_suites = 11,\n\t\t.ast_skid_limit = 0x10,\n\t\t.num_wds_entries = 0x20,\n\t\t.target_64bit = false,\n\t\t.rx_ring_fill_level = HTT_RX_RING_FILL_LEVEL,\n\t\t.shadow_reg_support = false,\n\t\t.rri_on_ddr = false,\n\t\t.hw_filter_reset_required = true,\n\t\t.fw_diag_ce_download = false,\n\t\t.credit_size_workaround = false,\n\t\t.tx_stats_over_pktlog = false,\n\t\t.dynamic_sar_support = false,\n\t\t.hw_restart_disconnect = false,\n\t\t.use_fw_tx_credits = true,\n\t\t.delay_unmap_buffer = false,\n\t},\n\t{\n\t\t.id = QCA9888_HW_2_0_DEV_VERSION,\n\t\t.dev_id = QCA9888_2_0_DEVICE_ID,\n\t\t.bus = ATH10K_BUS_PCI,\n\t\t.name = \"qca9888 hw2.0\",\n\t\t.patch_load_addr = QCA9888_HW_2_0_PATCH_LOAD_ADDR,\n\t\t.uart_pin = 7,\n\t\t.cc_wraparound_type = ATH10K_HW_CC_WRAP_SHIFTED_EACH,\n\t\t.otp_exe_param = 0x00000700,\n\t\t.continuous_frag_desc = true,\n\t\t.channel_counters_freq_hz = 150000,\n\t\t.max_probe_resp_desc_thres = 24,\n\t\t.tx_chain_mask = 3,\n\t\t.rx_chain_mask = 3,\n\t\t.max_spatial_stream = 2,\n\t\t.cal_data_len = 12064,\n\t\t.fw = {\n\t\t\t.dir = QCA9888_HW_2_0_FW_DIR,\n\t\t\t.board = QCA9888_HW_2_0_BOARD_DATA_FILE,\n\t\t\t.board_size = QCA99X0_BOARD_DATA_SZ,\n\t\t\t.board_ext_size = QCA99X0_BOARD_EXT_DATA_SZ,\n\t\t},\n\t\t.sw_decrypt_mcast_mgmt = true,\n\t\t.rx_desc_ops = &qca99x0_rx_desc_ops,\n\t\t.hw_ops = &qca99x0_ops,\n\t\t.decap_align_bytes = 1,\n\t\t.spectral_bin_discard = 12,\n\t\t.spectral_bin_offset = 8,\n\n\t\t \n\t\t.vht160_mcs_rx_highest = 780,\n\t\t.vht160_mcs_tx_highest = 780,\n\t\t.n_cipher_suites = 11,\n\t\t.ast_skid_limit = 0x10,\n\t\t.num_wds_entries = 0x20,\n\t\t.target_64bit = false,\n\t\t.rx_ring_fill_level = HTT_RX_RING_FILL_LEVEL,\n\t\t.shadow_reg_support = false,\n\t\t.rri_on_ddr = false,\n\t\t.hw_filter_reset_required = true,\n\t\t.fw_diag_ce_download = false,\n\t\t.credit_size_workaround = false,\n\t\t.tx_stats_over_pktlog = false,\n\t\t.dynamic_sar_support = false,\n\t\t.hw_restart_disconnect = false,\n\t\t.use_fw_tx_credits = true,\n\t\t.delay_unmap_buffer = false,\n\t},\n\t{\n\t\t.id = QCA9377_HW_1_0_DEV_VERSION,\n\t\t.dev_id = QCA9377_1_0_DEVICE_ID,\n\t\t.bus = ATH10K_BUS_PCI,\n\t\t.name = \"qca9377 hw1.0\",\n\t\t.patch_load_addr = QCA9377_HW_1_0_PATCH_LOAD_ADDR,\n\t\t.uart_pin = 6,\n\t\t.otp_exe_param = 0,\n\t\t.channel_counters_freq_hz = 88000,\n\t\t.max_probe_resp_desc_thres = 0,\n\t\t.cal_data_len = 8124,\n\t\t.fw = {\n\t\t\t.dir = QCA9377_HW_1_0_FW_DIR,\n\t\t\t.board = QCA9377_HW_1_0_BOARD_DATA_FILE,\n\t\t\t.board_size = QCA9377_BOARD_DATA_SZ,\n\t\t\t.board_ext_size = QCA9377_BOARD_EXT_DATA_SZ,\n\t\t},\n\t\t.rx_desc_ops = &qca988x_rx_desc_ops,\n\t\t.hw_ops = &qca988x_ops,\n\t\t.decap_align_bytes = 4,\n\t\t.spectral_bin_discard = 0,\n\t\t.spectral_bin_offset = 0,\n\t\t.vht160_mcs_rx_highest = 0,\n\t\t.vht160_mcs_tx_highest = 0,\n\t\t.n_cipher_suites = 8,\n\t\t.ast_skid_limit = 0x10,\n\t\t.num_wds_entries = 0x20,\n\t\t.target_64bit = false,\n\t\t.rx_ring_fill_level = HTT_RX_RING_FILL_LEVEL,\n\t\t.shadow_reg_support = false,\n\t\t.rri_on_ddr = false,\n\t\t.hw_filter_reset_required = true,\n\t\t.fw_diag_ce_download = false,\n\t\t.credit_size_workaround = false,\n\t\t.tx_stats_over_pktlog = false,\n\t\t.dynamic_sar_support = false,\n\t\t.hw_restart_disconnect = false,\n\t\t.use_fw_tx_credits = true,\n\t\t.delay_unmap_buffer = false,\n\t},\n\t{\n\t\t.id = QCA9377_HW_1_1_DEV_VERSION,\n\t\t.dev_id = QCA9377_1_0_DEVICE_ID,\n\t\t.bus = ATH10K_BUS_PCI,\n\t\t.name = \"qca9377 hw1.1\",\n\t\t.patch_load_addr = QCA9377_HW_1_0_PATCH_LOAD_ADDR,\n\t\t.uart_pin = 6,\n\t\t.otp_exe_param = 0,\n\t\t.channel_counters_freq_hz = 88000,\n\t\t.max_probe_resp_desc_thres = 0,\n\t\t.cal_data_len = 8124,\n\t\t.fw = {\n\t\t\t.dir = QCA9377_HW_1_0_FW_DIR,\n\t\t\t.board = QCA9377_HW_1_0_BOARD_DATA_FILE,\n\t\t\t.board_size = QCA9377_BOARD_DATA_SZ,\n\t\t\t.board_ext_size = QCA9377_BOARD_EXT_DATA_SZ,\n\t\t},\n\t\t.rx_desc_ops = &qca988x_rx_desc_ops,\n\t\t.hw_ops = &qca6174_ops,\n\t\t.hw_clk = qca6174_clk,\n\t\t.target_cpu_freq = 176000000,\n\t\t.decap_align_bytes = 4,\n\t\t.spectral_bin_discard = 0,\n\t\t.spectral_bin_offset = 0,\n\t\t.vht160_mcs_rx_highest = 0,\n\t\t.vht160_mcs_tx_highest = 0,\n\t\t.n_cipher_suites = 8,\n\t\t.ast_skid_limit = 0x10,\n\t\t.num_wds_entries = 0x20,\n\t\t.target_64bit = false,\n\t\t.rx_ring_fill_level = HTT_RX_RING_FILL_LEVEL,\n\t\t.shadow_reg_support = false,\n\t\t.rri_on_ddr = false,\n\t\t.hw_filter_reset_required = true,\n\t\t.fw_diag_ce_download = true,\n\t\t.credit_size_workaround = false,\n\t\t.tx_stats_over_pktlog = false,\n\t\t.dynamic_sar_support = false,\n\t\t.hw_restart_disconnect = false,\n\t\t.use_fw_tx_credits = true,\n\t\t.delay_unmap_buffer = false,\n\t},\n\t{\n\t\t.id = QCA9377_HW_1_1_DEV_VERSION,\n\t\t.dev_id = QCA9377_1_0_DEVICE_ID,\n\t\t.bus = ATH10K_BUS_SDIO,\n\t\t.name = \"qca9377 hw1.1 sdio\",\n\t\t.patch_load_addr = QCA9377_HW_1_0_PATCH_LOAD_ADDR,\n\t\t.uart_pin = 19,\n\t\t.otp_exe_param = 0,\n\t\t.channel_counters_freq_hz = 88000,\n\t\t.max_probe_resp_desc_thres = 0,\n\t\t.cal_data_len = 8124,\n\t\t.fw = {\n\t\t\t.dir = QCA9377_HW_1_0_FW_DIR,\n\t\t\t.board = QCA9377_HW_1_0_BOARD_DATA_FILE,\n\t\t\t.board_size = QCA9377_BOARD_DATA_SZ,\n\t\t\t.board_ext_size = QCA9377_BOARD_EXT_DATA_SZ,\n\t\t},\n\t\t.rx_desc_ops = &qca988x_rx_desc_ops,\n\t\t.hw_ops = &qca6174_ops,\n\t\t.hw_clk = qca6174_clk,\n\t\t.target_cpu_freq = 176000000,\n\t\t.decap_align_bytes = 4,\n\t\t.n_cipher_suites = 8,\n\t\t.num_peers = TARGET_QCA9377_HL_NUM_PEERS,\n\t\t.ast_skid_limit = 0x10,\n\t\t.num_wds_entries = 0x20,\n\t\t.uart_pin_workaround = true,\n\t\t.credit_size_workaround = true,\n\t\t.dynamic_sar_support = false,\n\t\t.hw_restart_disconnect = false,\n\t\t.use_fw_tx_credits = true,\n\t\t.delay_unmap_buffer = false,\n\t},\n\t{\n\t\t.id = QCA4019_HW_1_0_DEV_VERSION,\n\t\t.dev_id = 0,\n\t\t.bus = ATH10K_BUS_AHB,\n\t\t.name = \"qca4019 hw1.0\",\n\t\t.patch_load_addr = QCA4019_HW_1_0_PATCH_LOAD_ADDR,\n\t\t.uart_pin = 7,\n\t\t.cc_wraparound_type = ATH10K_HW_CC_WRAP_SHIFTED_EACH,\n\t\t.otp_exe_param = 0x0010000,\n\t\t.continuous_frag_desc = true,\n\t\t.cck_rate_map_rev2 = true,\n\t\t.channel_counters_freq_hz = 125000,\n\t\t.max_probe_resp_desc_thres = 24,\n\t\t.tx_chain_mask = 0x3,\n\t\t.rx_chain_mask = 0x3,\n\t\t.max_spatial_stream = 2,\n\t\t.cal_data_len = 12064,\n\t\t.fw = {\n\t\t\t.dir = QCA4019_HW_1_0_FW_DIR,\n\t\t\t.board = QCA4019_HW_1_0_BOARD_DATA_FILE,\n\t\t\t.board_size = QCA4019_BOARD_DATA_SZ,\n\t\t\t.board_ext_size = QCA4019_BOARD_EXT_DATA_SZ,\n\t\t},\n\t\t.sw_decrypt_mcast_mgmt = true,\n\t\t.rx_desc_ops = &qca99x0_rx_desc_ops,\n\t\t.hw_ops = &qca99x0_ops,\n\t\t.decap_align_bytes = 1,\n\t\t.spectral_bin_discard = 4,\n\t\t.spectral_bin_offset = 0,\n\t\t.vht160_mcs_rx_highest = 0,\n\t\t.vht160_mcs_tx_highest = 0,\n\t\t.n_cipher_suites = 11,\n\t\t.ast_skid_limit = 0x10,\n\t\t.num_wds_entries = 0x20,\n\t\t.target_64bit = false,\n\t\t.rx_ring_fill_level = HTT_RX_RING_FILL_LEVEL,\n\t\t.shadow_reg_support = false,\n\t\t.rri_on_ddr = false,\n\t\t.hw_filter_reset_required = true,\n\t\t.fw_diag_ce_download = false,\n\t\t.credit_size_workaround = false,\n\t\t.tx_stats_over_pktlog = false,\n\t\t.dynamic_sar_support = false,\n\t\t.hw_restart_disconnect = false,\n\t\t.use_fw_tx_credits = true,\n\t\t.delay_unmap_buffer = false,\n\t},\n\t{\n\t\t.id = WCN3990_HW_1_0_DEV_VERSION,\n\t\t.dev_id = 0,\n\t\t.bus = ATH10K_BUS_SNOC,\n\t\t.name = \"wcn3990 hw1.0\",\n\t\t.continuous_frag_desc = true,\n\t\t.tx_chain_mask = 0x7,\n\t\t.rx_chain_mask = 0x7,\n\t\t.max_spatial_stream = 4,\n\t\t.fw = {\n\t\t\t.dir = WCN3990_HW_1_0_FW_DIR,\n\t\t},\n\t\t.sw_decrypt_mcast_mgmt = true,\n\t\t.rx_desc_ops = &wcn3990_rx_desc_ops,\n\t\t.hw_ops = &wcn3990_ops,\n\t\t.decap_align_bytes = 1,\n\t\t.num_peers = TARGET_HL_TLV_NUM_PEERS,\n\t\t.n_cipher_suites = 11,\n\t\t.ast_skid_limit = TARGET_HL_TLV_AST_SKID_LIMIT,\n\t\t.num_wds_entries = TARGET_HL_TLV_NUM_WDS_ENTRIES,\n\t\t.target_64bit = true,\n\t\t.rx_ring_fill_level = HTT_RX_RING_FILL_LEVEL_DUAL_MAC,\n\t\t.shadow_reg_support = true,\n\t\t.rri_on_ddr = true,\n\t\t.hw_filter_reset_required = false,\n\t\t.fw_diag_ce_download = false,\n\t\t.credit_size_workaround = false,\n\t\t.tx_stats_over_pktlog = false,\n\t\t.dynamic_sar_support = true,\n\t\t.hw_restart_disconnect = true,\n\t\t.use_fw_tx_credits = false,\n\t\t.delay_unmap_buffer = true,\n\t},\n};\n\nstatic const char *const ath10k_core_fw_feature_str[] = {\n\t[ATH10K_FW_FEATURE_EXT_WMI_MGMT_RX] = \"wmi-mgmt-rx\",\n\t[ATH10K_FW_FEATURE_WMI_10X] = \"wmi-10.x\",\n\t[ATH10K_FW_FEATURE_HAS_WMI_MGMT_TX] = \"has-wmi-mgmt-tx\",\n\t[ATH10K_FW_FEATURE_NO_P2P] = \"no-p2p\",\n\t[ATH10K_FW_FEATURE_WMI_10_2] = \"wmi-10.2\",\n\t[ATH10K_FW_FEATURE_MULTI_VIF_PS_SUPPORT] = \"multi-vif-ps\",\n\t[ATH10K_FW_FEATURE_WOWLAN_SUPPORT] = \"wowlan\",\n\t[ATH10K_FW_FEATURE_IGNORE_OTP_RESULT] = \"ignore-otp\",\n\t[ATH10K_FW_FEATURE_NO_NWIFI_DECAP_4ADDR_PADDING] = \"no-4addr-pad\",\n\t[ATH10K_FW_FEATURE_SUPPORTS_SKIP_CLOCK_INIT] = \"skip-clock-init\",\n\t[ATH10K_FW_FEATURE_RAW_MODE_SUPPORT] = \"raw-mode\",\n\t[ATH10K_FW_FEATURE_SUPPORTS_ADAPTIVE_CCA] = \"adaptive-cca\",\n\t[ATH10K_FW_FEATURE_MFP_SUPPORT] = \"mfp\",\n\t[ATH10K_FW_FEATURE_PEER_FLOW_CONTROL] = \"peer-flow-ctrl\",\n\t[ATH10K_FW_FEATURE_BTCOEX_PARAM] = \"btcoex-param\",\n\t[ATH10K_FW_FEATURE_SKIP_NULL_FUNC_WAR] = \"skip-null-func-war\",\n\t[ATH10K_FW_FEATURE_ALLOWS_MESH_BCAST] = \"allows-mesh-bcast\",\n\t[ATH10K_FW_FEATURE_NO_PS] = \"no-ps\",\n\t[ATH10K_FW_FEATURE_MGMT_TX_BY_REF] = \"mgmt-tx-by-reference\",\n\t[ATH10K_FW_FEATURE_NON_BMI] = \"non-bmi\",\n\t[ATH10K_FW_FEATURE_SINGLE_CHAN_INFO_PER_CHANNEL] = \"single-chan-info-per-channel\",\n\t[ATH10K_FW_FEATURE_PEER_FIXED_RATE] = \"peer-fixed-rate\",\n\t[ATH10K_FW_FEATURE_IRAM_RECOVERY] = \"iram-recovery\",\n};\n\nstatic unsigned int ath10k_core_get_fw_feature_str(char *buf,\n\t\t\t\t\t\t   size_t buf_len,\n\t\t\t\t\t\t   enum ath10k_fw_features feat)\n{\n\t \n\tBUILD_BUG_ON(ARRAY_SIZE(ath10k_core_fw_feature_str) !=\n\t\t     ATH10K_FW_FEATURE_COUNT);\n\n\tif (feat >= ARRAY_SIZE(ath10k_core_fw_feature_str) ||\n\t    WARN_ON(!ath10k_core_fw_feature_str[feat])) {\n\t\treturn scnprintf(buf, buf_len, \"bit%d\", feat);\n\t}\n\n\treturn scnprintf(buf, buf_len, \"%s\", ath10k_core_fw_feature_str[feat]);\n}\n\nvoid ath10k_core_get_fw_features_str(struct ath10k *ar,\n\t\t\t\t     char *buf,\n\t\t\t\t     size_t buf_len)\n{\n\tsize_t len = 0;\n\tint i;\n\n\tfor (i = 0; i < ATH10K_FW_FEATURE_COUNT; i++) {\n\t\tif (test_bit(i, ar->normal_mode_fw.fw_file.fw_features)) {\n\t\t\tif (len > 0)\n\t\t\t\tlen += scnprintf(buf + len, buf_len - len, \",\");\n\n\t\t\tlen += ath10k_core_get_fw_feature_str(buf + len,\n\t\t\t\t\t\t\t      buf_len - len,\n\t\t\t\t\t\t\t      i);\n\t\t}\n\t}\n}\n\nstatic void ath10k_send_suspend_complete(struct ath10k *ar)\n{\n\tath10k_dbg(ar, ATH10K_DBG_BOOT, \"boot suspend complete\\n\");\n\n\tcomplete(&ar->target_suspend);\n}\n\nstatic int ath10k_init_sdio(struct ath10k *ar, enum ath10k_firmware_mode mode)\n{\n\tbool mtu_workaround = ar->hw_params.credit_size_workaround;\n\tint ret;\n\tu32 param = 0;\n\n\tret = ath10k_bmi_write32(ar, hi_mbox_io_block_sz, 256);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ath10k_bmi_write32(ar, hi_mbox_isr_yield_limit, 99);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ath10k_bmi_read32(ar, hi_acs_flags, &param);\n\tif (ret)\n\t\treturn ret;\n\n\tparam |= HI_ACS_FLAGS_SDIO_REDUCE_TX_COMPL_SET;\n\n\tif (mode == ATH10K_FIRMWARE_MODE_NORMAL && !mtu_workaround)\n\t\tparam |= HI_ACS_FLAGS_ALT_DATA_CREDIT_SIZE;\n\telse\n\t\tparam &= ~HI_ACS_FLAGS_ALT_DATA_CREDIT_SIZE;\n\n\tif (mode == ATH10K_FIRMWARE_MODE_UTF)\n\t\tparam &= ~HI_ACS_FLAGS_SDIO_SWAP_MAILBOX_SET;\n\telse\n\t\tparam |= HI_ACS_FLAGS_SDIO_SWAP_MAILBOX_SET;\n\n\tret = ath10k_bmi_write32(ar, hi_acs_flags, param);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ath10k_bmi_read32(ar, hi_option_flag2, &param);\n\tif (ret)\n\t\treturn ret;\n\n\tparam |= HI_OPTION_SDIO_CRASH_DUMP_ENHANCEMENT_HOST;\n\n\tret = ath10k_bmi_write32(ar, hi_option_flag2, param);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int ath10k_init_configure_target(struct ath10k *ar)\n{\n\tu32 param_host;\n\tint ret;\n\n\t \n\tret = ath10k_bmi_write32(ar, hi_app_host_interest,\n\t\t\t\t HTC_PROTOCOL_VERSION);\n\tif (ret) {\n\t\tath10k_err(ar, \"settings HTC version failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = ath10k_bmi_read32(ar, hi_option_flag, &param_host);\n\tif (ret) {\n\t\tath10k_err(ar, \"setting firmware mode (1/2) failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\t \n\tparam_host |= (1 << HI_OPTION_NUM_DEV_SHIFT);\n\t \n\t \n\tparam_host |= (HI_OPTION_FW_MODE_AP << HI_OPTION_FW_MODE_SHIFT);\n\t \n\tparam_host |= (1 << HI_OPTION_MAC_ADDR_METHOD_SHIFT);\n\t \n\tparam_host |= (0 << HI_OPTION_FW_BRIDGE_SHIFT);\n\t \n\tparam_host |= (0 << HI_OPTION_FW_SUBMODE_SHIFT);\n\n\tret = ath10k_bmi_write32(ar, hi_option_flag, param_host);\n\tif (ret) {\n\t\tath10k_err(ar, \"setting firmware mode (2/2) failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = ath10k_bmi_write32(ar, hi_be, 0);\n\tif (ret) {\n\t\tath10k_err(ar, \"setting host CPU BE mode failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = ath10k_bmi_write32(ar, hi_fw_swap, 0);\n\n\tif (ret) {\n\t\tath10k_err(ar, \"setting FW data/desc swap flags failed\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = ath10k_bmi_write32(ar, hi_hci_uart_pwr_mgmt_params_ext,\n\t\t\t\t ar->dev_id);\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to set pwr_mgmt_params: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct firmware *ath10k_fetch_fw_file(struct ath10k *ar,\n\t\t\t\t\t\t   const char *dir,\n\t\t\t\t\t\t   const char *file)\n{\n\tchar filename[100];\n\tconst struct firmware *fw;\n\tint ret;\n\n\tif (file == NULL)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tif (dir == NULL)\n\t\tdir = \".\";\n\n\tsnprintf(filename, sizeof(filename), \"%s/%s\", dir, file);\n\tret = firmware_request_nowarn(&fw, filename, ar->dev);\n\tath10k_dbg(ar, ATH10K_DBG_BOOT, \"boot fw request '%s': %d\\n\",\n\t\t   filename, ret);\n\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn fw;\n}\n\nstatic int ath10k_push_board_ext_data(struct ath10k *ar, const void *data,\n\t\t\t\t      size_t data_len)\n{\n\tu32 board_data_size = ar->hw_params.fw.board_size;\n\tu32 board_ext_data_size = ar->hw_params.fw.board_ext_size;\n\tu32 board_ext_data_addr;\n\tint ret;\n\n\tret = ath10k_bmi_read32(ar, hi_board_ext_data, &board_ext_data_addr);\n\tif (ret) {\n\t\tath10k_err(ar, \"could not read board ext data addr (%d)\\n\",\n\t\t\t   ret);\n\t\treturn ret;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t   \"boot push board extended data addr 0x%x\\n\",\n\t\t   board_ext_data_addr);\n\n\tif (board_ext_data_addr == 0)\n\t\treturn 0;\n\n\tif (data_len != (board_data_size + board_ext_data_size)) {\n\t\tath10k_err(ar, \"invalid board (ext) data sizes %zu != %d+%d\\n\",\n\t\t\t   data_len, board_data_size, board_ext_data_size);\n\t\treturn -EINVAL;\n\t}\n\n\tret = ath10k_bmi_write_memory(ar, board_ext_data_addr,\n\t\t\t\t      data + board_data_size,\n\t\t\t\t      board_ext_data_size);\n\tif (ret) {\n\t\tath10k_err(ar, \"could not write board ext data (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ath10k_bmi_write32(ar, hi_board_ext_data_config,\n\t\t\t\t (board_ext_data_size << 16) | 1);\n\tif (ret) {\n\t\tath10k_err(ar, \"could not write board ext data bit (%d)\\n\",\n\t\t\t   ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_core_get_board_id_from_otp(struct ath10k *ar)\n{\n\tu32 result, address;\n\tu8 board_id, chip_id;\n\tbool ext_bid_support;\n\tint ret, bmi_board_id_param;\n\n\taddress = ar->hw_params.patch_load_addr;\n\n\tif (!ar->normal_mode_fw.fw_file.otp_data ||\n\t    !ar->normal_mode_fw.fw_file.otp_len) {\n\t\tath10k_warn(ar,\n\t\t\t    \"failed to retrieve board id because of invalid otp\\n\");\n\t\treturn -ENODATA;\n\t}\n\n\tif (ar->id.bmi_ids_valid) {\n\t\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t\t   \"boot already acquired valid otp board id,skip download, board_id %d chip_id %d\\n\",\n\t\t\t   ar->id.bmi_board_id, ar->id.bmi_chip_id);\n\t\tgoto skip_otp_download;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t   \"boot upload otp to 0x%x len %zd for board id\\n\",\n\t\t   address, ar->normal_mode_fw.fw_file.otp_len);\n\n\tret = ath10k_bmi_fast_download(ar, address,\n\t\t\t\t       ar->normal_mode_fw.fw_file.otp_data,\n\t\t\t\t       ar->normal_mode_fw.fw_file.otp_len);\n\tif (ret) {\n\t\tath10k_err(ar, \"could not write otp for board id check: %d\\n\",\n\t\t\t   ret);\n\t\treturn ret;\n\t}\n\n\tif (ar->cal_mode == ATH10K_PRE_CAL_MODE_DT ||\n\t    ar->cal_mode == ATH10K_PRE_CAL_MODE_FILE ||\n\t    ar->cal_mode == ATH10K_PRE_CAL_MODE_NVMEM)\n\t\tbmi_board_id_param = BMI_PARAM_GET_FLASH_BOARD_ID;\n\telse\n\t\tbmi_board_id_param = BMI_PARAM_GET_EEPROM_BOARD_ID;\n\n\tret = ath10k_bmi_execute(ar, address, bmi_board_id_param, &result);\n\tif (ret) {\n\t\tath10k_err(ar, \"could not execute otp for board id check: %d\\n\",\n\t\t\t   ret);\n\t\treturn ret;\n\t}\n\n\tboard_id = MS(result, ATH10K_BMI_BOARD_ID_FROM_OTP);\n\tchip_id = MS(result, ATH10K_BMI_CHIP_ID_FROM_OTP);\n\text_bid_support = (result & ATH10K_BMI_EXT_BOARD_ID_SUPPORT);\n\n\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t   \"boot get otp board id result 0x%08x board_id %d chip_id %d ext_bid_support %d\\n\",\n\t\t   result, board_id, chip_id, ext_bid_support);\n\n\tar->id.ext_bid_supported = ext_bid_support;\n\n\tif ((result & ATH10K_BMI_BOARD_ID_STATUS_MASK) != 0 ||\n\t    (board_id == 0)) {\n\t\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t\t   \"board id does not exist in otp, ignore it\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tar->id.bmi_ids_valid = true;\n\tar->id.bmi_board_id = board_id;\n\tar->id.bmi_chip_id = chip_id;\n\nskip_otp_download:\n\n\treturn 0;\n}\n\nstatic void ath10k_core_check_bdfext(const struct dmi_header *hdr, void *data)\n{\n\tstruct ath10k *ar = data;\n\tconst char *bdf_ext;\n\tconst char *magic = ATH10K_SMBIOS_BDF_EXT_MAGIC;\n\tu8 bdf_enabled;\n\tint i;\n\n\tif (hdr->type != ATH10K_SMBIOS_BDF_EXT_TYPE)\n\t\treturn;\n\n\tif (hdr->length != ATH10K_SMBIOS_BDF_EXT_LENGTH) {\n\t\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t\t   \"wrong smbios bdf ext type length (%d).\\n\",\n\t\t\t   hdr->length);\n\t\treturn;\n\t}\n\n\tbdf_enabled = *((u8 *)hdr + ATH10K_SMBIOS_BDF_EXT_OFFSET);\n\tif (!bdf_enabled) {\n\t\tath10k_dbg(ar, ATH10K_DBG_BOOT, \"bdf variant name not found.\\n\");\n\t\treturn;\n\t}\n\n\t \n\tbdf_ext = (char *)hdr + hdr->length;\n\n\tif (memcmp(bdf_ext, magic, strlen(magic)) != 0) {\n\t\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t\t   \"bdf variant magic does not match.\\n\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < strlen(bdf_ext); i++) {\n\t\tif (!isascii(bdf_ext[i]) || !isprint(bdf_ext[i])) {\n\t\t\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t\t\t   \"bdf variant name contains non ascii chars.\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tif (strscpy(ar->id.bdf_ext, bdf_ext + strlen(magic),\n\t\t    sizeof(ar->id.bdf_ext)) < 0) {\n\t\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t\t   \"bdf variant string is longer than the buffer can accommodate (variant: %s)\\n\",\n\t\t\t    bdf_ext);\n\t\treturn;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t   \"found and validated bdf variant smbios_type 0x%x bdf %s\\n\",\n\t\t   ATH10K_SMBIOS_BDF_EXT_TYPE, bdf_ext);\n}\n\nstatic int ath10k_core_check_smbios(struct ath10k *ar)\n{\n\tar->id.bdf_ext[0] = '\\0';\n\tdmi_walk(ath10k_core_check_bdfext, ar);\n\n\tif (ar->id.bdf_ext[0] == '\\0')\n\t\treturn -ENODATA;\n\n\treturn 0;\n}\n\nint ath10k_core_check_dt(struct ath10k *ar)\n{\n\tstruct device_node *node;\n\tconst char *variant = NULL;\n\n\tnode = ar->dev->of_node;\n\tif (!node)\n\t\treturn -ENOENT;\n\n\tof_property_read_string(node, \"qcom,ath10k-calibration-variant\",\n\t\t\t\t&variant);\n\tif (!variant)\n\t\treturn -ENODATA;\n\n\tif (strscpy(ar->id.bdf_ext, variant, sizeof(ar->id.bdf_ext)) < 0)\n\t\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t\t   \"bdf variant string is longer than the buffer can accommodate (variant: %s)\\n\",\n\t\t\t    variant);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ath10k_core_check_dt);\n\nstatic int ath10k_download_fw(struct ath10k *ar)\n{\n\tu32 address, data_len;\n\tconst void *data;\n\tint ret;\n\tstruct pm_qos_request latency_qos;\n\n\taddress = ar->hw_params.patch_load_addr;\n\n\tdata = ar->running_fw->fw_file.firmware_data;\n\tdata_len = ar->running_fw->fw_file.firmware_len;\n\n\tret = ath10k_swap_code_seg_configure(ar, &ar->running_fw->fw_file);\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to configure fw code swap: %d\\n\",\n\t\t\t   ret);\n\t\treturn ret;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t   \"boot uploading firmware image %pK len %d\\n\",\n\t\t   data, data_len);\n\n\t \n\tif (ar->hw_params.fw_diag_ce_download) {\n\t\tret = ath10k_hw_diag_fast_download(ar, address,\n\t\t\t\t\t\t   data, data_len);\n\t\tif (ret == 0)\n\t\t\t \n\t\t\treturn 0;\n\n\t\tath10k_warn(ar,\n\t\t\t    \"failed to upload firmware via diag ce, trying BMI: %d\",\n\t\t\t    ret);\n\t}\n\n\tmemset(&latency_qos, 0, sizeof(latency_qos));\n\tcpu_latency_qos_add_request(&latency_qos, 0);\n\n\tret = ath10k_bmi_fast_download(ar, address, data, data_len);\n\n\tcpu_latency_qos_remove_request(&latency_qos);\n\n\treturn ret;\n}\n\nvoid ath10k_core_free_board_files(struct ath10k *ar)\n{\n\tif (!IS_ERR(ar->normal_mode_fw.board))\n\t\trelease_firmware(ar->normal_mode_fw.board);\n\n\tif (!IS_ERR(ar->normal_mode_fw.ext_board))\n\t\trelease_firmware(ar->normal_mode_fw.ext_board);\n\n\tar->normal_mode_fw.board = NULL;\n\tar->normal_mode_fw.board_data = NULL;\n\tar->normal_mode_fw.board_len = 0;\n\tar->normal_mode_fw.ext_board = NULL;\n\tar->normal_mode_fw.ext_board_data = NULL;\n\tar->normal_mode_fw.ext_board_len = 0;\n}\nEXPORT_SYMBOL(ath10k_core_free_board_files);\n\nstatic void ath10k_core_free_firmware_files(struct ath10k *ar)\n{\n\tif (!IS_ERR(ar->normal_mode_fw.fw_file.firmware))\n\t\trelease_firmware(ar->normal_mode_fw.fw_file.firmware);\n\n\tif (!IS_ERR(ar->cal_file))\n\t\trelease_firmware(ar->cal_file);\n\n\tif (!IS_ERR(ar->pre_cal_file))\n\t\trelease_firmware(ar->pre_cal_file);\n\n\tath10k_swap_code_seg_release(ar, &ar->normal_mode_fw.fw_file);\n\n\tar->normal_mode_fw.fw_file.otp_data = NULL;\n\tar->normal_mode_fw.fw_file.otp_len = 0;\n\n\tar->normal_mode_fw.fw_file.firmware = NULL;\n\tar->normal_mode_fw.fw_file.firmware_data = NULL;\n\tar->normal_mode_fw.fw_file.firmware_len = 0;\n\n\tar->cal_file = NULL;\n\tar->pre_cal_file = NULL;\n}\n\nstatic int ath10k_fetch_cal_file(struct ath10k *ar)\n{\n\tchar filename[100];\n\n\t \n\tscnprintf(filename, sizeof(filename), \"pre-cal-%s-%s.bin\",\n\t\t  ath10k_bus_str(ar->hif.bus), dev_name(ar->dev));\n\n\tar->pre_cal_file = ath10k_fetch_fw_file(ar, ATH10K_FW_DIR, filename);\n\tif (!IS_ERR(ar->pre_cal_file))\n\t\tgoto success;\n\n\t \n\tscnprintf(filename, sizeof(filename), \"cal-%s-%s.bin\",\n\t\t  ath10k_bus_str(ar->hif.bus), dev_name(ar->dev));\n\n\tar->cal_file = ath10k_fetch_fw_file(ar, ATH10K_FW_DIR, filename);\n\tif (IS_ERR(ar->cal_file))\n\t\t \n\t\treturn PTR_ERR(ar->cal_file);\nsuccess:\n\tath10k_dbg(ar, ATH10K_DBG_BOOT, \"found calibration file %s/%s\\n\",\n\t\t   ATH10K_FW_DIR, filename);\n\n\treturn 0;\n}\n\nstatic int ath10k_core_fetch_board_data_api_1(struct ath10k *ar, int bd_ie_type)\n{\n\tconst struct firmware *fw;\n\tchar boardname[100];\n\n\tif (bd_ie_type == ATH10K_BD_IE_BOARD) {\n\t\tif (!ar->hw_params.fw.board) {\n\t\t\tath10k_err(ar, \"failed to find board file fw entry\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tscnprintf(boardname, sizeof(boardname), \"board-%s-%s.bin\",\n\t\t\t  ath10k_bus_str(ar->hif.bus), dev_name(ar->dev));\n\n\t\tar->normal_mode_fw.board = ath10k_fetch_fw_file(ar,\n\t\t\t\t\t\t\t\tar->hw_params.fw.dir,\n\t\t\t\t\t\t\t\tboardname);\n\t\tif (IS_ERR(ar->normal_mode_fw.board)) {\n\t\t\tfw = ath10k_fetch_fw_file(ar,\n\t\t\t\t\t\t  ar->hw_params.fw.dir,\n\t\t\t\t\t\t  ar->hw_params.fw.board);\n\t\t\tar->normal_mode_fw.board = fw;\n\t\t}\n\n\t\tif (IS_ERR(ar->normal_mode_fw.board))\n\t\t\treturn PTR_ERR(ar->normal_mode_fw.board);\n\n\t\tar->normal_mode_fw.board_data = ar->normal_mode_fw.board->data;\n\t\tar->normal_mode_fw.board_len = ar->normal_mode_fw.board->size;\n\t} else if (bd_ie_type == ATH10K_BD_IE_BOARD_EXT) {\n\t\tif (!ar->hw_params.fw.eboard) {\n\t\t\tath10k_err(ar, \"failed to find eboard file fw entry\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfw = ath10k_fetch_fw_file(ar, ar->hw_params.fw.dir,\n\t\t\t\t\t  ar->hw_params.fw.eboard);\n\t\tar->normal_mode_fw.ext_board = fw;\n\t\tif (IS_ERR(ar->normal_mode_fw.ext_board))\n\t\t\treturn PTR_ERR(ar->normal_mode_fw.ext_board);\n\n\t\tar->normal_mode_fw.ext_board_data = ar->normal_mode_fw.ext_board->data;\n\t\tar->normal_mode_fw.ext_board_len = ar->normal_mode_fw.ext_board->size;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_core_parse_bd_ie_board(struct ath10k *ar,\n\t\t\t\t\t const void *buf, size_t buf_len,\n\t\t\t\t\t const char *boardname,\n\t\t\t\t\t int bd_ie_type)\n{\n\tconst struct ath10k_fw_ie *hdr;\n\tbool name_match_found;\n\tint ret, board_ie_id;\n\tsize_t board_ie_len;\n\tconst void *board_ie_data;\n\n\tname_match_found = false;\n\n\t \n\twhile (buf_len > sizeof(struct ath10k_fw_ie)) {\n\t\thdr = buf;\n\t\tboard_ie_id = le32_to_cpu(hdr->id);\n\t\tboard_ie_len = le32_to_cpu(hdr->len);\n\t\tboard_ie_data = hdr->data;\n\n\t\tbuf_len -= sizeof(*hdr);\n\t\tbuf += sizeof(*hdr);\n\n\t\tif (buf_len < ALIGN(board_ie_len, 4)) {\n\t\t\tath10k_err(ar, \"invalid ATH10K_BD_IE_BOARD length: %zu < %zu\\n\",\n\t\t\t\t   buf_len, ALIGN(board_ie_len, 4));\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tswitch (board_ie_id) {\n\t\tcase ATH10K_BD_IE_BOARD_NAME:\n\t\t\tath10k_dbg_dump(ar, ATH10K_DBG_BOOT, \"board name\", \"\",\n\t\t\t\t\tboard_ie_data, board_ie_len);\n\n\t\t\tif (board_ie_len != strlen(boardname))\n\t\t\t\tbreak;\n\n\t\t\tret = memcmp(board_ie_data, boardname, strlen(boardname));\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\tname_match_found = true;\n\t\t\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t\t\t   \"boot found match for name '%s'\",\n\t\t\t\t   boardname);\n\t\t\tbreak;\n\t\tcase ATH10K_BD_IE_BOARD_DATA:\n\t\t\tif (!name_match_found)\n\t\t\t\t \n\t\t\t\tbreak;\n\n\t\t\tif (bd_ie_type == ATH10K_BD_IE_BOARD) {\n\t\t\t\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t\t\t\t   \"boot found board data for '%s'\",\n\t\t\t\t\t\tboardname);\n\n\t\t\t\tar->normal_mode_fw.board_data = board_ie_data;\n\t\t\t\tar->normal_mode_fw.board_len = board_ie_len;\n\t\t\t} else if (bd_ie_type == ATH10K_BD_IE_BOARD_EXT) {\n\t\t\t\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t\t\t\t   \"boot found eboard data for '%s'\",\n\t\t\t\t\t\tboardname);\n\n\t\t\t\tar->normal_mode_fw.ext_board_data = board_ie_data;\n\t\t\t\tar->normal_mode_fw.ext_board_len = board_ie_len;\n\t\t\t}\n\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\tath10k_warn(ar, \"unknown ATH10K_BD_IE_BOARD found: %d\\n\",\n\t\t\t\t    board_ie_id);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tboard_ie_len = ALIGN(board_ie_len, 4);\n\n\t\tbuf_len -= board_ie_len;\n\t\tbuf += board_ie_len;\n\t}\n\n\t \n\tret = -ENOENT;\n\nout:\n\treturn ret;\n}\n\nstatic int ath10k_core_search_bd(struct ath10k *ar,\n\t\t\t\t const char *boardname,\n\t\t\t\t const u8 *data,\n\t\t\t\t size_t len)\n{\n\tsize_t ie_len;\n\tstruct ath10k_fw_ie *hdr;\n\tint ret = -ENOENT, ie_id;\n\n\twhile (len > sizeof(struct ath10k_fw_ie)) {\n\t\thdr = (struct ath10k_fw_ie *)data;\n\t\tie_id = le32_to_cpu(hdr->id);\n\t\tie_len = le32_to_cpu(hdr->len);\n\n\t\tlen -= sizeof(*hdr);\n\t\tdata = hdr->data;\n\n\t\tif (len < ALIGN(ie_len, 4)) {\n\t\t\tath10k_err(ar, \"invalid length for board ie_id %d ie_len %zu len %zu\\n\",\n\t\t\t\t   ie_id, ie_len, len);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (ie_id) {\n\t\tcase ATH10K_BD_IE_BOARD:\n\t\t\tret = ath10k_core_parse_bd_ie_board(ar, data, ie_len,\n\t\t\t\t\t\t\t    boardname,\n\t\t\t\t\t\t\t    ATH10K_BD_IE_BOARD);\n\t\t\tif (ret == -ENOENT)\n\t\t\t\t \n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tgoto out;\n\t\tcase ATH10K_BD_IE_BOARD_EXT:\n\t\t\tret = ath10k_core_parse_bd_ie_board(ar, data, ie_len,\n\t\t\t\t\t\t\t    boardname,\n\t\t\t\t\t\t\t    ATH10K_BD_IE_BOARD_EXT);\n\t\t\tif (ret == -ENOENT)\n\t\t\t\t \n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tie_len = ALIGN(ie_len, 4);\n\n\t\tlen -= ie_len;\n\t\tdata += ie_len;\n\t}\n\nout:\n\t \n\treturn ret;\n}\n\nstatic int ath10k_core_fetch_board_data_api_n(struct ath10k *ar,\n\t\t\t\t\t      const char *boardname,\n\t\t\t\t\t      const char *fallback_boardname1,\n\t\t\t\t\t      const char *fallback_boardname2,\n\t\t\t\t\t      const char *filename)\n{\n\tsize_t len, magic_len;\n\tconst u8 *data;\n\tint ret;\n\n\t \n\tif (!ar->normal_mode_fw.board)\n\t\tar->normal_mode_fw.board = ath10k_fetch_fw_file(ar,\n\t\t\t\t\t\t\t\tar->hw_params.fw.dir,\n\t\t\t\t\t\t\t\tfilename);\n\tif (IS_ERR(ar->normal_mode_fw.board))\n\t\treturn PTR_ERR(ar->normal_mode_fw.board);\n\n\tdata = ar->normal_mode_fw.board->data;\n\tlen = ar->normal_mode_fw.board->size;\n\n\t \n\tmagic_len = strlen(ATH10K_BOARD_MAGIC) + 1;\n\tif (len < magic_len) {\n\t\tath10k_err(ar, \"failed to find magic value in %s/%s, file too short: %zu\\n\",\n\t\t\t   ar->hw_params.fw.dir, filename, len);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (memcmp(data, ATH10K_BOARD_MAGIC, magic_len)) {\n\t\tath10k_err(ar, \"found invalid board magic\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t \n\tmagic_len = ALIGN(magic_len, 4);\n\tif (len < magic_len) {\n\t\tath10k_err(ar, \"failed: %s/%s too small to contain board data, len: %zu\\n\",\n\t\t\t   ar->hw_params.fw.dir, filename, len);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tdata += magic_len;\n\tlen -= magic_len;\n\n\t \n\tret = ath10k_core_search_bd(ar, boardname, data, len);\n\n\t \n\tif (ret == -ENOENT && fallback_boardname1)\n\t\tret = ath10k_core_search_bd(ar, fallback_boardname1, data, len);\n\n\tif (ret == -ENOENT && fallback_boardname2)\n\t\tret = ath10k_core_search_bd(ar, fallback_boardname2, data, len);\n\n\tif (ret == -ENOENT) {\n\t\tath10k_err(ar,\n\t\t\t   \"failed to fetch board data for %s from %s/%s\\n\",\n\t\t\t   boardname, ar->hw_params.fw.dir, filename);\n\t\tret = -ENODATA;\n\t}\n\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tath10k_core_free_board_files(ar);\n\treturn ret;\n}\n\nstatic int ath10k_core_create_board_name(struct ath10k *ar, char *name,\n\t\t\t\t\t size_t name_len, bool with_variant,\n\t\t\t\t\t bool with_chip_id)\n{\n\t \n\tchar variant[9 + ATH10K_SMBIOS_BDF_EXT_STR_LENGTH] = { 0 };\n\n\tif (with_variant && ar->id.bdf_ext[0] != '\\0')\n\t\tscnprintf(variant, sizeof(variant), \",variant=%s\",\n\t\t\t  ar->id.bdf_ext);\n\n\tif (ar->id.bmi_ids_valid) {\n\t\tscnprintf(name, name_len,\n\t\t\t  \"bus=%s,bmi-chip-id=%d,bmi-board-id=%d%s\",\n\t\t\t  ath10k_bus_str(ar->hif.bus),\n\t\t\t  ar->id.bmi_chip_id,\n\t\t\t  ar->id.bmi_board_id, variant);\n\t\tgoto out;\n\t}\n\n\tif (ar->id.qmi_ids_valid) {\n\t\tif (with_chip_id)\n\t\t\tscnprintf(name, name_len,\n\t\t\t\t  \"bus=%s,qmi-board-id=%x,qmi-chip-id=%x%s\",\n\t\t\t\t  ath10k_bus_str(ar->hif.bus),\n\t\t\t\t  ar->id.qmi_board_id, ar->id.qmi_chip_id,\n\t\t\t\t  variant);\n\t\telse\n\t\t\tscnprintf(name, name_len,\n\t\t\t\t  \"bus=%s,qmi-board-id=%x\",\n\t\t\t\t  ath10k_bus_str(ar->hif.bus),\n\t\t\t\t  ar->id.qmi_board_id);\n\t\tgoto out;\n\t}\n\n\tscnprintf(name, name_len,\n\t\t  \"bus=%s,vendor=%04x,device=%04x,subsystem-vendor=%04x,subsystem-device=%04x%s\",\n\t\t  ath10k_bus_str(ar->hif.bus),\n\t\t  ar->id.vendor, ar->id.device,\n\t\t  ar->id.subsystem_vendor, ar->id.subsystem_device, variant);\nout:\n\tath10k_dbg(ar, ATH10K_DBG_BOOT, \"boot using board name '%s'\\n\", name);\n\n\treturn 0;\n}\n\nstatic int ath10k_core_create_eboard_name(struct ath10k *ar, char *name,\n\t\t\t\t\t  size_t name_len)\n{\n\tif (ar->id.bmi_ids_valid) {\n\t\tscnprintf(name, name_len,\n\t\t\t  \"bus=%s,bmi-chip-id=%d,bmi-eboard-id=%d\",\n\t\t\t  ath10k_bus_str(ar->hif.bus),\n\t\t\t  ar->id.bmi_chip_id,\n\t\t\t  ar->id.bmi_eboard_id);\n\n\t\tath10k_dbg(ar, ATH10K_DBG_BOOT, \"boot using eboard name '%s'\\n\", name);\n\t\treturn 0;\n\t}\n\t \n\treturn -1;\n}\n\nint ath10k_core_fetch_board_file(struct ath10k *ar, int bd_ie_type)\n{\n\tchar boardname[100], fallback_boardname1[100], fallback_boardname2[100];\n\tint ret;\n\n\tif (bd_ie_type == ATH10K_BD_IE_BOARD) {\n\t\t \n\t\tret = ath10k_core_create_board_name(ar, boardname,\n\t\t\t\t\t\t    sizeof(boardname), true,\n\t\t\t\t\t\t    true);\n\t\tif (ret) {\n\t\t\tath10k_err(ar, \"failed to create board name: %d\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tret = ath10k_core_create_board_name(ar, fallback_boardname1,\n\t\t\t\t\t\t    sizeof(boardname), false,\n\t\t\t\t\t\t    true);\n\t\tif (ret) {\n\t\t\tath10k_err(ar, \"failed to create 1st fallback board name: %d\",\n\t\t\t\t   ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tret = ath10k_core_create_board_name(ar, fallback_boardname2,\n\t\t\t\t\t\t    sizeof(boardname), false,\n\t\t\t\t\t\t    false);\n\t\tif (ret) {\n\t\t\tath10k_err(ar, \"failed to create 2nd fallback board name: %d\",\n\t\t\t\t   ret);\n\t\t\treturn ret;\n\t\t}\n\t} else if (bd_ie_type == ATH10K_BD_IE_BOARD_EXT) {\n\t\tret = ath10k_core_create_eboard_name(ar, boardname,\n\t\t\t\t\t\t     sizeof(boardname));\n\t\tif (ret) {\n\t\t\tath10k_err(ar, \"fallback to eboard.bin since board id 0\");\n\t\t\tgoto fallback;\n\t\t}\n\t}\n\n\tar->bd_api = 2;\n\tret = ath10k_core_fetch_board_data_api_n(ar, boardname,\n\t\t\t\t\t\t fallback_boardname1,\n\t\t\t\t\t\t fallback_boardname2,\n\t\t\t\t\t\t ATH10K_BOARD_API2_FILE);\n\tif (!ret)\n\t\tgoto success;\n\nfallback:\n\tar->bd_api = 1;\n\tret = ath10k_core_fetch_board_data_api_1(ar, bd_ie_type);\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to fetch board-2.bin or board.bin from %s\\n\",\n\t\t\t   ar->hw_params.fw.dir);\n\t\treturn ret;\n\t}\n\nsuccess:\n\tath10k_dbg(ar, ATH10K_DBG_BOOT, \"using board api %d\\n\", ar->bd_api);\n\treturn 0;\n}\nEXPORT_SYMBOL(ath10k_core_fetch_board_file);\n\nstatic int ath10k_core_get_ext_board_id_from_otp(struct ath10k *ar)\n{\n\tu32 result, address;\n\tu8 ext_board_id;\n\tint ret;\n\n\taddress = ar->hw_params.patch_load_addr;\n\n\tif (!ar->normal_mode_fw.fw_file.otp_data ||\n\t    !ar->normal_mode_fw.fw_file.otp_len) {\n\t\tath10k_warn(ar,\n\t\t\t    \"failed to retrieve extended board id due to otp binary missing\\n\");\n\t\treturn -ENODATA;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t   \"boot upload otp to 0x%x len %zd for ext board id\\n\",\n\t\t   address, ar->normal_mode_fw.fw_file.otp_len);\n\n\tret = ath10k_bmi_fast_download(ar, address,\n\t\t\t\t       ar->normal_mode_fw.fw_file.otp_data,\n\t\t\t\t       ar->normal_mode_fw.fw_file.otp_len);\n\tif (ret) {\n\t\tath10k_err(ar, \"could not write otp for ext board id check: %d\\n\",\n\t\t\t   ret);\n\t\treturn ret;\n\t}\n\n\tret = ath10k_bmi_execute(ar, address, BMI_PARAM_GET_EXT_BOARD_ID, &result);\n\tif (ret) {\n\t\tath10k_err(ar, \"could not execute otp for ext board id check: %d\\n\",\n\t\t\t   ret);\n\t\treturn ret;\n\t}\n\n\tif (!result) {\n\t\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t\t   \"ext board id does not exist in otp, ignore it\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\text_board_id = result & ATH10K_BMI_EBOARD_ID_STATUS_MASK;\n\n\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t   \"boot get otp ext board id result 0x%08x ext_board_id %d\\n\",\n\t\t   result, ext_board_id);\n\n\tar->id.bmi_eboard_id = ext_board_id;\n\n\treturn 0;\n}\n\nstatic int ath10k_download_board_data(struct ath10k *ar, const void *data,\n\t\t\t\t      size_t data_len)\n{\n\tu32 board_data_size = ar->hw_params.fw.board_size;\n\tu32 eboard_data_size = ar->hw_params.fw.ext_board_size;\n\tu32 board_address;\n\tu32 ext_board_address;\n\tint ret;\n\n\tret = ath10k_push_board_ext_data(ar, data, data_len);\n\tif (ret) {\n\t\tath10k_err(ar, \"could not push board ext data (%d)\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tret = ath10k_bmi_read32(ar, hi_board_data, &board_address);\n\tif (ret) {\n\t\tath10k_err(ar, \"could not read board data addr (%d)\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tret = ath10k_bmi_write_memory(ar, board_address, data,\n\t\t\t\t      min_t(u32, board_data_size,\n\t\t\t\t\t    data_len));\n\tif (ret) {\n\t\tath10k_err(ar, \"could not write board data (%d)\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tret = ath10k_bmi_write32(ar, hi_board_data_initialized, 1);\n\tif (ret) {\n\t\tath10k_err(ar, \"could not write board data bit (%d)\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tif (!ar->id.ext_bid_supported)\n\t\tgoto exit;\n\n\t \n\tret = ath10k_core_get_ext_board_id_from_otp(ar);\n\tif (ret == -EOPNOTSUPP) {\n\t\t \n\t\tath10k_dbg(ar, ATH10K_DBG_BOOT, \"otp returned ext board id 0\\n\");\n\t\treturn 0;\n\t} else if (ret) {\n\t\tath10k_err(ar, \"failed to get extended board id: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tret = ath10k_core_fetch_board_file(ar, ATH10K_BD_IE_BOARD_EXT);\n\tif (ret)\n\t\tgoto exit;\n\n\tif (ar->normal_mode_fw.ext_board_data) {\n\t\text_board_address = board_address + EXT_BOARD_ADDRESS_OFFSET;\n\t\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t\t   \"boot writing ext board data to addr 0x%x\",\n\t\t\t   ext_board_address);\n\t\tret = ath10k_bmi_write_memory(ar, ext_board_address,\n\t\t\t\t\t      ar->normal_mode_fw.ext_board_data,\n\t\t\t\t\t      min_t(u32, eboard_data_size, data_len));\n\t\tif (ret)\n\t\t\tath10k_err(ar, \"failed to write ext board data: %d\\n\", ret);\n\t}\n\nexit:\n\treturn ret;\n}\n\nstatic int ath10k_download_and_run_otp(struct ath10k *ar)\n{\n\tu32 result, address = ar->hw_params.patch_load_addr;\n\tu32 bmi_otp_exe_param = ar->hw_params.otp_exe_param;\n\tint ret;\n\n\tret = ath10k_download_board_data(ar,\n\t\t\t\t\t ar->running_fw->board_data,\n\t\t\t\t\t ar->running_fw->board_len);\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to download board data: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\n\tif (!ar->running_fw->fw_file.otp_data ||\n\t    !ar->running_fw->fw_file.otp_len) {\n\t\tath10k_warn(ar, \"Not running otp, calibration will be incorrect (otp-data %pK otp_len %zd)!\\n\",\n\t\t\t    ar->running_fw->fw_file.otp_data,\n\t\t\t    ar->running_fw->fw_file.otp_len);\n\t\treturn 0;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_BOOT, \"boot upload otp to 0x%x len %zd\\n\",\n\t\t   address, ar->running_fw->fw_file.otp_len);\n\n\tret = ath10k_bmi_fast_download(ar, address,\n\t\t\t\t       ar->running_fw->fw_file.otp_data,\n\t\t\t\t       ar->running_fw->fw_file.otp_len);\n\tif (ret) {\n\t\tath10k_err(ar, \"could not write otp (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (ar->cal_mode == ATH10K_PRE_CAL_MODE_DT ||\n\t    ar->cal_mode == ATH10K_PRE_CAL_MODE_FILE ||\n\t    ar->cal_mode == ATH10K_PRE_CAL_MODE_NVMEM)\n\t\tbmi_otp_exe_param = BMI_PARAM_FLASH_SECTION_ALL;\n\n\tret = ath10k_bmi_execute(ar, address, bmi_otp_exe_param, &result);\n\tif (ret) {\n\t\tath10k_err(ar, \"could not execute otp (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_BOOT, \"boot otp execute result %d\\n\", result);\n\n\tif (!(skip_otp || test_bit(ATH10K_FW_FEATURE_IGNORE_OTP_RESULT,\n\t\t\t\t   ar->running_fw->fw_file.fw_features)) &&\n\t    result != 0) {\n\t\tath10k_err(ar, \"otp calibration failed: %d\", result);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_download_cal_file(struct ath10k *ar,\n\t\t\t\t    const struct firmware *file)\n{\n\tint ret;\n\n\tif (!file)\n\t\treturn -ENOENT;\n\n\tif (IS_ERR(file))\n\t\treturn PTR_ERR(file);\n\n\tret = ath10k_download_board_data(ar, file->data, file->size);\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to download cal_file data: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_BOOT, \"boot cal file downloaded\\n\");\n\n\treturn 0;\n}\n\nstatic int ath10k_download_cal_dt(struct ath10k *ar, const char *dt_name)\n{\n\tstruct device_node *node;\n\tint data_len;\n\tvoid *data;\n\tint ret;\n\n\tnode = ar->dev->of_node;\n\tif (!node)\n\t\t \n\t\treturn -ENOENT;\n\n\tif (!of_get_property(node, dt_name, &data_len)) {\n\t\t \n\t\treturn -ENOENT;\n\t}\n\n\tif (data_len != ar->hw_params.cal_data_len) {\n\t\tath10k_warn(ar, \"invalid calibration data length in DT: %d\\n\",\n\t\t\t    data_len);\n\t\tret = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\tdata = kmalloc(data_len, GFP_KERNEL);\n\tif (!data) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = of_property_read_u8_array(node, dt_name, data, data_len);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to read calibration data from DT: %d\\n\",\n\t\t\t    ret);\n\t\tgoto out_free;\n\t}\n\n\tret = ath10k_download_board_data(ar, data, data_len);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to download calibration data from Device Tree: %d\\n\",\n\t\t\t    ret);\n\t\tgoto out_free;\n\t}\n\n\tret = 0;\n\nout_free:\n\tkfree(data);\n\nout:\n\treturn ret;\n}\n\nstatic int ath10k_download_cal_eeprom(struct ath10k *ar)\n{\n\tsize_t data_len;\n\tvoid *data = NULL;\n\tint ret;\n\n\tret = ath10k_hif_fetch_cal_eeprom(ar, &data, &data_len);\n\tif (ret) {\n\t\tif (ret != -EOPNOTSUPP)\n\t\t\tath10k_warn(ar, \"failed to read calibration data from EEPROM: %d\\n\",\n\t\t\t\t    ret);\n\t\tgoto out_free;\n\t}\n\n\tret = ath10k_download_board_data(ar, data, data_len);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to download calibration data from EEPROM: %d\\n\",\n\t\t\t    ret);\n\t\tgoto out_free;\n\t}\n\n\tret = 0;\n\nout_free:\n\tkfree(data);\n\n\treturn ret;\n}\n\nstatic int ath10k_download_cal_nvmem(struct ath10k *ar, const char *cell_name)\n{\n\tstruct nvmem_cell *cell;\n\tvoid *buf;\n\tsize_t len;\n\tint ret;\n\n\tcell = devm_nvmem_cell_get(ar->dev, cell_name);\n\tif (IS_ERR(cell)) {\n\t\tret = PTR_ERR(cell);\n\t\treturn ret;\n\t}\n\n\tbuf = nvmem_cell_read(cell, &len);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tif (ar->hw_params.cal_data_len != len) {\n\t\tkfree(buf);\n\t\tath10k_warn(ar, \"invalid calibration data length in nvmem-cell '%s': %zu != %u\\n\",\n\t\t\t    cell_name, len, ar->hw_params.cal_data_len);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tret = ath10k_download_board_data(ar, buf, len);\n\tkfree(buf);\n\tif (ret)\n\t\tath10k_warn(ar, \"failed to download calibration data from nvmem-cell '%s': %d\\n\",\n\t\t\t    cell_name, ret);\n\n\treturn ret;\n}\n\nint ath10k_core_fetch_firmware_api_n(struct ath10k *ar, const char *name,\n\t\t\t\t     struct ath10k_fw_file *fw_file)\n{\n\tsize_t magic_len, len, ie_len;\n\tint ie_id, i, index, bit, ret;\n\tstruct ath10k_fw_ie *hdr;\n\tconst u8 *data;\n\t__le32 *timestamp, *version;\n\n\t \n\tfw_file->firmware = ath10k_fetch_fw_file(ar, ar->hw_params.fw.dir,\n\t\t\t\t\t\t name);\n\tif (IS_ERR(fw_file->firmware))\n\t\treturn PTR_ERR(fw_file->firmware);\n\n\tdata = fw_file->firmware->data;\n\tlen = fw_file->firmware->size;\n\n\t \n\tmagic_len = strlen(ATH10K_FIRMWARE_MAGIC) + 1;\n\n\tif (len < magic_len) {\n\t\tath10k_err(ar, \"firmware file '%s/%s' too small to contain magic: %zu\\n\",\n\t\t\t   ar->hw_params.fw.dir, name, len);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (memcmp(data, ATH10K_FIRMWARE_MAGIC, magic_len) != 0) {\n\t\tath10k_err(ar, \"invalid firmware magic\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t \n\tmagic_len = ALIGN(magic_len, 4);\n\n\tlen -= magic_len;\n\tdata += magic_len;\n\n\t \n\twhile (len > sizeof(struct ath10k_fw_ie)) {\n\t\thdr = (struct ath10k_fw_ie *)data;\n\n\t\tie_id = le32_to_cpu(hdr->id);\n\t\tie_len = le32_to_cpu(hdr->len);\n\n\t\tlen -= sizeof(*hdr);\n\t\tdata += sizeof(*hdr);\n\n\t\tif (len < ie_len) {\n\t\t\tath10k_err(ar, \"invalid length for FW IE %d (%zu < %zu)\\n\",\n\t\t\t\t   ie_id, len, ie_len);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tswitch (ie_id) {\n\t\tcase ATH10K_FW_IE_FW_VERSION:\n\t\t\tif (ie_len > sizeof(fw_file->fw_version) - 1)\n\t\t\t\tbreak;\n\n\t\t\tmemcpy(fw_file->fw_version, data, ie_len);\n\t\t\tfw_file->fw_version[ie_len] = '\\0';\n\n\t\t\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t\t\t   \"found fw version %s\\n\",\n\t\t\t\t    fw_file->fw_version);\n\t\t\tbreak;\n\t\tcase ATH10K_FW_IE_TIMESTAMP:\n\t\t\tif (ie_len != sizeof(u32))\n\t\t\t\tbreak;\n\n\t\t\ttimestamp = (__le32 *)data;\n\n\t\t\tath10k_dbg(ar, ATH10K_DBG_BOOT, \"found fw timestamp %d\\n\",\n\t\t\t\t   le32_to_cpup(timestamp));\n\t\t\tbreak;\n\t\tcase ATH10K_FW_IE_FEATURES:\n\t\t\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t\t\t   \"found firmware features ie (%zd B)\\n\",\n\t\t\t\t   ie_len);\n\n\t\t\tfor (i = 0; i < ATH10K_FW_FEATURE_COUNT; i++) {\n\t\t\t\tindex = i / 8;\n\t\t\t\tbit = i % 8;\n\n\t\t\t\tif (index == ie_len)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (data[index] & (1 << bit)) {\n\t\t\t\t\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t\t\t\t\t   \"Enabling feature bit: %i\\n\",\n\t\t\t\t\t\t   i);\n\t\t\t\t\t__set_bit(i, fw_file->fw_features);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tath10k_dbg_dump(ar, ATH10K_DBG_BOOT, \"features\", \"\",\n\t\t\t\t\tfw_file->fw_features,\n\t\t\t\t\tsizeof(fw_file->fw_features));\n\t\t\tbreak;\n\t\tcase ATH10K_FW_IE_FW_IMAGE:\n\t\t\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t\t\t   \"found fw image ie (%zd B)\\n\",\n\t\t\t\t   ie_len);\n\n\t\t\tfw_file->firmware_data = data;\n\t\t\tfw_file->firmware_len = ie_len;\n\n\t\t\tbreak;\n\t\tcase ATH10K_FW_IE_OTP_IMAGE:\n\t\t\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t\t\t   \"found otp image ie (%zd B)\\n\",\n\t\t\t\t   ie_len);\n\n\t\t\tfw_file->otp_data = data;\n\t\t\tfw_file->otp_len = ie_len;\n\n\t\t\tbreak;\n\t\tcase ATH10K_FW_IE_WMI_OP_VERSION:\n\t\t\tif (ie_len != sizeof(u32))\n\t\t\t\tbreak;\n\n\t\t\tversion = (__le32 *)data;\n\n\t\t\tfw_file->wmi_op_version = le32_to_cpup(version);\n\n\t\t\tath10k_dbg(ar, ATH10K_DBG_BOOT, \"found fw ie wmi op version %d\\n\",\n\t\t\t\t   fw_file->wmi_op_version);\n\t\t\tbreak;\n\t\tcase ATH10K_FW_IE_HTT_OP_VERSION:\n\t\t\tif (ie_len != sizeof(u32))\n\t\t\t\tbreak;\n\n\t\t\tversion = (__le32 *)data;\n\n\t\t\tfw_file->htt_op_version = le32_to_cpup(version);\n\n\t\t\tath10k_dbg(ar, ATH10K_DBG_BOOT, \"found fw ie htt op version %d\\n\",\n\t\t\t\t   fw_file->htt_op_version);\n\t\t\tbreak;\n\t\tcase ATH10K_FW_IE_FW_CODE_SWAP_IMAGE:\n\t\t\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t\t\t   \"found fw code swap image ie (%zd B)\\n\",\n\t\t\t\t   ie_len);\n\t\t\tfw_file->codeswap_data = data;\n\t\t\tfw_file->codeswap_len = ie_len;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tath10k_warn(ar, \"Unknown FW IE: %u\\n\",\n\t\t\t\t    le32_to_cpu(hdr->id));\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tie_len = ALIGN(ie_len, 4);\n\n\t\tlen -= ie_len;\n\t\tdata += ie_len;\n\t}\n\n\tif (!test_bit(ATH10K_FW_FEATURE_NON_BMI, fw_file->fw_features) &&\n\t    (!fw_file->firmware_data || !fw_file->firmware_len)) {\n\t\tath10k_warn(ar, \"No ATH10K_FW_IE_FW_IMAGE found from '%s/%s', skipping\\n\",\n\t\t\t    ar->hw_params.fw.dir, name);\n\t\tret = -ENOMEDIUM;\n\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tath10k_core_free_firmware_files(ar);\n\treturn ret;\n}\n\nstatic void ath10k_core_get_fw_name(struct ath10k *ar, char *fw_name,\n\t\t\t\t    size_t fw_name_len, int fw_api)\n{\n\tswitch (ar->hif.bus) {\n\tcase ATH10K_BUS_SDIO:\n\tcase ATH10K_BUS_USB:\n\t\tscnprintf(fw_name, fw_name_len, \"%s-%s-%d.bin\",\n\t\t\t  ATH10K_FW_FILE_BASE, ath10k_bus_str(ar->hif.bus),\n\t\t\t  fw_api);\n\t\tbreak;\n\tcase ATH10K_BUS_PCI:\n\tcase ATH10K_BUS_AHB:\n\tcase ATH10K_BUS_SNOC:\n\t\tscnprintf(fw_name, fw_name_len, \"%s-%d.bin\",\n\t\t\t  ATH10K_FW_FILE_BASE, fw_api);\n\t\tbreak;\n\t}\n}\n\nstatic int ath10k_core_fetch_firmware_files(struct ath10k *ar)\n{\n\tint ret, i;\n\tchar fw_name[100];\n\n\t \n\tath10k_fetch_cal_file(ar);\n\n\tfor (i = ATH10K_FW_API_MAX; i >= ATH10K_FW_API_MIN; i--) {\n\t\tar->fw_api = i;\n\t\tath10k_dbg(ar, ATH10K_DBG_BOOT, \"trying fw api %d\\n\",\n\t\t\t   ar->fw_api);\n\n\t\tath10k_core_get_fw_name(ar, fw_name, sizeof(fw_name), ar->fw_api);\n\t\tret = ath10k_core_fetch_firmware_api_n(ar, fw_name,\n\t\t\t\t\t\t       &ar->normal_mode_fw.fw_file);\n\t\tif (!ret)\n\t\t\tgoto success;\n\t}\n\n\t \n\n\tath10k_err(ar, \"Failed to find firmware-N.bin (N between %d and %d) from %s: %d\",\n\t\t   ATH10K_FW_API_MIN, ATH10K_FW_API_MAX, ar->hw_params.fw.dir,\n\t\t   ret);\n\n\treturn ret;\n\nsuccess:\n\tath10k_dbg(ar, ATH10K_DBG_BOOT, \"using fw api %d\\n\", ar->fw_api);\n\n\treturn 0;\n}\n\nstatic int ath10k_core_pre_cal_download(struct ath10k *ar)\n{\n\tint ret;\n\n\tret = ath10k_download_cal_nvmem(ar, \"pre-calibration\");\n\tif (ret == 0) {\n\t\tar->cal_mode = ATH10K_PRE_CAL_MODE_NVMEM;\n\t\tgoto success;\n\t} else if (ret == -EPROBE_DEFER) {\n\t\treturn ret;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t   \"boot did not find a pre-calibration nvmem-cell, try file next: %d\\n\",\n\t\t   ret);\n\n\tret = ath10k_download_cal_file(ar, ar->pre_cal_file);\n\tif (ret == 0) {\n\t\tar->cal_mode = ATH10K_PRE_CAL_MODE_FILE;\n\t\tgoto success;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t   \"boot did not find a pre calibration file, try DT next: %d\\n\",\n\t\t   ret);\n\n\tret = ath10k_download_cal_dt(ar, \"qcom,ath10k-pre-calibration-data\");\n\tif (ret) {\n\t\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t\t   \"unable to load pre cal data from DT: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tar->cal_mode = ATH10K_PRE_CAL_MODE_DT;\n\nsuccess:\n\tath10k_dbg(ar, ATH10K_DBG_BOOT, \"boot using calibration mode %s\\n\",\n\t\t   ath10k_cal_mode_str(ar->cal_mode));\n\n\treturn 0;\n}\n\nstatic int ath10k_core_pre_cal_config(struct ath10k *ar)\n{\n\tint ret;\n\n\tret = ath10k_core_pre_cal_download(ar);\n\tif (ret) {\n\t\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t\t   \"failed to load pre cal data: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ath10k_core_get_board_id_from_otp(ar);\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to get board id: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ath10k_download_and_run_otp(ar);\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to run otp: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t   \"pre cal configuration done successfully\\n\");\n\n\treturn 0;\n}\n\nstatic int ath10k_download_cal_data(struct ath10k *ar)\n{\n\tint ret;\n\n\tret = ath10k_core_pre_cal_config(ar);\n\tif (ret == 0)\n\t\treturn 0;\n\n\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t   \"pre cal download procedure failed, try cal file: %d\\n\",\n\t\t   ret);\n\n\tret = ath10k_download_cal_nvmem(ar, \"calibration\");\n\tif (ret == 0) {\n\t\tar->cal_mode = ATH10K_CAL_MODE_NVMEM;\n\t\tgoto done;\n\t} else if (ret == -EPROBE_DEFER) {\n\t\treturn ret;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t   \"boot did not find a calibration nvmem-cell, try file next: %d\\n\",\n\t\t   ret);\n\n\tret = ath10k_download_cal_file(ar, ar->cal_file);\n\tif (ret == 0) {\n\t\tar->cal_mode = ATH10K_CAL_MODE_FILE;\n\t\tgoto done;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t   \"boot did not find a calibration file, try DT next: %d\\n\",\n\t\t   ret);\n\n\tret = ath10k_download_cal_dt(ar, \"qcom,ath10k-calibration-data\");\n\tif (ret == 0) {\n\t\tar->cal_mode = ATH10K_CAL_MODE_DT;\n\t\tgoto done;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t   \"boot did not find DT entry, try target EEPROM next: %d\\n\",\n\t\t   ret);\n\n\tret = ath10k_download_cal_eeprom(ar);\n\tif (ret == 0) {\n\t\tar->cal_mode = ATH10K_CAL_MODE_EEPROM;\n\t\tgoto done;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t   \"boot did not find target EEPROM entry, try OTP next: %d\\n\",\n\t\t   ret);\n\n\tret = ath10k_download_and_run_otp(ar);\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to run otp: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tar->cal_mode = ATH10K_CAL_MODE_OTP;\n\ndone:\n\tath10k_dbg(ar, ATH10K_DBG_BOOT, \"boot using calibration mode %s\\n\",\n\t\t   ath10k_cal_mode_str(ar->cal_mode));\n\treturn 0;\n}\n\nstatic void ath10k_core_fetch_btcoex_dt(struct ath10k *ar)\n{\n\tstruct device_node *node;\n\tu8 coex_support = 0;\n\tint ret;\n\n\tnode = ar->dev->of_node;\n\tif (!node)\n\t\tgoto out;\n\n\tret = of_property_read_u8(node, \"qcom,coexist-support\", &coex_support);\n\tif (ret) {\n\t\tar->coex_support = true;\n\t\tgoto out;\n\t}\n\n\tif (coex_support) {\n\t\tar->coex_support = true;\n\t} else {\n\t\tar->coex_support = false;\n\t\tar->coex_gpio_pin = -1;\n\t\tgoto out;\n\t}\n\n\tret = of_property_read_u32(node, \"qcom,coexist-gpio-pin\",\n\t\t\t\t   &ar->coex_gpio_pin);\n\tif (ret)\n\t\tar->coex_gpio_pin = -1;\n\nout:\n\tath10k_dbg(ar, ATH10K_DBG_BOOT, \"boot coex_support %d coex_gpio_pin %d\\n\",\n\t\t   ar->coex_support, ar->coex_gpio_pin);\n}\n\nstatic int ath10k_init_uart(struct ath10k *ar)\n{\n\tint ret;\n\n\t \n\tret = ath10k_bmi_write32(ar, hi_serial_enable, 0);\n\tif (ret) {\n\t\tath10k_warn(ar, \"could not disable UART prints (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (!uart_print) {\n\t\tif (ar->hw_params.uart_pin_workaround) {\n\t\t\tret = ath10k_bmi_write32(ar, hi_dbg_uart_txpin,\n\t\t\t\t\t\t ar->hw_params.uart_pin);\n\t\t\tif (ret) {\n\t\t\t\tath10k_warn(ar, \"failed to set UART TX pin: %d\",\n\t\t\t\t\t    ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tret = ath10k_bmi_write32(ar, hi_dbg_uart_txpin, ar->hw_params.uart_pin);\n\tif (ret) {\n\t\tath10k_warn(ar, \"could not enable UART prints (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ath10k_bmi_write32(ar, hi_serial_enable, 1);\n\tif (ret) {\n\t\tath10k_warn(ar, \"could not enable UART prints (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = ath10k_bmi_write32(ar, hi_desired_baud_rate, 19200);\n\tif (ret) {\n\t\tath10k_warn(ar, \"could not set the baud rate (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tath10k_info(ar, \"UART prints enabled\\n\");\n\treturn 0;\n}\n\nstatic int ath10k_init_hw_params(struct ath10k *ar)\n{\n\tconst struct ath10k_hw_params *hw_params;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ath10k_hw_params_list); i++) {\n\t\thw_params = &ath10k_hw_params_list[i];\n\n\t\tif (hw_params->bus == ar->hif.bus &&\n\t\t    hw_params->id == ar->target_version &&\n\t\t    hw_params->dev_id == ar->dev_id)\n\t\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(ath10k_hw_params_list)) {\n\t\tath10k_err(ar, \"Unsupported hardware version: 0x%x\\n\",\n\t\t\t   ar->target_version);\n\t\treturn -EINVAL;\n\t}\n\n\tar->hw_params = *hw_params;\n\n\tath10k_dbg(ar, ATH10K_DBG_BOOT, \"Hardware name %s version 0x%x\\n\",\n\t\t   ar->hw_params.name, ar->target_version);\n\n\treturn 0;\n}\n\nvoid ath10k_core_start_recovery(struct ath10k *ar)\n{\n\tif (test_and_set_bit(ATH10K_FLAG_RESTARTING, &ar->dev_flags)) {\n\t\tath10k_warn(ar, \"already restarting\\n\");\n\t\treturn;\n\t}\n\n\tqueue_work(ar->workqueue, &ar->restart_work);\n}\nEXPORT_SYMBOL(ath10k_core_start_recovery);\n\nvoid ath10k_core_napi_enable(struct ath10k *ar)\n{\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (test_bit(ATH10K_FLAG_NAPI_ENABLED, &ar->dev_flags))\n\t\treturn;\n\n\tnapi_enable(&ar->napi);\n\tset_bit(ATH10K_FLAG_NAPI_ENABLED, &ar->dev_flags);\n}\nEXPORT_SYMBOL(ath10k_core_napi_enable);\n\nvoid ath10k_core_napi_sync_disable(struct ath10k *ar)\n{\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (!test_bit(ATH10K_FLAG_NAPI_ENABLED, &ar->dev_flags))\n\t\treturn;\n\n\tnapi_synchronize(&ar->napi);\n\tnapi_disable(&ar->napi);\n\tclear_bit(ATH10K_FLAG_NAPI_ENABLED, &ar->dev_flags);\n}\nEXPORT_SYMBOL(ath10k_core_napi_sync_disable);\n\nstatic void ath10k_core_restart(struct work_struct *work)\n{\n\tstruct ath10k *ar = container_of(work, struct ath10k, restart_work);\n\tint ret;\n\n\tset_bit(ATH10K_FLAG_CRASH_FLUSH, &ar->dev_flags);\n\n\t \n\tbarrier();\n\n\tieee80211_stop_queues(ar->hw);\n\tath10k_drain_tx(ar);\n\tcomplete(&ar->scan.started);\n\tcomplete(&ar->scan.completed);\n\tcomplete(&ar->scan.on_channel);\n\tcomplete(&ar->offchan_tx_completed);\n\tcomplete(&ar->install_key_done);\n\tcomplete(&ar->vdev_setup_done);\n\tcomplete(&ar->vdev_delete_done);\n\tcomplete(&ar->thermal.wmi_sync);\n\tcomplete(&ar->bss_survey_done);\n\twake_up(&ar->htt.empty_tx_wq);\n\twake_up(&ar->wmi.tx_credits_wq);\n\twake_up(&ar->peer_mapping_wq);\n\n\t \n\tcancel_work_sync(&ar->set_coverage_class_work);\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tswitch (ar->state) {\n\tcase ATH10K_STATE_ON:\n\t\tar->state = ATH10K_STATE_RESTARTING;\n\t\tath10k_halt(ar);\n\t\tath10k_scan_finish(ar);\n\t\tieee80211_restart_hw(ar->hw);\n\t\tbreak;\n\tcase ATH10K_STATE_OFF:\n\t\t \n\t\tath10k_warn(ar, \"cannot restart a device that hasn't been started\\n\");\n\t\tbreak;\n\tcase ATH10K_STATE_RESTARTING:\n\t\t \n\t\tbreak;\n\tcase ATH10K_STATE_RESTARTED:\n\t\tar->state = ATH10K_STATE_WEDGED;\n\t\tfallthrough;\n\tcase ATH10K_STATE_WEDGED:\n\t\tath10k_warn(ar, \"device is wedged, will not restart\\n\");\n\t\tbreak;\n\tcase ATH10K_STATE_UTF:\n\t\tath10k_warn(ar, \"firmware restart in UTF mode not supported\\n\");\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&ar->conf_mutex);\n\n\tret = ath10k_coredump_submit(ar);\n\tif (ret)\n\t\tath10k_warn(ar, \"failed to send firmware crash dump via devcoredump: %d\",\n\t\t\t    ret);\n\n\tcomplete(&ar->driver_recovery);\n}\n\nstatic void ath10k_core_set_coverage_class_work(struct work_struct *work)\n{\n\tstruct ath10k *ar = container_of(work, struct ath10k,\n\t\t\t\t\t set_coverage_class_work);\n\n\tif (ar->hw_params.hw_ops->set_coverage_class)\n\t\tar->hw_params.hw_ops->set_coverage_class(ar, -1);\n}\n\nstatic int ath10k_core_init_firmware_features(struct ath10k *ar)\n{\n\tstruct ath10k_fw_file *fw_file = &ar->normal_mode_fw.fw_file;\n\tint max_num_peers;\n\n\tif (test_bit(ATH10K_FW_FEATURE_WMI_10_2, fw_file->fw_features) &&\n\t    !test_bit(ATH10K_FW_FEATURE_WMI_10X, fw_file->fw_features)) {\n\t\tath10k_err(ar, \"feature bits corrupted: 10.2 feature requires 10.x feature to be set as well\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (fw_file->wmi_op_version >= ATH10K_FW_WMI_OP_VERSION_MAX) {\n\t\tath10k_err(ar, \"unsupported WMI OP version (max %d): %d\\n\",\n\t\t\t   ATH10K_FW_WMI_OP_VERSION_MAX, fw_file->wmi_op_version);\n\t\treturn -EINVAL;\n\t}\n\n\tar->wmi.rx_decap_mode = ATH10K_HW_TXRX_NATIVE_WIFI;\n\tswitch (ath10k_cryptmode_param) {\n\tcase ATH10K_CRYPT_MODE_HW:\n\t\tclear_bit(ATH10K_FLAG_RAW_MODE, &ar->dev_flags);\n\t\tclear_bit(ATH10K_FLAG_HW_CRYPTO_DISABLED, &ar->dev_flags);\n\t\tbreak;\n\tcase ATH10K_CRYPT_MODE_SW:\n\t\tif (!test_bit(ATH10K_FW_FEATURE_RAW_MODE_SUPPORT,\n\t\t\t      fw_file->fw_features)) {\n\t\t\tath10k_err(ar, \"cryptmode > 0 requires raw mode support from firmware\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tset_bit(ATH10K_FLAG_RAW_MODE, &ar->dev_flags);\n\t\tset_bit(ATH10K_FLAG_HW_CRYPTO_DISABLED, &ar->dev_flags);\n\t\tbreak;\n\tdefault:\n\t\tath10k_info(ar, \"invalid cryptmode: %d\\n\",\n\t\t\t    ath10k_cryptmode_param);\n\t\treturn -EINVAL;\n\t}\n\n\tar->htt.max_num_amsdu = ATH10K_HTT_MAX_NUM_AMSDU_DEFAULT;\n\tar->htt.max_num_ampdu = ATH10K_HTT_MAX_NUM_AMPDU_DEFAULT;\n\n\tif (ath10k_frame_mode == ATH10K_HW_TXRX_RAW) {\n\t\tif (!test_bit(ATH10K_FW_FEATURE_RAW_MODE_SUPPORT,\n\t\t\t      fw_file->fw_features)) {\n\t\t\tath10k_err(ar, \"rawmode = 1 requires support from firmware\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tset_bit(ATH10K_FLAG_RAW_MODE, &ar->dev_flags);\n\t}\n\n\tif (test_bit(ATH10K_FLAG_RAW_MODE, &ar->dev_flags)) {\n\t\tar->wmi.rx_decap_mode = ATH10K_HW_TXRX_RAW;\n\n\t\t \n\t\tar->htt.max_num_amsdu = 1;\n\t}\n\n\t \n\tif (fw_file->wmi_op_version == ATH10K_FW_WMI_OP_VERSION_UNSET) {\n\t\tif (test_bit(ATH10K_FW_FEATURE_WMI_10X, fw_file->fw_features)) {\n\t\t\tif (test_bit(ATH10K_FW_FEATURE_WMI_10_2,\n\t\t\t\t     fw_file->fw_features))\n\t\t\t\tfw_file->wmi_op_version = ATH10K_FW_WMI_OP_VERSION_10_2;\n\t\t\telse\n\t\t\t\tfw_file->wmi_op_version = ATH10K_FW_WMI_OP_VERSION_10_1;\n\t\t} else {\n\t\t\tfw_file->wmi_op_version = ATH10K_FW_WMI_OP_VERSION_MAIN;\n\t\t}\n\t}\n\n\tswitch (fw_file->wmi_op_version) {\n\tcase ATH10K_FW_WMI_OP_VERSION_MAIN:\n\t\tmax_num_peers = TARGET_NUM_PEERS;\n\t\tar->max_num_stations = TARGET_NUM_STATIONS;\n\t\tar->max_num_vdevs = TARGET_NUM_VDEVS;\n\t\tar->htt.max_num_pending_tx = TARGET_NUM_MSDU_DESC;\n\t\tar->fw_stats_req_mask = WMI_STAT_PDEV | WMI_STAT_VDEV |\n\t\t\tWMI_STAT_PEER;\n\t\tar->max_spatial_stream = WMI_MAX_SPATIAL_STREAM;\n\t\tbreak;\n\tcase ATH10K_FW_WMI_OP_VERSION_10_1:\n\tcase ATH10K_FW_WMI_OP_VERSION_10_2:\n\tcase ATH10K_FW_WMI_OP_VERSION_10_2_4:\n\t\tif (ath10k_peer_stats_enabled(ar)) {\n\t\t\tmax_num_peers = TARGET_10X_TX_STATS_NUM_PEERS;\n\t\t\tar->max_num_stations = TARGET_10X_TX_STATS_NUM_STATIONS;\n\t\t} else {\n\t\t\tmax_num_peers = TARGET_10X_NUM_PEERS;\n\t\t\tar->max_num_stations = TARGET_10X_NUM_STATIONS;\n\t\t}\n\t\tar->max_num_vdevs = TARGET_10X_NUM_VDEVS;\n\t\tar->htt.max_num_pending_tx = TARGET_10X_NUM_MSDU_DESC;\n\t\tar->fw_stats_req_mask = WMI_STAT_PEER;\n\t\tar->max_spatial_stream = WMI_MAX_SPATIAL_STREAM;\n\t\tbreak;\n\tcase ATH10K_FW_WMI_OP_VERSION_TLV:\n\t\tmax_num_peers = TARGET_TLV_NUM_PEERS;\n\t\tar->max_num_stations = TARGET_TLV_NUM_STATIONS;\n\t\tar->max_num_vdevs = TARGET_TLV_NUM_VDEVS;\n\t\tar->max_num_tdls_vdevs = TARGET_TLV_NUM_TDLS_VDEVS;\n\t\tif (ar->hif.bus == ATH10K_BUS_SDIO)\n\t\t\tar->htt.max_num_pending_tx =\n\t\t\t\tTARGET_TLV_NUM_MSDU_DESC_HL;\n\t\telse\n\t\t\tar->htt.max_num_pending_tx = TARGET_TLV_NUM_MSDU_DESC;\n\t\tar->wow.max_num_patterns = TARGET_TLV_NUM_WOW_PATTERNS;\n\t\tar->fw_stats_req_mask = WMI_TLV_STAT_PDEV | WMI_TLV_STAT_VDEV |\n\t\t\tWMI_TLV_STAT_PEER | WMI_TLV_STAT_PEER_EXTD;\n\t\tar->max_spatial_stream = WMI_MAX_SPATIAL_STREAM;\n\t\tar->wmi.mgmt_max_num_pending_tx = TARGET_TLV_MGMT_NUM_MSDU_DESC;\n\t\tbreak;\n\tcase ATH10K_FW_WMI_OP_VERSION_10_4:\n\t\tmax_num_peers = TARGET_10_4_NUM_PEERS;\n\t\tar->max_num_stations = TARGET_10_4_NUM_STATIONS;\n\t\tar->num_active_peers = TARGET_10_4_ACTIVE_PEERS;\n\t\tar->max_num_vdevs = TARGET_10_4_NUM_VDEVS;\n\t\tar->num_tids = TARGET_10_4_TGT_NUM_TIDS;\n\t\tar->fw_stats_req_mask = WMI_10_4_STAT_PEER |\n\t\t\t\t\tWMI_10_4_STAT_PEER_EXTD |\n\t\t\t\t\tWMI_10_4_STAT_VDEV_EXTD;\n\t\tar->max_spatial_stream = ar->hw_params.max_spatial_stream;\n\t\tar->max_num_tdls_vdevs = TARGET_10_4_NUM_TDLS_VDEVS;\n\n\t\tif (test_bit(ATH10K_FW_FEATURE_PEER_FLOW_CONTROL,\n\t\t\t     fw_file->fw_features))\n\t\t\tar->htt.max_num_pending_tx = TARGET_10_4_NUM_MSDU_DESC_PFC;\n\t\telse\n\t\t\tar->htt.max_num_pending_tx = TARGET_10_4_NUM_MSDU_DESC;\n\t\tbreak;\n\tcase ATH10K_FW_WMI_OP_VERSION_UNSET:\n\tcase ATH10K_FW_WMI_OP_VERSION_MAX:\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ar->hw_params.num_peers)\n\t\tar->max_num_peers = ar->hw_params.num_peers;\n\telse\n\t\tar->max_num_peers = max_num_peers;\n\n\t \n\tif (fw_file->htt_op_version == ATH10K_FW_HTT_OP_VERSION_UNSET) {\n\t\tswitch (fw_file->wmi_op_version) {\n\t\tcase ATH10K_FW_WMI_OP_VERSION_MAIN:\n\t\t\tfw_file->htt_op_version = ATH10K_FW_HTT_OP_VERSION_MAIN;\n\t\t\tbreak;\n\t\tcase ATH10K_FW_WMI_OP_VERSION_10_1:\n\t\tcase ATH10K_FW_WMI_OP_VERSION_10_2:\n\t\tcase ATH10K_FW_WMI_OP_VERSION_10_2_4:\n\t\t\tfw_file->htt_op_version = ATH10K_FW_HTT_OP_VERSION_10_1;\n\t\t\tbreak;\n\t\tcase ATH10K_FW_WMI_OP_VERSION_TLV:\n\t\t\tfw_file->htt_op_version = ATH10K_FW_HTT_OP_VERSION_TLV;\n\t\t\tbreak;\n\t\tcase ATH10K_FW_WMI_OP_VERSION_10_4:\n\t\tcase ATH10K_FW_WMI_OP_VERSION_UNSET:\n\t\tcase ATH10K_FW_WMI_OP_VERSION_MAX:\n\t\t\tath10k_err(ar, \"htt op version not found from fw meta data\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_core_reset_rx_filter(struct ath10k *ar)\n{\n\tint ret;\n\tint vdev_id;\n\tint vdev_type;\n\tint vdev_subtype;\n\tconst u8 *vdev_addr;\n\n\tvdev_id = 0;\n\tvdev_type = WMI_VDEV_TYPE_STA;\n\tvdev_subtype = ath10k_wmi_get_vdev_subtype(ar, WMI_VDEV_SUBTYPE_NONE);\n\tvdev_addr = ar->mac_addr;\n\n\tret = ath10k_wmi_vdev_create(ar, vdev_id, vdev_type, vdev_subtype,\n\t\t\t\t     vdev_addr);\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to create dummy vdev: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ath10k_wmi_vdev_delete(ar, vdev_id);\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to delete dummy vdev: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = ath10k_wmi_barrier(ar);\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to ping firmware: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_core_compat_services(struct ath10k *ar)\n{\n\tstruct ath10k_fw_file *fw_file = &ar->normal_mode_fw.fw_file;\n\n\t \n\tswitch (fw_file->wmi_op_version) {\n\tcase ATH10K_FW_WMI_OP_VERSION_10_1:\n\tcase ATH10K_FW_WMI_OP_VERSION_10_2:\n\tcase ATH10K_FW_WMI_OP_VERSION_10_2_4:\n\tcase ATH10K_FW_WMI_OP_VERSION_10_4:\n\t\tset_bit(WMI_SERVICE_THERM_THROT, ar->wmi.svc_map);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n#define TGT_IRAM_READ_PER_ITR (8 * 1024)\n\nstatic int ath10k_core_copy_target_iram(struct ath10k *ar)\n{\n\tconst struct ath10k_hw_mem_layout *hw_mem;\n\tconst struct ath10k_mem_region *tmp, *mem_region = NULL;\n\tdma_addr_t paddr;\n\tvoid *vaddr = NULL;\n\tu8 num_read_itr;\n\tint i, ret;\n\tu32 len, remaining_len;\n\n\t \n\thw_mem = _ath10k_coredump_get_mem_layout(ar);\n\tif (!hw_mem)\n\t\t \n\t\treturn 0;\n\n\tfor (i = 0; i < hw_mem->region_table.size; i++) {\n\t\ttmp = &hw_mem->region_table.regions[i];\n\t\tif (tmp->type == ATH10K_MEM_REGION_TYPE_REG) {\n\t\t\tmem_region = tmp;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!mem_region)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ar->wmi.num_mem_chunks; i++) {\n\t\tif (ar->wmi.mem_chunks[i].req_id ==\n\t\t    WMI_IRAM_RECOVERY_HOST_MEM_REQ_ID) {\n\t\t\tvaddr = ar->wmi.mem_chunks[i].vaddr;\n\t\t\tlen = ar->wmi.mem_chunks[i].len;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!vaddr || !len) {\n\t\tath10k_warn(ar, \"No allocated memory for IRAM back up\");\n\t\treturn -ENOMEM;\n\t}\n\n\tlen = (len < mem_region->len) ? len : mem_region->len;\n\tpaddr = mem_region->start;\n\tnum_read_itr = len / TGT_IRAM_READ_PER_ITR;\n\tremaining_len = len % TGT_IRAM_READ_PER_ITR;\n\tfor (i = 0; i < num_read_itr; i++) {\n\t\tret = ath10k_hif_diag_read(ar, paddr, vaddr,\n\t\t\t\t\t   TGT_IRAM_READ_PER_ITR);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to copy firmware IRAM contents: %d\",\n\t\t\t\t    ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpaddr += TGT_IRAM_READ_PER_ITR;\n\t\tvaddr += TGT_IRAM_READ_PER_ITR;\n\t}\n\n\tif (remaining_len) {\n\t\tret = ath10k_hif_diag_read(ar, paddr, vaddr, remaining_len);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to copy firmware IRAM contents: %d\",\n\t\t\t\t    ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_BOOT, \"target IRAM back up completed\\n\");\n\n\treturn 0;\n}\n\nint ath10k_core_start(struct ath10k *ar, enum ath10k_firmware_mode mode,\n\t\t      const struct ath10k_fw_components *fw)\n{\n\tint status;\n\tu32 val;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tclear_bit(ATH10K_FLAG_CRASH_FLUSH, &ar->dev_flags);\n\n\tar->running_fw = fw;\n\n\tif (!test_bit(ATH10K_FW_FEATURE_NON_BMI,\n\t\t      ar->running_fw->fw_file.fw_features)) {\n\t\tath10k_bmi_start(ar);\n\n\t\t \n\t\tif (ar->hw_params.hw_ops->enable_pll_clk) {\n\t\t\tstatus = ar->hw_params.hw_ops->enable_pll_clk(ar);\n\t\t\tath10k_dbg(ar, ATH10K_DBG_BOOT, \"boot enable pll ret %d\\n\",\n\t\t\t\t   status);\n\t\t}\n\n\t\tif (ath10k_init_configure_target(ar)) {\n\t\t\tstatus = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tstatus = ath10k_download_cal_data(ar);\n\t\tif (status)\n\t\t\tgoto err;\n\n\t\t \n\t\tif (test_bit(ATH10K_FW_FEATURE_SUPPORTS_SKIP_CLOCK_INIT,\n\t\t\t     ar->running_fw->fw_file.fw_features)) {\n\t\t\tstatus = ath10k_bmi_write32(ar, hi_skip_clock_init, 1);\n\t\t\tif (status) {\n\t\t\t\tath10k_err(ar, \"could not write to skip_clock_init: %d\\n\",\n\t\t\t\t\t   status);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\t\tstatus = ath10k_download_fw(ar);\n\t\tif (status)\n\t\t\tgoto err;\n\n\t\tstatus = ath10k_init_uart(ar);\n\t\tif (status)\n\t\t\tgoto err;\n\n\t\tif (ar->hif.bus == ATH10K_BUS_SDIO) {\n\t\t\tstatus = ath10k_init_sdio(ar, mode);\n\t\t\tif (status) {\n\t\t\t\tath10k_err(ar, \"failed to init SDIO: %d\\n\", status);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t}\n\n\tar->htc.htc_ops.target_send_suspend_complete =\n\t\tath10k_send_suspend_complete;\n\n\tstatus = ath10k_htc_init(ar);\n\tif (status) {\n\t\tath10k_err(ar, \"could not init HTC (%d)\\n\", status);\n\t\tgoto err;\n\t}\n\n\tif (!test_bit(ATH10K_FW_FEATURE_NON_BMI,\n\t\t      ar->running_fw->fw_file.fw_features)) {\n\t\tstatus = ath10k_bmi_done(ar);\n\t\tif (status)\n\t\t\tgoto err;\n\t}\n\n\tstatus = ath10k_wmi_attach(ar);\n\tif (status) {\n\t\tath10k_err(ar, \"WMI attach failed: %d\\n\", status);\n\t\tgoto err;\n\t}\n\n\tstatus = ath10k_htt_init(ar);\n\tif (status) {\n\t\tath10k_err(ar, \"failed to init htt: %d\\n\", status);\n\t\tgoto err_wmi_detach;\n\t}\n\n\tstatus = ath10k_htt_tx_start(&ar->htt);\n\tif (status) {\n\t\tath10k_err(ar, \"failed to alloc htt tx: %d\\n\", status);\n\t\tgoto err_wmi_detach;\n\t}\n\n\t \n\tar->htt.rx_ring.in_ord_rx = !!(test_bit(WMI_SERVICE_RX_FULL_REORDER,\n\t\t\t\t\t\tar->wmi.svc_map));\n\n\tstatus = ath10k_htt_rx_alloc(&ar->htt);\n\tif (status) {\n\t\tath10k_err(ar, \"failed to alloc htt rx: %d\\n\", status);\n\t\tgoto err_htt_tx_detach;\n\t}\n\n\tstatus = ath10k_hif_start(ar);\n\tif (status) {\n\t\tath10k_err(ar, \"could not start HIF: %d\\n\", status);\n\t\tgoto err_htt_rx_detach;\n\t}\n\n\tstatus = ath10k_htc_wait_target(&ar->htc);\n\tif (status) {\n\t\tath10k_err(ar, \"failed to connect to HTC: %d\\n\", status);\n\t\tgoto err_hif_stop;\n\t}\n\n\tstatus = ath10k_hif_start_post(ar);\n\tif (status) {\n\t\tath10k_err(ar, \"failed to swap mailbox: %d\\n\", status);\n\t\tgoto err_hif_stop;\n\t}\n\n\tif (mode == ATH10K_FIRMWARE_MODE_NORMAL) {\n\t\tstatus = ath10k_htt_connect(&ar->htt);\n\t\tif (status) {\n\t\t\tath10k_err(ar, \"failed to connect htt (%d)\\n\", status);\n\t\t\tgoto err_hif_stop;\n\t\t}\n\t}\n\n\tstatus = ath10k_wmi_connect(ar);\n\tif (status) {\n\t\tath10k_err(ar, \"could not connect wmi: %d\\n\", status);\n\t\tgoto err_hif_stop;\n\t}\n\n\tstatus = ath10k_htc_start(&ar->htc);\n\tif (status) {\n\t\tath10k_err(ar, \"failed to start htc: %d\\n\", status);\n\t\tgoto err_hif_stop;\n\t}\n\n\tif (mode == ATH10K_FIRMWARE_MODE_NORMAL) {\n\t\tstatus = ath10k_wmi_wait_for_service_ready(ar);\n\t\tif (status) {\n\t\t\tath10k_warn(ar, \"wmi service ready event not received\");\n\t\t\tgoto err_hif_stop;\n\t\t}\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_BOOT, \"firmware %s booted\\n\",\n\t\t   ar->hw->wiphy->fw_version);\n\n\tif (test_bit(ATH10K_FW_FEATURE_IRAM_RECOVERY,\n\t\t     ar->running_fw->fw_file.fw_features)) {\n\t\tstatus = ath10k_core_copy_target_iram(ar);\n\t\tif (status) {\n\t\t\tath10k_warn(ar, \"failed to copy target iram contents: %d\",\n\t\t\t\t    status);\n\t\t\tgoto err_hif_stop;\n\t\t}\n\t}\n\n\tif (test_bit(WMI_SERVICE_EXT_RES_CFG_SUPPORT, ar->wmi.svc_map) &&\n\t    mode == ATH10K_FIRMWARE_MODE_NORMAL) {\n\t\tval = 0;\n\t\tif (ath10k_peer_stats_enabled(ar))\n\t\t\tval = WMI_10_4_PEER_STATS;\n\n\t\t \n\t\tval |= WMI_10_4_VDEV_STATS;\n\n\t\tif (test_bit(WMI_SERVICE_BSS_CHANNEL_INFO_64, ar->wmi.svc_map))\n\t\t\tval |= WMI_10_4_BSS_CHANNEL_INFO_64;\n\n\t\tath10k_core_fetch_btcoex_dt(ar);\n\n\t\t \n\n\t\tif (test_bit(WMI_SERVICE_COEX_GPIO, ar->wmi.svc_map) &&\n\t\t    test_bit(ATH10K_FW_FEATURE_BTCOEX_PARAM,\n\t\t\t     ar->running_fw->fw_file.fw_features) &&\n\t\t    ar->coex_support)\n\t\t\tval |= WMI_10_4_COEX_GPIO_SUPPORT;\n\n\t\tif (test_bit(WMI_SERVICE_TDLS_EXPLICIT_MODE_ONLY,\n\t\t\t     ar->wmi.svc_map))\n\t\t\tval |= WMI_10_4_TDLS_EXPLICIT_MODE_ONLY;\n\n\t\tif (test_bit(WMI_SERVICE_TDLS_UAPSD_BUFFER_STA,\n\t\t\t     ar->wmi.svc_map))\n\t\t\tval |= WMI_10_4_TDLS_UAPSD_BUFFER_STA;\n\n\t\tif (test_bit(WMI_SERVICE_TX_DATA_ACK_RSSI,\n\t\t\t     ar->wmi.svc_map))\n\t\t\tval |= WMI_10_4_TX_DATA_ACK_RSSI;\n\n\t\tif (test_bit(WMI_SERVICE_REPORT_AIRTIME, ar->wmi.svc_map))\n\t\t\tval |= WMI_10_4_REPORT_AIRTIME;\n\n\t\tif (test_bit(WMI_SERVICE_EXT_PEER_TID_CONFIGS_SUPPORT,\n\t\t\t     ar->wmi.svc_map))\n\t\t\tval |= WMI_10_4_EXT_PEER_TID_CONFIGS_SUPPORT;\n\n\t\tstatus = ath10k_mac_ext_resource_config(ar, val);\n\t\tif (status) {\n\t\t\tath10k_err(ar,\n\t\t\t\t   \"failed to send ext resource cfg command : %d\\n\",\n\t\t\t\t   status);\n\t\t\tgoto err_hif_stop;\n\t\t}\n\t}\n\n\tstatus = ath10k_wmi_cmd_init(ar);\n\tif (status) {\n\t\tath10k_err(ar, \"could not send WMI init command (%d)\\n\",\n\t\t\t   status);\n\t\tgoto err_hif_stop;\n\t}\n\n\tstatus = ath10k_wmi_wait_for_unified_ready(ar);\n\tif (status) {\n\t\tath10k_err(ar, \"wmi unified ready event not received\\n\");\n\t\tgoto err_hif_stop;\n\t}\n\n\tstatus = ath10k_core_compat_services(ar);\n\tif (status) {\n\t\tath10k_err(ar, \"compat services failed: %d\\n\", status);\n\t\tgoto err_hif_stop;\n\t}\n\n\tstatus = ath10k_wmi_pdev_set_base_macaddr(ar, ar->mac_addr);\n\tif (status && status != -EOPNOTSUPP) {\n\t\tath10k_err(ar,\n\t\t\t   \"failed to set base mac address: %d\\n\", status);\n\t\tgoto err_hif_stop;\n\t}\n\n\t \n\tif (ar->hw_params.hw_filter_reset_required &&\n\t    mode == ATH10K_FIRMWARE_MODE_NORMAL) {\n\t\tstatus = ath10k_core_reset_rx_filter(ar);\n\t\tif (status) {\n\t\t\tath10k_err(ar,\n\t\t\t\t   \"failed to reset rx filter: %d\\n\", status);\n\t\t\tgoto err_hif_stop;\n\t\t}\n\t}\n\n\tstatus = ath10k_htt_rx_ring_refill(ar);\n\tif (status) {\n\t\tath10k_err(ar, \"failed to refill htt rx ring: %d\\n\", status);\n\t\tgoto err_hif_stop;\n\t}\n\n\tif (ar->max_num_vdevs >= 64)\n\t\tar->free_vdev_map = 0xFFFFFFFFFFFFFFFFLL;\n\telse\n\t\tar->free_vdev_map = (1LL << ar->max_num_vdevs) - 1;\n\n\tINIT_LIST_HEAD(&ar->arvifs);\n\n\t \n\tif (mode == ATH10K_FIRMWARE_MODE_NORMAL) {\n\t\tstatus = ath10k_htt_setup(&ar->htt);\n\t\tif (status) {\n\t\t\tath10k_err(ar, \"failed to setup htt: %d\\n\", status);\n\t\t\tgoto err_hif_stop;\n\t\t}\n\t}\n\n\tstatus = ath10k_debug_start(ar);\n\tif (status)\n\t\tgoto err_hif_stop;\n\n\tstatus = ath10k_hif_set_target_log_mode(ar, fw_diag_log);\n\tif (status && status != -EOPNOTSUPP) {\n\t\tath10k_warn(ar, \"set target log mode failed: %d\\n\", status);\n\t\tgoto err_hif_stop;\n\t}\n\n\treturn 0;\n\nerr_hif_stop:\n\tath10k_hif_stop(ar);\nerr_htt_rx_detach:\n\tath10k_htt_rx_free(&ar->htt);\nerr_htt_tx_detach:\n\tath10k_htt_tx_free(&ar->htt);\nerr_wmi_detach:\n\tath10k_wmi_detach(ar);\nerr:\n\treturn status;\n}\nEXPORT_SYMBOL(ath10k_core_start);\n\nint ath10k_wait_for_suspend(struct ath10k *ar, u32 suspend_opt)\n{\n\tint ret;\n\tunsigned long time_left;\n\n\treinit_completion(&ar->target_suspend);\n\n\tret = ath10k_wmi_pdev_suspend_target(ar, suspend_opt);\n\tif (ret) {\n\t\tath10k_warn(ar, \"could not suspend target (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ttime_left = wait_for_completion_timeout(&ar->target_suspend, 1 * HZ);\n\n\tif (!time_left) {\n\t\tath10k_warn(ar, \"suspend timed out - target pause event never came\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nvoid ath10k_core_stop(struct ath10k *ar)\n{\n\tlockdep_assert_held(&ar->conf_mutex);\n\tath10k_debug_stop(ar);\n\n\t \n\tif (ar->state != ATH10K_STATE_RESTARTING &&\n\t    ar->state != ATH10K_STATE_UTF)\n\t\tath10k_wait_for_suspend(ar, WMI_PDEV_SUSPEND_AND_DISABLE_INTR);\n\n\tath10k_hif_stop(ar);\n\tath10k_htt_tx_stop(&ar->htt);\n\tath10k_htt_rx_free(&ar->htt);\n\tath10k_wmi_detach(ar);\n\n\tar->id.bmi_ids_valid = false;\n}\nEXPORT_SYMBOL(ath10k_core_stop);\n\n \nstatic int ath10k_core_probe_fw(struct ath10k *ar)\n{\n\tstruct bmi_target_info target_info;\n\tint ret = 0;\n\n\tret = ath10k_hif_power_up(ar, ATH10K_FIRMWARE_MODE_NORMAL);\n\tif (ret) {\n\t\tath10k_err(ar, \"could not power on hif bus (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tswitch (ar->hif.bus) {\n\tcase ATH10K_BUS_SDIO:\n\t\tmemset(&target_info, 0, sizeof(target_info));\n\t\tret = ath10k_bmi_get_target_info_sdio(ar, &target_info);\n\t\tif (ret) {\n\t\t\tath10k_err(ar, \"could not get target info (%d)\\n\", ret);\n\t\t\tgoto err_power_down;\n\t\t}\n\t\tar->target_version = target_info.version;\n\t\tar->hw->wiphy->hw_version = target_info.version;\n\t\tbreak;\n\tcase ATH10K_BUS_PCI:\n\tcase ATH10K_BUS_AHB:\n\tcase ATH10K_BUS_USB:\n\t\tmemset(&target_info, 0, sizeof(target_info));\n\t\tret = ath10k_bmi_get_target_info(ar, &target_info);\n\t\tif (ret) {\n\t\t\tath10k_err(ar, \"could not get target info (%d)\\n\", ret);\n\t\t\tgoto err_power_down;\n\t\t}\n\t\tar->target_version = target_info.version;\n\t\tar->hw->wiphy->hw_version = target_info.version;\n\t\tbreak;\n\tcase ATH10K_BUS_SNOC:\n\t\tmemset(&target_info, 0, sizeof(target_info));\n\t\tret = ath10k_hif_get_target_info(ar, &target_info);\n\t\tif (ret) {\n\t\t\tath10k_err(ar, \"could not get target info (%d)\\n\", ret);\n\t\t\tgoto err_power_down;\n\t\t}\n\t\tar->target_version = target_info.version;\n\t\tar->hw->wiphy->hw_version = target_info.version;\n\t\tbreak;\n\tdefault:\n\t\tath10k_err(ar, \"incorrect hif bus type: %d\\n\", ar->hif.bus);\n\t}\n\n\tret = ath10k_init_hw_params(ar);\n\tif (ret) {\n\t\tath10k_err(ar, \"could not get hw params (%d)\\n\", ret);\n\t\tgoto err_power_down;\n\t}\n\n\tret = ath10k_core_fetch_firmware_files(ar);\n\tif (ret) {\n\t\tath10k_err(ar, \"could not fetch firmware files (%d)\\n\", ret);\n\t\tgoto err_power_down;\n\t}\n\n\tBUILD_BUG_ON(sizeof(ar->hw->wiphy->fw_version) !=\n\t\t     sizeof(ar->normal_mode_fw.fw_file.fw_version));\n\tmemcpy(ar->hw->wiphy->fw_version, ar->normal_mode_fw.fw_file.fw_version,\n\t       sizeof(ar->hw->wiphy->fw_version));\n\n\tath10k_debug_print_hwfw_info(ar);\n\n\tif (!test_bit(ATH10K_FW_FEATURE_NON_BMI,\n\t\t      ar->normal_mode_fw.fw_file.fw_features)) {\n\t\tret = ath10k_core_pre_cal_download(ar);\n\t\tif (ret) {\n\t\t\t \n\t\t\tath10k_dbg(ar, ATH10K_DBG_BOOT,\n\t\t\t\t   \"could not load pre cal data: %d\\n\", ret);\n\t\t}\n\n\t\tret = ath10k_core_get_board_id_from_otp(ar);\n\t\tif (ret && ret != -EOPNOTSUPP) {\n\t\t\tath10k_err(ar, \"failed to get board id from otp: %d\\n\",\n\t\t\t\t   ret);\n\t\t\tgoto err_free_firmware_files;\n\t\t}\n\n\t\tret = ath10k_core_check_smbios(ar);\n\t\tif (ret)\n\t\t\tath10k_dbg(ar, ATH10K_DBG_BOOT, \"SMBIOS bdf variant name not set.\\n\");\n\n\t\tret = ath10k_core_check_dt(ar);\n\t\tif (ret)\n\t\t\tath10k_dbg(ar, ATH10K_DBG_BOOT, \"DT bdf variant name not set.\\n\");\n\n\t\tret = ath10k_core_fetch_board_file(ar, ATH10K_BD_IE_BOARD);\n\t\tif (ret) {\n\t\t\tath10k_err(ar, \"failed to fetch board file: %d\\n\", ret);\n\t\t\tgoto err_free_firmware_files;\n\t\t}\n\n\t\tath10k_debug_print_board_info(ar);\n\t}\n\n\tdevice_get_mac_address(ar->dev, ar->mac_addr);\n\n\tret = ath10k_core_init_firmware_features(ar);\n\tif (ret) {\n\t\tath10k_err(ar, \"fatal problem with firmware features: %d\\n\",\n\t\t\t   ret);\n\t\tgoto err_free_firmware_files;\n\t}\n\n\tif (!test_bit(ATH10K_FW_FEATURE_NON_BMI,\n\t\t      ar->normal_mode_fw.fw_file.fw_features)) {\n\t\tret = ath10k_swap_code_seg_init(ar,\n\t\t\t\t\t\t&ar->normal_mode_fw.fw_file);\n\t\tif (ret) {\n\t\t\tath10k_err(ar, \"failed to initialize code swap segment: %d\\n\",\n\t\t\t\t   ret);\n\t\t\tgoto err_free_firmware_files;\n\t\t}\n\t}\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tret = ath10k_core_start(ar, ATH10K_FIRMWARE_MODE_NORMAL,\n\t\t\t\t&ar->normal_mode_fw);\n\tif (ret) {\n\t\tath10k_err(ar, \"could not init core (%d)\\n\", ret);\n\t\tgoto err_unlock;\n\t}\n\n\tath10k_debug_print_boot_info(ar);\n\tath10k_core_stop(ar);\n\n\tmutex_unlock(&ar->conf_mutex);\n\n\tath10k_hif_power_down(ar);\n\treturn 0;\n\nerr_unlock:\n\tmutex_unlock(&ar->conf_mutex);\n\nerr_free_firmware_files:\n\tath10k_core_free_firmware_files(ar);\n\nerr_power_down:\n\tath10k_hif_power_down(ar);\n\n\treturn ret;\n}\n\nstatic void ath10k_core_register_work(struct work_struct *work)\n{\n\tstruct ath10k *ar = container_of(work, struct ath10k, register_work);\n\tint status;\n\n\t \n\tset_bit(ATH10K_FLAG_PEER_STATS, &ar->dev_flags);\n\n\tstatus = ath10k_core_probe_fw(ar);\n\tif (status) {\n\t\tath10k_err(ar, \"could not probe fw (%d)\\n\", status);\n\t\tgoto err;\n\t}\n\n\tstatus = ath10k_mac_register(ar);\n\tif (status) {\n\t\tath10k_err(ar, \"could not register to mac80211 (%d)\\n\", status);\n\t\tgoto err_release_fw;\n\t}\n\n\tstatus = ath10k_coredump_register(ar);\n\tif (status) {\n\t\tath10k_err(ar, \"unable to register coredump\\n\");\n\t\tgoto err_unregister_mac;\n\t}\n\n\tstatus = ath10k_debug_register(ar);\n\tif (status) {\n\t\tath10k_err(ar, \"unable to initialize debugfs\\n\");\n\t\tgoto err_unregister_coredump;\n\t}\n\n\tstatus = ath10k_spectral_create(ar);\n\tif (status) {\n\t\tath10k_err(ar, \"failed to initialize spectral\\n\");\n\t\tgoto err_debug_destroy;\n\t}\n\n\tstatus = ath10k_thermal_register(ar);\n\tif (status) {\n\t\tath10k_err(ar, \"could not register thermal device: %d\\n\",\n\t\t\t   status);\n\t\tgoto err_spectral_destroy;\n\t}\n\n\tset_bit(ATH10K_FLAG_CORE_REGISTERED, &ar->dev_flags);\n\treturn;\n\nerr_spectral_destroy:\n\tath10k_spectral_destroy(ar);\nerr_debug_destroy:\n\tath10k_debug_destroy(ar);\nerr_unregister_coredump:\n\tath10k_coredump_unregister(ar);\nerr_unregister_mac:\n\tath10k_mac_unregister(ar);\nerr_release_fw:\n\tath10k_core_free_firmware_files(ar);\nerr:\n\t \n\treturn;\n}\n\nint ath10k_core_register(struct ath10k *ar,\n\t\t\t const struct ath10k_bus_params *bus_params)\n{\n\tar->bus_param = *bus_params;\n\n\tqueue_work(ar->workqueue, &ar->register_work);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ath10k_core_register);\n\nvoid ath10k_core_unregister(struct ath10k *ar)\n{\n\tcancel_work_sync(&ar->register_work);\n\n\tif (!test_bit(ATH10K_FLAG_CORE_REGISTERED, &ar->dev_flags))\n\t\treturn;\n\n\tath10k_thermal_unregister(ar);\n\t \n\tath10k_spectral_destroy(ar);\n\n\t \n\tath10k_mac_unregister(ar);\n\n\tath10k_testmode_destroy(ar);\n\n\tath10k_core_free_firmware_files(ar);\n\tath10k_core_free_board_files(ar);\n\n\tath10k_debug_unregister(ar);\n}\nEXPORT_SYMBOL(ath10k_core_unregister);\n\nstruct ath10k *ath10k_core_create(size_t priv_size, struct device *dev,\n\t\t\t\t  enum ath10k_bus bus,\n\t\t\t\t  enum ath10k_hw_rev hw_rev,\n\t\t\t\t  const struct ath10k_hif_ops *hif_ops)\n{\n\tstruct ath10k *ar;\n\tint ret;\n\n\tar = ath10k_mac_create(priv_size);\n\tif (!ar)\n\t\treturn NULL;\n\n\tar->ath_common.priv = ar;\n\tar->ath_common.hw = ar->hw;\n\tar->dev = dev;\n\tar->hw_rev = hw_rev;\n\tar->hif.ops = hif_ops;\n\tar->hif.bus = bus;\n\n\tswitch (hw_rev) {\n\tcase ATH10K_HW_QCA988X:\n\tcase ATH10K_HW_QCA9887:\n\t\tar->regs = &qca988x_regs;\n\t\tar->hw_ce_regs = &qcax_ce_regs;\n\t\tar->hw_values = &qca988x_values;\n\t\tbreak;\n\tcase ATH10K_HW_QCA6174:\n\tcase ATH10K_HW_QCA9377:\n\t\tar->regs = &qca6174_regs;\n\t\tar->hw_ce_regs = &qcax_ce_regs;\n\t\tar->hw_values = &qca6174_values;\n\t\tbreak;\n\tcase ATH10K_HW_QCA99X0:\n\tcase ATH10K_HW_QCA9984:\n\t\tar->regs = &qca99x0_regs;\n\t\tar->hw_ce_regs = &qcax_ce_regs;\n\t\tar->hw_values = &qca99x0_values;\n\t\tbreak;\n\tcase ATH10K_HW_QCA9888:\n\t\tar->regs = &qca99x0_regs;\n\t\tar->hw_ce_regs = &qcax_ce_regs;\n\t\tar->hw_values = &qca9888_values;\n\t\tbreak;\n\tcase ATH10K_HW_QCA4019:\n\t\tar->regs = &qca4019_regs;\n\t\tar->hw_ce_regs = &qcax_ce_regs;\n\t\tar->hw_values = &qca4019_values;\n\t\tbreak;\n\tcase ATH10K_HW_WCN3990:\n\t\tar->regs = &wcn3990_regs;\n\t\tar->hw_ce_regs = &wcn3990_ce_regs;\n\t\tar->hw_values = &wcn3990_values;\n\t\tbreak;\n\tdefault:\n\t\tath10k_err(ar, \"unsupported core hardware revision %d\\n\",\n\t\t\t   hw_rev);\n\t\tret = -ENOTSUPP;\n\t\tgoto err_free_mac;\n\t}\n\n\tinit_completion(&ar->scan.started);\n\tinit_completion(&ar->scan.completed);\n\tinit_completion(&ar->scan.on_channel);\n\tinit_completion(&ar->target_suspend);\n\tinit_completion(&ar->driver_recovery);\n\tinit_completion(&ar->wow.wakeup_completed);\n\n\tinit_completion(&ar->install_key_done);\n\tinit_completion(&ar->vdev_setup_done);\n\tinit_completion(&ar->vdev_delete_done);\n\tinit_completion(&ar->thermal.wmi_sync);\n\tinit_completion(&ar->bss_survey_done);\n\tinit_completion(&ar->peer_delete_done);\n\tinit_completion(&ar->peer_stats_info_complete);\n\n\tINIT_DELAYED_WORK(&ar->scan.timeout, ath10k_scan_timeout_work);\n\n\tar->workqueue = create_singlethread_workqueue(\"ath10k_wq\");\n\tif (!ar->workqueue)\n\t\tgoto err_free_mac;\n\n\tar->workqueue_aux = create_singlethread_workqueue(\"ath10k_aux_wq\");\n\tif (!ar->workqueue_aux)\n\t\tgoto err_free_wq;\n\n\tar->workqueue_tx_complete =\n\t\tcreate_singlethread_workqueue(\"ath10k_tx_complete_wq\");\n\tif (!ar->workqueue_tx_complete)\n\t\tgoto err_free_aux_wq;\n\n\tmutex_init(&ar->conf_mutex);\n\tmutex_init(&ar->dump_mutex);\n\tspin_lock_init(&ar->data_lock);\n\n\tfor (int ac = 0; ac < IEEE80211_NUM_ACS; ac++)\n\t\tspin_lock_init(&ar->queue_lock[ac]);\n\n\tINIT_LIST_HEAD(&ar->peers);\n\tinit_waitqueue_head(&ar->peer_mapping_wq);\n\tinit_waitqueue_head(&ar->htt.empty_tx_wq);\n\tinit_waitqueue_head(&ar->wmi.tx_credits_wq);\n\n\tskb_queue_head_init(&ar->htt.rx_indication_head);\n\n\tinit_completion(&ar->offchan_tx_completed);\n\tINIT_WORK(&ar->offchan_tx_work, ath10k_offchan_tx_work);\n\tskb_queue_head_init(&ar->offchan_tx_queue);\n\n\tINIT_WORK(&ar->wmi_mgmt_tx_work, ath10k_mgmt_over_wmi_tx_work);\n\tskb_queue_head_init(&ar->wmi_mgmt_tx_queue);\n\n\tINIT_WORK(&ar->register_work, ath10k_core_register_work);\n\tINIT_WORK(&ar->restart_work, ath10k_core_restart);\n\tINIT_WORK(&ar->set_coverage_class_work,\n\t\t  ath10k_core_set_coverage_class_work);\n\n\tinit_dummy_netdev(&ar->napi_dev);\n\n\tret = ath10k_coredump_create(ar);\n\tif (ret)\n\t\tgoto err_free_tx_complete;\n\n\tret = ath10k_debug_create(ar);\n\tif (ret)\n\t\tgoto err_free_coredump;\n\n\treturn ar;\n\nerr_free_coredump:\n\tath10k_coredump_destroy(ar);\nerr_free_tx_complete:\n\tdestroy_workqueue(ar->workqueue_tx_complete);\nerr_free_aux_wq:\n\tdestroy_workqueue(ar->workqueue_aux);\nerr_free_wq:\n\tdestroy_workqueue(ar->workqueue);\nerr_free_mac:\n\tath10k_mac_destroy(ar);\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(ath10k_core_create);\n\nvoid ath10k_core_destroy(struct ath10k *ar)\n{\n\tdestroy_workqueue(ar->workqueue);\n\n\tdestroy_workqueue(ar->workqueue_aux);\n\n\tdestroy_workqueue(ar->workqueue_tx_complete);\n\n\tath10k_debug_destroy(ar);\n\tath10k_coredump_destroy(ar);\n\tath10k_htt_tx_destroy(&ar->htt);\n\tath10k_wmi_free_host_mem(ar);\n\tath10k_mac_destroy(ar);\n}\nEXPORT_SYMBOL(ath10k_core_destroy);\n\nMODULE_AUTHOR(\"Qualcomm Atheros\");\nMODULE_DESCRIPTION(\"Core module for Qualcomm Atheros 802.11ac wireless LAN cards.\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}