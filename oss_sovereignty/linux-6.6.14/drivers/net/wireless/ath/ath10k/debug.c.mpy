{
  "module_name": "debug.c",
  "hash_id": "f078696ce7c3dc6eb1b1624c9197faba712530656fbd999c3852a96dc233f9a5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath10k/debug.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/vmalloc.h>\n#include <linux/crc32.h>\n#include <linux/firmware.h>\n#include <linux/kstrtox.h>\n\n#include \"core.h\"\n#include \"debug.h\"\n#include \"hif.h\"\n#include \"wmi-ops.h\"\n\n \n#define ATH10K_DEBUG_HTT_STATS_INTERVAL 1000\n\n#define ATH10K_DEBUG_CAL_DATA_LEN 12064\n\nvoid ath10k_info(struct ath10k *ar, const char *fmt, ...)\n{\n\tstruct va_format vaf = {\n\t\t.fmt = fmt,\n\t};\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.va = &args;\n\tdev_info(ar->dev, \"%pV\", &vaf);\n\ttrace_ath10k_log_info(ar, &vaf);\n\tva_end(args);\n}\nEXPORT_SYMBOL(ath10k_info);\n\nvoid ath10k_debug_print_hwfw_info(struct ath10k *ar)\n{\n\tconst struct firmware *firmware;\n\tchar fw_features[128] = {};\n\tu32 crc = 0;\n\n\tath10k_core_get_fw_features_str(ar, fw_features, sizeof(fw_features));\n\n\tath10k_info(ar, \"%s target 0x%08x chip_id 0x%08x sub %04x:%04x\",\n\t\t    ar->hw_params.name,\n\t\t    ar->target_version,\n\t\t    ar->bus_param.chip_id,\n\t\t    ar->id.subsystem_vendor, ar->id.subsystem_device);\n\n\tath10k_info(ar, \"kconfig debug %d debugfs %d tracing %d dfs %d testmode %d\\n\",\n\t\t    IS_ENABLED(CONFIG_ATH10K_DEBUG),\n\t\t    IS_ENABLED(CONFIG_ATH10K_DEBUGFS),\n\t\t    IS_ENABLED(CONFIG_ATH10K_TRACING),\n\t\t    IS_ENABLED(CONFIG_ATH10K_DFS_CERTIFIED),\n\t\t    IS_ENABLED(CONFIG_NL80211_TESTMODE));\n\n\tfirmware = ar->normal_mode_fw.fw_file.firmware;\n\tif (firmware)\n\t\tcrc = crc32_le(0, firmware->data, firmware->size);\n\n\tath10k_info(ar, \"firmware ver %s api %d features %s crc32 %08x\\n\",\n\t\t    ar->hw->wiphy->fw_version,\n\t\t    ar->fw_api,\n\t\t    fw_features,\n\t\t    crc);\n}\n\nvoid ath10k_debug_print_board_info(struct ath10k *ar)\n{\n\tchar boardinfo[100];\n\tconst struct firmware *board;\n\tu32 crc;\n\n\tif (ar->id.bmi_ids_valid)\n\t\tscnprintf(boardinfo, sizeof(boardinfo), \"%d:%d\",\n\t\t\t  ar->id.bmi_chip_id, ar->id.bmi_board_id);\n\telse\n\t\tscnprintf(boardinfo, sizeof(boardinfo), \"N/A\");\n\n\tboard = ar->normal_mode_fw.board;\n\tif (!IS_ERR_OR_NULL(board))\n\t\tcrc = crc32_le(0, board->data, board->size);\n\telse\n\t\tcrc = 0;\n\n\tath10k_info(ar, \"board_file api %d bmi_id %s crc32 %08x\",\n\t\t    ar->bd_api,\n\t\t    boardinfo,\n\t\t    crc);\n}\n\nvoid ath10k_debug_print_boot_info(struct ath10k *ar)\n{\n\tath10k_info(ar, \"htt-ver %d.%d wmi-op %d htt-op %d cal %s max-sta %d raw %d hwcrypto %d\\n\",\n\t\t    ar->htt.target_version_major,\n\t\t    ar->htt.target_version_minor,\n\t\t    ar->normal_mode_fw.fw_file.wmi_op_version,\n\t\t    ar->normal_mode_fw.fw_file.htt_op_version,\n\t\t    ath10k_cal_mode_str(ar->cal_mode),\n\t\t    ar->max_num_stations,\n\t\t    test_bit(ATH10K_FLAG_RAW_MODE, &ar->dev_flags),\n\t\t    !test_bit(ATH10K_FLAG_HW_CRYPTO_DISABLED, &ar->dev_flags));\n}\n\nvoid ath10k_print_driver_info(struct ath10k *ar)\n{\n\tath10k_debug_print_hwfw_info(ar);\n\tath10k_debug_print_board_info(ar);\n\tath10k_debug_print_boot_info(ar);\n}\nEXPORT_SYMBOL(ath10k_print_driver_info);\n\nvoid ath10k_err(struct ath10k *ar, const char *fmt, ...)\n{\n\tstruct va_format vaf = {\n\t\t.fmt = fmt,\n\t};\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.va = &args;\n\tdev_err(ar->dev, \"%pV\", &vaf);\n\ttrace_ath10k_log_err(ar, &vaf);\n\tva_end(args);\n}\nEXPORT_SYMBOL(ath10k_err);\n\nvoid ath10k_warn(struct ath10k *ar, const char *fmt, ...)\n{\n\tstruct va_format vaf = {\n\t\t.fmt = fmt,\n\t};\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.va = &args;\n\tdev_warn_ratelimited(ar->dev, \"%pV\", &vaf);\n\ttrace_ath10k_log_warn(ar, &vaf);\n\n\tva_end(args);\n}\nEXPORT_SYMBOL(ath10k_warn);\n\n#ifdef CONFIG_ATH10K_DEBUGFS\n\nstatic ssize_t ath10k_read_wmi_services(struct file *file,\n\t\t\t\t\tchar __user *user_buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct ath10k *ar = file->private_data;\n\tchar *buf;\n\tsize_t len = 0, buf_len = 8192;\n\tconst char *name;\n\tssize_t ret_cnt;\n\tbool enabled;\n\tint i;\n\n\tbuf = kzalloc(buf_len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tspin_lock_bh(&ar->data_lock);\n\tfor (i = 0; i < WMI_SERVICE_MAX; i++) {\n\t\tenabled = test_bit(i, ar->wmi.svc_map);\n\t\tname = wmi_service_name(i);\n\n\t\tif (!name) {\n\t\t\tif (enabled)\n\t\t\t\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t\t\t\t \"%-40s %s (bit %d)\\n\",\n\t\t\t\t\t\t \"unknown\", \"enabled\", i);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t\t \"%-40s %s\\n\",\n\t\t\t\t name, enabled ? \"enabled\" : \"-\");\n\t}\n\tspin_unlock_bh(&ar->data_lock);\n\n\tret_cnt = simple_read_from_buffer(user_buf, count, ppos, buf, len);\n\n\tmutex_unlock(&ar->conf_mutex);\n\n\tkfree(buf);\n\treturn ret_cnt;\n}\n\nstatic const struct file_operations fops_wmi_services = {\n\t.read = ath10k_read_wmi_services,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic void ath10k_fw_stats_pdevs_free(struct list_head *head)\n{\n\tstruct ath10k_fw_stats_pdev *i, *tmp;\n\n\tlist_for_each_entry_safe(i, tmp, head, list) {\n\t\tlist_del(&i->list);\n\t\tkfree(i);\n\t}\n}\n\nstatic void ath10k_fw_stats_vdevs_free(struct list_head *head)\n{\n\tstruct ath10k_fw_stats_vdev *i, *tmp;\n\n\tlist_for_each_entry_safe(i, tmp, head, list) {\n\t\tlist_del(&i->list);\n\t\tkfree(i);\n\t}\n}\n\nstatic void ath10k_fw_stats_peers_free(struct list_head *head)\n{\n\tstruct ath10k_fw_stats_peer *i, *tmp;\n\n\tlist_for_each_entry_safe(i, tmp, head, list) {\n\t\tlist_del(&i->list);\n\t\tkfree(i);\n\t}\n}\n\nstatic void ath10k_fw_extd_stats_peers_free(struct list_head *head)\n{\n\tstruct ath10k_fw_extd_stats_peer *i, *tmp;\n\n\tlist_for_each_entry_safe(i, tmp, head, list) {\n\t\tlist_del(&i->list);\n\t\tkfree(i);\n\t}\n}\n\nstatic void ath10k_debug_fw_stats_reset(struct ath10k *ar)\n{\n\tspin_lock_bh(&ar->data_lock);\n\tar->debug.fw_stats_done = false;\n\tar->debug.fw_stats.extended = false;\n\tath10k_fw_stats_pdevs_free(&ar->debug.fw_stats.pdevs);\n\tath10k_fw_stats_vdevs_free(&ar->debug.fw_stats.vdevs);\n\tath10k_fw_stats_peers_free(&ar->debug.fw_stats.peers);\n\tath10k_fw_extd_stats_peers_free(&ar->debug.fw_stats.peers_extd);\n\tspin_unlock_bh(&ar->data_lock);\n}\n\nvoid ath10k_debug_fw_stats_process(struct ath10k *ar, struct sk_buff *skb)\n{\n\tstruct ath10k_fw_stats stats = {};\n\tbool is_start, is_started, is_end;\n\tsize_t num_peers;\n\tsize_t num_vdevs;\n\tint ret;\n\n\tINIT_LIST_HEAD(&stats.pdevs);\n\tINIT_LIST_HEAD(&stats.vdevs);\n\tINIT_LIST_HEAD(&stats.peers);\n\tINIT_LIST_HEAD(&stats.peers_extd);\n\n\tspin_lock_bh(&ar->data_lock);\n\tret = ath10k_wmi_pull_fw_stats(ar, skb, &stats);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to pull fw stats: %d\\n\", ret);\n\t\tgoto free;\n\t}\n\n\t \n\tif (ath10k_peer_stats_enabled(ar))\n\t\tath10k_sta_update_rx_duration(ar, &stats);\n\n\tif (ar->debug.fw_stats_done) {\n\t\tif (!ath10k_peer_stats_enabled(ar))\n\t\t\tath10k_warn(ar, \"received unsolicited stats update event\\n\");\n\n\t\tgoto free;\n\t}\n\n\tnum_peers = list_count_nodes(&ar->debug.fw_stats.peers);\n\tnum_vdevs = list_count_nodes(&ar->debug.fw_stats.vdevs);\n\tis_start = (list_empty(&ar->debug.fw_stats.pdevs) &&\n\t\t    !list_empty(&stats.pdevs));\n\tis_end = (!list_empty(&ar->debug.fw_stats.pdevs) &&\n\t\t  !list_empty(&stats.pdevs));\n\n\tif (is_start)\n\t\tlist_splice_tail_init(&stats.pdevs, &ar->debug.fw_stats.pdevs);\n\n\tif (is_end)\n\t\tar->debug.fw_stats_done = true;\n\n\tif (stats.extended)\n\t\tar->debug.fw_stats.extended = true;\n\n\tis_started = !list_empty(&ar->debug.fw_stats.pdevs);\n\n\tif (is_started && !is_end) {\n\t\tif (num_peers >= ATH10K_MAX_NUM_PEER_IDS) {\n\t\t\t \n\t\t\tath10k_fw_stats_peers_free(&ar->debug.fw_stats.peers);\n\t\t\tath10k_fw_extd_stats_peers_free(&ar->debug.fw_stats.peers_extd);\n\t\t\tath10k_warn(ar, \"dropping fw peer stats\\n\");\n\t\t\tgoto free;\n\t\t}\n\n\t\tif (num_vdevs >= BITS_PER_LONG) {\n\t\t\tath10k_fw_stats_vdevs_free(&ar->debug.fw_stats.vdevs);\n\t\t\tath10k_warn(ar, \"dropping fw vdev stats\\n\");\n\t\t\tgoto free;\n\t\t}\n\n\t\tif (!list_empty(&stats.peers))\n\t\t\tlist_splice_tail_init(&stats.peers_extd,\n\t\t\t\t\t      &ar->debug.fw_stats.peers_extd);\n\n\t\tlist_splice_tail_init(&stats.peers, &ar->debug.fw_stats.peers);\n\t\tlist_splice_tail_init(&stats.vdevs, &ar->debug.fw_stats.vdevs);\n\t}\n\n\tcomplete(&ar->debug.fw_stats_complete);\n\nfree:\n\t \n\tath10k_fw_stats_pdevs_free(&stats.pdevs);\n\tath10k_fw_stats_vdevs_free(&stats.vdevs);\n\tath10k_fw_stats_peers_free(&stats.peers);\n\tath10k_fw_extd_stats_peers_free(&stats.peers_extd);\n\n\tspin_unlock_bh(&ar->data_lock);\n}\n\nint ath10k_debug_fw_stats_request(struct ath10k *ar)\n{\n\tunsigned long timeout, time_left;\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\ttimeout = jiffies + msecs_to_jiffies(1 * HZ);\n\n\tath10k_debug_fw_stats_reset(ar);\n\n\tfor (;;) {\n\t\tif (time_after(jiffies, timeout))\n\t\t\treturn -ETIMEDOUT;\n\n\t\treinit_completion(&ar->debug.fw_stats_complete);\n\n\t\tret = ath10k_wmi_request_stats(ar, ar->fw_stats_req_mask);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"could not request stats (%d)\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\ttime_left =\n\t\twait_for_completion_timeout(&ar->debug.fw_stats_complete,\n\t\t\t\t\t    1 * HZ);\n\t\tif (!time_left)\n\t\t\treturn -ETIMEDOUT;\n\n\t\tspin_lock_bh(&ar->data_lock);\n\t\tif (ar->debug.fw_stats_done) {\n\t\t\tspin_unlock_bh(&ar->data_lock);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock_bh(&ar->data_lock);\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_fw_stats_open(struct inode *inode, struct file *file)\n{\n\tstruct ath10k *ar = inode->i_private;\n\tvoid *buf = NULL;\n\tint ret;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (ar->state != ATH10K_STATE_ON) {\n\t\tret = -ENETDOWN;\n\t\tgoto err_unlock;\n\t}\n\n\tbuf = vmalloc(ATH10K_FW_STATS_BUF_SIZE);\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto err_unlock;\n\t}\n\n\tret = ath10k_debug_fw_stats_request(ar);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to request fw stats: %d\\n\", ret);\n\t\tgoto err_free;\n\t}\n\n\tret = ath10k_wmi_fw_stats_fill(ar, &ar->debug.fw_stats, buf);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to fill fw stats: %d\\n\", ret);\n\t\tgoto err_free;\n\t}\n\n\tfile->private_data = buf;\n\n\tmutex_unlock(&ar->conf_mutex);\n\treturn 0;\n\nerr_free:\n\tvfree(buf);\n\nerr_unlock:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic int ath10k_fw_stats_release(struct inode *inode, struct file *file)\n{\n\tvfree(file->private_data);\n\n\treturn 0;\n}\n\nstatic ssize_t ath10k_fw_stats_read(struct file *file, char __user *user_buf,\n\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tconst char *buf = file->private_data;\n\tsize_t len = strlen(buf);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic const struct file_operations fops_fw_stats = {\n\t.open = ath10k_fw_stats_open,\n\t.release = ath10k_fw_stats_release,\n\t.read = ath10k_fw_stats_read,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t ath10k_debug_fw_reset_stats_read(struct file *file,\n\t\t\t\t\t\tchar __user *user_buf,\n\t\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct ath10k *ar = file->private_data;\n\tint ret;\n\tsize_t len = 0, buf_len = 500;\n\tchar *buf;\n\n\tbuf = kmalloc(buf_len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tspin_lock_bh(&ar->data_lock);\n\n\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t \"fw_crash_counter\\t\\t%d\\n\", ar->stats.fw_crash_counter);\n\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t \"fw_warm_reset_counter\\t\\t%d\\n\",\n\t\t\t ar->stats.fw_warm_reset_counter);\n\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t \"fw_cold_reset_counter\\t\\t%d\\n\",\n\t\t\t ar->stats.fw_cold_reset_counter);\n\n\tspin_unlock_bh(&ar->data_lock);\n\n\tret = simple_read_from_buffer(user_buf, count, ppos, buf, len);\n\n\tkfree(buf);\n\n\treturn ret;\n}\n\nstatic const struct file_operations fops_fw_reset_stats = {\n\t.open = simple_open,\n\t.read = ath10k_debug_fw_reset_stats_read,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\n \nstatic int ath10k_debug_fw_assert(struct ath10k *ar)\n{\n\tstruct wmi_vdev_install_key_cmd *cmd;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd) + 16);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_vdev_install_key_cmd *)skb->data;\n\tmemset(cmd, 0, sizeof(*cmd));\n\n\t \n\tcmd->vdev_id = __cpu_to_le32(0x7ffe);\n\n\treturn ath10k_wmi_cmd_send(ar, skb,\n\t\t\t\t   ar->wmi.cmd->vdev_install_key_cmdid);\n}\n\nstatic ssize_t ath10k_read_simulate_fw_crash(struct file *file,\n\t\t\t\t\t     char __user *user_buf,\n\t\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tconst char buf[] =\n\t\t\"To simulate firmware crash write one of the keywords to this file:\\n\"\n\t\t\"`soft` - this will send WMI_FORCE_FW_HANG_ASSERT to firmware if FW supports that command.\\n\"\n\t\t\"`hard` - this will send to firmware command with illegal parameters causing firmware crash.\\n\"\n\t\t\"`assert` - this will send special illegal parameter to firmware to cause assert failure and crash.\\n\"\n\t\t\"`hw-restart` - this will simply queue hw restart without fw/hw actually crashing.\\n\";\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, strlen(buf));\n}\n\n \nstatic ssize_t ath10k_write_simulate_fw_crash(struct file *file,\n\t\t\t\t\t      const char __user *user_buf,\n\t\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct ath10k *ar = file->private_data;\n\tchar buf[32] = {0};\n\tssize_t rc;\n\tint ret;\n\n\t \n\tif (*ppos != 0 || count >= sizeof(buf) || count == 0)\n\t\treturn -EINVAL;\n\n\trc = simple_write_to_buffer(buf, sizeof(buf) - 1, ppos, user_buf, count);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tif (buf[*ppos - 1] == '\\n')\n\t\tbuf[*ppos - 1] = '\\0';\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (ar->state != ATH10K_STATE_ON &&\n\t    ar->state != ATH10K_STATE_RESTARTED) {\n\t\tret = -ENETDOWN;\n\t\tgoto exit;\n\t}\n\n\tif (!strcmp(buf, \"soft\")) {\n\t\tath10k_info(ar, \"simulating soft firmware crash\\n\");\n\t\tret = ath10k_wmi_force_fw_hang(ar, WMI_FORCE_FW_HANG_ASSERT, 0);\n\t} else if (!strcmp(buf, \"hard\")) {\n\t\tath10k_info(ar, \"simulating hard firmware crash\\n\");\n\t\t \n\t\tret = ath10k_wmi_vdev_set_param(ar, 0x7fff,\n\t\t\t\t\t\tar->wmi.vdev_param->rts_threshold,\n\t\t\t\t\t\t0);\n\t} else if (!strcmp(buf, \"assert\")) {\n\t\tath10k_info(ar, \"simulating firmware assert crash\\n\");\n\t\tret = ath10k_debug_fw_assert(ar);\n\t} else if (!strcmp(buf, \"hw-restart\")) {\n\t\tath10k_info(ar, \"user requested hw restart\\n\");\n\t\tath10k_core_start_recovery(ar);\n\t\tret = 0;\n\t} else {\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to simulate firmware crash: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tret = count;\n\nexit:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic const struct file_operations fops_simulate_fw_crash = {\n\t.read = ath10k_read_simulate_fw_crash,\n\t.write = ath10k_write_simulate_fw_crash,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t ath10k_read_chip_id(struct file *file, char __user *user_buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct ath10k *ar = file->private_data;\n\tsize_t len;\n\tchar buf[50];\n\n\tlen = scnprintf(buf, sizeof(buf), \"0x%08x\\n\", ar->bus_param.chip_id);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic const struct file_operations fops_chip_id = {\n\t.read = ath10k_read_chip_id,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t ath10k_reg_addr_read(struct file *file,\n\t\t\t\t    char __user *user_buf,\n\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct ath10k *ar = file->private_data;\n\tu8 buf[32];\n\tsize_t len = 0;\n\tu32 reg_addr;\n\n\tmutex_lock(&ar->conf_mutex);\n\treg_addr = ar->debug.reg_addr;\n\tmutex_unlock(&ar->conf_mutex);\n\n\tlen += scnprintf(buf + len, sizeof(buf) - len, \"0x%x\\n\", reg_addr);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic ssize_t ath10k_reg_addr_write(struct file *file,\n\t\t\t\t     const char __user *user_buf,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct ath10k *ar = file->private_data;\n\tu32 reg_addr;\n\tint ret;\n\n\tret = kstrtou32_from_user(user_buf, count, 0, &reg_addr);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!IS_ALIGNED(reg_addr, 4))\n\t\treturn -EFAULT;\n\n\tmutex_lock(&ar->conf_mutex);\n\tar->debug.reg_addr = reg_addr;\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn count;\n}\n\nstatic const struct file_operations fops_reg_addr = {\n\t.read = ath10k_reg_addr_read,\n\t.write = ath10k_reg_addr_write,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t ath10k_reg_value_read(struct file *file,\n\t\t\t\t     char __user *user_buf,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct ath10k *ar = file->private_data;\n\tu8 buf[48];\n\tsize_t len;\n\tu32 reg_addr, reg_val;\n\tint ret;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (ar->state != ATH10K_STATE_ON &&\n\t    ar->state != ATH10K_STATE_UTF) {\n\t\tret = -ENETDOWN;\n\t\tgoto exit;\n\t}\n\n\treg_addr = ar->debug.reg_addr;\n\n\treg_val = ath10k_hif_read32(ar, reg_addr);\n\tlen = scnprintf(buf, sizeof(buf), \"0x%08x:0x%08x\\n\", reg_addr, reg_val);\n\n\tret = simple_read_from_buffer(user_buf, count, ppos, buf, len);\n\nexit:\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn ret;\n}\n\nstatic ssize_t ath10k_reg_value_write(struct file *file,\n\t\t\t\t      const char __user *user_buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct ath10k *ar = file->private_data;\n\tu32 reg_addr, reg_val;\n\tint ret;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (ar->state != ATH10K_STATE_ON &&\n\t    ar->state != ATH10K_STATE_UTF) {\n\t\tret = -ENETDOWN;\n\t\tgoto exit;\n\t}\n\n\treg_addr = ar->debug.reg_addr;\n\n\tret = kstrtou32_from_user(user_buf, count, 0, &reg_val);\n\tif (ret)\n\t\tgoto exit;\n\n\tath10k_hif_write32(ar, reg_addr, reg_val);\n\n\tret = count;\n\nexit:\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn ret;\n}\n\nstatic const struct file_operations fops_reg_value = {\n\t.read = ath10k_reg_value_read,\n\t.write = ath10k_reg_value_write,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t ath10k_mem_value_read(struct file *file,\n\t\t\t\t     char __user *user_buf,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct ath10k *ar = file->private_data;\n\tu8 *buf;\n\tint ret;\n\n\tif (*ppos < 0)\n\t\treturn -EINVAL;\n\n\tif (!count)\n\t\treturn 0;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tbuf = vmalloc(count);\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\tif (ar->state != ATH10K_STATE_ON &&\n\t    ar->state != ATH10K_STATE_UTF) {\n\t\tret = -ENETDOWN;\n\t\tgoto exit;\n\t}\n\n\tret = ath10k_hif_diag_read(ar, *ppos, buf, count);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to read address 0x%08x via diagnose window from debugfs: %d\\n\",\n\t\t\t    (u32)(*ppos), ret);\n\t\tgoto exit;\n\t}\n\n\tret = copy_to_user(user_buf, buf, count);\n\tif (ret) {\n\t\tret = -EFAULT;\n\t\tgoto exit;\n\t}\n\n\tcount -= ret;\n\t*ppos += count;\n\tret = count;\n\nexit:\n\tvfree(buf);\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn ret;\n}\n\nstatic ssize_t ath10k_mem_value_write(struct file *file,\n\t\t\t\t      const char __user *user_buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct ath10k *ar = file->private_data;\n\tu8 *buf;\n\tint ret;\n\n\tif (*ppos < 0)\n\t\treturn -EINVAL;\n\n\tif (!count)\n\t\treturn 0;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tbuf = vmalloc(count);\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\tif (ar->state != ATH10K_STATE_ON &&\n\t    ar->state != ATH10K_STATE_UTF) {\n\t\tret = -ENETDOWN;\n\t\tgoto exit;\n\t}\n\n\tret = copy_from_user(buf, user_buf, count);\n\tif (ret) {\n\t\tret = -EFAULT;\n\t\tgoto exit;\n\t}\n\n\tret = ath10k_hif_diag_write(ar, *ppos, buf, count);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to write address 0x%08x via diagnose window from debugfs: %d\\n\",\n\t\t\t    (u32)(*ppos), ret);\n\t\tgoto exit;\n\t}\n\n\t*ppos += count;\n\tret = count;\n\nexit:\n\tvfree(buf);\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn ret;\n}\n\nstatic const struct file_operations fops_mem_value = {\n\t.read = ath10k_mem_value_read,\n\t.write = ath10k_mem_value_write,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic int ath10k_debug_htt_stats_req(struct ath10k *ar)\n{\n\tu64 cookie;\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (ar->debug.htt_stats_mask == 0)\n\t\t \n\t\treturn 0;\n\n\tif (ar->state != ATH10K_STATE_ON)\n\t\treturn 0;\n\n\tcookie = get_jiffies_64();\n\n\tret = ath10k_htt_h2t_stats_req(&ar->htt, ar->debug.htt_stats_mask,\n\t\t\t\t       ar->debug.reset_htt_stats, cookie);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to send htt stats request: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tqueue_delayed_work(ar->workqueue, &ar->debug.htt_stats_dwork,\n\t\t\t   msecs_to_jiffies(ATH10K_DEBUG_HTT_STATS_INTERVAL));\n\n\treturn 0;\n}\n\nstatic void ath10k_debug_htt_stats_dwork(struct work_struct *work)\n{\n\tstruct ath10k *ar = container_of(work, struct ath10k,\n\t\t\t\t\t debug.htt_stats_dwork.work);\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tath10k_debug_htt_stats_req(ar);\n\n\tmutex_unlock(&ar->conf_mutex);\n}\n\nstatic ssize_t ath10k_read_htt_stats_mask(struct file *file,\n\t\t\t\t\t  char __user *user_buf,\n\t\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct ath10k *ar = file->private_data;\n\tchar buf[32];\n\tsize_t len;\n\n\tlen = scnprintf(buf, sizeof(buf), \"%lu\\n\", ar->debug.htt_stats_mask);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic ssize_t ath10k_write_htt_stats_mask(struct file *file,\n\t\t\t\t\t   const char __user *user_buf,\n\t\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct ath10k *ar = file->private_data;\n\tunsigned long mask;\n\tint ret;\n\n\tret = kstrtoul_from_user(user_buf, count, 0, &mask);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (mask > HTT_STATS_BIT_MASK)\n\t\treturn -E2BIG;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tar->debug.htt_stats_mask = mask;\n\n\tret = ath10k_debug_htt_stats_req(ar);\n\tif (ret)\n\t\tgoto out;\n\n\tret = count;\n\nout:\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn ret;\n}\n\nstatic const struct file_operations fops_htt_stats_mask = {\n\t.read = ath10k_read_htt_stats_mask,\n\t.write = ath10k_write_htt_stats_mask,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t ath10k_read_htt_max_amsdu_ampdu(struct file *file,\n\t\t\t\t\t       char __user *user_buf,\n\t\t\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct ath10k *ar = file->private_data;\n\tchar buf[64];\n\tu8 amsdu, ampdu;\n\tsize_t len;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tamsdu = ar->htt.max_num_amsdu;\n\tampdu = ar->htt.max_num_ampdu;\n\tmutex_unlock(&ar->conf_mutex);\n\n\tlen = scnprintf(buf, sizeof(buf), \"%u %u\\n\", amsdu, ampdu);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic ssize_t ath10k_write_htt_max_amsdu_ampdu(struct file *file,\n\t\t\t\t\t\tconst char __user *user_buf,\n\t\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct ath10k *ar = file->private_data;\n\tint res;\n\tchar buf[64] = {0};\n\tunsigned int amsdu, ampdu;\n\n\tres = simple_write_to_buffer(buf, sizeof(buf) - 1, ppos,\n\t\t\t\t     user_buf, count);\n\tif (res <= 0)\n\t\treturn res;\n\n\tres = sscanf(buf, \"%u %u\", &amsdu, &ampdu);\n\n\tif (res != 2)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tres = ath10k_htt_h2t_aggr_cfg_msg(&ar->htt, ampdu, amsdu);\n\tif (res)\n\t\tgoto out;\n\n\tres = count;\n\tar->htt.max_num_amsdu = amsdu;\n\tar->htt.max_num_ampdu = ampdu;\n\nout:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn res;\n}\n\nstatic const struct file_operations fops_htt_max_amsdu_ampdu = {\n\t.read = ath10k_read_htt_max_amsdu_ampdu,\n\t.write = ath10k_write_htt_max_amsdu_ampdu,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t ath10k_read_fw_dbglog(struct file *file,\n\t\t\t\t     char __user *user_buf,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct ath10k *ar = file->private_data;\n\tsize_t len;\n\tchar buf[96];\n\n\tlen = scnprintf(buf, sizeof(buf), \"0x%16llx %u\\n\",\n\t\t\tar->debug.fw_dbglog_mask, ar->debug.fw_dbglog_level);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic ssize_t ath10k_write_fw_dbglog(struct file *file,\n\t\t\t\t      const char __user *user_buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct ath10k *ar = file->private_data;\n\tint ret;\n\tchar buf[96] = {0};\n\tunsigned int log_level;\n\tu64 mask;\n\n\tret = simple_write_to_buffer(buf, sizeof(buf) - 1, ppos,\n\t\t\t\t     user_buf, count);\n\tif (ret <= 0)\n\t\treturn ret;\n\n\tret = sscanf(buf, \"%llx %u\", &mask, &log_level);\n\n\tif (!ret)\n\t\treturn -EINVAL;\n\n\tif (ret == 1)\n\t\t \n\t\tlog_level = ATH10K_DBGLOG_LEVEL_WARN;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tar->debug.fw_dbglog_mask = mask;\n\tar->debug.fw_dbglog_level = log_level;\n\n\tif (ar->state == ATH10K_STATE_ON) {\n\t\tret = ath10k_wmi_dbglog_cfg(ar, ar->debug.fw_dbglog_mask,\n\t\t\t\t\t    ar->debug.fw_dbglog_level);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"dbglog cfg failed from debugfs: %d\\n\",\n\t\t\t\t    ret);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tret = count;\n\nexit:\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn ret;\n}\n\n \n\n \nstatic const char ath10k_gstrings_stats[][ETH_GSTRING_LEN] = {\n\t\"tx_pkts_nic\",\n\t\"tx_bytes_nic\",\n\t\"rx_pkts_nic\",\n\t\"rx_bytes_nic\",\n\t\"d_noise_floor\",\n\t\"d_cycle_count\",\n\t\"d_phy_error\",\n\t\"d_rts_bad\",\n\t\"d_rts_good\",\n\t\"d_tx_power\",  \n\t\"d_rx_crc_err\",  \n\t\"d_rx_crc_err_drop\",  \n\t\"d_no_beacon\",\n\t\"d_tx_mpdus_queued\",\n\t\"d_tx_msdu_queued\",\n\t\"d_tx_msdu_dropped\",\n\t\"d_local_enqued\",\n\t\"d_local_freed\",\n\t\"d_tx_ppdu_hw_queued\",\n\t\"d_tx_ppdu_reaped\",\n\t\"d_tx_fifo_underrun\",\n\t\"d_tx_ppdu_abort\",\n\t\"d_tx_mpdu_requeued\",\n\t\"d_tx_excessive_retries\",\n\t\"d_tx_hw_rate\",\n\t\"d_tx_dropped_sw_retries\",\n\t\"d_tx_illegal_rate\",\n\t\"d_tx_continuous_xretries\",\n\t\"d_tx_timeout\",\n\t\"d_tx_mpdu_txop_limit\",\n\t\"d_pdev_resets\",\n\t\"d_rx_mid_ppdu_route_change\",\n\t\"d_rx_status\",\n\t\"d_rx_extra_frags_ring0\",\n\t\"d_rx_extra_frags_ring1\",\n\t\"d_rx_extra_frags_ring2\",\n\t\"d_rx_extra_frags_ring3\",\n\t\"d_rx_msdu_htt\",\n\t\"d_rx_mpdu_htt\",\n\t\"d_rx_msdu_stack\",\n\t\"d_rx_mpdu_stack\",\n\t\"d_rx_phy_err\",\n\t\"d_rx_phy_err_drops\",\n\t\"d_rx_mpdu_errors\",  \n\t\"d_fw_crash_count\",\n\t\"d_fw_warm_reset_count\",\n\t\"d_fw_cold_reset_count\",\n};\n\n#define ATH10K_SSTATS_LEN ARRAY_SIZE(ath10k_gstrings_stats)\n\nvoid ath10k_debug_get_et_strings(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t u32 sset, u8 *data)\n{\n\tif (sset == ETH_SS_STATS)\n\t\tmemcpy(data, ath10k_gstrings_stats,\n\t\t       sizeof(ath10k_gstrings_stats));\n}\n\nint ath10k_debug_get_et_sset_count(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif, int sset)\n{\n\tif (sset == ETH_SS_STATS)\n\t\treturn ATH10K_SSTATS_LEN;\n\n\treturn 0;\n}\n\nvoid ath10k_debug_get_et_stats(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       struct ethtool_stats *stats, u64 *data)\n{\n\tstruct ath10k *ar = hw->priv;\n\tstatic const struct ath10k_fw_stats_pdev zero_stats = {};\n\tconst struct ath10k_fw_stats_pdev *pdev_stats;\n\tint i = 0, ret;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (ar->state == ATH10K_STATE_ON) {\n\t\tret = ath10k_debug_fw_stats_request(ar);\n\t\tif (ret) {\n\t\t\t \n\t\t\tath10k_warn(ar,\n\t\t\t\t    \"failed to get fw stats for ethtool: %d\\n\",\n\t\t\t\t    ret);\n\t\t}\n\t}\n\n\tpdev_stats = list_first_entry_or_null(&ar->debug.fw_stats.pdevs,\n\t\t\t\t\t      struct ath10k_fw_stats_pdev,\n\t\t\t\t\t      list);\n\tif (!pdev_stats) {\n\t\t \n\t\tpdev_stats = &zero_stats;\n\t}\n\n\tspin_lock_bh(&ar->data_lock);\n\n\tdata[i++] = pdev_stats->hw_reaped;  \n\tdata[i++] = 0;  \n\tdata[i++] = pdev_stats->htt_mpdus;\n\tdata[i++] = 0;  \n\tdata[i++] = pdev_stats->ch_noise_floor;\n\tdata[i++] = pdev_stats->cycle_count;\n\tdata[i++] = pdev_stats->phy_err_count;\n\tdata[i++] = pdev_stats->rts_bad;\n\tdata[i++] = pdev_stats->rts_good;\n\tdata[i++] = pdev_stats->chan_tx_power;\n\tdata[i++] = pdev_stats->fcs_bad;\n\tdata[i++] = ar->stats.rx_crc_err_drop;\n\tdata[i++] = pdev_stats->no_beacons;\n\tdata[i++] = pdev_stats->mpdu_enqued;\n\tdata[i++] = pdev_stats->msdu_enqued;\n\tdata[i++] = pdev_stats->wmm_drop;\n\tdata[i++] = pdev_stats->local_enqued;\n\tdata[i++] = pdev_stats->local_freed;\n\tdata[i++] = pdev_stats->hw_queued;\n\tdata[i++] = pdev_stats->hw_reaped;\n\tdata[i++] = pdev_stats->underrun;\n\tdata[i++] = pdev_stats->tx_abort;\n\tdata[i++] = pdev_stats->mpdus_requeued;\n\tdata[i++] = pdev_stats->tx_ko;\n\tdata[i++] = pdev_stats->data_rc;\n\tdata[i++] = pdev_stats->sw_retry_failure;\n\tdata[i++] = pdev_stats->illgl_rate_phy_err;\n\tdata[i++] = pdev_stats->pdev_cont_xretry;\n\tdata[i++] = pdev_stats->pdev_tx_timeout;\n\tdata[i++] = pdev_stats->txop_ovf;\n\tdata[i++] = pdev_stats->pdev_resets;\n\tdata[i++] = pdev_stats->mid_ppdu_route_change;\n\tdata[i++] = pdev_stats->status_rcvd;\n\tdata[i++] = pdev_stats->r0_frags;\n\tdata[i++] = pdev_stats->r1_frags;\n\tdata[i++] = pdev_stats->r2_frags;\n\tdata[i++] = pdev_stats->r3_frags;\n\tdata[i++] = pdev_stats->htt_msdus;\n\tdata[i++] = pdev_stats->htt_mpdus;\n\tdata[i++] = pdev_stats->loc_msdus;\n\tdata[i++] = pdev_stats->loc_mpdus;\n\tdata[i++] = pdev_stats->phy_errs;\n\tdata[i++] = pdev_stats->phy_err_drop;\n\tdata[i++] = pdev_stats->mpdu_errs;\n\tdata[i++] = ar->stats.fw_crash_counter;\n\tdata[i++] = ar->stats.fw_warm_reset_counter;\n\tdata[i++] = ar->stats.fw_cold_reset_counter;\n\n\tspin_unlock_bh(&ar->data_lock);\n\n\tmutex_unlock(&ar->conf_mutex);\n\n\tWARN_ON(i != ATH10K_SSTATS_LEN);\n}\n\nstatic const struct file_operations fops_fw_dbglog = {\n\t.read = ath10k_read_fw_dbglog,\n\t.write = ath10k_write_fw_dbglog,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic int ath10k_debug_cal_data_fetch(struct ath10k *ar)\n{\n\tu32 hi_addr;\n\t__le32 addr;\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (WARN_ON(ar->hw_params.cal_data_len > ATH10K_DEBUG_CAL_DATA_LEN))\n\t\treturn -EINVAL;\n\n\tif (ar->hw_params.cal_data_len == 0)\n\t\treturn -EOPNOTSUPP;\n\n\thi_addr = host_interest_item_address(HI_ITEM(hi_board_data));\n\n\tret = ath10k_hif_diag_read(ar, hi_addr, &addr, sizeof(addr));\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to read hi_board_data address: %d\\n\",\n\t\t\t    ret);\n\t\treturn ret;\n\t}\n\n\tret = ath10k_hif_diag_read(ar, le32_to_cpu(addr), ar->debug.cal_data,\n\t\t\t\t   ar->hw_params.cal_data_len);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to read calibration data: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_debug_cal_data_open(struct inode *inode, struct file *file)\n{\n\tstruct ath10k *ar = inode->i_private;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (ar->state == ATH10K_STATE_ON ||\n\t    ar->state == ATH10K_STATE_UTF) {\n\t\tath10k_debug_cal_data_fetch(ar);\n\t}\n\n\tfile->private_data = ar;\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn 0;\n}\n\nstatic ssize_t ath10k_debug_cal_data_read(struct file *file,\n\t\t\t\t\t  char __user *user_buf,\n\t\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct ath10k *ar = file->private_data;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tcount = simple_read_from_buffer(user_buf, count, ppos,\n\t\t\t\t\tar->debug.cal_data,\n\t\t\t\t\tar->hw_params.cal_data_len);\n\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn count;\n}\n\nstatic ssize_t ath10k_write_ani_enable(struct file *file,\n\t\t\t\t       const char __user *user_buf,\n\t\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct ath10k *ar = file->private_data;\n\tint ret;\n\tu8 enable;\n\n\tif (kstrtou8_from_user(user_buf, count, 0, &enable))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (ar->ani_enabled == enable) {\n\t\tret = count;\n\t\tgoto exit;\n\t}\n\n\tret = ath10k_wmi_pdev_set_param(ar, ar->wmi.pdev_param->ani_enable,\n\t\t\t\t\tenable);\n\tif (ret) {\n\t\tath10k_warn(ar, \"ani_enable failed from debugfs: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\tar->ani_enabled = enable;\n\n\tret = count;\n\nexit:\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn ret;\n}\n\nstatic ssize_t ath10k_read_ani_enable(struct file *file, char __user *user_buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct ath10k *ar = file->private_data;\n\tsize_t len;\n\tchar buf[32];\n\n\tlen = scnprintf(buf, sizeof(buf), \"%d\\n\", ar->ani_enabled);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic const struct file_operations fops_ani_enable = {\n\t.read = ath10k_read_ani_enable,\n\t.write = ath10k_write_ani_enable,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic const struct file_operations fops_cal_data = {\n\t.open = ath10k_debug_cal_data_open,\n\t.read = ath10k_debug_cal_data_read,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t ath10k_read_nf_cal_period(struct file *file,\n\t\t\t\t\t char __user *user_buf,\n\t\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct ath10k *ar = file->private_data;\n\tsize_t len;\n\tchar buf[32];\n\n\tlen = scnprintf(buf, sizeof(buf), \"%d\\n\", ar->debug.nf_cal_period);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic ssize_t ath10k_write_nf_cal_period(struct file *file,\n\t\t\t\t\t  const char __user *user_buf,\n\t\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct ath10k *ar = file->private_data;\n\tunsigned long period;\n\tint ret;\n\n\tret = kstrtoul_from_user(user_buf, count, 0, &period);\n\tif (ret)\n\t\treturn ret;\n\n\tif (period > WMI_PDEV_PARAM_CAL_PERIOD_MAX)\n\t\treturn -EINVAL;\n\n\t \n\tif (period == 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tar->debug.nf_cal_period = period;\n\n\tif (ar->state != ATH10K_STATE_ON) {\n\t\t \n\t\tret = count;\n\t\tgoto exit;\n\t}\n\n\tret = ath10k_wmi_pdev_set_param(ar, ar->wmi.pdev_param->cal_period,\n\t\t\t\t\tar->debug.nf_cal_period);\n\tif (ret) {\n\t\tath10k_warn(ar, \"cal period cfg failed from debugfs: %d\\n\",\n\t\t\t    ret);\n\t\tgoto exit;\n\t}\n\n\tret = count;\n\nexit:\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn ret;\n}\n\nstatic const struct file_operations fops_nf_cal_period = {\n\t.read = ath10k_read_nf_cal_period,\n\t.write = ath10k_write_nf_cal_period,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\n#define ATH10K_TPC_CONFIG_BUF_SIZE\t(1024 * 1024)\n\nstatic int ath10k_debug_tpc_stats_request(struct ath10k *ar)\n{\n\tint ret;\n\tunsigned long time_left;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\treinit_completion(&ar->debug.tpc_complete);\n\n\tret = ath10k_wmi_pdev_get_tpc_config(ar, WMI_TPC_CONFIG_PARAM);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to request tpc config: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ttime_left = wait_for_completion_timeout(&ar->debug.tpc_complete,\n\t\t\t\t\t\t1 * HZ);\n\tif (time_left == 0)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nvoid ath10k_debug_tpc_stats_process(struct ath10k *ar,\n\t\t\t\t    struct ath10k_tpc_stats *tpc_stats)\n{\n\tspin_lock_bh(&ar->data_lock);\n\n\tkfree(ar->debug.tpc_stats);\n\tar->debug.tpc_stats = tpc_stats;\n\tcomplete(&ar->debug.tpc_complete);\n\n\tspin_unlock_bh(&ar->data_lock);\n}\n\nvoid\nath10k_debug_tpc_stats_final_process(struct ath10k *ar,\n\t\t\t\t     struct ath10k_tpc_stats_final *tpc_stats)\n{\n\tspin_lock_bh(&ar->data_lock);\n\n\tkfree(ar->debug.tpc_stats_final);\n\tar->debug.tpc_stats_final = tpc_stats;\n\tcomplete(&ar->debug.tpc_complete);\n\n\tspin_unlock_bh(&ar->data_lock);\n}\n\nstatic void ath10k_tpc_stats_print(struct ath10k_tpc_stats *tpc_stats,\n\t\t\t\t   unsigned int j, char *buf, size_t *len)\n{\n\tint i;\n\tsize_t buf_len;\n\tstatic const char table_str[][5] = { \"CDD\",\n\t\t\t\t\t     \"STBC\",\n\t\t\t\t\t     \"TXBF\" };\n\tstatic const char pream_str[][6] = { \"CCK\",\n\t\t\t\t\t     \"OFDM\",\n\t\t\t\t\t     \"HT20\",\n\t\t\t\t\t     \"HT40\",\n\t\t\t\t\t     \"VHT20\",\n\t\t\t\t\t     \"VHT40\",\n\t\t\t\t\t     \"VHT80\",\n\t\t\t\t\t     \"HTCUP\" };\n\n\tbuf_len = ATH10K_TPC_CONFIG_BUF_SIZE;\n\t*len += scnprintf(buf + *len, buf_len - *len,\n\t\t\t  \"********************************\\n\");\n\t*len += scnprintf(buf + *len, buf_len - *len,\n\t\t\t  \"******************* %s POWER TABLE ****************\\n\",\n\t\t\t  table_str[j]);\n\t*len += scnprintf(buf + *len, buf_len - *len,\n\t\t\t  \"********************************\\n\");\n\t*len += scnprintf(buf + *len, buf_len - *len,\n\t\t\t  \"No.  Preamble Rate_code \");\n\n\tfor (i = 0; i < tpc_stats->num_tx_chain; i++)\n\t\t*len += scnprintf(buf + *len, buf_len - *len,\n\t\t\t\t  \"tpc_value%d \", i);\n\n\t*len += scnprintf(buf + *len, buf_len - *len, \"\\n\");\n\n\tfor (i = 0; i < tpc_stats->rate_max; i++) {\n\t\t*len += scnprintf(buf + *len, buf_len - *len,\n\t\t\t\t  \"%8d %s 0x%2x %s\\n\", i,\n\t\t\t\t  pream_str[tpc_stats->tpc_table[j].pream_idx[i]],\n\t\t\t\t  tpc_stats->tpc_table[j].rate_code[i],\n\t\t\t\t  tpc_stats->tpc_table[j].tpc_value[i]);\n\t}\n\n\t*len += scnprintf(buf + *len, buf_len - *len,\n\t\t\t  \"***********************************\\n\");\n}\n\nstatic void ath10k_tpc_stats_fill(struct ath10k *ar,\n\t\t\t\t  struct ath10k_tpc_stats *tpc_stats,\n\t\t\t\t  char *buf)\n{\n\tint j;\n\tsize_t len, buf_len;\n\n\tlen = 0;\n\tbuf_len = ATH10K_TPC_CONFIG_BUF_SIZE;\n\n\tspin_lock_bh(&ar->data_lock);\n\n\tif (!tpc_stats) {\n\t\tath10k_warn(ar, \"failed to get tpc stats\\n\");\n\t\tgoto unlock;\n\t}\n\n\tlen += scnprintf(buf + len, buf_len - len, \"\\n\");\n\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t \"*************************************\\n\");\n\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t \"TPC config for channel %4d mode %d\\n\",\n\t\t\t tpc_stats->chan_freq,\n\t\t\t tpc_stats->phy_mode);\n\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t \"*************************************\\n\");\n\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t \"CTL\t\t=  0x%2x Reg. Domain\t\t= %2d\\n\",\n\t\t\t tpc_stats->ctl,\n\t\t\t tpc_stats->reg_domain);\n\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t \"Antenna Gain\t= %2d Reg. Max Antenna Gain\t=  %2d\\n\",\n\t\t\t tpc_stats->twice_antenna_gain,\n\t\t\t tpc_stats->twice_antenna_reduction);\n\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t \"Power Limit\t= %2d Reg. Max Power\t\t= %2d\\n\",\n\t\t\t tpc_stats->power_limit,\n\t\t\t tpc_stats->twice_max_rd_power / 2);\n\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t \"Num tx chains\t= %2d Num supported rates\t= %2d\\n\",\n\t\t\t tpc_stats->num_tx_chain,\n\t\t\t tpc_stats->rate_max);\n\n\tfor (j = 0; j < WMI_TPC_FLAG; j++) {\n\t\tswitch (j) {\n\t\tcase WMI_TPC_TABLE_TYPE_CDD:\n\t\t\tif (tpc_stats->flag[j] == ATH10K_TPC_TABLE_TYPE_FLAG) {\n\t\t\t\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t\t\t\t \"CDD not supported\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tath10k_tpc_stats_print(tpc_stats, j, buf, &len);\n\t\t\tbreak;\n\t\tcase WMI_TPC_TABLE_TYPE_STBC:\n\t\t\tif (tpc_stats->flag[j] == ATH10K_TPC_TABLE_TYPE_FLAG) {\n\t\t\t\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t\t\t\t \"STBC not supported\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tath10k_tpc_stats_print(tpc_stats, j, buf, &len);\n\t\t\tbreak;\n\t\tcase WMI_TPC_TABLE_TYPE_TXBF:\n\t\t\tif (tpc_stats->flag[j] == ATH10K_TPC_TABLE_TYPE_FLAG) {\n\t\t\t\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t\t\t\t \"TXBF not supported\\n***************************\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tath10k_tpc_stats_print(tpc_stats, j, buf, &len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t\t\t \"Invalid Type\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\nunlock:\n\tspin_unlock_bh(&ar->data_lock);\n\n\tif (len >= buf_len)\n\t\tbuf[len - 1] = 0;\n\telse\n\t\tbuf[len] = 0;\n}\n\nstatic int ath10k_tpc_stats_open(struct inode *inode, struct file *file)\n{\n\tstruct ath10k *ar = inode->i_private;\n\tvoid *buf = NULL;\n\tint ret;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (ar->state != ATH10K_STATE_ON) {\n\t\tret = -ENETDOWN;\n\t\tgoto err_unlock;\n\t}\n\n\tbuf = vmalloc(ATH10K_TPC_CONFIG_BUF_SIZE);\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto err_unlock;\n\t}\n\n\tret = ath10k_debug_tpc_stats_request(ar);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to request tpc config stats: %d\\n\",\n\t\t\t    ret);\n\t\tgoto err_free;\n\t}\n\n\tath10k_tpc_stats_fill(ar, ar->debug.tpc_stats, buf);\n\tfile->private_data = buf;\n\n\tmutex_unlock(&ar->conf_mutex);\n\treturn 0;\n\nerr_free:\n\tvfree(buf);\n\nerr_unlock:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic int ath10k_tpc_stats_release(struct inode *inode, struct file *file)\n{\n\tvfree(file->private_data);\n\n\treturn 0;\n}\n\nstatic ssize_t ath10k_tpc_stats_read(struct file *file, char __user *user_buf,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tconst char *buf = file->private_data;\n\tsize_t len = strlen(buf);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic const struct file_operations fops_tpc_stats = {\n\t.open = ath10k_tpc_stats_open,\n\t.release = ath10k_tpc_stats_release,\n\t.read = ath10k_tpc_stats_read,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nint ath10k_debug_start(struct ath10k *ar)\n{\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tret = ath10k_debug_htt_stats_req(ar);\n\tif (ret)\n\t\t \n\t\tath10k_warn(ar, \"failed to start htt stats workqueue: %d\\n\",\n\t\t\t    ret);\n\n\tif (ar->debug.fw_dbglog_mask) {\n\t\tret = ath10k_wmi_dbglog_cfg(ar, ar->debug.fw_dbglog_mask,\n\t\t\t\t\t    ATH10K_DBGLOG_LEVEL_WARN);\n\t\tif (ret)\n\t\t\t \n\t\t\tath10k_warn(ar, \"failed to enable dbglog during start: %d\",\n\t\t\t\t    ret);\n\t}\n\n\tif (ar->pktlog_filter) {\n\t\tret = ath10k_wmi_pdev_pktlog_enable(ar,\n\t\t\t\t\t\t    ar->pktlog_filter);\n\t\tif (ret)\n\t\t\t \n\t\t\tath10k_warn(ar,\n\t\t\t\t    \"failed to enable pktlog filter %x: %d\\n\",\n\t\t\t\t    ar->pktlog_filter, ret);\n\t} else {\n\t\tret = ath10k_wmi_pdev_pktlog_disable(ar);\n\t\tif (ret)\n\t\t\t \n\t\t\tath10k_warn(ar, \"failed to disable pktlog: %d\\n\", ret);\n\t}\n\n\tif (ar->debug.nf_cal_period &&\n\t    !test_bit(ATH10K_FW_FEATURE_NON_BMI,\n\t\t      ar->normal_mode_fw.fw_file.fw_features)) {\n\t\tret = ath10k_wmi_pdev_set_param(ar,\n\t\t\t\t\t\tar->wmi.pdev_param->cal_period,\n\t\t\t\t\t\tar->debug.nf_cal_period);\n\t\tif (ret)\n\t\t\t \n\t\t\tath10k_warn(ar, \"cal period cfg failed from debug start: %d\\n\",\n\t\t\t\t    ret);\n\t}\n\n\treturn ret;\n}\n\nvoid ath10k_debug_stop(struct ath10k *ar)\n{\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (!test_bit(ATH10K_FW_FEATURE_NON_BMI,\n\t\t      ar->normal_mode_fw.fw_file.fw_features))\n\t\tath10k_debug_cal_data_fetch(ar);\n\n\t \n\tif (ar->debug.htt_stats_mask != 0)\n\t\tcancel_delayed_work(&ar->debug.htt_stats_dwork);\n\n\tath10k_wmi_pdev_pktlog_disable(ar);\n}\n\nstatic ssize_t ath10k_write_simulate_radar(struct file *file,\n\t\t\t\t\t   const char __user *user_buf,\n\t\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct ath10k *ar = file->private_data;\n\tstruct ath10k_vif *arvif;\n\n\t \n\tarvif = list_first_entry(&ar->arvifs, typeof(*arvif), list);\n\tif (!arvif->is_started)\n\t\treturn -EINVAL;\n\n\tieee80211_radar_detected(ar->hw);\n\n\treturn count;\n}\n\nstatic const struct file_operations fops_simulate_radar = {\n\t.write = ath10k_write_simulate_radar,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\n#define ATH10K_DFS_STAT(s, p) (\\\n\tlen += scnprintf(buf + len, size - len, \"%-28s : %10u\\n\", s, \\\n\t\t\t ar->debug.dfs_stats.p))\n\n#define ATH10K_DFS_POOL_STAT(s, p) (\\\n\tlen += scnprintf(buf + len, size - len, \"%-28s : %10u\\n\", s, \\\n\t\t\t ar->debug.dfs_pool_stats.p))\n\nstatic ssize_t ath10k_read_dfs_stats(struct file *file, char __user *user_buf,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tint retval = 0, len = 0;\n\tconst int size = 8000;\n\tstruct ath10k *ar = file->private_data;\n\tchar *buf;\n\n\tbuf = kzalloc(size, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\tif (!ar->dfs_detector) {\n\t\tlen += scnprintf(buf + len, size - len, \"DFS not enabled\\n\");\n\t\tgoto exit;\n\t}\n\n\tar->debug.dfs_pool_stats =\n\t\t\tar->dfs_detector->get_stats(ar->dfs_detector);\n\n\tlen += scnprintf(buf + len, size - len, \"Pulse detector statistics:\\n\");\n\n\tATH10K_DFS_STAT(\"reported phy errors\", phy_errors);\n\tATH10K_DFS_STAT(\"pulse events reported\", pulses_total);\n\tATH10K_DFS_STAT(\"DFS pulses detected\", pulses_detected);\n\tATH10K_DFS_STAT(\"DFS pulses discarded\", pulses_discarded);\n\tATH10K_DFS_STAT(\"Radars detected\", radar_detected);\n\n\tlen += scnprintf(buf + len, size - len, \"Global Pool statistics:\\n\");\n\tATH10K_DFS_POOL_STAT(\"Pool references\", pool_reference);\n\tATH10K_DFS_POOL_STAT(\"Pulses allocated\", pulse_allocated);\n\tATH10K_DFS_POOL_STAT(\"Pulses alloc error\", pulse_alloc_error);\n\tATH10K_DFS_POOL_STAT(\"Pulses in use\", pulse_used);\n\tATH10K_DFS_POOL_STAT(\"Seqs. allocated\", pseq_allocated);\n\tATH10K_DFS_POOL_STAT(\"Seqs. alloc error\", pseq_alloc_error);\n\tATH10K_DFS_POOL_STAT(\"Seqs. in use\", pseq_used);\n\nexit:\n\tif (len > size)\n\t\tlen = size;\n\n\tretval = simple_read_from_buffer(user_buf, count, ppos, buf, len);\n\tkfree(buf);\n\n\treturn retval;\n}\n\nstatic const struct file_operations fops_dfs_stats = {\n\t.read = ath10k_read_dfs_stats,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t ath10k_write_pktlog_filter(struct file *file,\n\t\t\t\t\t  const char __user *ubuf,\n\t\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct ath10k *ar = file->private_data;\n\tu32 filter;\n\tint ret;\n\n\tif (kstrtouint_from_user(ubuf, count, 0, &filter))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (ar->state != ATH10K_STATE_ON) {\n\t\tar->pktlog_filter = filter;\n\t\tret = count;\n\t\tgoto out;\n\t}\n\n\tif (filter == ar->pktlog_filter) {\n\t\tret = count;\n\t\tgoto out;\n\t}\n\n\tif (filter) {\n\t\tret = ath10k_wmi_pdev_pktlog_enable(ar, filter);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to enable pktlog filter %x: %d\\n\",\n\t\t\t\t    ar->pktlog_filter, ret);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tret = ath10k_wmi_pdev_pktlog_disable(ar);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to disable pktlog: %d\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tar->pktlog_filter = filter;\n\tret = count;\n\nout:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic ssize_t ath10k_read_pktlog_filter(struct file *file, char __user *ubuf,\n\t\t\t\t\t size_t count, loff_t *ppos)\n{\n\tchar buf[32];\n\tstruct ath10k *ar = file->private_data;\n\tint len = 0;\n\n\tmutex_lock(&ar->conf_mutex);\n\tlen = scnprintf(buf, sizeof(buf) - len, \"%08x\\n\",\n\t\t\tar->pktlog_filter);\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn simple_read_from_buffer(ubuf, count, ppos, buf, len);\n}\n\nstatic const struct file_operations fops_pktlog_filter = {\n\t.read = ath10k_read_pktlog_filter,\n\t.write = ath10k_write_pktlog_filter,\n\t.open = simple_open\n};\n\nstatic ssize_t ath10k_write_quiet_period(struct file *file,\n\t\t\t\t\t const char __user *ubuf,\n\t\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct ath10k *ar = file->private_data;\n\tu32 period;\n\n\tif (kstrtouint_from_user(ubuf, count, 0, &period))\n\t\treturn -EINVAL;\n\n\tif (period < ATH10K_QUIET_PERIOD_MIN) {\n\t\tath10k_warn(ar, \"Quiet period %u can not be lesser than 25ms\\n\",\n\t\t\t    period);\n\t\treturn -EINVAL;\n\t}\n\tmutex_lock(&ar->conf_mutex);\n\tar->thermal.quiet_period = period;\n\tath10k_thermal_set_throttling(ar);\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn count;\n}\n\nstatic ssize_t ath10k_read_quiet_period(struct file *file, char __user *ubuf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar buf[32];\n\tstruct ath10k *ar = file->private_data;\n\tint len = 0;\n\n\tmutex_lock(&ar->conf_mutex);\n\tlen = scnprintf(buf, sizeof(buf) - len, \"%d\\n\",\n\t\t\tar->thermal.quiet_period);\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn simple_read_from_buffer(ubuf, count, ppos, buf, len);\n}\n\nstatic const struct file_operations fops_quiet_period = {\n\t.read = ath10k_read_quiet_period,\n\t.write = ath10k_write_quiet_period,\n\t.open = simple_open\n};\n\nstatic ssize_t ath10k_write_btcoex(struct file *file,\n\t\t\t\t   const char __user *ubuf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct ath10k *ar = file->private_data;\n\tchar buf[32];\n\tsize_t buf_size;\n\tint ret;\n\tbool val;\n\tu32 pdev_param;\n\n\tbuf_size = min(count, (sizeof(buf) - 1));\n\tif (copy_from_user(buf, ubuf, buf_size))\n\t\treturn -EFAULT;\n\n\tbuf[buf_size] = '\\0';\n\n\tif (kstrtobool(buf, &val) != 0)\n\t\treturn -EINVAL;\n\n\tif (!ar->coex_support)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (ar->state != ATH10K_STATE_ON &&\n\t    ar->state != ATH10K_STATE_RESTARTED) {\n\t\tret = -ENETDOWN;\n\t\tgoto exit;\n\t}\n\n\tif (!(test_bit(ATH10K_FLAG_BTCOEX, &ar->dev_flags) ^ val)) {\n\t\tret = count;\n\t\tgoto exit;\n\t}\n\n\tpdev_param = ar->wmi.pdev_param->enable_btcoex;\n\tif (test_bit(ATH10K_FW_FEATURE_BTCOEX_PARAM,\n\t\t     ar->running_fw->fw_file.fw_features)) {\n\t\tret = ath10k_wmi_pdev_set_param(ar, pdev_param, val);\n\t\tif (ret) {\n\t\t\tath10k_warn(ar, \"failed to enable btcoex: %d\\n\", ret);\n\t\t\tret = count;\n\t\t\tgoto exit;\n\t\t}\n\t} else {\n\t\tath10k_info(ar, \"restarting firmware due to btcoex change\");\n\t\tath10k_core_start_recovery(ar);\n\t}\n\n\tif (val)\n\t\tset_bit(ATH10K_FLAG_BTCOEX, &ar->dev_flags);\n\telse\n\t\tclear_bit(ATH10K_FLAG_BTCOEX, &ar->dev_flags);\n\n\tret = count;\n\nexit:\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn ret;\n}\n\nstatic ssize_t ath10k_read_btcoex(struct file *file, char __user *ubuf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tchar buf[32];\n\tstruct ath10k *ar = file->private_data;\n\tint len = 0;\n\n\tmutex_lock(&ar->conf_mutex);\n\tlen = scnprintf(buf, sizeof(buf) - len, \"%d\\n\",\n\t\t\ttest_bit(ATH10K_FLAG_BTCOEX, &ar->dev_flags));\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn simple_read_from_buffer(ubuf, count, ppos, buf, len);\n}\n\nstatic const struct file_operations fops_btcoex = {\n\t.read = ath10k_read_btcoex,\n\t.write = ath10k_write_btcoex,\n\t.open = simple_open\n};\n\nstatic ssize_t ath10k_write_enable_extd_tx_stats(struct file *file,\n\t\t\t\t\t\t const char __user *ubuf,\n\t\t\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct ath10k *ar = file->private_data;\n\tu32 filter;\n\tint ret;\n\n\tif (kstrtouint_from_user(ubuf, count, 0, &filter))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (ar->state != ATH10K_STATE_ON) {\n\t\tar->debug.enable_extd_tx_stats = filter;\n\t\tret = count;\n\t\tgoto out;\n\t}\n\n\tif (filter == ar->debug.enable_extd_tx_stats) {\n\t\tret = count;\n\t\tgoto out;\n\t}\n\n\tar->debug.enable_extd_tx_stats = filter;\n\tret = count;\n\nout:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic ssize_t ath10k_read_enable_extd_tx_stats(struct file *file,\n\t\t\t\t\t\tchar __user *ubuf,\n\t\t\t\t\t\tsize_t count, loff_t *ppos)\n\n{\n\tchar buf[32];\n\tstruct ath10k *ar = file->private_data;\n\tint len = 0;\n\n\tmutex_lock(&ar->conf_mutex);\n\tlen = scnprintf(buf, sizeof(buf) - len, \"%08x\\n\",\n\t\t\tar->debug.enable_extd_tx_stats);\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn simple_read_from_buffer(ubuf, count, ppos, buf, len);\n}\n\nstatic const struct file_operations fops_enable_extd_tx_stats = {\n\t.read = ath10k_read_enable_extd_tx_stats,\n\t.write = ath10k_write_enable_extd_tx_stats,\n\t.open = simple_open\n};\n\nstatic ssize_t ath10k_write_peer_stats(struct file *file,\n\t\t\t\t       const char __user *ubuf,\n\t\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct ath10k *ar = file->private_data;\n\tchar buf[32];\n\tsize_t buf_size;\n\tint ret;\n\tbool val;\n\n\tbuf_size = min(count, (sizeof(buf) - 1));\n\tif (copy_from_user(buf, ubuf, buf_size))\n\t\treturn -EFAULT;\n\n\tbuf[buf_size] = '\\0';\n\n\tif (kstrtobool(buf, &val) != 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (ar->state != ATH10K_STATE_ON &&\n\t    ar->state != ATH10K_STATE_RESTARTED) {\n\t\tret = -ENETDOWN;\n\t\tgoto exit;\n\t}\n\n\tif (!(test_bit(ATH10K_FLAG_PEER_STATS, &ar->dev_flags) ^ val)) {\n\t\tret = count;\n\t\tgoto exit;\n\t}\n\n\tif (val)\n\t\tset_bit(ATH10K_FLAG_PEER_STATS, &ar->dev_flags);\n\telse\n\t\tclear_bit(ATH10K_FLAG_PEER_STATS, &ar->dev_flags);\n\n\tath10k_info(ar, \"restarting firmware due to Peer stats change\");\n\n\tath10k_core_start_recovery(ar);\n\tret = count;\n\nexit:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic ssize_t ath10k_read_peer_stats(struct file *file, char __user *ubuf,\n\t\t\t\t      size_t count, loff_t *ppos)\n\n{\n\tchar buf[32];\n\tstruct ath10k *ar = file->private_data;\n\tint len = 0;\n\n\tmutex_lock(&ar->conf_mutex);\n\tlen = scnprintf(buf, sizeof(buf) - len, \"%d\\n\",\n\t\t\ttest_bit(ATH10K_FLAG_PEER_STATS, &ar->dev_flags));\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn simple_read_from_buffer(ubuf, count, ppos, buf, len);\n}\n\nstatic const struct file_operations fops_peer_stats = {\n\t.read = ath10k_read_peer_stats,\n\t.write = ath10k_write_peer_stats,\n\t.open = simple_open\n};\n\nstatic ssize_t ath10k_debug_fw_checksums_read(struct file *file,\n\t\t\t\t\t      char __user *user_buf,\n\t\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct ath10k *ar = file->private_data;\n\tsize_t len = 0, buf_len = 4096;\n\tssize_t ret_cnt;\n\tchar *buf;\n\n\tbuf = kzalloc(buf_len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t \"firmware-N.bin\\t\\t%08x\\n\",\n\t\t\t crc32_le(0, ar->normal_mode_fw.fw_file.firmware->data,\n\t\t\t\t  ar->normal_mode_fw.fw_file.firmware->size));\n\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t \"athwlan\\t\\t\\t%08x\\n\",\n\t\t\t crc32_le(0, ar->normal_mode_fw.fw_file.firmware_data,\n\t\t\t\t  ar->normal_mode_fw.fw_file.firmware_len));\n\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t \"otp\\t\\t\\t%08x\\n\",\n\t\t\t crc32_le(0, ar->normal_mode_fw.fw_file.otp_data,\n\t\t\t\t  ar->normal_mode_fw.fw_file.otp_len));\n\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t \"codeswap\\t\\t%08x\\n\",\n\t\t\t crc32_le(0, ar->normal_mode_fw.fw_file.codeswap_data,\n\t\t\t\t  ar->normal_mode_fw.fw_file.codeswap_len));\n\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t \"board-N.bin\\t\\t%08x\\n\",\n\t\t\t crc32_le(0, ar->normal_mode_fw.board->data,\n\t\t\t\t  ar->normal_mode_fw.board->size));\n\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t \"board\\t\\t\\t%08x\\n\",\n\t\t\t crc32_le(0, ar->normal_mode_fw.board_data,\n\t\t\t\t  ar->normal_mode_fw.board_len));\n\n\tret_cnt = simple_read_from_buffer(user_buf, count, ppos, buf, len);\n\n\tmutex_unlock(&ar->conf_mutex);\n\n\tkfree(buf);\n\treturn ret_cnt;\n}\n\nstatic const struct file_operations fops_fw_checksums = {\n\t.read = ath10k_debug_fw_checksums_read,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t ath10k_sta_tid_stats_mask_read(struct file *file,\n\t\t\t\t\t      char __user *user_buf,\n\t\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct ath10k *ar = file->private_data;\n\tchar buf[32];\n\tsize_t len;\n\n\tlen = scnprintf(buf, sizeof(buf), \"0x%08x\\n\", ar->sta_tid_stats_mask);\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic ssize_t ath10k_sta_tid_stats_mask_write(struct file *file,\n\t\t\t\t\t       const char __user *user_buf,\n\t\t\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct ath10k *ar = file->private_data;\n\tchar buf[32];\n\tssize_t len;\n\tu32 mask;\n\n\tlen = min(count, sizeof(buf) - 1);\n\tif (copy_from_user(buf, user_buf, len))\n\t\treturn -EFAULT;\n\n\tbuf[len] = '\\0';\n\tif (kstrtoint(buf, 0, &mask))\n\t\treturn -EINVAL;\n\n\tar->sta_tid_stats_mask = mask;\n\n\treturn len;\n}\n\nstatic const struct file_operations fops_sta_tid_stats_mask = {\n\t.read = ath10k_sta_tid_stats_mask_read,\n\t.write = ath10k_sta_tid_stats_mask_write,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic int ath10k_debug_tpc_stats_final_request(struct ath10k *ar)\n{\n\tint ret;\n\tunsigned long time_left;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\treinit_completion(&ar->debug.tpc_complete);\n\n\tret = ath10k_wmi_pdev_get_tpc_table_cmdid(ar, WMI_TPC_CONFIG_PARAM);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to request tpc table cmdid: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ttime_left = wait_for_completion_timeout(&ar->debug.tpc_complete,\n\t\t\t\t\t\t1 * HZ);\n\tif (time_left == 0)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic int ath10k_tpc_stats_final_open(struct inode *inode, struct file *file)\n{\n\tstruct ath10k *ar = inode->i_private;\n\tvoid *buf;\n\tint ret;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (ar->state != ATH10K_STATE_ON) {\n\t\tret = -ENETDOWN;\n\t\tgoto err_unlock;\n\t}\n\n\tbuf = vmalloc(ATH10K_TPC_CONFIG_BUF_SIZE);\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto err_unlock;\n\t}\n\n\tret = ath10k_debug_tpc_stats_final_request(ar);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to request tpc stats final: %d\\n\",\n\t\t\t    ret);\n\t\tgoto err_free;\n\t}\n\n\tath10k_tpc_stats_fill(ar, ar->debug.tpc_stats, buf);\n\tfile->private_data = buf;\n\n\tmutex_unlock(&ar->conf_mutex);\n\treturn 0;\n\nerr_free:\n\tvfree(buf);\n\nerr_unlock:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic int ath10k_tpc_stats_final_release(struct inode *inode,\n\t\t\t\t\t  struct file *file)\n{\n\tvfree(file->private_data);\n\n\treturn 0;\n}\n\nstatic ssize_t ath10k_tpc_stats_final_read(struct file *file,\n\t\t\t\t\t   char __user *user_buf,\n\t\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tconst char *buf = file->private_data;\n\tunsigned int len = strlen(buf);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic const struct file_operations fops_tpc_stats_final = {\n\t.open = ath10k_tpc_stats_final_open,\n\t.release = ath10k_tpc_stats_final_release,\n\t.read = ath10k_tpc_stats_final_read,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t ath10k_write_warm_hw_reset(struct file *file,\n\t\t\t\t\t  const char __user *user_buf,\n\t\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct ath10k *ar = file->private_data;\n\tint ret;\n\tbool val;\n\n\tif (kstrtobool_from_user(user_buf, count, &val))\n\t\treturn -EFAULT;\n\n\tif (!val)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (ar->state != ATH10K_STATE_ON) {\n\t\tret = -ENETDOWN;\n\t\tgoto exit;\n\t}\n\n\tret = ath10k_wmi_pdev_set_param(ar, ar->wmi.pdev_param->pdev_reset,\n\t\t\t\t\tWMI_RST_MODE_WARM_RESET);\n\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to enable warm hw reset: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tret = count;\n\nexit:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic const struct file_operations fops_warm_hw_reset = {\n\t.write = ath10k_write_warm_hw_reset,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic void ath10k_peer_ps_state_disable(void *data,\n\t\t\t\t\t struct ieee80211_sta *sta)\n{\n\tstruct ath10k *ar = data;\n\tstruct ath10k_sta *arsta = (struct ath10k_sta *)sta->drv_priv;\n\n\tspin_lock_bh(&ar->data_lock);\n\tarsta->peer_ps_state = WMI_PEER_PS_STATE_DISABLED;\n\tspin_unlock_bh(&ar->data_lock);\n}\n\nstatic ssize_t ath10k_write_ps_state_enable(struct file *file,\n\t\t\t\t\t    const char __user *user_buf,\n\t\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct ath10k *ar = file->private_data;\n\tint ret;\n\tu32 param;\n\tu8 ps_state_enable;\n\n\tif (kstrtou8_from_user(user_buf, count, 0, &ps_state_enable))\n\t\treturn -EINVAL;\n\n\tif (ps_state_enable > 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (ar->ps_state_enable == ps_state_enable) {\n\t\tret = count;\n\t\tgoto exit;\n\t}\n\n\tparam = ar->wmi.pdev_param->peer_sta_ps_statechg_enable;\n\tret = ath10k_wmi_pdev_set_param(ar, param, ps_state_enable);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to enable ps_state_enable: %d\\n\",\n\t\t\t    ret);\n\t\tgoto exit;\n\t}\n\tar->ps_state_enable = ps_state_enable;\n\n\tif (!ar->ps_state_enable)\n\t\tieee80211_iterate_stations_atomic(ar->hw,\n\t\t\t\t\t\t  ath10k_peer_ps_state_disable,\n\t\t\t\t\t\t  ar);\n\n\tret = count;\n\nexit:\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn ret;\n}\n\nstatic ssize_t ath10k_read_ps_state_enable(struct file *file,\n\t\t\t\t\t   char __user *user_buf,\n\t\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct ath10k *ar = file->private_data;\n\tint len = 0;\n\tchar buf[32];\n\n\tmutex_lock(&ar->conf_mutex);\n\tlen = scnprintf(buf, sizeof(buf) - len, \"%d\\n\",\n\t\t\tar->ps_state_enable);\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic const struct file_operations fops_ps_state_enable = {\n\t.read = ath10k_read_ps_state_enable,\n\t.write = ath10k_write_ps_state_enable,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t ath10k_write_reset_htt_stats(struct file *file,\n\t\t\t\t\t    const char __user *user_buf,\n\t\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct ath10k *ar = file->private_data;\n\tunsigned long reset;\n\tint ret;\n\n\tret = kstrtoul_from_user(user_buf, count, 0, &reset);\n\tif (ret)\n\t\treturn ret;\n\n\tif (reset == 0 || reset > 0x1ffff)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tar->debug.reset_htt_stats = reset;\n\n\tret = ath10k_debug_htt_stats_req(ar);\n\tif (ret)\n\t\tgoto out;\n\n\tar->debug.reset_htt_stats = 0;\n\tret = count;\n\nout:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic const struct file_operations fops_reset_htt_stats = {\n\t.write = ath10k_write_reset_htt_stats,\n\t.owner = THIS_MODULE,\n\t.open = simple_open,\n\t.llseek = default_llseek,\n};\n\nint ath10k_debug_create(struct ath10k *ar)\n{\n\tar->debug.cal_data = vzalloc(ATH10K_DEBUG_CAL_DATA_LEN);\n\tif (!ar->debug.cal_data)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&ar->debug.fw_stats.pdevs);\n\tINIT_LIST_HEAD(&ar->debug.fw_stats.vdevs);\n\tINIT_LIST_HEAD(&ar->debug.fw_stats.peers);\n\tINIT_LIST_HEAD(&ar->debug.fw_stats.peers_extd);\n\n\treturn 0;\n}\n\nvoid ath10k_debug_destroy(struct ath10k *ar)\n{\n\tvfree(ar->debug.cal_data);\n\tar->debug.cal_data = NULL;\n\n\tath10k_debug_fw_stats_reset(ar);\n\n\tkfree(ar->debug.tpc_stats);\n\tkfree(ar->debug.tpc_stats_final);\n}\n\nint ath10k_debug_register(struct ath10k *ar)\n{\n\tar->debug.debugfs_phy = debugfs_create_dir(\"ath10k\",\n\t\t\t\t\t\t   ar->hw->wiphy->debugfsdir);\n\tif (IS_ERR_OR_NULL(ar->debug.debugfs_phy)) {\n\t\tif (IS_ERR(ar->debug.debugfs_phy))\n\t\t\treturn PTR_ERR(ar->debug.debugfs_phy);\n\n\t\treturn -ENOMEM;\n\t}\n\n\tINIT_DELAYED_WORK(&ar->debug.htt_stats_dwork,\n\t\t\t  ath10k_debug_htt_stats_dwork);\n\n\tinit_completion(&ar->debug.tpc_complete);\n\tinit_completion(&ar->debug.fw_stats_complete);\n\n\tdebugfs_create_file(\"fw_stats\", 0400, ar->debug.debugfs_phy, ar,\n\t\t\t    &fops_fw_stats);\n\n\tdebugfs_create_file(\"fw_reset_stats\", 0400, ar->debug.debugfs_phy, ar,\n\t\t\t    &fops_fw_reset_stats);\n\n\tdebugfs_create_file(\"wmi_services\", 0400, ar->debug.debugfs_phy, ar,\n\t\t\t    &fops_wmi_services);\n\n\tdebugfs_create_file(\"simulate_fw_crash\", 0600, ar->debug.debugfs_phy, ar,\n\t\t\t    &fops_simulate_fw_crash);\n\n\tdebugfs_create_file(\"reg_addr\", 0600, ar->debug.debugfs_phy, ar,\n\t\t\t    &fops_reg_addr);\n\n\tdebugfs_create_file(\"reg_value\", 0600, ar->debug.debugfs_phy, ar,\n\t\t\t    &fops_reg_value);\n\n\tdebugfs_create_file(\"mem_value\", 0600, ar->debug.debugfs_phy, ar,\n\t\t\t    &fops_mem_value);\n\n\tdebugfs_create_file(\"chip_id\", 0400, ar->debug.debugfs_phy, ar,\n\t\t\t    &fops_chip_id);\n\n\tdebugfs_create_file(\"htt_stats_mask\", 0600, ar->debug.debugfs_phy, ar,\n\t\t\t    &fops_htt_stats_mask);\n\n\tdebugfs_create_file(\"htt_max_amsdu_ampdu\", 0600, ar->debug.debugfs_phy, ar,\n\t\t\t    &fops_htt_max_amsdu_ampdu);\n\n\tdebugfs_create_file(\"fw_dbglog\", 0600, ar->debug.debugfs_phy, ar,\n\t\t\t    &fops_fw_dbglog);\n\n\tif (!test_bit(ATH10K_FW_FEATURE_NON_BMI,\n\t\t      ar->normal_mode_fw.fw_file.fw_features)) {\n\t\tdebugfs_create_file(\"cal_data\", 0400, ar->debug.debugfs_phy, ar,\n\t\t\t\t    &fops_cal_data);\n\n\t\tdebugfs_create_file(\"nf_cal_period\", 0600, ar->debug.debugfs_phy, ar,\n\t\t\t\t    &fops_nf_cal_period);\n\t}\n\n\tdebugfs_create_file(\"ani_enable\", 0600, ar->debug.debugfs_phy, ar,\n\t\t\t    &fops_ani_enable);\n\n\tif (IS_ENABLED(CONFIG_ATH10K_DFS_CERTIFIED)) {\n\t\tdebugfs_create_file(\"dfs_simulate_radar\", 0200, ar->debug.debugfs_phy,\n\t\t\t\t    ar, &fops_simulate_radar);\n\n\t\tdebugfs_create_bool(\"dfs_block_radar_events\", 0200,\n\t\t\t\t    ar->debug.debugfs_phy,\n\t\t\t\t    &ar->dfs_block_radar_events);\n\n\t\tdebugfs_create_file(\"dfs_stats\", 0400, ar->debug.debugfs_phy, ar,\n\t\t\t\t    &fops_dfs_stats);\n\t}\n\n\tdebugfs_create_file(\"pktlog_filter\", 0644, ar->debug.debugfs_phy, ar,\n\t\t\t    &fops_pktlog_filter);\n\n\tif (test_bit(WMI_SERVICE_THERM_THROT, ar->wmi.svc_map))\n\t\tdebugfs_create_file(\"quiet_period\", 0644, ar->debug.debugfs_phy, ar,\n\t\t\t\t    &fops_quiet_period);\n\n\tdebugfs_create_file(\"tpc_stats\", 0400, ar->debug.debugfs_phy, ar,\n\t\t\t    &fops_tpc_stats);\n\n\tif (test_bit(WMI_SERVICE_COEX_GPIO, ar->wmi.svc_map))\n\t\tdebugfs_create_file(\"btcoex\", 0644, ar->debug.debugfs_phy, ar,\n\t\t\t\t    &fops_btcoex);\n\n\tif (test_bit(WMI_SERVICE_PEER_STATS, ar->wmi.svc_map)) {\n\t\tdebugfs_create_file(\"peer_stats\", 0644, ar->debug.debugfs_phy, ar,\n\t\t\t\t    &fops_peer_stats);\n\n\t\tdebugfs_create_file(\"enable_extd_tx_stats\", 0644,\n\t\t\t\t    ar->debug.debugfs_phy, ar,\n\t\t\t\t    &fops_enable_extd_tx_stats);\n\t}\n\n\tdebugfs_create_file(\"fw_checksums\", 0400, ar->debug.debugfs_phy, ar,\n\t\t\t    &fops_fw_checksums);\n\n\tif (IS_ENABLED(CONFIG_MAC80211_DEBUGFS))\n\t\tdebugfs_create_file(\"sta_tid_stats_mask\", 0600,\n\t\t\t\t    ar->debug.debugfs_phy,\n\t\t\t\t    ar, &fops_sta_tid_stats_mask);\n\n\tif (test_bit(WMI_SERVICE_TPC_STATS_FINAL, ar->wmi.svc_map))\n\t\tdebugfs_create_file(\"tpc_stats_final\", 0400,\n\t\t\t\t    ar->debug.debugfs_phy, ar,\n\t\t\t\t    &fops_tpc_stats_final);\n\n\tif (test_bit(WMI_SERVICE_RESET_CHIP, ar->wmi.svc_map))\n\t\tdebugfs_create_file(\"warm_hw_reset\", 0600,\n\t\t\t\t    ar->debug.debugfs_phy, ar,\n\t\t\t\t    &fops_warm_hw_reset);\n\n\tdebugfs_create_file(\"ps_state_enable\", 0600, ar->debug.debugfs_phy, ar,\n\t\t\t    &fops_ps_state_enable);\n\n\tdebugfs_create_file(\"reset_htt_stats\", 0200, ar->debug.debugfs_phy, ar,\n\t\t\t    &fops_reset_htt_stats);\n\n\treturn 0;\n}\n\nvoid ath10k_debug_unregister(struct ath10k *ar)\n{\n\tcancel_delayed_work_sync(&ar->debug.htt_stats_dwork);\n}\n\n#endif  \n\n#ifdef CONFIG_ATH10K_DEBUG\nvoid __ath10k_dbg(struct ath10k *ar, enum ath10k_debug_mask mask,\n\t\t  const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tif (ath10k_debug_mask & mask)\n\t\tdev_printk(KERN_DEBUG, ar->dev, \"%pV\", &vaf);\n\n\ttrace_ath10k_log_dbg(ar, mask, &vaf);\n\n\tva_end(args);\n}\nEXPORT_SYMBOL(__ath10k_dbg);\n\nvoid ath10k_dbg_dump(struct ath10k *ar,\n\t\t     enum ath10k_debug_mask mask,\n\t\t     const char *msg, const char *prefix,\n\t\t     const void *buf, size_t len)\n{\n\tchar linebuf[256];\n\tsize_t linebuflen;\n\tconst void *ptr;\n\n\tif (ath10k_debug_mask & mask) {\n\t\tif (msg)\n\t\t\t__ath10k_dbg(ar, mask, \"%s\\n\", msg);\n\n\t\tfor (ptr = buf; (ptr - buf) < len; ptr += 16) {\n\t\t\tlinebuflen = 0;\n\t\t\tlinebuflen += scnprintf(linebuf + linebuflen,\n\t\t\t\t\t\tsizeof(linebuf) - linebuflen,\n\t\t\t\t\t\t\"%s%08x: \",\n\t\t\t\t\t\t(prefix ? prefix : \"\"),\n\t\t\t\t\t\t(unsigned int)(ptr - buf));\n\t\t\thex_dump_to_buffer(ptr, len - (ptr - buf), 16, 1,\n\t\t\t\t\t   linebuf + linebuflen,\n\t\t\t\t\t   sizeof(linebuf) - linebuflen, true);\n\t\t\tdev_printk(KERN_DEBUG, ar->dev, \"%s\\n\", linebuf);\n\t\t}\n\t}\n\n\t \n\ttrace_ath10k_log_dbg_dump(ar, msg ? msg : \"\", prefix ? prefix : \"\",\n\t\t\t\t  buf, len);\n}\nEXPORT_SYMBOL(ath10k_dbg_dump);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}