{
  "module_name": "debugfs_sta.c",
  "hash_id": "aa9d286464bcd8fc646312ef6b47311d1b0febc76936361e60d2613ec8f8f870",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath10k/debugfs_sta.c",
  "human_readable_source": "\n \n\n#include \"core.h\"\n#include \"wmi-ops.h\"\n#include \"txrx.h\"\n#include \"debug.h\"\n\nstatic void ath10k_rx_stats_update_amsdu_subfrm(struct ath10k *ar,\n\t\t\t\t\t\tstruct ath10k_sta_tid_stats *stats,\n\t\t\t\t\t\tu32 msdu_count)\n{\n\tif (msdu_count == 1)\n\t\tstats->rx_pkt_amsdu[ATH10K_AMSDU_SUBFRM_NUM_1]++;\n\telse if (msdu_count == 2)\n\t\tstats->rx_pkt_amsdu[ATH10K_AMSDU_SUBFRM_NUM_2]++;\n\telse if (msdu_count == 3)\n\t\tstats->rx_pkt_amsdu[ATH10K_AMSDU_SUBFRM_NUM_3]++;\n\telse if (msdu_count == 4)\n\t\tstats->rx_pkt_amsdu[ATH10K_AMSDU_SUBFRM_NUM_4]++;\n\telse if (msdu_count > 4)\n\t\tstats->rx_pkt_amsdu[ATH10K_AMSDU_SUBFRM_NUM_MORE]++;\n}\n\nstatic void ath10k_rx_stats_update_ampdu_subfrm(struct ath10k *ar,\n\t\t\t\t\t\tstruct ath10k_sta_tid_stats *stats,\n\t\t\t\t\t\tu32 mpdu_count)\n{\n\tif (mpdu_count <= 10)\n\t\tstats->rx_pkt_ampdu[ATH10K_AMPDU_SUBFRM_NUM_10]++;\n\telse if (mpdu_count <= 20)\n\t\tstats->rx_pkt_ampdu[ATH10K_AMPDU_SUBFRM_NUM_20]++;\n\telse if (mpdu_count <= 30)\n\t\tstats->rx_pkt_ampdu[ATH10K_AMPDU_SUBFRM_NUM_30]++;\n\telse if (mpdu_count <= 40)\n\t\tstats->rx_pkt_ampdu[ATH10K_AMPDU_SUBFRM_NUM_40]++;\n\telse if (mpdu_count <= 50)\n\t\tstats->rx_pkt_ampdu[ATH10K_AMPDU_SUBFRM_NUM_50]++;\n\telse if (mpdu_count <= 60)\n\t\tstats->rx_pkt_ampdu[ATH10K_AMPDU_SUBFRM_NUM_60]++;\n\telse if (mpdu_count > 60)\n\t\tstats->rx_pkt_ampdu[ATH10K_AMPDU_SUBFRM_NUM_MORE]++;\n}\n\nvoid ath10k_sta_update_rx_tid_stats_ampdu(struct ath10k *ar, u16 peer_id, u8 tid,\n\t\t\t\t\t  struct htt_rx_indication_mpdu_range *ranges,\n\t\t\t\t\t  int num_ranges)\n{\n\tstruct ath10k_sta *arsta;\n\tstruct ath10k_peer *peer;\n\tint i;\n\n\tif (tid > IEEE80211_NUM_TIDS || !(ar->sta_tid_stats_mask & BIT(tid)))\n\t\treturn;\n\n\trcu_read_lock();\n\tspin_lock_bh(&ar->data_lock);\n\n\tpeer = ath10k_peer_find_by_id(ar, peer_id);\n\tif (!peer || !peer->sta)\n\t\tgoto out;\n\n\tarsta = (struct ath10k_sta *)peer->sta->drv_priv;\n\n\tfor (i = 0; i < num_ranges; i++)\n\t\tath10k_rx_stats_update_ampdu_subfrm(ar,\n\t\t\t\t\t\t    &arsta->tid_stats[tid],\n\t\t\t\t\t\t    ranges[i].mpdu_count);\n\nout:\n\tspin_unlock_bh(&ar->data_lock);\n\trcu_read_unlock();\n}\n\nvoid ath10k_sta_update_rx_tid_stats(struct ath10k *ar, u8 *first_hdr,\n\t\t\t\t    unsigned long num_msdus,\n\t\t\t\t    enum ath10k_pkt_rx_err err,\n\t\t\t\t    unsigned long unchain_cnt,\n\t\t\t\t    unsigned long drop_cnt,\n\t\t\t\t    unsigned long drop_cnt_filter,\n\t\t\t\t    unsigned long queued_msdus)\n{\n\tstruct ieee80211_sta *sta;\n\tstruct ath10k_sta *arsta;\n\tstruct ieee80211_hdr *hdr;\n\tstruct ath10k_sta_tid_stats *stats;\n\tu8 tid = IEEE80211_NUM_TIDS;\n\tbool non_data_frm = false;\n\n\thdr = (struct ieee80211_hdr *)first_hdr;\n\tif (!ieee80211_is_data(hdr->frame_control))\n\t\tnon_data_frm = true;\n\n\tif (ieee80211_is_data_qos(hdr->frame_control))\n\t\ttid = *ieee80211_get_qos_ctl(hdr) & IEEE80211_QOS_CTL_TID_MASK;\n\n\tif (!(ar->sta_tid_stats_mask & BIT(tid)) || non_data_frm)\n\t\treturn;\n\n\trcu_read_lock();\n\n\tsta = ieee80211_find_sta_by_ifaddr(ar->hw, hdr->addr2, NULL);\n\tif (!sta)\n\t\tgoto exit;\n\n\tarsta = (struct ath10k_sta *)sta->drv_priv;\n\n\tspin_lock_bh(&ar->data_lock);\n\tstats = &arsta->tid_stats[tid];\n\tstats->rx_pkt_from_fw += num_msdus;\n\tstats->rx_pkt_unchained += unchain_cnt;\n\tstats->rx_pkt_drop_chained += drop_cnt;\n\tstats->rx_pkt_drop_filter += drop_cnt_filter;\n\tif (err != ATH10K_PKT_RX_ERR_MAX)\n\t\tstats->rx_pkt_err[err] += queued_msdus;\n\tstats->rx_pkt_queued_for_mac += queued_msdus;\n\tath10k_rx_stats_update_amsdu_subfrm(ar, &arsta->tid_stats[tid],\n\t\t\t\t\t    num_msdus);\n\tspin_unlock_bh(&ar->data_lock);\n\nexit:\n\trcu_read_unlock();\n}\n\nstatic void ath10k_sta_update_extd_stats_rx_duration(struct ath10k *ar,\n\t\t\t\t\t\t     struct ath10k_fw_stats *stats)\n{\n\tstruct ath10k_fw_extd_stats_peer *peer;\n\tstruct ieee80211_sta *sta;\n\tstruct ath10k_sta *arsta;\n\n\trcu_read_lock();\n\tlist_for_each_entry(peer, &stats->peers_extd, list) {\n\t\tsta = ieee80211_find_sta_by_ifaddr(ar->hw, peer->peer_macaddr,\n\t\t\t\t\t\t   NULL);\n\t\tif (!sta)\n\t\t\tcontinue;\n\t\tarsta = (struct ath10k_sta *)sta->drv_priv;\n\t\tarsta->rx_duration += (u64)peer->rx_duration;\n\t}\n\trcu_read_unlock();\n}\n\nstatic void ath10k_sta_update_stats_rx_duration(struct ath10k *ar,\n\t\t\t\t\t\tstruct ath10k_fw_stats *stats)\n{\n\tstruct ath10k_fw_stats_peer *peer;\n\tstruct ieee80211_sta *sta;\n\tstruct ath10k_sta *arsta;\n\n\trcu_read_lock();\n\tlist_for_each_entry(peer, &stats->peers, list) {\n\t\tsta = ieee80211_find_sta_by_ifaddr(ar->hw, peer->peer_macaddr,\n\t\t\t\t\t\t   NULL);\n\t\tif (!sta)\n\t\t\tcontinue;\n\t\tarsta = (struct ath10k_sta *)sta->drv_priv;\n\t\tarsta->rx_duration += (u64)peer->rx_duration;\n\t}\n\trcu_read_unlock();\n}\n\nvoid ath10k_sta_update_rx_duration(struct ath10k *ar,\n\t\t\t\t   struct ath10k_fw_stats *stats)\n{\n\tif (stats->extended)\n\t\tath10k_sta_update_extd_stats_rx_duration(ar, stats);\n\telse\n\t\tath10k_sta_update_stats_rx_duration(ar, stats);\n}\n\nstatic ssize_t ath10k_dbg_sta_read_aggr_mode(struct file *file,\n\t\t\t\t\t     char __user *user_buf,\n\t\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct ieee80211_sta *sta = file->private_data;\n\tstruct ath10k_sta *arsta = (struct ath10k_sta *)sta->drv_priv;\n\tstruct ath10k *ar = arsta->arvif->ar;\n\tchar buf[32];\n\tint len = 0;\n\n\tmutex_lock(&ar->conf_mutex);\n\tlen = scnprintf(buf, sizeof(buf) - len, \"aggregation mode: %s\\n\",\n\t\t\t(arsta->aggr_mode == ATH10K_DBG_AGGR_MODE_AUTO) ?\n\t\t\t\"auto\" : \"manual\");\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic ssize_t ath10k_dbg_sta_write_aggr_mode(struct file *file,\n\t\t\t\t\t      const char __user *user_buf,\n\t\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct ieee80211_sta *sta = file->private_data;\n\tstruct ath10k_sta *arsta = (struct ath10k_sta *)sta->drv_priv;\n\tstruct ath10k *ar = arsta->arvif->ar;\n\tu32 aggr_mode;\n\tint ret;\n\n\tif (kstrtouint_from_user(user_buf, count, 0, &aggr_mode))\n\t\treturn -EINVAL;\n\n\tif (aggr_mode >= ATH10K_DBG_AGGR_MODE_MAX)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ar->conf_mutex);\n\tif ((ar->state != ATH10K_STATE_ON) ||\n\t    (aggr_mode == arsta->aggr_mode)) {\n\t\tret = count;\n\t\tgoto out;\n\t}\n\n\tret = ath10k_wmi_addba_clear_resp(ar, arsta->arvif->vdev_id, sta->addr);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to clear addba session ret: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tarsta->aggr_mode = aggr_mode;\nout:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic const struct file_operations fops_aggr_mode = {\n\t.read = ath10k_dbg_sta_read_aggr_mode,\n\t.write = ath10k_dbg_sta_write_aggr_mode,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t ath10k_dbg_sta_write_addba(struct file *file,\n\t\t\t\t\t  const char __user *user_buf,\n\t\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct ieee80211_sta *sta = file->private_data;\n\tstruct ath10k_sta *arsta = (struct ath10k_sta *)sta->drv_priv;\n\tstruct ath10k *ar = arsta->arvif->ar;\n\tu32 tid, buf_size;\n\tint ret;\n\tchar buf[64] = {0};\n\n\tret = simple_write_to_buffer(buf, sizeof(buf) - 1, ppos,\n\t\t\t\t     user_buf, count);\n\tif (ret <= 0)\n\t\treturn ret;\n\n\tret = sscanf(buf, \"%u %u\", &tid, &buf_size);\n\tif (ret != 2)\n\t\treturn -EINVAL;\n\n\t \n\tif (tid > HTT_DATA_TX_EXT_TID_MGMT - 2)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ar->conf_mutex);\n\tif ((ar->state != ATH10K_STATE_ON) ||\n\t    (arsta->aggr_mode != ATH10K_DBG_AGGR_MODE_MANUAL)) {\n\t\tret = count;\n\t\tgoto out;\n\t}\n\n\tret = ath10k_wmi_addba_send(ar, arsta->arvif->vdev_id, sta->addr,\n\t\t\t\t    tid, buf_size);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to send addba request: vdev_id %u peer %pM tid %u buf_size %u\\n\",\n\t\t\t    arsta->arvif->vdev_id, sta->addr, tid, buf_size);\n\t}\n\n\tret = count;\nout:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic const struct file_operations fops_addba = {\n\t.write = ath10k_dbg_sta_write_addba,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t ath10k_dbg_sta_write_addba_resp(struct file *file,\n\t\t\t\t\t       const char __user *user_buf,\n\t\t\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct ieee80211_sta *sta = file->private_data;\n\tstruct ath10k_sta *arsta = (struct ath10k_sta *)sta->drv_priv;\n\tstruct ath10k *ar = arsta->arvif->ar;\n\tu32 tid, status;\n\tint ret;\n\tchar buf[64] = {0};\n\n\tret = simple_write_to_buffer(buf, sizeof(buf) - 1, ppos,\n\t\t\t\t     user_buf, count);\n\tif (ret <= 0)\n\t\treturn ret;\n\n\tret = sscanf(buf, \"%u %u\", &tid, &status);\n\tif (ret != 2)\n\t\treturn -EINVAL;\n\n\t \n\tif (tid > HTT_DATA_TX_EXT_TID_MGMT - 2)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ar->conf_mutex);\n\tif ((ar->state != ATH10K_STATE_ON) ||\n\t    (arsta->aggr_mode != ATH10K_DBG_AGGR_MODE_MANUAL)) {\n\t\tret = count;\n\t\tgoto out;\n\t}\n\n\tret = ath10k_wmi_addba_set_resp(ar, arsta->arvif->vdev_id, sta->addr,\n\t\t\t\t\ttid, status);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to send addba response: vdev_id %u peer %pM tid %u status%u\\n\",\n\t\t\t    arsta->arvif->vdev_id, sta->addr, tid, status);\n\t}\n\tret = count;\nout:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic const struct file_operations fops_addba_resp = {\n\t.write = ath10k_dbg_sta_write_addba_resp,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t ath10k_dbg_sta_write_delba(struct file *file,\n\t\t\t\t\t  const char __user *user_buf,\n\t\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct ieee80211_sta *sta = file->private_data;\n\tstruct ath10k_sta *arsta = (struct ath10k_sta *)sta->drv_priv;\n\tstruct ath10k *ar = arsta->arvif->ar;\n\tu32 tid, initiator, reason;\n\tint ret;\n\tchar buf[64] = {0};\n\n\tret = simple_write_to_buffer(buf, sizeof(buf) - 1, ppos,\n\t\t\t\t     user_buf, count);\n\tif (ret <= 0)\n\t\treturn ret;\n\n\tret = sscanf(buf, \"%u %u %u\", &tid, &initiator, &reason);\n\tif (ret != 3)\n\t\treturn -EINVAL;\n\n\t \n\tif (tid > HTT_DATA_TX_EXT_TID_MGMT - 2)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ar->conf_mutex);\n\tif ((ar->state != ATH10K_STATE_ON) ||\n\t    (arsta->aggr_mode != ATH10K_DBG_AGGR_MODE_MANUAL)) {\n\t\tret = count;\n\t\tgoto out;\n\t}\n\n\tret = ath10k_wmi_delba_send(ar, arsta->arvif->vdev_id, sta->addr,\n\t\t\t\t    tid, initiator, reason);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to send delba: vdev_id %u peer %pM tid %u initiator %u reason %u\\n\",\n\t\t\t    arsta->arvif->vdev_id, sta->addr, tid, initiator,\n\t\t\t    reason);\n\t}\n\tret = count;\nout:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic const struct file_operations fops_delba = {\n\t.write = ath10k_dbg_sta_write_delba,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t ath10k_dbg_sta_read_peer_debug_trigger(struct file *file,\n\t\t\t\t\t\t      char __user *user_buf,\n\t\t\t\t\t\t      size_t count,\n\t\t\t\t\t\t      loff_t *ppos)\n{\n\tstruct ieee80211_sta *sta = file->private_data;\n\tstruct ath10k_sta *arsta = (struct ath10k_sta *)sta->drv_priv;\n\tstruct ath10k *ar = arsta->arvif->ar;\n\tchar buf[8];\n\tint len = 0;\n\n\tmutex_lock(&ar->conf_mutex);\n\tlen = scnprintf(buf, sizeof(buf) - len,\n\t\t\t\"Write 1 to once trigger the debug logs\\n\");\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic ssize_t\nath10k_dbg_sta_write_peer_debug_trigger(struct file *file,\n\t\t\t\t\tconst char __user *user_buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct ieee80211_sta *sta = file->private_data;\n\tstruct ath10k_sta *arsta = (struct ath10k_sta *)sta->drv_priv;\n\tstruct ath10k *ar = arsta->arvif->ar;\n\tu8 peer_debug_trigger;\n\tint ret;\n\n\tif (kstrtou8_from_user(user_buf, count, 0, &peer_debug_trigger))\n\t\treturn -EINVAL;\n\n\tif (peer_debug_trigger != 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (ar->state != ATH10K_STATE_ON) {\n\t\tret = -ENETDOWN;\n\t\tgoto out;\n\t}\n\n\tret = ath10k_wmi_peer_set_param(ar, arsta->arvif->vdev_id, sta->addr,\n\t\t\t\t\tar->wmi.peer_param->debug, peer_debug_trigger);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to set param to trigger peer tid logs for station ret: %d\\n\",\n\t\t\t    ret);\n\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn count;\n}\n\nstatic const struct file_operations fops_peer_debug_trigger = {\n\t.open = simple_open,\n\t.read = ath10k_dbg_sta_read_peer_debug_trigger,\n\t.write = ath10k_dbg_sta_write_peer_debug_trigger,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t ath10k_dbg_sta_read_peer_ps_state(struct file *file,\n\t\t\t\t\t\t char __user *user_buf,\n\t\t\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct ieee80211_sta *sta = file->private_data;\n\tstruct ath10k_sta *arsta = (struct ath10k_sta *)sta->drv_priv;\n\tstruct ath10k *ar = arsta->arvif->ar;\n\tchar buf[20];\n\tint len = 0;\n\n\tspin_lock_bh(&ar->data_lock);\n\n\tlen = scnprintf(buf, sizeof(buf) - len, \"%d\\n\",\n\t\t\tarsta->peer_ps_state);\n\n\tspin_unlock_bh(&ar->data_lock);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic const struct file_operations fops_peer_ps_state = {\n\t.open = simple_open,\n\t.read = ath10k_dbg_sta_read_peer_ps_state,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic char *get_err_str(enum ath10k_pkt_rx_err i)\n{\n\tswitch (i) {\n\tcase ATH10K_PKT_RX_ERR_FCS:\n\t\treturn \"fcs_err\";\n\tcase ATH10K_PKT_RX_ERR_TKIP:\n\t\treturn \"tkip_err\";\n\tcase ATH10K_PKT_RX_ERR_CRYPT:\n\t\treturn \"crypt_err\";\n\tcase ATH10K_PKT_RX_ERR_PEER_IDX_INVAL:\n\t\treturn \"peer_idx_inval\";\n\tcase ATH10K_PKT_RX_ERR_MAX:\n\t\treturn \"unknown\";\n\t}\n\n\treturn \"unknown\";\n}\n\nstatic char *get_num_ampdu_subfrm_str(enum ath10k_ampdu_subfrm_num i)\n{\n\tswitch (i) {\n\tcase ATH10K_AMPDU_SUBFRM_NUM_10:\n\t\treturn \"up to 10\";\n\tcase ATH10K_AMPDU_SUBFRM_NUM_20:\n\t\treturn \"11-20\";\n\tcase ATH10K_AMPDU_SUBFRM_NUM_30:\n\t\treturn \"21-30\";\n\tcase ATH10K_AMPDU_SUBFRM_NUM_40:\n\t\treturn \"31-40\";\n\tcase ATH10K_AMPDU_SUBFRM_NUM_50:\n\t\treturn \"41-50\";\n\tcase ATH10K_AMPDU_SUBFRM_NUM_60:\n\t\treturn \"51-60\";\n\tcase ATH10K_AMPDU_SUBFRM_NUM_MORE:\n\t\treturn \">60\";\n\tcase ATH10K_AMPDU_SUBFRM_NUM_MAX:\n\t\treturn \"0\";\n\t}\n\n\treturn \"0\";\n}\n\nstatic char *get_num_amsdu_subfrm_str(enum ath10k_amsdu_subfrm_num i)\n{\n\tswitch (i) {\n\tcase ATH10K_AMSDU_SUBFRM_NUM_1:\n\t\treturn \"1\";\n\tcase ATH10K_AMSDU_SUBFRM_NUM_2:\n\t\treturn \"2\";\n\tcase ATH10K_AMSDU_SUBFRM_NUM_3:\n\t\treturn \"3\";\n\tcase ATH10K_AMSDU_SUBFRM_NUM_4:\n\t\treturn \"4\";\n\tcase ATH10K_AMSDU_SUBFRM_NUM_MORE:\n\t\treturn \">4\";\n\tcase ATH10K_AMSDU_SUBFRM_NUM_MAX:\n\t\treturn \"0\";\n\t}\n\n\treturn \"0\";\n}\n\n#define PRINT_TID_STATS(_field, _tabs) \\\n\tdo { \\\n\t\tint k = 0; \\\n\t\tfor (j = 0; j <= IEEE80211_NUM_TIDS; j++) { \\\n\t\t\tif (ar->sta_tid_stats_mask & BIT(j))  { \\\n\t\t\t\tlen += scnprintf(buf + len, buf_len - len, \\\n\t\t\t\t\t\t \"[%02d] %-10lu  \", \\\n\t\t\t\t\t\t j, stats[j]._field); \\\n\t\t\t\tk++; \\\n\t\t\t\tif (k % 8 == 0)  { \\\n\t\t\t\t\tlen += scnprintf(buf + len, \\\n\t\t\t\t\t\t\t buf_len - len, \"\\n\"); \\\n\t\t\t\t\tlen += scnprintf(buf + len, \\\n\t\t\t\t\t\t\t buf_len - len, \\\n\t\t\t\t\t\t\t _tabs); \\\n\t\t\t\t} \\\n\t\t\t} \\\n\t\t} \\\n\t\tlen += scnprintf(buf + len, buf_len - len, \"\\n\"); \\\n\t} while (0)\n\nstatic ssize_t ath10k_dbg_sta_read_tid_stats(struct file *file,\n\t\t\t\t\t     char __user *user_buf,\n\t\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct ieee80211_sta *sta = file->private_data;\n\tstruct ath10k_sta *arsta = (struct ath10k_sta *)sta->drv_priv;\n\tstruct ath10k *ar = arsta->arvif->ar;\n\tstruct ath10k_sta_tid_stats *stats = arsta->tid_stats;\n\tsize_t len = 0, buf_len = 1048 * IEEE80211_NUM_TIDS;\n\tchar *buf;\n\tint i, j;\n\tssize_t ret;\n\n\tbuf = kzalloc(buf_len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tspin_lock_bh(&ar->data_lock);\n\n\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t \"\\n\\t\\tDriver Rx pkt stats per tid, ([tid] count)\\n\");\n\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t \"\\t\\t------------------------------------------\\n\");\n\tlen += scnprintf(buf + len, buf_len - len, \"MSDUs from FW\\t\\t\\t\");\n\tPRINT_TID_STATS(rx_pkt_from_fw, \"\\t\\t\\t\\t\");\n\n\tlen += scnprintf(buf + len, buf_len - len, \"MSDUs unchained\\t\\t\\t\");\n\tPRINT_TID_STATS(rx_pkt_unchained, \"\\t\\t\\t\\t\");\n\n\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t \"MSDUs locally dropped:chained\\t\");\n\tPRINT_TID_STATS(rx_pkt_drop_chained, \"\\t\\t\\t\\t\");\n\n\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t \"MSDUs locally dropped:filtered\\t\");\n\tPRINT_TID_STATS(rx_pkt_drop_filter, \"\\t\\t\\t\\t\");\n\n\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t \"MSDUs queued for mac80211\\t\");\n\tPRINT_TID_STATS(rx_pkt_queued_for_mac, \"\\t\\t\\t\\t\");\n\n\tfor (i = 0; i < ATH10K_PKT_RX_ERR_MAX; i++) {\n\t\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t\t \"MSDUs with error:%s\\t\", get_err_str(i));\n\t\tPRINT_TID_STATS(rx_pkt_err[i], \"\\t\\t\\t\\t\");\n\t}\n\n\tlen += scnprintf(buf + len, buf_len - len, \"\\n\");\n\tfor (i = 0; i < ATH10K_AMPDU_SUBFRM_NUM_MAX; i++) {\n\t\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t\t \"A-MPDU num subframes %s\\t\",\n\t\t\t\t get_num_ampdu_subfrm_str(i));\n\t\tPRINT_TID_STATS(rx_pkt_ampdu[i], \"\\t\\t\\t\\t\");\n\t}\n\n\tlen += scnprintf(buf + len, buf_len - len, \"\\n\");\n\tfor (i = 0; i < ATH10K_AMSDU_SUBFRM_NUM_MAX; i++) {\n\t\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t\t \"A-MSDU num subframes %s\\t\\t\",\n\t\t\t\t get_num_amsdu_subfrm_str(i));\n\t\tPRINT_TID_STATS(rx_pkt_amsdu[i], \"\\t\\t\\t\\t\");\n\t}\n\n\tspin_unlock_bh(&ar->data_lock);\n\n\tret = simple_read_from_buffer(user_buf, count, ppos, buf, len);\n\n\tkfree(buf);\n\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn ret;\n}\n\nstatic const struct file_operations fops_tid_stats_dump = {\n\t.open = simple_open,\n\t.read = ath10k_dbg_sta_read_tid_stats,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t ath10k_dbg_sta_dump_tx_stats(struct file *file,\n\t\t\t\t\t    char __user *user_buf,\n\t\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct ieee80211_sta *sta = file->private_data;\n\tstruct ath10k_sta *arsta = (struct ath10k_sta *)sta->drv_priv;\n\tstruct ath10k *ar = arsta->arvif->ar;\n\tstruct ath10k_htt_data_stats *stats;\n\tconst char *str_name[ATH10K_STATS_TYPE_MAX] = {\"succ\", \"fail\",\n\t\t\t\t\t\t       \"retry\", \"ampdu\"};\n\tconst char *str[ATH10K_COUNTER_TYPE_MAX] = {\"bytes\", \"packets\"};\n\tint len = 0, i, j, k, retval = 0;\n\tconst int size = 16 * 4096;\n\tchar *buf;\n\n\tbuf = kzalloc(size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (!arsta->tx_stats) {\n\t\tath10k_warn(ar, \"failed to get tx stats\");\n\t\tmutex_unlock(&ar->conf_mutex);\n\t\tkfree(buf);\n\t\treturn 0;\n\t}\n\n\tspin_lock_bh(&ar->data_lock);\n\tfor (k = 0; k < ATH10K_STATS_TYPE_MAX; k++) {\n\t\tfor (j = 0; j < ATH10K_COUNTER_TYPE_MAX; j++) {\n\t\t\tstats = &arsta->tx_stats->stats[k];\n\t\t\tlen += scnprintf(buf + len, size - len, \"%s_%s\\n\",\n\t\t\t\t\t str_name[k],\n\t\t\t\t\t str[j]);\n\t\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\t \" VHT MCS %s\\n\",\n\t\t\t\t\t str[j]);\n\t\t\tfor (i = 0; i < ATH10K_VHT_MCS_NUM; i++)\n\t\t\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\t\t \"  %llu \",\n\t\t\t\t\t\t stats->vht[j][i]);\n\t\t\tlen += scnprintf(buf + len, size - len, \"\\n\");\n\t\t\tlen += scnprintf(buf + len, size - len, \" HT MCS %s\\n\",\n\t\t\t\t\t str[j]);\n\t\t\tfor (i = 0; i < ATH10K_HT_MCS_NUM; i++)\n\t\t\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\t\t \"  %llu \", stats->ht[j][i]);\n\t\t\tlen += scnprintf(buf + len, size - len, \"\\n\");\n\t\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\t\" BW %s (20,5,10,40,80,160 MHz)\\n\", str[j]);\n\t\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\t \"  %llu %llu %llu %llu %llu %llu\\n\",\n\t\t\t\t\t stats->bw[j][0], stats->bw[j][1],\n\t\t\t\t\t stats->bw[j][2], stats->bw[j][3],\n\t\t\t\t\t stats->bw[j][4], stats->bw[j][5]);\n\t\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\t \" NSS %s (1x1,2x2,3x3,4x4)\\n\", str[j]);\n\t\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\t \"  %llu %llu %llu %llu\\n\",\n\t\t\t\t\t stats->nss[j][0], stats->nss[j][1],\n\t\t\t\t\t stats->nss[j][2], stats->nss[j][3]);\n\t\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\t \" GI %s (LGI,SGI)\\n\",\n\t\t\t\t\t str[j]);\n\t\t\tlen += scnprintf(buf + len, size - len, \"  %llu %llu\\n\",\n\t\t\t\t\t stats->gi[j][0], stats->gi[j][1]);\n\t\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\t \" legacy rate %s (1,2 ... Mbps)\\n  \",\n\t\t\t\t\t str[j]);\n\t\t\tfor (i = 0; i < ATH10K_LEGACY_NUM; i++)\n\t\t\t\tlen += scnprintf(buf + len, size - len, \"%llu \",\n\t\t\t\t\t\t stats->legacy[j][i]);\n\t\t\tlen += scnprintf(buf + len, size - len, \"\\n\");\n\t\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\t \" Rate table %s (1,2 ... Mbps)\\n  \",\n\t\t\t\t\t str[j]);\n\t\t\tfor (i = 0; i < ATH10K_RATE_TABLE_NUM; i++) {\n\t\t\t\tlen += scnprintf(buf + len, size - len, \"%llu \",\n\t\t\t\t\t\t stats->rate_table[j][i]);\n\t\t\t\tif (!((i + 1) % 8))\n\t\t\t\t\tlen +=\n\t\t\t\t\tscnprintf(buf + len, size - len, \"\\n  \");\n\t\t\t}\n\t\t}\n\t}\n\n\tlen += scnprintf(buf + len, size - len,\n\t\t\t \"\\nTX duration\\n %llu usecs\\n\",\n\t\t\t arsta->tx_stats->tx_duration);\n\tlen += scnprintf(buf + len, size - len,\n\t\t\t\"BA fails\\n %llu\\n\", arsta->tx_stats->ba_fails);\n\tlen += scnprintf(buf + len, size - len,\n\t\t\t\"ack fails\\n %llu\\n\", arsta->tx_stats->ack_fails);\n\tspin_unlock_bh(&ar->data_lock);\n\n\tif (len > size)\n\t\tlen = size;\n\tretval = simple_read_from_buffer(user_buf, count, ppos, buf, len);\n\tkfree(buf);\n\n\tmutex_unlock(&ar->conf_mutex);\n\treturn retval;\n}\n\nstatic const struct file_operations fops_tx_stats = {\n\t.read = ath10k_dbg_sta_dump_tx_stats,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nvoid ath10k_sta_add_debugfs(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t    struct ieee80211_sta *sta, struct dentry *dir)\n{\n\tstruct ath10k *ar = hw->priv;\n\n\tdebugfs_create_file(\"aggr_mode\", 0644, dir, sta, &fops_aggr_mode);\n\tdebugfs_create_file(\"addba\", 0200, dir, sta, &fops_addba);\n\tdebugfs_create_file(\"addba_resp\", 0200, dir, sta, &fops_addba_resp);\n\tdebugfs_create_file(\"delba\", 0200, dir, sta, &fops_delba);\n\tdebugfs_create_file(\"peer_debug_trigger\", 0600, dir, sta,\n\t\t\t    &fops_peer_debug_trigger);\n\tdebugfs_create_file(\"dump_tid_stats\", 0400, dir, sta,\n\t\t\t    &fops_tid_stats_dump);\n\n\tif (ath10k_peer_stats_enabled(ar) &&\n\t    ath10k_debug_is_extd_tx_stats_enabled(ar))\n\t\tdebugfs_create_file(\"tx_stats\", 0400, dir, sta,\n\t\t\t\t    &fops_tx_stats);\n\tdebugfs_create_file(\"peer_ps_state\", 0400, dir, sta,\n\t\t\t    &fops_peer_ps_state);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}