{
  "module_name": "wmi-tlv.c",
  "hash_id": "2fc3581a2ccfcaff161939357e1c62d95fb4e30759c49c9f7c8c69b448328f1b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath10k/wmi-tlv.c",
  "human_readable_source": "\n \n#include \"core.h\"\n#include \"debug.h\"\n#include \"mac.h\"\n#include \"hw.h\"\n#include \"wmi.h\"\n#include \"wmi-ops.h\"\n#include \"wmi-tlv.h\"\n#include \"p2p.h\"\n#include \"testmode.h\"\n#include <linux/bitfield.h>\n\n \n \n \n\nstruct wmi_tlv_policy {\n\tsize_t min_len;\n};\n\nstatic const struct wmi_tlv_policy wmi_tlv_policies[] = {\n\t[WMI_TLV_TAG_ARRAY_BYTE]\n\t\t= { .min_len = 0 },\n\t[WMI_TLV_TAG_ARRAY_UINT32]\n\t\t= { .min_len = 0 },\n\t[WMI_TLV_TAG_STRUCT_SCAN_EVENT]\n\t\t= { .min_len = sizeof(struct wmi_scan_event) },\n\t[WMI_TLV_TAG_STRUCT_MGMT_RX_HDR]\n\t\t= { .min_len = sizeof(struct wmi_tlv_mgmt_rx_ev) },\n\t[WMI_TLV_TAG_STRUCT_CHAN_INFO_EVENT]\n\t\t= { .min_len = sizeof(struct wmi_chan_info_event) },\n\t[WMI_TLV_TAG_STRUCT_VDEV_START_RESPONSE_EVENT]\n\t\t= { .min_len = sizeof(struct wmi_vdev_start_response_event) },\n\t[WMI_TLV_TAG_STRUCT_PEER_STA_KICKOUT_EVENT]\n\t\t= { .min_len = sizeof(struct wmi_peer_sta_kickout_event) },\n\t[WMI_TLV_TAG_STRUCT_HOST_SWBA_EVENT]\n\t\t= { .min_len = sizeof(struct wmi_host_swba_event) },\n\t[WMI_TLV_TAG_STRUCT_TIM_INFO]\n\t\t= { .min_len = sizeof(struct wmi_tim_info) },\n\t[WMI_TLV_TAG_STRUCT_P2P_NOA_INFO]\n\t\t= { .min_len = sizeof(struct wmi_p2p_noa_info) },\n\t[WMI_TLV_TAG_STRUCT_SERVICE_READY_EVENT]\n\t\t= { .min_len = sizeof(struct wmi_tlv_svc_rdy_ev) },\n\t[WMI_TLV_TAG_STRUCT_HAL_REG_CAPABILITIES]\n\t\t= { .min_len = sizeof(struct hal_reg_capabilities) },\n\t[WMI_TLV_TAG_STRUCT_WLAN_HOST_MEM_REQ]\n\t\t= { .min_len = sizeof(struct wlan_host_mem_req) },\n\t[WMI_TLV_TAG_STRUCT_READY_EVENT]\n\t\t= { .min_len = sizeof(struct wmi_tlv_rdy_ev) },\n\t[WMI_TLV_TAG_STRUCT_OFFLOAD_BCN_TX_STATUS_EVENT]\n\t\t= { .min_len = sizeof(struct wmi_tlv_bcn_tx_status_ev) },\n\t[WMI_TLV_TAG_STRUCT_DIAG_DATA_CONTAINER_EVENT]\n\t\t= { .min_len = sizeof(struct wmi_tlv_diag_data_ev) },\n\t[WMI_TLV_TAG_STRUCT_P2P_NOA_EVENT]\n\t\t= { .min_len = sizeof(struct wmi_tlv_p2p_noa_ev) },\n\t[WMI_TLV_TAG_STRUCT_ROAM_EVENT]\n\t\t= { .min_len = sizeof(struct wmi_tlv_roam_ev) },\n\t[WMI_TLV_TAG_STRUCT_WOW_EVENT_INFO]\n\t\t= { .min_len = sizeof(struct wmi_tlv_wow_event_info) },\n\t[WMI_TLV_TAG_STRUCT_TX_PAUSE_EVENT]\n\t\t= { .min_len = sizeof(struct wmi_tlv_tx_pause_ev) },\n};\n\nstatic int\nath10k_wmi_tlv_iter(struct ath10k *ar, const void *ptr, size_t len,\n\t\t    int (*iter)(struct ath10k *ar, u16 tag, u16 len,\n\t\t\t\tconst void *ptr, void *data),\n\t\t    void *data)\n{\n\tconst void *begin = ptr;\n\tconst struct wmi_tlv *tlv;\n\tu16 tlv_tag, tlv_len;\n\tint ret;\n\n\twhile (len > 0) {\n\t\tif (len < sizeof(*tlv)) {\n\t\t\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t\t\t   \"wmi tlv parse failure at byte %zd (%zu bytes left, %zu expected)\\n\",\n\t\t\t\t   ptr - begin, len, sizeof(*tlv));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\ttlv = ptr;\n\t\ttlv_tag = __le16_to_cpu(tlv->tag);\n\t\ttlv_len = __le16_to_cpu(tlv->len);\n\t\tptr += sizeof(*tlv);\n\t\tlen -= sizeof(*tlv);\n\n\t\tif (tlv_len > len) {\n\t\t\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t\t\t   \"wmi tlv parse failure of tag %u at byte %zd (%zu bytes left, %u expected)\\n\",\n\t\t\t\t   tlv_tag, ptr - begin, len, tlv_len);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (tlv_tag < ARRAY_SIZE(wmi_tlv_policies) &&\n\t\t    wmi_tlv_policies[tlv_tag].min_len &&\n\t\t    wmi_tlv_policies[tlv_tag].min_len > tlv_len) {\n\t\t\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t\t\t   \"wmi tlv parse failure of tag %u at byte %zd (%u bytes is less than min length %zu)\\n\",\n\t\t\t\t   tlv_tag, ptr - begin, tlv_len,\n\t\t\t\t   wmi_tlv_policies[tlv_tag].min_len);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = iter(ar, tlv_tag, tlv_len, ptr, data);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tptr += tlv_len;\n\t\tlen -= tlv_len;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_wmi_tlv_iter_parse(struct ath10k *ar, u16 tag, u16 len,\n\t\t\t\t     const void *ptr, void *data)\n{\n\tconst void **tb = data;\n\n\tif (tag < WMI_TLV_TAG_MAX)\n\t\ttb[tag] = ptr;\n\n\treturn 0;\n}\n\nstatic int ath10k_wmi_tlv_parse(struct ath10k *ar, const void **tb,\n\t\t\t\tconst void *ptr, size_t len)\n{\n\treturn ath10k_wmi_tlv_iter(ar, ptr, len, ath10k_wmi_tlv_iter_parse,\n\t\t\t\t   (void *)tb);\n}\n\nstatic const void **\nath10k_wmi_tlv_parse_alloc(struct ath10k *ar, const void *ptr,\n\t\t\t   size_t len, gfp_t gfp)\n{\n\tconst void **tb;\n\tint ret;\n\n\ttb = kcalloc(WMI_TLV_TAG_MAX, sizeof(*tb), gfp);\n\tif (!tb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = ath10k_wmi_tlv_parse(ar, tb, ptr, len);\n\tif (ret) {\n\t\tkfree(tb);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn tb;\n}\n\nstatic u16 ath10k_wmi_tlv_len(const void *ptr)\n{\n\treturn __le16_to_cpu((((const struct wmi_tlv *)ptr) - 1)->len);\n}\n\n \n \n \nstatic int ath10k_wmi_tlv_event_bcn_tx_status(struct ath10k *ar,\n\t\t\t\t\t      struct sk_buff *skb)\n{\n\tconst void **tb;\n\tconst struct wmi_tlv_bcn_tx_status_ev *ev;\n\tstruct ath10k_vif *arvif;\n\tu32 vdev_id, tx_status;\n\tint ret;\n\n\ttb = ath10k_wmi_tlv_parse_alloc(ar, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath10k_warn(ar, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = tb[WMI_TLV_TAG_STRUCT_OFFLOAD_BCN_TX_STATUS_EVENT];\n\tif (!ev) {\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\ttx_status = __le32_to_cpu(ev->tx_status);\n\tvdev_id = __le32_to_cpu(ev->vdev_id);\n\n\tswitch (tx_status) {\n\tcase WMI_TLV_BCN_TX_STATUS_OK:\n\t\tbreak;\n\tcase WMI_TLV_BCN_TX_STATUS_XRETRY:\n\tcase WMI_TLV_BCN_TX_STATUS_DROP:\n\tcase WMI_TLV_BCN_TX_STATUS_FILTERED:\n\t\t \n\t\tath10k_warn(ar, \"received bcn tmpl tx status on vdev %i: %d\",\n\t\t\t    vdev_id, tx_status);\n\t\tbreak;\n\t}\n\n\tarvif = ath10k_get_arvif(ar, vdev_id);\n\tif (arvif && arvif->is_up && arvif->vif->bss_conf.csa_active)\n\t\tieee80211_queue_work(ar->hw, &arvif->ap_csa_work);\n\n\tkfree(tb);\n\treturn 0;\n}\n\nstatic void ath10k_wmi_tlv_event_vdev_delete_resp(struct ath10k *ar,\n\t\t\t\t\t\t  struct sk_buff *skb)\n{\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"WMI_VDEV_DELETE_RESP_EVENTID\\n\");\n\tcomplete(&ar->vdev_delete_done);\n}\n\nstatic int ath10k_wmi_tlv_parse_peer_stats_info(struct ath10k *ar, u16 tag, u16 len,\n\t\t\t\t\t\tconst void *ptr, void *data)\n{\n\tconst struct wmi_tlv_peer_stats_info *stat = ptr;\n\tstruct ieee80211_sta *sta;\n\tstruct ath10k_sta *arsta;\n\n\tif (tag != WMI_TLV_TAG_STRUCT_PEER_STATS_INFO)\n\t\treturn -EPROTO;\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi tlv stats peer addr %pMF rx rate code 0x%x bit rate %d kbps\\n\",\n\t\t   stat->peer_macaddr.addr,\n\t\t   __le32_to_cpu(stat->last_rx_rate_code),\n\t\t   __le32_to_cpu(stat->last_rx_bitrate_kbps));\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi tlv stats tx rate code 0x%x bit rate %d kbps\\n\",\n\t\t   __le32_to_cpu(stat->last_tx_rate_code),\n\t\t   __le32_to_cpu(stat->last_tx_bitrate_kbps));\n\n\trcu_read_lock();\n\tsta = ieee80211_find_sta_by_ifaddr(ar->hw, stat->peer_macaddr.addr, NULL);\n\tif (!sta) {\n\t\trcu_read_unlock();\n\t\tath10k_warn(ar, \"not found station for peer stats\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tarsta = (struct ath10k_sta *)sta->drv_priv;\n\tarsta->rx_rate_code = __le32_to_cpu(stat->last_rx_rate_code);\n\tarsta->rx_bitrate_kbps = __le32_to_cpu(stat->last_rx_bitrate_kbps);\n\tarsta->tx_rate_code = __le32_to_cpu(stat->last_tx_rate_code);\n\tarsta->tx_bitrate_kbps = __le32_to_cpu(stat->last_tx_bitrate_kbps);\n\trcu_read_unlock();\n\n\treturn 0;\n}\n\nstatic int ath10k_wmi_tlv_op_pull_peer_stats_info(struct ath10k *ar,\n\t\t\t\t\t\t  struct sk_buff *skb)\n{\n\tconst void **tb;\n\tconst struct wmi_tlv_peer_stats_info_ev *ev;\n\tconst void *data;\n\tu32 num_peer_stats;\n\tint ret;\n\n\ttb = ath10k_wmi_tlv_parse_alloc(ar, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath10k_warn(ar, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = tb[WMI_TLV_TAG_STRUCT_PEER_STATS_INFO_EVENT];\n\tdata = tb[WMI_TLV_TAG_ARRAY_STRUCT];\n\n\tif (!ev || !data) {\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\tnum_peer_stats = __le32_to_cpu(ev->num_peers);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi tlv peer stats info update peer vdev id %d peers %i more data %d\\n\",\n\t\t   __le32_to_cpu(ev->vdev_id),\n\t\t   num_peer_stats,\n\t\t   __le32_to_cpu(ev->more_data));\n\n\tret = ath10k_wmi_tlv_iter(ar, data, ath10k_wmi_tlv_len(data),\n\t\t\t\t  ath10k_wmi_tlv_parse_peer_stats_info, NULL);\n\tif (ret)\n\t\tath10k_warn(ar, \"failed to parse stats info tlv: %d\\n\", ret);\n\n\tkfree(tb);\n\treturn 0;\n}\n\nstatic void ath10k_wmi_tlv_event_peer_stats_info(struct ath10k *ar,\n\t\t\t\t\t\t struct sk_buff *skb)\n{\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"WMI_PEER_STATS_INFO_EVENTID\\n\");\n\tath10k_wmi_tlv_op_pull_peer_stats_info(ar, skb);\n\tcomplete(&ar->peer_stats_info_complete);\n}\n\nstatic int ath10k_wmi_tlv_event_diag_data(struct ath10k *ar,\n\t\t\t\t\t  struct sk_buff *skb)\n{\n\tconst void **tb;\n\tconst struct wmi_tlv_diag_data_ev *ev;\n\tconst struct wmi_tlv_diag_item *item;\n\tconst void *data;\n\tint ret, num_items, len;\n\n\ttb = ath10k_wmi_tlv_parse_alloc(ar, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath10k_warn(ar, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = tb[WMI_TLV_TAG_STRUCT_DIAG_DATA_CONTAINER_EVENT];\n\tdata = tb[WMI_TLV_TAG_ARRAY_BYTE];\n\tif (!ev || !data) {\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\tnum_items = __le32_to_cpu(ev->num_items);\n\tlen = ath10k_wmi_tlv_len(data);\n\n\twhile (num_items--) {\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tif (len < sizeof(*item)) {\n\t\t\tath10k_warn(ar, \"failed to parse diag data: can't fit item header\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\titem = data;\n\n\t\tif (len < sizeof(*item) + __le16_to_cpu(item->len)) {\n\t\t\tath10k_warn(ar, \"failed to parse diag data: item is too long\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\ttrace_ath10k_wmi_diag_container(ar,\n\t\t\t\t\t\titem->type,\n\t\t\t\t\t\t__le32_to_cpu(item->timestamp),\n\t\t\t\t\t\t__le32_to_cpu(item->code),\n\t\t\t\t\t\t__le16_to_cpu(item->len),\n\t\t\t\t\t\titem->payload);\n\n\t\tlen -= sizeof(*item);\n\t\tlen -= roundup(__le16_to_cpu(item->len), 4);\n\n\t\tdata += sizeof(*item);\n\t\tdata += roundup(__le16_to_cpu(item->len), 4);\n\t}\n\n\tif (num_items != -1 || len != 0)\n\t\tath10k_warn(ar, \"failed to parse diag data event: num_items %d len %d\\n\",\n\t\t\t    num_items, len);\n\n\tkfree(tb);\n\treturn 0;\n}\n\nstatic int ath10k_wmi_tlv_event_diag(struct ath10k *ar,\n\t\t\t\t     struct sk_buff *skb)\n{\n\tconst void **tb;\n\tconst void *data;\n\tint ret, len;\n\n\ttb = ath10k_wmi_tlv_parse_alloc(ar, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath10k_warn(ar, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdata = tb[WMI_TLV_TAG_ARRAY_BYTE];\n\tif (!data) {\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\tlen = ath10k_wmi_tlv_len(data);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv diag event len %d\\n\", len);\n\ttrace_ath10k_wmi_diag(ar, data, len);\n\n\tkfree(tb);\n\treturn 0;\n}\n\nstatic int ath10k_wmi_tlv_event_p2p_noa(struct ath10k *ar,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tconst void **tb;\n\tconst struct wmi_tlv_p2p_noa_ev *ev;\n\tconst struct wmi_p2p_noa_info *noa;\n\tint ret, vdev_id;\n\n\ttb = ath10k_wmi_tlv_parse_alloc(ar, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath10k_warn(ar, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = tb[WMI_TLV_TAG_STRUCT_P2P_NOA_EVENT];\n\tnoa = tb[WMI_TLV_TAG_STRUCT_P2P_NOA_INFO];\n\n\tif (!ev || !noa) {\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\tvdev_id = __le32_to_cpu(ev->vdev_id);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi tlv p2p noa vdev_id %i descriptors %u\\n\",\n\t\t   vdev_id, noa->num_descriptors);\n\n\tath10k_p2p_noa_update_by_vdev_id(ar, vdev_id, noa);\n\tkfree(tb);\n\treturn 0;\n}\n\nstatic int ath10k_wmi_tlv_event_tx_pause(struct ath10k *ar,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tconst void **tb;\n\tconst struct wmi_tlv_tx_pause_ev *ev;\n\tint ret, vdev_id;\n\tu32 pause_id, action, vdev_map, peer_id, tid_map;\n\n\ttb = ath10k_wmi_tlv_parse_alloc(ar, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath10k_warn(ar, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = tb[WMI_TLV_TAG_STRUCT_TX_PAUSE_EVENT];\n\tif (!ev) {\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\tpause_id = __le32_to_cpu(ev->pause_id);\n\taction = __le32_to_cpu(ev->action);\n\tvdev_map = __le32_to_cpu(ev->vdev_map);\n\tpeer_id = __le32_to_cpu(ev->peer_id);\n\ttid_map = __le32_to_cpu(ev->tid_map);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi tlv tx pause pause_id %u action %u vdev_map 0x%08x peer_id %u tid_map 0x%08x\\n\",\n\t\t   pause_id, action, vdev_map, peer_id, tid_map);\n\n\tswitch (pause_id) {\n\tcase WMI_TLV_TX_PAUSE_ID_MCC:\n\tcase WMI_TLV_TX_PAUSE_ID_P2P_CLI_NOA:\n\tcase WMI_TLV_TX_PAUSE_ID_P2P_GO_PS:\n\tcase WMI_TLV_TX_PAUSE_ID_AP_PS:\n\tcase WMI_TLV_TX_PAUSE_ID_IBSS_PS:\n\t\tfor (vdev_id = 0; vdev_map; vdev_id++) {\n\t\t\tif (!(vdev_map & BIT(vdev_id)))\n\t\t\t\tcontinue;\n\n\t\t\tvdev_map &= ~BIT(vdev_id);\n\t\t\tath10k_mac_handle_tx_pause_vdev(ar, vdev_id, pause_id,\n\t\t\t\t\t\t\taction);\n\t\t}\n\t\tbreak;\n\tcase WMI_TLV_TX_PAUSE_ID_AP_PEER_PS:\n\tcase WMI_TLV_TX_PAUSE_ID_AP_PEER_UAPSD:\n\tcase WMI_TLV_TX_PAUSE_ID_STA_ADD_BA:\n\tcase WMI_TLV_TX_PAUSE_ID_HOST:\n\t\tath10k_dbg(ar, ATH10K_DBG_MAC,\n\t\t\t   \"mac ignoring unsupported tx pause id %d\\n\",\n\t\t\t   pause_id);\n\t\tbreak;\n\tdefault:\n\t\tath10k_dbg(ar, ATH10K_DBG_MAC,\n\t\t\t   \"mac ignoring unknown tx pause vdev %d\\n\",\n\t\t\t   pause_id);\n\t\tbreak;\n\t}\n\n\tkfree(tb);\n\treturn 0;\n}\n\nstatic void ath10k_wmi_tlv_event_rfkill_state_change(struct ath10k *ar,\n\t\t\t\t\t\t     struct sk_buff *skb)\n{\n\tconst struct wmi_tlv_rfkill_state_change_ev *ev;\n\tconst void **tb;\n\tbool radio;\n\tint ret;\n\n\ttb = ath10k_wmi_tlv_parse_alloc(ar, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath10k_warn(ar,\n\t\t\t    \"failed to parse rfkill state change event: %d\\n\",\n\t\t\t    ret);\n\t\treturn;\n\t}\n\n\tev = tb[WMI_TLV_TAG_STRUCT_RFKILL_EVENT];\n\tif (!ev) {\n\t\tkfree(tb);\n\t\treturn;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_MAC,\n\t\t   \"wmi tlv rfkill state change gpio %d type %d radio_state %d\\n\",\n\t\t   __le32_to_cpu(ev->gpio_pin_num),\n\t\t   __le32_to_cpu(ev->int_type),\n\t\t   __le32_to_cpu(ev->radio_state));\n\n\tradio = (__le32_to_cpu(ev->radio_state) == WMI_TLV_RFKILL_RADIO_STATE_ON);\n\n\tspin_lock_bh(&ar->data_lock);\n\n\tif (!radio)\n\t\tar->hw_rfkill_on = true;\n\n\tspin_unlock_bh(&ar->data_lock);\n\n\t \n\tath10k_mac_rfkill_enable_radio(ar, radio);\n\twiphy_rfkill_set_hw_state(ar->hw->wiphy, !radio);\n}\n\nstatic int ath10k_wmi_tlv_event_temperature(struct ath10k *ar,\n\t\t\t\t\t    struct sk_buff *skb)\n{\n\tconst struct wmi_tlv_pdev_temperature_event *ev;\n\n\tev = (struct wmi_tlv_pdev_temperature_event *)skb->data;\n\tif (WARN_ON(skb->len < sizeof(*ev)))\n\t\treturn -EPROTO;\n\n\tath10k_thermal_event_temperature(ar, __le32_to_cpu(ev->temperature));\n\treturn 0;\n}\n\nstatic void ath10k_wmi_event_tdls_peer(struct ath10k *ar, struct sk_buff *skb)\n{\n\tstruct ieee80211_sta *station;\n\tconst struct wmi_tlv_tdls_peer_event *ev;\n\tconst void **tb;\n\tstruct ath10k_vif *arvif;\n\n\ttb = ath10k_wmi_tlv_parse_alloc(ar, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tath10k_warn(ar, \"tdls peer failed to parse tlv\");\n\t\treturn;\n\t}\n\tev = tb[WMI_TLV_TAG_STRUCT_TDLS_PEER_EVENT];\n\tif (!ev) {\n\t\tkfree(tb);\n\t\tath10k_warn(ar, \"tdls peer NULL event\");\n\t\treturn;\n\t}\n\n\tswitch (__le32_to_cpu(ev->peer_reason)) {\n\tcase WMI_TDLS_TEARDOWN_REASON_TX:\n\tcase WMI_TDLS_TEARDOWN_REASON_RSSI:\n\tcase WMI_TDLS_TEARDOWN_REASON_PTR_TIMEOUT:\n\t\trcu_read_lock();\n\t\tstation = ieee80211_find_sta_by_ifaddr(ar->hw,\n\t\t\t\t\t\t       ev->peer_macaddr.addr,\n\t\t\t\t\t\t       NULL);\n\t\tif (!station) {\n\t\t\tath10k_warn(ar, \"did not find station from tdls peer event\");\n\t\t\tgoto exit;\n\t\t}\n\n\t\tarvif = ath10k_get_arvif(ar, __le32_to_cpu(ev->vdev_id));\n\t\tif (!arvif) {\n\t\t\tath10k_warn(ar, \"no vif for vdev_id %d found\",\n\t\t\t\t    __le32_to_cpu(ev->vdev_id));\n\t\t\tgoto exit;\n\t\t}\n\n\t\tieee80211_tdls_oper_request(\n\t\t\t\t\tarvif->vif, station->addr,\n\t\t\t\t\tNL80211_TDLS_TEARDOWN,\n\t\t\t\t\tWLAN_REASON_TDLS_TEARDOWN_UNREACHABLE,\n\t\t\t\t\tGFP_ATOMIC\n\t\t\t\t\t);\n\t\tbreak;\n\tdefault:\n\t\tkfree(tb);\n\t\treturn;\n\t}\n\nexit:\n\trcu_read_unlock();\n\tkfree(tb);\n}\n\nstatic int ath10k_wmi_tlv_event_peer_delete_resp(struct ath10k *ar,\n\t\t\t\t\t\t struct sk_buff *skb)\n{\n\tstruct wmi_peer_delete_resp_ev_arg *arg;\n\tstruct wmi_tlv *tlv_hdr;\n\n\ttlv_hdr = (struct wmi_tlv *)skb->data;\n\targ = (struct wmi_peer_delete_resp_ev_arg *)tlv_hdr->value;\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"vdev id %d\", arg->vdev_id);\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"peer mac addr %pM\", &arg->peer_addr);\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv peer delete response\\n\");\n\n\tcomplete(&ar->peer_delete_done);\n\n\treturn 0;\n}\n\n \n \n \n\nstatic void ath10k_wmi_tlv_op_rx(struct ath10k *ar, struct sk_buff *skb)\n{\n\tstruct wmi_cmd_hdr *cmd_hdr;\n\tenum wmi_tlv_event_id id;\n\tbool consumed;\n\n\tcmd_hdr = (struct wmi_cmd_hdr *)skb->data;\n\tid = MS(__le32_to_cpu(cmd_hdr->cmd_id), WMI_CMD_HDR_CMD_ID);\n\n\tif (skb_pull(skb, sizeof(struct wmi_cmd_hdr)) == NULL)\n\t\tgoto out;\n\n\ttrace_ath10k_wmi_event(ar, id, skb->data, skb->len);\n\n\tconsumed = ath10k_tm_event_wmi(ar, id, skb);\n\n\t \n\tif (consumed && id != WMI_TLV_READY_EVENTID) {\n\t\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t\t   \"wmi tlv testmode consumed 0x%x\\n\", id);\n\t\tgoto out;\n\t}\n\n\tswitch (id) {\n\tcase WMI_TLV_MGMT_RX_EVENTID:\n\t\tath10k_wmi_event_mgmt_rx(ar, skb);\n\t\t \n\t\treturn;\n\tcase WMI_TLV_SCAN_EVENTID:\n\t\tath10k_wmi_event_scan(ar, skb);\n\t\tbreak;\n\tcase WMI_TLV_CHAN_INFO_EVENTID:\n\t\tath10k_wmi_event_chan_info(ar, skb);\n\t\tbreak;\n\tcase WMI_TLV_ECHO_EVENTID:\n\t\tath10k_wmi_event_echo(ar, skb);\n\t\tbreak;\n\tcase WMI_TLV_DEBUG_MESG_EVENTID:\n\t\tath10k_wmi_event_debug_mesg(ar, skb);\n\t\tbreak;\n\tcase WMI_TLV_UPDATE_STATS_EVENTID:\n\t\tath10k_wmi_event_update_stats(ar, skb);\n\t\tbreak;\n\tcase WMI_TLV_PEER_STATS_INFO_EVENTID:\n\t\tath10k_wmi_tlv_event_peer_stats_info(ar, skb);\n\t\tbreak;\n\tcase WMI_TLV_VDEV_START_RESP_EVENTID:\n\t\tath10k_wmi_event_vdev_start_resp(ar, skb);\n\t\tbreak;\n\tcase WMI_TLV_VDEV_STOPPED_EVENTID:\n\t\tath10k_wmi_event_vdev_stopped(ar, skb);\n\t\tbreak;\n\tcase WMI_TLV_VDEV_DELETE_RESP_EVENTID:\n\t\tath10k_wmi_tlv_event_vdev_delete_resp(ar, skb);\n\t\tbreak;\n\tcase WMI_TLV_PEER_STA_KICKOUT_EVENTID:\n\t\tath10k_wmi_event_peer_sta_kickout(ar, skb);\n\t\tbreak;\n\tcase WMI_TLV_HOST_SWBA_EVENTID:\n\t\tath10k_wmi_event_host_swba(ar, skb);\n\t\tbreak;\n\tcase WMI_TLV_TBTTOFFSET_UPDATE_EVENTID:\n\t\tath10k_wmi_event_tbttoffset_update(ar, skb);\n\t\tbreak;\n\tcase WMI_TLV_PHYERR_EVENTID:\n\t\tath10k_wmi_event_phyerr(ar, skb);\n\t\tbreak;\n\tcase WMI_TLV_ROAM_EVENTID:\n\t\tath10k_wmi_event_roam(ar, skb);\n\t\tbreak;\n\tcase WMI_TLV_PROFILE_MATCH:\n\t\tath10k_wmi_event_profile_match(ar, skb);\n\t\tbreak;\n\tcase WMI_TLV_DEBUG_PRINT_EVENTID:\n\t\tath10k_wmi_event_debug_print(ar, skb);\n\t\tbreak;\n\tcase WMI_TLV_PDEV_QVIT_EVENTID:\n\t\tath10k_wmi_event_pdev_qvit(ar, skb);\n\t\tbreak;\n\tcase WMI_TLV_WLAN_PROFILE_DATA_EVENTID:\n\t\tath10k_wmi_event_wlan_profile_data(ar, skb);\n\t\tbreak;\n\tcase WMI_TLV_RTT_MEASUREMENT_REPORT_EVENTID:\n\t\tath10k_wmi_event_rtt_measurement_report(ar, skb);\n\t\tbreak;\n\tcase WMI_TLV_TSF_MEASUREMENT_REPORT_EVENTID:\n\t\tath10k_wmi_event_tsf_measurement_report(ar, skb);\n\t\tbreak;\n\tcase WMI_TLV_RTT_ERROR_REPORT_EVENTID:\n\t\tath10k_wmi_event_rtt_error_report(ar, skb);\n\t\tbreak;\n\tcase WMI_TLV_WOW_WAKEUP_HOST_EVENTID:\n\t\tath10k_wmi_event_wow_wakeup_host(ar, skb);\n\t\tbreak;\n\tcase WMI_TLV_DCS_INTERFERENCE_EVENTID:\n\t\tath10k_wmi_event_dcs_interference(ar, skb);\n\t\tbreak;\n\tcase WMI_TLV_PDEV_TPC_CONFIG_EVENTID:\n\t\tath10k_wmi_event_pdev_tpc_config(ar, skb);\n\t\tbreak;\n\tcase WMI_TLV_PDEV_FTM_INTG_EVENTID:\n\t\tath10k_wmi_event_pdev_ftm_intg(ar, skb);\n\t\tbreak;\n\tcase WMI_TLV_GTK_OFFLOAD_STATUS_EVENTID:\n\t\tath10k_wmi_event_gtk_offload_status(ar, skb);\n\t\tbreak;\n\tcase WMI_TLV_GTK_REKEY_FAIL_EVENTID:\n\t\tath10k_wmi_event_gtk_rekey_fail(ar, skb);\n\t\tbreak;\n\tcase WMI_TLV_TX_DELBA_COMPLETE_EVENTID:\n\t\tath10k_wmi_event_delba_complete(ar, skb);\n\t\tbreak;\n\tcase WMI_TLV_TX_ADDBA_COMPLETE_EVENTID:\n\t\tath10k_wmi_event_addba_complete(ar, skb);\n\t\tbreak;\n\tcase WMI_TLV_VDEV_INSTALL_KEY_COMPLETE_EVENTID:\n\t\tath10k_wmi_event_vdev_install_key_complete(ar, skb);\n\t\tbreak;\n\tcase WMI_TLV_SERVICE_READY_EVENTID:\n\t\tath10k_wmi_event_service_ready(ar, skb);\n\t\treturn;\n\tcase WMI_TLV_READY_EVENTID:\n\t\tath10k_wmi_event_ready(ar, skb);\n\t\tbreak;\n\tcase WMI_TLV_SERVICE_AVAILABLE_EVENTID:\n\t\tath10k_wmi_event_service_available(ar, skb);\n\t\tbreak;\n\tcase WMI_TLV_OFFLOAD_BCN_TX_STATUS_EVENTID:\n\t\tath10k_wmi_tlv_event_bcn_tx_status(ar, skb);\n\t\tbreak;\n\tcase WMI_TLV_DIAG_DATA_CONTAINER_EVENTID:\n\t\tath10k_wmi_tlv_event_diag_data(ar, skb);\n\t\tbreak;\n\tcase WMI_TLV_DIAG_EVENTID:\n\t\tath10k_wmi_tlv_event_diag(ar, skb);\n\t\tbreak;\n\tcase WMI_TLV_P2P_NOA_EVENTID:\n\t\tath10k_wmi_tlv_event_p2p_noa(ar, skb);\n\t\tbreak;\n\tcase WMI_TLV_TX_PAUSE_EVENTID:\n\t\tath10k_wmi_tlv_event_tx_pause(ar, skb);\n\t\tbreak;\n\tcase WMI_TLV_RFKILL_STATE_CHANGE_EVENTID:\n\t\tath10k_wmi_tlv_event_rfkill_state_change(ar, skb);\n\t\tbreak;\n\tcase WMI_TLV_PDEV_TEMPERATURE_EVENTID:\n\t\tath10k_wmi_tlv_event_temperature(ar, skb);\n\t\tbreak;\n\tcase WMI_TLV_TDLS_PEER_EVENTID:\n\t\tath10k_wmi_event_tdls_peer(ar, skb);\n\t\tbreak;\n\tcase WMI_TLV_PEER_DELETE_RESP_EVENTID:\n\t\tath10k_wmi_tlv_event_peer_delete_resp(ar, skb);\n\t\tbreak;\n\tcase WMI_TLV_MGMT_TX_COMPLETION_EVENTID:\n\t\tath10k_wmi_event_mgmt_tx_compl(ar, skb);\n\t\tbreak;\n\tcase WMI_TLV_MGMT_TX_BUNDLE_COMPLETION_EVENTID:\n\t\tath10k_wmi_event_mgmt_tx_bundle_compl(ar, skb);\n\t\tbreak;\n\tdefault:\n\t\tath10k_dbg(ar, ATH10K_DBG_WMI, \"Unknown eventid: %d\\n\", id);\n\t\tbreak;\n\t}\n\nout:\n\tdev_kfree_skb(skb);\n}\n\nstatic int ath10k_wmi_tlv_op_pull_scan_ev(struct ath10k *ar,\n\t\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t\t  struct wmi_scan_ev_arg *arg)\n{\n\tconst void **tb;\n\tconst struct wmi_scan_event *ev;\n\tint ret;\n\n\ttb = ath10k_wmi_tlv_parse_alloc(ar, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath10k_warn(ar, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = tb[WMI_TLV_TAG_STRUCT_SCAN_EVENT];\n\tif (!ev) {\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\targ->event_type = ev->event_type;\n\targ->reason = ev->reason;\n\targ->channel_freq = ev->channel_freq;\n\targ->scan_req_id = ev->scan_req_id;\n\targ->scan_id = ev->scan_id;\n\targ->vdev_id = ev->vdev_id;\n\n\tkfree(tb);\n\treturn 0;\n}\n\nstatic int\nath10k_wmi_tlv_op_pull_mgmt_tx_compl_ev(struct ath10k *ar, struct sk_buff *skb,\n\t\t\t\t\tstruct wmi_tlv_mgmt_tx_compl_ev_arg *arg)\n{\n\tconst void **tb;\n\tconst struct wmi_tlv_mgmt_tx_compl_ev *ev;\n\tint ret;\n\n\ttb = ath10k_wmi_tlv_parse_alloc(ar, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath10k_warn(ar, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = tb[WMI_TLV_TAG_STRUCT_MGMT_TX_COMPL_EVENT];\n\n\targ->desc_id = ev->desc_id;\n\targ->status = ev->status;\n\targ->pdev_id = ev->pdev_id;\n\targ->ppdu_id = ev->ppdu_id;\n\n\tif (test_bit(WMI_SERVICE_TX_DATA_ACK_RSSI, ar->wmi.svc_map))\n\t\targ->ack_rssi = ev->ack_rssi;\n\n\tkfree(tb);\n\treturn 0;\n}\n\nstruct wmi_tlv_tx_bundle_compl_parse {\n\tconst __le32 *num_reports;\n\tconst __le32 *desc_ids;\n\tconst __le32 *status;\n\tconst __le32 *ppdu_ids;\n\tconst __le32 *ack_rssi;\n\tbool desc_ids_done;\n\tbool status_done;\n\tbool ppdu_ids_done;\n\tbool ack_rssi_done;\n};\n\nstatic int\nath10k_wmi_tlv_mgmt_tx_bundle_compl_parse(struct ath10k *ar, u16 tag, u16 len,\n\t\t\t\t\t  const void *ptr, void *data)\n{\n\tstruct wmi_tlv_tx_bundle_compl_parse *bundle_tx_compl = data;\n\n\tswitch (tag) {\n\tcase WMI_TLV_TAG_STRUCT_MGMT_TX_COMPL_BUNDLE_EVENT:\n\t\tbundle_tx_compl->num_reports = ptr;\n\t\tbreak;\n\tcase WMI_TLV_TAG_ARRAY_UINT32:\n\t\tif (!bundle_tx_compl->desc_ids_done) {\n\t\t\tbundle_tx_compl->desc_ids_done = true;\n\t\t\tbundle_tx_compl->desc_ids = ptr;\n\t\t} else if (!bundle_tx_compl->status_done) {\n\t\t\tbundle_tx_compl->status_done = true;\n\t\t\tbundle_tx_compl->status = ptr;\n\t\t} else if (!bundle_tx_compl->ppdu_ids_done) {\n\t\t\tbundle_tx_compl->ppdu_ids_done = true;\n\t\t\tbundle_tx_compl->ppdu_ids = ptr;\n\t\t} else if (!bundle_tx_compl->ack_rssi_done) {\n\t\t\tbundle_tx_compl->ack_rssi_done = true;\n\t\t\tbundle_tx_compl->ack_rssi = ptr;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int ath10k_wmi_tlv_op_pull_mgmt_tx_bundle_compl_ev(\n\t\t\t\tstruct ath10k *ar, struct sk_buff *skb,\n\t\t\t\tstruct wmi_tlv_mgmt_tx_bundle_compl_ev_arg *arg)\n{\n\tstruct wmi_tlv_tx_bundle_compl_parse bundle_tx_compl = { };\n\tint ret;\n\n\tret = ath10k_wmi_tlv_iter(ar, skb->data, skb->len,\n\t\t\t\t  ath10k_wmi_tlv_mgmt_tx_bundle_compl_parse,\n\t\t\t\t  &bundle_tx_compl);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (!bundle_tx_compl.num_reports || !bundle_tx_compl.desc_ids ||\n\t    !bundle_tx_compl.status)\n\t\treturn -EPROTO;\n\n\targ->num_reports = *bundle_tx_compl.num_reports;\n\targ->desc_ids = bundle_tx_compl.desc_ids;\n\targ->status = bundle_tx_compl.status;\n\targ->ppdu_ids = bundle_tx_compl.ppdu_ids;\n\n\tif (test_bit(WMI_SERVICE_TX_DATA_ACK_RSSI, ar->wmi.svc_map))\n\t\targ->ack_rssi = bundle_tx_compl.ack_rssi;\n\n\treturn 0;\n}\n\nstatic int ath10k_wmi_tlv_op_pull_mgmt_rx_ev(struct ath10k *ar,\n\t\t\t\t\t     struct sk_buff *skb,\n\t\t\t\t\t     struct wmi_mgmt_rx_ev_arg *arg)\n{\n\tconst void **tb;\n\tconst struct wmi_tlv_mgmt_rx_ev *ev;\n\tconst u8 *frame;\n\tu32 msdu_len;\n\tint ret, i;\n\n\ttb = ath10k_wmi_tlv_parse_alloc(ar, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath10k_warn(ar, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = tb[WMI_TLV_TAG_STRUCT_MGMT_RX_HDR];\n\tframe = tb[WMI_TLV_TAG_ARRAY_BYTE];\n\n\tif (!ev || !frame) {\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\targ->channel = ev->channel;\n\targ->buf_len = ev->buf_len;\n\targ->status = ev->status;\n\targ->snr = ev->snr;\n\targ->phy_mode = ev->phy_mode;\n\targ->rate = ev->rate;\n\n\tfor (i = 0; i < ARRAY_SIZE(ev->rssi); i++)\n\t\targ->rssi[i] = ev->rssi[i];\n\n\tmsdu_len = __le32_to_cpu(arg->buf_len);\n\n\tif (skb->len < (frame - skb->data) + msdu_len) {\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\t \n\tskb_trim(skb, 0);\n\tskb_put(skb, frame - skb->data);\n\tskb_pull(skb, frame - skb->data);\n\tskb_put(skb, msdu_len);\n\n\tkfree(tb);\n\treturn 0;\n}\n\nstatic int ath10k_wmi_tlv_op_pull_ch_info_ev(struct ath10k *ar,\n\t\t\t\t\t     struct sk_buff *skb,\n\t\t\t\t\t     struct wmi_ch_info_ev_arg *arg)\n{\n\tconst void **tb;\n\tconst struct wmi_tlv_chan_info_event *ev;\n\tint ret;\n\n\ttb = ath10k_wmi_tlv_parse_alloc(ar, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath10k_warn(ar, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = tb[WMI_TLV_TAG_STRUCT_CHAN_INFO_EVENT];\n\tif (!ev) {\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\targ->err_code = ev->err_code;\n\targ->freq = ev->freq;\n\targ->cmd_flags = ev->cmd_flags;\n\targ->noise_floor = ev->noise_floor;\n\targ->rx_clear_count = ev->rx_clear_count;\n\targ->cycle_count = ev->cycle_count;\n\tif (test_bit(ATH10K_FW_FEATURE_SINGLE_CHAN_INFO_PER_CHANNEL,\n\t\t     ar->running_fw->fw_file.fw_features))\n\t\targ->mac_clk_mhz = ev->mac_clk_mhz;\n\n\tkfree(tb);\n\treturn 0;\n}\n\nstatic int\nath10k_wmi_tlv_op_pull_vdev_start_ev(struct ath10k *ar, struct sk_buff *skb,\n\t\t\t\t     struct wmi_vdev_start_ev_arg *arg)\n{\n\tconst void **tb;\n\tconst struct wmi_vdev_start_response_event *ev;\n\tint ret;\n\n\ttb = ath10k_wmi_tlv_parse_alloc(ar, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath10k_warn(ar, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = tb[WMI_TLV_TAG_STRUCT_VDEV_START_RESPONSE_EVENT];\n\tif (!ev) {\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\tskb_pull(skb, sizeof(*ev));\n\targ->vdev_id = ev->vdev_id;\n\targ->req_id = ev->req_id;\n\targ->resp_type = ev->resp_type;\n\targ->status = ev->status;\n\n\tkfree(tb);\n\treturn 0;\n}\n\nstatic int ath10k_wmi_tlv_op_pull_peer_kick_ev(struct ath10k *ar,\n\t\t\t\t\t       struct sk_buff *skb,\n\t\t\t\t\t       struct wmi_peer_kick_ev_arg *arg)\n{\n\tconst void **tb;\n\tconst struct wmi_peer_sta_kickout_event *ev;\n\tint ret;\n\n\ttb = ath10k_wmi_tlv_parse_alloc(ar, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath10k_warn(ar, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = tb[WMI_TLV_TAG_STRUCT_PEER_STA_KICKOUT_EVENT];\n\tif (!ev) {\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\targ->mac_addr = ev->peer_macaddr.addr;\n\n\tkfree(tb);\n\treturn 0;\n}\n\nstruct wmi_tlv_swba_parse {\n\tconst struct wmi_host_swba_event *ev;\n\tbool tim_done;\n\tbool noa_done;\n\tsize_t n_tim;\n\tsize_t n_noa;\n\tstruct wmi_swba_ev_arg *arg;\n};\n\nstatic int ath10k_wmi_tlv_swba_tim_parse(struct ath10k *ar, u16 tag, u16 len,\n\t\t\t\t\t const void *ptr, void *data)\n{\n\tstruct wmi_tlv_swba_parse *swba = data;\n\tstruct wmi_tim_info_arg *tim_info_arg;\n\tconst struct wmi_tim_info *tim_info_ev = ptr;\n\n\tif (tag != WMI_TLV_TAG_STRUCT_TIM_INFO)\n\t\treturn -EPROTO;\n\n\tif (swba->n_tim >= ARRAY_SIZE(swba->arg->tim_info))\n\t\treturn -ENOBUFS;\n\n\tif (__le32_to_cpu(tim_info_ev->tim_len) >\n\t     sizeof(tim_info_ev->tim_bitmap)) {\n\t\tath10k_warn(ar, \"refusing to parse invalid swba structure\\n\");\n\t\treturn -EPROTO;\n\t}\n\n\ttim_info_arg = &swba->arg->tim_info[swba->n_tim];\n\ttim_info_arg->tim_len = tim_info_ev->tim_len;\n\ttim_info_arg->tim_mcast = tim_info_ev->tim_mcast;\n\ttim_info_arg->tim_bitmap = tim_info_ev->tim_bitmap;\n\ttim_info_arg->tim_changed = tim_info_ev->tim_changed;\n\ttim_info_arg->tim_num_ps_pending = tim_info_ev->tim_num_ps_pending;\n\n\tswba->n_tim++;\n\n\treturn 0;\n}\n\nstatic int ath10k_wmi_tlv_swba_noa_parse(struct ath10k *ar, u16 tag, u16 len,\n\t\t\t\t\t const void *ptr, void *data)\n{\n\tstruct wmi_tlv_swba_parse *swba = data;\n\n\tif (tag != WMI_TLV_TAG_STRUCT_P2P_NOA_INFO)\n\t\treturn -EPROTO;\n\n\tif (swba->n_noa >= ARRAY_SIZE(swba->arg->noa_info))\n\t\treturn -ENOBUFS;\n\n\tswba->arg->noa_info[swba->n_noa++] = ptr;\n\treturn 0;\n}\n\nstatic int ath10k_wmi_tlv_swba_parse(struct ath10k *ar, u16 tag, u16 len,\n\t\t\t\t     const void *ptr, void *data)\n{\n\tstruct wmi_tlv_swba_parse *swba = data;\n\tint ret;\n\n\tswitch (tag) {\n\tcase WMI_TLV_TAG_STRUCT_HOST_SWBA_EVENT:\n\t\tswba->ev = ptr;\n\t\tbreak;\n\tcase WMI_TLV_TAG_ARRAY_STRUCT:\n\t\tif (!swba->tim_done) {\n\t\t\tswba->tim_done = true;\n\t\t\tret = ath10k_wmi_tlv_iter(ar, ptr, len,\n\t\t\t\t\t\t  ath10k_wmi_tlv_swba_tim_parse,\n\t\t\t\t\t\t  swba);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t} else if (!swba->noa_done) {\n\t\t\tswba->noa_done = true;\n\t\t\tret = ath10k_wmi_tlv_iter(ar, ptr, len,\n\t\t\t\t\t\t  ath10k_wmi_tlv_swba_noa_parse,\n\t\t\t\t\t\t  swba);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int ath10k_wmi_tlv_op_pull_swba_ev(struct ath10k *ar,\n\t\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t\t  struct wmi_swba_ev_arg *arg)\n{\n\tstruct wmi_tlv_swba_parse swba = { .arg = arg };\n\tu32 map;\n\tsize_t n_vdevs;\n\tint ret;\n\n\tret = ath10k_wmi_tlv_iter(ar, skb->data, skb->len,\n\t\t\t\t  ath10k_wmi_tlv_swba_parse, &swba);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (!swba.ev)\n\t\treturn -EPROTO;\n\n\targ->vdev_map = swba.ev->vdev_map;\n\n\tfor (map = __le32_to_cpu(arg->vdev_map), n_vdevs = 0; map; map >>= 1)\n\t\tif (map & BIT(0))\n\t\t\tn_vdevs++;\n\n\tif (n_vdevs != swba.n_tim ||\n\t    n_vdevs != swba.n_noa)\n\t\treturn -EPROTO;\n\n\treturn 0;\n}\n\nstatic int ath10k_wmi_tlv_op_pull_phyerr_ev_hdr(struct ath10k *ar,\n\t\t\t\t\t\tstruct sk_buff *skb,\n\t\t\t\t\t\tstruct wmi_phyerr_hdr_arg *arg)\n{\n\tconst void **tb;\n\tconst struct wmi_tlv_phyerr_ev *ev;\n\tconst void *phyerrs;\n\tint ret;\n\n\ttb = ath10k_wmi_tlv_parse_alloc(ar, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath10k_warn(ar, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = tb[WMI_TLV_TAG_STRUCT_COMB_PHYERR_RX_HDR];\n\tphyerrs = tb[WMI_TLV_TAG_ARRAY_BYTE];\n\n\tif (!ev || !phyerrs) {\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\targ->num_phyerrs  = __le32_to_cpu(ev->num_phyerrs);\n\targ->tsf_l32 = __le32_to_cpu(ev->tsf_l32);\n\targ->tsf_u32 = __le32_to_cpu(ev->tsf_u32);\n\targ->buf_len = __le32_to_cpu(ev->buf_len);\n\targ->phyerrs = phyerrs;\n\n\tkfree(tb);\n\treturn 0;\n}\n\n#define WMI_TLV_ABI_VER_NS0 0x5F414351\n#define WMI_TLV_ABI_VER_NS1 0x00004C4D\n#define WMI_TLV_ABI_VER_NS2 0x00000000\n#define WMI_TLV_ABI_VER_NS3 0x00000000\n\n#define WMI_TLV_ABI_VER0_MAJOR 1\n#define WMI_TLV_ABI_VER0_MINOR 0\n#define WMI_TLV_ABI_VER0 ((((WMI_TLV_ABI_VER0_MAJOR) << 24) & 0xFF000000) | \\\n\t\t\t  (((WMI_TLV_ABI_VER0_MINOR) <<  0) & 0x00FFFFFF))\n#define WMI_TLV_ABI_VER1 53\n\nstatic int\nath10k_wmi_tlv_parse_mem_reqs(struct ath10k *ar, u16 tag, u16 len,\n\t\t\t      const void *ptr, void *data)\n{\n\tstruct wmi_svc_rdy_ev_arg *arg = data;\n\tint i;\n\n\tif (tag != WMI_TLV_TAG_STRUCT_WLAN_HOST_MEM_REQ)\n\t\treturn -EPROTO;\n\n\tfor (i = 0; i < ARRAY_SIZE(arg->mem_reqs); i++) {\n\t\tif (!arg->mem_reqs[i]) {\n\t\t\targ->mem_reqs[i] = ptr;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ENOMEM;\n}\n\nstruct wmi_tlv_svc_rdy_parse {\n\tconst struct hal_reg_capabilities *reg;\n\tconst struct wmi_tlv_svc_rdy_ev *ev;\n\tconst __le32 *svc_bmap;\n\tconst struct wlan_host_mem_req *mem_reqs;\n\tbool svc_bmap_done;\n\tbool dbs_hw_mode_done;\n};\n\nstatic int ath10k_wmi_tlv_svc_rdy_parse(struct ath10k *ar, u16 tag, u16 len,\n\t\t\t\t\tconst void *ptr, void *data)\n{\n\tstruct wmi_tlv_svc_rdy_parse *svc_rdy = data;\n\n\tswitch (tag) {\n\tcase WMI_TLV_TAG_STRUCT_SERVICE_READY_EVENT:\n\t\tsvc_rdy->ev = ptr;\n\t\tbreak;\n\tcase WMI_TLV_TAG_STRUCT_HAL_REG_CAPABILITIES:\n\t\tsvc_rdy->reg = ptr;\n\t\tbreak;\n\tcase WMI_TLV_TAG_ARRAY_STRUCT:\n\t\tsvc_rdy->mem_reqs = ptr;\n\t\tbreak;\n\tcase WMI_TLV_TAG_ARRAY_UINT32:\n\t\tif (!svc_rdy->svc_bmap_done) {\n\t\t\tsvc_rdy->svc_bmap_done = true;\n\t\t\tsvc_rdy->svc_bmap = ptr;\n\t\t} else if (!svc_rdy->dbs_hw_mode_done) {\n\t\t\tsvc_rdy->dbs_hw_mode_done = true;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int ath10k_wmi_tlv_op_pull_svc_rdy_ev(struct ath10k *ar,\n\t\t\t\t\t     struct sk_buff *skb,\n\t\t\t\t\t     struct wmi_svc_rdy_ev_arg *arg)\n{\n\tconst struct hal_reg_capabilities *reg;\n\tconst struct wmi_tlv_svc_rdy_ev *ev;\n\tconst __le32 *svc_bmap;\n\tconst struct wlan_host_mem_req *mem_reqs;\n\tstruct wmi_tlv_svc_rdy_parse svc_rdy = { };\n\tint ret;\n\n\tret = ath10k_wmi_tlv_iter(ar, skb->data, skb->len,\n\t\t\t\t  ath10k_wmi_tlv_svc_rdy_parse, &svc_rdy);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = svc_rdy.ev;\n\treg = svc_rdy.reg;\n\tsvc_bmap = svc_rdy.svc_bmap;\n\tmem_reqs = svc_rdy.mem_reqs;\n\n\tif (!ev || !reg || !svc_bmap || !mem_reqs)\n\t\treturn -EPROTO;\n\n\t \n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi tlv abi 0x%08x ?= 0x%08x, 0x%08x ?= 0x%08x, 0x%08x ?= 0x%08x, 0x%08x ?= 0x%08x, 0x%08x ?= 0x%08x\\n\",\n\t\t   __le32_to_cpu(ev->abi.abi_ver0), WMI_TLV_ABI_VER0,\n\t\t   __le32_to_cpu(ev->abi.abi_ver_ns0), WMI_TLV_ABI_VER_NS0,\n\t\t   __le32_to_cpu(ev->abi.abi_ver_ns1), WMI_TLV_ABI_VER_NS1,\n\t\t   __le32_to_cpu(ev->abi.abi_ver_ns2), WMI_TLV_ABI_VER_NS2,\n\t\t   __le32_to_cpu(ev->abi.abi_ver_ns3), WMI_TLV_ABI_VER_NS3);\n\n\tif (__le32_to_cpu(ev->abi.abi_ver0) != WMI_TLV_ABI_VER0 ||\n\t    __le32_to_cpu(ev->abi.abi_ver_ns0) != WMI_TLV_ABI_VER_NS0 ||\n\t    __le32_to_cpu(ev->abi.abi_ver_ns1) != WMI_TLV_ABI_VER_NS1 ||\n\t    __le32_to_cpu(ev->abi.abi_ver_ns2) != WMI_TLV_ABI_VER_NS2 ||\n\t    __le32_to_cpu(ev->abi.abi_ver_ns3) != WMI_TLV_ABI_VER_NS3) {\n\t\treturn -ENOTSUPP;\n\t}\n\n\targ->min_tx_power = ev->hw_min_tx_power;\n\targ->max_tx_power = ev->hw_max_tx_power;\n\targ->ht_cap = ev->ht_cap_info;\n\targ->vht_cap = ev->vht_cap_info;\n\targ->vht_supp_mcs = ev->vht_supp_mcs;\n\targ->sw_ver0 = ev->abi.abi_ver0;\n\targ->sw_ver1 = ev->abi.abi_ver1;\n\targ->fw_build = ev->fw_build_vers;\n\targ->phy_capab = ev->phy_capability;\n\targ->num_rf_chains = ev->num_rf_chains;\n\targ->eeprom_rd = reg->eeprom_rd;\n\targ->low_2ghz_chan = reg->low_2ghz_chan;\n\targ->high_2ghz_chan = reg->high_2ghz_chan;\n\targ->low_5ghz_chan = reg->low_5ghz_chan;\n\targ->high_5ghz_chan = reg->high_5ghz_chan;\n\targ->num_mem_reqs = ev->num_mem_reqs;\n\targ->service_map = svc_bmap;\n\targ->service_map_len = ath10k_wmi_tlv_len(svc_bmap);\n\targ->sys_cap_info = ev->sys_cap_info;\n\n\tret = ath10k_wmi_tlv_iter(ar, mem_reqs, ath10k_wmi_tlv_len(mem_reqs),\n\t\t\t\t  ath10k_wmi_tlv_parse_mem_reqs, arg);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to parse mem_reqs tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_wmi_tlv_op_pull_rdy_ev(struct ath10k *ar,\n\t\t\t\t\t struct sk_buff *skb,\n\t\t\t\t\t struct wmi_rdy_ev_arg *arg)\n{\n\tconst void **tb;\n\tconst struct wmi_tlv_rdy_ev *ev;\n\tint ret;\n\n\ttb = ath10k_wmi_tlv_parse_alloc(ar, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath10k_warn(ar, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = tb[WMI_TLV_TAG_STRUCT_READY_EVENT];\n\tif (!ev) {\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\targ->sw_version = ev->abi.abi_ver0;\n\targ->abi_version = ev->abi.abi_ver1;\n\targ->status = ev->status;\n\targ->mac_addr = ev->mac_addr.addr;\n\n\tkfree(tb);\n\treturn 0;\n}\n\nstatic int ath10k_wmi_tlv_svc_avail_parse(struct ath10k *ar, u16 tag, u16 len,\n\t\t\t\t\t  const void *ptr, void *data)\n{\n\tstruct wmi_svc_avail_ev_arg *arg = data;\n\n\tswitch (tag) {\n\tcase WMI_TLV_TAG_STRUCT_SERVICE_AVAILABLE_EVENT:\n\t\targ->service_map_ext_valid = true;\n\t\targ->service_map_ext_len = *(__le32 *)ptr;\n\t\targ->service_map_ext = ptr + sizeof(__le32);\n\t\treturn 0;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_wmi_tlv_op_pull_svc_avail(struct ath10k *ar,\n\t\t\t\t\t    struct sk_buff *skb,\n\t\t\t\t\t    struct wmi_svc_avail_ev_arg *arg)\n{\n\tint ret;\n\n\tret = ath10k_wmi_tlv_iter(ar, skb->data, skb->len,\n\t\t\t\t  ath10k_wmi_tlv_svc_avail_parse, arg);\n\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to parse svc_avail tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void ath10k_wmi_tlv_pull_vdev_stats(const struct wmi_tlv_vdev_stats *src,\n\t\t\t\t\t   struct ath10k_fw_stats_vdev *dst)\n{\n\tint i;\n\n\tdst->vdev_id = __le32_to_cpu(src->vdev_id);\n\tdst->beacon_snr = __le32_to_cpu(src->beacon_snr);\n\tdst->data_snr = __le32_to_cpu(src->data_snr);\n\tdst->num_rx_frames = __le32_to_cpu(src->num_rx_frames);\n\tdst->num_rts_fail = __le32_to_cpu(src->num_rts_fail);\n\tdst->num_rts_success = __le32_to_cpu(src->num_rts_success);\n\tdst->num_rx_err = __le32_to_cpu(src->num_rx_err);\n\tdst->num_rx_discard = __le32_to_cpu(src->num_rx_discard);\n\tdst->num_tx_not_acked = __le32_to_cpu(src->num_tx_not_acked);\n\n\tfor (i = 0; i < ARRAY_SIZE(src->num_tx_frames); i++)\n\t\tdst->num_tx_frames[i] =\n\t\t\t__le32_to_cpu(src->num_tx_frames[i]);\n\n\tfor (i = 0; i < ARRAY_SIZE(src->num_tx_frames_retries); i++)\n\t\tdst->num_tx_frames_retries[i] =\n\t\t\t__le32_to_cpu(src->num_tx_frames_retries[i]);\n\n\tfor (i = 0; i < ARRAY_SIZE(src->num_tx_frames_failures); i++)\n\t\tdst->num_tx_frames_failures[i] =\n\t\t\t__le32_to_cpu(src->num_tx_frames_failures[i]);\n\n\tfor (i = 0; i < ARRAY_SIZE(src->tx_rate_history); i++)\n\t\tdst->tx_rate_history[i] =\n\t\t\t__le32_to_cpu(src->tx_rate_history[i]);\n\n\tfor (i = 0; i < ARRAY_SIZE(src->beacon_rssi_history); i++)\n\t\tdst->beacon_rssi_history[i] =\n\t\t\t__le32_to_cpu(src->beacon_rssi_history[i]);\n}\n\nstatic int ath10k_wmi_tlv_op_pull_fw_stats(struct ath10k *ar,\n\t\t\t\t\t   struct sk_buff *skb,\n\t\t\t\t\t   struct ath10k_fw_stats *stats)\n{\n\tconst void **tb;\n\tconst struct wmi_tlv_stats_ev *ev;\n\tu32 num_peer_stats_extd;\n\tconst void *data;\n\tu32 num_pdev_stats;\n\tu32 num_vdev_stats;\n\tu32 num_peer_stats;\n\tu32 num_bcnflt_stats;\n\tu32 num_chan_stats;\n\tsize_t data_len;\n\tu32 stats_id;\n\tint ret;\n\tint i;\n\n\ttb = ath10k_wmi_tlv_parse_alloc(ar, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath10k_warn(ar, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = tb[WMI_TLV_TAG_STRUCT_STATS_EVENT];\n\tdata = tb[WMI_TLV_TAG_ARRAY_BYTE];\n\n\tif (!ev || !data) {\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\tdata_len = ath10k_wmi_tlv_len(data);\n\tnum_pdev_stats = __le32_to_cpu(ev->num_pdev_stats);\n\tnum_vdev_stats = __le32_to_cpu(ev->num_vdev_stats);\n\tnum_peer_stats = __le32_to_cpu(ev->num_peer_stats);\n\tnum_bcnflt_stats = __le32_to_cpu(ev->num_bcnflt_stats);\n\tnum_chan_stats = __le32_to_cpu(ev->num_chan_stats);\n\tstats_id = __le32_to_cpu(ev->stats_id);\n\tnum_peer_stats_extd = __le32_to_cpu(ev->num_peer_stats_extd);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi tlv stats update pdev %i vdev %i peer %i bcnflt %i chan %i peer_extd %i\\n\",\n\t\t   num_pdev_stats, num_vdev_stats, num_peer_stats,\n\t\t   num_bcnflt_stats, num_chan_stats, num_peer_stats_extd);\n\n\tfor (i = 0; i < num_pdev_stats; i++) {\n\t\tconst struct wmi_pdev_stats *src;\n\t\tstruct ath10k_fw_stats_pdev *dst;\n\n\t\tsrc = data;\n\t\tif (data_len < sizeof(*src)) {\n\t\t\tkfree(tb);\n\t\t\treturn -EPROTO;\n\t\t}\n\n\t\tdata += sizeof(*src);\n\t\tdata_len -= sizeof(*src);\n\n\t\tdst = kzalloc(sizeof(*dst), GFP_ATOMIC);\n\t\tif (!dst)\n\t\t\tcontinue;\n\n\t\tath10k_wmi_pull_pdev_stats_base(&src->base, dst);\n\t\tath10k_wmi_pull_pdev_stats_tx(&src->tx, dst);\n\t\tath10k_wmi_pull_pdev_stats_rx(&src->rx, dst);\n\t\tlist_add_tail(&dst->list, &stats->pdevs);\n\t}\n\n\tfor (i = 0; i < num_vdev_stats; i++) {\n\t\tconst struct wmi_tlv_vdev_stats *src;\n\t\tstruct ath10k_fw_stats_vdev *dst;\n\n\t\tsrc = data;\n\t\tif (data_len < sizeof(*src)) {\n\t\t\tkfree(tb);\n\t\t\treturn -EPROTO;\n\t\t}\n\n\t\tdata += sizeof(*src);\n\t\tdata_len -= sizeof(*src);\n\n\t\tdst = kzalloc(sizeof(*dst), GFP_ATOMIC);\n\t\tif (!dst)\n\t\t\tcontinue;\n\n\t\tath10k_wmi_tlv_pull_vdev_stats(src, dst);\n\t\tlist_add_tail(&dst->list, &stats->vdevs);\n\t}\n\n\tfor (i = 0; i < num_peer_stats; i++) {\n\t\tconst struct wmi_10x_peer_stats *src;\n\t\tstruct ath10k_fw_stats_peer *dst;\n\n\t\tsrc = data;\n\t\tif (data_len < sizeof(*src)) {\n\t\t\tkfree(tb);\n\t\t\treturn -EPROTO;\n\t\t}\n\n\t\tdata += sizeof(*src);\n\t\tdata_len -= sizeof(*src);\n\n\t\tdst = kzalloc(sizeof(*dst), GFP_ATOMIC);\n\t\tif (!dst)\n\t\t\tcontinue;\n\n\t\tath10k_wmi_pull_peer_stats(&src->old, dst);\n\t\tdst->peer_rx_rate = __le32_to_cpu(src->peer_rx_rate);\n\n\t\tif (stats_id & WMI_TLV_STAT_PEER_EXTD) {\n\t\t\tconst struct wmi_tlv_peer_stats_extd *extd;\n\t\t\tunsigned long rx_duration_high;\n\n\t\t\textd = data + sizeof(*src) * (num_peer_stats - i - 1)\n\t\t\t       + sizeof(*extd) * i;\n\n\t\t\tdst->rx_duration = __le32_to_cpu(extd->rx_duration);\n\t\t\trx_duration_high = __le32_to_cpu\n\t\t\t\t\t\t(extd->rx_duration_high);\n\n\t\t\tif (test_bit(WMI_TLV_PEER_RX_DURATION_HIGH_VALID_BIT,\n\t\t\t\t     &rx_duration_high)) {\n\t\t\t\trx_duration_high =\n\t\t\t\t\tFIELD_GET(WMI_TLV_PEER_RX_DURATION_HIGH_MASK,\n\t\t\t\t\t\t  rx_duration_high);\n\t\t\t\tdst->rx_duration |= (u64)rx_duration_high <<\n\t\t\t\t\t\t    WMI_TLV_PEER_RX_DURATION_SHIFT;\n\t\t\t}\n\t\t}\n\n\t\tlist_add_tail(&dst->list, &stats->peers);\n\t}\n\n\tkfree(tb);\n\treturn 0;\n}\n\nstatic int ath10k_wmi_tlv_op_pull_roam_ev(struct ath10k *ar,\n\t\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t\t  struct wmi_roam_ev_arg *arg)\n{\n\tconst void **tb;\n\tconst struct wmi_tlv_roam_ev *ev;\n\tint ret;\n\n\ttb = ath10k_wmi_tlv_parse_alloc(ar, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath10k_warn(ar, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = tb[WMI_TLV_TAG_STRUCT_ROAM_EVENT];\n\tif (!ev) {\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\targ->vdev_id = ev->vdev_id;\n\targ->reason = ev->reason;\n\targ->rssi = ev->rssi;\n\n\tkfree(tb);\n\treturn 0;\n}\n\nstatic int\nath10k_wmi_tlv_op_pull_wow_ev(struct ath10k *ar, struct sk_buff *skb,\n\t\t\t      struct wmi_wow_ev_arg *arg)\n{\n\tconst void **tb;\n\tconst struct wmi_tlv_wow_event_info *ev;\n\tint ret;\n\n\ttb = ath10k_wmi_tlv_parse_alloc(ar, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath10k_warn(ar, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = tb[WMI_TLV_TAG_STRUCT_WOW_EVENT_INFO];\n\tif (!ev) {\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\targ->vdev_id = __le32_to_cpu(ev->vdev_id);\n\targ->flag = __le32_to_cpu(ev->flag);\n\targ->wake_reason = __le32_to_cpu(ev->wake_reason);\n\targ->data_len = __le32_to_cpu(ev->data_len);\n\n\tkfree(tb);\n\treturn 0;\n}\n\nstatic int ath10k_wmi_tlv_op_pull_echo_ev(struct ath10k *ar,\n\t\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t\t  struct wmi_echo_ev_arg *arg)\n{\n\tconst void **tb;\n\tconst struct wmi_echo_event *ev;\n\tint ret;\n\n\ttb = ath10k_wmi_tlv_parse_alloc(ar, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath10k_warn(ar, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = tb[WMI_TLV_TAG_STRUCT_ECHO_EVENT];\n\tif (!ev) {\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\targ->value = ev->value;\n\n\tkfree(tb);\n\treturn 0;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_pdev_suspend(struct ath10k *ar, u32 opt)\n{\n\tstruct wmi_tlv_pdev_suspend *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttlv = (void *)skb->data;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_PDEV_SUSPEND_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\tcmd->opt = __cpu_to_le32(opt);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv pdev suspend\\n\");\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_pdev_resume(struct ath10k *ar)\n{\n\tstruct wmi_tlv_resume_cmd *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttlv = (void *)skb->data;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_PDEV_RESUME_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\tcmd->reserved = __cpu_to_le32(0);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv pdev resume\\n\");\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_pdev_set_rd(struct ath10k *ar,\n\t\t\t\t  u16 rd, u16 rd2g, u16 rd5g,\n\t\t\t\t  u16 ctl2g, u16 ctl5g,\n\t\t\t\t  enum wmi_dfs_region dfs_reg)\n{\n\tstruct wmi_tlv_pdev_set_rd_cmd *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttlv = (void *)skb->data;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_PDEV_SET_REGDOMAIN_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\tcmd->regd = __cpu_to_le32(rd);\n\tcmd->regd_2ghz = __cpu_to_le32(rd2g);\n\tcmd->regd_5ghz = __cpu_to_le32(rd5g);\n\tcmd->conform_limit_2ghz = __cpu_to_le32(ctl2g);\n\tcmd->conform_limit_5ghz = __cpu_to_le32(ctl5g);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv pdev set rd\\n\");\n\treturn skb;\n}\n\nstatic enum wmi_txbf_conf ath10k_wmi_tlv_txbf_conf_scheme(struct ath10k *ar)\n{\n\treturn WMI_TXBF_CONF_AFTER_ASSOC;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_pdev_set_param(struct ath10k *ar, u32 param_id,\n\t\t\t\t     u32 param_value)\n{\n\tstruct wmi_tlv_pdev_set_param_cmd *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttlv = (void *)skb->data;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_PDEV_SET_PARAM_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\tcmd->param_id = __cpu_to_le32(param_id);\n\tcmd->param_value = __cpu_to_le32(param_value);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv pdev set param %d value 0x%x\\n\",\n\t\t   param_id, param_value);\n\treturn skb;\n}\n\nstatic void\nath10k_wmi_tlv_put_host_mem_chunks(struct ath10k *ar, void *host_mem_chunks)\n{\n\tstruct host_memory_chunk_tlv *chunk;\n\tstruct wmi_tlv *tlv;\n\tdma_addr_t paddr;\n\tint i;\n\t__le16 tlv_len, tlv_tag;\n\n\ttlv_tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_WLAN_HOST_MEMORY_CHUNK);\n\ttlv_len = __cpu_to_le16(sizeof(*chunk));\n\tfor (i = 0; i < ar->wmi.num_mem_chunks; i++) {\n\t\ttlv = host_mem_chunks;\n\t\ttlv->tag = tlv_tag;\n\t\ttlv->len = tlv_len;\n\t\tchunk = (void *)tlv->value;\n\n\t\tchunk->ptr = __cpu_to_le32(ar->wmi.mem_chunks[i].paddr);\n\t\tchunk->size = __cpu_to_le32(ar->wmi.mem_chunks[i].len);\n\t\tchunk->req_id = __cpu_to_le32(ar->wmi.mem_chunks[i].req_id);\n\n\t\tif (test_bit(WMI_SERVICE_SUPPORT_EXTEND_ADDRESS,\n\t\t\t     ar->wmi.svc_map)) {\n\t\t\tpaddr = ar->wmi.mem_chunks[i].paddr;\n\t\t\tchunk->ptr_high = __cpu_to_le32(upper_32_bits(paddr));\n\t\t}\n\n\t\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t\t   \"wmi-tlv chunk %d len %d, addr 0x%llx, id 0x%x\\n\",\n\t\t\t   i,\n\t\t\t   ar->wmi.mem_chunks[i].len,\n\t\t\t   (unsigned long long)ar->wmi.mem_chunks[i].paddr,\n\t\t\t   ar->wmi.mem_chunks[i].req_id);\n\n\t\thost_mem_chunks += sizeof(*tlv);\n\t\thost_mem_chunks += sizeof(*chunk);\n\t}\n}\n\nstatic struct sk_buff *ath10k_wmi_tlv_op_gen_init(struct ath10k *ar)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_tlv *tlv;\n\tstruct wmi_tlv_init_cmd *cmd;\n\tstruct wmi_tlv_resource_config *cfg;\n\tvoid *chunks;\n\tsize_t len, chunks_len;\n\tvoid *ptr;\n\n\tchunks_len = ar->wmi.num_mem_chunks *\n\t\t     (sizeof(struct host_memory_chunk_tlv) + sizeof(*tlv));\n\tlen = (sizeof(*tlv) + sizeof(*cmd)) +\n\t      (sizeof(*tlv) + sizeof(*cfg)) +\n\t      (sizeof(*tlv) + chunks_len);\n\n\tskb = ath10k_wmi_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tptr = skb->data;\n\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_INIT_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\tptr += sizeof(*tlv);\n\tptr += sizeof(*cmd);\n\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_RESOURCE_CONFIG);\n\ttlv->len = __cpu_to_le16(sizeof(*cfg));\n\tcfg = (void *)tlv->value;\n\tptr += sizeof(*tlv);\n\tptr += sizeof(*cfg);\n\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_STRUCT);\n\ttlv->len = __cpu_to_le16(chunks_len);\n\tchunks = (void *)tlv->value;\n\n\tptr += sizeof(*tlv);\n\tptr += chunks_len;\n\n\tcmd->abi.abi_ver0 = __cpu_to_le32(WMI_TLV_ABI_VER0);\n\tcmd->abi.abi_ver1 = __cpu_to_le32(WMI_TLV_ABI_VER1);\n\tcmd->abi.abi_ver_ns0 = __cpu_to_le32(WMI_TLV_ABI_VER_NS0);\n\tcmd->abi.abi_ver_ns1 = __cpu_to_le32(WMI_TLV_ABI_VER_NS1);\n\tcmd->abi.abi_ver_ns2 = __cpu_to_le32(WMI_TLV_ABI_VER_NS2);\n\tcmd->abi.abi_ver_ns3 = __cpu_to_le32(WMI_TLV_ABI_VER_NS3);\n\tcmd->num_host_mem_chunks = __cpu_to_le32(ar->wmi.num_mem_chunks);\n\n\tcfg->num_vdevs = __cpu_to_le32(TARGET_TLV_NUM_VDEVS);\n\n\tif (ar->hw_params.num_peers)\n\t\tcfg->num_peers = __cpu_to_le32(ar->hw_params.num_peers);\n\telse\n\t\tcfg->num_peers = __cpu_to_le32(TARGET_TLV_NUM_PEERS);\n\tcfg->ast_skid_limit = __cpu_to_le32(ar->hw_params.ast_skid_limit);\n\tcfg->num_wds_entries = __cpu_to_le32(ar->hw_params.num_wds_entries);\n\n\tif (test_bit(WMI_SERVICE_RX_FULL_REORDER, ar->wmi.svc_map)) {\n\t\tcfg->num_offload_peers = __cpu_to_le32(TARGET_TLV_NUM_VDEVS);\n\t\tcfg->num_offload_reorder_bufs = __cpu_to_le32(TARGET_TLV_NUM_VDEVS);\n\t} else {\n\t\tcfg->num_offload_peers = __cpu_to_le32(0);\n\t\tcfg->num_offload_reorder_bufs = __cpu_to_le32(0);\n\t}\n\n\tcfg->num_peer_keys = __cpu_to_le32(2);\n\tif (ar->hw_params.num_peers)\n\t\tcfg->num_tids = __cpu_to_le32(ar->hw_params.num_peers * 2);\n\telse\n\t\tcfg->num_tids = __cpu_to_le32(TARGET_TLV_NUM_TIDS);\n\tcfg->tx_chain_mask = __cpu_to_le32(0x7);\n\tcfg->rx_chain_mask = __cpu_to_le32(0x7);\n\tcfg->rx_timeout_pri[0] = __cpu_to_le32(0x64);\n\tcfg->rx_timeout_pri[1] = __cpu_to_le32(0x64);\n\tcfg->rx_timeout_pri[2] = __cpu_to_le32(0x64);\n\tcfg->rx_timeout_pri[3] = __cpu_to_le32(0x28);\n\tcfg->rx_decap_mode = __cpu_to_le32(ar->wmi.rx_decap_mode);\n\tcfg->scan_max_pending_reqs = __cpu_to_le32(4);\n\tcfg->bmiss_offload_max_vdev = __cpu_to_le32(TARGET_TLV_NUM_VDEVS);\n\tcfg->roam_offload_max_vdev = __cpu_to_le32(TARGET_TLV_NUM_VDEVS);\n\tcfg->roam_offload_max_ap_profiles = __cpu_to_le32(8);\n\tcfg->num_mcast_groups = __cpu_to_le32(0);\n\tcfg->num_mcast_table_elems = __cpu_to_le32(0);\n\tcfg->mcast2ucast_mode = __cpu_to_le32(0);\n\tcfg->tx_dbg_log_size = __cpu_to_le32(0x400);\n\tcfg->dma_burst_size = __cpu_to_le32(0);\n\tcfg->mac_aggr_delim = __cpu_to_le32(0);\n\tcfg->rx_skip_defrag_timeout_dup_detection_check = __cpu_to_le32(0);\n\tcfg->vow_config = __cpu_to_le32(0);\n\tcfg->gtk_offload_max_vdev = __cpu_to_le32(2);\n\tcfg->num_msdu_desc = __cpu_to_le32(ar->htt.max_num_pending_tx);\n\tcfg->max_frag_entries = __cpu_to_le32(2);\n\tcfg->num_tdls_vdevs = __cpu_to_le32(TARGET_TLV_NUM_TDLS_VDEVS);\n\tcfg->num_tdls_conn_table_entries = __cpu_to_le32(0x20);\n\tcfg->beacon_tx_offload_max_vdev = __cpu_to_le32(2);\n\tcfg->num_multicast_filter_entries = __cpu_to_le32(5);\n\tcfg->num_wow_filters = __cpu_to_le32(ar->wow.max_num_patterns);\n\tcfg->num_keep_alive_pattern = __cpu_to_le32(6);\n\tcfg->keep_alive_pattern_size = __cpu_to_le32(0);\n\tcfg->max_tdls_concurrent_sleep_sta = __cpu_to_le32(1);\n\tcfg->max_tdls_concurrent_buffer_sta = __cpu_to_le32(1);\n\tcfg->wmi_send_separate = __cpu_to_le32(0);\n\tcfg->num_ocb_vdevs = __cpu_to_le32(0);\n\tcfg->num_ocb_channels = __cpu_to_le32(0);\n\tcfg->num_ocb_schedules = __cpu_to_le32(0);\n\tcfg->host_capab = __cpu_to_le32(WMI_TLV_FLAG_MGMT_BUNDLE_TX_COMPL);\n\n\tif (test_bit(WMI_SERVICE_TX_DATA_ACK_RSSI, ar->wmi.svc_map))\n\t\tcfg->host_capab |= __cpu_to_le32(WMI_RSRC_CFG_FLAG_TX_ACK_RSSI);\n\n\tath10k_wmi_tlv_put_host_mem_chunks(ar, chunks);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv init\\n\");\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_start_scan(struct ath10k *ar,\n\t\t\t\t const struct wmi_start_scan_arg *arg)\n{\n\tstruct wmi_tlv_start_scan_cmd *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tsize_t len, chan_len, ssid_len, bssid_len, ie_len;\n\t__le32 *chans;\n\tstruct wmi_ssid *ssids;\n\tstruct wmi_mac_addr *addrs;\n\tvoid *ptr;\n\tint i, ret;\n\n\tret = ath10k_wmi_start_scan_verify(arg);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tchan_len = arg->n_channels * sizeof(__le32);\n\tssid_len = arg->n_ssids * sizeof(struct wmi_ssid);\n\tbssid_len = arg->n_bssids * sizeof(struct wmi_mac_addr);\n\tie_len = roundup(arg->ie_len, 4);\n\tlen = (sizeof(*tlv) + sizeof(*cmd)) +\n\t      sizeof(*tlv) + chan_len +\n\t      sizeof(*tlv) + ssid_len +\n\t      sizeof(*tlv) + bssid_len +\n\t      sizeof(*tlv) + ie_len;\n\n\tskb = ath10k_wmi_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tptr = (void *)skb->data;\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_START_SCAN_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\n\tath10k_wmi_put_start_scan_common(&cmd->common, arg);\n\tcmd->burst_duration_ms = __cpu_to_le32(arg->burst_duration_ms);\n\tcmd->num_channels = __cpu_to_le32(arg->n_channels);\n\tcmd->num_ssids = __cpu_to_le32(arg->n_ssids);\n\tcmd->num_bssids = __cpu_to_le32(arg->n_bssids);\n\tcmd->ie_len = __cpu_to_le32(arg->ie_len);\n\tcmd->num_probes = __cpu_to_le32(3);\n\tether_addr_copy(cmd->mac_addr.addr, arg->mac_addr.addr);\n\tether_addr_copy(cmd->mac_mask.addr, arg->mac_mask.addr);\n\n\t \n\tcmd->common.scan_ctrl_flags ^= __cpu_to_le32(WMI_SCAN_FILTER_PROBE_REQ);\n\n\tptr += sizeof(*tlv);\n\tptr += sizeof(*cmd);\n\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_UINT32);\n\ttlv->len = __cpu_to_le16(chan_len);\n\tchans = (void *)tlv->value;\n\tfor (i = 0; i < arg->n_channels; i++)\n\t\tchans[i] = __cpu_to_le32(arg->channels[i]);\n\n\tptr += sizeof(*tlv);\n\tptr += chan_len;\n\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_FIXED_STRUCT);\n\ttlv->len = __cpu_to_le16(ssid_len);\n\tssids = (void *)tlv->value;\n\tfor (i = 0; i < arg->n_ssids; i++) {\n\t\tssids[i].ssid_len = __cpu_to_le32(arg->ssids[i].len);\n\t\tmemcpy(ssids[i].ssid, arg->ssids[i].ssid, arg->ssids[i].len);\n\t}\n\n\tptr += sizeof(*tlv);\n\tptr += ssid_len;\n\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_FIXED_STRUCT);\n\ttlv->len = __cpu_to_le16(bssid_len);\n\taddrs = (void *)tlv->value;\n\tfor (i = 0; i < arg->n_bssids; i++)\n\t\tether_addr_copy(addrs[i].addr, arg->bssids[i].bssid);\n\n\tptr += sizeof(*tlv);\n\tptr += bssid_len;\n\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_BYTE);\n\ttlv->len = __cpu_to_le16(ie_len);\n\tmemcpy(tlv->value, arg->ie, arg->ie_len);\n\n\tptr += sizeof(*tlv);\n\tptr += ie_len;\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv start scan\\n\");\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_stop_scan(struct ath10k *ar,\n\t\t\t\tconst struct wmi_stop_scan_arg *arg)\n{\n\tstruct wmi_stop_scan_cmd *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tu32 scan_id;\n\tu32 req_id;\n\n\tif (arg->req_id > 0xFFF)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (arg->req_type == WMI_SCAN_STOP_ONE && arg->u.scan_id > 0xFFF)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tscan_id = arg->u.scan_id;\n\tscan_id |= WMI_HOST_SCAN_REQ_ID_PREFIX;\n\n\treq_id = arg->req_id;\n\treq_id |= WMI_HOST_SCAN_REQUESTOR_ID_PREFIX;\n\n\ttlv = (void *)skb->data;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_STOP_SCAN_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\tcmd->req_type = __cpu_to_le32(arg->req_type);\n\tcmd->vdev_id = __cpu_to_le32(arg->u.vdev_id);\n\tcmd->scan_id = __cpu_to_le32(scan_id);\n\tcmd->scan_req_id = __cpu_to_le32(req_id);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv stop scan\\n\");\n\treturn skb;\n}\n\nstatic int ath10k_wmi_tlv_op_get_vdev_subtype(struct ath10k *ar,\n\t\t\t\t\t      enum wmi_vdev_subtype subtype)\n{\n\tswitch (subtype) {\n\tcase WMI_VDEV_SUBTYPE_NONE:\n\t\treturn WMI_TLV_VDEV_SUBTYPE_NONE;\n\tcase WMI_VDEV_SUBTYPE_P2P_DEVICE:\n\t\treturn WMI_TLV_VDEV_SUBTYPE_P2P_DEV;\n\tcase WMI_VDEV_SUBTYPE_P2P_CLIENT:\n\t\treturn WMI_TLV_VDEV_SUBTYPE_P2P_CLI;\n\tcase WMI_VDEV_SUBTYPE_P2P_GO:\n\t\treturn WMI_TLV_VDEV_SUBTYPE_P2P_GO;\n\tcase WMI_VDEV_SUBTYPE_PROXY_STA:\n\t\treturn WMI_TLV_VDEV_SUBTYPE_PROXY_STA;\n\tcase WMI_VDEV_SUBTYPE_MESH_11S:\n\t\treturn WMI_TLV_VDEV_SUBTYPE_MESH_11S;\n\tcase WMI_VDEV_SUBTYPE_MESH_NON_11S:\n\t\treturn -ENOTSUPP;\n\t}\n\treturn -ENOTSUPP;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_vdev_create(struct ath10k *ar,\n\t\t\t\t  u32 vdev_id,\n\t\t\t\t  enum wmi_vdev_type vdev_type,\n\t\t\t\t  enum wmi_vdev_subtype vdev_subtype,\n\t\t\t\t  const u8 mac_addr[ETH_ALEN])\n{\n\tstruct wmi_vdev_create_cmd *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttlv = (void *)skb->data;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_VDEV_CREATE_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n\tcmd->vdev_type = __cpu_to_le32(vdev_type);\n\tcmd->vdev_subtype = __cpu_to_le32(vdev_subtype);\n\tether_addr_copy(cmd->vdev_macaddr.addr, mac_addr);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv vdev create\\n\");\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_vdev_delete(struct ath10k *ar, u32 vdev_id)\n{\n\tstruct wmi_vdev_delete_cmd *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttlv = (void *)skb->data;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_VDEV_DELETE_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv vdev delete\\n\");\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_vdev_start(struct ath10k *ar,\n\t\t\t\t const struct wmi_vdev_start_request_arg *arg,\n\t\t\t\t bool restart)\n{\n\tstruct wmi_tlv_vdev_start_cmd *cmd;\n\tstruct wmi_channel *ch;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tsize_t len;\n\tvoid *ptr;\n\tu32 flags = 0;\n\n\tif (WARN_ON(arg->hidden_ssid && !arg->ssid))\n\t\treturn ERR_PTR(-EINVAL);\n\tif (WARN_ON(arg->ssid_len > sizeof(cmd->ssid.ssid)))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tlen = (sizeof(*tlv) + sizeof(*cmd)) +\n\t      (sizeof(*tlv) + sizeof(*ch)) +\n\t      (sizeof(*tlv) + 0);\n\tskb = ath10k_wmi_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (arg->hidden_ssid)\n\t\tflags |= WMI_VDEV_START_HIDDEN_SSID;\n\tif (arg->pmf_enabled)\n\t\tflags |= WMI_VDEV_START_PMF_ENABLED;\n\n\tptr = (void *)skb->data;\n\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_VDEV_START_REQUEST_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\tcmd->vdev_id = __cpu_to_le32(arg->vdev_id);\n\tcmd->bcn_intval = __cpu_to_le32(arg->bcn_intval);\n\tcmd->dtim_period = __cpu_to_le32(arg->dtim_period);\n\tcmd->flags = __cpu_to_le32(flags);\n\tcmd->bcn_tx_rate = __cpu_to_le32(arg->bcn_tx_rate);\n\tcmd->bcn_tx_power = __cpu_to_le32(arg->bcn_tx_power);\n\tcmd->disable_hw_ack = __cpu_to_le32(arg->disable_hw_ack);\n\n\tif (arg->ssid) {\n\t\tcmd->ssid.ssid_len = __cpu_to_le32(arg->ssid_len);\n\t\tmemcpy(cmd->ssid.ssid, arg->ssid, arg->ssid_len);\n\t}\n\n\tptr += sizeof(*tlv);\n\tptr += sizeof(*cmd);\n\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_CHANNEL);\n\ttlv->len = __cpu_to_le16(sizeof(*ch));\n\tch = (void *)tlv->value;\n\tath10k_wmi_put_wmi_channel(ar, ch, &arg->channel);\n\n\tptr += sizeof(*tlv);\n\tptr += sizeof(*ch);\n\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_STRUCT);\n\ttlv->len = 0;\n\n\t \n\n\tptr += sizeof(*tlv);\n\tptr += 0;\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv vdev start\\n\");\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_vdev_stop(struct ath10k *ar, u32 vdev_id)\n{\n\tstruct wmi_vdev_stop_cmd *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttlv = (void *)skb->data;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_VDEV_STOP_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv vdev stop\\n\");\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_vdev_up(struct ath10k *ar, u32 vdev_id, u32 aid,\n\t\t\t      const u8 *bssid)\n\n{\n\tstruct wmi_vdev_up_cmd *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttlv = (void *)skb->data;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_VDEV_UP_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n\tcmd->vdev_assoc_id = __cpu_to_le32(aid);\n\tether_addr_copy(cmd->vdev_bssid.addr, bssid);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv vdev up\\n\");\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_vdev_down(struct ath10k *ar, u32 vdev_id)\n{\n\tstruct wmi_vdev_down_cmd *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttlv = (void *)skb->data;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_VDEV_DOWN_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv vdev down\\n\");\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_vdev_set_param(struct ath10k *ar, u32 vdev_id,\n\t\t\t\t     u32 param_id, u32 param_value)\n{\n\tstruct wmi_vdev_set_param_cmd *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttlv = (void *)skb->data;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_VDEV_SET_PARAM_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n\tcmd->param_id = __cpu_to_le32(param_id);\n\tcmd->param_value = __cpu_to_le32(param_value);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv vdev %d set param %d value 0x%x\\n\",\n\t\t   vdev_id, param_id, param_value);\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_vdev_install_key(struct ath10k *ar,\n\t\t\t\t       const struct wmi_vdev_install_key_arg *arg)\n{\n\tstruct wmi_vdev_install_key_cmd *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tsize_t len;\n\tvoid *ptr;\n\n\tif (arg->key_cipher == ar->wmi_key_cipher[WMI_CIPHER_NONE] &&\n\t    arg->key_data)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (arg->key_cipher != ar->wmi_key_cipher[WMI_CIPHER_NONE] &&\n\t    !arg->key_data)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tlen = sizeof(*tlv) + sizeof(*cmd) +\n\t      sizeof(*tlv) + roundup(arg->key_len, sizeof(__le32));\n\tskb = ath10k_wmi_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tptr = (void *)skb->data;\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_VDEV_INSTALL_KEY_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\tcmd->vdev_id = __cpu_to_le32(arg->vdev_id);\n\tcmd->key_idx = __cpu_to_le32(arg->key_idx);\n\tcmd->key_flags = __cpu_to_le32(arg->key_flags);\n\tcmd->key_cipher = __cpu_to_le32(arg->key_cipher);\n\tcmd->key_len = __cpu_to_le32(arg->key_len);\n\tcmd->key_txmic_len = __cpu_to_le32(arg->key_txmic_len);\n\tcmd->key_rxmic_len = __cpu_to_le32(arg->key_rxmic_len);\n\n\tif (arg->macaddr)\n\t\tether_addr_copy(cmd->peer_macaddr.addr, arg->macaddr);\n\n\tptr += sizeof(*tlv);\n\tptr += sizeof(*cmd);\n\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_BYTE);\n\ttlv->len = __cpu_to_le16(roundup(arg->key_len, sizeof(__le32)));\n\tif (arg->key_data)\n\t\tmemcpy(tlv->value, arg->key_data, arg->key_len);\n\n\tptr += sizeof(*tlv);\n\tptr += roundup(arg->key_len, sizeof(__le32));\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv vdev install key\\n\");\n\treturn skb;\n}\n\nstatic void *ath10k_wmi_tlv_put_uapsd_ac(struct ath10k *ar, void *ptr,\n\t\t\t\t\t const struct wmi_sta_uapsd_auto_trig_arg *arg)\n{\n\tstruct wmi_sta_uapsd_auto_trig_param *ac;\n\tstruct wmi_tlv *tlv;\n\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_STA_UAPSD_AUTO_TRIG_PARAM);\n\ttlv->len = __cpu_to_le16(sizeof(*ac));\n\tac = (void *)tlv->value;\n\n\tac->wmm_ac = __cpu_to_le32(arg->wmm_ac);\n\tac->user_priority = __cpu_to_le32(arg->user_priority);\n\tac->service_interval = __cpu_to_le32(arg->service_interval);\n\tac->suspend_interval = __cpu_to_le32(arg->suspend_interval);\n\tac->delay_interval = __cpu_to_le32(arg->delay_interval);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi tlv vdev sta uapsd auto trigger ac %d prio %d svc int %d susp int %d delay int %d\\n\",\n\t\t   ac->wmm_ac, ac->user_priority, ac->service_interval,\n\t\t   ac->suspend_interval, ac->delay_interval);\n\n\treturn ptr + sizeof(*tlv) + sizeof(*ac);\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_vdev_sta_uapsd(struct ath10k *ar, u32 vdev_id,\n\t\t\t\t     const u8 peer_addr[ETH_ALEN],\n\t\t\t\t     const struct wmi_sta_uapsd_auto_trig_arg *args,\n\t\t\t\t     u32 num_ac)\n{\n\tstruct wmi_sta_uapsd_auto_trig_cmd_fixed_param *cmd;\n\tstruct wmi_sta_uapsd_auto_trig_param *ac;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tsize_t len;\n\tsize_t ac_tlv_len;\n\tvoid *ptr;\n\tint i;\n\n\tac_tlv_len = num_ac * (sizeof(*tlv) + sizeof(*ac));\n\tlen = sizeof(*tlv) + sizeof(*cmd) +\n\t      sizeof(*tlv) + ac_tlv_len;\n\tskb = ath10k_wmi_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tptr = (void *)skb->data;\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_STA_UAPSD_AUTO_TRIG_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n\tcmd->num_ac = __cpu_to_le32(num_ac);\n\tether_addr_copy(cmd->peer_macaddr.addr, peer_addr);\n\n\tptr += sizeof(*tlv);\n\tptr += sizeof(*cmd);\n\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_STRUCT);\n\ttlv->len = __cpu_to_le16(ac_tlv_len);\n\tac = (void *)tlv->value;\n\n\tptr += sizeof(*tlv);\n\tfor (i = 0; i < num_ac; i++)\n\t\tptr = ath10k_wmi_tlv_put_uapsd_ac(ar, ptr, &args[i]);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv vdev sta uapsd auto trigger\\n\");\n\treturn skb;\n}\n\nstatic void *ath10k_wmi_tlv_put_wmm(void *ptr,\n\t\t\t\t    const struct wmi_wmm_params_arg *arg)\n{\n\tstruct wmi_wmm_params *wmm;\n\tstruct wmi_tlv *tlv;\n\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_WMM_PARAMS);\n\ttlv->len = __cpu_to_le16(sizeof(*wmm));\n\twmm = (void *)tlv->value;\n\tath10k_wmi_set_wmm_param(wmm, arg);\n\n\treturn ptr + sizeof(*tlv) + sizeof(*wmm);\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_vdev_wmm_conf(struct ath10k *ar, u32 vdev_id,\n\t\t\t\t    const struct wmi_wmm_params_all_arg *arg)\n{\n\tstruct wmi_tlv_vdev_set_wmm_cmd *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tsize_t len;\n\tvoid *ptr;\n\n\tlen = sizeof(*tlv) + sizeof(*cmd);\n\tskb = ath10k_wmi_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tptr = (void *)skb->data;\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_VDEV_SET_WMM_PARAMS_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n\n\tath10k_wmi_set_wmm_param(&cmd->vdev_wmm_params[0].params, &arg->ac_be);\n\tath10k_wmi_set_wmm_param(&cmd->vdev_wmm_params[1].params, &arg->ac_bk);\n\tath10k_wmi_set_wmm_param(&cmd->vdev_wmm_params[2].params, &arg->ac_vi);\n\tath10k_wmi_set_wmm_param(&cmd->vdev_wmm_params[3].params, &arg->ac_vo);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv vdev wmm conf\\n\");\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_sta_keepalive(struct ath10k *ar,\n\t\t\t\t    const struct wmi_sta_keepalive_arg *arg)\n{\n\tstruct wmi_tlv_sta_keepalive_cmd *cmd;\n\tstruct wmi_sta_keepalive_arp_resp *arp;\n\tstruct sk_buff *skb;\n\tstruct wmi_tlv *tlv;\n\tvoid *ptr;\n\tsize_t len;\n\n\tlen = sizeof(*tlv) + sizeof(*cmd) +\n\t      sizeof(*tlv) + sizeof(*arp);\n\tskb = ath10k_wmi_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tptr = (void *)skb->data;\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_STA_KEEPALIVE_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\tcmd->vdev_id = __cpu_to_le32(arg->vdev_id);\n\tcmd->enabled = __cpu_to_le32(arg->enabled);\n\tcmd->method = __cpu_to_le32(arg->method);\n\tcmd->interval = __cpu_to_le32(arg->interval);\n\n\tptr += sizeof(*tlv);\n\tptr += sizeof(*cmd);\n\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_STA_KEEPALVE_ARP_RESPONSE);\n\ttlv->len = __cpu_to_le16(sizeof(*arp));\n\tarp = (void *)tlv->value;\n\n\tarp->src_ip4_addr = arg->src_ip4_addr;\n\tarp->dest_ip4_addr = arg->dest_ip4_addr;\n\tether_addr_copy(arp->dest_mac_addr.addr, arg->dest_mac_addr);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv sta keepalive vdev %d enabled %d method %d interval %d\\n\",\n\t\t   arg->vdev_id, arg->enabled, arg->method, arg->interval);\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_peer_create(struct ath10k *ar, u32 vdev_id,\n\t\t\t\t  const u8 peer_addr[ETH_ALEN],\n\t\t\t\t  enum wmi_peer_type peer_type)\n{\n\tstruct wmi_tlv_peer_create_cmd *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttlv = (void *)skb->data;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_PEER_CREATE_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n\tcmd->peer_type = __cpu_to_le32(peer_type);\n\tether_addr_copy(cmd->peer_addr.addr, peer_addr);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv peer create\\n\");\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_peer_delete(struct ath10k *ar, u32 vdev_id,\n\t\t\t\t  const u8 peer_addr[ETH_ALEN])\n{\n\tstruct wmi_peer_delete_cmd *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttlv = (void *)skb->data;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_PEER_DELETE_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n\tether_addr_copy(cmd->peer_macaddr.addr, peer_addr);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv peer delete\\n\");\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_peer_flush(struct ath10k *ar, u32 vdev_id,\n\t\t\t\t const u8 peer_addr[ETH_ALEN], u32 tid_bitmap)\n{\n\tstruct wmi_peer_flush_tids_cmd *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttlv = (void *)skb->data;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_PEER_FLUSH_TIDS_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n\tcmd->peer_tid_bitmap = __cpu_to_le32(tid_bitmap);\n\tether_addr_copy(cmd->peer_macaddr.addr, peer_addr);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv peer flush\\n\");\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_peer_set_param(struct ath10k *ar, u32 vdev_id,\n\t\t\t\t     const u8 *peer_addr,\n\t\t\t\t     enum wmi_peer_param param_id,\n\t\t\t\t     u32 param_value)\n{\n\tstruct wmi_peer_set_param_cmd *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttlv = (void *)skb->data;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_PEER_SET_PARAM_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n\tcmd->param_id = __cpu_to_le32(param_id);\n\tcmd->param_value = __cpu_to_le32(param_value);\n\tether_addr_copy(cmd->peer_macaddr.addr, peer_addr);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi tlv vdev %d peer %pM set param %d value 0x%x\\n\",\n\t\t   vdev_id, peer_addr, param_id, param_value);\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_peer_assoc(struct ath10k *ar,\n\t\t\t\t const struct wmi_peer_assoc_complete_arg *arg)\n{\n\tstruct wmi_tlv_peer_assoc_cmd *cmd;\n\tstruct wmi_vht_rate_set *vht_rate;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tsize_t len, legacy_rate_len, ht_rate_len;\n\tvoid *ptr;\n\n\tif (arg->peer_mpdu_density > 16)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (arg->peer_legacy_rates.num_rates > MAX_SUPPORTED_RATES)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (arg->peer_ht_rates.num_rates > MAX_SUPPORTED_RATES)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tlegacy_rate_len = roundup(arg->peer_legacy_rates.num_rates,\n\t\t\t\t  sizeof(__le32));\n\tht_rate_len = roundup(arg->peer_ht_rates.num_rates, sizeof(__le32));\n\tlen = (sizeof(*tlv) + sizeof(*cmd)) +\n\t      (sizeof(*tlv) + legacy_rate_len) +\n\t      (sizeof(*tlv) + ht_rate_len) +\n\t      (sizeof(*tlv) + sizeof(*vht_rate));\n\tskb = ath10k_wmi_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tptr = (void *)skb->data;\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_PEER_ASSOC_COMPLETE_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\n\tcmd->vdev_id = __cpu_to_le32(arg->vdev_id);\n\tcmd->new_assoc = __cpu_to_le32(arg->peer_reassoc ? 0 : 1);\n\tcmd->assoc_id = __cpu_to_le32(arg->peer_aid);\n\tcmd->flags = __cpu_to_le32(arg->peer_flags);\n\tcmd->caps = __cpu_to_le32(arg->peer_caps);\n\tcmd->listen_intval = __cpu_to_le32(arg->peer_listen_intval);\n\tcmd->ht_caps = __cpu_to_le32(arg->peer_ht_caps);\n\tcmd->max_mpdu = __cpu_to_le32(arg->peer_max_mpdu);\n\tcmd->mpdu_density = __cpu_to_le32(arg->peer_mpdu_density);\n\tcmd->rate_caps = __cpu_to_le32(arg->peer_rate_caps);\n\tcmd->nss = __cpu_to_le32(arg->peer_num_spatial_streams);\n\tcmd->vht_caps = __cpu_to_le32(arg->peer_vht_caps);\n\tcmd->phy_mode = __cpu_to_le32(arg->peer_phymode);\n\tcmd->num_legacy_rates = __cpu_to_le32(arg->peer_legacy_rates.num_rates);\n\tcmd->num_ht_rates = __cpu_to_le32(arg->peer_ht_rates.num_rates);\n\tether_addr_copy(cmd->mac_addr.addr, arg->addr);\n\n\tptr += sizeof(*tlv);\n\tptr += sizeof(*cmd);\n\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_BYTE);\n\ttlv->len = __cpu_to_le16(legacy_rate_len);\n\tmemcpy(tlv->value, arg->peer_legacy_rates.rates,\n\t       arg->peer_legacy_rates.num_rates);\n\n\tptr += sizeof(*tlv);\n\tptr += legacy_rate_len;\n\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_BYTE);\n\ttlv->len = __cpu_to_le16(ht_rate_len);\n\tmemcpy(tlv->value, arg->peer_ht_rates.rates,\n\t       arg->peer_ht_rates.num_rates);\n\n\tptr += sizeof(*tlv);\n\tptr += ht_rate_len;\n\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_VHT_RATE_SET);\n\ttlv->len = __cpu_to_le16(sizeof(*vht_rate));\n\tvht_rate = (void *)tlv->value;\n\n\tvht_rate->rx_max_rate = __cpu_to_le32(arg->peer_vht_rates.rx_max_rate);\n\tvht_rate->rx_mcs_set = __cpu_to_le32(arg->peer_vht_rates.rx_mcs_set);\n\tvht_rate->tx_max_rate = __cpu_to_le32(arg->peer_vht_rates.tx_max_rate);\n\tvht_rate->tx_mcs_set = __cpu_to_le32(arg->peer_vht_rates.tx_mcs_set);\n\n\tptr += sizeof(*tlv);\n\tptr += sizeof(*vht_rate);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv peer assoc\\n\");\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_set_psmode(struct ath10k *ar, u32 vdev_id,\n\t\t\t\t enum wmi_sta_ps_mode psmode)\n{\n\tstruct wmi_sta_powersave_mode_cmd *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttlv = (void *)skb->data;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_STA_POWERSAVE_MODE_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n\tcmd->sta_ps_mode = __cpu_to_le32(psmode);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv set psmode\\n\");\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_set_sta_ps(struct ath10k *ar, u32 vdev_id,\n\t\t\t\t enum wmi_sta_powersave_param param_id,\n\t\t\t\t u32 param_value)\n{\n\tstruct wmi_sta_powersave_param_cmd *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttlv = (void *)skb->data;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_STA_POWERSAVE_PARAM_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n\tcmd->param_id = __cpu_to_le32(param_id);\n\tcmd->param_value = __cpu_to_le32(param_value);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv set sta ps\\n\");\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_set_ap_ps(struct ath10k *ar, u32 vdev_id, const u8 *mac,\n\t\t\t\tenum wmi_ap_ps_peer_param param_id, u32 value)\n{\n\tstruct wmi_ap_ps_peer_cmd *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\n\tif (!mac)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttlv = (void *)skb->data;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_AP_PS_PEER_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n\tcmd->param_id = __cpu_to_le32(param_id);\n\tcmd->param_value = __cpu_to_le32(value);\n\tether_addr_copy(cmd->peer_macaddr.addr, mac);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv ap ps param\\n\");\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_scan_chan_list(struct ath10k *ar,\n\t\t\t\t     const struct wmi_scan_chan_list_arg *arg)\n{\n\tstruct wmi_tlv_scan_chan_list_cmd *cmd;\n\tstruct wmi_channel *ci;\n\tstruct wmi_channel_arg *ch;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tsize_t chans_len, len;\n\tint i;\n\tvoid *ptr, *chans;\n\n\tchans_len = arg->n_channels * (sizeof(*tlv) + sizeof(*ci));\n\tlen = (sizeof(*tlv) + sizeof(*cmd)) +\n\t      (sizeof(*tlv) + chans_len);\n\n\tskb = ath10k_wmi_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tptr = (void *)skb->data;\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_SCAN_CHAN_LIST_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\tcmd->num_scan_chans = __cpu_to_le32(arg->n_channels);\n\n\tptr += sizeof(*tlv);\n\tptr += sizeof(*cmd);\n\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_STRUCT);\n\ttlv->len = __cpu_to_le16(chans_len);\n\tchans = (void *)tlv->value;\n\n\tfor (i = 0; i < arg->n_channels; i++) {\n\t\tch = &arg->channels[i];\n\n\t\ttlv = chans;\n\t\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_CHANNEL);\n\t\ttlv->len = __cpu_to_le16(sizeof(*ci));\n\t\tci = (void *)tlv->value;\n\n\t\tath10k_wmi_put_wmi_channel(ar, ci, ch);\n\n\t\tchans += sizeof(*tlv);\n\t\tchans += sizeof(*ci);\n\t}\n\n\tptr += sizeof(*tlv);\n\tptr += chans_len;\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv scan chan list\\n\");\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_scan_prob_req_oui(struct ath10k *ar, u32 prob_req_oui)\n{\n\tstruct wmi_scan_prob_req_oui_cmd *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttlv = (void *)skb->data;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_SCAN_PROB_REQ_OUI_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\tcmd->prob_req_oui = __cpu_to_le32(prob_req_oui);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv scan prob req oui\\n\");\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_beacon_dma(struct ath10k *ar, u32 vdev_id,\n\t\t\t\t const void *bcn, size_t bcn_len,\n\t\t\t\t u32 bcn_paddr, bool dtim_zero,\n\t\t\t\t bool deliver_cab)\n\n{\n\tstruct wmi_bcn_tx_ref_cmd *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_hdr *hdr;\n\tu16 fc;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\thdr = (struct ieee80211_hdr *)bcn;\n\tfc = le16_to_cpu(hdr->frame_control);\n\n\ttlv = (void *)skb->data;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_BCN_SEND_FROM_HOST_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n\tcmd->data_len = __cpu_to_le32(bcn_len);\n\tcmd->data_ptr = __cpu_to_le32(bcn_paddr);\n\tcmd->msdu_id = 0;\n\tcmd->frame_control = __cpu_to_le32(fc);\n\tcmd->flags = 0;\n\n\tif (dtim_zero)\n\t\tcmd->flags |= __cpu_to_le32(WMI_BCN_TX_REF_FLAG_DTIM_ZERO);\n\n\tif (deliver_cab)\n\t\tcmd->flags |= __cpu_to_le32(WMI_BCN_TX_REF_FLAG_DELIVER_CAB);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv beacon dma\\n\");\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_pdev_set_wmm(struct ath10k *ar,\n\t\t\t\t   const struct wmi_wmm_params_all_arg *arg)\n{\n\tstruct wmi_tlv_pdev_set_wmm_cmd *cmd;\n\tstruct wmi_wmm_params *wmm;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tsize_t len;\n\tvoid *ptr;\n\n\tlen = (sizeof(*tlv) + sizeof(*cmd)) +\n\t      (4 * (sizeof(*tlv) + sizeof(*wmm)));\n\tskb = ath10k_wmi_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tptr = (void *)skb->data;\n\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_PDEV_SET_WMM_PARAMS_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\n\t \n\n\tptr += sizeof(*tlv);\n\tptr += sizeof(*cmd);\n\n\tptr = ath10k_wmi_tlv_put_wmm(ptr, &arg->ac_be);\n\tptr = ath10k_wmi_tlv_put_wmm(ptr, &arg->ac_bk);\n\tptr = ath10k_wmi_tlv_put_wmm(ptr, &arg->ac_vi);\n\tptr = ath10k_wmi_tlv_put_wmm(ptr, &arg->ac_vo);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv pdev set wmm\\n\");\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_request_stats(struct ath10k *ar, u32 stats_mask)\n{\n\tstruct wmi_request_stats_cmd *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttlv = (void *)skb->data;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_REQUEST_STATS_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\tcmd->stats_id = __cpu_to_le32(stats_mask);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv request stats\\n\");\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_request_peer_stats_info(struct ath10k *ar,\n\t\t\t\t\t      u32 vdev_id,\n\t\t\t\t\t      enum wmi_peer_stats_info_request_type type,\n\t\t\t\t\t      u8 *addr,\n\t\t\t\t\t      u32 reset)\n{\n\tstruct wmi_tlv_request_peer_stats_info *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttlv = (void *)skb->data;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_REQUEST_PEER_STATS_INFO_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n\tcmd->request_type = __cpu_to_le32(type);\n\n\tif (type == WMI_REQUEST_ONE_PEER_STATS_INFO)\n\t\tether_addr_copy(cmd->peer_macaddr.addr, addr);\n\n\tcmd->reset_after_request = __cpu_to_le32(reset);\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv request peer stats info\\n\");\n\treturn skb;\n}\n\nstatic int\nath10k_wmi_tlv_op_cleanup_mgmt_tx_send(struct ath10k *ar,\n\t\t\t\t       struct sk_buff *msdu)\n{\n\tstruct ath10k_skb_cb *cb = ATH10K_SKB_CB(msdu);\n\tstruct ath10k_wmi *wmi = &ar->wmi;\n\n\tidr_remove(&wmi->mgmt_pending_tx, cb->msdu_id);\n\n\treturn 0;\n}\n\nstatic int\nath10k_wmi_mgmt_tx_alloc_msdu_id(struct ath10k *ar, struct sk_buff *skb,\n\t\t\t\t dma_addr_t paddr)\n{\n\tstruct ath10k_wmi *wmi = &ar->wmi;\n\tstruct ath10k_mgmt_tx_pkt_addr *pkt_addr;\n\tint ret;\n\n\tpkt_addr = kmalloc(sizeof(*pkt_addr), GFP_ATOMIC);\n\tif (!pkt_addr)\n\t\treturn -ENOMEM;\n\n\tpkt_addr->vaddr = skb;\n\tpkt_addr->paddr = paddr;\n\n\tspin_lock_bh(&ar->data_lock);\n\tret = idr_alloc(&wmi->mgmt_pending_tx, pkt_addr, 0,\n\t\t\twmi->mgmt_max_num_pending_tx, GFP_ATOMIC);\n\tspin_unlock_bh(&ar->data_lock);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi mgmt tx alloc msdu_id ret %d\\n\", ret);\n\treturn ret;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_mgmt_tx_send(struct ath10k *ar, struct sk_buff *msdu,\n\t\t\t\t   dma_addr_t paddr)\n{\n\tstruct ath10k_skb_cb *cb = ATH10K_SKB_CB(msdu);\n\tstruct wmi_tlv_mgmt_tx_cmd *cmd;\n\tstruct ieee80211_hdr *hdr;\n\tstruct ath10k_vif *arvif;\n\tu32 buf_len = msdu->len;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tint len, desc_id;\n\tu32 vdev_id;\n\tvoid *ptr;\n\n\tif (!cb->vif)\n\t\treturn ERR_PTR(-EINVAL);\n\n\thdr = (struct ieee80211_hdr *)msdu->data;\n\tarvif = (void *)cb->vif->drv_priv;\n\tvdev_id = arvif->vdev_id;\n\n\tif (WARN_ON_ONCE(!ieee80211_is_mgmt(hdr->frame_control) &&\n\t\t\t (!(ieee80211_is_nullfunc(hdr->frame_control) ||\n\t\t\t ieee80211_is_qos_nullfunc(hdr->frame_control)))))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tlen = sizeof(*cmd) + 2 * sizeof(*tlv);\n\n\tif ((ieee80211_is_action(hdr->frame_control) ||\n\t     ieee80211_is_deauth(hdr->frame_control) ||\n\t     ieee80211_is_disassoc(hdr->frame_control)) &&\n\t     ieee80211_has_protected(hdr->frame_control)) {\n\t\tskb_put(msdu, IEEE80211_CCMP_MIC_LEN);\n\t\tbuf_len += IEEE80211_CCMP_MIC_LEN;\n\t}\n\n\tbuf_len = min_t(u32, buf_len, WMI_TLV_MGMT_TX_FRAME_MAX_LEN);\n\tbuf_len = round_up(buf_len, 4);\n\n\tlen += buf_len;\n\tlen = round_up(len, 4);\n\tskb = ath10k_wmi_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdesc_id = ath10k_wmi_mgmt_tx_alloc_msdu_id(ar, msdu, paddr);\n\tif (desc_id < 0)\n\t\tgoto err_free_skb;\n\n\tcb->msdu_id = desc_id;\n\n\tptr = (void *)skb->data;\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_MGMT_TX_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n\tcmd->desc_id = __cpu_to_le32(desc_id);\n\tcmd->chanfreq = 0;\n\tcmd->buf_len = __cpu_to_le32(buf_len);\n\tcmd->frame_len = __cpu_to_le32(msdu->len);\n\tcmd->paddr = __cpu_to_le64(paddr);\n\n\tptr += sizeof(*tlv);\n\tptr += sizeof(*cmd);\n\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_BYTE);\n\ttlv->len = __cpu_to_le16(buf_len);\n\n\tptr += sizeof(*tlv);\n\tmemcpy(ptr, msdu->data, buf_len);\n\n\treturn skb;\n\nerr_free_skb:\n\tdev_kfree_skb(skb);\n\treturn ERR_PTR(desc_id);\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_force_fw_hang(struct ath10k *ar,\n\t\t\t\t    enum wmi_force_fw_hang_type type,\n\t\t\t\t    u32 delay_ms)\n{\n\tstruct wmi_force_fw_hang_cmd *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttlv = (void *)skb->data;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_FORCE_FW_HANG_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\tcmd->type = __cpu_to_le32(type);\n\tcmd->delay_ms = __cpu_to_le32(delay_ms);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv force fw hang\\n\");\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_dbglog_cfg(struct ath10k *ar, u64 module_enable,\n\t\t\t\t u32 log_level)\n{\n\tstruct wmi_tlv_dbglog_cmd *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tsize_t len, bmap_len;\n\tu32 value;\n\tvoid *ptr;\n\n\tif (module_enable) {\n\t\tvalue = WMI_TLV_DBGLOG_LOG_LEVEL_VALUE(\n\t\t\t\tmodule_enable,\n\t\t\t\tWMI_TLV_DBGLOG_LOG_LEVEL_VERBOSE);\n\t} else {\n\t\tvalue = WMI_TLV_DBGLOG_LOG_LEVEL_VALUE(\n\t\t\t\tWMI_TLV_DBGLOG_ALL_MODULES,\n\t\t\t\tWMI_TLV_DBGLOG_LOG_LEVEL_WARN);\n\t}\n\n\tbmap_len = 0;\n\tlen = sizeof(*tlv) + sizeof(*cmd) + sizeof(*tlv) + bmap_len;\n\tskb = ath10k_wmi_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tptr = (void *)skb->data;\n\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_DEBUG_LOG_CONFIG_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\tcmd->param = __cpu_to_le32(WMI_TLV_DBGLOG_PARAM_LOG_LEVEL);\n\tcmd->value = __cpu_to_le32(value);\n\n\tptr += sizeof(*tlv);\n\tptr += sizeof(*cmd);\n\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_UINT32);\n\ttlv->len = __cpu_to_le16(bmap_len);\n\n\t \n\n\tptr += sizeof(*tlv);\n\tptr += sizeof(bmap_len);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv dbglog value 0x%08x\\n\", value);\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_pktlog_enable(struct ath10k *ar, u32 filter)\n{\n\tstruct wmi_tlv_pktlog_enable *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tvoid *ptr;\n\tsize_t len;\n\n\tlen = sizeof(*tlv) + sizeof(*cmd);\n\tskb = ath10k_wmi_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tptr = (void *)skb->data;\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_PDEV_PKTLOG_ENABLE_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\tcmd->filter = __cpu_to_le32(filter);\n\n\tptr += sizeof(*tlv);\n\tptr += sizeof(*cmd);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv pktlog enable filter 0x%08x\\n\",\n\t\t   filter);\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_pdev_get_temperature(struct ath10k *ar)\n{\n\tstruct wmi_tlv_pdev_get_temp_cmd *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttlv = (void *)skb->data;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_PDEV_GET_TEMPERATURE_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi pdev get temperature tlv\\n\");\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_pktlog_disable(struct ath10k *ar)\n{\n\tstruct wmi_tlv_pktlog_disable *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tvoid *ptr;\n\tsize_t len;\n\n\tlen = sizeof(*tlv) + sizeof(*cmd);\n\tskb = ath10k_wmi_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tptr = (void *)skb->data;\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_PDEV_PKTLOG_DISABLE_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\n\tptr += sizeof(*tlv);\n\tptr += sizeof(*cmd);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv pktlog disable\\n\");\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_bcn_tmpl(struct ath10k *ar, u32 vdev_id,\n\t\t\t       u32 tim_ie_offset, struct sk_buff *bcn,\n\t\t\t       u32 prb_caps, u32 prb_erp, void *prb_ies,\n\t\t\t       size_t prb_ies_len)\n{\n\tstruct wmi_tlv_bcn_tmpl_cmd *cmd;\n\tstruct wmi_tlv_bcn_prb_info *info;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tvoid *ptr;\n\tsize_t len;\n\n\tif (WARN_ON(prb_ies_len > 0 && !prb_ies))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tlen = sizeof(*tlv) + sizeof(*cmd) +\n\t      sizeof(*tlv) + sizeof(*info) + prb_ies_len +\n\t      sizeof(*tlv) + roundup(bcn->len, 4);\n\tskb = ath10k_wmi_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tptr = (void *)skb->data;\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_BCN_TMPL_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n\tcmd->tim_ie_offset = __cpu_to_le32(tim_ie_offset);\n\tcmd->buf_len = __cpu_to_le32(bcn->len);\n\n\tptr += sizeof(*tlv);\n\tptr += sizeof(*cmd);\n\n\t \n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_BCN_PRB_INFO);\n\ttlv->len = __cpu_to_le16(sizeof(*info) + prb_ies_len);\n\tinfo = (void *)tlv->value;\n\tinfo->caps = __cpu_to_le32(prb_caps);\n\tinfo->erp = __cpu_to_le32(prb_erp);\n\tmemcpy(info->ies, prb_ies, prb_ies_len);\n\n\tptr += sizeof(*tlv);\n\tptr += sizeof(*info);\n\tptr += prb_ies_len;\n\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_BYTE);\n\ttlv->len = __cpu_to_le16(roundup(bcn->len, 4));\n\tmemcpy(tlv->value, bcn->data, bcn->len);\n\n\t \n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv bcn tmpl vdev_id %i\\n\",\n\t\t   vdev_id);\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_prb_tmpl(struct ath10k *ar, u32 vdev_id,\n\t\t\t       struct sk_buff *prb)\n{\n\tstruct wmi_tlv_prb_tmpl_cmd *cmd;\n\tstruct wmi_tlv_bcn_prb_info *info;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tvoid *ptr;\n\tsize_t len;\n\n\tlen = sizeof(*tlv) + sizeof(*cmd) +\n\t      sizeof(*tlv) + sizeof(*info) +\n\t      sizeof(*tlv) + roundup(prb->len, 4);\n\tskb = ath10k_wmi_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tptr = (void *)skb->data;\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_PRB_TMPL_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n\tcmd->buf_len = __cpu_to_le32(prb->len);\n\n\tptr += sizeof(*tlv);\n\tptr += sizeof(*cmd);\n\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_BCN_PRB_INFO);\n\ttlv->len = __cpu_to_le16(sizeof(*info));\n\tinfo = (void *)tlv->value;\n\tinfo->caps = 0;\n\tinfo->erp = 0;\n\n\tptr += sizeof(*tlv);\n\tptr += sizeof(*info);\n\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_BYTE);\n\ttlv->len = __cpu_to_le16(roundup(prb->len, 4));\n\tmemcpy(tlv->value, prb->data, prb->len);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv prb tmpl vdev_id %i\\n\",\n\t\t   vdev_id);\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_p2p_go_bcn_ie(struct ath10k *ar, u32 vdev_id,\n\t\t\t\t    const u8 *p2p_ie)\n{\n\tstruct wmi_tlv_p2p_go_bcn_ie *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tvoid *ptr;\n\tsize_t len;\n\n\tlen = sizeof(*tlv) + sizeof(*cmd) +\n\t      sizeof(*tlv) + roundup(p2p_ie[1] + 2, 4);\n\tskb = ath10k_wmi_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tptr = (void *)skb->data;\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_P2P_GO_SET_BEACON_IE);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n\tcmd->ie_len = __cpu_to_le32(p2p_ie[1] + 2);\n\n\tptr += sizeof(*tlv);\n\tptr += sizeof(*cmd);\n\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_BYTE);\n\ttlv->len = __cpu_to_le16(roundup(p2p_ie[1] + 2, 4));\n\tmemcpy(tlv->value, p2p_ie, p2p_ie[1] + 2);\n\n\tptr += sizeof(*tlv);\n\tptr += roundup(p2p_ie[1] + 2, 4);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv p2p go bcn ie for vdev %i\\n\",\n\t\t   vdev_id);\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_update_fw_tdls_state(struct ath10k *ar, u32 vdev_id,\n\t\t\t\t\t   enum wmi_tdls_state state)\n{\n\tstruct wmi_tdls_set_state_cmd *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tvoid *ptr;\n\tsize_t len;\n\t \n\tu32 options = 0;\n\n\tif (test_bit(WMI_SERVICE_TDLS_UAPSD_BUFFER_STA, ar->wmi.svc_map))\n\t\toptions |=  WMI_TLV_TDLS_BUFFER_STA_EN;\n\n\t \n\tif (state == WMI_TDLS_ENABLE_ACTIVE)\n\t\tstate = WMI_TDLS_ENABLE_ACTIVE_EXTERNAL_CONTROL;\n\n\tlen = sizeof(*tlv) + sizeof(*cmd);\n\tskb = ath10k_wmi_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tptr = (void *)skb->data;\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_TDLS_SET_STATE_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\n\tcmd = (void *)tlv->value;\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n\tcmd->state = __cpu_to_le32(state);\n\tcmd->notification_interval_ms = __cpu_to_le32(5000);\n\tcmd->tx_discovery_threshold = __cpu_to_le32(100);\n\tcmd->tx_teardown_threshold = __cpu_to_le32(5);\n\tcmd->rssi_teardown_threshold = __cpu_to_le32(-75);\n\tcmd->rssi_delta = __cpu_to_le32(-20);\n\tcmd->tdls_options = __cpu_to_le32(options);\n\tcmd->tdls_peer_traffic_ind_window = __cpu_to_le32(2);\n\tcmd->tdls_peer_traffic_response_timeout_ms = __cpu_to_le32(5000);\n\tcmd->tdls_puapsd_mask = __cpu_to_le32(0xf);\n\tcmd->tdls_puapsd_inactivity_time_ms = __cpu_to_le32(0);\n\tcmd->tdls_puapsd_rx_frame_threshold = __cpu_to_le32(10);\n\n\tptr += sizeof(*tlv);\n\tptr += sizeof(*cmd);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv update fw tdls state %d for vdev %i\\n\",\n\t\t   state, vdev_id);\n\treturn skb;\n}\n\nstatic u32 ath10k_wmi_tlv_prepare_peer_qos(u8 uapsd_queues, u8 sp)\n{\n\tu32 peer_qos = 0;\n\n\tif (uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_VO)\n\t\tpeer_qos |= WMI_TLV_TDLS_PEER_QOS_AC_VO;\n\tif (uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_VI)\n\t\tpeer_qos |= WMI_TLV_TDLS_PEER_QOS_AC_VI;\n\tif (uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_BK)\n\t\tpeer_qos |= WMI_TLV_TDLS_PEER_QOS_AC_BK;\n\tif (uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_BE)\n\t\tpeer_qos |= WMI_TLV_TDLS_PEER_QOS_AC_BE;\n\n\tpeer_qos |= SM(sp, WMI_TLV_TDLS_PEER_SP);\n\n\treturn peer_qos;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_tdls_peer_update(struct ath10k *ar,\n\t\t\t\t       const struct wmi_tdls_peer_update_cmd_arg *arg,\n\t\t\t\t       const struct wmi_tdls_peer_capab_arg *cap,\n\t\t\t\t       const struct wmi_channel_arg *chan_arg)\n{\n\tstruct wmi_tdls_peer_update_cmd *cmd;\n\tstruct wmi_tdls_peer_capab *peer_cap;\n\tstruct wmi_channel *chan;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tu32 peer_qos;\n\tvoid *ptr;\n\tint len;\n\tint i;\n\n\tlen = sizeof(*tlv) + sizeof(*cmd) +\n\t      sizeof(*tlv) + sizeof(*peer_cap) +\n\t      sizeof(*tlv) + cap->peer_chan_len * sizeof(*chan);\n\n\tskb = ath10k_wmi_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tptr = (void *)skb->data;\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_TDLS_PEER_UPDATE_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\n\tcmd = (void *)tlv->value;\n\tcmd->vdev_id = __cpu_to_le32(arg->vdev_id);\n\tether_addr_copy(cmd->peer_macaddr.addr, arg->addr);\n\tcmd->peer_state = __cpu_to_le32(arg->peer_state);\n\n\tptr += sizeof(*tlv);\n\tptr += sizeof(*cmd);\n\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_TDLS_PEER_CAPABILITIES);\n\ttlv->len = __cpu_to_le16(sizeof(*peer_cap));\n\tpeer_cap = (void *)tlv->value;\n\tpeer_qos = ath10k_wmi_tlv_prepare_peer_qos(cap->peer_uapsd_queues,\n\t\t\t\t\t\t   cap->peer_max_sp);\n\tpeer_cap->peer_qos = __cpu_to_le32(peer_qos);\n\tpeer_cap->buff_sta_support = __cpu_to_le32(cap->buff_sta_support);\n\tpeer_cap->off_chan_support = __cpu_to_le32(cap->off_chan_support);\n\tpeer_cap->peer_curr_operclass = __cpu_to_le32(cap->peer_curr_operclass);\n\tpeer_cap->self_curr_operclass = __cpu_to_le32(cap->self_curr_operclass);\n\tpeer_cap->peer_chan_len = __cpu_to_le32(cap->peer_chan_len);\n\tpeer_cap->peer_operclass_len = __cpu_to_le32(cap->peer_operclass_len);\n\n\tfor (i = 0; i < WMI_TDLS_MAX_SUPP_OPER_CLASSES; i++)\n\t\tpeer_cap->peer_operclass[i] = cap->peer_operclass[i];\n\n\tpeer_cap->is_peer_responder = __cpu_to_le32(cap->is_peer_responder);\n\tpeer_cap->pref_offchan_num = __cpu_to_le32(cap->pref_offchan_num);\n\tpeer_cap->pref_offchan_bw = __cpu_to_le32(cap->pref_offchan_bw);\n\n\tptr += sizeof(*tlv);\n\tptr += sizeof(*peer_cap);\n\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_STRUCT);\n\ttlv->len = __cpu_to_le16(cap->peer_chan_len * sizeof(*chan));\n\n\tptr += sizeof(*tlv);\n\n\tfor (i = 0; i < cap->peer_chan_len; i++) {\n\t\ttlv = ptr;\n\t\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_CHANNEL);\n\t\ttlv->len = __cpu_to_le16(sizeof(*chan));\n\t\tchan = (void *)tlv->value;\n\t\tath10k_wmi_put_wmi_channel(ar, chan, &chan_arg[i]);\n\n\t\tptr += sizeof(*tlv);\n\t\tptr += sizeof(*chan);\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi tlv tdls peer update vdev %i state %d n_chans %u\\n\",\n\t\t   arg->vdev_id, arg->peer_state, cap->peer_chan_len);\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_pdev_set_quiet_mode(struct ath10k *ar, u32 period,\n\t\t\t\t\t  u32 duration, u32 next_offset,\n\t\t\t\t\t  u32 enabled)\n{\n\tstruct wmi_tlv_set_quiet_cmd *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\n\tskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttlv = (void *)skb->data;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_PDEV_SET_QUIET_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\n\t \n\tcmd->vdev_id = __cpu_to_le32(0);\n\tcmd->period = __cpu_to_le32(period);\n\tcmd->duration = __cpu_to_le32(duration);\n\tcmd->next_start = __cpu_to_le32(next_offset);\n\tcmd->enabled = __cpu_to_le32(enabled);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI,\n\t\t   \"wmi tlv quiet param: period %u duration %u enabled %d\\n\",\n\t\t   period, duration, enabled);\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_wow_enable(struct ath10k *ar)\n{\n\tstruct wmi_tlv_wow_enable_cmd *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tsize_t len;\n\n\tlen = sizeof(*tlv) + sizeof(*cmd);\n\tskb = ath10k_wmi_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttlv = (struct wmi_tlv *)skb->data;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_WOW_ENABLE_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\n\tcmd->enable = __cpu_to_le32(1);\n\tif (!ar->bus_param.link_can_suspend)\n\t\tcmd->pause_iface_config = __cpu_to_le32(WOW_IFACE_PAUSE_DISABLED);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv wow enable\\n\");\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_wow_add_wakeup_event(struct ath10k *ar,\n\t\t\t\t\t   u32 vdev_id,\n\t\t\t\t\t   enum wmi_wow_wakeup_event event,\n\t\t\t\t\t   u32 enable)\n{\n\tstruct wmi_tlv_wow_add_del_event_cmd *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tsize_t len;\n\n\tlen = sizeof(*tlv) + sizeof(*cmd);\n\tskb = ath10k_wmi_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttlv = (struct wmi_tlv *)skb->data;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_WOW_ADD_DEL_EVT_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n\tcmd->is_add = __cpu_to_le32(enable);\n\tcmd->event_bitmap = __cpu_to_le32(1 << event);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv wow add wakeup event %s enable %d vdev_id %d\\n\",\n\t\t   wow_wakeup_event(event), enable, vdev_id);\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_gen_wow_host_wakeup_ind(struct ath10k *ar)\n{\n\tstruct wmi_tlv_wow_host_wakeup_ind *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tsize_t len;\n\n\tlen = sizeof(*tlv) + sizeof(*cmd);\n\tskb = ath10k_wmi_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttlv = (struct wmi_tlv *)skb->data;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_WOW_HOSTWAKEUP_FROM_SLEEP_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv wow host wakeup ind\\n\");\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_wow_add_pattern(struct ath10k *ar, u32 vdev_id,\n\t\t\t\t      u32 pattern_id, const u8 *pattern,\n\t\t\t\t      const u8 *bitmask, int pattern_len,\n\t\t\t\t      int pattern_offset)\n{\n\tstruct wmi_tlv_wow_add_pattern_cmd *cmd;\n\tstruct wmi_tlv_wow_bitmap_pattern *bitmap;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tvoid *ptr;\n\tsize_t len;\n\n\tlen = sizeof(*tlv) + sizeof(*cmd) +\n\t      sizeof(*tlv) +\t\t\t \n\t      sizeof(*tlv) + sizeof(*bitmap) +   \n\t      sizeof(*tlv) +\t\t\t \n\t      sizeof(*tlv) +\t\t\t \n\t      sizeof(*tlv) +\t\t\t \n\t      sizeof(*tlv) +\t\t\t \n\t      sizeof(*tlv) + sizeof(u32);\t \n\n\tskb = ath10k_wmi_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tptr = (void *)skb->data;\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_WOW_ADD_PATTERN_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n\tcmd->pattern_id = __cpu_to_le32(pattern_id);\n\tcmd->pattern_type = __cpu_to_le32(WOW_BITMAP_PATTERN);\n\n\tptr += sizeof(*tlv);\n\tptr += sizeof(*cmd);\n\n\t \n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_STRUCT);\n\ttlv->len = __cpu_to_le16(sizeof(*tlv) + sizeof(*bitmap));\n\n\tptr += sizeof(*tlv);\n\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_WOW_BITMAP_PATTERN_T);\n\ttlv->len = __cpu_to_le16(sizeof(*bitmap));\n\tbitmap = (void *)tlv->value;\n\n\tmemcpy(bitmap->patternbuf, pattern, pattern_len);\n\tmemcpy(bitmap->bitmaskbuf, bitmask, pattern_len);\n\tbitmap->pattern_offset = __cpu_to_le32(pattern_offset);\n\tbitmap->pattern_len = __cpu_to_le32(pattern_len);\n\tbitmap->bitmask_len = __cpu_to_le32(pattern_len);\n\tbitmap->pattern_id = __cpu_to_le32(pattern_id);\n\n\tptr += sizeof(*tlv);\n\tptr += sizeof(*bitmap);\n\n\t \n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_STRUCT);\n\ttlv->len = __cpu_to_le16(0);\n\n\tptr += sizeof(*tlv);\n\n\t \n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_STRUCT);\n\ttlv->len = __cpu_to_le16(0);\n\n\tptr += sizeof(*tlv);\n\n\t \n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_STRUCT);\n\ttlv->len = __cpu_to_le16(0);\n\n\tptr += sizeof(*tlv);\n\n\t \n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_UINT32);\n\ttlv->len = __cpu_to_le16(0);\n\n\tptr += sizeof(*tlv);\n\n\t \n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_UINT32);\n\ttlv->len = __cpu_to_le16(sizeof(u32));\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv wow add pattern vdev_id %d pattern_id %d, pattern_offset %d\\n\",\n\t\t   vdev_id, pattern_id, pattern_offset);\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_wow_del_pattern(struct ath10k *ar, u32 vdev_id,\n\t\t\t\t      u32 pattern_id)\n{\n\tstruct wmi_tlv_wow_del_pattern_cmd *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tsize_t len;\n\n\tlen = sizeof(*tlv) + sizeof(*cmd);\n\tskb = ath10k_wmi_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttlv = (struct wmi_tlv *)skb->data;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_WOW_DEL_PATTERN_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n\tcmd->pattern_id = __cpu_to_le32(pattern_id);\n\tcmd->pattern_type = __cpu_to_le32(WOW_BITMAP_PATTERN);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv wow del pattern vdev_id %d pattern_id %d\\n\",\n\t\t   vdev_id, pattern_id);\n\treturn skb;\n}\n\n \nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_config_pno_start(struct ath10k *ar,\n\t\t\t\t       u32 vdev_id,\n\t\t\t\t       struct wmi_pno_scan_req *pno)\n{\n\tstruct nlo_configured_parameters *nlo_list;\n\tstruct wmi_tlv_wow_nlo_config_cmd *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\t__le32 *channel_list;\n\tu16 tlv_len;\n\tsize_t len;\n\tvoid *ptr;\n\tu32 i;\n\n\tlen = sizeof(*tlv) + sizeof(*cmd) +\n\t      sizeof(*tlv) +\n\t       \n\t      sizeof(*tlv);\n\t       \n\n\tlen += sizeof(u32) * min_t(u8, pno->a_networks[0].channel_count,\n\t\t\t\t   WMI_NLO_MAX_CHAN);\n\tlen += sizeof(struct nlo_configured_parameters) *\n\t\t\t\tmin_t(u8, pno->uc_networks_count, WMI_NLO_MAX_SSIDS);\n\n\tskb = ath10k_wmi_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tptr = (void *)skb->data;\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_NLO_CONFIG_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\n\t \n\tcmd->vdev_id = __cpu_to_le32(pno->vdev_id);\n\tcmd->flags = __cpu_to_le32(WMI_NLO_CONFIG_START | WMI_NLO_CONFIG_SSID_HIDE_EN);\n\n\t \n\tcmd->active_dwell_time = __cpu_to_le32(pno->active_max_time);\n\tcmd->passive_dwell_time = __cpu_to_le32(pno->passive_max_time);\n\n\tif (pno->do_passive_scan)\n\t\tcmd->flags |= __cpu_to_le32(WMI_NLO_CONFIG_SCAN_PASSIVE);\n\n\t \n\tcmd->fast_scan_period = __cpu_to_le32(pno->fast_scan_period);\n\tcmd->slow_scan_period = __cpu_to_le32(pno->slow_scan_period);\n\tcmd->fast_scan_max_cycles = __cpu_to_le32(pno->fast_scan_max_cycles);\n\tcmd->delay_start_time = __cpu_to_le32(pno->delay_start_time);\n\n\tif (pno->enable_pno_scan_randomization) {\n\t\tcmd->flags |= __cpu_to_le32(WMI_NLO_CONFIG_SPOOFED_MAC_IN_PROBE_REQ |\n\t\t\t\tWMI_NLO_CONFIG_RANDOM_SEQ_NO_IN_PROBE_REQ);\n\t\tether_addr_copy(cmd->mac_addr.addr, pno->mac_addr);\n\t\tether_addr_copy(cmd->mac_mask.addr, pno->mac_addr_mask);\n\t}\n\n\tptr += sizeof(*tlv);\n\tptr += sizeof(*cmd);\n\n\t \n\tcmd->no_of_ssids = __cpu_to_le32(min_t(u8, pno->uc_networks_count,\n\t\t\t\t\t       WMI_NLO_MAX_SSIDS));\n\ttlv_len = __le32_to_cpu(cmd->no_of_ssids) *\n\t\tsizeof(struct nlo_configured_parameters);\n\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_STRUCT);\n\ttlv->len = __cpu_to_le16(tlv_len);\n\n\tptr += sizeof(*tlv);\n\tnlo_list = ptr;\n\tfor (i = 0; i < __le32_to_cpu(cmd->no_of_ssids); i++) {\n\t\ttlv = (struct wmi_tlv *)(&nlo_list[i].tlv_header);\n\t\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_BYTE);\n\t\ttlv->len = __cpu_to_le16(sizeof(struct nlo_configured_parameters) -\n\t\t\t\t\t sizeof(*tlv));\n\n\t\t \n\t\tnlo_list[i].ssid.valid = __cpu_to_le32(true);\n\t\tnlo_list[i].ssid.ssid.ssid_len = pno->a_networks[i].ssid.ssid_len;\n\t\tmemcpy(nlo_list[i].ssid.ssid.ssid,\n\t\t       pno->a_networks[i].ssid.ssid,\n\t\t       __le32_to_cpu(nlo_list[i].ssid.ssid.ssid_len));\n\n\t\t \n\t\tif (pno->a_networks[i].rssi_threshold &&\n\t\t    pno->a_networks[i].rssi_threshold > -300) {\n\t\t\tnlo_list[i].rssi_cond.valid = __cpu_to_le32(true);\n\t\t\tnlo_list[i].rssi_cond.rssi =\n\t\t\t\t__cpu_to_le32(pno->a_networks[i].rssi_threshold);\n\t\t}\n\n\t\tnlo_list[i].bcast_nw_type.valid = __cpu_to_le32(true);\n\t\tnlo_list[i].bcast_nw_type.bcast_nw_type =\n\t\t\t__cpu_to_le32(pno->a_networks[i].bcast_nw_type);\n\t}\n\n\tptr += __le32_to_cpu(cmd->no_of_ssids) * sizeof(struct nlo_configured_parameters);\n\n\t \n\tcmd->num_of_channels = __cpu_to_le32(min_t(u8,\n\t\t\t\t\t\t   pno->a_networks[0].channel_count,\n\t\t\t\t\t\t   WMI_NLO_MAX_CHAN));\n\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_UINT32);\n\ttlv->len = __cpu_to_le16(__le32_to_cpu(cmd->num_of_channels) *\n\t\t\t\t sizeof(u_int32_t));\n\tptr += sizeof(*tlv);\n\n\tchannel_list = (__le32 *)ptr;\n\tfor (i = 0; i < __le32_to_cpu(cmd->num_of_channels); i++)\n\t\tchannel_list[i] = __cpu_to_le32(pno->a_networks[0].channels[i]);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv start pno config vdev_id %d\\n\",\n\t\t   vdev_id);\n\n\treturn skb;\n}\n\n \nstatic struct sk_buff *ath10k_wmi_tlv_op_gen_config_pno_stop(struct ath10k *ar,\n\t\t\t\t\t\t\t     u32 vdev_id)\n{\n\tstruct wmi_tlv_wow_nlo_config_cmd *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tvoid *ptr;\n\tsize_t len;\n\n\tlen = sizeof(*tlv) + sizeof(*cmd) +\n\t      sizeof(*tlv) +\n\t       \n\t      sizeof(*tlv);\n\t       \n\tskb = ath10k_wmi_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tptr = (void *)skb->data;\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_NLO_CONFIG_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n\tcmd->flags = __cpu_to_le32(WMI_NLO_CONFIG_STOP);\n\n\tptr += sizeof(*tlv);\n\tptr += sizeof(*cmd);\n\n\t \n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_STRUCT);\n\ttlv->len = __cpu_to_le16(0);\n\n\tptr += sizeof(*tlv);\n\n\t \n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_UINT32);\n\ttlv->len = __cpu_to_le16(0);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv stop pno config vdev_id %d\\n\", vdev_id);\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_config_pno(struct ath10k *ar, u32 vdev_id,\n\t\t\t\t struct wmi_pno_scan_req *pno_scan)\n{\n\tif (pno_scan->enable)\n\t\treturn ath10k_wmi_tlv_op_gen_config_pno_start(ar, vdev_id, pno_scan);\n\telse\n\t\treturn ath10k_wmi_tlv_op_gen_config_pno_stop(ar, vdev_id);\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_adaptive_qcs(struct ath10k *ar, bool enable)\n{\n\tstruct wmi_tlv_adaptive_qcs *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tvoid *ptr;\n\tsize_t len;\n\n\tlen = sizeof(*tlv) + sizeof(*cmd);\n\tskb = ath10k_wmi_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tptr = (void *)skb->data;\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_RESMGR_ADAPTIVE_OCS_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\tcmd->enable = __cpu_to_le32(enable ? 1 : 0);\n\n\tptr += sizeof(*tlv);\n\tptr += sizeof(*cmd);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv adaptive qcs %d\\n\", enable);\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_echo(struct ath10k *ar, u32 value)\n{\n\tstruct wmi_echo_cmd *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tvoid *ptr;\n\tsize_t len;\n\n\tlen = sizeof(*tlv) + sizeof(*cmd);\n\tskb = ath10k_wmi_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tptr = (void *)skb->data;\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_ECHO_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\tcmd->value = cpu_to_le32(value);\n\n\tptr += sizeof(*tlv);\n\tptr += sizeof(*cmd);\n\n\tath10k_dbg(ar, ATH10K_DBG_WMI, \"wmi tlv echo value 0x%08x\\n\", value);\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_vdev_spectral_conf(struct ath10k *ar,\n\t\t\t\t\t const struct wmi_vdev_spectral_conf_arg *arg)\n{\n\tstruct wmi_vdev_spectral_conf_cmd *cmd;\n\tstruct sk_buff *skb;\n\tstruct wmi_tlv *tlv;\n\tvoid *ptr;\n\tsize_t len;\n\n\tlen = sizeof(*tlv) + sizeof(*cmd);\n\tskb = ath10k_wmi_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tptr = (void *)skb->data;\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_VDEV_SPECTRAL_CONFIGURE_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\tcmd->vdev_id = __cpu_to_le32(arg->vdev_id);\n\tcmd->scan_count = __cpu_to_le32(arg->scan_count);\n\tcmd->scan_period = __cpu_to_le32(arg->scan_period);\n\tcmd->scan_priority = __cpu_to_le32(arg->scan_priority);\n\tcmd->scan_fft_size = __cpu_to_le32(arg->scan_fft_size);\n\tcmd->scan_gc_ena = __cpu_to_le32(arg->scan_gc_ena);\n\tcmd->scan_restart_ena = __cpu_to_le32(arg->scan_restart_ena);\n\tcmd->scan_noise_floor_ref = __cpu_to_le32(arg->scan_noise_floor_ref);\n\tcmd->scan_init_delay = __cpu_to_le32(arg->scan_init_delay);\n\tcmd->scan_nb_tone_thr = __cpu_to_le32(arg->scan_nb_tone_thr);\n\tcmd->scan_str_bin_thr = __cpu_to_le32(arg->scan_str_bin_thr);\n\tcmd->scan_wb_rpt_mode = __cpu_to_le32(arg->scan_wb_rpt_mode);\n\tcmd->scan_rssi_rpt_mode = __cpu_to_le32(arg->scan_rssi_rpt_mode);\n\tcmd->scan_rssi_thr = __cpu_to_le32(arg->scan_rssi_thr);\n\tcmd->scan_pwr_format = __cpu_to_le32(arg->scan_pwr_format);\n\tcmd->scan_rpt_mode = __cpu_to_le32(arg->scan_rpt_mode);\n\tcmd->scan_bin_scale = __cpu_to_le32(arg->scan_bin_scale);\n\tcmd->scan_dbm_adj = __cpu_to_le32(arg->scan_dbm_adj);\n\tcmd->scan_chn_mask = __cpu_to_le32(arg->scan_chn_mask);\n\n\treturn skb;\n}\n\nstatic struct sk_buff *\nath10k_wmi_tlv_op_gen_vdev_spectral_enable(struct ath10k *ar, u32 vdev_id,\n\t\t\t\t\t   u32 trigger, u32 enable)\n{\n\tstruct wmi_vdev_spectral_enable_cmd *cmd;\n\tstruct sk_buff *skb;\n\tstruct wmi_tlv *tlv;\n\tvoid *ptr;\n\tsize_t len;\n\n\tlen = sizeof(*tlv) + sizeof(*cmd);\n\tskb = ath10k_wmi_alloc_skb(ar, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tptr = (void *)skb->data;\n\ttlv = ptr;\n\ttlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_VDEV_SPECTRAL_ENABLE_CMD);\n\ttlv->len = __cpu_to_le16(sizeof(*cmd));\n\tcmd = (void *)tlv->value;\n\tcmd->vdev_id = __cpu_to_le32(vdev_id);\n\tcmd->trigger_cmd = __cpu_to_le32(trigger);\n\tcmd->enable_cmd = __cpu_to_le32(enable);\n\n\treturn skb;\n}\n\n \n \n \n\nstatic struct wmi_cmd_map wmi_tlv_cmd_map = {\n\t.init_cmdid = WMI_TLV_INIT_CMDID,\n\t.start_scan_cmdid = WMI_TLV_START_SCAN_CMDID,\n\t.stop_scan_cmdid = WMI_TLV_STOP_SCAN_CMDID,\n\t.scan_chan_list_cmdid = WMI_TLV_SCAN_CHAN_LIST_CMDID,\n\t.scan_sch_prio_tbl_cmdid = WMI_TLV_SCAN_SCH_PRIO_TBL_CMDID,\n\t.scan_prob_req_oui_cmdid = WMI_TLV_SCAN_PROB_REQ_OUI_CMDID,\n\t.pdev_set_regdomain_cmdid = WMI_TLV_PDEV_SET_REGDOMAIN_CMDID,\n\t.pdev_set_channel_cmdid = WMI_TLV_PDEV_SET_CHANNEL_CMDID,\n\t.pdev_set_param_cmdid = WMI_TLV_PDEV_SET_PARAM_CMDID,\n\t.pdev_pktlog_enable_cmdid = WMI_TLV_PDEV_PKTLOG_ENABLE_CMDID,\n\t.pdev_pktlog_disable_cmdid = WMI_TLV_PDEV_PKTLOG_DISABLE_CMDID,\n\t.pdev_set_wmm_params_cmdid = WMI_TLV_PDEV_SET_WMM_PARAMS_CMDID,\n\t.pdev_set_ht_cap_ie_cmdid = WMI_TLV_PDEV_SET_HT_CAP_IE_CMDID,\n\t.pdev_set_vht_cap_ie_cmdid = WMI_TLV_PDEV_SET_VHT_CAP_IE_CMDID,\n\t.pdev_set_dscp_tid_map_cmdid = WMI_TLV_PDEV_SET_DSCP_TID_MAP_CMDID,\n\t.pdev_set_quiet_mode_cmdid = WMI_TLV_PDEV_SET_QUIET_MODE_CMDID,\n\t.pdev_green_ap_ps_enable_cmdid = WMI_TLV_PDEV_GREEN_AP_PS_ENABLE_CMDID,\n\t.pdev_get_tpc_config_cmdid = WMI_TLV_PDEV_GET_TPC_CONFIG_CMDID,\n\t.pdev_set_base_macaddr_cmdid = WMI_TLV_PDEV_SET_BASE_MACADDR_CMDID,\n\t.vdev_create_cmdid = WMI_TLV_VDEV_CREATE_CMDID,\n\t.vdev_delete_cmdid = WMI_TLV_VDEV_DELETE_CMDID,\n\t.vdev_start_request_cmdid = WMI_TLV_VDEV_START_REQUEST_CMDID,\n\t.vdev_restart_request_cmdid = WMI_TLV_VDEV_RESTART_REQUEST_CMDID,\n\t.vdev_up_cmdid = WMI_TLV_VDEV_UP_CMDID,\n\t.vdev_stop_cmdid = WMI_TLV_VDEV_STOP_CMDID,\n\t.vdev_down_cmdid = WMI_TLV_VDEV_DOWN_CMDID,\n\t.vdev_set_param_cmdid = WMI_TLV_VDEV_SET_PARAM_CMDID,\n\t.vdev_install_key_cmdid = WMI_TLV_VDEV_INSTALL_KEY_CMDID,\n\t.peer_create_cmdid = WMI_TLV_PEER_CREATE_CMDID,\n\t.peer_delete_cmdid = WMI_TLV_PEER_DELETE_CMDID,\n\t.peer_flush_tids_cmdid = WMI_TLV_PEER_FLUSH_TIDS_CMDID,\n\t.peer_set_param_cmdid = WMI_TLV_PEER_SET_PARAM_CMDID,\n\t.peer_assoc_cmdid = WMI_TLV_PEER_ASSOC_CMDID,\n\t.peer_add_wds_entry_cmdid = WMI_TLV_PEER_ADD_WDS_ENTRY_CMDID,\n\t.peer_remove_wds_entry_cmdid = WMI_TLV_PEER_REMOVE_WDS_ENTRY_CMDID,\n\t.peer_mcast_group_cmdid = WMI_TLV_PEER_MCAST_GROUP_CMDID,\n\t.bcn_tx_cmdid = WMI_TLV_BCN_TX_CMDID,\n\t.pdev_send_bcn_cmdid = WMI_TLV_PDEV_SEND_BCN_CMDID,\n\t.bcn_tmpl_cmdid = WMI_TLV_BCN_TMPL_CMDID,\n\t.bcn_filter_rx_cmdid = WMI_TLV_BCN_FILTER_RX_CMDID,\n\t.prb_req_filter_rx_cmdid = WMI_TLV_PRB_REQ_FILTER_RX_CMDID,\n\t.mgmt_tx_cmdid = WMI_TLV_MGMT_TX_CMDID,\n\t.mgmt_tx_send_cmdid = WMI_TLV_MGMT_TX_SEND_CMD,\n\t.prb_tmpl_cmdid = WMI_TLV_PRB_TMPL_CMDID,\n\t.addba_clear_resp_cmdid = WMI_TLV_ADDBA_CLEAR_RESP_CMDID,\n\t.addba_send_cmdid = WMI_TLV_ADDBA_SEND_CMDID,\n\t.addba_status_cmdid = WMI_TLV_ADDBA_STATUS_CMDID,\n\t.delba_send_cmdid = WMI_TLV_DELBA_SEND_CMDID,\n\t.addba_set_resp_cmdid = WMI_TLV_ADDBA_SET_RESP_CMDID,\n\t.send_singleamsdu_cmdid = WMI_TLV_SEND_SINGLEAMSDU_CMDID,\n\t.sta_powersave_mode_cmdid = WMI_TLV_STA_POWERSAVE_MODE_CMDID,\n\t.sta_powersave_param_cmdid = WMI_TLV_STA_POWERSAVE_PARAM_CMDID,\n\t.sta_mimo_ps_mode_cmdid = WMI_TLV_STA_MIMO_PS_MODE_CMDID,\n\t.pdev_dfs_enable_cmdid = WMI_TLV_PDEV_DFS_ENABLE_CMDID,\n\t.pdev_dfs_disable_cmdid = WMI_TLV_PDEV_DFS_DISABLE_CMDID,\n\t.roam_scan_mode = WMI_TLV_ROAM_SCAN_MODE,\n\t.roam_scan_rssi_threshold = WMI_TLV_ROAM_SCAN_RSSI_THRESHOLD,\n\t.roam_scan_period = WMI_TLV_ROAM_SCAN_PERIOD,\n\t.roam_scan_rssi_change_threshold =\n\t\t\t\tWMI_TLV_ROAM_SCAN_RSSI_CHANGE_THRESHOLD,\n\t.roam_ap_profile = WMI_TLV_ROAM_AP_PROFILE,\n\t.ofl_scan_add_ap_profile = WMI_TLV_ROAM_AP_PROFILE,\n\t.ofl_scan_remove_ap_profile = WMI_TLV_OFL_SCAN_REMOVE_AP_PROFILE,\n\t.ofl_scan_period = WMI_TLV_OFL_SCAN_PERIOD,\n\t.p2p_dev_set_device_info = WMI_TLV_P2P_DEV_SET_DEVICE_INFO,\n\t.p2p_dev_set_discoverability = WMI_TLV_P2P_DEV_SET_DISCOVERABILITY,\n\t.p2p_go_set_beacon_ie = WMI_TLV_P2P_GO_SET_BEACON_IE,\n\t.p2p_go_set_probe_resp_ie = WMI_TLV_P2P_GO_SET_PROBE_RESP_IE,\n\t.p2p_set_vendor_ie_data_cmdid = WMI_TLV_P2P_SET_VENDOR_IE_DATA_CMDID,\n\t.ap_ps_peer_param_cmdid = WMI_TLV_AP_PS_PEER_PARAM_CMDID,\n\t.ap_ps_peer_uapsd_coex_cmdid = WMI_TLV_AP_PS_PEER_UAPSD_COEX_CMDID,\n\t.peer_rate_retry_sched_cmdid = WMI_TLV_PEER_RATE_RETRY_SCHED_CMDID,\n\t.wlan_profile_trigger_cmdid = WMI_TLV_WLAN_PROFILE_TRIGGER_CMDID,\n\t.wlan_profile_set_hist_intvl_cmdid =\n\t\t\t\tWMI_TLV_WLAN_PROFILE_SET_HIST_INTVL_CMDID,\n\t.wlan_profile_get_profile_data_cmdid =\n\t\t\t\tWMI_TLV_WLAN_PROFILE_GET_PROFILE_DATA_CMDID,\n\t.wlan_profile_enable_profile_id_cmdid =\n\t\t\t\tWMI_TLV_WLAN_PROFILE_ENABLE_PROFILE_ID_CMDID,\n\t.wlan_profile_list_profile_id_cmdid =\n\t\t\t\tWMI_TLV_WLAN_PROFILE_LIST_PROFILE_ID_CMDID,\n\t.pdev_suspend_cmdid = WMI_TLV_PDEV_SUSPEND_CMDID,\n\t.pdev_resume_cmdid = WMI_TLV_PDEV_RESUME_CMDID,\n\t.add_bcn_filter_cmdid = WMI_TLV_ADD_BCN_FILTER_CMDID,\n\t.rmv_bcn_filter_cmdid = WMI_TLV_RMV_BCN_FILTER_CMDID,\n\t.wow_add_wake_pattern_cmdid = WMI_TLV_WOW_ADD_WAKE_PATTERN_CMDID,\n\t.wow_del_wake_pattern_cmdid = WMI_TLV_WOW_DEL_WAKE_PATTERN_CMDID,\n\t.wow_enable_disable_wake_event_cmdid =\n\t\t\t\tWMI_TLV_WOW_ENABLE_DISABLE_WAKE_EVENT_CMDID,\n\t.wow_enable_cmdid = WMI_TLV_WOW_ENABLE_CMDID,\n\t.wow_hostwakeup_from_sleep_cmdid =\n\t\t\t\tWMI_TLV_WOW_HOSTWAKEUP_FROM_SLEEP_CMDID,\n\t.rtt_measreq_cmdid = WMI_TLV_RTT_MEASREQ_CMDID,\n\t.rtt_tsf_cmdid = WMI_TLV_RTT_TSF_CMDID,\n\t.vdev_spectral_scan_configure_cmdid = WMI_TLV_SPECTRAL_SCAN_CONF_CMDID,\n\t.vdev_spectral_scan_enable_cmdid = WMI_TLV_SPECTRAL_SCAN_ENABLE_CMDID,\n\t.request_stats_cmdid = WMI_TLV_REQUEST_STATS_CMDID,\n\t.request_peer_stats_info_cmdid = WMI_TLV_REQUEST_PEER_STATS_INFO_CMDID,\n\t.set_arp_ns_offload_cmdid = WMI_TLV_SET_ARP_NS_OFFLOAD_CMDID,\n\t.network_list_offload_config_cmdid =\n\t\t\t\tWMI_TLV_NETWORK_LIST_OFFLOAD_CONFIG_CMDID,\n\t.gtk_offload_cmdid = WMI_TLV_GTK_OFFLOAD_CMDID,\n\t.csa_offload_enable_cmdid = WMI_TLV_CSA_OFFLOAD_ENABLE_CMDID,\n\t.csa_offload_chanswitch_cmdid = WMI_TLV_CSA_OFFLOAD_CHANSWITCH_CMDID,\n\t.chatter_set_mode_cmdid = WMI_TLV_CHATTER_SET_MODE_CMDID,\n\t.peer_tid_addba_cmdid = WMI_TLV_PEER_TID_ADDBA_CMDID,\n\t.peer_tid_delba_cmdid = WMI_TLV_PEER_TID_DELBA_CMDID,\n\t.sta_dtim_ps_method_cmdid = WMI_TLV_STA_DTIM_PS_METHOD_CMDID,\n\t.sta_uapsd_auto_trig_cmdid = WMI_TLV_STA_UAPSD_AUTO_TRIG_CMDID,\n\t.sta_keepalive_cmd = WMI_TLV_STA_KEEPALIVE_CMDID,\n\t.echo_cmdid = WMI_TLV_ECHO_CMDID,\n\t.pdev_utf_cmdid = WMI_TLV_PDEV_UTF_CMDID,\n\t.dbglog_cfg_cmdid = WMI_TLV_DBGLOG_CFG_CMDID,\n\t.pdev_qvit_cmdid = WMI_TLV_PDEV_QVIT_CMDID,\n\t.pdev_ftm_intg_cmdid = WMI_TLV_PDEV_FTM_INTG_CMDID,\n\t.vdev_set_keepalive_cmdid = WMI_TLV_VDEV_SET_KEEPALIVE_CMDID,\n\t.vdev_get_keepalive_cmdid = WMI_TLV_VDEV_GET_KEEPALIVE_CMDID,\n\t.force_fw_hang_cmdid = WMI_TLV_FORCE_FW_HANG_CMDID,\n\t.gpio_config_cmdid = WMI_TLV_GPIO_CONFIG_CMDID,\n\t.gpio_output_cmdid = WMI_TLV_GPIO_OUTPUT_CMDID,\n\t.pdev_get_temperature_cmdid = WMI_TLV_PDEV_GET_TEMPERATURE_CMDID,\n\t.vdev_set_wmm_params_cmdid = WMI_TLV_VDEV_SET_WMM_PARAMS_CMDID,\n\t.tdls_set_state_cmdid = WMI_TLV_TDLS_SET_STATE_CMDID,\n\t.tdls_peer_update_cmdid = WMI_TLV_TDLS_PEER_UPDATE_CMDID,\n\t.adaptive_qcs_cmdid = WMI_TLV_RESMGR_ADAPTIVE_OCS_CMDID,\n\t.scan_update_request_cmdid = WMI_CMD_UNSUPPORTED,\n\t.vdev_standby_response_cmdid = WMI_CMD_UNSUPPORTED,\n\t.vdev_resume_response_cmdid = WMI_CMD_UNSUPPORTED,\n\t.wlan_peer_caching_add_peer_cmdid = WMI_CMD_UNSUPPORTED,\n\t.wlan_peer_caching_evict_peer_cmdid = WMI_CMD_UNSUPPORTED,\n\t.wlan_peer_caching_restore_peer_cmdid = WMI_CMD_UNSUPPORTED,\n\t.wlan_peer_caching_print_all_peers_info_cmdid = WMI_CMD_UNSUPPORTED,\n\t.peer_update_wds_entry_cmdid = WMI_CMD_UNSUPPORTED,\n\t.peer_add_proxy_sta_entry_cmdid = WMI_CMD_UNSUPPORTED,\n\t.rtt_keepalive_cmdid = WMI_CMD_UNSUPPORTED,\n\t.oem_req_cmdid = WMI_CMD_UNSUPPORTED,\n\t.nan_cmdid = WMI_CMD_UNSUPPORTED,\n\t.vdev_ratemask_cmdid = WMI_CMD_UNSUPPORTED,\n\t.qboost_cfg_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_smart_ant_enable_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_smart_ant_set_rx_antenna_cmdid = WMI_CMD_UNSUPPORTED,\n\t.peer_smart_ant_set_tx_antenna_cmdid = WMI_CMD_UNSUPPORTED,\n\t.peer_smart_ant_set_train_info_cmdid = WMI_CMD_UNSUPPORTED,\n\t.peer_smart_ant_set_node_config_ops_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_set_antenna_switch_table_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_set_ctl_table_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_set_mimogain_table_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_ratepwr_table_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_ratepwr_chainmsk_table_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_fips_cmdid = WMI_CMD_UNSUPPORTED,\n\t.tt_set_conf_cmdid = WMI_CMD_UNSUPPORTED,\n\t.fwtest_cmdid = WMI_CMD_UNSUPPORTED,\n\t.vdev_atf_request_cmdid = WMI_CMD_UNSUPPORTED,\n\t.peer_atf_request_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_get_ani_cck_config_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_get_ani_ofdm_config_cmdid = WMI_CMD_UNSUPPORTED,\n\t.pdev_reserve_ast_entry_cmdid = WMI_CMD_UNSUPPORTED,\n};\n\nstatic struct wmi_pdev_param_map wmi_tlv_pdev_param_map = {\n\t.tx_chain_mask = WMI_TLV_PDEV_PARAM_TX_CHAIN_MASK,\n\t.rx_chain_mask = WMI_TLV_PDEV_PARAM_RX_CHAIN_MASK,\n\t.txpower_limit2g = WMI_TLV_PDEV_PARAM_TXPOWER_LIMIT2G,\n\t.txpower_limit5g = WMI_TLV_PDEV_PARAM_TXPOWER_LIMIT5G,\n\t.txpower_scale = WMI_TLV_PDEV_PARAM_TXPOWER_SCALE,\n\t.beacon_gen_mode = WMI_TLV_PDEV_PARAM_BEACON_GEN_MODE,\n\t.beacon_tx_mode = WMI_TLV_PDEV_PARAM_BEACON_TX_MODE,\n\t.resmgr_offchan_mode = WMI_TLV_PDEV_PARAM_RESMGR_OFFCHAN_MODE,\n\t.protection_mode = WMI_TLV_PDEV_PARAM_PROTECTION_MODE,\n\t.dynamic_bw = WMI_TLV_PDEV_PARAM_DYNAMIC_BW,\n\t.non_agg_sw_retry_th = WMI_TLV_PDEV_PARAM_NON_AGG_SW_RETRY_TH,\n\t.agg_sw_retry_th = WMI_TLV_PDEV_PARAM_AGG_SW_RETRY_TH,\n\t.sta_kickout_th = WMI_TLV_PDEV_PARAM_STA_KICKOUT_TH,\n\t.ac_aggrsize_scaling = WMI_TLV_PDEV_PARAM_AC_AGGRSIZE_SCALING,\n\t.ltr_enable = WMI_TLV_PDEV_PARAM_LTR_ENABLE,\n\t.ltr_ac_latency_be = WMI_TLV_PDEV_PARAM_LTR_AC_LATENCY_BE,\n\t.ltr_ac_latency_bk = WMI_TLV_PDEV_PARAM_LTR_AC_LATENCY_BK,\n\t.ltr_ac_latency_vi = WMI_TLV_PDEV_PARAM_LTR_AC_LATENCY_VI,\n\t.ltr_ac_latency_vo = WMI_TLV_PDEV_PARAM_LTR_AC_LATENCY_VO,\n\t.ltr_ac_latency_timeout = WMI_TLV_PDEV_PARAM_LTR_AC_LATENCY_TIMEOUT,\n\t.ltr_sleep_override = WMI_TLV_PDEV_PARAM_LTR_SLEEP_OVERRIDE,\n\t.ltr_rx_override = WMI_TLV_PDEV_PARAM_LTR_RX_OVERRIDE,\n\t.ltr_tx_activity_timeout = WMI_TLV_PDEV_PARAM_LTR_TX_ACTIVITY_TIMEOUT,\n\t.l1ss_enable = WMI_TLV_PDEV_PARAM_L1SS_ENABLE,\n\t.dsleep_enable = WMI_TLV_PDEV_PARAM_DSLEEP_ENABLE,\n\t.pcielp_txbuf_flush = WMI_TLV_PDEV_PARAM_PCIELP_TXBUF_FLUSH,\n\t.pcielp_txbuf_watermark = WMI_TLV_PDEV_PARAM_PCIELP_TXBUF_TMO_EN,\n\t.pcielp_txbuf_tmo_en = WMI_TLV_PDEV_PARAM_PCIELP_TXBUF_TMO_EN,\n\t.pcielp_txbuf_tmo_value = WMI_TLV_PDEV_PARAM_PCIELP_TXBUF_TMO_VALUE,\n\t.pdev_stats_update_period = WMI_TLV_PDEV_PARAM_PDEV_STATS_UPDATE_PERIOD,\n\t.vdev_stats_update_period = WMI_TLV_PDEV_PARAM_VDEV_STATS_UPDATE_PERIOD,\n\t.peer_stats_update_period = WMI_TLV_PDEV_PARAM_PEER_STATS_UPDATE_PERIOD,\n\t.bcnflt_stats_update_period =\n\t\t\t\tWMI_TLV_PDEV_PARAM_BCNFLT_STATS_UPDATE_PERIOD,\n\t.pmf_qos = WMI_TLV_PDEV_PARAM_PMF_QOS,\n\t.arp_ac_override = WMI_TLV_PDEV_PARAM_ARP_AC_OVERRIDE,\n\t.dcs = WMI_TLV_PDEV_PARAM_DCS,\n\t.ani_enable = WMI_TLV_PDEV_PARAM_ANI_ENABLE,\n\t.ani_poll_period = WMI_TLV_PDEV_PARAM_ANI_POLL_PERIOD,\n\t.ani_listen_period = WMI_TLV_PDEV_PARAM_ANI_LISTEN_PERIOD,\n\t.ani_ofdm_level = WMI_TLV_PDEV_PARAM_ANI_OFDM_LEVEL,\n\t.ani_cck_level = WMI_TLV_PDEV_PARAM_ANI_CCK_LEVEL,\n\t.dyntxchain = WMI_TLV_PDEV_PARAM_DYNTXCHAIN,\n\t.proxy_sta = WMI_TLV_PDEV_PARAM_PROXY_STA,\n\t.idle_ps_config = WMI_TLV_PDEV_PARAM_IDLE_PS_CONFIG,\n\t.power_gating_sleep = WMI_TLV_PDEV_PARAM_POWER_GATING_SLEEP,\n\t.fast_channel_reset = WMI_TLV_PDEV_PARAM_UNSUPPORTED,\n\t.burst_dur = WMI_TLV_PDEV_PARAM_BURST_DUR,\n\t.burst_enable = WMI_TLV_PDEV_PARAM_BURST_ENABLE,\n\t.cal_period = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.aggr_burst = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.rx_decap_mode = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.smart_antenna_default_antenna = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.igmpmld_override = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.igmpmld_tid = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.antenna_gain = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.rx_filter = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.set_mcast_to_ucast_tid = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.proxy_sta_mode = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.set_mcast2ucast_mode = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.set_mcast2ucast_buffer = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.remove_mcast2ucast_buffer = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.peer_sta_ps_statechg_enable = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.igmpmld_ac_override = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.block_interbss = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.set_disable_reset_cmdid = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.set_msdu_ttl_cmdid = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.set_ppdu_duration_cmdid = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.txbf_sound_period_cmdid = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.set_promisc_mode_cmdid = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.set_burst_mode_cmdid = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.en_stats = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.mu_group_policy = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.noise_detection = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.noise_threshold = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.dpd_enable = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.set_mcast_bcast_echo = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.atf_strict_sch = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.atf_sched_duration = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.ant_plzn = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.mgmt_retry_limit = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.sensitivity_level = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.signed_txpower_2g = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.signed_txpower_5g = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.enable_per_tid_amsdu = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.enable_per_tid_ampdu = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.cca_threshold = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.rts_fixed_rate = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.pdev_reset = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.wapi_mbssid_offset = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.arp_srcaddr = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.arp_dstaddr = WMI_PDEV_PARAM_UNSUPPORTED,\n\t.rfkill_config = WMI_TLV_PDEV_PARAM_HW_RFKILL_CONFIG,\n\t.rfkill_enable = WMI_TLV_PDEV_PARAM_RFKILL_ENABLE,\n\t.peer_stats_info_enable = WMI_TLV_PDEV_PARAM_PEER_STATS_INFO_ENABLE,\n};\n\nstatic struct wmi_peer_param_map wmi_tlv_peer_param_map = {\n\t.smps_state = WMI_TLV_PEER_SMPS_STATE,\n\t.ampdu = WMI_TLV_PEER_AMPDU,\n\t.authorize = WMI_TLV_PEER_AUTHORIZE,\n\t.chan_width = WMI_TLV_PEER_CHAN_WIDTH,\n\t.nss = WMI_TLV_PEER_NSS,\n\t.use_4addr = WMI_TLV_PEER_USE_4ADDR,\n\t.membership = WMI_TLV_PEER_MEMBERSHIP,\n\t.user_pos = WMI_TLV_PEER_USERPOS,\n\t.crit_proto_hint_enabled = WMI_TLV_PEER_CRIT_PROTO_HINT_ENABLED,\n\t.tx_fail_cnt_thr = WMI_TLV_PEER_TX_FAIL_CNT_THR,\n\t.set_hw_retry_cts2s = WMI_TLV_PEER_SET_HW_RETRY_CTS2S,\n\t.ibss_atim_win_len = WMI_TLV_PEER_IBSS_ATIM_WINDOW_LENGTH,\n\t.phymode = WMI_TLV_PEER_PHYMODE,\n\t.use_fixed_power = WMI_TLV_PEER_USE_FIXED_PWR,\n\t.dummy_var = WMI_TLV_PEER_DUMMY_VAR,\n};\n\nstatic struct wmi_vdev_param_map wmi_tlv_vdev_param_map = {\n\t.rts_threshold = WMI_TLV_VDEV_PARAM_RTS_THRESHOLD,\n\t.fragmentation_threshold = WMI_TLV_VDEV_PARAM_FRAGMENTATION_THRESHOLD,\n\t.beacon_interval = WMI_TLV_VDEV_PARAM_BEACON_INTERVAL,\n\t.listen_interval = WMI_TLV_VDEV_PARAM_LISTEN_INTERVAL,\n\t.multicast_rate = WMI_TLV_VDEV_PARAM_MULTICAST_RATE,\n\t.mgmt_tx_rate = WMI_TLV_VDEV_PARAM_MGMT_TX_RATE,\n\t.slot_time = WMI_TLV_VDEV_PARAM_SLOT_TIME,\n\t.preamble = WMI_TLV_VDEV_PARAM_PREAMBLE,\n\t.swba_time = WMI_TLV_VDEV_PARAM_SWBA_TIME,\n\t.wmi_vdev_stats_update_period = WMI_TLV_VDEV_STATS_UPDATE_PERIOD,\n\t.wmi_vdev_pwrsave_ageout_time = WMI_TLV_VDEV_PWRSAVE_AGEOUT_TIME,\n\t.wmi_vdev_host_swba_interval = WMI_TLV_VDEV_HOST_SWBA_INTERVAL,\n\t.dtim_period = WMI_TLV_VDEV_PARAM_DTIM_PERIOD,\n\t.wmi_vdev_oc_scheduler_air_time_limit =\n\t\t\t\tWMI_TLV_VDEV_OC_SCHEDULER_AIR_TIME_LIMIT,\n\t.wds = WMI_TLV_VDEV_PARAM_WDS,\n\t.atim_window = WMI_TLV_VDEV_PARAM_ATIM_WINDOW,\n\t.bmiss_count_max = WMI_TLV_VDEV_PARAM_BMISS_COUNT_MAX,\n\t.bmiss_first_bcnt = WMI_TLV_VDEV_PARAM_BMISS_FIRST_BCNT,\n\t.bmiss_final_bcnt = WMI_TLV_VDEV_PARAM_BMISS_FINAL_BCNT,\n\t.feature_wmm = WMI_TLV_VDEV_PARAM_FEATURE_WMM,\n\t.chwidth = WMI_TLV_VDEV_PARAM_CHWIDTH,\n\t.chextoffset = WMI_TLV_VDEV_PARAM_CHEXTOFFSET,\n\t.disable_htprotection =\tWMI_TLV_VDEV_PARAM_DISABLE_HTPROTECTION,\n\t.sta_quickkickout = WMI_TLV_VDEV_PARAM_STA_QUICKKICKOUT,\n\t.mgmt_rate = WMI_TLV_VDEV_PARAM_MGMT_RATE,\n\t.protection_mode = WMI_TLV_VDEV_PARAM_PROTECTION_MODE,\n\t.fixed_rate = WMI_TLV_VDEV_PARAM_FIXED_RATE,\n\t.sgi = WMI_TLV_VDEV_PARAM_SGI,\n\t.ldpc = WMI_TLV_VDEV_PARAM_LDPC,\n\t.tx_stbc = WMI_TLV_VDEV_PARAM_TX_STBC,\n\t.rx_stbc = WMI_TLV_VDEV_PARAM_RX_STBC,\n\t.intra_bss_fwd = WMI_TLV_VDEV_PARAM_INTRA_BSS_FWD,\n\t.def_keyid = WMI_TLV_VDEV_PARAM_DEF_KEYID,\n\t.nss = WMI_TLV_VDEV_PARAM_NSS,\n\t.bcast_data_rate = WMI_TLV_VDEV_PARAM_BCAST_DATA_RATE,\n\t.mcast_data_rate = WMI_TLV_VDEV_PARAM_MCAST_DATA_RATE,\n\t.mcast_indicate = WMI_TLV_VDEV_PARAM_MCAST_INDICATE,\n\t.dhcp_indicate = WMI_TLV_VDEV_PARAM_DHCP_INDICATE,\n\t.unknown_dest_indicate = WMI_TLV_VDEV_PARAM_UNKNOWN_DEST_INDICATE,\n\t.ap_keepalive_min_idle_inactive_time_secs =\n\t\tWMI_TLV_VDEV_PARAM_AP_KEEPALIVE_MIN_IDLE_INACTIVE_TIME_SECS,\n\t.ap_keepalive_max_idle_inactive_time_secs =\n\t\tWMI_TLV_VDEV_PARAM_AP_KEEPALIVE_MAX_IDLE_INACTIVE_TIME_SECS,\n\t.ap_keepalive_max_unresponsive_time_secs =\n\t\tWMI_TLV_VDEV_PARAM_AP_KEEPALIVE_MAX_UNRESPONSIVE_TIME_SECS,\n\t.ap_enable_nawds = WMI_TLV_VDEV_PARAM_AP_ENABLE_NAWDS,\n\t.mcast2ucast_set = WMI_TLV_VDEV_PARAM_UNSUPPORTED,\n\t.enable_rtscts = WMI_TLV_VDEV_PARAM_ENABLE_RTSCTS,\n\t.txbf = WMI_TLV_VDEV_PARAM_TXBF,\n\t.packet_powersave = WMI_TLV_VDEV_PARAM_PACKET_POWERSAVE,\n\t.drop_unencry = WMI_TLV_VDEV_PARAM_DROP_UNENCRY,\n\t.tx_encap_type = WMI_TLV_VDEV_PARAM_TX_ENCAP_TYPE,\n\t.ap_detect_out_of_sync_sleeping_sta_time_secs =\n\t\t\t\t\tWMI_TLV_VDEV_PARAM_UNSUPPORTED,\n\t.rc_num_retries = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.cabq_maxdur = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.mfptest_set = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.rts_fixed_rate = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.vht_sgimask = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.vht80_ratemask = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.early_rx_adjust_enable = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.early_rx_tgt_bmiss_num = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.early_rx_bmiss_sample_cycle = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.early_rx_slop_step = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.early_rx_init_slop = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.early_rx_adjust_pause = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.proxy_sta = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.meru_vc = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.rx_decap_type = WMI_VDEV_PARAM_UNSUPPORTED,\n\t.bw_nss_ratemask = WMI_VDEV_PARAM_UNSUPPORTED,\n};\n\nstatic const struct wmi_ops wmi_tlv_ops = {\n\t.rx = ath10k_wmi_tlv_op_rx,\n\t.map_svc = wmi_tlv_svc_map,\n\t.map_svc_ext = wmi_tlv_svc_map_ext,\n\n\t.pull_scan = ath10k_wmi_tlv_op_pull_scan_ev,\n\t.pull_mgmt_rx = ath10k_wmi_tlv_op_pull_mgmt_rx_ev,\n\t.pull_mgmt_tx_compl = ath10k_wmi_tlv_op_pull_mgmt_tx_compl_ev,\n\t.pull_mgmt_tx_bundle_compl = ath10k_wmi_tlv_op_pull_mgmt_tx_bundle_compl_ev,\n\t.pull_ch_info = ath10k_wmi_tlv_op_pull_ch_info_ev,\n\t.pull_vdev_start = ath10k_wmi_tlv_op_pull_vdev_start_ev,\n\t.pull_peer_kick = ath10k_wmi_tlv_op_pull_peer_kick_ev,\n\t.pull_swba = ath10k_wmi_tlv_op_pull_swba_ev,\n\t.pull_phyerr_hdr = ath10k_wmi_tlv_op_pull_phyerr_ev_hdr,\n\t.pull_phyerr = ath10k_wmi_op_pull_phyerr_ev,\n\t.pull_svc_rdy = ath10k_wmi_tlv_op_pull_svc_rdy_ev,\n\t.pull_rdy = ath10k_wmi_tlv_op_pull_rdy_ev,\n\t.pull_svc_avail = ath10k_wmi_tlv_op_pull_svc_avail,\n\t.pull_fw_stats = ath10k_wmi_tlv_op_pull_fw_stats,\n\t.pull_roam_ev = ath10k_wmi_tlv_op_pull_roam_ev,\n\t.pull_wow_event = ath10k_wmi_tlv_op_pull_wow_ev,\n\t.pull_echo_ev = ath10k_wmi_tlv_op_pull_echo_ev,\n\t.get_txbf_conf_scheme = ath10k_wmi_tlv_txbf_conf_scheme,\n\n\t.gen_pdev_suspend = ath10k_wmi_tlv_op_gen_pdev_suspend,\n\t.gen_pdev_resume = ath10k_wmi_tlv_op_gen_pdev_resume,\n\t.gen_pdev_set_rd = ath10k_wmi_tlv_op_gen_pdev_set_rd,\n\t.gen_pdev_set_param = ath10k_wmi_tlv_op_gen_pdev_set_param,\n\t.gen_init = ath10k_wmi_tlv_op_gen_init,\n\t.gen_start_scan = ath10k_wmi_tlv_op_gen_start_scan,\n\t.gen_stop_scan = ath10k_wmi_tlv_op_gen_stop_scan,\n\t.gen_vdev_create = ath10k_wmi_tlv_op_gen_vdev_create,\n\t.gen_vdev_delete = ath10k_wmi_tlv_op_gen_vdev_delete,\n\t.gen_vdev_start = ath10k_wmi_tlv_op_gen_vdev_start,\n\t.gen_vdev_stop = ath10k_wmi_tlv_op_gen_vdev_stop,\n\t.gen_vdev_up = ath10k_wmi_tlv_op_gen_vdev_up,\n\t.gen_vdev_down = ath10k_wmi_tlv_op_gen_vdev_down,\n\t.gen_vdev_set_param = ath10k_wmi_tlv_op_gen_vdev_set_param,\n\t.gen_vdev_install_key = ath10k_wmi_tlv_op_gen_vdev_install_key,\n\t.gen_vdev_wmm_conf = ath10k_wmi_tlv_op_gen_vdev_wmm_conf,\n\t.gen_peer_create = ath10k_wmi_tlv_op_gen_peer_create,\n\t.gen_peer_delete = ath10k_wmi_tlv_op_gen_peer_delete,\n\t.gen_peer_flush = ath10k_wmi_tlv_op_gen_peer_flush,\n\t.gen_peer_set_param = ath10k_wmi_tlv_op_gen_peer_set_param,\n\t.gen_peer_assoc = ath10k_wmi_tlv_op_gen_peer_assoc,\n\t.gen_set_psmode = ath10k_wmi_tlv_op_gen_set_psmode,\n\t.gen_set_sta_ps = ath10k_wmi_tlv_op_gen_set_sta_ps,\n\t.gen_set_ap_ps = ath10k_wmi_tlv_op_gen_set_ap_ps,\n\t.gen_scan_chan_list = ath10k_wmi_tlv_op_gen_scan_chan_list,\n\t.gen_scan_prob_req_oui = ath10k_wmi_tlv_op_gen_scan_prob_req_oui,\n\t.gen_beacon_dma = ath10k_wmi_tlv_op_gen_beacon_dma,\n\t.gen_pdev_set_wmm = ath10k_wmi_tlv_op_gen_pdev_set_wmm,\n\t.gen_request_stats = ath10k_wmi_tlv_op_gen_request_stats,\n\t.gen_request_peer_stats_info = ath10k_wmi_tlv_op_gen_request_peer_stats_info,\n\t.gen_force_fw_hang = ath10k_wmi_tlv_op_gen_force_fw_hang,\n\t \n\t.gen_mgmt_tx_send = ath10k_wmi_tlv_op_gen_mgmt_tx_send,\n\t.cleanup_mgmt_tx_send = ath10k_wmi_tlv_op_cleanup_mgmt_tx_send,\n\t.gen_dbglog_cfg = ath10k_wmi_tlv_op_gen_dbglog_cfg,\n\t.gen_pktlog_enable = ath10k_wmi_tlv_op_gen_pktlog_enable,\n\t.gen_pktlog_disable = ath10k_wmi_tlv_op_gen_pktlog_disable,\n\t.gen_pdev_set_quiet_mode = ath10k_wmi_tlv_op_gen_pdev_set_quiet_mode,\n\t.gen_pdev_get_temperature = ath10k_wmi_tlv_op_gen_pdev_get_temperature,\n\t \n\t \n\t \n\t \n\t.gen_bcn_tmpl = ath10k_wmi_tlv_op_gen_bcn_tmpl,\n\t.gen_prb_tmpl = ath10k_wmi_tlv_op_gen_prb_tmpl,\n\t.gen_p2p_go_bcn_ie = ath10k_wmi_tlv_op_gen_p2p_go_bcn_ie,\n\t.gen_vdev_sta_uapsd = ath10k_wmi_tlv_op_gen_vdev_sta_uapsd,\n\t.gen_sta_keepalive = ath10k_wmi_tlv_op_gen_sta_keepalive,\n\t.gen_wow_enable = ath10k_wmi_tlv_op_gen_wow_enable,\n\t.gen_wow_add_wakeup_event = ath10k_wmi_tlv_op_gen_wow_add_wakeup_event,\n\t.gen_wow_host_wakeup_ind = ath10k_wmi_tlv_gen_wow_host_wakeup_ind,\n\t.gen_wow_add_pattern = ath10k_wmi_tlv_op_gen_wow_add_pattern,\n\t.gen_wow_del_pattern = ath10k_wmi_tlv_op_gen_wow_del_pattern,\n\t.gen_wow_config_pno = ath10k_wmi_tlv_op_gen_config_pno,\n\t.gen_update_fw_tdls_state = ath10k_wmi_tlv_op_gen_update_fw_tdls_state,\n\t.gen_tdls_peer_update = ath10k_wmi_tlv_op_gen_tdls_peer_update,\n\t.gen_adaptive_qcs = ath10k_wmi_tlv_op_gen_adaptive_qcs,\n\t.fw_stats_fill = ath10k_wmi_main_op_fw_stats_fill,\n\t.get_vdev_subtype = ath10k_wmi_tlv_op_get_vdev_subtype,\n\t.gen_echo = ath10k_wmi_tlv_op_gen_echo,\n\t.gen_vdev_spectral_conf = ath10k_wmi_tlv_op_gen_vdev_spectral_conf,\n\t.gen_vdev_spectral_enable = ath10k_wmi_tlv_op_gen_vdev_spectral_enable,\n};\n\nstatic const struct wmi_peer_flags_map wmi_tlv_peer_flags_map = {\n\t.auth = WMI_TLV_PEER_AUTH,\n\t.qos = WMI_TLV_PEER_QOS,\n\t.need_ptk_4_way = WMI_TLV_PEER_NEED_PTK_4_WAY,\n\t.need_gtk_2_way = WMI_TLV_PEER_NEED_GTK_2_WAY,\n\t.apsd = WMI_TLV_PEER_APSD,\n\t.ht = WMI_TLV_PEER_HT,\n\t.bw40 = WMI_TLV_PEER_40MHZ,\n\t.stbc = WMI_TLV_PEER_STBC,\n\t.ldbc = WMI_TLV_PEER_LDPC,\n\t.dyn_mimops = WMI_TLV_PEER_DYN_MIMOPS,\n\t.static_mimops = WMI_TLV_PEER_STATIC_MIMOPS,\n\t.spatial_mux = WMI_TLV_PEER_SPATIAL_MUX,\n\t.vht = WMI_TLV_PEER_VHT,\n\t.bw80 = WMI_TLV_PEER_80MHZ,\n\t.pmf = WMI_TLV_PEER_PMF,\n\t.bw160 = WMI_TLV_PEER_160MHZ,\n};\n\n \n \n \n\nvoid ath10k_wmi_tlv_attach(struct ath10k *ar)\n{\n\tar->wmi.cmd = &wmi_tlv_cmd_map;\n\tar->wmi.vdev_param = &wmi_tlv_vdev_param_map;\n\tar->wmi.pdev_param = &wmi_tlv_pdev_param_map;\n\tar->wmi.peer_param = &wmi_tlv_peer_param_map;\n\tar->wmi.ops = &wmi_tlv_ops;\n\tar->wmi.peer_flags = &wmi_tlv_peer_flags_map;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}