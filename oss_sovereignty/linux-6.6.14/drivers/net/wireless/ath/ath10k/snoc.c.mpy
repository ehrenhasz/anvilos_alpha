{
  "module_name": "snoc.c",
  "hash_id": "36f2e8439fafebc67367e781cc6b0c5985c450ce0d61c69b6dfb99c8be2547f9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath10k/snoc.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/regulator/consumer.h>\n#include <linux/remoteproc/qcom_rproc.h>\n#include <linux/of_address.h>\n#include <linux/iommu.h>\n\n#include \"ce.h\"\n#include \"coredump.h\"\n#include \"debug.h\"\n#include \"hif.h\"\n#include \"htc.h\"\n#include \"snoc.h\"\n\n#define ATH10K_SNOC_RX_POST_RETRY_MS 50\n#define CE_POLL_PIPE 4\n#define ATH10K_SNOC_WAKE_IRQ 2\n\nstatic char *const ce_name[] = {\n\t\"WLAN_CE_0\",\n\t\"WLAN_CE_1\",\n\t\"WLAN_CE_2\",\n\t\"WLAN_CE_3\",\n\t\"WLAN_CE_4\",\n\t\"WLAN_CE_5\",\n\t\"WLAN_CE_6\",\n\t\"WLAN_CE_7\",\n\t\"WLAN_CE_8\",\n\t\"WLAN_CE_9\",\n\t\"WLAN_CE_10\",\n\t\"WLAN_CE_11\",\n};\n\nstatic const char * const ath10k_regulators[] = {\n\t\"vdd-0.8-cx-mx\",\n\t\"vdd-1.8-xo\",\n\t\"vdd-1.3-rfa\",\n\t\"vdd-3.3-ch0\",\n\t\"vdd-3.3-ch1\",\n};\n\nstatic const char * const ath10k_clocks[] = {\n\t\"cxo_ref_clk_pin\", \"qdss\",\n};\n\nstatic void ath10k_snoc_htc_tx_cb(struct ath10k_ce_pipe *ce_state);\nstatic void ath10k_snoc_htt_tx_cb(struct ath10k_ce_pipe *ce_state);\nstatic void ath10k_snoc_htc_rx_cb(struct ath10k_ce_pipe *ce_state);\nstatic void ath10k_snoc_htt_rx_cb(struct ath10k_ce_pipe *ce_state);\nstatic void ath10k_snoc_htt_htc_rx_cb(struct ath10k_ce_pipe *ce_state);\nstatic void ath10k_snoc_pktlog_rx_cb(struct ath10k_ce_pipe *ce_state);\n\nstatic const struct ath10k_snoc_drv_priv drv_priv = {\n\t.hw_rev = ATH10K_HW_WCN3990,\n\t.dma_mask = DMA_BIT_MASK(35),\n\t.msa_size = 0x100000,\n};\n\n#define WCN3990_SRC_WR_IDX_OFFSET 0x3C\n#define WCN3990_DST_WR_IDX_OFFSET 0x40\n\nstatic struct ath10k_shadow_reg_cfg target_shadow_reg_cfg_map[] = {\n\t\t{\n\t\t\t.ce_id = __cpu_to_le16(0),\n\t\t\t.reg_offset = __cpu_to_le16(WCN3990_SRC_WR_IDX_OFFSET),\n\t\t},\n\n\t\t{\n\t\t\t.ce_id = __cpu_to_le16(3),\n\t\t\t.reg_offset = __cpu_to_le16(WCN3990_SRC_WR_IDX_OFFSET),\n\t\t},\n\n\t\t{\n\t\t\t.ce_id = __cpu_to_le16(4),\n\t\t\t.reg_offset = __cpu_to_le16(WCN3990_SRC_WR_IDX_OFFSET),\n\t\t},\n\n\t\t{\n\t\t\t.ce_id = __cpu_to_le16(5),\n\t\t\t.reg_offset =  __cpu_to_le16(WCN3990_SRC_WR_IDX_OFFSET),\n\t\t},\n\n\t\t{\n\t\t\t.ce_id = __cpu_to_le16(7),\n\t\t\t.reg_offset = __cpu_to_le16(WCN3990_SRC_WR_IDX_OFFSET),\n\t\t},\n\n\t\t{\n\t\t\t.ce_id = __cpu_to_le16(1),\n\t\t\t.reg_offset = __cpu_to_le16(WCN3990_DST_WR_IDX_OFFSET),\n\t\t},\n\n\t\t{\n\t\t\t.ce_id = __cpu_to_le16(2),\n\t\t\t.reg_offset =  __cpu_to_le16(WCN3990_DST_WR_IDX_OFFSET),\n\t\t},\n\n\t\t{\n\t\t\t.ce_id = __cpu_to_le16(7),\n\t\t\t.reg_offset =  __cpu_to_le16(WCN3990_DST_WR_IDX_OFFSET),\n\t\t},\n\n\t\t{\n\t\t\t.ce_id = __cpu_to_le16(8),\n\t\t\t.reg_offset =  __cpu_to_le16(WCN3990_DST_WR_IDX_OFFSET),\n\t\t},\n\n\t\t{\n\t\t\t.ce_id = __cpu_to_le16(9),\n\t\t\t.reg_offset = __cpu_to_le16(WCN3990_DST_WR_IDX_OFFSET),\n\t\t},\n\n\t\t{\n\t\t\t.ce_id = __cpu_to_le16(10),\n\t\t\t.reg_offset =  __cpu_to_le16(WCN3990_DST_WR_IDX_OFFSET),\n\t\t},\n\n\t\t{\n\t\t\t.ce_id = __cpu_to_le16(11),\n\t\t\t.reg_offset = __cpu_to_le16(WCN3990_DST_WR_IDX_OFFSET),\n\t\t},\n};\n\nstatic struct ce_attr host_ce_config_wlan[] = {\n\t \n\t{\n\t\t.flags = CE_ATTR_FLAGS,\n\t\t.src_nentries = 16,\n\t\t.src_sz_max = 2048,\n\t\t.dest_nentries = 0,\n\t\t.send_cb = ath10k_snoc_htc_tx_cb,\n\t},\n\n\t \n\t{\n\t\t.flags = CE_ATTR_FLAGS,\n\t\t.src_nentries = 0,\n\t\t.src_sz_max = 2048,\n\t\t.dest_nentries = 512,\n\t\t.recv_cb = ath10k_snoc_htt_htc_rx_cb,\n\t},\n\n\t \n\t{\n\t\t.flags = CE_ATTR_FLAGS,\n\t\t.src_nentries = 0,\n\t\t.src_sz_max = 2048,\n\t\t.dest_nentries = 64,\n\t\t.recv_cb = ath10k_snoc_htc_rx_cb,\n\t},\n\n\t \n\t{\n\t\t.flags = CE_ATTR_FLAGS,\n\t\t.src_nentries = 32,\n\t\t.src_sz_max = 2048,\n\t\t.dest_nentries = 0,\n\t\t.send_cb = ath10k_snoc_htc_tx_cb,\n\t},\n\n\t \n\t{\n\t\t.flags = CE_ATTR_FLAGS | CE_ATTR_DIS_INTR,\n\t\t.src_nentries = 2048,\n\t\t.src_sz_max = 256,\n\t\t.dest_nentries = 0,\n\t\t.send_cb = ath10k_snoc_htt_tx_cb,\n\t},\n\n\t \n\t{\n\t\t.flags = CE_ATTR_FLAGS,\n\t\t.src_nentries = 0,\n\t\t.src_sz_max = 512,\n\t\t.dest_nentries = 512,\n\t\t.recv_cb = ath10k_snoc_htt_rx_cb,\n\t},\n\n\t \n\t{\n\t\t.flags = CE_ATTR_FLAGS,\n\t\t.src_nentries = 0,\n\t\t.src_sz_max = 0,\n\t\t.dest_nentries = 0,\n\t},\n\n\t \n\t{\n\t\t.flags = CE_ATTR_FLAGS,\n\t\t.src_nentries = 2,\n\t\t.src_sz_max = 2048,\n\t\t.dest_nentries = 2,\n\t},\n\n\t \n\t{\n\t\t.flags = CE_ATTR_FLAGS,\n\t\t.src_nentries = 0,\n\t\t.src_sz_max = 2048,\n\t\t.dest_nentries = 128,\n\t},\n\n\t \n\t{\n\t\t.flags = CE_ATTR_FLAGS,\n\t\t.src_nentries = 0,\n\t\t.src_sz_max = 2048,\n\t\t.dest_nentries = 512,\n\t\t.recv_cb = ath10k_snoc_htt_htc_rx_cb,\n\t},\n\n\t \n\t{\n\t\t.flags = CE_ATTR_FLAGS,\n\t\t.src_nentries = 0,\n\t\t.src_sz_max = 2048,\n\t\t.dest_nentries = 512,\n\t\t.recv_cb = ath10k_snoc_htt_htc_rx_cb,\n\t},\n\n\t \n\t{\n\t\t.flags = CE_ATTR_FLAGS,\n\t\t.src_nentries = 0,\n\t\t.src_sz_max = 2048,\n\t\t.dest_nentries = 512,\n\t\t.recv_cb = ath10k_snoc_pktlog_rx_cb,\n\t},\n};\n\nstatic struct ce_pipe_config target_ce_config_wlan[] = {\n\t \n\t{\n\t\t.pipenum = __cpu_to_le32(0),\n\t\t.pipedir = __cpu_to_le32(PIPEDIR_OUT),\n\t\t.nentries = __cpu_to_le32(32),\n\t\t.nbytes_max = __cpu_to_le32(2048),\n\t\t.flags = __cpu_to_le32(CE_ATTR_FLAGS),\n\t\t.reserved = __cpu_to_le32(0),\n\t},\n\n\t \n\t{\n\t\t.pipenum = __cpu_to_le32(1),\n\t\t.pipedir = __cpu_to_le32(PIPEDIR_IN),\n\t\t.nentries = __cpu_to_le32(32),\n\t\t.nbytes_max = __cpu_to_le32(2048),\n\t\t.flags = __cpu_to_le32(CE_ATTR_FLAGS),\n\t\t.reserved = __cpu_to_le32(0),\n\t},\n\n\t \n\t{\n\t\t.pipenum = __cpu_to_le32(2),\n\t\t.pipedir = __cpu_to_le32(PIPEDIR_IN),\n\t\t.nentries = __cpu_to_le32(64),\n\t\t.nbytes_max = __cpu_to_le32(2048),\n\t\t.flags = __cpu_to_le32(CE_ATTR_FLAGS),\n\t\t.reserved = __cpu_to_le32(0),\n\t},\n\n\t \n\t{\n\t\t.pipenum = __cpu_to_le32(3),\n\t\t.pipedir = __cpu_to_le32(PIPEDIR_OUT),\n\t\t.nentries = __cpu_to_le32(32),\n\t\t.nbytes_max = __cpu_to_le32(2048),\n\t\t.flags = __cpu_to_le32(CE_ATTR_FLAGS),\n\t\t.reserved = __cpu_to_le32(0),\n\t},\n\n\t \n\t{\n\t\t.pipenum = __cpu_to_le32(4),\n\t\t.pipedir = __cpu_to_le32(PIPEDIR_OUT),\n\t\t.nentries = __cpu_to_le32(256),\n\t\t.nbytes_max = __cpu_to_le32(256),\n\t\t.flags = __cpu_to_le32(CE_ATTR_FLAGS | CE_ATTR_DIS_INTR),\n\t\t.reserved = __cpu_to_le32(0),\n\t},\n\n\t \n\t{\n\t\t.pipenum = __cpu_to_le32(5),\n\t\t.pipedir = __cpu_to_le32(PIPEDIR_OUT),\n\t\t.nentries = __cpu_to_le32(1024),\n\t\t.nbytes_max = __cpu_to_le32(64),\n\t\t.flags = __cpu_to_le32(CE_ATTR_FLAGS | CE_ATTR_DIS_INTR),\n\t\t.reserved = __cpu_to_le32(0),\n\t},\n\n\t \n\t{\n\t\t.pipenum = __cpu_to_le32(6),\n\t\t.pipedir = __cpu_to_le32(PIPEDIR_INOUT),\n\t\t.nentries = __cpu_to_le32(32),\n\t\t.nbytes_max = __cpu_to_le32(16384),\n\t\t.flags = __cpu_to_le32(CE_ATTR_FLAGS),\n\t\t.reserved = __cpu_to_le32(0),\n\t},\n\n\t \n\t{\n\t\t.pipenum = __cpu_to_le32(7),\n\t\t.pipedir = __cpu_to_le32(4),\n\t\t.nentries = __cpu_to_le32(0),\n\t\t.nbytes_max = __cpu_to_le32(0),\n\t\t.flags = __cpu_to_le32(CE_ATTR_FLAGS | CE_ATTR_DIS_INTR),\n\t\t.reserved = __cpu_to_le32(0),\n\t},\n\n\t \n\t{\n\t\t.pipenum = __cpu_to_le32(8),\n\t\t.pipedir = __cpu_to_le32(PIPEDIR_IN),\n\t\t.nentries = __cpu_to_le32(32),\n\t\t.nbytes_max = __cpu_to_le32(2048),\n\t\t.flags = __cpu_to_le32(0),\n\t\t.reserved = __cpu_to_le32(0),\n\t},\n\n\t \n\t{\n\t\t.pipenum = __cpu_to_le32(9),\n\t\t.pipedir = __cpu_to_le32(PIPEDIR_IN),\n\t\t.nentries = __cpu_to_le32(32),\n\t\t.nbytes_max = __cpu_to_le32(2048),\n\t\t.flags = __cpu_to_le32(CE_ATTR_FLAGS),\n\t\t.reserved = __cpu_to_le32(0),\n\t},\n\n\t \n\t{\n\t\t.pipenum = __cpu_to_le32(10),\n\t\t.pipedir = __cpu_to_le32(PIPEDIR_IN),\n\t\t.nentries = __cpu_to_le32(32),\n\t\t.nbytes_max = __cpu_to_le32(2048),\n\t\t.flags = __cpu_to_le32(CE_ATTR_FLAGS),\n\t\t.reserved = __cpu_to_le32(0),\n\t},\n\n\t \n\t{\n\t\t.pipenum = __cpu_to_le32(11),\n\t\t.pipedir = __cpu_to_le32(PIPEDIR_IN),\n\t\t.nentries = __cpu_to_le32(32),\n\t\t.nbytes_max = __cpu_to_le32(2048),\n\t\t.flags = __cpu_to_le32(CE_ATTR_FLAGS),\n\t\t.reserved = __cpu_to_le32(0),\n\t},\n};\n\nstatic struct ce_service_to_pipe target_service_to_ce_map_wlan[] = {\n\t{\n\t\t__cpu_to_le32(ATH10K_HTC_SVC_ID_WMI_DATA_VO),\n\t\t__cpu_to_le32(PIPEDIR_OUT),\t \n\t\t__cpu_to_le32(3),\n\t},\n\t{\n\t\t__cpu_to_le32(ATH10K_HTC_SVC_ID_WMI_DATA_VO),\n\t\t__cpu_to_le32(PIPEDIR_IN),\t \n\t\t__cpu_to_le32(2),\n\t},\n\t{\n\t\t__cpu_to_le32(ATH10K_HTC_SVC_ID_WMI_DATA_BK),\n\t\t__cpu_to_le32(PIPEDIR_OUT),\t \n\t\t__cpu_to_le32(3),\n\t},\n\t{\n\t\t__cpu_to_le32(ATH10K_HTC_SVC_ID_WMI_DATA_BK),\n\t\t__cpu_to_le32(PIPEDIR_IN),\t \n\t\t__cpu_to_le32(2),\n\t},\n\t{\n\t\t__cpu_to_le32(ATH10K_HTC_SVC_ID_WMI_DATA_BE),\n\t\t__cpu_to_le32(PIPEDIR_OUT),\t \n\t\t__cpu_to_le32(3),\n\t},\n\t{\n\t\t__cpu_to_le32(ATH10K_HTC_SVC_ID_WMI_DATA_BE),\n\t\t__cpu_to_le32(PIPEDIR_IN),\t \n\t\t__cpu_to_le32(2),\n\t},\n\t{\n\t\t__cpu_to_le32(ATH10K_HTC_SVC_ID_WMI_DATA_VI),\n\t\t__cpu_to_le32(PIPEDIR_OUT),\t \n\t\t__cpu_to_le32(3),\n\t},\n\t{\n\t\t__cpu_to_le32(ATH10K_HTC_SVC_ID_WMI_DATA_VI),\n\t\t__cpu_to_le32(PIPEDIR_IN),\t \n\t\t__cpu_to_le32(2),\n\t},\n\t{\n\t\t__cpu_to_le32(ATH10K_HTC_SVC_ID_WMI_CONTROL),\n\t\t__cpu_to_le32(PIPEDIR_OUT),\t \n\t\t__cpu_to_le32(3),\n\t},\n\t{\n\t\t__cpu_to_le32(ATH10K_HTC_SVC_ID_WMI_CONTROL),\n\t\t__cpu_to_le32(PIPEDIR_IN),\t \n\t\t__cpu_to_le32(2),\n\t},\n\t{\n\t\t__cpu_to_le32(ATH10K_HTC_SVC_ID_RSVD_CTRL),\n\t\t__cpu_to_le32(PIPEDIR_OUT),\t \n\t\t__cpu_to_le32(0),\n\t},\n\t{\n\t\t__cpu_to_le32(ATH10K_HTC_SVC_ID_RSVD_CTRL),\n\t\t__cpu_to_le32(PIPEDIR_IN),\t \n\t\t__cpu_to_le32(2),\n\t},\n\t{  \n\t\t__cpu_to_le32(ATH10K_HTC_SVC_ID_TEST_RAW_STREAMS),\n\t\t__cpu_to_le32(PIPEDIR_OUT),\t \n\t\t__cpu_to_le32(0),\n\t},\n\t{  \n\t\t__cpu_to_le32(ATH10K_HTC_SVC_ID_TEST_RAW_STREAMS),\n\t\t__cpu_to_le32(PIPEDIR_IN),\t \n\t\t__cpu_to_le32(2),\n\t},\n\t{\n\t\t__cpu_to_le32(ATH10K_HTC_SVC_ID_HTT_DATA_MSG),\n\t\t__cpu_to_le32(PIPEDIR_OUT),\t \n\t\t__cpu_to_le32(4),\n\t},\n\t{\n\t\t__cpu_to_le32(ATH10K_HTC_SVC_ID_HTT_DATA_MSG),\n\t\t__cpu_to_le32(PIPEDIR_IN),\t \n\t\t__cpu_to_le32(1),\n\t},\n\t{  \n\t\t__cpu_to_le32(ATH10K_HTC_SVC_ID_TEST_RAW_STREAMS),\n\t\t__cpu_to_le32(PIPEDIR_OUT),\n\t\t__cpu_to_le32(5),\n\t},\n\t{  \n\t\t__cpu_to_le32(ATH10K_HTC_SVC_ID_HTT_DATA2_MSG),\n\t\t__cpu_to_le32(PIPEDIR_IN),\t \n\t\t__cpu_to_le32(9),\n\t},\n\t{  \n\t\t__cpu_to_le32(ATH10K_HTC_SVC_ID_HTT_DATA3_MSG),\n\t\t__cpu_to_le32(PIPEDIR_IN),\t \n\t\t__cpu_to_le32(10),\n\t},\n\t{  \n\t\t__cpu_to_le32(ATH10K_HTC_SVC_ID_HTT_LOG_MSG),\n\t\t__cpu_to_le32(PIPEDIR_IN),\t \n\t\t__cpu_to_le32(11),\n\t},\n\t \n\n\t{  \n\t\t__cpu_to_le32(0),\n\t\t__cpu_to_le32(0),\n\t\t__cpu_to_le32(0),\n\t},\n};\n\nstatic void ath10k_snoc_write32(struct ath10k *ar, u32 offset, u32 value)\n{\n\tstruct ath10k_snoc *ar_snoc = ath10k_snoc_priv(ar);\n\n\tiowrite32(value, ar_snoc->mem + offset);\n}\n\nstatic u32 ath10k_snoc_read32(struct ath10k *ar, u32 offset)\n{\n\tstruct ath10k_snoc *ar_snoc = ath10k_snoc_priv(ar);\n\tu32 val;\n\n\tval = ioread32(ar_snoc->mem + offset);\n\n\treturn val;\n}\n\nstatic int __ath10k_snoc_rx_post_buf(struct ath10k_snoc_pipe *pipe)\n{\n\tstruct ath10k_ce_pipe *ce_pipe = pipe->ce_hdl;\n\tstruct ath10k *ar = pipe->hif_ce_state;\n\tstruct ath10k_ce *ce = ath10k_ce_priv(ar);\n\tstruct sk_buff *skb;\n\tdma_addr_t paddr;\n\tint ret;\n\n\tskb = dev_alloc_skb(pipe->buf_sz);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tWARN_ONCE((unsigned long)skb->data & 3, \"unaligned skb\");\n\n\tpaddr = dma_map_single(ar->dev, skb->data,\n\t\t\t       skb->len + skb_tailroom(skb),\n\t\t\t       DMA_FROM_DEVICE);\n\tif (unlikely(dma_mapping_error(ar->dev, paddr))) {\n\t\tath10k_warn(ar, \"failed to dma map snoc rx buf\\n\");\n\t\tdev_kfree_skb_any(skb);\n\t\treturn -EIO;\n\t}\n\n\tATH10K_SKB_RXCB(skb)->paddr = paddr;\n\n\tspin_lock_bh(&ce->ce_lock);\n\tret = ce_pipe->ops->ce_rx_post_buf(ce_pipe, skb, paddr);\n\tspin_unlock_bh(&ce->ce_lock);\n\tif (ret) {\n\t\tdma_unmap_single(ar->dev, paddr, skb->len + skb_tailroom(skb),\n\t\t\t\t DMA_FROM_DEVICE);\n\t\tdev_kfree_skb_any(skb);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void ath10k_snoc_rx_post_pipe(struct ath10k_snoc_pipe *pipe)\n{\n\tstruct ath10k *ar = pipe->hif_ce_state;\n\tstruct ath10k_ce *ce = ath10k_ce_priv(ar);\n\tstruct ath10k_snoc *ar_snoc = ath10k_snoc_priv(ar);\n\tstruct ath10k_ce_pipe *ce_pipe = pipe->ce_hdl;\n\tint ret, num;\n\n\tif (pipe->buf_sz == 0)\n\t\treturn;\n\n\tif (!ce_pipe->dest_ring)\n\t\treturn;\n\n\tspin_lock_bh(&ce->ce_lock);\n\tnum = __ath10k_ce_rx_num_free_bufs(ce_pipe);\n\tspin_unlock_bh(&ce->ce_lock);\n\twhile (num--) {\n\t\tret = __ath10k_snoc_rx_post_buf(pipe);\n\t\tif (ret) {\n\t\t\tif (ret == -ENOSPC)\n\t\t\t\tbreak;\n\t\t\tath10k_warn(ar, \"failed to post rx buf: %d\\n\", ret);\n\t\t\tmod_timer(&ar_snoc->rx_post_retry, jiffies +\n\t\t\t\t  ATH10K_SNOC_RX_POST_RETRY_MS);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void ath10k_snoc_rx_post(struct ath10k *ar)\n{\n\tstruct ath10k_snoc *ar_snoc = ath10k_snoc_priv(ar);\n\tint i;\n\n\tfor (i = 0; i < CE_COUNT; i++)\n\t\tath10k_snoc_rx_post_pipe(&ar_snoc->pipe_info[i]);\n}\n\nstatic void ath10k_snoc_process_rx_cb(struct ath10k_ce_pipe *ce_state,\n\t\t\t\t      void (*callback)(struct ath10k *ar,\n\t\t\t\t\t\t       struct sk_buff *skb))\n{\n\tstruct ath10k *ar = ce_state->ar;\n\tstruct ath10k_snoc *ar_snoc = ath10k_snoc_priv(ar);\n\tstruct ath10k_snoc_pipe *pipe_info =  &ar_snoc->pipe_info[ce_state->id];\n\tstruct sk_buff *skb;\n\tstruct sk_buff_head list;\n\tvoid *transfer_context;\n\tunsigned int nbytes, max_nbytes;\n\n\t__skb_queue_head_init(&list);\n\twhile (ath10k_ce_completed_recv_next(ce_state, &transfer_context,\n\t\t\t\t\t     &nbytes) == 0) {\n\t\tskb = transfer_context;\n\t\tmax_nbytes = skb->len + skb_tailroom(skb);\n\t\tdma_unmap_single(ar->dev, ATH10K_SKB_RXCB(skb)->paddr,\n\t\t\t\t max_nbytes, DMA_FROM_DEVICE);\n\n\t\tif (unlikely(max_nbytes < nbytes)) {\n\t\t\tath10k_warn(ar, \"rxed more than expected (nbytes %d, max %d)\\n\",\n\t\t\t\t    nbytes, max_nbytes);\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tskb_put(skb, nbytes);\n\t\t__skb_queue_tail(&list, skb);\n\t}\n\n\twhile ((skb = __skb_dequeue(&list))) {\n\t\tath10k_dbg(ar, ATH10K_DBG_SNOC, \"snoc rx ce pipe %d len %d\\n\",\n\t\t\t   ce_state->id, skb->len);\n\n\t\tcallback(ar, skb);\n\t}\n\n\tath10k_snoc_rx_post_pipe(pipe_info);\n}\n\nstatic void ath10k_snoc_htc_rx_cb(struct ath10k_ce_pipe *ce_state)\n{\n\tath10k_snoc_process_rx_cb(ce_state, ath10k_htc_rx_completion_handler);\n}\n\nstatic void ath10k_snoc_htt_htc_rx_cb(struct ath10k_ce_pipe *ce_state)\n{\n\t \n\tath10k_ce_per_engine_service(ce_state->ar, CE_POLL_PIPE);\n\n\tath10k_snoc_process_rx_cb(ce_state, ath10k_htc_rx_completion_handler);\n}\n\n \nstatic void ath10k_snoc_pktlog_rx_cb(struct ath10k_ce_pipe *ce_state)\n{\n\tath10k_snoc_process_rx_cb(ce_state, ath10k_htc_rx_completion_handler);\n}\n\nstatic void ath10k_snoc_htt_rx_deliver(struct ath10k *ar, struct sk_buff *skb)\n{\n\tskb_pull(skb, sizeof(struct ath10k_htc_hdr));\n\tath10k_htt_t2h_msg_handler(ar, skb);\n}\n\nstatic void ath10k_snoc_htt_rx_cb(struct ath10k_ce_pipe *ce_state)\n{\n\tath10k_ce_per_engine_service(ce_state->ar, CE_POLL_PIPE);\n\tath10k_snoc_process_rx_cb(ce_state, ath10k_snoc_htt_rx_deliver);\n}\n\nstatic void ath10k_snoc_rx_replenish_retry(struct timer_list *t)\n{\n\tstruct ath10k_snoc *ar_snoc = from_timer(ar_snoc, t, rx_post_retry);\n\tstruct ath10k *ar = ar_snoc->ar;\n\n\tath10k_snoc_rx_post(ar);\n}\n\nstatic void ath10k_snoc_htc_tx_cb(struct ath10k_ce_pipe *ce_state)\n{\n\tstruct ath10k *ar = ce_state->ar;\n\tstruct sk_buff_head list;\n\tstruct sk_buff *skb;\n\n\t__skb_queue_head_init(&list);\n\twhile (ath10k_ce_completed_send_next(ce_state, (void **)&skb) == 0) {\n\t\tif (!skb)\n\t\t\tcontinue;\n\n\t\t__skb_queue_tail(&list, skb);\n\t}\n\n\twhile ((skb = __skb_dequeue(&list)))\n\t\tath10k_htc_tx_completion_handler(ar, skb);\n}\n\nstatic void ath10k_snoc_htt_tx_cb(struct ath10k_ce_pipe *ce_state)\n{\n\tstruct ath10k *ar = ce_state->ar;\n\tstruct sk_buff *skb;\n\n\twhile (ath10k_ce_completed_send_next(ce_state, (void **)&skb) == 0) {\n\t\tif (!skb)\n\t\t\tcontinue;\n\n\t\tdma_unmap_single(ar->dev, ATH10K_SKB_CB(skb)->paddr,\n\t\t\t\t skb->len, DMA_TO_DEVICE);\n\t\tath10k_htt_hif_tx_complete(ar, skb);\n\t}\n}\n\nstatic int ath10k_snoc_hif_tx_sg(struct ath10k *ar, u8 pipe_id,\n\t\t\t\t struct ath10k_hif_sg_item *items, int n_items)\n{\n\tstruct ath10k_snoc *ar_snoc = ath10k_snoc_priv(ar);\n\tstruct ath10k_ce *ce = ath10k_ce_priv(ar);\n\tstruct ath10k_snoc_pipe *snoc_pipe;\n\tstruct ath10k_ce_pipe *ce_pipe;\n\tint err, i = 0;\n\n\tsnoc_pipe = &ar_snoc->pipe_info[pipe_id];\n\tce_pipe = snoc_pipe->ce_hdl;\n\tspin_lock_bh(&ce->ce_lock);\n\n\tfor (i = 0; i < n_items - 1; i++) {\n\t\tath10k_dbg(ar, ATH10K_DBG_SNOC,\n\t\t\t   \"snoc tx item %d paddr %pad len %d n_items %d\\n\",\n\t\t\t   i, &items[i].paddr, items[i].len, n_items);\n\n\t\terr = ath10k_ce_send_nolock(ce_pipe,\n\t\t\t\t\t    items[i].transfer_context,\n\t\t\t\t\t    items[i].paddr,\n\t\t\t\t\t    items[i].len,\n\t\t\t\t\t    items[i].transfer_id,\n\t\t\t\t\t    CE_SEND_FLAG_GATHER);\n\t\tif (err)\n\t\t\tgoto err;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_SNOC,\n\t\t   \"snoc tx item %d paddr %pad len %d n_items %d\\n\",\n\t\t   i, &items[i].paddr, items[i].len, n_items);\n\n\terr = ath10k_ce_send_nolock(ce_pipe,\n\t\t\t\t    items[i].transfer_context,\n\t\t\t\t    items[i].paddr,\n\t\t\t\t    items[i].len,\n\t\t\t\t    items[i].transfer_id,\n\t\t\t\t    0);\n\tif (err)\n\t\tgoto err;\n\n\tspin_unlock_bh(&ce->ce_lock);\n\n\treturn 0;\n\nerr:\n\tfor (; i > 0; i--)\n\t\t__ath10k_ce_send_revert(ce_pipe);\n\n\tspin_unlock_bh(&ce->ce_lock);\n\treturn err;\n}\n\nstatic int ath10k_snoc_hif_get_target_info(struct ath10k *ar,\n\t\t\t\t\t   struct bmi_target_info *target_info)\n{\n\ttarget_info->version = ATH10K_HW_WCN3990;\n\ttarget_info->type = ATH10K_HW_WCN3990;\n\n\treturn 0;\n}\n\nstatic u16 ath10k_snoc_hif_get_free_queue_number(struct ath10k *ar, u8 pipe)\n{\n\tstruct ath10k_snoc *ar_snoc = ath10k_snoc_priv(ar);\n\n\tath10k_dbg(ar, ATH10K_DBG_SNOC, \"hif get free queue number\\n\");\n\n\treturn ath10k_ce_num_free_src_entries(ar_snoc->pipe_info[pipe].ce_hdl);\n}\n\nstatic void ath10k_snoc_hif_send_complete_check(struct ath10k *ar, u8 pipe,\n\t\t\t\t\t\tint force)\n{\n\tint resources;\n\n\tath10k_dbg(ar, ATH10K_DBG_SNOC, \"snoc hif send complete check\\n\");\n\n\tif (!force) {\n\t\tresources = ath10k_snoc_hif_get_free_queue_number(ar, pipe);\n\n\t\tif (resources > (host_ce_config_wlan[pipe].src_nentries >> 1))\n\t\t\treturn;\n\t}\n\tath10k_ce_per_engine_service(ar, pipe);\n}\n\nstatic int ath10k_snoc_hif_map_service_to_pipe(struct ath10k *ar,\n\t\t\t\t\t       u16 service_id,\n\t\t\t\t\t       u8 *ul_pipe, u8 *dl_pipe)\n{\n\tconst struct ce_service_to_pipe *entry;\n\tbool ul_set = false, dl_set = false;\n\tint i;\n\n\tath10k_dbg(ar, ATH10K_DBG_SNOC, \"snoc hif map service\\n\");\n\n\tfor (i = 0; i < ARRAY_SIZE(target_service_to_ce_map_wlan); i++) {\n\t\tentry = &target_service_to_ce_map_wlan[i];\n\n\t\tif (__le32_to_cpu(entry->service_id) != service_id)\n\t\t\tcontinue;\n\n\t\tswitch (__le32_to_cpu(entry->pipedir)) {\n\t\tcase PIPEDIR_NONE:\n\t\t\tbreak;\n\t\tcase PIPEDIR_IN:\n\t\t\tWARN_ON(dl_set);\n\t\t\t*dl_pipe = __le32_to_cpu(entry->pipenum);\n\t\t\tdl_set = true;\n\t\t\tbreak;\n\t\tcase PIPEDIR_OUT:\n\t\t\tWARN_ON(ul_set);\n\t\t\t*ul_pipe = __le32_to_cpu(entry->pipenum);\n\t\t\tul_set = true;\n\t\t\tbreak;\n\t\tcase PIPEDIR_INOUT:\n\t\t\tWARN_ON(dl_set);\n\t\t\tWARN_ON(ul_set);\n\t\t\t*dl_pipe = __le32_to_cpu(entry->pipenum);\n\t\t\t*ul_pipe = __le32_to_cpu(entry->pipenum);\n\t\t\tdl_set = true;\n\t\t\tul_set = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!ul_set || !dl_set)\n\t\treturn -ENOENT;\n\n\treturn 0;\n}\n\nstatic void ath10k_snoc_hif_get_default_pipe(struct ath10k *ar,\n\t\t\t\t\t     u8 *ul_pipe, u8 *dl_pipe)\n{\n\tath10k_dbg(ar, ATH10K_DBG_SNOC, \"snoc hif get default pipe\\n\");\n\n\t(void)ath10k_snoc_hif_map_service_to_pipe(ar,\n\t\t\t\t\t\t ATH10K_HTC_SVC_ID_RSVD_CTRL,\n\t\t\t\t\t\t ul_pipe, dl_pipe);\n}\n\nstatic inline void ath10k_snoc_irq_disable(struct ath10k *ar)\n{\n\tstruct ath10k_snoc *ar_snoc = ath10k_snoc_priv(ar);\n\tint id;\n\n\tfor (id = 0; id < CE_COUNT_MAX; id++)\n\t\tdisable_irq(ar_snoc->ce_irqs[id].irq_line);\n}\n\nstatic inline void ath10k_snoc_irq_enable(struct ath10k *ar)\n{\n\tstruct ath10k_snoc *ar_snoc = ath10k_snoc_priv(ar);\n\tint id;\n\n\tfor (id = 0; id < CE_COUNT_MAX; id++)\n\t\tenable_irq(ar_snoc->ce_irqs[id].irq_line);\n}\n\nstatic void ath10k_snoc_rx_pipe_cleanup(struct ath10k_snoc_pipe *snoc_pipe)\n{\n\tstruct ath10k_ce_pipe *ce_pipe;\n\tstruct ath10k_ce_ring *ce_ring;\n\tstruct sk_buff *skb;\n\tstruct ath10k *ar;\n\tint i;\n\n\tar = snoc_pipe->hif_ce_state;\n\tce_pipe = snoc_pipe->ce_hdl;\n\tce_ring = ce_pipe->dest_ring;\n\n\tif (!ce_ring)\n\t\treturn;\n\n\tif (!snoc_pipe->buf_sz)\n\t\treturn;\n\n\tfor (i = 0; i < ce_ring->nentries; i++) {\n\t\tskb = ce_ring->per_transfer_context[i];\n\t\tif (!skb)\n\t\t\tcontinue;\n\n\t\tce_ring->per_transfer_context[i] = NULL;\n\n\t\tdma_unmap_single(ar->dev, ATH10K_SKB_RXCB(skb)->paddr,\n\t\t\t\t skb->len + skb_tailroom(skb),\n\t\t\t\t DMA_FROM_DEVICE);\n\t\tdev_kfree_skb_any(skb);\n\t}\n}\n\nstatic void ath10k_snoc_tx_pipe_cleanup(struct ath10k_snoc_pipe *snoc_pipe)\n{\n\tstruct ath10k_ce_pipe *ce_pipe;\n\tstruct ath10k_ce_ring *ce_ring;\n\tstruct sk_buff *skb;\n\tstruct ath10k *ar;\n\tint i;\n\n\tar = snoc_pipe->hif_ce_state;\n\tce_pipe = snoc_pipe->ce_hdl;\n\tce_ring = ce_pipe->src_ring;\n\n\tif (!ce_ring)\n\t\treturn;\n\n\tif (!snoc_pipe->buf_sz)\n\t\treturn;\n\n\tfor (i = 0; i < ce_ring->nentries; i++) {\n\t\tskb = ce_ring->per_transfer_context[i];\n\t\tif (!skb)\n\t\t\tcontinue;\n\n\t\tce_ring->per_transfer_context[i] = NULL;\n\n\t\tath10k_htc_tx_completion_handler(ar, skb);\n\t}\n}\n\nstatic void ath10k_snoc_buffer_cleanup(struct ath10k *ar)\n{\n\tstruct ath10k_snoc *ar_snoc = ath10k_snoc_priv(ar);\n\tstruct ath10k_snoc_pipe *pipe_info;\n\tint pipe_num;\n\n\tdel_timer_sync(&ar_snoc->rx_post_retry);\n\tfor (pipe_num = 0; pipe_num < CE_COUNT; pipe_num++) {\n\t\tpipe_info = &ar_snoc->pipe_info[pipe_num];\n\t\tath10k_snoc_rx_pipe_cleanup(pipe_info);\n\t\tath10k_snoc_tx_pipe_cleanup(pipe_info);\n\t}\n}\n\nstatic void ath10k_snoc_hif_stop(struct ath10k *ar)\n{\n\tif (!test_bit(ATH10K_FLAG_CRASH_FLUSH, &ar->dev_flags))\n\t\tath10k_snoc_irq_disable(ar);\n\n\tath10k_core_napi_sync_disable(ar);\n\tath10k_snoc_buffer_cleanup(ar);\n\tath10k_dbg(ar, ATH10K_DBG_BOOT, \"boot hif stop\\n\");\n}\n\nstatic int ath10k_snoc_hif_start(struct ath10k *ar)\n{\n\tstruct ath10k_snoc *ar_snoc = ath10k_snoc_priv(ar);\n\n\tbitmap_clear(ar_snoc->pending_ce_irqs, 0, CE_COUNT_MAX);\n\n\tdev_set_threaded(&ar->napi_dev, true);\n\tath10k_core_napi_enable(ar);\n\tath10k_snoc_irq_enable(ar);\n\tath10k_snoc_rx_post(ar);\n\n\tclear_bit(ATH10K_SNOC_FLAG_RECOVERY, &ar_snoc->flags);\n\n\tath10k_dbg(ar, ATH10K_DBG_BOOT, \"boot hif start\\n\");\n\n\treturn 0;\n}\n\nstatic int ath10k_snoc_init_pipes(struct ath10k *ar)\n{\n\tint i, ret;\n\n\tfor (i = 0; i < CE_COUNT; i++) {\n\t\tret = ath10k_ce_init_pipe(ar, i, &host_ce_config_wlan[i]);\n\t\tif (ret) {\n\t\t\tath10k_err(ar, \"failed to initialize copy engine pipe %d: %d\\n\",\n\t\t\t\t   i, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_snoc_wlan_enable(struct ath10k *ar,\n\t\t\t\t   enum ath10k_firmware_mode fw_mode)\n{\n\tstruct ath10k_tgt_pipe_cfg tgt_cfg[CE_COUNT_MAX];\n\tstruct ath10k_qmi_wlan_enable_cfg cfg;\n\tenum wlfw_driver_mode_enum_v01 mode;\n\tint pipe_num;\n\n\tfor (pipe_num = 0; pipe_num < CE_COUNT_MAX; pipe_num++) {\n\t\ttgt_cfg[pipe_num].pipe_num =\n\t\t\t\ttarget_ce_config_wlan[pipe_num].pipenum;\n\t\ttgt_cfg[pipe_num].pipe_dir =\n\t\t\t\ttarget_ce_config_wlan[pipe_num].pipedir;\n\t\ttgt_cfg[pipe_num].nentries =\n\t\t\t\ttarget_ce_config_wlan[pipe_num].nentries;\n\t\ttgt_cfg[pipe_num].nbytes_max =\n\t\t\t\ttarget_ce_config_wlan[pipe_num].nbytes_max;\n\t\ttgt_cfg[pipe_num].flags =\n\t\t\t\ttarget_ce_config_wlan[pipe_num].flags;\n\t\ttgt_cfg[pipe_num].reserved = 0;\n\t}\n\n\tcfg.num_ce_tgt_cfg = sizeof(target_ce_config_wlan) /\n\t\t\t\tsizeof(struct ath10k_tgt_pipe_cfg);\n\tcfg.ce_tgt_cfg = (struct ath10k_tgt_pipe_cfg *)\n\t\t&tgt_cfg;\n\tcfg.num_ce_svc_pipe_cfg = sizeof(target_service_to_ce_map_wlan) /\n\t\t\t\t  sizeof(struct ath10k_svc_pipe_cfg);\n\tcfg.ce_svc_cfg = (struct ath10k_svc_pipe_cfg *)\n\t\t&target_service_to_ce_map_wlan;\n\tcfg.num_shadow_reg_cfg = ARRAY_SIZE(target_shadow_reg_cfg_map);\n\tcfg.shadow_reg_cfg = (struct ath10k_shadow_reg_cfg *)\n\t\t&target_shadow_reg_cfg_map;\n\n\tswitch (fw_mode) {\n\tcase ATH10K_FIRMWARE_MODE_NORMAL:\n\t\tmode = QMI_WLFW_MISSION_V01;\n\t\tbreak;\n\tcase ATH10K_FIRMWARE_MODE_UTF:\n\t\tmode = QMI_WLFW_FTM_V01;\n\t\tbreak;\n\tdefault:\n\t\tath10k_err(ar, \"invalid firmware mode %d\\n\", fw_mode);\n\t\treturn -EINVAL;\n\t}\n\n\treturn ath10k_qmi_wlan_enable(ar, &cfg, mode,\n\t\t\t\t       NULL);\n}\n\nstatic int ath10k_hw_power_on(struct ath10k *ar)\n{\n\tstruct ath10k_snoc *ar_snoc = ath10k_snoc_priv(ar);\n\tint ret;\n\n\tath10k_dbg(ar, ATH10K_DBG_SNOC, \"soc power on\\n\");\n\n\tret = regulator_bulk_enable(ar_snoc->num_vregs, ar_snoc->vregs);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_bulk_prepare_enable(ar_snoc->num_clks, ar_snoc->clks);\n\tif (ret)\n\t\tgoto vreg_off;\n\n\treturn ret;\n\nvreg_off:\n\tregulator_bulk_disable(ar_snoc->num_vregs, ar_snoc->vregs);\n\treturn ret;\n}\n\nstatic int ath10k_hw_power_off(struct ath10k *ar)\n{\n\tstruct ath10k_snoc *ar_snoc = ath10k_snoc_priv(ar);\n\n\tath10k_dbg(ar, ATH10K_DBG_SNOC, \"soc power off\\n\");\n\n\tclk_bulk_disable_unprepare(ar_snoc->num_clks, ar_snoc->clks);\n\n\treturn regulator_bulk_disable(ar_snoc->num_vregs, ar_snoc->vregs);\n}\n\nstatic void ath10k_snoc_wlan_disable(struct ath10k *ar)\n{\n\tstruct ath10k_snoc *ar_snoc = ath10k_snoc_priv(ar);\n\n\t \n\tif (!test_bit(ATH10K_FLAG_CRASH_FLUSH, &ar->dev_flags) ||\n\t    !test_bit(ATH10K_SNOC_FLAG_RECOVERY, &ar_snoc->flags))\n\t\tath10k_qmi_wlan_disable(ar);\n}\n\nstatic void ath10k_snoc_hif_power_down(struct ath10k *ar)\n{\n\tath10k_dbg(ar, ATH10K_DBG_BOOT, \"boot hif power down\\n\");\n\n\tath10k_snoc_wlan_disable(ar);\n\tath10k_ce_free_rri(ar);\n\tath10k_hw_power_off(ar);\n}\n\nstatic int ath10k_snoc_hif_power_up(struct ath10k *ar,\n\t\t\t\t    enum ath10k_firmware_mode fw_mode)\n{\n\tint ret;\n\n\tath10k_dbg(ar, ATH10K_DBG_SNOC, \"%s:WCN3990 driver state = %d\\n\",\n\t\t   __func__, ar->state);\n\n\tret = ath10k_hw_power_on(ar);\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to power on device: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ath10k_snoc_wlan_enable(ar, fw_mode);\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to enable wcn3990: %d\\n\", ret);\n\t\tgoto err_hw_power_off;\n\t}\n\n\tath10k_ce_alloc_rri(ar);\n\n\tret = ath10k_snoc_init_pipes(ar);\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to initialize CE: %d\\n\", ret);\n\t\tgoto err_free_rri;\n\t}\n\n\tath10k_ce_enable_interrupts(ar);\n\n\treturn 0;\n\nerr_free_rri:\n\tath10k_ce_free_rri(ar);\n\tath10k_snoc_wlan_disable(ar);\n\nerr_hw_power_off:\n\tath10k_hw_power_off(ar);\n\n\treturn ret;\n}\n\nstatic int ath10k_snoc_hif_set_target_log_mode(struct ath10k *ar,\n\t\t\t\t\t       u8 fw_log_mode)\n{\n\tu8 fw_dbg_mode;\n\n\tif (fw_log_mode)\n\t\tfw_dbg_mode = ATH10K_ENABLE_FW_LOG_CE;\n\telse\n\t\tfw_dbg_mode = ATH10K_ENABLE_FW_LOG_DIAG;\n\n\treturn ath10k_qmi_set_fw_log_mode(ar, fw_dbg_mode);\n}\n\n#ifdef CONFIG_PM\nstatic int ath10k_snoc_hif_suspend(struct ath10k *ar)\n{\n\tstruct ath10k_snoc *ar_snoc = ath10k_snoc_priv(ar);\n\tint ret;\n\n\tif (!device_may_wakeup(ar->dev))\n\t\treturn -EPERM;\n\n\tret = enable_irq_wake(ar_snoc->ce_irqs[ATH10K_SNOC_WAKE_IRQ].irq_line);\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to enable wakeup irq :%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_SNOC, \"snoc device suspended\\n\");\n\n\treturn ret;\n}\n\nstatic int ath10k_snoc_hif_resume(struct ath10k *ar)\n{\n\tstruct ath10k_snoc *ar_snoc = ath10k_snoc_priv(ar);\n\tint ret;\n\n\tif (!device_may_wakeup(ar->dev))\n\t\treturn -EPERM;\n\n\tret = disable_irq_wake(ar_snoc->ce_irqs[ATH10K_SNOC_WAKE_IRQ].irq_line);\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to disable wakeup irq: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_SNOC, \"snoc device resumed\\n\");\n\n\treturn ret;\n}\n#endif\n\nstatic const struct ath10k_hif_ops ath10k_snoc_hif_ops = {\n\t.read32\t\t= ath10k_snoc_read32,\n\t.write32\t= ath10k_snoc_write32,\n\t.start\t\t= ath10k_snoc_hif_start,\n\t.stop\t\t= ath10k_snoc_hif_stop,\n\t.map_service_to_pipe\t= ath10k_snoc_hif_map_service_to_pipe,\n\t.get_default_pipe\t= ath10k_snoc_hif_get_default_pipe,\n\t.power_up\t\t= ath10k_snoc_hif_power_up,\n\t.power_down\t\t= ath10k_snoc_hif_power_down,\n\t.tx_sg\t\t\t= ath10k_snoc_hif_tx_sg,\n\t.send_complete_check\t= ath10k_snoc_hif_send_complete_check,\n\t.get_free_queue_number\t= ath10k_snoc_hif_get_free_queue_number,\n\t.get_target_info\t= ath10k_snoc_hif_get_target_info,\n\t.set_target_log_mode    = ath10k_snoc_hif_set_target_log_mode,\n\n#ifdef CONFIG_PM\n\t.suspend                = ath10k_snoc_hif_suspend,\n\t.resume                 = ath10k_snoc_hif_resume,\n#endif\n};\n\nstatic const struct ath10k_bus_ops ath10k_snoc_bus_ops = {\n\t.read32\t\t= ath10k_snoc_read32,\n\t.write32\t= ath10k_snoc_write32,\n};\n\nstatic int ath10k_snoc_get_ce_id_from_irq(struct ath10k *ar, int irq)\n{\n\tstruct ath10k_snoc *ar_snoc = ath10k_snoc_priv(ar);\n\tint i;\n\n\tfor (i = 0; i < CE_COUNT_MAX; i++) {\n\t\tif (ar_snoc->ce_irqs[i].irq_line == irq)\n\t\t\treturn i;\n\t}\n\tath10k_err(ar, \"No matching CE id for irq %d\\n\", irq);\n\n\treturn -EINVAL;\n}\n\nstatic irqreturn_t ath10k_snoc_per_engine_handler(int irq, void *arg)\n{\n\tstruct ath10k *ar = arg;\n\tstruct ath10k_snoc *ar_snoc = ath10k_snoc_priv(ar);\n\tint ce_id = ath10k_snoc_get_ce_id_from_irq(ar, irq);\n\n\tif (ce_id < 0 || ce_id >= ARRAY_SIZE(ar_snoc->pipe_info)) {\n\t\tath10k_warn(ar, \"unexpected/invalid irq %d ce_id %d\\n\", irq,\n\t\t\t    ce_id);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tath10k_ce_disable_interrupt(ar, ce_id);\n\tset_bit(ce_id, ar_snoc->pending_ce_irqs);\n\n\tnapi_schedule(&ar->napi);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ath10k_snoc_napi_poll(struct napi_struct *ctx, int budget)\n{\n\tstruct ath10k *ar = container_of(ctx, struct ath10k, napi);\n\tstruct ath10k_snoc *ar_snoc = ath10k_snoc_priv(ar);\n\tint done = 0;\n\tint ce_id;\n\n\tif (test_bit(ATH10K_FLAG_CRASH_FLUSH, &ar->dev_flags)) {\n\t\tnapi_complete(ctx);\n\t\treturn done;\n\t}\n\n\tfor (ce_id = 0; ce_id < CE_COUNT; ce_id++)\n\t\tif (test_and_clear_bit(ce_id, ar_snoc->pending_ce_irqs)) {\n\t\t\tath10k_ce_per_engine_service(ar, ce_id);\n\t\t\tath10k_ce_enable_interrupt(ar, ce_id);\n\t\t}\n\n\tdone = ath10k_htt_txrx_compl_task(ar, budget);\n\n\tif (done < budget)\n\t\tnapi_complete(ctx);\n\n\treturn done;\n}\n\nstatic void ath10k_snoc_init_napi(struct ath10k *ar)\n{\n\tnetif_napi_add(&ar->napi_dev, &ar->napi, ath10k_snoc_napi_poll);\n}\n\nstatic int ath10k_snoc_request_irq(struct ath10k *ar)\n{\n\tstruct ath10k_snoc *ar_snoc = ath10k_snoc_priv(ar);\n\tint ret, id;\n\n\tfor (id = 0; id < CE_COUNT_MAX; id++) {\n\t\tret = request_irq(ar_snoc->ce_irqs[id].irq_line,\n\t\t\t\t  ath10k_snoc_per_engine_handler,\n\t\t\t\t  IRQF_NO_AUTOEN, ce_name[id], ar);\n\t\tif (ret) {\n\t\t\tath10k_err(ar,\n\t\t\t\t   \"failed to register IRQ handler for CE %d: %d\\n\",\n\t\t\t\t   id, ret);\n\t\t\tgoto err_irq;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_irq:\n\tfor (id -= 1; id >= 0; id--)\n\t\tfree_irq(ar_snoc->ce_irqs[id].irq_line, ar);\n\n\treturn ret;\n}\n\nstatic void ath10k_snoc_free_irq(struct ath10k *ar)\n{\n\tstruct ath10k_snoc *ar_snoc = ath10k_snoc_priv(ar);\n\tint id;\n\n\tfor (id = 0; id < CE_COUNT_MAX; id++)\n\t\tfree_irq(ar_snoc->ce_irqs[id].irq_line, ar);\n}\n\nstatic int ath10k_snoc_resource_init(struct ath10k *ar)\n{\n\tstruct ath10k_snoc *ar_snoc = ath10k_snoc_priv(ar);\n\tstruct platform_device *pdev;\n\tstruct resource *res;\n\tint i, ret = 0;\n\n\tpdev = ar_snoc->dev;\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"membase\");\n\tif (!res) {\n\t\tath10k_err(ar, \"Memory base not found in DT\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tar_snoc->mem_pa = res->start;\n\tar_snoc->mem = devm_ioremap(&pdev->dev, ar_snoc->mem_pa,\n\t\t\t\t    resource_size(res));\n\tif (!ar_snoc->mem) {\n\t\tath10k_err(ar, \"Memory base ioremap failed with physical address %pa\\n\",\n\t\t\t   &ar_snoc->mem_pa);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < CE_COUNT; i++) {\n\t\tret = platform_get_irq(ar_snoc->dev, i);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tar_snoc->ce_irqs[i].irq_line = ret;\n\t}\n\n\tret = device_property_read_u32(&pdev->dev, \"qcom,xo-cal-data\",\n\t\t\t\t       &ar_snoc->xo_cal_data);\n\tath10k_dbg(ar, ATH10K_DBG_SNOC, \"snoc xo-cal-data return %d\\n\", ret);\n\tif (ret == 0) {\n\t\tar_snoc->xo_cal_supported = true;\n\t\tath10k_dbg(ar, ATH10K_DBG_SNOC, \"xo cal data %x\\n\",\n\t\t\t   ar_snoc->xo_cal_data);\n\t}\n\n\treturn 0;\n}\n\nstatic void ath10k_snoc_quirks_init(struct ath10k *ar)\n{\n\tstruct ath10k_snoc *ar_snoc = ath10k_snoc_priv(ar);\n\tstruct device *dev = &ar_snoc->dev->dev;\n\n\tif (of_property_read_bool(dev->of_node, \"qcom,snoc-host-cap-8bit-quirk\"))\n\t\tset_bit(ATH10K_SNOC_FLAG_8BIT_HOST_CAP_QUIRK, &ar_snoc->flags);\n}\n\nint ath10k_snoc_fw_indication(struct ath10k *ar, u64 type)\n{\n\tstruct ath10k_snoc *ar_snoc = ath10k_snoc_priv(ar);\n\tstruct ath10k_bus_params bus_params = {};\n\tint ret;\n\n\tif (test_bit(ATH10K_SNOC_FLAG_UNREGISTERING, &ar_snoc->flags))\n\t\treturn 0;\n\n\tswitch (type) {\n\tcase ATH10K_QMI_EVENT_FW_READY_IND:\n\t\tif (test_bit(ATH10K_SNOC_FLAG_REGISTERED, &ar_snoc->flags)) {\n\t\t\tath10k_core_start_recovery(ar);\n\t\t\tbreak;\n\t\t}\n\n\t\tbus_params.dev_type = ATH10K_DEV_TYPE_LL;\n\t\tbus_params.chip_id = ar_snoc->target_info.soc_version;\n\t\tret = ath10k_core_register(ar, &bus_params);\n\t\tif (ret) {\n\t\t\tath10k_err(ar, \"Failed to register driver core: %d\\n\",\n\t\t\t\t   ret);\n\t\t\treturn ret;\n\t\t}\n\t\tset_bit(ATH10K_SNOC_FLAG_REGISTERED, &ar_snoc->flags);\n\t\tbreak;\n\tcase ATH10K_QMI_EVENT_FW_DOWN_IND:\n\t\tset_bit(ATH10K_SNOC_FLAG_RECOVERY, &ar_snoc->flags);\n\t\tset_bit(ATH10K_FLAG_CRASH_FLUSH, &ar->dev_flags);\n\t\tbreak;\n\tdefault:\n\t\tath10k_err(ar, \"invalid fw indication: %llx\\n\", type);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath10k_snoc_setup_resource(struct ath10k *ar)\n{\n\tstruct ath10k_snoc *ar_snoc = ath10k_snoc_priv(ar);\n\tstruct ath10k_ce *ce = ath10k_ce_priv(ar);\n\tstruct ath10k_snoc_pipe *pipe;\n\tint i, ret;\n\n\ttimer_setup(&ar_snoc->rx_post_retry, ath10k_snoc_rx_replenish_retry, 0);\n\tspin_lock_init(&ce->ce_lock);\n\tfor (i = 0; i < CE_COUNT; i++) {\n\t\tpipe = &ar_snoc->pipe_info[i];\n\t\tpipe->ce_hdl = &ce->ce_states[i];\n\t\tpipe->pipe_num = i;\n\t\tpipe->hif_ce_state = ar;\n\n\t\tret = ath10k_ce_alloc_pipe(ar, i, &host_ce_config_wlan[i]);\n\t\tif (ret) {\n\t\t\tath10k_err(ar, \"failed to allocate copy engine pipe %d: %d\\n\",\n\t\t\t\t   i, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpipe->buf_sz = host_ce_config_wlan[i].src_sz_max;\n\t}\n\tath10k_snoc_init_napi(ar);\n\n\treturn 0;\n}\n\nstatic void ath10k_snoc_release_resource(struct ath10k *ar)\n{\n\tint i;\n\n\tnetif_napi_del(&ar->napi);\n\tfor (i = 0; i < CE_COUNT; i++)\n\t\tath10k_ce_free_pipe(ar, i);\n}\n\nstatic void ath10k_msa_dump_memory(struct ath10k *ar,\n\t\t\t\t   struct ath10k_fw_crash_data *crash_data)\n{\n\tconst struct ath10k_hw_mem_layout *mem_layout;\n\tconst struct ath10k_mem_region *current_region;\n\tstruct ath10k_dump_ram_data_hdr *hdr;\n\tsize_t buf_len;\n\tu8 *buf;\n\n\tif (!crash_data || !crash_data->ramdump_buf)\n\t\treturn;\n\n\tmem_layout = ath10k_coredump_get_mem_layout(ar);\n\tif (!mem_layout)\n\t\treturn;\n\n\tcurrent_region = &mem_layout->region_table.regions[0];\n\n\tbuf = crash_data->ramdump_buf;\n\tbuf_len = crash_data->ramdump_buf_len;\n\tmemset(buf, 0, buf_len);\n\n\t \n\thdr = (void *)buf;\n\tbuf += sizeof(*hdr);\n\tbuf_len -= sizeof(*hdr);\n\n\thdr->region_type = cpu_to_le32(current_region->type);\n\thdr->start = cpu_to_le32((unsigned long)ar->msa.vaddr);\n\thdr->length = cpu_to_le32(ar->msa.mem_size);\n\n\tif (current_region->len < ar->msa.mem_size) {\n\t\tmemcpy(buf, ar->msa.vaddr, current_region->len);\n\t\tath10k_warn(ar, \"msa dump length is less than msa size %x, %x\\n\",\n\t\t\t    current_region->len, ar->msa.mem_size);\n\t} else {\n\t\tmemcpy(buf, ar->msa.vaddr, ar->msa.mem_size);\n\t}\n}\n\nvoid ath10k_snoc_fw_crashed_dump(struct ath10k *ar)\n{\n\tstruct ath10k_fw_crash_data *crash_data;\n\tchar guid[UUID_STRING_LEN + 1];\n\n\tmutex_lock(&ar->dump_mutex);\n\n\tspin_lock_bh(&ar->data_lock);\n\tar->stats.fw_crash_counter++;\n\tspin_unlock_bh(&ar->data_lock);\n\n\tcrash_data = ath10k_coredump_new(ar);\n\n\tif (crash_data)\n\t\tscnprintf(guid, sizeof(guid), \"%pUl\", &crash_data->guid);\n\telse\n\t\tscnprintf(guid, sizeof(guid), \"n/a\");\n\n\tath10k_err(ar, \"firmware crashed! (guid %s)\\n\", guid);\n\tath10k_print_driver_info(ar);\n\tath10k_msa_dump_memory(ar, crash_data);\n\tmutex_unlock(&ar->dump_mutex);\n}\n\nstatic int ath10k_snoc_modem_notify(struct notifier_block *nb, unsigned long action,\n\t\t\t\t    void *data)\n{\n\tstruct ath10k_snoc *ar_snoc = container_of(nb, struct ath10k_snoc, nb);\n\tstruct ath10k *ar = ar_snoc->ar;\n\tstruct qcom_ssr_notify_data *notify_data = data;\n\n\tswitch (action) {\n\tcase QCOM_SSR_BEFORE_POWERUP:\n\t\tath10k_dbg(ar, ATH10K_DBG_SNOC, \"received modem starting event\\n\");\n\t\tclear_bit(ATH10K_SNOC_FLAG_MODEM_STOPPED, &ar_snoc->flags);\n\t\tbreak;\n\n\tcase QCOM_SSR_AFTER_POWERUP:\n\t\tath10k_dbg(ar, ATH10K_DBG_SNOC, \"received modem running event\\n\");\n\t\tbreak;\n\n\tcase QCOM_SSR_BEFORE_SHUTDOWN:\n\t\tath10k_dbg(ar, ATH10K_DBG_SNOC, \"received modem %s event\\n\",\n\t\t\t   notify_data->crashed ? \"crashed\" : \"stopping\");\n\t\tif (!notify_data->crashed)\n\t\t\tset_bit(ATH10K_SNOC_FLAG_MODEM_STOPPED, &ar_snoc->flags);\n\t\telse\n\t\t\tclear_bit(ATH10K_SNOC_FLAG_MODEM_STOPPED, &ar_snoc->flags);\n\t\tbreak;\n\n\tcase QCOM_SSR_AFTER_SHUTDOWN:\n\t\tath10k_dbg(ar, ATH10K_DBG_SNOC, \"received modem offline event\\n\");\n\t\tbreak;\n\n\tdefault:\n\t\tath10k_err(ar, \"received unrecognized event %lu\\n\", action);\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_OK;\n}\n\nstatic int ath10k_modem_init(struct ath10k *ar)\n{\n\tstruct ath10k_snoc *ar_snoc = ath10k_snoc_priv(ar);\n\tvoid *notifier;\n\tint ret;\n\n\tar_snoc->nb.notifier_call = ath10k_snoc_modem_notify;\n\n\tnotifier = qcom_register_ssr_notifier(\"mpss\", &ar_snoc->nb);\n\tif (IS_ERR(notifier)) {\n\t\tret = PTR_ERR(notifier);\n\t\tath10k_err(ar, \"failed to initialize modem notifier: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tar_snoc->notifier = notifier;\n\n\treturn 0;\n}\n\nstatic void ath10k_modem_deinit(struct ath10k *ar)\n{\n\tint ret;\n\tstruct ath10k_snoc *ar_snoc = ath10k_snoc_priv(ar);\n\n\tret = qcom_unregister_ssr_notifier(ar_snoc->notifier, &ar_snoc->nb);\n\tif (ret)\n\t\tath10k_err(ar, \"error %d unregistering notifier\\n\", ret);\n}\n\nstatic int ath10k_setup_msa_resources(struct ath10k *ar, u32 msa_size)\n{\n\tstruct device *dev = ar->dev;\n\tstruct device_node *node;\n\tstruct resource r;\n\tint ret;\n\n\tnode = of_parse_phandle(dev->of_node, \"memory-region\", 0);\n\tif (node) {\n\t\tret = of_address_to_resource(node, 0, &r);\n\t\tof_node_put(node);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to resolve msa fixed region\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tar->msa.paddr = r.start;\n\t\tar->msa.mem_size = resource_size(&r);\n\t\tar->msa.vaddr = devm_memremap(dev, ar->msa.paddr,\n\t\t\t\t\t      ar->msa.mem_size,\n\t\t\t\t\t      MEMREMAP_WT);\n\t\tif (IS_ERR(ar->msa.vaddr)) {\n\t\t\tdev_err(dev, \"failed to map memory region: %pa\\n\",\n\t\t\t\t&r.start);\n\t\t\treturn PTR_ERR(ar->msa.vaddr);\n\t\t}\n\t} else {\n\t\tar->msa.vaddr = dmam_alloc_coherent(dev, msa_size,\n\t\t\t\t\t\t    &ar->msa.paddr,\n\t\t\t\t\t\t    GFP_KERNEL);\n\t\tif (!ar->msa.vaddr) {\n\t\t\tath10k_err(ar, \"failed to allocate dma memory for msa region\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tar->msa.mem_size = msa_size;\n\t}\n\n\tath10k_dbg(ar, ATH10K_DBG_QMI, \"qmi msa.paddr: %pad , msa.vaddr: 0x%p\\n\",\n\t\t   &ar->msa.paddr,\n\t\t   ar->msa.vaddr);\n\n\treturn 0;\n}\n\nstatic int ath10k_fw_init(struct ath10k *ar)\n{\n\tstruct ath10k_snoc *ar_snoc = ath10k_snoc_priv(ar);\n\tstruct device *host_dev = &ar_snoc->dev->dev;\n\tstruct platform_device_info info;\n\tstruct iommu_domain *iommu_dom;\n\tstruct platform_device *pdev;\n\tstruct device_node *node;\n\tint ret;\n\n\tnode = of_get_child_by_name(host_dev->of_node, \"wifi-firmware\");\n\tif (!node) {\n\t\tar_snoc->use_tz = true;\n\t\treturn 0;\n\t}\n\n\tmemset(&info, 0, sizeof(info));\n\tinfo.fwnode = &node->fwnode;\n\tinfo.parent = host_dev;\n\tinfo.name = node->name;\n\tinfo.dma_mask = DMA_BIT_MASK(32);\n\n\tpdev = platform_device_register_full(&info);\n\tif (IS_ERR(pdev)) {\n\t\tof_node_put(node);\n\t\treturn PTR_ERR(pdev);\n\t}\n\n\tpdev->dev.of_node = node;\n\n\tret = of_dma_configure(&pdev->dev, node, true);\n\tif (ret) {\n\t\tath10k_err(ar, \"dma configure fail: %d\\n\", ret);\n\t\tgoto err_unregister;\n\t}\n\n\tar_snoc->fw.dev = &pdev->dev;\n\n\tiommu_dom = iommu_domain_alloc(&platform_bus_type);\n\tif (!iommu_dom) {\n\t\tath10k_err(ar, \"failed to allocate iommu domain\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_unregister;\n\t}\n\n\tret = iommu_attach_device(iommu_dom, ar_snoc->fw.dev);\n\tif (ret) {\n\t\tath10k_err(ar, \"could not attach device: %d\\n\", ret);\n\t\tgoto err_iommu_free;\n\t}\n\n\tar_snoc->fw.iommu_domain = iommu_dom;\n\tar_snoc->fw.fw_start_addr = ar->msa.paddr;\n\n\tret = iommu_map(iommu_dom, ar_snoc->fw.fw_start_addr,\n\t\t\tar->msa.paddr, ar->msa.mem_size,\n\t\t\tIOMMU_READ | IOMMU_WRITE, GFP_KERNEL);\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to map firmware region: %d\\n\", ret);\n\t\tgoto err_iommu_detach;\n\t}\n\n\tof_node_put(node);\n\n\treturn 0;\n\nerr_iommu_detach:\n\tiommu_detach_device(iommu_dom, ar_snoc->fw.dev);\n\nerr_iommu_free:\n\tiommu_domain_free(iommu_dom);\n\nerr_unregister:\n\tplatform_device_unregister(pdev);\n\tof_node_put(node);\n\n\treturn ret;\n}\n\nstatic int ath10k_fw_deinit(struct ath10k *ar)\n{\n\tstruct ath10k_snoc *ar_snoc = ath10k_snoc_priv(ar);\n\tconst size_t mapped_size = ar_snoc->fw.mapped_mem_size;\n\tstruct iommu_domain *iommu;\n\tsize_t unmapped_size;\n\n\tif (ar_snoc->use_tz)\n\t\treturn 0;\n\n\tiommu = ar_snoc->fw.iommu_domain;\n\n\tunmapped_size = iommu_unmap(iommu, ar_snoc->fw.fw_start_addr,\n\t\t\t\t    mapped_size);\n\tif (unmapped_size != mapped_size)\n\t\tath10k_err(ar, \"failed to unmap firmware: %zu\\n\",\n\t\t\t   unmapped_size);\n\n\tiommu_detach_device(iommu, ar_snoc->fw.dev);\n\tiommu_domain_free(iommu);\n\n\tplatform_device_unregister(to_platform_device(ar_snoc->fw.dev));\n\n\treturn 0;\n}\n\nstatic const struct of_device_id ath10k_snoc_dt_match[] = {\n\t{ .compatible = \"qcom,wcn3990-wifi\",\n\t .data = &drv_priv,\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ath10k_snoc_dt_match);\n\nstatic int ath10k_snoc_probe(struct platform_device *pdev)\n{\n\tconst struct ath10k_snoc_drv_priv *drv_data;\n\tstruct ath10k_snoc *ar_snoc;\n\tstruct device *dev;\n\tstruct ath10k *ar;\n\tu32 msa_size;\n\tint ret;\n\tu32 i;\n\n\tdev = &pdev->dev;\n\tdrv_data = device_get_match_data(dev);\n\tif (!drv_data) {\n\t\tdev_err(dev, \"failed to find matching device tree id\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = dma_set_mask_and_coherent(dev, drv_data->dma_mask);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to set dma mask: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tar = ath10k_core_create(sizeof(*ar_snoc), dev, ATH10K_BUS_SNOC,\n\t\t\t\tdrv_data->hw_rev, &ath10k_snoc_hif_ops);\n\tif (!ar) {\n\t\tdev_err(dev, \"failed to allocate core\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tar_snoc = ath10k_snoc_priv(ar);\n\tar_snoc->dev = pdev;\n\tplatform_set_drvdata(pdev, ar);\n\tar_snoc->ar = ar;\n\tar_snoc->ce.bus_ops = &ath10k_snoc_bus_ops;\n\tar->ce_priv = &ar_snoc->ce;\n\tmsa_size = drv_data->msa_size;\n\n\tath10k_snoc_quirks_init(ar);\n\n\tret = ath10k_snoc_resource_init(ar);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to initialize resource: %d\\n\", ret);\n\t\tgoto err_core_destroy;\n\t}\n\n\tret = ath10k_snoc_setup_resource(ar);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to setup resource: %d\\n\", ret);\n\t\tgoto err_core_destroy;\n\t}\n\tret = ath10k_snoc_request_irq(ar);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to request irqs: %d\\n\", ret);\n\t\tgoto err_release_resource;\n\t}\n\n\tar_snoc->num_vregs = ARRAY_SIZE(ath10k_regulators);\n\tar_snoc->vregs = devm_kcalloc(&pdev->dev, ar_snoc->num_vregs,\n\t\t\t\t      sizeof(*ar_snoc->vregs), GFP_KERNEL);\n\tif (!ar_snoc->vregs) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_irq;\n\t}\n\tfor (i = 0; i < ar_snoc->num_vregs; i++)\n\t\tar_snoc->vregs[i].supply = ath10k_regulators[i];\n\n\tret = devm_regulator_bulk_get(&pdev->dev, ar_snoc->num_vregs,\n\t\t\t\t      ar_snoc->vregs);\n\tif (ret < 0)\n\t\tgoto err_free_irq;\n\n\tar_snoc->num_clks = ARRAY_SIZE(ath10k_clocks);\n\tar_snoc->clks = devm_kcalloc(&pdev->dev, ar_snoc->num_clks,\n\t\t\t\t     sizeof(*ar_snoc->clks), GFP_KERNEL);\n\tif (!ar_snoc->clks) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free_irq;\n\t}\n\n\tfor (i = 0; i < ar_snoc->num_clks; i++)\n\t\tar_snoc->clks[i].id = ath10k_clocks[i];\n\n\tret = devm_clk_bulk_get_optional(&pdev->dev, ar_snoc->num_clks,\n\t\t\t\t\t ar_snoc->clks);\n\tif (ret)\n\t\tgoto err_free_irq;\n\n\tret = ath10k_setup_msa_resources(ar, msa_size);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to setup msa resources: %d\\n\", ret);\n\t\tgoto err_free_irq;\n\t}\n\n\tret = ath10k_fw_init(ar);\n\tif (ret) {\n\t\tath10k_err(ar, \"failed to initialize firmware: %d\\n\", ret);\n\t\tgoto err_free_irq;\n\t}\n\n\tret = ath10k_qmi_init(ar, msa_size);\n\tif (ret) {\n\t\tath10k_warn(ar, \"failed to register wlfw qmi client: %d\\n\", ret);\n\t\tgoto err_fw_deinit;\n\t}\n\n\tret = ath10k_modem_init(ar);\n\tif (ret)\n\t\tgoto err_qmi_deinit;\n\n\tath10k_dbg(ar, ATH10K_DBG_SNOC, \"snoc probe\\n\");\n\n\treturn 0;\n\nerr_qmi_deinit:\n\tath10k_qmi_deinit(ar);\n\nerr_fw_deinit:\n\tath10k_fw_deinit(ar);\n\nerr_free_irq:\n\tath10k_snoc_free_irq(ar);\n\nerr_release_resource:\n\tath10k_snoc_release_resource(ar);\n\nerr_core_destroy:\n\tath10k_core_destroy(ar);\n\n\treturn ret;\n}\n\nstatic int ath10k_snoc_free_resources(struct ath10k *ar)\n{\n\tstruct ath10k_snoc *ar_snoc = ath10k_snoc_priv(ar);\n\n\tath10k_dbg(ar, ATH10K_DBG_SNOC, \"snoc free resources\\n\");\n\n\tset_bit(ATH10K_SNOC_FLAG_UNREGISTERING, &ar_snoc->flags);\n\n\tath10k_core_unregister(ar);\n\tath10k_fw_deinit(ar);\n\tath10k_snoc_free_irq(ar);\n\tath10k_snoc_release_resource(ar);\n\tath10k_modem_deinit(ar);\n\tath10k_qmi_deinit(ar);\n\tath10k_core_destroy(ar);\n\n\treturn 0;\n}\n\nstatic void ath10k_snoc_remove(struct platform_device *pdev)\n{\n\tstruct ath10k *ar = platform_get_drvdata(pdev);\n\tstruct ath10k_snoc *ar_snoc = ath10k_snoc_priv(ar);\n\n\tath10k_dbg(ar, ATH10K_DBG_SNOC, \"snoc remove\\n\");\n\n\treinit_completion(&ar->driver_recovery);\n\n\tif (test_bit(ATH10K_SNOC_FLAG_RECOVERY, &ar_snoc->flags))\n\t\twait_for_completion_timeout(&ar->driver_recovery, 3 * HZ);\n\n\tath10k_snoc_free_resources(ar);\n}\n\nstatic void ath10k_snoc_shutdown(struct platform_device *pdev)\n{\n\tstruct ath10k *ar = platform_get_drvdata(pdev);\n\n\tath10k_dbg(ar, ATH10K_DBG_SNOC, \"snoc shutdown\\n\");\n\tath10k_snoc_free_resources(ar);\n}\n\nstatic struct platform_driver ath10k_snoc_driver = {\n\t.probe  = ath10k_snoc_probe,\n\t.remove_new = ath10k_snoc_remove,\n\t.shutdown = ath10k_snoc_shutdown,\n\t.driver = {\n\t\t.name   = \"ath10k_snoc\",\n\t\t.of_match_table = ath10k_snoc_dt_match,\n\t},\n};\nmodule_platform_driver(ath10k_snoc_driver);\n\nMODULE_AUTHOR(\"Qualcomm\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_DESCRIPTION(\"Driver support for Atheros WCN3990 SNOC devices\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}