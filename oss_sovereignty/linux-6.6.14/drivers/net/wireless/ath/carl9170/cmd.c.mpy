{
  "module_name": "cmd.c",
  "hash_id": "d4ae13d6b8ed049256314ffe82189134430c1640a32b9c5ffa84ec284368b3ad",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/carl9170/cmd.c",
  "human_readable_source": " \n\n#include <asm/div64.h>\n#include \"carl9170.h\"\n#include \"cmd.h\"\n\nint carl9170_write_reg(struct ar9170 *ar, const u32 reg, const u32 val)\n{\n\tconst __le32 buf[2] = {\n\t\tcpu_to_le32(reg),\n\t\tcpu_to_le32(val),\n\t};\n\tint err;\n\n\terr = carl9170_exec_cmd(ar, CARL9170_CMD_WREG, sizeof(buf),\n\t\t\t\t(u8 *) buf, 0, NULL);\n\tif (err) {\n\t\tif (net_ratelimit()) {\n\t\t\twiphy_err(ar->hw->wiphy, \"writing reg %#x \"\n\t\t\t\t\"(val %#x) failed (%d)\\n\", reg, val, err);\n\t\t}\n\t}\n\treturn err;\n}\n\nint carl9170_read_mreg(struct ar9170 *ar, const int nregs,\n\t\t       const u32 *regs, u32 *out)\n{\n\tint i, err;\n\t__le32 *offs, *res;\n\n\t \n\toffs = (__le32 *)out;\n\tfor (i = 0; i < nregs; i++)\n\t\toffs[i] = cpu_to_le32(regs[i]);\n\n\t \n\tres = (__le32 *)out;\n\n\terr = carl9170_exec_cmd(ar, CARL9170_CMD_RREG,\n\t\t\t\t4 * nregs, (u8 *)offs,\n\t\t\t\t4 * nregs, (u8 *)res);\n\tif (err) {\n\t\tif (net_ratelimit()) {\n\t\t\twiphy_err(ar->hw->wiphy, \"reading regs failed (%d)\\n\",\n\t\t\t\t  err);\n\t\t}\n\t\treturn err;\n\t}\n\n\t \n\tfor (i = 0; i < nregs; i++)\n\t\tout[i] = le32_to_cpu(res[i]);\n\n\treturn 0;\n}\n\nint carl9170_read_reg(struct ar9170 *ar, u32 reg, u32 *val)\n{\n\treturn carl9170_read_mreg(ar, 1, &reg, val);\n}\n\nint carl9170_echo_test(struct ar9170 *ar, const u32 v)\n{\n\tu32 echores;\n\tint err;\n\n\terr = carl9170_exec_cmd(ar, CARL9170_CMD_ECHO,\n\t\t\t\t4, (u8 *)&v,\n\t\t\t\t4, (u8 *)&echores);\n\tif (err)\n\t\treturn err;\n\n\tif (v != echores) {\n\t\twiphy_info(ar->hw->wiphy, \"wrong echo %x != %x\", v, echores);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstruct carl9170_cmd *carl9170_cmd_buf(struct ar9170 *ar,\n\tconst enum carl9170_cmd_oids cmd, const unsigned int len)\n{\n\tstruct carl9170_cmd *tmp;\n\n\ttmp = kzalloc(sizeof(*tmp), GFP_ATOMIC);\n\tif (tmp) {\n\t\ttmp->hdr.cmd = cmd;\n\t\ttmp->hdr.len = len;\n\t}\n\n\treturn tmp;\n}\n\nint carl9170_reboot(struct ar9170 *ar)\n{\n\tstruct carl9170_cmd *cmd;\n\tint err;\n\n\tcmd = carl9170_cmd_buf(ar, CARL9170_CMD_REBOOT_ASYNC, 0);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\terr = __carl9170_exec_cmd(ar, cmd, true);\n\treturn err;\n}\n\nint carl9170_mac_reset(struct ar9170 *ar)\n{\n\treturn carl9170_exec_cmd(ar, CARL9170_CMD_SWRST,\n\t\t\t\t 0, NULL, 0, NULL);\n}\n\nint carl9170_bcn_ctrl(struct ar9170 *ar, const unsigned int vif_id,\n\t\t       const u32 mode, const u32 addr, const u32 len)\n{\n\tstruct carl9170_cmd *cmd;\n\n\tcmd = carl9170_cmd_buf(ar, CARL9170_CMD_BCN_CTRL_ASYNC,\n\t\t\t       sizeof(struct carl9170_bcn_ctrl_cmd));\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tcmd->bcn_ctrl.vif_id = cpu_to_le32(vif_id);\n\tcmd->bcn_ctrl.mode = cpu_to_le32(mode);\n\tcmd->bcn_ctrl.bcn_addr = cpu_to_le32(addr);\n\tcmd->bcn_ctrl.bcn_len = cpu_to_le32(len);\n\n\treturn __carl9170_exec_cmd(ar, cmd, true);\n}\n\nint carl9170_collect_tally(struct ar9170 *ar)\n{\n\tstruct carl9170_tally_rsp tally;\n\tstruct survey_info *info;\n\tunsigned int tick;\n\tint err;\n\n\terr = carl9170_exec_cmd(ar, CARL9170_CMD_TALLY, 0, NULL,\n\t\t\t\tsizeof(tally), (u8 *)&tally);\n\tif (err)\n\t\treturn err;\n\n\ttick = le32_to_cpu(tally.tick);\n\tif (tick) {\n\t\tar->tally.active += le32_to_cpu(tally.active) / tick;\n\t\tar->tally.cca += le32_to_cpu(tally.cca) / tick;\n\t\tar->tally.tx_time += le32_to_cpu(tally.tx_time) / tick;\n\t\tar->tally.rx_total += le32_to_cpu(tally.rx_total);\n\t\tar->tally.rx_overrun += le32_to_cpu(tally.rx_overrun);\n\n\t\tif (ar->channel) {\n\t\t\tinfo = &ar->survey[ar->channel->hw_value];\n\t\t\tinfo->time = ar->tally.active;\n\t\t\tinfo->time_busy = ar->tally.cca;\n\t\t\tinfo->time_tx = ar->tally.tx_time;\n\t\t\tdo_div(info->time, 1000);\n\t\t\tdo_div(info->time_busy, 1000);\n\t\t\tdo_div(info->time_tx, 1000);\n\t\t}\n\t}\n\treturn 0;\n}\n\nint carl9170_powersave(struct ar9170 *ar, const bool ps)\n{\n\tstruct carl9170_cmd *cmd;\n\tu32 state;\n\n\tcmd = carl9170_cmd_buf(ar, CARL9170_CMD_PSM_ASYNC,\n\t\t\t       sizeof(struct carl9170_psm));\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tif (ps) {\n\t\t \n\t\tstate = CARL9170_PSM_SLEEP | 1;\n\t} else {\n\t\t \n\t\tstate = 1;\n\t}\n\n\tcmd->psm.state = cpu_to_le32(state);\n\treturn __carl9170_exec_cmd(ar, cmd, true);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}