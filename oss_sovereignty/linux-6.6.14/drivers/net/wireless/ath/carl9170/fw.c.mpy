{
  "module_name": "fw.c",
  "hash_id": "ed0835e722cc91e6abf44f21cde944390d7084a1a437f408d2482bdf761df3af",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/carl9170/fw.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/firmware.h>\n#include <linux/crc32.h>\n#include <linux/module.h>\n#include \"carl9170.h\"\n#include \"fwcmd.h\"\n#include \"version.h\"\n\nstatic const u8 otus_magic[4] = { OTUS_MAGIC };\n\nstatic const void *carl9170_fw_find_desc(struct ar9170 *ar, const u8 descid[4],\n\tconst unsigned int len, const u8 compatible_revision)\n{\n\tconst struct carl9170fw_desc_head *iter;\n\n\tcarl9170fw_for_each_hdr(iter, ar->fw.desc) {\n\t\tif (carl9170fw_desc_cmp(iter, descid, len,\n\t\t\t\t\tcompatible_revision))\n\t\t\treturn (void *)iter;\n\t}\n\n\t \n\tif (carl9170fw_desc_cmp(iter, descid, len,\n\t\t\t\tcompatible_revision))\n\t\treturn (void *)iter;\n\n\treturn NULL;\n}\n\nstatic int carl9170_fw_verify_descs(struct ar9170 *ar,\n\tconst struct carl9170fw_desc_head *head, unsigned int max_len)\n{\n\tconst struct carl9170fw_desc_head *pos;\n\tunsigned long pos_addr, end_addr;\n\tunsigned int pos_length;\n\n\tif (max_len < sizeof(*pos))\n\t\treturn -ENODATA;\n\n\tmax_len = min_t(unsigned int, CARL9170FW_DESC_MAX_LENGTH, max_len);\n\n\tpos = head;\n\tpos_addr = (unsigned long) pos;\n\tend_addr = pos_addr + max_len;\n\n\twhile (pos_addr < end_addr) {\n\t\tif (pos_addr + sizeof(*head) > end_addr)\n\t\t\treturn -E2BIG;\n\n\t\tpos_length = le16_to_cpu(pos->length);\n\n\t\tif (pos_length < sizeof(*head))\n\t\t\treturn -EBADMSG;\n\n\t\tif (pos_length > max_len)\n\t\t\treturn -EOVERFLOW;\n\n\t\tif (pos_addr + pos_length > end_addr)\n\t\t\treturn -EMSGSIZE;\n\n\t\tif (carl9170fw_desc_cmp(pos, LAST_MAGIC,\n\t\t\t\t\tCARL9170FW_LAST_DESC_SIZE,\n\t\t\t\t\tCARL9170FW_LAST_DESC_CUR_VER))\n\t\t\treturn 0;\n\n\t\tpos_addr += pos_length;\n\t\tpos = (void *)pos_addr;\n\t\tmax_len -= pos_length;\n\t}\n\treturn -EINVAL;\n}\n\nstatic void carl9170_fw_info(struct ar9170 *ar)\n{\n\tconst struct carl9170fw_motd_desc *motd_desc;\n\tunsigned int str_ver_len;\n\tu32 fw_date;\n\n\tdev_info(&ar->udev->dev, \"driver   API: %s 2%03d-%02d-%02d [%d-%d]\\n\",\n\t\tCARL9170FW_VERSION_GIT, CARL9170FW_VERSION_YEAR,\n\t\tCARL9170FW_VERSION_MONTH, CARL9170FW_VERSION_DAY,\n\t\tCARL9170FW_API_MIN_VER, CARL9170FW_API_MAX_VER);\n\n\tmotd_desc = carl9170_fw_find_desc(ar, MOTD_MAGIC,\n\t\tsizeof(*motd_desc), CARL9170FW_MOTD_DESC_CUR_VER);\n\n\tif (motd_desc) {\n\t\tstr_ver_len = strnlen(motd_desc->release,\n\t\t\tCARL9170FW_MOTD_RELEASE_LEN);\n\n\t\tfw_date = le32_to_cpu(motd_desc->fw_year_month_day);\n\n\t\tdev_info(&ar->udev->dev, \"firmware API: %.*s 2%03d-%02d-%02d\\n\",\n\t\t\t str_ver_len, motd_desc->release,\n\t\t\t CARL9170FW_GET_YEAR(fw_date),\n\t\t\t CARL9170FW_GET_MONTH(fw_date),\n\t\t\t CARL9170FW_GET_DAY(fw_date));\n\n\t\tstrscpy(ar->hw->wiphy->fw_version, motd_desc->release,\n\t\t\tsizeof(ar->hw->wiphy->fw_version));\n\t}\n}\n\nstatic bool valid_dma_addr(const u32 address)\n{\n\tif (address >= AR9170_SRAM_OFFSET &&\n\t    address < (AR9170_SRAM_OFFSET + AR9170_SRAM_SIZE))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool valid_cpu_addr(const u32 address)\n{\n\tif (valid_dma_addr(address) || (address >= AR9170_PRAM_OFFSET &&\n\t    address < (AR9170_PRAM_OFFSET + AR9170_PRAM_SIZE)))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int carl9170_fw_checksum(struct ar9170 *ar, const __u8 *data,\n\t\t\t\tsize_t len)\n{\n\tconst struct carl9170fw_otus_desc *otus_desc;\n\tconst struct carl9170fw_last_desc *last_desc;\n\tconst struct carl9170fw_chk_desc *chk_desc;\n\tunsigned long fin, diff;\n\tunsigned int dsc_len;\n\tu32 crc32;\n\n\tlast_desc = carl9170_fw_find_desc(ar, LAST_MAGIC,\n\t\tsizeof(*last_desc), CARL9170FW_LAST_DESC_CUR_VER);\n\tif (!last_desc)\n\t\treturn -EINVAL;\n\n\totus_desc = carl9170_fw_find_desc(ar, OTUS_MAGIC,\n\t\tsizeof(*otus_desc), CARL9170FW_OTUS_DESC_CUR_VER);\n\tif (!otus_desc) {\n\t\tdev_err(&ar->udev->dev, \"failed to find compatible firmware \"\n\t\t\t\"descriptor.\\n\");\n\t\treturn -ENODATA;\n\t}\n\n\tchk_desc = carl9170_fw_find_desc(ar, CHK_MAGIC,\n\t\tsizeof(*chk_desc), CARL9170FW_CHK_DESC_CUR_VER);\n\n\tif (!chk_desc) {\n\t\tdev_warn(&ar->udev->dev, \"Unprotected firmware image.\\n\");\n\t\treturn 0;\n\t}\n\n\tdsc_len = min_t(unsigned int, len,\n\t\t\t(unsigned long)chk_desc - (unsigned long)otus_desc);\n\n\tfin = (unsigned long) last_desc + sizeof(*last_desc);\n\tdiff = fin - (unsigned long) otus_desc;\n\n\tif (diff < len)\n\t\tlen -= diff;\n\n\tif (len < 256)\n\t\treturn -EIO;\n\n\tcrc32 = crc32_le(~0, data, len);\n\tif (cpu_to_le32(crc32) != chk_desc->fw_crc32) {\n\t\tdev_err(&ar->udev->dev, \"fw checksum test failed.\\n\");\n\t\treturn -ENOEXEC;\n\t}\n\n\tcrc32 = crc32_le(crc32, (void *)otus_desc, dsc_len);\n\tif (cpu_to_le32(crc32) != chk_desc->hdr_crc32) {\n\t\tdev_err(&ar->udev->dev, \"descriptor check failed.\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int carl9170_fw_tx_sequence(struct ar9170 *ar)\n{\n\tconst struct carl9170fw_txsq_desc *txsq_desc;\n\n\ttxsq_desc = carl9170_fw_find_desc(ar, TXSQ_MAGIC, sizeof(*txsq_desc),\n\t\t\t\t\t  CARL9170FW_TXSQ_DESC_CUR_VER);\n\tif (txsq_desc) {\n\t\tar->fw.tx_seq_table = le32_to_cpu(txsq_desc->seq_table_addr);\n\t\tif (!valid_cpu_addr(ar->fw.tx_seq_table))\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tar->fw.tx_seq_table = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic void carl9170_fw_set_if_combinations(struct ar9170 *ar,\n\t\t\t\t\t    u16 if_comb_types)\n{\n\tif (ar->fw.vif_num < 2)\n\t\treturn;\n\n\tar->if_comb_limits[0].max = ar->fw.vif_num;\n\tar->if_comb_limits[0].types = if_comb_types;\n\n\tar->if_combs[0].num_different_channels = 1;\n\tar->if_combs[0].max_interfaces = ar->fw.vif_num;\n\tar->if_combs[0].limits = ar->if_comb_limits;\n\tar->if_combs[0].n_limits = ARRAY_SIZE(ar->if_comb_limits);\n\n\tar->hw->wiphy->iface_combinations = ar->if_combs;\n\tar->hw->wiphy->n_iface_combinations = ARRAY_SIZE(ar->if_combs);\n}\n\nstatic int carl9170_fw(struct ar9170 *ar, const __u8 *data, size_t len)\n{\n\tconst struct carl9170fw_otus_desc *otus_desc;\n\tint err;\n\tu16 if_comb_types;\n\n\terr = carl9170_fw_checksum(ar, data, len);\n\tif (err)\n\t\treturn err;\n\n\totus_desc = carl9170_fw_find_desc(ar, OTUS_MAGIC,\n\t\tsizeof(*otus_desc), CARL9170FW_OTUS_DESC_CUR_VER);\n\tif (!otus_desc) {\n\t\treturn -ENODATA;\n\t}\n\n#define SUPP(feat)\t\t\t\t\t\t\\\n\t(carl9170fw_supports(otus_desc->feature_set, feat))\n\n\tif (!SUPP(CARL9170FW_DUMMY_FEATURE)) {\n\t\tdev_err(&ar->udev->dev, \"invalid firmware descriptor \"\n\t\t\t\"format detected.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tar->fw.api_version = otus_desc->api_ver;\n\n\tif (ar->fw.api_version < CARL9170FW_API_MIN_VER ||\n\t    ar->fw.api_version > CARL9170FW_API_MAX_VER) {\n\t\tdev_err(&ar->udev->dev, \"unsupported firmware api version.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!SUPP(CARL9170FW_COMMAND_PHY) || SUPP(CARL9170FW_UNUSABLE) ||\n\t    !SUPP(CARL9170FW_HANDLE_BACK_REQ)) {\n\t\tdev_err(&ar->udev->dev, \"firmware does support \"\n\t\t\t\"mandatory features.\\n\");\n\t\treturn -ECANCELED;\n\t}\n\n\tif (ilog2(le32_to_cpu(otus_desc->feature_set)) >=\n\t\t__CARL9170FW_FEATURE_NUM) {\n\t\tdev_warn(&ar->udev->dev, \"driver does not support all \"\n\t\t\t \"firmware features.\\n\");\n\t}\n\n\tif (!SUPP(CARL9170FW_COMMAND_CAM)) {\n\t\tdev_info(&ar->udev->dev, \"crypto offloading is disabled \"\n\t\t\t \"by firmware.\\n\");\n\t\tar->fw.disable_offload_fw = true;\n\t}\n\n\tif (SUPP(CARL9170FW_PSM) && SUPP(CARL9170FW_FIXED_5GHZ_PSM))\n\t\tieee80211_hw_set(ar->hw, SUPPORTS_PS);\n\n\tif (!SUPP(CARL9170FW_USB_INIT_FIRMWARE)) {\n\t\tdev_err(&ar->udev->dev, \"firmware does not provide \"\n\t\t\t\"mandatory interfaces.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (SUPP(CARL9170FW_MINIBOOT))\n\t\tar->fw.offset = le16_to_cpu(otus_desc->miniboot_size);\n\telse\n\t\tar->fw.offset = 0;\n\n\tif (SUPP(CARL9170FW_USB_DOWN_STREAM)) {\n\t\tar->hw->extra_tx_headroom += sizeof(struct ar9170_stream);\n\t\tar->fw.tx_stream = true;\n\t}\n\n\tif (SUPP(CARL9170FW_USB_UP_STREAM))\n\t\tar->fw.rx_stream = true;\n\n\tif (SUPP(CARL9170FW_RX_FILTER)) {\n\t\tar->fw.rx_filter = true;\n\t\tar->rx_filter_caps = FIF_FCSFAIL | FIF_PLCPFAIL |\n\t\t\tFIF_CONTROL | FIF_PSPOLL | FIF_OTHER_BSS;\n\t}\n\n\tif (SUPP(CARL9170FW_HW_COUNTERS))\n\t\tar->fw.hw_counters = true;\n\n\tif (SUPP(CARL9170FW_WOL))\n\t\tdevice_set_wakeup_enable(&ar->udev->dev, true);\n\n\tif (SUPP(CARL9170FW_RX_BA_FILTER))\n\t\tar->fw.ba_filter = true;\n\n\tif_comb_types = BIT(NL80211_IFTYPE_STATION) |\n\t\t\tBIT(NL80211_IFTYPE_P2P_CLIENT);\n\n\tar->fw.vif_num = otus_desc->vif_num;\n\tar->fw.cmd_bufs = otus_desc->cmd_bufs;\n\tar->fw.address = le32_to_cpu(otus_desc->fw_address);\n\tar->fw.rx_size = le16_to_cpu(otus_desc->rx_max_frame_len);\n\tar->fw.mem_blocks = min_t(unsigned int, otus_desc->tx_descs, 0xfe);\n\tatomic_set(&ar->mem_free_blocks, ar->fw.mem_blocks);\n\tar->fw.mem_block_size = le16_to_cpu(otus_desc->tx_frag_len);\n\n\tif (ar->fw.vif_num >= AR9170_MAX_VIRTUAL_MAC || !ar->fw.vif_num ||\n\t    ar->fw.mem_blocks < 16 || !ar->fw.cmd_bufs ||\n\t    ar->fw.mem_block_size < 64 || ar->fw.mem_block_size > 512 ||\n\t    ar->fw.rx_size > 32768 || ar->fw.rx_size < 4096 ||\n\t    !valid_cpu_addr(ar->fw.address)) {\n\t\tdev_err(&ar->udev->dev, \"firmware shows obvious signs of \"\n\t\t\t\"malicious tampering.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tar->fw.beacon_addr = le32_to_cpu(otus_desc->bcn_addr);\n\tar->fw.beacon_max_len = le16_to_cpu(otus_desc->bcn_len);\n\n\tif (valid_dma_addr(ar->fw.beacon_addr) && ar->fw.beacon_max_len >=\n\t    AR9170_MAC_BCN_LENGTH_MAX) {\n\t\tar->hw->wiphy->interface_modes |= BIT(NL80211_IFTYPE_ADHOC);\n\n\t\tif (SUPP(CARL9170FW_WLANTX_CAB)) {\n\t\t\tif_comb_types |= BIT(NL80211_IFTYPE_AP);\n\n#ifdef CONFIG_MAC80211_MESH\n\t\t\tif_comb_types |=\n\t\t\t\tBIT(NL80211_IFTYPE_MESH_POINT);\n#endif  \n\t\t}\n\t}\n\n\tcarl9170_fw_set_if_combinations(ar, if_comb_types);\n\n\tar->hw->wiphy->interface_modes |= if_comb_types;\n\n\tar->hw->wiphy->flags &= ~WIPHY_FLAG_PS_ON_BY_DEFAULT;\n\n\t \n\tar->hw->wiphy->flags |= WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL |\n\t\t WIPHY_FLAG_IBSS_RSN | WIPHY_FLAG_SUPPORTS_TDLS;\n\n#undef SUPPORTED\n\treturn carl9170_fw_tx_sequence(ar);\n}\n\nstatic struct carl9170fw_desc_head *\ncarl9170_find_fw_desc(struct ar9170 *ar, const __u8 *fw_data, const size_t len)\n\n{\n\tint scan = 0, found = 0;\n\n\tif (!carl9170fw_size_check(len)) {\n\t\tdev_err(&ar->udev->dev, \"firmware size is out of bound.\\n\");\n\t\treturn NULL;\n\t}\n\n\twhile (scan < len - sizeof(struct carl9170fw_desc_head)) {\n\t\tif (fw_data[scan++] == otus_magic[found])\n\t\t\tfound++;\n\t\telse\n\t\t\tfound = 0;\n\n\t\tif (scan >= len)\n\t\t\tbreak;\n\n\t\tif (found == sizeof(otus_magic))\n\t\t\tbreak;\n\t}\n\n\tif (found != sizeof(otus_magic))\n\t\treturn NULL;\n\n\treturn (void *)&fw_data[scan - found];\n}\n\nint carl9170_parse_firmware(struct ar9170 *ar)\n{\n\tconst struct carl9170fw_desc_head *fw_desc = NULL;\n\tconst struct firmware *fw = ar->fw.fw;\n\tunsigned long header_offset = 0;\n\tint err;\n\n\tif (WARN_ON(!fw))\n\t\treturn -EINVAL;\n\n\tfw_desc = carl9170_find_fw_desc(ar, fw->data, fw->size);\n\n\tif (!fw_desc) {\n\t\tdev_err(&ar->udev->dev, \"unsupported firmware.\\n\");\n\t\treturn -ENODATA;\n\t}\n\n\theader_offset = (unsigned long)fw_desc - (unsigned long)fw->data;\n\n\terr = carl9170_fw_verify_descs(ar, fw_desc, fw->size - header_offset);\n\tif (err) {\n\t\tdev_err(&ar->udev->dev, \"damaged firmware (%d).\\n\", err);\n\t\treturn err;\n\t}\n\n\tar->fw.desc = fw_desc;\n\n\tcarl9170_fw_info(ar);\n\n\terr = carl9170_fw(ar, fw->data, fw->size);\n\tif (err) {\n\t\tdev_err(&ar->udev->dev, \"failed to parse firmware (%d).\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}