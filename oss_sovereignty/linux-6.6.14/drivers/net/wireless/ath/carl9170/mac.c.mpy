{
  "module_name": "mac.c",
  "hash_id": "34018497f06a06e0bb7c2de1016055dda57990def25b48cb2d0b0a6baa31ec12",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/carl9170/mac.c",
  "human_readable_source": " \n\n#include <asm/unaligned.h>\n\n#include \"carl9170.h\"\n#include \"cmd.h\"\n\nint carl9170_set_dyn_sifs_ack(struct ar9170 *ar)\n{\n\tu32 val;\n\n\tif (conf_is_ht40(&ar->hw->conf))\n\t\tval = 0x010a;\n\telse {\n\t\tif (ar->hw->conf.chandef.chan->band == NL80211_BAND_2GHZ)\n\t\t\tval = 0x105;\n\t\telse\n\t\t\tval = 0x104;\n\t}\n\n\treturn carl9170_write_reg(ar, AR9170_MAC_REG_DYNAMIC_SIFS_ACK, val);\n}\n\nint carl9170_set_rts_cts_rate(struct ar9170 *ar)\n{\n\tu32 rts_rate, cts_rate;\n\n\tif (conf_is_ht(&ar->hw->conf)) {\n\t\t \n\t\trts_rate = 0x1da;\n\t\tcts_rate = 0x10a;\n\t} else {\n\t\tif (ar->hw->conf.chandef.chan->band == NL80211_BAND_2GHZ) {\n\t\t\t \n\t\t\trts_rate = 033;\n\t\t\tcts_rate = 003;\n\t\t} else {\n\t\t\t \n\t\t\trts_rate = 0x1bb;\n\t\t\tcts_rate = 0x10b;\n\t\t}\n\t}\n\n\treturn carl9170_write_reg(ar, AR9170_MAC_REG_RTS_CTS_RATE,\n\t\t\t\t  rts_rate | (cts_rate) << 16);\n}\n\nint carl9170_set_slot_time(struct ar9170 *ar)\n{\n\tstruct ieee80211_vif *vif;\n\tu32 slottime = 20;\n\n\trcu_read_lock();\n\tvif = carl9170_get_main_vif(ar);\n\tif (!vif) {\n\t\trcu_read_unlock();\n\t\treturn 0;\n\t}\n\n\tif ((ar->hw->conf.chandef.chan->band == NL80211_BAND_5GHZ) ||\n\t    vif->bss_conf.use_short_slot)\n\t\tslottime = 9;\n\n\trcu_read_unlock();\n\n\treturn carl9170_write_reg(ar, AR9170_MAC_REG_SLOT_TIME,\n\t\t\t\t  slottime << 10);\n}\n\nint carl9170_set_mac_rates(struct ar9170 *ar)\n{\n\tstruct ieee80211_vif *vif;\n\tu32 basic, mandatory;\n\n\trcu_read_lock();\n\tvif = carl9170_get_main_vif(ar);\n\n\tif (!vif) {\n\t\trcu_read_unlock();\n\t\treturn 0;\n\t}\n\n\tbasic = (vif->bss_conf.basic_rates & 0xf);\n\tbasic |= (vif->bss_conf.basic_rates & 0xff0) << 4;\n\trcu_read_unlock();\n\n\tif (ar->hw->conf.chandef.chan->band == NL80211_BAND_5GHZ)\n\t\tmandatory = 0xff00;  \n\telse\n\t\tmandatory = 0xff0f;  \n\n\tcarl9170_regwrite_begin(ar);\n\tcarl9170_regwrite(AR9170_MAC_REG_BASIC_RATE, basic);\n\tcarl9170_regwrite(AR9170_MAC_REG_MANDATORY_RATE, mandatory);\n\tcarl9170_regwrite_finish();\n\n\treturn carl9170_regwrite_result();\n}\n\nint carl9170_set_qos(struct ar9170 *ar)\n{\n\tcarl9170_regwrite_begin(ar);\n\n\tcarl9170_regwrite(AR9170_MAC_REG_AC0_CW, ar->edcf[0].cw_min |\n\t\t\t  (ar->edcf[0].cw_max << 16));\n\tcarl9170_regwrite(AR9170_MAC_REG_AC1_CW, ar->edcf[1].cw_min |\n\t\t\t  (ar->edcf[1].cw_max << 16));\n\tcarl9170_regwrite(AR9170_MAC_REG_AC2_CW, ar->edcf[2].cw_min |\n\t\t\t  (ar->edcf[2].cw_max << 16));\n\tcarl9170_regwrite(AR9170_MAC_REG_AC3_CW, ar->edcf[3].cw_min |\n\t\t\t  (ar->edcf[3].cw_max << 16));\n\tcarl9170_regwrite(AR9170_MAC_REG_AC4_CW, ar->edcf[4].cw_min |\n\t\t\t  (ar->edcf[4].cw_max << 16));\n\n\tcarl9170_regwrite(AR9170_MAC_REG_AC2_AC1_AC0_AIFS,\n\t\t\t  ((ar->edcf[0].aifs * 9 + 10)) |\n\t\t\t  ((ar->edcf[1].aifs * 9 + 10) << 12) |\n\t\t\t  ((ar->edcf[2].aifs * 9 + 10) << 24));\n\tcarl9170_regwrite(AR9170_MAC_REG_AC4_AC3_AC2_AIFS,\n\t\t\t  ((ar->edcf[2].aifs * 9 + 10) >> 8) |\n\t\t\t  ((ar->edcf[3].aifs * 9 + 10) << 4) |\n\t\t\t  ((ar->edcf[4].aifs * 9 + 10) << 16));\n\n\tcarl9170_regwrite(AR9170_MAC_REG_AC1_AC0_TXOP,\n\t\t\t  ar->edcf[0].txop | ar->edcf[1].txop << 16);\n\tcarl9170_regwrite(AR9170_MAC_REG_AC3_AC2_TXOP,\n\t\t\t  ar->edcf[2].txop | ar->edcf[3].txop << 16 |\n\t\t\t  ar->edcf[4].txop << 24);\n\n\tcarl9170_regwrite_finish();\n\n\treturn carl9170_regwrite_result();\n}\n\nint carl9170_init_mac(struct ar9170 *ar)\n{\n\tcarl9170_regwrite_begin(ar);\n\n\t \n\tcarl9170_regwrite(0x1c3600, 0x3);\n\n\tcarl9170_regwrite(AR9170_MAC_REG_ACK_EXTENSION, 0x40);\n\n\tcarl9170_regwrite(AR9170_MAC_REG_RETRY_MAX, 0x0);\n\n\tcarl9170_regwrite(AR9170_MAC_REG_FRAMETYPE_FILTER,\n\t\t\t  AR9170_MAC_FTF_MONITOR);\n\n\t \n\tcarl9170_regwrite(AR9170_MAC_REG_SNIFFER,\n\t\t\tAR9170_MAC_SNIFFER_DEFAULTS);\n\n\tcarl9170_regwrite(AR9170_MAC_REG_RX_THRESHOLD, 0xc1f80);\n\n\tcarl9170_regwrite(AR9170_MAC_REG_RX_PE_DELAY, 0x70);\n\tcarl9170_regwrite(AR9170_MAC_REG_EIFS_AND_SIFS, 0xa144000);\n\tcarl9170_regwrite(AR9170_MAC_REG_SLOT_TIME, 9 << 10);\n\n\t \n\tcarl9170_regwrite(AR9170_MAC_REG_TID_CFACK_CFEND_RATE, 0x59900000);\n\n\t \n\tcarl9170_regwrite(AR9170_MAC_REG_TXOP_DURATION, 0x201);\n\n\t \n\t \n\tcarl9170_regwrite(AR9170_MAC_REG_BCN_HT1, 0x8000170);\n\n\tcarl9170_regwrite(AR9170_MAC_REG_BACKOFF_PROTECT, 0x105);\n\n\t \n\tcarl9170_regwrite(AR9170_MAC_REG_AMPDU_FACTOR, 0x8000a);\n\tcarl9170_regwrite(AR9170_MAC_REG_AMPDU_DENSITY, 0x140a07);\n\n\tcarl9170_regwrite(AR9170_MAC_REG_FRAMETYPE_FILTER,\n\t\t\t  AR9170_MAC_FTF_DEFAULTS);\n\n\tcarl9170_regwrite(AR9170_MAC_REG_RX_CONTROL,\n\t\t\t  AR9170_MAC_RX_CTRL_DEAGG |\n\t\t\t  AR9170_MAC_RX_CTRL_SHORT_FILTER);\n\n\t \n\tcarl9170_regwrite(AR9170_MAC_REG_BASIC_RATE, 0x150f);\n\tcarl9170_regwrite(AR9170_MAC_REG_MANDATORY_RATE, 0x150f);\n\tcarl9170_regwrite(AR9170_MAC_REG_RTS_CTS_RATE, 0x0030033);\n\n\t \n\tcarl9170_regwrite(AR9170_MAC_REG_ACK_TPC, 0x4003c1e);\n\n\tcarl9170_regwrite(AR9170_MAC_REG_AMPDU_RX_THRESH, 0xffff);\n\n\t \n\tcarl9170_regwrite(AR9170_MAC_REG_MISC_680, 0xf00008);\n\n\t \n\tcarl9170_regwrite(AR9170_MAC_REG_RX_TIMEOUT, 0x0);\n\n\t \n\tcarl9170_regwrite(AR9170_MAC_REG_TXRX_MPI, 0x110011);\n\n\tcarl9170_regwrite(AR9170_MAC_REG_FCS_SELECT,\n\t\t\tAR9170_MAC_FCS_FIFO_PROT);\n\n\t \n\tcarl9170_regwrite(AR9170_MAC_REG_TXOP_NOT_ENOUGH_IND,\n\t\t\t0x141e0f48);\n\n\t \n\tcarl9170_regwrite(AR9170_MAC_REG_GROUP_HASH_TBL_L, 0xffffffff);\n\tcarl9170_regwrite(AR9170_MAC_REG_GROUP_HASH_TBL_H, 0xffffffff);\n\n\t \n\tcarl9170_regwrite(AR9170_MAC_REG_PRETBTT, 0x0);\n\tcarl9170_regwrite(AR9170_MAC_REG_BCN_PERIOD, 0x0);\n\n\tcarl9170_regwrite_finish();\n\n\treturn carl9170_regwrite_result();\n}\n\nstatic int carl9170_set_mac_reg(struct ar9170 *ar,\n\t\t\t\tconst u32 reg, const u8 *mac)\n{\n\tstatic const u8 zero[ETH_ALEN] = { 0 };\n\n\tif (!mac)\n\t\tmac = zero;\n\n\tcarl9170_regwrite_begin(ar);\n\n\tcarl9170_regwrite(reg, get_unaligned_le32(mac));\n\tcarl9170_regwrite(reg + 4, get_unaligned_le16(mac + 4));\n\n\tcarl9170_regwrite_finish();\n\n\treturn carl9170_regwrite_result();\n}\n\nint carl9170_mod_virtual_mac(struct ar9170 *ar, const unsigned int id,\n\t\t\t     const u8 *mac)\n{\n\tif (WARN_ON(id >= ar->fw.vif_num))\n\t\treturn -EINVAL;\n\n\treturn carl9170_set_mac_reg(ar,\n\t\tAR9170_MAC_REG_ACK_TABLE + (id - 1) * 8, mac);\n}\n\nint carl9170_update_multicast(struct ar9170 *ar, const u64 mc_hash)\n{\n\tint err;\n\n\tcarl9170_regwrite_begin(ar);\n\tcarl9170_regwrite(AR9170_MAC_REG_GROUP_HASH_TBL_H, mc_hash >> 32);\n\tcarl9170_regwrite(AR9170_MAC_REG_GROUP_HASH_TBL_L, mc_hash);\n\tcarl9170_regwrite_finish();\n\terr = carl9170_regwrite_result();\n\tif (err)\n\t\treturn err;\n\n\tar->cur_mc_hash = mc_hash;\n\treturn 0;\n}\n\nint carl9170_set_operating_mode(struct ar9170 *ar)\n{\n\tstruct ieee80211_vif *vif;\n\tstruct ath_common *common = &ar->common;\n\tu8 *mac_addr, *bssid;\n\tu32 cam_mode = AR9170_MAC_CAM_DEFAULTS;\n\tu32 enc_mode = AR9170_MAC_ENCRYPTION_DEFAULTS |\n\t\tAR9170_MAC_ENCRYPTION_MGMT_RX_SOFTWARE;\n\tu32 rx_ctrl = AR9170_MAC_RX_CTRL_DEAGG |\n\t\t      AR9170_MAC_RX_CTRL_SHORT_FILTER;\n\tu32 sniffer = AR9170_MAC_SNIFFER_DEFAULTS;\n\tint err = 0;\n\n\trcu_read_lock();\n\tvif = carl9170_get_main_vif(ar);\n\n\tif (vif) {\n\t\tmac_addr = common->macaddr;\n\t\tbssid = common->curbssid;\n\n\t\tswitch (vif->type) {\n\t\tcase NL80211_IFTYPE_ADHOC:\n\t\t\tcam_mode |= AR9170_MAC_CAM_IBSS;\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tcase NL80211_IFTYPE_AP:\n\t\t\tcam_mode |= AR9170_MAC_CAM_AP;\n\n\t\t\t \n\t\t\trx_ctrl |= AR9170_MAC_RX_CTRL_PASS_TO_HOST;\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_STATION:\n\t\t\tcam_mode |= AR9170_MAC_CAM_STA;\n\t\t\trx_ctrl |= AR9170_MAC_RX_CTRL_PASS_TO_HOST;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN(1, \"Unsupported operation mode %x\\n\", vif->type);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t \n\t\tcam_mode |= AR9170_MAC_CAM_STA;\n\t\trx_ctrl |= AR9170_MAC_RX_CTRL_PASS_TO_HOST;\n\t\tmac_addr = common->macaddr;\n\t\tbssid = NULL;\n\t}\n\trcu_read_unlock();\n\n\tif (err)\n\t\treturn err;\n\n\tif (ar->rx_software_decryption)\n\t\tenc_mode |= AR9170_MAC_ENCRYPTION_RX_SOFTWARE;\n\n\tif (ar->sniffer_enabled) {\n\t\tenc_mode |= AR9170_MAC_ENCRYPTION_RX_SOFTWARE;\n\t}\n\n\terr = carl9170_set_mac_reg(ar, AR9170_MAC_REG_MAC_ADDR_L, mac_addr);\n\tif (err)\n\t\treturn err;\n\n\terr = carl9170_set_mac_reg(ar, AR9170_MAC_REG_BSSID_L, bssid);\n\tif (err)\n\t\treturn err;\n\n\tcarl9170_regwrite_begin(ar);\n\tcarl9170_regwrite(AR9170_MAC_REG_SNIFFER, sniffer);\n\tcarl9170_regwrite(AR9170_MAC_REG_CAM_MODE, cam_mode);\n\tcarl9170_regwrite(AR9170_MAC_REG_ENCRYPTION, enc_mode);\n\tcarl9170_regwrite(AR9170_MAC_REG_RX_CONTROL, rx_ctrl);\n\tcarl9170_regwrite_finish();\n\n\treturn carl9170_regwrite_result();\n}\n\nint carl9170_set_hwretry_limit(struct ar9170 *ar, const unsigned int max_retry)\n{\n\tu32 tmp = min_t(u32, 0x33333, max_retry * 0x11111);\n\n\treturn carl9170_write_reg(ar, AR9170_MAC_REG_RETRY_MAX, tmp);\n}\n\nint carl9170_set_beacon_timers(struct ar9170 *ar)\n{\n\tstruct ieee80211_vif *vif;\n\tu32 v = 0;\n\tu32 pretbtt = 0;\n\n\trcu_read_lock();\n\tvif = carl9170_get_main_vif(ar);\n\n\tif (vif) {\n\t\tstruct carl9170_vif_info *mvif;\n\t\tmvif = (void *) vif->drv_priv;\n\n\t\tif (mvif->enable_beacon && !WARN_ON(!ar->beacon_enabled)) {\n\t\t\tar->global_beacon_int = vif->bss_conf.beacon_int /\n\t\t\t\t\t\tar->beacon_enabled;\n\n\t\t\tSET_VAL(AR9170_MAC_BCN_DTIM, v,\n\t\t\t\tvif->bss_conf.dtim_period);\n\n\t\t\tswitch (vif->type) {\n\t\t\tcase NL80211_IFTYPE_MESH_POINT:\n\t\t\tcase NL80211_IFTYPE_ADHOC:\n\t\t\t\tv |= AR9170_MAC_BCN_IBSS_MODE;\n\t\t\t\tbreak;\n\t\t\tcase NL80211_IFTYPE_AP:\n\t\t\t\tv |= AR9170_MAC_BCN_AP_MODE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (vif->type == NL80211_IFTYPE_STATION) {\n\t\t\tar->global_beacon_int = vif->bss_conf.beacon_int;\n\n\t\t\tSET_VAL(AR9170_MAC_BCN_DTIM, v,\n\t\t\t\tar->hw->conf.ps_dtim_period);\n\n\t\t\tv |= AR9170_MAC_BCN_STA_PS |\n\t\t\t     AR9170_MAC_BCN_PWR_MGT;\n\t\t}\n\n\t\tif (ar->global_beacon_int) {\n\t\t\tif (ar->global_beacon_int < 15) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn -ERANGE;\n\t\t\t}\n\n\t\t\tar->global_pretbtt = ar->global_beacon_int -\n\t\t\t\t\tCARL9170_PRETBTT_KUS;\n\t\t} else {\n\t\t\tar->global_pretbtt = 0;\n\t\t}\n\t} else {\n\t\tar->global_beacon_int = 0;\n\t\tar->global_pretbtt = 0;\n\t}\n\n\trcu_read_unlock();\n\n\tSET_VAL(AR9170_MAC_BCN_PERIOD, v, ar->global_beacon_int);\n\tSET_VAL(AR9170_MAC_PRETBTT, pretbtt, ar->global_pretbtt);\n\tSET_VAL(AR9170_MAC_PRETBTT2, pretbtt, ar->global_pretbtt);\n\n\tcarl9170_regwrite_begin(ar);\n\tcarl9170_regwrite(AR9170_MAC_REG_PRETBTT, pretbtt);\n\tcarl9170_regwrite(AR9170_MAC_REG_BCN_PERIOD, v);\n\tcarl9170_regwrite_finish();\n\treturn carl9170_regwrite_result();\n}\n\nint carl9170_upload_key(struct ar9170 *ar, const u8 id, const u8 *mac,\n\t\t\tconst u8 ktype, const u8 keyidx, const u8 *keydata,\n\t\t\tconst int keylen)\n{\n\tstruct carl9170_set_key_cmd key = { };\n\tstatic const u8 bcast[ETH_ALEN] = {\n\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\n\n\tmac = mac ? : bcast;\n\n\tkey.user = cpu_to_le16(id);\n\tkey.keyId = cpu_to_le16(keyidx);\n\tkey.type = cpu_to_le16(ktype);\n\tmemcpy(&key.macAddr, mac, ETH_ALEN);\n\tif (keydata)\n\t\tmemcpy(&key.key, keydata, keylen);\n\n\treturn carl9170_exec_cmd(ar, CARL9170_CMD_EKEY,\n\t\tsizeof(key), (u8 *)&key, 0, NULL);\n}\n\nint carl9170_disable_key(struct ar9170 *ar, const u8 id)\n{\n\tstruct carl9170_disable_key_cmd key = { };\n\n\tkey.user = cpu_to_le16(id);\n\n\treturn carl9170_exec_cmd(ar, CARL9170_CMD_DKEY,\n\t\tsizeof(key), (u8 *)&key, 0, NULL);\n}\n\nint carl9170_set_mac_tpc(struct ar9170 *ar, struct ieee80211_channel *channel)\n{\n\tunsigned int power, chains;\n\n\tif (ar->eeprom.tx_mask != 1)\n\t\tchains = AR9170_TX_PHY_TXCHAIN_2;\n\telse\n\t\tchains = AR9170_TX_PHY_TXCHAIN_1;\n\n\tswitch (channel->band) {\n\tcase NL80211_BAND_2GHZ:\n\t\tpower = ar->power_2G_ofdm[0] & 0x3f;\n\t\tbreak;\n\tcase NL80211_BAND_5GHZ:\n\t\tpower = ar->power_5G_leg[0] & 0x3f;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tpower = min_t(unsigned int, power, ar->hw->conf.power_level * 2);\n\n\tcarl9170_regwrite_begin(ar);\n\tcarl9170_regwrite(AR9170_MAC_REG_ACK_TPC,\n\t\t\t  0x3c1e | power << 20 | chains << 26);\n\tcarl9170_regwrite(AR9170_MAC_REG_RTS_CTS_TPC,\n\t\t\t  power << 5 | chains << 11 |\n\t\t\t  power << 21 | chains << 27);\n\tcarl9170_regwrite(AR9170_MAC_REG_CFEND_QOSNULL_TPC,\n\t\t\t  power << 5 | chains << 11 |\n\t\t\t  power << 21 | chains << 27);\n\tcarl9170_regwrite_finish();\n\treturn carl9170_regwrite_result();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}