{
  "module_name": "debug.c",
  "hash_id": "41f3ff759a7f5495a0adb3b2ec131f83142acd9251603041eba36b2b6a2f7b80",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/carl9170/debug.c",
  "human_readable_source": " \n\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/seq_file.h>\n#include <linux/vmalloc.h>\n#include \"carl9170.h\"\n#include \"cmd.h\"\n\n#define ADD(buf, off, max, fmt, args...)\t\t\t\t\\\n\toff += scnprintf(&buf[off], max - off, fmt, ##args)\n\n\nstruct carl9170_debugfs_fops {\n\tunsigned int read_bufsize;\n\tumode_t attr;\n\tchar *(*read)(struct ar9170 *ar, char *buf, size_t bufsize,\n\t\t      ssize_t *len);\n\tssize_t (*write)(struct ar9170 *aru, const char *buf, size_t size);\n\tconst struct file_operations fops;\n\n\tenum carl9170_device_state req_dev_state;\n};\n\nstatic ssize_t carl9170_debugfs_read(struct file *file, char __user *userbuf,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct carl9170_debugfs_fops *dfops;\n\tstruct ar9170 *ar;\n\tchar *buf = NULL, *res_buf = NULL;\n\tssize_t ret = 0;\n\tint err = 0;\n\n\tif (!count)\n\t\treturn 0;\n\n\tar = file->private_data;\n\n\tif (!ar)\n\t\treturn -ENODEV;\n\tdfops = container_of(debugfs_real_fops(file),\n\t\t\t     struct carl9170_debugfs_fops, fops);\n\n\tif (!dfops->read)\n\t\treturn -ENOSYS;\n\n\tif (dfops->read_bufsize) {\n\t\tbuf = vmalloc(dfops->read_bufsize);\n\t\tif (!buf)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tmutex_lock(&ar->mutex);\n\tif (!CHK_DEV_STATE(ar, dfops->req_dev_state)) {\n\t\terr = -ENODEV;\n\t\tres_buf = buf;\n\t\tgoto out_free;\n\t}\n\n\tres_buf = dfops->read(ar, buf, dfops->read_bufsize, &ret);\n\n\tif (ret > 0)\n\t\terr = simple_read_from_buffer(userbuf, count, ppos,\n\t\t\t\t\t      res_buf, ret);\n\telse\n\t\terr = ret;\n\n\tWARN_ON_ONCE(dfops->read_bufsize && (res_buf != buf));\n\nout_free:\n\tvfree(res_buf);\n\tmutex_unlock(&ar->mutex);\n\treturn err;\n}\n\nstatic ssize_t carl9170_debugfs_write(struct file *file,\n\tconst char __user *userbuf, size_t count, loff_t *ppos)\n{\n\tstruct carl9170_debugfs_fops *dfops;\n\tstruct ar9170 *ar;\n\tchar *buf = NULL;\n\tint err = 0;\n\n\tif (!count)\n\t\treturn 0;\n\n\tif (count > PAGE_SIZE)\n\t\treturn -E2BIG;\n\n\tar = file->private_data;\n\n\tif (!ar)\n\t\treturn -ENODEV;\n\tdfops = container_of(debugfs_real_fops(file),\n\t\t\t     struct carl9170_debugfs_fops, fops);\n\n\tif (!dfops->write)\n\t\treturn -ENOSYS;\n\n\tbuf = vmalloc(count);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(buf, userbuf, count)) {\n\t\terr = -EFAULT;\n\t\tgoto out_free;\n\t}\n\n\tif (mutex_trylock(&ar->mutex) == 0) {\n\t\terr = -EAGAIN;\n\t\tgoto out_free;\n\t}\n\n\tif (!CHK_DEV_STATE(ar, dfops->req_dev_state)) {\n\t\terr = -ENODEV;\n\t\tgoto out_unlock;\n\t}\n\n\terr = dfops->write(ar, buf, count);\n\tif (err)\n\t\tgoto out_unlock;\n\nout_unlock:\n\tmutex_unlock(&ar->mutex);\n\nout_free:\n\tvfree(buf);\n\treturn err;\n}\n\n#define __DEBUGFS_DECLARE_FILE(name, _read, _write, _read_bufsize,\t\\\n\t\t\t       _attr, _dstate)\t\t\t\t\\\nstatic const struct carl9170_debugfs_fops carl_debugfs_##name ##_ops = {\\\n\t.read_bufsize = _read_bufsize,\t\t\t\t\t\\\n\t.read = _read,\t\t\t\t\t\t\t\\\n\t.write = _write,\t\t\t\t\t\t\\\n\t.attr = _attr,\t\t\t\t\t\t\t\\\n\t.req_dev_state = _dstate,\t\t\t\t\t\\\n\t.fops = {\t\t\t\t\t\t\t\\\n\t\t.open\t= simple_open,\t\t\t\t\t\\\n\t\t.read\t= carl9170_debugfs_read,\t\t\t\\\n\t\t.write\t= carl9170_debugfs_write,\t\t\t\\\n\t\t.owner\t= THIS_MODULE\t\t\t\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n}\n\n#define DEBUGFS_DECLARE_FILE(name, _read, _write, _read_bufsize, _attr)\t\\\n\t__DEBUGFS_DECLARE_FILE(name, _read, _write, _read_bufsize,\t\\\n\t\t\t       _attr, CARL9170_STARTED)\t\t\t\\\n\n#define DEBUGFS_DECLARE_RO_FILE(name, _read_bufsize)\t\t\t\\\n\tDEBUGFS_DECLARE_FILE(name, carl9170_debugfs_##name ##_read,\t\\\n\t\t\t     NULL, _read_bufsize, 0400)\n\n#define DEBUGFS_DECLARE_WO_FILE(name)\t\t\t\t\t\\\n\tDEBUGFS_DECLARE_FILE(name, NULL, carl9170_debugfs_##name ##_write,\\\n\t\t\t     0, 0200)\n\n#define DEBUGFS_DECLARE_RW_FILE(name, _read_bufsize)\t\t\t\\\n\tDEBUGFS_DECLARE_FILE(name, carl9170_debugfs_##name ##_read,\t\\\n\t\t\t     carl9170_debugfs_##name ##_write,\t\t\\\n\t\t\t     _read_bufsize, 0600)\n\n#define __DEBUGFS_DECLARE_RW_FILE(name, _read_bufsize, _dstate)\t\t\\\n\t__DEBUGFS_DECLARE_FILE(name, carl9170_debugfs_##name ##_read,\t\\\n\t\t\t     carl9170_debugfs_##name ##_write,\t\t\\\n\t\t\t     _read_bufsize, 0600, _dstate)\n\n#define DEBUGFS_READONLY_FILE(name, _read_bufsize, fmt, value...)\t\\\nstatic char *carl9170_debugfs_ ##name ## _read(struct ar9170 *ar,\t\\\n\t\t\t\t\t     char *buf, size_t buf_size,\\\n\t\t\t\t\t     ssize_t *len)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tADD(buf, *len, buf_size, fmt \"\\n\", ##value);\t\t\t\\\n\treturn buf;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nDEBUGFS_DECLARE_RO_FILE(name, _read_bufsize)\n\nstatic char *carl9170_debugfs_mem_usage_read(struct ar9170 *ar, char *buf,\n\t\t\t\t\t     size_t bufsize, ssize_t *len)\n{\n\tspin_lock_bh(&ar->mem_lock);\n\n\tADD(buf, *len, bufsize, \"jar: [%*pb]\\n\",\n\t    ar->fw.mem_blocks, ar->mem_bitmap);\n\n\tADD(buf, *len, bufsize, \"cookies: used:%3d / total:%3d, allocs:%d\\n\",\n\t    bitmap_weight(ar->mem_bitmap, ar->fw.mem_blocks),\n\t    ar->fw.mem_blocks, atomic_read(&ar->mem_allocs));\n\n\tADD(buf, *len, bufsize, \"memory: free:%3d (%3d KiB) / total:%3d KiB)\\n\",\n\t    atomic_read(&ar->mem_free_blocks),\n\t    (atomic_read(&ar->mem_free_blocks) * ar->fw.mem_block_size) / 1024,\n\t    (ar->fw.mem_blocks * ar->fw.mem_block_size) / 1024);\n\n\tspin_unlock_bh(&ar->mem_lock);\n\n\treturn buf;\n}\nDEBUGFS_DECLARE_RO_FILE(mem_usage, 512);\n\nstatic char *carl9170_debugfs_qos_stat_read(struct ar9170 *ar, char *buf,\n\t\t\t\t\t    size_t bufsize, ssize_t *len)\n{\n\tADD(buf, *len, bufsize, \"%s QoS AC\\n\", modparam_noht ? \"Hardware\" :\n\t    \"Software\");\n\n\tADD(buf, *len, bufsize, \"[     VO            VI       \"\n\t\t\t\t \"     BE            BK      ]\\n\");\n\n\tspin_lock_bh(&ar->tx_stats_lock);\n\tADD(buf, *len, bufsize, \"[length/limit  length/limit  \"\n\t\t\t\t \"length/limit  length/limit ]\\n\"\n\t\t\t\t\"[   %3d/%3d       %3d/%3d    \"\n\t\t\t\t \"   %3d/%3d       %3d/%3d   ]\\n\\n\",\n\t    ar->tx_stats[0].len, ar->tx_stats[0].limit,\n\t    ar->tx_stats[1].len, ar->tx_stats[1].limit,\n\t    ar->tx_stats[2].len, ar->tx_stats[2].limit,\n\t    ar->tx_stats[3].len, ar->tx_stats[3].limit);\n\n\tADD(buf, *len, bufsize, \"[    total         total     \"\n\t\t\t\t \"    total         total    ]\\n\"\n\t\t\t\t\"[%10d    %10d    %10d    %10d   ]\\n\\n\",\n\t    ar->tx_stats[0].count, ar->tx_stats[1].count,\n\t    ar->tx_stats[2].count, ar->tx_stats[3].count);\n\n\tspin_unlock_bh(&ar->tx_stats_lock);\n\n\tADD(buf, *len, bufsize, \"[  pend/waittx   pend/waittx \"\n\t\t\t\t \"  pend/waittx   pend/waittx]\\n\"\n\t\t\t\t\"[   %3d/%3d       %3d/%3d    \"\n\t\t\t\t \"   %3d/%3d       %3d/%3d   ]\\n\\n\",\n\t    skb_queue_len(&ar->tx_pending[0]),\n\t    skb_queue_len(&ar->tx_status[0]),\n\t    skb_queue_len(&ar->tx_pending[1]),\n\t    skb_queue_len(&ar->tx_status[1]),\n\t    skb_queue_len(&ar->tx_pending[2]),\n\t    skb_queue_len(&ar->tx_status[2]),\n\t    skb_queue_len(&ar->tx_pending[3]),\n\t    skb_queue_len(&ar->tx_status[3]));\n\n\treturn buf;\n}\nDEBUGFS_DECLARE_RO_FILE(qos_stat, 512);\n\nstatic void carl9170_debugfs_format_frame(struct ar9170 *ar,\n\tstruct sk_buff *skb, const char *prefix, char *buf,\n\tssize_t *off, ssize_t bufsize)\n{\n\tstruct _carl9170_tx_superframe *txc = (void *) skb->data;\n\tstruct ieee80211_tx_info *txinfo = IEEE80211_SKB_CB(skb);\n\tstruct carl9170_tx_info *arinfo = (void *) txinfo->rate_driver_data;\n\tstruct ieee80211_hdr *hdr = (void *) txc->frame_data;\n\n\tADD(buf, *off, bufsize, \"%s %p, c:%2x, DA:%pM, sq:%4d, mc:%.4x, \"\n\t    \"pc:%.8x, to:%d ms\\n\", prefix, skb, txc->s.cookie,\n\t    ieee80211_get_DA(hdr), get_seq_h(hdr),\n\t    le16_to_cpu(txc->f.mac_control), le32_to_cpu(txc->f.phy_control),\n\t    jiffies_to_msecs(jiffies - arinfo->timeout));\n}\n\n\nstatic char *carl9170_debugfs_ampdu_state_read(struct ar9170 *ar, char *buf,\n\t\t\t\t\t       size_t bufsize, ssize_t *len)\n{\n\tstruct carl9170_sta_tid *iter;\n\tstruct sk_buff *skb;\n\tint cnt = 0, fc;\n\tint offset;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(iter, &ar->tx_ampdu_list, list) {\n\n\t\tspin_lock_bh(&iter->lock);\n\t\tADD(buf, *len, bufsize, \"Entry: #%2d TID:%1d, BSN:%4d, \"\n\t\t    \"SNX:%4d, HSN:%4d, BAW:%2d, state:%1d, toggles:%d\\n\",\n\t\t    cnt, iter->tid, iter->bsn, iter->snx, iter->hsn,\n\t\t    iter->max, iter->state, iter->counter);\n\n\t\tADD(buf, *len, bufsize, \"\\tWindow:  [%*pb,W]\\n\",\n\t\t    CARL9170_BAW_BITS, iter->bitmap);\n\n#define BM_STR_OFF(offset)\t\t\t\t\t\\\n\t((CARL9170_BAW_BITS - (offset) - 1) / 4 +\t\t\\\n\t (CARL9170_BAW_BITS - (offset) - 1) / 32 + 1)\n\n\t\toffset = BM_STR_OFF(0);\n\t\tADD(buf, *len, bufsize, \"\\tBase Seq: %*s\\n\", offset, \"T\");\n\n\t\toffset = BM_STR_OFF(SEQ_DIFF(iter->snx, iter->bsn));\n\t\tADD(buf, *len, bufsize, \"\\tNext Seq: %*s\\n\", offset, \"W\");\n\n\t\toffset = BM_STR_OFF(((int)iter->hsn - (int)iter->bsn) %\n\t\t\t\t     CARL9170_BAW_BITS);\n\t\tADD(buf, *len, bufsize, \"\\tLast Seq: %*s\\n\", offset, \"N\");\n\n\t\tADD(buf, *len, bufsize, \"\\tPre-Aggregation reorder buffer: \"\n\t\t    \" currently queued:%d\\n\", skb_queue_len(&iter->queue));\n\n\t\tfc = 0;\n\t\tskb_queue_walk(&iter->queue, skb) {\n\t\t\tchar prefix[32];\n\n\t\t\tsnprintf(prefix, sizeof(prefix), \"\\t\\t%3d :\", fc);\n\t\t\tcarl9170_debugfs_format_frame(ar, skb, prefix, buf,\n\t\t\t\t\t\t      len, bufsize);\n\n\t\t\tfc++;\n\t\t}\n\t\tspin_unlock_bh(&iter->lock);\n\t\tcnt++;\n\t}\n\trcu_read_unlock();\n\n\treturn buf;\n}\nDEBUGFS_DECLARE_RO_FILE(ampdu_state, 8000);\n\nstatic void carl9170_debugfs_queue_dump(struct ar9170 *ar, char *buf,\n\tssize_t *len, size_t bufsize, struct sk_buff_head *queue)\n{\n\tstruct sk_buff *skb;\n\tchar prefix[16];\n\tint fc = 0;\n\n\tspin_lock_bh(&queue->lock);\n\tskb_queue_walk(queue, skb) {\n\t\tsnprintf(prefix, sizeof(prefix), \"%3d :\", fc);\n\t\tcarl9170_debugfs_format_frame(ar, skb, prefix, buf,\n\t\t\t\t\t      len, bufsize);\n\t\tfc++;\n\t}\n\tspin_unlock_bh(&queue->lock);\n}\n\n#define DEBUGFS_QUEUE_DUMP(q, qi)\t\t\t\t\t\\\nstatic char *carl9170_debugfs_##q ##_##qi ##_read(struct ar9170 *ar,\t\\\n\tchar *buf, size_t bufsize, ssize_t *len)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tcarl9170_debugfs_queue_dump(ar, buf, len, bufsize, &ar->q[qi]);\t\\\n\treturn buf;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nDEBUGFS_DECLARE_RO_FILE(q##_##qi, 8000);\n\nstatic char *carl9170_debugfs_sta_psm_read(struct ar9170 *ar, char *buf,\n\t\t\t\t\t   size_t bufsize, ssize_t *len)\n{\n\tADD(buf, *len, bufsize, \"psm state: %s\\n\", (ar->ps.off_override ?\n\t    \"FORCE CAM\" : (ar->ps.state ? \"PSM\" : \"CAM\")));\n\n\tADD(buf, *len, bufsize, \"sleep duration: %d ms.\\n\", ar->ps.sleep_ms);\n\tADD(buf, *len, bufsize, \"last power-state transition: %d ms ago.\\n\",\n\t    jiffies_to_msecs(jiffies - ar->ps.last_action));\n\tADD(buf, *len, bufsize, \"last CAM->PSM transition: %d ms ago.\\n\",\n\t    jiffies_to_msecs(jiffies - ar->ps.last_slept));\n\n\treturn buf;\n}\nDEBUGFS_DECLARE_RO_FILE(sta_psm, 160);\n\nstatic char *carl9170_debugfs_tx_stuck_read(struct ar9170 *ar, char *buf,\n\t\t\t\t\t    size_t bufsize, ssize_t *len)\n{\n\tint i;\n\n\tfor (i = 0; i < ar->hw->queues; i++) {\n\t\tADD(buf, *len, bufsize, \"TX queue [%d]: %10d max:%10d ms.\\n\",\n\t\t    i, ieee80211_queue_stopped(ar->hw, i) ?\n\t\t    jiffies_to_msecs(jiffies - ar->queue_stop_timeout[i]) : 0,\n\t\t    jiffies_to_msecs(ar->max_queue_stop_timeout[i]));\n\n\t\tar->max_queue_stop_timeout[i] = 0;\n\t}\n\n\treturn buf;\n}\nDEBUGFS_DECLARE_RO_FILE(tx_stuck, 180);\n\nstatic char *carl9170_debugfs_phy_noise_read(struct ar9170 *ar, char *buf,\n\t\t\t\t\t     size_t bufsize, ssize_t *len)\n{\n\tint err;\n\n\terr = carl9170_get_noisefloor(ar);\n\tif (err) {\n\t\t*len = err;\n\t\treturn buf;\n\t}\n\n\tADD(buf, *len, bufsize, \"Chain 0: %10d dBm, ext. chan.:%10d dBm\\n\",\n\t    ar->noise[0], ar->noise[2]);\n\tADD(buf, *len, bufsize, \"Chain 2: %10d dBm, ext. chan.:%10d dBm\\n\",\n\t    ar->noise[1], ar->noise[3]);\n\n\treturn buf;\n}\nDEBUGFS_DECLARE_RO_FILE(phy_noise, 180);\n\nstatic char *carl9170_debugfs_vif_dump_read(struct ar9170 *ar, char *buf,\n\t\t\t\t\t    size_t bufsize, ssize_t *len)\n{\n\tstruct carl9170_vif_info *iter;\n\tint i = 0;\n\n\tADD(buf, *len, bufsize, \"registered VIFs:%d \\\\ %d\\n\",\n\t    ar->vifs, ar->fw.vif_num);\n\n\tADD(buf, *len, bufsize, \"VIF bitmap: [%*pb]\\n\",\n\t    ar->fw.vif_num, &ar->vif_bitmap);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(iter, &ar->vif_list, list) {\n\t\tstruct ieee80211_vif *vif = carl9170_get_vif(iter);\n\t\tADD(buf, *len, bufsize, \"\\t%d = [%s VIF, id:%d, type:%x \"\n\t\t    \" mac:%pM %s]\\n\", i, (carl9170_get_main_vif(ar) == vif ?\n\t\t    \"Master\" : \" Slave\"), iter->id, vif->type, vif->addr,\n\t\t    iter->enable_beacon ? \"beaconing \" : \"\");\n\t\ti++;\n\t}\n\trcu_read_unlock();\n\n\treturn buf;\n}\nDEBUGFS_DECLARE_RO_FILE(vif_dump, 8000);\n\n#define UPDATE_COUNTER(ar, name)\t({\t\t\t\t\\\n\tu32 __tmp[ARRAY_SIZE(name##_regs)];\t\t\t\t\\\n\tunsigned int __i, __err = -ENODEV;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tfor (__i = 0; __i < ARRAY_SIZE(name##_regs); __i++) {\t\t\\\n\t\t__tmp[__i] = name##_regs[__i].reg;\t\t\t\\\n\t\tar->debug.stats.name##_counter[__i] = 0;\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (IS_STARTED(ar))\t\t\t\t\t\t\\\n\t\t__err = carl9170_read_mreg(ar, ARRAY_SIZE(name##_regs),\t\\\n\t\t\t__tmp, ar->debug.stats.name##_counter);\t\t\\\n\t(__err); })\n\n#define TALLY_SUM_UP(ar, name)\tdo {\t\t\t\t\t\\\n\tunsigned int __i;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tfor (__i = 0; __i < ARRAY_SIZE(name##_regs); __i++) {\t\t\\\n\t\tar->debug.stats.name##_sum[__i] +=\t\t\t\\\n\t\t\tar->debug.stats.name##_counter[__i];\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n#define DEBUGFS_HW_TALLY_FILE(name, f)\t\t\t\t\t\\\nstatic char *carl9170_debugfs_##name ## _read(struct ar9170 *ar,\t\\\n\t char *dum, size_t bufsize, ssize_t *ret)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tchar *buf;\t\t\t\t\t\t\t\\\n\tint i, max_len, err;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmax_len = ARRAY_SIZE(name##_regs) * 80;\t\t\t\t\\\n\tbuf = vmalloc(max_len);\t\t\t\t\t\t\\\n\tif (!buf)\t\t\t\t\t\t\t\\\n\t\treturn NULL;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\terr = UPDATE_COUNTER(ar, name);\t\t\t\t\t\\\n\tif (err) {\t\t\t\t\t\t\t\\\n\t\t*ret = err;\t\t\t\t\t\t\\\n\t\treturn buf;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tTALLY_SUM_UP(ar, name);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tfor (i = 0; i < ARRAY_SIZE(name##_regs); i++) {\t\t\t\\\n\t\tADD(buf, *ret, max_len, \"%22s = %\" f \"[+%\" f \"]\\n\",\t\\\n\t\t    name##_regs[i].nreg, ar->debug.stats.name ##_sum[i],\\\n\t\t    ar->debug.stats.name ##_counter[i]);\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn buf;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nDEBUGFS_DECLARE_RO_FILE(name, 0);\n\n#define DEBUGFS_HW_REG_FILE(name, f)\t\t\t\t\t\\\nstatic char *carl9170_debugfs_##name ## _read(struct ar9170 *ar,\t\\\n\tchar *dum, size_t bufsize, ssize_t *ret)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tchar *buf;\t\t\t\t\t\t\t\\\n\tint i, max_len, err;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmax_len = ARRAY_SIZE(name##_regs) * 80;\t\t\t\t\\\n\tbuf = vmalloc(max_len);\t\t\t\t\t\t\\\n\tif (!buf)\t\t\t\t\t\t\t\\\n\t\treturn NULL;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\terr = UPDATE_COUNTER(ar, name);\t\t\t\t\t\\\n\tif (err) {\t\t\t\t\t\t\t\\\n\t\t*ret = err;\t\t\t\t\t\t\\\n\t\treturn buf;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tfor (i = 0; i < ARRAY_SIZE(name##_regs); i++) {\t\t\t\\\n\t\tADD(buf, *ret, max_len, \"%22s = %\" f \"\\n\",\t\t\\\n\t\t    name##_regs[i].nreg,\t\t\t\t\\\n\t\t    ar->debug.stats.name##_counter[i]);\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn buf;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nDEBUGFS_DECLARE_RO_FILE(name, 0);\n\nstatic ssize_t carl9170_debugfs_hw_ioread32_write(struct ar9170 *ar,\n\tconst char *buf, size_t count)\n{\n\tint err = 0, i, n = 0, max_len = 32, res;\n\tunsigned int reg, tmp;\n\n\tif (!count)\n\t\treturn 0;\n\n\tif (count > max_len)\n\t\treturn -E2BIG;\n\n\tres = sscanf(buf, \"0x%X %d\", &reg, &n);\n\tif (res < 1) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (res == 1)\n\t\tn = 1;\n\n\tif (n > 15) {\n\t\terr = -EMSGSIZE;\n\t\tgoto out;\n\t}\n\n\tif ((reg >= 0x280000) || ((reg + (n << 2)) >= 0x280000)) {\n\t\terr = -EADDRNOTAVAIL;\n\t\tgoto out;\n\t}\n\n\tif (reg & 3) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\terr = carl9170_read_reg(ar, reg + (i << 2), &tmp);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tar->debug.ring[ar->debug.ring_tail].reg = reg + (i << 2);\n\t\tar->debug.ring[ar->debug.ring_tail].value = tmp;\n\t\tar->debug.ring_tail++;\n\t\tar->debug.ring_tail %= CARL9170_DEBUG_RING_SIZE;\n\t}\n\nout:\n\treturn err ? err : count;\n}\n\nstatic char *carl9170_debugfs_hw_ioread32_read(struct ar9170 *ar, char *buf,\n\t\t\t\t\t       size_t bufsize, ssize_t *ret)\n{\n\tint i = 0;\n\n\twhile (ar->debug.ring_head != ar->debug.ring_tail) {\n\t\tADD(buf, *ret, bufsize, \"%.8x = %.8x\\n\",\n\t\t    ar->debug.ring[ar->debug.ring_head].reg,\n\t\t    ar->debug.ring[ar->debug.ring_head].value);\n\n\t\tar->debug.ring_head++;\n\t\tar->debug.ring_head %= CARL9170_DEBUG_RING_SIZE;\n\n\t\tif (i++ == 64)\n\t\t\tbreak;\n\t}\n\tar->debug.ring_head = ar->debug.ring_tail;\n\treturn buf;\n}\nDEBUGFS_DECLARE_RW_FILE(hw_ioread32, CARL9170_DEBUG_RING_SIZE * 40);\n\nstatic ssize_t carl9170_debugfs_bug_write(struct ar9170 *ar, const char *buf,\n\t\t\t\t\t  size_t count)\n{\n\tint err;\n\n\tif (count < 1)\n\t\treturn -EINVAL;\n\n\tswitch (buf[0]) {\n\tcase 'F':\n\t\tar->needs_full_reset = true;\n\t\tbreak;\n\n\tcase 'R':\n\t\tif (!IS_STARTED(ar)) {\n\t\t\terr = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\n\t\tar->needs_full_reset = false;\n\t\tbreak;\n\n\tcase 'M':\n\t\terr = carl9170_mac_reset(ar);\n\t\tif (err < 0)\n\t\t\tcount = err;\n\n\t\tgoto out;\n\n\tcase 'P':\n\t\terr = carl9170_set_channel(ar, ar->hw->conf.chandef.chan,\n\t\t\tcfg80211_get_chandef_type(&ar->hw->conf.chandef));\n\t\tif (err < 0)\n\t\t\tcount = err;\n\n\t\tgoto out;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tcarl9170_restart(ar, CARL9170_RR_USER_REQUEST);\n\nout:\n\treturn count;\n}\n\nstatic char *carl9170_debugfs_bug_read(struct ar9170 *ar, char *buf,\n\t\t\t\t       size_t bufsize, ssize_t *ret)\n{\n\tADD(buf, *ret, bufsize, \"[P]hy reinit, [R]estart, [F]ull usb reset, \"\n\t    \"[M]ac reset\\n\");\n\tADD(buf, *ret, bufsize, \"firmware restarts:%d, last reason:%d\\n\",\n\t\tar->restart_counter, ar->last_reason);\n\tADD(buf, *ret, bufsize, \"phy reinit errors:%d (%d)\\n\",\n\t\tar->total_chan_fail, ar->chan_fail);\n\tADD(buf, *ret, bufsize, \"reported firmware errors:%d\\n\",\n\t\tar->fw.err_counter);\n\tADD(buf, *ret, bufsize, \"reported firmware BUGs:%d\\n\",\n\t\tar->fw.bug_counter);\n\tADD(buf, *ret, bufsize, \"pending restart requests:%d\\n\",\n\t\tatomic_read(&ar->pending_restarts));\n\treturn buf;\n}\n__DEBUGFS_DECLARE_RW_FILE(bug, 400, CARL9170_STOPPED);\n\nstatic const char *const erp_modes[] = {\n\t[CARL9170_ERP_INVALID] = \"INVALID\",\n\t[CARL9170_ERP_AUTO] = \"Automatic\",\n\t[CARL9170_ERP_MAC80211] = \"Set by MAC80211\",\n\t[CARL9170_ERP_OFF] = \"Force Off\",\n\t[CARL9170_ERP_RTS] = \"Force RTS\",\n\t[CARL9170_ERP_CTS] = \"Force CTS\"\n};\n\nstatic char *carl9170_debugfs_erp_read(struct ar9170 *ar, char *buf,\n\t\t\t\t       size_t bufsize, ssize_t *ret)\n{\n\tADD(buf, *ret, bufsize, \"ERP Setting: (%d) -> %s\\n\", ar->erp_mode,\n\t    erp_modes[ar->erp_mode]);\n\treturn buf;\n}\n\nstatic ssize_t carl9170_debugfs_erp_write(struct ar9170 *ar, const char *buf,\n\t\t\t\t\t  size_t count)\n{\n\tint res, val;\n\n\tif (count < 1)\n\t\treturn -EINVAL;\n\n\tres = sscanf(buf, \"%d\", &val);\n\tif (res != 1)\n\t\treturn -EINVAL;\n\n\tif (!((val > CARL9170_ERP_INVALID) &&\n\t      (val < __CARL9170_ERP_NUM)))\n\t\treturn -EINVAL;\n\n\tar->erp_mode = val;\n\treturn count;\n}\n\nDEBUGFS_DECLARE_RW_FILE(erp, 80);\n\nstatic ssize_t carl9170_debugfs_hw_iowrite32_write(struct ar9170 *ar,\n\tconst char *buf, size_t count)\n{\n\tint err = 0, max_len = 22, res;\n\tu32 reg, val;\n\n\tif (!count)\n\t\treturn 0;\n\n\tif (count > max_len)\n\t\treturn -E2BIG;\n\n\tres = sscanf(buf, \"0x%X 0x%X\", &reg, &val);\n\tif (res != 2) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (reg <= 0x100000 || reg >= 0x280000) {\n\t\terr = -EADDRNOTAVAIL;\n\t\tgoto out;\n\t}\n\n\tif (reg & 3) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = carl9170_write_reg(ar, reg, val);\n\tif (err)\n\t\tgoto out;\n\nout:\n\treturn err ? err : count;\n}\nDEBUGFS_DECLARE_WO_FILE(hw_iowrite32);\n\nDEBUGFS_HW_TALLY_FILE(hw_tx_tally, \"u\");\nDEBUGFS_HW_TALLY_FILE(hw_rx_tally, \"u\");\nDEBUGFS_HW_TALLY_FILE(hw_phy_errors, \"u\");\nDEBUGFS_HW_REG_FILE(hw_wlan_queue, \".8x\");\nDEBUGFS_HW_REG_FILE(hw_pta_queue, \".8x\");\nDEBUGFS_HW_REG_FILE(hw_ampdu_info, \".8x\");\nDEBUGFS_QUEUE_DUMP(tx_status, 0);\nDEBUGFS_QUEUE_DUMP(tx_status, 1);\nDEBUGFS_QUEUE_DUMP(tx_status, 2);\nDEBUGFS_QUEUE_DUMP(tx_status, 3);\nDEBUGFS_QUEUE_DUMP(tx_pending, 0);\nDEBUGFS_QUEUE_DUMP(tx_pending, 1);\nDEBUGFS_QUEUE_DUMP(tx_pending, 2);\nDEBUGFS_QUEUE_DUMP(tx_pending, 3);\nDEBUGFS_READONLY_FILE(usb_tx_anch_urbs, 20, \"%d\",\n\t\t      atomic_read(&ar->tx_anch_urbs));\nDEBUGFS_READONLY_FILE(usb_rx_anch_urbs, 20, \"%d\",\n\t\t      atomic_read(&ar->rx_anch_urbs));\nDEBUGFS_READONLY_FILE(usb_rx_work_urbs, 20, \"%d\",\n\t\t      atomic_read(&ar->rx_work_urbs));\nDEBUGFS_READONLY_FILE(usb_rx_pool_urbs, 20, \"%d\",\n\t\t      atomic_read(&ar->rx_pool_urbs));\n\nDEBUGFS_READONLY_FILE(tx_total_queued, 20, \"%d\",\n\t\t      atomic_read(&ar->tx_total_queued));\nDEBUGFS_READONLY_FILE(tx_ampdu_scheduler, 20, \"%d\",\n\t\t      atomic_read(&ar->tx_ampdu_scheduler));\n\nDEBUGFS_READONLY_FILE(tx_total_pending, 20, \"%d\",\n\t\t      atomic_read(&ar->tx_total_pending));\n\nDEBUGFS_READONLY_FILE(tx_ampdu_list_len, 20, \"%d\",\n\t\t      ar->tx_ampdu_list_len);\n\nDEBUGFS_READONLY_FILE(tx_ampdu_upload, 20, \"%d\",\n\t\t      atomic_read(&ar->tx_ampdu_upload));\n\nDEBUGFS_READONLY_FILE(tx_janitor_last_run, 64, \"last run:%d ms ago\",\n\tjiffies_to_msecs(jiffies - ar->tx_janitor_last_run));\n\nDEBUGFS_READONLY_FILE(tx_dropped, 20, \"%d\", ar->tx_dropped);\n\nDEBUGFS_READONLY_FILE(rx_dropped, 20, \"%d\", ar->rx_dropped);\n\nDEBUGFS_READONLY_FILE(sniffer_enabled, 20, \"%d\", ar->sniffer_enabled);\nDEBUGFS_READONLY_FILE(rx_software_decryption, 20, \"%d\",\n\t\t      ar->rx_software_decryption);\nDEBUGFS_READONLY_FILE(ampdu_factor, 20, \"%d\",\n\t\t      ar->current_factor);\nDEBUGFS_READONLY_FILE(ampdu_density, 20, \"%d\",\n\t\t      ar->current_density);\n\nDEBUGFS_READONLY_FILE(beacon_int, 20, \"%d TU\", ar->global_beacon_int);\nDEBUGFS_READONLY_FILE(pretbtt, 20, \"%d TU\", ar->global_pretbtt);\n\nvoid carl9170_debugfs_register(struct ar9170 *ar)\n{\n\tar->debug_dir = debugfs_create_dir(KBUILD_MODNAME,\n\t\tar->hw->wiphy->debugfsdir);\n\n#define DEBUGFS_ADD(name)\t\t\t\t\t\t\\\n\tdebugfs_create_file(#name, carl_debugfs_##name ##_ops.attr,\t\\\n\t\t\t    ar->debug_dir, ar,\t\t\t\t\\\n\t\t\t    &carl_debugfs_##name ## _ops.fops)\n\n\tDEBUGFS_ADD(usb_tx_anch_urbs);\n\tDEBUGFS_ADD(usb_rx_pool_urbs);\n\tDEBUGFS_ADD(usb_rx_anch_urbs);\n\tDEBUGFS_ADD(usb_rx_work_urbs);\n\n\tDEBUGFS_ADD(tx_total_queued);\n\tDEBUGFS_ADD(tx_total_pending);\n\tDEBUGFS_ADD(tx_dropped);\n\tDEBUGFS_ADD(tx_stuck);\n\tDEBUGFS_ADD(tx_ampdu_upload);\n\tDEBUGFS_ADD(tx_ampdu_scheduler);\n\tDEBUGFS_ADD(tx_ampdu_list_len);\n\n\tDEBUGFS_ADD(rx_dropped);\n\tDEBUGFS_ADD(sniffer_enabled);\n\tDEBUGFS_ADD(rx_software_decryption);\n\n\tDEBUGFS_ADD(mem_usage);\n\tDEBUGFS_ADD(qos_stat);\n\tDEBUGFS_ADD(sta_psm);\n\tDEBUGFS_ADD(ampdu_state);\n\n\tDEBUGFS_ADD(hw_tx_tally);\n\tDEBUGFS_ADD(hw_rx_tally);\n\tDEBUGFS_ADD(hw_phy_errors);\n\tDEBUGFS_ADD(phy_noise);\n\n\tDEBUGFS_ADD(hw_wlan_queue);\n\tDEBUGFS_ADD(hw_pta_queue);\n\tDEBUGFS_ADD(hw_ampdu_info);\n\n\tDEBUGFS_ADD(ampdu_density);\n\tDEBUGFS_ADD(ampdu_factor);\n\n\tDEBUGFS_ADD(tx_janitor_last_run);\n\n\tDEBUGFS_ADD(tx_status_0);\n\tDEBUGFS_ADD(tx_status_1);\n\tDEBUGFS_ADD(tx_status_2);\n\tDEBUGFS_ADD(tx_status_3);\n\n\tDEBUGFS_ADD(tx_pending_0);\n\tDEBUGFS_ADD(tx_pending_1);\n\tDEBUGFS_ADD(tx_pending_2);\n\tDEBUGFS_ADD(tx_pending_3);\n\n\tDEBUGFS_ADD(hw_ioread32);\n\tDEBUGFS_ADD(hw_iowrite32);\n\tDEBUGFS_ADD(bug);\n\n\tDEBUGFS_ADD(erp);\n\n\tDEBUGFS_ADD(vif_dump);\n\n\tDEBUGFS_ADD(beacon_int);\n\tDEBUGFS_ADD(pretbtt);\n\n#undef DEBUGFS_ADD\n}\n\nvoid carl9170_debugfs_unregister(struct ar9170 *ar)\n{\n\tdebugfs_remove_recursive(ar->debug_dir);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}