{
  "module_name": "led.c",
  "hash_id": "943d6aaa14abc914805f5f21fd8829f9f665b3ad97f6a94900f4c2ed66dcc188",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/carl9170/led.c",
  "human_readable_source": " \n\n#include \"carl9170.h\"\n#include \"cmd.h\"\n\nint carl9170_led_set_state(struct ar9170 *ar, const u32 led_state)\n{\n\treturn carl9170_write_reg(ar, AR9170_GPIO_REG_PORT_DATA, led_state);\n}\n\nint carl9170_led_init(struct ar9170 *ar)\n{\n\tint err;\n\n\t \n\t \n\terr = carl9170_write_reg(ar, AR9170_GPIO_REG_PORT_TYPE, 3);\n\tif (err)\n\t\tgoto out;\n\n\t \n\terr = carl9170_led_set_state(ar, 0);\n\nout:\n\treturn err;\n}\n\n#ifdef CONFIG_CARL9170_LEDS\nstatic void carl9170_led_update(struct work_struct *work)\n{\n\tstruct ar9170 *ar = container_of(work, struct ar9170, led_work.work);\n\tint i, tmp = 300, blink_delay = 1000;\n\tu32 led_val = 0;\n\tbool rerun = false;\n\n\tif (!IS_ACCEPTING_CMD(ar))\n\t\treturn;\n\n\tmutex_lock(&ar->mutex);\n\tfor (i = 0; i < AR9170_NUM_LEDS; i++) {\n\t\tif (ar->leds[i].registered) {\n\t\t\tif (ar->leds[i].last_state ||\n\t\t\t    ar->leds[i].toggled) {\n\n\t\t\t\tif (ar->leds[i].toggled)\n\t\t\t\t\ttmp = 70 + 200 / (ar->leds[i].toggled);\n\n\t\t\t\tif (tmp < blink_delay)\n\t\t\t\t\tblink_delay = tmp;\n\n\t\t\t\tled_val |= 1 << i;\n\t\t\t\tar->leds[i].toggled = 0;\n\t\t\t\trerun = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tcarl9170_led_set_state(ar, led_val);\n\tmutex_unlock(&ar->mutex);\n\n\tif (!rerun)\n\t\treturn;\n\n\tieee80211_queue_delayed_work(ar->hw,\n\t\t\t\t     &ar->led_work,\n\t\t\t\t     msecs_to_jiffies(blink_delay));\n}\n\nstatic void carl9170_led_set_brightness(struct led_classdev *led,\n\t\t\t\t\tenum led_brightness brightness)\n{\n\tstruct carl9170_led *arl = container_of(led, struct carl9170_led, l);\n\tstruct ar9170 *ar = arl->ar;\n\n\tif (!arl->registered)\n\t\treturn;\n\n\tif (arl->last_state != !!brightness) {\n\t\tarl->toggled++;\n\t\tarl->last_state = !!brightness;\n\t}\n\n\tif (likely(IS_ACCEPTING_CMD(ar) && arl->toggled))\n\t\tieee80211_queue_delayed_work(ar->hw, &ar->led_work, HZ / 10);\n}\n\nstatic int carl9170_led_register_led(struct ar9170 *ar, int i, char *name,\n\t\t\t\t     const char *trigger)\n{\n\tint err;\n\n\tsnprintf(ar->leds[i].name, sizeof(ar->leds[i].name),\n\t\t \"carl9170-%s::%s\", wiphy_name(ar->hw->wiphy), name);\n\n\tar->leds[i].ar = ar;\n\tar->leds[i].l.name = ar->leds[i].name;\n\tar->leds[i].l.brightness_set = carl9170_led_set_brightness;\n\tar->leds[i].l.brightness = 0;\n\tar->leds[i].l.default_trigger = trigger;\n\n\terr = led_classdev_register(wiphy_dev(ar->hw->wiphy),\n\t\t\t\t    &ar->leds[i].l);\n\tif (err) {\n\t\twiphy_err(ar->hw->wiphy, \"failed to register %s LED (%d).\\n\",\n\t\t\tar->leds[i].name, err);\n\t} else {\n\t\tar->leds[i].registered = true;\n\t}\n\n\treturn err;\n}\n\nvoid carl9170_led_unregister(struct ar9170 *ar)\n{\n\tint i;\n\n\tfor (i = 0; i < AR9170_NUM_LEDS; i++)\n\t\tif (ar->leds[i].registered) {\n\t\t\tled_classdev_unregister(&ar->leds[i].l);\n\t\t\tar->leds[i].registered = false;\n\t\t\tar->leds[i].toggled = 0;\n\t\t}\n\n\tcancel_delayed_work_sync(&ar->led_work);\n}\n\nint carl9170_led_register(struct ar9170 *ar)\n{\n\tint err;\n\n\tINIT_DELAYED_WORK(&ar->led_work, carl9170_led_update);\n\n\terr = carl9170_led_register_led(ar, 0, \"tx\",\n\t\t\t\t\tieee80211_get_tx_led_name(ar->hw));\n\tif (err)\n\t\tgoto fail;\n\n\tif (ar->features & CARL9170_ONE_LED)\n\t\treturn 0;\n\n\terr = carl9170_led_register_led(ar, 1, \"assoc\",\n\t\t\t\t\tieee80211_get_assoc_led_name(ar->hw));\n\tif (err)\n\t\tgoto fail;\n\n\treturn 0;\n\nfail:\n\tcarl9170_led_unregister(ar);\n\treturn err;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}