{
  "module_name": "main.c",
  "hash_id": "a7b3778f1f84d0ab297f48fb57ac740d833f7d2a1fc067a6a58b267cd72e3bd6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/carl9170/main.c",
  "human_readable_source": " \n\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/etherdevice.h>\n#include <linux/random.h>\n#include <net/mac80211.h>\n#include <net/cfg80211.h>\n#include \"hw.h\"\n#include \"carl9170.h\"\n#include \"cmd.h\"\n\nstatic bool modparam_nohwcrypt;\nmodule_param_named(nohwcrypt, modparam_nohwcrypt, bool, 0444);\nMODULE_PARM_DESC(nohwcrypt, \"Disable hardware crypto offload.\");\n\nint modparam_noht;\nmodule_param_named(noht, modparam_noht, int, 0444);\nMODULE_PARM_DESC(noht, \"Disable MPDU aggregation.\");\n\n#define RATE(_bitrate, _hw_rate, _txpidx, _flags) {\t\\\n\t.bitrate\t= (_bitrate),\t\t\t\\\n\t.flags\t\t= (_flags),\t\t\t\\\n\t.hw_value\t= (_hw_rate) | (_txpidx) << 4,\t\\\n}\n\nstruct ieee80211_rate __carl9170_ratetable[] = {\n\tRATE(10, 0, 0, 0),\n\tRATE(20, 1, 1, IEEE80211_RATE_SHORT_PREAMBLE),\n\tRATE(55, 2, 2, IEEE80211_RATE_SHORT_PREAMBLE),\n\tRATE(110, 3, 3, IEEE80211_RATE_SHORT_PREAMBLE),\n\tRATE(60, 0xb, 0, 0),\n\tRATE(90, 0xf, 0, 0),\n\tRATE(120, 0xa, 0, 0),\n\tRATE(180, 0xe, 0, 0),\n\tRATE(240, 0x9, 0, 0),\n\tRATE(360, 0xd, 1, 0),\n\tRATE(480, 0x8, 2, 0),\n\tRATE(540, 0xc, 3, 0),\n};\n#undef RATE\n\n#define carl9170_g_ratetable\t(__carl9170_ratetable + 0)\n#define carl9170_g_ratetable_size\t12\n#define carl9170_a_ratetable\t(__carl9170_ratetable + 4)\n#define carl9170_a_ratetable_size\t8\n\n \n#define CHAN(_freq, _idx) {\t\t\\\n\t.center_freq\t= (_freq),\t\\\n\t.hw_value\t= (_idx),\t\\\n\t.max_power\t= 18,  \t\\\n}\n\nstatic struct ieee80211_channel carl9170_2ghz_chantable[] = {\n\tCHAN(2412,  0),\n\tCHAN(2417,  1),\n\tCHAN(2422,  2),\n\tCHAN(2427,  3),\n\tCHAN(2432,  4),\n\tCHAN(2437,  5),\n\tCHAN(2442,  6),\n\tCHAN(2447,  7),\n\tCHAN(2452,  8),\n\tCHAN(2457,  9),\n\tCHAN(2462, 10),\n\tCHAN(2467, 11),\n\tCHAN(2472, 12),\n\tCHAN(2484, 13),\n};\n\nstatic struct ieee80211_channel carl9170_5ghz_chantable[] = {\n\tCHAN(4920, 14),\n\tCHAN(4940, 15),\n\tCHAN(4960, 16),\n\tCHAN(4980, 17),\n\tCHAN(5040, 18),\n\tCHAN(5060, 19),\n\tCHAN(5080, 20),\n\tCHAN(5180, 21),\n\tCHAN(5200, 22),\n\tCHAN(5220, 23),\n\tCHAN(5240, 24),\n\tCHAN(5260, 25),\n\tCHAN(5280, 26),\n\tCHAN(5300, 27),\n\tCHAN(5320, 28),\n\tCHAN(5500, 29),\n\tCHAN(5520, 30),\n\tCHAN(5540, 31),\n\tCHAN(5560, 32),\n\tCHAN(5580, 33),\n\tCHAN(5600, 34),\n\tCHAN(5620, 35),\n\tCHAN(5640, 36),\n\tCHAN(5660, 37),\n\tCHAN(5680, 38),\n\tCHAN(5700, 39),\n\tCHAN(5745, 40),\n\tCHAN(5765, 41),\n\tCHAN(5785, 42),\n\tCHAN(5805, 43),\n\tCHAN(5825, 44),\n\tCHAN(5170, 45),\n\tCHAN(5190, 46),\n\tCHAN(5210, 47),\n\tCHAN(5230, 48),\n};\n#undef CHAN\n\n#define CARL9170_HT_CAP\t\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\t.ht_supported\t= true,\t\t\t\t\t\t\\\n\t.cap\t\t= IEEE80211_HT_CAP_MAX_AMSDU |\t\t\t\\\n\t\t\t  IEEE80211_HT_CAP_SUP_WIDTH_20_40 |\t\t\\\n\t\t\t  IEEE80211_HT_CAP_SGI_40 |\t\t\t\\\n\t\t\t  IEEE80211_HT_CAP_DSSSCCK40 |\t\t\t\\\n\t\t\t  IEEE80211_HT_CAP_SM_PS,\t\t\t\\\n\t.ampdu_factor\t= IEEE80211_HT_MAX_AMPDU_64K,\t\t\t\\\n\t.ampdu_density\t= IEEE80211_HT_MPDU_DENSITY_8,\t\t\t\\\n\t.mcs\t\t= {\t\t\t\t\t\t\\\n\t\t.rx_mask = { 0xff, 0xff, 0, 0, 0x1, 0, 0, 0, 0, 0, },\t\\\n\t\t.rx_highest = cpu_to_le16(300),\t\t\t\t\\\n\t\t.tx_params = IEEE80211_HT_MCS_TX_DEFINED,\t\t\\\n\t},\t\t\t\t\t\t\t\t\\\n}\n\nstatic struct ieee80211_supported_band carl9170_band_2GHz = {\n\t.channels\t= carl9170_2ghz_chantable,\n\t.n_channels\t= ARRAY_SIZE(carl9170_2ghz_chantable),\n\t.bitrates\t= carl9170_g_ratetable,\n\t.n_bitrates\t= carl9170_g_ratetable_size,\n\t.ht_cap\t\t= CARL9170_HT_CAP,\n};\n\nstatic struct ieee80211_supported_band carl9170_band_5GHz = {\n\t.channels\t= carl9170_5ghz_chantable,\n\t.n_channels\t= ARRAY_SIZE(carl9170_5ghz_chantable),\n\t.bitrates\t= carl9170_a_ratetable,\n\t.n_bitrates\t= carl9170_a_ratetable_size,\n\t.ht_cap\t\t= CARL9170_HT_CAP,\n};\n\nstatic void carl9170_ampdu_gc(struct ar9170 *ar)\n{\n\tstruct carl9170_sta_tid *tid_info;\n\tLIST_HEAD(tid_gc);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(tid_info, &ar->tx_ampdu_list, list) {\n\t\tspin_lock_bh(&ar->tx_ampdu_list_lock);\n\t\tif (tid_info->state == CARL9170_TID_STATE_SHUTDOWN) {\n\t\t\ttid_info->state = CARL9170_TID_STATE_KILLED;\n\t\t\tlist_del_rcu(&tid_info->list);\n\t\t\tar->tx_ampdu_list_len--;\n\t\t\tlist_add_tail(&tid_info->tmp_list, &tid_gc);\n\t\t}\n\t\tspin_unlock_bh(&ar->tx_ampdu_list_lock);\n\n\t}\n\trcu_assign_pointer(ar->tx_ampdu_iter, tid_info);\n\trcu_read_unlock();\n\n\tsynchronize_rcu();\n\n\twhile (!list_empty(&tid_gc)) {\n\t\tstruct sk_buff *skb;\n\t\ttid_info = list_first_entry(&tid_gc, struct carl9170_sta_tid,\n\t\t\t\t\t    tmp_list);\n\n\t\twhile ((skb = __skb_dequeue(&tid_info->queue)))\n\t\t\tcarl9170_tx_status(ar, skb, false);\n\n\t\tlist_del_init(&tid_info->tmp_list);\n\t\tkfree(tid_info);\n\t}\n}\n\nstatic void carl9170_flush(struct ar9170 *ar, bool drop_queued)\n{\n\tif (drop_queued) {\n\t\tint i;\n\n\t\t \n\n\t\tfor (i = 0; i < ar->hw->queues; i++) {\n\t\t\tstruct sk_buff *skb;\n\n\t\t\twhile ((skb = skb_dequeue(&ar->tx_pending[i]))) {\n\t\t\t\tstruct ieee80211_tx_info *info;\n\n\t\t\t\tinfo = IEEE80211_SKB_CB(skb);\n\t\t\t\tif (info->flags & IEEE80211_TX_CTL_AMPDU)\n\t\t\t\t\tatomic_dec(&ar->tx_ampdu_upload);\n\n\t\t\t\tcarl9170_tx_status(ar, skb, false);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (atomic_read(&ar->tx_total_queued))\n\t\tWARN_ON(wait_for_completion_timeout(&ar->tx_flush, HZ) == 0);\n}\n\nstatic void carl9170_flush_ba(struct ar9170 *ar)\n{\n\tstruct sk_buff_head free;\n\tstruct carl9170_sta_tid *tid_info;\n\tstruct sk_buff *skb;\n\n\t__skb_queue_head_init(&free);\n\n\trcu_read_lock();\n\tspin_lock_bh(&ar->tx_ampdu_list_lock);\n\tlist_for_each_entry_rcu(tid_info, &ar->tx_ampdu_list, list) {\n\t\tif (tid_info->state > CARL9170_TID_STATE_SUSPEND) {\n\t\t\ttid_info->state = CARL9170_TID_STATE_SUSPEND;\n\n\t\t\tspin_lock(&tid_info->lock);\n\t\t\twhile ((skb = __skb_dequeue(&tid_info->queue)))\n\t\t\t\t__skb_queue_tail(&free, skb);\n\t\t\tspin_unlock(&tid_info->lock);\n\t\t}\n\t}\n\tspin_unlock_bh(&ar->tx_ampdu_list_lock);\n\trcu_read_unlock();\n\n\twhile ((skb = __skb_dequeue(&free)))\n\t\tcarl9170_tx_status(ar, skb, false);\n}\n\nstatic void carl9170_zap_queues(struct ar9170 *ar)\n{\n\tstruct carl9170_vif_info *cvif;\n\tunsigned int i;\n\n\tcarl9170_ampdu_gc(ar);\n\n\tcarl9170_flush_ba(ar);\n\tcarl9170_flush(ar, true);\n\n\tfor (i = 0; i < ar->hw->queues; i++) {\n\t\tspin_lock_bh(&ar->tx_status[i].lock);\n\t\twhile (!skb_queue_empty(&ar->tx_status[i])) {\n\t\t\tstruct sk_buff *skb;\n\n\t\t\tskb = skb_peek(&ar->tx_status[i]);\n\t\t\tcarl9170_tx_get_skb(skb);\n\t\t\tspin_unlock_bh(&ar->tx_status[i].lock);\n\t\t\tcarl9170_tx_drop(ar, skb);\n\t\t\tspin_lock_bh(&ar->tx_status[i].lock);\n\t\t\tcarl9170_tx_put_skb(skb);\n\t\t}\n\t\tspin_unlock_bh(&ar->tx_status[i].lock);\n\t}\n\n\tBUILD_BUG_ON(CARL9170_NUM_TX_LIMIT_SOFT < 1);\n\tBUILD_BUG_ON(CARL9170_NUM_TX_LIMIT_HARD < CARL9170_NUM_TX_LIMIT_SOFT);\n\tBUILD_BUG_ON(CARL9170_NUM_TX_LIMIT_HARD >= CARL9170_BAW_BITS);\n\n\t \n\tmemset(&ar->tx_stats, 0, sizeof(ar->tx_stats));\n\tfor (i = 0; i < ar->hw->queues; i++)\n\t\tar->tx_stats[i].limit = CARL9170_NUM_TX_LIMIT_HARD;\n\n\tbitmap_zero(ar->mem_bitmap, ar->fw.mem_blocks);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(cvif, &ar->vif_list, list) {\n\t\tspin_lock_bh(&ar->beacon_lock);\n\t\tdev_kfree_skb_any(cvif->beacon);\n\t\tcvif->beacon = NULL;\n\t\tspin_unlock_bh(&ar->beacon_lock);\n\t}\n\trcu_read_unlock();\n\n\tatomic_set(&ar->tx_ampdu_upload, 0);\n\tatomic_set(&ar->tx_ampdu_scheduler, 0);\n\tatomic_set(&ar->tx_total_pending, 0);\n\tatomic_set(&ar->tx_total_queued, 0);\n\tatomic_set(&ar->mem_free_blocks, ar->fw.mem_blocks);\n}\n\n#define CARL9170_FILL_QUEUE(queue, ai_fs, cwmin, cwmax, _txop)\t\t\\\ndo {\t\t\t\t\t\t\t\t\t\\\n\tqueue.aifs = ai_fs;\t\t\t\t\t\t\\\n\tqueue.cw_min = cwmin;\t\t\t\t\t\t\\\n\tqueue.cw_max = cwmax;\t\t\t\t\t\t\\\n\tqueue.txop = _txop;\t\t\t\t\t\t\\\n} while (0)\n\nstatic int carl9170_op_start(struct ieee80211_hw *hw)\n{\n\tstruct ar9170 *ar = hw->priv;\n\tint err, i;\n\n\tmutex_lock(&ar->mutex);\n\n\tcarl9170_zap_queues(ar);\n\n\t \n\tCARL9170_FILL_QUEUE(ar->edcf[AR9170_TXQ_VO], 2, 3,     7, 47);\n\tCARL9170_FILL_QUEUE(ar->edcf[AR9170_TXQ_VI], 2, 7,    15, 94);\n\tCARL9170_FILL_QUEUE(ar->edcf[AR9170_TXQ_BE], 3, 15, 1023,  0);\n\tCARL9170_FILL_QUEUE(ar->edcf[AR9170_TXQ_BK], 7, 15, 1023,  0);\n\tCARL9170_FILL_QUEUE(ar->edcf[AR9170_TXQ_SPECIAL], 2, 3, 7, 0);\n\n\tar->current_factor = ar->current_density = -1;\n\t \n\tar->usedkeys = 1;\n\tar->filter_state = 0;\n\tar->ps.last_action = jiffies;\n\tar->ps.last_slept = jiffies;\n\tar->erp_mode = CARL9170_ERP_AUTO;\n\n\t \n\tar->disable_offload = modparam_nohwcrypt |\n\t\tar->fw.disable_offload_fw;\n\tar->rx_software_decryption = ar->disable_offload;\n\n\tfor (i = 0; i < ar->hw->queues; i++) {\n\t\tar->queue_stop_timeout[i] = jiffies;\n\t\tar->max_queue_stop_timeout[i] = 0;\n\t}\n\n\tatomic_set(&ar->mem_allocs, 0);\n\n\terr = carl9170_usb_open(ar);\n\tif (err)\n\t\tgoto out;\n\n\terr = carl9170_init_mac(ar);\n\tif (err)\n\t\tgoto out;\n\n\terr = carl9170_set_qos(ar);\n\tif (err)\n\t\tgoto out;\n\n\tif (ar->fw.rx_filter) {\n\t\terr = carl9170_rx_filter(ar, CARL9170_RX_FILTER_OTHER_RA |\n\t\t\tCARL9170_RX_FILTER_CTL_OTHER | CARL9170_RX_FILTER_BAD);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = carl9170_write_reg(ar, AR9170_MAC_REG_DMA_TRIGGER,\n\t\t\t\t AR9170_DMA_TRIGGER_RXQ);\n\tif (err)\n\t\tgoto out;\n\n\t \n\tfor (i = 0; i < AR9170_CAM_MAX_USER + 4; i++) {\n\t\terr = carl9170_upload_key(ar, i, NULL, AR9170_ENC_ALG_NONE,\n\t\t\t\t\t  0, NULL, 0);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = carl9170_upload_key(ar, i, NULL, AR9170_ENC_ALG_NONE,\n\t\t\t\t\t  1, NULL, 0);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (i < AR9170_CAM_MAX_USER) {\n\t\t\terr = carl9170_disable_key(ar, i);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tcarl9170_set_state_when(ar, CARL9170_IDLE, CARL9170_STARTED);\n\n\tieee80211_queue_delayed_work(ar->hw, &ar->stat_work,\n\t\tround_jiffies(msecs_to_jiffies(CARL9170_STAT_WORK)));\n\n\tieee80211_wake_queues(ar->hw);\n\terr = 0;\n\nout:\n\tmutex_unlock(&ar->mutex);\n\treturn err;\n}\n\nstatic void carl9170_cancel_worker(struct ar9170 *ar)\n{\n\tcancel_delayed_work_sync(&ar->stat_work);\n\tcancel_delayed_work_sync(&ar->tx_janitor);\n#ifdef CONFIG_CARL9170_LEDS\n\tcancel_delayed_work_sync(&ar->led_work);\n#endif  \n\tcancel_work_sync(&ar->ps_work);\n\tcancel_work_sync(&ar->ping_work);\n\tcancel_work_sync(&ar->ampdu_work);\n}\n\nstatic void carl9170_op_stop(struct ieee80211_hw *hw)\n{\n\tstruct ar9170 *ar = hw->priv;\n\n\tcarl9170_set_state_when(ar, CARL9170_STARTED, CARL9170_IDLE);\n\n\tieee80211_stop_queues(ar->hw);\n\n\tmutex_lock(&ar->mutex);\n\tif (IS_ACCEPTING_CMD(ar)) {\n\t\tRCU_INIT_POINTER(ar->beacon_iter, NULL);\n\n\t\tcarl9170_led_set_state(ar, 0);\n\n\t\t \n\t\tcarl9170_write_reg(ar, AR9170_MAC_REG_DMA_TRIGGER, 0);\n\t\tcarl9170_usb_stop(ar);\n\t}\n\n\tcarl9170_zap_queues(ar);\n\tmutex_unlock(&ar->mutex);\n\n\tcarl9170_cancel_worker(ar);\n}\n\nstatic void carl9170_restart_work(struct work_struct *work)\n{\n\tstruct ar9170 *ar = container_of(work, struct ar9170,\n\t\t\t\t\t restart_work);\n\tint err = -EIO;\n\n\tar->usedkeys = 0;\n\tar->filter_state = 0;\n\tcarl9170_cancel_worker(ar);\n\n\tmutex_lock(&ar->mutex);\n\tif (!ar->force_usb_reset) {\n\t\terr = carl9170_usb_restart(ar);\n\t\tif (net_ratelimit()) {\n\t\t\tif (err)\n\t\t\t\tdev_err(&ar->udev->dev, \"Failed to restart device (%d).\\n\", err);\n\t\t\telse\n\t\t\t\tdev_info(&ar->udev->dev, \"device restarted successfully.\\n\");\n\t\t}\n\t}\n\tcarl9170_zap_queues(ar);\n\tmutex_unlock(&ar->mutex);\n\n\tif (!err && !ar->force_usb_reset) {\n\t\tar->restart_counter++;\n\t\tatomic_set(&ar->pending_restarts, 0);\n\n\t\tieee80211_restart_hw(ar->hw);\n\t} else {\n\t\t \n\n\t\tcarl9170_usb_reset(ar);\n\t}\n}\n\nvoid carl9170_restart(struct ar9170 *ar, const enum carl9170_restart_reasons r)\n{\n\tcarl9170_set_state_when(ar, CARL9170_STARTED, CARL9170_IDLE);\n\n\t \n\tif (atomic_inc_return(&ar->pending_restarts) > 1) {\n\t\tdev_dbg(&ar->udev->dev, \"ignoring restart (%d)\\n\", r);\n\t\treturn;\n\t}\n\n\tieee80211_stop_queues(ar->hw);\n\n\tdev_err(&ar->udev->dev, \"restart device (%d)\\n\", r);\n\n\tif (!WARN_ON(r == CARL9170_RR_NO_REASON) ||\n\t    !WARN_ON(r >= __CARL9170_RR_LAST))\n\t\tar->last_reason = r;\n\n\tif (!ar->registered)\n\t\treturn;\n\n\tif (!IS_ACCEPTING_CMD(ar) || ar->needs_full_reset)\n\t\tar->force_usb_reset = true;\n\n\tieee80211_queue_work(ar->hw, &ar->restart_work);\n\n\t \n}\n\nstatic void carl9170_ping_work(struct work_struct *work)\n{\n\tstruct ar9170 *ar = container_of(work, struct ar9170, ping_work);\n\tint err;\n\n\tif (!IS_STARTED(ar))\n\t\treturn;\n\n\tmutex_lock(&ar->mutex);\n\terr = carl9170_echo_test(ar, 0xdeadbeef);\n\tif (err)\n\t\tcarl9170_restart(ar, CARL9170_RR_UNRESPONSIVE_DEVICE);\n\tmutex_unlock(&ar->mutex);\n}\n\nstatic int carl9170_init_interface(struct ar9170 *ar,\n\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tstruct ath_common *common = &ar->common;\n\tint err;\n\n\tif (!vif) {\n\t\tWARN_ON_ONCE(IS_STARTED(ar));\n\t\treturn 0;\n\t}\n\n\tmemcpy(common->macaddr, vif->addr, ETH_ALEN);\n\n\t \n\tar->disable_offload |= ((vif->type != NL80211_IFTYPE_STATION) &&\n\t    (vif->type != NL80211_IFTYPE_AP));\n\n\t \n\tar->disable_offload |= vif->p2p;\n\n\tar->rx_software_decryption = ar->disable_offload;\n\n\terr = carl9170_set_operating_mode(ar);\n\treturn err;\n}\n\nstatic int carl9170_op_add_interface(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct carl9170_vif_info *vif_priv = (void *) vif->drv_priv;\n\tstruct ieee80211_vif *main_vif, *old_main = NULL;\n\tstruct ar9170 *ar = hw->priv;\n\tint vif_id = -1, err = 0;\n\n\tmutex_lock(&ar->mutex);\n\trcu_read_lock();\n\tif (vif_priv->active) {\n\t\t \n\t\tvif_id = vif_priv->id;\n\t\tvif_priv->enable_beacon = false;\n\n\t\tspin_lock_bh(&ar->beacon_lock);\n\t\tdev_kfree_skb_any(vif_priv->beacon);\n\t\tvif_priv->beacon = NULL;\n\t\tspin_unlock_bh(&ar->beacon_lock);\n\n\t\tgoto init;\n\t}\n\n\t \n\tmain_vif = carl9170_get_main_vif(ar);\n\n\tif (main_vif) {\n\t\tswitch (main_vif->type) {\n\t\tcase NL80211_IFTYPE_STATION:\n\t\t\tif (vif->type == NL80211_IFTYPE_STATION)\n\t\t\t\tbreak;\n\n\t\t\terr = -EBUSY;\n\t\t\trcu_read_unlock();\n\n\t\t\tgoto unlock;\n\n\t\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tcase NL80211_IFTYPE_AP:\n\t\t\tif ((vif->type == NL80211_IFTYPE_STATION) ||\n\t\t\t    (vif->type == NL80211_IFTYPE_AP) ||\n\t\t\t    (vif->type == NL80211_IFTYPE_MESH_POINT))\n\t\t\t\tbreak;\n\n\t\t\terr = -EBUSY;\n\t\t\trcu_read_unlock();\n\t\t\tgoto unlock;\n\n\t\tdefault:\n\t\t\trcu_read_unlock();\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tvif_id = bitmap_find_free_region(&ar->vif_bitmap, ar->fw.vif_num, 0);\n\n\tif (vif_id < 0) {\n\t\trcu_read_unlock();\n\n\t\terr = -ENOSPC;\n\t\tgoto unlock;\n\t}\n\n\tBUG_ON(ar->vif_priv[vif_id].id != vif_id);\n\n\tvif_priv->active = true;\n\tvif_priv->id = vif_id;\n\tvif_priv->enable_beacon = false;\n\tar->vifs++;\n\tif (old_main) {\n\t\t \n\t\tlist_add_rcu(&vif_priv->list, &ar->vif_list);\n\t} else {\n\t\t \n\t\tlist_add_tail_rcu(&vif_priv->list, &ar->vif_list);\n\t}\n\trcu_assign_pointer(ar->vif_priv[vif_id].vif, vif);\n\ninit:\n\tmain_vif = carl9170_get_main_vif(ar);\n\n\tif (main_vif == vif) {\n\t\trcu_assign_pointer(ar->beacon_iter, vif_priv);\n\t\trcu_read_unlock();\n\n\t\tif (old_main) {\n\t\t\tstruct carl9170_vif_info *old_main_priv =\n\t\t\t\t(void *) old_main->drv_priv;\n\t\t\t \n\t\t\terr = carl9170_mod_virtual_mac(ar, old_main_priv->id,\n\t\t\t\t\t\t       old_main->addr);\n\t\t\tif (err)\n\t\t\t\tgoto unlock;\n\t\t}\n\n\t\terr = carl9170_init_interface(ar, vif);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t} else {\n\t\trcu_read_unlock();\n\t\terr = carl9170_mod_virtual_mac(ar, vif_id, vif->addr);\n\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\n\tif (ar->fw.tx_seq_table) {\n\t\terr = carl9170_write_reg(ar, ar->fw.tx_seq_table + vif_id * 4,\n\t\t\t\t\t 0);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\nunlock:\n\tif (err && (vif_id >= 0)) {\n\t\tvif_priv->active = false;\n\t\tbitmap_release_region(&ar->vif_bitmap, vif_id, 0);\n\t\tar->vifs--;\n\t\tRCU_INIT_POINTER(ar->vif_priv[vif_id].vif, NULL);\n\t\tlist_del_rcu(&vif_priv->list);\n\t\tmutex_unlock(&ar->mutex);\n\t\tsynchronize_rcu();\n\t} else {\n\t\tif (ar->vifs > 1)\n\t\t\tar->ps.off_override |= PS_OFF_VIF;\n\n\t\tmutex_unlock(&ar->mutex);\n\t}\n\n\treturn err;\n}\n\nstatic void carl9170_op_remove_interface(struct ieee80211_hw *hw,\n\t\t\t\t\t struct ieee80211_vif *vif)\n{\n\tstruct carl9170_vif_info *vif_priv = (void *) vif->drv_priv;\n\tstruct ieee80211_vif *main_vif;\n\tstruct ar9170 *ar = hw->priv;\n\tunsigned int id;\n\n\tmutex_lock(&ar->mutex);\n\n\tif (WARN_ON_ONCE(!vif_priv->active))\n\t\tgoto unlock;\n\n\tar->vifs--;\n\n\trcu_read_lock();\n\tmain_vif = carl9170_get_main_vif(ar);\n\n\tid = vif_priv->id;\n\n\tvif_priv->active = false;\n\tWARN_ON(vif_priv->enable_beacon);\n\tvif_priv->enable_beacon = false;\n\tlist_del_rcu(&vif_priv->list);\n\tRCU_INIT_POINTER(ar->vif_priv[id].vif, NULL);\n\n\tif (vif == main_vif) {\n\t\trcu_read_unlock();\n\n\t\tif (ar->vifs) {\n\t\t\tWARN_ON(carl9170_init_interface(ar,\n\t\t\t\t\tcarl9170_get_main_vif(ar)));\n\t\t} else {\n\t\t\tcarl9170_set_operating_mode(ar);\n\t\t}\n\t} else {\n\t\trcu_read_unlock();\n\n\t\tWARN_ON(carl9170_mod_virtual_mac(ar, id, NULL));\n\t}\n\n\tcarl9170_update_beacon(ar, false);\n\tcarl9170_flush_cab(ar, id);\n\n\tspin_lock_bh(&ar->beacon_lock);\n\tdev_kfree_skb_any(vif_priv->beacon);\n\tvif_priv->beacon = NULL;\n\tspin_unlock_bh(&ar->beacon_lock);\n\n\tbitmap_release_region(&ar->vif_bitmap, id, 0);\n\n\tcarl9170_set_beacon_timers(ar);\n\n\tif (ar->vifs == 1)\n\t\tar->ps.off_override &= ~PS_OFF_VIF;\n\nunlock:\n\tmutex_unlock(&ar->mutex);\n\n\tsynchronize_rcu();\n}\n\nvoid carl9170_ps_check(struct ar9170 *ar)\n{\n\tieee80211_queue_work(ar->hw, &ar->ps_work);\n}\n\n \nstatic int carl9170_ps_update(struct ar9170 *ar)\n{\n\tbool ps = false;\n\tint err = 0;\n\n\tif (!ar->ps.off_override)\n\t\tps = (ar->hw->conf.flags & IEEE80211_CONF_PS);\n\n\tif (ps != ar->ps.state) {\n\t\terr = carl9170_powersave(ar, ps);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (ar->ps.state && !ps) {\n\t\t\tar->ps.sleep_ms = jiffies_to_msecs(jiffies -\n\t\t\t\tar->ps.last_action);\n\t\t}\n\n\t\tif (ps)\n\t\t\tar->ps.last_slept = jiffies;\n\n\t\tar->ps.last_action = jiffies;\n\t\tar->ps.state = ps;\n\t}\n\n\treturn 0;\n}\n\nstatic void carl9170_ps_work(struct work_struct *work)\n{\n\tstruct ar9170 *ar = container_of(work, struct ar9170,\n\t\t\t\t\t ps_work);\n\tmutex_lock(&ar->mutex);\n\tif (IS_STARTED(ar))\n\t\tWARN_ON_ONCE(carl9170_ps_update(ar) != 0);\n\tmutex_unlock(&ar->mutex);\n}\n\nstatic int carl9170_update_survey(struct ar9170 *ar, bool flush, bool noise)\n{\n\tint err;\n\n\tif (noise) {\n\t\terr = carl9170_get_noisefloor(ar);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (ar->fw.hw_counters) {\n\t\terr = carl9170_collect_tally(ar);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (flush)\n\t\tmemset(&ar->tally, 0, sizeof(ar->tally));\n\n\treturn 0;\n}\n\nstatic void carl9170_stat_work(struct work_struct *work)\n{\n\tstruct ar9170 *ar = container_of(work, struct ar9170, stat_work.work);\n\tint err;\n\n\tmutex_lock(&ar->mutex);\n\terr = carl9170_update_survey(ar, false, true);\n\tmutex_unlock(&ar->mutex);\n\n\tif (err)\n\t\treturn;\n\n\tieee80211_queue_delayed_work(ar->hw, &ar->stat_work,\n\t\tround_jiffies(msecs_to_jiffies(CARL9170_STAT_WORK)));\n}\n\nstatic int carl9170_op_config(struct ieee80211_hw *hw, u32 changed)\n{\n\tstruct ar9170 *ar = hw->priv;\n\tint err = 0;\n\n\tmutex_lock(&ar->mutex);\n\tif (changed & IEEE80211_CONF_CHANGE_LISTEN_INTERVAL) {\n\t\t \n\t\terr = 0;\n\t}\n\n\tif (changed & IEEE80211_CONF_CHANGE_PS) {\n\t\terr = carl9170_ps_update(ar);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (changed & IEEE80211_CONF_CHANGE_SMPS) {\n\t\t \n\t\terr = 0;\n\t}\n\n\tif (changed & IEEE80211_CONF_CHANGE_CHANNEL) {\n\t\tenum nl80211_channel_type channel_type =\n\t\t\tcfg80211_get_chandef_type(&hw->conf.chandef);\n\n\t\t \n\t\terr = carl9170_set_slot_time(ar);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = carl9170_update_survey(ar, true, false);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = carl9170_set_channel(ar, hw->conf.chandef.chan,\n\t\t\t\t\t   channel_type);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = carl9170_update_survey(ar, false, true);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = carl9170_set_dyn_sifs_ack(ar);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = carl9170_set_rts_cts_rate(ar);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (changed & IEEE80211_CONF_CHANGE_POWER) {\n\t\terr = carl9170_set_mac_tpc(ar, ar->hw->conf.chandef.chan);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\nout:\n\tmutex_unlock(&ar->mutex);\n\treturn err;\n}\n\nstatic u64 carl9170_op_prepare_multicast(struct ieee80211_hw *hw,\n\t\t\t\t\t struct netdev_hw_addr_list *mc_list)\n{\n\tstruct netdev_hw_addr *ha;\n\tu64 mchash;\n\n\t \n\tmchash = 1ULL << (0xff >> 2);\n\n\tnetdev_hw_addr_list_for_each(ha, mc_list)\n\t\tmchash |= 1ULL << (ha->addr[5] >> 2);\n\n\treturn mchash;\n}\n\nstatic void carl9170_op_configure_filter(struct ieee80211_hw *hw,\n\t\t\t\t\t unsigned int changed_flags,\n\t\t\t\t\t unsigned int *new_flags,\n\t\t\t\t\t u64 multicast)\n{\n\tstruct ar9170 *ar = hw->priv;\n\n\t \n\t*new_flags &= FIF_ALLMULTI | ar->rx_filter_caps;\n\n\tif (!IS_ACCEPTING_CMD(ar))\n\t\treturn;\n\n\tmutex_lock(&ar->mutex);\n\n\tar->filter_state = *new_flags;\n\t \n\n\tif (*new_flags & FIF_ALLMULTI)\n\t\tmulticast = ~0ULL;\n\n\tif (multicast != ar->cur_mc_hash)\n\t\tWARN_ON(carl9170_update_multicast(ar, multicast));\n\n\tif (changed_flags & FIF_OTHER_BSS) {\n\t\tar->sniffer_enabled = !!(*new_flags & FIF_OTHER_BSS);\n\n\t\tWARN_ON(carl9170_set_operating_mode(ar));\n\t}\n\n\tif (ar->fw.rx_filter && changed_flags & ar->rx_filter_caps) {\n\t\tu32 rx_filter = 0;\n\n\t\tif (!ar->fw.ba_filter)\n\t\t\trx_filter |= CARL9170_RX_FILTER_CTL_OTHER;\n\n\t\tif (!(*new_flags & (FIF_FCSFAIL | FIF_PLCPFAIL)))\n\t\t\trx_filter |= CARL9170_RX_FILTER_BAD;\n\n\t\tif (!(*new_flags & FIF_CONTROL))\n\t\t\trx_filter |= CARL9170_RX_FILTER_CTL_OTHER;\n\n\t\tif (!(*new_flags & FIF_PSPOLL))\n\t\t\trx_filter |= CARL9170_RX_FILTER_CTL_PSPOLL;\n\n\t\tif (!(*new_flags & FIF_OTHER_BSS)) {\n\t\t\trx_filter |= CARL9170_RX_FILTER_OTHER_RA;\n\t\t\trx_filter |= CARL9170_RX_FILTER_DECRY_FAIL;\n\t\t}\n\n\t\tWARN_ON(carl9170_rx_filter(ar, rx_filter));\n\t}\n\n\tmutex_unlock(&ar->mutex);\n}\n\n\nstatic void carl9170_op_bss_info_changed(struct ieee80211_hw *hw,\n\t\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t\t struct ieee80211_bss_conf *bss_conf,\n\t\t\t\t\t u64 changed)\n{\n\tstruct ar9170 *ar = hw->priv;\n\tstruct ath_common *common = &ar->common;\n\tint err = 0;\n\tstruct carl9170_vif_info *vif_priv;\n\tstruct ieee80211_vif *main_vif;\n\n\tmutex_lock(&ar->mutex);\n\tvif_priv = (void *) vif->drv_priv;\n\tmain_vif = carl9170_get_main_vif(ar);\n\tif (WARN_ON(!main_vif))\n\t\tgoto out;\n\n\tif (changed & BSS_CHANGED_BEACON_ENABLED) {\n\t\tstruct carl9170_vif_info *iter;\n\t\tint i = 0;\n\n\t\tvif_priv->enable_beacon = bss_conf->enable_beacon;\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(iter, &ar->vif_list, list) {\n\t\t\tif (iter->active && iter->enable_beacon)\n\t\t\t\ti++;\n\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tar->beacon_enabled = i;\n\t}\n\n\tif (changed & BSS_CHANGED_BEACON) {\n\t\terr = carl9170_update_beacon(ar, false);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (changed & (BSS_CHANGED_BEACON_ENABLED | BSS_CHANGED_BEACON |\n\t\t       BSS_CHANGED_BEACON_INT)) {\n\n\t\tif (main_vif != vif) {\n\t\t\tbss_conf->beacon_int = main_vif->bss_conf.beacon_int;\n\t\t\tbss_conf->dtim_period = main_vif->bss_conf.dtim_period;\n\t\t}\n\n\t\t \n\t\tif (vif->type != NL80211_IFTYPE_STATION &&\n\t\t    (bss_conf->beacon_int * bss_conf->dtim_period >=\n\t\t     (CARL9170_QUEUE_STUCK_TIMEOUT / 2))) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = carl9170_set_beacon_timers(ar);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (changed & BSS_CHANGED_HT) {\n\t\t \n\t\terr = 0;\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (main_vif != vif)\n\t\tgoto out;\n\n\t \n\n\tif (changed & BSS_CHANGED_BSSID) {\n\t\tmemcpy(common->curbssid, bss_conf->bssid, ETH_ALEN);\n\t\terr = carl9170_set_operating_mode(ar);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (changed & BSS_CHANGED_ASSOC) {\n\t\tar->common.curaid = vif->cfg.aid;\n\t\terr = carl9170_set_beacon_timers(ar);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (changed & BSS_CHANGED_ERP_SLOT) {\n\t\terr = carl9170_set_slot_time(ar);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (changed & BSS_CHANGED_BASIC_RATES) {\n\t\terr = carl9170_set_mac_rates(ar);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\nout:\n\tWARN_ON_ONCE(err && IS_STARTED(ar));\n\tmutex_unlock(&ar->mutex);\n}\n\nstatic u64 carl9170_op_get_tsf(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif)\n{\n\tstruct ar9170 *ar = hw->priv;\n\tstruct carl9170_tsf_rsp tsf;\n\tint err;\n\n\tmutex_lock(&ar->mutex);\n\terr = carl9170_exec_cmd(ar, CARL9170_CMD_READ_TSF,\n\t\t\t\t0, NULL, sizeof(tsf), &tsf);\n\tmutex_unlock(&ar->mutex);\n\tif (WARN_ON(err))\n\t\treturn 0;\n\n\treturn le64_to_cpu(tsf.tsf_64);\n}\n\nstatic int carl9170_op_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       struct ieee80211_sta *sta,\n\t\t\t       struct ieee80211_key_conf *key)\n{\n\tstruct ar9170 *ar = hw->priv;\n\tint err = 0, i;\n\tu8 ktype;\n\n\tif (ar->disable_offload || !vif)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\n\tif (!is_main_vif(ar, vif)) {\n\t\tmutex_lock(&ar->mutex);\n\t\tgoto err_softw;\n\t}\n\n\t \n\tif ((vif->type != NL80211_IFTYPE_STATION &&\n\t     vif->type != NL80211_IFTYPE_ADHOC) &&\n\t    !(key->flags & IEEE80211_KEY_FLAG_PAIRWISE))\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (key->cipher) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\tktype = AR9170_ENC_ALG_WEP64;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\tktype = AR9170_ENC_ALG_WEP128;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\tktype = AR9170_ENC_ALG_TKIP;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tktype = AR9170_ENC_ALG_AESCCMP;\n\t\tkey->flags |= IEEE80211_KEY_FLAG_SW_MGMT_TX;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmutex_lock(&ar->mutex);\n\tif (cmd == SET_KEY) {\n\t\tif (!IS_STARTED(ar)) {\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!(key->flags & IEEE80211_KEY_FLAG_PAIRWISE)) {\n\t\t\tsta = NULL;\n\n\t\t\ti = 64 + key->keyidx;\n\t\t} else {\n\t\t\tfor (i = 0; i < 64; i++)\n\t\t\t\tif (!(ar->usedkeys & BIT(i)))\n\t\t\t\t\tbreak;\n\t\t\tif (i == 64)\n\t\t\t\tgoto err_softw;\n\t\t}\n\n\t\tkey->hw_key_idx = i;\n\n\t\terr = carl9170_upload_key(ar, i, sta ? sta->addr : NULL,\n\t\t\t\t\t  ktype, 0, key->key,\n\t\t\t\t\t  min_t(u8, 16, key->keylen));\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tif (key->cipher == WLAN_CIPHER_SUITE_TKIP) {\n\t\t\terr = carl9170_upload_key(ar, i, sta ? sta->addr :\n\t\t\t\t\t\t  NULL, ktype, 1,\n\t\t\t\t\t\t  key->key + 16, 16);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\t \n\t\t\tkey->flags |= IEEE80211_KEY_FLAG_GENERATE_MMIC;\n\t\t}\n\n\t\tif (i < 64)\n\t\t\tar->usedkeys |= BIT(i);\n\n\t\tkey->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;\n\t} else {\n\t\tif (!IS_STARTED(ar)) {\n\t\t\t \n\t\t\terr = 0;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (key->hw_key_idx < 64) {\n\t\t\tar->usedkeys &= ~BIT(key->hw_key_idx);\n\t\t} else {\n\t\t\terr = carl9170_upload_key(ar, key->hw_key_idx, NULL,\n\t\t\t\t\t\t  AR9170_ENC_ALG_NONE, 0,\n\t\t\t\t\t\t  NULL, 0);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\n\t\t\tif (key->cipher == WLAN_CIPHER_SUITE_TKIP) {\n\t\t\t\terr = carl9170_upload_key(ar, key->hw_key_idx,\n\t\t\t\t\t\t\t  NULL,\n\t\t\t\t\t\t\t  AR9170_ENC_ALG_NONE,\n\t\t\t\t\t\t\t  1, NULL, 0);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t}\n\n\t\terr = carl9170_disable_key(ar, key->hw_key_idx);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\nout:\n\tmutex_unlock(&ar->mutex);\n\treturn err;\n\nerr_softw:\n\tif (!ar->rx_software_decryption) {\n\t\tar->rx_software_decryption = true;\n\t\tcarl9170_set_operating_mode(ar);\n\t}\n\tmutex_unlock(&ar->mutex);\n\treturn -ENOSPC;\n}\n\nstatic int carl9170_op_sta_add(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       struct ieee80211_sta *sta)\n{\n\tstruct carl9170_sta_info *sta_info = (void *) sta->drv_priv;\n\tunsigned int i;\n\n\tatomic_set(&sta_info->pending_frames, 0);\n\n\tif (sta->deflink.ht_cap.ht_supported) {\n\t\tif (sta->deflink.ht_cap.ampdu_density > 6) {\n\t\t\t \n\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor (i = 0; i < ARRAY_SIZE(sta_info->agg); i++)\n\t\t\tRCU_INIT_POINTER(sta_info->agg[i], NULL);\n\n\t\tsta_info->ampdu_max_len = 1 << (3 + sta->deflink.ht_cap.ampdu_factor);\n\t\tsta_info->ht_sta = true;\n\t}\n\n\treturn 0;\n}\n\nstatic int carl9170_op_sta_remove(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_sta *sta)\n{\n\tstruct ar9170 *ar = hw->priv;\n\tstruct carl9170_sta_info *sta_info = (void *) sta->drv_priv;\n\tunsigned int i;\n\tbool cleanup = false;\n\n\tif (sta->deflink.ht_cap.ht_supported) {\n\n\t\tsta_info->ht_sta = false;\n\n\t\trcu_read_lock();\n\t\tfor (i = 0; i < ARRAY_SIZE(sta_info->agg); i++) {\n\t\t\tstruct carl9170_sta_tid *tid_info;\n\n\t\t\ttid_info = rcu_dereference(sta_info->agg[i]);\n\t\t\tRCU_INIT_POINTER(sta_info->agg[i], NULL);\n\n\t\t\tif (!tid_info)\n\t\t\t\tcontinue;\n\n\t\t\tspin_lock_bh(&ar->tx_ampdu_list_lock);\n\t\t\tif (tid_info->state > CARL9170_TID_STATE_SHUTDOWN)\n\t\t\t\ttid_info->state = CARL9170_TID_STATE_SHUTDOWN;\n\t\t\tspin_unlock_bh(&ar->tx_ampdu_list_lock);\n\t\t\tcleanup = true;\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tif (cleanup)\n\t\t\tcarl9170_ampdu_gc(ar);\n\t}\n\n\treturn 0;\n}\n\nstatic int carl9170_op_conf_tx(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       unsigned int link_id, u16 queue,\n\t\t\t       const struct ieee80211_tx_queue_params *param)\n{\n\tstruct ar9170 *ar = hw->priv;\n\tint ret;\n\n\tmutex_lock(&ar->mutex);\n\tmemcpy(&ar->edcf[ar9170_qmap(queue)], param, sizeof(*param));\n\tret = carl9170_set_qos(ar);\n\tmutex_unlock(&ar->mutex);\n\treturn ret;\n}\n\nstatic void carl9170_ampdu_work(struct work_struct *work)\n{\n\tstruct ar9170 *ar = container_of(work, struct ar9170,\n\t\t\t\t\t ampdu_work);\n\n\tif (!IS_STARTED(ar))\n\t\treturn;\n\n\tmutex_lock(&ar->mutex);\n\tcarl9170_ampdu_gc(ar);\n\tmutex_unlock(&ar->mutex);\n}\n\nstatic int carl9170_op_ampdu_action(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct ieee80211_ampdu_params *params)\n{\n\tstruct ieee80211_sta *sta = params->sta;\n\tenum ieee80211_ampdu_mlme_action action = params->action;\n\tu16 tid = params->tid;\n\tu16 *ssn = &params->ssn;\n\tstruct ar9170 *ar = hw->priv;\n\tstruct carl9170_sta_info *sta_info = (void *) sta->drv_priv;\n\tstruct carl9170_sta_tid *tid_info;\n\n\tif (modparam_noht)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (action) {\n\tcase IEEE80211_AMPDU_TX_START:\n\t\tif (!sta_info->ht_sta)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\ttid_info = kzalloc(sizeof(struct carl9170_sta_tid),\n\t\t\t\t   GFP_KERNEL);\n\t\tif (!tid_info)\n\t\t\treturn -ENOMEM;\n\n\t\ttid_info->hsn = tid_info->bsn = tid_info->snx = (*ssn);\n\t\ttid_info->state = CARL9170_TID_STATE_PROGRESS;\n\t\ttid_info->tid = tid;\n\t\ttid_info->max = sta_info->ampdu_max_len;\n\t\ttid_info->sta = sta;\n\t\ttid_info->vif = vif;\n\n\t\tINIT_LIST_HEAD(&tid_info->list);\n\t\tINIT_LIST_HEAD(&tid_info->tmp_list);\n\t\tskb_queue_head_init(&tid_info->queue);\n\t\tspin_lock_init(&tid_info->lock);\n\n\t\tspin_lock_bh(&ar->tx_ampdu_list_lock);\n\t\tar->tx_ampdu_list_len++;\n\t\tlist_add_tail_rcu(&tid_info->list, &ar->tx_ampdu_list);\n\t\trcu_assign_pointer(sta_info->agg[tid], tid_info);\n\t\tspin_unlock_bh(&ar->tx_ampdu_list_lock);\n\n\t\treturn IEEE80211_AMPDU_TX_START_IMMEDIATE;\n\n\tcase IEEE80211_AMPDU_TX_STOP_CONT:\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH:\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH_CONT:\n\t\trcu_read_lock();\n\t\ttid_info = rcu_dereference(sta_info->agg[tid]);\n\t\tif (tid_info) {\n\t\t\tspin_lock_bh(&ar->tx_ampdu_list_lock);\n\t\t\tif (tid_info->state > CARL9170_TID_STATE_SHUTDOWN)\n\t\t\t\ttid_info->state = CARL9170_TID_STATE_SHUTDOWN;\n\t\t\tspin_unlock_bh(&ar->tx_ampdu_list_lock);\n\t\t}\n\n\t\tRCU_INIT_POINTER(sta_info->agg[tid], NULL);\n\t\trcu_read_unlock();\n\n\t\tieee80211_stop_tx_ba_cb_irqsafe(vif, sta->addr, tid);\n\t\tieee80211_queue_work(ar->hw, &ar->ampdu_work);\n\t\tbreak;\n\n\tcase IEEE80211_AMPDU_TX_OPERATIONAL:\n\t\trcu_read_lock();\n\t\ttid_info = rcu_dereference(sta_info->agg[tid]);\n\n\t\tsta_info->stats[tid].clear = true;\n\t\tsta_info->stats[tid].req = false;\n\n\t\tif (tid_info) {\n\t\t\tbitmap_zero(tid_info->bitmap, CARL9170_BAW_SIZE);\n\t\t\ttid_info->state = CARL9170_TID_STATE_IDLE;\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tif (WARN_ON_ONCE(!tid_info))\n\t\t\treturn -EFAULT;\n\n\t\tbreak;\n\n\tcase IEEE80211_AMPDU_RX_START:\n\tcase IEEE80211_AMPDU_RX_STOP:\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_CARL9170_WPC\nstatic int carl9170_register_wps_button(struct ar9170 *ar)\n{\n\tstruct input_dev *input;\n\tint err;\n\n\tif (!(ar->features & CARL9170_WPS_BUTTON))\n\t\treturn 0;\n\n\tinput = devm_input_allocate_device(&ar->udev->dev);\n\tif (!input)\n\t\treturn -ENOMEM;\n\n\tsnprintf(ar->wps.name, sizeof(ar->wps.name), \"%s WPS Button\",\n\t\t wiphy_name(ar->hw->wiphy));\n\n\tsnprintf(ar->wps.phys, sizeof(ar->wps.phys),\n\t\t \"ieee80211/%s/input0\", wiphy_name(ar->hw->wiphy));\n\n\tinput->name = ar->wps.name;\n\tinput->phys = ar->wps.phys;\n\tinput->id.bustype = BUS_USB;\n\tinput->dev.parent = &ar->hw->wiphy->dev;\n\n\tinput_set_capability(input, EV_KEY, KEY_WPS_BUTTON);\n\n\terr = input_register_device(input);\n\tif (err)\n\t\treturn err;\n\n\tar->wps.pbc = input;\n\treturn 0;\n}\n#endif  \n\n#ifdef CONFIG_CARL9170_HWRNG\nstatic int carl9170_rng_get(struct ar9170 *ar)\n{\n\n#define RW\t(CARL9170_MAX_CMD_PAYLOAD_LEN / sizeof(u32))\n#define RB\t(CARL9170_MAX_CMD_PAYLOAD_LEN)\n\n\tstatic const __le32 rng_load[RW] = {\n\t\t[0 ... (RW - 1)] = cpu_to_le32(AR9170_RAND_REG_NUM)};\n\n\tu32 buf[RW];\n\n\tunsigned int i, off = 0, transfer, count;\n\tint err;\n\n\tBUILD_BUG_ON(RB > CARL9170_MAX_CMD_PAYLOAD_LEN);\n\n\tif (!IS_ACCEPTING_CMD(ar))\n\t\treturn -EAGAIN;\n\n\tcount = ARRAY_SIZE(ar->rng.cache);\n\twhile (count) {\n\t\terr = carl9170_exec_cmd(ar, CARL9170_CMD_RREG,\n\t\t\t\t\tRB, (u8 *) rng_load,\n\t\t\t\t\tRB, (u8 *) buf);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\ttransfer = min_t(unsigned int, count, RW);\n\t\tfor (i = 0; i < transfer; i++)\n\t\t\tar->rng.cache[off + i] = buf[i];\n\n\t\toff += transfer;\n\t\tcount -= transfer;\n\t}\n\n\tar->rng.cache_idx = 0;\n\n#undef RW\n#undef RB\n\treturn 0;\n}\n\nstatic int carl9170_rng_read(struct hwrng *rng, u32 *data)\n{\n\tstruct ar9170 *ar = (struct ar9170 *)rng->priv;\n\tint ret = -EIO;\n\n\tmutex_lock(&ar->mutex);\n\tif (ar->rng.cache_idx >= ARRAY_SIZE(ar->rng.cache)) {\n\t\tret = carl9170_rng_get(ar);\n\t\tif (ret) {\n\t\t\tmutex_unlock(&ar->mutex);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t*data = ar->rng.cache[ar->rng.cache_idx++];\n\tmutex_unlock(&ar->mutex);\n\n\treturn sizeof(u16);\n}\n\nstatic int carl9170_register_hwrng(struct ar9170 *ar)\n{\n\tint err;\n\n\tsnprintf(ar->rng.name, ARRAY_SIZE(ar->rng.name),\n\t\t \"%s_%s\", KBUILD_MODNAME, wiphy_name(ar->hw->wiphy));\n\tar->rng.rng.name = ar->rng.name;\n\tar->rng.rng.data_read = carl9170_rng_read;\n\tar->rng.rng.priv = (unsigned long)ar;\n\n\terr = devm_hwrng_register(&ar->udev->dev, &ar->rng.rng);\n\tif (err) {\n\t\tdev_err(&ar->udev->dev, \"Failed to register the random \"\n\t\t\t\"number generator (%d)\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn carl9170_rng_get(ar);\n}\n#endif  \n\nstatic int carl9170_op_get_survey(struct ieee80211_hw *hw, int idx,\n\t\t\t\tstruct survey_info *survey)\n{\n\tstruct ar9170 *ar = hw->priv;\n\tstruct ieee80211_channel *chan;\n\tstruct ieee80211_supported_band *band;\n\tint err, b, i;\n\n\tchan = ar->channel;\n\tif (!chan)\n\t\treturn -ENODEV;\n\n\tif (idx == chan->hw_value) {\n\t\tmutex_lock(&ar->mutex);\n\t\terr = carl9170_update_survey(ar, false, true);\n\t\tmutex_unlock(&ar->mutex);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tfor (b = 0; b < NUM_NL80211_BANDS; b++) {\n\t\tband = ar->hw->wiphy->bands[b];\n\n\t\tif (!band)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < band->n_channels; i++) {\n\t\t\tif (band->channels[i].hw_value == idx) {\n\t\t\t\tchan = &band->channels[i];\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\t}\n\treturn -ENOENT;\n\nfound:\n\tmemcpy(survey, &ar->survey[idx], sizeof(*survey));\n\n\tsurvey->channel = chan;\n\tsurvey->filled = SURVEY_INFO_NOISE_DBM;\n\n\tif (ar->channel == chan)\n\t\tsurvey->filled |= SURVEY_INFO_IN_USE;\n\n\tif (ar->fw.hw_counters) {\n\t\tsurvey->filled |= SURVEY_INFO_TIME |\n\t\t\t\t  SURVEY_INFO_TIME_BUSY |\n\t\t\t\t  SURVEY_INFO_TIME_TX;\n\t}\n\n\treturn 0;\n}\n\nstatic void carl9170_op_flush(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      u32 queues, bool drop)\n{\n\tstruct ar9170 *ar = hw->priv;\n\tunsigned int vid;\n\n\tmutex_lock(&ar->mutex);\n\tfor_each_set_bit(vid, &ar->vif_bitmap, ar->fw.vif_num)\n\t\tcarl9170_flush_cab(ar, vid);\n\n\tcarl9170_flush(ar, drop);\n\tmutex_unlock(&ar->mutex);\n}\n\nstatic int carl9170_op_get_stats(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_low_level_stats *stats)\n{\n\tstruct ar9170 *ar = hw->priv;\n\n\tmemset(stats, 0, sizeof(*stats));\n\tstats->dot11ACKFailureCount = ar->tx_ack_failures;\n\tstats->dot11FCSErrorCount = ar->tx_fcs_errors;\n\treturn 0;\n}\n\nstatic void carl9170_op_sta_notify(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   enum sta_notify_cmd cmd,\n\t\t\t\t   struct ieee80211_sta *sta)\n{\n\tstruct carl9170_sta_info *sta_info = (void *) sta->drv_priv;\n\n\tswitch (cmd) {\n\tcase STA_NOTIFY_SLEEP:\n\t\tsta_info->sleeping = true;\n\t\tif (atomic_read(&sta_info->pending_frames))\n\t\t\tieee80211_sta_block_awake(hw, sta, true);\n\t\tbreak;\n\n\tcase STA_NOTIFY_AWAKE:\n\t\tsta_info->sleeping = false;\n\t\tbreak;\n\t}\n}\n\nstatic bool carl9170_tx_frames_pending(struct ieee80211_hw *hw)\n{\n\tstruct ar9170 *ar = hw->priv;\n\n\treturn !!atomic_read(&ar->tx_total_queued);\n}\n\nstatic const struct ieee80211_ops carl9170_ops = {\n\t.start\t\t\t= carl9170_op_start,\n\t.stop\t\t\t= carl9170_op_stop,\n\t.tx\t\t\t= carl9170_op_tx,\n\t.wake_tx_queue\t\t= ieee80211_handle_wake_tx_queue,\n\t.flush\t\t\t= carl9170_op_flush,\n\t.add_interface\t\t= carl9170_op_add_interface,\n\t.remove_interface\t= carl9170_op_remove_interface,\n\t.config\t\t\t= carl9170_op_config,\n\t.prepare_multicast\t= carl9170_op_prepare_multicast,\n\t.configure_filter\t= carl9170_op_configure_filter,\n\t.conf_tx\t\t= carl9170_op_conf_tx,\n\t.bss_info_changed\t= carl9170_op_bss_info_changed,\n\t.get_tsf\t\t= carl9170_op_get_tsf,\n\t.set_key\t\t= carl9170_op_set_key,\n\t.sta_add\t\t= carl9170_op_sta_add,\n\t.sta_remove\t\t= carl9170_op_sta_remove,\n\t.sta_notify\t\t= carl9170_op_sta_notify,\n\t.get_survey\t\t= carl9170_op_get_survey,\n\t.get_stats\t\t= carl9170_op_get_stats,\n\t.ampdu_action\t\t= carl9170_op_ampdu_action,\n\t.tx_frames_pending\t= carl9170_tx_frames_pending,\n};\n\nvoid *carl9170_alloc(size_t priv_size)\n{\n\tstruct ieee80211_hw *hw;\n\tstruct ar9170 *ar;\n\tstruct sk_buff *skb;\n\tint i;\n\n\t \n\n\tskb = __dev_alloc_skb(AR9170_RX_STREAM_MAX_SIZE, GFP_KERNEL);\n\tif (!skb)\n\t\tgoto err_nomem;\n\n\thw = ieee80211_alloc_hw(priv_size, &carl9170_ops);\n\tif (!hw)\n\t\tgoto err_nomem;\n\n\tar = hw->priv;\n\tar->hw = hw;\n\tar->rx_failover = skb;\n\n\tmemset(&ar->rx_plcp, 0, sizeof(struct ar9170_rx_head));\n\tar->rx_has_plcp = false;\n\n\t \n\thw->queues = __AR9170_NUM_TXQ;\n\n\tmutex_init(&ar->mutex);\n\tspin_lock_init(&ar->beacon_lock);\n\tspin_lock_init(&ar->cmd_lock);\n\tspin_lock_init(&ar->tx_stats_lock);\n\tspin_lock_init(&ar->tx_ampdu_list_lock);\n\tspin_lock_init(&ar->mem_lock);\n\tspin_lock_init(&ar->state_lock);\n\tatomic_set(&ar->pending_restarts, 0);\n\tar->vifs = 0;\n\tfor (i = 0; i < ar->hw->queues; i++) {\n\t\tskb_queue_head_init(&ar->tx_status[i]);\n\t\tskb_queue_head_init(&ar->tx_pending[i]);\n\n\t\tINIT_LIST_HEAD(&ar->bar_list[i]);\n\t\tspin_lock_init(&ar->bar_list_lock[i]);\n\t}\n\tINIT_WORK(&ar->ps_work, carl9170_ps_work);\n\tINIT_WORK(&ar->ping_work, carl9170_ping_work);\n\tINIT_WORK(&ar->restart_work, carl9170_restart_work);\n\tINIT_WORK(&ar->ampdu_work, carl9170_ampdu_work);\n\tINIT_DELAYED_WORK(&ar->stat_work, carl9170_stat_work);\n\tINIT_DELAYED_WORK(&ar->tx_janitor, carl9170_tx_janitor);\n\tINIT_LIST_HEAD(&ar->tx_ampdu_list);\n\trcu_assign_pointer(ar->tx_ampdu_iter,\n\t\t\t   (struct carl9170_sta_tid *) &ar->tx_ampdu_list);\n\n\tbitmap_zero(&ar->vif_bitmap, ar->fw.vif_num);\n\tINIT_LIST_HEAD(&ar->vif_list);\n\tinit_completion(&ar->tx_flush);\n\n\t \n\thw->wiphy->interface_modes = 0;\n\n\tieee80211_hw_set(hw, RX_INCLUDES_FCS);\n\tieee80211_hw_set(hw, MFP_CAPABLE);\n\tieee80211_hw_set(hw, REPORTS_TX_ACK_STATUS);\n\tieee80211_hw_set(hw, SUPPORTS_PS);\n\tieee80211_hw_set(hw, PS_NULLFUNC_STACK);\n\tieee80211_hw_set(hw, NEED_DTIM_BEFORE_ASSOC);\n\tieee80211_hw_set(hw, SUPPORTS_RC_TABLE);\n\tieee80211_hw_set(hw, SIGNAL_DBM);\n\tieee80211_hw_set(hw, SUPPORTS_HT_CCK_RATES);\n\n\tif (!modparam_noht) {\n\t\t \n\t\tieee80211_hw_set(hw, AMPDU_AGGREGATION);\n\t}\n\n\thw->extra_tx_headroom = sizeof(struct _carl9170_tx_superframe);\n\thw->sta_data_size = sizeof(struct carl9170_sta_info);\n\thw->vif_data_size = sizeof(struct carl9170_vif_info);\n\n\thw->max_rates = CARL9170_TX_MAX_RATES;\n\thw->max_rate_tries = CARL9170_TX_USER_RATE_TRIES;\n\n\tfor (i = 0; i < ARRAY_SIZE(ar->noise); i++)\n\t\tar->noise[i] = -95;  \n\n\twiphy_ext_feature_set(hw->wiphy, NL80211_EXT_FEATURE_CQM_RSSI_LIST);\n\n\treturn ar;\n\nerr_nomem:\n\tkfree_skb(skb);\n\treturn ERR_PTR(-ENOMEM);\n}\n\nstatic int carl9170_read_eeprom(struct ar9170 *ar)\n{\n#define RW\t8\t \n#define RB\t(sizeof(u32) * RW)\n\tu8 *eeprom = (void *)&ar->eeprom;\n\t__le32 offsets[RW];\n\tint i, j, err;\n\n\tBUILD_BUG_ON(sizeof(ar->eeprom) & 3);\n\n\tBUILD_BUG_ON(RB > CARL9170_MAX_CMD_LEN - 4);\n#ifndef __CHECKER__\n\t \n\tBUILD_BUG_ON(sizeof(ar->eeprom) % RB);\n#endif\n\n\tfor (i = 0; i < sizeof(ar->eeprom) / RB; i++) {\n\t\tfor (j = 0; j < RW; j++)\n\t\t\toffsets[j] = cpu_to_le32(AR9170_EEPROM_START +\n\t\t\t\t\t\t RB * i + 4 * j);\n\n\t\terr = carl9170_exec_cmd(ar, CARL9170_CMD_RREG,\n\t\t\t\t\tRB, (u8 *) &offsets,\n\t\t\t\t\tRB, eeprom + RB * i);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n#undef RW\n#undef RB\n\treturn 0;\n}\n\nstatic int carl9170_parse_eeprom(struct ar9170 *ar)\n{\n\tstruct ath_regulatory *regulatory = &ar->common.regulatory;\n\tunsigned int rx_streams, tx_streams, tx_params = 0;\n\tint bands = 0;\n\tint chans = 0;\n\n\tif (ar->eeprom.length == cpu_to_le16(0xffff))\n\t\treturn -ENODATA;\n\n\trx_streams = hweight8(ar->eeprom.rx_mask);\n\ttx_streams = hweight8(ar->eeprom.tx_mask);\n\n\tif (rx_streams != tx_streams) {\n\t\ttx_params = IEEE80211_HT_MCS_TX_RX_DIFF;\n\n\t\tWARN_ON(!(tx_streams >= 1 && tx_streams <=\n\t\t\tIEEE80211_HT_MCS_TX_MAX_STREAMS));\n\n\t\ttx_params |= (tx_streams - 1) <<\n\t\t\t    IEEE80211_HT_MCS_TX_MAX_STREAMS_SHIFT;\n\n\t\tcarl9170_band_2GHz.ht_cap.mcs.tx_params |= tx_params;\n\t\tcarl9170_band_5GHz.ht_cap.mcs.tx_params |= tx_params;\n\t}\n\n\tif (ar->eeprom.operating_flags & AR9170_OPFLAG_2GHZ) {\n\t\tar->hw->wiphy->bands[NL80211_BAND_2GHZ] =\n\t\t\t&carl9170_band_2GHz;\n\t\tchans += carl9170_band_2GHz.n_channels;\n\t\tbands++;\n\t}\n\tif (ar->eeprom.operating_flags & AR9170_OPFLAG_5GHZ) {\n\t\tar->hw->wiphy->bands[NL80211_BAND_5GHZ] =\n\t\t\t&carl9170_band_5GHz;\n\t\tchans += carl9170_band_5GHz.n_channels;\n\t\tbands++;\n\t}\n\n\tif (!bands)\n\t\treturn -EINVAL;\n\n\tar->survey = devm_kcalloc(&ar->udev->dev, chans,\n\t\t\t\t  sizeof(struct survey_info), GFP_KERNEL);\n\tif (!ar->survey)\n\t\treturn -ENOMEM;\n\tar->num_channels = chans;\n\n\tregulatory->current_rd = le16_to_cpu(ar->eeprom.reg_domain[0]);\n\n\t \n\tSET_IEEE80211_PERM_ADDR(ar->hw, ar->eeprom.mac_address);\n\n\treturn 0;\n}\n\nstatic void carl9170_reg_notifier(struct wiphy *wiphy,\n\t\t\t\t  struct regulatory_request *request)\n{\n\tstruct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);\n\tstruct ar9170 *ar = hw->priv;\n\n\tath_reg_notifier_apply(wiphy, request, &ar->common.regulatory);\n}\n\nint carl9170_register(struct ar9170 *ar)\n{\n\tstruct ath_regulatory *regulatory = &ar->common.regulatory;\n\tint err = 0, i;\n\n\tar->mem_bitmap = devm_bitmap_zalloc(&ar->udev->dev, ar->fw.mem_blocks, GFP_KERNEL);\n\tif (!ar->mem_bitmap)\n\t\treturn -ENOMEM;\n\n\t \n\terr = carl9170_read_eeprom(ar);\n\tif (err)\n\t\treturn err;\n\n\terr = carl9170_parse_eeprom(ar);\n\tif (err)\n\t\treturn err;\n\n\terr = ath_regd_init(regulatory, ar->hw->wiphy,\n\t\t\t    carl9170_reg_notifier);\n\tif (err)\n\t\treturn err;\n\n\tif (modparam_noht) {\n\t\tcarl9170_band_2GHz.ht_cap.ht_supported = false;\n\t\tcarl9170_band_5GHz.ht_cap.ht_supported = false;\n\t}\n\n\tfor (i = 0; i < ar->fw.vif_num; i++) {\n\t\tar->vif_priv[i].id = i;\n\t\tar->vif_priv[i].vif = NULL;\n\t}\n\n\terr = ieee80211_register_hw(ar->hw);\n\tif (err)\n\t\treturn err;\n\n\t \n\tar->registered = true;\n\n\tif (!ath_is_world_regd(regulatory))\n\t\tregulatory_hint(ar->hw->wiphy, regulatory->alpha2);\n\n#ifdef CONFIG_CARL9170_DEBUGFS\n\tcarl9170_debugfs_register(ar);\n#endif  \n\n\terr = carl9170_led_init(ar);\n\tif (err)\n\t\tgoto err_unreg;\n\n#ifdef CONFIG_CARL9170_LEDS\n\terr = carl9170_led_register(ar);\n\tif (err)\n\t\tgoto err_unreg;\n#endif  \n\n#ifdef CONFIG_CARL9170_WPC\n\terr = carl9170_register_wps_button(ar);\n\tif (err)\n\t\tgoto err_unreg;\n#endif  \n\n#ifdef CONFIG_CARL9170_HWRNG\n\terr = carl9170_register_hwrng(ar);\n\tif (err)\n\t\tgoto err_unreg;\n#endif  \n\n\tdev_info(&ar->udev->dev, \"Atheros AR9170 is registered as '%s'\\n\",\n\t\t wiphy_name(ar->hw->wiphy));\n\n\treturn 0;\n\nerr_unreg:\n\tcarl9170_unregister(ar);\n\treturn err;\n}\n\nvoid carl9170_unregister(struct ar9170 *ar)\n{\n\tif (!ar->registered)\n\t\treturn;\n\n\tar->registered = false;\n\n#ifdef CONFIG_CARL9170_LEDS\n\tcarl9170_led_unregister(ar);\n#endif  \n\n#ifdef CONFIG_CARL9170_DEBUGFS\n\tcarl9170_debugfs_unregister(ar);\n#endif  \n\n\tcarl9170_cancel_worker(ar);\n\tcancel_work_sync(&ar->restart_work);\n\n\tieee80211_unregister_hw(ar->hw);\n}\n\nvoid carl9170_free(struct ar9170 *ar)\n{\n\tWARN_ON(ar->registered);\n\tWARN_ON(IS_INITIALIZED(ar));\n\n\tkfree_skb(ar->rx_failover);\n\tar->rx_failover = NULL;\n\n\tmutex_destroy(&ar->mutex);\n\n\tieee80211_free_hw(ar->hw);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}