{
  "module_name": "tx.c",
  "hash_id": "dca9b9f7cbc70a386067645cd76da242c9bbc5838e9d745d7a42b8c363ccdc4f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/carl9170/tx.c",
  "human_readable_source": " \n\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/etherdevice.h>\n#include <net/mac80211.h>\n#include \"carl9170.h\"\n#include \"hw.h\"\n#include \"cmd.h\"\n\nstatic inline unsigned int __carl9170_get_queue(struct ar9170 *ar,\n\t\t\t\t\t\tunsigned int queue)\n{\n\tif (unlikely(modparam_noht)) {\n\t\treturn queue;\n\t} else {\n\t\t \n\n\t\treturn 2;\t\t \n\t}\n}\n\nstatic inline unsigned int carl9170_get_queue(struct ar9170 *ar,\n\t\t\t\t\t      struct sk_buff *skb)\n{\n\treturn __carl9170_get_queue(ar, skb_get_queue_mapping(skb));\n}\n\nstatic bool is_mem_full(struct ar9170 *ar)\n{\n\treturn (DIV_ROUND_UP(IEEE80211_MAX_FRAME_LEN, ar->fw.mem_block_size) >\n\t\tatomic_read(&ar->mem_free_blocks));\n}\n\nstatic void carl9170_tx_accounting(struct ar9170 *ar, struct sk_buff *skb)\n{\n\tint queue, i;\n\tbool mem_full;\n\n\tatomic_inc(&ar->tx_total_queued);\n\n\tqueue = skb_get_queue_mapping(skb);\n\tspin_lock_bh(&ar->tx_stats_lock);\n\n\t \n\tar->tx_stats[queue].len++;\n\tar->tx_stats[queue].count++;\n\n\tmem_full = is_mem_full(ar);\n\tfor (i = 0; i < ar->hw->queues; i++) {\n\t\tif (mem_full || ar->tx_stats[i].len >= ar->tx_stats[i].limit) {\n\t\t\tieee80211_stop_queue(ar->hw, i);\n\t\t\tar->queue_stop_timeout[i] = jiffies;\n\t\t}\n\t}\n\n\tspin_unlock_bh(&ar->tx_stats_lock);\n}\n\n \nstatic struct ieee80211_sta *__carl9170_get_tx_sta(struct ar9170 *ar,\n\t\t\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct _carl9170_tx_superframe *super = (void *) skb->data;\n\tstruct ieee80211_hdr *hdr = (void *) super->frame_data;\n\tstruct ieee80211_vif *vif;\n\tunsigned int vif_id;\n\n\tvif_id = (super->s.misc & CARL9170_TX_SUPER_MISC_VIF_ID) >>\n\t\t CARL9170_TX_SUPER_MISC_VIF_ID_S;\n\n\tif (WARN_ON_ONCE(vif_id >= AR9170_MAX_VIRTUAL_MAC))\n\t\treturn NULL;\n\n\tvif = rcu_dereference(ar->vif_priv[vif_id].vif);\n\tif (unlikely(!vif))\n\t\treturn NULL;\n\n\t \n\n\treturn ieee80211_find_sta(vif, hdr->addr1);\n}\n\nstatic void carl9170_tx_ps_unblock(struct ar9170 *ar, struct sk_buff *skb)\n{\n\tstruct ieee80211_sta *sta;\n\tstruct carl9170_sta_info *sta_info;\n\n\trcu_read_lock();\n\tsta = __carl9170_get_tx_sta(ar, skb);\n\tif (unlikely(!sta))\n\t\tgoto out_rcu;\n\n\tsta_info = (struct carl9170_sta_info *) sta->drv_priv;\n\tif (atomic_dec_return(&sta_info->pending_frames) == 0)\n\t\tieee80211_sta_block_awake(ar->hw, sta, false);\n\nout_rcu:\n\trcu_read_unlock();\n}\n\nstatic void carl9170_tx_accounting_free(struct ar9170 *ar, struct sk_buff *skb)\n{\n\tint queue;\n\n\tqueue = skb_get_queue_mapping(skb);\n\n\tspin_lock_bh(&ar->tx_stats_lock);\n\n\tar->tx_stats[queue].len--;\n\n\tif (!is_mem_full(ar)) {\n\t\tunsigned int i;\n\t\tfor (i = 0; i < ar->hw->queues; i++) {\n\t\t\tif (ar->tx_stats[i].len >= CARL9170_NUM_TX_LIMIT_SOFT)\n\t\t\t\tcontinue;\n\n\t\t\tif (ieee80211_queue_stopped(ar->hw, i)) {\n\t\t\t\tunsigned long tmp;\n\n\t\t\t\ttmp = jiffies - ar->queue_stop_timeout[i];\n\t\t\t\tif (tmp > ar->max_queue_stop_timeout[i])\n\t\t\t\t\tar->max_queue_stop_timeout[i] = tmp;\n\t\t\t}\n\n\t\t\tieee80211_wake_queue(ar->hw, i);\n\t\t}\n\t}\n\n\tspin_unlock_bh(&ar->tx_stats_lock);\n\n\tif (atomic_dec_and_test(&ar->tx_total_queued))\n\t\tcomplete(&ar->tx_flush);\n}\n\nstatic int carl9170_alloc_dev_space(struct ar9170 *ar, struct sk_buff *skb)\n{\n\tstruct _carl9170_tx_superframe *super = (void *) skb->data;\n\tunsigned int chunks;\n\tint cookie = -1;\n\n\tatomic_inc(&ar->mem_allocs);\n\n\tchunks = DIV_ROUND_UP(skb->len, ar->fw.mem_block_size);\n\tif (unlikely(atomic_sub_return(chunks, &ar->mem_free_blocks) < 0)) {\n\t\tatomic_add(chunks, &ar->mem_free_blocks);\n\t\treturn -ENOSPC;\n\t}\n\n\tspin_lock_bh(&ar->mem_lock);\n\tcookie = bitmap_find_free_region(ar->mem_bitmap, ar->fw.mem_blocks, 0);\n\tspin_unlock_bh(&ar->mem_lock);\n\n\tif (unlikely(cookie < 0)) {\n\t\tatomic_add(chunks, &ar->mem_free_blocks);\n\t\treturn -ENOSPC;\n\t}\n\n\tsuper = (void *) skb->data;\n\n\t \n\tsuper->s.cookie = (u8) cookie + 1;\n\treturn 0;\n}\n\nstatic void carl9170_release_dev_space(struct ar9170 *ar, struct sk_buff *skb)\n{\n\tstruct _carl9170_tx_superframe *super = (void *) skb->data;\n\tint cookie;\n\n\t \n\tcookie = super->s.cookie;\n\t \n\tsuper->s.cookie = 0;\n\n\t \n\tif (WARN_ON_ONCE(cookie == 0) ||\n\t    WARN_ON_ONCE(cookie > ar->fw.mem_blocks))\n\t\treturn;\n\n\tatomic_add(DIV_ROUND_UP(skb->len, ar->fw.mem_block_size),\n\t\t   &ar->mem_free_blocks);\n\n\tspin_lock_bh(&ar->mem_lock);\n\tbitmap_release_region(ar->mem_bitmap, cookie - 1, 0);\n\tspin_unlock_bh(&ar->mem_lock);\n}\n\n \nstatic void carl9170_tx_release(struct kref *ref)\n{\n\tstruct ar9170 *ar;\n\tstruct carl9170_tx_info *arinfo;\n\tstruct ieee80211_tx_info *txinfo;\n\tstruct sk_buff *skb;\n\n\tarinfo = container_of(ref, struct carl9170_tx_info, ref);\n\ttxinfo = container_of((void *) arinfo, struct ieee80211_tx_info,\n\t\t\t      rate_driver_data);\n\tskb = container_of((void *) txinfo, struct sk_buff, cb);\n\n\tar = arinfo->ar;\n\tif (WARN_ON_ONCE(!ar))\n\t\treturn;\n\n\t \n\tmemset_after(&txinfo->status, 0, rates);\n\n\tif (atomic_read(&ar->tx_total_queued))\n\t\tar->tx_schedule = true;\n\n\tif (txinfo->flags & IEEE80211_TX_CTL_AMPDU) {\n\t\tif (!atomic_read(&ar->tx_ampdu_upload))\n\t\t\tar->tx_ampdu_schedule = true;\n\n\t\tif (txinfo->flags & IEEE80211_TX_STAT_AMPDU) {\n\t\t\tstruct _carl9170_tx_superframe *super;\n\n\t\t\tsuper = (void *)skb->data;\n\t\t\ttxinfo->status.ampdu_len = super->s.rix;\n\t\t\ttxinfo->status.ampdu_ack_len = super->s.cnt;\n\t\t} else if ((txinfo->flags & IEEE80211_TX_STAT_ACK) &&\n\t\t\t   !(txinfo->flags & IEEE80211_TX_CTL_REQ_TX_STATUS)) {\n\t\t\t \n\n\t\t\tieee80211_free_txskb(ar->hw, skb);\n\t\t\treturn;\n\t\t} else {\n\t\t\t \n\t\t}\n\t}\n\n\tskb_pull(skb, sizeof(struct _carl9170_tx_superframe));\n\tieee80211_tx_status_irqsafe(ar->hw, skb);\n}\n\nvoid carl9170_tx_get_skb(struct sk_buff *skb)\n{\n\tstruct carl9170_tx_info *arinfo = (void *)\n\t\t(IEEE80211_SKB_CB(skb))->rate_driver_data;\n\tkref_get(&arinfo->ref);\n}\n\nint carl9170_tx_put_skb(struct sk_buff *skb)\n{\n\tstruct carl9170_tx_info *arinfo = (void *)\n\t\t(IEEE80211_SKB_CB(skb))->rate_driver_data;\n\n\treturn kref_put(&arinfo->ref, carl9170_tx_release);\n}\n\n \nstatic void carl9170_tx_shift_bm(struct ar9170 *ar,\n\tstruct carl9170_sta_tid *tid_info, u16 seq)\n{\n\tu16 off;\n\n\toff = SEQ_DIFF(seq, tid_info->bsn);\n\n\tif (WARN_ON_ONCE(off >= CARL9170_BAW_BITS))\n\t\treturn;\n\n\t \n\tWARN_ON_ONCE(!test_and_clear_bit(off, tid_info->bitmap));\n\n\toff = SEQ_DIFF(tid_info->snx, tid_info->bsn);\n\tif (WARN_ON_ONCE(off >= CARL9170_BAW_BITS))\n\t\treturn;\n\n\tif (!bitmap_empty(tid_info->bitmap, off))\n\t\toff = find_first_bit(tid_info->bitmap, off);\n\n\ttid_info->bsn += off;\n\ttid_info->bsn &= 0x0fff;\n\n\tbitmap_shift_right(tid_info->bitmap, tid_info->bitmap,\n\t\t\t   off, CARL9170_BAW_BITS);\n}\n\nstatic void carl9170_tx_status_process_ampdu(struct ar9170 *ar,\n\tstruct sk_buff *skb, struct ieee80211_tx_info *txinfo)\n{\n\tstruct _carl9170_tx_superframe *super = (void *) skb->data;\n\tstruct ieee80211_hdr *hdr = (void *) super->frame_data;\n\tstruct ieee80211_sta *sta;\n\tstruct carl9170_sta_info *sta_info;\n\tstruct carl9170_sta_tid *tid_info;\n\tu8 tid;\n\n\tif (!(txinfo->flags & IEEE80211_TX_CTL_AMPDU) ||\n\t    txinfo->flags & IEEE80211_TX_CTL_INJECTED)\n\t\treturn;\n\n\trcu_read_lock();\n\tsta = __carl9170_get_tx_sta(ar, skb);\n\tif (unlikely(!sta))\n\t\tgoto out_rcu;\n\n\ttid = ieee80211_get_tid(hdr);\n\n\tsta_info = (void *) sta->drv_priv;\n\ttid_info = rcu_dereference(sta_info->agg[tid]);\n\tif (!tid_info)\n\t\tgoto out_rcu;\n\n\tspin_lock_bh(&tid_info->lock);\n\tif (likely(tid_info->state >= CARL9170_TID_STATE_IDLE))\n\t\tcarl9170_tx_shift_bm(ar, tid_info, get_seq_h(hdr));\n\n\tif (sta_info->stats[tid].clear) {\n\t\tsta_info->stats[tid].clear = false;\n\t\tsta_info->stats[tid].req = false;\n\t\tsta_info->stats[tid].ampdu_len = 0;\n\t\tsta_info->stats[tid].ampdu_ack_len = 0;\n\t}\n\n\tsta_info->stats[tid].ampdu_len++;\n\tif (txinfo->status.rates[0].count == 1)\n\t\tsta_info->stats[tid].ampdu_ack_len++;\n\n\tif (!(txinfo->flags & IEEE80211_TX_STAT_ACK))\n\t\tsta_info->stats[tid].req = true;\n\n\tif (super->f.mac_control & cpu_to_le16(AR9170_TX_MAC_IMM_BA)) {\n\t\tsuper->s.rix = sta_info->stats[tid].ampdu_len;\n\t\tsuper->s.cnt = sta_info->stats[tid].ampdu_ack_len;\n\t\ttxinfo->flags |= IEEE80211_TX_STAT_AMPDU;\n\t\tif (sta_info->stats[tid].req)\n\t\t\ttxinfo->flags |= IEEE80211_TX_STAT_AMPDU_NO_BACK;\n\n\t\tsta_info->stats[tid].clear = true;\n\t}\n\tspin_unlock_bh(&tid_info->lock);\n\nout_rcu:\n\trcu_read_unlock();\n}\n\nstatic void carl9170_tx_bar_status(struct ar9170 *ar, struct sk_buff *skb,\n\tstruct ieee80211_tx_info *tx_info)\n{\n\tstruct _carl9170_tx_superframe *super = (void *) skb->data;\n\tstruct ieee80211_bar *bar = (void *) super->frame_data;\n\n\t \n\n\tif (unlikely(ieee80211_is_back_req(bar->frame_control)) &&\n\t   !(tx_info->flags & IEEE80211_TX_STAT_ACK)) {\n\t\tstruct carl9170_bar_list_entry *entry;\n\t\tint queue = skb_get_queue_mapping(skb);\n\n\t\trcu_read_lock();\n\t\tlist_for_each_entry_rcu(entry, &ar->bar_list[queue], list) {\n\t\t\tif (entry->skb == skb) {\n\t\t\t\tspin_lock_bh(&ar->bar_list_lock[queue]);\n\t\t\t\tlist_del_rcu(&entry->list);\n\t\t\t\tspin_unlock_bh(&ar->bar_list_lock[queue]);\n\t\t\t\tkfree_rcu(entry, head);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tWARN(1, \"bar not found in %d - ra:%pM ta:%pM c:%x ssn:%x\\n\",\n\t\t       queue, bar->ra, bar->ta, bar->control,\n\t\t\tbar->start_seq_num);\nout:\n\t\trcu_read_unlock();\n\t}\n}\n\nvoid carl9170_tx_status(struct ar9170 *ar, struct sk_buff *skb,\n\t\t\tconst bool success)\n{\n\tstruct ieee80211_tx_info *txinfo;\n\n\tcarl9170_tx_accounting_free(ar, skb);\n\n\ttxinfo = IEEE80211_SKB_CB(skb);\n\n\tcarl9170_tx_bar_status(ar, skb, txinfo);\n\n\tif (success)\n\t\ttxinfo->flags |= IEEE80211_TX_STAT_ACK;\n\telse\n\t\tar->tx_ack_failures++;\n\n\tif (txinfo->flags & IEEE80211_TX_CTL_AMPDU)\n\t\tcarl9170_tx_status_process_ampdu(ar, skb, txinfo);\n\n\tcarl9170_tx_ps_unblock(ar, skb);\n\tcarl9170_tx_put_skb(skb);\n}\n\n \nvoid carl9170_tx_callback(struct ar9170 *ar, struct sk_buff *skb)\n{\n\tstruct ieee80211_tx_info *txinfo = IEEE80211_SKB_CB(skb);\n\n\tatomic_dec(&ar->tx_total_pending);\n\n\tif (txinfo->flags & IEEE80211_TX_CTL_AMPDU)\n\t\tatomic_dec(&ar->tx_ampdu_upload);\n\n\tif (carl9170_tx_put_skb(skb))\n\t\ttasklet_hi_schedule(&ar->usb_tasklet);\n}\n\nstatic struct sk_buff *carl9170_get_queued_skb(struct ar9170 *ar, u8 cookie,\n\t\t\t\t\t       struct sk_buff_head *queue)\n{\n\tstruct sk_buff *skb;\n\n\tspin_lock_bh(&queue->lock);\n\tskb_queue_walk(queue, skb) {\n\t\tstruct _carl9170_tx_superframe *txc = (void *) skb->data;\n\n\t\tif (txc->s.cookie != cookie)\n\t\t\tcontinue;\n\n\t\t__skb_unlink(skb, queue);\n\t\tspin_unlock_bh(&queue->lock);\n\n\t\tcarl9170_release_dev_space(ar, skb);\n\t\treturn skb;\n\t}\n\tspin_unlock_bh(&queue->lock);\n\n\treturn NULL;\n}\n\nstatic void carl9170_tx_fill_rateinfo(struct ar9170 *ar, unsigned int rix,\n\tunsigned int tries, struct ieee80211_tx_info *txinfo)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < IEEE80211_TX_MAX_RATES; i++) {\n\t\tif (txinfo->status.rates[i].idx < 0)\n\t\t\tbreak;\n\n\t\tif (i == rix) {\n\t\t\ttxinfo->status.rates[i].count = tries;\n\t\t\ti++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (; i < IEEE80211_TX_MAX_RATES; i++) {\n\t\ttxinfo->status.rates[i].idx = -1;\n\t\ttxinfo->status.rates[i].count = 0;\n\t}\n}\n\nstatic void carl9170_check_queue_stop_timeout(struct ar9170 *ar)\n{\n\tint i;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_tx_info *txinfo;\n\tstruct carl9170_tx_info *arinfo;\n\tbool restart = false;\n\n\tfor (i = 0; i < ar->hw->queues; i++) {\n\t\tspin_lock_bh(&ar->tx_status[i].lock);\n\n\t\tskb = skb_peek(&ar->tx_status[i]);\n\n\t\tif (!skb)\n\t\t\tgoto next;\n\n\t\ttxinfo = IEEE80211_SKB_CB(skb);\n\t\tarinfo = (void *) txinfo->rate_driver_data;\n\n\t\tif (time_is_before_jiffies(arinfo->timeout +\n\t\t    msecs_to_jiffies(CARL9170_QUEUE_STUCK_TIMEOUT)) == true)\n\t\t\trestart = true;\n\nnext:\n\t\tspin_unlock_bh(&ar->tx_status[i].lock);\n\t}\n\n\tif (restart) {\n\t\t \n\t\tcarl9170_restart(ar, CARL9170_RR_STUCK_TX);\n\t}\n}\n\nstatic void carl9170_tx_ampdu_timeout(struct ar9170 *ar)\n{\n\tstruct carl9170_sta_tid *iter;\n\tstruct sk_buff *skb;\n\tstruct ieee80211_tx_info *txinfo;\n\tstruct carl9170_tx_info *arinfo;\n\tstruct ieee80211_sta *sta;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(iter, &ar->tx_ampdu_list, list) {\n\t\tif (iter->state < CARL9170_TID_STATE_IDLE)\n\t\t\tcontinue;\n\n\t\tspin_lock_bh(&iter->lock);\n\t\tskb = skb_peek(&iter->queue);\n\t\tif (!skb)\n\t\t\tgoto unlock;\n\n\t\ttxinfo = IEEE80211_SKB_CB(skb);\n\t\tarinfo = (void *)txinfo->rate_driver_data;\n\t\tif (time_is_after_jiffies(arinfo->timeout +\n\t\t    msecs_to_jiffies(CARL9170_QUEUE_TIMEOUT)))\n\t\t\tgoto unlock;\n\n\t\tsta = iter->sta;\n\t\tif (WARN_ON(!sta))\n\t\t\tgoto unlock;\n\n\t\tieee80211_stop_tx_ba_session(sta, iter->tid);\nunlock:\n\t\tspin_unlock_bh(&iter->lock);\n\n\t}\n\trcu_read_unlock();\n}\n\nvoid carl9170_tx_janitor(struct work_struct *work)\n{\n\tstruct ar9170 *ar = container_of(work, struct ar9170,\n\t\t\t\t\t tx_janitor.work);\n\tif (!IS_STARTED(ar))\n\t\treturn;\n\n\tar->tx_janitor_last_run = jiffies;\n\n\tcarl9170_check_queue_stop_timeout(ar);\n\tcarl9170_tx_ampdu_timeout(ar);\n\n\tif (!atomic_read(&ar->tx_total_queued))\n\t\treturn;\n\n\tieee80211_queue_delayed_work(ar->hw, &ar->tx_janitor,\n\t\tmsecs_to_jiffies(CARL9170_TX_TIMEOUT));\n}\n\nstatic void __carl9170_tx_process_status(struct ar9170 *ar,\n\tconst uint8_t cookie, const uint8_t info)\n{\n\tstruct sk_buff *skb;\n\tstruct ieee80211_tx_info *txinfo;\n\tunsigned int r, t, q;\n\tbool success = true;\n\n\tq = ar9170_qmap(info & CARL9170_TX_STATUS_QUEUE);\n\n\tskb = carl9170_get_queued_skb(ar, cookie, &ar->tx_status[q]);\n\tif (!skb) {\n\t\t \n\n\t\treturn ;\n\t}\n\n\ttxinfo = IEEE80211_SKB_CB(skb);\n\n\tif (!(info & CARL9170_TX_STATUS_SUCCESS))\n\t\tsuccess = false;\n\n\tr = (info & CARL9170_TX_STATUS_RIX) >> CARL9170_TX_STATUS_RIX_S;\n\tt = (info & CARL9170_TX_STATUS_TRIES) >> CARL9170_TX_STATUS_TRIES_S;\n\n\tcarl9170_tx_fill_rateinfo(ar, r, t, txinfo);\n\tcarl9170_tx_status(ar, skb, success);\n}\n\nvoid carl9170_tx_process_status(struct ar9170 *ar,\n\t\t\t\tconst struct carl9170_rsp *cmd)\n{\n\tunsigned int i;\n\n\tfor (i = 0;  i < cmd->hdr.ext; i++) {\n\t\tif (WARN_ON(i > ((cmd->hdr.len / 2) + 1))) {\n\t\t\tprint_hex_dump_bytes(\"UU:\", DUMP_PREFIX_NONE,\n\t\t\t\t\t     (void *) cmd, cmd->hdr.len + 4);\n\t\t\tbreak;\n\t\t}\n\n\t\t__carl9170_tx_process_status(ar, cmd->_tx_status[i].cookie,\n\t\t\t\t\t     cmd->_tx_status[i].info);\n\t}\n}\n\nstatic void carl9170_tx_rate_tpc_chains(struct ar9170 *ar,\n\tstruct ieee80211_tx_info *info,\tstruct ieee80211_tx_rate *txrate,\n\tunsigned int *phyrate, unsigned int *tpc, unsigned int *chains)\n{\n\tstruct ieee80211_rate *rate = NULL;\n\tu8 *txpower;\n\tunsigned int idx;\n\n\tidx = txrate->idx;\n\t*tpc = 0;\n\t*phyrate = 0;\n\n\tif (txrate->flags & IEEE80211_TX_RC_MCS) {\n\t\tif (txrate->flags & IEEE80211_TX_RC_40_MHZ_WIDTH) {\n\t\t\t \n\t\t\t*tpc += 2;\n\n\t\t\tif (info->band == NL80211_BAND_2GHZ)\n\t\t\t\ttxpower = ar->power_2G_ht40;\n\t\t\telse\n\t\t\t\ttxpower = ar->power_5G_ht40;\n\t\t} else {\n\t\t\tif (info->band == NL80211_BAND_2GHZ)\n\t\t\t\ttxpower = ar->power_2G_ht20;\n\t\t\telse\n\t\t\t\ttxpower = ar->power_5G_ht20;\n\t\t}\n\n\t\t*phyrate = txrate->idx;\n\t\t*tpc += txpower[idx & 7];\n\t} else {\n\t\tif (info->band == NL80211_BAND_2GHZ) {\n\t\t\tif (idx < 4)\n\t\t\t\ttxpower = ar->power_2G_cck;\n\t\t\telse\n\t\t\t\ttxpower = ar->power_2G_ofdm;\n\t\t} else {\n\t\t\ttxpower = ar->power_5G_leg;\n\t\t\tidx += 4;\n\t\t}\n\n\t\trate = &__carl9170_ratetable[idx];\n\t\t*tpc += txpower[(rate->hw_value & 0x30) >> 4];\n\t\t*phyrate = rate->hw_value & 0xf;\n\t}\n\n\tif (ar->eeprom.tx_mask == 1) {\n\t\t*chains = AR9170_TX_PHY_TXCHAIN_1;\n\t} else {\n\t\tif (!(txrate->flags & IEEE80211_TX_RC_MCS) &&\n\t\t    rate && rate->bitrate >= 360)\n\t\t\t*chains = AR9170_TX_PHY_TXCHAIN_1;\n\t\telse\n\t\t\t*chains = AR9170_TX_PHY_TXCHAIN_2;\n\t}\n\n\t*tpc = min_t(unsigned int, *tpc, ar->hw->conf.power_level * 2);\n}\n\nstatic __le32 carl9170_tx_physet(struct ar9170 *ar,\n\tstruct ieee80211_tx_info *info, struct ieee80211_tx_rate *txrate)\n{\n\tunsigned int power = 0, chains = 0, phyrate = 0;\n\t__le32 tmp;\n\n\ttmp = cpu_to_le32(0);\n\n\tif (txrate->flags & IEEE80211_TX_RC_40_MHZ_WIDTH)\n\t\ttmp |= cpu_to_le32(AR9170_TX_PHY_BW_40MHZ <<\n\t\t\tAR9170_TX_PHY_BW_S);\n\t \n\tif (txrate->flags & IEEE80211_TX_RC_DUP_DATA)\n\t\ttmp |= cpu_to_le32(AR9170_TX_PHY_BW_40MHZ_DUP <<\n\t\t\tAR9170_TX_PHY_BW_S);\n\n\tif (txrate->flags & IEEE80211_TX_RC_SHORT_GI)\n\t\ttmp |= cpu_to_le32(AR9170_TX_PHY_SHORT_GI);\n\n\tif (txrate->flags & IEEE80211_TX_RC_MCS) {\n\t\tSET_VAL(AR9170_TX_PHY_MCS, phyrate, txrate->idx);\n\n\t\t \n\t\ttmp |= cpu_to_le32((txrate->idx & 0x7) <<\n\t\t\tAR9170_TX_PHY_TX_HEAVY_CLIP_S);\n\n\t\ttmp |= cpu_to_le32(AR9170_TX_PHY_MOD_HT);\n\n\t\t \n\t} else {\n\t\tif (info->band == NL80211_BAND_2GHZ) {\n\t\t\tif (txrate->idx <= AR9170_TX_PHY_RATE_CCK_11M)\n\t\t\t\ttmp |= cpu_to_le32(AR9170_TX_PHY_MOD_CCK);\n\t\t\telse\n\t\t\t\ttmp |= cpu_to_le32(AR9170_TX_PHY_MOD_OFDM);\n\t\t} else {\n\t\t\ttmp |= cpu_to_le32(AR9170_TX_PHY_MOD_OFDM);\n\t\t}\n\n\t\t \n\t}\n\tcarl9170_tx_rate_tpc_chains(ar, info, txrate,\n\t\t\t\t    &phyrate, &power, &chains);\n\n\ttmp |= cpu_to_le32(SET_CONSTVAL(AR9170_TX_PHY_MCS, phyrate));\n\ttmp |= cpu_to_le32(SET_CONSTVAL(AR9170_TX_PHY_TX_PWR, power));\n\ttmp |= cpu_to_le32(SET_CONSTVAL(AR9170_TX_PHY_TXCHAIN, chains));\n\treturn tmp;\n}\n\nstatic bool carl9170_tx_rts_check(struct ar9170 *ar,\n\t\t\t\t  struct ieee80211_tx_rate *rate,\n\t\t\t\t  bool ampdu, bool multi)\n{\n\tswitch (ar->erp_mode) {\n\tcase CARL9170_ERP_AUTO:\n\t\tif (ampdu)\n\t\t\tbreak;\n\t\tfallthrough;\n\n\tcase CARL9170_ERP_MAC80211:\n\t\tif (!(rate->flags & IEEE80211_TX_RC_USE_RTS_CTS))\n\t\t\tbreak;\n\t\tfallthrough;\n\n\tcase CARL9170_ERP_RTS:\n\t\tif (likely(!multi))\n\t\t\treturn true;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\nstatic bool carl9170_tx_cts_check(struct ar9170 *ar,\n\t\t\t\t  struct ieee80211_tx_rate *rate)\n{\n\tswitch (ar->erp_mode) {\n\tcase CARL9170_ERP_AUTO:\n\tcase CARL9170_ERP_MAC80211:\n\t\tif (!(rate->flags & IEEE80211_TX_RC_USE_CTS_PROTECT))\n\t\t\tbreak;\n\t\tfallthrough;\n\n\tcase CARL9170_ERP_CTS:\n\t\treturn true;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\nstatic void carl9170_tx_get_rates(struct ar9170 *ar,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  struct ieee80211_sta *sta,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct ieee80211_tx_info *info;\n\n\tBUILD_BUG_ON(IEEE80211_TX_MAX_RATES < CARL9170_TX_MAX_RATES);\n\tBUILD_BUG_ON(IEEE80211_TX_MAX_RATES > IEEE80211_TX_RATE_TABLE_SIZE);\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\n\tieee80211_get_tx_rates(vif, sta, skb,\n\t\t\t       info->control.rates,\n\t\t\t       IEEE80211_TX_MAX_RATES);\n}\n\nstatic void carl9170_tx_apply_rateset(struct ar9170 *ar,\n\t\t\t\t      struct ieee80211_tx_info *sinfo,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct ieee80211_tx_rate *txrate;\n\tstruct ieee80211_tx_info *info;\n\tstruct _carl9170_tx_superframe *txc = (void *) skb->data;\n\tint i;\n\tbool ampdu;\n\tbool no_ack;\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\tampdu = !!(info->flags & IEEE80211_TX_CTL_AMPDU);\n\tno_ack = !!(info->flags & IEEE80211_TX_CTL_NO_ACK);\n\n\t \n\tinfo->flags |= (sinfo->flags & IEEE80211_TX_CTL_RATE_CTRL_PROBE);\n\n\t \n\tfor (i = 0; i < CARL9170_TX_MAX_RATES; i++) {\n\t\t__le32 phy_set;\n\n\t\ttxrate = &sinfo->control.rates[i];\n\t\tif (txrate->idx < 0)\n\t\t\tbreak;\n\n\t\tphy_set = carl9170_tx_physet(ar, info, txrate);\n\t\tif (i == 0) {\n\t\t\t__le16 mac_tmp = cpu_to_le16(0);\n\n\t\t\t \n\t\t\ttxc->f.phy_control = phy_set;\n\n\t\t\tif (ampdu && txrate->flags & IEEE80211_TX_RC_MCS)\n\t\t\t\tmac_tmp |= cpu_to_le16(AR9170_TX_MAC_AGGR);\n\n\t\t\tif (carl9170_tx_rts_check(ar, txrate, ampdu, no_ack))\n\t\t\t\tmac_tmp |= cpu_to_le16(AR9170_TX_MAC_PROT_RTS);\n\t\t\telse if (carl9170_tx_cts_check(ar, txrate))\n\t\t\t\tmac_tmp |= cpu_to_le16(AR9170_TX_MAC_PROT_CTS);\n\n\t\t\ttxc->f.mac_control |= mac_tmp;\n\t\t} else {\n\t\t\t \n\t\t\ttxc->s.rr[i - 1] = phy_set;\n\t\t}\n\n\t\tSET_VAL(CARL9170_TX_SUPER_RI_TRIES, txc->s.ri[i],\n\t\t\ttxrate->count);\n\n\t\tif (carl9170_tx_rts_check(ar, txrate, ampdu, no_ack))\n\t\t\ttxc->s.ri[i] |= (AR9170_TX_MAC_PROT_RTS <<\n\t\t\t\tCARL9170_TX_SUPER_RI_ERP_PROT_S);\n\t\telse if (carl9170_tx_cts_check(ar, txrate))\n\t\t\ttxc->s.ri[i] |= (AR9170_TX_MAC_PROT_CTS <<\n\t\t\t\tCARL9170_TX_SUPER_RI_ERP_PROT_S);\n\n\t\tif (ampdu && (txrate->flags & IEEE80211_TX_RC_MCS))\n\t\t\ttxc->s.ri[i] |= CARL9170_TX_SUPER_RI_AMPDU;\n\t}\n}\n\nstatic int carl9170_tx_prepare(struct ar9170 *ar,\n\t\t\t       struct ieee80211_sta *sta,\n\t\t\t       struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr;\n\tstruct _carl9170_tx_superframe *txc;\n\tstruct carl9170_vif_info *cvif;\n\tstruct ieee80211_tx_info *info;\n\tstruct carl9170_tx_info *arinfo;\n\tunsigned int hw_queue;\n\t__le16 mac_tmp;\n\tu16 len;\n\n\tBUILD_BUG_ON(sizeof(*arinfo) > sizeof(info->rate_driver_data));\n\tBUILD_BUG_ON(sizeof(struct _carl9170_tx_superdesc) !=\n\t\t     CARL9170_TX_SUPERDESC_LEN);\n\n\tBUILD_BUG_ON(sizeof(struct _ar9170_tx_hwdesc) !=\n\t\t     AR9170_TX_HWDESC_LEN);\n\n\tBUILD_BUG_ON(AR9170_MAX_VIRTUAL_MAC >\n\t\t((CARL9170_TX_SUPER_MISC_VIF_ID >>\n\t\t CARL9170_TX_SUPER_MISC_VIF_ID_S) + 1));\n\n\thw_queue = ar9170_qmap(carl9170_get_queue(ar, skb));\n\n\thdr = (void *)skb->data;\n\tinfo = IEEE80211_SKB_CB(skb);\n\tlen = skb->len;\n\n\t \n\tif (likely(info->control.vif))\n\t\tcvif = (void *) info->control.vif->drv_priv;\n\telse\n\t\tcvif = NULL;\n\n\ttxc = skb_push(skb, sizeof(*txc));\n\tmemset(txc, 0, sizeof(*txc));\n\n\tSET_VAL(CARL9170_TX_SUPER_MISC_QUEUE, txc->s.misc, hw_queue);\n\n\tif (likely(cvif))\n\t\tSET_VAL(CARL9170_TX_SUPER_MISC_VIF_ID, txc->s.misc, cvif->id);\n\n\tif (unlikely(info->flags & IEEE80211_TX_CTL_SEND_AFTER_DTIM))\n\t\ttxc->s.misc |= CARL9170_TX_SUPER_MISC_CAB;\n\n\tif (unlikely(info->flags & IEEE80211_TX_CTL_ASSIGN_SEQ))\n\t\ttxc->s.misc |= CARL9170_TX_SUPER_MISC_ASSIGN_SEQ;\n\n\tif (unlikely(ieee80211_is_probe_resp(hdr->frame_control)))\n\t\ttxc->s.misc |= CARL9170_TX_SUPER_MISC_FILL_IN_TSF;\n\n\tmac_tmp = cpu_to_le16(AR9170_TX_MAC_HW_DURATION |\n\t\t\t      AR9170_TX_MAC_BACKOFF);\n\tmac_tmp |= cpu_to_le16((hw_queue << AR9170_TX_MAC_QOS_S) &\n\t\t\t       AR9170_TX_MAC_QOS);\n\n\tif (unlikely(info->flags & IEEE80211_TX_CTL_NO_ACK))\n\t\tmac_tmp |= cpu_to_le16(AR9170_TX_MAC_NO_ACK);\n\n\tif (info->control.hw_key) {\n\t\tlen += info->control.hw_key->icv_len;\n\n\t\tswitch (info->control.hw_key->cipher) {\n\t\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\t\tmac_tmp |= cpu_to_le16(AR9170_TX_MAC_ENCR_RC4);\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\t\tmac_tmp |= cpu_to_le16(AR9170_TX_MAC_ENCR_AES);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tif (info->flags & IEEE80211_TX_CTL_AMPDU) {\n\t\tunsigned int density, factor;\n\n\t\tif (unlikely(!sta || !cvif))\n\t\t\tgoto err_out;\n\n\t\tfactor = min_t(unsigned int, 1u,\n\t\t\t       sta->deflink.ht_cap.ampdu_factor);\n\t\tdensity = sta->deflink.ht_cap.ampdu_density;\n\n\t\tif (density) {\n\t\t\t \n\n\t\t\tdensity = max_t(unsigned int, density + 1, 7u);\n\t\t}\n\n\t\tSET_VAL(CARL9170_TX_SUPER_AMPDU_DENSITY,\n\t\t\ttxc->s.ampdu_settings, density);\n\n\t\tSET_VAL(CARL9170_TX_SUPER_AMPDU_FACTOR,\n\t\t\ttxc->s.ampdu_settings, factor);\n\t}\n\n\ttxc->s.len = cpu_to_le16(skb->len);\n\ttxc->f.length = cpu_to_le16(len + FCS_LEN);\n\ttxc->f.mac_control = mac_tmp;\n\n\tarinfo = (void *)info->rate_driver_data;\n\tarinfo->timeout = jiffies;\n\tarinfo->ar = ar;\n\tkref_init(&arinfo->ref);\n\treturn 0;\n\nerr_out:\n\tskb_pull(skb, sizeof(*txc));\n\treturn -EINVAL;\n}\n\nstatic void carl9170_set_immba(struct ar9170 *ar, struct sk_buff *skb)\n{\n\tstruct _carl9170_tx_superframe *super;\n\n\tsuper = (void *) skb->data;\n\tsuper->f.mac_control |= cpu_to_le16(AR9170_TX_MAC_IMM_BA);\n}\n\nstatic void carl9170_set_ampdu_params(struct ar9170 *ar, struct sk_buff *skb)\n{\n\tstruct _carl9170_tx_superframe *super;\n\tint tmp;\n\n\tsuper = (void *) skb->data;\n\n\ttmp = (super->s.ampdu_settings & CARL9170_TX_SUPER_AMPDU_DENSITY) <<\n\t\tCARL9170_TX_SUPER_AMPDU_DENSITY_S;\n\n\t \n\n\tif (tmp != ar->current_density) {\n\t\tar->current_density = tmp;\n\t\tsuper->s.ampdu_settings |=\n\t\t\tCARL9170_TX_SUPER_AMPDU_COMMIT_DENSITY;\n\t}\n\n\ttmp = (super->s.ampdu_settings & CARL9170_TX_SUPER_AMPDU_FACTOR) <<\n\t\tCARL9170_TX_SUPER_AMPDU_FACTOR_S;\n\n\tif (tmp != ar->current_factor) {\n\t\tar->current_factor = tmp;\n\t\tsuper->s.ampdu_settings |=\n\t\t\tCARL9170_TX_SUPER_AMPDU_COMMIT_FACTOR;\n\t}\n}\n\nstatic void carl9170_tx_ampdu(struct ar9170 *ar)\n{\n\tstruct sk_buff_head agg;\n\tstruct carl9170_sta_tid *tid_info;\n\tstruct sk_buff *skb, *first;\n\tstruct ieee80211_tx_info *tx_info_first;\n\tunsigned int i = 0, done_ampdus = 0;\n\tu16 seq, queue, tmpssn;\n\n\tatomic_inc(&ar->tx_ampdu_scheduler);\n\tar->tx_ampdu_schedule = false;\n\n\tif (atomic_read(&ar->tx_ampdu_upload))\n\t\treturn;\n\n\tif (!ar->tx_ampdu_list_len)\n\t\treturn;\n\n\t__skb_queue_head_init(&agg);\n\n\trcu_read_lock();\n\ttid_info = rcu_dereference(ar->tx_ampdu_iter);\n\tif (WARN_ON_ONCE(!tid_info)) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\nretry:\n\tlist_for_each_entry_continue_rcu(tid_info, &ar->tx_ampdu_list, list) {\n\t\ti++;\n\n\t\tif (tid_info->state < CARL9170_TID_STATE_PROGRESS)\n\t\t\tcontinue;\n\n\t\tqueue = TID_TO_WME_AC(tid_info->tid);\n\n\t\tspin_lock_bh(&tid_info->lock);\n\t\tif (tid_info->state != CARL9170_TID_STATE_XMIT)\n\t\t\tgoto processed;\n\n\t\ttid_info->counter++;\n\t\tfirst = skb_peek(&tid_info->queue);\n\t\ttmpssn = carl9170_get_seq(first);\n\t\tseq = tid_info->snx;\n\n\t\tif (unlikely(tmpssn != seq)) {\n\t\t\ttid_info->state = CARL9170_TID_STATE_IDLE;\n\n\t\t\tgoto processed;\n\t\t}\n\n\t\ttx_info_first = NULL;\n\t\twhile ((skb = skb_peek(&tid_info->queue))) {\n\t\t\t \n\t\t\tif (unlikely(carl9170_get_seq(skb) != seq))\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (unlikely(SEQ_DIFF(tid_info->snx, tid_info->bsn) >=\n\t\t\t    (tid_info->max - 1)))\n\t\t\t\tbreak;\n\n\t\t\tif (!tx_info_first) {\n\t\t\t\tcarl9170_tx_get_rates(ar, tid_info->vif,\n\t\t\t\t\t\t      tid_info->sta, first);\n\t\t\t\ttx_info_first = IEEE80211_SKB_CB(first);\n\t\t\t}\n\n\t\t\tcarl9170_tx_apply_rateset(ar, tx_info_first, skb);\n\n\t\t\tatomic_inc(&ar->tx_ampdu_upload);\n\t\t\ttid_info->snx = seq = SEQ_NEXT(seq);\n\t\t\t__skb_unlink(skb, &tid_info->queue);\n\n\t\t\t__skb_queue_tail(&agg, skb);\n\n\t\t\tif (skb_queue_len(&agg) >= CARL9170_NUM_TX_AGG_MAX)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (skb_queue_empty(&tid_info->queue) ||\n\t\t    carl9170_get_seq(skb_peek(&tid_info->queue)) !=\n\t\t    tid_info->snx) {\n\t\t\t \n\n\t\t\ttid_info->state = CARL9170_TID_STATE_IDLE;\n\t\t}\n\t\tdone_ampdus++;\n\nprocessed:\n\t\tspin_unlock_bh(&tid_info->lock);\n\n\t\tif (skb_queue_empty(&agg))\n\t\t\tcontinue;\n\n\t\t \n\t\tcarl9170_set_ampdu_params(ar, skb_peek(&agg));\n\n\t\t \n\t\tcarl9170_set_immba(ar, skb_peek_tail(&agg));\n\n\t\tspin_lock_bh(&ar->tx_pending[queue].lock);\n\t\tskb_queue_splice_tail_init(&agg, &ar->tx_pending[queue]);\n\t\tspin_unlock_bh(&ar->tx_pending[queue].lock);\n\t\tar->tx_schedule = true;\n\t}\n\tif ((done_ampdus++ == 0) && (i++ == 0))\n\t\tgoto retry;\n\n\trcu_assign_pointer(ar->tx_ampdu_iter, tid_info);\n\trcu_read_unlock();\n}\n\nstatic struct sk_buff *carl9170_tx_pick_skb(struct ar9170 *ar,\n\t\t\t\t\t    struct sk_buff_head *queue)\n{\n\tstruct sk_buff *skb;\n\tstruct ieee80211_tx_info *info;\n\tstruct carl9170_tx_info *arinfo;\n\n\tBUILD_BUG_ON(sizeof(*arinfo) > sizeof(info->rate_driver_data));\n\n\tspin_lock_bh(&queue->lock);\n\tskb = skb_peek(queue);\n\tif (unlikely(!skb))\n\t\tgoto err_unlock;\n\n\tif (carl9170_alloc_dev_space(ar, skb))\n\t\tgoto err_unlock;\n\n\t__skb_unlink(skb, queue);\n\tspin_unlock_bh(&queue->lock);\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\tarinfo = (void *) info->rate_driver_data;\n\n\tarinfo->timeout = jiffies;\n\treturn skb;\n\nerr_unlock:\n\tspin_unlock_bh(&queue->lock);\n\treturn NULL;\n}\n\nvoid carl9170_tx_drop(struct ar9170 *ar, struct sk_buff *skb)\n{\n\tstruct _carl9170_tx_superframe *super;\n\tuint8_t q = 0;\n\n\tar->tx_dropped++;\n\n\tsuper = (void *)skb->data;\n\tSET_VAL(CARL9170_TX_SUPER_MISC_QUEUE, q,\n\t\tar9170_qmap(carl9170_get_queue(ar, skb)));\n\t__carl9170_tx_process_status(ar, super->s.cookie, q);\n}\n\nstatic bool carl9170_tx_ps_drop(struct ar9170 *ar, struct sk_buff *skb)\n{\n\tstruct ieee80211_sta *sta;\n\tstruct carl9170_sta_info *sta_info;\n\tstruct ieee80211_tx_info *tx_info;\n\n\trcu_read_lock();\n\tsta = __carl9170_get_tx_sta(ar, skb);\n\tif (!sta)\n\t\tgoto out_rcu;\n\n\tsta_info = (void *) sta->drv_priv;\n\ttx_info = IEEE80211_SKB_CB(skb);\n\n\tif (unlikely(sta_info->sleeping) &&\n\t    !(tx_info->flags & (IEEE80211_TX_CTL_NO_PS_BUFFER |\n\t\t\t\tIEEE80211_TX_CTL_CLEAR_PS_FILT))) {\n\t\trcu_read_unlock();\n\n\t\tif (tx_info->flags & IEEE80211_TX_CTL_AMPDU)\n\t\t\tatomic_dec(&ar->tx_ampdu_upload);\n\n\t\ttx_info->flags |= IEEE80211_TX_STAT_TX_FILTERED;\n\t\tcarl9170_release_dev_space(ar, skb);\n\t\tcarl9170_tx_status(ar, skb, false);\n\t\treturn true;\n\t}\n\nout_rcu:\n\trcu_read_unlock();\n\treturn false;\n}\n\nstatic void carl9170_bar_check(struct ar9170 *ar, struct sk_buff *skb)\n{\n\tstruct _carl9170_tx_superframe *super = (void *) skb->data;\n\tstruct ieee80211_bar *bar = (void *) super->frame_data;\n\n\tif (unlikely(ieee80211_is_back_req(bar->frame_control)) &&\n\t    skb->len >= sizeof(struct ieee80211_bar)) {\n\t\tstruct carl9170_bar_list_entry *entry;\n\t\tunsigned int queue = skb_get_queue_mapping(skb);\n\n\t\tentry = kmalloc(sizeof(*entry), GFP_ATOMIC);\n\t\tif (!WARN_ON_ONCE(!entry)) {\n\t\t\tentry->skb = skb;\n\t\t\tspin_lock_bh(&ar->bar_list_lock[queue]);\n\t\t\tlist_add_tail_rcu(&entry->list, &ar->bar_list[queue]);\n\t\t\tspin_unlock_bh(&ar->bar_list_lock[queue]);\n\t\t}\n\t}\n}\n\nstatic void carl9170_tx(struct ar9170 *ar)\n{\n\tstruct sk_buff *skb;\n\tunsigned int i, q;\n\tbool schedule_garbagecollector = false;\n\n\tar->tx_schedule = false;\n\n\tif (unlikely(!IS_STARTED(ar)))\n\t\treturn;\n\n\tcarl9170_usb_handle_tx_err(ar);\n\n\tfor (i = 0; i < ar->hw->queues; i++) {\n\t\twhile (!skb_queue_empty(&ar->tx_pending[i])) {\n\t\t\tskb = carl9170_tx_pick_skb(ar, &ar->tx_pending[i]);\n\t\t\tif (unlikely(!skb))\n\t\t\t\tbreak;\n\n\t\t\tif (unlikely(carl9170_tx_ps_drop(ar, skb)))\n\t\t\t\tcontinue;\n\n\t\t\tcarl9170_bar_check(ar, skb);\n\n\t\t\tatomic_inc(&ar->tx_total_pending);\n\n\t\t\tq = __carl9170_get_queue(ar, i);\n\t\t\t \n\t\t\tskb_queue_tail(&ar->tx_status[q], skb);\n\n\t\t\t \n\t\t\tcarl9170_tx_get_skb(skb);\n\n\t\t\tcarl9170_usb_tx(ar, skb);\n\t\t\tschedule_garbagecollector = true;\n\t\t}\n\t}\n\n\tif (!schedule_garbagecollector)\n\t\treturn;\n\n\tieee80211_queue_delayed_work(ar->hw, &ar->tx_janitor,\n\t\tmsecs_to_jiffies(CARL9170_TX_TIMEOUT));\n}\n\nstatic bool carl9170_tx_ampdu_queue(struct ar9170 *ar,\n\tstruct ieee80211_sta *sta, struct sk_buff *skb,\n\tstruct ieee80211_tx_info *txinfo)\n{\n\tstruct carl9170_sta_info *sta_info;\n\tstruct carl9170_sta_tid *agg;\n\tstruct sk_buff *iter;\n\tu16 tid, seq, qseq, off;\n\tbool run = false;\n\n\ttid = carl9170_get_tid(skb);\n\tseq = carl9170_get_seq(skb);\n\tsta_info = (void *) sta->drv_priv;\n\n\trcu_read_lock();\n\tagg = rcu_dereference(sta_info->agg[tid]);\n\n\tif (!agg)\n\t\tgoto err_unlock_rcu;\n\n\tspin_lock_bh(&agg->lock);\n\tif (unlikely(agg->state < CARL9170_TID_STATE_IDLE))\n\t\tgoto err_unlock;\n\n\t \n\tif (unlikely(!BAW_WITHIN(agg->bsn, CARL9170_BAW_BITS, seq)))\n\t\tgoto err_unlock;\n\n\tif (WARN_ON_ONCE(!BAW_WITHIN(agg->snx, CARL9170_BAW_BITS, seq)))\n\t\tgoto err_unlock;\n\n\toff = SEQ_DIFF(seq, agg->bsn);\n\tif (WARN_ON_ONCE(test_and_set_bit(off, agg->bitmap)))\n\t\tgoto err_unlock;\n\n\tif (likely(BAW_WITHIN(agg->hsn, CARL9170_BAW_BITS, seq))) {\n\t\t__skb_queue_tail(&agg->queue, skb);\n\t\tagg->hsn = seq;\n\t\tgoto queued;\n\t}\n\n\tskb_queue_reverse_walk(&agg->queue, iter) {\n\t\tqseq = carl9170_get_seq(iter);\n\n\t\tif (BAW_WITHIN(qseq, CARL9170_BAW_BITS, seq)) {\n\t\t\t__skb_queue_after(&agg->queue, iter, skb);\n\t\t\tgoto queued;\n\t\t}\n\t}\n\n\t__skb_queue_head(&agg->queue, skb);\nqueued:\n\n\tif (unlikely(agg->state != CARL9170_TID_STATE_XMIT)) {\n\t\tif (agg->snx == carl9170_get_seq(skb_peek(&agg->queue))) {\n\t\t\tagg->state = CARL9170_TID_STATE_XMIT;\n\t\t\trun = true;\n\t\t}\n\t}\n\n\tspin_unlock_bh(&agg->lock);\n\trcu_read_unlock();\n\n\treturn run;\n\nerr_unlock:\n\tspin_unlock_bh(&agg->lock);\n\nerr_unlock_rcu:\n\trcu_read_unlock();\n\ttxinfo->flags &= ~IEEE80211_TX_CTL_AMPDU;\n\tcarl9170_tx_status(ar, skb, false);\n\tar->tx_dropped++;\n\treturn false;\n}\n\nvoid carl9170_op_tx(struct ieee80211_hw *hw,\n\t\t    struct ieee80211_tx_control *control,\n\t\t    struct sk_buff *skb)\n{\n\tstruct ar9170 *ar = hw->priv;\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211_sta *sta = control->sta;\n\tstruct ieee80211_vif *vif;\n\tbool run;\n\n\tif (unlikely(!IS_STARTED(ar)))\n\t\tgoto err_free;\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\tvif = info->control.vif;\n\n\tif (unlikely(carl9170_tx_prepare(ar, sta, skb)))\n\t\tgoto err_free;\n\n\tcarl9170_tx_accounting(ar, skb);\n\t \n\n\tif (sta) {\n\t\tstruct carl9170_sta_info *stai = (void *) sta->drv_priv;\n\t\tatomic_inc(&stai->pending_frames);\n\t}\n\n\tif (info->flags & IEEE80211_TX_CTL_AMPDU) {\n\t\t \n\t\trun = carl9170_tx_ampdu_queue(ar, sta, skb, info);\n\t\tif (run)\n\t\t\tcarl9170_tx_ampdu(ar);\n\n\t} else {\n\t\tunsigned int queue = skb_get_queue_mapping(skb);\n\n\t\tcarl9170_tx_get_rates(ar, vif, sta, skb);\n\t\tcarl9170_tx_apply_rateset(ar, info, skb);\n\t\tskb_queue_tail(&ar->tx_pending[queue], skb);\n\t}\n\n\tcarl9170_tx(ar);\n\treturn;\n\nerr_free:\n\tar->tx_dropped++;\n\tieee80211_free_txskb(ar->hw, skb);\n}\n\nvoid carl9170_tx_scheduler(struct ar9170 *ar)\n{\n\n\tif (ar->tx_ampdu_schedule)\n\t\tcarl9170_tx_ampdu(ar);\n\n\tif (ar->tx_schedule)\n\t\tcarl9170_tx(ar);\n}\n\n \nstatic struct carl9170_vif_info *carl9170_pick_beaconing_vif(struct ar9170 *ar)\n{\n\tstruct carl9170_vif_info *cvif;\n\tint i = 1;\n\n\t \n\n\tcvif = rcu_dereference(ar->beacon_iter);\n\tif (ar->vifs > 0 && cvif) {\n\t\tdo {\n\t\t\tlist_for_each_entry_continue_rcu(cvif, &ar->vif_list,\n\t\t\t\t\t\t\t list) {\n\t\t\t\tif (cvif->active && cvif->enable_beacon)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t} while (ar->beacon_enabled && i--);\n\n\t\t \n\t\treturn NULL;\n\t}\n\nout:\n\tRCU_INIT_POINTER(ar->beacon_iter, cvif);\n\treturn cvif;\n}\n\nstatic bool carl9170_tx_beacon_physet(struct ar9170 *ar, struct sk_buff *skb,\n\t\t\t\t      u32 *ht1, u32 *plcp)\n{\n\tstruct ieee80211_tx_info *txinfo;\n\tstruct ieee80211_tx_rate *rate;\n\tunsigned int power, chains;\n\tbool ht_rate;\n\n\ttxinfo = IEEE80211_SKB_CB(skb);\n\trate = &txinfo->control.rates[0];\n\tht_rate = !!(txinfo->control.rates[0].flags & IEEE80211_TX_RC_MCS);\n\tcarl9170_tx_rate_tpc_chains(ar, txinfo, rate, plcp, &power, &chains);\n\n\t*ht1 = AR9170_MAC_BCN_HT1_TX_ANT0;\n\tif (chains == AR9170_TX_PHY_TXCHAIN_2)\n\t\t*ht1 |= AR9170_MAC_BCN_HT1_TX_ANT1;\n\tSET_VAL(AR9170_MAC_BCN_HT1_PWR_CTRL, *ht1, 7);\n\tSET_VAL(AR9170_MAC_BCN_HT1_TPC, *ht1, power);\n\tSET_VAL(AR9170_MAC_BCN_HT1_CHAIN_MASK, *ht1, chains);\n\n\tif (ht_rate) {\n\t\t*ht1 |= AR9170_MAC_BCN_HT1_HT_EN;\n\t\tif (rate->flags & IEEE80211_TX_RC_SHORT_GI)\n\t\t\t*plcp |= AR9170_MAC_BCN_HT2_SGI;\n\n\t\tif (rate->flags & IEEE80211_TX_RC_40_MHZ_WIDTH) {\n\t\t\t*ht1 |= AR9170_MAC_BCN_HT1_BWC_40M_SHARED;\n\t\t\t*plcp |= AR9170_MAC_BCN_HT2_BW40;\n\t\t} else if (rate->flags & IEEE80211_TX_RC_DUP_DATA) {\n\t\t\t*ht1 |= AR9170_MAC_BCN_HT1_BWC_40M_DUP;\n\t\t\t*plcp |= AR9170_MAC_BCN_HT2_BW40;\n\t\t}\n\n\t\tSET_VAL(AR9170_MAC_BCN_HT2_LEN, *plcp, skb->len + FCS_LEN);\n\t} else {\n\t\tif (*plcp <= AR9170_TX_PHY_RATE_CCK_11M)\n\t\t\t*plcp |= ((skb->len + FCS_LEN) << (3 + 16)) + 0x0400;\n\t\telse\n\t\t\t*plcp |= ((skb->len + FCS_LEN) << 16) + 0x0010;\n\t}\n\n\treturn ht_rate;\n}\n\nint carl9170_update_beacon(struct ar9170 *ar, const bool submit)\n{\n\tstruct sk_buff *skb = NULL;\n\tstruct carl9170_vif_info *cvif;\n\t__le32 *data, *old = NULL;\n\tu32 word, ht1, plcp, off, addr, len;\n\tint i = 0, err = 0;\n\tbool ht_rate;\n\n\trcu_read_lock();\n\tcvif = carl9170_pick_beaconing_vif(ar);\n\tif (!cvif)\n\t\tgoto out_unlock;\n\n\tskb = ieee80211_beacon_get_tim(ar->hw, carl9170_get_vif(cvif),\n\t\t\t\t       NULL, NULL, 0);\n\n\tif (!skb) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free;\n\t}\n\n\tspin_lock_bh(&ar->beacon_lock);\n\tdata = (__le32 *)skb->data;\n\tif (cvif->beacon)\n\t\told = (__le32 *)cvif->beacon->data;\n\n\toff = cvif->id * AR9170_MAC_BCN_LENGTH_MAX;\n\taddr = ar->fw.beacon_addr + off;\n\tlen = roundup(skb->len + FCS_LEN, 4);\n\n\tif ((off + len) > ar->fw.beacon_max_len) {\n\t\tif (net_ratelimit()) {\n\t\t\twiphy_err(ar->hw->wiphy, \"beacon does not \"\n\t\t\t\t  \"fit into device memory!\\n\");\n\t\t}\n\t\terr = -EINVAL;\n\t\tgoto err_unlock;\n\t}\n\n\tif (len > AR9170_MAC_BCN_LENGTH_MAX) {\n\t\tif (net_ratelimit()) {\n\t\t\twiphy_err(ar->hw->wiphy, \"no support for beacons \"\n\t\t\t\t\"bigger than %d (yours:%d).\\n\",\n\t\t\t\t AR9170_MAC_BCN_LENGTH_MAX, len);\n\t\t}\n\n\t\terr = -EMSGSIZE;\n\t\tgoto err_unlock;\n\t}\n\n\tht_rate = carl9170_tx_beacon_physet(ar, skb, &ht1, &plcp);\n\n\tcarl9170_async_regwrite_begin(ar);\n\tcarl9170_async_regwrite(AR9170_MAC_REG_BCN_HT1, ht1);\n\tif (ht_rate)\n\t\tcarl9170_async_regwrite(AR9170_MAC_REG_BCN_HT2, plcp);\n\telse\n\t\tcarl9170_async_regwrite(AR9170_MAC_REG_BCN_PLCP, plcp);\n\n\tfor (i = 0; i < DIV_ROUND_UP(skb->len, 4); i++) {\n\t\t \n\n\t\tif (old && (data[i] == old[i]))\n\t\t\tcontinue;\n\n\t\tword = le32_to_cpu(data[i]);\n\t\tcarl9170_async_regwrite(addr + 4 * i, word);\n\t}\n\tcarl9170_async_regwrite_finish();\n\n\tdev_kfree_skb_any(cvif->beacon);\n\tcvif->beacon = NULL;\n\n\terr = carl9170_async_regwrite_result();\n\tif (!err)\n\t\tcvif->beacon = skb;\n\tspin_unlock_bh(&ar->beacon_lock);\n\tif (err)\n\t\tgoto err_free;\n\n\tif (submit) {\n\t\terr = carl9170_bcn_ctrl(ar, cvif->id,\n\t\t\t\t\tCARL9170_BCN_CTRL_CAB_TRIGGER,\n\t\t\t\t\taddr, skb->len + FCS_LEN);\n\n\t\tif (err)\n\t\t\tgoto err_free;\n\t}\nout_unlock:\n\trcu_read_unlock();\n\treturn 0;\n\nerr_unlock:\n\tspin_unlock_bh(&ar->beacon_lock);\n\nerr_free:\n\trcu_read_unlock();\n\tdev_kfree_skb_any(skb);\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}