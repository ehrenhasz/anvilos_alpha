{
  "module_name": "carl9170.h",
  "hash_id": "723dbdbde171ec836724644f83dc838a75a2a7506d2c6b577adb32dc78e1112e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/carl9170/carl9170.h",
  "human_readable_source": " \n#ifndef __CARL9170_H\n#define __CARL9170_H\n\n#include <linux/kernel.h>\n#include <linux/firmware.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/hw_random.h>\n#include <net/cfg80211.h>\n#include <net/mac80211.h>\n#include <linux/usb.h>\n#ifdef CONFIG_CARL9170_LEDS\n#include <linux/leds.h>\n#endif  \n#ifdef CONFIG_CARL9170_WPC\n#include <linux/input.h>\n#endif  \n#include \"eeprom.h\"\n#include \"wlan.h\"\n#include \"hw.h\"\n#include \"fwdesc.h\"\n#include \"fwcmd.h\"\n#include \"../regd.h\"\n\n#ifdef CONFIG_CARL9170_DEBUGFS\n#include \"debug.h\"\n#endif  \n\n#define CARL9170FW_NAME\t\"carl9170-1.fw\"\n\n#define PAYLOAD_MAX\t(CARL9170_MAX_CMD_LEN / 4 - 1)\n\nstatic inline u8 ar9170_qmap(u8 idx)\n{\n\treturn 3 - idx;  \n}\n\n#define CARL9170_MAX_RX_BUFFER_SIZE\t\t8192\n\nenum carl9170_device_state {\n\tCARL9170_UNKNOWN_STATE,\n\tCARL9170_STOPPED,\n\tCARL9170_IDLE,\n\tCARL9170_STARTED,\n};\n\n#define WME_BA_BMP_SIZE\t\t\t64\n#define CARL9170_TX_USER_RATE_TRIES\t3\n\n#define TID_TO_WME_AC(_tid)\t\t\t\t\\\n\t((((_tid) == 0) || ((_tid) == 3)) ? IEEE80211_AC_BE :\t\\\n\t (((_tid) == 1) || ((_tid) == 2)) ? IEEE80211_AC_BK :\t\\\n\t (((_tid) == 4) || ((_tid) == 5)) ? IEEE80211_AC_VI :\t\\\n\t IEEE80211_AC_VO)\n\n#define SEQ_DIFF(_start, _seq) \\\n\t(((_start) - (_seq)) & 0x0fff)\n#define SEQ_PREV(_seq) \\\n\t(((_seq) - 1) & 0x0fff)\n#define SEQ_NEXT(_seq) \\\n\t(((_seq) + 1) & 0x0fff)\n#define BAW_WITHIN(_start, _bawsz, _seqno) \\\n\t((((_seqno) - (_start)) & 0xfff) < (_bawsz))\n\nenum carl9170_tid_state {\n\tCARL9170_TID_STATE_INVALID,\n\tCARL9170_TID_STATE_KILLED,\n\tCARL9170_TID_STATE_SHUTDOWN,\n\tCARL9170_TID_STATE_SUSPEND,\n\tCARL9170_TID_STATE_PROGRESS,\n\tCARL9170_TID_STATE_IDLE,\n\tCARL9170_TID_STATE_XMIT,\n};\n\n#define CARL9170_BAW_BITS (2 * WME_BA_BMP_SIZE)\n#define CARL9170_BAW_SIZE (BITS_TO_LONGS(CARL9170_BAW_BITS))\n#define CARL9170_BAW_LEN (DIV_ROUND_UP(CARL9170_BAW_BITS, BITS_PER_BYTE))\n\nstruct carl9170_sta_tid {\n\t \n\tstruct list_head list;\n\n\t \n\tstruct list_head tmp_list;\n\n\t \n\tspinlock_t lock;\n\n\tunsigned int counter;\n\tenum carl9170_tid_state state;\n\tu8 tid;\t\t \n\tu16 max;\t \n\n\tu16 snx;\t \n\tu16 hsn;\t \n\tu16 bsn;\t \n\tunsigned long bitmap[CARL9170_BAW_SIZE];\n\n\t \n\tstruct sk_buff_head queue;\n\n\tstruct ieee80211_sta *sta;\n\tstruct ieee80211_vif *vif;\n};\n\n#define CARL9170_QUEUE_TIMEOUT\t\t256\n#define CARL9170_BUMP_QUEUE\t\t1000\n#define CARL9170_TX_TIMEOUT\t\t2500\n#define CARL9170_JANITOR_DELAY\t\t128\n#define CARL9170_QUEUE_STUCK_TIMEOUT\t5500\n#define CARL9170_STAT_WORK\t\t30000\n\n#define CARL9170_NUM_TX_AGG_MAX\t\t30\n\n \n#define CARL9170_NUM_TX_LIMIT_HARD\t((AR9170_TXQ_DEPTH * 3) / 2)\n#define CARL9170_NUM_TX_LIMIT_SOFT\t(AR9170_TXQ_DEPTH)\n\nstruct carl9170_tx_queue_stats {\n\tunsigned int count;\n\tunsigned int limit;\n\tunsigned int len;\n};\n\nstruct carl9170_vif {\n\tunsigned int id;\n\tstruct ieee80211_vif __rcu *vif;\n};\n\nstruct carl9170_vif_info {\n\tstruct list_head list;\n\tbool active;\n\tunsigned int id;\n\tstruct sk_buff *beacon;\n\tbool enable_beacon;\n};\n\n#define AR9170_NUM_RX_URBS\t16\n#define AR9170_NUM_RX_URBS_MUL\t2\n#define AR9170_NUM_TX_URBS\t8\n#define AR9170_NUM_RX_URBS_POOL (AR9170_NUM_RX_URBS_MUL * AR9170_NUM_RX_URBS)\n\nenum carl9170_device_features {\n\tCARL9170_WPS_BUTTON\t\t= BIT(0),\n\tCARL9170_ONE_LED\t\t= BIT(1),\n};\n\n#ifdef CONFIG_CARL9170_LEDS\nstruct ar9170;\n\nstruct carl9170_led {\n\tstruct ar9170 *ar;\n\tstruct led_classdev l;\n\tchar name[32];\n\tunsigned int toggled;\n\tbool last_state;\n\tbool registered;\n};\n#endif  \n\nenum carl9170_restart_reasons {\n\tCARL9170_RR_NO_REASON = 0,\n\tCARL9170_RR_FATAL_FIRMWARE_ERROR,\n\tCARL9170_RR_TOO_MANY_FIRMWARE_ERRORS,\n\tCARL9170_RR_WATCHDOG,\n\tCARL9170_RR_STUCK_TX,\n\tCARL9170_RR_UNRESPONSIVE_DEVICE,\n\tCARL9170_RR_COMMAND_TIMEOUT,\n\tCARL9170_RR_TOO_MANY_PHY_ERRORS,\n\tCARL9170_RR_LOST_RSP,\n\tCARL9170_RR_INVALID_RSP,\n\tCARL9170_RR_USER_REQUEST,\n\n\t__CARL9170_RR_LAST,\n};\n\nenum carl9170_erp_modes {\n\tCARL9170_ERP_INVALID,\n\tCARL9170_ERP_AUTO,\n\tCARL9170_ERP_MAC80211,\n\tCARL9170_ERP_OFF,\n\tCARL9170_ERP_CTS,\n\tCARL9170_ERP_RTS,\n\t__CARL9170_ERP_NUM,\n};\n\nstruct ar9170 {\n\tstruct ath_common common;\n\tstruct ieee80211_hw *hw;\n\tstruct mutex mutex;\n\tenum carl9170_device_state state;\n\tspinlock_t state_lock;\n\tenum carl9170_restart_reasons last_reason;\n\tbool registered;\n\n\t \n\tstruct usb_device *udev;\n\tstruct usb_interface *intf;\n\tstruct usb_anchor rx_anch;\n\tstruct usb_anchor rx_work;\n\tstruct usb_anchor rx_pool;\n\tstruct usb_anchor tx_wait;\n\tstruct usb_anchor tx_anch;\n\tstruct usb_anchor tx_cmd;\n\tstruct usb_anchor tx_err;\n\tstruct tasklet_struct usb_tasklet;\n\tatomic_t tx_cmd_urbs;\n\tatomic_t tx_anch_urbs;\n\tatomic_t rx_anch_urbs;\n\tatomic_t rx_work_urbs;\n\tatomic_t rx_pool_urbs;\n\tkernel_ulong_t features;\n\tbool usb_ep_cmd_is_bulk;\n\n\t \n\tstruct completion fw_load_wait;\n\tstruct completion fw_boot_wait;\n\tstruct {\n\t\tconst struct carl9170fw_desc_head *desc;\n\t\tconst struct firmware *fw;\n\t\tunsigned int offset;\n\t\tunsigned int address;\n\t\tunsigned int cmd_bufs;\n\t\tunsigned int api_version;\n\t\tunsigned int vif_num;\n\t\tunsigned int err_counter;\n\t\tunsigned int bug_counter;\n\t\tu32 beacon_addr;\n\t\tunsigned int beacon_max_len;\n\t\tbool rx_stream;\n\t\tbool tx_stream;\n\t\tbool rx_filter;\n\t\tbool hw_counters;\n\t\tunsigned int mem_blocks;\n\t\tunsigned int mem_block_size;\n\t\tunsigned int rx_size;\n\t\tunsigned int tx_seq_table;\n\t\tbool ba_filter;\n\t\tbool disable_offload_fw;\n\t} fw;\n\n\t \n\tstruct ieee80211_iface_limit if_comb_limits[1];\n\tstruct ieee80211_iface_combination if_combs[1];\n\n\t \n\tstruct work_struct restart_work;\n\tstruct work_struct ping_work;\n\tunsigned int restart_counter;\n\tunsigned long queue_stop_timeout[__AR9170_NUM_TXQ];\n\tunsigned long max_queue_stop_timeout[__AR9170_NUM_TXQ];\n\tbool needs_full_reset;\n\tbool force_usb_reset;\n\tatomic_t pending_restarts;\n\n\t \n\tstruct list_head vif_list;\n\tunsigned long vif_bitmap;\n\tunsigned int vifs;\n\tstruct carl9170_vif vif_priv[AR9170_MAX_VIRTUAL_MAC];\n\n\t \n\tspinlock_t beacon_lock;\n\tunsigned int global_pretbtt;\n\tunsigned int global_beacon_int;\n\tstruct carl9170_vif_info __rcu *beacon_iter;\n\tunsigned int beacon_enabled;\n\n\t \n\tu64 usedkeys;\n\tbool rx_software_decryption;\n\tbool disable_offload;\n\n\t \n\tu64 cur_mc_hash;\n\tu32 cur_filter;\n\tunsigned int filter_state;\n\tunsigned int rx_filter_caps;\n\tbool sniffer_enabled;\n\n\t \n\tenum carl9170_erp_modes erp_mode;\n\n\t \n\tstruct ieee80211_channel *channel;\n\tunsigned int num_channels;\n\tint noise[4];\n\tunsigned int chan_fail;\n\tunsigned int total_chan_fail;\n\tu8 heavy_clip;\n\tu8 ht_settings;\n\tstruct {\n\t\tu64 active;\t \n\t\tu64 cca;\t \n\t\tu64 tx_time;\t \n\t\tu64 rx_total;\n\t\tu64 rx_overrun;\n\t} tally;\n\tstruct delayed_work stat_work;\n\tstruct survey_info *survey;\n\n\t \n\tu8 power_5G_leg[4];\n\tu8 power_2G_cck[4];\n\tu8 power_2G_ofdm[4];\n\tu8 power_5G_ht20[8];\n\tu8 power_5G_ht40[8];\n\tu8 power_2G_ht20[8];\n\tu8 power_2G_ht40[8];\n\n#ifdef CONFIG_CARL9170_LEDS\n\t \n\tstruct delayed_work led_work;\n\tstruct carl9170_led leds[AR9170_NUM_LEDS];\n#endif  \n\n\t \n\tspinlock_t tx_stats_lock;\n\tstruct carl9170_tx_queue_stats tx_stats[__AR9170_NUM_TXQ];\n\tstruct ieee80211_tx_queue_params edcf[5];\n\tstruct completion tx_flush;\n\n\t \n\tint cmd_seq;\n\tint readlen;\n\tu8 *readbuf;\n\tspinlock_t cmd_lock;\n\tstruct completion cmd_wait;\n\tunion {\n\t\t__le32 cmd_buf[PAYLOAD_MAX + 1];\n\t\tstruct carl9170_cmd cmd;\n\t\tstruct carl9170_rsp rsp;\n\t};\n\n\t \n\tunsigned int tx_dropped;\n\tunsigned int tx_ack_failures;\n\tunsigned int tx_fcs_errors;\n\tunsigned int rx_dropped;\n\n\t \n\tstruct ar9170_eeprom eeprom;\n\n\t \n\tstruct sk_buff_head tx_pending[__AR9170_NUM_TXQ];\n\tstruct sk_buff_head tx_status[__AR9170_NUM_TXQ];\n\tstruct delayed_work tx_janitor;\n\tunsigned long tx_janitor_last_run;\n\tbool tx_schedule;\n\n\t \n\tstruct work_struct ampdu_work;\n\tspinlock_t tx_ampdu_list_lock;\n\tstruct carl9170_sta_tid __rcu *tx_ampdu_iter;\n\tstruct list_head tx_ampdu_list;\n\tatomic_t tx_ampdu_upload;\n\tatomic_t tx_ampdu_scheduler;\n\tatomic_t tx_total_pending;\n\tatomic_t tx_total_queued;\n\tunsigned int tx_ampdu_list_len;\n\tint current_density;\n\tint current_factor;\n\tbool tx_ampdu_schedule;\n\n\t \n\tspinlock_t mem_lock;\n\tunsigned long *mem_bitmap;\n\tatomic_t mem_free_blocks;\n\tatomic_t mem_allocs;\n\n\t \n\tstruct ar9170_rx_head rx_plcp;\n\tbool rx_has_plcp;\n\tstruct sk_buff *rx_failover;\n\tint rx_failover_missing;\n\tu32 ampdu_ref;\n\n\t \n\tstruct list_head bar_list[__AR9170_NUM_TXQ];\n\tspinlock_t bar_list_lock[__AR9170_NUM_TXQ];\n\n#ifdef CONFIG_CARL9170_WPC\n\tstruct {\n\t\tbool pbc_state;\n\t\tstruct input_dev *pbc;\n\t\tchar name[32];\n\t\tchar phys[32];\n\t} wps;\n#endif  \n\n#ifdef CONFIG_CARL9170_DEBUGFS\n\tstruct carl9170_debug debug;\n\tstruct dentry *debug_dir;\n#endif  \n\n\t \n\tstruct work_struct ps_work;\n\tstruct {\n\t\tunsigned int dtim_counter;\n\t\tunsigned long last_beacon;\n\t\tunsigned long last_action;\n\t\tunsigned long last_slept;\n\t\tunsigned int sleep_ms;\n\t\tunsigned int off_override;\n\t\tbool state;\n\t} ps;\n\n#ifdef CONFIG_CARL9170_HWRNG\n# define CARL9170_HWRNG_CACHE_SIZE\tCARL9170_MAX_CMD_PAYLOAD_LEN\n\tstruct {\n\t\tstruct hwrng rng;\n\t\tchar name[30 + 1];\n\t\tu16 cache[CARL9170_HWRNG_CACHE_SIZE / sizeof(u16)];\n\t\tunsigned int cache_idx;\n\t} rng;\n#endif  \n};\n\nenum carl9170_ps_off_override_reasons {\n\tPS_OFF_VIF\t= BIT(0),\n\tPS_OFF_BCN\t= BIT(1),\n};\n\nstruct carl9170_bar_list_entry {\n\tstruct list_head list;\n\tstruct rcu_head head;\n\tstruct sk_buff *skb;\n};\n\nstruct carl9170_ba_stats {\n\tu8 ampdu_len;\n\tu8 ampdu_ack_len;\n\tbool clear;\n\tbool req;\n};\n\nstruct carl9170_sta_info {\n\tbool ht_sta;\n\tbool sleeping;\n\tatomic_t pending_frames;\n\tunsigned int ampdu_max_len;\n\tstruct carl9170_sta_tid __rcu *agg[IEEE80211_NUM_TIDS];\n\tstruct carl9170_ba_stats stats[IEEE80211_NUM_TIDS];\n};\n\nstruct carl9170_tx_info {\n\tunsigned long timeout;\n\tstruct ar9170 *ar;\n\tstruct kref ref;\n};\n\n#define CHK_DEV_STATE(a, s)\t(((struct ar9170 *)a)->state >= (s))\n#define IS_INITIALIZED(a)\t(CHK_DEV_STATE(a, CARL9170_STOPPED))\n#define IS_ACCEPTING_CMD(a)\t(CHK_DEV_STATE(a, CARL9170_IDLE))\n#define IS_STARTED(a)\t\t(CHK_DEV_STATE(a, CARL9170_STARTED))\n\nstatic inline void __carl9170_set_state(struct ar9170 *ar,\n\tenum carl9170_device_state newstate)\n{\n\tar->state = newstate;\n}\n\nstatic inline void carl9170_set_state(struct ar9170 *ar,\n\tenum carl9170_device_state newstate)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ar->state_lock, flags);\n\t__carl9170_set_state(ar, newstate);\n\tspin_unlock_irqrestore(&ar->state_lock, flags);\n}\n\nstatic inline void carl9170_set_state_when(struct ar9170 *ar,\n\tenum carl9170_device_state min, enum carl9170_device_state newstate)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ar->state_lock, flags);\n\tif (CHK_DEV_STATE(ar, min))\n\t\t__carl9170_set_state(ar, newstate);\n\tspin_unlock_irqrestore(&ar->state_lock, flags);\n}\n\n \nvoid *carl9170_alloc(size_t priv_size);\nint carl9170_register(struct ar9170 *ar);\nvoid carl9170_unregister(struct ar9170 *ar);\nvoid carl9170_free(struct ar9170 *ar);\nvoid carl9170_restart(struct ar9170 *ar, const enum carl9170_restart_reasons r);\nvoid carl9170_ps_check(struct ar9170 *ar);\n\n \nint carl9170_usb_open(struct ar9170 *ar);\nvoid carl9170_usb_stop(struct ar9170 *ar);\nvoid carl9170_usb_tx(struct ar9170 *ar, struct sk_buff *skb);\nvoid carl9170_usb_handle_tx_err(struct ar9170 *ar);\nint carl9170_exec_cmd(struct ar9170 *ar, const enum carl9170_cmd_oids,\n\t\t      u32 plen, void *payload, u32 rlen, void *resp);\nint __carl9170_exec_cmd(struct ar9170 *ar, struct carl9170_cmd *cmd,\n\t\t\tconst bool free_buf);\nint carl9170_usb_restart(struct ar9170 *ar);\nvoid carl9170_usb_reset(struct ar9170 *ar);\n\n \nint carl9170_init_mac(struct ar9170 *ar);\nint carl9170_set_qos(struct ar9170 *ar);\nint carl9170_update_multicast(struct ar9170 *ar, const u64 mc_hast);\nint carl9170_mod_virtual_mac(struct ar9170 *ar, const unsigned int id,\n\t\t\t     const u8 *mac);\nint carl9170_set_operating_mode(struct ar9170 *ar);\nint carl9170_set_beacon_timers(struct ar9170 *ar);\nint carl9170_set_dyn_sifs_ack(struct ar9170 *ar);\nint carl9170_set_rts_cts_rate(struct ar9170 *ar);\nint carl9170_set_ampdu_settings(struct ar9170 *ar);\nint carl9170_set_slot_time(struct ar9170 *ar);\nint carl9170_set_mac_rates(struct ar9170 *ar);\nint carl9170_set_hwretry_limit(struct ar9170 *ar, const u32 max_retry);\nint carl9170_upload_key(struct ar9170 *ar, const u8 id, const u8 *mac,\n\tconst u8 ktype, const u8 keyidx, const u8 *keydata, const int keylen);\nint carl9170_disable_key(struct ar9170 *ar, const u8 id);\nint carl9170_set_mac_tpc(struct ar9170 *ar, struct ieee80211_channel *channel);\n\n \nvoid carl9170_rx(struct ar9170 *ar, void *buf, unsigned int len);\nvoid carl9170_handle_command_response(struct ar9170 *ar, void *buf, u32 len);\n\n \nvoid carl9170_op_tx(struct ieee80211_hw *hw,\n\t\t    struct ieee80211_tx_control *control,\n\t\t    struct sk_buff *skb);\nvoid carl9170_tx_janitor(struct work_struct *work);\nvoid carl9170_tx_process_status(struct ar9170 *ar,\n\t\t\t\tconst struct carl9170_rsp *cmd);\nvoid carl9170_tx_status(struct ar9170 *ar, struct sk_buff *skb,\n\t\t\tconst bool success);\nvoid carl9170_tx_callback(struct ar9170 *ar, struct sk_buff *skb);\nvoid carl9170_tx_drop(struct ar9170 *ar, struct sk_buff *skb);\nvoid carl9170_tx_scheduler(struct ar9170 *ar);\nvoid carl9170_tx_get_skb(struct sk_buff *skb);\nint carl9170_tx_put_skb(struct sk_buff *skb);\nint carl9170_update_beacon(struct ar9170 *ar, const bool submit);\n\n \n#ifdef CONFIG_CARL9170_LEDS\nint carl9170_led_register(struct ar9170 *ar);\nvoid carl9170_led_unregister(struct ar9170 *ar);\n#endif  \nint carl9170_led_init(struct ar9170 *ar);\nint carl9170_led_set_state(struct ar9170 *ar, const u32 led_state);\n\n \nint carl9170_set_channel(struct ar9170 *ar, struct ieee80211_channel *channel,\n\t\t\t enum nl80211_channel_type bw);\nint carl9170_get_noisefloor(struct ar9170 *ar);\n\n \nint carl9170_parse_firmware(struct ar9170 *ar);\n\nextern struct ieee80211_rate __carl9170_ratetable[];\nextern int modparam_noht;\n\nstatic inline struct ar9170 *carl9170_get_priv(struct carl9170_vif *carl_vif)\n{\n\treturn container_of(carl_vif, struct ar9170,\n\t\t\t    vif_priv[carl_vif->id]);\n}\n\nstatic inline struct ieee80211_hdr *carl9170_get_hdr(struct sk_buff *skb)\n{\n\treturn (void *)((struct _carl9170_tx_superframe *)\n\t\tskb->data)->frame_data;\n}\n\nstatic inline u16 get_seq_h(struct ieee80211_hdr *hdr)\n{\n\treturn le16_to_cpu(hdr->seq_ctrl) >> 4;\n}\n\nstatic inline u16 carl9170_get_seq(struct sk_buff *skb)\n{\n\treturn get_seq_h(carl9170_get_hdr(skb));\n}\n\nstatic inline u16 carl9170_get_tid(struct sk_buff *skb)\n{\n\treturn ieee80211_get_tid(carl9170_get_hdr(skb));\n}\n\nstatic inline struct ieee80211_vif *\ncarl9170_get_vif(struct carl9170_vif_info *priv)\n{\n\treturn container_of((void *)priv, struct ieee80211_vif, drv_priv);\n}\n\n \nstatic inline struct ieee80211_vif *carl9170_get_main_vif(struct ar9170 *ar)\n{\n\tstruct carl9170_vif_info *cvif;\n\n\tlist_for_each_entry_rcu(cvif, &ar->vif_list, list) {\n\t\tif (cvif->active)\n\t\t\treturn carl9170_get_vif(cvif);\n\t}\n\n\treturn NULL;\n}\n\nstatic inline bool is_main_vif(struct ar9170 *ar, struct ieee80211_vif *vif)\n{\n\tbool ret;\n\n\trcu_read_lock();\n\tret = (carl9170_get_main_vif(ar) == vif);\n\trcu_read_unlock();\n\treturn ret;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}