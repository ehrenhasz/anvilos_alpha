{
  "module_name": "usb.c",
  "hash_id": "484311d05eb38e8b58cac6f0b40215d294da9d043501278275c53bc950624dbb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/carl9170/usb.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n#include <linux/firmware.h>\n#include <linux/etherdevice.h>\n#include <linux/device.h>\n#include <net/mac80211.h>\n#include \"carl9170.h\"\n#include \"cmd.h\"\n#include \"hw.h\"\n#include \"fwcmd.h\"\n\nMODULE_AUTHOR(\"Johannes Berg <johannes@sipsolutions.net>\");\nMODULE_AUTHOR(\"Christian Lamparter <chunkeey@googlemail.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Atheros AR9170 802.11n USB wireless\");\nMODULE_FIRMWARE(CARL9170FW_NAME);\nMODULE_ALIAS(\"ar9170usb\");\nMODULE_ALIAS(\"arusb_lnx\");\n\n \nstatic const struct usb_device_id carl9170_usb_ids[] = {\n\t \n\t{ USB_DEVICE(0x0cf3, 0x9170) },\n\t \n\t{ USB_DEVICE(0x0cf3, 0x1001) },\n\t \n\t{ USB_DEVICE(0x0cf3, 0x1002), .driver_info = CARL9170_WPS_BUTTON |\n\t\t CARL9170_ONE_LED },\n\t \n\t{ USB_DEVICE(0x0cf3, 0x1010) },\n\t \n\t{ USB_DEVICE(0x0cf3, 0x1011) },\n\t \n\t{ USB_DEVICE(0xcace, 0x0300) },\n\t \n\t{ USB_DEVICE(0x07d1, 0x3c10) },\n\t \n\t{ USB_DEVICE(0x07d1, 0x3a09) },\n\t \n\t{ USB_DEVICE(0x07d1, 0x3a0f) },\n\t \n\t{ USB_DEVICE(0x0846, 0x9040) },\n\t \n\t{ USB_DEVICE(0x0846, 0x9010) },\n\t \n\t{ USB_DEVICE(0x0846, 0x9001), .driver_info = CARL9170_ONE_LED },\n\t \n\t{ USB_DEVICE(0x0ace, 0x1221) },\n\t \n\t{ USB_DEVICE(0x1435, 0x0804) },\n\t \n\t{ USB_DEVICE(0x1435, 0x0326) },\n\t \n\t{ USB_DEVICE(0x0586, 0x3417) },\n\t \n\t{ USB_DEVICE(0x0cde, 0x0023) },\n\t \n\t{ USB_DEVICE(0x0cde, 0x0026) },\n\t \n\t{ USB_DEVICE(0x0cde, 0x0027) },\n\t \n\t{ USB_DEVICE(0x083a, 0xf522) },\n\t \n\t{ USB_DEVICE(0x2019, 0x5304) },\n\t \n\t{ USB_DEVICE(0x04bb, 0x093f) },\n\t \n\t{ USB_DEVICE(0x0409, 0x0249) },\n\t \n\t{ USB_DEVICE(0x0409, 0x02b4) },\n\t \n\t{ USB_DEVICE(0x057c, 0x8401) },\n\t \n\t{ USB_DEVICE(0x057c, 0x8402) },\n\t \n\t{ USB_DEVICE(0x1668, 0x1200) },\n\t \n\t{ USB_DEVICE(0x1b75, 0x9170) },\n\n\t \n\t{}\n};\nMODULE_DEVICE_TABLE(usb, carl9170_usb_ids);\n\nstatic struct usb_driver carl9170_driver;\n\nstatic void carl9170_usb_submit_data_urb(struct ar9170 *ar)\n{\n\tstruct urb *urb;\n\tint err;\n\n\tif (atomic_inc_return(&ar->tx_anch_urbs) > AR9170_NUM_TX_URBS)\n\t\tgoto err_acc;\n\n\turb = usb_get_from_anchor(&ar->tx_wait);\n\tif (!urb)\n\t\tgoto err_acc;\n\n\tusb_anchor_urb(urb, &ar->tx_anch);\n\n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (unlikely(err)) {\n\t\tif (net_ratelimit()) {\n\t\t\tdev_err(&ar->udev->dev, \"tx submit failed (%d)\\n\",\n\t\t\t\turb->status);\n\t\t}\n\n\t\tusb_unanchor_urb(urb);\n\t\tusb_anchor_urb(urb, &ar->tx_err);\n\t}\n\n\tusb_free_urb(urb);\n\n\tif (likely(err == 0))\n\t\treturn;\n\nerr_acc:\n\tatomic_dec(&ar->tx_anch_urbs);\n}\n\nstatic void carl9170_usb_tx_data_complete(struct urb *urb)\n{\n\tstruct ar9170 *ar = usb_get_intfdata(usb_ifnum_to_if(urb->dev, 0));\n\n\tif (WARN_ON_ONCE(!ar)) {\n\t\tdev_kfree_skb_irq(urb->context);\n\t\treturn;\n\t}\n\n\tatomic_dec(&ar->tx_anch_urbs);\n\n\tswitch (urb->status) {\n\t \n\tcase 0:\n\t\tcarl9170_tx_callback(ar, (void *)urb->context);\n\t\tbreak;\n\n\t \n\tcase -ENOENT:\n\tcase -ECONNRESET:\n\tcase -ENODEV:\n\tcase -ESHUTDOWN:\n\t\t \n\t\tusb_anchor_urb(urb, &ar->tx_err);\n\t\treturn;\n\n\t \n\tdefault:\n\t\tif (net_ratelimit()) {\n\t\t\tdev_err(&ar->udev->dev, \"tx failed (%d)\\n\",\n\t\t\t\turb->status);\n\t\t}\n\n\t\tusb_anchor_urb(urb, &ar->tx_err);\n\t\tbreak;\n\t}\n\n\tif (likely(IS_STARTED(ar)))\n\t\tcarl9170_usb_submit_data_urb(ar);\n}\n\nstatic int carl9170_usb_submit_cmd_urb(struct ar9170 *ar)\n{\n\tstruct urb *urb;\n\tint err;\n\n\tif (atomic_inc_return(&ar->tx_cmd_urbs) != 1) {\n\t\tatomic_dec(&ar->tx_cmd_urbs);\n\t\treturn 0;\n\t}\n\n\turb = usb_get_from_anchor(&ar->tx_cmd);\n\tif (!urb) {\n\t\tatomic_dec(&ar->tx_cmd_urbs);\n\t\treturn 0;\n\t}\n\n\tusb_anchor_urb(urb, &ar->tx_anch);\n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (unlikely(err)) {\n\t\tusb_unanchor_urb(urb);\n\t\tatomic_dec(&ar->tx_cmd_urbs);\n\t}\n\tusb_free_urb(urb);\n\n\treturn err;\n}\n\nstatic void carl9170_usb_cmd_complete(struct urb *urb)\n{\n\tstruct ar9170 *ar = urb->context;\n\tint err = 0;\n\n\tif (WARN_ON_ONCE(!ar))\n\t\treturn;\n\n\tatomic_dec(&ar->tx_cmd_urbs);\n\n\tswitch (urb->status) {\n\t \n\tcase 0:\n\t\tbreak;\n\n\t \n\tcase -ENOENT:\n\tcase -ECONNRESET:\n\tcase -ENODEV:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\n\tdefault:\n\t\terr = urb->status;\n\t\tbreak;\n\t}\n\n\tif (!IS_INITIALIZED(ar))\n\t\treturn;\n\n\tif (err)\n\t\tdev_err(&ar->udev->dev, \"submit cmd cb failed (%d).\\n\", err);\n\n\terr = carl9170_usb_submit_cmd_urb(ar);\n\tif (err)\n\t\tdev_err(&ar->udev->dev, \"submit cmd failed (%d).\\n\", err);\n}\n\nstatic void carl9170_usb_rx_irq_complete(struct urb *urb)\n{\n\tstruct ar9170 *ar = urb->context;\n\n\tif (WARN_ON_ONCE(!ar))\n\t\treturn;\n\n\tswitch (urb->status) {\n\t \n\tcase 0:\n\t\tbreak;\n\n\t \n\tcase -ENOENT:\n\tcase -ECONNRESET:\n\tcase -ENODEV:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\n\tdefault:\n\t\tgoto resubmit;\n\t}\n\n\t \n\tcarl9170_handle_command_response(ar, urb->transfer_buffer,\n\t\t\t\t\t urb->actual_length);\n\nresubmit:\n\tusb_anchor_urb(urb, &ar->rx_anch);\n\tif (unlikely(usb_submit_urb(urb, GFP_ATOMIC)))\n\t\tusb_unanchor_urb(urb);\n}\n\nstatic int carl9170_usb_submit_rx_urb(struct ar9170 *ar, gfp_t gfp)\n{\n\tstruct urb *urb;\n\tint err = 0, runs = 0;\n\n\twhile ((atomic_read(&ar->rx_anch_urbs) < AR9170_NUM_RX_URBS) &&\n\t\t(runs++ < AR9170_NUM_RX_URBS)) {\n\t\terr = -ENOSPC;\n\t\turb = usb_get_from_anchor(&ar->rx_pool);\n\t\tif (urb) {\n\t\t\tusb_anchor_urb(urb, &ar->rx_anch);\n\t\t\terr = usb_submit_urb(urb, gfp);\n\t\t\tif (unlikely(err)) {\n\t\t\t\tusb_unanchor_urb(urb);\n\t\t\t\tusb_anchor_urb(urb, &ar->rx_pool);\n\t\t\t} else {\n\t\t\t\tatomic_dec(&ar->rx_pool_urbs);\n\t\t\t\tatomic_inc(&ar->rx_anch_urbs);\n\t\t\t}\n\t\t\tusb_free_urb(urb);\n\t\t}\n\t}\n\n\treturn err;\n}\n\nstatic void carl9170_usb_rx_work(struct ar9170 *ar)\n{\n\tstruct urb *urb;\n\tint i;\n\n\tfor (i = 0; i < AR9170_NUM_RX_URBS_POOL; i++) {\n\t\turb = usb_get_from_anchor(&ar->rx_work);\n\t\tif (!urb)\n\t\t\tbreak;\n\n\t\tatomic_dec(&ar->rx_work_urbs);\n\t\tif (IS_INITIALIZED(ar)) {\n\t\t\tcarl9170_rx(ar, urb->transfer_buffer,\n\t\t\t\t    urb->actual_length);\n\t\t}\n\n\t\tusb_anchor_urb(urb, &ar->rx_pool);\n\t\tatomic_inc(&ar->rx_pool_urbs);\n\n\t\tusb_free_urb(urb);\n\n\t\tcarl9170_usb_submit_rx_urb(ar, GFP_ATOMIC);\n\t}\n}\n\nvoid carl9170_usb_handle_tx_err(struct ar9170 *ar)\n{\n\tstruct urb *urb;\n\n\twhile ((urb = usb_get_from_anchor(&ar->tx_err))) {\n\t\tstruct sk_buff *skb = (void *)urb->context;\n\n\t\tcarl9170_tx_drop(ar, skb);\n\t\tcarl9170_tx_callback(ar, skb);\n\t\tusb_free_urb(urb);\n\t}\n}\n\nstatic void carl9170_usb_tasklet(struct tasklet_struct *t)\n{\n\tstruct ar9170 *ar = from_tasklet(ar, t, usb_tasklet);\n\n\tif (!IS_INITIALIZED(ar))\n\t\treturn;\n\n\tcarl9170_usb_rx_work(ar);\n\n\t \n\tif (IS_STARTED(ar))\n\t\tcarl9170_tx_scheduler(ar);\n}\n\nstatic void carl9170_usb_rx_complete(struct urb *urb)\n{\n\tstruct ar9170 *ar = (struct ar9170 *)urb->context;\n\tint err;\n\n\tif (WARN_ON_ONCE(!ar))\n\t\treturn;\n\n\tatomic_dec(&ar->rx_anch_urbs);\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\t \n\t\tusb_anchor_urb(urb, &ar->rx_work);\n\t\tatomic_inc(&ar->rx_work_urbs);\n\t\tbreak;\n\n\tcase -ENOENT:\n\tcase -ECONNRESET:\n\tcase -ENODEV:\n\tcase -ESHUTDOWN:\n\t\t \n\t\treturn;\n\n\tdefault:\n\t\t \n\t\tusb_anchor_urb(urb, &ar->rx_pool);\n\t\tatomic_inc(&ar->rx_pool_urbs);\n\t\tbreak;\n\t}\n\n\terr = carl9170_usb_submit_rx_urb(ar, GFP_ATOMIC);\n\tif (unlikely(err)) {\n\t\t \n\t\ttasklet_hi_schedule(&ar->usb_tasklet);\n\n\t\tif (atomic_read(&ar->rx_anch_urbs) == 0) {\n\t\t\t \n\n\t\t\tieee80211_queue_work(ar->hw, &ar->ping_work);\n\t\t}\n\t} else {\n\t\t \n\t\ttasklet_hi_schedule(&ar->usb_tasklet);\n\t}\n}\n\nstatic struct urb *carl9170_usb_alloc_rx_urb(struct ar9170 *ar, gfp_t gfp)\n{\n\tstruct urb *urb;\n\tvoid *buf;\n\n\tbuf = kmalloc(ar->fw.rx_size, gfp);\n\tif (!buf)\n\t\treturn NULL;\n\n\turb = usb_alloc_urb(0, gfp);\n\tif (!urb) {\n\t\tkfree(buf);\n\t\treturn NULL;\n\t}\n\n\tusb_fill_bulk_urb(urb, ar->udev, usb_rcvbulkpipe(ar->udev,\n\t\t\t  AR9170_USB_EP_RX), buf, ar->fw.rx_size,\n\t\t\t  carl9170_usb_rx_complete, ar);\n\n\turb->transfer_flags |= URB_FREE_BUFFER;\n\n\treturn urb;\n}\n\nstatic int carl9170_usb_send_rx_irq_urb(struct ar9170 *ar)\n{\n\tstruct urb *urb = NULL;\n\tvoid *ibuf;\n\tint err = -ENOMEM;\n\n\turb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!urb)\n\t\tgoto out;\n\n\tibuf = kmalloc(AR9170_USB_EP_CTRL_MAX, GFP_KERNEL);\n\tif (!ibuf)\n\t\tgoto out;\n\n\tusb_fill_int_urb(urb, ar->udev, usb_rcvintpipe(ar->udev,\n\t\t\t AR9170_USB_EP_IRQ), ibuf, AR9170_USB_EP_CTRL_MAX,\n\t\t\t carl9170_usb_rx_irq_complete, ar, 1);\n\n\turb->transfer_flags |= URB_FREE_BUFFER;\n\n\tusb_anchor_urb(urb, &ar->rx_anch);\n\terr = usb_submit_urb(urb, GFP_KERNEL);\n\tif (err)\n\t\tusb_unanchor_urb(urb);\n\nout:\n\tusb_free_urb(urb);\n\treturn err;\n}\n\nstatic int carl9170_usb_init_rx_bulk_urbs(struct ar9170 *ar)\n{\n\tstruct urb *urb;\n\tint i, err = -EINVAL;\n\n\t \n\tfor (i = 0; i < AR9170_NUM_RX_URBS_POOL; i++) {\n\t\turb = carl9170_usb_alloc_rx_urb(ar, GFP_KERNEL);\n\t\tif (!urb) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tusb_anchor_urb(urb, &ar->rx_pool);\n\t\tatomic_inc(&ar->rx_pool_urbs);\n\t\tusb_free_urb(urb);\n\t}\n\n\terr = carl9170_usb_submit_rx_urb(ar, GFP_KERNEL);\n\tif (err)\n\t\tgoto err_out;\n\n\t \n\tcarl9170_set_state_when(ar, CARL9170_STOPPED, CARL9170_IDLE);\n\treturn 0;\n\nerr_out:\n\n\tusb_scuttle_anchored_urbs(&ar->rx_pool);\n\tusb_scuttle_anchored_urbs(&ar->rx_work);\n\tusb_kill_anchored_urbs(&ar->rx_anch);\n\treturn err;\n}\n\nstatic int carl9170_usb_flush(struct ar9170 *ar)\n{\n\tstruct urb *urb;\n\tint ret, err = 0;\n\n\twhile ((urb = usb_get_from_anchor(&ar->tx_wait))) {\n\t\tstruct sk_buff *skb = (void *)urb->context;\n\t\tcarl9170_tx_drop(ar, skb);\n\t\tcarl9170_tx_callback(ar, skb);\n\t\tusb_free_urb(urb);\n\t}\n\n\tret = usb_wait_anchor_empty_timeout(&ar->tx_cmd, 1000);\n\tif (ret == 0)\n\t\terr = -ETIMEDOUT;\n\n\t \n\tret = usb_wait_anchor_empty_timeout(&ar->tx_anch, 1000);\n\tif (ret == 0)\n\t\terr = -ETIMEDOUT;\n\n\tusb_kill_anchored_urbs(&ar->tx_anch);\n\tcarl9170_usb_handle_tx_err(ar);\n\n\treturn err;\n}\n\nstatic void carl9170_usb_cancel_urbs(struct ar9170 *ar)\n{\n\tint err;\n\n\tcarl9170_set_state(ar, CARL9170_UNKNOWN_STATE);\n\n\terr = carl9170_usb_flush(ar);\n\tif (err)\n\t\tdev_err(&ar->udev->dev, \"stuck tx urbs!\\n\");\n\n\tusb_poison_anchored_urbs(&ar->tx_anch);\n\tcarl9170_usb_handle_tx_err(ar);\n\tusb_poison_anchored_urbs(&ar->rx_anch);\n\n\ttasklet_kill(&ar->usb_tasklet);\n\n\tusb_scuttle_anchored_urbs(&ar->rx_work);\n\tusb_scuttle_anchored_urbs(&ar->rx_pool);\n\tusb_scuttle_anchored_urbs(&ar->tx_cmd);\n}\n\nint __carl9170_exec_cmd(struct ar9170 *ar, struct carl9170_cmd *cmd,\n\t\t\tconst bool free_buf)\n{\n\tstruct urb *urb;\n\tint err = 0;\n\n\tif (!IS_INITIALIZED(ar)) {\n\t\terr = -EPERM;\n\t\tgoto err_free;\n\t}\n\n\tif (WARN_ON(cmd->hdr.len > CARL9170_MAX_CMD_LEN - 4)) {\n\t\terr = -EINVAL;\n\t\tgoto err_free;\n\t}\n\n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free;\n\t}\n\n\tif (ar->usb_ep_cmd_is_bulk)\n\t\tusb_fill_bulk_urb(urb, ar->udev,\n\t\t\t\t  usb_sndbulkpipe(ar->udev, AR9170_USB_EP_CMD),\n\t\t\t\t  cmd, cmd->hdr.len + 4,\n\t\t\t\t  carl9170_usb_cmd_complete, ar);\n\telse\n\t\tusb_fill_int_urb(urb, ar->udev,\n\t\t\t\t usb_sndintpipe(ar->udev, AR9170_USB_EP_CMD),\n\t\t\t\t cmd, cmd->hdr.len + 4,\n\t\t\t\t carl9170_usb_cmd_complete, ar, 1);\n\n\tif (free_buf)\n\t\turb->transfer_flags |= URB_FREE_BUFFER;\n\n\tusb_anchor_urb(urb, &ar->tx_cmd);\n\tusb_free_urb(urb);\n\n\treturn carl9170_usb_submit_cmd_urb(ar);\n\nerr_free:\n\tif (free_buf)\n\t\tkfree(cmd);\n\n\treturn err;\n}\n\nint carl9170_exec_cmd(struct ar9170 *ar, const enum carl9170_cmd_oids cmd,\n\tunsigned int plen, void *payload, unsigned int outlen, void *out)\n{\n\tint err = -ENOMEM;\n\tunsigned long time_left;\n\n\tif (!IS_ACCEPTING_CMD(ar))\n\t\treturn -EIO;\n\n\tif (!(cmd & CARL9170_CMD_ASYNC_FLAG))\n\t\tmight_sleep();\n\n\tar->cmd.hdr.len = plen;\n\tar->cmd.hdr.cmd = cmd;\n\t \n\tif (plen && payload != (u8 *)(ar->cmd.data))\n\t\tmemcpy(ar->cmd.data, payload, plen);\n\n\tspin_lock_bh(&ar->cmd_lock);\n\tar->readbuf = (u8 *)out;\n\tar->readlen = outlen;\n\tspin_unlock_bh(&ar->cmd_lock);\n\n\treinit_completion(&ar->cmd_wait);\n\terr = __carl9170_exec_cmd(ar, &ar->cmd, false);\n\n\tif (!(cmd & CARL9170_CMD_ASYNC_FLAG)) {\n\t\ttime_left = wait_for_completion_timeout(&ar->cmd_wait, HZ);\n\t\tif (time_left == 0) {\n\t\t\terr = -ETIMEDOUT;\n\t\t\tgoto err_unbuf;\n\t\t}\n\n\t\tif (ar->readlen != outlen) {\n\t\t\terr = -EMSGSIZE;\n\t\t\tgoto err_unbuf;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_unbuf:\n\t \n\tif (IS_STARTED(ar)) {\n\t\tdev_err(&ar->udev->dev, \"no command feedback \"\n\t\t\t\"received (%d).\\n\", err);\n\n\t\t \n\t\tprint_hex_dump_bytes(\"carl9170 cmd: \", DUMP_PREFIX_NONE,\n\t\t\t\t     &ar->cmd, plen + 4);\n\n\t\tcarl9170_restart(ar, CARL9170_RR_COMMAND_TIMEOUT);\n\t}\n\n\t \n\tspin_lock_bh(&ar->cmd_lock);\n\tar->readbuf = NULL;\n\tar->readlen = 0;\n\tspin_unlock_bh(&ar->cmd_lock);\n\n\treturn err;\n}\n\nvoid carl9170_usb_tx(struct ar9170 *ar, struct sk_buff *skb)\n{\n\tstruct urb *urb;\n\tstruct ar9170_stream *tx_stream;\n\tvoid *data;\n\tunsigned int len;\n\n\tif (!IS_STARTED(ar))\n\t\tgoto err_drop;\n\n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb)\n\t\tgoto err_drop;\n\n\tif (ar->fw.tx_stream) {\n\t\ttx_stream = (void *) (skb->data - sizeof(*tx_stream));\n\n\t\tlen = skb->len + sizeof(*tx_stream);\n\t\ttx_stream->length = cpu_to_le16(len);\n\t\ttx_stream->tag = cpu_to_le16(AR9170_TX_STREAM_TAG);\n\t\tdata = tx_stream;\n\t} else {\n\t\tdata = skb->data;\n\t\tlen = skb->len;\n\t}\n\n\tusb_fill_bulk_urb(urb, ar->udev, usb_sndbulkpipe(ar->udev,\n\t\tAR9170_USB_EP_TX), data, len,\n\t\tcarl9170_usb_tx_data_complete, skb);\n\n\turb->transfer_flags |= URB_ZERO_PACKET;\n\n\tusb_anchor_urb(urb, &ar->tx_wait);\n\n\tusb_free_urb(urb);\n\n\tcarl9170_usb_submit_data_urb(ar);\n\treturn;\n\nerr_drop:\n\tcarl9170_tx_drop(ar, skb);\n\tcarl9170_tx_callback(ar, skb);\n}\n\nstatic void carl9170_release_firmware(struct ar9170 *ar)\n{\n\tif (ar->fw.fw) {\n\t\trelease_firmware(ar->fw.fw);\n\t\tmemset(&ar->fw, 0, sizeof(ar->fw));\n\t}\n}\n\nvoid carl9170_usb_stop(struct ar9170 *ar)\n{\n\tint ret;\n\n\tcarl9170_set_state_when(ar, CARL9170_IDLE, CARL9170_STOPPED);\n\n\tret = carl9170_usb_flush(ar);\n\tif (ret)\n\t\tdev_err(&ar->udev->dev, \"kill pending tx urbs.\\n\");\n\n\tusb_poison_anchored_urbs(&ar->tx_anch);\n\tcarl9170_usb_handle_tx_err(ar);\n\n\t \n\tspin_lock_bh(&ar->cmd_lock);\n\tar->readlen = 0;\n\tspin_unlock_bh(&ar->cmd_lock);\n\tcomplete(&ar->cmd_wait);\n\n\t \n}\n\nint carl9170_usb_open(struct ar9170 *ar)\n{\n\tusb_unpoison_anchored_urbs(&ar->tx_anch);\n\n\tcarl9170_set_state_when(ar, CARL9170_STOPPED, CARL9170_IDLE);\n\treturn 0;\n}\n\nstatic int carl9170_usb_load_firmware(struct ar9170 *ar)\n{\n\tconst u8 *data;\n\tu8 *buf;\n\tunsigned int transfer;\n\tsize_t len;\n\tu32 addr;\n\tint err = 0;\n\n\tbuf = kmalloc(4096, GFP_KERNEL);\n\tif (!buf) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\tdata = ar->fw.fw->data;\n\tlen = ar->fw.fw->size;\n\taddr = ar->fw.address;\n\n\t \n\tdata += ar->fw.offset;\n\tlen -= ar->fw.offset;\n\n\twhile (len) {\n\t\ttransfer = min_t(unsigned int, len, 4096u);\n\t\tmemcpy(buf, data, transfer);\n\n\t\terr = usb_control_msg(ar->udev, usb_sndctrlpipe(ar->udev, 0),\n\t\t\t\t      0x30  , 0x40 | USB_DIR_OUT,\n\t\t\t\t      addr >> 8, 0, buf, transfer, 100);\n\n\t\tif (err < 0) {\n\t\t\tkfree(buf);\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tlen -= transfer;\n\t\tdata += transfer;\n\t\taddr += transfer;\n\t}\n\tkfree(buf);\n\n\terr = usb_control_msg(ar->udev, usb_sndctrlpipe(ar->udev, 0),\n\t\t\t      0x31  ,\n\t\t\t      0x40 | USB_DIR_OUT, 0, 0, NULL, 0, 200);\n\n\tif (wait_for_completion_timeout(&ar->fw_boot_wait, HZ) == 0) {\n\t\terr = -ETIMEDOUT;\n\t\tgoto err_out;\n\t}\n\n\terr = carl9170_echo_test(ar, 0x4a110123);\n\tif (err)\n\t\tgoto err_out;\n\n\t \n\tar->cmd_seq = -1;\n\n\treturn 0;\n\nerr_out:\n\tdev_err(&ar->udev->dev, \"firmware upload failed (%d).\\n\", err);\n\treturn err;\n}\n\nint carl9170_usb_restart(struct ar9170 *ar)\n{\n\tint err = 0;\n\n\tif (ar->intf->condition != USB_INTERFACE_BOUND)\n\t\treturn 0;\n\n\t \n\tar->cmd_seq = -2;\n\n\terr = carl9170_reboot(ar);\n\n\tcarl9170_usb_stop(ar);\n\n\tif (err)\n\t\tgoto err_out;\n\n\ttasklet_schedule(&ar->usb_tasklet);\n\n\t \n\tmsleep(1100);\n\n\terr = carl9170_usb_open(ar);\n\tif (err)\n\t\tgoto err_out;\n\n\terr = carl9170_usb_load_firmware(ar);\n\tif (err)\n\t\tgoto err_out;\n\n\treturn 0;\n\nerr_out:\n\tcarl9170_usb_cancel_urbs(ar);\n\treturn err;\n}\n\nvoid carl9170_usb_reset(struct ar9170 *ar)\n{\n\t \n\tcarl9170_usb_cancel_urbs(ar);\n\n\tcarl9170_usb_stop(ar);\n\n\tusb_queue_reset_device(ar->intf);\n}\n\nstatic int carl9170_usb_init_device(struct ar9170 *ar)\n{\n\tint err;\n\n\t \n\tar->cmd_seq = -2;\n\n\terr = carl9170_usb_send_rx_irq_urb(ar);\n\tif (err)\n\t\tgoto err_out;\n\n\terr = carl9170_usb_init_rx_bulk_urbs(ar);\n\tif (err)\n\t\tgoto err_unrx;\n\n\terr = carl9170_usb_open(ar);\n\tif (err)\n\t\tgoto err_unrx;\n\n\tmutex_lock(&ar->mutex);\n\terr = carl9170_usb_load_firmware(ar);\n\tmutex_unlock(&ar->mutex);\n\tif (err)\n\t\tgoto err_stop;\n\n\treturn 0;\n\nerr_stop:\n\tcarl9170_usb_stop(ar);\n\nerr_unrx:\n\tcarl9170_usb_cancel_urbs(ar);\n\nerr_out:\n\treturn err;\n}\n\nstatic void carl9170_usb_firmware_failed(struct ar9170 *ar)\n{\n\t \n\tstruct usb_interface *intf = ar->intf;\n\tstruct usb_device *udev = ar->udev;\n\n\tcomplete(&ar->fw_load_wait);\n\t \n\tar = NULL;\n\n\t \n\tusb_lock_device(udev);\n\tusb_driver_release_interface(&carl9170_driver, intf);\n\tusb_unlock_device(udev);\n\n\tusb_put_intf(intf);\n}\n\nstatic void carl9170_usb_firmware_finish(struct ar9170 *ar)\n{\n\tstruct usb_interface *intf = ar->intf;\n\tint err;\n\n\terr = carl9170_parse_firmware(ar);\n\tif (err)\n\t\tgoto err_freefw;\n\n\terr = carl9170_usb_init_device(ar);\n\tif (err)\n\t\tgoto err_freefw;\n\n\terr = carl9170_register(ar);\n\n\tcarl9170_usb_stop(ar);\n\tif (err)\n\t\tgoto err_unrx;\n\n\tcomplete(&ar->fw_load_wait);\n\tusb_put_intf(intf);\n\treturn;\n\nerr_unrx:\n\tcarl9170_usb_cancel_urbs(ar);\n\nerr_freefw:\n\tcarl9170_release_firmware(ar);\n\tcarl9170_usb_firmware_failed(ar);\n}\n\nstatic void carl9170_usb_firmware_step2(const struct firmware *fw,\n\t\t\t\t\tvoid *context)\n{\n\tstruct ar9170 *ar = context;\n\n\tif (fw) {\n\t\tar->fw.fw = fw;\n\t\tcarl9170_usb_firmware_finish(ar);\n\t\treturn;\n\t}\n\n\tdev_err(&ar->udev->dev, \"firmware not found.\\n\");\n\tcarl9170_usb_firmware_failed(ar);\n}\n\nstatic int carl9170_usb_probe(struct usb_interface *intf,\n\t\t\t      const struct usb_device_id *id)\n{\n\tstruct usb_endpoint_descriptor *ep;\n\tstruct ar9170 *ar;\n\tstruct usb_device *udev;\n\tint i, err;\n\n\terr = usb_reset_device(interface_to_usbdev(intf));\n\tif (err)\n\t\treturn err;\n\n\tar = carl9170_alloc(sizeof(*ar));\n\tif (IS_ERR(ar))\n\t\treturn PTR_ERR(ar);\n\n\tudev = interface_to_usbdev(intf);\n\tar->udev = udev;\n\tar->intf = intf;\n\tar->features = id->driver_info;\n\n\t \n\tfor (i = 0; i < intf->cur_altsetting->desc.bNumEndpoints; ++i) {\n\t\tep = &intf->cur_altsetting->endpoint[i].desc;\n\n\t\tif (usb_endpoint_num(ep) == AR9170_USB_EP_CMD &&\n\t\t    usb_endpoint_dir_out(ep) &&\n\t\t    usb_endpoint_type(ep) == USB_ENDPOINT_XFER_BULK)\n\t\t\tar->usb_ep_cmd_is_bulk = true;\n\t}\n\n\tusb_set_intfdata(intf, ar);\n\tSET_IEEE80211_DEV(ar->hw, &intf->dev);\n\n\tinit_usb_anchor(&ar->rx_anch);\n\tinit_usb_anchor(&ar->rx_pool);\n\tinit_usb_anchor(&ar->rx_work);\n\tinit_usb_anchor(&ar->tx_wait);\n\tinit_usb_anchor(&ar->tx_anch);\n\tinit_usb_anchor(&ar->tx_cmd);\n\tinit_usb_anchor(&ar->tx_err);\n\tinit_completion(&ar->cmd_wait);\n\tinit_completion(&ar->fw_boot_wait);\n\tinit_completion(&ar->fw_load_wait);\n\ttasklet_setup(&ar->usb_tasklet, carl9170_usb_tasklet);\n\n\tatomic_set(&ar->tx_cmd_urbs, 0);\n\tatomic_set(&ar->tx_anch_urbs, 0);\n\tatomic_set(&ar->rx_work_urbs, 0);\n\tatomic_set(&ar->rx_anch_urbs, 0);\n\tatomic_set(&ar->rx_pool_urbs, 0);\n\n\tusb_get_intf(intf);\n\n\tcarl9170_set_state(ar, CARL9170_STOPPED);\n\n\terr = request_firmware_nowait(THIS_MODULE, 1, CARL9170FW_NAME,\n\t\t&ar->udev->dev, GFP_KERNEL, ar, carl9170_usb_firmware_step2);\n\tif (err) {\n\t\tusb_put_intf(intf);\n\t\tcarl9170_free(ar);\n\t}\n\treturn err;\n}\n\nstatic void carl9170_usb_disconnect(struct usb_interface *intf)\n{\n\tstruct ar9170 *ar = usb_get_intfdata(intf);\n\n\tif (WARN_ON(!ar))\n\t\treturn;\n\n\twait_for_completion(&ar->fw_load_wait);\n\n\tif (IS_INITIALIZED(ar)) {\n\t\tcarl9170_reboot(ar);\n\t\tcarl9170_usb_stop(ar);\n\t}\n\n\tcarl9170_usb_cancel_urbs(ar);\n\tcarl9170_unregister(ar);\n\n\tusb_set_intfdata(intf, NULL);\n\n\tcarl9170_release_firmware(ar);\n\tcarl9170_free(ar);\n}\n\n#ifdef CONFIG_PM\nstatic int carl9170_usb_suspend(struct usb_interface *intf,\n\t\t\t\tpm_message_t message)\n{\n\tstruct ar9170 *ar = usb_get_intfdata(intf);\n\n\tif (!ar)\n\t\treturn -ENODEV;\n\n\tcarl9170_usb_cancel_urbs(ar);\n\n\treturn 0;\n}\n\nstatic int carl9170_usb_resume(struct usb_interface *intf)\n{\n\tstruct ar9170 *ar = usb_get_intfdata(intf);\n\tint err;\n\n\tif (!ar)\n\t\treturn -ENODEV;\n\n\tusb_unpoison_anchored_urbs(&ar->rx_anch);\n\tcarl9170_set_state(ar, CARL9170_STOPPED);\n\n\t \n\tmsleep(1100);\n\n\terr = carl9170_usb_init_device(ar);\n\tif (err)\n\t\tgoto err_unrx;\n\n\treturn 0;\n\nerr_unrx:\n\tcarl9170_usb_cancel_urbs(ar);\n\n\treturn err;\n}\n#endif  \n\nstatic struct usb_driver carl9170_driver = {\n\t.name = KBUILD_MODNAME,\n\t.probe = carl9170_usb_probe,\n\t.disconnect = carl9170_usb_disconnect,\n\t.id_table = carl9170_usb_ids,\n\t.soft_unbind = 1,\n#ifdef CONFIG_PM\n\t.suspend = carl9170_usb_suspend,\n\t.resume = carl9170_usb_resume,\n\t.reset_resume = carl9170_usb_resume,\n#endif  \n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(carl9170_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}