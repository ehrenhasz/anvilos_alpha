{
  "module_name": "rx.c",
  "hash_id": "0d1c6a1a13ddfb63be69222905d0dad8054baae7888d7a24e539b6d15134c57f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/carl9170/rx.c",
  "human_readable_source": " \n\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/etherdevice.h>\n#include <linux/crc32.h>\n#include <net/mac80211.h>\n#include \"carl9170.h\"\n#include \"hw.h\"\n#include \"cmd.h\"\n\nstatic void carl9170_dbg_message(struct ar9170 *ar, const char *buf, u32 len)\n{\n\tbool restart = false;\n\tenum carl9170_restart_reasons reason = CARL9170_RR_NO_REASON;\n\n\tif (len > 3) {\n\t\tif (memcmp(buf, CARL9170_ERR_MAGIC, 3) == 0) {\n\t\t\tar->fw.err_counter++;\n\t\t\tif (ar->fw.err_counter > 3) {\n\t\t\t\trestart = true;\n\t\t\t\treason = CARL9170_RR_TOO_MANY_FIRMWARE_ERRORS;\n\t\t\t}\n\t\t}\n\n\t\tif (memcmp(buf, CARL9170_BUG_MAGIC, 3) == 0) {\n\t\t\tar->fw.bug_counter++;\n\t\t\trestart = true;\n\t\t\treason = CARL9170_RR_FATAL_FIRMWARE_ERROR;\n\t\t}\n\t}\n\n\twiphy_info(ar->hw->wiphy, \"FW: %.*s\\n\", len, buf);\n\n\tif (restart)\n\t\tcarl9170_restart(ar, reason);\n}\n\nstatic void carl9170_handle_ps(struct ar9170 *ar, struct carl9170_rsp *rsp)\n{\n\tu32 ps;\n\tbool new_ps;\n\n\tps = le32_to_cpu(rsp->psm.state);\n\n\tnew_ps = (ps & CARL9170_PSM_COUNTER) != CARL9170_PSM_WAKE;\n\tif (ar->ps.state != new_ps) {\n\t\tif (!new_ps) {\n\t\t\tar->ps.sleep_ms = jiffies_to_msecs(jiffies -\n\t\t\t\tar->ps.last_action);\n\t\t}\n\n\t\tar->ps.last_action = jiffies;\n\n\t\tar->ps.state = new_ps;\n\t}\n}\n\nstatic int carl9170_check_sequence(struct ar9170 *ar, unsigned int seq)\n{\n\tif (ar->cmd_seq < -1)\n\t\treturn 0;\n\n\t \n\tif (ar->cmd_seq < 0)\n\t\tar->cmd_seq = seq;\n\n\t \n\tif (seq != ar->cmd_seq) {\n\t\tint count;\n\n\t\tcount = (seq - ar->cmd_seq) % ar->fw.cmd_bufs;\n\n\t\twiphy_err(ar->hw->wiphy, \"lost %d command responses/traps! \"\n\t\t\t  \"w:%d g:%d\\n\", count, ar->cmd_seq, seq);\n\n\t\tcarl9170_restart(ar, CARL9170_RR_LOST_RSP);\n\t\treturn -EIO;\n\t}\n\n\tar->cmd_seq = (ar->cmd_seq + 1) % ar->fw.cmd_bufs;\n\treturn 0;\n}\n\nstatic void carl9170_cmd_callback(struct ar9170 *ar, u32 len, void *buffer)\n{\n\t \n\tif (unlikely(ar->readlen != (len - 4))) {\n\t\tdev_warn(&ar->udev->dev, \"received invalid command response:\"\n\t\t\t \"got %d, instead of %d\\n\", len - 4, ar->readlen);\n\t\tprint_hex_dump_bytes(\"carl9170 cmd:\", DUMP_PREFIX_OFFSET,\n\t\t\tar->cmd_buf, (ar->cmd.hdr.len + 4) & 0x3f);\n\t\tprint_hex_dump_bytes(\"carl9170 rsp:\", DUMP_PREFIX_OFFSET,\n\t\t\tbuffer, len);\n\t\t \n\t\tcarl9170_restart(ar, CARL9170_RR_INVALID_RSP);\n\t}\n\n\tspin_lock(&ar->cmd_lock);\n\tif (ar->readbuf) {\n\t\tif (len >= 4)\n\t\t\tmemcpy(ar->readbuf, buffer + 4, len - 4);\n\n\t\tar->readbuf = NULL;\n\t}\n\tcomplete(&ar->cmd_wait);\n\tspin_unlock(&ar->cmd_lock);\n}\n\nvoid carl9170_handle_command_response(struct ar9170 *ar, void *buf, u32 len)\n{\n\tstruct carl9170_rsp *cmd = buf;\n\tstruct ieee80211_vif *vif;\n\n\tif ((cmd->hdr.cmd & CARL9170_RSP_FLAG) != CARL9170_RSP_FLAG) {\n\t\tif (!(cmd->hdr.cmd & CARL9170_CMD_ASYNC_FLAG))\n\t\t\tcarl9170_cmd_callback(ar, len, buf);\n\n\t\treturn;\n\t}\n\n\tif (unlikely(cmd->hdr.len != (len - 4))) {\n\t\tif (net_ratelimit()) {\n\t\t\twiphy_err(ar->hw->wiphy, \"FW: received over-/under\"\n\t\t\t\t\"sized event %x (%d, but should be %d).\\n\",\n\t\t\t       cmd->hdr.cmd, cmd->hdr.len, len - 4);\n\n\t\t\tprint_hex_dump_bytes(\"dump:\", DUMP_PREFIX_NONE,\n\t\t\t\t\t     buf, len);\n\t\t}\n\n\t\treturn;\n\t}\n\n\t \n\tswitch (cmd->hdr.cmd) {\n\tcase CARL9170_RSP_PRETBTT:\n\t\t \n\t\trcu_read_lock();\n\t\tvif = carl9170_get_main_vif(ar);\n\n\t\tif (!vif) {\n\t\t\trcu_read_unlock();\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (vif->type) {\n\t\tcase NL80211_IFTYPE_STATION:\n\t\t\tcarl9170_handle_ps(ar, cmd);\n\t\t\tbreak;\n\n\t\tcase NL80211_IFTYPE_AP:\n\t\tcase NL80211_IFTYPE_ADHOC:\n\t\tcase NL80211_IFTYPE_MESH_POINT:\n\t\t\tcarl9170_update_beacon(ar, true);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\trcu_read_unlock();\n\n\t\tbreak;\n\n\n\tcase CARL9170_RSP_TXCOMP:\n\t\t \n\t\tcarl9170_tx_process_status(ar, cmd);\n\t\tbreak;\n\n\tcase CARL9170_RSP_BEACON_CONFIG:\n\t\t \n\t\tbreak;\n\n\tcase CARL9170_RSP_ATIM:\n\t\t \n\t\tbreak;\n\n\tcase CARL9170_RSP_WATCHDOG:\n\t\t \n\t\tcarl9170_restart(ar, CARL9170_RR_WATCHDOG);\n\t\tbreak;\n\n\tcase CARL9170_RSP_TEXT:\n\t\t \n\t\tcarl9170_dbg_message(ar, (char *)buf + 4, len - 4);\n\t\tbreak;\n\n\tcase CARL9170_RSP_HEXDUMP:\n\t\twiphy_dbg(ar->hw->wiphy, \"FW: HD %d\\n\", len - 4);\n\t\tprint_hex_dump_bytes(\"FW:\", DUMP_PREFIX_NONE,\n\t\t\t\t     (char *)buf + 4, len - 4);\n\t\tbreak;\n\n\tcase CARL9170_RSP_RADAR:\n\t\tif (!net_ratelimit())\n\t\t\tbreak;\n\n\t\twiphy_info(ar->hw->wiphy, \"FW: RADAR! Please report this \"\n\t\t       \"incident to linux-wireless@vger.kernel.org !\\n\");\n\t\tbreak;\n\n\tcase CARL9170_RSP_GPIO:\n#ifdef CONFIG_CARL9170_WPC\n\t\tif (ar->wps.pbc) {\n\t\t\tbool state = !!(cmd->gpio.gpio & cpu_to_le32(\n\t\t\t\tAR9170_GPIO_PORT_WPS_BUTTON_PRESSED));\n\n\t\t\tif (state != ar->wps.pbc_state) {\n\t\t\t\tar->wps.pbc_state = state;\n\t\t\t\tinput_report_key(ar->wps.pbc, KEY_WPS_BUTTON,\n\t\t\t\t\t\t state);\n\t\t\t\tinput_sync(ar->wps.pbc);\n\t\t\t}\n\t\t}\n#endif  \n\t\tbreak;\n\n\tcase CARL9170_RSP_BOOT:\n\t\tcomplete(&ar->fw_boot_wait);\n\t\tbreak;\n\n\tdefault:\n\t\twiphy_err(ar->hw->wiphy, \"FW: received unhandled event %x\\n\",\n\t\t\tcmd->hdr.cmd);\n\t\tprint_hex_dump_bytes(\"dump:\", DUMP_PREFIX_NONE, buf, len);\n\t\tbreak;\n\t}\n}\n\nstatic int carl9170_rx_mac_status(struct ar9170 *ar,\n\tstruct ar9170_rx_head *head, struct ar9170_rx_macstatus *mac,\n\tstruct ieee80211_rx_status *status)\n{\n\tstruct ieee80211_channel *chan;\n\tu8 error, decrypt;\n\n\tBUILD_BUG_ON(sizeof(struct ar9170_rx_head) != 12);\n\tBUILD_BUG_ON(sizeof(struct ar9170_rx_macstatus) != 4);\n\n\terror = mac->error;\n\n\tif (error & AR9170_RX_ERROR_WRONG_RA) {\n\t\tif (!ar->sniffer_enabled)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (error & AR9170_RX_ERROR_PLCP) {\n\t\tif (!(ar->filter_state & FIF_PLCPFAIL))\n\t\t\treturn -EINVAL;\n\n\t\tstatus->flag |= RX_FLAG_FAILED_PLCP_CRC;\n\t}\n\n\tif (error & AR9170_RX_ERROR_FCS) {\n\t\tar->tx_fcs_errors++;\n\n\t\tif (!(ar->filter_state & FIF_FCSFAIL))\n\t\t\treturn -EINVAL;\n\n\t\tstatus->flag |= RX_FLAG_FAILED_FCS_CRC;\n\t}\n\n\tdecrypt = ar9170_get_decrypt_type(mac);\n\tif (!(decrypt & AR9170_RX_ENC_SOFTWARE) &&\n\t    decrypt != AR9170_ENC_ALG_NONE) {\n\t\tif ((decrypt == AR9170_ENC_ALG_TKIP) &&\n\t\t    (error & AR9170_RX_ERROR_MMIC))\n\t\t\tstatus->flag |= RX_FLAG_MMIC_ERROR;\n\n\t\tstatus->flag |= RX_FLAG_DECRYPTED;\n\t}\n\n\tif (error & AR9170_RX_ERROR_DECRYPT && !ar->sniffer_enabled)\n\t\treturn -ENODATA;\n\n\terror &= ~(AR9170_RX_ERROR_MMIC |\n\t\t   AR9170_RX_ERROR_FCS |\n\t\t   AR9170_RX_ERROR_WRONG_RA |\n\t\t   AR9170_RX_ERROR_DECRYPT |\n\t\t   AR9170_RX_ERROR_PLCP);\n\n\t \n\tif (unlikely(error)) {\n\t\t \n\n\t\tif (net_ratelimit())\n\t\t\twiphy_dbg(ar->hw->wiphy, \"received frame with \"\n\t\t\t       \"suspicious error code (%#x).\\n\", error);\n\n\t\treturn -EINVAL;\n\t}\n\n\tchan = ar->channel;\n\tif (chan) {\n\t\tstatus->band = chan->band;\n\t\tstatus->freq = chan->center_freq;\n\t}\n\n\tswitch (mac->status & AR9170_RX_STATUS_MODULATION) {\n\tcase AR9170_RX_STATUS_MODULATION_CCK:\n\t\tif (mac->status & AR9170_RX_STATUS_SHORT_PREAMBLE)\n\t\t\tstatus->enc_flags |= RX_ENC_FLAG_SHORTPRE;\n\t\tswitch (head->plcp[0]) {\n\t\tcase AR9170_RX_PHY_RATE_CCK_1M:\n\t\t\tstatus->rate_idx = 0;\n\t\t\tbreak;\n\t\tcase AR9170_RX_PHY_RATE_CCK_2M:\n\t\t\tstatus->rate_idx = 1;\n\t\t\tbreak;\n\t\tcase AR9170_RX_PHY_RATE_CCK_5M:\n\t\t\tstatus->rate_idx = 2;\n\t\t\tbreak;\n\t\tcase AR9170_RX_PHY_RATE_CCK_11M:\n\t\t\tstatus->rate_idx = 3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (net_ratelimit()) {\n\t\t\t\twiphy_err(ar->hw->wiphy, \"invalid plcp cck \"\n\t\t\t\t       \"rate (%x).\\n\", head->plcp[0]);\n\t\t\t}\n\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\n\tcase AR9170_RX_STATUS_MODULATION_DUPOFDM:\n\tcase AR9170_RX_STATUS_MODULATION_OFDM:\n\t\tswitch (head->plcp[0] & 0xf) {\n\t\tcase AR9170_TXRX_PHY_RATE_OFDM_6M:\n\t\t\tstatus->rate_idx = 0;\n\t\t\tbreak;\n\t\tcase AR9170_TXRX_PHY_RATE_OFDM_9M:\n\t\t\tstatus->rate_idx = 1;\n\t\t\tbreak;\n\t\tcase AR9170_TXRX_PHY_RATE_OFDM_12M:\n\t\t\tstatus->rate_idx = 2;\n\t\t\tbreak;\n\t\tcase AR9170_TXRX_PHY_RATE_OFDM_18M:\n\t\t\tstatus->rate_idx = 3;\n\t\t\tbreak;\n\t\tcase AR9170_TXRX_PHY_RATE_OFDM_24M:\n\t\t\tstatus->rate_idx = 4;\n\t\t\tbreak;\n\t\tcase AR9170_TXRX_PHY_RATE_OFDM_36M:\n\t\t\tstatus->rate_idx = 5;\n\t\t\tbreak;\n\t\tcase AR9170_TXRX_PHY_RATE_OFDM_48M:\n\t\t\tstatus->rate_idx = 6;\n\t\t\tbreak;\n\t\tcase AR9170_TXRX_PHY_RATE_OFDM_54M:\n\t\t\tstatus->rate_idx = 7;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (net_ratelimit()) {\n\t\t\t\twiphy_err(ar->hw->wiphy, \"invalid plcp ofdm \"\n\t\t\t\t\t\"rate (%x).\\n\", head->plcp[0]);\n\t\t\t}\n\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (status->band == NL80211_BAND_2GHZ)\n\t\t\tstatus->rate_idx += 4;\n\t\tbreak;\n\n\tcase AR9170_RX_STATUS_MODULATION_HT:\n\t\tif (head->plcp[3] & 0x80)\n\t\t\tstatus->bw = RATE_INFO_BW_40;\n\t\tif (head->plcp[6] & 0x80)\n\t\t\tstatus->enc_flags |= RX_ENC_FLAG_SHORT_GI;\n\n\t\tstatus->rate_idx = clamp(head->plcp[3] & 0x7f, 0, 75);\n\t\tstatus->encoding = RX_ENC_HT;\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t\treturn -ENOSYS;\n\t}\n\n\treturn 0;\n}\n\nstatic void carl9170_rx_phy_status(struct ar9170 *ar,\n\tstruct ar9170_rx_phystatus *phy, struct ieee80211_rx_status *status)\n{\n\tint i;\n\n\tBUILD_BUG_ON(sizeof(struct ar9170_rx_phystatus) != 20);\n\n\tfor (i = 0; i < 3; i++)\n\t\tif (phy->rssi[i] != 0x80)\n\t\t\tstatus->antenna |= BIT(i);\n\n\t \n\tfor (i = 0; i < 7; i++)\n\t\tif (phy->rssi[i] & 0x80)\n\t\t\tphy->rssi[i] = ((~phy->rssi[i] & 0x7f) + 1) & 0x7f;\n\n\t \n\tstatus->signal = ar->noise[0] + phy->rssi_combined;\n}\n\nstatic struct sk_buff *carl9170_rx_copy_data(u8 *buf, int len)\n{\n\tstruct sk_buff *skb;\n\tint reserved = 0;\n\tstruct ieee80211_hdr *hdr = (void *) buf;\n\n\tif (ieee80211_is_data_qos(hdr->frame_control)) {\n\t\tu8 *qc = ieee80211_get_qos_ctl(hdr);\n\t\treserved += NET_IP_ALIGN;\n\n\t\tif (*qc & IEEE80211_QOS_CTL_A_MSDU_PRESENT)\n\t\t\treserved += NET_IP_ALIGN;\n\t}\n\n\tif (ieee80211_has_a4(hdr->frame_control))\n\t\treserved += NET_IP_ALIGN;\n\n\treserved = 32 + (reserved & NET_IP_ALIGN);\n\n\tskb = dev_alloc_skb(len + reserved);\n\tif (likely(skb)) {\n\t\tskb_reserve(skb, reserved);\n\t\tskb_put_data(skb, buf, len);\n\t}\n\n\treturn skb;\n}\n\nstatic u8 *carl9170_find_ie(u8 *data, unsigned int len, u8 ie)\n{\n\tstruct ieee80211_mgmt *mgmt = (void *)data;\n\tu8 *pos, *end;\n\n\tpos = (u8 *)mgmt->u.beacon.variable;\n\tend = data + len;\n\twhile (pos < end) {\n\t\tif (pos + 2 + pos[1] > end)\n\t\t\treturn NULL;\n\n\t\tif (pos[0] == ie)\n\t\t\treturn pos;\n\n\t\tpos += 2 + pos[1];\n\t}\n\treturn NULL;\n}\n\n \nstatic void carl9170_ps_beacon(struct ar9170 *ar, void *data, unsigned int len)\n{\n\tstruct ieee80211_hdr *hdr = data;\n\tstruct ieee80211_tim_ie *tim_ie;\n\tstruct ath_common *common = &ar->common;\n\tu8 *tim;\n\tu8 tim_len;\n\tbool cam;\n\n\tif (likely(!(ar->hw->conf.flags & IEEE80211_CONF_PS)))\n\t\treturn;\n\n\t \n\tif (len <= 40 + FCS_LEN)\n\t\treturn;\n\n\t \n\t \n\tif (!ath_is_mybeacon(common, hdr) || !common->curaid)\n\t\treturn;\n\n\tar->ps.last_beacon = jiffies;\n\n\ttim = carl9170_find_ie(data, len - FCS_LEN, WLAN_EID_TIM);\n\tif (!tim)\n\t\treturn;\n\n\tif (tim[1] < sizeof(*tim_ie))\n\t\treturn;\n\n\ttim_len = tim[1];\n\ttim_ie = (struct ieee80211_tim_ie *) &tim[2];\n\n\tif (!WARN_ON_ONCE(!ar->hw->conf.ps_dtim_period))\n\t\tar->ps.dtim_counter = (tim_ie->dtim_count - 1) %\n\t\t\tar->hw->conf.ps_dtim_period;\n\n\t \n\n\t \n\tcam = ieee80211_check_tim(tim_ie, tim_len, ar->common.curaid);\n\n\t \n\tcam |= !!(tim_ie->bitmap_ctrl & 0x01);\n\n\tif (!cam) {\n\t\t \n\t\tar->ps.off_override &= ~PS_OFF_BCN;\n\t\tcarl9170_ps_check(ar);\n\t} else {\n\t\t \n\t\tar->ps.off_override |= PS_OFF_BCN;\n\t}\n}\n\nstatic void carl9170_ba_check(struct ar9170 *ar, void *data, unsigned int len)\n{\n\tstruct ieee80211_bar *bar = data;\n\tstruct carl9170_bar_list_entry *entry;\n\tunsigned int queue;\n\n\tif (likely(!ieee80211_is_back(bar->frame_control)))\n\t\treturn;\n\n\tif (len <= sizeof(*bar) + FCS_LEN)\n\t\treturn;\n\n\tqueue = TID_TO_WME_AC(((le16_to_cpu(bar->control) &\n\t\tIEEE80211_BAR_CTRL_TID_INFO_MASK) >>\n\t\tIEEE80211_BAR_CTRL_TID_INFO_SHIFT) & 7);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(entry, &ar->bar_list[queue], list) {\n\t\tstruct sk_buff *entry_skb = entry->skb;\n\t\tstruct _carl9170_tx_superframe *super = (void *)entry_skb->data;\n\t\tstruct ieee80211_bar *entry_bar = (void *)super->frame_data;\n\n#define TID_CHECK(a, b) (\t\t\t\t\t\t\\\n\t((a) & cpu_to_le16(IEEE80211_BAR_CTRL_TID_INFO_MASK)) ==\t\\\n\t((b) & cpu_to_le16(IEEE80211_BAR_CTRL_TID_INFO_MASK)))\t\t\\\n\n\t\tif (bar->start_seq_num == entry_bar->start_seq_num &&\n\t\t    TID_CHECK(bar->control, entry_bar->control) &&\n\t\t    ether_addr_equal_64bits(bar->ra, entry_bar->ta) &&\n\t\t    ether_addr_equal_64bits(bar->ta, entry_bar->ra)) {\n\t\t\tstruct ieee80211_tx_info *tx_info;\n\n\t\t\ttx_info = IEEE80211_SKB_CB(entry_skb);\n\t\t\ttx_info->flags |= IEEE80211_TX_STAT_ACK;\n\n\t\t\tspin_lock_bh(&ar->bar_list_lock[queue]);\n\t\t\tlist_del_rcu(&entry->list);\n\t\t\tspin_unlock_bh(&ar->bar_list_lock[queue]);\n\t\t\tkfree_rcu(entry, head);\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n#undef TID_CHECK\n}\n\nstatic bool carl9170_ampdu_check(struct ar9170 *ar, u8 *buf, u8 ms,\n\t\t\t\t struct ieee80211_rx_status *rx_status)\n{\n\t__le16 fc;\n\n\tif ((ms & AR9170_RX_STATUS_MPDU) == AR9170_RX_STATUS_MPDU_SINGLE) {\n\t\t \n\t\treturn true;\n\t}\n\n\trx_status->flag |= RX_FLAG_AMPDU_DETAILS | RX_FLAG_AMPDU_LAST_KNOWN;\n\trx_status->ampdu_reference = ar->ampdu_ref;\n\n\t \n\n\tfc = ((struct ieee80211_hdr *)buf)->frame_control;\n\tif (ieee80211_is_data_qos(fc) && ieee80211_is_data_present(fc))\n\t\treturn true;\n\n\tif (ieee80211_is_ack(fc) || ieee80211_is_back(fc) ||\n\t    ieee80211_is_back_req(fc))\n\t\treturn true;\n\n\tif (ieee80211_is_action(fc))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int carl9170_handle_mpdu(struct ar9170 *ar, u8 *buf, int len,\n\t\t\t\tstruct ieee80211_rx_status *status)\n{\n\tstruct sk_buff *skb;\n\n\t \n\n\tcarl9170_ps_beacon(ar, buf, len);\n\n\tcarl9170_ba_check(ar, buf, len);\n\n\tskb = carl9170_rx_copy_data(buf, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tmemcpy(IEEE80211_SKB_RXCB(skb), status, sizeof(*status));\n\tieee80211_rx(ar->hw, skb);\n\treturn 0;\n}\n\n \nstatic void carl9170_rx_untie_data(struct ar9170 *ar, u8 *buf, int len)\n{\n\tstruct ar9170_rx_head *head;\n\tstruct ar9170_rx_macstatus *mac;\n\tstruct ar9170_rx_phystatus *phy = NULL;\n\tstruct ieee80211_rx_status status;\n\tint mpdu_len;\n\tu8 mac_status;\n\n\tif (!IS_STARTED(ar))\n\t\treturn;\n\n\tif (unlikely(len < sizeof(*mac)))\n\t\tgoto drop;\n\n\tmemset(&status, 0, sizeof(status));\n\n\tmpdu_len = len - sizeof(*mac);\n\n\tmac = (void *)(buf + mpdu_len);\n\tmac_status = mac->status;\n\tswitch (mac_status & AR9170_RX_STATUS_MPDU) {\n\tcase AR9170_RX_STATUS_MPDU_FIRST:\n\t\tar->ampdu_ref++;\n\t\t \n\t\tif (likely(mpdu_len >= sizeof(struct ar9170_rx_head))) {\n\t\t\thead = (void *) buf;\n\n\t\t\t \n\t\t\tmemcpy(&ar->rx_plcp, (void *) buf,\n\t\t\t       sizeof(struct ar9170_rx_head));\n\n\t\t\tmpdu_len -= sizeof(struct ar9170_rx_head);\n\t\t\tbuf += sizeof(struct ar9170_rx_head);\n\n\t\t\tar->rx_has_plcp = true;\n\t\t} else {\n\t\t\tif (net_ratelimit()) {\n\t\t\t\twiphy_err(ar->hw->wiphy, \"plcp info \"\n\t\t\t\t\t\"is clipped.\\n\");\n\t\t\t}\n\n\t\t\tgoto drop;\n\t\t}\n\t\tbreak;\n\n\tcase AR9170_RX_STATUS_MPDU_LAST:\n\t\tstatus.flag |= RX_FLAG_AMPDU_IS_LAST;\n\n\t\t \n\t\tif (likely(mpdu_len >= sizeof(struct ar9170_rx_phystatus))) {\n\t\t\tmpdu_len -= sizeof(struct ar9170_rx_phystatus);\n\t\t\tphy = (void *)(buf + mpdu_len);\n\t\t} else {\n\t\t\tif (net_ratelimit()) {\n\t\t\t\twiphy_err(ar->hw->wiphy, \"frame tail \"\n\t\t\t\t\t\"is clipped.\\n\");\n\t\t\t}\n\n\t\t\tgoto drop;\n\t\t}\n\t\tfallthrough;\n\n\tcase AR9170_RX_STATUS_MPDU_MIDDLE:\n\t\t \n\t\tif (unlikely(!ar->rx_has_plcp)) {\n\t\t\tif (!net_ratelimit())\n\t\t\t\treturn;\n\n\t\t\twiphy_err(ar->hw->wiphy, \"rx stream does not start \"\n\t\t\t\t\t\"with a first_mpdu frame tag.\\n\");\n\n\t\t\tgoto drop;\n\t\t}\n\n\t\thead = &ar->rx_plcp;\n\t\tbreak;\n\n\tcase AR9170_RX_STATUS_MPDU_SINGLE:\n\t\t \n\t\thead = (void *) buf;\n\n\t\tmpdu_len -= sizeof(struct ar9170_rx_head);\n\t\tmpdu_len -= sizeof(struct ar9170_rx_phystatus);\n\n\t\tbuf += sizeof(struct ar9170_rx_head);\n\t\tphy = (void *)(buf + mpdu_len);\n\t\tbreak;\n\n\tdefault:\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\t \n\tif (unlikely(mpdu_len < (2 + 2 + ETH_ALEN + FCS_LEN)))\n\t\tgoto drop;\n\n\tif (unlikely(carl9170_rx_mac_status(ar, head, mac, &status)))\n\t\tgoto drop;\n\n\tif (!carl9170_ampdu_check(ar, buf, mac_status, &status))\n\t\tgoto drop;\n\n\tif (phy)\n\t\tcarl9170_rx_phy_status(ar, phy, &status);\n\telse\n\t\tstatus.flag |= RX_FLAG_NO_SIGNAL_VAL;\n\n\tif (carl9170_handle_mpdu(ar, buf, mpdu_len, &status))\n\t\tgoto drop;\n\n\treturn;\ndrop:\n\tar->rx_dropped++;\n}\n\nstatic void carl9170_rx_untie_cmds(struct ar9170 *ar, const u8 *respbuf,\n\t\t\t\t   const unsigned int resplen)\n{\n\tstruct carl9170_rsp *cmd;\n\tint i = 0;\n\n\twhile (i < resplen) {\n\t\tcmd = (void *) &respbuf[i];\n\n\t\ti += cmd->hdr.len + 4;\n\t\tif (unlikely(i > resplen))\n\t\t\tbreak;\n\n\t\tif (carl9170_check_sequence(ar, cmd->hdr.seq))\n\t\t\tbreak;\n\n\t\tcarl9170_handle_command_response(ar, cmd, cmd->hdr.len + 4);\n\t}\n\n\tif (unlikely(i != resplen)) {\n\t\tif (!net_ratelimit())\n\t\t\treturn;\n\n\t\twiphy_err(ar->hw->wiphy, \"malformed firmware trap:\\n\");\n\t\tprint_hex_dump_bytes(\"rxcmd:\", DUMP_PREFIX_OFFSET,\n\t\t\t\t     respbuf, resplen);\n\t}\n}\n\nstatic void __carl9170_rx(struct ar9170 *ar, u8 *buf, unsigned int len)\n{\n\tunsigned int i = 0;\n\n\t \n\twhile (len > 2 && i < 12 && buf[0] == 0xff && buf[1] == 0xff) {\n\t\ti += 2;\n\t\tlen -= 2;\n\t\tbuf += 2;\n\t}\n\n\tif (unlikely(len < 4))\n\t\treturn;\n\n\t \n\tif (i == 12)\n\t\tcarl9170_rx_untie_cmds(ar, buf, len);\n\telse\n\t\tcarl9170_rx_untie_data(ar, buf, len);\n}\n\nstatic void carl9170_rx_stream(struct ar9170 *ar, void *buf, unsigned int len)\n{\n\tunsigned int tlen, wlen = 0, clen = 0;\n\tstruct ar9170_stream *rx_stream;\n\tu8 *tbuf;\n\n\ttbuf = buf;\n\ttlen = len;\n\n\twhile (tlen >= 4) {\n\t\trx_stream = (void *) tbuf;\n\t\tclen = le16_to_cpu(rx_stream->length);\n\t\twlen = ALIGN(clen, 4);\n\n\t\t \n\t\tif (rx_stream->tag != cpu_to_le16(AR9170_RX_STREAM_TAG)) {\n\t\t\t \n\n\t\t\t \n\t\t\tif (!ar->rx_failover_missing) {\n\n\t\t\t\t \n\t\t\t\tif (net_ratelimit()) {\n\t\t\t\t\twiphy_err(ar->hw->wiphy,\n\t\t\t\t\t\t\"missing tag!\\n\");\n\t\t\t\t}\n\n\t\t\t\t__carl9170_rx(ar, tbuf, tlen);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (ar->rx_failover_missing > tlen) {\n\t\t\t\tif (net_ratelimit()) {\n\t\t\t\t\twiphy_err(ar->hw->wiphy,\n\t\t\t\t\t\t\"possible multi \"\n\t\t\t\t\t\t\"stream corruption!\\n\");\n\t\t\t\t\tgoto err_telluser;\n\t\t\t\t} else {\n\t\t\t\t\tgoto err_silent;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tskb_put_data(ar->rx_failover, tbuf, tlen);\n\t\t\tar->rx_failover_missing -= tlen;\n\n\t\t\tif (ar->rx_failover_missing <= 0) {\n\t\t\t\t \n\n\t\t\t\tar->rx_failover_missing = 0;\n\t\t\t\tcarl9170_rx_stream(ar, ar->rx_failover->data,\n\t\t\t\t\t\t   ar->rx_failover->len);\n\n\t\t\t\tskb_reset_tail_pointer(ar->rx_failover);\n\t\t\t\tskb_trim(ar->rx_failover, 0);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tif (wlen > tlen - 4) {\n\t\t\tif (ar->rx_failover_missing) {\n\t\t\t\t \n\t\t\t\tif (net_ratelimit()) {\n\t\t\t\t\twiphy_err(ar->hw->wiphy, \"double rx \"\n\t\t\t\t\t\t\"stream corruption!\\n\");\n\t\t\t\t\tgoto err_telluser;\n\t\t\t\t} else {\n\t\t\t\t\tgoto err_silent;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\n\t\t\tskb_put_data(ar->rx_failover, tbuf, tlen);\n\t\t\tar->rx_failover_missing = clen - tlen;\n\t\t\treturn;\n\t\t}\n\t\t__carl9170_rx(ar, rx_stream->payload, clen);\n\n\t\ttbuf += wlen + 4;\n\t\ttlen -= wlen + 4;\n\t}\n\n\tif (tlen) {\n\t\tif (net_ratelimit()) {\n\t\t\twiphy_err(ar->hw->wiphy, \"%d bytes of unprocessed \"\n\t\t\t\t\"data left in rx stream!\\n\", tlen);\n\t\t}\n\n\t\tgoto err_telluser;\n\t}\n\n\treturn;\n\nerr_telluser:\n\twiphy_err(ar->hw->wiphy, \"damaged RX stream data [want:%d, \"\n\t\t\"data:%d, rx:%d, pending:%d ]\\n\", clen, wlen, tlen,\n\t\tar->rx_failover_missing);\n\n\tif (ar->rx_failover_missing)\n\t\tprint_hex_dump_bytes(\"rxbuf:\", DUMP_PREFIX_OFFSET,\n\t\t\t\t     ar->rx_failover->data,\n\t\t\t\t     ar->rx_failover->len);\n\n\tprint_hex_dump_bytes(\"stream:\", DUMP_PREFIX_OFFSET,\n\t\t\t     buf, len);\n\n\twiphy_err(ar->hw->wiphy, \"please check your hardware and cables, if \"\n\t\t\"you see this message frequently.\\n\");\n\nerr_silent:\n\tif (ar->rx_failover_missing) {\n\t\tskb_reset_tail_pointer(ar->rx_failover);\n\t\tskb_trim(ar->rx_failover, 0);\n\t\tar->rx_failover_missing = 0;\n\t}\n}\n\nvoid carl9170_rx(struct ar9170 *ar, void *buf, unsigned int len)\n{\n\tif (ar->fw.rx_stream)\n\t\tcarl9170_rx_stream(ar, buf, len);\n\telse\n\t\t__carl9170_rx(ar, buf, len);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}