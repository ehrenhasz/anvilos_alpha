{
  "module_name": "key.c",
  "hash_id": "fa192caf28885f8a0ad99cb04218b642596cfa6657c45e3f6f32c55f8b58f762",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/key.c",
  "human_readable_source": " \n\n#include <linux/export.h>\n#include <asm/unaligned.h>\n#include <net/mac80211.h>\n\n#include \"ath.h\"\n#include \"reg.h\"\n\n#define REG_READ\t\t\t(common->ops->read)\n#define REG_WRITE(_ah, _reg, _val)\t(common->ops->write)(_ah, _val, _reg)\n#define ENABLE_REGWRITE_BUFFER(_ah)\t\t\t\\\n\tif (common->ops->enable_write_buffer)\t\t\\\n\t\tcommon->ops->enable_write_buffer((_ah));\n\n#define REGWRITE_BUFFER_FLUSH(_ah)\t\t\t\\\n\tif (common->ops->write_flush)\t\t\t\\\n\t\tcommon->ops->write_flush((_ah));\n\n\n#define IEEE80211_WEP_NKID      4        \n\n \n \n \n\nbool ath_hw_keyreset(struct ath_common *common, u16 entry)\n{\n\tu32 keyType;\n\tvoid *ah = common->ah;\n\n\tif (entry >= common->keymax) {\n\t\tath_err(common, \"keyreset: keycache entry %u out of range\\n\",\n\t\t\tentry);\n\t\treturn false;\n\t}\n\n\tkeyType = REG_READ(ah, AR_KEYTABLE_TYPE(entry));\n\n\tENABLE_REGWRITE_BUFFER(ah);\n\n\tREG_WRITE(ah, AR_KEYTABLE_KEY0(entry), 0);\n\tREG_WRITE(ah, AR_KEYTABLE_KEY1(entry), 0);\n\tREG_WRITE(ah, AR_KEYTABLE_KEY2(entry), 0);\n\tREG_WRITE(ah, AR_KEYTABLE_KEY3(entry), 0);\n\tREG_WRITE(ah, AR_KEYTABLE_KEY4(entry), 0);\n\tREG_WRITE(ah, AR_KEYTABLE_TYPE(entry), AR_KEYTABLE_TYPE_CLR);\n\tREG_WRITE(ah, AR_KEYTABLE_MAC0(entry), 0);\n\tREG_WRITE(ah, AR_KEYTABLE_MAC1(entry), 0);\n\n\tif (keyType == AR_KEYTABLE_TYPE_TKIP) {\n\t\tu16 micentry = entry + 64;\n\n\t\tREG_WRITE(ah, AR_KEYTABLE_KEY0(micentry), 0);\n\t\tREG_WRITE(ah, AR_KEYTABLE_KEY1(micentry), 0);\n\t\tREG_WRITE(ah, AR_KEYTABLE_KEY2(micentry), 0);\n\t\tREG_WRITE(ah, AR_KEYTABLE_KEY3(micentry), 0);\n\t\tif (common->crypt_caps & ATH_CRYPT_CAP_MIC_COMBINED) {\n\t\t\tREG_WRITE(ah, AR_KEYTABLE_KEY4(micentry), 0);\n\t\t\tREG_WRITE(ah, AR_KEYTABLE_TYPE(micentry),\n\t\t\t\t  AR_KEYTABLE_TYPE_CLR);\n\t\t}\n\n\t}\n\n\tREGWRITE_BUFFER_FLUSH(ah);\n\n\treturn true;\n}\nEXPORT_SYMBOL(ath_hw_keyreset);\n\nbool ath_hw_keysetmac(struct ath_common *common, u16 entry, const u8 *mac)\n{\n\tu32 macHi, macLo;\n\tu32 unicast_flag = AR_KEYTABLE_VALID;\n\tvoid *ah = common->ah;\n\n\tif (entry >= common->keymax) {\n\t\tath_err(common, \"keysetmac: keycache entry %u out of range\\n\",\n\t\t\tentry);\n\t\treturn false;\n\t}\n\n\tif (mac != NULL) {\n\t\t \n\t\tif (is_multicast_ether_addr(mac))\n\t\t\tunicast_flag = 0;\n\n\t\tmacLo = get_unaligned_le32(mac);\n\t\tmacHi = get_unaligned_le16(mac + 4);\n\t\tmacLo >>= 1;\n\t\tmacLo |= (macHi & 1) << 31;\n\t\tmacHi >>= 1;\n\t} else {\n\t\tmacLo = macHi = 0;\n\t}\n\tENABLE_REGWRITE_BUFFER(ah);\n\n\tREG_WRITE(ah, AR_KEYTABLE_MAC0(entry), macLo);\n\tREG_WRITE(ah, AR_KEYTABLE_MAC1(entry), macHi | unicast_flag);\n\n\tREGWRITE_BUFFER_FLUSH(ah);\n\n\treturn true;\n}\nEXPORT_SYMBOL(ath_hw_keysetmac);\n\nstatic bool ath_hw_set_keycache_entry(struct ath_common *common, u16 entry,\n\t\t\t\t      const struct ath_keyval *k,\n\t\t\t\t      const u8 *mac)\n{\n\tvoid *ah = common->ah;\n\tu32 key0, key1, key2, key3, key4;\n\tu32 keyType;\n\n\tif (entry >= common->keymax) {\n\t\tath_err(common, \"set-entry: keycache entry %u out of range\\n\",\n\t\t\tentry);\n\t\treturn false;\n\t}\n\n\tswitch (k->kv_type) {\n\tcase ATH_CIPHER_AES_OCB:\n\t\tkeyType = AR_KEYTABLE_TYPE_AES;\n\t\tbreak;\n\tcase ATH_CIPHER_AES_CCM:\n\t\tif (!(common->crypt_caps & ATH_CRYPT_CAP_CIPHER_AESCCM)) {\n\t\t\tath_dbg(common, ANY,\n\t\t\t\t\"AES-CCM not supported by this mac rev\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tkeyType = AR_KEYTABLE_TYPE_CCM;\n\t\tbreak;\n\tcase ATH_CIPHER_TKIP:\n\t\tkeyType = AR_KEYTABLE_TYPE_TKIP;\n\t\tif (entry + 64 >= common->keymax) {\n\t\t\tath_dbg(common, ANY,\n\t\t\t\t\"entry %u inappropriate for TKIP\\n\", entry);\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tcase ATH_CIPHER_WEP:\n\t\tif (k->kv_len < WLAN_KEY_LEN_WEP40) {\n\t\t\tath_dbg(common, ANY, \"WEP key length %u too small\\n\",\n\t\t\t\tk->kv_len);\n\t\t\treturn false;\n\t\t}\n\t\tif (k->kv_len <= WLAN_KEY_LEN_WEP40)\n\t\t\tkeyType = AR_KEYTABLE_TYPE_40;\n\t\telse if (k->kv_len <= WLAN_KEY_LEN_WEP104)\n\t\t\tkeyType = AR_KEYTABLE_TYPE_104;\n\t\telse\n\t\t\tkeyType = AR_KEYTABLE_TYPE_128;\n\t\tbreak;\n\tcase ATH_CIPHER_CLR:\n\t\tkeyType = AR_KEYTABLE_TYPE_CLR;\n\t\tbreak;\n\tdefault:\n\t\tath_err(common, \"cipher %u not supported\\n\", k->kv_type);\n\t\treturn false;\n\t}\n\n\tkey0 = get_unaligned_le32(k->kv_val + 0);\n\tkey1 = get_unaligned_le16(k->kv_val + 4);\n\tkey2 = get_unaligned_le32(k->kv_val + 6);\n\tkey3 = get_unaligned_le16(k->kv_val + 10);\n\tkey4 = get_unaligned_le32(k->kv_val + 12);\n\tif (k->kv_len <= WLAN_KEY_LEN_WEP104)\n\t\tkey4 &= 0xff;\n\n\t \n\n\tif (keyType == AR_KEYTABLE_TYPE_TKIP) {\n\t\tu16 micentry = entry + 64;\n\n\t\t \n\t\tREG_WRITE(ah, AR_KEYTABLE_KEY0(entry), ~key0);\n\t\tREG_WRITE(ah, AR_KEYTABLE_KEY1(entry), ~key1);\n\n\t\t \n\t\tREG_WRITE(ah, AR_KEYTABLE_KEY2(entry), key2);\n\t\tREG_WRITE(ah, AR_KEYTABLE_KEY3(entry), key3);\n\n\t\t \n\t\tREG_WRITE(ah, AR_KEYTABLE_KEY4(entry), key4);\n\t\tREG_WRITE(ah, AR_KEYTABLE_TYPE(entry), keyType);\n\n\t\t \n\t\t(void) ath_hw_keysetmac(common, entry, mac);\n\n\t\tif (common->crypt_caps & ATH_CRYPT_CAP_MIC_COMBINED) {\n\t\t\t \n\t\t\tu32 mic0, mic1, mic2, mic3, mic4;\n\n\t\t\tmic0 = get_unaligned_le32(k->kv_mic + 0);\n\t\t\tmic2 = get_unaligned_le32(k->kv_mic + 4);\n\t\t\tmic1 = get_unaligned_le16(k->kv_txmic + 2) & 0xffff;\n\t\t\tmic3 = get_unaligned_le16(k->kv_txmic + 0) & 0xffff;\n\t\t\tmic4 = get_unaligned_le32(k->kv_txmic + 4);\n\n\t\t\tENABLE_REGWRITE_BUFFER(ah);\n\n\t\t\t \n\t\t\tREG_WRITE(ah, AR_KEYTABLE_KEY0(micentry), mic0);\n\t\t\tREG_WRITE(ah, AR_KEYTABLE_KEY1(micentry), mic1);\n\n\t\t\t \n\t\t\tREG_WRITE(ah, AR_KEYTABLE_KEY2(micentry), mic2);\n\t\t\tREG_WRITE(ah, AR_KEYTABLE_KEY3(micentry), mic3);\n\n\t\t\t \n\t\t\tREG_WRITE(ah, AR_KEYTABLE_KEY4(micentry), mic4);\n\t\t\tREG_WRITE(ah, AR_KEYTABLE_TYPE(micentry),\n\t\t\t\t  AR_KEYTABLE_TYPE_CLR);\n\n\t\t\tREGWRITE_BUFFER_FLUSH(ah);\n\n\t\t} else {\n\t\t\t \n\t\t\tu32 mic0, mic2;\n\n\t\t\tmic0 = get_unaligned_le32(k->kv_mic + 0);\n\t\t\tmic2 = get_unaligned_le32(k->kv_mic + 4);\n\n\t\t\tENABLE_REGWRITE_BUFFER(ah);\n\n\t\t\t \n\t\t\tREG_WRITE(ah, AR_KEYTABLE_KEY0(micentry), mic0);\n\t\t\tREG_WRITE(ah, AR_KEYTABLE_KEY1(micentry), 0);\n\n\t\t\t \n\t\t\tREG_WRITE(ah, AR_KEYTABLE_KEY2(micentry), mic2);\n\t\t\tREG_WRITE(ah, AR_KEYTABLE_KEY3(micentry), 0);\n\n\t\t\t \n\t\t\tREG_WRITE(ah, AR_KEYTABLE_KEY4(micentry), 0);\n\t\t\tREG_WRITE(ah, AR_KEYTABLE_TYPE(micentry),\n\t\t\t\t  AR_KEYTABLE_TYPE_CLR);\n\n\t\t\tREGWRITE_BUFFER_FLUSH(ah);\n\t\t}\n\n\t\tENABLE_REGWRITE_BUFFER(ah);\n\n\t\t \n\t\tREG_WRITE(ah, AR_KEYTABLE_MAC0(micentry), 0);\n\t\tREG_WRITE(ah, AR_KEYTABLE_MAC1(micentry), 0);\n\n\t\t \n\t\tREG_WRITE(ah, AR_KEYTABLE_KEY0(entry), key0);\n\t\tREG_WRITE(ah, AR_KEYTABLE_KEY1(entry), key1);\n\n\t\tREGWRITE_BUFFER_FLUSH(ah);\n\t} else {\n\t\tENABLE_REGWRITE_BUFFER(ah);\n\n\t\t \n\t\tREG_WRITE(ah, AR_KEYTABLE_KEY0(entry), key0);\n\t\tREG_WRITE(ah, AR_KEYTABLE_KEY1(entry), key1);\n\n\t\t \n\t\tREG_WRITE(ah, AR_KEYTABLE_KEY2(entry), key2);\n\t\tREG_WRITE(ah, AR_KEYTABLE_KEY3(entry), key3);\n\n\t\t \n\t\tREG_WRITE(ah, AR_KEYTABLE_KEY4(entry), key4);\n\t\tREG_WRITE(ah, AR_KEYTABLE_TYPE(entry), keyType);\n\n\t\tREGWRITE_BUFFER_FLUSH(ah);\n\n\t\t \n\t\t(void) ath_hw_keysetmac(common, entry, mac);\n\t}\n\n\treturn true;\n}\n\nstatic int ath_setkey_tkip(struct ath_common *common, u16 keyix, const u8 *key,\n\t\t\t   struct ath_keyval *hk, const u8 *addr,\n\t\t\t   bool authenticator)\n{\n\tconst u8 *key_rxmic;\n\tconst u8 *key_txmic;\n\n\tkey_txmic = key + NL80211_TKIP_DATA_OFFSET_TX_MIC_KEY;\n\tkey_rxmic = key + NL80211_TKIP_DATA_OFFSET_RX_MIC_KEY;\n\n\tif (addr == NULL) {\n\t\t \n\t\tif (authenticator) {\n\t\t\tmemcpy(hk->kv_mic, key_txmic, sizeof(hk->kv_mic));\n\t\t\tmemcpy(hk->kv_txmic, key_txmic, sizeof(hk->kv_mic));\n\t\t} else {\n\t\t\tmemcpy(hk->kv_mic, key_rxmic, sizeof(hk->kv_mic));\n\t\t\tmemcpy(hk->kv_txmic, key_rxmic, sizeof(hk->kv_mic));\n\t\t}\n\t\treturn ath_hw_set_keycache_entry(common, keyix, hk, addr);\n\t}\n\tif (common->crypt_caps & ATH_CRYPT_CAP_MIC_COMBINED) {\n\t\t \n\t\tmemcpy(hk->kv_mic, key_rxmic, sizeof(hk->kv_mic));\n\t\tmemcpy(hk->kv_txmic, key_txmic, sizeof(hk->kv_txmic));\n\t\treturn ath_hw_set_keycache_entry(common, keyix, hk, addr);\n\t}\n\n\t \n\n\t \n\tmemcpy(hk->kv_mic, key_txmic, sizeof(hk->kv_mic));\n\tif (!ath_hw_set_keycache_entry(common, keyix, hk, NULL)) {\n\t\t \n\t\tath_err(common, \"Setting TX MIC Key Failed\\n\");\n\t\treturn 0;\n\t}\n\n\tmemcpy(hk->kv_mic, key_rxmic, sizeof(hk->kv_mic));\n\t \n\treturn ath_hw_set_keycache_entry(common, keyix + 32, hk, addr);\n}\n\nstatic int ath_reserve_key_cache_slot_tkip(struct ath_common *common)\n{\n\tint i;\n\n\tfor (i = IEEE80211_WEP_NKID; i < common->keymax / 2; i++) {\n\t\tif (test_bit(i, common->keymap) ||\n\t\t    test_bit(i + 64, common->keymap))\n\t\t\tcontinue;  \n\t\tif (!(common->crypt_caps & ATH_CRYPT_CAP_MIC_COMBINED) &&\n\t\t    (test_bit(i + 32, common->keymap) ||\n\t\t     test_bit(i + 64 + 32, common->keymap)))\n\t\t\tcontinue;  \n\n\t\t \n\t\treturn i;\n\t}\n\treturn -1;\n}\n\nstatic int ath_reserve_key_cache_slot(struct ath_common *common,\n\t\t\t\t      u32 cipher)\n{\n\tint i;\n\n\tif (cipher == WLAN_CIPHER_SUITE_TKIP)\n\t\treturn ath_reserve_key_cache_slot_tkip(common);\n\n\t \n\tif (!(common->crypt_caps & ATH_CRYPT_CAP_MIC_COMBINED)) {\n\t\tfor (i = IEEE80211_WEP_NKID; i < common->keymax / 4; i++) {\n\t\t\tif (!test_bit(i, common->keymap) &&\n\t\t\t    (test_bit(i + 32, common->keymap) ||\n\t\t\t     test_bit(i + 64, common->keymap) ||\n\t\t\t     test_bit(i + 64 + 32, common->keymap)))\n\t\t\t\treturn i;\n\t\t\tif (!test_bit(i + 32, common->keymap) &&\n\t\t\t    (test_bit(i, common->keymap) ||\n\t\t\t     test_bit(i + 64, common->keymap) ||\n\t\t\t     test_bit(i + 64 + 32, common->keymap)))\n\t\t\t\treturn i + 32;\n\t\t\tif (!test_bit(i + 64, common->keymap) &&\n\t\t\t    (test_bit(i , common->keymap) ||\n\t\t\t     test_bit(i + 32, common->keymap) ||\n\t\t\t     test_bit(i + 64 + 32, common->keymap)))\n\t\t\t\treturn i + 64;\n\t\t\tif (!test_bit(i + 64 + 32, common->keymap) &&\n\t\t\t    (test_bit(i, common->keymap) ||\n\t\t\t     test_bit(i + 32, common->keymap) ||\n\t\t\t     test_bit(i + 64, common->keymap)))\n\t\t\t\treturn i + 64 + 32;\n\t\t}\n\t} else {\n\t\tfor (i = IEEE80211_WEP_NKID; i < common->keymax / 2; i++) {\n\t\t\tif (!test_bit(i, common->keymap) &&\n\t\t\t    test_bit(i + 64, common->keymap))\n\t\t\t\treturn i;\n\t\t\tif (test_bit(i, common->keymap) &&\n\t\t\t    !test_bit(i + 64, common->keymap))\n\t\t\t\treturn i + 64;\n\t\t}\n\t}\n\n\t \n\tfor (i = IEEE80211_WEP_NKID; i < common->keymax; i++) {\n\t\t \n\t\tif (i >= 64 && i < 64 + IEEE80211_WEP_NKID)\n\t\t\tcontinue;\n\t\tif (!(common->crypt_caps & ATH_CRYPT_CAP_MIC_COMBINED)) {\n\t\t\tif (i >= 32 && i < 32 + IEEE80211_WEP_NKID)\n\t\t\t\tcontinue;\n\t\t\tif (i >= 64 + 32 && i < 64 + 32 + IEEE80211_WEP_NKID)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (!test_bit(i, common->keymap))\n\t\t\treturn i;  \n\t}\n\n\t \n\treturn -1;\n}\n\n \nint ath_key_config(struct ath_common *common,\n\t\t\t  struct ieee80211_vif *vif,\n\t\t\t  struct ieee80211_sta *sta,\n\t\t\t  struct ieee80211_key_conf *key)\n{\n\tstruct ath_keyval hk;\n\tconst u8 *mac = NULL;\n\tu8 gmac[ETH_ALEN];\n\tint ret = 0;\n\tint idx;\n\n\tmemset(&hk, 0, sizeof(hk));\n\n\tswitch (key->cipher) {\n\tcase 0:\n\t\thk.kv_type = ATH_CIPHER_CLR;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\thk.kv_type = ATH_CIPHER_WEP;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\thk.kv_type = ATH_CIPHER_TKIP;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\thk.kv_type = ATH_CIPHER_AES_CCM;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\thk.kv_len = key->keylen;\n\tif (key->keylen)\n\t\tmemcpy(&hk.kv_values, key->key, key->keylen);\n\n\tif (!(key->flags & IEEE80211_KEY_FLAG_PAIRWISE)) {\n\t\tswitch (vif->type) {\n\t\tcase NL80211_IFTYPE_AP:\n\t\t\tmemcpy(gmac, vif->addr, ETH_ALEN);\n\t\t\tgmac[0] |= 0x01;\n\t\t\tmac = gmac;\n\t\t\tidx = ath_reserve_key_cache_slot(common, key->cipher);\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_ADHOC:\n\t\t\tif (!sta) {\n\t\t\t\tidx = key->keyidx;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(gmac, sta->addr, ETH_ALEN);\n\t\t\tgmac[0] |= 0x01;\n\t\t\tmac = gmac;\n\t\t\tidx = ath_reserve_key_cache_slot(common, key->cipher);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tidx = key->keyidx;\n\t\t\tbreak;\n\t\t}\n\t} else if (key->keyidx) {\n\t\tif (WARN_ON(!sta))\n\t\t\treturn -EOPNOTSUPP;\n\t\tmac = sta->addr;\n\n\t\tif (vif->type != NL80211_IFTYPE_AP) {\n\t\t\t \n\t\t\tidx = key->keyidx;\n\t\t} else\n\t\t\treturn -EIO;\n\t} else {\n\t\tif (WARN_ON(!sta))\n\t\t\treturn -EOPNOTSUPP;\n\t\tmac = sta->addr;\n\n\t\tidx = ath_reserve_key_cache_slot(common, key->cipher);\n\t}\n\n\tif (idx < 0)\n\t\treturn -ENOSPC;  \n\n\tif (key->cipher == WLAN_CIPHER_SUITE_TKIP)\n\t\tret = ath_setkey_tkip(common, idx, key->key, &hk, mac,\n\t\t\t\t      vif->type == NL80211_IFTYPE_AP);\n\telse\n\t\tret = ath_hw_set_keycache_entry(common, idx, &hk, mac);\n\n\tif (!ret)\n\t\treturn -EIO;\n\n\tset_bit(idx, common->keymap);\n\tif (key->cipher == WLAN_CIPHER_SUITE_CCMP)\n\t\tset_bit(idx, common->ccmp_keymap);\n\n\tif (key->cipher == WLAN_CIPHER_SUITE_TKIP) {\n\t\tset_bit(idx + 64, common->keymap);\n\t\tset_bit(idx, common->tkip_keymap);\n\t\tset_bit(idx + 64, common->tkip_keymap);\n\t\tif (!(common->crypt_caps & ATH_CRYPT_CAP_MIC_COMBINED)) {\n\t\t\tset_bit(idx + 32, common->keymap);\n\t\t\tset_bit(idx + 64 + 32, common->keymap);\n\t\t\tset_bit(idx + 32, common->tkip_keymap);\n\t\t\tset_bit(idx + 64 + 32, common->tkip_keymap);\n\t\t}\n\t}\n\n\treturn idx;\n}\nEXPORT_SYMBOL(ath_key_config);\n\n \nvoid ath_key_delete(struct ath_common *common, u8 hw_key_idx)\n{\n\t \n\tif (test_bit(hw_key_idx, common->ccmp_keymap) ||\n\t    test_bit(hw_key_idx, common->tkip_keymap))\n\t\tath_hw_keysetmac(common, hw_key_idx, NULL);\n\telse\n\t\tath_hw_keyreset(common, hw_key_idx);\n\tif (hw_key_idx < IEEE80211_WEP_NKID)\n\t\treturn;\n\n\tclear_bit(hw_key_idx, common->keymap);\n\tclear_bit(hw_key_idx, common->ccmp_keymap);\n\tif (!test_bit(hw_key_idx, common->tkip_keymap))\n\t\treturn;\n\n\tclear_bit(hw_key_idx + 64, common->keymap);\n\n\tclear_bit(hw_key_idx, common->tkip_keymap);\n\tclear_bit(hw_key_idx + 64, common->tkip_keymap);\n\n\tif (!(common->crypt_caps & ATH_CRYPT_CAP_MIC_COMBINED)) {\n\t\tath_hw_keyreset(common, hw_key_idx + 32);\n\t\tclear_bit(hw_key_idx + 32, common->keymap);\n\t\tclear_bit(hw_key_idx + 64 + 32, common->keymap);\n\n\t\tclear_bit(hw_key_idx + 32, common->tkip_keymap);\n\t\tclear_bit(hw_key_idx + 64 + 32, common->tkip_keymap);\n\t}\n}\nEXPORT_SYMBOL(ath_key_delete);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}