{
  "module_name": "peer.c",
  "hash_id": "ce932bcc69f76ff009df0aad0fa3b5d80fbe122579fcdff33cf37d503bcd37e7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath11k/peer.c",
  "human_readable_source": "\n \n\n#include \"core.h\"\n#include \"peer.h\"\n#include \"debug.h\"\n\nstatic struct ath11k_peer *ath11k_peer_find_list_by_id(struct ath11k_base *ab,\n\t\t\t\t\t\t       int peer_id)\n{\n\tstruct ath11k_peer *peer;\n\n\tlockdep_assert_held(&ab->base_lock);\n\n\tlist_for_each_entry(peer, &ab->peers, list) {\n\t\tif (peer->peer_id != peer_id)\n\t\t\tcontinue;\n\n\t\treturn peer;\n\t}\n\n\treturn NULL;\n}\n\nstruct ath11k_peer *ath11k_peer_find(struct ath11k_base *ab, int vdev_id,\n\t\t\t\t     const u8 *addr)\n{\n\tstruct ath11k_peer *peer;\n\n\tlockdep_assert_held(&ab->base_lock);\n\n\tlist_for_each_entry(peer, &ab->peers, list) {\n\t\tif (peer->vdev_id != vdev_id)\n\t\t\tcontinue;\n\t\tif (!ether_addr_equal(peer->addr, addr))\n\t\t\tcontinue;\n\n\t\treturn peer;\n\t}\n\n\treturn NULL;\n}\n\nstruct ath11k_peer *ath11k_peer_find_by_addr(struct ath11k_base *ab,\n\t\t\t\t\t     const u8 *addr)\n{\n\tstruct ath11k_peer *peer;\n\n\tlockdep_assert_held(&ab->base_lock);\n\n\tif (!ab->rhead_peer_addr)\n\t\treturn NULL;\n\n\tpeer = rhashtable_lookup_fast(ab->rhead_peer_addr, addr,\n\t\t\t\t      ab->rhash_peer_addr_param);\n\n\treturn peer;\n}\n\nstruct ath11k_peer *ath11k_peer_find_by_id(struct ath11k_base *ab,\n\t\t\t\t\t   int peer_id)\n{\n\tstruct ath11k_peer *peer;\n\n\tlockdep_assert_held(&ab->base_lock);\n\n\tif (!ab->rhead_peer_id)\n\t\treturn NULL;\n\n\tpeer = rhashtable_lookup_fast(ab->rhead_peer_id, &peer_id,\n\t\t\t\t      ab->rhash_peer_id_param);\n\n\treturn peer;\n}\n\nstruct ath11k_peer *ath11k_peer_find_by_vdev_id(struct ath11k_base *ab,\n\t\t\t\t\t\tint vdev_id)\n{\n\tstruct ath11k_peer *peer;\n\n\tspin_lock_bh(&ab->base_lock);\n\n\tlist_for_each_entry(peer, &ab->peers, list) {\n\t\tif (vdev_id == peer->vdev_id) {\n\t\t\tspin_unlock_bh(&ab->base_lock);\n\t\t\treturn peer;\n\t\t}\n\t}\n\tspin_unlock_bh(&ab->base_lock);\n\treturn NULL;\n}\n\nvoid ath11k_peer_unmap_event(struct ath11k_base *ab, u16 peer_id)\n{\n\tstruct ath11k_peer *peer;\n\n\tspin_lock_bh(&ab->base_lock);\n\n\tpeer = ath11k_peer_find_list_by_id(ab, peer_id);\n\tif (!peer) {\n\t\tath11k_warn(ab, \"peer-unmap-event: unknown peer id %d\\n\",\n\t\t\t    peer_id);\n\t\tgoto exit;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_DP_HTT, \"peer unmap vdev %d peer %pM id %d\\n\",\n\t\t   peer->vdev_id, peer->addr, peer_id);\n\n\tlist_del(&peer->list);\n\tkfree(peer);\n\twake_up(&ab->peer_mapping_wq);\n\nexit:\n\tspin_unlock_bh(&ab->base_lock);\n}\n\nvoid ath11k_peer_map_event(struct ath11k_base *ab, u8 vdev_id, u16 peer_id,\n\t\t\t   u8 *mac_addr, u16 ast_hash, u16 hw_peer_id)\n{\n\tstruct ath11k_peer *peer;\n\n\tspin_lock_bh(&ab->base_lock);\n\tpeer = ath11k_peer_find(ab, vdev_id, mac_addr);\n\tif (!peer) {\n\t\tpeer = kzalloc(sizeof(*peer), GFP_ATOMIC);\n\t\tif (!peer)\n\t\t\tgoto exit;\n\n\t\tpeer->vdev_id = vdev_id;\n\t\tpeer->peer_id = peer_id;\n\t\tpeer->ast_hash = ast_hash;\n\t\tpeer->hw_peer_id = hw_peer_id;\n\t\tether_addr_copy(peer->addr, mac_addr);\n\t\tlist_add(&peer->list, &ab->peers);\n\t\twake_up(&ab->peer_mapping_wq);\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_DP_HTT, \"peer map vdev %d peer %pM id %d\\n\",\n\t\t   vdev_id, mac_addr, peer_id);\n\nexit:\n\tspin_unlock_bh(&ab->base_lock);\n}\n\nstatic int ath11k_wait_for_peer_common(struct ath11k_base *ab, int vdev_id,\n\t\t\t\t       const u8 *addr, bool expect_mapped)\n{\n\tint ret;\n\n\tret = wait_event_timeout(ab->peer_mapping_wq, ({\n\t\t\t\tbool mapped;\n\n\t\t\t\tspin_lock_bh(&ab->base_lock);\n\t\t\t\tmapped = !!ath11k_peer_find(ab, vdev_id, addr);\n\t\t\t\tspin_unlock_bh(&ab->base_lock);\n\n\t\t\t\t(mapped == expect_mapped ||\n\t\t\t\t test_bit(ATH11K_FLAG_CRASH_FLUSH, &ab->dev_flags));\n\t\t\t\t}), 3 * HZ);\n\n\tif (ret <= 0)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic inline int ath11k_peer_rhash_insert(struct ath11k_base *ab,\n\t\t\t\t\t   struct rhashtable *rtbl,\n\t\t\t\t\t   struct rhash_head *rhead,\n\t\t\t\t\t   struct rhashtable_params *params,\n\t\t\t\t\t   void *key)\n{\n\tstruct ath11k_peer *tmp;\n\n\tlockdep_assert_held(&ab->tbl_mtx_lock);\n\n\ttmp = rhashtable_lookup_get_insert_fast(rtbl, rhead, *params);\n\n\tif (!tmp)\n\t\treturn 0;\n\telse if (IS_ERR(tmp))\n\t\treturn PTR_ERR(tmp);\n\telse\n\t\treturn -EEXIST;\n}\n\nstatic inline int ath11k_peer_rhash_remove(struct ath11k_base *ab,\n\t\t\t\t\t   struct rhashtable *rtbl,\n\t\t\t\t\t   struct rhash_head *rhead,\n\t\t\t\t\t   struct rhashtable_params *params)\n{\n\tint ret;\n\n\tlockdep_assert_held(&ab->tbl_mtx_lock);\n\n\tret = rhashtable_remove_fast(rtbl, rhead, *params);\n\tif (ret && ret != -ENOENT)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int ath11k_peer_rhash_add(struct ath11k_base *ab, struct ath11k_peer *peer)\n{\n\tint ret;\n\n\tlockdep_assert_held(&ab->base_lock);\n\tlockdep_assert_held(&ab->tbl_mtx_lock);\n\n\tif (!ab->rhead_peer_id || !ab->rhead_peer_addr)\n\t\treturn -EPERM;\n\n\tret = ath11k_peer_rhash_insert(ab, ab->rhead_peer_id, &peer->rhash_id,\n\t\t\t\t       &ab->rhash_peer_id_param, &peer->peer_id);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to add peer %pM with id %d in rhash_id ret %d\\n\",\n\t\t\t    peer->addr, peer->peer_id, ret);\n\t\treturn ret;\n\t}\n\n\tret = ath11k_peer_rhash_insert(ab, ab->rhead_peer_addr, &peer->rhash_addr,\n\t\t\t\t       &ab->rhash_peer_addr_param, &peer->addr);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to add peer %pM with id %d in rhash_addr ret %d\\n\",\n\t\t\t    peer->addr, peer->peer_id, ret);\n\t\tgoto err_clean;\n\t}\n\n\treturn 0;\n\nerr_clean:\n\tath11k_peer_rhash_remove(ab, ab->rhead_peer_id, &peer->rhash_id,\n\t\t\t\t &ab->rhash_peer_id_param);\n\treturn ret;\n}\n\nvoid ath11k_peer_cleanup(struct ath11k *ar, u32 vdev_id)\n{\n\tstruct ath11k_peer *peer, *tmp;\n\tstruct ath11k_base *ab = ar->ab;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tmutex_lock(&ab->tbl_mtx_lock);\n\tspin_lock_bh(&ab->base_lock);\n\tlist_for_each_entry_safe(peer, tmp, &ab->peers, list) {\n\t\tif (peer->vdev_id != vdev_id)\n\t\t\tcontinue;\n\n\t\tath11k_warn(ab, \"removing stale peer %pM from vdev_id %d\\n\",\n\t\t\t    peer->addr, vdev_id);\n\n\t\tath11k_peer_rhash_delete(ab, peer);\n\t\tlist_del(&peer->list);\n\t\tkfree(peer);\n\t\tar->num_peers--;\n\t}\n\n\tspin_unlock_bh(&ab->base_lock);\n\tmutex_unlock(&ab->tbl_mtx_lock);\n}\n\nstatic int ath11k_wait_for_peer_deleted(struct ath11k *ar, int vdev_id, const u8 *addr)\n{\n\treturn ath11k_wait_for_peer_common(ar->ab, vdev_id, addr, false);\n}\n\nint ath11k_wait_for_peer_delete_done(struct ath11k *ar, u32 vdev_id,\n\t\t\t\t     const u8 *addr)\n{\n\tint ret;\n\tunsigned long time_left;\n\n\tret = ath11k_wait_for_peer_deleted(ar, vdev_id, addr);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed wait for peer deleted\");\n\t\treturn ret;\n\t}\n\n\ttime_left = wait_for_completion_timeout(&ar->peer_delete_done,\n\t\t\t\t\t\t3 * HZ);\n\tif (time_left == 0) {\n\t\tath11k_warn(ar->ab, \"Timeout in receiving peer delete response\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic int __ath11k_peer_delete(struct ath11k *ar, u32 vdev_id, const u8 *addr)\n{\n\tint ret;\n\tstruct ath11k_peer *peer;\n\tstruct ath11k_base *ab = ar->ab;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tmutex_lock(&ab->tbl_mtx_lock);\n\tspin_lock_bh(&ab->base_lock);\n\n\tpeer = ath11k_peer_find_by_addr(ab, addr);\n\t \n\tif (peer && peer->vdev_id == vdev_id)\n\t\tath11k_peer_rhash_delete(ab, peer);\n\n\t \n\tif (!peer)\n\t\tpeer = ath11k_peer_find(ab, vdev_id, addr);\n\n\tif (!peer) {\n\t\tspin_unlock_bh(&ab->base_lock);\n\t\tmutex_unlock(&ab->tbl_mtx_lock);\n\n\t\tath11k_warn(ab,\n\t\t\t    \"failed to find peer vdev_id %d addr %pM in delete\\n\",\n\t\t\t    vdev_id, addr);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_unlock_bh(&ab->base_lock);\n\tmutex_unlock(&ab->tbl_mtx_lock);\n\n\treinit_completion(&ar->peer_delete_done);\n\n\tret = ath11k_wmi_send_peer_delete_cmd(ar, addr, vdev_id);\n\tif (ret) {\n\t\tath11k_warn(ab,\n\t\t\t    \"failed to delete peer vdev_id %d addr %pM ret %d\\n\",\n\t\t\t    vdev_id, addr, ret);\n\t\treturn ret;\n\t}\n\n\tret = ath11k_wait_for_peer_delete_done(ar, vdev_id, addr);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nint ath11k_peer_delete(struct ath11k *ar, u32 vdev_id, u8 *addr)\n{\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tret = __ath11k_peer_delete(ar, vdev_id, addr);\n\tif (ret)\n\t\treturn ret;\n\n\tar->num_peers--;\n\n\treturn 0;\n}\n\nstatic int ath11k_wait_for_peer_created(struct ath11k *ar, int vdev_id, const u8 *addr)\n{\n\treturn ath11k_wait_for_peer_common(ar->ab, vdev_id, addr, true);\n}\n\nint ath11k_peer_create(struct ath11k *ar, struct ath11k_vif *arvif,\n\t\t       struct ieee80211_sta *sta, struct peer_create_params *param)\n{\n\tstruct ath11k_peer *peer;\n\tstruct ath11k_sta *arsta;\n\tint ret, fbret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (ar->num_peers > (ar->max_num_peers - 1)) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to create peer due to insufficient peer entry resource in firmware\\n\");\n\t\treturn -ENOBUFS;\n\t}\n\n\tmutex_lock(&ar->ab->tbl_mtx_lock);\n\tspin_lock_bh(&ar->ab->base_lock);\n\tpeer = ath11k_peer_find_by_addr(ar->ab, param->peer_addr);\n\tif (peer) {\n\t\tif (peer->vdev_id == param->vdev_id) {\n\t\t\tspin_unlock_bh(&ar->ab->base_lock);\n\t\t\tmutex_unlock(&ar->ab->tbl_mtx_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tath11k_peer_rhash_delete(ar->ab, peer);\n\t}\n\tspin_unlock_bh(&ar->ab->base_lock);\n\tmutex_unlock(&ar->ab->tbl_mtx_lock);\n\n\tret = ath11k_wmi_send_peer_create_cmd(ar, param);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to send peer create vdev_id %d ret %d\\n\",\n\t\t\t    param->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\tret = ath11k_wait_for_peer_created(ar, param->vdev_id,\n\t\t\t\t\t   param->peer_addr);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&ar->ab->tbl_mtx_lock);\n\tspin_lock_bh(&ar->ab->base_lock);\n\n\tpeer = ath11k_peer_find(ar->ab, param->vdev_id, param->peer_addr);\n\tif (!peer) {\n\t\tspin_unlock_bh(&ar->ab->base_lock);\n\t\tmutex_unlock(&ar->ab->tbl_mtx_lock);\n\t\tath11k_warn(ar->ab, \"failed to find peer %pM on vdev %i after creation\\n\",\n\t\t\t    param->peer_addr, param->vdev_id);\n\n\t\tret = -ENOENT;\n\t\tgoto cleanup;\n\t}\n\n\tret = ath11k_peer_rhash_add(ar->ab, peer);\n\tif (ret) {\n\t\tspin_unlock_bh(&ar->ab->base_lock);\n\t\tmutex_unlock(&ar->ab->tbl_mtx_lock);\n\t\tgoto cleanup;\n\t}\n\n\tpeer->pdev_idx = ar->pdev_idx;\n\tpeer->sta = sta;\n\n\tif (arvif->vif->type == NL80211_IFTYPE_STATION) {\n\t\tarvif->ast_hash = peer->ast_hash;\n\t\tarvif->ast_idx = peer->hw_peer_id;\n\t}\n\n\tpeer->sec_type = HAL_ENCRYPT_TYPE_OPEN;\n\tpeer->sec_type_grp = HAL_ENCRYPT_TYPE_OPEN;\n\n\tif (sta) {\n\t\tarsta = (struct ath11k_sta *)sta->drv_priv;\n\t\tarsta->tcl_metadata |= FIELD_PREP(HTT_TCL_META_DATA_TYPE, 0) |\n\t\t\t\t       FIELD_PREP(HTT_TCL_META_DATA_PEER_ID,\n\t\t\t\t\t\t  peer->peer_id);\n\n\t\t \n\t\tarsta->tcl_metadata &= ~HTT_TCL_META_DATA_VALID_HTT;\n\t}\n\n\tar->num_peers++;\n\n\tspin_unlock_bh(&ar->ab->base_lock);\n\tmutex_unlock(&ar->ab->tbl_mtx_lock);\n\n\treturn 0;\n\ncleanup:\n\tfbret = __ath11k_peer_delete(ar, param->vdev_id, param->peer_addr);\n\tif (fbret)\n\t\tath11k_warn(ar->ab, \"failed peer %pM delete vdev_id %d fallback ret %d\\n\",\n\t\t\t    param->peer_addr, param->vdev_id, fbret);\n\n\treturn ret;\n}\n\nint ath11k_peer_rhash_delete(struct ath11k_base *ab, struct ath11k_peer *peer)\n{\n\tint ret;\n\n\tlockdep_assert_held(&ab->base_lock);\n\tlockdep_assert_held(&ab->tbl_mtx_lock);\n\n\tif (!ab->rhead_peer_id || !ab->rhead_peer_addr)\n\t\treturn -EPERM;\n\n\tret = ath11k_peer_rhash_remove(ab, ab->rhead_peer_addr, &peer->rhash_addr,\n\t\t\t\t       &ab->rhash_peer_addr_param);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to remove peer %pM id %d in rhash_addr ret %d\\n\",\n\t\t\t    peer->addr, peer->peer_id, ret);\n\t\treturn ret;\n\t}\n\n\tret = ath11k_peer_rhash_remove(ab, ab->rhead_peer_id, &peer->rhash_id,\n\t\t\t\t       &ab->rhash_peer_id_param);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to remove peer %pM id %d in rhash_id ret %d\\n\",\n\t\t\t    peer->addr, peer->peer_id, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath11k_peer_rhash_id_tbl_init(struct ath11k_base *ab)\n{\n\tstruct rhashtable_params *param;\n\tstruct rhashtable *rhash_id_tbl;\n\tint ret;\n\tsize_t size;\n\n\tlockdep_assert_held(&ab->tbl_mtx_lock);\n\n\tif (ab->rhead_peer_id)\n\t\treturn 0;\n\n\tsize = sizeof(*ab->rhead_peer_id);\n\trhash_id_tbl = kzalloc(size, GFP_KERNEL);\n\tif (!rhash_id_tbl) {\n\t\tath11k_warn(ab, \"failed to init rhash id table due to no mem (size %zu)\\n\",\n\t\t\t    size);\n\t\treturn -ENOMEM;\n\t}\n\n\tparam = &ab->rhash_peer_id_param;\n\n\tparam->key_offset = offsetof(struct ath11k_peer, peer_id);\n\tparam->head_offset = offsetof(struct ath11k_peer, rhash_id);\n\tparam->key_len = sizeof_field(struct ath11k_peer, peer_id);\n\tparam->automatic_shrinking = true;\n\tparam->nelem_hint = ab->num_radios * TARGET_NUM_PEERS_PDEV(ab);\n\n\tret = rhashtable_init(rhash_id_tbl, param);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to init peer id rhash table %d\\n\", ret);\n\t\tgoto err_free;\n\t}\n\n\tspin_lock_bh(&ab->base_lock);\n\n\tif (!ab->rhead_peer_id) {\n\t\tab->rhead_peer_id = rhash_id_tbl;\n\t} else {\n\t\tspin_unlock_bh(&ab->base_lock);\n\t\tgoto cleanup_tbl;\n\t}\n\n\tspin_unlock_bh(&ab->base_lock);\n\n\treturn 0;\n\ncleanup_tbl:\n\trhashtable_destroy(rhash_id_tbl);\nerr_free:\n\tkfree(rhash_id_tbl);\n\n\treturn ret;\n}\n\nstatic int ath11k_peer_rhash_addr_tbl_init(struct ath11k_base *ab)\n{\n\tstruct rhashtable_params *param;\n\tstruct rhashtable *rhash_addr_tbl;\n\tint ret;\n\tsize_t size;\n\n\tlockdep_assert_held(&ab->tbl_mtx_lock);\n\n\tif (ab->rhead_peer_addr)\n\t\treturn 0;\n\n\tsize = sizeof(*ab->rhead_peer_addr);\n\trhash_addr_tbl = kzalloc(size, GFP_KERNEL);\n\tif (!rhash_addr_tbl) {\n\t\tath11k_warn(ab, \"failed to init rhash addr table due to no mem (size %zu)\\n\",\n\t\t\t    size);\n\t\treturn -ENOMEM;\n\t}\n\n\tparam = &ab->rhash_peer_addr_param;\n\n\tparam->key_offset = offsetof(struct ath11k_peer, addr);\n\tparam->head_offset = offsetof(struct ath11k_peer, rhash_addr);\n\tparam->key_len = sizeof_field(struct ath11k_peer, addr);\n\tparam->automatic_shrinking = true;\n\tparam->nelem_hint = ab->num_radios * TARGET_NUM_PEERS_PDEV(ab);\n\n\tret = rhashtable_init(rhash_addr_tbl, param);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to init peer addr rhash table %d\\n\", ret);\n\t\tgoto err_free;\n\t}\n\n\tspin_lock_bh(&ab->base_lock);\n\n\tif (!ab->rhead_peer_addr) {\n\t\tab->rhead_peer_addr = rhash_addr_tbl;\n\t} else {\n\t\tspin_unlock_bh(&ab->base_lock);\n\t\tgoto cleanup_tbl;\n\t}\n\n\tspin_unlock_bh(&ab->base_lock);\n\n\treturn 0;\n\ncleanup_tbl:\n\trhashtable_destroy(rhash_addr_tbl);\nerr_free:\n\tkfree(rhash_addr_tbl);\n\n\treturn ret;\n}\n\nstatic inline void ath11k_peer_rhash_id_tbl_destroy(struct ath11k_base *ab)\n{\n\tlockdep_assert_held(&ab->tbl_mtx_lock);\n\n\tif (!ab->rhead_peer_id)\n\t\treturn;\n\n\trhashtable_destroy(ab->rhead_peer_id);\n\tkfree(ab->rhead_peer_id);\n\tab->rhead_peer_id = NULL;\n}\n\nstatic inline void ath11k_peer_rhash_addr_tbl_destroy(struct ath11k_base *ab)\n{\n\tlockdep_assert_held(&ab->tbl_mtx_lock);\n\n\tif (!ab->rhead_peer_addr)\n\t\treturn;\n\n\trhashtable_destroy(ab->rhead_peer_addr);\n\tkfree(ab->rhead_peer_addr);\n\tab->rhead_peer_addr = NULL;\n}\n\nint ath11k_peer_rhash_tbl_init(struct ath11k_base *ab)\n{\n\tint ret;\n\n\tmutex_lock(&ab->tbl_mtx_lock);\n\n\tret = ath11k_peer_rhash_id_tbl_init(ab);\n\tif (ret)\n\t\tgoto out;\n\n\tret = ath11k_peer_rhash_addr_tbl_init(ab);\n\tif (ret)\n\t\tgoto cleanup_tbl;\n\n\tmutex_unlock(&ab->tbl_mtx_lock);\n\n\treturn 0;\n\ncleanup_tbl:\n\tath11k_peer_rhash_id_tbl_destroy(ab);\nout:\n\tmutex_unlock(&ab->tbl_mtx_lock);\n\treturn ret;\n}\n\nvoid ath11k_peer_rhash_tbl_destroy(struct ath11k_base *ab)\n{\n\tmutex_lock(&ab->tbl_mtx_lock);\n\n\tath11k_peer_rhash_addr_tbl_destroy(ab);\n\tath11k_peer_rhash_id_tbl_destroy(ab);\n\n\tmutex_unlock(&ab->tbl_mtx_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}