{
  "module_name": "mac.c",
  "hash_id": "bdd298da8e7b323b6d29262f2cadb31925efcbc016d55c1b5f99e8ba52c52990",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath11k/mac.c",
  "human_readable_source": "\n \n\n#include <net/mac80211.h>\n#include <linux/etherdevice.h>\n#include <linux/bitfield.h>\n#include <linux/inetdevice.h>\n#include <net/if_inet6.h>\n#include <net/ipv6.h>\n\n#include \"mac.h\"\n#include \"core.h\"\n#include \"debug.h\"\n#include \"wmi.h\"\n#include \"hw.h\"\n#include \"dp_tx.h\"\n#include \"dp_rx.h\"\n#include \"testmode.h\"\n#include \"peer.h\"\n#include \"debugfs_sta.h\"\n#include \"hif.h\"\n#include \"wow.h\"\n\n#define CHAN2G(_channel, _freq, _flags) { \\\n\t.band                   = NL80211_BAND_2GHZ, \\\n\t.hw_value               = (_channel), \\\n\t.center_freq            = (_freq), \\\n\t.flags                  = (_flags), \\\n\t.max_antenna_gain       = 0, \\\n\t.max_power              = 30, \\\n}\n\n#define CHAN5G(_channel, _freq, _flags) { \\\n\t.band                   = NL80211_BAND_5GHZ, \\\n\t.hw_value               = (_channel), \\\n\t.center_freq            = (_freq), \\\n\t.flags                  = (_flags), \\\n\t.max_antenna_gain       = 0, \\\n\t.max_power              = 30, \\\n}\n\n#define CHAN6G(_channel, _freq, _flags) { \\\n\t.band                   = NL80211_BAND_6GHZ, \\\n\t.hw_value               = (_channel), \\\n\t.center_freq            = (_freq), \\\n\t.flags                  = (_flags), \\\n\t.max_antenna_gain       = 0, \\\n\t.max_power              = 30, \\\n}\n\nstatic const struct ieee80211_channel ath11k_2ghz_channels[] = {\n\tCHAN2G(1, 2412, 0),\n\tCHAN2G(2, 2417, 0),\n\tCHAN2G(3, 2422, 0),\n\tCHAN2G(4, 2427, 0),\n\tCHAN2G(5, 2432, 0),\n\tCHAN2G(6, 2437, 0),\n\tCHAN2G(7, 2442, 0),\n\tCHAN2G(8, 2447, 0),\n\tCHAN2G(9, 2452, 0),\n\tCHAN2G(10, 2457, 0),\n\tCHAN2G(11, 2462, 0),\n\tCHAN2G(12, 2467, 0),\n\tCHAN2G(13, 2472, 0),\n\tCHAN2G(14, 2484, 0),\n};\n\nstatic const struct ieee80211_channel ath11k_5ghz_channels[] = {\n\tCHAN5G(36, 5180, 0),\n\tCHAN5G(40, 5200, 0),\n\tCHAN5G(44, 5220, 0),\n\tCHAN5G(48, 5240, 0),\n\tCHAN5G(52, 5260, 0),\n\tCHAN5G(56, 5280, 0),\n\tCHAN5G(60, 5300, 0),\n\tCHAN5G(64, 5320, 0),\n\tCHAN5G(100, 5500, 0),\n\tCHAN5G(104, 5520, 0),\n\tCHAN5G(108, 5540, 0),\n\tCHAN5G(112, 5560, 0),\n\tCHAN5G(116, 5580, 0),\n\tCHAN5G(120, 5600, 0),\n\tCHAN5G(124, 5620, 0),\n\tCHAN5G(128, 5640, 0),\n\tCHAN5G(132, 5660, 0),\n\tCHAN5G(136, 5680, 0),\n\tCHAN5G(140, 5700, 0),\n\tCHAN5G(144, 5720, 0),\n\tCHAN5G(149, 5745, 0),\n\tCHAN5G(153, 5765, 0),\n\tCHAN5G(157, 5785, 0),\n\tCHAN5G(161, 5805, 0),\n\tCHAN5G(165, 5825, 0),\n\tCHAN5G(169, 5845, 0),\n\tCHAN5G(173, 5865, 0),\n\tCHAN5G(177, 5885, 0),\n};\n\nstatic const struct ieee80211_channel ath11k_6ghz_channels[] = {\n\tCHAN6G(1, 5955, 0),\n\tCHAN6G(5, 5975, 0),\n\tCHAN6G(9, 5995, 0),\n\tCHAN6G(13, 6015, 0),\n\tCHAN6G(17, 6035, 0),\n\tCHAN6G(21, 6055, 0),\n\tCHAN6G(25, 6075, 0),\n\tCHAN6G(29, 6095, 0),\n\tCHAN6G(33, 6115, 0),\n\tCHAN6G(37, 6135, 0),\n\tCHAN6G(41, 6155, 0),\n\tCHAN6G(45, 6175, 0),\n\tCHAN6G(49, 6195, 0),\n\tCHAN6G(53, 6215, 0),\n\tCHAN6G(57, 6235, 0),\n\tCHAN6G(61, 6255, 0),\n\tCHAN6G(65, 6275, 0),\n\tCHAN6G(69, 6295, 0),\n\tCHAN6G(73, 6315, 0),\n\tCHAN6G(77, 6335, 0),\n\tCHAN6G(81, 6355, 0),\n\tCHAN6G(85, 6375, 0),\n\tCHAN6G(89, 6395, 0),\n\tCHAN6G(93, 6415, 0),\n\tCHAN6G(97, 6435, 0),\n\tCHAN6G(101, 6455, 0),\n\tCHAN6G(105, 6475, 0),\n\tCHAN6G(109, 6495, 0),\n\tCHAN6G(113, 6515, 0),\n\tCHAN6G(117, 6535, 0),\n\tCHAN6G(121, 6555, 0),\n\tCHAN6G(125, 6575, 0),\n\tCHAN6G(129, 6595, 0),\n\tCHAN6G(133, 6615, 0),\n\tCHAN6G(137, 6635, 0),\n\tCHAN6G(141, 6655, 0),\n\tCHAN6G(145, 6675, 0),\n\tCHAN6G(149, 6695, 0),\n\tCHAN6G(153, 6715, 0),\n\tCHAN6G(157, 6735, 0),\n\tCHAN6G(161, 6755, 0),\n\tCHAN6G(165, 6775, 0),\n\tCHAN6G(169, 6795, 0),\n\tCHAN6G(173, 6815, 0),\n\tCHAN6G(177, 6835, 0),\n\tCHAN6G(181, 6855, 0),\n\tCHAN6G(185, 6875, 0),\n\tCHAN6G(189, 6895, 0),\n\tCHAN6G(193, 6915, 0),\n\tCHAN6G(197, 6935, 0),\n\tCHAN6G(201, 6955, 0),\n\tCHAN6G(205, 6975, 0),\n\tCHAN6G(209, 6995, 0),\n\tCHAN6G(213, 7015, 0),\n\tCHAN6G(217, 7035, 0),\n\tCHAN6G(221, 7055, 0),\n\tCHAN6G(225, 7075, 0),\n\tCHAN6G(229, 7095, 0),\n\tCHAN6G(233, 7115, 0),\n\n\t \n\tCHAN6G(2, 5935, 0),\n};\n\nstatic struct ieee80211_rate ath11k_legacy_rates[] = {\n\t{ .bitrate = 10,\n\t  .hw_value = ATH11K_HW_RATE_CCK_LP_1M },\n\t{ .bitrate = 20,\n\t  .hw_value = ATH11K_HW_RATE_CCK_LP_2M,\n\t  .hw_value_short = ATH11K_HW_RATE_CCK_SP_2M,\n\t  .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 55,\n\t  .hw_value = ATH11K_HW_RATE_CCK_LP_5_5M,\n\t  .hw_value_short = ATH11K_HW_RATE_CCK_SP_5_5M,\n\t  .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 110,\n\t  .hw_value = ATH11K_HW_RATE_CCK_LP_11M,\n\t  .hw_value_short = ATH11K_HW_RATE_CCK_SP_11M,\n\t  .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\n\t{ .bitrate = 60, .hw_value = ATH11K_HW_RATE_OFDM_6M },\n\t{ .bitrate = 90, .hw_value = ATH11K_HW_RATE_OFDM_9M },\n\t{ .bitrate = 120, .hw_value = ATH11K_HW_RATE_OFDM_12M },\n\t{ .bitrate = 180, .hw_value = ATH11K_HW_RATE_OFDM_18M },\n\t{ .bitrate = 240, .hw_value = ATH11K_HW_RATE_OFDM_24M },\n\t{ .bitrate = 360, .hw_value = ATH11K_HW_RATE_OFDM_36M },\n\t{ .bitrate = 480, .hw_value = ATH11K_HW_RATE_OFDM_48M },\n\t{ .bitrate = 540, .hw_value = ATH11K_HW_RATE_OFDM_54M },\n};\n\nstatic const int\nath11k_phymodes[NUM_NL80211_BANDS][ATH11K_CHAN_WIDTH_NUM] = {\n\t[NL80211_BAND_2GHZ] = {\n\t\t\t[NL80211_CHAN_WIDTH_5] = MODE_UNKNOWN,\n\t\t\t[NL80211_CHAN_WIDTH_10] = MODE_UNKNOWN,\n\t\t\t[NL80211_CHAN_WIDTH_20_NOHT] = MODE_11AX_HE20_2G,\n\t\t\t[NL80211_CHAN_WIDTH_20] = MODE_11AX_HE20_2G,\n\t\t\t[NL80211_CHAN_WIDTH_40] = MODE_11AX_HE40_2G,\n\t\t\t[NL80211_CHAN_WIDTH_80] = MODE_11AX_HE80_2G,\n\t\t\t[NL80211_CHAN_WIDTH_80P80] = MODE_UNKNOWN,\n\t\t\t[NL80211_CHAN_WIDTH_160] = MODE_UNKNOWN,\n\t},\n\t[NL80211_BAND_5GHZ] = {\n\t\t\t[NL80211_CHAN_WIDTH_5] = MODE_UNKNOWN,\n\t\t\t[NL80211_CHAN_WIDTH_10] = MODE_UNKNOWN,\n\t\t\t[NL80211_CHAN_WIDTH_20_NOHT] = MODE_11AX_HE20,\n\t\t\t[NL80211_CHAN_WIDTH_20] = MODE_11AX_HE20,\n\t\t\t[NL80211_CHAN_WIDTH_40] = MODE_11AX_HE40,\n\t\t\t[NL80211_CHAN_WIDTH_80] = MODE_11AX_HE80,\n\t\t\t[NL80211_CHAN_WIDTH_160] = MODE_11AX_HE160,\n\t\t\t[NL80211_CHAN_WIDTH_80P80] = MODE_11AX_HE80_80,\n\t},\n\t[NL80211_BAND_6GHZ] = {\n\t\t\t[NL80211_CHAN_WIDTH_5] = MODE_UNKNOWN,\n\t\t\t[NL80211_CHAN_WIDTH_10] = MODE_UNKNOWN,\n\t\t\t[NL80211_CHAN_WIDTH_20_NOHT] = MODE_11AX_HE20,\n\t\t\t[NL80211_CHAN_WIDTH_20] = MODE_11AX_HE20,\n\t\t\t[NL80211_CHAN_WIDTH_40] = MODE_11AX_HE40,\n\t\t\t[NL80211_CHAN_WIDTH_80] = MODE_11AX_HE80,\n\t\t\t[NL80211_CHAN_WIDTH_160] = MODE_11AX_HE160,\n\t\t\t[NL80211_CHAN_WIDTH_80P80] = MODE_11AX_HE80_80,\n\t},\n\n};\n\nconst struct htt_rx_ring_tlv_filter ath11k_mac_mon_status_filter_default = {\n\t.rx_filter = HTT_RX_FILTER_TLV_FLAGS_MPDU_START |\n\t\t     HTT_RX_FILTER_TLV_FLAGS_PPDU_END |\n\t\t     HTT_RX_FILTER_TLV_FLAGS_PPDU_END_STATUS_DONE,\n\t.pkt_filter_flags0 = HTT_RX_FP_MGMT_FILTER_FLAGS0,\n\t.pkt_filter_flags1 = HTT_RX_FP_MGMT_FILTER_FLAGS1,\n\t.pkt_filter_flags2 = HTT_RX_FP_CTRL_FILTER_FLASG2,\n\t.pkt_filter_flags3 = HTT_RX_FP_DATA_FILTER_FLASG3 |\n\t\t\t     HTT_RX_FP_CTRL_FILTER_FLASG3\n};\n\n#define ATH11K_MAC_FIRST_OFDM_RATE_IDX 4\n#define ath11k_g_rates ath11k_legacy_rates\n#define ath11k_g_rates_size (ARRAY_SIZE(ath11k_legacy_rates))\n#define ath11k_a_rates (ath11k_legacy_rates + 4)\n#define ath11k_a_rates_size (ARRAY_SIZE(ath11k_legacy_rates) - 4)\n\n#define ATH11K_MAC_SCAN_CMD_EVT_OVERHEAD\t\t200  \n\n \n#define ATH11K_SCAN_CHANNEL_SWITCH_WMI_EVT_OVERHEAD\t10  \n\nstatic const u32 ath11k_smps_map[] = {\n\t[WLAN_HT_CAP_SM_PS_STATIC] = WMI_PEER_SMPS_STATIC,\n\t[WLAN_HT_CAP_SM_PS_DYNAMIC] = WMI_PEER_SMPS_DYNAMIC,\n\t[WLAN_HT_CAP_SM_PS_INVALID] = WMI_PEER_SMPS_PS_NONE,\n\t[WLAN_HT_CAP_SM_PS_DISABLED] = WMI_PEER_SMPS_PS_NONE,\n};\n\nstatic int ath11k_start_vdev_delay(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif);\n\nenum nl80211_he_ru_alloc ath11k_mac_phy_he_ru_to_nl80211_he_ru_alloc(u16 ru_phy)\n{\n\tenum nl80211_he_ru_alloc ret;\n\n\tswitch (ru_phy) {\n\tcase RU_26:\n\t\tret = NL80211_RATE_INFO_HE_RU_ALLOC_26;\n\t\tbreak;\n\tcase RU_52:\n\t\tret = NL80211_RATE_INFO_HE_RU_ALLOC_52;\n\t\tbreak;\n\tcase RU_106:\n\t\tret = NL80211_RATE_INFO_HE_RU_ALLOC_106;\n\t\tbreak;\n\tcase RU_242:\n\t\tret = NL80211_RATE_INFO_HE_RU_ALLOC_242;\n\t\tbreak;\n\tcase RU_484:\n\t\tret = NL80211_RATE_INFO_HE_RU_ALLOC_484;\n\t\tbreak;\n\tcase RU_996:\n\t\tret = NL80211_RATE_INFO_HE_RU_ALLOC_996;\n\t\tbreak;\n\tdefault:\n\t\tret = NL80211_RATE_INFO_HE_RU_ALLOC_26;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nenum nl80211_he_ru_alloc ath11k_mac_he_ru_tones_to_nl80211_he_ru_alloc(u16 ru_tones)\n{\n\tenum nl80211_he_ru_alloc ret;\n\n\tswitch (ru_tones) {\n\tcase 26:\n\t\tret = NL80211_RATE_INFO_HE_RU_ALLOC_26;\n\t\tbreak;\n\tcase 52:\n\t\tret = NL80211_RATE_INFO_HE_RU_ALLOC_52;\n\t\tbreak;\n\tcase 106:\n\t\tret = NL80211_RATE_INFO_HE_RU_ALLOC_106;\n\t\tbreak;\n\tcase 242:\n\t\tret = NL80211_RATE_INFO_HE_RU_ALLOC_242;\n\t\tbreak;\n\tcase 484:\n\t\tret = NL80211_RATE_INFO_HE_RU_ALLOC_484;\n\t\tbreak;\n\tcase 996:\n\t\tret = NL80211_RATE_INFO_HE_RU_ALLOC_996;\n\t\tbreak;\n\tcase (996 * 2):\n\t\tret = NL80211_RATE_INFO_HE_RU_ALLOC_2x996;\n\t\tbreak;\n\tdefault:\n\t\tret = NL80211_RATE_INFO_HE_RU_ALLOC_26;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nenum nl80211_he_gi ath11k_mac_he_gi_to_nl80211_he_gi(u8 sgi)\n{\n\tenum nl80211_he_gi ret;\n\n\tswitch (sgi) {\n\tcase RX_MSDU_START_SGI_0_8_US:\n\t\tret = NL80211_RATE_INFO_HE_GI_0_8;\n\t\tbreak;\n\tcase RX_MSDU_START_SGI_1_6_US:\n\t\tret = NL80211_RATE_INFO_HE_GI_1_6;\n\t\tbreak;\n\tcase RX_MSDU_START_SGI_3_2_US:\n\t\tret = NL80211_RATE_INFO_HE_GI_3_2;\n\t\tbreak;\n\tdefault:\n\t\tret = NL80211_RATE_INFO_HE_GI_0_8;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nu8 ath11k_mac_bw_to_mac80211_bw(u8 bw)\n{\n\tu8 ret = 0;\n\n\tswitch (bw) {\n\tcase ATH11K_BW_20:\n\t\tret = RATE_INFO_BW_20;\n\t\tbreak;\n\tcase ATH11K_BW_40:\n\t\tret = RATE_INFO_BW_40;\n\t\tbreak;\n\tcase ATH11K_BW_80:\n\t\tret = RATE_INFO_BW_80;\n\t\tbreak;\n\tcase ATH11K_BW_160:\n\t\tret = RATE_INFO_BW_160;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nenum ath11k_supported_bw ath11k_mac_mac80211_bw_to_ath11k_bw(enum rate_info_bw bw)\n{\n\tswitch (bw) {\n\tcase RATE_INFO_BW_20:\n\t\treturn ATH11K_BW_20;\n\tcase RATE_INFO_BW_40:\n\t\treturn ATH11K_BW_40;\n\tcase RATE_INFO_BW_80:\n\t\treturn ATH11K_BW_80;\n\tcase RATE_INFO_BW_160:\n\t\treturn ATH11K_BW_160;\n\tdefault:\n\t\treturn ATH11K_BW_20;\n\t}\n}\n\nint ath11k_mac_hw_ratecode_to_legacy_rate(u8 hw_rc, u8 preamble, u8 *rateidx,\n\t\t\t\t\t  u16 *rate)\n{\n\t \n\tint i = ATH11K_MAC_FIRST_OFDM_RATE_IDX;\n\tint max_rates_idx = ath11k_g_rates_size;\n\n\tif (preamble == WMI_RATE_PREAMBLE_CCK) {\n\t\thw_rc &= ~ATH11k_HW_RATECODE_CCK_SHORT_PREAM_MASK;\n\t\ti = 0;\n\t\tmax_rates_idx = ATH11K_MAC_FIRST_OFDM_RATE_IDX;\n\t}\n\n\twhile (i < max_rates_idx) {\n\t\tif (hw_rc == ath11k_legacy_rates[i].hw_value) {\n\t\t\t*rateidx = i;\n\t\t\t*rate = ath11k_legacy_rates[i].bitrate;\n\t\t\treturn 0;\n\t\t}\n\t\ti++;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int get_num_chains(u32 mask)\n{\n\tint num_chains = 0;\n\n\twhile (mask) {\n\t\tif (mask & BIT(0))\n\t\t\tnum_chains++;\n\t\tmask >>= 1;\n\t}\n\n\treturn num_chains;\n}\n\nu8 ath11k_mac_bitrate_to_idx(const struct ieee80211_supported_band *sband,\n\t\t\t     u32 bitrate)\n{\n\tint i;\n\n\tfor (i = 0; i < sband->n_bitrates; i++)\n\t\tif (sband->bitrates[i].bitrate == bitrate)\n\t\t\treturn i;\n\n\treturn 0;\n}\n\nstatic u32\nath11k_mac_max_ht_nss(const u8 *ht_mcs_mask)\n{\n\tint nss;\n\n\tfor (nss = IEEE80211_HT_MCS_MASK_LEN - 1; nss >= 0; nss--)\n\t\tif (ht_mcs_mask[nss])\n\t\t\treturn nss + 1;\n\n\treturn 1;\n}\n\nstatic u32\nath11k_mac_max_vht_nss(const u16 *vht_mcs_mask)\n{\n\tint nss;\n\n\tfor (nss = NL80211_VHT_NSS_MAX - 1; nss >= 0; nss--)\n\t\tif (vht_mcs_mask[nss])\n\t\t\treturn nss + 1;\n\n\treturn 1;\n}\n\nstatic u32\nath11k_mac_max_he_nss(const u16 *he_mcs_mask)\n{\n\tint nss;\n\n\tfor (nss = NL80211_HE_NSS_MAX - 1; nss >= 0; nss--)\n\t\tif (he_mcs_mask[nss])\n\t\t\treturn nss + 1;\n\n\treturn 1;\n}\n\nstatic u8 ath11k_parse_mpdudensity(u8 mpdudensity)\n{\n \n\tswitch (mpdudensity) {\n\tcase 0:\n\t\treturn 0;\n\tcase 1:\n\tcase 2:\n\tcase 3:\n\t \n\t\treturn 1;\n\tcase 4:\n\t\treturn 2;\n\tcase 5:\n\t\treturn 4;\n\tcase 6:\n\t\treturn 8;\n\tcase 7:\n\t\treturn 16;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int ath11k_mac_vif_chan(struct ieee80211_vif *vif,\n\t\t\t       struct cfg80211_chan_def *def)\n{\n\tstruct ieee80211_chanctx_conf *conf;\n\n\trcu_read_lock();\n\tconf = rcu_dereference(vif->bss_conf.chanctx_conf);\n\tif (!conf) {\n\t\trcu_read_unlock();\n\t\treturn -ENOENT;\n\t}\n\n\t*def = conf->def;\n\trcu_read_unlock();\n\n\treturn 0;\n}\n\nstatic bool ath11k_mac_bitrate_is_cck(int bitrate)\n{\n\tswitch (bitrate) {\n\tcase 10:\n\tcase 20:\n\tcase 55:\n\tcase 110:\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nu8 ath11k_mac_hw_rate_to_idx(const struct ieee80211_supported_band *sband,\n\t\t\t     u8 hw_rate, bool cck)\n{\n\tconst struct ieee80211_rate *rate;\n\tint i;\n\n\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\trate = &sband->bitrates[i];\n\n\t\tif (ath11k_mac_bitrate_is_cck(rate->bitrate) != cck)\n\t\t\tcontinue;\n\n\t\tif (rate->hw_value == hw_rate)\n\t\t\treturn i;\n\t\telse if (rate->flags & IEEE80211_RATE_SHORT_PREAMBLE &&\n\t\t\t rate->hw_value_short == hw_rate)\n\t\t\treturn i;\n\t}\n\n\treturn 0;\n}\n\nstatic u8 ath11k_mac_bitrate_to_rate(int bitrate)\n{\n\treturn DIV_ROUND_UP(bitrate, 5) |\n\t       (ath11k_mac_bitrate_is_cck(bitrate) ? BIT(7) : 0);\n}\n\nstatic void ath11k_get_arvif_iter(void *data, u8 *mac,\n\t\t\t\t  struct ieee80211_vif *vif)\n{\n\tstruct ath11k_vif_iter *arvif_iter = data;\n\tstruct ath11k_vif *arvif = ath11k_vif_to_arvif(vif);\n\n\tif (arvif->vdev_id == arvif_iter->vdev_id)\n\t\tarvif_iter->arvif = arvif;\n}\n\nstruct ath11k_vif *ath11k_mac_get_arvif(struct ath11k *ar, u32 vdev_id)\n{\n\tstruct ath11k_vif_iter arvif_iter;\n\tu32 flags;\n\n\tmemset(&arvif_iter, 0, sizeof(struct ath11k_vif_iter));\n\tarvif_iter.vdev_id = vdev_id;\n\n\tflags = IEEE80211_IFACE_ITER_RESUME_ALL;\n\tieee80211_iterate_active_interfaces_atomic(ar->hw,\n\t\t\t\t\t\t   flags,\n\t\t\t\t\t\t   ath11k_get_arvif_iter,\n\t\t\t\t\t\t   &arvif_iter);\n\tif (!arvif_iter.arvif) {\n\t\tath11k_warn(ar->ab, \"No VIF found for vdev %d\\n\", vdev_id);\n\t\treturn NULL;\n\t}\n\n\treturn arvif_iter.arvif;\n}\n\nstruct ath11k_vif *ath11k_mac_get_arvif_by_vdev_id(struct ath11k_base *ab,\n\t\t\t\t\t\t   u32 vdev_id)\n{\n\tint i;\n\tstruct ath11k_pdev *pdev;\n\tstruct ath11k_vif *arvif;\n\n\tfor (i = 0; i < ab->num_radios; i++) {\n\t\tpdev = rcu_dereference(ab->pdevs_active[i]);\n\t\tif (pdev && pdev->ar &&\n\t\t    (pdev->ar->allocated_vdev_map & (1LL << vdev_id))) {\n\t\t\tarvif = ath11k_mac_get_arvif(pdev->ar, vdev_id);\n\t\t\tif (arvif)\n\t\t\t\treturn arvif;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstruct ath11k *ath11k_mac_get_ar_by_vdev_id(struct ath11k_base *ab, u32 vdev_id)\n{\n\tint i;\n\tstruct ath11k_pdev *pdev;\n\n\tfor (i = 0; i < ab->num_radios; i++) {\n\t\tpdev = rcu_dereference(ab->pdevs_active[i]);\n\t\tif (pdev && pdev->ar) {\n\t\t\tif (pdev->ar->allocated_vdev_map & (1LL << vdev_id))\n\t\t\t\treturn pdev->ar;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstruct ath11k *ath11k_mac_get_ar_by_pdev_id(struct ath11k_base *ab, u32 pdev_id)\n{\n\tint i;\n\tstruct ath11k_pdev *pdev;\n\n\tif (ab->hw_params.single_pdev_only) {\n\t\tpdev = rcu_dereference(ab->pdevs_active[0]);\n\t\treturn pdev ? pdev->ar : NULL;\n\t}\n\n\tif (WARN_ON(pdev_id > ab->num_radios))\n\t\treturn NULL;\n\n\tfor (i = 0; i < ab->num_radios; i++) {\n\t\tif (ab->fw_mode == ATH11K_FIRMWARE_MODE_FTM)\n\t\t\tpdev = &ab->pdevs[i];\n\t\telse\n\t\t\tpdev = rcu_dereference(ab->pdevs_active[i]);\n\n\t\tif (pdev && pdev->pdev_id == pdev_id)\n\t\t\treturn (pdev->ar ? pdev->ar : NULL);\n\t}\n\n\treturn NULL;\n}\n\nstruct ath11k_vif *ath11k_mac_get_vif_up(struct ath11k_base *ab)\n{\n\tstruct ath11k *ar;\n\tstruct ath11k_pdev *pdev;\n\tstruct ath11k_vif *arvif;\n\tint i;\n\n\tfor (i = 0; i < ab->num_radios; i++) {\n\t\tpdev = &ab->pdevs[i];\n\t\tar = pdev->ar;\n\t\tlist_for_each_entry(arvif, &ar->arvifs, list) {\n\t\t\tif (arvif->is_up)\n\t\t\t\treturn arvif;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic bool ath11k_mac_band_match(enum nl80211_band band1, enum WMI_HOST_WLAN_BAND band2)\n{\n\treturn (((band1 == NL80211_BAND_2GHZ) && (band2 & WMI_HOST_WLAN_2G_CAP)) ||\n\t\t(((band1 == NL80211_BAND_5GHZ) || (band1 == NL80211_BAND_6GHZ)) &&\n\t\t   (band2 & WMI_HOST_WLAN_5G_CAP)));\n}\n\nu8 ath11k_mac_get_target_pdev_id_from_vif(struct ath11k_vif *arvif)\n{\n\tstruct ath11k *ar = arvif->ar;\n\tstruct ath11k_base *ab = ar->ab;\n\tstruct ieee80211_vif *vif = arvif->vif;\n\tstruct cfg80211_chan_def def;\n\tenum nl80211_band band;\n\tu8 pdev_id = ab->target_pdev_ids[0].pdev_id;\n\tint i;\n\n\tif (WARN_ON(ath11k_mac_vif_chan(vif, &def)))\n\t\treturn pdev_id;\n\n\tband = def.chan->band;\n\n\tfor (i = 0; i < ab->target_pdev_count; i++) {\n\t\tif (ath11k_mac_band_match(band, ab->target_pdev_ids[i].supported_bands))\n\t\t\treturn ab->target_pdev_ids[i].pdev_id;\n\t}\n\n\treturn pdev_id;\n}\n\nu8 ath11k_mac_get_target_pdev_id(struct ath11k *ar)\n{\n\tstruct ath11k_vif *arvif;\n\n\tarvif = ath11k_mac_get_vif_up(ar->ab);\n\n\tif (arvif)\n\t\treturn ath11k_mac_get_target_pdev_id_from_vif(arvif);\n\telse\n\t\treturn ar->ab->target_pdev_ids[0].pdev_id;\n}\n\nstatic void ath11k_pdev_caps_update(struct ath11k *ar)\n{\n\tstruct ath11k_base *ab = ar->ab;\n\n\tar->max_tx_power = ab->target_caps.hw_max_tx_power;\n\n\t \n\tar->min_tx_power = 0;\n\n\tar->txpower_limit_2g = ar->max_tx_power;\n\tar->txpower_limit_5g = ar->max_tx_power;\n\tar->txpower_scale = WMI_HOST_TP_SCALE_MAX;\n}\n\nstatic int ath11k_mac_txpower_recalc(struct ath11k *ar)\n{\n\tstruct ath11k_pdev *pdev = ar->pdev;\n\tstruct ath11k_vif *arvif;\n\tint ret, txpower = -1;\n\tu32 param;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tlist_for_each_entry(arvif, &ar->arvifs, list) {\n\t\tif (arvif->txpower <= 0)\n\t\t\tcontinue;\n\n\t\tif (txpower == -1)\n\t\t\ttxpower = arvif->txpower;\n\t\telse\n\t\t\ttxpower = min(txpower, arvif->txpower);\n\t}\n\n\tif (txpower == -1)\n\t\treturn 0;\n\n\t \n\ttxpower = min_t(u32, max_t(u32, ar->min_tx_power, txpower),\n\t\t\tar->max_tx_power) * 2;\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_MAC, \"txpower to set in hw %d\\n\",\n\t\t   txpower / 2);\n\n\tif ((pdev->cap.supported_bands & WMI_HOST_WLAN_2G_CAP) &&\n\t    ar->txpower_limit_2g != txpower) {\n\t\tparam = WMI_PDEV_PARAM_TXPOWER_LIMIT2G;\n\t\tret = ath11k_wmi_pdev_set_param(ar, param,\n\t\t\t\t\t\ttxpower, ar->pdev->pdev_id);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t\tar->txpower_limit_2g = txpower;\n\t}\n\n\tif ((pdev->cap.supported_bands & WMI_HOST_WLAN_5G_CAP) &&\n\t    ar->txpower_limit_5g != txpower) {\n\t\tparam = WMI_PDEV_PARAM_TXPOWER_LIMIT5G;\n\t\tret = ath11k_wmi_pdev_set_param(ar, param,\n\t\t\t\t\t\ttxpower, ar->pdev->pdev_id);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t\tar->txpower_limit_5g = txpower;\n\t}\n\n\treturn 0;\n\nfail:\n\tath11k_warn(ar->ab, \"failed to recalc txpower limit %d using pdev param %d: %d\\n\",\n\t\t    txpower / 2, param, ret);\n\treturn ret;\n}\n\nstatic int ath11k_recalc_rtscts_prot(struct ath11k_vif *arvif)\n{\n\tstruct ath11k *ar = arvif->ar;\n\tu32 vdev_param, rts_cts = 0;\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tvdev_param = WMI_VDEV_PARAM_ENABLE_RTSCTS;\n\n\t \n\trts_cts = WMI_USE_RTS_CTS;\n\n\tif (arvif->num_legacy_stations > 0)\n\t\trts_cts |= WMI_RTSCTS_ACROSS_SW_RETRIES << 4;\n\telse\n\t\trts_cts |= WMI_RTSCTS_FOR_SECOND_RATESERIES << 4;\n\n\t \n\tif (arvif->rtscts_prot_mode == rts_cts)\n\t\treturn 0;\n\n\tarvif->rtscts_prot_mode = rts_cts;\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_MAC, \"vdev %d recalc rts/cts prot %d\\n\",\n\t\t   arvif->vdev_id, rts_cts);\n\n\tret =  ath11k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id,\n\t\t\t\t\t     vdev_param, rts_cts);\n\tif (ret)\n\t\tath11k_warn(ar->ab, \"failed to recalculate rts/cts prot for vdev %d: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\n\treturn ret;\n}\n\nstatic int ath11k_mac_set_kickout(struct ath11k_vif *arvif)\n{\n\tstruct ath11k *ar = arvif->ar;\n\tu32 param;\n\tint ret;\n\n\tret = ath11k_wmi_pdev_set_param(ar, WMI_PDEV_PARAM_STA_KICKOUT_TH,\n\t\t\t\t\tATH11K_KICKOUT_THRESHOLD,\n\t\t\t\t\tar->pdev->pdev_id);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to set kickout threshold on vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\tparam = WMI_VDEV_PARAM_AP_KEEPALIVE_MIN_IDLE_INACTIVE_TIME_SECS;\n\tret = ath11k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id, param,\n\t\t\t\t\t    ATH11K_KEEPALIVE_MIN_IDLE);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to set keepalive minimum idle time on vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\tparam = WMI_VDEV_PARAM_AP_KEEPALIVE_MAX_IDLE_INACTIVE_TIME_SECS;\n\tret = ath11k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id, param,\n\t\t\t\t\t    ATH11K_KEEPALIVE_MAX_IDLE);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to set keepalive maximum idle time on vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\tparam = WMI_VDEV_PARAM_AP_KEEPALIVE_MAX_UNRESPONSIVE_TIME_SECS;\n\tret = ath11k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id, param,\n\t\t\t\t\t    ATH11K_KEEPALIVE_MAX_UNRESPONSIVE);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to set keepalive maximum unresponsive time on vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nvoid ath11k_mac_peer_cleanup_all(struct ath11k *ar)\n{\n\tstruct ath11k_peer *peer, *tmp;\n\tstruct ath11k_base *ab = ar->ab;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tmutex_lock(&ab->tbl_mtx_lock);\n\tspin_lock_bh(&ab->base_lock);\n\tlist_for_each_entry_safe(peer, tmp, &ab->peers, list) {\n\t\tath11k_peer_rx_tid_cleanup(ar, peer);\n\t\tath11k_peer_rhash_delete(ab, peer);\n\t\tlist_del(&peer->list);\n\t\tkfree(peer);\n\t}\n\tspin_unlock_bh(&ab->base_lock);\n\tmutex_unlock(&ab->tbl_mtx_lock);\n\n\tar->num_peers = 0;\n\tar->num_stations = 0;\n}\n\nstatic inline int ath11k_mac_vdev_setup_sync(struct ath11k *ar)\n{\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (test_bit(ATH11K_FLAG_CRASH_FLUSH, &ar->ab->dev_flags))\n\t\treturn -ESHUTDOWN;\n\n\tif (!wait_for_completion_timeout(&ar->vdev_setup_done,\n\t\t\t\t\t ATH11K_VDEV_SETUP_TIMEOUT_HZ))\n\t\treturn -ETIMEDOUT;\n\n\treturn ar->last_wmi_vdev_start_status ? -EINVAL : 0;\n}\n\nstatic void\nath11k_mac_get_any_chandef_iter(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_chanctx_conf *conf,\n\t\t\t\tvoid *data)\n{\n\tstruct cfg80211_chan_def **def = data;\n\n\t*def = &conf->def;\n}\n\nstatic int ath11k_mac_monitor_vdev_start(struct ath11k *ar, int vdev_id,\n\t\t\t\t\t struct cfg80211_chan_def *chandef)\n{\n\tstruct ieee80211_channel *channel;\n\tstruct wmi_vdev_start_req_arg arg = {};\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tchannel = chandef->chan;\n\n\targ.vdev_id = vdev_id;\n\targ.channel.freq = channel->center_freq;\n\targ.channel.band_center_freq1 = chandef->center_freq1;\n\targ.channel.band_center_freq2 = chandef->center_freq2;\n\n\targ.channel.mode = ath11k_phymodes[chandef->chan->band][chandef->width];\n\targ.channel.chan_radar = !!(channel->flags & IEEE80211_CHAN_RADAR);\n\n\targ.channel.min_power = 0;\n\targ.channel.max_power = channel->max_power;\n\targ.channel.max_reg_power = channel->max_reg_power;\n\targ.channel.max_antenna_gain = channel->max_antenna_gain;\n\n\targ.pref_tx_streams = ar->num_tx_chains;\n\targ.pref_rx_streams = ar->num_rx_chains;\n\n\targ.channel.passive = !!(chandef->chan->flags & IEEE80211_CHAN_NO_IR);\n\n\treinit_completion(&ar->vdev_setup_done);\n\treinit_completion(&ar->vdev_delete_done);\n\n\tret = ath11k_wmi_vdev_start(ar, &arg, false);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to request monitor vdev %i start: %d\\n\",\n\t\t\t    vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\tret = ath11k_mac_vdev_setup_sync(ar);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to synchronize setup for monitor vdev %i start: %d\\n\",\n\t\t\t    vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\tret = ath11k_wmi_vdev_up(ar, vdev_id, 0, ar->mac_addr, NULL, 0, 0);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to put up monitor vdev %i: %d\\n\",\n\t\t\t    vdev_id, ret);\n\t\tgoto vdev_stop;\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_MAC, \"monitor vdev %i started\\n\",\n\t\t   vdev_id);\n\n\treturn 0;\n\nvdev_stop:\n\treinit_completion(&ar->vdev_setup_done);\n\n\tret = ath11k_wmi_vdev_stop(ar, vdev_id);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to stop monitor vdev %i after start failure: %d\\n\",\n\t\t\t    vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\tret = ath11k_mac_vdev_setup_sync(ar);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to synchronize setup for vdev %i stop: %d\\n\",\n\t\t\t    vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\treturn -EIO;\n}\n\nstatic int ath11k_mac_monitor_vdev_stop(struct ath11k *ar)\n{\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\treinit_completion(&ar->vdev_setup_done);\n\n\tret = ath11k_wmi_vdev_stop(ar, ar->monitor_vdev_id);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to request monitor vdev %i stop: %d\\n\",\n\t\t\t    ar->monitor_vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\tret = ath11k_mac_vdev_setup_sync(ar);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to synchronize monitor vdev %i stop: %d\\n\",\n\t\t\t    ar->monitor_vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\tret = ath11k_wmi_vdev_down(ar, ar->monitor_vdev_id);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to put down monitor vdev %i: %d\\n\",\n\t\t\t    ar->monitor_vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_MAC, \"monitor vdev %i stopped\\n\",\n\t\t   ar->monitor_vdev_id);\n\n\treturn 0;\n}\n\nstatic int ath11k_mac_monitor_vdev_create(struct ath11k *ar)\n{\n\tstruct ath11k_pdev *pdev = ar->pdev;\n\tstruct vdev_create_params param = {};\n\tint bit, ret;\n\tu8 tmp_addr[6] = {0};\n\tu16 nss;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (test_bit(ATH11K_FLAG_MONITOR_VDEV_CREATED, &ar->monitor_flags))\n\t\treturn 0;\n\n\tif (ar->ab->free_vdev_map == 0) {\n\t\tath11k_warn(ar->ab, \"failed to find free vdev id for monitor vdev\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tbit = __ffs64(ar->ab->free_vdev_map);\n\n\tar->monitor_vdev_id = bit;\n\n\tparam.if_id = ar->monitor_vdev_id;\n\tparam.type = WMI_VDEV_TYPE_MONITOR;\n\tparam.subtype = WMI_VDEV_SUBTYPE_NONE;\n\tparam.pdev_id = pdev->pdev_id;\n\n\tif (pdev->cap.supported_bands & WMI_HOST_WLAN_2G_CAP) {\n\t\tparam.chains[NL80211_BAND_2GHZ].tx = ar->num_tx_chains;\n\t\tparam.chains[NL80211_BAND_2GHZ].rx = ar->num_rx_chains;\n\t}\n\tif (pdev->cap.supported_bands & WMI_HOST_WLAN_5G_CAP) {\n\t\tparam.chains[NL80211_BAND_5GHZ].tx = ar->num_tx_chains;\n\t\tparam.chains[NL80211_BAND_5GHZ].rx = ar->num_rx_chains;\n\t}\n\n\tret = ath11k_wmi_vdev_create(ar, tmp_addr, &param);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to request monitor vdev %i creation: %d\\n\",\n\t\t\t    ar->monitor_vdev_id, ret);\n\t\tar->monitor_vdev_id = -1;\n\t\treturn ret;\n\t}\n\n\tnss = get_num_chains(ar->cfg_tx_chainmask) ? : 1;\n\tret = ath11k_wmi_vdev_set_param_cmd(ar, ar->monitor_vdev_id,\n\t\t\t\t\t    WMI_VDEV_PARAM_NSS, nss);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to set vdev %d chainmask 0x%x, nss %d :%d\\n\",\n\t\t\t    ar->monitor_vdev_id, ar->cfg_tx_chainmask, nss, ret);\n\t\tgoto err_vdev_del;\n\t}\n\n\tret = ath11k_mac_txpower_recalc(ar);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to recalc txpower for monitor vdev %d: %d\\n\",\n\t\t\t    ar->monitor_vdev_id, ret);\n\t\tgoto err_vdev_del;\n\t}\n\n\tar->allocated_vdev_map |= 1LL << ar->monitor_vdev_id;\n\tar->ab->free_vdev_map &= ~(1LL << ar->monitor_vdev_id);\n\tar->num_created_vdevs++;\n\tset_bit(ATH11K_FLAG_MONITOR_VDEV_CREATED, &ar->monitor_flags);\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_MAC, \"monitor vdev %d created\\n\",\n\t\t   ar->monitor_vdev_id);\n\n\treturn 0;\n\nerr_vdev_del:\n\tath11k_wmi_vdev_delete(ar, ar->monitor_vdev_id);\n\tar->monitor_vdev_id = -1;\n\treturn ret;\n}\n\nstatic int ath11k_mac_monitor_vdev_delete(struct ath11k *ar)\n{\n\tint ret;\n\tunsigned long time_left;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (!test_bit(ATH11K_FLAG_MONITOR_VDEV_CREATED, &ar->monitor_flags))\n\t\treturn 0;\n\n\treinit_completion(&ar->vdev_delete_done);\n\n\tret = ath11k_wmi_vdev_delete(ar, ar->monitor_vdev_id);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to request wmi monitor vdev %i removal: %d\\n\",\n\t\t\t    ar->monitor_vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\ttime_left = wait_for_completion_timeout(&ar->vdev_delete_done,\n\t\t\t\t\t\tATH11K_VDEV_DELETE_TIMEOUT_HZ);\n\tif (time_left == 0) {\n\t\tath11k_warn(ar->ab, \"Timeout in receiving vdev delete response\\n\");\n\t} else {\n\t\tath11k_dbg(ar->ab, ATH11K_DBG_MAC, \"monitor vdev %d deleted\\n\",\n\t\t\t   ar->monitor_vdev_id);\n\n\t\tar->allocated_vdev_map &= ~(1LL << ar->monitor_vdev_id);\n\t\tar->ab->free_vdev_map |= 1LL << (ar->monitor_vdev_id);\n\t\tar->num_created_vdevs--;\n\t\tar->monitor_vdev_id = -1;\n\t\tclear_bit(ATH11K_FLAG_MONITOR_VDEV_CREATED, &ar->monitor_flags);\n\t}\n\n\treturn ret;\n}\n\nstatic int ath11k_mac_monitor_start(struct ath11k *ar)\n{\n\tstruct cfg80211_chan_def *chandef = NULL;\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (test_bit(ATH11K_FLAG_MONITOR_STARTED, &ar->monitor_flags))\n\t\treturn 0;\n\n\tieee80211_iter_chan_contexts_atomic(ar->hw,\n\t\t\t\t\t    ath11k_mac_get_any_chandef_iter,\n\t\t\t\t\t    &chandef);\n\tif (!chandef)\n\t\treturn 0;\n\n\tret = ath11k_mac_monitor_vdev_start(ar, ar->monitor_vdev_id, chandef);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to start monitor vdev: %d\\n\", ret);\n\t\tath11k_mac_monitor_vdev_delete(ar);\n\t\treturn ret;\n\t}\n\n\tset_bit(ATH11K_FLAG_MONITOR_STARTED, &ar->monitor_flags);\n\n\tar->num_started_vdevs++;\n\tret = ath11k_dp_tx_htt_monitor_mode_ring_config(ar, false);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to configure htt monitor mode ring during start: %d\",\n\t\t\t    ret);\n\t\treturn ret;\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_MAC, \"monitor started\\n\");\n\n\treturn 0;\n}\n\nstatic int ath11k_mac_monitor_stop(struct ath11k *ar)\n{\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (!test_bit(ATH11K_FLAG_MONITOR_STARTED, &ar->monitor_flags))\n\t\treturn 0;\n\n\tret = ath11k_mac_monitor_vdev_stop(ar);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to stop monitor vdev: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tclear_bit(ATH11K_FLAG_MONITOR_STARTED, &ar->monitor_flags);\n\tar->num_started_vdevs--;\n\n\tret = ath11k_dp_tx_htt_monitor_mode_ring_config(ar, true);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to configure htt monitor mode ring during stop: %d\",\n\t\t\t    ret);\n\t\treturn ret;\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_MAC, \"monitor stopped ret %d\\n\", ret);\n\n\treturn 0;\n}\n\nstatic int ath11k_mac_vif_setup_ps(struct ath11k_vif *arvif)\n{\n\tstruct ath11k *ar = arvif->ar;\n\tstruct ieee80211_vif *vif = arvif->vif;\n\tstruct ieee80211_conf *conf = &ar->hw->conf;\n\tenum wmi_sta_powersave_param param;\n\tenum wmi_sta_ps_mode psmode;\n\tint ret;\n\tint timeout;\n\tbool enable_ps;\n\n\tlockdep_assert_held(&arvif->ar->conf_mutex);\n\n\tif (arvif->vif->type != NL80211_IFTYPE_STATION)\n\t\treturn 0;\n\n\tenable_ps = arvif->ps;\n\n\tif (!arvif->is_started) {\n\t\t \n\t\tpsmode = WMI_STA_PS_MODE_ENABLED;\n\t} else if (enable_ps) {\n\t\tpsmode = WMI_STA_PS_MODE_ENABLED;\n\t\tparam = WMI_STA_PS_PARAM_INACTIVITY_TIME;\n\n\t\ttimeout = conf->dynamic_ps_timeout;\n\t\tif (timeout == 0) {\n\t\t\t \n\t\t\ttimeout = ieee80211_tu_to_usec(vif->bss_conf.beacon_int) / 1000;\n\t\t}\n\n\t\tret = ath11k_wmi_set_sta_ps_param(ar, arvif->vdev_id, param,\n\t\t\t\t\t\t  timeout);\n\t\tif (ret) {\n\t\t\tath11k_warn(ar->ab, \"failed to set inactivity time for vdev %d: %i\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tpsmode = WMI_STA_PS_MODE_DISABLED;\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_MAC, \"vdev %d psmode %s\\n\",\n\t\t   arvif->vdev_id, psmode ? \"enable\" : \"disable\");\n\n\tret = ath11k_wmi_pdev_set_ps_mode(ar, arvif->vdev_id, psmode);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to set sta power save mode %d for vdev %d: %d\\n\",\n\t\t\t    psmode, arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath11k_mac_config_ps(struct ath11k *ar)\n{\n\tstruct ath11k_vif *arvif;\n\tint ret = 0;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tlist_for_each_entry(arvif, &ar->arvifs, list) {\n\t\tret = ath11k_mac_vif_setup_ps(arvif);\n\t\tif (ret) {\n\t\t\tath11k_warn(ar->ab, \"failed to setup powersave: %d\\n\", ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int ath11k_mac_op_config(struct ieee80211_hw *hw, u32 changed)\n{\n\tstruct ath11k *ar = hw->priv;\n\tstruct ieee80211_conf *conf = &hw->conf;\n\tint ret = 0;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (changed & IEEE80211_CONF_CHANGE_MONITOR) {\n\t\tif (conf->flags & IEEE80211_CONF_MONITOR) {\n\t\t\tset_bit(ATH11K_FLAG_MONITOR_CONF_ENABLED, &ar->monitor_flags);\n\n\t\t\tif (test_bit(ATH11K_FLAG_MONITOR_VDEV_CREATED,\n\t\t\t\t     &ar->monitor_flags))\n\t\t\t\tgoto out;\n\n\t\t\tret = ath11k_mac_monitor_vdev_create(ar);\n\t\t\tif (ret) {\n\t\t\t\tath11k_warn(ar->ab, \"failed to create monitor vdev: %d\",\n\t\t\t\t\t    ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ath11k_mac_monitor_start(ar);\n\t\t\tif (ret) {\n\t\t\t\tath11k_warn(ar->ab, \"failed to start monitor: %d\",\n\t\t\t\t\t    ret);\n\t\t\t\tgoto err_mon_del;\n\t\t\t}\n\t\t} else {\n\t\t\tclear_bit(ATH11K_FLAG_MONITOR_CONF_ENABLED, &ar->monitor_flags);\n\n\t\t\tif (!test_bit(ATH11K_FLAG_MONITOR_VDEV_CREATED,\n\t\t\t\t      &ar->monitor_flags))\n\t\t\t\tgoto out;\n\n\t\t\tret = ath11k_mac_monitor_stop(ar);\n\t\t\tif (ret) {\n\t\t\t\tath11k_warn(ar->ab, \"failed to stop monitor: %d\",\n\t\t\t\t\t    ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = ath11k_mac_monitor_vdev_delete(ar);\n\t\t\tif (ret) {\n\t\t\t\tath11k_warn(ar->ab, \"failed to delete monitor vdev: %d\",\n\t\t\t\t\t    ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\nout:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n\nerr_mon_del:\n\tath11k_mac_monitor_vdev_delete(ar);\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic void ath11k_mac_setup_nontx_vif_rsnie(struct ath11k_vif *arvif,\n\t\t\t\t\t     bool tx_arvif_rsnie_present,\n\t\t\t\t\t     const u8 *profile, u8 profile_len)\n{\n\tif (cfg80211_find_ie(WLAN_EID_RSN, profile, profile_len)) {\n\t\tarvif->rsnie_present = true;\n\t} else if (tx_arvif_rsnie_present) {\n\t\tint i;\n\t\tu8 nie_len;\n\t\tconst u8 *nie = cfg80211_find_ext_ie(WLAN_EID_EXT_NON_INHERITANCE,\n\t\t\t\t\t\t     profile, profile_len);\n\t\tif (!nie)\n\t\t\treturn;\n\n\t\tnie_len = nie[1];\n\t\tnie += 2;\n\t\tfor (i = 0; i < nie_len; i++) {\n\t\t\tif (nie[i] == WLAN_EID_RSN) {\n\t\t\t\tarvif->rsnie_present = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic bool ath11k_mac_set_nontx_vif_params(struct ath11k_vif *tx_arvif,\n\t\t\t\t\t    struct ath11k_vif *arvif,\n\t\t\t\t\t    struct sk_buff *bcn)\n{\n\tstruct ieee80211_mgmt *mgmt;\n\tconst u8 *ies, *profile, *next_profile;\n\tint ies_len;\n\n\ties = bcn->data + ieee80211_get_hdrlen_from_skb(bcn);\n\tmgmt = (struct ieee80211_mgmt *)bcn->data;\n\ties += sizeof(mgmt->u.beacon);\n\ties_len = skb_tail_pointer(bcn) - ies;\n\n\ties = cfg80211_find_ie(WLAN_EID_MULTIPLE_BSSID, ies, ies_len);\n\tarvif->rsnie_present = tx_arvif->rsnie_present;\n\n\twhile (ies) {\n\t\tu8 mbssid_len;\n\n\t\ties_len -= (2 + ies[1]);\n\t\tmbssid_len = ies[1] - 1;\n\t\tprofile = &ies[3];\n\n\t\twhile (mbssid_len) {\n\t\t\tu8 profile_len;\n\n\t\t\tprofile_len = profile[1];\n\t\t\tnext_profile = profile + (2 + profile_len);\n\t\t\tmbssid_len -= (2 + profile_len);\n\n\t\t\tprofile += 2;\n\t\t\tprofile_len -= (2 + profile[1]);\n\t\t\tprofile += (2 + profile[1]);  \n\t\t\tprofile_len -= (2 + profile[1]);\n\t\t\tprofile += (2 + profile[1]);  \n\t\t\tif (profile[2] == arvif->vif->bss_conf.bssid_index) {\n\t\t\t\tprofile_len -= 5;\n\t\t\t\tprofile = profile + 5;\n\t\t\t\tath11k_mac_setup_nontx_vif_rsnie(arvif,\n\t\t\t\t\t\t\t\t tx_arvif->rsnie_present,\n\t\t\t\t\t\t\t\t profile,\n\t\t\t\t\t\t\t\t profile_len);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tprofile = next_profile;\n\t\t}\n\t\ties = cfg80211_find_ie(WLAN_EID_MULTIPLE_BSSID, profile,\n\t\t\t\t       ies_len);\n\t}\n\n\treturn false;\n}\n\nstatic void ath11k_mac_set_vif_params(struct ath11k_vif *arvif,\n\t\t\t\t      struct sk_buff *bcn)\n{\n\tstruct ieee80211_mgmt *mgmt;\n\tu8 *ies;\n\n\ties = bcn->data + ieee80211_get_hdrlen_from_skb(bcn);\n\tmgmt = (struct ieee80211_mgmt *)bcn->data;\n\ties += sizeof(mgmt->u.beacon);\n\n\tif (cfg80211_find_ie(WLAN_EID_RSN, ies, (skb_tail_pointer(bcn) - ies)))\n\t\tarvif->rsnie_present = true;\n\telse\n\t\tarvif->rsnie_present = false;\n\n\tif (cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t    WLAN_OUI_TYPE_MICROSOFT_WPA,\n\t\t\t\t    ies, (skb_tail_pointer(bcn) - ies)))\n\t\tarvif->wpaie_present = true;\n\telse\n\t\tarvif->wpaie_present = false;\n}\n\nstatic int ath11k_mac_setup_bcn_tmpl_ema(struct ath11k_vif *arvif)\n{\n\tstruct ath11k_vif *tx_arvif;\n\tstruct ieee80211_ema_beacons *beacons;\n\tint ret = 0;\n\tbool nontx_vif_params_set = false;\n\tu32 params = 0;\n\tu8 i = 0;\n\n\ttx_arvif = ath11k_vif_to_arvif(arvif->vif->mbssid_tx_vif);\n\n\tbeacons = ieee80211_beacon_get_template_ema_list(tx_arvif->ar->hw,\n\t\t\t\t\t\t\t tx_arvif->vif, 0);\n\tif (!beacons || !beacons->cnt) {\n\t\tath11k_warn(arvif->ar->ab,\n\t\t\t    \"failed to get ema beacon templates from mac80211\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tif (tx_arvif == arvif)\n\t\tath11k_mac_set_vif_params(tx_arvif, beacons->bcn[0].skb);\n\telse\n\t\tarvif->wpaie_present = tx_arvif->wpaie_present;\n\n\tfor (i = 0; i < beacons->cnt; i++) {\n\t\tif (tx_arvif != arvif && !nontx_vif_params_set)\n\t\t\tnontx_vif_params_set =\n\t\t\t\tath11k_mac_set_nontx_vif_params(tx_arvif, arvif,\n\t\t\t\t\t\t\t\tbeacons->bcn[i].skb);\n\n\t\tparams = beacons->cnt;\n\t\tparams |= (i << WMI_EMA_TMPL_IDX_SHIFT);\n\t\tparams |= ((!i ? 1 : 0) << WMI_EMA_FIRST_TMPL_SHIFT);\n\t\tparams |= ((i + 1 == beacons->cnt ? 1 : 0) << WMI_EMA_LAST_TMPL_SHIFT);\n\n\t\tret = ath11k_wmi_bcn_tmpl(tx_arvif->ar, tx_arvif->vdev_id,\n\t\t\t\t\t  &beacons->bcn[i].offs,\n\t\t\t\t\t  beacons->bcn[i].skb, params);\n\t\tif (ret) {\n\t\t\tath11k_warn(tx_arvif->ar->ab,\n\t\t\t\t    \"failed to set ema beacon template id %i error %d\\n\",\n\t\t\t\t    i, ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tieee80211_beacon_free_ema_list(beacons);\n\n\tif (tx_arvif != arvif && !nontx_vif_params_set)\n\t\treturn -EINVAL;  \n\n\treturn ret;\n}\n\nstatic int ath11k_mac_setup_bcn_tmpl_mbssid(struct ath11k_vif *arvif)\n{\n\tstruct ath11k *ar = arvif->ar;\n\tstruct ath11k_base *ab = ar->ab;\n\tstruct ath11k_vif *tx_arvif = arvif;\n\tstruct ieee80211_hw *hw = ar->hw;\n\tstruct ieee80211_vif *vif = arvif->vif;\n\tstruct ieee80211_mutable_offsets offs = {};\n\tstruct sk_buff *bcn;\n\tint ret;\n\n\tif (vif->mbssid_tx_vif) {\n\t\ttx_arvif = ath11k_vif_to_arvif(vif->mbssid_tx_vif);\n\t\tif (tx_arvif != arvif) {\n\t\t\tar = tx_arvif->ar;\n\t\t\tab = ar->ab;\n\t\t\thw = ar->hw;\n\t\t\tvif = tx_arvif->vif;\n\t\t}\n\t}\n\n\tbcn = ieee80211_beacon_get_template(hw, vif, &offs, 0);\n\tif (!bcn) {\n\t\tath11k_warn(ab, \"failed to get beacon template from mac80211\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tif (tx_arvif == arvif)\n\t\tath11k_mac_set_vif_params(tx_arvif, bcn);\n\telse if (!ath11k_mac_set_nontx_vif_params(tx_arvif, arvif, bcn))\n\t\treturn -EINVAL;\n\n\tret = ath11k_wmi_bcn_tmpl(ar, arvif->vdev_id, &offs, bcn, 0);\n\tkfree_skb(bcn);\n\n\tif (ret)\n\t\tath11k_warn(ab, \"failed to submit beacon template command: %d\\n\",\n\t\t\t    ret);\n\n\treturn ret;\n}\n\nstatic int ath11k_mac_setup_bcn_tmpl(struct ath11k_vif *arvif)\n{\n\tstruct ieee80211_vif *vif = arvif->vif;\n\n\tif (arvif->vdev_type != WMI_VDEV_TYPE_AP)\n\t\treturn 0;\n\n\t \n\tif (vif->mbssid_tx_vif &&\n\t    arvif != ath11k_vif_to_arvif(vif->mbssid_tx_vif) && arvif->is_up)\n\t\treturn 0;\n\n\tif (vif->bss_conf.ema_ap && vif->mbssid_tx_vif)\n\t\treturn ath11k_mac_setup_bcn_tmpl_ema(arvif);\n\n\treturn ath11k_mac_setup_bcn_tmpl_mbssid(arvif);\n}\n\nvoid ath11k_mac_bcn_tx_event(struct ath11k_vif *arvif)\n{\n\tstruct ieee80211_vif *vif = arvif->vif;\n\n\tif (!vif->bss_conf.color_change_active && !arvif->bcca_zero_sent)\n\t\treturn;\n\n\tif (vif->bss_conf.color_change_active &&\n\t    ieee80211_beacon_cntdwn_is_complete(vif)) {\n\t\tarvif->bcca_zero_sent = true;\n\t\tieee80211_color_change_finish(vif);\n\t\treturn;\n\t}\n\n\tarvif->bcca_zero_sent = false;\n\n\tif (vif->bss_conf.color_change_active)\n\t\tieee80211_beacon_update_cntdwn(vif);\n\tath11k_mac_setup_bcn_tmpl(arvif);\n}\n\nstatic void ath11k_control_beaconing(struct ath11k_vif *arvif,\n\t\t\t\t     struct ieee80211_bss_conf *info)\n{\n\tstruct ath11k *ar = arvif->ar;\n\tstruct ath11k_vif *tx_arvif = NULL;\n\tint ret = 0;\n\n\tlockdep_assert_held(&arvif->ar->conf_mutex);\n\n\tif (!info->enable_beacon) {\n\t\tret = ath11k_wmi_vdev_down(ar, arvif->vdev_id);\n\t\tif (ret)\n\t\t\tath11k_warn(ar->ab, \"failed to down vdev_id %i: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\n\t\tarvif->is_up = false;\n\t\treturn;\n\t}\n\n\t \n\tret = ath11k_mac_setup_bcn_tmpl(arvif);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to update bcn tmpl during vdev up: %d\\n\",\n\t\t\t    ret);\n\t\treturn;\n\t}\n\n\tarvif->tx_seq_no = 0x1000;\n\n\tarvif->aid = 0;\n\n\tether_addr_copy(arvif->bssid, info->bssid);\n\n\tif (arvif->vif->mbssid_tx_vif)\n\t\ttx_arvif = ath11k_vif_to_arvif(arvif->vif->mbssid_tx_vif);\n\n\tret = ath11k_wmi_vdev_up(arvif->ar, arvif->vdev_id, arvif->aid,\n\t\t\t\t arvif->bssid,\n\t\t\t\t tx_arvif ? tx_arvif->bssid : NULL,\n\t\t\t\t info->bssid_index,\n\t\t\t\t 1 << info->bssid_indicator);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to bring up vdev %d: %i\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn;\n\t}\n\n\tarvif->is_up = true;\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_MAC, \"vdev %d up\\n\", arvif->vdev_id);\n}\n\nstatic void ath11k_mac_handle_beacon_iter(void *data, u8 *mac,\n\t\t\t\t\t  struct ieee80211_vif *vif)\n{\n\tstruct sk_buff *skb = data;\n\tstruct ieee80211_mgmt *mgmt = (void *)skb->data;\n\tstruct ath11k_vif *arvif = ath11k_vif_to_arvif(vif);\n\n\tif (vif->type != NL80211_IFTYPE_STATION)\n\t\treturn;\n\n\tif (!ether_addr_equal(mgmt->bssid, vif->bss_conf.bssid))\n\t\treturn;\n\n\tcancel_delayed_work(&arvif->connection_loss_work);\n}\n\nvoid ath11k_mac_handle_beacon(struct ath11k *ar, struct sk_buff *skb)\n{\n\tieee80211_iterate_active_interfaces_atomic(ar->hw,\n\t\t\t\t\t\t   IEEE80211_IFACE_ITER_NORMAL,\n\t\t\t\t\t\t   ath11k_mac_handle_beacon_iter,\n\t\t\t\t\t\t   skb);\n}\n\nstatic void ath11k_mac_handle_beacon_miss_iter(void *data, u8 *mac,\n\t\t\t\t\t       struct ieee80211_vif *vif)\n{\n\tu32 *vdev_id = data;\n\tstruct ath11k_vif *arvif = ath11k_vif_to_arvif(vif);\n\tstruct ath11k *ar = arvif->ar;\n\tstruct ieee80211_hw *hw = ar->hw;\n\n\tif (arvif->vdev_id != *vdev_id)\n\t\treturn;\n\n\tif (!arvif->is_up)\n\t\treturn;\n\n\tieee80211_beacon_loss(vif);\n\n\t \n\tieee80211_queue_delayed_work(hw, &arvif->connection_loss_work,\n\t\t\t\t     ATH11K_CONNECTION_LOSS_HZ);\n}\n\nvoid ath11k_mac_handle_beacon_miss(struct ath11k *ar, u32 vdev_id)\n{\n\tieee80211_iterate_active_interfaces_atomic(ar->hw,\n\t\t\t\t\t\t   IEEE80211_IFACE_ITER_NORMAL,\n\t\t\t\t\t\t   ath11k_mac_handle_beacon_miss_iter,\n\t\t\t\t\t\t   &vdev_id);\n}\n\nstatic void ath11k_mac_vif_sta_connection_loss_work(struct work_struct *work)\n{\n\tstruct ath11k_vif *arvif = container_of(work, struct ath11k_vif,\n\t\t\t\t\t\tconnection_loss_work.work);\n\tstruct ieee80211_vif *vif = arvif->vif;\n\n\tif (!arvif->is_up)\n\t\treturn;\n\n\tieee80211_connection_loss(vif);\n}\n\nstatic void ath11k_peer_assoc_h_basic(struct ath11k *ar,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      struct ieee80211_sta *sta,\n\t\t\t\t      struct peer_assoc_params *arg)\n{\n\tstruct ath11k_vif *arvif = ath11k_vif_to_arvif(vif);\n\tu32 aid;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (vif->type == NL80211_IFTYPE_STATION)\n\t\taid = vif->cfg.aid;\n\telse\n\t\taid = sta->aid;\n\n\tether_addr_copy(arg->peer_mac, sta->addr);\n\targ->vdev_id = arvif->vdev_id;\n\targ->peer_associd = aid;\n\targ->auth_flag = true;\n\t \n\targ->peer_listen_intval = ar->hw->conf.listen_interval;\n\targ->peer_nss = 1;\n\targ->peer_caps = vif->bss_conf.assoc_capability;\n}\n\nstatic void ath11k_peer_assoc_h_crypto(struct ath11k *ar,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       struct ieee80211_sta *sta,\n\t\t\t\t       struct peer_assoc_params *arg)\n{\n\tstruct ieee80211_bss_conf *info = &vif->bss_conf;\n\tstruct cfg80211_chan_def def;\n\tstruct cfg80211_bss *bss;\n\tstruct ath11k_vif *arvif = ath11k_vif_to_arvif(vif);\n\tconst u8 *rsnie = NULL;\n\tconst u8 *wpaie = NULL;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (WARN_ON(ath11k_mac_vif_chan(vif, &def)))\n\t\treturn;\n\n\tbss = cfg80211_get_bss(ar->hw->wiphy, def.chan, info->bssid, NULL, 0,\n\t\t\t       IEEE80211_BSS_TYPE_ANY, IEEE80211_PRIVACY_ANY);\n\n\tif (arvif->rsnie_present || arvif->wpaie_present) {\n\t\targ->need_ptk_4_way = true;\n\t\tif (arvif->wpaie_present)\n\t\t\targ->need_gtk_2_way = true;\n\t} else if (bss) {\n\t\tconst struct cfg80211_bss_ies *ies;\n\n\t\trcu_read_lock();\n\t\trsnie = ieee80211_bss_get_ie(bss, WLAN_EID_RSN);\n\n\t\ties = rcu_dereference(bss->ies);\n\n\t\twpaie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t\tWLAN_OUI_TYPE_MICROSOFT_WPA,\n\t\t\t\t\t\ties->data,\n\t\t\t\t\t\ties->len);\n\t\trcu_read_unlock();\n\t\tcfg80211_put_bss(ar->hw->wiphy, bss);\n\t}\n\n\t \n\tif (rsnie || wpaie) {\n\t\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t\t   \"%s: rsn ie found\\n\", __func__);\n\t\targ->need_ptk_4_way = true;\n\t}\n\n\tif (wpaie) {\n\t\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t\t   \"%s: wpa ie found\\n\", __func__);\n\t\targ->need_gtk_2_way = true;\n\t}\n\n\tif (sta->mfp) {\n\t\t \n\t\targ->is_pmf_enabled = true;\n\t}\n\n\t \n}\n\nstatic void ath11k_peer_assoc_h_rates(struct ath11k *ar,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      struct ieee80211_sta *sta,\n\t\t\t\t      struct peer_assoc_params *arg)\n{\n\tstruct ath11k_vif *arvif = ath11k_vif_to_arvif(vif);\n\tstruct wmi_rate_set_arg *rateset = &arg->peer_legacy_rates;\n\tstruct cfg80211_chan_def def;\n\tconst struct ieee80211_supported_band *sband;\n\tconst struct ieee80211_rate *rates;\n\tenum nl80211_band band;\n\tu32 ratemask;\n\tu8 rate;\n\tint i;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (WARN_ON(ath11k_mac_vif_chan(vif, &def)))\n\t\treturn;\n\n\tband = def.chan->band;\n\tsband = ar->hw->wiphy->bands[band];\n\tratemask = sta->deflink.supp_rates[band];\n\tratemask &= arvif->bitrate_mask.control[band].legacy;\n\trates = sband->bitrates;\n\n\trateset->num_rates = 0;\n\n\tfor (i = 0; i < 32; i++, ratemask >>= 1, rates++) {\n\t\tif (!(ratemask & 1))\n\t\t\tcontinue;\n\n\t\trate = ath11k_mac_bitrate_to_rate(rates->bitrate);\n\t\trateset->rates[rateset->num_rates] = rate;\n\t\trateset->num_rates++;\n\t}\n}\n\nstatic bool\nath11k_peer_assoc_h_ht_masked(const u8 *ht_mcs_mask)\n{\n\tint nss;\n\n\tfor (nss = 0; nss < IEEE80211_HT_MCS_MASK_LEN; nss++)\n\t\tif (ht_mcs_mask[nss])\n\t\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool\nath11k_peer_assoc_h_vht_masked(const u16 *vht_mcs_mask)\n{\n\tint nss;\n\n\tfor (nss = 0; nss < NL80211_VHT_NSS_MAX; nss++)\n\t\tif (vht_mcs_mask[nss])\n\t\t\treturn false;\n\n\treturn true;\n}\n\nstatic void ath11k_peer_assoc_h_ht(struct ath11k *ar,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   struct ieee80211_sta *sta,\n\t\t\t\t   struct peer_assoc_params *arg)\n{\n\tconst struct ieee80211_sta_ht_cap *ht_cap = &sta->deflink.ht_cap;\n\tstruct ath11k_vif *arvif = ath11k_vif_to_arvif(vif);\n\tstruct cfg80211_chan_def def;\n\tenum nl80211_band band;\n\tconst u8 *ht_mcs_mask;\n\tint i, n;\n\tu8 max_nss;\n\tu32 stbc;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (WARN_ON(ath11k_mac_vif_chan(vif, &def)))\n\t\treturn;\n\n\tif (!ht_cap->ht_supported)\n\t\treturn;\n\n\tband = def.chan->band;\n\tht_mcs_mask = arvif->bitrate_mask.control[band].ht_mcs;\n\n\tif (ath11k_peer_assoc_h_ht_masked(ht_mcs_mask))\n\t\treturn;\n\n\targ->ht_flag = true;\n\n\targ->peer_max_mpdu = (1 << (IEEE80211_HT_MAX_AMPDU_FACTOR +\n\t\t\t\t    ht_cap->ampdu_factor)) - 1;\n\n\targ->peer_mpdu_density =\n\t\tath11k_parse_mpdudensity(ht_cap->ampdu_density);\n\n\targ->peer_ht_caps = ht_cap->cap;\n\targ->peer_rate_caps |= WMI_HOST_RC_HT_FLAG;\n\n\tif (ht_cap->cap & IEEE80211_HT_CAP_LDPC_CODING)\n\t\targ->ldpc_flag = true;\n\n\tif (sta->deflink.bandwidth >= IEEE80211_STA_RX_BW_40) {\n\t\targ->bw_40 = true;\n\t\targ->peer_rate_caps |= WMI_HOST_RC_CW40_FLAG;\n\t}\n\n\t \n\tif (arvif->bitrate_mask.control[band].gi == NL80211_TXRATE_DEFAULT_GI)\n\t\targ->peer_ht_caps &= ~(IEEE80211_HT_CAP_SGI_20 |\n\t\t\t\tIEEE80211_HT_CAP_SGI_40);\n\n\tif (arvif->bitrate_mask.control[band].gi != NL80211_TXRATE_FORCE_LGI) {\n\t\tif (ht_cap->cap & (IEEE80211_HT_CAP_SGI_20 |\n\t\t    IEEE80211_HT_CAP_SGI_40))\n\t\t\targ->peer_rate_caps |= WMI_HOST_RC_SGI_FLAG;\n\t}\n\n\tif (ht_cap->cap & IEEE80211_HT_CAP_TX_STBC) {\n\t\targ->peer_rate_caps |= WMI_HOST_RC_TX_STBC_FLAG;\n\t\targ->stbc_flag = true;\n\t}\n\n\tif (ht_cap->cap & IEEE80211_HT_CAP_RX_STBC) {\n\t\tstbc = ht_cap->cap & IEEE80211_HT_CAP_RX_STBC;\n\t\tstbc = stbc >> IEEE80211_HT_CAP_RX_STBC_SHIFT;\n\t\tstbc = stbc << WMI_HOST_RC_RX_STBC_FLAG_S;\n\t\targ->peer_rate_caps |= stbc;\n\t\targ->stbc_flag = true;\n\t}\n\n\tif (ht_cap->mcs.rx_mask[1] && ht_cap->mcs.rx_mask[2])\n\t\targ->peer_rate_caps |= WMI_HOST_RC_TS_FLAG;\n\telse if (ht_cap->mcs.rx_mask[1])\n\t\targ->peer_rate_caps |= WMI_HOST_RC_DS_FLAG;\n\n\tfor (i = 0, n = 0, max_nss = 0; i < IEEE80211_HT_MCS_MASK_LEN * 8; i++)\n\t\tif ((ht_cap->mcs.rx_mask[i / 8] & BIT(i % 8)) &&\n\t\t    (ht_mcs_mask[i / 8] & BIT(i % 8))) {\n\t\t\tmax_nss = (i / 8) + 1;\n\t\t\targ->peer_ht_rates.rates[n++] = i;\n\t\t}\n\n\t \n\tif (n == 0) {\n\t\targ->peer_ht_rates.num_rates = 8;\n\t\tfor (i = 0; i < arg->peer_ht_rates.num_rates; i++)\n\t\t\targ->peer_ht_rates.rates[i] = i;\n\t} else {\n\t\targ->peer_ht_rates.num_rates = n;\n\t\targ->peer_nss = min(sta->deflink.rx_nss, max_nss);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_MAC, \"ht peer %pM mcs cnt %d nss %d\\n\",\n\t\t   arg->peer_mac,\n\t\t   arg->peer_ht_rates.num_rates,\n\t\t   arg->peer_nss);\n}\n\nstatic int ath11k_mac_get_max_vht_mcs_map(u16 mcs_map, int nss)\n{\n\tswitch ((mcs_map >> (2 * nss)) & 0x3) {\n\tcase IEEE80211_VHT_MCS_SUPPORT_0_7: return BIT(8) - 1;\n\tcase IEEE80211_VHT_MCS_SUPPORT_0_8: return BIT(9) - 1;\n\tcase IEEE80211_VHT_MCS_SUPPORT_0_9: return BIT(10) - 1;\n\t}\n\treturn 0;\n}\n\nstatic u16\nath11k_peer_assoc_h_vht_limit(u16 tx_mcs_set,\n\t\t\t      const u16 vht_mcs_limit[NL80211_VHT_NSS_MAX])\n{\n\tint idx_limit;\n\tint nss;\n\tu16 mcs_map;\n\tu16 mcs;\n\n\tfor (nss = 0; nss < NL80211_VHT_NSS_MAX; nss++) {\n\t\tmcs_map = ath11k_mac_get_max_vht_mcs_map(tx_mcs_set, nss) &\n\t\t\t  vht_mcs_limit[nss];\n\n\t\tif (mcs_map)\n\t\t\tidx_limit = fls(mcs_map) - 1;\n\t\telse\n\t\t\tidx_limit = -1;\n\n\t\tswitch (idx_limit) {\n\t\tcase 0:\n\t\tcase 1:\n\t\tcase 2:\n\t\tcase 3:\n\t\tcase 4:\n\t\tcase 5:\n\t\tcase 6:\n\t\tcase 7:\n\t\t\tmcs = IEEE80211_VHT_MCS_SUPPORT_0_7;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tmcs = IEEE80211_VHT_MCS_SUPPORT_0_8;\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tmcs = IEEE80211_VHT_MCS_SUPPORT_0_9;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t\tfallthrough;\n\t\tcase -1:\n\t\t\tmcs = IEEE80211_VHT_MCS_NOT_SUPPORTED;\n\t\t\tbreak;\n\t\t}\n\n\t\ttx_mcs_set &= ~(0x3 << (nss * 2));\n\t\ttx_mcs_set |= mcs << (nss * 2);\n\t}\n\n\treturn tx_mcs_set;\n}\n\nstatic u8 ath11k_get_nss_160mhz(struct ath11k *ar,\n\t\t\t\tu8 max_nss)\n{\n\tu8 nss_ratio_info = ar->pdev->cap.nss_ratio_info;\n\tu8 max_sup_nss = 0;\n\n\tswitch (nss_ratio_info) {\n\tcase WMI_NSS_RATIO_1BY2_NSS:\n\t\tmax_sup_nss = max_nss >> 1;\n\t\tbreak;\n\tcase WMI_NSS_RATIO_3BY4_NSS:\n\t\tath11k_warn(ar->ab, \"WMI_NSS_RATIO_3BY4_NSS not supported\\n\");\n\t\tbreak;\n\tcase WMI_NSS_RATIO_1_NSS:\n\t\tmax_sup_nss = max_nss;\n\t\tbreak;\n\tcase WMI_NSS_RATIO_2_NSS:\n\t\tath11k_warn(ar->ab, \"WMI_NSS_RATIO_2_NSS not supported\\n\");\n\t\tbreak;\n\tdefault:\n\t\tath11k_warn(ar->ab, \"invalid nss ratio received from firmware: %d\\n\",\n\t\t\t    nss_ratio_info);\n\t\tbreak;\n\t}\n\n\treturn max_sup_nss;\n}\n\nstatic void ath11k_peer_assoc_h_vht(struct ath11k *ar,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct ieee80211_sta *sta,\n\t\t\t\t    struct peer_assoc_params *arg)\n{\n\tconst struct ieee80211_sta_vht_cap *vht_cap = &sta->deflink.vht_cap;\n\tstruct ath11k_vif *arvif = ath11k_vif_to_arvif(vif);\n\tstruct cfg80211_chan_def def;\n\tenum nl80211_band band;\n\tu16 *vht_mcs_mask;\n\tu8 ampdu_factor;\n\tu8 max_nss, vht_mcs;\n\tint i, vht_nss, nss_idx;\n\tbool user_rate_valid = true;\n\tu32 rx_nss, tx_nss, nss_160;\n\n\tif (WARN_ON(ath11k_mac_vif_chan(vif, &def)))\n\t\treturn;\n\n\tif (!vht_cap->vht_supported)\n\t\treturn;\n\n\tband = def.chan->band;\n\tvht_mcs_mask = arvif->bitrate_mask.control[band].vht_mcs;\n\n\tif (ath11k_peer_assoc_h_vht_masked(vht_mcs_mask))\n\t\treturn;\n\n\targ->vht_flag = true;\n\n\t \n\targ->vht_capable = true;\n\n\tif (def.chan->band == NL80211_BAND_2GHZ)\n\t\targ->vht_ng_flag = true;\n\n\targ->peer_vht_caps = vht_cap->cap;\n\n\tampdu_factor = (vht_cap->cap &\n\t\t\tIEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK) >>\n\t\t       IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_SHIFT;\n\n\t \n\targ->peer_max_mpdu = max(arg->peer_max_mpdu,\n\t\t\t\t (1U << (IEEE80211_HT_MAX_AMPDU_FACTOR +\n\t\t\t\t\tampdu_factor)) - 1);\n\n\tif (sta->deflink.bandwidth == IEEE80211_STA_RX_BW_80)\n\t\targ->bw_80 = true;\n\n\tif (sta->deflink.bandwidth == IEEE80211_STA_RX_BW_160)\n\t\targ->bw_160 = true;\n\n\tvht_nss =  ath11k_mac_max_vht_nss(vht_mcs_mask);\n\n\tif (vht_nss > sta->deflink.rx_nss) {\n\t\tuser_rate_valid = false;\n\t\tfor (nss_idx = sta->deflink.rx_nss - 1; nss_idx >= 0; nss_idx--) {\n\t\t\tif (vht_mcs_mask[nss_idx]) {\n\t\t\t\tuser_rate_valid = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!user_rate_valid) {\n\t\tath11k_dbg(ar->ab, ATH11K_DBG_MAC, \"setting vht range mcs value to peer supported nss %d for peer %pM\\n\",\n\t\t\t   sta->deflink.rx_nss, sta->addr);\n\t\tvht_mcs_mask[sta->deflink.rx_nss - 1] = vht_mcs_mask[vht_nss - 1];\n\t}\n\n\t \n\tfor (i = 0, max_nss = 0; i < NL80211_VHT_NSS_MAX; i++) {\n\t\tvht_mcs = __le16_to_cpu(vht_cap->vht_mcs.rx_mcs_map) >>\n\t\t\t  (2 * i) & 3;\n\n\t\tif (vht_mcs != IEEE80211_VHT_MCS_NOT_SUPPORTED &&\n\t\t    vht_mcs_mask[i])\n\t\t\tmax_nss = i + 1;\n\t}\n\targ->peer_nss = min(sta->deflink.rx_nss, max_nss);\n\targ->rx_max_rate = __le16_to_cpu(vht_cap->vht_mcs.rx_highest);\n\targ->rx_mcs_set = __le16_to_cpu(vht_cap->vht_mcs.rx_mcs_map);\n\targ->tx_max_rate = __le16_to_cpu(vht_cap->vht_mcs.tx_highest);\n\targ->tx_mcs_set = ath11k_peer_assoc_h_vht_limit(\n\t\t__le16_to_cpu(vht_cap->vht_mcs.tx_mcs_map), vht_mcs_mask);\n\n\t \n\targ->tx_mcs_set &= ~IEEE80211_VHT_MCS_SUPPORT_0_11_MASK;\n\targ->tx_mcs_set |= IEEE80211_DISABLE_VHT_MCS_SUPPORT_0_11;\n\n\tif ((arg->tx_mcs_set & IEEE80211_VHT_MCS_NOT_SUPPORTED) ==\n\t\t\tIEEE80211_VHT_MCS_NOT_SUPPORTED)\n\t\targ->peer_vht_caps &= ~IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE;\n\n\t \n\targ->tx_max_mcs_nss = 0xFF;\n\n\tif (arg->peer_phymode == MODE_11AC_VHT160 ||\n\t    arg->peer_phymode == MODE_11AC_VHT80_80) {\n\t\ttx_nss = ath11k_get_nss_160mhz(ar, max_nss);\n\t\trx_nss = min(arg->peer_nss, tx_nss);\n\t\targ->peer_bw_rxnss_override = ATH11K_BW_NSS_MAP_ENABLE;\n\n\t\tif (!rx_nss) {\n\t\t\tath11k_warn(ar->ab, \"invalid max_nss\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (arg->peer_phymode == MODE_11AC_VHT160)\n\t\t\tnss_160 = FIELD_PREP(ATH11K_PEER_RX_NSS_160MHZ, rx_nss - 1);\n\t\telse\n\t\t\tnss_160 = FIELD_PREP(ATH11K_PEER_RX_NSS_80_80MHZ, rx_nss - 1);\n\n\t\targ->peer_bw_rxnss_override |= nss_160;\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_MAC,\n\t\t   \"vht peer %pM max_mpdu %d flags 0x%x nss_override 0x%x\\n\",\n\t\t   sta->addr, arg->peer_max_mpdu, arg->peer_flags,\n\t\t   arg->peer_bw_rxnss_override);\n}\n\nstatic int ath11k_mac_get_max_he_mcs_map(u16 mcs_map, int nss)\n{\n\tswitch ((mcs_map >> (2 * nss)) & 0x3) {\n\tcase IEEE80211_HE_MCS_SUPPORT_0_7: return BIT(8) - 1;\n\tcase IEEE80211_HE_MCS_SUPPORT_0_9: return BIT(10) - 1;\n\tcase IEEE80211_HE_MCS_SUPPORT_0_11: return BIT(12) - 1;\n\t}\n\treturn 0;\n}\n\nstatic u16 ath11k_peer_assoc_h_he_limit(u16 tx_mcs_set,\n\t\t\t\t\tconst u16 he_mcs_limit[NL80211_HE_NSS_MAX])\n{\n\tint idx_limit;\n\tint nss;\n\tu16 mcs_map;\n\tu16 mcs;\n\n\tfor (nss = 0; nss < NL80211_HE_NSS_MAX; nss++) {\n\t\tmcs_map = ath11k_mac_get_max_he_mcs_map(tx_mcs_set, nss) &\n\t\t\the_mcs_limit[nss];\n\n\t\tif (mcs_map)\n\t\t\tidx_limit = fls(mcs_map) - 1;\n\t\telse\n\t\t\tidx_limit = -1;\n\n\t\tswitch (idx_limit) {\n\t\tcase 0 ... 7:\n\t\t\tmcs = IEEE80211_HE_MCS_SUPPORT_0_7;\n\t\t\tbreak;\n\t\tcase 8:\n\t\tcase 9:\n\t\t\tmcs = IEEE80211_HE_MCS_SUPPORT_0_9;\n\t\t\tbreak;\n\t\tcase 10:\n\t\tcase 11:\n\t\t\tmcs = IEEE80211_HE_MCS_SUPPORT_0_11;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON(1);\n\t\t\tfallthrough;\n\t\tcase -1:\n\t\t\tmcs = IEEE80211_HE_MCS_NOT_SUPPORTED;\n\t\t\tbreak;\n\t\t}\n\n\t\ttx_mcs_set &= ~(0x3 << (nss * 2));\n\t\ttx_mcs_set |= mcs << (nss * 2);\n\t}\n\n\treturn tx_mcs_set;\n}\n\nstatic bool\nath11k_peer_assoc_h_he_masked(const u16 *he_mcs_mask)\n{\n\tint nss;\n\n\tfor (nss = 0; nss < NL80211_HE_NSS_MAX; nss++)\n\t\tif (he_mcs_mask[nss])\n\t\t\treturn false;\n\n\treturn true;\n}\n\nstatic void ath11k_peer_assoc_h_he(struct ath11k *ar,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   struct ieee80211_sta *sta,\n\t\t\t\t   struct peer_assoc_params *arg)\n{\n\tstruct ath11k_vif *arvif = ath11k_vif_to_arvif(vif);\n\tstruct cfg80211_chan_def def;\n\tconst struct ieee80211_sta_he_cap *he_cap = &sta->deflink.he_cap;\n\tenum nl80211_band band;\n\tu16 he_mcs_mask[NL80211_HE_NSS_MAX];\n\tu8 max_nss, he_mcs;\n\tu16 he_tx_mcs = 0, v = 0;\n\tint i, he_nss, nss_idx;\n\tbool user_rate_valid = true;\n\tu32 rx_nss, tx_nss, nss_160;\n\tu8 ampdu_factor, rx_mcs_80, rx_mcs_160;\n\tu16 mcs_160_map, mcs_80_map;\n\tbool support_160;\n\n\tif (WARN_ON(ath11k_mac_vif_chan(vif, &def)))\n\t\treturn;\n\n\tif (!he_cap->has_he)\n\t\treturn;\n\n\tband = def.chan->band;\n\tmemcpy(he_mcs_mask, arvif->bitrate_mask.control[band].he_mcs,\n\t       sizeof(he_mcs_mask));\n\n\tif (ath11k_peer_assoc_h_he_masked(he_mcs_mask))\n\t\treturn;\n\n\targ->he_flag = true;\n\tsupport_160 = !!(he_cap->he_cap_elem.phy_cap_info[0] &\n\t\t  IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G);\n\n\t \n\tmcs_160_map = le16_to_cpu(he_cap->he_mcs_nss_supp.rx_mcs_160);\n\tmcs_80_map = le16_to_cpu(he_cap->he_mcs_nss_supp.rx_mcs_80);\n\n\tif (support_160) {\n\t\tfor (i = 7; i >= 0; i--) {\n\t\t\tu8 mcs_160 = (mcs_160_map >> (2 * i)) & 3;\n\n\t\t\tif (mcs_160 != IEEE80211_VHT_MCS_NOT_SUPPORTED) {\n\t\t\t\trx_mcs_160 = i + 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 7; i >= 0; i--) {\n\t\tu8 mcs_80 = (mcs_80_map >> (2 * i)) & 3;\n\n\t\tif (mcs_80 != IEEE80211_VHT_MCS_NOT_SUPPORTED) {\n\t\t\trx_mcs_80 = i + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (support_160)\n\t\tmax_nss = min(rx_mcs_80, rx_mcs_160);\n\telse\n\t\tmax_nss = rx_mcs_80;\n\n\targ->peer_nss = min(sta->deflink.rx_nss, max_nss);\n\n\tmemcpy_and_pad(&arg->peer_he_cap_macinfo,\n\t\t       sizeof(arg->peer_he_cap_macinfo),\n\t\t       he_cap->he_cap_elem.mac_cap_info,\n\t\t       sizeof(he_cap->he_cap_elem.mac_cap_info),\n\t\t       0);\n\tmemcpy_and_pad(&arg->peer_he_cap_phyinfo,\n\t\t       sizeof(arg->peer_he_cap_phyinfo),\n\t\t       he_cap->he_cap_elem.phy_cap_info,\n\t\t       sizeof(he_cap->he_cap_elem.phy_cap_info),\n\t\t       0);\n\targ->peer_he_ops = vif->bss_conf.he_oper.params;\n\n\t \n\targ->peer_he_ops &= 0xffffff;\n\n\t \n\tampdu_factor = u8_get_bits(he_cap->he_cap_elem.mac_cap_info[3],\n\t\t\t\t   IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_MASK);\n\n\tif (ampdu_factor) {\n\t\tif (sta->deflink.vht_cap.vht_supported)\n\t\t\targ->peer_max_mpdu = (1 << (IEEE80211_HE_VHT_MAX_AMPDU_FACTOR +\n\t\t\t\t\t\t    ampdu_factor)) - 1;\n\t\telse if (sta->deflink.ht_cap.ht_supported)\n\t\t\targ->peer_max_mpdu = (1 << (IEEE80211_HE_HT_MAX_AMPDU_FACTOR +\n\t\t\t\t\t\t    ampdu_factor)) - 1;\n\t}\n\n\tif (he_cap->he_cap_elem.phy_cap_info[6] &\n\t    IEEE80211_HE_PHY_CAP6_PPE_THRESHOLD_PRESENT) {\n\t\tint bit = 7;\n\t\tint nss, ru;\n\n\t\targ->peer_ppet.numss_m1 = he_cap->ppe_thres[0] &\n\t\t\t\t\t  IEEE80211_PPE_THRES_NSS_MASK;\n\t\targ->peer_ppet.ru_bit_mask =\n\t\t\t(he_cap->ppe_thres[0] &\n\t\t\t IEEE80211_PPE_THRES_RU_INDEX_BITMASK_MASK) >>\n\t\t\tIEEE80211_PPE_THRES_RU_INDEX_BITMASK_POS;\n\n\t\tfor (nss = 0; nss <= arg->peer_ppet.numss_m1; nss++) {\n\t\t\tfor (ru = 0; ru < 4; ru++) {\n\t\t\t\tu32 val = 0;\n\t\t\t\tint i;\n\n\t\t\t\tif ((arg->peer_ppet.ru_bit_mask & BIT(ru)) == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tfor (i = 0; i < 6; i++) {\n\t\t\t\t\tval >>= 1;\n\t\t\t\t\tval |= ((he_cap->ppe_thres[bit / 8] >>\n\t\t\t\t\t\t (bit % 8)) & 0x1) << 5;\n\t\t\t\t\tbit++;\n\t\t\t\t}\n\t\t\t\targ->peer_ppet.ppet16_ppet8_ru3_ru0[nss] |=\n\t\t\t\t\t\t\t\tval << (ru * 6);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (he_cap->he_cap_elem.mac_cap_info[0] & IEEE80211_HE_MAC_CAP0_TWT_RES)\n\t\targ->twt_responder = true;\n\tif (he_cap->he_cap_elem.mac_cap_info[0] & IEEE80211_HE_MAC_CAP0_TWT_REQ)\n\t\targ->twt_requester = true;\n\n\the_nss =  ath11k_mac_max_he_nss(he_mcs_mask);\n\n\tif (he_nss > sta->deflink.rx_nss) {\n\t\tuser_rate_valid = false;\n\t\tfor (nss_idx = sta->deflink.rx_nss - 1; nss_idx >= 0; nss_idx--) {\n\t\t\tif (he_mcs_mask[nss_idx]) {\n\t\t\t\tuser_rate_valid = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!user_rate_valid) {\n\t\tath11k_dbg(ar->ab, ATH11K_DBG_MAC, \"setting he range mcs value to peer supported nss %d for peer %pM\\n\",\n\t\t\t   sta->deflink.rx_nss, sta->addr);\n\t\the_mcs_mask[sta->deflink.rx_nss - 1] = he_mcs_mask[he_nss - 1];\n\t}\n\n\tswitch (sta->deflink.bandwidth) {\n\tcase IEEE80211_STA_RX_BW_160:\n\t\tif (he_cap->he_cap_elem.phy_cap_info[0] &\n\t\t    IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G) {\n\t\t\tv = le16_to_cpu(he_cap->he_mcs_nss_supp.rx_mcs_80p80);\n\t\t\tv = ath11k_peer_assoc_h_he_limit(v, he_mcs_mask);\n\t\t\targ->peer_he_rx_mcs_set[WMI_HECAP_TXRX_MCS_NSS_IDX_80_80] = v;\n\n\t\t\tv = le16_to_cpu(he_cap->he_mcs_nss_supp.tx_mcs_80p80);\n\t\t\targ->peer_he_tx_mcs_set[WMI_HECAP_TXRX_MCS_NSS_IDX_80_80] = v;\n\n\t\t\targ->peer_he_mcs_count++;\n\t\t\the_tx_mcs = v;\n\t\t}\n\t\tv = le16_to_cpu(he_cap->he_mcs_nss_supp.rx_mcs_160);\n\t\targ->peer_he_rx_mcs_set[WMI_HECAP_TXRX_MCS_NSS_IDX_160] = v;\n\n\t\tv = le16_to_cpu(he_cap->he_mcs_nss_supp.tx_mcs_160);\n\t\tv = ath11k_peer_assoc_h_he_limit(v, he_mcs_mask);\n\t\targ->peer_he_tx_mcs_set[WMI_HECAP_TXRX_MCS_NSS_IDX_160] = v;\n\n\t\targ->peer_he_mcs_count++;\n\t\tif (!he_tx_mcs)\n\t\t\the_tx_mcs = v;\n\t\tfallthrough;\n\n\tdefault:\n\t\tv = le16_to_cpu(he_cap->he_mcs_nss_supp.rx_mcs_80);\n\t\targ->peer_he_rx_mcs_set[WMI_HECAP_TXRX_MCS_NSS_IDX_80] = v;\n\n\t\tv = le16_to_cpu(he_cap->he_mcs_nss_supp.tx_mcs_80);\n\t\tv = ath11k_peer_assoc_h_he_limit(v, he_mcs_mask);\n\t\targ->peer_he_tx_mcs_set[WMI_HECAP_TXRX_MCS_NSS_IDX_80] = v;\n\n\t\targ->peer_he_mcs_count++;\n\t\tif (!he_tx_mcs)\n\t\t\the_tx_mcs = v;\n\t\tbreak;\n\t}\n\n\t \n\tfor (i = 0, max_nss = 0; i < NL80211_HE_NSS_MAX; i++) {\n\t\the_mcs = he_tx_mcs >> (2 * i) & 3;\n\n\t\t \n\t\tif (he_mcs != IEEE80211_HE_MCS_NOT_SUPPORTED ||\n\t\t    he_mcs_mask[i])\n\t\t\tmax_nss = i + 1;\n\t}\n\targ->peer_nss = min(sta->deflink.rx_nss, max_nss);\n\n\tif (arg->peer_phymode == MODE_11AX_HE160 ||\n\t    arg->peer_phymode == MODE_11AX_HE80_80) {\n\t\ttx_nss = ath11k_get_nss_160mhz(ar, max_nss);\n\t\trx_nss = min(arg->peer_nss, tx_nss);\n\t\targ->peer_bw_rxnss_override = ATH11K_BW_NSS_MAP_ENABLE;\n\n\t\tif (!rx_nss) {\n\t\t\tath11k_warn(ar->ab, \"invalid max_nss\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tif (arg->peer_phymode == MODE_11AX_HE160)\n\t\t\tnss_160 = FIELD_PREP(ATH11K_PEER_RX_NSS_160MHZ, rx_nss - 1);\n\t\telse\n\t\t\tnss_160 = FIELD_PREP(ATH11K_PEER_RX_NSS_80_80MHZ, rx_nss - 1);\n\n\t\targ->peer_bw_rxnss_override |= nss_160;\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_MAC,\n\t\t   \"he peer %pM nss %d mcs cnt %d nss_override 0x%x\\n\",\n\t\t   sta->addr, arg->peer_nss,\n\t\t   arg->peer_he_mcs_count,\n\t\t   arg->peer_bw_rxnss_override);\n}\n\nstatic void ath11k_peer_assoc_h_he_6ghz(struct ath11k *ar,\n\t\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\t\tstruct ieee80211_sta *sta,\n\t\t\t\t\tstruct peer_assoc_params *arg)\n{\n\tconst struct ieee80211_sta_he_cap *he_cap = &sta->deflink.he_cap;\n\tstruct cfg80211_chan_def def;\n\tenum nl80211_band band;\n\tu8  ampdu_factor;\n\n\tif (WARN_ON(ath11k_mac_vif_chan(vif, &def)))\n\t\treturn;\n\n\tband = def.chan->band;\n\n\tif (!arg->he_flag || band != NL80211_BAND_6GHZ || !sta->deflink.he_6ghz_capa.capa)\n\t\treturn;\n\n\tif (sta->deflink.bandwidth == IEEE80211_STA_RX_BW_40)\n\t\targ->bw_40 = true;\n\n\tif (sta->deflink.bandwidth == IEEE80211_STA_RX_BW_80)\n\t\targ->bw_80 = true;\n\n\tif (sta->deflink.bandwidth == IEEE80211_STA_RX_BW_160)\n\t\targ->bw_160 = true;\n\n\targ->peer_he_caps_6ghz = le16_to_cpu(sta->deflink.he_6ghz_capa.capa);\n\targ->peer_mpdu_density =\n\t\tath11k_parse_mpdudensity(FIELD_GET(IEEE80211_HE_6GHZ_CAP_MIN_MPDU_START,\n\t\t\t\t\t\t   arg->peer_he_caps_6ghz));\n\n\t \n\tampdu_factor = FIELD_GET(IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_MASK,\n\t\t\t\t he_cap->he_cap_elem.mac_cap_info[3]) +\n\t\t\tFIELD_GET(IEEE80211_HE_6GHZ_CAP_MAX_AMPDU_LEN_EXP,\n\t\t\t\t  arg->peer_he_caps_6ghz);\n\n\targ->peer_max_mpdu = (1u << (IEEE80211_HE_6GHZ_MAX_AMPDU_FACTOR +\n\t\t\t\t     ampdu_factor)) - 1;\n}\n\nstatic void ath11k_peer_assoc_h_smps(struct ieee80211_sta *sta,\n\t\t\t\t     struct peer_assoc_params *arg)\n{\n\tconst struct ieee80211_sta_ht_cap *ht_cap = &sta->deflink.ht_cap;\n\tint smps;\n\n\tif (!ht_cap->ht_supported && !sta->deflink.he_6ghz_capa.capa)\n\t\treturn;\n\n\tif (ht_cap->ht_supported) {\n\t\tsmps = ht_cap->cap & IEEE80211_HT_CAP_SM_PS;\n\t\tsmps >>= IEEE80211_HT_CAP_SM_PS_SHIFT;\n\t} else {\n\t\tsmps = le16_get_bits(sta->deflink.he_6ghz_capa.capa,\n\t\t\t\t     IEEE80211_HE_6GHZ_CAP_SM_PS);\n\t}\n\n\tswitch (smps) {\n\tcase WLAN_HT_CAP_SM_PS_STATIC:\n\t\targ->static_mimops_flag = true;\n\t\tbreak;\n\tcase WLAN_HT_CAP_SM_PS_DYNAMIC:\n\t\targ->dynamic_mimops_flag = true;\n\t\tbreak;\n\tcase WLAN_HT_CAP_SM_PS_DISABLED:\n\t\targ->spatial_mux_flag = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void ath11k_peer_assoc_h_qos(struct ath11k *ar,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct ieee80211_sta *sta,\n\t\t\t\t    struct peer_assoc_params *arg)\n{\n\tstruct ath11k_vif *arvif = ath11k_vif_to_arvif(vif);\n\n\tswitch (arvif->vdev_type) {\n\tcase WMI_VDEV_TYPE_AP:\n\t\tif (sta->wme) {\n\t\t\t \n\t\t\targ->is_wme_set = true;\n\t\t\targ->qos_flag = true;\n\t\t}\n\n\t\tif (sta->wme && sta->uapsd_queues) {\n\t\t\t \n\t\t\targ->is_wme_set = true;\n\t\t\targ->apsd_flag = true;\n\t\t\targ->peer_rate_caps |= WMI_HOST_RC_UAPSD_FLAG;\n\t\t}\n\t\tbreak;\n\tcase WMI_VDEV_TYPE_STA:\n\t\tif (sta->wme) {\n\t\t\targ->is_wme_set = true;\n\t\t\targ->qos_flag = true;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_MAC, \"peer %pM qos %d\\n\",\n\t\t   sta->addr, arg->qos_flag);\n}\n\nstatic int ath11k_peer_assoc_qos_ap(struct ath11k *ar,\n\t\t\t\t    struct ath11k_vif *arvif,\n\t\t\t\t    struct ieee80211_sta *sta)\n{\n\tstruct ap_ps_params params;\n\tu32 max_sp;\n\tu32 uapsd;\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tparams.vdev_id = arvif->vdev_id;\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_MAC, \"uapsd_queues 0x%x max_sp %d\\n\",\n\t\t   sta->uapsd_queues, sta->max_sp);\n\n\tuapsd = 0;\n\tif (sta->uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_VO)\n\t\tuapsd |= WMI_AP_PS_UAPSD_AC3_DELIVERY_EN |\n\t\t\t WMI_AP_PS_UAPSD_AC3_TRIGGER_EN;\n\tif (sta->uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_VI)\n\t\tuapsd |= WMI_AP_PS_UAPSD_AC2_DELIVERY_EN |\n\t\t\t WMI_AP_PS_UAPSD_AC2_TRIGGER_EN;\n\tif (sta->uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_BK)\n\t\tuapsd |= WMI_AP_PS_UAPSD_AC1_DELIVERY_EN |\n\t\t\t WMI_AP_PS_UAPSD_AC1_TRIGGER_EN;\n\tif (sta->uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_BE)\n\t\tuapsd |= WMI_AP_PS_UAPSD_AC0_DELIVERY_EN |\n\t\t\t WMI_AP_PS_UAPSD_AC0_TRIGGER_EN;\n\n\tmax_sp = 0;\n\tif (sta->max_sp < MAX_WMI_AP_PS_PEER_PARAM_MAX_SP)\n\t\tmax_sp = sta->max_sp;\n\n\tparams.param = WMI_AP_PS_PEER_PARAM_UAPSD;\n\tparams.value = uapsd;\n\tret = ath11k_wmi_send_set_ap_ps_param_cmd(ar, sta->addr, &params);\n\tif (ret)\n\t\tgoto err;\n\n\tparams.param = WMI_AP_PS_PEER_PARAM_MAX_SP;\n\tparams.value = max_sp;\n\tret = ath11k_wmi_send_set_ap_ps_param_cmd(ar, sta->addr, &params);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\tparams.param = WMI_AP_PS_PEER_PARAM_SIFS_RESP_FRMTYPE;\n\tparams.value = DISABLE_SIFS_RESPONSE_TRIGGER;\n\tret = ath11k_wmi_send_set_ap_ps_param_cmd(ar, sta->addr, &params);\n\tif (ret)\n\t\tgoto err;\n\n\tparams.param = WMI_AP_PS_PEER_PARAM_SIFS_RESP_UAPSD;\n\tparams.value = DISABLE_SIFS_RESPONSE_TRIGGER;\n\tret = ath11k_wmi_send_set_ap_ps_param_cmd(ar, sta->addr, &params);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tath11k_warn(ar->ab, \"failed to set ap ps peer param %d for vdev %i: %d\\n\",\n\t\t    params.param, arvif->vdev_id, ret);\n\treturn ret;\n}\n\nstatic bool ath11k_mac_sta_has_ofdm_only(struct ieee80211_sta *sta)\n{\n\treturn sta->deflink.supp_rates[NL80211_BAND_2GHZ] >>\n\t       ATH11K_MAC_FIRST_OFDM_RATE_IDX;\n}\n\nstatic enum wmi_phy_mode ath11k_mac_get_phymode_vht(struct ath11k *ar,\n\t\t\t\t\t\t    struct ieee80211_sta *sta)\n{\n\tif (sta->deflink.bandwidth == IEEE80211_STA_RX_BW_160) {\n\t\tswitch (sta->deflink.vht_cap.cap &\n\t\t\tIEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK) {\n\t\tcase IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ:\n\t\t\treturn MODE_11AC_VHT160;\n\t\tcase IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ:\n\t\t\treturn MODE_11AC_VHT80_80;\n\t\tdefault:\n\t\t\t \n\t\t\treturn MODE_11AC_VHT160;\n\t\t}\n\t}\n\n\tif (sta->deflink.bandwidth == IEEE80211_STA_RX_BW_80)\n\t\treturn MODE_11AC_VHT80;\n\n\tif (sta->deflink.bandwidth == IEEE80211_STA_RX_BW_40)\n\t\treturn MODE_11AC_VHT40;\n\n\tif (sta->deflink.bandwidth == IEEE80211_STA_RX_BW_20)\n\t\treturn MODE_11AC_VHT20;\n\n\treturn MODE_UNKNOWN;\n}\n\nstatic enum wmi_phy_mode ath11k_mac_get_phymode_he(struct ath11k *ar,\n\t\t\t\t\t\t   struct ieee80211_sta *sta)\n{\n\tif (sta->deflink.bandwidth == IEEE80211_STA_RX_BW_160) {\n\t\tif (sta->deflink.he_cap.he_cap_elem.phy_cap_info[0] &\n\t\t     IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G)\n\t\t\treturn MODE_11AX_HE160;\n\t\telse if (sta->deflink.he_cap.he_cap_elem.phy_cap_info[0] &\n\t\t\t IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G)\n\t\t\treturn MODE_11AX_HE80_80;\n\t\t \n\t\treturn MODE_11AX_HE160;\n\t}\n\n\tif (sta->deflink.bandwidth == IEEE80211_STA_RX_BW_80)\n\t\treturn MODE_11AX_HE80;\n\n\tif (sta->deflink.bandwidth == IEEE80211_STA_RX_BW_40)\n\t\treturn MODE_11AX_HE40;\n\n\tif (sta->deflink.bandwidth == IEEE80211_STA_RX_BW_20)\n\t\treturn MODE_11AX_HE20;\n\n\treturn MODE_UNKNOWN;\n}\n\nstatic void ath11k_peer_assoc_h_phymode(struct ath11k *ar,\n\t\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\t\tstruct ieee80211_sta *sta,\n\t\t\t\t\tstruct peer_assoc_params *arg)\n{\n\tstruct ath11k_vif *arvif = ath11k_vif_to_arvif(vif);\n\tstruct cfg80211_chan_def def;\n\tenum nl80211_band band;\n\tconst u8 *ht_mcs_mask;\n\tconst u16 *vht_mcs_mask;\n\tconst u16 *he_mcs_mask;\n\tenum wmi_phy_mode phymode = MODE_UNKNOWN;\n\n\tif (WARN_ON(ath11k_mac_vif_chan(vif, &def)))\n\t\treturn;\n\n\tband = def.chan->band;\n\tht_mcs_mask = arvif->bitrate_mask.control[band].ht_mcs;\n\tvht_mcs_mask = arvif->bitrate_mask.control[band].vht_mcs;\n\the_mcs_mask = arvif->bitrate_mask.control[band].he_mcs;\n\n\tswitch (band) {\n\tcase NL80211_BAND_2GHZ:\n\t\tif (sta->deflink.he_cap.has_he &&\n\t\t    !ath11k_peer_assoc_h_he_masked(he_mcs_mask)) {\n\t\t\tif (sta->deflink.bandwidth == IEEE80211_STA_RX_BW_80)\n\t\t\t\tphymode = MODE_11AX_HE80_2G;\n\t\t\telse if (sta->deflink.bandwidth == IEEE80211_STA_RX_BW_40)\n\t\t\t\tphymode = MODE_11AX_HE40_2G;\n\t\t\telse\n\t\t\t\tphymode = MODE_11AX_HE20_2G;\n\t\t} else if (sta->deflink.vht_cap.vht_supported &&\n\t\t\t   !ath11k_peer_assoc_h_vht_masked(vht_mcs_mask)) {\n\t\t\tif (sta->deflink.bandwidth == IEEE80211_STA_RX_BW_40)\n\t\t\t\tphymode = MODE_11AC_VHT40;\n\t\t\telse\n\t\t\t\tphymode = MODE_11AC_VHT20;\n\t\t} else if (sta->deflink.ht_cap.ht_supported &&\n\t\t\t   !ath11k_peer_assoc_h_ht_masked(ht_mcs_mask)) {\n\t\t\tif (sta->deflink.bandwidth == IEEE80211_STA_RX_BW_40)\n\t\t\t\tphymode = MODE_11NG_HT40;\n\t\t\telse\n\t\t\t\tphymode = MODE_11NG_HT20;\n\t\t} else if (ath11k_mac_sta_has_ofdm_only(sta)) {\n\t\t\tphymode = MODE_11G;\n\t\t} else {\n\t\t\tphymode = MODE_11B;\n\t\t}\n\t\tbreak;\n\tcase NL80211_BAND_5GHZ:\n\tcase NL80211_BAND_6GHZ:\n\t\t \n\t\tif (sta->deflink.he_cap.has_he &&\n\t\t    !ath11k_peer_assoc_h_he_masked(he_mcs_mask)) {\n\t\t\tphymode = ath11k_mac_get_phymode_he(ar, sta);\n\t\t} else if (sta->deflink.vht_cap.vht_supported &&\n\t\t\t   !ath11k_peer_assoc_h_vht_masked(vht_mcs_mask)) {\n\t\t\tphymode = ath11k_mac_get_phymode_vht(ar, sta);\n\t\t} else if (sta->deflink.ht_cap.ht_supported &&\n\t\t\t   !ath11k_peer_assoc_h_ht_masked(ht_mcs_mask)) {\n\t\t\tif (sta->deflink.bandwidth >= IEEE80211_STA_RX_BW_40)\n\t\t\t\tphymode = MODE_11NA_HT40;\n\t\t\telse\n\t\t\t\tphymode = MODE_11NA_HT20;\n\t\t} else {\n\t\t\tphymode = MODE_11A;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_MAC, \"peer %pM phymode %s\\n\",\n\t\t   sta->addr, ath11k_wmi_phymode_str(phymode));\n\n\targ->peer_phymode = phymode;\n\tWARN_ON(phymode == MODE_UNKNOWN);\n}\n\nstatic void ath11k_peer_assoc_prepare(struct ath11k *ar,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      struct ieee80211_sta *sta,\n\t\t\t\t      struct peer_assoc_params *arg,\n\t\t\t\t      bool reassoc)\n{\n\tstruct ath11k_sta *arsta;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tarsta = (struct ath11k_sta *)sta->drv_priv;\n\n\tmemset(arg, 0, sizeof(*arg));\n\n\treinit_completion(&ar->peer_assoc_done);\n\n\targ->peer_new_assoc = !reassoc;\n\tath11k_peer_assoc_h_basic(ar, vif, sta, arg);\n\tath11k_peer_assoc_h_crypto(ar, vif, sta, arg);\n\tath11k_peer_assoc_h_rates(ar, vif, sta, arg);\n\tath11k_peer_assoc_h_phymode(ar, vif, sta, arg);\n\tath11k_peer_assoc_h_ht(ar, vif, sta, arg);\n\tath11k_peer_assoc_h_vht(ar, vif, sta, arg);\n\tath11k_peer_assoc_h_he(ar, vif, sta, arg);\n\tath11k_peer_assoc_h_he_6ghz(ar, vif, sta, arg);\n\tath11k_peer_assoc_h_qos(ar, vif, sta, arg);\n\tath11k_peer_assoc_h_smps(sta, arg);\n\n\tarsta->peer_nss = arg->peer_nss;\n\n\t \n}\n\nstatic int ath11k_setup_peer_smps(struct ath11k *ar, struct ath11k_vif *arvif,\n\t\t\t\t  const u8 *addr,\n\t\t\t\t  const struct ieee80211_sta_ht_cap *ht_cap,\n\t\t\t\t  u16 he_6ghz_capa)\n{\n\tint smps;\n\n\tif (!ht_cap->ht_supported && !he_6ghz_capa)\n\t\treturn 0;\n\n\tif (ht_cap->ht_supported) {\n\t\tsmps = ht_cap->cap & IEEE80211_HT_CAP_SM_PS;\n\t\tsmps >>= IEEE80211_HT_CAP_SM_PS_SHIFT;\n\t} else {\n\t\tsmps = FIELD_GET(IEEE80211_HE_6GHZ_CAP_SM_PS, he_6ghz_capa);\n\t}\n\n\tif (smps >= ARRAY_SIZE(ath11k_smps_map))\n\t\treturn -EINVAL;\n\n\treturn ath11k_wmi_set_peer_param(ar, addr, arvif->vdev_id,\n\t\t\t\t\t WMI_PEER_MIMO_PS_STATE,\n\t\t\t\t\t ath11k_smps_map[smps]);\n}\n\nstatic bool ath11k_mac_set_he_txbf_conf(struct ath11k_vif *arvif)\n{\n\tstruct ath11k *ar = arvif->ar;\n\tu32 param, value;\n\tint ret;\n\n\tif (!arvif->vif->bss_conf.he_support)\n\t\treturn true;\n\n\tparam = WMI_VDEV_PARAM_SET_HEMU_MODE;\n\tvalue = 0;\n\tif (arvif->vif->bss_conf.he_su_beamformer) {\n\t\tvalue |= FIELD_PREP(HE_MODE_SU_TX_BFER, HE_SU_BFER_ENABLE);\n\t\tif (arvif->vif->bss_conf.he_mu_beamformer &&\n\t\t    arvif->vdev_type == WMI_VDEV_TYPE_AP)\n\t\t\tvalue |= FIELD_PREP(HE_MODE_MU_TX_BFER, HE_MU_BFER_ENABLE);\n\t}\n\n\tif (arvif->vif->type != NL80211_IFTYPE_MESH_POINT) {\n\t\tvalue |= FIELD_PREP(HE_MODE_DL_OFDMA, HE_DL_MUOFDMA_ENABLE) |\n\t\t\t FIELD_PREP(HE_MODE_UL_OFDMA, HE_UL_MUOFDMA_ENABLE);\n\n\t\tif (arvif->vif->bss_conf.he_full_ul_mumimo)\n\t\t\tvalue |= FIELD_PREP(HE_MODE_UL_MUMIMO, HE_UL_MUMIMO_ENABLE);\n\n\t\tif (arvif->vif->bss_conf.he_su_beamformee)\n\t\t\tvalue |= FIELD_PREP(HE_MODE_SU_TX_BFEE, HE_SU_BFEE_ENABLE);\n\t}\n\n\tret = ath11k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id, param, value);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to set vdev %d HE MU mode: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn false;\n\t}\n\n\tparam = WMI_VDEV_PARAM_SET_HE_SOUNDING_MODE;\n\tvalue =\tFIELD_PREP(HE_VHT_SOUNDING_MODE, HE_VHT_SOUNDING_MODE_ENABLE) |\n\t\tFIELD_PREP(HE_TRIG_NONTRIG_SOUNDING_MODE,\n\t\t\t   HE_TRIG_NONTRIG_SOUNDING_MODE_ENABLE);\n\tret = ath11k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id,\n\t\t\t\t\t    param, value);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to set vdev %d sounding mode: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool ath11k_mac_vif_recalc_sta_he_txbf(struct ath11k *ar,\n\t\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t\t      struct ieee80211_sta_he_cap *he_cap)\n{\n\tstruct ath11k_vif *arvif = ath11k_vif_to_arvif(vif);\n\tstruct ieee80211_he_cap_elem he_cap_elem = {0};\n\tstruct ieee80211_sta_he_cap *cap_band = NULL;\n\tstruct cfg80211_chan_def def;\n\tu32 param = WMI_VDEV_PARAM_SET_HEMU_MODE;\n\tu32 hemode = 0;\n\tint ret;\n\n\tif (!vif->bss_conf.he_support)\n\t\treturn true;\n\n\tif (vif->type != NL80211_IFTYPE_STATION)\n\t\treturn false;\n\n\tif (WARN_ON(ath11k_mac_vif_chan(vif, &def)))\n\t\treturn false;\n\n\tif (def.chan->band == NL80211_BAND_2GHZ)\n\t\tcap_band = &ar->mac.iftype[NL80211_BAND_2GHZ][vif->type].he_cap;\n\telse\n\t\tcap_band = &ar->mac.iftype[NL80211_BAND_5GHZ][vif->type].he_cap;\n\n\tmemcpy(&he_cap_elem, &cap_band->he_cap_elem, sizeof(he_cap_elem));\n\n\tif (HECAP_PHY_SUBFME_GET(he_cap_elem.phy_cap_info)) {\n\t\tif (HECAP_PHY_SUBFMR_GET(he_cap->he_cap_elem.phy_cap_info))\n\t\t\themode |= FIELD_PREP(HE_MODE_SU_TX_BFEE, HE_SU_BFEE_ENABLE);\n\t\tif (HECAP_PHY_MUBFMR_GET(he_cap->he_cap_elem.phy_cap_info))\n\t\t\themode |= FIELD_PREP(HE_MODE_MU_TX_BFEE, HE_MU_BFEE_ENABLE);\n\t}\n\n\tif (vif->type != NL80211_IFTYPE_MESH_POINT) {\n\t\themode |= FIELD_PREP(HE_MODE_DL_OFDMA, HE_DL_MUOFDMA_ENABLE) |\n\t\t\t  FIELD_PREP(HE_MODE_UL_OFDMA, HE_UL_MUOFDMA_ENABLE);\n\n\t\tif (HECAP_PHY_ULMUMIMO_GET(he_cap_elem.phy_cap_info))\n\t\t\tif (HECAP_PHY_ULMUMIMO_GET(he_cap->he_cap_elem.phy_cap_info))\n\t\t\t\themode |= FIELD_PREP(HE_MODE_UL_MUMIMO,\n\t\t\t\t\t\t     HE_UL_MUMIMO_ENABLE);\n\n\t\tif (FIELD_GET(HE_MODE_MU_TX_BFEE, hemode))\n\t\t\themode |= FIELD_PREP(HE_MODE_SU_TX_BFEE, HE_SU_BFEE_ENABLE);\n\n\t\tif (FIELD_GET(HE_MODE_MU_TX_BFER, hemode))\n\t\t\themode |= FIELD_PREP(HE_MODE_SU_TX_BFER, HE_SU_BFER_ENABLE);\n\t}\n\n\tret = ath11k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id, param, hemode);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to submit vdev param txbf 0x%x: %d\\n\",\n\t\t\t    hemode, ret);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void ath11k_bss_assoc(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     struct ieee80211_bss_conf *bss_conf)\n{\n\tstruct ath11k *ar = hw->priv;\n\tstruct ath11k_vif *arvif = ath11k_vif_to_arvif(vif);\n\tstruct peer_assoc_params peer_arg;\n\tstruct ieee80211_sta *ap_sta;\n\tstruct ath11k_peer *peer;\n\tbool is_auth = false;\n\tstruct ieee80211_sta_he_cap  he_cap;\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_MAC, \"vdev %i assoc bssid %pM aid %d\\n\",\n\t\t   arvif->vdev_id, arvif->bssid, arvif->aid);\n\n\trcu_read_lock();\n\n\tap_sta = ieee80211_find_sta(vif, bss_conf->bssid);\n\tif (!ap_sta) {\n\t\tath11k_warn(ar->ab, \"failed to find station entry for bss %pM vdev %i\\n\",\n\t\t\t    bss_conf->bssid, arvif->vdev_id);\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t \n\the_cap  = ap_sta->deflink.he_cap;\n\n\tath11k_peer_assoc_prepare(ar, vif, ap_sta, &peer_arg, false);\n\n\trcu_read_unlock();\n\n\tpeer_arg.is_assoc = true;\n\tret = ath11k_wmi_send_peer_assoc_cmd(ar, &peer_arg);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to run peer assoc for %pM vdev %i: %d\\n\",\n\t\t\t    bss_conf->bssid, arvif->vdev_id, ret);\n\t\treturn;\n\t}\n\n\tif (!wait_for_completion_timeout(&ar->peer_assoc_done, 1 * HZ)) {\n\t\tath11k_warn(ar->ab, \"failed to get peer assoc conf event for %pM vdev %i\\n\",\n\t\t\t    bss_conf->bssid, arvif->vdev_id);\n\t\treturn;\n\t}\n\n\tret = ath11k_setup_peer_smps(ar, arvif, bss_conf->bssid,\n\t\t\t\t     &ap_sta->deflink.ht_cap,\n\t\t\t\t     le16_to_cpu(ap_sta->deflink.he_6ghz_capa.capa));\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to setup peer SMPS for vdev %d: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn;\n\t}\n\n\tif (!ath11k_mac_vif_recalc_sta_he_txbf(ar, vif, &he_cap)) {\n\t\tath11k_warn(ar->ab, \"failed to recalc he txbf for vdev %i on bss %pM\\n\",\n\t\t\t    arvif->vdev_id, bss_conf->bssid);\n\t\treturn;\n\t}\n\n\tWARN_ON(arvif->is_up);\n\n\tarvif->aid = vif->cfg.aid;\n\tether_addr_copy(arvif->bssid, bss_conf->bssid);\n\n\tret = ath11k_wmi_vdev_up(ar, arvif->vdev_id, arvif->aid, arvif->bssid,\n\t\t\t\t NULL, 0, 0);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to set vdev %d up: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn;\n\t}\n\n\tarvif->is_up = true;\n\tarvif->rekey_data.enable_offload = false;\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_MAC,\n\t\t   \"vdev %d up (associated) bssid %pM aid %d\\n\",\n\t\t   arvif->vdev_id, bss_conf->bssid, vif->cfg.aid);\n\n\tspin_lock_bh(&ar->ab->base_lock);\n\n\tpeer = ath11k_peer_find(ar->ab, arvif->vdev_id, arvif->bssid);\n\tif (peer && peer->is_authorized)\n\t\tis_auth = true;\n\n\tspin_unlock_bh(&ar->ab->base_lock);\n\n\tif (is_auth) {\n\t\tret = ath11k_wmi_set_peer_param(ar, arvif->bssid,\n\t\t\t\t\t\tarvif->vdev_id,\n\t\t\t\t\t\tWMI_PEER_AUTHORIZE,\n\t\t\t\t\t\t1);\n\t\tif (ret)\n\t\t\tath11k_warn(ar->ab, \"Unable to authorize BSS peer: %d\\n\", ret);\n\t}\n\n\tret = ath11k_wmi_send_obss_spr_cmd(ar, arvif->vdev_id,\n\t\t\t\t\t   &bss_conf->he_obss_pd);\n\tif (ret)\n\t\tath11k_warn(ar->ab, \"failed to set vdev %i OBSS PD parameters: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\n\tret = ath11k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id,\n\t\t\t\t\t    WMI_VDEV_PARAM_DTIM_POLICY,\n\t\t\t\t\t    WMI_DTIM_POLICY_STICK);\n\tif (ret)\n\t\tath11k_warn(ar->ab, \"failed to set vdev %d dtim policy: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\n\tath11k_mac_11d_scan_stop_all(ar->ab);\n}\n\nstatic void ath11k_bss_disassoc(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif)\n{\n\tstruct ath11k *ar = hw->priv;\n\tstruct ath11k_vif *arvif = ath11k_vif_to_arvif(vif);\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_MAC, \"vdev %i disassoc bssid %pM\\n\",\n\t\t   arvif->vdev_id, arvif->bssid);\n\n\tret = ath11k_wmi_vdev_down(ar, arvif->vdev_id);\n\tif (ret)\n\t\tath11k_warn(ar->ab, \"failed to down vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\n\tarvif->is_up = false;\n\n\tmemset(&arvif->rekey_data, 0, sizeof(arvif->rekey_data));\n\n\tcancel_delayed_work_sync(&arvif->connection_loss_work);\n}\n\nstatic u32 ath11k_mac_get_rate_hw_value(int bitrate)\n{\n\tu32 preamble;\n\tu16 hw_value;\n\tint rate;\n\tsize_t i;\n\n\tif (ath11k_mac_bitrate_is_cck(bitrate))\n\t\tpreamble = WMI_RATE_PREAMBLE_CCK;\n\telse\n\t\tpreamble = WMI_RATE_PREAMBLE_OFDM;\n\n\tfor (i = 0; i < ARRAY_SIZE(ath11k_legacy_rates); i++) {\n\t\tif (ath11k_legacy_rates[i].bitrate != bitrate)\n\t\t\tcontinue;\n\n\t\thw_value = ath11k_legacy_rates[i].hw_value;\n\t\trate = ATH11K_HW_RATE_CODE(hw_value, 0, preamble);\n\n\t\treturn rate;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic void ath11k_recalculate_mgmt_rate(struct ath11k *ar,\n\t\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t\t struct cfg80211_chan_def *def)\n{\n\tstruct ath11k_vif *arvif = ath11k_vif_to_arvif(vif);\n\tconst struct ieee80211_supported_band *sband;\n\tu8 basic_rate_idx;\n\tint hw_rate_code;\n\tu32 vdev_param;\n\tu16 bitrate;\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tsband = ar->hw->wiphy->bands[def->chan->band];\n\tbasic_rate_idx = ffs(vif->bss_conf.basic_rates) - 1;\n\tbitrate = sband->bitrates[basic_rate_idx].bitrate;\n\n\thw_rate_code = ath11k_mac_get_rate_hw_value(bitrate);\n\tif (hw_rate_code < 0) {\n\t\tath11k_warn(ar->ab, \"bitrate not supported %d\\n\", bitrate);\n\t\treturn;\n\t}\n\n\tvdev_param = WMI_VDEV_PARAM_MGMT_RATE;\n\tret = ath11k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id, vdev_param,\n\t\t\t\t\t    hw_rate_code);\n\tif (ret)\n\t\tath11k_warn(ar->ab, \"failed to set mgmt tx rate %d\\n\", ret);\n\n\t \n\tar->hw_rate_code = hw_rate_code;\n\n\tvdev_param = WMI_VDEV_PARAM_BEACON_RATE;\n\tret = ath11k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id, vdev_param,\n\t\t\t\t\t    hw_rate_code);\n\tif (ret)\n\t\tath11k_warn(ar->ab, \"failed to set beacon tx rate %d\\n\", ret);\n}\n\nstatic int ath11k_mac_fils_discovery(struct ath11k_vif *arvif,\n\t\t\t\t     struct ieee80211_bss_conf *info)\n{\n\tstruct ath11k *ar = arvif->ar;\n\tstruct sk_buff *tmpl;\n\tint ret;\n\tu32 interval;\n\tbool unsol_bcast_probe_resp_enabled = false;\n\n\tif (info->fils_discovery.max_interval) {\n\t\tinterval = info->fils_discovery.max_interval;\n\n\t\ttmpl = ieee80211_get_fils_discovery_tmpl(ar->hw, arvif->vif);\n\t\tif (tmpl)\n\t\t\tret = ath11k_wmi_fils_discovery_tmpl(ar, arvif->vdev_id,\n\t\t\t\t\t\t\t     tmpl);\n\t} else if (info->unsol_bcast_probe_resp_interval) {\n\t\tunsol_bcast_probe_resp_enabled = 1;\n\t\tinterval = info->unsol_bcast_probe_resp_interval;\n\n\t\ttmpl = ieee80211_get_unsol_bcast_probe_resp_tmpl(ar->hw,\n\t\t\t\t\t\t\t\t arvif->vif);\n\t\tif (tmpl)\n\t\t\tret = ath11k_wmi_probe_resp_tmpl(ar, arvif->vdev_id,\n\t\t\t\t\t\t\t tmpl);\n\t} else {  \n\t\treturn ath11k_wmi_fils_discovery(ar, arvif->vdev_id, 0, false);\n\t}\n\n\tif (!tmpl) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"mac vdev %i failed to retrieve %s template\\n\",\n\t\t\t    arvif->vdev_id, (unsol_bcast_probe_resp_enabled ?\n\t\t\t    \"unsolicited broadcast probe response\" :\n\t\t\t    \"FILS discovery\"));\n\t\treturn -EPERM;\n\t}\n\tkfree_skb(tmpl);\n\n\tif (!ret)\n\t\tret = ath11k_wmi_fils_discovery(ar, arvif->vdev_id, interval,\n\t\t\t\t\t\tunsol_bcast_probe_resp_enabled);\n\n\treturn ret;\n}\n\nstatic int ath11k_mac_config_obss_pd(struct ath11k *ar,\n\t\t\t\t     struct ieee80211_he_obss_pd *he_obss_pd)\n{\n\tu32 bitmap[2], param_id, param_val, pdev_id;\n\tint ret;\n\ts8 non_srg_th = 0, srg_th = 0;\n\n\tpdev_id = ar->pdev->pdev_id;\n\n\t \n\tparam_id = WMI_PDEV_PARAM_SET_CMD_OBSS_PD_THRESHOLD;\n\tif (test_bit(ATH11K_FLAG_MONITOR_STARTED, &ar->monitor_flags)) {\n\t\tret = ath11k_wmi_pdev_set_param(ar, param_id, 0, pdev_id);\n\t\tif (ret)\n\t\t\tath11k_warn(ar->ab,\n\t\t\t\t    \"failed to set obss_pd_threshold for pdev: %u\\n\",\n\t\t\t\t    pdev_id);\n\t\treturn ret;\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_MAC,\n\t\t   \"obss pd sr_ctrl %x non_srg_thres %u srg_max %u\\n\",\n\t\t   he_obss_pd->sr_ctrl, he_obss_pd->non_srg_max_offset,\n\t\t   he_obss_pd->max_offset);\n\n\tparam_val = 0;\n\n\tif (he_obss_pd->sr_ctrl &\n\t    IEEE80211_HE_SPR_NON_SRG_OBSS_PD_SR_DISALLOWED) {\n\t\tnon_srg_th = ATH11K_OBSS_PD_MAX_THRESHOLD;\n\t} else {\n\t\tif (he_obss_pd->sr_ctrl & IEEE80211_HE_SPR_NON_SRG_OFFSET_PRESENT)\n\t\t\tnon_srg_th = (ATH11K_OBSS_PD_MAX_THRESHOLD +\n\t\t\t\t      he_obss_pd->non_srg_max_offset);\n\t\telse\n\t\t\tnon_srg_th = ATH11K_OBSS_PD_NON_SRG_MAX_THRESHOLD;\n\n\t\tparam_val |= ATH11K_OBSS_PD_NON_SRG_EN;\n\t}\n\n\tif (he_obss_pd->sr_ctrl & IEEE80211_HE_SPR_SRG_INFORMATION_PRESENT) {\n\t\tsrg_th = ATH11K_OBSS_PD_MAX_THRESHOLD + he_obss_pd->max_offset;\n\t\tparam_val |= ATH11K_OBSS_PD_SRG_EN;\n\t}\n\n\tif (test_bit(WMI_TLV_SERVICE_SRG_SRP_SPATIAL_REUSE_SUPPORT,\n\t\t     ar->ab->wmi_ab.svc_map)) {\n\t\tparam_val |= ATH11K_OBSS_PD_THRESHOLD_IN_DBM;\n\t\tparam_val |= FIELD_PREP(GENMASK(15, 8), srg_th);\n\t} else {\n\t\tnon_srg_th -= ATH11K_DEFAULT_NOISE_FLOOR;\n\t\t \n\t\tparam_val &= ~(ATH11K_OBSS_PD_SRG_EN |\n\t\t\t       ATH11K_OBSS_PD_THRESHOLD_IN_DBM);\n\t}\n\n\tparam_val |= (non_srg_th & GENMASK(7, 0));\n\tret = ath11k_wmi_pdev_set_param(ar, param_id, param_val, pdev_id);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to set obss_pd_threshold for pdev: %u\\n\",\n\t\t\t    pdev_id);\n\t\treturn ret;\n\t}\n\n\t \n\tparam_id  = WMI_PDEV_PARAM_SET_CMD_OBSS_PD_PER_AC;\n\tparam_val = 0xf;\n\tret = ath11k_wmi_pdev_set_param(ar, param_id, param_val, pdev_id);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to set obss_pd_per_ac for pdev: %u\\n\",\n\t\t\t    pdev_id);\n\t\treturn ret;\n\t}\n\n\t \n\tparam_id  = WMI_PDEV_PARAM_ENABLE_SR_PROHIBIT;\n\tparam_val = !!(he_obss_pd->sr_ctrl &\n\t\t       IEEE80211_HE_SPR_HESIGA_SR_VAL15_ALLOWED);\n\tret = ath11k_wmi_pdev_set_param(ar, param_id, param_val, pdev_id);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to set sr_prohibit for pdev: %u\\n\",\n\t\t\t    pdev_id);\n\t\treturn ret;\n\t}\n\n\tif (!test_bit(WMI_TLV_SERVICE_SRG_SRP_SPATIAL_REUSE_SUPPORT,\n\t\t      ar->ab->wmi_ab.svc_map))\n\t\treturn 0;\n\n\t \n\tmemcpy(bitmap, he_obss_pd->bss_color_bitmap, sizeof(bitmap));\n\tret = ath11k_wmi_pdev_set_srg_bss_color_bitmap(ar, bitmap);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to set bss_color_bitmap for pdev: %u\\n\",\n\t\t\t    pdev_id);\n\t\treturn ret;\n\t}\n\n\t \n\tmemcpy(bitmap, he_obss_pd->partial_bssid_bitmap, sizeof(bitmap));\n\tret = ath11k_wmi_pdev_set_srg_patial_bssid_bitmap(ar, bitmap);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to set partial_bssid_bitmap for pdev: %u\\n\",\n\t\t\t    pdev_id);\n\t\treturn ret;\n\t}\n\n\tmemset(bitmap, 0xff, sizeof(bitmap));\n\n\t \n\tret = ath11k_wmi_pdev_srg_obss_color_enable_bitmap(ar, bitmap);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to set srg_color_en_bitmap pdev: %u\\n\",\n\t\t\t    pdev_id);\n\t\treturn ret;\n\t}\n\n\t \n\tret = ath11k_wmi_pdev_srg_obss_bssid_enable_bitmap(ar, bitmap);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to set srg_bssid_en_bitmap pdev: %u\\n\",\n\t\t\t    pdev_id);\n\t\treturn ret;\n\t}\n\n\t \n\tret = ath11k_wmi_pdev_non_srg_obss_color_enable_bitmap(ar, bitmap);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to set non_srg_color_en_bitmap pdev: %u\\n\",\n\t\t\t    pdev_id);\n\t\treturn ret;\n\t}\n\n\t \n\tret = ath11k_wmi_pdev_non_srg_obss_bssid_enable_bitmap(ar, bitmap);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to set non_srg_bssid_en_bitmap pdev: %u\\n\",\n\t\t\t    pdev_id);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void ath11k_mac_op_bss_info_changed(struct ieee80211_hw *hw,\n\t\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t\t   struct ieee80211_bss_conf *info,\n\t\t\t\t\t   u64 changed)\n{\n\tstruct ath11k *ar = hw->priv;\n\tstruct ath11k_vif *arvif = ath11k_vif_to_arvif(vif);\n\tstruct cfg80211_chan_def def;\n\tu32 param_id, param_value;\n\tenum nl80211_band band;\n\tu32 vdev_param;\n\tint mcast_rate;\n\tu32 preamble;\n\tu16 hw_value;\n\tu16 bitrate;\n\tint ret = 0;\n\tu8 rateidx;\n\tu32 rate, param;\n\tu32 ipv4_cnt;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (changed & BSS_CHANGED_BEACON_INT) {\n\t\tarvif->beacon_interval = info->beacon_int;\n\n\t\tparam_id = WMI_VDEV_PARAM_BEACON_INTERVAL;\n\t\tret = ath11k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id,\n\t\t\t\t\t\t    param_id,\n\t\t\t\t\t\t    arvif->beacon_interval);\n\t\tif (ret)\n\t\t\tath11k_warn(ar->ab, \"Failed to set beacon interval for VDEV: %d\\n\",\n\t\t\t\t    arvif->vdev_id);\n\t\telse\n\t\t\tath11k_dbg(ar->ab, ATH11K_DBG_MAC,\n\t\t\t\t   \"Beacon interval: %d set for VDEV: %d\\n\",\n\t\t\t\t   arvif->beacon_interval, arvif->vdev_id);\n\t}\n\n\tif (changed & BSS_CHANGED_BEACON) {\n\t\tparam_id = WMI_PDEV_PARAM_BEACON_TX_MODE;\n\t\tparam_value = WMI_BEACON_STAGGERED_MODE;\n\t\tret = ath11k_wmi_pdev_set_param(ar, param_id,\n\t\t\t\t\t\tparam_value, ar->pdev->pdev_id);\n\t\tif (ret)\n\t\t\tath11k_warn(ar->ab, \"Failed to set beacon mode for VDEV: %d\\n\",\n\t\t\t\t    arvif->vdev_id);\n\t\telse\n\t\t\tath11k_dbg(ar->ab, ATH11K_DBG_MAC,\n\t\t\t\t   \"Set staggered beacon mode for VDEV: %d\\n\",\n\t\t\t\t   arvif->vdev_id);\n\n\t\tif (!arvif->do_not_send_tmpl || !arvif->bcca_zero_sent) {\n\t\t\tret = ath11k_mac_setup_bcn_tmpl(arvif);\n\t\t\tif (ret)\n\t\t\t\tath11k_warn(ar->ab, \"failed to update bcn template: %d\\n\",\n\t\t\t\t\t    ret);\n\t\t}\n\n\t\tif (arvif->bcca_zero_sent)\n\t\t\tarvif->do_not_send_tmpl = true;\n\t\telse\n\t\t\tarvif->do_not_send_tmpl = false;\n\n\t\tif (vif->bss_conf.he_support) {\n\t\t\tret = ath11k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id,\n\t\t\t\t\t\t\t    WMI_VDEV_PARAM_BA_MODE,\n\t\t\t\t\t\t\t    WMI_BA_MODE_BUFFER_SIZE_256);\n\t\t\tif (ret)\n\t\t\t\tath11k_warn(ar->ab,\n\t\t\t\t\t    \"failed to set BA BUFFER SIZE 256 for vdev: %d\\n\",\n\t\t\t\t\t    arvif->vdev_id);\n\t\t\telse\n\t\t\t\tath11k_dbg(ar->ab, ATH11K_DBG_MAC,\n\t\t\t\t\t   \"Set BA BUFFER SIZE 256 for VDEV: %d\\n\",\n\t\t\t\t\t   arvif->vdev_id);\n\t\t}\n\t}\n\n\tif (changed & (BSS_CHANGED_BEACON_INFO | BSS_CHANGED_BEACON)) {\n\t\tarvif->dtim_period = info->dtim_period;\n\n\t\tparam_id = WMI_VDEV_PARAM_DTIM_PERIOD;\n\t\tret = ath11k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id,\n\t\t\t\t\t\t    param_id,\n\t\t\t\t\t\t    arvif->dtim_period);\n\n\t\tif (ret)\n\t\t\tath11k_warn(ar->ab, \"Failed to set dtim period for VDEV %d: %i\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\telse\n\t\t\tath11k_dbg(ar->ab, ATH11K_DBG_MAC,\n\t\t\t\t   \"DTIM period: %d set for VDEV: %d\\n\",\n\t\t\t\t   arvif->dtim_period, arvif->vdev_id);\n\t}\n\n\tif (changed & BSS_CHANGED_SSID &&\n\t    vif->type == NL80211_IFTYPE_AP) {\n\t\tarvif->u.ap.ssid_len = vif->cfg.ssid_len;\n\t\tif (vif->cfg.ssid_len)\n\t\t\tmemcpy(arvif->u.ap.ssid, vif->cfg.ssid,\n\t\t\t       vif->cfg.ssid_len);\n\t\tarvif->u.ap.hidden_ssid = info->hidden_ssid;\n\t}\n\n\tif (changed & BSS_CHANGED_BSSID && !is_zero_ether_addr(info->bssid))\n\t\tether_addr_copy(arvif->bssid, info->bssid);\n\n\tif (changed & BSS_CHANGED_BEACON_ENABLED) {\n\t\tif (info->enable_beacon)\n\t\t\tath11k_mac_set_he_txbf_conf(arvif);\n\t\tath11k_control_beaconing(arvif, info);\n\n\t\tif (arvif->is_up && vif->bss_conf.he_support &&\n\t\t    vif->bss_conf.he_oper.params) {\n\t\t\tparam_id = WMI_VDEV_PARAM_HEOPS_0_31;\n\t\t\tparam_value = vif->bss_conf.he_oper.params;\n\t\t\tret = ath11k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id,\n\t\t\t\t\t\t\t    param_id, param_value);\n\t\t\tath11k_dbg(ar->ab, ATH11K_DBG_MAC,\n\t\t\t\t   \"he oper param: %x set for VDEV: %d\\n\",\n\t\t\t\t   param_value, arvif->vdev_id);\n\n\t\t\tif (ret)\n\t\t\t\tath11k_warn(ar->ab, \"Failed to set he oper params %x for VDEV %d: %i\\n\",\n\t\t\t\t\t    param_value, arvif->vdev_id, ret);\n\t\t}\n\t}\n\n\tif (changed & BSS_CHANGED_ERP_CTS_PROT) {\n\t\tu32 cts_prot;\n\n\t\tcts_prot = !!(info->use_cts_prot);\n\t\tparam_id = WMI_VDEV_PARAM_PROTECTION_MODE;\n\n\t\tif (arvif->is_started) {\n\t\t\tret = ath11k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id,\n\t\t\t\t\t\t\t    param_id, cts_prot);\n\t\t\tif (ret)\n\t\t\t\tath11k_warn(ar->ab, \"Failed to set CTS prot for VDEV: %d\\n\",\n\t\t\t\t\t    arvif->vdev_id);\n\t\t\telse\n\t\t\t\tath11k_dbg(ar->ab, ATH11K_DBG_MAC, \"Set CTS prot: %d for VDEV: %d\\n\",\n\t\t\t\t\t   cts_prot, arvif->vdev_id);\n\t\t} else {\n\t\t\tath11k_dbg(ar->ab, ATH11K_DBG_MAC, \"defer protection mode setup, vdev is not ready yet\\n\");\n\t\t}\n\t}\n\n\tif (changed & BSS_CHANGED_ERP_SLOT) {\n\t\tu32 slottime;\n\n\t\tif (info->use_short_slot)\n\t\t\tslottime = WMI_VDEV_SLOT_TIME_SHORT;  \n\n\t\telse\n\t\t\tslottime = WMI_VDEV_SLOT_TIME_LONG;  \n\n\t\tparam_id = WMI_VDEV_PARAM_SLOT_TIME;\n\t\tret = ath11k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id,\n\t\t\t\t\t\t    param_id, slottime);\n\t\tif (ret)\n\t\t\tath11k_warn(ar->ab, \"Failed to set erp slot for VDEV: %d\\n\",\n\t\t\t\t    arvif->vdev_id);\n\t\telse\n\t\t\tath11k_dbg(ar->ab, ATH11K_DBG_MAC,\n\t\t\t\t   \"Set slottime: %d for VDEV: %d\\n\",\n\t\t\t\t   slottime, arvif->vdev_id);\n\t}\n\n\tif (changed & BSS_CHANGED_ERP_PREAMBLE) {\n\t\tu32 preamble;\n\n\t\tif (info->use_short_preamble)\n\t\t\tpreamble = WMI_VDEV_PREAMBLE_SHORT;\n\t\telse\n\t\t\tpreamble = WMI_VDEV_PREAMBLE_LONG;\n\n\t\tparam_id = WMI_VDEV_PARAM_PREAMBLE;\n\t\tret = ath11k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id,\n\t\t\t\t\t\t    param_id, preamble);\n\t\tif (ret)\n\t\t\tath11k_warn(ar->ab, \"Failed to set preamble for VDEV: %d\\n\",\n\t\t\t\t    arvif->vdev_id);\n\t\telse\n\t\t\tath11k_dbg(ar->ab, ATH11K_DBG_MAC,\n\t\t\t\t   \"Set preamble: %d for VDEV: %d\\n\",\n\t\t\t\t   preamble, arvif->vdev_id);\n\t}\n\n\tif (changed & BSS_CHANGED_ASSOC) {\n\t\tif (vif->cfg.assoc)\n\t\t\tath11k_bss_assoc(hw, vif, info);\n\t\telse\n\t\t\tath11k_bss_disassoc(hw, vif);\n\t}\n\n\tif (changed & BSS_CHANGED_TXPOWER) {\n\t\tath11k_dbg(ar->ab, ATH11K_DBG_MAC, \"vdev_id %i txpower %d\\n\",\n\t\t\t   arvif->vdev_id, info->txpower);\n\n\t\tarvif->txpower = info->txpower;\n\t\tath11k_mac_txpower_recalc(ar);\n\t}\n\n\tif (changed & BSS_CHANGED_PS &&\n\t    ar->ab->hw_params.supports_sta_ps) {\n\t\tarvif->ps = vif->cfg.ps;\n\n\t\tret = ath11k_mac_config_ps(ar);\n\t\tif (ret)\n\t\t\tath11k_warn(ar->ab, \"failed to setup ps on vdev %i: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t}\n\n\tif (changed & BSS_CHANGED_MCAST_RATE &&\n\t    !ath11k_mac_vif_chan(arvif->vif, &def)) {\n\t\tband = def.chan->band;\n\t\tmcast_rate = vif->bss_conf.mcast_rate[band];\n\n\t\tif (mcast_rate > 0)\n\t\t\trateidx = mcast_rate - 1;\n\t\telse\n\t\t\trateidx = ffs(vif->bss_conf.basic_rates) - 1;\n\n\t\tif (ar->pdev->cap.supported_bands & WMI_HOST_WLAN_5G_CAP)\n\t\t\trateidx += ATH11K_MAC_FIRST_OFDM_RATE_IDX;\n\n\t\tbitrate = ath11k_legacy_rates[rateidx].bitrate;\n\t\thw_value = ath11k_legacy_rates[rateidx].hw_value;\n\n\t\tif (ath11k_mac_bitrate_is_cck(bitrate))\n\t\t\tpreamble = WMI_RATE_PREAMBLE_CCK;\n\t\telse\n\t\t\tpreamble = WMI_RATE_PREAMBLE_OFDM;\n\n\t\trate = ATH11K_HW_RATE_CODE(hw_value, 0, preamble);\n\n\t\tath11k_dbg(ar->ab, ATH11K_DBG_MAC,\n\t\t\t   \"vdev %d mcast_rate %x\\n\",\n\t\t\t   arvif->vdev_id, rate);\n\n\t\tvdev_param = WMI_VDEV_PARAM_MCAST_DATA_RATE;\n\t\tret = ath11k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id,\n\t\t\t\t\t\t    vdev_param, rate);\n\t\tif (ret)\n\t\t\tath11k_warn(ar->ab,\n\t\t\t\t    \"failed to set mcast rate on vdev %i: %d\\n\",\n\t\t\t\t    arvif->vdev_id,  ret);\n\n\t\tvdev_param = WMI_VDEV_PARAM_BCAST_DATA_RATE;\n\t\tret = ath11k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id,\n\t\t\t\t\t\t    vdev_param, rate);\n\t\tif (ret)\n\t\t\tath11k_warn(ar->ab,\n\t\t\t\t    \"failed to set bcast rate on vdev %i: %d\\n\",\n\t\t\t\t    arvif->vdev_id,  ret);\n\t}\n\n\tif (changed & BSS_CHANGED_BASIC_RATES &&\n\t    !ath11k_mac_vif_chan(arvif->vif, &def))\n\t\tath11k_recalculate_mgmt_rate(ar, vif, &def);\n\n\tif (changed & BSS_CHANGED_TWT) {\n\t\tstruct wmi_twt_enable_params twt_params = {0};\n\n\t\tif (info->twt_requester || info->twt_responder) {\n\t\t\tath11k_wmi_fill_default_twt_params(&twt_params);\n\t\t\tath11k_wmi_send_twt_enable_cmd(ar, ar->pdev->pdev_id,\n\t\t\t\t\t\t       &twt_params);\n\t\t} else {\n\t\t\tath11k_wmi_send_twt_disable_cmd(ar, ar->pdev->pdev_id);\n\t\t}\n\t}\n\n\tif (changed & BSS_CHANGED_HE_OBSS_PD)\n\t\tath11k_mac_config_obss_pd(ar, &info->he_obss_pd);\n\n\tif (changed & BSS_CHANGED_HE_BSS_COLOR) {\n\t\tif (vif->type == NL80211_IFTYPE_AP) {\n\t\t\tret = ath11k_wmi_send_obss_color_collision_cfg_cmd(\n\t\t\t\tar, arvif->vdev_id, info->he_bss_color.color,\n\t\t\t\tATH11K_BSS_COLOR_COLLISION_DETECTION_AP_PERIOD_MS,\n\t\t\t\tinfo->he_bss_color.enabled);\n\t\t\tif (ret)\n\t\t\t\tath11k_warn(ar->ab, \"failed to set bss color collision on vdev %i: %d\\n\",\n\t\t\t\t\t    arvif->vdev_id,  ret);\n\n\t\t\tparam_id = WMI_VDEV_PARAM_BSS_COLOR;\n\t\t\tif (info->he_bss_color.enabled)\n\t\t\t\tparam_value = info->he_bss_color.color <<\n\t\t\t\t\t\tIEEE80211_HE_OPERATION_BSS_COLOR_OFFSET;\n\t\t\telse\n\t\t\t\tparam_value = IEEE80211_HE_OPERATION_BSS_COLOR_DISABLED;\n\n\t\t\tret = ath11k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id,\n\t\t\t\t\t\t\t    param_id,\n\t\t\t\t\t\t\t    param_value);\n\t\t\tif (ret)\n\t\t\t\tath11k_warn(ar->ab,\n\t\t\t\t\t    \"failed to set bss color param on vdev %i: %d\\n\",\n\t\t\t\t\t    arvif->vdev_id,  ret);\n\n\t\t\tath11k_dbg(ar->ab, ATH11K_DBG_MAC,\n\t\t\t\t   \"bss color param 0x%x set on vdev %i\\n\",\n\t\t\t\t   param_value, arvif->vdev_id);\n\t\t} else if (vif->type == NL80211_IFTYPE_STATION) {\n\t\t\tret = ath11k_wmi_send_bss_color_change_enable_cmd(ar,\n\t\t\t\t\t\t\t\t\t  arvif->vdev_id,\n\t\t\t\t\t\t\t\t\t  1);\n\t\t\tif (ret)\n\t\t\t\tath11k_warn(ar->ab, \"failed to enable bss color change on vdev %i: %d\\n\",\n\t\t\t\t\t    arvif->vdev_id,  ret);\n\t\t\tret = ath11k_wmi_send_obss_color_collision_cfg_cmd(\n\t\t\t\tar, arvif->vdev_id, 0,\n\t\t\t\tATH11K_BSS_COLOR_COLLISION_DETECTION_STA_PERIOD_MS, 1);\n\t\t\tif (ret)\n\t\t\t\tath11k_warn(ar->ab, \"failed to set bss color collision on vdev %i: %d\\n\",\n\t\t\t\t\t    arvif->vdev_id,  ret);\n\t\t}\n\t}\n\n\tif (changed & BSS_CHANGED_FTM_RESPONDER &&\n\t    arvif->ftm_responder != info->ftm_responder &&\n\t    test_bit(WMI_TLV_SERVICE_RTT, ar->ab->wmi_ab.svc_map) &&\n\t    (vif->type == NL80211_IFTYPE_AP ||\n\t     vif->type == NL80211_IFTYPE_MESH_POINT)) {\n\t\tarvif->ftm_responder = info->ftm_responder;\n\t\tparam = WMI_VDEV_PARAM_ENABLE_DISABLE_RTT_RESPONDER_ROLE;\n\t\tret = ath11k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id, param,\n\t\t\t\t\t\t    arvif->ftm_responder);\n\t\tif (ret)\n\t\t\tath11k_warn(ar->ab, \"Failed to set ftm responder %i: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t}\n\n\tif (changed & BSS_CHANGED_FILS_DISCOVERY ||\n\t    changed & BSS_CHANGED_UNSOL_BCAST_PROBE_RESP)\n\t\tath11k_mac_fils_discovery(arvif, info);\n\n\tif (changed & BSS_CHANGED_ARP_FILTER) {\n\t\tipv4_cnt = min(vif->cfg.arp_addr_cnt, ATH11K_IPV4_MAX_COUNT);\n\t\tmemcpy(arvif->arp_ns_offload.ipv4_addr,\n\t\t       vif->cfg.arp_addr_list,\n\t\t       ipv4_cnt * sizeof(u32));\n\t\tmemcpy(arvif->arp_ns_offload.mac_addr, vif->addr, ETH_ALEN);\n\t\tarvif->arp_ns_offload.ipv4_count = ipv4_cnt;\n\n\t\tath11k_dbg(ar->ab, ATH11K_DBG_MAC, \"arp_addr_cnt %d vif->addr %pM, offload_addr %pI4\\n\",\n\t\t\t   vif->cfg.arp_addr_cnt,\n\t\t\t   vif->addr, arvif->arp_ns_offload.ipv4_addr);\n\t}\n\n\tmutex_unlock(&ar->conf_mutex);\n}\n\nvoid __ath11k_mac_scan_finish(struct ath11k *ar)\n{\n\tlockdep_assert_held(&ar->data_lock);\n\n\tswitch (ar->scan.state) {\n\tcase ATH11K_SCAN_IDLE:\n\t\tbreak;\n\tcase ATH11K_SCAN_RUNNING:\n\tcase ATH11K_SCAN_ABORTING:\n\t\tif (ar->scan.is_roc && ar->scan.roc_notify)\n\t\t\tieee80211_remain_on_channel_expired(ar->hw);\n\t\tfallthrough;\n\tcase ATH11K_SCAN_STARTING:\n\t\tif (!ar->scan.is_roc) {\n\t\t\tstruct cfg80211_scan_info info = {\n\t\t\t\t.aborted = ((ar->scan.state ==\n\t\t\t\t\t    ATH11K_SCAN_ABORTING) ||\n\t\t\t\t\t    (ar->scan.state ==\n\t\t\t\t\t    ATH11K_SCAN_STARTING)),\n\t\t\t};\n\n\t\t\tieee80211_scan_completed(ar->hw, &info);\n\t\t}\n\n\t\tar->scan.state = ATH11K_SCAN_IDLE;\n\t\tar->scan_channel = NULL;\n\t\tar->scan.roc_freq = 0;\n\t\tcancel_delayed_work(&ar->scan.timeout);\n\t\tcomplete_all(&ar->scan.completed);\n\t\tbreak;\n\t}\n}\n\nvoid ath11k_mac_scan_finish(struct ath11k *ar)\n{\n\tspin_lock_bh(&ar->data_lock);\n\t__ath11k_mac_scan_finish(ar);\n\tspin_unlock_bh(&ar->data_lock);\n}\n\nstatic int ath11k_scan_stop(struct ath11k *ar)\n{\n\tstruct scan_cancel_param arg = {\n\t\t.req_type = WLAN_SCAN_CANCEL_SINGLE,\n\t\t.scan_id = ATH11K_SCAN_ID,\n\t};\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\t \n\targ.pdev_id = ar->pdev->pdev_id;\n\n\tret = ath11k_wmi_send_scan_stop_cmd(ar, &arg);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to stop wmi scan: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = wait_for_completion_timeout(&ar->scan.completed, 3 * HZ);\n\tif (ret == 0) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to receive scan abort comple: timed out\\n\");\n\t\tret = -ETIMEDOUT;\n\t} else if (ret > 0) {\n\t\tret = 0;\n\t}\n\nout:\n\t \n\tspin_lock_bh(&ar->data_lock);\n\tif (ar->scan.state != ATH11K_SCAN_IDLE)\n\t\t__ath11k_mac_scan_finish(ar);\n\tspin_unlock_bh(&ar->data_lock);\n\n\treturn ret;\n}\n\nstatic void ath11k_scan_abort(struct ath11k *ar)\n{\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tspin_lock_bh(&ar->data_lock);\n\n\tswitch (ar->scan.state) {\n\tcase ATH11K_SCAN_IDLE:\n\t\t \n\t\tbreak;\n\tcase ATH11K_SCAN_STARTING:\n\tcase ATH11K_SCAN_ABORTING:\n\t\tath11k_warn(ar->ab, \"refusing scan abortion due to invalid scan state: %d\\n\",\n\t\t\t    ar->scan.state);\n\t\tbreak;\n\tcase ATH11K_SCAN_RUNNING:\n\t\tar->scan.state = ATH11K_SCAN_ABORTING;\n\t\tspin_unlock_bh(&ar->data_lock);\n\n\t\tret = ath11k_scan_stop(ar);\n\t\tif (ret)\n\t\t\tath11k_warn(ar->ab, \"failed to abort scan: %d\\n\", ret);\n\n\t\tspin_lock_bh(&ar->data_lock);\n\t\tbreak;\n\t}\n\n\tspin_unlock_bh(&ar->data_lock);\n}\n\nstatic void ath11k_scan_timeout_work(struct work_struct *work)\n{\n\tstruct ath11k *ar = container_of(work, struct ath11k,\n\t\t\t\t\t scan.timeout.work);\n\n\tmutex_lock(&ar->conf_mutex);\n\tath11k_scan_abort(ar);\n\tmutex_unlock(&ar->conf_mutex);\n}\n\nstatic int ath11k_start_scan(struct ath11k *ar,\n\t\t\t     struct scan_req_params *arg)\n{\n\tint ret;\n\tunsigned long timeout = 1 * HZ;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (ath11k_spectral_get_mode(ar) == ATH11K_SPECTRAL_BACKGROUND)\n\t\tath11k_spectral_reset_buffer(ar);\n\n\tret = ath11k_wmi_send_scan_start_cmd(ar, arg);\n\tif (ret)\n\t\treturn ret;\n\n\tif (test_bit(WMI_TLV_SERVICE_11D_OFFLOAD, ar->ab->wmi_ab.svc_map)) {\n\t\ttimeout = 5 * HZ;\n\n\t\tif (ar->supports_6ghz)\n\t\t\ttimeout += 5 * HZ;\n\t}\n\n\tret = wait_for_completion_timeout(&ar->scan.started, timeout);\n\tif (ret == 0) {\n\t\tret = ath11k_scan_stop(ar);\n\t\tif (ret)\n\t\t\tath11k_warn(ar->ab, \"failed to stop scan: %d\\n\", ret);\n\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\tspin_lock_bh(&ar->data_lock);\n\tif (ar->scan.state == ATH11K_SCAN_IDLE) {\n\t\tspin_unlock_bh(&ar->data_lock);\n\t\treturn -EINVAL;\n\t}\n\tspin_unlock_bh(&ar->data_lock);\n\n\treturn 0;\n}\n\nstatic int ath11k_mac_op_hw_scan(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_scan_request *hw_req)\n{\n\tstruct ath11k *ar = hw->priv;\n\tstruct ath11k_vif *arvif = ath11k_vif_to_arvif(vif);\n\tstruct cfg80211_scan_request *req = &hw_req->req;\n\tstruct scan_req_params *arg = NULL;\n\tint ret = 0;\n\tint i;\n\tu32 scan_timeout;\n\n\t \n\tif (ar->state_11d == ATH11K_11D_PREPARING &&\n\t    test_bit(WMI_TLV_SERVICE_SUPPORT_11D_FOR_HOST_SCAN,\n\t\t     ar->ab->wmi_ab.svc_map))\n\t\tath11k_mac_11d_scan_start(ar, arvif->vdev_id);\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tspin_lock_bh(&ar->data_lock);\n\tswitch (ar->scan.state) {\n\tcase ATH11K_SCAN_IDLE:\n\t\treinit_completion(&ar->scan.started);\n\t\treinit_completion(&ar->scan.completed);\n\t\tar->scan.state = ATH11K_SCAN_STARTING;\n\t\tar->scan.is_roc = false;\n\t\tar->scan.vdev_id = arvif->vdev_id;\n\t\tret = 0;\n\t\tbreak;\n\tcase ATH11K_SCAN_STARTING:\n\tcase ATH11K_SCAN_RUNNING:\n\tcase ATH11K_SCAN_ABORTING:\n\t\tret = -EBUSY;\n\t\tbreak;\n\t}\n\tspin_unlock_bh(&ar->data_lock);\n\n\tif (ret)\n\t\tgoto exit;\n\n\targ = kzalloc(sizeof(*arg), GFP_KERNEL);\n\n\tif (!arg) {\n\t\tret = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\tath11k_wmi_start_scan_init(ar, arg);\n\targ->vdev_id = arvif->vdev_id;\n\targ->scan_id = ATH11K_SCAN_ID;\n\n\tif (req->ie_len) {\n\t\targ->extraie.ptr = kmemdup(req->ie, req->ie_len, GFP_KERNEL);\n\t\tif (!arg->extraie.ptr) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto exit;\n\t\t}\n\t\targ->extraie.len = req->ie_len;\n\t}\n\n\tif (req->n_ssids) {\n\t\targ->num_ssids = req->n_ssids;\n\t\tfor (i = 0; i < arg->num_ssids; i++) {\n\t\t\targ->ssid[i].length  = req->ssids[i].ssid_len;\n\t\t\tmemcpy(&arg->ssid[i].ssid, req->ssids[i].ssid,\n\t\t\t       req->ssids[i].ssid_len);\n\t\t}\n\t} else {\n\t\targ->scan_flags |= WMI_SCAN_FLAG_PASSIVE;\n\t}\n\n\tif (req->n_channels) {\n\t\targ->num_chan = req->n_channels;\n\t\targ->chan_list = kcalloc(arg->num_chan, sizeof(*arg->chan_list),\n\t\t\t\t\t GFP_KERNEL);\n\n\t\tif (!arg->chan_list) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tfor (i = 0; i < arg->num_chan; i++) {\n\t\t\tif (test_bit(WMI_TLV_SERVICE_SCAN_CONFIG_PER_CHANNEL,\n\t\t\t\t     ar->ab->wmi_ab.svc_map)) {\n\t\t\t\targ->chan_list[i] =\n\t\t\t\t\tu32_encode_bits(req->channels[i]->center_freq,\n\t\t\t\t\t\t\tWMI_SCAN_CONFIG_PER_CHANNEL_MASK);\n\n\t\t\t\t \n\t\t\t\tif (req->channels[i]->band == NL80211_BAND_6GHZ &&\n\t\t\t\t    req->flags & NL80211_SCAN_FLAG_COLOCATED_6GHZ &&\n\t\t\t\t    !cfg80211_channel_is_psc(req->channels[i]))\n\t\t\t\t\targ->chan_list[i] |=\n\t\t\t\t\t\tWMI_SCAN_CH_FLAG_SCAN_ONLY_IF_RNR_FOUND;\n\t\t\t} else {\n\t\t\t\targ->chan_list[i] = req->channels[i]->center_freq;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (req->flags & NL80211_SCAN_FLAG_RANDOM_ADDR) {\n\t\targ->scan_f_add_spoofed_mac_in_probe = 1;\n\t\tether_addr_copy(arg->mac_addr.addr, req->mac_addr);\n\t\tether_addr_copy(arg->mac_mask.addr, req->mac_addr_mask);\n\t}\n\n\t \n\tif (req->duration) {\n\t\targ->dwell_time_active = req->duration;\n\t\targ->dwell_time_active_2g = req->duration;\n\t\targ->dwell_time_active_6g = req->duration;\n\t\targ->dwell_time_passive = req->duration;\n\t\targ->dwell_time_passive_6g = req->duration;\n\t\targ->burst_duration = req->duration;\n\n\t\tscan_timeout = min_t(u32, arg->max_rest_time *\n\t\t\t\t(arg->num_chan - 1) + (req->duration +\n\t\t\t\tATH11K_SCAN_CHANNEL_SWITCH_WMI_EVT_OVERHEAD) *\n\t\t\t\targ->num_chan, arg->max_scan_time);\n\t} else {\n\t\tscan_timeout = arg->max_scan_time;\n\t}\n\n\t \n\tscan_timeout += ATH11K_MAC_SCAN_CMD_EVT_OVERHEAD;\n\n\tret = ath11k_start_scan(ar, arg);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to start hw scan: %d\\n\", ret);\n\t\tspin_lock_bh(&ar->data_lock);\n\t\tar->scan.state = ATH11K_SCAN_IDLE;\n\t\tspin_unlock_bh(&ar->data_lock);\n\t}\n\n\tieee80211_queue_delayed_work(ar->hw, &ar->scan.timeout,\n\t\t\t\t     msecs_to_jiffies(scan_timeout));\n\nexit:\n\tif (arg) {\n\t\tkfree(arg->chan_list);\n\t\tkfree(arg->extraie.ptr);\n\t\tkfree(arg);\n\t}\n\n\tmutex_unlock(&ar->conf_mutex);\n\n\tif (ar->state_11d == ATH11K_11D_PREPARING)\n\t\tath11k_mac_11d_scan_start(ar, arvif->vdev_id);\n\n\treturn ret;\n}\n\nstatic void ath11k_mac_op_cancel_hw_scan(struct ieee80211_hw *hw,\n\t\t\t\t\t struct ieee80211_vif *vif)\n{\n\tstruct ath11k *ar = hw->priv;\n\n\tmutex_lock(&ar->conf_mutex);\n\tath11k_scan_abort(ar);\n\tmutex_unlock(&ar->conf_mutex);\n\n\tcancel_delayed_work_sync(&ar->scan.timeout);\n}\n\nstatic int ath11k_install_key(struct ath11k_vif *arvif,\n\t\t\t      struct ieee80211_key_conf *key,\n\t\t\t      enum set_key_cmd cmd,\n\t\t\t      const u8 *macaddr, u32 flags)\n{\n\tint ret;\n\tstruct ath11k *ar = arvif->ar;\n\tstruct wmi_vdev_install_key_arg arg = {\n\t\t.vdev_id = arvif->vdev_id,\n\t\t.key_idx = key->keyidx,\n\t\t.key_len = key->keylen,\n\t\t.key_data = key->key,\n\t\t.key_flags = flags,\n\t\t.macaddr = macaddr,\n\t};\n\n\tlockdep_assert_held(&arvif->ar->conf_mutex);\n\n\treinit_completion(&ar->install_key_done);\n\n\tif (test_bit(ATH11K_FLAG_HW_CRYPTO_DISABLED, &ar->ab->dev_flags))\n\t\treturn 0;\n\n\tif (cmd == DISABLE_KEY) {\n\t\targ.key_cipher = WMI_CIPHER_NONE;\n\t\targ.key_data = NULL;\n\t\tgoto install;\n\t}\n\n\tswitch (key->cipher) {\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\targ.key_cipher = WMI_CIPHER_AES_CCM;\n\t\t \n\t\tkey->flags |= IEEE80211_KEY_FLAG_GENERATE_IV_MGMT;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\targ.key_cipher = WMI_CIPHER_TKIP;\n\t\targ.key_txmic_len = 8;\n\t\targ.key_rxmic_len = 8;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP_256:\n\t\targ.key_cipher = WMI_CIPHER_AES_CCM;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_GCMP:\n\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\targ.key_cipher = WMI_CIPHER_AES_GCM;\n\t\tbreak;\n\tdefault:\n\t\tath11k_warn(ar->ab, \"cipher %d is not supported\\n\", key->cipher);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (test_bit(ATH11K_FLAG_RAW_MODE, &ar->ab->dev_flags))\n\t\tkey->flags |= IEEE80211_KEY_FLAG_GENERATE_IV |\n\t\t\t      IEEE80211_KEY_FLAG_RESERVE_TAILROOM;\n\ninstall:\n\tret = ath11k_wmi_vdev_install_key(arvif->ar, &arg);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (!wait_for_completion_timeout(&ar->install_key_done, 1 * HZ))\n\t\treturn -ETIMEDOUT;\n\n\treturn ar->install_key_status ? -EINVAL : 0;\n}\n\nstatic int ath11k_clear_peer_keys(struct ath11k_vif *arvif,\n\t\t\t\t  const u8 *addr)\n{\n\tstruct ath11k *ar = arvif->ar;\n\tstruct ath11k_base *ab = ar->ab;\n\tstruct ath11k_peer *peer;\n\tint first_errno = 0;\n\tint ret;\n\tint i;\n\tu32 flags = 0;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tspin_lock_bh(&ab->base_lock);\n\tpeer = ath11k_peer_find(ab, arvif->vdev_id, addr);\n\tspin_unlock_bh(&ab->base_lock);\n\n\tif (!peer)\n\t\treturn -ENOENT;\n\n\tfor (i = 0; i < ARRAY_SIZE(peer->keys); i++) {\n\t\tif (!peer->keys[i])\n\t\t\tcontinue;\n\n\t\t \n\t\tret = ath11k_install_key(arvif, peer->keys[i],\n\t\t\t\t\t DISABLE_KEY, addr, flags);\n\t\tif (ret < 0 && first_errno == 0)\n\t\t\tfirst_errno = ret;\n\n\t\tif (ret < 0)\n\t\t\tath11k_warn(ab, \"failed to remove peer key %d: %d\\n\",\n\t\t\t\t    i, ret);\n\n\t\tspin_lock_bh(&ab->base_lock);\n\t\tpeer->keys[i] = NULL;\n\t\tspin_unlock_bh(&ab->base_lock);\n\t}\n\n\treturn first_errno;\n}\n\nstatic int ath11k_mac_op_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,\n\t\t\t\t struct ieee80211_vif *vif, struct ieee80211_sta *sta,\n\t\t\t\t struct ieee80211_key_conf *key)\n{\n\tstruct ath11k *ar = hw->priv;\n\tstruct ath11k_base *ab = ar->ab;\n\tstruct ath11k_vif *arvif = ath11k_vif_to_arvif(vif);\n\tstruct ath11k_peer *peer;\n\tstruct ath11k_sta *arsta;\n\tconst u8 *peer_addr;\n\tint ret = 0;\n\tu32 flags = 0;\n\n\t \n\tif (key->cipher == WLAN_CIPHER_SUITE_AES_CMAC ||\n\t    key->cipher == WLAN_CIPHER_SUITE_BIP_GMAC_128 ||\n\t    key->cipher == WLAN_CIPHER_SUITE_BIP_GMAC_256 ||\n\t    key->cipher == WLAN_CIPHER_SUITE_BIP_CMAC_256)\n\t\treturn 1;\n\n\tif (test_bit(ATH11K_FLAG_HW_CRYPTO_DISABLED, &ar->ab->dev_flags))\n\t\treturn 1;\n\n\tif (key->keyidx > WMI_MAX_KEY_INDEX)\n\t\treturn -ENOSPC;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (sta)\n\t\tpeer_addr = sta->addr;\n\telse if (arvif->vdev_type == WMI_VDEV_TYPE_STA)\n\t\tpeer_addr = vif->bss_conf.bssid;\n\telse\n\t\tpeer_addr = vif->addr;\n\n\tkey->hw_key_idx = key->keyidx;\n\n\t \n\tspin_lock_bh(&ab->base_lock);\n\tpeer = ath11k_peer_find(ab, arvif->vdev_id, peer_addr);\n\n\t \n\tif (peer && sta && cmd == SET_KEY)\n\t\tath11k_peer_frags_flush(ar, peer);\n\tspin_unlock_bh(&ab->base_lock);\n\n\tif (!peer) {\n\t\tif (cmd == SET_KEY) {\n\t\t\tath11k_warn(ab, \"cannot install key for non-existent peer %pM\\n\",\n\t\t\t\t    peer_addr);\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto exit;\n\t\t} else {\n\t\t\t \n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (key->flags & IEEE80211_KEY_FLAG_PAIRWISE)\n\t\tflags |= WMI_KEY_PAIRWISE;\n\telse\n\t\tflags |= WMI_KEY_GROUP;\n\n\tret = ath11k_install_key(arvif, key, cmd, peer_addr, flags);\n\tif (ret) {\n\t\tath11k_warn(ab, \"ath11k_install_key failed (%d)\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tret = ath11k_dp_peer_rx_pn_replay_config(arvif, peer_addr, cmd, key);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to offload PN replay detection %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tspin_lock_bh(&ab->base_lock);\n\tpeer = ath11k_peer_find(ab, arvif->vdev_id, peer_addr);\n\tif (peer && cmd == SET_KEY) {\n\t\tpeer->keys[key->keyidx] = key;\n\t\tif (key->flags & IEEE80211_KEY_FLAG_PAIRWISE) {\n\t\t\tpeer->ucast_keyidx = key->keyidx;\n\t\t\tpeer->sec_type = ath11k_dp_tx_get_encrypt_type(key->cipher);\n\t\t} else {\n\t\t\tpeer->mcast_keyidx = key->keyidx;\n\t\t\tpeer->sec_type_grp = ath11k_dp_tx_get_encrypt_type(key->cipher);\n\t\t}\n\t} else if (peer && cmd == DISABLE_KEY) {\n\t\tpeer->keys[key->keyidx] = NULL;\n\t\tif (key->flags & IEEE80211_KEY_FLAG_PAIRWISE)\n\t\t\tpeer->ucast_keyidx = 0;\n\t\telse\n\t\t\tpeer->mcast_keyidx = 0;\n\t} else if (!peer)\n\t\t \n\t\tath11k_warn(ab, \"peer %pM disappeared!\\n\", peer_addr);\n\n\tif (sta) {\n\t\tarsta = (struct ath11k_sta *)sta->drv_priv;\n\n\t\tswitch (key->cipher) {\n\t\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tcase WLAN_CIPHER_SUITE_CCMP_256:\n\t\tcase WLAN_CIPHER_SUITE_GCMP:\n\t\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\t\tif (cmd == SET_KEY)\n\t\t\t\tarsta->pn_type = HAL_PN_TYPE_WPA;\n\t\t\telse\n\t\t\t\tarsta->pn_type = HAL_PN_TYPE_NONE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tarsta->pn_type = HAL_PN_TYPE_NONE;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock_bh(&ab->base_lock);\n\nexit:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic int\nath11k_mac_bitrate_mask_num_ht_rates(struct ath11k *ar,\n\t\t\t\t     enum nl80211_band band,\n\t\t\t\t     const struct cfg80211_bitrate_mask *mask)\n{\n\tint num_rates = 0;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mask->control[band].ht_mcs); i++)\n\t\tnum_rates += hweight8(mask->control[band].ht_mcs[i]);\n\n\treturn num_rates;\n}\n\nstatic int\nath11k_mac_bitrate_mask_num_vht_rates(struct ath11k *ar,\n\t\t\t\t      enum nl80211_band band,\n\t\t\t\t      const struct cfg80211_bitrate_mask *mask)\n{\n\tint num_rates = 0;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mask->control[band].vht_mcs); i++)\n\t\tnum_rates += hweight16(mask->control[band].vht_mcs[i]);\n\n\treturn num_rates;\n}\n\nstatic int\nath11k_mac_bitrate_mask_num_he_rates(struct ath11k *ar,\n\t\t\t\t     enum nl80211_band band,\n\t\t\t\t     const struct cfg80211_bitrate_mask *mask)\n{\n\tint num_rates = 0;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mask->control[band].he_mcs); i++)\n\t\tnum_rates += hweight16(mask->control[band].he_mcs[i]);\n\n\treturn num_rates;\n}\n\nstatic int\nath11k_mac_set_peer_vht_fixed_rate(struct ath11k_vif *arvif,\n\t\t\t\t   struct ieee80211_sta *sta,\n\t\t\t\t   const struct cfg80211_bitrate_mask *mask,\n\t\t\t\t   enum nl80211_band band)\n{\n\tstruct ath11k *ar = arvif->ar;\n\tu8 vht_rate, nss;\n\tu32 rate_code;\n\tint ret, i;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tnss = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(mask->control[band].vht_mcs); i++) {\n\t\tif (hweight16(mask->control[band].vht_mcs[i]) == 1) {\n\t\t\tnss = i + 1;\n\t\t\tvht_rate = ffs(mask->control[band].vht_mcs[i]) - 1;\n\t\t}\n\t}\n\n\tif (!nss) {\n\t\tath11k_warn(ar->ab, \"No single VHT Fixed rate found to set for %pM\",\n\t\t\t    sta->addr);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (nss > sta->deflink.rx_nss)\n\t\treturn -EINVAL;\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_MAC,\n\t\t   \"Setting Fixed VHT Rate for peer %pM. Device will not switch to any other selected rates\",\n\t\t   sta->addr);\n\n\trate_code = ATH11K_HW_RATE_CODE(vht_rate, nss - 1,\n\t\t\t\t\tWMI_RATE_PREAMBLE_VHT);\n\tret = ath11k_wmi_set_peer_param(ar, sta->addr,\n\t\t\t\t\tarvif->vdev_id,\n\t\t\t\t\tWMI_PEER_PARAM_FIXED_RATE,\n\t\t\t\t\trate_code);\n\tif (ret)\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to update STA %pM Fixed Rate %d: %d\\n\",\n\t\t\t     sta->addr, rate_code, ret);\n\n\treturn ret;\n}\n\nstatic int\nath11k_mac_set_peer_he_fixed_rate(struct ath11k_vif *arvif,\n\t\t\t\t  struct ieee80211_sta *sta,\n\t\t\t\t  const struct cfg80211_bitrate_mask *mask,\n\t\t\t\t  enum nl80211_band band)\n{\n\tstruct ath11k *ar = arvif->ar;\n\tu8 he_rate, nss;\n\tu32 rate_code;\n\tint ret, i;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tnss = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(mask->control[band].he_mcs); i++) {\n\t\tif (hweight16(mask->control[band].he_mcs[i]) == 1) {\n\t\t\tnss = i + 1;\n\t\t\the_rate = ffs(mask->control[band].he_mcs[i]) - 1;\n\t\t}\n\t}\n\n\tif (!nss) {\n\t\tath11k_warn(ar->ab, \"No single he fixed rate found to set for %pM\",\n\t\t\t    sta->addr);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (nss > sta->deflink.rx_nss)\n\t\treturn -EINVAL;\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_MAC,\n\t\t   \"setting fixed he rate for peer %pM, device will not switch to any other selected rates\",\n\t\t   sta->addr);\n\n\trate_code = ATH11K_HW_RATE_CODE(he_rate, nss - 1,\n\t\t\t\t\tWMI_RATE_PREAMBLE_HE);\n\n\tret = ath11k_wmi_set_peer_param(ar, sta->addr,\n\t\t\t\t\tarvif->vdev_id,\n\t\t\t\t\tWMI_PEER_PARAM_FIXED_RATE,\n\t\t\t\t\trate_code);\n\tif (ret)\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to update sta %pM fixed rate %d: %d\\n\",\n\t\t\t    sta->addr, rate_code, ret);\n\n\treturn ret;\n}\n\nstatic int\nath11k_mac_set_peer_ht_fixed_rate(struct ath11k_vif *arvif,\n\t\t\t\t  struct ieee80211_sta *sta,\n\t\t\t\t  const struct cfg80211_bitrate_mask *mask,\n\t\t\t\t  enum nl80211_band band)\n{\n\tstruct ath11k *ar = arvif->ar;\n\tu8 ht_rate, nss = 0;\n\tu32 rate_code;\n\tint ret, i;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tfor (i = 0; i < ARRAY_SIZE(mask->control[band].ht_mcs); i++) {\n\t\tif (hweight8(mask->control[band].ht_mcs[i]) == 1) {\n\t\t\tnss = i + 1;\n\t\t\tht_rate = ffs(mask->control[band].ht_mcs[i]) - 1;\n\t\t}\n\t}\n\n\tif (!nss) {\n\t\tath11k_warn(ar->ab, \"No single HT Fixed rate found to set for %pM\",\n\t\t\t    sta->addr);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (nss > sta->deflink.rx_nss)\n\t\treturn -EINVAL;\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_MAC,\n\t\t   \"Setting Fixed HT Rate for peer %pM. Device will not switch to any other selected rates\",\n\t\t   sta->addr);\n\n\trate_code = ATH11K_HW_RATE_CODE(ht_rate, nss - 1,\n\t\t\t\t\tWMI_RATE_PREAMBLE_HT);\n\tret = ath11k_wmi_set_peer_param(ar, sta->addr,\n\t\t\t\t\tarvif->vdev_id,\n\t\t\t\t\tWMI_PEER_PARAM_FIXED_RATE,\n\t\t\t\t\trate_code);\n\tif (ret)\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to update STA %pM HT Fixed Rate %d: %d\\n\",\n\t\t\t    sta->addr, rate_code, ret);\n\n\treturn ret;\n}\n\nstatic int ath11k_station_assoc(struct ath11k *ar,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_sta *sta,\n\t\t\t\tbool reassoc)\n{\n\tstruct ath11k_vif *arvif = ath11k_vif_to_arvif(vif);\n\tstruct peer_assoc_params peer_arg;\n\tint ret = 0;\n\tstruct cfg80211_chan_def def;\n\tenum nl80211_band band;\n\tstruct cfg80211_bitrate_mask *mask;\n\tu8 num_ht_rates, num_vht_rates, num_he_rates;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (WARN_ON(ath11k_mac_vif_chan(vif, &def)))\n\t\treturn -EPERM;\n\n\tband = def.chan->band;\n\tmask = &arvif->bitrate_mask;\n\n\tath11k_peer_assoc_prepare(ar, vif, sta, &peer_arg, reassoc);\n\n\tpeer_arg.is_assoc = true;\n\tret = ath11k_wmi_send_peer_assoc_cmd(ar, &peer_arg);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to run peer assoc for STA %pM vdev %i: %d\\n\",\n\t\t\t    sta->addr, arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\tif (!wait_for_completion_timeout(&ar->peer_assoc_done, 1 * HZ)) {\n\t\tath11k_warn(ar->ab, \"failed to get peer assoc conf event for %pM vdev %i\\n\",\n\t\t\t    sta->addr, arvif->vdev_id);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tnum_vht_rates = ath11k_mac_bitrate_mask_num_vht_rates(ar, band, mask);\n\tnum_he_rates = ath11k_mac_bitrate_mask_num_he_rates(ar, band, mask);\n\tnum_ht_rates = ath11k_mac_bitrate_mask_num_ht_rates(ar, band, mask);\n\n\t \n\tif (sta->deflink.vht_cap.vht_supported && num_vht_rates == 1) {\n\t\tret = ath11k_mac_set_peer_vht_fixed_rate(arvif, sta, mask,\n\t\t\t\t\t\t\t band);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else if (sta->deflink.he_cap.has_he && num_he_rates == 1) {\n\t\tret = ath11k_mac_set_peer_he_fixed_rate(arvif, sta, mask,\n\t\t\t\t\t\t\tband);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else if (sta->deflink.ht_cap.ht_supported && num_ht_rates == 1) {\n\t\tret = ath11k_mac_set_peer_ht_fixed_rate(arvif, sta, mask,\n\t\t\t\t\t\t\tband);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (reassoc)\n\t\treturn 0;\n\n\tret = ath11k_setup_peer_smps(ar, arvif, sta->addr,\n\t\t\t\t     &sta->deflink.ht_cap,\n\t\t\t\t     le16_to_cpu(sta->deflink.he_6ghz_capa.capa));\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to setup peer SMPS for vdev %d: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\tif (!sta->wme) {\n\t\tarvif->num_legacy_stations++;\n\t\tret = ath11k_recalc_rtscts_prot(arvif);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (sta->wme && sta->uapsd_queues) {\n\t\tret = ath11k_peer_assoc_qos_ap(ar, arvif, sta);\n\t\tif (ret) {\n\t\t\tath11k_warn(ar->ab, \"failed to set qos params for STA %pM for vdev %i: %d\\n\",\n\t\t\t\t    sta->addr, arvif->vdev_id, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ath11k_station_disassoc(struct ath11k *ar,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   struct ieee80211_sta *sta)\n{\n\tstruct ath11k_vif *arvif = ath11k_vif_to_arvif(vif);\n\tint ret = 0;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (!sta->wme) {\n\t\tarvif->num_legacy_stations--;\n\t\tret = ath11k_recalc_rtscts_prot(arvif);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = ath11k_clear_peer_keys(arvif, sta->addr);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to clear all peer keys for vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic void ath11k_sta_rc_update_wk(struct work_struct *wk)\n{\n\tstruct ath11k *ar;\n\tstruct ath11k_vif *arvif;\n\tstruct ath11k_sta *arsta;\n\tstruct ieee80211_sta *sta;\n\tstruct cfg80211_chan_def def;\n\tenum nl80211_band band;\n\tconst u8 *ht_mcs_mask;\n\tconst u16 *vht_mcs_mask;\n\tconst u16 *he_mcs_mask;\n\tu32 changed, bw, nss, smps, bw_prev;\n\tint err, num_ht_rates, num_vht_rates, num_he_rates;\n\tconst struct cfg80211_bitrate_mask *mask;\n\tstruct peer_assoc_params peer_arg;\n\tenum wmi_phy_mode peer_phymode;\n\n\tarsta = container_of(wk, struct ath11k_sta, update_wk);\n\tsta = container_of((void *)arsta, struct ieee80211_sta, drv_priv);\n\tarvif = arsta->arvif;\n\tar = arvif->ar;\n\n\tif (WARN_ON(ath11k_mac_vif_chan(arvif->vif, &def)))\n\t\treturn;\n\n\tband = def.chan->band;\n\tht_mcs_mask = arvif->bitrate_mask.control[band].ht_mcs;\n\tvht_mcs_mask = arvif->bitrate_mask.control[band].vht_mcs;\n\the_mcs_mask = arvif->bitrate_mask.control[band].he_mcs;\n\n\tspin_lock_bh(&ar->data_lock);\n\n\tchanged = arsta->changed;\n\tarsta->changed = 0;\n\n\tbw = arsta->bw;\n\tbw_prev = arsta->bw_prev;\n\tnss = arsta->nss;\n\tsmps = arsta->smps;\n\n\tspin_unlock_bh(&ar->data_lock);\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tnss = max_t(u32, 1, nss);\n\tnss = min(nss, max(max(ath11k_mac_max_ht_nss(ht_mcs_mask),\n\t\t\t       ath11k_mac_max_vht_nss(vht_mcs_mask)),\n\t\t\t   ath11k_mac_max_he_nss(he_mcs_mask)));\n\n\tif (changed & IEEE80211_RC_BW_CHANGED) {\n\t\t \n\t\tath11k_peer_assoc_h_phymode(ar, arvif->vif, sta, &peer_arg);\n\t\tpeer_phymode = peer_arg.peer_phymode;\n\n\t\tath11k_dbg(ar->ab, ATH11K_DBG_MAC, \"update sta %pM peer bw %d phymode %d\\n\",\n\t\t\t   sta->addr, bw, peer_phymode);\n\n\t\tif (bw > bw_prev) {\n\t\t\t \n\t\t\tath11k_dbg(ar->ab, ATH11K_DBG_MAC, \"BW upgrade for sta %pM new BW %d, old BW %d\\n\",\n\t\t\t\t   sta->addr, bw, bw_prev);\n\n\t\t\terr = ath11k_wmi_set_peer_param(ar, sta->addr, arvif->vdev_id,\n\t\t\t\t\t\t\tWMI_PEER_PHYMODE, peer_phymode);\n\n\t\t\tif (err) {\n\t\t\t\tath11k_warn(ar->ab, \"failed to update STA %pM peer phymode %d: %d\\n\",\n\t\t\t\t\t    sta->addr, peer_phymode, err);\n\t\t\t\tgoto err_rc_bw_changed;\n\t\t\t}\n\n\t\t\terr = ath11k_wmi_set_peer_param(ar, sta->addr, arvif->vdev_id,\n\t\t\t\t\t\t\tWMI_PEER_CHWIDTH, bw);\n\n\t\t\tif (err)\n\t\t\t\tath11k_warn(ar->ab, \"failed to update STA %pM peer bw %d: %d\\n\",\n\t\t\t\t\t    sta->addr, bw, err);\n\t\t} else {\n\t\t\t \n\t\t\tath11k_dbg(ar->ab, ATH11K_DBG_MAC, \"BW downgrade for sta %pM new BW %d,old BW %d\\n\",\n\t\t\t\t   sta->addr, bw, bw_prev);\n\n\t\t\terr = ath11k_wmi_set_peer_param(ar, sta->addr, arvif->vdev_id,\n\t\t\t\t\t\t\tWMI_PEER_CHWIDTH, bw);\n\n\t\t\tif (err) {\n\t\t\t\tath11k_warn(ar->ab, \"failed to update STA %pM peer bw %d: %d\\n\",\n\t\t\t\t\t    sta->addr, bw, err);\n\t\t\t\tgoto err_rc_bw_changed;\n\t\t\t}\n\n\t\t\terr = ath11k_wmi_set_peer_param(ar, sta->addr, arvif->vdev_id,\n\t\t\t\t\t\t\tWMI_PEER_PHYMODE, peer_phymode);\n\n\t\t\tif (err)\n\t\t\t\tath11k_warn(ar->ab, \"failed to update STA %pM peer phymode %d: %d\\n\",\n\t\t\t\t\t    sta->addr, peer_phymode, err);\n\t\t}\n\t}\n\n\tif (changed & IEEE80211_RC_NSS_CHANGED) {\n\t\tath11k_dbg(ar->ab, ATH11K_DBG_MAC, \"update sta %pM nss %d\\n\",\n\t\t\t   sta->addr, nss);\n\n\t\terr = ath11k_wmi_set_peer_param(ar, sta->addr, arvif->vdev_id,\n\t\t\t\t\t\tWMI_PEER_NSS, nss);\n\t\tif (err)\n\t\t\tath11k_warn(ar->ab, \"failed to update STA %pM nss %d: %d\\n\",\n\t\t\t\t    sta->addr, nss, err);\n\t}\n\n\tif (changed & IEEE80211_RC_SMPS_CHANGED) {\n\t\tath11k_dbg(ar->ab, ATH11K_DBG_MAC, \"update sta %pM smps %d\\n\",\n\t\t\t   sta->addr, smps);\n\n\t\terr = ath11k_wmi_set_peer_param(ar, sta->addr, arvif->vdev_id,\n\t\t\t\t\t\tWMI_PEER_MIMO_PS_STATE, smps);\n\t\tif (err)\n\t\t\tath11k_warn(ar->ab, \"failed to update STA %pM smps %d: %d\\n\",\n\t\t\t\t    sta->addr, smps, err);\n\t}\n\n\tif (changed & IEEE80211_RC_SUPP_RATES_CHANGED) {\n\t\tmask = &arvif->bitrate_mask;\n\t\tnum_ht_rates = ath11k_mac_bitrate_mask_num_ht_rates(ar, band,\n\t\t\t\t\t\t\t\t    mask);\n\t\tnum_vht_rates = ath11k_mac_bitrate_mask_num_vht_rates(ar, band,\n\t\t\t\t\t\t\t\t      mask);\n\t\tnum_he_rates = ath11k_mac_bitrate_mask_num_he_rates(ar, band,\n\t\t\t\t\t\t\t\t    mask);\n\n\t\t \n\t\tif (sta->deflink.vht_cap.vht_supported && num_vht_rates == 1) {\n\t\t\tath11k_mac_set_peer_vht_fixed_rate(arvif, sta, mask,\n\t\t\t\t\t\t\t   band);\n\t\t} else if (sta->deflink.he_cap.has_he && num_he_rates == 1) {\n\t\t\tath11k_mac_set_peer_he_fixed_rate(arvif, sta, mask,\n\t\t\t\t\t\t\t  band);\n\t\t} else if (sta->deflink.ht_cap.ht_supported && num_ht_rates == 1) {\n\t\t\tath11k_mac_set_peer_ht_fixed_rate(arvif, sta, mask,\n\t\t\t\t\t\t\t  band);\n\t\t} else {\n\t\t\t \n\t\t\terr = ath11k_wmi_set_peer_param(ar, sta->addr,\n\t\t\t\t\t\t\tarvif->vdev_id,\n\t\t\t\t\t\t\tWMI_PEER_PARAM_FIXED_RATE,\n\t\t\t\t\t\t\tWMI_FIXED_RATE_NONE);\n\t\t\tif (err)\n\t\t\t\tath11k_warn(ar->ab,\n\t\t\t\t\t    \"failed to disable peer fixed rate for sta %pM: %d\\n\",\n\t\t\t\t\t    sta->addr, err);\n\n\t\t\tath11k_peer_assoc_prepare(ar, arvif->vif, sta,\n\t\t\t\t\t\t  &peer_arg, true);\n\n\t\t\tpeer_arg.is_assoc = false;\n\t\t\terr = ath11k_wmi_send_peer_assoc_cmd(ar, &peer_arg);\n\t\t\tif (err)\n\t\t\t\tath11k_warn(ar->ab, \"failed to run peer assoc for STA %pM vdev %i: %d\\n\",\n\t\t\t\t\t    sta->addr, arvif->vdev_id, err);\n\n\t\t\tif (!wait_for_completion_timeout(&ar->peer_assoc_done, 1 * HZ))\n\t\t\t\tath11k_warn(ar->ab, \"failed to get peer assoc conf event for %pM vdev %i\\n\",\n\t\t\t\t\t    sta->addr, arvif->vdev_id);\n\t\t}\n\t}\n\nerr_rc_bw_changed:\n\tmutex_unlock(&ar->conf_mutex);\n}\n\nstatic void ath11k_sta_set_4addr_wk(struct work_struct *wk)\n{\n\tstruct ath11k *ar;\n\tstruct ath11k_vif *arvif;\n\tstruct ath11k_sta *arsta;\n\tstruct ieee80211_sta *sta;\n\tint ret = 0;\n\n\tarsta = container_of(wk, struct ath11k_sta, set_4addr_wk);\n\tsta = container_of((void *)arsta, struct ieee80211_sta, drv_priv);\n\tarvif = arsta->arvif;\n\tar = arvif->ar;\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_MAC,\n\t\t   \"setting USE_4ADDR for peer %pM\\n\", sta->addr);\n\n\tret = ath11k_wmi_set_peer_param(ar, sta->addr,\n\t\t\t\t\tarvif->vdev_id,\n\t\t\t\t\tWMI_PEER_USE_4ADDR, 1);\n\n\tif (ret)\n\t\tath11k_warn(ar->ab, \"failed to set peer %pM 4addr capability: %d\\n\",\n\t\t\t    sta->addr, ret);\n}\n\nstatic int ath11k_mac_inc_num_stations(struct ath11k_vif *arvif,\n\t\t\t\t       struct ieee80211_sta *sta)\n{\n\tstruct ath11k *ar = arvif->ar;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (arvif->vdev_type == WMI_VDEV_TYPE_STA && !sta->tdls)\n\t\treturn 0;\n\n\tif (ar->num_stations >= ar->max_num_stations)\n\t\treturn -ENOBUFS;\n\n\tar->num_stations++;\n\n\treturn 0;\n}\n\nstatic void ath11k_mac_dec_num_stations(struct ath11k_vif *arvif,\n\t\t\t\t\tstruct ieee80211_sta *sta)\n{\n\tstruct ath11k *ar = arvif->ar;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (arvif->vdev_type == WMI_VDEV_TYPE_STA && !sta->tdls)\n\t\treturn;\n\n\tar->num_stations--;\n}\n\nstatic int ath11k_mac_station_add(struct ath11k *ar,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  struct ieee80211_sta *sta)\n{\n\tstruct ath11k_base *ab = ar->ab;\n\tstruct ath11k_vif *arvif = ath11k_vif_to_arvif(vif);\n\tstruct ath11k_sta *arsta = (struct ath11k_sta *)sta->drv_priv;\n\tstruct peer_create_params peer_param;\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tret = ath11k_mac_inc_num_stations(arvif, sta);\n\tif (ret) {\n\t\tath11k_warn(ab, \"refusing to associate station: too many connected already (%d)\\n\",\n\t\t\t    ar->max_num_stations);\n\t\tgoto exit;\n\t}\n\n\tarsta->rx_stats = kzalloc(sizeof(*arsta->rx_stats), GFP_KERNEL);\n\tif (!arsta->rx_stats) {\n\t\tret = -ENOMEM;\n\t\tgoto dec_num_station;\n\t}\n\n\tpeer_param.vdev_id = arvif->vdev_id;\n\tpeer_param.peer_addr = sta->addr;\n\tpeer_param.peer_type = WMI_PEER_TYPE_DEFAULT;\n\n\tret = ath11k_peer_create(ar, arvif, sta, &peer_param);\n\tif (ret) {\n\t\tath11k_warn(ab, \"Failed to add peer: %pM for VDEV: %d\\n\",\n\t\t\t    sta->addr, arvif->vdev_id);\n\t\tgoto free_rx_stats;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_MAC, \"Added peer: %pM for VDEV: %d\\n\",\n\t\t   sta->addr, arvif->vdev_id);\n\n\tif (ath11k_debugfs_is_extd_tx_stats_enabled(ar)) {\n\t\tarsta->tx_stats = kzalloc(sizeof(*arsta->tx_stats), GFP_KERNEL);\n\t\tif (!arsta->tx_stats) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free_peer;\n\t\t}\n\t}\n\n\tif (ieee80211_vif_is_mesh(vif)) {\n\t\tath11k_dbg(ab, ATH11K_DBG_MAC,\n\t\t\t   \"setting USE_4ADDR for mesh STA %pM\\n\", sta->addr);\n\t\tret = ath11k_wmi_set_peer_param(ar, sta->addr,\n\t\t\t\t\t\tarvif->vdev_id,\n\t\t\t\t\t\tWMI_PEER_USE_4ADDR, 1);\n\t\tif (ret) {\n\t\t\tath11k_warn(ab, \"failed to set mesh STA %pM 4addr capability: %d\\n\",\n\t\t\t\t    sta->addr, ret);\n\t\t\tgoto free_tx_stats;\n\t\t}\n\t}\n\n\tret = ath11k_dp_peer_setup(ar, arvif->vdev_id, sta->addr);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to setup dp for peer %pM on vdev %i (%d)\\n\",\n\t\t\t    sta->addr, arvif->vdev_id, ret);\n\t\tgoto free_tx_stats;\n\t}\n\n\tif (ab->hw_params.vdev_start_delay &&\n\t    !arvif->is_started &&\n\t    arvif->vdev_type != WMI_VDEV_TYPE_AP) {\n\t\tret = ath11k_start_vdev_delay(ar->hw, vif);\n\t\tif (ret) {\n\t\t\tath11k_warn(ab, \"failed to delay vdev start: %d\\n\", ret);\n\t\t\tgoto free_tx_stats;\n\t\t}\n\t}\n\n\tewma_avg_rssi_init(&arsta->avg_rssi);\n\treturn 0;\n\nfree_tx_stats:\n\tkfree(arsta->tx_stats);\n\tarsta->tx_stats = NULL;\nfree_peer:\n\tath11k_peer_delete(ar, arvif->vdev_id, sta->addr);\nfree_rx_stats:\n\tkfree(arsta->rx_stats);\n\tarsta->rx_stats = NULL;\ndec_num_station:\n\tath11k_mac_dec_num_stations(arvif, sta);\nexit:\n\treturn ret;\n}\n\nstatic u32 ath11k_mac_ieee80211_sta_bw_to_wmi(struct ath11k *ar,\n\t\t\t\t\t      struct ieee80211_sta *sta)\n{\n\tu32 bw = WMI_PEER_CHWIDTH_20MHZ;\n\n\tswitch (sta->deflink.bandwidth) {\n\tcase IEEE80211_STA_RX_BW_20:\n\t\tbw = WMI_PEER_CHWIDTH_20MHZ;\n\t\tbreak;\n\tcase IEEE80211_STA_RX_BW_40:\n\t\tbw = WMI_PEER_CHWIDTH_40MHZ;\n\t\tbreak;\n\tcase IEEE80211_STA_RX_BW_80:\n\t\tbw = WMI_PEER_CHWIDTH_80MHZ;\n\t\tbreak;\n\tcase IEEE80211_STA_RX_BW_160:\n\t\tbw = WMI_PEER_CHWIDTH_160MHZ;\n\t\tbreak;\n\tdefault:\n\t\tath11k_warn(ar->ab, \"Invalid bandwidth %d for %pM\\n\",\n\t\t\t    sta->deflink.bandwidth, sta->addr);\n\t\tbw = WMI_PEER_CHWIDTH_20MHZ;\n\t\tbreak;\n\t}\n\n\treturn bw;\n}\n\nstatic int ath11k_mac_op_sta_state(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   struct ieee80211_sta *sta,\n\t\t\t\t   enum ieee80211_sta_state old_state,\n\t\t\t\t   enum ieee80211_sta_state new_state)\n{\n\tstruct ath11k *ar = hw->priv;\n\tstruct ath11k_vif *arvif = ath11k_vif_to_arvif(vif);\n\tstruct ath11k_sta *arsta = (struct ath11k_sta *)sta->drv_priv;\n\tstruct ath11k_peer *peer;\n\tint ret = 0;\n\n\t \n\tif ((old_state == IEEE80211_STA_NONE &&\n\t     new_state == IEEE80211_STA_NOTEXIST)) {\n\t\tcancel_work_sync(&arsta->update_wk);\n\t\tcancel_work_sync(&arsta->set_4addr_wk);\n\t}\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (old_state == IEEE80211_STA_NOTEXIST &&\n\t    new_state == IEEE80211_STA_NONE) {\n\t\tmemset(arsta, 0, sizeof(*arsta));\n\t\tarsta->arvif = arvif;\n\t\tarsta->peer_ps_state = WMI_PEER_PS_STATE_DISABLED;\n\t\tINIT_WORK(&arsta->update_wk, ath11k_sta_rc_update_wk);\n\t\tINIT_WORK(&arsta->set_4addr_wk, ath11k_sta_set_4addr_wk);\n\n\t\tret = ath11k_mac_station_add(ar, vif, sta);\n\t\tif (ret)\n\t\t\tath11k_warn(ar->ab, \"Failed to add station: %pM for VDEV: %d\\n\",\n\t\t\t\t    sta->addr, arvif->vdev_id);\n\t} else if ((old_state == IEEE80211_STA_NONE &&\n\t\t    new_state == IEEE80211_STA_NOTEXIST)) {\n\t\tbool skip_peer_delete = ar->ab->hw_params.vdev_start_delay &&\n\t\t\tvif->type == NL80211_IFTYPE_STATION;\n\n\t\tath11k_dp_peer_cleanup(ar, arvif->vdev_id, sta->addr);\n\n\t\tif (!skip_peer_delete) {\n\t\t\tret = ath11k_peer_delete(ar, arvif->vdev_id, sta->addr);\n\t\t\tif (ret)\n\t\t\t\tath11k_warn(ar->ab,\n\t\t\t\t\t    \"Failed to delete peer: %pM for VDEV: %d\\n\",\n\t\t\t\t\t    sta->addr, arvif->vdev_id);\n\t\t\telse\n\t\t\t\tath11k_dbg(ar->ab,\n\t\t\t\t\t   ATH11K_DBG_MAC,\n\t\t\t\t\t   \"Removed peer: %pM for VDEV: %d\\n\",\n\t\t\t\t\t   sta->addr, arvif->vdev_id);\n\t\t}\n\n\t\tath11k_mac_dec_num_stations(arvif, sta);\n\t\tmutex_lock(&ar->ab->tbl_mtx_lock);\n\t\tspin_lock_bh(&ar->ab->base_lock);\n\t\tpeer = ath11k_peer_find(ar->ab, arvif->vdev_id, sta->addr);\n\t\tif (skip_peer_delete && peer) {\n\t\t\tpeer->sta = NULL;\n\t\t} else if (peer && peer->sta == sta) {\n\t\t\tath11k_warn(ar->ab, \"Found peer entry %pM n vdev %i after it was supposedly removed\\n\",\n\t\t\t\t    vif->addr, arvif->vdev_id);\n\t\t\tath11k_peer_rhash_delete(ar->ab, peer);\n\t\t\tpeer->sta = NULL;\n\t\t\tlist_del(&peer->list);\n\t\t\tkfree(peer);\n\t\t\tar->num_peers--;\n\t\t}\n\t\tspin_unlock_bh(&ar->ab->base_lock);\n\t\tmutex_unlock(&ar->ab->tbl_mtx_lock);\n\n\t\tkfree(arsta->tx_stats);\n\t\tarsta->tx_stats = NULL;\n\n\t\tkfree(arsta->rx_stats);\n\t\tarsta->rx_stats = NULL;\n\t} else if (old_state == IEEE80211_STA_AUTH &&\n\t\t   new_state == IEEE80211_STA_ASSOC &&\n\t\t   (vif->type == NL80211_IFTYPE_AP ||\n\t\t    vif->type == NL80211_IFTYPE_MESH_POINT ||\n\t\t    vif->type == NL80211_IFTYPE_ADHOC)) {\n\t\tret = ath11k_station_assoc(ar, vif, sta, false);\n\t\tif (ret)\n\t\t\tath11k_warn(ar->ab, \"Failed to associate station: %pM\\n\",\n\t\t\t\t    sta->addr);\n\n\t\tspin_lock_bh(&ar->data_lock);\n\t\t \n\t\tarsta->bw = ath11k_mac_ieee80211_sta_bw_to_wmi(ar, sta);\n\t\tarsta->bw_prev = arsta->bw;\n\t\tspin_unlock_bh(&ar->data_lock);\n\t} else if (old_state == IEEE80211_STA_ASSOC &&\n\t\t   new_state == IEEE80211_STA_AUTHORIZED) {\n\t\tspin_lock_bh(&ar->ab->base_lock);\n\n\t\tpeer = ath11k_peer_find(ar->ab, arvif->vdev_id, sta->addr);\n\t\tif (peer)\n\t\t\tpeer->is_authorized = true;\n\n\t\tspin_unlock_bh(&ar->ab->base_lock);\n\n\t\tif (vif->type == NL80211_IFTYPE_STATION && arvif->is_up) {\n\t\t\tret = ath11k_wmi_set_peer_param(ar, sta->addr,\n\t\t\t\t\t\t\tarvif->vdev_id,\n\t\t\t\t\t\t\tWMI_PEER_AUTHORIZE,\n\t\t\t\t\t\t\t1);\n\t\t\tif (ret)\n\t\t\t\tath11k_warn(ar->ab, \"Unable to authorize peer %pM vdev %d: %d\\n\",\n\t\t\t\t\t    sta->addr, arvif->vdev_id, ret);\n\t\t}\n\t} else if (old_state == IEEE80211_STA_AUTHORIZED &&\n\t\t   new_state == IEEE80211_STA_ASSOC) {\n\t\tspin_lock_bh(&ar->ab->base_lock);\n\n\t\tpeer = ath11k_peer_find(ar->ab, arvif->vdev_id, sta->addr);\n\t\tif (peer)\n\t\t\tpeer->is_authorized = false;\n\n\t\tspin_unlock_bh(&ar->ab->base_lock);\n\t} else if (old_state == IEEE80211_STA_ASSOC &&\n\t\t   new_state == IEEE80211_STA_AUTH &&\n\t\t   (vif->type == NL80211_IFTYPE_AP ||\n\t\t    vif->type == NL80211_IFTYPE_MESH_POINT ||\n\t\t    vif->type == NL80211_IFTYPE_ADHOC)) {\n\t\tret = ath11k_station_disassoc(ar, vif, sta);\n\t\tif (ret)\n\t\t\tath11k_warn(ar->ab, \"Failed to disassociate station: %pM\\n\",\n\t\t\t\t    sta->addr);\n\t}\n\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic int ath11k_mac_op_sta_set_txpwr(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       struct ieee80211_sta *sta)\n{\n\tstruct ath11k *ar = hw->priv;\n\tstruct ath11k_vif *arvif = ath11k_vif_to_arvif(vif);\n\tint ret = 0;\n\ts16 txpwr;\n\n\tif (sta->deflink.txpwr.type == NL80211_TX_POWER_AUTOMATIC) {\n\t\ttxpwr = 0;\n\t} else {\n\t\ttxpwr = sta->deflink.txpwr.power;\n\t\tif (!txpwr)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (txpwr > ATH11K_TX_POWER_MAX_VAL || txpwr < ATH11K_TX_POWER_MIN_VAL)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tret = ath11k_wmi_set_peer_param(ar, sta->addr, arvif->vdev_id,\n\t\t\t\t\tWMI_PEER_USE_FIXED_PWR, txpwr);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to set tx power for station ret: %d\\n\",\n\t\t\t    ret);\n\t\tgoto out;\n\t}\n\nout:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic void ath11k_mac_op_sta_set_4addr(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\t\tstruct ieee80211_sta *sta, bool enabled)\n{\n\tstruct ath11k *ar = hw->priv;\n\tstruct ath11k_sta *arsta = (struct ath11k_sta *)sta->drv_priv;\n\n\tif (enabled && !arsta->use_4addr_set) {\n\t\tieee80211_queue_work(ar->hw, &arsta->set_4addr_wk);\n\t\tarsta->use_4addr_set = true;\n\t}\n}\n\nstatic void ath11k_mac_op_sta_rc_update(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\t\tstruct ieee80211_sta *sta,\n\t\t\t\t\tu32 changed)\n{\n\tstruct ath11k *ar = hw->priv;\n\tstruct ath11k_sta *arsta = (struct ath11k_sta *)sta->drv_priv;\n\tstruct ath11k_vif *arvif = ath11k_vif_to_arvif(vif);\n\tstruct ath11k_peer *peer;\n\tu32 bw, smps;\n\n\tspin_lock_bh(&ar->ab->base_lock);\n\n\tpeer = ath11k_peer_find(ar->ab, arvif->vdev_id, sta->addr);\n\tif (!peer) {\n\t\tspin_unlock_bh(&ar->ab->base_lock);\n\t\tath11k_warn(ar->ab, \"mac sta rc update failed to find peer %pM on vdev %i\\n\",\n\t\t\t    sta->addr, arvif->vdev_id);\n\t\treturn;\n\t}\n\n\tspin_unlock_bh(&ar->ab->base_lock);\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_MAC,\n\t\t   \"sta rc update for %pM changed %08x bw %d nss %d smps %d\\n\",\n\t\t   sta->addr, changed, sta->deflink.bandwidth,\n\t\t   sta->deflink.rx_nss,\n\t\t   sta->deflink.smps_mode);\n\n\tspin_lock_bh(&ar->data_lock);\n\n\tif (changed & IEEE80211_RC_BW_CHANGED) {\n\t\tbw = ath11k_mac_ieee80211_sta_bw_to_wmi(ar, sta);\n\t\tarsta->bw_prev = arsta->bw;\n\t\tarsta->bw = bw;\n\t}\n\n\tif (changed & IEEE80211_RC_NSS_CHANGED)\n\t\tarsta->nss = sta->deflink.rx_nss;\n\n\tif (changed & IEEE80211_RC_SMPS_CHANGED) {\n\t\tsmps = WMI_PEER_SMPS_PS_NONE;\n\n\t\tswitch (sta->deflink.smps_mode) {\n\t\tcase IEEE80211_SMPS_AUTOMATIC:\n\t\tcase IEEE80211_SMPS_OFF:\n\t\t\tsmps = WMI_PEER_SMPS_PS_NONE;\n\t\t\tbreak;\n\t\tcase IEEE80211_SMPS_STATIC:\n\t\t\tsmps = WMI_PEER_SMPS_STATIC;\n\t\t\tbreak;\n\t\tcase IEEE80211_SMPS_DYNAMIC:\n\t\t\tsmps = WMI_PEER_SMPS_DYNAMIC;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tath11k_warn(ar->ab, \"Invalid smps %d in sta rc update for %pM\\n\",\n\t\t\t\t    sta->deflink.smps_mode, sta->addr);\n\t\t\tsmps = WMI_PEER_SMPS_PS_NONE;\n\t\t\tbreak;\n\t\t}\n\n\t\tarsta->smps = smps;\n\t}\n\n\tarsta->changed |= changed;\n\n\tspin_unlock_bh(&ar->data_lock);\n\n\tieee80211_queue_work(hw, &arsta->update_wk);\n}\n\nstatic int ath11k_conf_tx_uapsd(struct ath11k *ar, struct ieee80211_vif *vif,\n\t\t\t\tu16 ac, bool enable)\n{\n\tstruct ath11k_vif *arvif = ath11k_vif_to_arvif(vif);\n\tu32 value = 0;\n\tint ret = 0;\n\n\tif (arvif->vdev_type != WMI_VDEV_TYPE_STA)\n\t\treturn 0;\n\n\tswitch (ac) {\n\tcase IEEE80211_AC_VO:\n\t\tvalue = WMI_STA_PS_UAPSD_AC3_DELIVERY_EN |\n\t\t\tWMI_STA_PS_UAPSD_AC3_TRIGGER_EN;\n\t\tbreak;\n\tcase IEEE80211_AC_VI:\n\t\tvalue = WMI_STA_PS_UAPSD_AC2_DELIVERY_EN |\n\t\t\tWMI_STA_PS_UAPSD_AC2_TRIGGER_EN;\n\t\tbreak;\n\tcase IEEE80211_AC_BE:\n\t\tvalue = WMI_STA_PS_UAPSD_AC1_DELIVERY_EN |\n\t\t\tWMI_STA_PS_UAPSD_AC1_TRIGGER_EN;\n\t\tbreak;\n\tcase IEEE80211_AC_BK:\n\t\tvalue = WMI_STA_PS_UAPSD_AC0_DELIVERY_EN |\n\t\t\tWMI_STA_PS_UAPSD_AC0_TRIGGER_EN;\n\t\tbreak;\n\t}\n\n\tif (enable)\n\t\tarvif->u.sta.uapsd |= value;\n\telse\n\t\tarvif->u.sta.uapsd &= ~value;\n\n\tret = ath11k_wmi_set_sta_ps_param(ar, arvif->vdev_id,\n\t\t\t\t\t  WMI_STA_PS_PARAM_UAPSD,\n\t\t\t\t\t  arvif->u.sta.uapsd);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"could not set uapsd params %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tif (arvif->u.sta.uapsd)\n\t\tvalue = WMI_STA_PS_RX_WAKE_POLICY_POLL_UAPSD;\n\telse\n\t\tvalue = WMI_STA_PS_RX_WAKE_POLICY_WAKE;\n\n\tret = ath11k_wmi_set_sta_ps_param(ar, arvif->vdev_id,\n\t\t\t\t\t  WMI_STA_PS_PARAM_RX_WAKE_POLICY,\n\t\t\t\t\t  value);\n\tif (ret)\n\t\tath11k_warn(ar->ab, \"could not set rx wake param %d\\n\", ret);\n\nexit:\n\treturn ret;\n}\n\nstatic int ath11k_mac_op_conf_tx(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t unsigned int link_id, u16 ac,\n\t\t\t\t const struct ieee80211_tx_queue_params *params)\n{\n\tstruct ath11k *ar = hw->priv;\n\tstruct ath11k_vif *arvif = ath11k_vif_to_arvif(vif);\n\tstruct wmi_wmm_params_arg *p = NULL;\n\tint ret;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tswitch (ac) {\n\tcase IEEE80211_AC_VO:\n\t\tp = &arvif->wmm_params.ac_vo;\n\t\tbreak;\n\tcase IEEE80211_AC_VI:\n\t\tp = &arvif->wmm_params.ac_vi;\n\t\tbreak;\n\tcase IEEE80211_AC_BE:\n\t\tp = &arvif->wmm_params.ac_be;\n\t\tbreak;\n\tcase IEEE80211_AC_BK:\n\t\tp = &arvif->wmm_params.ac_bk;\n\t\tbreak;\n\t}\n\n\tif (WARN_ON(!p)) {\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tp->cwmin = params->cw_min;\n\tp->cwmax = params->cw_max;\n\tp->aifs = params->aifs;\n\tp->txop = params->txop;\n\n\tret = ath11k_wmi_send_wmm_update_cmd_tlv(ar, arvif->vdev_id,\n\t\t\t\t\t\t &arvif->wmm_params);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to set wmm params: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tret = ath11k_conf_tx_uapsd(ar, vif, ac, params->uapsd);\n\n\tif (ret)\n\t\tath11k_warn(ar->ab, \"failed to set sta uapsd: %d\\n\", ret);\n\nexit:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic struct ieee80211_sta_ht_cap\nath11k_create_ht_cap(struct ath11k *ar, u32 ar_ht_cap, u32 rate_cap_rx_chainmask)\n{\n\tint i;\n\tstruct ieee80211_sta_ht_cap ht_cap = {0};\n\tu32 ar_vht_cap = ar->pdev->cap.vht_cap;\n\n\tif (!(ar_ht_cap & WMI_HT_CAP_ENABLED))\n\t\treturn ht_cap;\n\n\tht_cap.ht_supported = 1;\n\tht_cap.ampdu_factor = IEEE80211_HT_MAX_AMPDU_64K;\n\tht_cap.ampdu_density = IEEE80211_HT_MPDU_DENSITY_NONE;\n\tht_cap.cap |= IEEE80211_HT_CAP_SUP_WIDTH_20_40;\n\tht_cap.cap |= IEEE80211_HT_CAP_DSSSCCK40;\n\tht_cap.cap |= WLAN_HT_CAP_SM_PS_STATIC << IEEE80211_HT_CAP_SM_PS_SHIFT;\n\n\tif (ar_ht_cap & WMI_HT_CAP_HT20_SGI)\n\t\tht_cap.cap |= IEEE80211_HT_CAP_SGI_20;\n\n\tif (ar_ht_cap & WMI_HT_CAP_HT40_SGI)\n\t\tht_cap.cap |= IEEE80211_HT_CAP_SGI_40;\n\n\tif (ar_ht_cap & WMI_HT_CAP_DYNAMIC_SMPS) {\n\t\tu32 smps;\n\n\t\tsmps   = WLAN_HT_CAP_SM_PS_DYNAMIC;\n\t\tsmps <<= IEEE80211_HT_CAP_SM_PS_SHIFT;\n\n\t\tht_cap.cap |= smps;\n\t}\n\n\tif (ar_ht_cap & WMI_HT_CAP_TX_STBC)\n\t\tht_cap.cap |= IEEE80211_HT_CAP_TX_STBC;\n\n\tif (ar_ht_cap & WMI_HT_CAP_RX_STBC) {\n\t\tu32 stbc;\n\n\t\tstbc   = ar_ht_cap;\n\t\tstbc  &= WMI_HT_CAP_RX_STBC;\n\t\tstbc >>= WMI_HT_CAP_RX_STBC_MASK_SHIFT;\n\t\tstbc <<= IEEE80211_HT_CAP_RX_STBC_SHIFT;\n\t\tstbc  &= IEEE80211_HT_CAP_RX_STBC;\n\n\t\tht_cap.cap |= stbc;\n\t}\n\n\tif (ar_ht_cap & WMI_HT_CAP_RX_LDPC)\n\t\tht_cap.cap |= IEEE80211_HT_CAP_LDPC_CODING;\n\n\tif (ar_ht_cap & WMI_HT_CAP_L_SIG_TXOP_PROT)\n\t\tht_cap.cap |= IEEE80211_HT_CAP_LSIG_TXOP_PROT;\n\n\tif (ar_vht_cap & WMI_VHT_CAP_MAX_MPDU_LEN_MASK)\n\t\tht_cap.cap |= IEEE80211_HT_CAP_MAX_AMSDU;\n\n\tfor (i = 0; i < ar->num_rx_chains; i++) {\n\t\tif (rate_cap_rx_chainmask & BIT(i))\n\t\t\tht_cap.mcs.rx_mask[i] = 0xFF;\n\t}\n\n\tht_cap.mcs.tx_params |= IEEE80211_HT_MCS_TX_DEFINED;\n\n\treturn ht_cap;\n}\n\nstatic int ath11k_mac_set_txbf_conf(struct ath11k_vif *arvif)\n{\n\tu32 value = 0;\n\tstruct ath11k *ar = arvif->ar;\n\tint nsts;\n\tint sound_dim;\n\tu32 vht_cap = ar->pdev->cap.vht_cap;\n\tu32 vdev_param = WMI_VDEV_PARAM_TXBF;\n\n\tif (vht_cap & (IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE)) {\n\t\tnsts = vht_cap & IEEE80211_VHT_CAP_BEAMFORMEE_STS_MASK;\n\t\tnsts >>= IEEE80211_VHT_CAP_BEAMFORMEE_STS_SHIFT;\n\t\tif (nsts > (ar->num_rx_chains - 1))\n\t\t\tnsts = ar->num_rx_chains - 1;\n\t\tvalue |= SM(nsts, WMI_TXBF_STS_CAP_OFFSET);\n\t}\n\n\tif (vht_cap & (IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE)) {\n\t\tsound_dim = vht_cap &\n\t\t\t    IEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_MASK;\n\t\tsound_dim >>= IEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_SHIFT;\n\t\tif (sound_dim > (ar->num_tx_chains - 1))\n\t\t\tsound_dim = ar->num_tx_chains - 1;\n\t\tvalue |= SM(sound_dim, WMI_BF_SOUND_DIM_OFFSET);\n\t}\n\n\tif (!value)\n\t\treturn 0;\n\n\tif (vht_cap & IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE) {\n\t\tvalue |= WMI_VDEV_PARAM_TXBF_SU_TX_BFER;\n\n\t\tif ((vht_cap & IEEE80211_VHT_CAP_MU_BEAMFORMER_CAPABLE) &&\n\t\t    arvif->vdev_type == WMI_VDEV_TYPE_AP)\n\t\t\tvalue |= WMI_VDEV_PARAM_TXBF_MU_TX_BFER;\n\t}\n\n\t \n\n\tif (vht_cap & IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE) {\n\t\tvalue |= WMI_VDEV_PARAM_TXBF_SU_TX_BFEE;\n\n\t\tif ((vht_cap & IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE) &&\n\t\t    arvif->vdev_type == WMI_VDEV_TYPE_STA)\n\t\t\tvalue |= WMI_VDEV_PARAM_TXBF_MU_TX_BFEE;\n\t}\n\n\treturn ath11k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id,\n\t\t\t\t\t     vdev_param, value);\n}\n\nstatic void ath11k_set_vht_txbf_cap(struct ath11k *ar, u32 *vht_cap)\n{\n\tbool subfer, subfee;\n\tint sound_dim = 0, nsts = 0;\n\n\tsubfer = !!(*vht_cap & (IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE));\n\tsubfee = !!(*vht_cap & (IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE));\n\n\tif (ar->num_tx_chains < 2) {\n\t\t*vht_cap &= ~(IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE);\n\t\tsubfer = false;\n\t}\n\n\tif (ar->num_rx_chains < 2) {\n\t\t*vht_cap &= ~(IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE);\n\t\tsubfee = false;\n\t}\n\n\t \n\tif (!subfer)\n\t\t*vht_cap &= ~(IEEE80211_VHT_CAP_MU_BEAMFORMER_CAPABLE);\n\n\t \n\tif (!subfee)\n\t\t*vht_cap &= ~(IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE);\n\n\tsound_dim = (*vht_cap & IEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_MASK);\n\tsound_dim >>= IEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_SHIFT;\n\t*vht_cap &= ~IEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_MASK;\n\n\tnsts = (*vht_cap & IEEE80211_VHT_CAP_BEAMFORMEE_STS_MASK);\n\tnsts >>= IEEE80211_VHT_CAP_BEAMFORMEE_STS_SHIFT;\n\t*vht_cap &= ~IEEE80211_VHT_CAP_BEAMFORMEE_STS_MASK;\n\n\t \n\tif (subfer) {\n\t\tif (sound_dim > (ar->num_tx_chains - 1))\n\t\t\tsound_dim = ar->num_tx_chains - 1;\n\n\t\tsound_dim <<= IEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_SHIFT;\n\t\tsound_dim &=  IEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_MASK;\n\t\t*vht_cap |= sound_dim;\n\t}\n\n\t \n\tif (subfee) {\n\t\tif (nsts > (ar->num_rx_chains - 1))\n\t\t\tnsts = ar->num_rx_chains - 1;\n\n\t\tnsts <<= IEEE80211_VHT_CAP_BEAMFORMEE_STS_SHIFT;\n\t\tnsts &=  IEEE80211_VHT_CAP_BEAMFORMEE_STS_MASK;\n\t\t*vht_cap |= nsts;\n\t}\n}\n\nstatic struct ieee80211_sta_vht_cap\nath11k_create_vht_cap(struct ath11k *ar, u32 rate_cap_tx_chainmask,\n\t\t      u32 rate_cap_rx_chainmask)\n{\n\tstruct ieee80211_sta_vht_cap vht_cap = {0};\n\tu16 txmcs_map, rxmcs_map;\n\tint i;\n\n\tvht_cap.vht_supported = 1;\n\tvht_cap.cap = ar->pdev->cap.vht_cap;\n\n\tif (ar->pdev->cap.nss_ratio_enabled)\n\t\tvht_cap.vht_mcs.tx_highest |=\n\t\t\tcpu_to_le16(IEEE80211_VHT_EXT_NSS_BW_CAPABLE);\n\n\tath11k_set_vht_txbf_cap(ar, &vht_cap.cap);\n\n\trxmcs_map = 0;\n\ttxmcs_map = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\tif (i < ar->num_tx_chains && rate_cap_tx_chainmask & BIT(i))\n\t\t\ttxmcs_map |= IEEE80211_VHT_MCS_SUPPORT_0_9 << (i * 2);\n\t\telse\n\t\t\ttxmcs_map |= IEEE80211_VHT_MCS_NOT_SUPPORTED << (i * 2);\n\n\t\tif (i < ar->num_rx_chains && rate_cap_rx_chainmask & BIT(i))\n\t\t\trxmcs_map |= IEEE80211_VHT_MCS_SUPPORT_0_9 << (i * 2);\n\t\telse\n\t\t\trxmcs_map |= IEEE80211_VHT_MCS_NOT_SUPPORTED << (i * 2);\n\t}\n\n\tif (rate_cap_tx_chainmask <= 1)\n\t\tvht_cap.cap &= ~IEEE80211_VHT_CAP_TXSTBC;\n\n\tvht_cap.vht_mcs.rx_mcs_map = cpu_to_le16(rxmcs_map);\n\tvht_cap.vht_mcs.tx_mcs_map = cpu_to_le16(txmcs_map);\n\n\treturn vht_cap;\n}\n\nstatic void ath11k_mac_setup_ht_vht_cap(struct ath11k *ar,\n\t\t\t\t\tstruct ath11k_pdev_cap *cap,\n\t\t\t\t\tu32 *ht_cap_info)\n{\n\tstruct ieee80211_supported_band *band;\n\tu32 rate_cap_tx_chainmask;\n\tu32 rate_cap_rx_chainmask;\n\tu32 ht_cap;\n\n\trate_cap_tx_chainmask = ar->cfg_tx_chainmask >> cap->tx_chain_mask_shift;\n\trate_cap_rx_chainmask = ar->cfg_rx_chainmask >> cap->rx_chain_mask_shift;\n\n\tif (cap->supported_bands & WMI_HOST_WLAN_2G_CAP) {\n\t\tband = &ar->mac.sbands[NL80211_BAND_2GHZ];\n\t\tht_cap = cap->band[NL80211_BAND_2GHZ].ht_cap_info;\n\t\tif (ht_cap_info)\n\t\t\t*ht_cap_info = ht_cap;\n\t\tband->ht_cap = ath11k_create_ht_cap(ar, ht_cap,\n\t\t\t\t\t\t    rate_cap_rx_chainmask);\n\t}\n\n\tif (cap->supported_bands & WMI_HOST_WLAN_5G_CAP &&\n\t    (ar->ab->hw_params.single_pdev_only ||\n\t     !ar->supports_6ghz)) {\n\t\tband = &ar->mac.sbands[NL80211_BAND_5GHZ];\n\t\tht_cap = cap->band[NL80211_BAND_5GHZ].ht_cap_info;\n\t\tif (ht_cap_info)\n\t\t\t*ht_cap_info = ht_cap;\n\t\tband->ht_cap = ath11k_create_ht_cap(ar, ht_cap,\n\t\t\t\t\t\t    rate_cap_rx_chainmask);\n\t\tband->vht_cap = ath11k_create_vht_cap(ar, rate_cap_tx_chainmask,\n\t\t\t\t\t\t      rate_cap_rx_chainmask);\n\t}\n}\n\nstatic int ath11k_check_chain_mask(struct ath11k *ar, u32 ant, bool is_tx_ant)\n{\n\t \n\n\treturn 0;\n}\n\nstatic void ath11k_gen_ppe_thresh(struct ath11k_ppe_threshold *fw_ppet,\n\t\t\t\t  u8 *he_ppet)\n{\n\tint nss, ru;\n\tu8 bit = 7;\n\n\the_ppet[0] = fw_ppet->numss_m1 & IEEE80211_PPE_THRES_NSS_MASK;\n\the_ppet[0] |= (fw_ppet->ru_bit_mask <<\n\t\t       IEEE80211_PPE_THRES_RU_INDEX_BITMASK_POS) &\n\t\t      IEEE80211_PPE_THRES_RU_INDEX_BITMASK_MASK;\n\tfor (nss = 0; nss <= fw_ppet->numss_m1; nss++) {\n\t\tfor (ru = 0; ru < 4; ru++) {\n\t\t\tu8 val;\n\t\t\tint i;\n\n\t\t\tif ((fw_ppet->ru_bit_mask & BIT(ru)) == 0)\n\t\t\t\tcontinue;\n\t\t\tval = (fw_ppet->ppet16_ppet8_ru3_ru0[nss] >> (ru * 6)) &\n\t\t\t       0x3f;\n\t\t\tval = ((val >> 3) & 0x7) | ((val & 0x7) << 3);\n\t\t\tfor (i = 5; i >= 0; i--) {\n\t\t\t\the_ppet[bit / 8] |=\n\t\t\t\t\t((val >> i) & 0x1) << ((bit % 8));\n\t\t\t\tbit++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void\nath11k_mac_filter_he_cap_mesh(struct ieee80211_he_cap_elem *he_cap_elem)\n{\n\tu8 m;\n\n\tm = IEEE80211_HE_MAC_CAP0_TWT_RES |\n\t    IEEE80211_HE_MAC_CAP0_TWT_REQ;\n\the_cap_elem->mac_cap_info[0] &= ~m;\n\n\tm = IEEE80211_HE_MAC_CAP2_TRS |\n\t    IEEE80211_HE_MAC_CAP2_BCAST_TWT |\n\t    IEEE80211_HE_MAC_CAP2_MU_CASCADING;\n\the_cap_elem->mac_cap_info[2] &= ~m;\n\n\tm = IEEE80211_HE_MAC_CAP3_FLEX_TWT_SCHED |\n\t    IEEE80211_HE_MAC_CAP2_BCAST_TWT |\n\t    IEEE80211_HE_MAC_CAP2_MU_CASCADING;\n\the_cap_elem->mac_cap_info[3] &= ~m;\n\n\tm = IEEE80211_HE_MAC_CAP4_BSRP_BQRP_A_MPDU_AGG |\n\t    IEEE80211_HE_MAC_CAP4_BQR;\n\the_cap_elem->mac_cap_info[4] &= ~m;\n\n\tm = IEEE80211_HE_MAC_CAP5_SUBCHAN_SELECTIVE_TRANSMISSION |\n\t    IEEE80211_HE_MAC_CAP5_UL_2x996_TONE_RU |\n\t    IEEE80211_HE_MAC_CAP5_PUNCTURED_SOUNDING |\n\t    IEEE80211_HE_MAC_CAP5_HT_VHT_TRIG_FRAME_RX;\n\the_cap_elem->mac_cap_info[5] &= ~m;\n\n\tm = IEEE80211_HE_PHY_CAP2_UL_MU_FULL_MU_MIMO |\n\t    IEEE80211_HE_PHY_CAP2_UL_MU_PARTIAL_MU_MIMO;\n\the_cap_elem->phy_cap_info[2] &= ~m;\n\n\tm = IEEE80211_HE_PHY_CAP3_RX_PARTIAL_BW_SU_IN_20MHZ_MU |\n\t    IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_TX_MASK |\n\t    IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_RX_MASK;\n\the_cap_elem->phy_cap_info[3] &= ~m;\n\n\tm = IEEE80211_HE_PHY_CAP4_MU_BEAMFORMER;\n\the_cap_elem->phy_cap_info[4] &= ~m;\n\n\tm = IEEE80211_HE_PHY_CAP5_NG16_MU_FEEDBACK;\n\the_cap_elem->phy_cap_info[5] &= ~m;\n\n\tm = IEEE80211_HE_PHY_CAP6_CODEBOOK_SIZE_75_MU |\n\t    IEEE80211_HE_PHY_CAP6_TRIG_MU_BEAMFORMING_PARTIAL_BW_FB |\n\t    IEEE80211_HE_PHY_CAP6_TRIG_CQI_FB |\n\t    IEEE80211_HE_PHY_CAP6_PARTIAL_BANDWIDTH_DL_MUMIMO;\n\the_cap_elem->phy_cap_info[6] &= ~m;\n\n\tm = IEEE80211_HE_PHY_CAP7_PSR_BASED_SR |\n\t    IEEE80211_HE_PHY_CAP7_POWER_BOOST_FACTOR_SUPP |\n\t    IEEE80211_HE_PHY_CAP7_STBC_TX_ABOVE_80MHZ |\n\t    IEEE80211_HE_PHY_CAP7_STBC_RX_ABOVE_80MHZ;\n\the_cap_elem->phy_cap_info[7] &= ~m;\n\n\tm = IEEE80211_HE_PHY_CAP8_HE_ER_SU_PPDU_4XLTF_AND_08_US_GI |\n\t    IEEE80211_HE_PHY_CAP8_20MHZ_IN_40MHZ_HE_PPDU_IN_2G |\n\t    IEEE80211_HE_PHY_CAP8_20MHZ_IN_160MHZ_HE_PPDU |\n\t    IEEE80211_HE_PHY_CAP8_80MHZ_IN_160MHZ_HE_PPDU;\n\the_cap_elem->phy_cap_info[8] &= ~m;\n\n\tm = IEEE80211_HE_PHY_CAP9_LONGER_THAN_16_SIGB_OFDM_SYM |\n\t    IEEE80211_HE_PHY_CAP9_NON_TRIGGERED_CQI_FEEDBACK |\n\t    IEEE80211_HE_PHY_CAP9_RX_1024_QAM_LESS_THAN_242_TONE_RU |\n\t    IEEE80211_HE_PHY_CAP9_TX_1024_QAM_LESS_THAN_242_TONE_RU |\n\t    IEEE80211_HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_WITH_COMP_SIGB |\n\t    IEEE80211_HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_WITH_NON_COMP_SIGB;\n\the_cap_elem->phy_cap_info[9] &= ~m;\n}\n\nstatic __le16 ath11k_mac_setup_he_6ghz_cap(struct ath11k_pdev_cap *pcap,\n\t\t\t\t\t   struct ath11k_band_cap *bcap)\n{\n\tu8 val;\n\n\tbcap->he_6ghz_capa = IEEE80211_HT_MPDU_DENSITY_NONE;\n\tif (bcap->ht_cap_info & WMI_HT_CAP_DYNAMIC_SMPS)\n\t\tbcap->he_6ghz_capa |=\n\t\t\tFIELD_PREP(IEEE80211_HE_6GHZ_CAP_SM_PS,\n\t\t\t\t   WLAN_HT_CAP_SM_PS_DYNAMIC);\n\telse\n\t\tbcap->he_6ghz_capa |=\n\t\t\tFIELD_PREP(IEEE80211_HE_6GHZ_CAP_SM_PS,\n\t\t\t\t   WLAN_HT_CAP_SM_PS_DISABLED);\n\tval = FIELD_GET(IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK,\n\t\t\tpcap->vht_cap);\n\tbcap->he_6ghz_capa |=\n\t\tFIELD_PREP(IEEE80211_HE_6GHZ_CAP_MAX_AMPDU_LEN_EXP, val);\n\tval = FIELD_GET(IEEE80211_VHT_CAP_MAX_MPDU_MASK, pcap->vht_cap);\n\tbcap->he_6ghz_capa |=\n\t\tFIELD_PREP(IEEE80211_HE_6GHZ_CAP_MAX_MPDU_LEN, val);\n\tif (pcap->vht_cap & IEEE80211_VHT_CAP_RX_ANTENNA_PATTERN)\n\t\tbcap->he_6ghz_capa |= IEEE80211_HE_6GHZ_CAP_RX_ANTPAT_CONS;\n\tif (pcap->vht_cap & IEEE80211_VHT_CAP_TX_ANTENNA_PATTERN)\n\t\tbcap->he_6ghz_capa |= IEEE80211_HE_6GHZ_CAP_TX_ANTPAT_CONS;\n\n\treturn cpu_to_le16(bcap->he_6ghz_capa);\n}\n\nstatic void ath11k_mac_set_hemcsmap(struct ath11k *ar,\n\t\t\t\t    struct ath11k_pdev_cap *cap,\n\t\t\t\t    struct ieee80211_sta_he_cap *he_cap,\n\t\t\t\t    int band)\n{\n\tu16 txmcs_map, rxmcs_map;\n\tu32 i;\n\n\trxmcs_map = 0;\n\ttxmcs_map = 0;\n\tfor (i = 0; i < 8; i++) {\n\t\tif (i < ar->num_tx_chains &&\n\t\t    (ar->cfg_tx_chainmask >> cap->tx_chain_mask_shift) & BIT(i))\n\t\t\ttxmcs_map |= IEEE80211_HE_MCS_SUPPORT_0_11 << (i * 2);\n\t\telse\n\t\t\ttxmcs_map |= IEEE80211_HE_MCS_NOT_SUPPORTED << (i * 2);\n\n\t\tif (i < ar->num_rx_chains &&\n\t\t    (ar->cfg_rx_chainmask >> cap->tx_chain_mask_shift) & BIT(i))\n\t\t\trxmcs_map |= IEEE80211_HE_MCS_SUPPORT_0_11 << (i * 2);\n\t\telse\n\t\t\trxmcs_map |= IEEE80211_HE_MCS_NOT_SUPPORTED << (i * 2);\n\t}\n\the_cap->he_mcs_nss_supp.rx_mcs_80 =\n\t\tcpu_to_le16(rxmcs_map & 0xffff);\n\the_cap->he_mcs_nss_supp.tx_mcs_80 =\n\t\tcpu_to_le16(txmcs_map & 0xffff);\n\the_cap->he_mcs_nss_supp.rx_mcs_160 =\n\t\tcpu_to_le16(rxmcs_map & 0xffff);\n\the_cap->he_mcs_nss_supp.tx_mcs_160 =\n\t\tcpu_to_le16(txmcs_map & 0xffff);\n\the_cap->he_mcs_nss_supp.rx_mcs_80p80 =\n\t\tcpu_to_le16(rxmcs_map & 0xffff);\n\the_cap->he_mcs_nss_supp.tx_mcs_80p80 =\n\t\tcpu_to_le16(txmcs_map & 0xffff);\n}\n\nstatic int ath11k_mac_copy_he_cap(struct ath11k *ar,\n\t\t\t\t  struct ath11k_pdev_cap *cap,\n\t\t\t\t  struct ieee80211_sband_iftype_data *data,\n\t\t\t\t  int band)\n{\n\tint i, idx = 0;\n\n\tfor (i = 0; i < NUM_NL80211_IFTYPES; i++) {\n\t\tstruct ieee80211_sta_he_cap *he_cap = &data[idx].he_cap;\n\t\tstruct ath11k_band_cap *band_cap = &cap->band[band];\n\t\tstruct ieee80211_he_cap_elem *he_cap_elem =\n\t\t\t\t&he_cap->he_cap_elem;\n\n\t\tswitch (i) {\n\t\tcase NL80211_IFTYPE_STATION:\n\t\tcase NL80211_IFTYPE_AP:\n\t\tcase NL80211_IFTYPE_MESH_POINT:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\tdata[idx].types_mask = BIT(i);\n\t\the_cap->has_he = true;\n\t\tmemcpy(he_cap_elem->mac_cap_info, band_cap->he_cap_info,\n\t\t       sizeof(he_cap_elem->mac_cap_info));\n\t\tmemcpy(he_cap_elem->phy_cap_info, band_cap->he_cap_phy_info,\n\t\t       sizeof(he_cap_elem->phy_cap_info));\n\n\t\the_cap_elem->mac_cap_info[1] &=\n\t\t\tIEEE80211_HE_MAC_CAP1_TF_MAC_PAD_DUR_MASK;\n\n\t\the_cap_elem->phy_cap_info[5] &=\n\t\t\t~IEEE80211_HE_PHY_CAP5_BEAMFORMEE_NUM_SND_DIM_UNDER_80MHZ_MASK;\n\t\the_cap_elem->phy_cap_info[5] |= ar->num_tx_chains - 1;\n\n\t\tswitch (i) {\n\t\tcase NL80211_IFTYPE_AP:\n\t\t\the_cap_elem->phy_cap_info[3] &=\n\t\t\t\t~IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_TX_MASK;\n\t\t\the_cap_elem->phy_cap_info[9] |=\n\t\t\t\tIEEE80211_HE_PHY_CAP9_RX_1024_QAM_LESS_THAN_242_TONE_RU;\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_STATION:\n\t\t\the_cap_elem->mac_cap_info[0] &=\n\t\t\t\t~IEEE80211_HE_MAC_CAP0_TWT_RES;\n\t\t\the_cap_elem->mac_cap_info[0] |=\n\t\t\t\tIEEE80211_HE_MAC_CAP0_TWT_REQ;\n\t\t\the_cap_elem->phy_cap_info[9] |=\n\t\t\t\tIEEE80211_HE_PHY_CAP9_TX_1024_QAM_LESS_THAN_242_TONE_RU;\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_MESH_POINT:\n\t\t\tath11k_mac_filter_he_cap_mesh(he_cap_elem);\n\t\t\tbreak;\n\t\t}\n\n\t\tath11k_mac_set_hemcsmap(ar, cap, he_cap, band);\n\n\t\tmemset(he_cap->ppe_thres, 0, sizeof(he_cap->ppe_thres));\n\t\tif (he_cap_elem->phy_cap_info[6] &\n\t\t    IEEE80211_HE_PHY_CAP6_PPE_THRESHOLD_PRESENT)\n\t\t\tath11k_gen_ppe_thresh(&band_cap->he_ppet,\n\t\t\t\t\t      he_cap->ppe_thres);\n\n\t\tif (band == NL80211_BAND_6GHZ) {\n\t\t\tdata[idx].he_6ghz_capa.capa =\n\t\t\t\tath11k_mac_setup_he_6ghz_cap(cap, band_cap);\n\t\t}\n\t\tidx++;\n\t}\n\n\treturn idx;\n}\n\nstatic void ath11k_mac_setup_he_cap(struct ath11k *ar,\n\t\t\t\t    struct ath11k_pdev_cap *cap)\n{\n\tstruct ieee80211_supported_band *band;\n\tint count;\n\n\tif (cap->supported_bands & WMI_HOST_WLAN_2G_CAP) {\n\t\tcount = ath11k_mac_copy_he_cap(ar, cap,\n\t\t\t\t\t       ar->mac.iftype[NL80211_BAND_2GHZ],\n\t\t\t\t\t       NL80211_BAND_2GHZ);\n\t\tband = &ar->mac.sbands[NL80211_BAND_2GHZ];\n\t\tband->iftype_data = ar->mac.iftype[NL80211_BAND_2GHZ];\n\t\tband->n_iftype_data = count;\n\t}\n\n\tif (cap->supported_bands & WMI_HOST_WLAN_5G_CAP) {\n\t\tcount = ath11k_mac_copy_he_cap(ar, cap,\n\t\t\t\t\t       ar->mac.iftype[NL80211_BAND_5GHZ],\n\t\t\t\t\t       NL80211_BAND_5GHZ);\n\t\tband = &ar->mac.sbands[NL80211_BAND_5GHZ];\n\t\tband->iftype_data = ar->mac.iftype[NL80211_BAND_5GHZ];\n\t\tband->n_iftype_data = count;\n\t}\n\n\tif (cap->supported_bands & WMI_HOST_WLAN_5G_CAP &&\n\t    ar->supports_6ghz) {\n\t\tcount = ath11k_mac_copy_he_cap(ar, cap,\n\t\t\t\t\t       ar->mac.iftype[NL80211_BAND_6GHZ],\n\t\t\t\t\t       NL80211_BAND_6GHZ);\n\t\tband = &ar->mac.sbands[NL80211_BAND_6GHZ];\n\t\tband->iftype_data = ar->mac.iftype[NL80211_BAND_6GHZ];\n\t\tband->n_iftype_data = count;\n\t}\n}\n\nstatic int __ath11k_set_antenna(struct ath11k *ar, u32 tx_ant, u32 rx_ant)\n{\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (ath11k_check_chain_mask(ar, tx_ant, true))\n\t\treturn -EINVAL;\n\n\tif (ath11k_check_chain_mask(ar, rx_ant, false))\n\t\treturn -EINVAL;\n\n\tar->cfg_tx_chainmask = tx_ant;\n\tar->cfg_rx_chainmask = rx_ant;\n\n\tif (ar->state != ATH11K_STATE_ON &&\n\t    ar->state != ATH11K_STATE_RESTARTED)\n\t\treturn 0;\n\n\tret = ath11k_wmi_pdev_set_param(ar, WMI_PDEV_PARAM_TX_CHAIN_MASK,\n\t\t\t\t\ttx_ant, ar->pdev->pdev_id);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to set tx-chainmask: %d, req 0x%x\\n\",\n\t\t\t    ret, tx_ant);\n\t\treturn ret;\n\t}\n\n\tar->num_tx_chains = get_num_chains(tx_ant);\n\n\tret = ath11k_wmi_pdev_set_param(ar, WMI_PDEV_PARAM_RX_CHAIN_MASK,\n\t\t\t\t\trx_ant, ar->pdev->pdev_id);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to set rx-chainmask: %d, req 0x%x\\n\",\n\t\t\t    ret, rx_ant);\n\t\treturn ret;\n\t}\n\n\tar->num_rx_chains = get_num_chains(rx_ant);\n\n\t \n\tath11k_mac_setup_ht_vht_cap(ar, &ar->pdev->cap, NULL);\n\tath11k_mac_setup_he_cap(ar, &ar->pdev->cap);\n\n\treturn 0;\n}\n\nstatic void ath11k_mgmt_over_wmi_tx_drop(struct ath11k *ar, struct sk_buff *skb)\n{\n\tint num_mgmt;\n\n\tieee80211_free_txskb(ar->hw, skb);\n\n\tnum_mgmt = atomic_dec_if_positive(&ar->num_pending_mgmt_tx);\n\n\tif (num_mgmt < 0)\n\t\tWARN_ON_ONCE(1);\n\n\tif (!num_mgmt)\n\t\twake_up(&ar->txmgmt_empty_waitq);\n}\n\nstatic void ath11k_mac_tx_mgmt_free(struct ath11k *ar, int buf_id)\n{\n\tstruct sk_buff *msdu;\n\tstruct ieee80211_tx_info *info;\n\n\tspin_lock_bh(&ar->txmgmt_idr_lock);\n\tmsdu = idr_remove(&ar->txmgmt_idr, buf_id);\n\tspin_unlock_bh(&ar->txmgmt_idr_lock);\n\n\tif (!msdu)\n\t\treturn;\n\n\tdma_unmap_single(ar->ab->dev, ATH11K_SKB_CB(msdu)->paddr, msdu->len,\n\t\t\t DMA_TO_DEVICE);\n\n\tinfo = IEEE80211_SKB_CB(msdu);\n\tmemset(&info->status, 0, sizeof(info->status));\n\n\tath11k_mgmt_over_wmi_tx_drop(ar, msdu);\n}\n\nint ath11k_mac_tx_mgmt_pending_free(int buf_id, void *skb, void *ctx)\n{\n\tstruct ath11k *ar = ctx;\n\n\tath11k_mac_tx_mgmt_free(ar, buf_id);\n\n\treturn 0;\n}\n\nstatic int ath11k_mac_vif_txmgmt_idr_remove(int buf_id, void *skb, void *ctx)\n{\n\tstruct ieee80211_vif *vif = ctx;\n\tstruct ath11k_skb_cb *skb_cb = ATH11K_SKB_CB((struct sk_buff *)skb);\n\tstruct ath11k *ar = skb_cb->ar;\n\n\tif (skb_cb->vif == vif)\n\t\tath11k_mac_tx_mgmt_free(ar, buf_id);\n\n\treturn 0;\n}\n\nstatic int ath11k_mac_mgmt_tx_wmi(struct ath11k *ar, struct ath11k_vif *arvif,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct ath11k_base *ab = ar->ab;\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tstruct ieee80211_tx_info *info;\n\tdma_addr_t paddr;\n\tint buf_id;\n\tint ret;\n\n\tATH11K_SKB_CB(skb)->ar = ar;\n\n\tspin_lock_bh(&ar->txmgmt_idr_lock);\n\tbuf_id = idr_alloc(&ar->txmgmt_idr, skb, 0,\n\t\t\t   ATH11K_TX_MGMT_NUM_PENDING_MAX, GFP_ATOMIC);\n\tspin_unlock_bh(&ar->txmgmt_idr_lock);\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_MAC,\n\t\t   \"tx mgmt frame, buf id %d\\n\", buf_id);\n\n\tif (buf_id < 0)\n\t\treturn -ENOSPC;\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\tif (!(info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP)) {\n\t\tif ((ieee80211_is_action(hdr->frame_control) ||\n\t\t     ieee80211_is_deauth(hdr->frame_control) ||\n\t\t     ieee80211_is_disassoc(hdr->frame_control)) &&\n\t\t     ieee80211_has_protected(hdr->frame_control)) {\n\t\t\tskb_put(skb, IEEE80211_CCMP_MIC_LEN);\n\t\t}\n\t}\n\n\tpaddr = dma_map_single(ab->dev, skb->data, skb->len, DMA_TO_DEVICE);\n\tif (dma_mapping_error(ab->dev, paddr)) {\n\t\tath11k_warn(ab, \"failed to DMA map mgmt Tx buffer\\n\");\n\t\tret = -EIO;\n\t\tgoto err_free_idr;\n\t}\n\n\tATH11K_SKB_CB(skb)->paddr = paddr;\n\n\tret = ath11k_wmi_mgmt_send(ar, arvif->vdev_id, buf_id, skb);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to send mgmt frame: %d\\n\", ret);\n\t\tgoto err_unmap_buf;\n\t}\n\n\treturn 0;\n\nerr_unmap_buf:\n\tdma_unmap_single(ab->dev, ATH11K_SKB_CB(skb)->paddr,\n\t\t\t skb->len, DMA_TO_DEVICE);\nerr_free_idr:\n\tspin_lock_bh(&ar->txmgmt_idr_lock);\n\tidr_remove(&ar->txmgmt_idr, buf_id);\n\tspin_unlock_bh(&ar->txmgmt_idr_lock);\n\n\treturn ret;\n}\n\nstatic void ath11k_mgmt_over_wmi_tx_purge(struct ath11k *ar)\n{\n\tstruct sk_buff *skb;\n\n\twhile ((skb = skb_dequeue(&ar->wmi_mgmt_tx_queue)) != NULL)\n\t\tath11k_mgmt_over_wmi_tx_drop(ar, skb);\n}\n\nstatic void ath11k_mgmt_over_wmi_tx_work(struct work_struct *work)\n{\n\tstruct ath11k *ar = container_of(work, struct ath11k, wmi_mgmt_tx_work);\n\tstruct ath11k_skb_cb *skb_cb;\n\tstruct ath11k_vif *arvif;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\twhile ((skb = skb_dequeue(&ar->wmi_mgmt_tx_queue)) != NULL) {\n\t\tskb_cb = ATH11K_SKB_CB(skb);\n\t\tif (!skb_cb->vif) {\n\t\t\tath11k_warn(ar->ab, \"no vif found for mgmt frame\\n\");\n\t\t\tath11k_mgmt_over_wmi_tx_drop(ar, skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tarvif = ath11k_vif_to_arvif(skb_cb->vif);\n\t\tmutex_lock(&ar->conf_mutex);\n\t\tif (ar->allocated_vdev_map & (1LL << arvif->vdev_id)) {\n\t\t\tret = ath11k_mac_mgmt_tx_wmi(ar, arvif, skb);\n\t\t\tif (ret) {\n\t\t\t\tath11k_warn(ar->ab, \"failed to tx mgmt frame, vdev_id %d :%d\\n\",\n\t\t\t\t\t    arvif->vdev_id, ret);\n\t\t\t\tath11k_mgmt_over_wmi_tx_drop(ar, skb);\n\t\t\t} else {\n\t\t\t\tath11k_dbg(ar->ab, ATH11K_DBG_MAC,\n\t\t\t\t\t   \"tx mgmt frame, vdev_id %d\\n\",\n\t\t\t\t\t   arvif->vdev_id);\n\t\t\t}\n\t\t} else {\n\t\t\tath11k_warn(ar->ab,\n\t\t\t\t    \"dropping mgmt frame for vdev %d, is_started %d\\n\",\n\t\t\t\t    arvif->vdev_id,\n\t\t\t\t    arvif->is_started);\n\t\t\tath11k_mgmt_over_wmi_tx_drop(ar, skb);\n\t\t}\n\t\tmutex_unlock(&ar->conf_mutex);\n\t}\n}\n\nstatic int ath11k_mac_mgmt_tx(struct ath11k *ar, struct sk_buff *skb,\n\t\t\t      bool is_prb_rsp)\n{\n\tstruct sk_buff_head *q = &ar->wmi_mgmt_tx_queue;\n\n\tif (test_bit(ATH11K_FLAG_CRASH_FLUSH, &ar->ab->dev_flags))\n\t\treturn -ESHUTDOWN;\n\n\t \n\tif (is_prb_rsp &&\n\t    atomic_read(&ar->num_pending_mgmt_tx) > ATH11K_PRB_RSP_DROP_THRESHOLD) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"dropping probe response as pending queue is almost full\\n\");\n\t\treturn -ENOSPC;\n\t}\n\n\tif (skb_queue_len_lockless(q) >= ATH11K_TX_MGMT_NUM_PENDING_MAX) {\n\t\tath11k_warn(ar->ab, \"mgmt tx queue is full\\n\");\n\t\treturn -ENOSPC;\n\t}\n\n\tskb_queue_tail(q, skb);\n\tatomic_inc(&ar->num_pending_mgmt_tx);\n\tqueue_work(ar->ab->workqueue_aux, &ar->wmi_mgmt_tx_work);\n\n\treturn 0;\n}\n\nstatic void ath11k_mac_op_tx(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_tx_control *control,\n\t\t\t     struct sk_buff *skb)\n{\n\tstruct ath11k_skb_cb *skb_cb = ATH11K_SKB_CB(skb);\n\tstruct ath11k *ar = hw->priv;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_vif *vif = info->control.vif;\n\tstruct ath11k_vif *arvif = ath11k_vif_to_arvif(vif);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tstruct ieee80211_key_conf *key = info->control.hw_key;\n\tstruct ath11k_sta *arsta = NULL;\n\tu32 info_flags = info->flags;\n\tbool is_prb_rsp;\n\tint ret;\n\n\tmemset(skb_cb, 0, sizeof(*skb_cb));\n\tskb_cb->vif = vif;\n\n\tif (key) {\n\t\tskb_cb->cipher = key->cipher;\n\t\tskb_cb->flags |= ATH11K_SKB_CIPHER_SET;\n\t}\n\n\tif (info_flags & IEEE80211_TX_CTL_HW_80211_ENCAP) {\n\t\tskb_cb->flags |= ATH11K_SKB_HW_80211_ENCAP;\n\t} else if (ieee80211_is_mgmt(hdr->frame_control)) {\n\t\tis_prb_rsp = ieee80211_is_probe_resp(hdr->frame_control);\n\t\tret = ath11k_mac_mgmt_tx(ar, skb, is_prb_rsp);\n\t\tif (ret) {\n\t\t\tath11k_warn(ar->ab, \"failed to queue management frame %d\\n\",\n\t\t\t\t    ret);\n\t\t\tieee80211_free_txskb(ar->hw, skb);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (control->sta)\n\t\tarsta = (struct ath11k_sta *)control->sta->drv_priv;\n\n\tret = ath11k_dp_tx(ar, arvif, arsta, skb);\n\tif (unlikely(ret)) {\n\t\tath11k_warn(ar->ab, \"failed to transmit frame %d\\n\", ret);\n\t\tieee80211_free_txskb(ar->hw, skb);\n\t}\n}\n\nvoid ath11k_mac_drain_tx(struct ath11k *ar)\n{\n\t \n\tsynchronize_net();\n\n\tcancel_work_sync(&ar->wmi_mgmt_tx_work);\n\tath11k_mgmt_over_wmi_tx_purge(ar);\n}\n\nstatic int ath11k_mac_config_mon_status_default(struct ath11k *ar, bool enable)\n{\n\tstruct htt_rx_ring_tlv_filter tlv_filter = {0};\n\tstruct ath11k_base *ab = ar->ab;\n\tint i, ret = 0;\n\tu32 ring_id;\n\n\tif (enable) {\n\t\ttlv_filter = ath11k_mac_mon_status_filter_default;\n\t\tif (ath11k_debugfs_rx_filter(ar))\n\t\t\ttlv_filter.rx_filter = ath11k_debugfs_rx_filter(ar);\n\t}\n\n\tfor (i = 0; i < ab->hw_params.num_rxmda_per_pdev; i++) {\n\t\tring_id = ar->dp.rx_mon_status_refill_ring[i].refill_buf_ring.ring_id;\n\t\tret = ath11k_dp_tx_htt_rx_filter_setup(ar->ab, ring_id,\n\t\t\t\t\t\t       ar->dp.mac_id + i,\n\t\t\t\t\t\t       HAL_RXDMA_MONITOR_STATUS,\n\t\t\t\t\t\t       DP_RX_BUFFER_SIZE,\n\t\t\t\t\t\t       &tlv_filter);\n\t}\n\n\tif (enable && !ar->ab->hw_params.rxdma1_enable)\n\t\tmod_timer(&ar->ab->mon_reap_timer, jiffies +\n\t\t\t  msecs_to_jiffies(ATH11K_MON_TIMER_INTERVAL));\n\n\treturn ret;\n}\n\nstatic void ath11k_mac_wait_reconfigure(struct ath11k_base *ab)\n{\n\tint recovery_start_count;\n\n\tif (!ab->is_reset)\n\t\treturn;\n\n\trecovery_start_count = atomic_inc_return(&ab->recovery_start_count);\n\tath11k_dbg(ab, ATH11K_DBG_MAC, \"recovery start count %d\\n\", recovery_start_count);\n\n\tif (recovery_start_count == ab->num_radios) {\n\t\tcomplete(&ab->recovery_start);\n\t\tath11k_dbg(ab, ATH11K_DBG_MAC, \"recovery started success\\n\");\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_MAC, \"waiting reconfigure...\\n\");\n\n\twait_for_completion_timeout(&ab->reconfigure_complete,\n\t\t\t\t    ATH11K_RECONFIGURE_TIMEOUT_HZ);\n}\n\nstatic int ath11k_mac_op_start(struct ieee80211_hw *hw)\n{\n\tstruct ath11k *ar = hw->priv;\n\tstruct ath11k_base *ab = ar->ab;\n\tstruct ath11k_pdev *pdev = ar->pdev;\n\tint ret;\n\n\tif (ath11k_ftm_mode) {\n\t\tath11k_warn(ab, \"mac operations not supported in factory test mode\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tath11k_mac_drain_tx(ar);\n\tmutex_lock(&ar->conf_mutex);\n\n\tswitch (ar->state) {\n\tcase ATH11K_STATE_OFF:\n\t\tar->state = ATH11K_STATE_ON;\n\t\tbreak;\n\tcase ATH11K_STATE_RESTARTING:\n\t\tar->state = ATH11K_STATE_RESTARTED;\n\t\tath11k_mac_wait_reconfigure(ab);\n\t\tbreak;\n\tcase ATH11K_STATE_RESTARTED:\n\tcase ATH11K_STATE_WEDGED:\n\tcase ATH11K_STATE_ON:\n\tcase ATH11K_STATE_FTM:\n\t\tWARN_ON(1);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tret = ath11k_wmi_pdev_set_param(ar, WMI_PDEV_PARAM_PMF_QOS,\n\t\t\t\t\t1, pdev->pdev_id);\n\n\tif (ret) {\n\t\tath11k_err(ar->ab, \"failed to enable PMF QOS: (%d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tret = ath11k_wmi_pdev_set_param(ar, WMI_PDEV_PARAM_DYNAMIC_BW, 1,\n\t\t\t\t\tpdev->pdev_id);\n\tif (ret) {\n\t\tath11k_err(ar->ab, \"failed to enable dynamic bw: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tif (test_bit(WMI_TLV_SERVICE_SPOOF_MAC_SUPPORT, ar->wmi->wmi_ab->svc_map)) {\n\t\tret = ath11k_wmi_scan_prob_req_oui(ar, ar->mac_addr);\n\t\tif (ret) {\n\t\t\tath11k_err(ab, \"failed to set prob req oui: %i\\n\", ret);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tret = ath11k_wmi_pdev_set_param(ar, WMI_PDEV_PARAM_ARP_AC_OVERRIDE,\n\t\t\t\t\t0, pdev->pdev_id);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to set ac override for ARP: %d\\n\",\n\t\t\t   ret);\n\t\tgoto err;\n\t}\n\n\tret = ath11k_wmi_send_dfs_phyerr_offload_enable_cmd(ar, pdev->pdev_id);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to offload radar detection: %d\\n\",\n\t\t\t   ret);\n\t\tgoto err;\n\t}\n\n\tret = ath11k_dp_tx_htt_h2t_ppdu_stats_req(ar,\n\t\t\t\t\t\t  HTT_PPDU_STATS_TAG_DEFAULT);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to req ppdu stats: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tret = ath11k_wmi_pdev_set_param(ar, WMI_PDEV_PARAM_MESH_MCAST_ENABLE,\n\t\t\t\t\t1, pdev->pdev_id);\n\n\tif (ret) {\n\t\tath11k_err(ar->ab, \"failed to enable MESH MCAST ENABLE: (%d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\t__ath11k_set_antenna(ar, ar->cfg_tx_chainmask, ar->cfg_rx_chainmask);\n\n\t \n\n\tath11k_reg_update_chan_list(ar, false);\n\n\tar->num_started_vdevs = 0;\n\tar->num_created_vdevs = 0;\n\tar->num_peers = 0;\n\tar->allocated_vdev_map = 0;\n\n\t \n\tret = ath11k_mac_config_mon_status_default(ar, true);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to configure monitor status ring with default rx_filter: (%d)\\n\",\n\t\t\t   ret);\n\t\tgoto err;\n\t}\n\n\t \n\tath11k_wmi_pdev_lro_cfg(ar, ar->pdev->pdev_id);\n\n\t \n\tif (ab->hw_params.idle_ps) {\n\t\tret = ath11k_wmi_pdev_set_param(ar, WMI_PDEV_PARAM_IDLE_PS_CONFIG,\n\t\t\t\t\t\t1, pdev->pdev_id);\n\t\tif (ret) {\n\t\t\tath11k_err(ab, \"failed to enable idle ps: %d\\n\", ret);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tmutex_unlock(&ar->conf_mutex);\n\n\trcu_assign_pointer(ab->pdevs_active[ar->pdev_idx],\n\t\t\t   &ab->pdevs[ar->pdev_idx]);\n\n\treturn 0;\n\nerr:\n\tar->state = ATH11K_STATE_OFF;\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn ret;\n}\n\nstatic void ath11k_mac_op_stop(struct ieee80211_hw *hw)\n{\n\tstruct ath11k *ar = hw->priv;\n\tstruct htt_ppdu_stats_info *ppdu_stats, *tmp;\n\tint ret;\n\n\tath11k_mac_drain_tx(ar);\n\n\tmutex_lock(&ar->conf_mutex);\n\tret = ath11k_mac_config_mon_status_default(ar, false);\n\tif (ret)\n\t\tath11k_err(ar->ab, \"failed to clear rx_filter for monitor status ring: (%d)\\n\",\n\t\t\t   ret);\n\n\tclear_bit(ATH11K_CAC_RUNNING, &ar->dev_flags);\n\tar->state = ATH11K_STATE_OFF;\n\tmutex_unlock(&ar->conf_mutex);\n\n\tcancel_delayed_work_sync(&ar->scan.timeout);\n\tcancel_work_sync(&ar->regd_update_work);\n\tcancel_work_sync(&ar->ab->update_11d_work);\n\n\tif (ar->state_11d == ATH11K_11D_PREPARING) {\n\t\tar->state_11d = ATH11K_11D_IDLE;\n\t\tcomplete(&ar->completed_11d_scan);\n\t}\n\n\tspin_lock_bh(&ar->data_lock);\n\tlist_for_each_entry_safe(ppdu_stats, tmp, &ar->ppdu_stats_info, list) {\n\t\tlist_del(&ppdu_stats->list);\n\t\tkfree(ppdu_stats);\n\t}\n\tspin_unlock_bh(&ar->data_lock);\n\n\trcu_assign_pointer(ar->ab->pdevs_active[ar->pdev_idx], NULL);\n\n\tsynchronize_rcu();\n\n\tatomic_set(&ar->num_pending_mgmt_tx, 0);\n}\n\nstatic int ath11k_mac_setup_vdev_params_mbssid(struct ath11k_vif *arvif,\n\t\t\t\t\t       u32 *flags, u32 *tx_vdev_id)\n{\n\tstruct ath11k *ar = arvif->ar;\n\tstruct ath11k_vif *tx_arvif;\n\tstruct ieee80211_vif *tx_vif;\n\n\t*tx_vdev_id = 0;\n\ttx_vif = arvif->vif->mbssid_tx_vif;\n\tif (!tx_vif) {\n\t\t*flags = WMI_HOST_VDEV_FLAGS_NON_MBSSID_AP;\n\t\treturn 0;\n\t}\n\n\ttx_arvif = ath11k_vif_to_arvif(tx_vif);\n\n\tif (arvif->vif->bss_conf.nontransmitted) {\n\t\tif (ar->hw->wiphy != ieee80211_vif_to_wdev(tx_vif)->wiphy)\n\t\t\treturn -EINVAL;\n\n\t\t*flags = WMI_HOST_VDEV_FLAGS_NON_TRANSMIT_AP;\n\t\t*tx_vdev_id = ath11k_vif_to_arvif(tx_vif)->vdev_id;\n\t} else if (tx_arvif == arvif) {\n\t\t*flags = WMI_HOST_VDEV_FLAGS_TRANSMIT_AP;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\tif (arvif->vif->bss_conf.ema_ap)\n\t\t*flags |= WMI_HOST_VDEV_FLAGS_EMA_MODE;\n\n\treturn 0;\n}\n\nstatic int ath11k_mac_setup_vdev_create_params(struct ath11k_vif *arvif,\n\t\t\t\t\t       struct vdev_create_params *params)\n{\n\tstruct ath11k *ar = arvif->ar;\n\tstruct ath11k_pdev *pdev = ar->pdev;\n\tint ret;\n\n\tparams->if_id = arvif->vdev_id;\n\tparams->type = arvif->vdev_type;\n\tparams->subtype = arvif->vdev_subtype;\n\tparams->pdev_id = pdev->pdev_id;\n\tparams->mbssid_flags = 0;\n\tparams->mbssid_tx_vdev_id = 0;\n\n\tif (!test_bit(WMI_TLV_SERVICE_MBSS_PARAM_IN_VDEV_START_SUPPORT,\n\t\t      ar->ab->wmi_ab.svc_map)) {\n\t\tret = ath11k_mac_setup_vdev_params_mbssid(arvif,\n\t\t\t\t\t\t\t  &params->mbssid_flags,\n\t\t\t\t\t\t\t  &params->mbssid_tx_vdev_id);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (pdev->cap.supported_bands & WMI_HOST_WLAN_2G_CAP) {\n\t\tparams->chains[NL80211_BAND_2GHZ].tx = ar->num_tx_chains;\n\t\tparams->chains[NL80211_BAND_2GHZ].rx = ar->num_rx_chains;\n\t}\n\tif (pdev->cap.supported_bands & WMI_HOST_WLAN_5G_CAP) {\n\t\tparams->chains[NL80211_BAND_5GHZ].tx = ar->num_tx_chains;\n\t\tparams->chains[NL80211_BAND_5GHZ].rx = ar->num_rx_chains;\n\t}\n\tif (pdev->cap.supported_bands & WMI_HOST_WLAN_5G_CAP &&\n\t    ar->supports_6ghz) {\n\t\tparams->chains[NL80211_BAND_6GHZ].tx = ar->num_tx_chains;\n\t\tparams->chains[NL80211_BAND_6GHZ].rx = ar->num_rx_chains;\n\t}\n\treturn 0;\n}\n\nstatic void ath11k_mac_op_update_vif_offload(struct ieee80211_hw *hw,\n\t\t\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct ath11k *ar = hw->priv;\n\tstruct ath11k_base *ab = ar->ab;\n\tstruct ath11k_vif *arvif = ath11k_vif_to_arvif(vif);\n\tu32 param_id, param_value;\n\tint ret;\n\n\tparam_id = WMI_VDEV_PARAM_TX_ENCAP_TYPE;\n\tif (ath11k_frame_mode != ATH11K_HW_TXRX_ETHERNET ||\n\t    (vif->type != NL80211_IFTYPE_STATION &&\n\t     vif->type != NL80211_IFTYPE_AP))\n\t\tvif->offload_flags &= ~(IEEE80211_OFFLOAD_ENCAP_ENABLED |\n\t\t\t\t\tIEEE80211_OFFLOAD_DECAP_ENABLED);\n\n\tif (vif->offload_flags & IEEE80211_OFFLOAD_ENCAP_ENABLED)\n\t\tparam_value = ATH11K_HW_TXRX_ETHERNET;\n\telse if (test_bit(ATH11K_FLAG_RAW_MODE, &ab->dev_flags))\n\t\tparam_value = ATH11K_HW_TXRX_RAW;\n\telse\n\t\tparam_value = ATH11K_HW_TXRX_NATIVE_WIFI;\n\n\tret = ath11k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id,\n\t\t\t\t\t    param_id, param_value);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to set vdev %d tx encap mode: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\tvif->offload_flags &= ~IEEE80211_OFFLOAD_ENCAP_ENABLED;\n\t}\n\n\tparam_id = WMI_VDEV_PARAM_RX_DECAP_TYPE;\n\tif (vif->offload_flags & IEEE80211_OFFLOAD_DECAP_ENABLED)\n\t\tparam_value = ATH11K_HW_TXRX_ETHERNET;\n\telse if (test_bit(ATH11K_FLAG_RAW_MODE, &ab->dev_flags))\n\t\tparam_value = ATH11K_HW_TXRX_RAW;\n\telse\n\t\tparam_value = ATH11K_HW_TXRX_NATIVE_WIFI;\n\n\tret = ath11k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id,\n\t\t\t\t\t    param_id, param_value);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to set vdev %d rx decap mode: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\tvif->offload_flags &= ~IEEE80211_OFFLOAD_DECAP_ENABLED;\n\t}\n}\n\nstatic bool ath11k_mac_vif_ap_active_any(struct ath11k_base *ab)\n{\n\tstruct ath11k *ar;\n\tstruct ath11k_pdev *pdev;\n\tstruct ath11k_vif *arvif;\n\tint i;\n\n\tfor (i = 0; i < ab->num_radios; i++) {\n\t\tpdev = &ab->pdevs[i];\n\t\tar = pdev->ar;\n\t\tlist_for_each_entry(arvif, &ar->arvifs, list) {\n\t\t\tif (arvif->is_up && arvif->vdev_type == WMI_VDEV_TYPE_AP)\n\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid ath11k_mac_11d_scan_start(struct ath11k *ar, u32 vdev_id)\n{\n\tstruct wmi_11d_scan_start_params param;\n\tint ret;\n\n\tmutex_lock(&ar->ab->vdev_id_11d_lock);\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_MAC, \"vdev id for 11d scan %d\\n\",\n\t\t   ar->vdev_id_11d_scan);\n\n\tif (ar->regdom_set_by_user)\n\t\tgoto fin;\n\n\tif (ar->vdev_id_11d_scan != ATH11K_11D_INVALID_VDEV_ID)\n\t\tgoto fin;\n\n\tif (!test_bit(WMI_TLV_SERVICE_11D_OFFLOAD, ar->ab->wmi_ab.svc_map))\n\t\tgoto fin;\n\n\tif (ath11k_mac_vif_ap_active_any(ar->ab))\n\t\tgoto fin;\n\n\tparam.vdev_id = vdev_id;\n\tparam.start_interval_msec = 0;\n\tparam.scan_period_msec = ATH11K_SCAN_11D_INTERVAL;\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_MAC, \"start 11d scan\\n\");\n\n\tret = ath11k_wmi_send_11d_scan_start_cmd(ar, &param);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to start 11d scan vdev %d ret: %d\\n\",\n\t\t\t    vdev_id, ret);\n\t} else {\n\t\tar->vdev_id_11d_scan = vdev_id;\n\t\tif (ar->state_11d == ATH11K_11D_PREPARING)\n\t\t\tar->state_11d = ATH11K_11D_RUNNING;\n\t}\n\nfin:\n\tif (ar->state_11d == ATH11K_11D_PREPARING) {\n\t\tar->state_11d = ATH11K_11D_IDLE;\n\t\tcomplete(&ar->completed_11d_scan);\n\t}\n\n\tmutex_unlock(&ar->ab->vdev_id_11d_lock);\n}\n\nvoid ath11k_mac_11d_scan_stop(struct ath11k *ar)\n{\n\tint ret;\n\tu32 vdev_id;\n\n\tif (!test_bit(WMI_TLV_SERVICE_11D_OFFLOAD, ar->ab->wmi_ab.svc_map))\n\t\treturn;\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_MAC, \"stop 11d scan\\n\");\n\n\tmutex_lock(&ar->ab->vdev_id_11d_lock);\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_MAC, \"stop 11d vdev id %d\\n\",\n\t\t   ar->vdev_id_11d_scan);\n\n\tif (ar->state_11d == ATH11K_11D_PREPARING) {\n\t\tar->state_11d = ATH11K_11D_IDLE;\n\t\tcomplete(&ar->completed_11d_scan);\n\t}\n\n\tif (ar->vdev_id_11d_scan != ATH11K_11D_INVALID_VDEV_ID) {\n\t\tvdev_id = ar->vdev_id_11d_scan;\n\n\t\tret = ath11k_wmi_send_11d_scan_stop_cmd(ar, vdev_id);\n\t\tif (ret) {\n\t\t\tath11k_warn(ar->ab,\n\t\t\t\t    \"failed to stopt 11d scan vdev %d ret: %d\\n\",\n\t\t\t\t    vdev_id, ret);\n\t\t} else {\n\t\t\tar->vdev_id_11d_scan = ATH11K_11D_INVALID_VDEV_ID;\n\t\t\tar->state_11d = ATH11K_11D_IDLE;\n\t\t\tcomplete(&ar->completed_11d_scan);\n\t\t}\n\t}\n\tmutex_unlock(&ar->ab->vdev_id_11d_lock);\n}\n\nvoid ath11k_mac_11d_scan_stop_all(struct ath11k_base *ab)\n{\n\tstruct ath11k *ar;\n\tstruct ath11k_pdev *pdev;\n\tint i;\n\n\tath11k_dbg(ab, ATH11K_DBG_MAC, \"stop soc 11d scan\\n\");\n\n\tfor (i = 0; i < ab->num_radios; i++) {\n\t\tpdev = &ab->pdevs[i];\n\t\tar = pdev->ar;\n\n\t\tath11k_mac_11d_scan_stop(ar);\n\t}\n}\n\nstatic int ath11k_mac_vdev_delete(struct ath11k *ar, struct ath11k_vif *arvif)\n{\n\tunsigned long time_left;\n\tstruct ieee80211_vif *vif = arvif->vif;\n\tint ret = 0;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\treinit_completion(&ar->vdev_delete_done);\n\n\tret = ath11k_wmi_vdev_delete(ar, arvif->vdev_id);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to delete WMI vdev %d: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\ttime_left = wait_for_completion_timeout(&ar->vdev_delete_done,\n\t\t\t\t\t\tATH11K_VDEV_DELETE_TIMEOUT_HZ);\n\tif (time_left == 0) {\n\t\tath11k_warn(ar->ab, \"Timeout in receiving vdev delete response\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tar->ab->free_vdev_map |= 1LL << (arvif->vdev_id);\n\tar->allocated_vdev_map &= ~(1LL << arvif->vdev_id);\n\tar->num_created_vdevs--;\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_MAC, \"vdev %pM deleted, vdev_id %d\\n\",\n\t\t   vif->addr, arvif->vdev_id);\n\n\treturn ret;\n}\n\nstatic int ath11k_mac_op_add_interface(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_vif *vif)\n{\n\tstruct ath11k *ar = hw->priv;\n\tstruct ath11k_base *ab = ar->ab;\n\tstruct ath11k_vif *arvif = ath11k_vif_to_arvif(vif);\n\tstruct vdev_create_params vdev_param = {0};\n\tstruct peer_create_params peer_param;\n\tu32 param_id, param_value;\n\tu16 nss;\n\tint i;\n\tint ret, fbret;\n\tint bit;\n\n\tvif->driver_flags |= IEEE80211_VIF_SUPPORTS_UAPSD;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (vif->type == NL80211_IFTYPE_AP &&\n\t    ar->num_peers > (ar->max_num_peers - 1)) {\n\t\tath11k_warn(ab, \"failed to create vdev due to insufficient peer entry resource in firmware\\n\");\n\t\tret = -ENOBUFS;\n\t\tgoto err;\n\t}\n\n\tif (ar->num_created_vdevs > (TARGET_NUM_VDEVS(ab) - 1)) {\n\t\tath11k_warn(ab, \"failed to create vdev %u, reached max vdev limit %d\\n\",\n\t\t\t    ar->num_created_vdevs, TARGET_NUM_VDEVS(ab));\n\t\tret = -EBUSY;\n\t\tgoto err;\n\t}\n\n\t \n\tath11k_debugfs_remove_interface(arvif);\n\n\tmemset(arvif, 0, sizeof(*arvif));\n\n\tarvif->ar = ar;\n\tarvif->vif = vif;\n\n\tINIT_LIST_HEAD(&arvif->list);\n\tINIT_DELAYED_WORK(&arvif->connection_loss_work,\n\t\t\t  ath11k_mac_vif_sta_connection_loss_work);\n\n\tfor (i = 0; i < ARRAY_SIZE(arvif->bitrate_mask.control); i++) {\n\t\tarvif->bitrate_mask.control[i].legacy = 0xffffffff;\n\t\tarvif->bitrate_mask.control[i].gi = NL80211_TXRATE_FORCE_SGI;\n\t\tmemset(arvif->bitrate_mask.control[i].ht_mcs, 0xff,\n\t\t       sizeof(arvif->bitrate_mask.control[i].ht_mcs));\n\t\tmemset(arvif->bitrate_mask.control[i].vht_mcs, 0xff,\n\t\t       sizeof(arvif->bitrate_mask.control[i].vht_mcs));\n\t\tmemset(arvif->bitrate_mask.control[i].he_mcs, 0xff,\n\t\t       sizeof(arvif->bitrate_mask.control[i].he_mcs));\n\t}\n\n\tbit = __ffs64(ab->free_vdev_map);\n\n\tarvif->vdev_id = bit;\n\tarvif->vdev_subtype = WMI_VDEV_SUBTYPE_NONE;\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_UNSPECIFIED:\n\tcase NL80211_IFTYPE_STATION:\n\t\tarvif->vdev_type = WMI_VDEV_TYPE_STA;\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tarvif->vdev_subtype = WMI_VDEV_SUBTYPE_MESH_11S;\n\t\tfallthrough;\n\tcase NL80211_IFTYPE_AP:\n\t\tarvif->vdev_type = WMI_VDEV_TYPE_AP;\n\t\tbreak;\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tarvif->vdev_type = WMI_VDEV_TYPE_MONITOR;\n\t\tar->monitor_vdev_id = bit;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_MAC, \"add interface id %d type %d subtype %d map %llx\\n\",\n\t\t   arvif->vdev_id, arvif->vdev_type, arvif->vdev_subtype,\n\t\t   ab->free_vdev_map);\n\n\tvif->cab_queue = arvif->vdev_id % (ATH11K_HW_MAX_QUEUES - 1);\n\tfor (i = 0; i < ARRAY_SIZE(vif->hw_queue); i++)\n\t\tvif->hw_queue[i] = i % (ATH11K_HW_MAX_QUEUES - 1);\n\n\tret = ath11k_mac_setup_vdev_create_params(arvif, &vdev_param);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to create vdev parameters %d: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\tgoto err;\n\t}\n\n\tret = ath11k_wmi_vdev_create(ar, vif->addr, &vdev_param);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to create WMI vdev %d: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\tgoto err;\n\t}\n\n\tar->num_created_vdevs++;\n\tath11k_dbg(ab, ATH11K_DBG_MAC, \"vdev %pM created, vdev_id %d\\n\",\n\t\t   vif->addr, arvif->vdev_id);\n\tar->allocated_vdev_map |= 1LL << arvif->vdev_id;\n\tab->free_vdev_map &= ~(1LL << arvif->vdev_id);\n\n\tspin_lock_bh(&ar->data_lock);\n\tlist_add(&arvif->list, &ar->arvifs);\n\tspin_unlock_bh(&ar->data_lock);\n\n\tath11k_mac_op_update_vif_offload(hw, vif);\n\n\tnss = get_num_chains(ar->cfg_tx_chainmask) ? : 1;\n\tret = ath11k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id,\n\t\t\t\t\t    WMI_VDEV_PARAM_NSS, nss);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to set vdev %d chainmask 0x%x, nss %d :%d\\n\",\n\t\t\t    arvif->vdev_id, ar->cfg_tx_chainmask, nss, ret);\n\t\tgoto err_vdev_del;\n\t}\n\n\tswitch (arvif->vdev_type) {\n\tcase WMI_VDEV_TYPE_AP:\n\t\tpeer_param.vdev_id = arvif->vdev_id;\n\t\tpeer_param.peer_addr = vif->addr;\n\t\tpeer_param.peer_type = WMI_PEER_TYPE_DEFAULT;\n\t\tret = ath11k_peer_create(ar, arvif, NULL, &peer_param);\n\t\tif (ret) {\n\t\t\tath11k_warn(ab, \"failed to vdev %d create peer for AP: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\tgoto err_vdev_del;\n\t\t}\n\n\t\tret = ath11k_mac_set_kickout(arvif);\n\t\tif (ret) {\n\t\t\tath11k_warn(ar->ab, \"failed to set vdev %i kickout parameters: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\tgoto err_peer_del;\n\t\t}\n\n\t\tath11k_mac_11d_scan_stop_all(ar->ab);\n\t\tbreak;\n\tcase WMI_VDEV_TYPE_STA:\n\t\tparam_id = WMI_STA_PS_PARAM_RX_WAKE_POLICY;\n\t\tparam_value = WMI_STA_PS_RX_WAKE_POLICY_WAKE;\n\t\tret = ath11k_wmi_set_sta_ps_param(ar, arvif->vdev_id,\n\t\t\t\t\t\t  param_id, param_value);\n\t\tif (ret) {\n\t\t\tath11k_warn(ar->ab, \"failed to set vdev %d RX wake policy: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\tgoto err_peer_del;\n\t\t}\n\n\t\tparam_id = WMI_STA_PS_PARAM_TX_WAKE_THRESHOLD;\n\t\tparam_value = WMI_STA_PS_TX_WAKE_THRESHOLD_ALWAYS;\n\t\tret = ath11k_wmi_set_sta_ps_param(ar, arvif->vdev_id,\n\t\t\t\t\t\t  param_id, param_value);\n\t\tif (ret) {\n\t\t\tath11k_warn(ar->ab, \"failed to set vdev %d TX wake threshold: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\tgoto err_peer_del;\n\t\t}\n\n\t\tparam_id = WMI_STA_PS_PARAM_PSPOLL_COUNT;\n\t\tparam_value = WMI_STA_PS_PSPOLL_COUNT_NO_MAX;\n\t\tret = ath11k_wmi_set_sta_ps_param(ar, arvif->vdev_id,\n\t\t\t\t\t\t  param_id, param_value);\n\t\tif (ret) {\n\t\t\tath11k_warn(ar->ab, \"failed to set vdev %d pspoll count: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\tgoto err_peer_del;\n\t\t}\n\n\t\tret = ath11k_wmi_pdev_set_ps_mode(ar, arvif->vdev_id,\n\t\t\t\t\t\t  WMI_STA_PS_MODE_DISABLED);\n\t\tif (ret) {\n\t\t\tath11k_warn(ar->ab, \"failed to disable vdev %d ps mode: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\tgoto err_peer_del;\n\t\t}\n\n\t\tif (test_bit(WMI_TLV_SERVICE_11D_OFFLOAD, ab->wmi_ab.svc_map)) {\n\t\t\treinit_completion(&ar->completed_11d_scan);\n\t\t\tar->state_11d = ATH11K_11D_PREPARING;\n\t\t}\n\t\tbreak;\n\tcase WMI_VDEV_TYPE_MONITOR:\n\t\tset_bit(ATH11K_FLAG_MONITOR_VDEV_CREATED, &ar->monitor_flags);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tarvif->txpower = vif->bss_conf.txpower;\n\tret = ath11k_mac_txpower_recalc(ar);\n\tif (ret)\n\t\tgoto err_peer_del;\n\n\tparam_id = WMI_VDEV_PARAM_RTS_THRESHOLD;\n\tparam_value = ar->hw->wiphy->rts_threshold;\n\tret = ath11k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id,\n\t\t\t\t\t    param_id, param_value);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to set rts threshold for vdev %d: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t}\n\n\tath11k_dp_vdev_tx_attach(ar, arvif);\n\n\tath11k_debugfs_add_interface(arvif);\n\n\tif (vif->type != NL80211_IFTYPE_MONITOR &&\n\t    test_bit(ATH11K_FLAG_MONITOR_CONF_ENABLED, &ar->monitor_flags)) {\n\t\tret = ath11k_mac_monitor_vdev_create(ar);\n\t\tif (ret)\n\t\t\tath11k_warn(ar->ab, \"failed to create monitor vdev during add interface: %d\",\n\t\t\t\t    ret);\n\t}\n\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn 0;\n\nerr_peer_del:\n\tif (arvif->vdev_type == WMI_VDEV_TYPE_AP) {\n\t\tfbret = ath11k_peer_delete(ar, arvif->vdev_id, vif->addr);\n\t\tif (fbret) {\n\t\t\tath11k_warn(ar->ab, \"fallback fail to delete peer addr %pM vdev_id %d ret %d\\n\",\n\t\t\t\t    vif->addr, arvif->vdev_id, fbret);\n\t\t\tgoto err;\n\t\t}\n\t}\n\nerr_vdev_del:\n\tath11k_mac_vdev_delete(ar, arvif);\n\tspin_lock_bh(&ar->data_lock);\n\tlist_del(&arvif->list);\n\tspin_unlock_bh(&ar->data_lock);\n\nerr:\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn ret;\n}\n\nstatic int ath11k_mac_vif_unref(int buf_id, void *skb, void *ctx)\n{\n\tstruct ieee80211_vif *vif = (struct ieee80211_vif *)ctx;\n\tstruct ath11k_skb_cb *skb_cb = ATH11K_SKB_CB((struct sk_buff *)skb);\n\n\tif (skb_cb->vif == vif)\n\t\tskb_cb->vif = NULL;\n\n\treturn 0;\n}\n\nstatic void ath11k_mac_op_remove_interface(struct ieee80211_hw *hw,\n\t\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tstruct ath11k *ar = hw->priv;\n\tstruct ath11k_vif *arvif = ath11k_vif_to_arvif(vif);\n\tstruct ath11k_base *ab = ar->ab;\n\tint ret;\n\tint i;\n\n\tcancel_delayed_work_sync(&arvif->connection_loss_work);\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tath11k_dbg(ab, ATH11K_DBG_MAC, \"remove interface (vdev %d)\\n\",\n\t\t   arvif->vdev_id);\n\n\tret = ath11k_spectral_vif_stop(arvif);\n\tif (ret)\n\t\tath11k_warn(ab, \"failed to stop spectral for vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\n\tif (arvif->vdev_type == WMI_VDEV_TYPE_STA)\n\t\tath11k_mac_11d_scan_stop(ar);\n\n\tif (arvif->vdev_type == WMI_VDEV_TYPE_AP) {\n\t\tret = ath11k_peer_delete(ar, arvif->vdev_id, vif->addr);\n\t\tif (ret)\n\t\t\tath11k_warn(ab, \"failed to submit AP self-peer removal on vdev %d: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t}\n\n\tret = ath11k_mac_vdev_delete(ar, arvif);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to delete vdev %d: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\tgoto err_vdev_del;\n\t}\n\n\tif (arvif->vdev_type == WMI_VDEV_TYPE_MONITOR) {\n\t\tclear_bit(ATH11K_FLAG_MONITOR_VDEV_CREATED, &ar->monitor_flags);\n\t\tar->monitor_vdev_id = -1;\n\t} else if (test_bit(ATH11K_FLAG_MONITOR_VDEV_CREATED, &ar->monitor_flags) &&\n\t\t   !test_bit(ATH11K_FLAG_MONITOR_STARTED, &ar->monitor_flags)) {\n\t\tret = ath11k_mac_monitor_vdev_delete(ar);\n\t\tif (ret)\n\t\t\t \n\t\t\tath11k_warn(ar->ab, \"failed to delete vdev monitor during remove interface: %d\",\n\t\t\t\t    ret);\n\t}\n\nerr_vdev_del:\n\tspin_lock_bh(&ar->data_lock);\n\tlist_del(&arvif->list);\n\tspin_unlock_bh(&ar->data_lock);\n\n\tath11k_peer_cleanup(ar, arvif->vdev_id);\n\n\tidr_for_each(&ar->txmgmt_idr,\n\t\t     ath11k_mac_vif_txmgmt_idr_remove, vif);\n\n\tfor (i = 0; i < ab->hw_params.max_tx_ring; i++) {\n\t\tspin_lock_bh(&ab->dp.tx_ring[i].tx_idr_lock);\n\t\tidr_for_each(&ab->dp.tx_ring[i].txbuf_idr,\n\t\t\t     ath11k_mac_vif_unref, vif);\n\t\tspin_unlock_bh(&ab->dp.tx_ring[i].tx_idr_lock);\n\t}\n\n\t \n\tath11k_mac_txpower_recalc(ar);\n\n\tath11k_debugfs_remove_interface(arvif);\n\n\t \n\n\tmutex_unlock(&ar->conf_mutex);\n}\n\n \n#define SUPPORTED_FILTERS\t\t\t\\\n\t(FIF_ALLMULTI |\t\t\t\t\\\n\tFIF_CONTROL |\t\t\t\t\\\n\tFIF_PSPOLL |\t\t\t\t\\\n\tFIF_OTHER_BSS |\t\t\t\t\\\n\tFIF_BCN_PRBRESP_PROMISC |\t\t\\\n\tFIF_PROBE_REQ |\t\t\t\t\\\n\tFIF_FCSFAIL)\n\nstatic void ath11k_mac_op_configure_filter(struct ieee80211_hw *hw,\n\t\t\t\t\t   unsigned int changed_flags,\n\t\t\t\t\t   unsigned int *total_flags,\n\t\t\t\t\t   u64 multicast)\n{\n\tstruct ath11k *ar = hw->priv;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\t*total_flags &= SUPPORTED_FILTERS;\n\tar->filter_flags = *total_flags;\n\n\tmutex_unlock(&ar->conf_mutex);\n}\n\nstatic int ath11k_mac_op_get_antenna(struct ieee80211_hw *hw, u32 *tx_ant, u32 *rx_ant)\n{\n\tstruct ath11k *ar = hw->priv;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\t*tx_ant = ar->cfg_tx_chainmask;\n\t*rx_ant = ar->cfg_rx_chainmask;\n\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn 0;\n}\n\nstatic int ath11k_mac_op_set_antenna(struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant)\n{\n\tstruct ath11k *ar = hw->priv;\n\tint ret;\n\n\tmutex_lock(&ar->conf_mutex);\n\tret = __ath11k_set_antenna(ar, tx_ant, rx_ant);\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn ret;\n}\n\nstatic int ath11k_mac_op_ampdu_action(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      struct ieee80211_ampdu_params *params)\n{\n\tstruct ath11k *ar = hw->priv;\n\tint ret = -EINVAL;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tswitch (params->action) {\n\tcase IEEE80211_AMPDU_RX_START:\n\t\tret = ath11k_dp_rx_ampdu_start(ar, params);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_RX_STOP:\n\t\tret = ath11k_dp_rx_ampdu_stop(ar, params);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_START:\n\tcase IEEE80211_AMPDU_TX_STOP_CONT:\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH:\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH_CONT:\n\tcase IEEE80211_AMPDU_TX_OPERATIONAL:\n\t\t \n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn ret;\n}\n\nstatic int ath11k_mac_op_add_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_chanctx_conf *ctx)\n{\n\tstruct ath11k *ar = hw->priv;\n\tstruct ath11k_base *ab = ar->ab;\n\n\tath11k_dbg(ab, ATH11K_DBG_MAC,\n\t\t   \"chanctx add freq %u width %d ptr %p\\n\",\n\t\t   ctx->def.chan->center_freq, ctx->def.width, ctx);\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tspin_lock_bh(&ar->data_lock);\n\t \n\tar->rx_channel = ctx->def.chan;\n\tspin_unlock_bh(&ar->data_lock);\n\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn 0;\n}\n\nstatic void ath11k_mac_op_remove_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t\t struct ieee80211_chanctx_conf *ctx)\n{\n\tstruct ath11k *ar = hw->priv;\n\tstruct ath11k_base *ab = ar->ab;\n\n\tath11k_dbg(ab, ATH11K_DBG_MAC,\n\t\t   \"chanctx remove freq %u width %d ptr %p\\n\",\n\t\t   ctx->def.chan->center_freq, ctx->def.width, ctx);\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tspin_lock_bh(&ar->data_lock);\n\t \n\tar->rx_channel = NULL;\n\tspin_unlock_bh(&ar->data_lock);\n\n\tmutex_unlock(&ar->conf_mutex);\n}\n\nstatic int\nath11k_mac_vdev_start_restart(struct ath11k_vif *arvif,\n\t\t\t      struct ieee80211_chanctx_conf *ctx,\n\t\t\t      bool restart)\n{\n\tstruct ath11k *ar = arvif->ar;\n\tstruct ath11k_base *ab = ar->ab;\n\tstruct wmi_vdev_start_req_arg arg = {};\n\tconst struct cfg80211_chan_def *chandef = &ctx->def;\n\tint ret = 0;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\treinit_completion(&ar->vdev_setup_done);\n\n\targ.vdev_id = arvif->vdev_id;\n\targ.dtim_period = arvif->dtim_period;\n\targ.bcn_intval = arvif->beacon_interval;\n\n\targ.channel.freq = chandef->chan->center_freq;\n\targ.channel.band_center_freq1 = chandef->center_freq1;\n\targ.channel.band_center_freq2 = chandef->center_freq2;\n\targ.channel.mode =\n\t\tath11k_phymodes[chandef->chan->band][chandef->width];\n\n\targ.channel.min_power = 0;\n\targ.channel.max_power = chandef->chan->max_power;\n\targ.channel.max_reg_power = chandef->chan->max_reg_power;\n\targ.channel.max_antenna_gain = chandef->chan->max_antenna_gain;\n\n\targ.pref_tx_streams = ar->num_tx_chains;\n\targ.pref_rx_streams = ar->num_rx_chains;\n\n\targ.mbssid_flags = 0;\n\targ.mbssid_tx_vdev_id = 0;\n\tif (test_bit(WMI_TLV_SERVICE_MBSS_PARAM_IN_VDEV_START_SUPPORT,\n\t\t     ar->ab->wmi_ab.svc_map)) {\n\t\tret = ath11k_mac_setup_vdev_params_mbssid(arvif,\n\t\t\t\t\t\t\t  &arg.mbssid_flags,\n\t\t\t\t\t\t\t  &arg.mbssid_tx_vdev_id);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (arvif->vdev_type == WMI_VDEV_TYPE_AP) {\n\t\targ.ssid = arvif->u.ap.ssid;\n\t\targ.ssid_len = arvif->u.ap.ssid_len;\n\t\targ.hidden_ssid = arvif->u.ap.hidden_ssid;\n\n\t\t \n\t\targ.channel.chan_radar =\n\t\t\t!!(chandef->chan->flags & IEEE80211_CHAN_RADAR);\n\n\t\targ.channel.freq2_radar = ctx->radar_enabled;\n\n\t\targ.channel.passive = arg.channel.chan_radar;\n\n\t\tspin_lock_bh(&ab->base_lock);\n\t\targ.regdomain = ar->ab->dfs_region;\n\t\tspin_unlock_bh(&ab->base_lock);\n\t}\n\n\targ.channel.passive |= !!(chandef->chan->flags & IEEE80211_CHAN_NO_IR);\n\n\tath11k_dbg(ab, ATH11K_DBG_MAC,\n\t\t   \"vdev %d start center_freq %d phymode %s\\n\",\n\t\t   arg.vdev_id, arg.channel.freq,\n\t\t   ath11k_wmi_phymode_str(arg.channel.mode));\n\n\tret = ath11k_wmi_vdev_start(ar, &arg, restart);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to %s WMI vdev %i\\n\",\n\t\t\t    restart ? \"restart\" : \"start\", arg.vdev_id);\n\t\treturn ret;\n\t}\n\n\tret = ath11k_mac_vdev_setup_sync(ar);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to synchronize setup for vdev %i %s: %d\\n\",\n\t\t\t    arg.vdev_id, restart ? \"restart\" : \"start\", ret);\n\t\treturn ret;\n\t}\n\n\tif (!restart)\n\t\tar->num_started_vdevs++;\n\n\tath11k_dbg(ab, ATH11K_DBG_MAC,  \"vdev %pM started, vdev_id %d\\n\",\n\t\t   arvif->vif->addr, arvif->vdev_id);\n\n\t \n\t \n\tif (arvif->vdev_type == WMI_VDEV_TYPE_AP &&\n\t    chandef->chan->dfs_cac_ms &&\n\t    chandef->chan->dfs_state == NL80211_DFS_USABLE) {\n\t\tset_bit(ATH11K_CAC_RUNNING, &ar->dev_flags);\n\t\tath11k_dbg(ab, ATH11K_DBG_MAC,\n\t\t\t   \"CAC Started in chan_freq %d for vdev %d\\n\",\n\t\t\t   arg.channel.freq, arg.vdev_id);\n\t}\n\n\tret = ath11k_mac_set_txbf_conf(arvif);\n\tif (ret)\n\t\tath11k_warn(ab, \"failed to set txbf conf for vdev %d: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\n\treturn 0;\n}\n\nstatic int ath11k_mac_vdev_stop(struct ath11k_vif *arvif)\n{\n\tstruct ath11k *ar = arvif->ar;\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\treinit_completion(&ar->vdev_setup_done);\n\n\tret = ath11k_wmi_vdev_stop(ar, arvif->vdev_id);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to stop WMI vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\tgoto err;\n\t}\n\n\tret = ath11k_mac_vdev_setup_sync(ar);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to synchronize setup for vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\tgoto err;\n\t}\n\n\tWARN_ON(ar->num_started_vdevs == 0);\n\n\tar->num_started_vdevs--;\n\tath11k_dbg(ar->ab, ATH11K_DBG_MAC, \"vdev %pM stopped, vdev_id %d\\n\",\n\t\t   arvif->vif->addr, arvif->vdev_id);\n\n\tif (test_bit(ATH11K_CAC_RUNNING, &ar->dev_flags)) {\n\t\tclear_bit(ATH11K_CAC_RUNNING, &ar->dev_flags);\n\t\tath11k_dbg(ar->ab, ATH11K_DBG_MAC, \"CAC Stopped for vdev %d\\n\",\n\t\t\t   arvif->vdev_id);\n\t}\n\n\treturn 0;\nerr:\n\treturn ret;\n}\n\nstatic int ath11k_mac_vdev_start(struct ath11k_vif *arvif,\n\t\t\t\t struct ieee80211_chanctx_conf *ctx)\n{\n\treturn ath11k_mac_vdev_start_restart(arvif, ctx, false);\n}\n\nstatic int ath11k_mac_vdev_restart(struct ath11k_vif *arvif,\n\t\t\t\t   struct ieee80211_chanctx_conf *ctx)\n{\n\treturn ath11k_mac_vdev_start_restart(arvif, ctx, true);\n}\n\nstruct ath11k_mac_change_chanctx_arg {\n\tstruct ieee80211_chanctx_conf *ctx;\n\tstruct ieee80211_vif_chanctx_switch *vifs;\n\tint n_vifs;\n\tint next_vif;\n};\n\nstatic void\nath11k_mac_change_chanctx_cnt_iter(void *data, u8 *mac,\n\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tstruct ath11k_mac_change_chanctx_arg *arg = data;\n\n\tif (rcu_access_pointer(vif->bss_conf.chanctx_conf) != arg->ctx)\n\t\treturn;\n\n\targ->n_vifs++;\n}\n\nstatic void\nath11k_mac_change_chanctx_fill_iter(void *data, u8 *mac,\n\t\t\t\t    struct ieee80211_vif *vif)\n{\n\tstruct ath11k_mac_change_chanctx_arg *arg = data;\n\tstruct ieee80211_chanctx_conf *ctx;\n\n\tctx = rcu_access_pointer(vif->bss_conf.chanctx_conf);\n\tif (ctx != arg->ctx)\n\t\treturn;\n\n\tif (WARN_ON(arg->next_vif == arg->n_vifs))\n\t\treturn;\n\n\targ->vifs[arg->next_vif].vif = vif;\n\targ->vifs[arg->next_vif].old_ctx = ctx;\n\targ->vifs[arg->next_vif].new_ctx = ctx;\n\targ->next_vif++;\n}\n\nstatic void\nath11k_mac_update_vif_chan(struct ath11k *ar,\n\t\t\t   struct ieee80211_vif_chanctx_switch *vifs,\n\t\t\t   int n_vifs)\n{\n\tstruct ath11k_base *ab = ar->ab;\n\tstruct ath11k_vif *arvif, *tx_arvif = NULL;\n\tstruct ieee80211_vif *mbssid_tx_vif;\n\tint ret;\n\tint i;\n\tbool monitor_vif = false;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\t \n\n\t \n\n\tfor (i = 0; i < n_vifs; i++) {\n\t\tarvif = ath11k_vif_to_arvif(vifs[i].vif);\n\n\t\tif (WARN_ON(!arvif->is_started))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (arvif->is_up) {\n\t\t\tret = ath11k_mac_vdev_restart(arvif, vifs[i].new_ctx);\n\t\t\tif (ret) {\n\t\t\t\tath11k_warn(ab, \"failed to restart vdev %d: %d\\n\",\n\t\t\t\t\t    arvif->vdev_id, ret);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tret = ath11k_mac_vdev_stop(arvif);\n\t\t\tif (ret) {\n\t\t\t\tath11k_warn(ab, \"failed to stop vdev %d: %d\\n\",\n\t\t\t\t\t    arvif->vdev_id, ret);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = ath11k_mac_vdev_start(arvif, vifs[i].new_ctx);\n\t\t\tif (ret)\n\t\t\t\tath11k_warn(ab, \"failed to start vdev %d: %d\\n\",\n\t\t\t\t\t    arvif->vdev_id, ret);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = ath11k_mac_setup_bcn_tmpl(arvif);\n\t\tif (ret)\n\t\t\tath11k_warn(ab, \"failed to update bcn tmpl during csa: %d\\n\",\n\t\t\t\t    ret);\n\n\t\tmbssid_tx_vif = arvif->vif->mbssid_tx_vif;\n\t\tif (mbssid_tx_vif)\n\t\t\ttx_arvif = ath11k_vif_to_arvif(mbssid_tx_vif);\n\n\t\tret = ath11k_wmi_vdev_up(arvif->ar, arvif->vdev_id, arvif->aid,\n\t\t\t\t\t arvif->bssid,\n\t\t\t\t\t tx_arvif ? tx_arvif->bssid : NULL,\n\t\t\t\t\t arvif->vif->bss_conf.bssid_index,\n\t\t\t\t\t 1 << arvif->vif->bss_conf.bssid_indicator);\n\t\tif (ret) {\n\t\t\tath11k_warn(ab, \"failed to bring vdev up %d: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\t \n\tif (!monitor_vif &&\n\t    test_bit(ATH11K_FLAG_MONITOR_VDEV_CREATED, &ar->monitor_flags)) {\n\t\tret = ath11k_mac_monitor_stop(ar);\n\t\tif (ret) {\n\t\t\tath11k_warn(ar->ab, \"failed to stop monitor during vif channel update: %d\",\n\t\t\t\t    ret);\n\t\t\treturn;\n\t\t}\n\n\t\tret = ath11k_mac_monitor_start(ar);\n\t\tif (ret) {\n\t\t\tath11k_warn(ar->ab, \"failed to start monitor during vif channel update: %d\",\n\t\t\t\t    ret);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void\nath11k_mac_update_active_vif_chan(struct ath11k *ar,\n\t\t\t\t  struct ieee80211_chanctx_conf *ctx)\n{\n\tstruct ath11k_mac_change_chanctx_arg arg = { .ctx = ctx };\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tieee80211_iterate_active_interfaces_atomic(ar->hw,\n\t\t\t\t\t\t   IEEE80211_IFACE_ITER_NORMAL,\n\t\t\t\t\t\t   ath11k_mac_change_chanctx_cnt_iter,\n\t\t\t\t\t\t   &arg);\n\tif (arg.n_vifs == 0)\n\t\treturn;\n\n\targ.vifs = kcalloc(arg.n_vifs, sizeof(arg.vifs[0]), GFP_KERNEL);\n\tif (!arg.vifs)\n\t\treturn;\n\n\tieee80211_iterate_active_interfaces_atomic(ar->hw,\n\t\t\t\t\t\t   IEEE80211_IFACE_ITER_NORMAL,\n\t\t\t\t\t\t   ath11k_mac_change_chanctx_fill_iter,\n\t\t\t\t\t\t   &arg);\n\n\tath11k_mac_update_vif_chan(ar, arg.vifs, arg.n_vifs);\n\n\tkfree(arg.vifs);\n}\n\nstatic void ath11k_mac_op_change_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t\t struct ieee80211_chanctx_conf *ctx,\n\t\t\t\t\t u32 changed)\n{\n\tstruct ath11k *ar = hw->priv;\n\tstruct ath11k_base *ab = ar->ab;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tath11k_dbg(ab, ATH11K_DBG_MAC,\n\t\t   \"chanctx change freq %u width %d ptr %p changed %x\\n\",\n\t\t   ctx->def.chan->center_freq, ctx->def.width, ctx, changed);\n\n\t \n\tif (WARN_ON(changed & IEEE80211_CHANCTX_CHANGE_CHANNEL))\n\t\tgoto unlock;\n\n\tif (changed & IEEE80211_CHANCTX_CHANGE_WIDTH ||\n\t    changed & IEEE80211_CHANCTX_CHANGE_RADAR)\n\t\tath11k_mac_update_active_vif_chan(ar, ctx);\n\n\t \n\nunlock:\n\tmutex_unlock(&ar->conf_mutex);\n}\n\nstatic int ath11k_start_vdev_delay(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tstruct ath11k *ar = hw->priv;\n\tstruct ath11k_base *ab = ar->ab;\n\tstruct ath11k_vif *arvif = ath11k_vif_to_arvif(vif);\n\tint ret;\n\n\tif (WARN_ON(arvif->is_started))\n\t\treturn -EBUSY;\n\n\tret = ath11k_mac_vdev_start(arvif, &arvif->chanctx);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to start vdev %i addr %pM on freq %d: %d\\n\",\n\t\t\t    arvif->vdev_id, vif->addr,\n\t\t\t    arvif->chanctx.def.chan->center_freq, ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (ar->hw_rate_code > 0) {\n\t\tu32 vdev_param = WMI_VDEV_PARAM_MGMT_RATE;\n\n\t\tret = ath11k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id, vdev_param,\n\t\t\t\t\t\t    ar->hw_rate_code);\n\t\tif (ret) {\n\t\t\tath11k_warn(ar->ab, \"failed to set mgmt tx rate %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (arvif->vdev_type == WMI_VDEV_TYPE_MONITOR) {\n\t\tret = ath11k_wmi_vdev_up(ar, arvif->vdev_id, 0, ar->mac_addr,\n\t\t\t\t\t NULL, 0, 0);\n\t\tif (ret) {\n\t\t\tath11k_warn(ab, \"failed put monitor up: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tarvif->is_started = true;\n\n\t \n\treturn 0;\n}\n\nstatic int\nath11k_mac_op_assign_vif_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_bss_conf *link_conf,\n\t\t\t\t struct ieee80211_chanctx_conf *ctx)\n{\n\tstruct ath11k *ar = hw->priv;\n\tstruct ath11k_base *ab = ar->ab;\n\tstruct ath11k_vif *arvif = ath11k_vif_to_arvif(vif);\n\tint ret;\n\tstruct peer_create_params param;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tath11k_dbg(ab, ATH11K_DBG_MAC,\n\t\t   \"chanctx assign ptr %p vdev_id %i\\n\",\n\t\t   ctx, arvif->vdev_id);\n\n\t \n\tif (ab->hw_params.vdev_start_delay &&\n\t    arvif->vdev_type != WMI_VDEV_TYPE_AP &&\n\t    arvif->vdev_type != WMI_VDEV_TYPE_MONITOR &&\n\t    !ath11k_peer_find_by_vdev_id(ab, arvif->vdev_id)) {\n\t\tmemcpy(&arvif->chanctx, ctx, sizeof(*ctx));\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON(arvif->is_started)) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (ab->hw_params.vdev_start_delay &&\n\t    arvif->vdev_type != WMI_VDEV_TYPE_AP &&\n\t    arvif->vdev_type != WMI_VDEV_TYPE_MONITOR) {\n\t\tparam.vdev_id = arvif->vdev_id;\n\t\tparam.peer_type = WMI_PEER_TYPE_DEFAULT;\n\t\tparam.peer_addr = ar->mac_addr;\n\n\t\tret = ath11k_peer_create(ar, arvif, NULL, &param);\n\t\tif (ret) {\n\t\t\tath11k_warn(ab, \"failed to create peer after vdev start delay: %d\",\n\t\t\t\t    ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (arvif->vdev_type == WMI_VDEV_TYPE_MONITOR) {\n\t\tret = ath11k_mac_monitor_start(ar);\n\t\tif (ret) {\n\t\t\tath11k_warn(ar->ab, \"failed to start monitor during vif channel context assignment: %d\",\n\t\t\t\t    ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tarvif->is_started = true;\n\t\tgoto out;\n\t}\n\n\tret = ath11k_mac_vdev_start(arvif, ctx);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to start vdev %i addr %pM on freq %d: %d\\n\",\n\t\t\t    arvif->vdev_id, vif->addr,\n\t\t\t    ctx->def.chan->center_freq, ret);\n\t\tgoto out;\n\t}\n\n\tarvif->is_started = true;\n\n\tif (arvif->vdev_type != WMI_VDEV_TYPE_MONITOR &&\n\t    test_bit(ATH11K_FLAG_MONITOR_VDEV_CREATED, &ar->monitor_flags)) {\n\t\tret = ath11k_mac_monitor_start(ar);\n\t\tif (ret) {\n\t\t\tath11k_warn(ar->ab, \"failed to start monitor during vif channel context assignment: %d\",\n\t\t\t\t    ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\n\tret = 0;\n\nout:\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn ret;\n}\n\nstatic void\nath11k_mac_op_unassign_vif_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   struct ieee80211_bss_conf *link_conf,\n\t\t\t\t   struct ieee80211_chanctx_conf *ctx)\n{\n\tstruct ath11k *ar = hw->priv;\n\tstruct ath11k_base *ab = ar->ab;\n\tstruct ath11k_vif *arvif = ath11k_vif_to_arvif(vif);\n\tstruct ath11k_peer *peer;\n\tint ret;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tath11k_dbg(ab, ATH11K_DBG_MAC,\n\t\t   \"chanctx unassign ptr %p vdev_id %i\\n\",\n\t\t   ctx, arvif->vdev_id);\n\n\tWARN_ON(!arvif->is_started);\n\n\tif (ab->hw_params.vdev_start_delay &&\n\t    arvif->vdev_type == WMI_VDEV_TYPE_MONITOR) {\n\t\tspin_lock_bh(&ab->base_lock);\n\t\tpeer = ath11k_peer_find_by_addr(ab, ar->mac_addr);\n\t\tspin_unlock_bh(&ab->base_lock);\n\t\tif (peer)\n\t\t\tath11k_peer_delete(ar, arvif->vdev_id, ar->mac_addr);\n\t}\n\n\tif (arvif->vdev_type == WMI_VDEV_TYPE_MONITOR) {\n\t\tret = ath11k_mac_monitor_stop(ar);\n\t\tif (ret) {\n\t\t\tath11k_warn(ar->ab, \"failed to stop monitor during vif channel context unassignment: %d\",\n\t\t\t\t    ret);\n\t\t\tmutex_unlock(&ar->conf_mutex);\n\t\t\treturn;\n\t\t}\n\n\t\tarvif->is_started = false;\n\t\tmutex_unlock(&ar->conf_mutex);\n\t\treturn;\n\t}\n\n\tret = ath11k_mac_vdev_stop(arvif);\n\tif (ret)\n\t\tath11k_warn(ab, \"failed to stop vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\n\tarvif->is_started = false;\n\n\tif (ab->hw_params.vdev_start_delay &&\n\t    arvif->vdev_type == WMI_VDEV_TYPE_STA) {\n\t\tret = ath11k_peer_delete(ar, arvif->vdev_id, arvif->bssid);\n\t\tif (ret)\n\t\t\tath11k_warn(ar->ab,\n\t\t\t\t    \"failed to delete peer %pM for vdev %d: %d\\n\",\n\t\t\t\t    arvif->bssid, arvif->vdev_id, ret);\n\t\telse\n\t\t\tath11k_dbg(ar->ab, ATH11K_DBG_MAC,\n\t\t\t\t   \"removed peer %pM  vdev %d after vdev stop\\n\",\n\t\t\t\t   arvif->bssid, arvif->vdev_id);\n\t}\n\n\tif (ab->hw_params.vdev_start_delay &&\n\t    arvif->vdev_type == WMI_VDEV_TYPE_MONITOR)\n\t\tath11k_wmi_vdev_down(ar, arvif->vdev_id);\n\n\tif (arvif->vdev_type != WMI_VDEV_TYPE_MONITOR &&\n\t    ar->num_started_vdevs == 1 &&\n\t    test_bit(ATH11K_FLAG_MONITOR_VDEV_CREATED, &ar->monitor_flags)) {\n\t\tret = ath11k_mac_monitor_stop(ar);\n\t\tif (ret)\n\t\t\t \n\t\t\tath11k_warn(ar->ab, \"failed to stop monitor during vif channel context unassignment: %d\",\n\t\t\t\t    ret);\n\t}\n\n\tif (arvif->vdev_type == WMI_VDEV_TYPE_STA)\n\t\tath11k_mac_11d_scan_start(ar, arvif->vdev_id);\n\n\tmutex_unlock(&ar->conf_mutex);\n}\n\nstatic int\nath11k_mac_op_switch_vif_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif_chanctx_switch *vifs,\n\t\t\t\t int n_vifs,\n\t\t\t\t enum ieee80211_chanctx_switch_mode mode)\n{\n\tstruct ath11k *ar = hw->priv;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_MAC,\n\t\t   \"chanctx switch n_vifs %d mode %d\\n\",\n\t\t   n_vifs, mode);\n\tath11k_mac_update_vif_chan(ar, vifs, n_vifs);\n\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn 0;\n}\n\nstatic int\nath11k_set_vdev_param_to_all_vifs(struct ath11k *ar, int param, u32 value)\n{\n\tstruct ath11k_vif *arvif;\n\tint ret = 0;\n\n\tmutex_lock(&ar->conf_mutex);\n\tlist_for_each_entry(arvif, &ar->arvifs, list) {\n\t\tath11k_dbg(ar->ab, ATH11K_DBG_MAC, \"setting mac vdev %d param %d value %d\\n\",\n\t\t\t   param, arvif->vdev_id, value);\n\n\t\tret = ath11k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id,\n\t\t\t\t\t\t    param, value);\n\t\tif (ret) {\n\t\t\tath11k_warn(ar->ab, \"failed to set param %d for vdev %d: %d\\n\",\n\t\t\t\t    param, arvif->vdev_id, ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\n \nstatic int ath11k_mac_op_set_rts_threshold(struct ieee80211_hw *hw, u32 value)\n{\n\tstruct ath11k *ar = hw->priv;\n\tint param_id = WMI_VDEV_PARAM_RTS_THRESHOLD;\n\n\treturn ath11k_set_vdev_param_to_all_vifs(ar, param_id, value);\n}\n\nstatic int ath11k_mac_op_set_frag_threshold(struct ieee80211_hw *hw, u32 value)\n{\n\t \n\treturn -EOPNOTSUPP;\n}\n\nstatic int ath11k_mac_flush_tx_complete(struct ath11k *ar)\n{\n\tlong time_left;\n\tint ret = 0;\n\n\ttime_left = wait_event_timeout(ar->dp.tx_empty_waitq,\n\t\t\t\t       (atomic_read(&ar->dp.num_tx_pending) == 0),\n\t\t\t\t       ATH11K_FLUSH_TIMEOUT);\n\tif (time_left == 0) {\n\t\tath11k_warn(ar->ab, \"failed to flush transmit queue, data pkts pending %d\\n\",\n\t\t\t    atomic_read(&ar->dp.num_tx_pending));\n\t\tret = -ETIMEDOUT;\n\t}\n\n\ttime_left = wait_event_timeout(ar->txmgmt_empty_waitq,\n\t\t\t\t       (atomic_read(&ar->num_pending_mgmt_tx) == 0),\n\t\t\t\t       ATH11K_FLUSH_TIMEOUT);\n\tif (time_left == 0) {\n\t\tath11k_warn(ar->ab, \"failed to flush mgmt transmit queue, mgmt pkts pending %d\\n\",\n\t\t\t    atomic_read(&ar->num_pending_mgmt_tx));\n\t\tret = -ETIMEDOUT;\n\t}\n\n\treturn ret;\n}\n\nint ath11k_mac_wait_tx_complete(struct ath11k *ar)\n{\n\tath11k_mac_drain_tx(ar);\n\treturn ath11k_mac_flush_tx_complete(ar);\n}\n\nstatic void ath11k_mac_op_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t\tu32 queues, bool drop)\n{\n\tstruct ath11k *ar = hw->priv;\n\n\tif (drop)\n\t\treturn;\n\n\tath11k_mac_flush_tx_complete(ar);\n}\n\nstatic bool\nath11k_mac_has_single_legacy_rate(struct ath11k *ar,\n\t\t\t\t  enum nl80211_band band,\n\t\t\t\t  const struct cfg80211_bitrate_mask *mask)\n{\n\tint num_rates = 0;\n\n\tnum_rates = hweight32(mask->control[band].legacy);\n\n\tif (ath11k_mac_bitrate_mask_num_ht_rates(ar, band, mask))\n\t\treturn false;\n\n\tif (ath11k_mac_bitrate_mask_num_vht_rates(ar, band, mask))\n\t\treturn false;\n\n\tif (ath11k_mac_bitrate_mask_num_he_rates(ar, band, mask))\n\t\treturn false;\n\n\treturn num_rates == 1;\n}\n\nstatic __le16\nath11k_mac_get_tx_mcs_map(const struct ieee80211_sta_he_cap *he_cap)\n{\n\tif (he_cap->he_cap_elem.phy_cap_info[0] &\n\t    IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G)\n\t\treturn he_cap->he_mcs_nss_supp.tx_mcs_80p80;\n\n\tif (he_cap->he_cap_elem.phy_cap_info[0] &\n\t    IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G)\n\t\treturn he_cap->he_mcs_nss_supp.tx_mcs_160;\n\n\treturn he_cap->he_mcs_nss_supp.tx_mcs_80;\n}\n\nstatic bool\nath11k_mac_bitrate_mask_get_single_nss(struct ath11k *ar,\n\t\t\t\t       enum nl80211_band band,\n\t\t\t\t       const struct cfg80211_bitrate_mask *mask,\n\t\t\t\t       int *nss)\n{\n\tstruct ieee80211_supported_band *sband = &ar->mac.sbands[band];\n\tu16 vht_mcs_map = le16_to_cpu(sband->vht_cap.vht_mcs.tx_mcs_map);\n\tu16 he_mcs_map = 0;\n\tu8 ht_nss_mask = 0;\n\tu8 vht_nss_mask = 0;\n\tu8 he_nss_mask = 0;\n\tint i;\n\n\t \n\n\tfor (i = 0; i < ARRAY_SIZE(mask->control[band].ht_mcs); i++) {\n\t\tif (mask->control[band].ht_mcs[i] == 0)\n\t\t\tcontinue;\n\t\telse if (mask->control[band].ht_mcs[i] ==\n\t\t\t sband->ht_cap.mcs.rx_mask[i])\n\t\t\tht_nss_mask |= BIT(i);\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(mask->control[band].vht_mcs); i++) {\n\t\tif (mask->control[band].vht_mcs[i] == 0)\n\t\t\tcontinue;\n\t\telse if (mask->control[band].vht_mcs[i] ==\n\t\t\t ath11k_mac_get_max_vht_mcs_map(vht_mcs_map, i))\n\t\t\tvht_nss_mask |= BIT(i);\n\t\telse\n\t\t\treturn false;\n\t}\n\n\the_mcs_map = le16_to_cpu(ath11k_mac_get_tx_mcs_map(&sband->iftype_data->he_cap));\n\n\tfor (i = 0; i < ARRAY_SIZE(mask->control[band].he_mcs); i++) {\n\t\tif (mask->control[band].he_mcs[i] == 0)\n\t\t\tcontinue;\n\n\t\tif (mask->control[band].he_mcs[i] ==\n\t\t    ath11k_mac_get_max_he_mcs_map(he_mcs_map, i))\n\t\t\the_nss_mask |= BIT(i);\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tif (ht_nss_mask != vht_nss_mask || ht_nss_mask != he_nss_mask)\n\t\treturn false;\n\n\tif (ht_nss_mask == 0)\n\t\treturn false;\n\n\tif (BIT(fls(ht_nss_mask)) - 1 != ht_nss_mask)\n\t\treturn false;\n\n\t*nss = fls(ht_nss_mask);\n\n\treturn true;\n}\n\nstatic int\nath11k_mac_get_single_legacy_rate(struct ath11k *ar,\n\t\t\t\t  enum nl80211_band band,\n\t\t\t\t  const struct cfg80211_bitrate_mask *mask,\n\t\t\t\t  u32 *rate, u8 *nss)\n{\n\tint rate_idx;\n\tu16 bitrate;\n\tu8 preamble;\n\tu8 hw_rate;\n\n\tif (hweight32(mask->control[band].legacy) != 1)\n\t\treturn -EINVAL;\n\n\trate_idx = ffs(mask->control[band].legacy) - 1;\n\n\tif (band == NL80211_BAND_5GHZ || band == NL80211_BAND_6GHZ)\n\t\trate_idx += ATH11K_MAC_FIRST_OFDM_RATE_IDX;\n\n\thw_rate = ath11k_legacy_rates[rate_idx].hw_value;\n\tbitrate = ath11k_legacy_rates[rate_idx].bitrate;\n\n\tif (ath11k_mac_bitrate_is_cck(bitrate))\n\t\tpreamble = WMI_RATE_PREAMBLE_CCK;\n\telse\n\t\tpreamble = WMI_RATE_PREAMBLE_OFDM;\n\n\t*nss = 1;\n\t*rate = ATH11K_HW_RATE_CODE(hw_rate, 0, preamble);\n\n\treturn 0;\n}\n\nstatic int\nath11k_mac_set_fixed_rate_gi_ltf(struct ath11k_vif *arvif, u8 he_gi, u8 he_ltf)\n{\n\tstruct ath11k *ar = arvif->ar;\n\tint ret;\n\n\t \n\tif (he_gi && he_gi != 0xFF)\n\t\the_gi += 1;\n\n\tret = ath11k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id,\n\t\t\t\t\t    WMI_VDEV_PARAM_SGI, he_gi);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to set he gi %d: %d\\n\",\n\t\t\t    he_gi, ret);\n\t\treturn ret;\n\t}\n\t \n\tif (he_ltf != 0xFF)\n\t\the_ltf += 1;\n\n\tret = ath11k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id,\n\t\t\t\t\t    WMI_VDEV_PARAM_HE_LTF, he_ltf);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to set he ltf %d: %d\\n\",\n\t\t\t    he_ltf, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nath11k_mac_set_auto_rate_gi_ltf(struct ath11k_vif *arvif, u16 he_gi, u8 he_ltf)\n{\n\tstruct ath11k *ar = arvif->ar;\n\tint ret;\n\tu32 he_ar_gi_ltf;\n\n\tif (he_gi != 0xFF) {\n\t\tswitch (he_gi) {\n\t\tcase NL80211_RATE_INFO_HE_GI_0_8:\n\t\t\the_gi = WMI_AUTORATE_800NS_GI;\n\t\t\tbreak;\n\t\tcase NL80211_RATE_INFO_HE_GI_1_6:\n\t\t\the_gi = WMI_AUTORATE_1600NS_GI;\n\t\t\tbreak;\n\t\tcase NL80211_RATE_INFO_HE_GI_3_2:\n\t\t\the_gi = WMI_AUTORATE_3200NS_GI;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tath11k_warn(ar->ab, \"invalid he gi: %d\\n\", he_gi);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (he_ltf != 0xFF) {\n\t\tswitch (he_ltf) {\n\t\tcase NL80211_RATE_INFO_HE_1XLTF:\n\t\t\the_ltf = WMI_HE_AUTORATE_LTF_1X;\n\t\t\tbreak;\n\t\tcase NL80211_RATE_INFO_HE_2XLTF:\n\t\t\the_ltf = WMI_HE_AUTORATE_LTF_2X;\n\t\t\tbreak;\n\t\tcase NL80211_RATE_INFO_HE_4XLTF:\n\t\t\the_ltf = WMI_HE_AUTORATE_LTF_4X;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tath11k_warn(ar->ab, \"invalid he ltf: %d\\n\", he_ltf);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\the_ar_gi_ltf = he_gi | he_ltf;\n\tret = ath11k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id,\n\t\t\t\t\t    WMI_VDEV_PARAM_AUTORATE_MISC_CFG,\n\t\t\t\t\t    he_ar_gi_ltf);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to set he autorate gi %u ltf %u: %d\\n\",\n\t\t\t    he_gi, he_ltf, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath11k_mac_set_rate_params(struct ath11k_vif *arvif,\n\t\t\t\t      u32 rate, u8 nss, u8 sgi, u8 ldpc,\n\t\t\t\t      u8 he_gi, u8 he_ltf, bool he_fixed_rate)\n{\n\tstruct ath11k *ar = arvif->ar;\n\tu32 vdev_param;\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_MAC,\n\t\t   \"set rate params vdev %i rate 0x%02x nss 0x%02x sgi 0x%02x ldpc 0x%02x he_gi 0x%02x he_ltf 0x%02x he_fixed_rate %d\\n\",\n\t\t   arvif->vdev_id, rate, nss, sgi, ldpc, he_gi,\n\t\t   he_ltf, he_fixed_rate);\n\n\tif (!arvif->vif->bss_conf.he_support) {\n\t\tvdev_param = WMI_VDEV_PARAM_FIXED_RATE;\n\t\tret = ath11k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id,\n\t\t\t\t\t\t    vdev_param, rate);\n\t\tif (ret) {\n\t\t\tath11k_warn(ar->ab, \"failed to set fixed rate param 0x%02x: %d\\n\",\n\t\t\t\t    rate, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tvdev_param = WMI_VDEV_PARAM_NSS;\n\tret = ath11k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id,\n\t\t\t\t\t    vdev_param, nss);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to set nss param %d: %d\\n\",\n\t\t\t    nss, ret);\n\t\treturn ret;\n\t}\n\n\tvdev_param = WMI_VDEV_PARAM_LDPC;\n\tret = ath11k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id,\n\t\t\t\t\t    vdev_param, ldpc);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to set ldpc param %d: %d\\n\",\n\t\t\t    ldpc, ret);\n\t\treturn ret;\n\t}\n\n\tif (arvif->vif->bss_conf.he_support) {\n\t\tif (he_fixed_rate) {\n\t\t\tret = ath11k_mac_set_fixed_rate_gi_ltf(arvif, he_gi,\n\t\t\t\t\t\t\t       he_ltf);\n\t\t\tif (ret) {\n\t\t\t\tath11k_warn(ar->ab, \"failed to set fixed rate gi ltf: %d\\n\",\n\t\t\t\t\t    ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else {\n\t\t\tret = ath11k_mac_set_auto_rate_gi_ltf(arvif, he_gi,\n\t\t\t\t\t\t\t      he_ltf);\n\t\t\tif (ret) {\n\t\t\t\tath11k_warn(ar->ab, \"failed to set auto rate gi ltf: %d\\n\",\n\t\t\t\t\t    ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tvdev_param = WMI_VDEV_PARAM_SGI;\n\t\tret = ath11k_wmi_vdev_set_param_cmd(ar, arvif->vdev_id,\n\t\t\t\t\t\t    vdev_param, sgi);\n\t\tif (ret) {\n\t\t\tath11k_warn(ar->ab, \"failed to set sgi param %d: %d\\n\",\n\t\t\t\t    sgi, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic bool\nath11k_mac_vht_mcs_range_present(struct ath11k *ar,\n\t\t\t\t enum nl80211_band band,\n\t\t\t\t const struct cfg80211_bitrate_mask *mask)\n{\n\tint i;\n\tu16 vht_mcs;\n\n\tfor (i = 0; i < NL80211_VHT_NSS_MAX; i++) {\n\t\tvht_mcs = mask->control[band].vht_mcs[i];\n\n\t\tswitch (vht_mcs) {\n\t\tcase 0:\n\t\tcase BIT(8) - 1:\n\t\tcase BIT(9) - 1:\n\t\tcase BIT(10) - 1:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic bool\nath11k_mac_he_mcs_range_present(struct ath11k *ar,\n\t\t\t\tenum nl80211_band band,\n\t\t\t\tconst struct cfg80211_bitrate_mask *mask)\n{\n\tint i;\n\tu16 he_mcs;\n\n\tfor (i = 0; i < NL80211_HE_NSS_MAX; i++) {\n\t\the_mcs = mask->control[band].he_mcs[i];\n\n\t\tswitch (he_mcs) {\n\t\tcase 0:\n\t\tcase BIT(8) - 1:\n\t\tcase BIT(10) - 1:\n\t\tcase BIT(12) - 1:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic void ath11k_mac_set_bitrate_mask_iter(void *data,\n\t\t\t\t\t     struct ieee80211_sta *sta)\n{\n\tstruct ath11k_vif *arvif = data;\n\tstruct ath11k_sta *arsta = (struct ath11k_sta *)sta->drv_priv;\n\tstruct ath11k *ar = arvif->ar;\n\n\tspin_lock_bh(&ar->data_lock);\n\tarsta->changed |= IEEE80211_RC_SUPP_RATES_CHANGED;\n\tspin_unlock_bh(&ar->data_lock);\n\n\tieee80211_queue_work(ar->hw, &arsta->update_wk);\n}\n\nstatic void ath11k_mac_disable_peer_fixed_rate(void *data,\n\t\t\t\t\t       struct ieee80211_sta *sta)\n{\n\tstruct ath11k_vif *arvif = data;\n\tstruct ath11k *ar = arvif->ar;\n\tint ret;\n\n\tret = ath11k_wmi_set_peer_param(ar, sta->addr,\n\t\t\t\t\tarvif->vdev_id,\n\t\t\t\t\tWMI_PEER_PARAM_FIXED_RATE,\n\t\t\t\t\tWMI_FIXED_RATE_NONE);\n\tif (ret)\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to disable peer fixed rate for STA %pM ret %d\\n\",\n\t\t\t    sta->addr, ret);\n}\n\nstatic bool\nath11k_mac_validate_vht_he_fixed_rate_settings(struct ath11k *ar, enum nl80211_band band,\n\t\t\t\t\t       const struct cfg80211_bitrate_mask *mask)\n{\n\tbool he_fixed_rate = false, vht_fixed_rate = false;\n\tstruct ath11k_peer *peer;\n\tconst u16 *vht_mcs_mask, *he_mcs_mask;\n\tstruct ieee80211_link_sta *deflink;\n\tu8 vht_nss, he_nss;\n\tbool ret = true;\n\n\tvht_mcs_mask = mask->control[band].vht_mcs;\n\the_mcs_mask = mask->control[band].he_mcs;\n\n\tif (ath11k_mac_bitrate_mask_num_vht_rates(ar, band, mask) == 1)\n\t\tvht_fixed_rate = true;\n\n\tif (ath11k_mac_bitrate_mask_num_he_rates(ar, band, mask) == 1)\n\t\the_fixed_rate = true;\n\n\tif (!vht_fixed_rate && !he_fixed_rate)\n\t\treturn true;\n\n\tvht_nss = ath11k_mac_max_vht_nss(vht_mcs_mask);\n\the_nss =  ath11k_mac_max_he_nss(he_mcs_mask);\n\n\trcu_read_lock();\n\tspin_lock_bh(&ar->ab->base_lock);\n\tlist_for_each_entry(peer, &ar->ab->peers, list) {\n\t\tif (peer->sta) {\n\t\t\tdeflink = &peer->sta->deflink;\n\n\t\t\tif (vht_fixed_rate && (!deflink->vht_cap.vht_supported ||\n\t\t\t\t\t       deflink->rx_nss < vht_nss)) {\n\t\t\t\tret = false;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (he_fixed_rate && (!deflink->he_cap.has_he ||\n\t\t\t\t\t      deflink->rx_nss < he_nss)) {\n\t\t\t\tret = false;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\nout:\n\tspin_unlock_bh(&ar->ab->base_lock);\n\trcu_read_unlock();\n\treturn ret;\n}\n\nstatic int\nath11k_mac_op_set_bitrate_mask(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       const struct cfg80211_bitrate_mask *mask)\n{\n\tstruct ath11k_vif *arvif = ath11k_vif_to_arvif(vif);\n\tstruct cfg80211_chan_def def;\n\tstruct ath11k_pdev_cap *cap;\n\tstruct ath11k *ar = arvif->ar;\n\tenum nl80211_band band;\n\tconst u8 *ht_mcs_mask;\n\tconst u16 *vht_mcs_mask;\n\tconst u16 *he_mcs_mask;\n\tu8 he_ltf = 0;\n\tu8 he_gi = 0;\n\tu32 rate;\n\tu8 nss;\n\tu8 sgi;\n\tu8 ldpc;\n\tint single_nss;\n\tint ret;\n\tint num_rates;\n\tbool he_fixed_rate = false;\n\n\tif (ath11k_mac_vif_chan(vif, &def))\n\t\treturn -EPERM;\n\n\tband = def.chan->band;\n\tcap = &ar->pdev->cap;\n\tht_mcs_mask = mask->control[band].ht_mcs;\n\tvht_mcs_mask = mask->control[band].vht_mcs;\n\the_mcs_mask = mask->control[band].he_mcs;\n\tldpc = !!(cap->band[band].ht_cap_info & WMI_HT_CAP_TX_LDPC);\n\n\tsgi = mask->control[band].gi;\n\tif (sgi == NL80211_TXRATE_FORCE_LGI)\n\t\treturn -EINVAL;\n\n\the_gi = mask->control[band].he_gi;\n\the_ltf = mask->control[band].he_ltf;\n\n\t \n\tif (ath11k_mac_has_single_legacy_rate(ar, band, mask)) {\n\t\tret = ath11k_mac_get_single_legacy_rate(ar, band, mask, &rate,\n\t\t\t\t\t\t\t&nss);\n\t\tif (ret) {\n\t\t\tath11k_warn(ar->ab, \"failed to get single legacy rate for vdev %i: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\treturn ret;\n\t\t}\n\t\tieee80211_iterate_stations_atomic(ar->hw,\n\t\t\t\t\t\t  ath11k_mac_disable_peer_fixed_rate,\n\t\t\t\t\t\t  arvif);\n\t} else if (ath11k_mac_bitrate_mask_get_single_nss(ar, band, mask,\n\t\t\t\t\t\t\t  &single_nss)) {\n\t\trate = WMI_FIXED_RATE_NONE;\n\t\tnss = single_nss;\n\t\tmutex_lock(&ar->conf_mutex);\n\t\tarvif->bitrate_mask = *mask;\n\t\tieee80211_iterate_stations_atomic(ar->hw,\n\t\t\t\t\t\t  ath11k_mac_set_bitrate_mask_iter,\n\t\t\t\t\t\t  arvif);\n\t\tmutex_unlock(&ar->conf_mutex);\n\t} else {\n\t\trate = WMI_FIXED_RATE_NONE;\n\n\t\tif (!ath11k_mac_validate_vht_he_fixed_rate_settings(ar, band, mask))\n\t\t\tath11k_warn(ar->ab,\n\t\t\t\t    \"could not update fixed rate settings to all peers due to mcs/nss incompatibility\\n\");\n\t\tnss = min_t(u32, ar->num_tx_chains,\n\t\t\t    max(max(ath11k_mac_max_ht_nss(ht_mcs_mask),\n\t\t\t\t    ath11k_mac_max_vht_nss(vht_mcs_mask)),\n\t\t\t\tath11k_mac_max_he_nss(he_mcs_mask)));\n\n\t\t \n\n\t\tnum_rates = ath11k_mac_bitrate_mask_num_vht_rates(ar, band,\n\t\t\t\t\t\t\t\t  mask);\n\n\t\tif (!ath11k_mac_vht_mcs_range_present(ar, band, mask) &&\n\t\t    num_rates > 1) {\n\t\t\t \n\t\t\tath11k_warn(ar->ab,\n\t\t\t\t    \"setting %d mcs values in bitrate mask not supported\\n\",\n\t\t\t\tnum_rates);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tnum_rates = ath11k_mac_bitrate_mask_num_he_rates(ar, band,\n\t\t\t\t\t\t\t\t mask);\n\t\tif (num_rates == 1)\n\t\t\the_fixed_rate = true;\n\n\t\tif (!ath11k_mac_he_mcs_range_present(ar, band, mask) &&\n\t\t    num_rates > 1) {\n\t\t\tath11k_warn(ar->ab,\n\t\t\t\t    \"Setting more than one HE MCS Value in bitrate mask not supported\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmutex_lock(&ar->conf_mutex);\n\t\tieee80211_iterate_stations_atomic(ar->hw,\n\t\t\t\t\t\t  ath11k_mac_disable_peer_fixed_rate,\n\t\t\t\t\t\t  arvif);\n\n\t\tarvif->bitrate_mask = *mask;\n\t\tieee80211_iterate_stations_atomic(ar->hw,\n\t\t\t\t\t\t  ath11k_mac_set_bitrate_mask_iter,\n\t\t\t\t\t\t  arvif);\n\n\t\tmutex_unlock(&ar->conf_mutex);\n\t}\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tret = ath11k_mac_set_rate_params(arvif, rate, nss, sgi, ldpc, he_gi,\n\t\t\t\t\t he_ltf, he_fixed_rate);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to set rate params on vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t}\n\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn ret;\n}\n\nstatic void\nath11k_mac_op_reconfig_complete(struct ieee80211_hw *hw,\n\t\t\t\tenum ieee80211_reconfig_type reconfig_type)\n{\n\tstruct ath11k *ar = hw->priv;\n\tstruct ath11k_base *ab = ar->ab;\n\tint recovery_count;\n\tstruct ath11k_vif *arvif;\n\n\tif (reconfig_type != IEEE80211_RECONFIG_TYPE_RESTART)\n\t\treturn;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (ar->state == ATH11K_STATE_RESTARTED) {\n\t\tath11k_warn(ar->ab, \"pdev %d successfully recovered\\n\",\n\t\t\t    ar->pdev->pdev_id);\n\t\tar->state = ATH11K_STATE_ON;\n\t\tieee80211_wake_queues(ar->hw);\n\n\t\tif (ar->ab->hw_params.current_cc_support &&\n\t\t    ar->alpha2[0] != 0 && ar->alpha2[1] != 0) {\n\t\t\tstruct wmi_set_current_country_params set_current_param = {};\n\n\t\t\tmemcpy(&set_current_param.alpha2, ar->alpha2, 2);\n\t\t\tath11k_wmi_send_set_current_country_cmd(ar, &set_current_param);\n\t\t}\n\n\t\tif (ab->is_reset) {\n\t\t\trecovery_count = atomic_inc_return(&ab->recovery_count);\n\t\t\tath11k_dbg(ab, ATH11K_DBG_BOOT,\n\t\t\t\t   \"recovery count %d\\n\", recovery_count);\n\t\t\t \n\t\t\tif (recovery_count == ab->num_radios) {\n\t\t\t\tatomic_dec(&ab->reset_count);\n\t\t\t\tcomplete(&ab->reset_complete);\n\t\t\t\tab->is_reset = false;\n\t\t\t\tatomic_set(&ab->fail_cont_count, 0);\n\t\t\t\tath11k_dbg(ab, ATH11K_DBG_BOOT, \"reset success\\n\");\n\t\t\t}\n\t\t}\n\t\tif (ar->ab->hw_params.support_fw_mac_sequence) {\n\t\t\tlist_for_each_entry(arvif, &ar->arvifs, list) {\n\t\t\t\tif (arvif->is_up && arvif->vdev_type == WMI_VDEV_TYPE_STA)\n\t\t\t\t\tieee80211_hw_restart_disconnect(arvif->vif);\n\t\t\t}\n\t\t}\n\t}\n\n\tmutex_unlock(&ar->conf_mutex);\n}\n\nstatic void\nath11k_mac_update_bss_chan_survey(struct ath11k *ar,\n\t\t\t\t  struct ieee80211_channel *channel)\n{\n\tint ret;\n\tenum wmi_bss_chan_info_req_type type = WMI_BSS_SURVEY_REQ_TYPE_READ;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (!test_bit(WMI_TLV_SERVICE_BSS_CHANNEL_INFO_64, ar->ab->wmi_ab.svc_map) ||\n\t    ar->rx_channel != channel)\n\t\treturn;\n\n\tif (ar->scan.state != ATH11K_SCAN_IDLE) {\n\t\tath11k_dbg(ar->ab, ATH11K_DBG_MAC,\n\t\t\t   \"ignoring bss chan info req while scanning..\\n\");\n\t\treturn;\n\t}\n\n\treinit_completion(&ar->bss_survey_done);\n\n\tret = ath11k_wmi_pdev_bss_chan_info_request(ar, type);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to send pdev bss chan info request\\n\");\n\t\treturn;\n\t}\n\n\tret = wait_for_completion_timeout(&ar->bss_survey_done, 3 * HZ);\n\tif (ret == 0)\n\t\tath11k_warn(ar->ab, \"bss channel survey timed out\\n\");\n}\n\nstatic int ath11k_mac_op_get_survey(struct ieee80211_hw *hw, int idx,\n\t\t\t\t    struct survey_info *survey)\n{\n\tstruct ath11k *ar = hw->priv;\n\tstruct ieee80211_supported_band *sband;\n\tstruct survey_info *ar_survey;\n\tint ret = 0;\n\n\tif (idx >= ATH11K_NUM_CHANS)\n\t\treturn -ENOENT;\n\n\tar_survey = &ar->survey[idx];\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tsband = hw->wiphy->bands[NL80211_BAND_2GHZ];\n\tif (sband && idx >= sband->n_channels) {\n\t\tidx -= sband->n_channels;\n\t\tsband = NULL;\n\t}\n\n\tif (!sband)\n\t\tsband = hw->wiphy->bands[NL80211_BAND_5GHZ];\n\tif (sband && idx >= sband->n_channels) {\n\t\tidx -= sband->n_channels;\n\t\tsband = NULL;\n\t}\n\n\tif (!sband)\n\t\tsband = hw->wiphy->bands[NL80211_BAND_6GHZ];\n\tif (!sband || idx >= sband->n_channels) {\n\t\tret = -ENOENT;\n\t\tgoto exit;\n\t}\n\n\tath11k_mac_update_bss_chan_survey(ar, &sband->channels[idx]);\n\n\tspin_lock_bh(&ar->data_lock);\n\tmemcpy(survey, ar_survey, sizeof(*survey));\n\tspin_unlock_bh(&ar->data_lock);\n\n\tsurvey->channel = &sband->channels[idx];\n\n\tif (ar->rx_channel == survey->channel)\n\t\tsurvey->filled |= SURVEY_INFO_IN_USE;\n\nexit:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic void ath11k_mac_put_chain_rssi(struct station_info *sinfo,\n\t\t\t\t      struct ath11k_sta *arsta,\n\t\t\t\t      char *pre,\n\t\t\t\t      bool clear)\n{\n\tstruct ath11k *ar = arsta->arvif->ar;\n\tint i;\n\ts8 rssi;\n\n\tfor (i = 0; i < ARRAY_SIZE(sinfo->chain_signal); i++) {\n\t\tsinfo->chains &= ~BIT(i);\n\t\trssi = arsta->chain_signal[i];\n\t\tif (clear)\n\t\t\tarsta->chain_signal[i] = ATH11K_INVALID_RSSI_FULL;\n\n\t\tath11k_dbg(ar->ab, ATH11K_DBG_MAC,\n\t\t\t   \"sta statistics %s rssi[%d] %d\\n\", pre, i, rssi);\n\n\t\tif (rssi != ATH11K_DEFAULT_NOISE_FLOOR &&\n\t\t    rssi != ATH11K_INVALID_RSSI_FULL &&\n\t\t    rssi != ATH11K_INVALID_RSSI_EMPTY &&\n\t\t    rssi != 0) {\n\t\t\tsinfo->chain_signal[i] = rssi;\n\t\t\tsinfo->chains |= BIT(i);\n\t\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_CHAIN_SIGNAL);\n\t\t}\n\t}\n}\n\nstatic void ath11k_mac_op_sta_statistics(struct ieee80211_hw *hw,\n\t\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t\t struct ieee80211_sta *sta,\n\t\t\t\t\t struct station_info *sinfo)\n{\n\tstruct ath11k_sta *arsta = (struct ath11k_sta *)sta->drv_priv;\n\tstruct ath11k *ar = arsta->arvif->ar;\n\ts8 signal;\n\tbool db2dbm = test_bit(WMI_TLV_SERVICE_HW_DB2DBM_CONVERSION_SUPPORT,\n\t\t\t       ar->ab->wmi_ab.svc_map);\n\n\tsinfo->rx_duration = arsta->rx_duration;\n\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_RX_DURATION);\n\n\tsinfo->tx_duration = arsta->tx_duration;\n\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_DURATION);\n\n\tif (arsta->txrate.legacy || arsta->txrate.nss) {\n\t\tif (arsta->txrate.legacy) {\n\t\t\tsinfo->txrate.legacy = arsta->txrate.legacy;\n\t\t} else {\n\t\t\tsinfo->txrate.mcs = arsta->txrate.mcs;\n\t\t\tsinfo->txrate.nss = arsta->txrate.nss;\n\t\t\tsinfo->txrate.bw = arsta->txrate.bw;\n\t\t\tsinfo->txrate.he_gi = arsta->txrate.he_gi;\n\t\t\tsinfo->txrate.he_dcm = arsta->txrate.he_dcm;\n\t\t\tsinfo->txrate.he_ru_alloc = arsta->txrate.he_ru_alloc;\n\t\t}\n\t\tsinfo->txrate.flags = arsta->txrate.flags;\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_BITRATE);\n\t}\n\n\tath11k_mac_put_chain_rssi(sinfo, arsta, \"ppdu\", false);\n\n\tif (!(sinfo->filled & BIT_ULL(NL80211_STA_INFO_CHAIN_SIGNAL)) &&\n\t    arsta->arvif->vdev_type == WMI_VDEV_TYPE_STA &&\n\t    ar->ab->hw_params.supports_rssi_stats &&\n\t    !ath11k_debugfs_get_fw_stats(ar, ar->pdev->pdev_id, 0,\n\t\t\t\t\t WMI_REQUEST_RSSI_PER_CHAIN_STAT)) {\n\t\tath11k_mac_put_chain_rssi(sinfo, arsta, \"fw stats\", true);\n\t}\n\n\tsignal = arsta->rssi_comb;\n\tif (!signal &&\n\t    arsta->arvif->vdev_type == WMI_VDEV_TYPE_STA &&\n\t    ar->ab->hw_params.supports_rssi_stats &&\n\t    !(ath11k_debugfs_get_fw_stats(ar, ar->pdev->pdev_id, 0,\n\t\t\t\t\tWMI_REQUEST_VDEV_STAT)))\n\t\tsignal = arsta->rssi_beacon;\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_MAC,\n\t\t   \"sta statistics db2dbm %u rssi comb %d rssi beacon %d\\n\",\n\t\t   db2dbm, arsta->rssi_comb, arsta->rssi_beacon);\n\n\tif (signal) {\n\t\tsinfo->signal = db2dbm ? signal : signal + ATH11K_DEFAULT_NOISE_FLOOR;\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_SIGNAL);\n\t}\n\n\tsinfo->signal_avg = ewma_avg_rssi_read(&arsta->avg_rssi) +\n\t\tATH11K_DEFAULT_NOISE_FLOOR;\n\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_SIGNAL_AVG);\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic void ath11k_generate_ns_mc_addr(struct ath11k *ar,\n\t\t\t\t       struct ath11k_arp_ns_offload *offload)\n{\n\tint i;\n\n\tfor (i = 0; i < offload->ipv6_count; i++) {\n\t\toffload->self_ipv6_addr[i][0] = 0xff;\n\t\toffload->self_ipv6_addr[i][1] = 0x02;\n\t\toffload->self_ipv6_addr[i][11] = 0x01;\n\t\toffload->self_ipv6_addr[i][12] = 0xff;\n\t\toffload->self_ipv6_addr[i][13] =\n\t\t\t\t\toffload->ipv6_addr[i][13];\n\t\toffload->self_ipv6_addr[i][14] =\n\t\t\t\t\toffload->ipv6_addr[i][14];\n\t\toffload->self_ipv6_addr[i][15] =\n\t\t\t\t\toffload->ipv6_addr[i][15];\n\t\tath11k_dbg(ar->ab, ATH11K_DBG_MAC, \"NS solicited addr %pI6\\n\",\n\t\t\t   offload->self_ipv6_addr[i]);\n\t}\n}\n\nstatic void ath11k_mac_op_ipv6_changed(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       struct inet6_dev *idev)\n{\n\tstruct ath11k *ar = hw->priv;\n\tstruct ath11k_arp_ns_offload *offload;\n\tstruct ath11k_vif *arvif = ath11k_vif_to_arvif(vif);\n\tstruct inet6_ifaddr *ifa6;\n\tstruct ifacaddr6 *ifaca6;\n\tstruct list_head *p;\n\tu32 count, scope;\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_MAC, \"op ipv6 changed\\n\");\n\n\toffload = &arvif->arp_ns_offload;\n\tcount = 0;\n\n\tread_lock_bh(&idev->lock);\n\n\tmemset(offload->ipv6_addr, 0, sizeof(offload->ipv6_addr));\n\tmemset(offload->self_ipv6_addr, 0, sizeof(offload->self_ipv6_addr));\n\tmemcpy(offload->mac_addr, vif->addr, ETH_ALEN);\n\n\t \n\tlist_for_each(p, &idev->addr_list) {\n\t\tif (count >= ATH11K_IPV6_MAX_COUNT)\n\t\t\tgoto generate;\n\n\t\tifa6 = list_entry(p, struct inet6_ifaddr, if_list);\n\t\tif (ifa6->flags & IFA_F_DADFAILED)\n\t\t\tcontinue;\n\t\tscope = ipv6_addr_src_scope(&ifa6->addr);\n\t\tif (scope == IPV6_ADDR_SCOPE_LINKLOCAL ||\n\t\t    scope == IPV6_ADDR_SCOPE_GLOBAL) {\n\t\t\tmemcpy(offload->ipv6_addr[count], &ifa6->addr.s6_addr,\n\t\t\t       sizeof(ifa6->addr.s6_addr));\n\t\t\toffload->ipv6_type[count] = ATH11K_IPV6_UC_TYPE;\n\t\t\tath11k_dbg(ar->ab, ATH11K_DBG_MAC, \"count %d ipv6 uc %pI6 scope %d\\n\",\n\t\t\t\t   count, offload->ipv6_addr[count],\n\t\t\t\t   scope);\n\t\t\tcount++;\n\t\t} else {\n\t\t\tath11k_warn(ar->ab, \"Unsupported ipv6 scope: %d\\n\", scope);\n\t\t}\n\t}\n\n\t \n\tfor (ifaca6 = idev->ac_list; ifaca6; ifaca6 = ifaca6->aca_next) {\n\t\tif (count >= ATH11K_IPV6_MAX_COUNT)\n\t\t\tgoto generate;\n\n\t\tscope = ipv6_addr_src_scope(&ifaca6->aca_addr);\n\t\tif (scope == IPV6_ADDR_SCOPE_LINKLOCAL ||\n\t\t    scope == IPV6_ADDR_SCOPE_GLOBAL) {\n\t\t\tmemcpy(offload->ipv6_addr[count], &ifaca6->aca_addr,\n\t\t\t       sizeof(ifaca6->aca_addr));\n\t\t\toffload->ipv6_type[count] = ATH11K_IPV6_AC_TYPE;\n\t\t\tath11k_dbg(ar->ab, ATH11K_DBG_MAC, \"count %d ipv6 ac %pI6 scope %d\\n\",\n\t\t\t\t   count, offload->ipv6_addr[count],\n\t\t\t\t   scope);\n\t\t\tcount++;\n\t\t} else {\n\t\t\tath11k_warn(ar->ab, \"Unsupported ipv scope: %d\\n\", scope);\n\t\t}\n\t}\n\ngenerate:\n\toffload->ipv6_count = count;\n\tread_unlock_bh(&idev->lock);\n\n\t \n\tath11k_generate_ns_mc_addr(ar, offload);\n}\n#endif\n\nstatic void ath11k_mac_op_set_rekey_data(struct ieee80211_hw *hw,\n\t\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t\t struct cfg80211_gtk_rekey_data *data)\n{\n\tstruct ath11k *ar = hw->priv;\n\tstruct ath11k_vif *arvif = ath11k_vif_to_arvif(vif);\n\tstruct ath11k_rekey_data *rekey_data = &arvif->rekey_data;\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_MAC, \"set rekey data vdev %d\\n\",\n\t\t   arvif->vdev_id);\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tmemcpy(rekey_data->kck, data->kck, NL80211_KCK_LEN);\n\tmemcpy(rekey_data->kek, data->kek, NL80211_KEK_LEN);\n\n\t \n\trekey_data->replay_ctr = get_unaligned_be64(data->replay_ctr);\n\n\tarvif->rekey_data.enable_offload = true;\n\n\tath11k_dbg_dump(ar->ab, ATH11K_DBG_MAC, \"kck\", NULL,\n\t\t\trekey_data->kck, NL80211_KCK_LEN);\n\tath11k_dbg_dump(ar->ab, ATH11K_DBG_MAC, \"kek\", NULL,\n\t\t\trekey_data->kck, NL80211_KEK_LEN);\n\tath11k_dbg_dump(ar->ab, ATH11K_DBG_MAC, \"replay ctr\", NULL,\n\t\t\t&rekey_data->replay_ctr, sizeof(rekey_data->replay_ctr));\n\n\tmutex_unlock(&ar->conf_mutex);\n}\n\nstatic int ath11k_mac_op_set_bios_sar_specs(struct ieee80211_hw *hw,\n\t\t\t\t\t    const struct cfg80211_sar_specs *sar)\n{\n\tstruct ath11k *ar = hw->priv;\n\tconst struct cfg80211_sar_sub_specs *sspec;\n\tint ret, index;\n\tu8 *sar_tbl;\n\tu32 i;\n\n\tif (!sar || sar->type != NL80211_SAR_TYPE_POWER ||\n\t    sar->num_sub_specs == 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (!test_bit(WMI_TLV_SERVICE_BIOS_SAR_SUPPORT, ar->ab->wmi_ab.svc_map) ||\n\t    !ar->ab->hw_params.bios_sar_capa) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto exit;\n\t}\n\n\tret = ath11k_wmi_pdev_set_bios_geo_table_param(ar);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to set geo table: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tsar_tbl = kzalloc(BIOS_SAR_TABLE_LEN, GFP_KERNEL);\n\tif (!sar_tbl) {\n\t\tret = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\tsspec = sar->sub_specs;\n\tfor (i = 0; i < sar->num_sub_specs; i++) {\n\t\tif (sspec->freq_range_index >= (BIOS_SAR_TABLE_LEN >> 1)) {\n\t\t\tath11k_warn(ar->ab, \"Ignore bad frequency index %u, max allowed %u\\n\",\n\t\t\t\t    sspec->freq_range_index, BIOS_SAR_TABLE_LEN >> 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tsar_tbl[sspec->freq_range_index] = sspec->power;\n\t\tindex = sspec->freq_range_index + (BIOS_SAR_TABLE_LEN >> 1);\n\t\tsar_tbl[index] = sspec->power;\n\t\tath11k_dbg(ar->ab, ATH11K_DBG_MAC, \"sar tbl[%d] = %d\\n\",\n\t\t\t   sspec->freq_range_index, sar_tbl[sspec->freq_range_index]);\n\t\tsspec++;\n\t}\n\n\tret = ath11k_wmi_pdev_set_bios_sar_table_param(ar, sar_tbl);\n\tif (ret)\n\t\tath11k_warn(ar->ab, \"failed to set sar power: %d\", ret);\n\n\tkfree(sar_tbl);\nexit:\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn ret;\n}\n\nstatic int ath11k_mac_op_cancel_remain_on_channel(struct ieee80211_hw *hw,\n\t\t\t\t\t\t  struct ieee80211_vif *vif)\n{\n\tstruct ath11k *ar = hw->priv;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tspin_lock_bh(&ar->data_lock);\n\tar->scan.roc_notify = false;\n\tspin_unlock_bh(&ar->data_lock);\n\n\tath11k_scan_abort(ar);\n\n\tmutex_unlock(&ar->conf_mutex);\n\n\tcancel_delayed_work_sync(&ar->scan.timeout);\n\n\treturn 0;\n}\n\nstatic int ath11k_mac_op_remain_on_channel(struct ieee80211_hw *hw,\n\t\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t\t   struct ieee80211_channel *chan,\n\t\t\t\t\t   int duration,\n\t\t\t\t\t   enum ieee80211_roc_type type)\n{\n\tstruct ath11k *ar = hw->priv;\n\tstruct ath11k_vif *arvif = ath11k_vif_to_arvif(vif);\n\tstruct scan_req_params arg;\n\tint ret;\n\tu32 scan_time_msec;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tspin_lock_bh(&ar->data_lock);\n\tswitch (ar->scan.state) {\n\tcase ATH11K_SCAN_IDLE:\n\t\treinit_completion(&ar->scan.started);\n\t\treinit_completion(&ar->scan.completed);\n\t\treinit_completion(&ar->scan.on_channel);\n\t\tar->scan.state = ATH11K_SCAN_STARTING;\n\t\tar->scan.is_roc = true;\n\t\tar->scan.vdev_id = arvif->vdev_id;\n\t\tar->scan.roc_freq = chan->center_freq;\n\t\tar->scan.roc_notify = true;\n\t\tret = 0;\n\t\tbreak;\n\tcase ATH11K_SCAN_STARTING:\n\tcase ATH11K_SCAN_RUNNING:\n\tcase ATH11K_SCAN_ABORTING:\n\t\tret = -EBUSY;\n\t\tbreak;\n\t}\n\tspin_unlock_bh(&ar->data_lock);\n\n\tif (ret)\n\t\tgoto exit;\n\n\tscan_time_msec = ar->hw->wiphy->max_remain_on_channel_duration * 2;\n\n\tmemset(&arg, 0, sizeof(arg));\n\tath11k_wmi_start_scan_init(ar, &arg);\n\targ.num_chan = 1;\n\targ.chan_list = kcalloc(arg.num_chan, sizeof(*arg.chan_list),\n\t\t\t\tGFP_KERNEL);\n\tif (!arg.chan_list) {\n\t\tret = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\targ.vdev_id = arvif->vdev_id;\n\targ.scan_id = ATH11K_SCAN_ID;\n\targ.chan_list[0] = chan->center_freq;\n\targ.dwell_time_active = scan_time_msec;\n\targ.dwell_time_passive = scan_time_msec;\n\targ.max_scan_time = scan_time_msec;\n\targ.scan_flags |= WMI_SCAN_FLAG_PASSIVE;\n\targ.scan_flags |= WMI_SCAN_FILTER_PROBE_REQ;\n\targ.burst_duration = duration;\n\n\tret = ath11k_start_scan(ar, &arg);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to start roc scan: %d\\n\", ret);\n\n\t\tspin_lock_bh(&ar->data_lock);\n\t\tar->scan.state = ATH11K_SCAN_IDLE;\n\t\tspin_unlock_bh(&ar->data_lock);\n\t\tgoto free_chan_list;\n\t}\n\n\tret = wait_for_completion_timeout(&ar->scan.on_channel, 3 * HZ);\n\tif (ret == 0) {\n\t\tath11k_warn(ar->ab, \"failed to switch to channel for roc scan\\n\");\n\t\tret = ath11k_scan_stop(ar);\n\t\tif (ret)\n\t\t\tath11k_warn(ar->ab, \"failed to stop scan: %d\\n\", ret);\n\t\tret = -ETIMEDOUT;\n\t\tgoto free_chan_list;\n\t}\n\n\tieee80211_queue_delayed_work(ar->hw, &ar->scan.timeout,\n\t\t\t\t     msecs_to_jiffies(duration));\n\n\tret = 0;\n\nfree_chan_list:\n\tkfree(arg.chan_list);\nexit:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic int ath11k_fw_stats_request(struct ath11k *ar,\n\t\t\t\t   struct stats_request_params *req_param)\n{\n\tstruct ath11k_base *ab = ar->ab;\n\tunsigned long time_left;\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tspin_lock_bh(&ar->data_lock);\n\tar->fw_stats_done = false;\n\tath11k_fw_stats_pdevs_free(&ar->fw_stats.pdevs);\n\tspin_unlock_bh(&ar->data_lock);\n\n\treinit_completion(&ar->fw_stats_complete);\n\n\tret = ath11k_wmi_send_stats_request_cmd(ar, req_param);\n\tif (ret) {\n\t\tath11k_warn(ab, \"could not request fw stats (%d)\\n\",\n\t\t\t    ret);\n\t\treturn ret;\n\t}\n\n\ttime_left = wait_for_completion_timeout(&ar->fw_stats_complete,\n\t\t\t\t\t\t1 * HZ);\n\n\tif (!time_left)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic int ath11k_mac_op_get_txpower(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t     int *dbm)\n{\n\tstruct ath11k *ar = hw->priv;\n\tstruct ath11k_base *ab = ar->ab;\n\tstruct stats_request_params req_param = {0};\n\tstruct ath11k_fw_stats_pdev *pdev;\n\tint ret;\n\n\t \n\tmutex_lock(&ar->conf_mutex);\n\n\tif (ar->state != ATH11K_STATE_ON)\n\t\tgoto err_fallback;\n\n\t \n\tif (test_bit(ATH11K_CAC_RUNNING, &ar->dev_flags)) {\n\t\tmutex_unlock(&ar->conf_mutex);\n\t\treturn -EAGAIN;\n\t}\n\n\treq_param.pdev_id = ar->pdev->pdev_id;\n\treq_param.stats_id = WMI_REQUEST_PDEV_STAT;\n\n\tret = ath11k_fw_stats_request(ar, &req_param);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to request fw pdev stats: %d\\n\", ret);\n\t\tgoto err_fallback;\n\t}\n\n\tspin_lock_bh(&ar->data_lock);\n\tpdev = list_first_entry_or_null(&ar->fw_stats.pdevs,\n\t\t\t\t\tstruct ath11k_fw_stats_pdev, list);\n\tif (!pdev) {\n\t\tspin_unlock_bh(&ar->data_lock);\n\t\tgoto err_fallback;\n\t}\n\n\t \n\t*dbm = pdev->chan_tx_power / 2;\n\n\tspin_unlock_bh(&ar->data_lock);\n\tmutex_unlock(&ar->conf_mutex);\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_MAC, \"txpower from firmware %d, reported %d dBm\\n\",\n\t\t   pdev->chan_tx_power, *dbm);\n\treturn 0;\n\nerr_fallback:\n\tmutex_unlock(&ar->conf_mutex);\n\t \n\t*dbm = vif->bss_conf.txpower;\n\tath11k_dbg(ar->ab, ATH11K_DBG_MAC, \"txpower from firmware NaN, reported %d dBm\\n\",\n\t\t   *dbm);\n\treturn 0;\n}\n\nstatic const struct ieee80211_ops ath11k_ops = {\n\t.tx\t\t\t\t= ath11k_mac_op_tx,\n\t.wake_tx_queue\t\t\t= ieee80211_handle_wake_tx_queue,\n\t.start                          = ath11k_mac_op_start,\n\t.stop                           = ath11k_mac_op_stop,\n\t.reconfig_complete              = ath11k_mac_op_reconfig_complete,\n\t.add_interface                  = ath11k_mac_op_add_interface,\n\t.remove_interface\t\t= ath11k_mac_op_remove_interface,\n\t.update_vif_offload\t\t= ath11k_mac_op_update_vif_offload,\n\t.config                         = ath11k_mac_op_config,\n\t.bss_info_changed               = ath11k_mac_op_bss_info_changed,\n\t.configure_filter\t\t= ath11k_mac_op_configure_filter,\n\t.hw_scan                        = ath11k_mac_op_hw_scan,\n\t.cancel_hw_scan                 = ath11k_mac_op_cancel_hw_scan,\n\t.set_key                        = ath11k_mac_op_set_key,\n\t.set_rekey_data\t                = ath11k_mac_op_set_rekey_data,\n\t.sta_state                      = ath11k_mac_op_sta_state,\n\t.sta_set_4addr                  = ath11k_mac_op_sta_set_4addr,\n\t.sta_set_txpwr\t\t\t= ath11k_mac_op_sta_set_txpwr,\n\t.sta_rc_update\t\t\t= ath11k_mac_op_sta_rc_update,\n\t.conf_tx                        = ath11k_mac_op_conf_tx,\n\t.set_antenna\t\t\t= ath11k_mac_op_set_antenna,\n\t.get_antenna\t\t\t= ath11k_mac_op_get_antenna,\n\t.ampdu_action\t\t\t= ath11k_mac_op_ampdu_action,\n\t.add_chanctx\t\t\t= ath11k_mac_op_add_chanctx,\n\t.remove_chanctx\t\t\t= ath11k_mac_op_remove_chanctx,\n\t.change_chanctx\t\t\t= ath11k_mac_op_change_chanctx,\n\t.assign_vif_chanctx\t\t= ath11k_mac_op_assign_vif_chanctx,\n\t.unassign_vif_chanctx\t\t= ath11k_mac_op_unassign_vif_chanctx,\n\t.switch_vif_chanctx\t\t= ath11k_mac_op_switch_vif_chanctx,\n\t.set_rts_threshold\t\t= ath11k_mac_op_set_rts_threshold,\n\t.set_frag_threshold\t\t= ath11k_mac_op_set_frag_threshold,\n\t.set_bitrate_mask\t\t= ath11k_mac_op_set_bitrate_mask,\n\t.get_survey\t\t\t= ath11k_mac_op_get_survey,\n\t.flush\t\t\t\t= ath11k_mac_op_flush,\n\t.sta_statistics\t\t\t= ath11k_mac_op_sta_statistics,\n\tCFG80211_TESTMODE_CMD(ath11k_tm_cmd)\n\n#ifdef CONFIG_PM\n\t.suspend\t\t\t= ath11k_wow_op_suspend,\n\t.resume\t\t\t\t= ath11k_wow_op_resume,\n\t.set_wakeup\t\t\t= ath11k_wow_op_set_wakeup,\n#endif\n\n#ifdef CONFIG_ATH11K_DEBUGFS\n\t.sta_add_debugfs\t\t= ath11k_debugfs_sta_op_add,\n#endif\n\n#if IS_ENABLED(CONFIG_IPV6)\n\t.ipv6_addr_change = ath11k_mac_op_ipv6_changed,\n#endif\n\t.get_txpower                    = ath11k_mac_op_get_txpower,\n\n\t.set_sar_specs\t\t\t= ath11k_mac_op_set_bios_sar_specs,\n\t.remain_on_channel\t\t= ath11k_mac_op_remain_on_channel,\n\t.cancel_remain_on_channel\t= ath11k_mac_op_cancel_remain_on_channel,\n};\n\nstatic void ath11k_mac_update_ch_list(struct ath11k *ar,\n\t\t\t\t      struct ieee80211_supported_band *band,\n\t\t\t\t      u32 freq_low, u32 freq_high)\n{\n\tint i;\n\n\tif (!(freq_low && freq_high))\n\t\treturn;\n\n\tfor (i = 0; i < band->n_channels; i++) {\n\t\tif (band->channels[i].center_freq < freq_low ||\n\t\t    band->channels[i].center_freq > freq_high)\n\t\t\tband->channels[i].flags |= IEEE80211_CHAN_DISABLED;\n\t}\n}\n\nstatic u32 ath11k_get_phy_id(struct ath11k *ar, u32 band)\n{\n\tstruct ath11k_pdev *pdev = ar->pdev;\n\tstruct ath11k_pdev_cap *pdev_cap = &pdev->cap;\n\n\tif (band == WMI_HOST_WLAN_2G_CAP)\n\t\treturn pdev_cap->band[NL80211_BAND_2GHZ].phy_id;\n\n\tif (band == WMI_HOST_WLAN_5G_CAP)\n\t\treturn pdev_cap->band[NL80211_BAND_5GHZ].phy_id;\n\n\tath11k_warn(ar->ab, \"unsupported phy cap:%d\\n\", band);\n\n\treturn 0;\n}\n\nstatic int ath11k_mac_setup_channels_rates(struct ath11k *ar,\n\t\t\t\t\t   u32 supported_bands)\n{\n\tstruct ieee80211_supported_band *band;\n\tstruct ath11k_hal_reg_capabilities_ext *reg_cap, *temp_reg_cap;\n\tvoid *channels;\n\tu32 phy_id;\n\n\tBUILD_BUG_ON((ARRAY_SIZE(ath11k_2ghz_channels) +\n\t\t      ARRAY_SIZE(ath11k_5ghz_channels) +\n\t\t      ARRAY_SIZE(ath11k_6ghz_channels)) !=\n\t\t     ATH11K_NUM_CHANS);\n\n\treg_cap = &ar->ab->hal_reg_cap[ar->pdev_idx];\n\ttemp_reg_cap = reg_cap;\n\n\tif (supported_bands & WMI_HOST_WLAN_2G_CAP) {\n\t\tchannels = kmemdup(ath11k_2ghz_channels,\n\t\t\t\t   sizeof(ath11k_2ghz_channels),\n\t\t\t\t   GFP_KERNEL);\n\t\tif (!channels)\n\t\t\treturn -ENOMEM;\n\n\t\tband = &ar->mac.sbands[NL80211_BAND_2GHZ];\n\t\tband->band = NL80211_BAND_2GHZ;\n\t\tband->n_channels = ARRAY_SIZE(ath11k_2ghz_channels);\n\t\tband->channels = channels;\n\t\tband->n_bitrates = ath11k_g_rates_size;\n\t\tband->bitrates = ath11k_g_rates;\n\t\tar->hw->wiphy->bands[NL80211_BAND_2GHZ] = band;\n\n\t\tif (ar->ab->hw_params.single_pdev_only) {\n\t\t\tphy_id = ath11k_get_phy_id(ar, WMI_HOST_WLAN_2G_CAP);\n\t\t\ttemp_reg_cap = &ar->ab->hal_reg_cap[phy_id];\n\t\t}\n\t\tath11k_mac_update_ch_list(ar, band,\n\t\t\t\t\t  temp_reg_cap->low_2ghz_chan,\n\t\t\t\t\t  temp_reg_cap->high_2ghz_chan);\n\t}\n\n\tif (supported_bands & WMI_HOST_WLAN_5G_CAP) {\n\t\tif (reg_cap->high_5ghz_chan >= ATH11K_MIN_6G_FREQ) {\n\t\t\tchannels = kmemdup(ath11k_6ghz_channels,\n\t\t\t\t\t   sizeof(ath11k_6ghz_channels), GFP_KERNEL);\n\t\t\tif (!channels) {\n\t\t\t\tkfree(ar->mac.sbands[NL80211_BAND_2GHZ].channels);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\tar->supports_6ghz = true;\n\t\t\tband = &ar->mac.sbands[NL80211_BAND_6GHZ];\n\t\t\tband->band = NL80211_BAND_6GHZ;\n\t\t\tband->n_channels = ARRAY_SIZE(ath11k_6ghz_channels);\n\t\t\tband->channels = channels;\n\t\t\tband->n_bitrates = ath11k_a_rates_size;\n\t\t\tband->bitrates = ath11k_a_rates;\n\t\t\tar->hw->wiphy->bands[NL80211_BAND_6GHZ] = band;\n\n\t\t\tif (ar->ab->hw_params.single_pdev_only) {\n\t\t\t\tphy_id = ath11k_get_phy_id(ar, WMI_HOST_WLAN_5G_CAP);\n\t\t\t\ttemp_reg_cap = &ar->ab->hal_reg_cap[phy_id];\n\t\t\t}\n\n\t\t\tath11k_mac_update_ch_list(ar, band,\n\t\t\t\t\t\t  temp_reg_cap->low_5ghz_chan,\n\t\t\t\t\t\t  temp_reg_cap->high_5ghz_chan);\n\t\t}\n\n\t\tif (reg_cap->low_5ghz_chan < ATH11K_MIN_6G_FREQ) {\n\t\t\tchannels = kmemdup(ath11k_5ghz_channels,\n\t\t\t\t\t   sizeof(ath11k_5ghz_channels),\n\t\t\t\t\t   GFP_KERNEL);\n\t\t\tif (!channels) {\n\t\t\t\tkfree(ar->mac.sbands[NL80211_BAND_2GHZ].channels);\n\t\t\t\tkfree(ar->mac.sbands[NL80211_BAND_6GHZ].channels);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\tband = &ar->mac.sbands[NL80211_BAND_5GHZ];\n\t\t\tband->band = NL80211_BAND_5GHZ;\n\t\t\tband->n_channels = ARRAY_SIZE(ath11k_5ghz_channels);\n\t\t\tband->channels = channels;\n\t\t\tband->n_bitrates = ath11k_a_rates_size;\n\t\t\tband->bitrates = ath11k_a_rates;\n\t\t\tar->hw->wiphy->bands[NL80211_BAND_5GHZ] = band;\n\n\t\t\tif (ar->ab->hw_params.single_pdev_only) {\n\t\t\t\tphy_id = ath11k_get_phy_id(ar, WMI_HOST_WLAN_5G_CAP);\n\t\t\t\ttemp_reg_cap = &ar->ab->hal_reg_cap[phy_id];\n\t\t\t}\n\n\t\t\tath11k_mac_update_ch_list(ar, band,\n\t\t\t\t\t\t  temp_reg_cap->low_5ghz_chan,\n\t\t\t\t\t\t  temp_reg_cap->high_5ghz_chan);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ath11k_mac_setup_iface_combinations(struct ath11k *ar)\n{\n\tstruct ath11k_base *ab = ar->ab;\n\tstruct ieee80211_iface_combination *combinations;\n\tstruct ieee80211_iface_limit *limits;\n\tint n_limits;\n\n\tcombinations = kzalloc(sizeof(*combinations), GFP_KERNEL);\n\tif (!combinations)\n\t\treturn -ENOMEM;\n\n\tn_limits = 2;\n\n\tlimits = kcalloc(n_limits, sizeof(*limits), GFP_KERNEL);\n\tif (!limits) {\n\t\tkfree(combinations);\n\t\treturn -ENOMEM;\n\t}\n\n\tlimits[0].max = 1;\n\tlimits[0].types |= BIT(NL80211_IFTYPE_STATION);\n\n\tlimits[1].max = 16;\n\tlimits[1].types |= BIT(NL80211_IFTYPE_AP);\n\n\tif (IS_ENABLED(CONFIG_MAC80211_MESH) &&\n\t    ab->hw_params.interface_modes & BIT(NL80211_IFTYPE_MESH_POINT))\n\t\tlimits[1].types |= BIT(NL80211_IFTYPE_MESH_POINT);\n\n\tcombinations[0].limits = limits;\n\tcombinations[0].n_limits = n_limits;\n\tcombinations[0].max_interfaces = 16;\n\tcombinations[0].num_different_channels = 1;\n\tcombinations[0].beacon_int_infra_match = true;\n\tcombinations[0].beacon_int_min_gcd = 100;\n\tcombinations[0].radar_detect_widths = BIT(NL80211_CHAN_WIDTH_20_NOHT) |\n\t\t\t\t\t\tBIT(NL80211_CHAN_WIDTH_20) |\n\t\t\t\t\t\tBIT(NL80211_CHAN_WIDTH_40) |\n\t\t\t\t\t\tBIT(NL80211_CHAN_WIDTH_80) |\n\t\t\t\t\t\tBIT(NL80211_CHAN_WIDTH_80P80) |\n\t\t\t\t\t\tBIT(NL80211_CHAN_WIDTH_160);\n\n\tar->hw->wiphy->iface_combinations = combinations;\n\tar->hw->wiphy->n_iface_combinations = 1;\n\n\treturn 0;\n}\n\nstatic const u8 ath11k_if_types_ext_capa[] = {\n\t[0] = WLAN_EXT_CAPA1_EXT_CHANNEL_SWITCHING,\n\t[2] = WLAN_EXT_CAPA3_MULTI_BSSID_SUPPORT,\n\t[7] = WLAN_EXT_CAPA8_OPMODE_NOTIF,\n};\n\nstatic const u8 ath11k_if_types_ext_capa_sta[] = {\n\t[0] = WLAN_EXT_CAPA1_EXT_CHANNEL_SWITCHING,\n\t[2] = WLAN_EXT_CAPA3_MULTI_BSSID_SUPPORT,\n\t[7] = WLAN_EXT_CAPA8_OPMODE_NOTIF,\n\t[9] = WLAN_EXT_CAPA10_TWT_REQUESTER_SUPPORT,\n};\n\nstatic const u8 ath11k_if_types_ext_capa_ap[] = {\n\t[0] = WLAN_EXT_CAPA1_EXT_CHANNEL_SWITCHING,\n\t[2] = WLAN_EXT_CAPA3_MULTI_BSSID_SUPPORT,\n\t[7] = WLAN_EXT_CAPA8_OPMODE_NOTIF,\n\t[9] = WLAN_EXT_CAPA10_TWT_RESPONDER_SUPPORT,\n\t[10] = WLAN_EXT_CAPA11_EMA_SUPPORT,\n};\n\nstatic const struct wiphy_iftype_ext_capab ath11k_iftypes_ext_capa[] = {\n\t{\n\t\t.extended_capabilities = ath11k_if_types_ext_capa,\n\t\t.extended_capabilities_mask = ath11k_if_types_ext_capa,\n\t\t.extended_capabilities_len = sizeof(ath11k_if_types_ext_capa),\n\t}, {\n\t\t.iftype = NL80211_IFTYPE_STATION,\n\t\t.extended_capabilities = ath11k_if_types_ext_capa_sta,\n\t\t.extended_capabilities_mask = ath11k_if_types_ext_capa_sta,\n\t\t.extended_capabilities_len =\n\t\t\t\tsizeof(ath11k_if_types_ext_capa_sta),\n\t}, {\n\t\t.iftype = NL80211_IFTYPE_AP,\n\t\t.extended_capabilities = ath11k_if_types_ext_capa_ap,\n\t\t.extended_capabilities_mask = ath11k_if_types_ext_capa_ap,\n\t\t.extended_capabilities_len =\n\t\t\t\tsizeof(ath11k_if_types_ext_capa_ap),\n\t},\n};\n\nstatic void __ath11k_mac_unregister(struct ath11k *ar)\n{\n\tcancel_work_sync(&ar->regd_update_work);\n\n\tieee80211_unregister_hw(ar->hw);\n\n\tidr_for_each(&ar->txmgmt_idr, ath11k_mac_tx_mgmt_pending_free, ar);\n\tidr_destroy(&ar->txmgmt_idr);\n\n\tkfree(ar->mac.sbands[NL80211_BAND_2GHZ].channels);\n\tkfree(ar->mac.sbands[NL80211_BAND_5GHZ].channels);\n\tkfree(ar->mac.sbands[NL80211_BAND_6GHZ].channels);\n\n\tkfree(ar->hw->wiphy->iface_combinations[0].limits);\n\tkfree(ar->hw->wiphy->iface_combinations);\n\n\tSET_IEEE80211_DEV(ar->hw, NULL);\n}\n\nvoid ath11k_mac_unregister(struct ath11k_base *ab)\n{\n\tstruct ath11k *ar;\n\tstruct ath11k_pdev *pdev;\n\tint i;\n\n\tfor (i = 0; i < ab->num_radios; i++) {\n\t\tpdev = &ab->pdevs[i];\n\t\tar = pdev->ar;\n\t\tif (!ar)\n\t\t\tcontinue;\n\n\t\t__ath11k_mac_unregister(ar);\n\t}\n\n\tath11k_peer_rhash_tbl_destroy(ab);\n}\n\nstatic int __ath11k_mac_register(struct ath11k *ar)\n{\n\tstruct ath11k_base *ab = ar->ab;\n\tstruct ath11k_pdev_cap *cap = &ar->pdev->cap;\n\tstatic const u32 cipher_suites[] = {\n\t\tWLAN_CIPHER_SUITE_TKIP,\n\t\tWLAN_CIPHER_SUITE_CCMP,\n\t\tWLAN_CIPHER_SUITE_AES_CMAC,\n\t\tWLAN_CIPHER_SUITE_BIP_CMAC_256,\n\t\tWLAN_CIPHER_SUITE_BIP_GMAC_128,\n\t\tWLAN_CIPHER_SUITE_BIP_GMAC_256,\n\t\tWLAN_CIPHER_SUITE_GCMP,\n\t\tWLAN_CIPHER_SUITE_GCMP_256,\n\t\tWLAN_CIPHER_SUITE_CCMP_256,\n\t};\n\tint ret;\n\tu32 ht_cap = 0;\n\n\tath11k_pdev_caps_update(ar);\n\n\tSET_IEEE80211_PERM_ADDR(ar->hw, ar->mac_addr);\n\n\tSET_IEEE80211_DEV(ar->hw, ab->dev);\n\n\tret = ath11k_mac_setup_channels_rates(ar,\n\t\t\t\t\t      cap->supported_bands);\n\tif (ret)\n\t\tgoto err;\n\n\tath11k_mac_setup_ht_vht_cap(ar, cap, &ht_cap);\n\tath11k_mac_setup_he_cap(ar, cap);\n\n\tret = ath11k_mac_setup_iface_combinations(ar);\n\tif (ret) {\n\t\tath11k_err(ar->ab, \"failed to setup interface combinations: %d\\n\", ret);\n\t\tgoto err_free_channels;\n\t}\n\n\tar->hw->wiphy->available_antennas_rx = cap->rx_chain_mask;\n\tar->hw->wiphy->available_antennas_tx = cap->tx_chain_mask;\n\n\tar->hw->wiphy->interface_modes = ab->hw_params.interface_modes;\n\n\tif (ab->hw_params.single_pdev_only && ar->supports_6ghz)\n\t\tieee80211_hw_set(ar->hw, SINGLE_SCAN_ON_ALL_BANDS);\n\n\tif (ab->hw_params.supports_multi_bssid) {\n\t\tieee80211_hw_set(ar->hw, SUPPORTS_MULTI_BSSID);\n\t\tieee80211_hw_set(ar->hw, SUPPORTS_ONLY_HE_MULTI_BSSID);\n\t}\n\n\tieee80211_hw_set(ar->hw, SIGNAL_DBM);\n\tieee80211_hw_set(ar->hw, SUPPORTS_PS);\n\tieee80211_hw_set(ar->hw, SUPPORTS_DYNAMIC_PS);\n\tieee80211_hw_set(ar->hw, MFP_CAPABLE);\n\tieee80211_hw_set(ar->hw, REPORTS_TX_ACK_STATUS);\n\tieee80211_hw_set(ar->hw, HAS_RATE_CONTROL);\n\tieee80211_hw_set(ar->hw, AP_LINK_PS);\n\tieee80211_hw_set(ar->hw, SPECTRUM_MGMT);\n\tieee80211_hw_set(ar->hw, CONNECTION_MONITOR);\n\tieee80211_hw_set(ar->hw, SUPPORTS_PER_STA_GTK);\n\tieee80211_hw_set(ar->hw, WANT_MONITOR_VIF);\n\tieee80211_hw_set(ar->hw, CHANCTX_STA_CSA);\n\tieee80211_hw_set(ar->hw, QUEUE_CONTROL);\n\tieee80211_hw_set(ar->hw, SUPPORTS_TX_FRAG);\n\tieee80211_hw_set(ar->hw, REPORTS_LOW_ACK);\n\n\tif (ath11k_frame_mode == ATH11K_HW_TXRX_ETHERNET) {\n\t\tieee80211_hw_set(ar->hw, SUPPORTS_TX_ENCAP_OFFLOAD);\n\t\tieee80211_hw_set(ar->hw, SUPPORTS_RX_DECAP_OFFLOAD);\n\t}\n\n\tif (cap->nss_ratio_enabled)\n\t\tieee80211_hw_set(ar->hw, SUPPORTS_VHT_EXT_NSS_BW);\n\n\tif ((ht_cap & WMI_HT_CAP_ENABLED) || ar->supports_6ghz) {\n\t\tieee80211_hw_set(ar->hw, AMPDU_AGGREGATION);\n\t\tieee80211_hw_set(ar->hw, TX_AMPDU_SETUP_IN_HW);\n\t\tieee80211_hw_set(ar->hw, SUPPORTS_REORDERING_BUFFER);\n\t\tieee80211_hw_set(ar->hw, SUPPORTS_AMSDU_IN_AMPDU);\n\t\tieee80211_hw_set(ar->hw, USES_RSS);\n\t}\n\n\tar->hw->wiphy->features |= NL80211_FEATURE_STATIC_SMPS;\n\tar->hw->wiphy->flags |= WIPHY_FLAG_IBSS_RSN;\n\n\t \n\tif (ht_cap & WMI_HT_CAP_DYNAMIC_SMPS ||\n\t    (ar->supports_6ghz && ab->hw_params.supports_dynamic_smps_6ghz))\n\t\tar->hw->wiphy->features |= NL80211_FEATURE_DYNAMIC_SMPS;\n\n\tar->hw->wiphy->max_scan_ssids = WLAN_SCAN_PARAMS_MAX_SSID;\n\tar->hw->wiphy->max_scan_ie_len = WLAN_SCAN_PARAMS_MAX_IE_LEN;\n\n\tar->hw->max_listen_interval = ATH11K_MAX_HW_LISTEN_INTERVAL;\n\n\tar->hw->wiphy->flags |= WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;\n\tar->hw->wiphy->flags |= WIPHY_FLAG_HAS_CHANNEL_SWITCH;\n\tar->hw->wiphy->max_remain_on_channel_duration = 5000;\n\n\tar->hw->wiphy->flags |= WIPHY_FLAG_AP_UAPSD;\n\tar->hw->wiphy->features |= NL80211_FEATURE_AP_MODE_CHAN_WIDTH_CHANGE |\n\t\t\t\t   NL80211_FEATURE_AP_SCAN;\n\n\tar->max_num_stations = TARGET_NUM_STATIONS(ab);\n\tar->max_num_peers = TARGET_NUM_PEERS_PDEV(ab);\n\n\tar->hw->wiphy->max_ap_assoc_sta = ar->max_num_stations;\n\n\tif (test_bit(WMI_TLV_SERVICE_SPOOF_MAC_SUPPORT, ar->wmi->wmi_ab->svc_map)) {\n\t\tar->hw->wiphy->features |=\n\t\t\tNL80211_FEATURE_SCAN_RANDOM_MAC_ADDR;\n\t}\n\n\tif (test_bit(WMI_TLV_SERVICE_NLO, ar->wmi->wmi_ab->svc_map)) {\n\t\tar->hw->wiphy->max_sched_scan_ssids = WMI_PNO_MAX_SUPP_NETWORKS;\n\t\tar->hw->wiphy->max_match_sets = WMI_PNO_MAX_SUPP_NETWORKS;\n\t\tar->hw->wiphy->max_sched_scan_ie_len = WMI_PNO_MAX_IE_LENGTH;\n\t\tar->hw->wiphy->max_sched_scan_plans = WMI_PNO_MAX_SCHED_SCAN_PLANS;\n\t\tar->hw->wiphy->max_sched_scan_plan_interval =\n\t\t\tWMI_PNO_MAX_SCHED_SCAN_PLAN_INT;\n\t\tar->hw->wiphy->max_sched_scan_plan_iterations =\n\t\t\tWMI_PNO_MAX_SCHED_SCAN_PLAN_ITRNS;\n\t\tar->hw->wiphy->features |= NL80211_FEATURE_ND_RANDOM_MAC_ADDR;\n\t}\n\n\tret = ath11k_wow_init(ar);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to init wow: %d\\n\", ret);\n\t\tgoto err_free_if_combs;\n\t}\n\n\tif (test_bit(WMI_TLV_SERVICE_TX_DATA_MGMT_ACK_RSSI,\n\t\t     ar->ab->wmi_ab.svc_map))\n\t\twiphy_ext_feature_set(ar->hw->wiphy,\n\t\t\t\t      NL80211_EXT_FEATURE_ACK_SIGNAL_SUPPORT);\n\n\tar->hw->queues = ATH11K_HW_MAX_QUEUES;\n\tar->hw->wiphy->tx_queue_len = ATH11K_QUEUE_LEN;\n\tar->hw->offchannel_tx_hw_queue = ATH11K_HW_MAX_QUEUES - 1;\n\tar->hw->max_rx_aggregation_subframes = IEEE80211_MAX_AMPDU_BUF_HE;\n\n\tar->hw->vif_data_size = sizeof(struct ath11k_vif);\n\tar->hw->sta_data_size = sizeof(struct ath11k_sta);\n\n\twiphy_ext_feature_set(ar->hw->wiphy, NL80211_EXT_FEATURE_CQM_RSSI_LIST);\n\twiphy_ext_feature_set(ar->hw->wiphy, NL80211_EXT_FEATURE_STA_TX_PWR);\n\tif (test_bit(WMI_TLV_SERVICE_BSS_COLOR_OFFLOAD,\n\t\t     ar->ab->wmi_ab.svc_map)) {\n\t\twiphy_ext_feature_set(ar->hw->wiphy,\n\t\t\t\t      NL80211_EXT_FEATURE_BSS_COLOR);\n\t\tieee80211_hw_set(ar->hw, DETECTS_COLOR_COLLISION);\n\t}\n\n\tar->hw->wiphy->cipher_suites = cipher_suites;\n\tar->hw->wiphy->n_cipher_suites = ARRAY_SIZE(cipher_suites);\n\n\tar->hw->wiphy->iftype_ext_capab = ath11k_iftypes_ext_capa;\n\tar->hw->wiphy->num_iftype_ext_capab =\n\t\tARRAY_SIZE(ath11k_iftypes_ext_capa);\n\n\tif (ar->supports_6ghz) {\n\t\twiphy_ext_feature_set(ar->hw->wiphy,\n\t\t\t\t      NL80211_EXT_FEATURE_FILS_DISCOVERY);\n\t\twiphy_ext_feature_set(ar->hw->wiphy,\n\t\t\t\t      NL80211_EXT_FEATURE_UNSOL_BCAST_PROBE_RESP);\n\t}\n\n\twiphy_ext_feature_set(ar->hw->wiphy,\n\t\t\t      NL80211_EXT_FEATURE_SET_SCAN_DWELL);\n\n\tif (test_bit(WMI_TLV_SERVICE_RTT, ar->ab->wmi_ab.svc_map))\n\t\twiphy_ext_feature_set(ar->hw->wiphy,\n\t\t\t\t      NL80211_EXT_FEATURE_ENABLE_FTM_RESPONDER);\n\n\tar->hw->wiphy->mbssid_max_interfaces = TARGET_NUM_VDEVS(ab);\n\tar->hw->wiphy->ema_max_profile_periodicity = TARGET_EMA_MAX_PROFILE_PERIOD;\n\n\tath11k_reg_init(ar);\n\n\tif (!test_bit(ATH11K_FLAG_RAW_MODE, &ab->dev_flags)) {\n\t\tar->hw->netdev_features = NETIF_F_HW_CSUM;\n\t\tieee80211_hw_set(ar->hw, SW_CRYPTO_CONTROL);\n\t\tieee80211_hw_set(ar->hw, SUPPORT_FAST_XMIT);\n\t}\n\n\tif (test_bit(WMI_TLV_SERVICE_BIOS_SAR_SUPPORT, ar->ab->wmi_ab.svc_map) &&\n\t    ab->hw_params.bios_sar_capa)\n\t\tar->hw->wiphy->sar_capa = ab->hw_params.bios_sar_capa;\n\n\tret = ieee80211_register_hw(ar->hw);\n\tif (ret) {\n\t\tath11k_err(ar->ab, \"ieee80211 registration failed: %d\\n\", ret);\n\t\tgoto err_free_if_combs;\n\t}\n\n\tif (!ab->hw_params.supports_monitor)\n\t\t \n\t\tar->hw->wiphy->interface_modes &= ~BIT(NL80211_IFTYPE_MONITOR);\n\n\t \n\tret = ath11k_regd_update(ar);\n\tif (ret) {\n\t\tath11k_err(ar->ab, \"ath11k regd update failed: %d\\n\", ret);\n\t\tgoto err_unregister_hw;\n\t}\n\n\tif (ab->hw_params.current_cc_support && ab->new_alpha2[0]) {\n\t\tstruct wmi_set_current_country_params set_current_param = {};\n\n\t\tmemcpy(&set_current_param.alpha2, ab->new_alpha2, 2);\n\t\tmemcpy(&ar->alpha2, ab->new_alpha2, 2);\n\t\tret = ath11k_wmi_send_set_current_country_cmd(ar, &set_current_param);\n\t\tif (ret)\n\t\t\tath11k_warn(ar->ab,\n\t\t\t\t    \"failed set cc code for mac register: %d\\n\", ret);\n\t}\n\n\tret = ath11k_debugfs_register(ar);\n\tif (ret) {\n\t\tath11k_err(ar->ab, \"debugfs registration failed: %d\\n\", ret);\n\t\tgoto err_unregister_hw;\n\t}\n\n\treturn 0;\n\nerr_unregister_hw:\n\tieee80211_unregister_hw(ar->hw);\n\nerr_free_if_combs:\n\tkfree(ar->hw->wiphy->iface_combinations[0].limits);\n\tkfree(ar->hw->wiphy->iface_combinations);\n\nerr_free_channels:\n\tkfree(ar->mac.sbands[NL80211_BAND_2GHZ].channels);\n\tkfree(ar->mac.sbands[NL80211_BAND_5GHZ].channels);\n\tkfree(ar->mac.sbands[NL80211_BAND_6GHZ].channels);\n\nerr:\n\tSET_IEEE80211_DEV(ar->hw, NULL);\n\treturn ret;\n}\n\nint ath11k_mac_register(struct ath11k_base *ab)\n{\n\tstruct ath11k *ar;\n\tstruct ath11k_pdev *pdev;\n\tint i;\n\tint ret;\n\tu8 mac_addr[ETH_ALEN] = {0};\n\n\tif (test_bit(ATH11K_FLAG_REGISTERED, &ab->dev_flags))\n\t\treturn 0;\n\n\t \n\tab->cc_freq_hz = IPQ8074_CC_FREQ_HERTZ;\n\tab->free_vdev_map = (1LL << (ab->num_radios * TARGET_NUM_VDEVS(ab))) - 1;\n\n\tret = ath11k_peer_rhash_tbl_init(ab);\n\tif (ret)\n\t\treturn ret;\n\n\tdevice_get_mac_address(ab->dev, mac_addr);\n\n\tfor (i = 0; i < ab->num_radios; i++) {\n\t\tpdev = &ab->pdevs[i];\n\t\tar = pdev->ar;\n\t\tif (ab->pdevs_macaddr_valid) {\n\t\t\tether_addr_copy(ar->mac_addr, pdev->mac_addr);\n\t\t} else {\n\t\t\tif (is_zero_ether_addr(mac_addr))\n\t\t\t\tether_addr_copy(ar->mac_addr, ab->mac_addr);\n\t\t\telse\n\t\t\t\tether_addr_copy(ar->mac_addr, mac_addr);\n\t\t\tar->mac_addr[4] += i;\n\t\t}\n\n\t\tidr_init(&ar->txmgmt_idr);\n\t\tspin_lock_init(&ar->txmgmt_idr_lock);\n\n\t\tret = __ath11k_mac_register(ar);\n\t\tif (ret)\n\t\t\tgoto err_cleanup;\n\n\t\tinit_waitqueue_head(&ar->txmgmt_empty_waitq);\n\t}\n\n\treturn 0;\n\nerr_cleanup:\n\tfor (i = i - 1; i >= 0; i--) {\n\t\tpdev = &ab->pdevs[i];\n\t\tar = pdev->ar;\n\t\t__ath11k_mac_unregister(ar);\n\t}\n\n\tath11k_peer_rhash_tbl_destroy(ab);\n\n\treturn ret;\n}\n\nint ath11k_mac_allocate(struct ath11k_base *ab)\n{\n\tstruct ieee80211_hw *hw;\n\tstruct ath11k *ar;\n\tstruct ath11k_pdev *pdev;\n\tint ret;\n\tint i;\n\n\tif (test_bit(ATH11K_FLAG_REGISTERED, &ab->dev_flags))\n\t\treturn 0;\n\n\tfor (i = 0; i < ab->num_radios; i++) {\n\t\tpdev = &ab->pdevs[i];\n\t\thw = ieee80211_alloc_hw(sizeof(struct ath11k), &ath11k_ops);\n\t\tif (!hw) {\n\t\t\tath11k_warn(ab, \"failed to allocate mac80211 hw device\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_free_mac;\n\t\t}\n\n\t\tar = hw->priv;\n\t\tar->hw = hw;\n\t\tar->ab = ab;\n\t\tar->pdev = pdev;\n\t\tar->pdev_idx = i;\n\t\tar->lmac_id = ath11k_hw_get_mac_from_pdev_id(&ab->hw_params, i);\n\n\t\tar->wmi = &ab->wmi_ab.wmi[i];\n\t\t \n\t\tath11k_wmi_pdev_attach(ab, i);\n\n\t\tar->cfg_tx_chainmask = pdev->cap.tx_chain_mask;\n\t\tar->cfg_rx_chainmask = pdev->cap.rx_chain_mask;\n\t\tar->num_tx_chains = get_num_chains(pdev->cap.tx_chain_mask);\n\t\tar->num_rx_chains = get_num_chains(pdev->cap.rx_chain_mask);\n\n\t\tpdev->ar = ar;\n\t\tspin_lock_init(&ar->data_lock);\n\t\tINIT_LIST_HEAD(&ar->arvifs);\n\t\tINIT_LIST_HEAD(&ar->ppdu_stats_info);\n\t\tmutex_init(&ar->conf_mutex);\n\t\tinit_completion(&ar->vdev_setup_done);\n\t\tinit_completion(&ar->vdev_delete_done);\n\t\tinit_completion(&ar->peer_assoc_done);\n\t\tinit_completion(&ar->peer_delete_done);\n\t\tinit_completion(&ar->install_key_done);\n\t\tinit_completion(&ar->bss_survey_done);\n\t\tinit_completion(&ar->scan.started);\n\t\tinit_completion(&ar->scan.completed);\n\t\tinit_completion(&ar->scan.on_channel);\n\t\tinit_completion(&ar->thermal.wmi_sync);\n\n\t\tINIT_DELAYED_WORK(&ar->scan.timeout, ath11k_scan_timeout_work);\n\t\tINIT_WORK(&ar->regd_update_work, ath11k_regd_update_work);\n\n\t\tINIT_WORK(&ar->wmi_mgmt_tx_work, ath11k_mgmt_over_wmi_tx_work);\n\t\tskb_queue_head_init(&ar->wmi_mgmt_tx_queue);\n\n\t\tclear_bit(ATH11K_FLAG_MONITOR_STARTED, &ar->monitor_flags);\n\n\t\tar->monitor_vdev_id = -1;\n\t\tclear_bit(ATH11K_FLAG_MONITOR_VDEV_CREATED, &ar->monitor_flags);\n\t\tar->vdev_id_11d_scan = ATH11K_11D_INVALID_VDEV_ID;\n\t\tinit_completion(&ar->completed_11d_scan);\n\n\t\tath11k_fw_stats_init(ar);\n\t}\n\n\treturn 0;\n\nerr_free_mac:\n\tath11k_mac_destroy(ab);\n\n\treturn ret;\n}\n\nvoid ath11k_mac_destroy(struct ath11k_base *ab)\n{\n\tstruct ath11k *ar;\n\tstruct ath11k_pdev *pdev;\n\tint i;\n\n\tfor (i = 0; i < ab->num_radios; i++) {\n\t\tpdev = &ab->pdevs[i];\n\t\tar = pdev->ar;\n\t\tif (!ar)\n\t\t\tcontinue;\n\n\t\tath11k_fw_stats_free(&ar->fw_stats);\n\t\tieee80211_free_hw(ar->hw);\n\t\tpdev->ar = NULL;\n\t}\n}\n\nint ath11k_mac_vif_set_keepalive(struct ath11k_vif *arvif,\n\t\t\t\t enum wmi_sta_keepalive_method method,\n\t\t\t\t u32 interval)\n{\n\tstruct ath11k *ar = arvif->ar;\n\tstruct wmi_sta_keepalive_arg arg = {};\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (arvif->vdev_type != WMI_VDEV_TYPE_STA)\n\t\treturn 0;\n\n\tif (!test_bit(WMI_TLV_SERVICE_STA_KEEP_ALIVE, ar->ab->wmi_ab.svc_map))\n\t\treturn 0;\n\n\targ.vdev_id = arvif->vdev_id;\n\targ.enabled = 1;\n\targ.method = method;\n\targ.interval = interval;\n\n\tret = ath11k_wmi_sta_keepalive(ar, &arg);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to set keepalive on vdev %i: %d\\n\",\n\t\t\t    arvif->vdev_id, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}