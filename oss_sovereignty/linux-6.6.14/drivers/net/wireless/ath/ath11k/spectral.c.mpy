{
  "module_name": "spectral.c",
  "hash_id": "945ca94adc56d2e88854a471457ba9c4a6bbfd18ca5c4ce0e12757a327ca023f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath11k/spectral.c",
  "human_readable_source": "\n \n\n#include <linux/relay.h>\n#include \"core.h\"\n#include \"debug.h\"\n\n#define ATH11K_SPECTRAL_NUM_RESP_PER_EVENT\t2\n#define ATH11K_SPECTRAL_EVENT_TIMEOUT_MS\t1\n\n#define ATH11K_SPECTRAL_DWORD_SIZE\t\t4\n#define ATH11K_SPECTRAL_MIN_BINS\t\t32\n#define ATH11K_SPECTRAL_MIN_IB_BINS\t\t(ATH11K_SPECTRAL_MIN_BINS >> 1)\n#define ATH11K_SPECTRAL_MAX_IB_BINS(x)\t((x)->hw_params.spectral.max_fft_bins >> 1)\n\n#define ATH11K_SPECTRAL_SCAN_COUNT_MAX\t\t4095\n\n \n#define ATH11K_SPECTRAL_TOTAL_CHANNEL\t\t41\n#define ATH11K_SPECTRAL_SAMPLES_PER_CHANNEL\t70\n#define ATH11K_SPECTRAL_PER_SAMPLE_SIZE(x)\t(sizeof(struct fft_sample_ath11k) + \\\n\t\t\t\t\t\t ATH11K_SPECTRAL_MAX_IB_BINS(x))\n#define ATH11K_SPECTRAL_TOTAL_SAMPLE\t\t(ATH11K_SPECTRAL_TOTAL_CHANNEL * \\\n\t\t\t\t\t\t ATH11K_SPECTRAL_SAMPLES_PER_CHANNEL)\n#define ATH11K_SPECTRAL_SUB_BUFF_SIZE(x)\tATH11K_SPECTRAL_PER_SAMPLE_SIZE(x)\n#define ATH11K_SPECTRAL_NUM_SUB_BUF\t\tATH11K_SPECTRAL_TOTAL_SAMPLE\n\n#define ATH11K_SPECTRAL_20MHZ\t\t\t20\n#define ATH11K_SPECTRAL_40MHZ\t\t\t40\n#define ATH11K_SPECTRAL_80MHZ\t\t\t80\n#define ATH11K_SPECTRAL_160MHZ\t\t\t160\n\n#define ATH11K_SPECTRAL_SIGNATURE\t\t0xFA\n\n#define ATH11K_SPECTRAL_TAG_RADAR_SUMMARY\t0x0\n#define ATH11K_SPECTRAL_TAG_RADAR_FFT\t\t0x1\n#define ATH11K_SPECTRAL_TAG_SCAN_SUMMARY\t0x2\n#define ATH11K_SPECTRAL_TAG_SCAN_SEARCH\t\t0x3\n\n#define SPECTRAL_TLV_HDR_LEN\t\t\t\tGENMASK(15, 0)\n#define SPECTRAL_TLV_HDR_TAG\t\t\t\tGENMASK(23, 16)\n#define SPECTRAL_TLV_HDR_SIGN\t\t\t\tGENMASK(31, 24)\n\n#define SPECTRAL_SUMMARY_INFO0_AGC_TOTAL_GAIN\t\tGENMASK(7, 0)\n#define SPECTRAL_SUMMARY_INFO0_OB_FLAG\t\t\tBIT(8)\n#define SPECTRAL_SUMMARY_INFO0_GRP_IDX\t\t\tGENMASK(16, 9)\n#define SPECTRAL_SUMMARY_INFO0_RECENT_RFSAT\t\tBIT(17)\n#define SPECTRAL_SUMMARY_INFO0_INBAND_PWR_DB\t\tGENMASK(27, 18)\n#define SPECTRAL_SUMMARY_INFO0_FALSE_SCAN\t\tBIT(28)\n#define SPECTRAL_SUMMARY_INFO0_DETECTOR_ID\t\tGENMASK(30, 29)\n#define SPECTRAL_SUMMARY_INFO0_PRI80\t\t\tBIT(31)\n\n#define SPECTRAL_SUMMARY_INFO2_PEAK_SIGNED_IDX\t\tGENMASK(11, 0)\n#define SPECTRAL_SUMMARY_INFO2_PEAK_MAGNITUDE\t\tGENMASK(21, 12)\n#define SPECTRAL_SUMMARY_INFO2_NARROWBAND_MASK\t\tGENMASK(29, 22)\n#define SPECTRAL_SUMMARY_INFO2_GAIN_CHANGE\t\tBIT(30)\n\nstruct spectral_tlv {\n\t__le32 timestamp;\n\t__le32 header;\n} __packed;\n\nstruct spectral_summary_fft_report {\n\t__le32 timestamp;\n\t__le32 tlv_header;\n\t__le32 info0;\n\t__le32 reserve0;\n\t__le32 info2;\n\t__le32 reserve1;\n} __packed;\n\nstruct ath11k_spectral_summary_report {\n\tstruct wmi_dma_buf_release_meta_data meta;\n\tu32 timestamp;\n\tu8 agc_total_gain;\n\tu8 grp_idx;\n\tu16 inb_pwr_db;\n\ts16 peak_idx;\n\tu16 peak_mag;\n\tu8 detector_id;\n\tbool out_of_band_flag;\n\tbool rf_saturation;\n\tbool primary80;\n\tbool gain_change;\n\tbool false_scan;\n};\n\n#define SPECTRAL_FFT_REPORT_INFO0_DETECTOR_ID\t\tGENMASK(1, 0)\n#define SPECTRAL_FFT_REPORT_INFO0_FFT_NUM\t\tGENMASK(4, 2)\n#define SPECTRAL_FFT_REPORT_INFO0_RADAR_CHECK\t\tGENMASK(16, 5)\n#define SPECTRAL_FFT_REPORT_INFO0_PEAK_SIGNED_IDX\tGENMASK(27, 17)\n#define SPECTRAL_FFT_REPORT_INFO0_CHAIN_IDX\t\tGENMASK(30, 28)\n\n#define SPECTRAL_FFT_REPORT_INFO1_BASE_PWR_DB\t\tGENMASK(8, 0)\n#define SPECTRAL_FFT_REPORT_INFO1_TOTAL_GAIN_DB\t\tGENMASK(16, 9)\n\n#define SPECTRAL_FFT_REPORT_INFO2_NUM_STRONG_BINS\tGENMASK(7, 0)\n#define SPECTRAL_FFT_REPORT_INFO2_PEAK_MAGNITUDE\tGENMASK(17, 8)\n#define SPECTRAL_FFT_REPORT_INFO2_AVG_PWR_DB\t\tGENMASK(24, 18)\n#define SPECTRAL_FFT_REPORT_INFO2_REL_PWR_DB\t\tGENMASK(31, 25)\n\nstruct spectral_search_fft_report {\n\t__le32 timestamp;\n\t__le32 tlv_header;\n\t__le32 info0;\n\t__le32 info1;\n\t__le32 info2;\n\t__le32 reserve0;\n\tu8 bins[];\n} __packed;\n\nstruct ath11k_spectral_search_report {\n\tu32 timestamp;\n\tu8 detector_id;\n\tu8 fft_count;\n\tu16 radar_check;\n\ts16 peak_idx;\n\tu8 chain_idx;\n\tu16 base_pwr_db;\n\tu8 total_gain_db;\n\tu8 strong_bin_count;\n\tu16 peak_mag;\n\tu8 avg_pwr_db;\n\tu8 rel_pwr_db;\n};\n\nstatic struct dentry *create_buf_file_handler(const char *filename,\n\t\t\t\t\t      struct dentry *parent,\n\t\t\t\t\t      umode_t mode,\n\t\t\t\t\t      struct rchan_buf *buf,\n\t\t\t\t\t      int *is_global)\n{\n\tstruct dentry *buf_file;\n\n\tbuf_file = debugfs_create_file(filename, mode, parent, buf,\n\t\t\t\t       &relay_file_operations);\n\t*is_global = 1;\n\treturn buf_file;\n}\n\nstatic int remove_buf_file_handler(struct dentry *dentry)\n{\n\tdebugfs_remove(dentry);\n\n\treturn 0;\n}\n\nstatic const struct rchan_callbacks rfs_scan_cb = {\n\t.create_buf_file = create_buf_file_handler,\n\t.remove_buf_file = remove_buf_file_handler,\n};\n\nstatic struct ath11k_vif *ath11k_spectral_get_vdev(struct ath11k *ar)\n{\n\tstruct ath11k_vif *arvif;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (list_empty(&ar->arvifs))\n\t\treturn NULL;\n\n\t \n\tlist_for_each_entry(arvif, &ar->arvifs, list)\n\t\tif (arvif->spectral_enabled)\n\t\t\treturn arvif;\n\n\t \n\treturn list_first_entry(&ar->arvifs, typeof(*arvif), list);\n}\n\nstatic int ath11k_spectral_scan_trigger(struct ath11k *ar)\n{\n\tstruct ath11k_vif *arvif;\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tarvif = ath11k_spectral_get_vdev(ar);\n\tif (!arvif)\n\t\treturn -ENODEV;\n\n\tif (ar->spectral.mode == ATH11K_SPECTRAL_DISABLED)\n\t\treturn 0;\n\n\tar->spectral.is_primary = true;\n\n\tret = ath11k_wmi_vdev_spectral_enable(ar, arvif->vdev_id,\n\t\t\t\t\t      ATH11K_WMI_SPECTRAL_TRIGGER_CMD_CLEAR,\n\t\t\t\t\t      ATH11K_WMI_SPECTRAL_ENABLE_CMD_ENABLE);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ath11k_wmi_vdev_spectral_enable(ar, arvif->vdev_id,\n\t\t\t\t\t      ATH11K_WMI_SPECTRAL_TRIGGER_CMD_TRIGGER,\n\t\t\t\t\t      ATH11K_WMI_SPECTRAL_ENABLE_CMD_ENABLE);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int ath11k_spectral_scan_config(struct ath11k *ar,\n\t\t\t\t       enum ath11k_spectral_mode mode)\n{\n\tstruct ath11k_wmi_vdev_spectral_conf_param param = { 0 };\n\tstruct ath11k_vif *arvif;\n\tint ret, count;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tarvif = ath11k_spectral_get_vdev(ar);\n\tif (!arvif)\n\t\treturn -ENODEV;\n\n\tarvif->spectral_enabled = (mode != ATH11K_SPECTRAL_DISABLED);\n\n\tspin_lock_bh(&ar->spectral.lock);\n\tar->spectral.mode = mode;\n\tspin_unlock_bh(&ar->spectral.lock);\n\n\tret = ath11k_wmi_vdev_spectral_enable(ar, arvif->vdev_id,\n\t\t\t\t\t      ATH11K_WMI_SPECTRAL_TRIGGER_CMD_CLEAR,\n\t\t\t\t\t      ATH11K_WMI_SPECTRAL_ENABLE_CMD_DISABLE);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to enable spectral scan: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (mode == ATH11K_SPECTRAL_DISABLED)\n\t\treturn 0;\n\n\tif (mode == ATH11K_SPECTRAL_BACKGROUND)\n\t\tcount = ATH11K_WMI_SPECTRAL_COUNT_DEFAULT;\n\telse\n\t\tcount = max_t(u16, 1, ar->spectral.count);\n\n\tparam.vdev_id = arvif->vdev_id;\n\tparam.scan_count = count;\n\tparam.scan_fft_size = ar->spectral.fft_size;\n\tparam.scan_period = ATH11K_WMI_SPECTRAL_PERIOD_DEFAULT;\n\tparam.scan_priority = ATH11K_WMI_SPECTRAL_PRIORITY_DEFAULT;\n\tparam.scan_gc_ena = ATH11K_WMI_SPECTRAL_GC_ENA_DEFAULT;\n\tparam.scan_restart_ena = ATH11K_WMI_SPECTRAL_RESTART_ENA_DEFAULT;\n\tparam.scan_noise_floor_ref = ATH11K_WMI_SPECTRAL_NOISE_FLOOR_REF_DEFAULT;\n\tparam.scan_init_delay = ATH11K_WMI_SPECTRAL_INIT_DELAY_DEFAULT;\n\tparam.scan_nb_tone_thr = ATH11K_WMI_SPECTRAL_NB_TONE_THR_DEFAULT;\n\tparam.scan_str_bin_thr = ATH11K_WMI_SPECTRAL_STR_BIN_THR_DEFAULT;\n\tparam.scan_wb_rpt_mode = ATH11K_WMI_SPECTRAL_WB_RPT_MODE_DEFAULT;\n\tparam.scan_rssi_rpt_mode = ATH11K_WMI_SPECTRAL_RSSI_RPT_MODE_DEFAULT;\n\tparam.scan_rssi_thr = ATH11K_WMI_SPECTRAL_RSSI_THR_DEFAULT;\n\tparam.scan_pwr_format = ATH11K_WMI_SPECTRAL_PWR_FORMAT_DEFAULT;\n\tparam.scan_rpt_mode = ATH11K_WMI_SPECTRAL_RPT_MODE_DEFAULT;\n\tparam.scan_bin_scale = ATH11K_WMI_SPECTRAL_BIN_SCALE_DEFAULT;\n\tparam.scan_dbm_adj = ATH11K_WMI_SPECTRAL_DBM_ADJ_DEFAULT;\n\tparam.scan_chn_mask = ATH11K_WMI_SPECTRAL_CHN_MASK_DEFAULT;\n\n\tret = ath11k_wmi_vdev_spectral_conf(ar, &param);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to configure spectral scan: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic ssize_t ath11k_read_file_spec_scan_ctl(struct file *file,\n\t\t\t\t\t      char __user *user_buf,\n\t\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct ath11k *ar = file->private_data;\n\tchar *mode = \"\";\n\tsize_t len;\n\tenum ath11k_spectral_mode spectral_mode;\n\n\tmutex_lock(&ar->conf_mutex);\n\tspectral_mode = ar->spectral.mode;\n\tmutex_unlock(&ar->conf_mutex);\n\n\tswitch (spectral_mode) {\n\tcase ATH11K_SPECTRAL_DISABLED:\n\t\tmode = \"disable\";\n\t\tbreak;\n\tcase ATH11K_SPECTRAL_BACKGROUND:\n\t\tmode = \"background\";\n\t\tbreak;\n\tcase ATH11K_SPECTRAL_MANUAL:\n\t\tmode = \"manual\";\n\t\tbreak;\n\t}\n\n\tlen = strlen(mode);\n\treturn simple_read_from_buffer(user_buf, count, ppos, mode, len);\n}\n\nstatic ssize_t ath11k_write_file_spec_scan_ctl(struct file *file,\n\t\t\t\t\t       const char __user *user_buf,\n\t\t\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct ath11k *ar = file->private_data;\n\tchar buf[32];\n\tssize_t len;\n\tint ret;\n\n\tlen = min(count, sizeof(buf) - 1);\n\tif (copy_from_user(buf, user_buf, len))\n\t\treturn -EFAULT;\n\n\tbuf[len] = '\\0';\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (strncmp(\"trigger\", buf, 7) == 0) {\n\t\tif (ar->spectral.mode == ATH11K_SPECTRAL_MANUAL ||\n\t\t    ar->spectral.mode == ATH11K_SPECTRAL_BACKGROUND) {\n\t\t\t \n\t\t\tret = ath11k_spectral_scan_config(ar, ar->spectral.mode);\n\t\t\tif (ret) {\n\t\t\t\tath11k_warn(ar->ab, \"failed to reconfigure spectral scan: %d\\n\",\n\t\t\t\t\t    ret);\n\t\t\t\tgoto unlock;\n\t\t\t}\n\n\t\t\tret = ath11k_spectral_scan_trigger(ar);\n\t\t\tif (ret) {\n\t\t\t\tath11k_warn(ar->ab, \"failed to trigger spectral scan: %d\\n\",\n\t\t\t\t\t    ret);\n\t\t\t}\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else if (strncmp(\"background\", buf, 10) == 0) {\n\t\tret = ath11k_spectral_scan_config(ar, ATH11K_SPECTRAL_BACKGROUND);\n\t} else if (strncmp(\"manual\", buf, 6) == 0) {\n\t\tret = ath11k_spectral_scan_config(ar, ATH11K_SPECTRAL_MANUAL);\n\t} else if (strncmp(\"disable\", buf, 7) == 0) {\n\t\tret = ath11k_spectral_scan_config(ar, ATH11K_SPECTRAL_DISABLED);\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\nunlock:\n\tmutex_unlock(&ar->conf_mutex);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic const struct file_operations fops_scan_ctl = {\n\t.read = ath11k_read_file_spec_scan_ctl,\n\t.write = ath11k_write_file_spec_scan_ctl,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t ath11k_read_file_spectral_count(struct file *file,\n\t\t\t\t\t       char __user *user_buf,\n\t\t\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct ath11k *ar = file->private_data;\n\tchar buf[32];\n\tsize_t len;\n\tu16 spectral_count;\n\n\tmutex_lock(&ar->conf_mutex);\n\tspectral_count = ar->spectral.count;\n\tmutex_unlock(&ar->conf_mutex);\n\n\tlen = sprintf(buf, \"%d\\n\", spectral_count);\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic ssize_t ath11k_write_file_spectral_count(struct file *file,\n\t\t\t\t\t\tconst char __user *user_buf,\n\t\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct ath11k *ar = file->private_data;\n\tunsigned long val;\n\tchar buf[32];\n\tssize_t len;\n\n\tlen = min(count, sizeof(buf) - 1);\n\tif (copy_from_user(buf, user_buf, len))\n\t\treturn -EFAULT;\n\n\tbuf[len] = '\\0';\n\tif (kstrtoul(buf, 0, &val))\n\t\treturn -EINVAL;\n\n\tif (val > ATH11K_SPECTRAL_SCAN_COUNT_MAX)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ar->conf_mutex);\n\tar->spectral.count = val;\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn count;\n}\n\nstatic const struct file_operations fops_scan_count = {\n\t.read = ath11k_read_file_spectral_count,\n\t.write = ath11k_write_file_spectral_count,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t ath11k_read_file_spectral_bins(struct file *file,\n\t\t\t\t\t      char __user *user_buf,\n\t\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct ath11k *ar = file->private_data;\n\tchar buf[32];\n\tunsigned int bins, fft_size;\n\tsize_t len;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tfft_size = ar->spectral.fft_size;\n\tbins = 1 << fft_size;\n\n\tmutex_unlock(&ar->conf_mutex);\n\n\tlen = sprintf(buf, \"%d\\n\", bins);\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic ssize_t ath11k_write_file_spectral_bins(struct file *file,\n\t\t\t\t\t       const char __user *user_buf,\n\t\t\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct ath11k *ar = file->private_data;\n\tunsigned long val;\n\tchar buf[32];\n\tssize_t len;\n\n\tlen = min(count, sizeof(buf) - 1);\n\tif (copy_from_user(buf, user_buf, len))\n\t\treturn -EFAULT;\n\n\tbuf[len] = '\\0';\n\tif (kstrtoul(buf, 0, &val))\n\t\treturn -EINVAL;\n\n\tif (val < ATH11K_SPECTRAL_MIN_BINS ||\n\t    val > ar->ab->hw_params.spectral.max_fft_bins)\n\t\treturn -EINVAL;\n\n\tif (!is_power_of_2(val))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ar->conf_mutex);\n\tar->spectral.fft_size = ilog2(val);\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn count;\n}\n\nstatic const struct file_operations fops_scan_bins = {\n\t.read = ath11k_read_file_spectral_bins,\n\t.write = ath11k_write_file_spectral_bins,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic int ath11k_spectral_pull_summary(struct ath11k *ar,\n\t\t\t\t\tstruct wmi_dma_buf_release_meta_data *meta,\n\t\t\t\t\tstruct spectral_summary_fft_report *summary,\n\t\t\t\t\tstruct ath11k_spectral_summary_report *report)\n{\n\treport->timestamp = __le32_to_cpu(summary->timestamp);\n\treport->agc_total_gain = FIELD_GET(SPECTRAL_SUMMARY_INFO0_AGC_TOTAL_GAIN,\n\t\t\t\t\t   __le32_to_cpu(summary->info0));\n\treport->out_of_band_flag = FIELD_GET(SPECTRAL_SUMMARY_INFO0_OB_FLAG,\n\t\t\t\t\t     __le32_to_cpu(summary->info0));\n\treport->grp_idx = FIELD_GET(SPECTRAL_SUMMARY_INFO0_GRP_IDX,\n\t\t\t\t    __le32_to_cpu(summary->info0));\n\treport->rf_saturation = FIELD_GET(SPECTRAL_SUMMARY_INFO0_RECENT_RFSAT,\n\t\t\t\t\t  __le32_to_cpu(summary->info0));\n\treport->inb_pwr_db = FIELD_GET(SPECTRAL_SUMMARY_INFO0_INBAND_PWR_DB,\n\t\t\t\t       __le32_to_cpu(summary->info0));\n\treport->false_scan = FIELD_GET(SPECTRAL_SUMMARY_INFO0_FALSE_SCAN,\n\t\t\t\t       __le32_to_cpu(summary->info0));\n\treport->detector_id = FIELD_GET(SPECTRAL_SUMMARY_INFO0_DETECTOR_ID,\n\t\t\t\t\t__le32_to_cpu(summary->info0));\n\treport->primary80 = FIELD_GET(SPECTRAL_SUMMARY_INFO0_PRI80,\n\t\t\t\t      __le32_to_cpu(summary->info0));\n\treport->peak_idx = FIELD_GET(SPECTRAL_SUMMARY_INFO2_PEAK_SIGNED_IDX,\n\t\t\t\t     __le32_to_cpu(summary->info2));\n\treport->peak_mag = FIELD_GET(SPECTRAL_SUMMARY_INFO2_PEAK_MAGNITUDE,\n\t\t\t\t     __le32_to_cpu(summary->info2));\n\treport->gain_change = FIELD_GET(SPECTRAL_SUMMARY_INFO2_GAIN_CHANGE,\n\t\t\t\t\t__le32_to_cpu(summary->info2));\n\n\tmemcpy(&report->meta, meta, sizeof(*meta));\n\n\treturn 0;\n}\n\nstatic int ath11k_spectral_pull_search(struct ath11k *ar,\n\t\t\t\t       struct spectral_search_fft_report *search,\n\t\t\t\t       struct ath11k_spectral_search_report *report)\n{\n\treport->timestamp = __le32_to_cpu(search->timestamp);\n\treport->detector_id = FIELD_GET(SPECTRAL_FFT_REPORT_INFO0_DETECTOR_ID,\n\t\t\t\t\t__le32_to_cpu(search->info0));\n\treport->fft_count = FIELD_GET(SPECTRAL_FFT_REPORT_INFO0_FFT_NUM,\n\t\t\t\t      __le32_to_cpu(search->info0));\n\treport->radar_check = FIELD_GET(SPECTRAL_FFT_REPORT_INFO0_RADAR_CHECK,\n\t\t\t\t\t__le32_to_cpu(search->info0));\n\treport->peak_idx = FIELD_GET(SPECTRAL_FFT_REPORT_INFO0_PEAK_SIGNED_IDX,\n\t\t\t\t     __le32_to_cpu(search->info0));\n\treport->chain_idx = FIELD_GET(SPECTRAL_FFT_REPORT_INFO0_CHAIN_IDX,\n\t\t\t\t      __le32_to_cpu(search->info0));\n\treport->base_pwr_db = FIELD_GET(SPECTRAL_FFT_REPORT_INFO1_BASE_PWR_DB,\n\t\t\t\t\t__le32_to_cpu(search->info1));\n\treport->total_gain_db = FIELD_GET(SPECTRAL_FFT_REPORT_INFO1_TOTAL_GAIN_DB,\n\t\t\t\t\t  __le32_to_cpu(search->info1));\n\treport->strong_bin_count = FIELD_GET(SPECTRAL_FFT_REPORT_INFO2_NUM_STRONG_BINS,\n\t\t\t\t\t     __le32_to_cpu(search->info2));\n\treport->peak_mag = FIELD_GET(SPECTRAL_FFT_REPORT_INFO2_PEAK_MAGNITUDE,\n\t\t\t\t     __le32_to_cpu(search->info2));\n\treport->avg_pwr_db = FIELD_GET(SPECTRAL_FFT_REPORT_INFO2_AVG_PWR_DB,\n\t\t\t\t       __le32_to_cpu(search->info2));\n\treport->rel_pwr_db = FIELD_GET(SPECTRAL_FFT_REPORT_INFO2_REL_PWR_DB,\n\t\t\t\t       __le32_to_cpu(search->info2));\n\n\treturn 0;\n}\n\nstatic u8 ath11k_spectral_get_max_exp(s8 max_index, u8 max_magnitude,\n\t\t\t\t      int bin_len, u8 *bins)\n{\n\tint dc_pos;\n\tu8 max_exp;\n\n\tdc_pos = bin_len / 2;\n\n\t \n\tif (dc_pos <= max_index || -dc_pos >= max_index)\n\t\treturn 0;\n\n\tfor (max_exp = 0; max_exp < 8; max_exp++) {\n\t\tif (bins[dc_pos + max_index] == (max_magnitude >> max_exp))\n\t\t\tbreak;\n\t}\n\n\t \n\tif (bins[dc_pos + max_index] != (max_magnitude >> max_exp))\n\t\treturn 0;\n\n\treturn max_exp;\n}\n\nstatic void ath11k_spectral_parse_fft(u8 *outbins, u8 *inbins, int num_bins, u8 fft_sz)\n{\n\tint i, j;\n\n\ti = 0;\n\tj = 0;\n\twhile (i < num_bins) {\n\t\toutbins[i] = inbins[j];\n\t\ti++;\n\t\tj += fft_sz;\n\t}\n}\n\nstatic\nint ath11k_spectral_process_fft(struct ath11k *ar,\n\t\t\t\tstruct ath11k_spectral_summary_report *summary,\n\t\t\t\tvoid *data,\n\t\t\t\tstruct fft_sample_ath11k *fft_sample,\n\t\t\t\tu32 data_len)\n{\n\tstruct ath11k_base *ab = ar->ab;\n\tstruct spectral_search_fft_report *fft_report = data;\n\tstruct ath11k_spectral_search_report search;\n\tstruct spectral_tlv *tlv;\n\tint tlv_len, bin_len, num_bins;\n\tu16 length, freq;\n\tu8 chan_width_mhz, bin_sz;\n\tint ret;\n\tu32 check_length;\n\tbool fragment_sample = false;\n\n\tlockdep_assert_held(&ar->spectral.lock);\n\n\tif (!ab->hw_params.spectral.fft_sz) {\n\t\tath11k_warn(ab, \"invalid bin size type for hw rev %d\\n\",\n\t\t\t    ab->hw_rev);\n\t\treturn -EINVAL;\n\t}\n\n\ttlv = (struct spectral_tlv *)data;\n\ttlv_len = FIELD_GET(SPECTRAL_TLV_HDR_LEN, __le32_to_cpu(tlv->header));\n\t \n\ttlv_len *= ATH11K_SPECTRAL_DWORD_SIZE;\n\tbin_len = tlv_len - ab->hw_params.spectral.fft_hdr_len;\n\n\tif (data_len < (bin_len + sizeof(*fft_report))) {\n\t\tath11k_warn(ab, \"mismatch in expected bin len %d and data len %d\\n\",\n\t\t\t    bin_len, data_len);\n\t\treturn -EINVAL;\n\t}\n\n\tbin_sz = ab->hw_params.spectral.fft_sz + ab->hw_params.spectral.fft_pad_sz;\n\tnum_bins = bin_len / bin_sz;\n\t \n\tnum_bins >>= 1;\n\n\tif (num_bins < ATH11K_SPECTRAL_MIN_IB_BINS ||\n\t    num_bins > ATH11K_SPECTRAL_MAX_IB_BINS(ab) ||\n\t    !is_power_of_2(num_bins)) {\n\t\tath11k_warn(ab, \"Invalid num of bins %d\\n\", num_bins);\n\t\treturn -EINVAL;\n\t}\n\n\tcheck_length = sizeof(*fft_report) + (num_bins * ab->hw_params.spectral.fft_sz);\n\tret = ath11k_dbring_validate_buffer(ar, data, check_length);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"found magic value in fft data, dropping\\n\");\n\t\treturn ret;\n\t}\n\n\tret = ath11k_spectral_pull_search(ar, data, &search);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to pull search report %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tchan_width_mhz = summary->meta.ch_width;\n\n\tswitch (chan_width_mhz) {\n\tcase ATH11K_SPECTRAL_20MHZ:\n\tcase ATH11K_SPECTRAL_40MHZ:\n\tcase ATH11K_SPECTRAL_80MHZ:\n\t\tfft_sample->chan_width_mhz = chan_width_mhz;\n\t\tbreak;\n\tcase ATH11K_SPECTRAL_160MHZ:\n\t\tif (ab->hw_params.spectral.fragment_160mhz) {\n\t\t\tchan_width_mhz /= 2;\n\t\t\tfragment_sample = true;\n\t\t}\n\t\tfft_sample->chan_width_mhz = chan_width_mhz;\n\t\tbreak;\n\tdefault:\n\t\tath11k_warn(ab, \"invalid channel width %d\\n\", chan_width_mhz);\n\t\treturn -EINVAL;\n\t}\n\n\tlength = sizeof(*fft_sample) - sizeof(struct fft_sample_tlv) + num_bins;\n\tfft_sample->tlv.type = ATH_FFT_SAMPLE_ATH11K;\n\tfft_sample->tlv.length = __cpu_to_be16(length);\n\n\tfft_sample->tsf = __cpu_to_be32(search.timestamp);\n\tfft_sample->max_magnitude = __cpu_to_be16(search.peak_mag);\n\tfft_sample->max_index = FIELD_GET(SPECTRAL_FFT_REPORT_INFO0_PEAK_SIGNED_IDX,\n\t\t\t\t\t  __le32_to_cpu(fft_report->info0));\n\n\tsummary->inb_pwr_db >>= 1;\n\tfft_sample->rssi = __cpu_to_be16(summary->inb_pwr_db);\n\tfft_sample->noise = __cpu_to_be32(summary->meta.noise_floor[search.chain_idx]);\n\n\tfreq = summary->meta.freq1;\n\tfft_sample->freq1 = __cpu_to_be16(freq);\n\n\tfreq = summary->meta.freq2;\n\tfft_sample->freq2 = __cpu_to_be16(freq);\n\n\t \n\tif (fragment_sample && freq) {\n\t\tif (!ar->spectral.is_primary)\n\t\t\tfft_sample->freq1 = cpu_to_be16(freq);\n\n\t\t \n\t\tar->spectral.is_primary = !ar->spectral.is_primary;\n\t}\n\n\tath11k_spectral_parse_fft(fft_sample->data, fft_report->bins, num_bins,\n\t\t\t\t  ab->hw_params.spectral.fft_sz);\n\n\tfft_sample->max_exp = ath11k_spectral_get_max_exp(fft_sample->max_index,\n\t\t\t\t\t\t\t  search.peak_mag,\n\t\t\t\t\t\t\t  num_bins,\n\t\t\t\t\t\t\t  fft_sample->data);\n\n\tif (ar->spectral.rfs_scan)\n\t\trelay_write(ar->spectral.rfs_scan, fft_sample,\n\t\t\t    length + sizeof(struct fft_sample_tlv));\n\n\treturn 0;\n}\n\nstatic int ath11k_spectral_process_data(struct ath11k *ar,\n\t\t\t\t\tstruct ath11k_dbring_data *param)\n{\n\tstruct ath11k_base *ab = ar->ab;\n\tstruct spectral_tlv *tlv;\n\tstruct spectral_summary_fft_report *summary = NULL;\n\tstruct ath11k_spectral_summary_report summ_rpt;\n\tstruct fft_sample_ath11k *fft_sample = NULL;\n\tu8 *data;\n\tu32 data_len, i;\n\tu8 sign, tag;\n\tint tlv_len, sample_sz;\n\tint ret;\n\tbool quit = false;\n\n\tspin_lock_bh(&ar->spectral.lock);\n\n\tif (!ar->spectral.enabled) {\n\t\tret = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tsample_sz = sizeof(*fft_sample) + ATH11K_SPECTRAL_MAX_IB_BINS(ab);\n\tfft_sample = kmalloc(sample_sz, GFP_ATOMIC);\n\tif (!fft_sample) {\n\t\tret = -ENOBUFS;\n\t\tgoto unlock;\n\t}\n\n\tdata = param->data;\n\tdata_len = param->data_sz;\n\ti = 0;\n\twhile (!quit && (i < data_len)) {\n\t\tif ((i + sizeof(*tlv)) > data_len) {\n\t\t\tath11k_warn(ab, \"failed to parse spectral tlv hdr at bytes %d\\n\",\n\t\t\t\t    i);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\ttlv = (struct spectral_tlv *)&data[i];\n\t\tsign = FIELD_GET(SPECTRAL_TLV_HDR_SIGN,\n\t\t\t\t __le32_to_cpu(tlv->header));\n\t\tif (sign != ATH11K_SPECTRAL_SIGNATURE) {\n\t\t\tath11k_warn(ab, \"Invalid sign 0x%x at bytes %d\\n\",\n\t\t\t\t    sign, i);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\ttlv_len = FIELD_GET(SPECTRAL_TLV_HDR_LEN,\n\t\t\t\t    __le32_to_cpu(tlv->header));\n\t\t \n\t\ttlv_len *= ATH11K_SPECTRAL_DWORD_SIZE;\n\t\tif ((i + sizeof(*tlv) + tlv_len) > data_len) {\n\t\t\tath11k_warn(ab, \"failed to parse spectral tlv payload at bytes %d tlv_len:%d data_len:%d\\n\",\n\t\t\t\t    i, tlv_len, data_len);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\ttag = FIELD_GET(SPECTRAL_TLV_HDR_TAG,\n\t\t\t\t__le32_to_cpu(tlv->header));\n\t\tswitch (tag) {\n\t\tcase ATH11K_SPECTRAL_TAG_SCAN_SUMMARY:\n\t\t\t \n\t\t\ttlv_len = sizeof(*summary) - sizeof(*tlv) +\n\t\t\t\t  ab->hw_params.spectral.summary_pad_sz;\n\n\t\t\tif (tlv_len < (sizeof(*summary) - sizeof(*tlv))) {\n\t\t\t\tath11k_warn(ab, \"failed to parse spectral summary at bytes %d tlv_len:%d\\n\",\n\t\t\t\t\t    i, tlv_len);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tret = ath11k_dbring_validate_buffer(ar, data, tlv_len);\n\t\t\tif (ret) {\n\t\t\t\tath11k_warn(ar->ab, \"found magic value in spectral summary, dropping\\n\");\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tsummary = (struct spectral_summary_fft_report *)tlv;\n\t\t\tath11k_spectral_pull_summary(ar, &param->meta,\n\t\t\t\t\t\t     summary, &summ_rpt);\n\t\t\tbreak;\n\t\tcase ATH11K_SPECTRAL_TAG_SCAN_SEARCH:\n\t\t\tif (tlv_len < (sizeof(struct spectral_search_fft_report) -\n\t\t\t\t       sizeof(*tlv))) {\n\t\t\t\tath11k_warn(ab, \"failed to parse spectral search fft at bytes %d\\n\",\n\t\t\t\t\t    i);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tmemset(fft_sample, 0, sample_sz);\n\t\t\tret = ath11k_spectral_process_fft(ar, &summ_rpt, tlv,\n\t\t\t\t\t\t\t  fft_sample,\n\t\t\t\t\t\t\t  data_len - i);\n\t\t\tif (ret) {\n\t\t\t\tath11k_warn(ab, \"failed to process spectral fft at bytes %d\\n\",\n\t\t\t\t\t    i);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tquit = true;\n\t\t\tbreak;\n\t\t}\n\n\t\ti += sizeof(*tlv) + tlv_len;\n\t}\n\n\tret = 0;\n\nerr:\n\tkfree(fft_sample);\nunlock:\n\tspin_unlock_bh(&ar->spectral.lock);\n\treturn ret;\n}\n\nstatic int ath11k_spectral_ring_alloc(struct ath11k *ar,\n\t\t\t\t      struct ath11k_dbring_cap *db_cap)\n{\n\tstruct ath11k_spectral *sp = &ar->spectral;\n\tint ret;\n\n\tret = ath11k_dbring_srng_setup(ar, &sp->rx_ring,\n\t\t\t\t       0, db_cap->min_elem);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to setup db ring\\n\");\n\t\treturn ret;\n\t}\n\n\tath11k_dbring_set_cfg(ar, &sp->rx_ring,\n\t\t\t      ATH11K_SPECTRAL_NUM_RESP_PER_EVENT,\n\t\t\t      ATH11K_SPECTRAL_EVENT_TIMEOUT_MS,\n\t\t\t      ath11k_spectral_process_data);\n\n\tret = ath11k_dbring_buf_setup(ar, &sp->rx_ring, db_cap);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to setup db ring buffer\\n\");\n\t\tgoto srng_cleanup;\n\t}\n\n\tret = ath11k_dbring_wmi_cfg_setup(ar, &sp->rx_ring,\n\t\t\t\t\t  WMI_DIRECT_BUF_SPECTRAL);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to setup db ring cfg\\n\");\n\t\tgoto buffer_cleanup;\n\t}\n\n\treturn 0;\n\nbuffer_cleanup:\n\tath11k_dbring_buf_cleanup(ar, &sp->rx_ring);\nsrng_cleanup:\n\tath11k_dbring_srng_cleanup(ar, &sp->rx_ring);\n\treturn ret;\n}\n\nstatic inline void ath11k_spectral_ring_free(struct ath11k *ar)\n{\n\tstruct ath11k_spectral *sp = &ar->spectral;\n\n\tath11k_dbring_srng_cleanup(ar, &sp->rx_ring);\n\tath11k_dbring_buf_cleanup(ar, &sp->rx_ring);\n}\n\nstatic inline void ath11k_spectral_debug_unregister(struct ath11k *ar)\n{\n\tdebugfs_remove(ar->spectral.scan_bins);\n\tar->spectral.scan_bins = NULL;\n\n\tdebugfs_remove(ar->spectral.scan_count);\n\tar->spectral.scan_count = NULL;\n\n\tdebugfs_remove(ar->spectral.scan_ctl);\n\tar->spectral.scan_ctl = NULL;\n\n\tif (ar->spectral.rfs_scan) {\n\t\trelay_close(ar->spectral.rfs_scan);\n\t\tar->spectral.rfs_scan = NULL;\n\t}\n}\n\nint ath11k_spectral_vif_stop(struct ath11k_vif *arvif)\n{\n\tif (!arvif->spectral_enabled)\n\t\treturn 0;\n\n\treturn ath11k_spectral_scan_config(arvif->ar, ATH11K_SPECTRAL_DISABLED);\n}\n\nvoid ath11k_spectral_reset_buffer(struct ath11k *ar)\n{\n\tif (!ar->spectral.enabled)\n\t\treturn;\n\n\tif (ar->spectral.rfs_scan)\n\t\trelay_reset(ar->spectral.rfs_scan);\n}\n\nvoid ath11k_spectral_deinit(struct ath11k_base *ab)\n{\n\tstruct ath11k *ar;\n\tstruct ath11k_spectral *sp;\n\tint i;\n\n\tfor (i = 0; i <  ab->num_radios; i++) {\n\t\tar = ab->pdevs[i].ar;\n\t\tsp = &ar->spectral;\n\n\t\tif (!sp->enabled)\n\t\t\tcontinue;\n\n\t\tmutex_lock(&ar->conf_mutex);\n\t\tath11k_spectral_scan_config(ar, ATH11K_SPECTRAL_DISABLED);\n\t\tmutex_unlock(&ar->conf_mutex);\n\n\t\tspin_lock_bh(&sp->lock);\n\t\tsp->enabled = false;\n\t\tspin_unlock_bh(&sp->lock);\n\n\t\tath11k_spectral_debug_unregister(ar);\n\t\tath11k_spectral_ring_free(ar);\n\t}\n}\n\nstatic inline int ath11k_spectral_debug_register(struct ath11k *ar)\n{\n\tint ret;\n\n\tar->spectral.rfs_scan = relay_open(\"spectral_scan\",\n\t\t\t\t\t   ar->debug.debugfs_pdev,\n\t\t\t\t\t   ATH11K_SPECTRAL_SUB_BUFF_SIZE(ar->ab),\n\t\t\t\t\t   ATH11K_SPECTRAL_NUM_SUB_BUF,\n\t\t\t\t\t   &rfs_scan_cb, NULL);\n\tif (!ar->spectral.rfs_scan) {\n\t\tath11k_warn(ar->ab, \"failed to open relay in pdev %d\\n\",\n\t\t\t    ar->pdev_idx);\n\t\treturn -EINVAL;\n\t}\n\n\tar->spectral.scan_ctl = debugfs_create_file(\"spectral_scan_ctl\",\n\t\t\t\t\t\t    0600,\n\t\t\t\t\t\t    ar->debug.debugfs_pdev, ar,\n\t\t\t\t\t\t    &fops_scan_ctl);\n\tif (!ar->spectral.scan_ctl) {\n\t\tath11k_warn(ar->ab, \"failed to open debugfs in pdev %d\\n\",\n\t\t\t    ar->pdev_idx);\n\t\tret = -EINVAL;\n\t\tgoto debug_unregister;\n\t}\n\n\tar->spectral.scan_count = debugfs_create_file(\"spectral_count\",\n\t\t\t\t\t\t      0600,\n\t\t\t\t\t\t      ar->debug.debugfs_pdev, ar,\n\t\t\t\t\t\t      &fops_scan_count);\n\tif (!ar->spectral.scan_count) {\n\t\tath11k_warn(ar->ab, \"failed to open debugfs in pdev %d\\n\",\n\t\t\t    ar->pdev_idx);\n\t\tret = -EINVAL;\n\t\tgoto debug_unregister;\n\t}\n\n\tar->spectral.scan_bins = debugfs_create_file(\"spectral_bins\",\n\t\t\t\t\t\t     0600,\n\t\t\t\t\t\t     ar->debug.debugfs_pdev, ar,\n\t\t\t\t\t\t     &fops_scan_bins);\n\tif (!ar->spectral.scan_bins) {\n\t\tath11k_warn(ar->ab, \"failed to open debugfs in pdev %d\\n\",\n\t\t\t    ar->pdev_idx);\n\t\tret = -EINVAL;\n\t\tgoto debug_unregister;\n\t}\n\n\treturn 0;\n\ndebug_unregister:\n\tath11k_spectral_debug_unregister(ar);\n\treturn ret;\n}\n\nint ath11k_spectral_init(struct ath11k_base *ab)\n{\n\tstruct ath11k *ar;\n\tstruct ath11k_spectral *sp;\n\tstruct ath11k_dbring_cap db_cap;\n\tint ret;\n\tint i;\n\n\tif (!test_bit(WMI_TLV_SERVICE_FREQINFO_IN_METADATA,\n\t\t      ab->wmi_ab.svc_map))\n\t\treturn 0;\n\n\tif (!ab->hw_params.spectral.fft_sz)\n\t\treturn 0;\n\n\tfor (i = 0; i < ab->num_radios; i++) {\n\t\tar = ab->pdevs[i].ar;\n\t\tsp = &ar->spectral;\n\n\t\tret = ath11k_dbring_get_cap(ar->ab, ar->pdev_idx,\n\t\t\t\t\t    WMI_DIRECT_BUF_SPECTRAL,\n\t\t\t\t\t    &db_cap);\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tidr_init(&sp->rx_ring.bufs_idr);\n\t\tspin_lock_init(&sp->rx_ring.idr_lock);\n\t\tspin_lock_init(&sp->lock);\n\n\t\tret = ath11k_spectral_ring_alloc(ar, &db_cap);\n\t\tif (ret) {\n\t\t\tath11k_warn(ab, \"failed to init spectral ring for pdev %d\\n\",\n\t\t\t\t    i);\n\t\t\tgoto deinit;\n\t\t}\n\n\t\tspin_lock_bh(&sp->lock);\n\n\t\tsp->mode = ATH11K_SPECTRAL_DISABLED;\n\t\tsp->count = ATH11K_WMI_SPECTRAL_COUNT_DEFAULT;\n\t\tsp->fft_size = ATH11K_WMI_SPECTRAL_FFT_SIZE_DEFAULT;\n\t\tsp->enabled = true;\n\n\t\tspin_unlock_bh(&sp->lock);\n\n\t\tret = ath11k_spectral_debug_register(ar);\n\t\tif (ret) {\n\t\t\tath11k_warn(ab, \"failed to register spectral for pdev %d\\n\",\n\t\t\t\t    i);\n\t\t\tgoto deinit;\n\t\t}\n\t}\n\n\treturn 0;\n\ndeinit:\n\tath11k_spectral_deinit(ab);\n\treturn ret;\n}\n\nenum ath11k_spectral_mode ath11k_spectral_get_mode(struct ath11k *ar)\n{\n\tif (ar->spectral.enabled)\n\t\treturn ar->spectral.mode;\n\telse\n\t\treturn ATH11K_SPECTRAL_DISABLED;\n}\n\nstruct ath11k_dbring *ath11k_spectral_get_dbring(struct ath11k *ar)\n{\n\tif (ar->spectral.enabled)\n\t\treturn &ar->spectral.rx_ring;\n\telse\n\t\treturn NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}