{
  "module_name": "pci.c",
  "hash_id": "08338973ff4b2716f781af2bcf17cb24b9c91d658780e884eeed0f9af25a62cf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath11k/pci.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/pci.h>\n#include <linux/of.h>\n\n#include \"pci.h\"\n#include \"core.h\"\n#include \"hif.h\"\n#include \"mhi.h\"\n#include \"debug.h\"\n#include \"pcic.h\"\n#include \"qmi.h\"\n\n#define ATH11K_PCI_BAR_NUM\t\t0\n#define ATH11K_PCI_DMA_MASK\t\t32\n\n#define TCSR_SOC_HW_VERSION\t\t0x0224\n#define TCSR_SOC_HW_VERSION_MAJOR_MASK\tGENMASK(11, 8)\n#define TCSR_SOC_HW_VERSION_MINOR_MASK\tGENMASK(7, 0)\n\n#define QCA6390_DEVICE_ID\t\t0x1101\n#define QCN9074_DEVICE_ID\t\t0x1104\n#define WCN6855_DEVICE_ID\t\t0x1103\n\nstatic const struct pci_device_id ath11k_pci_id_table[] = {\n\t{ PCI_VDEVICE(QCOM, QCA6390_DEVICE_ID) },\n\t{ PCI_VDEVICE(QCOM, WCN6855_DEVICE_ID) },\n\t{ PCI_VDEVICE(QCOM, QCN9074_DEVICE_ID) },\n\t{0}\n};\n\nMODULE_DEVICE_TABLE(pci, ath11k_pci_id_table);\n\nstatic int ath11k_pci_bus_wake_up(struct ath11k_base *ab)\n{\n\tstruct ath11k_pci *ab_pci = ath11k_pci_priv(ab);\n\n\treturn mhi_device_get_sync(ab_pci->mhi_ctrl->mhi_dev);\n}\n\nstatic void ath11k_pci_bus_release(struct ath11k_base *ab)\n{\n\tstruct ath11k_pci *ab_pci = ath11k_pci_priv(ab);\n\n\tmhi_device_put(ab_pci->mhi_ctrl->mhi_dev);\n}\n\nstatic u32 ath11k_pci_get_window_start(struct ath11k_base *ab, u32 offset)\n{\n\tif (!ab->hw_params.static_window_map)\n\t\treturn ATH11K_PCI_WINDOW_START;\n\n\tif ((offset ^ HAL_SEQ_WCSS_UMAC_OFFSET) < ATH11K_PCI_WINDOW_RANGE_MASK)\n\t\t \n\t\treturn 3 * ATH11K_PCI_WINDOW_START;\n\telse if ((offset ^ HAL_SEQ_WCSS_UMAC_CE0_SRC_REG(ab)) <\n\t\t ATH11K_PCI_WINDOW_RANGE_MASK)\n\t\t  \n\t\treturn 2 * ATH11K_PCI_WINDOW_START;\n\telse\n\t\treturn ATH11K_PCI_WINDOW_START;\n}\n\nstatic inline void ath11k_pci_select_window(struct ath11k_pci *ab_pci, u32 offset)\n{\n\tstruct ath11k_base *ab = ab_pci->ab;\n\n\tu32 window = FIELD_GET(ATH11K_PCI_WINDOW_VALUE_MASK, offset);\n\n\tlockdep_assert_held(&ab_pci->window_lock);\n\n\tif (window != ab_pci->register_window) {\n\t\tiowrite32(ATH11K_PCI_WINDOW_ENABLE_BIT | window,\n\t\t\t  ab->mem + ATH11K_PCI_WINDOW_REG_ADDRESS);\n\t\tioread32(ab->mem + ATH11K_PCI_WINDOW_REG_ADDRESS);\n\t\tab_pci->register_window = window;\n\t}\n}\n\nstatic void\nath11k_pci_window_write32(struct ath11k_base *ab, u32 offset, u32 value)\n{\n\tstruct ath11k_pci *ab_pci = ath11k_pci_priv(ab);\n\tu32 window_start;\n\n\twindow_start = ath11k_pci_get_window_start(ab, offset);\n\n\tif (window_start == ATH11K_PCI_WINDOW_START) {\n\t\tspin_lock_bh(&ab_pci->window_lock);\n\t\tath11k_pci_select_window(ab_pci, offset);\n\t\tiowrite32(value, ab->mem + window_start +\n\t\t\t  (offset & ATH11K_PCI_WINDOW_RANGE_MASK));\n\t\tspin_unlock_bh(&ab_pci->window_lock);\n\t} else {\n\t\tiowrite32(value, ab->mem + window_start +\n\t\t\t  (offset & ATH11K_PCI_WINDOW_RANGE_MASK));\n\t}\n}\n\nstatic u32 ath11k_pci_window_read32(struct ath11k_base *ab, u32 offset)\n{\n\tstruct ath11k_pci *ab_pci = ath11k_pci_priv(ab);\n\tu32 window_start, val;\n\n\twindow_start = ath11k_pci_get_window_start(ab, offset);\n\n\tif (window_start == ATH11K_PCI_WINDOW_START) {\n\t\tspin_lock_bh(&ab_pci->window_lock);\n\t\tath11k_pci_select_window(ab_pci, offset);\n\t\tval = ioread32(ab->mem + window_start +\n\t\t\t       (offset & ATH11K_PCI_WINDOW_RANGE_MASK));\n\t\tspin_unlock_bh(&ab_pci->window_lock);\n\t} else {\n\t\tval = ioread32(ab->mem + window_start +\n\t\t\t       (offset & ATH11K_PCI_WINDOW_RANGE_MASK));\n\t}\n\n\treturn val;\n}\n\nint ath11k_pci_get_msi_irq(struct ath11k_base *ab, unsigned int vector)\n{\n\tstruct pci_dev *pci_dev = to_pci_dev(ab->dev);\n\n\treturn pci_irq_vector(pci_dev, vector);\n}\n\nstatic const struct ath11k_pci_ops ath11k_pci_ops_qca6390 = {\n\t.wakeup = ath11k_pci_bus_wake_up,\n\t.release = ath11k_pci_bus_release,\n\t.get_msi_irq = ath11k_pci_get_msi_irq,\n\t.window_write32 = ath11k_pci_window_write32,\n\t.window_read32 = ath11k_pci_window_read32,\n};\n\nstatic const struct ath11k_pci_ops ath11k_pci_ops_qcn9074 = {\n\t.wakeup = NULL,\n\t.release = NULL,\n\t.get_msi_irq = ath11k_pci_get_msi_irq,\n\t.window_write32 = ath11k_pci_window_write32,\n\t.window_read32 = ath11k_pci_window_read32,\n};\n\nstatic const struct ath11k_msi_config msi_config_one_msi = {\n\t.total_vectors = 1,\n\t.total_users = 4,\n\t.users = (struct ath11k_msi_user[]) {\n\t\t{ .name = \"MHI\", .num_vectors = 3, .base_vector = 0 },\n\t\t{ .name = \"CE\", .num_vectors = 1, .base_vector = 0 },\n\t\t{ .name = \"WAKE\", .num_vectors = 1, .base_vector = 0 },\n\t\t{ .name = \"DP\", .num_vectors = 1, .base_vector = 0 },\n\t},\n};\n\nstatic inline void ath11k_pci_select_static_window(struct ath11k_pci *ab_pci)\n{\n\tu32 umac_window;\n\tu32 ce_window;\n\tu32 window;\n\n\tumac_window = FIELD_GET(ATH11K_PCI_WINDOW_VALUE_MASK, HAL_SEQ_WCSS_UMAC_OFFSET);\n\tce_window = FIELD_GET(ATH11K_PCI_WINDOW_VALUE_MASK, HAL_CE_WFSS_CE_REG_BASE);\n\twindow = (umac_window << 12) | (ce_window << 6);\n\n\tiowrite32(ATH11K_PCI_WINDOW_ENABLE_BIT | window,\n\t\t  ab_pci->ab->mem + ATH11K_PCI_WINDOW_REG_ADDRESS);\n}\n\nstatic void ath11k_pci_soc_global_reset(struct ath11k_base *ab)\n{\n\tu32 val, delay;\n\n\tval = ath11k_pcic_read32(ab, PCIE_SOC_GLOBAL_RESET);\n\n\tval |= PCIE_SOC_GLOBAL_RESET_V;\n\n\tath11k_pcic_write32(ab, PCIE_SOC_GLOBAL_RESET, val);\n\n\t \n\tdelay = 10;\n\tmdelay(delay);\n\n\t \n\tval &= ~PCIE_SOC_GLOBAL_RESET_V;\n\n\tath11k_pcic_write32(ab, PCIE_SOC_GLOBAL_RESET, val);\n\n\tmdelay(delay);\n\n\tval = ath11k_pcic_read32(ab, PCIE_SOC_GLOBAL_RESET);\n\tif (val == 0xffffffff)\n\t\tath11k_warn(ab, \"link down error during global reset\\n\");\n}\n\nstatic void ath11k_pci_clear_dbg_registers(struct ath11k_base *ab)\n{\n\tu32 val;\n\n\t \n\tval = ath11k_pcic_read32(ab, PCIE_Q6_COOKIE_ADDR);\n\tath11k_dbg(ab, ATH11K_DBG_PCI, \"pcie_q6_cookie_addr 0x%x\\n\", val);\n\n\tval = ath11k_pcic_read32(ab, WLAON_WARM_SW_ENTRY);\n\tath11k_dbg(ab, ATH11K_DBG_PCI, \"wlaon_warm_sw_entry 0x%x\\n\", val);\n\n\t \n\tmdelay(10);\n\n\t \n\tath11k_pcic_write32(ab, WLAON_WARM_SW_ENTRY, 0);\n\tmdelay(10);\n\n\tval = ath11k_pcic_read32(ab, WLAON_WARM_SW_ENTRY);\n\tath11k_dbg(ab, ATH11K_DBG_PCI, \"wlaon_warm_sw_entry 0x%x\\n\", val);\n\n\t \n\tval = ath11k_pcic_read32(ab, WLAON_SOC_RESET_CAUSE_REG);\n\tath11k_dbg(ab, ATH11K_DBG_PCI, \"soc reset cause %d\\n\", val);\n}\n\nstatic int ath11k_pci_set_link_reg(struct ath11k_base *ab,\n\t\t\t\t   u32 offset, u32 value, u32 mask)\n{\n\tu32 v;\n\tint i;\n\n\tv = ath11k_pcic_read32(ab, offset);\n\tif ((v & mask) == value)\n\t\treturn 0;\n\n\tfor (i = 0; i < 10; i++) {\n\t\tath11k_pcic_write32(ab, offset, (v & ~mask) | value);\n\n\t\tv = ath11k_pcic_read32(ab, offset);\n\t\tif ((v & mask) == value)\n\t\t\treturn 0;\n\n\t\tmdelay(2);\n\t}\n\n\tath11k_warn(ab, \"failed to set pcie link register 0x%08x: 0x%08x != 0x%08x\\n\",\n\t\t    offset, v & mask, value);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int ath11k_pci_fix_l1ss(struct ath11k_base *ab)\n{\n\tint ret;\n\n\tret = ath11k_pci_set_link_reg(ab,\n\t\t\t\t      PCIE_QSERDES_COM_SYSCLK_EN_SEL_REG(ab),\n\t\t\t\t      PCIE_QSERDES_COM_SYSCLK_EN_SEL_VAL,\n\t\t\t\t      PCIE_QSERDES_COM_SYSCLK_EN_SEL_MSK);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to set sysclk: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ath11k_pci_set_link_reg(ab,\n\t\t\t\t      PCIE_PCS_OSC_DTCT_CONFIG1_REG(ab),\n\t\t\t\t      PCIE_PCS_OSC_DTCT_CONFIG1_VAL,\n\t\t\t\t      PCIE_PCS_OSC_DTCT_CONFIG_MSK);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to set dtct config1 error: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ath11k_pci_set_link_reg(ab,\n\t\t\t\t      PCIE_PCS_OSC_DTCT_CONFIG2_REG(ab),\n\t\t\t\t      PCIE_PCS_OSC_DTCT_CONFIG2_VAL,\n\t\t\t\t      PCIE_PCS_OSC_DTCT_CONFIG_MSK);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to set dtct config2: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ath11k_pci_set_link_reg(ab,\n\t\t\t\t      PCIE_PCS_OSC_DTCT_CONFIG4_REG(ab),\n\t\t\t\t      PCIE_PCS_OSC_DTCT_CONFIG4_VAL,\n\t\t\t\t      PCIE_PCS_OSC_DTCT_CONFIG_MSK);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to set dtct config4: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void ath11k_pci_enable_ltssm(struct ath11k_base *ab)\n{\n\tu32 val;\n\tint i;\n\n\tval = ath11k_pcic_read32(ab, PCIE_PCIE_PARF_LTSSM);\n\n\t \n\tfor (i = 0; val != PARM_LTSSM_VALUE && i < 5; i++) {\n\t\tif (val == 0xffffffff)\n\t\t\tmdelay(5);\n\n\t\tath11k_pcic_write32(ab, PCIE_PCIE_PARF_LTSSM, PARM_LTSSM_VALUE);\n\t\tval = ath11k_pcic_read32(ab, PCIE_PCIE_PARF_LTSSM);\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_PCI, \"ltssm 0x%x\\n\", val);\n\n\tval = ath11k_pcic_read32(ab, GCC_GCC_PCIE_HOT_RST);\n\tval |= GCC_GCC_PCIE_HOT_RST_VAL;\n\tath11k_pcic_write32(ab, GCC_GCC_PCIE_HOT_RST, val);\n\tval = ath11k_pcic_read32(ab, GCC_GCC_PCIE_HOT_RST);\n\n\tath11k_dbg(ab, ATH11K_DBG_PCI, \"pcie_hot_rst 0x%x\\n\", val);\n\n\tmdelay(5);\n}\n\nstatic void ath11k_pci_clear_all_intrs(struct ath11k_base *ab)\n{\n\t \n\tath11k_pcic_write32(ab, PCIE_PCIE_INT_ALL_CLEAR, PCIE_INT_CLEAR_ALL);\n}\n\nstatic void ath11k_pci_set_wlaon_pwr_ctrl(struct ath11k_base *ab)\n{\n\tu32 val;\n\n\tval = ath11k_pcic_read32(ab, WLAON_QFPROM_PWR_CTRL_REG);\n\tval &= ~QFPROM_PWR_CTRL_VDD4BLOW_MASK;\n\tath11k_pcic_write32(ab, WLAON_QFPROM_PWR_CTRL_REG, val);\n}\n\nstatic void ath11k_pci_force_wake(struct ath11k_base *ab)\n{\n\tath11k_pcic_write32(ab, PCIE_SOC_WAKE_PCIE_LOCAL_REG, 1);\n\tmdelay(5);\n}\n\nstatic void ath11k_pci_sw_reset(struct ath11k_base *ab, bool power_on)\n{\n\tmdelay(100);\n\n\tif (power_on) {\n\t\tath11k_pci_enable_ltssm(ab);\n\t\tath11k_pci_clear_all_intrs(ab);\n\t\tath11k_pci_set_wlaon_pwr_ctrl(ab);\n\t\tif (ab->hw_params.fix_l1ss)\n\t\t\tath11k_pci_fix_l1ss(ab);\n\t}\n\n\tath11k_mhi_clear_vector(ab);\n\tath11k_pci_clear_dbg_registers(ab);\n\tath11k_pci_soc_global_reset(ab);\n\tath11k_mhi_set_mhictrl_reset(ab);\n}\n\nstatic void ath11k_pci_init_qmi_ce_config(struct ath11k_base *ab)\n{\n\tstruct ath11k_qmi_ce_cfg *cfg = &ab->qmi.ce_cfg;\n\n\tcfg->tgt_ce = ab->hw_params.target_ce_config;\n\tcfg->tgt_ce_len = ab->hw_params.target_ce_count;\n\n\tcfg->svc_to_ce_map = ab->hw_params.svc_to_ce_map;\n\tcfg->svc_to_ce_map_len = ab->hw_params.svc_to_ce_map_len;\n\tab->qmi.service_ins_id = ab->hw_params.qmi_service_ins_id;\n\n\tath11k_ce_get_shadow_config(ab, &cfg->shadow_reg_v2,\n\t\t\t\t    &cfg->shadow_reg_v2_len);\n}\n\nstatic void ath11k_pci_msi_config(struct ath11k_pci *ab_pci, bool enable)\n{\n\tstruct pci_dev *dev = ab_pci->pdev;\n\tu16 control;\n\n\tpci_read_config_word(dev, dev->msi_cap + PCI_MSI_FLAGS, &control);\n\n\tif (enable)\n\t\tcontrol |= PCI_MSI_FLAGS_ENABLE;\n\telse\n\t\tcontrol &= ~PCI_MSI_FLAGS_ENABLE;\n\n\tpci_write_config_word(dev, dev->msi_cap + PCI_MSI_FLAGS, control);\n}\n\nstatic void ath11k_pci_msi_enable(struct ath11k_pci *ab_pci)\n{\n\tath11k_pci_msi_config(ab_pci, true);\n}\n\nstatic void ath11k_pci_msi_disable(struct ath11k_pci *ab_pci)\n{\n\tath11k_pci_msi_config(ab_pci, false);\n}\n\nstatic int ath11k_pci_alloc_msi(struct ath11k_pci *ab_pci)\n{\n\tstruct ath11k_base *ab = ab_pci->ab;\n\tconst struct ath11k_msi_config *msi_config = ab->pci.msi.config;\n\tstruct pci_dev *pci_dev = ab_pci->pdev;\n\tstruct msi_desc *msi_desc;\n\tint num_vectors;\n\tint ret;\n\n\tnum_vectors = pci_alloc_irq_vectors(pci_dev,\n\t\t\t\t\t    msi_config->total_vectors,\n\t\t\t\t\t    msi_config->total_vectors,\n\t\t\t\t\t    PCI_IRQ_MSI);\n\tif (num_vectors == msi_config->total_vectors) {\n\t\tset_bit(ATH11K_FLAG_MULTI_MSI_VECTORS, &ab->dev_flags);\n\t} else {\n\t\tnum_vectors = pci_alloc_irq_vectors(ab_pci->pdev,\n\t\t\t\t\t\t    1,\n\t\t\t\t\t\t    1,\n\t\t\t\t\t\t    PCI_IRQ_MSI);\n\t\tif (num_vectors < 0) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto reset_msi_config;\n\t\t}\n\t\tclear_bit(ATH11K_FLAG_MULTI_MSI_VECTORS, &ab->dev_flags);\n\t\tab->pci.msi.config = &msi_config_one_msi;\n\t\tath11k_dbg(ab, ATH11K_DBG_PCI, \"request one msi vector\\n\");\n\t}\n\tath11k_info(ab, \"MSI vectors: %d\\n\", num_vectors);\n\n\tath11k_pci_msi_disable(ab_pci);\n\n\tmsi_desc = irq_get_msi_desc(ab_pci->pdev->irq);\n\tif (!msi_desc) {\n\t\tath11k_err(ab, \"msi_desc is NULL!\\n\");\n\t\tret = -EINVAL;\n\t\tgoto free_msi_vector;\n\t}\n\n\tab->pci.msi.ep_base_data = msi_desc->msg.data;\n\n\tpci_read_config_dword(pci_dev, pci_dev->msi_cap + PCI_MSI_ADDRESS_LO,\n\t\t\t      &ab->pci.msi.addr_lo);\n\n\tif (msi_desc->pci.msi_attrib.is_64) {\n\t\tpci_read_config_dword(pci_dev, pci_dev->msi_cap + PCI_MSI_ADDRESS_HI,\n\t\t\t\t      &ab->pci.msi.addr_hi);\n\t} else {\n\t\tab->pci.msi.addr_hi = 0;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_PCI, \"msi base data is %d\\n\", ab->pci.msi.ep_base_data);\n\n\treturn 0;\n\nfree_msi_vector:\n\tpci_free_irq_vectors(ab_pci->pdev);\n\nreset_msi_config:\n\treturn ret;\n}\n\nstatic void ath11k_pci_free_msi(struct ath11k_pci *ab_pci)\n{\n\tpci_free_irq_vectors(ab_pci->pdev);\n}\n\nstatic int ath11k_pci_config_msi_data(struct ath11k_pci *ab_pci)\n{\n\tstruct msi_desc *msi_desc;\n\n\tmsi_desc = irq_get_msi_desc(ab_pci->pdev->irq);\n\tif (!msi_desc) {\n\t\tath11k_err(ab_pci->ab, \"msi_desc is NULL!\\n\");\n\t\tpci_free_irq_vectors(ab_pci->pdev);\n\t\treturn -EINVAL;\n\t}\n\n\tab_pci->ab->pci.msi.ep_base_data = msi_desc->msg.data;\n\n\tath11k_dbg(ab_pci->ab, ATH11K_DBG_PCI, \"after request_irq msi_ep_base_data %d\\n\",\n\t\t   ab_pci->ab->pci.msi.ep_base_data);\n\n\treturn 0;\n}\n\nstatic int ath11k_pci_claim(struct ath11k_pci *ab_pci, struct pci_dev *pdev)\n{\n\tstruct ath11k_base *ab = ab_pci->ab;\n\tu16 device_id;\n\tint ret = 0;\n\n\tpci_read_config_word(pdev, PCI_DEVICE_ID, &device_id);\n\tif (device_id != ab_pci->dev_id)  {\n\t\tath11k_err(ab, \"pci device id mismatch: 0x%x 0x%x\\n\",\n\t\t\t   device_id, ab_pci->dev_id);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tret = pci_assign_resource(pdev, ATH11K_PCI_BAR_NUM);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to assign pci resource: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = pci_enable_device(pdev);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to enable pci device: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = pci_request_region(pdev, ATH11K_PCI_BAR_NUM, \"ath11k_pci\");\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to request pci region: %d\\n\", ret);\n\t\tgoto disable_device;\n\t}\n\n\tret = dma_set_mask_and_coherent(&pdev->dev,\n\t\t\t\t\tDMA_BIT_MASK(ATH11K_PCI_DMA_MASK));\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to set pci dma mask to %d: %d\\n\",\n\t\t\t   ATH11K_PCI_DMA_MASK, ret);\n\t\tgoto release_region;\n\t}\n\n\tpci_set_master(pdev);\n\n\tab->mem_len = pci_resource_len(pdev, ATH11K_PCI_BAR_NUM);\n\tab->mem = pci_iomap(pdev, ATH11K_PCI_BAR_NUM, 0);\n\tif (!ab->mem) {\n\t\tath11k_err(ab, \"failed to map pci bar %d\\n\", ATH11K_PCI_BAR_NUM);\n\t\tret = -EIO;\n\t\tgoto release_region;\n\t}\n\n\tab->mem_ce = ab->mem;\n\n\tath11k_dbg(ab, ATH11K_DBG_BOOT, \"pci_mem 0x%p\\n\", ab->mem);\n\treturn 0;\n\nrelease_region:\n\tpci_release_region(pdev, ATH11K_PCI_BAR_NUM);\ndisable_device:\n\tpci_disable_device(pdev);\nout:\n\treturn ret;\n}\n\nstatic void ath11k_pci_free_region(struct ath11k_pci *ab_pci)\n{\n\tstruct ath11k_base *ab = ab_pci->ab;\n\tstruct pci_dev *pci_dev = ab_pci->pdev;\n\n\tpci_iounmap(pci_dev, ab->mem);\n\tab->mem = NULL;\n\tpci_release_region(pci_dev, ATH11K_PCI_BAR_NUM);\n\tif (pci_is_enabled(pci_dev))\n\t\tpci_disable_device(pci_dev);\n}\n\nstatic void ath11k_pci_aspm_disable(struct ath11k_pci *ab_pci)\n{\n\tstruct ath11k_base *ab = ab_pci->ab;\n\n\tpcie_capability_read_word(ab_pci->pdev, PCI_EXP_LNKCTL,\n\t\t\t\t  &ab_pci->link_ctl);\n\n\tath11k_dbg(ab, ATH11K_DBG_PCI, \"link_ctl 0x%04x L0s %d L1 %d\\n\",\n\t\t   ab_pci->link_ctl,\n\t\t   u16_get_bits(ab_pci->link_ctl, PCI_EXP_LNKCTL_ASPM_L0S),\n\t\t   u16_get_bits(ab_pci->link_ctl, PCI_EXP_LNKCTL_ASPM_L1));\n\n\t \n\tpcie_capability_clear_word(ab_pci->pdev, PCI_EXP_LNKCTL,\n\t\t\t\t   PCI_EXP_LNKCTL_ASPMC);\n\n\tset_bit(ATH11K_PCI_ASPM_RESTORE, &ab_pci->flags);\n}\n\nstatic void ath11k_pci_aspm_restore(struct ath11k_pci *ab_pci)\n{\n\tif (test_and_clear_bit(ATH11K_PCI_ASPM_RESTORE, &ab_pci->flags))\n\t\tpcie_capability_clear_and_set_word(ab_pci->pdev, PCI_EXP_LNKCTL,\n\t\t\t\t\t\t   PCI_EXP_LNKCTL_ASPMC,\n\t\t\t\t\t\t   ab_pci->link_ctl &\n\t\t\t\t\t\t   PCI_EXP_LNKCTL_ASPMC);\n}\n\nstatic int ath11k_pci_power_up(struct ath11k_base *ab)\n{\n\tstruct ath11k_pci *ab_pci = ath11k_pci_priv(ab);\n\tint ret;\n\n\tab_pci->register_window = 0;\n\tclear_bit(ATH11K_FLAG_DEVICE_INIT_DONE, &ab->dev_flags);\n\tath11k_pci_sw_reset(ab_pci->ab, true);\n\n\t \n\tath11k_pci_aspm_disable(ab_pci);\n\n\tath11k_pci_msi_enable(ab_pci);\n\n\tret = ath11k_mhi_start(ab_pci);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to start mhi: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (ab->hw_params.static_window_map)\n\t\tath11k_pci_select_static_window(ab_pci);\n\n\treturn 0;\n}\n\nstatic void ath11k_pci_power_down(struct ath11k_base *ab)\n{\n\tstruct ath11k_pci *ab_pci = ath11k_pci_priv(ab);\n\n\t \n\tath11k_pci_aspm_restore(ab_pci);\n\n\tath11k_pci_force_wake(ab_pci->ab);\n\n\tath11k_pci_msi_disable(ab_pci);\n\n\tath11k_mhi_stop(ab_pci);\n\tclear_bit(ATH11K_FLAG_DEVICE_INIT_DONE, &ab->dev_flags);\n\tath11k_pci_sw_reset(ab_pci->ab, false);\n}\n\nstatic int ath11k_pci_hif_suspend(struct ath11k_base *ab)\n{\n\tstruct ath11k_pci *ar_pci = ath11k_pci_priv(ab);\n\n\treturn ath11k_mhi_suspend(ar_pci);\n}\n\nstatic int ath11k_pci_hif_resume(struct ath11k_base *ab)\n{\n\tstruct ath11k_pci *ar_pci = ath11k_pci_priv(ab);\n\n\treturn ath11k_mhi_resume(ar_pci);\n}\n\nstatic void ath11k_pci_hif_ce_irq_enable(struct ath11k_base *ab)\n{\n\tath11k_pcic_ce_irqs_enable(ab);\n}\n\nstatic void ath11k_pci_hif_ce_irq_disable(struct ath11k_base *ab)\n{\n\tath11k_pcic_ce_irq_disable_sync(ab);\n}\n\nstatic int ath11k_pci_start(struct ath11k_base *ab)\n{\n\tstruct ath11k_pci *ab_pci = ath11k_pci_priv(ab);\n\n\t \n\tif (test_bit(ATH11K_FLAG_MULTI_MSI_VECTORS, &ab->dev_flags))\n\t\tath11k_pci_aspm_restore(ab_pci);\n\telse\n\t\tath11k_info(ab, \"leaving PCI ASPM disabled to avoid MHI M2 problems\\n\");\n\n\tath11k_pcic_start(ab);\n\n\treturn 0;\n}\n\nstatic const struct ath11k_hif_ops ath11k_pci_hif_ops = {\n\t.start = ath11k_pci_start,\n\t.stop = ath11k_pcic_stop,\n\t.read32 = ath11k_pcic_read32,\n\t.write32 = ath11k_pcic_write32,\n\t.read = ath11k_pcic_read,\n\t.power_down = ath11k_pci_power_down,\n\t.power_up = ath11k_pci_power_up,\n\t.suspend = ath11k_pci_hif_suspend,\n\t.resume = ath11k_pci_hif_resume,\n\t.irq_enable = ath11k_pcic_ext_irq_enable,\n\t.irq_disable = ath11k_pcic_ext_irq_disable,\n\t.get_msi_address =  ath11k_pcic_get_msi_address,\n\t.get_user_msi_vector = ath11k_pcic_get_user_msi_assignment,\n\t.map_service_to_pipe = ath11k_pcic_map_service_to_pipe,\n\t.ce_irq_enable = ath11k_pci_hif_ce_irq_enable,\n\t.ce_irq_disable = ath11k_pci_hif_ce_irq_disable,\n\t.get_ce_msi_idx = ath11k_pcic_get_ce_msi_idx,\n};\n\nstatic void ath11k_pci_read_hw_version(struct ath11k_base *ab, u32 *major, u32 *minor)\n{\n\tu32 soc_hw_version;\n\n\tsoc_hw_version = ath11k_pcic_read32(ab, TCSR_SOC_HW_VERSION);\n\t*major = FIELD_GET(TCSR_SOC_HW_VERSION_MAJOR_MASK,\n\t\t\t   soc_hw_version);\n\t*minor = FIELD_GET(TCSR_SOC_HW_VERSION_MINOR_MASK,\n\t\t\t   soc_hw_version);\n\n\tath11k_dbg(ab, ATH11K_DBG_PCI, \"tcsr_soc_hw_version major %d minor %d\\n\",\n\t\t   *major, *minor);\n}\n\nstatic int ath11k_pci_set_irq_affinity_hint(struct ath11k_pci *ab_pci,\n\t\t\t\t\t    const struct cpumask *m)\n{\n\tif (test_bit(ATH11K_FLAG_MULTI_MSI_VECTORS, &ab_pci->ab->dev_flags))\n\t\treturn 0;\n\n\treturn irq_set_affinity_hint(ab_pci->pdev->irq, m);\n}\n\nstatic int ath11k_pci_probe(struct pci_dev *pdev,\n\t\t\t    const struct pci_device_id *pci_dev)\n{\n\tstruct ath11k_base *ab;\n\tstruct ath11k_pci *ab_pci;\n\tu32 soc_hw_version_major, soc_hw_version_minor, addr;\n\tconst struct ath11k_pci_ops *pci_ops;\n\tint ret;\n\n\tab = ath11k_core_alloc(&pdev->dev, sizeof(*ab_pci), ATH11K_BUS_PCI);\n\n\tif (!ab) {\n\t\tdev_err(&pdev->dev, \"failed to allocate ath11k base\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tab->dev = &pdev->dev;\n\tpci_set_drvdata(pdev, ab);\n\tab_pci = ath11k_pci_priv(ab);\n\tab_pci->dev_id = pci_dev->device;\n\tab_pci->ab = ab;\n\tab_pci->pdev = pdev;\n\tab->hif.ops = &ath11k_pci_hif_ops;\n\tab->fw_mode = ATH11K_FIRMWARE_MODE_NORMAL;\n\tpci_set_drvdata(pdev, ab);\n\tspin_lock_init(&ab_pci->window_lock);\n\n\t \n\tret = of_property_read_u32(ab->dev->of_node, \"memory-region\", &addr);\n\tif (!ret)\n\t\tset_bit(ATH11K_FLAG_FIXED_MEM_RGN, &ab->dev_flags);\n\n\tret = ath11k_pci_claim(ab_pci, pdev);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to claim device: %d\\n\", ret);\n\t\tgoto err_free_core;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_BOOT, \"pci probe %04x:%04x %04x:%04x\\n\",\n\t\t   pdev->vendor, pdev->device,\n\t\t   pdev->subsystem_vendor, pdev->subsystem_device);\n\n\tab->id.vendor = pdev->vendor;\n\tab->id.device = pdev->device;\n\tab->id.subsystem_vendor = pdev->subsystem_vendor;\n\tab->id.subsystem_device = pdev->subsystem_device;\n\n\tswitch (pci_dev->device) {\n\tcase QCA6390_DEVICE_ID:\n\t\tath11k_pci_read_hw_version(ab, &soc_hw_version_major,\n\t\t\t\t\t   &soc_hw_version_minor);\n\t\tswitch (soc_hw_version_major) {\n\t\tcase 2:\n\t\t\tab->hw_rev = ATH11K_HW_QCA6390_HW20;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&pdev->dev, \"Unsupported QCA6390 SOC hardware version: %d %d\\n\",\n\t\t\t\tsoc_hw_version_major, soc_hw_version_minor);\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto err_pci_free_region;\n\t\t}\n\n\t\tpci_ops = &ath11k_pci_ops_qca6390;\n\t\tbreak;\n\tcase QCN9074_DEVICE_ID:\n\t\tpci_ops = &ath11k_pci_ops_qcn9074;\n\t\tab->hw_rev = ATH11K_HW_QCN9074_HW10;\n\t\tbreak;\n\tcase WCN6855_DEVICE_ID:\n\t\tab->id.bdf_search = ATH11K_BDF_SEARCH_BUS_AND_BOARD;\n\t\tath11k_pci_read_hw_version(ab, &soc_hw_version_major,\n\t\t\t\t\t   &soc_hw_version_minor);\n\t\tswitch (soc_hw_version_major) {\n\t\tcase 2:\n\t\t\tswitch (soc_hw_version_minor) {\n\t\t\tcase 0x00:\n\t\t\tcase 0x01:\n\t\t\t\tab->hw_rev = ATH11K_HW_WCN6855_HW20;\n\t\t\t\tbreak;\n\t\t\tcase 0x10:\n\t\t\tcase 0x11:\n\t\t\t\tab->hw_rev = ATH11K_HW_WCN6855_HW21;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto unsupported_wcn6855_soc;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\nunsupported_wcn6855_soc:\n\t\t\tdev_err(&pdev->dev, \"Unsupported WCN6855 SOC hardware version: %d %d\\n\",\n\t\t\t\tsoc_hw_version_major, soc_hw_version_minor);\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto err_pci_free_region;\n\t\t}\n\n\t\tpci_ops = &ath11k_pci_ops_qca6390;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&pdev->dev, \"Unknown PCI device found: 0x%x\\n\",\n\t\t\tpci_dev->device);\n\t\tret = -EOPNOTSUPP;\n\t\tgoto err_pci_free_region;\n\t}\n\n\tret = ath11k_pcic_register_pci_ops(ab, pci_ops);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to register PCI ops: %d\\n\", ret);\n\t\tgoto err_pci_free_region;\n\t}\n\n\tret = ath11k_pcic_init_msi_config(ab);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to init msi config: %d\\n\", ret);\n\t\tgoto err_pci_free_region;\n\t}\n\n\tret = ath11k_pci_alloc_msi(ab_pci);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to enable msi: %d\\n\", ret);\n\t\tgoto err_pci_free_region;\n\t}\n\n\tret = ath11k_core_pre_init(ab);\n\tif (ret)\n\t\tgoto err_pci_disable_msi;\n\n\tret = ath11k_pci_set_irq_affinity_hint(ab_pci, cpumask_of(0));\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to set irq affinity %d\\n\", ret);\n\t\tgoto err_pci_disable_msi;\n\t}\n\n\tret = ath11k_mhi_register(ab_pci);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to register mhi: %d\\n\", ret);\n\t\tgoto err_irq_affinity_cleanup;\n\t}\n\n\tret = ath11k_hal_srng_init(ab);\n\tif (ret)\n\t\tgoto err_mhi_unregister;\n\n\tret = ath11k_ce_alloc_pipes(ab);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to allocate ce pipes: %d\\n\", ret);\n\t\tgoto err_hal_srng_deinit;\n\t}\n\n\tath11k_pci_init_qmi_ce_config(ab);\n\n\tret = ath11k_pcic_config_irq(ab);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to config irq: %d\\n\", ret);\n\t\tgoto err_ce_free;\n\t}\n\n\t \n\tret = ath11k_pci_config_msi_data(ab_pci);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to config msi_data: %d\\n\", ret);\n\t\tgoto err_free_irq;\n\t}\n\n\tret = ath11k_core_init(ab);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to init core: %d\\n\", ret);\n\t\tgoto err_free_irq;\n\t}\n\tath11k_qmi_fwreset_from_cold_boot(ab);\n\treturn 0;\n\nerr_free_irq:\n\tath11k_pcic_free_irq(ab);\n\nerr_ce_free:\n\tath11k_ce_free_pipes(ab);\n\nerr_hal_srng_deinit:\n\tath11k_hal_srng_deinit(ab);\n\nerr_mhi_unregister:\n\tath11k_mhi_unregister(ab_pci);\n\nerr_irq_affinity_cleanup:\n\tath11k_pci_set_irq_affinity_hint(ab_pci, NULL);\n\nerr_pci_disable_msi:\n\tath11k_pci_free_msi(ab_pci);\n\nerr_pci_free_region:\n\tath11k_pci_free_region(ab_pci);\n\nerr_free_core:\n\tath11k_core_free(ab);\n\n\treturn ret;\n}\n\nstatic void ath11k_pci_remove(struct pci_dev *pdev)\n{\n\tstruct ath11k_base *ab = pci_get_drvdata(pdev);\n\tstruct ath11k_pci *ab_pci = ath11k_pci_priv(ab);\n\n\tath11k_pci_set_irq_affinity_hint(ab_pci, NULL);\n\n\tif (test_bit(ATH11K_FLAG_QMI_FAIL, &ab->dev_flags)) {\n\t\tath11k_pci_power_down(ab);\n\t\tath11k_debugfs_soc_destroy(ab);\n\t\tath11k_qmi_deinit_service(ab);\n\t\tgoto qmi_fail;\n\t}\n\n\tset_bit(ATH11K_FLAG_UNREGISTERING, &ab->dev_flags);\n\n\tath11k_core_deinit(ab);\n\nqmi_fail:\n\tath11k_mhi_unregister(ab_pci);\n\n\tath11k_pcic_free_irq(ab);\n\tath11k_pci_free_msi(ab_pci);\n\tath11k_pci_free_region(ab_pci);\n\n\tath11k_hal_srng_deinit(ab);\n\tath11k_ce_free_pipes(ab);\n\tath11k_core_free(ab);\n}\n\nstatic void ath11k_pci_shutdown(struct pci_dev *pdev)\n{\n\tstruct ath11k_base *ab = pci_get_drvdata(pdev);\n\tstruct ath11k_pci *ab_pci = ath11k_pci_priv(ab);\n\n\tath11k_pci_set_irq_affinity_hint(ab_pci, NULL);\n\tath11k_pci_power_down(ab);\n}\n\nstatic __maybe_unused int ath11k_pci_pm_suspend(struct device *dev)\n{\n\tstruct ath11k_base *ab = dev_get_drvdata(dev);\n\tint ret;\n\n\tif (test_bit(ATH11K_FLAG_QMI_FAIL, &ab->dev_flags)) {\n\t\tath11k_dbg(ab, ATH11K_DBG_BOOT, \"boot skipping pci suspend as qmi is not initialised\\n\");\n\t\treturn 0;\n\t}\n\n\tret = ath11k_core_suspend(ab);\n\tif (ret)\n\t\tath11k_warn(ab, \"failed to suspend core: %d\\n\", ret);\n\n\treturn 0;\n}\n\nstatic __maybe_unused int ath11k_pci_pm_resume(struct device *dev)\n{\n\tstruct ath11k_base *ab = dev_get_drvdata(dev);\n\tint ret;\n\n\tif (test_bit(ATH11K_FLAG_QMI_FAIL, &ab->dev_flags)) {\n\t\tath11k_dbg(ab, ATH11K_DBG_BOOT, \"boot skipping pci resume as qmi is not initialised\\n\");\n\t\treturn 0;\n\t}\n\n\tret = ath11k_core_resume(ab);\n\tif (ret)\n\t\tath11k_warn(ab, \"failed to resume core: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic SIMPLE_DEV_PM_OPS(ath11k_pci_pm_ops,\n\t\t\t ath11k_pci_pm_suspend,\n\t\t\t ath11k_pci_pm_resume);\n\nstatic struct pci_driver ath11k_pci_driver = {\n\t.name = \"ath11k_pci\",\n\t.id_table = ath11k_pci_id_table,\n\t.probe = ath11k_pci_probe,\n\t.remove = ath11k_pci_remove,\n\t.shutdown = ath11k_pci_shutdown,\n#ifdef CONFIG_PM\n\t.driver.pm = &ath11k_pci_pm_ops,\n#endif\n};\n\nstatic int ath11k_pci_init(void)\n{\n\tint ret;\n\n\tret = pci_register_driver(&ath11k_pci_driver);\n\tif (ret)\n\t\tpr_err(\"failed to register ath11k pci driver: %d\\n\",\n\t\t       ret);\n\n\treturn ret;\n}\nmodule_init(ath11k_pci_init);\n\nstatic void ath11k_pci_exit(void)\n{\n\tpci_unregister_driver(&ath11k_pci_driver);\n}\n\nmodule_exit(ath11k_pci_exit);\n\nMODULE_DESCRIPTION(\"Driver support for Qualcomm Technologies PCIe 802.11ax WLAN devices\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n\n \nMODULE_FIRMWARE(ATH11K_FW_DIR \"/QCA6390/hw2.0/*\");\nMODULE_FIRMWARE(ATH11K_FW_DIR \"/QCN9074/hw1.0/*\");\nMODULE_FIRMWARE(ATH11K_FW_DIR \"/WCN6855/hw2.0/*\");\nMODULE_FIRMWARE(ATH11K_FW_DIR \"/WCN6855/hw2.1/*\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}