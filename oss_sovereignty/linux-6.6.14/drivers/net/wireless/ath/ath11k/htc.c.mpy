{
  "module_name": "htc.c",
  "hash_id": "8100d440d6c901cb8e4ef32950450cde848c81692b77cb3017bf5c573372d3f7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath11k/htc.c",
  "human_readable_source": "\n \n#include <linux/skbuff.h>\n#include <linux/ctype.h>\n\n#include \"debug.h\"\n#include \"hif.h\"\n\nstruct sk_buff *ath11k_htc_alloc_skb(struct ath11k_base *ab, int size)\n{\n\tstruct sk_buff *skb;\n\n\tskb = dev_alloc_skb(size + sizeof(struct ath11k_htc_hdr));\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, sizeof(struct ath11k_htc_hdr));\n\n\t \n\tif (!IS_ALIGNED((unsigned long)skb->data, 4))\n\t\tath11k_warn(ab, \"Unaligned HTC tx skb\\n\");\n\n\treturn skb;\n}\n\nstatic void ath11k_htc_control_tx_complete(struct ath11k_base *ab,\n\t\t\t\t\t   struct sk_buff *skb)\n{\n\tkfree_skb(skb);\n}\n\nstatic struct sk_buff *ath11k_htc_build_tx_ctrl_skb(void *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct ath11k_skb_cb *skb_cb;\n\n\tskb = dev_alloc_skb(ATH11K_HTC_CONTROL_BUFFER_SIZE);\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, sizeof(struct ath11k_htc_hdr));\n\tWARN_ON_ONCE(!IS_ALIGNED((unsigned long)skb->data, 4));\n\n\tskb_cb = ATH11K_SKB_CB(skb);\n\tmemset(skb_cb, 0, sizeof(*skb_cb));\n\n\treturn skb;\n}\n\nstatic void ath11k_htc_prepare_tx_skb(struct ath11k_htc_ep *ep,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct ath11k_htc_hdr *hdr;\n\n\thdr = (struct ath11k_htc_hdr *)skb->data;\n\n\tmemset(hdr, 0, sizeof(*hdr));\n\thdr->htc_info = FIELD_PREP(HTC_HDR_ENDPOINTID, ep->eid) |\n\t\t\tFIELD_PREP(HTC_HDR_PAYLOADLEN,\n\t\t\t\t   (skb->len - sizeof(*hdr)));\n\n\tif (ep->tx_credit_flow_enabled)\n\t\thdr->htc_info |= FIELD_PREP(HTC_HDR_FLAGS,\n\t\t\t\t\t    ATH11K_HTC_FLAG_NEED_CREDIT_UPDATE);\n\n\tspin_lock_bh(&ep->htc->tx_lock);\n\thdr->ctrl_info = FIELD_PREP(HTC_HDR_CONTROLBYTES1, ep->seq_no++);\n\tspin_unlock_bh(&ep->htc->tx_lock);\n}\n\nint ath11k_htc_send(struct ath11k_htc *htc,\n\t\t    enum ath11k_htc_ep_id eid,\n\t\t    struct sk_buff *skb)\n{\n\tstruct ath11k_htc_ep *ep = &htc->endpoint[eid];\n\tstruct ath11k_skb_cb *skb_cb = ATH11K_SKB_CB(skb);\n\tstruct device *dev = htc->ab->dev;\n\tstruct ath11k_base *ab = htc->ab;\n\tint credits = 0;\n\tint ret;\n\tbool credit_flow_enabled = (ab->hw_params.credit_flow &&\n\t\t\t\t    ep->tx_credit_flow_enabled);\n\n\tif (eid >= ATH11K_HTC_EP_COUNT) {\n\t\tath11k_warn(ab, \"Invalid endpoint id: %d\\n\", eid);\n\t\treturn -ENOENT;\n\t}\n\n\tskb_push(skb, sizeof(struct ath11k_htc_hdr));\n\n\tif (credit_flow_enabled) {\n\t\tcredits = DIV_ROUND_UP(skb->len, htc->target_credit_size);\n\t\tspin_lock_bh(&htc->tx_lock);\n\t\tif (ep->tx_credits < credits) {\n\t\t\tath11k_dbg(ab, ATH11K_DBG_HTC,\n\t\t\t\t   \"ep %d insufficient credits required %d total %d\\n\",\n\t\t\t\t   eid, credits, ep->tx_credits);\n\t\t\tspin_unlock_bh(&htc->tx_lock);\n\t\t\tret = -EAGAIN;\n\t\t\tgoto err_pull;\n\t\t}\n\t\tep->tx_credits -= credits;\n\t\tath11k_dbg(ab, ATH11K_DBG_HTC,\n\t\t\t   \"ep %d credits consumed %d total %d\\n\",\n\t\t\t   eid, credits, ep->tx_credits);\n\t\tspin_unlock_bh(&htc->tx_lock);\n\t}\n\n\tath11k_htc_prepare_tx_skb(ep, skb);\n\n\tskb_cb->eid = eid;\n\tskb_cb->paddr = dma_map_single(dev, skb->data, skb->len, DMA_TO_DEVICE);\n\tret = dma_mapping_error(dev, skb_cb->paddr);\n\tif (ret) {\n\t\tret = -EIO;\n\t\tgoto err_credits;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_HTC, \"tx skb %p eid %d paddr %pad\\n\",\n\t\t   skb, skb_cb->eid, &skb_cb->paddr);\n\n\tret = ath11k_ce_send(htc->ab, skb, ep->ul_pipe_id, ep->eid);\n\tif (ret)\n\t\tgoto err_unmap;\n\n\treturn 0;\n\nerr_unmap:\n\tdma_unmap_single(dev, skb_cb->paddr, skb->len, DMA_TO_DEVICE);\nerr_credits:\n\tif (credit_flow_enabled) {\n\t\tspin_lock_bh(&htc->tx_lock);\n\t\tep->tx_credits += credits;\n\t\tath11k_dbg(ab, ATH11K_DBG_HTC,\n\t\t\t   \"ep %d credits reverted %d total %d\\n\",\n\t\t\t   eid, credits, ep->tx_credits);\n\t\tspin_unlock_bh(&htc->tx_lock);\n\n\t\tif (ep->ep_ops.ep_tx_credits)\n\t\t\tep->ep_ops.ep_tx_credits(htc->ab);\n\t}\nerr_pull:\n\tskb_pull(skb, sizeof(struct ath11k_htc_hdr));\n\treturn ret;\n}\n\nstatic void\nath11k_htc_process_credit_report(struct ath11k_htc *htc,\n\t\t\t\t const struct ath11k_htc_credit_report *report,\n\t\t\t\t int len,\n\t\t\t\t enum ath11k_htc_ep_id eid)\n{\n\tstruct ath11k_base *ab = htc->ab;\n\tstruct ath11k_htc_ep *ep;\n\tint i, n_reports;\n\n\tif (len % sizeof(*report))\n\t\tath11k_warn(ab, \"Uneven credit report len %d\", len);\n\n\tn_reports = len / sizeof(*report);\n\n\tspin_lock_bh(&htc->tx_lock);\n\tfor (i = 0; i < n_reports; i++, report++) {\n\t\tif (report->eid >= ATH11K_HTC_EP_COUNT)\n\t\t\tbreak;\n\n\t\tep = &htc->endpoint[report->eid];\n\t\tep->tx_credits += report->credits;\n\n\t\tath11k_dbg(ab, ATH11K_DBG_HTC, \"ep %d credits got %d total %d\\n\",\n\t\t\t   report->eid, report->credits, ep->tx_credits);\n\n\t\tif (ep->ep_ops.ep_tx_credits) {\n\t\t\tspin_unlock_bh(&htc->tx_lock);\n\t\t\tep->ep_ops.ep_tx_credits(htc->ab);\n\t\t\tspin_lock_bh(&htc->tx_lock);\n\t\t}\n\t}\n\tspin_unlock_bh(&htc->tx_lock);\n}\n\nstatic int ath11k_htc_process_trailer(struct ath11k_htc *htc,\n\t\t\t\t      u8 *buffer,\n\t\t\t\t      int length,\n\t\t\t\t      enum ath11k_htc_ep_id src_eid)\n{\n\tstruct ath11k_base *ab = htc->ab;\n\tint status = 0;\n\tstruct ath11k_htc_record *record;\n\tsize_t len;\n\n\twhile (length > 0) {\n\t\trecord = (struct ath11k_htc_record *)buffer;\n\n\t\tif (length < sizeof(record->hdr)) {\n\t\t\tstatus = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (record->hdr.len > length) {\n\t\t\t \n\t\t\tath11k_warn(ab, \"Invalid record length: %d\\n\",\n\t\t\t\t    record->hdr.len);\n\t\t\tstatus = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ab->hw_params.credit_flow) {\n\t\t\tswitch (record->hdr.id) {\n\t\t\tcase ATH11K_HTC_RECORD_CREDITS:\n\t\t\t\tlen = sizeof(struct ath11k_htc_credit_report);\n\t\t\t\tif (record->hdr.len < len) {\n\t\t\t\t\tath11k_warn(ab, \"Credit report too long\\n\");\n\t\t\t\t\tstatus = -EINVAL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tath11k_htc_process_credit_report(htc,\n\t\t\t\t\t\t\t\t record->credit_report,\n\t\t\t\t\t\t\t\t record->hdr.len,\n\t\t\t\t\t\t\t\t src_eid);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tath11k_warn(ab, \"Unhandled record: id:%d length:%d\\n\",\n\t\t\t\t\t    record->hdr.id, record->hdr.len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (status)\n\t\t\tbreak;\n\n\t\t \n\t\tbuffer += sizeof(record->hdr) + record->hdr.len;\n\t\tlength -= sizeof(record->hdr) + record->hdr.len;\n\t}\n\n\treturn status;\n}\n\nstatic void ath11k_htc_suspend_complete(struct ath11k_base *ab, bool ack)\n{\n\tath11k_dbg(ab, ATH11K_DBG_BOOT, \"suspend complete %d\\n\", ack);\n\n\tif (ack)\n\t\tset_bit(ATH11K_FLAG_HTC_SUSPEND_COMPLETE, &ab->dev_flags);\n\telse\n\t\tclear_bit(ATH11K_FLAG_HTC_SUSPEND_COMPLETE, &ab->dev_flags);\n\n\tcomplete(&ab->htc_suspend);\n}\n\nvoid ath11k_htc_tx_completion_handler(struct ath11k_base *ab,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct ath11k_htc *htc = &ab->htc;\n\tstruct ath11k_htc_ep *ep;\n\tvoid (*ep_tx_complete)(struct ath11k_base *, struct sk_buff *);\n\tu8 eid;\n\n\teid = ATH11K_SKB_CB(skb)->eid;\n\tif (eid >= ATH11K_HTC_EP_COUNT) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn;\n\t}\n\n\tep = &htc->endpoint[eid];\n\tspin_lock_bh(&htc->tx_lock);\n\tep_tx_complete = ep->ep_ops.ep_tx_complete;\n\tspin_unlock_bh(&htc->tx_lock);\n\tif (!ep_tx_complete) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn;\n\t}\n\tep_tx_complete(htc->ab, skb);\n}\n\nstatic void ath11k_htc_wakeup_from_suspend(struct ath11k_base *ab)\n{\n\tath11k_dbg(ab, ATH11K_DBG_BOOT, \"wakeup from suspend is received\\n\");\n}\n\nvoid ath11k_htc_rx_completion_handler(struct ath11k_base *ab,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tint status = 0;\n\tstruct ath11k_htc *htc = &ab->htc;\n\tstruct ath11k_htc_hdr *hdr;\n\tstruct ath11k_htc_ep *ep;\n\tu16 payload_len;\n\tu32 message_id, trailer_len = 0;\n\tsize_t min_len;\n\tu8 eid;\n\tbool trailer_present;\n\n\thdr = (struct ath11k_htc_hdr *)skb->data;\n\tskb_pull(skb, sizeof(*hdr));\n\n\teid = FIELD_GET(HTC_HDR_ENDPOINTID, hdr->htc_info);\n\n\tif (eid >= ATH11K_HTC_EP_COUNT) {\n\t\tath11k_warn(ab, \"HTC Rx: invalid eid %d\\n\", eid);\n\t\tgoto out;\n\t}\n\n\tep = &htc->endpoint[eid];\n\n\tpayload_len = FIELD_GET(HTC_HDR_PAYLOADLEN, hdr->htc_info);\n\n\tif (payload_len + sizeof(*hdr) > ATH11K_HTC_MAX_LEN) {\n\t\tath11k_warn(ab, \"HTC rx frame too long, len: %zu\\n\",\n\t\t\t    payload_len + sizeof(*hdr));\n\t\tgoto out;\n\t}\n\n\tif (skb->len < payload_len) {\n\t\tath11k_warn(ab, \"HTC Rx: insufficient length, got %d, expected %d\\n\",\n\t\t\t    skb->len, payload_len);\n\t\tgoto out;\n\t}\n\n\t \n\ttrailer_present = (FIELD_GET(HTC_HDR_FLAGS, hdr->htc_info)) &\n\t\t\t  ATH11K_HTC_FLAG_TRAILER_PRESENT;\n\n\tath11k_dbg(ab, ATH11K_DBG_HTC, \"rx ep %d skb %p trailer_present %d\\n\",\n\t\t   eid, skb, trailer_present);\n\n\tif (trailer_present) {\n\t\tu8 *trailer;\n\n\t\ttrailer_len = FIELD_GET(HTC_HDR_CONTROLBYTES0, hdr->ctrl_info);\n\t\tmin_len = sizeof(struct ath11k_htc_record_hdr);\n\n\t\tif ((trailer_len < min_len) ||\n\t\t    (trailer_len > payload_len)) {\n\t\t\tath11k_warn(ab, \"Invalid trailer length: %d\\n\",\n\t\t\t\t    trailer_len);\n\t\t\tgoto out;\n\t\t}\n\n\t\ttrailer = (u8 *)hdr;\n\t\ttrailer += sizeof(*hdr);\n\t\ttrailer += payload_len;\n\t\ttrailer -= trailer_len;\n\t\tstatus = ath11k_htc_process_trailer(htc, trailer,\n\t\t\t\t\t\t    trailer_len, eid);\n\t\tif (status)\n\t\t\tgoto out;\n\n\t\tskb_trim(skb, skb->len - trailer_len);\n\t}\n\n\tif (trailer_len >= payload_len)\n\t\t \n\t\tgoto out;\n\n\tif (eid == ATH11K_HTC_EP_0) {\n\t\tstruct ath11k_htc_msg *msg = (struct ath11k_htc_msg *)skb->data;\n\n\t\tmessage_id = FIELD_GET(HTC_MSG_MESSAGEID, msg->msg_svc_id);\n\n\t\tath11k_dbg(ab, ATH11K_DBG_HTC, \"rx ep %d skb %p message_id %d\\n\",\n\t\t\t   eid, skb, message_id);\n\n\t\tswitch (message_id) {\n\t\tcase ATH11K_HTC_MSG_READY_ID:\n\t\tcase ATH11K_HTC_MSG_CONNECT_SERVICE_RESP_ID:\n\t\t\t \n\t\t\tif (completion_done(&htc->ctl_resp)) {\n\t\t\t\t \n\t\t\t\tath11k_warn(ab, \"HTC rx ctrl still processing\\n\");\n\t\t\t\tcomplete(&htc->ctl_resp);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\thtc->control_resp_len =\n\t\t\t\tmin_t(int, skb->len,\n\t\t\t\t      ATH11K_HTC_MAX_CTRL_MSG_LEN);\n\n\t\t\tmemcpy(htc->control_resp_buffer, skb->data,\n\t\t\t       htc->control_resp_len);\n\n\t\t\tcomplete(&htc->ctl_resp);\n\t\t\tbreak;\n\t\tcase ATH11K_HTC_MSG_SEND_SUSPEND_COMPLETE:\n\t\t\tath11k_htc_suspend_complete(ab, true);\n\t\t\tbreak;\n\t\tcase ATH11K_HTC_MSG_NACK_SUSPEND:\n\t\t\tath11k_htc_suspend_complete(ab, false);\n\t\t\tbreak;\n\t\tcase ATH11K_HTC_MSG_WAKEUP_FROM_SUSPEND_ID:\n\t\t\tath11k_htc_wakeup_from_suspend(ab);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tath11k_warn(ab, \"ignoring unsolicited htc ep0 event %ld\\n\",\n\t\t\t\t    FIELD_GET(HTC_MSG_MESSAGEID, msg->msg_svc_id));\n\t\t\tbreak;\n\t\t}\n\t\tgoto out;\n\t}\n\n\tep->ep_ops.ep_rx_complete(ab, skb);\n\n\t \n\tath11k_ce_poll_send_completed(ab, ep->ul_pipe_id);\n\n\t \n\tskb = NULL;\nout:\n\tkfree_skb(skb);\n}\n\nstatic void ath11k_htc_control_rx_complete(struct ath11k_base *ab,\n\t\t\t\t\t   struct sk_buff *skb)\n{\n\t \n\tath11k_warn(ab, \"unexpected htc rx\\n\");\n\tkfree_skb(skb);\n}\n\nstatic const char *htc_service_name(enum ath11k_htc_svc_id id)\n{\n\tswitch (id) {\n\tcase ATH11K_HTC_SVC_ID_RESERVED:\n\t\treturn \"Reserved\";\n\tcase ATH11K_HTC_SVC_ID_RSVD_CTRL:\n\t\treturn \"Control\";\n\tcase ATH11K_HTC_SVC_ID_WMI_CONTROL:\n\t\treturn \"WMI\";\n\tcase ATH11K_HTC_SVC_ID_WMI_DATA_BE:\n\t\treturn \"DATA BE\";\n\tcase ATH11K_HTC_SVC_ID_WMI_DATA_BK:\n\t\treturn \"DATA BK\";\n\tcase ATH11K_HTC_SVC_ID_WMI_DATA_VI:\n\t\treturn \"DATA VI\";\n\tcase ATH11K_HTC_SVC_ID_WMI_DATA_VO:\n\t\treturn \"DATA VO\";\n\tcase ATH11K_HTC_SVC_ID_WMI_CONTROL_MAC1:\n\t\treturn \"WMI MAC1\";\n\tcase ATH11K_HTC_SVC_ID_WMI_CONTROL_MAC2:\n\t\treturn \"WMI MAC2\";\n\tcase ATH11K_HTC_SVC_ID_NMI_CONTROL:\n\t\treturn \"NMI Control\";\n\tcase ATH11K_HTC_SVC_ID_NMI_DATA:\n\t\treturn \"NMI Data\";\n\tcase ATH11K_HTC_SVC_ID_HTT_DATA_MSG:\n\t\treturn \"HTT Data\";\n\tcase ATH11K_HTC_SVC_ID_TEST_RAW_STREAMS:\n\t\treturn \"RAW\";\n\tcase ATH11K_HTC_SVC_ID_IPA_TX:\n\t\treturn \"IPA TX\";\n\tcase ATH11K_HTC_SVC_ID_PKT_LOG:\n\t\treturn \"PKT LOG\";\n\t}\n\n\treturn \"Unknown\";\n}\n\nstatic void ath11k_htc_reset_endpoint_states(struct ath11k_htc *htc)\n{\n\tstruct ath11k_htc_ep *ep;\n\tint i;\n\n\tfor (i = ATH11K_HTC_EP_0; i < ATH11K_HTC_EP_COUNT; i++) {\n\t\tep = &htc->endpoint[i];\n\t\tep->service_id = ATH11K_HTC_SVC_ID_UNUSED;\n\t\tep->max_ep_message_len = 0;\n\t\tep->max_tx_queue_depth = 0;\n\t\tep->eid = i;\n\t\tep->htc = htc;\n\t\tep->tx_credit_flow_enabled = true;\n\t}\n}\n\nstatic u8 ath11k_htc_get_credit_allocation(struct ath11k_htc *htc,\n\t\t\t\t\t   u16 service_id)\n{\n\tu8 i, allocation = 0;\n\n\tfor (i = 0; i < ATH11K_HTC_MAX_SERVICE_ALLOC_ENTRIES; i++) {\n\t\tif (htc->service_alloc_table[i].service_id == service_id) {\n\t\t\tallocation =\n\t\t\t\thtc->service_alloc_table[i].credit_allocation;\n\t\t}\n\t}\n\n\treturn allocation;\n}\n\nstatic int ath11k_htc_setup_target_buffer_assignments(struct ath11k_htc *htc)\n{\n\tstruct ath11k_htc_svc_tx_credits *serv_entry;\n\tu32 svc_id[] = {\n\t\tATH11K_HTC_SVC_ID_WMI_CONTROL,\n\t\tATH11K_HTC_SVC_ID_WMI_CONTROL_MAC1,\n\t\tATH11K_HTC_SVC_ID_WMI_CONTROL_MAC2,\n\t};\n\tint i, credits;\n\n\tcredits =  htc->total_transmit_credits;\n\tserv_entry = htc->service_alloc_table;\n\n\tif ((htc->wmi_ep_count == 0) ||\n\t    (htc->wmi_ep_count > ARRAY_SIZE(svc_id)))\n\t\treturn -EINVAL;\n\n\t \n\tcredits = credits / htc->wmi_ep_count;\n\tfor (i = 0; i < htc->wmi_ep_count; i++) {\n\t\tserv_entry[i].service_id = svc_id[i];\n\t\tserv_entry[i].credit_allocation = credits;\n\t}\n\n\treturn 0;\n}\n\nint ath11k_htc_wait_target(struct ath11k_htc *htc)\n{\n\tint i, status = 0;\n\tstruct ath11k_base *ab = htc->ab;\n\tunsigned long time_left;\n\tstruct ath11k_htc_ready *ready;\n\tu16 message_id;\n\tu16 credit_count;\n\tu16 credit_size;\n\n\ttime_left = wait_for_completion_timeout(&htc->ctl_resp,\n\t\t\t\t\t\tATH11K_HTC_WAIT_TIMEOUT_HZ);\n\tif (!time_left) {\n\t\tath11k_warn(ab, \"failed to receive control response completion, polling..\\n\");\n\n\t\tfor (i = 0; i < ab->hw_params.ce_count; i++)\n\t\t\tath11k_ce_per_engine_service(htc->ab, i);\n\n\t\ttime_left =\n\t\t\twait_for_completion_timeout(&htc->ctl_resp,\n\t\t\t\t\t\t    ATH11K_HTC_WAIT_TIMEOUT_HZ);\n\n\t\tif (!time_left)\n\t\t\tstatus = -ETIMEDOUT;\n\t}\n\n\tif (status < 0) {\n\t\tath11k_warn(ab, \"ctl_resp never came in (%d)\\n\", status);\n\t\treturn status;\n\t}\n\n\tif (htc->control_resp_len < sizeof(*ready)) {\n\t\tath11k_warn(ab, \"Invalid HTC ready msg len:%d\\n\",\n\t\t\t    htc->control_resp_len);\n\t\treturn -ECOMM;\n\t}\n\n\tready = (struct ath11k_htc_ready *)htc->control_resp_buffer;\n\tmessage_id   = FIELD_GET(HTC_MSG_MESSAGEID, ready->id_credit_count);\n\tcredit_count = FIELD_GET(HTC_READY_MSG_CREDITCOUNT,\n\t\t\t\t ready->id_credit_count);\n\tcredit_size  = FIELD_GET(HTC_READY_MSG_CREDITSIZE, ready->size_ep);\n\n\tif (message_id != ATH11K_HTC_MSG_READY_ID) {\n\t\tath11k_warn(ab, \"Invalid HTC ready msg: 0x%x\\n\", message_id);\n\t\treturn -ECOMM;\n\t}\n\n\thtc->total_transmit_credits = credit_count;\n\thtc->target_credit_size = credit_size;\n\n\tath11k_dbg(ab, ATH11K_DBG_HTC,\n\t\t   \"target ready total_transmit_credits %d target_credit_size %d\\n\",\n\t\t   htc->total_transmit_credits, htc->target_credit_size);\n\n\tif ((htc->total_transmit_credits == 0) ||\n\t    (htc->target_credit_size == 0)) {\n\t\tath11k_warn(ab, \"Invalid credit size received\\n\");\n\t\treturn -ECOMM;\n\t}\n\n\t \n\tif (ab->hw_params.supports_shadow_regs)\n\t\thtc->total_transmit_credits = 1;\n\n\tath11k_htc_setup_target_buffer_assignments(htc);\n\n\treturn 0;\n}\n\nint ath11k_htc_connect_service(struct ath11k_htc *htc,\n\t\t\t       struct ath11k_htc_svc_conn_req *conn_req,\n\t\t\t       struct ath11k_htc_svc_conn_resp *conn_resp)\n{\n\tstruct ath11k_base *ab = htc->ab;\n\tstruct ath11k_htc_conn_svc *req_msg;\n\tstruct ath11k_htc_conn_svc_resp resp_msg_dummy;\n\tstruct ath11k_htc_conn_svc_resp *resp_msg = &resp_msg_dummy;\n\tenum ath11k_htc_ep_id assigned_eid = ATH11K_HTC_EP_COUNT;\n\tstruct ath11k_htc_ep *ep;\n\tstruct sk_buff *skb;\n\tunsigned int max_msg_size = 0;\n\tint length, status;\n\tunsigned long time_left;\n\tbool disable_credit_flow_ctrl = false;\n\tu16 message_id, service_id, flags = 0;\n\tu8 tx_alloc = 0;\n\n\t \n\tif (conn_req->service_id == ATH11K_HTC_SVC_ID_RSVD_CTRL) {\n\t\tdisable_credit_flow_ctrl = true;\n\t\tassigned_eid = ATH11K_HTC_EP_0;\n\t\tmax_msg_size = ATH11K_HTC_MAX_CTRL_MSG_LEN;\n\t\tmemset(&resp_msg_dummy, 0, sizeof(resp_msg_dummy));\n\t\tgoto setup;\n\t}\n\n\ttx_alloc = ath11k_htc_get_credit_allocation(htc,\n\t\t\t\t\t\t    conn_req->service_id);\n\tif (!tx_alloc)\n\t\tath11k_dbg(ab, ATH11K_DBG_BOOT,\n\t\t\t   \"htc service %s does not allocate target credits\\n\",\n\t\t\t   htc_service_name(conn_req->service_id));\n\n\tskb = ath11k_htc_build_tx_ctrl_skb(htc->ab);\n\tif (!skb) {\n\t\tath11k_warn(ab, \"Failed to allocate HTC packet\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tlength = sizeof(*req_msg);\n\tskb_put(skb, length);\n\tmemset(skb->data, 0, length);\n\n\treq_msg = (struct ath11k_htc_conn_svc *)skb->data;\n\treq_msg->msg_svc_id = FIELD_PREP(HTC_MSG_MESSAGEID,\n\t\t\t\t\t ATH11K_HTC_MSG_CONNECT_SERVICE_ID);\n\n\tflags |= FIELD_PREP(ATH11K_HTC_CONN_FLAGS_RECV_ALLOC, tx_alloc);\n\n\t \n\tif (!(conn_req->service_id == ATH11K_HTC_SVC_ID_WMI_CONTROL ||\n\t      conn_req->service_id == ATH11K_HTC_SVC_ID_WMI_CONTROL_MAC1 ||\n\t      conn_req->service_id == ATH11K_HTC_SVC_ID_WMI_CONTROL_MAC2)) {\n\t\tflags |= ATH11K_HTC_CONN_FLAGS_DISABLE_CREDIT_FLOW_CTRL;\n\t\tdisable_credit_flow_ctrl = true;\n\t}\n\n\tif (!ab->hw_params.credit_flow) {\n\t\tflags |= ATH11K_HTC_CONN_FLAGS_DISABLE_CREDIT_FLOW_CTRL;\n\t\tdisable_credit_flow_ctrl = true;\n\t}\n\n\treq_msg->flags_len = FIELD_PREP(HTC_SVC_MSG_CONNECTIONFLAGS, flags);\n\treq_msg->msg_svc_id |= FIELD_PREP(HTC_SVC_MSG_SERVICE_ID,\n\t\t\t\t\t  conn_req->service_id);\n\n\treinit_completion(&htc->ctl_resp);\n\n\tstatus = ath11k_htc_send(htc, ATH11K_HTC_EP_0, skb);\n\tif (status) {\n\t\tkfree_skb(skb);\n\t\treturn status;\n\t}\n\n\t \n\ttime_left = wait_for_completion_timeout(&htc->ctl_resp,\n\t\t\t\t\t\tATH11K_HTC_CONN_SVC_TIMEOUT_HZ);\n\tif (!time_left) {\n\t\tath11k_err(ab, \"Service connect timeout\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\tresp_msg = (struct ath11k_htc_conn_svc_resp *)htc->control_resp_buffer;\n\tmessage_id = FIELD_GET(HTC_MSG_MESSAGEID, resp_msg->msg_svc_id);\n\tservice_id = FIELD_GET(HTC_SVC_RESP_MSG_SERVICEID,\n\t\t\t       resp_msg->msg_svc_id);\n\n\tif ((message_id != ATH11K_HTC_MSG_CONNECT_SERVICE_RESP_ID) ||\n\t    (htc->control_resp_len < sizeof(*resp_msg))) {\n\t\tath11k_err(ab, \"Invalid resp message ID 0x%x\", message_id);\n\t\treturn -EPROTO;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_HTC,\n\t\t   \"service %s connect response status 0x%lx assigned ep 0x%lx\\n\",\n\t\t   htc_service_name(service_id),\n\t\t   FIELD_GET(HTC_SVC_RESP_MSG_STATUS, resp_msg->flags_len),\n\t\t   FIELD_GET(HTC_SVC_RESP_MSG_ENDPOINTID, resp_msg->flags_len));\n\n\tconn_resp->connect_resp_code = FIELD_GET(HTC_SVC_RESP_MSG_STATUS,\n\t\t\t\t\t\t resp_msg->flags_len);\n\n\t \n\tif (conn_resp->connect_resp_code != ATH11K_HTC_CONN_SVC_STATUS_SUCCESS) {\n\t\tath11k_err(ab, \"HTC Service %s connect request failed: 0x%x)\\n\",\n\t\t\t   htc_service_name(service_id),\n\t\t       conn_resp->connect_resp_code);\n\t\treturn -EPROTO;\n\t}\n\n\tassigned_eid = (enum ath11k_htc_ep_id)FIELD_GET(\n\t\t\t\t\t\tHTC_SVC_RESP_MSG_ENDPOINTID,\n\t\t\t\t\t\tresp_msg->flags_len);\n\n\tmax_msg_size = FIELD_GET(HTC_SVC_RESP_MSG_MAXMSGSIZE,\n\t\t\t\t resp_msg->flags_len);\n\nsetup:\n\n\tif (assigned_eid >= ATH11K_HTC_EP_COUNT)\n\t\treturn -EPROTO;\n\n\tif (max_msg_size == 0)\n\t\treturn -EPROTO;\n\n\tep = &htc->endpoint[assigned_eid];\n\tep->eid = assigned_eid;\n\n\tif (ep->service_id != ATH11K_HTC_SVC_ID_UNUSED)\n\t\treturn -EPROTO;\n\n\t \n\tconn_resp->eid = assigned_eid;\n\tconn_resp->max_msg_len = FIELD_GET(HTC_SVC_RESP_MSG_MAXMSGSIZE,\n\t\t\t\t\t   resp_msg->flags_len);\n\n\t \n\tep->service_id = conn_req->service_id;\n\tep->max_tx_queue_depth = conn_req->max_send_queue_depth;\n\tep->max_ep_message_len = FIELD_GET(HTC_SVC_RESP_MSG_MAXMSGSIZE,\n\t\t\t\t\t   resp_msg->flags_len);\n\tep->tx_credits = tx_alloc;\n\n\t \n\tep->ep_ops = conn_req->ep_ops;\n\n\tstatus = ath11k_hif_map_service_to_pipe(htc->ab,\n\t\t\t\t\t\tep->service_id,\n\t\t\t\t\t\t&ep->ul_pipe_id,\n\t\t\t\t\t\t&ep->dl_pipe_id);\n\tif (status)\n\t\treturn status;\n\n\tath11k_dbg(ab, ATH11K_DBG_BOOT,\n\t\t   \"htc service '%s' ul pipe %d dl pipe %d eid %d ready\\n\",\n\t\t   htc_service_name(ep->service_id), ep->ul_pipe_id,\n\t\t   ep->dl_pipe_id, ep->eid);\n\n\tif (disable_credit_flow_ctrl && ep->tx_credit_flow_enabled) {\n\t\tep->tx_credit_flow_enabled = false;\n\t\tath11k_dbg(ab, ATH11K_DBG_BOOT,\n\t\t\t   \"htc service '%s' eid %d tx flow control disabled\\n\",\n\t\t\t   htc_service_name(ep->service_id), assigned_eid);\n\t}\n\n\treturn status;\n}\n\nint ath11k_htc_start(struct ath11k_htc *htc)\n{\n\tstruct sk_buff *skb;\n\tint status = 0;\n\tstruct ath11k_base *ab = htc->ab;\n\tstruct ath11k_htc_setup_complete_extended *msg;\n\n\tskb = ath11k_htc_build_tx_ctrl_skb(htc->ab);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put(skb, sizeof(*msg));\n\tmemset(skb->data, 0, skb->len);\n\n\tmsg = (struct ath11k_htc_setup_complete_extended *)skb->data;\n\tmsg->msg_id = FIELD_PREP(HTC_MSG_MESSAGEID,\n\t\t\t\t ATH11K_HTC_MSG_SETUP_COMPLETE_EX_ID);\n\n\tif (ab->hw_params.credit_flow)\n\t\tath11k_dbg(ab, ATH11K_DBG_HTC, \"using tx credit flow control\\n\");\n\telse\n\t\tmsg->flags |= ATH11K_GLOBAL_DISABLE_CREDIT_FLOW;\n\n\tstatus = ath11k_htc_send(htc, ATH11K_HTC_EP_0, skb);\n\tif (status) {\n\t\tkfree_skb(skb);\n\t\treturn status;\n\t}\n\n\treturn 0;\n}\n\nint ath11k_htc_init(struct ath11k_base *ab)\n{\n\tstruct ath11k_htc *htc = &ab->htc;\n\tstruct ath11k_htc_svc_conn_req conn_req;\n\tstruct ath11k_htc_svc_conn_resp conn_resp;\n\tint ret;\n\n\tspin_lock_init(&htc->tx_lock);\n\n\tath11k_htc_reset_endpoint_states(htc);\n\n\thtc->ab = ab;\n\n\tswitch (ab->wmi_ab.preferred_hw_mode) {\n\tcase WMI_HOST_HW_MODE_SINGLE:\n\t\thtc->wmi_ep_count = 1;\n\t\tbreak;\n\tcase WMI_HOST_HW_MODE_DBS:\n\tcase WMI_HOST_HW_MODE_DBS_OR_SBS:\n\t\thtc->wmi_ep_count = 2;\n\t\tbreak;\n\tcase WMI_HOST_HW_MODE_DBS_SBS:\n\t\thtc->wmi_ep_count = 3;\n\t\tbreak;\n\tdefault:\n\t\thtc->wmi_ep_count = ab->hw_params.max_radios;\n\t\tbreak;\n\t}\n\n\t \n\tmemset(&conn_req, 0, sizeof(conn_req));\n\tmemset(&conn_resp, 0, sizeof(conn_resp));\n\tconn_req.ep_ops.ep_tx_complete = ath11k_htc_control_tx_complete;\n\tconn_req.ep_ops.ep_rx_complete = ath11k_htc_control_rx_complete;\n\tconn_req.max_send_queue_depth = ATH11K_NUM_CONTROL_TX_BUFFERS;\n\tconn_req.service_id = ATH11K_HTC_SVC_ID_RSVD_CTRL;\n\n\t \n\tret = ath11k_htc_connect_service(htc, &conn_req, &conn_resp);\n\tif (ret) {\n\t\tath11k_err(ab, \"could not connect to htc service (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tinit_completion(&htc->ctl_resp);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}