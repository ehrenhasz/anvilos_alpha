{
  "module_name": "thermal.c",
  "hash_id": "9a6fa1075d58d48bb1f8420d7148772a6ca57e0794316668a9730840f77c779e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath11k/thermal.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/sysfs.h>\n#include <linux/thermal.h>\n#include <linux/hwmon.h>\n#include <linux/hwmon-sysfs.h>\n#include \"core.h\"\n#include \"debug.h\"\n\nstatic int\nath11k_thermal_get_max_throttle_state(struct thermal_cooling_device *cdev,\n\t\t\t\t      unsigned long *state)\n{\n\t*state = ATH11K_THERMAL_THROTTLE_MAX;\n\n\treturn 0;\n}\n\nstatic int\nath11k_thermal_get_cur_throttle_state(struct thermal_cooling_device *cdev,\n\t\t\t\t      unsigned long *state)\n{\n\tstruct ath11k *ar = cdev->devdata;\n\n\tmutex_lock(&ar->conf_mutex);\n\t*state = ar->thermal.throttle_state;\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn 0;\n}\n\nstatic int\nath11k_thermal_set_cur_throttle_state(struct thermal_cooling_device *cdev,\n\t\t\t\t      unsigned long throttle_state)\n{\n\tstruct ath11k *ar = cdev->devdata;\n\tint ret;\n\n\tif (throttle_state > ATH11K_THERMAL_THROTTLE_MAX) {\n\t\tath11k_warn(ar->ab, \"throttle state %ld is exceeding the limit %d\\n\",\n\t\t\t    throttle_state, ATH11K_THERMAL_THROTTLE_MAX);\n\t\treturn -EINVAL;\n\t}\n\tmutex_lock(&ar->conf_mutex);\n\tret = ath11k_thermal_set_throttling(ar, throttle_state);\n\tif (ret == 0)\n\t\tar->thermal.throttle_state = throttle_state;\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic const struct thermal_cooling_device_ops ath11k_thermal_ops = {\n\t.get_max_state = ath11k_thermal_get_max_throttle_state,\n\t.get_cur_state = ath11k_thermal_get_cur_throttle_state,\n\t.set_cur_state = ath11k_thermal_set_cur_throttle_state,\n};\n\nstatic ssize_t ath11k_thermal_show_temp(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct ath11k *ar = dev_get_drvdata(dev);\n\tint ret, temperature;\n\tunsigned long time_left;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\t \n\tif (ar->state != ATH11K_STATE_ON) {\n\t\tret = -ENETDOWN;\n\t\tgoto out;\n\t}\n\n\treinit_completion(&ar->thermal.wmi_sync);\n\tret = ath11k_wmi_send_pdev_temperature_cmd(ar);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to read temperature %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tif (test_bit(ATH11K_FLAG_CRASH_FLUSH, &ar->ab->dev_flags)) {\n\t\tret = -ESHUTDOWN;\n\t\tgoto out;\n\t}\n\n\ttime_left = wait_for_completion_timeout(&ar->thermal.wmi_sync,\n\t\t\t\t\t\tATH11K_THERMAL_SYNC_TIMEOUT_HZ);\n\tif (!time_left) {\n\t\tath11k_warn(ar->ab, \"failed to synchronize thermal read\\n\");\n\t\tret = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\tspin_lock_bh(&ar->data_lock);\n\ttemperature = ar->thermal.temperature;\n\tspin_unlock_bh(&ar->data_lock);\n\n\t \n\tret = snprintf(buf, PAGE_SIZE, \"%d\\n\", temperature * 1000);\nout:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nvoid ath11k_thermal_event_temperature(struct ath11k *ar, int temperature)\n{\n\tspin_lock_bh(&ar->data_lock);\n\tar->thermal.temperature = temperature;\n\tspin_unlock_bh(&ar->data_lock);\n\tcomplete(&ar->thermal.wmi_sync);\n}\n\nstatic SENSOR_DEVICE_ATTR(temp1_input, 0444, ath11k_thermal_show_temp,\n\t\t\t  NULL, 0);\n\nstatic struct attribute *ath11k_hwmon_attrs[] = {\n\t&sensor_dev_attr_temp1_input.dev_attr.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(ath11k_hwmon);\n\nint ath11k_thermal_set_throttling(struct ath11k *ar, u32 throttle_state)\n{\n\tstruct ath11k_base *sc = ar->ab;\n\tstruct thermal_mitigation_params param;\n\tint ret = 0;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tif (ar->state != ATH11K_STATE_ON)\n\t\treturn 0;\n\n\tmemset(&param, 0, sizeof(param));\n\tparam.pdev_id = ar->pdev->pdev_id;\n\tparam.enable = throttle_state ? 1 : 0;\n\tparam.dc = ATH11K_THERMAL_DEFAULT_DUTY_CYCLE;\n\tparam.dc_per_event = 0xFFFFFFFF;\n\n\tparam.levelconf[0].tmplwm = ATH11K_THERMAL_TEMP_LOW_MARK;\n\tparam.levelconf[0].tmphwm = ATH11K_THERMAL_TEMP_HIGH_MARK;\n\tparam.levelconf[0].dcoffpercent = throttle_state;\n\tparam.levelconf[0].priority = 0;  \n\n\tret = ath11k_wmi_send_thermal_mitigation_param_cmd(ar, &param);\n\tif (ret) {\n\t\tath11k_warn(sc, \"failed to send thermal mitigation duty cycle %u ret %d\\n\",\n\t\t\t    throttle_state, ret);\n\t}\n\n\treturn ret;\n}\n\nint ath11k_thermal_register(struct ath11k_base *sc)\n{\n\tstruct thermal_cooling_device *cdev;\n\tstruct device *hwmon_dev;\n\tstruct ath11k *ar;\n\tstruct ath11k_pdev *pdev;\n\tint i, ret;\n\n\tfor (i = 0; i < sc->num_radios; i++) {\n\t\tpdev = &sc->pdevs[i];\n\t\tar = pdev->ar;\n\t\tif (!ar)\n\t\t\tcontinue;\n\n\t\tcdev = thermal_cooling_device_register(\"ath11k_thermal\", ar,\n\t\t\t\t\t\t       &ath11k_thermal_ops);\n\n\t\tif (IS_ERR(cdev)) {\n\t\t\tath11k_err(sc, \"failed to setup thermal device result: %ld\\n\",\n\t\t\t\t   PTR_ERR(cdev));\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_thermal_destroy;\n\t\t}\n\n\t\tar->thermal.cdev = cdev;\n\n\t\tret = sysfs_create_link(&ar->hw->wiphy->dev.kobj, &cdev->device.kobj,\n\t\t\t\t\t\"cooling_device\");\n\t\tif (ret) {\n\t\t\tath11k_err(sc, \"failed to create cooling device symlink\\n\");\n\t\t\tgoto err_thermal_destroy;\n\t\t}\n\n\t\tif (!IS_REACHABLE(CONFIG_HWMON))\n\t\t\treturn 0;\n\n\t\thwmon_dev = devm_hwmon_device_register_with_groups(&ar->hw->wiphy->dev,\n\t\t\t\t\t\t\t\t   \"ath11k_hwmon\", ar,\n\t\t\t\t\t\t\t\t   ath11k_hwmon_groups);\n\t\tif (IS_ERR(hwmon_dev)) {\n\t\t\tath11k_err(ar->ab, \"failed to register hwmon device: %ld\\n\",\n\t\t\t\t   PTR_ERR(hwmon_dev));\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_thermal_destroy;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_thermal_destroy:\n\tath11k_thermal_unregister(sc);\n\treturn ret;\n}\n\nvoid ath11k_thermal_unregister(struct ath11k_base *sc)\n{\n\tstruct ath11k *ar;\n\tstruct ath11k_pdev *pdev;\n\tint i;\n\n\tfor (i = 0; i < sc->num_radios; i++) {\n\t\tpdev = &sc->pdevs[i];\n\t\tar = pdev->ar;\n\t\tif (!ar)\n\t\t\tcontinue;\n\n\t\tsysfs_remove_link(&ar->hw->wiphy->dev.kobj, \"cooling_device\");\n\t\tthermal_cooling_device_unregister(ar->thermal.cdev);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}