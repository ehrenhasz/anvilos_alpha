{
  "module_name": "pcic.c",
  "hash_id": "f63e6ae5952b500b0540981d9e17e37f62c10650cb631167fb01b8beda06b798",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath11k/pcic.c",
  "human_readable_source": "\n \n\n#include \"core.h\"\n#include \"pcic.h\"\n#include \"debug.h\"\n\nstatic const char *irq_name[ATH11K_IRQ_NUM_MAX] = {\n\t\"bhi\",\n\t\"mhi-er0\",\n\t\"mhi-er1\",\n\t\"ce0\",\n\t\"ce1\",\n\t\"ce2\",\n\t\"ce3\",\n\t\"ce4\",\n\t\"ce5\",\n\t\"ce6\",\n\t\"ce7\",\n\t\"ce8\",\n\t\"ce9\",\n\t\"ce10\",\n\t\"ce11\",\n\t\"host2wbm-desc-feed\",\n\t\"host2reo-re-injection\",\n\t\"host2reo-command\",\n\t\"host2rxdma-monitor-ring3\",\n\t\"host2rxdma-monitor-ring2\",\n\t\"host2rxdma-monitor-ring1\",\n\t\"reo2ost-exception\",\n\t\"wbm2host-rx-release\",\n\t\"reo2host-status\",\n\t\"reo2host-destination-ring4\",\n\t\"reo2host-destination-ring3\",\n\t\"reo2host-destination-ring2\",\n\t\"reo2host-destination-ring1\",\n\t\"rxdma2host-monitor-destination-mac3\",\n\t\"rxdma2host-monitor-destination-mac2\",\n\t\"rxdma2host-monitor-destination-mac1\",\n\t\"ppdu-end-interrupts-mac3\",\n\t\"ppdu-end-interrupts-mac2\",\n\t\"ppdu-end-interrupts-mac1\",\n\t\"rxdma2host-monitor-status-ring-mac3\",\n\t\"rxdma2host-monitor-status-ring-mac2\",\n\t\"rxdma2host-monitor-status-ring-mac1\",\n\t\"host2rxdma-host-buf-ring-mac3\",\n\t\"host2rxdma-host-buf-ring-mac2\",\n\t\"host2rxdma-host-buf-ring-mac1\",\n\t\"rxdma2host-destination-ring-mac3\",\n\t\"rxdma2host-destination-ring-mac2\",\n\t\"rxdma2host-destination-ring-mac1\",\n\t\"host2tcl-input-ring4\",\n\t\"host2tcl-input-ring3\",\n\t\"host2tcl-input-ring2\",\n\t\"host2tcl-input-ring1\",\n\t\"wbm2host-tx-completions-ring3\",\n\t\"wbm2host-tx-completions-ring2\",\n\t\"wbm2host-tx-completions-ring1\",\n\t\"tcl2host-status-ring\",\n};\n\nstatic const struct ath11k_msi_config ath11k_msi_config[] = {\n\t{\n\t\t.total_vectors = 32,\n\t\t.total_users = 4,\n\t\t.users = (struct ath11k_msi_user[]) {\n\t\t\t{ .name = \"MHI\", .num_vectors = 3, .base_vector = 0 },\n\t\t\t{ .name = \"CE\", .num_vectors = 10, .base_vector = 3 },\n\t\t\t{ .name = \"WAKE\", .num_vectors = 1, .base_vector = 13 },\n\t\t\t{ .name = \"DP\", .num_vectors = 18, .base_vector = 14 },\n\t\t},\n\t\t.hw_rev = ATH11K_HW_QCA6390_HW20,\n\t},\n\t{\n\t\t.total_vectors = 16,\n\t\t.total_users = 3,\n\t\t.users = (struct ath11k_msi_user[]) {\n\t\t\t{ .name = \"MHI\", .num_vectors = 3, .base_vector = 0 },\n\t\t\t{ .name = \"CE\", .num_vectors = 5, .base_vector = 3 },\n\t\t\t{ .name = \"DP\", .num_vectors = 8, .base_vector = 8 },\n\t\t},\n\t\t.hw_rev = ATH11K_HW_QCN9074_HW10,\n\t},\n\t{\n\t\t.total_vectors = 32,\n\t\t.total_users = 4,\n\t\t.users = (struct ath11k_msi_user[]) {\n\t\t\t{ .name = \"MHI\", .num_vectors = 3, .base_vector = 0 },\n\t\t\t{ .name = \"CE\", .num_vectors = 10, .base_vector = 3 },\n\t\t\t{ .name = \"WAKE\", .num_vectors = 1, .base_vector = 13 },\n\t\t\t{ .name = \"DP\", .num_vectors = 18, .base_vector = 14 },\n\t\t},\n\t\t.hw_rev = ATH11K_HW_WCN6855_HW20,\n\t},\n\t{\n\t\t.total_vectors = 32,\n\t\t.total_users = 4,\n\t\t.users = (struct ath11k_msi_user[]) {\n\t\t\t{ .name = \"MHI\", .num_vectors = 3, .base_vector = 0 },\n\t\t\t{ .name = \"CE\", .num_vectors = 10, .base_vector = 3 },\n\t\t\t{ .name = \"WAKE\", .num_vectors = 1, .base_vector = 13 },\n\t\t\t{ .name = \"DP\", .num_vectors = 18, .base_vector = 14 },\n\t\t},\n\t\t.hw_rev = ATH11K_HW_WCN6855_HW21,\n\t},\n\t{\n\t\t.total_vectors = 28,\n\t\t.total_users = 2,\n\t\t.users = (struct ath11k_msi_user[]) {\n\t\t\t{ .name = \"CE\", .num_vectors = 10, .base_vector = 0 },\n\t\t\t{ .name = \"DP\", .num_vectors = 18, .base_vector = 10 },\n\t\t},\n\t\t.hw_rev = ATH11K_HW_WCN6750_HW10,\n\t},\n};\n\nint ath11k_pcic_init_msi_config(struct ath11k_base *ab)\n{\n\tconst struct ath11k_msi_config *msi_config;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ath11k_msi_config); i++) {\n\t\tmsi_config = &ath11k_msi_config[i];\n\n\t\tif (msi_config->hw_rev == ab->hw_rev)\n\t\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(ath11k_msi_config)) {\n\t\tath11k_err(ab, \"failed to fetch msi config, unsupported hw version: 0x%x\\n\",\n\t\t\t   ab->hw_rev);\n\t\treturn -EINVAL;\n\t}\n\n\tab->pci.msi.config = msi_config;\n\treturn 0;\n}\nEXPORT_SYMBOL(ath11k_pcic_init_msi_config);\n\nstatic void __ath11k_pcic_write32(struct ath11k_base *ab, u32 offset, u32 value)\n{\n\tif (offset < ATH11K_PCI_WINDOW_START)\n\t\tiowrite32(value, ab->mem  + offset);\n\telse\n\t\tab->pci.ops->window_write32(ab, offset, value);\n}\n\nvoid ath11k_pcic_write32(struct ath11k_base *ab, u32 offset, u32 value)\n{\n\tint ret = 0;\n\tbool wakeup_required;\n\n\t \n\twakeup_required = test_bit(ATH11K_FLAG_DEVICE_INIT_DONE, &ab->dev_flags) &&\n\t\t\t  offset >= ATH11K_PCI_ACCESS_ALWAYS_OFF;\n\tif (wakeup_required && ab->pci.ops->wakeup)\n\t\tret = ab->pci.ops->wakeup(ab);\n\n\t__ath11k_pcic_write32(ab, offset, value);\n\n\tif (wakeup_required && !ret && ab->pci.ops->release)\n\t\tab->pci.ops->release(ab);\n}\nEXPORT_SYMBOL(ath11k_pcic_write32);\n\nstatic u32 __ath11k_pcic_read32(struct ath11k_base *ab, u32 offset)\n{\n\tu32 val;\n\n\tif (offset < ATH11K_PCI_WINDOW_START)\n\t\tval = ioread32(ab->mem + offset);\n\telse\n\t\tval = ab->pci.ops->window_read32(ab, offset);\n\n\treturn val;\n}\n\nu32 ath11k_pcic_read32(struct ath11k_base *ab, u32 offset)\n{\n\tint ret = 0;\n\tu32 val;\n\tbool wakeup_required;\n\n\t \n\twakeup_required = test_bit(ATH11K_FLAG_DEVICE_INIT_DONE, &ab->dev_flags) &&\n\t\t\t  offset >= ATH11K_PCI_ACCESS_ALWAYS_OFF;\n\tif (wakeup_required && ab->pci.ops->wakeup)\n\t\tret = ab->pci.ops->wakeup(ab);\n\n\tval = __ath11k_pcic_read32(ab, offset);\n\n\tif (wakeup_required && !ret && ab->pci.ops->release)\n\t\tab->pci.ops->release(ab);\n\n\treturn val;\n}\nEXPORT_SYMBOL(ath11k_pcic_read32);\n\nint ath11k_pcic_read(struct ath11k_base *ab, void *buf, u32 start, u32 end)\n{\n\tint ret = 0;\n\tbool wakeup_required;\n\tu32 *data = buf;\n\tu32 i;\n\n\t \n\twakeup_required = test_bit(ATH11K_FLAG_DEVICE_INIT_DONE, &ab->dev_flags) &&\n\t\t\t  end >= ATH11K_PCI_ACCESS_ALWAYS_OFF;\n\tif (wakeup_required && ab->pci.ops->wakeup) {\n\t\tret = ab->pci.ops->wakeup(ab);\n\t\tif (ret) {\n\t\t\tath11k_warn(ab,\n\t\t\t\t    \"wakeup failed, data may be invalid: %d\",\n\t\t\t\t    ret);\n\t\t\t \n\t\t}\n\t}\n\n\tfor (i = start; i < end + 1; i += 4)\n\t\t*data++ = __ath11k_pcic_read32(ab, i);\n\n\tif (wakeup_required && ab->pci.ops->release)\n\t\tab->pci.ops->release(ab);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ath11k_pcic_read);\n\nvoid ath11k_pcic_get_msi_address(struct ath11k_base *ab, u32 *msi_addr_lo,\n\t\t\t\t u32 *msi_addr_hi)\n{\n\t*msi_addr_lo = ab->pci.msi.addr_lo;\n\t*msi_addr_hi = ab->pci.msi.addr_hi;\n}\nEXPORT_SYMBOL(ath11k_pcic_get_msi_address);\n\nint ath11k_pcic_get_user_msi_assignment(struct ath11k_base *ab, char *user_name,\n\t\t\t\t\tint *num_vectors, u32 *user_base_data,\n\t\t\t\t\tu32 *base_vector)\n{\n\tconst struct ath11k_msi_config *msi_config = ab->pci.msi.config;\n\tint idx;\n\n\tfor (idx = 0; idx < msi_config->total_users; idx++) {\n\t\tif (strcmp(user_name, msi_config->users[idx].name) == 0) {\n\t\t\t*num_vectors = msi_config->users[idx].num_vectors;\n\t\t\t*base_vector =  msi_config->users[idx].base_vector;\n\t\t\t*user_base_data = *base_vector + ab->pci.msi.ep_base_data;\n\n\t\t\tath11k_dbg(ab, ATH11K_DBG_PCI,\n\t\t\t\t   \"msi assignment %s num_vectors %d user_base_data %u base_vector %u\\n\",\n\t\t\t\t   user_name, *num_vectors, *user_base_data,\n\t\t\t\t   *base_vector);\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tath11k_err(ab, \"Failed to find MSI assignment for %s!\\n\", user_name);\n\n\treturn -EINVAL;\n}\nEXPORT_SYMBOL(ath11k_pcic_get_user_msi_assignment);\n\nvoid ath11k_pcic_get_ce_msi_idx(struct ath11k_base *ab, u32 ce_id, u32 *msi_idx)\n{\n\tu32 i, msi_data_idx;\n\n\tfor (i = 0, msi_data_idx = 0; i < ab->hw_params.ce_count; i++) {\n\t\tif (ath11k_ce_get_attr_flags(ab, i) & CE_ATTR_DIS_INTR)\n\t\t\tcontinue;\n\n\t\tif (ce_id == i)\n\t\t\tbreak;\n\n\t\tmsi_data_idx++;\n\t}\n\t*msi_idx = msi_data_idx;\n}\nEXPORT_SYMBOL(ath11k_pcic_get_ce_msi_idx);\n\nstatic void ath11k_pcic_free_ext_irq(struct ath11k_base *ab)\n{\n\tint i, j;\n\n\tfor (i = 0; i < ATH11K_EXT_IRQ_GRP_NUM_MAX; i++) {\n\t\tstruct ath11k_ext_irq_grp *irq_grp = &ab->ext_irq_grp[i];\n\n\t\tfor (j = 0; j < irq_grp->num_irq; j++)\n\t\t\tfree_irq(ab->irq_num[irq_grp->irqs[j]], irq_grp);\n\n\t\tnetif_napi_del(&irq_grp->napi);\n\t}\n}\n\nvoid ath11k_pcic_free_irq(struct ath11k_base *ab)\n{\n\tint i, irq_idx;\n\n\tfor (i = 0; i < ab->hw_params.ce_count; i++) {\n\t\tif (ath11k_ce_get_attr_flags(ab, i) & CE_ATTR_DIS_INTR)\n\t\t\tcontinue;\n\t\tirq_idx = ATH11K_PCI_IRQ_CE0_OFFSET + i;\n\t\tfree_irq(ab->irq_num[irq_idx], &ab->ce.ce_pipe[i]);\n\t}\n\n\tath11k_pcic_free_ext_irq(ab);\n}\nEXPORT_SYMBOL(ath11k_pcic_free_irq);\n\nstatic void ath11k_pcic_ce_irq_enable(struct ath11k_base *ab, u16 ce_id)\n{\n\tu32 irq_idx;\n\n\t \n\tif (!test_bit(ATH11K_FLAG_MULTI_MSI_VECTORS, &ab->dev_flags))\n\t\treturn;\n\n\tirq_idx = ATH11K_PCI_IRQ_CE0_OFFSET + ce_id;\n\tenable_irq(ab->irq_num[irq_idx]);\n}\n\nstatic void ath11k_pcic_ce_irq_disable(struct ath11k_base *ab, u16 ce_id)\n{\n\tu32 irq_idx;\n\n\t \n\tif (!test_bit(ATH11K_FLAG_MULTI_MSI_VECTORS, &ab->dev_flags))\n\t\treturn;\n\n\tirq_idx = ATH11K_PCI_IRQ_CE0_OFFSET + ce_id;\n\tdisable_irq_nosync(ab->irq_num[irq_idx]);\n}\n\nstatic void ath11k_pcic_ce_irqs_disable(struct ath11k_base *ab)\n{\n\tint i;\n\n\tclear_bit(ATH11K_FLAG_CE_IRQ_ENABLED, &ab->dev_flags);\n\n\tfor (i = 0; i < ab->hw_params.ce_count; i++) {\n\t\tif (ath11k_ce_get_attr_flags(ab, i) & CE_ATTR_DIS_INTR)\n\t\t\tcontinue;\n\t\tath11k_pcic_ce_irq_disable(ab, i);\n\t}\n}\n\nstatic void ath11k_pcic_sync_ce_irqs(struct ath11k_base *ab)\n{\n\tint i;\n\tint irq_idx;\n\n\tfor (i = 0; i < ab->hw_params.ce_count; i++) {\n\t\tif (ath11k_ce_get_attr_flags(ab, i) & CE_ATTR_DIS_INTR)\n\t\t\tcontinue;\n\n\t\tirq_idx = ATH11K_PCI_IRQ_CE0_OFFSET + i;\n\t\tsynchronize_irq(ab->irq_num[irq_idx]);\n\t}\n}\n\nstatic void ath11k_pcic_ce_tasklet(struct tasklet_struct *t)\n{\n\tstruct ath11k_ce_pipe *ce_pipe = from_tasklet(ce_pipe, t, intr_tq);\n\tint irq_idx = ATH11K_PCI_IRQ_CE0_OFFSET + ce_pipe->pipe_num;\n\n\tath11k_ce_per_engine_service(ce_pipe->ab, ce_pipe->pipe_num);\n\n\tenable_irq(ce_pipe->ab->irq_num[irq_idx]);\n}\n\nstatic irqreturn_t ath11k_pcic_ce_interrupt_handler(int irq, void *arg)\n{\n\tstruct ath11k_ce_pipe *ce_pipe = arg;\n\tstruct ath11k_base *ab = ce_pipe->ab;\n\tint irq_idx = ATH11K_PCI_IRQ_CE0_OFFSET + ce_pipe->pipe_num;\n\n\tif (!test_bit(ATH11K_FLAG_CE_IRQ_ENABLED, &ab->dev_flags))\n\t\treturn IRQ_HANDLED;\n\n\t \n\tce_pipe->timestamp = jiffies;\n\n\tdisable_irq_nosync(ab->irq_num[irq_idx]);\n\n\ttasklet_schedule(&ce_pipe->intr_tq);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void ath11k_pcic_ext_grp_disable(struct ath11k_ext_irq_grp *irq_grp)\n{\n\tstruct ath11k_base *ab = irq_grp->ab;\n\tint i;\n\n\t \n\tif (!test_bit(ATH11K_FLAG_MULTI_MSI_VECTORS, &ab->dev_flags))\n\t\treturn;\n\n\tfor (i = 0; i < irq_grp->num_irq; i++)\n\t\tdisable_irq_nosync(irq_grp->ab->irq_num[irq_grp->irqs[i]]);\n}\n\nstatic void __ath11k_pcic_ext_irq_disable(struct ath11k_base *sc)\n{\n\tint i;\n\n\tclear_bit(ATH11K_FLAG_EXT_IRQ_ENABLED, &sc->dev_flags);\n\n\tfor (i = 0; i < ATH11K_EXT_IRQ_GRP_NUM_MAX; i++) {\n\t\tstruct ath11k_ext_irq_grp *irq_grp = &sc->ext_irq_grp[i];\n\n\t\tath11k_pcic_ext_grp_disable(irq_grp);\n\n\t\tif (irq_grp->napi_enabled) {\n\t\t\tnapi_synchronize(&irq_grp->napi);\n\t\t\tnapi_disable(&irq_grp->napi);\n\t\t\tirq_grp->napi_enabled = false;\n\t\t}\n\t}\n}\n\nstatic void ath11k_pcic_ext_grp_enable(struct ath11k_ext_irq_grp *irq_grp)\n{\n\tstruct ath11k_base *ab = irq_grp->ab;\n\tint i;\n\n\t \n\tif (!test_bit(ATH11K_FLAG_MULTI_MSI_VECTORS, &ab->dev_flags))\n\t\treturn;\n\n\tfor (i = 0; i < irq_grp->num_irq; i++)\n\t\tenable_irq(irq_grp->ab->irq_num[irq_grp->irqs[i]]);\n}\n\nvoid ath11k_pcic_ext_irq_enable(struct ath11k_base *ab)\n{\n\tint i;\n\n\tset_bit(ATH11K_FLAG_EXT_IRQ_ENABLED, &ab->dev_flags);\n\n\tfor (i = 0; i < ATH11K_EXT_IRQ_GRP_NUM_MAX; i++) {\n\t\tstruct ath11k_ext_irq_grp *irq_grp = &ab->ext_irq_grp[i];\n\n\t\tif (!irq_grp->napi_enabled) {\n\t\t\tnapi_enable(&irq_grp->napi);\n\t\t\tirq_grp->napi_enabled = true;\n\t\t}\n\t\tath11k_pcic_ext_grp_enable(irq_grp);\n\t}\n}\nEXPORT_SYMBOL(ath11k_pcic_ext_irq_enable);\n\nstatic void ath11k_pcic_sync_ext_irqs(struct ath11k_base *ab)\n{\n\tint i, j, irq_idx;\n\n\tfor (i = 0; i < ATH11K_EXT_IRQ_GRP_NUM_MAX; i++) {\n\t\tstruct ath11k_ext_irq_grp *irq_grp = &ab->ext_irq_grp[i];\n\n\t\tfor (j = 0; j < irq_grp->num_irq; j++) {\n\t\t\tirq_idx = irq_grp->irqs[j];\n\t\t\tsynchronize_irq(ab->irq_num[irq_idx]);\n\t\t}\n\t}\n}\n\nvoid ath11k_pcic_ext_irq_disable(struct ath11k_base *ab)\n{\n\t__ath11k_pcic_ext_irq_disable(ab);\n\tath11k_pcic_sync_ext_irqs(ab);\n}\nEXPORT_SYMBOL(ath11k_pcic_ext_irq_disable);\n\nstatic int ath11k_pcic_ext_grp_napi_poll(struct napi_struct *napi, int budget)\n{\n\tstruct ath11k_ext_irq_grp *irq_grp = container_of(napi,\n\t\t\t\t\t\tstruct ath11k_ext_irq_grp,\n\t\t\t\t\t\tnapi);\n\tstruct ath11k_base *ab = irq_grp->ab;\n\tint work_done;\n\tint i;\n\n\twork_done = ath11k_dp_service_srng(ab, irq_grp, budget);\n\tif (work_done < budget) {\n\t\tnapi_complete_done(napi, work_done);\n\t\tfor (i = 0; i < irq_grp->num_irq; i++)\n\t\t\tenable_irq(irq_grp->ab->irq_num[irq_grp->irqs[i]]);\n\t}\n\n\tif (work_done > budget)\n\t\twork_done = budget;\n\n\treturn work_done;\n}\n\nstatic irqreturn_t ath11k_pcic_ext_interrupt_handler(int irq, void *arg)\n{\n\tstruct ath11k_ext_irq_grp *irq_grp = arg;\n\tstruct ath11k_base *ab = irq_grp->ab;\n\tint i;\n\n\tif (!test_bit(ATH11K_FLAG_EXT_IRQ_ENABLED, &ab->dev_flags))\n\t\treturn IRQ_HANDLED;\n\n\tath11k_dbg(irq_grp->ab, ATH11K_DBG_PCI, \"ext irq %d\\n\", irq);\n\n\t \n\tirq_grp->timestamp = jiffies;\n\n\tfor (i = 0; i < irq_grp->num_irq; i++)\n\t\tdisable_irq_nosync(irq_grp->ab->irq_num[irq_grp->irqs[i]]);\n\n\tnapi_schedule(&irq_grp->napi);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int\nath11k_pcic_get_msi_irq(struct ath11k_base *ab, unsigned int vector)\n{\n\treturn ab->pci.ops->get_msi_irq(ab, vector);\n}\n\nstatic int ath11k_pcic_ext_irq_config(struct ath11k_base *ab)\n{\n\tint i, j, ret, num_vectors = 0;\n\tu32 user_base_data = 0, base_vector = 0;\n\tunsigned long irq_flags;\n\n\tret = ath11k_pcic_get_user_msi_assignment(ab, \"DP\", &num_vectors,\n\t\t\t\t\t\t  &user_base_data,\n\t\t\t\t\t\t  &base_vector);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tirq_flags = IRQF_SHARED;\n\tif (!test_bit(ATH11K_FLAG_MULTI_MSI_VECTORS, &ab->dev_flags))\n\t\tirq_flags |= IRQF_NOBALANCING;\n\n\tfor (i = 0; i < ATH11K_EXT_IRQ_GRP_NUM_MAX; i++) {\n\t\tstruct ath11k_ext_irq_grp *irq_grp = &ab->ext_irq_grp[i];\n\t\tu32 num_irq = 0;\n\n\t\tirq_grp->ab = ab;\n\t\tirq_grp->grp_id = i;\n\t\tinit_dummy_netdev(&irq_grp->napi_ndev);\n\t\tnetif_napi_add(&irq_grp->napi_ndev, &irq_grp->napi,\n\t\t\t       ath11k_pcic_ext_grp_napi_poll);\n\n\t\tif (ab->hw_params.ring_mask->tx[i] ||\n\t\t    ab->hw_params.ring_mask->rx[i] ||\n\t\t    ab->hw_params.ring_mask->rx_err[i] ||\n\t\t    ab->hw_params.ring_mask->rx_wbm_rel[i] ||\n\t\t    ab->hw_params.ring_mask->reo_status[i] ||\n\t\t    ab->hw_params.ring_mask->rxdma2host[i] ||\n\t\t    ab->hw_params.ring_mask->host2rxdma[i] ||\n\t\t    ab->hw_params.ring_mask->rx_mon_status[i]) {\n\t\t\tnum_irq = 1;\n\t\t}\n\n\t\tirq_grp->num_irq = num_irq;\n\t\tirq_grp->irqs[0] = ATH11K_PCI_IRQ_DP_OFFSET + i;\n\n\t\tfor (j = 0; j < irq_grp->num_irq; j++) {\n\t\t\tint irq_idx = irq_grp->irqs[j];\n\t\t\tint vector = (i % num_vectors) + base_vector;\n\t\t\tint irq = ath11k_pcic_get_msi_irq(ab, vector);\n\n\t\t\tif (irq < 0)\n\t\t\t\treturn irq;\n\n\t\t\tab->irq_num[irq_idx] = irq;\n\n\t\t\tath11k_dbg(ab, ATH11K_DBG_PCI,\n\t\t\t\t   \"irq %d group %d\\n\", irq, i);\n\n\t\t\tirq_set_status_flags(irq, IRQ_DISABLE_UNLAZY);\n\t\t\tret = request_irq(irq, ath11k_pcic_ext_interrupt_handler,\n\t\t\t\t\t  irq_flags, \"DP_EXT_IRQ\", irq_grp);\n\t\t\tif (ret) {\n\t\t\t\tath11k_err(ab, \"failed request irq %d: %d\\n\",\n\t\t\t\t\t   vector, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tath11k_pcic_ext_grp_disable(irq_grp);\n\t}\n\n\treturn 0;\n}\n\nint ath11k_pcic_config_irq(struct ath11k_base *ab)\n{\n\tstruct ath11k_ce_pipe *ce_pipe;\n\tu32 msi_data_start;\n\tu32 msi_data_count, msi_data_idx;\n\tu32 msi_irq_start;\n\tunsigned int msi_data;\n\tint irq, i, ret, irq_idx;\n\tunsigned long irq_flags;\n\n\tret = ath11k_pcic_get_user_msi_assignment(ab, \"CE\", &msi_data_count,\n\t\t\t\t\t\t  &msi_data_start, &msi_irq_start);\n\tif (ret)\n\t\treturn ret;\n\n\tirq_flags = IRQF_SHARED;\n\tif (!test_bit(ATH11K_FLAG_MULTI_MSI_VECTORS, &ab->dev_flags))\n\t\tirq_flags |= IRQF_NOBALANCING;\n\n\t \n\tfor (i = 0, msi_data_idx = 0; i < ab->hw_params.ce_count; i++) {\n\t\tif (ath11k_ce_get_attr_flags(ab, i) & CE_ATTR_DIS_INTR)\n\t\t\tcontinue;\n\n\t\tmsi_data = (msi_data_idx % msi_data_count) + msi_irq_start;\n\t\tirq = ath11k_pcic_get_msi_irq(ab, msi_data);\n\t\tif (irq < 0)\n\t\t\treturn irq;\n\n\t\tce_pipe = &ab->ce.ce_pipe[i];\n\n\t\tirq_idx = ATH11K_PCI_IRQ_CE0_OFFSET + i;\n\n\t\ttasklet_setup(&ce_pipe->intr_tq, ath11k_pcic_ce_tasklet);\n\n\t\tret = request_irq(irq, ath11k_pcic_ce_interrupt_handler,\n\t\t\t\t  irq_flags, irq_name[irq_idx], ce_pipe);\n\t\tif (ret) {\n\t\t\tath11k_err(ab, \"failed to request irq %d: %d\\n\",\n\t\t\t\t   irq_idx, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tab->irq_num[irq_idx] = irq;\n\t\tmsi_data_idx++;\n\n\t\tath11k_pcic_ce_irq_disable(ab, i);\n\t}\n\n\tret = ath11k_pcic_ext_irq_config(ab);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ath11k_pcic_config_irq);\n\nvoid ath11k_pcic_ce_irqs_enable(struct ath11k_base *ab)\n{\n\tint i;\n\n\tset_bit(ATH11K_FLAG_CE_IRQ_ENABLED, &ab->dev_flags);\n\n\tfor (i = 0; i < ab->hw_params.ce_count; i++) {\n\t\tif (ath11k_ce_get_attr_flags(ab, i) & CE_ATTR_DIS_INTR)\n\t\t\tcontinue;\n\t\tath11k_pcic_ce_irq_enable(ab, i);\n\t}\n}\nEXPORT_SYMBOL(ath11k_pcic_ce_irqs_enable);\n\nstatic void ath11k_pcic_kill_tasklets(struct ath11k_base *ab)\n{\n\tint i;\n\n\tfor (i = 0; i < ab->hw_params.ce_count; i++) {\n\t\tstruct ath11k_ce_pipe *ce_pipe = &ab->ce.ce_pipe[i];\n\n\t\tif (ath11k_ce_get_attr_flags(ab, i) & CE_ATTR_DIS_INTR)\n\t\t\tcontinue;\n\n\t\ttasklet_kill(&ce_pipe->intr_tq);\n\t}\n}\n\nvoid ath11k_pcic_ce_irq_disable_sync(struct ath11k_base *ab)\n{\n\tath11k_pcic_ce_irqs_disable(ab);\n\tath11k_pcic_sync_ce_irqs(ab);\n\tath11k_pcic_kill_tasklets(ab);\n}\nEXPORT_SYMBOL(ath11k_pcic_ce_irq_disable_sync);\n\nvoid ath11k_pcic_stop(struct ath11k_base *ab)\n{\n\tath11k_pcic_ce_irq_disable_sync(ab);\n\tath11k_ce_cleanup_pipes(ab);\n}\nEXPORT_SYMBOL(ath11k_pcic_stop);\n\nint ath11k_pcic_start(struct ath11k_base *ab)\n{\n\tset_bit(ATH11K_FLAG_DEVICE_INIT_DONE, &ab->dev_flags);\n\n\tath11k_pcic_ce_irqs_enable(ab);\n\tath11k_ce_rx_post_buf(ab);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ath11k_pcic_start);\n\nint ath11k_pcic_map_service_to_pipe(struct ath11k_base *ab, u16 service_id,\n\t\t\t\t    u8 *ul_pipe, u8 *dl_pipe)\n{\n\tconst struct service_to_pipe *entry;\n\tbool ul_set = false, dl_set = false;\n\tint i;\n\n\tfor (i = 0; i < ab->hw_params.svc_to_ce_map_len; i++) {\n\t\tentry = &ab->hw_params.svc_to_ce_map[i];\n\n\t\tif (__le32_to_cpu(entry->service_id) != service_id)\n\t\t\tcontinue;\n\n\t\tswitch (__le32_to_cpu(entry->pipedir)) {\n\t\tcase PIPEDIR_NONE:\n\t\t\tbreak;\n\t\tcase PIPEDIR_IN:\n\t\t\tWARN_ON(dl_set);\n\t\t\t*dl_pipe = __le32_to_cpu(entry->pipenum);\n\t\t\tdl_set = true;\n\t\t\tbreak;\n\t\tcase PIPEDIR_OUT:\n\t\t\tWARN_ON(ul_set);\n\t\t\t*ul_pipe = __le32_to_cpu(entry->pipenum);\n\t\t\tul_set = true;\n\t\t\tbreak;\n\t\tcase PIPEDIR_INOUT:\n\t\t\tWARN_ON(dl_set);\n\t\t\tWARN_ON(ul_set);\n\t\t\t*dl_pipe = __le32_to_cpu(entry->pipenum);\n\t\t\t*ul_pipe = __le32_to_cpu(entry->pipenum);\n\t\t\tdl_set = true;\n\t\t\tul_set = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (WARN_ON(!ul_set || !dl_set))\n\t\treturn -ENOENT;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ath11k_pcic_map_service_to_pipe);\n\nint ath11k_pcic_register_pci_ops(struct ath11k_base *ab,\n\t\t\t\t const struct ath11k_pci_ops *pci_ops)\n{\n\tif (!pci_ops)\n\t\treturn 0;\n\n\t \n\tif (!pci_ops->get_msi_irq || !pci_ops->window_write32 ||\n\t    !pci_ops->window_read32)\n\t\treturn -EINVAL;\n\n\tab->pci.ops = pci_ops;\n\treturn 0;\n}\nEXPORT_SYMBOL(ath11k_pcic_register_pci_ops);\n\nvoid ath11k_pci_enable_ce_irqs_except_wake_irq(struct ath11k_base *ab)\n{\n\tint i;\n\n\tfor (i = 0; i < ab->hw_params.ce_count; i++) {\n\t\tif (ath11k_ce_get_attr_flags(ab, i) & CE_ATTR_DIS_INTR ||\n\t\t    i == ATH11K_PCI_CE_WAKE_IRQ)\n\t\t\tcontinue;\n\t\tath11k_pcic_ce_irq_enable(ab, i);\n\t}\n}\nEXPORT_SYMBOL(ath11k_pci_enable_ce_irqs_except_wake_irq);\n\nvoid ath11k_pci_disable_ce_irqs_except_wake_irq(struct ath11k_base *ab)\n{\n\tint i;\n\tint irq_idx;\n\tstruct ath11k_ce_pipe *ce_pipe;\n\n\tfor (i = 0; i < ab->hw_params.ce_count; i++) {\n\t\tce_pipe = &ab->ce.ce_pipe[i];\n\t\tirq_idx = ATH11K_PCI_IRQ_CE0_OFFSET + i;\n\n\t\tif (ath11k_ce_get_attr_flags(ab, i) & CE_ATTR_DIS_INTR ||\n\t\t    i == ATH11K_PCI_CE_WAKE_IRQ)\n\t\t\tcontinue;\n\n\t\tdisable_irq_nosync(ab->irq_num[irq_idx]);\n\t\tsynchronize_irq(ab->irq_num[irq_idx]);\n\t\ttasklet_kill(&ce_pipe->intr_tq);\n\t}\n}\nEXPORT_SYMBOL(ath11k_pci_disable_ce_irqs_except_wake_irq);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}