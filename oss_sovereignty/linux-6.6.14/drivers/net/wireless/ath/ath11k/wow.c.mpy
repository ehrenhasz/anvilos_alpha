{
  "module_name": "wow.c",
  "hash_id": "78e310165161aafce604675fb730defe6889648557b25b8efc418cfefc1d8f7a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath11k/wow.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n\n#include \"mac.h\"\n\n#include <net/mac80211.h>\n#include \"core.h\"\n#include \"hif.h\"\n#include \"debug.h\"\n#include \"wmi.h\"\n#include \"wow.h\"\n#include \"dp_rx.h\"\n\nstatic const struct wiphy_wowlan_support ath11k_wowlan_support = {\n\t.flags = WIPHY_WOWLAN_DISCONNECT |\n\t\t WIPHY_WOWLAN_MAGIC_PKT |\n\t\t WIPHY_WOWLAN_SUPPORTS_GTK_REKEY |\n\t\t WIPHY_WOWLAN_GTK_REKEY_FAILURE,\n\t.pattern_min_len = WOW_MIN_PATTERN_SIZE,\n\t.pattern_max_len = WOW_MAX_PATTERN_SIZE,\n\t.max_pkt_offset = WOW_MAX_PKT_OFFSET,\n};\n\nint ath11k_wow_enable(struct ath11k_base *ab)\n{\n\tstruct ath11k *ar = ath11k_ab_to_ar(ab, 0);\n\tint i, ret;\n\n\tclear_bit(ATH11K_FLAG_HTC_SUSPEND_COMPLETE, &ab->dev_flags);\n\n\tfor (i = 0; i < ATH11K_WOW_RETRY_NUM; i++) {\n\t\treinit_completion(&ab->htc_suspend);\n\n\t\tret = ath11k_wmi_wow_enable(ar);\n\t\tif (ret) {\n\t\t\tath11k_warn(ab, \"failed to issue wow enable: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = wait_for_completion_timeout(&ab->htc_suspend, 3 * HZ);\n\t\tif (ret == 0) {\n\t\t\tath11k_warn(ab,\n\t\t\t\t    \"timed out while waiting for htc suspend completion\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\n\t\tif (test_bit(ATH11K_FLAG_HTC_SUSPEND_COMPLETE, &ab->dev_flags))\n\t\t\t \n\t\t\treturn 0;\n\n\t\tath11k_warn(ab, \"htc suspend not complete, retrying (try %d)\\n\",\n\t\t\t    i);\n\t\tmsleep(ATH11K_WOW_RETRY_WAIT_MS);\n\t}\n\n\tath11k_warn(ab, \"htc suspend not complete, failing after %d tries\\n\", i);\n\n\treturn -ETIMEDOUT;\n}\n\nint ath11k_wow_wakeup(struct ath11k_base *ab)\n{\n\tstruct ath11k *ar = ath11k_ab_to_ar(ab, 0);\n\tint ret;\n\n\t \n\tif (ab->hw_params.smp2p_wow_exit)\n\t\treturn 0;\n\n\treinit_completion(&ab->wow.wakeup_completed);\n\n\tret = ath11k_wmi_wow_host_wakeup_ind(ar);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to send wow wakeup indication: %d\\n\",\n\t\t\t    ret);\n\t\treturn ret;\n\t}\n\n\tret = wait_for_completion_timeout(&ab->wow.wakeup_completed, 3 * HZ);\n\tif (ret == 0) {\n\t\tath11k_warn(ab, \"timed out while waiting for wow wakeup completion\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath11k_wow_vif_cleanup(struct ath11k_vif *arvif)\n{\n\tstruct ath11k *ar = arvif->ar;\n\tint i, ret;\n\n\tfor (i = 0; i < WOW_EVENT_MAX; i++) {\n\t\tret = ath11k_wmi_wow_add_wakeup_event(ar, arvif->vdev_id, i, 0);\n\t\tif (ret) {\n\t\t\tath11k_warn(ar->ab, \"failed to issue wow wakeup for event %s on vdev %i: %d\\n\",\n\t\t\t\t    wow_wakeup_event(i), arvif->vdev_id, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tfor (i = 0; i < ar->wow.max_num_patterns; i++) {\n\t\tret = ath11k_wmi_wow_del_pattern(ar, arvif->vdev_id, i);\n\t\tif (ret) {\n\t\t\tath11k_warn(ar->ab, \"failed to delete wow pattern %d for vdev %i: %d\\n\",\n\t\t\t\t    i, arvif->vdev_id, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ath11k_wow_cleanup(struct ath11k *ar)\n{\n\tstruct ath11k_vif *arvif;\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tlist_for_each_entry(arvif, &ar->arvifs, list) {\n\t\tret = ath11k_wow_vif_cleanup(arvif);\n\t\tif (ret) {\n\t\t\tath11k_warn(ar->ab, \"failed to clean wow wakeups on vdev %i: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void ath11k_wow_convert_8023_to_80211(struct cfg80211_pkt_pattern *new,\n\t\t\t\t\t     const struct cfg80211_pkt_pattern *old)\n{\n\tu8 hdr_8023_pattern[ETH_HLEN] = {};\n\tu8 hdr_8023_bit_mask[ETH_HLEN] = {};\n\tu8 hdr_80211_pattern[WOW_HDR_LEN] = {};\n\tu8 hdr_80211_bit_mask[WOW_HDR_LEN] = {};\n\n\tint total_len = old->pkt_offset + old->pattern_len;\n\tint hdr_80211_end_offset;\n\n\tstruct ieee80211_hdr_3addr *new_hdr_pattern =\n\t\t(struct ieee80211_hdr_3addr *)hdr_80211_pattern;\n\tstruct ieee80211_hdr_3addr *new_hdr_mask =\n\t\t(struct ieee80211_hdr_3addr *)hdr_80211_bit_mask;\n\tstruct ethhdr *old_hdr_pattern = (struct ethhdr *)hdr_8023_pattern;\n\tstruct ethhdr *old_hdr_mask = (struct ethhdr *)hdr_8023_bit_mask;\n\tint hdr_len = sizeof(*new_hdr_pattern);\n\n\tstruct rfc1042_hdr *new_rfc_pattern =\n\t\t(struct rfc1042_hdr *)(hdr_80211_pattern + hdr_len);\n\tstruct rfc1042_hdr *new_rfc_mask =\n\t\t(struct rfc1042_hdr *)(hdr_80211_bit_mask + hdr_len);\n\tint rfc_len = sizeof(*new_rfc_pattern);\n\n\tmemcpy(hdr_8023_pattern + old->pkt_offset,\n\t       old->pattern, ETH_HLEN - old->pkt_offset);\n\tmemcpy(hdr_8023_bit_mask + old->pkt_offset,\n\t       old->mask, ETH_HLEN - old->pkt_offset);\n\n\t \n\tmemcpy(new_hdr_pattern->addr1, old_hdr_pattern->h_dest, ETH_ALEN);\n\tmemcpy(new_hdr_mask->addr1, old_hdr_mask->h_dest, ETH_ALEN);\n\n\t \n\tmemcpy(new_hdr_pattern->addr3, old_hdr_pattern->h_source, ETH_ALEN);\n\tmemcpy(new_hdr_mask->addr3, old_hdr_mask->h_source, ETH_ALEN);\n\n\t \n\tmemcpy(&new_rfc_pattern->snap_type,\n\t       &old_hdr_pattern->h_proto,\n\t       sizeof(old_hdr_pattern->h_proto));\n\tmemcpy(&new_rfc_mask->snap_type,\n\t       &old_hdr_mask->h_proto,\n\t       sizeof(old_hdr_mask->h_proto));\n\n\t \n\tif (old->pkt_offset < ETH_ALEN)\n\t\tnew->pkt_offset = old->pkt_offset +\n\t\t\toffsetof(struct ieee80211_hdr_3addr, addr1);\n\telse if (old->pkt_offset < offsetof(struct ethhdr, h_proto))\n\t\tnew->pkt_offset = old->pkt_offset +\n\t\t\toffsetof(struct ieee80211_hdr_3addr, addr3) -\n\t\t\toffsetof(struct ethhdr, h_source);\n\telse\n\t\tnew->pkt_offset = old->pkt_offset + hdr_len + rfc_len - ETH_HLEN;\n\n\t \n\tif (total_len > ETH_HLEN)\n\t\thdr_80211_end_offset = hdr_len + rfc_len;\n\telse if (total_len > offsetof(struct ethhdr, h_proto))\n\t\thdr_80211_end_offset = hdr_len + rfc_len + total_len - ETH_HLEN;\n\telse if (total_len > ETH_ALEN)\n\t\thdr_80211_end_offset = total_len - ETH_ALEN +\n\t\t\toffsetof(struct ieee80211_hdr_3addr, addr3);\n\telse\n\t\thdr_80211_end_offset = total_len +\n\t\t\toffsetof(struct ieee80211_hdr_3addr, addr1);\n\n\tnew->pattern_len = hdr_80211_end_offset - new->pkt_offset;\n\n\tmemcpy((u8 *)new->pattern,\n\t       hdr_80211_pattern + new->pkt_offset,\n\t       new->pattern_len);\n\tmemcpy((u8 *)new->mask,\n\t       hdr_80211_bit_mask + new->pkt_offset,\n\t       new->pattern_len);\n\n\tif (total_len > ETH_HLEN) {\n\t\t \n\t\tmemcpy((u8 *)new->pattern + new->pattern_len,\n\t\t       (void *)old->pattern + ETH_HLEN - old->pkt_offset,\n\t\t       total_len - ETH_HLEN);\n\t\tmemcpy((u8 *)new->mask + new->pattern_len,\n\t\t       (void *)old->mask + ETH_HLEN - old->pkt_offset,\n\t\t       total_len - ETH_HLEN);\n\n\t\tnew->pattern_len += total_len - ETH_HLEN;\n\t}\n}\n\nstatic int ath11k_wmi_pno_check_and_convert(struct ath11k *ar, u32 vdev_id,\n\t\t\t\t\t    struct cfg80211_sched_scan_request *nd_config,\n\t\t\t\t\t    struct wmi_pno_scan_req *pno)\n{\n\tint i, j;\n\tu8 ssid_len;\n\n\tpno->enable = 1;\n\tpno->vdev_id = vdev_id;\n\tpno->uc_networks_count = nd_config->n_match_sets;\n\n\tif (!pno->uc_networks_count ||\n\t    pno->uc_networks_count > WMI_PNO_MAX_SUPP_NETWORKS)\n\t\treturn -EINVAL;\n\n\tif (nd_config->n_channels > WMI_PNO_MAX_NETW_CHANNELS_EX)\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 0; i < pno->uc_networks_count; i++) {\n\t\tssid_len = nd_config->match_sets[i].ssid.ssid_len;\n\n\t\tif (ssid_len == 0 || ssid_len > 32)\n\t\t\treturn -EINVAL;\n\n\t\tpno->a_networks[i].ssid.ssid_len = ssid_len;\n\n\t\tmemcpy(pno->a_networks[i].ssid.ssid,\n\t\t       nd_config->match_sets[i].ssid.ssid,\n\t\t       nd_config->match_sets[i].ssid.ssid_len);\n\t\tpno->a_networks[i].authentication = 0;\n\t\tpno->a_networks[i].encryption     = 0;\n\t\tpno->a_networks[i].bcast_nw_type  = 0;\n\n\t\t \n\t\tpno->a_networks[i].channel_count = nd_config->n_channels;\n\t\tpno->a_networks[i].rssi_threshold = nd_config->match_sets[i].rssi_thold;\n\n\t\tfor (j = 0; j < nd_config->n_channels; j++) {\n\t\t\tpno->a_networks[i].channels[j] =\n\t\t\t\t\tnd_config->channels[j]->center_freq;\n\t\t}\n\t}\n\n\t \n\tif (nd_config->n_ssids == 0)\n\t\tpno->do_passive_scan = true;\n\telse\n\t\tpno->do_passive_scan = false;\n\n\tfor (i = 0; i < nd_config->n_ssids; i++) {\n\t\tj = 0;\n\t\twhile (j < pno->uc_networks_count) {\n\t\t\tif (pno->a_networks[j].ssid.ssid_len ==\n\t\t\t\tnd_config->ssids[i].ssid_len &&\n\t\t\t(memcmp(pno->a_networks[j].ssid.ssid,\n\t\t\t\tnd_config->ssids[i].ssid,\n\t\t\t\tpno->a_networks[j].ssid.ssid_len) == 0)) {\n\t\t\t\tpno->a_networks[j].bcast_nw_type = BCAST_HIDDEN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t}\n\n\tif (nd_config->n_scan_plans == 2) {\n\t\tpno->fast_scan_period = nd_config->scan_plans[0].interval * MSEC_PER_SEC;\n\t\tpno->fast_scan_max_cycles = nd_config->scan_plans[0].iterations;\n\t\tpno->slow_scan_period =\n\t\t\tnd_config->scan_plans[1].interval * MSEC_PER_SEC;\n\t} else if (nd_config->n_scan_plans == 1) {\n\t\tpno->fast_scan_period = nd_config->scan_plans[0].interval * MSEC_PER_SEC;\n\t\tpno->fast_scan_max_cycles = 1;\n\t\tpno->slow_scan_period = nd_config->scan_plans[0].interval * MSEC_PER_SEC;\n\t} else {\n\t\tath11k_warn(ar->ab, \"Invalid number of scan plans %d !!\",\n\t\t\t    nd_config->n_scan_plans);\n\t}\n\n\tif (nd_config->flags & NL80211_SCAN_FLAG_RANDOM_ADDR) {\n\t\t \n\t\tpno->enable_pno_scan_randomization = 1;\n\t\tmemcpy(pno->mac_addr, nd_config->mac_addr, ETH_ALEN);\n\t\tmemcpy(pno->mac_addr_mask, nd_config->mac_addr_mask, ETH_ALEN);\n\t}\n\n\tpno->delay_start_time = nd_config->delay;\n\n\t \n\tpno->active_max_time = WMI_ACTIVE_MAX_CHANNEL_TIME;\n\tpno->passive_max_time = WMI_PASSIVE_MAX_CHANNEL_TIME;\n\n\treturn 0;\n}\n\nstatic int ath11k_vif_wow_set_wakeups(struct ath11k_vif *arvif,\n\t\t\t\t      struct cfg80211_wowlan *wowlan)\n{\n\tint ret, i;\n\tunsigned long wow_mask = 0;\n\tstruct ath11k *ar = arvif->ar;\n\tconst struct cfg80211_pkt_pattern *patterns = wowlan->patterns;\n\tint pattern_id = 0;\n\n\t \n\tswitch (arvif->vdev_type) {\n\tcase WMI_VDEV_TYPE_IBSS:\n\t\t__set_bit(WOW_BEACON_EVENT, &wow_mask);\n\t\tfallthrough;\n\tcase WMI_VDEV_TYPE_AP:\n\t\t__set_bit(WOW_DEAUTH_RECVD_EVENT, &wow_mask);\n\t\t__set_bit(WOW_DISASSOC_RECVD_EVENT, &wow_mask);\n\t\t__set_bit(WOW_PROBE_REQ_WPS_IE_EVENT, &wow_mask);\n\t\t__set_bit(WOW_AUTH_REQ_EVENT, &wow_mask);\n\t\t__set_bit(WOW_ASSOC_REQ_EVENT, &wow_mask);\n\t\t__set_bit(WOW_HTT_EVENT, &wow_mask);\n\t\t__set_bit(WOW_RA_MATCH_EVENT, &wow_mask);\n\t\tbreak;\n\tcase WMI_VDEV_TYPE_STA:\n\t\tif (wowlan->disconnect) {\n\t\t\t__set_bit(WOW_DEAUTH_RECVD_EVENT, &wow_mask);\n\t\t\t__set_bit(WOW_DISASSOC_RECVD_EVENT, &wow_mask);\n\t\t\t__set_bit(WOW_BMISS_EVENT, &wow_mask);\n\t\t\t__set_bit(WOW_CSA_IE_EVENT, &wow_mask);\n\t\t}\n\n\t\tif (wowlan->magic_pkt)\n\t\t\t__set_bit(WOW_MAGIC_PKT_RECVD_EVENT, &wow_mask);\n\n\t\tif (wowlan->nd_config) {\n\t\t\tstruct wmi_pno_scan_req *pno;\n\t\t\tint ret;\n\n\t\t\tpno = kzalloc(sizeof(*pno), GFP_KERNEL);\n\t\t\tif (!pno)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tar->nlo_enabled = true;\n\n\t\t\tret = ath11k_wmi_pno_check_and_convert(ar, arvif->vdev_id,\n\t\t\t\t\t\t\t       wowlan->nd_config, pno);\n\t\t\tif (!ret) {\n\t\t\t\tath11k_wmi_wow_config_pno(ar, arvif->vdev_id, pno);\n\t\t\t\t__set_bit(WOW_NLO_DETECTED_EVENT, &wow_mask);\n\t\t\t}\n\n\t\t\tkfree(pno);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < wowlan->n_patterns; i++) {\n\t\tu8 bitmask[WOW_MAX_PATTERN_SIZE] = {};\n\t\tu8 ath_pattern[WOW_MAX_PATTERN_SIZE] = {};\n\t\tu8 ath_bitmask[WOW_MAX_PATTERN_SIZE] = {};\n\t\tstruct cfg80211_pkt_pattern new_pattern = {};\n\t\tstruct cfg80211_pkt_pattern old_pattern = patterns[i];\n\t\tint j;\n\n\t\tnew_pattern.pattern = ath_pattern;\n\t\tnew_pattern.mask = ath_bitmask;\n\t\tif (patterns[i].pattern_len > WOW_MAX_PATTERN_SIZE)\n\t\t\tcontinue;\n\t\t \n\t\tfor (j = 0; j < patterns[i].pattern_len; j++)\n\t\t\tif (patterns[i].mask[j / 8] & BIT(j % 8))\n\t\t\t\tbitmask[j] = 0xff;\n\t\told_pattern.mask = bitmask;\n\n\t\tif (ar->wmi->wmi_ab->wlan_resource_config.rx_decap_mode ==\n\t\t    ATH11K_HW_TXRX_NATIVE_WIFI) {\n\t\t\tif (patterns[i].pkt_offset < ETH_HLEN) {\n\t\t\t\tu8 pattern_ext[WOW_MAX_PATTERN_SIZE] = {};\n\n\t\t\t\tmemcpy(pattern_ext, old_pattern.pattern,\n\t\t\t\t       old_pattern.pattern_len);\n\t\t\t\told_pattern.pattern = pattern_ext;\n\t\t\t\tath11k_wow_convert_8023_to_80211(&new_pattern,\n\t\t\t\t\t\t\t\t &old_pattern);\n\t\t\t} else {\n\t\t\t\tnew_pattern = old_pattern;\n\t\t\t\tnew_pattern.pkt_offset += WOW_HDR_LEN - ETH_HLEN;\n\t\t\t}\n\t\t}\n\n\t\tif (WARN_ON(new_pattern.pattern_len > WOW_MAX_PATTERN_SIZE))\n\t\t\treturn -EINVAL;\n\n\t\tret = ath11k_wmi_wow_add_pattern(ar, arvif->vdev_id,\n\t\t\t\t\t\t pattern_id,\n\t\t\t\t\t\t new_pattern.pattern,\n\t\t\t\t\t\t new_pattern.mask,\n\t\t\t\t\t\t new_pattern.pattern_len,\n\t\t\t\t\t\t new_pattern.pkt_offset);\n\t\tif (ret) {\n\t\t\tath11k_warn(ar->ab, \"failed to add pattern %i to vdev %i: %d\\n\",\n\t\t\t\t    pattern_id,\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tpattern_id++;\n\t\t__set_bit(WOW_PATTERN_MATCH_EVENT, &wow_mask);\n\t}\n\n\tfor (i = 0; i < WOW_EVENT_MAX; i++) {\n\t\tif (!test_bit(i, &wow_mask))\n\t\t\tcontinue;\n\t\tret = ath11k_wmi_wow_add_wakeup_event(ar, arvif->vdev_id, i, 1);\n\t\tif (ret) {\n\t\t\tath11k_warn(ar->ab, \"failed to enable wakeup event %s on vdev %i: %d\\n\",\n\t\t\t\t    wow_wakeup_event(i), arvif->vdev_id, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ath11k_wow_set_wakeups(struct ath11k *ar,\n\t\t\t\t  struct cfg80211_wowlan *wowlan)\n{\n\tstruct ath11k_vif *arvif;\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tlist_for_each_entry(arvif, &ar->arvifs, list) {\n\t\tret = ath11k_vif_wow_set_wakeups(arvif, wowlan);\n\t\tif (ret) {\n\t\t\tath11k_warn(ar->ab, \"failed to set wow wakeups on vdev %i: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ath11k_vif_wow_clean_nlo(struct ath11k_vif *arvif)\n{\n\tint ret = 0;\n\tstruct ath11k *ar = arvif->ar;\n\n\tswitch (arvif->vdev_type) {\n\tcase WMI_VDEV_TYPE_STA:\n\t\tif (ar->nlo_enabled) {\n\t\t\tstruct wmi_pno_scan_req *pno;\n\n\t\t\tpno = kzalloc(sizeof(*pno), GFP_KERNEL);\n\t\t\tif (!pno)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tpno->enable = 0;\n\t\t\tar->nlo_enabled = false;\n\t\t\tret = ath11k_wmi_wow_config_pno(ar, arvif->vdev_id, pno);\n\t\t\tkfree(pno);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int ath11k_wow_nlo_cleanup(struct ath11k *ar)\n{\n\tstruct ath11k_vif *arvif;\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tlist_for_each_entry(arvif, &ar->arvifs, list) {\n\t\tret = ath11k_vif_wow_clean_nlo(arvif);\n\t\tif (ret) {\n\t\t\tath11k_warn(ar->ab, \"failed to clean nlo settings on vdev %i: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ath11k_wow_set_hw_filter(struct ath11k *ar)\n{\n\tstruct ath11k_vif *arvif;\n\tu32 bitmap;\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tlist_for_each_entry(arvif, &ar->arvifs, list) {\n\t\tbitmap = WMI_HW_DATA_FILTER_DROP_NON_ICMPV6_MC |\n\t\t\tWMI_HW_DATA_FILTER_DROP_NON_ARP_BC;\n\t\tret = ath11k_wmi_hw_data_filter_cmd(ar, arvif->vdev_id,\n\t\t\t\t\t\t    bitmap,\n\t\t\t\t\t\t    true);\n\t\tif (ret) {\n\t\t\tath11k_warn(ar->ab, \"failed to set hw data filter on vdev %i: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ath11k_wow_clear_hw_filter(struct ath11k *ar)\n{\n\tstruct ath11k_vif *arvif;\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tlist_for_each_entry(arvif, &ar->arvifs, list) {\n\t\tret = ath11k_wmi_hw_data_filter_cmd(ar, arvif->vdev_id, 0, false);\n\n\t\tif (ret) {\n\t\t\tath11k_warn(ar->ab, \"failed to clear hw data filter on vdev %i: %d\\n\",\n\t\t\t\t    arvif->vdev_id, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ath11k_wow_arp_ns_offload(struct ath11k *ar, bool enable)\n{\n\tstruct ath11k_vif *arvif;\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tlist_for_each_entry(arvif, &ar->arvifs, list) {\n\t\tif (arvif->vdev_type != WMI_VDEV_TYPE_STA)\n\t\t\tcontinue;\n\n\t\tret = ath11k_wmi_arp_ns_offload(ar, arvif, enable);\n\n\t\tif (ret) {\n\t\t\tath11k_warn(ar->ab, \"failed to set arp ns offload vdev %i: enable %d, ret %d\\n\",\n\t\t\t\t    arvif->vdev_id, enable, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ath11k_gtk_rekey_offload(struct ath11k *ar, bool enable)\n{\n\tstruct ath11k_vif *arvif;\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tlist_for_each_entry(arvif, &ar->arvifs, list) {\n\t\tif (arvif->vdev_type != WMI_VDEV_TYPE_STA ||\n\t\t    !arvif->is_up ||\n\t\t    !arvif->rekey_data.enable_offload)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!enable) {\n\t\t\tret = ath11k_wmi_gtk_rekey_getinfo(ar, arvif);\n\t\t\tif (ret) {\n\t\t\t\tath11k_warn(ar->ab, \"failed to request rekey info vdev %i, ret %d\\n\",\n\t\t\t\t\t    arvif->vdev_id, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tret = ath11k_wmi_gtk_rekey_offload(ar, arvif, enable);\n\n\t\tif (ret) {\n\t\t\tath11k_warn(ar->ab, \"failed to offload gtk reky vdev %i: enable %d, ret %d\\n\",\n\t\t\t\t    arvif->vdev_id, enable, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ath11k_wow_protocol_offload(struct ath11k *ar, bool enable)\n{\n\tint ret;\n\n\tret = ath11k_wow_arp_ns_offload(ar, enable);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to offload ARP and NS %d %d\\n\",\n\t\t\t    enable, ret);\n\t\treturn ret;\n\t}\n\n\tret = ath11k_gtk_rekey_offload(ar, enable);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to offload gtk rekey %d %d\\n\",\n\t\t\t    enable, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath11k_wow_set_keepalive(struct ath11k *ar,\n\t\t\t\t    enum wmi_sta_keepalive_method method,\n\t\t\t\t    u32 interval)\n{\n\tstruct ath11k_vif *arvif;\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tlist_for_each_entry(arvif, &ar->arvifs, list) {\n\t\tret = ath11k_mac_vif_set_keepalive(arvif, method, interval);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint ath11k_wow_op_suspend(struct ieee80211_hw *hw,\n\t\t\t  struct cfg80211_wowlan *wowlan)\n{\n\tstruct ath11k *ar = hw->priv;\n\tint ret;\n\n\tret = ath11k_mac_wait_tx_complete(ar);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to wait tx complete: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tret = ath11k_dp_rx_pktlog_stop(ar->ab, true);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to stop dp rx (and timer) pktlog during wow suspend: %d\\n\",\n\t\t\t    ret);\n\t\tgoto exit;\n\t}\n\n\tret =  ath11k_wow_cleanup(ar);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to clear wow wakeup events: %d\\n\",\n\t\t\t    ret);\n\t\tgoto exit;\n\t}\n\n\tret = ath11k_wow_set_wakeups(ar, wowlan);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to set wow wakeup events: %d\\n\",\n\t\t\t    ret);\n\t\tgoto cleanup;\n\t}\n\n\tret = ath11k_wow_protocol_offload(ar, true);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to set wow protocol offload events: %d\\n\",\n\t\t\t    ret);\n\t\tgoto cleanup;\n\t}\n\n\tret = ath11k_wow_set_hw_filter(ar);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to set hw filter: %d\\n\",\n\t\t\t    ret);\n\t\tgoto cleanup;\n\t}\n\n\tret = ath11k_wow_set_keepalive(ar,\n\t\t\t\t       WMI_STA_KEEPALIVE_METHOD_NULL_FRAME,\n\t\t\t\t       WMI_STA_KEEPALIVE_INTERVAL_DEFAULT);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to enable wow keepalive: %d\\n\", ret);\n\t\tgoto cleanup;\n\t}\n\n\tret = ath11k_wow_enable(ar->ab);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to start wow: %d\\n\", ret);\n\t\tgoto cleanup;\n\t}\n\n\tret = ath11k_dp_rx_pktlog_stop(ar->ab, false);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to stop dp rx pktlog during wow suspend: %d\\n\",\n\t\t\t    ret);\n\t\tgoto cleanup;\n\t}\n\n\tath11k_ce_stop_shadow_timers(ar->ab);\n\tath11k_dp_stop_shadow_timers(ar->ab);\n\n\tath11k_hif_irq_disable(ar->ab);\n\tath11k_hif_ce_irq_disable(ar->ab);\n\n\tret = ath11k_hif_suspend(ar->ab);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to suspend hif: %d\\n\", ret);\n\t\tgoto wakeup;\n\t}\n\n\tgoto exit;\n\nwakeup:\n\tath11k_wow_wakeup(ar->ab);\n\ncleanup:\n\tath11k_wow_cleanup(ar);\n\nexit:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret ? 1 : 0;\n}\n\nvoid ath11k_wow_op_set_wakeup(struct ieee80211_hw *hw, bool enabled)\n{\n\tstruct ath11k *ar = hw->priv;\n\n\tmutex_lock(&ar->conf_mutex);\n\tdevice_set_wakeup_enable(ar->ab->dev, enabled);\n\tmutex_unlock(&ar->conf_mutex);\n}\n\nint ath11k_wow_op_resume(struct ieee80211_hw *hw)\n{\n\tstruct ath11k *ar = hw->priv;\n\tint ret;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tret = ath11k_hif_resume(ar->ab);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to resume hif: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tath11k_hif_ce_irq_enable(ar->ab);\n\tath11k_hif_irq_enable(ar->ab);\n\n\tret = ath11k_dp_rx_pktlog_start(ar->ab);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to start rx pktlog from wow: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tret = ath11k_wow_wakeup(ar->ab);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to wakeup from wow: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tret = ath11k_wow_nlo_cleanup(ar);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to cleanup nlo: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tret = ath11k_wow_clear_hw_filter(ar);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to clear hw filter: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tret = ath11k_wow_protocol_offload(ar, false);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to clear wow protocol offload events: %d\\n\",\n\t\t\t    ret);\n\t\tgoto exit;\n\t}\n\n\tret = ath11k_wow_set_keepalive(ar,\n\t\t\t\t       WMI_STA_KEEPALIVE_METHOD_NULL_FRAME,\n\t\t\t\t       WMI_STA_KEEPALIVE_INTERVAL_DISABLE);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to disable wow keepalive: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\nexit:\n\tif (ret) {\n\t\tswitch (ar->state) {\n\t\tcase ATH11K_STATE_ON:\n\t\t\tar->state = ATH11K_STATE_RESTARTING;\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\tcase ATH11K_STATE_OFF:\n\t\tcase ATH11K_STATE_RESTARTING:\n\t\tcase ATH11K_STATE_RESTARTED:\n\t\tcase ATH11K_STATE_WEDGED:\n\t\tcase ATH11K_STATE_FTM:\n\t\t\tath11k_warn(ar->ab, \"encountered unexpected device state %d on resume, cannot recover\\n\",\n\t\t\t\t    ar->state);\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nint ath11k_wow_init(struct ath11k *ar)\n{\n\tif (!test_bit(WMI_TLV_SERVICE_WOW, ar->wmi->wmi_ab->svc_map))\n\t\treturn 0;\n\n\tar->wow.wowlan_support = ath11k_wowlan_support;\n\n\tif (ar->wmi->wmi_ab->wlan_resource_config.rx_decap_mode ==\n\t    ATH11K_HW_TXRX_NATIVE_WIFI) {\n\t\tar->wow.wowlan_support.pattern_max_len -= WOW_MAX_REDUCE;\n\t\tar->wow.wowlan_support.max_pkt_offset -= WOW_MAX_REDUCE;\n\t}\n\n\tif (test_bit(WMI_TLV_SERVICE_NLO, ar->wmi->wmi_ab->svc_map)) {\n\t\tar->wow.wowlan_support.flags |= WIPHY_WOWLAN_NET_DETECT;\n\t\tar->wow.wowlan_support.max_nd_match_sets = WMI_PNO_MAX_SUPP_NETWORKS;\n\t}\n\n\tar->wow.max_num_patterns = ATH11K_WOW_PATTERNS;\n\tar->wow.wowlan_support.n_patterns = ar->wow.max_num_patterns;\n\tar->hw->wiphy->wowlan = &ar->wow.wowlan_support;\n\n\tdevice_set_wakeup_capable(ar->ab->dev, true);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}