{
  "module_name": "testmode.c",
  "hash_id": "cfb7c9285dbb38d619a38b7eb2bdea8ef2c7320c3e81d80e2c3109810fa9d703",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath11k/testmode.c",
  "human_readable_source": "\n \n\n#include \"testmode.h\"\n#include <net/netlink.h>\n#include \"debug.h\"\n#include \"wmi.h\"\n#include \"hw.h\"\n#include \"core.h\"\n#include \"testmode_i.h\"\n\n#define ATH11K_FTM_SEGHDR_CURRENT_SEQ\t\tGENMASK(3, 0)\n#define ATH11K_FTM_SEGHDR_TOTAL_SEGMENTS\tGENMASK(7, 4)\n\nstatic const struct nla_policy ath11k_tm_policy[ATH11K_TM_ATTR_MAX + 1] = {\n\t[ATH11K_TM_ATTR_CMD]\t\t= { .type = NLA_U32 },\n\t[ATH11K_TM_ATTR_DATA]\t\t= { .type = NLA_BINARY,\n\t\t\t\t\t    .len = ATH11K_TM_DATA_MAX_LEN },\n\t[ATH11K_TM_ATTR_WMI_CMDID]\t= { .type = NLA_U32 },\n\t[ATH11K_TM_ATTR_VERSION_MAJOR]\t= { .type = NLA_U32 },\n\t[ATH11K_TM_ATTR_VERSION_MINOR]\t= { .type = NLA_U32 },\n};\n\nstatic struct ath11k *ath11k_tm_get_ar(struct ath11k_base *ab)\n{\n\tstruct ath11k_pdev *pdev;\n\tstruct ath11k *ar = NULL;\n\tint i;\n\n\tfor (i = 0; i < ab->num_radios; i++) {\n\t\tpdev = &ab->pdevs[i];\n\t\tar = pdev->ar;\n\n\t\tif (ar && ar->state == ATH11K_STATE_FTM)\n\t\t\tbreak;\n\t}\n\n\treturn ar;\n}\n\n \nstatic void ath11k_tm_wmi_event_unsegmented(struct ath11k_base *ab, u32 cmd_id,\n\t\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct sk_buff *nl_skb;\n\tstruct ath11k *ar;\n\n\tath11k_dbg(ab, ATH11K_DBG_TESTMODE,\n\t\t   \"event wmi cmd_id %d skb length %d\\n\",\n\t\t   cmd_id, skb->len);\n\tath11k_dbg_dump(ab, ATH11K_DBG_TESTMODE, NULL, \"\", skb->data, skb->len);\n\n\tar = ath11k_tm_get_ar(ab);\n\tif (!ar) {\n\t\tath11k_warn(ab, \"testmode event not handled due to invalid pdev\\n\");\n\t\treturn;\n\t}\n\n\tspin_lock_bh(&ar->data_lock);\n\n\tnl_skb = cfg80211_testmode_alloc_event_skb(ar->hw->wiphy,\n\t\t\t\t\t\t   2 * nla_total_size(sizeof(u32)) +\n\t\t\t\t\t\t   nla_total_size(skb->len),\n\t\t\t\t\t\t   GFP_ATOMIC);\n\tif (!nl_skb) {\n\t\tath11k_warn(ab,\n\t\t\t    \"failed to allocate skb for unsegmented testmode wmi event\\n\");\n\t\tgoto out;\n\t}\n\n\tif (nla_put_u32(nl_skb, ATH11K_TM_ATTR_CMD, ATH11K_TM_CMD_WMI) ||\n\t    nla_put_u32(nl_skb, ATH11K_TM_ATTR_WMI_CMDID, cmd_id) ||\n\t    nla_put(nl_skb, ATH11K_TM_ATTR_DATA, skb->len, skb->data)) {\n\t\tath11k_warn(ab, \"failed to populate testmode unsegmented event\\n\");\n\t\tkfree_skb(nl_skb);\n\t\tgoto out;\n\t}\n\n\tcfg80211_testmode_event(nl_skb, GFP_ATOMIC);\n\tspin_unlock_bh(&ar->data_lock);\n\treturn;\n\nout:\n\tspin_unlock_bh(&ar->data_lock);\n\tath11k_warn(ab, \"Failed to send testmode event to higher layers\\n\");\n}\n\n \nstatic int ath11k_tm_process_event(struct ath11k_base *ab, u32 cmd_id,\n\t\t\t\t   const struct wmi_ftm_event_msg *ftm_msg,\n\t\t\t\t   u16 length)\n{\n\tstruct sk_buff *nl_skb;\n\tint ret = 0;\n\tstruct ath11k *ar;\n\tu8 const *buf_pos;\n\tu16 datalen;\n\tu8 total_segments, current_seq;\n\tu32 data_pos;\n\tu32 pdev_id;\n\n\tath11k_dbg(ab, ATH11K_DBG_TESTMODE,\n\t\t   \"event wmi cmd_id %d ftm event msg %pK datalen %d\\n\",\n\t\t   cmd_id, ftm_msg, length);\n\tath11k_dbg_dump(ab, ATH11K_DBG_TESTMODE, NULL, \"\", ftm_msg, length);\n\tpdev_id = DP_HW2SW_MACID(ftm_msg->seg_hdr.pdev_id);\n\n\tif (pdev_id >= ab->num_radios) {\n\t\tath11k_warn(ab, \"testmode event not handled due to invalid pdev id: %d\\n\",\n\t\t\t    pdev_id);\n\t\treturn -EINVAL;\n\t}\n\n\tar = ab->pdevs[pdev_id].ar;\n\tif (!ar) {\n\t\tath11k_warn(ab, \"testmode event not handled due to absence of pdev\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tcurrent_seq = FIELD_GET(ATH11K_FTM_SEGHDR_CURRENT_SEQ,\n\t\t\t\tftm_msg->seg_hdr.segmentinfo);\n\ttotal_segments = FIELD_GET(ATH11K_FTM_SEGHDR_TOTAL_SEGMENTS,\n\t\t\t\t   ftm_msg->seg_hdr.segmentinfo);\n\tdatalen = length - (sizeof(struct wmi_ftm_seg_hdr));\n\tbuf_pos = ftm_msg->data;\n\n\tspin_lock_bh(&ar->data_lock);\n\n\tif (current_seq == 0) {\n\t\tab->testmode.expected_seq = 0;\n\t\tab->testmode.data_pos = 0;\n\t}\n\n\tdata_pos = ab->testmode.data_pos;\n\n\tif ((data_pos + datalen) > ATH11K_FTM_EVENT_MAX_BUF_LENGTH) {\n\t\tath11k_warn(ab, \"Invalid ftm event length at %d: %d\\n\",\n\t\t\t    data_pos, datalen);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmemcpy(&ab->testmode.eventdata[data_pos], buf_pos, datalen);\n\tdata_pos += datalen;\n\n\tif (++ab->testmode.expected_seq != total_segments) {\n\t\tab->testmode.data_pos = data_pos;\n\t\tath11k_dbg(ab, ATH11K_DBG_TESTMODE,\n\t\t\t   \"partial data received current_seq %d total_seg %d\\n\",\n\t\t\t    current_seq, total_segments);\n\t\tgoto out;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_TESTMODE,\n\t\t   \"total data length pos %d len %d\\n\",\n\t\t    data_pos, ftm_msg->seg_hdr.len);\n\tnl_skb = cfg80211_testmode_alloc_event_skb(ar->hw->wiphy,\n\t\t\t\t\t\t   2 * nla_total_size(sizeof(u32)) +\n\t\t\t\t\t\t   nla_total_size(data_pos),\n\t\t\t\t\t\t   GFP_ATOMIC);\n\tif (!nl_skb) {\n\t\tath11k_warn(ab,\n\t\t\t    \"failed to allocate skb for segmented testmode wmi event\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tif (nla_put_u32(nl_skb, ATH11K_TM_ATTR_CMD,\n\t\t\tATH11K_TM_CMD_WMI_FTM) ||\n\t    nla_put_u32(nl_skb, ATH11K_TM_ATTR_WMI_CMDID, cmd_id) ||\n\t    nla_put(nl_skb, ATH11K_TM_ATTR_DATA, data_pos,\n\t\t    &ab->testmode.eventdata[0])) {\n\t\tath11k_warn(ab, \"failed to populate segmented testmode event\");\n\t\tkfree_skb(nl_skb);\n\t\tret = -ENOBUFS;\n\t\tgoto out;\n\t}\n\n\tcfg80211_testmode_event(nl_skb, GFP_ATOMIC);\n\nout:\n\tspin_unlock_bh(&ar->data_lock);\n\treturn ret;\n}\n\nstatic void ath11k_tm_wmi_event_segmented(struct ath11k_base *ab, u32 cmd_id,\n\t\t\t\t\t  struct sk_buff *skb)\n{\n\tconst void **tb;\n\tconst struct wmi_ftm_event_msg *ev;\n\tu16 length;\n\tint ret;\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab, \"failed to parse ftm event tlv: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tev = tb[WMI_TAG_ARRAY_BYTE];\n\tif (!ev) {\n\t\tath11k_warn(ab, \"failed to fetch ftm msg\\n\");\n\t\tkfree(tb);\n\t\treturn;\n\t}\n\n\tlength = skb->len - TLV_HDR_SIZE;\n\tret = ath11k_tm_process_event(ab, cmd_id, ev, length);\n\tif (ret)\n\t\tath11k_warn(ab, \"Failed to process ftm event\\n\");\n\n\tkfree(tb);\n}\n\nvoid ath11k_tm_wmi_event(struct ath11k_base *ab, u32 cmd_id, struct sk_buff *skb)\n{\n\tif (test_bit(ATH11K_FLAG_FTM_SEGMENTED, &ab->dev_flags))\n\t\tath11k_tm_wmi_event_segmented(ab, cmd_id, skb);\n\telse\n\t\tath11k_tm_wmi_event_unsegmented(ab, cmd_id, skb);\n}\n\nstatic int ath11k_tm_cmd_get_version(struct ath11k *ar, struct nlattr *tb[])\n{\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_TESTMODE,\n\t\t   \"cmd get version_major %d version_minor %d\\n\",\n\t\t   ATH11K_TESTMODE_VERSION_MAJOR,\n\t\t   ATH11K_TESTMODE_VERSION_MINOR);\n\n\tskb = cfg80211_testmode_alloc_reply_skb(ar->hw->wiphy,\n\t\t\t\t\t\tnla_total_size(sizeof(u32)));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tret = nla_put_u32(skb, ATH11K_TM_ATTR_VERSION_MAJOR,\n\t\t\t  ATH11K_TESTMODE_VERSION_MAJOR);\n\tif (ret) {\n\t\tkfree_skb(skb);\n\t\treturn ret;\n\t}\n\n\tret = nla_put_u32(skb, ATH11K_TM_ATTR_VERSION_MINOR,\n\t\t\t  ATH11K_TESTMODE_VERSION_MINOR);\n\tif (ret) {\n\t\tkfree_skb(skb);\n\t\treturn ret;\n\t}\n\n\treturn cfg80211_testmode_reply(skb);\n}\n\nstatic int ath11k_tm_cmd_testmode_start(struct ath11k *ar, struct nlattr *tb[])\n{\n\tint ret;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (ar->state == ATH11K_STATE_FTM) {\n\t\tret = -EALREADY;\n\t\tgoto err;\n\t}\n\n\t \n\tif (ar->state != ATH11K_STATE_OFF) {\n\t\tret = -EBUSY;\n\t\tgoto err;\n\t}\n\n\tar->ab->testmode.eventdata = kzalloc(ATH11K_FTM_EVENT_MAX_BUF_LENGTH,\n\t\t\t\t\t     GFP_KERNEL);\n\tif (!ar->ab->testmode.eventdata) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tar->state = ATH11K_STATE_FTM;\n\tar->ftm_msgref = 0;\n\n\tmutex_unlock(&ar->conf_mutex);\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_TESTMODE, \"cmd start\\n\");\n\treturn 0;\n\nerr:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic int ath11k_tm_cmd_wmi(struct ath11k *ar, struct nlattr *tb[],\n\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct sk_buff *skb;\n\tstruct ath11k_vif *arvif;\n\tu32 cmd_id, buf_len;\n\tint ret, tag;\n\tvoid *buf;\n\tu32 *ptr;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (!tb[ATH11K_TM_ATTR_DATA]) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (!tb[ATH11K_TM_ATTR_WMI_CMDID]) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbuf = nla_data(tb[ATH11K_TM_ATTR_DATA]);\n\tbuf_len = nla_len(tb[ATH11K_TM_ATTR_DATA]);\n\tif (!buf_len) {\n\t\tath11k_warn(ar->ab, \"No data present in testmode wmi command\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tcmd_id = nla_get_u32(tb[ATH11K_TM_ATTR_WMI_CMDID]);\n\n\t \n\tif (buf_len < sizeof(struct wmi_tlv) + sizeof(u32)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tptr = buf;\n\ttag = FIELD_GET(WMI_TLV_TAG, *ptr);\n\n\t \n\tptr++;\n\n\tif (tag == WMI_TAG_PDEV_SET_PARAM_CMD)\n\t\t*ptr = ar->pdev->pdev_id;\n\n\tif (ar->ab->fw_mode != ATH11K_FIRMWARE_MODE_FTM &&\n\t    (tag == WMI_TAG_VDEV_SET_PARAM_CMD || tag == WMI_TAG_UNIT_TEST_CMD)) {\n\t\tif (vif) {\n\t\t\tarvif = ath11k_vif_to_arvif(vif);\n\t\t\t*ptr = arvif->vdev_id;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_TESTMODE,\n\t\t   \"cmd wmi cmd_id %d buf length %d\\n\",\n\t\t   cmd_id, buf_len);\n\n\tath11k_dbg_dump(ar->ab, ATH11K_DBG_TESTMODE, NULL, \"\", buf, buf_len);\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, buf_len);\n\tif (!skb) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmemcpy(skb->data, buf, buf_len);\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, cmd_id);\n\tif (ret) {\n\t\tdev_kfree_skb(skb);\n\t\tath11k_warn(ar->ab, \"failed to transmit wmi command (testmode): %d\\n\",\n\t\t\t    ret);\n\t\tgoto out;\n\t}\n\n\tret = 0;\n\nout:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic int ath11k_tm_cmd_wmi_ftm(struct ath11k *ar, struct nlattr *tb[])\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct ath11k_base *ab = ar->ab;\n\tstruct sk_buff *skb;\n\tu32 cmd_id, buf_len, hdr_info;\n\tint ret;\n\tvoid *buf;\n\tu8 segnumber = 0, seginfo;\n\tu16 chunk_len, total_bytes, num_segments;\n\tu8 *bufpos;\n\tstruct wmi_ftm_cmd *ftm_cmd;\n\n\tset_bit(ATH11K_FLAG_FTM_SEGMENTED, &ab->dev_flags);\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (ar->state != ATH11K_STATE_FTM) {\n\t\tret = -ENETDOWN;\n\t\tgoto out;\n\t}\n\n\tif (!tb[ATH11K_TM_ATTR_DATA]) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tbuf = nla_data(tb[ATH11K_TM_ATTR_DATA]);\n\tbuf_len = nla_len(tb[ATH11K_TM_ATTR_DATA]);\n\tcmd_id = WMI_PDEV_UTF_CMDID;\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_TESTMODE,\n\t\t   \"cmd wmi ftm cmd_id %d buffer length %d\\n\",\n\t\t   cmd_id, buf_len);\n\tath11k_dbg_dump(ar->ab, ATH11K_DBG_TESTMODE, NULL, \"\", buf, buf_len);\n\n\tbufpos = buf;\n\ttotal_bytes = buf_len;\n\tnum_segments = total_bytes / MAX_WMI_UTF_LEN;\n\n\tif (buf_len - (num_segments * MAX_WMI_UTF_LEN))\n\t\tnum_segments++;\n\n\twhile (buf_len) {\n\t\tchunk_len = min_t(u16, buf_len, MAX_WMI_UTF_LEN);\n\n\t\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, (chunk_len +\n\t\t\t\t\t   sizeof(struct wmi_ftm_cmd)));\n\t\tif (!skb) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tftm_cmd = (struct wmi_ftm_cmd *)skb->data;\n\t\thdr_info = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_BYTE) |\n\t\t\t   FIELD_PREP(WMI_TLV_LEN, (chunk_len +\n\t\t\t\t      sizeof(struct wmi_ftm_seg_hdr)));\n\t\tftm_cmd->tlv_header = hdr_info;\n\t\tftm_cmd->seg_hdr.len = total_bytes;\n\t\tftm_cmd->seg_hdr.msgref = ar->ftm_msgref;\n\t\tseginfo = FIELD_PREP(ATH11K_FTM_SEGHDR_TOTAL_SEGMENTS, num_segments) |\n\t\t\t  FIELD_PREP(ATH11K_FTM_SEGHDR_CURRENT_SEQ, segnumber);\n\t\tftm_cmd->seg_hdr.segmentinfo = seginfo;\n\t\tsegnumber++;\n\n\t\tmemcpy(&ftm_cmd->data, bufpos, chunk_len);\n\n\t\tret = ath11k_wmi_cmd_send(wmi, skb, cmd_id);\n\t\tif (ret) {\n\t\t\tath11k_warn(ar->ab, \"failed to send wmi ftm command: %d\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tbuf_len -= chunk_len;\n\t\tbufpos += chunk_len;\n\t}\n\n\tar->ftm_msgref++;\n\tret = 0;\n\nout:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nint ath11k_tm_cmd(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t  void *data, int len)\n{\n\tstruct ath11k *ar = hw->priv;\n\tstruct nlattr *tb[ATH11K_TM_ATTR_MAX + 1];\n\tint ret;\n\n\tret = nla_parse(tb, ATH11K_TM_ATTR_MAX, data, len, ath11k_tm_policy,\n\t\t\tNULL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!tb[ATH11K_TM_ATTR_CMD])\n\t\treturn -EINVAL;\n\n\tswitch (nla_get_u32(tb[ATH11K_TM_ATTR_CMD])) {\n\tcase ATH11K_TM_CMD_GET_VERSION:\n\t\treturn ath11k_tm_cmd_get_version(ar, tb);\n\tcase ATH11K_TM_CMD_WMI:\n\t\treturn ath11k_tm_cmd_wmi(ar, tb, vif);\n\tcase ATH11K_TM_CMD_TESTMODE_START:\n\t\treturn ath11k_tm_cmd_testmode_start(ar, tb);\n\tcase ATH11K_TM_CMD_WMI_FTM:\n\t\treturn ath11k_tm_cmd_wmi_ftm(ar, tb);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}