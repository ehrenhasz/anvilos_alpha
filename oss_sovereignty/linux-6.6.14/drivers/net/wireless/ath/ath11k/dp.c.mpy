{
  "module_name": "dp.c",
  "hash_id": "2cb78f68f59dd6e54899c7ccab143d062b750be38cbc70737166719b3c7a80fa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath11k/dp.c",
  "human_readable_source": "\n \n\n#include <crypto/hash.h>\n#include \"core.h\"\n#include \"dp_tx.h\"\n#include \"hal_tx.h\"\n#include \"hif.h\"\n#include \"debug.h\"\n#include \"dp_rx.h\"\n#include \"peer.h\"\n\nstatic void ath11k_dp_htt_htc_tx_complete(struct ath11k_base *ab,\n\t\t\t\t\t  struct sk_buff *skb)\n{\n\tdev_kfree_skb_any(skb);\n}\n\nvoid ath11k_dp_peer_cleanup(struct ath11k *ar, int vdev_id, const u8 *addr)\n{\n\tstruct ath11k_base *ab = ar->ab;\n\tstruct ath11k_peer *peer;\n\n\t \n\n\tspin_lock_bh(&ab->base_lock);\n\tpeer = ath11k_peer_find(ab, vdev_id, addr);\n\tif (!peer) {\n\t\tath11k_warn(ab, \"failed to lookup peer %pM on vdev %d\\n\",\n\t\t\t    addr, vdev_id);\n\t\tspin_unlock_bh(&ab->base_lock);\n\t\treturn;\n\t}\n\n\tath11k_peer_rx_tid_cleanup(ar, peer);\n\tpeer->dp_setup_done = false;\n\tcrypto_free_shash(peer->tfm_mmic);\n\tspin_unlock_bh(&ab->base_lock);\n}\n\nint ath11k_dp_peer_setup(struct ath11k *ar, int vdev_id, const u8 *addr)\n{\n\tstruct ath11k_base *ab = ar->ab;\n\tstruct ath11k_peer *peer;\n\tu32 reo_dest;\n\tint ret = 0, tid;\n\n\t \n\treo_dest = ar->dp.mac_id + 1;\n\tret = ath11k_wmi_set_peer_param(ar, addr, vdev_id,\n\t\t\t\t\tWMI_PEER_SET_DEFAULT_ROUTING,\n\t\t\t\t\tDP_RX_HASH_ENABLE | (reo_dest << 1));\n\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to set default routing %d peer :%pM vdev_id :%d\\n\",\n\t\t\t    ret, addr, vdev_id);\n\t\treturn ret;\n\t}\n\n\tfor (tid = 0; tid <= IEEE80211_NUM_TIDS; tid++) {\n\t\tret = ath11k_peer_rx_tid_setup(ar, addr, vdev_id, tid, 1, 0,\n\t\t\t\t\t       HAL_PN_TYPE_NONE);\n\t\tif (ret) {\n\t\t\tath11k_warn(ab, \"failed to setup rxd tid queue for tid %d: %d\\n\",\n\t\t\t\t    tid, ret);\n\t\t\tgoto peer_clean;\n\t\t}\n\t}\n\n\tret = ath11k_peer_rx_frag_setup(ar, addr, vdev_id);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to setup rx defrag context\\n\");\n\t\ttid--;\n\t\tgoto peer_clean;\n\t}\n\n\t \n\n\treturn 0;\n\npeer_clean:\n\tspin_lock_bh(&ab->base_lock);\n\n\tpeer = ath11k_peer_find(ab, vdev_id, addr);\n\tif (!peer) {\n\t\tath11k_warn(ab, \"failed to find the peer to del rx tid\\n\");\n\t\tspin_unlock_bh(&ab->base_lock);\n\t\treturn -ENOENT;\n\t}\n\n\tfor (; tid >= 0; tid--)\n\t\tath11k_peer_rx_tid_delete(ar, peer, tid);\n\n\tspin_unlock_bh(&ab->base_lock);\n\n\treturn ret;\n}\n\nvoid ath11k_dp_srng_cleanup(struct ath11k_base *ab, struct dp_srng *ring)\n{\n\tif (!ring->vaddr_unaligned)\n\t\treturn;\n\n\tif (ring->cached)\n\t\tkfree(ring->vaddr_unaligned);\n\telse\n\t\tdma_free_coherent(ab->dev, ring->size, ring->vaddr_unaligned,\n\t\t\t\t  ring->paddr_unaligned);\n\n\tring->vaddr_unaligned = NULL;\n}\n\nstatic int ath11k_dp_srng_find_ring_in_mask(int ring_num, const u8 *grp_mask)\n{\n\tint ext_group_num;\n\tu8 mask = 1 << ring_num;\n\n\tfor (ext_group_num = 0; ext_group_num < ATH11K_EXT_IRQ_GRP_NUM_MAX;\n\t     ext_group_num++) {\n\t\tif (mask & grp_mask[ext_group_num])\n\t\t\treturn ext_group_num;\n\t}\n\n\treturn -ENOENT;\n}\n\nstatic int ath11k_dp_srng_calculate_msi_group(struct ath11k_base *ab,\n\t\t\t\t\t      enum hal_ring_type type, int ring_num)\n{\n\tconst u8 *grp_mask;\n\n\tswitch (type) {\n\tcase HAL_WBM2SW_RELEASE:\n\t\tif (ring_num == DP_RX_RELEASE_RING_NUM) {\n\t\t\tgrp_mask = &ab->hw_params.ring_mask->rx_wbm_rel[0];\n\t\t\tring_num = 0;\n\t\t} else {\n\t\t\tgrp_mask = &ab->hw_params.ring_mask->tx[0];\n\t\t}\n\t\tbreak;\n\tcase HAL_REO_EXCEPTION:\n\t\tgrp_mask = &ab->hw_params.ring_mask->rx_err[0];\n\t\tbreak;\n\tcase HAL_REO_DST:\n\t\tgrp_mask = &ab->hw_params.ring_mask->rx[0];\n\t\tbreak;\n\tcase HAL_REO_STATUS:\n\t\tgrp_mask = &ab->hw_params.ring_mask->reo_status[0];\n\t\tbreak;\n\tcase HAL_RXDMA_MONITOR_STATUS:\n\tcase HAL_RXDMA_MONITOR_DST:\n\t\tgrp_mask = &ab->hw_params.ring_mask->rx_mon_status[0];\n\t\tbreak;\n\tcase HAL_RXDMA_DST:\n\t\tgrp_mask = &ab->hw_params.ring_mask->rxdma2host[0];\n\t\tbreak;\n\tcase HAL_RXDMA_BUF:\n\t\tgrp_mask = &ab->hw_params.ring_mask->host2rxdma[0];\n\t\tbreak;\n\tcase HAL_RXDMA_MONITOR_BUF:\n\tcase HAL_TCL_DATA:\n\tcase HAL_TCL_CMD:\n\tcase HAL_REO_CMD:\n\tcase HAL_SW2WBM_RELEASE:\n\tcase HAL_WBM_IDLE_LINK:\n\tcase HAL_TCL_STATUS:\n\tcase HAL_REO_REINJECT:\n\tcase HAL_CE_SRC:\n\tcase HAL_CE_DST:\n\tcase HAL_CE_DST_STATUS:\n\tdefault:\n\t\treturn -ENOENT;\n\t}\n\n\treturn ath11k_dp_srng_find_ring_in_mask(ring_num, grp_mask);\n}\n\nstatic void ath11k_dp_srng_msi_setup(struct ath11k_base *ab,\n\t\t\t\t     struct hal_srng_params *ring_params,\n\t\t\t\t     enum hal_ring_type type, int ring_num)\n{\n\tint msi_group_number, msi_data_count;\n\tu32 msi_data_start, msi_irq_start, addr_lo, addr_hi;\n\tint ret;\n\n\tret = ath11k_get_user_msi_vector(ab, \"DP\",\n\t\t\t\t\t &msi_data_count, &msi_data_start,\n\t\t\t\t\t &msi_irq_start);\n\tif (ret)\n\t\treturn;\n\n\tmsi_group_number = ath11k_dp_srng_calculate_msi_group(ab, type,\n\t\t\t\t\t\t\t      ring_num);\n\tif (msi_group_number < 0) {\n\t\tath11k_dbg(ab, ATH11K_DBG_PCI,\n\t\t\t   \"ring not part of an ext_group; ring_type: %d,ring_num %d\",\n\t\t\t   type, ring_num);\n\t\tring_params->msi_addr = 0;\n\t\tring_params->msi_data = 0;\n\t\treturn;\n\t}\n\n\tif (msi_group_number > msi_data_count) {\n\t\tath11k_dbg(ab, ATH11K_DBG_PCI,\n\t\t\t   \"multiple msi_groups share one msi, msi_group_num %d\",\n\t\t\t   msi_group_number);\n\t}\n\n\tath11k_get_msi_address(ab, &addr_lo, &addr_hi);\n\n\tring_params->msi_addr = addr_lo;\n\tring_params->msi_addr |= (dma_addr_t)(((uint64_t)addr_hi) << 32);\n\tring_params->msi_data = (msi_group_number % msi_data_count)\n\t\t+ msi_data_start;\n\tring_params->flags |= HAL_SRNG_FLAGS_MSI_INTR;\n}\n\nint ath11k_dp_srng_setup(struct ath11k_base *ab, struct dp_srng *ring,\n\t\t\t enum hal_ring_type type, int ring_num,\n\t\t\t int mac_id, int num_entries)\n{\n\tstruct hal_srng_params params = { 0 };\n\tint entry_sz = ath11k_hal_srng_get_entrysize(ab, type);\n\tint max_entries = ath11k_hal_srng_get_max_entries(ab, type);\n\tint ret;\n\tbool cached = false;\n\n\tif (max_entries < 0 || entry_sz < 0)\n\t\treturn -EINVAL;\n\n\tif (num_entries > max_entries)\n\t\tnum_entries = max_entries;\n\n\tring->size = (num_entries * entry_sz) + HAL_RING_BASE_ALIGN - 1;\n\n\tif (ab->hw_params.alloc_cacheable_memory) {\n\t\t \n\t\tswitch (type) {\n\t\tcase HAL_REO_DST:\n\t\tcase HAL_WBM2SW_RELEASE:\n\t\t\tcached = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcached = false;\n\t\t}\n\n\t\tif (cached) {\n\t\t\tring->vaddr_unaligned = kzalloc(ring->size, GFP_KERNEL);\n\t\t\tring->paddr_unaligned = virt_to_phys(ring->vaddr_unaligned);\n\t\t}\n\t}\n\n\tif (!cached)\n\t\tring->vaddr_unaligned = dma_alloc_coherent(ab->dev, ring->size,\n\t\t\t\t\t\t\t   &ring->paddr_unaligned,\n\t\t\t\t\t\t\t   GFP_KERNEL);\n\n\tif (!ring->vaddr_unaligned)\n\t\treturn -ENOMEM;\n\n\tring->vaddr = PTR_ALIGN(ring->vaddr_unaligned, HAL_RING_BASE_ALIGN);\n\tring->paddr = ring->paddr_unaligned + ((unsigned long)ring->vaddr -\n\t\t      (unsigned long)ring->vaddr_unaligned);\n\n\tparams.ring_base_vaddr = ring->vaddr;\n\tparams.ring_base_paddr = ring->paddr;\n\tparams.num_entries = num_entries;\n\tath11k_dp_srng_msi_setup(ab, &params, type, ring_num + mac_id);\n\n\tswitch (type) {\n\tcase HAL_REO_DST:\n\t\tparams.intr_batch_cntr_thres_entries =\n\t\t\t\t\tHAL_SRNG_INT_BATCH_THRESHOLD_RX;\n\t\tparams.intr_timer_thres_us = HAL_SRNG_INT_TIMER_THRESHOLD_RX;\n\t\tbreak;\n\tcase HAL_RXDMA_BUF:\n\tcase HAL_RXDMA_MONITOR_BUF:\n\tcase HAL_RXDMA_MONITOR_STATUS:\n\t\tparams.low_threshold = num_entries >> 3;\n\t\tparams.flags |= HAL_SRNG_FLAGS_LOW_THRESH_INTR_EN;\n\t\tparams.intr_batch_cntr_thres_entries = 0;\n\t\tparams.intr_timer_thres_us = HAL_SRNG_INT_TIMER_THRESHOLD_RX;\n\t\tbreak;\n\tcase HAL_WBM2SW_RELEASE:\n\t\tif (ring_num < 3) {\n\t\t\tparams.intr_batch_cntr_thres_entries =\n\t\t\t\t\tHAL_SRNG_INT_BATCH_THRESHOLD_TX;\n\t\t\tparams.intr_timer_thres_us =\n\t\t\t\t\tHAL_SRNG_INT_TIMER_THRESHOLD_TX;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tfallthrough;\n\tcase HAL_REO_EXCEPTION:\n\tcase HAL_REO_REINJECT:\n\tcase HAL_REO_CMD:\n\tcase HAL_REO_STATUS:\n\tcase HAL_TCL_DATA:\n\tcase HAL_TCL_CMD:\n\tcase HAL_TCL_STATUS:\n\tcase HAL_WBM_IDLE_LINK:\n\tcase HAL_SW2WBM_RELEASE:\n\tcase HAL_RXDMA_DST:\n\tcase HAL_RXDMA_MONITOR_DST:\n\tcase HAL_RXDMA_MONITOR_DESC:\n\t\tparams.intr_batch_cntr_thres_entries =\n\t\t\t\t\tHAL_SRNG_INT_BATCH_THRESHOLD_OTHER;\n\t\tparams.intr_timer_thres_us = HAL_SRNG_INT_TIMER_THRESHOLD_OTHER;\n\t\tbreak;\n\tcase HAL_RXDMA_DIR_BUF:\n\t\tbreak;\n\tdefault:\n\t\tath11k_warn(ab, \"Not a valid ring type in dp :%d\\n\", type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (cached) {\n\t\tparams.flags |= HAL_SRNG_FLAGS_CACHED;\n\t\tring->cached = 1;\n\t}\n\n\tret = ath11k_hal_srng_setup(ab, type, ring_num, mac_id, &params);\n\tif (ret < 0) {\n\t\tath11k_warn(ab, \"failed to setup srng: %d ring_id %d\\n\",\n\t\t\t    ret, ring_num);\n\t\treturn ret;\n\t}\n\n\tring->ring_id = ret;\n\n\treturn 0;\n}\n\nvoid ath11k_dp_stop_shadow_timers(struct ath11k_base *ab)\n{\n\tint i;\n\n\tif (!ab->hw_params.supports_shadow_regs)\n\t\treturn;\n\n\tfor (i = 0; i < ab->hw_params.max_tx_ring; i++)\n\t\tath11k_dp_shadow_stop_timer(ab, &ab->dp.tx_ring_timer[i]);\n\n\tath11k_dp_shadow_stop_timer(ab, &ab->dp.reo_cmd_timer);\n}\n\nstatic void ath11k_dp_srng_common_cleanup(struct ath11k_base *ab)\n{\n\tstruct ath11k_dp *dp = &ab->dp;\n\tint i;\n\n\tath11k_dp_stop_shadow_timers(ab);\n\tath11k_dp_srng_cleanup(ab, &dp->wbm_desc_rel_ring);\n\tath11k_dp_srng_cleanup(ab, &dp->tcl_cmd_ring);\n\tath11k_dp_srng_cleanup(ab, &dp->tcl_status_ring);\n\tfor (i = 0; i < ab->hw_params.max_tx_ring; i++) {\n\t\tath11k_dp_srng_cleanup(ab, &dp->tx_ring[i].tcl_data_ring);\n\t\tath11k_dp_srng_cleanup(ab, &dp->tx_ring[i].tcl_comp_ring);\n\t}\n\tath11k_dp_srng_cleanup(ab, &dp->reo_reinject_ring);\n\tath11k_dp_srng_cleanup(ab, &dp->rx_rel_ring);\n\tath11k_dp_srng_cleanup(ab, &dp->reo_except_ring);\n\tath11k_dp_srng_cleanup(ab, &dp->reo_cmd_ring);\n\tath11k_dp_srng_cleanup(ab, &dp->reo_status_ring);\n}\n\nstatic int ath11k_dp_srng_common_setup(struct ath11k_base *ab)\n{\n\tstruct ath11k_dp *dp = &ab->dp;\n\tstruct hal_srng *srng;\n\tint i, ret;\n\tu8 tcl_num, wbm_num;\n\n\tret = ath11k_dp_srng_setup(ab, &dp->wbm_desc_rel_ring,\n\t\t\t\t   HAL_SW2WBM_RELEASE, 0, 0,\n\t\t\t\t   DP_WBM_RELEASE_RING_SIZE);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to set up wbm2sw_release ring :%d\\n\",\n\t\t\t    ret);\n\t\tgoto err;\n\t}\n\n\tret = ath11k_dp_srng_setup(ab, &dp->tcl_cmd_ring, HAL_TCL_CMD, 0, 0,\n\t\t\t\t   DP_TCL_CMD_RING_SIZE);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to set up tcl_cmd ring :%d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tret = ath11k_dp_srng_setup(ab, &dp->tcl_status_ring, HAL_TCL_STATUS,\n\t\t\t\t   0, 0, DP_TCL_STATUS_RING_SIZE);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to set up tcl_status ring :%d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tfor (i = 0; i < ab->hw_params.max_tx_ring; i++) {\n\t\ttcl_num = ab->hw_params.hal_params->tcl2wbm_rbm_map[i].tcl_ring_num;\n\t\twbm_num = ab->hw_params.hal_params->tcl2wbm_rbm_map[i].wbm_ring_num;\n\n\t\tret = ath11k_dp_srng_setup(ab, &dp->tx_ring[i].tcl_data_ring,\n\t\t\t\t\t   HAL_TCL_DATA, tcl_num, 0,\n\t\t\t\t\t   ab->hw_params.tx_ring_size);\n\t\tif (ret) {\n\t\t\tath11k_warn(ab, \"failed to set up tcl_data ring (%d) :%d\\n\",\n\t\t\t\t    i, ret);\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = ath11k_dp_srng_setup(ab, &dp->tx_ring[i].tcl_comp_ring,\n\t\t\t\t\t   HAL_WBM2SW_RELEASE, wbm_num, 0,\n\t\t\t\t\t   DP_TX_COMP_RING_SIZE);\n\t\tif (ret) {\n\t\t\tath11k_warn(ab, \"failed to set up tcl_comp ring (%d) :%d\\n\",\n\t\t\t\t    i, ret);\n\t\t\tgoto err;\n\t\t}\n\n\t\tsrng = &ab->hal.srng_list[dp->tx_ring[i].tcl_data_ring.ring_id];\n\t\tath11k_hal_tx_init_data_ring(ab, srng);\n\n\t\tath11k_dp_shadow_init_timer(ab, &dp->tx_ring_timer[i],\n\t\t\t\t\t    ATH11K_SHADOW_DP_TIMER_INTERVAL,\n\t\t\t\t\t    dp->tx_ring[i].tcl_data_ring.ring_id);\n\t}\n\n\tret = ath11k_dp_srng_setup(ab, &dp->reo_reinject_ring, HAL_REO_REINJECT,\n\t\t\t\t   0, 0, DP_REO_REINJECT_RING_SIZE);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to set up reo_reinject ring :%d\\n\",\n\t\t\t    ret);\n\t\tgoto err;\n\t}\n\n\tret = ath11k_dp_srng_setup(ab, &dp->rx_rel_ring, HAL_WBM2SW_RELEASE,\n\t\t\t\t   DP_RX_RELEASE_RING_NUM, 0, DP_RX_RELEASE_RING_SIZE);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to set up rx_rel ring :%d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tret = ath11k_dp_srng_setup(ab, &dp->reo_except_ring, HAL_REO_EXCEPTION,\n\t\t\t\t   0, 0, DP_REO_EXCEPTION_RING_SIZE);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to set up reo_exception ring :%d\\n\",\n\t\t\t    ret);\n\t\tgoto err;\n\t}\n\n\tret = ath11k_dp_srng_setup(ab, &dp->reo_cmd_ring, HAL_REO_CMD,\n\t\t\t\t   0, 0, DP_REO_CMD_RING_SIZE);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to set up reo_cmd ring :%d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tsrng = &ab->hal.srng_list[dp->reo_cmd_ring.ring_id];\n\tath11k_hal_reo_init_cmd_ring(ab, srng);\n\n\tath11k_dp_shadow_init_timer(ab, &dp->reo_cmd_timer,\n\t\t\t\t    ATH11K_SHADOW_CTRL_TIMER_INTERVAL,\n\t\t\t\t    dp->reo_cmd_ring.ring_id);\n\n\tret = ath11k_dp_srng_setup(ab, &dp->reo_status_ring, HAL_REO_STATUS,\n\t\t\t\t   0, 0, DP_REO_STATUS_RING_SIZE);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to set up reo_status ring :%d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\t \n\tab->hw_params.hw_ops->reo_setup(ab);\n\n\treturn 0;\n\nerr:\n\tath11k_dp_srng_common_cleanup(ab);\n\n\treturn ret;\n}\n\nstatic void ath11k_dp_scatter_idle_link_desc_cleanup(struct ath11k_base *ab)\n{\n\tstruct ath11k_dp *dp = &ab->dp;\n\tstruct hal_wbm_idle_scatter_list *slist = dp->scatter_list;\n\tint i;\n\n\tfor (i = 0; i < DP_IDLE_SCATTER_BUFS_MAX; i++) {\n\t\tif (!slist[i].vaddr)\n\t\t\tcontinue;\n\n\t\tdma_free_coherent(ab->dev, HAL_WBM_IDLE_SCATTER_BUF_SIZE_MAX,\n\t\t\t\t  slist[i].vaddr, slist[i].paddr);\n\t\tslist[i].vaddr = NULL;\n\t}\n}\n\nstatic int ath11k_dp_scatter_idle_link_desc_setup(struct ath11k_base *ab,\n\t\t\t\t\t\t  int size,\n\t\t\t\t\t\t  u32 n_link_desc_bank,\n\t\t\t\t\t\t  u32 n_link_desc,\n\t\t\t\t\t\t  u32 last_bank_sz)\n{\n\tstruct ath11k_dp *dp = &ab->dp;\n\tstruct dp_link_desc_bank *link_desc_banks = dp->link_desc_banks;\n\tstruct hal_wbm_idle_scatter_list *slist = dp->scatter_list;\n\tu32 n_entries_per_buf;\n\tint num_scatter_buf, scatter_idx;\n\tstruct hal_wbm_link_desc *scatter_buf;\n\tint align_bytes, n_entries;\n\tdma_addr_t paddr;\n\tint rem_entries;\n\tint i;\n\tint ret = 0;\n\tu32 end_offset;\n\n\tn_entries_per_buf = HAL_WBM_IDLE_SCATTER_BUF_SIZE /\n\t\tath11k_hal_srng_get_entrysize(ab, HAL_WBM_IDLE_LINK);\n\tnum_scatter_buf = DIV_ROUND_UP(size, HAL_WBM_IDLE_SCATTER_BUF_SIZE);\n\n\tif (num_scatter_buf > DP_IDLE_SCATTER_BUFS_MAX)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < num_scatter_buf; i++) {\n\t\tslist[i].vaddr = dma_alloc_coherent(ab->dev,\n\t\t\t\t\t\t    HAL_WBM_IDLE_SCATTER_BUF_SIZE_MAX,\n\t\t\t\t\t\t    &slist[i].paddr, GFP_KERNEL);\n\t\tif (!slist[i].vaddr) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tscatter_idx = 0;\n\tscatter_buf = slist[scatter_idx].vaddr;\n\trem_entries = n_entries_per_buf;\n\n\tfor (i = 0; i < n_link_desc_bank; i++) {\n\t\talign_bytes = link_desc_banks[i].vaddr -\n\t\t\t      link_desc_banks[i].vaddr_unaligned;\n\t\tn_entries = (DP_LINK_DESC_ALLOC_SIZE_THRESH - align_bytes) /\n\t\t\t     HAL_LINK_DESC_SIZE;\n\t\tpaddr = link_desc_banks[i].paddr;\n\t\twhile (n_entries) {\n\t\t\tath11k_hal_set_link_desc_addr(scatter_buf, i, paddr);\n\t\t\tn_entries--;\n\t\t\tpaddr += HAL_LINK_DESC_SIZE;\n\t\t\tif (rem_entries) {\n\t\t\t\trem_entries--;\n\t\t\t\tscatter_buf++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\trem_entries = n_entries_per_buf;\n\t\t\tscatter_idx++;\n\t\t\tscatter_buf = slist[scatter_idx].vaddr;\n\t\t}\n\t}\n\n\tend_offset = (scatter_buf - slist[scatter_idx].vaddr) *\n\t\t     sizeof(struct hal_wbm_link_desc);\n\tath11k_hal_setup_link_idle_list(ab, slist, num_scatter_buf,\n\t\t\t\t\tn_link_desc, end_offset);\n\n\treturn 0;\n\nerr:\n\tath11k_dp_scatter_idle_link_desc_cleanup(ab);\n\n\treturn ret;\n}\n\nstatic void\nath11k_dp_link_desc_bank_free(struct ath11k_base *ab,\n\t\t\t      struct dp_link_desc_bank *link_desc_banks)\n{\n\tint i;\n\n\tfor (i = 0; i < DP_LINK_DESC_BANKS_MAX; i++) {\n\t\tif (link_desc_banks[i].vaddr_unaligned) {\n\t\t\tdma_free_coherent(ab->dev,\n\t\t\t\t\t  link_desc_banks[i].size,\n\t\t\t\t\t  link_desc_banks[i].vaddr_unaligned,\n\t\t\t\t\t  link_desc_banks[i].paddr_unaligned);\n\t\t\tlink_desc_banks[i].vaddr_unaligned = NULL;\n\t\t}\n\t}\n}\n\nstatic int ath11k_dp_link_desc_bank_alloc(struct ath11k_base *ab,\n\t\t\t\t\t  struct dp_link_desc_bank *desc_bank,\n\t\t\t\t\t  int n_link_desc_bank,\n\t\t\t\t\t  int last_bank_sz)\n{\n\tstruct ath11k_dp *dp = &ab->dp;\n\tint i;\n\tint ret = 0;\n\tint desc_sz = DP_LINK_DESC_ALLOC_SIZE_THRESH;\n\n\tfor (i = 0; i < n_link_desc_bank; i++) {\n\t\tif (i == (n_link_desc_bank - 1) && last_bank_sz)\n\t\t\tdesc_sz = last_bank_sz;\n\n\t\tdesc_bank[i].vaddr_unaligned =\n\t\t\t\t\tdma_alloc_coherent(ab->dev, desc_sz,\n\t\t\t\t\t\t\t   &desc_bank[i].paddr_unaligned,\n\t\t\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!desc_bank[i].vaddr_unaligned) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tdesc_bank[i].vaddr = PTR_ALIGN(desc_bank[i].vaddr_unaligned,\n\t\t\t\t\t       HAL_LINK_DESC_ALIGN);\n\t\tdesc_bank[i].paddr = desc_bank[i].paddr_unaligned +\n\t\t\t\t     ((unsigned long)desc_bank[i].vaddr -\n\t\t\t\t      (unsigned long)desc_bank[i].vaddr_unaligned);\n\t\tdesc_bank[i].size = desc_sz;\n\t}\n\n\treturn 0;\n\nerr:\n\tath11k_dp_link_desc_bank_free(ab, dp->link_desc_banks);\n\n\treturn ret;\n}\n\nvoid ath11k_dp_link_desc_cleanup(struct ath11k_base *ab,\n\t\t\t\t struct dp_link_desc_bank *desc_bank,\n\t\t\t\t u32 ring_type, struct dp_srng *ring)\n{\n\tath11k_dp_link_desc_bank_free(ab, desc_bank);\n\n\tif (ring_type != HAL_RXDMA_MONITOR_DESC) {\n\t\tath11k_dp_srng_cleanup(ab, ring);\n\t\tath11k_dp_scatter_idle_link_desc_cleanup(ab);\n\t}\n}\n\nstatic int ath11k_wbm_idle_ring_setup(struct ath11k_base *ab, u32 *n_link_desc)\n{\n\tstruct ath11k_dp *dp = &ab->dp;\n\tu32 n_mpdu_link_desc, n_mpdu_queue_desc;\n\tu32 n_tx_msdu_link_desc, n_rx_msdu_link_desc;\n\tint ret = 0;\n\n\tn_mpdu_link_desc = (DP_NUM_TIDS_MAX * DP_AVG_MPDUS_PER_TID_MAX) /\n\t\t\t   HAL_NUM_MPDUS_PER_LINK_DESC;\n\n\tn_mpdu_queue_desc = n_mpdu_link_desc /\n\t\t\t    HAL_NUM_MPDU_LINKS_PER_QUEUE_DESC;\n\n\tn_tx_msdu_link_desc = (DP_NUM_TIDS_MAX * DP_AVG_FLOWS_PER_TID *\n\t\t\t       DP_AVG_MSDUS_PER_FLOW) /\n\t\t\t      HAL_NUM_TX_MSDUS_PER_LINK_DESC;\n\n\tn_rx_msdu_link_desc = (DP_NUM_TIDS_MAX * DP_AVG_MPDUS_PER_TID_MAX *\n\t\t\t       DP_AVG_MSDUS_PER_MPDU) /\n\t\t\t      HAL_NUM_RX_MSDUS_PER_LINK_DESC;\n\n\t*n_link_desc = n_mpdu_link_desc + n_mpdu_queue_desc +\n\t\t      n_tx_msdu_link_desc + n_rx_msdu_link_desc;\n\n\tif (*n_link_desc & (*n_link_desc - 1))\n\t\t*n_link_desc = 1 << fls(*n_link_desc);\n\n\tret = ath11k_dp_srng_setup(ab, &dp->wbm_idle_ring,\n\t\t\t\t   HAL_WBM_IDLE_LINK, 0, 0, *n_link_desc);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to setup wbm_idle_ring: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\treturn ret;\n}\n\nint ath11k_dp_link_desc_setup(struct ath11k_base *ab,\n\t\t\t      struct dp_link_desc_bank *link_desc_banks,\n\t\t\t      u32 ring_type, struct hal_srng *srng,\n\t\t\t      u32 n_link_desc)\n{\n\tu32 tot_mem_sz;\n\tu32 n_link_desc_bank, last_bank_sz;\n\tu32 entry_sz, align_bytes, n_entries;\n\tu32 paddr;\n\tu32 *desc;\n\tint i, ret;\n\n\ttot_mem_sz = n_link_desc * HAL_LINK_DESC_SIZE;\n\ttot_mem_sz += HAL_LINK_DESC_ALIGN;\n\n\tif (tot_mem_sz <= DP_LINK_DESC_ALLOC_SIZE_THRESH) {\n\t\tn_link_desc_bank = 1;\n\t\tlast_bank_sz = tot_mem_sz;\n\t} else {\n\t\tn_link_desc_bank = tot_mem_sz /\n\t\t\t\t   (DP_LINK_DESC_ALLOC_SIZE_THRESH -\n\t\t\t\t    HAL_LINK_DESC_ALIGN);\n\t\tlast_bank_sz = tot_mem_sz %\n\t\t\t       (DP_LINK_DESC_ALLOC_SIZE_THRESH -\n\t\t\t\tHAL_LINK_DESC_ALIGN);\n\n\t\tif (last_bank_sz)\n\t\t\tn_link_desc_bank += 1;\n\t}\n\n\tif (n_link_desc_bank > DP_LINK_DESC_BANKS_MAX)\n\t\treturn -EINVAL;\n\n\tret = ath11k_dp_link_desc_bank_alloc(ab, link_desc_banks,\n\t\t\t\t\t     n_link_desc_bank, last_bank_sz);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tentry_sz = ath11k_hal_srng_get_entrysize(ab, ring_type);\n\ttot_mem_sz = entry_sz * n_link_desc;\n\n\t \n\tif (tot_mem_sz > DP_LINK_DESC_ALLOC_SIZE_THRESH &&\n\t    ring_type != HAL_RXDMA_MONITOR_DESC) {\n\t\tret = ath11k_dp_scatter_idle_link_desc_setup(ab, tot_mem_sz,\n\t\t\t\t\t\t\t     n_link_desc_bank,\n\t\t\t\t\t\t\t     n_link_desc,\n\t\t\t\t\t\t\t     last_bank_sz);\n\t\tif (ret) {\n\t\t\tath11k_warn(ab, \"failed to setup scatting idle list descriptor :%d\\n\",\n\t\t\t\t    ret);\n\t\t\tgoto fail_desc_bank_free;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tspin_lock_bh(&srng->lock);\n\n\tath11k_hal_srng_access_begin(ab, srng);\n\n\tfor (i = 0; i < n_link_desc_bank; i++) {\n\t\talign_bytes = link_desc_banks[i].vaddr -\n\t\t\t      link_desc_banks[i].vaddr_unaligned;\n\t\tn_entries = (link_desc_banks[i].size - align_bytes) /\n\t\t\t    HAL_LINK_DESC_SIZE;\n\t\tpaddr = link_desc_banks[i].paddr;\n\t\twhile (n_entries &&\n\t\t       (desc = ath11k_hal_srng_src_get_next_entry(ab, srng))) {\n\t\t\tath11k_hal_set_link_desc_addr((struct hal_wbm_link_desc *)desc,\n\t\t\t\t\t\t      i, paddr);\n\t\t\tn_entries--;\n\t\t\tpaddr += HAL_LINK_DESC_SIZE;\n\t\t}\n\t}\n\n\tath11k_hal_srng_access_end(ab, srng);\n\n\tspin_unlock_bh(&srng->lock);\n\n\treturn 0;\n\nfail_desc_bank_free:\n\tath11k_dp_link_desc_bank_free(ab, link_desc_banks);\n\n\treturn ret;\n}\n\nint ath11k_dp_service_srng(struct ath11k_base *ab,\n\t\t\t   struct ath11k_ext_irq_grp *irq_grp,\n\t\t\t   int budget)\n{\n\tstruct napi_struct *napi = &irq_grp->napi;\n\tconst struct ath11k_hw_hal_params *hal_params;\n\tint grp_id = irq_grp->grp_id;\n\tint work_done = 0;\n\tint i, j;\n\tint tot_work_done = 0;\n\n\tfor (i = 0; i < ab->hw_params.max_tx_ring; i++) {\n\t\tif (BIT(ab->hw_params.hal_params->tcl2wbm_rbm_map[i].wbm_ring_num) &\n\t\t    ab->hw_params.ring_mask->tx[grp_id])\n\t\t\tath11k_dp_tx_completion_handler(ab, i);\n\t}\n\n\tif (ab->hw_params.ring_mask->rx_err[grp_id]) {\n\t\twork_done = ath11k_dp_process_rx_err(ab, napi, budget);\n\t\tbudget -= work_done;\n\t\ttot_work_done += work_done;\n\t\tif (budget <= 0)\n\t\t\tgoto done;\n\t}\n\n\tif (ab->hw_params.ring_mask->rx_wbm_rel[grp_id]) {\n\t\twork_done = ath11k_dp_rx_process_wbm_err(ab,\n\t\t\t\t\t\t\t napi,\n\t\t\t\t\t\t\t budget);\n\t\tbudget -= work_done;\n\t\ttot_work_done += work_done;\n\n\t\tif (budget <= 0)\n\t\t\tgoto done;\n\t}\n\n\tif (ab->hw_params.ring_mask->rx[grp_id]) {\n\t\ti =  fls(ab->hw_params.ring_mask->rx[grp_id]) - 1;\n\t\twork_done = ath11k_dp_process_rx(ab, i, napi,\n\t\t\t\t\t\t budget);\n\t\tbudget -= work_done;\n\t\ttot_work_done += work_done;\n\t\tif (budget <= 0)\n\t\t\tgoto done;\n\t}\n\n\tif (ab->hw_params.ring_mask->rx_mon_status[grp_id]) {\n\t\tfor (i = 0; i < ab->num_radios; i++) {\n\t\t\tfor (j = 0; j < ab->hw_params.num_rxmda_per_pdev; j++) {\n\t\t\t\tint id = i * ab->hw_params.num_rxmda_per_pdev + j;\n\n\t\t\t\tif (ab->hw_params.ring_mask->rx_mon_status[grp_id] &\n\t\t\t\t\tBIT(id)) {\n\t\t\t\t\twork_done =\n\t\t\t\t\tath11k_dp_rx_process_mon_rings(ab,\n\t\t\t\t\t\t\t\t       id,\n\t\t\t\t\t\t\t\t       napi, budget);\n\t\t\t\t\tbudget -= work_done;\n\t\t\t\t\ttot_work_done += work_done;\n\n\t\t\t\t\tif (budget <= 0)\n\t\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ab->hw_params.ring_mask->reo_status[grp_id])\n\t\tath11k_dp_process_reo_status(ab);\n\n\tfor (i = 0; i < ab->num_radios; i++) {\n\t\tfor (j = 0; j < ab->hw_params.num_rxmda_per_pdev; j++) {\n\t\t\tint id = i * ab->hw_params.num_rxmda_per_pdev + j;\n\n\t\t\tif (ab->hw_params.ring_mask->rxdma2host[grp_id] & BIT(id)) {\n\t\t\t\twork_done = ath11k_dp_process_rxdma_err(ab, id, budget);\n\t\t\t\tbudget -= work_done;\n\t\t\t\ttot_work_done += work_done;\n\t\t\t}\n\n\t\t\tif (budget <= 0)\n\t\t\t\tgoto done;\n\n\t\t\tif (ab->hw_params.ring_mask->host2rxdma[grp_id] & BIT(id)) {\n\t\t\t\tstruct ath11k *ar = ath11k_ab_to_ar(ab, id);\n\t\t\t\tstruct ath11k_pdev_dp *dp = &ar->dp;\n\t\t\t\tstruct dp_rxdma_ring *rx_ring = &dp->rx_refill_buf_ring;\n\n\t\t\t\thal_params = ab->hw_params.hal_params;\n\t\t\t\tath11k_dp_rxbufs_replenish(ab, id, rx_ring, 0,\n\t\t\t\t\t\t\t   hal_params->rx_buf_rbm);\n\t\t\t}\n\t\t}\n\t}\n\t \n\ndone:\n\treturn tot_work_done;\n}\nEXPORT_SYMBOL(ath11k_dp_service_srng);\n\nvoid ath11k_dp_pdev_free(struct ath11k_base *ab)\n{\n\tstruct ath11k *ar;\n\tint i;\n\n\tdel_timer_sync(&ab->mon_reap_timer);\n\n\tfor (i = 0; i < ab->num_radios; i++) {\n\t\tar = ab->pdevs[i].ar;\n\t\tath11k_dp_rx_pdev_free(ab, i);\n\t\tath11k_debugfs_unregister(ar);\n\t\tath11k_dp_rx_pdev_mon_detach(ar);\n\t}\n}\n\nvoid ath11k_dp_pdev_pre_alloc(struct ath11k_base *ab)\n{\n\tstruct ath11k *ar;\n\tstruct ath11k_pdev_dp *dp;\n\tint i;\n\tint j;\n\n\tfor (i = 0; i <  ab->num_radios; i++) {\n\t\tar = ab->pdevs[i].ar;\n\t\tdp = &ar->dp;\n\t\tdp->mac_id = i;\n\t\tidr_init(&dp->rx_refill_buf_ring.bufs_idr);\n\t\tspin_lock_init(&dp->rx_refill_buf_ring.idr_lock);\n\t\tatomic_set(&dp->num_tx_pending, 0);\n\t\tinit_waitqueue_head(&dp->tx_empty_waitq);\n\t\tfor (j = 0; j < ab->hw_params.num_rxmda_per_pdev; j++) {\n\t\t\tidr_init(&dp->rx_mon_status_refill_ring[j].bufs_idr);\n\t\t\tspin_lock_init(&dp->rx_mon_status_refill_ring[j].idr_lock);\n\t\t}\n\t\tidr_init(&dp->rxdma_mon_buf_ring.bufs_idr);\n\t\tspin_lock_init(&dp->rxdma_mon_buf_ring.idr_lock);\n\t}\n}\n\nint ath11k_dp_pdev_alloc(struct ath11k_base *ab)\n{\n\tstruct ath11k *ar;\n\tint ret;\n\tint i;\n\n\t \n\tfor (i = 0; i < ab->num_radios; i++) {\n\t\tar = ab->pdevs[i].ar;\n\t\tret = ath11k_dp_rx_pdev_alloc(ab, i);\n\t\tif (ret) {\n\t\t\tath11k_warn(ab, \"failed to allocate pdev rx for pdev_id :%d\\n\",\n\t\t\t\t    i);\n\t\t\tgoto err;\n\t\t}\n\t\tret = ath11k_dp_rx_pdev_mon_attach(ar);\n\t\tif (ret) {\n\t\t\tath11k_warn(ab, \"failed to initialize mon pdev %d\\n\",\n\t\t\t\t    i);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\tath11k_dp_pdev_free(ab);\n\n\treturn ret;\n}\n\nint ath11k_dp_htt_connect(struct ath11k_dp *dp)\n{\n\tstruct ath11k_htc_svc_conn_req conn_req;\n\tstruct ath11k_htc_svc_conn_resp conn_resp;\n\tint status;\n\n\tmemset(&conn_req, 0, sizeof(conn_req));\n\tmemset(&conn_resp, 0, sizeof(conn_resp));\n\n\tconn_req.ep_ops.ep_tx_complete = ath11k_dp_htt_htc_tx_complete;\n\tconn_req.ep_ops.ep_rx_complete = ath11k_dp_htt_htc_t2h_msg_handler;\n\n\t \n\tconn_req.service_id = ATH11K_HTC_SVC_ID_HTT_DATA_MSG;\n\n\tstatus = ath11k_htc_connect_service(&dp->ab->htc, &conn_req,\n\t\t\t\t\t    &conn_resp);\n\n\tif (status)\n\t\treturn status;\n\n\tdp->eid = conn_resp.eid;\n\n\treturn 0;\n}\n\nstatic void ath11k_dp_update_vdev_search(struct ath11k_vif *arvif)\n{\n\t  \n\tswitch (arvif->vdev_type) {\n\tcase WMI_VDEV_TYPE_STA:\n\t\tif (arvif->ar->ab->hw_params.htt_peer_map_v2) {\n\t\t\tarvif->hal_addr_search_flags = HAL_TX_ADDRX_EN;\n\t\t\tarvif->search_type = HAL_TX_ADDR_SEARCH_INDEX;\n\t\t} else {\n\t\t\tarvif->hal_addr_search_flags = HAL_TX_ADDRY_EN;\n\t\t\tarvif->search_type = HAL_TX_ADDR_SEARCH_DEFAULT;\n\t\t}\n\t\tbreak;\n\tcase WMI_VDEV_TYPE_AP:\n\tcase WMI_VDEV_TYPE_IBSS:\n\t\tarvif->hal_addr_search_flags = HAL_TX_ADDRX_EN;\n\t\tarvif->search_type = HAL_TX_ADDR_SEARCH_DEFAULT;\n\t\tbreak;\n\tcase WMI_VDEV_TYPE_MONITOR:\n\tdefault:\n\t\treturn;\n\t}\n}\n\nvoid ath11k_dp_vdev_tx_attach(struct ath11k *ar, struct ath11k_vif *arvif)\n{\n\tarvif->tcl_metadata |= FIELD_PREP(HTT_TCL_META_DATA_TYPE, 1) |\n\t\t\t       FIELD_PREP(HTT_TCL_META_DATA_VDEV_ID,\n\t\t\t\t\t  arvif->vdev_id) |\n\t\t\t       FIELD_PREP(HTT_TCL_META_DATA_PDEV_ID,\n\t\t\t\t\t  ar->pdev->pdev_id);\n\n\t \n\tarvif->tcl_metadata &= ~HTT_TCL_META_DATA_VALID_HTT;\n\n\tath11k_dp_update_vdev_search(arvif);\n}\n\nstatic int ath11k_dp_tx_pending_cleanup(int buf_id, void *skb, void *ctx)\n{\n\tstruct ath11k_base *ab = (struct ath11k_base *)ctx;\n\tstruct sk_buff *msdu = skb;\n\n\tdma_unmap_single(ab->dev, ATH11K_SKB_CB(msdu)->paddr, msdu->len,\n\t\t\t DMA_TO_DEVICE);\n\n\tdev_kfree_skb_any(msdu);\n\n\treturn 0;\n}\n\nvoid ath11k_dp_free(struct ath11k_base *ab)\n{\n\tstruct ath11k_dp *dp = &ab->dp;\n\tint i;\n\n\tath11k_dp_link_desc_cleanup(ab, dp->link_desc_banks,\n\t\t\t\t    HAL_WBM_IDLE_LINK, &dp->wbm_idle_ring);\n\n\tath11k_dp_srng_common_cleanup(ab);\n\n\tath11k_dp_reo_cmd_list_cleanup(ab);\n\n\tfor (i = 0; i < ab->hw_params.max_tx_ring; i++) {\n\t\tspin_lock_bh(&dp->tx_ring[i].tx_idr_lock);\n\t\tidr_for_each(&dp->tx_ring[i].txbuf_idr,\n\t\t\t     ath11k_dp_tx_pending_cleanup, ab);\n\t\tidr_destroy(&dp->tx_ring[i].txbuf_idr);\n\t\tspin_unlock_bh(&dp->tx_ring[i].tx_idr_lock);\n\t\tkfree(dp->tx_ring[i].tx_status);\n\t}\n\n\t \n}\n\nint ath11k_dp_alloc(struct ath11k_base *ab)\n{\n\tstruct ath11k_dp *dp = &ab->dp;\n\tstruct hal_srng *srng = NULL;\n\tsize_t size = 0;\n\tu32 n_link_desc = 0;\n\tint ret;\n\tint i;\n\n\tdp->ab = ab;\n\n\tINIT_LIST_HEAD(&dp->reo_cmd_list);\n\tINIT_LIST_HEAD(&dp->reo_cmd_cache_flush_list);\n\tINIT_LIST_HEAD(&dp->dp_full_mon_mpdu_list);\n\tspin_lock_init(&dp->reo_cmd_lock);\n\n\tdp->reo_cmd_cache_flush_count = 0;\n\n\tret = ath11k_wbm_idle_ring_setup(ab, &n_link_desc);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to setup wbm_idle_ring: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tsrng = &ab->hal.srng_list[dp->wbm_idle_ring.ring_id];\n\n\tret = ath11k_dp_link_desc_setup(ab, dp->link_desc_banks,\n\t\t\t\t\tHAL_WBM_IDLE_LINK, srng, n_link_desc);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to setup link desc: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ath11k_dp_srng_common_setup(ab);\n\tif (ret)\n\t\tgoto fail_link_desc_cleanup;\n\n\tsize = sizeof(struct hal_wbm_release_ring) * DP_TX_COMP_RING_SIZE;\n\n\tfor (i = 0; i < ab->hw_params.max_tx_ring; i++) {\n\t\tidr_init(&dp->tx_ring[i].txbuf_idr);\n\t\tspin_lock_init(&dp->tx_ring[i].tx_idr_lock);\n\t\tdp->tx_ring[i].tcl_data_ring_id = i;\n\n\t\tdp->tx_ring[i].tx_status_head = 0;\n\t\tdp->tx_ring[i].tx_status_tail = DP_TX_COMP_RING_SIZE - 1;\n\t\tdp->tx_ring[i].tx_status = kmalloc(size, GFP_KERNEL);\n\t\tif (!dp->tx_ring[i].tx_status) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail_cmn_srng_cleanup;\n\t\t}\n\t}\n\n\tfor (i = 0; i < HAL_DSCP_TID_MAP_TBL_NUM_ENTRIES_MAX; i++)\n\t\tath11k_hal_tx_set_dscp_tid_map(ab, i);\n\n\t \n\n\treturn 0;\n\nfail_cmn_srng_cleanup:\n\tath11k_dp_srng_common_cleanup(ab);\n\nfail_link_desc_cleanup:\n\tath11k_dp_link_desc_cleanup(ab, dp->link_desc_banks,\n\t\t\t\t    HAL_WBM_IDLE_LINK, &dp->wbm_idle_ring);\n\n\treturn ret;\n}\n\nstatic void ath11k_dp_shadow_timer_handler(struct timer_list *t)\n{\n\tstruct ath11k_hp_update_timer *update_timer = from_timer(update_timer,\n\t\t\t\t\t\t\t\t t, timer);\n\tstruct ath11k_base *ab = update_timer->ab;\n\tstruct hal_srng\t*srng = &ab->hal.srng_list[update_timer->ring_id];\n\n\tspin_lock_bh(&srng->lock);\n\n\t \n\tif (update_timer->timer_tx_num != update_timer->tx_num) {\n\t\tupdate_timer->timer_tx_num = update_timer->tx_num;\n\t\tmod_timer(&update_timer->timer, jiffies +\n\t\t  msecs_to_jiffies(update_timer->interval));\n\t} else {\n\t\tupdate_timer->started = false;\n\t\tath11k_hal_srng_shadow_update_hp_tp(ab, srng);\n\t}\n\n\tspin_unlock_bh(&srng->lock);\n}\n\nvoid ath11k_dp_shadow_start_timer(struct ath11k_base *ab,\n\t\t\t\t  struct hal_srng *srng,\n\t\t\t\t  struct ath11k_hp_update_timer *update_timer)\n{\n\tlockdep_assert_held(&srng->lock);\n\n\tif (!ab->hw_params.supports_shadow_regs)\n\t\treturn;\n\n\tupdate_timer->tx_num++;\n\n\tif (update_timer->started)\n\t\treturn;\n\n\tupdate_timer->started = true;\n\tupdate_timer->timer_tx_num = update_timer->tx_num;\n\tmod_timer(&update_timer->timer, jiffies +\n\t\t  msecs_to_jiffies(update_timer->interval));\n}\n\nvoid ath11k_dp_shadow_stop_timer(struct ath11k_base *ab,\n\t\t\t\t struct ath11k_hp_update_timer *update_timer)\n{\n\tif (!ab->hw_params.supports_shadow_regs)\n\t\treturn;\n\n\tif (!update_timer->init)\n\t\treturn;\n\n\tdel_timer_sync(&update_timer->timer);\n}\n\nvoid ath11k_dp_shadow_init_timer(struct ath11k_base *ab,\n\t\t\t\t struct ath11k_hp_update_timer *update_timer,\n\t\t\t\t u32 interval, u32 ring_id)\n{\n\tif (!ab->hw_params.supports_shadow_regs)\n\t\treturn;\n\n\tupdate_timer->tx_num = 0;\n\tupdate_timer->timer_tx_num = 0;\n\tupdate_timer->ab = ab;\n\tupdate_timer->ring_id = ring_id;\n\tupdate_timer->interval = interval;\n\tupdate_timer->init = true;\n\ttimer_setup(&update_timer->timer,\n\t\t    ath11k_dp_shadow_timer_handler, 0);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}