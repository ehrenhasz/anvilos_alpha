{
  "module_name": "dp_tx.c",
  "hash_id": "40cc35c8a6002ab7c2d51dd1dde0c2b5a0608e0804649d08445af137a639887d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath11k/dp_tx.c",
  "human_readable_source": "\n \n\n#include \"core.h\"\n#include \"dp_tx.h\"\n#include \"debug.h\"\n#include \"debugfs_sta.h\"\n#include \"hw.h\"\n#include \"peer.h\"\n#include \"mac.h\"\n\nstatic enum hal_tcl_encap_type\nath11k_dp_tx_get_encap_type(struct ath11k_vif *arvif, struct sk_buff *skb)\n{\n\tstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);\n\tstruct ath11k_base *ab = arvif->ar->ab;\n\n\tif (test_bit(ATH11K_FLAG_RAW_MODE, &ab->dev_flags))\n\t\treturn HAL_TCL_ENCAP_TYPE_RAW;\n\n\tif (tx_info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP)\n\t\treturn HAL_TCL_ENCAP_TYPE_ETHERNET;\n\n\treturn HAL_TCL_ENCAP_TYPE_NATIVE_WIFI;\n}\n\nstatic void ath11k_dp_tx_encap_nwifi(struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\tu8 *qos_ctl;\n\n\tif (!ieee80211_is_data_qos(hdr->frame_control))\n\t\treturn;\n\n\tqos_ctl = ieee80211_get_qos_ctl(hdr);\n\tmemmove(skb->data + IEEE80211_QOS_CTL_LEN,\n\t\tskb->data, (void *)qos_ctl - (void *)skb->data);\n\tskb_pull(skb, IEEE80211_QOS_CTL_LEN);\n\n\thdr = (void *)skb->data;\n\thdr->frame_control &= ~__cpu_to_le16(IEEE80211_STYPE_QOS_DATA);\n}\n\nstatic u8 ath11k_dp_tx_get_tid(struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\tstruct ath11k_skb_cb *cb = ATH11K_SKB_CB(skb);\n\n\tif (cb->flags & ATH11K_SKB_HW_80211_ENCAP)\n\t\treturn skb->priority & IEEE80211_QOS_CTL_TID_MASK;\n\telse if (!ieee80211_is_data_qos(hdr->frame_control))\n\t\treturn HAL_DESC_REO_NON_QOS_TID;\n\telse\n\t\treturn skb->priority & IEEE80211_QOS_CTL_TID_MASK;\n}\n\nenum hal_encrypt_type ath11k_dp_tx_get_encrypt_type(u32 cipher)\n{\n\tswitch (cipher) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\treturn HAL_ENCRYPT_TYPE_WEP_40;\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\treturn HAL_ENCRYPT_TYPE_WEP_104;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\treturn HAL_ENCRYPT_TYPE_TKIP_MIC;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\treturn HAL_ENCRYPT_TYPE_CCMP_128;\n\tcase WLAN_CIPHER_SUITE_CCMP_256:\n\t\treturn HAL_ENCRYPT_TYPE_CCMP_256;\n\tcase WLAN_CIPHER_SUITE_GCMP:\n\t\treturn HAL_ENCRYPT_TYPE_GCMP_128;\n\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\treturn HAL_ENCRYPT_TYPE_AES_GCMP_256;\n\tdefault:\n\t\treturn HAL_ENCRYPT_TYPE_OPEN;\n\t}\n}\n\nint ath11k_dp_tx(struct ath11k *ar, struct ath11k_vif *arvif,\n\t\t struct ath11k_sta *arsta, struct sk_buff *skb)\n{\n\tstruct ath11k_base *ab = ar->ab;\n\tstruct ath11k_dp *dp = &ab->dp;\n\tstruct hal_tx_info ti = {0};\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ath11k_skb_cb *skb_cb = ATH11K_SKB_CB(skb);\n\tstruct hal_srng *tcl_ring;\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\tstruct dp_tx_ring *tx_ring;\n\tvoid *hal_tcl_desc;\n\tu8 pool_id;\n\tu8 hal_ring_id;\n\tint ret;\n\tu32 ring_selector = 0;\n\tu8 ring_map = 0;\n\tbool tcl_ring_retry;\n\n\tif (unlikely(test_bit(ATH11K_FLAG_CRASH_FLUSH, &ar->ab->dev_flags)))\n\t\treturn -ESHUTDOWN;\n\n\tif (unlikely(!(info->flags & IEEE80211_TX_CTL_HW_80211_ENCAP) &&\n\t\t     !ieee80211_is_data(hdr->frame_control)))\n\t\treturn -ENOTSUPP;\n\n\tpool_id = skb_get_queue_mapping(skb) & (ATH11K_HW_MAX_QUEUES - 1);\n\n\tring_selector = ab->hw_params.hw_ops->get_ring_selector(skb);\n\ntcl_ring_sel:\n\ttcl_ring_retry = false;\n\n\tti.ring_id = ring_selector % ab->hw_params.max_tx_ring;\n\tti.rbm_id = ab->hw_params.hal_params->tcl2wbm_rbm_map[ti.ring_id].rbm_id;\n\n\tring_map |= BIT(ti.ring_id);\n\n\ttx_ring = &dp->tx_ring[ti.ring_id];\n\n\tspin_lock_bh(&tx_ring->tx_idr_lock);\n\tret = idr_alloc(&tx_ring->txbuf_idr, skb, 0,\n\t\t\tDP_TX_IDR_SIZE - 1, GFP_ATOMIC);\n\tspin_unlock_bh(&tx_ring->tx_idr_lock);\n\n\tif (unlikely(ret < 0)) {\n\t\tif (ring_map == (BIT(ab->hw_params.max_tx_ring) - 1) ||\n\t\t    !ab->hw_params.tcl_ring_retry) {\n\t\t\tatomic_inc(&ab->soc_stats.tx_err.misc_fail);\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\t \n\t\tring_selector++;\n\t\tgoto tcl_ring_sel;\n\t}\n\n\tti.desc_id = FIELD_PREP(DP_TX_DESC_ID_MAC_ID, ar->pdev_idx) |\n\t\t     FIELD_PREP(DP_TX_DESC_ID_MSDU_ID, ret) |\n\t\t     FIELD_PREP(DP_TX_DESC_ID_POOL_ID, pool_id);\n\tti.encap_type = ath11k_dp_tx_get_encap_type(arvif, skb);\n\n\tif (ieee80211_has_a4(hdr->frame_control) &&\n\t    is_multicast_ether_addr(hdr->addr3) && arsta &&\n\t    arsta->use_4addr_set) {\n\t\tti.meta_data_flags = arsta->tcl_metadata;\n\t\tti.flags0 |= FIELD_PREP(HAL_TCL_DATA_CMD_INFO1_TO_FW, 1);\n\t} else {\n\t\tti.meta_data_flags = arvif->tcl_metadata;\n\t}\n\n\tif (unlikely(ti.encap_type == HAL_TCL_ENCAP_TYPE_RAW)) {\n\t\tif (skb_cb->flags & ATH11K_SKB_CIPHER_SET) {\n\t\t\tti.encrypt_type =\n\t\t\t\tath11k_dp_tx_get_encrypt_type(skb_cb->cipher);\n\n\t\t\tif (ieee80211_has_protected(hdr->frame_control))\n\t\t\t\tskb_put(skb, IEEE80211_CCMP_MIC_LEN);\n\t\t} else {\n\t\t\tti.encrypt_type = HAL_ENCRYPT_TYPE_OPEN;\n\t\t}\n\t}\n\n\tti.addr_search_flags = arvif->hal_addr_search_flags;\n\tti.search_type = arvif->search_type;\n\tti.type = HAL_TCL_DESC_TYPE_BUFFER;\n\tti.pkt_offset = 0;\n\tti.lmac_id = ar->lmac_id;\n\tti.bss_ast_hash = arvif->ast_hash;\n\tti.bss_ast_idx = arvif->ast_idx;\n\tti.dscp_tid_tbl_idx = 0;\n\n\tif (likely(skb->ip_summed == CHECKSUM_PARTIAL &&\n\t\t   ti.encap_type != HAL_TCL_ENCAP_TYPE_RAW)) {\n\t\tti.flags0 |= FIELD_PREP(HAL_TCL_DATA_CMD_INFO1_IP4_CKSUM_EN, 1) |\n\t\t\t     FIELD_PREP(HAL_TCL_DATA_CMD_INFO1_UDP4_CKSUM_EN, 1) |\n\t\t\t     FIELD_PREP(HAL_TCL_DATA_CMD_INFO1_UDP6_CKSUM_EN, 1) |\n\t\t\t     FIELD_PREP(HAL_TCL_DATA_CMD_INFO1_TCP4_CKSUM_EN, 1) |\n\t\t\t     FIELD_PREP(HAL_TCL_DATA_CMD_INFO1_TCP6_CKSUM_EN, 1);\n\t}\n\n\tif (ieee80211_vif_is_mesh(arvif->vif))\n\t\tti.enable_mesh = true;\n\n\tti.flags1 |= FIELD_PREP(HAL_TCL_DATA_CMD_INFO2_TID_OVERWRITE, 1);\n\n\tti.tid = ath11k_dp_tx_get_tid(skb);\n\n\tswitch (ti.encap_type) {\n\tcase HAL_TCL_ENCAP_TYPE_NATIVE_WIFI:\n\t\tath11k_dp_tx_encap_nwifi(skb);\n\t\tbreak;\n\tcase HAL_TCL_ENCAP_TYPE_RAW:\n\t\tif (!test_bit(ATH11K_FLAG_RAW_MODE, &ab->dev_flags)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto fail_remove_idr;\n\t\t}\n\t\tbreak;\n\tcase HAL_TCL_ENCAP_TYPE_ETHERNET:\n\t\t \n\t\tbreak;\n\tcase HAL_TCL_ENCAP_TYPE_802_3:\n\tdefault:\n\t\t \n\t\tret = -EINVAL;\n\t\tatomic_inc(&ab->soc_stats.tx_err.misc_fail);\n\t\tgoto fail_remove_idr;\n\t}\n\n\tti.paddr = dma_map_single(ab->dev, skb->data, skb->len, DMA_TO_DEVICE);\n\tif (unlikely(dma_mapping_error(ab->dev, ti.paddr))) {\n\t\tatomic_inc(&ab->soc_stats.tx_err.misc_fail);\n\t\tath11k_warn(ab, \"failed to DMA map data Tx buffer\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto fail_remove_idr;\n\t}\n\n\tti.data_len = skb->len;\n\tskb_cb->paddr = ti.paddr;\n\tskb_cb->vif = arvif->vif;\n\tskb_cb->ar = ar;\n\n\thal_ring_id = tx_ring->tcl_data_ring.ring_id;\n\ttcl_ring = &ab->hal.srng_list[hal_ring_id];\n\n\tspin_lock_bh(&tcl_ring->lock);\n\n\tath11k_hal_srng_access_begin(ab, tcl_ring);\n\n\thal_tcl_desc = (void *)ath11k_hal_srng_src_get_next_entry(ab, tcl_ring);\n\tif (unlikely(!hal_tcl_desc)) {\n\t\t \n\t\tath11k_hal_srng_access_end(ab, tcl_ring);\n\t\tab->soc_stats.tx_err.desc_na[ti.ring_id]++;\n\t\tspin_unlock_bh(&tcl_ring->lock);\n\t\tret = -ENOMEM;\n\n\t\t \n\t\tif (unlikely(ring_map != (BIT(ab->hw_params.max_tx_ring)) - 1) &&\n\t\t    ab->hw_params.tcl_ring_retry && ab->hw_params.max_tx_ring > 1) {\n\t\t\ttcl_ring_retry = true;\n\t\t\tring_selector++;\n\t\t}\n\n\t\tgoto fail_unmap_dma;\n\t}\n\n\tath11k_hal_tx_cmd_desc_setup(ab, hal_tcl_desc +\n\t\t\t\t\t sizeof(struct hal_tlv_hdr), &ti);\n\n\tath11k_hal_srng_access_end(ab, tcl_ring);\n\n\tath11k_dp_shadow_start_timer(ab, tcl_ring, &dp->tx_ring_timer[ti.ring_id]);\n\n\tspin_unlock_bh(&tcl_ring->lock);\n\n\tath11k_dbg_dump(ab, ATH11K_DBG_DP_TX, NULL, \"dp tx msdu: \",\n\t\t\tskb->data, skb->len);\n\n\tatomic_inc(&ar->dp.num_tx_pending);\n\n\treturn 0;\n\nfail_unmap_dma:\n\tdma_unmap_single(ab->dev, ti.paddr, ti.data_len, DMA_TO_DEVICE);\n\nfail_remove_idr:\n\tspin_lock_bh(&tx_ring->tx_idr_lock);\n\tidr_remove(&tx_ring->txbuf_idr,\n\t\t   FIELD_GET(DP_TX_DESC_ID_MSDU_ID, ti.desc_id));\n\tspin_unlock_bh(&tx_ring->tx_idr_lock);\n\n\tif (tcl_ring_retry)\n\t\tgoto tcl_ring_sel;\n\n\treturn ret;\n}\n\nstatic void ath11k_dp_tx_free_txbuf(struct ath11k_base *ab, u8 mac_id,\n\t\t\t\t    int msdu_id,\n\t\t\t\t    struct dp_tx_ring *tx_ring)\n{\n\tstruct ath11k *ar;\n\tstruct sk_buff *msdu;\n\tstruct ath11k_skb_cb *skb_cb;\n\n\tspin_lock(&tx_ring->tx_idr_lock);\n\tmsdu = idr_remove(&tx_ring->txbuf_idr, msdu_id);\n\tspin_unlock(&tx_ring->tx_idr_lock);\n\n\tif (unlikely(!msdu)) {\n\t\tath11k_warn(ab, \"tx completion for unknown msdu_id %d\\n\",\n\t\t\t    msdu_id);\n\t\treturn;\n\t}\n\n\tskb_cb = ATH11K_SKB_CB(msdu);\n\n\tdma_unmap_single(ab->dev, skb_cb->paddr, msdu->len, DMA_TO_DEVICE);\n\tdev_kfree_skb_any(msdu);\n\n\tar = ab->pdevs[mac_id].ar;\n\tif (atomic_dec_and_test(&ar->dp.num_tx_pending))\n\t\twake_up(&ar->dp.tx_empty_waitq);\n}\n\nstatic void\nath11k_dp_tx_htt_tx_complete_buf(struct ath11k_base *ab,\n\t\t\t\t struct dp_tx_ring *tx_ring,\n\t\t\t\t struct ath11k_dp_htt_wbm_tx_status *ts)\n{\n\tstruct ieee80211_tx_status status = { 0 };\n\tstruct sk_buff *msdu;\n\tstruct ieee80211_tx_info *info;\n\tstruct ath11k_skb_cb *skb_cb;\n\tstruct ath11k *ar;\n\tstruct ath11k_peer *peer;\n\n\tspin_lock(&tx_ring->tx_idr_lock);\n\tmsdu = idr_remove(&tx_ring->txbuf_idr, ts->msdu_id);\n\tspin_unlock(&tx_ring->tx_idr_lock);\n\n\tif (unlikely(!msdu)) {\n\t\tath11k_warn(ab, \"htt tx completion for unknown msdu_id %d\\n\",\n\t\t\t    ts->msdu_id);\n\t\treturn;\n\t}\n\n\tskb_cb = ATH11K_SKB_CB(msdu);\n\tinfo = IEEE80211_SKB_CB(msdu);\n\n\tar = skb_cb->ar;\n\n\tif (atomic_dec_and_test(&ar->dp.num_tx_pending))\n\t\twake_up(&ar->dp.tx_empty_waitq);\n\n\tdma_unmap_single(ab->dev, skb_cb->paddr, msdu->len, DMA_TO_DEVICE);\n\n\tif (!skb_cb->vif) {\n\t\tieee80211_free_txskb(ar->hw, msdu);\n\t\treturn;\n\t}\n\n\tmemset(&info->status, 0, sizeof(info->status));\n\n\tif (ts->acked) {\n\t\tif (!(info->flags & IEEE80211_TX_CTL_NO_ACK)) {\n\t\t\tinfo->flags |= IEEE80211_TX_STAT_ACK;\n\t\t\tinfo->status.ack_signal = ATH11K_DEFAULT_NOISE_FLOOR +\n\t\t\t\t\t\t  ts->ack_rssi;\n\t\t\tinfo->status.flags |=\n\t\t\t\tIEEE80211_TX_STATUS_ACK_SIGNAL_VALID;\n\t\t} else {\n\t\t\tinfo->flags |= IEEE80211_TX_STAT_NOACK_TRANSMITTED;\n\t\t}\n\t}\n\n\tspin_lock_bh(&ab->base_lock);\n\tpeer = ath11k_peer_find_by_id(ab, ts->peer_id);\n\tif (!peer || !peer->sta) {\n\t\tath11k_dbg(ab, ATH11K_DBG_DATA,\n\t\t\t   \"dp_tx: failed to find the peer with peer_id %d\\n\",\n\t\t\t    ts->peer_id);\n\t\tspin_unlock_bh(&ab->base_lock);\n\t\tieee80211_free_txskb(ar->hw, msdu);\n\t\treturn;\n\t}\n\tspin_unlock_bh(&ab->base_lock);\n\n\tstatus.sta = peer->sta;\n\tstatus.info = info;\n\tstatus.skb = msdu;\n\n\tieee80211_tx_status_ext(ar->hw, &status);\n}\n\nstatic void\nath11k_dp_tx_process_htt_tx_complete(struct ath11k_base *ab,\n\t\t\t\t     void *desc, u8 mac_id,\n\t\t\t\t     u32 msdu_id, struct dp_tx_ring *tx_ring)\n{\n\tstruct htt_tx_wbm_completion *status_desc;\n\tstruct ath11k_dp_htt_wbm_tx_status ts = {0};\n\tenum hal_wbm_htt_tx_comp_status wbm_status;\n\n\tstatus_desc = desc + HTT_TX_WBM_COMP_STATUS_OFFSET;\n\n\twbm_status = FIELD_GET(HTT_TX_WBM_COMP_INFO0_STATUS,\n\t\t\t       status_desc->info0);\n\tswitch (wbm_status) {\n\tcase HAL_WBM_REL_HTT_TX_COMP_STATUS_OK:\n\tcase HAL_WBM_REL_HTT_TX_COMP_STATUS_DROP:\n\tcase HAL_WBM_REL_HTT_TX_COMP_STATUS_TTL:\n\t\tts.acked = (wbm_status == HAL_WBM_REL_HTT_TX_COMP_STATUS_OK);\n\t\tts.msdu_id = msdu_id;\n\t\tts.ack_rssi = FIELD_GET(HTT_TX_WBM_COMP_INFO1_ACK_RSSI,\n\t\t\t\t\tstatus_desc->info1);\n\n\t\tif (FIELD_GET(HTT_TX_WBM_COMP_INFO2_VALID, status_desc->info2))\n\t\t\tts.peer_id = FIELD_GET(HTT_TX_WBM_COMP_INFO2_SW_PEER_ID,\n\t\t\t\t\t       status_desc->info2);\n\t\telse\n\t\t\tts.peer_id = HTT_INVALID_PEER_ID;\n\n\t\tath11k_dp_tx_htt_tx_complete_buf(ab, tx_ring, &ts);\n\n\t\tbreak;\n\tcase HAL_WBM_REL_HTT_TX_COMP_STATUS_REINJ:\n\tcase HAL_WBM_REL_HTT_TX_COMP_STATUS_INSPECT:\n\t\tath11k_dp_tx_free_txbuf(ab, mac_id, msdu_id, tx_ring);\n\t\tbreak;\n\tcase HAL_WBM_REL_HTT_TX_COMP_STATUS_MEC_NOTIFY:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tath11k_warn(ab, \"Unknown htt tx status %d\\n\", wbm_status);\n\t\tbreak;\n\t}\n}\n\nstatic void ath11k_dp_tx_cache_peer_stats(struct ath11k *ar,\n\t\t\t\t\t  struct sk_buff *msdu,\n\t\t\t\t\t  struct hal_tx_status *ts)\n{\n\tstruct ath11k_per_peer_tx_stats *peer_stats = &ar->cached_stats;\n\n\tif (ts->try_cnt > 1) {\n\t\tpeer_stats->retry_pkts += ts->try_cnt - 1;\n\t\tpeer_stats->retry_bytes += (ts->try_cnt - 1) * msdu->len;\n\n\t\tif (ts->status != HAL_WBM_TQM_REL_REASON_FRAME_ACKED) {\n\t\t\tpeer_stats->failed_pkts += 1;\n\t\t\tpeer_stats->failed_bytes += msdu->len;\n\t\t}\n\t}\n}\n\nvoid ath11k_dp_tx_update_txcompl(struct ath11k *ar, struct hal_tx_status *ts)\n{\n\tstruct ath11k_base *ab = ar->ab;\n\tstruct ath11k_per_peer_tx_stats *peer_stats = &ar->cached_stats;\n\tenum hal_tx_rate_stats_pkt_type pkt_type;\n\tenum hal_tx_rate_stats_sgi sgi;\n\tenum hal_tx_rate_stats_bw bw;\n\tstruct ath11k_peer *peer;\n\tstruct ath11k_sta *arsta;\n\tstruct ieee80211_sta *sta;\n\tu16 rate, ru_tones;\n\tu8 mcs, rate_idx = 0, ofdma;\n\tint ret;\n\n\tspin_lock_bh(&ab->base_lock);\n\tpeer = ath11k_peer_find_by_id(ab, ts->peer_id);\n\tif (!peer || !peer->sta) {\n\t\tath11k_dbg(ab, ATH11K_DBG_DP_TX,\n\t\t\t   \"failed to find the peer by id %u\\n\", ts->peer_id);\n\t\tgoto err_out;\n\t}\n\n\tsta = peer->sta;\n\tarsta = (struct ath11k_sta *)sta->drv_priv;\n\n\tmemset(&arsta->txrate, 0, sizeof(arsta->txrate));\n\tpkt_type = FIELD_GET(HAL_TX_RATE_STATS_INFO0_PKT_TYPE,\n\t\t\t     ts->rate_stats);\n\tmcs = FIELD_GET(HAL_TX_RATE_STATS_INFO0_MCS,\n\t\t\tts->rate_stats);\n\tsgi = FIELD_GET(HAL_TX_RATE_STATS_INFO0_SGI,\n\t\t\tts->rate_stats);\n\tbw = FIELD_GET(HAL_TX_RATE_STATS_INFO0_BW, ts->rate_stats);\n\tru_tones = FIELD_GET(HAL_TX_RATE_STATS_INFO0_TONES_IN_RU, ts->rate_stats);\n\tofdma = FIELD_GET(HAL_TX_RATE_STATS_INFO0_OFDMA_TX, ts->rate_stats);\n\n\t \n\tif (arsta->last_txrate.nss)\n\t\tarsta->txrate.nss = arsta->last_txrate.nss;\n\telse\n\t\tarsta->txrate.nss = arsta->peer_nss;\n\n\tif (pkt_type == HAL_TX_RATE_STATS_PKT_TYPE_11A ||\n\t    pkt_type == HAL_TX_RATE_STATS_PKT_TYPE_11B) {\n\t\tret = ath11k_mac_hw_ratecode_to_legacy_rate(mcs,\n\t\t\t\t\t\t\t    pkt_type,\n\t\t\t\t\t\t\t    &rate_idx,\n\t\t\t\t\t\t\t    &rate);\n\t\tif (ret < 0)\n\t\t\tgoto err_out;\n\t\tarsta->txrate.legacy = rate;\n\t} else if (pkt_type == HAL_TX_RATE_STATS_PKT_TYPE_11N) {\n\t\tif (mcs > 7) {\n\t\t\tath11k_warn(ab, \"Invalid HT mcs index %d\\n\", mcs);\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tif (arsta->txrate.nss != 0)\n\t\t\tarsta->txrate.mcs = mcs + 8 * (arsta->txrate.nss - 1);\n\t\tarsta->txrate.flags = RATE_INFO_FLAGS_MCS;\n\t\tif (sgi)\n\t\t\tarsta->txrate.flags |= RATE_INFO_FLAGS_SHORT_GI;\n\t} else if (pkt_type == HAL_TX_RATE_STATS_PKT_TYPE_11AC) {\n\t\tif (mcs > 9) {\n\t\t\tath11k_warn(ab, \"Invalid VHT mcs index %d\\n\", mcs);\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tarsta->txrate.mcs = mcs;\n\t\tarsta->txrate.flags = RATE_INFO_FLAGS_VHT_MCS;\n\t\tif (sgi)\n\t\t\tarsta->txrate.flags |= RATE_INFO_FLAGS_SHORT_GI;\n\t} else if (pkt_type == HAL_TX_RATE_STATS_PKT_TYPE_11AX) {\n\t\tif (mcs > 11) {\n\t\t\tath11k_warn(ab, \"Invalid HE mcs index %d\\n\", mcs);\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tarsta->txrate.mcs = mcs;\n\t\tarsta->txrate.flags = RATE_INFO_FLAGS_HE_MCS;\n\t\tarsta->txrate.he_gi = ath11k_mac_he_gi_to_nl80211_he_gi(sgi);\n\t}\n\n\tarsta->txrate.bw = ath11k_mac_bw_to_mac80211_bw(bw);\n\tif (ofdma && pkt_type == HAL_TX_RATE_STATS_PKT_TYPE_11AX) {\n\t\tarsta->txrate.bw = RATE_INFO_BW_HE_RU;\n\t\tarsta->txrate.he_ru_alloc =\n\t\t\tath11k_mac_he_ru_tones_to_nl80211_he_ru_alloc(ru_tones);\n\t}\n\n\tif (ath11k_debugfs_is_extd_tx_stats_enabled(ar))\n\t\tath11k_debugfs_sta_add_tx_stats(arsta, peer_stats, rate_idx);\n\nerr_out:\n\tspin_unlock_bh(&ab->base_lock);\n}\n\nstatic void ath11k_dp_tx_complete_msdu(struct ath11k *ar,\n\t\t\t\t       struct sk_buff *msdu,\n\t\t\t\t       struct hal_tx_status *ts)\n{\n\tstruct ieee80211_tx_status status = { 0 };\n\tstruct ieee80211_rate_status status_rate = { 0 };\n\tstruct ath11k_base *ab = ar->ab;\n\tstruct ieee80211_tx_info *info;\n\tstruct ath11k_skb_cb *skb_cb;\n\tstruct ath11k_peer *peer;\n\tstruct ath11k_sta *arsta;\n\tstruct rate_info rate;\n\n\tif (WARN_ON_ONCE(ts->buf_rel_source != HAL_WBM_REL_SRC_MODULE_TQM)) {\n\t\t \n\t\treturn;\n\t}\n\n\tskb_cb = ATH11K_SKB_CB(msdu);\n\n\tdma_unmap_single(ab->dev, skb_cb->paddr, msdu->len, DMA_TO_DEVICE);\n\n\tif (unlikely(!rcu_access_pointer(ab->pdevs_active[ar->pdev_idx]))) {\n\t\tieee80211_free_txskb(ar->hw, msdu);\n\t\treturn;\n\t}\n\n\tif (unlikely(!skb_cb->vif)) {\n\t\tieee80211_free_txskb(ar->hw, msdu);\n\t\treturn;\n\t}\n\n\tinfo = IEEE80211_SKB_CB(msdu);\n\tmemset(&info->status, 0, sizeof(info->status));\n\n\t \n\tinfo->status.rates[0].idx = -1;\n\n\tif (ts->status == HAL_WBM_TQM_REL_REASON_FRAME_ACKED &&\n\t    !(info->flags & IEEE80211_TX_CTL_NO_ACK)) {\n\t\tinfo->flags |= IEEE80211_TX_STAT_ACK;\n\t\tinfo->status.ack_signal = ATH11K_DEFAULT_NOISE_FLOOR +\n\t\t\t\t\t  ts->ack_rssi;\n\t\tinfo->status.flags |= IEEE80211_TX_STATUS_ACK_SIGNAL_VALID;\n\t}\n\n\tif (ts->status == HAL_WBM_TQM_REL_REASON_CMD_REMOVE_TX &&\n\t    (info->flags & IEEE80211_TX_CTL_NO_ACK))\n\t\tinfo->flags |= IEEE80211_TX_STAT_NOACK_TRANSMITTED;\n\n\tif (unlikely(ath11k_debugfs_is_extd_tx_stats_enabled(ar)) ||\n\t    ab->hw_params.single_pdev_only) {\n\t\tif (ts->flags & HAL_TX_STATUS_FLAGS_FIRST_MSDU) {\n\t\t\tif (ar->last_ppdu_id == 0) {\n\t\t\t\tar->last_ppdu_id = ts->ppdu_id;\n\t\t\t} else if (ar->last_ppdu_id == ts->ppdu_id ||\n\t\t\t\t   ar->cached_ppdu_id == ar->last_ppdu_id) {\n\t\t\t\tar->cached_ppdu_id = ar->last_ppdu_id;\n\t\t\t\tar->cached_stats.is_ampdu = true;\n\t\t\t\tath11k_dp_tx_update_txcompl(ar, ts);\n\t\t\t\tmemset(&ar->cached_stats, 0,\n\t\t\t\t       sizeof(struct ath11k_per_peer_tx_stats));\n\t\t\t} else {\n\t\t\t\tar->cached_stats.is_ampdu = false;\n\t\t\t\tath11k_dp_tx_update_txcompl(ar, ts);\n\t\t\t\tmemset(&ar->cached_stats, 0,\n\t\t\t\t       sizeof(struct ath11k_per_peer_tx_stats));\n\t\t\t}\n\t\t\tar->last_ppdu_id = ts->ppdu_id;\n\t\t}\n\n\t\tath11k_dp_tx_cache_peer_stats(ar, msdu, ts);\n\t}\n\n\tspin_lock_bh(&ab->base_lock);\n\tpeer = ath11k_peer_find_by_id(ab, ts->peer_id);\n\tif (!peer || !peer->sta) {\n\t\tath11k_dbg(ab, ATH11K_DBG_DATA,\n\t\t\t   \"dp_tx: failed to find the peer with peer_id %d\\n\",\n\t\t\t    ts->peer_id);\n\t\tspin_unlock_bh(&ab->base_lock);\n\t\tieee80211_free_txskb(ar->hw, msdu);\n\t\treturn;\n\t}\n\tarsta = (struct ath11k_sta *)peer->sta->drv_priv;\n\tstatus.sta = peer->sta;\n\tstatus.skb = msdu;\n\tstatus.info = info;\n\trate = arsta->last_txrate;\n\n\tstatus_rate.rate_idx = rate;\n\tstatus_rate.try_count = 1;\n\n\tstatus.rates = &status_rate;\n\tstatus.n_rates = 1;\n\n\tspin_unlock_bh(&ab->base_lock);\n\n\tieee80211_tx_status_ext(ar->hw, &status);\n}\n\nstatic inline void ath11k_dp_tx_status_parse(struct ath11k_base *ab,\n\t\t\t\t\t     struct hal_wbm_release_ring *desc,\n\t\t\t\t\t     struct hal_tx_status *ts)\n{\n\tts->buf_rel_source =\n\t\tFIELD_GET(HAL_WBM_RELEASE_INFO0_REL_SRC_MODULE, desc->info0);\n\tif (unlikely(ts->buf_rel_source != HAL_WBM_REL_SRC_MODULE_FW &&\n\t\t     ts->buf_rel_source != HAL_WBM_REL_SRC_MODULE_TQM))\n\t\treturn;\n\n\tif (unlikely(ts->buf_rel_source == HAL_WBM_REL_SRC_MODULE_FW))\n\t\treturn;\n\n\tts->status = FIELD_GET(HAL_WBM_RELEASE_INFO0_TQM_RELEASE_REASON,\n\t\t\t       desc->info0);\n\tts->ppdu_id = FIELD_GET(HAL_WBM_RELEASE_INFO1_TQM_STATUS_NUMBER,\n\t\t\t\tdesc->info1);\n\tts->try_cnt = FIELD_GET(HAL_WBM_RELEASE_INFO1_TRANSMIT_COUNT,\n\t\t\t\tdesc->info1);\n\tts->ack_rssi = FIELD_GET(HAL_WBM_RELEASE_INFO2_ACK_FRAME_RSSI,\n\t\t\t\t desc->info2);\n\tif (desc->info2 & HAL_WBM_RELEASE_INFO2_FIRST_MSDU)\n\t\tts->flags |= HAL_TX_STATUS_FLAGS_FIRST_MSDU;\n\tts->peer_id = FIELD_GET(HAL_WBM_RELEASE_INFO3_PEER_ID, desc->info3);\n\tts->tid = FIELD_GET(HAL_WBM_RELEASE_INFO3_TID, desc->info3);\n\tif (desc->rate_stats.info0 & HAL_TX_RATE_STATS_INFO0_VALID)\n\t\tts->rate_stats = desc->rate_stats.info0;\n\telse\n\t\tts->rate_stats = 0;\n}\n\nvoid ath11k_dp_tx_completion_handler(struct ath11k_base *ab, int ring_id)\n{\n\tstruct ath11k *ar;\n\tstruct ath11k_dp *dp = &ab->dp;\n\tint hal_ring_id = dp->tx_ring[ring_id].tcl_comp_ring.ring_id;\n\tstruct hal_srng *status_ring = &ab->hal.srng_list[hal_ring_id];\n\tstruct sk_buff *msdu;\n\tstruct hal_tx_status ts = { 0 };\n\tstruct dp_tx_ring *tx_ring = &dp->tx_ring[ring_id];\n\tu32 *desc;\n\tu32 msdu_id;\n\tu8 mac_id;\n\n\tspin_lock_bh(&status_ring->lock);\n\n\tath11k_hal_srng_access_begin(ab, status_ring);\n\n\twhile ((ATH11K_TX_COMPL_NEXT(tx_ring->tx_status_head) !=\n\t\ttx_ring->tx_status_tail) &&\n\t       (desc = ath11k_hal_srng_dst_get_next_entry(ab, status_ring))) {\n\t\tmemcpy(&tx_ring->tx_status[tx_ring->tx_status_head],\n\t\t       desc, sizeof(struct hal_wbm_release_ring));\n\t\ttx_ring->tx_status_head =\n\t\t\tATH11K_TX_COMPL_NEXT(tx_ring->tx_status_head);\n\t}\n\n\tif (unlikely((ath11k_hal_srng_dst_peek(ab, status_ring) != NULL) &&\n\t\t     (ATH11K_TX_COMPL_NEXT(tx_ring->tx_status_head) ==\n\t\t      tx_ring->tx_status_tail))) {\n\t\t \n\t\tath11k_warn(ab, \"Unable to process some of the tx_status ring desc because status_fifo is full\\n\");\n\t}\n\n\tath11k_hal_srng_access_end(ab, status_ring);\n\n\tspin_unlock_bh(&status_ring->lock);\n\n\twhile (ATH11K_TX_COMPL_NEXT(tx_ring->tx_status_tail) != tx_ring->tx_status_head) {\n\t\tstruct hal_wbm_release_ring *tx_status;\n\t\tu32 desc_id;\n\n\t\ttx_ring->tx_status_tail =\n\t\t\tATH11K_TX_COMPL_NEXT(tx_ring->tx_status_tail);\n\t\ttx_status = &tx_ring->tx_status[tx_ring->tx_status_tail];\n\t\tath11k_dp_tx_status_parse(ab, tx_status, &ts);\n\n\t\tdesc_id = FIELD_GET(BUFFER_ADDR_INFO1_SW_COOKIE,\n\t\t\t\t    tx_status->buf_addr_info.info1);\n\t\tmac_id = FIELD_GET(DP_TX_DESC_ID_MAC_ID, desc_id);\n\t\tmsdu_id = FIELD_GET(DP_TX_DESC_ID_MSDU_ID, desc_id);\n\n\t\tif (unlikely(ts.buf_rel_source == HAL_WBM_REL_SRC_MODULE_FW)) {\n\t\t\tath11k_dp_tx_process_htt_tx_complete(ab,\n\t\t\t\t\t\t\t     (void *)tx_status,\n\t\t\t\t\t\t\t     mac_id, msdu_id,\n\t\t\t\t\t\t\t     tx_ring);\n\t\t\tcontinue;\n\t\t}\n\n\t\tspin_lock(&tx_ring->tx_idr_lock);\n\t\tmsdu = idr_remove(&tx_ring->txbuf_idr, msdu_id);\n\t\tif (unlikely(!msdu)) {\n\t\t\tath11k_warn(ab, \"tx completion for unknown msdu_id %d\\n\",\n\t\t\t\t    msdu_id);\n\t\t\tspin_unlock(&tx_ring->tx_idr_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tspin_unlock(&tx_ring->tx_idr_lock);\n\n\t\tar = ab->pdevs[mac_id].ar;\n\n\t\tif (atomic_dec_and_test(&ar->dp.num_tx_pending))\n\t\t\twake_up(&ar->dp.tx_empty_waitq);\n\n\t\tath11k_dp_tx_complete_msdu(ar, msdu, &ts);\n\t}\n}\n\nint ath11k_dp_tx_send_reo_cmd(struct ath11k_base *ab, struct dp_rx_tid *rx_tid,\n\t\t\t      enum hal_reo_cmd_type type,\n\t\t\t      struct ath11k_hal_reo_cmd *cmd,\n\t\t\t      void (*cb)(struct ath11k_dp *, void *,\n\t\t\t\t\t enum hal_reo_cmd_status))\n{\n\tstruct ath11k_dp *dp = &ab->dp;\n\tstruct dp_reo_cmd *dp_cmd;\n\tstruct hal_srng *cmd_ring;\n\tint cmd_num;\n\n\tif (test_bit(ATH11K_FLAG_CRASH_FLUSH, &ab->dev_flags))\n\t\treturn -ESHUTDOWN;\n\n\tcmd_ring = &ab->hal.srng_list[dp->reo_cmd_ring.ring_id];\n\tcmd_num = ath11k_hal_reo_cmd_send(ab, cmd_ring, type, cmd);\n\n\t \n\tif (cmd_num < 0)\n\t\treturn cmd_num;\n\n\t \n\tif (cmd_num == 0)\n\t\treturn -EINVAL;\n\n\tif (!cb)\n\t\treturn 0;\n\n\t \n\tdp_cmd = kzalloc(sizeof(*dp_cmd), GFP_ATOMIC);\n\n\tif (!dp_cmd)\n\t\treturn -ENOMEM;\n\n\tmemcpy(&dp_cmd->data, rx_tid, sizeof(struct dp_rx_tid));\n\tdp_cmd->cmd_num = cmd_num;\n\tdp_cmd->handler = cb;\n\n\tspin_lock_bh(&dp->reo_cmd_lock);\n\tlist_add_tail(&dp_cmd->list, &dp->reo_cmd_list);\n\tspin_unlock_bh(&dp->reo_cmd_lock);\n\n\treturn 0;\n}\n\nstatic int\nath11k_dp_tx_get_ring_id_type(struct ath11k_base *ab,\n\t\t\t      int mac_id, u32 ring_id,\n\t\t\t      enum hal_ring_type ring_type,\n\t\t\t      enum htt_srng_ring_type *htt_ring_type,\n\t\t\t      enum htt_srng_ring_id *htt_ring_id)\n{\n\tint lmac_ring_id_offset = 0;\n\tint ret = 0;\n\n\tswitch (ring_type) {\n\tcase HAL_RXDMA_BUF:\n\t\tlmac_ring_id_offset = mac_id * HAL_SRNG_RINGS_PER_LMAC;\n\n\t\t \n\t\tif (!ab->hw_params.rx_mac_buf_ring) {\n\t\t\tif (!(ring_id == (HAL_SRNG_RING_ID_WMAC1_SW2RXDMA0_BUF +\n\t\t\t\t\t  lmac_ring_id_offset) ||\n\t\t\t\tring_id == (HAL_SRNG_RING_ID_WMAC1_SW2RXDMA1_BUF +\n\t\t\t\t\tlmac_ring_id_offset))) {\n\t\t\t\tret = -EINVAL;\n\t\t\t}\n\t\t\t*htt_ring_id = HTT_RXDMA_HOST_BUF_RING;\n\t\t\t*htt_ring_type = HTT_SW_TO_HW_RING;\n\t\t} else {\n\t\t\tif (ring_id == HAL_SRNG_RING_ID_WMAC1_SW2RXDMA0_BUF) {\n\t\t\t\t*htt_ring_id = HTT_HOST1_TO_FW_RXBUF_RING;\n\t\t\t\t*htt_ring_type = HTT_SW_TO_SW_RING;\n\t\t\t} else {\n\t\t\t\t*htt_ring_id = HTT_RXDMA_HOST_BUF_RING;\n\t\t\t\t*htt_ring_type = HTT_SW_TO_HW_RING;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase HAL_RXDMA_DST:\n\t\t*htt_ring_id = HTT_RXDMA_NON_MONITOR_DEST_RING;\n\t\t*htt_ring_type = HTT_HW_TO_SW_RING;\n\t\tbreak;\n\tcase HAL_RXDMA_MONITOR_BUF:\n\t\t*htt_ring_id = HTT_RXDMA_MONITOR_BUF_RING;\n\t\t*htt_ring_type = HTT_SW_TO_HW_RING;\n\t\tbreak;\n\tcase HAL_RXDMA_MONITOR_STATUS:\n\t\t*htt_ring_id = HTT_RXDMA_MONITOR_STATUS_RING;\n\t\t*htt_ring_type = HTT_SW_TO_HW_RING;\n\t\tbreak;\n\tcase HAL_RXDMA_MONITOR_DST:\n\t\t*htt_ring_id = HTT_RXDMA_MONITOR_DEST_RING;\n\t\t*htt_ring_type = HTT_HW_TO_SW_RING;\n\t\tbreak;\n\tcase HAL_RXDMA_MONITOR_DESC:\n\t\t*htt_ring_id = HTT_RXDMA_MONITOR_DESC_RING;\n\t\t*htt_ring_type = HTT_SW_TO_HW_RING;\n\t\tbreak;\n\tdefault:\n\t\tath11k_warn(ab, \"Unsupported ring type in DP :%d\\n\", ring_type);\n\t\tret = -EINVAL;\n\t}\n\treturn ret;\n}\n\nint ath11k_dp_tx_htt_srng_setup(struct ath11k_base *ab, u32 ring_id,\n\t\t\t\tint mac_id, enum hal_ring_type ring_type)\n{\n\tstruct htt_srng_setup_cmd *cmd;\n\tstruct hal_srng *srng = &ab->hal.srng_list[ring_id];\n\tstruct hal_srng_params params;\n\tstruct sk_buff *skb;\n\tu32 ring_entry_sz;\n\tint len = sizeof(*cmd);\n\tdma_addr_t hp_addr, tp_addr;\n\tenum htt_srng_ring_type htt_ring_type;\n\tenum htt_srng_ring_id htt_ring_id;\n\tint ret;\n\n\tskb = ath11k_htc_alloc_skb(ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tmemset(&params, 0, sizeof(params));\n\tath11k_hal_srng_get_params(ab, srng, &params);\n\n\thp_addr = ath11k_hal_srng_get_hp_addr(ab, srng);\n\ttp_addr = ath11k_hal_srng_get_tp_addr(ab, srng);\n\n\tret = ath11k_dp_tx_get_ring_id_type(ab, mac_id, ring_id,\n\t\t\t\t\t    ring_type, &htt_ring_type,\n\t\t\t\t\t    &htt_ring_id);\n\tif (ret)\n\t\tgoto err_free;\n\n\tskb_put(skb, len);\n\tcmd = (struct htt_srng_setup_cmd *)skb->data;\n\tcmd->info0 = FIELD_PREP(HTT_SRNG_SETUP_CMD_INFO0_MSG_TYPE,\n\t\t\t\tHTT_H2T_MSG_TYPE_SRING_SETUP);\n\tif (htt_ring_type == HTT_SW_TO_HW_RING ||\n\t    htt_ring_type == HTT_HW_TO_SW_RING)\n\t\tcmd->info0 |= FIELD_PREP(HTT_SRNG_SETUP_CMD_INFO0_PDEV_ID,\n\t\t\t\t\t DP_SW2HW_MACID(mac_id));\n\telse\n\t\tcmd->info0 |= FIELD_PREP(HTT_SRNG_SETUP_CMD_INFO0_PDEV_ID,\n\t\t\t\t\t mac_id);\n\tcmd->info0 |= FIELD_PREP(HTT_SRNG_SETUP_CMD_INFO0_RING_TYPE,\n\t\t\t\t htt_ring_type);\n\tcmd->info0 |= FIELD_PREP(HTT_SRNG_SETUP_CMD_INFO0_RING_ID, htt_ring_id);\n\n\tcmd->ring_base_addr_lo = params.ring_base_paddr &\n\t\t\t\t HAL_ADDR_LSB_REG_MASK;\n\n\tcmd->ring_base_addr_hi = (u64)params.ring_base_paddr >>\n\t\t\t\t HAL_ADDR_MSB_REG_SHIFT;\n\n\tret = ath11k_hal_srng_get_entrysize(ab, ring_type);\n\tif (ret < 0)\n\t\tgoto err_free;\n\n\tring_entry_sz = ret;\n\n\tring_entry_sz >>= 2;\n\tcmd->info1 = FIELD_PREP(HTT_SRNG_SETUP_CMD_INFO1_RING_ENTRY_SIZE,\n\t\t\t\tring_entry_sz);\n\tcmd->info1 |= FIELD_PREP(HTT_SRNG_SETUP_CMD_INFO1_RING_SIZE,\n\t\t\t\t params.num_entries * ring_entry_sz);\n\tcmd->info1 |= FIELD_PREP(HTT_SRNG_SETUP_CMD_INFO1_RING_FLAGS_MSI_SWAP,\n\t\t\t\t !!(params.flags & HAL_SRNG_FLAGS_MSI_SWAP));\n\tcmd->info1 |= FIELD_PREP(\n\t\t\tHTT_SRNG_SETUP_CMD_INFO1_RING_FLAGS_TLV_SWAP,\n\t\t\t!!(params.flags & HAL_SRNG_FLAGS_DATA_TLV_SWAP));\n\tcmd->info1 |= FIELD_PREP(\n\t\t\tHTT_SRNG_SETUP_CMD_INFO1_RING_FLAGS_HOST_FW_SWAP,\n\t\t\t!!(params.flags & HAL_SRNG_FLAGS_RING_PTR_SWAP));\n\tif (htt_ring_type == HTT_SW_TO_HW_RING)\n\t\tcmd->info1 |= HTT_SRNG_SETUP_CMD_INFO1_RING_LOOP_CNT_DIS;\n\n\tcmd->ring_head_off32_remote_addr_lo = hp_addr & HAL_ADDR_LSB_REG_MASK;\n\tcmd->ring_head_off32_remote_addr_hi = (u64)hp_addr >>\n\t\t\t\t\t      HAL_ADDR_MSB_REG_SHIFT;\n\n\tcmd->ring_tail_off32_remote_addr_lo = tp_addr & HAL_ADDR_LSB_REG_MASK;\n\tcmd->ring_tail_off32_remote_addr_hi = (u64)tp_addr >>\n\t\t\t\t\t      HAL_ADDR_MSB_REG_SHIFT;\n\n\tcmd->ring_msi_addr_lo = lower_32_bits(params.msi_addr);\n\tcmd->ring_msi_addr_hi = upper_32_bits(params.msi_addr);\n\tcmd->msi_data = params.msi_data;\n\n\tcmd->intr_info = FIELD_PREP(\n\t\t\tHTT_SRNG_SETUP_CMD_INTR_INFO_BATCH_COUNTER_THRESH,\n\t\t\tparams.intr_batch_cntr_thres_entries * ring_entry_sz);\n\tcmd->intr_info |= FIELD_PREP(\n\t\t\tHTT_SRNG_SETUP_CMD_INTR_INFO_INTR_TIMER_THRESH,\n\t\t\tparams.intr_timer_thres_us >> 3);\n\n\tcmd->info2 = 0;\n\tif (params.flags & HAL_SRNG_FLAGS_LOW_THRESH_INTR_EN) {\n\t\tcmd->info2 = FIELD_PREP(\n\t\t\t\tHTT_SRNG_SETUP_CMD_INFO2_INTR_LOW_THRESH,\n\t\t\t\tparams.low_threshold);\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_DP_TX,\n\t\t   \"htt srng setup msi_addr_lo 0x%x msi_addr_hi 0x%x msi_data 0x%x ring_id %d ring_type %d intr_info 0x%x flags 0x%x\\n\",\n\t\t   cmd->ring_msi_addr_lo, cmd->ring_msi_addr_hi,\n\t\t   cmd->msi_data, ring_id, ring_type, cmd->intr_info, cmd->info2);\n\n\tret = ath11k_htc_send(&ab->htc, ab->dp.eid, skb);\n\tif (ret)\n\t\tgoto err_free;\n\n\treturn 0;\n\nerr_free:\n\tdev_kfree_skb_any(skb);\n\n\treturn ret;\n}\n\n#define HTT_TARGET_VERSION_TIMEOUT_HZ (3 * HZ)\n\nint ath11k_dp_tx_htt_h2t_ver_req_msg(struct ath11k_base *ab)\n{\n\tstruct ath11k_dp *dp = &ab->dp;\n\tstruct sk_buff *skb;\n\tstruct htt_ver_req_cmd *cmd;\n\tint len = sizeof(*cmd);\n\tint ret;\n\n\tinit_completion(&dp->htt_tgt_version_received);\n\n\tskb = ath11k_htc_alloc_skb(ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put(skb, len);\n\tcmd = (struct htt_ver_req_cmd *)skb->data;\n\tcmd->ver_reg_info = FIELD_PREP(HTT_VER_REQ_INFO_MSG_ID,\n\t\t\t\t       HTT_H2T_MSG_TYPE_VERSION_REQ);\n\n\tret = ath11k_htc_send(&ab->htc, dp->eid, skb);\n\tif (ret) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn ret;\n\t}\n\n\tret = wait_for_completion_timeout(&dp->htt_tgt_version_received,\n\t\t\t\t\t  HTT_TARGET_VERSION_TIMEOUT_HZ);\n\tif (ret == 0) {\n\t\tath11k_warn(ab, \"htt target version request timed out\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tif (dp->htt_tgt_ver_major != HTT_TARGET_VERSION_MAJOR) {\n\t\tath11k_err(ab, \"unsupported htt major version %d supported version is %d\\n\",\n\t\t\t   dp->htt_tgt_ver_major, HTT_TARGET_VERSION_MAJOR);\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nint ath11k_dp_tx_htt_h2t_ppdu_stats_req(struct ath11k *ar, u32 mask)\n{\n\tstruct ath11k_base *ab = ar->ab;\n\tstruct ath11k_dp *dp = &ab->dp;\n\tstruct sk_buff *skb;\n\tstruct htt_ppdu_stats_cfg_cmd *cmd;\n\tint len = sizeof(*cmd);\n\tu8 pdev_mask;\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < ab->hw_params.num_rxmda_per_pdev; i++) {\n\t\tskb = ath11k_htc_alloc_skb(ab, len);\n\t\tif (!skb)\n\t\t\treturn -ENOMEM;\n\n\t\tskb_put(skb, len);\n\t\tcmd = (struct htt_ppdu_stats_cfg_cmd *)skb->data;\n\t\tcmd->msg = FIELD_PREP(HTT_PPDU_STATS_CFG_MSG_TYPE,\n\t\t\t\t      HTT_H2T_MSG_TYPE_PPDU_STATS_CFG);\n\n\t\tpdev_mask = 1 << (ar->pdev_idx + i);\n\t\tcmd->msg |= FIELD_PREP(HTT_PPDU_STATS_CFG_PDEV_ID, pdev_mask);\n\t\tcmd->msg |= FIELD_PREP(HTT_PPDU_STATS_CFG_TLV_TYPE_BITMASK, mask);\n\n\t\tret = ath11k_htc_send(&ab->htc, dp->eid, skb);\n\t\tif (ret) {\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint ath11k_dp_tx_htt_rx_filter_setup(struct ath11k_base *ab, u32 ring_id,\n\t\t\t\t     int mac_id, enum hal_ring_type ring_type,\n\t\t\t\t     int rx_buf_size,\n\t\t\t\t     struct htt_rx_ring_tlv_filter *tlv_filter)\n{\n\tstruct htt_rx_ring_selection_cfg_cmd *cmd;\n\tstruct hal_srng *srng = &ab->hal.srng_list[ring_id];\n\tstruct hal_srng_params params;\n\tstruct sk_buff *skb;\n\tint len = sizeof(*cmd);\n\tenum htt_srng_ring_type htt_ring_type;\n\tenum htt_srng_ring_id htt_ring_id;\n\tint ret;\n\n\tskb = ath11k_htc_alloc_skb(ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tmemset(&params, 0, sizeof(params));\n\tath11k_hal_srng_get_params(ab, srng, &params);\n\n\tret = ath11k_dp_tx_get_ring_id_type(ab, mac_id, ring_id,\n\t\t\t\t\t    ring_type, &htt_ring_type,\n\t\t\t\t\t    &htt_ring_id);\n\tif (ret)\n\t\tgoto err_free;\n\n\tskb_put(skb, len);\n\tcmd = (struct htt_rx_ring_selection_cfg_cmd *)skb->data;\n\tcmd->info0 = FIELD_PREP(HTT_RX_RING_SELECTION_CFG_CMD_INFO0_MSG_TYPE,\n\t\t\t\tHTT_H2T_MSG_TYPE_RX_RING_SELECTION_CFG);\n\tif (htt_ring_type == HTT_SW_TO_HW_RING ||\n\t    htt_ring_type == HTT_HW_TO_SW_RING)\n\t\tcmd->info0 |=\n\t\t\tFIELD_PREP(HTT_RX_RING_SELECTION_CFG_CMD_INFO0_PDEV_ID,\n\t\t\t\t   DP_SW2HW_MACID(mac_id));\n\telse\n\t\tcmd->info0 |=\n\t\t\tFIELD_PREP(HTT_RX_RING_SELECTION_CFG_CMD_INFO0_PDEV_ID,\n\t\t\t\t   mac_id);\n\tcmd->info0 |= FIELD_PREP(HTT_RX_RING_SELECTION_CFG_CMD_INFO0_RING_ID,\n\t\t\t\t htt_ring_id);\n\tcmd->info0 |= FIELD_PREP(HTT_RX_RING_SELECTION_CFG_CMD_INFO0_SS,\n\t\t\t\t !!(params.flags & HAL_SRNG_FLAGS_MSI_SWAP));\n\tcmd->info0 |= FIELD_PREP(HTT_RX_RING_SELECTION_CFG_CMD_INFO0_PS,\n\t\t\t\t !!(params.flags & HAL_SRNG_FLAGS_DATA_TLV_SWAP));\n\n\tcmd->info1 = FIELD_PREP(HTT_RX_RING_SELECTION_CFG_CMD_INFO1_BUF_SIZE,\n\t\t\t\trx_buf_size);\n\tcmd->pkt_type_en_flags0 = tlv_filter->pkt_filter_flags0;\n\tcmd->pkt_type_en_flags1 = tlv_filter->pkt_filter_flags1;\n\tcmd->pkt_type_en_flags2 = tlv_filter->pkt_filter_flags2;\n\tcmd->pkt_type_en_flags3 = tlv_filter->pkt_filter_flags3;\n\tcmd->rx_filter_tlv = tlv_filter->rx_filter;\n\n\tret = ath11k_htc_send(&ab->htc, ab->dp.eid, skb);\n\tif (ret)\n\t\tgoto err_free;\n\n\treturn 0;\n\nerr_free:\n\tdev_kfree_skb_any(skb);\n\n\treturn ret;\n}\n\nint\nath11k_dp_tx_htt_h2t_ext_stats_req(struct ath11k *ar, u8 type,\n\t\t\t\t   struct htt_ext_stats_cfg_params *cfg_params,\n\t\t\t\t   u64 cookie)\n{\n\tstruct ath11k_base *ab = ar->ab;\n\tstruct ath11k_dp *dp = &ab->dp;\n\tstruct sk_buff *skb;\n\tstruct htt_ext_stats_cfg_cmd *cmd;\n\tu32 pdev_id;\n\tint len = sizeof(*cmd);\n\tint ret;\n\n\tskb = ath11k_htc_alloc_skb(ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put(skb, len);\n\n\tcmd = (struct htt_ext_stats_cfg_cmd *)skb->data;\n\tmemset(cmd, 0, sizeof(*cmd));\n\tcmd->hdr.msg_type = HTT_H2T_MSG_TYPE_EXT_STATS_CFG;\n\n\tif (ab->hw_params.single_pdev_only)\n\t\tpdev_id = ath11k_mac_get_target_pdev_id(ar);\n\telse\n\t\tpdev_id = ar->pdev->pdev_id;\n\n\tcmd->hdr.pdev_mask = 1 << pdev_id;\n\n\tcmd->hdr.stats_type = type;\n\tcmd->cfg_param0 = cfg_params->cfg0;\n\tcmd->cfg_param1 = cfg_params->cfg1;\n\tcmd->cfg_param2 = cfg_params->cfg2;\n\tcmd->cfg_param3 = cfg_params->cfg3;\n\tcmd->cookie_lsb = lower_32_bits(cookie);\n\tcmd->cookie_msb = upper_32_bits(cookie);\n\n\tret = ath11k_htc_send(&ab->htc, dp->eid, skb);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to send htt type stats request: %d\",\n\t\t\t    ret);\n\t\tdev_kfree_skb_any(skb);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint ath11k_dp_tx_htt_monitor_mode_ring_config(struct ath11k *ar, bool reset)\n{\n\tstruct ath11k_pdev_dp *dp = &ar->dp;\n\tstruct ath11k_base *ab = ar->ab;\n\tstruct htt_rx_ring_tlv_filter tlv_filter = {0};\n\tint ret = 0, ring_id = 0, i;\n\n\tif (ab->hw_params.full_monitor_mode) {\n\t\tret = ath11k_dp_tx_htt_rx_full_mon_setup(ab,\n\t\t\t\t\t\t\t dp->mac_id, !reset);\n\t\tif (ret < 0) {\n\t\t\tath11k_err(ab, \"failed to setup full monitor %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tring_id = dp->rxdma_mon_buf_ring.refill_buf_ring.ring_id;\n\n\tif (!reset) {\n\t\ttlv_filter.rx_filter = HTT_RX_MON_FILTER_TLV_FLAGS_MON_BUF_RING;\n\t\ttlv_filter.pkt_filter_flags0 =\n\t\t\t\t\tHTT_RX_MON_FP_MGMT_FILTER_FLAGS0 |\n\t\t\t\t\tHTT_RX_MON_MO_MGMT_FILTER_FLAGS0;\n\t\ttlv_filter.pkt_filter_flags1 =\n\t\t\t\t\tHTT_RX_MON_FP_MGMT_FILTER_FLAGS1 |\n\t\t\t\t\tHTT_RX_MON_MO_MGMT_FILTER_FLAGS1;\n\t\ttlv_filter.pkt_filter_flags2 =\n\t\t\t\t\tHTT_RX_MON_FP_CTRL_FILTER_FLASG2 |\n\t\t\t\t\tHTT_RX_MON_MO_CTRL_FILTER_FLASG2;\n\t\ttlv_filter.pkt_filter_flags3 =\n\t\t\t\t\tHTT_RX_MON_FP_CTRL_FILTER_FLASG3 |\n\t\t\t\t\tHTT_RX_MON_MO_CTRL_FILTER_FLASG3 |\n\t\t\t\t\tHTT_RX_MON_FP_DATA_FILTER_FLASG3 |\n\t\t\t\t\tHTT_RX_MON_MO_DATA_FILTER_FLASG3;\n\t}\n\n\tif (ab->hw_params.rxdma1_enable) {\n\t\tret = ath11k_dp_tx_htt_rx_filter_setup(ar->ab, ring_id, dp->mac_id,\n\t\t\t\t\t\t       HAL_RXDMA_MONITOR_BUF,\n\t\t\t\t\t\t       DP_RXDMA_REFILL_RING_SIZE,\n\t\t\t\t\t\t       &tlv_filter);\n\t} else if (!reset) {\n\t\t \n\t\tfor (i = 0; i < ab->hw_params.num_rxmda_per_pdev; i++) {\n\t\t\tring_id = dp->rx_mac_buf_ring[i].ring_id;\n\t\t\tret = ath11k_dp_tx_htt_rx_filter_setup(ar->ab, ring_id,\n\t\t\t\t\t\t\t       dp->mac_id + i,\n\t\t\t\t\t\t\t       HAL_RXDMA_BUF,\n\t\t\t\t\t\t\t       1024,\n\t\t\t\t\t\t\t       &tlv_filter);\n\t\t}\n\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < ab->hw_params.num_rxmda_per_pdev; i++) {\n\t\tring_id = dp->rx_mon_status_refill_ring[i].refill_buf_ring.ring_id;\n\t\tif (!reset) {\n\t\t\ttlv_filter.rx_filter =\n\t\t\t\t\tHTT_RX_MON_FILTER_TLV_FLAGS_MON_STATUS_RING;\n\t\t} else {\n\t\t\ttlv_filter = ath11k_mac_mon_status_filter_default;\n\n\t\t\tif (ath11k_debugfs_is_extd_rx_stats_enabled(ar))\n\t\t\t\ttlv_filter.rx_filter = ath11k_debugfs_rx_filter(ar);\n\t\t}\n\n\t\tret = ath11k_dp_tx_htt_rx_filter_setup(ab, ring_id,\n\t\t\t\t\t\t       dp->mac_id + i,\n\t\t\t\t\t\t       HAL_RXDMA_MONITOR_STATUS,\n\t\t\t\t\t\t       DP_RXDMA_REFILL_RING_SIZE,\n\t\t\t\t\t\t       &tlv_filter);\n\t}\n\n\tif (!ar->ab->hw_params.rxdma1_enable)\n\t\tmod_timer(&ar->ab->mon_reap_timer, jiffies +\n\t\t\t  msecs_to_jiffies(ATH11K_MON_TIMER_INTERVAL));\n\n\treturn ret;\n}\n\nint ath11k_dp_tx_htt_rx_full_mon_setup(struct ath11k_base *ab, int mac_id,\n\t\t\t\t       bool config)\n{\n\tstruct htt_rx_full_monitor_mode_cfg_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret, len = sizeof(*cmd);\n\n\tskb = ath11k_htc_alloc_skb(ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put(skb, len);\n\tcmd = (struct htt_rx_full_monitor_mode_cfg_cmd *)skb->data;\n\tmemset(cmd, 0, sizeof(*cmd));\n\tcmd->info0 = FIELD_PREP(HTT_RX_FULL_MON_MODE_CFG_CMD_INFO0_MSG_TYPE,\n\t\t\t\tHTT_H2T_MSG_TYPE_RX_FULL_MONITOR_MODE);\n\n\tcmd->info0 |= FIELD_PREP(HTT_RX_FULL_MON_MODE_CFG_CMD_INFO0_PDEV_ID, mac_id);\n\n\tcmd->cfg = HTT_RX_FULL_MON_MODE_CFG_CMD_CFG_ENABLE |\n\t\t   FIELD_PREP(HTT_RX_FULL_MON_MODE_CFG_CMD_CFG_RELEASE_RING,\n\t\t\t      HTT_RX_MON_RING_SW);\n\tif (config) {\n\t\tcmd->cfg |= HTT_RX_FULL_MON_MODE_CFG_CMD_CFG_ZERO_MPDUS_END |\n\t\t\t    HTT_RX_FULL_MON_MODE_CFG_CMD_CFG_NON_ZERO_MPDUS_END;\n\t}\n\n\tret = ath11k_htc_send(&ab->htc, ab->dp.eid, skb);\n\tif (ret)\n\t\tgoto err_free;\n\n\treturn 0;\n\nerr_free:\n\tdev_kfree_skb_any(skb);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}