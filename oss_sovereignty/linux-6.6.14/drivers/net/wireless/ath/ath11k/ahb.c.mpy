{
  "module_name": "ahb.c",
  "hash_id": "3ad02fdc0baaa5549e360204df4c4a5258acd95bb247bd6808e7c49819f016cf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath11k/ahb.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/of_device.h>\n#include <linux/of.h>\n#include <linux/dma-mapping.h>\n#include <linux/of_address.h>\n#include <linux/iommu.h>\n#include \"ahb.h\"\n#include \"debug.h\"\n#include \"hif.h\"\n#include \"qmi.h\"\n#include <linux/remoteproc.h>\n#include \"pcic.h\"\n#include <linux/soc/qcom/smem.h>\n#include <linux/soc/qcom/smem_state.h>\n\nstatic const struct of_device_id ath11k_ahb_of_match[] = {\n\t \n\t{ .compatible = \"qcom,ipq8074-wifi\",\n\t  .data = (void *)ATH11K_HW_IPQ8074,\n\t},\n\t{ .compatible = \"qcom,ipq6018-wifi\",\n\t  .data = (void *)ATH11K_HW_IPQ6018_HW10,\n\t},\n\t{ .compatible = \"qcom,wcn6750-wifi\",\n\t  .data = (void *)ATH11K_HW_WCN6750_HW10,\n\t},\n\t{ .compatible = \"qcom,ipq5018-wifi\",\n\t  .data = (void *)ATH11K_HW_IPQ5018_HW10,\n\t},\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(of, ath11k_ahb_of_match);\n\n#define ATH11K_IRQ_CE0_OFFSET 4\n\nstatic const char *irq_name[ATH11K_IRQ_NUM_MAX] = {\n\t\"misc-pulse1\",\n\t\"misc-latch\",\n\t\"sw-exception\",\n\t\"watchdog\",\n\t\"ce0\",\n\t\"ce1\",\n\t\"ce2\",\n\t\"ce3\",\n\t\"ce4\",\n\t\"ce5\",\n\t\"ce6\",\n\t\"ce7\",\n\t\"ce8\",\n\t\"ce9\",\n\t\"ce10\",\n\t\"ce11\",\n\t\"host2wbm-desc-feed\",\n\t\"host2reo-re-injection\",\n\t\"host2reo-command\",\n\t\"host2rxdma-monitor-ring3\",\n\t\"host2rxdma-monitor-ring2\",\n\t\"host2rxdma-monitor-ring1\",\n\t\"reo2ost-exception\",\n\t\"wbm2host-rx-release\",\n\t\"reo2host-status\",\n\t\"reo2host-destination-ring4\",\n\t\"reo2host-destination-ring3\",\n\t\"reo2host-destination-ring2\",\n\t\"reo2host-destination-ring1\",\n\t\"rxdma2host-monitor-destination-mac3\",\n\t\"rxdma2host-monitor-destination-mac2\",\n\t\"rxdma2host-monitor-destination-mac1\",\n\t\"ppdu-end-interrupts-mac3\",\n\t\"ppdu-end-interrupts-mac2\",\n\t\"ppdu-end-interrupts-mac1\",\n\t\"rxdma2host-monitor-status-ring-mac3\",\n\t\"rxdma2host-monitor-status-ring-mac2\",\n\t\"rxdma2host-monitor-status-ring-mac1\",\n\t\"host2rxdma-host-buf-ring-mac3\",\n\t\"host2rxdma-host-buf-ring-mac2\",\n\t\"host2rxdma-host-buf-ring-mac1\",\n\t\"rxdma2host-destination-ring-mac3\",\n\t\"rxdma2host-destination-ring-mac2\",\n\t\"rxdma2host-destination-ring-mac1\",\n\t\"host2tcl-input-ring4\",\n\t\"host2tcl-input-ring3\",\n\t\"host2tcl-input-ring2\",\n\t\"host2tcl-input-ring1\",\n\t\"wbm2host-tx-completions-ring3\",\n\t\"wbm2host-tx-completions-ring2\",\n\t\"wbm2host-tx-completions-ring1\",\n\t\"tcl2host-status-ring\",\n};\n\n \nenum ext_irq_num {\n\thost2wbm_desc_feed = 16,\n\thost2reo_re_injection,\n\thost2reo_command,\n\thost2rxdma_monitor_ring3,\n\thost2rxdma_monitor_ring2,\n\thost2rxdma_monitor_ring1,\n\treo2host_exception,\n\twbm2host_rx_release,\n\treo2host_status,\n\treo2host_destination_ring4,\n\treo2host_destination_ring3,\n\treo2host_destination_ring2,\n\treo2host_destination_ring1,\n\trxdma2host_monitor_destination_mac3,\n\trxdma2host_monitor_destination_mac2,\n\trxdma2host_monitor_destination_mac1,\n\tppdu_end_interrupts_mac3,\n\tppdu_end_interrupts_mac2,\n\tppdu_end_interrupts_mac1,\n\trxdma2host_monitor_status_ring_mac3,\n\trxdma2host_monitor_status_ring_mac2,\n\trxdma2host_monitor_status_ring_mac1,\n\thost2rxdma_host_buf_ring_mac3,\n\thost2rxdma_host_buf_ring_mac2,\n\thost2rxdma_host_buf_ring_mac1,\n\trxdma2host_destination_ring_mac3,\n\trxdma2host_destination_ring_mac2,\n\trxdma2host_destination_ring_mac1,\n\thost2tcl_input_ring4,\n\thost2tcl_input_ring3,\n\thost2tcl_input_ring2,\n\thost2tcl_input_ring1,\n\twbm2host_tx_completions_ring3,\n\twbm2host_tx_completions_ring2,\n\twbm2host_tx_completions_ring1,\n\ttcl2host_status_ring,\n};\n\nstatic int\nath11k_ahb_get_msi_irq_wcn6750(struct ath11k_base *ab, unsigned int vector)\n{\n\treturn ab->pci.msi.irqs[vector];\n}\n\nstatic inline u32\nath11k_ahb_get_window_start_wcn6750(struct ath11k_base *ab, u32 offset)\n{\n\tu32 window_start = 0;\n\n\t \n\tif ((offset ^ HAL_SEQ_WCSS_UMAC_OFFSET) < ATH11K_PCI_WINDOW_RANGE_MASK)\n\t\twindow_start = ATH11K_PCI_WINDOW_START;\n\t \n\telse if ((offset ^ HAL_SEQ_WCSS_UMAC_CE0_SRC_REG(ab)) <\n\t\t ATH11K_PCI_WINDOW_RANGE_MASK)\n\t\twindow_start = 2 * ATH11K_PCI_WINDOW_START;\n\n\treturn window_start;\n}\n\nstatic void\nath11k_ahb_window_write32_wcn6750(struct ath11k_base *ab, u32 offset, u32 value)\n{\n\tu32 window_start;\n\n\t \n\twindow_start = ath11k_ahb_get_window_start_wcn6750(ab, offset);\n\n\tiowrite32(value, ab->mem + window_start +\n\t\t  (offset & ATH11K_PCI_WINDOW_RANGE_MASK));\n}\n\nstatic u32 ath11k_ahb_window_read32_wcn6750(struct ath11k_base *ab, u32 offset)\n{\n\tu32 window_start;\n\tu32 val;\n\n\t \n\twindow_start = ath11k_ahb_get_window_start_wcn6750(ab, offset);\n\n\tval = ioread32(ab->mem + window_start +\n\t\t       (offset & ATH11K_PCI_WINDOW_RANGE_MASK));\n\treturn val;\n}\n\nstatic const struct ath11k_pci_ops ath11k_ahb_pci_ops_wcn6750 = {\n\t.wakeup = NULL,\n\t.release = NULL,\n\t.get_msi_irq = ath11k_ahb_get_msi_irq_wcn6750,\n\t.window_write32 = ath11k_ahb_window_write32_wcn6750,\n\t.window_read32 = ath11k_ahb_window_read32_wcn6750,\n};\n\nstatic inline u32 ath11k_ahb_read32(struct ath11k_base *ab, u32 offset)\n{\n\treturn ioread32(ab->mem + offset);\n}\n\nstatic inline void ath11k_ahb_write32(struct ath11k_base *ab, u32 offset, u32 value)\n{\n\tiowrite32(value, ab->mem + offset);\n}\n\nstatic void ath11k_ahb_kill_tasklets(struct ath11k_base *ab)\n{\n\tint i;\n\n\tfor (i = 0; i < ab->hw_params.ce_count; i++) {\n\t\tstruct ath11k_ce_pipe *ce_pipe = &ab->ce.ce_pipe[i];\n\n\t\tif (ath11k_ce_get_attr_flags(ab, i) & CE_ATTR_DIS_INTR)\n\t\t\tcontinue;\n\n\t\ttasklet_kill(&ce_pipe->intr_tq);\n\t}\n}\n\nstatic void ath11k_ahb_ext_grp_disable(struct ath11k_ext_irq_grp *irq_grp)\n{\n\tint i;\n\n\tfor (i = 0; i < irq_grp->num_irq; i++)\n\t\tdisable_irq_nosync(irq_grp->ab->irq_num[irq_grp->irqs[i]]);\n}\n\nstatic void __ath11k_ahb_ext_irq_disable(struct ath11k_base *ab)\n{\n\tint i;\n\n\tfor (i = 0; i < ATH11K_EXT_IRQ_GRP_NUM_MAX; i++) {\n\t\tstruct ath11k_ext_irq_grp *irq_grp = &ab->ext_irq_grp[i];\n\n\t\tath11k_ahb_ext_grp_disable(irq_grp);\n\n\t\tif (irq_grp->napi_enabled) {\n\t\t\tnapi_synchronize(&irq_grp->napi);\n\t\t\tnapi_disable(&irq_grp->napi);\n\t\t\tirq_grp->napi_enabled = false;\n\t\t}\n\t}\n}\n\nstatic void ath11k_ahb_ext_grp_enable(struct ath11k_ext_irq_grp *irq_grp)\n{\n\tint i;\n\n\tfor (i = 0; i < irq_grp->num_irq; i++)\n\t\tenable_irq(irq_grp->ab->irq_num[irq_grp->irqs[i]]);\n}\n\nstatic void ath11k_ahb_setbit32(struct ath11k_base *ab, u8 bit, u32 offset)\n{\n\tu32 val;\n\n\tval = ath11k_ahb_read32(ab, offset);\n\tath11k_ahb_write32(ab, offset, val | BIT(bit));\n}\n\nstatic void ath11k_ahb_clearbit32(struct ath11k_base *ab, u8 bit, u32 offset)\n{\n\tu32 val;\n\n\tval = ath11k_ahb_read32(ab, offset);\n\tath11k_ahb_write32(ab, offset, val & ~BIT(bit));\n}\n\nstatic void ath11k_ahb_ce_irq_enable(struct ath11k_base *ab, u16 ce_id)\n{\n\tconst struct ce_attr *ce_attr;\n\tconst struct ce_ie_addr *ce_ie_addr = ab->hw_params.ce_ie_addr;\n\tu32 ie1_reg_addr, ie2_reg_addr, ie3_reg_addr;\n\n\tie1_reg_addr = ce_ie_addr->ie1_reg_addr + ATH11K_CE_OFFSET(ab);\n\tie2_reg_addr = ce_ie_addr->ie2_reg_addr + ATH11K_CE_OFFSET(ab);\n\tie3_reg_addr = ce_ie_addr->ie3_reg_addr + ATH11K_CE_OFFSET(ab);\n\n\tce_attr = &ab->hw_params.host_ce_config[ce_id];\n\tif (ce_attr->src_nentries)\n\t\tath11k_ahb_setbit32(ab, ce_id, ie1_reg_addr);\n\n\tif (ce_attr->dest_nentries) {\n\t\tath11k_ahb_setbit32(ab, ce_id, ie2_reg_addr);\n\t\tath11k_ahb_setbit32(ab, ce_id + CE_HOST_IE_3_SHIFT,\n\t\t\t\t    ie3_reg_addr);\n\t}\n}\n\nstatic void ath11k_ahb_ce_irq_disable(struct ath11k_base *ab, u16 ce_id)\n{\n\tconst struct ce_attr *ce_attr;\n\tconst struct ce_ie_addr *ce_ie_addr = ab->hw_params.ce_ie_addr;\n\tu32 ie1_reg_addr, ie2_reg_addr, ie3_reg_addr;\n\n\tie1_reg_addr = ce_ie_addr->ie1_reg_addr + ATH11K_CE_OFFSET(ab);\n\tie2_reg_addr = ce_ie_addr->ie2_reg_addr + ATH11K_CE_OFFSET(ab);\n\tie3_reg_addr = ce_ie_addr->ie3_reg_addr + ATH11K_CE_OFFSET(ab);\n\n\tce_attr = &ab->hw_params.host_ce_config[ce_id];\n\tif (ce_attr->src_nentries)\n\t\tath11k_ahb_clearbit32(ab, ce_id, ie1_reg_addr);\n\n\tif (ce_attr->dest_nentries) {\n\t\tath11k_ahb_clearbit32(ab, ce_id, ie2_reg_addr);\n\t\tath11k_ahb_clearbit32(ab, ce_id + CE_HOST_IE_3_SHIFT,\n\t\t\t\t      ie3_reg_addr);\n\t}\n}\n\nstatic void ath11k_ahb_sync_ce_irqs(struct ath11k_base *ab)\n{\n\tint i;\n\tint irq_idx;\n\n\tfor (i = 0; i < ab->hw_params.ce_count; i++) {\n\t\tif (ath11k_ce_get_attr_flags(ab, i) & CE_ATTR_DIS_INTR)\n\t\t\tcontinue;\n\n\t\tirq_idx = ATH11K_IRQ_CE0_OFFSET + i;\n\t\tsynchronize_irq(ab->irq_num[irq_idx]);\n\t}\n}\n\nstatic void ath11k_ahb_sync_ext_irqs(struct ath11k_base *ab)\n{\n\tint i, j;\n\tint irq_idx;\n\n\tfor (i = 0; i < ATH11K_EXT_IRQ_GRP_NUM_MAX; i++) {\n\t\tstruct ath11k_ext_irq_grp *irq_grp = &ab->ext_irq_grp[i];\n\n\t\tfor (j = 0; j < irq_grp->num_irq; j++) {\n\t\t\tirq_idx = irq_grp->irqs[j];\n\t\t\tsynchronize_irq(ab->irq_num[irq_idx]);\n\t\t}\n\t}\n}\n\nstatic void ath11k_ahb_ce_irqs_enable(struct ath11k_base *ab)\n{\n\tint i;\n\n\tfor (i = 0; i < ab->hw_params.ce_count; i++) {\n\t\tif (ath11k_ce_get_attr_flags(ab, i) & CE_ATTR_DIS_INTR)\n\t\t\tcontinue;\n\t\tath11k_ahb_ce_irq_enable(ab, i);\n\t}\n}\n\nstatic void ath11k_ahb_ce_irqs_disable(struct ath11k_base *ab)\n{\n\tint i;\n\n\tfor (i = 0; i < ab->hw_params.ce_count; i++) {\n\t\tif (ath11k_ce_get_attr_flags(ab, i) & CE_ATTR_DIS_INTR)\n\t\t\tcontinue;\n\t\tath11k_ahb_ce_irq_disable(ab, i);\n\t}\n}\n\nstatic int ath11k_ahb_start(struct ath11k_base *ab)\n{\n\tath11k_ahb_ce_irqs_enable(ab);\n\tath11k_ce_rx_post_buf(ab);\n\n\treturn 0;\n}\n\nstatic void ath11k_ahb_ext_irq_enable(struct ath11k_base *ab)\n{\n\tint i;\n\n\tfor (i = 0; i < ATH11K_EXT_IRQ_GRP_NUM_MAX; i++) {\n\t\tstruct ath11k_ext_irq_grp *irq_grp = &ab->ext_irq_grp[i];\n\n\t\tif (!irq_grp->napi_enabled) {\n\t\t\tnapi_enable(&irq_grp->napi);\n\t\t\tirq_grp->napi_enabled = true;\n\t\t}\n\t\tath11k_ahb_ext_grp_enable(irq_grp);\n\t}\n}\n\nstatic void ath11k_ahb_ext_irq_disable(struct ath11k_base *ab)\n{\n\t__ath11k_ahb_ext_irq_disable(ab);\n\tath11k_ahb_sync_ext_irqs(ab);\n}\n\nstatic void ath11k_ahb_stop(struct ath11k_base *ab)\n{\n\tif (!test_bit(ATH11K_FLAG_CRASH_FLUSH, &ab->dev_flags))\n\t\tath11k_ahb_ce_irqs_disable(ab);\n\tath11k_ahb_sync_ce_irqs(ab);\n\tath11k_ahb_kill_tasklets(ab);\n\tdel_timer_sync(&ab->rx_replenish_retry);\n\tath11k_ce_cleanup_pipes(ab);\n}\n\nstatic int ath11k_ahb_power_up(struct ath11k_base *ab)\n{\n\tstruct ath11k_ahb *ab_ahb = ath11k_ahb_priv(ab);\n\tint ret;\n\n\tret = rproc_boot(ab_ahb->tgt_rproc);\n\tif (ret)\n\t\tath11k_err(ab, \"failed to boot the remote processor Q6\\n\");\n\n\treturn ret;\n}\n\nstatic void ath11k_ahb_power_down(struct ath11k_base *ab)\n{\n\tstruct ath11k_ahb *ab_ahb = ath11k_ahb_priv(ab);\n\n\trproc_shutdown(ab_ahb->tgt_rproc);\n}\n\nstatic void ath11k_ahb_init_qmi_ce_config(struct ath11k_base *ab)\n{\n\tstruct ath11k_qmi_ce_cfg *cfg = &ab->qmi.ce_cfg;\n\n\tcfg->tgt_ce_len = ab->hw_params.target_ce_count;\n\tcfg->tgt_ce = ab->hw_params.target_ce_config;\n\tcfg->svc_to_ce_map_len = ab->hw_params.svc_to_ce_map_len;\n\tcfg->svc_to_ce_map = ab->hw_params.svc_to_ce_map;\n\tab->qmi.service_ins_id = ab->hw_params.qmi_service_ins_id;\n}\n\nstatic void ath11k_ahb_free_ext_irq(struct ath11k_base *ab)\n{\n\tint i, j;\n\n\tfor (i = 0; i < ATH11K_EXT_IRQ_GRP_NUM_MAX; i++) {\n\t\tstruct ath11k_ext_irq_grp *irq_grp = &ab->ext_irq_grp[i];\n\n\t\tfor (j = 0; j < irq_grp->num_irq; j++)\n\t\t\tfree_irq(ab->irq_num[irq_grp->irqs[j]], irq_grp);\n\n\t\tnetif_napi_del(&irq_grp->napi);\n\t}\n}\n\nstatic void ath11k_ahb_free_irq(struct ath11k_base *ab)\n{\n\tint irq_idx;\n\tint i;\n\n\tif (ab->hw_params.hybrid_bus_type)\n\t\treturn ath11k_pcic_free_irq(ab);\n\n\tfor (i = 0; i < ab->hw_params.ce_count; i++) {\n\t\tif (ath11k_ce_get_attr_flags(ab, i) & CE_ATTR_DIS_INTR)\n\t\t\tcontinue;\n\t\tirq_idx = ATH11K_IRQ_CE0_OFFSET + i;\n\t\tfree_irq(ab->irq_num[irq_idx], &ab->ce.ce_pipe[i]);\n\t}\n\n\tath11k_ahb_free_ext_irq(ab);\n}\n\nstatic void ath11k_ahb_ce_tasklet(struct tasklet_struct *t)\n{\n\tstruct ath11k_ce_pipe *ce_pipe = from_tasklet(ce_pipe, t, intr_tq);\n\n\tath11k_ce_per_engine_service(ce_pipe->ab, ce_pipe->pipe_num);\n\n\tath11k_ahb_ce_irq_enable(ce_pipe->ab, ce_pipe->pipe_num);\n}\n\nstatic irqreturn_t ath11k_ahb_ce_interrupt_handler(int irq, void *arg)\n{\n\tstruct ath11k_ce_pipe *ce_pipe = arg;\n\n\t \n\tce_pipe->timestamp = jiffies;\n\n\tath11k_ahb_ce_irq_disable(ce_pipe->ab, ce_pipe->pipe_num);\n\n\ttasklet_schedule(&ce_pipe->intr_tq);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ath11k_ahb_ext_grp_napi_poll(struct napi_struct *napi, int budget)\n{\n\tstruct ath11k_ext_irq_grp *irq_grp = container_of(napi,\n\t\t\t\t\t\tstruct ath11k_ext_irq_grp,\n\t\t\t\t\t\tnapi);\n\tstruct ath11k_base *ab = irq_grp->ab;\n\tint work_done;\n\n\twork_done = ath11k_dp_service_srng(ab, irq_grp, budget);\n\tif (work_done < budget) {\n\t\tnapi_complete_done(napi, work_done);\n\t\tath11k_ahb_ext_grp_enable(irq_grp);\n\t}\n\n\tif (work_done > budget)\n\t\twork_done = budget;\n\n\treturn work_done;\n}\n\nstatic irqreturn_t ath11k_ahb_ext_interrupt_handler(int irq, void *arg)\n{\n\tstruct ath11k_ext_irq_grp *irq_grp = arg;\n\n\t \n\tirq_grp->timestamp = jiffies;\n\n\tath11k_ahb_ext_grp_disable(irq_grp);\n\n\tnapi_schedule(&irq_grp->napi);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ath11k_ahb_config_ext_irq(struct ath11k_base *ab)\n{\n\tstruct ath11k_hw_params *hw = &ab->hw_params;\n\tint i, j;\n\tint irq;\n\tint ret;\n\n\tfor (i = 0; i < ATH11K_EXT_IRQ_GRP_NUM_MAX; i++) {\n\t\tstruct ath11k_ext_irq_grp *irq_grp = &ab->ext_irq_grp[i];\n\t\tu32 num_irq = 0;\n\n\t\tirq_grp->ab = ab;\n\t\tirq_grp->grp_id = i;\n\t\tinit_dummy_netdev(&irq_grp->napi_ndev);\n\t\tnetif_napi_add(&irq_grp->napi_ndev, &irq_grp->napi,\n\t\t\t       ath11k_ahb_ext_grp_napi_poll);\n\n\t\tfor (j = 0; j < ATH11K_EXT_IRQ_NUM_MAX; j++) {\n\t\t\tif (ab->hw_params.ring_mask->tx[i] & BIT(j)) {\n\t\t\t\tirq_grp->irqs[num_irq++] =\n\t\t\t\t\twbm2host_tx_completions_ring1 - j;\n\t\t\t}\n\n\t\t\tif (ab->hw_params.ring_mask->rx[i] & BIT(j)) {\n\t\t\t\tirq_grp->irqs[num_irq++] =\n\t\t\t\t\treo2host_destination_ring1 - j;\n\t\t\t}\n\n\t\t\tif (ab->hw_params.ring_mask->rx_err[i] & BIT(j))\n\t\t\t\tirq_grp->irqs[num_irq++] = reo2host_exception;\n\n\t\t\tif (ab->hw_params.ring_mask->rx_wbm_rel[i] & BIT(j))\n\t\t\t\tirq_grp->irqs[num_irq++] = wbm2host_rx_release;\n\n\t\t\tif (ab->hw_params.ring_mask->reo_status[i] & BIT(j))\n\t\t\t\tirq_grp->irqs[num_irq++] = reo2host_status;\n\n\t\t\tif (j < ab->hw_params.max_radios) {\n\t\t\t\tif (ab->hw_params.ring_mask->rxdma2host[i] & BIT(j)) {\n\t\t\t\t\tirq_grp->irqs[num_irq++] =\n\t\t\t\t\t\trxdma2host_destination_ring_mac1 -\n\t\t\t\t\t\tath11k_hw_get_mac_from_pdev_id(hw, j);\n\t\t\t\t}\n\n\t\t\t\tif (ab->hw_params.ring_mask->host2rxdma[i] & BIT(j)) {\n\t\t\t\t\tirq_grp->irqs[num_irq++] =\n\t\t\t\t\t\thost2rxdma_host_buf_ring_mac1 -\n\t\t\t\t\t\tath11k_hw_get_mac_from_pdev_id(hw, j);\n\t\t\t\t}\n\n\t\t\t\tif (ab->hw_params.ring_mask->rx_mon_status[i] & BIT(j)) {\n\t\t\t\t\tirq_grp->irqs[num_irq++] =\n\t\t\t\t\t\tppdu_end_interrupts_mac1 -\n\t\t\t\t\t\tath11k_hw_get_mac_from_pdev_id(hw, j);\n\t\t\t\t\tirq_grp->irqs[num_irq++] =\n\t\t\t\t\t\trxdma2host_monitor_status_ring_mac1 -\n\t\t\t\t\t\tath11k_hw_get_mac_from_pdev_id(hw, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tirq_grp->num_irq = num_irq;\n\n\t\tfor (j = 0; j < irq_grp->num_irq; j++) {\n\t\t\tint irq_idx = irq_grp->irqs[j];\n\n\t\t\tirq = platform_get_irq_byname(ab->pdev,\n\t\t\t\t\t\t      irq_name[irq_idx]);\n\t\t\tab->irq_num[irq_idx] = irq;\n\t\t\tirq_set_status_flags(irq, IRQ_NOAUTOEN | IRQ_DISABLE_UNLAZY);\n\t\t\tret = request_irq(irq, ath11k_ahb_ext_interrupt_handler,\n\t\t\t\t\t  IRQF_TRIGGER_RISING,\n\t\t\t\t\t  irq_name[irq_idx], irq_grp);\n\t\t\tif (ret) {\n\t\t\t\tath11k_err(ab, \"failed request_irq for %d\\n\",\n\t\t\t\t\t   irq);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ath11k_ahb_config_irq(struct ath11k_base *ab)\n{\n\tint irq, irq_idx, i;\n\tint ret;\n\n\tif (ab->hw_params.hybrid_bus_type)\n\t\treturn ath11k_pcic_config_irq(ab);\n\n\t \n\tfor (i = 0; i < ab->hw_params.ce_count; i++) {\n\t\tstruct ath11k_ce_pipe *ce_pipe = &ab->ce.ce_pipe[i];\n\n\t\tif (ath11k_ce_get_attr_flags(ab, i) & CE_ATTR_DIS_INTR)\n\t\t\tcontinue;\n\n\t\tirq_idx = ATH11K_IRQ_CE0_OFFSET + i;\n\n\t\ttasklet_setup(&ce_pipe->intr_tq, ath11k_ahb_ce_tasklet);\n\t\tirq = platform_get_irq_byname(ab->pdev, irq_name[irq_idx]);\n\t\tret = request_irq(irq, ath11k_ahb_ce_interrupt_handler,\n\t\t\t\t  IRQF_TRIGGER_RISING, irq_name[irq_idx],\n\t\t\t\t  ce_pipe);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tab->irq_num[irq_idx] = irq;\n\t}\n\n\t \n\tret = ath11k_ahb_config_ext_irq(ab);\n\n\treturn ret;\n}\n\nstatic int ath11k_ahb_map_service_to_pipe(struct ath11k_base *ab, u16 service_id,\n\t\t\t\t\t  u8 *ul_pipe, u8 *dl_pipe)\n{\n\tconst struct service_to_pipe *entry;\n\tbool ul_set = false, dl_set = false;\n\tint i;\n\n\tfor (i = 0; i < ab->hw_params.svc_to_ce_map_len; i++) {\n\t\tentry = &ab->hw_params.svc_to_ce_map[i];\n\n\t\tif (__le32_to_cpu(entry->service_id) != service_id)\n\t\t\tcontinue;\n\n\t\tswitch (__le32_to_cpu(entry->pipedir)) {\n\t\tcase PIPEDIR_NONE:\n\t\t\tbreak;\n\t\tcase PIPEDIR_IN:\n\t\t\tWARN_ON(dl_set);\n\t\t\t*dl_pipe = __le32_to_cpu(entry->pipenum);\n\t\t\tdl_set = true;\n\t\t\tbreak;\n\t\tcase PIPEDIR_OUT:\n\t\t\tWARN_ON(ul_set);\n\t\t\t*ul_pipe = __le32_to_cpu(entry->pipenum);\n\t\t\tul_set = true;\n\t\t\tbreak;\n\t\tcase PIPEDIR_INOUT:\n\t\t\tWARN_ON(dl_set);\n\t\t\tWARN_ON(ul_set);\n\t\t\t*dl_pipe = __le32_to_cpu(entry->pipenum);\n\t\t\t*ul_pipe = __le32_to_cpu(entry->pipenum);\n\t\t\tdl_set = true;\n\t\t\tul_set = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (WARN_ON(!ul_set || !dl_set))\n\t\treturn -ENOENT;\n\n\treturn 0;\n}\n\nstatic int ath11k_ahb_hif_suspend(struct ath11k_base *ab)\n{\n\tstruct ath11k_ahb *ab_ahb = ath11k_ahb_priv(ab);\n\tu32 wake_irq;\n\tu32 value = 0;\n\tint ret;\n\n\tif (!device_may_wakeup(ab->dev))\n\t\treturn -EPERM;\n\n\twake_irq = ab->irq_num[ATH11K_PCI_IRQ_CE0_OFFSET + ATH11K_PCI_CE_WAKE_IRQ];\n\n\tret = enable_irq_wake(wake_irq);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to enable wakeup irq :%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tvalue = u32_encode_bits(ab_ahb->smp2p_info.seq_no++,\n\t\t\t\tATH11K_AHB_SMP2P_SMEM_SEQ_NO);\n\tvalue |= u32_encode_bits(ATH11K_AHB_POWER_SAVE_ENTER,\n\t\t\t\t ATH11K_AHB_SMP2P_SMEM_MSG);\n\n\tret = qcom_smem_state_update_bits(ab_ahb->smp2p_info.smem_state,\n\t\t\t\t\t  ATH11K_AHB_SMP2P_SMEM_VALUE_MASK, value);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to send smp2p power save enter cmd :%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_AHB, \"device suspended\\n\");\n\n\treturn ret;\n}\n\nstatic int ath11k_ahb_hif_resume(struct ath11k_base *ab)\n{\n\tstruct ath11k_ahb *ab_ahb = ath11k_ahb_priv(ab);\n\tu32 wake_irq;\n\tu32 value = 0;\n\tint ret;\n\n\tif (!device_may_wakeup(ab->dev))\n\t\treturn -EPERM;\n\n\twake_irq = ab->irq_num[ATH11K_PCI_IRQ_CE0_OFFSET + ATH11K_PCI_CE_WAKE_IRQ];\n\n\tret = disable_irq_wake(wake_irq);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to disable wakeup irq: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treinit_completion(&ab->wow.wakeup_completed);\n\n\tvalue = u32_encode_bits(ab_ahb->smp2p_info.seq_no++,\n\t\t\t\tATH11K_AHB_SMP2P_SMEM_SEQ_NO);\n\tvalue |= u32_encode_bits(ATH11K_AHB_POWER_SAVE_EXIT,\n\t\t\t\t ATH11K_AHB_SMP2P_SMEM_MSG);\n\n\tret = qcom_smem_state_update_bits(ab_ahb->smp2p_info.smem_state,\n\t\t\t\t\t  ATH11K_AHB_SMP2P_SMEM_VALUE_MASK, value);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to send smp2p power save enter cmd :%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = wait_for_completion_timeout(&ab->wow.wakeup_completed, 3 * HZ);\n\tif (ret == 0) {\n\t\tath11k_warn(ab, \"timed out while waiting for wow wakeup completion\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_AHB, \"device resumed\\n\");\n\n\treturn 0;\n}\n\nstatic const struct ath11k_hif_ops ath11k_ahb_hif_ops_ipq8074 = {\n\t.start = ath11k_ahb_start,\n\t.stop = ath11k_ahb_stop,\n\t.read32 = ath11k_ahb_read32,\n\t.write32 = ath11k_ahb_write32,\n\t.read = NULL,\n\t.irq_enable = ath11k_ahb_ext_irq_enable,\n\t.irq_disable = ath11k_ahb_ext_irq_disable,\n\t.map_service_to_pipe = ath11k_ahb_map_service_to_pipe,\n\t.power_down = ath11k_ahb_power_down,\n\t.power_up = ath11k_ahb_power_up,\n};\n\nstatic const struct ath11k_hif_ops ath11k_ahb_hif_ops_wcn6750 = {\n\t.start = ath11k_pcic_start,\n\t.stop = ath11k_pcic_stop,\n\t.read32 = ath11k_pcic_read32,\n\t.write32 = ath11k_pcic_write32,\n\t.read = NULL,\n\t.irq_enable = ath11k_pcic_ext_irq_enable,\n\t.irq_disable = ath11k_pcic_ext_irq_disable,\n\t.get_msi_address =  ath11k_pcic_get_msi_address,\n\t.get_user_msi_vector = ath11k_pcic_get_user_msi_assignment,\n\t.map_service_to_pipe = ath11k_pcic_map_service_to_pipe,\n\t.power_down = ath11k_ahb_power_down,\n\t.power_up = ath11k_ahb_power_up,\n\t.suspend = ath11k_ahb_hif_suspend,\n\t.resume = ath11k_ahb_hif_resume,\n\t.ce_irq_enable = ath11k_pci_enable_ce_irqs_except_wake_irq,\n\t.ce_irq_disable = ath11k_pci_disable_ce_irqs_except_wake_irq,\n};\n\nstatic int ath11k_core_get_rproc(struct ath11k_base *ab)\n{\n\tstruct ath11k_ahb *ab_ahb = ath11k_ahb_priv(ab);\n\tstruct device *dev = ab->dev;\n\tstruct rproc *prproc;\n\tphandle rproc_phandle;\n\n\tif (of_property_read_u32(dev->of_node, \"qcom,rproc\", &rproc_phandle)) {\n\t\tath11k_err(ab, \"failed to get q6_rproc handle\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tprproc = rproc_get_by_phandle(rproc_phandle);\n\tif (!prproc) {\n\t\tath11k_dbg(ab, ATH11K_DBG_AHB, \"failed to get rproc, deferring\\n\");\n\t\treturn -EPROBE_DEFER;\n\t}\n\tab_ahb->tgt_rproc = prproc;\n\n\treturn 0;\n}\n\nstatic int ath11k_ahb_setup_msi_resources(struct ath11k_base *ab)\n{\n\tstruct platform_device *pdev = ab->pdev;\n\tphys_addr_t msi_addr_pa;\n\tdma_addr_t msi_addr_iova;\n\tstruct resource *res;\n\tint int_prop;\n\tint ret;\n\tint i;\n\n\tret = ath11k_pcic_init_msi_config(ab);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to init msi config: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tath11k_err(ab, \"failed to fetch msi_addr\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tmsi_addr_pa = res->start;\n\tmsi_addr_iova = dma_map_resource(ab->dev, msi_addr_pa, PAGE_SIZE,\n\t\t\t\t\t DMA_FROM_DEVICE, 0);\n\tif (dma_mapping_error(ab->dev, msi_addr_iova))\n\t\treturn -ENOMEM;\n\n\tab->pci.msi.addr_lo = lower_32_bits(msi_addr_iova);\n\tab->pci.msi.addr_hi = upper_32_bits(msi_addr_iova);\n\n\tret = of_property_read_u32_index(ab->dev->of_node, \"interrupts\", 1, &int_prop);\n\tif (ret)\n\t\treturn ret;\n\n\tab->pci.msi.ep_base_data = int_prop + 32;\n\n\tfor (i = 0; i < ab->pci.msi.config->total_vectors; i++) {\n\t\tret = platform_get_irq(pdev, i);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tab->pci.msi.irqs[i] = ret;\n\t}\n\n\tset_bit(ATH11K_FLAG_MULTI_MSI_VECTORS, &ab->dev_flags);\n\n\treturn 0;\n}\n\nstatic int ath11k_ahb_setup_smp2p_handle(struct ath11k_base *ab)\n{\n\tstruct ath11k_ahb *ab_ahb = ath11k_ahb_priv(ab);\n\n\tif (!ab->hw_params.smp2p_wow_exit)\n\t\treturn 0;\n\n\tab_ahb->smp2p_info.smem_state = qcom_smem_state_get(ab->dev, \"wlan-smp2p-out\",\n\t\t\t\t\t\t\t    &ab_ahb->smp2p_info.smem_bit);\n\tif (IS_ERR(ab_ahb->smp2p_info.smem_state)) {\n\t\tath11k_err(ab, \"failed to fetch smem state: %ld\\n\",\n\t\t\t   PTR_ERR(ab_ahb->smp2p_info.smem_state));\n\t\treturn PTR_ERR(ab_ahb->smp2p_info.smem_state);\n\t}\n\n\treturn 0;\n}\n\nstatic void ath11k_ahb_release_smp2p_handle(struct ath11k_base *ab)\n{\n\tstruct ath11k_ahb *ab_ahb = ath11k_ahb_priv(ab);\n\n\tif (!ab->hw_params.smp2p_wow_exit)\n\t\treturn;\n\n\tqcom_smem_state_put(ab_ahb->smp2p_info.smem_state);\n}\n\nstatic int ath11k_ahb_setup_resources(struct ath11k_base *ab)\n{\n\tstruct platform_device *pdev = ab->pdev;\n\tstruct resource *mem_res;\n\tvoid __iomem *mem;\n\n\tif (ab->hw_params.hybrid_bus_type)\n\t\treturn ath11k_ahb_setup_msi_resources(ab);\n\n\tmem = devm_platform_get_and_ioremap_resource(pdev, 0, &mem_res);\n\tif (IS_ERR(mem)) {\n\t\tdev_err(&pdev->dev, \"ioremap error\\n\");\n\t\treturn PTR_ERR(mem);\n\t}\n\n\tab->mem = mem;\n\tab->mem_len = resource_size(mem_res);\n\n\treturn 0;\n}\n\nstatic int ath11k_ahb_setup_msa_resources(struct ath11k_base *ab)\n{\n\tstruct ath11k_ahb *ab_ahb = ath11k_ahb_priv(ab);\n\tstruct device *dev = ab->dev;\n\tstruct device_node *node;\n\tstruct resource r;\n\tint ret;\n\n\tnode = of_parse_phandle(dev->of_node, \"memory-region\", 0);\n\tif (!node)\n\t\treturn -ENOENT;\n\n\tret = of_address_to_resource(node, 0, &r);\n\tof_node_put(node);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to resolve msa fixed region\\n\");\n\t\treturn ret;\n\t}\n\n\tab_ahb->fw.msa_paddr = r.start;\n\tab_ahb->fw.msa_size = resource_size(&r);\n\n\tnode = of_parse_phandle(dev->of_node, \"memory-region\", 1);\n\tif (!node)\n\t\treturn -ENOENT;\n\n\tret = of_address_to_resource(node, 0, &r);\n\tof_node_put(node);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to resolve ce fixed region\\n\");\n\t\treturn ret;\n\t}\n\n\tab_ahb->fw.ce_paddr = r.start;\n\tab_ahb->fw.ce_size = resource_size(&r);\n\n\treturn 0;\n}\n\nstatic int ath11k_ahb_fw_resources_init(struct ath11k_base *ab)\n{\n\tstruct ath11k_ahb *ab_ahb = ath11k_ahb_priv(ab);\n\tstruct device *host_dev = ab->dev;\n\tstruct platform_device_info info = {0};\n\tstruct iommu_domain *iommu_dom;\n\tstruct platform_device *pdev;\n\tstruct device_node *node;\n\tint ret;\n\n\t \n\tif (!ab->hw_params.fixed_fw_mem)\n\t\treturn 0;\n\n\tret = ath11k_ahb_setup_msa_resources(ab);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to setup msa resources\\n\");\n\t\treturn ret;\n\t}\n\n\tnode = of_get_child_by_name(host_dev->of_node, \"wifi-firmware\");\n\tif (!node) {\n\t\tab_ahb->fw.use_tz = true;\n\t\treturn 0;\n\t}\n\n\tinfo.fwnode = &node->fwnode;\n\tinfo.parent = host_dev;\n\tinfo.name = node->name;\n\tinfo.dma_mask = DMA_BIT_MASK(32);\n\n\tpdev = platform_device_register_full(&info);\n\tif (IS_ERR(pdev)) {\n\t\tof_node_put(node);\n\t\treturn PTR_ERR(pdev);\n\t}\n\n\tret = of_dma_configure(&pdev->dev, node, true);\n\tif (ret) {\n\t\tath11k_err(ab, \"dma configure fail: %d\\n\", ret);\n\t\tgoto err_unregister;\n\t}\n\n\tab_ahb->fw.dev = &pdev->dev;\n\n\tiommu_dom = iommu_domain_alloc(&platform_bus_type);\n\tif (!iommu_dom) {\n\t\tath11k_err(ab, \"failed to allocate iommu domain\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_unregister;\n\t}\n\n\tret = iommu_attach_device(iommu_dom, ab_ahb->fw.dev);\n\tif (ret) {\n\t\tath11k_err(ab, \"could not attach device: %d\\n\", ret);\n\t\tgoto err_iommu_free;\n\t}\n\n\tret = iommu_map(iommu_dom, ab_ahb->fw.msa_paddr,\n\t\t\tab_ahb->fw.msa_paddr, ab_ahb->fw.msa_size,\n\t\t\tIOMMU_READ | IOMMU_WRITE, GFP_KERNEL);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to map firmware region: %d\\n\", ret);\n\t\tgoto err_iommu_detach;\n\t}\n\n\tret = iommu_map(iommu_dom, ab_ahb->fw.ce_paddr,\n\t\t\tab_ahb->fw.ce_paddr, ab_ahb->fw.ce_size,\n\t\t\tIOMMU_READ | IOMMU_WRITE, GFP_KERNEL);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to map firmware CE region: %d\\n\", ret);\n\t\tgoto err_iommu_unmap;\n\t}\n\n\tab_ahb->fw.use_tz = false;\n\tab_ahb->fw.iommu_domain = iommu_dom;\n\tof_node_put(node);\n\n\treturn 0;\n\nerr_iommu_unmap:\n\tiommu_unmap(iommu_dom, ab_ahb->fw.msa_paddr, ab_ahb->fw.msa_size);\n\nerr_iommu_detach:\n\tiommu_detach_device(iommu_dom, ab_ahb->fw.dev);\n\nerr_iommu_free:\n\tiommu_domain_free(iommu_dom);\n\nerr_unregister:\n\tplatform_device_unregister(pdev);\n\tof_node_put(node);\n\n\treturn ret;\n}\n\nstatic int ath11k_ahb_fw_resource_deinit(struct ath11k_base *ab)\n{\n\tstruct ath11k_ahb *ab_ahb = ath11k_ahb_priv(ab);\n\tstruct iommu_domain *iommu;\n\tsize_t unmapped_size;\n\n\t \n\tif (!ab->hw_params.fixed_fw_mem)\n\t\treturn 0;\n\n\tif (ab_ahb->fw.use_tz)\n\t\treturn 0;\n\n\tiommu = ab_ahb->fw.iommu_domain;\n\n\tunmapped_size = iommu_unmap(iommu, ab_ahb->fw.msa_paddr, ab_ahb->fw.msa_size);\n\tif (unmapped_size != ab_ahb->fw.msa_size)\n\t\tath11k_err(ab, \"failed to unmap firmware: %zu\\n\",\n\t\t\t   unmapped_size);\n\n\tunmapped_size = iommu_unmap(iommu, ab_ahb->fw.ce_paddr, ab_ahb->fw.ce_size);\n\tif (unmapped_size != ab_ahb->fw.ce_size)\n\t\tath11k_err(ab, \"failed to unmap firmware CE memory: %zu\\n\",\n\t\t\t   unmapped_size);\n\n\tiommu_detach_device(iommu, ab_ahb->fw.dev);\n\tiommu_domain_free(iommu);\n\n\tplatform_device_unregister(to_platform_device(ab_ahb->fw.dev));\n\n\treturn 0;\n}\n\nstatic int ath11k_ahb_probe(struct platform_device *pdev)\n{\n\tstruct ath11k_base *ab;\n\tconst struct of_device_id *of_id;\n\tconst struct ath11k_hif_ops *hif_ops;\n\tconst struct ath11k_pci_ops *pci_ops;\n\tenum ath11k_hw_rev hw_rev;\n\tint ret;\n\n\tof_id = of_match_device(ath11k_ahb_of_match, &pdev->dev);\n\tif (!of_id) {\n\t\tdev_err(&pdev->dev, \"failed to find matching device tree id\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\thw_rev = (uintptr_t)of_id->data;\n\n\tswitch (hw_rev) {\n\tcase ATH11K_HW_IPQ8074:\n\tcase ATH11K_HW_IPQ6018_HW10:\n\tcase ATH11K_HW_IPQ5018_HW10:\n\t\thif_ops = &ath11k_ahb_hif_ops_ipq8074;\n\t\tpci_ops = NULL;\n\t\tbreak;\n\tcase ATH11K_HW_WCN6750_HW10:\n\t\thif_ops = &ath11k_ahb_hif_ops_wcn6750;\n\t\tpci_ops = &ath11k_ahb_pci_ops_wcn6750;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&pdev->dev, \"unsupported device type %d\\n\", hw_rev);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to set 32-bit consistent dma\\n\");\n\t\treturn ret;\n\t}\n\n\tab = ath11k_core_alloc(&pdev->dev, sizeof(struct ath11k_ahb),\n\t\t\t       ATH11K_BUS_AHB);\n\tif (!ab) {\n\t\tdev_err(&pdev->dev, \"failed to allocate ath11k base\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tab->hif.ops = hif_ops;\n\tab->pdev = pdev;\n\tab->hw_rev = hw_rev;\n\tab->fw_mode = ATH11K_FIRMWARE_MODE_NORMAL;\n\tplatform_set_drvdata(pdev, ab);\n\n\tret = ath11k_pcic_register_pci_ops(ab, pci_ops);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to register PCI ops: %d\\n\", ret);\n\t\tgoto err_core_free;\n\t}\n\n\tret = ath11k_core_pre_init(ab);\n\tif (ret)\n\t\tgoto err_core_free;\n\n\tret = ath11k_ahb_setup_resources(ab);\n\tif (ret)\n\t\tgoto err_core_free;\n\n\tab->mem_ce = ab->mem;\n\n\tif (ab->hw_params.ce_remap) {\n\t\tconst struct ce_remap *ce_remap = ab->hw_params.ce_remap;\n\t\t \n\t\tab->mem_ce = ioremap(ce_remap->base, ce_remap->size);\n\t\tif (!ab->mem_ce) {\n\t\t\tdev_err(&pdev->dev, \"ce ioremap error\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_core_free;\n\t\t}\n\t}\n\n\tret = ath11k_ahb_fw_resources_init(ab);\n\tif (ret)\n\t\tgoto err_core_free;\n\n\tret = ath11k_ahb_setup_smp2p_handle(ab);\n\tif (ret)\n\t\tgoto err_fw_deinit;\n\n\tret = ath11k_hal_srng_init(ab);\n\tif (ret)\n\t\tgoto err_release_smp2p_handle;\n\n\tret = ath11k_ce_alloc_pipes(ab);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to allocate ce pipes: %d\\n\", ret);\n\t\tgoto err_hal_srng_deinit;\n\t}\n\n\tath11k_ahb_init_qmi_ce_config(ab);\n\n\tret = ath11k_core_get_rproc(ab);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to get rproc: %d\\n\", ret);\n\t\tgoto err_ce_free;\n\t}\n\n\tret = ath11k_core_init(ab);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to init core: %d\\n\", ret);\n\t\tgoto err_ce_free;\n\t}\n\n\tret = ath11k_ahb_config_irq(ab);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to configure irq: %d\\n\", ret);\n\t\tgoto err_ce_free;\n\t}\n\n\tath11k_qmi_fwreset_from_cold_boot(ab);\n\n\treturn 0;\n\nerr_ce_free:\n\tath11k_ce_free_pipes(ab);\n\nerr_hal_srng_deinit:\n\tath11k_hal_srng_deinit(ab);\n\nerr_release_smp2p_handle:\n\tath11k_ahb_release_smp2p_handle(ab);\n\nerr_fw_deinit:\n\tath11k_ahb_fw_resource_deinit(ab);\n\nerr_core_free:\n\tath11k_core_free(ab);\n\tplatform_set_drvdata(pdev, NULL);\n\n\treturn ret;\n}\n\nstatic void ath11k_ahb_remove_prepare(struct ath11k_base *ab)\n{\n\tunsigned long left;\n\n\tif (test_bit(ATH11K_FLAG_RECOVERY, &ab->dev_flags)) {\n\t\tleft = wait_for_completion_timeout(&ab->driver_recovery,\n\t\t\t\t\t\t   ATH11K_AHB_RECOVERY_TIMEOUT);\n\t\tif (!left)\n\t\t\tath11k_warn(ab, \"failed to receive recovery response completion\\n\");\n\t}\n\n\tset_bit(ATH11K_FLAG_UNREGISTERING, &ab->dev_flags);\n\tcancel_work_sync(&ab->restart_work);\n\tcancel_work_sync(&ab->qmi.event_work);\n}\n\nstatic void ath11k_ahb_free_resources(struct ath11k_base *ab)\n{\n\tstruct platform_device *pdev = ab->pdev;\n\n\tath11k_ahb_free_irq(ab);\n\tath11k_hal_srng_deinit(ab);\n\tath11k_ahb_release_smp2p_handle(ab);\n\tath11k_ahb_fw_resource_deinit(ab);\n\tath11k_ce_free_pipes(ab);\n\n\tif (ab->hw_params.ce_remap)\n\t\tiounmap(ab->mem_ce);\n\n\tath11k_core_free(ab);\n\tplatform_set_drvdata(pdev, NULL);\n}\n\nstatic int ath11k_ahb_remove(struct platform_device *pdev)\n{\n\tstruct ath11k_base *ab = platform_get_drvdata(pdev);\n\n\tif (test_bit(ATH11K_FLAG_QMI_FAIL, &ab->dev_flags)) {\n\t\tath11k_ahb_power_down(ab);\n\t\tath11k_debugfs_soc_destroy(ab);\n\t\tath11k_qmi_deinit_service(ab);\n\t\tgoto qmi_fail;\n\t}\n\n\tath11k_ahb_remove_prepare(ab);\n\tath11k_core_deinit(ab);\n\nqmi_fail:\n\tath11k_ahb_free_resources(ab);\n\n\treturn 0;\n}\n\nstatic void ath11k_ahb_shutdown(struct platform_device *pdev)\n{\n\tstruct ath11k_base *ab = platform_get_drvdata(pdev);\n\n\t \n\tath11k_ahb_remove_prepare(ab);\n\n\tif (!(test_bit(ATH11K_FLAG_REGISTERED, &ab->dev_flags)))\n\t\tgoto free_resources;\n\n\tath11k_core_deinit(ab);\n\nfree_resources:\n\tath11k_ahb_free_resources(ab);\n}\n\nstatic struct platform_driver ath11k_ahb_driver = {\n\t.driver         = {\n\t\t.name   = \"ath11k\",\n\t\t.of_match_table = ath11k_ahb_of_match,\n\t},\n\t.probe  = ath11k_ahb_probe,\n\t.remove = ath11k_ahb_remove,\n\t.shutdown = ath11k_ahb_shutdown,\n};\n\nmodule_platform_driver(ath11k_ahb_driver);\n\nMODULE_DESCRIPTION(\"Driver support for Qualcomm Technologies 802.11ax WLAN AHB devices\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}