{
  "module_name": "debugfs.c",
  "hash_id": "6aff2c71ce193cae01410b4556d85925198bd05340ce484221818c284dff3ec7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath11k/debugfs.c",
  "human_readable_source": "\n \n\n#include <linux/vmalloc.h>\n\n#include \"debugfs.h\"\n\n#include \"core.h\"\n#include \"debug.h\"\n#include \"wmi.h\"\n#include \"hal_rx.h\"\n#include \"dp_tx.h\"\n#include \"debugfs_htt_stats.h\"\n#include \"peer.h\"\n#include \"hif.h\"\n\nstatic const char *htt_bp_umac_ring[HTT_SW_UMAC_RING_IDX_MAX] = {\n\t\"REO2SW1_RING\",\n\t\"REO2SW2_RING\",\n\t\"REO2SW3_RING\",\n\t\"REO2SW4_RING\",\n\t\"WBM2REO_LINK_RING\",\n\t\"REO2TCL_RING\",\n\t\"REO2FW_RING\",\n\t\"RELEASE_RING\",\n\t\"PPE_RELEASE_RING\",\n\t\"TCL2TQM_RING\",\n\t\"TQM_RELEASE_RING\",\n\t\"REO_RELEASE_RING\",\n\t\"WBM2SW0_RELEASE_RING\",\n\t\"WBM2SW1_RELEASE_RING\",\n\t\"WBM2SW2_RELEASE_RING\",\n\t\"WBM2SW3_RELEASE_RING\",\n\t\"REO_CMD_RING\",\n\t\"REO_STATUS_RING\",\n};\n\nstatic const char *htt_bp_lmac_ring[HTT_SW_LMAC_RING_IDX_MAX] = {\n\t\"FW2RXDMA_BUF_RING\",\n\t\"FW2RXDMA_STATUS_RING\",\n\t\"FW2RXDMA_LINK_RING\",\n\t\"SW2RXDMA_BUF_RING\",\n\t\"WBM2RXDMA_LINK_RING\",\n\t\"RXDMA2FW_RING\",\n\t\"RXDMA2SW_RING\",\n\t\"RXDMA2RELEASE_RING\",\n\t\"RXDMA2REO_RING\",\n\t\"MONITOR_STATUS_RING\",\n\t\"MONITOR_BUF_RING\",\n\t\"MONITOR_DESC_RING\",\n\t\"MONITOR_DEST_RING\",\n};\n\nvoid ath11k_debugfs_add_dbring_entry(struct ath11k *ar,\n\t\t\t\t     enum wmi_direct_buffer_module id,\n\t\t\t\t     enum ath11k_dbg_dbr_event event,\n\t\t\t\t     struct hal_srng *srng)\n{\n\tstruct ath11k_debug_dbr *dbr_debug;\n\tstruct ath11k_dbg_dbr_data *dbr_data;\n\tstruct ath11k_dbg_dbr_entry *entry;\n\n\tif (id >= WMI_DIRECT_BUF_MAX || event >= ATH11K_DBG_DBR_EVENT_MAX)\n\t\treturn;\n\n\tdbr_debug = ar->debug.dbr_debug[id];\n\tif (!dbr_debug)\n\t\treturn;\n\n\tif (!dbr_debug->dbr_debug_enabled)\n\t\treturn;\n\n\tdbr_data = &dbr_debug->dbr_dbg_data;\n\n\tspin_lock_bh(&dbr_data->lock);\n\n\tif (dbr_data->entries) {\n\t\tentry = &dbr_data->entries[dbr_data->dbr_debug_idx];\n\t\tentry->hp = srng->u.src_ring.hp;\n\t\tentry->tp = *srng->u.src_ring.tp_addr;\n\t\tentry->timestamp = jiffies;\n\t\tentry->event = event;\n\n\t\tdbr_data->dbr_debug_idx++;\n\t\tif (dbr_data->dbr_debug_idx ==\n\t\t    dbr_data->num_ring_debug_entries)\n\t\t\tdbr_data->dbr_debug_idx = 0;\n\t}\n\n\tspin_unlock_bh(&dbr_data->lock);\n}\n\nstatic void ath11k_debugfs_fw_stats_reset(struct ath11k *ar)\n{\n\tspin_lock_bh(&ar->data_lock);\n\tar->fw_stats_done = false;\n\tath11k_fw_stats_pdevs_free(&ar->fw_stats.pdevs);\n\tath11k_fw_stats_vdevs_free(&ar->fw_stats.vdevs);\n\tspin_unlock_bh(&ar->data_lock);\n}\n\nvoid ath11k_debugfs_fw_stats_process(struct ath11k *ar, struct ath11k_fw_stats *stats)\n{\n\tstruct ath11k_base *ab = ar->ab;\n\tstruct ath11k_pdev *pdev;\n\tbool is_end;\n\tstatic unsigned int num_vdev, num_bcn;\n\tsize_t total_vdevs_started = 0;\n\tint i;\n\n\t \n\n\tif (stats->stats_id == WMI_REQUEST_RSSI_PER_CHAIN_STAT) {\n\t\tar->fw_stats_done = true;\n\t\treturn;\n\t}\n\n\tif (stats->stats_id == WMI_REQUEST_VDEV_STAT) {\n\t\tif (list_empty(&stats->vdevs)) {\n\t\t\tath11k_warn(ab, \"empty vdev stats\");\n\t\t\treturn;\n\t\t}\n\t\t \n\t\tfor (i = 0; i < ab->num_radios; i++) {\n\t\t\tpdev = rcu_dereference(ab->pdevs_active[i]);\n\t\t\tif (pdev && pdev->ar)\n\t\t\t\ttotal_vdevs_started += ar->num_started_vdevs;\n\t\t}\n\n\t\tis_end = ((++num_vdev) == total_vdevs_started);\n\n\t\tlist_splice_tail_init(&stats->vdevs,\n\t\t\t\t      &ar->fw_stats.vdevs);\n\n\t\tif (is_end) {\n\t\t\tar->fw_stats_done = true;\n\t\t\tnum_vdev = 0;\n\t\t}\n\t\treturn;\n\t}\n\n\tif (stats->stats_id == WMI_REQUEST_BCN_STAT) {\n\t\tif (list_empty(&stats->bcn)) {\n\t\t\tath11k_warn(ab, \"empty bcn stats\");\n\t\t\treturn;\n\t\t}\n\t\t \n\t\tis_end = ((++num_bcn) == ar->num_started_vdevs);\n\n\t\tlist_splice_tail_init(&stats->bcn,\n\t\t\t\t      &ar->fw_stats.bcn);\n\n\t\tif (is_end) {\n\t\t\tar->fw_stats_done = true;\n\t\t\tnum_bcn = 0;\n\t\t}\n\t}\n}\n\nstatic int ath11k_debugfs_fw_stats_request(struct ath11k *ar,\n\t\t\t\t\t   struct stats_request_params *req_param)\n{\n\tstruct ath11k_base *ab = ar->ab;\n\tunsigned long timeout, time_left;\n\tint ret;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(3 * 1000);\n\n\tath11k_debugfs_fw_stats_reset(ar);\n\n\treinit_completion(&ar->fw_stats_complete);\n\n\tret = ath11k_wmi_send_stats_request_cmd(ar, req_param);\n\n\tif (ret) {\n\t\tath11k_warn(ab, \"could not request fw stats (%d)\\n\",\n\t\t\t    ret);\n\t\treturn ret;\n\t}\n\n\ttime_left = wait_for_completion_timeout(&ar->fw_stats_complete, 1 * HZ);\n\n\tif (!time_left)\n\t\treturn -ETIMEDOUT;\n\n\tfor (;;) {\n\t\tif (time_after(jiffies, timeout))\n\t\t\tbreak;\n\n\t\tspin_lock_bh(&ar->data_lock);\n\t\tif (ar->fw_stats_done) {\n\t\t\tspin_unlock_bh(&ar->data_lock);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock_bh(&ar->data_lock);\n\t}\n\treturn 0;\n}\n\nint ath11k_debugfs_get_fw_stats(struct ath11k *ar, u32 pdev_id,\n\t\t\t\tu32 vdev_id, u32 stats_id)\n{\n\tstruct ath11k_base *ab = ar->ab;\n\tstruct stats_request_params req_param;\n\tint ret;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (ar->state != ATH11K_STATE_ON) {\n\t\tret = -ENETDOWN;\n\t\tgoto err_unlock;\n\t}\n\n\treq_param.pdev_id = pdev_id;\n\treq_param.vdev_id = vdev_id;\n\treq_param.stats_id = stats_id;\n\n\tret = ath11k_debugfs_fw_stats_request(ar, &req_param);\n\tif (ret)\n\t\tath11k_warn(ab, \"failed to request fw stats: %d\\n\", ret);\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t   \"debug get fw stat pdev id %d vdev id %d stats id 0x%x\\n\",\n\t\t   pdev_id, vdev_id, stats_id);\n\nerr_unlock:\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn ret;\n}\n\nstatic int ath11k_open_pdev_stats(struct inode *inode, struct file *file)\n{\n\tstruct ath11k *ar = inode->i_private;\n\tstruct ath11k_base *ab = ar->ab;\n\tstruct stats_request_params req_param;\n\tvoid *buf = NULL;\n\tint ret;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (ar->state != ATH11K_STATE_ON) {\n\t\tret = -ENETDOWN;\n\t\tgoto err_unlock;\n\t}\n\n\tbuf = vmalloc(ATH11K_FW_STATS_BUF_SIZE);\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto err_unlock;\n\t}\n\n\treq_param.pdev_id = ar->pdev->pdev_id;\n\treq_param.vdev_id = 0;\n\treq_param.stats_id = WMI_REQUEST_PDEV_STAT;\n\n\tret = ath11k_debugfs_fw_stats_request(ar, &req_param);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to request fw pdev stats: %d\\n\", ret);\n\t\tgoto err_free;\n\t}\n\n\tath11k_wmi_fw_stats_fill(ar, &ar->fw_stats, req_param.stats_id, buf);\n\n\tfile->private_data = buf;\n\n\tmutex_unlock(&ar->conf_mutex);\n\treturn 0;\n\nerr_free:\n\tvfree(buf);\n\nerr_unlock:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic int ath11k_release_pdev_stats(struct inode *inode, struct file *file)\n{\n\tvfree(file->private_data);\n\n\treturn 0;\n}\n\nstatic ssize_t ath11k_read_pdev_stats(struct file *file,\n\t\t\t\t      char __user *user_buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tconst char *buf = file->private_data;\n\tsize_t len = strlen(buf);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic const struct file_operations fops_pdev_stats = {\n\t.open = ath11k_open_pdev_stats,\n\t.release = ath11k_release_pdev_stats,\n\t.read = ath11k_read_pdev_stats,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic int ath11k_open_vdev_stats(struct inode *inode, struct file *file)\n{\n\tstruct ath11k *ar = inode->i_private;\n\tstruct stats_request_params req_param;\n\tvoid *buf = NULL;\n\tint ret;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (ar->state != ATH11K_STATE_ON) {\n\t\tret = -ENETDOWN;\n\t\tgoto err_unlock;\n\t}\n\n\tbuf = vmalloc(ATH11K_FW_STATS_BUF_SIZE);\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto err_unlock;\n\t}\n\n\treq_param.pdev_id = ar->pdev->pdev_id;\n\t \n\treq_param.vdev_id = 0;\n\treq_param.stats_id = WMI_REQUEST_VDEV_STAT;\n\n\tret = ath11k_debugfs_fw_stats_request(ar, &req_param);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to request fw vdev stats: %d\\n\", ret);\n\t\tgoto err_free;\n\t}\n\n\tath11k_wmi_fw_stats_fill(ar, &ar->fw_stats, req_param.stats_id, buf);\n\n\tfile->private_data = buf;\n\n\tmutex_unlock(&ar->conf_mutex);\n\treturn 0;\n\nerr_free:\n\tvfree(buf);\n\nerr_unlock:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic int ath11k_release_vdev_stats(struct inode *inode, struct file *file)\n{\n\tvfree(file->private_data);\n\n\treturn 0;\n}\n\nstatic ssize_t ath11k_read_vdev_stats(struct file *file,\n\t\t\t\t      char __user *user_buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tconst char *buf = file->private_data;\n\tsize_t len = strlen(buf);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic const struct file_operations fops_vdev_stats = {\n\t.open = ath11k_open_vdev_stats,\n\t.release = ath11k_release_vdev_stats,\n\t.read = ath11k_read_vdev_stats,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic int ath11k_open_bcn_stats(struct inode *inode, struct file *file)\n{\n\tstruct ath11k *ar = inode->i_private;\n\tstruct ath11k_vif *arvif;\n\tstruct stats_request_params req_param;\n\tvoid *buf = NULL;\n\tint ret;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (ar->state != ATH11K_STATE_ON) {\n\t\tret = -ENETDOWN;\n\t\tgoto err_unlock;\n\t}\n\n\tbuf = vmalloc(ATH11K_FW_STATS_BUF_SIZE);\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto err_unlock;\n\t}\n\n\treq_param.stats_id = WMI_REQUEST_BCN_STAT;\n\treq_param.pdev_id = ar->pdev->pdev_id;\n\n\t \n\tlist_for_each_entry(arvif, &ar->arvifs, list) {\n\t\tif (!arvif->is_up)\n\t\t\tcontinue;\n\n\t\treq_param.vdev_id = arvif->vdev_id;\n\t\tret = ath11k_debugfs_fw_stats_request(ar, &req_param);\n\t\tif (ret) {\n\t\t\tath11k_warn(ar->ab, \"failed to request fw bcn stats: %d\\n\", ret);\n\t\t\tgoto err_free;\n\t\t}\n\t}\n\n\tath11k_wmi_fw_stats_fill(ar, &ar->fw_stats, req_param.stats_id, buf);\n\n\t \n\tspin_lock_bh(&ar->data_lock);\n\tath11k_fw_stats_bcn_free(&ar->fw_stats.bcn);\n\tspin_unlock_bh(&ar->data_lock);\n\n\tfile->private_data = buf;\n\n\tmutex_unlock(&ar->conf_mutex);\n\treturn 0;\n\nerr_free:\n\tvfree(buf);\n\nerr_unlock:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic int ath11k_release_bcn_stats(struct inode *inode, struct file *file)\n{\n\tvfree(file->private_data);\n\n\treturn 0;\n}\n\nstatic ssize_t ath11k_read_bcn_stats(struct file *file,\n\t\t\t\t     char __user *user_buf,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tconst char *buf = file->private_data;\n\tsize_t len = strlen(buf);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic const struct file_operations fops_bcn_stats = {\n\t.open = ath11k_open_bcn_stats,\n\t.release = ath11k_release_bcn_stats,\n\t.read = ath11k_read_bcn_stats,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t ath11k_read_simulate_fw_crash(struct file *file,\n\t\t\t\t\t     char __user *user_buf,\n\t\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tconst char buf[] =\n\t\t\"To simulate firmware crash write one of the keywords to this file:\\n\"\n\t\t\"`assert` - this will send WMI_FORCE_FW_HANG_CMDID to firmware to cause assert.\\n\"\n\t\t\"`hw-restart` - this will simply queue hw restart without fw/hw actually crashing.\\n\";\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, strlen(buf));\n}\n\n \nstatic ssize_t ath11k_write_simulate_fw_crash(struct file *file,\n\t\t\t\t\t      const char __user *user_buf,\n\t\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct ath11k_base *ab = file->private_data;\n\tstruct ath11k_pdev *pdev;\n\tstruct ath11k *ar = ab->pdevs[0].ar;\n\tchar buf[32] = {0};\n\tssize_t rc;\n\tint i, ret, radioup = 0;\n\n\tfor (i = 0; i < ab->num_radios; i++) {\n\t\tpdev = &ab->pdevs[i];\n\t\tar = pdev->ar;\n\t\tif (ar && ar->state == ATH11K_STATE_ON) {\n\t\t\tradioup = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t \n\tif (*ppos != 0 || count >= sizeof(buf) || count == 0)\n\t\treturn -EINVAL;\n\n\trc = simple_write_to_buffer(buf, sizeof(buf) - 1, ppos, user_buf, count);\n\tif (rc < 0)\n\t\treturn rc;\n\n\t \n\tif (buf[*ppos - 1] == '\\n')\n\t\tbuf[*ppos - 1] = '\\0';\n\n\tif (radioup == 0) {\n\t\tret = -ENETDOWN;\n\t\tgoto exit;\n\t}\n\n\tif (!strcmp(buf, \"assert\")) {\n\t\tath11k_info(ab, \"simulating firmware assert crash\\n\");\n\t\tret = ath11k_wmi_force_fw_hang_cmd(ar,\n\t\t\t\t\t\t   ATH11K_WMI_FW_HANG_ASSERT_TYPE,\n\t\t\t\t\t\t   ATH11K_WMI_FW_HANG_DELAY);\n\t} else if (!strcmp(buf, \"hw-restart\")) {\n\t\tath11k_info(ab, \"user requested hw restart\\n\");\n\t\tqueue_work(ab->workqueue_aux, &ab->reset_work);\n\t\tret = 0;\n\t} else {\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to simulate firmware crash: %d\\n\", ret);\n\t\tgoto exit;\n\t}\n\n\tret = count;\n\nexit:\n\treturn ret;\n}\n\nstatic const struct file_operations fops_simulate_fw_crash = {\n\t.read = ath11k_read_simulate_fw_crash,\n\t.write = ath11k_write_simulate_fw_crash,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t ath11k_write_enable_extd_tx_stats(struct file *file,\n\t\t\t\t\t\t const char __user *ubuf,\n\t\t\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct ath11k *ar = file->private_data;\n\tu32 filter;\n\tint ret;\n\n\tif (kstrtouint_from_user(ubuf, count, 0, &filter))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (ar->state != ATH11K_STATE_ON) {\n\t\tret = -ENETDOWN;\n\t\tgoto out;\n\t}\n\n\tif (filter == ar->debug.extd_tx_stats) {\n\t\tret = count;\n\t\tgoto out;\n\t}\n\n\tar->debug.extd_tx_stats = filter;\n\tret = count;\n\nout:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic ssize_t ath11k_read_enable_extd_tx_stats(struct file *file,\n\t\t\t\t\t\tchar __user *ubuf,\n\t\t\t\t\t\tsize_t count, loff_t *ppos)\n\n{\n\tchar buf[32] = {0};\n\tstruct ath11k *ar = file->private_data;\n\tint len = 0;\n\n\tmutex_lock(&ar->conf_mutex);\n\tlen = scnprintf(buf, sizeof(buf) - len, \"%08x\\n\",\n\t\t\tar->debug.extd_tx_stats);\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn simple_read_from_buffer(ubuf, count, ppos, buf, len);\n}\n\nstatic const struct file_operations fops_extd_tx_stats = {\n\t.read = ath11k_read_enable_extd_tx_stats,\n\t.write = ath11k_write_enable_extd_tx_stats,\n\t.open = simple_open\n};\n\nstatic ssize_t ath11k_write_extd_rx_stats(struct file *file,\n\t\t\t\t\t  const char __user *ubuf,\n\t\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct ath11k *ar = file->private_data;\n\tstruct ath11k_base *ab = ar->ab;\n\tstruct htt_rx_ring_tlv_filter tlv_filter = {0};\n\tu32 enable, rx_filter = 0, ring_id;\n\tint i;\n\tint ret;\n\n\tif (kstrtouint_from_user(ubuf, count, 0, &enable))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (ar->state != ATH11K_STATE_ON) {\n\t\tret = -ENETDOWN;\n\t\tgoto exit;\n\t}\n\n\tif (enable > 1) {\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tif (enable == ar->debug.extd_rx_stats) {\n\t\tret = count;\n\t\tgoto exit;\n\t}\n\n\tif (test_bit(ATH11K_FLAG_MONITOR_STARTED, &ar->monitor_flags)) {\n\t\tar->debug.extd_rx_stats = enable;\n\t\tret = count;\n\t\tgoto exit;\n\t}\n\n\tif (enable) {\n\t\trx_filter =  HTT_RX_FILTER_TLV_FLAGS_MPDU_START;\n\t\trx_filter |= HTT_RX_FILTER_TLV_FLAGS_PPDU_START;\n\t\trx_filter |= HTT_RX_FILTER_TLV_FLAGS_PPDU_END;\n\t\trx_filter |= HTT_RX_FILTER_TLV_FLAGS_PPDU_END_USER_STATS;\n\t\trx_filter |= HTT_RX_FILTER_TLV_FLAGS_PPDU_END_USER_STATS_EXT;\n\t\trx_filter |= HTT_RX_FILTER_TLV_FLAGS_PPDU_END_STATUS_DONE;\n\n\t\ttlv_filter.rx_filter = rx_filter;\n\t\ttlv_filter.pkt_filter_flags0 = HTT_RX_FP_MGMT_FILTER_FLAGS0;\n\t\ttlv_filter.pkt_filter_flags1 = HTT_RX_FP_MGMT_FILTER_FLAGS1;\n\t\ttlv_filter.pkt_filter_flags2 = HTT_RX_FP_CTRL_FILTER_FLASG2;\n\t\ttlv_filter.pkt_filter_flags3 = HTT_RX_FP_CTRL_FILTER_FLASG3 |\n\t\t\tHTT_RX_FP_DATA_FILTER_FLASG3;\n\t} else {\n\t\ttlv_filter = ath11k_mac_mon_status_filter_default;\n\t}\n\n\tar->debug.rx_filter = tlv_filter.rx_filter;\n\n\tfor (i = 0; i < ab->hw_params.num_rxmda_per_pdev; i++) {\n\t\tring_id = ar->dp.rx_mon_status_refill_ring[i].refill_buf_ring.ring_id;\n\t\tret = ath11k_dp_tx_htt_rx_filter_setup(ar->ab, ring_id, ar->dp.mac_id,\n\t\t\t\t\t\t       HAL_RXDMA_MONITOR_STATUS,\n\t\t\t\t\t\t       DP_RX_BUFFER_SIZE, &tlv_filter);\n\n\t\tif (ret) {\n\t\t\tath11k_warn(ar->ab, \"failed to set rx filter for monitor status ring\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tar->debug.extd_rx_stats = enable;\n\tret = count;\nexit:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic ssize_t ath11k_read_extd_rx_stats(struct file *file,\n\t\t\t\t\t char __user *ubuf,\n\t\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct ath11k *ar = file->private_data;\n\tchar buf[32];\n\tint len = 0;\n\n\tmutex_lock(&ar->conf_mutex);\n\tlen = scnprintf(buf, sizeof(buf) - len, \"%d\\n\",\n\t\t\tar->debug.extd_rx_stats);\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn simple_read_from_buffer(ubuf, count, ppos, buf, len);\n}\n\nstatic const struct file_operations fops_extd_rx_stats = {\n\t.read = ath11k_read_extd_rx_stats,\n\t.write = ath11k_write_extd_rx_stats,\n\t.open = simple_open,\n};\n\nstatic int ath11k_fill_bp_stats(struct ath11k_base *ab,\n\t\t\t\tstruct ath11k_bp_stats *bp_stats,\n\t\t\t\tchar *buf, int len, int size)\n{\n\tlockdep_assert_held(&ab->base_lock);\n\n\tlen += scnprintf(buf + len, size - len, \"count: %u\\n\",\n\t\t\t bp_stats->count);\n\tlen += scnprintf(buf + len, size - len, \"hp: %u\\n\",\n\t\t\t bp_stats->hp);\n\tlen += scnprintf(buf + len, size - len, \"tp: %u\\n\",\n\t\t\t bp_stats->tp);\n\tlen += scnprintf(buf + len, size - len, \"seen before: %ums\\n\\n\",\n\t\t\t jiffies_to_msecs(jiffies - bp_stats->jiffies));\n\treturn len;\n}\n\nstatic ssize_t ath11k_debugfs_dump_soc_ring_bp_stats(struct ath11k_base *ab,\n\t\t\t\t\t\t     char *buf, int size)\n{\n\tstruct ath11k_bp_stats *bp_stats;\n\tbool stats_rxd = false;\n\tu8 i, pdev_idx;\n\tint len = 0;\n\n\tlen += scnprintf(buf + len, size - len, \"\\nBackpressure Stats\\n\");\n\tlen += scnprintf(buf + len, size - len, \"==================\\n\");\n\n\tspin_lock_bh(&ab->base_lock);\n\tfor (i = 0; i < HTT_SW_UMAC_RING_IDX_MAX; i++) {\n\t\tbp_stats = &ab->soc_stats.bp_stats.umac_ring_bp_stats[i];\n\n\t\tif (!bp_stats->count)\n\t\t\tcontinue;\n\n\t\tlen += scnprintf(buf + len, size - len, \"Ring: %s\\n\",\n\t\t\t\t htt_bp_umac_ring[i]);\n\t\tlen = ath11k_fill_bp_stats(ab, bp_stats, buf, len, size);\n\t\tstats_rxd = true;\n\t}\n\n\tfor (i = 0; i < HTT_SW_LMAC_RING_IDX_MAX; i++) {\n\t\tfor (pdev_idx = 0; pdev_idx < MAX_RADIOS; pdev_idx++) {\n\t\t\tbp_stats =\n\t\t\t\t&ab->soc_stats.bp_stats.lmac_ring_bp_stats[i][pdev_idx];\n\n\t\t\tif (!bp_stats->count)\n\t\t\t\tcontinue;\n\n\t\t\tlen += scnprintf(buf + len, size - len, \"Ring: %s\\n\",\n\t\t\t\t\t htt_bp_lmac_ring[i]);\n\t\t\tlen += scnprintf(buf + len, size - len, \"pdev: %d\\n\",\n\t\t\t\t\t pdev_idx);\n\t\t\tlen = ath11k_fill_bp_stats(ab, bp_stats, buf, len, size);\n\t\t\tstats_rxd = true;\n\t\t}\n\t}\n\tspin_unlock_bh(&ab->base_lock);\n\n\tif (!stats_rxd)\n\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t \"No Ring Backpressure stats received\\n\\n\");\n\n\treturn len;\n}\n\nstatic ssize_t ath11k_debugfs_dump_soc_dp_stats(struct file *file,\n\t\t\t\t\t\tchar __user *user_buf,\n\t\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct ath11k_base *ab = file->private_data;\n\tstruct ath11k_soc_dp_stats *soc_stats = &ab->soc_stats;\n\tint len = 0, i, retval;\n\tconst int size = 4096;\n\tstatic const char *rxdma_err[HAL_REO_ENTR_RING_RXDMA_ECODE_MAX] = {\n\t\t\t\"Overflow\", \"MPDU len\", \"FCS\", \"Decrypt\", \"TKIP MIC\",\n\t\t\t\"Unencrypt\", \"MSDU len\", \"MSDU limit\", \"WiFi parse\",\n\t\t\t\"AMSDU parse\", \"SA timeout\", \"DA timeout\",\n\t\t\t\"Flow timeout\", \"Flush req\"};\n\tstatic const char *reo_err[HAL_REO_DEST_RING_ERROR_CODE_MAX] = {\n\t\t\t\"Desc addr zero\", \"Desc inval\", \"AMPDU in non BA\",\n\t\t\t\"Non BA dup\", \"BA dup\", \"Frame 2k jump\", \"BAR 2k jump\",\n\t\t\t\"Frame OOR\", \"BAR OOR\", \"No BA session\",\n\t\t\t\"Frame SN equal SSN\", \"PN check fail\", \"2k err\",\n\t\t\t\"PN err\", \"Desc blocked\"};\n\n\tchar *buf;\n\n\tbuf = kzalloc(size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tlen += scnprintf(buf + len, size - len, \"SOC RX STATS:\\n\\n\");\n\tlen += scnprintf(buf + len, size - len, \"err ring pkts: %u\\n\",\n\t\t\t soc_stats->err_ring_pkts);\n\tlen += scnprintf(buf + len, size - len, \"Invalid RBM: %u\\n\\n\",\n\t\t\t soc_stats->invalid_rbm);\n\tlen += scnprintf(buf + len, size - len, \"RXDMA errors:\\n\");\n\tfor (i = 0; i < HAL_REO_ENTR_RING_RXDMA_ECODE_MAX; i++)\n\t\tlen += scnprintf(buf + len, size - len, \"%s: %u\\n\",\n\t\t\t\t rxdma_err[i], soc_stats->rxdma_error[i]);\n\n\tlen += scnprintf(buf + len, size - len, \"\\nREO errors:\\n\");\n\tfor (i = 0; i < HAL_REO_DEST_RING_ERROR_CODE_MAX; i++)\n\t\tlen += scnprintf(buf + len, size - len, \"%s: %u\\n\",\n\t\t\t\t reo_err[i], soc_stats->reo_error[i]);\n\n\tlen += scnprintf(buf + len, size - len, \"\\nHAL REO errors:\\n\");\n\tlen += scnprintf(buf + len, size - len,\n\t\t\t \"ring0: %u\\nring1: %u\\nring2: %u\\nring3: %u\\n\",\n\t\t\t soc_stats->hal_reo_error[0],\n\t\t\t soc_stats->hal_reo_error[1],\n\t\t\t soc_stats->hal_reo_error[2],\n\t\t\t soc_stats->hal_reo_error[3]);\n\n\tlen += scnprintf(buf + len, size - len, \"\\nSOC TX STATS:\\n\");\n\tlen += scnprintf(buf + len, size - len, \"\\nTCL Ring Full Failures:\\n\");\n\n\tfor (i = 0; i < ab->hw_params.max_tx_ring; i++)\n\t\tlen += scnprintf(buf + len, size - len, \"ring%d: %u\\n\",\n\t\t\t\t i, soc_stats->tx_err.desc_na[i]);\n\n\tlen += scnprintf(buf + len, size - len,\n\t\t\t \"\\nMisc Transmit Failures: %d\\n\",\n\t\t\t atomic_read(&soc_stats->tx_err.misc_fail));\n\n\tlen += ath11k_debugfs_dump_soc_ring_bp_stats(ab, buf + len, size - len);\n\n\tif (len > size)\n\t\tlen = size;\n\tretval = simple_read_from_buffer(user_buf, count, ppos, buf, len);\n\tkfree(buf);\n\n\treturn retval;\n}\n\nstatic const struct file_operations fops_soc_dp_stats = {\n\t.read = ath11k_debugfs_dump_soc_dp_stats,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t ath11k_write_fw_dbglog(struct file *file,\n\t\t\t\t      const char __user *user_buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct ath11k *ar = file->private_data;\n\tchar buf[128] = {0};\n\tstruct ath11k_fw_dbglog dbglog;\n\tunsigned int param, mod_id_index, is_end;\n\tu64 value;\n\tint ret, num;\n\n\tret = simple_write_to_buffer(buf, sizeof(buf) - 1, ppos,\n\t\t\t\t     user_buf, count);\n\tif (ret <= 0)\n\t\treturn ret;\n\n\tnum = sscanf(buf, \"%u %llx %u %u\", &param, &value, &mod_id_index, &is_end);\n\n\tif (num < 2)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ar->conf_mutex);\n\tif (param == WMI_DEBUG_LOG_PARAM_MOD_ENABLE_BITMAP ||\n\t    param == WMI_DEBUG_LOG_PARAM_WOW_MOD_ENABLE_BITMAP) {\n\t\tif (num != 4 || mod_id_index > (MAX_MODULE_ID_BITMAP_WORDS - 1)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tar->debug.module_id_bitmap[mod_id_index] = upper_32_bits(value);\n\t\tif (!is_end) {\n\t\t\tret = count;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tif (num != 2) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdbglog.param = param;\n\tdbglog.value = lower_32_bits(value);\n\tret = ath11k_wmi_fw_dbglog_cfg(ar, ar->debug.module_id_bitmap, &dbglog);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"fw dbglog config failed from debugfs: %d\\n\",\n\t\t\t    ret);\n\t\tgoto out;\n\t}\n\n\tret = count;\n\nout:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic const struct file_operations fops_fw_dbglog = {\n\t.write = ath11k_write_fw_dbglog,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic int ath11k_open_sram_dump(struct inode *inode, struct file *file)\n{\n\tstruct ath11k_base *ab = inode->i_private;\n\tu8 *buf;\n\tu32 start, end;\n\tint ret;\n\n\tstart = ab->hw_params.sram_dump.start;\n\tend = ab->hw_params.sram_dump.end;\n\n\tbuf = vmalloc(end - start + 1);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = ath11k_hif_read(ab, buf, start, end);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to dump sram: %d\\n\", ret);\n\t\tvfree(buf);\n\t\treturn ret;\n\t}\n\n\tfile->private_data = buf;\n\treturn 0;\n}\n\nstatic ssize_t ath11k_read_sram_dump(struct file *file,\n\t\t\t\t     char __user *user_buf,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct ath11k_base *ab = file->f_inode->i_private;\n\tconst char *buf = file->private_data;\n\tint len;\n\tu32 start, end;\n\n\tstart = ab->hw_params.sram_dump.start;\n\tend = ab->hw_params.sram_dump.end;\n\tlen = end - start + 1;\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic int ath11k_release_sram_dump(struct inode *inode, struct file *file)\n{\n\tvfree(file->private_data);\n\tfile->private_data = NULL;\n\n\treturn 0;\n}\n\nstatic const struct file_operations fops_sram_dump = {\n\t.open = ath11k_open_sram_dump,\n\t.read = ath11k_read_sram_dump,\n\t.release = ath11k_release_sram_dump,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nint ath11k_debugfs_pdev_create(struct ath11k_base *ab)\n{\n\tif (test_bit(ATH11K_FLAG_REGISTERED, &ab->dev_flags))\n\t\treturn 0;\n\n\tdebugfs_create_file(\"simulate_fw_crash\", 0600, ab->debugfs_soc, ab,\n\t\t\t    &fops_simulate_fw_crash);\n\n\tdebugfs_create_file(\"soc_dp_stats\", 0600, ab->debugfs_soc, ab,\n\t\t\t    &fops_soc_dp_stats);\n\n\tif (ab->hw_params.sram_dump.start != 0)\n\t\tdebugfs_create_file(\"sram\", 0400, ab->debugfs_soc, ab,\n\t\t\t\t    &fops_sram_dump);\n\n\treturn 0;\n}\n\nvoid ath11k_debugfs_pdev_destroy(struct ath11k_base *ab)\n{\n\tdebugfs_remove_recursive(ab->debugfs_soc);\n\tab->debugfs_soc = NULL;\n}\n\nint ath11k_debugfs_soc_create(struct ath11k_base *ab)\n{\n\tstruct dentry *root;\n\tbool dput_needed;\n\tchar name[64];\n\tint ret;\n\n\troot = debugfs_lookup(\"ath11k\", NULL);\n\tif (!root) {\n\t\troot = debugfs_create_dir(\"ath11k\", NULL);\n\t\tif (IS_ERR_OR_NULL(root))\n\t\t\treturn PTR_ERR(root);\n\n\t\tdput_needed = false;\n\t} else {\n\t\t \n\t\tdput_needed = true;\n\t}\n\n\tscnprintf(name, sizeof(name), \"%s-%s\", ath11k_bus_str(ab->hif.bus),\n\t\t  dev_name(ab->dev));\n\n\tab->debugfs_soc = debugfs_create_dir(name, root);\n\tif (IS_ERR_OR_NULL(ab->debugfs_soc)) {\n\t\tret = PTR_ERR(ab->debugfs_soc);\n\t\tgoto out;\n\t}\n\n\tret = 0;\n\nout:\n\tif (dput_needed)\n\t\tdput(root);\n\n\treturn ret;\n}\n\nvoid ath11k_debugfs_soc_destroy(struct ath11k_base *ab)\n{\n\tdebugfs_remove_recursive(ab->debugfs_soc);\n\tab->debugfs_soc = NULL;\n\n\t \n}\nEXPORT_SYMBOL(ath11k_debugfs_soc_destroy);\n\nvoid ath11k_debugfs_fw_stats_init(struct ath11k *ar)\n{\n\tstruct dentry *fwstats_dir = debugfs_create_dir(\"fw_stats\",\n\t\t\t\t\t\t\tar->debug.debugfs_pdev);\n\n\tar->fw_stats.debugfs_fwstats = fwstats_dir;\n\n\t \n\tdebugfs_create_file(\"pdev_stats\", 0600, fwstats_dir, ar,\n\t\t\t    &fops_pdev_stats);\n\tdebugfs_create_file(\"vdev_stats\", 0600, fwstats_dir, ar,\n\t\t\t    &fops_vdev_stats);\n\tdebugfs_create_file(\"beacon_stats\", 0600, fwstats_dir, ar,\n\t\t\t    &fops_bcn_stats);\n}\n\nstatic ssize_t ath11k_write_pktlog_filter(struct file *file,\n\t\t\t\t\t  const char __user *ubuf,\n\t\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct ath11k *ar = file->private_data;\n\tstruct ath11k_base *ab = ar->ab;\n\tstruct htt_rx_ring_tlv_filter tlv_filter = {0};\n\tu32 rx_filter = 0, ring_id, filter, mode;\n\tu8 buf[128] = {0};\n\tint i, ret, rx_buf_sz = 0;\n\tssize_t rc;\n\n\tmutex_lock(&ar->conf_mutex);\n\tif (ar->state != ATH11K_STATE_ON) {\n\t\tret = -ENETDOWN;\n\t\tgoto out;\n\t}\n\n\trc = simple_write_to_buffer(buf, sizeof(buf) - 1, ppos, ubuf, count);\n\tif (rc < 0) {\n\t\tret = rc;\n\t\tgoto out;\n\t}\n\tbuf[rc] = '\\0';\n\n\tret = sscanf(buf, \"0x%x %u\", &filter, &mode);\n\tif (ret != 2) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (filter) {\n\t\tret = ath11k_wmi_pdev_pktlog_enable(ar, filter);\n\t\tif (ret) {\n\t\t\tath11k_warn(ar->ab,\n\t\t\t\t    \"failed to enable pktlog filter %x: %d\\n\",\n\t\t\t\t    ar->debug.pktlog_filter, ret);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tret = ath11k_wmi_pdev_pktlog_disable(ar);\n\t\tif (ret) {\n\t\t\tath11k_warn(ar->ab, \"failed to disable pktlog: %d\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < ab->hw_params.num_rxmda_per_pdev; i++) {\n\t\tring_id = ar->dp.rx_mon_status_refill_ring[i].refill_buf_ring.ring_id;\n\t\tret = ath11k_dp_tx_htt_rx_filter_setup(ar->ab, ring_id, ar->dp.mac_id,\n\t\t\t\t\t\t       HAL_RXDMA_MONITOR_STATUS,\n\t\t\t\t\t\t       rx_buf_sz, &tlv_filter);\n\t\tif (ret) {\n\t\t\tath11k_warn(ar->ab, \"failed to set rx filter for monitor status ring\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n#define HTT_RX_FILTER_TLV_LITE_MODE \\\n\t\t\t(HTT_RX_FILTER_TLV_FLAGS_PPDU_START | \\\n\t\t\tHTT_RX_FILTER_TLV_FLAGS_PPDU_END | \\\n\t\t\tHTT_RX_FILTER_TLV_FLAGS_PPDU_END_USER_STATS | \\\n\t\t\tHTT_RX_FILTER_TLV_FLAGS_PPDU_END_USER_STATS_EXT | \\\n\t\t\tHTT_RX_FILTER_TLV_FLAGS_PPDU_END_STATUS_DONE | \\\n\t\t\tHTT_RX_FILTER_TLV_FLAGS_MPDU_START)\n\n\tif (mode == ATH11K_PKTLOG_MODE_FULL) {\n\t\trx_filter = HTT_RX_FILTER_TLV_LITE_MODE |\n\t\t\t    HTT_RX_FILTER_TLV_FLAGS_MSDU_START |\n\t\t\t    HTT_RX_FILTER_TLV_FLAGS_MSDU_END |\n\t\t\t    HTT_RX_FILTER_TLV_FLAGS_MPDU_END |\n\t\t\t    HTT_RX_FILTER_TLV_FLAGS_PACKET_HEADER |\n\t\t\t    HTT_RX_FILTER_TLV_FLAGS_ATTENTION;\n\t\trx_buf_sz = DP_RX_BUFFER_SIZE;\n\t} else if (mode == ATH11K_PKTLOG_MODE_LITE) {\n\t\tret = ath11k_dp_tx_htt_h2t_ppdu_stats_req(ar,\n\t\t\t\t\t\t\t  HTT_PPDU_STATS_TAG_PKTLOG);\n\t\tif (ret) {\n\t\t\tath11k_err(ar->ab, \"failed to enable pktlog lite: %d\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\trx_filter = HTT_RX_FILTER_TLV_LITE_MODE;\n\t\trx_buf_sz = DP_RX_BUFFER_SIZE_LITE;\n\t} else {\n\t\trx_buf_sz = DP_RX_BUFFER_SIZE;\n\t\ttlv_filter = ath11k_mac_mon_status_filter_default;\n\t\trx_filter = tlv_filter.rx_filter;\n\n\t\tret = ath11k_dp_tx_htt_h2t_ppdu_stats_req(ar,\n\t\t\t\t\t\t\t  HTT_PPDU_STATS_TAG_DEFAULT);\n\t\tif (ret) {\n\t\t\tath11k_err(ar->ab, \"failed to send htt ppdu stats req: %d\\n\",\n\t\t\t\t   ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\ttlv_filter.rx_filter = rx_filter;\n\tif (rx_filter) {\n\t\ttlv_filter.pkt_filter_flags0 = HTT_RX_FP_MGMT_FILTER_FLAGS0;\n\t\ttlv_filter.pkt_filter_flags1 = HTT_RX_FP_MGMT_FILTER_FLAGS1;\n\t\ttlv_filter.pkt_filter_flags2 = HTT_RX_FP_CTRL_FILTER_FLASG2;\n\t\ttlv_filter.pkt_filter_flags3 = HTT_RX_FP_CTRL_FILTER_FLASG3 |\n\t\t\t\t\t       HTT_RX_FP_DATA_FILTER_FLASG3;\n\t}\n\n\tfor (i = 0; i < ab->hw_params.num_rxmda_per_pdev; i++) {\n\t\tring_id = ar->dp.rx_mon_status_refill_ring[i].refill_buf_ring.ring_id;\n\t\tret = ath11k_dp_tx_htt_rx_filter_setup(ab, ring_id,\n\t\t\t\t\t\t       ar->dp.mac_id + i,\n\t\t\t\t\t\t       HAL_RXDMA_MONITOR_STATUS,\n\t\t\t\t\t\t       rx_buf_sz, &tlv_filter);\n\n\t\tif (ret) {\n\t\t\tath11k_warn(ab, \"failed to set rx filter for monitor status ring\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tath11k_info(ab, \"pktlog mode %s\\n\",\n\t\t    ((mode == ATH11K_PKTLOG_MODE_FULL) ? \"full\" : \"lite\"));\n\n\tar->debug.pktlog_filter = filter;\n\tar->debug.pktlog_mode = mode;\n\tret = count;\n\nout:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic ssize_t ath11k_read_pktlog_filter(struct file *file,\n\t\t\t\t\t char __user *ubuf,\n\t\t\t\t\t size_t count, loff_t *ppos)\n\n{\n\tchar buf[32] = {0};\n\tstruct ath11k *ar = file->private_data;\n\tint len = 0;\n\n\tmutex_lock(&ar->conf_mutex);\n\tlen = scnprintf(buf, sizeof(buf) - len, \"%08x %08x\\n\",\n\t\t\tar->debug.pktlog_filter,\n\t\t\tar->debug.pktlog_mode);\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn simple_read_from_buffer(ubuf, count, ppos, buf, len);\n}\n\nstatic const struct file_operations fops_pktlog_filter = {\n\t.read = ath11k_read_pktlog_filter,\n\t.write = ath11k_write_pktlog_filter,\n\t.open = simple_open\n};\n\nstatic ssize_t ath11k_write_simulate_radar(struct file *file,\n\t\t\t\t\t   const char __user *user_buf,\n\t\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct ath11k *ar = file->private_data;\n\tint ret;\n\n\tret = ath11k_wmi_simulate_radar(ar);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic const struct file_operations fops_simulate_radar = {\n\t.write = ath11k_write_simulate_radar,\n\t.open = simple_open\n};\n\nstatic ssize_t ath11k_debug_dump_dbr_entries(struct file *file,\n\t\t\t\t\t     char __user *user_buf,\n\t\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct ath11k_dbg_dbr_data *dbr_dbg_data = file->private_data;\n\tstatic const char * const event_id_to_string[] = {\"empty\", \"Rx\", \"Replenish\"};\n\tint size = ATH11K_DEBUG_DBR_ENTRIES_MAX * 100;\n\tchar *buf;\n\tint i, ret;\n\tint len = 0;\n\n\tbuf = kzalloc(size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tlen += scnprintf(buf + len, size - len,\n\t\t\t \"-----------------------------------------\\n\");\n\tlen += scnprintf(buf + len, size - len,\n\t\t\t \"| idx |  hp  |  tp  | timestamp |  event |\\n\");\n\tlen += scnprintf(buf + len, size - len,\n\t\t\t \"-----------------------------------------\\n\");\n\n\tspin_lock_bh(&dbr_dbg_data->lock);\n\n\tfor (i = 0; i < dbr_dbg_data->num_ring_debug_entries; i++) {\n\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t \"|%4u|%8u|%8u|%11llu|%8s|\\n\", i,\n\t\t\t\t dbr_dbg_data->entries[i].hp,\n\t\t\t\t dbr_dbg_data->entries[i].tp,\n\t\t\t\t dbr_dbg_data->entries[i].timestamp,\n\t\t\t\t event_id_to_string[dbr_dbg_data->entries[i].event]);\n\t}\n\n\tspin_unlock_bh(&dbr_dbg_data->lock);\n\n\tret = simple_read_from_buffer(user_buf, count, ppos, buf, len);\n\tkfree(buf);\n\n\treturn ret;\n}\n\nstatic const struct file_operations fops_debug_dump_dbr_entries = {\n\t.read = ath11k_debug_dump_dbr_entries,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic void ath11k_debugfs_dbr_dbg_destroy(struct ath11k *ar, int dbr_id)\n{\n\tstruct ath11k_debug_dbr *dbr_debug;\n\tstruct ath11k_dbg_dbr_data *dbr_dbg_data;\n\n\tif (!ar->debug.dbr_debug[dbr_id])\n\t\treturn;\n\n\tdbr_debug = ar->debug.dbr_debug[dbr_id];\n\tdbr_dbg_data = &dbr_debug->dbr_dbg_data;\n\n\tdebugfs_remove_recursive(dbr_debug->dbr_debugfs);\n\tkfree(dbr_dbg_data->entries);\n\tkfree(dbr_debug);\n\tar->debug.dbr_debug[dbr_id] = NULL;\n}\n\nstatic int ath11k_debugfs_dbr_dbg_init(struct ath11k *ar, int dbr_id)\n{\n\tstruct ath11k_debug_dbr *dbr_debug;\n\tstruct ath11k_dbg_dbr_data *dbr_dbg_data;\n\tstatic const char * const dbr_id_to_str[] = {\"spectral\", \"CFR\"};\n\n\tif (ar->debug.dbr_debug[dbr_id])\n\t\treturn 0;\n\n\tar->debug.dbr_debug[dbr_id] = kzalloc(sizeof(*dbr_debug),\n\t\t\t\t\t      GFP_KERNEL);\n\n\tif (!ar->debug.dbr_debug[dbr_id])\n\t\treturn -ENOMEM;\n\n\tdbr_debug = ar->debug.dbr_debug[dbr_id];\n\tdbr_dbg_data = &dbr_debug->dbr_dbg_data;\n\n\tif (dbr_debug->dbr_debugfs)\n\t\treturn 0;\n\n\tdbr_debug->dbr_debugfs = debugfs_create_dir(dbr_id_to_str[dbr_id],\n\t\t\t\t\t\t    ar->debug.debugfs_pdev);\n\tif (IS_ERR_OR_NULL(dbr_debug->dbr_debugfs)) {\n\t\tif (IS_ERR(dbr_debug->dbr_debugfs))\n\t\t\treturn PTR_ERR(dbr_debug->dbr_debugfs);\n\t\treturn -ENOMEM;\n\t}\n\n\tdbr_debug->dbr_debug_enabled = true;\n\tdbr_dbg_data->num_ring_debug_entries = ATH11K_DEBUG_DBR_ENTRIES_MAX;\n\tdbr_dbg_data->dbr_debug_idx = 0;\n\tdbr_dbg_data->entries = kcalloc(ATH11K_DEBUG_DBR_ENTRIES_MAX,\n\t\t\t\t\tsizeof(struct ath11k_dbg_dbr_entry),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!dbr_dbg_data->entries)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&dbr_dbg_data->lock);\n\n\tdebugfs_create_file(\"dump_dbr_debug\", 0444, dbr_debug->dbr_debugfs,\n\t\t\t    dbr_dbg_data, &fops_debug_dump_dbr_entries);\n\n\treturn 0;\n}\n\nstatic ssize_t ath11k_debugfs_write_enable_dbr_dbg(struct file *file,\n\t\t\t\t\t\t   const char __user *ubuf,\n\t\t\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct ath11k *ar = file->private_data;\n\tchar buf[32] = {0};\n\tu32 dbr_id, enable;\n\tint ret;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (ar->state != ATH11K_STATE_ON) {\n\t\tret = -ENETDOWN;\n\t\tgoto out;\n\t}\n\n\tret = simple_write_to_buffer(buf, sizeof(buf) - 1, ppos, ubuf, count);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tbuf[ret] = '\\0';\n\tret = sscanf(buf, \"%u %u\", &dbr_id, &enable);\n\tif (ret != 2 || dbr_id > 1 || enable > 1) {\n\t\tret = -EINVAL;\n\t\tath11k_warn(ar->ab, \"usage: echo <dbr_id> <val> dbr_id:0-Spectral 1-CFR val:0-disable 1-enable\\n\");\n\t\tgoto out;\n\t}\n\n\tif (enable) {\n\t\tret = ath11k_debugfs_dbr_dbg_init(ar, dbr_id);\n\t\tif (ret) {\n\t\t\tath11k_warn(ar->ab, \"db ring module debugfs init failed: %d\\n\",\n\t\t\t\t    ret);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tath11k_debugfs_dbr_dbg_destroy(ar, dbr_id);\n\t}\n\n\tret = count;\nout:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic const struct file_operations fops_dbr_debug = {\n\t.write = ath11k_debugfs_write_enable_dbr_dbg,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t ath11k_write_ps_timekeeper_enable(struct file *file,\n\t\t\t\t\t\t const char __user *user_buf,\n\t\t\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct ath11k *ar = file->private_data;\n\tssize_t ret;\n\tu8 ps_timekeeper_enable;\n\n\tif (kstrtou8_from_user(user_buf, count, 0, &ps_timekeeper_enable))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (ar->state != ATH11K_STATE_ON) {\n\t\tret = -ENETDOWN;\n\t\tgoto exit;\n\t}\n\n\tif (!ar->ps_state_enable) {\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tar->ps_timekeeper_enable = !!ps_timekeeper_enable;\n\tret = count;\nexit:\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn ret;\n}\n\nstatic ssize_t ath11k_read_ps_timekeeper_enable(struct file *file,\n\t\t\t\t\t\tchar __user *user_buf,\n\t\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct ath11k *ar = file->private_data;\n\tchar buf[32];\n\tint len;\n\n\tmutex_lock(&ar->conf_mutex);\n\tlen = scnprintf(buf, sizeof(buf), \"%d\\n\", ar->ps_timekeeper_enable);\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic const struct file_operations fops_ps_timekeeper_enable = {\n\t.read = ath11k_read_ps_timekeeper_enable,\n\t.write = ath11k_write_ps_timekeeper_enable,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic void ath11k_reset_peer_ps_duration(void *data,\n\t\t\t\t\t  struct ieee80211_sta *sta)\n{\n\tstruct ath11k *ar = data;\n\tstruct ath11k_sta *arsta = (struct ath11k_sta *)sta->drv_priv;\n\n\tspin_lock_bh(&ar->data_lock);\n\tarsta->ps_total_duration = 0;\n\tspin_unlock_bh(&ar->data_lock);\n}\n\nstatic ssize_t ath11k_write_reset_ps_duration(struct file *file,\n\t\t\t\t\t      const  char __user *user_buf,\n\t\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct ath11k *ar = file->private_data;\n\tint ret;\n\tu8 reset_ps_duration;\n\n\tif (kstrtou8_from_user(user_buf, count, 0, &reset_ps_duration))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (ar->state != ATH11K_STATE_ON) {\n\t\tret = -ENETDOWN;\n\t\tgoto exit;\n\t}\n\n\tif (!ar->ps_state_enable) {\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tieee80211_iterate_stations_atomic(ar->hw,\n\t\t\t\t\t  ath11k_reset_peer_ps_duration,\n\t\t\t\t\t  ar);\n\n\tret = count;\nexit:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic const struct file_operations fops_reset_ps_duration = {\n\t.write = ath11k_write_reset_ps_duration,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic void ath11k_peer_ps_state_disable(void *data,\n\t\t\t\t\t struct ieee80211_sta *sta)\n{\n\tstruct ath11k *ar = data;\n\tstruct ath11k_sta *arsta = (struct ath11k_sta *)sta->drv_priv;\n\n\tspin_lock_bh(&ar->data_lock);\n\tarsta->peer_ps_state = WMI_PEER_PS_STATE_DISABLED;\n\tarsta->ps_start_time = 0;\n\tarsta->ps_total_duration = 0;\n\tspin_unlock_bh(&ar->data_lock);\n}\n\nstatic ssize_t ath11k_write_ps_state_enable(struct file *file,\n\t\t\t\t\t    const char __user *user_buf,\n\t\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct ath11k *ar = file->private_data;\n\tstruct ath11k_pdev *pdev = ar->pdev;\n\tint ret;\n\tu32 param;\n\tu8 ps_state_enable;\n\n\tif (kstrtou8_from_user(user_buf, count, 0, &ps_state_enable))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tps_state_enable = !!ps_state_enable;\n\n\tif (ar->ps_state_enable == ps_state_enable) {\n\t\tret = count;\n\t\tgoto exit;\n\t}\n\n\tparam = WMI_PDEV_PEER_STA_PS_STATECHG_ENABLE;\n\tret = ath11k_wmi_pdev_set_param(ar, param, ps_state_enable, pdev->pdev_id);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to enable ps_state_enable: %d\\n\",\n\t\t\t    ret);\n\t\tgoto exit;\n\t}\n\tar->ps_state_enable = ps_state_enable;\n\n\tif (!ar->ps_state_enable) {\n\t\tar->ps_timekeeper_enable = false;\n\t\tieee80211_iterate_stations_atomic(ar->hw,\n\t\t\t\t\t\t  ath11k_peer_ps_state_disable,\n\t\t\t\t\t\t  ar);\n\t}\n\n\tret = count;\n\nexit:\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn ret;\n}\n\nstatic ssize_t ath11k_read_ps_state_enable(struct file *file,\n\t\t\t\t\t   char __user *user_buf,\n\t\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct ath11k *ar = file->private_data;\n\tchar buf[32];\n\tint len;\n\n\tmutex_lock(&ar->conf_mutex);\n\tlen = scnprintf(buf, sizeof(buf), \"%d\\n\", ar->ps_state_enable);\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic const struct file_operations fops_ps_state_enable = {\n\t.read = ath11k_read_ps_state_enable,\n\t.write = ath11k_write_ps_state_enable,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nint ath11k_debugfs_register(struct ath11k *ar)\n{\n\tstruct ath11k_base *ab = ar->ab;\n\tchar pdev_name[5];\n\tchar buf[100] = {0};\n\n\tsnprintf(pdev_name, sizeof(pdev_name), \"%s%d\", \"mac\", ar->pdev_idx);\n\n\tar->debug.debugfs_pdev = debugfs_create_dir(pdev_name, ab->debugfs_soc);\n\tif (IS_ERR(ar->debug.debugfs_pdev))\n\t\treturn PTR_ERR(ar->debug.debugfs_pdev);\n\n\t \n\tsnprintf(buf, 100, \"../../ath11k/%pd2\", ar->debug.debugfs_pdev);\n\tdebugfs_create_symlink(\"ath11k\", ar->hw->wiphy->debugfsdir, buf);\n\n\tath11k_debugfs_htt_stats_init(ar);\n\n\tath11k_debugfs_fw_stats_init(ar);\n\n\tdebugfs_create_file(\"ext_tx_stats\", 0644,\n\t\t\t    ar->debug.debugfs_pdev, ar,\n\t\t\t    &fops_extd_tx_stats);\n\tdebugfs_create_file(\"ext_rx_stats\", 0644,\n\t\t\t    ar->debug.debugfs_pdev, ar,\n\t\t\t    &fops_extd_rx_stats);\n\tdebugfs_create_file(\"pktlog_filter\", 0644,\n\t\t\t    ar->debug.debugfs_pdev, ar,\n\t\t\t    &fops_pktlog_filter);\n\tdebugfs_create_file(\"fw_dbglog_config\", 0600,\n\t\t\t    ar->debug.debugfs_pdev, ar,\n\t\t\t    &fops_fw_dbglog);\n\n\tif (ar->hw->wiphy->bands[NL80211_BAND_5GHZ]) {\n\t\tdebugfs_create_file(\"dfs_simulate_radar\", 0200,\n\t\t\t\t    ar->debug.debugfs_pdev, ar,\n\t\t\t\t    &fops_simulate_radar);\n\t\tdebugfs_create_bool(\"dfs_block_radar_events\", 0200,\n\t\t\t\t    ar->debug.debugfs_pdev,\n\t\t\t\t    &ar->dfs_block_radar_events);\n\t}\n\n\tif (ab->hw_params.dbr_debug_support)\n\t\tdebugfs_create_file(\"enable_dbr_debug\", 0200, ar->debug.debugfs_pdev,\n\t\t\t\t    ar, &fops_dbr_debug);\n\n\tdebugfs_create_file(\"ps_state_enable\", 0600, ar->debug.debugfs_pdev, ar,\n\t\t\t    &fops_ps_state_enable);\n\n\tif (test_bit(WMI_TLV_SERVICE_PEER_POWER_SAVE_DURATION_SUPPORT,\n\t\t     ar->ab->wmi_ab.svc_map)) {\n\t\tdebugfs_create_file(\"ps_timekeeper_enable\", 0600,\n\t\t\t\t    ar->debug.debugfs_pdev, ar,\n\t\t\t\t    &fops_ps_timekeeper_enable);\n\n\t\tdebugfs_create_file(\"reset_ps_duration\", 0200,\n\t\t\t\t    ar->debug.debugfs_pdev, ar,\n\t\t\t\t    &fops_reset_ps_duration);\n\t}\n\n\treturn 0;\n}\n\nvoid ath11k_debugfs_unregister(struct ath11k *ar)\n{\n\tstruct ath11k_debug_dbr *dbr_debug;\n\tstruct ath11k_dbg_dbr_data *dbr_dbg_data;\n\tint i;\n\n\tfor (i = 0; i < WMI_DIRECT_BUF_MAX; i++) {\n\t\tdbr_debug = ar->debug.dbr_debug[i];\n\t\tif (!dbr_debug)\n\t\t\tcontinue;\n\n\t\tdbr_dbg_data = &dbr_debug->dbr_dbg_data;\n\t\tkfree(dbr_dbg_data->entries);\n\t\tdebugfs_remove_recursive(dbr_debug->dbr_debugfs);\n\t\tkfree(dbr_debug);\n\t\tar->debug.dbr_debug[i] = NULL;\n\t}\n}\n\nstatic ssize_t ath11k_write_twt_add_dialog(struct file *file,\n\t\t\t\t\t   const char __user *ubuf,\n\t\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct ath11k_vif *arvif = file->private_data;\n\tstruct wmi_twt_add_dialog_params params = { 0 };\n\tstruct wmi_twt_enable_params twt_params = {0};\n\tstruct ath11k *ar = arvif->ar;\n\tu8 buf[128] = {0};\n\tint ret;\n\n\tif (ar->twt_enabled == 0) {\n\t\tath11k_err(ar->ab, \"twt support is not enabled\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tret = simple_write_to_buffer(buf, sizeof(buf) - 1, ppos, ubuf, count);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tbuf[ret] = '\\0';\n\tret = sscanf(buf,\n\t\t     \"%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx %u %u %u %u %u %hhu %hhu %hhu %hhu %hhu\",\n\t\t     &params.peer_macaddr[0],\n\t\t     &params.peer_macaddr[1],\n\t\t     &params.peer_macaddr[2],\n\t\t     &params.peer_macaddr[3],\n\t\t     &params.peer_macaddr[4],\n\t\t     &params.peer_macaddr[5],\n\t\t     &params.dialog_id,\n\t\t     &params.wake_intvl_us,\n\t\t     &params.wake_intvl_mantis,\n\t\t     &params.wake_dura_us,\n\t\t     &params.sp_offset_us,\n\t\t     &params.twt_cmd,\n\t\t     &params.flag_bcast,\n\t\t     &params.flag_trigger,\n\t\t     &params.flag_flow_type,\n\t\t     &params.flag_protection);\n\tif (ret != 16)\n\t\treturn -EINVAL;\n\n\t \n\tif (arvif->vif->type == NL80211_IFTYPE_STATION) {\n\t\tath11k_wmi_send_twt_disable_cmd(ar, ar->pdev->pdev_id);\n\n\t\tath11k_wmi_fill_default_twt_params(&twt_params);\n\t\ttwt_params.sta_cong_timer_ms = 0;\n\n\t\tath11k_wmi_send_twt_enable_cmd(ar, ar->pdev->pdev_id, &twt_params);\n\t}\n\n\tparams.vdev_id = arvif->vdev_id;\n\n\tret = ath11k_wmi_send_twt_add_dialog_cmd(arvif->ar, &params);\n\tif (ret)\n\t\tgoto err_twt_add_dialog;\n\n\treturn count;\n\nerr_twt_add_dialog:\n\tif (arvif->vif->type == NL80211_IFTYPE_STATION) {\n\t\tath11k_wmi_send_twt_disable_cmd(ar, ar->pdev->pdev_id);\n\t\tath11k_wmi_fill_default_twt_params(&twt_params);\n\t\tath11k_wmi_send_twt_enable_cmd(ar, ar->pdev->pdev_id, &twt_params);\n\t}\n\n\treturn ret;\n}\n\nstatic ssize_t ath11k_write_twt_del_dialog(struct file *file,\n\t\t\t\t\t   const char __user *ubuf,\n\t\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct ath11k_vif *arvif = file->private_data;\n\tstruct wmi_twt_del_dialog_params params = { 0 };\n\tstruct wmi_twt_enable_params twt_params = {0};\n\tstruct ath11k *ar = arvif->ar;\n\tu8 buf[64] = {0};\n\tint ret;\n\n\tif (ar->twt_enabled == 0) {\n\t\tath11k_err(ar->ab, \"twt support is not enabled\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tret = simple_write_to_buffer(buf, sizeof(buf) - 1, ppos, ubuf, count);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tbuf[ret] = '\\0';\n\tret = sscanf(buf, \"%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx %u\",\n\t\t     &params.peer_macaddr[0],\n\t\t     &params.peer_macaddr[1],\n\t\t     &params.peer_macaddr[2],\n\t\t     &params.peer_macaddr[3],\n\t\t     &params.peer_macaddr[4],\n\t\t     &params.peer_macaddr[5],\n\t\t     &params.dialog_id);\n\tif (ret != 7)\n\t\treturn -EINVAL;\n\n\tparams.vdev_id = arvif->vdev_id;\n\n\tret = ath11k_wmi_send_twt_del_dialog_cmd(arvif->ar, &params);\n\tif (ret)\n\t\treturn ret;\n\n\tif (arvif->vif->type == NL80211_IFTYPE_STATION) {\n\t\tath11k_wmi_send_twt_disable_cmd(ar, ar->pdev->pdev_id);\n\t\tath11k_wmi_fill_default_twt_params(&twt_params);\n\t\tath11k_wmi_send_twt_enable_cmd(ar, ar->pdev->pdev_id, &twt_params);\n\t}\n\n\treturn count;\n}\n\nstatic ssize_t ath11k_write_twt_pause_dialog(struct file *file,\n\t\t\t\t\t     const char __user *ubuf,\n\t\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct ath11k_vif *arvif = file->private_data;\n\tstruct wmi_twt_pause_dialog_params params = { 0 };\n\tu8 buf[64] = {0};\n\tint ret;\n\n\tif (arvif->ar->twt_enabled == 0) {\n\t\tath11k_err(arvif->ar->ab, \"twt support is not enabled\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tret = simple_write_to_buffer(buf, sizeof(buf) - 1, ppos, ubuf, count);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tbuf[ret] = '\\0';\n\tret = sscanf(buf, \"%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx %u\",\n\t\t     &params.peer_macaddr[0],\n\t\t     &params.peer_macaddr[1],\n\t\t     &params.peer_macaddr[2],\n\t\t     &params.peer_macaddr[3],\n\t\t     &params.peer_macaddr[4],\n\t\t     &params.peer_macaddr[5],\n\t\t     &params.dialog_id);\n\tif (ret != 7)\n\t\treturn -EINVAL;\n\n\tparams.vdev_id = arvif->vdev_id;\n\n\tret = ath11k_wmi_send_twt_pause_dialog_cmd(arvif->ar, &params);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic ssize_t ath11k_write_twt_resume_dialog(struct file *file,\n\t\t\t\t\t      const char __user *ubuf,\n\t\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct ath11k_vif *arvif = file->private_data;\n\tstruct wmi_twt_resume_dialog_params params = { 0 };\n\tu8 buf[64] = {0};\n\tint ret;\n\n\tif (arvif->ar->twt_enabled == 0) {\n\t\tath11k_err(arvif->ar->ab, \"twt support is not enabled\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tret = simple_write_to_buffer(buf, sizeof(buf) - 1, ppos, ubuf, count);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tbuf[ret] = '\\0';\n\tret = sscanf(buf, \"%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx %u %u %u\",\n\t\t     &params.peer_macaddr[0],\n\t\t     &params.peer_macaddr[1],\n\t\t     &params.peer_macaddr[2],\n\t\t     &params.peer_macaddr[3],\n\t\t     &params.peer_macaddr[4],\n\t\t     &params.peer_macaddr[5],\n\t\t     &params.dialog_id,\n\t\t     &params.sp_offset_us,\n\t\t     &params.next_twt_size);\n\tif (ret != 9)\n\t\treturn -EINVAL;\n\n\tparams.vdev_id = arvif->vdev_id;\n\n\tret = ath11k_wmi_send_twt_resume_dialog_cmd(arvif->ar, &params);\n\tif (ret)\n\t\treturn ret;\n\n\treturn count;\n}\n\nstatic const struct file_operations ath11k_fops_twt_add_dialog = {\n\t.write = ath11k_write_twt_add_dialog,\n\t.open = simple_open\n};\n\nstatic const struct file_operations ath11k_fops_twt_del_dialog = {\n\t.write = ath11k_write_twt_del_dialog,\n\t.open = simple_open\n};\n\nstatic const struct file_operations ath11k_fops_twt_pause_dialog = {\n\t.write = ath11k_write_twt_pause_dialog,\n\t.open = simple_open\n};\n\nstatic const struct file_operations ath11k_fops_twt_resume_dialog = {\n\t.write = ath11k_write_twt_resume_dialog,\n\t.open = simple_open\n};\n\nvoid ath11k_debugfs_add_interface(struct ath11k_vif *arvif)\n{\n\tstruct ath11k_base *ab = arvif->ar->ab;\n\n\tif (arvif->vif->type != NL80211_IFTYPE_AP &&\n\t    !(arvif->vif->type == NL80211_IFTYPE_STATION &&\n\t      test_bit(WMI_TLV_SERVICE_STA_TWT, ab->wmi_ab.svc_map)))\n\t\treturn;\n\n\tarvif->debugfs_twt = debugfs_create_dir(\"twt\",\n\t\t\t\t\t\tarvif->vif->debugfs_dir);\n\tdebugfs_create_file(\"add_dialog\", 0200, arvif->debugfs_twt,\n\t\t\t    arvif, &ath11k_fops_twt_add_dialog);\n\n\tdebugfs_create_file(\"del_dialog\", 0200, arvif->debugfs_twt,\n\t\t\t    arvif, &ath11k_fops_twt_del_dialog);\n\n\tdebugfs_create_file(\"pause_dialog\", 0200, arvif->debugfs_twt,\n\t\t\t    arvif, &ath11k_fops_twt_pause_dialog);\n\n\tdebugfs_create_file(\"resume_dialog\", 0200, arvif->debugfs_twt,\n\t\t\t    arvif, &ath11k_fops_twt_resume_dialog);\n}\n\nvoid ath11k_debugfs_remove_interface(struct ath11k_vif *arvif)\n{\n\tif (!arvif->debugfs_twt)\n\t\treturn;\n\n\tdebugfs_remove_recursive(arvif->debugfs_twt);\n\tarvif->debugfs_twt = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}