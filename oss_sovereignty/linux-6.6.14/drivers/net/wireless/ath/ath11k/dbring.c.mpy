{
  "module_name": "dbring.c",
  "hash_id": "e06c41d0d6d9b68b0a1a8d6214858b3ea61ad6b382da84c012e90ec3bf242418",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath11k/dbring.c",
  "human_readable_source": "\n \n\n#include \"core.h\"\n#include \"debug.h\"\n\n#define ATH11K_DB_MAGIC_VALUE 0xdeadbeaf\n\nint ath11k_dbring_validate_buffer(struct ath11k *ar, void *buffer, u32 size)\n{\n\tu32 *temp;\n\tint idx;\n\n\tsize = size >> 2;\n\n\tfor (idx = 0, temp = buffer; idx < size; idx++, temp++) {\n\t\tif (*temp == ATH11K_DB_MAGIC_VALUE)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void ath11k_dbring_fill_magic_value(struct ath11k *ar,\n\t\t\t\t\t   void *buffer, u32 size)\n{\n\t \n\tsize = size / sizeof(u32);\n\n\tmemset32(buffer, ATH11K_DB_MAGIC_VALUE, size);\n}\n\nstatic int ath11k_dbring_bufs_replenish(struct ath11k *ar,\n\t\t\t\t\tstruct ath11k_dbring *ring,\n\t\t\t\t\tstruct ath11k_dbring_element *buff,\n\t\t\t\t\tenum wmi_direct_buffer_module id)\n{\n\tstruct ath11k_base *ab = ar->ab;\n\tstruct hal_srng *srng;\n\tdma_addr_t paddr;\n\tvoid *ptr_aligned, *ptr_unaligned, *desc;\n\tint ret;\n\tint buf_id;\n\tu32 cookie;\n\n\tsrng = &ab->hal.srng_list[ring->refill_srng.ring_id];\n\n\tlockdep_assert_held(&srng->lock);\n\n\tath11k_hal_srng_access_begin(ab, srng);\n\n\tptr_unaligned = buff->payload;\n\tptr_aligned = PTR_ALIGN(ptr_unaligned, ring->buf_align);\n\tath11k_dbring_fill_magic_value(ar, ptr_aligned, ring->buf_sz);\n\tpaddr = dma_map_single(ab->dev, ptr_aligned, ring->buf_sz,\n\t\t\t       DMA_FROM_DEVICE);\n\n\tret = dma_mapping_error(ab->dev, paddr);\n\tif (ret)\n\t\tgoto err;\n\n\tspin_lock_bh(&ring->idr_lock);\n\tbuf_id = idr_alloc(&ring->bufs_idr, buff, 0, ring->bufs_max, GFP_ATOMIC);\n\tspin_unlock_bh(&ring->idr_lock);\n\tif (buf_id < 0) {\n\t\tret = -ENOBUFS;\n\t\tgoto err_dma_unmap;\n\t}\n\n\tdesc = ath11k_hal_srng_src_get_next_entry(ab, srng);\n\tif (!desc) {\n\t\tret = -ENOENT;\n\t\tgoto err_idr_remove;\n\t}\n\n\tbuff->paddr = paddr;\n\n\tcookie = FIELD_PREP(DP_RXDMA_BUF_COOKIE_PDEV_ID, ar->pdev_idx) |\n\t\t FIELD_PREP(DP_RXDMA_BUF_COOKIE_BUF_ID, buf_id);\n\n\tath11k_hal_rx_buf_addr_info_set(desc, paddr, cookie, 0);\n\n\tath11k_debugfs_add_dbring_entry(ar, id, ATH11K_DBG_DBR_EVENT_REPLENISH, srng);\n\tath11k_hal_srng_access_end(ab, srng);\n\n\treturn 0;\n\nerr_idr_remove:\n\tspin_lock_bh(&ring->idr_lock);\n\tidr_remove(&ring->bufs_idr, buf_id);\n\tspin_unlock_bh(&ring->idr_lock);\nerr_dma_unmap:\n\tdma_unmap_single(ab->dev, paddr, ring->buf_sz,\n\t\t\t DMA_FROM_DEVICE);\nerr:\n\tath11k_hal_srng_access_end(ab, srng);\n\treturn ret;\n}\n\nstatic int ath11k_dbring_fill_bufs(struct ath11k *ar,\n\t\t\t\t   struct ath11k_dbring *ring,\n\t\t\t\t   enum wmi_direct_buffer_module id)\n{\n\tstruct ath11k_dbring_element *buff;\n\tstruct hal_srng *srng;\n\tint num_remain, req_entries, num_free;\n\tu32 align;\n\tint size, ret;\n\n\tsrng = &ar->ab->hal.srng_list[ring->refill_srng.ring_id];\n\n\tspin_lock_bh(&srng->lock);\n\n\tnum_free = ath11k_hal_srng_src_num_free(ar->ab, srng, true);\n\treq_entries = min(num_free, ring->bufs_max);\n\tnum_remain = req_entries;\n\talign = ring->buf_align;\n\tsize = ring->buf_sz + align - 1;\n\n\twhile (num_remain > 0) {\n\t\tbuff = kzalloc(sizeof(*buff), GFP_ATOMIC);\n\t\tif (!buff)\n\t\t\tbreak;\n\n\t\tbuff->payload = kzalloc(size, GFP_ATOMIC);\n\t\tif (!buff->payload) {\n\t\t\tkfree(buff);\n\t\t\tbreak;\n\t\t}\n\t\tret = ath11k_dbring_bufs_replenish(ar, ring, buff, id);\n\t\tif (ret) {\n\t\t\tath11k_warn(ar->ab, \"failed to replenish db ring num_remain %d req_ent %d\\n\",\n\t\t\t\t    num_remain, req_entries);\n\t\t\tkfree(buff->payload);\n\t\t\tkfree(buff);\n\t\t\tbreak;\n\t\t}\n\t\tnum_remain--;\n\t}\n\n\tspin_unlock_bh(&srng->lock);\n\n\treturn num_remain;\n}\n\nint ath11k_dbring_wmi_cfg_setup(struct ath11k *ar,\n\t\t\t\tstruct ath11k_dbring *ring,\n\t\t\t\tenum wmi_direct_buffer_module id)\n{\n\tstruct ath11k_wmi_pdev_dma_ring_cfg_req_cmd param = {0};\n\tint ret;\n\n\tif (id >= WMI_DIRECT_BUF_MAX)\n\t\treturn -EINVAL;\n\n\tparam.pdev_id\t\t= DP_SW2HW_MACID(ring->pdev_id);\n\tparam.module_id\t\t= id;\n\tparam.base_paddr_lo\t= lower_32_bits(ring->refill_srng.paddr);\n\tparam.base_paddr_hi\t= upper_32_bits(ring->refill_srng.paddr);\n\tparam.head_idx_paddr_lo\t= lower_32_bits(ring->hp_addr);\n\tparam.head_idx_paddr_hi = upper_32_bits(ring->hp_addr);\n\tparam.tail_idx_paddr_lo = lower_32_bits(ring->tp_addr);\n\tparam.tail_idx_paddr_hi = upper_32_bits(ring->tp_addr);\n\tparam.num_elems\t\t= ring->bufs_max;\n\tparam.buf_size\t\t= ring->buf_sz;\n\tparam.num_resp_per_event = ring->num_resp_per_event;\n\tparam.event_timeout_ms\t= ring->event_timeout_ms;\n\n\tret = ath11k_wmi_pdev_dma_ring_cfg(ar, &param);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to setup db ring cfg\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint ath11k_dbring_set_cfg(struct ath11k *ar, struct ath11k_dbring *ring,\n\t\t\t  u32 num_resp_per_event, u32 event_timeout_ms,\n\t\t\t  int (*handler)(struct ath11k *,\n\t\t\t\t\t struct ath11k_dbring_data *))\n{\n\tif (WARN_ON(!ring))\n\t\treturn -EINVAL;\n\n\tring->num_resp_per_event = num_resp_per_event;\n\tring->event_timeout_ms = event_timeout_ms;\n\tring->handler = handler;\n\n\treturn 0;\n}\n\nint ath11k_dbring_buf_setup(struct ath11k *ar,\n\t\t\t    struct ath11k_dbring *ring,\n\t\t\t    struct ath11k_dbring_cap *db_cap)\n{\n\tstruct ath11k_base *ab = ar->ab;\n\tstruct hal_srng *srng;\n\tint ret;\n\n\tsrng = &ab->hal.srng_list[ring->refill_srng.ring_id];\n\tring->bufs_max = ring->refill_srng.size /\n\t\tath11k_hal_srng_get_entrysize(ab, HAL_RXDMA_DIR_BUF);\n\n\tring->buf_sz = db_cap->min_buf_sz;\n\tring->buf_align = db_cap->min_buf_align;\n\tring->pdev_id = db_cap->pdev_id;\n\tring->hp_addr = ath11k_hal_srng_get_hp_addr(ar->ab, srng);\n\tring->tp_addr = ath11k_hal_srng_get_tp_addr(ar->ab, srng);\n\n\tret = ath11k_dbring_fill_bufs(ar, ring, db_cap->id);\n\n\treturn ret;\n}\n\nint ath11k_dbring_srng_setup(struct ath11k *ar, struct ath11k_dbring *ring,\n\t\t\t     int ring_num, int num_entries)\n{\n\tint ret;\n\n\tret = ath11k_dp_srng_setup(ar->ab, &ring->refill_srng, HAL_RXDMA_DIR_BUF,\n\t\t\t\t   ring_num, ar->pdev_idx, num_entries);\n\tif (ret < 0) {\n\t\tath11k_warn(ar->ab, \"failed to setup srng: %d ring_id %d\\n\",\n\t\t\t    ret, ring_num);\n\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tath11k_dp_srng_cleanup(ar->ab, &ring->refill_srng);\n\treturn ret;\n}\n\nint ath11k_dbring_get_cap(struct ath11k_base *ab,\n\t\t\t  u8 pdev_idx,\n\t\t\t  enum wmi_direct_buffer_module id,\n\t\t\t  struct ath11k_dbring_cap *db_cap)\n{\n\tint i;\n\n\tif (!ab->num_db_cap || !ab->db_caps)\n\t\treturn -ENOENT;\n\n\tif (id >= WMI_DIRECT_BUF_MAX)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ab->num_db_cap; i++) {\n\t\tif (pdev_idx == ab->db_caps[i].pdev_id &&\n\t\t    id == ab->db_caps[i].id) {\n\t\t\t*db_cap = ab->db_caps[i];\n\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ENOENT;\n}\n\nint ath11k_dbring_buffer_release_event(struct ath11k_base *ab,\n\t\t\t\t       struct ath11k_dbring_buf_release_event *ev)\n{\n\tstruct ath11k_dbring *ring;\n\tstruct hal_srng *srng;\n\tstruct ath11k *ar;\n\tstruct ath11k_dbring_element *buff;\n\tstruct ath11k_dbring_data handler_data;\n\tstruct ath11k_buffer_addr desc;\n\tu8 *vaddr_unalign;\n\tu32 num_entry, num_buff_reaped;\n\tu8 pdev_idx, rbm, module_id;\n\tu32 cookie;\n\tint buf_id;\n\tint size;\n\tdma_addr_t paddr;\n\tint ret = 0;\n\n\tpdev_idx = ev->fixed.pdev_id;\n\tmodule_id = ev->fixed.module_id;\n\n\tif (pdev_idx >= ab->num_radios) {\n\t\tath11k_warn(ab, \"Invalid pdev id %d\\n\", pdev_idx);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ev->fixed.num_buf_release_entry !=\n\t    ev->fixed.num_meta_data_entry) {\n\t\tath11k_warn(ab, \"Buffer entry %d mismatch meta entry %d\\n\",\n\t\t\t    ev->fixed.num_buf_release_entry,\n\t\t\t    ev->fixed.num_meta_data_entry);\n\t\treturn -EINVAL;\n\t}\n\n\tar = ab->pdevs[pdev_idx].ar;\n\n\trcu_read_lock();\n\tif (!rcu_dereference(ab->pdevs_active[pdev_idx])) {\n\t\tret = -EINVAL;\n\t\tgoto rcu_unlock;\n\t}\n\n\tswitch (ev->fixed.module_id) {\n\tcase WMI_DIRECT_BUF_SPECTRAL:\n\t\tring = ath11k_spectral_get_dbring(ar);\n\t\tbreak;\n\tdefault:\n\t\tring = NULL;\n\t\tath11k_warn(ab, \"Recv dma buffer release ev on unsupp module %d\\n\",\n\t\t\t    ev->fixed.module_id);\n\t\tbreak;\n\t}\n\n\tif (!ring) {\n\t\tret = -EINVAL;\n\t\tgoto rcu_unlock;\n\t}\n\n\tsrng = &ab->hal.srng_list[ring->refill_srng.ring_id];\n\tnum_entry = ev->fixed.num_buf_release_entry;\n\tsize = ring->buf_sz + ring->buf_align - 1;\n\tnum_buff_reaped = 0;\n\n\tspin_lock_bh(&srng->lock);\n\n\twhile (num_buff_reaped < num_entry) {\n\t\tdesc.info0 = ev->buf_entry[num_buff_reaped].paddr_lo;\n\t\tdesc.info1 = ev->buf_entry[num_buff_reaped].paddr_hi;\n\t\thandler_data.meta = ev->meta_data[num_buff_reaped];\n\n\t\tnum_buff_reaped++;\n\n\t\tath11k_hal_rx_buf_addr_info_get(&desc, &paddr, &cookie, &rbm);\n\n\t\tbuf_id = FIELD_GET(DP_RXDMA_BUF_COOKIE_BUF_ID, cookie);\n\n\t\tspin_lock_bh(&ring->idr_lock);\n\t\tbuff = idr_find(&ring->bufs_idr, buf_id);\n\t\tif (!buff) {\n\t\t\tspin_unlock_bh(&ring->idr_lock);\n\t\t\tcontinue;\n\t\t}\n\t\tidr_remove(&ring->bufs_idr, buf_id);\n\t\tspin_unlock_bh(&ring->idr_lock);\n\n\t\tdma_unmap_single(ab->dev, buff->paddr, ring->buf_sz,\n\t\t\t\t DMA_FROM_DEVICE);\n\n\t\tath11k_debugfs_add_dbring_entry(ar, module_id,\n\t\t\t\t\t\tATH11K_DBG_DBR_EVENT_RX, srng);\n\n\t\tif (ring->handler) {\n\t\t\tvaddr_unalign = buff->payload;\n\t\t\thandler_data.data = PTR_ALIGN(vaddr_unalign,\n\t\t\t\t\t\t      ring->buf_align);\n\t\t\thandler_data.data_sz = ring->buf_sz;\n\n\t\t\tring->handler(ar, &handler_data);\n\t\t}\n\n\t\tbuff->paddr = 0;\n\t\tmemset(buff->payload, 0, size);\n\t\tath11k_dbring_bufs_replenish(ar, ring, buff, module_id);\n\t}\n\n\tspin_unlock_bh(&srng->lock);\n\nrcu_unlock:\n\trcu_read_unlock();\n\n\treturn ret;\n}\n\nvoid ath11k_dbring_srng_cleanup(struct ath11k *ar, struct ath11k_dbring *ring)\n{\n\tath11k_dp_srng_cleanup(ar->ab, &ring->refill_srng);\n}\n\nvoid ath11k_dbring_buf_cleanup(struct ath11k *ar, struct ath11k_dbring *ring)\n{\n\tstruct ath11k_dbring_element *buff;\n\tint buf_id;\n\n\tspin_lock_bh(&ring->idr_lock);\n\tidr_for_each_entry(&ring->bufs_idr, buff, buf_id) {\n\t\tidr_remove(&ring->bufs_idr, buf_id);\n\t\tdma_unmap_single(ar->ab->dev, buff->paddr,\n\t\t\t\t ring->buf_sz, DMA_FROM_DEVICE);\n\t\tkfree(buff->payload);\n\t\tkfree(buff);\n\t}\n\n\tidr_destroy(&ring->bufs_idr);\n\tspin_unlock_bh(&ring->idr_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}