{
  "module_name": "core.c",
  "hash_id": "1206c5cee1f6d346c04d57b7a5e9367051dcc9092ea468f3cefe7e55775eac07",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath11k/core.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/remoteproc.h>\n#include <linux/firmware.h>\n#include <linux/of.h>\n\n#include \"core.h\"\n#include \"dp_tx.h\"\n#include \"dp_rx.h\"\n#include \"debug.h\"\n#include \"hif.h\"\n#include \"wow.h\"\n\nunsigned int ath11k_debug_mask;\nEXPORT_SYMBOL(ath11k_debug_mask);\nmodule_param_named(debug_mask, ath11k_debug_mask, uint, 0644);\nMODULE_PARM_DESC(debug_mask, \"Debugging mask\");\n\nstatic unsigned int ath11k_crypto_mode;\nmodule_param_named(crypto_mode, ath11k_crypto_mode, uint, 0644);\nMODULE_PARM_DESC(crypto_mode, \"crypto mode: 0-hardware, 1-software\");\n\n \nunsigned int ath11k_frame_mode = ATH11K_HW_TXRX_NATIVE_WIFI;\nmodule_param_named(frame_mode, ath11k_frame_mode, uint, 0644);\nMODULE_PARM_DESC(frame_mode,\n\t\t \"Datapath frame mode (0: raw, 1: native wifi (default), 2: ethernet)\");\n\nbool ath11k_ftm_mode;\nmodule_param_named(ftm_mode, ath11k_ftm_mode, bool, 0444);\nMODULE_PARM_DESC(ftm_mode, \"Boots up in factory test mode\");\n\nstatic const struct ath11k_hw_params ath11k_hw_params[] = {\n\t{\n\t\t.hw_rev = ATH11K_HW_IPQ8074,\n\t\t.name = \"ipq8074 hw2.0\",\n\t\t.fw = {\n\t\t\t.dir = \"IPQ8074/hw2.0\",\n\t\t\t.board_size = 256 * 1024,\n\t\t\t.cal_offset = 128 * 1024,\n\t\t},\n\t\t.max_radios = 3,\n\t\t.bdf_addr = 0x4B0C0000,\n\t\t.hw_ops = &ipq8074_ops,\n\t\t.ring_mask = &ath11k_hw_ring_mask_ipq8074,\n\t\t.internal_sleep_clock = false,\n\t\t.regs = &ipq8074_regs,\n\t\t.qmi_service_ins_id = ATH11K_QMI_WLFW_SERVICE_INS_ID_V01_IPQ8074,\n\t\t.host_ce_config = ath11k_host_ce_config_ipq8074,\n\t\t.ce_count = 12,\n\t\t.target_ce_config = ath11k_target_ce_config_wlan_ipq8074,\n\t\t.target_ce_count = 11,\n\t\t.svc_to_ce_map = ath11k_target_service_to_ce_map_wlan_ipq8074,\n\t\t.svc_to_ce_map_len = 21,\n\t\t.ce_ie_addr = &ath11k_ce_ie_addr_ipq8074,\n\t\t.single_pdev_only = false,\n\t\t.rxdma1_enable = true,\n\t\t.num_rxmda_per_pdev = 1,\n\t\t.rx_mac_buf_ring = false,\n\t\t.vdev_start_delay = false,\n\t\t.htt_peer_map_v2 = true,\n\n\t\t.spectral = {\n\t\t\t.fft_sz = 2,\n\t\t\t \n\t\t\t.fft_pad_sz = 2,\n\t\t\t.summary_pad_sz = 0,\n\t\t\t.fft_hdr_len = 16,\n\t\t\t.max_fft_bins = 512,\n\t\t\t.fragment_160mhz = true,\n\t\t},\n\n\t\t.interface_modes = BIT(NL80211_IFTYPE_STATION) |\n\t\t\t\t\tBIT(NL80211_IFTYPE_AP) |\n\t\t\t\t\tBIT(NL80211_IFTYPE_MESH_POINT),\n\t\t.supports_monitor = true,\n\t\t.full_monitor_mode = false,\n\t\t.supports_shadow_regs = false,\n\t\t.idle_ps = false,\n\t\t.supports_sta_ps = false,\n\t\t.coldboot_cal_mm = true,\n\t\t.coldboot_cal_ftm = true,\n\t\t.cbcal_restart_fw = true,\n\t\t.fw_mem_mode = 0,\n\t\t.num_vdevs = 16 + 1,\n\t\t.num_peers = 512,\n\t\t.supports_suspend = false,\n\t\t.hal_desc_sz = sizeof(struct hal_rx_desc_ipq8074),\n\t\t.supports_regdb = false,\n\t\t.fix_l1ss = true,\n\t\t.credit_flow = false,\n\t\t.max_tx_ring = DP_TCL_NUM_RING_MAX,\n\t\t.hal_params = &ath11k_hw_hal_params_ipq8074,\n\t\t.supports_dynamic_smps_6ghz = false,\n\t\t.alloc_cacheable_memory = true,\n\t\t.supports_rssi_stats = false,\n\t\t.fw_wmi_diag_event = false,\n\t\t.current_cc_support = false,\n\t\t.dbr_debug_support = true,\n\t\t.global_reset = false,\n\t\t.bios_sar_capa = NULL,\n\t\t.m3_fw_support = false,\n\t\t.fixed_bdf_addr = true,\n\t\t.fixed_mem_region = true,\n\t\t.static_window_map = false,\n\t\t.hybrid_bus_type = false,\n\t\t.fixed_fw_mem = false,\n\t\t.support_off_channel_tx = false,\n\t\t.supports_multi_bssid = false,\n\n\t\t.sram_dump = {},\n\n\t\t.tcl_ring_retry = true,\n\t\t.tx_ring_size = DP_TCL_DATA_RING_SIZE,\n\t\t.smp2p_wow_exit = false,\n\t},\n\t{\n\t\t.hw_rev = ATH11K_HW_IPQ6018_HW10,\n\t\t.name = \"ipq6018 hw1.0\",\n\t\t.fw = {\n\t\t\t.dir = \"IPQ6018/hw1.0\",\n\t\t\t.board_size = 256 * 1024,\n\t\t\t.cal_offset = 128 * 1024,\n\t\t},\n\t\t.max_radios = 2,\n\t\t.bdf_addr = 0x4ABC0000,\n\t\t.hw_ops = &ipq6018_ops,\n\t\t.ring_mask = &ath11k_hw_ring_mask_ipq8074,\n\t\t.internal_sleep_clock = false,\n\t\t.regs = &ipq8074_regs,\n\t\t.qmi_service_ins_id = ATH11K_QMI_WLFW_SERVICE_INS_ID_V01_IPQ8074,\n\t\t.host_ce_config = ath11k_host_ce_config_ipq8074,\n\t\t.ce_count = 12,\n\t\t.target_ce_config = ath11k_target_ce_config_wlan_ipq8074,\n\t\t.target_ce_count = 11,\n\t\t.svc_to_ce_map = ath11k_target_service_to_ce_map_wlan_ipq6018,\n\t\t.svc_to_ce_map_len = 19,\n\t\t.ce_ie_addr = &ath11k_ce_ie_addr_ipq8074,\n\t\t.single_pdev_only = false,\n\t\t.rxdma1_enable = true,\n\t\t.num_rxmda_per_pdev = 1,\n\t\t.rx_mac_buf_ring = false,\n\t\t.vdev_start_delay = false,\n\t\t.htt_peer_map_v2 = true,\n\n\t\t.spectral = {\n\t\t\t.fft_sz = 4,\n\t\t\t.fft_pad_sz = 0,\n\t\t\t.summary_pad_sz = 0,\n\t\t\t.fft_hdr_len = 16,\n\t\t\t.max_fft_bins = 512,\n\t\t\t.fragment_160mhz = true,\n\t\t},\n\n\t\t.interface_modes = BIT(NL80211_IFTYPE_STATION) |\n\t\t\t\t\tBIT(NL80211_IFTYPE_AP) |\n\t\t\t\t\tBIT(NL80211_IFTYPE_MESH_POINT),\n\t\t.supports_monitor = true,\n\t\t.full_monitor_mode = false,\n\t\t.supports_shadow_regs = false,\n\t\t.idle_ps = false,\n\t\t.supports_sta_ps = false,\n\t\t.coldboot_cal_mm = true,\n\t\t.coldboot_cal_ftm = true,\n\t\t.cbcal_restart_fw = true,\n\t\t.fw_mem_mode = 0,\n\t\t.num_vdevs = 16 + 1,\n\t\t.num_peers = 512,\n\t\t.supports_suspend = false,\n\t\t.hal_desc_sz = sizeof(struct hal_rx_desc_ipq8074),\n\t\t.supports_regdb = false,\n\t\t.fix_l1ss = true,\n\t\t.credit_flow = false,\n\t\t.max_tx_ring = DP_TCL_NUM_RING_MAX,\n\t\t.hal_params = &ath11k_hw_hal_params_ipq8074,\n\t\t.supports_dynamic_smps_6ghz = false,\n\t\t.alloc_cacheable_memory = true,\n\t\t.supports_rssi_stats = false,\n\t\t.fw_wmi_diag_event = false,\n\t\t.current_cc_support = false,\n\t\t.dbr_debug_support = true,\n\t\t.global_reset = false,\n\t\t.bios_sar_capa = NULL,\n\t\t.m3_fw_support = false,\n\t\t.fixed_bdf_addr = true,\n\t\t.fixed_mem_region = true,\n\t\t.static_window_map = false,\n\t\t.hybrid_bus_type = false,\n\t\t.fixed_fw_mem = false,\n\t\t.support_off_channel_tx = false,\n\t\t.supports_multi_bssid = false,\n\n\t\t.sram_dump = {},\n\n\t\t.tcl_ring_retry = true,\n\t\t.tx_ring_size = DP_TCL_DATA_RING_SIZE,\n\t\t.smp2p_wow_exit = false,\n\t\t.support_fw_mac_sequence = false,\n\t},\n\t{\n\t\t.name = \"qca6390 hw2.0\",\n\t\t.hw_rev = ATH11K_HW_QCA6390_HW20,\n\t\t.fw = {\n\t\t\t.dir = \"QCA6390/hw2.0\",\n\t\t\t.board_size = 256 * 1024,\n\t\t\t.cal_offset = 128 * 1024,\n\t\t},\n\t\t.max_radios = 3,\n\t\t.bdf_addr = 0x4B0C0000,\n\t\t.hw_ops = &qca6390_ops,\n\t\t.ring_mask = &ath11k_hw_ring_mask_qca6390,\n\t\t.internal_sleep_clock = true,\n\t\t.regs = &qca6390_regs,\n\t\t.qmi_service_ins_id = ATH11K_QMI_WLFW_SERVICE_INS_ID_V01_QCA6390,\n\t\t.host_ce_config = ath11k_host_ce_config_qca6390,\n\t\t.ce_count = 9,\n\t\t.target_ce_config = ath11k_target_ce_config_wlan_qca6390,\n\t\t.target_ce_count = 9,\n\t\t.svc_to_ce_map = ath11k_target_service_to_ce_map_wlan_qca6390,\n\t\t.svc_to_ce_map_len = 14,\n\t\t.ce_ie_addr = &ath11k_ce_ie_addr_ipq8074,\n\t\t.single_pdev_only = true,\n\t\t.rxdma1_enable = false,\n\t\t.num_rxmda_per_pdev = 2,\n\t\t.rx_mac_buf_ring = true,\n\t\t.vdev_start_delay = true,\n\t\t.htt_peer_map_v2 = false,\n\n\t\t.spectral = {\n\t\t\t.fft_sz = 0,\n\t\t\t.fft_pad_sz = 0,\n\t\t\t.summary_pad_sz = 0,\n\t\t\t.fft_hdr_len = 0,\n\t\t\t.max_fft_bins = 0,\n\t\t\t.fragment_160mhz = false,\n\t\t},\n\n\t\t.interface_modes = BIT(NL80211_IFTYPE_STATION) |\n\t\t\t\t\tBIT(NL80211_IFTYPE_AP),\n\t\t.supports_monitor = false,\n\t\t.full_monitor_mode = false,\n\t\t.supports_shadow_regs = true,\n\t\t.idle_ps = true,\n\t\t.supports_sta_ps = true,\n\t\t.coldboot_cal_mm = false,\n\t\t.coldboot_cal_ftm = false,\n\t\t.cbcal_restart_fw = false,\n\t\t.fw_mem_mode = 0,\n\t\t.num_vdevs = 16 + 1,\n\t\t.num_peers = 512,\n\t\t.supports_suspend = true,\n\t\t.hal_desc_sz = sizeof(struct hal_rx_desc_ipq8074),\n\t\t.supports_regdb = false,\n\t\t.fix_l1ss = true,\n\t\t.credit_flow = true,\n\t\t.max_tx_ring = DP_TCL_NUM_RING_MAX_QCA6390,\n\t\t.hal_params = &ath11k_hw_hal_params_qca6390,\n\t\t.supports_dynamic_smps_6ghz = false,\n\t\t.alloc_cacheable_memory = false,\n\t\t.supports_rssi_stats = true,\n\t\t.fw_wmi_diag_event = true,\n\t\t.current_cc_support = true,\n\t\t.dbr_debug_support = false,\n\t\t.global_reset = true,\n\t\t.bios_sar_capa = NULL,\n\t\t.m3_fw_support = true,\n\t\t.fixed_bdf_addr = false,\n\t\t.fixed_mem_region = false,\n\t\t.static_window_map = false,\n\t\t.hybrid_bus_type = false,\n\t\t.fixed_fw_mem = false,\n\t\t.support_off_channel_tx = true,\n\t\t.supports_multi_bssid = true,\n\n\t\t.sram_dump = {\n\t\t\t.start = 0x01400000,\n\t\t\t.end = 0x0171ffff,\n\t\t},\n\n\t\t.tcl_ring_retry = true,\n\t\t.tx_ring_size = DP_TCL_DATA_RING_SIZE,\n\t\t.smp2p_wow_exit = false,\n\t\t.support_fw_mac_sequence = true,\n\t},\n\t{\n\t\t.name = \"qcn9074 hw1.0\",\n\t\t.hw_rev = ATH11K_HW_QCN9074_HW10,\n\t\t.fw = {\n\t\t\t.dir = \"QCN9074/hw1.0\",\n\t\t\t.board_size = 256 * 1024,\n\t\t\t.cal_offset = 128 * 1024,\n\t\t},\n\t\t.max_radios = 1,\n\t\t.single_pdev_only = false,\n\t\t.qmi_service_ins_id = ATH11K_QMI_WLFW_SERVICE_INS_ID_V01_QCN9074,\n\t\t.hw_ops = &qcn9074_ops,\n\t\t.ring_mask = &ath11k_hw_ring_mask_qcn9074,\n\t\t.internal_sleep_clock = false,\n\t\t.regs = &qcn9074_regs,\n\t\t.host_ce_config = ath11k_host_ce_config_qcn9074,\n\t\t.ce_count = 6,\n\t\t.target_ce_config = ath11k_target_ce_config_wlan_qcn9074,\n\t\t.target_ce_count = 9,\n\t\t.svc_to_ce_map = ath11k_target_service_to_ce_map_wlan_qcn9074,\n\t\t.svc_to_ce_map_len = 18,\n\t\t.ce_ie_addr = &ath11k_ce_ie_addr_ipq8074,\n\t\t.rxdma1_enable = true,\n\t\t.num_rxmda_per_pdev = 1,\n\t\t.rx_mac_buf_ring = false,\n\t\t.vdev_start_delay = false,\n\t\t.htt_peer_map_v2 = true,\n\n\t\t.spectral = {\n\t\t\t.fft_sz = 2,\n\t\t\t.fft_pad_sz = 0,\n\t\t\t.summary_pad_sz = 16,\n\t\t\t.fft_hdr_len = 24,\n\t\t\t.max_fft_bins = 1024,\n\t\t\t.fragment_160mhz = false,\n\t\t},\n\n\t\t.interface_modes = BIT(NL80211_IFTYPE_STATION) |\n\t\t\t\t\tBIT(NL80211_IFTYPE_AP) |\n\t\t\t\t\tBIT(NL80211_IFTYPE_MESH_POINT),\n\t\t.supports_monitor = true,\n\t\t.full_monitor_mode = true,\n\t\t.supports_shadow_regs = false,\n\t\t.idle_ps = false,\n\t\t.supports_sta_ps = false,\n\t\t.coldboot_cal_mm = false,\n\t\t.coldboot_cal_ftm = true,\n\t\t.cbcal_restart_fw = true,\n\t\t.fw_mem_mode = 2,\n\t\t.num_vdevs = 8,\n\t\t.num_peers = 128,\n\t\t.supports_suspend = false,\n\t\t.hal_desc_sz = sizeof(struct hal_rx_desc_qcn9074),\n\t\t.supports_regdb = false,\n\t\t.fix_l1ss = true,\n\t\t.credit_flow = false,\n\t\t.max_tx_ring = DP_TCL_NUM_RING_MAX,\n\t\t.hal_params = &ath11k_hw_hal_params_ipq8074,\n\t\t.supports_dynamic_smps_6ghz = true,\n\t\t.alloc_cacheable_memory = true,\n\t\t.supports_rssi_stats = false,\n\t\t.fw_wmi_diag_event = false,\n\t\t.current_cc_support = false,\n\t\t.dbr_debug_support = true,\n\t\t.global_reset = false,\n\t\t.bios_sar_capa = NULL,\n\t\t.m3_fw_support = true,\n\t\t.fixed_bdf_addr = false,\n\t\t.fixed_mem_region = false,\n\t\t.static_window_map = true,\n\t\t.hybrid_bus_type = false,\n\t\t.fixed_fw_mem = false,\n\t\t.support_off_channel_tx = false,\n\t\t.supports_multi_bssid = false,\n\n\t\t.sram_dump = {},\n\n\t\t.tcl_ring_retry = true,\n\t\t.tx_ring_size = DP_TCL_DATA_RING_SIZE,\n\t\t.smp2p_wow_exit = false,\n\t\t.support_fw_mac_sequence = false,\n\t},\n\t{\n\t\t.name = \"wcn6855 hw2.0\",\n\t\t.hw_rev = ATH11K_HW_WCN6855_HW20,\n\t\t.fw = {\n\t\t\t.dir = \"WCN6855/hw2.0\",\n\t\t\t.board_size = 256 * 1024,\n\t\t\t.cal_offset = 128 * 1024,\n\t\t},\n\t\t.max_radios = 3,\n\t\t.bdf_addr = 0x4B0C0000,\n\t\t.hw_ops = &wcn6855_ops,\n\t\t.ring_mask = &ath11k_hw_ring_mask_qca6390,\n\t\t.internal_sleep_clock = true,\n\t\t.regs = &wcn6855_regs,\n\t\t.qmi_service_ins_id = ATH11K_QMI_WLFW_SERVICE_INS_ID_V01_QCA6390,\n\t\t.host_ce_config = ath11k_host_ce_config_qca6390,\n\t\t.ce_count = 9,\n\t\t.target_ce_config = ath11k_target_ce_config_wlan_qca6390,\n\t\t.target_ce_count = 9,\n\t\t.svc_to_ce_map = ath11k_target_service_to_ce_map_wlan_qca6390,\n\t\t.svc_to_ce_map_len = 14,\n\t\t.ce_ie_addr = &ath11k_ce_ie_addr_ipq8074,\n\t\t.single_pdev_only = true,\n\t\t.rxdma1_enable = false,\n\t\t.num_rxmda_per_pdev = 2,\n\t\t.rx_mac_buf_ring = true,\n\t\t.vdev_start_delay = true,\n\t\t.htt_peer_map_v2 = false,\n\n\t\t.spectral = {\n\t\t\t.fft_sz = 0,\n\t\t\t.fft_pad_sz = 0,\n\t\t\t.summary_pad_sz = 0,\n\t\t\t.fft_hdr_len = 0,\n\t\t\t.max_fft_bins = 0,\n\t\t\t.fragment_160mhz = false,\n\t\t},\n\n\t\t.interface_modes = BIT(NL80211_IFTYPE_STATION) |\n\t\t\t\t\tBIT(NL80211_IFTYPE_AP),\n\t\t.supports_monitor = false,\n\t\t.full_monitor_mode = false,\n\t\t.supports_shadow_regs = true,\n\t\t.idle_ps = true,\n\t\t.supports_sta_ps = true,\n\t\t.coldboot_cal_mm = false,\n\t\t.coldboot_cal_ftm = false,\n\t\t.cbcal_restart_fw = false,\n\t\t.fw_mem_mode = 0,\n\t\t.num_vdevs = 16 + 1,\n\t\t.num_peers = 512,\n\t\t.supports_suspend = true,\n\t\t.hal_desc_sz = sizeof(struct hal_rx_desc_wcn6855),\n\t\t.supports_regdb = true,\n\t\t.fix_l1ss = false,\n\t\t.credit_flow = true,\n\t\t.max_tx_ring = DP_TCL_NUM_RING_MAX_QCA6390,\n\t\t.hal_params = &ath11k_hw_hal_params_qca6390,\n\t\t.supports_dynamic_smps_6ghz = false,\n\t\t.alloc_cacheable_memory = false,\n\t\t.supports_rssi_stats = true,\n\t\t.fw_wmi_diag_event = true,\n\t\t.current_cc_support = true,\n\t\t.dbr_debug_support = false,\n\t\t.global_reset = true,\n\t\t.bios_sar_capa = &ath11k_hw_sar_capa_wcn6855,\n\t\t.m3_fw_support = true,\n\t\t.fixed_bdf_addr = false,\n\t\t.fixed_mem_region = false,\n\t\t.static_window_map = false,\n\t\t.hybrid_bus_type = false,\n\t\t.fixed_fw_mem = false,\n\t\t.support_off_channel_tx = true,\n\t\t.supports_multi_bssid = true,\n\n\t\t.sram_dump = {\n\t\t\t.start = 0x01400000,\n\t\t\t.end = 0x0177ffff,\n\t\t},\n\n\t\t.tcl_ring_retry = true,\n\t\t.tx_ring_size = DP_TCL_DATA_RING_SIZE,\n\t\t.smp2p_wow_exit = false,\n\t\t.support_fw_mac_sequence = true,\n\t},\n\t{\n\t\t.name = \"wcn6855 hw2.1\",\n\t\t.hw_rev = ATH11K_HW_WCN6855_HW21,\n\t\t.fw = {\n\t\t\t.dir = \"WCN6855/hw2.1\",\n\t\t\t.board_size = 256 * 1024,\n\t\t\t.cal_offset = 128 * 1024,\n\t\t},\n\t\t.max_radios = 3,\n\t\t.bdf_addr = 0x4B0C0000,\n\t\t.hw_ops = &wcn6855_ops,\n\t\t.ring_mask = &ath11k_hw_ring_mask_qca6390,\n\t\t.internal_sleep_clock = true,\n\t\t.regs = &wcn6855_regs,\n\t\t.qmi_service_ins_id = ATH11K_QMI_WLFW_SERVICE_INS_ID_V01_QCA6390,\n\t\t.host_ce_config = ath11k_host_ce_config_qca6390,\n\t\t.ce_count = 9,\n\t\t.target_ce_config = ath11k_target_ce_config_wlan_qca6390,\n\t\t.target_ce_count = 9,\n\t\t.svc_to_ce_map = ath11k_target_service_to_ce_map_wlan_qca6390,\n\t\t.svc_to_ce_map_len = 14,\n\t\t.single_pdev_only = true,\n\t\t.rxdma1_enable = false,\n\t\t.num_rxmda_per_pdev = 2,\n\t\t.rx_mac_buf_ring = true,\n\t\t.vdev_start_delay = true,\n\t\t.htt_peer_map_v2 = false,\n\n\t\t.spectral = {\n\t\t\t.fft_sz = 0,\n\t\t\t.fft_pad_sz = 0,\n\t\t\t.summary_pad_sz = 0,\n\t\t\t.fft_hdr_len = 0,\n\t\t\t.max_fft_bins = 0,\n\t\t\t.fragment_160mhz = false,\n\t\t},\n\n\t\t.interface_modes = BIT(NL80211_IFTYPE_STATION) |\n\t\t\t\t\tBIT(NL80211_IFTYPE_AP),\n\t\t.supports_monitor = false,\n\t\t.supports_shadow_regs = true,\n\t\t.idle_ps = true,\n\t\t.supports_sta_ps = true,\n\t\t.coldboot_cal_mm = false,\n\t\t.coldboot_cal_ftm = false,\n\t\t.cbcal_restart_fw = false,\n\t\t.fw_mem_mode = 0,\n\t\t.num_vdevs = 16 + 1,\n\t\t.num_peers = 512,\n\t\t.supports_suspend = true,\n\t\t.hal_desc_sz = sizeof(struct hal_rx_desc_wcn6855),\n\t\t.supports_regdb = true,\n\t\t.fix_l1ss = false,\n\t\t.credit_flow = true,\n\t\t.max_tx_ring = DP_TCL_NUM_RING_MAX_QCA6390,\n\t\t.hal_params = &ath11k_hw_hal_params_qca6390,\n\t\t.supports_dynamic_smps_6ghz = false,\n\t\t.alloc_cacheable_memory = false,\n\t\t.supports_rssi_stats = true,\n\t\t.fw_wmi_diag_event = true,\n\t\t.current_cc_support = true,\n\t\t.dbr_debug_support = false,\n\t\t.global_reset = true,\n\t\t.bios_sar_capa = &ath11k_hw_sar_capa_wcn6855,\n\t\t.m3_fw_support = true,\n\t\t.fixed_bdf_addr = false,\n\t\t.fixed_mem_region = false,\n\t\t.static_window_map = false,\n\t\t.hybrid_bus_type = false,\n\t\t.fixed_fw_mem = false,\n\t\t.support_off_channel_tx = true,\n\t\t.supports_multi_bssid = true,\n\n\t\t.sram_dump = {\n\t\t\t.start = 0x01400000,\n\t\t\t.end = 0x0177ffff,\n\t\t},\n\n\t\t.tcl_ring_retry = true,\n\t\t.tx_ring_size = DP_TCL_DATA_RING_SIZE,\n\t\t.smp2p_wow_exit = false,\n\t\t.support_fw_mac_sequence = true,\n\t},\n\t{\n\t\t.name = \"wcn6750 hw1.0\",\n\t\t.hw_rev = ATH11K_HW_WCN6750_HW10,\n\t\t.fw = {\n\t\t\t.dir = \"WCN6750/hw1.0\",\n\t\t\t.board_size = 256 * 1024,\n\t\t\t.cal_offset = 128 * 1024,\n\t\t},\n\t\t.max_radios = 1,\n\t\t.bdf_addr = 0x4B0C0000,\n\t\t.hw_ops = &wcn6750_ops,\n\t\t.ring_mask = &ath11k_hw_ring_mask_wcn6750,\n\t\t.internal_sleep_clock = false,\n\t\t.regs = &wcn6750_regs,\n\t\t.qmi_service_ins_id = ATH11K_QMI_WLFW_SERVICE_INS_ID_V01_WCN6750,\n\t\t.host_ce_config = ath11k_host_ce_config_qca6390,\n\t\t.ce_count = 9,\n\t\t.target_ce_config = ath11k_target_ce_config_wlan_qca6390,\n\t\t.target_ce_count = 9,\n\t\t.svc_to_ce_map = ath11k_target_service_to_ce_map_wlan_qca6390,\n\t\t.svc_to_ce_map_len = 14,\n\t\t.ce_ie_addr = &ath11k_ce_ie_addr_ipq8074,\n\t\t.single_pdev_only = true,\n\t\t.rxdma1_enable = false,\n\t\t.num_rxmda_per_pdev = 1,\n\t\t.rx_mac_buf_ring = true,\n\t\t.vdev_start_delay = true,\n\t\t.htt_peer_map_v2 = false,\n\n\t\t.spectral = {\n\t\t\t.fft_sz = 0,\n\t\t\t.fft_pad_sz = 0,\n\t\t\t.summary_pad_sz = 0,\n\t\t\t.fft_hdr_len = 0,\n\t\t\t.max_fft_bins = 0,\n\t\t\t.fragment_160mhz = false,\n\t\t},\n\n\t\t.interface_modes = BIT(NL80211_IFTYPE_STATION) |\n\t\t\t\t\tBIT(NL80211_IFTYPE_AP),\n\t\t.supports_monitor = false,\n\t\t.supports_shadow_regs = true,\n\t\t.idle_ps = true,\n\t\t.supports_sta_ps = true,\n\t\t.coldboot_cal_mm = true,\n\t\t.coldboot_cal_ftm = true,\n\t\t.cbcal_restart_fw = false,\n\t\t.fw_mem_mode = 0,\n\t\t.num_vdevs = 16 + 1,\n\t\t.num_peers = 512,\n\t\t.supports_suspend = false,\n\t\t.hal_desc_sz = sizeof(struct hal_rx_desc_qcn9074),\n\t\t.supports_regdb = true,\n\t\t.fix_l1ss = false,\n\t\t.credit_flow = true,\n\t\t.max_tx_ring = DP_TCL_NUM_RING_MAX,\n\t\t.hal_params = &ath11k_hw_hal_params_wcn6750,\n\t\t.supports_dynamic_smps_6ghz = false,\n\t\t.alloc_cacheable_memory = false,\n\t\t.supports_rssi_stats = true,\n\t\t.fw_wmi_diag_event = false,\n\t\t.current_cc_support = true,\n\t\t.dbr_debug_support = false,\n\t\t.global_reset = false,\n\t\t.bios_sar_capa = &ath11k_hw_sar_capa_wcn6855,\n\t\t.m3_fw_support = false,\n\t\t.fixed_bdf_addr = false,\n\t\t.fixed_mem_region = false,\n\t\t.static_window_map = true,\n\t\t.hybrid_bus_type = true,\n\t\t.fixed_fw_mem = true,\n\t\t.support_off_channel_tx = true,\n\t\t.supports_multi_bssid = true,\n\n\t\t.sram_dump = {},\n\n\t\t.tcl_ring_retry = false,\n\t\t.tx_ring_size = DP_TCL_DATA_RING_SIZE_WCN6750,\n\t\t.smp2p_wow_exit = true,\n\t\t.support_fw_mac_sequence = true,\n\t},\n\t{\n\t\t.hw_rev = ATH11K_HW_IPQ5018_HW10,\n\t\t.name = \"ipq5018 hw1.0\",\n\t\t.fw = {\n\t\t\t.dir = \"IPQ5018/hw1.0\",\n\t\t\t.board_size = 256 * 1024,\n\t\t\t.cal_offset = 128 * 1024,\n\t\t},\n\t\t.max_radios = MAX_RADIOS_5018,\n\t\t.bdf_addr = 0x4BA00000,\n\t\t \n\t\t.hal_desc_sz = sizeof(struct hal_rx_desc_qcn9074),\n\t\t.qmi_service_ins_id = ATH11K_QMI_WLFW_SERVICE_INS_ID_V01_IPQ8074,\n\t\t.ring_mask = &ath11k_hw_ring_mask_ipq8074,\n\t\t.credit_flow = false,\n\t\t.max_tx_ring = 1,\n\t\t.spectral = {\n\t\t\t.fft_sz = 2,\n\t\t\t.fft_pad_sz = 0,\n\t\t\t.summary_pad_sz = 16,\n\t\t\t.fft_hdr_len = 24,\n\t\t\t.max_fft_bins = 1024,\n\t\t},\n\t\t.internal_sleep_clock = false,\n\t\t.regs = &ipq5018_regs,\n\t\t.hw_ops = &ipq5018_ops,\n\t\t.host_ce_config = ath11k_host_ce_config_qcn9074,\n\t\t.ce_count = CE_CNT_5018,\n\t\t.target_ce_config = ath11k_target_ce_config_wlan_ipq5018,\n\t\t.target_ce_count = TARGET_CE_CNT_5018,\n\t\t.svc_to_ce_map = ath11k_target_service_to_ce_map_wlan_ipq5018,\n\t\t.svc_to_ce_map_len = SVC_CE_MAP_LEN_5018,\n\t\t.ce_ie_addr = &ath11k_ce_ie_addr_ipq5018,\n\t\t.ce_remap = &ath11k_ce_remap_ipq5018,\n\t\t.rxdma1_enable = true,\n\t\t.num_rxmda_per_pdev = RXDMA_PER_PDEV_5018,\n\t\t.rx_mac_buf_ring = false,\n\t\t.vdev_start_delay = false,\n\t\t.htt_peer_map_v2 = true,\n\t\t.interface_modes = BIT(NL80211_IFTYPE_STATION) |\n\t\t\tBIT(NL80211_IFTYPE_AP) |\n\t\t\tBIT(NL80211_IFTYPE_MESH_POINT),\n\t\t.supports_monitor = false,\n\t\t.supports_sta_ps = false,\n\t\t.supports_shadow_regs = false,\n\t\t.fw_mem_mode = 0,\n\t\t.num_vdevs = 16 + 1,\n\t\t.num_peers = 512,\n\t\t.supports_regdb = false,\n\t\t.idle_ps = false,\n\t\t.supports_suspend = false,\n\t\t.hal_params = &ath11k_hw_hal_params_ipq8074,\n\t\t.single_pdev_only = false,\n\t\t.coldboot_cal_mm = true,\n\t\t.coldboot_cal_ftm = true,\n\t\t.cbcal_restart_fw = true,\n\t\t.fix_l1ss = true,\n\t\t.supports_dynamic_smps_6ghz = false,\n\t\t.alloc_cacheable_memory = true,\n\t\t.supports_rssi_stats = false,\n\t\t.fw_wmi_diag_event = false,\n\t\t.current_cc_support = false,\n\t\t.dbr_debug_support = true,\n\t\t.global_reset = false,\n\t\t.bios_sar_capa = NULL,\n\t\t.m3_fw_support = false,\n\t\t.fixed_bdf_addr = true,\n\t\t.fixed_mem_region = true,\n\t\t.static_window_map = false,\n\t\t.hybrid_bus_type = false,\n\t\t.fixed_fw_mem = false,\n\t\t.support_off_channel_tx = false,\n\t\t.supports_multi_bssid = false,\n\n\t\t.sram_dump = {},\n\n\t\t.tcl_ring_retry = true,\n\t\t.tx_ring_size = DP_TCL_DATA_RING_SIZE,\n\t\t.smp2p_wow_exit = false,\n\t\t.support_fw_mac_sequence = false,\n\t},\n};\n\nstatic inline struct ath11k_pdev *ath11k_core_get_single_pdev(struct ath11k_base *ab)\n{\n\tWARN_ON(!ab->hw_params.single_pdev_only);\n\n\treturn &ab->pdevs[0];\n}\n\nvoid ath11k_fw_stats_pdevs_free(struct list_head *head)\n{\n\tstruct ath11k_fw_stats_pdev *i, *tmp;\n\n\tlist_for_each_entry_safe(i, tmp, head, list) {\n\t\tlist_del(&i->list);\n\t\tkfree(i);\n\t}\n}\n\nvoid ath11k_fw_stats_vdevs_free(struct list_head *head)\n{\n\tstruct ath11k_fw_stats_vdev *i, *tmp;\n\n\tlist_for_each_entry_safe(i, tmp, head, list) {\n\t\tlist_del(&i->list);\n\t\tkfree(i);\n\t}\n}\n\nvoid ath11k_fw_stats_bcn_free(struct list_head *head)\n{\n\tstruct ath11k_fw_stats_bcn *i, *tmp;\n\n\tlist_for_each_entry_safe(i, tmp, head, list) {\n\t\tlist_del(&i->list);\n\t\tkfree(i);\n\t}\n}\n\nvoid ath11k_fw_stats_init(struct ath11k *ar)\n{\n\tINIT_LIST_HEAD(&ar->fw_stats.pdevs);\n\tINIT_LIST_HEAD(&ar->fw_stats.vdevs);\n\tINIT_LIST_HEAD(&ar->fw_stats.bcn);\n\n\tinit_completion(&ar->fw_stats_complete);\n}\n\nvoid ath11k_fw_stats_free(struct ath11k_fw_stats *stats)\n{\n\tath11k_fw_stats_pdevs_free(&stats->pdevs);\n\tath11k_fw_stats_vdevs_free(&stats->vdevs);\n\tath11k_fw_stats_bcn_free(&stats->bcn);\n}\n\nbool ath11k_core_coldboot_cal_support(struct ath11k_base *ab)\n{\n\tif (!ath11k_cold_boot_cal)\n\t\treturn false;\n\n\tif (ath11k_ftm_mode)\n\t\treturn ab->hw_params.coldboot_cal_ftm;\n\n\telse\n\t\treturn ab->hw_params.coldboot_cal_mm;\n}\n\nint ath11k_core_suspend(struct ath11k_base *ab)\n{\n\tint ret;\n\tstruct ath11k_pdev *pdev;\n\tstruct ath11k *ar;\n\n\tif (!ab->hw_params.supports_suspend)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tpdev = ath11k_core_get_single_pdev(ab);\n\tar = pdev->ar;\n\tif (!ar || ar->state != ATH11K_STATE_OFF)\n\t\treturn 0;\n\n\tret = ath11k_dp_rx_pktlog_stop(ab, true);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to stop dp rx (and timer) pktlog during suspend: %d\\n\",\n\t\t\t    ret);\n\t\treturn ret;\n\t}\n\n\tret = ath11k_mac_wait_tx_complete(ar);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to wait tx complete: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ath11k_wow_enable(ab);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to enable wow during suspend: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ath11k_dp_rx_pktlog_stop(ab, false);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to stop dp rx pktlog during suspend: %d\\n\",\n\t\t\t    ret);\n\t\treturn ret;\n\t}\n\n\tath11k_ce_stop_shadow_timers(ab);\n\tath11k_dp_stop_shadow_timers(ab);\n\n\tath11k_hif_irq_disable(ab);\n\tath11k_hif_ce_irq_disable(ab);\n\n\tret = ath11k_hif_suspend(ab);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to suspend hif: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ath11k_core_suspend);\n\nint ath11k_core_resume(struct ath11k_base *ab)\n{\n\tint ret;\n\tstruct ath11k_pdev *pdev;\n\tstruct ath11k *ar;\n\n\tif (!ab->hw_params.supports_suspend)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tpdev = ath11k_core_get_single_pdev(ab);\n\tar = pdev->ar;\n\tif (!ar || ar->state != ATH11K_STATE_OFF)\n\t\treturn 0;\n\n\tret = ath11k_hif_resume(ab);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to resume hif during resume: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tath11k_hif_ce_irq_enable(ab);\n\tath11k_hif_irq_enable(ab);\n\n\tret = ath11k_dp_rx_pktlog_start(ab);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to start rx pktlog during resume: %d\\n\",\n\t\t\t    ret);\n\t\treturn ret;\n\t}\n\n\tret = ath11k_wow_wakeup(ab);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to wakeup wow during resume: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ath11k_core_resume);\n\nstatic void ath11k_core_check_cc_code_bdfext(const struct dmi_header *hdr, void *data)\n{\n\tstruct ath11k_base *ab = data;\n\tconst char *magic = ATH11K_SMBIOS_BDF_EXT_MAGIC;\n\tstruct ath11k_smbios_bdf *smbios = (struct ath11k_smbios_bdf *)hdr;\n\tssize_t copied;\n\tsize_t len;\n\tint i;\n\n\tif (ab->qmi.target.bdf_ext[0] != '\\0')\n\t\treturn;\n\n\tif (hdr->type != ATH11K_SMBIOS_BDF_EXT_TYPE)\n\t\treturn;\n\n\tif (hdr->length != ATH11K_SMBIOS_BDF_EXT_LENGTH) {\n\t\tath11k_dbg(ab, ATH11K_DBG_BOOT,\n\t\t\t   \"wrong smbios bdf ext type length (%d).\\n\",\n\t\t\t   hdr->length);\n\t\treturn;\n\t}\n\n\tspin_lock_bh(&ab->base_lock);\n\n\tswitch (smbios->country_code_flag) {\n\tcase ATH11K_SMBIOS_CC_ISO:\n\t\tab->new_alpha2[0] = (smbios->cc_code >> 8) & 0xff;\n\t\tab->new_alpha2[1] = smbios->cc_code & 0xff;\n\t\tath11k_dbg(ab, ATH11K_DBG_BOOT, \"smbios cc_code %c%c\\n\",\n\t\t\t   ab->new_alpha2[0], ab->new_alpha2[1]);\n\t\tbreak;\n\tcase ATH11K_SMBIOS_CC_WW:\n\t\tab->new_alpha2[0] = '0';\n\t\tab->new_alpha2[1] = '0';\n\t\tath11k_dbg(ab, ATH11K_DBG_BOOT, \"smbios worldwide regdomain\\n\");\n\t\tbreak;\n\tdefault:\n\t\tath11k_dbg(ab, ATH11K_DBG_BOOT, \"ignore smbios country code setting %d\\n\",\n\t\t\t   smbios->country_code_flag);\n\t\tbreak;\n\t}\n\n\tspin_unlock_bh(&ab->base_lock);\n\n\tif (!smbios->bdf_enabled) {\n\t\tath11k_dbg(ab, ATH11K_DBG_BOOT, \"bdf variant name not found.\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (memcmp(smbios->bdf_ext, magic, strlen(magic)) != 0) {\n\t\tath11k_dbg(ab, ATH11K_DBG_BOOT,\n\t\t\t   \"bdf variant magic does not match.\\n\");\n\t\treturn;\n\t}\n\n\tlen = min_t(size_t,\n\t\t    strlen(smbios->bdf_ext), sizeof(ab->qmi.target.bdf_ext));\n\tfor (i = 0; i < len; i++) {\n\t\tif (!isascii(smbios->bdf_ext[i]) || !isprint(smbios->bdf_ext[i])) {\n\t\t\tath11k_dbg(ab, ATH11K_DBG_BOOT,\n\t\t\t\t   \"bdf variant name contains non ascii chars.\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tcopied = strscpy(ab->qmi.target.bdf_ext, smbios->bdf_ext + strlen(magic),\n\t\t\t sizeof(ab->qmi.target.bdf_ext));\n\tif (copied < 0) {\n\t\tath11k_dbg(ab, ATH11K_DBG_BOOT,\n\t\t\t   \"bdf variant string is longer than the buffer can accommodate\\n\");\n\t\treturn;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_BOOT,\n\t\t   \"found and validated bdf variant smbios_type 0x%x bdf %s\\n\",\n\t\t   ATH11K_SMBIOS_BDF_EXT_TYPE, ab->qmi.target.bdf_ext);\n}\n\nint ath11k_core_check_smbios(struct ath11k_base *ab)\n{\n\tab->qmi.target.bdf_ext[0] = '\\0';\n\tdmi_walk(ath11k_core_check_cc_code_bdfext, ab);\n\n\tif (ab->qmi.target.bdf_ext[0] == '\\0')\n\t\treturn -ENODATA;\n\n\treturn 0;\n}\n\nint ath11k_core_check_dt(struct ath11k_base *ab)\n{\n\tsize_t max_len = sizeof(ab->qmi.target.bdf_ext);\n\tconst char *variant = NULL;\n\tstruct device_node *node;\n\n\tnode = ab->dev->of_node;\n\tif (!node)\n\t\treturn -ENOENT;\n\n\tof_property_read_string(node, \"qcom,ath11k-calibration-variant\",\n\t\t\t\t&variant);\n\tif (!variant)\n\t\treturn -ENODATA;\n\n\tif (strscpy(ab->qmi.target.bdf_ext, variant, max_len) < 0)\n\t\tath11k_dbg(ab, ATH11K_DBG_BOOT,\n\t\t\t   \"bdf variant string is longer than the buffer can accommodate (variant: %s)\\n\",\n\t\t\t    variant);\n\n\treturn 0;\n}\n\nstatic int __ath11k_core_create_board_name(struct ath11k_base *ab, char *name,\n\t\t\t\t\t   size_t name_len, bool with_variant,\n\t\t\t\t\t   bool bus_type_mode)\n{\n\t \n\tchar variant[9 + ATH11K_QMI_BDF_EXT_STR_LENGTH] = { 0 };\n\n\tif (with_variant && ab->qmi.target.bdf_ext[0] != '\\0')\n\t\tscnprintf(variant, sizeof(variant), \",variant=%s\",\n\t\t\t  ab->qmi.target.bdf_ext);\n\n\tswitch (ab->id.bdf_search) {\n\tcase ATH11K_BDF_SEARCH_BUS_AND_BOARD:\n\t\tif (bus_type_mode)\n\t\t\tscnprintf(name, name_len,\n\t\t\t\t  \"bus=%s\",\n\t\t\t\t  ath11k_bus_str(ab->hif.bus));\n\t\telse\n\t\t\tscnprintf(name, name_len,\n\t\t\t\t  \"bus=%s,vendor=%04x,device=%04x,subsystem-vendor=%04x,subsystem-device=%04x,qmi-chip-id=%d,qmi-board-id=%d%s\",\n\t\t\t\t  ath11k_bus_str(ab->hif.bus),\n\t\t\t\t  ab->id.vendor, ab->id.device,\n\t\t\t\t  ab->id.subsystem_vendor,\n\t\t\t\t  ab->id.subsystem_device,\n\t\t\t\t  ab->qmi.target.chip_id,\n\t\t\t\t  ab->qmi.target.board_id,\n\t\t\t\t  variant);\n\t\tbreak;\n\tdefault:\n\t\tscnprintf(name, name_len,\n\t\t\t  \"bus=%s,qmi-chip-id=%d,qmi-board-id=%d%s\",\n\t\t\t  ath11k_bus_str(ab->hif.bus),\n\t\t\t  ab->qmi.target.chip_id,\n\t\t\t  ab->qmi.target.board_id, variant);\n\t\tbreak;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_BOOT, \"using board name '%s'\\n\", name);\n\n\treturn 0;\n}\n\nstatic int ath11k_core_create_board_name(struct ath11k_base *ab, char *name,\n\t\t\t\t\t size_t name_len)\n{\n\treturn __ath11k_core_create_board_name(ab, name, name_len, true, false);\n}\n\nstatic int ath11k_core_create_fallback_board_name(struct ath11k_base *ab, char *name,\n\t\t\t\t\t\t  size_t name_len)\n{\n\treturn __ath11k_core_create_board_name(ab, name, name_len, false, false);\n}\n\nstatic int ath11k_core_create_bus_type_board_name(struct ath11k_base *ab, char *name,\n\t\t\t\t\t\t  size_t name_len)\n{\n\treturn __ath11k_core_create_board_name(ab, name, name_len, false, true);\n}\n\nconst struct firmware *ath11k_core_firmware_request(struct ath11k_base *ab,\n\t\t\t\t\t\t    const char *file)\n{\n\tconst struct firmware *fw;\n\tchar path[100];\n\tint ret;\n\n\tif (file == NULL)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tath11k_core_create_firmware_path(ab, file, path, sizeof(path));\n\n\tret = firmware_request_nowarn(&fw, path, ab->dev);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tath11k_dbg(ab, ATH11K_DBG_BOOT, \"firmware request %s size %zu\\n\",\n\t\t   path, fw->size);\n\n\treturn fw;\n}\n\nvoid ath11k_core_free_bdf(struct ath11k_base *ab, struct ath11k_board_data *bd)\n{\n\tif (!IS_ERR(bd->fw))\n\t\trelease_firmware(bd->fw);\n\n\tmemset(bd, 0, sizeof(*bd));\n}\n\nstatic int ath11k_core_parse_bd_ie_board(struct ath11k_base *ab,\n\t\t\t\t\t struct ath11k_board_data *bd,\n\t\t\t\t\t const void *buf, size_t buf_len,\n\t\t\t\t\t const char *boardname,\n\t\t\t\t\t int ie_id,\n\t\t\t\t\t int name_id,\n\t\t\t\t\t int data_id)\n{\n\tconst struct ath11k_fw_ie *hdr;\n\tbool name_match_found;\n\tint ret, board_ie_id;\n\tsize_t board_ie_len;\n\tconst void *board_ie_data;\n\n\tname_match_found = false;\n\n\t \n\twhile (buf_len > sizeof(struct ath11k_fw_ie)) {\n\t\thdr = buf;\n\t\tboard_ie_id = le32_to_cpu(hdr->id);\n\t\tboard_ie_len = le32_to_cpu(hdr->len);\n\t\tboard_ie_data = hdr->data;\n\n\t\tbuf_len -= sizeof(*hdr);\n\t\tbuf += sizeof(*hdr);\n\n\t\tif (buf_len < ALIGN(board_ie_len, 4)) {\n\t\t\tath11k_err(ab, \"invalid %s length: %zu < %zu\\n\",\n\t\t\t\t   ath11k_bd_ie_type_str(ie_id),\n\t\t\t\t   buf_len, ALIGN(board_ie_len, 4));\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (board_ie_id == name_id) {\n\t\t\tath11k_dbg_dump(ab, ATH11K_DBG_BOOT, \"board name\", \"\",\n\t\t\t\t\tboard_ie_data, board_ie_len);\n\n\t\t\tif (board_ie_len != strlen(boardname))\n\t\t\t\tgoto next;\n\n\t\t\tret = memcmp(board_ie_data, boardname, strlen(boardname));\n\t\t\tif (ret)\n\t\t\t\tgoto next;\n\n\t\t\tname_match_found = true;\n\t\t\tath11k_dbg(ab, ATH11K_DBG_BOOT,\n\t\t\t\t   \"found match %s for name '%s'\",\n\t\t\t\t   ath11k_bd_ie_type_str(ie_id),\n\t\t\t\t   boardname);\n\t\t} else if (board_ie_id == data_id) {\n\t\t\tif (!name_match_found)\n\t\t\t\t \n\t\t\t\tgoto next;\n\n\t\t\tath11k_dbg(ab, ATH11K_DBG_BOOT,\n\t\t\t\t   \"found %s for '%s'\",\n\t\t\t\t   ath11k_bd_ie_type_str(ie_id),\n\t\t\t\t   boardname);\n\n\t\t\tbd->data = board_ie_data;\n\t\t\tbd->len = board_ie_len;\n\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tath11k_warn(ab, \"unknown %s id found: %d\\n\",\n\t\t\t\t    ath11k_bd_ie_type_str(ie_id),\n\t\t\t\t    board_ie_id);\n\t\t}\nnext:\n\t\t \n\t\tboard_ie_len = ALIGN(board_ie_len, 4);\n\n\t\tbuf_len -= board_ie_len;\n\t\tbuf += board_ie_len;\n\t}\n\n\t \n\tret = -ENOENT;\n\nout:\n\treturn ret;\n}\n\nstatic int ath11k_core_fetch_board_data_api_n(struct ath11k_base *ab,\n\t\t\t\t\t      struct ath11k_board_data *bd,\n\t\t\t\t\t      const char *boardname,\n\t\t\t\t\t      int ie_id_match,\n\t\t\t\t\t      int name_id,\n\t\t\t\t\t      int data_id)\n{\n\tsize_t len, magic_len;\n\tconst u8 *data;\n\tchar *filename, filepath[100];\n\tsize_t ie_len;\n\tstruct ath11k_fw_ie *hdr;\n\tint ret, ie_id;\n\n\tfilename = ATH11K_BOARD_API2_FILE;\n\n\tif (!bd->fw)\n\t\tbd->fw = ath11k_core_firmware_request(ab, filename);\n\n\tif (IS_ERR(bd->fw))\n\t\treturn PTR_ERR(bd->fw);\n\n\tdata = bd->fw->data;\n\tlen = bd->fw->size;\n\n\tath11k_core_create_firmware_path(ab, filename,\n\t\t\t\t\t filepath, sizeof(filepath));\n\n\t \n\tmagic_len = strlen(ATH11K_BOARD_MAGIC) + 1;\n\tif (len < magic_len) {\n\t\tath11k_err(ab, \"failed to find magic value in %s, file too short: %zu\\n\",\n\t\t\t   filepath, len);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (memcmp(data, ATH11K_BOARD_MAGIC, magic_len)) {\n\t\tath11k_err(ab, \"found invalid board magic\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t \n\tmagic_len = ALIGN(magic_len, 4);\n\tif (len < magic_len) {\n\t\tath11k_err(ab, \"failed: %s too small to contain board data, len: %zu\\n\",\n\t\t\t   filepath, len);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tdata += magic_len;\n\tlen -= magic_len;\n\n\twhile (len > sizeof(struct ath11k_fw_ie)) {\n\t\thdr = (struct ath11k_fw_ie *)data;\n\t\tie_id = le32_to_cpu(hdr->id);\n\t\tie_len = le32_to_cpu(hdr->len);\n\n\t\tlen -= sizeof(*hdr);\n\t\tdata = hdr->data;\n\n\t\tif (len < ALIGN(ie_len, 4)) {\n\t\t\tath11k_err(ab, \"invalid length for board ie_id %d ie_len %zu len %zu\\n\",\n\t\t\t\t   ie_id, ie_len, len);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (ie_id == ie_id_match) {\n\t\t\tret = ath11k_core_parse_bd_ie_board(ab, bd, data,\n\t\t\t\t\t\t\t    ie_len,\n\t\t\t\t\t\t\t    boardname,\n\t\t\t\t\t\t\t    ie_id_match,\n\t\t\t\t\t\t\t    name_id,\n\t\t\t\t\t\t\t    data_id);\n\t\t\tif (ret == -ENOENT)\n\t\t\t\t \n\t\t\t\tgoto next;\n\t\t\telse if (ret)\n\t\t\t\t \n\t\t\t\tgoto err;\n\t\t\t \n\t\t\tgoto out;\n\t\t}\nnext:\n\t\t \n\t\tie_len = ALIGN(ie_len, 4);\n\n\t\tlen -= ie_len;\n\t\tdata += ie_len;\n\t}\n\nout:\n\tif (!bd->data || !bd->len) {\n\t\tath11k_dbg(ab, ATH11K_DBG_BOOT,\n\t\t\t   \"failed to fetch %s for %s from %s\\n\",\n\t\t\t   ath11k_bd_ie_type_str(ie_id_match),\n\t\t\t   boardname, filepath);\n\t\tret = -ENODATA;\n\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tath11k_core_free_bdf(ab, bd);\n\treturn ret;\n}\n\nint ath11k_core_fetch_board_data_api_1(struct ath11k_base *ab,\n\t\t\t\t       struct ath11k_board_data *bd,\n\t\t\t\t       const char *name)\n{\n\tbd->fw = ath11k_core_firmware_request(ab, name);\n\n\tif (IS_ERR(bd->fw))\n\t\treturn PTR_ERR(bd->fw);\n\n\tbd->data = bd->fw->data;\n\tbd->len = bd->fw->size;\n\n\treturn 0;\n}\n\n#define BOARD_NAME_SIZE 200\nint ath11k_core_fetch_bdf(struct ath11k_base *ab, struct ath11k_board_data *bd)\n{\n\tchar boardname[BOARD_NAME_SIZE], fallback_boardname[BOARD_NAME_SIZE];\n\tchar *filename, filepath[100];\n\tint ret;\n\n\tfilename = ATH11K_BOARD_API2_FILE;\n\n\tret = ath11k_core_create_board_name(ab, boardname, sizeof(boardname));\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to create board name: %d\", ret);\n\t\treturn ret;\n\t}\n\n\tab->bd_api = 2;\n\tret = ath11k_core_fetch_board_data_api_n(ab, bd, boardname,\n\t\t\t\t\t\t ATH11K_BD_IE_BOARD,\n\t\t\t\t\t\t ATH11K_BD_IE_BOARD_NAME,\n\t\t\t\t\t\t ATH11K_BD_IE_BOARD_DATA);\n\tif (!ret)\n\t\tgoto success;\n\n\tret = ath11k_core_create_fallback_board_name(ab, fallback_boardname,\n\t\t\t\t\t\t     sizeof(fallback_boardname));\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to create fallback board name: %d\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ath11k_core_fetch_board_data_api_n(ab, bd, fallback_boardname,\n\t\t\t\t\t\t ATH11K_BD_IE_BOARD,\n\t\t\t\t\t\t ATH11K_BD_IE_BOARD_NAME,\n\t\t\t\t\t\t ATH11K_BD_IE_BOARD_DATA);\n\tif (!ret)\n\t\tgoto success;\n\n\tab->bd_api = 1;\n\tret = ath11k_core_fetch_board_data_api_1(ab, bd, ATH11K_DEFAULT_BOARD_FILE);\n\tif (ret) {\n\t\tath11k_core_create_firmware_path(ab, filename,\n\t\t\t\t\t\t filepath, sizeof(filepath));\n\t\tath11k_err(ab, \"failed to fetch board data for %s from %s\\n\",\n\t\t\t   boardname, filepath);\n\t\tif (memcmp(boardname, fallback_boardname, strlen(boardname)))\n\t\t\tath11k_err(ab, \"failed to fetch board data for %s from %s\\n\",\n\t\t\t\t   fallback_boardname, filepath);\n\n\t\tath11k_err(ab, \"failed to fetch board.bin from %s\\n\",\n\t\t\t   ab->hw_params.fw.dir);\n\t\treturn ret;\n\t}\n\nsuccess:\n\tath11k_dbg(ab, ATH11K_DBG_BOOT, \"using board api %d\\n\", ab->bd_api);\n\treturn 0;\n}\n\nint ath11k_core_fetch_regdb(struct ath11k_base *ab, struct ath11k_board_data *bd)\n{\n\tchar boardname[BOARD_NAME_SIZE], default_boardname[BOARD_NAME_SIZE];\n\tint ret;\n\n\tret = ath11k_core_create_board_name(ab, boardname, BOARD_NAME_SIZE);\n\tif (ret) {\n\t\tath11k_dbg(ab, ATH11K_DBG_BOOT,\n\t\t\t   \"failed to create board name for regdb: %d\", ret);\n\t\tgoto exit;\n\t}\n\n\tret = ath11k_core_fetch_board_data_api_n(ab, bd, boardname,\n\t\t\t\t\t\t ATH11K_BD_IE_REGDB,\n\t\t\t\t\t\t ATH11K_BD_IE_REGDB_NAME,\n\t\t\t\t\t\t ATH11K_BD_IE_REGDB_DATA);\n\tif (!ret)\n\t\tgoto exit;\n\n\tret = ath11k_core_create_bus_type_board_name(ab, default_boardname,\n\t\t\t\t\t\t     BOARD_NAME_SIZE);\n\tif (ret) {\n\t\tath11k_dbg(ab, ATH11K_DBG_BOOT,\n\t\t\t   \"failed to create default board name for regdb: %d\", ret);\n\t\tgoto exit;\n\t}\n\n\tret = ath11k_core_fetch_board_data_api_n(ab, bd, default_boardname,\n\t\t\t\t\t\t ATH11K_BD_IE_REGDB,\n\t\t\t\t\t\t ATH11K_BD_IE_REGDB_NAME,\n\t\t\t\t\t\t ATH11K_BD_IE_REGDB_DATA);\n\tif (!ret)\n\t\tgoto exit;\n\n\tret = ath11k_core_fetch_board_data_api_1(ab, bd, ATH11K_REGDB_FILE_NAME);\n\tif (ret)\n\t\tath11k_dbg(ab, ATH11K_DBG_BOOT, \"failed to fetch %s from %s\\n\",\n\t\t\t   ATH11K_REGDB_FILE_NAME, ab->hw_params.fw.dir);\n\nexit:\n\tif (!ret)\n\t\tath11k_dbg(ab, ATH11K_DBG_BOOT, \"fetched regdb\\n\");\n\n\treturn ret;\n}\n\nstatic void ath11k_core_stop(struct ath11k_base *ab)\n{\n\tif (!test_bit(ATH11K_FLAG_CRASH_FLUSH, &ab->dev_flags))\n\t\tath11k_qmi_firmware_stop(ab);\n\n\tath11k_hif_stop(ab);\n\tath11k_wmi_detach(ab);\n\tath11k_dp_pdev_reo_cleanup(ab);\n\n\t \n}\n\nstatic int ath11k_core_soc_create(struct ath11k_base *ab)\n{\n\tint ret;\n\n\tif (ath11k_ftm_mode) {\n\t\tab->fw_mode = ATH11K_FIRMWARE_MODE_FTM;\n\t\tath11k_info(ab, \"Booting in factory test mode\\n\");\n\t}\n\n\tret = ath11k_qmi_init_service(ab);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to initialize qmi :%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ath11k_debugfs_soc_create(ab);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to create ath11k debugfs\\n\");\n\t\tgoto err_qmi_deinit;\n\t}\n\n\tret = ath11k_hif_power_up(ab);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to power up :%d\\n\", ret);\n\t\tgoto err_debugfs_reg;\n\t}\n\n\treturn 0;\n\nerr_debugfs_reg:\n\tath11k_debugfs_soc_destroy(ab);\nerr_qmi_deinit:\n\tath11k_qmi_deinit_service(ab);\n\treturn ret;\n}\n\nstatic void ath11k_core_soc_destroy(struct ath11k_base *ab)\n{\n\tath11k_debugfs_soc_destroy(ab);\n\tath11k_dp_free(ab);\n\tath11k_reg_free(ab);\n\tath11k_qmi_deinit_service(ab);\n}\n\nstatic int ath11k_core_pdev_create(struct ath11k_base *ab)\n{\n\tint ret;\n\n\tret = ath11k_debugfs_pdev_create(ab);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to create core pdev debugfs: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ath11k_dp_pdev_alloc(ab);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to attach DP pdev: %d\\n\", ret);\n\t\tgoto err_pdev_debug;\n\t}\n\n\tret = ath11k_mac_register(ab);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed register the radio with mac80211: %d\\n\", ret);\n\t\tgoto err_dp_pdev_free;\n\t}\n\n\tret = ath11k_thermal_register(ab);\n\tif (ret) {\n\t\tath11k_err(ab, \"could not register thermal device: %d\\n\",\n\t\t\t   ret);\n\t\tgoto err_mac_unregister;\n\t}\n\n\tret = ath11k_spectral_init(ab);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to init spectral %d\\n\", ret);\n\t\tgoto err_thermal_unregister;\n\t}\n\n\treturn 0;\n\nerr_thermal_unregister:\n\tath11k_thermal_unregister(ab);\nerr_mac_unregister:\n\tath11k_mac_unregister(ab);\nerr_dp_pdev_free:\n\tath11k_dp_pdev_free(ab);\nerr_pdev_debug:\n\tath11k_debugfs_pdev_destroy(ab);\n\n\treturn ret;\n}\n\nstatic void ath11k_core_pdev_destroy(struct ath11k_base *ab)\n{\n\tath11k_spectral_deinit(ab);\n\tath11k_thermal_unregister(ab);\n\tath11k_mac_unregister(ab);\n\tath11k_hif_irq_disable(ab);\n\tath11k_dp_pdev_free(ab);\n\tath11k_debugfs_pdev_destroy(ab);\n}\n\nstatic int ath11k_core_start(struct ath11k_base *ab)\n{\n\tint ret;\n\n\tret = ath11k_wmi_attach(ab);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to attach wmi: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ath11k_htc_init(ab);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to init htc: %d\\n\", ret);\n\t\tgoto err_wmi_detach;\n\t}\n\n\tret = ath11k_hif_start(ab);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to start HIF: %d\\n\", ret);\n\t\tgoto err_wmi_detach;\n\t}\n\n\tret = ath11k_htc_wait_target(&ab->htc);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to connect to HTC: %d\\n\", ret);\n\t\tgoto err_hif_stop;\n\t}\n\n\tret = ath11k_dp_htt_connect(&ab->dp);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to connect to HTT: %d\\n\", ret);\n\t\tgoto err_hif_stop;\n\t}\n\n\tret = ath11k_wmi_connect(ab);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to connect wmi: %d\\n\", ret);\n\t\tgoto err_hif_stop;\n\t}\n\n\tret = ath11k_htc_start(&ab->htc);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to start HTC: %d\\n\", ret);\n\t\tgoto err_hif_stop;\n\t}\n\n\tret = ath11k_wmi_wait_for_service_ready(ab);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to receive wmi service ready event: %d\\n\",\n\t\t\t   ret);\n\t\tgoto err_hif_stop;\n\t}\n\n\tret = ath11k_mac_allocate(ab);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to create new hw device with mac80211 :%d\\n\",\n\t\t\t   ret);\n\t\tgoto err_hif_stop;\n\t}\n\n\tath11k_dp_pdev_pre_alloc(ab);\n\n\tret = ath11k_dp_pdev_reo_setup(ab);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to initialize reo destination rings: %d\\n\", ret);\n\t\tgoto err_mac_destroy;\n\t}\n\n\tret = ath11k_wmi_cmd_init(ab);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to send wmi init cmd: %d\\n\", ret);\n\t\tgoto err_reo_cleanup;\n\t}\n\n\tret = ath11k_wmi_wait_for_unified_ready(ab);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to receive wmi unified ready event: %d\\n\",\n\t\t\t   ret);\n\t\tgoto err_reo_cleanup;\n\t}\n\n\t \n\tif (ab->hw_params.single_pdev_only && ab->hw_params.num_rxmda_per_pdev > 1) {\n\t\tret = ath11k_wmi_set_hw_mode(ab, WMI_HOST_HW_MODE_DBS);\n\t\tif (ret) {\n\t\t\tath11k_err(ab, \"failed to send dbs mode: %d\\n\", ret);\n\t\t\tgoto err_hif_stop;\n\t\t}\n\t}\n\n\tret = ath11k_dp_tx_htt_h2t_ver_req_msg(ab);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to send htt version request message: %d\\n\",\n\t\t\t   ret);\n\t\tgoto err_reo_cleanup;\n\t}\n\n\treturn 0;\n\nerr_reo_cleanup:\n\tath11k_dp_pdev_reo_cleanup(ab);\nerr_mac_destroy:\n\tath11k_mac_destroy(ab);\nerr_hif_stop:\n\tath11k_hif_stop(ab);\nerr_wmi_detach:\n\tath11k_wmi_detach(ab);\n\n\treturn ret;\n}\n\nstatic int ath11k_core_start_firmware(struct ath11k_base *ab,\n\t\t\t\t      enum ath11k_firmware_mode mode)\n{\n\tint ret;\n\n\tath11k_ce_get_shadow_config(ab, &ab->qmi.ce_cfg.shadow_reg_v2,\n\t\t\t\t    &ab->qmi.ce_cfg.shadow_reg_v2_len);\n\n\tret = ath11k_qmi_firmware_start(ab, mode);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to send firmware start: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nint ath11k_core_qmi_firmware_ready(struct ath11k_base *ab)\n{\n\tint ret;\n\n\tret = ath11k_core_start_firmware(ab, ab->fw_mode);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to start firmware: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ath11k_ce_init_pipes(ab);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to initialize CE: %d\\n\", ret);\n\t\tgoto err_firmware_stop;\n\t}\n\n\tret = ath11k_dp_alloc(ab);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to init DP: %d\\n\", ret);\n\t\tgoto err_firmware_stop;\n\t}\n\n\tswitch (ath11k_crypto_mode) {\n\tcase ATH11K_CRYPT_MODE_SW:\n\t\tset_bit(ATH11K_FLAG_HW_CRYPTO_DISABLED, &ab->dev_flags);\n\t\tset_bit(ATH11K_FLAG_RAW_MODE, &ab->dev_flags);\n\t\tbreak;\n\tcase ATH11K_CRYPT_MODE_HW:\n\t\tclear_bit(ATH11K_FLAG_HW_CRYPTO_DISABLED, &ab->dev_flags);\n\t\tclear_bit(ATH11K_FLAG_RAW_MODE, &ab->dev_flags);\n\t\tbreak;\n\tdefault:\n\t\tath11k_info(ab, \"invalid crypto_mode: %d\\n\", ath11k_crypto_mode);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ath11k_frame_mode == ATH11K_HW_TXRX_RAW)\n\t\tset_bit(ATH11K_FLAG_RAW_MODE, &ab->dev_flags);\n\n\tmutex_lock(&ab->core_lock);\n\tret = ath11k_core_start(ab);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to start core: %d\\n\", ret);\n\t\tgoto err_dp_free;\n\t}\n\n\tret = ath11k_core_pdev_create(ab);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to create pdev core: %d\\n\", ret);\n\t\tgoto err_core_stop;\n\t}\n\tath11k_hif_irq_enable(ab);\n\tmutex_unlock(&ab->core_lock);\n\n\treturn 0;\n\nerr_core_stop:\n\tath11k_core_stop(ab);\n\tath11k_mac_destroy(ab);\nerr_dp_free:\n\tath11k_dp_free(ab);\n\tmutex_unlock(&ab->core_lock);\nerr_firmware_stop:\n\tath11k_qmi_firmware_stop(ab);\n\n\treturn ret;\n}\n\nstatic int ath11k_core_reconfigure_on_crash(struct ath11k_base *ab)\n{\n\tint ret;\n\n\tmutex_lock(&ab->core_lock);\n\tath11k_thermal_unregister(ab);\n\tath11k_hif_irq_disable(ab);\n\tath11k_dp_pdev_free(ab);\n\tath11k_spectral_deinit(ab);\n\tath11k_hif_stop(ab);\n\tath11k_wmi_detach(ab);\n\tath11k_dp_pdev_reo_cleanup(ab);\n\tmutex_unlock(&ab->core_lock);\n\n\tath11k_dp_free(ab);\n\tath11k_hal_srng_deinit(ab);\n\n\tab->free_vdev_map = (1LL << (ab->num_radios * TARGET_NUM_VDEVS(ab))) - 1;\n\n\tret = ath11k_hal_srng_init(ab);\n\tif (ret)\n\t\treturn ret;\n\n\tclear_bit(ATH11K_FLAG_CRASH_FLUSH, &ab->dev_flags);\n\n\tret = ath11k_core_qmi_firmware_ready(ab);\n\tif (ret)\n\t\tgoto err_hal_srng_deinit;\n\n\tclear_bit(ATH11K_FLAG_RECOVERY, &ab->dev_flags);\n\n\treturn 0;\n\nerr_hal_srng_deinit:\n\tath11k_hal_srng_deinit(ab);\n\treturn ret;\n}\n\nvoid ath11k_core_halt(struct ath11k *ar)\n{\n\tstruct ath11k_base *ab = ar->ab;\n\n\tlockdep_assert_held(&ar->conf_mutex);\n\n\tar->num_created_vdevs = 0;\n\tar->allocated_vdev_map = 0;\n\n\tath11k_mac_scan_finish(ar);\n\tath11k_mac_peer_cleanup_all(ar);\n\tcancel_delayed_work_sync(&ar->scan.timeout);\n\tcancel_work_sync(&ar->regd_update_work);\n\tcancel_work_sync(&ab->update_11d_work);\n\n\trcu_assign_pointer(ab->pdevs_active[ar->pdev_idx], NULL);\n\tsynchronize_rcu();\n\tINIT_LIST_HEAD(&ar->arvifs);\n\tidr_init(&ar->txmgmt_idr);\n}\n\nstatic void ath11k_update_11d(struct work_struct *work)\n{\n\tstruct ath11k_base *ab = container_of(work, struct ath11k_base, update_11d_work);\n\tstruct ath11k *ar;\n\tstruct ath11k_pdev *pdev;\n\tstruct wmi_set_current_country_params set_current_param = {};\n\tint ret, i;\n\n\tspin_lock_bh(&ab->base_lock);\n\tmemcpy(&set_current_param.alpha2, &ab->new_alpha2, 2);\n\tspin_unlock_bh(&ab->base_lock);\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI, \"update 11d new cc %c%c\\n\",\n\t\t   set_current_param.alpha2[0],\n\t\t   set_current_param.alpha2[1]);\n\n\tfor (i = 0; i < ab->num_radios; i++) {\n\t\tpdev = &ab->pdevs[i];\n\t\tar = pdev->ar;\n\n\t\tmemcpy(&ar->alpha2, &set_current_param.alpha2, 2);\n\t\tret = ath11k_wmi_send_set_current_country_cmd(ar, &set_current_param);\n\t\tif (ret)\n\t\t\tath11k_warn(ar->ab,\n\t\t\t\t    \"pdev id %d failed set current country code: %d\\n\",\n\t\t\t\t    i, ret);\n\t}\n}\n\nvoid ath11k_core_pre_reconfigure_recovery(struct ath11k_base *ab)\n{\n\tstruct ath11k *ar;\n\tstruct ath11k_pdev *pdev;\n\tint i;\n\n\tspin_lock_bh(&ab->base_lock);\n\tab->stats.fw_crash_counter++;\n\tspin_unlock_bh(&ab->base_lock);\n\n\tfor (i = 0; i < ab->num_radios; i++) {\n\t\tpdev = &ab->pdevs[i];\n\t\tar = pdev->ar;\n\t\tif (!ar || ar->state == ATH11K_STATE_OFF ||\n\t\t    ar->state == ATH11K_STATE_FTM)\n\t\t\tcontinue;\n\n\t\tieee80211_stop_queues(ar->hw);\n\t\tath11k_mac_drain_tx(ar);\n\t\tar->state_11d = ATH11K_11D_IDLE;\n\t\tcomplete(&ar->completed_11d_scan);\n\t\tcomplete(&ar->scan.started);\n\t\tcomplete_all(&ar->scan.completed);\n\t\tcomplete(&ar->scan.on_channel);\n\t\tcomplete(&ar->peer_assoc_done);\n\t\tcomplete(&ar->peer_delete_done);\n\t\tcomplete(&ar->install_key_done);\n\t\tcomplete(&ar->vdev_setup_done);\n\t\tcomplete(&ar->vdev_delete_done);\n\t\tcomplete(&ar->bss_survey_done);\n\t\tcomplete(&ar->thermal.wmi_sync);\n\n\t\twake_up(&ar->dp.tx_empty_waitq);\n\t\tidr_for_each(&ar->txmgmt_idr,\n\t\t\t     ath11k_mac_tx_mgmt_pending_free, ar);\n\t\tidr_destroy(&ar->txmgmt_idr);\n\t\twake_up(&ar->txmgmt_empty_waitq);\n\n\t\tar->monitor_vdev_id = -1;\n\t\tclear_bit(ATH11K_FLAG_MONITOR_STARTED, &ar->monitor_flags);\n\t\tclear_bit(ATH11K_FLAG_MONITOR_VDEV_CREATED, &ar->monitor_flags);\n\t}\n\n\twake_up(&ab->wmi_ab.tx_credits_wq);\n\twake_up(&ab->peer_mapping_wq);\n\n\treinit_completion(&ab->driver_recovery);\n}\n\nstatic void ath11k_core_post_reconfigure_recovery(struct ath11k_base *ab)\n{\n\tstruct ath11k *ar;\n\tstruct ath11k_pdev *pdev;\n\tint i;\n\n\tfor (i = 0; i < ab->num_radios; i++) {\n\t\tpdev = &ab->pdevs[i];\n\t\tar = pdev->ar;\n\t\tif (!ar || ar->state == ATH11K_STATE_OFF)\n\t\t\tcontinue;\n\n\t\tmutex_lock(&ar->conf_mutex);\n\n\t\tswitch (ar->state) {\n\t\tcase ATH11K_STATE_ON:\n\t\t\tar->state = ATH11K_STATE_RESTARTING;\n\t\t\tath11k_core_halt(ar);\n\t\t\tieee80211_restart_hw(ar->hw);\n\t\t\tbreak;\n\t\tcase ATH11K_STATE_OFF:\n\t\t\tath11k_warn(ab,\n\t\t\t\t    \"cannot restart radio %d that hasn't been started\\n\",\n\t\t\t\t    i);\n\t\t\tbreak;\n\t\tcase ATH11K_STATE_RESTARTING:\n\t\t\tbreak;\n\t\tcase ATH11K_STATE_RESTARTED:\n\t\t\tar->state = ATH11K_STATE_WEDGED;\n\t\t\tfallthrough;\n\t\tcase ATH11K_STATE_WEDGED:\n\t\t\tath11k_warn(ab,\n\t\t\t\t    \"device is wedged, will not restart radio %d\\n\", i);\n\t\t\tbreak;\n\t\tcase ATH11K_STATE_FTM:\n\t\t\tath11k_dbg(ab, ATH11K_DBG_TESTMODE,\n\t\t\t\t   \"fw mode reset done radio %d\\n\", i);\n\t\t\tbreak;\n\t\t}\n\n\t\tmutex_unlock(&ar->conf_mutex);\n\t}\n\tcomplete(&ab->driver_recovery);\n}\n\nstatic void ath11k_core_restart(struct work_struct *work)\n{\n\tstruct ath11k_base *ab = container_of(work, struct ath11k_base, restart_work);\n\tint ret;\n\n\tret = ath11k_core_reconfigure_on_crash(ab);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to reconfigure driver on crash recovery\\n\");\n\t\treturn;\n\t}\n\n\tif (ab->is_reset)\n\t\tcomplete_all(&ab->reconfigure_complete);\n\n\tif (!ab->is_reset)\n\t\tath11k_core_post_reconfigure_recovery(ab);\n}\n\nstatic void ath11k_core_reset(struct work_struct *work)\n{\n\tstruct ath11k_base *ab = container_of(work, struct ath11k_base, reset_work);\n\tint reset_count, fail_cont_count;\n\tlong time_left;\n\n\tif (!(test_bit(ATH11K_FLAG_REGISTERED, &ab->dev_flags))) {\n\t\tath11k_warn(ab, \"ignore reset dev flags 0x%lx\\n\", ab->dev_flags);\n\t\treturn;\n\t}\n\n\t \n\tfail_cont_count = atomic_read(&ab->fail_cont_count);\n\n\tif (fail_cont_count >= ATH11K_RESET_MAX_FAIL_COUNT_FINAL)\n\t\treturn;\n\n\tif (fail_cont_count >= ATH11K_RESET_MAX_FAIL_COUNT_FIRST &&\n\t    time_before(jiffies, ab->reset_fail_timeout))\n\t\treturn;\n\n\treset_count = atomic_inc_return(&ab->reset_count);\n\n\tif (reset_count > 1) {\n\t\t \n\t\tath11k_warn(ab, \"already resetting count %d\\n\", reset_count);\n\n\t\treinit_completion(&ab->reset_complete);\n\t\ttime_left = wait_for_completion_timeout(&ab->reset_complete,\n\t\t\t\t\t\t\tATH11K_RESET_TIMEOUT_HZ);\n\n\t\tif (time_left) {\n\t\t\tath11k_dbg(ab, ATH11K_DBG_BOOT, \"to skip reset\\n\");\n\t\t\tatomic_dec(&ab->reset_count);\n\t\t\treturn;\n\t\t}\n\n\t\tab->reset_fail_timeout = jiffies + ATH11K_RESET_FAIL_TIMEOUT_HZ;\n\t\t \n\t\tatomic_inc(&ab->fail_cont_count);\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_BOOT, \"reset starting\\n\");\n\n\tab->is_reset = true;\n\tatomic_set(&ab->recovery_count, 0);\n\treinit_completion(&ab->recovery_start);\n\tatomic_set(&ab->recovery_start_count, 0);\n\n\tath11k_core_pre_reconfigure_recovery(ab);\n\n\treinit_completion(&ab->reconfigure_complete);\n\tath11k_core_post_reconfigure_recovery(ab);\n\n\tath11k_dbg(ab, ATH11K_DBG_BOOT, \"waiting recovery start...\\n\");\n\n\ttime_left = wait_for_completion_timeout(&ab->recovery_start,\n\t\t\t\t\t\tATH11K_RECOVER_START_TIMEOUT_HZ);\n\n\tath11k_hif_power_down(ab);\n\tath11k_hif_power_up(ab);\n\n\tath11k_dbg(ab, ATH11K_DBG_BOOT, \"reset started\\n\");\n}\n\nstatic int ath11k_init_hw_params(struct ath11k_base *ab)\n{\n\tconst struct ath11k_hw_params *hw_params = NULL;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ath11k_hw_params); i++) {\n\t\thw_params = &ath11k_hw_params[i];\n\n\t\tif (hw_params->hw_rev == ab->hw_rev)\n\t\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(ath11k_hw_params)) {\n\t\tath11k_err(ab, \"Unsupported hardware version: 0x%x\\n\", ab->hw_rev);\n\t\treturn -EINVAL;\n\t}\n\n\tab->hw_params = *hw_params;\n\n\tath11k_info(ab, \"%s\\n\", ab->hw_params.name);\n\n\treturn 0;\n}\n\nint ath11k_core_pre_init(struct ath11k_base *ab)\n{\n\tint ret;\n\n\tret = ath11k_init_hw_params(ab);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to get hw params: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ath11k_core_pre_init);\n\nint ath11k_core_init(struct ath11k_base *ab)\n{\n\tint ret;\n\n\tret = ath11k_core_soc_create(ab);\n\tif (ret) {\n\t\tath11k_err(ab, \"failed to create soc core: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ath11k_core_init);\n\nvoid ath11k_core_deinit(struct ath11k_base *ab)\n{\n\tmutex_lock(&ab->core_lock);\n\n\tath11k_core_pdev_destroy(ab);\n\tath11k_core_stop(ab);\n\n\tmutex_unlock(&ab->core_lock);\n\n\tath11k_hif_power_down(ab);\n\tath11k_mac_destroy(ab);\n\tath11k_core_soc_destroy(ab);\n}\nEXPORT_SYMBOL(ath11k_core_deinit);\n\nvoid ath11k_core_free(struct ath11k_base *ab)\n{\n\tdestroy_workqueue(ab->workqueue_aux);\n\tdestroy_workqueue(ab->workqueue);\n\n\tkfree(ab);\n}\nEXPORT_SYMBOL(ath11k_core_free);\n\nstruct ath11k_base *ath11k_core_alloc(struct device *dev, size_t priv_size,\n\t\t\t\t      enum ath11k_bus bus)\n{\n\tstruct ath11k_base *ab;\n\n\tab = kzalloc(sizeof(*ab) + priv_size, GFP_KERNEL);\n\tif (!ab)\n\t\treturn NULL;\n\n\tinit_completion(&ab->driver_recovery);\n\n\tab->workqueue = create_singlethread_workqueue(\"ath11k_wq\");\n\tif (!ab->workqueue)\n\t\tgoto err_sc_free;\n\n\tab->workqueue_aux = create_singlethread_workqueue(\"ath11k_aux_wq\");\n\tif (!ab->workqueue_aux)\n\t\tgoto err_free_wq;\n\n\tmutex_init(&ab->core_lock);\n\tmutex_init(&ab->tbl_mtx_lock);\n\tspin_lock_init(&ab->base_lock);\n\tmutex_init(&ab->vdev_id_11d_lock);\n\tinit_completion(&ab->reset_complete);\n\tinit_completion(&ab->reconfigure_complete);\n\tinit_completion(&ab->recovery_start);\n\n\tINIT_LIST_HEAD(&ab->peers);\n\tinit_waitqueue_head(&ab->peer_mapping_wq);\n\tinit_waitqueue_head(&ab->wmi_ab.tx_credits_wq);\n\tinit_waitqueue_head(&ab->qmi.cold_boot_waitq);\n\tINIT_WORK(&ab->restart_work, ath11k_core_restart);\n\tINIT_WORK(&ab->update_11d_work, ath11k_update_11d);\n\tINIT_WORK(&ab->reset_work, ath11k_core_reset);\n\ttimer_setup(&ab->rx_replenish_retry, ath11k_ce_rx_replenish_retry, 0);\n\tinit_completion(&ab->htc_suspend);\n\tinit_completion(&ab->wow.wakeup_completed);\n\n\tab->dev = dev;\n\tab->hif.bus = bus;\n\n\treturn ab;\n\nerr_free_wq:\n\tdestroy_workqueue(ab->workqueue);\nerr_sc_free:\n\tkfree(ab);\n\treturn NULL;\n}\nEXPORT_SYMBOL(ath11k_core_alloc);\n\nMODULE_DESCRIPTION(\"Core module for Qualcomm Atheros 802.11ax wireless LAN cards.\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}