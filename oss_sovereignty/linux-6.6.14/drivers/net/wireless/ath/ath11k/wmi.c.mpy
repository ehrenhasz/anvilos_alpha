{
  "module_name": "wmi.c",
  "hash_id": "d750254ca11344279cd37e0267ca3957cff42feba5641bfae3f87d3613632c76",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath11k/wmi.c",
  "human_readable_source": "\n \n#include <linux/skbuff.h>\n#include <linux/ctype.h>\n#include <net/mac80211.h>\n#include <net/cfg80211.h>\n#include <linux/completion.h>\n#include <linux/if_ether.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/uuid.h>\n#include <linux/time.h>\n#include <linux/of.h>\n#include \"core.h\"\n#include \"debug.h\"\n#include \"mac.h\"\n#include \"hw.h\"\n#include \"peer.h\"\n#include \"testmode.h\"\n\nstruct wmi_tlv_policy {\n\tsize_t min_len;\n};\n\nstruct wmi_tlv_svc_ready_parse {\n\tbool wmi_svc_bitmap_done;\n};\n\nstruct wmi_tlv_dma_ring_caps_parse {\n\tstruct wmi_dma_ring_capabilities *dma_ring_caps;\n\tu32 n_dma_ring_caps;\n};\n\nstruct wmi_tlv_svc_rdy_ext_parse {\n\tstruct ath11k_service_ext_param param;\n\tstruct wmi_soc_mac_phy_hw_mode_caps *hw_caps;\n\tstruct wmi_hw_mode_capabilities *hw_mode_caps;\n\tu32 n_hw_mode_caps;\n\tu32 tot_phy_id;\n\tstruct wmi_hw_mode_capabilities pref_hw_mode_caps;\n\tstruct wmi_mac_phy_capabilities *mac_phy_caps;\n\tu32 n_mac_phy_caps;\n\tstruct wmi_soc_hal_reg_capabilities *soc_hal_reg_caps;\n\tstruct wmi_hal_reg_capabilities_ext *ext_hal_reg_caps;\n\tu32 n_ext_hal_reg_caps;\n\tstruct wmi_tlv_dma_ring_caps_parse dma_caps_parse;\n\tbool hw_mode_done;\n\tbool mac_phy_done;\n\tbool ext_hal_reg_done;\n\tbool mac_phy_chainmask_combo_done;\n\tbool mac_phy_chainmask_cap_done;\n\tbool oem_dma_ring_cap_done;\n\tbool dma_ring_cap_done;\n};\n\nstruct wmi_tlv_svc_rdy_ext2_parse {\n\tstruct wmi_tlv_dma_ring_caps_parse dma_caps_parse;\n\tbool dma_ring_cap_done;\n};\n\nstruct wmi_tlv_rdy_parse {\n\tu32 num_extra_mac_addr;\n};\n\nstruct wmi_tlv_dma_buf_release_parse {\n\tstruct ath11k_wmi_dma_buf_release_fixed_param fixed;\n\tstruct wmi_dma_buf_release_entry *buf_entry;\n\tstruct wmi_dma_buf_release_meta_data *meta_data;\n\tu32 num_buf_entry;\n\tu32 num_meta;\n\tbool buf_entry_done;\n\tbool meta_data_done;\n};\n\nstruct wmi_tlv_fw_stats_parse {\n\tconst struct wmi_stats_event *ev;\n\tconst struct wmi_per_chain_rssi_stats *rssi;\n\tstruct ath11k_fw_stats *stats;\n\tint rssi_num;\n\tbool chain_rssi_done;\n};\n\nstruct wmi_tlv_mgmt_rx_parse {\n\tconst struct wmi_mgmt_rx_hdr *fixed;\n\tconst u8 *frame_buf;\n\tbool frame_buf_done;\n};\n\nstatic const struct wmi_tlv_policy wmi_tlv_policies[] = {\n\t[WMI_TAG_ARRAY_BYTE]\n\t\t= { .min_len = 0 },\n\t[WMI_TAG_ARRAY_UINT32]\n\t\t= { .min_len = 0 },\n\t[WMI_TAG_SERVICE_READY_EVENT]\n\t\t= { .min_len = sizeof(struct wmi_service_ready_event) },\n\t[WMI_TAG_SERVICE_READY_EXT_EVENT]\n\t\t= { .min_len =  sizeof(struct wmi_service_ready_ext_event) },\n\t[WMI_TAG_SOC_MAC_PHY_HW_MODE_CAPS]\n\t\t= { .min_len = sizeof(struct wmi_soc_mac_phy_hw_mode_caps) },\n\t[WMI_TAG_SOC_HAL_REG_CAPABILITIES]\n\t\t= { .min_len = sizeof(struct wmi_soc_hal_reg_capabilities) },\n\t[WMI_TAG_VDEV_START_RESPONSE_EVENT]\n\t\t= { .min_len = sizeof(struct wmi_vdev_start_resp_event) },\n\t[WMI_TAG_PEER_DELETE_RESP_EVENT]\n\t\t= { .min_len = sizeof(struct wmi_peer_delete_resp_event) },\n\t[WMI_TAG_OFFLOAD_BCN_TX_STATUS_EVENT]\n\t\t= { .min_len = sizeof(struct wmi_bcn_tx_status_event) },\n\t[WMI_TAG_VDEV_STOPPED_EVENT]\n\t\t= { .min_len = sizeof(struct wmi_vdev_stopped_event) },\n\t[WMI_TAG_REG_CHAN_LIST_CC_EVENT]\n\t\t= { .min_len = sizeof(struct wmi_reg_chan_list_cc_event) },\n\t[WMI_TAG_REG_CHAN_LIST_CC_EXT_EVENT]\n\t\t= { .min_len = sizeof(struct wmi_reg_chan_list_cc_ext_event) },\n\t[WMI_TAG_MGMT_RX_HDR]\n\t\t= { .min_len = sizeof(struct wmi_mgmt_rx_hdr) },\n\t[WMI_TAG_MGMT_TX_COMPL_EVENT]\n\t\t= { .min_len = sizeof(struct wmi_mgmt_tx_compl_event) },\n\t[WMI_TAG_SCAN_EVENT]\n\t\t= { .min_len = sizeof(struct wmi_scan_event) },\n\t[WMI_TAG_PEER_STA_KICKOUT_EVENT]\n\t\t= { .min_len = sizeof(struct wmi_peer_sta_kickout_event) },\n\t[WMI_TAG_ROAM_EVENT]\n\t\t= { .min_len = sizeof(struct wmi_roam_event) },\n\t[WMI_TAG_CHAN_INFO_EVENT]\n\t\t= { .min_len = sizeof(struct wmi_chan_info_event) },\n\t[WMI_TAG_PDEV_BSS_CHAN_INFO_EVENT]\n\t\t= { .min_len = sizeof(struct wmi_pdev_bss_chan_info_event) },\n\t[WMI_TAG_VDEV_INSTALL_KEY_COMPLETE_EVENT]\n\t\t= { .min_len = sizeof(struct wmi_vdev_install_key_compl_event) },\n\t[WMI_TAG_READY_EVENT] = {\n\t\t.min_len = sizeof(struct wmi_ready_event_min) },\n\t[WMI_TAG_SERVICE_AVAILABLE_EVENT]\n\t\t= {.min_len = sizeof(struct wmi_service_available_event) },\n\t[WMI_TAG_PEER_ASSOC_CONF_EVENT]\n\t\t= { .min_len = sizeof(struct wmi_peer_assoc_conf_event) },\n\t[WMI_TAG_STATS_EVENT]\n\t\t= { .min_len = sizeof(struct wmi_stats_event) },\n\t[WMI_TAG_PDEV_CTL_FAILSAFE_CHECK_EVENT]\n\t\t= { .min_len = sizeof(struct wmi_pdev_ctl_failsafe_chk_event) },\n\t[WMI_TAG_HOST_SWFDA_EVENT] = {\n\t\t.min_len = sizeof(struct wmi_fils_discovery_event) },\n\t[WMI_TAG_OFFLOAD_PRB_RSP_TX_STATUS_EVENT] = {\n\t\t.min_len = sizeof(struct wmi_probe_resp_tx_status_event) },\n\t[WMI_TAG_VDEV_DELETE_RESP_EVENT] = {\n\t\t.min_len = sizeof(struct wmi_vdev_delete_resp_event) },\n\t[WMI_TAG_OBSS_COLOR_COLLISION_EVT] = {\n\t\t.min_len = sizeof(struct wmi_obss_color_collision_event) },\n\t[WMI_TAG_11D_NEW_COUNTRY_EVENT] = {\n\t\t.min_len = sizeof(struct wmi_11d_new_cc_ev) },\n\t[WMI_TAG_PER_CHAIN_RSSI_STATS] = {\n\t\t.min_len = sizeof(struct wmi_per_chain_rssi_stats) },\n\t[WMI_TAG_TWT_ADD_DIALOG_COMPLETE_EVENT] = {\n\t\t.min_len = sizeof(struct wmi_twt_add_dialog_event) },\n};\n\n#define PRIMAP(_hw_mode_) \\\n\t[_hw_mode_] = _hw_mode_##_PRI\n\nstatic const int ath11k_hw_mode_pri_map[] = {\n\tPRIMAP(WMI_HOST_HW_MODE_SINGLE),\n\tPRIMAP(WMI_HOST_HW_MODE_DBS),\n\tPRIMAP(WMI_HOST_HW_MODE_SBS_PASSIVE),\n\tPRIMAP(WMI_HOST_HW_MODE_SBS),\n\tPRIMAP(WMI_HOST_HW_MODE_DBS_SBS),\n\tPRIMAP(WMI_HOST_HW_MODE_DBS_OR_SBS),\n\t \n\tPRIMAP(WMI_HOST_HW_MODE_MAX),\n};\n\nstatic int\nath11k_wmi_tlv_iter(struct ath11k_base *ab, const void *ptr, size_t len,\n\t\t    int (*iter)(struct ath11k_base *ab, u16 tag, u16 len,\n\t\t\t\tconst void *ptr, void *data),\n\t\t    void *data)\n{\n\tconst void *begin = ptr;\n\tconst struct wmi_tlv *tlv;\n\tu16 tlv_tag, tlv_len;\n\tint ret;\n\n\twhile (len > 0) {\n\t\tif (len < sizeof(*tlv)) {\n\t\t\tath11k_err(ab, \"wmi tlv parse failure at byte %zd (%zu bytes left, %zu expected)\\n\",\n\t\t\t\t   ptr - begin, len, sizeof(*tlv));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\ttlv = ptr;\n\t\ttlv_tag = FIELD_GET(WMI_TLV_TAG, tlv->header);\n\t\ttlv_len = FIELD_GET(WMI_TLV_LEN, tlv->header);\n\t\tptr += sizeof(*tlv);\n\t\tlen -= sizeof(*tlv);\n\n\t\tif (tlv_len > len) {\n\t\t\tath11k_err(ab, \"wmi tlv parse failure of tag %u at byte %zd (%zu bytes left, %u expected)\\n\",\n\t\t\t\t   tlv_tag, ptr - begin, len, tlv_len);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (tlv_tag < ARRAY_SIZE(wmi_tlv_policies) &&\n\t\t    wmi_tlv_policies[tlv_tag].min_len &&\n\t\t    wmi_tlv_policies[tlv_tag].min_len > tlv_len) {\n\t\t\tath11k_err(ab, \"wmi tlv parse failure of tag %u at byte %zd (%u bytes is less than min length %zu)\\n\",\n\t\t\t\t   tlv_tag, ptr - begin, tlv_len,\n\t\t\t\t   wmi_tlv_policies[tlv_tag].min_len);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = iter(ab, tlv_tag, tlv_len, ptr, data);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tptr += tlv_len;\n\t\tlen -= tlv_len;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath11k_wmi_tlv_iter_parse(struct ath11k_base *ab, u16 tag, u16 len,\n\t\t\t\t     const void *ptr, void *data)\n{\n\tconst void **tb = data;\n\n\tif (tag < WMI_TAG_MAX)\n\t\ttb[tag] = ptr;\n\n\treturn 0;\n}\n\nstatic int ath11k_wmi_tlv_parse(struct ath11k_base *ar, const void **tb,\n\t\t\t\tconst void *ptr, size_t len)\n{\n\treturn ath11k_wmi_tlv_iter(ar, ptr, len, ath11k_wmi_tlv_iter_parse,\n\t\t\t\t   (void *)tb);\n}\n\nconst void **ath11k_wmi_tlv_parse_alloc(struct ath11k_base *ab, const void *ptr,\n\t\t\t\t\tsize_t len, gfp_t gfp)\n{\n\tconst void **tb;\n\tint ret;\n\n\ttb = kcalloc(WMI_TAG_MAX, sizeof(*tb), gfp);\n\tif (!tb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = ath11k_wmi_tlv_parse(ab, tb, ptr, len);\n\tif (ret) {\n\t\tkfree(tb);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn tb;\n}\n\nstatic int ath11k_wmi_cmd_send_nowait(struct ath11k_pdev_wmi *wmi, struct sk_buff *skb,\n\t\t\t\t      u32 cmd_id)\n{\n\tstruct ath11k_skb_cb *skb_cb = ATH11K_SKB_CB(skb);\n\tstruct ath11k_base *ab = wmi->wmi_ab->ab;\n\tstruct wmi_cmd_hdr *cmd_hdr;\n\tint ret;\n\tu32 cmd = 0;\n\n\tif (skb_push(skb, sizeof(struct wmi_cmd_hdr)) == NULL)\n\t\treturn -ENOMEM;\n\n\tcmd |= FIELD_PREP(WMI_CMD_HDR_CMD_ID, cmd_id);\n\n\tcmd_hdr = (struct wmi_cmd_hdr *)skb->data;\n\tcmd_hdr->cmd_id = cmd;\n\n\ttrace_ath11k_wmi_cmd(ab, cmd_id, skb->data, skb->len);\n\n\tmemset(skb_cb, 0, sizeof(*skb_cb));\n\tret = ath11k_htc_send(&ab->htc, wmi->eid, skb);\n\n\tif (ret)\n\t\tgoto err_pull;\n\n\treturn 0;\n\nerr_pull:\n\tskb_pull(skb, sizeof(struct wmi_cmd_hdr));\n\treturn ret;\n}\n\nint ath11k_wmi_cmd_send(struct ath11k_pdev_wmi *wmi, struct sk_buff *skb,\n\t\t\tu32 cmd_id)\n{\n\tstruct ath11k_wmi_base *wmi_sc = wmi->wmi_ab;\n\tint ret = -EOPNOTSUPP;\n\tstruct ath11k_base *ab = wmi_sc->ab;\n\n\tmight_sleep();\n\n\tif (ab->hw_params.credit_flow) {\n\t\twait_event_timeout(wmi_sc->tx_credits_wq, ({\n\t\t\tret = ath11k_wmi_cmd_send_nowait(wmi, skb, cmd_id);\n\n\t\t\tif (ret && test_bit(ATH11K_FLAG_CRASH_FLUSH,\n\t\t\t\t\t    &wmi_sc->ab->dev_flags))\n\t\t\t\tret = -ESHUTDOWN;\n\n\t\t\t(ret != -EAGAIN);\n\t\t\t}), WMI_SEND_TIMEOUT_HZ);\n\t} else {\n\t\twait_event_timeout(wmi->tx_ce_desc_wq, ({\n\t\t\tret = ath11k_wmi_cmd_send_nowait(wmi, skb, cmd_id);\n\n\t\t\tif (ret && test_bit(ATH11K_FLAG_CRASH_FLUSH,\n\t\t\t\t\t    &wmi_sc->ab->dev_flags))\n\t\t\t\tret = -ESHUTDOWN;\n\n\t\t\t(ret != -ENOBUFS);\n\t\t\t}), WMI_SEND_TIMEOUT_HZ);\n\t}\n\n\tif (ret == -EAGAIN)\n\t\tath11k_warn(wmi_sc->ab, \"wmi command %d timeout\\n\", cmd_id);\n\n\tif (ret == -ENOBUFS)\n\t\tath11k_warn(wmi_sc->ab, \"ce desc not available for wmi command %d\\n\",\n\t\t\t    cmd_id);\n\n\treturn ret;\n}\n\nstatic int ath11k_pull_svc_ready_ext(struct ath11k_pdev_wmi *wmi_handle,\n\t\t\t\t     const void *ptr,\n\t\t\t\t     struct ath11k_service_ext_param *param)\n{\n\tconst struct wmi_service_ready_ext_event *ev = ptr;\n\n\tif (!ev)\n\t\treturn -EINVAL;\n\n\t \n\tparam->default_conc_scan_config_bits = ev->default_conc_scan_config_bits;\n\tparam->default_fw_config_bits =\tev->default_fw_config_bits;\n\tparam->he_cap_info = ev->he_cap_info;\n\tparam->mpdu_density = ev->mpdu_density;\n\tparam->max_bssid_rx_filters = ev->max_bssid_rx_filters;\n\tmemcpy(&param->ppet, &ev->ppet, sizeof(param->ppet));\n\n\treturn 0;\n}\n\nstatic int\nath11k_pull_mac_phy_cap_svc_ready_ext(struct ath11k_pdev_wmi *wmi_handle,\n\t\t\t\t      struct wmi_soc_mac_phy_hw_mode_caps *hw_caps,\n\t\t\t\t      struct wmi_hw_mode_capabilities *wmi_hw_mode_caps,\n\t\t\t\t      struct wmi_soc_hal_reg_capabilities *hal_reg_caps,\n\t\t\t\t      struct wmi_mac_phy_capabilities *wmi_mac_phy_caps,\n\t\t\t\t      u8 hw_mode_id, u8 phy_id,\n\t\t\t\t      struct ath11k_pdev *pdev)\n{\n\tstruct wmi_mac_phy_capabilities *mac_phy_caps;\n\tstruct ath11k_base *ab = wmi_handle->wmi_ab->ab;\n\tstruct ath11k_band_cap *cap_band;\n\tstruct ath11k_pdev_cap *pdev_cap = &pdev->cap;\n\tu32 phy_map;\n\tu32 hw_idx, phy_idx = 0;\n\n\tif (!hw_caps || !wmi_hw_mode_caps || !hal_reg_caps)\n\t\treturn -EINVAL;\n\n\tfor (hw_idx = 0; hw_idx < hw_caps->num_hw_modes; hw_idx++) {\n\t\tif (hw_mode_id == wmi_hw_mode_caps[hw_idx].hw_mode_id)\n\t\t\tbreak;\n\n\t\tphy_map = wmi_hw_mode_caps[hw_idx].phy_id_map;\n\t\twhile (phy_map) {\n\t\t\tphy_map >>= 1;\n\t\t\tphy_idx++;\n\t\t}\n\t}\n\n\tif (hw_idx == hw_caps->num_hw_modes)\n\t\treturn -EINVAL;\n\n\tphy_idx += phy_id;\n\tif (phy_id >= hal_reg_caps->num_phy)\n\t\treturn -EINVAL;\n\n\tmac_phy_caps = wmi_mac_phy_caps + phy_idx;\n\n\tpdev->pdev_id = mac_phy_caps->pdev_id;\n\tpdev_cap->supported_bands |= mac_phy_caps->supported_bands;\n\tpdev_cap->ampdu_density = mac_phy_caps->ampdu_density;\n\tab->target_pdev_ids[ab->target_pdev_count].supported_bands =\n\t\tmac_phy_caps->supported_bands;\n\tab->target_pdev_ids[ab->target_pdev_count].pdev_id = mac_phy_caps->pdev_id;\n\tab->target_pdev_count++;\n\n\tif (!(mac_phy_caps->supported_bands & WMI_HOST_WLAN_2G_CAP) &&\n\t    !(mac_phy_caps->supported_bands & WMI_HOST_WLAN_5G_CAP))\n\t\treturn -EINVAL;\n\n\t \n\tif (mac_phy_caps->supported_bands & WMI_HOST_WLAN_2G_CAP) {\n\t\tpdev_cap->tx_chain_mask = mac_phy_caps->tx_chain_mask_2g;\n\t\tpdev_cap->rx_chain_mask = mac_phy_caps->rx_chain_mask_2g;\n\t}\n\n\tif (mac_phy_caps->supported_bands & WMI_HOST_WLAN_5G_CAP) {\n\t\tpdev_cap->vht_cap = mac_phy_caps->vht_cap_info_5g;\n\t\tpdev_cap->vht_mcs = mac_phy_caps->vht_supp_mcs_5g;\n\t\tpdev_cap->he_mcs = mac_phy_caps->he_supp_mcs_5g;\n\t\tpdev_cap->tx_chain_mask = mac_phy_caps->tx_chain_mask_5g;\n\t\tpdev_cap->rx_chain_mask = mac_phy_caps->rx_chain_mask_5g;\n\t\tpdev_cap->nss_ratio_enabled =\n\t\t\tWMI_NSS_RATIO_ENABLE_DISABLE_GET(mac_phy_caps->nss_ratio);\n\t\tpdev_cap->nss_ratio_info =\n\t\t\tWMI_NSS_RATIO_INFO_GET(mac_phy_caps->nss_ratio);\n\t}\n\n\t \n\tpdev_cap->tx_chain_mask_shift =\n\t\t\tfind_first_bit((unsigned long *)&pdev_cap->tx_chain_mask, 32);\n\tpdev_cap->rx_chain_mask_shift =\n\t\t\tfind_first_bit((unsigned long *)&pdev_cap->rx_chain_mask, 32);\n\n\tif (mac_phy_caps->supported_bands & WMI_HOST_WLAN_2G_CAP) {\n\t\tcap_band = &pdev_cap->band[NL80211_BAND_2GHZ];\n\t\tcap_band->phy_id = mac_phy_caps->phy_id;\n\t\tcap_band->max_bw_supported = mac_phy_caps->max_bw_supported_2g;\n\t\tcap_band->ht_cap_info = mac_phy_caps->ht_cap_info_2g;\n\t\tcap_band->he_cap_info[0] = mac_phy_caps->he_cap_info_2g;\n\t\tcap_band->he_cap_info[1] = mac_phy_caps->he_cap_info_2g_ext;\n\t\tcap_band->he_mcs = mac_phy_caps->he_supp_mcs_2g;\n\t\tmemcpy(cap_band->he_cap_phy_info, &mac_phy_caps->he_cap_phy_info_2g,\n\t\t       sizeof(u32) * PSOC_HOST_MAX_PHY_SIZE);\n\t\tmemcpy(&cap_band->he_ppet, &mac_phy_caps->he_ppet2g,\n\t\t       sizeof(struct ath11k_ppe_threshold));\n\t}\n\n\tif (mac_phy_caps->supported_bands & WMI_HOST_WLAN_5G_CAP) {\n\t\tcap_band = &pdev_cap->band[NL80211_BAND_5GHZ];\n\t\tcap_band->phy_id = mac_phy_caps->phy_id;\n\t\tcap_band->max_bw_supported = mac_phy_caps->max_bw_supported_5g;\n\t\tcap_band->ht_cap_info = mac_phy_caps->ht_cap_info_5g;\n\t\tcap_band->he_cap_info[0] = mac_phy_caps->he_cap_info_5g;\n\t\tcap_band->he_cap_info[1] = mac_phy_caps->he_cap_info_5g_ext;\n\t\tcap_band->he_mcs = mac_phy_caps->he_supp_mcs_5g;\n\t\tmemcpy(cap_band->he_cap_phy_info, &mac_phy_caps->he_cap_phy_info_5g,\n\t\t       sizeof(u32) * PSOC_HOST_MAX_PHY_SIZE);\n\t\tmemcpy(&cap_band->he_ppet, &mac_phy_caps->he_ppet5g,\n\t\t       sizeof(struct ath11k_ppe_threshold));\n\n\t\tcap_band = &pdev_cap->band[NL80211_BAND_6GHZ];\n\t\tcap_band->max_bw_supported = mac_phy_caps->max_bw_supported_5g;\n\t\tcap_band->ht_cap_info = mac_phy_caps->ht_cap_info_5g;\n\t\tcap_band->he_cap_info[0] = mac_phy_caps->he_cap_info_5g;\n\t\tcap_band->he_cap_info[1] = mac_phy_caps->he_cap_info_5g_ext;\n\t\tcap_band->he_mcs = mac_phy_caps->he_supp_mcs_5g;\n\t\tmemcpy(cap_band->he_cap_phy_info, &mac_phy_caps->he_cap_phy_info_5g,\n\t\t       sizeof(u32) * PSOC_HOST_MAX_PHY_SIZE);\n\t\tmemcpy(&cap_band->he_ppet, &mac_phy_caps->he_ppet5g,\n\t\t       sizeof(struct ath11k_ppe_threshold));\n\t}\n\n\treturn 0;\n}\n\nstatic int\nath11k_pull_reg_cap_svc_rdy_ext(struct ath11k_pdev_wmi *wmi_handle,\n\t\t\t\tstruct wmi_soc_hal_reg_capabilities *reg_caps,\n\t\t\t\tstruct wmi_hal_reg_capabilities_ext *wmi_ext_reg_cap,\n\t\t\t\tu8 phy_idx,\n\t\t\t\tstruct ath11k_hal_reg_capabilities_ext *param)\n{\n\tstruct wmi_hal_reg_capabilities_ext *ext_reg_cap;\n\n\tif (!reg_caps || !wmi_ext_reg_cap)\n\t\treturn -EINVAL;\n\n\tif (phy_idx >= reg_caps->num_phy)\n\t\treturn -EINVAL;\n\n\text_reg_cap = &wmi_ext_reg_cap[phy_idx];\n\n\tparam->phy_id = ext_reg_cap->phy_id;\n\tparam->eeprom_reg_domain = ext_reg_cap->eeprom_reg_domain;\n\tparam->eeprom_reg_domain_ext =\n\t\t\t      ext_reg_cap->eeprom_reg_domain_ext;\n\tparam->regcap1 = ext_reg_cap->regcap1;\n\tparam->regcap2 = ext_reg_cap->regcap2;\n\t \n\tparam->low_2ghz_chan = ext_reg_cap->low_2ghz_chan;\n\tparam->high_2ghz_chan = ext_reg_cap->high_2ghz_chan;\n\tparam->low_5ghz_chan = ext_reg_cap->low_5ghz_chan;\n\tparam->high_5ghz_chan = ext_reg_cap->high_5ghz_chan;\n\n\treturn 0;\n}\n\nstatic int ath11k_pull_service_ready_tlv(struct ath11k_base *ab,\n\t\t\t\t\t const void *evt_buf,\n\t\t\t\t\t struct ath11k_targ_cap *cap)\n{\n\tconst struct wmi_service_ready_event *ev = evt_buf;\n\n\tif (!ev) {\n\t\tath11k_err(ab, \"%s: failed by NULL param\\n\",\n\t\t\t   __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tcap->phy_capability = ev->phy_capability;\n\tcap->max_frag_entry = ev->max_frag_entry;\n\tcap->num_rf_chains = ev->num_rf_chains;\n\tcap->ht_cap_info = ev->ht_cap_info;\n\tcap->vht_cap_info = ev->vht_cap_info;\n\tcap->vht_supp_mcs = ev->vht_supp_mcs;\n\tcap->hw_min_tx_power = ev->hw_min_tx_power;\n\tcap->hw_max_tx_power = ev->hw_max_tx_power;\n\tcap->sys_cap_info = ev->sys_cap_info;\n\tcap->min_pkt_size_enable = ev->min_pkt_size_enable;\n\tcap->max_bcn_ie_size = ev->max_bcn_ie_size;\n\tcap->max_num_scan_channels = ev->max_num_scan_channels;\n\tcap->max_supported_macs = ev->max_supported_macs;\n\tcap->wmi_fw_sub_feat_caps = ev->wmi_fw_sub_feat_caps;\n\tcap->txrx_chainmask = ev->txrx_chainmask;\n\tcap->default_dbs_hw_mode_index = ev->default_dbs_hw_mode_index;\n\tcap->num_msdu_desc = ev->num_msdu_desc;\n\n\treturn 0;\n}\n\n \nstatic void ath11k_wmi_service_bitmap_copy(struct ath11k_pdev_wmi *wmi,\n\t\t\t\t\t   const u32 *wmi_svc_bm)\n{\n\tint i, j;\n\n\tfor (i = 0, j = 0; i < WMI_SERVICE_BM_SIZE && j < WMI_MAX_SERVICE; i++) {\n\t\tdo {\n\t\t\tif (wmi_svc_bm[i] & BIT(j % WMI_SERVICE_BITS_IN_SIZE32))\n\t\t\t\tset_bit(j, wmi->wmi_ab->svc_map);\n\t\t} while (++j % WMI_SERVICE_BITS_IN_SIZE32);\n\t}\n}\n\nstatic int ath11k_wmi_tlv_svc_rdy_parse(struct ath11k_base *ab, u16 tag, u16 len,\n\t\t\t\t\tconst void *ptr, void *data)\n{\n\tstruct wmi_tlv_svc_ready_parse *svc_ready = data;\n\tstruct ath11k_pdev_wmi *wmi_handle = &ab->wmi_ab.wmi[0];\n\tu16 expect_len;\n\n\tswitch (tag) {\n\tcase WMI_TAG_SERVICE_READY_EVENT:\n\t\tif (ath11k_pull_service_ready_tlv(ab, ptr, &ab->target_caps))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\n\tcase WMI_TAG_ARRAY_UINT32:\n\t\tif (!svc_ready->wmi_svc_bitmap_done) {\n\t\t\texpect_len = WMI_SERVICE_BM_SIZE * sizeof(u32);\n\t\t\tif (len < expect_len) {\n\t\t\t\tath11k_warn(ab, \"invalid len %d for the tag 0x%x\\n\",\n\t\t\t\t\t    len, tag);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\tath11k_wmi_service_bitmap_copy(wmi_handle, ptr);\n\n\t\t\tsvc_ready->wmi_svc_bitmap_done = true;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath11k_service_ready_event(struct ath11k_base *ab, struct sk_buff *skb)\n{\n\tstruct wmi_tlv_svc_ready_parse svc_ready = { };\n\tint ret;\n\n\tret = ath11k_wmi_tlv_iter(ab, skb->data, skb->len,\n\t\t\t\t  ath11k_wmi_tlv_svc_rdy_parse,\n\t\t\t\t  &svc_ready);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to parse tlv %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI, \"event service ready\");\n\n\treturn 0;\n}\n\nstruct sk_buff *ath11k_wmi_alloc_skb(struct ath11k_wmi_base *wmi_sc, u32 len)\n{\n\tstruct sk_buff *skb;\n\tstruct ath11k_base *ab = wmi_sc->ab;\n\tu32 round_len = roundup(len, 4);\n\n\tskb = ath11k_htc_alloc_skb(ab, WMI_SKB_HEADROOM + round_len);\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, WMI_SKB_HEADROOM);\n\tif (!IS_ALIGNED((unsigned long)skb->data, 4))\n\t\tath11k_warn(ab, \"unaligned WMI skb data\\n\");\n\n\tskb_put(skb, round_len);\n\tmemset(skb->data, 0, round_len);\n\n\treturn skb;\n}\n\nstatic u32 ath11k_wmi_mgmt_get_freq(struct ath11k *ar,\n\t\t\t\t    struct ieee80211_tx_info *info)\n{\n\tstruct ath11k_base *ab = ar->ab;\n\tu32 freq = 0;\n\n\tif (ab->hw_params.support_off_channel_tx &&\n\t    ar->scan.is_roc &&\n\t    (info->flags & IEEE80211_TX_CTL_TX_OFFCHAN))\n\t\tfreq = ar->scan.roc_freq;\n\n\treturn freq;\n}\n\nint ath11k_wmi_mgmt_send(struct ath11k *ar, u32 vdev_id, u32 buf_id,\n\t\t\t struct sk_buff *frame)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(frame);\n\tstruct wmi_mgmt_send_cmd *cmd;\n\tstruct wmi_tlv *frame_tlv;\n\tstruct sk_buff *skb;\n\tu32 buf_len;\n\tint ret, len;\n\n\tbuf_len = frame->len < WMI_MGMT_SEND_DOWNLD_LEN ?\n\t\t  frame->len : WMI_MGMT_SEND_DOWNLD_LEN;\n\n\tlen = sizeof(*cmd) + sizeof(*frame_tlv) + roundup(buf_len, 4);\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_mgmt_send_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_MGMT_TX_SEND_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\tcmd->vdev_id = vdev_id;\n\tcmd->desc_id = buf_id;\n\tcmd->chanfreq = ath11k_wmi_mgmt_get_freq(ar, info);\n\tcmd->paddr_lo = lower_32_bits(ATH11K_SKB_CB(frame)->paddr);\n\tcmd->paddr_hi = upper_32_bits(ATH11K_SKB_CB(frame)->paddr);\n\tcmd->frame_len = frame->len;\n\tcmd->buf_len = buf_len;\n\tcmd->tx_params_valid = 0;\n\n\tframe_tlv = (struct wmi_tlv *)(skb->data + sizeof(*cmd));\n\tframe_tlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_BYTE) |\n\t\t\t    FIELD_PREP(WMI_TLV_LEN, buf_len);\n\n\tmemcpy(frame_tlv->value, frame->data, buf_len);\n\n\tath11k_ce_byte_swap(frame_tlv->value, buf_len);\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_MGMT_TX_SEND_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to submit WMI_MGMT_TX_SEND_CMDID cmd\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI, \"cmd mgmt tx send\");\n\n\treturn ret;\n}\n\nint ath11k_wmi_vdev_create(struct ath11k *ar, u8 *macaddr,\n\t\t\t   struct vdev_create_params *param)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_vdev_create_cmd *cmd;\n\tstruct sk_buff *skb;\n\tstruct wmi_vdev_txrx_streams *txrx_streams;\n\tstruct wmi_tlv *tlv;\n\tint ret, len;\n\tvoid *ptr;\n\n\t \n\tlen = sizeof(*cmd) + TLV_HDR_SIZE +\n\t\t(WMI_NUM_SUPPORTED_BAND_MAX * sizeof(*txrx_streams));\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_vdev_create_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_VDEV_CREATE_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->vdev_id = param->if_id;\n\tcmd->vdev_type = param->type;\n\tcmd->vdev_subtype = param->subtype;\n\tcmd->num_cfg_txrx_streams = WMI_NUM_SUPPORTED_BAND_MAX;\n\tcmd->pdev_id = param->pdev_id;\n\tcmd->mbssid_flags = param->mbssid_flags;\n\tcmd->mbssid_tx_vdev_id = param->mbssid_tx_vdev_id;\n\n\tether_addr_copy(cmd->vdev_macaddr.addr, macaddr);\n\n\tptr = skb->data + sizeof(*cmd);\n\tlen = WMI_NUM_SUPPORTED_BAND_MAX * sizeof(*txrx_streams);\n\n\ttlv = ptr;\n\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_STRUCT) |\n\t\t      FIELD_PREP(WMI_TLV_LEN, len);\n\n\tptr += TLV_HDR_SIZE;\n\ttxrx_streams = ptr;\n\tlen = sizeof(*txrx_streams);\n\ttxrx_streams->tlv_header =\n\t\tFIELD_PREP(WMI_TLV_TAG, WMI_TAG_VDEV_TXRX_STREAMS) |\n\t\tFIELD_PREP(WMI_TLV_LEN, len - TLV_HDR_SIZE);\n\ttxrx_streams->band = WMI_TPC_CHAINMASK_CONFIG_BAND_2G;\n\ttxrx_streams->supported_tx_streams =\n\t\t\t\t param->chains[NL80211_BAND_2GHZ].tx;\n\ttxrx_streams->supported_rx_streams =\n\t\t\t\t param->chains[NL80211_BAND_2GHZ].rx;\n\n\ttxrx_streams++;\n\ttxrx_streams->tlv_header =\n\t\tFIELD_PREP(WMI_TLV_TAG, WMI_TAG_VDEV_TXRX_STREAMS) |\n\t\tFIELD_PREP(WMI_TLV_LEN, len - TLV_HDR_SIZE);\n\ttxrx_streams->band = WMI_TPC_CHAINMASK_CONFIG_BAND_5G;\n\ttxrx_streams->supported_tx_streams =\n\t\t\t\t param->chains[NL80211_BAND_5GHZ].tx;\n\ttxrx_streams->supported_rx_streams =\n\t\t\t\t param->chains[NL80211_BAND_5GHZ].rx;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_VDEV_CREATE_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to submit WMI_VDEV_CREATE_CMDID\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"cmd vdev create id %d type %d subtype %d macaddr %pM pdevid %d\\n\",\n\t\t   param->if_id, param->type, param->subtype,\n\t\t   macaddr, param->pdev_id);\n\n\treturn ret;\n}\n\nint ath11k_wmi_vdev_delete(struct ath11k *ar, u8 vdev_id)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_vdev_delete_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_vdev_delete_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_VDEV_DELETE_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\tcmd->vdev_id = vdev_id;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_VDEV_DELETE_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to submit WMI_VDEV_DELETE_CMDID\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI, \"cmd vdev delete id %d\\n\", vdev_id);\n\n\treturn ret;\n}\n\nint ath11k_wmi_vdev_stop(struct ath11k *ar, u8 vdev_id)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_vdev_stop_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_vdev_stop_cmd *)skb->data;\n\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_VDEV_STOP_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\tcmd->vdev_id = vdev_id;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_VDEV_STOP_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to submit WMI_VDEV_STOP cmd\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI, \"cmd vdev stop id 0x%x\\n\", vdev_id);\n\n\treturn ret;\n}\n\nint ath11k_wmi_vdev_down(struct ath11k *ar, u8 vdev_id)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_vdev_down_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_vdev_down_cmd *)skb->data;\n\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_VDEV_DOWN_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\tcmd->vdev_id = vdev_id;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_VDEV_DOWN_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to submit WMI_VDEV_DOWN cmd\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI, \"cmd vdev down id 0x%x\\n\", vdev_id);\n\n\treturn ret;\n}\n\nstatic void ath11k_wmi_put_wmi_channel(struct wmi_channel *chan,\n\t\t\t\t       struct wmi_vdev_start_req_arg *arg)\n{\n\tu32 center_freq1 = arg->channel.band_center_freq1;\n\n\tmemset(chan, 0, sizeof(*chan));\n\n\tchan->mhz = arg->channel.freq;\n\tchan->band_center_freq1 = arg->channel.band_center_freq1;\n\n\tif (arg->channel.mode == MODE_11AX_HE160) {\n\t\tif (arg->channel.freq > arg->channel.band_center_freq1)\n\t\t\tchan->band_center_freq1 = center_freq1 + 40;\n\t\telse\n\t\t\tchan->band_center_freq1 = center_freq1 - 40;\n\n\t\tchan->band_center_freq2 = arg->channel.band_center_freq1;\n\n\t} else if ((arg->channel.mode == MODE_11AC_VHT80_80) ||\n\t\t   (arg->channel.mode == MODE_11AX_HE80_80)) {\n\t\tchan->band_center_freq2 = arg->channel.band_center_freq2;\n\t} else {\n\t\tchan->band_center_freq2 = 0;\n\t}\n\n\tchan->info |= FIELD_PREP(WMI_CHAN_INFO_MODE, arg->channel.mode);\n\tif (arg->channel.passive)\n\t\tchan->info |= WMI_CHAN_INFO_PASSIVE;\n\tif (arg->channel.allow_ibss)\n\t\tchan->info |= WMI_CHAN_INFO_ADHOC_ALLOWED;\n\tif (arg->channel.allow_ht)\n\t\tchan->info |= WMI_CHAN_INFO_ALLOW_HT;\n\tif (arg->channel.allow_vht)\n\t\tchan->info |= WMI_CHAN_INFO_ALLOW_VHT;\n\tif (arg->channel.allow_he)\n\t\tchan->info |= WMI_CHAN_INFO_ALLOW_HE;\n\tif (arg->channel.ht40plus)\n\t\tchan->info |= WMI_CHAN_INFO_HT40_PLUS;\n\tif (arg->channel.chan_radar)\n\t\tchan->info |= WMI_CHAN_INFO_DFS;\n\tif (arg->channel.freq2_radar)\n\t\tchan->info |= WMI_CHAN_INFO_DFS_FREQ2;\n\n\tchan->reg_info_1 = FIELD_PREP(WMI_CHAN_REG_INFO1_MAX_PWR,\n\t\t\t\t      arg->channel.max_power) |\n\t\tFIELD_PREP(WMI_CHAN_REG_INFO1_MAX_REG_PWR,\n\t\t\t   arg->channel.max_reg_power);\n\n\tchan->reg_info_2 = FIELD_PREP(WMI_CHAN_REG_INFO2_ANT_MAX,\n\t\t\t\t      arg->channel.max_antenna_gain) |\n\t\tFIELD_PREP(WMI_CHAN_REG_INFO2_MAX_TX_PWR,\n\t\t\t   arg->channel.max_power);\n}\n\nint ath11k_wmi_vdev_start(struct ath11k *ar, struct wmi_vdev_start_req_arg *arg,\n\t\t\t  bool restart)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_vdev_start_request_cmd *cmd;\n\tstruct sk_buff *skb;\n\tstruct wmi_channel *chan;\n\tstruct wmi_tlv *tlv;\n\tvoid *ptr;\n\tint ret, len;\n\n\tif (WARN_ON(arg->ssid_len > sizeof(cmd->ssid.ssid)))\n\t\treturn -EINVAL;\n\n\tlen = sizeof(*cmd) + sizeof(*chan) + TLV_HDR_SIZE;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_vdev_start_request_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t     WMI_TAG_VDEV_START_REQUEST_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\tcmd->vdev_id = arg->vdev_id;\n\tcmd->beacon_interval = arg->bcn_intval;\n\tcmd->bcn_tx_rate = arg->bcn_tx_rate;\n\tcmd->dtim_period = arg->dtim_period;\n\tcmd->num_noa_descriptors = arg->num_noa_descriptors;\n\tcmd->preferred_rx_streams = arg->pref_rx_streams;\n\tcmd->preferred_tx_streams = arg->pref_tx_streams;\n\tcmd->cac_duration_ms = arg->cac_duration_ms;\n\tcmd->regdomain = arg->regdomain;\n\tcmd->he_ops = arg->he_ops;\n\tcmd->mbssid_flags = arg->mbssid_flags;\n\tcmd->mbssid_tx_vdev_id = arg->mbssid_tx_vdev_id;\n\n\tif (!restart) {\n\t\tif (arg->ssid) {\n\t\t\tcmd->ssid.ssid_len = arg->ssid_len;\n\t\t\tmemcpy(cmd->ssid.ssid, arg->ssid, arg->ssid_len);\n\t\t}\n\t\tif (arg->hidden_ssid)\n\t\t\tcmd->flags |= WMI_VDEV_START_HIDDEN_SSID;\n\t\tif (arg->pmf_enabled)\n\t\t\tcmd->flags |= WMI_VDEV_START_PMF_ENABLED;\n\t}\n\n\tcmd->flags |= WMI_VDEV_START_LDPC_RX_ENABLED;\n\tif (test_bit(ATH11K_FLAG_HW_CRYPTO_DISABLED, &ar->ab->dev_flags))\n\t\tcmd->flags |= WMI_VDEV_START_HW_ENCRYPTION_DISABLED;\n\n\tptr = skb->data + sizeof(*cmd);\n\tchan = ptr;\n\n\tath11k_wmi_put_wmi_channel(chan, arg);\n\n\tchan->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_CHANNEL) |\n\t\t\t   FIELD_PREP(WMI_TLV_LEN,\n\t\t\t\t      sizeof(*chan) - TLV_HDR_SIZE);\n\tptr += sizeof(*chan);\n\n\ttlv = ptr;\n\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_STRUCT) |\n\t\t      FIELD_PREP(WMI_TLV_LEN, 0);\n\n\t \n\n\tptr += sizeof(*tlv);\n\n\tif (restart)\n\t\tret = ath11k_wmi_cmd_send(wmi, skb,\n\t\t\t\t\t  WMI_VDEV_RESTART_REQUEST_CMDID);\n\telse\n\t\tret = ath11k_wmi_cmd_send(wmi, skb,\n\t\t\t\t\t  WMI_VDEV_START_REQUEST_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to submit vdev_%s cmd\\n\",\n\t\t\t    restart ? \"restart\" : \"start\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI, \"cmd vdev %s id 0x%x freq 0x%x mode 0x%x\\n\",\n\t\t   restart ? \"restart\" : \"start\", arg->vdev_id,\n\t\t   arg->channel.freq, arg->channel.mode);\n\n\treturn ret;\n}\n\nint ath11k_wmi_vdev_up(struct ath11k *ar, u32 vdev_id, u32 aid, const u8 *bssid,\n\t\t       u8 *tx_bssid, u32 nontx_profile_idx, u32 nontx_profile_cnt)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_vdev_up_cmd *cmd;\n\tstruct ieee80211_bss_conf *bss_conf;\n\tstruct ath11k_vif *arvif;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tarvif = ath11k_mac_get_arvif(ar, vdev_id);\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_vdev_up_cmd *)skb->data;\n\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_VDEV_UP_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\tcmd->vdev_id = vdev_id;\n\tcmd->vdev_assoc_id = aid;\n\n\tether_addr_copy(cmd->vdev_bssid.addr, bssid);\n\n\tcmd->nontx_profile_idx = nontx_profile_idx;\n\tcmd->nontx_profile_cnt = nontx_profile_cnt;\n\tif (tx_bssid)\n\t\tether_addr_copy(cmd->tx_vdev_bssid.addr, tx_bssid);\n\n\tif (arvif && arvif->vif->type == NL80211_IFTYPE_STATION) {\n\t\tbss_conf = &arvif->vif->bss_conf;\n\n\t\tif (bss_conf->nontransmitted) {\n\t\t\tether_addr_copy(cmd->tx_vdev_bssid.addr,\n\t\t\t\t\tbss_conf->transmitter_bssid);\n\t\t\tcmd->nontx_profile_idx = bss_conf->bssid_index;\n\t\t\tcmd->nontx_profile_cnt = bss_conf->bssid_indicator;\n\t\t}\n\t}\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_VDEV_UP_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to submit WMI_VDEV_UP cmd\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"cmd vdev up id 0x%x assoc id %d bssid %pM\\n\",\n\t\t   vdev_id, aid, bssid);\n\n\treturn ret;\n}\n\nint ath11k_wmi_send_peer_create_cmd(struct ath11k *ar,\n\t\t\t\t    struct peer_create_params *param)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_peer_create_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_peer_create_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_PEER_CREATE_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tether_addr_copy(cmd->peer_macaddr.addr, param->peer_addr);\n\tcmd->peer_type = param->peer_type;\n\tcmd->vdev_id = param->vdev_id;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_PEER_CREATE_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to submit WMI_PEER_CREATE cmd\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"cmd peer create vdev_id %d peer_addr %pM\\n\",\n\t\t   param->vdev_id, param->peer_addr);\n\n\treturn ret;\n}\n\nint ath11k_wmi_send_peer_delete_cmd(struct ath11k *ar,\n\t\t\t\t    const u8 *peer_addr, u8 vdev_id)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_peer_delete_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_peer_delete_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_PEER_DELETE_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tether_addr_copy(cmd->peer_macaddr.addr, peer_addr);\n\tcmd->vdev_id = vdev_id;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_PEER_DELETE_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to send WMI_PEER_DELETE cmd\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"cmd peer delete vdev_id %d peer_addr %pM\\n\",\n\t\t   vdev_id,  peer_addr);\n\n\treturn ret;\n}\n\nint ath11k_wmi_send_pdev_set_regdomain(struct ath11k *ar,\n\t\t\t\t       struct pdev_set_regdomain_params *param)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_pdev_set_regdomain_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_pdev_set_regdomain_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t     WMI_TAG_PDEV_SET_REGDOMAIN_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->reg_domain = param->current_rd_in_use;\n\tcmd->reg_domain_2g = param->current_rd_2g;\n\tcmd->reg_domain_5g = param->current_rd_5g;\n\tcmd->conformance_test_limit_2g = param->ctl_2g;\n\tcmd->conformance_test_limit_5g = param->ctl_5g;\n\tcmd->dfs_domain = param->dfs_domain;\n\tcmd->pdev_id = param->pdev_id;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_PDEV_SET_REGDOMAIN_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to send WMI_PDEV_SET_REGDOMAIN cmd\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"cmd pdev regd rd %d rd2g %d rd5g %d domain %d pdev id %d\\n\",\n\t\t   param->current_rd_in_use, param->current_rd_2g,\n\t\t   param->current_rd_5g, param->dfs_domain, param->pdev_id);\n\n\treturn ret;\n}\n\nint ath11k_wmi_set_peer_param(struct ath11k *ar, const u8 *peer_addr,\n\t\t\t      u32 vdev_id, u32 param_id, u32 param_val)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_peer_set_param_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_peer_set_param_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_PEER_SET_PARAM_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\tether_addr_copy(cmd->peer_macaddr.addr, peer_addr);\n\tcmd->vdev_id = vdev_id;\n\tcmd->param_id = param_id;\n\tcmd->param_value = param_val;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_PEER_SET_PARAM_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to send WMI_PEER_SET_PARAM cmd\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"cmd peer set param vdev %d peer 0x%pM set param %d value %d\\n\",\n\t\t   vdev_id, peer_addr, param_id, param_val);\n\n\treturn ret;\n}\n\nint ath11k_wmi_send_peer_flush_tids_cmd(struct ath11k *ar,\n\t\t\t\t\tu8 peer_addr[ETH_ALEN],\n\t\t\t\t\tstruct peer_flush_params *param)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_peer_flush_tids_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_peer_flush_tids_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_PEER_FLUSH_TIDS_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tether_addr_copy(cmd->peer_macaddr.addr, peer_addr);\n\tcmd->peer_tid_bitmap = param->peer_tid_bitmap;\n\tcmd->vdev_id = param->vdev_id;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_PEER_FLUSH_TIDS_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to send WMI_PEER_FLUSH_TIDS cmd\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"cmd peer flush tids vdev_id %d peer_addr %pM tids %08x\\n\",\n\t\t   param->vdev_id, peer_addr, param->peer_tid_bitmap);\n\n\treturn ret;\n}\n\nint ath11k_wmi_peer_rx_reorder_queue_setup(struct ath11k *ar,\n\t\t\t\t\t   int vdev_id, const u8 *addr,\n\t\t\t\t\t   dma_addr_t paddr, u8 tid,\n\t\t\t\t\t   u8 ba_window_size_valid,\n\t\t\t\t\t   u32 ba_window_size)\n{\n\tstruct wmi_peer_reorder_queue_setup_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(ar->wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_peer_reorder_queue_setup_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t     WMI_TAG_REORDER_QUEUE_SETUP_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tether_addr_copy(cmd->peer_macaddr.addr, addr);\n\tcmd->vdev_id = vdev_id;\n\tcmd->tid = tid;\n\tcmd->queue_ptr_lo = lower_32_bits(paddr);\n\tcmd->queue_ptr_hi = upper_32_bits(paddr);\n\tcmd->queue_no = tid;\n\tcmd->ba_window_size_valid = ba_window_size_valid;\n\tcmd->ba_window_size = ba_window_size;\n\n\tret = ath11k_wmi_cmd_send(ar->wmi, skb,\n\t\t\t\t  WMI_PEER_REORDER_QUEUE_SETUP_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to send WMI_PEER_REORDER_QUEUE_SETUP\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"cmd peer reorder queue setup addr %pM vdev_id %d tid %d\\n\",\n\t\t   addr, vdev_id, tid);\n\n\treturn ret;\n}\n\nint\nath11k_wmi_rx_reord_queue_remove(struct ath11k *ar,\n\t\t\t\t struct rx_reorder_queue_remove_params *param)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_peer_reorder_queue_remove_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_peer_reorder_queue_remove_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t     WMI_TAG_REORDER_QUEUE_REMOVE_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tether_addr_copy(cmd->peer_macaddr.addr, param->peer_macaddr);\n\tcmd->vdev_id = param->vdev_id;\n\tcmd->tid_mask = param->peer_tid_bitmap;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb,\n\t\t\t\t  WMI_PEER_REORDER_QUEUE_REMOVE_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to send WMI_PEER_REORDER_QUEUE_REMOVE_CMDID\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"cmd peer reorder queue remove peer_macaddr %pM vdev_id %d tid_map %d\",\n\t\t   param->peer_macaddr, param->vdev_id, param->peer_tid_bitmap);\n\n\treturn ret;\n}\n\nint ath11k_wmi_pdev_set_param(struct ath11k *ar, u32 param_id,\n\t\t\t      u32 param_value, u8 pdev_id)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_pdev_set_param_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_pdev_set_param_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_PDEV_SET_PARAM_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\tcmd->pdev_id = pdev_id;\n\tcmd->param_id = param_id;\n\tcmd->param_value = param_value;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_PDEV_SET_PARAM_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to send WMI_PDEV_SET_PARAM cmd\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"cmd pdev set param %d pdev id %d value %d\\n\",\n\t\t   param_id, pdev_id, param_value);\n\n\treturn ret;\n}\n\nint ath11k_wmi_pdev_set_ps_mode(struct ath11k *ar, int vdev_id,\n\t\t\t\tenum wmi_sta_ps_mode psmode)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_pdev_set_ps_mode_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_pdev_set_ps_mode_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_STA_POWERSAVE_MODE_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\tcmd->vdev_id = vdev_id;\n\tcmd->sta_ps_mode = psmode;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_STA_POWERSAVE_MODE_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to send WMI_PDEV_SET_PARAM cmd\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"cmd sta powersave mode psmode %d vdev id %d\\n\",\n\t\t   psmode, vdev_id);\n\n\treturn ret;\n}\n\nint ath11k_wmi_pdev_suspend(struct ath11k *ar, u32 suspend_opt,\n\t\t\t    u32 pdev_id)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_pdev_suspend_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_pdev_suspend_cmd *)skb->data;\n\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_PDEV_SUSPEND_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->suspend_opt = suspend_opt;\n\tcmd->pdev_id = pdev_id;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_PDEV_SUSPEND_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to send WMI_PDEV_SUSPEND cmd\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"cmd pdev suspend pdev_id %d\\n\", pdev_id);\n\n\treturn ret;\n}\n\nint ath11k_wmi_pdev_resume(struct ath11k *ar, u32 pdev_id)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_pdev_resume_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_pdev_resume_cmd *)skb->data;\n\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_PDEV_RESUME_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\tcmd->pdev_id = pdev_id;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_PDEV_RESUME_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to send WMI_PDEV_RESUME cmd\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"cmd pdev resume pdev id %d\\n\", pdev_id);\n\n\treturn ret;\n}\n\n \nint ath11k_wmi_pdev_bss_chan_info_request(struct ath11k *ar,\n\t\t\t\t\t  enum wmi_bss_chan_info_req_type type)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_pdev_bss_chan_info_req_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_pdev_bss_chan_info_req_cmd *)skb->data;\n\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t     WMI_TAG_PDEV_BSS_CHAN_INFO_REQUEST) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\tcmd->req_type = type;\n\tcmd->pdev_id = ar->pdev->pdev_id;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb,\n\t\t\t\t  WMI_PDEV_BSS_CHAN_INFO_REQUEST_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to send WMI_PDEV_BSS_CHAN_INFO_REQUEST cmd\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"cmd pdev bss chan info request type %d\\n\", type);\n\n\treturn ret;\n}\n\nint ath11k_wmi_send_set_ap_ps_param_cmd(struct ath11k *ar, u8 *peer_addr,\n\t\t\t\t\tstruct ap_ps_params *param)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_ap_ps_peer_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_ap_ps_peer_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_AP_PS_PEER_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->vdev_id = param->vdev_id;\n\tether_addr_copy(cmd->peer_macaddr.addr, peer_addr);\n\tcmd->param = param->param;\n\tcmd->value = param->value;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_AP_PS_PEER_PARAM_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to send WMI_AP_PS_PEER_PARAM_CMDID\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"cmd ap ps peer param vdev id %d peer %pM param %d value %d\\n\",\n\t\t   param->vdev_id, peer_addr, param->param, param->value);\n\n\treturn ret;\n}\n\nint ath11k_wmi_set_sta_ps_param(struct ath11k *ar, u32 vdev_id,\n\t\t\t\tu32 param, u32 param_value)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_sta_powersave_param_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_sta_powersave_param_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t     WMI_TAG_STA_POWERSAVE_PARAM_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->vdev_id = vdev_id;\n\tcmd->param = param;\n\tcmd->value = param_value;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_STA_POWERSAVE_PARAM_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to send WMI_STA_POWERSAVE_PARAM_CMDID\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"cmd set powersave param vdev_id %d param %d value %d\\n\",\n\t\t   vdev_id, param, param_value);\n\n\treturn ret;\n}\n\nint ath11k_wmi_force_fw_hang_cmd(struct ath11k *ar, u32 type, u32 delay_time_ms)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_force_fw_hang_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret, len;\n\n\tlen = sizeof(*cmd);\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_force_fw_hang_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_FORCE_FW_HANG_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, len - TLV_HDR_SIZE);\n\n\tcmd->type = type;\n\tcmd->delay_time_ms = delay_time_ms;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_FORCE_FW_HANG_CMDID);\n\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"Failed to send WMI_FORCE_FW_HANG_CMDID\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI, \"cmd force fw hang\");\n\n\treturn ret;\n}\n\nint ath11k_wmi_vdev_set_param_cmd(struct ath11k *ar, u32 vdev_id,\n\t\t\t\t  u32 param_id, u32 param_value)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_vdev_set_param_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_vdev_set_param_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_VDEV_SET_PARAM_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->vdev_id = vdev_id;\n\tcmd->param_id = param_id;\n\tcmd->param_value = param_value;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_VDEV_SET_PARAM_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to send WMI_VDEV_SET_PARAM_CMDID\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"cmd vdev set param vdev 0x%x param %d value %d\\n\",\n\t\t   vdev_id, param_id, param_value);\n\n\treturn ret;\n}\n\nint ath11k_wmi_send_stats_request_cmd(struct ath11k *ar,\n\t\t\t\t      struct stats_request_params *param)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_request_stats_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_request_stats_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_REQUEST_STATS_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->stats_id = param->stats_id;\n\tcmd->vdev_id = param->vdev_id;\n\tcmd->pdev_id = param->pdev_id;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_REQUEST_STATS_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to send WMI_REQUEST_STATS cmd\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"cmd request stats 0x%x vdev id %d pdev id %d\\n\",\n\t\t   param->stats_id, param->vdev_id, param->pdev_id);\n\n\treturn ret;\n}\n\nint ath11k_wmi_send_pdev_temperature_cmd(struct ath11k *ar)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_get_pdev_temperature_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_get_pdev_temperature_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_PDEV_GET_TEMPERATURE_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\tcmd->pdev_id = ar->pdev->pdev_id;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_PDEV_GET_TEMPERATURE_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to send WMI_PDEV_GET_TEMPERATURE cmd\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"cmd pdev get temperature for pdev_id %d\\n\", ar->pdev->pdev_id);\n\n\treturn ret;\n}\n\nint ath11k_wmi_send_bcn_offload_control_cmd(struct ath11k *ar,\n\t\t\t\t\t    u32 vdev_id, u32 bcn_ctrl_op)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_bcn_offload_ctrl_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_bcn_offload_ctrl_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t     WMI_TAG_BCN_OFFLOAD_CTRL_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->vdev_id = vdev_id;\n\tcmd->bcn_ctrl_op = bcn_ctrl_op;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_BCN_OFFLOAD_CTRL_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to send WMI_BCN_OFFLOAD_CTRL_CMDID\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"cmd bcn offload ctrl vdev id %d ctrl_op %d\\n\",\n\t\t   vdev_id, bcn_ctrl_op);\n\n\treturn ret;\n}\n\nint ath11k_wmi_bcn_tmpl(struct ath11k *ar, u32 vdev_id,\n\t\t\tstruct ieee80211_mutable_offsets *offs,\n\t\t\tstruct sk_buff *bcn, u32 ema_params)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_bcn_tmpl_cmd *cmd;\n\tstruct wmi_bcn_prb_info *bcn_prb_info;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tvoid *ptr;\n\tint ret, len;\n\tsize_t aligned_len = roundup(bcn->len, 4);\n\tstruct ieee80211_vif *vif;\n\tstruct ath11k_vif *arvif = ath11k_mac_get_arvif(ar, vdev_id);\n\n\tif (!arvif) {\n\t\tath11k_warn(ar->ab, \"failed to find arvif with vdev id %d\\n\", vdev_id);\n\t\treturn -EINVAL;\n\t}\n\n\tvif = arvif->vif;\n\n\tlen = sizeof(*cmd) + sizeof(*bcn_prb_info) + TLV_HDR_SIZE + aligned_len;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_bcn_tmpl_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_BCN_TMPL_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\tcmd->vdev_id = vdev_id;\n\tcmd->tim_ie_offset = offs->tim_offset;\n\n\tif (vif->bss_conf.csa_active) {\n\t\tcmd->csa_switch_count_offset = offs->cntdwn_counter_offs[0];\n\t\tcmd->ext_csa_switch_count_offset = offs->cntdwn_counter_offs[1];\n\t}\n\n\tcmd->buf_len = bcn->len;\n\tcmd->mbssid_ie_offset = offs->mbssid_off;\n\tcmd->ema_params = ema_params;\n\n\tptr = skb->data + sizeof(*cmd);\n\n\tbcn_prb_info = ptr;\n\tlen = sizeof(*bcn_prb_info);\n\tbcn_prb_info->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t\t      WMI_TAG_BCN_PRB_INFO) |\n\t\t\t\t   FIELD_PREP(WMI_TLV_LEN, len - TLV_HDR_SIZE);\n\tbcn_prb_info->caps = 0;\n\tbcn_prb_info->erp = 0;\n\n\tptr += sizeof(*bcn_prb_info);\n\n\ttlv = ptr;\n\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_BYTE) |\n\t\t      FIELD_PREP(WMI_TLV_LEN, aligned_len);\n\tmemcpy(tlv->value, bcn->data, bcn->len);\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_BCN_TMPL_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to send WMI_BCN_TMPL_CMDID\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI, \"cmd bcn tmpl\");\n\n\treturn ret;\n}\n\nint ath11k_wmi_vdev_install_key(struct ath11k *ar,\n\t\t\t\tstruct wmi_vdev_install_key_arg *arg)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_vdev_install_key_cmd *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tint ret, len;\n\tint key_len_aligned = roundup(arg->key_len, sizeof(uint32_t));\n\n\tlen = sizeof(*cmd) + TLV_HDR_SIZE + key_len_aligned;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_vdev_install_key_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_VDEV_INSTALL_KEY_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\tcmd->vdev_id = arg->vdev_id;\n\tether_addr_copy(cmd->peer_macaddr.addr, arg->macaddr);\n\tcmd->key_idx = arg->key_idx;\n\tcmd->key_flags = arg->key_flags;\n\tcmd->key_cipher = arg->key_cipher;\n\tcmd->key_len = arg->key_len;\n\tcmd->key_txmic_len = arg->key_txmic_len;\n\tcmd->key_rxmic_len = arg->key_rxmic_len;\n\n\tif (arg->key_rsc_counter)\n\t\tmemcpy(&cmd->key_rsc_counter, &arg->key_rsc_counter,\n\t\t       sizeof(struct wmi_key_seq_counter));\n\n\ttlv = (struct wmi_tlv *)(skb->data + sizeof(*cmd));\n\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_BYTE) |\n\t\t      FIELD_PREP(WMI_TLV_LEN, key_len_aligned);\n\tif (arg->key_data)\n\t\tmemcpy(tlv->value, (u8 *)arg->key_data, key_len_aligned);\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_VDEV_INSTALL_KEY_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to send WMI_VDEV_INSTALL_KEY cmd\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"cmd vdev install key idx %d cipher %d len %d\\n\",\n\t\t   arg->key_idx, arg->key_cipher, arg->key_len);\n\n\treturn ret;\n}\n\nstatic inline void\nath11k_wmi_copy_peer_flags(struct wmi_peer_assoc_complete_cmd *cmd,\n\t\t\t   struct peer_assoc_params *param,\n\t\t\t   bool hw_crypto_disabled)\n{\n\tcmd->peer_flags = 0;\n\n\tif (param->is_wme_set) {\n\t\tif (param->qos_flag)\n\t\t\tcmd->peer_flags |= WMI_PEER_QOS;\n\t\tif (param->apsd_flag)\n\t\t\tcmd->peer_flags |= WMI_PEER_APSD;\n\t\tif (param->ht_flag)\n\t\t\tcmd->peer_flags |= WMI_PEER_HT;\n\t\tif (param->bw_40)\n\t\t\tcmd->peer_flags |= WMI_PEER_40MHZ;\n\t\tif (param->bw_80)\n\t\t\tcmd->peer_flags |= WMI_PEER_80MHZ;\n\t\tif (param->bw_160)\n\t\t\tcmd->peer_flags |= WMI_PEER_160MHZ;\n\n\t\t \n\t\tif (param->stbc_flag)\n\t\t\tcmd->peer_flags |= WMI_PEER_STBC;\n\n\t\t \n\t\tif (param->ldpc_flag)\n\t\t\tcmd->peer_flags |= WMI_PEER_LDPC;\n\n\t\tif (param->static_mimops_flag)\n\t\t\tcmd->peer_flags |= WMI_PEER_STATIC_MIMOPS;\n\t\tif (param->dynamic_mimops_flag)\n\t\t\tcmd->peer_flags |= WMI_PEER_DYN_MIMOPS;\n\t\tif (param->spatial_mux_flag)\n\t\t\tcmd->peer_flags |= WMI_PEER_SPATIAL_MUX;\n\t\tif (param->vht_flag)\n\t\t\tcmd->peer_flags |= WMI_PEER_VHT;\n\t\tif (param->he_flag)\n\t\t\tcmd->peer_flags |= WMI_PEER_HE;\n\t\tif (param->twt_requester)\n\t\t\tcmd->peer_flags |= WMI_PEER_TWT_REQ;\n\t\tif (param->twt_responder)\n\t\t\tcmd->peer_flags |= WMI_PEER_TWT_RESP;\n\t}\n\n\t \n\tif (param->auth_flag)\n\t\tcmd->peer_flags |= WMI_PEER_AUTH;\n\tif (param->need_ptk_4_way) {\n\t\tcmd->peer_flags |= WMI_PEER_NEED_PTK_4_WAY;\n\t\tif (!hw_crypto_disabled && param->is_assoc)\n\t\t\tcmd->peer_flags &= ~WMI_PEER_AUTH;\n\t}\n\tif (param->need_gtk_2_way)\n\t\tcmd->peer_flags |= WMI_PEER_NEED_GTK_2_WAY;\n\t \n\tif (param->safe_mode_enabled)\n\t\tcmd->peer_flags &= ~(WMI_PEER_NEED_PTK_4_WAY |\n\t\t\t\t     WMI_PEER_NEED_GTK_2_WAY);\n\n\tif (param->is_pmf_enabled)\n\t\tcmd->peer_flags |= WMI_PEER_PMF;\n\n\t \n\t \n\n\t \n\tif (param->peer_ht_rates.num_rates == 0)\n\t\tcmd->peer_flags &= ~WMI_PEER_HT;\n}\n\nint ath11k_wmi_send_peer_assoc_cmd(struct ath11k *ar,\n\t\t\t\t   struct peer_assoc_params *param)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_peer_assoc_complete_cmd *cmd;\n\tstruct wmi_vht_rate_set *mcs;\n\tstruct wmi_he_rate_set *he_mcs;\n\tstruct sk_buff *skb;\n\tstruct wmi_tlv *tlv;\n\tvoid *ptr;\n\tu32 peer_legacy_rates_align;\n\tu32 peer_ht_rates_align;\n\tint i, ret, len;\n\n\tpeer_legacy_rates_align = roundup(param->peer_legacy_rates.num_rates,\n\t\t\t\t\t  sizeof(u32));\n\tpeer_ht_rates_align = roundup(param->peer_ht_rates.num_rates,\n\t\t\t\t      sizeof(u32));\n\n\tlen = sizeof(*cmd) +\n\t      TLV_HDR_SIZE + (peer_legacy_rates_align * sizeof(u8)) +\n\t      TLV_HDR_SIZE + (peer_ht_rates_align * sizeof(u8)) +\n\t      sizeof(*mcs) + TLV_HDR_SIZE +\n\t      (sizeof(*he_mcs) * param->peer_he_mcs_count);\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tptr = skb->data;\n\n\tcmd = ptr;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t     WMI_TAG_PEER_ASSOC_COMPLETE_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->vdev_id = param->vdev_id;\n\n\tcmd->peer_new_assoc = param->peer_new_assoc;\n\tcmd->peer_associd = param->peer_associd;\n\n\tath11k_wmi_copy_peer_flags(cmd, param,\n\t\t\t\t   test_bit(ATH11K_FLAG_HW_CRYPTO_DISABLED,\n\t\t\t\t\t    &ar->ab->dev_flags));\n\n\tether_addr_copy(cmd->peer_macaddr.addr, param->peer_mac);\n\n\tcmd->peer_rate_caps = param->peer_rate_caps;\n\tcmd->peer_caps = param->peer_caps;\n\tcmd->peer_listen_intval = param->peer_listen_intval;\n\tcmd->peer_ht_caps = param->peer_ht_caps;\n\tcmd->peer_max_mpdu = param->peer_max_mpdu;\n\tcmd->peer_mpdu_density = param->peer_mpdu_density;\n\tcmd->peer_vht_caps = param->peer_vht_caps;\n\tcmd->peer_phymode = param->peer_phymode;\n\n\t \n\tcmd->peer_he_cap_info = param->peer_he_cap_macinfo[0];\n\tcmd->peer_he_cap_info_ext = param->peer_he_cap_macinfo[1];\n\tcmd->peer_he_cap_info_internal = param->peer_he_cap_macinfo_internal;\n\tcmd->peer_he_caps_6ghz = param->peer_he_caps_6ghz;\n\tcmd->peer_he_ops = param->peer_he_ops;\n\tmemcpy(&cmd->peer_he_cap_phy, &param->peer_he_cap_phyinfo,\n\t       sizeof(param->peer_he_cap_phyinfo));\n\tmemcpy(&cmd->peer_ppet, &param->peer_ppet,\n\t       sizeof(param->peer_ppet));\n\n\t \n\tptr += sizeof(*cmd);\n\n\ttlv = ptr;\n\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_BYTE) |\n\t\t      FIELD_PREP(WMI_TLV_LEN, peer_legacy_rates_align);\n\n\tptr += TLV_HDR_SIZE;\n\n\tcmd->num_peer_legacy_rates = param->peer_legacy_rates.num_rates;\n\tmemcpy(ptr, param->peer_legacy_rates.rates,\n\t       param->peer_legacy_rates.num_rates);\n\n\t \n\tptr += peer_legacy_rates_align;\n\n\ttlv = ptr;\n\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_BYTE) |\n\t\t      FIELD_PREP(WMI_TLV_LEN, peer_ht_rates_align);\n\tptr += TLV_HDR_SIZE;\n\tcmd->num_peer_ht_rates = param->peer_ht_rates.num_rates;\n\tmemcpy(ptr, param->peer_ht_rates.rates,\n\t       param->peer_ht_rates.num_rates);\n\n\t \n\tptr += peer_ht_rates_align;\n\n\tmcs = ptr;\n\n\tmcs->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_VHT_RATE_SET) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*mcs) - TLV_HDR_SIZE);\n\n\tcmd->peer_nss = param->peer_nss;\n\n\t \n\tcmd->peer_bw_rxnss_override = 0;\n\tcmd->peer_bw_rxnss_override |= param->peer_bw_rxnss_override;\n\n\tif (param->vht_capable) {\n\t\tmcs->rx_max_rate = param->rx_max_rate;\n\t\tmcs->rx_mcs_set = param->rx_mcs_set;\n\t\tmcs->tx_max_rate = param->tx_max_rate;\n\t\tmcs->tx_mcs_set = param->tx_mcs_set;\n\t}\n\n\t \n\tcmd->peer_he_mcs = param->peer_he_mcs_count;\n\tcmd->min_data_rate = param->min_data_rate;\n\n\tptr += sizeof(*mcs);\n\n\tlen = param->peer_he_mcs_count * sizeof(*he_mcs);\n\n\ttlv = ptr;\n\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_STRUCT) |\n\t\t      FIELD_PREP(WMI_TLV_LEN, len);\n\tptr += TLV_HDR_SIZE;\n\n\t \n\tfor (i = 0; i < param->peer_he_mcs_count; i++) {\n\t\the_mcs = ptr;\n\t\the_mcs->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t\t\tWMI_TAG_HE_RATE_SET) |\n\t\t\t\t     FIELD_PREP(WMI_TLV_LEN,\n\t\t\t\t\t\tsizeof(*he_mcs) - TLV_HDR_SIZE);\n\n\t\the_mcs->rx_mcs_set = param->peer_he_tx_mcs_set[i];\n\t\the_mcs->tx_mcs_set = param->peer_he_rx_mcs_set[i];\n\t\tptr += sizeof(*he_mcs);\n\t}\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_PEER_ASSOC_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to send WMI_PEER_ASSOC_CMDID\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"cmd peer assoc vdev id %d assoc id %d peer mac %pM peer_flags %x rate_caps %x peer_caps %x listen_intval %d ht_caps %x max_mpdu %d nss %d phymode %d peer_mpdu_density %d vht_caps %x he cap_info %x he ops %x he cap_info_ext %x he phy %x %x %x peer_bw_rxnss_override %x\\n\",\n\t\t   cmd->vdev_id, cmd->peer_associd, param->peer_mac,\n\t\t   cmd->peer_flags, cmd->peer_rate_caps, cmd->peer_caps,\n\t\t   cmd->peer_listen_intval, cmd->peer_ht_caps,\n\t\t   cmd->peer_max_mpdu, cmd->peer_nss, cmd->peer_phymode,\n\t\t   cmd->peer_mpdu_density,\n\t\t   cmd->peer_vht_caps, cmd->peer_he_cap_info,\n\t\t   cmd->peer_he_ops, cmd->peer_he_cap_info_ext,\n\t\t   cmd->peer_he_cap_phy[0], cmd->peer_he_cap_phy[1],\n\t\t   cmd->peer_he_cap_phy[2],\n\t\t   cmd->peer_bw_rxnss_override);\n\n\treturn ret;\n}\n\nvoid ath11k_wmi_start_scan_init(struct ath11k *ar,\n\t\t\t\tstruct scan_req_params *arg)\n{\n\t \n\targ->scan_req_id = 1;\n\tif (ar->state_11d == ATH11K_11D_PREPARING)\n\t\targ->scan_priority = WMI_SCAN_PRIORITY_MEDIUM;\n\telse\n\t\targ->scan_priority = WMI_SCAN_PRIORITY_LOW;\n\targ->dwell_time_active = 50;\n\targ->dwell_time_active_2g = 0;\n\targ->dwell_time_passive = 150;\n\targ->dwell_time_active_6g = 40;\n\targ->dwell_time_passive_6g = 30;\n\targ->min_rest_time = 50;\n\targ->max_rest_time = 500;\n\targ->repeat_probe_time = 0;\n\targ->probe_spacing_time = 0;\n\targ->idle_time = 0;\n\targ->max_scan_time = 20000;\n\targ->probe_delay = 5;\n\targ->notify_scan_events = WMI_SCAN_EVENT_STARTED |\n\t\t\t\t  WMI_SCAN_EVENT_COMPLETED |\n\t\t\t\t  WMI_SCAN_EVENT_BSS_CHANNEL |\n\t\t\t\t  WMI_SCAN_EVENT_FOREIGN_CHAN |\n\t\t\t\t  WMI_SCAN_EVENT_DEQUEUED;\n\targ->scan_flags |= WMI_SCAN_CHAN_STAT_EVENT;\n\n\tif (test_bit(WMI_TLV_SERVICE_PASSIVE_SCAN_START_TIME_ENHANCE,\n\t\t     ar->ab->wmi_ab.svc_map))\n\t\targ->scan_ctrl_flags_ext |=\n\t\t\tWMI_SCAN_FLAG_EXT_PASSIVE_SCAN_START_TIME_ENHANCE;\n\n\targ->num_bssid = 1;\n\n\t \n\teth_broadcast_addr(arg->bssid_list[0].addr);\n}\n\nstatic inline void\nath11k_wmi_copy_scan_event_cntrl_flags(struct wmi_start_scan_cmd *cmd,\n\t\t\t\t       struct scan_req_params *param)\n{\n\t \n\tif (param->scan_ev_started)\n\t\tcmd->notify_scan_events |=  WMI_SCAN_EVENT_STARTED;\n\tif (param->scan_ev_completed)\n\t\tcmd->notify_scan_events |=  WMI_SCAN_EVENT_COMPLETED;\n\tif (param->scan_ev_bss_chan)\n\t\tcmd->notify_scan_events |=  WMI_SCAN_EVENT_BSS_CHANNEL;\n\tif (param->scan_ev_foreign_chan)\n\t\tcmd->notify_scan_events |=  WMI_SCAN_EVENT_FOREIGN_CHAN;\n\tif (param->scan_ev_dequeued)\n\t\tcmd->notify_scan_events |=  WMI_SCAN_EVENT_DEQUEUED;\n\tif (param->scan_ev_preempted)\n\t\tcmd->notify_scan_events |=  WMI_SCAN_EVENT_PREEMPTED;\n\tif (param->scan_ev_start_failed)\n\t\tcmd->notify_scan_events |=  WMI_SCAN_EVENT_START_FAILED;\n\tif (param->scan_ev_restarted)\n\t\tcmd->notify_scan_events |=  WMI_SCAN_EVENT_RESTARTED;\n\tif (param->scan_ev_foreign_chn_exit)\n\t\tcmd->notify_scan_events |=  WMI_SCAN_EVENT_FOREIGN_CHAN_EXIT;\n\tif (param->scan_ev_suspended)\n\t\tcmd->notify_scan_events |=  WMI_SCAN_EVENT_SUSPENDED;\n\tif (param->scan_ev_resumed)\n\t\tcmd->notify_scan_events |=  WMI_SCAN_EVENT_RESUMED;\n\n\t \n\tcmd->scan_ctrl_flags = 0;\n\tif (param->scan_f_passive)\n\t\tcmd->scan_ctrl_flags |=  WMI_SCAN_FLAG_PASSIVE;\n\tif (param->scan_f_strict_passive_pch)\n\t\tcmd->scan_ctrl_flags |=  WMI_SCAN_FLAG_STRICT_PASSIVE_ON_PCHN;\n\tif (param->scan_f_promisc_mode)\n\t\tcmd->scan_ctrl_flags |=  WMI_SCAN_FILTER_PROMISCUOS;\n\tif (param->scan_f_capture_phy_err)\n\t\tcmd->scan_ctrl_flags |=  WMI_SCAN_CAPTURE_PHY_ERROR;\n\tif (param->scan_f_half_rate)\n\t\tcmd->scan_ctrl_flags |=  WMI_SCAN_FLAG_HALF_RATE_SUPPORT;\n\tif (param->scan_f_quarter_rate)\n\t\tcmd->scan_ctrl_flags |=  WMI_SCAN_FLAG_QUARTER_RATE_SUPPORT;\n\tif (param->scan_f_cck_rates)\n\t\tcmd->scan_ctrl_flags |=  WMI_SCAN_ADD_CCK_RATES;\n\tif (param->scan_f_ofdm_rates)\n\t\tcmd->scan_ctrl_flags |=  WMI_SCAN_ADD_OFDM_RATES;\n\tif (param->scan_f_chan_stat_evnt)\n\t\tcmd->scan_ctrl_flags |=  WMI_SCAN_CHAN_STAT_EVENT;\n\tif (param->scan_f_filter_prb_req)\n\t\tcmd->scan_ctrl_flags |=  WMI_SCAN_FILTER_PROBE_REQ;\n\tif (param->scan_f_bcast_probe)\n\t\tcmd->scan_ctrl_flags |=  WMI_SCAN_ADD_BCAST_PROBE_REQ;\n\tif (param->scan_f_offchan_mgmt_tx)\n\t\tcmd->scan_ctrl_flags |=  WMI_SCAN_OFFCHAN_MGMT_TX;\n\tif (param->scan_f_offchan_data_tx)\n\t\tcmd->scan_ctrl_flags |=  WMI_SCAN_OFFCHAN_DATA_TX;\n\tif (param->scan_f_force_active_dfs_chn)\n\t\tcmd->scan_ctrl_flags |=  WMI_SCAN_FLAG_FORCE_ACTIVE_ON_DFS;\n\tif (param->scan_f_add_tpc_ie_in_probe)\n\t\tcmd->scan_ctrl_flags |=  WMI_SCAN_ADD_TPC_IE_IN_PROBE_REQ;\n\tif (param->scan_f_add_ds_ie_in_probe)\n\t\tcmd->scan_ctrl_flags |=  WMI_SCAN_ADD_DS_IE_IN_PROBE_REQ;\n\tif (param->scan_f_add_spoofed_mac_in_probe)\n\t\tcmd->scan_ctrl_flags |=  WMI_SCAN_ADD_SPOOF_MAC_IN_PROBE_REQ;\n\tif (param->scan_f_add_rand_seq_in_probe)\n\t\tcmd->scan_ctrl_flags |=  WMI_SCAN_RANDOM_SEQ_NO_IN_PROBE_REQ;\n\tif (param->scan_f_en_ie_whitelist_in_probe)\n\t\tcmd->scan_ctrl_flags |=\n\t\t\t WMI_SCAN_ENABLE_IE_WHTELIST_IN_PROBE_REQ;\n\n\t \n\tWMI_SCAN_SET_DWELL_MODE(cmd->scan_ctrl_flags,\n\t\t\t\tparam->adaptive_dwell_time_mode);\n\n\tcmd->scan_ctrl_flags_ext = param->scan_ctrl_flags_ext;\n}\n\nint ath11k_wmi_send_scan_start_cmd(struct ath11k *ar,\n\t\t\t\t   struct scan_req_params *params)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_start_scan_cmd *cmd;\n\tstruct wmi_ssid *ssid = NULL;\n\tstruct wmi_mac_addr *bssid;\n\tstruct sk_buff *skb;\n\tstruct wmi_tlv *tlv;\n\tvoid *ptr;\n\tint i, ret, len;\n\tu32 *tmp_ptr;\n\tu16 extraie_len_with_pad = 0;\n\tstruct hint_short_ssid *s_ssid = NULL;\n\tstruct hint_bssid *hint_bssid = NULL;\n\n\tlen = sizeof(*cmd);\n\n\tlen += TLV_HDR_SIZE;\n\tif (params->num_chan)\n\t\tlen += params->num_chan * sizeof(u32);\n\n\tlen += TLV_HDR_SIZE;\n\tif (params->num_ssids)\n\t\tlen += params->num_ssids * sizeof(*ssid);\n\n\tlen += TLV_HDR_SIZE;\n\tif (params->num_bssid)\n\t\tlen += sizeof(*bssid) * params->num_bssid;\n\n\tlen += TLV_HDR_SIZE;\n\tif (params->extraie.len && params->extraie.len <= 0xFFFF)\n\t\textraie_len_with_pad =\n\t\t\troundup(params->extraie.len, sizeof(u32));\n\tlen += extraie_len_with_pad;\n\n\tif (params->num_hint_bssid)\n\t\tlen += TLV_HDR_SIZE +\n\t\t       params->num_hint_bssid * sizeof(struct hint_bssid);\n\n\tif (params->num_hint_s_ssid)\n\t\tlen += TLV_HDR_SIZE +\n\t\t       params->num_hint_s_ssid * sizeof(struct hint_short_ssid);\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tptr = skb->data;\n\n\tcmd = ptr;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_START_SCAN_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->scan_id = params->scan_id;\n\tcmd->scan_req_id = params->scan_req_id;\n\tcmd->vdev_id = params->vdev_id;\n\tcmd->scan_priority = params->scan_priority;\n\tcmd->notify_scan_events = params->notify_scan_events;\n\n\tath11k_wmi_copy_scan_event_cntrl_flags(cmd, params);\n\n\tcmd->dwell_time_active = params->dwell_time_active;\n\tcmd->dwell_time_active_2g = params->dwell_time_active_2g;\n\tcmd->dwell_time_passive = params->dwell_time_passive;\n\tcmd->dwell_time_active_6g = params->dwell_time_active_6g;\n\tcmd->dwell_time_passive_6g = params->dwell_time_passive_6g;\n\tcmd->min_rest_time = params->min_rest_time;\n\tcmd->max_rest_time = params->max_rest_time;\n\tcmd->repeat_probe_time = params->repeat_probe_time;\n\tcmd->probe_spacing_time = params->probe_spacing_time;\n\tcmd->idle_time = params->idle_time;\n\tcmd->max_scan_time = params->max_scan_time;\n\tcmd->probe_delay = params->probe_delay;\n\tcmd->burst_duration = params->burst_duration;\n\tcmd->num_chan = params->num_chan;\n\tcmd->num_bssid = params->num_bssid;\n\tcmd->num_ssids = params->num_ssids;\n\tcmd->ie_len = params->extraie.len;\n\tcmd->n_probes = params->n_probes;\n\tether_addr_copy(cmd->mac_addr.addr, params->mac_addr.addr);\n\tether_addr_copy(cmd->mac_mask.addr, params->mac_mask.addr);\n\n\tptr += sizeof(*cmd);\n\n\tlen = params->num_chan * sizeof(u32);\n\n\ttlv = ptr;\n\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_UINT32) |\n\t\t      FIELD_PREP(WMI_TLV_LEN, len);\n\tptr += TLV_HDR_SIZE;\n\ttmp_ptr = (u32 *)ptr;\n\n\tfor (i = 0; i < params->num_chan; ++i)\n\t\ttmp_ptr[i] = params->chan_list[i];\n\n\tptr += len;\n\n\tlen = params->num_ssids * sizeof(*ssid);\n\ttlv = ptr;\n\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_FIXED_STRUCT) |\n\t\t      FIELD_PREP(WMI_TLV_LEN, len);\n\n\tptr += TLV_HDR_SIZE;\n\n\tif (params->num_ssids) {\n\t\tssid = ptr;\n\t\tfor (i = 0; i < params->num_ssids; ++i) {\n\t\t\tssid->ssid_len = params->ssid[i].length;\n\t\t\tmemcpy(ssid->ssid, params->ssid[i].ssid,\n\t\t\t       params->ssid[i].length);\n\t\t\tssid++;\n\t\t}\n\t}\n\n\tptr += (params->num_ssids * sizeof(*ssid));\n\tlen = params->num_bssid * sizeof(*bssid);\n\ttlv = ptr;\n\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_FIXED_STRUCT) |\n\t\t      FIELD_PREP(WMI_TLV_LEN, len);\n\n\tptr += TLV_HDR_SIZE;\n\tbssid = ptr;\n\n\tif (params->num_bssid) {\n\t\tfor (i = 0; i < params->num_bssid; ++i) {\n\t\t\tether_addr_copy(bssid->addr,\n\t\t\t\t\tparams->bssid_list[i].addr);\n\t\t\tbssid++;\n\t\t}\n\t}\n\n\tptr += params->num_bssid * sizeof(*bssid);\n\n\tlen = extraie_len_with_pad;\n\ttlv = ptr;\n\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_BYTE) |\n\t\t      FIELD_PREP(WMI_TLV_LEN, len);\n\tptr += TLV_HDR_SIZE;\n\n\tif (extraie_len_with_pad)\n\t\tmemcpy(ptr, params->extraie.ptr,\n\t\t       params->extraie.len);\n\n\tptr += extraie_len_with_pad;\n\n\tif (params->num_hint_s_ssid) {\n\t\tlen = params->num_hint_s_ssid * sizeof(struct hint_short_ssid);\n\t\ttlv = ptr;\n\t\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_FIXED_STRUCT) |\n\t\t\t      FIELD_PREP(WMI_TLV_LEN, len);\n\t\tptr += TLV_HDR_SIZE;\n\t\ts_ssid = ptr;\n\t\tfor (i = 0; i < params->num_hint_s_ssid; ++i) {\n\t\t\ts_ssid->freq_flags = params->hint_s_ssid[i].freq_flags;\n\t\t\ts_ssid->short_ssid = params->hint_s_ssid[i].short_ssid;\n\t\t\ts_ssid++;\n\t\t}\n\t\tptr += len;\n\t}\n\n\tif (params->num_hint_bssid) {\n\t\tlen = params->num_hint_bssid * sizeof(struct hint_bssid);\n\t\ttlv = ptr;\n\t\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_FIXED_STRUCT) |\n\t\t\t      FIELD_PREP(WMI_TLV_LEN, len);\n\t\tptr += TLV_HDR_SIZE;\n\t\thint_bssid = ptr;\n\t\tfor (i = 0; i < params->num_hint_bssid; ++i) {\n\t\t\thint_bssid->freq_flags =\n\t\t\t\tparams->hint_bssid[i].freq_flags;\n\t\t\tether_addr_copy(&params->hint_bssid[i].bssid.addr[0],\n\t\t\t\t\t&hint_bssid->bssid.addr[0]);\n\t\t\thint_bssid++;\n\t\t}\n\t}\n\n\tret = ath11k_wmi_cmd_send(wmi, skb,\n\t\t\t\t  WMI_START_SCAN_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to send WMI_START_SCAN_CMDID\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI, \"cmd start scan\");\n\n\treturn ret;\n}\n\nint ath11k_wmi_send_scan_stop_cmd(struct ath11k *ar,\n\t\t\t\t  struct scan_cancel_param *param)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_stop_scan_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_stop_scan_cmd *)skb->data;\n\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_STOP_SCAN_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->vdev_id = param->vdev_id;\n\tcmd->requestor = param->requester;\n\tcmd->scan_id = param->scan_id;\n\tcmd->pdev_id = param->pdev_id;\n\t \n\tif (param->req_type == WLAN_SCAN_CANCEL_PDEV_ALL) {\n\t\t \n\t\tcmd->req_type =  WMI_SCAN_STOP_ALL;\n\t} else if (param->req_type == WLAN_SCAN_CANCEL_VDEV_ALL) {\n\t\t \n\t\tcmd->req_type =  WMI_SCN_STOP_VAP_ALL;\n\t} else if (param->req_type == WLAN_SCAN_CANCEL_SINGLE) {\n\t\t \n\t\tcmd->req_type =  WMI_SCAN_STOP_ONE;\n\t} else {\n\t\tath11k_warn(ar->ab, \"invalid scan cancel param %d\",\n\t\t\t    param->req_type);\n\t\tdev_kfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\tret = ath11k_wmi_cmd_send(wmi, skb,\n\t\t\t\t  WMI_STOP_SCAN_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to send WMI_STOP_SCAN_CMDID\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI, \"cmd stop scan\");\n\n\treturn ret;\n}\n\nint ath11k_wmi_send_scan_chan_list_cmd(struct ath11k *ar,\n\t\t\t\t       struct scan_chan_list_params *chan_list)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_scan_chan_list_cmd *cmd;\n\tstruct sk_buff *skb;\n\tstruct wmi_channel *chan_info;\n\tstruct channel_param *tchan_info;\n\tstruct wmi_tlv *tlv;\n\tvoid *ptr;\n\tint i, ret, len;\n\tu16 num_send_chans, num_sends = 0, max_chan_limit = 0;\n\tu32 *reg1, *reg2;\n\n\ttchan_info = chan_list->ch_param;\n\twhile (chan_list->nallchans) {\n\t\tlen = sizeof(*cmd) + TLV_HDR_SIZE;\n\t\tmax_chan_limit = (wmi->wmi_ab->max_msg_len[ar->pdev_idx] - len) /\n\t\t\tsizeof(*chan_info);\n\n\t\tif (chan_list->nallchans > max_chan_limit)\n\t\t\tnum_send_chans = max_chan_limit;\n\t\telse\n\t\t\tnum_send_chans = chan_list->nallchans;\n\n\t\tchan_list->nallchans -= num_send_chans;\n\t\tlen += sizeof(*chan_info) * num_send_chans;\n\n\t\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, len);\n\t\tif (!skb)\n\t\t\treturn -ENOMEM;\n\n\t\tcmd = (struct wmi_scan_chan_list_cmd *)skb->data;\n\t\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_SCAN_CHAN_LIST_CMD) |\n\t\t\tFIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\t\tcmd->pdev_id = chan_list->pdev_id;\n\t\tcmd->num_scan_chans = num_send_chans;\n\t\tif (num_sends)\n\t\t\tcmd->flags |= WMI_APPEND_TO_EXISTING_CHAN_LIST_FLAG;\n\n\t\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t\t   \"no.of chan = %d len = %d pdev_id = %d num_sends = %d\\n\",\n\t\t\t   num_send_chans, len, cmd->pdev_id, num_sends);\n\n\t\tptr = skb->data + sizeof(*cmd);\n\n\t\tlen = sizeof(*chan_info) * num_send_chans;\n\t\ttlv = ptr;\n\t\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_STRUCT) |\n\t\t\t      FIELD_PREP(WMI_TLV_LEN, len - TLV_HDR_SIZE);\n\t\tptr += TLV_HDR_SIZE;\n\n\t\tfor (i = 0; i < num_send_chans; ++i) {\n\t\t\tchan_info = ptr;\n\t\t\tmemset(chan_info, 0, sizeof(*chan_info));\n\t\t\tlen = sizeof(*chan_info);\n\t\t\tchan_info->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t\t\t\t   WMI_TAG_CHANNEL) |\n\t\t\t\t\t\tFIELD_PREP(WMI_TLV_LEN,\n\t\t\t\t\t\t\t   len - TLV_HDR_SIZE);\n\n\t\t\treg1 = &chan_info->reg_info_1;\n\t\t\treg2 = &chan_info->reg_info_2;\n\t\t\tchan_info->mhz = tchan_info->mhz;\n\t\t\tchan_info->band_center_freq1 = tchan_info->cfreq1;\n\t\t\tchan_info->band_center_freq2 = tchan_info->cfreq2;\n\n\t\t\tif (tchan_info->is_chan_passive)\n\t\t\t\tchan_info->info |= WMI_CHAN_INFO_PASSIVE;\n\t\t\tif (tchan_info->allow_he)\n\t\t\t\tchan_info->info |= WMI_CHAN_INFO_ALLOW_HE;\n\t\t\telse if (tchan_info->allow_vht)\n\t\t\t\tchan_info->info |= WMI_CHAN_INFO_ALLOW_VHT;\n\t\t\telse if (tchan_info->allow_ht)\n\t\t\t\tchan_info->info |= WMI_CHAN_INFO_ALLOW_HT;\n\t\t\tif (tchan_info->half_rate)\n\t\t\t\tchan_info->info |= WMI_CHAN_INFO_HALF_RATE;\n\t\t\tif (tchan_info->quarter_rate)\n\t\t\t\tchan_info->info |= WMI_CHAN_INFO_QUARTER_RATE;\n\t\t\tif (tchan_info->psc_channel)\n\t\t\t\tchan_info->info |= WMI_CHAN_INFO_PSC;\n\t\t\tif (tchan_info->dfs_set)\n\t\t\t\tchan_info->info |= WMI_CHAN_INFO_DFS;\n\n\t\t\tchan_info->info |= FIELD_PREP(WMI_CHAN_INFO_MODE,\n\t\t\t\t\t\t      tchan_info->phy_mode);\n\t\t\t*reg1 |= FIELD_PREP(WMI_CHAN_REG_INFO1_MIN_PWR,\n\t\t\t\t\t    tchan_info->minpower);\n\t\t\t*reg1 |= FIELD_PREP(WMI_CHAN_REG_INFO1_MAX_PWR,\n\t\t\t\t\t    tchan_info->maxpower);\n\t\t\t*reg1 |= FIELD_PREP(WMI_CHAN_REG_INFO1_MAX_REG_PWR,\n\t\t\t\t\t    tchan_info->maxregpower);\n\t\t\t*reg1 |= FIELD_PREP(WMI_CHAN_REG_INFO1_REG_CLS,\n\t\t\t\t\t    tchan_info->reg_class_id);\n\t\t\t*reg2 |= FIELD_PREP(WMI_CHAN_REG_INFO2_ANT_MAX,\n\t\t\t\t\t    tchan_info->antennamax);\n\t\t\t*reg2 |= FIELD_PREP(WMI_CHAN_REG_INFO2_MAX_TX_PWR,\n\t\t\t\t\t    tchan_info->maxregpower);\n\n\t\t\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t\t\t   \"chan scan list chan[%d] = %u, chan_info->info %8x\\n\",\n\t\t\t\t   i, chan_info->mhz, chan_info->info);\n\n\t\t\tptr += sizeof(*chan_info);\n\n\t\t\ttchan_info++;\n\t\t}\n\n\t\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_SCAN_CHAN_LIST_CMDID);\n\t\tif (ret) {\n\t\t\tath11k_warn(ar->ab, \"failed to send WMI_SCAN_CHAN_LIST cmd\\n\");\n\t\t\tdev_kfree_skb(skb);\n\t\t\treturn ret;\n\t\t}\n\n\t\tath11k_dbg(ar->ab, ATH11K_DBG_WMI, \"cmd scan chan list channels %d\",\n\t\t\t   num_send_chans);\n\n\t\tnum_sends++;\n\t}\n\n\treturn 0;\n}\n\nint ath11k_wmi_send_wmm_update_cmd_tlv(struct ath11k *ar, u32 vdev_id,\n\t\t\t\t       struct wmi_wmm_params_all_arg *param)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_vdev_set_wmm_params_cmd *cmd;\n\tstruct wmi_wmm_params *wmm_param;\n\tstruct wmi_wmm_params_arg *wmi_wmm_arg;\n\tstruct sk_buff *skb;\n\tint ret, ac;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_vdev_set_wmm_params_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t     WMI_TAG_VDEV_SET_WMM_PARAMS_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->vdev_id = vdev_id;\n\tcmd->wmm_param_type = 0;\n\n\tfor (ac = 0; ac < WME_NUM_AC; ac++) {\n\t\tswitch (ac) {\n\t\tcase WME_AC_BE:\n\t\t\twmi_wmm_arg = &param->ac_be;\n\t\t\tbreak;\n\t\tcase WME_AC_BK:\n\t\t\twmi_wmm_arg = &param->ac_bk;\n\t\t\tbreak;\n\t\tcase WME_AC_VI:\n\t\t\twmi_wmm_arg = &param->ac_vi;\n\t\t\tbreak;\n\t\tcase WME_AC_VO:\n\t\t\twmi_wmm_arg = &param->ac_vo;\n\t\t\tbreak;\n\t\t}\n\n\t\twmm_param = (struct wmi_wmm_params *)&cmd->wmm_params[ac];\n\t\twmm_param->tlv_header =\n\t\t\t\tFIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t\t   WMI_TAG_VDEV_SET_WMM_PARAMS_CMD) |\n\t\t\t\tFIELD_PREP(WMI_TLV_LEN,\n\t\t\t\t\t   sizeof(*wmm_param) - TLV_HDR_SIZE);\n\n\t\twmm_param->aifs = wmi_wmm_arg->aifs;\n\t\twmm_param->cwmin = wmi_wmm_arg->cwmin;\n\t\twmm_param->cwmax = wmi_wmm_arg->cwmax;\n\t\twmm_param->txoplimit = wmi_wmm_arg->txop;\n\t\twmm_param->acm = wmi_wmm_arg->acm;\n\t\twmm_param->no_ack = wmi_wmm_arg->no_ack;\n\n\t\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t\t   \"wmm set ac %d aifs %d cwmin %d cwmax %d txop %d acm %d no_ack %d\\n\",\n\t\t\t   ac, wmm_param->aifs, wmm_param->cwmin,\n\t\t\t   wmm_param->cwmax, wmm_param->txoplimit,\n\t\t\t   wmm_param->acm, wmm_param->no_ack);\n\t}\n\tret = ath11k_wmi_cmd_send(wmi, skb,\n\t\t\t\t  WMI_VDEV_SET_WMM_PARAMS_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to send WMI_VDEV_SET_WMM_PARAMS_CMDID\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI, \"cmd vdev set wmm params\");\n\n\treturn ret;\n}\n\nint ath11k_wmi_send_dfs_phyerr_offload_enable_cmd(struct ath11k *ar,\n\t\t\t\t\t\t  u32 pdev_id)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_dfs_phyerr_offload_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_dfs_phyerr_offload_cmd *)skb->data;\n\tcmd->tlv_header =\n\t\tFIELD_PREP(WMI_TLV_TAG,\n\t\t\t   WMI_TAG_PDEV_DFS_PHYERR_OFFLOAD_ENABLE_CMD) |\n\t\tFIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->pdev_id = pdev_id;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb,\n\t\t\t\t  WMI_PDEV_DFS_PHYERR_OFFLOAD_ENABLE_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to send WMI_PDEV_DFS_PHYERR_OFFLOAD_ENABLE cmd\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"cmd pdev dfs phyerr offload enable pdev id %d\\n\", pdev_id);\n\n\treturn ret;\n}\n\nint ath11k_wmi_delba_send(struct ath11k *ar, u32 vdev_id, const u8 *mac,\n\t\t\t  u32 tid, u32 initiator, u32 reason)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_delba_send_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_delba_send_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_DELBA_SEND_CMD) |\n\t\t\tFIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\tcmd->vdev_id = vdev_id;\n\tether_addr_copy(cmd->peer_macaddr.addr, mac);\n\tcmd->tid = tid;\n\tcmd->initiator = initiator;\n\tcmd->reasoncode = reason;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_DELBA_SEND_CMDID);\n\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to send WMI_DELBA_SEND_CMDID cmd\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"cmd delba send vdev_id 0x%X mac_addr %pM tid %u initiator %u reason %u\\n\",\n\t\t   vdev_id, mac, tid, initiator, reason);\n\n\treturn ret;\n}\n\nint ath11k_wmi_addba_set_resp(struct ath11k *ar, u32 vdev_id, const u8 *mac,\n\t\t\t      u32 tid, u32 status)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_addba_setresponse_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_addba_setresponse_cmd *)skb->data;\n\tcmd->tlv_header =\n\t\tFIELD_PREP(WMI_TLV_TAG, WMI_TAG_ADDBA_SETRESPONSE_CMD) |\n\t\tFIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\tcmd->vdev_id = vdev_id;\n\tether_addr_copy(cmd->peer_macaddr.addr, mac);\n\tcmd->tid = tid;\n\tcmd->statuscode = status;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_ADDBA_SET_RESP_CMDID);\n\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to send WMI_ADDBA_SET_RESP_CMDID cmd\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"cmd addba set resp vdev_id 0x%X mac_addr %pM tid %u status %u\\n\",\n\t\t   vdev_id, mac, tid, status);\n\n\treturn ret;\n}\n\nint ath11k_wmi_addba_send(struct ath11k *ar, u32 vdev_id, const u8 *mac,\n\t\t\t  u32 tid, u32 buf_size)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_addba_send_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_addba_send_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ADDBA_SEND_CMD) |\n\t\tFIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\tcmd->vdev_id = vdev_id;\n\tether_addr_copy(cmd->peer_macaddr.addr, mac);\n\tcmd->tid = tid;\n\tcmd->buffersize = buf_size;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_ADDBA_SEND_CMDID);\n\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to send WMI_ADDBA_SEND_CMDID cmd\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"cmd addba send vdev_id 0x%X mac_addr %pM tid %u bufsize %u\\n\",\n\t\t   vdev_id, mac, tid, buf_size);\n\n\treturn ret;\n}\n\nint ath11k_wmi_addba_clear_resp(struct ath11k *ar, u32 vdev_id, const u8 *mac)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_addba_clear_resp_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_addba_clear_resp_cmd *)skb->data;\n\tcmd->tlv_header =\n\t\tFIELD_PREP(WMI_TLV_TAG, WMI_TAG_ADDBA_CLEAR_RESP_CMD) |\n\t\tFIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\tcmd->vdev_id = vdev_id;\n\tether_addr_copy(cmd->peer_macaddr.addr, mac);\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_ADDBA_CLEAR_RESP_CMDID);\n\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to send WMI_ADDBA_CLEAR_RESP_CMDID cmd\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"cmd addba clear resp vdev_id 0x%X mac_addr %pM\\n\",\n\t\t   vdev_id, mac);\n\n\treturn ret;\n}\n\nint ath11k_wmi_pdev_peer_pktlog_filter(struct ath11k *ar, u8 *addr, u8 enable)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_pdev_pktlog_filter_cmd *cmd;\n\tstruct wmi_pdev_pktlog_filter_info *info;\n\tstruct sk_buff *skb;\n\tstruct wmi_tlv *tlv;\n\tvoid *ptr;\n\tint ret, len;\n\n\tlen = sizeof(*cmd) + sizeof(*info) + TLV_HDR_SIZE;\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_pdev_pktlog_filter_cmd *)skb->data;\n\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_PDEV_PEER_PKTLOG_FILTER_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->pdev_id = DP_HW2SW_MACID(ar->pdev->pdev_id);\n\tcmd->num_mac = 1;\n\tcmd->enable = enable;\n\n\tptr = skb->data + sizeof(*cmd);\n\n\ttlv = ptr;\n\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_STRUCT) |\n\t\t      FIELD_PREP(WMI_TLV_LEN, sizeof(*info));\n\n\tptr += TLV_HDR_SIZE;\n\tinfo = ptr;\n\n\tether_addr_copy(info->peer_macaddr.addr, addr);\n\tinfo->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_PDEV_PEER_PKTLOG_FILTER_INFO) |\n\t\t\t   FIELD_PREP(WMI_TLV_LEN,\n\t\t\t\t      sizeof(*info) - TLV_HDR_SIZE);\n\n\tret = ath11k_wmi_cmd_send(wmi, skb,\n\t\t\t\t  WMI_PDEV_PKTLOG_FILTER_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to send WMI_PDEV_PKTLOG_ENABLE_CMDID\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI, \"cmd pdev pktlog filter\");\n\n\treturn ret;\n}\n\nint\nath11k_wmi_send_init_country_cmd(struct ath11k *ar,\n\t\t\t\t struct wmi_init_country_params init_cc_params)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_init_country_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_init_country_cmd *)skb->data;\n\tcmd->tlv_header =\n\t\tFIELD_PREP(WMI_TLV_TAG,\n\t\t\t   WMI_TAG_SET_INIT_COUNTRY_CMD) |\n\t\tFIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->pdev_id = ar->pdev->pdev_id;\n\n\tswitch (init_cc_params.flags) {\n\tcase ALPHA_IS_SET:\n\t\tcmd->init_cc_type = WMI_COUNTRY_INFO_TYPE_ALPHA;\n\t\tmemcpy((u8 *)&cmd->cc_info.alpha2,\n\t\t       init_cc_params.cc_info.alpha2, 3);\n\t\tbreak;\n\tcase CC_IS_SET:\n\t\tcmd->init_cc_type = WMI_COUNTRY_INFO_TYPE_COUNTRY_CODE;\n\t\tcmd->cc_info.country_code = init_cc_params.cc_info.country_code;\n\t\tbreak;\n\tcase REGDMN_IS_SET:\n\t\tcmd->init_cc_type = WMI_COUNTRY_INFO_TYPE_REGDOMAIN;\n\t\tcmd->cc_info.regdom_id = init_cc_params.cc_info.regdom_id;\n\t\tbreak;\n\tdefault:\n\t\tath11k_warn(ar->ab, \"unknown cc params flags: 0x%x\",\n\t\t\t    init_cc_params.flags);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tret = ath11k_wmi_cmd_send(wmi, skb,\n\t\t\t\t  WMI_SET_INIT_COUNTRY_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to send WMI_SET_INIT_COUNTRY CMD :%d\\n\",\n\t\t\t    ret);\n\t\tgoto err;\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI, \"cmd set init country\");\n\n\treturn 0;\n\nerr:\n\tdev_kfree_skb(skb);\n\treturn ret;\n}\n\nint ath11k_wmi_send_set_current_country_cmd(struct ath11k *ar,\n\t\t\t\t\t    struct wmi_set_current_country_params *param)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_set_current_country_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_set_current_country_cmd *)skb->data;\n\tcmd->tlv_header =\n\t\tFIELD_PREP(WMI_TLV_TAG, WMI_TAG_SET_CURRENT_COUNTRY_CMD) |\n\t\tFIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->pdev_id = ar->pdev->pdev_id;\n\tmemcpy(&cmd->new_alpha2, &param->alpha2, 3);\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_SET_CURRENT_COUNTRY_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to send WMI_SET_CURRENT_COUNTRY_CMDID: %d\\n\", ret);\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"cmd set current country pdev id %d alpha2 %c%c\\n\",\n\t\t   ar->pdev->pdev_id,\n\t\t   param->alpha2[0],\n\t\t   param->alpha2[1]);\n\n\treturn ret;\n}\n\nint\nath11k_wmi_send_thermal_mitigation_param_cmd(struct ath11k *ar,\n\t\t\t\t\t     struct thermal_mitigation_params *param)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_therm_throt_config_request_cmd *cmd;\n\tstruct wmi_therm_throt_level_config_info *lvl_conf;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tint i, ret, len;\n\n\tlen = sizeof(*cmd) + TLV_HDR_SIZE +\n\t      THERMAL_LEVELS * sizeof(struct wmi_therm_throt_level_config_info);\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_therm_throt_config_request_cmd *)skb->data;\n\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_THERM_THROT_CONFIG_REQUEST) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->pdev_id = ar->pdev->pdev_id;\n\tcmd->enable = param->enable;\n\tcmd->dc = param->dc;\n\tcmd->dc_per_event = param->dc_per_event;\n\tcmd->therm_throt_levels = THERMAL_LEVELS;\n\n\ttlv = (struct wmi_tlv *)(skb->data + sizeof(*cmd));\n\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_STRUCT) |\n\t\t      FIELD_PREP(WMI_TLV_LEN,\n\t\t\t\t (THERMAL_LEVELS *\n\t\t\t\t  sizeof(struct wmi_therm_throt_level_config_info)));\n\n\tlvl_conf = (struct wmi_therm_throt_level_config_info *)(skb->data +\n\t\t\t\t\t\t\t\tsizeof(*cmd) +\n\t\t\t\t\t\t\t\tTLV_HDR_SIZE);\n\tfor (i = 0; i < THERMAL_LEVELS; i++) {\n\t\tlvl_conf->tlv_header =\n\t\t\tFIELD_PREP(WMI_TLV_TAG, WMI_TAG_THERM_THROT_LEVEL_CONFIG_INFO) |\n\t\t\tFIELD_PREP(WMI_TLV_LEN, sizeof(*lvl_conf) - TLV_HDR_SIZE);\n\n\t\tlvl_conf->temp_lwm = param->levelconf[i].tmplwm;\n\t\tlvl_conf->temp_hwm = param->levelconf[i].tmphwm;\n\t\tlvl_conf->dc_off_percent = param->levelconf[i].dcoffpercent;\n\t\tlvl_conf->prio = param->levelconf[i].priority;\n\t\tlvl_conf++;\n\t}\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_THERM_THROT_SET_CONF_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to send THERM_THROT_SET_CONF cmd\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"cmd therm throt set conf pdev_id %d enable %d dc %d dc_per_event %x levels %d\\n\",\n\t\t   ar->pdev->pdev_id, param->enable, param->dc,\n\t\t   param->dc_per_event, THERMAL_LEVELS);\n\n\treturn ret;\n}\n\nint ath11k_wmi_send_11d_scan_start_cmd(struct ath11k *ar,\n\t\t\t\t       struct wmi_11d_scan_start_params *param)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_11d_scan_start_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_11d_scan_start_cmd *)skb->data;\n\tcmd->tlv_header =\n\t\tFIELD_PREP(WMI_TLV_TAG, WMI_TAG_11D_SCAN_START_CMD) |\n\t\tFIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->vdev_id = param->vdev_id;\n\tcmd->scan_period_msec = param->scan_period_msec;\n\tcmd->start_interval_msec = param->start_interval_msec;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_11D_SCAN_START_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to send WMI_11D_SCAN_START_CMDID: %d\\n\", ret);\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"cmd 11d scan start vdev id %d period %d ms internal %d ms\\n\",\n\t\t   cmd->vdev_id,\n\t\t   cmd->scan_period_msec,\n\t\t   cmd->start_interval_msec);\n\n\treturn ret;\n}\n\nint ath11k_wmi_send_11d_scan_stop_cmd(struct ath11k *ar, u32 vdev_id)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_11d_scan_stop_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_11d_scan_stop_cmd *)skb->data;\n\tcmd->tlv_header =\n\t\tFIELD_PREP(WMI_TLV_TAG, WMI_TAG_11D_SCAN_STOP_CMD) |\n\t\tFIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->vdev_id = vdev_id;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_11D_SCAN_STOP_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to send WMI_11D_SCAN_STOP_CMDID: %d\\n\", ret);\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"cmd 11d scan stop vdev id %d\\n\",\n\t\t   cmd->vdev_id);\n\n\treturn ret;\n}\n\nint ath11k_wmi_pdev_pktlog_enable(struct ath11k *ar, u32 pktlog_filter)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_pktlog_enable_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_pktlog_enable_cmd *)skb->data;\n\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_PDEV_PKTLOG_ENABLE_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->pdev_id = DP_HW2SW_MACID(ar->pdev->pdev_id);\n\tcmd->evlist = pktlog_filter;\n\tcmd->enable = ATH11K_WMI_PKTLOG_ENABLE_FORCE;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb,\n\t\t\t\t  WMI_PDEV_PKTLOG_ENABLE_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to send WMI_PDEV_PKTLOG_ENABLE_CMDID\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI, \"cmd pdev pktlog enable\");\n\n\treturn ret;\n}\n\nint ath11k_wmi_pdev_pktlog_disable(struct ath11k *ar)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_pktlog_disable_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_pktlog_disable_cmd *)skb->data;\n\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_PDEV_PKTLOG_DISABLE_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->pdev_id = DP_HW2SW_MACID(ar->pdev->pdev_id);\n\n\tret = ath11k_wmi_cmd_send(wmi, skb,\n\t\t\t\t  WMI_PDEV_PKTLOG_DISABLE_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to send WMI_PDEV_PKTLOG_ENABLE_CMDID\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI, \"cmd pdev pktlog disable\");\n\n\treturn ret;\n}\n\nvoid ath11k_wmi_fill_default_twt_params(struct wmi_twt_enable_params *twt_params)\n{\n\ttwt_params->sta_cong_timer_ms = ATH11K_TWT_DEF_STA_CONG_TIMER_MS;\n\ttwt_params->default_slot_size = ATH11K_TWT_DEF_DEFAULT_SLOT_SIZE;\n\ttwt_params->congestion_thresh_setup = ATH11K_TWT_DEF_CONGESTION_THRESH_SETUP;\n\ttwt_params->congestion_thresh_teardown =\n\t\tATH11K_TWT_DEF_CONGESTION_THRESH_TEARDOWN;\n\ttwt_params->congestion_thresh_critical =\n\t\tATH11K_TWT_DEF_CONGESTION_THRESH_CRITICAL;\n\ttwt_params->interference_thresh_teardown =\n\t\tATH11K_TWT_DEF_INTERFERENCE_THRESH_TEARDOWN;\n\ttwt_params->interference_thresh_setup =\n\t\tATH11K_TWT_DEF_INTERFERENCE_THRESH_SETUP;\n\ttwt_params->min_no_sta_setup = ATH11K_TWT_DEF_MIN_NO_STA_SETUP;\n\ttwt_params->min_no_sta_teardown = ATH11K_TWT_DEF_MIN_NO_STA_TEARDOWN;\n\ttwt_params->no_of_bcast_mcast_slots = ATH11K_TWT_DEF_NO_OF_BCAST_MCAST_SLOTS;\n\ttwt_params->min_no_twt_slots = ATH11K_TWT_DEF_MIN_NO_TWT_SLOTS;\n\ttwt_params->max_no_sta_twt = ATH11K_TWT_DEF_MAX_NO_STA_TWT;\n\ttwt_params->mode_check_interval = ATH11K_TWT_DEF_MODE_CHECK_INTERVAL;\n\ttwt_params->add_sta_slot_interval = ATH11K_TWT_DEF_ADD_STA_SLOT_INTERVAL;\n\ttwt_params->remove_sta_slot_interval =\n\t\tATH11K_TWT_DEF_REMOVE_STA_SLOT_INTERVAL;\n\t \n\ttwt_params->mbss_support = 0;\n}\n\nint ath11k_wmi_send_twt_enable_cmd(struct ath11k *ar, u32 pdev_id,\n\t\t\t\t   struct wmi_twt_enable_params *params)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct ath11k_base *ab = wmi->wmi_ab->ab;\n\tstruct wmi_twt_enable_params_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret, len;\n\n\tlen = sizeof(*cmd);\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_twt_enable_params_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_TWT_ENABLE_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, len - TLV_HDR_SIZE);\n\tcmd->pdev_id = pdev_id;\n\tcmd->sta_cong_timer_ms = params->sta_cong_timer_ms;\n\tcmd->default_slot_size = params->default_slot_size;\n\tcmd->congestion_thresh_setup = params->congestion_thresh_setup;\n\tcmd->congestion_thresh_teardown = params->congestion_thresh_teardown;\n\tcmd->congestion_thresh_critical = params->congestion_thresh_critical;\n\tcmd->interference_thresh_teardown = params->interference_thresh_teardown;\n\tcmd->interference_thresh_setup = params->interference_thresh_setup;\n\tcmd->min_no_sta_setup = params->min_no_sta_setup;\n\tcmd->min_no_sta_teardown = params->min_no_sta_teardown;\n\tcmd->no_of_bcast_mcast_slots = params->no_of_bcast_mcast_slots;\n\tcmd->min_no_twt_slots = params->min_no_twt_slots;\n\tcmd->max_no_sta_twt = params->max_no_sta_twt;\n\tcmd->mode_check_interval = params->mode_check_interval;\n\tcmd->add_sta_slot_interval = params->add_sta_slot_interval;\n\tcmd->remove_sta_slot_interval = params->remove_sta_slot_interval;\n\tcmd->mbss_support = params->mbss_support;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_TWT_ENABLE_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ab, \"Failed to send WMI_TWT_ENABLE_CMDID\");\n\t\tdev_kfree_skb(skb);\n\t\treturn ret;\n\t}\n\n\tar->twt_enabled = 1;\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI, \"cmd twt enable\");\n\n\treturn 0;\n}\n\nint\nath11k_wmi_send_twt_disable_cmd(struct ath11k *ar, u32 pdev_id)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct ath11k_base *ab = wmi->wmi_ab->ab;\n\tstruct wmi_twt_disable_params_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret, len;\n\n\tlen = sizeof(*cmd);\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_twt_disable_params_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_TWT_DISABLE_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, len - TLV_HDR_SIZE);\n\tcmd->pdev_id = pdev_id;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_TWT_DISABLE_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ab, \"Failed to send WMI_TWT_DISABLE_CMDID\");\n\t\tdev_kfree_skb(skb);\n\t\treturn ret;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI, \"cmd twt disable\");\n\n\tar->twt_enabled = 0;\n\n\treturn 0;\n}\n\nint ath11k_wmi_send_twt_add_dialog_cmd(struct ath11k *ar,\n\t\t\t\t       struct wmi_twt_add_dialog_params *params)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct ath11k_base *ab = wmi->wmi_ab->ab;\n\tstruct wmi_twt_add_dialog_params_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret, len;\n\n\tlen = sizeof(*cmd);\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_twt_add_dialog_params_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_TWT_ADD_DIALOG_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, len - TLV_HDR_SIZE);\n\n\tcmd->vdev_id = params->vdev_id;\n\tether_addr_copy(cmd->peer_macaddr.addr, params->peer_macaddr);\n\tcmd->dialog_id = params->dialog_id;\n\tcmd->wake_intvl_us = params->wake_intvl_us;\n\tcmd->wake_intvl_mantis = params->wake_intvl_mantis;\n\tcmd->wake_dura_us = params->wake_dura_us;\n\tcmd->sp_offset_us = params->sp_offset_us;\n\tcmd->flags = params->twt_cmd;\n\tif (params->flag_bcast)\n\t\tcmd->flags |= WMI_TWT_ADD_DIALOG_FLAG_BCAST;\n\tif (params->flag_trigger)\n\t\tcmd->flags |= WMI_TWT_ADD_DIALOG_FLAG_TRIGGER;\n\tif (params->flag_flow_type)\n\t\tcmd->flags |= WMI_TWT_ADD_DIALOG_FLAG_FLOW_TYPE;\n\tif (params->flag_protection)\n\t\tcmd->flags |= WMI_TWT_ADD_DIALOG_FLAG_PROTECTION;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_TWT_ADD_DIALOG_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ab,\n\t\t\t    \"failed to send wmi command to add twt dialog: %d\",\n\t\t\t    ret);\n\t\tdev_kfree_skb(skb);\n\t\treturn ret;\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"cmd twt add dialog vdev %u dialog id %u wake interval %u mantissa %u wake duration %u service period offset %u flags 0x%x\\n\",\n\t\t   cmd->vdev_id, cmd->dialog_id, cmd->wake_intvl_us,\n\t\t   cmd->wake_intvl_mantis, cmd->wake_dura_us, cmd->sp_offset_us,\n\t\t   cmd->flags);\n\n\treturn 0;\n}\n\nint ath11k_wmi_send_twt_del_dialog_cmd(struct ath11k *ar,\n\t\t\t\t       struct wmi_twt_del_dialog_params *params)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct ath11k_base *ab = wmi->wmi_ab->ab;\n\tstruct wmi_twt_del_dialog_params_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret, len;\n\n\tlen = sizeof(*cmd);\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_twt_del_dialog_params_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_TWT_DEL_DIALOG_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, len - TLV_HDR_SIZE);\n\n\tcmd->vdev_id = params->vdev_id;\n\tether_addr_copy(cmd->peer_macaddr.addr, params->peer_macaddr);\n\tcmd->dialog_id = params->dialog_id;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_TWT_DEL_DIALOG_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ab,\n\t\t\t    \"failed to send wmi command to delete twt dialog: %d\",\n\t\t\t    ret);\n\t\tdev_kfree_skb(skb);\n\t\treturn ret;\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"cmd twt del dialog vdev %u dialog id %u\\n\",\n\t\t   cmd->vdev_id, cmd->dialog_id);\n\n\treturn 0;\n}\n\nint ath11k_wmi_send_twt_pause_dialog_cmd(struct ath11k *ar,\n\t\t\t\t\t struct wmi_twt_pause_dialog_params *params)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct ath11k_base *ab = wmi->wmi_ab->ab;\n\tstruct wmi_twt_pause_dialog_params_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret, len;\n\n\tlen = sizeof(*cmd);\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_twt_pause_dialog_params_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t     WMI_TAG_TWT_PAUSE_DIALOG_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, len - TLV_HDR_SIZE);\n\n\tcmd->vdev_id = params->vdev_id;\n\tether_addr_copy(cmd->peer_macaddr.addr, params->peer_macaddr);\n\tcmd->dialog_id = params->dialog_id;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_TWT_PAUSE_DIALOG_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ab,\n\t\t\t    \"failed to send wmi command to pause twt dialog: %d\",\n\t\t\t    ret);\n\t\tdev_kfree_skb(skb);\n\t\treturn ret;\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"cmd twt pause dialog vdev %u dialog id %u\\n\",\n\t\t   cmd->vdev_id, cmd->dialog_id);\n\n\treturn 0;\n}\n\nint ath11k_wmi_send_twt_resume_dialog_cmd(struct ath11k *ar,\n\t\t\t\t\t  struct wmi_twt_resume_dialog_params *params)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct ath11k_base *ab = wmi->wmi_ab->ab;\n\tstruct wmi_twt_resume_dialog_params_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret, len;\n\n\tlen = sizeof(*cmd);\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_twt_resume_dialog_params_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t     WMI_TAG_TWT_RESUME_DIALOG_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, len - TLV_HDR_SIZE);\n\n\tcmd->vdev_id = params->vdev_id;\n\tether_addr_copy(cmd->peer_macaddr.addr, params->peer_macaddr);\n\tcmd->dialog_id = params->dialog_id;\n\tcmd->sp_offset_us = params->sp_offset_us;\n\tcmd->next_twt_size = params->next_twt_size;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_TWT_RESUME_DIALOG_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ab,\n\t\t\t    \"failed to send wmi command to resume twt dialog: %d\",\n\t\t\t    ret);\n\t\tdev_kfree_skb(skb);\n\t\treturn ret;\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"cmd twt resume dialog vdev %u dialog id %u service period offset %u next twt subfield size %u\\n\",\n\t\t   cmd->vdev_id, cmd->dialog_id, cmd->sp_offset_us,\n\t\t   cmd->next_twt_size);\n\n\treturn 0;\n}\n\nint\nath11k_wmi_send_obss_spr_cmd(struct ath11k *ar, u32 vdev_id,\n\t\t\t     struct ieee80211_he_obss_pd *he_obss_pd)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct ath11k_base *ab = wmi->wmi_ab->ab;\n\tstruct wmi_obss_spatial_reuse_params_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret, len;\n\n\tlen = sizeof(*cmd);\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_obss_spatial_reuse_params_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t     WMI_TAG_OBSS_SPATIAL_REUSE_SET_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, len - TLV_HDR_SIZE);\n\tcmd->vdev_id = vdev_id;\n\tcmd->enable = he_obss_pd->enable;\n\tcmd->obss_min = he_obss_pd->min_offset;\n\tcmd->obss_max = he_obss_pd->max_offset;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb,\n\t\t\t\t  WMI_PDEV_OBSS_PD_SPATIAL_REUSE_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ab,\n\t\t\t    \"Failed to send WMI_PDEV_OBSS_PD_SPATIAL_REUSE_CMDID\");\n\t\tdev_kfree_skb(skb);\n\t\treturn ret;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI, \"cmd pdev obss pd spatial reuse\");\n\n\treturn 0;\n}\n\nint\nath11k_wmi_pdev_set_srg_bss_color_bitmap(struct ath11k *ar, u32 *bitmap)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct ath11k_base *ab = wmi->wmi_ab->ab;\n\tstruct wmi_pdev_obss_pd_bitmap_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret, len;\n\n\tlen = sizeof(*cmd);\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_pdev_obss_pd_bitmap_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t     WMI_TAG_PDEV_SRG_BSS_COLOR_BITMAP_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, len - TLV_HDR_SIZE);\n\tcmd->pdev_id = ar->pdev->pdev_id;\n\tmemcpy(cmd->bitmap, bitmap, sizeof(cmd->bitmap));\n\n\tret = ath11k_wmi_cmd_send(wmi, skb,\n\t\t\t\t  WMI_PDEV_SET_SRG_BSS_COLOR_BITMAP_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ab,\n\t\t\t    \"failed to send WMI_PDEV_SET_SRG_BSS_COLOR_BITMAP_CMDID\");\n\t\tdev_kfree_skb(skb);\n\t\treturn ret;\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"cmd pdev set srg bss color bitmap pdev_id %d bss color bitmap %08x %08x\\n\",\n\t\t   cmd->pdev_id, cmd->bitmap[0], cmd->bitmap[1]);\n\n\treturn 0;\n}\n\nint\nath11k_wmi_pdev_set_srg_patial_bssid_bitmap(struct ath11k *ar, u32 *bitmap)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct ath11k_base *ab = wmi->wmi_ab->ab;\n\tstruct wmi_pdev_obss_pd_bitmap_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret, len;\n\n\tlen = sizeof(*cmd);\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_pdev_obss_pd_bitmap_cmd *)skb->data;\n\tcmd->tlv_header =\n\t\tFIELD_PREP(WMI_TLV_TAG,\n\t\t\t   WMI_TAG_PDEV_SRG_PARTIAL_BSSID_BITMAP_CMD) |\n\t\tFIELD_PREP(WMI_TLV_LEN, len - TLV_HDR_SIZE);\n\tcmd->pdev_id = ar->pdev->pdev_id;\n\tmemcpy(cmd->bitmap, bitmap, sizeof(cmd->bitmap));\n\n\tret = ath11k_wmi_cmd_send(wmi, skb,\n\t\t\t\t  WMI_PDEV_SET_SRG_PARTIAL_BSSID_BITMAP_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ab,\n\t\t\t    \"failed to send WMI_PDEV_SET_SRG_PARTIAL_BSSID_BITMAP_CMDID\");\n\t\tdev_kfree_skb(skb);\n\t\treturn ret;\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"cmd pdev set srg partial bssid bitmap pdev_id %d partial bssid bitmap %08x %08x\\n\",\n\t\t   cmd->pdev_id, cmd->bitmap[0], cmd->bitmap[1]);\n\n\treturn 0;\n}\n\nint\nath11k_wmi_pdev_srg_obss_color_enable_bitmap(struct ath11k *ar, u32 *bitmap)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct ath11k_base *ab = wmi->wmi_ab->ab;\n\tstruct wmi_pdev_obss_pd_bitmap_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret, len;\n\n\tlen = sizeof(*cmd);\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_pdev_obss_pd_bitmap_cmd *)skb->data;\n\tcmd->tlv_header =\n\t\tFIELD_PREP(WMI_TLV_TAG,\n\t\t\t   WMI_TAG_PDEV_SRG_OBSS_COLOR_ENABLE_BITMAP_CMD) |\n\t\tFIELD_PREP(WMI_TLV_LEN, len - TLV_HDR_SIZE);\n\tcmd->pdev_id = ar->pdev->pdev_id;\n\tmemcpy(cmd->bitmap, bitmap, sizeof(cmd->bitmap));\n\n\tret = ath11k_wmi_cmd_send(wmi, skb,\n\t\t\t\t  WMI_PDEV_SET_SRG_OBSS_COLOR_ENABLE_BITMAP_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ab,\n\t\t\t    \"failed to send WMI_PDEV_SET_SRG_OBSS_COLOR_ENABLE_BITMAP_CMDID\");\n\t\tdev_kfree_skb(skb);\n\t\treturn ret;\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"cmd pdev set srg obsscolor enable pdev_id %d bss color enable bitmap %08x %08x\\n\",\n\t\t   cmd->pdev_id, cmd->bitmap[0], cmd->bitmap[1]);\n\n\treturn 0;\n}\n\nint\nath11k_wmi_pdev_srg_obss_bssid_enable_bitmap(struct ath11k *ar, u32 *bitmap)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct ath11k_base *ab = wmi->wmi_ab->ab;\n\tstruct wmi_pdev_obss_pd_bitmap_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret, len;\n\n\tlen = sizeof(*cmd);\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_pdev_obss_pd_bitmap_cmd *)skb->data;\n\tcmd->tlv_header =\n\t\tFIELD_PREP(WMI_TLV_TAG,\n\t\t\t   WMI_TAG_PDEV_SRG_OBSS_BSSID_ENABLE_BITMAP_CMD) |\n\t\tFIELD_PREP(WMI_TLV_LEN, len - TLV_HDR_SIZE);\n\tcmd->pdev_id = ar->pdev->pdev_id;\n\tmemcpy(cmd->bitmap, bitmap, sizeof(cmd->bitmap));\n\n\tret = ath11k_wmi_cmd_send(wmi, skb,\n\t\t\t\t  WMI_PDEV_SET_SRG_OBSS_BSSID_ENABLE_BITMAP_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ab,\n\t\t\t    \"failed to send WMI_PDEV_SET_SRG_OBSS_BSSID_ENABLE_BITMAP_CMDID\");\n\t\tdev_kfree_skb(skb);\n\t\treturn ret;\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"cmd pdev set srg obss bssid enable bitmap pdev_id %d bssid enable bitmap %08x %08x\\n\",\n\t\t   cmd->pdev_id, cmd->bitmap[0], cmd->bitmap[1]);\n\n\treturn 0;\n}\n\nint\nath11k_wmi_pdev_non_srg_obss_color_enable_bitmap(struct ath11k *ar, u32 *bitmap)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct ath11k_base *ab = wmi->wmi_ab->ab;\n\tstruct wmi_pdev_obss_pd_bitmap_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret, len;\n\n\tlen = sizeof(*cmd);\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_pdev_obss_pd_bitmap_cmd *)skb->data;\n\tcmd->tlv_header =\n\t\tFIELD_PREP(WMI_TLV_TAG,\n\t\t\t   WMI_TAG_PDEV_NON_SRG_OBSS_COLOR_ENABLE_BITMAP_CMD) |\n\t\tFIELD_PREP(WMI_TLV_LEN, len - TLV_HDR_SIZE);\n\tcmd->pdev_id = ar->pdev->pdev_id;\n\tmemcpy(cmd->bitmap, bitmap, sizeof(cmd->bitmap));\n\n\tret = ath11k_wmi_cmd_send(wmi, skb,\n\t\t\t\t  WMI_PDEV_SET_NON_SRG_OBSS_COLOR_ENABLE_BITMAP_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ab,\n\t\t\t    \"failed to send WMI_PDEV_SET_NON_SRG_OBSS_COLOR_ENABLE_BITMAP_CMDID\");\n\t\tdev_kfree_skb(skb);\n\t\treturn ret;\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"cmd pdev set non srg obss color enable bitmap pdev_id %d bss color enable bitmap %08x %08x\\n\",\n\t\t   cmd->pdev_id, cmd->bitmap[0], cmd->bitmap[1]);\n\n\treturn 0;\n}\n\nint\nath11k_wmi_pdev_non_srg_obss_bssid_enable_bitmap(struct ath11k *ar, u32 *bitmap)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct ath11k_base *ab = wmi->wmi_ab->ab;\n\tstruct wmi_pdev_obss_pd_bitmap_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret, len;\n\n\tlen = sizeof(*cmd);\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_pdev_obss_pd_bitmap_cmd *)skb->data;\n\tcmd->tlv_header =\n\t\tFIELD_PREP(WMI_TLV_TAG,\n\t\t\t   WMI_TAG_PDEV_NON_SRG_OBSS_BSSID_ENABLE_BITMAP_CMD) |\n\t\tFIELD_PREP(WMI_TLV_LEN, len - TLV_HDR_SIZE);\n\tcmd->pdev_id = ar->pdev->pdev_id;\n\tmemcpy(cmd->bitmap, bitmap, sizeof(cmd->bitmap));\n\n\tret = ath11k_wmi_cmd_send(wmi, skb,\n\t\t\t\t  WMI_PDEV_SET_NON_SRG_OBSS_BSSID_ENABLE_BITMAP_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ab,\n\t\t\t    \"failed to send WMI_PDEV_SET_NON_SRG_OBSS_BSSID_ENABLE_BITMAP_CMDID\");\n\t\tdev_kfree_skb(skb);\n\t\treturn ret;\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"cmd pdev set non srg obss bssid enable bitmap pdev_id %d bssid enable bitmap %08x %08x\\n\",\n\t\t   cmd->pdev_id, cmd->bitmap[0], cmd->bitmap[1]);\n\n\treturn 0;\n}\n\nint\nath11k_wmi_send_obss_color_collision_cfg_cmd(struct ath11k *ar, u32 vdev_id,\n\t\t\t\t\t     u8 bss_color, u32 period,\n\t\t\t\t\t     bool enable)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct ath11k_base *ab = wmi->wmi_ab->ab;\n\tstruct wmi_obss_color_collision_cfg_params_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret, len;\n\n\tlen = sizeof(*cmd);\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_obss_color_collision_cfg_params_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t     WMI_TAG_OBSS_COLOR_COLLISION_DET_CONFIG) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, len - TLV_HDR_SIZE);\n\tcmd->vdev_id = vdev_id;\n\tcmd->evt_type = enable ? ATH11K_OBSS_COLOR_COLLISION_DETECTION :\n\t\t\t\t ATH11K_OBSS_COLOR_COLLISION_DETECTION_DISABLE;\n\tcmd->current_bss_color = bss_color;\n\tcmd->detection_period_ms = period;\n\tcmd->scan_period_ms = ATH11K_BSS_COLOR_COLLISION_SCAN_PERIOD_MS;\n\tcmd->free_slot_expiry_time_ms = 0;\n\tcmd->flags = 0;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb,\n\t\t\t\t  WMI_OBSS_COLOR_COLLISION_DET_CONFIG_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ab, \"Failed to send WMI_OBSS_COLOR_COLLISION_DET_CONFIG_CMDID\");\n\t\tdev_kfree_skb(skb);\n\t\treturn ret;\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"cmd obss color collision det config id %d type %d bss_color %d detect_period %d scan_period %d\\n\",\n\t\t   cmd->vdev_id, cmd->evt_type, cmd->current_bss_color,\n\t\t   cmd->detection_period_ms, cmd->scan_period_ms);\n\n\treturn 0;\n}\n\nint ath11k_wmi_send_bss_color_change_enable_cmd(struct ath11k *ar, u32 vdev_id,\n\t\t\t\t\t\tbool enable)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct ath11k_base *ab = wmi->wmi_ab->ab;\n\tstruct wmi_bss_color_change_enable_params_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret, len;\n\n\tlen = sizeof(*cmd);\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_bss_color_change_enable_params_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_BSS_COLOR_CHANGE_ENABLE) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, len - TLV_HDR_SIZE);\n\tcmd->vdev_id = vdev_id;\n\tcmd->enable = enable ? 1 : 0;\n\n\tret = ath11k_wmi_cmd_send(wmi, skb,\n\t\t\t\t  WMI_BSS_COLOR_CHANGE_ENABLE_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ab, \"Failed to send WMI_BSS_COLOR_CHANGE_ENABLE_CMDID\");\n\t\tdev_kfree_skb(skb);\n\t\treturn ret;\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"cmd bss color change enable id %d enable %d\\n\",\n\t\t   cmd->vdev_id, cmd->enable);\n\n\treturn 0;\n}\n\nint ath11k_wmi_fils_discovery_tmpl(struct ath11k *ar, u32 vdev_id,\n\t\t\t\t   struct sk_buff *tmpl)\n{\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tvoid *ptr;\n\tint ret, len;\n\tsize_t aligned_len;\n\tstruct wmi_fils_discovery_tmpl_cmd *cmd;\n\n\taligned_len = roundup(tmpl->len, 4);\n\tlen = sizeof(*cmd) + TLV_HDR_SIZE + aligned_len;\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"vdev %i set FILS discovery template\\n\", vdev_id);\n\n\tskb = ath11k_wmi_alloc_skb(ar->wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_fils_discovery_tmpl_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t     WMI_TAG_FILS_DISCOVERY_TMPL_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\tcmd->vdev_id = vdev_id;\n\tcmd->buf_len = tmpl->len;\n\tptr = skb->data + sizeof(*cmd);\n\n\ttlv = ptr;\n\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_BYTE) |\n\t\t      FIELD_PREP(WMI_TLV_LEN, aligned_len);\n\tmemcpy(tlv->value, tmpl->data, tmpl->len);\n\n\tret = ath11k_wmi_cmd_send(ar->wmi, skb, WMI_FILS_DISCOVERY_TMPL_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"WMI vdev %i failed to send FILS discovery template command\\n\",\n\t\t\t    vdev_id);\n\t\tdev_kfree_skb(skb);\n\t\treturn ret;\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI, \"cmd fils discovery tmpl\");\n\n\treturn 0;\n}\n\nint ath11k_wmi_probe_resp_tmpl(struct ath11k *ar, u32 vdev_id,\n\t\t\t       struct sk_buff *tmpl)\n{\n\tstruct wmi_probe_tmpl_cmd *cmd;\n\tstruct wmi_bcn_prb_info *probe_info;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tvoid *ptr;\n\tint ret, len;\n\tsize_t aligned_len = roundup(tmpl->len, 4);\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"vdev %i set probe response template\\n\", vdev_id);\n\n\tlen = sizeof(*cmd) + sizeof(*probe_info) + TLV_HDR_SIZE + aligned_len;\n\n\tskb = ath11k_wmi_alloc_skb(ar->wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_probe_tmpl_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_PRB_TMPL_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\tcmd->vdev_id = vdev_id;\n\tcmd->buf_len = tmpl->len;\n\n\tptr = skb->data + sizeof(*cmd);\n\n\tprobe_info = ptr;\n\tlen = sizeof(*probe_info);\n\tprobe_info->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t\t    WMI_TAG_BCN_PRB_INFO) |\n\t\t\t\t FIELD_PREP(WMI_TLV_LEN, len - TLV_HDR_SIZE);\n\tprobe_info->caps = 0;\n\tprobe_info->erp = 0;\n\n\tptr += sizeof(*probe_info);\n\n\ttlv = ptr;\n\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_BYTE) |\n\t\t      FIELD_PREP(WMI_TLV_LEN, aligned_len);\n\tmemcpy(tlv->value, tmpl->data, tmpl->len);\n\n\tret = ath11k_wmi_cmd_send(ar->wmi, skb, WMI_PRB_TMPL_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"WMI vdev %i failed to send probe response template command\\n\",\n\t\t\t    vdev_id);\n\t\tdev_kfree_skb(skb);\n\t\treturn ret;\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI, \"cmd \");\n\n\treturn 0;\n}\n\nint ath11k_wmi_fils_discovery(struct ath11k *ar, u32 vdev_id, u32 interval,\n\t\t\t      bool unsol_bcast_probe_resp_enabled)\n{\n\tstruct sk_buff *skb;\n\tint ret, len;\n\tstruct wmi_fils_discovery_cmd *cmd;\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"vdev %i set %s interval to %u TU\\n\",\n\t\t   vdev_id, unsol_bcast_probe_resp_enabled ?\n\t\t   \"unsolicited broadcast probe response\" : \"FILS discovery\",\n\t\t   interval);\n\n\tlen = sizeof(*cmd);\n\tskb = ath11k_wmi_alloc_skb(ar->wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_fils_discovery_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ENABLE_FILS_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, len - TLV_HDR_SIZE);\n\tcmd->vdev_id = vdev_id;\n\tcmd->interval = interval;\n\tcmd->config = unsol_bcast_probe_resp_enabled;\n\n\tret = ath11k_wmi_cmd_send(ar->wmi, skb, WMI_ENABLE_FILS_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"WMI vdev %i failed to send FILS discovery enable/disable command\\n\",\n\t\t\t    vdev_id);\n\t\tdev_kfree_skb(skb);\n\t\treturn ret;\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI, \"cmd enable fils\");\n\n\treturn 0;\n}\n\nstatic void\nath11k_wmi_obss_color_collision_event(struct ath11k_base *ab, struct sk_buff *skb)\n{\n\tconst void **tb;\n\tconst struct wmi_obss_color_collision_event *ev;\n\tstruct ath11k_vif *arvif;\n\tint ret;\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI, \"event obss color collision\");\n\n\trcu_read_lock();\n\n\tev = tb[WMI_TAG_OBSS_COLOR_COLLISION_EVT];\n\tif (!ev) {\n\t\tath11k_warn(ab, \"failed to fetch obss color collision ev\");\n\t\tgoto exit;\n\t}\n\n\tarvif = ath11k_mac_get_arvif_by_vdev_id(ab, ev->vdev_id);\n\tif (!arvif) {\n\t\tath11k_warn(ab, \"failed to find arvif with vedv id %d in obss_color_collision_event\\n\",\n\t\t\t    ev->vdev_id);\n\t\tgoto exit;\n\t}\n\n\tswitch (ev->evt_type) {\n\tcase WMI_BSS_COLOR_COLLISION_DETECTION:\n\t\tieee80211_obss_color_collision_notify(arvif->vif, ev->obss_color_bitmap,\n\t\t\t\t\t\t      GFP_KERNEL);\n\t\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t\t   \"OBSS color collision detected vdev:%d, event:%d, bitmap:%08llx\\n\",\n\t\t\t   ev->vdev_id, ev->evt_type, ev->obss_color_bitmap);\n\t\tbreak;\n\tcase WMI_BSS_COLOR_COLLISION_DISABLE:\n\tcase WMI_BSS_COLOR_FREE_SLOT_TIMER_EXPIRY:\n\tcase WMI_BSS_COLOR_FREE_SLOT_AVAILABLE:\n\t\tbreak;\n\tdefault:\n\t\tath11k_warn(ab, \"received unknown obss color collision detection event\\n\");\n\t}\n\nexit:\n\tkfree(tb);\n\trcu_read_unlock();\n}\n\nstatic void\nath11k_fill_band_to_mac_param(struct ath11k_base  *soc,\n\t\t\t      struct wmi_host_pdev_band_to_mac *band_to_mac)\n{\n\tu8 i;\n\tstruct ath11k_hal_reg_capabilities_ext *hal_reg_cap;\n\tstruct ath11k_pdev *pdev;\n\n\tfor (i = 0; i < soc->num_radios; i++) {\n\t\tpdev = &soc->pdevs[i];\n\t\thal_reg_cap = &soc->hal_reg_cap[i];\n\t\tband_to_mac[i].pdev_id = pdev->pdev_id;\n\n\t\tswitch (pdev->cap.supported_bands) {\n\t\tcase WMI_HOST_WLAN_2G_5G_CAP:\n\t\t\tband_to_mac[i].start_freq = hal_reg_cap->low_2ghz_chan;\n\t\t\tband_to_mac[i].end_freq = hal_reg_cap->high_5ghz_chan;\n\t\t\tbreak;\n\t\tcase WMI_HOST_WLAN_2G_CAP:\n\t\t\tband_to_mac[i].start_freq = hal_reg_cap->low_2ghz_chan;\n\t\t\tband_to_mac[i].end_freq = hal_reg_cap->high_2ghz_chan;\n\t\t\tbreak;\n\t\tcase WMI_HOST_WLAN_5G_CAP:\n\t\t\tband_to_mac[i].start_freq = hal_reg_cap->low_5ghz_chan;\n\t\t\tband_to_mac[i].end_freq = hal_reg_cap->high_5ghz_chan;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void\nath11k_wmi_copy_resource_config(struct wmi_resource_config *wmi_cfg,\n\t\t\t\tstruct target_resource_config *tg_cfg)\n{\n\twmi_cfg->num_vdevs = tg_cfg->num_vdevs;\n\twmi_cfg->num_peers = tg_cfg->num_peers;\n\twmi_cfg->num_offload_peers = tg_cfg->num_offload_peers;\n\twmi_cfg->num_offload_reorder_buffs = tg_cfg->num_offload_reorder_buffs;\n\twmi_cfg->num_peer_keys = tg_cfg->num_peer_keys;\n\twmi_cfg->num_tids = tg_cfg->num_tids;\n\twmi_cfg->ast_skid_limit = tg_cfg->ast_skid_limit;\n\twmi_cfg->tx_chain_mask = tg_cfg->tx_chain_mask;\n\twmi_cfg->rx_chain_mask = tg_cfg->rx_chain_mask;\n\twmi_cfg->rx_timeout_pri[0] = tg_cfg->rx_timeout_pri[0];\n\twmi_cfg->rx_timeout_pri[1] = tg_cfg->rx_timeout_pri[1];\n\twmi_cfg->rx_timeout_pri[2] = tg_cfg->rx_timeout_pri[2];\n\twmi_cfg->rx_timeout_pri[3] = tg_cfg->rx_timeout_pri[3];\n\twmi_cfg->rx_decap_mode = tg_cfg->rx_decap_mode;\n\twmi_cfg->scan_max_pending_req = tg_cfg->scan_max_pending_req;\n\twmi_cfg->bmiss_offload_max_vdev = tg_cfg->bmiss_offload_max_vdev;\n\twmi_cfg->roam_offload_max_vdev = tg_cfg->roam_offload_max_vdev;\n\twmi_cfg->roam_offload_max_ap_profiles =\n\t\ttg_cfg->roam_offload_max_ap_profiles;\n\twmi_cfg->num_mcast_groups = tg_cfg->num_mcast_groups;\n\twmi_cfg->num_mcast_table_elems = tg_cfg->num_mcast_table_elems;\n\twmi_cfg->mcast2ucast_mode = tg_cfg->mcast2ucast_mode;\n\twmi_cfg->tx_dbg_log_size = tg_cfg->tx_dbg_log_size;\n\twmi_cfg->num_wds_entries = tg_cfg->num_wds_entries;\n\twmi_cfg->dma_burst_size = tg_cfg->dma_burst_size;\n\twmi_cfg->mac_aggr_delim = tg_cfg->mac_aggr_delim;\n\twmi_cfg->rx_skip_defrag_timeout_dup_detection_check =\n\t\ttg_cfg->rx_skip_defrag_timeout_dup_detection_check;\n\twmi_cfg->vow_config = tg_cfg->vow_config;\n\twmi_cfg->gtk_offload_max_vdev = tg_cfg->gtk_offload_max_vdev;\n\twmi_cfg->num_msdu_desc = tg_cfg->num_msdu_desc;\n\twmi_cfg->max_frag_entries = tg_cfg->max_frag_entries;\n\twmi_cfg->num_tdls_vdevs = tg_cfg->num_tdls_vdevs;\n\twmi_cfg->num_tdls_conn_table_entries =\n\t\ttg_cfg->num_tdls_conn_table_entries;\n\twmi_cfg->beacon_tx_offload_max_vdev =\n\t\ttg_cfg->beacon_tx_offload_max_vdev;\n\twmi_cfg->num_multicast_filter_entries =\n\t\ttg_cfg->num_multicast_filter_entries;\n\twmi_cfg->num_wow_filters = tg_cfg->num_wow_filters;\n\twmi_cfg->num_keep_alive_pattern = tg_cfg->num_keep_alive_pattern;\n\twmi_cfg->keep_alive_pattern_size = tg_cfg->keep_alive_pattern_size;\n\twmi_cfg->max_tdls_concurrent_sleep_sta =\n\t\ttg_cfg->max_tdls_concurrent_sleep_sta;\n\twmi_cfg->max_tdls_concurrent_buffer_sta =\n\t\ttg_cfg->max_tdls_concurrent_buffer_sta;\n\twmi_cfg->wmi_send_separate = tg_cfg->wmi_send_separate;\n\twmi_cfg->num_ocb_vdevs = tg_cfg->num_ocb_vdevs;\n\twmi_cfg->num_ocb_channels = tg_cfg->num_ocb_channels;\n\twmi_cfg->num_ocb_schedules = tg_cfg->num_ocb_schedules;\n\twmi_cfg->bpf_instruction_size = tg_cfg->bpf_instruction_size;\n\twmi_cfg->max_bssid_rx_filters = tg_cfg->max_bssid_rx_filters;\n\twmi_cfg->use_pdev_id = tg_cfg->use_pdev_id;\n\twmi_cfg->flag1 = tg_cfg->flag1;\n\twmi_cfg->peer_map_unmap_v2_support = tg_cfg->peer_map_unmap_v2_support;\n\twmi_cfg->sched_params = tg_cfg->sched_params;\n\twmi_cfg->twt_ap_pdev_count = tg_cfg->twt_ap_pdev_count;\n\twmi_cfg->twt_ap_sta_count = tg_cfg->twt_ap_sta_count;\n\twmi_cfg->host_service_flags &=\n\t\t~(1 << WMI_CFG_HOST_SERVICE_FLAG_REG_CC_EXT);\n\twmi_cfg->host_service_flags |= (tg_cfg->is_reg_cc_ext_event_supported <<\n\t\t\t\t\tWMI_CFG_HOST_SERVICE_FLAG_REG_CC_EXT);\n\twmi_cfg->flags2 = WMI_RSRC_CFG_FLAG2_CALC_NEXT_DTIM_COUNT_SET;\n\twmi_cfg->ema_max_vap_cnt = tg_cfg->ema_max_vap_cnt;\n\twmi_cfg->ema_max_profile_period = tg_cfg->ema_max_profile_period;\n}\n\nstatic int ath11k_init_cmd_send(struct ath11k_pdev_wmi *wmi,\n\t\t\t\tstruct wmi_init_cmd_param *param)\n{\n\tstruct ath11k_base *ab = wmi->wmi_ab->ab;\n\tstruct sk_buff *skb;\n\tstruct wmi_init_cmd *cmd;\n\tstruct wmi_resource_config *cfg;\n\tstruct wmi_pdev_set_hw_mode_cmd_param *hw_mode;\n\tstruct wmi_pdev_band_to_mac *band_to_mac;\n\tstruct wlan_host_mem_chunk *host_mem_chunks;\n\tstruct wmi_tlv *tlv;\n\tsize_t ret, len;\n\tvoid *ptr;\n\tu32 hw_mode_len = 0;\n\tu16 idx;\n\n\tif (param->hw_mode_id != WMI_HOST_HW_MODE_MAX)\n\t\thw_mode_len = sizeof(*hw_mode) + TLV_HDR_SIZE +\n\t\t\t      (param->num_band_to_mac * sizeof(*band_to_mac));\n\n\tlen = sizeof(*cmd) + TLV_HDR_SIZE + sizeof(*cfg) + hw_mode_len +\n\t      (param->num_mem_chunks ? (sizeof(*host_mem_chunks) * WMI_MAX_MEM_REQS) : 0);\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_init_cmd *)skb->data;\n\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_INIT_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tptr = skb->data + sizeof(*cmd);\n\tcfg = ptr;\n\n\tath11k_wmi_copy_resource_config(cfg, param->res_cfg);\n\n\tcfg->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_RESOURCE_CONFIG) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cfg) - TLV_HDR_SIZE);\n\n\tptr += sizeof(*cfg);\n\thost_mem_chunks = ptr + TLV_HDR_SIZE;\n\tlen = sizeof(struct wlan_host_mem_chunk);\n\n\tfor (idx = 0; idx < param->num_mem_chunks; ++idx) {\n\t\thost_mem_chunks[idx].tlv_header =\n\t\t\t\tFIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t\t   WMI_TAG_WLAN_HOST_MEMORY_CHUNK) |\n\t\t\t\tFIELD_PREP(WMI_TLV_LEN, len);\n\n\t\thost_mem_chunks[idx].ptr = param->mem_chunks[idx].paddr;\n\t\thost_mem_chunks[idx].size = param->mem_chunks[idx].len;\n\t\thost_mem_chunks[idx].req_id = param->mem_chunks[idx].req_id;\n\n\t\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t\t   \"host mem chunk req_id %d paddr 0x%llx len %d\\n\",\n\t\t\t   param->mem_chunks[idx].req_id,\n\t\t\t   (u64)param->mem_chunks[idx].paddr,\n\t\t\t   param->mem_chunks[idx].len);\n\t}\n\tcmd->num_host_mem_chunks = param->num_mem_chunks;\n\tlen = sizeof(struct wlan_host_mem_chunk) * param->num_mem_chunks;\n\n\t \n\ttlv = ptr;\n\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_STRUCT) |\n\t\t      FIELD_PREP(WMI_TLV_LEN, len);\n\tptr += TLV_HDR_SIZE + len;\n\n\tif (param->hw_mode_id != WMI_HOST_HW_MODE_MAX) {\n\t\thw_mode = (struct wmi_pdev_set_hw_mode_cmd_param *)ptr;\n\t\thw_mode->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t\t\t WMI_TAG_PDEV_SET_HW_MODE_CMD) |\n\t\t\t\t      FIELD_PREP(WMI_TLV_LEN,\n\t\t\t\t\t\t sizeof(*hw_mode) - TLV_HDR_SIZE);\n\n\t\thw_mode->hw_mode_index = param->hw_mode_id;\n\t\thw_mode->num_band_to_mac = param->num_band_to_mac;\n\n\t\tptr += sizeof(*hw_mode);\n\n\t\tlen = param->num_band_to_mac * sizeof(*band_to_mac);\n\t\ttlv = ptr;\n\t\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_STRUCT) |\n\t\t\t      FIELD_PREP(WMI_TLV_LEN, len);\n\n\t\tptr += TLV_HDR_SIZE;\n\t\tlen = sizeof(*band_to_mac);\n\n\t\tfor (idx = 0; idx < param->num_band_to_mac; idx++) {\n\t\t\tband_to_mac = (void *)ptr;\n\n\t\t\tband_to_mac->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t\t\t\t     WMI_TAG_PDEV_BAND_TO_MAC) |\n\t\t\t\t\t\t  FIELD_PREP(WMI_TLV_LEN,\n\t\t\t\t\t\t\t     len - TLV_HDR_SIZE);\n\t\t\tband_to_mac->pdev_id = param->band_to_mac[idx].pdev_id;\n\t\t\tband_to_mac->start_freq =\n\t\t\t\tparam->band_to_mac[idx].start_freq;\n\t\t\tband_to_mac->end_freq =\n\t\t\t\tparam->band_to_mac[idx].end_freq;\n\t\t\tptr += sizeof(*band_to_mac);\n\t\t}\n\t}\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_INIT_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to send WMI_INIT_CMDID\\n\");\n\t\tdev_kfree_skb(skb);\n\t\treturn ret;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI, \"cmd wmi init\");\n\n\treturn 0;\n}\n\nint ath11k_wmi_pdev_lro_cfg(struct ath11k *ar,\n\t\t\t    int pdev_id)\n{\n\tstruct ath11k_wmi_pdev_lro_config_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(ar->wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct ath11k_wmi_pdev_lro_config_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_LRO_INFO_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tget_random_bytes(cmd->th_4, sizeof(uint32_t) * ATH11K_IPV4_TH_SEED_SIZE);\n\tget_random_bytes(cmd->th_6, sizeof(uint32_t) * ATH11K_IPV6_TH_SEED_SIZE);\n\n\tcmd->pdev_id = pdev_id;\n\n\tret = ath11k_wmi_cmd_send(ar->wmi, skb, WMI_LRO_CONFIG_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to send lro cfg req wmi cmd\\n\");\n\t\tgoto err;\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"cmd lro config pdev_id 0x%x\\n\", pdev_id);\n\treturn 0;\nerr:\n\tdev_kfree_skb(skb);\n\treturn ret;\n}\n\nint ath11k_wmi_wait_for_service_ready(struct ath11k_base *ab)\n{\n\tunsigned long time_left;\n\n\ttime_left = wait_for_completion_timeout(&ab->wmi_ab.service_ready,\n\t\t\t\t\t\tWMI_SERVICE_READY_TIMEOUT_HZ);\n\tif (!time_left)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nint ath11k_wmi_wait_for_unified_ready(struct ath11k_base *ab)\n{\n\tunsigned long time_left;\n\n\ttime_left = wait_for_completion_timeout(&ab->wmi_ab.unified_ready,\n\t\t\t\t\t\tWMI_SERVICE_READY_TIMEOUT_HZ);\n\tif (!time_left)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nint ath11k_wmi_set_hw_mode(struct ath11k_base *ab,\n\t\t\t   enum wmi_host_hw_mode_config_type mode)\n{\n\tstruct wmi_pdev_set_hw_mode_cmd_param *cmd;\n\tstruct sk_buff *skb;\n\tstruct ath11k_wmi_base *wmi_ab = &ab->wmi_ab;\n\tint len;\n\tint ret;\n\n\tlen = sizeof(*cmd);\n\n\tskb = ath11k_wmi_alloc_skb(wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_pdev_set_hw_mode_cmd_param *)skb->data;\n\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_PDEV_SET_HW_MODE_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->pdev_id = WMI_PDEV_ID_SOC;\n\tcmd->hw_mode_index = mode;\n\n\tret = ath11k_wmi_cmd_send(&wmi_ab->wmi[0], skb, WMI_PDEV_SET_HW_MODE_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to send WMI_PDEV_SET_HW_MODE_CMDID\\n\");\n\t\tdev_kfree_skb(skb);\n\t\treturn ret;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI, \"cmd pdev set hw mode %d\", cmd->hw_mode_index);\n\n\treturn 0;\n}\n\nint ath11k_wmi_cmd_init(struct ath11k_base *ab)\n{\n\tstruct ath11k_wmi_base *wmi_sc = &ab->wmi_ab;\n\tstruct wmi_init_cmd_param init_param;\n\tstruct target_resource_config  config;\n\n\tmemset(&init_param, 0, sizeof(init_param));\n\tmemset(&config, 0, sizeof(config));\n\n\tab->hw_params.hw_ops->wmi_init_config(ab, &config);\n\n\tif (test_bit(WMI_TLV_SERVICE_REG_CC_EXT_EVENT_SUPPORT,\n\t\t     ab->wmi_ab.svc_map))\n\t\tconfig.is_reg_cc_ext_event_supported = 1;\n\n\tmemcpy(&wmi_sc->wlan_resource_config, &config, sizeof(config));\n\n\tinit_param.res_cfg = &wmi_sc->wlan_resource_config;\n\tinit_param.num_mem_chunks = wmi_sc->num_mem_chunks;\n\tinit_param.hw_mode_id = wmi_sc->preferred_hw_mode;\n\tinit_param.mem_chunks = wmi_sc->mem_chunks;\n\n\tif (ab->hw_params.single_pdev_only)\n\t\tinit_param.hw_mode_id = WMI_HOST_HW_MODE_MAX;\n\n\tinit_param.num_band_to_mac = ab->num_radios;\n\tath11k_fill_band_to_mac_param(ab, init_param.band_to_mac);\n\n\treturn ath11k_init_cmd_send(&wmi_sc->wmi[0], &init_param);\n}\n\nint ath11k_wmi_vdev_spectral_conf(struct ath11k *ar,\n\t\t\t\t  struct ath11k_wmi_vdev_spectral_conf_param *param)\n{\n\tstruct ath11k_wmi_vdev_spectral_conf_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(ar->wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct ath11k_wmi_vdev_spectral_conf_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t     WMI_TAG_VDEV_SPECTRAL_CONFIGURE_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tmemcpy(&cmd->param, param, sizeof(*param));\n\n\tret = ath11k_wmi_cmd_send(ar->wmi, skb,\n\t\t\t\t  WMI_VDEV_SPECTRAL_SCAN_CONFIGURE_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to send spectral scan config wmi cmd\\n\");\n\t\tgoto err;\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"cmd vdev spectral scan configure vdev_id 0x%x\\n\",\n\t\t   param->vdev_id);\n\n\treturn 0;\nerr:\n\tdev_kfree_skb(skb);\n\treturn ret;\n}\n\nint ath11k_wmi_vdev_spectral_enable(struct ath11k *ar, u32 vdev_id,\n\t\t\t\t    u32 trigger, u32 enable)\n{\n\tstruct ath11k_wmi_vdev_spectral_enable_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(ar->wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct ath11k_wmi_vdev_spectral_enable_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t     WMI_TAG_VDEV_SPECTRAL_ENABLE_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->vdev_id = vdev_id;\n\tcmd->trigger_cmd = trigger;\n\tcmd->enable_cmd = enable;\n\n\tret = ath11k_wmi_cmd_send(ar->wmi, skb,\n\t\t\t\t  WMI_VDEV_SPECTRAL_SCAN_ENABLE_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to send spectral enable wmi cmd\\n\");\n\t\tgoto err;\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"cmd vdev spectral scan enable vdev id 0x%x\\n\",\n\t\t   vdev_id);\n\n\treturn 0;\nerr:\n\tdev_kfree_skb(skb);\n\treturn ret;\n}\n\nint ath11k_wmi_pdev_dma_ring_cfg(struct ath11k *ar,\n\t\t\t\t struct ath11k_wmi_pdev_dma_ring_cfg_req_cmd *param)\n{\n\tstruct ath11k_wmi_pdev_dma_ring_cfg_req_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = ath11k_wmi_alloc_skb(ar->wmi->wmi_ab, sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct ath11k_wmi_pdev_dma_ring_cfg_req_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_DMA_RING_CFG_REQ) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->pdev_id\t\t= param->pdev_id;\n\tcmd->module_id\t\t= param->module_id;\n\tcmd->base_paddr_lo\t= param->base_paddr_lo;\n\tcmd->base_paddr_hi\t= param->base_paddr_hi;\n\tcmd->head_idx_paddr_lo\t= param->head_idx_paddr_lo;\n\tcmd->head_idx_paddr_hi\t= param->head_idx_paddr_hi;\n\tcmd->tail_idx_paddr_lo\t= param->tail_idx_paddr_lo;\n\tcmd->tail_idx_paddr_hi\t= param->tail_idx_paddr_hi;\n\tcmd->num_elems\t\t= param->num_elems;\n\tcmd->buf_size\t\t= param->buf_size;\n\tcmd->num_resp_per_event\t= param->num_resp_per_event;\n\tcmd->event_timeout_ms\t= param->event_timeout_ms;\n\n\tret = ath11k_wmi_cmd_send(ar->wmi, skb,\n\t\t\t\t  WMI_PDEV_DMA_RING_CFG_REQ_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to send dma ring cfg req wmi cmd\\n\");\n\t\tgoto err;\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"cmd pdev dma ring cfg req pdev_id 0x%x\\n\",\n\t\t   param->pdev_id);\n\n\treturn 0;\nerr:\n\tdev_kfree_skb(skb);\n\treturn ret;\n}\n\nstatic int ath11k_wmi_tlv_dma_buf_entry_parse(struct ath11k_base *soc,\n\t\t\t\t\t      u16 tag, u16 len,\n\t\t\t\t\t      const void *ptr, void *data)\n{\n\tstruct wmi_tlv_dma_buf_release_parse *parse = data;\n\n\tif (tag != WMI_TAG_DMA_BUF_RELEASE_ENTRY)\n\t\treturn -EPROTO;\n\n\tif (parse->num_buf_entry >= parse->fixed.num_buf_release_entry)\n\t\treturn -ENOBUFS;\n\n\tparse->num_buf_entry++;\n\treturn 0;\n}\n\nstatic int ath11k_wmi_tlv_dma_buf_meta_parse(struct ath11k_base *soc,\n\t\t\t\t\t     u16 tag, u16 len,\n\t\t\t\t\t     const void *ptr, void *data)\n{\n\tstruct wmi_tlv_dma_buf_release_parse *parse = data;\n\n\tif (tag != WMI_TAG_DMA_BUF_RELEASE_SPECTRAL_META_DATA)\n\t\treturn -EPROTO;\n\n\tif (parse->num_meta >= parse->fixed.num_meta_data_entry)\n\t\treturn -ENOBUFS;\n\n\tparse->num_meta++;\n\treturn 0;\n}\n\nstatic int ath11k_wmi_tlv_dma_buf_parse(struct ath11k_base *ab,\n\t\t\t\t\tu16 tag, u16 len,\n\t\t\t\t\tconst void *ptr, void *data)\n{\n\tstruct wmi_tlv_dma_buf_release_parse *parse = data;\n\tint ret;\n\n\tswitch (tag) {\n\tcase WMI_TAG_DMA_BUF_RELEASE:\n\t\tmemcpy(&parse->fixed, ptr,\n\t\t       sizeof(struct ath11k_wmi_dma_buf_release_fixed_param));\n\t\tparse->fixed.pdev_id = DP_HW2SW_MACID(parse->fixed.pdev_id);\n\t\tbreak;\n\tcase WMI_TAG_ARRAY_STRUCT:\n\t\tif (!parse->buf_entry_done) {\n\t\t\tparse->num_buf_entry = 0;\n\t\t\tparse->buf_entry = (struct wmi_dma_buf_release_entry *)ptr;\n\n\t\t\tret = ath11k_wmi_tlv_iter(ab, ptr, len,\n\t\t\t\t\t\t  ath11k_wmi_tlv_dma_buf_entry_parse,\n\t\t\t\t\t\t  parse);\n\t\t\tif (ret) {\n\t\t\t\tath11k_warn(ab, \"failed to parse dma buf entry tlv %d\\n\",\n\t\t\t\t\t    ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tparse->buf_entry_done = true;\n\t\t} else if (!parse->meta_data_done) {\n\t\t\tparse->num_meta = 0;\n\t\t\tparse->meta_data = (struct wmi_dma_buf_release_meta_data *)ptr;\n\n\t\t\tret = ath11k_wmi_tlv_iter(ab, ptr, len,\n\t\t\t\t\t\t  ath11k_wmi_tlv_dma_buf_meta_parse,\n\t\t\t\t\t\t  parse);\n\t\t\tif (ret) {\n\t\t\t\tath11k_warn(ab, \"failed to parse dma buf meta tlv %d\\n\",\n\t\t\t\t\t    ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tparse->meta_data_done = true;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void ath11k_wmi_pdev_dma_ring_buf_release_event(struct ath11k_base *ab,\n\t\t\t\t\t\t       struct sk_buff *skb)\n{\n\tstruct wmi_tlv_dma_buf_release_parse parse = { };\n\tstruct ath11k_dbring_buf_release_event param;\n\tint ret;\n\n\tret = ath11k_wmi_tlv_iter(ab, skb->data, skb->len,\n\t\t\t\t  ath11k_wmi_tlv_dma_buf_parse,\n\t\t\t\t  &parse);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to parse dma buf release tlv %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI, \"event pdev dma ring buf release\");\n\n\tparam.fixed\t\t= parse.fixed;\n\tparam.buf_entry\t\t= parse.buf_entry;\n\tparam.num_buf_entry\t= parse.num_buf_entry;\n\tparam.meta_data\t\t= parse.meta_data;\n\tparam.num_meta\t\t= parse.num_meta;\n\n\tret = ath11k_dbring_buffer_release_event(ab, &param);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to handle dma buf release event %d\\n\", ret);\n\t\treturn;\n\t}\n}\n\nstatic int ath11k_wmi_tlv_hw_mode_caps_parse(struct ath11k_base *soc,\n\t\t\t\t\t     u16 tag, u16 len,\n\t\t\t\t\t     const void *ptr, void *data)\n{\n\tstruct wmi_tlv_svc_rdy_ext_parse *svc_rdy_ext = data;\n\tstruct wmi_hw_mode_capabilities *hw_mode_cap;\n\tu32 phy_map = 0;\n\n\tif (tag != WMI_TAG_HW_MODE_CAPABILITIES)\n\t\treturn -EPROTO;\n\n\tif (svc_rdy_ext->n_hw_mode_caps >= svc_rdy_ext->param.num_hw_modes)\n\t\treturn -ENOBUFS;\n\n\thw_mode_cap = container_of(ptr, struct wmi_hw_mode_capabilities,\n\t\t\t\t   hw_mode_id);\n\tsvc_rdy_ext->n_hw_mode_caps++;\n\n\tphy_map = hw_mode_cap->phy_id_map;\n\twhile (phy_map) {\n\t\tsvc_rdy_ext->tot_phy_id++;\n\t\tphy_map = phy_map >> 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath11k_wmi_tlv_hw_mode_caps(struct ath11k_base *soc,\n\t\t\t\t       u16 len, const void *ptr, void *data)\n{\n\tstruct wmi_tlv_svc_rdy_ext_parse *svc_rdy_ext = data;\n\tstruct wmi_hw_mode_capabilities *hw_mode_caps;\n\tenum wmi_host_hw_mode_config_type mode, pref;\n\tu32 i;\n\tint ret;\n\n\tsvc_rdy_ext->n_hw_mode_caps = 0;\n\tsvc_rdy_ext->hw_mode_caps = (struct wmi_hw_mode_capabilities *)ptr;\n\n\tret = ath11k_wmi_tlv_iter(soc, ptr, len,\n\t\t\t\t  ath11k_wmi_tlv_hw_mode_caps_parse,\n\t\t\t\t  svc_rdy_ext);\n\tif (ret) {\n\t\tath11k_warn(soc, \"failed to parse tlv %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ti = 0;\n\twhile (i < svc_rdy_ext->n_hw_mode_caps) {\n\t\thw_mode_caps = &svc_rdy_ext->hw_mode_caps[i];\n\t\tmode = hw_mode_caps->hw_mode_id;\n\t\tpref = soc->wmi_ab.preferred_hw_mode;\n\n\t\tif (ath11k_hw_mode_pri_map[mode] < ath11k_hw_mode_pri_map[pref]) {\n\t\t\tsvc_rdy_ext->pref_hw_mode_caps = *hw_mode_caps;\n\t\t\tsoc->wmi_ab.preferred_hw_mode = mode;\n\t\t}\n\t\ti++;\n\t}\n\n\tath11k_dbg(soc, ATH11K_DBG_WMI, \"preferred_hw_mode:%d\\n\",\n\t\t   soc->wmi_ab.preferred_hw_mode);\n\tif (soc->wmi_ab.preferred_hw_mode == WMI_HOST_HW_MODE_MAX)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int ath11k_wmi_tlv_mac_phy_caps_parse(struct ath11k_base *soc,\n\t\t\t\t\t     u16 tag, u16 len,\n\t\t\t\t\t     const void *ptr, void *data)\n{\n\tstruct wmi_tlv_svc_rdy_ext_parse *svc_rdy_ext = data;\n\n\tif (tag != WMI_TAG_MAC_PHY_CAPABILITIES)\n\t\treturn -EPROTO;\n\n\tif (svc_rdy_ext->n_mac_phy_caps >= svc_rdy_ext->tot_phy_id)\n\t\treturn -ENOBUFS;\n\n\tlen = min_t(u16, len, sizeof(struct wmi_mac_phy_capabilities));\n\tif (!svc_rdy_ext->n_mac_phy_caps) {\n\t\tsvc_rdy_ext->mac_phy_caps = kcalloc(svc_rdy_ext->tot_phy_id,\n\t\t\t\t\t\t    len, GFP_ATOMIC);\n\t\tif (!svc_rdy_ext->mac_phy_caps)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tmemcpy(svc_rdy_ext->mac_phy_caps + svc_rdy_ext->n_mac_phy_caps, ptr, len);\n\tsvc_rdy_ext->n_mac_phy_caps++;\n\treturn 0;\n}\n\nstatic int ath11k_wmi_tlv_ext_hal_reg_caps_parse(struct ath11k_base *soc,\n\t\t\t\t\t\t u16 tag, u16 len,\n\t\t\t\t\t\t const void *ptr, void *data)\n{\n\tstruct wmi_tlv_svc_rdy_ext_parse *svc_rdy_ext = data;\n\n\tif (tag != WMI_TAG_HAL_REG_CAPABILITIES_EXT)\n\t\treturn -EPROTO;\n\n\tif (svc_rdy_ext->n_ext_hal_reg_caps >= svc_rdy_ext->param.num_phy)\n\t\treturn -ENOBUFS;\n\n\tsvc_rdy_ext->n_ext_hal_reg_caps++;\n\treturn 0;\n}\n\nstatic int ath11k_wmi_tlv_ext_hal_reg_caps(struct ath11k_base *soc,\n\t\t\t\t\t   u16 len, const void *ptr, void *data)\n{\n\tstruct ath11k_pdev_wmi *wmi_handle = &soc->wmi_ab.wmi[0];\n\tstruct wmi_tlv_svc_rdy_ext_parse *svc_rdy_ext = data;\n\tstruct ath11k_hal_reg_capabilities_ext reg_cap;\n\tint ret;\n\tu32 i;\n\n\tsvc_rdy_ext->n_ext_hal_reg_caps = 0;\n\tsvc_rdy_ext->ext_hal_reg_caps = (struct wmi_hal_reg_capabilities_ext *)ptr;\n\tret = ath11k_wmi_tlv_iter(soc, ptr, len,\n\t\t\t\t  ath11k_wmi_tlv_ext_hal_reg_caps_parse,\n\t\t\t\t  svc_rdy_ext);\n\tif (ret) {\n\t\tath11k_warn(soc, \"failed to parse tlv %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < svc_rdy_ext->param.num_phy; i++) {\n\t\tret = ath11k_pull_reg_cap_svc_rdy_ext(wmi_handle,\n\t\t\t\t\t\t      svc_rdy_ext->soc_hal_reg_caps,\n\t\t\t\t\t\t      svc_rdy_ext->ext_hal_reg_caps, i,\n\t\t\t\t\t\t      &reg_cap);\n\t\tif (ret) {\n\t\t\tath11k_warn(soc, \"failed to extract reg cap %d\\n\", i);\n\t\t\treturn ret;\n\t\t}\n\n\t\tmemcpy(&soc->hal_reg_cap[reg_cap.phy_id],\n\t\t       &reg_cap, sizeof(reg_cap));\n\t}\n\treturn 0;\n}\n\nstatic int ath11k_wmi_tlv_ext_soc_hal_reg_caps_parse(struct ath11k_base *soc,\n\t\t\t\t\t\t     u16 len, const void *ptr,\n\t\t\t\t\t\t     void *data)\n{\n\tstruct ath11k_pdev_wmi *wmi_handle = &soc->wmi_ab.wmi[0];\n\tstruct wmi_tlv_svc_rdy_ext_parse *svc_rdy_ext = data;\n\tu8 hw_mode_id = svc_rdy_ext->pref_hw_mode_caps.hw_mode_id;\n\tu32 phy_id_map;\n\tint pdev_index = 0;\n\tint ret;\n\n\tsvc_rdy_ext->soc_hal_reg_caps = (struct wmi_soc_hal_reg_capabilities *)ptr;\n\tsvc_rdy_ext->param.num_phy = svc_rdy_ext->soc_hal_reg_caps->num_phy;\n\n\tsoc->num_radios = 0;\n\tsoc->target_pdev_count = 0;\n\tphy_id_map = svc_rdy_ext->pref_hw_mode_caps.phy_id_map;\n\n\twhile (phy_id_map && soc->num_radios < MAX_RADIOS) {\n\t\tret = ath11k_pull_mac_phy_cap_svc_ready_ext(wmi_handle,\n\t\t\t\t\t\t\t    svc_rdy_ext->hw_caps,\n\t\t\t\t\t\t\t    svc_rdy_ext->hw_mode_caps,\n\t\t\t\t\t\t\t    svc_rdy_ext->soc_hal_reg_caps,\n\t\t\t\t\t\t\t    svc_rdy_ext->mac_phy_caps,\n\t\t\t\t\t\t\t    hw_mode_id, soc->num_radios,\n\t\t\t\t\t\t\t    &soc->pdevs[pdev_index]);\n\t\tif (ret) {\n\t\t\tath11k_warn(soc, \"failed to extract mac caps, idx :%d\\n\",\n\t\t\t\t    soc->num_radios);\n\t\t\treturn ret;\n\t\t}\n\n\t\tsoc->num_radios++;\n\n\t\t \n\t\tif (soc->hw_params.single_pdev_only)\n\t\t\tpdev_index = 0;\n\t\telse\n\t\t\tpdev_index = soc->num_radios;\n\n\t\t \n\t\tphy_id_map >>= 1;\n\t}\n\n\t \n\tif (soc->hw_params.single_pdev_only) {\n\t\tsoc->num_radios = 1;\n\t\tsoc->pdevs[0].pdev_id = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath11k_wmi_tlv_dma_ring_caps_parse(struct ath11k_base *soc,\n\t\t\t\t\t      u16 tag, u16 len,\n\t\t\t\t\t      const void *ptr, void *data)\n{\n\tstruct wmi_tlv_dma_ring_caps_parse *parse = data;\n\n\tif (tag != WMI_TAG_DMA_RING_CAPABILITIES)\n\t\treturn -EPROTO;\n\n\tparse->n_dma_ring_caps++;\n\treturn 0;\n}\n\nstatic int ath11k_wmi_alloc_dbring_caps(struct ath11k_base *ab,\n\t\t\t\t\tu32 num_cap)\n{\n\tsize_t sz;\n\tvoid *ptr;\n\n\tsz = num_cap * sizeof(struct ath11k_dbring_cap);\n\tptr = kzalloc(sz, GFP_ATOMIC);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\n\tab->db_caps = ptr;\n\tab->num_db_cap = num_cap;\n\n\treturn 0;\n}\n\nstatic void ath11k_wmi_free_dbring_caps(struct ath11k_base *ab)\n{\n\tkfree(ab->db_caps);\n\tab->db_caps = NULL;\n}\n\nstatic int ath11k_wmi_tlv_dma_ring_caps(struct ath11k_base *ab,\n\t\t\t\t\tu16 len, const void *ptr, void *data)\n{\n\tstruct wmi_tlv_dma_ring_caps_parse *dma_caps_parse = data;\n\tstruct wmi_dma_ring_capabilities *dma_caps;\n\tstruct ath11k_dbring_cap *dir_buff_caps;\n\tint ret;\n\tu32 i;\n\n\tdma_caps_parse->n_dma_ring_caps = 0;\n\tdma_caps = (struct wmi_dma_ring_capabilities *)ptr;\n\tret = ath11k_wmi_tlv_iter(ab, ptr, len,\n\t\t\t\t  ath11k_wmi_tlv_dma_ring_caps_parse,\n\t\t\t\t  dma_caps_parse);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to parse dma ring caps tlv %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (!dma_caps_parse->n_dma_ring_caps)\n\t\treturn 0;\n\n\tif (ab->num_db_cap) {\n\t\tath11k_warn(ab, \"Already processed, so ignoring dma ring caps\\n\");\n\t\treturn 0;\n\t}\n\n\tret = ath11k_wmi_alloc_dbring_caps(ab, dma_caps_parse->n_dma_ring_caps);\n\tif (ret)\n\t\treturn ret;\n\n\tdir_buff_caps = ab->db_caps;\n\tfor (i = 0; i < dma_caps_parse->n_dma_ring_caps; i++) {\n\t\tif (dma_caps[i].module_id >= WMI_DIRECT_BUF_MAX) {\n\t\t\tath11k_warn(ab, \"Invalid module id %d\\n\", dma_caps[i].module_id);\n\t\t\tret = -EINVAL;\n\t\t\tgoto free_dir_buff;\n\t\t}\n\n\t\tdir_buff_caps[i].id = dma_caps[i].module_id;\n\t\tdir_buff_caps[i].pdev_id = DP_HW2SW_MACID(dma_caps[i].pdev_id);\n\t\tdir_buff_caps[i].min_elem = dma_caps[i].min_elem;\n\t\tdir_buff_caps[i].min_buf_sz = dma_caps[i].min_buf_sz;\n\t\tdir_buff_caps[i].min_buf_align = dma_caps[i].min_buf_align;\n\t}\n\n\treturn 0;\n\nfree_dir_buff:\n\tath11k_wmi_free_dbring_caps(ab);\n\treturn ret;\n}\n\nstatic int ath11k_wmi_tlv_svc_rdy_ext_parse(struct ath11k_base *ab,\n\t\t\t\t\t    u16 tag, u16 len,\n\t\t\t\t\t    const void *ptr, void *data)\n{\n\tstruct ath11k_pdev_wmi *wmi_handle = &ab->wmi_ab.wmi[0];\n\tstruct wmi_tlv_svc_rdy_ext_parse *svc_rdy_ext = data;\n\tint ret;\n\n\tswitch (tag) {\n\tcase WMI_TAG_SERVICE_READY_EXT_EVENT:\n\t\tret = ath11k_pull_svc_ready_ext(wmi_handle, ptr,\n\t\t\t\t\t\t&svc_rdy_ext->param);\n\t\tif (ret) {\n\t\t\tath11k_warn(ab, \"unable to extract ext params\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\n\tcase WMI_TAG_SOC_MAC_PHY_HW_MODE_CAPS:\n\t\tsvc_rdy_ext->hw_caps = (struct wmi_soc_mac_phy_hw_mode_caps *)ptr;\n\t\tsvc_rdy_ext->param.num_hw_modes = svc_rdy_ext->hw_caps->num_hw_modes;\n\t\tbreak;\n\n\tcase WMI_TAG_SOC_HAL_REG_CAPABILITIES:\n\t\tret = ath11k_wmi_tlv_ext_soc_hal_reg_caps_parse(ab, len, ptr,\n\t\t\t\t\t\t\t\tsvc_rdy_ext);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\n\tcase WMI_TAG_ARRAY_STRUCT:\n\t\tif (!svc_rdy_ext->hw_mode_done) {\n\t\t\tret = ath11k_wmi_tlv_hw_mode_caps(ab, len, ptr,\n\t\t\t\t\t\t\t  svc_rdy_ext);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tsvc_rdy_ext->hw_mode_done = true;\n\t\t} else if (!svc_rdy_ext->mac_phy_done) {\n\t\t\tsvc_rdy_ext->n_mac_phy_caps = 0;\n\t\t\tret = ath11k_wmi_tlv_iter(ab, ptr, len,\n\t\t\t\t\t\t  ath11k_wmi_tlv_mac_phy_caps_parse,\n\t\t\t\t\t\t  svc_rdy_ext);\n\t\t\tif (ret) {\n\t\t\t\tath11k_warn(ab, \"failed to parse tlv %d\\n\", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\tsvc_rdy_ext->mac_phy_done = true;\n\t\t} else if (!svc_rdy_ext->ext_hal_reg_done) {\n\t\t\tret = ath11k_wmi_tlv_ext_hal_reg_caps(ab, len, ptr,\n\t\t\t\t\t\t\t      svc_rdy_ext);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tsvc_rdy_ext->ext_hal_reg_done = true;\n\t\t} else if (!svc_rdy_ext->mac_phy_chainmask_combo_done) {\n\t\t\tsvc_rdy_ext->mac_phy_chainmask_combo_done = true;\n\t\t} else if (!svc_rdy_ext->mac_phy_chainmask_cap_done) {\n\t\t\tsvc_rdy_ext->mac_phy_chainmask_cap_done = true;\n\t\t} else if (!svc_rdy_ext->oem_dma_ring_cap_done) {\n\t\t\tsvc_rdy_ext->oem_dma_ring_cap_done = true;\n\t\t} else if (!svc_rdy_ext->dma_ring_cap_done) {\n\t\t\tret = ath11k_wmi_tlv_dma_ring_caps(ab, len, ptr,\n\t\t\t\t\t\t\t   &svc_rdy_ext->dma_caps_parse);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tsvc_rdy_ext->dma_ring_cap_done = true;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int ath11k_service_ready_ext_event(struct ath11k_base *ab,\n\t\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct wmi_tlv_svc_rdy_ext_parse svc_rdy_ext = { };\n\tint ret;\n\n\tret = ath11k_wmi_tlv_iter(ab, skb->data, skb->len,\n\t\t\t\t  ath11k_wmi_tlv_svc_rdy_ext_parse,\n\t\t\t\t  &svc_rdy_ext);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to parse tlv %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI, \"event service ready ext\");\n\n\tif (!test_bit(WMI_TLV_SERVICE_EXT2_MSG, ab->wmi_ab.svc_map))\n\t\tcomplete(&ab->wmi_ab.service_ready);\n\n\tkfree(svc_rdy_ext.mac_phy_caps);\n\treturn 0;\n\nerr:\n\tath11k_wmi_free_dbring_caps(ab);\n\treturn ret;\n}\n\nstatic int ath11k_wmi_tlv_svc_rdy_ext2_parse(struct ath11k_base *ab,\n\t\t\t\t\t     u16 tag, u16 len,\n\t\t\t\t\t     const void *ptr, void *data)\n{\n\tstruct wmi_tlv_svc_rdy_ext2_parse *parse = data;\n\tint ret;\n\n\tswitch (tag) {\n\tcase WMI_TAG_ARRAY_STRUCT:\n\t\tif (!parse->dma_ring_cap_done) {\n\t\t\tret = ath11k_wmi_tlv_dma_ring_caps(ab, len, ptr,\n\t\t\t\t\t\t\t   &parse->dma_caps_parse);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tparse->dma_ring_cap_done = true;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath11k_service_ready_ext2_event(struct ath11k_base *ab,\n\t\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct wmi_tlv_svc_rdy_ext2_parse svc_rdy_ext2 = { };\n\tint ret;\n\n\tret = ath11k_wmi_tlv_iter(ab, skb->data, skb->len,\n\t\t\t\t  ath11k_wmi_tlv_svc_rdy_ext2_parse,\n\t\t\t\t  &svc_rdy_ext2);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to parse ext2 event tlv %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI, \"event service ready ext2\");\n\n\tcomplete(&ab->wmi_ab.service_ready);\n\n\treturn 0;\n\nerr:\n\tath11k_wmi_free_dbring_caps(ab);\n\treturn ret;\n}\n\nstatic int ath11k_pull_vdev_start_resp_tlv(struct ath11k_base *ab, struct sk_buff *skb,\n\t\t\t\t\t   struct wmi_vdev_start_resp_event *vdev_rsp)\n{\n\tconst void **tb;\n\tconst struct wmi_vdev_start_resp_event *ev;\n\tint ret;\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = tb[WMI_TAG_VDEV_START_RESPONSE_EVENT];\n\tif (!ev) {\n\t\tath11k_warn(ab, \"failed to fetch vdev start resp ev\");\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\tmemset(vdev_rsp, 0, sizeof(*vdev_rsp));\n\n\tvdev_rsp->vdev_id = ev->vdev_id;\n\tvdev_rsp->requestor_id = ev->requestor_id;\n\tvdev_rsp->resp_type = ev->resp_type;\n\tvdev_rsp->status = ev->status;\n\tvdev_rsp->chain_mask = ev->chain_mask;\n\tvdev_rsp->smps_mode = ev->smps_mode;\n\tvdev_rsp->mac_id = ev->mac_id;\n\tvdev_rsp->cfgd_tx_streams = ev->cfgd_tx_streams;\n\tvdev_rsp->cfgd_rx_streams = ev->cfgd_rx_streams;\n\n\tkfree(tb);\n\treturn 0;\n}\n\nstatic void ath11k_print_reg_rule(struct ath11k_base *ab, const char *band,\n\t\t\t\t  u32 num_reg_rules,\n\t\t\t\t  struct cur_reg_rule *reg_rule_ptr)\n{\n\tstruct cur_reg_rule *reg_rule = reg_rule_ptr;\n\tu32 count;\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI, \"number of reg rules in %s band: %d\\n\",\n\t\t   band, num_reg_rules);\n\n\tfor (count = 0; count < num_reg_rules; count++) {\n\t\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t\t   \"reg rule %d: (%d - %d @ %d) (%d, %d) (FLAGS %d)\\n\",\n\t\t\t   count + 1, reg_rule->start_freq, reg_rule->end_freq,\n\t\t\t   reg_rule->max_bw, reg_rule->ant_gain,\n\t\t\t   reg_rule->reg_power, reg_rule->flags);\n\t\treg_rule++;\n\t}\n}\n\nstatic struct cur_reg_rule\n*create_reg_rules_from_wmi(u32 num_reg_rules,\n\t\t\t   struct wmi_regulatory_rule_struct *wmi_reg_rule)\n{\n\tstruct cur_reg_rule *reg_rule_ptr;\n\tu32 count;\n\n\treg_rule_ptr = kcalloc(num_reg_rules, sizeof(*reg_rule_ptr),\n\t\t\t       GFP_ATOMIC);\n\n\tif (!reg_rule_ptr)\n\t\treturn NULL;\n\n\tfor (count = 0; count < num_reg_rules; count++) {\n\t\treg_rule_ptr[count].start_freq =\n\t\t\tFIELD_GET(REG_RULE_START_FREQ,\n\t\t\t\t  wmi_reg_rule[count].freq_info);\n\t\treg_rule_ptr[count].end_freq =\n\t\t\tFIELD_GET(REG_RULE_END_FREQ,\n\t\t\t\t  wmi_reg_rule[count].freq_info);\n\t\treg_rule_ptr[count].max_bw =\n\t\t\tFIELD_GET(REG_RULE_MAX_BW,\n\t\t\t\t  wmi_reg_rule[count].bw_pwr_info);\n\t\treg_rule_ptr[count].reg_power =\n\t\t\tFIELD_GET(REG_RULE_REG_PWR,\n\t\t\t\t  wmi_reg_rule[count].bw_pwr_info);\n\t\treg_rule_ptr[count].ant_gain =\n\t\t\tFIELD_GET(REG_RULE_ANT_GAIN,\n\t\t\t\t  wmi_reg_rule[count].bw_pwr_info);\n\t\treg_rule_ptr[count].flags =\n\t\t\tFIELD_GET(REG_RULE_FLAGS,\n\t\t\t\t  wmi_reg_rule[count].flag_info);\n\t}\n\n\treturn reg_rule_ptr;\n}\n\nstatic int ath11k_pull_reg_chan_list_update_ev(struct ath11k_base *ab,\n\t\t\t\t\t       struct sk_buff *skb,\n\t\t\t\t\t       struct cur_regulatory_info *reg_info)\n{\n\tconst void **tb;\n\tconst struct wmi_reg_chan_list_cc_event *chan_list_event_hdr;\n\tstruct wmi_regulatory_rule_struct *wmi_reg_rule;\n\tu32 num_2ghz_reg_rules, num_5ghz_reg_rules;\n\tint ret;\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI, \"processing regulatory channel list\\n\");\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tchan_list_event_hdr = tb[WMI_TAG_REG_CHAN_LIST_CC_EVENT];\n\tif (!chan_list_event_hdr) {\n\t\tath11k_warn(ab, \"failed to fetch reg chan list update ev\\n\");\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\treg_info->num_2ghz_reg_rules = chan_list_event_hdr->num_2ghz_reg_rules;\n\treg_info->num_5ghz_reg_rules = chan_list_event_hdr->num_5ghz_reg_rules;\n\n\tif (!(reg_info->num_2ghz_reg_rules + reg_info->num_5ghz_reg_rules)) {\n\t\tath11k_warn(ab, \"No regulatory rules available in the event info\\n\");\n\t\tkfree(tb);\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(reg_info->alpha2, &chan_list_event_hdr->alpha2,\n\t       REG_ALPHA2_LEN);\n\treg_info->dfs_region = chan_list_event_hdr->dfs_region;\n\treg_info->phybitmap = chan_list_event_hdr->phybitmap;\n\treg_info->num_phy = chan_list_event_hdr->num_phy;\n\treg_info->phy_id = chan_list_event_hdr->phy_id;\n\treg_info->ctry_code = chan_list_event_hdr->country_id;\n\treg_info->reg_dmn_pair = chan_list_event_hdr->domain_code;\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t   \"status_code %s\",\n\t\t   ath11k_cc_status_to_str(reg_info->status_code));\n\n\treg_info->status_code =\n\t\tath11k_wmi_cc_setting_code_to_reg(chan_list_event_hdr->status_code);\n\n\treg_info->is_ext_reg_event = false;\n\n\treg_info->min_bw_2ghz = chan_list_event_hdr->min_bw_2ghz;\n\treg_info->max_bw_2ghz = chan_list_event_hdr->max_bw_2ghz;\n\treg_info->min_bw_5ghz = chan_list_event_hdr->min_bw_5ghz;\n\treg_info->max_bw_5ghz = chan_list_event_hdr->max_bw_5ghz;\n\n\tnum_2ghz_reg_rules = reg_info->num_2ghz_reg_rules;\n\tnum_5ghz_reg_rules = reg_info->num_5ghz_reg_rules;\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t   \"cc %s dsf %d BW: min_2ghz %d max_2ghz %d min_5ghz %d max_5ghz %d\",\n\t\t   reg_info->alpha2, reg_info->dfs_region,\n\t\t   reg_info->min_bw_2ghz, reg_info->max_bw_2ghz,\n\t\t   reg_info->min_bw_5ghz, reg_info->max_bw_5ghz);\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t   \"num_2ghz_reg_rules %d num_5ghz_reg_rules %d\",\n\t\t   num_2ghz_reg_rules, num_5ghz_reg_rules);\n\n\twmi_reg_rule =\n\t\t(struct wmi_regulatory_rule_struct *)((u8 *)chan_list_event_hdr\n\t\t\t\t\t\t+ sizeof(*chan_list_event_hdr)\n\t\t\t\t\t\t+ sizeof(struct wmi_tlv));\n\n\tif (num_2ghz_reg_rules) {\n\t\treg_info->reg_rules_2ghz_ptr =\n\t\t\t\tcreate_reg_rules_from_wmi(num_2ghz_reg_rules,\n\t\t\t\t\t\t\t  wmi_reg_rule);\n\t\tif (!reg_info->reg_rules_2ghz_ptr) {\n\t\t\tkfree(tb);\n\t\t\tath11k_warn(ab, \"Unable to Allocate memory for 2 GHz rules\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tath11k_print_reg_rule(ab, \"2 GHz\",\n\t\t\t\t      num_2ghz_reg_rules,\n\t\t\t\t      reg_info->reg_rules_2ghz_ptr);\n\t}\n\n\tif (num_5ghz_reg_rules) {\n\t\twmi_reg_rule += num_2ghz_reg_rules;\n\t\treg_info->reg_rules_5ghz_ptr =\n\t\t\t\tcreate_reg_rules_from_wmi(num_5ghz_reg_rules,\n\t\t\t\t\t\t\t  wmi_reg_rule);\n\t\tif (!reg_info->reg_rules_5ghz_ptr) {\n\t\t\tkfree(tb);\n\t\t\tath11k_warn(ab, \"Unable to Allocate memory for 5 GHz rules\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tath11k_print_reg_rule(ab, \"5 GHz\",\n\t\t\t\t      num_5ghz_reg_rules,\n\t\t\t\t      reg_info->reg_rules_5ghz_ptr);\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI, \"processed regulatory channel list\\n\");\n\n\tkfree(tb);\n\treturn 0;\n}\n\nstatic struct cur_reg_rule\n*create_ext_reg_rules_from_wmi(u32 num_reg_rules,\n\t\t\t       struct wmi_regulatory_ext_rule *wmi_reg_rule)\n{\n\tstruct cur_reg_rule *reg_rule_ptr;\n\tu32 count;\n\n\treg_rule_ptr =  kcalloc(num_reg_rules, sizeof(*reg_rule_ptr), GFP_ATOMIC);\n\n\tif (!reg_rule_ptr)\n\t\treturn NULL;\n\n\tfor (count = 0; count < num_reg_rules; count++) {\n\t\treg_rule_ptr[count].start_freq =\n\t\t\tu32_get_bits(wmi_reg_rule[count].freq_info,\n\t\t\t\t     REG_RULE_START_FREQ);\n\t\treg_rule_ptr[count].end_freq =\n\t\t\tu32_get_bits(wmi_reg_rule[count].freq_info,\n\t\t\t\t     REG_RULE_END_FREQ);\n\t\treg_rule_ptr[count].max_bw =\n\t\t\tu32_get_bits(wmi_reg_rule[count].bw_pwr_info,\n\t\t\t\t     REG_RULE_MAX_BW);\n\t\treg_rule_ptr[count].reg_power =\n\t\t\tu32_get_bits(wmi_reg_rule[count].bw_pwr_info,\n\t\t\t\t     REG_RULE_REG_PWR);\n\t\treg_rule_ptr[count].ant_gain =\n\t\t\tu32_get_bits(wmi_reg_rule[count].bw_pwr_info,\n\t\t\t\t     REG_RULE_ANT_GAIN);\n\t\treg_rule_ptr[count].flags =\n\t\t\tu32_get_bits(wmi_reg_rule[count].flag_info,\n\t\t\t\t     REG_RULE_FLAGS);\n\t\treg_rule_ptr[count].psd_flag =\n\t\t\tu32_get_bits(wmi_reg_rule[count].psd_power_info,\n\t\t\t\t     REG_RULE_PSD_INFO);\n\t\treg_rule_ptr[count].psd_eirp =\n\t\t\tu32_get_bits(wmi_reg_rule[count].psd_power_info,\n\t\t\t\t     REG_RULE_PSD_EIRP);\n\t}\n\n\treturn reg_rule_ptr;\n}\n\nstatic u8\nath11k_invalid_5ghz_reg_ext_rules_from_wmi(u32 num_reg_rules,\n\t\t\t\t\t   const struct wmi_regulatory_ext_rule *rule)\n{\n\tu8 num_invalid_5ghz_rules = 0;\n\tu32 count, start_freq;\n\n\tfor (count = 0; count < num_reg_rules; count++) {\n\t\tstart_freq = u32_get_bits(rule[count].freq_info,\n\t\t\t\t\t  REG_RULE_START_FREQ);\n\n\t\tif (start_freq >= ATH11K_MIN_6G_FREQ)\n\t\t\tnum_invalid_5ghz_rules++;\n\t}\n\n\treturn num_invalid_5ghz_rules;\n}\n\nstatic int ath11k_pull_reg_chan_list_ext_update_ev(struct ath11k_base *ab,\n\t\t\t\t\t\t   struct sk_buff *skb,\n\t\t\t\t\t\t   struct cur_regulatory_info *reg_info)\n{\n\tconst void **tb;\n\tconst struct wmi_reg_chan_list_cc_ext_event *ev;\n\tstruct wmi_regulatory_ext_rule *ext_wmi_reg_rule;\n\tu32 num_2ghz_reg_rules, num_5ghz_reg_rules;\n\tu32 num_6ghz_reg_rules_ap[WMI_REG_CURRENT_MAX_AP_TYPE];\n\tu32 num_6ghz_client[WMI_REG_CURRENT_MAX_AP_TYPE][WMI_REG_MAX_CLIENT_TYPE];\n\tu32 total_reg_rules = 0;\n\tint ret, i, j, num_invalid_5ghz_ext_rules = 0;\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI, \"processing regulatory ext channel list\\n\");\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = tb[WMI_TAG_REG_CHAN_LIST_CC_EXT_EVENT];\n\tif (!ev) {\n\t\tath11k_warn(ab, \"failed to fetch reg chan list ext update ev\\n\");\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\treg_info->num_2ghz_reg_rules = ev->num_2ghz_reg_rules;\n\treg_info->num_5ghz_reg_rules = ev->num_5ghz_reg_rules;\n\treg_info->num_6ghz_rules_ap[WMI_REG_INDOOR_AP] =\n\t\t\tev->num_6ghz_reg_rules_ap_lpi;\n\treg_info->num_6ghz_rules_ap[WMI_REG_STANDARD_POWER_AP] =\n\t\t\tev->num_6ghz_reg_rules_ap_sp;\n\treg_info->num_6ghz_rules_ap[WMI_REG_VERY_LOW_POWER_AP] =\n\t\t\tev->num_6ghz_reg_rules_ap_vlp;\n\n\tfor (i = 0; i < WMI_REG_MAX_CLIENT_TYPE; i++) {\n\t\treg_info->num_6ghz_rules_client[WMI_REG_INDOOR_AP][i] =\n\t\t\tev->num_6ghz_reg_rules_client_lpi[i];\n\t\treg_info->num_6ghz_rules_client[WMI_REG_STANDARD_POWER_AP][i] =\n\t\t\tev->num_6ghz_reg_rules_client_sp[i];\n\t\treg_info->num_6ghz_rules_client[WMI_REG_VERY_LOW_POWER_AP][i] =\n\t\t\tev->num_6ghz_reg_rules_client_vlp[i];\n\t}\n\n\tnum_2ghz_reg_rules = reg_info->num_2ghz_reg_rules;\n\tnum_5ghz_reg_rules = reg_info->num_5ghz_reg_rules;\n\n\ttotal_reg_rules += num_2ghz_reg_rules;\n\ttotal_reg_rules += num_5ghz_reg_rules;\n\n\tif ((num_2ghz_reg_rules > MAX_REG_RULES) ||\n\t    (num_5ghz_reg_rules > MAX_REG_RULES)) {\n\t\tath11k_warn(ab, \"Num reg rules for 2.4 GHz/5 GHz exceeds max limit (num_2ghz_reg_rules: %d num_5ghz_reg_rules: %d max_rules: %d)\\n\",\n\t\t\t    num_2ghz_reg_rules, num_5ghz_reg_rules, MAX_REG_RULES);\n\t\tkfree(tb);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < WMI_REG_CURRENT_MAX_AP_TYPE; i++) {\n\t\tnum_6ghz_reg_rules_ap[i] = reg_info->num_6ghz_rules_ap[i];\n\n\t\tif (num_6ghz_reg_rules_ap[i] > MAX_6GHZ_REG_RULES) {\n\t\t\tath11k_warn(ab, \"Num 6 GHz reg rules for AP mode(%d) exceeds max limit (num_6ghz_reg_rules_ap: %d, max_rules: %d)\\n\",\n\t\t\t\t    i, num_6ghz_reg_rules_ap[i], MAX_6GHZ_REG_RULES);\n\t\t\tkfree(tb);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\ttotal_reg_rules += num_6ghz_reg_rules_ap[i];\n\t}\n\n\tfor (i = 0; i < WMI_REG_MAX_CLIENT_TYPE; i++) {\n\t\tnum_6ghz_client[WMI_REG_INDOOR_AP][i] =\n\t\t\treg_info->num_6ghz_rules_client[WMI_REG_INDOOR_AP][i];\n\t\ttotal_reg_rules += num_6ghz_client[WMI_REG_INDOOR_AP][i];\n\n\t\tnum_6ghz_client[WMI_REG_STANDARD_POWER_AP][i] =\n\t\t\treg_info->num_6ghz_rules_client[WMI_REG_STANDARD_POWER_AP][i];\n\t\ttotal_reg_rules += num_6ghz_client[WMI_REG_STANDARD_POWER_AP][i];\n\n\t\tnum_6ghz_client[WMI_REG_VERY_LOW_POWER_AP][i] =\n\t\t\treg_info->num_6ghz_rules_client[WMI_REG_VERY_LOW_POWER_AP][i];\n\t\ttotal_reg_rules += num_6ghz_client[WMI_REG_VERY_LOW_POWER_AP][i];\n\n\t\tif ((num_6ghz_client[WMI_REG_INDOOR_AP][i] > MAX_6GHZ_REG_RULES) ||\n\t\t    (num_6ghz_client[WMI_REG_STANDARD_POWER_AP][i] >\n\t\t\t\t\t\t\t     MAX_6GHZ_REG_RULES) ||\n\t\t    (num_6ghz_client[WMI_REG_VERY_LOW_POWER_AP][i] >\n\t\t\t\t\t\t\t     MAX_6GHZ_REG_RULES)) {\n\t\t\tath11k_warn(ab,\n\t\t\t\t    \"Num 6 GHz client reg rules exceeds max limit, for client(type: %d)\\n\",\n\t\t\t\t    i);\n\t\t\tkfree(tb);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (!total_reg_rules) {\n\t\tath11k_warn(ab, \"No reg rules available\\n\");\n\t\tkfree(tb);\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(reg_info->alpha2, &ev->alpha2, REG_ALPHA2_LEN);\n\n\treg_info->dfs_region = ev->dfs_region;\n\treg_info->phybitmap = ev->phybitmap;\n\treg_info->num_phy = ev->num_phy;\n\treg_info->phy_id = ev->phy_id;\n\treg_info->ctry_code = ev->country_id;\n\treg_info->reg_dmn_pair = ev->domain_code;\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t   \"status_code %s\",\n\t\t   ath11k_cc_status_to_str(reg_info->status_code));\n\n\treg_info->status_code =\n\t\tath11k_wmi_cc_setting_code_to_reg(ev->status_code);\n\n\treg_info->is_ext_reg_event = true;\n\n\treg_info->min_bw_2ghz = ev->min_bw_2ghz;\n\treg_info->max_bw_2ghz = ev->max_bw_2ghz;\n\treg_info->min_bw_5ghz = ev->min_bw_5ghz;\n\treg_info->max_bw_5ghz = ev->max_bw_5ghz;\n\n\treg_info->min_bw_6ghz_ap[WMI_REG_INDOOR_AP] =\n\t\t\tev->min_bw_6ghz_ap_lpi;\n\treg_info->max_bw_6ghz_ap[WMI_REG_INDOOR_AP] =\n\t\t\tev->max_bw_6ghz_ap_lpi;\n\treg_info->min_bw_6ghz_ap[WMI_REG_STANDARD_POWER_AP] =\n\t\t\tev->min_bw_6ghz_ap_sp;\n\treg_info->max_bw_6ghz_ap[WMI_REG_STANDARD_POWER_AP] =\n\t\t\tev->max_bw_6ghz_ap_sp;\n\treg_info->min_bw_6ghz_ap[WMI_REG_VERY_LOW_POWER_AP] =\n\t\t\tev->min_bw_6ghz_ap_vlp;\n\treg_info->max_bw_6ghz_ap[WMI_REG_VERY_LOW_POWER_AP] =\n\t\t\tev->max_bw_6ghz_ap_vlp;\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t   \"6 GHz AP BW: LPI (%d - %d), SP (%d - %d), VLP (%d - %d)\\n\",\n\t\t   reg_info->min_bw_6ghz_ap[WMI_REG_INDOOR_AP],\n\t\t   reg_info->max_bw_6ghz_ap[WMI_REG_INDOOR_AP],\n\t\t   reg_info->min_bw_6ghz_ap[WMI_REG_STANDARD_POWER_AP],\n\t\t   reg_info->max_bw_6ghz_ap[WMI_REG_STANDARD_POWER_AP],\n\t\t   reg_info->min_bw_6ghz_ap[WMI_REG_VERY_LOW_POWER_AP],\n\t\t   reg_info->max_bw_6ghz_ap[WMI_REG_VERY_LOW_POWER_AP]);\n\n\tfor (i = 0; i < WMI_REG_MAX_CLIENT_TYPE; i++) {\n\t\treg_info->min_bw_6ghz_client[WMI_REG_INDOOR_AP][i] =\n\t\t\t\tev->min_bw_6ghz_client_lpi[i];\n\t\treg_info->max_bw_6ghz_client[WMI_REG_INDOOR_AP][i] =\n\t\t\t\tev->max_bw_6ghz_client_lpi[i];\n\t\treg_info->min_bw_6ghz_client[WMI_REG_STANDARD_POWER_AP][i] =\n\t\t\t\tev->min_bw_6ghz_client_sp[i];\n\t\treg_info->max_bw_6ghz_client[WMI_REG_STANDARD_POWER_AP][i] =\n\t\t\t\tev->max_bw_6ghz_client_sp[i];\n\t\treg_info->min_bw_6ghz_client[WMI_REG_VERY_LOW_POWER_AP][i] =\n\t\t\t\tev->min_bw_6ghz_client_vlp[i];\n\t\treg_info->max_bw_6ghz_client[WMI_REG_VERY_LOW_POWER_AP][i] =\n\t\t\t\tev->max_bw_6ghz_client_vlp[i];\n\n\t\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t\t   \"6 GHz %s BW: LPI (%d - %d), SP (%d - %d), VLP (%d - %d)\\n\",\n\t\t\t   ath11k_6ghz_client_type_to_str(i),\n\t\t\t   reg_info->min_bw_6ghz_client[WMI_REG_INDOOR_AP][i],\n\t\t\t   reg_info->max_bw_6ghz_client[WMI_REG_INDOOR_AP][i],\n\t\t\t   reg_info->min_bw_6ghz_client[WMI_REG_STANDARD_POWER_AP][i],\n\t\t\t   reg_info->max_bw_6ghz_client[WMI_REG_STANDARD_POWER_AP][i],\n\t\t\t   reg_info->min_bw_6ghz_client[WMI_REG_VERY_LOW_POWER_AP][i],\n\t\t\t   reg_info->max_bw_6ghz_client[WMI_REG_VERY_LOW_POWER_AP][i]);\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t   \"cc_ext %s dsf %d BW: min_2ghz %d max_2ghz %d min_5ghz %d max_5ghz %d\",\n\t\t   reg_info->alpha2, reg_info->dfs_region,\n\t\t   reg_info->min_bw_2ghz, reg_info->max_bw_2ghz,\n\t\t   reg_info->min_bw_5ghz, reg_info->max_bw_5ghz);\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t   \"num_2ghz_reg_rules %d num_5ghz_reg_rules %d\",\n\t\t   num_2ghz_reg_rules, num_5ghz_reg_rules);\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t   \"num_6ghz_reg_rules_ap_lpi: %d num_6ghz_reg_rules_ap_sp: %d num_6ghz_reg_rules_ap_vlp: %d\",\n\t\t   num_6ghz_reg_rules_ap[WMI_REG_INDOOR_AP],\n\t\t   num_6ghz_reg_rules_ap[WMI_REG_STANDARD_POWER_AP],\n\t\t   num_6ghz_reg_rules_ap[WMI_REG_VERY_LOW_POWER_AP]);\n\n\tj = WMI_REG_DEFAULT_CLIENT;\n\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t   \"6 GHz Regular client: num_6ghz_reg_rules_lpi: %d num_6ghz_reg_rules_sp: %d num_6ghz_reg_rules_vlp: %d\",\n\t\t   num_6ghz_client[WMI_REG_INDOOR_AP][j],\n\t\t   num_6ghz_client[WMI_REG_STANDARD_POWER_AP][j],\n\t\t   num_6ghz_client[WMI_REG_VERY_LOW_POWER_AP][j]);\n\n\tj = WMI_REG_SUBORDINATE_CLIENT;\n\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t   \"6 GHz Subordinate client: num_6ghz_reg_rules_lpi: %d num_6ghz_reg_rules_sp: %d num_6ghz_reg_rules_vlp: %d\",\n\t\t   num_6ghz_client[WMI_REG_INDOOR_AP][j],\n\t\t   num_6ghz_client[WMI_REG_STANDARD_POWER_AP][j],\n\t\t   num_6ghz_client[WMI_REG_VERY_LOW_POWER_AP][j]);\n\n\text_wmi_reg_rule =\n\t\t(struct wmi_regulatory_ext_rule *)((u8 *)ev + sizeof(*ev) +\n\t\t\t\t\t\t   sizeof(struct wmi_tlv));\n\tif (num_2ghz_reg_rules) {\n\t\treg_info->reg_rules_2ghz_ptr =\n\t\t\tcreate_ext_reg_rules_from_wmi(num_2ghz_reg_rules,\n\t\t\t\t\t\t      ext_wmi_reg_rule);\n\n\t\tif (!reg_info->reg_rules_2ghz_ptr) {\n\t\t\tkfree(tb);\n\t\t\tath11k_warn(ab, \"Unable to Allocate memory for 2 GHz rules\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tath11k_print_reg_rule(ab, \"2 GHz\",\n\t\t\t\t      num_2ghz_reg_rules,\n\t\t\t\t      reg_info->reg_rules_2ghz_ptr);\n\t}\n\n\text_wmi_reg_rule += num_2ghz_reg_rules;\n\n\t \n\tnum_invalid_5ghz_ext_rules =\n\t\tath11k_invalid_5ghz_reg_ext_rules_from_wmi(num_5ghz_reg_rules,\n\t\t\t\t\t\t\t   ext_wmi_reg_rule);\n\n\tif (num_invalid_5ghz_ext_rules) {\n\t\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t\t   \"CC: %s 5 GHz reg rules number %d from fw, %d number of invalid 5 GHz rules\",\n\t\t\t   reg_info->alpha2, reg_info->num_5ghz_reg_rules,\n\t\t\t   num_invalid_5ghz_ext_rules);\n\n\t\tnum_5ghz_reg_rules = num_5ghz_reg_rules - num_invalid_5ghz_ext_rules;\n\t\treg_info->num_5ghz_reg_rules = num_5ghz_reg_rules;\n\t}\n\n\tif (num_5ghz_reg_rules) {\n\t\treg_info->reg_rules_5ghz_ptr =\n\t\t\tcreate_ext_reg_rules_from_wmi(num_5ghz_reg_rules,\n\t\t\t\t\t\t      ext_wmi_reg_rule);\n\n\t\tif (!reg_info->reg_rules_5ghz_ptr) {\n\t\t\tkfree(tb);\n\t\t\tath11k_warn(ab, \"Unable to Allocate memory for 5 GHz rules\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tath11k_print_reg_rule(ab, \"5 GHz\",\n\t\t\t\t      num_5ghz_reg_rules,\n\t\t\t\t      reg_info->reg_rules_5ghz_ptr);\n\t}\n\n\t \n\text_wmi_reg_rule += (num_5ghz_reg_rules + num_invalid_5ghz_ext_rules);\n\n\tfor (i = 0; i < WMI_REG_CURRENT_MAX_AP_TYPE; i++) {\n\t\treg_info->reg_rules_6ghz_ap_ptr[i] =\n\t\t\tcreate_ext_reg_rules_from_wmi(num_6ghz_reg_rules_ap[i],\n\t\t\t\t\t\t      ext_wmi_reg_rule);\n\n\t\tif (!reg_info->reg_rules_6ghz_ap_ptr[i]) {\n\t\t\tkfree(tb);\n\t\t\tath11k_warn(ab, \"Unable to Allocate memory for 6 GHz AP rules\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tath11k_print_reg_rule(ab, ath11k_6ghz_ap_type_to_str(i),\n\t\t\t\t      num_6ghz_reg_rules_ap[i],\n\t\t\t\t      reg_info->reg_rules_6ghz_ap_ptr[i]);\n\n\t\text_wmi_reg_rule += num_6ghz_reg_rules_ap[i];\n\t}\n\n\tfor (j = 0; j < WMI_REG_CURRENT_MAX_AP_TYPE; j++) {\n\t\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t\t   \"6 GHz AP type %s\", ath11k_6ghz_ap_type_to_str(j));\n\n\t\tfor (i = 0; i < WMI_REG_MAX_CLIENT_TYPE; i++) {\n\t\t\treg_info->reg_rules_6ghz_client_ptr[j][i] =\n\t\t\t\tcreate_ext_reg_rules_from_wmi(num_6ghz_client[j][i],\n\t\t\t\t\t\t\t      ext_wmi_reg_rule);\n\n\t\t\tif (!reg_info->reg_rules_6ghz_client_ptr[j][i]) {\n\t\t\t\tkfree(tb);\n\t\t\t\tath11k_warn(ab, \"Unable to Allocate memory for 6 GHz client rules\\n\");\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\tath11k_print_reg_rule(ab,\n\t\t\t\t\t      ath11k_6ghz_client_type_to_str(i),\n\t\t\t\t\t      num_6ghz_client[j][i],\n\t\t\t\t\t      reg_info->reg_rules_6ghz_client_ptr[j][i]);\n\n\t\t\text_wmi_reg_rule += num_6ghz_client[j][i];\n\t\t}\n\t}\n\n\treg_info->client_type = ev->client_type;\n\treg_info->rnr_tpe_usable = ev->rnr_tpe_usable;\n\treg_info->unspecified_ap_usable =\n\t\t\tev->unspecified_ap_usable;\n\treg_info->domain_code_6ghz_ap[WMI_REG_INDOOR_AP] =\n\t\t\tev->domain_code_6ghz_ap_lpi;\n\treg_info->domain_code_6ghz_ap[WMI_REG_STANDARD_POWER_AP] =\n\t\t\tev->domain_code_6ghz_ap_sp;\n\treg_info->domain_code_6ghz_ap[WMI_REG_VERY_LOW_POWER_AP] =\n\t\t\tev->domain_code_6ghz_ap_vlp;\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t   \"6 GHz reg info client type %s rnr_tpe_usable %d unspecified_ap_usable %d AP sub domain: lpi %s, sp %s, vlp %s\\n\",\n\t\t   ath11k_6ghz_client_type_to_str(reg_info->client_type),\n\t\t   reg_info->rnr_tpe_usable,\n\t\t   reg_info->unspecified_ap_usable,\n\t\t   ath11k_sub_reg_6ghz_to_str(ev->domain_code_6ghz_ap_lpi),\n\t\t   ath11k_sub_reg_6ghz_to_str(ev->domain_code_6ghz_ap_sp),\n\t\t   ath11k_sub_reg_6ghz_to_str(ev->domain_code_6ghz_ap_vlp));\n\n\tfor (i = 0; i < WMI_REG_MAX_CLIENT_TYPE; i++) {\n\t\treg_info->domain_code_6ghz_client[WMI_REG_INDOOR_AP][i] =\n\t\t\t\tev->domain_code_6ghz_client_lpi[i];\n\t\treg_info->domain_code_6ghz_client[WMI_REG_STANDARD_POWER_AP][i] =\n\t\t\t\tev->domain_code_6ghz_client_sp[i];\n\t\treg_info->domain_code_6ghz_client[WMI_REG_VERY_LOW_POWER_AP][i] =\n\t\t\t\tev->domain_code_6ghz_client_vlp[i];\n\n\t\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t\t   \"6 GHz client type %s client sub domain: lpi %s, sp %s, vlp %s\\n\",\n\t\t\t   ath11k_6ghz_client_type_to_str(i),\n\t\t\t   ath11k_sub_reg_6ghz_to_str(ev->domain_code_6ghz_client_lpi[i]),\n\t\t\t   ath11k_sub_reg_6ghz_to_str(ev->domain_code_6ghz_client_sp[i]),\n\t\t\t   ath11k_sub_reg_6ghz_to_str(ev->domain_code_6ghz_client_vlp[i])\n\t\t\t  );\n\t}\n\n\treg_info->domain_code_6ghz_super_id = ev->domain_code_6ghz_super_id;\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t   \"6 GHz client_type %s 6 GHz super domain %s\",\n\t\t   ath11k_6ghz_client_type_to_str(reg_info->client_type),\n\t\t   ath11k_super_reg_6ghz_to_str(reg_info->domain_code_6ghz_super_id));\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI, \"processed regulatory ext channel list\\n\");\n\n\tkfree(tb);\n\treturn 0;\n}\n\nstatic int ath11k_pull_peer_del_resp_ev(struct ath11k_base *ab, struct sk_buff *skb,\n\t\t\t\t\tstruct wmi_peer_delete_resp_event *peer_del_resp)\n{\n\tconst void **tb;\n\tconst struct wmi_peer_delete_resp_event *ev;\n\tint ret;\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = tb[WMI_TAG_PEER_DELETE_RESP_EVENT];\n\tif (!ev) {\n\t\tath11k_warn(ab, \"failed to fetch peer delete resp ev\");\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\tmemset(peer_del_resp, 0, sizeof(*peer_del_resp));\n\n\tpeer_del_resp->vdev_id = ev->vdev_id;\n\tether_addr_copy(peer_del_resp->peer_macaddr.addr,\n\t\t\tev->peer_macaddr.addr);\n\n\tkfree(tb);\n\treturn 0;\n}\n\nstatic int ath11k_pull_vdev_del_resp_ev(struct ath11k_base *ab,\n\t\t\t\t\tstruct sk_buff *skb,\n\t\t\t\t\tu32 *vdev_id)\n{\n\tconst void **tb;\n\tconst struct wmi_vdev_delete_resp_event *ev;\n\tint ret;\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = tb[WMI_TAG_VDEV_DELETE_RESP_EVENT];\n\tif (!ev) {\n\t\tath11k_warn(ab, \"failed to fetch vdev delete resp ev\");\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\t*vdev_id = ev->vdev_id;\n\n\tkfree(tb);\n\treturn 0;\n}\n\nstatic int ath11k_pull_bcn_tx_status_ev(struct ath11k_base *ab, void *evt_buf,\n\t\t\t\t\tu32 len, u32 *vdev_id,\n\t\t\t\t\tu32 *tx_status)\n{\n\tconst void **tb;\n\tconst struct wmi_bcn_tx_status_event *ev;\n\tint ret;\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, evt_buf, len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = tb[WMI_TAG_OFFLOAD_BCN_TX_STATUS_EVENT];\n\tif (!ev) {\n\t\tath11k_warn(ab, \"failed to fetch bcn tx status ev\");\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\t*vdev_id   = ev->vdev_id;\n\t*tx_status = ev->tx_status;\n\n\tkfree(tb);\n\treturn 0;\n}\n\nstatic int ath11k_pull_vdev_stopped_param_tlv(struct ath11k_base *ab, struct sk_buff *skb,\n\t\t\t\t\t      u32 *vdev_id)\n{\n\tconst void **tb;\n\tconst struct wmi_vdev_stopped_event *ev;\n\tint ret;\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = tb[WMI_TAG_VDEV_STOPPED_EVENT];\n\tif (!ev) {\n\t\tath11k_warn(ab, \"failed to fetch vdev stop ev\");\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\t*vdev_id =  ev->vdev_id;\n\n\tkfree(tb);\n\treturn 0;\n}\n\nstatic int ath11k_wmi_tlv_mgmt_rx_parse(struct ath11k_base *ab,\n\t\t\t\t\tu16 tag, u16 len,\n\t\t\t\t\tconst void *ptr, void *data)\n{\n\tstruct wmi_tlv_mgmt_rx_parse *parse = data;\n\n\tswitch (tag) {\n\tcase WMI_TAG_MGMT_RX_HDR:\n\t\tparse->fixed = ptr;\n\t\tbreak;\n\tcase WMI_TAG_ARRAY_BYTE:\n\t\tif (!parse->frame_buf_done) {\n\t\t\tparse->frame_buf = ptr;\n\t\t\tparse->frame_buf_done = true;\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int ath11k_pull_mgmt_rx_params_tlv(struct ath11k_base *ab,\n\t\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t\t  struct mgmt_rx_event_params *hdr)\n{\n\tstruct wmi_tlv_mgmt_rx_parse parse = { };\n\tconst struct wmi_mgmt_rx_hdr *ev;\n\tconst u8 *frame;\n\tint ret;\n\n\tret = ath11k_wmi_tlv_iter(ab, skb->data, skb->len,\n\t\t\t\t  ath11k_wmi_tlv_mgmt_rx_parse,\n\t\t\t\t  &parse);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to parse mgmt rx tlv %d\\n\",\n\t\t\t    ret);\n\t\treturn ret;\n\t}\n\n\tev = parse.fixed;\n\tframe = parse.frame_buf;\n\n\tif (!ev || !frame) {\n\t\tath11k_warn(ab, \"failed to fetch mgmt rx hdr\");\n\t\treturn -EPROTO;\n\t}\n\n\thdr->pdev_id =  ev->pdev_id;\n\thdr->chan_freq = ev->chan_freq;\n\thdr->channel =  ev->channel;\n\thdr->snr =  ev->snr;\n\thdr->rate =  ev->rate;\n\thdr->phy_mode =  ev->phy_mode;\n\thdr->buf_len =  ev->buf_len;\n\thdr->status =  ev->status;\n\thdr->flags =  ev->flags;\n\thdr->rssi =  ev->rssi;\n\thdr->tsf_delta =  ev->tsf_delta;\n\tmemcpy(hdr->rssi_ctl, ev->rssi_ctl, sizeof(hdr->rssi_ctl));\n\n\tif (skb->len < (frame - skb->data) + hdr->buf_len) {\n\t\tath11k_warn(ab, \"invalid length in mgmt rx hdr ev\");\n\t\treturn -EPROTO;\n\t}\n\n\t \n\tskb_trim(skb, 0);\n\tskb_put(skb, frame - skb->data);\n\tskb_pull(skb, frame - skb->data);\n\tskb_put(skb, hdr->buf_len);\n\n\tath11k_ce_byte_swap(skb->data, hdr->buf_len);\n\n\treturn 0;\n}\n\nstatic int wmi_process_mgmt_tx_comp(struct ath11k *ar,\n\t\t\t\t    struct wmi_mgmt_tx_compl_event *tx_compl_param)\n{\n\tstruct sk_buff *msdu;\n\tstruct ieee80211_tx_info *info;\n\tstruct ath11k_skb_cb *skb_cb;\n\tint num_mgmt;\n\n\tspin_lock_bh(&ar->txmgmt_idr_lock);\n\tmsdu = idr_find(&ar->txmgmt_idr, tx_compl_param->desc_id);\n\n\tif (!msdu) {\n\t\tath11k_warn(ar->ab, \"received mgmt tx compl for invalid msdu_id: %d\\n\",\n\t\t\t    tx_compl_param->desc_id);\n\t\tspin_unlock_bh(&ar->txmgmt_idr_lock);\n\t\treturn -ENOENT;\n\t}\n\n\tidr_remove(&ar->txmgmt_idr, tx_compl_param->desc_id);\n\tspin_unlock_bh(&ar->txmgmt_idr_lock);\n\n\tskb_cb = ATH11K_SKB_CB(msdu);\n\tdma_unmap_single(ar->ab->dev, skb_cb->paddr, msdu->len, DMA_TO_DEVICE);\n\n\tinfo = IEEE80211_SKB_CB(msdu);\n\tif ((!(info->flags & IEEE80211_TX_CTL_NO_ACK)) &&\n\t    !tx_compl_param->status) {\n\t\tinfo->flags |= IEEE80211_TX_STAT_ACK;\n\t\tif (test_bit(WMI_TLV_SERVICE_TX_DATA_MGMT_ACK_RSSI,\n\t\t\t     ar->ab->wmi_ab.svc_map))\n\t\t\tinfo->status.ack_signal = tx_compl_param->ack_rssi;\n\t}\n\n\tieee80211_tx_status_irqsafe(ar->hw, msdu);\n\n\tnum_mgmt = atomic_dec_if_positive(&ar->num_pending_mgmt_tx);\n\n\t \n\tif (num_mgmt < 0)\n\t\tWARN_ON_ONCE(1);\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"mgmt tx comp pending %d desc id %d\\n\",\n\t\t   num_mgmt, tx_compl_param->desc_id);\n\n\tif (!num_mgmt)\n\t\twake_up(&ar->txmgmt_empty_waitq);\n\n\treturn 0;\n}\n\nstatic int ath11k_pull_mgmt_tx_compl_param_tlv(struct ath11k_base *ab,\n\t\t\t\t\t       struct sk_buff *skb,\n\t\t\t\t\t       struct wmi_mgmt_tx_compl_event *param)\n{\n\tconst void **tb;\n\tconst struct wmi_mgmt_tx_compl_event *ev;\n\tint ret;\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = tb[WMI_TAG_MGMT_TX_COMPL_EVENT];\n\tif (!ev) {\n\t\tath11k_warn(ab, \"failed to fetch mgmt tx compl ev\");\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\tparam->pdev_id = ev->pdev_id;\n\tparam->desc_id = ev->desc_id;\n\tparam->status = ev->status;\n\tparam->ack_rssi = ev->ack_rssi;\n\n\tkfree(tb);\n\treturn 0;\n}\n\nstatic void ath11k_wmi_event_scan_started(struct ath11k *ar)\n{\n\tlockdep_assert_held(&ar->data_lock);\n\n\tswitch (ar->scan.state) {\n\tcase ATH11K_SCAN_IDLE:\n\tcase ATH11K_SCAN_RUNNING:\n\tcase ATH11K_SCAN_ABORTING:\n\t\tath11k_warn(ar->ab, \"received scan started event in an invalid scan state: %s (%d)\\n\",\n\t\t\t    ath11k_scan_state_str(ar->scan.state),\n\t\t\t    ar->scan.state);\n\t\tbreak;\n\tcase ATH11K_SCAN_STARTING:\n\t\tar->scan.state = ATH11K_SCAN_RUNNING;\n\t\tif (ar->scan.is_roc)\n\t\t\tieee80211_ready_on_channel(ar->hw);\n\t\tcomplete(&ar->scan.started);\n\t\tbreak;\n\t}\n}\n\nstatic void ath11k_wmi_event_scan_start_failed(struct ath11k *ar)\n{\n\tlockdep_assert_held(&ar->data_lock);\n\n\tswitch (ar->scan.state) {\n\tcase ATH11K_SCAN_IDLE:\n\tcase ATH11K_SCAN_RUNNING:\n\tcase ATH11K_SCAN_ABORTING:\n\t\tath11k_warn(ar->ab, \"received scan start failed event in an invalid scan state: %s (%d)\\n\",\n\t\t\t    ath11k_scan_state_str(ar->scan.state),\n\t\t\t    ar->scan.state);\n\t\tbreak;\n\tcase ATH11K_SCAN_STARTING:\n\t\tcomplete(&ar->scan.started);\n\t\t__ath11k_mac_scan_finish(ar);\n\t\tbreak;\n\t}\n}\n\nstatic void ath11k_wmi_event_scan_completed(struct ath11k *ar)\n{\n\tlockdep_assert_held(&ar->data_lock);\n\n\tswitch (ar->scan.state) {\n\tcase ATH11K_SCAN_IDLE:\n\tcase ATH11K_SCAN_STARTING:\n\t\t \n\t\tath11k_warn(ar->ab, \"received scan completed event in an invalid scan state: %s (%d)\\n\",\n\t\t\t    ath11k_scan_state_str(ar->scan.state),\n\t\t\t    ar->scan.state);\n\t\tbreak;\n\tcase ATH11K_SCAN_RUNNING:\n\tcase ATH11K_SCAN_ABORTING:\n\t\t__ath11k_mac_scan_finish(ar);\n\t\tbreak;\n\t}\n}\n\nstatic void ath11k_wmi_event_scan_bss_chan(struct ath11k *ar)\n{\n\tlockdep_assert_held(&ar->data_lock);\n\n\tswitch (ar->scan.state) {\n\tcase ATH11K_SCAN_IDLE:\n\tcase ATH11K_SCAN_STARTING:\n\t\tath11k_warn(ar->ab, \"received scan bss chan event in an invalid scan state: %s (%d)\\n\",\n\t\t\t    ath11k_scan_state_str(ar->scan.state),\n\t\t\t    ar->scan.state);\n\t\tbreak;\n\tcase ATH11K_SCAN_RUNNING:\n\tcase ATH11K_SCAN_ABORTING:\n\t\tar->scan_channel = NULL;\n\t\tbreak;\n\t}\n}\n\nstatic void ath11k_wmi_event_scan_foreign_chan(struct ath11k *ar, u32 freq)\n{\n\tlockdep_assert_held(&ar->data_lock);\n\n\tswitch (ar->scan.state) {\n\tcase ATH11K_SCAN_IDLE:\n\tcase ATH11K_SCAN_STARTING:\n\t\tath11k_warn(ar->ab, \"received scan foreign chan event in an invalid scan state: %s (%d)\\n\",\n\t\t\t    ath11k_scan_state_str(ar->scan.state),\n\t\t\t    ar->scan.state);\n\t\tbreak;\n\tcase ATH11K_SCAN_RUNNING:\n\tcase ATH11K_SCAN_ABORTING:\n\t\tar->scan_channel = ieee80211_get_channel(ar->hw->wiphy, freq);\n\t\tif (ar->scan.is_roc && ar->scan.roc_freq == freq)\n\t\t\tcomplete(&ar->scan.on_channel);\n\t\tbreak;\n\t}\n}\n\nstatic const char *\nath11k_wmi_event_scan_type_str(enum wmi_scan_event_type type,\n\t\t\t       enum wmi_scan_completion_reason reason)\n{\n\tswitch (type) {\n\tcase WMI_SCAN_EVENT_STARTED:\n\t\treturn \"started\";\n\tcase WMI_SCAN_EVENT_COMPLETED:\n\t\tswitch (reason) {\n\t\tcase WMI_SCAN_REASON_COMPLETED:\n\t\t\treturn \"completed\";\n\t\tcase WMI_SCAN_REASON_CANCELLED:\n\t\t\treturn \"completed [cancelled]\";\n\t\tcase WMI_SCAN_REASON_PREEMPTED:\n\t\t\treturn \"completed [preempted]\";\n\t\tcase WMI_SCAN_REASON_TIMEDOUT:\n\t\t\treturn \"completed [timedout]\";\n\t\tcase WMI_SCAN_REASON_INTERNAL_FAILURE:\n\t\t\treturn \"completed [internal err]\";\n\t\tcase WMI_SCAN_REASON_MAX:\n\t\t\tbreak;\n\t\t}\n\t\treturn \"completed [unknown]\";\n\tcase WMI_SCAN_EVENT_BSS_CHANNEL:\n\t\treturn \"bss channel\";\n\tcase WMI_SCAN_EVENT_FOREIGN_CHAN:\n\t\treturn \"foreign channel\";\n\tcase WMI_SCAN_EVENT_DEQUEUED:\n\t\treturn \"dequeued\";\n\tcase WMI_SCAN_EVENT_PREEMPTED:\n\t\treturn \"preempted\";\n\tcase WMI_SCAN_EVENT_START_FAILED:\n\t\treturn \"start failed\";\n\tcase WMI_SCAN_EVENT_RESTARTED:\n\t\treturn \"restarted\";\n\tcase WMI_SCAN_EVENT_FOREIGN_CHAN_EXIT:\n\t\treturn \"foreign channel exit\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\nstatic int ath11k_pull_scan_ev(struct ath11k_base *ab, struct sk_buff *skb,\n\t\t\t       struct wmi_scan_event *scan_evt_param)\n{\n\tconst void **tb;\n\tconst struct wmi_scan_event *ev;\n\tint ret;\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = tb[WMI_TAG_SCAN_EVENT];\n\tif (!ev) {\n\t\tath11k_warn(ab, \"failed to fetch scan ev\");\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\tscan_evt_param->event_type = ev->event_type;\n\tscan_evt_param->reason = ev->reason;\n\tscan_evt_param->channel_freq = ev->channel_freq;\n\tscan_evt_param->scan_req_id = ev->scan_req_id;\n\tscan_evt_param->scan_id = ev->scan_id;\n\tscan_evt_param->vdev_id = ev->vdev_id;\n\tscan_evt_param->tsf_timestamp = ev->tsf_timestamp;\n\n\tkfree(tb);\n\treturn 0;\n}\n\nstatic int ath11k_pull_peer_sta_kickout_ev(struct ath11k_base *ab, struct sk_buff *skb,\n\t\t\t\t\t   struct wmi_peer_sta_kickout_arg *arg)\n{\n\tconst void **tb;\n\tconst struct wmi_peer_sta_kickout_event *ev;\n\tint ret;\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = tb[WMI_TAG_PEER_STA_KICKOUT_EVENT];\n\tif (!ev) {\n\t\tath11k_warn(ab, \"failed to fetch peer sta kickout ev\");\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\targ->mac_addr = ev->peer_macaddr.addr;\n\n\tkfree(tb);\n\treturn 0;\n}\n\nstatic int ath11k_pull_roam_ev(struct ath11k_base *ab, struct sk_buff *skb,\n\t\t\t       struct wmi_roam_event *roam_ev)\n{\n\tconst void **tb;\n\tconst struct wmi_roam_event *ev;\n\tint ret;\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = tb[WMI_TAG_ROAM_EVENT];\n\tif (!ev) {\n\t\tath11k_warn(ab, \"failed to fetch roam ev\");\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\troam_ev->vdev_id = ev->vdev_id;\n\troam_ev->reason = ev->reason;\n\troam_ev->rssi = ev->rssi;\n\n\tkfree(tb);\n\treturn 0;\n}\n\nstatic int freq_to_idx(struct ath11k *ar, int freq)\n{\n\tstruct ieee80211_supported_band *sband;\n\tint band, ch, idx = 0;\n\n\tfor (band = NL80211_BAND_2GHZ; band < NUM_NL80211_BANDS; band++) {\n\t\tsband = ar->hw->wiphy->bands[band];\n\t\tif (!sband)\n\t\t\tcontinue;\n\n\t\tfor (ch = 0; ch < sband->n_channels; ch++, idx++)\n\t\t\tif (sband->channels[ch].center_freq == freq)\n\t\t\t\tgoto exit;\n\t}\n\nexit:\n\treturn idx;\n}\n\nstatic int ath11k_pull_chan_info_ev(struct ath11k_base *ab, u8 *evt_buf,\n\t\t\t\t    u32 len, struct wmi_chan_info_event *ch_info_ev)\n{\n\tconst void **tb;\n\tconst struct wmi_chan_info_event *ev;\n\tint ret;\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, evt_buf, len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = tb[WMI_TAG_CHAN_INFO_EVENT];\n\tif (!ev) {\n\t\tath11k_warn(ab, \"failed to fetch chan info ev\");\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\tch_info_ev->err_code = ev->err_code;\n\tch_info_ev->freq = ev->freq;\n\tch_info_ev->cmd_flags = ev->cmd_flags;\n\tch_info_ev->noise_floor = ev->noise_floor;\n\tch_info_ev->rx_clear_count = ev->rx_clear_count;\n\tch_info_ev->cycle_count = ev->cycle_count;\n\tch_info_ev->chan_tx_pwr_range = ev->chan_tx_pwr_range;\n\tch_info_ev->chan_tx_pwr_tp = ev->chan_tx_pwr_tp;\n\tch_info_ev->rx_frame_count = ev->rx_frame_count;\n\tch_info_ev->tx_frame_cnt = ev->tx_frame_cnt;\n\tch_info_ev->mac_clk_mhz = ev->mac_clk_mhz;\n\tch_info_ev->vdev_id = ev->vdev_id;\n\n\tkfree(tb);\n\treturn 0;\n}\n\nstatic int\nath11k_pull_pdev_bss_chan_info_ev(struct ath11k_base *ab, struct sk_buff *skb,\n\t\t\t\t  struct wmi_pdev_bss_chan_info_event *bss_ch_info_ev)\n{\n\tconst void **tb;\n\tconst struct wmi_pdev_bss_chan_info_event *ev;\n\tint ret;\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = tb[WMI_TAG_PDEV_BSS_CHAN_INFO_EVENT];\n\tif (!ev) {\n\t\tath11k_warn(ab, \"failed to fetch pdev bss chan info ev\");\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\tbss_ch_info_ev->pdev_id = ev->pdev_id;\n\tbss_ch_info_ev->freq = ev->freq;\n\tbss_ch_info_ev->noise_floor = ev->noise_floor;\n\tbss_ch_info_ev->rx_clear_count_low = ev->rx_clear_count_low;\n\tbss_ch_info_ev->rx_clear_count_high = ev->rx_clear_count_high;\n\tbss_ch_info_ev->cycle_count_low = ev->cycle_count_low;\n\tbss_ch_info_ev->cycle_count_high = ev->cycle_count_high;\n\tbss_ch_info_ev->tx_cycle_count_low = ev->tx_cycle_count_low;\n\tbss_ch_info_ev->tx_cycle_count_high = ev->tx_cycle_count_high;\n\tbss_ch_info_ev->rx_cycle_count_low = ev->rx_cycle_count_low;\n\tbss_ch_info_ev->rx_cycle_count_high = ev->rx_cycle_count_high;\n\tbss_ch_info_ev->rx_bss_cycle_count_low = ev->rx_bss_cycle_count_low;\n\tbss_ch_info_ev->rx_bss_cycle_count_high = ev->rx_bss_cycle_count_high;\n\n\tkfree(tb);\n\treturn 0;\n}\n\nstatic int\nath11k_pull_vdev_install_key_compl_ev(struct ath11k_base *ab, struct sk_buff *skb,\n\t\t\t\t      struct wmi_vdev_install_key_complete_arg *arg)\n{\n\tconst void **tb;\n\tconst struct wmi_vdev_install_key_compl_event *ev;\n\tint ret;\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = tb[WMI_TAG_VDEV_INSTALL_KEY_COMPLETE_EVENT];\n\tif (!ev) {\n\t\tath11k_warn(ab, \"failed to fetch vdev install key compl ev\");\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\targ->vdev_id = ev->vdev_id;\n\targ->macaddr = ev->peer_macaddr.addr;\n\targ->key_idx = ev->key_idx;\n\targ->key_flags = ev->key_flags;\n\targ->status = ev->status;\n\n\tkfree(tb);\n\treturn 0;\n}\n\nstatic int ath11k_pull_peer_assoc_conf_ev(struct ath11k_base *ab, struct sk_buff *skb,\n\t\t\t\t\t  struct wmi_peer_assoc_conf_arg *peer_assoc_conf)\n{\n\tconst void **tb;\n\tconst struct wmi_peer_assoc_conf_event *ev;\n\tint ret;\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = tb[WMI_TAG_PEER_ASSOC_CONF_EVENT];\n\tif (!ev) {\n\t\tath11k_warn(ab, \"failed to fetch peer assoc conf ev\");\n\t\tkfree(tb);\n\t\treturn -EPROTO;\n\t}\n\n\tpeer_assoc_conf->vdev_id = ev->vdev_id;\n\tpeer_assoc_conf->macaddr = ev->peer_macaddr.addr;\n\n\tkfree(tb);\n\treturn 0;\n}\n\nstatic void ath11k_wmi_pull_pdev_stats_base(const struct wmi_pdev_stats_base *src,\n\t\t\t\t\t    struct ath11k_fw_stats_pdev *dst)\n{\n\tdst->ch_noise_floor = src->chan_nf;\n\tdst->tx_frame_count = src->tx_frame_count;\n\tdst->rx_frame_count = src->rx_frame_count;\n\tdst->rx_clear_count = src->rx_clear_count;\n\tdst->cycle_count = src->cycle_count;\n\tdst->phy_err_count = src->phy_err_count;\n\tdst->chan_tx_power = src->chan_tx_pwr;\n}\n\nstatic void\nath11k_wmi_pull_pdev_stats_tx(const struct wmi_pdev_stats_tx *src,\n\t\t\t      struct ath11k_fw_stats_pdev *dst)\n{\n\tdst->comp_queued = src->comp_queued;\n\tdst->comp_delivered = src->comp_delivered;\n\tdst->msdu_enqued = src->msdu_enqued;\n\tdst->mpdu_enqued = src->mpdu_enqued;\n\tdst->wmm_drop = src->wmm_drop;\n\tdst->local_enqued = src->local_enqued;\n\tdst->local_freed = src->local_freed;\n\tdst->hw_queued = src->hw_queued;\n\tdst->hw_reaped = src->hw_reaped;\n\tdst->underrun = src->underrun;\n\tdst->hw_paused = src->hw_paused;\n\tdst->tx_abort = src->tx_abort;\n\tdst->mpdus_requeued = src->mpdus_requeued;\n\tdst->tx_ko = src->tx_ko;\n\tdst->tx_xretry = src->tx_xretry;\n\tdst->data_rc = src->data_rc;\n\tdst->self_triggers = src->self_triggers;\n\tdst->sw_retry_failure = src->sw_retry_failure;\n\tdst->illgl_rate_phy_err = src->illgl_rate_phy_err;\n\tdst->pdev_cont_xretry = src->pdev_cont_xretry;\n\tdst->pdev_tx_timeout = src->pdev_tx_timeout;\n\tdst->pdev_resets = src->pdev_resets;\n\tdst->stateless_tid_alloc_failure = src->stateless_tid_alloc_failure;\n\tdst->phy_underrun = src->phy_underrun;\n\tdst->txop_ovf = src->txop_ovf;\n\tdst->seq_posted = src->seq_posted;\n\tdst->seq_failed_queueing = src->seq_failed_queueing;\n\tdst->seq_completed = src->seq_completed;\n\tdst->seq_restarted = src->seq_restarted;\n\tdst->mu_seq_posted = src->mu_seq_posted;\n\tdst->mpdus_sw_flush = src->mpdus_sw_flush;\n\tdst->mpdus_hw_filter = src->mpdus_hw_filter;\n\tdst->mpdus_truncated = src->mpdus_truncated;\n\tdst->mpdus_ack_failed = src->mpdus_ack_failed;\n\tdst->mpdus_expired = src->mpdus_expired;\n}\n\nstatic void ath11k_wmi_pull_pdev_stats_rx(const struct wmi_pdev_stats_rx *src,\n\t\t\t\t\t  struct ath11k_fw_stats_pdev *dst)\n{\n\tdst->mid_ppdu_route_change = src->mid_ppdu_route_change;\n\tdst->status_rcvd = src->status_rcvd;\n\tdst->r0_frags = src->r0_frags;\n\tdst->r1_frags = src->r1_frags;\n\tdst->r2_frags = src->r2_frags;\n\tdst->r3_frags = src->r3_frags;\n\tdst->htt_msdus = src->htt_msdus;\n\tdst->htt_mpdus = src->htt_mpdus;\n\tdst->loc_msdus = src->loc_msdus;\n\tdst->loc_mpdus = src->loc_mpdus;\n\tdst->oversize_amsdu = src->oversize_amsdu;\n\tdst->phy_errs = src->phy_errs;\n\tdst->phy_err_drop = src->phy_err_drop;\n\tdst->mpdu_errs = src->mpdu_errs;\n\tdst->rx_ovfl_errs = src->rx_ovfl_errs;\n}\n\nstatic void\nath11k_wmi_pull_vdev_stats(const struct wmi_vdev_stats *src,\n\t\t\t   struct ath11k_fw_stats_vdev *dst)\n{\n\tint i;\n\n\tdst->vdev_id = src->vdev_id;\n\tdst->beacon_snr = src->beacon_snr;\n\tdst->data_snr = src->data_snr;\n\tdst->num_rx_frames = src->num_rx_frames;\n\tdst->num_rts_fail = src->num_rts_fail;\n\tdst->num_rts_success = src->num_rts_success;\n\tdst->num_rx_err = src->num_rx_err;\n\tdst->num_rx_discard = src->num_rx_discard;\n\tdst->num_tx_not_acked = src->num_tx_not_acked;\n\n\tfor (i = 0; i < ARRAY_SIZE(src->num_tx_frames); i++)\n\t\tdst->num_tx_frames[i] = src->num_tx_frames[i];\n\n\tfor (i = 0; i < ARRAY_SIZE(src->num_tx_frames_retries); i++)\n\t\tdst->num_tx_frames_retries[i] = src->num_tx_frames_retries[i];\n\n\tfor (i = 0; i < ARRAY_SIZE(src->num_tx_frames_failures); i++)\n\t\tdst->num_tx_frames_failures[i] = src->num_tx_frames_failures[i];\n\n\tfor (i = 0; i < ARRAY_SIZE(src->tx_rate_history); i++)\n\t\tdst->tx_rate_history[i] = src->tx_rate_history[i];\n\n\tfor (i = 0; i < ARRAY_SIZE(src->beacon_rssi_history); i++)\n\t\tdst->beacon_rssi_history[i] = src->beacon_rssi_history[i];\n}\n\nstatic void\nath11k_wmi_pull_bcn_stats(const struct wmi_bcn_stats *src,\n\t\t\t  struct ath11k_fw_stats_bcn *dst)\n{\n\tdst->vdev_id = src->vdev_id;\n\tdst->tx_bcn_succ_cnt = src->tx_bcn_succ_cnt;\n\tdst->tx_bcn_outage_cnt = src->tx_bcn_outage_cnt;\n}\n\nstatic int ath11k_wmi_tlv_rssi_chain_parse(struct ath11k_base *ab,\n\t\t\t\t\t   u16 tag, u16 len,\n\t\t\t\t\t   const void *ptr, void *data)\n{\n\tstruct wmi_tlv_fw_stats_parse *parse = data;\n\tconst struct wmi_stats_event *ev = parse->ev;\n\tstruct ath11k_fw_stats *stats = parse->stats;\n\tstruct ath11k *ar;\n\tstruct ath11k_vif *arvif;\n\tstruct ieee80211_sta *sta;\n\tstruct ath11k_sta *arsta;\n\tconst struct wmi_rssi_stats *stats_rssi = (const struct wmi_rssi_stats *)ptr;\n\tint j, ret = 0;\n\n\tif (tag != WMI_TAG_RSSI_STATS)\n\t\treturn -EPROTO;\n\n\trcu_read_lock();\n\n\tar = ath11k_mac_get_ar_by_pdev_id(ab, ev->pdev_id);\n\tstats->stats_id = WMI_REQUEST_RSSI_PER_CHAIN_STAT;\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t   \"stats vdev id %d mac %pM\\n\",\n\t\t   stats_rssi->vdev_id, stats_rssi->peer_macaddr.addr);\n\n\tarvif = ath11k_mac_get_arvif(ar, stats_rssi->vdev_id);\n\tif (!arvif) {\n\t\tath11k_warn(ab, \"not found vif for vdev id %d\\n\",\n\t\t\t    stats_rssi->vdev_id);\n\t\tret = -EPROTO;\n\t\tgoto exit;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t   \"stats bssid %pM vif %p\\n\",\n\t\t   arvif->bssid, arvif->vif);\n\n\tsta = ieee80211_find_sta_by_ifaddr(ar->hw,\n\t\t\t\t\t   arvif->bssid,\n\t\t\t\t\t   NULL);\n\tif (!sta) {\n\t\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t\t   \"not found station of bssid %pM for rssi chain\\n\",\n\t\t\t   arvif->bssid);\n\t\tgoto exit;\n\t}\n\n\tarsta = (struct ath11k_sta *)sta->drv_priv;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(arsta->chain_signal) >\n\t\t     ARRAY_SIZE(stats_rssi->rssi_avg_beacon));\n\n\tfor (j = 0; j < ARRAY_SIZE(arsta->chain_signal); j++) {\n\t\tarsta->chain_signal[j] = stats_rssi->rssi_avg_beacon[j];\n\t\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t\t   \"stats beacon rssi[%d] %d data rssi[%d] %d\\n\",\n\t\t\t   j,\n\t\t\t   stats_rssi->rssi_avg_beacon[j],\n\t\t\t   j,\n\t\t\t   stats_rssi->rssi_avg_data[j]);\n\t}\n\nexit:\n\trcu_read_unlock();\n\treturn ret;\n}\n\nstatic int ath11k_wmi_tlv_fw_stats_data_parse(struct ath11k_base *ab,\n\t\t\t\t\t      struct wmi_tlv_fw_stats_parse *parse,\n\t\t\t\t\t      const void *ptr,\n\t\t\t\t\t      u16 len)\n{\n\tstruct ath11k_fw_stats *stats = parse->stats;\n\tconst struct wmi_stats_event *ev = parse->ev;\n\tstruct ath11k *ar;\n\tstruct ath11k_vif *arvif;\n\tstruct ieee80211_sta *sta;\n\tstruct ath11k_sta *arsta;\n\tint i, ret = 0;\n\tconst void *data = ptr;\n\n\tif (!ev) {\n\t\tath11k_warn(ab, \"failed to fetch update stats ev\");\n\t\treturn -EPROTO;\n\t}\n\n\tstats->stats_id = 0;\n\n\trcu_read_lock();\n\n\tar = ath11k_mac_get_ar_by_pdev_id(ab, ev->pdev_id);\n\n\tfor (i = 0; i < ev->num_pdev_stats; i++) {\n\t\tconst struct wmi_pdev_stats *src;\n\t\tstruct ath11k_fw_stats_pdev *dst;\n\n\t\tsrc = data;\n\t\tif (len < sizeof(*src)) {\n\t\t\tret = -EPROTO;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tstats->stats_id = WMI_REQUEST_PDEV_STAT;\n\n\t\tdata += sizeof(*src);\n\t\tlen -= sizeof(*src);\n\n\t\tdst = kzalloc(sizeof(*dst), GFP_ATOMIC);\n\t\tif (!dst)\n\t\t\tcontinue;\n\n\t\tath11k_wmi_pull_pdev_stats_base(&src->base, dst);\n\t\tath11k_wmi_pull_pdev_stats_tx(&src->tx, dst);\n\t\tath11k_wmi_pull_pdev_stats_rx(&src->rx, dst);\n\t\tlist_add_tail(&dst->list, &stats->pdevs);\n\t}\n\n\tfor (i = 0; i < ev->num_vdev_stats; i++) {\n\t\tconst struct wmi_vdev_stats *src;\n\t\tstruct ath11k_fw_stats_vdev *dst;\n\n\t\tsrc = data;\n\t\tif (len < sizeof(*src)) {\n\t\t\tret = -EPROTO;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tstats->stats_id = WMI_REQUEST_VDEV_STAT;\n\n\t\tarvif = ath11k_mac_get_arvif(ar, src->vdev_id);\n\t\tif (arvif) {\n\t\t\tsta = ieee80211_find_sta_by_ifaddr(ar->hw,\n\t\t\t\t\t\t\t   arvif->bssid,\n\t\t\t\t\t\t\t   NULL);\n\t\t\tif (sta) {\n\t\t\t\tarsta = (struct ath11k_sta *)sta->drv_priv;\n\t\t\t\tarsta->rssi_beacon = src->beacon_snr;\n\t\t\t\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t\t\t\t   \"stats vdev id %d snr %d\\n\",\n\t\t\t\t\t   src->vdev_id, src->beacon_snr);\n\t\t\t} else {\n\t\t\t\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t\t\t\t   \"not found station of bssid %pM for vdev stat\\n\",\n\t\t\t\t\t   arvif->bssid);\n\t\t\t}\n\t\t}\n\n\t\tdata += sizeof(*src);\n\t\tlen -= sizeof(*src);\n\n\t\tdst = kzalloc(sizeof(*dst), GFP_ATOMIC);\n\t\tif (!dst)\n\t\t\tcontinue;\n\n\t\tath11k_wmi_pull_vdev_stats(src, dst);\n\t\tlist_add_tail(&dst->list, &stats->vdevs);\n\t}\n\n\tfor (i = 0; i < ev->num_bcn_stats; i++) {\n\t\tconst struct wmi_bcn_stats *src;\n\t\tstruct ath11k_fw_stats_bcn *dst;\n\n\t\tsrc = data;\n\t\tif (len < sizeof(*src)) {\n\t\t\tret = -EPROTO;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tstats->stats_id = WMI_REQUEST_BCN_STAT;\n\n\t\tdata += sizeof(*src);\n\t\tlen -= sizeof(*src);\n\n\t\tdst = kzalloc(sizeof(*dst), GFP_ATOMIC);\n\t\tif (!dst)\n\t\t\tcontinue;\n\n\t\tath11k_wmi_pull_bcn_stats(src, dst);\n\t\tlist_add_tail(&dst->list, &stats->bcn);\n\t}\n\nexit:\n\trcu_read_unlock();\n\treturn ret;\n}\n\nstatic int ath11k_wmi_tlv_fw_stats_parse(struct ath11k_base *ab,\n\t\t\t\t\t u16 tag, u16 len,\n\t\t\t\t\t const void *ptr, void *data)\n{\n\tstruct wmi_tlv_fw_stats_parse *parse = data;\n\tint ret = 0;\n\n\tswitch (tag) {\n\tcase WMI_TAG_STATS_EVENT:\n\t\tparse->ev = (struct wmi_stats_event *)ptr;\n\t\tparse->stats->pdev_id = parse->ev->pdev_id;\n\t\tbreak;\n\tcase WMI_TAG_ARRAY_BYTE:\n\t\tret = ath11k_wmi_tlv_fw_stats_data_parse(ab, parse, ptr, len);\n\t\tbreak;\n\tcase WMI_TAG_PER_CHAIN_RSSI_STATS:\n\t\tparse->rssi = (struct wmi_per_chain_rssi_stats *)ptr;\n\n\t\tif (parse->ev->stats_id & WMI_REQUEST_RSSI_PER_CHAIN_STAT)\n\t\t\tparse->rssi_num = parse->rssi->num_per_chain_rssi_stats;\n\n\t\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t\t   \"stats id 0x%x num chain %d\\n\",\n\t\t\t   parse->ev->stats_id,\n\t\t\t   parse->rssi_num);\n\t\tbreak;\n\tcase WMI_TAG_ARRAY_STRUCT:\n\t\tif (parse->rssi_num && !parse->chain_rssi_done) {\n\t\t\tret = ath11k_wmi_tlv_iter(ab, ptr, len,\n\t\t\t\t\t\t  ath11k_wmi_tlv_rssi_chain_parse,\n\t\t\t\t\t\t  parse);\n\t\t\tif (ret) {\n\t\t\t\tath11k_warn(ab, \"failed to parse rssi chain %d\\n\",\n\t\t\t\t\t    ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tparse->chain_rssi_done = true;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nint ath11k_wmi_pull_fw_stats(struct ath11k_base *ab, struct sk_buff *skb,\n\t\t\t     struct ath11k_fw_stats *stats)\n{\n\tstruct wmi_tlv_fw_stats_parse parse = { };\n\n\tstats->stats_id = 0;\n\tparse.stats = stats;\n\n\treturn ath11k_wmi_tlv_iter(ab, skb->data, skb->len,\n\t\t\t\t   ath11k_wmi_tlv_fw_stats_parse,\n\t\t\t\t   &parse);\n}\n\nstatic void\nath11k_wmi_fw_pdev_base_stats_fill(const struct ath11k_fw_stats_pdev *pdev,\n\t\t\t\t   char *buf, u32 *length)\n{\n\tu32 len = *length;\n\tu32 buf_len = ATH11K_FW_STATS_BUF_SIZE;\n\n\tlen += scnprintf(buf + len, buf_len - len, \"\\n\");\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s\\n\",\n\t\t\t\"ath11k PDEV stats\");\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s\\n\\n\",\n\t\t\t\"=================\");\n\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t\"Channel noise floor\", pdev->ch_noise_floor);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t\"Channel TX power\", pdev->chan_tx_power);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t\"TX frame count\", pdev->tx_frame_count);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t\"RX frame count\", pdev->rx_frame_count);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t\"RX clear count\", pdev->rx_clear_count);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t\"Cycle count\", pdev->cycle_count);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t\"PHY error count\", pdev->phy_err_count);\n\n\t*length = len;\n}\n\nstatic void\nath11k_wmi_fw_pdev_tx_stats_fill(const struct ath11k_fw_stats_pdev *pdev,\n\t\t\t\t char *buf, u32 *length)\n{\n\tu32 len = *length;\n\tu32 buf_len = ATH11K_FW_STATS_BUF_SIZE;\n\n\tlen += scnprintf(buf + len, buf_len - len, \"\\n%30s\\n\",\n\t\t\t \"ath11k PDEV TX stats\");\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s\\n\\n\",\n\t\t\t \"====================\");\n\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"HTT cookies queued\", pdev->comp_queued);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"HTT cookies disp.\", pdev->comp_delivered);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"MSDU queued\", pdev->msdu_enqued);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"MPDU queued\", pdev->mpdu_enqued);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"MSDUs dropped\", pdev->wmm_drop);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"Local enqued\", pdev->local_enqued);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"Local freed\", pdev->local_freed);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"HW queued\", pdev->hw_queued);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"PPDUs reaped\", pdev->hw_reaped);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"Num underruns\", pdev->underrun);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"Num HW Paused\", pdev->hw_paused);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"PPDUs cleaned\", pdev->tx_abort);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"MPDUs requeued\", pdev->mpdus_requeued);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t \"PPDU OK\", pdev->tx_ko);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t \"Excessive retries\", pdev->tx_xretry);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t \"HW rate\", pdev->data_rc);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t \"Sched self triggers\", pdev->self_triggers);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t \"Dropped due to SW retries\",\n\t\t\t pdev->sw_retry_failure);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t \"Illegal rate phy errors\",\n\t\t\t pdev->illgl_rate_phy_err);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t \"PDEV continuous xretry\", pdev->pdev_cont_xretry);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t \"TX timeout\", pdev->pdev_tx_timeout);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t \"PDEV resets\", pdev->pdev_resets);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t \"Stateless TIDs alloc failures\",\n\t\t\t pdev->stateless_tid_alloc_failure);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t \"PHY underrun\", pdev->phy_underrun);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t \"MPDU is more than txop limit\", pdev->txop_ovf);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t \"Num sequences posted\", pdev->seq_posted);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t \"Num seq failed queueing \", pdev->seq_failed_queueing);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t \"Num sequences completed \", pdev->seq_completed);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t \"Num sequences restarted \", pdev->seq_restarted);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t \"Num of MU sequences posted \", pdev->mu_seq_posted);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t \"Num of MPDUS SW flushed \", pdev->mpdus_sw_flush);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t \"Num of MPDUS HW filtered \", pdev->mpdus_hw_filter);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t \"Num of MPDUS truncated \", pdev->mpdus_truncated);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t \"Num of MPDUS ACK failed \", pdev->mpdus_ack_failed);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10u\\n\",\n\t\t\t \"Num of MPDUS expired \", pdev->mpdus_expired);\n\t*length = len;\n}\n\nstatic void\nath11k_wmi_fw_pdev_rx_stats_fill(const struct ath11k_fw_stats_pdev *pdev,\n\t\t\t\t char *buf, u32 *length)\n{\n\tu32 len = *length;\n\tu32 buf_len = ATH11K_FW_STATS_BUF_SIZE;\n\n\tlen += scnprintf(buf + len, buf_len - len, \"\\n%30s\\n\",\n\t\t\t \"ath11k PDEV RX stats\");\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s\\n\\n\",\n\t\t\t \"====================\");\n\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"Mid PPDU route change\",\n\t\t\t pdev->mid_ppdu_route_change);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"Tot. number of statuses\", pdev->status_rcvd);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"Extra frags on rings 0\", pdev->r0_frags);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"Extra frags on rings 1\", pdev->r1_frags);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"Extra frags on rings 2\", pdev->r2_frags);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"Extra frags on rings 3\", pdev->r3_frags);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"MSDUs delivered to HTT\", pdev->htt_msdus);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"MPDUs delivered to HTT\", pdev->htt_mpdus);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"MSDUs delivered to stack\", pdev->loc_msdus);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"MPDUs delivered to stack\", pdev->loc_mpdus);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"Oversized AMSUs\", pdev->oversize_amsdu);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"PHY errors\", pdev->phy_errs);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"PHY errors drops\", pdev->phy_err_drop);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"MPDU errors (FCS, MIC, ENC)\", pdev->mpdu_errs);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %10d\\n\",\n\t\t\t \"Overflow errors\", pdev->rx_ovfl_errs);\n\t*length = len;\n}\n\nstatic void\nath11k_wmi_fw_vdev_stats_fill(struct ath11k *ar,\n\t\t\t      const struct ath11k_fw_stats_vdev *vdev,\n\t\t\t      char *buf, u32 *length)\n{\n\tu32 len = *length;\n\tu32 buf_len = ATH11K_FW_STATS_BUF_SIZE;\n\tstruct ath11k_vif *arvif = ath11k_mac_get_arvif(ar, vdev->vdev_id);\n\tu8 *vif_macaddr;\n\tint i;\n\n\t \n\tif (!arvif)\n\t\treturn;\n\n\tvif_macaddr = arvif->vif->addr;\n\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t \"VDEV ID\", vdev->vdev_id);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %pM\\n\",\n\t\t\t \"VDEV MAC address\", vif_macaddr);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t \"beacon snr\", vdev->beacon_snr);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t \"data snr\", vdev->data_snr);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t \"num rx frames\", vdev->num_rx_frames);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t \"num rts fail\", vdev->num_rts_fail);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t \"num rts success\", vdev->num_rts_success);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t \"num rx err\", vdev->num_rx_err);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t \"num rx discard\", vdev->num_rx_discard);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t \"num tx not acked\", vdev->num_tx_not_acked);\n\n\tfor (i = 0 ; i < ARRAY_SIZE(vdev->num_tx_frames); i++)\n\t\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t\t\"%25s [%02d] %u\\n\",\n\t\t\t\t\"num tx frames\", i,\n\t\t\t\tvdev->num_tx_frames[i]);\n\n\tfor (i = 0 ; i < ARRAY_SIZE(vdev->num_tx_frames_retries); i++)\n\t\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t\t\"%25s [%02d] %u\\n\",\n\t\t\t\t\"num tx frames retries\", i,\n\t\t\t\tvdev->num_tx_frames_retries[i]);\n\n\tfor (i = 0 ; i < ARRAY_SIZE(vdev->num_tx_frames_failures); i++)\n\t\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t\t\"%25s [%02d] %u\\n\",\n\t\t\t\t\"num tx frames failures\", i,\n\t\t\t\tvdev->num_tx_frames_failures[i]);\n\n\tfor (i = 0 ; i < ARRAY_SIZE(vdev->tx_rate_history); i++)\n\t\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t\t\"%25s [%02d] 0x%08x\\n\",\n\t\t\t\t\"tx rate history\", i,\n\t\t\t\tvdev->tx_rate_history[i]);\n\n\tfor (i = 0 ; i < ARRAY_SIZE(vdev->beacon_rssi_history); i++)\n\t\tlen += scnprintf(buf + len, buf_len - len,\n\t\t\t\t\"%25s [%02d] %u\\n\",\n\t\t\t\t\"beacon rssi history\", i,\n\t\t\t\tvdev->beacon_rssi_history[i]);\n\n\tlen += scnprintf(buf + len, buf_len - len, \"\\n\");\n\t*length = len;\n}\n\nstatic void\nath11k_wmi_fw_bcn_stats_fill(struct ath11k *ar,\n\t\t\t     const struct ath11k_fw_stats_bcn *bcn,\n\t\t\t     char *buf, u32 *length)\n{\n\tu32 len = *length;\n\tu32 buf_len = ATH11K_FW_STATS_BUF_SIZE;\n\tstruct ath11k_vif *arvif = ath11k_mac_get_arvif(ar, bcn->vdev_id);\n\tu8 *vdev_macaddr;\n\n\tif (!arvif) {\n\t\tath11k_warn(ar->ab, \"invalid vdev id %d in bcn stats\",\n\t\t\t    bcn->vdev_id);\n\t\treturn;\n\t}\n\n\tvdev_macaddr = arvif->vif->addr;\n\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t \"VDEV ID\", bcn->vdev_id);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %pM\\n\",\n\t\t\t \"VDEV MAC address\", vdev_macaddr);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s\\n\\n\",\n\t\t\t \"================\");\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t \"Num of beacon tx success\", bcn->tx_bcn_succ_cnt);\n\tlen += scnprintf(buf + len, buf_len - len, \"%30s %u\\n\",\n\t\t\t \"Num of beacon tx failures\", bcn->tx_bcn_outage_cnt);\n\n\tlen += scnprintf(buf + len, buf_len - len, \"\\n\");\n\t*length = len;\n}\n\nvoid ath11k_wmi_fw_stats_fill(struct ath11k *ar,\n\t\t\t      struct ath11k_fw_stats *fw_stats,\n\t\t\t      u32 stats_id, char *buf)\n{\n\tu32 len = 0;\n\tu32 buf_len = ATH11K_FW_STATS_BUF_SIZE;\n\tconst struct ath11k_fw_stats_pdev *pdev;\n\tconst struct ath11k_fw_stats_vdev *vdev;\n\tconst struct ath11k_fw_stats_bcn *bcn;\n\tsize_t num_bcn;\n\n\tspin_lock_bh(&ar->data_lock);\n\n\tif (stats_id == WMI_REQUEST_PDEV_STAT) {\n\t\tpdev = list_first_entry_or_null(&fw_stats->pdevs,\n\t\t\t\t\t\tstruct ath11k_fw_stats_pdev, list);\n\t\tif (!pdev) {\n\t\t\tath11k_warn(ar->ab, \"failed to get pdev stats\\n\");\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tath11k_wmi_fw_pdev_base_stats_fill(pdev, buf, &len);\n\t\tath11k_wmi_fw_pdev_tx_stats_fill(pdev, buf, &len);\n\t\tath11k_wmi_fw_pdev_rx_stats_fill(pdev, buf, &len);\n\t}\n\n\tif (stats_id == WMI_REQUEST_VDEV_STAT) {\n\t\tlen += scnprintf(buf + len, buf_len - len, \"\\n\");\n\t\tlen += scnprintf(buf + len, buf_len - len, \"%30s\\n\",\n\t\t\t\t \"ath11k VDEV stats\");\n\t\tlen += scnprintf(buf + len, buf_len - len, \"%30s\\n\\n\",\n\t\t\t\t \"=================\");\n\n\t\tlist_for_each_entry(vdev, &fw_stats->vdevs, list)\n\t\t\tath11k_wmi_fw_vdev_stats_fill(ar, vdev, buf, &len);\n\t}\n\n\tif (stats_id == WMI_REQUEST_BCN_STAT) {\n\t\tnum_bcn = list_count_nodes(&fw_stats->bcn);\n\n\t\tlen += scnprintf(buf + len, buf_len - len, \"\\n\");\n\t\tlen += scnprintf(buf + len, buf_len - len, \"%30s (%zu)\\n\",\n\t\t\t\t \"ath11k Beacon stats\", num_bcn);\n\t\tlen += scnprintf(buf + len, buf_len - len, \"%30s\\n\\n\",\n\t\t\t\t \"===================\");\n\n\t\tlist_for_each_entry(bcn, &fw_stats->bcn, list)\n\t\t\tath11k_wmi_fw_bcn_stats_fill(ar, bcn, buf, &len);\n\t}\n\nunlock:\n\tspin_unlock_bh(&ar->data_lock);\n\n\tif (len >= buf_len)\n\t\tbuf[len - 1] = 0;\n\telse\n\t\tbuf[len] = 0;\n}\n\nstatic void ath11k_wmi_op_ep_tx_credits(struct ath11k_base *ab)\n{\n\t \n\twake_up(&ab->wmi_ab.tx_credits_wq);\n}\n\nstatic int ath11k_reg_11d_new_cc_event(struct ath11k_base *ab, struct sk_buff *skb)\n{\n\tconst struct wmi_11d_new_cc_ev *ev;\n\tstruct ath11k *ar;\n\tstruct ath11k_pdev *pdev;\n\tconst void **tb;\n\tint ret, i;\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tev = tb[WMI_TAG_11D_NEW_COUNTRY_EVENT];\n\tif (!ev) {\n\t\tkfree(tb);\n\t\tath11k_warn(ab, \"failed to fetch 11d new cc ev\");\n\t\treturn -EPROTO;\n\t}\n\n\tspin_lock_bh(&ab->base_lock);\n\tmemcpy(&ab->new_alpha2, &ev->new_alpha2, 2);\n\tspin_unlock_bh(&ab->base_lock);\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI, \"event 11d new cc %c%c\\n\",\n\t\t   ab->new_alpha2[0],\n\t\t   ab->new_alpha2[1]);\n\n\tkfree(tb);\n\n\tfor (i = 0; i < ab->num_radios; i++) {\n\t\tpdev = &ab->pdevs[i];\n\t\tar = pdev->ar;\n\t\tar->state_11d = ATH11K_11D_IDLE;\n\t\tcomplete(&ar->completed_11d_scan);\n\t}\n\n\tqueue_work(ab->workqueue, &ab->update_11d_work);\n\n\treturn 0;\n}\n\nstatic void ath11k_wmi_htc_tx_complete(struct ath11k_base *ab,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tstruct ath11k_pdev_wmi *wmi = NULL;\n\tu32 i;\n\tu8 wmi_ep_count;\n\tu8 eid;\n\n\teid = ATH11K_SKB_CB(skb)->eid;\n\tdev_kfree_skb(skb);\n\n\tif (eid >= ATH11K_HTC_EP_COUNT)\n\t\treturn;\n\n\twmi_ep_count = ab->htc.wmi_ep_count;\n\tif (wmi_ep_count > ab->hw_params.max_radios)\n\t\treturn;\n\n\tfor (i = 0; i < ab->htc.wmi_ep_count; i++) {\n\t\tif (ab->wmi_ab.wmi[i].eid == eid) {\n\t\t\twmi = &ab->wmi_ab.wmi[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (wmi)\n\t\twake_up(&wmi->tx_ce_desc_wq);\n}\n\nstatic bool ath11k_reg_is_world_alpha(char *alpha)\n{\n\tif (alpha[0] == '0' && alpha[1] == '0')\n\t\treturn true;\n\n\tif (alpha[0] == 'n' && alpha[1] == 'a')\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int ath11k_reg_chan_list_event(struct ath11k_base *ab,\n\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t      enum wmi_reg_chan_list_cmd_type id)\n{\n\tstruct cur_regulatory_info *reg_info = NULL;\n\tstruct ieee80211_regdomain *regd = NULL;\n\tbool intersect = false;\n\tint ret = 0, pdev_idx, i, j;\n\tstruct ath11k *ar;\n\n\treg_info = kzalloc(sizeof(*reg_info), GFP_ATOMIC);\n\tif (!reg_info) {\n\t\tret = -ENOMEM;\n\t\tgoto fallback;\n\t}\n\n\tif (id == WMI_REG_CHAN_LIST_CC_ID)\n\t\tret = ath11k_pull_reg_chan_list_update_ev(ab, skb, reg_info);\n\telse\n\t\tret = ath11k_pull_reg_chan_list_ext_update_ev(ab, skb, reg_info);\n\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to extract regulatory info from received event\\n\");\n\t\tgoto fallback;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI, \"event reg chan list id %d\", id);\n\n\tif (reg_info->status_code != REG_SET_CC_STATUS_PASS) {\n\t\t \n\t\tath11k_warn(ab, \"Failed to set the requested Country regulatory setting\\n\");\n\t\tgoto mem_free;\n\t}\n\n\tpdev_idx = reg_info->phy_id;\n\n\t \n\tspin_lock(&ab->base_lock);\n\tif (test_bit(ATH11K_FLAG_RECOVERY, &ab->dev_flags) &&\n\t    ab->default_regd[pdev_idx]) {\n\t\tspin_unlock(&ab->base_lock);\n\t\tgoto mem_free;\n\t}\n\tspin_unlock(&ab->base_lock);\n\n\tif (pdev_idx >= ab->num_radios) {\n\t\t \n\t\tif (ab->hw_params.single_pdev_only &&\n\t\t    pdev_idx < ab->hw_params.num_rxmda_per_pdev)\n\t\t\tgoto mem_free;\n\t\telse\n\t\t\tgoto fallback;\n\t}\n\n\t \n\tif (ab->default_regd[pdev_idx] && !ab->new_regd[pdev_idx] &&\n\t    !memcmp((char *)ab->default_regd[pdev_idx]->alpha2,\n\t\t    (char *)reg_info->alpha2, 2))\n\t\tgoto mem_free;\n\n\t \n\tif (ab->default_regd[pdev_idx] &&\n\t    !ath11k_reg_is_world_alpha((char *)\n\t\tab->default_regd[pdev_idx]->alpha2) &&\n\t    !ath11k_reg_is_world_alpha((char *)reg_info->alpha2))\n\t\tintersect = true;\n\n\tregd = ath11k_reg_build_regd(ab, reg_info, intersect);\n\tif (!regd) {\n\t\tath11k_warn(ab, \"failed to build regd from reg_info\\n\");\n\t\tgoto fallback;\n\t}\n\n\tspin_lock(&ab->base_lock);\n\tif (ab->default_regd[pdev_idx]) {\n\t\t \n\t\tar = ab->pdevs[pdev_idx].ar;\n\t\tkfree(ab->new_regd[pdev_idx]);\n\t\tab->new_regd[pdev_idx] = regd;\n\t\tqueue_work(ab->workqueue, &ar->regd_update_work);\n\t} else {\n\t\t \n\t\tab->default_regd[pdev_idx] = regd;\n\t}\n\tab->dfs_region = reg_info->dfs_region;\n\tspin_unlock(&ab->base_lock);\n\n\tgoto mem_free;\n\nfallback:\n\t \n\t \n\tWARN_ON(1);\nmem_free:\n\tif (reg_info) {\n\t\tkfree(reg_info->reg_rules_2ghz_ptr);\n\t\tkfree(reg_info->reg_rules_5ghz_ptr);\n\t\tif (reg_info->is_ext_reg_event) {\n\t\t\tfor (i = 0; i < WMI_REG_CURRENT_MAX_AP_TYPE; i++)\n\t\t\t\tkfree(reg_info->reg_rules_6ghz_ap_ptr[i]);\n\n\t\t\tfor (j = 0; j < WMI_REG_CURRENT_MAX_AP_TYPE; j++)\n\t\t\t\tfor (i = 0; i < WMI_REG_MAX_CLIENT_TYPE; i++)\n\t\t\t\t\tkfree(reg_info->reg_rules_6ghz_client_ptr[j][i]);\n\t\t}\n\t\tkfree(reg_info);\n\t}\n\treturn ret;\n}\n\nstatic int ath11k_wmi_tlv_rdy_parse(struct ath11k_base *ab, u16 tag, u16 len,\n\t\t\t\t    const void *ptr, void *data)\n{\n\tstruct wmi_tlv_rdy_parse *rdy_parse = data;\n\tstruct wmi_ready_event fixed_param;\n\tstruct wmi_mac_addr *addr_list;\n\tstruct ath11k_pdev *pdev;\n\tu32 num_mac_addr;\n\tint i;\n\n\tswitch (tag) {\n\tcase WMI_TAG_READY_EVENT:\n\t\tmemset(&fixed_param, 0, sizeof(fixed_param));\n\t\tmemcpy(&fixed_param, (struct wmi_ready_event *)ptr,\n\t\t       min_t(u16, sizeof(fixed_param), len));\n\t\tab->wlan_init_status = fixed_param.ready_event_min.status;\n\t\trdy_parse->num_extra_mac_addr =\n\t\t\tfixed_param.ready_event_min.num_extra_mac_addr;\n\n\t\tether_addr_copy(ab->mac_addr,\n\t\t\t\tfixed_param.ready_event_min.mac_addr.addr);\n\t\tab->pktlog_defs_checksum = fixed_param.pktlog_defs_checksum;\n\t\tab->wmi_ready = true;\n\t\tbreak;\n\tcase WMI_TAG_ARRAY_FIXED_STRUCT:\n\t\taddr_list = (struct wmi_mac_addr *)ptr;\n\t\tnum_mac_addr = rdy_parse->num_extra_mac_addr;\n\n\t\tif (!(ab->num_radios > 1 && num_mac_addr >= ab->num_radios))\n\t\t\tbreak;\n\n\t\tfor (i = 0; i < ab->num_radios; i++) {\n\t\t\tpdev = &ab->pdevs[i];\n\t\t\tether_addr_copy(pdev->mac_addr, addr_list[i].addr);\n\t\t}\n\t\tab->pdevs_macaddr_valid = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int ath11k_ready_event(struct ath11k_base *ab, struct sk_buff *skb)\n{\n\tstruct wmi_tlv_rdy_parse rdy_parse = { };\n\tint ret;\n\n\tret = ath11k_wmi_tlv_iter(ab, skb->data, skb->len,\n\t\t\t\t  ath11k_wmi_tlv_rdy_parse, &rdy_parse);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to parse tlv %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI, \"event ready\");\n\n\tcomplete(&ab->wmi_ab.unified_ready);\n\treturn 0;\n}\n\nstatic void ath11k_peer_delete_resp_event(struct ath11k_base *ab, struct sk_buff *skb)\n{\n\tstruct wmi_peer_delete_resp_event peer_del_resp;\n\tstruct ath11k *ar;\n\n\tif (ath11k_pull_peer_del_resp_ev(ab, skb, &peer_del_resp) != 0) {\n\t\tath11k_warn(ab, \"failed to extract peer delete resp\");\n\t\treturn;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI, \"event peer delete resp\");\n\n\trcu_read_lock();\n\tar = ath11k_mac_get_ar_by_vdev_id(ab, peer_del_resp.vdev_id);\n\tif (!ar) {\n\t\tath11k_warn(ab, \"invalid vdev id in peer delete resp ev %d\",\n\t\t\t    peer_del_resp.vdev_id);\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tcomplete(&ar->peer_delete_done);\n\trcu_read_unlock();\n\tath11k_dbg(ab, ATH11K_DBG_WMI, \"peer delete resp for vdev id %d addr %pM\\n\",\n\t\t   peer_del_resp.vdev_id, peer_del_resp.peer_macaddr.addr);\n}\n\nstatic void ath11k_vdev_delete_resp_event(struct ath11k_base *ab,\n\t\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct ath11k *ar;\n\tu32 vdev_id = 0;\n\n\tif (ath11k_pull_vdev_del_resp_ev(ab, skb, &vdev_id) != 0) {\n\t\tath11k_warn(ab, \"failed to extract vdev delete resp\");\n\t\treturn;\n\t}\n\n\trcu_read_lock();\n\tar = ath11k_mac_get_ar_by_vdev_id(ab, vdev_id);\n\tif (!ar) {\n\t\tath11k_warn(ab, \"invalid vdev id in vdev delete resp ev %d\",\n\t\t\t    vdev_id);\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tcomplete(&ar->vdev_delete_done);\n\n\trcu_read_unlock();\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI, \"event vdev delete resp for vdev id %d\\n\",\n\t\t   vdev_id);\n}\n\nstatic inline const char *ath11k_wmi_vdev_resp_print(u32 vdev_resp_status)\n{\n\tswitch (vdev_resp_status) {\n\tcase WMI_VDEV_START_RESPONSE_INVALID_VDEVID:\n\t\treturn \"invalid vdev id\";\n\tcase WMI_VDEV_START_RESPONSE_NOT_SUPPORTED:\n\t\treturn \"not supported\";\n\tcase WMI_VDEV_START_RESPONSE_DFS_VIOLATION:\n\t\treturn \"dfs violation\";\n\tcase WMI_VDEV_START_RESPONSE_INVALID_REGDOMAIN:\n\t\treturn \"invalid regdomain\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\nstatic void ath11k_vdev_start_resp_event(struct ath11k_base *ab, struct sk_buff *skb)\n{\n\tstruct wmi_vdev_start_resp_event vdev_start_resp;\n\tstruct ath11k *ar;\n\tu32 status;\n\n\tif (ath11k_pull_vdev_start_resp_tlv(ab, skb, &vdev_start_resp) != 0) {\n\t\tath11k_warn(ab, \"failed to extract vdev start resp\");\n\t\treturn;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI, \"event start resp event\");\n\n\trcu_read_lock();\n\tar = ath11k_mac_get_ar_by_vdev_id(ab, vdev_start_resp.vdev_id);\n\tif (!ar) {\n\t\tath11k_warn(ab, \"invalid vdev id in vdev start resp ev %d\",\n\t\t\t    vdev_start_resp.vdev_id);\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tar->last_wmi_vdev_start_status = 0;\n\n\tstatus = vdev_start_resp.status;\n\n\tif (WARN_ON_ONCE(status)) {\n\t\tath11k_warn(ab, \"vdev start resp error status %d (%s)\\n\",\n\t\t\t    status, ath11k_wmi_vdev_resp_print(status));\n\t\tar->last_wmi_vdev_start_status = status;\n\t}\n\n\tcomplete(&ar->vdev_setup_done);\n\n\trcu_read_unlock();\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI, \"vdev start resp for vdev id %d\",\n\t\t   vdev_start_resp.vdev_id);\n}\n\nstatic void ath11k_bcn_tx_status_event(struct ath11k_base *ab, struct sk_buff *skb)\n{\n\tstruct ath11k_vif *arvif;\n\tu32 vdev_id, tx_status;\n\n\tif (ath11k_pull_bcn_tx_status_ev(ab, skb->data, skb->len,\n\t\t\t\t\t &vdev_id, &tx_status) != 0) {\n\t\tath11k_warn(ab, \"failed to extract bcn tx status\");\n\t\treturn;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI, \"event offload bcn tx status\");\n\n\trcu_read_lock();\n\tarvif = ath11k_mac_get_arvif_by_vdev_id(ab, vdev_id);\n\tif (!arvif) {\n\t\tath11k_warn(ab, \"invalid vdev id %d in bcn_tx_status\",\n\t\t\t    vdev_id);\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\tath11k_mac_bcn_tx_event(arvif);\n\trcu_read_unlock();\n}\n\nstatic void ath11k_wmi_event_peer_sta_ps_state_chg(struct ath11k_base *ab,\n\t\t\t\t\t\t   struct sk_buff *skb)\n{\n\tconst struct wmi_peer_sta_ps_state_chg_event *ev;\n\tstruct ieee80211_sta *sta;\n\tstruct ath11k_peer *peer;\n\tstruct ath11k *ar;\n\tstruct ath11k_sta *arsta;\n\tconst void **tb;\n\tenum ath11k_wmi_peer_ps_state peer_previous_ps_state;\n\tint ret;\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tev = tb[WMI_TAG_PEER_STA_PS_STATECHANGE_EVENT];\n\tif (!ev) {\n\t\tath11k_warn(ab, \"failed to fetch sta ps change ev\");\n\t\tkfree(tb);\n\t\treturn;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t   \"event peer sta ps change ev addr %pM state %u sup_bitmap %x ps_valid %u ts %u\\n\",\n\t\t   ev->peer_macaddr.addr, ev->peer_ps_state,\n\t\t   ev->ps_supported_bitmap, ev->peer_ps_valid,\n\t\t   ev->peer_ps_timestamp);\n\n\trcu_read_lock();\n\n\tspin_lock_bh(&ab->base_lock);\n\n\tpeer = ath11k_peer_find_by_addr(ab, ev->peer_macaddr.addr);\n\n\tif (!peer) {\n\t\tspin_unlock_bh(&ab->base_lock);\n\t\tath11k_warn(ab, \"peer not found %pM\\n\", ev->peer_macaddr.addr);\n\t\tgoto exit;\n\t}\n\n\tar = ath11k_mac_get_ar_by_vdev_id(ab, peer->vdev_id);\n\n\tif (!ar) {\n\t\tspin_unlock_bh(&ab->base_lock);\n\t\tath11k_warn(ab, \"invalid vdev id in peer sta ps state change ev %d\",\n\t\t\t    peer->vdev_id);\n\n\t\tgoto exit;\n\t}\n\n\tsta = peer->sta;\n\n\tspin_unlock_bh(&ab->base_lock);\n\n\tif (!sta) {\n\t\tath11k_warn(ab, \"failed to find station entry %pM\\n\",\n\t\t\t    ev->peer_macaddr.addr);\n\t\tgoto exit;\n\t}\n\n\tarsta = (struct ath11k_sta *)sta->drv_priv;\n\n\tspin_lock_bh(&ar->data_lock);\n\n\tpeer_previous_ps_state = arsta->peer_ps_state;\n\tarsta->peer_ps_state = ev->peer_ps_state;\n\tarsta->peer_current_ps_valid = !!ev->peer_ps_valid;\n\n\tif (test_bit(WMI_TLV_SERVICE_PEER_POWER_SAVE_DURATION_SUPPORT,\n\t\t     ar->ab->wmi_ab.svc_map)) {\n\t\tif (!(ev->ps_supported_bitmap & WMI_PEER_PS_VALID) ||\n\t\t    !(ev->ps_supported_bitmap & WMI_PEER_PS_STATE_TIMESTAMP) ||\n\t\t    !ev->peer_ps_valid)\n\t\t\tgoto out;\n\n\t\tif (arsta->peer_ps_state == WMI_PEER_PS_STATE_ON) {\n\t\t\tarsta->ps_start_time = ev->peer_ps_timestamp;\n\t\t\tarsta->ps_start_jiffies = jiffies;\n\t\t} else if (arsta->peer_ps_state == WMI_PEER_PS_STATE_OFF &&\n\t\t\t   peer_previous_ps_state == WMI_PEER_PS_STATE_ON) {\n\t\t\tarsta->ps_total_duration = arsta->ps_total_duration +\n\t\t\t\t\t(ev->peer_ps_timestamp - arsta->ps_start_time);\n\t\t}\n\n\t\tif (ar->ps_timekeeper_enable)\n\t\t\ttrace_ath11k_ps_timekeeper(ar, ev->peer_macaddr.addr,\n\t\t\t\t\t\t   ev->peer_ps_timestamp,\n\t\t\t\t\t\t   arsta->peer_ps_state);\n\t}\n\nout:\n\tspin_unlock_bh(&ar->data_lock);\nexit:\n\trcu_read_unlock();\n\tkfree(tb);\n}\n\nstatic void ath11k_vdev_stopped_event(struct ath11k_base *ab, struct sk_buff *skb)\n{\n\tstruct ath11k *ar;\n\tu32 vdev_id = 0;\n\n\tif (ath11k_pull_vdev_stopped_param_tlv(ab, skb, &vdev_id) != 0) {\n\t\tath11k_warn(ab, \"failed to extract vdev stopped event\");\n\t\treturn;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI, \"event vdev stopped\");\n\n\trcu_read_lock();\n\tar = ath11k_mac_get_ar_by_vdev_id(ab, vdev_id);\n\tif (!ar) {\n\t\tath11k_warn(ab, \"invalid vdev id in vdev stopped ev %d\",\n\t\t\t    vdev_id);\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tcomplete(&ar->vdev_setup_done);\n\n\trcu_read_unlock();\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI, \"vdev stopped for vdev id %d\", vdev_id);\n}\n\nstatic void ath11k_mgmt_rx_event(struct ath11k_base *ab, struct sk_buff *skb)\n{\n\tstruct mgmt_rx_event_params rx_ev = {0};\n\tstruct ath11k *ar;\n\tstruct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);\n\tstruct ieee80211_hdr *hdr;\n\tu16 fc;\n\tstruct ieee80211_supported_band *sband;\n\n\tif (ath11k_pull_mgmt_rx_params_tlv(ab, skb, &rx_ev) != 0) {\n\t\tath11k_warn(ab, \"failed to extract mgmt rx event\");\n\t\tdev_kfree_skb(skb);\n\t\treturn;\n\t}\n\n\tmemset(status, 0, sizeof(*status));\n\n\tath11k_dbg(ab, ATH11K_DBG_MGMT, \"event mgmt rx status %08x\\n\",\n\t\t   rx_ev.status);\n\n\trcu_read_lock();\n\tar = ath11k_mac_get_ar_by_pdev_id(ab, rx_ev.pdev_id);\n\n\tif (!ar) {\n\t\tath11k_warn(ab, \"invalid pdev_id %d in mgmt_rx_event\\n\",\n\t\t\t    rx_ev.pdev_id);\n\t\tdev_kfree_skb(skb);\n\t\tgoto exit;\n\t}\n\n\tif ((test_bit(ATH11K_CAC_RUNNING, &ar->dev_flags)) ||\n\t    (rx_ev.status & (WMI_RX_STATUS_ERR_DECRYPT |\n\t    WMI_RX_STATUS_ERR_KEY_CACHE_MISS | WMI_RX_STATUS_ERR_CRC))) {\n\t\tdev_kfree_skb(skb);\n\t\tgoto exit;\n\t}\n\n\tif (rx_ev.status & WMI_RX_STATUS_ERR_MIC)\n\t\tstatus->flag |= RX_FLAG_MMIC_ERROR;\n\n\tif (rx_ev.chan_freq >= ATH11K_MIN_6G_FREQ &&\n\t    rx_ev.chan_freq <= ATH11K_MAX_6G_FREQ) {\n\t\tstatus->band = NL80211_BAND_6GHZ;\n\t\tstatus->freq = rx_ev.chan_freq;\n\t} else if (rx_ev.channel >= 1 && rx_ev.channel <= 14) {\n\t\tstatus->band = NL80211_BAND_2GHZ;\n\t} else if (rx_ev.channel >= 36 && rx_ev.channel <= ATH11K_MAX_5G_CHAN) {\n\t\tstatus->band = NL80211_BAND_5GHZ;\n\t} else {\n\t\t \n\t\tWARN_ON_ONCE(1);\n\t\tdev_kfree_skb(skb);\n\t\tgoto exit;\n\t}\n\n\tif (rx_ev.phy_mode == MODE_11B &&\n\t    (status->band == NL80211_BAND_5GHZ || status->band == NL80211_BAND_6GHZ))\n\t\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t\t   \"mgmt rx 11b (CCK) on 5/6GHz, band = %d\\n\", status->band);\n\n\tsband = &ar->mac.sbands[status->band];\n\n\tif (status->band != NL80211_BAND_6GHZ)\n\t\tstatus->freq = ieee80211_channel_to_frequency(rx_ev.channel,\n\t\t\t\t\t\t\t      status->band);\n\n\tstatus->signal = rx_ev.snr + ATH11K_DEFAULT_NOISE_FLOOR;\n\tstatus->rate_idx = ath11k_mac_bitrate_to_idx(sband, rx_ev.rate / 100);\n\n\thdr = (struct ieee80211_hdr *)skb->data;\n\tfc = le16_to_cpu(hdr->frame_control);\n\n\t \n\tstatus->flag |= RX_FLAG_SKIP_MONITOR;\n\n\t \n\tif (ieee80211_has_protected(hdr->frame_control) &&\n\t    !is_multicast_ether_addr(ieee80211_get_DA(hdr))) {\n\t\tstatus->flag |= RX_FLAG_DECRYPTED;\n\n\t\tif (!ieee80211_is_robust_mgmt_frame(skb)) {\n\t\t\tstatus->flag |= RX_FLAG_IV_STRIPPED |\n\t\t\t\t\tRX_FLAG_MMIC_STRIPPED;\n\t\t\thdr->frame_control = __cpu_to_le16(fc &\n\t\t\t\t\t     ~IEEE80211_FCTL_PROTECTED);\n\t\t}\n\t}\n\n\tif (ieee80211_is_beacon(hdr->frame_control))\n\t\tath11k_mac_handle_beacon(ar, skb);\n\n\tath11k_dbg(ab, ATH11K_DBG_MGMT,\n\t\t   \"event mgmt rx skb %p len %d ftype %02x stype %02x\\n\",\n\t\t   skb, skb->len,\n\t\t   fc & IEEE80211_FCTL_FTYPE, fc & IEEE80211_FCTL_STYPE);\n\n\tath11k_dbg(ab, ATH11K_DBG_MGMT,\n\t\t   \"event mgmt rx freq %d band %d snr %d, rate_idx %d\\n\",\n\t\t   status->freq, status->band, status->signal,\n\t\t   status->rate_idx);\n\n\tieee80211_rx_ni(ar->hw, skb);\n\nexit:\n\trcu_read_unlock();\n}\n\nstatic void ath11k_mgmt_tx_compl_event(struct ath11k_base *ab, struct sk_buff *skb)\n{\n\tstruct wmi_mgmt_tx_compl_event tx_compl_param = {0};\n\tstruct ath11k *ar;\n\n\tif (ath11k_pull_mgmt_tx_compl_param_tlv(ab, skb, &tx_compl_param) != 0) {\n\t\tath11k_warn(ab, \"failed to extract mgmt tx compl event\");\n\t\treturn;\n\t}\n\n\trcu_read_lock();\n\tar = ath11k_mac_get_ar_by_pdev_id(ab, tx_compl_param.pdev_id);\n\tif (!ar) {\n\t\tath11k_warn(ab, \"invalid pdev id %d in mgmt_tx_compl_event\\n\",\n\t\t\t    tx_compl_param.pdev_id);\n\t\tgoto exit;\n\t}\n\n\twmi_process_mgmt_tx_comp(ar, &tx_compl_param);\n\n\tath11k_dbg(ab, ATH11K_DBG_MGMT,\n\t\t   \"event mgmt tx compl ev pdev_id %d, desc_id %d, status %d ack_rssi %d\",\n\t\t   tx_compl_param.pdev_id, tx_compl_param.desc_id,\n\t\t   tx_compl_param.status, tx_compl_param.ack_rssi);\n\nexit:\n\trcu_read_unlock();\n}\n\nstatic struct ath11k *ath11k_get_ar_on_scan_state(struct ath11k_base *ab,\n\t\t\t\t\t\t  u32 vdev_id,\n\t\t\t\t\t\t  enum ath11k_scan_state state)\n{\n\tint i;\n\tstruct ath11k_pdev *pdev;\n\tstruct ath11k *ar;\n\n\tfor (i = 0; i < ab->num_radios; i++) {\n\t\tpdev = rcu_dereference(ab->pdevs_active[i]);\n\t\tif (pdev && pdev->ar) {\n\t\t\tar = pdev->ar;\n\n\t\t\tspin_lock_bh(&ar->data_lock);\n\t\t\tif (ar->scan.state == state &&\n\t\t\t    ar->scan.vdev_id == vdev_id) {\n\t\t\t\tspin_unlock_bh(&ar->data_lock);\n\t\t\t\treturn ar;\n\t\t\t}\n\t\t\tspin_unlock_bh(&ar->data_lock);\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic void ath11k_scan_event(struct ath11k_base *ab, struct sk_buff *skb)\n{\n\tstruct ath11k *ar;\n\tstruct wmi_scan_event scan_ev = {0};\n\n\tif (ath11k_pull_scan_ev(ab, skb, &scan_ev) != 0) {\n\t\tath11k_warn(ab, \"failed to extract scan event\");\n\t\treturn;\n\t}\n\n\trcu_read_lock();\n\n\t \n\tif (scan_ev.event_type == WMI_SCAN_EVENT_COMPLETED &&\n\t    scan_ev.reason == WMI_SCAN_REASON_CANCELLED) {\n\t\tar = ath11k_get_ar_on_scan_state(ab, scan_ev.vdev_id,\n\t\t\t\t\t\t ATH11K_SCAN_ABORTING);\n\t\tif (!ar)\n\t\t\tar = ath11k_get_ar_on_scan_state(ab, scan_ev.vdev_id,\n\t\t\t\t\t\t\t ATH11K_SCAN_RUNNING);\n\t} else {\n\t\tar = ath11k_mac_get_ar_by_vdev_id(ab, scan_ev.vdev_id);\n\t}\n\n\tif (!ar) {\n\t\tath11k_warn(ab, \"Received scan event for unknown vdev\");\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tspin_lock_bh(&ar->data_lock);\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t   \"event scan %s type %d reason %d freq %d req_id %d scan_id %d vdev_id %d state %s (%d)\\n\",\n\t\t   ath11k_wmi_event_scan_type_str(scan_ev.event_type, scan_ev.reason),\n\t\t   scan_ev.event_type, scan_ev.reason, scan_ev.channel_freq,\n\t\t   scan_ev.scan_req_id, scan_ev.scan_id, scan_ev.vdev_id,\n\t\t   ath11k_scan_state_str(ar->scan.state), ar->scan.state);\n\n\tswitch (scan_ev.event_type) {\n\tcase WMI_SCAN_EVENT_STARTED:\n\t\tath11k_wmi_event_scan_started(ar);\n\t\tbreak;\n\tcase WMI_SCAN_EVENT_COMPLETED:\n\t\tath11k_wmi_event_scan_completed(ar);\n\t\tbreak;\n\tcase WMI_SCAN_EVENT_BSS_CHANNEL:\n\t\tath11k_wmi_event_scan_bss_chan(ar);\n\t\tbreak;\n\tcase WMI_SCAN_EVENT_FOREIGN_CHAN:\n\t\tath11k_wmi_event_scan_foreign_chan(ar, scan_ev.channel_freq);\n\t\tbreak;\n\tcase WMI_SCAN_EVENT_START_FAILED:\n\t\tath11k_warn(ab, \"received scan start failure event\\n\");\n\t\tath11k_wmi_event_scan_start_failed(ar);\n\t\tbreak;\n\tcase WMI_SCAN_EVENT_DEQUEUED:\n\t\t__ath11k_mac_scan_finish(ar);\n\t\tbreak;\n\tcase WMI_SCAN_EVENT_PREEMPTED:\n\tcase WMI_SCAN_EVENT_RESTARTED:\n\tcase WMI_SCAN_EVENT_FOREIGN_CHAN_EXIT:\n\tdefault:\n\t\tbreak;\n\t}\n\n\tspin_unlock_bh(&ar->data_lock);\n\n\trcu_read_unlock();\n}\n\nstatic void ath11k_peer_sta_kickout_event(struct ath11k_base *ab, struct sk_buff *skb)\n{\n\tstruct wmi_peer_sta_kickout_arg arg = {};\n\tstruct ieee80211_sta *sta;\n\tstruct ath11k_peer *peer;\n\tstruct ath11k *ar;\n\tu32 vdev_id;\n\n\tif (ath11k_pull_peer_sta_kickout_ev(ab, skb, &arg) != 0) {\n\t\tath11k_warn(ab, \"failed to extract peer sta kickout event\");\n\t\treturn;\n\t}\n\n\trcu_read_lock();\n\n\tspin_lock_bh(&ab->base_lock);\n\n\tpeer = ath11k_peer_find_by_addr(ab, arg.mac_addr);\n\n\tif (!peer) {\n\t\tath11k_warn(ab, \"peer not found %pM\\n\",\n\t\t\t    arg.mac_addr);\n\t\tspin_unlock_bh(&ab->base_lock);\n\t\tgoto exit;\n\t}\n\n\tvdev_id = peer->vdev_id;\n\n\tspin_unlock_bh(&ab->base_lock);\n\n\tar = ath11k_mac_get_ar_by_vdev_id(ab, vdev_id);\n\tif (!ar) {\n\t\tath11k_warn(ab, \"invalid vdev id in peer sta kickout ev %d\",\n\t\t\t    peer->vdev_id);\n\t\tgoto exit;\n\t}\n\n\tsta = ieee80211_find_sta_by_ifaddr(ar->hw,\n\t\t\t\t\t   arg.mac_addr, NULL);\n\tif (!sta) {\n\t\tath11k_warn(ab, \"Spurious quick kickout for STA %pM\\n\",\n\t\t\t    arg.mac_addr);\n\t\tgoto exit;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI, \"event peer sta kickout %pM\",\n\t\t   arg.mac_addr);\n\n\tieee80211_report_low_ack(sta, 10);\n\nexit:\n\trcu_read_unlock();\n}\n\nstatic void ath11k_roam_event(struct ath11k_base *ab, struct sk_buff *skb)\n{\n\tstruct wmi_roam_event roam_ev = {};\n\tstruct ath11k *ar;\n\n\tif (ath11k_pull_roam_ev(ab, skb, &roam_ev) != 0) {\n\t\tath11k_warn(ab, \"failed to extract roam event\");\n\t\treturn;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t   \"event roam vdev %u reason 0x%08x rssi %d\\n\",\n\t\t   roam_ev.vdev_id, roam_ev.reason, roam_ev.rssi);\n\n\trcu_read_lock();\n\tar = ath11k_mac_get_ar_by_vdev_id(ab, roam_ev.vdev_id);\n\tif (!ar) {\n\t\tath11k_warn(ab, \"invalid vdev id in roam ev %d\",\n\t\t\t    roam_ev.vdev_id);\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tif (roam_ev.reason >= WMI_ROAM_REASON_MAX)\n\t\tath11k_warn(ab, \"ignoring unknown roam event reason %d on vdev %i\\n\",\n\t\t\t    roam_ev.reason, roam_ev.vdev_id);\n\n\tswitch (roam_ev.reason) {\n\tcase WMI_ROAM_REASON_BEACON_MISS:\n\t\tath11k_mac_handle_beacon_miss(ar, roam_ev.vdev_id);\n\t\tbreak;\n\tcase WMI_ROAM_REASON_BETTER_AP:\n\tcase WMI_ROAM_REASON_LOW_RSSI:\n\tcase WMI_ROAM_REASON_SUITABLE_AP_FOUND:\n\tcase WMI_ROAM_REASON_HO_FAILED:\n\t\tath11k_warn(ab, \"ignoring not implemented roam event reason %d on vdev %i\\n\",\n\t\t\t    roam_ev.reason, roam_ev.vdev_id);\n\t\tbreak;\n\t}\n\n\trcu_read_unlock();\n}\n\nstatic void ath11k_chan_info_event(struct ath11k_base *ab, struct sk_buff *skb)\n{\n\tstruct wmi_chan_info_event ch_info_ev = {0};\n\tstruct ath11k *ar;\n\tstruct survey_info *survey;\n\tint idx;\n\t \n\tu32 cc_freq_hz = ab->cc_freq_hz;\n\n\tif (ath11k_pull_chan_info_ev(ab, skb->data, skb->len, &ch_info_ev) != 0) {\n\t\tath11k_warn(ab, \"failed to extract chan info event\");\n\t\treturn;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t   \"event chan info vdev_id %d err_code %d freq %d cmd_flags %d noise_floor %d rx_clear_count %d cycle_count %d mac_clk_mhz %d\\n\",\n\t\t   ch_info_ev.vdev_id, ch_info_ev.err_code, ch_info_ev.freq,\n\t\t   ch_info_ev.cmd_flags, ch_info_ev.noise_floor,\n\t\t   ch_info_ev.rx_clear_count, ch_info_ev.cycle_count,\n\t\t   ch_info_ev.mac_clk_mhz);\n\n\tif (ch_info_ev.cmd_flags == WMI_CHAN_INFO_END_RESP) {\n\t\tath11k_dbg(ab, ATH11K_DBG_WMI, \"chan info report completed\\n\");\n\t\treturn;\n\t}\n\n\trcu_read_lock();\n\tar = ath11k_mac_get_ar_by_vdev_id(ab, ch_info_ev.vdev_id);\n\tif (!ar) {\n\t\tath11k_warn(ab, \"invalid vdev id in chan info ev %d\",\n\t\t\t    ch_info_ev.vdev_id);\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\tspin_lock_bh(&ar->data_lock);\n\n\tswitch (ar->scan.state) {\n\tcase ATH11K_SCAN_IDLE:\n\tcase ATH11K_SCAN_STARTING:\n\t\tath11k_warn(ab, \"received chan info event without a scan request, ignoring\\n\");\n\t\tgoto exit;\n\tcase ATH11K_SCAN_RUNNING:\n\tcase ATH11K_SCAN_ABORTING:\n\t\tbreak;\n\t}\n\n\tidx = freq_to_idx(ar, ch_info_ev.freq);\n\tif (idx >= ARRAY_SIZE(ar->survey)) {\n\t\tath11k_warn(ab, \"chan info: invalid frequency %d (idx %d out of bounds)\\n\",\n\t\t\t    ch_info_ev.freq, idx);\n\t\tgoto exit;\n\t}\n\n\t \n\tif (ch_info_ev.mac_clk_mhz)\n\t\tcc_freq_hz = (ch_info_ev.mac_clk_mhz * 1000);\n\n\tif (ch_info_ev.cmd_flags == WMI_CHAN_INFO_START_RESP) {\n\t\tsurvey = &ar->survey[idx];\n\t\tmemset(survey, 0, sizeof(*survey));\n\t\tsurvey->noise = ch_info_ev.noise_floor;\n\t\tsurvey->filled = SURVEY_INFO_NOISE_DBM | SURVEY_INFO_TIME |\n\t\t\t\t SURVEY_INFO_TIME_BUSY;\n\t\tsurvey->time = div_u64(ch_info_ev.cycle_count, cc_freq_hz);\n\t\tsurvey->time_busy = div_u64(ch_info_ev.rx_clear_count, cc_freq_hz);\n\t}\nexit:\n\tspin_unlock_bh(&ar->data_lock);\n\trcu_read_unlock();\n}\n\nstatic void\nath11k_pdev_bss_chan_info_event(struct ath11k_base *ab, struct sk_buff *skb)\n{\n\tstruct wmi_pdev_bss_chan_info_event bss_ch_info_ev = {};\n\tstruct survey_info *survey;\n\tstruct ath11k *ar;\n\tu32 cc_freq_hz = ab->cc_freq_hz;\n\tu64 busy, total, tx, rx, rx_bss;\n\tint idx;\n\n\tif (ath11k_pull_pdev_bss_chan_info_ev(ab, skb, &bss_ch_info_ev) != 0) {\n\t\tath11k_warn(ab, \"failed to extract pdev bss chan info event\");\n\t\treturn;\n\t}\n\n\tbusy = (u64)(bss_ch_info_ev.rx_clear_count_high) << 32 |\n\t\t\tbss_ch_info_ev.rx_clear_count_low;\n\n\ttotal = (u64)(bss_ch_info_ev.cycle_count_high) << 32 |\n\t\t\tbss_ch_info_ev.cycle_count_low;\n\n\ttx = (u64)(bss_ch_info_ev.tx_cycle_count_high) << 32 |\n\t\t\tbss_ch_info_ev.tx_cycle_count_low;\n\n\trx = (u64)(bss_ch_info_ev.rx_cycle_count_high) << 32 |\n\t\t\tbss_ch_info_ev.rx_cycle_count_low;\n\n\trx_bss = (u64)(bss_ch_info_ev.rx_bss_cycle_count_high) << 32 |\n\t\t\tbss_ch_info_ev.rx_bss_cycle_count_low;\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t   \"event pdev bss chan info:\\n pdev_id: %d freq: %d noise: %d cycle: busy %llu total %llu tx %llu rx %llu rx_bss %llu\\n\",\n\t\t   bss_ch_info_ev.pdev_id, bss_ch_info_ev.freq,\n\t\t   bss_ch_info_ev.noise_floor, busy, total,\n\t\t   tx, rx, rx_bss);\n\n\trcu_read_lock();\n\tar = ath11k_mac_get_ar_by_pdev_id(ab, bss_ch_info_ev.pdev_id);\n\n\tif (!ar) {\n\t\tath11k_warn(ab, \"invalid pdev id %d in bss_chan_info event\\n\",\n\t\t\t    bss_ch_info_ev.pdev_id);\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tspin_lock_bh(&ar->data_lock);\n\tidx = freq_to_idx(ar, bss_ch_info_ev.freq);\n\tif (idx >= ARRAY_SIZE(ar->survey)) {\n\t\tath11k_warn(ab, \"bss chan info: invalid frequency %d (idx %d out of bounds)\\n\",\n\t\t\t    bss_ch_info_ev.freq, idx);\n\t\tgoto exit;\n\t}\n\n\tsurvey = &ar->survey[idx];\n\n\tsurvey->noise     = bss_ch_info_ev.noise_floor;\n\tsurvey->time      = div_u64(total, cc_freq_hz);\n\tsurvey->time_busy = div_u64(busy, cc_freq_hz);\n\tsurvey->time_rx   = div_u64(rx_bss, cc_freq_hz);\n\tsurvey->time_tx   = div_u64(tx, cc_freq_hz);\n\tsurvey->filled   |= (SURVEY_INFO_NOISE_DBM |\n\t\t\t     SURVEY_INFO_TIME |\n\t\t\t     SURVEY_INFO_TIME_BUSY |\n\t\t\t     SURVEY_INFO_TIME_RX |\n\t\t\t     SURVEY_INFO_TIME_TX);\nexit:\n\tspin_unlock_bh(&ar->data_lock);\n\tcomplete(&ar->bss_survey_done);\n\n\trcu_read_unlock();\n}\n\nstatic void ath11k_vdev_install_key_compl_event(struct ath11k_base *ab,\n\t\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct wmi_vdev_install_key_complete_arg install_key_compl = {0};\n\tstruct ath11k *ar;\n\n\tif (ath11k_pull_vdev_install_key_compl_ev(ab, skb, &install_key_compl) != 0) {\n\t\tath11k_warn(ab, \"failed to extract install key compl event\");\n\t\treturn;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t   \"event vdev install key ev idx %d flags %08x macaddr %pM status %d\\n\",\n\t\t   install_key_compl.key_idx, install_key_compl.key_flags,\n\t\t   install_key_compl.macaddr, install_key_compl.status);\n\n\trcu_read_lock();\n\tar = ath11k_mac_get_ar_by_vdev_id(ab, install_key_compl.vdev_id);\n\tif (!ar) {\n\t\tath11k_warn(ab, \"invalid vdev id in install key compl ev %d\",\n\t\t\t    install_key_compl.vdev_id);\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tar->install_key_status = 0;\n\n\tif (install_key_compl.status != WMI_VDEV_INSTALL_KEY_COMPL_STATUS_SUCCESS) {\n\t\tath11k_warn(ab, \"install key failed for %pM status %d\\n\",\n\t\t\t    install_key_compl.macaddr, install_key_compl.status);\n\t\tar->install_key_status = install_key_compl.status;\n\t}\n\n\tcomplete(&ar->install_key_done);\n\trcu_read_unlock();\n}\n\nstatic int  ath11k_wmi_tlv_services_parser(struct ath11k_base *ab,\n\t\t\t\t\t   u16 tag, u16 len,\n\t\t\t\t\t   const void *ptr, void *data)\n{\n\tconst struct wmi_service_available_event *ev;\n\tu32 *wmi_ext2_service_bitmap;\n\tint i, j;\n\n\tswitch (tag) {\n\tcase WMI_TAG_SERVICE_AVAILABLE_EVENT:\n\t\tev = (struct wmi_service_available_event *)ptr;\n\t\tfor (i = 0, j = WMI_MAX_SERVICE;\n\t\t\ti < WMI_SERVICE_SEGMENT_BM_SIZE32 && j < WMI_MAX_EXT_SERVICE;\n\t\t\ti++) {\n\t\t\tdo {\n\t\t\t\tif (ev->wmi_service_segment_bitmap[i] &\n\t\t\t\t    BIT(j % WMI_AVAIL_SERVICE_BITS_IN_SIZE32))\n\t\t\t\t\tset_bit(j, ab->wmi_ab.svc_map);\n\t\t\t} while (++j % WMI_AVAIL_SERVICE_BITS_IN_SIZE32);\n\t\t}\n\n\t\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t\t   \"wmi_ext_service_bitmap 0:0x%04x, 1:0x%04x, 2:0x%04x, 3:0x%04x\",\n\t\t\t   ev->wmi_service_segment_bitmap[0],\n\t\t\t   ev->wmi_service_segment_bitmap[1],\n\t\t\t   ev->wmi_service_segment_bitmap[2],\n\t\t\t   ev->wmi_service_segment_bitmap[3]);\n\t\tbreak;\n\tcase WMI_TAG_ARRAY_UINT32:\n\t\twmi_ext2_service_bitmap = (u32 *)ptr;\n\t\tfor (i = 0, j = WMI_MAX_EXT_SERVICE;\n\t\t\ti < WMI_SERVICE_SEGMENT_BM_SIZE32 && j < WMI_MAX_EXT2_SERVICE;\n\t\t\ti++) {\n\t\t\tdo {\n\t\t\t\tif (wmi_ext2_service_bitmap[i] &\n\t\t\t\t    BIT(j % WMI_AVAIL_SERVICE_BITS_IN_SIZE32))\n\t\t\t\t\tset_bit(j, ab->wmi_ab.svc_map);\n\t\t\t} while (++j % WMI_AVAIL_SERVICE_BITS_IN_SIZE32);\n\t\t}\n\n\t\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t\t   \"wmi_ext2_service__bitmap  0:0x%04x, 1:0x%04x, 2:0x%04x, 3:0x%04x\",\n\t\t\t   wmi_ext2_service_bitmap[0], wmi_ext2_service_bitmap[1],\n\t\t\t   wmi_ext2_service_bitmap[2], wmi_ext2_service_bitmap[3]);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void ath11k_service_available_event(struct ath11k_base *ab, struct sk_buff *skb)\n{\n\tint ret;\n\n\tret = ath11k_wmi_tlv_iter(ab, skb->data, skb->len,\n\t\t\t\t  ath11k_wmi_tlv_services_parser,\n\t\t\t\t  NULL);\n\tif (ret)\n\t\tath11k_warn(ab, \"failed to parse services available tlv %d\\n\", ret);\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI, \"event service available\");\n}\n\nstatic void ath11k_peer_assoc_conf_event(struct ath11k_base *ab, struct sk_buff *skb)\n{\n\tstruct wmi_peer_assoc_conf_arg peer_assoc_conf = {0};\n\tstruct ath11k *ar;\n\n\tif (ath11k_pull_peer_assoc_conf_ev(ab, skb, &peer_assoc_conf) != 0) {\n\t\tath11k_warn(ab, \"failed to extract peer assoc conf event\");\n\t\treturn;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t   \"event peer assoc conf ev vdev id %d macaddr %pM\\n\",\n\t\t   peer_assoc_conf.vdev_id, peer_assoc_conf.macaddr);\n\n\trcu_read_lock();\n\tar = ath11k_mac_get_ar_by_vdev_id(ab, peer_assoc_conf.vdev_id);\n\n\tif (!ar) {\n\t\tath11k_warn(ab, \"invalid vdev id in peer assoc conf ev %d\",\n\t\t\t    peer_assoc_conf.vdev_id);\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\tcomplete(&ar->peer_assoc_done);\n\trcu_read_unlock();\n}\n\nstatic void ath11k_update_stats_event(struct ath11k_base *ab, struct sk_buff *skb)\n{\n\tstruct ath11k_fw_stats stats = {};\n\tstruct ath11k *ar;\n\tint ret;\n\n\tINIT_LIST_HEAD(&stats.pdevs);\n\tINIT_LIST_HEAD(&stats.vdevs);\n\tINIT_LIST_HEAD(&stats.bcn);\n\n\tret = ath11k_wmi_pull_fw_stats(ab, skb, &stats);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to pull fw stats: %d\\n\", ret);\n\t\tgoto free;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI, \"event update stats\");\n\n\trcu_read_lock();\n\tar = ath11k_mac_get_ar_by_pdev_id(ab, stats.pdev_id);\n\tif (!ar) {\n\t\trcu_read_unlock();\n\t\tath11k_warn(ab, \"failed to get ar for pdev_id %d: %d\\n\",\n\t\t\t    stats.pdev_id, ret);\n\t\tgoto free;\n\t}\n\n\tspin_lock_bh(&ar->data_lock);\n\n\t \n\tif (stats.stats_id == WMI_REQUEST_PDEV_STAT) {\n\t\tlist_splice_tail_init(&stats.pdevs, &ar->fw_stats.pdevs);\n\t\tar->fw_stats_done = true;\n\t\tgoto complete;\n\t}\n\n\t \n\tath11k_debugfs_fw_stats_process(ar, &stats);\n\ncomplete:\n\tcomplete(&ar->fw_stats_complete);\n\trcu_read_unlock();\n\tspin_unlock_bh(&ar->data_lock);\n\n\t \n\treturn;\n\nfree:\n\tath11k_fw_stats_free(&stats);\n}\n\n \nstatic void ath11k_pdev_ctl_failsafe_check_event(struct ath11k_base *ab,\n\t\t\t\t\t\t struct sk_buff *skb)\n{\n\tconst void **tb;\n\tconst struct wmi_pdev_ctl_failsafe_chk_event *ev;\n\tint ret;\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tev = tb[WMI_TAG_PDEV_CTL_FAILSAFE_CHECK_EVENT];\n\tif (!ev) {\n\t\tath11k_warn(ab, \"failed to fetch pdev ctl failsafe check ev\");\n\t\tkfree(tb);\n\t\treturn;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t   \"event pdev ctl failsafe check status %d\\n\",\n\t\t   ev->ctl_failsafe_status);\n\n\t \n\tif (ev->ctl_failsafe_status != 0)\n\t\tath11k_warn(ab, \"pdev ctl failsafe failure status %d\",\n\t\t\t    ev->ctl_failsafe_status);\n\n\tkfree(tb);\n}\n\nstatic void\nath11k_wmi_process_csa_switch_count_event(struct ath11k_base *ab,\n\t\t\t\t\t  const struct wmi_pdev_csa_switch_ev *ev,\n\t\t\t\t\t  const u32 *vdev_ids)\n{\n\tint i;\n\tstruct ath11k_vif *arvif;\n\n\t \n\tif (ev->current_switch_count)\n\t\treturn;\n\n\trcu_read_lock();\n\tfor (i = 0; i < ev->num_vdevs; i++) {\n\t\tarvif = ath11k_mac_get_arvif_by_vdev_id(ab, vdev_ids[i]);\n\n\t\tif (!arvif) {\n\t\t\tath11k_warn(ab, \"Recvd csa status for unknown vdev %d\",\n\t\t\t\t    vdev_ids[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (arvif->is_up && arvif->vif->bss_conf.csa_active)\n\t\t\tieee80211_csa_finish(arvif->vif);\n\t}\n\trcu_read_unlock();\n}\n\nstatic void\nath11k_wmi_pdev_csa_switch_count_status_event(struct ath11k_base *ab,\n\t\t\t\t\t      struct sk_buff *skb)\n{\n\tconst void **tb;\n\tconst struct wmi_pdev_csa_switch_ev *ev;\n\tconst u32 *vdev_ids;\n\tint ret;\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tev = tb[WMI_TAG_PDEV_CSA_SWITCH_COUNT_STATUS_EVENT];\n\tvdev_ids = tb[WMI_TAG_ARRAY_UINT32];\n\n\tif (!ev || !vdev_ids) {\n\t\tath11k_warn(ab, \"failed to fetch pdev csa switch count ev\");\n\t\tkfree(tb);\n\t\treturn;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t   \"event pdev csa switch count %d for pdev %d, num_vdevs %d\",\n\t\t   ev->current_switch_count, ev->pdev_id,\n\t\t   ev->num_vdevs);\n\n\tath11k_wmi_process_csa_switch_count_event(ab, ev, vdev_ids);\n\n\tkfree(tb);\n}\n\nstatic void\nath11k_wmi_pdev_dfs_radar_detected_event(struct ath11k_base *ab, struct sk_buff *skb)\n{\n\tconst void **tb;\n\tconst struct wmi_pdev_radar_ev *ev;\n\tstruct ath11k *ar;\n\tint ret;\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tev = tb[WMI_TAG_PDEV_DFS_RADAR_DETECTION_EVENT];\n\n\tif (!ev) {\n\t\tath11k_warn(ab, \"failed to fetch pdev dfs radar detected ev\");\n\t\tkfree(tb);\n\t\treturn;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI,\n\t\t   \"event pdev dfs radar detected on pdev %d, detection mode %d, chan freq %d, chan_width %d, detector id %d, seg id %d, timestamp %d, chirp %d, freq offset %d, sidx %d\",\n\t\t   ev->pdev_id, ev->detection_mode, ev->chan_freq, ev->chan_width,\n\t\t   ev->detector_id, ev->segment_id, ev->timestamp, ev->is_chirp,\n\t\t   ev->freq_offset, ev->sidx);\n\n\trcu_read_lock();\n\n\tar = ath11k_mac_get_ar_by_pdev_id(ab, ev->pdev_id);\n\n\tif (!ar) {\n\t\tath11k_warn(ab, \"radar detected in invalid pdev %d\\n\",\n\t\t\t    ev->pdev_id);\n\t\tgoto exit;\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_REG, \"DFS Radar Detected in pdev %d\\n\",\n\t\t   ev->pdev_id);\n\n\tif (ar->dfs_block_radar_events)\n\t\tath11k_info(ab, \"DFS Radar detected, but ignored as requested\\n\");\n\telse\n\t\tieee80211_radar_detected(ar->hw);\n\nexit:\n\trcu_read_unlock();\n\n\tkfree(tb);\n}\n\nstatic void\nath11k_wmi_pdev_temperature_event(struct ath11k_base *ab,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct ath11k *ar;\n\tconst void **tb;\n\tconst struct wmi_pdev_temperature_event *ev;\n\tint ret;\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tev = tb[WMI_TAG_PDEV_TEMPERATURE_EVENT];\n\tif (!ev) {\n\t\tath11k_warn(ab, \"failed to fetch pdev temp ev\");\n\t\tkfree(tb);\n\t\treturn;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI, \"event pdev temperature ev temp %d pdev_id %d\\n\",\n\t\t   ev->temp, ev->pdev_id);\n\n\trcu_read_lock();\n\n\tar = ath11k_mac_get_ar_by_pdev_id(ab, ev->pdev_id);\n\tif (!ar) {\n\t\tath11k_warn(ab, \"invalid pdev id in pdev temperature ev %d\", ev->pdev_id);\n\t\tgoto exit;\n\t}\n\n\tath11k_thermal_event_temperature(ar, ev->temp);\n\nexit:\n\trcu_read_unlock();\n\n\tkfree(tb);\n}\n\nstatic void ath11k_fils_discovery_event(struct ath11k_base *ab,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tconst void **tb;\n\tconst struct wmi_fils_discovery_event *ev;\n\tint ret;\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab,\n\t\t\t    \"failed to parse FILS discovery event tlv %d\\n\",\n\t\t\t    ret);\n\t\treturn;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI, \"event fils discovery\");\n\n\tev = tb[WMI_TAG_HOST_SWFDA_EVENT];\n\tif (!ev) {\n\t\tath11k_warn(ab, \"failed to fetch FILS discovery event\\n\");\n\t\tkfree(tb);\n\t\treturn;\n\t}\n\n\tath11k_warn(ab,\n\t\t    \"FILS discovery frame expected from host for vdev_id: %u, transmission scheduled at %u, next TBTT: %u\\n\",\n\t\t    ev->vdev_id, ev->fils_tt, ev->tbtt);\n\n\tkfree(tb);\n}\n\nstatic void ath11k_probe_resp_tx_status_event(struct ath11k_base *ab,\n\t\t\t\t\t      struct sk_buff *skb)\n{\n\tconst void **tb;\n\tconst struct wmi_probe_resp_tx_status_event *ev;\n\tint ret;\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab,\n\t\t\t    \"failed to parse probe response transmission status event tlv: %d\\n\",\n\t\t\t    ret);\n\t\treturn;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI, \"event probe resp tx status\");\n\n\tev = tb[WMI_TAG_OFFLOAD_PRB_RSP_TX_STATUS_EVENT];\n\tif (!ev) {\n\t\tath11k_warn(ab,\n\t\t\t    \"failed to fetch probe response transmission status event\");\n\t\tkfree(tb);\n\t\treturn;\n\t}\n\n\tif (ev->tx_status)\n\t\tath11k_warn(ab,\n\t\t\t    \"Probe response transmission failed for vdev_id %u, status %u\\n\",\n\t\t\t    ev->vdev_id, ev->tx_status);\n\n\tkfree(tb);\n}\n\nstatic int ath11k_wmi_tlv_wow_wakeup_host_parse(struct ath11k_base *ab,\n\t\t\t\t\t\tu16 tag, u16 len,\n\t\t\t\t\t\tconst void *ptr, void *data)\n{\n\tstruct wmi_wow_ev_arg *ev = data;\n\tconst char *wow_pg_fault;\n\tint wow_pg_len;\n\n\tswitch (tag) {\n\tcase WMI_TAG_WOW_EVENT_INFO:\n\t\tmemcpy(ev, ptr, sizeof(*ev));\n\t\tath11k_dbg(ab, ATH11K_DBG_WMI, \"wow wakeup host reason %d %s\\n\",\n\t\t\t   ev->wake_reason, wow_reason(ev->wake_reason));\n\t\tbreak;\n\n\tcase WMI_TAG_ARRAY_BYTE:\n\t\tif (ev && ev->wake_reason == WOW_REASON_PAGE_FAULT) {\n\t\t\twow_pg_fault = ptr;\n\t\t\t \n\t\t\twow_pg_len = *(int *)wow_pg_fault;\n\t\t\twow_pg_fault += sizeof(int);\n\t\t\tath11k_dbg(ab, ATH11K_DBG_WMI, \"wow data_len = %d\\n\",\n\t\t\t\t   wow_pg_len);\n\t\t\tath11k_dbg_dump(ab, ATH11K_DBG_WMI,\n\t\t\t\t\t\"wow_event_info_type packet present\",\n\t\t\t\t\t\"wow_pg_fault \",\n\t\t\t\t\twow_pg_fault,\n\t\t\t\t\twow_pg_len);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void ath11k_wmi_event_wow_wakeup_host(struct ath11k_base *ab, struct sk_buff *skb)\n{\n\tstruct wmi_wow_ev_arg ev = { };\n\tint ret;\n\n\tret = ath11k_wmi_tlv_iter(ab, skb->data, skb->len,\n\t\t\t\t  ath11k_wmi_tlv_wow_wakeup_host_parse,\n\t\t\t\t  &ev);\n\tif (ret) {\n\t\tath11k_warn(ab, \"failed to parse wmi wow tlv: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI, \"event wow wakeup host\");\n\n\tcomplete(&ab->wow.wakeup_completed);\n}\n\nstatic void\nath11k_wmi_diag_event(struct ath11k_base *ab,\n\t\t      struct sk_buff *skb)\n{\n\tath11k_dbg(ab, ATH11K_DBG_WMI, \"event diag\");\n\n\ttrace_ath11k_wmi_diag(ab, skb->data, skb->len);\n}\n\nstatic const char *ath11k_wmi_twt_add_dialog_event_status(u32 status)\n{\n\tswitch (status) {\n\tcase WMI_ADD_TWT_STATUS_OK:\n\t\treturn \"ok\";\n\tcase WMI_ADD_TWT_STATUS_TWT_NOT_ENABLED:\n\t\treturn \"twt disabled\";\n\tcase WMI_ADD_TWT_STATUS_USED_DIALOG_ID:\n\t\treturn \"dialog id in use\";\n\tcase WMI_ADD_TWT_STATUS_INVALID_PARAM:\n\t\treturn \"invalid parameters\";\n\tcase WMI_ADD_TWT_STATUS_NOT_READY:\n\t\treturn \"not ready\";\n\tcase WMI_ADD_TWT_STATUS_NO_RESOURCE:\n\t\treturn \"resource unavailable\";\n\tcase WMI_ADD_TWT_STATUS_NO_ACK:\n\t\treturn \"no ack\";\n\tcase WMI_ADD_TWT_STATUS_NO_RESPONSE:\n\t\treturn \"no response\";\n\tcase WMI_ADD_TWT_STATUS_DENIED:\n\t\treturn \"denied\";\n\tcase WMI_ADD_TWT_STATUS_UNKNOWN_ERROR:\n\t\tfallthrough;\n\tdefault:\n\t\treturn \"unknown error\";\n\t}\n}\n\nstatic void ath11k_wmi_twt_add_dialog_event(struct ath11k_base *ab,\n\t\t\t\t\t    struct sk_buff *skb)\n{\n\tconst void **tb;\n\tconst struct wmi_twt_add_dialog_event *ev;\n\tint ret;\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab,\n\t\t\t    \"failed to parse wmi twt add dialog status event tlv: %d\\n\",\n\t\t\t    ret);\n\t\treturn;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI, \"event twt add dialog\");\n\n\tev = tb[WMI_TAG_TWT_ADD_DIALOG_COMPLETE_EVENT];\n\tif (!ev) {\n\t\tath11k_warn(ab, \"failed to fetch twt add dialog wmi event\\n\");\n\t\tgoto exit;\n\t}\n\n\tif (ev->status)\n\t\tath11k_warn(ab,\n\t\t\t    \"wmi add twt dialog event vdev %d dialog id %d status %s\\n\",\n\t\t\t    ev->vdev_id, ev->dialog_id,\n\t\t\t    ath11k_wmi_twt_add_dialog_event_status(ev->status));\n\nexit:\n\tkfree(tb);\n}\n\nstatic void ath11k_wmi_gtk_offload_status_event(struct ath11k_base *ab,\n\t\t\t\t\t\tstruct sk_buff *skb)\n{\n\tconst void **tb;\n\tconst struct wmi_gtk_offload_status_event *ev;\n\tstruct ath11k_vif *arvif;\n\t__be64 replay_ctr_be;\n\tu64    replay_ctr;\n\tint ret;\n\n\ttb = ath11k_wmi_tlv_parse_alloc(ab, skb->data, skb->len, GFP_ATOMIC);\n\tif (IS_ERR(tb)) {\n\t\tret = PTR_ERR(tb);\n\t\tath11k_warn(ab, \"failed to parse tlv: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tev = tb[WMI_TAG_GTK_OFFLOAD_STATUS_EVENT];\n\tif (!ev) {\n\t\tath11k_warn(ab, \"failed to fetch gtk offload status ev\");\n\t\tkfree(tb);\n\t\treturn;\n\t}\n\n\trcu_read_lock();\n\n\tarvif = ath11k_mac_get_arvif_by_vdev_id(ab, ev->vdev_id);\n\tif (!arvif) {\n\t\tath11k_warn(ab, \"failed to get arvif for vdev_id:%d\\n\",\n\t\t\t    ev->vdev_id);\n\t\tgoto exit;\n\t}\n\n\tath11k_dbg(ab, ATH11K_DBG_WMI, \"event gtk offload refresh_cnt %d\\n\",\n\t\t   ev->refresh_cnt);\n\tath11k_dbg_dump(ab, ATH11K_DBG_WMI, \"replay_cnt\",\n\t\t\tNULL, ev->replay_ctr.counter, GTK_REPLAY_COUNTER_BYTES);\n\n\treplay_ctr =  ev->replay_ctr.word1;\n\treplay_ctr = (replay_ctr << 32) | ev->replay_ctr.word0;\n\tarvif->rekey_data.replay_ctr = replay_ctr;\n\n\t \n\treplay_ctr_be = cpu_to_be64(replay_ctr);\n\n\tieee80211_gtk_rekey_notify(arvif->vif, arvif->bssid,\n\t\t\t\t   (void *)&replay_ctr_be, GFP_ATOMIC);\nexit:\n\trcu_read_unlock();\n\n\tkfree(tb);\n}\n\nstatic void ath11k_wmi_tlv_op_rx(struct ath11k_base *ab, struct sk_buff *skb)\n{\n\tstruct wmi_cmd_hdr *cmd_hdr;\n\tenum wmi_tlv_event_id id;\n\n\tcmd_hdr = (struct wmi_cmd_hdr *)skb->data;\n\tid = FIELD_GET(WMI_CMD_HDR_CMD_ID, (cmd_hdr->cmd_id));\n\n\ttrace_ath11k_wmi_event(ab, id, skb->data, skb->len);\n\n\tif (skb_pull(skb, sizeof(struct wmi_cmd_hdr)) == NULL)\n\t\tgoto out;\n\n\tswitch (id) {\n\t\t \n\tcase WMI_SERVICE_READY_EVENTID:\n\t\tath11k_service_ready_event(ab, skb);\n\t\tbreak;\n\tcase WMI_SERVICE_READY_EXT_EVENTID:\n\t\tath11k_service_ready_ext_event(ab, skb);\n\t\tbreak;\n\tcase WMI_SERVICE_READY_EXT2_EVENTID:\n\t\tath11k_service_ready_ext2_event(ab, skb);\n\t\tbreak;\n\tcase WMI_REG_CHAN_LIST_CC_EVENTID:\n\t\tath11k_reg_chan_list_event(ab, skb, WMI_REG_CHAN_LIST_CC_ID);\n\t\tbreak;\n\tcase WMI_REG_CHAN_LIST_CC_EXT_EVENTID:\n\t\tath11k_reg_chan_list_event(ab, skb, WMI_REG_CHAN_LIST_CC_EXT_ID);\n\t\tbreak;\n\tcase WMI_READY_EVENTID:\n\t\tath11k_ready_event(ab, skb);\n\t\tbreak;\n\tcase WMI_PEER_DELETE_RESP_EVENTID:\n\t\tath11k_peer_delete_resp_event(ab, skb);\n\t\tbreak;\n\tcase WMI_VDEV_START_RESP_EVENTID:\n\t\tath11k_vdev_start_resp_event(ab, skb);\n\t\tbreak;\n\tcase WMI_OFFLOAD_BCN_TX_STATUS_EVENTID:\n\t\tath11k_bcn_tx_status_event(ab, skb);\n\t\tbreak;\n\tcase WMI_VDEV_STOPPED_EVENTID:\n\t\tath11k_vdev_stopped_event(ab, skb);\n\t\tbreak;\n\tcase WMI_MGMT_RX_EVENTID:\n\t\tath11k_mgmt_rx_event(ab, skb);\n\t\t \n\t\treturn;\n\tcase WMI_MGMT_TX_COMPLETION_EVENTID:\n\t\tath11k_mgmt_tx_compl_event(ab, skb);\n\t\tbreak;\n\tcase WMI_SCAN_EVENTID:\n\t\tath11k_scan_event(ab, skb);\n\t\tbreak;\n\tcase WMI_PEER_STA_KICKOUT_EVENTID:\n\t\tath11k_peer_sta_kickout_event(ab, skb);\n\t\tbreak;\n\tcase WMI_ROAM_EVENTID:\n\t\tath11k_roam_event(ab, skb);\n\t\tbreak;\n\tcase WMI_CHAN_INFO_EVENTID:\n\t\tath11k_chan_info_event(ab, skb);\n\t\tbreak;\n\tcase WMI_PDEV_BSS_CHAN_INFO_EVENTID:\n\t\tath11k_pdev_bss_chan_info_event(ab, skb);\n\t\tbreak;\n\tcase WMI_VDEV_INSTALL_KEY_COMPLETE_EVENTID:\n\t\tath11k_vdev_install_key_compl_event(ab, skb);\n\t\tbreak;\n\tcase WMI_SERVICE_AVAILABLE_EVENTID:\n\t\tath11k_service_available_event(ab, skb);\n\t\tbreak;\n\tcase WMI_PEER_ASSOC_CONF_EVENTID:\n\t\tath11k_peer_assoc_conf_event(ab, skb);\n\t\tbreak;\n\tcase WMI_UPDATE_STATS_EVENTID:\n\t\tath11k_update_stats_event(ab, skb);\n\t\tbreak;\n\tcase WMI_PDEV_CTL_FAILSAFE_CHECK_EVENTID:\n\t\tath11k_pdev_ctl_failsafe_check_event(ab, skb);\n\t\tbreak;\n\tcase WMI_PDEV_CSA_SWITCH_COUNT_STATUS_EVENTID:\n\t\tath11k_wmi_pdev_csa_switch_count_status_event(ab, skb);\n\t\tbreak;\n\tcase WMI_PDEV_UTF_EVENTID:\n\t\tath11k_tm_wmi_event(ab, id, skb);\n\t\tbreak;\n\tcase WMI_PDEV_TEMPERATURE_EVENTID:\n\t\tath11k_wmi_pdev_temperature_event(ab, skb);\n\t\tbreak;\n\tcase WMI_PDEV_DMA_RING_BUF_RELEASE_EVENTID:\n\t\tath11k_wmi_pdev_dma_ring_buf_release_event(ab, skb);\n\t\tbreak;\n\tcase WMI_HOST_FILS_DISCOVERY_EVENTID:\n\t\tath11k_fils_discovery_event(ab, skb);\n\t\tbreak;\n\tcase WMI_OFFLOAD_PROB_RESP_TX_STATUS_EVENTID:\n\t\tath11k_probe_resp_tx_status_event(ab, skb);\n\t\tbreak;\n\tcase WMI_OBSS_COLOR_COLLISION_DETECTION_EVENTID:\n\t\tath11k_wmi_obss_color_collision_event(ab, skb);\n\t\tbreak;\n\tcase WMI_TWT_ADD_DIALOG_EVENTID:\n\t\tath11k_wmi_twt_add_dialog_event(ab, skb);\n\t\tbreak;\n\tcase WMI_PDEV_DFS_RADAR_DETECTION_EVENTID:\n\t\tath11k_wmi_pdev_dfs_radar_detected_event(ab, skb);\n\t\tbreak;\n\tcase WMI_VDEV_DELETE_RESP_EVENTID:\n\t\tath11k_vdev_delete_resp_event(ab, skb);\n\t\tbreak;\n\tcase WMI_WOW_WAKEUP_HOST_EVENTID:\n\t\tath11k_wmi_event_wow_wakeup_host(ab, skb);\n\t\tbreak;\n\tcase WMI_11D_NEW_COUNTRY_EVENTID:\n\t\tath11k_reg_11d_new_cc_event(ab, skb);\n\t\tbreak;\n\tcase WMI_DIAG_EVENTID:\n\t\tath11k_wmi_diag_event(ab, skb);\n\t\tbreak;\n\tcase WMI_PEER_STA_PS_STATECHG_EVENTID:\n\t\tath11k_wmi_event_peer_sta_ps_state_chg(ab, skb);\n\t\tbreak;\n\tcase WMI_GTK_OFFLOAD_STATUS_EVENTID:\n\t\tath11k_wmi_gtk_offload_status_event(ab, skb);\n\t\tbreak;\n\tdefault:\n\t\tath11k_dbg(ab, ATH11K_DBG_WMI, \"unsupported event id 0x%x\\n\", id);\n\t\tbreak;\n\t}\n\nout:\n\tdev_kfree_skb(skb);\n}\n\nstatic int ath11k_connect_pdev_htc_service(struct ath11k_base *ab,\n\t\t\t\t\t   u32 pdev_idx)\n{\n\tint status;\n\tu32 svc_id[] = { ATH11K_HTC_SVC_ID_WMI_CONTROL,\n\t\t\t ATH11K_HTC_SVC_ID_WMI_CONTROL_MAC1,\n\t\t\t ATH11K_HTC_SVC_ID_WMI_CONTROL_MAC2 };\n\n\tstruct ath11k_htc_svc_conn_req conn_req;\n\tstruct ath11k_htc_svc_conn_resp conn_resp;\n\n\tmemset(&conn_req, 0, sizeof(conn_req));\n\tmemset(&conn_resp, 0, sizeof(conn_resp));\n\n\t \n\tconn_req.ep_ops.ep_tx_complete = ath11k_wmi_htc_tx_complete;\n\tconn_req.ep_ops.ep_rx_complete = ath11k_wmi_tlv_op_rx;\n\tconn_req.ep_ops.ep_tx_credits = ath11k_wmi_op_ep_tx_credits;\n\n\t \n\tconn_req.service_id = svc_id[pdev_idx];\n\n\tstatus = ath11k_htc_connect_service(&ab->htc, &conn_req, &conn_resp);\n\tif (status) {\n\t\tath11k_warn(ab, \"failed to connect to WMI CONTROL service status: %d\\n\",\n\t\t\t    status);\n\t\treturn status;\n\t}\n\n\tab->wmi_ab.wmi_endpoint_id[pdev_idx] = conn_resp.eid;\n\tab->wmi_ab.wmi[pdev_idx].eid = conn_resp.eid;\n\tab->wmi_ab.max_msg_len[pdev_idx] = conn_resp.max_msg_len;\n\tinit_waitqueue_head(&ab->wmi_ab.wmi[pdev_idx].tx_ce_desc_wq);\n\n\treturn 0;\n}\n\nstatic int\nath11k_wmi_send_unit_test_cmd(struct ath11k *ar,\n\t\t\t      struct wmi_unit_test_cmd ut_cmd,\n\t\t\t      u32 *test_args)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_unit_test_cmd *cmd;\n\tstruct sk_buff *skb;\n\tstruct wmi_tlv *tlv;\n\tvoid *ptr;\n\tu32 *ut_cmd_args;\n\tint buf_len, arg_len;\n\tint ret;\n\tint i;\n\n\targ_len = sizeof(u32) * ut_cmd.num_args;\n\tbuf_len = sizeof(ut_cmd) + arg_len + TLV_HDR_SIZE;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, buf_len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_unit_test_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_UNIT_TEST_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(ut_cmd) - TLV_HDR_SIZE);\n\n\tcmd->vdev_id = ut_cmd.vdev_id;\n\tcmd->module_id = ut_cmd.module_id;\n\tcmd->num_args = ut_cmd.num_args;\n\tcmd->diag_token = ut_cmd.diag_token;\n\n\tptr = skb->data + sizeof(ut_cmd);\n\n\ttlv = ptr;\n\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_UINT32) |\n\t\t      FIELD_PREP(WMI_TLV_LEN, arg_len);\n\n\tptr += TLV_HDR_SIZE;\n\n\tut_cmd_args = ptr;\n\tfor (i = 0; i < ut_cmd.num_args; i++)\n\t\tut_cmd_args[i] = test_args[i];\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_UNIT_TEST_CMDID);\n\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to send WMI_UNIT_TEST CMD :%d\\n\",\n\t\t\t    ret);\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"cmd unit test module %d vdev %d n_args %d token %d\\n\",\n\t\t   cmd->module_id, cmd->vdev_id, cmd->num_args,\n\t\t   cmd->diag_token);\n\n\treturn ret;\n}\n\nint ath11k_wmi_simulate_radar(struct ath11k *ar)\n{\n\tstruct ath11k_vif *arvif;\n\tu32 dfs_args[DFS_MAX_TEST_ARGS];\n\tstruct wmi_unit_test_cmd wmi_ut;\n\tbool arvif_found = false;\n\n\tlist_for_each_entry(arvif, &ar->arvifs, list) {\n\t\tif (arvif->is_started && arvif->vdev_type == WMI_VDEV_TYPE_AP) {\n\t\t\tarvif_found = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!arvif_found)\n\t\treturn -EINVAL;\n\n\tdfs_args[DFS_TEST_CMDID] = 0;\n\tdfs_args[DFS_TEST_PDEV_ID] = ar->pdev->pdev_id;\n\t \n\tdfs_args[DFS_TEST_RADAR_PARAM] = 0;\n\n\twmi_ut.vdev_id = arvif->vdev_id;\n\twmi_ut.module_id = DFS_UNIT_TEST_MODULE;\n\twmi_ut.num_args = DFS_MAX_TEST_ARGS;\n\twmi_ut.diag_token = DFS_UNIT_TEST_TOKEN;\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_REG, \"Triggering Radar Simulation\\n\");\n\n\treturn ath11k_wmi_send_unit_test_cmd(ar, wmi_ut, dfs_args);\n}\n\nint ath11k_wmi_fw_dbglog_cfg(struct ath11k *ar, u32 *module_id_bitmap,\n\t\t\t     struct ath11k_fw_dbglog *dbglog)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_debug_log_config_cmd_fixed_param *cmd;\n\tstruct sk_buff *skb;\n\tstruct wmi_tlv *tlv;\n\tint ret, len;\n\n\tlen = sizeof(*cmd) + TLV_HDR_SIZE + (MAX_MODULE_ID_BITMAP_WORDS * sizeof(u32));\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_debug_log_config_cmd_fixed_param *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_DEBUG_LOG_CONFIG_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\tcmd->dbg_log_param = dbglog->param;\n\n\ttlv = (struct wmi_tlv *)((u8 *)cmd + sizeof(*cmd));\n\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_UINT32) |\n\t\t      FIELD_PREP(WMI_TLV_LEN, MAX_MODULE_ID_BITMAP_WORDS * sizeof(u32));\n\n\tswitch (dbglog->param) {\n\tcase WMI_DEBUG_LOG_PARAM_LOG_LEVEL:\n\tcase WMI_DEBUG_LOG_PARAM_VDEV_ENABLE:\n\tcase WMI_DEBUG_LOG_PARAM_VDEV_DISABLE:\n\tcase WMI_DEBUG_LOG_PARAM_VDEV_ENABLE_BITMAP:\n\t\tcmd->value = dbglog->value;\n\t\tbreak;\n\tcase WMI_DEBUG_LOG_PARAM_MOD_ENABLE_BITMAP:\n\tcase WMI_DEBUG_LOG_PARAM_WOW_MOD_ENABLE_BITMAP:\n\t\tcmd->value = dbglog->value;\n\t\tmemcpy(tlv->value, module_id_bitmap,\n\t\t       MAX_MODULE_ID_BITMAP_WORDS * sizeof(u32));\n\t\t \n\t\tmemset(module_id_bitmap, 0,\n\t\t       MAX_MODULE_ID_BITMAP_WORDS * sizeof(u32));\n\t\tbreak;\n\tdefault:\n\t\tdev_kfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\tret = ath11k_wmi_cmd_send(wmi, skb, WMI_DBGLOG_CFG_CMDID);\n\tif (ret) {\n\t\tath11k_warn(ar->ab,\n\t\t\t    \"failed to send WMI_DBGLOG_CFG_CMDID\\n\");\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI, \"cmd dbglog cfg\");\n\n\treturn ret;\n}\n\nint ath11k_wmi_connect(struct ath11k_base *ab)\n{\n\tu32 i;\n\tu8 wmi_ep_count;\n\n\twmi_ep_count = ab->htc.wmi_ep_count;\n\tif (wmi_ep_count > ab->hw_params.max_radios)\n\t\treturn -1;\n\n\tfor (i = 0; i < wmi_ep_count; i++)\n\t\tath11k_connect_pdev_htc_service(ab, i);\n\n\treturn 0;\n}\n\nstatic void ath11k_wmi_pdev_detach(struct ath11k_base *ab, u8 pdev_id)\n{\n\tif (WARN_ON(pdev_id >= MAX_RADIOS))\n\t\treturn;\n\n\t \n}\n\nint ath11k_wmi_pdev_attach(struct ath11k_base *ab,\n\t\t\t   u8 pdev_id)\n{\n\tstruct ath11k_pdev_wmi *wmi_handle;\n\n\tif (pdev_id >= ab->hw_params.max_radios)\n\t\treturn -EINVAL;\n\n\twmi_handle = &ab->wmi_ab.wmi[pdev_id];\n\n\twmi_handle->wmi_ab = &ab->wmi_ab;\n\n\tab->wmi_ab.ab = ab;\n\t \n\n\treturn 0;\n}\n\nint ath11k_wmi_attach(struct ath11k_base *ab)\n{\n\tint ret;\n\n\tret = ath11k_wmi_pdev_attach(ab, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tab->wmi_ab.ab = ab;\n\tab->wmi_ab.preferred_hw_mode = WMI_HOST_HW_MODE_MAX;\n\n\t \n\tif (ab->hw_params.single_pdev_only && ab->hw_params.num_rxmda_per_pdev > 1)\n\t\tab->wmi_ab.preferred_hw_mode = WMI_HOST_HW_MODE_SINGLE;\n\n\t \n\tinit_completion(&ab->wmi_ab.service_ready);\n\tinit_completion(&ab->wmi_ab.unified_ready);\n\n\treturn 0;\n}\n\nvoid ath11k_wmi_detach(struct ath11k_base *ab)\n{\n\tint i;\n\n\t \n\n\tfor (i = 0; i < ab->htc.wmi_ep_count; i++)\n\t\tath11k_wmi_pdev_detach(ab, i);\n\n\tath11k_wmi_free_dbring_caps(ab);\n}\n\nint ath11k_wmi_hw_data_filter_cmd(struct ath11k *ar, u32 vdev_id,\n\t\t\t\t  u32 filter_bitmap, bool enable)\n{\n\tstruct wmi_hw_data_filter_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint len;\n\n\tlen = sizeof(*cmd);\n\tskb = ath11k_wmi_alloc_skb(ar->wmi->wmi_ab, len);\n\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_hw_data_filter_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_HW_DATA_FILTER_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->vdev_id = vdev_id;\n\tcmd->enable = enable;\n\n\t \n\tif (cmd->enable)\n\t\tcmd->hw_filter_bitmap = filter_bitmap;\n\telse\n\t\tcmd->hw_filter_bitmap = ((u32)~0U);\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"hw data filter enable %d filter_bitmap 0x%x\\n\",\n\t\t   enable, filter_bitmap);\n\n\treturn ath11k_wmi_cmd_send(ar->wmi, skb, WMI_HW_DATA_FILTER_CMDID);\n}\n\nint ath11k_wmi_wow_host_wakeup_ind(struct ath11k *ar)\n{\n\tstruct wmi_wow_host_wakeup_ind *cmd;\n\tstruct sk_buff *skb;\n\tsize_t len;\n\n\tlen = sizeof(*cmd);\n\tskb = ath11k_wmi_alloc_skb(ar->wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_wow_host_wakeup_ind *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t     WMI_TAG_WOW_HOSTWAKEUP_FROM_SLEEP_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI, \"tlv wow host wakeup ind\\n\");\n\n\treturn ath11k_wmi_cmd_send(ar->wmi, skb, WMI_WOW_HOSTWAKEUP_FROM_SLEEP_CMDID);\n}\n\nint ath11k_wmi_wow_enable(struct ath11k *ar)\n{\n\tstruct wmi_wow_enable_cmd *cmd;\n\tstruct sk_buff *skb;\n\tint len;\n\n\tlen = sizeof(*cmd);\n\tskb = ath11k_wmi_alloc_skb(ar->wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_wow_enable_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_WOW_ENABLE_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->enable = 1;\n\tcmd->pause_iface_config = WOW_IFACE_PAUSE_ENABLED;\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI, \"tlv wow enable\\n\");\n\n\treturn ath11k_wmi_cmd_send(ar->wmi, skb, WMI_WOW_ENABLE_CMDID);\n}\n\nint ath11k_wmi_scan_prob_req_oui(struct ath11k *ar,\n\t\t\t\t const u8 mac_addr[ETH_ALEN])\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_scan_prob_req_oui_cmd *cmd;\n\tu32 prob_req_oui;\n\tint len;\n\n\tprob_req_oui = (((u32)mac_addr[0]) << 16) |\n\t\t       (((u32)mac_addr[1]) << 8) | mac_addr[2];\n\n\tlen = sizeof(*cmd);\n\tskb = ath11k_wmi_alloc_skb(ar->wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_scan_prob_req_oui_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t     WMI_TAG_SCAN_PROB_REQ_OUI_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\tcmd->prob_req_oui = prob_req_oui;\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI, \"scan prob req oui %d\\n\",\n\t\t   prob_req_oui);\n\n\treturn ath11k_wmi_cmd_send(ar->wmi, skb, WMI_SCAN_PROB_REQ_OUI_CMDID);\n}\n\nint ath11k_wmi_wow_add_wakeup_event(struct ath11k *ar, u32 vdev_id,\n\t\t\t\t    enum wmi_wow_wakeup_event event,\n\t\t\t\tu32 enable)\n{\n\tstruct wmi_wow_add_del_event_cmd *cmd;\n\tstruct sk_buff *skb;\n\tsize_t len;\n\n\tlen = sizeof(*cmd);\n\tskb = ath11k_wmi_alloc_skb(ar->wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_wow_add_del_event_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_WOW_ADD_DEL_EVT_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->vdev_id = vdev_id;\n\tcmd->is_add = enable;\n\tcmd->event_bitmap = (1 << event);\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI, \"tlv wow add wakeup event %s enable %d vdev_id %d\\n\",\n\t\t   wow_wakeup_event(event), enable, vdev_id);\n\n\treturn ath11k_wmi_cmd_send(ar->wmi, skb, WMI_WOW_ENABLE_DISABLE_WAKE_EVENT_CMDID);\n}\n\nint ath11k_wmi_wow_add_pattern(struct ath11k *ar, u32 vdev_id, u32 pattern_id,\n\t\t\t       const u8 *pattern, const u8 *mask,\n\t\t\t   int pattern_len, int pattern_offset)\n{\n\tstruct wmi_wow_add_pattern_cmd *cmd;\n\tstruct wmi_wow_bitmap_pattern *bitmap;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tu8 *ptr;\n\tsize_t len;\n\n\tlen = sizeof(*cmd) +\n\t      sizeof(*tlv) +\t\t\t \n\t      sizeof(*bitmap) +\t\t\t \n\t      sizeof(*tlv) +\t\t\t \n\t      sizeof(*tlv) +\t\t\t \n\t      sizeof(*tlv) +\t\t\t \n\t      sizeof(*tlv) +\t\t\t \n\t      sizeof(*tlv) + sizeof(u32);\t \n\n\tskb = ath11k_wmi_alloc_skb(ar->wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\t \n\tptr = (u8 *)skb->data;\n\tcmd = (struct wmi_wow_add_pattern_cmd *)ptr;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t     WMI_TAG_WOW_ADD_PATTERN_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->vdev_id = vdev_id;\n\tcmd->pattern_id = pattern_id;\n\tcmd->pattern_type = WOW_BITMAP_PATTERN;\n\n\tptr += sizeof(*cmd);\n\n\t \n\ttlv = (struct wmi_tlv *)ptr;\n\ttlv->header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t WMI_TAG_ARRAY_STRUCT) |\n\t\t      FIELD_PREP(WMI_TLV_LEN, sizeof(*bitmap));\n\n\tptr += sizeof(*tlv);\n\n\tbitmap = (struct wmi_wow_bitmap_pattern *)ptr;\n\tbitmap->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t\tWMI_TAG_WOW_BITMAP_PATTERN_T) |\n\t\t\t     FIELD_PREP(WMI_TLV_LEN, sizeof(*bitmap) - TLV_HDR_SIZE);\n\n\tmemcpy(bitmap->patternbuf, pattern, pattern_len);\n\tath11k_ce_byte_swap(bitmap->patternbuf, roundup(pattern_len, 4));\n\tmemcpy(bitmap->bitmaskbuf, mask, pattern_len);\n\tath11k_ce_byte_swap(bitmap->bitmaskbuf, roundup(pattern_len, 4));\n\tbitmap->pattern_offset = pattern_offset;\n\tbitmap->pattern_len = pattern_len;\n\tbitmap->bitmask_len = pattern_len;\n\tbitmap->pattern_id = pattern_id;\n\n\tptr += sizeof(*bitmap);\n\n\t \n\ttlv = (struct wmi_tlv *)ptr;\n\ttlv->header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t WMI_TAG_ARRAY_STRUCT) |\n\t\t      FIELD_PREP(WMI_TLV_LEN, 0);\n\n\tptr += sizeof(*tlv);\n\n\t \n\ttlv = (struct wmi_tlv *)ptr;\n\ttlv->header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t WMI_TAG_ARRAY_STRUCT) |\n\t\t      FIELD_PREP(WMI_TLV_LEN, 0);\n\n\tptr += sizeof(*tlv);\n\n\t \n\ttlv = (struct wmi_tlv *)ptr;\n\ttlv->header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t WMI_TAG_ARRAY_STRUCT) |\n\t\t      FIELD_PREP(WMI_TLV_LEN, 0);\n\n\tptr += sizeof(*tlv);\n\n\t \n\ttlv = (struct wmi_tlv *)ptr;\n\ttlv->header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t WMI_TAG_ARRAY_UINT32) |\n\t\t      FIELD_PREP(WMI_TLV_LEN, 0);\n\n\tptr += sizeof(*tlv);\n\n\t \n\ttlv = (struct wmi_tlv *)ptr;\n\ttlv->header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t WMI_TAG_ARRAY_UINT32) |\n\t\t      FIELD_PREP(WMI_TLV_LEN, sizeof(u32));\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI, \"tlv wow add pattern vdev_id %d pattern_id %d pattern_offset %d\\n\",\n\t\t   vdev_id, pattern_id, pattern_offset);\n\n\treturn ath11k_wmi_cmd_send(ar->wmi, skb, WMI_WOW_ADD_WAKE_PATTERN_CMDID);\n}\n\nint ath11k_wmi_wow_del_pattern(struct ath11k *ar, u32 vdev_id, u32 pattern_id)\n{\n\tstruct wmi_wow_del_pattern_cmd *cmd;\n\tstruct sk_buff *skb;\n\tsize_t len;\n\n\tlen = sizeof(*cmd);\n\tskb = ath11k_wmi_alloc_skb(ar->wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_wow_del_pattern_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t     WMI_TAG_WOW_DEL_PATTERN_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->vdev_id = vdev_id;\n\tcmd->pattern_id = pattern_id;\n\tcmd->pattern_type = WOW_BITMAP_PATTERN;\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI, \"tlv wow del pattern vdev_id %d pattern_id %d\\n\",\n\t\t   vdev_id, pattern_id);\n\n\treturn ath11k_wmi_cmd_send(ar->wmi, skb, WMI_WOW_DEL_WAKE_PATTERN_CMDID);\n}\n\nstatic struct sk_buff *\nath11k_wmi_op_gen_config_pno_start(struct ath11k *ar,\n\t\t\t\t   u32 vdev_id,\n\t\t\t\t       struct wmi_pno_scan_req *pno)\n{\n\tstruct nlo_configured_parameters *nlo_list;\n\tstruct wmi_wow_nlo_config_cmd *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tu32 *channel_list;\n\tsize_t len, nlo_list_len, channel_list_len;\n\tu8 *ptr;\n\tu32 i;\n\n\tlen = sizeof(*cmd) +\n\t      sizeof(*tlv) +\n\t       \n\t      sizeof(*tlv);\n\t       \n\n\tchannel_list_len = sizeof(u32) * pno->a_networks[0].channel_count;\n\tlen += channel_list_len;\n\n\tnlo_list_len = sizeof(*nlo_list) * pno->uc_networks_count;\n\tlen += nlo_list_len;\n\n\tskb = ath11k_wmi_alloc_skb(ar->wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tptr = (u8 *)skb->data;\n\tcmd = (struct wmi_wow_nlo_config_cmd *)ptr;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_NLO_CONFIG_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->vdev_id = pno->vdev_id;\n\tcmd->flags = WMI_NLO_CONFIG_START | WMI_NLO_CONFIG_SSID_HIDE_EN;\n\n\t \n\tcmd->active_dwell_time = pno->active_max_time;\n\tcmd->passive_dwell_time = pno->passive_max_time;\n\n\tif (pno->do_passive_scan)\n\t\tcmd->flags |= WMI_NLO_CONFIG_SCAN_PASSIVE;\n\n\tcmd->fast_scan_period = pno->fast_scan_period;\n\tcmd->slow_scan_period = pno->slow_scan_period;\n\tcmd->fast_scan_max_cycles = pno->fast_scan_max_cycles;\n\tcmd->delay_start_time = pno->delay_start_time;\n\n\tif (pno->enable_pno_scan_randomization) {\n\t\tcmd->flags |= WMI_NLO_CONFIG_SPOOFED_MAC_IN_PROBE_REQ |\n\t\t\t\tWMI_NLO_CONFIG_RANDOM_SEQ_NO_IN_PROBE_REQ;\n\t\tether_addr_copy(cmd->mac_addr.addr, pno->mac_addr);\n\t\tether_addr_copy(cmd->mac_mask.addr, pno->mac_addr_mask);\n\t\tath11k_ce_byte_swap(cmd->mac_addr.addr, 8);\n\t\tath11k_ce_byte_swap(cmd->mac_mask.addr, 8);\n\t}\n\n\tptr += sizeof(*cmd);\n\n\t \n\tcmd->no_of_ssids = pno->uc_networks_count;\n\ttlv = (struct wmi_tlv *)ptr;\n\ttlv->header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t WMI_TAG_ARRAY_STRUCT) |\n\t\t      FIELD_PREP(WMI_TLV_LEN, nlo_list_len);\n\n\tptr += sizeof(*tlv);\n\tnlo_list = (struct nlo_configured_parameters *)ptr;\n\tfor (i = 0; i < cmd->no_of_ssids; i++) {\n\t\ttlv = (struct wmi_tlv *)(&nlo_list[i].tlv_header);\n\t\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_BYTE) |\n\t\t\t      FIELD_PREP(WMI_TLV_LEN, sizeof(*nlo_list) - sizeof(*tlv));\n\n\t\tnlo_list[i].ssid.valid = true;\n\t\tnlo_list[i].ssid.ssid.ssid_len = pno->a_networks[i].ssid.ssid_len;\n\t\tmemcpy(nlo_list[i].ssid.ssid.ssid,\n\t\t       pno->a_networks[i].ssid.ssid,\n\t\t       nlo_list[i].ssid.ssid.ssid_len);\n\t\tath11k_ce_byte_swap(nlo_list[i].ssid.ssid.ssid,\n\t\t\t\t    roundup(nlo_list[i].ssid.ssid.ssid_len, 4));\n\n\t\tif (pno->a_networks[i].rssi_threshold &&\n\t\t    pno->a_networks[i].rssi_threshold > -300) {\n\t\t\tnlo_list[i].rssi_cond.valid = true;\n\t\t\tnlo_list[i].rssi_cond.rssi =\n\t\t\t\tpno->a_networks[i].rssi_threshold;\n\t\t}\n\n\t\tnlo_list[i].bcast_nw_type.valid = true;\n\t\tnlo_list[i].bcast_nw_type.bcast_nw_type =\n\t\t\tpno->a_networks[i].bcast_nw_type;\n\t}\n\n\tptr += nlo_list_len;\n\tcmd->num_of_channels = pno->a_networks[0].channel_count;\n\ttlv = (struct wmi_tlv *)ptr;\n\ttlv->header =  FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_UINT32) |\n\t\t       FIELD_PREP(WMI_TLV_LEN, channel_list_len);\n\tptr += sizeof(*tlv);\n\tchannel_list = (u32 *)ptr;\n\tfor (i = 0; i < cmd->num_of_channels; i++)\n\t\tchannel_list[i] = pno->a_networks[0].channels[i];\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI, \"tlv start pno config vdev_id %d\\n\",\n\t\t   vdev_id);\n\n\treturn skb;\n}\n\nstatic struct sk_buff *ath11k_wmi_op_gen_config_pno_stop(struct ath11k *ar,\n\t\t\t\t\t\t\t u32 vdev_id)\n{\n\tstruct wmi_wow_nlo_config_cmd *cmd;\n\tstruct sk_buff *skb;\n\tsize_t len;\n\n\tlen = sizeof(*cmd);\n\tskb = ath11k_wmi_alloc_skb(ar->wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = (struct wmi_wow_nlo_config_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_NLO_CONFIG_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, len - TLV_HDR_SIZE);\n\n\tcmd->vdev_id = vdev_id;\n\tcmd->flags = WMI_NLO_CONFIG_STOP;\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"tlv stop pno config vdev_id %d\\n\", vdev_id);\n\treturn skb;\n}\n\nint ath11k_wmi_wow_config_pno(struct ath11k *ar, u32 vdev_id,\n\t\t\t      struct wmi_pno_scan_req  *pno_scan)\n{\n\tstruct sk_buff *skb;\n\n\tif (pno_scan->enable)\n\t\tskb = ath11k_wmi_op_gen_config_pno_start(ar, vdev_id, pno_scan);\n\telse\n\t\tskb = ath11k_wmi_op_gen_config_pno_stop(ar, vdev_id);\n\n\tif (IS_ERR_OR_NULL(skb))\n\t\treturn -ENOMEM;\n\n\treturn ath11k_wmi_cmd_send(ar->wmi, skb, WMI_NETWORK_LIST_OFFLOAD_CONFIG_CMDID);\n}\n\nstatic void ath11k_wmi_fill_ns_offload(struct ath11k *ar,\n\t\t\t\t       struct ath11k_arp_ns_offload *offload,\n\t\t\t\t       u8 **ptr,\n\t\t\t\t       bool enable,\n\t\t\t\t       bool ext)\n{\n\tstruct wmi_ns_offload_tuple *ns;\n\tstruct wmi_tlv *tlv;\n\tu8 *buf_ptr = *ptr;\n\tu32 ns_cnt, ns_ext_tuples;\n\tint i, max_offloads;\n\n\tns_cnt = offload->ipv6_count;\n\n\ttlv  = (struct wmi_tlv *)buf_ptr;\n\n\tif (ext) {\n\t\tns_ext_tuples = offload->ipv6_count - WMI_MAX_NS_OFFLOADS;\n\t\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_STRUCT) |\n\t\t\t      FIELD_PREP(WMI_TLV_LEN, ns_ext_tuples * sizeof(*ns));\n\t\ti = WMI_MAX_NS_OFFLOADS;\n\t\tmax_offloads = offload->ipv6_count;\n\t} else {\n\t\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_STRUCT) |\n\t\t\t      FIELD_PREP(WMI_TLV_LEN, WMI_MAX_NS_OFFLOADS * sizeof(*ns));\n\t\ti = 0;\n\t\tmax_offloads = WMI_MAX_NS_OFFLOADS;\n\t}\n\n\tbuf_ptr += sizeof(*tlv);\n\n\tfor (; i < max_offloads; i++) {\n\t\tns = (struct wmi_ns_offload_tuple *)buf_ptr;\n\t\tns->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_NS_OFFLOAD_TUPLE) |\n\t\t\t\t FIELD_PREP(WMI_TLV_LEN, sizeof(*ns) - TLV_HDR_SIZE);\n\n\t\tif (enable) {\n\t\t\tif (i < ns_cnt)\n\t\t\t\tns->flags |= WMI_NSOL_FLAGS_VALID;\n\n\t\t\tmemcpy(ns->target_ipaddr[0], offload->ipv6_addr[i], 16);\n\t\t\tmemcpy(ns->solicitation_ipaddr, offload->self_ipv6_addr[i], 16);\n\t\t\tath11k_ce_byte_swap(ns->target_ipaddr[0], 16);\n\t\t\tath11k_ce_byte_swap(ns->solicitation_ipaddr, 16);\n\n\t\t\tif (offload->ipv6_type[i])\n\t\t\t\tns->flags |= WMI_NSOL_FLAGS_IS_IPV6_ANYCAST;\n\n\t\t\tmemcpy(ns->target_mac.addr, offload->mac_addr, ETH_ALEN);\n\t\t\tath11k_ce_byte_swap(ns->target_mac.addr, 8);\n\n\t\t\tif (ns->target_mac.word0 != 0 ||\n\t\t\t    ns->target_mac.word1 != 0) {\n\t\t\t\tns->flags |= WMI_NSOL_FLAGS_MAC_VALID;\n\t\t\t}\n\n\t\t\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t\t\t   \"index %d ns_solicited %pI6 target %pI6\",\n\t\t\t\t   i, ns->solicitation_ipaddr,\n\t\t\t\t   ns->target_ipaddr[0]);\n\t\t}\n\n\t\tbuf_ptr += sizeof(*ns);\n\t}\n\n\t*ptr = buf_ptr;\n}\n\nstatic void ath11k_wmi_fill_arp_offload(struct ath11k *ar,\n\t\t\t\t\tstruct ath11k_arp_ns_offload *offload,\n\t\t\t\t\tu8 **ptr,\n\t\t\t\t\tbool enable)\n{\n\tstruct wmi_arp_offload_tuple *arp;\n\tstruct wmi_tlv *tlv;\n\tu8 *buf_ptr = *ptr;\n\tint i;\n\n\t \n\ttlv = (struct wmi_tlv *)buf_ptr;\n\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_STRUCT) |\n\t\t      FIELD_PREP(WMI_TLV_LEN, WMI_MAX_ARP_OFFLOADS * sizeof(*arp));\n\tbuf_ptr += sizeof(*tlv);\n\n\tfor (i = 0; i < WMI_MAX_ARP_OFFLOADS; i++) {\n\t\tarp = (struct wmi_arp_offload_tuple *)buf_ptr;\n\t\tarp->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARP_OFFLOAD_TUPLE) |\n\t\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*arp) - TLV_HDR_SIZE);\n\n\t\tif (enable && i < offload->ipv4_count) {\n\t\t\t \n\t\t\tarp->flags = WMI_ARPOL_FLAGS_VALID;\n\t\t\tmemcpy(arp->target_ipaddr, offload->ipv4_addr[i], 4);\n\t\t\tath11k_ce_byte_swap(arp->target_ipaddr, 4);\n\n\t\t\tath11k_dbg(ar->ab, ATH11K_DBG_WMI, \"arp offload address %pI4\",\n\t\t\t\t   arp->target_ipaddr);\n\t\t}\n\n\t\tbuf_ptr += sizeof(*arp);\n\t}\n\n\t*ptr = buf_ptr;\n}\n\nint ath11k_wmi_arp_ns_offload(struct ath11k *ar,\n\t\t\t      struct ath11k_vif *arvif, bool enable)\n{\n\tstruct ath11k_arp_ns_offload *offload;\n\tstruct wmi_set_arp_ns_offload_cmd *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tu8 *buf_ptr;\n\tsize_t len;\n\tu8 ns_cnt, ns_ext_tuples = 0;\n\n\toffload = &arvif->arp_ns_offload;\n\tns_cnt = offload->ipv6_count;\n\n\tlen = sizeof(*cmd) +\n\t      sizeof(*tlv) +\n\t      WMI_MAX_NS_OFFLOADS * sizeof(struct wmi_ns_offload_tuple) +\n\t      sizeof(*tlv) +\n\t      WMI_MAX_ARP_OFFLOADS * sizeof(struct wmi_arp_offload_tuple);\n\n\tif (ns_cnt > WMI_MAX_NS_OFFLOADS) {\n\t\tns_ext_tuples = ns_cnt - WMI_MAX_NS_OFFLOADS;\n\t\tlen += sizeof(*tlv) +\n\t\t       ns_ext_tuples * sizeof(struct wmi_ns_offload_tuple);\n\t}\n\n\tskb = ath11k_wmi_alloc_skb(ar->wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tbuf_ptr = skb->data;\n\tcmd = (struct wmi_set_arp_ns_offload_cmd *)buf_ptr;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t     WMI_TAG_SET_ARP_NS_OFFLOAD_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->flags = 0;\n\tcmd->vdev_id = arvif->vdev_id;\n\tcmd->num_ns_ext_tuples = ns_ext_tuples;\n\n\tbuf_ptr += sizeof(*cmd);\n\n\tath11k_wmi_fill_ns_offload(ar, offload, &buf_ptr, enable, 0);\n\tath11k_wmi_fill_arp_offload(ar, offload, &buf_ptr, enable);\n\n\tif (ns_ext_tuples)\n\t\tath11k_wmi_fill_ns_offload(ar, offload, &buf_ptr, enable, 1);\n\n\treturn ath11k_wmi_cmd_send(ar->wmi, skb, WMI_SET_ARP_NS_OFFLOAD_CMDID);\n}\n\nint ath11k_wmi_gtk_rekey_offload(struct ath11k *ar,\n\t\t\t\t struct ath11k_vif *arvif, bool enable)\n{\n\tstruct wmi_gtk_rekey_offload_cmd *cmd;\n\tstruct ath11k_rekey_data *rekey_data = &arvif->rekey_data;\n\tint len;\n\tstruct sk_buff *skb;\n\t__le64 replay_ctr;\n\n\tlen = sizeof(*cmd);\n\tskb =  ath11k_wmi_alloc_skb(ar->wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_gtk_rekey_offload_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_GTK_OFFLOAD_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->vdev_id = arvif->vdev_id;\n\n\tif (enable) {\n\t\tcmd->flags = GTK_OFFLOAD_ENABLE_OPCODE;\n\n\t\t \n\t\tmemcpy(cmd->kck, rekey_data->kck, sizeof(cmd->kck));\n\t\tath11k_ce_byte_swap(cmd->kck, GTK_OFFLOAD_KEK_BYTES);\n\t\tmemcpy(cmd->kek, rekey_data->kek, sizeof(cmd->kek));\n\t\tath11k_ce_byte_swap(cmd->kek, GTK_OFFLOAD_KEK_BYTES);\n\n\t\treplay_ctr = cpu_to_le64(rekey_data->replay_ctr);\n\t\tmemcpy(cmd->replay_ctr, &replay_ctr,\n\t\t       sizeof(replay_ctr));\n\t\tath11k_ce_byte_swap(cmd->replay_ctr, GTK_REPLAY_COUNTER_BYTES);\n\t} else {\n\t\tcmd->flags = GTK_OFFLOAD_DISABLE_OPCODE;\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI, \"offload gtk rekey vdev: %d %d\\n\",\n\t\t   arvif->vdev_id, enable);\n\treturn ath11k_wmi_cmd_send(ar->wmi, skb, WMI_GTK_OFFLOAD_CMDID);\n}\n\nint ath11k_wmi_gtk_rekey_getinfo(struct ath11k *ar,\n\t\t\t\t struct ath11k_vif *arvif)\n{\n\tstruct wmi_gtk_rekey_offload_cmd *cmd;\n\tint len;\n\tstruct sk_buff *skb;\n\n\tlen = sizeof(*cmd);\n\tskb =  ath11k_wmi_alloc_skb(ar->wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_gtk_rekey_offload_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_GTK_OFFLOAD_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\n\tcmd->vdev_id = arvif->vdev_id;\n\tcmd->flags = GTK_OFFLOAD_REQUEST_STATUS_OPCODE;\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI, \"get gtk rekey vdev_id: %d\\n\",\n\t\t   arvif->vdev_id);\n\treturn ath11k_wmi_cmd_send(ar->wmi, skb, WMI_GTK_OFFLOAD_CMDID);\n}\n\nint ath11k_wmi_pdev_set_bios_sar_table_param(struct ath11k *ar, const u8 *sar_val)\n{\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_pdev_set_sar_table_cmd *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tu8 *buf_ptr;\n\tu32 len, sar_len_aligned, rsvd_len_aligned;\n\n\tsar_len_aligned = roundup(BIOS_SAR_TABLE_LEN, sizeof(u32));\n\trsvd_len_aligned = roundup(BIOS_SAR_RSVD1_LEN, sizeof(u32));\n\tlen = sizeof(*cmd) +\n\t      TLV_HDR_SIZE + sar_len_aligned +\n\t      TLV_HDR_SIZE + rsvd_len_aligned;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_pdev_set_sar_table_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_PDEV_SET_BIOS_SAR_TABLE_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\tcmd->pdev_id = ar->pdev->pdev_id;\n\tcmd->sar_len = BIOS_SAR_TABLE_LEN;\n\tcmd->rsvd_len = BIOS_SAR_RSVD1_LEN;\n\n\tbuf_ptr = skb->data + sizeof(*cmd);\n\ttlv = (struct wmi_tlv *)buf_ptr;\n\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_BYTE) |\n\t\t      FIELD_PREP(WMI_TLV_LEN, sar_len_aligned);\n\tbuf_ptr += TLV_HDR_SIZE;\n\tmemcpy(buf_ptr, sar_val, BIOS_SAR_TABLE_LEN);\n\n\tbuf_ptr += sar_len_aligned;\n\ttlv = (struct wmi_tlv *)buf_ptr;\n\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_BYTE) |\n\t\t      FIELD_PREP(WMI_TLV_LEN, rsvd_len_aligned);\n\n\treturn ath11k_wmi_cmd_send(wmi, skb, WMI_PDEV_SET_BIOS_SAR_TABLE_CMDID);\n}\n\nint ath11k_wmi_pdev_set_bios_geo_table_param(struct ath11k *ar)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_pdev_set_geo_table_cmd *cmd;\n\tstruct wmi_tlv *tlv;\n\tstruct sk_buff *skb;\n\tu8 *buf_ptr;\n\tu32 len, rsvd_len_aligned;\n\n\trsvd_len_aligned = roundup(BIOS_SAR_RSVD2_LEN, sizeof(u32));\n\tlen = sizeof(*cmd) + TLV_HDR_SIZE + rsvd_len_aligned;\n\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_pdev_set_geo_table_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_PDEV_SET_BIOS_GEO_TABLE_CMD) |\n\t\t\t  FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\tcmd->pdev_id = ar->pdev->pdev_id;\n\tcmd->rsvd_len = BIOS_SAR_RSVD2_LEN;\n\n\tbuf_ptr = skb->data + sizeof(*cmd);\n\ttlv = (struct wmi_tlv *)buf_ptr;\n\ttlv->header = FIELD_PREP(WMI_TLV_TAG, WMI_TAG_ARRAY_BYTE) |\n\t\t      FIELD_PREP(WMI_TLV_LEN, rsvd_len_aligned);\n\n\treturn ath11k_wmi_cmd_send(wmi, skb, WMI_PDEV_SET_BIOS_GEO_TABLE_CMDID);\n}\n\nint ath11k_wmi_sta_keepalive(struct ath11k *ar,\n\t\t\t     const struct wmi_sta_keepalive_arg *arg)\n{\n\tstruct ath11k_pdev_wmi *wmi = ar->wmi;\n\tstruct wmi_sta_keepalive_cmd *cmd;\n\tstruct wmi_sta_keepalive_arp_resp *arp;\n\tstruct sk_buff *skb;\n\tsize_t len;\n\n\tlen = sizeof(*cmd) + sizeof(*arp);\n\tskb = ath11k_wmi_alloc_skb(wmi->wmi_ab, len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_sta_keepalive_cmd *)skb->data;\n\tcmd->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t     WMI_TAG_STA_KEEPALIVE_CMD) |\n\t\t\t\t     FIELD_PREP(WMI_TLV_LEN, sizeof(*cmd) - TLV_HDR_SIZE);\n\tcmd->vdev_id = arg->vdev_id;\n\tcmd->enabled = arg->enabled;\n\tcmd->interval = arg->interval;\n\tcmd->method = arg->method;\n\n\tarp = (struct wmi_sta_keepalive_arp_resp *)(cmd + 1);\n\tarp->tlv_header = FIELD_PREP(WMI_TLV_TAG,\n\t\t\t\t     WMI_TAG_STA_KEEPALIVE_ARP_RESPONSE) |\n\t\t\t FIELD_PREP(WMI_TLV_LEN, sizeof(*arp) - TLV_HDR_SIZE);\n\n\tif (arg->method == WMI_STA_KEEPALIVE_METHOD_UNSOLICITED_ARP_RESPONSE ||\n\t    arg->method == WMI_STA_KEEPALIVE_METHOD_GRATUITOUS_ARP_REQUEST) {\n\t\tarp->src_ip4_addr = arg->src_ip4_addr;\n\t\tarp->dest_ip4_addr = arg->dest_ip4_addr;\n\t\tether_addr_copy(arp->dest_mac_addr.addr, arg->dest_mac_addr);\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t   \"sta keepalive vdev %d enabled %d method %d interval %d\\n\",\n\t\t   arg->vdev_id, arg->enabled, arg->method, arg->interval);\n\n\treturn ath11k_wmi_cmd_send(wmi, skb, WMI_STA_KEEPALIVE_CMDID);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}