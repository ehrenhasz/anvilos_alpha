{
  "module_name": "debugfs_sta.c",
  "hash_id": "f6b591698fe35b2216b8c11053e82086966b2325f96fc35b7cb0d15b9b406fc2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath11k/debugfs_sta.c",
  "human_readable_source": "\n \n\n#include <linux/vmalloc.h>\n\n#include \"debugfs_sta.h\"\n#include \"core.h\"\n#include \"peer.h\"\n#include \"debug.h\"\n#include \"dp_tx.h\"\n#include \"debugfs_htt_stats.h\"\n\nvoid ath11k_debugfs_sta_add_tx_stats(struct ath11k_sta *arsta,\n\t\t\t\t     struct ath11k_per_peer_tx_stats *peer_stats,\n\t\t\t\t     u8 legacy_rate_idx)\n{\n\tstruct rate_info *txrate = &arsta->txrate;\n\tstruct ath11k_htt_tx_stats *tx_stats;\n\tint gi, mcs, bw, nss;\n\n\tif (!arsta->tx_stats)\n\t\treturn;\n\n\ttx_stats = arsta->tx_stats;\n\tgi = FIELD_GET(RATE_INFO_FLAGS_SHORT_GI, arsta->txrate.flags);\n\tmcs = txrate->mcs;\n\tbw = ath11k_mac_mac80211_bw_to_ath11k_bw(txrate->bw);\n\tnss = txrate->nss - 1;\n\n#define STATS_OP_FMT(name) tx_stats->stats[ATH11K_STATS_TYPE_##name]\n\n\tif (txrate->flags & RATE_INFO_FLAGS_HE_MCS) {\n\t\tSTATS_OP_FMT(SUCC).he[0][mcs] += peer_stats->succ_bytes;\n\t\tSTATS_OP_FMT(SUCC).he[1][mcs] += peer_stats->succ_pkts;\n\t\tSTATS_OP_FMT(FAIL).he[0][mcs] += peer_stats->failed_bytes;\n\t\tSTATS_OP_FMT(FAIL).he[1][mcs] += peer_stats->failed_pkts;\n\t\tSTATS_OP_FMT(RETRY).he[0][mcs] += peer_stats->retry_bytes;\n\t\tSTATS_OP_FMT(RETRY).he[1][mcs] += peer_stats->retry_pkts;\n\t} else if (txrate->flags & RATE_INFO_FLAGS_VHT_MCS) {\n\t\tSTATS_OP_FMT(SUCC).vht[0][mcs] += peer_stats->succ_bytes;\n\t\tSTATS_OP_FMT(SUCC).vht[1][mcs] += peer_stats->succ_pkts;\n\t\tSTATS_OP_FMT(FAIL).vht[0][mcs] += peer_stats->failed_bytes;\n\t\tSTATS_OP_FMT(FAIL).vht[1][mcs] += peer_stats->failed_pkts;\n\t\tSTATS_OP_FMT(RETRY).vht[0][mcs] += peer_stats->retry_bytes;\n\t\tSTATS_OP_FMT(RETRY).vht[1][mcs] += peer_stats->retry_pkts;\n\t} else if (txrate->flags & RATE_INFO_FLAGS_MCS) {\n\t\tSTATS_OP_FMT(SUCC).ht[0][mcs] += peer_stats->succ_bytes;\n\t\tSTATS_OP_FMT(SUCC).ht[1][mcs] += peer_stats->succ_pkts;\n\t\tSTATS_OP_FMT(FAIL).ht[0][mcs] += peer_stats->failed_bytes;\n\t\tSTATS_OP_FMT(FAIL).ht[1][mcs] += peer_stats->failed_pkts;\n\t\tSTATS_OP_FMT(RETRY).ht[0][mcs] += peer_stats->retry_bytes;\n\t\tSTATS_OP_FMT(RETRY).ht[1][mcs] += peer_stats->retry_pkts;\n\t} else {\n\t\tmcs = legacy_rate_idx;\n\n\t\tSTATS_OP_FMT(SUCC).legacy[0][mcs] += peer_stats->succ_bytes;\n\t\tSTATS_OP_FMT(SUCC).legacy[1][mcs] += peer_stats->succ_pkts;\n\t\tSTATS_OP_FMT(FAIL).legacy[0][mcs] += peer_stats->failed_bytes;\n\t\tSTATS_OP_FMT(FAIL).legacy[1][mcs] += peer_stats->failed_pkts;\n\t\tSTATS_OP_FMT(RETRY).legacy[0][mcs] += peer_stats->retry_bytes;\n\t\tSTATS_OP_FMT(RETRY).legacy[1][mcs] += peer_stats->retry_pkts;\n\t}\n\n\tif (peer_stats->is_ampdu) {\n\t\ttx_stats->ba_fails += peer_stats->ba_fails;\n\n\t\tif (txrate->flags & RATE_INFO_FLAGS_HE_MCS) {\n\t\t\tSTATS_OP_FMT(AMPDU).he[0][mcs] +=\n\t\t\tpeer_stats->succ_bytes + peer_stats->retry_bytes;\n\t\t\tSTATS_OP_FMT(AMPDU).he[1][mcs] +=\n\t\t\tpeer_stats->succ_pkts + peer_stats->retry_pkts;\n\t\t} else if (txrate->flags & RATE_INFO_FLAGS_MCS) {\n\t\t\tSTATS_OP_FMT(AMPDU).ht[0][mcs] +=\n\t\t\tpeer_stats->succ_bytes + peer_stats->retry_bytes;\n\t\t\tSTATS_OP_FMT(AMPDU).ht[1][mcs] +=\n\t\t\tpeer_stats->succ_pkts + peer_stats->retry_pkts;\n\t\t} else {\n\t\t\tSTATS_OP_FMT(AMPDU).vht[0][mcs] +=\n\t\t\tpeer_stats->succ_bytes + peer_stats->retry_bytes;\n\t\t\tSTATS_OP_FMT(AMPDU).vht[1][mcs] +=\n\t\t\tpeer_stats->succ_pkts + peer_stats->retry_pkts;\n\t\t}\n\t\tSTATS_OP_FMT(AMPDU).bw[0][bw] +=\n\t\t\tpeer_stats->succ_bytes + peer_stats->retry_bytes;\n\t\tSTATS_OP_FMT(AMPDU).nss[0][nss] +=\n\t\t\tpeer_stats->succ_bytes + peer_stats->retry_bytes;\n\t\tSTATS_OP_FMT(AMPDU).gi[0][gi] +=\n\t\t\tpeer_stats->succ_bytes + peer_stats->retry_bytes;\n\t\tSTATS_OP_FMT(AMPDU).bw[1][bw] +=\n\t\t\tpeer_stats->succ_pkts + peer_stats->retry_pkts;\n\t\tSTATS_OP_FMT(AMPDU).nss[1][nss] +=\n\t\t\tpeer_stats->succ_pkts + peer_stats->retry_pkts;\n\t\tSTATS_OP_FMT(AMPDU).gi[1][gi] +=\n\t\t\tpeer_stats->succ_pkts + peer_stats->retry_pkts;\n\t} else {\n\t\ttx_stats->ack_fails += peer_stats->ba_fails;\n\t}\n\n\tSTATS_OP_FMT(SUCC).bw[0][bw] += peer_stats->succ_bytes;\n\tSTATS_OP_FMT(SUCC).nss[0][nss] += peer_stats->succ_bytes;\n\tSTATS_OP_FMT(SUCC).gi[0][gi] += peer_stats->succ_bytes;\n\n\tSTATS_OP_FMT(SUCC).bw[1][bw] += peer_stats->succ_pkts;\n\tSTATS_OP_FMT(SUCC).nss[1][nss] += peer_stats->succ_pkts;\n\tSTATS_OP_FMT(SUCC).gi[1][gi] += peer_stats->succ_pkts;\n\n\tSTATS_OP_FMT(FAIL).bw[0][bw] += peer_stats->failed_bytes;\n\tSTATS_OP_FMT(FAIL).nss[0][nss] += peer_stats->failed_bytes;\n\tSTATS_OP_FMT(FAIL).gi[0][gi] += peer_stats->failed_bytes;\n\n\tSTATS_OP_FMT(FAIL).bw[1][bw] += peer_stats->failed_pkts;\n\tSTATS_OP_FMT(FAIL).nss[1][nss] += peer_stats->failed_pkts;\n\tSTATS_OP_FMT(FAIL).gi[1][gi] += peer_stats->failed_pkts;\n\n\tSTATS_OP_FMT(RETRY).bw[0][bw] += peer_stats->retry_bytes;\n\tSTATS_OP_FMT(RETRY).nss[0][nss] += peer_stats->retry_bytes;\n\tSTATS_OP_FMT(RETRY).gi[0][gi] += peer_stats->retry_bytes;\n\n\tSTATS_OP_FMT(RETRY).bw[1][bw] += peer_stats->retry_pkts;\n\tSTATS_OP_FMT(RETRY).nss[1][nss] += peer_stats->retry_pkts;\n\tSTATS_OP_FMT(RETRY).gi[1][gi] += peer_stats->retry_pkts;\n\n\ttx_stats->tx_duration += peer_stats->duration;\n}\n\nvoid ath11k_debugfs_sta_update_txcompl(struct ath11k *ar,\n\t\t\t\t       struct hal_tx_status *ts)\n{\n\tath11k_dp_tx_update_txcompl(ar, ts);\n}\n\nstatic ssize_t ath11k_dbg_sta_dump_tx_stats(struct file *file,\n\t\t\t\t\t    char __user *user_buf,\n\t\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct ieee80211_sta *sta = file->private_data;\n\tstruct ath11k_sta *arsta = (struct ath11k_sta *)sta->drv_priv;\n\tstruct ath11k *ar = arsta->arvif->ar;\n\tstruct ath11k_htt_data_stats *stats;\n\tstatic const char *str_name[ATH11K_STATS_TYPE_MAX] = {\"succ\", \"fail\",\n\t\t\t\t\t\t\t      \"retry\", \"ampdu\"};\n\tstatic const char *str[ATH11K_COUNTER_TYPE_MAX] = {\"bytes\", \"packets\"};\n\tint len = 0, i, j, k, retval = 0;\n\tconst int size = 2 * 4096;\n\tchar *buf;\n\n\tif (!arsta->tx_stats)\n\t\treturn -ENOENT;\n\n\tbuf = kzalloc(size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tspin_lock_bh(&ar->data_lock);\n\tfor (k = 0; k < ATH11K_STATS_TYPE_MAX; k++) {\n\t\tfor (j = 0; j < ATH11K_COUNTER_TYPE_MAX; j++) {\n\t\t\tstats = &arsta->tx_stats->stats[k];\n\t\t\tlen += scnprintf(buf + len, size - len, \"%s_%s\\n\",\n\t\t\t\t\t str_name[k],\n\t\t\t\t\t str[j]);\n\t\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\t \" HE MCS %s\\n\",\n\t\t\t\t\t str[j]);\n\t\t\tfor (i = 0; i < ATH11K_HE_MCS_NUM; i++)\n\t\t\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\t\t \"  %llu \",\n\t\t\t\t\t\t stats->he[j][i]);\n\t\t\tlen += scnprintf(buf + len, size - len, \"\\n\");\n\t\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\t \" VHT MCS %s\\n\",\n\t\t\t\t\t str[j]);\n\t\t\tfor (i = 0; i < ATH11K_VHT_MCS_NUM; i++)\n\t\t\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\t\t \"  %llu \",\n\t\t\t\t\t\t stats->vht[j][i]);\n\t\t\tlen += scnprintf(buf + len, size - len, \"\\n\");\n\t\t\tlen += scnprintf(buf + len, size - len, \" HT MCS %s\\n\",\n\t\t\t\t\t str[j]);\n\t\t\tfor (i = 0; i < ATH11K_HT_MCS_NUM; i++)\n\t\t\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\t\t \"  %llu \", stats->ht[j][i]);\n\t\t\tlen += scnprintf(buf + len, size - len, \"\\n\");\n\t\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\t\" BW %s (20,40,80,160 MHz)\\n\", str[j]);\n\t\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\t \"  %llu %llu %llu %llu\\n\",\n\t\t\t\t\t stats->bw[j][0], stats->bw[j][1],\n\t\t\t\t\t stats->bw[j][2], stats->bw[j][3]);\n\t\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\t \" NSS %s (1x1,2x2,3x3,4x4)\\n\", str[j]);\n\t\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\t \"  %llu %llu %llu %llu\\n\",\n\t\t\t\t\t stats->nss[j][0], stats->nss[j][1],\n\t\t\t\t\t stats->nss[j][2], stats->nss[j][3]);\n\t\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\t \" GI %s (0.4us,0.8us,1.6us,3.2us)\\n\",\n\t\t\t\t\t str[j]);\n\t\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\t \"  %llu %llu %llu %llu\\n\",\n\t\t\t\t\t stats->gi[j][0], stats->gi[j][1],\n\t\t\t\t\t stats->gi[j][2], stats->gi[j][3]);\n\t\t\tlen += scnprintf(buf + len, size - len,\n\t\t\t\t\t \" legacy rate %s (1,2 ... Mbps)\\n  \",\n\t\t\t\t\t str[j]);\n\t\t\tfor (i = 0; i < ATH11K_LEGACY_NUM; i++)\n\t\t\t\tlen += scnprintf(buf + len, size - len, \"%llu \",\n\t\t\t\t\t\t stats->legacy[j][i]);\n\t\t\tlen += scnprintf(buf + len, size - len, \"\\n\");\n\t\t}\n\t}\n\n\tlen += scnprintf(buf + len, size - len,\n\t\t\t \"\\nTX duration\\n %llu usecs\\n\",\n\t\t\t arsta->tx_stats->tx_duration);\n\tlen += scnprintf(buf + len, size - len,\n\t\t\t\"BA fails\\n %llu\\n\", arsta->tx_stats->ba_fails);\n\tlen += scnprintf(buf + len, size - len,\n\t\t\t\"ack fails\\n %llu\\n\", arsta->tx_stats->ack_fails);\n\tspin_unlock_bh(&ar->data_lock);\n\n\tif (len > size)\n\t\tlen = size;\n\tretval = simple_read_from_buffer(user_buf, count, ppos, buf, len);\n\tkfree(buf);\n\n\tmutex_unlock(&ar->conf_mutex);\n\treturn retval;\n}\n\nstatic const struct file_operations fops_tx_stats = {\n\t.read = ath11k_dbg_sta_dump_tx_stats,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t ath11k_dbg_sta_dump_rx_stats(struct file *file,\n\t\t\t\t\t    char __user *user_buf,\n\t\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct ieee80211_sta *sta = file->private_data;\n\tstruct ath11k_sta *arsta = (struct ath11k_sta *)sta->drv_priv;\n\tstruct ath11k *ar = arsta->arvif->ar;\n\tstruct ath11k_rx_peer_stats *rx_stats = arsta->rx_stats;\n\tint len = 0, i, retval = 0;\n\tconst int size = 4096;\n\tchar *buf;\n\n\tif (!rx_stats)\n\t\treturn -ENOENT;\n\n\tbuf = kzalloc(size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&ar->conf_mutex);\n\tspin_lock_bh(&ar->ab->base_lock);\n\n\tlen += scnprintf(buf + len, size - len, \"RX peer stats:\\n\");\n\tlen += scnprintf(buf + len, size - len, \"Num of MSDUs: %llu\\n\",\n\t\t\t rx_stats->num_msdu);\n\tlen += scnprintf(buf + len, size - len, \"Num of MSDUs with TCP L4: %llu\\n\",\n\t\t\t rx_stats->tcp_msdu_count);\n\tlen += scnprintf(buf + len, size - len, \"Num of MSDUs with UDP L4: %llu\\n\",\n\t\t\t rx_stats->udp_msdu_count);\n\tlen += scnprintf(buf + len, size - len, \"Num of MSDUs part of AMPDU: %llu\\n\",\n\t\t\t rx_stats->ampdu_msdu_count);\n\tlen += scnprintf(buf + len, size - len, \"Num of MSDUs not part of AMPDU: %llu\\n\",\n\t\t\t rx_stats->non_ampdu_msdu_count);\n\tlen += scnprintf(buf + len, size - len, \"Num of MSDUs using STBC: %llu\\n\",\n\t\t\t rx_stats->stbc_count);\n\tlen += scnprintf(buf + len, size - len, \"Num of MSDUs beamformed: %llu\\n\",\n\t\t\t rx_stats->beamformed_count);\n\tlen += scnprintf(buf + len, size - len, \"Num of MPDUs with FCS ok: %llu\\n\",\n\t\t\t rx_stats->num_mpdu_fcs_ok);\n\tlen += scnprintf(buf + len, size - len, \"Num of MPDUs with FCS error: %llu\\n\",\n\t\t\t rx_stats->num_mpdu_fcs_err);\n\tlen += scnprintf(buf + len, size - len,\n\t\t\t \"GI: 0.8us %llu 0.4us %llu 1.6us %llu 3.2us %llu\\n\",\n\t\t\t rx_stats->gi_count[0], rx_stats->gi_count[1],\n\t\t\t rx_stats->gi_count[2], rx_stats->gi_count[3]);\n\tlen += scnprintf(buf + len, size - len,\n\t\t\t \"BW: 20Mhz %llu 40Mhz %llu 80Mhz %llu 160Mhz %llu\\n\",\n\t\t\t rx_stats->bw_count[0], rx_stats->bw_count[1],\n\t\t\t rx_stats->bw_count[2], rx_stats->bw_count[3]);\n\tlen += scnprintf(buf + len, size - len, \"BCC %llu LDPC %llu\\n\",\n\t\t\t rx_stats->coding_count[0], rx_stats->coding_count[1]);\n\tlen += scnprintf(buf + len, size - len,\n\t\t\t \"preamble: 11A %llu 11B %llu 11N %llu 11AC %llu 11AX %llu\\n\",\n\t\t\t rx_stats->pream_cnt[0], rx_stats->pream_cnt[1],\n\t\t\t rx_stats->pream_cnt[2], rx_stats->pream_cnt[3],\n\t\t\t rx_stats->pream_cnt[4]);\n\tlen += scnprintf(buf + len, size - len,\n\t\t\t \"reception type: SU %llu MU_MIMO %llu MU_OFDMA %llu MU_OFDMA_MIMO %llu\\n\",\n\t\t\t rx_stats->reception_type[0], rx_stats->reception_type[1],\n\t\t\t rx_stats->reception_type[2], rx_stats->reception_type[3]);\n\tlen += scnprintf(buf + len, size - len, \"TID(0-15) Legacy TID(16):\");\n\tfor (i = 0; i <= IEEE80211_NUM_TIDS; i++)\n\t\tlen += scnprintf(buf + len, size - len, \"%llu \", rx_stats->tid_count[i]);\n\tlen += scnprintf(buf + len, size - len, \"\\nMCS(0-11) Legacy MCS(12):\");\n\tfor (i = 0; i < HAL_RX_MAX_MCS + 1; i++)\n\t\tlen += scnprintf(buf + len, size - len, \"%llu \", rx_stats->mcs_count[i]);\n\tlen += scnprintf(buf + len, size - len, \"\\nNSS(1-8):\");\n\tfor (i = 0; i < HAL_RX_MAX_NSS; i++)\n\t\tlen += scnprintf(buf + len, size - len, \"%llu \", rx_stats->nss_count[i]);\n\tlen += scnprintf(buf + len, size - len, \"\\nRX Duration:%llu \",\n\t\t\t rx_stats->rx_duration);\n\tlen += scnprintf(buf + len, size - len,\n\t\t\t \"\\nDCM: %llu\\nRU: 26 %llu 52: %llu 106: %llu 242: %llu 484: %llu 996: %llu\\n\",\n\t\t\t rx_stats->dcm_count, rx_stats->ru_alloc_cnt[0],\n\t\t\t rx_stats->ru_alloc_cnt[1], rx_stats->ru_alloc_cnt[2],\n\t\t\t rx_stats->ru_alloc_cnt[3], rx_stats->ru_alloc_cnt[4],\n\t\t\t rx_stats->ru_alloc_cnt[5]);\n\n\tlen += scnprintf(buf + len, size - len, \"\\n\");\n\n\tspin_unlock_bh(&ar->ab->base_lock);\n\n\tif (len > size)\n\t\tlen = size;\n\tretval = simple_read_from_buffer(user_buf, count, ppos, buf, len);\n\tkfree(buf);\n\n\tmutex_unlock(&ar->conf_mutex);\n\treturn retval;\n}\n\nstatic const struct file_operations fops_rx_stats = {\n\t.read = ath11k_dbg_sta_dump_rx_stats,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic int\nath11k_dbg_sta_open_htt_peer_stats(struct inode *inode, struct file *file)\n{\n\tstruct ieee80211_sta *sta = inode->i_private;\n\tstruct ath11k_sta *arsta = (struct ath11k_sta *)sta->drv_priv;\n\tstruct ath11k *ar = arsta->arvif->ar;\n\tstruct debug_htt_stats_req *stats_req;\n\tint type = ar->debug.htt_stats.type;\n\tint ret;\n\n\tif ((type != ATH11K_DBG_HTT_EXT_STATS_PEER_INFO &&\n\t     type != ATH11K_DBG_HTT_EXT_STATS_PEER_CTRL_PATH_TXRX_STATS) ||\n\t    type == ATH11K_DBG_HTT_EXT_STATS_RESET)\n\t\treturn -EPERM;\n\n\tstats_req = vzalloc(sizeof(*stats_req) + ATH11K_HTT_STATS_BUF_SIZE);\n\tif (!stats_req)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&ar->conf_mutex);\n\tar->debug.htt_stats.stats_req = stats_req;\n\tstats_req->type = type;\n\tmemcpy(stats_req->peer_addr, sta->addr, ETH_ALEN);\n\tret = ath11k_debugfs_htt_stats_req(ar);\n\tmutex_unlock(&ar->conf_mutex);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tfile->private_data = stats_req;\n\treturn 0;\nout:\n\tvfree(stats_req);\n\tar->debug.htt_stats.stats_req = NULL;\n\treturn ret;\n}\n\nstatic int\nath11k_dbg_sta_release_htt_peer_stats(struct inode *inode, struct file *file)\n{\n\tstruct ieee80211_sta *sta = inode->i_private;\n\tstruct ath11k_sta *arsta = (struct ath11k_sta *)sta->drv_priv;\n\tstruct ath11k *ar = arsta->arvif->ar;\n\n\tmutex_lock(&ar->conf_mutex);\n\tvfree(file->private_data);\n\tar->debug.htt_stats.stats_req = NULL;\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn 0;\n}\n\nstatic ssize_t ath11k_dbg_sta_read_htt_peer_stats(struct file *file,\n\t\t\t\t\t\t  char __user *user_buf,\n\t\t\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct debug_htt_stats_req *stats_req = file->private_data;\n\tchar *buf;\n\tu32 length = 0;\n\n\tbuf = stats_req->buf;\n\tlength = min_t(u32, stats_req->buf_len, ATH11K_HTT_STATS_BUF_SIZE);\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, length);\n}\n\nstatic const struct file_operations fops_htt_peer_stats = {\n\t.open = ath11k_dbg_sta_open_htt_peer_stats,\n\t.release = ath11k_dbg_sta_release_htt_peer_stats,\n\t.read = ath11k_dbg_sta_read_htt_peer_stats,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t ath11k_dbg_sta_write_peer_pktlog(struct file *file,\n\t\t\t\t\t\tconst char __user *buf,\n\t\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct ieee80211_sta *sta = file->private_data;\n\tstruct ath11k_sta *arsta = (struct ath11k_sta *)sta->drv_priv;\n\tstruct ath11k *ar = arsta->arvif->ar;\n\tint ret, enable;\n\n\tmutex_lock(&ar->conf_mutex);\n\n\tif (ar->state != ATH11K_STATE_ON) {\n\t\tret = -ENETDOWN;\n\t\tgoto out;\n\t}\n\n\tret = kstrtoint_from_user(buf, count, 0, &enable);\n\tif (ret)\n\t\tgoto out;\n\n\tar->debug.pktlog_peer_valid = enable;\n\tmemcpy(ar->debug.pktlog_peer_addr, sta->addr, ETH_ALEN);\n\n\t \n\tret = ath11k_wmi_pdev_peer_pktlog_filter(ar, sta->addr, enable);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to set peer pktlog filter %pM: %d\\n\",\n\t\t\t    sta->addr, ret);\n\t\tgoto out;\n\t}\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_WMI, \"peer pktlog filter set to %d\\n\",\n\t\t   enable);\n\tret = count;\n\nout:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic ssize_t ath11k_dbg_sta_read_peer_pktlog(struct file *file,\n\t\t\t\t\t       char __user *ubuf,\n\t\t\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct ieee80211_sta *sta = file->private_data;\n\tstruct ath11k_sta *arsta = (struct ath11k_sta *)sta->drv_priv;\n\tstruct ath11k *ar = arsta->arvif->ar;\n\tchar buf[32] = {0};\n\tint len;\n\n\tmutex_lock(&ar->conf_mutex);\n\tlen = scnprintf(buf, sizeof(buf), \"%08x %pM\\n\",\n\t\t\tar->debug.pktlog_peer_valid,\n\t\t\tar->debug.pktlog_peer_addr);\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn simple_read_from_buffer(ubuf, count, ppos, buf, len);\n}\n\nstatic const struct file_operations fops_peer_pktlog = {\n\t.write = ath11k_dbg_sta_write_peer_pktlog,\n\t.read = ath11k_dbg_sta_read_peer_pktlog,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t ath11k_dbg_sta_write_delba(struct file *file,\n\t\t\t\t\t  const char __user *user_buf,\n\t\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct ieee80211_sta *sta = file->private_data;\n\tstruct ath11k_sta *arsta = (struct ath11k_sta *)sta->drv_priv;\n\tstruct ath11k *ar = arsta->arvif->ar;\n\tu32 tid, initiator, reason;\n\tint ret;\n\tchar buf[64] = {0};\n\n\tret = simple_write_to_buffer(buf, sizeof(buf) - 1, ppos,\n\t\t\t\t     user_buf, count);\n\tif (ret <= 0)\n\t\treturn ret;\n\n\tret = sscanf(buf, \"%u %u %u\", &tid, &initiator, &reason);\n\tif (ret != 3)\n\t\treturn -EINVAL;\n\n\t \n\tif (tid > HAL_DESC_REO_NON_QOS_TID - 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ar->conf_mutex);\n\tif (ar->state != ATH11K_STATE_ON ||\n\t    arsta->aggr_mode != ATH11K_DBG_AGGR_MODE_MANUAL) {\n\t\tret = count;\n\t\tgoto out;\n\t}\n\n\tret = ath11k_wmi_delba_send(ar, arsta->arvif->vdev_id, sta->addr,\n\t\t\t\t    tid, initiator, reason);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to send delba: vdev_id %u peer %pM tid %u initiator %u reason %u\\n\",\n\t\t\t    arsta->arvif->vdev_id, sta->addr, tid, initiator,\n\t\t\t    reason);\n\t}\n\tret = count;\nout:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic const struct file_operations fops_delba = {\n\t.write = ath11k_dbg_sta_write_delba,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t ath11k_dbg_sta_write_addba_resp(struct file *file,\n\t\t\t\t\t       const char __user *user_buf,\n\t\t\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct ieee80211_sta *sta = file->private_data;\n\tstruct ath11k_sta *arsta = (struct ath11k_sta *)sta->drv_priv;\n\tstruct ath11k *ar = arsta->arvif->ar;\n\tu32 tid, status;\n\tint ret;\n\tchar buf[64] = {0};\n\n\tret = simple_write_to_buffer(buf, sizeof(buf) - 1, ppos,\n\t\t\t\t     user_buf, count);\n\tif (ret <= 0)\n\t\treturn ret;\n\n\tret = sscanf(buf, \"%u %u\", &tid, &status);\n\tif (ret != 2)\n\t\treturn -EINVAL;\n\n\t \n\tif (tid > HAL_DESC_REO_NON_QOS_TID - 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ar->conf_mutex);\n\tif (ar->state != ATH11K_STATE_ON ||\n\t    arsta->aggr_mode != ATH11K_DBG_AGGR_MODE_MANUAL) {\n\t\tret = count;\n\t\tgoto out;\n\t}\n\n\tret = ath11k_wmi_addba_set_resp(ar, arsta->arvif->vdev_id, sta->addr,\n\t\t\t\t\ttid, status);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to send addba response: vdev_id %u peer %pM tid %u status%u\\n\",\n\t\t\t    arsta->arvif->vdev_id, sta->addr, tid, status);\n\t}\n\tret = count;\nout:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic const struct file_operations fops_addba_resp = {\n\t.write = ath11k_dbg_sta_write_addba_resp,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t ath11k_dbg_sta_write_addba(struct file *file,\n\t\t\t\t\t  const char __user *user_buf,\n\t\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct ieee80211_sta *sta = file->private_data;\n\tstruct ath11k_sta *arsta = (struct ath11k_sta *)sta->drv_priv;\n\tstruct ath11k *ar = arsta->arvif->ar;\n\tu32 tid, buf_size;\n\tint ret;\n\tchar buf[64] = {0};\n\n\tret = simple_write_to_buffer(buf, sizeof(buf) - 1, ppos,\n\t\t\t\t     user_buf, count);\n\tif (ret <= 0)\n\t\treturn ret;\n\n\tret = sscanf(buf, \"%u %u\", &tid, &buf_size);\n\tif (ret != 2)\n\t\treturn -EINVAL;\n\n\t \n\tif (tid > HAL_DESC_REO_NON_QOS_TID - 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ar->conf_mutex);\n\tif (ar->state != ATH11K_STATE_ON ||\n\t    arsta->aggr_mode != ATH11K_DBG_AGGR_MODE_MANUAL) {\n\t\tret = count;\n\t\tgoto out;\n\t}\n\n\tret = ath11k_wmi_addba_send(ar, arsta->arvif->vdev_id, sta->addr,\n\t\t\t\t    tid, buf_size);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to send addba request: vdev_id %u peer %pM tid %u buf_size %u\\n\",\n\t\t\t    arsta->arvif->vdev_id, sta->addr, tid, buf_size);\n\t}\n\n\tret = count;\nout:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic const struct file_operations fops_addba = {\n\t.write = ath11k_dbg_sta_write_addba,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t ath11k_dbg_sta_read_aggr_mode(struct file *file,\n\t\t\t\t\t     char __user *user_buf,\n\t\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct ieee80211_sta *sta = file->private_data;\n\tstruct ath11k_sta *arsta = (struct ath11k_sta *)sta->drv_priv;\n\tstruct ath11k *ar = arsta->arvif->ar;\n\tchar buf[64];\n\tint len = 0;\n\n\tmutex_lock(&ar->conf_mutex);\n\tlen = scnprintf(buf, sizeof(buf) - len,\n\t\t\t\"aggregation mode: %s\\n\\n%s\\n%s\\n\",\n\t\t\t(arsta->aggr_mode == ATH11K_DBG_AGGR_MODE_AUTO) ?\n\t\t\t\"auto\" : \"manual\", \"auto = 0\", \"manual = 1\");\n\tmutex_unlock(&ar->conf_mutex);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic ssize_t ath11k_dbg_sta_write_aggr_mode(struct file *file,\n\t\t\t\t\t      const char __user *user_buf,\n\t\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct ieee80211_sta *sta = file->private_data;\n\tstruct ath11k_sta *arsta = (struct ath11k_sta *)sta->drv_priv;\n\tstruct ath11k *ar = arsta->arvif->ar;\n\tu32 aggr_mode;\n\tint ret;\n\n\tif (kstrtouint_from_user(user_buf, count, 0, &aggr_mode))\n\t\treturn -EINVAL;\n\n\tif (aggr_mode >= ATH11K_DBG_AGGR_MODE_MAX)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ar->conf_mutex);\n\tif (ar->state != ATH11K_STATE_ON ||\n\t    aggr_mode == arsta->aggr_mode) {\n\t\tret = count;\n\t\tgoto out;\n\t}\n\n\tret = ath11k_wmi_addba_clear_resp(ar, arsta->arvif->vdev_id, sta->addr);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to clear addba session ret: %d\\n\",\n\t\t\t    ret);\n\t\tgoto out;\n\t}\n\n\tarsta->aggr_mode = aggr_mode;\nout:\n\tmutex_unlock(&ar->conf_mutex);\n\treturn ret;\n}\n\nstatic const struct file_operations fops_aggr_mode = {\n\t.read = ath11k_dbg_sta_read_aggr_mode,\n\t.write = ath11k_dbg_sta_write_aggr_mode,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t\nath11k_write_htt_peer_stats_reset(struct file *file,\n\t\t\t\t  const char __user *user_buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct ieee80211_sta *sta = file->private_data;\n\tstruct ath11k_sta *arsta = (struct ath11k_sta *)sta->drv_priv;\n\tstruct ath11k *ar = arsta->arvif->ar;\n\tstruct htt_ext_stats_cfg_params cfg_params = { 0 };\n\tint ret;\n\tu8 type;\n\n\tret = kstrtou8_from_user(user_buf, count, 0, &type);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!type)\n\t\treturn ret;\n\n\tmutex_lock(&ar->conf_mutex);\n\tcfg_params.cfg0 = HTT_STAT_PEER_INFO_MAC_ADDR;\n\tcfg_params.cfg0 |= FIELD_PREP(GENMASK(15, 1),\n\t\t\t\tHTT_PEER_STATS_REQ_MODE_FLUSH_TQM);\n\n\tcfg_params.cfg1 = HTT_STAT_DEFAULT_PEER_REQ_TYPE;\n\n\tcfg_params.cfg2 |= FIELD_PREP(GENMASK(7, 0), sta->addr[0]);\n\tcfg_params.cfg2 |= FIELD_PREP(GENMASK(15, 8), sta->addr[1]);\n\tcfg_params.cfg2 |= FIELD_PREP(GENMASK(23, 16), sta->addr[2]);\n\tcfg_params.cfg2 |= FIELD_PREP(GENMASK(31, 24), sta->addr[3]);\n\n\tcfg_params.cfg3 |= FIELD_PREP(GENMASK(7, 0), sta->addr[4]);\n\tcfg_params.cfg3 |= FIELD_PREP(GENMASK(15, 8), sta->addr[5]);\n\n\tcfg_params.cfg3 |= ATH11K_HTT_PEER_STATS_RESET;\n\n\tret = ath11k_dp_tx_htt_h2t_ext_stats_req(ar,\n\t\t\t\t\t\t ATH11K_DBG_HTT_EXT_STATS_PEER_INFO,\n\t\t\t\t\t\t &cfg_params,\n\t\t\t\t\t\t 0ULL);\n\tif (ret) {\n\t\tath11k_warn(ar->ab, \"failed to send htt peer stats request: %d\\n\", ret);\n\t\tmutex_unlock(&ar->conf_mutex);\n\t\treturn ret;\n\t}\n\n\tmutex_unlock(&ar->conf_mutex);\n\n\tret = count;\n\n\treturn ret;\n}\n\nstatic const struct file_operations fops_htt_peer_stats_reset = {\n\t.write = ath11k_write_htt_peer_stats_reset,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t ath11k_dbg_sta_read_peer_ps_state(struct file *file,\n\t\t\t\t\t\t char __user *user_buf,\n\t\t\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct ieee80211_sta *sta = file->private_data;\n\tstruct ath11k_sta *arsta = (struct ath11k_sta *)sta->drv_priv;\n\tstruct ath11k *ar = arsta->arvif->ar;\n\tchar buf[20];\n\tint len;\n\n\tspin_lock_bh(&ar->data_lock);\n\n\tlen = scnprintf(buf, sizeof(buf), \"%d\\n\", arsta->peer_ps_state);\n\n\tspin_unlock_bh(&ar->data_lock);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic const struct file_operations fops_peer_ps_state = {\n\t.open = simple_open,\n\t.read = ath11k_dbg_sta_read_peer_ps_state,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t ath11k_dbg_sta_read_current_ps_duration(struct file *file,\n\t\t\t\t\t\t       char __user *user_buf,\n\t\t\t\t\t\t       size_t count,\n\t\t\t\t\t\t       loff_t *ppos)\n{\n\tstruct ieee80211_sta *sta = file->private_data;\n\tstruct ath11k_sta *arsta = (struct ath11k_sta *)sta->drv_priv;\n\tstruct ath11k *ar = arsta->arvif->ar;\n\tu64 time_since_station_in_power_save;\n\tchar buf[20];\n\tint len;\n\n\tspin_lock_bh(&ar->data_lock);\n\n\tif (arsta->peer_ps_state == WMI_PEER_PS_STATE_ON &&\n\t    arsta->peer_current_ps_valid)\n\t\ttime_since_station_in_power_save = jiffies_to_msecs(jiffies\n\t\t\t\t\t\t- arsta->ps_start_jiffies);\n\telse\n\t\ttime_since_station_in_power_save = 0;\n\n\tlen = scnprintf(buf, sizeof(buf), \"%llu\\n\",\n\t\t\ttime_since_station_in_power_save);\n\tspin_unlock_bh(&ar->data_lock);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic const struct file_operations fops_current_ps_duration = {\n\t.open = simple_open,\n\t.read = ath11k_dbg_sta_read_current_ps_duration,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nstatic ssize_t ath11k_dbg_sta_read_total_ps_duration(struct file *file,\n\t\t\t\t\t\t     char __user *user_buf,\n\t\t\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct ieee80211_sta *sta = file->private_data;\n\tstruct ath11k_sta *arsta = (struct ath11k_sta *)sta->drv_priv;\n\tstruct ath11k *ar = arsta->arvif->ar;\n\tchar buf[20];\n\tu64 power_save_duration;\n\tint len;\n\n\tspin_lock_bh(&ar->data_lock);\n\n\tif (arsta->peer_ps_state == WMI_PEER_PS_STATE_ON &&\n\t    arsta->peer_current_ps_valid)\n\t\tpower_save_duration = jiffies_to_msecs(jiffies\n\t\t\t\t\t\t- arsta->ps_start_jiffies)\n\t\t\t\t\t\t+ arsta->ps_total_duration;\n\telse\n\t\tpower_save_duration = arsta->ps_total_duration;\n\n\tlen = scnprintf(buf, sizeof(buf), \"%llu\\n\", power_save_duration);\n\n\tspin_unlock_bh(&ar->data_lock);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic const struct file_operations fops_total_ps_duration = {\n\t.open = simple_open,\n\t.read = ath11k_dbg_sta_read_total_ps_duration,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\nvoid ath11k_debugfs_sta_op_add(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t       struct ieee80211_sta *sta, struct dentry *dir)\n{\n\tstruct ath11k *ar = hw->priv;\n\n\tif (ath11k_debugfs_is_extd_tx_stats_enabled(ar))\n\t\tdebugfs_create_file(\"tx_stats\", 0400, dir, sta,\n\t\t\t\t    &fops_tx_stats);\n\tif (ath11k_debugfs_is_extd_rx_stats_enabled(ar))\n\t\tdebugfs_create_file(\"rx_stats\", 0400, dir, sta,\n\t\t\t\t    &fops_rx_stats);\n\n\tdebugfs_create_file(\"htt_peer_stats\", 0400, dir, sta,\n\t\t\t    &fops_htt_peer_stats);\n\n\tdebugfs_create_file(\"peer_pktlog\", 0644, dir, sta,\n\t\t\t    &fops_peer_pktlog);\n\n\tdebugfs_create_file(\"aggr_mode\", 0644, dir, sta, &fops_aggr_mode);\n\tdebugfs_create_file(\"addba\", 0200, dir, sta, &fops_addba);\n\tdebugfs_create_file(\"addba_resp\", 0200, dir, sta, &fops_addba_resp);\n\tdebugfs_create_file(\"delba\", 0200, dir, sta, &fops_delba);\n\n\tif (test_bit(WMI_TLV_SERVICE_PER_PEER_HTT_STATS_RESET,\n\t\t     ar->ab->wmi_ab.svc_map))\n\t\tdebugfs_create_file(\"htt_peer_stats_reset\", 0600, dir, sta,\n\t\t\t\t    &fops_htt_peer_stats_reset);\n\n\tdebugfs_create_file(\"peer_ps_state\", 0400, dir, sta,\n\t\t\t    &fops_peer_ps_state);\n\n\tif (test_bit(WMI_TLV_SERVICE_PEER_POWER_SAVE_DURATION_SUPPORT,\n\t\t     ar->ab->wmi_ab.svc_map)) {\n\t\tdebugfs_create_file(\"current_ps_duration\", 0440, dir, sta,\n\t\t\t\t    &fops_current_ps_duration);\n\t\tdebugfs_create_file(\"total_ps_duration\", 0440, dir, sta,\n\t\t\t\t    &fops_total_ps_duration);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}