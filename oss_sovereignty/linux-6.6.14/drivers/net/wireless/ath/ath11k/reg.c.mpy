{
  "module_name": "reg.c",
  "hash_id": "8aff9a358af131b8954a544a5c5b5252182a1f5105c9f4b36c244fb9846b1c76",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath11k/reg.c",
  "human_readable_source": "\n \n#include <linux/rtnetlink.h>\n\n#include \"core.h\"\n#include \"debug.h\"\n\n \n#define ATH11K_2GHZ_CH01_11      REG_RULE(2412 - 10, 2462 + 10, 40, 0, 20, 0)\n#define ATH11K_5GHZ_5150_5350    REG_RULE(5150 - 10, 5350 + 10, 80, 0, 30,\\\n\t\t\t\t\t  NL80211_RRF_NO_IR)\n#define ATH11K_5GHZ_5725_5850    REG_RULE(5725 - 10, 5850 + 10, 80, 0, 30,\\\n\t\t\t\t\t  NL80211_RRF_NO_IR)\n\n#define ETSI_WEATHER_RADAR_BAND_LOW\t\t5590\n#define ETSI_WEATHER_RADAR_BAND_HIGH\t\t5650\n#define ETSI_WEATHER_RADAR_BAND_CAC_TIMEOUT\t600000\n\nstatic const struct ieee80211_regdomain ath11k_world_regd = {\n\t.n_reg_rules = 3,\n\t.alpha2 =  \"00\",\n\t.reg_rules = {\n\t\tATH11K_2GHZ_CH01_11,\n\t\tATH11K_5GHZ_5150_5350,\n\t\tATH11K_5GHZ_5725_5850,\n\t}\n};\n\nstatic bool ath11k_regdom_changes(struct ath11k *ar, char *alpha2)\n{\n\tconst struct ieee80211_regdomain *regd;\n\n\tregd = rcu_dereference_rtnl(ar->hw->wiphy->regd);\n\t \n\tif (!regd)\n\t\treturn true;\n\n\treturn memcmp(regd->alpha2, alpha2, 2) != 0;\n}\n\nstatic void\nath11k_reg_notifier(struct wiphy *wiphy, struct regulatory_request *request)\n{\n\tstruct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);\n\tstruct wmi_init_country_params init_country_param;\n\tstruct wmi_set_current_country_params set_current_param = {};\n\tstruct ath11k *ar = hw->priv;\n\tint ret;\n\n\tath11k_dbg(ar->ab, ATH11K_DBG_REG,\n\t\t   \"Regulatory Notification received for %s\\n\", wiphy_name(wiphy));\n\n\t \n\tif (!(request->initiator == NL80211_REGDOM_SET_BY_USER &&\n\t      request->user_reg_hint_type == NL80211_USER_REG_HINT_USER)) {\n\t\tath11k_warn(ar->ab, \"Unexpected Regulatory event for this wiphy\\n\");\n\t\treturn;\n\t}\n\n\tif (!IS_ENABLED(CONFIG_ATH_REG_DYNAMIC_USER_REG_HINTS)) {\n\t\tath11k_dbg(ar->ab, ATH11K_DBG_REG,\n\t\t\t   \"Country Setting is not allowed\\n\");\n\t\treturn;\n\t}\n\n\tif (!ath11k_regdom_changes(ar, request->alpha2)) {\n\t\tath11k_dbg(ar->ab, ATH11K_DBG_REG, \"Country is already set\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (ar->ab->hw_params.current_cc_support) {\n\t\tmemcpy(&set_current_param.alpha2, request->alpha2, 2);\n\t\tmemcpy(&ar->alpha2, &set_current_param.alpha2, 2);\n\t\tret = ath11k_wmi_send_set_current_country_cmd(ar, &set_current_param);\n\t\tif (ret)\n\t\t\tath11k_warn(ar->ab,\n\t\t\t\t    \"failed set current country code: %d\\n\", ret);\n\t} else {\n\t\tinit_country_param.flags = ALPHA_IS_SET;\n\t\tmemcpy(&init_country_param.cc_info.alpha2, request->alpha2, 2);\n\t\tinit_country_param.cc_info.alpha2[2] = 0;\n\n\t\tret = ath11k_wmi_send_init_country_cmd(ar, init_country_param);\n\t\tif (ret)\n\t\t\tath11k_warn(ar->ab,\n\t\t\t\t    \"INIT Country code set to fw failed : %d\\n\", ret);\n\t}\n\n\tath11k_mac_11d_scan_stop(ar);\n\tar->regdom_set_by_user = true;\n}\n\nint ath11k_reg_update_chan_list(struct ath11k *ar, bool wait)\n{\n\tstruct ieee80211_supported_band **bands;\n\tstruct scan_chan_list_params *params;\n\tstruct ieee80211_channel *channel;\n\tstruct ieee80211_hw *hw = ar->hw;\n\tstruct channel_param *ch;\n\tenum nl80211_band band;\n\tint num_channels = 0;\n\tint i, ret, left;\n\n\tif (wait && ar->state_11d != ATH11K_11D_IDLE) {\n\t\tleft = wait_for_completion_timeout(&ar->completed_11d_scan,\n\t\t\t\t\t\t   ATH11K_SCAN_TIMEOUT_HZ);\n\t\tif (!left) {\n\t\t\tath11k_dbg(ar->ab, ATH11K_DBG_REG,\n\t\t\t\t   \"failed to receive 11d scan complete: timed out\\n\");\n\t\t\tar->state_11d = ATH11K_11D_IDLE;\n\t\t}\n\t\tath11k_dbg(ar->ab, ATH11K_DBG_REG,\n\t\t\t   \"11d scan wait left time %d\\n\", left);\n\t}\n\n\tif (wait &&\n\t    (ar->scan.state == ATH11K_SCAN_STARTING ||\n\t    ar->scan.state == ATH11K_SCAN_RUNNING)) {\n\t\tleft = wait_for_completion_timeout(&ar->scan.completed,\n\t\t\t\t\t\t   ATH11K_SCAN_TIMEOUT_HZ);\n\t\tif (!left)\n\t\t\tath11k_dbg(ar->ab, ATH11K_DBG_REG,\n\t\t\t\t   \"failed to receive hw scan complete: timed out\\n\");\n\n\t\tath11k_dbg(ar->ab, ATH11K_DBG_REG,\n\t\t\t   \"hw scan wait left time %d\\n\", left);\n\t}\n\n\tif (ar->state == ATH11K_STATE_RESTARTING)\n\t\treturn 0;\n\n\tbands = hw->wiphy->bands;\n\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\tif (!bands[band])\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < bands[band]->n_channels; i++) {\n\t\t\tif (bands[band]->channels[i].flags &\n\t\t\t    IEEE80211_CHAN_DISABLED)\n\t\t\t\tcontinue;\n\n\t\t\tnum_channels++;\n\t\t}\n\t}\n\n\tif (WARN_ON(!num_channels))\n\t\treturn -EINVAL;\n\n\tparams = kzalloc(struct_size(params, ch_param, num_channels),\n\t\t\t GFP_KERNEL);\n\tif (!params)\n\t\treturn -ENOMEM;\n\n\tparams->pdev_id = ar->pdev->pdev_id;\n\tparams->nallchans = num_channels;\n\n\tch = params->ch_param;\n\n\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\tif (!bands[band])\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < bands[band]->n_channels; i++) {\n\t\t\tchannel = &bands[band]->channels[i];\n\n\t\t\tif (channel->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tch->allow_ht = true;\n\t\t\tch->allow_vht = true;\n\t\t\tch->allow_he = true;\n\n\t\t\tch->dfs_set =\n\t\t\t\t!!(channel->flags & IEEE80211_CHAN_RADAR);\n\t\t\tch->is_chan_passive = !!(channel->flags &\n\t\t\t\t\t\tIEEE80211_CHAN_NO_IR);\n\t\t\tch->is_chan_passive |= ch->dfs_set;\n\t\t\tch->mhz = channel->center_freq;\n\t\t\tch->cfreq1 = channel->center_freq;\n\t\t\tch->minpower = 0;\n\t\t\tch->maxpower = channel->max_power * 2;\n\t\t\tch->maxregpower = channel->max_reg_power * 2;\n\t\t\tch->antennamax = channel->max_antenna_gain * 2;\n\n\t\t\t \n\t\t\tif (channel->band == NL80211_BAND_2GHZ)\n\t\t\t\tch->phy_mode = MODE_11G;\n\t\t\telse\n\t\t\t\tch->phy_mode = MODE_11A;\n\n\t\t\tif (channel->band == NL80211_BAND_6GHZ &&\n\t\t\t    cfg80211_channel_is_psc(channel))\n\t\t\t\tch->psc_channel = true;\n\n\t\t\tath11k_dbg(ar->ab, ATH11K_DBG_WMI,\n\t\t\t\t   \"mac channel [%d/%d] freq %d maxpower %d regpower %d antenna %d mode %d\\n\",\n\t\t\t\t   i, params->nallchans,\n\t\t\t\t   ch->mhz, ch->maxpower, ch->maxregpower,\n\t\t\t\t   ch->antennamax, ch->phy_mode);\n\n\t\t\tch++;\n\t\t\t \n\t\t}\n\t}\n\n\tret = ath11k_wmi_send_scan_chan_list_cmd(ar, params);\n\tkfree(params);\n\n\treturn ret;\n}\n\nstatic void ath11k_copy_regd(struct ieee80211_regdomain *regd_orig,\n\t\t\t     struct ieee80211_regdomain *regd_copy)\n{\n\tu8 i;\n\n\t \n\tmemcpy(regd_copy, regd_orig, sizeof(*regd_orig));\n\n\tfor (i = 0; i < regd_orig->n_reg_rules; i++)\n\t\tmemcpy(&regd_copy->reg_rules[i], &regd_orig->reg_rules[i],\n\t\t       sizeof(struct ieee80211_reg_rule));\n}\n\nint ath11k_regd_update(struct ath11k *ar)\n{\n\tstruct ieee80211_regdomain *regd, *regd_copy = NULL;\n\tint ret, regd_len, pdev_id;\n\tstruct ath11k_base *ab;\n\n\tab = ar->ab;\n\tpdev_id = ar->pdev_idx;\n\n\tspin_lock_bh(&ab->base_lock);\n\n\t \n\tif (ab->new_regd[pdev_id]) {\n\t\tregd = ab->new_regd[pdev_id];\n\t} else {\n\t\t \n\t\tif (ab->default_regd[pdev_id]) {\n\t\t\tregd = ab->default_regd[pdev_id];\n\t\t} else {\n\t\t\tath11k_warn(ab,\n\t\t\t\t    \"failed to receive default regd during init\\n\");\n\t\t\tregd = (struct ieee80211_regdomain *)&ath11k_world_regd;\n\t\t}\n\t}\n\n\tif (!regd) {\n\t\tret = -EINVAL;\n\t\tspin_unlock_bh(&ab->base_lock);\n\t\tgoto err;\n\t}\n\n\tregd_len = sizeof(*regd) + (regd->n_reg_rules *\n\t\tsizeof(struct ieee80211_reg_rule));\n\n\tregd_copy = kzalloc(regd_len, GFP_ATOMIC);\n\tif (regd_copy)\n\t\tath11k_copy_regd(regd, regd_copy);\n\n\tspin_unlock_bh(&ab->base_lock);\n\n\tif (!regd_copy) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tret = regulatory_set_wiphy_regd(ar->hw->wiphy, regd_copy);\n\n\tkfree(regd_copy);\n\n\tif (ret)\n\t\tgoto err;\n\n\tif (ar->state == ATH11K_STATE_ON) {\n\t\tret = ath11k_reg_update_chan_list(ar, true);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tath11k_warn(ab, \"failed to perform regd update : %d\\n\", ret);\n\treturn ret;\n}\n\nstatic enum nl80211_dfs_regions\nath11k_map_fw_dfs_region(enum ath11k_dfs_region dfs_region)\n{\n\tswitch (dfs_region) {\n\tcase ATH11K_DFS_REG_FCC:\n\tcase ATH11K_DFS_REG_CN:\n\t\treturn NL80211_DFS_FCC;\n\tcase ATH11K_DFS_REG_ETSI:\n\tcase ATH11K_DFS_REG_KR:\n\t\treturn NL80211_DFS_ETSI;\n\tcase ATH11K_DFS_REG_MKK:\n\tcase ATH11K_DFS_REG_MKK_N:\n\t\treturn NL80211_DFS_JP;\n\tdefault:\n\t\treturn NL80211_DFS_UNSET;\n\t}\n}\n\nstatic u32 ath11k_map_fw_reg_flags(u16 reg_flags)\n{\n\tu32 flags = 0;\n\n\tif (reg_flags & REGULATORY_CHAN_NO_IR)\n\t\tflags = NL80211_RRF_NO_IR;\n\n\tif (reg_flags & REGULATORY_CHAN_RADAR)\n\t\tflags |= NL80211_RRF_DFS;\n\n\tif (reg_flags & REGULATORY_CHAN_NO_OFDM)\n\t\tflags |= NL80211_RRF_NO_OFDM;\n\n\tif (reg_flags & REGULATORY_CHAN_INDOOR_ONLY)\n\t\tflags |= NL80211_RRF_NO_OUTDOOR;\n\n\tif (reg_flags & REGULATORY_CHAN_NO_HT40)\n\t\tflags |= NL80211_RRF_NO_HT40;\n\n\tif (reg_flags & REGULATORY_CHAN_NO_80MHZ)\n\t\tflags |= NL80211_RRF_NO_80MHZ;\n\n\tif (reg_flags & REGULATORY_CHAN_NO_160MHZ)\n\t\tflags |= NL80211_RRF_NO_160MHZ;\n\n\treturn flags;\n}\n\nstatic bool\nath11k_reg_can_intersect(struct ieee80211_reg_rule *rule1,\n\t\t\t struct ieee80211_reg_rule *rule2)\n{\n\tu32 start_freq1, end_freq1;\n\tu32 start_freq2, end_freq2;\n\n\tstart_freq1 = rule1->freq_range.start_freq_khz;\n\tstart_freq2 = rule2->freq_range.start_freq_khz;\n\n\tend_freq1 = rule1->freq_range.end_freq_khz;\n\tend_freq2 = rule2->freq_range.end_freq_khz;\n\n\tif ((start_freq1 >= start_freq2 &&\n\t     start_freq1 < end_freq2) ||\n\t    (start_freq2 > start_freq1 &&\n\t     start_freq2 < end_freq1))\n\t\treturn true;\n\n\t \n\n\treturn false;\n}\n\nstatic void ath11k_reg_intersect_rules(struct ieee80211_reg_rule *rule1,\n\t\t\t\t       struct ieee80211_reg_rule *rule2,\n\t\t\t\t       struct ieee80211_reg_rule *new_rule)\n{\n\tu32 start_freq1, end_freq1;\n\tu32 start_freq2, end_freq2;\n\tu32 freq_diff, max_bw;\n\n\tstart_freq1 = rule1->freq_range.start_freq_khz;\n\tstart_freq2 = rule2->freq_range.start_freq_khz;\n\n\tend_freq1 = rule1->freq_range.end_freq_khz;\n\tend_freq2 = rule2->freq_range.end_freq_khz;\n\n\tnew_rule->freq_range.start_freq_khz = max_t(u32, start_freq1,\n\t\t\t\t\t\t    start_freq2);\n\tnew_rule->freq_range.end_freq_khz = min_t(u32, end_freq1, end_freq2);\n\n\tfreq_diff = new_rule->freq_range.end_freq_khz -\n\t\t\tnew_rule->freq_range.start_freq_khz;\n\tmax_bw = min_t(u32, rule1->freq_range.max_bandwidth_khz,\n\t\t       rule2->freq_range.max_bandwidth_khz);\n\tnew_rule->freq_range.max_bandwidth_khz = min_t(u32, max_bw, freq_diff);\n\n\tnew_rule->power_rule.max_antenna_gain =\n\t\tmin_t(u32, rule1->power_rule.max_antenna_gain,\n\t\t      rule2->power_rule.max_antenna_gain);\n\n\tnew_rule->power_rule.max_eirp = min_t(u32, rule1->power_rule.max_eirp,\n\t\t\t\t\t      rule2->power_rule.max_eirp);\n\n\t \n\tnew_rule->flags = rule1->flags | rule2->flags;\n\n\t \n\tnew_rule->dfs_cac_ms = max_t(u32, rule1->dfs_cac_ms,\n\t\t\t\t     rule2->dfs_cac_ms);\n}\n\nstatic struct ieee80211_regdomain *\nath11k_regd_intersect(struct ieee80211_regdomain *default_regd,\n\t\t      struct ieee80211_regdomain *curr_regd)\n{\n\tu8 num_old_regd_rules, num_curr_regd_rules, num_new_regd_rules;\n\tstruct ieee80211_reg_rule *old_rule, *curr_rule, *new_rule;\n\tstruct ieee80211_regdomain *new_regd = NULL;\n\tu8 i, j, k;\n\n\tnum_old_regd_rules = default_regd->n_reg_rules;\n\tnum_curr_regd_rules = curr_regd->n_reg_rules;\n\tnum_new_regd_rules = 0;\n\n\t \n\tfor (i = 0; i < num_old_regd_rules; i++) {\n\t\told_rule = default_regd->reg_rules + i;\n\t\tfor (j = 0; j < num_curr_regd_rules; j++) {\n\t\t\tcurr_rule = curr_regd->reg_rules + j;\n\n\t\t\tif (ath11k_reg_can_intersect(old_rule, curr_rule))\n\t\t\t\tnum_new_regd_rules++;\n\t\t}\n\t}\n\n\tif (!num_new_regd_rules)\n\t\treturn NULL;\n\n\tnew_regd = kzalloc(sizeof(*new_regd) + (num_new_regd_rules *\n\t\t\tsizeof(struct ieee80211_reg_rule)),\n\t\t\tGFP_ATOMIC);\n\n\tif (!new_regd)\n\t\treturn NULL;\n\n\t \n\tnew_regd->n_reg_rules = num_new_regd_rules;\n\tmemcpy(new_regd->alpha2, curr_regd->alpha2, sizeof(new_regd->alpha2));\n\tnew_regd->dfs_region = curr_regd->dfs_region;\n\tnew_rule = new_regd->reg_rules;\n\n\tfor (i = 0, k = 0; i < num_old_regd_rules; i++) {\n\t\told_rule = default_regd->reg_rules + i;\n\t\tfor (j = 0; j < num_curr_regd_rules; j++) {\n\t\t\tcurr_rule = curr_regd->reg_rules + j;\n\n\t\t\tif (ath11k_reg_can_intersect(old_rule, curr_rule))\n\t\t\t\tath11k_reg_intersect_rules(old_rule, curr_rule,\n\t\t\t\t\t\t\t   (new_rule + k++));\n\t\t}\n\t}\n\treturn new_regd;\n}\n\nstatic const char *\nath11k_reg_get_regdom_str(enum nl80211_dfs_regions dfs_region)\n{\n\tswitch (dfs_region) {\n\tcase NL80211_DFS_FCC:\n\t\treturn \"FCC\";\n\tcase NL80211_DFS_ETSI:\n\t\treturn \"ETSI\";\n\tcase NL80211_DFS_JP:\n\t\treturn \"JP\";\n\tdefault:\n\t\treturn \"UNSET\";\n\t}\n}\n\nstatic u16\nath11k_reg_adjust_bw(u16 start_freq, u16 end_freq, u16 max_bw)\n{\n\tu16 bw;\n\n\tif (end_freq <= start_freq)\n\t\treturn 0;\n\n\tbw = end_freq - start_freq;\n\tbw = min_t(u16, bw, max_bw);\n\n\tif (bw >= 80 && bw < 160)\n\t\tbw = 80;\n\telse if (bw >= 40 && bw < 80)\n\t\tbw = 40;\n\telse if (bw >= 20 && bw < 40)\n\t\tbw = 20;\n\telse\n\t\tbw = 0;\n\n\treturn bw;\n}\n\nstatic void\nath11k_reg_update_rule(struct ieee80211_reg_rule *reg_rule, u32 start_freq,\n\t\t       u32 end_freq, u32 bw, u32 ant_gain, u32 reg_pwr,\n\t\t       u32 reg_flags)\n{\n\treg_rule->freq_range.start_freq_khz = MHZ_TO_KHZ(start_freq);\n\treg_rule->freq_range.end_freq_khz = MHZ_TO_KHZ(end_freq);\n\treg_rule->freq_range.max_bandwidth_khz = MHZ_TO_KHZ(bw);\n\treg_rule->power_rule.max_antenna_gain = DBI_TO_MBI(ant_gain);\n\treg_rule->power_rule.max_eirp = DBM_TO_MBM(reg_pwr);\n\treg_rule->flags = reg_flags;\n}\n\nstatic void\nath11k_reg_update_weather_radar_band(struct ath11k_base *ab,\n\t\t\t\t     struct ieee80211_regdomain *regd,\n\t\t\t\t     struct cur_reg_rule *reg_rule,\n\t\t\t\t     u8 *rule_idx, u32 flags, u16 max_bw)\n{\n\tu32 start_freq;\n\tu32 end_freq;\n\tu16 bw;\n\tu8 i;\n\n\ti = *rule_idx;\n\n\t \n\ti--;\n\n\t \n\tbw = ath11k_reg_adjust_bw(reg_rule->start_freq,\n\t\t\t\t  ETSI_WEATHER_RADAR_BAND_LOW, max_bw);\n\tif (bw > 0) {\n\t\ti++;\n\n\t\tath11k_reg_update_rule(regd->reg_rules + i,\n\t\t\t\t       reg_rule->start_freq,\n\t\t\t\t       ETSI_WEATHER_RADAR_BAND_LOW, bw,\n\t\t\t\t       reg_rule->ant_gain, reg_rule->reg_power,\n\t\t\t\t       flags);\n\n\t\tath11k_dbg(ab, ATH11K_DBG_REG,\n\t\t\t   \"\\t%d. (%d - %d @ %d) (%d, %d) (%d ms) (FLAGS %d)\\n\",\n\t\t\t   i + 1, reg_rule->start_freq,\n\t\t\t   ETSI_WEATHER_RADAR_BAND_LOW, bw, reg_rule->ant_gain,\n\t\t\t   reg_rule->reg_power, regd->reg_rules[i].dfs_cac_ms,\n\t\t\t   flags);\n\t}\n\n\t \n\tstart_freq = max_t(u32, reg_rule->start_freq,\n\t\t\t   ETSI_WEATHER_RADAR_BAND_LOW);\n\tend_freq = min_t(u32, reg_rule->end_freq, ETSI_WEATHER_RADAR_BAND_HIGH);\n\n\tbw = ath11k_reg_adjust_bw(start_freq, end_freq, max_bw);\n\tif (bw > 0) {\n\t\ti++;\n\n\t\tath11k_reg_update_rule(regd->reg_rules + i, start_freq,\n\t\t\t\t       end_freq, bw, reg_rule->ant_gain,\n\t\t\t\t       reg_rule->reg_power, flags);\n\n\t\tregd->reg_rules[i].dfs_cac_ms = ETSI_WEATHER_RADAR_BAND_CAC_TIMEOUT;\n\n\t\tath11k_dbg(ab, ATH11K_DBG_REG,\n\t\t\t   \"\\t%d. (%d - %d @ %d) (%d, %d) (%d ms) (FLAGS %d)\\n\",\n\t\t\t   i + 1, start_freq, end_freq, bw,\n\t\t\t   reg_rule->ant_gain, reg_rule->reg_power,\n\t\t\t   regd->reg_rules[i].dfs_cac_ms, flags);\n\t}\n\n\t \n\tbw = ath11k_reg_adjust_bw(ETSI_WEATHER_RADAR_BAND_HIGH,\n\t\t\t\t  reg_rule->end_freq, max_bw);\n\tif (bw > 0) {\n\t\ti++;\n\n\t\tath11k_reg_update_rule(regd->reg_rules + i,\n\t\t\t\t       ETSI_WEATHER_RADAR_BAND_HIGH,\n\t\t\t\t       reg_rule->end_freq, bw,\n\t\t\t\t       reg_rule->ant_gain, reg_rule->reg_power,\n\t\t\t\t       flags);\n\n\t\tath11k_dbg(ab, ATH11K_DBG_REG,\n\t\t\t   \"\\t%d. (%d - %d @ %d) (%d, %d) (%d ms) (FLAGS %d)\\n\",\n\t\t\t   i + 1, ETSI_WEATHER_RADAR_BAND_HIGH,\n\t\t\t   reg_rule->end_freq, bw, reg_rule->ant_gain,\n\t\t\t   reg_rule->reg_power, regd->reg_rules[i].dfs_cac_ms,\n\t\t\t   flags);\n\t}\n\n\t*rule_idx = i;\n}\n\nstruct ieee80211_regdomain *\nath11k_reg_build_regd(struct ath11k_base *ab,\n\t\t      struct cur_regulatory_info *reg_info, bool intersect)\n{\n\tstruct ieee80211_regdomain *tmp_regd, *default_regd, *new_regd = NULL;\n\tstruct cur_reg_rule *reg_rule;\n\tu8 i = 0, j = 0, k = 0;\n\tu8 num_rules;\n\tu16 max_bw;\n\tu32 flags;\n\tchar alpha2[3];\n\n\tnum_rules = reg_info->num_5ghz_reg_rules + reg_info->num_2ghz_reg_rules;\n\n\t \n\tif (reg_info->is_ext_reg_event)\n\t\tnum_rules += reg_info->num_6ghz_rules_ap[WMI_REG_INDOOR_AP];\n\n\tif (!num_rules)\n\t\tgoto ret;\n\n\t \n\tif (reg_info->dfs_region == ATH11K_DFS_REG_ETSI)\n\t\tnum_rules += 2;\n\n\ttmp_regd =  kzalloc(sizeof(*tmp_regd) +\n\t\t\t(num_rules * sizeof(struct ieee80211_reg_rule)),\n\t\t\tGFP_ATOMIC);\n\tif (!tmp_regd)\n\t\tgoto ret;\n\n\tmemcpy(tmp_regd->alpha2, reg_info->alpha2, REG_ALPHA2_LEN + 1);\n\tmemcpy(alpha2, reg_info->alpha2, REG_ALPHA2_LEN + 1);\n\talpha2[2] = '\\0';\n\ttmp_regd->dfs_region = ath11k_map_fw_dfs_region(reg_info->dfs_region);\n\n\tath11k_dbg(ab, ATH11K_DBG_REG,\n\t\t   \"Country %s, CFG Regdomain %s FW Regdomain %d, num_reg_rules %d\\n\",\n\t\t   alpha2, ath11k_reg_get_regdom_str(tmp_regd->dfs_region),\n\t\t   reg_info->dfs_region, num_rules);\n\t \n\tfor (; i < num_rules; i++) {\n\t\tif (reg_info->num_2ghz_reg_rules &&\n\t\t    (i < reg_info->num_2ghz_reg_rules)) {\n\t\t\treg_rule = reg_info->reg_rules_2ghz_ptr + i;\n\t\t\tmax_bw = min_t(u16, reg_rule->max_bw,\n\t\t\t\t       reg_info->max_bw_2ghz);\n\t\t\tflags = 0;\n\t\t} else if (reg_info->num_5ghz_reg_rules &&\n\t\t\t   (j < reg_info->num_5ghz_reg_rules)) {\n\t\t\treg_rule = reg_info->reg_rules_5ghz_ptr + j++;\n\t\t\tmax_bw = min_t(u16, reg_rule->max_bw,\n\t\t\t\t       reg_info->max_bw_5ghz);\n\n\t\t\t \n\t\t\tflags = NL80211_RRF_AUTO_BW;\n\t\t} else if (reg_info->is_ext_reg_event &&\n\t\t\t   reg_info->num_6ghz_rules_ap[WMI_REG_INDOOR_AP] &&\n\t\t\t   (k < reg_info->num_6ghz_rules_ap[WMI_REG_INDOOR_AP])) {\n\t\t\treg_rule = reg_info->reg_rules_6ghz_ap_ptr[WMI_REG_INDOOR_AP] +\n\t\t\t\t   k++;\n\t\t\tmax_bw = min_t(u16, reg_rule->max_bw,\n\t\t\t\t       reg_info->max_bw_6ghz_ap[WMI_REG_INDOOR_AP]);\n\t\t\tflags = NL80211_RRF_AUTO_BW;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\n\t\tflags |= ath11k_map_fw_reg_flags(reg_rule->flags);\n\n\t\tath11k_reg_update_rule(tmp_regd->reg_rules + i,\n\t\t\t\t       reg_rule->start_freq,\n\t\t\t\t       reg_rule->end_freq, max_bw,\n\t\t\t\t       reg_rule->ant_gain, reg_rule->reg_power,\n\t\t\t\t       flags);\n\n\t\t \n\t\tif (flags & NL80211_RRF_DFS &&\n\t\t    reg_info->dfs_region == ATH11K_DFS_REG_ETSI &&\n\t\t    (reg_rule->end_freq > ETSI_WEATHER_RADAR_BAND_LOW &&\n\t\t    reg_rule->start_freq < ETSI_WEATHER_RADAR_BAND_HIGH)){\n\t\t\tath11k_reg_update_weather_radar_band(ab, tmp_regd,\n\t\t\t\t\t\t\t     reg_rule, &i,\n\t\t\t\t\t\t\t     flags, max_bw);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (reg_info->is_ext_reg_event) {\n\t\t\tath11k_dbg(ab, ATH11K_DBG_REG,\n\t\t\t\t   \"\\t%d. (%d - %d @ %d) (%d, %d) (%d ms) (FLAGS %d) (%d, %d)\\n\",\n\t\t\t\t   i + 1, reg_rule->start_freq, reg_rule->end_freq,\n\t\t\t\t   max_bw, reg_rule->ant_gain, reg_rule->reg_power,\n\t\t\t\t   tmp_regd->reg_rules[i].dfs_cac_ms, flags,\n\t\t\t\t   reg_rule->psd_flag, reg_rule->psd_eirp);\n\t\t} else {\n\t\t\tath11k_dbg(ab, ATH11K_DBG_REG,\n\t\t\t\t   \"\\t%d. (%d - %d @ %d) (%d, %d) (%d ms) (FLAGS %d)\\n\",\n\t\t\t\t   i + 1, reg_rule->start_freq, reg_rule->end_freq,\n\t\t\t\t   max_bw, reg_rule->ant_gain, reg_rule->reg_power,\n\t\t\t\t   tmp_regd->reg_rules[i].dfs_cac_ms,\n\t\t\t\t   flags);\n\t\t}\n\t}\n\n\ttmp_regd->n_reg_rules = i;\n\n\tif (intersect) {\n\t\tdefault_regd = ab->default_regd[reg_info->phy_id];\n\n\t\t \n\t\tnew_regd = ath11k_regd_intersect(default_regd, tmp_regd);\n\t\tkfree(tmp_regd);\n\t\tif (!new_regd) {\n\t\t\tath11k_warn(ab, \"Unable to create intersected regdomain\\n\");\n\t\t\tgoto ret;\n\t\t}\n\t} else {\n\t\tnew_regd = tmp_regd;\n\t}\n\nret:\n\treturn new_regd;\n}\n\nvoid ath11k_regd_update_work(struct work_struct *work)\n{\n\tstruct ath11k *ar = container_of(work, struct ath11k,\n\t\t\t\t\t regd_update_work);\n\tint ret;\n\n\tret = ath11k_regd_update(ar);\n\tif (ret) {\n\t\t \n\t\t \n\t}\n}\n\nvoid ath11k_reg_init(struct ath11k *ar)\n{\n\tar->hw->wiphy->regulatory_flags = REGULATORY_WIPHY_SELF_MANAGED;\n\tar->hw->wiphy->reg_notifier = ath11k_reg_notifier;\n}\n\nvoid ath11k_reg_free(struct ath11k_base *ab)\n{\n\tint i;\n\n\tfor (i = 0; i < ab->hw_params.max_radios; i++) {\n\t\tkfree(ab->default_regd[i]);\n\t\tkfree(ab->new_regd[i]);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}