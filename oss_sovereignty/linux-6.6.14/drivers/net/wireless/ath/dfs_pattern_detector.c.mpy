{
  "module_name": "dfs_pattern_detector.c",
  "hash_id": "2c680613d05e6993ddbc2dd71726c893068c1b411fb415b894b75ad393823f19",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/dfs_pattern_detector.c",
  "human_readable_source": " \n\n#include <linux/slab.h>\n#include <linux/export.h>\n\n#include \"dfs_pattern_detector.h\"\n#include \"dfs_pri_detector.h\"\n#include \"ath.h\"\n\n \nstruct radar_types {\n\tenum nl80211_dfs_regions region;\n\tu32 num_radar_types;\n\tconst struct radar_detector_specs *radar_types;\n};\n\n \n#define MIN_PPB_THRESH\t50\n#define PPB_THRESH_RATE(PPB, RATE) ((PPB * RATE + 100 - RATE) / 100)\n#define PPB_THRESH(PPB) PPB_THRESH_RATE(PPB, MIN_PPB_THRESH)\n#define PRF2PRI(PRF) ((1000000 + PRF / 2) / PRF)\n \n#define WIDTH_TOLERANCE 5\n#define WIDTH_LOWER(X) ((X*(100-WIDTH_TOLERANCE)+50)/100)\n#define WIDTH_UPPER(X) ((X*(100+WIDTH_TOLERANCE)+50)/100)\n\n#define ETSI_PATTERN(ID, WMIN, WMAX, PMIN, PMAX, PRF, PPB, CHIRP)\t\\\n{\t\t\t\t\t\t\t\t\\\n\tID, WIDTH_LOWER(WMIN), WIDTH_UPPER(WMAX),\t\t\\\n\t(PRF2PRI(PMAX) - PRI_TOLERANCE),\t\t\t\\\n\t(PRF2PRI(PMIN) * PRF + PRI_TOLERANCE), PRF, PPB * PRF,\t\\\n\tPPB_THRESH(PPB), PRI_TOLERANCE,\tCHIRP\t\t\t\\\n}\n\n \nstatic const struct radar_detector_specs etsi_radar_ref_types_v15[] = {\n\tETSI_PATTERN(0,  0,  1,  700,  700, 1, 18, false),\n\tETSI_PATTERN(1,  0,  5,  200, 1000, 1, 10, false),\n\tETSI_PATTERN(2,  0, 15,  200, 1600, 1, 15, false),\n\tETSI_PATTERN(3,  0, 15, 2300, 4000, 1, 25, false),\n\tETSI_PATTERN(4, 20, 30, 2000, 4000, 1, 20, false),\n\tETSI_PATTERN(5,  0,  2,  300,  400, 3, 10, false),\n\tETSI_PATTERN(6,  0,  2,  400, 1200, 3, 15, false),\n};\n\nstatic const struct radar_types etsi_radar_types_v15 = {\n\t.region\t\t\t= NL80211_DFS_ETSI,\n\t.num_radar_types\t= ARRAY_SIZE(etsi_radar_ref_types_v15),\n\t.radar_types\t\t= etsi_radar_ref_types_v15,\n};\n\n#define FCC_PATTERN(ID, WMIN, WMAX, PMIN, PMAX, PRF, PPB, CHIRP)\t\\\n{\t\t\t\t\t\t\t\t\\\n\tID, WIDTH_LOWER(WMIN), WIDTH_UPPER(WMAX),\t\t\\\n\tPMIN - PRI_TOLERANCE,\t\t\t\t\t\\\n\tPMAX * PRF + PRI_TOLERANCE, PRF, PPB * PRF,\t\t\\\n\tPPB_THRESH(PPB), PRI_TOLERANCE,\tCHIRP\t\t\t\\\n}\n\n \nstatic const struct radar_detector_specs fcc_radar_ref_types[] = {\n\tFCC_PATTERN(0, 0, 1, 1428, 1428, 1, 18, false),\n\tFCC_PATTERN(101, 0, 1, 518, 938, 1, 57, false),\n\tFCC_PATTERN(102, 0, 1, 938, 2000, 1, 27, false),\n\tFCC_PATTERN(103, 0, 1, 2000, 3066, 1, 18, false),\n\tFCC_PATTERN(2, 0, 5, 150, 230, 1, 23, false),\n\tFCC_PATTERN(3, 6, 10, 200, 500, 1, 16, false),\n\tFCC_PATTERN(4, 11, 20, 200, 500, 1, 12, false),\n\tFCC_PATTERN(5, 50, 100, 1000, 2000, 1, 1, true),\n\tFCC_PATTERN(6, 0, 1, 333, 333, 1, 9, false),\n};\n\nstatic const struct radar_types fcc_radar_types = {\n\t.region\t\t\t= NL80211_DFS_FCC,\n\t.num_radar_types\t= ARRAY_SIZE(fcc_radar_ref_types),\n\t.radar_types\t\t= fcc_radar_ref_types,\n};\n\n#define JP_PATTERN(ID, WMIN, WMAX, PMIN, PMAX, PRF, PPB, RATE, CHIRP)\t\\\n{\t\t\t\t\t\t\t\t\\\n\tID, WIDTH_LOWER(WMIN), WIDTH_UPPER(WMAX),\t\t\\\n\tPMIN - PRI_TOLERANCE,\t\t\t\t\t\\\n\tPMAX * PRF + PRI_TOLERANCE, PRF, PPB * PRF,\t\t\\\n\tPPB_THRESH_RATE(PPB, RATE), PRI_TOLERANCE, CHIRP\t\\\n}\nstatic const struct radar_detector_specs jp_radar_ref_types[] = {\n\tJP_PATTERN(0, 0, 1, 1428, 1428, 1, 18, 29, false),\n\tJP_PATTERN(1, 2, 3, 3846, 3846, 1, 18, 29, false),\n\tJP_PATTERN(2, 0, 1, 1388, 1388, 1, 18, 50, false),\n\tJP_PATTERN(3, 0, 4, 4000, 4000, 1, 18, 50, false),\n\tJP_PATTERN(4, 0, 5, 150, 230, 1, 23, 50, false),\n\tJP_PATTERN(5, 6, 10, 200, 500, 1, 16, 50, false),\n\tJP_PATTERN(6, 11, 20, 200, 500, 1, 12, 50, false),\n\tJP_PATTERN(7, 50, 100, 1000, 2000, 1, 3, 50, true),\n\tJP_PATTERN(5, 0, 1, 333, 333, 1, 9, 50, false),\n};\n\nstatic const struct radar_types jp_radar_types = {\n\t.region\t\t\t= NL80211_DFS_JP,\n\t.num_radar_types\t= ARRAY_SIZE(jp_radar_ref_types),\n\t.radar_types\t\t= jp_radar_ref_types,\n};\n\nstatic const struct radar_types *dfs_domains[] = {\n\t&etsi_radar_types_v15,\n\t&fcc_radar_types,\n\t&jp_radar_types,\n};\n\n \nstatic const struct radar_types *\nget_dfs_domain_radar_types(enum nl80211_dfs_regions region)\n{\n\tu32 i;\n\tfor (i = 0; i < ARRAY_SIZE(dfs_domains); i++) {\n\t\tif (dfs_domains[i]->region == region)\n\t\t\treturn dfs_domains[i];\n\t}\n\treturn NULL;\n}\n\n \nstruct channel_detector {\n\tstruct list_head head;\n\tu16 freq;\n\tstruct pri_detector **detectors;\n};\n\n \nstatic void channel_detector_reset(struct dfs_pattern_detector *dpd,\n\t\t\t\t   struct channel_detector *cd)\n{\n\tu32 i;\n\tif (cd == NULL)\n\t\treturn;\n\tfor (i = 0; i < dpd->num_radar_types; i++)\n\t\tcd->detectors[i]->reset(cd->detectors[i], dpd->last_pulse_ts);\n}\n\n \nstatic void channel_detector_exit(struct dfs_pattern_detector *dpd,\n\t\t\t\t  struct channel_detector *cd)\n{\n\tu32 i;\n\tif (cd == NULL)\n\t\treturn;\n\tlist_del(&cd->head);\n\tif (cd->detectors) {\n\t\tfor (i = 0; i < dpd->num_radar_types; i++) {\n\t\t\tstruct pri_detector *de = cd->detectors[i];\n\t\t\tif (de != NULL)\n\t\t\t\tde->exit(de);\n\t\t}\n\t}\n\tkfree(cd->detectors);\n\tkfree(cd);\n}\n\nstatic struct channel_detector *\nchannel_detector_create(struct dfs_pattern_detector *dpd, u16 freq)\n{\n\tu32 i;\n\tstruct channel_detector *cd;\n\n\tcd = kmalloc(sizeof(*cd), GFP_ATOMIC);\n\tif (cd == NULL)\n\t\tgoto fail;\n\n\tINIT_LIST_HEAD(&cd->head);\n\tcd->freq = freq;\n\tcd->detectors = kcalloc(dpd->num_radar_types,\n\t\t\t\t      sizeof(*cd->detectors), GFP_ATOMIC);\n\tif (cd->detectors == NULL)\n\t\tgoto fail;\n\n\tfor (i = 0; i < dpd->num_radar_types; i++) {\n\t\tconst struct radar_detector_specs *rs = &dpd->radar_spec[i];\n\t\tstruct pri_detector *de = pri_detector_init(rs);\n\t\tif (de == NULL)\n\t\t\tgoto fail;\n\t\tcd->detectors[i] = de;\n\t}\n\tlist_add(&cd->head, &dpd->channel_detectors);\n\treturn cd;\n\nfail:\n\tath_dbg(dpd->common, DFS,\n\t\t\"failed to allocate channel_detector for freq=%d\\n\", freq);\n\tchannel_detector_exit(dpd, cd);\n\treturn NULL;\n}\n\n \nstatic struct channel_detector *\nchannel_detector_get(struct dfs_pattern_detector *dpd, u16 freq)\n{\n\tstruct channel_detector *cd;\n\tlist_for_each_entry(cd, &dpd->channel_detectors, head) {\n\t\tif (cd->freq == freq)\n\t\t\treturn cd;\n\t}\n\treturn channel_detector_create(dpd, freq);\n}\n\n \n\n \nstatic void dpd_reset(struct dfs_pattern_detector *dpd)\n{\n\tstruct channel_detector *cd;\n\tlist_for_each_entry(cd, &dpd->channel_detectors, head)\n\t\tchannel_detector_reset(dpd, cd);\n\n}\nstatic void dpd_exit(struct dfs_pattern_detector *dpd)\n{\n\tstruct channel_detector *cd, *cd0;\n\tlist_for_each_entry_safe(cd, cd0, &dpd->channel_detectors, head)\n\t\tchannel_detector_exit(dpd, cd);\n\tkfree(dpd);\n}\n\nstatic bool\ndpd_add_pulse(struct dfs_pattern_detector *dpd, struct pulse_event *event,\n\t      struct radar_detector_specs *rs)\n{\n\tu32 i;\n\tstruct channel_detector *cd;\n\n\t \n\tif (dpd->region == NL80211_DFS_UNSET)\n\t\treturn true;\n\n\tcd = channel_detector_get(dpd, event->freq);\n\tif (cd == NULL)\n\t\treturn false;\n\n\t \n\tif (event->ts < dpd->last_pulse_ts)\n\t\tdpd_reset(dpd);\n\tdpd->last_pulse_ts = event->ts;\n\n\t \n\tfor (i = 0; i < dpd->num_radar_types; i++) {\n\t\tstruct pri_detector *pd = cd->detectors[i];\n\t\tstruct pri_sequence *ps = pd->add_pulse(pd, event);\n\t\tif (ps != NULL) {\n\t\t\tif (rs != NULL)\n\t\t\t\tmemcpy(rs, pd->rs, sizeof(*rs));\n\t\t\tath_dbg(dpd->common, DFS,\n\t\t\t\t\"DFS: radar found on freq=%d: id=%d, pri=%d, \"\n\t\t\t\t\"count=%d, count_false=%d\\n\",\n\t\t\t\tevent->freq, pd->rs->type_id,\n\t\t\t\tps->pri, ps->count, ps->count_falses);\n\t\t\tpd->reset(pd, dpd->last_pulse_ts);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic struct ath_dfs_pool_stats\ndpd_get_stats(struct dfs_pattern_detector *dpd)\n{\n\treturn global_dfs_pool_stats;\n}\n\nstatic bool dpd_set_domain(struct dfs_pattern_detector *dpd,\n\t\t\t   enum nl80211_dfs_regions region)\n{\n\tconst struct radar_types *rt;\n\tstruct channel_detector *cd, *cd0;\n\n\tif (dpd->region == region)\n\t\treturn true;\n\n\tdpd->region = NL80211_DFS_UNSET;\n\n\trt = get_dfs_domain_radar_types(region);\n\tif (rt == NULL)\n\t\treturn false;\n\n\t \n\tlist_for_each_entry_safe(cd, cd0, &dpd->channel_detectors, head)\n\t\tchannel_detector_exit(dpd, cd);\n\tdpd->radar_spec = rt->radar_types;\n\tdpd->num_radar_types = rt->num_radar_types;\n\n\tdpd->region = region;\n\treturn true;\n}\n\nstatic const struct dfs_pattern_detector default_dpd = {\n\t.exit\t\t= dpd_exit,\n\t.set_dfs_domain\t= dpd_set_domain,\n\t.add_pulse\t= dpd_add_pulse,\n\t.get_stats\t= dpd_get_stats,\n\t.region\t\t= NL80211_DFS_UNSET,\n};\n\nstruct dfs_pattern_detector *\ndfs_pattern_detector_init(struct ath_common *common,\n\t\t\t  enum nl80211_dfs_regions region)\n{\n\tstruct dfs_pattern_detector *dpd;\n\n\tif (!IS_ENABLED(CONFIG_CFG80211_CERTIFICATION_ONUS))\n\t\treturn NULL;\n\n\tdpd = kmalloc(sizeof(*dpd), GFP_KERNEL);\n\tif (dpd == NULL)\n\t\treturn NULL;\n\n\t*dpd = default_dpd;\n\tINIT_LIST_HEAD(&dpd->channel_detectors);\n\n\tdpd->common = common;\n\tif (dpd->set_dfs_domain(dpd, region))\n\t\treturn dpd;\n\n\tath_dbg(common, DFS,\"Could not set DFS domain to %d\", region);\n\tkfree(dpd);\n\treturn NULL;\n}\nEXPORT_SYMBOL(dfs_pattern_detector_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}