{
  "module_name": "ar5523.c",
  "hash_id": "f4d6c9dba2e7f38078dcb60460688d11431586b66dfc653b43f9e2f9f45274da",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ar5523/ar5523.c",
  "human_readable_source": " \n\n \n#include <linux/compiler.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/list.h>\n#include <linux/completion.h>\n#include <linux/firmware.h>\n#include <linux/skbuff.h>\n#include <linux/usb.h>\n#include <net/mac80211.h>\n\n#include \"ar5523.h\"\n#include \"ar5523_hw.h\"\n\n \n\nstatic int ar5523_submit_rx_cmd(struct ar5523 *ar);\nstatic void ar5523_data_tx_pkt_put(struct ar5523 *ar);\n\nstatic void ar5523_read_reply(struct ar5523 *ar, struct ar5523_cmd_hdr *hdr,\n\t\t\t      struct ar5523_tx_cmd *cmd)\n{\n\tint dlen, olen;\n\t__be32 *rp;\n\n\tdlen = be32_to_cpu(hdr->len) - sizeof(*hdr);\n\n\tif (dlen < 0) {\n\t\tWARN_ON(1);\n\t\tgoto out;\n\t}\n\n\tar5523_dbg(ar, \"Code = %d len = %d\\n\", be32_to_cpu(hdr->code) & 0xff,\n\t\t   dlen);\n\n\trp = (__be32 *)(hdr + 1);\n\tif (dlen >= sizeof(u32)) {\n\t\tolen = be32_to_cpu(rp[0]);\n\t\tdlen -= sizeof(u32);\n\t\tif (olen == 0) {\n\t\t\t \n\t\t\tolen = sizeof(u32);\n\t\t}\n\t} else\n\t\tolen = 0;\n\n\tif (cmd->odata) {\n\t\tif (cmd->olen < olen) {\n\t\t\tar5523_err(ar, \"olen too small %d < %d\\n\",\n\t\t\t\t   cmd->olen, olen);\n\t\t\tcmd->olen = 0;\n\t\t\tcmd->res = -EOVERFLOW;\n\t\t} else {\n\t\t\tcmd->olen = olen;\n\t\t\tmemcpy(cmd->odata, &rp[1], olen);\n\t\t\tcmd->res = 0;\n\t\t}\n\t}\n\nout:\n\tcomplete(&cmd->done);\n}\n\nstatic void ar5523_cmd_rx_cb(struct urb *urb)\n{\n\tstruct ar5523 *ar = urb->context;\n\tstruct ar5523_tx_cmd *cmd = &ar->tx_cmd;\n\tstruct ar5523_cmd_hdr *hdr = ar->rx_cmd_buf;\n\tint dlen;\n\tu32 code, hdrlen;\n\n\tif (urb->status) {\n\t\tif (urb->status != -ESHUTDOWN)\n\t\t\tar5523_err(ar, \"RX USB error %d.\\n\", urb->status);\n\t\tgoto skip;\n\t}\n\n\tif (urb->actual_length < sizeof(struct ar5523_cmd_hdr)) {\n\t\tar5523_err(ar, \"RX USB too short.\\n\");\n\t\tgoto skip;\n\t}\n\n\tar5523_dbg(ar, \"%s code %02x priv %d\\n\", __func__,\n\t\t   be32_to_cpu(hdr->code) & 0xff, hdr->priv);\n\n\tcode = be32_to_cpu(hdr->code);\n\thdrlen = be32_to_cpu(hdr->len);\n\n\tswitch (code & 0xff) {\n\tdefault:\n\t\t \n\t\tif (hdr->priv != AR5523_CMD_ID) {\n\t\t\tar5523_err(ar, \"Unexpected command id: %02x\\n\",\n\t\t\t\t   code & 0xff);\n\t\t\tgoto skip;\n\t\t}\n\t\tar5523_read_reply(ar, hdr, cmd);\n\t\tbreak;\n\n\tcase WDCMSG_DEVICE_AVAIL:\n\t\tar5523_dbg(ar, \"WDCMSG_DEVICE_AVAIL\\n\");\n\t\tcmd->res = 0;\n\t\tcmd->olen = 0;\n\t\tcomplete(&cmd->done);\n\t\tbreak;\n\n\tcase WDCMSG_SEND_COMPLETE:\n\t\tar5523_dbg(ar, \"WDCMSG_SEND_COMPLETE: %d pending\\n\",\n\t\t\tatomic_read(&ar->tx_nr_pending));\n\t\tif (!test_bit(AR5523_HW_UP, &ar->flags))\n\t\t\tar5523_dbg(ar, \"Unexpected WDCMSG_SEND_COMPLETE\\n\");\n\t\telse {\n\t\t\tmod_timer(&ar->tx_wd_timer,\n\t\t\t\t  jiffies + AR5523_TX_WD_TIMEOUT);\n\t\t\tar5523_data_tx_pkt_put(ar);\n\n\t\t}\n\t\tbreak;\n\n\tcase WDCMSG_TARGET_START:\n\t\t \n\t\tdlen = hdrlen - sizeof(*hdr);\n\t\tif (dlen != (int)sizeof(u32)) {\n\t\t\tar5523_err(ar, \"Invalid reply to WDCMSG_TARGET_START\");\n\t\t\treturn;\n\t\t}\n\t\tif (!cmd->odata) {\n\t\t\tar5523_err(ar, \"Unexpected WDCMSG_TARGET_START reply\");\n\t\t\treturn;\n\t\t}\n\t\tmemcpy(cmd->odata, hdr + 1, sizeof(u32));\n\t\tcmd->olen = sizeof(u32);\n\t\tcmd->res = 0;\n\t\tcomplete(&cmd->done);\n\t\tbreak;\n\n\tcase WDCMSG_STATS_UPDATE:\n\t\tar5523_dbg(ar, \"WDCMSG_STATS_UPDATE\\n\");\n\t\tbreak;\n\t}\n\nskip:\n\tar5523_submit_rx_cmd(ar);\n}\n\nstatic int ar5523_alloc_rx_cmd(struct ar5523 *ar)\n{\n\tar->rx_cmd_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!ar->rx_cmd_urb)\n\t\treturn -ENOMEM;\n\n\tar->rx_cmd_buf = usb_alloc_coherent(ar->dev, AR5523_MAX_RXCMDSZ,\n\t\t\t\t\t    GFP_KERNEL,\n\t\t\t\t\t    &ar->rx_cmd_urb->transfer_dma);\n\tif (!ar->rx_cmd_buf) {\n\t\tusb_free_urb(ar->rx_cmd_urb);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nstatic void ar5523_cancel_rx_cmd(struct ar5523 *ar)\n{\n\tusb_kill_urb(ar->rx_cmd_urb);\n}\n\nstatic void ar5523_free_rx_cmd(struct ar5523 *ar)\n{\n\tusb_free_coherent(ar->dev, AR5523_MAX_RXCMDSZ,\n\t\t\t  ar->rx_cmd_buf, ar->rx_cmd_urb->transfer_dma);\n\tusb_free_urb(ar->rx_cmd_urb);\n}\n\nstatic int ar5523_submit_rx_cmd(struct ar5523 *ar)\n{\n\tint error;\n\n\tusb_fill_bulk_urb(ar->rx_cmd_urb, ar->dev,\n\t\t\t  ar5523_cmd_rx_pipe(ar->dev), ar->rx_cmd_buf,\n\t\t\t  AR5523_MAX_RXCMDSZ, ar5523_cmd_rx_cb, ar);\n\tar->rx_cmd_urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\terror = usb_submit_urb(ar->rx_cmd_urb, GFP_ATOMIC);\n\tif (error) {\n\t\tif (error != -ENODEV)\n\t\t\tar5523_err(ar, \"error %d when submitting rx urb\\n\",\n\t\t\t\t   error);\n\t\treturn error;\n\t}\n\treturn 0;\n}\n\n \nstatic void ar5523_cmd_tx_cb(struct urb *urb)\n{\n\tstruct ar5523_tx_cmd *cmd = urb->context;\n\tstruct ar5523 *ar = cmd->ar;\n\n\tif (urb->status) {\n\t\tar5523_err(ar, \"Failed to TX command. Status = %d\\n\",\n\t\t\t   urb->status);\n\t\tcmd->res = urb->status;\n\t\tcomplete(&cmd->done);\n\t\treturn;\n\t}\n\n\tif (!(cmd->flags & AR5523_CMD_FLAG_READ)) {\n\t\tcmd->res = 0;\n\t\tcomplete(&cmd->done);\n\t}\n}\n\nstatic void ar5523_cancel_tx_cmd(struct ar5523 *ar)\n{\n\tusb_kill_urb(ar->tx_cmd.urb_tx);\n}\n\nstatic int ar5523_cmd(struct ar5523 *ar, u32 code, const void *idata,\n\t\t      int ilen, void *odata, int olen, int flags)\n{\n\tstruct ar5523_cmd_hdr *hdr;\n\tstruct ar5523_tx_cmd *cmd = &ar->tx_cmd;\n\tint xferlen, error;\n\n\t \n\txferlen = (sizeof(struct ar5523_cmd_hdr) + ilen + 3) & ~3;\n\n\thdr = (struct ar5523_cmd_hdr *)cmd->buf_tx;\n\tmemset(hdr, 0, sizeof(struct ar5523_cmd_hdr));\n\thdr->len  = cpu_to_be32(xferlen);\n\thdr->code = cpu_to_be32(code);\n\thdr->priv = AR5523_CMD_ID;\n\n\tif (flags & AR5523_CMD_FLAG_MAGIC)\n\t\thdr->magic = cpu_to_be32(1 << 24);\n\tif (ilen)\n\t\tmemcpy(hdr + 1, idata, ilen);\n\n\tcmd->odata = odata;\n\tcmd->olen = olen;\n\tcmd->flags = flags;\n\n\tar5523_dbg(ar, \"do cmd %02x\\n\", code);\n\n\tusb_fill_bulk_urb(cmd->urb_tx, ar->dev, ar5523_cmd_tx_pipe(ar->dev),\n\t\t\t  cmd->buf_tx, xferlen, ar5523_cmd_tx_cb, cmd);\n\tcmd->urb_tx->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\terror = usb_submit_urb(cmd->urb_tx, GFP_KERNEL);\n\tif (error) {\n\t\tar5523_err(ar, \"could not send command 0x%x, error=%d\\n\",\n\t\t\t   code, error);\n\t\treturn error;\n\t}\n\n\tif (!wait_for_completion_timeout(&cmd->done, 2 * HZ)) {\n\t\tar5523_cancel_tx_cmd(ar);\n\t\tcmd->odata = NULL;\n\t\tar5523_err(ar, \"timeout waiting for command %02x reply\\n\",\n\t\t\t   code);\n\t\tcmd->res = -ETIMEDOUT;\n\t}\n\treturn cmd->res;\n}\n\nstatic int ar5523_cmd_write(struct ar5523 *ar, u32 code, const void *data,\n\t\t\t    int len, int flags)\n{\n\tflags &= ~AR5523_CMD_FLAG_READ;\n\treturn ar5523_cmd(ar, code, data, len, NULL, 0, flags);\n}\n\nstatic int ar5523_cmd_read(struct ar5523 *ar, u32 code, const void *idata,\n\t\t\t   int ilen, void *odata, int olen, int flags)\n{\n\tflags |= AR5523_CMD_FLAG_READ;\n\treturn ar5523_cmd(ar, code, idata, ilen, odata, olen, flags);\n}\n\nstatic int ar5523_config(struct ar5523 *ar, u32 reg, u32 val)\n{\n\tstruct ar5523_write_mac write;\n\tint error;\n\n\twrite.reg = cpu_to_be32(reg);\n\twrite.len = cpu_to_be32(0);\t \n\t*(__be32 *)write.data = cpu_to_be32(val);\n\n\terror = ar5523_cmd_write(ar, WDCMSG_TARGET_SET_CONFIG, &write,\n\t\t\t\t 3 * sizeof(u32), 0);\n\tif (error != 0)\n\t\tar5523_err(ar, \"could not write register 0x%02x\\n\", reg);\n\treturn error;\n}\n\nstatic int ar5523_config_multi(struct ar5523 *ar, u32 reg, const void *data,\n\t\t\t       int len)\n{\n\tstruct ar5523_write_mac write;\n\tint error;\n\n\twrite.reg = cpu_to_be32(reg);\n\twrite.len = cpu_to_be32(len);\n\tmemcpy(write.data, data, len);\n\n\t \n\terror = ar5523_cmd_write(ar, WDCMSG_TARGET_SET_CONFIG, &write,\n\t    (len == 0) ? sizeof(u32) : 2 * sizeof(u32) + len, 0);\n\tif (error != 0)\n\t\tar5523_err(ar, \"could not write %d bytes to register 0x%02x\\n\",\n\t\t\t   len, reg);\n\treturn error;\n}\n\nstatic int ar5523_get_status(struct ar5523 *ar, u32 which, void *odata,\n\t\t\t     int olen)\n{\n\tint error;\n\t__be32 which_be;\n\n\twhich_be = cpu_to_be32(which);\n\terror = ar5523_cmd_read(ar, WDCMSG_TARGET_GET_STATUS,\n\t    &which_be, sizeof(which_be), odata, olen, AR5523_CMD_FLAG_MAGIC);\n\tif (error != 0)\n\t\tar5523_err(ar, \"could not read EEPROM offset 0x%02x\\n\", which);\n\treturn error;\n}\n\nstatic int ar5523_get_capability(struct ar5523 *ar, u32 cap, u32 *val)\n{\n\tint error;\n\t__be32 cap_be, val_be;\n\n\tcap_be = cpu_to_be32(cap);\n\terror = ar5523_cmd_read(ar, WDCMSG_TARGET_GET_CAPABILITY, &cap_be,\n\t\t\t\tsizeof(cap_be), &val_be, sizeof(__be32),\n\t\t\t\tAR5523_CMD_FLAG_MAGIC);\n\tif (error != 0) {\n\t\tar5523_err(ar, \"could not read capability %u\\n\", cap);\n\t\treturn error;\n\t}\n\t*val = be32_to_cpu(val_be);\n\treturn error;\n}\n\nstatic int ar5523_get_devcap(struct ar5523 *ar)\n{\n#define\tGETCAP(x) do {\t\t\t\t\\\n\terror = ar5523_get_capability(ar, x, &cap);\t\t\\\n\tif (error != 0)\t\t\t\t\t\\\n\t\treturn error;\t\t\t\t\\\n\tar5523_info(ar, \"Cap: \"\t\t\t\\\n\t    \"%s=0x%08x\\n\", #x, cap);\t\\\n} while (0)\n\tint error;\n\tu32 cap;\n\n\t \n\tGETCAP(CAP_TARGET_VERSION);\n\tGETCAP(CAP_TARGET_REVISION);\n\tGETCAP(CAP_MAC_VERSION);\n\tGETCAP(CAP_MAC_REVISION);\n\tGETCAP(CAP_PHY_REVISION);\n\tGETCAP(CAP_ANALOG_5GHz_REVISION);\n\tGETCAP(CAP_ANALOG_2GHz_REVISION);\n\n\tGETCAP(CAP_REG_DOMAIN);\n\tGETCAP(CAP_REG_CAP_BITS);\n\tGETCAP(CAP_WIRELESS_MODES);\n\tGETCAP(CAP_CHAN_SPREAD_SUPPORT);\n\tGETCAP(CAP_COMPRESS_SUPPORT);\n\tGETCAP(CAP_BURST_SUPPORT);\n\tGETCAP(CAP_FAST_FRAMES_SUPPORT);\n\tGETCAP(CAP_CHAP_TUNING_SUPPORT);\n\tGETCAP(CAP_TURBOG_SUPPORT);\n\tGETCAP(CAP_TURBO_PRIME_SUPPORT);\n\tGETCAP(CAP_DEVICE_TYPE);\n\tGETCAP(CAP_WME_SUPPORT);\n\tGETCAP(CAP_TOTAL_QUEUES);\n\tGETCAP(CAP_CONNECTION_ID_MAX);\n\n\tGETCAP(CAP_LOW_5GHZ_CHAN);\n\tGETCAP(CAP_HIGH_5GHZ_CHAN);\n\tGETCAP(CAP_LOW_2GHZ_CHAN);\n\tGETCAP(CAP_HIGH_2GHZ_CHAN);\n\tGETCAP(CAP_TWICE_ANTENNAGAIN_5G);\n\tGETCAP(CAP_TWICE_ANTENNAGAIN_2G);\n\n\tGETCAP(CAP_CIPHER_AES_CCM);\n\tGETCAP(CAP_CIPHER_TKIP);\n\tGETCAP(CAP_MIC_TKIP);\n\treturn 0;\n}\n\nstatic int ar5523_set_ledsteady(struct ar5523 *ar, int lednum, int ledmode)\n{\n\tstruct ar5523_cmd_ledsteady led;\n\n\tled.lednum = cpu_to_be32(lednum);\n\tled.ledmode = cpu_to_be32(ledmode);\n\n\tar5523_dbg(ar, \"set %s led %s (steady)\\n\",\n\t\t   (lednum == UATH_LED_LINK) ? \"link\" : \"activity\",\n\t\t   ledmode ? \"on\" : \"off\");\n\treturn ar5523_cmd_write(ar, WDCMSG_SET_LED_STEADY, &led, sizeof(led),\n\t\t\t\t 0);\n}\n\nstatic int ar5523_set_rxfilter(struct ar5523 *ar, u32 bits, u32 op)\n{\n\tstruct ar5523_cmd_rx_filter rxfilter;\n\n\trxfilter.bits = cpu_to_be32(bits);\n\trxfilter.op = cpu_to_be32(op);\n\n\tar5523_dbg(ar, \"setting Rx filter=0x%x flags=0x%x\\n\", bits, op);\n\treturn ar5523_cmd_write(ar, WDCMSG_RX_FILTER, &rxfilter,\n\t\t\t\t sizeof(rxfilter), 0);\n}\n\nstatic int ar5523_reset_tx_queues(struct ar5523 *ar)\n{\n\t__be32 qid = cpu_to_be32(0);\n\n\tar5523_dbg(ar, \"resetting Tx queue\\n\");\n\treturn ar5523_cmd_write(ar, WDCMSG_RELEASE_TX_QUEUE,\n\t\t\t\t &qid, sizeof(qid), 0);\n}\n\nstatic int ar5523_set_chan(struct ar5523 *ar)\n{\n\tstruct ieee80211_conf *conf = &ar->hw->conf;\n\n\tstruct ar5523_cmd_reset reset;\n\n\tmemset(&reset, 0, sizeof(reset));\n\treset.flags |= cpu_to_be32(UATH_CHAN_2GHZ);\n\treset.flags |= cpu_to_be32(UATH_CHAN_OFDM);\n\treset.freq = cpu_to_be32(conf->chandef.chan->center_freq);\n\treset.maxrdpower = cpu_to_be32(50);\t \n\treset.channelchange = cpu_to_be32(1);\n\treset.keeprccontent = cpu_to_be32(0);\n\n\tar5523_dbg(ar, \"set chan flags 0x%x freq %d\\n\",\n\t\t   be32_to_cpu(reset.flags),\n\t\t   conf->chandef.chan->center_freq);\n\treturn ar5523_cmd_write(ar, WDCMSG_RESET, &reset, sizeof(reset), 0);\n}\n\nstatic int ar5523_queue_init(struct ar5523 *ar)\n{\n\tstruct ar5523_cmd_txq_setup qinfo;\n\n\tar5523_dbg(ar, \"setting up Tx queue\\n\");\n\tqinfo.qid\t     = cpu_to_be32(0);\n\tqinfo.len\t     = cpu_to_be32(sizeof(qinfo.attr));\n\tqinfo.attr.priority  = cpu_to_be32(0);\t \n\tqinfo.attr.aifs\t     = cpu_to_be32(3);\n\tqinfo.attr.logcwmin  = cpu_to_be32(4);\n\tqinfo.attr.logcwmax  = cpu_to_be32(10);\n\tqinfo.attr.bursttime = cpu_to_be32(0);\n\tqinfo.attr.mode\t     = cpu_to_be32(0);\n\tqinfo.attr.qflags    = cpu_to_be32(1);\t \n\treturn ar5523_cmd_write(ar, WDCMSG_SETUP_TX_QUEUE, &qinfo,\n\t\t\t\t sizeof(qinfo), 0);\n}\n\nstatic int ar5523_switch_chan(struct ar5523 *ar)\n{\n\tint error;\n\n\terror = ar5523_set_chan(ar);\n\tif (error) {\n\t\tar5523_err(ar, \"could not set chan, error %d\\n\", error);\n\t\tgoto out_err;\n\t}\n\n\t \n\terror = ar5523_reset_tx_queues(ar);\n\tif (error) {\n\t\tar5523_err(ar, \"could not reset Tx queues, error %d\\n\",\n\t\t\t   error);\n\t\tgoto out_err;\n\t}\n\t \n\terror = ar5523_queue_init(ar);\n\tif (error)\n\t\tar5523_err(ar, \"could not init wme, error %d\\n\", error);\n\nout_err:\n\treturn error;\n}\n\nstatic void ar5523_rx_data_put(struct ar5523 *ar,\n\t\t\t\tstruct ar5523_rx_data *data)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&ar->rx_data_list_lock, flags);\n\tlist_move(&data->list, &ar->rx_data_free);\n\tspin_unlock_irqrestore(&ar->rx_data_list_lock, flags);\n}\n\nstatic void ar5523_data_rx_cb(struct urb *urb)\n{\n\tstruct ar5523_rx_data *data = urb->context;\n\tstruct ar5523 *ar = data->ar;\n\tstruct ar5523_rx_desc *desc;\n\tstruct ar5523_chunk *chunk;\n\tstruct ieee80211_hw *hw = ar->hw;\n\tstruct ieee80211_rx_status *rx_status;\n\tu32 rxlen;\n\tint usblen = urb->actual_length;\n\tint hdrlen, pad;\n\n\tar5523_dbg(ar, \"%s\\n\", __func__);\n\t \n\tif (urb->status) {\n\t\tif (urb->status != -ESHUTDOWN)\n\t\t\tar5523_err(ar, \"%s: USB err: %d\\n\", __func__,\n\t\t\t\t   urb->status);\n\t\tgoto skip;\n\t}\n\n\tif (usblen < AR5523_MIN_RXBUFSZ) {\n\t\tar5523_err(ar, \"RX: wrong xfer size (usblen=%d)\\n\", usblen);\n\t\tgoto skip;\n\t}\n\n\tchunk = (struct ar5523_chunk *) data->skb->data;\n\n\tif (((chunk->flags & UATH_CFLAGS_FINAL) == 0) ||\n\t\tchunk->seqnum != 0) {\n\t\tar5523_dbg(ar, \"RX: No final flag. s: %d f: %02x l: %d\\n\",\n\t\t\t   chunk->seqnum, chunk->flags,\n\t\t\t   be16_to_cpu(chunk->length));\n\t\tgoto skip;\n\t}\n\n\t \n\tdesc = (struct ar5523_rx_desc *)\n\t\t(data->skb->data + usblen - sizeof(struct ar5523_rx_desc));\n\n\trxlen = be32_to_cpu(desc->len);\n\tif (rxlen > ar->rxbufsz) {\n\t\tar5523_dbg(ar, \"RX: Bad descriptor (len=%d)\\n\",\n\t\t\t   be32_to_cpu(desc->len));\n\t\tgoto skip;\n\t}\n\n\tif (!rxlen) {\n\t\tar5523_dbg(ar, \"RX: rxlen is 0\\n\");\n\t\tgoto skip;\n\t}\n\n\tif (be32_to_cpu(desc->status) != 0) {\n\t\tar5523_dbg(ar, \"Bad RX status (0x%x len = %d). Skip\\n\",\n\t\t\t   be32_to_cpu(desc->status), be32_to_cpu(desc->len));\n\t\tgoto skip;\n\t}\n\n\tskb_reserve(data->skb, sizeof(*chunk));\n\tskb_put(data->skb, rxlen - sizeof(struct ar5523_rx_desc));\n\n\thdrlen = ieee80211_get_hdrlen_from_skb(data->skb);\n\tif (!IS_ALIGNED(hdrlen, 4)) {\n\t\tar5523_dbg(ar, \"eek, alignment workaround activated\\n\");\n\t\tpad = ALIGN(hdrlen, 4) - hdrlen;\n\t\tmemmove(data->skb->data + pad, data->skb->data, hdrlen);\n\t\tskb_pull(data->skb, pad);\n\t\tskb_put(data->skb, pad);\n\t}\n\n\trx_status = IEEE80211_SKB_RXCB(data->skb);\n\tmemset(rx_status, 0, sizeof(*rx_status));\n\trx_status->freq = be32_to_cpu(desc->channel);\n\trx_status->band = hw->conf.chandef.chan->band;\n\trx_status->signal = -95 + be32_to_cpu(desc->rssi);\n\n\tieee80211_rx_irqsafe(hw, data->skb);\n\tdata->skb = NULL;\n\nskip:\n\tif (data->skb) {\n\t\tdev_kfree_skb_irq(data->skb);\n\t\tdata->skb = NULL;\n\t}\n\n\tar5523_rx_data_put(ar, data);\n\tif (atomic_inc_return(&ar->rx_data_free_cnt) >=\n\t    AR5523_RX_DATA_REFILL_COUNT &&\n\t    test_bit(AR5523_HW_UP, &ar->flags))\n\t\tqueue_work(ar->wq, &ar->rx_refill_work);\n}\n\nstatic void ar5523_rx_refill_work(struct work_struct *work)\n{\n\tstruct ar5523 *ar = container_of(work, struct ar5523, rx_refill_work);\n\tstruct ar5523_rx_data *data;\n\tunsigned long flags;\n\tint error;\n\n\tar5523_dbg(ar, \"%s\\n\", __func__);\n\tdo {\n\t\tspin_lock_irqsave(&ar->rx_data_list_lock, flags);\n\n\t\tif (!list_empty(&ar->rx_data_free))\n\t\t\tdata = (struct ar5523_rx_data *) ar->rx_data_free.next;\n\t\telse\n\t\t\tdata = NULL;\n\t\tspin_unlock_irqrestore(&ar->rx_data_list_lock, flags);\n\n\t\tif (!data)\n\t\t\tgoto done;\n\n\t\tdata->skb = alloc_skb(ar->rxbufsz, GFP_KERNEL);\n\t\tif (!data->skb) {\n\t\t\tar5523_err(ar, \"could not allocate rx skbuff\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tusb_fill_bulk_urb(data->urb, ar->dev,\n\t\t\t\t  ar5523_data_rx_pipe(ar->dev), data->skb->data,\n\t\t\t\t  ar->rxbufsz, ar5523_data_rx_cb, data);\n\n\t\tspin_lock_irqsave(&ar->rx_data_list_lock, flags);\n\t\tlist_move(&data->list, &ar->rx_data_used);\n\t\tspin_unlock_irqrestore(&ar->rx_data_list_lock, flags);\n\t\tatomic_dec(&ar->rx_data_free_cnt);\n\n\t\terror = usb_submit_urb(data->urb, GFP_KERNEL);\n\t\tif (error) {\n\t\t\tkfree_skb(data->skb);\n\t\t\tif (error != -ENODEV)\n\t\t\t\tar5523_err(ar, \"Err sending rx data urb %d\\n\",\n\t\t\t\t\t   error);\n\t\t\tar5523_rx_data_put(ar, data);\n\t\t\tatomic_inc(&ar->rx_data_free_cnt);\n\t\t\treturn;\n\t\t}\n\n\t} while (true);\ndone:\n\treturn;\n}\n\nstatic void ar5523_cancel_rx_bufs(struct ar5523 *ar)\n{\n\tstruct ar5523_rx_data *data;\n\tunsigned long flags;\n\n\tdo {\n\t\tspin_lock_irqsave(&ar->rx_data_list_lock, flags);\n\t\tif (!list_empty(&ar->rx_data_used))\n\t\t\tdata = (struct ar5523_rx_data *) ar->rx_data_used.next;\n\t\telse\n\t\t\tdata = NULL;\n\t\tspin_unlock_irqrestore(&ar->rx_data_list_lock, flags);\n\n\t\tif (!data)\n\t\t\tbreak;\n\n\t\tusb_kill_urb(data->urb);\n\t\tlist_move(&data->list, &ar->rx_data_free);\n\t\tatomic_inc(&ar->rx_data_free_cnt);\n\t} while (data);\n}\n\nstatic void ar5523_free_rx_bufs(struct ar5523 *ar)\n{\n\tstruct ar5523_rx_data *data;\n\n\tar5523_cancel_rx_bufs(ar);\n\twhile (!list_empty(&ar->rx_data_free)) {\n\t\tdata = (struct ar5523_rx_data *) ar->rx_data_free.next;\n\t\tlist_del(&data->list);\n\t\tusb_free_urb(data->urb);\n\t}\n}\n\nstatic int ar5523_alloc_rx_bufs(struct ar5523 *ar)\n{\n\tint i;\n\n\tfor (i = 0; i < AR5523_RX_DATA_COUNT; i++) {\n\t\tstruct ar5523_rx_data *data = &ar->rx_data[i];\n\n\t\tdata->ar = ar;\n\t\tdata->urb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!data->urb)\n\t\t\tgoto err;\n\t\tlist_add_tail(&data->list, &ar->rx_data_free);\n\t\tatomic_inc(&ar->rx_data_free_cnt);\n\t}\n\treturn 0;\n\nerr:\n\tar5523_free_rx_bufs(ar);\n\treturn -ENOMEM;\n}\n\nstatic void ar5523_data_tx_pkt_put(struct ar5523 *ar)\n{\n\tatomic_dec(&ar->tx_nr_total);\n\tif (!atomic_dec_return(&ar->tx_nr_pending)) {\n\t\tdel_timer(&ar->tx_wd_timer);\n\t\twake_up(&ar->tx_flush_waitq);\n\t}\n\n\tif (atomic_read(&ar->tx_nr_total) < AR5523_TX_DATA_RESTART_COUNT) {\n\t\tar5523_dbg(ar, \"restart tx queue\\n\");\n\t\tieee80211_wake_queues(ar->hw);\n\t}\n}\n\nstatic void ar5523_data_tx_cb(struct urb *urb)\n{\n\tstruct sk_buff *skb = urb->context;\n\tstruct ieee80211_tx_info *txi = IEEE80211_SKB_CB(skb);\n\tstruct ar5523_tx_data *data = (struct ar5523_tx_data *)\n\t\t\t\t       txi->driver_data;\n\tstruct ar5523 *ar = data->ar;\n\tunsigned long flags;\n\n\tar5523_dbg(ar, \"data tx urb completed: %d\\n\", urb->status);\n\n\tspin_lock_irqsave(&ar->tx_data_list_lock, flags);\n\tlist_del(&data->list);\n\tspin_unlock_irqrestore(&ar->tx_data_list_lock, flags);\n\n\tif (urb->status) {\n\t\tar5523_dbg(ar, \"%s: urb status: %d\\n\", __func__, urb->status);\n\t\tar5523_data_tx_pkt_put(ar);\n\t\tieee80211_free_txskb(ar->hw, skb);\n\t} else {\n\t\tskb_pull(skb, sizeof(struct ar5523_tx_desc) + sizeof(__be32));\n\t\tieee80211_tx_status_irqsafe(ar->hw, skb);\n\t}\n\tusb_free_urb(urb);\n}\n\nstatic void ar5523_tx(struct ieee80211_hw *hw,\n\t\t       struct ieee80211_tx_control *control,\n\t\t       struct sk_buff *skb)\n{\n\tstruct ieee80211_tx_info *txi = IEEE80211_SKB_CB(skb);\n\tstruct ar5523_tx_data *data = (struct ar5523_tx_data *)\n\t\t\t\t\ttxi->driver_data;\n\tstruct ar5523 *ar = hw->priv;\n\tunsigned long flags;\n\n\tar5523_dbg(ar, \"tx called\\n\");\n\tif (atomic_inc_return(&ar->tx_nr_total) >= AR5523_TX_DATA_COUNT) {\n\t\tar5523_dbg(ar, \"tx queue full\\n\");\n\t\tar5523_dbg(ar, \"stop queues (tot %d pend %d)\\n\",\n\t\t\t   atomic_read(&ar->tx_nr_total),\n\t\t\t   atomic_read(&ar->tx_nr_pending));\n\t\tieee80211_stop_queues(hw);\n\t}\n\n\tspin_lock_irqsave(&ar->tx_data_list_lock, flags);\n\tlist_add_tail(&data->list, &ar->tx_queue_pending);\n\tspin_unlock_irqrestore(&ar->tx_data_list_lock, flags);\n\n\tieee80211_queue_work(ar->hw, &ar->tx_work);\n}\n\nstatic void ar5523_tx_work_locked(struct ar5523 *ar)\n{\n\tstruct ar5523_tx_data *data;\n\tstruct ar5523_tx_desc *desc;\n\tstruct ar5523_chunk *chunk;\n\tstruct ieee80211_tx_info *txi;\n\tstruct urb *urb;\n\tstruct sk_buff *skb;\n\tint error = 0, paylen;\n\tu32 txqid;\n\tunsigned long flags;\n\n\tBUILD_BUG_ON(sizeof(struct ar5523_tx_data) >\n\t\t     IEEE80211_TX_INFO_DRIVER_DATA_SIZE);\n\n\tar5523_dbg(ar, \"%s\\n\", __func__);\n\tdo {\n\t\tspin_lock_irqsave(&ar->tx_data_list_lock, flags);\n\t\tif (!list_empty(&ar->tx_queue_pending)) {\n\t\t\tdata = (struct ar5523_tx_data *)\n\t\t\t\tar->tx_queue_pending.next;\n\t\t\tlist_del(&data->list);\n\t\t} else\n\t\t\tdata = NULL;\n\t\tspin_unlock_irqrestore(&ar->tx_data_list_lock, flags);\n\n\t\tif (!data)\n\t\t\tbreak;\n\n\t\ttxi = container_of((void *)data, struct ieee80211_tx_info,\n\t\t\t\t   driver_data);\n\t\ttxqid = 0;\n\n\t\tskb = container_of((void *)txi, struct sk_buff, cb);\n\t\tpaylen = skb->len;\n\n\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!urb) {\n\t\t\tieee80211_free_txskb(ar->hw, skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdata->ar = ar;\n\t\tdata->urb = urb;\n\n\t\tdesc = skb_push(skb, sizeof(*desc));\n\t\tchunk = skb_push(skb, sizeof(*chunk));\n\n\t\tchunk->seqnum = 0;\n\t\tchunk->flags = UATH_CFLAGS_FINAL;\n\t\tchunk->length = cpu_to_be16(skb->len);\n\n\t\tdesc->msglen = cpu_to_be32(skb->len);\n\t\tdesc->msgid  = AR5523_DATA_ID;\n\t\tdesc->buflen = cpu_to_be32(paylen);\n\t\tdesc->type   = cpu_to_be32(WDCMSG_SEND);\n\t\tdesc->flags  = cpu_to_be32(UATH_TX_NOTIFY);\n\n\t\tif (test_bit(AR5523_CONNECTED, &ar->flags))\n\t\t\tdesc->connid = cpu_to_be32(AR5523_ID_BSS);\n\t\telse\n\t\t\tdesc->connid = cpu_to_be32(AR5523_ID_BROADCAST);\n\n\t\tif (txi->flags & IEEE80211_TX_CTL_USE_MINRATE)\n\t\t\ttxqid |= UATH_TXQID_MINRATE;\n\n\t\tdesc->txqid = cpu_to_be32(txqid);\n\n\t\turb->transfer_flags = URB_ZERO_PACKET;\n\t\tusb_fill_bulk_urb(urb, ar->dev, ar5523_data_tx_pipe(ar->dev),\n\t\t\t\t  skb->data, skb->len, ar5523_data_tx_cb, skb);\n\n\t\tspin_lock_irqsave(&ar->tx_data_list_lock, flags);\n\t\tlist_add_tail(&data->list, &ar->tx_queue_submitted);\n\t\tspin_unlock_irqrestore(&ar->tx_data_list_lock, flags);\n\t\tmod_timer(&ar->tx_wd_timer, jiffies + AR5523_TX_WD_TIMEOUT);\n\t\tatomic_inc(&ar->tx_nr_pending);\n\n\t\tar5523_dbg(ar, \"TX Frame (%d pending)\\n\",\n\t\t\t   atomic_read(&ar->tx_nr_pending));\n\t\terror = usb_submit_urb(urb, GFP_KERNEL);\n\t\tif (error) {\n\t\t\tar5523_err(ar, \"error %d when submitting tx urb\\n\",\n\t\t\t\t   error);\n\t\t\tspin_lock_irqsave(&ar->tx_data_list_lock, flags);\n\t\t\tlist_del(&data->list);\n\t\t\tspin_unlock_irqrestore(&ar->tx_data_list_lock, flags);\n\t\t\tatomic_dec(&ar->tx_nr_pending);\n\t\t\tar5523_data_tx_pkt_put(ar);\n\t\t\tusb_free_urb(urb);\n\t\t\tieee80211_free_txskb(ar->hw, skb);\n\t\t}\n\t} while (true);\n}\n\nstatic void ar5523_tx_work(struct work_struct *work)\n{\n\tstruct ar5523 *ar = container_of(work, struct ar5523, tx_work);\n\n\tar5523_dbg(ar, \"%s\\n\", __func__);\n\tmutex_lock(&ar->mutex);\n\tar5523_tx_work_locked(ar);\n\tmutex_unlock(&ar->mutex);\n}\n\nstatic void ar5523_tx_wd_timer(struct timer_list *t)\n{\n\tstruct ar5523 *ar = from_timer(ar, t, tx_wd_timer);\n\n\tar5523_dbg(ar, \"TX watchdog timer triggered\\n\");\n\tieee80211_queue_work(ar->hw, &ar->tx_wd_work);\n}\n\nstatic void ar5523_tx_wd_work(struct work_struct *work)\n{\n\tstruct ar5523 *ar = container_of(work, struct ar5523, tx_wd_work);\n\n\t \n\n\tmutex_lock(&ar->mutex);\n\tar5523_err(ar, \"TX queue stuck (tot %d pend %d)\\n\",\n\t\t   atomic_read(&ar->tx_nr_total),\n\t\t   atomic_read(&ar->tx_nr_pending));\n\n\tar5523_err(ar, \"Will restart dongle.\\n\");\n\tar5523_cmd_write(ar, WDCMSG_TARGET_RESET, NULL, 0, 0);\n\tmutex_unlock(&ar->mutex);\n}\n\nstatic void ar5523_flush_tx(struct ar5523 *ar)\n{\n\tar5523_tx_work_locked(ar);\n\n\t \n\tif (test_bit(AR5523_USB_DISCONNECTED, &ar->flags))\n\t\treturn;\n\tif (!wait_event_timeout(ar->tx_flush_waitq,\n\t    !atomic_read(&ar->tx_nr_pending), AR5523_FLUSH_TIMEOUT))\n\t\tar5523_err(ar, \"flush timeout (tot %d pend %d)\\n\",\n\t\t\t   atomic_read(&ar->tx_nr_total),\n\t\t\t   atomic_read(&ar->tx_nr_pending));\n}\n\nstatic void ar5523_free_tx_cmd(struct ar5523 *ar)\n{\n\tstruct ar5523_tx_cmd *cmd = &ar->tx_cmd;\n\n\tusb_free_coherent(ar->dev, AR5523_MAX_RXCMDSZ, cmd->buf_tx,\n\t\t\t  cmd->urb_tx->transfer_dma);\n\tusb_free_urb(cmd->urb_tx);\n}\n\nstatic int ar5523_alloc_tx_cmd(struct ar5523 *ar)\n{\n\tstruct ar5523_tx_cmd *cmd = &ar->tx_cmd;\n\n\tcmd->ar = ar;\n\tinit_completion(&cmd->done);\n\n\tcmd->urb_tx = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!cmd->urb_tx)\n\t\treturn -ENOMEM;\n\tcmd->buf_tx = usb_alloc_coherent(ar->dev, AR5523_MAX_TXCMDSZ,\n\t\t\t\t\t GFP_KERNEL,\n\t\t\t\t\t &cmd->urb_tx->transfer_dma);\n\tif (!cmd->buf_tx) {\n\t\tusb_free_urb(cmd->urb_tx);\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\n \nstatic void ar5523_stat_work(struct work_struct *work)\n{\n\tstruct ar5523 *ar = container_of(work, struct ar5523, stat_work.work);\n\tint error;\n\n\tar5523_dbg(ar, \"%s\\n\", __func__);\n\tmutex_lock(&ar->mutex);\n\n\t \n\terror = ar5523_cmd_write(ar, WDCMSG_TARGET_GET_STATS, NULL, 0, 0);\n\tif (error)\n\t\tar5523_err(ar, \"could not query stats, error %d\\n\", error);\n\tmutex_unlock(&ar->mutex);\n\tieee80211_queue_delayed_work(ar->hw, &ar->stat_work, HZ);\n}\n\n \nstatic int ar5523_start(struct ieee80211_hw *hw)\n{\n\tstruct ar5523 *ar = hw->priv;\n\tint error;\n\t__be32 val;\n\n\tar5523_dbg(ar, \"start called\\n\");\n\n\tmutex_lock(&ar->mutex);\n\tval = cpu_to_be32(0);\n\tar5523_cmd_write(ar, WDCMSG_BIND, &val, sizeof(val), 0);\n\n\t \n\tar5523_config_multi(ar, CFG_MAC_ADDR, &ar->hw->wiphy->perm_addr,\n\t\t\t    ETH_ALEN);\n\n\t \n\tar5523_config(ar, CFG_RATE_CONTROL_ENABLE, 0x00000001);\n\tar5523_config(ar, CFG_DIVERSITY_CTL, 0x00000001);\n\tar5523_config(ar, CFG_ABOLT, 0x0000003f);\n\tar5523_config(ar, CFG_WME_ENABLED, 0x00000000);\n\n\tar5523_config(ar, CFG_SERVICE_TYPE, 1);\n\tar5523_config(ar, CFG_TP_SCALE, 0x00000000);\n\tar5523_config(ar, CFG_TPC_HALF_DBM5, 0x0000003c);\n\tar5523_config(ar, CFG_TPC_HALF_DBM2, 0x0000003c);\n\tar5523_config(ar, CFG_OVERRD_TX_POWER, 0x00000000);\n\tar5523_config(ar, CFG_GMODE_PROTECTION, 0x00000000);\n\tar5523_config(ar, CFG_GMODE_PROTECT_RATE_INDEX, 0x00000003);\n\tar5523_config(ar, CFG_PROTECTION_TYPE, 0x00000000);\n\tar5523_config(ar, CFG_MODE_CTS, 0x00000002);\n\n\terror = ar5523_cmd_read(ar, WDCMSG_TARGET_START, NULL, 0,\n\t    &val, sizeof(val), AR5523_CMD_FLAG_MAGIC);\n\tif (error) {\n\t\tar5523_dbg(ar, \"could not start target, error %d\\n\", error);\n\t\tgoto err;\n\t}\n\tar5523_dbg(ar, \"WDCMSG_TARGET_START returns handle: 0x%x\\n\",\n\t\t   be32_to_cpu(val));\n\n\tar5523_switch_chan(ar);\n\n\tval = cpu_to_be32(TARGET_DEVICE_AWAKE);\n\tar5523_cmd_write(ar, WDCMSG_SET_PWR_MODE, &val, sizeof(val), 0);\n\t \n\tar5523_cmd_write(ar, WDCMSG_RESET_KEY_CACHE, NULL, 0, 0);\n\n\tset_bit(AR5523_HW_UP, &ar->flags);\n\tqueue_work(ar->wq, &ar->rx_refill_work);\n\n\t \n\tar5523_set_rxfilter(ar, 0, UATH_FILTER_OP_INIT);\n\tar5523_set_rxfilter(ar,\n\t\t\t    UATH_FILTER_RX_UCAST | UATH_FILTER_RX_MCAST |\n\t\t\t    UATH_FILTER_RX_BCAST | UATH_FILTER_RX_BEACON,\n\t\t\t    UATH_FILTER_OP_SET);\n\n\tar5523_set_ledsteady(ar, UATH_LED_ACTIVITY, UATH_LED_ON);\n\tar5523_dbg(ar, \"start OK\\n\");\n\nerr:\n\tmutex_unlock(&ar->mutex);\n\treturn error;\n}\n\nstatic void ar5523_stop(struct ieee80211_hw *hw)\n{\n\tstruct ar5523 *ar = hw->priv;\n\n\tar5523_dbg(ar, \"stop called\\n\");\n\n\tcancel_delayed_work_sync(&ar->stat_work);\n\tmutex_lock(&ar->mutex);\n\tclear_bit(AR5523_HW_UP, &ar->flags);\n\n\tar5523_set_ledsteady(ar, UATH_LED_LINK, UATH_LED_OFF);\n\tar5523_set_ledsteady(ar, UATH_LED_ACTIVITY, UATH_LED_OFF);\n\n\tar5523_cmd_write(ar, WDCMSG_TARGET_STOP, NULL, 0, 0);\n\n\tdel_timer_sync(&ar->tx_wd_timer);\n\tcancel_work_sync(&ar->tx_wd_work);\n\tcancel_work_sync(&ar->rx_refill_work);\n\tar5523_cancel_rx_bufs(ar);\n\tmutex_unlock(&ar->mutex);\n}\n\nstatic int ar5523_set_rts_threshold(struct ieee80211_hw *hw, u32 value)\n{\n\tstruct ar5523 *ar = hw->priv;\n\tint ret;\n\n\tar5523_dbg(ar, \"set_rts_threshold called\\n\");\n\tmutex_lock(&ar->mutex);\n\n\tret = ar5523_config(ar, CFG_USER_RTS_THRESHOLD, value);\n\n\tmutex_unlock(&ar->mutex);\n\treturn ret;\n}\n\nstatic void ar5523_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t u32 queues, bool drop)\n{\n\tstruct ar5523 *ar = hw->priv;\n\n\tar5523_dbg(ar, \"flush called\\n\");\n\tar5523_flush_tx(ar);\n}\n\nstatic int ar5523_add_interface(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif)\n{\n\tstruct ar5523 *ar = hw->priv;\n\n\tar5523_dbg(ar, \"add interface called\\n\");\n\n\tif (ar->vif) {\n\t\tar5523_dbg(ar, \"invalid add_interface\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\tar->vif = vif;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\nstatic void ar5523_remove_interface(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif)\n{\n\tstruct ar5523 *ar = hw->priv;\n\n\tar5523_dbg(ar, \"remove interface called\\n\");\n\tar->vif = NULL;\n}\n\nstatic int ar5523_hwconfig(struct ieee80211_hw *hw, u32 changed)\n{\n\tstruct ar5523 *ar = hw->priv;\n\n\tar5523_dbg(ar, \"config called\\n\");\n\tmutex_lock(&ar->mutex);\n\tif (changed & IEEE80211_CONF_CHANGE_CHANNEL) {\n\t\tar5523_dbg(ar, \"Do channel switch\\n\");\n\t\tar5523_flush_tx(ar);\n\t\tar5523_switch_chan(ar);\n\t}\n\tmutex_unlock(&ar->mutex);\n\treturn 0;\n}\n\nstatic int ar5523_get_wlan_mode(struct ar5523 *ar,\n\t\t\t\tstruct ieee80211_bss_conf *bss_conf)\n{\n\tstruct ieee80211_supported_band *band;\n\tint bit;\n\tstruct ieee80211_sta *sta;\n\tu32 sta_rate_set;\n\n\tband = ar->hw->wiphy->bands[ar->hw->conf.chandef.chan->band];\n\tsta = ieee80211_find_sta(ar->vif, bss_conf->bssid);\n\tif (!sta) {\n\t\tar5523_info(ar, \"STA not found!\\n\");\n\t\treturn WLAN_MODE_11b;\n\t}\n\tsta_rate_set = sta->deflink.supp_rates[ar->hw->conf.chandef.chan->band];\n\n\tfor (bit = 0; bit < band->n_bitrates; bit++) {\n\t\tif (sta_rate_set & 1) {\n\t\t\tint rate = band->bitrates[bit].bitrate;\n\t\t\tswitch (rate) {\n\t\t\tcase 60:\n\t\t\tcase 90:\n\t\t\tcase 120:\n\t\t\tcase 180:\n\t\t\tcase 240:\n\t\t\tcase 360:\n\t\t\tcase 480:\n\t\t\tcase 540:\n\t\t\t\treturn WLAN_MODE_11g;\n\t\t\t}\n\t\t}\n\t\tsta_rate_set >>= 1;\n\t}\n\treturn WLAN_MODE_11b;\n}\n\nstatic void ar5523_create_rateset(struct ar5523 *ar,\n\t\t\t\t  struct ieee80211_bss_conf *bss_conf,\n\t\t\t\t  struct ar5523_cmd_rateset *rs,\n\t\t\t\t  bool basic)\n{\n\tstruct ieee80211_supported_band *band;\n\tstruct ieee80211_sta *sta;\n\tint bit, i = 0;\n\tu32 sta_rate_set, basic_rate_set;\n\n\tsta = ieee80211_find_sta(ar->vif, bss_conf->bssid);\n\tbasic_rate_set = bss_conf->basic_rates;\n\tif (!sta) {\n\t\tar5523_info(ar, \"STA not found. Cannot set rates\\n\");\n\t\tsta_rate_set = bss_conf->basic_rates;\n\t} else\n\t\tsta_rate_set = sta->deflink.supp_rates[ar->hw->conf.chandef.chan->band];\n\n\tar5523_dbg(ar, \"sta rate_set = %08x\\n\", sta_rate_set);\n\n\tband = ar->hw->wiphy->bands[ar->hw->conf.chandef.chan->band];\n\tfor (bit = 0; bit < band->n_bitrates; bit++) {\n\t\tBUG_ON(i >= AR5523_MAX_NRATES);\n\t\tar5523_dbg(ar, \"Considering rate %d : %d\\n\",\n\t\t\t   band->bitrates[bit].hw_value, sta_rate_set & 1);\n\t\tif (sta_rate_set & 1) {\n\t\t\trs->set[i] = band->bitrates[bit].hw_value;\n\t\t\tif (basic_rate_set & 1 && basic)\n\t\t\t\trs->set[i] |= 0x80;\n\t\t\ti++;\n\t\t}\n\t\tsta_rate_set >>= 1;\n\t\tbasic_rate_set >>= 1;\n\t}\n\n\trs->length = i;\n}\n\nstatic int ar5523_set_basic_rates(struct ar5523 *ar,\n\t\t\t\t  struct ieee80211_bss_conf *bss)\n{\n\tstruct ar5523_cmd_rates rates;\n\n\tmemset(&rates, 0, sizeof(rates));\n\trates.connid = cpu_to_be32(2);\t\t \n\trates.size   = cpu_to_be32(sizeof(struct ar5523_cmd_rateset));\n\tar5523_create_rateset(ar, bss, &rates.rateset, true);\n\n\treturn ar5523_cmd_write(ar, WDCMSG_SET_BASIC_RATE, &rates,\n\t\t\t\tsizeof(rates), 0);\n}\n\nstatic int ar5523_create_connection(struct ar5523 *ar,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct ieee80211_bss_conf *bss)\n{\n\tstruct ar5523_cmd_create_connection create;\n\tint wlan_mode;\n\n\tmemset(&create, 0, sizeof(create));\n\tcreate.connid = cpu_to_be32(2);\n\tcreate.bssid = cpu_to_be32(0);\n\t \n\tcreate.size = cpu_to_be32(sizeof(struct ar5523_cmd_rateset));\n\n\tar5523_create_rateset(ar, bss, &create.connattr.rateset, false);\n\n\twlan_mode = ar5523_get_wlan_mode(ar, bss);\n\tcreate.connattr.wlanmode = cpu_to_be32(wlan_mode);\n\n\treturn ar5523_cmd_write(ar, WDCMSG_CREATE_CONNECTION, &create,\n\t\t\t\tsizeof(create), 0);\n}\n\nstatic int ar5523_write_associd(struct ar5523 *ar, struct ieee80211_vif *vif)\n{\n\tstruct ieee80211_bss_conf *bss = &vif->bss_conf;\n\tstruct ar5523_cmd_set_associd associd;\n\n\tmemset(&associd, 0, sizeof(associd));\n\tassocid.defaultrateix = cpu_to_be32(0);\t \n\tassocid.associd = cpu_to_be32(vif->cfg.aid);\n\tassocid.timoffset = cpu_to_be32(0x3b);\t \n\tmemcpy(associd.bssid, bss->bssid, ETH_ALEN);\n\treturn ar5523_cmd_write(ar, WDCMSG_WRITE_ASSOCID, &associd,\n\t\t\t\tsizeof(associd), 0);\n}\n\nstatic void ar5523_bss_info_changed(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct ieee80211_bss_conf *bss,\n\t\t\t\t    u64 changed)\n{\n\tstruct ar5523 *ar = hw->priv;\n\tint error;\n\n\tar5523_dbg(ar, \"bss_info_changed called\\n\");\n\tmutex_lock(&ar->mutex);\n\n\tif (!(changed & BSS_CHANGED_ASSOC))\n\t\tgoto out_unlock;\n\n\tif (vif->cfg.assoc) {\n\t\terror = ar5523_create_connection(ar, vif, bss);\n\t\tif (error) {\n\t\t\tar5523_err(ar, \"could not create connection\\n\");\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\terror = ar5523_set_basic_rates(ar, bss);\n\t\tif (error) {\n\t\t\tar5523_err(ar, \"could not set negotiated rate set\\n\");\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\terror = ar5523_write_associd(ar, vif);\n\t\tif (error) {\n\t\t\tar5523_err(ar, \"could not set association\\n\");\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\t \n\t\tar5523_set_ledsteady(ar, UATH_LED_LINK, UATH_LED_ON);\n\t\tset_bit(AR5523_CONNECTED, &ar->flags);\n\t\tieee80211_queue_delayed_work(hw, &ar->stat_work, HZ);\n\n\t} else {\n\t\tcancel_delayed_work(&ar->stat_work);\n\t\tclear_bit(AR5523_CONNECTED, &ar->flags);\n\t\tar5523_set_ledsteady(ar, UATH_LED_LINK, UATH_LED_OFF);\n\t}\n\nout_unlock:\n\tmutex_unlock(&ar->mutex);\n\n}\n\n#define AR5523_SUPPORTED_FILTERS (FIF_ALLMULTI | \\\n\t\t\t\t  FIF_FCSFAIL | \\\n\t\t\t\t  FIF_OTHER_BSS)\n\nstatic void ar5523_configure_filter(struct ieee80211_hw *hw,\n\t\t\t\t    unsigned int changed_flags,\n\t\t\t\t    unsigned int *total_flags,\n\t\t\t\t    u64 multicast)\n{\n\tstruct ar5523 *ar = hw->priv;\n\tu32 filter = 0;\n\n\tar5523_dbg(ar, \"configure_filter called\\n\");\n\tmutex_lock(&ar->mutex);\n\tar5523_flush_tx(ar);\n\n\t*total_flags &= AR5523_SUPPORTED_FILTERS;\n\n\t \n\tfilter |= UATH_FILTER_RX_UCAST | UATH_FILTER_RX_MCAST |\n\t\t  UATH_FILTER_RX_BCAST | UATH_FILTER_RX_BEACON |\n\t\t  UATH_FILTER_RX_PROM;\n\n\tar5523_set_rxfilter(ar, 0, UATH_FILTER_OP_INIT);\n\tar5523_set_rxfilter(ar, filter, UATH_FILTER_OP_SET);\n\n\tmutex_unlock(&ar->mutex);\n}\n\nstatic const struct ieee80211_ops ar5523_ops = {\n\t.start\t\t\t= ar5523_start,\n\t.stop\t\t\t= ar5523_stop,\n\t.tx\t\t\t= ar5523_tx,\n\t.wake_tx_queue\t\t= ieee80211_handle_wake_tx_queue,\n\t.set_rts_threshold\t= ar5523_set_rts_threshold,\n\t.add_interface\t\t= ar5523_add_interface,\n\t.remove_interface\t= ar5523_remove_interface,\n\t.config\t\t\t= ar5523_hwconfig,\n\t.bss_info_changed\t= ar5523_bss_info_changed,\n\t.configure_filter\t= ar5523_configure_filter,\n\t.flush\t\t\t= ar5523_flush,\n};\n\nstatic int ar5523_host_available(struct ar5523 *ar)\n{\n\tstruct ar5523_cmd_host_available setup;\n\n\t \n\tsetup.sw_ver_major = cpu_to_be32(ATH_SW_VER_MAJOR);\n\tsetup.sw_ver_minor = cpu_to_be32(ATH_SW_VER_MINOR);\n\tsetup.sw_ver_patch = cpu_to_be32(ATH_SW_VER_PATCH);\n\tsetup.sw_ver_build = cpu_to_be32(ATH_SW_VER_BUILD);\n\treturn ar5523_cmd_read(ar, WDCMSG_HOST_AVAILABLE,\n\t\t\t       &setup, sizeof(setup), NULL, 0, 0);\n}\n\nstatic int ar5523_get_devstatus(struct ar5523 *ar)\n{\n\tu8 macaddr[ETH_ALEN];\n\tint error;\n\n\t \n\terror = ar5523_get_status(ar, ST_MAC_ADDR, macaddr, ETH_ALEN);\n\tif (error) {\n\t\tar5523_err(ar, \"could not read MAC address\\n\");\n\t\treturn error;\n\t}\n\n\tSET_IEEE80211_PERM_ADDR(ar->hw, macaddr);\n\n\terror = ar5523_get_status(ar, ST_SERIAL_NUMBER,\n\t    &ar->serial[0], sizeof(ar->serial));\n\tif (error) {\n\t\tar5523_err(ar, \"could not read device serial number\\n\");\n\t\treturn error;\n\t}\n\treturn 0;\n}\n\n#define AR5523_SANE_RXBUFSZ 2000\n\nstatic int ar5523_get_max_rxsz(struct ar5523 *ar)\n{\n\tint error;\n\t__be32 rxsize;\n\n\t \n\terror = ar5523_get_status(ar, ST_WDC_TRANSPORT_CHUNK_SIZE, &rxsize,\n\t\t\t\t  sizeof(rxsize));\n\tif (error != 0) {\n\t\tar5523_err(ar, \"could not read max RX size\\n\");\n\t\treturn error;\n\t}\n\n\tar->rxbufsz = be32_to_cpu(rxsize);\n\n\tif (!ar->rxbufsz || ar->rxbufsz > AR5523_SANE_RXBUFSZ) {\n\t\tar5523_err(ar, \"Bad rxbufsz from device. Using %d instead\\n\",\n\t\t\t   AR5523_SANE_RXBUFSZ);\n\t\tar->rxbufsz = AR5523_SANE_RXBUFSZ;\n\t}\n\n\tar5523_dbg(ar, \"Max RX buf size: %d\\n\", ar->rxbufsz);\n\treturn 0;\n}\n\n \nstatic const struct ieee80211_rate ar5523_rates[] = {\n\t{ .bitrate = 10, .hw_value = 2, },\n\t{ .bitrate = 20, .hw_value = 4 },\n\t{ .bitrate = 55, .hw_value = 11, },\n\t{ .bitrate = 110, .hw_value = 22, },\n\t{ .bitrate = 60, .hw_value = 12, },\n\t{ .bitrate = 90, .hw_value = 18, },\n\t{ .bitrate = 120, .hw_value = 24, },\n\t{ .bitrate = 180, .hw_value = 36, },\n\t{ .bitrate = 240, .hw_value = 48, },\n\t{ .bitrate = 360, .hw_value = 72, },\n\t{ .bitrate = 480, .hw_value = 96, },\n\t{ .bitrate = 540, .hw_value = 108, },\n};\n\nstatic const struct ieee80211_channel ar5523_channels[] = {\n\t{ .center_freq = 2412 },\n\t{ .center_freq = 2417 },\n\t{ .center_freq = 2422 },\n\t{ .center_freq = 2427 },\n\t{ .center_freq = 2432 },\n\t{ .center_freq = 2437 },\n\t{ .center_freq = 2442 },\n\t{ .center_freq = 2447 },\n\t{ .center_freq = 2452 },\n\t{ .center_freq = 2457 },\n\t{ .center_freq = 2462 },\n\t{ .center_freq = 2467 },\n\t{ .center_freq = 2472 },\n\t{ .center_freq = 2484 },\n};\n\nstatic int ar5523_init_modes(struct ar5523 *ar)\n{\n\tBUILD_BUG_ON(sizeof(ar->channels) != sizeof(ar5523_channels));\n\tBUILD_BUG_ON(sizeof(ar->rates) != sizeof(ar5523_rates));\n\n\tmemcpy(ar->channels, ar5523_channels, sizeof(ar5523_channels));\n\tmemcpy(ar->rates, ar5523_rates, sizeof(ar5523_rates));\n\n\tar->band.band = NL80211_BAND_2GHZ;\n\tar->band.channels = ar->channels;\n\tar->band.n_channels = ARRAY_SIZE(ar5523_channels);\n\tar->band.bitrates = ar->rates;\n\tar->band.n_bitrates = ARRAY_SIZE(ar5523_rates);\n\tar->hw->wiphy->bands[NL80211_BAND_2GHZ] = &ar->band;\n\treturn 0;\n}\n\n \nstatic int ar5523_load_firmware(struct usb_device *dev)\n{\n\tstruct ar5523_fwblock *txblock, *rxblock;\n\tconst struct firmware *fw;\n\tvoid *fwbuf;\n\tint len, offset;\n\tint foolen;  \n\tint error = -ENXIO;\n\n\tif (request_firmware(&fw, AR5523_FIRMWARE_FILE, &dev->dev)) {\n\t\tdev_err(&dev->dev, \"no firmware found: %s\\n\",\n\t\t\tAR5523_FIRMWARE_FILE);\n\t\treturn -ENOENT;\n\t}\n\n\ttxblock = kzalloc(sizeof(*txblock), GFP_KERNEL);\n\tif (!txblock)\n\t\tgoto out;\n\n\trxblock = kmalloc(sizeof(*rxblock), GFP_KERNEL);\n\tif (!rxblock)\n\t\tgoto out_free_txblock;\n\n\tfwbuf = kmalloc(AR5523_MAX_FWBLOCK_SIZE, GFP_KERNEL);\n\tif (!fwbuf)\n\t\tgoto out_free_rxblock;\n\n\ttxblock->flags = cpu_to_be32(AR5523_WRITE_BLOCK);\n\ttxblock->total = cpu_to_be32(fw->size);\n\n\toffset = 0;\n\tlen = fw->size;\n\twhile (len > 0) {\n\t\tint mlen = min(len, AR5523_MAX_FWBLOCK_SIZE);\n\n\t\ttxblock->remain = cpu_to_be32(len - mlen);\n\t\ttxblock->len = cpu_to_be32(mlen);\n\n\t\t \n\t\terror = usb_bulk_msg(dev, ar5523_cmd_tx_pipe(dev),\n\t\t\t\t     txblock, sizeof(*txblock), &foolen,\n\t\t\t\t     AR5523_CMD_TIMEOUT);\n\t\tif (error) {\n\t\t\tdev_err(&dev->dev,\n\t\t\t\t\"could not send firmware block info\\n\");\n\t\t\tgoto out_free_fwbuf;\n\t\t}\n\n\t\t \n\t\tmemcpy(fwbuf, fw->data + offset, mlen);\n\t\terror = usb_bulk_msg(dev, ar5523_data_tx_pipe(dev),\n\t\t\t\t     fwbuf, mlen, &foolen,\n\t\t\t\t     AR5523_DATA_TIMEOUT);\n\t\tif (error) {\n\t\t\tdev_err(&dev->dev,\n\t\t\t\t\"could not send firmware block data\\n\");\n\t\t\tgoto out_free_fwbuf;\n\t\t}\n\n\t\t \n\t\terror = usb_bulk_msg(dev, ar5523_cmd_rx_pipe(dev),\n\t\t\t\t     rxblock, sizeof(*rxblock), &foolen,\n\t\t\t\t     AR5523_CMD_TIMEOUT);\n\t\tif (error) {\n\t\t\tdev_err(&dev->dev,\n\t\t\t\t\"could not read firmware answer\\n\");\n\t\t\tgoto out_free_fwbuf;\n\t\t}\n\n\t\tlen -= mlen;\n\t\toffset += mlen;\n\t}\n\n\t \n\terror = -ENXIO;\n\n out_free_fwbuf:\n\tkfree(fwbuf);\n out_free_rxblock:\n\tkfree(rxblock);\n out_free_txblock:\n\tkfree(txblock);\n out:\n\trelease_firmware(fw);\n\treturn error;\n}\n\nstatic int ar5523_probe(struct usb_interface *intf,\n\t\t\tconst struct usb_device_id *id)\n{\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\tstruct ieee80211_hw *hw;\n\tstruct ar5523 *ar;\n\tint error = -ENOMEM;\n\n\t \n\tif (id->driver_info & AR5523_FLAG_PRE_FIRMWARE)\n\t\treturn ar5523_load_firmware(dev);\n\n\n\thw = ieee80211_alloc_hw(sizeof(*ar), &ar5523_ops);\n\tif (!hw)\n\t\tgoto out;\n\tSET_IEEE80211_DEV(hw, &intf->dev);\n\n\tar = hw->priv;\n\tar->hw = hw;\n\tar->dev = dev;\n\tmutex_init(&ar->mutex);\n\n\tINIT_DELAYED_WORK(&ar->stat_work, ar5523_stat_work);\n\ttimer_setup(&ar->tx_wd_timer, ar5523_tx_wd_timer, 0);\n\tINIT_WORK(&ar->tx_wd_work, ar5523_tx_wd_work);\n\tINIT_WORK(&ar->tx_work, ar5523_tx_work);\n\tINIT_LIST_HEAD(&ar->tx_queue_pending);\n\tINIT_LIST_HEAD(&ar->tx_queue_submitted);\n\tspin_lock_init(&ar->tx_data_list_lock);\n\tatomic_set(&ar->tx_nr_total, 0);\n\tatomic_set(&ar->tx_nr_pending, 0);\n\tinit_waitqueue_head(&ar->tx_flush_waitq);\n\n\tatomic_set(&ar->rx_data_free_cnt, 0);\n\tINIT_WORK(&ar->rx_refill_work, ar5523_rx_refill_work);\n\tINIT_LIST_HEAD(&ar->rx_data_free);\n\tINIT_LIST_HEAD(&ar->rx_data_used);\n\tspin_lock_init(&ar->rx_data_list_lock);\n\n\tar->wq = create_singlethread_workqueue(\"ar5523\");\n\tif (!ar->wq) {\n\t\tar5523_err(ar, \"Could not create wq\\n\");\n\t\tgoto out_free_ar;\n\t}\n\n\terror = ar5523_alloc_rx_bufs(ar);\n\tif (error) {\n\t\tar5523_err(ar, \"Could not allocate rx buffers\\n\");\n\t\tgoto out_free_wq;\n\t}\n\n\terror = ar5523_alloc_rx_cmd(ar);\n\tif (error) {\n\t\tar5523_err(ar, \"Could not allocate rx command buffers\\n\");\n\t\tgoto out_free_rx_bufs;\n\t}\n\n\terror = ar5523_alloc_tx_cmd(ar);\n\tif (error) {\n\t\tar5523_err(ar, \"Could not allocate tx command buffers\\n\");\n\t\tgoto out_free_rx_cmd;\n\t}\n\n\terror = ar5523_submit_rx_cmd(ar);\n\tif (error) {\n\t\tar5523_err(ar, \"Failed to submit rx cmd\\n\");\n\t\tgoto out_free_tx_cmd;\n\t}\n\n\t \n\terror = ar5523_host_available(ar);\n\tif (error) {\n\t\tar5523_err(ar, \"could not initialize adapter\\n\");\n\t\tgoto out_cancel_rx_cmd;\n\t}\n\n\terror = ar5523_get_max_rxsz(ar);\n\tif (error) {\n\t\tar5523_err(ar, \"could not get caps from adapter\\n\");\n\t\tgoto out_cancel_rx_cmd;\n\t}\n\n\terror = ar5523_get_devcap(ar);\n\tif (error) {\n\t\tar5523_err(ar, \"could not get caps from adapter\\n\");\n\t\tgoto out_cancel_rx_cmd;\n\t}\n\n\terror = ar5523_get_devstatus(ar);\n\tif (error != 0) {\n\t\tar5523_err(ar, \"could not get device status\\n\");\n\t\tgoto out_cancel_rx_cmd;\n\t}\n\n\tar5523_info(ar, \"MAC/BBP AR5523, RF AR%c112\\n\",\n\t\t\t(id->driver_info & AR5523_FLAG_ABG) ? '5' : '2');\n\n\tar->vif = NULL;\n\tieee80211_hw_set(hw, HAS_RATE_CONTROL);\n\tieee80211_hw_set(hw, RX_INCLUDES_FCS);\n\tieee80211_hw_set(hw, SIGNAL_DBM);\n\thw->extra_tx_headroom = sizeof(struct ar5523_tx_desc) +\n\t\t\t\tsizeof(struct ar5523_chunk);\n\thw->wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION);\n\thw->queues = 1;\n\n\terror = ar5523_init_modes(ar);\n\tif (error)\n\t\tgoto out_cancel_rx_cmd;\n\n\twiphy_ext_feature_set(hw->wiphy, NL80211_EXT_FEATURE_CQM_RSSI_LIST);\n\n\tusb_set_intfdata(intf, hw);\n\n\terror = ieee80211_register_hw(hw);\n\tif (error) {\n\t\tar5523_err(ar, \"could not register device\\n\");\n\t\tgoto out_cancel_rx_cmd;\n\t}\n\n\tar5523_info(ar, \"Found and initialized AR5523 device\\n\");\n\treturn 0;\n\nout_cancel_rx_cmd:\n\tar5523_cancel_rx_cmd(ar);\nout_free_tx_cmd:\n\tar5523_free_tx_cmd(ar);\nout_free_rx_cmd:\n\tar5523_free_rx_cmd(ar);\nout_free_rx_bufs:\n\tar5523_free_rx_bufs(ar);\nout_free_wq:\n\tdestroy_workqueue(ar->wq);\nout_free_ar:\n\tieee80211_free_hw(hw);\nout:\n\treturn error;\n}\n\nstatic void ar5523_disconnect(struct usb_interface *intf)\n{\n\tstruct ieee80211_hw *hw = usb_get_intfdata(intf);\n\tstruct ar5523 *ar = hw->priv;\n\n\tar5523_dbg(ar, \"detaching\\n\");\n\tset_bit(AR5523_USB_DISCONNECTED, &ar->flags);\n\n\tieee80211_unregister_hw(hw);\n\n\tar5523_cancel_rx_cmd(ar);\n\tar5523_free_tx_cmd(ar);\n\tar5523_free_rx_cmd(ar);\n\tar5523_free_rx_bufs(ar);\n\n\tdestroy_workqueue(ar->wq);\n\n\tieee80211_free_hw(hw);\n\tusb_set_intfdata(intf, NULL);\n}\n\n#define AR5523_DEVICE_UG(vendor, device) \\\n\t{ USB_DEVICE((vendor), (device)) }, \\\n\t{ USB_DEVICE((vendor), (device) + 1), \\\n\t\t.driver_info = AR5523_FLAG_PRE_FIRMWARE }\n#define AR5523_DEVICE_UX(vendor, device) \\\n\t{ USB_DEVICE((vendor), (device)), \\\n\t\t.driver_info = AR5523_FLAG_ABG }, \\\n\t{ USB_DEVICE((vendor), (device) + 1), \\\n\t\t.driver_info = AR5523_FLAG_ABG|AR5523_FLAG_PRE_FIRMWARE }\n\nstatic const struct usb_device_id ar5523_id_table[] = {\n\tAR5523_DEVICE_UG(0x168c, 0x0001),\t \n\tAR5523_DEVICE_UG(0x0cf3, 0x0001),\t \n\tAR5523_DEVICE_UG(0x0cf3, 0x0003),\t \n\tAR5523_DEVICE_UX(0x0cf3, 0x0005),\t \n\tAR5523_DEVICE_UG(0x0d8e, 0x7801),\t \n\tAR5523_DEVICE_UX(0x0d8e, 0x7811),\t \n\tAR5523_DEVICE_UX(0x2001, 0x3a00),\t \n\tAR5523_DEVICE_UG(0x2001, 0x3a02),\t \n\tAR5523_DEVICE_UX(0x2001, 0x3a04),\t \n\tAR5523_DEVICE_UG(0x07d1, 0x3a07),\t \n\tAR5523_DEVICE_UG(0x1690, 0x0712),\t \n\tAR5523_DEVICE_UG(0x1690, 0x0710),\t \n\tAR5523_DEVICE_UG(0x129b, 0x160b),\t \n\tAR5523_DEVICE_UG(0x16ab, 0x7801),\t \n\tAR5523_DEVICE_UX(0x16ab, 0x7811),\t \n\tAR5523_DEVICE_UG(0x0d8e, 0x7802),\t \n\tAR5523_DEVICE_UX(0x0846, 0x4300),\t \n\tAR5523_DEVICE_UG(0x0846, 0x4250),\t \n\tAR5523_DEVICE_UG(0x0846, 0x5f00),\t \n\tAR5523_DEVICE_UG(0x083a, 0x4506),\t \n\tAR5523_DEVICE_UG(0x157e, 0x3006),\t \n\tAR5523_DEVICE_UX(0x157e, 0x3205),\t \n\tAR5523_DEVICE_UG(0x1435, 0x0826),\t \n\tAR5523_DEVICE_UX(0x1435, 0x0828),\t \n\tAR5523_DEVICE_UG(0x0cde, 0x0012),\t \n\tAR5523_DEVICE_UG(0x1385, 0x4250),\t \n\tAR5523_DEVICE_UG(0x1385, 0x5f00),\t \n\tAR5523_DEVICE_UG(0x1385, 0x5f02),\t \n\t{ }\n};\nMODULE_DEVICE_TABLE(usb, ar5523_id_table);\n\nstatic struct usb_driver ar5523_driver = {\n\t.name\t\t= \"ar5523\",\n\t.id_table\t= ar5523_id_table,\n\t.probe\t\t= ar5523_probe,\n\t.disconnect\t= ar5523_disconnect,\n};\n\nmodule_usb_driver(ar5523_driver);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_FIRMWARE(AR5523_FIRMWARE_FILE);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}