{
  "module_name": "dfs_pri_detector.c",
  "hash_id": "9b66da6338faa0efac76b935bf0692d11464a608843d813e16665ee245d51c60",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/dfs_pri_detector.c",
  "human_readable_source": " \n\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n#include \"ath.h\"\n#include \"dfs_pattern_detector.h\"\n#include \"dfs_pri_detector.h\"\n\nstruct ath_dfs_pool_stats global_dfs_pool_stats = {};\n\n#define DFS_POOL_STAT_INC(c) (global_dfs_pool_stats.c++)\n#define DFS_POOL_STAT_DEC(c) (global_dfs_pool_stats.c--)\n#define GET_PRI_TO_USE(MIN, MAX, RUNTIME) \\\n\t(MIN + PRI_TOLERANCE == MAX - PRI_TOLERANCE ? \\\n\tMIN + PRI_TOLERANCE : RUNTIME)\n\n \nstruct pulse_elem {\n\tstruct list_head head;\n\tu64 ts;\n};\n\n \nstatic u32 pde_get_multiple(u32 val, u32 fraction, u32 tolerance)\n{\n\tu32 remainder;\n\tu32 factor;\n\tu32 delta;\n\n\tif (fraction == 0)\n\t\treturn 0;\n\n\tdelta = (val < fraction) ? (fraction - val) : (val - fraction);\n\n\tif (delta <= tolerance)\n\t\t \n\t\treturn 1;\n\n\tfactor = val / fraction;\n\tremainder = val % fraction;\n\tif (remainder > tolerance) {\n\t\t \n\t\tif ((fraction - remainder) <= tolerance)\n\t\t\t \n\t\t\tfactor++;\n\t\telse\n\t\t\tfactor = 0;\n\t}\n\treturn factor;\n}\n\n \nstatic u32 singleton_pool_references;\nstatic LIST_HEAD(pulse_pool);\nstatic LIST_HEAD(pseq_pool);\nstatic DEFINE_SPINLOCK(pool_lock);\n\nstatic void pool_register_ref(void)\n{\n\tspin_lock_bh(&pool_lock);\n\tsingleton_pool_references++;\n\tDFS_POOL_STAT_INC(pool_reference);\n\tspin_unlock_bh(&pool_lock);\n}\n\nstatic void pool_deregister_ref(void)\n{\n\tspin_lock_bh(&pool_lock);\n\tsingleton_pool_references--;\n\tDFS_POOL_STAT_DEC(pool_reference);\n\tif (singleton_pool_references == 0) {\n\t\t \n\t\tstruct pri_sequence *ps, *ps0;\n\t\tstruct pulse_elem *p, *p0;\n\n\t\tlist_for_each_entry_safe(p, p0, &pulse_pool, head) {\n\t\t\tlist_del(&p->head);\n\t\t\tDFS_POOL_STAT_DEC(pulse_allocated);\n\t\t\tkfree(p);\n\t\t}\n\t\tlist_for_each_entry_safe(ps, ps0, &pseq_pool, head) {\n\t\t\tlist_del(&ps->head);\n\t\t\tDFS_POOL_STAT_DEC(pseq_allocated);\n\t\t\tkfree(ps);\n\t\t}\n\t}\n\tspin_unlock_bh(&pool_lock);\n}\n\nstatic void pool_put_pulse_elem(struct pulse_elem *pe)\n{\n\tspin_lock_bh(&pool_lock);\n\tlist_add(&pe->head, &pulse_pool);\n\tDFS_POOL_STAT_DEC(pulse_used);\n\tspin_unlock_bh(&pool_lock);\n}\n\nstatic void pool_put_pseq_elem(struct pri_sequence *pse)\n{\n\tspin_lock_bh(&pool_lock);\n\tlist_add(&pse->head, &pseq_pool);\n\tDFS_POOL_STAT_DEC(pseq_used);\n\tspin_unlock_bh(&pool_lock);\n}\n\nstatic struct pri_sequence *pool_get_pseq_elem(void)\n{\n\tstruct pri_sequence *pse = NULL;\n\tspin_lock_bh(&pool_lock);\n\tif (!list_empty(&pseq_pool)) {\n\t\tpse = list_first_entry(&pseq_pool, struct pri_sequence, head);\n\t\tlist_del(&pse->head);\n\t\tDFS_POOL_STAT_INC(pseq_used);\n\t}\n\tspin_unlock_bh(&pool_lock);\n\treturn pse;\n}\n\nstatic struct pulse_elem *pool_get_pulse_elem(void)\n{\n\tstruct pulse_elem *pe = NULL;\n\tspin_lock_bh(&pool_lock);\n\tif (!list_empty(&pulse_pool)) {\n\t\tpe = list_first_entry(&pulse_pool, struct pulse_elem, head);\n\t\tlist_del(&pe->head);\n\t\tDFS_POOL_STAT_INC(pulse_used);\n\t}\n\tspin_unlock_bh(&pool_lock);\n\treturn pe;\n}\n\nstatic struct pulse_elem *pulse_queue_get_tail(struct pri_detector *pde)\n{\n\tstruct list_head *l = &pde->pulses;\n\tif (list_empty(l))\n\t\treturn NULL;\n\treturn list_entry(l->prev, struct pulse_elem, head);\n}\n\nstatic bool pulse_queue_dequeue(struct pri_detector *pde)\n{\n\tstruct pulse_elem *p = pulse_queue_get_tail(pde);\n\tif (p != NULL) {\n\t\tlist_del_init(&p->head);\n\t\tpde->count--;\n\t\t \n\t\tpool_put_pulse_elem(p);\n\t}\n\treturn (pde->count > 0);\n}\n\n \nstatic void pulse_queue_check_window(struct pri_detector *pde)\n{\n\tu64 min_valid_ts;\n\tstruct pulse_elem *p;\n\n\t \n\tif (pde->count < 2)\n\t\treturn;\n\n\tif (pde->last_ts <= pde->window_size)\n\t\treturn;\n\n\tmin_valid_ts = pde->last_ts - pde->window_size;\n\twhile ((p = pulse_queue_get_tail(pde)) != NULL) {\n\t\tif (p->ts >= min_valid_ts)\n\t\t\treturn;\n\t\tpulse_queue_dequeue(pde);\n\t}\n}\n\nstatic bool pulse_queue_enqueue(struct pri_detector *pde, u64 ts)\n{\n\tstruct pulse_elem *p = pool_get_pulse_elem();\n\tif (p == NULL) {\n\t\tp = kmalloc(sizeof(*p), GFP_ATOMIC);\n\t\tif (p == NULL) {\n\t\t\tDFS_POOL_STAT_INC(pulse_alloc_error);\n\t\t\treturn false;\n\t\t}\n\t\tDFS_POOL_STAT_INC(pulse_allocated);\n\t\tDFS_POOL_STAT_INC(pulse_used);\n\t}\n\tINIT_LIST_HEAD(&p->head);\n\tp->ts = ts;\n\tlist_add(&p->head, &pde->pulses);\n\tpde->count++;\n\tpde->last_ts = ts;\n\tpulse_queue_check_window(pde);\n\tif (pde->count >= pde->max_count)\n\t\tpulse_queue_dequeue(pde);\n\treturn true;\n}\n\nstatic bool pseq_handler_create_sequences(struct pri_detector *pde,\n\t\t\t\t\t  u64 ts, u32 min_count)\n{\n\tstruct pulse_elem *p;\n\tlist_for_each_entry(p, &pde->pulses, head) {\n\t\tstruct pri_sequence ps, *new_ps;\n\t\tstruct pulse_elem *p2;\n\t\tu32 tmp_false_count;\n\t\tu64 min_valid_ts;\n\t\tu32 delta_ts = ts - p->ts;\n\n\t\tif (delta_ts < pde->rs->pri_min)\n\t\t\t \n\t\t\tcontinue;\n\n\t\tif (delta_ts > pde->rs->pri_max)\n\t\t\t \n\t\t\tbreak;\n\n\t\t \n\t\tps.count = 2;\n\t\tps.count_falses = 0;\n\t\tps.first_ts = p->ts;\n\t\tps.last_ts = ts;\n\t\tps.pri = GET_PRI_TO_USE(pde->rs->pri_min,\n\t\t\tpde->rs->pri_max, ts - p->ts);\n\t\tps.dur = ps.pri * (pde->rs->ppb - 1)\n\t\t\t\t+ 2 * pde->rs->max_pri_tolerance;\n\n\t\tp2 = p;\n\t\ttmp_false_count = 0;\n\t\tmin_valid_ts = ts - ps.dur;\n\t\t \n\t\tlist_for_each_entry_continue(p2, &pde->pulses, head) {\n\t\t\tu32 factor;\n\t\t\tif (p2->ts < min_valid_ts)\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t \n\t\t\tfactor = pde_get_multiple(ps.last_ts - p2->ts, ps.pri,\n\t\t\t\t\t\t  pde->rs->max_pri_tolerance);\n\t\t\tif (factor > 0) {\n\t\t\t\tps.count++;\n\t\t\t\tps.first_ts = p2->ts;\n\t\t\t\t \n\t\t\t\tps.count_falses += tmp_false_count;\n\t\t\t\ttmp_false_count = 0;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\ttmp_false_count++;\n\t\t\t}\n\t\t}\n\t\tif (ps.count <= min_count)\n\t\t\t \n\t\t\tcontinue;\n\n\t\t \n\t\tps.deadline_ts = ps.first_ts + ps.dur;\n\t\tnew_ps = pool_get_pseq_elem();\n\t\tif (new_ps == NULL) {\n\t\t\tnew_ps = kmalloc(sizeof(*new_ps), GFP_ATOMIC);\n\t\t\tif (new_ps == NULL) {\n\t\t\t\tDFS_POOL_STAT_INC(pseq_alloc_error);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tDFS_POOL_STAT_INC(pseq_allocated);\n\t\t\tDFS_POOL_STAT_INC(pseq_used);\n\t\t}\n\t\tmemcpy(new_ps, &ps, sizeof(ps));\n\t\tINIT_LIST_HEAD(&new_ps->head);\n\t\tlist_add(&new_ps->head, &pde->sequences);\n\t}\n\treturn true;\n}\n\n \nstatic u32\npseq_handler_add_to_existing_seqs(struct pri_detector *pde, u64 ts)\n{\n\tu32 max_count = 0;\n\tstruct pri_sequence *ps, *ps2;\n\tlist_for_each_entry_safe(ps, ps2, &pde->sequences, head) {\n\t\tu32 delta_ts;\n\t\tu32 factor;\n\n\t\t \n\t\tif (ts > ps->deadline_ts) {\n\t\t\tlist_del_init(&ps->head);\n\t\t\tpool_put_pseq_elem(ps);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdelta_ts = ts - ps->last_ts;\n\t\tfactor = pde_get_multiple(delta_ts, ps->pri,\n\t\t\t\t\t  pde->rs->max_pri_tolerance);\n\t\tif (factor > 0) {\n\t\t\tps->last_ts = ts;\n\t\t\tps->count++;\n\n\t\t\tif (max_count < ps->count)\n\t\t\t\tmax_count = ps->count;\n\t\t} else {\n\t\t\tps->count_falses++;\n\t\t}\n\t}\n\treturn max_count;\n}\n\nstatic struct pri_sequence *\npseq_handler_check_detection(struct pri_detector *pde)\n{\n\tstruct pri_sequence *ps;\n\n\tif (list_empty(&pde->sequences))\n\t\treturn NULL;\n\n\tlist_for_each_entry(ps, &pde->sequences, head) {\n\t\t \n\t\tif ((ps->count >= pde->rs->ppb_thresh) &&\n\t\t    (ps->count * pde->rs->num_pri >= ps->count_falses))\n\t\t\treturn ps;\n\t}\n\treturn NULL;\n}\n\n\n \nstatic void pri_detector_reset(struct pri_detector *pde, u64 ts)\n{\n\tstruct pri_sequence *ps, *ps0;\n\tstruct pulse_elem *p, *p0;\n\tlist_for_each_entry_safe(ps, ps0, &pde->sequences, head) {\n\t\tlist_del_init(&ps->head);\n\t\tpool_put_pseq_elem(ps);\n\t}\n\tlist_for_each_entry_safe(p, p0, &pde->pulses, head) {\n\t\tlist_del_init(&p->head);\n\t\tpool_put_pulse_elem(p);\n\t}\n\tpde->count = 0;\n\tpde->last_ts = ts;\n}\n\nstatic void pri_detector_exit(struct pri_detector *de)\n{\n\tpri_detector_reset(de, 0);\n\tpool_deregister_ref();\n\tkfree(de);\n}\n\nstatic struct pri_sequence *pri_detector_add_pulse(struct pri_detector *de,\n\t\t\t\t\t\t   struct pulse_event *event)\n{\n\tu32 max_updated_seq;\n\tstruct pri_sequence *ps;\n\tu64 ts = event->ts;\n\tconst struct radar_detector_specs *rs = de->rs;\n\n\t \n\tif ((rs->width_min > event->width) || (rs->width_max < event->width))\n\t\treturn NULL;\n\n\tif ((ts - de->last_ts) < rs->max_pri_tolerance)\n\t\t \n\t\treturn NULL;\n\t \n\tif (rs->chirp && rs->chirp != event->chirp)\n\t\treturn NULL;\n\n\tde->last_ts = ts;\n\n\tmax_updated_seq = pseq_handler_add_to_existing_seqs(de, ts);\n\n\tif (!pseq_handler_create_sequences(de, ts, max_updated_seq)) {\n\t\tpri_detector_reset(de, ts);\n\t\treturn NULL;\n\t}\n\n\tps = pseq_handler_check_detection(de);\n\n\tif (ps == NULL)\n\t\tpulse_queue_enqueue(de, ts);\n\n\treturn ps;\n}\n\nstruct pri_detector *pri_detector_init(const struct radar_detector_specs *rs)\n{\n\tstruct pri_detector *de;\n\n\tde = kzalloc(sizeof(*de), GFP_ATOMIC);\n\tif (de == NULL)\n\t\treturn NULL;\n\tde->exit = pri_detector_exit;\n\tde->add_pulse = pri_detector_add_pulse;\n\tde->reset = pri_detector_reset;\n\n\tINIT_LIST_HEAD(&de->sequences);\n\tINIT_LIST_HEAD(&de->pulses);\n\tde->window_size = rs->pri_max * rs->ppb * rs->num_pri;\n\tde->max_count = rs->ppb * 2;\n\tde->rs = rs;\n\n\tpool_register_ref();\n\treturn de;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}