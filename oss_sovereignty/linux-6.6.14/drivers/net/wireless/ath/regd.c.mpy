{
  "module_name": "regd.c",
  "hash_id": "afc364518bcdd0e61b15b0c45ea8ad175121d8ff43acea93075c8b2d81912e00",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/regd.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <net/cfg80211.h>\n#include <net/mac80211.h>\n#include \"regd.h\"\n#include \"regd_common.h\"\n\nstatic int __ath_regd_init(struct ath_regulatory *reg);\n\n \n\n \n#define ATH_2GHZ_CH01_11\tREG_RULE(2412-10, 2462+10, 40, 0, 20, 0)\n\n \n#define ATH_2GHZ_CH12_13\tREG_RULE(2467-10, 2472+10, 40, 0, 20,\\\n\t\t\t\t\t NL80211_RRF_NO_IR)\n#define ATH_2GHZ_CH14\t\tREG_RULE(2484-10, 2484+10, 40, 0, 20,\\\n\t\t\t\t\t NL80211_RRF_NO_IR | \\\n\t\t\t\t\t NL80211_RRF_NO_OFDM)\n\n \n#define ATH_5GHZ_5150_5350\tREG_RULE(5150-10, 5350+10, 80, 0, 30,\\\n\t\t\t\t\t NL80211_RRF_NO_IR)\n#define ATH_5GHZ_5470_5850\tREG_RULE(5470-10, 5850+10, 80, 0, 30,\\\n\t\t\t\t\t NL80211_RRF_NO_IR)\n#define ATH_5GHZ_5725_5850\tREG_RULE(5725-10, 5850+10, 80, 0, 30,\\\n\t\t\t\t\t NL80211_RRF_NO_IR)\n\n#define ATH_2GHZ_ALL\t\tATH_2GHZ_CH01_11, \\\n\t\t\t\tATH_2GHZ_CH12_13, \\\n\t\t\t\tATH_2GHZ_CH14\n\n#define ATH_5GHZ_ALL\t\tATH_5GHZ_5150_5350, \\\n\t\t\t\tATH_5GHZ_5470_5850\n\n \n#define ATH_5GHZ_NO_MIDBAND\tATH_5GHZ_5150_5350, \\\n\t\t\t\tATH_5GHZ_5725_5850\n\n \nstatic const struct ieee80211_regdomain ath_world_regdom_60_61_62 = {\n\t.n_reg_rules = 5,\n\t.alpha2 =  \"99\",\n\t.reg_rules = {\n\t\tATH_2GHZ_ALL,\n\t\tATH_5GHZ_ALL,\n\t}\n};\n\n \nstatic const struct ieee80211_regdomain ath_world_regdom_63_65 = {\n\t.n_reg_rules = 4,\n\t.alpha2 =  \"99\",\n\t.reg_rules = {\n\t\tATH_2GHZ_CH01_11,\n\t\tATH_2GHZ_CH12_13,\n\t\tATH_5GHZ_NO_MIDBAND,\n\t}\n};\n\n \nstatic const struct ieee80211_regdomain ath_world_regdom_64 = {\n\t.n_reg_rules = 3,\n\t.alpha2 =  \"99\",\n\t.reg_rules = {\n\t\tATH_2GHZ_CH01_11,\n\t\tATH_5GHZ_NO_MIDBAND,\n\t}\n};\n\n \nstatic const struct ieee80211_regdomain ath_world_regdom_66_69 = {\n\t.n_reg_rules = 3,\n\t.alpha2 =  \"99\",\n\t.reg_rules = {\n\t\tATH_2GHZ_CH01_11,\n\t\tATH_5GHZ_ALL,\n\t}\n};\n\n \nstatic const struct ieee80211_regdomain ath_world_regdom_67_68_6A_6C = {\n\t.n_reg_rules = 4,\n\t.alpha2 =  \"99\",\n\t.reg_rules = {\n\t\tATH_2GHZ_CH01_11,\n\t\tATH_2GHZ_CH12_13,\n\t\tATH_5GHZ_ALL,\n\t}\n};\n\nstatic bool dynamic_country_user_possible(struct ath_regulatory *reg)\n{\n\tif (IS_ENABLED(CONFIG_ATH_REG_DYNAMIC_USER_CERT_TESTING))\n\t\treturn true;\n\n\tswitch (reg->country_code) {\n\tcase CTRY_UNITED_STATES:\n\tcase CTRY_JAPAN1:\n\tcase CTRY_JAPAN2:\n\tcase CTRY_JAPAN3:\n\tcase CTRY_JAPAN4:\n\tcase CTRY_JAPAN5:\n\tcase CTRY_JAPAN6:\n\tcase CTRY_JAPAN7:\n\tcase CTRY_JAPAN8:\n\tcase CTRY_JAPAN9:\n\tcase CTRY_JAPAN10:\n\tcase CTRY_JAPAN11:\n\tcase CTRY_JAPAN12:\n\tcase CTRY_JAPAN13:\n\tcase CTRY_JAPAN14:\n\tcase CTRY_JAPAN15:\n\tcase CTRY_JAPAN16:\n\tcase CTRY_JAPAN17:\n\tcase CTRY_JAPAN18:\n\tcase CTRY_JAPAN19:\n\tcase CTRY_JAPAN20:\n\tcase CTRY_JAPAN21:\n\tcase CTRY_JAPAN22:\n\tcase CTRY_JAPAN23:\n\tcase CTRY_JAPAN24:\n\tcase CTRY_JAPAN25:\n\tcase CTRY_JAPAN26:\n\tcase CTRY_JAPAN27:\n\tcase CTRY_JAPAN28:\n\tcase CTRY_JAPAN29:\n\tcase CTRY_JAPAN30:\n\tcase CTRY_JAPAN31:\n\tcase CTRY_JAPAN32:\n\tcase CTRY_JAPAN33:\n\tcase CTRY_JAPAN34:\n\tcase CTRY_JAPAN35:\n\tcase CTRY_JAPAN36:\n\tcase CTRY_JAPAN37:\n\tcase CTRY_JAPAN38:\n\tcase CTRY_JAPAN39:\n\tcase CTRY_JAPAN40:\n\tcase CTRY_JAPAN41:\n\tcase CTRY_JAPAN42:\n\tcase CTRY_JAPAN43:\n\tcase CTRY_JAPAN44:\n\tcase CTRY_JAPAN45:\n\tcase CTRY_JAPAN46:\n\tcase CTRY_JAPAN47:\n\tcase CTRY_JAPAN48:\n\tcase CTRY_JAPAN49:\n\tcase CTRY_JAPAN50:\n\tcase CTRY_JAPAN51:\n\tcase CTRY_JAPAN52:\n\tcase CTRY_JAPAN53:\n\tcase CTRY_JAPAN54:\n\tcase CTRY_JAPAN55:\n\tcase CTRY_JAPAN56:\n\tcase CTRY_JAPAN57:\n\tcase CTRY_JAPAN58:\n\tcase CTRY_JAPAN59:\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool ath_reg_dyn_country_user_allow(struct ath_regulatory *reg)\n{\n\tif (!IS_ENABLED(CONFIG_ATH_REG_DYNAMIC_USER_REG_HINTS))\n\t\treturn false;\n\tif (!dynamic_country_user_possible(reg))\n\t\treturn false;\n\treturn true;\n}\n\nstatic inline bool is_wwr_sku(u16 regd)\n{\n\treturn ((regd & COUNTRY_ERD_FLAG) != COUNTRY_ERD_FLAG) &&\n\t\t(((regd & WORLD_SKU_MASK) == WORLD_SKU_PREFIX) ||\n\t\t(regd == WORLD));\n}\n\nstatic u16 ath_regd_get_eepromRD(struct ath_regulatory *reg)\n{\n\treturn reg->current_rd & ~WORLDWIDE_ROAMING_FLAG;\n}\n\nbool ath_is_world_regd(struct ath_regulatory *reg)\n{\n\treturn is_wwr_sku(ath_regd_get_eepromRD(reg));\n}\nEXPORT_SYMBOL(ath_is_world_regd);\n\nstatic const struct ieee80211_regdomain *ath_default_world_regdomain(void)\n{\n\t \n\treturn &ath_world_regdom_64;\n}\n\nstatic const struct\nieee80211_regdomain *ath_world_regdomain(struct ath_regulatory *reg)\n{\n\tswitch (reg->regpair->reg_domain) {\n\tcase 0x60:\n\tcase 0x61:\n\tcase 0x62:\n\t\treturn &ath_world_regdom_60_61_62;\n\tcase 0x63:\n\tcase 0x65:\n\t\treturn &ath_world_regdom_63_65;\n\tcase 0x64:\n\t\treturn &ath_world_regdom_64;\n\tcase 0x66:\n\tcase 0x69:\n\t\treturn &ath_world_regdom_66_69;\n\tcase 0x67:\n\tcase 0x68:\n\tcase 0x6A:\n\tcase 0x6C:\n\t\treturn &ath_world_regdom_67_68_6A_6C;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn ath_default_world_regdomain();\n\t}\n}\n\nbool ath_is_49ghz_allowed(u16 regdomain)\n{\n\t \n\treturn regdomain == MKK9_MKKC;\n}\nEXPORT_SYMBOL(ath_is_49ghz_allowed);\n\n \nstatic bool ath_is_radar_freq(u16 center_freq,\n\t\t\t      struct ath_regulatory *reg)\n\n{\n\tif (reg->country_code == CTRY_INDIA)\n\t\treturn (center_freq >= 5500 && center_freq <= 5700);\n\treturn (center_freq >= 5260 && center_freq <= 5700);\n}\n\nstatic void ath_force_clear_no_ir_chan(struct wiphy *wiphy,\n\t\t\t\t       struct ieee80211_channel *ch)\n{\n\tconst struct ieee80211_reg_rule *reg_rule;\n\n\treg_rule = freq_reg_info(wiphy, MHZ_TO_KHZ(ch->center_freq));\n\tif (IS_ERR(reg_rule))\n\t\treturn;\n\n\tif (!(reg_rule->flags & NL80211_RRF_NO_IR))\n\t\tif (ch->flags & IEEE80211_CHAN_NO_IR)\n\t\t\tch->flags &= ~IEEE80211_CHAN_NO_IR;\n}\n\nstatic void ath_force_clear_no_ir_freq(struct wiphy *wiphy, u16 center_freq)\n{\n\tstruct ieee80211_channel *ch;\n\n\tch = ieee80211_get_channel(wiphy, center_freq);\n\tif (!ch)\n\t\treturn;\n\n\tath_force_clear_no_ir_chan(wiphy, ch);\n}\n\nstatic void ath_force_no_ir_chan(struct ieee80211_channel *ch)\n{\n\tch->flags |= IEEE80211_CHAN_NO_IR;\n}\n\nstatic void ath_force_no_ir_freq(struct wiphy *wiphy, u16 center_freq)\n{\n\tstruct ieee80211_channel *ch;\n\n\tch = ieee80211_get_channel(wiphy, center_freq);\n\tif (!ch)\n\t\treturn;\n\n\tath_force_no_ir_chan(ch);\n}\n\nstatic void\n__ath_reg_apply_beaconing_flags(struct wiphy *wiphy,\n\t\t\t\tstruct ath_regulatory *reg,\n\t\t\t\tenum nl80211_reg_initiator initiator,\n\t\t\t\tstruct ieee80211_channel *ch)\n{\n\tif (ath_is_radar_freq(ch->center_freq, reg) ||\n\t    (ch->flags & IEEE80211_CHAN_RADAR))\n\t\treturn;\n\n\tswitch (initiator) {\n\tcase NL80211_REGDOM_SET_BY_COUNTRY_IE:\n\t\tath_force_clear_no_ir_chan(wiphy, ch);\n\t\tbreak;\n\tcase NL80211_REGDOM_SET_BY_USER:\n\t\tif (ath_reg_dyn_country_user_allow(reg))\n\t\t\tath_force_clear_no_ir_chan(wiphy, ch);\n\t\tbreak;\n\tdefault:\n\t\tif (ch->beacon_found)\n\t\t\tch->flags &= ~IEEE80211_CHAN_NO_IR;\n\t}\n}\n\n \nstatic void\nath_reg_apply_beaconing_flags(struct wiphy *wiphy,\n\t\t\t      struct ath_regulatory *reg,\n\t\t\t      enum nl80211_reg_initiator initiator)\n{\n\tenum nl80211_band band;\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_channel *ch;\n\tunsigned int i;\n\n\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\tif (!wiphy->bands[band])\n\t\t\tcontinue;\n\t\tsband = wiphy->bands[band];\n\t\tfor (i = 0; i < sband->n_channels; i++) {\n\t\t\tch = &sband->channels[i];\n\t\t\t__ath_reg_apply_beaconing_flags(wiphy, reg,\n\t\t\t\t\t\t\tinitiator, ch);\n\t\t}\n\t}\n}\n\n \nstatic void\nath_reg_apply_ir_flags(struct wiphy *wiphy,\n\t\t       struct ath_regulatory *reg,\n\t\t       enum nl80211_reg_initiator initiator)\n{\n\tstruct ieee80211_supported_band *sband;\n\n\tsband = wiphy->bands[NL80211_BAND_2GHZ];\n\tif (!sband)\n\t\treturn;\n\n\tswitch(initiator) {\n\tcase NL80211_REGDOM_SET_BY_COUNTRY_IE:\n\t\tath_force_clear_no_ir_freq(wiphy, 2467);\n\t\tath_force_clear_no_ir_freq(wiphy, 2472);\n\t\tbreak;\n\tcase NL80211_REGDOM_SET_BY_USER:\n\t\tif (!ath_reg_dyn_country_user_allow(reg))\n\t\t\tbreak;\n\t\tath_force_clear_no_ir_freq(wiphy, 2467);\n\t\tath_force_clear_no_ir_freq(wiphy, 2472);\n\t\tbreak;\n\tdefault:\n\t\tath_force_no_ir_freq(wiphy, 2467);\n\t\tath_force_no_ir_freq(wiphy, 2472);\n\t}\n}\n\n \nstatic void ath_reg_apply_radar_flags(struct wiphy *wiphy,\n\t\t\t\t      struct ath_regulatory *reg)\n{\n\tstruct ieee80211_supported_band *sband;\n\tstruct ieee80211_channel *ch;\n\tunsigned int i;\n\n\tif (!wiphy->bands[NL80211_BAND_5GHZ])\n\t\treturn;\n\n\tsband = wiphy->bands[NL80211_BAND_5GHZ];\n\n\tfor (i = 0; i < sband->n_channels; i++) {\n\t\tch = &sband->channels[i];\n\t\tif (!ath_is_radar_freq(ch->center_freq, reg))\n\t\t\tcontinue;\n\t\t \n\t\tif (!(ch->flags & IEEE80211_CHAN_DISABLED))\n\t\t\tch->flags |= IEEE80211_CHAN_RADAR |\n\t\t\t\t     IEEE80211_CHAN_NO_IR;\n\t}\n}\n\nstatic void ath_reg_apply_world_flags(struct wiphy *wiphy,\n\t\t\t\t      enum nl80211_reg_initiator initiator,\n\t\t\t\t      struct ath_regulatory *reg)\n{\n\tswitch (reg->regpair->reg_domain) {\n\tcase 0x60:\n\tcase 0x63:\n\tcase 0x66:\n\tcase 0x67:\n\tcase 0x6C:\n\t\tath_reg_apply_beaconing_flags(wiphy, reg, initiator);\n\t\tbreak;\n\tcase 0x68:\n\t\tath_reg_apply_beaconing_flags(wiphy, reg, initiator);\n\t\tath_reg_apply_ir_flags(wiphy, reg, initiator);\n\t\tbreak;\n\tdefault:\n\t\tif (ath_reg_dyn_country_user_allow(reg))\n\t\t\tath_reg_apply_beaconing_flags(wiphy, reg, initiator);\n\t}\n}\n\nu16 ath_regd_find_country_by_name(char *alpha2)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(allCountries); i++) {\n\t\tif (!memcmp(allCountries[i].isoName, alpha2, 2))\n\t\t\treturn allCountries[i].countryCode;\n\t}\n\n\treturn -1;\n}\nEXPORT_SYMBOL(ath_regd_find_country_by_name);\n\nstatic int __ath_reg_dyn_country(struct wiphy *wiphy,\n\t\t\t\t struct ath_regulatory *reg,\n\t\t\t\t struct regulatory_request *request)\n{\n\tu16 country_code;\n\n\tif (request->initiator == NL80211_REGDOM_SET_BY_COUNTRY_IE &&\n\t    !ath_is_world_regd(reg))\n\t\treturn -EINVAL;\n\n\tcountry_code = ath_regd_find_country_by_name(request->alpha2);\n\tif (country_code == (u16) -1)\n\t\treturn -EINVAL;\n\n\treg->current_rd = COUNTRY_ERD_FLAG;\n\treg->current_rd |= country_code;\n\n\t__ath_regd_init(reg);\n\n\tath_reg_apply_world_flags(wiphy, request->initiator, reg);\n\n\treturn 0;\n}\n\nstatic void ath_reg_dyn_country(struct wiphy *wiphy,\n\t\t\t\tstruct ath_regulatory *reg,\n\t\t\t\tstruct regulatory_request *request)\n{\n\tif (__ath_reg_dyn_country(wiphy, reg, request))\n\t\treturn;\n\n\tprintk(KERN_DEBUG \"ath: regdomain 0x%0x \"\n\t\t\t  \"dynamically updated by %s\\n\",\n\t       reg->current_rd,\n\t       reg_initiator_name(request->initiator));\n}\n\nvoid ath_reg_notifier_apply(struct wiphy *wiphy,\n\t\t\t    struct regulatory_request *request,\n\t\t\t    struct ath_regulatory *reg)\n{\n\tstruct ath_common *common = container_of(reg, struct ath_common,\n\t\t\t\t\t\t regulatory);\n\t \n\tath_reg_apply_radar_flags(wiphy, reg);\n\n\t \n\tif (!request)\n\t\treturn;\n\n\treg->region = request->dfs_region;\n\tswitch (request->initiator) {\n\tcase NL80211_REGDOM_SET_BY_CORE:\n\t\t \n\t\tif (!ath_is_world_regd(&common->reg_world_copy))\n\t\t\tbreak;\n\n\t\tmemcpy(reg, &common->reg_world_copy,\n\t\t       sizeof(struct ath_regulatory));\n\t\tbreak;\n\tcase NL80211_REGDOM_SET_BY_DRIVER:\n\t\tbreak;\n\tcase NL80211_REGDOM_SET_BY_USER:\n\t\tif (ath_reg_dyn_country_user_allow(reg))\n\t\t\tath_reg_dyn_country(wiphy, reg, request);\n\t\tbreak;\n\tcase NL80211_REGDOM_SET_BY_COUNTRY_IE:\n\t\tath_reg_dyn_country(wiphy, reg, request);\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL(ath_reg_notifier_apply);\n\nstatic bool ath_regd_is_eeprom_valid(struct ath_regulatory *reg)\n{\n\tu16 rd = ath_regd_get_eepromRD(reg);\n\tint i;\n\n\tif (rd & COUNTRY_ERD_FLAG) {\n\t\t \n\t\tu16 cc = rd & ~COUNTRY_ERD_FLAG;\n\t\tprintk(KERN_DEBUG\n\t\t       \"ath: EEPROM indicates we should expect \"\n\t\t\t\"a country code\\n\");\n\t\tfor (i = 0; i < ARRAY_SIZE(allCountries); i++)\n\t\t\tif (allCountries[i].countryCode == cc)\n\t\t\t\treturn true;\n\t} else {\n\t\t \n\t\tif (rd != CTRY_DEFAULT)\n\t\t\tprintk(KERN_DEBUG \"ath: EEPROM indicates we \"\n\t\t\t       \"should expect a direct regpair map\\n\");\n\t\tfor (i = 0; i < ARRAY_SIZE(regDomainPairs); i++)\n\t\t\tif (regDomainPairs[i].reg_domain == rd)\n\t\t\t\treturn true;\n\t}\n\tprintk(KERN_DEBUG\n\t\t \"ath: invalid regulatory domain/country code 0x%x\\n\", rd);\n\treturn false;\n}\n\n \nstatic struct country_code_to_enum_rd*\nath_regd_find_country(u16 countryCode)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(allCountries); i++) {\n\t\tif (allCountries[i].countryCode == countryCode)\n\t\t\treturn &allCountries[i];\n\t}\n\treturn NULL;\n}\n\n \nstatic struct country_code_to_enum_rd*\nath_regd_find_country_by_rd(int regdmn)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(allCountries); i++) {\n\t\tif (allCountries[i].regDmnEnum == regdmn)\n\t\t\treturn &allCountries[i];\n\t}\n\treturn NULL;\n}\n\n \nstatic u16 ath_regd_get_default_country(u16 rd)\n{\n\tif (rd & COUNTRY_ERD_FLAG) {\n\t\tstruct country_code_to_enum_rd *country = NULL;\n\t\tu16 cc = rd & ~COUNTRY_ERD_FLAG;\n\n\t\tcountry = ath_regd_find_country(cc);\n\t\tif (country != NULL)\n\t\t\treturn cc;\n\t}\n\n\treturn CTRY_DEFAULT;\n}\n\nstatic struct reg_dmn_pair_mapping*\nath_get_regpair(int regdmn)\n{\n\tint i;\n\n\tif (regdmn == NO_ENUMRD)\n\t\treturn NULL;\n\tfor (i = 0; i < ARRAY_SIZE(regDomainPairs); i++) {\n\t\tif (regDomainPairs[i].reg_domain == regdmn)\n\t\t\treturn &regDomainPairs[i];\n\t}\n\treturn NULL;\n}\n\nstatic int\nath_regd_init_wiphy(struct ath_regulatory *reg,\n\t\t    struct wiphy *wiphy,\n\t\t    void (*reg_notifier)(struct wiphy *wiphy,\n\t\t\t\t\t struct regulatory_request *request))\n{\n\tconst struct ieee80211_regdomain *regd;\n\n\twiphy->reg_notifier = reg_notifier;\n\twiphy->regulatory_flags |= REGULATORY_STRICT_REG |\n\t\t\t\t   REGULATORY_CUSTOM_REG;\n\n\tif (ath_is_world_regd(reg)) {\n\t\t \n\t\tregd = ath_world_regdomain(reg);\n\t\twiphy->regulatory_flags |= REGULATORY_COUNTRY_IE_FOLLOW_POWER;\n\t} else {\n\t\t \n\t\tregd = ath_default_world_regdomain();\n\t}\n\n\twiphy_apply_custom_regulatory(wiphy, regd);\n\tath_reg_apply_radar_flags(wiphy, reg);\n\tath_reg_apply_world_flags(wiphy, NL80211_REGDOM_SET_BY_DRIVER, reg);\n\treturn 0;\n}\n\n \nstatic void ath_regd_sanitize(struct ath_regulatory *reg)\n{\n\tif (reg->current_rd != COUNTRY_ERD_FLAG)\n\t\treturn;\n\tprintk(KERN_DEBUG \"ath: EEPROM regdomain sanitized\\n\");\n\treg->current_rd = 0x64;\n}\n\nstatic int __ath_regd_init(struct ath_regulatory *reg)\n{\n\tstruct country_code_to_enum_rd *country = NULL;\n\tu16 regdmn;\n\n\tif (!reg)\n\t\treturn -EINVAL;\n\n\tath_regd_sanitize(reg);\n\n\tprintk(KERN_DEBUG \"ath: EEPROM regdomain: 0x%0x\\n\", reg->current_rd);\n\n\tif (!ath_regd_is_eeprom_valid(reg)) {\n\t\tpr_err(\"Invalid EEPROM contents\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tregdmn = ath_regd_get_eepromRD(reg);\n\treg->country_code = ath_regd_get_default_country(regdmn);\n\n\tif (reg->country_code == CTRY_DEFAULT &&\n\t    regdmn == CTRY_DEFAULT) {\n\t\tprintk(KERN_DEBUG \"ath: EEPROM indicates default \"\n\t\t       \"country code should be used\\n\");\n\t\treg->country_code = CTRY_UNITED_STATES;\n\t}\n\n\tif (reg->country_code == CTRY_DEFAULT) {\n\t\tcountry = NULL;\n\t} else {\n\t\tprintk(KERN_DEBUG \"ath: doing EEPROM country->regdmn \"\n\t\t       \"map search\\n\");\n\t\tcountry = ath_regd_find_country(reg->country_code);\n\t\tif (country == NULL) {\n\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\"ath: no valid country maps found for \"\n\t\t\t\t\"country code: 0x%0x\\n\",\n\t\t\t\treg->country_code);\n\t\t\treturn -EINVAL;\n\t\t} else {\n\t\t\tregdmn = country->regDmnEnum;\n\t\t\tprintk(KERN_DEBUG \"ath: country maps to \"\n\t\t\t       \"regdmn code: 0x%0x\\n\",\n\t\t\t       regdmn);\n\t\t}\n\t}\n\n\treg->regpair = ath_get_regpair(regdmn);\n\n\tif (!reg->regpair) {\n\t\tprintk(KERN_DEBUG \"ath: \"\n\t\t\t\"No regulatory domain pair found, cannot continue\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!country)\n\t\tcountry = ath_regd_find_country_by_rd(regdmn);\n\n\tif (country) {\n\t\treg->alpha2[0] = country->isoName[0];\n\t\treg->alpha2[1] = country->isoName[1];\n\t} else {\n\t\treg->alpha2[0] = '0';\n\t\treg->alpha2[1] = '0';\n\t}\n\n\tprintk(KERN_DEBUG \"ath: Country alpha2 being used: %c%c\\n\",\n\t\treg->alpha2[0], reg->alpha2[1]);\n\tprintk(KERN_DEBUG \"ath: Regpair used: 0x%0x\\n\",\n\t\treg->regpair->reg_domain);\n\n\treturn 0;\n}\n\nint\nath_regd_init(struct ath_regulatory *reg,\n\t      struct wiphy *wiphy,\n\t      void (*reg_notifier)(struct wiphy *wiphy,\n\t\t\t\t   struct regulatory_request *request))\n{\n\tstruct ath_common *common = container_of(reg, struct ath_common,\n\t\t\t\t\t\t regulatory);\n\tint r;\n\n\tr = __ath_regd_init(reg);\n\tif (r)\n\t\treturn r;\n\n\tif (ath_is_world_regd(reg))\n\t\tmemcpy(&common->reg_world_copy, reg,\n\t\t       sizeof(struct ath_regulatory));\n\n\tath_regd_init_wiphy(reg, wiphy, reg_notifier);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(ath_regd_init);\n\nu32 ath_regd_get_band_ctl(struct ath_regulatory *reg,\n\t\t\t  enum nl80211_band band)\n{\n\tif (!reg->regpair ||\n\t    (reg->country_code == CTRY_DEFAULT &&\n\t     is_wwr_sku(ath_regd_get_eepromRD(reg)))) {\n\t\treturn SD_NO_CTL;\n\t}\n\n\tif (ath_regd_get_eepromRD(reg) == CTRY_DEFAULT) {\n\t\tswitch (reg->region) {\n\t\tcase NL80211_DFS_FCC:\n\t\t\treturn CTL_FCC;\n\t\tcase NL80211_DFS_ETSI:\n\t\t\treturn CTL_ETSI;\n\t\tcase NL80211_DFS_JP:\n\t\t\treturn CTL_MKK;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (band) {\n\tcase NL80211_BAND_2GHZ:\n\t\treturn reg->regpair->reg_2ghz_ctl;\n\tcase NL80211_BAND_5GHZ:\n\t\treturn reg->regpair->reg_5ghz_ctl;\n\tdefault:\n\t\treturn NO_CTL;\n\t}\n}\nEXPORT_SYMBOL(ath_regd_get_band_ctl);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}