{
  "module_name": "txrx_edma.c",
  "hash_id": "7e2b6bd6dc54cb728bcd5bca965c84b2031f04f2fb283317c886c6adddb0af1f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/wil6210/txrx_edma.c",
  "human_readable_source": "\n \n\n#include <linux/etherdevice.h>\n#include <linux/moduleparam.h>\n#include <linux/prefetch.h>\n#include <linux/types.h>\n#include <linux/list.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include \"wil6210.h\"\n#include \"txrx_edma.h\"\n#include \"txrx.h\"\n#include \"trace.h\"\n\n \n#define WIL_EDMA_TX_SRING_UPDATE_HW_TAIL 128\n#define WIL_EDMA_MAX_DATA_OFFSET (2)\n \n#define WIL_EDMA_RX_BUF_LEN_DEFAULT (2048)\n#define MAX_INVALID_BUFF_ID_RETRY (3)\n\nstatic void wil_tx_desc_unmap_edma(struct device *dev,\n\t\t\t\t   union wil_tx_desc *desc,\n\t\t\t\t   struct wil_ctx *ctx)\n{\n\tstruct wil_tx_enhanced_desc *d = (struct wil_tx_enhanced_desc *)desc;\n\tdma_addr_t pa = wil_tx_desc_get_addr_edma(&d->dma);\n\tu16 dmalen = le16_to_cpu(d->dma.length);\n\n\tswitch (ctx->mapped_as) {\n\tcase wil_mapped_as_single:\n\t\tdma_unmap_single(dev, pa, dmalen, DMA_TO_DEVICE);\n\t\tbreak;\n\tcase wil_mapped_as_page:\n\t\tdma_unmap_page(dev, pa, dmalen, DMA_TO_DEVICE);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int wil_find_free_sring(struct wil6210_priv *wil)\n{\n\tint i;\n\n\tfor (i = 0; i < WIL6210_MAX_STATUS_RINGS; i++) {\n\t\tif (!wil->srings[i].va)\n\t\t\treturn i;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic void wil_sring_free(struct wil6210_priv *wil,\n\t\t\t   struct wil_status_ring *sring)\n{\n\tstruct device *dev = wil_to_dev(wil);\n\tsize_t sz;\n\n\tif (!sring || !sring->va)\n\t\treturn;\n\n\tsz = sring->elem_size * sring->size;\n\n\twil_dbg_misc(wil, \"status_ring_free, size(bytes)=%zu, 0x%p:%pad\\n\",\n\t\t     sz, sring->va, &sring->pa);\n\n\tdma_free_coherent(dev, sz, (void *)sring->va, sring->pa);\n\tsring->pa = 0;\n\tsring->va = NULL;\n}\n\nstatic int wil_sring_alloc(struct wil6210_priv *wil,\n\t\t\t   struct wil_status_ring *sring)\n{\n\tstruct device *dev = wil_to_dev(wil);\n\tsize_t sz = sring->elem_size * sring->size;\n\n\twil_dbg_misc(wil, \"status_ring_alloc: size=%zu\\n\", sz);\n\n\tif (sz == 0) {\n\t\twil_err(wil, \"Cannot allocate a zero size status ring\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsring->swhead = 0;\n\n\t \n\tsring->va = dma_alloc_coherent(dev, sz, &sring->pa, GFP_KERNEL);\n\tif (!sring->va)\n\t\treturn -ENOMEM;\n\n\twil_dbg_misc(wil, \"status_ring[%d] 0x%p:%pad\\n\", sring->size, sring->va,\n\t\t     &sring->pa);\n\n\treturn 0;\n}\n\nstatic int wil_tx_init_edma(struct wil6210_priv *wil)\n{\n\tint ring_id = wil_find_free_sring(wil);\n\tstruct wil_status_ring *sring;\n\tint rc;\n\tu16 status_ring_size;\n\n\tif (wil->tx_status_ring_order < WIL_SRING_SIZE_ORDER_MIN ||\n\t    wil->tx_status_ring_order > WIL_SRING_SIZE_ORDER_MAX)\n\t\twil->tx_status_ring_order = WIL_TX_SRING_SIZE_ORDER_DEFAULT;\n\n\tstatus_ring_size = 1 << wil->tx_status_ring_order;\n\n\twil_dbg_misc(wil, \"init TX sring: size=%u, ring_id=%u\\n\",\n\t\t     status_ring_size, ring_id);\n\n\tif (ring_id < 0)\n\t\treturn ring_id;\n\n\t \n\tsring = &wil->srings[ring_id];\n\n\tsring->is_rx = false;\n\tsring->size = status_ring_size;\n\tsring->elem_size = sizeof(struct wil_ring_tx_status);\n\trc = wil_sring_alloc(wil, sring);\n\tif (rc)\n\t\treturn rc;\n\n\trc = wil_wmi_tx_sring_cfg(wil, ring_id);\n\tif (rc)\n\t\tgoto out_free;\n\n\tsring->desc_rdy_pol = 1;\n\twil->tx_sring_idx = ring_id;\n\n\treturn 0;\nout_free:\n\twil_sring_free(wil, sring);\n\treturn rc;\n}\n\n \nstatic int wil_ring_alloc_skb_edma(struct wil6210_priv *wil,\n\t\t\t\t   struct wil_ring *ring, u32 i)\n{\n\tstruct device *dev = wil_to_dev(wil);\n\tunsigned int sz = wil->rx_buf_len;\n\tdma_addr_t pa;\n\tu16 buff_id;\n\tstruct list_head *active = &wil->rx_buff_mgmt.active;\n\tstruct list_head *free = &wil->rx_buff_mgmt.free;\n\tstruct wil_rx_buff *rx_buff;\n\tstruct wil_rx_buff *buff_arr = wil->rx_buff_mgmt.buff_arr;\n\tstruct sk_buff *skb;\n\tstruct wil_rx_enhanced_desc dd, *d = &dd;\n\tstruct wil_rx_enhanced_desc *_d = (struct wil_rx_enhanced_desc *)\n\t\t&ring->va[i].rx.enhanced;\n\n\tif (unlikely(list_empty(free))) {\n\t\twil->rx_buff_mgmt.free_list_empty_cnt++;\n\t\treturn -EAGAIN;\n\t}\n\n\tskb = dev_alloc_skb(sz);\n\tif (unlikely(!skb))\n\t\treturn -ENOMEM;\n\n\tskb_put(skb, sz);\n\n\t \n\tskb->ip_summed = CHECKSUM_NONE;\n\n\tpa = dma_map_single(dev, skb->data, skb->len, DMA_FROM_DEVICE);\n\tif (unlikely(dma_mapping_error(dev, pa))) {\n\t\tkfree_skb(skb);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\trx_buff = list_first_entry(free, struct wil_rx_buff, list);\n\tbuff_id = rx_buff->id;\n\n\t \n\tlist_move(&rx_buff->list, active);\n\n\tbuff_arr[buff_id].skb = skb;\n\n\twil_desc_set_addr_edma(&d->dma.addr, &d->dma.addr_high_high, pa);\n\td->dma.length = cpu_to_le16(sz);\n\td->mac.buff_id = cpu_to_le16(buff_id);\n\t*_d = *d;\n\n\t \n\tmemcpy(skb->cb, &pa, sizeof(pa));\n\n\treturn 0;\n}\n\nstatic inline\nvoid wil_get_next_rx_status_msg(struct wil_status_ring *sring, u8 *dr_bit,\n\t\t\t\tvoid *msg)\n{\n\tstruct wil_rx_status_compressed *_msg;\n\n\t_msg = (struct wil_rx_status_compressed *)\n\t\t(sring->va + (sring->elem_size * sring->swhead));\n\t*dr_bit = WIL_GET_BITS(_msg->d0, 31, 31);\n\t \n\trmb();\n\tmemcpy(msg, (void *)_msg, sring->elem_size);\n}\n\nstatic inline void wil_sring_advance_swhead(struct wil_status_ring *sring)\n{\n\tsring->swhead = (sring->swhead + 1) % sring->size;\n\tif (sring->swhead == 0)\n\t\tsring->desc_rdy_pol = 1 - sring->desc_rdy_pol;\n}\n\nstatic int wil_rx_refill_edma(struct wil6210_priv *wil)\n{\n\tstruct wil_ring *ring = &wil->ring_rx;\n\tu32 next_head;\n\tint rc = 0;\n\tring->swtail = *ring->edma_rx_swtail.va;\n\n\tfor (; next_head = wil_ring_next_head(ring),\n\t     (next_head != ring->swtail);\n\t     ring->swhead = next_head) {\n\t\trc = wil_ring_alloc_skb_edma(wil, ring, ring->swhead);\n\t\tif (unlikely(rc)) {\n\t\t\tif (rc == -EAGAIN)\n\t\t\t\twil_dbg_txrx(wil, \"No free buffer ID found\\n\");\n\t\t\telse\n\t\t\t\twil_err_ratelimited(wil,\n\t\t\t\t\t\t    \"Error %d in refill desc[%d]\\n\",\n\t\t\t\t\t\t    rc, ring->swhead);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\twmb();\n\n\twil_w(wil, ring->hwtail, ring->swhead);\n\n\treturn rc;\n}\n\nstatic void wil_move_all_rx_buff_to_free_list(struct wil6210_priv *wil,\n\t\t\t\t\t      struct wil_ring *ring)\n{\n\tstruct device *dev = wil_to_dev(wil);\n\tstruct list_head *active = &wil->rx_buff_mgmt.active;\n\tdma_addr_t pa;\n\n\tif (!wil->rx_buff_mgmt.buff_arr)\n\t\treturn;\n\n\twhile (!list_empty(active)) {\n\t\tstruct wil_rx_buff *rx_buff =\n\t\t\tlist_first_entry(active, struct wil_rx_buff, list);\n\t\tstruct sk_buff *skb = rx_buff->skb;\n\n\t\tif (unlikely(!skb)) {\n\t\t\twil_err(wil, \"No Rx skb at buff_id %d\\n\", rx_buff->id);\n\t\t} else {\n\t\t\trx_buff->skb = NULL;\n\t\t\tmemcpy(&pa, skb->cb, sizeof(pa));\n\t\t\tdma_unmap_single(dev, pa, wil->rx_buf_len,\n\t\t\t\t\t DMA_FROM_DEVICE);\n\t\t\tkfree_skb(skb);\n\t\t}\n\n\t\t \n\t\tlist_move(&rx_buff->list, &wil->rx_buff_mgmt.free);\n\t}\n}\n\nstatic void wil_free_rx_buff_arr(struct wil6210_priv *wil)\n{\n\tstruct wil_ring *ring = &wil->ring_rx;\n\n\tif (!wil->rx_buff_mgmt.buff_arr)\n\t\treturn;\n\n\t \n\twil_move_all_rx_buff_to_free_list(wil, ring);\n\n\tkfree(wil->rx_buff_mgmt.buff_arr);\n\twil->rx_buff_mgmt.buff_arr = NULL;\n}\n\nstatic int wil_init_rx_buff_arr(struct wil6210_priv *wil,\n\t\t\t\tsize_t size)\n{\n\tstruct wil_rx_buff *buff_arr;\n\tstruct list_head *active = &wil->rx_buff_mgmt.active;\n\tstruct list_head *free = &wil->rx_buff_mgmt.free;\n\tint i;\n\n\twil->rx_buff_mgmt.buff_arr = kcalloc(size + 1,\n\t\t\t\t\t     sizeof(struct wil_rx_buff),\n\t\t\t\t\t     GFP_KERNEL);\n\tif (!wil->rx_buff_mgmt.buff_arr)\n\t\treturn -ENOMEM;\n\n\t \n\tINIT_LIST_HEAD(active);\n\tINIT_LIST_HEAD(free);\n\n\t \n\tbuff_arr = wil->rx_buff_mgmt.buff_arr;\n\tfor (i = 1; i <= size; i++) {\n\t\tlist_add(&buff_arr[i].list, free);\n\t\tbuff_arr[i].id = i;\n\t}\n\n\twil->rx_buff_mgmt.size = size + 1;\n\n\treturn 0;\n}\n\nstatic int wil_init_rx_sring(struct wil6210_priv *wil,\n\t\t\t     u16 status_ring_size,\n\t\t\t     size_t elem_size,\n\t\t\t     u16 ring_id)\n{\n\tstruct wil_status_ring *sring = &wil->srings[ring_id];\n\tint rc;\n\n\twil_dbg_misc(wil, \"init RX sring: size=%u, ring_id=%u\\n\",\n\t\t     status_ring_size, ring_id);\n\n\tmemset(&sring->rx_data, 0, sizeof(sring->rx_data));\n\n\tsring->is_rx = true;\n\tsring->size = status_ring_size;\n\tsring->elem_size = elem_size;\n\trc = wil_sring_alloc(wil, sring);\n\tif (rc)\n\t\treturn rc;\n\n\trc = wil_wmi_rx_sring_add(wil, ring_id);\n\tif (rc)\n\t\tgoto out_free;\n\n\tsring->desc_rdy_pol = 1;\n\n\treturn 0;\nout_free:\n\twil_sring_free(wil, sring);\n\treturn rc;\n}\n\nstatic int wil_ring_alloc_desc_ring(struct wil6210_priv *wil,\n\t\t\t\t    struct wil_ring *ring)\n{\n\tstruct device *dev = wil_to_dev(wil);\n\tsize_t sz = ring->size * sizeof(ring->va[0]);\n\n\twil_dbg_misc(wil, \"alloc_desc_ring:\\n\");\n\n\tBUILD_BUG_ON(sizeof(ring->va[0]) != 32);\n\n\tring->swhead = 0;\n\tring->swtail = 0;\n\tring->ctx = kcalloc(ring->size, sizeof(ring->ctx[0]), GFP_KERNEL);\n\tif (!ring->ctx)\n\t\tgoto err;\n\n\tring->va = dma_alloc_coherent(dev, sz, &ring->pa, GFP_KERNEL);\n\tif (!ring->va)\n\t\tgoto err_free_ctx;\n\n\tif (ring->is_rx) {\n\t\tsz = sizeof(*ring->edma_rx_swtail.va);\n\t\tring->edma_rx_swtail.va =\n\t\t\tdma_alloc_coherent(dev, sz, &ring->edma_rx_swtail.pa,\n\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!ring->edma_rx_swtail.va)\n\t\t\tgoto err_free_va;\n\t}\n\n\twil_dbg_misc(wil, \"%s ring[%d] 0x%p:%pad 0x%p\\n\",\n\t\t     ring->is_rx ? \"RX\" : \"TX\",\n\t\t     ring->size, ring->va, &ring->pa, ring->ctx);\n\n\treturn 0;\nerr_free_va:\n\tdma_free_coherent(dev, ring->size * sizeof(ring->va[0]),\n\t\t\t  (void *)ring->va, ring->pa);\n\tring->va = NULL;\nerr_free_ctx:\n\tkfree(ring->ctx);\n\tring->ctx = NULL;\nerr:\n\treturn -ENOMEM;\n}\n\nstatic void wil_ring_free_edma(struct wil6210_priv *wil, struct wil_ring *ring)\n{\n\tstruct device *dev = wil_to_dev(wil);\n\tsize_t sz;\n\tint ring_index = 0;\n\n\tif (!ring->va)\n\t\treturn;\n\n\tsz = ring->size * sizeof(ring->va[0]);\n\n\tlockdep_assert_held(&wil->mutex);\n\tif (ring->is_rx) {\n\t\twil_dbg_misc(wil, \"free Rx ring [%d] 0x%p:%pad 0x%p\\n\",\n\t\t\t     ring->size, ring->va,\n\t\t\t     &ring->pa, ring->ctx);\n\n\t\twil_move_all_rx_buff_to_free_list(wil, ring);\n\t\tdma_free_coherent(dev, sizeof(*ring->edma_rx_swtail.va),\n\t\t\t\t  ring->edma_rx_swtail.va,\n\t\t\t\t  ring->edma_rx_swtail.pa);\n\t\tgoto out;\n\t}\n\n\t \n\tring_index = ring - wil->ring_tx;\n\n\twil_dbg_misc(wil, \"free Tx ring %d [%d] 0x%p:%pad 0x%p\\n\",\n\t\t     ring_index, ring->size, ring->va,\n\t\t     &ring->pa, ring->ctx);\n\n\twhile (!wil_ring_is_empty(ring)) {\n\t\tstruct wil_ctx *ctx;\n\n\t\tstruct wil_tx_enhanced_desc dd, *d = &dd;\n\t\tstruct wil_tx_enhanced_desc *_d =\n\t\t\t(struct wil_tx_enhanced_desc *)\n\t\t\t&ring->va[ring->swtail].tx.enhanced;\n\n\t\tctx = &ring->ctx[ring->swtail];\n\t\tif (!ctx) {\n\t\t\twil_dbg_txrx(wil,\n\t\t\t\t     \"ctx(%d) was already completed\\n\",\n\t\t\t\t     ring->swtail);\n\t\t\tring->swtail = wil_ring_next_tail(ring);\n\t\t\tcontinue;\n\t\t}\n\t\t*d = *_d;\n\t\twil_tx_desc_unmap_edma(dev, (union wil_tx_desc *)d, ctx);\n\t\tif (ctx->skb)\n\t\t\tdev_kfree_skb_any(ctx->skb);\n\t\tring->swtail = wil_ring_next_tail(ring);\n\t}\n\nout:\n\tdma_free_coherent(dev, sz, (void *)ring->va, ring->pa);\n\tkfree(ring->ctx);\n\tring->pa = 0;\n\tring->va = NULL;\n\tring->ctx = NULL;\n}\n\nstatic int wil_init_rx_desc_ring(struct wil6210_priv *wil, u16 desc_ring_size,\n\t\t\t\t int status_ring_id)\n{\n\tstruct wil_ring *ring = &wil->ring_rx;\n\tint rc;\n\n\twil_dbg_misc(wil, \"init RX desc ring\\n\");\n\n\tring->size = desc_ring_size;\n\tring->is_rx = true;\n\trc = wil_ring_alloc_desc_ring(wil, ring);\n\tif (rc)\n\t\treturn rc;\n\n\trc = wil_wmi_rx_desc_ring_add(wil, status_ring_id);\n\tif (rc)\n\t\tgoto out_free;\n\n\treturn 0;\nout_free:\n\twil_ring_free_edma(wil, ring);\n\treturn rc;\n}\n\nstatic void wil_get_reorder_params_edma(struct wil6210_priv *wil,\n\t\t\t\t\tstruct sk_buff *skb, int *tid,\n\t\t\t\t\tint *cid, int *mid, u16 *seq,\n\t\t\t\t\tint *mcast, int *retry)\n{\n\tstruct wil_rx_status_extended *s = wil_skb_rxstatus(skb);\n\n\t*tid = wil_rx_status_get_tid(s);\n\t*cid = wil_rx_status_get_cid(s);\n\t*mid = wil_rx_status_get_mid(s);\n\t*seq = le16_to_cpu(wil_rx_status_get_seq(wil, s));\n\t*mcast = wil_rx_status_get_mcast(s);\n\t*retry = wil_rx_status_get_retry(s);\n}\n\nstatic void wil_get_netif_rx_params_edma(struct sk_buff *skb, int *cid,\n\t\t\t\t\t int *security)\n{\n\tstruct wil_rx_status_extended *s = wil_skb_rxstatus(skb);\n\n\t*cid = wil_rx_status_get_cid(s);\n\t*security = wil_rx_status_get_security(s);\n}\n\nstatic int wil_rx_crypto_check_edma(struct wil6210_priv *wil,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct wil_rx_status_extended *st;\n\tint cid, tid, key_id, mc;\n\tstruct wil_sta_info *s;\n\tstruct wil_tid_crypto_rx *c;\n\tstruct wil_tid_crypto_rx_single *cc;\n\tconst u8 *pn;\n\n\t \n\tif (wil->use_rx_hw_reordering)\n\t\treturn 0;\n\n\tst = wil_skb_rxstatus(skb);\n\n\tcid = wil_rx_status_get_cid(st);\n\ttid = wil_rx_status_get_tid(st);\n\tkey_id = wil_rx_status_get_key_id(st);\n\tmc = wil_rx_status_get_mcast(st);\n\ts = &wil->sta[cid];\n\tc = mc ? &s->group_crypto_rx : &s->tid_crypto_rx[tid];\n\tcc = &c->key_id[key_id];\n\tpn = (u8 *)&st->ext.pn;\n\n\tif (!cc->key_set) {\n\t\twil_err_ratelimited(wil,\n\t\t\t\t    \"Key missing. CID %d TID %d MCast %d KEY_ID %d\\n\",\n\t\t\t\t    cid, tid, mc, key_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (reverse_memcmp(pn, cc->pn, IEEE80211_GCMP_PN_LEN) <= 0) {\n\t\twil_err_ratelimited(wil,\n\t\t\t\t    \"Replay attack. CID %d TID %d MCast %d KEY_ID %d PN %6phN last %6phN\\n\",\n\t\t\t\t    cid, tid, mc, key_id, pn, cc->pn);\n\t\treturn -EINVAL;\n\t}\n\tmemcpy(cc->pn, pn, IEEE80211_GCMP_PN_LEN);\n\n\treturn 0;\n}\n\nstatic bool wil_is_rx_idle_edma(struct wil6210_priv *wil)\n{\n\tstruct wil_status_ring *sring;\n\tstruct wil_rx_status_extended msg1;\n\tvoid *msg = &msg1;\n\tu8 dr_bit;\n\tint i;\n\n\tfor (i = 0; i < wil->num_rx_status_rings; i++) {\n\t\tsring = &wil->srings[i];\n\t\tif (!sring->va)\n\t\t\tcontinue;\n\n\t\twil_get_next_rx_status_msg(sring, &dr_bit, msg);\n\n\t\t \n\t\tif (dr_bit == sring->desc_rdy_pol)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void wil_rx_buf_len_init_edma(struct wil6210_priv *wil)\n{\n\t \n\twil->rx_buf_len = rx_large_buf ?\n\t\tWIL_MAX_ETH_MTU : WIL_EDMA_RX_BUF_LEN_DEFAULT;\n}\n\nstatic int wil_rx_init_edma(struct wil6210_priv *wil, uint desc_ring_order)\n{\n\tu16 status_ring_size, desc_ring_size = 1 << desc_ring_order;\n\tstruct wil_ring *ring = &wil->ring_rx;\n\tint rc;\n\tsize_t elem_size = wil->use_compressed_rx_status ?\n\t\tsizeof(struct wil_rx_status_compressed) :\n\t\tsizeof(struct wil_rx_status_extended);\n\tint i;\n\n\t \n\tif (wil->use_compressed_rx_status && !wil->use_rx_hw_reordering) {\n\t\twil_err(wil,\n\t\t\t\"compressed RX status cannot be used with SW reorder\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (wil->rx_status_ring_order <= desc_ring_order)\n\t\t \n\t\twil->rx_status_ring_order = desc_ring_order + 1;\n\tif (wil->rx_buff_id_count <= desc_ring_size)\n\t\t \n\t\twil->rx_buff_id_count = desc_ring_size + 512;\n\tif (wil->rx_status_ring_order < WIL_SRING_SIZE_ORDER_MIN ||\n\t    wil->rx_status_ring_order > WIL_SRING_SIZE_ORDER_MAX)\n\t\twil->rx_status_ring_order = WIL_RX_SRING_SIZE_ORDER_DEFAULT;\n\n\tstatus_ring_size = 1 << wil->rx_status_ring_order;\n\n\twil_dbg_misc(wil,\n\t\t     \"rx_init, desc_ring_size=%u, status_ring_size=%u, elem_size=%zu\\n\",\n\t\t     desc_ring_size, status_ring_size, elem_size);\n\n\twil_rx_buf_len_init_edma(wil);\n\n\t \n\tif (wil->num_rx_status_rings > WIL6210_MAX_STATUS_RINGS - 1)\n\t\twil->num_rx_status_rings = WIL6210_MAX_STATUS_RINGS - 1;\n\n\twil_dbg_misc(wil, \"rx_init: allocate %d status rings\\n\",\n\t\t     wil->num_rx_status_rings);\n\n\trc = wil_wmi_cfg_def_rx_offload(wil, wil->rx_buf_len);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tfor (i = 0; i < wil->num_rx_status_rings; i++) {\n\t\tint sring_id = wil_find_free_sring(wil);\n\n\t\tif (sring_id < 0) {\n\t\t\trc = -EFAULT;\n\t\t\tgoto err_free_status;\n\t\t}\n\t\trc = wil_init_rx_sring(wil, status_ring_size, elem_size,\n\t\t\t\t       sring_id);\n\t\tif (rc)\n\t\t\tgoto err_free_status;\n\t}\n\n\t \n\trc = wil_init_rx_desc_ring(wil, desc_ring_size,\n\t\t\t\t   WIL_DEFAULT_RX_STATUS_RING_ID);\n\tif (rc)\n\t\tgoto err_free_status;\n\n\tif (wil->rx_buff_id_count >= status_ring_size) {\n\t\twil_info(wil,\n\t\t\t \"rx_buff_id_count %d exceeds sring_size %d. set it to %d\\n\",\n\t\t\t wil->rx_buff_id_count, status_ring_size,\n\t\t\t status_ring_size - 1);\n\t\twil->rx_buff_id_count = status_ring_size - 1;\n\t}\n\n\t \n\trc = wil_init_rx_buff_arr(wil, wil->rx_buff_id_count);\n\tif (rc)\n\t\tgoto err_free_desc;\n\n\t \n\trc = wil_rx_refill_edma(wil);\n\tif (rc)\n\t\tgoto err_free_rx_buff_arr;\n\n\treturn 0;\nerr_free_rx_buff_arr:\n\twil_free_rx_buff_arr(wil);\nerr_free_desc:\n\twil_ring_free_edma(wil, ring);\nerr_free_status:\n\tfor (i = 0; i < wil->num_rx_status_rings; i++)\n\t\twil_sring_free(wil, &wil->srings[i]);\n\n\treturn rc;\n}\n\nstatic int wil_ring_init_tx_edma(struct wil6210_vif *vif, int ring_id,\n\t\t\t\t int size, int cid, int tid)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tint rc;\n\tstruct wil_ring *ring = &wil->ring_tx[ring_id];\n\tstruct wil_ring_tx_data *txdata = &wil->ring_tx_data[ring_id];\n\n\tlockdep_assert_held(&wil->mutex);\n\n\twil_dbg_misc(wil,\n\t\t     \"init TX ring: ring_id=%u, cid=%u, tid=%u, sring_id=%u\\n\",\n\t\t     ring_id, cid, tid, wil->tx_sring_idx);\n\n\twil_tx_data_init(txdata);\n\tring->size = size;\n\trc = wil_ring_alloc_desc_ring(wil, ring);\n\tif (rc)\n\t\tgoto out;\n\n\twil->ring2cid_tid[ring_id][0] = cid;\n\twil->ring2cid_tid[ring_id][1] = tid;\n\tif (!vif->privacy)\n\t\ttxdata->dot1x_open = true;\n\n\trc = wil_wmi_tx_desc_ring_add(vif, ring_id, cid, tid);\n\tif (rc) {\n\t\twil_err(wil, \"WMI_TX_DESC_RING_ADD_CMD failed\\n\");\n\t\tgoto out_free;\n\t}\n\n\tif (txdata->dot1x_open && agg_wsize >= 0)\n\t\twil_addba_tx_request(wil, ring_id, agg_wsize);\n\n\treturn 0;\n out_free:\n\tspin_lock_bh(&txdata->lock);\n\ttxdata->dot1x_open = false;\n\ttxdata->enabled = 0;\n\tspin_unlock_bh(&txdata->lock);\n\twil_ring_free_edma(wil, ring);\n\twil->ring2cid_tid[ring_id][0] = wil->max_assoc_sta;\n\twil->ring2cid_tid[ring_id][1] = 0;\n\n out:\n\treturn rc;\n}\n\nstatic int wil_tx_ring_modify_edma(struct wil6210_vif *vif, int ring_id,\n\t\t\t\t   int cid, int tid)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\n\twil_err(wil, \"ring modify is not supported for EDMA\\n\");\n\n\treturn -EOPNOTSUPP;\n}\n\n \nstatic int wil_check_bar(struct wil6210_priv *wil, void *msg, int cid,\n\t\t\t struct sk_buff *skb, struct wil_net_stats *stats)\n{\n\tu8 ftype;\n\tu8 fc1;\n\tint mid;\n\tint tid;\n\tu16 seq;\n\tstruct wil6210_vif *vif;\n\n\tftype = wil_rx_status_get_frame_type(wil, msg);\n\tif (ftype == IEEE80211_FTYPE_DATA)\n\t\treturn 0;\n\n\tfc1 = wil_rx_status_get_fc1(wil, msg);\n\tmid = wil_rx_status_get_mid(msg);\n\ttid = wil_rx_status_get_tid(msg);\n\tseq = le16_to_cpu(wil_rx_status_get_seq(wil, msg));\n\tvif = wil->vifs[mid];\n\n\tif (unlikely(!vif)) {\n\t\twil_dbg_txrx(wil, \"RX descriptor with invalid mid %d\", mid);\n\t\treturn -EAGAIN;\n\t}\n\n\twil_dbg_txrx(wil,\n\t\t     \"Non-data frame FC[7:0] 0x%02x MID %d CID %d TID %d Seq 0x%03x\\n\",\n\t\t     fc1, mid, cid, tid, seq);\n\tif (stats)\n\t\tstats->rx_non_data_frame++;\n\tif (wil_is_back_req(fc1)) {\n\t\twil_dbg_txrx(wil,\n\t\t\t     \"BAR: MID %d CID %d TID %d Seq 0x%03x\\n\",\n\t\t\t     mid, cid, tid, seq);\n\t\twil_rx_bar(wil, vif, cid, tid, seq);\n\t} else {\n\t\tu32 sz = wil->use_compressed_rx_status ?\n\t\t\tsizeof(struct wil_rx_status_compressed) :\n\t\t\tsizeof(struct wil_rx_status_extended);\n\n\t\t \n\t\twil_dbg_txrx(wil,\n\t\t\t     \"Unhandled non-data frame FC[7:0] 0x%02x MID %d CID %d TID %d Seq 0x%03x\\n\",\n\t\t\t     fc1, mid, cid, tid, seq);\n\t\twil_hex_dump_txrx(\"RxS \", DUMP_PREFIX_NONE, 32, 4,\n\t\t\t\t  (const void *)msg, sz, false);\n\t\twil_hex_dump_txrx(\"Rx \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t\t  skb->data, skb_headlen(skb), false);\n\t}\n\n\treturn -EAGAIN;\n}\n\nstatic int wil_rx_error_check_edma(struct wil6210_priv *wil,\n\t\t\t\t   struct sk_buff *skb,\n\t\t\t\t   struct wil_net_stats *stats)\n{\n\tint l2_rx_status;\n\tvoid *msg = wil_skb_rxstatus(skb);\n\n\tl2_rx_status = wil_rx_status_get_l2_rx_status(msg);\n\tif (l2_rx_status != 0) {\n\t\twil_dbg_txrx(wil, \"L2 RX error, l2_rx_status=0x%x\\n\",\n\t\t\t     l2_rx_status);\n\t\t \n\t\tif (l2_rx_status == WIL_RX_EDMA_ERROR_MIC) {\n\t\t\twil_err_ratelimited(wil,\n\t\t\t\t\t    \"L2 MIC/KEY error, dropping packet\\n\");\n\t\t\tstats->rx_mic_error++;\n\t\t}\n\t\tif (l2_rx_status == WIL_RX_EDMA_ERROR_KEY) {\n\t\t\twil_err_ratelimited(wil,\n\t\t\t\t\t    \"L2 KEY error, dropping packet\\n\");\n\t\t\tstats->rx_key_error++;\n\t\t}\n\t\tif (l2_rx_status == WIL_RX_EDMA_ERROR_REPLAY) {\n\t\t\twil_err_ratelimited(wil,\n\t\t\t\t\t    \"L2 REPLAY error, dropping packet\\n\");\n\t\t\tstats->rx_replay++;\n\t\t}\n\t\tif (l2_rx_status == WIL_RX_EDMA_ERROR_AMSDU) {\n\t\t\twil_err_ratelimited(wil,\n\t\t\t\t\t    \"L2 AMSDU error, dropping packet\\n\");\n\t\t\tstats->rx_amsdu_error++;\n\t\t}\n\t\treturn -EFAULT;\n\t}\n\n\tskb->ip_summed = wil_rx_status_get_checksum(msg, stats);\n\n\treturn 0;\n}\n\nstatic struct sk_buff *wil_sring_reap_rx_edma(struct wil6210_priv *wil,\n\t\t\t\t\t      struct wil_status_ring *sring)\n{\n\tstruct device *dev = wil_to_dev(wil);\n\tstruct wil_rx_status_extended msg1;\n\tvoid *msg = &msg1;\n\tu16 buff_id;\n\tstruct sk_buff *skb;\n\tdma_addr_t pa;\n\tstruct wil_ring_rx_data *rxdata = &sring->rx_data;\n\tunsigned int sz = wil->rx_buf_len;\n\tstruct wil_net_stats *stats = NULL;\n\tu16 dmalen;\n\tint cid;\n\tbool eop, headstolen;\n\tint delta;\n\tu8 dr_bit;\n\tu8 data_offset;\n\tstruct wil_rx_status_extended *s;\n\tu16 sring_idx = sring - wil->srings;\n\tint invalid_buff_id_retry;\n\n\tBUILD_BUG_ON(sizeof(struct wil_rx_status_extended) > sizeof(skb->cb));\n\nagain:\n\twil_get_next_rx_status_msg(sring, &dr_bit, msg);\n\n\t \n\tif (dr_bit != sring->desc_rdy_pol)\n\t\treturn NULL;\n\n\t \n\tbuff_id = le16_to_cpu(wil_rx_status_get_buff_id(msg));\n\n\tinvalid_buff_id_retry = 0;\n\twhile (!buff_id) {\n\t\tstruct wil_rx_status_extended *s;\n\n\t\twil_dbg_txrx(wil,\n\t\t\t     \"buff_id is not updated yet by HW, (swhead 0x%x)\\n\",\n\t\t\t     sring->swhead);\n\t\tif (++invalid_buff_id_retry > MAX_INVALID_BUFF_ID_RETRY)\n\t\t\tbreak;\n\n\t\t \n\t\ts = (struct wil_rx_status_extended *)\n\t\t\t(sring->va + (sring->elem_size * sring->swhead));\n\t\t*(struct wil_rx_status_extended *)msg = *s;\n\t\tbuff_id = le16_to_cpu(wil_rx_status_get_buff_id(msg));\n\t}\n\n\tif (unlikely(!wil_val_in_range(buff_id, 1, wil->rx_buff_mgmt.size))) {\n\t\twil_err(wil, \"Corrupt buff_id=%d, sring->swhead=%d\\n\",\n\t\t\tbuff_id, sring->swhead);\n\t\tprint_hex_dump(KERN_ERR, \"RxS \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t       msg, wil->use_compressed_rx_status ?\n\t\t\t       sizeof(struct wil_rx_status_compressed) :\n\t\t\t       sizeof(struct wil_rx_status_extended), false);\n\n\t\twil_rx_status_reset_buff_id(sring);\n\t\twil_sring_advance_swhead(sring);\n\t\tsring->invalid_buff_id_cnt++;\n\t\tgoto again;\n\t}\n\n\t \n\tskb = wil->rx_buff_mgmt.buff_arr[buff_id].skb;\n\twil->rx_buff_mgmt.buff_arr[buff_id].skb = NULL;\n\tif (!skb) {\n\t\twil_err(wil, \"No Rx skb at buff_id %d\\n\", buff_id);\n\t\twil_rx_status_reset_buff_id(sring);\n\t\t \n\t\tlist_move_tail(&wil->rx_buff_mgmt.buff_arr[buff_id].list,\n\t\t\t       &wil->rx_buff_mgmt.free);\n\t\twil_sring_advance_swhead(sring);\n\t\tsring->invalid_buff_id_cnt++;\n\t\tgoto again;\n\t}\n\n\twil_rx_status_reset_buff_id(sring);\n\twil_sring_advance_swhead(sring);\n\n\tmemcpy(&pa, skb->cb, sizeof(pa));\n\tdma_unmap_single(dev, pa, sz, DMA_FROM_DEVICE);\n\tdmalen = le16_to_cpu(wil_rx_status_get_length(msg));\n\n\ttrace_wil6210_rx_status(wil, wil->use_compressed_rx_status, buff_id,\n\t\t\t\tmsg);\n\twil_dbg_txrx(wil, \"Rx, buff_id=%u, sring_idx=%u, dmalen=%u bytes\\n\",\n\t\t     buff_id, sring_idx, dmalen);\n\twil_hex_dump_txrx(\"RxS \", DUMP_PREFIX_NONE, 32, 4,\n\t\t\t  (const void *)msg, wil->use_compressed_rx_status ?\n\t\t\t  sizeof(struct wil_rx_status_compressed) :\n\t\t\t  sizeof(struct wil_rx_status_extended), false);\n\n\t \n\tlist_move_tail(&wil->rx_buff_mgmt.buff_arr[buff_id].list,\n\t\t       &wil->rx_buff_mgmt.free);\n\n\teop = wil_rx_status_get_eop(msg);\n\n\tcid = wil_rx_status_get_cid(msg);\n\tif (unlikely(!wil_val_in_range(cid, 0, wil->max_assoc_sta))) {\n\t\twil_err(wil, \"Corrupt cid=%d, sring->swhead=%d\\n\",\n\t\t\tcid, sring->swhead);\n\t\trxdata->skipping = true;\n\t\tgoto skipping;\n\t}\n\tstats = &wil->sta[cid].stats;\n\n\tif (unlikely(dmalen < ETH_HLEN)) {\n\t\twil_dbg_txrx(wil, \"Short frame, len = %d\\n\", dmalen);\n\t\tstats->rx_short_frame++;\n\t\trxdata->skipping = true;\n\t\tgoto skipping;\n\t}\n\n\tif (unlikely(dmalen > sz)) {\n\t\twil_err(wil, \"Rx size too large: %d bytes!\\n\", dmalen);\n\t\tprint_hex_dump(KERN_ERR, \"RxS \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t       msg, wil->use_compressed_rx_status ?\n\t\t\t       sizeof(struct wil_rx_status_compressed) :\n\t\t\t       sizeof(struct wil_rx_status_extended), false);\n\n\t\tstats->rx_large_frame++;\n\t\trxdata->skipping = true;\n\t}\n\nskipping:\n\t \n\tif (unlikely(rxdata->skipping)) {\n\t\tkfree_skb(skb);\n\t\tif (rxdata->skb) {\n\t\t\tkfree_skb(rxdata->skb);\n\t\t\trxdata->skb = NULL;\n\t\t}\n\t\trxdata->skipping = !eop;\n\t\tgoto again;\n\t}\n\n\tskb_trim(skb, dmalen);\n\n\tprefetch(skb->data);\n\n\tif (!rxdata->skb) {\n\t\trxdata->skb = skb;\n\t} else {\n\t\tif (likely(skb_try_coalesce(rxdata->skb, skb, &headstolen,\n\t\t\t\t\t    &delta))) {\n\t\t\tkfree_skb_partial(skb, headstolen);\n\t\t} else {\n\t\t\twil_err(wil, \"failed to merge skbs!\\n\");\n\t\t\tkfree_skb(skb);\n\t\t\tkfree_skb(rxdata->skb);\n\t\t\trxdata->skb = NULL;\n\t\t\trxdata->skipping = !eop;\n\t\t\tgoto again;\n\t\t}\n\t}\n\n\tif (!eop)\n\t\tgoto again;\n\n\t \n\tskb = rxdata->skb;\n\trxdata->skb = NULL;\n\trxdata->skipping = false;\n\n\tif (stats) {\n\t\tstats->last_mcs_rx = wil_rx_status_get_mcs(msg);\n\t\tif (stats->last_mcs_rx < ARRAY_SIZE(stats->rx_per_mcs))\n\t\t\tstats->rx_per_mcs[stats->last_mcs_rx]++;\n\t\telse if (stats->last_mcs_rx == WIL_EXTENDED_MCS_26)\n\t\t\tstats->rx_per_mcs[WIL_BASE_MCS_FOR_EXTENDED_26]++;\n\n\t\tstats->last_cb_mode_rx  = wil_rx_status_get_cb_mode(msg);\n\t}\n\n\tif (!wil->use_rx_hw_reordering && !wil->use_compressed_rx_status &&\n\t    wil_check_bar(wil, msg, cid, skb, stats) == -EAGAIN) {\n\t\tkfree_skb(skb);\n\t\tgoto again;\n\t}\n\n\t \n\tdata_offset = wil_rx_status_get_data_offset(msg);\n\tif (data_offset == 0xFF ||\n\t    data_offset > WIL_EDMA_MAX_DATA_OFFSET) {\n\t\twil_err(wil, \"Unexpected data offset %d\\n\", data_offset);\n\t\tkfree_skb(skb);\n\t\tgoto again;\n\t}\n\n\tskb_pull(skb, data_offset);\n\n\twil_hex_dump_txrx(\"Rx \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t  skb->data, skb_headlen(skb), false);\n\n\t \n\ts = wil_skb_rxstatus(skb);\n\tmemcpy(s, msg, sring->elem_size);\n\n\treturn skb;\n}\n\nvoid wil_rx_handle_edma(struct wil6210_priv *wil, int *quota)\n{\n\tstruct net_device *ndev;\n\tstruct wil_ring *ring = &wil->ring_rx;\n\tstruct wil_status_ring *sring;\n\tstruct sk_buff *skb;\n\tint i;\n\n\tif (unlikely(!ring->va)) {\n\t\twil_err(wil, \"Rx IRQ while Rx not yet initialized\\n\");\n\t\treturn;\n\t}\n\twil_dbg_txrx(wil, \"rx_handle\\n\");\n\n\tfor (i = 0; i < wil->num_rx_status_rings; i++) {\n\t\tsring = &wil->srings[i];\n\t\tif (unlikely(!sring->va)) {\n\t\t\twil_err(wil,\n\t\t\t\t\"Rx IRQ while Rx status ring %d not yet initialized\\n\",\n\t\t\t\ti);\n\t\t\tcontinue;\n\t\t}\n\n\t\twhile ((*quota > 0) &&\n\t\t       (NULL != (skb =\n\t\t\twil_sring_reap_rx_edma(wil, sring)))) {\n\t\t\t(*quota)--;\n\t\t\tif (wil->use_rx_hw_reordering) {\n\t\t\t\tvoid *msg = wil_skb_rxstatus(skb);\n\t\t\t\tint mid = wil_rx_status_get_mid(msg);\n\t\t\t\tstruct wil6210_vif *vif = wil->vifs[mid];\n\n\t\t\t\tif (unlikely(!vif)) {\n\t\t\t\t\twil_dbg_txrx(wil,\n\t\t\t\t\t\t     \"RX desc invalid mid %d\",\n\t\t\t\t\t\t     mid);\n\t\t\t\t\tkfree_skb(skb);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tndev = vif_to_ndev(vif);\n\t\t\t\twil_netif_rx_any(skb, ndev);\n\t\t\t} else {\n\t\t\t\twil_rx_reorder(wil, skb);\n\t\t\t}\n\t\t}\n\n\t\twil_w(wil, sring->hwtail, (sring->swhead - 1) % sring->size);\n\t}\n\n\twil_rx_refill_edma(wil);\n}\n\nstatic int wil_tx_desc_map_edma(union wil_tx_desc *desc,\n\t\t\t\tdma_addr_t pa,\n\t\t\t\tu32 len,\n\t\t\t\tint ring_index)\n{\n\tstruct wil_tx_enhanced_desc *d =\n\t\t(struct wil_tx_enhanced_desc *)&desc->enhanced;\n\n\tmemset(d, 0, sizeof(struct wil_tx_enhanced_desc));\n\n\twil_desc_set_addr_edma(&d->dma.addr, &d->dma.addr_high_high, pa);\n\n\t \n\td->dma.length = cpu_to_le16((u16)len);\n\td->mac.d[0] = (ring_index << WIL_EDMA_DESC_TX_MAC_CFG_0_QID_POS);\n\t \n\td->mac.d[2] = BIT(MAC_CFG_DESC_TX_2_SNAP_HDR_INSERTION_EN_POS) |\n\t\t      (0x3 << MAC_CFG_DESC_TX_2_L2_TRANSLATION_TYPE_POS);\n\n\treturn 0;\n}\n\nstatic inline void\nwil_get_next_tx_status_msg(struct wil_status_ring *sring, u8 *dr_bit,\n\t\t\t   struct wil_ring_tx_status *msg)\n{\n\tstruct wil_ring_tx_status *_msg = (struct wil_ring_tx_status *)\n\t\t(sring->va + (sring->elem_size * sring->swhead));\n\n\t*dr_bit = _msg->desc_ready >> TX_STATUS_DESC_READY_POS;\n\t \n\trmb();\n\t*msg = *_msg;\n}\n\n \nint wil_tx_sring_handler(struct wil6210_priv *wil,\n\t\t\t struct wil_status_ring *sring)\n{\n\tstruct net_device *ndev;\n\tstruct device *dev = wil_to_dev(wil);\n\tstruct wil_ring *ring = NULL;\n\tstruct wil_ring_tx_data *txdata;\n\t \n\tint desc_cnt = 0;\n\tint cid;\n\tstruct wil_net_stats *stats;\n\tstruct wil_tx_enhanced_desc *_d;\n\tunsigned int ring_id;\n\tunsigned int num_descs, num_statuses = 0;\n\tint i;\n\tu8 dr_bit;  \n\tstruct wil_ring_tx_status msg;\n\tstruct wil6210_vif *vif;\n\tint used_before_complete;\n\tint used_new;\n\n\twil_get_next_tx_status_msg(sring, &dr_bit, &msg);\n\n\t \n\twhile (dr_bit == sring->desc_rdy_pol) {\n\t\tnum_descs = msg.num_descriptors;\n\t\tif (!num_descs) {\n\t\t\twil_err(wil, \"invalid num_descs 0\\n\");\n\t\t\tgoto again;\n\t\t}\n\n\t\t \n\t\tring_id = msg.ring_id;\n\n\t\tif (unlikely(ring_id >= WIL6210_MAX_TX_RINGS)) {\n\t\t\twil_err(wil, \"invalid ring id %d\\n\", ring_id);\n\t\t\tgoto again;\n\t\t}\n\t\tring = &wil->ring_tx[ring_id];\n\t\tif (unlikely(!ring->va)) {\n\t\t\twil_err(wil, \"Tx irq[%d]: ring not initialized\\n\",\n\t\t\t\tring_id);\n\t\t\tgoto again;\n\t\t}\n\t\ttxdata = &wil->ring_tx_data[ring_id];\n\t\tif (unlikely(!txdata->enabled)) {\n\t\t\twil_info(wil, \"Tx irq[%d]: ring disabled\\n\", ring_id);\n\t\t\tgoto again;\n\t\t}\n\t\tvif = wil->vifs[txdata->mid];\n\t\tif (unlikely(!vif)) {\n\t\t\twil_dbg_txrx(wil, \"invalid MID %d for ring %d\\n\",\n\t\t\t\t     txdata->mid, ring_id);\n\t\t\tgoto again;\n\t\t}\n\n\t\tndev = vif_to_ndev(vif);\n\n\t\tcid = wil->ring2cid_tid[ring_id][0];\n\t\tstats = (cid < wil->max_assoc_sta) ? &wil->sta[cid].stats :\n\t\t\t\t\t\t     NULL;\n\n\t\twil_dbg_txrx(wil,\n\t\t\t     \"tx_status: completed desc_ring (%d), num_descs (%d)\\n\",\n\t\t\t     ring_id, num_descs);\n\n\t\tused_before_complete = wil_ring_used_tx(ring);\n\n\t\tfor (i = 0 ; i < num_descs; ++i) {\n\t\t\tstruct wil_ctx *ctx = &ring->ctx[ring->swtail];\n\t\t\tstruct wil_tx_enhanced_desc dd, *d = &dd;\n\t\t\tu16 dmalen;\n\t\t\tstruct sk_buff *skb = ctx->skb;\n\n\t\t\t_d = (struct wil_tx_enhanced_desc *)\n\t\t\t\t&ring->va[ring->swtail].tx.enhanced;\n\t\t\t*d = *_d;\n\n\t\t\tdmalen = le16_to_cpu(d->dma.length);\n\t\t\ttrace_wil6210_tx_status(&msg, ring->swtail, dmalen);\n\t\t\twil_dbg_txrx(wil,\n\t\t\t\t     \"TxC[%2d][%3d] : %d bytes, status 0x%02x\\n\",\n\t\t\t\t     ring_id, ring->swtail, dmalen,\n\t\t\t\t     msg.status);\n\t\t\twil_hex_dump_txrx(\"TxS \", DUMP_PREFIX_NONE, 32, 4,\n\t\t\t\t\t  (const void *)&msg, sizeof(msg),\n\t\t\t\t\t  false);\n\n\t\t\twil_tx_desc_unmap_edma(dev,\n\t\t\t\t\t       (union wil_tx_desc *)d,\n\t\t\t\t\t       ctx);\n\n\t\t\tif (skb) {\n\t\t\t\tif (likely(msg.status == 0)) {\n\t\t\t\t\tndev->stats.tx_packets++;\n\t\t\t\t\tndev->stats.tx_bytes += skb->len;\n\t\t\t\t\tif (stats) {\n\t\t\t\t\t\tstats->tx_packets++;\n\t\t\t\t\t\tstats->tx_bytes += skb->len;\n\n\t\t\t\t\t\twil_tx_latency_calc(wil, skb,\n\t\t\t\t\t\t\t&wil->sta[cid]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tndev->stats.tx_errors++;\n\t\t\t\t\tif (stats)\n\t\t\t\t\t\tstats->tx_errors++;\n\t\t\t\t}\n\n\t\t\t\tif (skb->protocol == cpu_to_be16(ETH_P_PAE))\n\t\t\t\t\twil_tx_complete_handle_eapol(vif, skb);\n\n\t\t\t\twil_consume_skb(skb, msg.status == 0);\n\t\t\t}\n\t\t\tmemset(ctx, 0, sizeof(*ctx));\n\t\t\t \n\t\t\twmb();\n\n\t\t\tring->swtail = wil_ring_next_tail(ring);\n\n\t\t\tdesc_cnt++;\n\t\t}\n\n\t\t \n\t\tused_new = wil_ring_used_tx(ring);\n\t\tif (wil_val_in_range(wil->ring_idle_trsh,\n\t\t\t\t     used_new, used_before_complete)) {\n\t\t\twil_dbg_txrx(wil, \"Ring[%2d] idle %d -> %d\\n\",\n\t\t\t\t     ring_id, used_before_complete, used_new);\n\t\t\ttxdata->last_idle = get_cycles();\n\t\t}\n\nagain:\n\t\tnum_statuses++;\n\t\tif (num_statuses % WIL_EDMA_TX_SRING_UPDATE_HW_TAIL == 0)\n\t\t\t \n\t\t\twil_w(wil, sring->hwtail, sring->swhead);\n\n\t\twil_sring_advance_swhead(sring);\n\n\t\twil_get_next_tx_status_msg(sring, &dr_bit, &msg);\n\t}\n\n\t \n\tif (desc_cnt)\n\t\twil_update_net_queues(wil, vif, NULL, false);\n\n\tif (num_statuses % WIL_EDMA_TX_SRING_UPDATE_HW_TAIL != 0)\n\t\t \n\t\twil_w(wil, sring->hwtail, (sring->swhead - 1) % sring->size);\n\n\treturn desc_cnt;\n}\n\n \nstatic void wil_tx_desc_offload_setup_tso_edma(struct wil_tx_enhanced_desc *d,\n\t\t\t\t\t       int tso_desc_type, bool is_ipv4,\n\t\t\t\t\t       int tcp_hdr_len,\n\t\t\t\t\t       int skb_net_hdr_len,\n\t\t\t\t\t       int mss)\n{\n\t \n\td->mac.d[2] |= 1;\n\t \n\td->mac.tso_mss |= cpu_to_le16(mss >> 2);\n\t \n\td->dma.l4_hdr_len |= tcp_hdr_len & DMA_CFG_DESC_TX_0_L4_LENGTH_MSK;\n\t \n\td->dma.cmd |= BIT(WIL_EDMA_DESC_TX_CFG_EOP_POS) |\n\t\t      tso_desc_type << WIL_EDMA_DESC_TX_CFG_TSO_DESC_TYPE_POS |\n\t\t      BIT(WIL_EDMA_DESC_TX_CFG_SEG_EN_POS) |\n\t\t      BIT(WIL_EDMA_DESC_TX_CFG_INSERT_IP_CHKSUM_POS) |\n\t\t      BIT(WIL_EDMA_DESC_TX_CFG_INSERT_TCP_CHKSUM_POS);\n\t \n\td->dma.w1 |= BIT(WIL_EDMA_DESC_TX_CFG_PSEUDO_HEADER_CALC_EN_POS) |\n\t\t     BIT(WIL_EDMA_DESC_TX_CFG_L4_TYPE_POS);\n\t \n\td->dma.ip_length |= skb_net_hdr_len;\n\t \n\td->dma.b11 |= ETH_HLEN |\n\t\t      is_ipv4 << DMA_CFG_DESC_TX_OFFLOAD_CFG_L3T_IPV4_POS;\n}\n\nstatic int wil_tx_tso_gen_desc(struct wil6210_priv *wil, void *buff_addr,\n\t\t\t       int len, uint i, int tso_desc_type,\n\t\t\t       skb_frag_t *frag, struct wil_ring *ring,\n\t\t\t       struct sk_buff *skb, bool is_ipv4,\n\t\t\t       int tcp_hdr_len, int skb_net_hdr_len,\n\t\t\t       int mss, int *descs_used)\n{\n\tstruct device *dev = wil_to_dev(wil);\n\tstruct wil_tx_enhanced_desc *_desc = (struct wil_tx_enhanced_desc *)\n\t\t&ring->va[i].tx.enhanced;\n\tstruct wil_tx_enhanced_desc desc_mem, *d = &desc_mem;\n\tint ring_index = ring - wil->ring_tx;\n\tdma_addr_t pa;\n\n\tif (len == 0)\n\t\treturn 0;\n\n\tif (!frag) {\n\t\tpa = dma_map_single(dev, buff_addr, len, DMA_TO_DEVICE);\n\t\tring->ctx[i].mapped_as = wil_mapped_as_single;\n\t} else {\n\t\tpa = skb_frag_dma_map(dev, frag, 0, len, DMA_TO_DEVICE);\n\t\tring->ctx[i].mapped_as = wil_mapped_as_page;\n\t}\n\tif (unlikely(dma_mapping_error(dev, pa))) {\n\t\twil_err(wil, \"TSO: Skb DMA map error\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\twil->txrx_ops.tx_desc_map((union wil_tx_desc *)d, pa,\n\t\t\t\t   len, ring_index);\n\twil_tx_desc_offload_setup_tso_edma(d, tso_desc_type, is_ipv4,\n\t\t\t\t\t   tcp_hdr_len,\n\t\t\t\t\t   skb_net_hdr_len, mss);\n\n\t \n\tif (tso_desc_type == wil_tso_type_lst)\n\t\tring->ctx[i].skb = skb_get(skb);\n\n\twil_hex_dump_txrx(\"TxD \", DUMP_PREFIX_NONE, 32, 4,\n\t\t\t  (const void *)d, sizeof(*d), false);\n\n\t*_desc = *d;\n\t(*descs_used)++;\n\n\treturn 0;\n}\n\nstatic int __wil_tx_ring_tso_edma(struct wil6210_priv *wil,\n\t\t\t\t  struct wil6210_vif *vif,\n\t\t\t\t  struct wil_ring *ring,\n\t\t\t\t  struct sk_buff *skb)\n{\n\tint ring_index = ring - wil->ring_tx;\n\tstruct wil_ring_tx_data *txdata = &wil->ring_tx_data[ring_index];\n\tint nr_frags = skb_shinfo(skb)->nr_frags;\n\tint min_desc_required = nr_frags + 2;  \n\tint used, avail = wil_ring_avail_tx(ring);\n\tint f, hdrlen, headlen;\n\tint gso_type;\n\tbool is_ipv4;\n\tu32 swhead = ring->swhead;\n\tint descs_used = 0;  \n\tint rc = -EINVAL;\n\tint tcp_hdr_len;\n\tint skb_net_hdr_len;\n\tint mss = skb_shinfo(skb)->gso_size;\n\n\twil_dbg_txrx(wil, \"tx_ring_tso: %d bytes to ring %d\\n\", skb->len,\n\t\t     ring_index);\n\n\tif (unlikely(!txdata->enabled))\n\t\treturn -EINVAL;\n\n\tif (unlikely(avail < min_desc_required)) {\n\t\twil_err_ratelimited(wil,\n\t\t\t\t    \"TSO: Tx ring[%2d] full. No space for %d fragments\\n\",\n\t\t\t\t    ring_index, min_desc_required);\n\t\treturn -ENOMEM;\n\t}\n\n\tgso_type = skb_shinfo(skb)->gso_type & (SKB_GSO_TCPV6 | SKB_GSO_TCPV4);\n\tswitch (gso_type) {\n\tcase SKB_GSO_TCPV4:\n\t\tis_ipv4 = true;\n\t\tbreak;\n\tcase SKB_GSO_TCPV6:\n\t\tis_ipv4 = false;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (skb->ip_summed != CHECKSUM_PARTIAL)\n\t\treturn -EINVAL;\n\n\t \n\ttcp_hdr_len = tcp_hdrlen(skb);\n\tskb_net_hdr_len = skb_network_header_len(skb);\n\n\t \n\thdrlen = ETH_HLEN + tcp_hdr_len + skb_net_hdr_len;\n\twil_dbg_txrx(wil, \"TSO: process header descriptor, hdrlen %u\\n\",\n\t\t     hdrlen);\n\trc = wil_tx_tso_gen_desc(wil, skb->data, hdrlen, swhead,\n\t\t\t\t wil_tso_type_hdr, NULL, ring, skb,\n\t\t\t\t is_ipv4, tcp_hdr_len, skb_net_hdr_len,\n\t\t\t\t mss, &descs_used);\n\tif (rc)\n\t\treturn -EINVAL;\n\n\t \n\theadlen = skb_headlen(skb) - hdrlen;\n\twil_dbg_txrx(wil, \"TSO: process skb head, headlen %u\\n\", headlen);\n\trc = wil_tx_tso_gen_desc(wil, skb->data + hdrlen, headlen,\n\t\t\t\t (swhead + descs_used) % ring->size,\n\t\t\t\t (nr_frags != 0) ? wil_tso_type_first :\n\t\t\t\t wil_tso_type_lst, NULL, ring, skb,\n\t\t\t\t is_ipv4, tcp_hdr_len, skb_net_hdr_len,\n\t\t\t\t mss, &descs_used);\n\tif (rc)\n\t\tgoto mem_error;\n\n\t \n\tfor (f = 0; f < nr_frags; f++) {\n\t\tskb_frag_t *frag = &skb_shinfo(skb)->frags[f];\n\t\tint len = skb_frag_size(frag);\n\n\t\twil_dbg_txrx(wil, \"TSO: frag[%d]: len %u, descs_used %d\\n\", f,\n\t\t\t     len, descs_used);\n\n\t\trc = wil_tx_tso_gen_desc(wil, NULL, len,\n\t\t\t\t\t (swhead + descs_used) % ring->size,\n\t\t\t\t\t (f != nr_frags - 1) ?\n\t\t\t\t\t wil_tso_type_mid : wil_tso_type_lst,\n\t\t\t\t\t frag, ring, skb, is_ipv4,\n\t\t\t\t\t tcp_hdr_len, skb_net_hdr_len,\n\t\t\t\t\t mss, &descs_used);\n\t\tif (rc)\n\t\t\tgoto mem_error;\n\t}\n\n\t \n\tused = wil_ring_used_tx(ring);\n\tif (wil_val_in_range(wil->ring_idle_trsh,\n\t\t\t     used, used + descs_used)) {\n\t\ttxdata->idle += get_cycles() - txdata->last_idle;\n\t\twil_dbg_txrx(wil,  \"Ring[%2d] not idle %d -> %d\\n\",\n\t\t\t     ring_index, used, used + descs_used);\n\t}\n\n\t \n\twil_ring_advance_head(ring, descs_used);\n\twil_dbg_txrx(wil, \"TSO: Tx swhead %d -> %d\\n\", swhead, ring->swhead);\n\n\t \n\twmb();\n\n\tif (wil->tx_latency)\n\t\t*(ktime_t *)&skb->cb = ktime_get();\n\telse\n\t\tmemset(skb->cb, 0, sizeof(ktime_t));\n\n\twil_w(wil, ring->hwtail, ring->swhead);\n\n\treturn 0;\n\nmem_error:\n\twhile (descs_used > 0) {\n\t\tstruct device *dev = wil_to_dev(wil);\n\t\tstruct wil_ctx *ctx;\n\t\tint i = (swhead + descs_used - 1) % ring->size;\n\t\tstruct wil_tx_enhanced_desc dd, *d = &dd;\n\t\tstruct wil_tx_enhanced_desc *_desc =\n\t\t\t(struct wil_tx_enhanced_desc *)\n\t\t\t&ring->va[i].tx.enhanced;\n\n\t\t*d = *_desc;\n\t\tctx = &ring->ctx[i];\n\t\twil_tx_desc_unmap_edma(dev, (union wil_tx_desc *)d, ctx);\n\t\tmemset(ctx, 0, sizeof(*ctx));\n\t\tdescs_used--;\n\t}\n\treturn rc;\n}\n\nstatic int wil_ring_init_bcast_edma(struct wil6210_vif *vif, int ring_id,\n\t\t\t\t    int size)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tstruct wil_ring *ring = &wil->ring_tx[ring_id];\n\tint rc;\n\tstruct wil_ring_tx_data *txdata = &wil->ring_tx_data[ring_id];\n\n\twil_dbg_misc(wil, \"init bcast: ring_id=%d, sring_id=%d\\n\",\n\t\t     ring_id, wil->tx_sring_idx);\n\n\tlockdep_assert_held(&wil->mutex);\n\n\twil_tx_data_init(txdata);\n\tring->size = size;\n\tring->is_rx = false;\n\trc = wil_ring_alloc_desc_ring(wil, ring);\n\tif (rc)\n\t\tgoto out;\n\n\twil->ring2cid_tid[ring_id][0] = WIL6210_MAX_CID;  \n\twil->ring2cid_tid[ring_id][1] = 0;  \n\tif (!vif->privacy)\n\t\ttxdata->dot1x_open = true;\n\n\trc = wil_wmi_bcast_desc_ring_add(vif, ring_id);\n\tif (rc)\n\t\tgoto out_free;\n\n\treturn 0;\n\n out_free:\n\tspin_lock_bh(&txdata->lock);\n\ttxdata->enabled = 0;\n\ttxdata->dot1x_open = false;\n\tspin_unlock_bh(&txdata->lock);\n\twil_ring_free_edma(wil, ring);\n\nout:\n\treturn rc;\n}\n\nstatic void wil_tx_fini_edma(struct wil6210_priv *wil)\n{\n\tstruct wil_status_ring *sring = &wil->srings[wil->tx_sring_idx];\n\n\twil_dbg_misc(wil, \"free TX sring\\n\");\n\n\twil_sring_free(wil, sring);\n}\n\nstatic void wil_rx_data_free(struct wil_status_ring *sring)\n{\n\tif (!sring)\n\t\treturn;\n\n\tkfree_skb(sring->rx_data.skb);\n\tsring->rx_data.skb = NULL;\n}\n\nstatic void wil_rx_fini_edma(struct wil6210_priv *wil)\n{\n\tstruct wil_ring *ring = &wil->ring_rx;\n\tint i;\n\n\twil_dbg_misc(wil, \"rx_fini_edma\\n\");\n\n\twil_ring_free_edma(wil, ring);\n\n\tfor (i = 0; i < wil->num_rx_status_rings; i++) {\n\t\twil_rx_data_free(&wil->srings[i]);\n\t\twil_sring_free(wil, &wil->srings[i]);\n\t}\n\n\twil_free_rx_buff_arr(wil);\n}\n\nvoid wil_init_txrx_ops_edma(struct wil6210_priv *wil)\n{\n\twil->txrx_ops.configure_interrupt_moderation =\n\t\twil_configure_interrupt_moderation_edma;\n\t \n\twil->txrx_ops.ring_init_tx = wil_ring_init_tx_edma;\n\twil->txrx_ops.ring_fini_tx = wil_ring_free_edma;\n\twil->txrx_ops.ring_init_bcast = wil_ring_init_bcast_edma;\n\twil->txrx_ops.tx_init = wil_tx_init_edma;\n\twil->txrx_ops.tx_fini = wil_tx_fini_edma;\n\twil->txrx_ops.tx_desc_map = wil_tx_desc_map_edma;\n\twil->txrx_ops.tx_desc_unmap = wil_tx_desc_unmap_edma;\n\twil->txrx_ops.tx_ring_tso = __wil_tx_ring_tso_edma;\n\twil->txrx_ops.tx_ring_modify = wil_tx_ring_modify_edma;\n\t \n\twil->txrx_ops.rx_init = wil_rx_init_edma;\n\twil->txrx_ops.wmi_addba_rx_resp = wmi_addba_rx_resp_edma;\n\twil->txrx_ops.get_reorder_params = wil_get_reorder_params_edma;\n\twil->txrx_ops.get_netif_rx_params = wil_get_netif_rx_params_edma;\n\twil->txrx_ops.rx_crypto_check = wil_rx_crypto_check_edma;\n\twil->txrx_ops.rx_error_check = wil_rx_error_check_edma;\n\twil->txrx_ops.is_rx_idle = wil_is_rx_idle_edma;\n\twil->txrx_ops.rx_fini = wil_rx_fini_edma;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}