{
  "module_name": "pcie_bus.c",
  "hash_id": "0aeb2fa567875f5ec0f507f4b09578f27a32c8b7e0c5005f3ac5dc52eee5a2a2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/wil6210/pcie_bus.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/moduleparam.h>\n#include <linux/interrupt.h>\n#include <linux/suspend.h>\n#include \"wil6210.h\"\n#include <linux/rtnetlink.h>\n#include <linux/pm_runtime.h>\n\nstatic int n_msi = 3;\nmodule_param(n_msi, int, 0444);\nMODULE_PARM_DESC(n_msi, \" Use MSI interrupt: 0 - use INTx, 1 - single, or 3 - (default) \");\n\nbool ftm_mode;\nmodule_param(ftm_mode, bool, 0444);\nMODULE_PARM_DESC(ftm_mode, \" Set factory test mode, default - false\");\n\nstatic int wil6210_pm_notify(struct notifier_block *notify_block,\n\t\t\t     unsigned long mode, void *unused);\n\nstatic\nint wil_set_capabilities(struct wil6210_priv *wil)\n{\n\tconst char *wil_fw_name;\n\tu32 jtag_id = wil_r(wil, RGF_USER_JTAG_DEV_ID);\n\tu8 chip_revision = (wil_r(wil, RGF_USER_REVISION_ID) &\n\t\t\t    RGF_USER_REVISION_ID_MASK);\n\tint platform_capa;\n\tstruct fw_map *iccm_section, *sct;\n\n\tbitmap_zero(wil->hw_capa, hw_capa_last);\n\tbitmap_zero(wil->fw_capabilities, WMI_FW_CAPABILITY_MAX);\n\tbitmap_zero(wil->platform_capa, WIL_PLATFORM_CAPA_MAX);\n\twil->wil_fw_name = ftm_mode ? WIL_FW_NAME_FTM_DEFAULT :\n\t\t\t   WIL_FW_NAME_DEFAULT;\n\twil->chip_revision = chip_revision;\n\n\tswitch (jtag_id) {\n\tcase JTAG_DEV_ID_SPARROW:\n\t\tmemcpy(fw_mapping, sparrow_fw_mapping,\n\t\t       sizeof(sparrow_fw_mapping));\n\t\tswitch (chip_revision) {\n\t\tcase REVISION_ID_SPARROW_D0:\n\t\t\twil->hw_name = \"Sparrow D0\";\n\t\t\twil->hw_version = HW_VER_SPARROW_D0;\n\t\t\twil_fw_name = ftm_mode ? WIL_FW_NAME_FTM_SPARROW_PLUS :\n\t\t\t\t      WIL_FW_NAME_SPARROW_PLUS;\n\n\t\t\tif (wil_fw_verify_file_exists(wil, wil_fw_name))\n\t\t\t\twil->wil_fw_name = wil_fw_name;\n\t\t\tsct = wil_find_fw_mapping(\"mac_rgf_ext\");\n\t\t\tif (!sct) {\n\t\t\t\twil_err(wil, \"mac_rgf_ext section not found in fw_mapping\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tmemcpy(sct, &sparrow_d0_mac_rgf_ext, sizeof(*sct));\n\t\t\tbreak;\n\t\tcase REVISION_ID_SPARROW_B0:\n\t\t\twil->hw_name = \"Sparrow B0\";\n\t\t\twil->hw_version = HW_VER_SPARROW_B0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\twil->hw_name = \"Unknown\";\n\t\t\twil->hw_version = HW_VER_UNKNOWN;\n\t\t\tbreak;\n\t\t}\n\t\twil->rgf_fw_assert_code_addr = SPARROW_RGF_FW_ASSERT_CODE;\n\t\twil->rgf_ucode_assert_code_addr = SPARROW_RGF_UCODE_ASSERT_CODE;\n\t\tbreak;\n\tcase JTAG_DEV_ID_TALYN:\n\t\twil->hw_name = \"Talyn-MA\";\n\t\twil->hw_version = HW_VER_TALYN;\n\t\tmemcpy(fw_mapping, talyn_fw_mapping, sizeof(talyn_fw_mapping));\n\t\twil->rgf_fw_assert_code_addr = TALYN_RGF_FW_ASSERT_CODE;\n\t\twil->rgf_ucode_assert_code_addr = TALYN_RGF_UCODE_ASSERT_CODE;\n\t\tif (wil_r(wil, RGF_USER_OTP_HW_RD_MACHINE_1) &\n\t\t    BIT_NO_FLASH_INDICATION)\n\t\t\tset_bit(hw_capa_no_flash, wil->hw_capa);\n\t\twil_fw_name = ftm_mode ? WIL_FW_NAME_FTM_TALYN :\n\t\t\t      WIL_FW_NAME_TALYN;\n\t\tif (wil_fw_verify_file_exists(wil, wil_fw_name))\n\t\t\twil->wil_fw_name = wil_fw_name;\n\t\tbreak;\n\tcase JTAG_DEV_ID_TALYN_MB:\n\t\twil->hw_name = \"Talyn-MB\";\n\t\twil->hw_version = HW_VER_TALYN_MB;\n\t\tmemcpy(fw_mapping, talyn_mb_fw_mapping,\n\t\t       sizeof(talyn_mb_fw_mapping));\n\t\twil->rgf_fw_assert_code_addr = TALYN_RGF_FW_ASSERT_CODE;\n\t\twil->rgf_ucode_assert_code_addr = TALYN_RGF_UCODE_ASSERT_CODE;\n\t\tset_bit(hw_capa_no_flash, wil->hw_capa);\n\t\twil->use_enhanced_dma_hw = true;\n\t\twil->use_rx_hw_reordering = true;\n\t\twil->use_compressed_rx_status = true;\n\t\twil_fw_name = ftm_mode ? WIL_FW_NAME_FTM_TALYN :\n\t\t\t      WIL_FW_NAME_TALYN;\n\t\tif (wil_fw_verify_file_exists(wil, wil_fw_name))\n\t\t\twil->wil_fw_name = wil_fw_name;\n\t\tbreak;\n\tdefault:\n\t\twil_err(wil, \"Unknown board hardware, chip_id 0x%08x, chip_revision 0x%08x\\n\",\n\t\t\tjtag_id, chip_revision);\n\t\twil->hw_name = \"Unknown\";\n\t\twil->hw_version = HW_VER_UNKNOWN;\n\t\treturn -EINVAL;\n\t}\n\n\twil_init_txrx_ops(wil);\n\n\ticcm_section = wil_find_fw_mapping(\"fw_code\");\n\tif (!iccm_section) {\n\t\twil_err(wil, \"fw_code section not found in fw_mapping\\n\");\n\t\treturn -EINVAL;\n\t}\n\twil->iccm_base = iccm_section->host;\n\n\twil_info(wil, \"Board hardware is %s, flash %sexist\\n\", wil->hw_name,\n\t\t test_bit(hw_capa_no_flash, wil->hw_capa) ? \"doesn't \" : \"\");\n\n\t \n\tif (wil->platform_ops.get_capa) {\n\t\tplatform_capa =\n\t\t\twil->platform_ops.get_capa(wil->platform_handle);\n\t\tmemcpy(wil->platform_capa, &platform_capa,\n\t\t       min(sizeof(wil->platform_capa), sizeof(platform_capa)));\n\t}\n\n\twil_info(wil, \"platform_capa 0x%lx\\n\", *wil->platform_capa);\n\n\t \n\twil_request_firmware(wil, wil->wil_fw_name, false);\n\twil_refresh_fw_capabilities(wil);\n\n\treturn 0;\n}\n\nvoid wil_disable_irq(struct wil6210_priv *wil)\n{\n\tint irq = wil->pdev->irq;\n\n\tdisable_irq(irq);\n\tif (wil->n_msi == 3) {\n\t\tdisable_irq(irq + 1);\n\t\tdisable_irq(irq + 2);\n\t}\n}\n\nvoid wil_enable_irq(struct wil6210_priv *wil)\n{\n\tint irq = wil->pdev->irq;\n\n\tenable_irq(irq);\n\tif (wil->n_msi == 3) {\n\t\tenable_irq(irq + 1);\n\t\tenable_irq(irq + 2);\n\t}\n}\n\nstatic void wil_remove_all_additional_vifs(struct wil6210_priv *wil)\n{\n\tstruct wil6210_vif *vif;\n\tint i;\n\n\tfor (i = 1; i < GET_MAX_VIFS(wil); i++) {\n\t\tvif = wil->vifs[i];\n\t\tif (vif) {\n\t\t\twil_vif_prepare_stop(vif);\n\t\t\twil_vif_remove(wil, vif->mid);\n\t\t}\n\t}\n}\n\n \nstatic int wil_if_pcie_enable(struct wil6210_priv *wil)\n{\n\tstruct pci_dev *pdev = wil->pdev;\n\tint rc;\n\t \n\tint msi_only = pdev->msi_enabled;\n\n\twil_dbg_misc(wil, \"if_pcie_enable\\n\");\n\n\tpci_set_master(pdev);\n\n\t \n\tswitch (n_msi) {\n\tcase 3:\n\tcase 1:\n\t\twil_dbg_misc(wil, \"Setup %d MSI interrupts\\n\", n_msi);\n\t\tbreak;\n\tcase 0:\n\t\twil_dbg_misc(wil, \"MSI interrupts disabled, use INTx\\n\");\n\t\tbreak;\n\tdefault:\n\t\twil_err(wil, \"Invalid n_msi=%d, default to 1\\n\", n_msi);\n\t\tn_msi = 1;\n\t}\n\n\tif (n_msi == 3 &&\n\t    pci_alloc_irq_vectors(pdev, n_msi, n_msi, PCI_IRQ_MSI) < n_msi) {\n\t\twil_err(wil, \"3 MSI mode failed, try 1 MSI\\n\");\n\t\tn_msi = 1;\n\t}\n\n\tif (n_msi == 1 && pci_enable_msi(pdev)) {\n\t\twil_err(wil, \"pci_enable_msi failed, use INTx\\n\");\n\t\tn_msi = 0;\n\t}\n\n\twil->n_msi = n_msi;\n\n\tif (wil->n_msi == 0 && msi_only) {\n\t\twil_err(wil, \"Interrupt pin not routed, unable to use INTx\\n\");\n\t\trc = -ENODEV;\n\t\tgoto stop_master;\n\t}\n\n\trc = wil6210_init_irq(wil, pdev->irq);\n\tif (rc)\n\t\tgoto release_vectors;\n\n\t \n\tmutex_lock(&wil->mutex);\n\trc = wil_reset(wil, false);\n\tmutex_unlock(&wil->mutex);\n\tif (rc)\n\t\tgoto release_irq;\n\n\treturn 0;\n\n release_irq:\n\twil6210_fini_irq(wil, pdev->irq);\n release_vectors:\n\t \n\tpci_free_irq_vectors(pdev);\n stop_master:\n\tpci_clear_master(pdev);\n\treturn rc;\n}\n\nstatic int wil_if_pcie_disable(struct wil6210_priv *wil)\n{\n\tstruct pci_dev *pdev = wil->pdev;\n\n\twil_dbg_misc(wil, \"if_pcie_disable\\n\");\n\n\tpci_clear_master(pdev);\n\t \n\twil6210_fini_irq(wil, pdev->irq);\n\t \n\tpci_disable_msi(pdev);\n\t \n\n\treturn 0;\n}\n\nstatic int wil_platform_rop_ramdump(void *wil_handle, void *buf, uint32_t size)\n{\n\tstruct wil6210_priv *wil = wil_handle;\n\n\tif (!wil)\n\t\treturn -EINVAL;\n\n\treturn wil_fw_copy_crash_dump(wil, buf, size);\n}\n\nstatic int wil_platform_rop_fw_recovery(void *wil_handle)\n{\n\tstruct wil6210_priv *wil = wil_handle;\n\n\tif (!wil)\n\t\treturn -EINVAL;\n\n\twil_fw_error_recovery(wil);\n\n\treturn 0;\n}\n\nstatic void wil_platform_ops_uninit(struct wil6210_priv *wil)\n{\n\tif (wil->platform_ops.uninit)\n\t\twil->platform_ops.uninit(wil->platform_handle);\n\tmemset(&wil->platform_ops, 0, sizeof(wil->platform_ops));\n}\n\nstatic int wil_pcie_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct wil6210_priv *wil;\n\tstruct device *dev = &pdev->dev;\n\tint rc;\n\tconst struct wil_platform_rops rops = {\n\t\t.ramdump = wil_platform_rop_ramdump,\n\t\t.fw_recovery = wil_platform_rop_fw_recovery,\n\t};\n\tu32 bar_size = pci_resource_len(pdev, 0);\n\tint dma_addr_size[] = {64, 48, 40, 32};  \n\tint i, start_idx;\n\n\t \n\tdev_info(&pdev->dev, WIL_NAME\n\t\t \" device found [%04x:%04x] (rev %x) bar size 0x%x\\n\",\n\t\t (int)pdev->vendor, (int)pdev->device, (int)pdev->revision,\n\t\t bar_size);\n\n\tif ((bar_size < WIL6210_MIN_MEM_SIZE) ||\n\t    (bar_size > WIL6210_MAX_MEM_SIZE)) {\n\t\tdev_err(&pdev->dev, \"Unexpected BAR0 size 0x%x\\n\",\n\t\t\tbar_size);\n\t\treturn -ENODEV;\n\t}\n\n\twil = wil_if_alloc(dev);\n\tif (IS_ERR(wil)) {\n\t\trc = (int)PTR_ERR(wil);\n\t\tdev_err(dev, \"wil_if_alloc failed: %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\twil->pdev = pdev;\n\tpci_set_drvdata(pdev, wil);\n\twil->bar_size = bar_size;\n\t \n\n\twil->platform_handle =\n\t\twil_platform_init(&pdev->dev, &wil->platform_ops, &rops, wil);\n\tif (!wil->platform_handle) {\n\t\trc = -ENODEV;\n\t\twil_err(wil, \"wil_platform_init failed\\n\");\n\t\tgoto if_free;\n\t}\n\t \n\trc = pci_enable_device(pdev);\n\tif (rc && pdev->msi_enabled == 0) {\n\t\twil_err(wil,\n\t\t\t\"pci_enable_device failed, retry with MSI only\\n\");\n\t\t \n\t\tpdev->msi_enabled = 1;\n\t\trc = pci_enable_device(pdev);\n\t}\n\tif (rc) {\n\t\twil_err(wil,\n\t\t\t\"pci_enable_device failed, even with MSI only\\n\");\n\t\tgoto err_plat;\n\t}\n\t \n\tpci_set_power_state(pdev, PCI_D0);\n\n\trc = pci_request_region(pdev, 0, WIL_NAME);\n\tif (rc) {\n\t\twil_err(wil, \"pci_request_region failed\\n\");\n\t\tgoto err_disable_pdev;\n\t}\n\t \n\n\twil->csr = pci_ioremap_bar(pdev, 0);\n\tif (!wil->csr) {\n\t\twil_err(wil, \"pci_ioremap_bar failed\\n\");\n\t\trc = -ENODEV;\n\t\tgoto err_release_reg;\n\t}\n\t \n\twil_info(wil, \"CSR at %pR -> 0x%p\\n\", &pdev->resource[0], wil->csr);\n\n\trc = wil_set_capabilities(wil);\n\tif (rc) {\n\t\twil_err(wil, \"wil_set_capabilities failed, rc %d\\n\", rc);\n\t\tgoto err_iounmap;\n\t}\n\n\t \n\tstart_idx = wil->use_enhanced_dma_hw ? 0 : 1;\n\n\tfor (i = start_idx; i < ARRAY_SIZE(dma_addr_size); i++) {\n\t\trc = dma_set_mask_and_coherent(dev,\n\t\t\t\t\t       DMA_BIT_MASK(dma_addr_size[i]));\n\t\tif (rc) {\n\t\t\tdev_err(dev, \"dma_set_mask_and_coherent(%d) failed: %d\\n\",\n\t\t\t\tdma_addr_size[i], rc);\n\t\t\tcontinue;\n\t\t}\n\t\tdev_info(dev, \"using dma mask %d\", dma_addr_size[i]);\n\t\twil->dma_addr_size = dma_addr_size[i];\n\t\tbreak;\n\t}\n\n\tif (wil->dma_addr_size == 0)\n\t\tgoto err_iounmap;\n\n\twil6210_clear_irq(wil);\n\n\t \n\trc = wil_if_pcie_enable(wil);\n\tif (rc) {\n\t\twil_err(wil, \"Enable device failed\\n\");\n\t\tgoto err_iounmap;\n\t}\n\t \n\n\twil_clear_fw_log_addr(wil);\n\trc = wil_if_add(wil);\n\tif (rc) {\n\t\twil_err(wil, \"wil_if_add failed: %d\\n\", rc);\n\t\tgoto bus_disable;\n\t}\n\n\t \n\tif (test_bit(WMI_FW_CAPABILITY_WMI_ONLY, wil->fw_capabilities)) {\n\t\twil_dbg_misc(wil, \"Loading WMI only FW\\n\");\n\t\tmutex_lock(&wil->mutex);\n\t\trc = wil_reset(wil, true);\n\t\tmutex_unlock(&wil->mutex);\n\t\tif (rc) {\n\t\t\twil_err(wil, \"failed to load WMI only FW\\n\");\n\t\t\t \n\t\t}\n\t}\n\n\tif (IS_ENABLED(CONFIG_PM))\n\t\twil->pm_notify.notifier_call = wil6210_pm_notify;\n\n\trc = register_pm_notifier(&wil->pm_notify);\n\tif (rc)\n\t\t \n\t\twil_err(wil, \"register_pm_notifier failed: %d\\n\", rc);\n\n\twil6210_debugfs_init(wil);\n\n\twil_pm_runtime_allow(wil);\n\n\treturn 0;\n\nbus_disable:\n\twil_if_pcie_disable(wil);\nerr_iounmap:\n\tpci_iounmap(pdev, wil->csr);\nerr_release_reg:\n\tpci_release_region(pdev, 0);\nerr_disable_pdev:\n\tpci_disable_device(pdev);\nerr_plat:\n\twil_platform_ops_uninit(wil);\nif_free:\n\twil_if_free(wil);\n\n\treturn rc;\n}\n\nstatic void wil_pcie_remove(struct pci_dev *pdev)\n{\n\tstruct wil6210_priv *wil = pci_get_drvdata(pdev);\n\tvoid __iomem *csr = wil->csr;\n\n\twil_dbg_misc(wil, \"pcie_remove\\n\");\n\n\tunregister_pm_notifier(&wil->pm_notify);\n\n\twil_pm_runtime_forbid(wil);\n\n\twil6210_debugfs_remove(wil);\n\trtnl_lock();\n\twiphy_lock(wil->wiphy);\n\twil_p2p_wdev_free(wil);\n\twil_remove_all_additional_vifs(wil);\n\twiphy_unlock(wil->wiphy);\n\trtnl_unlock();\n\twil_if_remove(wil);\n\twil_if_pcie_disable(wil);\n\tpci_iounmap(pdev, csr);\n\tpci_release_region(pdev, 0);\n\tpci_disable_device(pdev);\n\twil_platform_ops_uninit(wil);\n\twil_if_free(wil);\n}\n\nstatic const struct pci_device_id wil6210_pcie_ids[] = {\n\t{ PCI_DEVICE(0x1ae9, 0x0310) },\n\t{ PCI_DEVICE(0x1ae9, 0x0302) },  \n\t{ PCI_DEVICE(0x17cb, 0x1201) },  \n\t{  \t},\n};\nMODULE_DEVICE_TABLE(pci, wil6210_pcie_ids);\n\nstatic int wil6210_suspend(struct device *dev, bool is_runtime)\n{\n\tint rc = 0;\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct wil6210_priv *wil = pci_get_drvdata(pdev);\n\tbool keep_radio_on, active_ifaces;\n\n\twil_dbg_pm(wil, \"suspend: %s\\n\", is_runtime ? \"runtime\" : \"system\");\n\n\tmutex_lock(&wil->vif_mutex);\n\tactive_ifaces = wil_has_active_ifaces(wil, true, false);\n\tmutex_unlock(&wil->vif_mutex);\n\tkeep_radio_on = active_ifaces && wil->keep_radio_on_during_sleep;\n\n\trc = wil_can_suspend(wil, is_runtime);\n\tif (rc)\n\t\tgoto out;\n\n\trc = wil_suspend(wil, is_runtime, keep_radio_on);\n\tif (!rc) {\n\t\t \n\t\tif (!keep_radio_on) {\n\t\t\t \n\t\t\tpci_clear_master(pdev);\n\t\t\twil->suspend_stats.r_off.successful_suspends++;\n\t\t} else {\n\t\t\twil->suspend_stats.r_on.successful_suspends++;\n\t\t}\n\t}\nout:\n\treturn rc;\n}\n\nstatic int wil6210_resume(struct device *dev, bool is_runtime)\n{\n\tint rc = 0;\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct wil6210_priv *wil = pci_get_drvdata(pdev);\n\tbool keep_radio_on, active_ifaces;\n\n\twil_dbg_pm(wil, \"resume: %s\\n\", is_runtime ? \"runtime\" : \"system\");\n\n\tmutex_lock(&wil->vif_mutex);\n\tactive_ifaces = wil_has_active_ifaces(wil, true, false);\n\tmutex_unlock(&wil->vif_mutex);\n\tkeep_radio_on = active_ifaces && wil->keep_radio_on_during_sleep;\n\n\t \n\tif (!keep_radio_on)\n\t\t \n\t\tpci_set_master(pdev);\n\trc = wil_resume(wil, is_runtime, keep_radio_on);\n\tif (rc) {\n\t\twil_err(wil, \"device failed to resume (%d)\\n\", rc);\n\t\tif (!keep_radio_on) {\n\t\t\tpci_clear_master(pdev);\n\t\t\twil->suspend_stats.r_off.failed_resumes++;\n\t\t} else {\n\t\t\twil->suspend_stats.r_on.failed_resumes++;\n\t\t}\n\t} else {\n\t\tif (keep_radio_on)\n\t\t\twil->suspend_stats.r_on.successful_resumes++;\n\t\telse\n\t\t\twil->suspend_stats.r_off.successful_resumes++;\n\t}\n\n\treturn rc;\n}\n\nstatic int wil6210_pm_notify(struct notifier_block *notify_block,\n\t\t\t     unsigned long mode, void *unused)\n{\n\tstruct wil6210_priv *wil = container_of(\n\t\tnotify_block, struct wil6210_priv, pm_notify);\n\tint rc = 0;\n\tenum wil_platform_event evt;\n\n\twil_dbg_pm(wil, \"pm_notify: mode (%ld)\\n\", mode);\n\n\tswitch (mode) {\n\tcase PM_HIBERNATION_PREPARE:\n\tcase PM_SUSPEND_PREPARE:\n\tcase PM_RESTORE_PREPARE:\n\t\trc = wil_can_suspend(wil, false);\n\t\tif (rc)\n\t\t\tbreak;\n\t\tevt = WIL_PLATFORM_EVT_PRE_SUSPEND;\n\t\tif (wil->platform_ops.notify)\n\t\t\trc = wil->platform_ops.notify(wil->platform_handle,\n\t\t\t\t\t\t      evt);\n\t\tbreak;\n\tcase PM_POST_SUSPEND:\n\tcase PM_POST_HIBERNATION:\n\tcase PM_POST_RESTORE:\n\t\tevt = WIL_PLATFORM_EVT_POST_SUSPEND;\n\t\tif (wil->platform_ops.notify)\n\t\t\trc = wil->platform_ops.notify(wil->platform_handle,\n\t\t\t\t\t\t      evt);\n\t\tbreak;\n\tdefault:\n\t\twil_dbg_pm(wil, \"unhandled notify mode %ld\\n\", mode);\n\t\tbreak;\n\t}\n\n\twil_dbg_pm(wil, \"notification mode %ld: rc (%d)\\n\", mode, rc);\n\treturn rc;\n}\n\nstatic int __maybe_unused wil6210_pm_suspend(struct device *dev)\n{\n\treturn wil6210_suspend(dev, false);\n}\n\nstatic int __maybe_unused wil6210_pm_resume(struct device *dev)\n{\n\treturn wil6210_resume(dev, false);\n}\n\nstatic int __maybe_unused wil6210_pm_runtime_idle(struct device *dev)\n{\n\tstruct wil6210_priv *wil = dev_get_drvdata(dev);\n\n\twil_dbg_pm(wil, \"Runtime idle\\n\");\n\n\treturn wil_can_suspend(wil, true);\n}\n\nstatic int __maybe_unused wil6210_pm_runtime_resume(struct device *dev)\n{\n\treturn wil6210_resume(dev, true);\n}\n\nstatic int __maybe_unused wil6210_pm_runtime_suspend(struct device *dev)\n{\n\tstruct wil6210_priv *wil = dev_get_drvdata(dev);\n\n\tif (test_bit(wil_status_suspended, wil->status)) {\n\t\twil_dbg_pm(wil, \"trying to suspend while suspended\\n\");\n\t\treturn 1;\n\t}\n\n\treturn wil6210_suspend(dev, true);\n}\n\nstatic const struct dev_pm_ops wil6210_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(wil6210_pm_suspend, wil6210_pm_resume)\n\tSET_RUNTIME_PM_OPS(wil6210_pm_runtime_suspend,\n\t\t\t   wil6210_pm_runtime_resume,\n\t\t\t   wil6210_pm_runtime_idle)\n};\n\nstatic struct pci_driver wil6210_driver = {\n\t.probe\t\t= wil_pcie_probe,\n\t.remove\t\t= wil_pcie_remove,\n\t.id_table\t= wil6210_pcie_ids,\n\t.name\t\t= WIL_NAME,\n\t.driver\t\t= {\n\t\t.pm = &wil6210_pm_ops,\n\t},\n};\n\nstatic int __init wil6210_driver_init(void)\n{\n\tint rc;\n\n\trc = wil_platform_modinit();\n\tif (rc)\n\t\treturn rc;\n\n\trc = pci_register_driver(&wil6210_driver);\n\tif (rc)\n\t\twil_platform_modexit();\n\treturn rc;\n}\nmodule_init(wil6210_driver_init);\n\nstatic void __exit wil6210_driver_exit(void)\n{\n\tpci_unregister_driver(&wil6210_driver);\n\twil_platform_modexit();\n}\nmodule_exit(wil6210_driver_exit);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_AUTHOR(\"Qualcomm Atheros <wil6210@qca.qualcomm.com>\");\nMODULE_DESCRIPTION(\"Driver for 60g WiFi WIL6210 card\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}