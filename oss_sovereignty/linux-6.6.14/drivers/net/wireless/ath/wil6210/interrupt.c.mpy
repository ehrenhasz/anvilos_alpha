{
  "module_name": "interrupt.c",
  "hash_id": "9766641884c15e9e7acd346a19abc741628294673627daab78706a777f03d093",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/wil6210/interrupt.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n\n#include \"wil6210.h\"\n#include \"trace.h\"\n\n \n\n#define WIL6210_IRQ_DISABLE\t\t(0xFFFFFFFFUL)\n#define WIL6210_IRQ_DISABLE_NO_HALP\t(0xF7FFFFFFUL)\n#define WIL6210_IMC_RX\t\t(BIT_DMA_EP_RX_ICR_RX_DONE | \\\n\t\t\t\t BIT_DMA_EP_RX_ICR_RX_HTRSH)\n#define WIL6210_IMC_RX_NO_RX_HTRSH (WIL6210_IMC_RX & \\\n\t\t\t\t    (~(BIT_DMA_EP_RX_ICR_RX_HTRSH)))\n#define WIL6210_IMC_TX\t\t(BIT_DMA_EP_TX_ICR_TX_DONE | \\\n\t\t\t\tBIT_DMA_EP_TX_ICR_TX_DONE_N(0))\n#define WIL6210_IMC_TX_EDMA\t\tBIT_TX_STATUS_IRQ\n#define WIL6210_IMC_RX_EDMA\t\tBIT_RX_STATUS_IRQ\n#define WIL6210_IMC_MISC_NO_HALP\t(ISR_MISC_FW_READY | \\\n\t\t\t\t\t ISR_MISC_MBOX_EVT | \\\n\t\t\t\t\t ISR_MISC_FW_ERROR)\n#define WIL6210_IMC_MISC\t\t(WIL6210_IMC_MISC_NO_HALP | \\\n\t\t\t\t\t BIT_DMA_EP_MISC_ICR_HALP)\n#define WIL6210_IRQ_PSEUDO_MASK (u32)(~(BIT_DMA_PSEUDO_CAUSE_RX | \\\n\t\t\t\t\tBIT_DMA_PSEUDO_CAUSE_TX | \\\n\t\t\t\t\tBIT_DMA_PSEUDO_CAUSE_MISC))\n\n#if defined(CONFIG_WIL6210_ISR_COR)\n \n#define WIL_ICR_ICC_VALUE\t(0xFFFFFFFFUL)\n#define WIL_ICR_ICC_MISC_VALUE\t(0xF7FFFFFFUL)\n\nstatic inline void wil_icr_clear(u32 x, void __iomem *addr)\n{\n}\n#else  \n \n#define WIL_ICR_ICC_VALUE\t(0UL)\n#define WIL_ICR_ICC_MISC_VALUE\t(0UL)\n\nstatic inline void wil_icr_clear(u32 x, void __iomem *addr)\n{\n\twritel(x, addr);\n}\n#endif  \n\nstatic inline u32 wil_ioread32_and_clear(void __iomem *addr)\n{\n\tu32 x = readl(addr);\n\n\twil_icr_clear(x, addr);\n\n\treturn x;\n}\n\nstatic void wil6210_mask_irq_tx(struct wil6210_priv *wil)\n{\n\twil_w(wil, RGF_DMA_EP_TX_ICR + offsetof(struct RGF_ICR, IMS),\n\t      WIL6210_IRQ_DISABLE);\n}\n\nstatic void wil6210_mask_irq_tx_edma(struct wil6210_priv *wil)\n{\n\twil_w(wil, RGF_INT_GEN_TX_ICR + offsetof(struct RGF_ICR, IMS),\n\t      WIL6210_IRQ_DISABLE);\n}\n\nstatic void wil6210_mask_irq_rx(struct wil6210_priv *wil)\n{\n\twil_w(wil, RGF_DMA_EP_RX_ICR + offsetof(struct RGF_ICR, IMS),\n\t      WIL6210_IRQ_DISABLE);\n}\n\nstatic void wil6210_mask_irq_rx_edma(struct wil6210_priv *wil)\n{\n\twil_w(wil, RGF_INT_GEN_RX_ICR + offsetof(struct RGF_ICR, IMS),\n\t      WIL6210_IRQ_DISABLE);\n}\n\nstatic void wil6210_mask_irq_misc(struct wil6210_priv *wil, bool mask_halp)\n{\n\twil_dbg_irq(wil, \"mask_irq_misc: mask_halp(%s)\\n\",\n\t\t    mask_halp ? \"true\" : \"false\");\n\n\twil_w(wil, RGF_DMA_EP_MISC_ICR + offsetof(struct RGF_ICR, IMS),\n\t      mask_halp ? WIL6210_IRQ_DISABLE : WIL6210_IRQ_DISABLE_NO_HALP);\n}\n\nvoid wil6210_mask_halp(struct wil6210_priv *wil)\n{\n\twil_dbg_irq(wil, \"mask_halp\\n\");\n\n\twil_w(wil, RGF_DMA_EP_MISC_ICR + offsetof(struct RGF_ICR, IMS),\n\t      BIT_DMA_EP_MISC_ICR_HALP);\n}\n\nstatic void wil6210_mask_irq_pseudo(struct wil6210_priv *wil)\n{\n\twil_dbg_irq(wil, \"mask_irq_pseudo\\n\");\n\n\twil_w(wil, RGF_DMA_PSEUDO_CAUSE_MASK_SW, WIL6210_IRQ_DISABLE);\n\n\tclear_bit(wil_status_irqen, wil->status);\n}\n\nvoid wil6210_unmask_irq_tx(struct wil6210_priv *wil)\n{\n\twil_w(wil, RGF_DMA_EP_TX_ICR + offsetof(struct RGF_ICR, IMC),\n\t      WIL6210_IMC_TX);\n}\n\nvoid wil6210_unmask_irq_tx_edma(struct wil6210_priv *wil)\n{\n\twil_w(wil, RGF_INT_GEN_TX_ICR + offsetof(struct RGF_ICR, IMC),\n\t      WIL6210_IMC_TX_EDMA);\n}\n\nvoid wil6210_unmask_irq_rx(struct wil6210_priv *wil)\n{\n\tbool unmask_rx_htrsh = atomic_read(&wil->connected_vifs) > 0;\n\n\twil_w(wil, RGF_DMA_EP_RX_ICR + offsetof(struct RGF_ICR, IMC),\n\t      unmask_rx_htrsh ? WIL6210_IMC_RX : WIL6210_IMC_RX_NO_RX_HTRSH);\n}\n\nvoid wil6210_unmask_irq_rx_edma(struct wil6210_priv *wil)\n{\n\twil_w(wil, RGF_INT_GEN_RX_ICR + offsetof(struct RGF_ICR, IMC),\n\t      WIL6210_IMC_RX_EDMA);\n}\n\nstatic void wil6210_unmask_irq_misc(struct wil6210_priv *wil, bool unmask_halp)\n{\n\twil_dbg_irq(wil, \"unmask_irq_misc: unmask_halp(%s)\\n\",\n\t\t    unmask_halp ? \"true\" : \"false\");\n\n\twil_w(wil, RGF_DMA_EP_MISC_ICR + offsetof(struct RGF_ICR, IMC),\n\t      unmask_halp ? WIL6210_IMC_MISC : WIL6210_IMC_MISC_NO_HALP);\n}\n\nstatic void wil6210_unmask_halp(struct wil6210_priv *wil)\n{\n\twil_dbg_irq(wil, \"unmask_halp\\n\");\n\n\twil_w(wil, RGF_DMA_EP_MISC_ICR + offsetof(struct RGF_ICR, IMC),\n\t      BIT_DMA_EP_MISC_ICR_HALP);\n}\n\nstatic void wil6210_unmask_irq_pseudo(struct wil6210_priv *wil)\n{\n\twil_dbg_irq(wil, \"unmask_irq_pseudo\\n\");\n\n\tset_bit(wil_status_irqen, wil->status);\n\n\twil_w(wil, RGF_DMA_PSEUDO_CAUSE_MASK_SW, WIL6210_IRQ_PSEUDO_MASK);\n}\n\nvoid wil_mask_irq(struct wil6210_priv *wil)\n{\n\twil_dbg_irq(wil, \"mask_irq\\n\");\n\n\twil6210_mask_irq_tx(wil);\n\twil6210_mask_irq_tx_edma(wil);\n\twil6210_mask_irq_rx(wil);\n\twil6210_mask_irq_rx_edma(wil);\n\twil6210_mask_irq_misc(wil, true);\n\twil6210_mask_irq_pseudo(wil);\n}\n\nvoid wil_unmask_irq(struct wil6210_priv *wil)\n{\n\twil_dbg_irq(wil, \"unmask_irq\\n\");\n\n\twil_w(wil, RGF_DMA_EP_RX_ICR + offsetof(struct RGF_ICR, ICC),\n\t      WIL_ICR_ICC_VALUE);\n\twil_w(wil, RGF_DMA_EP_TX_ICR + offsetof(struct RGF_ICR, ICC),\n\t      WIL_ICR_ICC_VALUE);\n\twil_w(wil, RGF_DMA_EP_MISC_ICR + offsetof(struct RGF_ICR, ICC),\n\t      WIL_ICR_ICC_MISC_VALUE);\n\twil_w(wil, RGF_INT_GEN_TX_ICR + offsetof(struct RGF_ICR, ICC),\n\t      WIL_ICR_ICC_VALUE);\n\twil_w(wil, RGF_INT_GEN_RX_ICR + offsetof(struct RGF_ICR, ICC),\n\t      WIL_ICR_ICC_VALUE);\n\n\twil6210_unmask_irq_pseudo(wil);\n\tif (wil->use_enhanced_dma_hw) {\n\t\twil6210_unmask_irq_tx_edma(wil);\n\t\twil6210_unmask_irq_rx_edma(wil);\n\t} else {\n\t\twil6210_unmask_irq_tx(wil);\n\t\twil6210_unmask_irq_rx(wil);\n\t}\n\twil6210_unmask_irq_misc(wil, true);\n}\n\nvoid wil_configure_interrupt_moderation_edma(struct wil6210_priv *wil)\n{\n\tu32 moderation;\n\n\twil_s(wil, RGF_INT_GEN_IDLE_TIME_LIMIT, WIL_EDMA_IDLE_TIME_LIMIT_USEC);\n\n\twil_s(wil, RGF_INT_GEN_TIME_UNIT_LIMIT, WIL_EDMA_TIME_UNIT_CLK_CYCLES);\n\n\t \n\tmoderation = wil->rx_max_burst_duration |\n\t\t(WIL_EDMA_AGG_WATERMARK << WIL_EDMA_AGG_WATERMARK_POS);\n\twil_w(wil, RGF_INT_CTRL_INT_GEN_CFG_0, moderation);\n\twil_w(wil, RGF_INT_CTRL_INT_GEN_CFG_1, moderation);\n\n\t \n\twil_c(wil, RGF_INT_COUNT_ON_SPECIAL_EVT, 0x1FE);\n\twil_s(wil, RGF_INT_COUNT_ON_SPECIAL_EVT, 0x1);\n}\n\nvoid wil_configure_interrupt_moderation(struct wil6210_priv *wil)\n{\n\tstruct wireless_dev *wdev = wil->main_ndev->ieee80211_ptr;\n\n\twil_dbg_irq(wil, \"configure_interrupt_moderation\\n\");\n\n\t \n\tif (wdev->iftype == NL80211_IFTYPE_MONITOR)\n\t\treturn;\n\n\t \n\twil_w(wil, RGF_DMA_ITR_TX_CNT_CTL, BIT_DMA_ITR_TX_CNT_CTL_CLR);\n\twil_w(wil, RGF_DMA_ITR_TX_CNT_TRSH, wil->tx_max_burst_duration);\n\twil_info(wil, \"set ITR_TX_CNT_TRSH = %d usec\\n\",\n\t\t wil->tx_max_burst_duration);\n\t \n\twil_w(wil, RGF_DMA_ITR_TX_CNT_CTL,\n\t      BIT_DMA_ITR_TX_CNT_CTL_EN | BIT_DMA_ITR_TX_CNT_CTL_EXT_TIC_SEL);\n\n\t \n\twil_w(wil, RGF_DMA_ITR_TX_IDL_CNT_CTL, BIT_DMA_ITR_TX_IDL_CNT_CTL_CLR);\n\twil_w(wil, RGF_DMA_ITR_TX_IDL_CNT_TRSH, wil->tx_interframe_timeout);\n\twil_info(wil, \"set ITR_TX_IDL_CNT_TRSH = %d usec\\n\",\n\t\t wil->tx_interframe_timeout);\n\t \n\twil_w(wil, RGF_DMA_ITR_TX_IDL_CNT_CTL, BIT_DMA_ITR_TX_IDL_CNT_CTL_EN |\n\t      BIT_DMA_ITR_TX_IDL_CNT_CTL_EXT_TIC_SEL);\n\n\t \n\twil_w(wil, RGF_DMA_ITR_RX_CNT_CTL, BIT_DMA_ITR_RX_CNT_CTL_CLR);\n\twil_w(wil, RGF_DMA_ITR_RX_CNT_TRSH, wil->rx_max_burst_duration);\n\twil_info(wil, \"set ITR_RX_CNT_TRSH = %d usec\\n\",\n\t\t wil->rx_max_burst_duration);\n\t \n\twil_w(wil, RGF_DMA_ITR_RX_CNT_CTL,\n\t      BIT_DMA_ITR_RX_CNT_CTL_EN | BIT_DMA_ITR_RX_CNT_CTL_EXT_TIC_SEL);\n\n\t \n\twil_w(wil, RGF_DMA_ITR_RX_IDL_CNT_CTL, BIT_DMA_ITR_RX_IDL_CNT_CTL_CLR);\n\twil_w(wil, RGF_DMA_ITR_RX_IDL_CNT_TRSH, wil->rx_interframe_timeout);\n\twil_info(wil, \"set ITR_RX_IDL_CNT_TRSH = %d usec\\n\",\n\t\t wil->rx_interframe_timeout);\n\t \n\twil_w(wil, RGF_DMA_ITR_RX_IDL_CNT_CTL, BIT_DMA_ITR_RX_IDL_CNT_CTL_EN |\n\t      BIT_DMA_ITR_RX_IDL_CNT_CTL_EXT_TIC_SEL);\n}\n\nstatic irqreturn_t wil6210_irq_rx(int irq, void *cookie)\n{\n\tstruct wil6210_priv *wil = cookie;\n\tu32 isr;\n\tbool need_unmask = true;\n\n\twil6210_mask_irq_rx(wil);\n\n\tisr = wil_ioread32_and_clear(wil->csr +\n\t\t\t\t     HOSTADDR(RGF_DMA_EP_RX_ICR) +\n\t\t\t\t     offsetof(struct RGF_ICR, ICR));\n\n\ttrace_wil6210_irq_rx(isr);\n\twil_dbg_irq(wil, \"ISR RX 0x%08x\\n\", isr);\n\n\tif (unlikely(!isr)) {\n\t\twil_err_ratelimited(wil, \"spurious IRQ: RX\\n\");\n\t\twil6210_unmask_irq_rx(wil);\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tif (likely(isr & (BIT_DMA_EP_RX_ICR_RX_DONE |\n\t\t\t  BIT_DMA_EP_RX_ICR_RX_HTRSH))) {\n\t\twil_dbg_irq(wil, \"RX done / RX_HTRSH received, ISR (0x%x)\\n\",\n\t\t\t    isr);\n\n\t\tisr &= ~(BIT_DMA_EP_RX_ICR_RX_DONE |\n\t\t\t BIT_DMA_EP_RX_ICR_RX_HTRSH);\n\t\tif (likely(test_bit(wil_status_fwready, wil->status))) {\n\t\t\tif (likely(test_bit(wil_status_napi_en, wil->status))) {\n\t\t\t\twil_dbg_txrx(wil, \"NAPI(Rx) schedule\\n\");\n\t\t\t\tneed_unmask = false;\n\t\t\t\tnapi_schedule(&wil->napi_rx);\n\t\t\t} else {\n\t\t\t\twil_err_ratelimited(\n\t\t\t\t\twil,\n\t\t\t\t\t\"Got Rx interrupt while stopping interface\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\twil_err_ratelimited(wil, \"Got Rx interrupt while in reset\\n\");\n\t\t}\n\t}\n\n\tif (unlikely(isr))\n\t\twil_err(wil, \"un-handled RX ISR bits 0x%08x\\n\", isr);\n\n\t \n\n\tatomic_inc(&wil->isr_count_rx);\n\n\tif (unlikely(need_unmask))\n\t\twil6210_unmask_irq_rx(wil);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t wil6210_irq_rx_edma(int irq, void *cookie)\n{\n\tstruct wil6210_priv *wil = cookie;\n\tu32 isr;\n\tbool need_unmask = true;\n\n\twil6210_mask_irq_rx_edma(wil);\n\n\tisr = wil_ioread32_and_clear(wil->csr +\n\t\t\t\t     HOSTADDR(RGF_INT_GEN_RX_ICR) +\n\t\t\t\t     offsetof(struct RGF_ICR, ICR));\n\n\ttrace_wil6210_irq_rx(isr);\n\twil_dbg_irq(wil, \"ISR RX 0x%08x\\n\", isr);\n\n\tif (unlikely(!isr)) {\n\t\twil_err(wil, \"spurious IRQ: RX\\n\");\n\t\twil6210_unmask_irq_rx_edma(wil);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (likely(isr & BIT_RX_STATUS_IRQ)) {\n\t\twil_dbg_irq(wil, \"RX status ring\\n\");\n\t\tisr &= ~BIT_RX_STATUS_IRQ;\n\t\tif (likely(test_bit(wil_status_fwready, wil->status))) {\n\t\t\tif (likely(test_bit(wil_status_napi_en, wil->status))) {\n\t\t\t\twil_dbg_txrx(wil, \"NAPI(Rx) schedule\\n\");\n\t\t\t\tneed_unmask = false;\n\t\t\t\tnapi_schedule(&wil->napi_rx);\n\t\t\t} else {\n\t\t\t\twil_err(wil,\n\t\t\t\t\t\"Got Rx interrupt while stopping interface\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\twil_err(wil, \"Got Rx interrupt while in reset\\n\");\n\t\t}\n\t}\n\n\tif (unlikely(isr))\n\t\twil_err(wil, \"un-handled RX ISR bits 0x%08x\\n\", isr);\n\n\t \n\n\tatomic_inc(&wil->isr_count_rx);\n\n\tif (unlikely(need_unmask))\n\t\twil6210_unmask_irq_rx_edma(wil);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t wil6210_irq_tx_edma(int irq, void *cookie)\n{\n\tstruct wil6210_priv *wil = cookie;\n\tu32 isr;\n\tbool need_unmask = true;\n\n\twil6210_mask_irq_tx_edma(wil);\n\n\tisr = wil_ioread32_and_clear(wil->csr +\n\t\t\t\t     HOSTADDR(RGF_INT_GEN_TX_ICR) +\n\t\t\t\t     offsetof(struct RGF_ICR, ICR));\n\n\ttrace_wil6210_irq_tx(isr);\n\twil_dbg_irq(wil, \"ISR TX 0x%08x\\n\", isr);\n\n\tif (unlikely(!isr)) {\n\t\twil_err(wil, \"spurious IRQ: TX\\n\");\n\t\twil6210_unmask_irq_tx_edma(wil);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (likely(isr & BIT_TX_STATUS_IRQ)) {\n\t\twil_dbg_irq(wil, \"TX status ring\\n\");\n\t\tisr &= ~BIT_TX_STATUS_IRQ;\n\t\tif (likely(test_bit(wil_status_fwready, wil->status))) {\n\t\t\twil_dbg_txrx(wil, \"NAPI(Tx) schedule\\n\");\n\t\t\tneed_unmask = false;\n\t\t\tnapi_schedule(&wil->napi_tx);\n\t\t} else {\n\t\t\twil_err(wil, \"Got Tx status ring IRQ while in reset\\n\");\n\t\t}\n\t}\n\n\tif (unlikely(isr))\n\t\twil_err(wil, \"un-handled TX ISR bits 0x%08x\\n\", isr);\n\n\t \n\n\tatomic_inc(&wil->isr_count_tx);\n\n\tif (unlikely(need_unmask))\n\t\twil6210_unmask_irq_tx_edma(wil);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t wil6210_irq_tx(int irq, void *cookie)\n{\n\tstruct wil6210_priv *wil = cookie;\n\tu32 isr;\n\tbool need_unmask = true;\n\n\twil6210_mask_irq_tx(wil);\n\n\tisr = wil_ioread32_and_clear(wil->csr +\n\t\t\t\t     HOSTADDR(RGF_DMA_EP_TX_ICR) +\n\t\t\t\t     offsetof(struct RGF_ICR, ICR));\n\n\ttrace_wil6210_irq_tx(isr);\n\twil_dbg_irq(wil, \"ISR TX 0x%08x\\n\", isr);\n\n\tif (unlikely(!isr)) {\n\t\twil_err_ratelimited(wil, \"spurious IRQ: TX\\n\");\n\t\twil6210_unmask_irq_tx(wil);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (likely(isr & BIT_DMA_EP_TX_ICR_TX_DONE)) {\n\t\twil_dbg_irq(wil, \"TX done\\n\");\n\t\tisr &= ~BIT_DMA_EP_TX_ICR_TX_DONE;\n\t\t \n\t\tisr &= ~(BIT(25) - 1UL);\n\t\tif (likely(test_bit(wil_status_fwready, wil->status))) {\n\t\t\twil_dbg_txrx(wil, \"NAPI(Tx) schedule\\n\");\n\t\t\tneed_unmask = false;\n\t\t\tnapi_schedule(&wil->napi_tx);\n\t\t} else {\n\t\t\twil_err_ratelimited(wil, \"Got Tx interrupt while in reset\\n\");\n\t\t}\n\t}\n\n\tif (unlikely(isr))\n\t\twil_err_ratelimited(wil, \"un-handled TX ISR bits 0x%08x\\n\",\n\t\t\t\t    isr);\n\n\t \n\n\tatomic_inc(&wil->isr_count_tx);\n\n\tif (unlikely(need_unmask))\n\t\twil6210_unmask_irq_tx(wil);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void wil_notify_fw_error(struct wil6210_priv *wil)\n{\n\tstruct device *dev = &wil->main_ndev->dev;\n\tchar *envp[3] = {\n\t\t[0] = \"SOURCE=wil6210\",\n\t\t[1] = \"EVENT=FW_ERROR\",\n\t\t[2] = NULL,\n\t};\n\twil_err(wil, \"Notify about firmware error\\n\");\n\tkobject_uevent_env(&dev->kobj, KOBJ_CHANGE, envp);\n}\n\nstatic void wil_cache_mbox_regs(struct wil6210_priv *wil)\n{\n\t \n\twil_memcpy_fromio_32(&wil->mbox_ctl, wil->csr + HOST_MBOX,\n\t\t\t     sizeof(struct wil6210_mbox_ctl));\n\twil_mbox_ring_le2cpus(&wil->mbox_ctl.rx);\n\twil_mbox_ring_le2cpus(&wil->mbox_ctl.tx);\n}\n\nstatic bool wil_validate_mbox_regs(struct wil6210_priv *wil)\n{\n\tsize_t min_size = sizeof(struct wil6210_mbox_hdr) +\n\t\tsizeof(struct wmi_cmd_hdr);\n\n\tif (wil->mbox_ctl.rx.entry_size < min_size) {\n\t\twil_err(wil, \"rx mbox entry too small (%d)\\n\",\n\t\t\twil->mbox_ctl.rx.entry_size);\n\t\treturn false;\n\t}\n\tif (wil->mbox_ctl.tx.entry_size < min_size) {\n\t\twil_err(wil, \"tx mbox entry too small (%d)\\n\",\n\t\t\twil->mbox_ctl.tx.entry_size);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic irqreturn_t wil6210_irq_misc(int irq, void *cookie)\n{\n\tstruct wil6210_priv *wil = cookie;\n\tu32 isr;\n\n\twil6210_mask_irq_misc(wil, false);\n\n\tisr = wil_ioread32_and_clear(wil->csr +\n\t\t\t\t     HOSTADDR(RGF_DMA_EP_MISC_ICR) +\n\t\t\t\t     offsetof(struct RGF_ICR, ICR));\n\n\ttrace_wil6210_irq_misc(isr);\n\twil_dbg_irq(wil, \"ISR MISC 0x%08x\\n\", isr);\n\n\tif (!isr) {\n\t\twil_err(wil, \"spurious IRQ: MISC\\n\");\n\t\twil6210_unmask_irq_misc(wil, false);\n\t\treturn IRQ_NONE;\n\t}\n\n\tif (isr & ISR_MISC_FW_ERROR) {\n\t\tu32 fw_assert_code = wil_r(wil, wil->rgf_fw_assert_code_addr);\n\t\tu32 ucode_assert_code =\n\t\t\twil_r(wil, wil->rgf_ucode_assert_code_addr);\n\n\t\twil_err(wil,\n\t\t\t\"Firmware error detected, assert codes FW 0x%08x, UCODE 0x%08x\\n\",\n\t\t\tfw_assert_code, ucode_assert_code);\n\t\tclear_bit(wil_status_fwready, wil->status);\n\t\t \n\t}\n\n\tif (isr & ISR_MISC_FW_READY) {\n\t\twil_dbg_irq(wil, \"IRQ: FW ready\\n\");\n\t\twil_cache_mbox_regs(wil);\n\t\tif (wil_validate_mbox_regs(wil))\n\t\t\tset_bit(wil_status_mbox_ready, wil->status);\n\t\t \n\t\tisr &= ~ISR_MISC_FW_READY;\n\t}\n\n\tif (isr & BIT_DMA_EP_MISC_ICR_HALP) {\n\t\tisr &= ~BIT_DMA_EP_MISC_ICR_HALP;\n\t\tif (wil->halp.handle_icr) {\n\t\t\t \n\t\t\twil->halp.handle_icr = false;\n\t\t\twil_dbg_irq(wil, \"irq_misc: HALP IRQ invoked\\n\");\n\t\t\twil6210_mask_irq_misc(wil, true);\n\t\t\tcomplete(&wil->halp.comp);\n\t\t}\n\t}\n\n\twil->isr_misc = isr;\n\n\tif (isr) {\n\t\treturn IRQ_WAKE_THREAD;\n\t} else {\n\t\twil6210_unmask_irq_misc(wil, false);\n\t\treturn IRQ_HANDLED;\n\t}\n}\n\nstatic irqreturn_t wil6210_irq_misc_thread(int irq, void *cookie)\n{\n\tstruct wil6210_priv *wil = cookie;\n\tu32 isr = wil->isr_misc;\n\n\ttrace_wil6210_irq_misc_thread(isr);\n\twil_dbg_irq(wil, \"Thread ISR MISC 0x%08x\\n\", isr);\n\n\tif (isr & ISR_MISC_FW_ERROR) {\n\t\twil->recovery_state = fw_recovery_pending;\n\t\twil_fw_core_dump(wil);\n\t\twil_notify_fw_error(wil);\n\t\tisr &= ~ISR_MISC_FW_ERROR;\n\t\tif (wil->platform_ops.notify) {\n\t\t\twil_err(wil, \"notify platform driver about FW crash\");\n\t\t\twil->platform_ops.notify(wil->platform_handle,\n\t\t\t\t\t\t WIL_PLATFORM_EVT_FW_CRASH);\n\t\t} else {\n\t\t\twil_fw_error_recovery(wil);\n\t\t}\n\t}\n\tif (isr & ISR_MISC_MBOX_EVT) {\n\t\twil_dbg_irq(wil, \"MBOX event\\n\");\n\t\twmi_recv_cmd(wil);\n\t\tisr &= ~ISR_MISC_MBOX_EVT;\n\t}\n\n\tif (isr)\n\t\twil_dbg_irq(wil, \"un-handled MISC ISR bits 0x%08x\\n\", isr);\n\n\twil->isr_misc = 0;\n\n\twil6210_unmask_irq_misc(wil, false);\n\n\t \n\tif (wil->n_msi == 3 && wil->suspend_resp_rcvd) {\n\t\twil_dbg_irq(wil, \"set suspend_resp_comp to true\\n\");\n\t\twil->suspend_resp_comp = true;\n\t\twake_up_interruptible(&wil->wq);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t wil6210_thread_irq(int irq, void *cookie)\n{\n\tstruct wil6210_priv *wil = cookie;\n\n\twil_dbg_irq(wil, \"Thread IRQ\\n\");\n\t \n\tif (wil->isr_misc)\n\t\twil6210_irq_misc_thread(irq, cookie);\n\n\twil6210_unmask_irq_pseudo(wil);\n\n\tif (wil->suspend_resp_rcvd) {\n\t\twil_dbg_irq(wil, \"set suspend_resp_comp to true\\n\");\n\t\twil->suspend_resp_comp = true;\n\t\twake_up_interruptible(&wil->wq);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int wil6210_debug_irq_mask(struct wil6210_priv *wil, u32 pseudo_cause)\n{\n\tu32 icm_rx, icr_rx, imv_rx;\n\tu32 icm_tx, icr_tx, imv_tx;\n\tu32 icm_misc, icr_misc, imv_misc;\n\n\tif (!test_bit(wil_status_irqen, wil->status)) {\n\t\tif (wil->use_enhanced_dma_hw) {\n\t\t\ticm_rx = wil_ioread32_and_clear(wil->csr +\n\t\t\t\t\tHOSTADDR(RGF_INT_GEN_RX_ICR) +\n\t\t\t\t\toffsetof(struct RGF_ICR, ICM));\n\t\t\ticr_rx = wil_ioread32_and_clear(wil->csr +\n\t\t\t\t\tHOSTADDR(RGF_INT_GEN_RX_ICR) +\n\t\t\t\t\toffsetof(struct RGF_ICR, ICR));\n\t\t\timv_rx = wil_r(wil, RGF_INT_GEN_RX_ICR +\n\t\t\t\t   offsetof(struct RGF_ICR, IMV));\n\t\t\ticm_tx = wil_ioread32_and_clear(wil->csr +\n\t\t\t\t\tHOSTADDR(RGF_INT_GEN_TX_ICR) +\n\t\t\t\t\toffsetof(struct RGF_ICR, ICM));\n\t\t\ticr_tx = wil_ioread32_and_clear(wil->csr +\n\t\t\t\t\tHOSTADDR(RGF_INT_GEN_TX_ICR) +\n\t\t\t\t\toffsetof(struct RGF_ICR, ICR));\n\t\t\timv_tx = wil_r(wil, RGF_INT_GEN_TX_ICR +\n\t\t\t\t\t   offsetof(struct RGF_ICR, IMV));\n\t\t} else {\n\t\t\ticm_rx = wil_ioread32_and_clear(wil->csr +\n\t\t\t\t\tHOSTADDR(RGF_DMA_EP_RX_ICR) +\n\t\t\t\t\toffsetof(struct RGF_ICR, ICM));\n\t\t\ticr_rx = wil_ioread32_and_clear(wil->csr +\n\t\t\t\t\tHOSTADDR(RGF_DMA_EP_RX_ICR) +\n\t\t\t\t\toffsetof(struct RGF_ICR, ICR));\n\t\t\timv_rx = wil_r(wil, RGF_DMA_EP_RX_ICR +\n\t\t\t\t   offsetof(struct RGF_ICR, IMV));\n\t\t\ticm_tx = wil_ioread32_and_clear(wil->csr +\n\t\t\t\t\tHOSTADDR(RGF_DMA_EP_TX_ICR) +\n\t\t\t\t\toffsetof(struct RGF_ICR, ICM));\n\t\t\ticr_tx = wil_ioread32_and_clear(wil->csr +\n\t\t\t\t\tHOSTADDR(RGF_DMA_EP_TX_ICR) +\n\t\t\t\t\toffsetof(struct RGF_ICR, ICR));\n\t\t\timv_tx = wil_r(wil, RGF_DMA_EP_TX_ICR +\n\t\t\t\t\t   offsetof(struct RGF_ICR, IMV));\n\t\t}\n\t\ticm_misc = wil_ioread32_and_clear(wil->csr +\n\t\t\t\tHOSTADDR(RGF_DMA_EP_MISC_ICR) +\n\t\t\t\toffsetof(struct RGF_ICR, ICM));\n\t\ticr_misc = wil_ioread32_and_clear(wil->csr +\n\t\t\t\tHOSTADDR(RGF_DMA_EP_MISC_ICR) +\n\t\t\t\toffsetof(struct RGF_ICR, ICR));\n\t\timv_misc = wil_r(wil, RGF_DMA_EP_MISC_ICR +\n\t\t\t\t     offsetof(struct RGF_ICR, IMV));\n\n\t\t \n\t\tif (icr_misc & BIT_DMA_EP_MISC_ICR_HALP)\n\t\t\treturn 0;\n\n\t\twil_err(wil, \"IRQ when it should be masked: pseudo 0x%08x\\n\"\n\t\t\t\t\"Rx   icm:icr:imv 0x%08x 0x%08x 0x%08x\\n\"\n\t\t\t\t\"Tx   icm:icr:imv 0x%08x 0x%08x 0x%08x\\n\"\n\t\t\t\t\"Misc icm:icr:imv 0x%08x 0x%08x 0x%08x\\n\",\n\t\t\t\tpseudo_cause,\n\t\t\t\ticm_rx, icr_rx, imv_rx,\n\t\t\t\ticm_tx, icr_tx, imv_tx,\n\t\t\t\ticm_misc, icr_misc, imv_misc);\n\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t wil6210_hardirq(int irq, void *cookie)\n{\n\tirqreturn_t rc = IRQ_HANDLED;\n\tstruct wil6210_priv *wil = cookie;\n\tu32 pseudo_cause = wil_r(wil, RGF_DMA_PSEUDO_CAUSE);\n\n\t \n\tif (unlikely((pseudo_cause == 0) || ((pseudo_cause & 0xff) == 0xff)))\n\t\treturn IRQ_NONE;\n\n\t \n\tif (unlikely(wil6210_debug_irq_mask(wil, pseudo_cause)))\n\t\treturn IRQ_NONE;\n\n\ttrace_wil6210_irq_pseudo(pseudo_cause);\n\twil_dbg_irq(wil, \"Pseudo IRQ 0x%08x\\n\", pseudo_cause);\n\n\twil6210_mask_irq_pseudo(wil);\n\n\t \n\tif ((pseudo_cause & BIT_DMA_PSEUDO_CAUSE_RX) &&\n\t    (wil->txrx_ops.irq_rx(irq, cookie) == IRQ_WAKE_THREAD))\n\t\trc = IRQ_WAKE_THREAD;\n\n\tif ((pseudo_cause & BIT_DMA_PSEUDO_CAUSE_TX) &&\n\t    (wil->txrx_ops.irq_tx(irq, cookie) == IRQ_WAKE_THREAD))\n\t\trc = IRQ_WAKE_THREAD;\n\n\tif ((pseudo_cause & BIT_DMA_PSEUDO_CAUSE_MISC) &&\n\t    (wil6210_irq_misc(irq, cookie) == IRQ_WAKE_THREAD))\n\t\trc = IRQ_WAKE_THREAD;\n\n\t \n\tif (rc != IRQ_WAKE_THREAD)\n\t\twil6210_unmask_irq_pseudo(wil);\n\n\treturn rc;\n}\n\nstatic int wil6210_request_3msi(struct wil6210_priv *wil, int irq)\n{\n\tint rc;\n\n\t \n\trc = request_irq(irq, wil->txrx_ops.irq_tx, IRQF_SHARED,\n\t\t\t WIL_NAME \"_tx\", wil);\n\tif (rc)\n\t\treturn rc;\n\n\trc = request_irq(irq + 1, wil->txrx_ops.irq_rx, IRQF_SHARED,\n\t\t\t WIL_NAME \"_rx\", wil);\n\tif (rc)\n\t\tgoto free0;\n\n\trc = request_threaded_irq(irq + 2, wil6210_irq_misc,\n\t\t\t\t  wil6210_irq_misc_thread,\n\t\t\t\t  IRQF_SHARED, WIL_NAME \"_misc\", wil);\n\tif (rc)\n\t\tgoto free1;\n\n\treturn 0;\nfree1:\n\tfree_irq(irq + 1, wil);\nfree0:\n\tfree_irq(irq, wil);\n\n\treturn rc;\n}\n\n \nstatic inline void wil_clear32(void __iomem *addr)\n{\n\tu32 x = readl(addr);\n\n\twritel(x, addr);\n}\n\nvoid wil6210_clear_irq(struct wil6210_priv *wil)\n{\n\twil_clear32(wil->csr + HOSTADDR(RGF_DMA_EP_RX_ICR) +\n\t\t    offsetof(struct RGF_ICR, ICR));\n\twil_clear32(wil->csr + HOSTADDR(RGF_DMA_EP_TX_ICR) +\n\t\t    offsetof(struct RGF_ICR, ICR));\n\twil_clear32(wil->csr + HOSTADDR(RGF_INT_GEN_RX_ICR) +\n\t\t    offsetof(struct RGF_ICR, ICR));\n\twil_clear32(wil->csr + HOSTADDR(RGF_INT_GEN_TX_ICR) +\n\t\t    offsetof(struct RGF_ICR, ICR));\n\twil_clear32(wil->csr + HOSTADDR(RGF_DMA_EP_MISC_ICR) +\n\t\t    offsetof(struct RGF_ICR, ICR));\n\twmb();  \n}\n\nvoid wil6210_set_halp(struct wil6210_priv *wil)\n{\n\twil_dbg_irq(wil, \"set_halp\\n\");\n\n\twil_w(wil, RGF_DMA_EP_MISC_ICR + offsetof(struct RGF_ICR, ICS),\n\t      BIT_DMA_EP_MISC_ICR_HALP);\n}\n\nvoid wil6210_clear_halp(struct wil6210_priv *wil)\n{\n\twil_dbg_irq(wil, \"clear_halp\\n\");\n\n\twil_w(wil, RGF_DMA_EP_MISC_ICR + offsetof(struct RGF_ICR, ICR),\n\t      BIT_DMA_EP_MISC_ICR_HALP);\n\twil6210_unmask_halp(wil);\n}\n\nint wil6210_init_irq(struct wil6210_priv *wil, int irq)\n{\n\tint rc;\n\n\twil_dbg_misc(wil, \"init_irq: %s, n_msi=%d\\n\",\n\t\t     wil->n_msi ? \"MSI\" : \"INTx\", wil->n_msi);\n\n\tif (wil->use_enhanced_dma_hw) {\n\t\twil->txrx_ops.irq_tx = wil6210_irq_tx_edma;\n\t\twil->txrx_ops.irq_rx = wil6210_irq_rx_edma;\n\t} else {\n\t\twil->txrx_ops.irq_tx = wil6210_irq_tx;\n\t\twil->txrx_ops.irq_rx = wil6210_irq_rx;\n\t}\n\n\tif (wil->n_msi == 3)\n\t\trc = wil6210_request_3msi(wil, irq);\n\telse\n\t\trc = request_threaded_irq(irq, wil6210_hardirq,\n\t\t\t\t\t  wil6210_thread_irq,\n\t\t\t\t\t  wil->n_msi ? 0 : IRQF_SHARED,\n\t\t\t\t\t  WIL_NAME, wil);\n\treturn rc;\n}\n\nvoid wil6210_fini_irq(struct wil6210_priv *wil, int irq)\n{\n\twil_dbg_misc(wil, \"fini_irq:\\n\");\n\n\twil_mask_irq(wil);\n\tfree_irq(irq, wil);\n\tif (wil->n_msi == 3) {\n\t\tfree_irq(irq + 1, wil);\n\t\tfree_irq(irq + 2, wil);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}