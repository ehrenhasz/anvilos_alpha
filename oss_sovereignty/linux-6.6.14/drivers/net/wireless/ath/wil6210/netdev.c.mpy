{
  "module_name": "netdev.c",
  "hash_id": "797e9bd195be7322c39dfccba78cbef7d48d5d220e1e5e9b71c6e6b8834cef88",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/wil6210/netdev.c",
  "human_readable_source": "\n \n\n#include <linux/etherdevice.h>\n#include <linux/rtnetlink.h>\n#include \"wil6210.h\"\n#include \"txrx.h\"\n\nbool wil_has_other_active_ifaces(struct wil6210_priv *wil,\n\t\t\t\t struct net_device *ndev, bool up, bool ok)\n{\n\tint i;\n\tstruct wil6210_vif *vif;\n\tstruct net_device *ndev_i;\n\n\tfor (i = 0; i < GET_MAX_VIFS(wil); i++) {\n\t\tvif = wil->vifs[i];\n\t\tif (vif) {\n\t\t\tndev_i = vif_to_ndev(vif);\n\t\t\tif (ndev_i != ndev)\n\t\t\t\tif ((up && (ndev_i->flags & IFF_UP)) ||\n\t\t\t\t    (ok && netif_carrier_ok(ndev_i)))\n\t\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nbool wil_has_active_ifaces(struct wil6210_priv *wil, bool up, bool ok)\n{\n\t \n\treturn wil_has_other_active_ifaces(wil, NULL, up, ok);\n}\n\nstatic int wil_open(struct net_device *ndev)\n{\n\tstruct wil6210_priv *wil = ndev_to_wil(ndev);\n\tint rc = 0;\n\n\twil_dbg_misc(wil, \"open\\n\");\n\n\tif (debug_fw ||\n\t    test_bit(WMI_FW_CAPABILITY_WMI_ONLY, wil->fw_capabilities)) {\n\t\twil_err(wil, \"while in debug_fw or wmi_only mode\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!wil_has_other_active_ifaces(wil, ndev, true, false)) {\n\t\twil_dbg_misc(wil, \"open, first iface\\n\");\n\t\trc = wil_pm_runtime_get(wil);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\n\t\trc = wil_up(wil);\n\t\tif (rc)\n\t\t\twil_pm_runtime_put(wil);\n\t}\n\n\treturn rc;\n}\n\nstatic int wil_stop(struct net_device *ndev)\n{\n\tstruct wil6210_priv *wil = ndev_to_wil(ndev);\n\tint rc = 0;\n\n\twil_dbg_misc(wil, \"stop\\n\");\n\n\tif (!wil_has_other_active_ifaces(wil, ndev, true, false)) {\n\t\twil_dbg_misc(wil, \"stop, last iface\\n\");\n\t\trc = wil_down(wil);\n\t\tif (!rc)\n\t\t\twil_pm_runtime_put(wil);\n\t}\n\n\treturn rc;\n}\n\nstatic const struct net_device_ops wil_netdev_ops = {\n\t.ndo_open\t\t= wil_open,\n\t.ndo_stop\t\t= wil_stop,\n\t.ndo_start_xmit\t\t= wil_start_xmit,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic int wil6210_netdev_poll_rx(struct napi_struct *napi, int budget)\n{\n\tstruct wil6210_priv *wil = container_of(napi, struct wil6210_priv,\n\t\t\t\t\t\tnapi_rx);\n\tint quota = budget;\n\tint done;\n\n\twil_rx_handle(wil, &quota);\n\tdone = budget - quota;\n\n\tif (done < budget) {\n\t\tnapi_complete_done(napi, done);\n\t\twil6210_unmask_irq_rx(wil);\n\t\twil_dbg_txrx(wil, \"NAPI RX complete\\n\");\n\t}\n\n\twil_dbg_txrx(wil, \"NAPI RX poll(%d) done %d\\n\", budget, done);\n\n\treturn done;\n}\n\nstatic int wil6210_netdev_poll_rx_edma(struct napi_struct *napi, int budget)\n{\n\tstruct wil6210_priv *wil = container_of(napi, struct wil6210_priv,\n\t\t\t\t\t\tnapi_rx);\n\tint quota = budget;\n\tint done;\n\n\twil_rx_handle_edma(wil, &quota);\n\tdone = budget - quota;\n\n\tif (done < budget) {\n\t\tnapi_complete_done(napi, done);\n\t\twil6210_unmask_irq_rx_edma(wil);\n\t\twil_dbg_txrx(wil, \"NAPI RX complete\\n\");\n\t}\n\n\twil_dbg_txrx(wil, \"NAPI RX poll(%d) done %d\\n\", budget, done);\n\n\treturn done;\n}\n\nstatic int wil6210_netdev_poll_tx(struct napi_struct *napi, int budget)\n{\n\tstruct wil6210_priv *wil = container_of(napi, struct wil6210_priv,\n\t\t\t\t\t\tnapi_tx);\n\tint tx_done = 0;\n\tuint i;\n\n\t \n\tfor (i = 0; i < WIL6210_MAX_TX_RINGS; i++) {\n\t\tstruct wil_ring *ring = &wil->ring_tx[i];\n\t\tstruct wil_ring_tx_data *txdata = &wil->ring_tx_data[i];\n\t\tstruct wil6210_vif *vif;\n\n\t\tif (!ring->va || !txdata->enabled ||\n\t\t    txdata->mid >= GET_MAX_VIFS(wil))\n\t\t\tcontinue;\n\n\t\tvif = wil->vifs[txdata->mid];\n\t\tif (unlikely(!vif)) {\n\t\t\twil_dbg_txrx(wil, \"Invalid MID %d\\n\", txdata->mid);\n\t\t\tcontinue;\n\t\t}\n\n\t\ttx_done += wil_tx_complete(vif, i);\n\t}\n\n\tif (tx_done < budget) {\n\t\tnapi_complete(napi);\n\t\twil6210_unmask_irq_tx(wil);\n\t\twil_dbg_txrx(wil, \"NAPI TX complete\\n\");\n\t}\n\n\twil_dbg_txrx(wil, \"NAPI TX poll(%d) done %d\\n\", budget, tx_done);\n\n\treturn min(tx_done, budget);\n}\n\nstatic int wil6210_netdev_poll_tx_edma(struct napi_struct *napi, int budget)\n{\n\tstruct wil6210_priv *wil = container_of(napi, struct wil6210_priv,\n\t\t\t\t\t\tnapi_tx);\n\tint tx_done;\n\t \n\tstruct wil_status_ring *sring = &wil->srings[wil->tx_sring_idx];\n\n\tif (!sring->va)\n\t\treturn 0;\n\n\ttx_done = wil_tx_sring_handler(wil, sring);\n\n\tif (tx_done < budget) {\n\t\tnapi_complete(napi);\n\t\twil6210_unmask_irq_tx_edma(wil);\n\t\twil_dbg_txrx(wil, \"NAPI TX complete\\n\");\n\t}\n\n\twil_dbg_txrx(wil, \"NAPI TX poll(%d) done %d\\n\", budget, tx_done);\n\n\treturn min(tx_done, budget);\n}\n\nstatic void wil_dev_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\tdev->max_mtu = mtu_max;\n\tdev->tx_queue_len = WIL_TX_Q_LEN_DEFAULT;\n}\n\nstatic void wil_vif_deinit(struct wil6210_vif *vif)\n{\n\tdel_timer_sync(&vif->scan_timer);\n\tdel_timer_sync(&vif->p2p.discovery_timer);\n\tcancel_work_sync(&vif->disconnect_worker);\n\tcancel_work_sync(&vif->p2p.discovery_expired_work);\n\tcancel_work_sync(&vif->p2p.delayed_listen_work);\n\twil_probe_client_flush(vif);\n\tcancel_work_sync(&vif->probe_client_worker);\n\tcancel_work_sync(&vif->enable_tx_key_worker);\n}\n\nvoid wil_vif_free(struct wil6210_vif *vif)\n{\n\tstruct net_device *ndev = vif_to_ndev(vif);\n\n\twil_vif_deinit(vif);\n\tfree_netdev(ndev);\n}\n\nstatic void wil_ndev_destructor(struct net_device *ndev)\n{\n\tstruct wil6210_vif *vif = ndev_to_vif(ndev);\n\n\twil_vif_deinit(vif);\n}\n\nstatic void wil_connect_timer_fn(struct timer_list *t)\n{\n\tstruct wil6210_vif *vif = from_timer(vif, t, connect_timer);\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tbool q;\n\n\twil_err(wil, \"Connect timeout detected, disconnect station\\n\");\n\n\t \n\tq = queue_work(wil->wmi_wq, &vif->disconnect_worker);\n\twil_dbg_wmi(wil, \"queue_work of disconnect_worker -> %d\\n\", q);\n}\n\nstatic void wil_scan_timer_fn(struct timer_list *t)\n{\n\tstruct wil6210_vif *vif = from_timer(vif, t, scan_timer);\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\n\tclear_bit(wil_status_fwready, wil->status);\n\twil_err(wil, \"Scan timeout detected, start fw error recovery\\n\");\n\twil_fw_error_recovery(wil);\n}\n\nstatic void wil_p2p_discovery_timer_fn(struct timer_list *t)\n{\n\tstruct wil6210_vif *vif = from_timer(vif, t, p2p.discovery_timer);\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\n\twil_dbg_misc(wil, \"p2p_discovery_timer_fn\\n\");\n\n\tschedule_work(&vif->p2p.discovery_expired_work);\n}\n\nstatic void wil_vif_init(struct wil6210_vif *vif)\n{\n\tvif->bcast_ring = -1;\n\n\tmutex_init(&vif->probe_client_mutex);\n\n\ttimer_setup(&vif->connect_timer, wil_connect_timer_fn, 0);\n\ttimer_setup(&vif->scan_timer, wil_scan_timer_fn, 0);\n\ttimer_setup(&vif->p2p.discovery_timer, wil_p2p_discovery_timer_fn, 0);\n\n\tINIT_WORK(&vif->probe_client_worker, wil_probe_client_worker);\n\tINIT_WORK(&vif->disconnect_worker, wil_disconnect_worker);\n\tINIT_WORK(&vif->p2p.discovery_expired_work, wil_p2p_listen_expired);\n\tINIT_WORK(&vif->p2p.delayed_listen_work, wil_p2p_delayed_listen_work);\n\tINIT_WORK(&vif->enable_tx_key_worker, wil_enable_tx_key_worker);\n\n\tINIT_LIST_HEAD(&vif->probe_client_pending);\n\n\tvif->net_queue_stopped = 1;\n}\n\nstatic u8 wil_vif_find_free_mid(struct wil6210_priv *wil)\n{\n\tu8 i;\n\n\tfor (i = 0; i < GET_MAX_VIFS(wil); i++) {\n\t\tif (!wil->vifs[i])\n\t\t\treturn i;\n\t}\n\n\treturn U8_MAX;\n}\n\nstruct wil6210_vif *\nwil_vif_alloc(struct wil6210_priv *wil, const char *name,\n\t      unsigned char name_assign_type, enum nl80211_iftype iftype)\n{\n\tstruct net_device *ndev;\n\tstruct wireless_dev *wdev;\n\tstruct wil6210_vif *vif;\n\tu8 mid;\n\n\tmid = wil_vif_find_free_mid(wil);\n\tif (mid == U8_MAX) {\n\t\twil_err(wil, \"no available virtual interface\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tndev = alloc_netdev(sizeof(*vif), name, name_assign_type,\n\t\t\t    wil_dev_setup);\n\tif (!ndev) {\n\t\tdev_err(wil_to_dev(wil), \"alloc_netdev failed\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tif (mid == 0) {\n\t\twil->main_ndev = ndev;\n\t} else {\n\t\tndev->priv_destructor = wil_ndev_destructor;\n\t\tndev->needs_free_netdev = true;\n\t}\n\n\tvif = ndev_to_vif(ndev);\n\tvif->ndev = ndev;\n\tvif->wil = wil;\n\tvif->mid = mid;\n\twil_vif_init(vif);\n\n\twdev = &vif->wdev;\n\twdev->wiphy = wil->wiphy;\n\twdev->iftype = iftype;\n\n\tndev->netdev_ops = &wil_netdev_ops;\n\twil_set_ethtoolops(ndev);\n\tndev->ieee80211_ptr = wdev;\n\tndev->hw_features = NETIF_F_HW_CSUM | NETIF_F_RXCSUM |\n\t\t\t    NETIF_F_SG | NETIF_F_GRO |\n\t\t\t    NETIF_F_TSO | NETIF_F_TSO6;\n\n\tndev->features |= ndev->hw_features;\n\tSET_NETDEV_DEV(ndev, wiphy_dev(wdev->wiphy));\n\twdev->netdev = ndev;\n\treturn vif;\n}\n\nvoid *wil_if_alloc(struct device *dev)\n{\n\tstruct wil6210_priv *wil;\n\tstruct wil6210_vif *vif;\n\tint rc = 0;\n\n\twil = wil_cfg80211_init(dev);\n\tif (IS_ERR(wil)) {\n\t\tdev_err(dev, \"wil_cfg80211_init failed\\n\");\n\t\treturn wil;\n\t}\n\n\trc = wil_priv_init(wil);\n\tif (rc) {\n\t\tdev_err(dev, \"wil_priv_init failed\\n\");\n\t\tgoto out_cfg;\n\t}\n\n\twil_dbg_misc(wil, \"if_alloc\\n\");\n\n\tvif = wil_vif_alloc(wil, \"wlan%d\", NET_NAME_UNKNOWN,\n\t\t\t    NL80211_IFTYPE_STATION);\n\tif (IS_ERR(vif)) {\n\t\tdev_err(dev, \"wil_vif_alloc failed\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto out_priv;\n\t}\n\n\twil->radio_wdev = vif_to_wdev(vif);\n\n\treturn wil;\n\nout_priv:\n\twil_priv_deinit(wil);\n\nout_cfg:\n\twil_cfg80211_deinit(wil);\n\n\treturn ERR_PTR(rc);\n}\n\nvoid wil_if_free(struct wil6210_priv *wil)\n{\n\tstruct net_device *ndev = wil->main_ndev;\n\n\twil_dbg_misc(wil, \"if_free\\n\");\n\n\tif (!ndev)\n\t\treturn;\n\n\twil_priv_deinit(wil);\n\n\twil->main_ndev = NULL;\n\twil_ndev_destructor(ndev);\n\tfree_netdev(ndev);\n\n\twil_cfg80211_deinit(wil);\n}\n\nint wil_vif_add(struct wil6210_priv *wil, struct wil6210_vif *vif)\n{\n\tstruct net_device *ndev = vif_to_ndev(vif);\n\tstruct wireless_dev *wdev = vif_to_wdev(vif);\n\tbool any_active = wil_has_active_ifaces(wil, true, false);\n\tint rc;\n\n\tASSERT_RTNL();\n\n\tif (wil->vifs[vif->mid]) {\n\t\tdev_err(&ndev->dev, \"VIF with mid %d already in use\\n\",\n\t\t\tvif->mid);\n\t\treturn -EEXIST;\n\t}\n\tif (any_active && vif->mid != 0) {\n\t\trc = wmi_port_allocate(wil, vif->mid, ndev->dev_addr,\n\t\t\t\t       wdev->iftype);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\trc = cfg80211_register_netdevice(ndev);\n\tif (rc < 0) {\n\t\tdev_err(&ndev->dev, \"Failed to register netdev: %d\\n\", rc);\n\t\tif (any_active && vif->mid != 0)\n\t\t\twmi_port_delete(wil, vif->mid);\n\t\treturn rc;\n\t}\n\n\twil->vifs[vif->mid] = vif;\n\treturn 0;\n}\n\nint wil_if_add(struct wil6210_priv *wil)\n{\n\tstruct wiphy *wiphy = wil->wiphy;\n\tstruct net_device *ndev = wil->main_ndev;\n\tstruct wil6210_vif *vif = ndev_to_vif(ndev);\n\tint rc;\n\n\twil_dbg_misc(wil, \"entered\");\n\n\tstrscpy(wiphy->fw_version, wil->fw_version, sizeof(wiphy->fw_version));\n\n\trc = wiphy_register(wiphy);\n\tif (rc < 0) {\n\t\twil_err(wil, \"failed to register wiphy, err %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tinit_dummy_netdev(&wil->napi_ndev);\n\tif (wil->use_enhanced_dma_hw) {\n\t\tnetif_napi_add(&wil->napi_ndev, &wil->napi_rx,\n\t\t\t       wil6210_netdev_poll_rx_edma);\n\t\tnetif_napi_add_tx(&wil->napi_ndev,\n\t\t\t\t  &wil->napi_tx, wil6210_netdev_poll_tx_edma);\n\t} else {\n\t\tnetif_napi_add(&wil->napi_ndev, &wil->napi_rx,\n\t\t\t       wil6210_netdev_poll_rx);\n\t\tnetif_napi_add_tx(&wil->napi_ndev,\n\t\t\t\t  &wil->napi_tx, wil6210_netdev_poll_tx);\n\t}\n\n\twil_update_net_queues_bh(wil, vif, NULL, true);\n\n\trtnl_lock();\n\twiphy_lock(wiphy);\n\trc = wil_vif_add(wil, vif);\n\twiphy_unlock(wiphy);\n\trtnl_unlock();\n\tif (rc < 0)\n\t\tgoto out_wiphy;\n\n\treturn 0;\n\nout_wiphy:\n\twiphy_unregister(wiphy);\n\treturn rc;\n}\n\nvoid wil_vif_remove(struct wil6210_priv *wil, u8 mid)\n{\n\tstruct wil6210_vif *vif;\n\tstruct net_device *ndev;\n\tbool any_active = wil_has_active_ifaces(wil, true, false);\n\n\tASSERT_RTNL();\n\tif (mid >= GET_MAX_VIFS(wil)) {\n\t\twil_err(wil, \"invalid MID: %d\\n\", mid);\n\t\treturn;\n\t}\n\n\tvif = wil->vifs[mid];\n\tif (!vif) {\n\t\twil_err(wil, \"MID %d not registered\\n\", mid);\n\t\treturn;\n\t}\n\n\tmutex_lock(&wil->mutex);\n\twil6210_disconnect(vif, NULL, WLAN_REASON_DEAUTH_LEAVING);\n\tmutex_unlock(&wil->mutex);\n\n\tndev = vif_to_ndev(vif);\n\t \n\tcfg80211_unregister_netdevice(ndev);\n\n\tif (any_active && vif->mid != 0)\n\t\twmi_port_delete(wil, vif->mid);\n\n\t \n\tmutex_lock(&wil->vif_mutex);\n\twil->vifs[mid] = NULL;\n\t \n\twmb();\n\tif (test_bit(wil_status_napi_en, wil->status)) {\n\t\tnapi_synchronize(&wil->napi_rx);\n\t\tnapi_synchronize(&wil->napi_tx);\n\t}\n\tmutex_unlock(&wil->vif_mutex);\n\n\tflush_work(&wil->wmi_event_worker);\n\tdel_timer_sync(&vif->connect_timer);\n\tcancel_work_sync(&vif->disconnect_worker);\n\twil_probe_client_flush(vif);\n\tcancel_work_sync(&vif->probe_client_worker);\n\tcancel_work_sync(&vif->enable_tx_key_worker);\n\t \n}\n\nvoid wil_if_remove(struct wil6210_priv *wil)\n{\n\tstruct net_device *ndev = wil->main_ndev;\n\tstruct wireless_dev *wdev = ndev->ieee80211_ptr;\n\tstruct wiphy *wiphy = wdev->wiphy;\n\n\twil_dbg_misc(wil, \"if_remove\\n\");\n\n\trtnl_lock();\n\twiphy_lock(wiphy);\n\twil_vif_remove(wil, 0);\n\twiphy_unlock(wiphy);\n\trtnl_unlock();\n\n\tnetif_napi_del(&wil->napi_tx);\n\tnetif_napi_del(&wil->napi_rx);\n\n\twiphy_unregister(wiphy);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}