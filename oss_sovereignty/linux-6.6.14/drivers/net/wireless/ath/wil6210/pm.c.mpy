{
  "module_name": "pm.c",
  "hash_id": "80392b7808997e3d79d92cce36c67f1fefbbb38895e23081f90207120ce6472d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/wil6210/pm.c",
  "human_readable_source": "\n \n\n#include \"wil6210.h\"\n#include <linux/jiffies.h>\n#include <linux/pm_runtime.h>\n\n#define WIL6210_AUTOSUSPEND_DELAY_MS (1000)\n\nstatic void wil_pm_wake_connected_net_queues(struct wil6210_priv *wil)\n{\n\tint i;\n\n\tmutex_lock(&wil->vif_mutex);\n\tfor (i = 0; i < GET_MAX_VIFS(wil); i++) {\n\t\tstruct wil6210_vif *vif = wil->vifs[i];\n\n\t\tif (vif && test_bit(wil_vif_fwconnected, vif->status))\n\t\t\twil_update_net_queues_bh(wil, vif, NULL, false);\n\t}\n\tmutex_unlock(&wil->vif_mutex);\n}\n\nstatic void wil_pm_stop_all_net_queues(struct wil6210_priv *wil)\n{\n\tint i;\n\n\tmutex_lock(&wil->vif_mutex);\n\tfor (i = 0; i < GET_MAX_VIFS(wil); i++) {\n\t\tstruct wil6210_vif *vif = wil->vifs[i];\n\n\t\tif (vif)\n\t\t\twil_update_net_queues_bh(wil, vif, NULL, true);\n\t}\n\tmutex_unlock(&wil->vif_mutex);\n}\n\nstatic bool\nwil_can_suspend_vif(struct wil6210_priv *wil, struct wil6210_vif *vif,\n\t\t    bool is_runtime)\n{\n\tstruct wireless_dev *wdev = vif_to_wdev(vif);\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_MONITOR:\n\t\twil_dbg_pm(wil, \"Sniffer\\n\");\n\t\treturn false;\n\n\t \n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tif (test_bit(wil_vif_fwconnecting, vif->status)) {\n\t\t\twil_dbg_pm(wil, \"Delay suspend when connecting\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tif (is_runtime) {\n\t\t\twil_dbg_pm(wil, \"STA-like interface\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\t \n\tdefault:\n\t\twil_dbg_pm(wil, \"AP-like interface\\n\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nint wil_can_suspend(struct wil6210_priv *wil, bool is_runtime)\n{\n\tint rc = 0, i;\n\tbool wmi_only = test_bit(WMI_FW_CAPABILITY_WMI_ONLY,\n\t\t\t\t wil->fw_capabilities);\n\tbool active_ifaces;\n\n\twil_dbg_pm(wil, \"can_suspend: %s\\n\", is_runtime ? \"runtime\" : \"system\");\n\n\tif (wmi_only || debug_fw) {\n\t\twil_dbg_pm(wil, \"Deny any suspend - %s mode\\n\",\n\t\t\t   wmi_only ? \"wmi_only\" : \"debug_fw\");\n\t\trc = -EBUSY;\n\t\tgoto out;\n\t}\n\tif (is_runtime && !wil->platform_ops.suspend) {\n\t\trc = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&wil->vif_mutex);\n\tactive_ifaces = wil_has_active_ifaces(wil, true, false);\n\tmutex_unlock(&wil->vif_mutex);\n\n\tif (!active_ifaces) {\n\t\t \n\t\twil_dbg_pm(wil, \"Interface is down\\n\");\n\t\tgoto out;\n\t}\n\tif (test_bit(wil_status_resetting, wil->status)) {\n\t\twil_dbg_pm(wil, \"Delay suspend when resetting\\n\");\n\t\trc = -EBUSY;\n\t\tgoto out;\n\t}\n\tif (wil->recovery_state != fw_recovery_idle) {\n\t\twil_dbg_pm(wil, \"Delay suspend during recovery\\n\");\n\t\trc = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t \n\tmutex_lock(&wil->vif_mutex);\n\tfor (i = 0; i < GET_MAX_VIFS(wil); i++) {\n\t\tstruct wil6210_vif *vif = wil->vifs[i];\n\n\t\tif (!vif)\n\t\t\tcontinue;\n\t\tif (!wil_can_suspend_vif(wil, vif, is_runtime)) {\n\t\t\trc = -EBUSY;\n\t\t\tmutex_unlock(&wil->vif_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmutex_unlock(&wil->vif_mutex);\n\nout:\n\twil_dbg_pm(wil, \"can_suspend: %s => %s (%d)\\n\",\n\t\t   is_runtime ? \"runtime\" : \"system\", rc ? \"No\" : \"Yes\", rc);\n\n\tif (rc)\n\t\twil->suspend_stats.rejected_by_host++;\n\n\treturn rc;\n}\n\nstatic int wil_resume_keep_radio_on(struct wil6210_priv *wil)\n{\n\tint rc = 0;\n\n\t \n\tset_bit(wil_status_resuming, wil->status);\n\tclear_bit(wil_status_suspended, wil->status);\n\twil_c(wil, RGF_USER_CLKS_CTL_0, BIT_USER_CLKS_RST_PWGD);\n\twil_unmask_irq(wil);\n\n\twil6210_bus_request(wil, wil->bus_request_kbps_pre_suspend);\n\n\t \n\trc = wmi_resume(wil);\n\tif (rc) {\n\t\twil_err(wil, \"device failed to resume (%d)\\n\", rc);\n\t\tif (no_fw_recovery)\n\t\t\tgoto out;\n\t\trc = wil_down(wil);\n\t\tif (rc) {\n\t\t\twil_err(wil, \"wil_down failed (%d)\\n\", rc);\n\t\t\tgoto out;\n\t\t}\n\t\trc = wil_up(wil);\n\t\tif (rc) {\n\t\t\twil_err(wil, \"wil_up failed (%d)\\n\", rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\twil_pm_wake_connected_net_queues(wil);\n\nout:\n\tif (rc)\n\t\tset_bit(wil_status_suspended, wil->status);\n\treturn rc;\n}\n\nstatic int wil_suspend_keep_radio_on(struct wil6210_priv *wil)\n{\n\tint rc = 0;\n\tunsigned long data_comp_to;\n\n\twil_dbg_pm(wil, \"suspend keep radio on\\n\");\n\n\t \n\trc = down_write_trylock(&wil->mem_lock);\n\tif (!rc) {\n\t\twil_err(wil,\n\t\t\t\"device is busy. down_write_trylock failed, returned (0x%x)\\n\",\n\t\t\trc);\n\t\twil->suspend_stats.rejected_by_host++;\n\t\treturn -EBUSY;\n\t}\n\n\tset_bit(wil_status_suspending, wil->status);\n\tup_write(&wil->mem_lock);\n\n\twil_pm_stop_all_net_queues(wil);\n\n\tif (!wil_is_tx_idle(wil)) {\n\t\twil_dbg_pm(wil, \"Pending TX data, reject suspend\\n\");\n\t\twil->suspend_stats.rejected_by_host++;\n\t\tgoto reject_suspend;\n\t}\n\n\tif (!wil->txrx_ops.is_rx_idle(wil)) {\n\t\twil_dbg_pm(wil, \"Pending RX data, reject suspend\\n\");\n\t\twil->suspend_stats.rejected_by_host++;\n\t\tgoto reject_suspend;\n\t}\n\n\tif (!wil_is_wmi_idle(wil)) {\n\t\twil_dbg_pm(wil, \"Pending WMI events, reject suspend\\n\");\n\t\twil->suspend_stats.rejected_by_host++;\n\t\tgoto reject_suspend;\n\t}\n\n\t \n\trc = wmi_suspend(wil);\n\tif (rc) {\n\t\twil_dbg_pm(wil, \"wmi_suspend failed, reject suspend (%d)\\n\",\n\t\t\t   rc);\n\t\tgoto reject_suspend;\n\t}\n\n\t \n\tdata_comp_to = jiffies + msecs_to_jiffies(WIL_DATA_COMPLETION_TO_MS);\n\tif (test_bit(wil_status_napi_en, wil->status)) {\n\t\twhile (!wil->txrx_ops.is_rx_idle(wil)) {\n\t\t\tif (time_after(jiffies, data_comp_to)) {\n\t\t\t\tif (wil->txrx_ops.is_rx_idle(wil))\n\t\t\t\t\tbreak;\n\t\t\t\twil_err(wil,\n\t\t\t\t\t\"TO waiting for idle RX, suspend failed\\n\");\n\t\t\t\twil->suspend_stats.r_on.failed_suspends++;\n\t\t\t\tgoto resume_after_fail;\n\t\t\t}\n\t\t\twil_dbg_ratelimited(wil, \"rx vring is not empty -> NAPI\\n\");\n\t\t\tnapi_synchronize(&wil->napi_rx);\n\t\t\tmsleep(20);\n\t\t}\n\t}\n\n\t \n\tif (!wil_is_wmi_idle(wil)) {\n\t\twil_err(wil, \"suspend failed due to pending WMI events\\n\");\n\t\twil->suspend_stats.r_on.failed_suspends++;\n\t\tgoto resume_after_fail;\n\t}\n\n\twil_mask_irq(wil);\n\n\t \n\twil_s(wil, RGF_USER_CLKS_CTL_0, BIT_USER_CLKS_RST_PWGD);\n\n\tif (wil->platform_ops.suspend) {\n\t\trc = wil->platform_ops.suspend(wil->platform_handle, true);\n\t\tif (rc) {\n\t\t\twil_err(wil, \"platform device failed to suspend (%d)\\n\",\n\t\t\t\trc);\n\t\t\twil->suspend_stats.r_on.failed_suspends++;\n\t\t\twil_c(wil, RGF_USER_CLKS_CTL_0, BIT_USER_CLKS_RST_PWGD);\n\t\t\twil_unmask_irq(wil);\n\t\t\tgoto resume_after_fail;\n\t\t}\n\t}\n\n\t \n\twil->bus_request_kbps_pre_suspend = wil->bus_request_kbps;\n\twil6210_bus_request(wil, 0);\n\n\tset_bit(wil_status_suspended, wil->status);\n\tclear_bit(wil_status_suspending, wil->status);\n\n\treturn rc;\n\nresume_after_fail:\n\tset_bit(wil_status_resuming, wil->status);\n\tclear_bit(wil_status_suspending, wil->status);\n\trc = wmi_resume(wil);\n\t \n\tif (!rc) {\n\t\trc = -EBUSY;\n\t\twil_pm_wake_connected_net_queues(wil);\n\t}\n\treturn rc;\n\nreject_suspend:\n\tclear_bit(wil_status_suspending, wil->status);\n\twil_pm_wake_connected_net_queues(wil);\n\treturn -EBUSY;\n}\n\nstatic int wil_suspend_radio_off(struct wil6210_priv *wil)\n{\n\tint rc = 0;\n\tbool active_ifaces;\n\n\twil_dbg_pm(wil, \"suspend radio off\\n\");\n\n\trc = down_write_trylock(&wil->mem_lock);\n\tif (!rc) {\n\t\twil_err(wil,\n\t\t\t\"device is busy. down_write_trylock failed, returned (0x%x)\\n\",\n\t\t\trc);\n\t\twil->suspend_stats.rejected_by_host++;\n\t\treturn -EBUSY;\n\t}\n\n\tset_bit(wil_status_suspending, wil->status);\n\tup_write(&wil->mem_lock);\n\n\t \n\tmutex_lock(&wil->vif_mutex);\n\tactive_ifaces = wil_has_active_ifaces(wil, true, false);\n\tmutex_unlock(&wil->vif_mutex);\n\n\tif (active_ifaces) {\n\t\trc = wil_down(wil);\n\t\tif (rc) {\n\t\t\twil_err(wil, \"wil_down : %d\\n\", rc);\n\t\t\twil->suspend_stats.r_off.failed_suspends++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\twil_dbg_pm(wil, \"Disabling PCIe IRQ before suspending\\n\");\n\twil_disable_irq(wil);\n\n\tif (wil->platform_ops.suspend) {\n\t\trc = wil->platform_ops.suspend(wil->platform_handle, false);\n\t\tif (rc) {\n\t\t\twil_enable_irq(wil);\n\t\t\twil->suspend_stats.r_off.failed_suspends++;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tset_bit(wil_status_suspended, wil->status);\n\nout:\n\tclear_bit(wil_status_suspending, wil->status);\n\twil_dbg_pm(wil, \"suspend radio off: %d\\n\", rc);\n\n\treturn rc;\n}\n\nstatic int wil_resume_radio_off(struct wil6210_priv *wil)\n{\n\tint rc = 0;\n\tbool active_ifaces;\n\n\twil_dbg_pm(wil, \"Enabling PCIe IRQ\\n\");\n\twil_enable_irq(wil);\n\t \n\tmutex_lock(&wil->vif_mutex);\n\tactive_ifaces = wil_has_active_ifaces(wil, true, false);\n\tmutex_unlock(&wil->vif_mutex);\n\tif (active_ifaces)\n\t\trc = wil_up(wil);\n\telse\n\t\tclear_bit(wil_status_suspended, wil->status);\n\n\treturn rc;\n}\n\nint wil_suspend(struct wil6210_priv *wil, bool is_runtime, bool keep_radio_on)\n{\n\tint rc = 0;\n\n\twil_dbg_pm(wil, \"suspend: %s\\n\", is_runtime ? \"runtime\" : \"system\");\n\n\tif (test_bit(wil_status_suspended, wil->status)) {\n\t\twil_dbg_pm(wil, \"trying to suspend while suspended\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!keep_radio_on)\n\t\trc = wil_suspend_radio_off(wil);\n\telse\n\t\trc = wil_suspend_keep_radio_on(wil);\n\n\twil_dbg_pm(wil, \"suspend: %s => %d\\n\",\n\t\t   is_runtime ? \"runtime\" : \"system\", rc);\n\n\treturn rc;\n}\n\nint wil_resume(struct wil6210_priv *wil, bool is_runtime, bool keep_radio_on)\n{\n\tint rc = 0;\n\n\twil_dbg_pm(wil, \"resume: %s\\n\", is_runtime ? \"runtime\" : \"system\");\n\n\tif (wil->platform_ops.resume) {\n\t\trc = wil->platform_ops.resume(wil->platform_handle,\n\t\t\t\t\t      keep_radio_on);\n\t\tif (rc) {\n\t\t\twil_err(wil, \"platform_ops.resume : %d\\n\", rc);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (keep_radio_on)\n\t\trc = wil_resume_keep_radio_on(wil);\n\telse\n\t\trc = wil_resume_radio_off(wil);\n\nout:\n\twil_dbg_pm(wil, \"resume: %s => %d\\n\", is_runtime ? \"runtime\" : \"system\",\n\t\t   rc);\n\treturn rc;\n}\n\nvoid wil_pm_runtime_allow(struct wil6210_priv *wil)\n{\n\tstruct device *dev = wil_to_dev(wil);\n\n\tpm_runtime_put_noidle(dev);\n\tpm_runtime_set_autosuspend_delay(dev, WIL6210_AUTOSUSPEND_DELAY_MS);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_allow(dev);\n}\n\nvoid wil_pm_runtime_forbid(struct wil6210_priv *wil)\n{\n\tstruct device *dev = wil_to_dev(wil);\n\n\tpm_runtime_forbid(dev);\n\tpm_runtime_get_noresume(dev);\n}\n\nint wil_pm_runtime_get(struct wil6210_priv *wil)\n{\n\tint rc;\n\tstruct device *dev = wil_to_dev(wil);\n\n\trc = pm_runtime_resume_and_get(dev);\n\tif (rc < 0) {\n\t\twil_err(wil, \"pm_runtime_resume_and_get() failed, rc = %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nvoid wil_pm_runtime_put(struct wil6210_priv *wil)\n{\n\tstruct device *dev = wil_to_dev(wil);\n\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}