{
  "module_name": "fw_inc.c",
  "hash_id": "a84e8af325eeea6da6d480c5f7e19dc7ee628480dcecf19ac70c39dd29795af7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/wil6210/fw_inc.c",
  "human_readable_source": "\n \n\n \n\n#define wil_err_fw(wil, fmt, arg...) wil_err(wil, \"ERR[ FW ]\" fmt, ##arg)\n#define wil_dbg_fw(wil, fmt, arg...) wil_dbg(wil, \"DBG[ FW ]\" fmt, ##arg)\n#define wil_hex_dump_fw(prefix_str, prefix_type, rowsize,\t\t\\\n\t\t\tgroupsize, buf, len, ascii)\t\t\t\\\n\t\t\tprint_hex_dump_debug(\"DBG[ FW ]\" prefix_str,\t\\\n\t\t\t\t\t     prefix_type, rowsize,\t\\\n\t\t\t\t\t     groupsize, buf, len, ascii)\n\nstatic bool wil_fw_addr_check(struct wil6210_priv *wil,\n\t\t\t      void __iomem **ioaddr, __le32 val,\n\t\t\t      u32 size, const char *msg)\n{\n\t*ioaddr = wmi_buffer_block(wil, val, size);\n\tif (!(*ioaddr)) {\n\t\twil_err_fw(wil, \"bad %s: 0x%08x\\n\", msg, le32_to_cpu(val));\n\t\treturn false;\n\t}\n\treturn true;\n}\n\n \nstatic int wil_fw_verify(struct wil6210_priv *wil, const u8 *data, size_t size)\n{\n\tconst struct wil_fw_record_head *hdr = (const void *)data;\n\tstruct wil_fw_record_file_header fh;\n\tconst struct wil_fw_record_file_header *fh_;\n\tu32 crc;\n\tu32 dlen;\n\n\tif (size % 4) {\n\t\twil_err_fw(wil, \"image size not aligned: %zu\\n\", size);\n\t\treturn -EINVAL;\n\t}\n\t \n\tif (size < sizeof(*hdr) + sizeof(fh)) {\n\t\twil_err_fw(wil, \"file too short: %zu bytes\\n\", size);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (le16_to_cpu(hdr->type) != wil_fw_type_file_header) {\n\t\twil_err_fw(wil, \"no file header\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfh_ = (struct wil_fw_record_file_header *)&hdr[1];\n\tdlen = le32_to_cpu(fh_->data_len);\n\tif (dlen % 4) {\n\t\twil_err_fw(wil, \"data length not aligned: %lu\\n\", (ulong)dlen);\n\t\treturn -EINVAL;\n\t}\n\tif (size < dlen) {\n\t\twil_err_fw(wil, \"file truncated at %zu/%lu\\n\",\n\t\t\t   size, (ulong)dlen);\n\t\treturn -EINVAL;\n\t}\n\tif (dlen < sizeof(*hdr) + sizeof(fh)) {\n\t\twil_err_fw(wil, \"data length too short: %lu\\n\", (ulong)dlen);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (le32_to_cpu(fh_->signature) != WIL_FW_SIGNATURE) {\n\t\twil_err_fw(wil, \"bad header signature: 0x%08x\\n\",\n\t\t\t   le32_to_cpu(fh_->signature));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (le32_to_cpu(fh_->version) > WIL_FW_FMT_VERSION) {\n\t\twil_err_fw(wil, \"unsupported header version: %d\\n\",\n\t\t\t   le32_to_cpu(fh_->version));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfh = *fh_;\n\tfh.crc = 0;\n\n\tcrc = crc32_le(~0, (unsigned char const *)hdr, sizeof(*hdr));\n\tcrc = crc32_le(crc, (unsigned char const *)&fh, sizeof(fh));\n\tcrc = crc32_le(crc, (unsigned char const *)&fh_[1],\n\t\t       dlen - sizeof(*hdr) - sizeof(fh));\n\tcrc = ~crc;\n\n\tif (crc != le32_to_cpu(fh_->crc)) {\n\t\twil_err_fw(wil, \"checksum mismatch:\"\n\t\t\t   \" calculated for %lu bytes 0x%08x != 0x%08x\\n\",\n\t\t\t   (ulong)dlen, crc, le32_to_cpu(fh_->crc));\n\t\treturn -EINVAL;\n\t}\n\n\treturn (int)dlen;\n}\n\nstatic int fw_ignore_section(struct wil6210_priv *wil, const void *data,\n\t\t\t     size_t size)\n{\n\treturn 0;\n}\n\nstatic int\nfw_handle_capabilities(struct wil6210_priv *wil, const void *data,\n\t\t       size_t size)\n{\n\tconst struct wil_fw_record_capabilities *rec = data;\n\tsize_t capa_size;\n\n\tif (size < sizeof(*rec)) {\n\t\twil_err_fw(wil, \"capabilities record too short: %zu\\n\", size);\n\t\t \n\t\treturn 0;\n\t}\n\n\tcapa_size = size - offsetof(struct wil_fw_record_capabilities,\n\t\t\t\t    capabilities);\n\tbitmap_zero(wil->fw_capabilities, WMI_FW_CAPABILITY_MAX);\n\tmemcpy(wil->fw_capabilities, rec->capabilities,\n\t       min_t(size_t, sizeof(wil->fw_capabilities), capa_size));\n\twil_hex_dump_fw(\"CAPA\", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\trec->capabilities, capa_size, false);\n\treturn 0;\n}\n\nstatic int\nfw_handle_brd_file(struct wil6210_priv *wil, const void *data,\n\t\t   size_t size)\n{\n\tconst struct wil_fw_record_brd_file *rec = data;\n\tu32 max_num_ent, i, ent_size;\n\n\tif (size <= offsetof(struct wil_fw_record_brd_file, brd_info)) {\n\t\twil_err(wil, \"board record too short, size %zu\\n\", size);\n\t\treturn -EINVAL;\n\t}\n\n\tent_size = size - offsetof(struct wil_fw_record_brd_file, brd_info);\n\tmax_num_ent = ent_size / sizeof(struct brd_info);\n\n\tif (!max_num_ent) {\n\t\twil_err(wil, \"brd info entries are missing\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\twil->brd_info = kcalloc(max_num_ent, sizeof(struct wil_brd_info),\n\t\t\t\tGFP_KERNEL);\n\tif (!wil->brd_info)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < max_num_ent; i++) {\n\t\twil->brd_info[i].file_addr =\n\t\t\tle32_to_cpu(rec->brd_info[i].base_addr);\n\t\twil->brd_info[i].file_max_size =\n\t\t\tle32_to_cpu(rec->brd_info[i].max_size_bytes);\n\n\t\tif (!wil->brd_info[i].file_addr)\n\t\t\tbreak;\n\n\t\twil_dbg_fw(wil,\n\t\t\t   \"brd info %d: file_addr 0x%x, file_max_size %d\\n\",\n\t\t\t   i, wil->brd_info[i].file_addr,\n\t\t\t   wil->brd_info[i].file_max_size);\n\t}\n\n\twil->num_of_brd_entries = i;\n\tif (wil->num_of_brd_entries == 0) {\n\t\tkfree(wil->brd_info);\n\t\twil->brd_info = NULL;\n\t\twil_dbg_fw(wil,\n\t\t\t   \"no valid brd info entries, using brd file addr\\n\");\n\n\t} else {\n\t\twil_dbg_fw(wil, \"num of brd info entries %d\\n\",\n\t\t\t   wil->num_of_brd_entries);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nfw_handle_concurrency(struct wil6210_priv *wil, const void *data,\n\t\t      size_t size)\n{\n\tconst struct wil_fw_record_concurrency *rec = data;\n\tconst struct wil_fw_concurrency_combo *combo;\n\tconst struct wil_fw_concurrency_limit *limit;\n\tsize_t remain, lsize;\n\tint i, n_combos;\n\n\tif (size < sizeof(*rec)) {\n\t\twil_err_fw(wil, \"concurrency record too short: %zu\\n\", size);\n\t\t \n\t\treturn 0;\n\t}\n\n\tn_combos = le16_to_cpu(rec->n_combos);\n\tremain = size - offsetof(struct wil_fw_record_concurrency, combos);\n\tcombo = rec->combos;\n\tfor (i = 0; i < n_combos; i++) {\n\t\tif (remain < sizeof(*combo))\n\t\t\tgoto out_short;\n\t\tremain -= sizeof(*combo);\n\t\tlimit = combo->limits;\n\t\tlsize = combo->n_limits * sizeof(*limit);\n\t\tif (remain < lsize)\n\t\t\tgoto out_short;\n\t\tremain -= lsize;\n\t\tlimit += combo->n_limits;\n\t\tcombo = (struct wil_fw_concurrency_combo *)limit;\n\t}\n\n\treturn wil_cfg80211_iface_combinations_from_fw(wil, rec);\nout_short:\n\twil_err_fw(wil, \"concurrency record truncated\\n\");\n\treturn 0;\n}\n\nstatic int\nfw_handle_comment(struct wil6210_priv *wil, const void *data,\n\t\t  size_t size)\n{\n\tconst struct wil_fw_record_comment_hdr *hdr = data;\n\tu32 magic;\n\tint rc = 0;\n\n\tif (size < sizeof(*hdr))\n\t\treturn 0;\n\n\tmagic = le32_to_cpu(hdr->magic);\n\n\tswitch (magic) {\n\tcase WIL_FW_CAPABILITIES_MAGIC:\n\t\twil_dbg_fw(wil, \"magic is WIL_FW_CAPABILITIES_MAGIC\\n\");\n\t\trc = fw_handle_capabilities(wil, data, size);\n\t\tbreak;\n\tcase WIL_BRD_FILE_MAGIC:\n\t\twil_dbg_fw(wil, \"magic is WIL_BRD_FILE_MAGIC\\n\");\n\t\trc = fw_handle_brd_file(wil, data, size);\n\t\tbreak;\n\tcase WIL_FW_CONCURRENCY_MAGIC:\n\t\twil_dbg_fw(wil, \"magic is WIL_FW_CONCURRENCY_MAGIC\\n\");\n\t\trc = fw_handle_concurrency(wil, data, size);\n\t\tbreak;\n\tdefault:\n\t\twil_hex_dump_fw(\"\", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t\tdata, size, true);\n\t}\n\n\treturn rc;\n}\n\nstatic int __fw_handle_data(struct wil6210_priv *wil, const void *data,\n\t\t\t    size_t size, __le32 addr)\n{\n\tconst struct wil_fw_record_data *d = data;\n\tvoid __iomem *dst;\n\tsize_t s = size - sizeof(*d);\n\n\tif (size < sizeof(*d) + sizeof(u32)) {\n\t\twil_err_fw(wil, \"data record too short: %zu\\n\", size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!wil_fw_addr_check(wil, &dst, addr, s, \"address\"))\n\t\treturn -EINVAL;\n\twil_dbg_fw(wil, \"write [0x%08x] <== %zu bytes\\n\", le32_to_cpu(addr), s);\n\twil_memcpy_toio_32(dst, d->data, s);\n\twmb();  \n\n\treturn 0;\n}\n\nstatic int fw_handle_data(struct wil6210_priv *wil, const void *data,\n\t\t\t  size_t size)\n{\n\tconst struct wil_fw_record_data *d = data;\n\n\treturn __fw_handle_data(wil, data, size, d->addr);\n}\n\nstatic int fw_handle_fill(struct wil6210_priv *wil, const void *data,\n\t\t\t  size_t size)\n{\n\tconst struct wil_fw_record_fill *d = data;\n\tvoid __iomem *dst;\n\tu32 v;\n\tsize_t s = (size_t)le32_to_cpu(d->size);\n\n\tif (size != sizeof(*d)) {\n\t\twil_err_fw(wil, \"bad size for fill record: %zu\\n\", size);\n\t\treturn -EINVAL;\n\t}\n\n\tif (s < sizeof(u32)) {\n\t\twil_err_fw(wil, \"fill size too short: %zu\\n\", s);\n\t\treturn -EINVAL;\n\t}\n\n\tif (s % sizeof(u32)) {\n\t\twil_err_fw(wil, \"fill size not aligned: %zu\\n\", s);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!wil_fw_addr_check(wil, &dst, d->addr, s, \"address\"))\n\t\treturn -EINVAL;\n\n\tv = le32_to_cpu(d->value);\n\twil_dbg_fw(wil, \"fill [0x%08x] <== 0x%08x, %zu bytes\\n\",\n\t\t   le32_to_cpu(d->addr), v, s);\n\twil_memset_toio_32(dst, v, s);\n\twmb();  \n\n\treturn 0;\n}\n\nstatic int fw_handle_file_header(struct wil6210_priv *wil, const void *data,\n\t\t\t\t size_t size)\n{\n\tconst struct wil_fw_record_file_header *d = data;\n\n\tif (size != sizeof(*d)) {\n\t\twil_err_fw(wil, \"file header length incorrect: %zu\\n\", size);\n\t\treturn -EINVAL;\n\t}\n\n\twil_dbg_fw(wil, \"new file, ver. %d, %i bytes\\n\",\n\t\t   d->version, d->data_len);\n\twil_hex_dump_fw(\"\", DUMP_PREFIX_OFFSET, 16, 1, d->comment,\n\t\t\tsizeof(d->comment), true);\n\n\tif (!memcmp(d->comment, WIL_FW_VERSION_PREFIX,\n\t\t    WIL_FW_VERSION_PREFIX_LEN))\n\t\tmemcpy(wil->fw_version,\n\t\t       d->comment + WIL_FW_VERSION_PREFIX_LEN,\n\t\t       min(sizeof(d->comment) - WIL_FW_VERSION_PREFIX_LEN,\n\t\t\t   sizeof(wil->fw_version) - 1));\n\n\treturn 0;\n}\n\nstatic int fw_handle_direct_write(struct wil6210_priv *wil, const void *data,\n\t\t\t\t  size_t size)\n{\n\tconst struct wil_fw_record_direct_write *d = data;\n\tconst struct wil_fw_data_dwrite *block = d->data;\n\tint n, i;\n\n\tif (size % sizeof(*block)) {\n\t\twil_err_fw(wil, \"record size not aligned on %zu: %zu\\n\",\n\t\t\t   sizeof(*block), size);\n\t\treturn -EINVAL;\n\t}\n\tn = size / sizeof(*block);\n\n\tfor (i = 0; i < n; i++) {\n\t\tvoid __iomem *dst;\n\t\tu32 m = le32_to_cpu(block[i].mask);\n\t\tu32 v = le32_to_cpu(block[i].value);\n\t\tu32 x, y;\n\n\t\tif (!wil_fw_addr_check(wil, &dst, block[i].addr, 0, \"address\"))\n\t\t\treturn -EINVAL;\n\n\t\tx = readl(dst);\n\t\ty = (x & m) | (v & ~m);\n\t\twil_dbg_fw(wil, \"write [0x%08x] <== 0x%08x \"\n\t\t\t   \"(old 0x%08x val 0x%08x mask 0x%08x)\\n\",\n\t\t\t   le32_to_cpu(block[i].addr), y, x, v, m);\n\t\twritel(y, dst);\n\t\twmb();  \n\t}\n\n\treturn 0;\n}\n\nstatic int gw_write(struct wil6210_priv *wil, void __iomem *gwa_addr,\n\t\t    void __iomem *gwa_cmd, void __iomem *gwa_ctl, u32 gw_cmd,\n\t\t    u32 a)\n{\n\tunsigned delay = 0;\n\n\twritel(a, gwa_addr);\n\twritel(gw_cmd, gwa_cmd);\n\twmb();  \n\n\twritel(WIL_FW_GW_CTL_RUN, gwa_ctl);  \n\tdo {\n\t\tudelay(1);  \n\t\tif (delay++ > 100) {\n\t\t\twil_err_fw(wil, \"gw timeout\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} while (readl(gwa_ctl) & WIL_FW_GW_CTL_BUSY);  \n\n\treturn 0;\n}\n\nstatic int fw_handle_gateway_data(struct wil6210_priv *wil, const void *data,\n\t\t\t\t  size_t size)\n{\n\tconst struct wil_fw_record_gateway_data *d = data;\n\tconst struct wil_fw_data_gw *block = d->data;\n\tvoid __iomem *gwa_addr;\n\tvoid __iomem *gwa_val;\n\tvoid __iomem *gwa_cmd;\n\tvoid __iomem *gwa_ctl;\n\tu32 gw_cmd;\n\tint n, i;\n\n\tif (size < sizeof(*d) + sizeof(*block)) {\n\t\twil_err_fw(wil, \"gateway record too short: %zu\\n\", size);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((size - sizeof(*d)) % sizeof(*block)) {\n\t\twil_err_fw(wil, \"gateway record data size\"\n\t\t\t   \" not aligned on %zu: %zu\\n\",\n\t\t\t   sizeof(*block), size - sizeof(*d));\n\t\treturn -EINVAL;\n\t}\n\tn = (size - sizeof(*d)) / sizeof(*block);\n\n\tgw_cmd = le32_to_cpu(d->command);\n\n\twil_dbg_fw(wil, \"gw write record [%3d] blocks, cmd 0x%08x\\n\",\n\t\t   n, gw_cmd);\n\n\tif (!wil_fw_addr_check(wil, &gwa_addr, d->gateway_addr_addr, 0,\n\t\t\t       \"gateway_addr_addr\") ||\n\t    !wil_fw_addr_check(wil, &gwa_val, d->gateway_value_addr, 0,\n\t\t\t       \"gateway_value_addr\") ||\n\t    !wil_fw_addr_check(wil, &gwa_cmd, d->gateway_cmd_addr, 0,\n\t\t\t       \"gateway_cmd_addr\") ||\n\t    !wil_fw_addr_check(wil, &gwa_ctl, d->gateway_ctrl_address, 0,\n\t\t\t       \"gateway_ctrl_address\"))\n\t\treturn -EINVAL;\n\n\twil_dbg_fw(wil, \"gw addresses: addr 0x%08x val 0x%08x\"\n\t\t   \" cmd 0x%08x ctl 0x%08x\\n\",\n\t\t   le32_to_cpu(d->gateway_addr_addr),\n\t\t   le32_to_cpu(d->gateway_value_addr),\n\t\t   le32_to_cpu(d->gateway_cmd_addr),\n\t\t   le32_to_cpu(d->gateway_ctrl_address));\n\n\tfor (i = 0; i < n; i++) {\n\t\tint rc;\n\t\tu32 a = le32_to_cpu(block[i].addr);\n\t\tu32 v = le32_to_cpu(block[i].value);\n\n\t\twil_dbg_fw(wil, \"  gw write[%3d] [0x%08x] <== 0x%08x\\n\",\n\t\t\t   i, a, v);\n\n\t\twritel(v, gwa_val);\n\t\trc = gw_write(wil, gwa_addr, gwa_cmd, gwa_ctl, gw_cmd, a);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic int fw_handle_gateway_data4(struct wil6210_priv *wil, const void *data,\n\t\t\t\t   size_t size)\n{\n\tconst struct wil_fw_record_gateway_data4 *d = data;\n\tconst struct wil_fw_data_gw4 *block = d->data;\n\tvoid __iomem *gwa_addr;\n\tvoid __iomem *gwa_val[ARRAY_SIZE(block->value)];\n\tvoid __iomem *gwa_cmd;\n\tvoid __iomem *gwa_ctl;\n\tu32 gw_cmd;\n\tint n, i, k;\n\n\tif (size < sizeof(*d) + sizeof(*block)) {\n\t\twil_err_fw(wil, \"gateway4 record too short: %zu\\n\", size);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((size - sizeof(*d)) % sizeof(*block)) {\n\t\twil_err_fw(wil, \"gateway4 record data size\"\n\t\t\t   \" not aligned on %zu: %zu\\n\",\n\t\t\t   sizeof(*block), size - sizeof(*d));\n\t\treturn -EINVAL;\n\t}\n\tn = (size - sizeof(*d)) / sizeof(*block);\n\n\tgw_cmd = le32_to_cpu(d->command);\n\n\twil_dbg_fw(wil, \"gw4 write record [%3d] blocks, cmd 0x%08x\\n\",\n\t\t   n, gw_cmd);\n\n\tif (!wil_fw_addr_check(wil, &gwa_addr, d->gateway_addr_addr, 0,\n\t\t\t       \"gateway_addr_addr\"))\n\t\treturn -EINVAL;\n\tfor (k = 0; k < ARRAY_SIZE(block->value); k++)\n\t\tif (!wil_fw_addr_check(wil, &gwa_val[k],\n\t\t\t\t       d->gateway_value_addr[k],\n\t\t\t\t       0, \"gateway_value_addr\"))\n\t\t\treturn -EINVAL;\n\tif (!wil_fw_addr_check(wil, &gwa_cmd, d->gateway_cmd_addr, 0,\n\t\t\t       \"gateway_cmd_addr\") ||\n\t    !wil_fw_addr_check(wil, &gwa_ctl, d->gateway_ctrl_address, 0,\n\t\t\t       \"gateway_ctrl_address\"))\n\t\treturn -EINVAL;\n\n\twil_dbg_fw(wil, \"gw4 addresses: addr 0x%08x cmd 0x%08x ctl 0x%08x\\n\",\n\t\t   le32_to_cpu(d->gateway_addr_addr),\n\t\t   le32_to_cpu(d->gateway_cmd_addr),\n\t\t   le32_to_cpu(d->gateway_ctrl_address));\n\twil_hex_dump_fw(\"val addresses: \", DUMP_PREFIX_NONE, 16, 4,\n\t\t\td->gateway_value_addr, sizeof(d->gateway_value_addr),\n\t\t\tfalse);\n\n\tfor (i = 0; i < n; i++) {\n\t\tint rc;\n\t\tu32 a = le32_to_cpu(block[i].addr);\n\t\tu32 v[ARRAY_SIZE(block->value)];\n\n\t\tfor (k = 0; k < ARRAY_SIZE(block->value); k++)\n\t\t\tv[k] = le32_to_cpu(block[i].value[k]);\n\n\t\twil_dbg_fw(wil, \"  gw4 write[%3d] [0x%08x] <==\\n\", i, a);\n\t\twil_hex_dump_fw(\"    val \", DUMP_PREFIX_NONE, 16, 4, v,\n\t\t\t\tsizeof(v), false);\n\n\t\tfor (k = 0; k < ARRAY_SIZE(block->value); k++)\n\t\t\twritel(v[k], gwa_val[k]);\n\t\trc = gw_write(wil, gwa_addr, gwa_cmd, gwa_ctl, gw_cmd, a);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct {\n\tint type;\n\tint (*load_handler)(struct wil6210_priv *wil, const void *data,\n\t\t\t    size_t size);\n\tint (*parse_handler)(struct wil6210_priv *wil, const void *data,\n\t\t\t     size_t size);\n} wil_fw_handlers[] = {\n\t{wil_fw_type_comment, fw_handle_comment, fw_handle_comment},\n\t{wil_fw_type_data, fw_handle_data, fw_ignore_section},\n\t{wil_fw_type_fill, fw_handle_fill, fw_ignore_section},\n\t \n\t \n\t{wil_fw_type_file_header, fw_handle_file_header,\n\t\tfw_handle_file_header},\n\t{wil_fw_type_direct_write, fw_handle_direct_write, fw_ignore_section},\n\t{wil_fw_type_gateway_data, fw_handle_gateway_data, fw_ignore_section},\n\t{wil_fw_type_gateway_data4, fw_handle_gateway_data4,\n\t\tfw_ignore_section},\n};\n\nstatic int wil_fw_handle_record(struct wil6210_priv *wil, int type,\n\t\t\t\tconst void *data, size_t size, bool load)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(wil_fw_handlers); i++)\n\t\tif (wil_fw_handlers[i].type == type)\n\t\t\treturn load ?\n\t\t\t\twil_fw_handlers[i].load_handler(\n\t\t\t\t\twil, data, size) :\n\t\t\t\twil_fw_handlers[i].parse_handler(\n\t\t\t\t\twil, data, size);\n\n\twil_err_fw(wil, \"unknown record type: %d\\n\", type);\n\treturn -EINVAL;\n}\n\n \nstatic int wil_fw_process(struct wil6210_priv *wil, const void *data,\n\t\t\t  size_t size, bool load)\n{\n\tint rc = 0;\n\tconst struct wil_fw_record_head *hdr;\n\tsize_t s, hdr_sz;\n\n\tfor (hdr = data;; hdr = (const void *)hdr + s, size -= s) {\n\t\tif (size < sizeof(*hdr))\n\t\t\tbreak;\n\t\thdr_sz = le32_to_cpu(hdr->size);\n\t\ts = sizeof(*hdr) + hdr_sz;\n\t\tif (s > size)\n\t\t\tbreak;\n\t\tif (hdr_sz % 4) {\n\t\t\twil_err_fw(wil, \"unaligned record size: %zu\\n\",\n\t\t\t\t   hdr_sz);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\trc = wil_fw_handle_record(wil, le16_to_cpu(hdr->type),\n\t\t\t\t\t  &hdr[1], hdr_sz, load);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\tif (size) {\n\t\twil_err_fw(wil, \"unprocessed bytes: %zu\\n\", size);\n\t\tif (size >= sizeof(*hdr)) {\n\t\t\twil_err_fw(wil, \"Stop at offset %ld\"\n\t\t\t\t   \" record type %d [%zd bytes]\\n\",\n\t\t\t\t   (long)((const void *)hdr - data),\n\t\t\t\t   le16_to_cpu(hdr->type), hdr_sz);\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\n\treturn rc;\n}\n\n \nint wil_request_firmware(struct wil6210_priv *wil, const char *name,\n\t\t\t bool load)\n{\n\tint rc, rc1;\n\tconst struct firmware *fw;\n\tsize_t sz;\n\tconst void *d;\n\n\trc = request_firmware(&fw, name, wil_to_dev(wil));\n\tif (rc) {\n\t\twil_err_fw(wil, \"Failed to load firmware %s rc %d\\n\", name, rc);\n\t\treturn rc;\n\t}\n\twil_dbg_fw(wil, \"Loading <%s>, %zu bytes\\n\", name, fw->size);\n\n\t \n\twil->num_of_brd_entries = 0;\n\tkfree(wil->brd_info);\n\twil->brd_info = NULL;\n\n\tfor (sz = fw->size, d = fw->data; sz; sz -= rc1, d += rc1) {\n\t\trc1 = wil_fw_verify(wil, d, sz);\n\t\tif (rc1 < 0) {\n\t\t\trc = rc1;\n\t\t\tgoto out;\n\t\t}\n\t\trc = wil_fw_process(wil, d, rc1, load);\n\t\tif (rc < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\trelease_firmware(fw);\n\tif (rc)\n\t\twil_err_fw(wil, \"Loading <%s> failed, rc %d\\n\", name, rc);\n\treturn rc;\n}\n\n \nstatic int wil_brd_process(struct wil6210_priv *wil, const void *data,\n\t\t\t   size_t size)\n{\n\tint rc = 0;\n\tconst struct wil_fw_record_head *hdr = data;\n\tsize_t s, hdr_sz = 0;\n\tu16 type;\n\tint i = 0;\n\n\t \n\tif (size < sizeof(*hdr))\n\t\treturn -EINVAL;\n\ts = sizeof(*hdr) + le32_to_cpu(hdr->size);\n\tif (s > size)\n\t\treturn -EINVAL;\n\n\t \n\tsize -= s;\n\n\tfor (hdr = data + s;; hdr = (const void *)hdr + s, size -= s, i++) {\n\t\tif (size < sizeof(*hdr))\n\t\t\tbreak;\n\n\t\tif (i >= wil->num_of_brd_entries) {\n\t\t\twil_err_fw(wil,\n\t\t\t\t   \"Too many brd records: %d, num of expected entries %d\\n\",\n\t\t\t\t   i, wil->num_of_brd_entries);\n\t\t\tbreak;\n\t\t}\n\n\t\thdr_sz = le32_to_cpu(hdr->size);\n\t\ts = sizeof(*hdr) + hdr_sz;\n\t\tif (wil->brd_info[i].file_max_size &&\n\t\t    hdr_sz > wil->brd_info[i].file_max_size)\n\t\t\treturn -EINVAL;\n\t\tif (sizeof(*hdr) + hdr_sz > size)\n\t\t\treturn -EINVAL;\n\t\tif (hdr_sz % 4) {\n\t\t\twil_err_fw(wil, \"unaligned record size: %zu\\n\",\n\t\t\t\t   hdr_sz);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttype = le16_to_cpu(hdr->type);\n\t\tif (type != wil_fw_type_data) {\n\t\t\twil_err_fw(wil,\n\t\t\t\t   \"invalid record type for board file: %d\\n\",\n\t\t\t\t   type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (hdr_sz < sizeof(struct wil_fw_record_data)) {\n\t\t\twil_err_fw(wil, \"data record too short: %zu\\n\", hdr_sz);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\twil_dbg_fw(wil,\n\t\t\t   \"using info from fw file for record %d: addr[0x%08x], max size %d\\n\",\n\t\t\t   i, wil->brd_info[i].file_addr,\n\t\t\t   wil->brd_info[i].file_max_size);\n\n\t\trc = __fw_handle_data(wil, &hdr[1], hdr_sz,\n\t\t\t\t      cpu_to_le32(wil->brd_info[i].file_addr));\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\tif (size) {\n\t\twil_err_fw(wil, \"unprocessed bytes: %zu\\n\", size);\n\t\tif (size >= sizeof(*hdr)) {\n\t\t\twil_err_fw(wil,\n\t\t\t\t   \"Stop at offset %ld record type %d [%zd bytes]\\n\",\n\t\t\t\t   (long)((const void *)hdr - data),\n\t\t\t\t   le16_to_cpu(hdr->type), hdr_sz);\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nint wil_request_board(struct wil6210_priv *wil, const char *name)\n{\n\tint rc, dlen;\n\tconst struct firmware *brd;\n\n\trc = request_firmware(&brd, name, wil_to_dev(wil));\n\tif (rc) {\n\t\twil_err_fw(wil, \"Failed to load brd %s\\n\", name);\n\t\treturn rc;\n\t}\n\twil_dbg_fw(wil, \"Loading <%s>, %zu bytes\\n\", name, brd->size);\n\n\t \n\tdlen = wil_fw_verify(wil, brd->data, brd->size);\n\tif (dlen < 0) {\n\t\trc = dlen;\n\t\tgoto out;\n\t}\n\n\t \n\trc = wil_brd_process(wil, brd->data, dlen);\n\nout:\n\trelease_firmware(brd);\n\tif (rc)\n\t\twil_err_fw(wil, \"Loading <%s> failed, rc %d\\n\", name, rc);\n\treturn rc;\n}\n\n \nbool wil_fw_verify_file_exists(struct wil6210_priv *wil, const char *name)\n{\n\tconst struct firmware *fw;\n\tint rc;\n\n\trc = request_firmware(&fw, name, wil_to_dev(wil));\n\tif (!rc)\n\t\trelease_firmware(fw);\n\telse\n\t\twil_dbg_fw(wil, \"<%s> not available: %d\\n\", name, rc);\n\treturn !rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}