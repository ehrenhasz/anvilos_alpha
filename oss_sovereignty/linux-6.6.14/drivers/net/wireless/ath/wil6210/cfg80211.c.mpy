{
  "module_name": "cfg80211.c",
  "hash_id": "bab47c37ae0ad7132115d427d03295cca20f92fc0b9f4efd0d79fea5ea095c43",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/wil6210/cfg80211.c",
  "human_readable_source": "\n \n\n#include <linux/etherdevice.h>\n#include <linux/moduleparam.h>\n#include <net/netlink.h>\n#include <net/cfg80211.h>\n#include \"wil6210.h\"\n#include \"wmi.h\"\n#include \"fw.h\"\n\n#define WIL_MAX_ROC_DURATION_MS 5000\n\n#define WIL_EDMG_CHANNEL_9_SUBCHANNELS\t(BIT(0) | BIT(1))\n#define WIL_EDMG_CHANNEL_10_SUBCHANNELS\t(BIT(1) | BIT(2))\n#define WIL_EDMG_CHANNEL_11_SUBCHANNELS\t(BIT(2) | BIT(3))\n\n \n#define WIL_EDMG_BW_CONFIGURATION 5\n\n \n#define WIL_EDMG_CHANNELS (BIT(0) | BIT(1) | BIT(2) | BIT(3))\n\nbool disable_ap_sme;\nmodule_param(disable_ap_sme, bool, 0444);\nMODULE_PARM_DESC(disable_ap_sme, \" let user space handle AP mode SME\");\n\n#ifdef CONFIG_PM\nstatic struct wiphy_wowlan_support wil_wowlan_support = {\n\t.flags = WIPHY_WOWLAN_ANY | WIPHY_WOWLAN_DISCONNECT,\n};\n#endif\n\n#define CHAN60G(_channel, _flags) {\t\t\t\t\\\n\t.band\t\t\t= NL80211_BAND_60GHZ,\t\t\\\n\t.center_freq\t\t= 56160 + (2160 * (_channel)),\t\\\n\t.hw_value\t\t= (_channel),\t\t\t\\\n\t.flags\t\t\t= (_flags),\t\t\t\\\n\t.max_antenna_gain\t= 0,\t\t\t\t\\\n\t.max_power\t\t= 40,\t\t\t\t\\\n}\n\nstatic struct ieee80211_channel wil_60ghz_channels[] = {\n\tCHAN60G(1, 0),\n\tCHAN60G(2, 0),\n\tCHAN60G(3, 0),\n\tCHAN60G(4, 0),\n};\n\n \nenum wil_rx_cb_mode {\n\tWIL_RX_CB_MODE_DMG,\n\tWIL_RX_CB_MODE_EDMG,\n\tWIL_RX_CB_MODE_WIDE,\n};\n\nstatic int wil_rx_cb_mode_to_n_bonded(u8 cb_mode)\n{\n\tswitch (cb_mode) {\n\tcase WIL_RX_CB_MODE_DMG:\n\tcase WIL_RX_CB_MODE_EDMG:\n\t\treturn 1;\n\tcase WIL_RX_CB_MODE_WIDE:\n\t\treturn 2;\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\nstatic int wil_tx_cb_mode_to_n_bonded(u8 cb_mode)\n{\n\tswitch (cb_mode) {\n\tcase WMI_TX_MODE_DMG:\n\tcase WMI_TX_MODE_EDMG_CB1:\n\t\treturn 1;\n\tcase WMI_TX_MODE_EDMG_CB2:\n\t\treturn 2;\n\tdefault:\n\t\treturn 1;\n\t}\n}\n\nstatic void\nwil_memdup_ie(u8 **pdst, size_t *pdst_len, const u8 *src, size_t src_len)\n{\n\tkfree(*pdst);\n\t*pdst = NULL;\n\t*pdst_len = 0;\n\tif (src_len > 0) {\n\t\t*pdst = kmemdup(src, src_len, GFP_KERNEL);\n\t\tif (*pdst)\n\t\t\t*pdst_len = src_len;\n\t}\n}\n\nstatic int wil_num_supported_channels(struct wil6210_priv *wil)\n{\n\tint num_channels = ARRAY_SIZE(wil_60ghz_channels);\n\n\tif (!test_bit(WMI_FW_CAPABILITY_CHANNEL_4, wil->fw_capabilities))\n\t\tnum_channels--;\n\n\treturn num_channels;\n}\n\nvoid update_supported_bands(struct wil6210_priv *wil)\n{\n\tstruct wiphy *wiphy = wil_to_wiphy(wil);\n\n\twil_dbg_misc(wil, \"update supported bands\");\n\n\twiphy->bands[NL80211_BAND_60GHZ]->n_channels =\n\t\t\t\t\t\twil_num_supported_channels(wil);\n\n\tif (test_bit(WMI_FW_CAPABILITY_CHANNEL_BONDING, wil->fw_capabilities)) {\n\t\twiphy->bands[NL80211_BAND_60GHZ]->edmg_cap.channels =\n\t\t\t\t\t\t\tWIL_EDMG_CHANNELS;\n\t\twiphy->bands[NL80211_BAND_60GHZ]->edmg_cap.bw_config =\n\t\t\t\t\t\t      WIL_EDMG_BW_CONFIGURATION;\n\t}\n}\n\n \n\n#define QCA_NL80211_VENDOR_ID\t0x001374\n\n#define WIL_MAX_RF_SECTORS (128)\n#define WIL_CID_ALL (0xff)\n\nenum qca_wlan_vendor_attr_rf_sector {\n\tQCA_ATTR_MAC_ADDR = 6,\n\tQCA_ATTR_PAD = 13,\n\tQCA_ATTR_TSF = 29,\n\tQCA_ATTR_DMG_RF_SECTOR_INDEX = 30,\n\tQCA_ATTR_DMG_RF_SECTOR_TYPE = 31,\n\tQCA_ATTR_DMG_RF_MODULE_MASK = 32,\n\tQCA_ATTR_DMG_RF_SECTOR_CFG = 33,\n\tQCA_ATTR_DMG_RF_SECTOR_MAX,\n};\n\nenum qca_wlan_vendor_attr_dmg_rf_sector_type {\n\tQCA_ATTR_DMG_RF_SECTOR_TYPE_RX,\n\tQCA_ATTR_DMG_RF_SECTOR_TYPE_TX,\n\tQCA_ATTR_DMG_RF_SECTOR_TYPE_MAX\n};\n\nenum qca_wlan_vendor_attr_dmg_rf_sector_cfg {\n\tQCA_ATTR_DMG_RF_SECTOR_CFG_INVALID = 0,\n\tQCA_ATTR_DMG_RF_SECTOR_CFG_MODULE_INDEX,\n\tQCA_ATTR_DMG_RF_SECTOR_CFG_ETYPE0,\n\tQCA_ATTR_DMG_RF_SECTOR_CFG_ETYPE1,\n\tQCA_ATTR_DMG_RF_SECTOR_CFG_ETYPE2,\n\tQCA_ATTR_DMG_RF_SECTOR_CFG_PSH_HI,\n\tQCA_ATTR_DMG_RF_SECTOR_CFG_PSH_LO,\n\tQCA_ATTR_DMG_RF_SECTOR_CFG_DTYPE_X16,\n\n\t \n\tQCA_ATTR_DMG_RF_SECTOR_CFG_AFTER_LAST,\n\tQCA_ATTR_DMG_RF_SECTOR_CFG_MAX =\n\tQCA_ATTR_DMG_RF_SECTOR_CFG_AFTER_LAST - 1\n};\n\nstatic const struct\nnla_policy wil_rf_sector_policy[QCA_ATTR_DMG_RF_SECTOR_MAX + 1] = {\n\t[QCA_ATTR_MAC_ADDR] = { .len = ETH_ALEN },\n\t[QCA_ATTR_DMG_RF_SECTOR_INDEX] = { .type = NLA_U16 },\n\t[QCA_ATTR_DMG_RF_SECTOR_TYPE] = { .type = NLA_U8 },\n\t[QCA_ATTR_DMG_RF_MODULE_MASK] = { .type = NLA_U32 },\n\t[QCA_ATTR_DMG_RF_SECTOR_CFG] = { .type = NLA_NESTED },\n};\n\nstatic const struct\nnla_policy wil_rf_sector_cfg_policy[QCA_ATTR_DMG_RF_SECTOR_CFG_MAX + 1] = {\n\t[QCA_ATTR_DMG_RF_SECTOR_CFG_MODULE_INDEX] = { .type = NLA_U8 },\n\t[QCA_ATTR_DMG_RF_SECTOR_CFG_ETYPE0] = { .type = NLA_U32 },\n\t[QCA_ATTR_DMG_RF_SECTOR_CFG_ETYPE1] = { .type = NLA_U32 },\n\t[QCA_ATTR_DMG_RF_SECTOR_CFG_ETYPE2] = { .type = NLA_U32 },\n\t[QCA_ATTR_DMG_RF_SECTOR_CFG_PSH_HI] = { .type = NLA_U32 },\n\t[QCA_ATTR_DMG_RF_SECTOR_CFG_PSH_LO] = { .type = NLA_U32 },\n\t[QCA_ATTR_DMG_RF_SECTOR_CFG_DTYPE_X16] = { .type = NLA_U32 },\n};\n\nenum qca_nl80211_vendor_subcmds {\n\tQCA_NL80211_VENDOR_SUBCMD_DMG_RF_GET_SECTOR_CFG = 139,\n\tQCA_NL80211_VENDOR_SUBCMD_DMG_RF_SET_SECTOR_CFG = 140,\n\tQCA_NL80211_VENDOR_SUBCMD_DMG_RF_GET_SELECTED_SECTOR = 141,\n\tQCA_NL80211_VENDOR_SUBCMD_DMG_RF_SET_SELECTED_SECTOR = 142,\n};\n\nstatic int wil_rf_sector_get_cfg(struct wiphy *wiphy,\n\t\t\t\t struct wireless_dev *wdev,\n\t\t\t\t const void *data, int data_len);\nstatic int wil_rf_sector_set_cfg(struct wiphy *wiphy,\n\t\t\t\t struct wireless_dev *wdev,\n\t\t\t\t const void *data, int data_len);\nstatic int wil_rf_sector_get_selected(struct wiphy *wiphy,\n\t\t\t\t      struct wireless_dev *wdev,\n\t\t\t\t      const void *data, int data_len);\nstatic int wil_rf_sector_set_selected(struct wiphy *wiphy,\n\t\t\t\t      struct wireless_dev *wdev,\n\t\t\t\t      const void *data, int data_len);\n\n \nstatic const struct wiphy_vendor_command wil_nl80211_vendor_commands[] = {\n\t{\n\t\t.info.vendor_id = QCA_NL80211_VENDOR_ID,\n\t\t.info.subcmd = QCA_NL80211_VENDOR_SUBCMD_DMG_RF_GET_SECTOR_CFG,\n\t\t.flags = WIPHY_VENDOR_CMD_NEED_WDEV |\n\t\t\t WIPHY_VENDOR_CMD_NEED_RUNNING,\n\t\t.policy = wil_rf_sector_policy,\n\t\t.doit = wil_rf_sector_get_cfg\n\t},\n\t{\n\t\t.info.vendor_id = QCA_NL80211_VENDOR_ID,\n\t\t.info.subcmd = QCA_NL80211_VENDOR_SUBCMD_DMG_RF_SET_SECTOR_CFG,\n\t\t.flags = WIPHY_VENDOR_CMD_NEED_WDEV |\n\t\t\t WIPHY_VENDOR_CMD_NEED_RUNNING,\n\t\t.policy = wil_rf_sector_policy,\n\t\t.doit = wil_rf_sector_set_cfg\n\t},\n\t{\n\t\t.info.vendor_id = QCA_NL80211_VENDOR_ID,\n\t\t.info.subcmd =\n\t\t\tQCA_NL80211_VENDOR_SUBCMD_DMG_RF_GET_SELECTED_SECTOR,\n\t\t.flags = WIPHY_VENDOR_CMD_NEED_WDEV |\n\t\t\t WIPHY_VENDOR_CMD_NEED_RUNNING,\n\t\t.policy = wil_rf_sector_policy,\n\t\t.doit = wil_rf_sector_get_selected\n\t},\n\t{\n\t\t.info.vendor_id = QCA_NL80211_VENDOR_ID,\n\t\t.info.subcmd =\n\t\t\tQCA_NL80211_VENDOR_SUBCMD_DMG_RF_SET_SELECTED_SECTOR,\n\t\t.flags = WIPHY_VENDOR_CMD_NEED_WDEV |\n\t\t\t WIPHY_VENDOR_CMD_NEED_RUNNING,\n\t\t.policy = wil_rf_sector_policy,\n\t\t.doit = wil_rf_sector_set_selected\n\t},\n};\n\nstatic struct ieee80211_supported_band wil_band_60ghz = {\n\t.channels = wil_60ghz_channels,\n\t.n_channels = ARRAY_SIZE(wil_60ghz_channels),\n\t.ht_cap = {\n\t\t.ht_supported = true,\n\t\t.cap = 0,  \n\t\t.ampdu_factor = IEEE80211_HT_MAX_AMPDU_64K,  \n\t\t.ampdu_density = IEEE80211_HT_MPDU_DENSITY_8,  \n\t\t.mcs = {\n\t\t\t\t \n\t\t\t.rx_mask = {0xfe, 0x1f},  \n\t\t\t.tx_params = IEEE80211_HT_MCS_TX_DEFINED,  \n\t\t},\n\t},\n};\n\nstatic const struct ieee80211_txrx_stypes\nwil_mgmt_stypes[NUM_NL80211_IFTYPES] = {\n\t[NL80211_IFTYPE_STATION] = {\n\t\t.tx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\tBIT(IEEE80211_STYPE_PROBE_RESP >> 4),\n\t\t.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\tBIT(IEEE80211_STYPE_PROBE_REQ >> 4)\n\t},\n\t[NL80211_IFTYPE_AP] = {\n\t\t.tx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\tBIT(IEEE80211_STYPE_PROBE_RESP >> 4) |\n\t\tBIT(IEEE80211_STYPE_ASSOC_RESP >> 4) |\n\t\tBIT(IEEE80211_STYPE_DISASSOC >> 4) |\n\t\tBIT(IEEE80211_STYPE_AUTH >> 4) |\n\t\tBIT(IEEE80211_STYPE_REASSOC_RESP >> 4),\n\t\t.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\tBIT(IEEE80211_STYPE_PROBE_REQ >> 4) |\n\t\tBIT(IEEE80211_STYPE_ASSOC_REQ >> 4) |\n\t\tBIT(IEEE80211_STYPE_DISASSOC >> 4) |\n\t\tBIT(IEEE80211_STYPE_AUTH >> 4) |\n\t\tBIT(IEEE80211_STYPE_DEAUTH >> 4) |\n\t\tBIT(IEEE80211_STYPE_REASSOC_REQ >> 4)\n\t},\n\t[NL80211_IFTYPE_P2P_CLIENT] = {\n\t\t.tx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\tBIT(IEEE80211_STYPE_PROBE_RESP >> 4),\n\t\t.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\tBIT(IEEE80211_STYPE_PROBE_REQ >> 4)\n\t},\n\t[NL80211_IFTYPE_P2P_GO] = {\n\t\t.tx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\tBIT(IEEE80211_STYPE_PROBE_RESP >> 4),\n\t\t.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\tBIT(IEEE80211_STYPE_PROBE_REQ >> 4)\n\t},\n\t[NL80211_IFTYPE_P2P_DEVICE] = {\n\t\t.tx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\tBIT(IEEE80211_STYPE_PROBE_RESP >> 4),\n\t\t.rx = BIT(IEEE80211_STYPE_ACTION >> 4) |\n\t\tBIT(IEEE80211_STYPE_PROBE_REQ >> 4)\n\t},\n};\n\nstatic const u32 wil_cipher_suites[] = {\n\tWLAN_CIPHER_SUITE_GCMP,\n};\n\nstatic const char * const key_usage_str[] = {\n\t[WMI_KEY_USE_PAIRWISE]\t= \"PTK\",\n\t[WMI_KEY_USE_RX_GROUP]\t= \"RX_GTK\",\n\t[WMI_KEY_USE_TX_GROUP]\t= \"TX_GTK\",\n\t[WMI_KEY_USE_STORE_PTK]\t= \"STORE_PTK\",\n\t[WMI_KEY_USE_APPLY_PTK]\t= \"APPLY_PTK\",\n};\n\nint wil_iftype_nl2wmi(enum nl80211_iftype type)\n{\n\tstatic const struct {\n\t\tenum nl80211_iftype nl;\n\t\tenum wmi_network_type wmi;\n\t} __nl2wmi[] = {\n\t\t{NL80211_IFTYPE_ADHOC,\t\tWMI_NETTYPE_ADHOC},\n\t\t{NL80211_IFTYPE_STATION,\tWMI_NETTYPE_INFRA},\n\t\t{NL80211_IFTYPE_AP,\t\tWMI_NETTYPE_AP},\n\t\t{NL80211_IFTYPE_P2P_CLIENT,\tWMI_NETTYPE_P2P},\n\t\t{NL80211_IFTYPE_P2P_GO,\t\tWMI_NETTYPE_P2P},\n\t\t{NL80211_IFTYPE_MONITOR,\tWMI_NETTYPE_ADHOC},  \n\t};\n\tuint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(__nl2wmi); i++) {\n\t\tif (__nl2wmi[i].nl == type)\n\t\t\treturn __nl2wmi[i].wmi;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nint wil_spec2wmi_ch(u8 spec_ch, u8 *wmi_ch)\n{\n\tswitch (spec_ch) {\n\tcase 1:\n\t\t*wmi_ch = WMI_CHANNEL_1;\n\t\tbreak;\n\tcase 2:\n\t\t*wmi_ch = WMI_CHANNEL_2;\n\t\tbreak;\n\tcase 3:\n\t\t*wmi_ch = WMI_CHANNEL_3;\n\t\tbreak;\n\tcase 4:\n\t\t*wmi_ch = WMI_CHANNEL_4;\n\t\tbreak;\n\tcase 5:\n\t\t*wmi_ch = WMI_CHANNEL_5;\n\t\tbreak;\n\tcase 6:\n\t\t*wmi_ch = WMI_CHANNEL_6;\n\t\tbreak;\n\tcase 9:\n\t\t*wmi_ch = WMI_CHANNEL_9;\n\t\tbreak;\n\tcase 10:\n\t\t*wmi_ch = WMI_CHANNEL_10;\n\t\tbreak;\n\tcase 11:\n\t\t*wmi_ch = WMI_CHANNEL_11;\n\t\tbreak;\n\tcase 12:\n\t\t*wmi_ch = WMI_CHANNEL_12;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint wil_wmi2spec_ch(u8 wmi_ch, u8 *spec_ch)\n{\n\tswitch (wmi_ch) {\n\tcase WMI_CHANNEL_1:\n\t\t*spec_ch = 1;\n\t\tbreak;\n\tcase WMI_CHANNEL_2:\n\t\t*spec_ch = 2;\n\t\tbreak;\n\tcase WMI_CHANNEL_3:\n\t\t*spec_ch = 3;\n\t\tbreak;\n\tcase WMI_CHANNEL_4:\n\t\t*spec_ch = 4;\n\t\tbreak;\n\tcase WMI_CHANNEL_5:\n\t\t*spec_ch = 5;\n\t\tbreak;\n\tcase WMI_CHANNEL_6:\n\t\t*spec_ch = 6;\n\t\tbreak;\n\tcase WMI_CHANNEL_9:\n\t\t*spec_ch = 9;\n\t\tbreak;\n\tcase WMI_CHANNEL_10:\n\t\t*spec_ch = 10;\n\t\tbreak;\n\tcase WMI_CHANNEL_11:\n\t\t*spec_ch = 11;\n\t\tbreak;\n\tcase WMI_CHANNEL_12:\n\t\t*spec_ch = 12;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint wil_cid_fill_sinfo(struct wil6210_vif *vif, int cid,\n\t\t       struct station_info *sinfo)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tstruct wmi_notify_req_cmd cmd = {\n\t\t.cid = cid,\n\t\t.interval_usec = 0,\n\t};\n\tstruct {\n\t\tstruct wmi_cmd_hdr wmi;\n\t\tstruct wmi_notify_req_done_event evt;\n\t} __packed reply;\n\tstruct wil_net_stats *stats = &wil->sta[cid].stats;\n\tint rc;\n\tu8 tx_mcs, rx_mcs;\n\tu8 tx_rate_flag = RATE_INFO_FLAGS_DMG;\n\tu8 rx_rate_flag = RATE_INFO_FLAGS_DMG;\n\n\tmemset(&reply, 0, sizeof(reply));\n\n\trc = wmi_call(wil, WMI_NOTIFY_REQ_CMDID, vif->mid, &cmd, sizeof(cmd),\n\t\t      WMI_NOTIFY_REQ_DONE_EVENTID, &reply, sizeof(reply),\n\t\t      WIL_WMI_CALL_GENERAL_TO_MS);\n\tif (rc)\n\t\treturn rc;\n\n\ttx_mcs = le16_to_cpu(reply.evt.bf_mcs);\n\n\twil_dbg_wmi(wil, \"Link status for CID %d MID %d: {\\n\"\n\t\t    \"  MCS %s TSF 0x%016llx\\n\"\n\t\t    \"  BF status 0x%08x RSSI %d SQI %d%%\\n\"\n\t\t    \"  Tx Tpt %d goodput %d Rx goodput %d\\n\"\n\t\t    \"  Sectors(rx:tx) my %d:%d peer %d:%d\\n\"\n\t\t    \"  Tx mode %d}\\n\",\n\t\t    cid, vif->mid, WIL_EXTENDED_MCS_CHECK(tx_mcs),\n\t\t    le64_to_cpu(reply.evt.tsf), reply.evt.status,\n\t\t    reply.evt.rssi,\n\t\t    reply.evt.sqi,\n\t\t    le32_to_cpu(reply.evt.tx_tpt),\n\t\t    le32_to_cpu(reply.evt.tx_goodput),\n\t\t    le32_to_cpu(reply.evt.rx_goodput),\n\t\t    le16_to_cpu(reply.evt.my_rx_sector),\n\t\t    le16_to_cpu(reply.evt.my_tx_sector),\n\t\t    le16_to_cpu(reply.evt.other_rx_sector),\n\t\t    le16_to_cpu(reply.evt.other_tx_sector),\n\t\t    reply.evt.tx_mode);\n\n\tsinfo->generation = wil->sinfo_gen;\n\n\tsinfo->filled = BIT_ULL(NL80211_STA_INFO_RX_BYTES) |\n\t\t\tBIT_ULL(NL80211_STA_INFO_TX_BYTES) |\n\t\t\tBIT_ULL(NL80211_STA_INFO_RX_PACKETS) |\n\t\t\tBIT_ULL(NL80211_STA_INFO_TX_PACKETS) |\n\t\t\tBIT_ULL(NL80211_STA_INFO_RX_BITRATE) |\n\t\t\tBIT_ULL(NL80211_STA_INFO_TX_BITRATE) |\n\t\t\tBIT_ULL(NL80211_STA_INFO_RX_DROP_MISC) |\n\t\t\tBIT_ULL(NL80211_STA_INFO_TX_FAILED);\n\n\tif (wil->use_enhanced_dma_hw && reply.evt.tx_mode != WMI_TX_MODE_DMG) {\n\t\ttx_rate_flag = RATE_INFO_FLAGS_EDMG;\n\t\trx_rate_flag = RATE_INFO_FLAGS_EDMG;\n\t}\n\n\trx_mcs = stats->last_mcs_rx;\n\n\t \n\tif (tx_mcs == WIL_EXTENDED_MCS_26) {\n\t\ttx_rate_flag = RATE_INFO_FLAGS_EXTENDED_SC_DMG;\n\t\ttx_mcs = WIL_BASE_MCS_FOR_EXTENDED_26;\n\t}\n\tif (rx_mcs == WIL_EXTENDED_MCS_26) {\n\t\trx_rate_flag = RATE_INFO_FLAGS_EXTENDED_SC_DMG;\n\t\trx_mcs = WIL_BASE_MCS_FOR_EXTENDED_26;\n\t}\n\n\tsinfo->txrate.flags = tx_rate_flag;\n\tsinfo->rxrate.flags = rx_rate_flag;\n\tsinfo->txrate.mcs = tx_mcs;\n\tsinfo->rxrate.mcs = rx_mcs;\n\n\tsinfo->txrate.n_bonded_ch =\n\t\t\t\t  wil_tx_cb_mode_to_n_bonded(reply.evt.tx_mode);\n\tsinfo->rxrate.n_bonded_ch =\n\t\t\t     wil_rx_cb_mode_to_n_bonded(stats->last_cb_mode_rx);\n\tsinfo->rx_bytes = stats->rx_bytes;\n\tsinfo->rx_packets = stats->rx_packets;\n\tsinfo->rx_dropped_misc = stats->rx_dropped;\n\tsinfo->tx_bytes = stats->tx_bytes;\n\tsinfo->tx_packets = stats->tx_packets;\n\tsinfo->tx_failed = stats->tx_errors;\n\n\tif (test_bit(wil_vif_fwconnected, vif->status)) {\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_SIGNAL);\n\t\tif (test_bit(WMI_FW_CAPABILITY_RSSI_REPORTING,\n\t\t\t     wil->fw_capabilities))\n\t\t\tsinfo->signal = reply.evt.rssi;\n\t\telse\n\t\t\tsinfo->signal = reply.evt.sqi;\n\t}\n\n\treturn rc;\n}\n\nstatic int wil_cfg80211_get_station(struct wiphy *wiphy,\n\t\t\t\t    struct net_device *ndev,\n\t\t\t\t    const u8 *mac, struct station_info *sinfo)\n{\n\tstruct wil6210_vif *vif = ndev_to_vif(ndev);\n\tstruct wil6210_priv *wil = wiphy_to_wil(wiphy);\n\tint rc;\n\n\tint cid = wil_find_cid(wil, vif->mid, mac);\n\n\twil_dbg_misc(wil, \"get_station: %pM CID %d MID %d\\n\", mac, cid,\n\t\t     vif->mid);\n\tif (!wil_cid_valid(wil, cid))\n\t\treturn -ENOENT;\n\n\trc = wil_cid_fill_sinfo(vif, cid, sinfo);\n\n\treturn rc;\n}\n\n \nint wil_find_cid_by_idx(struct wil6210_priv *wil, u8 mid, int idx)\n{\n\tint i;\n\n\tfor (i = 0; i < wil->max_assoc_sta; i++) {\n\t\tif (wil->sta[i].status == wil_sta_unused)\n\t\t\tcontinue;\n\t\tif (wil->sta[i].mid != mid)\n\t\t\tcontinue;\n\t\tif (idx == 0)\n\t\t\treturn i;\n\t\tidx--;\n\t}\n\n\treturn -ENOENT;\n}\n\nstatic int wil_cfg80211_dump_station(struct wiphy *wiphy,\n\t\t\t\t     struct net_device *dev, int idx,\n\t\t\t\t     u8 *mac, struct station_info *sinfo)\n{\n\tstruct wil6210_vif *vif = ndev_to_vif(dev);\n\tstruct wil6210_priv *wil = wiphy_to_wil(wiphy);\n\tint rc;\n\tint cid = wil_find_cid_by_idx(wil, vif->mid, idx);\n\n\tif (!wil_cid_valid(wil, cid))\n\t\treturn -ENOENT;\n\n\tether_addr_copy(mac, wil->sta[cid].addr);\n\twil_dbg_misc(wil, \"dump_station: %pM CID %d MID %d\\n\", mac, cid,\n\t\t     vif->mid);\n\n\trc = wil_cid_fill_sinfo(vif, cid, sinfo);\n\n\treturn rc;\n}\n\nstatic int wil_cfg80211_start_p2p_device(struct wiphy *wiphy,\n\t\t\t\t\t struct wireless_dev *wdev)\n{\n\tstruct wil6210_priv *wil = wiphy_to_wil(wiphy);\n\n\twil_dbg_misc(wil, \"start_p2p_device: entered\\n\");\n\twil->p2p_dev_started = 1;\n\treturn 0;\n}\n\nstatic void wil_cfg80211_stop_p2p_device(struct wiphy *wiphy,\n\t\t\t\t\t struct wireless_dev *wdev)\n{\n\tstruct wil6210_priv *wil = wiphy_to_wil(wiphy);\n\n\tif (!wil->p2p_dev_started)\n\t\treturn;\n\n\twil_dbg_misc(wil, \"stop_p2p_device: entered\\n\");\n\tmutex_lock(&wil->mutex);\n\tmutex_lock(&wil->vif_mutex);\n\twil_p2p_stop_radio_operations(wil);\n\twil->p2p_dev_started = 0;\n\tmutex_unlock(&wil->vif_mutex);\n\tmutex_unlock(&wil->mutex);\n}\n\nstatic int wil_cfg80211_validate_add_iface(struct wil6210_priv *wil,\n\t\t\t\t\t   enum nl80211_iftype new_type)\n{\n\tint i;\n\tstruct wireless_dev *wdev;\n\tstruct iface_combination_params params = {\n\t\t.num_different_channels = 1,\n\t};\n\n\tfor (i = 0; i < GET_MAX_VIFS(wil); i++) {\n\t\tif (wil->vifs[i]) {\n\t\t\twdev = vif_to_wdev(wil->vifs[i]);\n\t\t\tparams.iftype_num[wdev->iftype]++;\n\t\t}\n\t}\n\tparams.iftype_num[new_type]++;\n\treturn cfg80211_check_combinations(wil->wiphy, &params);\n}\n\nstatic int wil_cfg80211_validate_change_iface(struct wil6210_priv *wil,\n\t\t\t\t\t      struct wil6210_vif *vif,\n\t\t\t\t\t      enum nl80211_iftype new_type)\n{\n\tint i, ret = 0;\n\tstruct wireless_dev *wdev;\n\tstruct iface_combination_params params = {\n\t\t.num_different_channels = 1,\n\t};\n\tbool check_combos = false;\n\n\tfor (i = 0; i < GET_MAX_VIFS(wil); i++) {\n\t\tstruct wil6210_vif *vif_pos = wil->vifs[i];\n\n\t\tif (vif_pos && vif != vif_pos) {\n\t\t\twdev = vif_to_wdev(vif_pos);\n\t\t\tparams.iftype_num[wdev->iftype]++;\n\t\t\tcheck_combos = true;\n\t\t}\n\t}\n\n\tif (check_combos) {\n\t\tparams.iftype_num[new_type]++;\n\t\tret = cfg80211_check_combinations(wil->wiphy, &params);\n\t}\n\treturn ret;\n}\n\nstatic struct wireless_dev *\nwil_cfg80211_add_iface(struct wiphy *wiphy, const char *name,\n\t\t       unsigned char name_assign_type,\n\t\t       enum nl80211_iftype type,\n\t\t       struct vif_params *params)\n{\n\tstruct wil6210_priv *wil = wiphy_to_wil(wiphy);\n\tstruct net_device *ndev_main = wil->main_ndev, *ndev;\n\tstruct wil6210_vif *vif;\n\tstruct wireless_dev *p2p_wdev, *wdev;\n\tint rc;\n\n\twil_dbg_misc(wil, \"add_iface, type %d\\n\", type);\n\n\t \n\tif (type == NL80211_IFTYPE_P2P_DEVICE) {\n\t\tif (wil->p2p_wdev) {\n\t\t\twil_err(wil, \"P2P_DEVICE interface already created\\n\");\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\n\t\tp2p_wdev = kzalloc(sizeof(*p2p_wdev), GFP_KERNEL);\n\t\tif (!p2p_wdev)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\tp2p_wdev->iftype = type;\n\t\tp2p_wdev->wiphy = wiphy;\n\t\t \n\t\tether_addr_copy(p2p_wdev->address, ndev_main->perm_addr);\n\n\t\twil->p2p_wdev = p2p_wdev;\n\n\t\treturn p2p_wdev;\n\t}\n\n\tif (!wil->wiphy->n_iface_combinations) {\n\t\twil_err(wil, \"virtual interfaces not supported\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\trc = wil_cfg80211_validate_add_iface(wil, type);\n\tif (rc) {\n\t\twil_err(wil, \"iface validation failed, err=%d\\n\", rc);\n\t\treturn ERR_PTR(rc);\n\t}\n\n\tvif = wil_vif_alloc(wil, name, name_assign_type, type);\n\tif (IS_ERR(vif))\n\t\treturn ERR_CAST(vif);\n\n\tndev = vif_to_ndev(vif);\n\tether_addr_copy(ndev->perm_addr, ndev_main->perm_addr);\n\tif (is_valid_ether_addr(params->macaddr)) {\n\t\teth_hw_addr_set(ndev, params->macaddr);\n\t} else {\n\t\tu8 addr[ETH_ALEN];\n\n\t\tether_addr_copy(addr, ndev_main->perm_addr);\n\t\taddr[0] = (addr[0] ^ (1 << vif->mid)) |\t0x2;  \n\t\teth_hw_addr_set(ndev, addr);\n\t}\n\twdev = vif_to_wdev(vif);\n\tether_addr_copy(wdev->address, ndev->dev_addr);\n\n\trc = wil_vif_add(wil, vif);\n\tif (rc)\n\t\tgoto out;\n\n\twil_info(wil, \"added VIF, mid %d iftype %d MAC %pM\\n\",\n\t\t vif->mid, type, wdev->address);\n\treturn wdev;\nout:\n\twil_vif_free(vif);\n\treturn ERR_PTR(rc);\n}\n\nint wil_vif_prepare_stop(struct wil6210_vif *vif)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tstruct wireless_dev *wdev = vif_to_wdev(vif);\n\tstruct net_device *ndev;\n\tint rc;\n\n\tif (wdev->iftype != NL80211_IFTYPE_AP)\n\t\treturn 0;\n\n\tndev = vif_to_ndev(vif);\n\tif (netif_carrier_ok(ndev)) {\n\t\trc = wmi_pcp_stop(vif);\n\t\tif (rc) {\n\t\t\twil_info(wil, \"failed to stop AP, status %d\\n\",\n\t\t\t\t rc);\n\t\t\t \n\t\t}\n\t\twil_bcast_fini(vif);\n\t\tnetif_carrier_off(ndev);\n\t}\n\n\treturn 0;\n}\n\nstatic int wil_cfg80211_del_iface(struct wiphy *wiphy,\n\t\t\t\t  struct wireless_dev *wdev)\n{\n\tstruct wil6210_priv *wil = wiphy_to_wil(wiphy);\n\tstruct wil6210_vif *vif = wdev_to_vif(wil, wdev);\n\tint rc;\n\n\twil_dbg_misc(wil, \"del_iface\\n\");\n\n\tif (wdev->iftype == NL80211_IFTYPE_P2P_DEVICE) {\n\t\tif (wdev != wil->p2p_wdev) {\n\t\t\twil_err(wil, \"delete of incorrect interface 0x%p\\n\",\n\t\t\t\twdev);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\twil_cfg80211_stop_p2p_device(wiphy, wdev);\n\t\twil_p2p_wdev_free(wil);\n\t\treturn 0;\n\t}\n\n\tif (vif->mid == 0) {\n\t\twil_err(wil, \"cannot remove the main interface\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trc = wil_vif_prepare_stop(vif);\n\tif (rc)\n\t\tgoto out;\n\n\twil_info(wil, \"deleted VIF, mid %d iftype %d MAC %pM\\n\",\n\t\t vif->mid, wdev->iftype, wdev->address);\n\n\twil_vif_remove(wil, vif->mid);\nout:\n\treturn rc;\n}\n\nstatic bool wil_is_safe_switch(enum nl80211_iftype from,\n\t\t\t       enum nl80211_iftype to)\n{\n\tif (from == NL80211_IFTYPE_STATION &&\n\t    to == NL80211_IFTYPE_P2P_CLIENT)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic int wil_cfg80211_change_iface(struct wiphy *wiphy,\n\t\t\t\t     struct net_device *ndev,\n\t\t\t\t     enum nl80211_iftype type,\n\t\t\t\t     struct vif_params *params)\n{\n\tstruct wil6210_priv *wil = wiphy_to_wil(wiphy);\n\tstruct wil6210_vif *vif = ndev_to_vif(ndev);\n\tstruct wireless_dev *wdev = vif_to_wdev(vif);\n\tint rc;\n\tbool fw_reset = false;\n\n\twil_dbg_misc(wil, \"change_iface: type=%d\\n\", type);\n\n\tif (wiphy->n_iface_combinations) {\n\t\trc = wil_cfg80211_validate_change_iface(wil, vif, type);\n\t\tif (rc) {\n\t\t\twil_err(wil, \"iface validation failed, err=%d\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\t \n\tif (!wil_has_other_active_ifaces(wil, ndev, true, false) &&\n\t    netif_running(ndev) && !wil_is_recovery_blocked(wil) &&\n\t    !wil_is_safe_switch(wdev->iftype, type)) {\n\t\twil_dbg_misc(wil, \"interface is up. resetting...\\n\");\n\t\tmutex_lock(&wil->mutex);\n\t\t__wil_down(wil);\n\t\trc = __wil_up(wil);\n\t\tmutex_unlock(&wil->mutex);\n\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tfw_reset = true;\n\t}\n\n\tswitch (type) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tbreak;\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tif (params->flags)\n\t\t\twil->monitor_flags = params->flags;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (vif->mid != 0 && wil_has_active_ifaces(wil, true, false)) {\n\t\tif (!fw_reset)\n\t\t\twil_vif_prepare_stop(vif);\n\t\trc = wmi_port_delete(wil, vif->mid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\trc = wmi_port_allocate(wil, vif->mid, ndev->dev_addr, type);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\twdev->iftype = type;\n\treturn 0;\n}\n\nstatic int wil_cfg80211_scan(struct wiphy *wiphy,\n\t\t\t     struct cfg80211_scan_request *request)\n{\n\tstruct wil6210_priv *wil = wiphy_to_wil(wiphy);\n\tstruct wireless_dev *wdev = request->wdev;\n\tstruct wil6210_vif *vif = wdev_to_vif(wil, wdev);\n\tstruct {\n\t\tstruct wmi_start_scan_cmd cmd;\n\t\tu16 chnl[4];\n\t} __packed cmd;\n\tuint i, n;\n\tint rc;\n\n\twil_dbg_misc(wil, \"scan: wdev=0x%p iftype=%d\\n\", wdev, wdev->iftype);\n\n\t \n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_P2P_DEVICE:\n\tcase NL80211_IFTYPE_AP:\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tif (test_bit(wil_status_dontscan, wil->status)) {\n\t\twil_err(wil, \"Can't scan now\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tmutex_lock(&wil->mutex);\n\n\tmutex_lock(&wil->vif_mutex);\n\tif (vif->scan_request || vif->p2p.discovery_started) {\n\t\twil_err(wil, \"Already scanning\\n\");\n\t\tmutex_unlock(&wil->vif_mutex);\n\t\trc = -EAGAIN;\n\t\tgoto out;\n\t}\n\tmutex_unlock(&wil->vif_mutex);\n\n\tif (wdev->iftype == NL80211_IFTYPE_P2P_DEVICE) {\n\t\tif (!wil->p2p_dev_started) {\n\t\t\twil_err(wil, \"P2P search requested on stopped P2P device\\n\");\n\t\t\trc = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\t \n\t\tif (wil_p2p_is_social_scan(request)) {\n\t\t\tvif->scan_request = request;\n\t\t\tif (vif->mid == 0)\n\t\t\t\twil->radio_wdev = wdev;\n\t\t\trc = wil_p2p_search(vif, request);\n\t\t\tif (rc) {\n\t\t\t\tif (vif->mid == 0)\n\t\t\t\t\twil->radio_wdev =\n\t\t\t\t\t\twil->main_ndev->ieee80211_ptr;\n\t\t\t\tvif->scan_request = NULL;\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t(void)wil_p2p_stop_discovery(vif);\n\n\twil_dbg_misc(wil, \"Start scan_request 0x%p\\n\", request);\n\twil_dbg_misc(wil, \"SSID count: %d\", request->n_ssids);\n\n\tfor (i = 0; i < request->n_ssids; i++) {\n\t\twil_dbg_misc(wil, \"SSID[%d]\", i);\n\t\twil_hex_dump_misc(\"SSID \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t\t  request->ssids[i].ssid,\n\t\t\t\t  request->ssids[i].ssid_len, true);\n\t}\n\n\tif (request->n_ssids)\n\t\trc = wmi_set_ssid(vif, request->ssids[0].ssid_len,\n\t\t\t\t  request->ssids[0].ssid);\n\telse\n\t\trc = wmi_set_ssid(vif, 0, NULL);\n\n\tif (rc) {\n\t\twil_err(wil, \"set SSID for scan request failed: %d\\n\", rc);\n\t\tgoto out;\n\t}\n\n\tvif->scan_request = request;\n\tmod_timer(&vif->scan_timer, jiffies + WIL6210_SCAN_TO);\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.cmd.scan_type = WMI_ACTIVE_SCAN;\n\tcmd.cmd.num_channels = 0;\n\tn = min(request->n_channels, 4U);\n\tfor (i = 0; i < n; i++) {\n\t\tint ch = request->channels[i]->hw_value;\n\n\t\tif (ch == 0) {\n\t\t\twil_err(wil,\n\t\t\t\t\"Scan requested for unknown frequency %dMhz\\n\",\n\t\t\t\trequest->channels[i]->center_freq);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tcmd.cmd.channel_list[cmd.cmd.num_channels++].channel = ch - 1;\n\t\twil_dbg_misc(wil, \"Scan for ch %d  : %d MHz\\n\", ch,\n\t\t\t     request->channels[i]->center_freq);\n\t}\n\n\tif (request->ie_len)\n\t\twil_hex_dump_misc(\"Scan IE \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t\t  request->ie, request->ie_len, true);\n\telse\n\t\twil_dbg_misc(wil, \"Scan has no IE's\\n\");\n\n\trc = wmi_set_ie(vif, WMI_FRAME_PROBE_REQ,\n\t\t\trequest->ie_len, request->ie);\n\tif (rc)\n\t\tgoto out_restore;\n\n\tif (wil->discovery_mode && cmd.cmd.scan_type == WMI_ACTIVE_SCAN) {\n\t\tcmd.cmd.discovery_mode = 1;\n\t\twil_dbg_misc(wil, \"active scan with discovery_mode=1\\n\");\n\t}\n\n\tif (vif->mid == 0)\n\t\twil->radio_wdev = wdev;\n\trc = wmi_send(wil, WMI_START_SCAN_CMDID, vif->mid,\n\t\t      &cmd, sizeof(cmd.cmd) +\n\t\t      cmd.cmd.num_channels * sizeof(cmd.cmd.channel_list[0]));\n\nout_restore:\n\tif (rc) {\n\t\tdel_timer_sync(&vif->scan_timer);\n\t\tif (vif->mid == 0)\n\t\t\twil->radio_wdev = wil->main_ndev->ieee80211_ptr;\n\t\tvif->scan_request = NULL;\n\t}\nout:\n\tmutex_unlock(&wil->mutex);\n\treturn rc;\n}\n\nstatic void wil_cfg80211_abort_scan(struct wiphy *wiphy,\n\t\t\t\t    struct wireless_dev *wdev)\n{\n\tstruct wil6210_priv *wil = wiphy_to_wil(wiphy);\n\tstruct wil6210_vif *vif = wdev_to_vif(wil, wdev);\n\n\twil_dbg_misc(wil, \"wdev=0x%p iftype=%d\\n\", wdev, wdev->iftype);\n\n\tmutex_lock(&wil->mutex);\n\tmutex_lock(&wil->vif_mutex);\n\n\tif (!vif->scan_request)\n\t\tgoto out;\n\n\tif (wdev != vif->scan_request->wdev) {\n\t\twil_dbg_misc(wil, \"abort scan was called on the wrong iface\\n\");\n\t\tgoto out;\n\t}\n\n\tif (wdev == wil->p2p_wdev && wil->radio_wdev == wil->p2p_wdev)\n\t\twil_p2p_stop_radio_operations(wil);\n\telse\n\t\twil_abort_scan(vif, true);\n\nout:\n\tmutex_unlock(&wil->vif_mutex);\n\tmutex_unlock(&wil->mutex);\n}\n\nstatic void wil_print_crypto(struct wil6210_priv *wil,\n\t\t\t     struct cfg80211_crypto_settings *c)\n{\n\tint i, n;\n\n\twil_dbg_misc(wil, \"WPA versions: 0x%08x cipher group 0x%08x\\n\",\n\t\t     c->wpa_versions, c->cipher_group);\n\twil_dbg_misc(wil, \"Pairwise ciphers [%d] {\\n\", c->n_ciphers_pairwise);\n\tn = min_t(int, c->n_ciphers_pairwise, ARRAY_SIZE(c->ciphers_pairwise));\n\tfor (i = 0; i < n; i++)\n\t\twil_dbg_misc(wil, \"  [%d] = 0x%08x\\n\", i,\n\t\t\t     c->ciphers_pairwise[i]);\n\twil_dbg_misc(wil, \"}\\n\");\n\twil_dbg_misc(wil, \"AKM suites [%d] {\\n\", c->n_akm_suites);\n\tn = min_t(int, c->n_akm_suites, ARRAY_SIZE(c->akm_suites));\n\tfor (i = 0; i < n; i++)\n\t\twil_dbg_misc(wil, \"  [%d] = 0x%08x\\n\", i,\n\t\t\t     c->akm_suites[i]);\n\twil_dbg_misc(wil, \"}\\n\");\n\twil_dbg_misc(wil, \"Control port : %d, eth_type 0x%04x no_encrypt %d\\n\",\n\t\t     c->control_port, be16_to_cpu(c->control_port_ethertype),\n\t\t     c->control_port_no_encrypt);\n}\n\nstatic const char *\nwil_get_auth_type_name(enum nl80211_auth_type auth_type)\n{\n\tswitch (auth_type) {\n\tcase NL80211_AUTHTYPE_OPEN_SYSTEM:\n\t\treturn \"OPEN_SYSTEM\";\n\tcase NL80211_AUTHTYPE_SHARED_KEY:\n\t\treturn \"SHARED_KEY\";\n\tcase NL80211_AUTHTYPE_FT:\n\t\treturn \"FT\";\n\tcase NL80211_AUTHTYPE_NETWORK_EAP:\n\t\treturn \"NETWORK_EAP\";\n\tcase NL80211_AUTHTYPE_SAE:\n\t\treturn \"SAE\";\n\tcase NL80211_AUTHTYPE_AUTOMATIC:\n\t\treturn \"AUTOMATIC\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\nstatic void wil_print_connect_params(struct wil6210_priv *wil,\n\t\t\t\t     struct cfg80211_connect_params *sme)\n{\n\twil_info(wil, \"Connecting to:\\n\");\n\tif (sme->channel) {\n\t\twil_info(wil, \"  Channel: %d freq %d\\n\",\n\t\t\t sme->channel->hw_value, sme->channel->center_freq);\n\t}\n\tif (sme->bssid)\n\t\twil_info(wil, \"  BSSID: %pM\\n\", sme->bssid);\n\tif (sme->ssid)\n\t\tprint_hex_dump(KERN_INFO, \"  SSID: \", DUMP_PREFIX_OFFSET,\n\t\t\t       16, 1, sme->ssid, sme->ssid_len, true);\n\tif (sme->prev_bssid)\n\t\twil_info(wil, \"  Previous BSSID=%pM\\n\", sme->prev_bssid);\n\twil_info(wil, \"  Auth Type: %s\\n\",\n\t\t wil_get_auth_type_name(sme->auth_type));\n\twil_info(wil, \"  Privacy: %s\\n\", sme->privacy ? \"secure\" : \"open\");\n\twil_info(wil, \"  PBSS: %d\\n\", sme->pbss);\n\twil_print_crypto(wil, &sme->crypto);\n}\n\nstatic int wil_ft_connect(struct wiphy *wiphy,\n\t\t\t  struct net_device *ndev,\n\t\t\t  struct cfg80211_connect_params *sme)\n{\n\tstruct wil6210_priv *wil = wiphy_to_wil(wiphy);\n\tstruct wil6210_vif *vif = ndev_to_vif(ndev);\n\tstruct wmi_ft_auth_cmd auth_cmd;\n\tint rc;\n\n\tif (!test_bit(WMI_FW_CAPABILITY_FT_ROAMING, wil->fw_capabilities)) {\n\t\twil_err(wil, \"FT: FW does not support FT roaming\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!sme->prev_bssid) {\n\t\twil_err(wil, \"FT: prev_bssid was not set\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ether_addr_equal(sme->prev_bssid, sme->bssid)) {\n\t\twil_err(wil, \"FT: can not roam to same AP\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!test_bit(wil_vif_fwconnected, vif->status)) {\n\t\twil_err(wil, \"FT: roam while not connected\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (vif->privacy != sme->privacy) {\n\t\twil_err(wil, \"FT: privacy mismatch, current (%d) roam (%d)\\n\",\n\t\t\tvif->privacy, sme->privacy);\n\t\treturn -EINVAL;\n\t}\n\n\tif (sme->pbss) {\n\t\twil_err(wil, \"FT: roam is not valid for PBSS\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(&auth_cmd, 0, sizeof(auth_cmd));\n\tauth_cmd.channel = sme->channel->hw_value - 1;\n\tether_addr_copy(auth_cmd.bssid, sme->bssid);\n\n\twil_info(wil, \"FT: roaming\\n\");\n\n\tset_bit(wil_vif_ft_roam, vif->status);\n\trc = wmi_send(wil, WMI_FT_AUTH_CMDID, vif->mid,\n\t\t      &auth_cmd, sizeof(auth_cmd));\n\tif (rc == 0)\n\t\tmod_timer(&vif->connect_timer,\n\t\t\t  jiffies + msecs_to_jiffies(5000));\n\telse\n\t\tclear_bit(wil_vif_ft_roam, vif->status);\n\n\treturn rc;\n}\n\nstatic int wil_get_wmi_edmg_channel(struct wil6210_priv *wil, u8 edmg_bw_config,\n\t\t\t\t    u8 edmg_channels, u8 *wmi_ch)\n{\n\tif (!edmg_bw_config) {\n\t\t*wmi_ch = 0;\n\t\treturn 0;\n\t} else if (edmg_bw_config == WIL_EDMG_BW_CONFIGURATION) {\n\t\t \n\t\tswitch (edmg_channels) {\n\t\tcase WIL_EDMG_CHANNEL_9_SUBCHANNELS:\n\t\t\treturn wil_spec2wmi_ch(9, wmi_ch);\n\t\tcase WIL_EDMG_CHANNEL_10_SUBCHANNELS:\n\t\t\treturn wil_spec2wmi_ch(10, wmi_ch);\n\t\tcase WIL_EDMG_CHANNEL_11_SUBCHANNELS:\n\t\t\treturn wil_spec2wmi_ch(11, wmi_ch);\n\t\tdefault:\n\t\t\twil_err(wil, \"Unsupported edmg channel bitmap 0x%x\\n\",\n\t\t\t\tedmg_channels);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\twil_err(wil, \"Unsupported EDMG BW configuration %d\\n\",\n\t\t\tedmg_bw_config);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int wil_cfg80211_connect(struct wiphy *wiphy,\n\t\t\t\tstruct net_device *ndev,\n\t\t\t\tstruct cfg80211_connect_params *sme)\n{\n\tstruct wil6210_priv *wil = wiphy_to_wil(wiphy);\n\tstruct wil6210_vif *vif = ndev_to_vif(ndev);\n\tstruct cfg80211_bss *bss;\n\tstruct wmi_connect_cmd conn;\n\tconst u8 *ssid_eid;\n\tconst u8 *rsn_eid;\n\tint ch;\n\tint rc = 0;\n\tbool is_ft_roam = false;\n\tu8 network_type;\n\tenum ieee80211_bss_type bss_type = IEEE80211_BSS_TYPE_ESS;\n\n\twil_dbg_misc(wil, \"connect, mid=%d\\n\", vif->mid);\n\twil_print_connect_params(wil, sme);\n\n\tif (sme->auth_type == NL80211_AUTHTYPE_FT)\n\t\tis_ft_roam = true;\n\tif (sme->auth_type == NL80211_AUTHTYPE_AUTOMATIC &&\n\t    test_bit(wil_vif_fwconnected, vif->status))\n\t\tis_ft_roam = true;\n\n\tif (!is_ft_roam)\n\t\tif (test_bit(wil_vif_fwconnecting, vif->status) ||\n\t\t    test_bit(wil_vif_fwconnected, vif->status))\n\t\t\treturn -EALREADY;\n\n\tif (sme->ie_len > WMI_MAX_IE_LEN) {\n\t\twil_err(wil, \"IE too large (%td bytes)\\n\", sme->ie_len);\n\t\treturn -ERANGE;\n\t}\n\n\trsn_eid = sme->ie ?\n\t\t\tcfg80211_find_ie(WLAN_EID_RSN, sme->ie, sme->ie_len) :\n\t\t\tNULL;\n\tif (sme->privacy && !rsn_eid) {\n\t\twil_info(wil, \"WSC connection\\n\");\n\t\tif (is_ft_roam) {\n\t\t\twil_err(wil, \"No WSC with FT roam\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (sme->pbss)\n\t\tbss_type = IEEE80211_BSS_TYPE_PBSS;\n\n\tbss = cfg80211_get_bss(wiphy, sme->channel, sme->bssid,\n\t\t\t       sme->ssid, sme->ssid_len,\n\t\t\t       bss_type, IEEE80211_PRIVACY_ANY);\n\tif (!bss) {\n\t\twil_err(wil, \"Unable to find BSS\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tssid_eid = ieee80211_bss_get_ie(bss, WLAN_EID_SSID);\n\tif (!ssid_eid) {\n\t\twil_err(wil, \"No SSID\\n\");\n\t\trc = -ENOENT;\n\t\tgoto out;\n\t}\n\tvif->privacy = sme->privacy;\n\tvif->pbss = sme->pbss;\n\n\trc = wmi_set_ie(vif, WMI_FRAME_ASSOC_REQ, sme->ie_len, sme->ie);\n\tif (rc)\n\t\tgoto out;\n\n\tswitch (bss->capability & WLAN_CAPABILITY_DMG_TYPE_MASK) {\n\tcase WLAN_CAPABILITY_DMG_TYPE_AP:\n\t\tnetwork_type = WMI_NETTYPE_INFRA;\n\t\tbreak;\n\tcase WLAN_CAPABILITY_DMG_TYPE_PBSS:\n\t\tnetwork_type = WMI_NETTYPE_P2P;\n\t\tbreak;\n\tdefault:\n\t\twil_err(wil, \"Unsupported BSS type, capability= 0x%04x\\n\",\n\t\t\tbss->capability);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tch = bss->channel->hw_value;\n\tif (ch == 0) {\n\t\twil_err(wil, \"BSS at unknown frequency %dMhz\\n\",\n\t\t\tbss->channel->center_freq);\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (is_ft_roam) {\n\t\tif (network_type != WMI_NETTYPE_INFRA) {\n\t\t\twil_err(wil, \"FT: Unsupported BSS type, capability= 0x%04x\\n\",\n\t\t\t\tbss->capability);\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\trc = wil_ft_connect(wiphy, ndev, sme);\n\t\tif (rc == 0)\n\t\t\tvif->bss = bss;\n\t\tgoto out;\n\t}\n\n\tif (vif->privacy) {\n\t\t \n\t\trc = wmi_del_cipher_key(vif, 0, bss->bssid,\n\t\t\t\t\tWMI_KEY_USE_PAIRWISE);\n\t\tif (rc) {\n\t\t\twil_err(wil, \"WMI_DELETE_CIPHER_KEY_CMD(PTK) failed\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\trc = wmi_del_cipher_key(vif, 0, bss->bssid,\n\t\t\t\t\tWMI_KEY_USE_RX_GROUP);\n\t\tif (rc) {\n\t\t\twil_err(wil, \"WMI_DELETE_CIPHER_KEY_CMD(GTK) failed\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tmemset(&conn, 0, sizeof(conn));\n\tconn.network_type = network_type;\n\tif (vif->privacy) {\n\t\tif (rsn_eid) {  \n\t\t\tconn.dot11_auth_mode = WMI_AUTH11_SHARED;\n\t\t\tconn.auth_mode = WMI_AUTH_WPA2_PSK;\n\t\t\tconn.pairwise_crypto_type = WMI_CRYPT_AES_GCMP;\n\t\t\tconn.pairwise_crypto_len = 16;\n\t\t\tconn.group_crypto_type = WMI_CRYPT_AES_GCMP;\n\t\t\tconn.group_crypto_len = 16;\n\t\t} else {  \n\t\t\tconn.dot11_auth_mode = WMI_AUTH11_WSC;\n\t\t\tconn.auth_mode = WMI_AUTH_NONE;\n\t\t}\n\t} else {  \n\t\tconn.dot11_auth_mode = WMI_AUTH11_OPEN;\n\t\tconn.auth_mode = WMI_AUTH_NONE;\n\t}\n\n\tconn.ssid_len = min_t(u8, ssid_eid[1], 32);\n\tmemcpy(conn.ssid, ssid_eid+2, conn.ssid_len);\n\tconn.channel = ch - 1;\n\n\trc = wil_get_wmi_edmg_channel(wil, sme->edmg.bw_config,\n\t\t\t\t      sme->edmg.channels, &conn.edmg_channel);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tether_addr_copy(conn.bssid, bss->bssid);\n\tether_addr_copy(conn.dst_mac, bss->bssid);\n\n\tset_bit(wil_vif_fwconnecting, vif->status);\n\n\trc = wmi_send(wil, WMI_CONNECT_CMDID, vif->mid, &conn, sizeof(conn));\n\tif (rc == 0) {\n\t\tnetif_carrier_on(ndev);\n\t\tif (!wil_has_other_active_ifaces(wil, ndev, false, true))\n\t\t\twil6210_bus_request(wil, WIL_MAX_BUS_REQUEST_KBPS);\n\t\tvif->bss = bss;\n\t\t \n\t\tmod_timer(&vif->connect_timer,\n\t\t\t  jiffies + msecs_to_jiffies(5000));\n\t} else {\n\t\tclear_bit(wil_vif_fwconnecting, vif->status);\n\t}\n\n out:\n\tcfg80211_put_bss(wiphy, bss);\n\n\treturn rc;\n}\n\nstatic int wil_cfg80211_disconnect(struct wiphy *wiphy,\n\t\t\t\t   struct net_device *ndev,\n\t\t\t\t   u16 reason_code)\n{\n\tint rc;\n\tstruct wil6210_priv *wil = wiphy_to_wil(wiphy);\n\tstruct wil6210_vif *vif = ndev_to_vif(ndev);\n\n\twil_dbg_misc(wil, \"disconnect: reason=%d, mid=%d\\n\",\n\t\t     reason_code, vif->mid);\n\n\tif (!(test_bit(wil_vif_fwconnecting, vif->status) ||\n\t      test_bit(wil_vif_fwconnected, vif->status))) {\n\t\twil_err(wil, \"Disconnect was called while disconnected\\n\");\n\t\treturn 0;\n\t}\n\n\tvif->locally_generated_disc = true;\n\trc = wmi_call(wil, WMI_DISCONNECT_CMDID, vif->mid, NULL, 0,\n\t\t      WMI_DISCONNECT_EVENTID, NULL, 0,\n\t\t      WIL6210_DISCONNECT_TO_MS);\n\tif (rc)\n\t\twil_err(wil, \"disconnect error %d\\n\", rc);\n\n\treturn rc;\n}\n\nstatic int wil_cfg80211_set_wiphy_params(struct wiphy *wiphy, u32 changed)\n{\n\tstruct wil6210_priv *wil = wiphy_to_wil(wiphy);\n\tint rc;\n\n\t \n\tif (changed & (WIPHY_PARAM_RETRY_LONG |\n\t\t       WIPHY_PARAM_FRAG_THRESHOLD |\n\t\t       WIPHY_PARAM_RTS_THRESHOLD))\n\t\treturn -ENOTSUPP;\n\n\tif (changed & WIPHY_PARAM_RETRY_SHORT) {\n\t\trc = wmi_set_mgmt_retry(wil, wiphy->retry_short);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nint wil_cfg80211_mgmt_tx(struct wiphy *wiphy, struct wireless_dev *wdev,\n\t\t\t struct cfg80211_mgmt_tx_params *params,\n\t\t\t u64 *cookie)\n{\n\tconst u8 *buf = params->buf;\n\tsize_t len = params->len;\n\tstruct wil6210_priv *wil = wiphy_to_wil(wiphy);\n\tstruct wil6210_vif *vif = wdev_to_vif(wil, wdev);\n\tint rc;\n\tbool tx_status;\n\n\twil_dbg_misc(wil, \"mgmt_tx: channel %d offchan %d, wait %d\\n\",\n\t\t     params->chan ? params->chan->hw_value : -1,\n\t\t     params->offchan,\n\t\t     params->wait);\n\n\t \n\n\tif (params->chan && params->chan->hw_value == 0) {\n\t\twil_err(wil, \"invalid channel\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (wdev->iftype != NL80211_IFTYPE_AP) {\n\t\twil_dbg_misc(wil,\n\t\t\t     \"send WMI_SW_TX_REQ_CMDID on non-AP interfaces\\n\");\n\t\trc = wmi_mgmt_tx(vif, buf, len);\n\t\tgoto out;\n\t}\n\n\tif (!params->chan || params->chan->hw_value == vif->channel) {\n\t\twil_dbg_misc(wil,\n\t\t\t     \"send WMI_SW_TX_REQ_CMDID for on-channel\\n\");\n\t\trc = wmi_mgmt_tx(vif, buf, len);\n\t\tgoto out;\n\t}\n\n\tif (params->offchan == 0) {\n\t\twil_err(wil,\n\t\t\t\"invalid channel params: current %d requested %d, off-channel not allowed\\n\",\n\t\t\tvif->channel, params->chan->hw_value);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\trc = wmi_mgmt_tx_ext(vif, buf, len, params->chan->hw_value,\n\t\t\t     params->wait);\n\nout:\n\t \n\ttx_status = (rc == 0);\n\trc = (rc == -EAGAIN) ? 0 : rc;\n\tcfg80211_mgmt_tx_status(wdev, cookie ? *cookie : 0, buf, len,\n\t\t\t\ttx_status, GFP_KERNEL);\n\n\treturn rc;\n}\n\nstatic int wil_cfg80211_set_channel(struct wiphy *wiphy,\n\t\t\t\t    struct cfg80211_chan_def *chandef)\n{\n\tstruct wil6210_priv *wil = wiphy_to_wil(wiphy);\n\n\twil->monitor_chandef = *chandef;\n\n\treturn 0;\n}\n\nstatic enum wmi_key_usage wil_detect_key_usage(struct wireless_dev *wdev,\n\t\t\t\t\t       bool pairwise)\n{\n\tstruct wil6210_priv *wil = wdev_to_wil(wdev);\n\tenum wmi_key_usage rc;\n\n\tif (pairwise) {\n\t\trc = WMI_KEY_USE_PAIRWISE;\n\t} else {\n\t\tswitch (wdev->iftype) {\n\t\tcase NL80211_IFTYPE_STATION:\n\t\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\t\trc = WMI_KEY_USE_RX_GROUP;\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_AP:\n\t\tcase NL80211_IFTYPE_P2P_GO:\n\t\t\trc = WMI_KEY_USE_TX_GROUP;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\twil_err(wil, \"Can't determine GTK type\\n\");\n\t\t\trc = WMI_KEY_USE_RX_GROUP;\n\t\t\tbreak;\n\t\t}\n\t}\n\twil_dbg_misc(wil, \"detect_key_usage: -> %s\\n\", key_usage_str[rc]);\n\n\treturn rc;\n}\n\nstatic struct wil_sta_info *\nwil_find_sta_by_key_usage(struct wil6210_priv *wil, u8 mid,\n\t\t\t  enum wmi_key_usage key_usage, const u8 *mac_addr)\n{\n\tint cid = -EINVAL;\n\n\tif (key_usage == WMI_KEY_USE_TX_GROUP)\n\t\treturn NULL;  \n\n\t \n\tif (mac_addr)\n\t\tcid = wil_find_cid(wil, mid, mac_addr);\n\telse if (key_usage == WMI_KEY_USE_RX_GROUP)\n\t\tcid = wil_find_cid_by_idx(wil, mid, 0);\n\tif (cid < 0) {\n\t\twil_err(wil, \"No CID for %pM %s\\n\", mac_addr,\n\t\t\tkey_usage_str[key_usage]);\n\t\treturn ERR_PTR(cid);\n\t}\n\n\treturn &wil->sta[cid];\n}\n\nvoid wil_set_crypto_rx(u8 key_index, enum wmi_key_usage key_usage,\n\t\t       struct wil_sta_info *cs,\n\t\t       struct key_params *params)\n{\n\tstruct wil_tid_crypto_rx_single *cc;\n\tint tid;\n\n\tif (!cs)\n\t\treturn;\n\n\tswitch (key_usage) {\n\tcase WMI_KEY_USE_STORE_PTK:\n\tcase WMI_KEY_USE_PAIRWISE:\n\t\tfor (tid = 0; tid < WIL_STA_TID_NUM; tid++) {\n\t\t\tcc = &cs->tid_crypto_rx[tid].key_id[key_index];\n\t\t\tif (params->seq)\n\t\t\t\tmemcpy(cc->pn, params->seq,\n\t\t\t\t       IEEE80211_GCMP_PN_LEN);\n\t\t\telse\n\t\t\t\tmemset(cc->pn, 0, IEEE80211_GCMP_PN_LEN);\n\t\t\tcc->key_set = true;\n\t\t}\n\t\tbreak;\n\tcase WMI_KEY_USE_RX_GROUP:\n\t\tcc = &cs->group_crypto_rx.key_id[key_index];\n\t\tif (params->seq)\n\t\t\tmemcpy(cc->pn, params->seq, IEEE80211_GCMP_PN_LEN);\n\t\telse\n\t\t\tmemset(cc->pn, 0, IEEE80211_GCMP_PN_LEN);\n\t\tcc->key_set = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void wil_del_rx_key(u8 key_index, enum wmi_key_usage key_usage,\n\t\t\t   struct wil_sta_info *cs)\n{\n\tstruct wil_tid_crypto_rx_single *cc;\n\tint tid;\n\n\tif (!cs)\n\t\treturn;\n\n\tswitch (key_usage) {\n\tcase WMI_KEY_USE_PAIRWISE:\n\t\tfor (tid = 0; tid < WIL_STA_TID_NUM; tid++) {\n\t\t\tcc = &cs->tid_crypto_rx[tid].key_id[key_index];\n\t\t\tcc->key_set = false;\n\t\t}\n\t\tbreak;\n\tcase WMI_KEY_USE_RX_GROUP:\n\t\tcc = &cs->group_crypto_rx.key_id[key_index];\n\t\tcc->key_set = false;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int wil_cfg80211_add_key(struct wiphy *wiphy,\n\t\t\t\tstruct net_device *ndev, int link_id,\n\t\t\t\tu8 key_index, bool pairwise,\n\t\t\t\tconst u8 *mac_addr,\n\t\t\t\tstruct key_params *params)\n{\n\tint rc;\n\tstruct wil6210_vif *vif = ndev_to_vif(ndev);\n\tstruct wil6210_priv *wil = wiphy_to_wil(wiphy);\n\tstruct wireless_dev *wdev = vif_to_wdev(vif);\n\tenum wmi_key_usage key_usage = wil_detect_key_usage(wdev, pairwise);\n\tstruct wil_sta_info *cs = wil_find_sta_by_key_usage(wil, vif->mid,\n\t\t\t\t\t\t\t    key_usage,\n\t\t\t\t\t\t\t    mac_addr);\n\n\tif (!params) {\n\t\twil_err(wil, \"NULL params\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\twil_dbg_misc(wil, \"add_key: %pM %s[%d] PN %*phN\\n\",\n\t\t     mac_addr, key_usage_str[key_usage], key_index,\n\t\t     params->seq_len, params->seq);\n\n\tif (IS_ERR(cs)) {\n\t\t \n\t\tif (!test_bit(wil_vif_ft_roam, vif->status)) {\n\t\t\twil_err(wil, \"Not connected, %pM %s[%d] PN %*phN\\n\",\n\t\t\t\tmac_addr, key_usage_str[key_usage], key_index,\n\t\t\t\tparams->seq_len, params->seq);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\twil_del_rx_key(key_index, key_usage, cs);\n\t}\n\n\tif (params->seq && params->seq_len != IEEE80211_GCMP_PN_LEN) {\n\t\twil_err(wil,\n\t\t\t\"Wrong PN len %d, %pM %s[%d] PN %*phN\\n\",\n\t\t\tparams->seq_len, mac_addr,\n\t\t\tkey_usage_str[key_usage], key_index,\n\t\t\tparams->seq_len, params->seq);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_bh(&wil->eap_lock);\n\tif (pairwise && wdev->iftype == NL80211_IFTYPE_STATION &&\n\t    (vif->ptk_rekey_state == WIL_REKEY_M3_RECEIVED ||\n\t     vif->ptk_rekey_state == WIL_REKEY_WAIT_M4_SENT)) {\n\t\tkey_usage = WMI_KEY_USE_STORE_PTK;\n\t\tvif->ptk_rekey_state = WIL_REKEY_WAIT_M4_SENT;\n\t\twil_dbg_misc(wil, \"Store EAPOL key\\n\");\n\t}\n\tspin_unlock_bh(&wil->eap_lock);\n\n\trc = wmi_add_cipher_key(vif, key_index, mac_addr, params->key_len,\n\t\t\t\tparams->key, key_usage);\n\tif (!rc && !IS_ERR(cs)) {\n\t\t \n\t\tif (key_usage == WMI_KEY_USE_TX_GROUP && params->key &&\n\t\t    params->key_len <= WMI_MAX_KEY_LEN) {\n\t\t\tvif->gtk_index = key_index;\n\t\t\tmemcpy(vif->gtk, params->key, params->key_len);\n\t\t\tvif->gtk_len = params->key_len;\n\t\t}\n\t\t \n\t\twil_set_crypto_rx(key_index, key_usage, cs, params);\n\t}\n\n\treturn rc;\n}\n\nstatic int wil_cfg80211_del_key(struct wiphy *wiphy,\n\t\t\t\tstruct net_device *ndev, int link_id,\n\t\t\t\tu8 key_index, bool pairwise,\n\t\t\t\tconst u8 *mac_addr)\n{\n\tstruct wil6210_vif *vif = ndev_to_vif(ndev);\n\tstruct wil6210_priv *wil = wiphy_to_wil(wiphy);\n\tstruct wireless_dev *wdev = vif_to_wdev(vif);\n\tenum wmi_key_usage key_usage = wil_detect_key_usage(wdev, pairwise);\n\tstruct wil_sta_info *cs = wil_find_sta_by_key_usage(wil, vif->mid,\n\t\t\t\t\t\t\t    key_usage,\n\t\t\t\t\t\t\t    mac_addr);\n\n\twil_dbg_misc(wil, \"del_key: %pM %s[%d]\\n\", mac_addr,\n\t\t     key_usage_str[key_usage], key_index);\n\n\tif (IS_ERR(cs))\n\t\twil_info(wil, \"Not connected, %pM %s[%d]\\n\",\n\t\t\t mac_addr, key_usage_str[key_usage], key_index);\n\n\tif (!IS_ERR_OR_NULL(cs))\n\t\twil_del_rx_key(key_index, key_usage, cs);\n\n\treturn wmi_del_cipher_key(vif, key_index, mac_addr, key_usage);\n}\n\n \nstatic int wil_cfg80211_set_default_key(struct wiphy *wiphy,\n\t\t\t\t\tstruct net_device *ndev, int link_id,\n\t\t\t\t\tu8 key_index, bool unicast,\n\t\t\t\t\tbool multicast)\n{\n\tstruct wil6210_priv *wil = wiphy_to_wil(wiphy);\n\n\twil_dbg_misc(wil, \"set_default_key: entered\\n\");\n\treturn 0;\n}\n\nstatic int wil_remain_on_channel(struct wiphy *wiphy,\n\t\t\t\t struct wireless_dev *wdev,\n\t\t\t\t struct ieee80211_channel *chan,\n\t\t\t\t unsigned int duration,\n\t\t\t\t u64 *cookie)\n{\n\tstruct wil6210_priv *wil = wiphy_to_wil(wiphy);\n\tint rc;\n\n\twil_dbg_misc(wil,\n\t\t     \"remain_on_channel: center_freq=%d, duration=%d iftype=%d\\n\",\n\t\t     chan->center_freq, duration, wdev->iftype);\n\n\trc = wil_p2p_listen(wil, wdev, duration, chan, cookie);\n\treturn rc;\n}\n\nstatic int wil_cancel_remain_on_channel(struct wiphy *wiphy,\n\t\t\t\t\tstruct wireless_dev *wdev,\n\t\t\t\t\tu64 cookie)\n{\n\tstruct wil6210_priv *wil = wiphy_to_wil(wiphy);\n\tstruct wil6210_vif *vif = wdev_to_vif(wil, wdev);\n\n\twil_dbg_misc(wil, \"cancel_remain_on_channel\\n\");\n\n\treturn wil_p2p_cancel_listen(vif, cookie);\n}\n\n \nstatic const u8 *_wil_cfg80211_find_ie(const u8 *ies, u16 ies_len, const u8 *ie,\n\t\t\t\t       u16 ie_len)\n{\n\tstruct ieee80211_vendor_ie *vie;\n\tu32 oui;\n\n\t \n\tif (ie_len < 2 || 2 + ie[1] > ie_len)\n\t\treturn NULL;\n\n\tif (ie[0] != WLAN_EID_VENDOR_SPECIFIC)\n\t\treturn cfg80211_find_ie(ie[0], ies, ies_len);\n\n\t \n\tif (ie[1] < 4)\n\t\treturn NULL;\n\tvie = (struct ieee80211_vendor_ie *)ie;\n\toui = vie->oui[0] << 16 | vie->oui[1] << 8 | vie->oui[2];\n\treturn cfg80211_find_vendor_ie(oui, vie->oui_type, ies,\n\t\t\t\t       ies_len);\n}\n\n \nstatic int _wil_cfg80211_merge_extra_ies(const u8 *ies1, u16 ies1_len,\n\t\t\t\t\t const u8 *ies2, u16 ies2_len,\n\t\t\t\t\t u8 **merged_ies, u16 *merged_len)\n{\n\tu8 *buf, *dpos;\n\tconst u8 *spos;\n\n\tif (!ies1)\n\t\ties1_len = 0;\n\n\tif (!ies2)\n\t\ties2_len = 0;\n\n\tif (ies1_len == 0 && ies2_len == 0) {\n\t\t*merged_ies = NULL;\n\t\t*merged_len = 0;\n\t\treturn 0;\n\t}\n\n\tbuf = kmalloc(ies1_len + ies2_len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tif (ies1)\n\t\tmemcpy(buf, ies1, ies1_len);\n\tdpos = buf + ies1_len;\n\tspos = ies2;\n\twhile (spos && (spos + 1 < ies2 + ies2_len)) {\n\t\t \n\t\tu16 ielen = 2 + spos[1];\n\n\t\tif (spos + ielen > ies2 + ies2_len)\n\t\t\tbreak;\n\t\tif (spos[0] == WLAN_EID_VENDOR_SPECIFIC &&\n\t\t    (!ies1 || !_wil_cfg80211_find_ie(ies1, ies1_len,\n\t\t\t\t\t\t     spos, ielen))) {\n\t\t\tmemcpy(dpos, spos, ielen);\n\t\t\tdpos += ielen;\n\t\t}\n\t\tspos += ielen;\n\t}\n\n\t*merged_ies = buf;\n\t*merged_len = dpos - buf;\n\treturn 0;\n}\n\nstatic void wil_print_bcon_data(struct cfg80211_beacon_data *b)\n{\n\twil_hex_dump_misc(\"head     \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t  b->head, b->head_len, true);\n\twil_hex_dump_misc(\"tail     \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t  b->tail, b->tail_len, true);\n\twil_hex_dump_misc(\"BCON IE  \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t  b->beacon_ies, b->beacon_ies_len, true);\n\twil_hex_dump_misc(\"PROBE    \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t  b->probe_resp, b->probe_resp_len, true);\n\twil_hex_dump_misc(\"PROBE IE \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t  b->proberesp_ies, b->proberesp_ies_len, true);\n\twil_hex_dump_misc(\"ASSOC IE \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t  b->assocresp_ies, b->assocresp_ies_len, true);\n}\n\n \nstatic u8 *\n_wil_cfg80211_get_proberesp_ies(const u8 *proberesp, u16 proberesp_len,\n\t\t\t\tu16 *ies_len)\n{\n\tu8 *ies = NULL;\n\n\tif (proberesp) {\n\t\tstruct ieee80211_mgmt *f =\n\t\t\t(struct ieee80211_mgmt *)proberesp;\n\t\tsize_t hlen = offsetof(struct ieee80211_mgmt,\n\t\t\t\t       u.probe_resp.variable);\n\n\t\ties = f->u.probe_resp.variable;\n\t\tif (ies_len)\n\t\t\t*ies_len = proberesp_len - hlen;\n\t}\n\n\treturn ies;\n}\n\nstatic int _wil_cfg80211_set_ies(struct wil6210_vif *vif,\n\t\t\t\t struct cfg80211_beacon_data *bcon)\n{\n\tint rc;\n\tu16 len = 0, proberesp_len = 0;\n\tu8 *ies = NULL, *proberesp;\n\n\t \n\twil_memdup_ie(&vif->proberesp, &vif->proberesp_len, bcon->probe_resp,\n\t\t      bcon->probe_resp_len);\n\twil_memdup_ie(&vif->proberesp_ies, &vif->proberesp_ies_len,\n\t\t      bcon->proberesp_ies, bcon->proberesp_ies_len);\n\twil_memdup_ie(&vif->assocresp_ies, &vif->assocresp_ies_len,\n\t\t      bcon->assocresp_ies, bcon->assocresp_ies_len);\n\n\tproberesp = _wil_cfg80211_get_proberesp_ies(bcon->probe_resp,\n\t\t\t\t\t\t    bcon->probe_resp_len,\n\t\t\t\t\t\t    &proberesp_len);\n\trc = _wil_cfg80211_merge_extra_ies(proberesp,\n\t\t\t\t\t   proberesp_len,\n\t\t\t\t\t   bcon->proberesp_ies,\n\t\t\t\t\t   bcon->proberesp_ies_len,\n\t\t\t\t\t   &ies, &len);\n\n\tif (rc)\n\t\tgoto out;\n\n\trc = wmi_set_ie(vif, WMI_FRAME_PROBE_RESP, len, ies);\n\tif (rc)\n\t\tgoto out;\n\n\tif (bcon->assocresp_ies)\n\t\trc = wmi_set_ie(vif, WMI_FRAME_ASSOC_RESP,\n\t\t\t\tbcon->assocresp_ies_len, bcon->assocresp_ies);\n\telse\n\t\trc = wmi_set_ie(vif, WMI_FRAME_ASSOC_RESP, len, ies);\n#if 0  \n\tif (rc)\n\t\tgoto out;\n\n\trc = wmi_set_ie(vif, WMI_FRAME_BEACON,\n\t\t\tbcon->tail_len, bcon->tail);\n#endif\nout:\n\tkfree(ies);\n\treturn rc;\n}\n\nstatic int _wil_cfg80211_start_ap(struct wiphy *wiphy,\n\t\t\t\t  struct net_device *ndev,\n\t\t\t\t  const u8 *ssid, size_t ssid_len, u32 privacy,\n\t\t\t\t  int bi, u8 chan, u8 wmi_edmg_channel,\n\t\t\t\t  struct cfg80211_beacon_data *bcon,\n\t\t\t\t  u8 hidden_ssid, u32 pbss)\n{\n\tstruct wil6210_priv *wil = wiphy_to_wil(wiphy);\n\tstruct wil6210_vif *vif = ndev_to_vif(ndev);\n\tint rc;\n\tstruct wireless_dev *wdev = ndev->ieee80211_ptr;\n\tu8 wmi_nettype = wil_iftype_nl2wmi(wdev->iftype);\n\tu8 is_go = (wdev->iftype == NL80211_IFTYPE_P2P_GO);\n\tu16 proberesp_len = 0;\n\tu8 *proberesp;\n\tbool ft = false;\n\n\tif (pbss)\n\t\twmi_nettype = WMI_NETTYPE_P2P;\n\n\twil_dbg_misc(wil, \"start_ap: mid=%d, is_go=%d\\n\", vif->mid, is_go);\n\tif (is_go && !pbss) {\n\t\twil_err(wil, \"P2P GO must be in PBSS\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\twil_set_recovery_state(wil, fw_recovery_idle);\n\n\tproberesp = _wil_cfg80211_get_proberesp_ies(bcon->probe_resp,\n\t\t\t\t\t\t    bcon->probe_resp_len,\n\t\t\t\t\t\t    &proberesp_len);\n\t \n\tif ((proberesp && proberesp_len > 0 &&\n\t     cfg80211_find_ie(WLAN_EID_MOBILITY_DOMAIN,\n\t\t\t      proberesp,\n\t\t\t      proberesp_len)))\n\t\tft = true;\n\n\tif (ft) {\n\t\tif (!test_bit(WMI_FW_CAPABILITY_FT_ROAMING,\n\t\t\t      wil->fw_capabilities)) {\n\t\t\twil_err(wil, \"FW does not support FT roaming\\n\");\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t\tset_bit(wil_vif_ft_roam, vif->status);\n\t}\n\n\tmutex_lock(&wil->mutex);\n\n\tif (!wil_has_other_active_ifaces(wil, ndev, true, false)) {\n\t\t__wil_down(wil);\n\t\trc = __wil_up(wil);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\trc = wmi_set_ssid(vif, ssid_len, ssid);\n\tif (rc)\n\t\tgoto out;\n\n\trc = _wil_cfg80211_set_ies(vif, bcon);\n\tif (rc)\n\t\tgoto out;\n\n\tvif->privacy = privacy;\n\tvif->channel = chan;\n\tvif->wmi_edmg_channel = wmi_edmg_channel;\n\tvif->hidden_ssid = hidden_ssid;\n\tvif->pbss = pbss;\n\tvif->bi = bi;\n\tmemcpy(vif->ssid, ssid, ssid_len);\n\tvif->ssid_len = ssid_len;\n\n\tnetif_carrier_on(ndev);\n\tif (!wil_has_other_active_ifaces(wil, ndev, false, true))\n\t\twil6210_bus_request(wil, WIL_MAX_BUS_REQUEST_KBPS);\n\n\trc = wmi_pcp_start(vif, bi, wmi_nettype, chan, wmi_edmg_channel,\n\t\t\t   hidden_ssid, is_go);\n\tif (rc)\n\t\tgoto err_pcp_start;\n\n\trc = wil_bcast_init(vif);\n\tif (rc)\n\t\tgoto err_bcast;\n\n\tgoto out;  \n\nerr_bcast:\n\twmi_pcp_stop(vif);\nerr_pcp_start:\n\tnetif_carrier_off(ndev);\n\tif (!wil_has_other_active_ifaces(wil, ndev, false, true))\n\t\twil6210_bus_request(wil, WIL_DEFAULT_BUS_REQUEST_KBPS);\nout:\n\tmutex_unlock(&wil->mutex);\n\treturn rc;\n}\n\nvoid wil_cfg80211_ap_recovery(struct wil6210_priv *wil)\n{\n\tint rc, i;\n\tstruct wiphy *wiphy = wil_to_wiphy(wil);\n\n\tfor (i = 0; i < GET_MAX_VIFS(wil); i++) {\n\t\tstruct wil6210_vif *vif = wil->vifs[i];\n\t\tstruct net_device *ndev;\n\t\tstruct cfg80211_beacon_data bcon = {};\n\t\tstruct key_params key_params = {};\n\n\t\tif (!vif || vif->ssid_len == 0)\n\t\t\tcontinue;\n\n\t\tndev = vif_to_ndev(vif);\n\t\tbcon.proberesp_ies = vif->proberesp_ies;\n\t\tbcon.assocresp_ies = vif->assocresp_ies;\n\t\tbcon.probe_resp = vif->proberesp;\n\t\tbcon.proberesp_ies_len = vif->proberesp_ies_len;\n\t\tbcon.assocresp_ies_len = vif->assocresp_ies_len;\n\t\tbcon.probe_resp_len = vif->proberesp_len;\n\n\t\twil_info(wil,\n\t\t\t \"AP (vif %d) recovery: privacy %d, bi %d, channel %d, hidden %d, pbss %d\\n\",\n\t\t\t i, vif->privacy, vif->bi, vif->channel,\n\t\t\t vif->hidden_ssid, vif->pbss);\n\t\twil_hex_dump_misc(\"SSID \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t\t  vif->ssid, vif->ssid_len, true);\n\t\trc = _wil_cfg80211_start_ap(wiphy, ndev,\n\t\t\t\t\t    vif->ssid, vif->ssid_len,\n\t\t\t\t\t    vif->privacy, vif->bi,\n\t\t\t\t\t    vif->channel,\n\t\t\t\t\t    vif->wmi_edmg_channel, &bcon,\n\t\t\t\t\t    vif->hidden_ssid, vif->pbss);\n\t\tif (rc) {\n\t\t\twil_err(wil, \"vif %d recovery failed (%d)\\n\", i, rc);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!vif->privacy || vif->gtk_len == 0)\n\t\t\tcontinue;\n\n\t\tkey_params.key = vif->gtk;\n\t\tkey_params.key_len = vif->gtk_len;\n\t\tkey_params.seq_len = IEEE80211_GCMP_PN_LEN;\n\t\trc = wil_cfg80211_add_key(wiphy, ndev, -1, vif->gtk_index,\n\t\t\t\t\t  false, NULL, &key_params);\n\t\tif (rc)\n\t\t\twil_err(wil, \"vif %d recovery add key failed (%d)\\n\",\n\t\t\t\ti, rc);\n\t}\n}\n\nstatic int wil_cfg80211_change_beacon(struct wiphy *wiphy,\n\t\t\t\t      struct net_device *ndev,\n\t\t\t\t      struct cfg80211_beacon_data *bcon)\n{\n\tstruct wil6210_priv *wil = wiphy_to_wil(wiphy);\n\tstruct wireless_dev *wdev = ndev->ieee80211_ptr;\n\tstruct wil6210_vif *vif = ndev_to_vif(ndev);\n\tint rc;\n\tu32 privacy = 0;\n\n\twil_dbg_misc(wil, \"change_beacon, mid=%d\\n\", vif->mid);\n\twil_print_bcon_data(bcon);\n\n\tif (bcon->tail &&\n\t    cfg80211_find_ie(WLAN_EID_RSN, bcon->tail,\n\t\t\t     bcon->tail_len))\n\t\tprivacy = 1;\n\n\tmemcpy(vif->ssid, wdev->u.ap.ssid, wdev->u.ap.ssid_len);\n\tvif->ssid_len = wdev->u.ap.ssid_len;\n\n\t \n\tif (vif->privacy != privacy) {\n\t\twil_dbg_misc(wil, \"privacy changed %d=>%d. Restarting AP\\n\",\n\t\t\t     vif->privacy, privacy);\n\n\t\trc = _wil_cfg80211_start_ap(wiphy, ndev, vif->ssid,\n\t\t\t\t\t    vif->ssid_len, privacy,\n\t\t\t\t\t    wdev->links[0].ap.beacon_interval,\n\t\t\t\t\t    vif->channel,\n\t\t\t\t\t    vif->wmi_edmg_channel, bcon,\n\t\t\t\t\t    vif->hidden_ssid,\n\t\t\t\t\t    vif->pbss);\n\t} else {\n\t\trc = _wil_cfg80211_set_ies(vif, bcon);\n\t}\n\n\treturn rc;\n}\n\nstatic int wil_cfg80211_start_ap(struct wiphy *wiphy,\n\t\t\t\t struct net_device *ndev,\n\t\t\t\t struct cfg80211_ap_settings *info)\n{\n\tint rc;\n\tstruct wil6210_priv *wil = wiphy_to_wil(wiphy);\n\tstruct ieee80211_channel *channel = info->chandef.chan;\n\tstruct cfg80211_beacon_data *bcon = &info->beacon;\n\tstruct cfg80211_crypto_settings *crypto = &info->crypto;\n\tu8 wmi_edmg_channel;\n\tu8 hidden_ssid;\n\n\twil_dbg_misc(wil, \"start_ap\\n\");\n\n\trc = wil_get_wmi_edmg_channel(wil, info->chandef.edmg.bw_config,\n\t\t\t\t      info->chandef.edmg.channels,\n\t\t\t\t      &wmi_edmg_channel);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tif (!channel) {\n\t\twil_err(wil, \"AP: No channel???\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (info->hidden_ssid) {\n\tcase NL80211_HIDDEN_SSID_NOT_IN_USE:\n\t\thidden_ssid = WMI_HIDDEN_SSID_DISABLED;\n\t\tbreak;\n\n\tcase NL80211_HIDDEN_SSID_ZERO_LEN:\n\t\thidden_ssid = WMI_HIDDEN_SSID_SEND_EMPTY;\n\t\tbreak;\n\n\tcase NL80211_HIDDEN_SSID_ZERO_CONTENTS:\n\t\thidden_ssid = WMI_HIDDEN_SSID_CLEAR;\n\t\tbreak;\n\n\tdefault:\n\t\twil_err(wil, \"AP: Invalid hidden SSID %d\\n\", info->hidden_ssid);\n\t\treturn -EOPNOTSUPP;\n\t}\n\twil_dbg_misc(wil, \"AP on Channel %d %d MHz, %s\\n\", channel->hw_value,\n\t\t     channel->center_freq, info->privacy ? \"secure\" : \"open\");\n\twil_dbg_misc(wil, \"Privacy: %d auth_type %d\\n\",\n\t\t     info->privacy, info->auth_type);\n\twil_dbg_misc(wil, \"Hidden SSID mode: %d\\n\",\n\t\t     info->hidden_ssid);\n\twil_dbg_misc(wil, \"BI %d DTIM %d\\n\", info->beacon_interval,\n\t\t     info->dtim_period);\n\twil_dbg_misc(wil, \"PBSS %d\\n\", info->pbss);\n\twil_hex_dump_misc(\"SSID \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t  info->ssid, info->ssid_len, true);\n\twil_print_bcon_data(bcon);\n\twil_print_crypto(wil, crypto);\n\n\trc = _wil_cfg80211_start_ap(wiphy, ndev,\n\t\t\t\t    info->ssid, info->ssid_len, info->privacy,\n\t\t\t\t    info->beacon_interval, channel->hw_value,\n\t\t\t\t    wmi_edmg_channel, bcon, hidden_ssid,\n\t\t\t\t    info->pbss);\n\n\treturn rc;\n}\n\nstatic int wil_cfg80211_stop_ap(struct wiphy *wiphy,\n\t\t\t\tstruct net_device *ndev,\n\t\t\t\tunsigned int link_id)\n{\n\tstruct wil6210_priv *wil = wiphy_to_wil(wiphy);\n\tstruct wil6210_vif *vif = ndev_to_vif(ndev);\n\tbool last;\n\n\twil_dbg_misc(wil, \"stop_ap, mid=%d\\n\", vif->mid);\n\n\tnetif_carrier_off(ndev);\n\tlast = !wil_has_other_active_ifaces(wil, ndev, false, true);\n\tif (last) {\n\t\twil6210_bus_request(wil, WIL_DEFAULT_BUS_REQUEST_KBPS);\n\t\twil_set_recovery_state(wil, fw_recovery_idle);\n\t\tset_bit(wil_status_resetting, wil->status);\n\t}\n\n\tmutex_lock(&wil->mutex);\n\n\twmi_pcp_stop(vif);\n\tclear_bit(wil_vif_ft_roam, vif->status);\n\tvif->ssid_len = 0;\n\twil_memdup_ie(&vif->proberesp, &vif->proberesp_len, NULL, 0);\n\twil_memdup_ie(&vif->proberesp_ies, &vif->proberesp_ies_len, NULL, 0);\n\twil_memdup_ie(&vif->assocresp_ies, &vif->assocresp_ies_len, NULL, 0);\n\tmemset(vif->gtk, 0, WMI_MAX_KEY_LEN);\n\tvif->gtk_len = 0;\n\n\tif (last)\n\t\t__wil_down(wil);\n\telse\n\t\twil_bcast_fini(vif);\n\n\tmutex_unlock(&wil->mutex);\n\n\treturn 0;\n}\n\nstatic int wil_cfg80211_add_station(struct wiphy *wiphy,\n\t\t\t\t    struct net_device *dev,\n\t\t\t\t    const u8 *mac,\n\t\t\t\t    struct station_parameters *params)\n{\n\tstruct wil6210_vif *vif = ndev_to_vif(dev);\n\tstruct wil6210_priv *wil = wiphy_to_wil(wiphy);\n\n\twil_dbg_misc(wil, \"add station %pM aid %d mid %d mask 0x%x set 0x%x\\n\",\n\t\t     mac, params->aid, vif->mid,\n\t\t     params->sta_flags_mask, params->sta_flags_set);\n\n\tif (!disable_ap_sme) {\n\t\twil_err(wil, \"not supported with AP SME enabled\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (params->aid > WIL_MAX_DMG_AID) {\n\t\twil_err(wil, \"invalid aid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn wmi_new_sta(vif, mac, params->aid);\n}\n\nstatic int wil_cfg80211_del_station(struct wiphy *wiphy,\n\t\t\t\t    struct net_device *dev,\n\t\t\t\t    struct station_del_parameters *params)\n{\n\tstruct wil6210_vif *vif = ndev_to_vif(dev);\n\tstruct wil6210_priv *wil = wiphy_to_wil(wiphy);\n\n\twil_dbg_misc(wil, \"del_station: %pM, reason=%d mid=%d\\n\",\n\t\t     params->mac, params->reason_code, vif->mid);\n\n\tmutex_lock(&wil->mutex);\n\twil6210_disconnect(vif, params->mac, params->reason_code);\n\tmutex_unlock(&wil->mutex);\n\n\treturn 0;\n}\n\nstatic int wil_cfg80211_change_station(struct wiphy *wiphy,\n\t\t\t\t       struct net_device *dev,\n\t\t\t\t       const u8 *mac,\n\t\t\t\t       struct station_parameters *params)\n{\n\tstruct wil6210_vif *vif = ndev_to_vif(dev);\n\tstruct wil6210_priv *wil = wiphy_to_wil(wiphy);\n\tint authorize;\n\tint cid, i;\n\tstruct wil_ring_tx_data *txdata = NULL;\n\n\twil_dbg_misc(wil, \"change station %pM mask 0x%x set 0x%x mid %d\\n\",\n\t\t     mac, params->sta_flags_mask, params->sta_flags_set,\n\t\t     vif->mid);\n\n\tif (!disable_ap_sme) {\n\t\twil_dbg_misc(wil, \"not supported with AP SME enabled\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!(params->sta_flags_mask & BIT(NL80211_STA_FLAG_AUTHORIZED)))\n\t\treturn 0;\n\n\tcid = wil_find_cid(wil, vif->mid, mac);\n\tif (cid < 0) {\n\t\twil_err(wil, \"station not found\\n\");\n\t\treturn -ENOLINK;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(wil->ring2cid_tid); i++)\n\t\tif (wil->ring2cid_tid[i][0] == cid) {\n\t\t\ttxdata = &wil->ring_tx_data[i];\n\t\t\tbreak;\n\t\t}\n\n\tif (!txdata) {\n\t\twil_err(wil, \"ring data not found\\n\");\n\t\treturn -ENOLINK;\n\t}\n\n\tauthorize = params->sta_flags_set & BIT(NL80211_STA_FLAG_AUTHORIZED);\n\ttxdata->dot1x_open = authorize ? 1 : 0;\n\twil_dbg_misc(wil, \"cid %d ring %d authorize %d\\n\", cid, i,\n\t\t     txdata->dot1x_open);\n\n\treturn 0;\n}\n\n \nstatic void wil_probe_client_handle(struct wil6210_priv *wil,\n\t\t\t\t    struct wil6210_vif *vif,\n\t\t\t\t    struct wil_probe_client_req *req)\n{\n\tstruct net_device *ndev = vif_to_ndev(vif);\n\tstruct wil_sta_info *sta = &wil->sta[req->cid];\n\t \n\tbool alive = (sta->status == wil_sta_connected);\n\n\tcfg80211_probe_status(ndev, sta->addr, req->cookie, alive,\n\t\t\t      0, false, GFP_KERNEL);\n}\n\nstatic struct list_head *next_probe_client(struct wil6210_vif *vif)\n{\n\tstruct list_head *ret = NULL;\n\n\tmutex_lock(&vif->probe_client_mutex);\n\n\tif (!list_empty(&vif->probe_client_pending)) {\n\t\tret = vif->probe_client_pending.next;\n\t\tlist_del(ret);\n\t}\n\n\tmutex_unlock(&vif->probe_client_mutex);\n\n\treturn ret;\n}\n\nvoid wil_probe_client_worker(struct work_struct *work)\n{\n\tstruct wil6210_vif *vif = container_of(work, struct wil6210_vif,\n\t\t\t\t\t       probe_client_worker);\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tstruct wil_probe_client_req *req;\n\tstruct list_head *lh;\n\n\twhile ((lh = next_probe_client(vif)) != NULL) {\n\t\treq = list_entry(lh, struct wil_probe_client_req, list);\n\n\t\twil_probe_client_handle(wil, vif, req);\n\t\tkfree(req);\n\t}\n}\n\nvoid wil_probe_client_flush(struct wil6210_vif *vif)\n{\n\tstruct wil_probe_client_req *req, *t;\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\n\twil_dbg_misc(wil, \"probe_client_flush\\n\");\n\n\tmutex_lock(&vif->probe_client_mutex);\n\n\tlist_for_each_entry_safe(req, t, &vif->probe_client_pending, list) {\n\t\tlist_del(&req->list);\n\t\tkfree(req);\n\t}\n\n\tmutex_unlock(&vif->probe_client_mutex);\n}\n\nstatic int wil_cfg80211_probe_client(struct wiphy *wiphy,\n\t\t\t\t     struct net_device *dev,\n\t\t\t\t     const u8 *peer, u64 *cookie)\n{\n\tstruct wil6210_priv *wil = wiphy_to_wil(wiphy);\n\tstruct wil6210_vif *vif = ndev_to_vif(dev);\n\tstruct wil_probe_client_req *req;\n\tint cid = wil_find_cid(wil, vif->mid, peer);\n\n\twil_dbg_misc(wil, \"probe_client: %pM => CID %d MID %d\\n\",\n\t\t     peer, cid, vif->mid);\n\n\tif (cid < 0)\n\t\treturn -ENOLINK;\n\n\treq = kzalloc(sizeof(*req), GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\treq->cid = cid;\n\treq->cookie = cid;\n\n\tmutex_lock(&vif->probe_client_mutex);\n\tlist_add_tail(&req->list, &vif->probe_client_pending);\n\tmutex_unlock(&vif->probe_client_mutex);\n\n\t*cookie = req->cookie;\n\tqueue_work(wil->wq_service, &vif->probe_client_worker);\n\treturn 0;\n}\n\nstatic int wil_cfg80211_change_bss(struct wiphy *wiphy,\n\t\t\t\t   struct net_device *dev,\n\t\t\t\t   struct bss_parameters *params)\n{\n\tstruct wil6210_priv *wil = wiphy_to_wil(wiphy);\n\tstruct wil6210_vif *vif = ndev_to_vif(dev);\n\n\tif (params->ap_isolate >= 0) {\n\t\twil_dbg_misc(wil, \"change_bss: ap_isolate MID %d, %d => %d\\n\",\n\t\t\t     vif->mid, vif->ap_isolate, params->ap_isolate);\n\t\tvif->ap_isolate = params->ap_isolate;\n\t}\n\n\treturn 0;\n}\n\nstatic int wil_cfg80211_set_power_mgmt(struct wiphy *wiphy,\n\t\t\t\t       struct net_device *dev,\n\t\t\t\t       bool enabled, int timeout)\n{\n\tstruct wil6210_priv *wil = wiphy_to_wil(wiphy);\n\tenum wmi_ps_profile_type ps_profile;\n\n\twil_dbg_misc(wil, \"enabled=%d, timeout=%d\\n\",\n\t\t     enabled, timeout);\n\n\tif (enabled)\n\t\tps_profile = WMI_PS_PROFILE_TYPE_DEFAULT;\n\telse\n\t\tps_profile = WMI_PS_PROFILE_TYPE_PS_DISABLED;\n\n\treturn wil_ps_update(wil, ps_profile);\n}\n\nstatic int wil_cfg80211_suspend(struct wiphy *wiphy,\n\t\t\t\tstruct cfg80211_wowlan *wow)\n{\n\tstruct wil6210_priv *wil = wiphy_to_wil(wiphy);\n\tint rc;\n\n\t \n\n\tif (test_bit(wil_status_suspended, wil->status)) {\n\t\twil_dbg_pm(wil, \"trying to suspend while suspended\\n\");\n\t\treturn 0;\n\t}\n\n\trc = wil_can_suspend(wil, false);\n\tif (rc)\n\t\tgoto out;\n\n\twil_dbg_pm(wil, \"suspending\\n\");\n\n\tmutex_lock(&wil->mutex);\n\tmutex_lock(&wil->vif_mutex);\n\twil_p2p_stop_radio_operations(wil);\n\twil_abort_scan_all_vifs(wil, true);\n\tmutex_unlock(&wil->vif_mutex);\n\tmutex_unlock(&wil->mutex);\n\nout:\n\treturn rc;\n}\n\nstatic int wil_cfg80211_resume(struct wiphy *wiphy)\n{\n\tstruct wil6210_priv *wil = wiphy_to_wil(wiphy);\n\n\twil_dbg_pm(wil, \"resuming\\n\");\n\n\treturn 0;\n}\n\nstatic int\nwil_cfg80211_sched_scan_start(struct wiphy *wiphy,\n\t\t\t      struct net_device *dev,\n\t\t\t      struct cfg80211_sched_scan_request *request)\n{\n\tstruct wil6210_priv *wil = wiphy_to_wil(wiphy);\n\tstruct wil6210_vif *vif = ndev_to_vif(dev);\n\tint i, rc;\n\n\tif (vif->mid != 0)\n\t\treturn -EOPNOTSUPP;\n\n\twil_dbg_misc(wil,\n\t\t     \"sched scan start: n_ssids %d, ie_len %zu, flags 0x%x\\n\",\n\t\t     request->n_ssids, request->ie_len, request->flags);\n\tfor (i = 0; i < request->n_ssids; i++) {\n\t\twil_dbg_misc(wil, \"SSID[%d]:\", i);\n\t\twil_hex_dump_misc(\"SSID \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t\t  request->ssids[i].ssid,\n\t\t\t\t  request->ssids[i].ssid_len, true);\n\t}\n\twil_dbg_misc(wil, \"channels:\");\n\tfor (i = 0; i < request->n_channels; i++)\n\t\twil_dbg_misc(wil, \" %d%s\", request->channels[i]->hw_value,\n\t\t\t     i == request->n_channels - 1 ? \"\\n\" : \"\");\n\twil_dbg_misc(wil, \"n_match_sets %d, min_rssi_thold %d, delay %d\\n\",\n\t\t     request->n_match_sets, request->min_rssi_thold,\n\t\t     request->delay);\n\tfor (i = 0; i < request->n_match_sets; i++) {\n\t\tstruct cfg80211_match_set *ms = &request->match_sets[i];\n\n\t\twil_dbg_misc(wil, \"MATCHSET[%d]: rssi_thold %d\\n\",\n\t\t\t     i, ms->rssi_thold);\n\t\twil_hex_dump_misc(\"SSID \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t\t  ms->ssid.ssid,\n\t\t\t\t  ms->ssid.ssid_len, true);\n\t}\n\twil_dbg_misc(wil, \"n_scan_plans %d\\n\", request->n_scan_plans);\n\tfor (i = 0; i < request->n_scan_plans; i++) {\n\t\tstruct cfg80211_sched_scan_plan *sp = &request->scan_plans[i];\n\n\t\twil_dbg_misc(wil, \"SCAN PLAN[%d]: interval %d iterations %d\\n\",\n\t\t\t     i, sp->interval, sp->iterations);\n\t}\n\n\trc = wmi_set_ie(vif, WMI_FRAME_PROBE_REQ,\n\t\t\trequest->ie_len, request->ie);\n\tif (rc)\n\t\treturn rc;\n\treturn wmi_start_sched_scan(wil, request);\n}\n\nstatic int\nwil_cfg80211_sched_scan_stop(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t     u64 reqid)\n{\n\tstruct wil6210_priv *wil = wiphy_to_wil(wiphy);\n\tstruct wil6210_vif *vif = ndev_to_vif(dev);\n\tint rc;\n\n\tif (vif->mid != 0)\n\t\treturn -EOPNOTSUPP;\n\n\trc = wmi_stop_sched_scan(wil);\n\t \n\twil_dbg_misc(wil, \"sched scan stopped (%d)\\n\", rc);\n\n\treturn 0;\n}\n\nstatic int\nwil_cfg80211_update_ft_ies(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t   struct cfg80211_update_ft_ies_params *ftie)\n{\n\tstruct wil6210_priv *wil = wiphy_to_wil(wiphy);\n\tstruct wil6210_vif *vif = ndev_to_vif(dev);\n\tstruct cfg80211_bss *bss;\n\tstruct wmi_ft_reassoc_cmd reassoc;\n\tint rc = 0;\n\n\twil_dbg_misc(wil, \"update ft ies, mid=%d\\n\", vif->mid);\n\twil_hex_dump_misc(\"FT IE \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t  ftie->ie, ftie->ie_len, true);\n\n\tif (!test_bit(WMI_FW_CAPABILITY_FT_ROAMING, wil->fw_capabilities)) {\n\t\twil_err(wil, \"FW does not support FT roaming\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\trc = wmi_update_ft_ies(vif, ftie->ie_len, ftie->ie);\n\tif (rc)\n\t\treturn rc;\n\n\tif (!test_bit(wil_vif_ft_roam, vif->status))\n\t\t \n\t\treturn 0;\n\n\t \n\n\tbss = vif->bss;\n\tif (!bss) {\n\t\twil_err(wil, \"FT: bss is NULL\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(&reassoc, 0, sizeof(reassoc));\n\tether_addr_copy(reassoc.bssid, bss->bssid);\n\n\trc = wmi_send(wil, WMI_FT_REASSOC_CMDID, vif->mid,\n\t\t      &reassoc, sizeof(reassoc));\n\tif (rc)\n\t\twil_err(wil, \"FT: reassoc failed (%d)\\n\", rc);\n\n\treturn rc;\n}\n\nstatic int wil_cfg80211_set_multicast_to_unicast(struct wiphy *wiphy,\n\t\t\t\t\t\t struct net_device *dev,\n\t\t\t\t\t\t const bool enabled)\n{\n\tstruct wil6210_priv *wil = wiphy_to_wil(wiphy);\n\n\tif (wil->multicast_to_unicast == enabled)\n\t\treturn 0;\n\n\twil_info(wil, \"set multicast to unicast, enabled=%d\\n\", enabled);\n\twil->multicast_to_unicast = enabled;\n\n\treturn 0;\n}\n\nstatic int wil_cfg80211_set_cqm_rssi_config(struct wiphy *wiphy,\n\t\t\t\t\t    struct net_device *dev,\n\t\t\t\t\t    s32 rssi_thold, u32 rssi_hyst)\n{\n\tstruct wil6210_priv *wil = wiphy_to_wil(wiphy);\n\tint rc;\n\n\twil->cqm_rssi_thold = rssi_thold;\n\n\trc = wmi_set_cqm_rssi_config(wil, rssi_thold, rssi_hyst);\n\tif (rc)\n\t\t \n\t\twil->cqm_rssi_thold = 0;\n\n\treturn rc;\n}\n\nstatic const struct cfg80211_ops wil_cfg80211_ops = {\n\t.add_virtual_intf = wil_cfg80211_add_iface,\n\t.del_virtual_intf = wil_cfg80211_del_iface,\n\t.scan = wil_cfg80211_scan,\n\t.abort_scan = wil_cfg80211_abort_scan,\n\t.connect = wil_cfg80211_connect,\n\t.disconnect = wil_cfg80211_disconnect,\n\t.set_wiphy_params = wil_cfg80211_set_wiphy_params,\n\t.change_virtual_intf = wil_cfg80211_change_iface,\n\t.get_station = wil_cfg80211_get_station,\n\t.dump_station = wil_cfg80211_dump_station,\n\t.remain_on_channel = wil_remain_on_channel,\n\t.cancel_remain_on_channel = wil_cancel_remain_on_channel,\n\t.mgmt_tx = wil_cfg80211_mgmt_tx,\n\t.set_monitor_channel = wil_cfg80211_set_channel,\n\t.add_key = wil_cfg80211_add_key,\n\t.del_key = wil_cfg80211_del_key,\n\t.set_default_key = wil_cfg80211_set_default_key,\n\t \n\t.change_beacon = wil_cfg80211_change_beacon,\n\t.start_ap = wil_cfg80211_start_ap,\n\t.stop_ap = wil_cfg80211_stop_ap,\n\t.add_station = wil_cfg80211_add_station,\n\t.del_station = wil_cfg80211_del_station,\n\t.change_station = wil_cfg80211_change_station,\n\t.probe_client = wil_cfg80211_probe_client,\n\t.change_bss = wil_cfg80211_change_bss,\n\t \n\t.start_p2p_device = wil_cfg80211_start_p2p_device,\n\t.stop_p2p_device = wil_cfg80211_stop_p2p_device,\n\t.set_power_mgmt = wil_cfg80211_set_power_mgmt,\n\t.set_cqm_rssi_config = wil_cfg80211_set_cqm_rssi_config,\n\t.suspend = wil_cfg80211_suspend,\n\t.resume = wil_cfg80211_resume,\n\t.sched_scan_start = wil_cfg80211_sched_scan_start,\n\t.sched_scan_stop = wil_cfg80211_sched_scan_stop,\n\t.update_ft_ies = wil_cfg80211_update_ft_ies,\n\t.set_multicast_to_unicast = wil_cfg80211_set_multicast_to_unicast,\n};\n\nstatic void wil_wiphy_init(struct wiphy *wiphy)\n{\n\twiphy->max_scan_ssids = 1;\n\twiphy->max_scan_ie_len = WMI_MAX_IE_LEN;\n\twiphy->max_remain_on_channel_duration = WIL_MAX_ROC_DURATION_MS;\n\twiphy->max_num_pmkids = 0  ;\n\twiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |\n\t\t\t\t BIT(NL80211_IFTYPE_AP) |\n\t\t\t\t BIT(NL80211_IFTYPE_P2P_CLIENT) |\n\t\t\t\t BIT(NL80211_IFTYPE_P2P_GO) |\n\t\t\t\t BIT(NL80211_IFTYPE_P2P_DEVICE) |\n\t\t\t\t BIT(NL80211_IFTYPE_MONITOR);\n\twiphy->flags |= WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL |\n\t\t\tWIPHY_FLAG_AP_PROBE_RESP_OFFLOAD |\n\t\t\tWIPHY_FLAG_PS_ON_BY_DEFAULT;\n\tif (!disable_ap_sme)\n\t\twiphy->flags |= WIPHY_FLAG_HAVE_AP_SME;\n\tdev_dbg(wiphy_dev(wiphy), \"%s : flags = 0x%08x\\n\",\n\t\t__func__, wiphy->flags);\n\twiphy->probe_resp_offload =\n\t\tNL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS |\n\t\tNL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS2 |\n\t\tNL80211_PROBE_RESP_OFFLOAD_SUPPORT_P2P;\n\n\twiphy->bands[NL80211_BAND_60GHZ] = &wil_band_60ghz;\n\n\t \n\twiphy->signal_type = CFG80211_SIGNAL_TYPE_UNSPEC;\n\n\twiphy->cipher_suites = wil_cipher_suites;\n\twiphy->n_cipher_suites = ARRAY_SIZE(wil_cipher_suites);\n\twiphy->mgmt_stypes = wil_mgmt_stypes;\n\twiphy->features |= NL80211_FEATURE_SK_TX_STATUS;\n\n\twiphy->n_vendor_commands = ARRAY_SIZE(wil_nl80211_vendor_commands);\n\twiphy->vendor_commands = wil_nl80211_vendor_commands;\n\n#ifdef CONFIG_PM\n\twiphy->wowlan = &wil_wowlan_support;\n#endif\n}\n\nint wil_cfg80211_iface_combinations_from_fw(\n\tstruct wil6210_priv *wil, const struct wil_fw_record_concurrency *conc)\n{\n\tstruct wiphy *wiphy = wil_to_wiphy(wil);\n\tu32 total_limits = 0;\n\tu16 n_combos;\n\tconst struct wil_fw_concurrency_combo *combo;\n\tconst struct wil_fw_concurrency_limit *limit;\n\tstruct ieee80211_iface_combination *iface_combinations;\n\tstruct ieee80211_iface_limit *iface_limit;\n\tint i, j;\n\n\tif (wiphy->iface_combinations) {\n\t\twil_dbg_misc(wil, \"iface_combinations already set, skipping\\n\");\n\t\treturn 0;\n\t}\n\n\tcombo = conc->combos;\n\tn_combos = le16_to_cpu(conc->n_combos);\n\tfor (i = 0; i < n_combos; i++) {\n\t\ttotal_limits += combo->n_limits;\n\t\tlimit = combo->limits + combo->n_limits;\n\t\tcombo = (struct wil_fw_concurrency_combo *)limit;\n\t}\n\n\tiface_combinations =\n\t\tkzalloc(n_combos * sizeof(struct ieee80211_iface_combination) +\n\t\t\ttotal_limits * sizeof(struct ieee80211_iface_limit),\n\t\t\tGFP_KERNEL);\n\tif (!iface_combinations)\n\t\treturn -ENOMEM;\n\tiface_limit = (struct ieee80211_iface_limit *)(iface_combinations +\n\t\t\t\t\t\t       n_combos);\n\tcombo = conc->combos;\n\tfor (i = 0; i < n_combos; i++) {\n\t\tiface_combinations[i].max_interfaces = combo->max_interfaces;\n\t\tiface_combinations[i].num_different_channels =\n\t\t\tcombo->n_diff_channels;\n\t\tiface_combinations[i].beacon_int_infra_match =\n\t\t\tcombo->same_bi;\n\t\tiface_combinations[i].n_limits = combo->n_limits;\n\t\twil_dbg_misc(wil,\n\t\t\t     \"iface_combination %d: max_if %d, num_ch %d, bi_match %d\\n\",\n\t\t\t     i, iface_combinations[i].max_interfaces,\n\t\t\t     iface_combinations[i].num_different_channels,\n\t\t\t     iface_combinations[i].beacon_int_infra_match);\n\t\tlimit = combo->limits;\n\t\tfor (j = 0; j < combo->n_limits; j++) {\n\t\t\tiface_limit[j].max = le16_to_cpu(limit[j].max);\n\t\t\tiface_limit[j].types = le16_to_cpu(limit[j].types);\n\t\t\twil_dbg_misc(wil,\n\t\t\t\t     \"limit %d: max %d types 0x%x\\n\", j,\n\t\t\t\t     iface_limit[j].max, iface_limit[j].types);\n\t\t}\n\t\tiface_combinations[i].limits = iface_limit;\n\t\tiface_limit += combo->n_limits;\n\t\tlimit += combo->n_limits;\n\t\tcombo = (struct wil_fw_concurrency_combo *)limit;\n\t}\n\n\twil_dbg_misc(wil, \"multiple VIFs supported, n_mids %d\\n\", conc->n_mids);\n\twil->max_vifs = conc->n_mids + 1;  \n\tif (wil->max_vifs > WIL_MAX_VIFS) {\n\t\twil_info(wil, \"limited number of VIFs supported(%d, FW %d)\\n\",\n\t\t\t WIL_MAX_VIFS, wil->max_vifs);\n\t\twil->max_vifs = WIL_MAX_VIFS;\n\t}\n\twiphy->n_iface_combinations = n_combos;\n\twiphy->iface_combinations = iface_combinations;\n\treturn 0;\n}\n\nstruct wil6210_priv *wil_cfg80211_init(struct device *dev)\n{\n\tstruct wiphy *wiphy;\n\tstruct wil6210_priv *wil;\n\tstruct ieee80211_channel *ch;\n\n\tdev_dbg(dev, \"%s()\\n\", __func__);\n\n\t \n\twiphy = wiphy_new(&wil_cfg80211_ops, sizeof(struct wil6210_priv));\n\tif (!wiphy)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tset_wiphy_dev(wiphy, dev);\n\twil_wiphy_init(wiphy);\n\n\twil = wiphy_to_wil(wiphy);\n\twil->wiphy = wiphy;\n\n\t \n\tch = wiphy->bands[NL80211_BAND_60GHZ]->channels;\n\tcfg80211_chandef_create(&wil->monitor_chandef, ch, NL80211_CHAN_NO_HT);\n\n\treturn wil;\n}\n\nvoid wil_cfg80211_deinit(struct wil6210_priv *wil)\n{\n\tstruct wiphy *wiphy = wil_to_wiphy(wil);\n\n\tdev_dbg(wil_to_dev(wil), \"%s()\\n\", __func__);\n\n\tif (!wiphy)\n\t\treturn;\n\n\tkfree(wiphy->iface_combinations);\n\twiphy->iface_combinations = NULL;\n\n\twiphy_free(wiphy);\n\t \n}\n\nvoid wil_p2p_wdev_free(struct wil6210_priv *wil)\n{\n\tstruct wireless_dev *p2p_wdev;\n\n\tmutex_lock(&wil->vif_mutex);\n\tp2p_wdev = wil->p2p_wdev;\n\twil->p2p_wdev = NULL;\n\twil->radio_wdev = wil->main_ndev->ieee80211_ptr;\n\tmutex_unlock(&wil->vif_mutex);\n\tif (p2p_wdev) {\n\t\tcfg80211_unregister_wdev(p2p_wdev);\n\t\tkfree(p2p_wdev);\n\t}\n}\n\nstatic int wil_rf_sector_status_to_rc(u8 status)\n{\n\tswitch (status) {\n\tcase WMI_RF_SECTOR_STATUS_SUCCESS:\n\t\treturn 0;\n\tcase WMI_RF_SECTOR_STATUS_BAD_PARAMETERS_ERROR:\n\t\treturn -EINVAL;\n\tcase WMI_RF_SECTOR_STATUS_BUSY_ERROR:\n\t\treturn -EAGAIN;\n\tcase WMI_RF_SECTOR_STATUS_NOT_SUPPORTED_ERROR:\n\t\treturn -EOPNOTSUPP;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int wil_rf_sector_get_cfg(struct wiphy *wiphy,\n\t\t\t\t struct wireless_dev *wdev,\n\t\t\t\t const void *data, int data_len)\n{\n\tstruct wil6210_priv *wil = wdev_to_wil(wdev);\n\tstruct wil6210_vif *vif = wdev_to_vif(wil, wdev);\n\tint rc;\n\tstruct nlattr *tb[QCA_ATTR_DMG_RF_SECTOR_MAX + 1];\n\tu16 sector_index;\n\tu8 sector_type;\n\tu32 rf_modules_vec;\n\tstruct wmi_get_rf_sector_params_cmd cmd;\n\tstruct {\n\t\tstruct wmi_cmd_hdr wmi;\n\t\tstruct wmi_get_rf_sector_params_done_event evt;\n\t} __packed reply = {\n\t\t.evt = {.status = WMI_RF_SECTOR_STATUS_NOT_SUPPORTED_ERROR},\n\t};\n\tstruct sk_buff *msg;\n\tstruct nlattr *nl_cfgs, *nl_cfg;\n\tu32 i;\n\tstruct wmi_rf_sector_info *si;\n\n\tif (!test_bit(WMI_FW_CAPABILITY_RF_SECTORS, wil->fw_capabilities))\n\t\treturn -EOPNOTSUPP;\n\n\trc = nla_parse_deprecated(tb, QCA_ATTR_DMG_RF_SECTOR_MAX, data,\n\t\t\t\t  data_len, wil_rf_sector_policy, NULL);\n\tif (rc) {\n\t\twil_err(wil, \"Invalid rf sector ATTR\\n\");\n\t\treturn rc;\n\t}\n\n\tif (!tb[QCA_ATTR_DMG_RF_SECTOR_INDEX] ||\n\t    !tb[QCA_ATTR_DMG_RF_SECTOR_TYPE] ||\n\t    !tb[QCA_ATTR_DMG_RF_MODULE_MASK]) {\n\t\twil_err(wil, \"Invalid rf sector spec\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsector_index = nla_get_u16(\n\t\ttb[QCA_ATTR_DMG_RF_SECTOR_INDEX]);\n\tif (sector_index >= WIL_MAX_RF_SECTORS) {\n\t\twil_err(wil, \"Invalid sector index %d\\n\", sector_index);\n\t\treturn -EINVAL;\n\t}\n\n\tsector_type = nla_get_u8(tb[QCA_ATTR_DMG_RF_SECTOR_TYPE]);\n\tif (sector_type >= QCA_ATTR_DMG_RF_SECTOR_TYPE_MAX) {\n\t\twil_err(wil, \"Invalid sector type %d\\n\", sector_type);\n\t\treturn -EINVAL;\n\t}\n\n\trf_modules_vec = nla_get_u32(\n\t\ttb[QCA_ATTR_DMG_RF_MODULE_MASK]);\n\tif (rf_modules_vec >= BIT(WMI_MAX_RF_MODULES_NUM)) {\n\t\twil_err(wil, \"Invalid rf module mask 0x%x\\n\", rf_modules_vec);\n\t\treturn -EINVAL;\n\t}\n\n\tcmd.sector_idx = cpu_to_le16(sector_index);\n\tcmd.sector_type = sector_type;\n\tcmd.rf_modules_vec = rf_modules_vec & 0xFF;\n\trc = wmi_call(wil, WMI_GET_RF_SECTOR_PARAMS_CMDID, vif->mid,\n\t\t      &cmd, sizeof(cmd), WMI_GET_RF_SECTOR_PARAMS_DONE_EVENTID,\n\t\t      &reply, sizeof(reply),\n\t\t      500);\n\tif (rc)\n\t\treturn rc;\n\tif (reply.evt.status) {\n\t\twil_err(wil, \"get rf sector cfg failed with status %d\\n\",\n\t\t\treply.evt.status);\n\t\treturn wil_rf_sector_status_to_rc(reply.evt.status);\n\t}\n\n\tmsg = cfg80211_vendor_cmd_alloc_reply_skb(\n\t\twiphy, 64 * WMI_MAX_RF_MODULES_NUM);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tif (nla_put_u64_64bit(msg, QCA_ATTR_TSF,\n\t\t\t      le64_to_cpu(reply.evt.tsf),\n\t\t\t      QCA_ATTR_PAD))\n\t\tgoto nla_put_failure;\n\n\tnl_cfgs = nla_nest_start_noflag(msg, QCA_ATTR_DMG_RF_SECTOR_CFG);\n\tif (!nl_cfgs)\n\t\tgoto nla_put_failure;\n\tfor (i = 0; i < WMI_MAX_RF_MODULES_NUM; i++) {\n\t\tif (!(rf_modules_vec & BIT(i)))\n\t\t\tcontinue;\n\t\tnl_cfg = nla_nest_start_noflag(msg, i);\n\t\tif (!nl_cfg)\n\t\t\tgoto nla_put_failure;\n\t\tsi = &reply.evt.sectors_info[i];\n\t\tif (nla_put_u8(msg, QCA_ATTR_DMG_RF_SECTOR_CFG_MODULE_INDEX,\n\t\t\t       i) ||\n\t\t    nla_put_u32(msg, QCA_ATTR_DMG_RF_SECTOR_CFG_ETYPE0,\n\t\t\t\tle32_to_cpu(si->etype0)) ||\n\t\t    nla_put_u32(msg, QCA_ATTR_DMG_RF_SECTOR_CFG_ETYPE1,\n\t\t\t\tle32_to_cpu(si->etype1)) ||\n\t\t    nla_put_u32(msg, QCA_ATTR_DMG_RF_SECTOR_CFG_ETYPE2,\n\t\t\t\tle32_to_cpu(si->etype2)) ||\n\t\t    nla_put_u32(msg, QCA_ATTR_DMG_RF_SECTOR_CFG_PSH_HI,\n\t\t\t\tle32_to_cpu(si->psh_hi)) ||\n\t\t    nla_put_u32(msg, QCA_ATTR_DMG_RF_SECTOR_CFG_PSH_LO,\n\t\t\t\tle32_to_cpu(si->psh_lo)) ||\n\t\t    nla_put_u32(msg, QCA_ATTR_DMG_RF_SECTOR_CFG_DTYPE_X16,\n\t\t\t\tle32_to_cpu(si->dtype_swch_off)))\n\t\t\tgoto nla_put_failure;\n\t\tnla_nest_end(msg, nl_cfg);\n\t}\n\n\tnla_nest_end(msg, nl_cfgs);\n\trc = cfg80211_vendor_cmd_reply(msg);\n\treturn rc;\nnla_put_failure:\n\tkfree_skb(msg);\n\treturn -ENOBUFS;\n}\n\nstatic int wil_rf_sector_set_cfg(struct wiphy *wiphy,\n\t\t\t\t struct wireless_dev *wdev,\n\t\t\t\t const void *data, int data_len)\n{\n\tstruct wil6210_priv *wil = wdev_to_wil(wdev);\n\tstruct wil6210_vif *vif = wdev_to_vif(wil, wdev);\n\tint rc, tmp;\n\tstruct nlattr *tb[QCA_ATTR_DMG_RF_SECTOR_MAX + 1];\n\tstruct nlattr *tb2[QCA_ATTR_DMG_RF_SECTOR_CFG_MAX + 1];\n\tu16 sector_index, rf_module_index;\n\tu8 sector_type;\n\tu32 rf_modules_vec = 0;\n\tstruct wmi_set_rf_sector_params_cmd cmd;\n\tstruct {\n\t\tstruct wmi_cmd_hdr wmi;\n\t\tstruct wmi_set_rf_sector_params_done_event evt;\n\t} __packed reply = {\n\t\t.evt = {.status = WMI_RF_SECTOR_STATUS_NOT_SUPPORTED_ERROR},\n\t};\n\tstruct nlattr *nl_cfg;\n\tstruct wmi_rf_sector_info *si;\n\n\tif (!test_bit(WMI_FW_CAPABILITY_RF_SECTORS, wil->fw_capabilities))\n\t\treturn -EOPNOTSUPP;\n\n\trc = nla_parse_deprecated(tb, QCA_ATTR_DMG_RF_SECTOR_MAX, data,\n\t\t\t\t  data_len, wil_rf_sector_policy, NULL);\n\tif (rc) {\n\t\twil_err(wil, \"Invalid rf sector ATTR\\n\");\n\t\treturn rc;\n\t}\n\n\tif (!tb[QCA_ATTR_DMG_RF_SECTOR_INDEX] ||\n\t    !tb[QCA_ATTR_DMG_RF_SECTOR_TYPE] ||\n\t    !tb[QCA_ATTR_DMG_RF_SECTOR_CFG]) {\n\t\twil_err(wil, \"Invalid rf sector spec\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsector_index = nla_get_u16(\n\t\ttb[QCA_ATTR_DMG_RF_SECTOR_INDEX]);\n\tif (sector_index >= WIL_MAX_RF_SECTORS) {\n\t\twil_err(wil, \"Invalid sector index %d\\n\", sector_index);\n\t\treturn -EINVAL;\n\t}\n\n\tsector_type = nla_get_u8(tb[QCA_ATTR_DMG_RF_SECTOR_TYPE]);\n\tif (sector_type >= QCA_ATTR_DMG_RF_SECTOR_TYPE_MAX) {\n\t\twil_err(wil, \"Invalid sector type %d\\n\", sector_type);\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\n\tcmd.sector_idx = cpu_to_le16(sector_index);\n\tcmd.sector_type = sector_type;\n\tnla_for_each_nested(nl_cfg, tb[QCA_ATTR_DMG_RF_SECTOR_CFG],\n\t\t\t    tmp) {\n\t\trc = nla_parse_nested_deprecated(tb2,\n\t\t\t\t\t\t QCA_ATTR_DMG_RF_SECTOR_CFG_MAX,\n\t\t\t\t\t\t nl_cfg,\n\t\t\t\t\t\t wil_rf_sector_cfg_policy,\n\t\t\t\t\t\t NULL);\n\t\tif (rc) {\n\t\t\twil_err(wil, \"invalid sector cfg\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!tb2[QCA_ATTR_DMG_RF_SECTOR_CFG_MODULE_INDEX] ||\n\t\t    !tb2[QCA_ATTR_DMG_RF_SECTOR_CFG_ETYPE0] ||\n\t\t    !tb2[QCA_ATTR_DMG_RF_SECTOR_CFG_ETYPE1] ||\n\t\t    !tb2[QCA_ATTR_DMG_RF_SECTOR_CFG_ETYPE2] ||\n\t\t    !tb2[QCA_ATTR_DMG_RF_SECTOR_CFG_PSH_HI] ||\n\t\t    !tb2[QCA_ATTR_DMG_RF_SECTOR_CFG_PSH_LO] ||\n\t\t    !tb2[QCA_ATTR_DMG_RF_SECTOR_CFG_DTYPE_X16]) {\n\t\t\twil_err(wil, \"missing cfg params\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\trf_module_index = nla_get_u8(\n\t\t\ttb2[QCA_ATTR_DMG_RF_SECTOR_CFG_MODULE_INDEX]);\n\t\tif (rf_module_index >= WMI_MAX_RF_MODULES_NUM) {\n\t\t\twil_err(wil, \"invalid RF module index %d\\n\",\n\t\t\t\trf_module_index);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\trf_modules_vec |= BIT(rf_module_index);\n\t\tsi = &cmd.sectors_info[rf_module_index];\n\t\tsi->etype0 = cpu_to_le32(nla_get_u32(\n\t\t\ttb2[QCA_ATTR_DMG_RF_SECTOR_CFG_ETYPE0]));\n\t\tsi->etype1 = cpu_to_le32(nla_get_u32(\n\t\t\ttb2[QCA_ATTR_DMG_RF_SECTOR_CFG_ETYPE1]));\n\t\tsi->etype2 = cpu_to_le32(nla_get_u32(\n\t\t\ttb2[QCA_ATTR_DMG_RF_SECTOR_CFG_ETYPE2]));\n\t\tsi->psh_hi = cpu_to_le32(nla_get_u32(\n\t\t\ttb2[QCA_ATTR_DMG_RF_SECTOR_CFG_PSH_HI]));\n\t\tsi->psh_lo = cpu_to_le32(nla_get_u32(\n\t\t\ttb2[QCA_ATTR_DMG_RF_SECTOR_CFG_PSH_LO]));\n\t\tsi->dtype_swch_off = cpu_to_le32(nla_get_u32(\n\t\t\ttb2[QCA_ATTR_DMG_RF_SECTOR_CFG_DTYPE_X16]));\n\t}\n\n\tcmd.rf_modules_vec = rf_modules_vec & 0xFF;\n\trc = wmi_call(wil, WMI_SET_RF_SECTOR_PARAMS_CMDID, vif->mid,\n\t\t      &cmd, sizeof(cmd), WMI_SET_RF_SECTOR_PARAMS_DONE_EVENTID,\n\t\t      &reply, sizeof(reply),\n\t\t      500);\n\tif (rc)\n\t\treturn rc;\n\treturn wil_rf_sector_status_to_rc(reply.evt.status);\n}\n\nstatic int wil_rf_sector_get_selected(struct wiphy *wiphy,\n\t\t\t\t      struct wireless_dev *wdev,\n\t\t\t\t      const void *data, int data_len)\n{\n\tstruct wil6210_priv *wil = wdev_to_wil(wdev);\n\tstruct wil6210_vif *vif = wdev_to_vif(wil, wdev);\n\tint rc;\n\tstruct nlattr *tb[QCA_ATTR_DMG_RF_SECTOR_MAX + 1];\n\tu8 sector_type, mac_addr[ETH_ALEN];\n\tint cid = 0;\n\tstruct wmi_get_selected_rf_sector_index_cmd cmd;\n\tstruct {\n\t\tstruct wmi_cmd_hdr wmi;\n\t\tstruct wmi_get_selected_rf_sector_index_done_event evt;\n\t} __packed reply = {\n\t\t.evt = {.status = WMI_RF_SECTOR_STATUS_NOT_SUPPORTED_ERROR},\n\t};\n\tstruct sk_buff *msg;\n\n\tif (!test_bit(WMI_FW_CAPABILITY_RF_SECTORS, wil->fw_capabilities))\n\t\treturn -EOPNOTSUPP;\n\n\trc = nla_parse_deprecated(tb, QCA_ATTR_DMG_RF_SECTOR_MAX, data,\n\t\t\t\t  data_len, wil_rf_sector_policy, NULL);\n\tif (rc) {\n\t\twil_err(wil, \"Invalid rf sector ATTR\\n\");\n\t\treturn rc;\n\t}\n\n\tif (!tb[QCA_ATTR_DMG_RF_SECTOR_TYPE]) {\n\t\twil_err(wil, \"Invalid rf sector spec\\n\");\n\t\treturn -EINVAL;\n\t}\n\tsector_type = nla_get_u8(tb[QCA_ATTR_DMG_RF_SECTOR_TYPE]);\n\tif (sector_type >= QCA_ATTR_DMG_RF_SECTOR_TYPE_MAX) {\n\t\twil_err(wil, \"Invalid sector type %d\\n\", sector_type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (tb[QCA_ATTR_MAC_ADDR]) {\n\t\tether_addr_copy(mac_addr, nla_data(tb[QCA_ATTR_MAC_ADDR]));\n\t\tcid = wil_find_cid(wil, vif->mid, mac_addr);\n\t\tif (cid < 0) {\n\t\t\twil_err(wil, \"invalid MAC address %pM\\n\", mac_addr);\n\t\t\treturn -ENOENT;\n\t\t}\n\t} else {\n\t\tif (test_bit(wil_vif_fwconnected, vif->status)) {\n\t\t\twil_err(wil, \"must specify MAC address when connected\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.cid = (u8)cid;\n\tcmd.sector_type = sector_type;\n\trc = wmi_call(wil, WMI_GET_SELECTED_RF_SECTOR_INDEX_CMDID, vif->mid,\n\t\t      &cmd, sizeof(cmd),\n\t\t      WMI_GET_SELECTED_RF_SECTOR_INDEX_DONE_EVENTID,\n\t\t      &reply, sizeof(reply),\n\t\t      500);\n\tif (rc)\n\t\treturn rc;\n\tif (reply.evt.status) {\n\t\twil_err(wil, \"get rf selected sector cfg failed with status %d\\n\",\n\t\t\treply.evt.status);\n\t\treturn wil_rf_sector_status_to_rc(reply.evt.status);\n\t}\n\n\tmsg = cfg80211_vendor_cmd_alloc_reply_skb(\n\t\twiphy, 64 * WMI_MAX_RF_MODULES_NUM);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tif (nla_put_u64_64bit(msg, QCA_ATTR_TSF,\n\t\t\t      le64_to_cpu(reply.evt.tsf),\n\t\t\t      QCA_ATTR_PAD) ||\n\t    nla_put_u16(msg, QCA_ATTR_DMG_RF_SECTOR_INDEX,\n\t\t\tle16_to_cpu(reply.evt.sector_idx)))\n\t\tgoto nla_put_failure;\n\n\trc = cfg80211_vendor_cmd_reply(msg);\n\treturn rc;\nnla_put_failure:\n\tkfree_skb(msg);\n\treturn -ENOBUFS;\n}\n\nstatic int wil_rf_sector_wmi_set_selected(struct wil6210_priv *wil,\n\t\t\t\t\t  u8 mid, u16 sector_index,\n\t\t\t\t\t  u8 sector_type, u8 cid)\n{\n\tstruct wmi_set_selected_rf_sector_index_cmd cmd;\n\tstruct {\n\t\tstruct wmi_cmd_hdr wmi;\n\t\tstruct wmi_set_selected_rf_sector_index_done_event evt;\n\t} __packed reply = {\n\t\t.evt = {.status = WMI_RF_SECTOR_STATUS_NOT_SUPPORTED_ERROR},\n\t};\n\tint rc;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.sector_idx = cpu_to_le16(sector_index);\n\tcmd.sector_type = sector_type;\n\tcmd.cid = (u8)cid;\n\trc = wmi_call(wil, WMI_SET_SELECTED_RF_SECTOR_INDEX_CMDID, mid,\n\t\t      &cmd, sizeof(cmd),\n\t\t      WMI_SET_SELECTED_RF_SECTOR_INDEX_DONE_EVENTID,\n\t\t      &reply, sizeof(reply),\n\t\t      500);\n\tif (rc)\n\t\treturn rc;\n\treturn wil_rf_sector_status_to_rc(reply.evt.status);\n}\n\nstatic int wil_rf_sector_set_selected(struct wiphy *wiphy,\n\t\t\t\t      struct wireless_dev *wdev,\n\t\t\t\t      const void *data, int data_len)\n{\n\tstruct wil6210_priv *wil = wdev_to_wil(wdev);\n\tstruct wil6210_vif *vif = wdev_to_vif(wil, wdev);\n\tint rc;\n\tstruct nlattr *tb[QCA_ATTR_DMG_RF_SECTOR_MAX + 1];\n\tu16 sector_index;\n\tu8 sector_type, mac_addr[ETH_ALEN], i;\n\tint cid = 0;\n\n\tif (!test_bit(WMI_FW_CAPABILITY_RF_SECTORS, wil->fw_capabilities))\n\t\treturn -EOPNOTSUPP;\n\n\trc = nla_parse_deprecated(tb, QCA_ATTR_DMG_RF_SECTOR_MAX, data,\n\t\t\t\t  data_len, wil_rf_sector_policy, NULL);\n\tif (rc) {\n\t\twil_err(wil, \"Invalid rf sector ATTR\\n\");\n\t\treturn rc;\n\t}\n\n\tif (!tb[QCA_ATTR_DMG_RF_SECTOR_INDEX] ||\n\t    !tb[QCA_ATTR_DMG_RF_SECTOR_TYPE]) {\n\t\twil_err(wil, \"Invalid rf sector spec\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tsector_index = nla_get_u16(\n\t\ttb[QCA_ATTR_DMG_RF_SECTOR_INDEX]);\n\tif (sector_index >= WIL_MAX_RF_SECTORS &&\n\t    sector_index != WMI_INVALID_RF_SECTOR_INDEX) {\n\t\twil_err(wil, \"Invalid sector index %d\\n\", sector_index);\n\t\treturn -EINVAL;\n\t}\n\n\tsector_type = nla_get_u8(tb[QCA_ATTR_DMG_RF_SECTOR_TYPE]);\n\tif (sector_type >= QCA_ATTR_DMG_RF_SECTOR_TYPE_MAX) {\n\t\twil_err(wil, \"Invalid sector type %d\\n\", sector_type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (tb[QCA_ATTR_MAC_ADDR]) {\n\t\tether_addr_copy(mac_addr, nla_data(tb[QCA_ATTR_MAC_ADDR]));\n\t\tif (!is_broadcast_ether_addr(mac_addr)) {\n\t\t\tcid = wil_find_cid(wil, vif->mid, mac_addr);\n\t\t\tif (cid < 0) {\n\t\t\t\twil_err(wil, \"invalid MAC address %pM\\n\",\n\t\t\t\t\tmac_addr);\n\t\t\t\treturn -ENOENT;\n\t\t\t}\n\t\t} else {\n\t\t\tif (sector_index != WMI_INVALID_RF_SECTOR_INDEX) {\n\t\t\t\twil_err(wil, \"broadcast MAC valid only with unlocking\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tcid = -1;\n\t\t}\n\t} else {\n\t\tif (test_bit(wil_vif_fwconnected, vif->status)) {\n\t\t\twil_err(wil, \"must specify MAC address when connected\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t}\n\n\tif (cid >= 0) {\n\t\trc = wil_rf_sector_wmi_set_selected(wil, vif->mid, sector_index,\n\t\t\t\t\t\t    sector_type, cid);\n\t} else {\n\t\t \n\t\trc = wil_rf_sector_wmi_set_selected(\n\t\t\twil, vif->mid, WMI_INVALID_RF_SECTOR_INDEX,\n\t\t\tsector_type, WIL_CID_ALL);\n\t\tif (rc == -EINVAL) {\n\t\t\tfor (i = 0; i < wil->max_assoc_sta; i++) {\n\t\t\t\tif (wil->sta[i].mid != vif->mid)\n\t\t\t\t\tcontinue;\n\t\t\t\trc = wil_rf_sector_wmi_set_selected(\n\t\t\t\t\twil, vif->mid,\n\t\t\t\t\tWMI_INVALID_RF_SECTOR_INDEX,\n\t\t\t\t\tsector_type, i);\n\t\t\t\t \n\t\t\t\tif (rc) {\n\t\t\t\t\twil_err(wil, \"unlock cid %d failed with status %d\\n\",\n\t\t\t\t\t\ti, rc);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}