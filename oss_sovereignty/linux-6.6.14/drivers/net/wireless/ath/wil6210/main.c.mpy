{
  "module_name": "main.c",
  "hash_id": "e6c934d6f8f35ca062fc4f4d5d7a8e89d8db4b752299b8f1bf1b8216fb47ecbe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/wil6210/main.c",
  "human_readable_source": "\n \n\n#include <linux/moduleparam.h>\n#include <linux/if_arp.h>\n#include <linux/etherdevice.h>\n#include <linux/rtnetlink.h>\n\n#include \"wil6210.h\"\n#include \"txrx.h\"\n#include \"txrx_edma.h\"\n#include \"wmi.h\"\n#include \"boot_loader.h\"\n\n#define WAIT_FOR_HALP_VOTE_MS 100\n#define WAIT_FOR_SCAN_ABORT_MS 1000\n#define WIL_DEFAULT_NUM_RX_STATUS_RINGS 1\n#define WIL_BOARD_FILE_MAX_NAMELEN 128\n\nbool debug_fw;  \nmodule_param(debug_fw, bool, 0444);\nMODULE_PARM_DESC(debug_fw, \" do not perform card reset. For FW debug\");\n\nstatic u8 oob_mode;\nmodule_param(oob_mode, byte, 0444);\nMODULE_PARM_DESC(oob_mode,\n\t\t \" enable out of the box (OOB) mode in FW, for diagnostics and certification\");\n\nbool no_fw_recovery;\nmodule_param(no_fw_recovery, bool, 0644);\nMODULE_PARM_DESC(no_fw_recovery, \" disable automatic FW error recovery\");\n\n \nunsigned short rx_ring_overflow_thrsh = WIL6210_RX_HIGH_TRSH_INIT;\nmodule_param(rx_ring_overflow_thrsh, ushort, 0444);\nMODULE_PARM_DESC(rx_ring_overflow_thrsh,\n\t\t \" RX ring overflow threshold in descriptors.\");\n\n \nunsigned int mtu_max = TXRX_BUF_LEN_DEFAULT - WIL_MAX_MPDU_OVERHEAD;\nstatic int mtu_max_set(const char *val, const struct kernel_param *kp)\n{\n\tint ret;\n\n\t \n\tret = param_set_uint(val, kp);\n\tif (ret)\n\t\treturn ret;\n\n\tif (mtu_max < 68 || mtu_max > WIL_MAX_ETH_MTU)\n\t\tret = -EINVAL;\n\n\treturn ret;\n}\n\nstatic const struct kernel_param_ops mtu_max_ops = {\n\t.set = mtu_max_set,\n\t.get = param_get_uint,\n};\n\nmodule_param_cb(mtu_max, &mtu_max_ops, &mtu_max, 0444);\nMODULE_PARM_DESC(mtu_max, \" Max MTU value.\");\n\nstatic uint rx_ring_order;\nstatic uint tx_ring_order = WIL_TX_RING_SIZE_ORDER_DEFAULT;\nstatic uint bcast_ring_order = WIL_BCAST_RING_SIZE_ORDER_DEFAULT;\n\nstatic int ring_order_set(const char *val, const struct kernel_param *kp)\n{\n\tint ret;\n\tuint x;\n\n\tret = kstrtouint(val, 0, &x);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((x < WIL_RING_SIZE_ORDER_MIN) || (x > WIL_RING_SIZE_ORDER_MAX))\n\t\treturn -EINVAL;\n\n\t*((uint *)kp->arg) = x;\n\n\treturn 0;\n}\n\nstatic const struct kernel_param_ops ring_order_ops = {\n\t.set = ring_order_set,\n\t.get = param_get_uint,\n};\n\nmodule_param_cb(rx_ring_order, &ring_order_ops, &rx_ring_order, 0444);\nMODULE_PARM_DESC(rx_ring_order, \" Rx ring order; size = 1 << order\");\nmodule_param_cb(tx_ring_order, &ring_order_ops, &tx_ring_order, 0444);\nMODULE_PARM_DESC(tx_ring_order, \" Tx ring order; size = 1 << order\");\nmodule_param_cb(bcast_ring_order, &ring_order_ops, &bcast_ring_order, 0444);\nMODULE_PARM_DESC(bcast_ring_order, \" Bcast ring order; size = 1 << order\");\n\nenum {\n\tWIL_BOOT_ERR,\n\tWIL_BOOT_VANILLA,\n\tWIL_BOOT_PRODUCTION,\n\tWIL_BOOT_DEVELOPMENT,\n};\n\nenum {\n\tWIL_SIG_STATUS_VANILLA = 0x0,\n\tWIL_SIG_STATUS_DEVELOPMENT = 0x1,\n\tWIL_SIG_STATUS_PRODUCTION = 0x2,\n\tWIL_SIG_STATUS_CORRUPTED_PRODUCTION = 0x3,\n};\n\n#define RST_DELAY (20)  \n#define RST_COUNT (1 + 1000/RST_DELAY)  \n\n#define PMU_READY_DELAY_MS (4)  \n\n#define OTP_HW_DELAY (200)  \n \n#define OTP_HW_COUNT (1 + 2000 / OTP_HW_DELAY)\n\n \nvoid wil_memcpy_fromio_32(void *dst, const volatile void __iomem *src,\n\t\t\t  size_t count)\n{\n\tu32 *d = dst;\n\tconst volatile u32 __iomem *s = src;\n\n\tfor (; count >= 4; count -= 4)\n\t\t*d++ = __raw_readl(s++);\n\n\tif (unlikely(count)) {\n\t\t \n\t\tu32 tmp = __raw_readl(s);\n\n\t\tmemcpy(d, &tmp, count);\n\t}\n}\n\nvoid wil_memcpy_toio_32(volatile void __iomem *dst, const void *src,\n\t\t\tsize_t count)\n{\n\tvolatile u32 __iomem *d = dst;\n\tconst u32 *s = src;\n\n\tfor (; count >= 4; count -= 4)\n\t\t__raw_writel(*s++, d++);\n\n\tif (unlikely(count)) {\n\t\t \n\t\tu32 tmp = 0;\n\n\t\tmemcpy(&tmp, s, count);\n\t\t__raw_writel(tmp, d);\n\t}\n}\n\n \nint wil_mem_access_lock(struct wil6210_priv *wil)\n{\n\tif (!down_read_trylock(&wil->mem_lock))\n\t\treturn -EBUSY;\n\n\tif (test_bit(wil_status_suspending, wil->status) ||\n\t    test_bit(wil_status_suspended, wil->status)) {\n\t\tup_read(&wil->mem_lock);\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nvoid wil_mem_access_unlock(struct wil6210_priv *wil)\n{\n\tup_read(&wil->mem_lock);\n}\n\nstatic void wil_ring_fini_tx(struct wil6210_priv *wil, int id)\n{\n\tstruct wil_ring *ring = &wil->ring_tx[id];\n\tstruct wil_ring_tx_data *txdata = &wil->ring_tx_data[id];\n\n\tlockdep_assert_held(&wil->mutex);\n\n\tif (!ring->va)\n\t\treturn;\n\n\twil_dbg_misc(wil, \"vring_fini_tx: id=%d\\n\", id);\n\n\tspin_lock_bh(&txdata->lock);\n\ttxdata->dot1x_open = false;\n\ttxdata->mid = U8_MAX;\n\ttxdata->enabled = 0;  \n\tspin_unlock_bh(&txdata->lock);\n\t \n\twmb();\n\t \n\tif (test_bit(wil_status_napi_en, wil->status))\n\t\tnapi_synchronize(&wil->napi_tx);\n\n\twil->txrx_ops.ring_fini_tx(wil, ring);\n}\n\nstatic bool wil_vif_is_connected(struct wil6210_priv *wil, u8 mid)\n{\n\tint i;\n\n\tfor (i = 0; i < wil->max_assoc_sta; i++) {\n\t\tif (wil->sta[i].mid == mid &&\n\t\t    wil->sta[i].status == wil_sta_connected)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void wil_disconnect_cid_complete(struct wil6210_vif *vif, int cid,\n\t\t\t\t\tu16 reason_code)\n__acquires(&sta->tid_rx_lock) __releases(&sta->tid_rx_lock)\n{\n\tuint i;\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tstruct net_device *ndev = vif_to_ndev(vif);\n\tstruct wireless_dev *wdev = vif_to_wdev(vif);\n\tstruct wil_sta_info *sta = &wil->sta[cid];\n\tint min_ring_id = wil_get_min_tx_ring_id(wil);\n\n\tmight_sleep();\n\twil_dbg_misc(wil,\n\t\t     \"disconnect_cid_complete: CID %d, MID %d, status %d\\n\",\n\t\t     cid, sta->mid, sta->status);\n\t \n\tif (sta->status != wil_sta_unused) {\n\t\tif (vif->mid != sta->mid) {\n\t\t\twil_err(wil, \"STA MID mismatch with VIF MID(%d)\\n\",\n\t\t\t\tvif->mid);\n\t\t}\n\n\t\tswitch (wdev->iftype) {\n\t\tcase NL80211_IFTYPE_AP:\n\t\tcase NL80211_IFTYPE_P2P_GO:\n\t\t\t \n\t\t\tcfg80211_del_sta(ndev, sta->addr, GFP_KERNEL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tsta->status = wil_sta_unused;\n\t\tsta->mid = U8_MAX;\n\t}\n\t \n\tfor (i = 0; i < WIL_STA_TID_NUM; i++) {\n\t\tstruct wil_tid_ampdu_rx *r;\n\n\t\tspin_lock_bh(&sta->tid_rx_lock);\n\n\t\tr = sta->tid_rx[i];\n\t\tsta->tid_rx[i] = NULL;\n\t\twil_tid_ampdu_rx_free(wil, r);\n\n\t\tspin_unlock_bh(&sta->tid_rx_lock);\n\t}\n\t \n\tmemset(sta->tid_crypto_rx, 0, sizeof(sta->tid_crypto_rx));\n\tmemset(&sta->group_crypto_rx, 0, sizeof(sta->group_crypto_rx));\n\t \n\tfor (i = min_ring_id; i < ARRAY_SIZE(wil->ring_tx); i++) {\n\t\tif (wil->ring2cid_tid[i][0] == cid)\n\t\t\twil_ring_fini_tx(wil, i);\n\t}\n\t \n\tmemset(&sta->stats, 0, sizeof(sta->stats));\n\tsta->stats.tx_latency_min_us = U32_MAX;\n}\n\nstatic void _wil6210_disconnect_complete(struct wil6210_vif *vif,\n\t\t\t\t\t const u8 *bssid, u16 reason_code)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tint cid = -ENOENT;\n\tstruct net_device *ndev;\n\tstruct wireless_dev *wdev;\n\n\tndev = vif_to_ndev(vif);\n\twdev = vif_to_wdev(vif);\n\n\tmight_sleep();\n\twil_info(wil, \"disconnect_complete: bssid=%pM, reason=%d\\n\",\n\t\t bssid, reason_code);\n\n\t \n\tif (bssid && !is_broadcast_ether_addr(bssid) &&\n\t    !ether_addr_equal_unaligned(ndev->dev_addr, bssid)) {\n\t\tcid = wil_find_cid(wil, vif->mid, bssid);\n\t\twil_dbg_misc(wil,\n\t\t\t     \"Disconnect complete %pM, CID=%d, reason=%d\\n\",\n\t\t\t     bssid, cid, reason_code);\n\t\tif (wil_cid_valid(wil, cid))  \n\t\t\twil_disconnect_cid_complete(vif, cid, reason_code);\n\t} else {  \n\t\twil_dbg_misc(wil, \"Disconnect complete all\\n\");\n\t\tfor (cid = 0; cid < wil->max_assoc_sta; cid++)\n\t\t\twil_disconnect_cid_complete(vif, cid, reason_code);\n\t}\n\n\t \n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\twil_bcast_fini(vif);\n\t\twil_update_net_queues_bh(wil, vif, NULL, true);\n\t\tnetif_carrier_off(ndev);\n\t\tif (!wil_has_other_active_ifaces(wil, ndev, false, true))\n\t\t\twil6210_bus_request(wil, WIL_DEFAULT_BUS_REQUEST_KBPS);\n\n\t\tif (test_and_clear_bit(wil_vif_fwconnected, vif->status)) {\n\t\t\tatomic_dec(&wil->connected_vifs);\n\t\t\tcfg80211_disconnected(ndev, reason_code,\n\t\t\t\t\t      NULL, 0,\n\t\t\t\t\t      vif->locally_generated_disc,\n\t\t\t\t\t      GFP_KERNEL);\n\t\t\tvif->locally_generated_disc = false;\n\t\t} else if (test_bit(wil_vif_fwconnecting, vif->status)) {\n\t\t\tcfg80211_connect_result(ndev, bssid, NULL, 0, NULL, 0,\n\t\t\t\t\t\tWLAN_STATUS_UNSPECIFIED_FAILURE,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tvif->bss = NULL;\n\t\t}\n\t\tclear_bit(wil_vif_fwconnecting, vif->status);\n\t\tclear_bit(wil_vif_ft_roam, vif->status);\n\t\tvif->ptk_rekey_state = WIL_REKEY_IDLE;\n\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tif (!wil_vif_is_connected(wil, vif->mid)) {\n\t\t\twil_update_net_queues_bh(wil, vif, NULL, true);\n\t\t\tif (test_and_clear_bit(wil_vif_fwconnected,\n\t\t\t\t\t       vif->status))\n\t\t\t\tatomic_dec(&wil->connected_vifs);\n\t\t} else {\n\t\t\twil_update_net_queues_bh(wil, vif, NULL, false);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int wil_disconnect_cid(struct wil6210_vif *vif, int cid,\n\t\t\t      u16 reason_code)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tstruct wireless_dev *wdev = vif_to_wdev(vif);\n\tstruct wil_sta_info *sta = &wil->sta[cid];\n\tbool del_sta = false;\n\n\tmight_sleep();\n\twil_dbg_misc(wil, \"disconnect_cid: CID %d, MID %d, status %d\\n\",\n\t\t     cid, sta->mid, sta->status);\n\n\tif (sta->status == wil_sta_unused)\n\t\treturn 0;\n\n\tif (vif->mid != sta->mid) {\n\t\twil_err(wil, \"STA MID mismatch with VIF MID(%d)\\n\", vif->mid);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (wdev->iftype == NL80211_IFTYPE_AP && disable_ap_sme)\n\t\tdel_sta = true;\n\n\t \n\treturn wmi_disconnect_sta(vif, sta->addr, reason_code, del_sta);\n}\n\nstatic void _wil6210_disconnect(struct wil6210_vif *vif, const u8 *bssid,\n\t\t\t\tu16 reason_code)\n{\n\tstruct wil6210_priv *wil;\n\tstruct net_device *ndev;\n\tint cid = -ENOENT;\n\n\tif (unlikely(!vif))\n\t\treturn;\n\n\twil = vif_to_wil(vif);\n\tndev = vif_to_ndev(vif);\n\n\tmight_sleep();\n\twil_info(wil, \"disconnect bssid=%pM, reason=%d\\n\", bssid, reason_code);\n\n\t \n\tif (bssid && !is_broadcast_ether_addr(bssid) &&\n\t    !ether_addr_equal_unaligned(ndev->dev_addr, bssid)) {\n\t\tcid = wil_find_cid(wil, vif->mid, bssid);\n\t\twil_dbg_misc(wil, \"Disconnect %pM, CID=%d, reason=%d\\n\",\n\t\t\t     bssid, cid, reason_code);\n\t\tif (wil_cid_valid(wil, cid))  \n\t\t\twil_disconnect_cid(vif, cid, reason_code);\n\t} else {  \n\t\twil_dbg_misc(wil, \"Disconnect all\\n\");\n\t\tfor (cid = 0; cid < wil->max_assoc_sta; cid++)\n\t\t\twil_disconnect_cid(vif, cid, reason_code);\n\t}\n\n\t \n\t_wil6210_disconnect_complete(vif, bssid, reason_code);\n}\n\nvoid wil_disconnect_worker(struct work_struct *work)\n{\n\tstruct wil6210_vif *vif = container_of(work,\n\t\t\tstruct wil6210_vif, disconnect_worker);\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tstruct net_device *ndev = vif_to_ndev(vif);\n\tint rc;\n\tstruct {\n\t\tstruct wmi_cmd_hdr wmi;\n\t\tstruct wmi_disconnect_event evt;\n\t} __packed reply;\n\n\tif (test_bit(wil_vif_fwconnected, vif->status))\n\t\t \n\t\treturn;\n\n\tif (!test_bit(wil_vif_fwconnecting, vif->status))\n\t\t \n\t\treturn;\n\n\tmemset(&reply, 0, sizeof(reply));\n\n\trc = wmi_call(wil, WMI_DISCONNECT_CMDID, vif->mid, NULL, 0,\n\t\t      WMI_DISCONNECT_EVENTID, &reply, sizeof(reply),\n\t\t      WIL6210_DISCONNECT_TO_MS);\n\tif (rc) {\n\t\twil_err(wil, \"disconnect error %d\\n\", rc);\n\t\treturn;\n\t}\n\n\twil_update_net_queues_bh(wil, vif, NULL, true);\n\tnetif_carrier_off(ndev);\n\tcfg80211_connect_result(ndev, NULL, NULL, 0, NULL, 0,\n\t\t\t\tWLAN_STATUS_UNSPECIFIED_FAILURE, GFP_KERNEL);\n\tclear_bit(wil_vif_fwconnecting, vif->status);\n}\n\nstatic int wil_wait_for_recovery(struct wil6210_priv *wil)\n{\n\tif (wait_event_interruptible(wil->wq, wil->recovery_state !=\n\t\t\t\t     fw_recovery_pending)) {\n\t\twil_err(wil, \"Interrupt, canceling recovery\\n\");\n\t\treturn -ERESTARTSYS;\n\t}\n\tif (wil->recovery_state != fw_recovery_running) {\n\t\twil_info(wil, \"Recovery cancelled\\n\");\n\t\treturn -EINTR;\n\t}\n\twil_info(wil, \"Proceed with recovery\\n\");\n\treturn 0;\n}\n\nvoid wil_set_recovery_state(struct wil6210_priv *wil, int state)\n{\n\twil_dbg_misc(wil, \"set_recovery_state: %d -> %d\\n\",\n\t\t     wil->recovery_state, state);\n\n\twil->recovery_state = state;\n\twake_up_interruptible(&wil->wq);\n}\n\nbool wil_is_recovery_blocked(struct wil6210_priv *wil)\n{\n\treturn no_fw_recovery && (wil->recovery_state == fw_recovery_pending);\n}\n\nstatic void wil_fw_error_worker(struct work_struct *work)\n{\n\tstruct wil6210_priv *wil = container_of(work, struct wil6210_priv,\n\t\t\t\t\t\tfw_error_worker);\n\tstruct net_device *ndev = wil->main_ndev;\n\tstruct wireless_dev *wdev;\n\n\twil_dbg_misc(wil, \"fw error worker\\n\");\n\n\tif (!ndev || !(ndev->flags & IFF_UP)) {\n\t\twil_info(wil, \"No recovery - interface is down\\n\");\n\t\treturn;\n\t}\n\twdev = ndev->ieee80211_ptr;\n\n\t \n\tif (time_is_after_jiffies(wil->last_fw_recovery +\n\t\t\t\t  WIL6210_FW_RECOVERY_TO))\n\t\twil->recovery_count++;\n\telse\n\t\twil->recovery_count = 1;  \n\n\tif (wil->recovery_count > WIL6210_FW_RECOVERY_RETRIES) {\n\t\twil_err(wil, \"too many recovery attempts (%d), giving up\\n\",\n\t\t\twil->recovery_count);\n\t\treturn;\n\t}\n\n\twil->last_fw_recovery = jiffies;\n\n\twil_info(wil, \"fw error recovery requested (try %d)...\\n\",\n\t\t wil->recovery_count);\n\tif (!no_fw_recovery)\n\t\twil->recovery_state = fw_recovery_running;\n\tif (wil_wait_for_recovery(wil) != 0)\n\t\treturn;\n\n\trtnl_lock();\n\tmutex_lock(&wil->mutex);\n\t \n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_MONITOR:\n\t\t \n\t\t__wil_down(wil);\n\t\t__wil_up(wil);\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tif (no_fw_recovery)  \n\t\t\tbreak;\n\t\t \n\t\t__wil_down(wil);\n\t\t__wil_up(wil);\n\t\tmutex_unlock(&wil->mutex);\n\t\twil_cfg80211_ap_recovery(wil);\n\t\tmutex_lock(&wil->mutex);\n\t\twil_info(wil, \"... completed\\n\");\n\t\tbreak;\n\tdefault:\n\t\twil_err(wil, \"No recovery - unknown interface type %d\\n\",\n\t\t\twdev->iftype);\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&wil->mutex);\n\trtnl_unlock();\n}\n\nstatic int wil_find_free_ring(struct wil6210_priv *wil)\n{\n\tint i;\n\tint min_ring_id = wil_get_min_tx_ring_id(wil);\n\n\tfor (i = min_ring_id; i < WIL6210_MAX_TX_RINGS; i++) {\n\t\tif (!wil->ring_tx[i].va)\n\t\t\treturn i;\n\t}\n\treturn -EINVAL;\n}\n\nint wil_ring_init_tx(struct wil6210_vif *vif, int cid)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tint rc = -EINVAL, ringid;\n\n\tif (cid < 0) {\n\t\twil_err(wil, \"No connection pending\\n\");\n\t\tgoto out;\n\t}\n\tringid = wil_find_free_ring(wil);\n\tif (ringid < 0) {\n\t\twil_err(wil, \"No free vring found\\n\");\n\t\tgoto out;\n\t}\n\n\twil_dbg_wmi(wil, \"Configure for connection CID %d MID %d ring %d\\n\",\n\t\t    cid, vif->mid, ringid);\n\n\trc = wil->txrx_ops.ring_init_tx(vif, ringid, 1 << tx_ring_order,\n\t\t\t\t\tcid, 0);\n\tif (rc)\n\t\twil_err(wil, \"init TX for CID %d MID %d vring %d failed\\n\",\n\t\t\tcid, vif->mid, ringid);\n\nout:\n\treturn rc;\n}\n\nint wil_bcast_init(struct wil6210_vif *vif)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tint ri = vif->bcast_ring, rc;\n\n\tif (ri >= 0 && wil->ring_tx[ri].va)\n\t\treturn 0;\n\n\tri = wil_find_free_ring(wil);\n\tif (ri < 0)\n\t\treturn ri;\n\n\tvif->bcast_ring = ri;\n\trc = wil->txrx_ops.ring_init_bcast(vif, ri, 1 << bcast_ring_order);\n\tif (rc)\n\t\tvif->bcast_ring = -1;\n\n\treturn rc;\n}\n\nvoid wil_bcast_fini(struct wil6210_vif *vif)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tint ri = vif->bcast_ring;\n\n\tif (ri < 0)\n\t\treturn;\n\n\tvif->bcast_ring = -1;\n\twil_ring_fini_tx(wil, ri);\n}\n\nvoid wil_bcast_fini_all(struct wil6210_priv *wil)\n{\n\tint i;\n\tstruct wil6210_vif *vif;\n\n\tfor (i = 0; i < GET_MAX_VIFS(wil); i++) {\n\t\tvif = wil->vifs[i];\n\t\tif (vif)\n\t\t\twil_bcast_fini(vif);\n\t}\n}\n\nint wil_priv_init(struct wil6210_priv *wil)\n{\n\tuint i;\n\n\twil_dbg_misc(wil, \"priv_init\\n\");\n\n\tmemset(wil->sta, 0, sizeof(wil->sta));\n\tfor (i = 0; i < WIL6210_MAX_CID; i++) {\n\t\tspin_lock_init(&wil->sta[i].tid_rx_lock);\n\t\twil->sta[i].mid = U8_MAX;\n\t}\n\n\tfor (i = 0; i < WIL6210_MAX_TX_RINGS; i++) {\n\t\tspin_lock_init(&wil->ring_tx_data[i].lock);\n\t\twil->ring2cid_tid[i][0] = WIL6210_MAX_CID;\n\t}\n\n\tmutex_init(&wil->mutex);\n\tmutex_init(&wil->vif_mutex);\n\tmutex_init(&wil->wmi_mutex);\n\tmutex_init(&wil->halp.lock);\n\n\tinit_completion(&wil->wmi_ready);\n\tinit_completion(&wil->wmi_call);\n\tinit_completion(&wil->halp.comp);\n\n\tINIT_WORK(&wil->wmi_event_worker, wmi_event_worker);\n\tINIT_WORK(&wil->fw_error_worker, wil_fw_error_worker);\n\n\tINIT_LIST_HEAD(&wil->pending_wmi_ev);\n\tspin_lock_init(&wil->wmi_ev_lock);\n\tspin_lock_init(&wil->net_queue_lock);\n\tspin_lock_init(&wil->eap_lock);\n\n\tinit_waitqueue_head(&wil->wq);\n\tinit_rwsem(&wil->mem_lock);\n\n\twil->wmi_wq = create_singlethread_workqueue(WIL_NAME \"_wmi\");\n\tif (!wil->wmi_wq)\n\t\treturn -EAGAIN;\n\n\twil->wq_service = create_singlethread_workqueue(WIL_NAME \"_service\");\n\tif (!wil->wq_service)\n\t\tgoto out_wmi_wq;\n\n\twil->last_fw_recovery = jiffies;\n\twil->tx_interframe_timeout = WIL6210_ITR_TX_INTERFRAME_TIMEOUT_DEFAULT;\n\twil->rx_interframe_timeout = WIL6210_ITR_RX_INTERFRAME_TIMEOUT_DEFAULT;\n\twil->tx_max_burst_duration = WIL6210_ITR_TX_MAX_BURST_DURATION_DEFAULT;\n\twil->rx_max_burst_duration = WIL6210_ITR_RX_MAX_BURST_DURATION_DEFAULT;\n\n\tif (rx_ring_overflow_thrsh == WIL6210_RX_HIGH_TRSH_INIT)\n\t\trx_ring_overflow_thrsh = WIL6210_RX_HIGH_TRSH_DEFAULT;\n\n\twil->ps_profile =  WMI_PS_PROFILE_TYPE_DEFAULT;\n\n\twil->wakeup_trigger = WMI_WAKEUP_TRIGGER_UCAST |\n\t\t\t      WMI_WAKEUP_TRIGGER_BCAST;\n\tmemset(&wil->suspend_stats, 0, sizeof(wil->suspend_stats));\n\twil->ring_idle_trsh = 16;\n\n\twil->reply_mid = U8_MAX;\n\twil->max_vifs = 1;\n\twil->max_assoc_sta = max_assoc_sta;\n\n\t \n\twil->num_rx_status_rings = WIL_DEFAULT_NUM_RX_STATUS_RINGS;\n\twil->tx_status_ring_order = WIL_TX_SRING_SIZE_ORDER_DEFAULT;\n\n\t \n\twil->rx_status_ring_order = WIL_RX_SRING_SIZE_ORDER_DEFAULT;\n\t \n\twil->rx_buff_id_count = WIL_RX_BUFF_ARR_SIZE_DEFAULT;\n\n\twil->amsdu_en = true;\n\n\treturn 0;\n\nout_wmi_wq:\n\tdestroy_workqueue(wil->wmi_wq);\n\n\treturn -EAGAIN;\n}\n\nvoid wil6210_bus_request(struct wil6210_priv *wil, u32 kbps)\n{\n\tif (wil->platform_ops.bus_request) {\n\t\twil->bus_request_kbps = kbps;\n\t\twil->platform_ops.bus_request(wil->platform_handle, kbps);\n\t}\n}\n\n \nvoid wil6210_disconnect(struct wil6210_vif *vif, const u8 *bssid,\n\t\t\tu16 reason_code)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\n\twil_dbg_misc(wil, \"disconnecting\\n\");\n\n\tdel_timer_sync(&vif->connect_timer);\n\t_wil6210_disconnect(vif, bssid, reason_code);\n}\n\n \nvoid wil6210_disconnect_complete(struct wil6210_vif *vif, const u8 *bssid,\n\t\t\t\t u16 reason_code)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\n\twil_dbg_misc(wil, \"got disconnect\\n\");\n\n\tdel_timer_sync(&vif->connect_timer);\n\t_wil6210_disconnect_complete(vif, bssid, reason_code);\n}\n\nvoid wil_priv_deinit(struct wil6210_priv *wil)\n{\n\twil_dbg_misc(wil, \"priv_deinit\\n\");\n\n\twil_set_recovery_state(wil, fw_recovery_idle);\n\tcancel_work_sync(&wil->fw_error_worker);\n\twmi_event_flush(wil);\n\tdestroy_workqueue(wil->wq_service);\n\tdestroy_workqueue(wil->wmi_wq);\n\tkfree(wil->brd_info);\n}\n\nstatic void wil_shutdown_bl(struct wil6210_priv *wil)\n{\n\tu32 val;\n\n\twil_s(wil, RGF_USER_BL +\n\t      offsetof(struct bl_dedicated_registers_v1,\n\t\t       bl_shutdown_handshake), BL_SHUTDOWN_HS_GRTD);\n\n\tusleep_range(100, 150);\n\n\tval = wil_r(wil, RGF_USER_BL +\n\t\t    offsetof(struct bl_dedicated_registers_v1,\n\t\t\t     bl_shutdown_handshake));\n\tif (val & BL_SHUTDOWN_HS_RTD) {\n\t\twil_dbg_misc(wil, \"BL is ready for halt\\n\");\n\t\treturn;\n\t}\n\n\twil_err(wil, \"BL did not report ready for halt\\n\");\n}\n\n \nstatic inline u32 ARC_me_imm32(u32 d)\n{\n\treturn ((d & 0xffff0000) >> 16) | ((d & 0x0000ffff) << 16);\n}\n\n \n#define ARC_IRQ_VECTOR_OFFSET(N)\t((N) * 8)\n \n#define ARC_JAL_INST\t\t\t(0x20200f80)\n\nstatic void wil_freeze_bl(struct wil6210_priv *wil)\n{\n\tu32 jal, upc, saved;\n\tu32 ivt3 = ARC_IRQ_VECTOR_OFFSET(3);\n\n\tjal = wil_r(wil, wil->iccm_base + ivt3);\n\tif (jal != ARC_me_imm32(ARC_JAL_INST)) {\n\t\twil_dbg_misc(wil, \"invalid IVT entry found, skipping\\n\");\n\t\treturn;\n\t}\n\n\t \n\tsaved = wil_r(wil, RGF_USER_USAGE_8);\n\twil_w(wil, RGF_USER_USAGE_8, saved | BIT_USER_PREVENT_DEEP_SLEEP);\n\tusleep_range(20, 25);  \n\n\t \n\twil_w(wil, wil->iccm_base + ivt3 + 4, ARC_me_imm32(ivt3));\n\tusleep_range(20, 25);  \n\n\t \n\tupc = wil_r(wil, RGF_USER_CPU_PC);\n\tif (upc < ivt3 || (upc > (ivt3 + 8)))\n\t\twil_dbg_misc(wil, \"BL freeze failed, PC=0x%08X\\n\", upc);\n\n\twil_w(wil, RGF_USER_USAGE_8, saved);\n}\n\nstatic void wil_bl_prepare_halt(struct wil6210_priv *wil)\n{\n\tu32 tmp, ver;\n\n\t \n\ttmp = wil_r(wil, RGF_USER_BL +\n\t\t    offsetof(struct bl_dedicated_registers_v0,\n\t\t\t     boot_loader_struct_version));\n\tif (!tmp) {\n\t\twil_dbg_misc(wil, \"old BL, skipping halt preparation\\n\");\n\t\treturn;\n\t}\n\n\ttmp = wil_r(wil, RGF_USER_BL +\n\t\t    offsetof(struct bl_dedicated_registers_v1,\n\t\t\t     bl_shutdown_handshake));\n\tver = BL_SHUTDOWN_HS_PROT_VER(tmp);\n\n\tif (ver > 0)\n\t\twil_shutdown_bl(wil);\n\telse\n\t\twil_freeze_bl(wil);\n}\n\nstatic inline void wil_halt_cpu(struct wil6210_priv *wil)\n{\n\tif (wil->hw_version >= HW_VER_TALYN_MB) {\n\t\twil_w(wil, RGF_USER_USER_CPU_0_TALYN_MB,\n\t\t      BIT_USER_USER_CPU_MAN_RST);\n\t\twil_w(wil, RGF_USER_MAC_CPU_0_TALYN_MB,\n\t\t      BIT_USER_MAC_CPU_MAN_RST);\n\t} else {\n\t\twil_w(wil, RGF_USER_USER_CPU_0, BIT_USER_USER_CPU_MAN_RST);\n\t\twil_w(wil, RGF_USER_MAC_CPU_0,  BIT_USER_MAC_CPU_MAN_RST);\n\t}\n}\n\nstatic inline void wil_release_cpu(struct wil6210_priv *wil)\n{\n\t \n\tif (wil->hw_version >= HW_VER_TALYN_MB)\n\t\twil_w(wil, RGF_USER_USER_CPU_0_TALYN_MB, 1);\n\telse\n\t\twil_w(wil, RGF_USER_USER_CPU_0, 1);\n}\n\nstatic void wil_set_oob_mode(struct wil6210_priv *wil, u8 mode)\n{\n\twil_info(wil, \"oob_mode to %d\\n\", mode);\n\tswitch (mode) {\n\tcase 0:\n\t\twil_c(wil, RGF_USER_USAGE_6, BIT_USER_OOB_MODE |\n\t\t      BIT_USER_OOB_R2_MODE);\n\t\tbreak;\n\tcase 1:\n\t\twil_c(wil, RGF_USER_USAGE_6, BIT_USER_OOB_R2_MODE);\n\t\twil_s(wil, RGF_USER_USAGE_6, BIT_USER_OOB_MODE);\n\t\tbreak;\n\tcase 2:\n\t\twil_c(wil, RGF_USER_USAGE_6, BIT_USER_OOB_MODE);\n\t\twil_s(wil, RGF_USER_USAGE_6, BIT_USER_OOB_R2_MODE);\n\t\tbreak;\n\tdefault:\n\t\twil_err(wil, \"invalid oob_mode: %d\\n\", mode);\n\t}\n}\n\nstatic int wil_wait_device_ready(struct wil6210_priv *wil, int no_flash)\n{\n\tint delay = 0;\n\tu32 x, x1 = 0;\n\n\t \n\tif (no_flash) {\n\t\tmsleep(PMU_READY_DELAY_MS);\n\n\t\twil_dbg_misc(wil, \"Reset completed\\n\");\n\t} else {\n\t\tdo {\n\t\t\tmsleep(RST_DELAY);\n\t\t\tx = wil_r(wil, RGF_USER_BL +\n\t\t\t\t  offsetof(struct bl_dedicated_registers_v0,\n\t\t\t\t\t   boot_loader_ready));\n\t\t\tif (x1 != x) {\n\t\t\t\twil_dbg_misc(wil, \"BL.ready 0x%08x => 0x%08x\\n\",\n\t\t\t\t\t     x1, x);\n\t\t\t\tx1 = x;\n\t\t\t}\n\t\t\tif (delay++ > RST_COUNT) {\n\t\t\t\twil_err(wil, \"Reset not completed, bl.ready 0x%08x\\n\",\n\t\t\t\t\tx);\n\t\t\t\treturn -ETIME;\n\t\t\t}\n\t\t} while (x != BL_READY);\n\n\t\twil_dbg_misc(wil, \"Reset completed in %d ms\\n\",\n\t\t\t     delay * RST_DELAY);\n\t}\n\n\treturn 0;\n}\n\nstatic int wil_wait_device_ready_talyn_mb(struct wil6210_priv *wil)\n{\n\tu32 otp_hw;\n\tu8 signature_status;\n\tbool otp_signature_err;\n\tbool hw_section_done;\n\tu32 otp_qc_secured;\n\tint delay = 0;\n\n\t \n\tusleep_range(2000, 2200);\n\n\twil->boot_config = WIL_BOOT_ERR;\n\n\t \n\tdo {\n\t\totp_hw = wil_r(wil, RGF_USER_OTP_HW_RD_MACHINE_1);\n\t\tsignature_status = WIL_GET_BITS(otp_hw, 8, 9);\n\t\totp_signature_err = otp_hw & BIT_OTP_SIGNATURE_ERR_TALYN_MB;\n\n\t\tif (otp_signature_err &&\n\t\t    signature_status == WIL_SIG_STATUS_VANILLA) {\n\t\t\twil->boot_config = WIL_BOOT_VANILLA;\n\t\t\tbreak;\n\t\t}\n\t\tif (otp_signature_err &&\n\t\t    signature_status == WIL_SIG_STATUS_DEVELOPMENT) {\n\t\t\twil->boot_config = WIL_BOOT_DEVELOPMENT;\n\t\t\tbreak;\n\t\t}\n\t\tif (!otp_signature_err &&\n\t\t    signature_status == WIL_SIG_STATUS_PRODUCTION) {\n\t\t\twil->boot_config = WIL_BOOT_PRODUCTION;\n\t\t\tbreak;\n\t\t}\n\t\tif  (!otp_signature_err &&\n\t\t     signature_status ==\n\t\t     WIL_SIG_STATUS_CORRUPTED_PRODUCTION) {\n\t\t\t \n\t\t\twil->boot_config = WIL_BOOT_PRODUCTION;\n\t\t\tbreak;\n\t\t}\n\t\tif (delay++ > OTP_HW_COUNT)\n\t\t\tbreak;\n\n\t\tusleep_range(OTP_HW_DELAY, OTP_HW_DELAY + 10);\n\t} while (!otp_signature_err && signature_status == 0);\n\n\tif (wil->boot_config == WIL_BOOT_ERR) {\n\t\twil_err(wil,\n\t\t\t\"invalid boot config, signature_status %d otp_signature_err %d\\n\",\n\t\t\tsignature_status, otp_signature_err);\n\t\treturn -ETIME;\n\t}\n\n\twil_dbg_misc(wil,\n\t\t     \"signature test done in %d usec, otp_hw 0x%x, boot_config %d\\n\",\n\t\t     delay * OTP_HW_DELAY, otp_hw, wil->boot_config);\n\n\tif (wil->boot_config == WIL_BOOT_VANILLA)\n\t\t \n\t\tgoto out;\n\n\thw_section_done = otp_hw & BIT_OTP_HW_SECTION_DONE_TALYN_MB;\n\tdelay = 0;\n\n\twhile (!hw_section_done) {\n\t\tmsleep(RST_DELAY);\n\n\t\totp_hw = wil_r(wil, RGF_USER_OTP_HW_RD_MACHINE_1);\n\t\thw_section_done = otp_hw & BIT_OTP_HW_SECTION_DONE_TALYN_MB;\n\n\t\tif (delay++ > RST_COUNT) {\n\t\t\twil_err(wil, \"TO waiting for hw_section_done\\n\");\n\t\t\treturn -ETIME;\n\t\t}\n\t}\n\n\twil_dbg_misc(wil, \"HW section done in %d ms\\n\", delay * RST_DELAY);\n\n\totp_qc_secured = wil_r(wil, RGF_OTP_QC_SECURED);\n\twil->secured_boot = otp_qc_secured & BIT_BOOT_FROM_ROM ? 1 : 0;\n\twil_dbg_misc(wil, \"secured boot is %sabled\\n\",\n\t\t     wil->secured_boot ? \"en\" : \"dis\");\n\nout:\n\twil_dbg_misc(wil, \"Reset completed\\n\");\n\n\treturn 0;\n}\n\nstatic int wil_target_reset(struct wil6210_priv *wil, int no_flash)\n{\n\tu32 x;\n\tint rc;\n\n\twil_dbg_misc(wil, \"Resetting \\\"%s\\\"...\\n\", wil->hw_name);\n\n\tif (wil->hw_version < HW_VER_TALYN) {\n\t\t \n\t\twil_s(wil, RGF_HP_CTRL, BIT(15));\n\t\twil_s(wil, RGF_USER_CLKS_CTL_SW_RST_MASK_0,\n\t\t      BIT_HPAL_PERST_FROM_PAD);\n\t\twil_s(wil, RGF_USER_CLKS_CTL_SW_RST_MASK_0, BIT_CAR_PERST_RST);\n\t}\n\n\twil_halt_cpu(wil);\n\n\tif (!no_flash) {\n\t\t \n\t\twil_w(wil, RGF_USER_BL +\n\t\t      offsetof(struct bl_dedicated_registers_v0,\n\t\t\t       boot_loader_ready), 0);\n\t\t \n\t\twil_w(wil, RGF_USER_BL +\n\t\t      offsetof(struct bl_dedicated_registers_v1,\n\t\t\t       bl_shutdown_handshake), 0);\n\t}\n\t \n\twil_c(wil, RGF_USER_USAGE_6, BIT(0));\n\n\twil_s(wil, RGF_CAF_OSC_CONTROL, BIT_CAF_OSC_XTAL_EN);\n\t \n\tusleep_range(5000, 7000);\n\tx = wil_r(wil, RGF_CAF_PLL_LOCK_STATUS);\n\tif (!(x & BIT_CAF_OSC_DIG_XTAL_STABLE)) {\n\t\twil_err(wil, \"Xtal stabilization timeout\\n\"\n\t\t\t\"RGF_CAF_PLL_LOCK_STATUS = 0x%08x\\n\", x);\n\t\treturn -ETIME;\n\t}\n\t \n\twil_c(wil, RGF_USER_SPARROW_M_4, BIT_SPARROW_M_4_SEL_SLEEP_OR_REF);\n\t \n\twil_c(wil, RGF_USER_CLKS_CTL_0, BIT_USER_CLKS_CAR_AHB_SW_SEL);\n\n\twil_w(wil, RGF_USER_CLKS_CTL_EXT_SW_RST_VEC_0, 0x3ff81f);\n\twil_w(wil, RGF_USER_CLKS_CTL_EXT_SW_RST_VEC_1, 0xf);\n\n\tif (wil->hw_version >= HW_VER_TALYN_MB) {\n\t\twil_w(wil, RGF_USER_CLKS_CTL_SW_RST_VEC_2, 0x7e000000);\n\t\twil_w(wil, RGF_USER_CLKS_CTL_SW_RST_VEC_1, 0x0000003f);\n\t\twil_w(wil, RGF_USER_CLKS_CTL_SW_RST_VEC_3, 0xc00000f0);\n\t\twil_w(wil, RGF_USER_CLKS_CTL_SW_RST_VEC_0, 0xffe7fe00);\n\t} else {\n\t\twil_w(wil, RGF_USER_CLKS_CTL_SW_RST_VEC_2, 0xfe000000);\n\t\twil_w(wil, RGF_USER_CLKS_CTL_SW_RST_VEC_1, 0x0000003f);\n\t\twil_w(wil, RGF_USER_CLKS_CTL_SW_RST_VEC_3, 0x000000f0);\n\t\twil_w(wil, RGF_USER_CLKS_CTL_SW_RST_VEC_0, 0xffe7fe00);\n\t}\n\n\twil_w(wil, RGF_USER_CLKS_CTL_EXT_SW_RST_VEC_0, 0x0);\n\twil_w(wil, RGF_USER_CLKS_CTL_EXT_SW_RST_VEC_1, 0x0);\n\n\twil_w(wil, RGF_USER_CLKS_CTL_SW_RST_VEC_3, 0);\n\twil_w(wil, RGF_USER_CLKS_CTL_SW_RST_VEC_2, 0);\n\twil_w(wil, RGF_USER_CLKS_CTL_SW_RST_VEC_1, 0);\n\twil_w(wil, RGF_USER_CLKS_CTL_SW_RST_VEC_0, 0);\n\n\twil_w(wil, RGF_USER_CLKS_CTL_SW_RST_VEC_3, 0x00000003);\n\t \n\twil_w(wil, RGF_USER_CLKS_CTL_SW_RST_VEC_2, 0x00008000);\n\n\twil_w(wil, RGF_USER_CLKS_CTL_SW_RST_VEC_0, 0);\n\n\tif (wil->hw_version == HW_VER_TALYN_MB)\n\t\trc = wil_wait_device_ready_talyn_mb(wil);\n\telse\n\t\trc = wil_wait_device_ready(wil, no_flash);\n\tif (rc)\n\t\treturn rc;\n\n\twil_c(wil, RGF_USER_CLKS_CTL_0, BIT_USER_CLKS_RST_PWGD);\n\n\t \n\twil_s(wil, RGF_DMA_OFUL_NID_0, BIT_DMA_OFUL_NID_0_RX_EXT_TR_EN |\n\t      BIT_DMA_OFUL_NID_0_RX_EXT_A3_SRC);\n\n\tif (wil->hw_version < HW_VER_TALYN_MB && no_flash) {\n\t\t \n\t\twil_w(wil, RGF_USER_XPM_IFC_RD_TIME1, 0x60001);\n\t\twil_w(wil, RGF_USER_XPM_IFC_RD_TIME2, 0x20027);\n\t\twil_w(wil, RGF_USER_XPM_IFC_RD_TIME3, 0x1);\n\t\twil_w(wil, RGF_USER_XPM_IFC_RD_TIME4, 0x20027);\n\t\twil_w(wil, RGF_USER_XPM_IFC_RD_TIME5, 0x30003);\n\t\twil_w(wil, RGF_USER_XPM_IFC_RD_TIME6, 0x20002);\n\t\twil_w(wil, RGF_USER_XPM_IFC_RD_TIME7, 0x60001);\n\t\twil_w(wil, RGF_USER_XPM_IFC_RD_TIME8, 0x60001);\n\t\twil_w(wil, RGF_USER_XPM_IFC_RD_TIME9, 0x60001);\n\t\twil_w(wil, RGF_USER_XPM_IFC_RD_TIME10, 0x60001);\n\t\twil_w(wil, RGF_USER_XPM_RD_DOUT_SAMPLE_TIME, 0x57);\n\t}\n\n\treturn 0;\n}\n\nstatic void wil_collect_fw_info(struct wil6210_priv *wil)\n{\n\tstruct wiphy *wiphy = wil_to_wiphy(wil);\n\tu8 retry_short;\n\tint rc;\n\n\twil_refresh_fw_capabilities(wil);\n\n\trc = wmi_get_mgmt_retry(wil, &retry_short);\n\tif (!rc) {\n\t\twiphy->retry_short = retry_short;\n\t\twil_dbg_misc(wil, \"FW retry_short: %d\\n\", retry_short);\n\t}\n}\n\nvoid wil_refresh_fw_capabilities(struct wil6210_priv *wil)\n{\n\tstruct wiphy *wiphy = wil_to_wiphy(wil);\n\tint features;\n\n\twil->keep_radio_on_during_sleep =\n\t\ttest_bit(WIL_PLATFORM_CAPA_RADIO_ON_IN_SUSPEND,\n\t\t\t wil->platform_capa) &&\n\t\ttest_bit(WMI_FW_CAPABILITY_D3_SUSPEND, wil->fw_capabilities);\n\n\twil_info(wil, \"keep_radio_on_during_sleep (%d)\\n\",\n\t\t wil->keep_radio_on_during_sleep);\n\n\tif (test_bit(WMI_FW_CAPABILITY_RSSI_REPORTING, wil->fw_capabilities))\n\t\twiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;\n\telse\n\t\twiphy->signal_type = CFG80211_SIGNAL_TYPE_UNSPEC;\n\n\tif (test_bit(WMI_FW_CAPABILITY_PNO, wil->fw_capabilities)) {\n\t\twiphy->max_sched_scan_reqs = 1;\n\t\twiphy->max_sched_scan_ssids = WMI_MAX_PNO_SSID_NUM;\n\t\twiphy->max_match_sets = WMI_MAX_PNO_SSID_NUM;\n\t\twiphy->max_sched_scan_ie_len = WMI_MAX_IE_LEN;\n\t\twiphy->max_sched_scan_plans = WMI_MAX_PLANS_NUM;\n\t}\n\n\tif (test_bit(WMI_FW_CAPABILITY_TX_REQ_EXT, wil->fw_capabilities))\n\t\twiphy->flags |= WIPHY_FLAG_OFFCHAN_TX;\n\n\tif (wil->platform_ops.set_features) {\n\t\tfeatures = (test_bit(WMI_FW_CAPABILITY_REF_CLOCK_CONTROL,\n\t\t\t\t     wil->fw_capabilities) &&\n\t\t\t    test_bit(WIL_PLATFORM_CAPA_EXT_CLK,\n\t\t\t\t     wil->platform_capa)) ?\n\t\t\tBIT(WIL_PLATFORM_FEATURE_FW_EXT_CLK_CONTROL) : 0;\n\n\t\tif (wil->n_msi == 3)\n\t\t\tfeatures |= BIT(WIL_PLATFORM_FEATURE_TRIPLE_MSI);\n\n\t\twil->platform_ops.set_features(wil->platform_handle, features);\n\t}\n\n\tif (test_bit(WMI_FW_CAPABILITY_BACK_WIN_SIZE_64,\n\t\t     wil->fw_capabilities)) {\n\t\twil->max_agg_wsize = WIL_MAX_AGG_WSIZE_64;\n\t\twil->max_ampdu_size = WIL_MAX_AMPDU_SIZE_128;\n\t} else {\n\t\twil->max_agg_wsize = WIL_MAX_AGG_WSIZE;\n\t\twil->max_ampdu_size = WIL_MAX_AMPDU_SIZE;\n\t}\n\n\tupdate_supported_bands(wil);\n}\n\nvoid wil_mbox_ring_le2cpus(struct wil6210_mbox_ring *r)\n{\n\tle32_to_cpus(&r->base);\n\tle16_to_cpus(&r->entry_size);\n\tle16_to_cpus(&r->size);\n\tle32_to_cpus(&r->tail);\n\tle32_to_cpus(&r->head);\n}\n\n \nvoid wil_get_board_file(struct wil6210_priv *wil, char *buf, size_t len)\n{\n\tconst char *board_file;\n\tconst char *wil_talyn_fw_name = ftm_mode ? WIL_FW_NAME_FTM_TALYN :\n\t\t\t      WIL_FW_NAME_TALYN;\n\n\tif (wil->board_file) {\n\t\tboard_file = wil->board_file;\n\t} else {\n\t\t \n\t\tif (strcmp(wil->wil_fw_name, wil_talyn_fw_name) == 0)\n\t\t\tboard_file = WIL_BRD_NAME_TALYN;\n\t\telse\n\t\t\tboard_file = WIL_BOARD_FILE_NAME;\n\t}\n\n\tstrscpy(buf, board_file, len);\n}\n\nstatic int wil_get_bl_info(struct wil6210_priv *wil)\n{\n\tstruct net_device *ndev = wil->main_ndev;\n\tstruct wiphy *wiphy = wil_to_wiphy(wil);\n\tunion {\n\t\tstruct bl_dedicated_registers_v0 bl0;\n\t\tstruct bl_dedicated_registers_v1 bl1;\n\t} bl;\n\tu32 bl_ver;\n\tu8 *mac;\n\tu16 rf_status;\n\n\twil_memcpy_fromio_32(&bl, wil->csr + HOSTADDR(RGF_USER_BL),\n\t\t\t     sizeof(bl));\n\tbl_ver = le32_to_cpu(bl.bl0.boot_loader_struct_version);\n\tmac = bl.bl0.mac_address;\n\n\tif (bl_ver == 0) {\n\t\tle32_to_cpus(&bl.bl0.rf_type);\n\t\tle32_to_cpus(&bl.bl0.baseband_type);\n\t\trf_status = 0;  \n\t\twil_info(wil,\n\t\t\t \"Boot Loader struct v%d: MAC = %pM RF = 0x%08x bband = 0x%08x\\n\",\n\t\t\t bl_ver, mac,\n\t\t\t bl.bl0.rf_type, bl.bl0.baseband_type);\n\t\twil_info(wil, \"Boot Loader build unknown for struct v0\\n\");\n\t} else {\n\t\tle16_to_cpus(&bl.bl1.rf_type);\n\t\trf_status = le16_to_cpu(bl.bl1.rf_status);\n\t\tle32_to_cpus(&bl.bl1.baseband_type);\n\t\tle16_to_cpus(&bl.bl1.bl_version_subminor);\n\t\tle16_to_cpus(&bl.bl1.bl_version_build);\n\t\twil_info(wil,\n\t\t\t \"Boot Loader struct v%d: MAC = %pM RF = 0x%04x (status 0x%04x) bband = 0x%08x\\n\",\n\t\t\t bl_ver, mac,\n\t\t\t bl.bl1.rf_type, rf_status,\n\t\t\t bl.bl1.baseband_type);\n\t\twil_info(wil, \"Boot Loader build %d.%d.%d.%d\\n\",\n\t\t\t bl.bl1.bl_version_major, bl.bl1.bl_version_minor,\n\t\t\t bl.bl1.bl_version_subminor, bl.bl1.bl_version_build);\n\t}\n\n\tif (!is_valid_ether_addr(mac)) {\n\t\twil_err(wil, \"BL: Invalid MAC %pM\\n\", mac);\n\t\treturn -EINVAL;\n\t}\n\n\tether_addr_copy(ndev->perm_addr, mac);\n\tether_addr_copy(wiphy->perm_addr, mac);\n\tif (!is_valid_ether_addr(ndev->dev_addr))\n\t\teth_hw_addr_set(ndev, mac);\n\n\tif (rf_status) { \n\t\twil_err(wil, \"RF communication error 0x%04x\",\n\t\t\trf_status);\n\t\treturn -EAGAIN;\n\t}\n\n\treturn 0;\n}\n\nstatic void wil_bl_crash_info(struct wil6210_priv *wil, bool is_err)\n{\n\tu32 bl_assert_code, bl_assert_blink, bl_magic_number;\n\tu32 bl_ver = wil_r(wil, RGF_USER_BL +\n\t\t\t   offsetof(struct bl_dedicated_registers_v0,\n\t\t\t\t    boot_loader_struct_version));\n\n\tif (bl_ver < 2)\n\t\treturn;\n\n\tbl_assert_code = wil_r(wil, RGF_USER_BL +\n\t\t\t       offsetof(struct bl_dedicated_registers_v1,\n\t\t\t\t\tbl_assert_code));\n\tbl_assert_blink = wil_r(wil, RGF_USER_BL +\n\t\t\t\toffsetof(struct bl_dedicated_registers_v1,\n\t\t\t\t\t bl_assert_blink));\n\tbl_magic_number = wil_r(wil, RGF_USER_BL +\n\t\t\t\toffsetof(struct bl_dedicated_registers_v1,\n\t\t\t\t\t bl_magic_number));\n\n\tif (is_err) {\n\t\twil_err(wil,\n\t\t\t\"BL assert code 0x%08x blink 0x%08x magic 0x%08x\\n\",\n\t\t\tbl_assert_code, bl_assert_blink, bl_magic_number);\n\t} else {\n\t\twil_dbg_misc(wil,\n\t\t\t     \"BL assert code 0x%08x blink 0x%08x magic 0x%08x\\n\",\n\t\t\t     bl_assert_code, bl_assert_blink, bl_magic_number);\n\t}\n}\n\nstatic int wil_get_otp_info(struct wil6210_priv *wil)\n{\n\tstruct net_device *ndev = wil->main_ndev;\n\tstruct wiphy *wiphy = wil_to_wiphy(wil);\n\tu8 mac[8];\n\tint mac_addr;\n\n\t \n\tmac_addr = RGF_OTP_OEM_MAC;\n\twil_memcpy_fromio_32(mac, wil->csr + HOSTADDR(mac_addr), sizeof(mac));\n\n\tif (is_valid_ether_addr(mac)) {\n\t\twil_info(wil, \"using OEM MAC %pM\\n\", mac);\n\t} else {\n\t\tif (wil->hw_version >= HW_VER_TALYN_MB)\n\t\t\tmac_addr = RGF_OTP_MAC_TALYN_MB;\n\t\telse\n\t\t\tmac_addr = RGF_OTP_MAC;\n\n\t\twil_memcpy_fromio_32(mac, wil->csr + HOSTADDR(mac_addr),\n\t\t\t\t     sizeof(mac));\n\t}\n\n\tif (!is_valid_ether_addr(mac)) {\n\t\twil_err(wil, \"Invalid MAC %pM\\n\", mac);\n\t\treturn -EINVAL;\n\t}\n\n\tether_addr_copy(ndev->perm_addr, mac);\n\tether_addr_copy(wiphy->perm_addr, mac);\n\tif (!is_valid_ether_addr(ndev->dev_addr))\n\t\teth_hw_addr_set(ndev, mac);\n\n\treturn 0;\n}\n\nstatic int wil_wait_for_fw_ready(struct wil6210_priv *wil)\n{\n\tulong to = msecs_to_jiffies(2000);\n\tulong left = wait_for_completion_timeout(&wil->wmi_ready, to);\n\n\tif (0 == left) {\n\t\twil_err(wil, \"Firmware not ready\\n\");\n\t\treturn -ETIME;\n\t} else {\n\t\twil_info(wil, \"FW ready after %d ms. HW version 0x%08x\\n\",\n\t\t\t jiffies_to_msecs(to-left), wil->hw_version);\n\t}\n\treturn 0;\n}\n\nvoid wil_abort_scan(struct wil6210_vif *vif, bool sync)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tint rc;\n\tstruct cfg80211_scan_info info = {\n\t\t.aborted = true,\n\t};\n\n\tlockdep_assert_held(&wil->vif_mutex);\n\n\tif (!vif->scan_request)\n\t\treturn;\n\n\twil_dbg_misc(wil, \"Abort scan_request 0x%p\\n\", vif->scan_request);\n\tdel_timer_sync(&vif->scan_timer);\n\tmutex_unlock(&wil->vif_mutex);\n\trc = wmi_abort_scan(vif);\n\tif (!rc && sync)\n\t\twait_event_interruptible_timeout(wil->wq, !vif->scan_request,\n\t\t\t\t\t\t msecs_to_jiffies(\n\t\t\t\t\t\t WAIT_FOR_SCAN_ABORT_MS));\n\n\tmutex_lock(&wil->vif_mutex);\n\tif (vif->scan_request) {\n\t\tcfg80211_scan_done(vif->scan_request, &info);\n\t\tvif->scan_request = NULL;\n\t}\n}\n\nvoid wil_abort_scan_all_vifs(struct wil6210_priv *wil, bool sync)\n{\n\tint i;\n\n\tlockdep_assert_held(&wil->vif_mutex);\n\n\tfor (i = 0; i < GET_MAX_VIFS(wil); i++) {\n\t\tstruct wil6210_vif *vif = wil->vifs[i];\n\n\t\tif (vif)\n\t\t\twil_abort_scan(vif, sync);\n\t}\n}\n\nint wil_ps_update(struct wil6210_priv *wil, enum wmi_ps_profile_type ps_profile)\n{\n\tint rc;\n\n\tif (!test_bit(WMI_FW_CAPABILITY_PS_CONFIG, wil->fw_capabilities)) {\n\t\twil_err(wil, \"set_power_mgmt not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\trc  = wmi_ps_dev_profile_cfg(wil, ps_profile);\n\tif (rc)\n\t\twil_err(wil, \"wmi_ps_dev_profile_cfg failed (%d)\\n\", rc);\n\telse\n\t\twil->ps_profile = ps_profile;\n\n\treturn rc;\n}\n\nstatic void wil_pre_fw_config(struct wil6210_priv *wil)\n{\n\twil_clear_fw_log_addr(wil);\n\t \n\twil_s(wil, RGF_USER_USAGE_6, 1);\n\n\t \n\twil6210_clear_irq(wil);\n\t \n\t \n\tif (wil->hw_version < HW_VER_TALYN_MB) {\n\t\twil_s(wil, RGF_CAF_ICR + offsetof(struct RGF_ICR, ICR), 0);\n\t\twil_w(wil, RGF_CAF_ICR + offsetof(struct RGF_ICR, IMV), ~0);\n\t}\n\t \n\tif (wil->hw_version < HW_VER_TALYN_MB)\n\t\twil_s(wil, RGF_PAL_UNIT_ICR + offsetof(struct RGF_ICR, ICR),\n\t\t      0);\n\n\tif (wil->fw_calib_result > 0) {\n\t\t__le32 val = cpu_to_le32(wil->fw_calib_result |\n\t\t\t\t\t\t(CALIB_RESULT_SIGNATURE << 8));\n\t\twil_w(wil, RGF_USER_FW_CALIB_RESULT, (u32 __force)val);\n\t}\n}\n\nstatic int wil_restore_vifs(struct wil6210_priv *wil)\n{\n\tstruct wil6210_vif *vif;\n\tstruct net_device *ndev;\n\tstruct wireless_dev *wdev;\n\tint i, rc;\n\n\tfor (i = 0; i < GET_MAX_VIFS(wil); i++) {\n\t\tvif = wil->vifs[i];\n\t\tif (!vif)\n\t\t\tcontinue;\n\t\tvif->ap_isolate = 0;\n\t\tif (vif->mid) {\n\t\t\tndev = vif_to_ndev(vif);\n\t\t\twdev = vif_to_wdev(vif);\n\t\t\trc = wmi_port_allocate(wil, vif->mid, ndev->dev_addr,\n\t\t\t\t\t       wdev->iftype);\n\t\t\tif (rc) {\n\t\t\t\twil_err(wil, \"fail to restore VIF %d type %d, rc %d\\n\",\n\t\t\t\t\ti, wdev->iftype, rc);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nvoid wil_clear_fw_log_addr(struct wil6210_priv *wil)\n{\n\t \n\twil_w(wil, RGF_USER_USAGE_1, 0);\n\t \n\twil_w(wil, RGF_USER_USAGE_2, 0);\n\twil_dbg_misc(wil, \"Cleared FW and ucode log address\");\n}\n\n \nint wil_reset(struct wil6210_priv *wil, bool load_fw)\n{\n\tint rc, i;\n\tunsigned long status_flags = BIT(wil_status_resetting);\n\tint no_flash;\n\tstruct wil6210_vif *vif;\n\n\twil_dbg_misc(wil, \"reset\\n\");\n\n\tWARN_ON(!mutex_is_locked(&wil->mutex));\n\tWARN_ON(test_bit(wil_status_napi_en, wil->status));\n\n\tif (debug_fw) {\n\t\tstatic const u8 mac[ETH_ALEN] = {\n\t\t\t0x00, 0xde, 0xad, 0x12, 0x34, 0x56,\n\t\t};\n\t\tstruct net_device *ndev = wil->main_ndev;\n\n\t\tether_addr_copy(ndev->perm_addr, mac);\n\t\teth_hw_addr_set(ndev, ndev->perm_addr);\n\t\treturn 0;\n\t}\n\n\tif (wil->hw_version == HW_VER_UNKNOWN)\n\t\treturn -ENODEV;\n\n\tif (test_bit(WIL_PLATFORM_CAPA_T_PWR_ON_0, wil->platform_capa) &&\n\t    wil->hw_version < HW_VER_TALYN_MB) {\n\t\twil_dbg_misc(wil, \"Notify FW to set T_POWER_ON=0\\n\");\n\t\twil_s(wil, RGF_USER_USAGE_8, BIT_USER_SUPPORT_T_POWER_ON_0);\n\t}\n\n\tif (test_bit(WIL_PLATFORM_CAPA_EXT_CLK, wil->platform_capa)) {\n\t\twil_dbg_misc(wil, \"Notify FW on ext clock configuration\\n\");\n\t\twil_s(wil, RGF_USER_USAGE_8, BIT_USER_EXT_CLK);\n\t}\n\n\tif (wil->platform_ops.notify) {\n\t\trc = wil->platform_ops.notify(wil->platform_handle,\n\t\t\t\t\t      WIL_PLATFORM_EVT_PRE_RESET);\n\t\tif (rc)\n\t\t\twil_err(wil, \"PRE_RESET platform notify failed, rc %d\\n\",\n\t\t\t\trc);\n\t}\n\n\tset_bit(wil_status_resetting, wil->status);\n\tmutex_lock(&wil->vif_mutex);\n\twil_abort_scan_all_vifs(wil, false);\n\tmutex_unlock(&wil->vif_mutex);\n\n\tfor (i = 0; i < GET_MAX_VIFS(wil); i++) {\n\t\tvif = wil->vifs[i];\n\t\tif (vif) {\n\t\t\tcancel_work_sync(&vif->disconnect_worker);\n\t\t\twil6210_disconnect(vif, NULL,\n\t\t\t\t\t   WLAN_REASON_DEAUTH_LEAVING);\n\t\t\tvif->ptk_rekey_state = WIL_REKEY_IDLE;\n\t\t}\n\t}\n\twil_bcast_fini_all(wil);\n\n\t \n\twmi_led_cfg(wil, false);\n\n\tdown_write(&wil->mem_lock);\n\n\t \n\tmutex_lock(&wil->wmi_mutex);\n\tif (test_bit(wil_status_suspending, wil->status))\n\t\tstatus_flags |= BIT(wil_status_suspending);\n\tbitmap_and(wil->status, wil->status, &status_flags,\n\t\t   wil_status_last);\n\twil_dbg_misc(wil, \"wil->status (0x%lx)\\n\", *wil->status);\n\tmutex_unlock(&wil->wmi_mutex);\n\n\twil_mask_irq(wil);\n\n\twmi_event_flush(wil);\n\n\tflush_workqueue(wil->wq_service);\n\tflush_workqueue(wil->wmi_wq);\n\n\tno_flash = test_bit(hw_capa_no_flash, wil->hw_capa);\n\tif (!no_flash)\n\t\twil_bl_crash_info(wil, false);\n\twil_disable_irq(wil);\n\trc = wil_target_reset(wil, no_flash);\n\twil6210_clear_irq(wil);\n\twil_enable_irq(wil);\n\twil->txrx_ops.rx_fini(wil);\n\twil->txrx_ops.tx_fini(wil);\n\tif (rc) {\n\t\tif (!no_flash)\n\t\t\twil_bl_crash_info(wil, true);\n\t\tgoto out;\n\t}\n\n\tif (no_flash) {\n\t\trc = wil_get_otp_info(wil);\n\t} else {\n\t\trc = wil_get_bl_info(wil);\n\t\tif (rc == -EAGAIN && !load_fw)\n\t\t\t \n\t\t\trc = 0;\n\t}\n\tif (rc)\n\t\tgoto out;\n\n\twil_set_oob_mode(wil, oob_mode);\n\tif (load_fw) {\n\t\tchar board_file[WIL_BOARD_FILE_MAX_NAMELEN];\n\n\t\tif  (wil->secured_boot) {\n\t\t\twil_err(wil, \"secured boot is not supported\\n\");\n\t\t\tup_write(&wil->mem_lock);\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\n\t\tboard_file[0] = '\\0';\n\t\twil_get_board_file(wil, board_file, sizeof(board_file));\n\t\twil_info(wil, \"Use firmware <%s> + board <%s>\\n\",\n\t\t\t wil->wil_fw_name, board_file);\n\n\t\tif (!no_flash)\n\t\t\twil_bl_prepare_halt(wil);\n\n\t\twil_halt_cpu(wil);\n\t\tmemset(wil->fw_version, 0, sizeof(wil->fw_version));\n\t\t \n\t\trc = wil_request_firmware(wil, wil->wil_fw_name, true);\n\t\tif (rc)\n\t\t\tgoto out;\n\t\tif (wil->num_of_brd_entries)\n\t\t\trc = wil_request_board(wil, board_file);\n\t\telse\n\t\t\trc = wil_request_firmware(wil, board_file, true);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\twil_pre_fw_config(wil);\n\t\twil_release_cpu(wil);\n\t}\n\n\t \n\treinit_completion(&wil->wmi_ready);\n\treinit_completion(&wil->wmi_call);\n\treinit_completion(&wil->halp.comp);\n\n\tclear_bit(wil_status_resetting, wil->status);\n\n\tup_write(&wil->mem_lock);\n\n\tif (load_fw) {\n\t\twil_unmask_irq(wil);\n\n\t\t \n\t\trc = wil_wait_for_fw_ready(wil);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\t \n\t\trc = wmi_echo(wil);\n\t\tif (rc) {\n\t\t\twil_err(wil, \"wmi_echo failed, rc %d\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\n\t\twil->txrx_ops.configure_interrupt_moderation(wil);\n\n\t\t \n\t\tif (wil->hw_version >= HW_VER_TALYN_MB)\n\t\t\twil_s(wil, RGF_DMA_MISC_CTL,\n\t\t\t      BIT_OFUL34_RDY_VALID_BUG_FIX_EN);\n\n\t\trc = wil_restore_vifs(wil);\n\t\tif (rc) {\n\t\t\twil_err(wil, \"failed to restore vifs, rc %d\\n\", rc);\n\t\t\treturn rc;\n\t\t}\n\n\t\twil_collect_fw_info(wil);\n\n\t\tif (wil->ps_profile != WMI_PS_PROFILE_TYPE_DEFAULT)\n\t\t\twil_ps_update(wil, wil->ps_profile);\n\n\t\tif (wil->platform_ops.notify) {\n\t\t\trc = wil->platform_ops.notify(wil->platform_handle,\n\t\t\t\t\t\t      WIL_PLATFORM_EVT_FW_RDY);\n\t\t\tif (rc) {\n\t\t\t\twil_err(wil, \"FW_RDY notify failed, rc %d\\n\",\n\t\t\t\t\trc);\n\t\t\t\trc = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn rc;\n\nout:\n\tup_write(&wil->mem_lock);\n\tclear_bit(wil_status_resetting, wil->status);\n\treturn rc;\n}\n\nvoid wil_fw_error_recovery(struct wil6210_priv *wil)\n{\n\twil_dbg_misc(wil, \"starting fw error recovery\\n\");\n\n\tif (test_bit(wil_status_resetting, wil->status)) {\n\t\twil_info(wil, \"Reset already in progress\\n\");\n\t\treturn;\n\t}\n\n\twil->recovery_state = fw_recovery_pending;\n\tschedule_work(&wil->fw_error_worker);\n}\n\nint __wil_up(struct wil6210_priv *wil)\n{\n\tstruct net_device *ndev = wil->main_ndev;\n\tstruct wireless_dev *wdev = ndev->ieee80211_ptr;\n\tint rc;\n\n\tWARN_ON(!mutex_is_locked(&wil->mutex));\n\n\trc = wil_reset(wil, true);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tif (rx_ring_order == 0)\n\t\trx_ring_order = wil->hw_version < HW_VER_TALYN_MB ?\n\t\t\tWIL_RX_RING_SIZE_ORDER_DEFAULT :\n\t\t\tWIL_RX_RING_SIZE_ORDER_TALYN_DEFAULT;\n\n\trc = wil->txrx_ops.rx_init(wil, rx_ring_order);\n\tif (rc)\n\t\treturn rc;\n\n\trc = wil->txrx_ops.tx_init(wil);\n\tif (rc)\n\t\treturn rc;\n\n\tswitch (wdev->iftype) {\n\tcase NL80211_IFTYPE_STATION:\n\t\twil_dbg_misc(wil, \"type: STATION\\n\");\n\t\tndev->type = ARPHRD_ETHER;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\t\twil_dbg_misc(wil, \"type: AP\\n\");\n\t\tndev->type = ARPHRD_ETHER;\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\twil_dbg_misc(wil, \"type: P2P_CLIENT\\n\");\n\t\tndev->type = ARPHRD_ETHER;\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\twil_dbg_misc(wil, \"type: P2P_GO\\n\");\n\t\tndev->type = ARPHRD_ETHER;\n\t\tbreak;\n\tcase NL80211_IFTYPE_MONITOR:\n\t\twil_dbg_misc(wil, \"type: Monitor\\n\");\n\t\tndev->type = ARPHRD_IEEE80211_RADIOTAP;\n\t\t \n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\twmi_set_mac_address(wil, ndev->dev_addr);\n\n\twil_dbg_misc(wil, \"NAPI enable\\n\");\n\tnapi_enable(&wil->napi_rx);\n\tnapi_enable(&wil->napi_tx);\n\tset_bit(wil_status_napi_en, wil->status);\n\n\twil6210_bus_request(wil, WIL_DEFAULT_BUS_REQUEST_KBPS);\n\n\treturn 0;\n}\n\nint wil_up(struct wil6210_priv *wil)\n{\n\tint rc;\n\n\twil_dbg_misc(wil, \"up\\n\");\n\n\tmutex_lock(&wil->mutex);\n\trc = __wil_up(wil);\n\tmutex_unlock(&wil->mutex);\n\n\treturn rc;\n}\n\nint __wil_down(struct wil6210_priv *wil)\n{\n\tint rc;\n\tWARN_ON(!mutex_is_locked(&wil->mutex));\n\n\tset_bit(wil_status_resetting, wil->status);\n\n\twil6210_bus_request(wil, 0);\n\n\twil_disable_irq(wil);\n\tif (test_and_clear_bit(wil_status_napi_en, wil->status)) {\n\t\tnapi_disable(&wil->napi_rx);\n\t\tnapi_disable(&wil->napi_tx);\n\t\twil_dbg_misc(wil, \"NAPI disable\\n\");\n\t}\n\twil_enable_irq(wil);\n\n\tmutex_lock(&wil->vif_mutex);\n\twil_p2p_stop_radio_operations(wil);\n\twil_abort_scan_all_vifs(wil, false);\n\tmutex_unlock(&wil->vif_mutex);\n\n\trc = wil_reset(wil, false);\n\n\treturn rc;\n}\n\nint wil_down(struct wil6210_priv *wil)\n{\n\tint rc;\n\n\twil_dbg_misc(wil, \"down\\n\");\n\n\twil_set_recovery_state(wil, fw_recovery_idle);\n\tmutex_lock(&wil->mutex);\n\trc = __wil_down(wil);\n\tmutex_unlock(&wil->mutex);\n\n\treturn rc;\n}\n\nint wil_find_cid(struct wil6210_priv *wil, u8 mid, const u8 *mac)\n{\n\tint i;\n\tint rc = -ENOENT;\n\n\tfor (i = 0; i < wil->max_assoc_sta; i++) {\n\t\tif (wil->sta[i].mid == mid &&\n\t\t    wil->sta[i].status != wil_sta_unused &&\n\t\t    ether_addr_equal(wil->sta[i].addr, mac)) {\n\t\t\trc = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rc;\n}\n\nvoid wil_halp_vote(struct wil6210_priv *wil)\n{\n\tunsigned long rc;\n\tunsigned long to_jiffies = msecs_to_jiffies(WAIT_FOR_HALP_VOTE_MS);\n\n\tif (wil->hw_version >= HW_VER_TALYN_MB)\n\t\treturn;\n\n\tmutex_lock(&wil->halp.lock);\n\n\twil_dbg_irq(wil, \"halp_vote: start, HALP ref_cnt (%d)\\n\",\n\t\t    wil->halp.ref_cnt);\n\n\tif (++wil->halp.ref_cnt == 1) {\n\t\treinit_completion(&wil->halp.comp);\n\t\t \n\t\twil->halp.handle_icr = true;\n\t\twil6210_set_halp(wil);\n\t\trc = wait_for_completion_timeout(&wil->halp.comp, to_jiffies);\n\t\tif (!rc) {\n\t\t\twil_err(wil, \"HALP vote timed out\\n\");\n\t\t\t \n\t\t\twil->halp.handle_icr = false;\n\t\t\twil6210_mask_halp(wil);\n\t\t} else {\n\t\t\twil_dbg_irq(wil,\n\t\t\t\t    \"halp_vote: HALP vote completed after %d ms\\n\",\n\t\t\t\t    jiffies_to_msecs(to_jiffies - rc));\n\t\t}\n\t}\n\n\twil_dbg_irq(wil, \"halp_vote: end, HALP ref_cnt (%d)\\n\",\n\t\t    wil->halp.ref_cnt);\n\n\tmutex_unlock(&wil->halp.lock);\n}\n\nvoid wil_halp_unvote(struct wil6210_priv *wil)\n{\n\tif (wil->hw_version >= HW_VER_TALYN_MB)\n\t\treturn;\n\n\tWARN_ON(wil->halp.ref_cnt == 0);\n\n\tmutex_lock(&wil->halp.lock);\n\n\twil_dbg_irq(wil, \"halp_unvote: start, HALP ref_cnt (%d)\\n\",\n\t\t    wil->halp.ref_cnt);\n\n\tif (--wil->halp.ref_cnt == 0) {\n\t\twil6210_clear_halp(wil);\n\t\twil_dbg_irq(wil, \"HALP unvote\\n\");\n\t}\n\n\twil_dbg_irq(wil, \"halp_unvote:end, HALP ref_cnt (%d)\\n\",\n\t\t    wil->halp.ref_cnt);\n\n\tmutex_unlock(&wil->halp.lock);\n}\n\nvoid wil_init_txrx_ops(struct wil6210_priv *wil)\n{\n\tif (wil->use_enhanced_dma_hw)\n\t\twil_init_txrx_ops_edma(wil);\n\telse\n\t\twil_init_txrx_ops_legacy_dma(wil);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}