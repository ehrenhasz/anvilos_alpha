{
  "module_name": "debugfs.c",
  "hash_id": "b1d1d5510715b900754b41e08643e112feb9ec20e44fc55cf1e072d382268963",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/wil6210/debugfs.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/pci.h>\n#include <linux/rtnetlink.h>\n#include <linux/power_supply.h>\n#include \"wil6210.h\"\n#include \"wmi.h\"\n#include \"txrx.h\"\n#include \"pmc.h\"\n\n \nstatic u32 mem_addr;\nstatic u32 dbg_txdesc_index;\nstatic u32 dbg_ring_index;  \nstatic u32 dbg_status_msg_index;\n \nstatic u32 dbg_sring_index;\n\nenum dbg_off_type {\n\tdoff_u32 = 0,\n\tdoff_x32 = 1,\n\tdoff_ulong = 2,\n\tdoff_io32 = 3,\n\tdoff_u8 = 4\n};\n\n \nstruct dbg_off {\n\tconst char *name;\n\tumode_t mode;\n\tulong off;\n\tenum dbg_off_type type;\n};\n\nstatic void wil_print_desc_edma(struct seq_file *s, struct wil6210_priv *wil,\n\t\t\t\tstruct wil_ring *ring,\n\t\t\t\tchar _s, char _h, int idx)\n{\n\tu8 num_of_descs;\n\tbool has_skb = false;\n\n\tif (ring->is_rx) {\n\t\tstruct wil_rx_enhanced_desc *rx_d =\n\t\t\t(struct wil_rx_enhanced_desc *)\n\t\t\t&ring->va[idx].rx.enhanced;\n\t\tu16 buff_id = le16_to_cpu(rx_d->mac.buff_id);\n\n\t\tif (wil->rx_buff_mgmt.buff_arr &&\n\t\t    wil_val_in_range(buff_id, 0, wil->rx_buff_mgmt.size))\n\t\t\thas_skb = wil->rx_buff_mgmt.buff_arr[buff_id].skb;\n\t\tseq_printf(s, \"%c\", (has_skb) ? _h : _s);\n\t} else {\n\t\tstruct wil_tx_enhanced_desc *d =\n\t\t\t(struct wil_tx_enhanced_desc *)\n\t\t\t&ring->va[idx].tx.enhanced;\n\n\t\tnum_of_descs = (u8)d->mac.d[2];\n\t\thas_skb = ring->ctx && ring->ctx[idx].skb;\n\t\tif (num_of_descs >= 1)\n\t\t\tseq_printf(s, \"%c\", has_skb ? _h : _s);\n\t\telse\n\t\t\t \n\t\t\tseq_printf(s, \"%c\", has_skb ? 'h' : _s);\n\t}\n}\n\nstatic void wil_print_ring(struct seq_file *s, struct wil6210_priv *wil,\n\t\t\t   const char *name, struct wil_ring *ring,\n\t\t\t   char _s, char _h)\n{\n\tvoid __iomem *x;\n\tu32 v;\n\n\tseq_printf(s, \"RING %s = {\\n\", name);\n\tseq_printf(s, \"  pa     = %pad\\n\", &ring->pa);\n\tseq_printf(s, \"  va     = 0x%p\\n\", ring->va);\n\tseq_printf(s, \"  size   = %d\\n\", ring->size);\n\tif (wil->use_enhanced_dma_hw && ring->is_rx)\n\t\tseq_printf(s, \"  swtail = %u\\n\", *ring->edma_rx_swtail.va);\n\telse\n\t\tseq_printf(s, \"  swtail = %d\\n\", ring->swtail);\n\tseq_printf(s, \"  swhead = %d\\n\", ring->swhead);\n\tif (wil->use_enhanced_dma_hw) {\n\t\tint ring_id = ring->is_rx ?\n\t\t\tWIL_RX_DESC_RING_ID : ring - wil->ring_tx;\n\t\t \n\t\tx = wmi_addr(wil, RGF_DMA_SCM_SUBQ_CONS + 4 * (ring_id / 2));\n\t\tv = readl_relaxed(x);\n\n\t\tv = (ring_id % 2 ? (v >> 16) : (v & 0xffff));\n\t\tseq_printf(s, \"  hwhead = %u\\n\", v);\n\t}\n\tseq_printf(s, \"  hwtail = [0x%08x] -> \", ring->hwtail);\n\tx = wmi_addr(wil, ring->hwtail);\n\tif (x) {\n\t\tv = readl(x);\n\t\tseq_printf(s, \"0x%08x = %d\\n\", v, v);\n\t} else {\n\t\tseq_puts(s, \"???\\n\");\n\t}\n\n\tif (ring->va && (ring->size <= (1 << WIL_RING_SIZE_ORDER_MAX))) {\n\t\tuint i;\n\n\t\tfor (i = 0; i < ring->size; i++) {\n\t\t\tif ((i % 128) == 0 && i != 0)\n\t\t\t\tseq_puts(s, \"\\n\");\n\t\t\tif (wil->use_enhanced_dma_hw) {\n\t\t\t\twil_print_desc_edma(s, wil, ring, _s, _h, i);\n\t\t\t} else {\n\t\t\t\tvolatile struct vring_tx_desc *d =\n\t\t\t\t\t&ring->va[i].tx.legacy;\n\t\t\t\tseq_printf(s, \"%c\", (d->dma.status & BIT(0)) ?\n\t\t\t\t\t   _s : (ring->ctx[i].skb ? _h : 'h'));\n\t\t\t}\n\t\t}\n\t\tseq_puts(s, \"\\n\");\n\t}\n\tseq_puts(s, \"}\\n\");\n}\n\nstatic int ring_show(struct seq_file *s, void *data)\n{\n\tuint i;\n\tstruct wil6210_priv *wil = s->private;\n\n\twil_print_ring(s, wil, \"rx\", &wil->ring_rx, 'S', '_');\n\n\tfor (i = 0; i < ARRAY_SIZE(wil->ring_tx); i++) {\n\t\tstruct wil_ring *ring = &wil->ring_tx[i];\n\t\tstruct wil_ring_tx_data *txdata = &wil->ring_tx_data[i];\n\n\t\tif (ring->va) {\n\t\t\tint cid = wil->ring2cid_tid[i][0];\n\t\t\tint tid = wil->ring2cid_tid[i][1];\n\t\t\tu32 swhead = ring->swhead;\n\t\t\tu32 swtail = ring->swtail;\n\t\t\tint used = (ring->size + swhead - swtail)\n\t\t\t\t   % ring->size;\n\t\t\tint avail = ring->size - used - 1;\n\t\t\tchar name[10];\n\t\t\tchar sidle[10];\n\t\t\t \n\t\t\tcycles_t now = get_cycles();\n\t\t\tuint64_t idle = txdata->idle * 100;\n\t\t\tuint64_t total = now - txdata->begin;\n\n\t\t\tif (total != 0) {\n\t\t\t\tdo_div(idle, total);\n\t\t\t\tsnprintf(sidle, sizeof(sidle), \"%3d%%\",\n\t\t\t\t\t (int)idle);\n\t\t\t} else {\n\t\t\t\tsnprintf(sidle, sizeof(sidle), \"N/A\");\n\t\t\t}\n\t\t\ttxdata->begin = now;\n\t\t\ttxdata->idle = 0ULL;\n\n\t\t\tsnprintf(name, sizeof(name), \"tx_%2d\", i);\n\n\t\t\tif (cid < wil->max_assoc_sta)\n\t\t\t\tseq_printf(s,\n\t\t\t\t\t   \"\\n%pM CID %d TID %d 1x%s BACK([%u] %u TU A%s) [%3d|%3d] idle %s\\n\",\n\t\t\t\t\t   wil->sta[cid].addr, cid, tid,\n\t\t\t\t\t   txdata->dot1x_open ? \"+\" : \"-\",\n\t\t\t\t\t   txdata->agg_wsize,\n\t\t\t\t\t   txdata->agg_timeout,\n\t\t\t\t\t   txdata->agg_amsdu ? \"+\" : \"-\",\n\t\t\t\t\t   used, avail, sidle);\n\t\t\telse\n\t\t\t\tseq_printf(s,\n\t\t\t\t\t   \"\\nBroadcast 1x%s [%3d|%3d] idle %s\\n\",\n\t\t\t\t\t   txdata->dot1x_open ? \"+\" : \"-\",\n\t\t\t\t\t   used, avail, sidle);\n\n\t\t\twil_print_ring(s, wil, name, ring, '_', 'H');\n\t\t}\n\t}\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(ring);\n\nstatic void wil_print_sring(struct seq_file *s, struct wil6210_priv *wil,\n\t\t\t    struct wil_status_ring *sring)\n{\n\tvoid __iomem *x;\n\tint sring_idx = sring - wil->srings;\n\tu32 v;\n\n\tseq_printf(s, \"Status Ring %s [ %d ] = {\\n\",\n\t\t   sring->is_rx ? \"RX\" : \"TX\", sring_idx);\n\tseq_printf(s, \"  pa     = %pad\\n\", &sring->pa);\n\tseq_printf(s, \"  va     = 0x%pK\\n\", sring->va);\n\tseq_printf(s, \"  size   = %d\\n\", sring->size);\n\tseq_printf(s, \"  elem_size   = %zu\\n\", sring->elem_size);\n\tseq_printf(s, \"  swhead = %d\\n\", sring->swhead);\n\tif (wil->use_enhanced_dma_hw) {\n\t\t \n\t\tx = wmi_addr(wil, RGF_DMA_SCM_COMPQ_PROD + 4 * (sring_idx / 2));\n\t\tv = readl_relaxed(x);\n\n\t\tv = (sring_idx % 2 ? (v >> 16) : (v & 0xffff));\n\t\tseq_printf(s, \"  hwhead = %u\\n\", v);\n\t}\n\tseq_printf(s, \"  hwtail = [0x%08x] -> \", sring->hwtail);\n\tx = wmi_addr(wil, sring->hwtail);\n\tif (x) {\n\t\tv = readl_relaxed(x);\n\t\tseq_printf(s, \"0x%08x = %d\\n\", v, v);\n\t} else {\n\t\tseq_puts(s, \"???\\n\");\n\t}\n\tseq_printf(s, \"  desc_rdy_pol   = %d\\n\", sring->desc_rdy_pol);\n\tseq_printf(s, \"  invalid_buff_id_cnt   = %d\\n\",\n\t\t   sring->invalid_buff_id_cnt);\n\n\tif (sring->va && (sring->size <= (1 << WIL_RING_SIZE_ORDER_MAX))) {\n\t\tuint i;\n\n\t\tfor (i = 0; i < sring->size; i++) {\n\t\t\tu32 *sdword_0 =\n\t\t\t\t(u32 *)(sring->va + (sring->elem_size * i));\n\n\t\t\tif ((i % 128) == 0 && i != 0)\n\t\t\t\tseq_puts(s, \"\\n\");\n\t\t\tif (i == sring->swhead)\n\t\t\t\tseq_printf(s, \"%c\", (*sdword_0 & BIT(31)) ?\n\t\t\t\t\t   'X' : 'x');\n\t\t\telse\n\t\t\t\tseq_printf(s, \"%c\", (*sdword_0 & BIT(31)) ?\n\t\t\t\t\t   '1' : '0');\n\t\t}\n\t\tseq_puts(s, \"\\n\");\n\t}\n\tseq_puts(s, \"}\\n\");\n}\n\nstatic int srings_show(struct seq_file *s, void *data)\n{\n\tstruct wil6210_priv *wil = s->private;\n\tint i = 0;\n\n\tfor (i = 0; i < WIL6210_MAX_STATUS_RINGS; i++)\n\t\tif (wil->srings[i].va)\n\t\t\twil_print_sring(s, wil, &wil->srings[i]);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(srings);\n\nstatic void wil_seq_hexdump(struct seq_file *s, void *p, int len,\n\t\t\t    const char *prefix)\n{\n\tseq_hex_dump(s, prefix, DUMP_PREFIX_NONE, 16, 1, p, len, false);\n}\n\nstatic void wil_print_mbox_ring(struct seq_file *s, const char *prefix,\n\t\t\t\tvoid __iomem *off)\n{\n\tstruct wil6210_priv *wil = s->private;\n\tstruct wil6210_mbox_ring r;\n\tint rsize;\n\tuint i;\n\n\twil_halp_vote(wil);\n\n\tif (wil_mem_access_lock(wil)) {\n\t\twil_halp_unvote(wil);\n\t\treturn;\n\t}\n\n\twil_memcpy_fromio_32(&r, off, sizeof(r));\n\twil_mbox_ring_le2cpus(&r);\n\t \n\trsize = r.size / sizeof(struct wil6210_mbox_ring_desc);\n\n\tseq_printf(s, \"ring %s = {\\n\", prefix);\n\tseq_printf(s, \"  base = 0x%08x\\n\", r.base);\n\tseq_printf(s, \"  size = 0x%04x bytes -> %d entries\\n\", r.size, rsize);\n\tseq_printf(s, \"  tail = 0x%08x\\n\", r.tail);\n\tseq_printf(s, \"  head = 0x%08x\\n\", r.head);\n\tseq_printf(s, \"  entry size = %d\\n\", r.entry_size);\n\n\tif (r.size % sizeof(struct wil6210_mbox_ring_desc)) {\n\t\tseq_printf(s, \"  ??? size is not multiple of %zd, garbage?\\n\",\n\t\t\t   sizeof(struct wil6210_mbox_ring_desc));\n\t\tgoto out;\n\t}\n\n\tif (!wmi_addr(wil, r.base) ||\n\t    !wmi_addr(wil, r.tail) ||\n\t    !wmi_addr(wil, r.head)) {\n\t\tseq_puts(s, \"  ??? pointers are garbage?\\n\");\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < rsize; i++) {\n\t\tstruct wil6210_mbox_ring_desc d;\n\t\tstruct wil6210_mbox_hdr hdr;\n\t\tsize_t delta = i * sizeof(d);\n\t\tvoid __iomem *x = wil->csr + HOSTADDR(r.base) + delta;\n\n\t\twil_memcpy_fromio_32(&d, x, sizeof(d));\n\n\t\tseq_printf(s, \"  [%2x] %s %s%s 0x%08x\", i,\n\t\t\t   d.sync ? \"F\" : \"E\",\n\t\t\t   (r.tail - r.base == delta) ? \"t\" : \" \",\n\t\t\t   (r.head - r.base == delta) ? \"h\" : \" \",\n\t\t\t   le32_to_cpu(d.addr));\n\t\tif (0 == wmi_read_hdr(wil, d.addr, &hdr)) {\n\t\t\tu16 len = le16_to_cpu(hdr.len);\n\n\t\t\tseq_printf(s, \" -> %04x %04x %04x %02x\\n\",\n\t\t\t\t   le16_to_cpu(hdr.seq), len,\n\t\t\t\t   le16_to_cpu(hdr.type), hdr.flags);\n\t\t\tif (len <= MAX_MBOXITEM_SIZE) {\n\t\t\t\tunsigned char databuf[MAX_MBOXITEM_SIZE];\n\t\t\t\tvoid __iomem *src = wmi_buffer(wil, d.addr) +\n\t\t\t\t\tsizeof(struct wil6210_mbox_hdr);\n\t\t\t\t \n\t\t\t\twil_memcpy_fromio_32(databuf, src, len);\n\t\t\t\twil_seq_hexdump(s, databuf, len, \"      : \");\n\t\t\t}\n\t\t} else {\n\t\t\tseq_puts(s, \"\\n\");\n\t\t}\n\t}\n out:\n\tseq_puts(s, \"}\\n\");\n\twil_mem_access_unlock(wil);\n\twil_halp_unvote(wil);\n}\n\nstatic int mbox_show(struct seq_file *s, void *data)\n{\n\tstruct wil6210_priv *wil = s->private;\n\tint ret;\n\n\tret = wil_pm_runtime_get(wil);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twil_print_mbox_ring(s, \"tx\", wil->csr + HOST_MBOX +\n\t\t       offsetof(struct wil6210_mbox_ctl, tx));\n\twil_print_mbox_ring(s, \"rx\", wil->csr + HOST_MBOX +\n\t\t       offsetof(struct wil6210_mbox_ctl, rx));\n\n\twil_pm_runtime_put(wil);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(mbox);\n\nstatic int wil_debugfs_iomem_x32_set(void *data, u64 val)\n{\n\tstruct wil_debugfs_iomem_data *d = (struct\n\t\t\t\t\t    wil_debugfs_iomem_data *)data;\n\tstruct wil6210_priv *wil = d->wil;\n\tint ret;\n\n\tret = wil_pm_runtime_get(wil);\n\tif (ret < 0)\n\t\treturn ret;\n\n\twritel_relaxed(val, (void __iomem *)d->offset);\n\n\twmb();  \n\n\twil_pm_runtime_put(wil);\n\n\treturn 0;\n}\n\nstatic int wil_debugfs_iomem_x32_get(void *data, u64 *val)\n{\n\tstruct wil_debugfs_iomem_data *d = (struct\n\t\t\t\t\t    wil_debugfs_iomem_data *)data;\n\tstruct wil6210_priv *wil = d->wil;\n\tint ret;\n\n\tret = wil_pm_runtime_get(wil);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*val = readl((void __iomem *)d->offset);\n\n\twil_pm_runtime_put(wil);\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(fops_iomem_x32, wil_debugfs_iomem_x32_get,\n\t\t\t wil_debugfs_iomem_x32_set, \"0x%08llx\\n\");\n\nstatic void wil_debugfs_create_iomem_x32(const char *name, umode_t mode,\n\t\t\t\t\t struct dentry *parent, void *value,\n\t\t\t\t\t struct wil6210_priv *wil)\n{\n\tstruct wil_debugfs_iomem_data *data = &wil->dbg_data.data_arr[\n\t\t\t\t\t      wil->dbg_data.iomem_data_count];\n\n\tdata->wil = wil;\n\tdata->offset = value;\n\n\tdebugfs_create_file_unsafe(name, mode, parent, data, &fops_iomem_x32);\n\twil->dbg_data.iomem_data_count++;\n}\n\nstatic int wil_debugfs_ulong_set(void *data, u64 val)\n{\n\t*(ulong *)data = val;\n\treturn 0;\n}\n\nstatic int wil_debugfs_ulong_get(void *data, u64 *val)\n{\n\t*val = *(ulong *)data;\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(wil_fops_ulong, wil_debugfs_ulong_get,\n\t\t\t wil_debugfs_ulong_set, \"0x%llx\\n\");\n\n \nstatic void wil6210_debugfs_init_offset(struct wil6210_priv *wil,\n\t\t\t\t\tstruct dentry *dbg, void *base,\n\t\t\t\t\tconst struct dbg_off * const tbl)\n{\n\tint i;\n\n\tfor (i = 0; tbl[i].name; i++) {\n\t\tswitch (tbl[i].type) {\n\t\tcase doff_u32:\n\t\t\tdebugfs_create_u32(tbl[i].name, tbl[i].mode, dbg,\n\t\t\t\t\t   base + tbl[i].off);\n\t\t\tbreak;\n\t\tcase doff_x32:\n\t\t\tdebugfs_create_x32(tbl[i].name, tbl[i].mode, dbg,\n\t\t\t\t\t   base + tbl[i].off);\n\t\t\tbreak;\n\t\tcase doff_ulong:\n\t\t\tdebugfs_create_file_unsafe(tbl[i].name, tbl[i].mode,\n\t\t\t\t\t\t   dbg, base + tbl[i].off,\n\t\t\t\t\t\t   &wil_fops_ulong);\n\t\t\tbreak;\n\t\tcase doff_io32:\n\t\t\twil_debugfs_create_iomem_x32(tbl[i].name, tbl[i].mode,\n\t\t\t\t\t\t     dbg, base + tbl[i].off,\n\t\t\t\t\t\t     wil);\n\t\t\tbreak;\n\t\tcase doff_u8:\n\t\t\tdebugfs_create_u8(tbl[i].name, tbl[i].mode, dbg,\n\t\t\t\t\t  base + tbl[i].off);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic const struct dbg_off isr_off[] = {\n\t{\"ICC\", 0644, offsetof(struct RGF_ICR, ICC), doff_io32},\n\t{\"ICR\", 0644, offsetof(struct RGF_ICR, ICR), doff_io32},\n\t{\"ICM\", 0644, offsetof(struct RGF_ICR, ICM), doff_io32},\n\t{\"ICS\",\t0244, offsetof(struct RGF_ICR, ICS), doff_io32},\n\t{\"IMV\", 0644, offsetof(struct RGF_ICR, IMV), doff_io32},\n\t{\"IMS\",\t0244, offsetof(struct RGF_ICR, IMS), doff_io32},\n\t{\"IMC\",\t0244, offsetof(struct RGF_ICR, IMC), doff_io32},\n\t{},\n};\n\nstatic void wil6210_debugfs_create_ISR(struct wil6210_priv *wil,\n\t\t\t\t       const char *name, struct dentry *parent,\n\t\t\t\t       u32 off)\n{\n\tstruct dentry *d = debugfs_create_dir(name, parent);\n\n\twil6210_debugfs_init_offset(wil, d, (void * __force)wil->csr + off,\n\t\t\t\t    isr_off);\n}\n\nstatic const struct dbg_off pseudo_isr_off[] = {\n\t{\"CAUSE\",   0444, HOSTADDR(RGF_DMA_PSEUDO_CAUSE), doff_io32},\n\t{\"MASK_SW\", 0444, HOSTADDR(RGF_DMA_PSEUDO_CAUSE_MASK_SW), doff_io32},\n\t{\"MASK_FW\", 0444, HOSTADDR(RGF_DMA_PSEUDO_CAUSE_MASK_FW), doff_io32},\n\t{},\n};\n\nstatic void wil6210_debugfs_create_pseudo_ISR(struct wil6210_priv *wil,\n\t\t\t\t\t      struct dentry *parent)\n{\n\tstruct dentry *d = debugfs_create_dir(\"PSEUDO_ISR\", parent);\n\n\twil6210_debugfs_init_offset(wil, d, (void * __force)wil->csr,\n\t\t\t\t    pseudo_isr_off);\n}\n\nstatic const struct dbg_off lgc_itr_cnt_off[] = {\n\t{\"TRSH\", 0644, HOSTADDR(RGF_DMA_ITR_CNT_TRSH), doff_io32},\n\t{\"DATA\", 0644, HOSTADDR(RGF_DMA_ITR_CNT_DATA), doff_io32},\n\t{\"CTL\",  0644, HOSTADDR(RGF_DMA_ITR_CNT_CRL), doff_io32},\n\t{},\n};\n\nstatic const struct dbg_off tx_itr_cnt_off[] = {\n\t{\"TRSH\", 0644, HOSTADDR(RGF_DMA_ITR_TX_CNT_TRSH),\n\t doff_io32},\n\t{\"DATA\", 0644, HOSTADDR(RGF_DMA_ITR_TX_CNT_DATA),\n\t doff_io32},\n\t{\"CTL\",  0644, HOSTADDR(RGF_DMA_ITR_TX_CNT_CTL),\n\t doff_io32},\n\t{\"IDL_TRSH\", 0644, HOSTADDR(RGF_DMA_ITR_TX_IDL_CNT_TRSH),\n\t doff_io32},\n\t{\"IDL_DATA\", 0644, HOSTADDR(RGF_DMA_ITR_TX_IDL_CNT_DATA),\n\t doff_io32},\n\t{\"IDL_CTL\",  0644, HOSTADDR(RGF_DMA_ITR_TX_IDL_CNT_CTL),\n\t doff_io32},\n\t{},\n};\n\nstatic const struct dbg_off rx_itr_cnt_off[] = {\n\t{\"TRSH\", 0644, HOSTADDR(RGF_DMA_ITR_RX_CNT_TRSH),\n\t doff_io32},\n\t{\"DATA\", 0644, HOSTADDR(RGF_DMA_ITR_RX_CNT_DATA),\n\t doff_io32},\n\t{\"CTL\",  0644, HOSTADDR(RGF_DMA_ITR_RX_CNT_CTL),\n\t doff_io32},\n\t{\"IDL_TRSH\", 0644, HOSTADDR(RGF_DMA_ITR_RX_IDL_CNT_TRSH),\n\t doff_io32},\n\t{\"IDL_DATA\", 0644, HOSTADDR(RGF_DMA_ITR_RX_IDL_CNT_DATA),\n\t doff_io32},\n\t{\"IDL_CTL\",  0644, HOSTADDR(RGF_DMA_ITR_RX_IDL_CNT_CTL),\n\t doff_io32},\n\t{},\n};\n\nstatic int wil6210_debugfs_create_ITR_CNT(struct wil6210_priv *wil,\n\t\t\t\t\t  struct dentry *parent)\n{\n\tstruct dentry *d, *dtx, *drx;\n\n\td = debugfs_create_dir(\"ITR_CNT\", parent);\n\n\tdtx = debugfs_create_dir(\"TX\", d);\n\tdrx = debugfs_create_dir(\"RX\", d);\n\n\twil6210_debugfs_init_offset(wil, d, (void * __force)wil->csr,\n\t\t\t\t    lgc_itr_cnt_off);\n\n\twil6210_debugfs_init_offset(wil, dtx, (void * __force)wil->csr,\n\t\t\t\t    tx_itr_cnt_off);\n\n\twil6210_debugfs_init_offset(wil, drx, (void * __force)wil->csr,\n\t\t\t\t    rx_itr_cnt_off);\n\treturn 0;\n}\n\nstatic int memread_show(struct seq_file *s, void *data)\n{\n\tstruct wil6210_priv *wil = s->private;\n\tvoid __iomem *a;\n\tint ret;\n\n\tret = wil_pm_runtime_get(wil);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wil_mem_access_lock(wil);\n\tif (ret) {\n\t\twil_pm_runtime_put(wil);\n\t\treturn ret;\n\t}\n\n\ta = wmi_buffer(wil, cpu_to_le32(mem_addr));\n\n\tif (a)\n\t\tseq_printf(s, \"[0x%08x] = 0x%08x\\n\", mem_addr, readl(a));\n\telse\n\t\tseq_printf(s, \"[0x%08x] = INVALID\\n\", mem_addr);\n\n\twil_mem_access_unlock(wil);\n\twil_pm_runtime_put(wil);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(memread);\n\nstatic ssize_t wil_read_file_ioblob(struct file *file, char __user *user_buf,\n\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tenum { max_count = 4096 };\n\tstruct wil_blob_wrapper *wil_blob = file->private_data;\n\tstruct wil6210_priv *wil = wil_blob->wil;\n\tloff_t aligned_pos, pos = *ppos;\n\tsize_t available = wil_blob->blob.size;\n\tvoid *buf;\n\tsize_t unaligned_bytes, aligned_count, ret;\n\tint rc;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\n\tif (pos >= available || !count)\n\t\treturn 0;\n\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tif (count > max_count)\n\t\tcount = max_count;\n\n\t \n\tunaligned_bytes = pos % 4;\n\taligned_pos = pos - unaligned_bytes;\n\taligned_count = count + unaligned_bytes;\n\n\tbuf = kmalloc(aligned_count, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\trc = wil_pm_runtime_get(wil);\n\tif (rc < 0) {\n\t\tkfree(buf);\n\t\treturn rc;\n\t}\n\n\trc = wil_mem_access_lock(wil);\n\tif (rc) {\n\t\tkfree(buf);\n\t\twil_pm_runtime_put(wil);\n\t\treturn rc;\n\t}\n\n\twil_memcpy_fromio_32(buf, (const void __iomem *)\n\t\t\t     wil_blob->blob.data + aligned_pos, aligned_count);\n\n\tret = copy_to_user(user_buf, buf + unaligned_bytes, count);\n\n\twil_mem_access_unlock(wil);\n\twil_pm_runtime_put(wil);\n\n\tkfree(buf);\n\tif (ret == count)\n\t\treturn -EFAULT;\n\n\tcount -= ret;\n\t*ppos = pos + count;\n\n\treturn count;\n}\n\nstatic const struct file_operations fops_ioblob = {\n\t.read =\t\twil_read_file_ioblob,\n\t.open =\t\tsimple_open,\n\t.llseek =\tdefault_llseek,\n};\n\nstatic\nstruct dentry *wil_debugfs_create_ioblob(const char *name,\n\t\t\t\t\t umode_t mode,\n\t\t\t\t\t struct dentry *parent,\n\t\t\t\t\t struct wil_blob_wrapper *wil_blob)\n{\n\treturn debugfs_create_file(name, mode, parent, wil_blob, &fops_ioblob);\n}\n\n \nstatic ssize_t wil_write_file_rxon(struct file *file, const char __user *buf,\n\t\t\t\t   size_t len, loff_t *ppos)\n{\n\tstruct wil6210_priv *wil = file->private_data;\n\tint rc;\n\tlong channel;\n\tbool on;\n\n\tchar *kbuf = memdup_user_nul(buf, len);\n\n\tif (IS_ERR(kbuf))\n\t\treturn PTR_ERR(kbuf);\n\trc = kstrtol(kbuf, 0, &channel);\n\tkfree(kbuf);\n\tif (rc)\n\t\treturn rc;\n\n\tif ((channel < 0) || (channel > 4)) {\n\t\twil_err(wil, \"Invalid channel %ld\\n\", channel);\n\t\treturn -EINVAL;\n\t}\n\ton = !!channel;\n\n\tif (on) {\n\t\trc = wmi_set_channel(wil, (int)channel);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\n\trc = wmi_rxon(wil, on);\n\tif (rc)\n\t\treturn rc;\n\n\treturn len;\n}\n\nstatic const struct file_operations fops_rxon = {\n\t.write = wil_write_file_rxon,\n\t.open  = simple_open,\n};\n\nstatic ssize_t wil_write_file_rbufcap(struct file *file,\n\t\t\t\t      const char __user *buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct wil6210_priv *wil = file->private_data;\n\tint val;\n\tint rc;\n\n\trc = kstrtoint_from_user(buf, count, 0, &val);\n\tif (rc) {\n\t\twil_err(wil, \"Invalid argument\\n\");\n\t\treturn rc;\n\t}\n\t \n\twil_info(wil, \"%s RBUFCAP, descriptors threshold - %d\\n\",\n\t\t val < 0 ? \"Disabling\" : \"Enabling\", val);\n\n\tif (!wil->ring_rx.va || val > wil->ring_rx.size) {\n\t\twil_err(wil, \"Invalid descriptors threshold, %d\\n\", val);\n\t\treturn -EINVAL;\n\t}\n\n\trc = wmi_rbufcap_cfg(wil, val < 0 ? 0 : 1, val < 0 ? 0 : val);\n\tif (rc) {\n\t\twil_err(wil, \"RBUFCAP config failed: %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\treturn count;\n}\n\nstatic const struct file_operations fops_rbufcap = {\n\t.write = wil_write_file_rbufcap,\n\t.open  = simple_open,\n};\n\n \nstatic ssize_t wil_write_back(struct file *file, const char __user *buf,\n\t\t\t      size_t len, loff_t *ppos)\n{\n\tstruct wil6210_priv *wil = file->private_data;\n\tint rc;\n\tchar *kbuf = kmalloc(len + 1, GFP_KERNEL);\n\tchar cmd[9];\n\tint p1, p2, p3;\n\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\trc = simple_write_to_buffer(kbuf, len, ppos, buf, len);\n\tif (rc != len) {\n\t\tkfree(kbuf);\n\t\treturn rc >= 0 ? -EIO : rc;\n\t}\n\n\tkbuf[len] = '\\0';\n\trc = sscanf(kbuf, \"%8s %d %d %d\", cmd, &p1, &p2, &p3);\n\tkfree(kbuf);\n\n\tif (rc < 0)\n\t\treturn rc;\n\tif (rc < 2)\n\t\treturn -EINVAL;\n\n\tif ((strcmp(cmd, \"add\") == 0) ||\n\t    (strcmp(cmd, \"del_tx\") == 0)) {\n\t\tstruct wil_ring_tx_data *txdata;\n\n\t\tif (p1 < 0 || p1 >= WIL6210_MAX_TX_RINGS) {\n\t\t\twil_err(wil, \"BACK: invalid ring id %d\\n\", p1);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttxdata = &wil->ring_tx_data[p1];\n\t\tif (strcmp(cmd, \"add\") == 0) {\n\t\t\tif (rc < 3) {\n\t\t\t\twil_err(wil, \"BACK: add require at least 2 params\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (rc < 4)\n\t\t\t\tp3 = 0;\n\t\t\twmi_addba(wil, txdata->mid, p1, p2, p3);\n\t\t} else {\n\t\t\tif (rc < 3)\n\t\t\t\tp2 = WLAN_REASON_QSTA_LEAVE_QBSS;\n\t\t\twmi_delba_tx(wil, txdata->mid, p1, p2);\n\t\t}\n\t} else if (strcmp(cmd, \"del_rx\") == 0) {\n\t\tstruct wil_sta_info *sta;\n\n\t\tif (rc < 3) {\n\t\t\twil_err(wil,\n\t\t\t\t\"BACK: del_rx require at least 2 params\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (p1 < 0 || p1 >= wil->max_assoc_sta) {\n\t\t\twil_err(wil, \"BACK: invalid CID %d\\n\", p1);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (rc < 4)\n\t\t\tp3 = WLAN_REASON_QSTA_LEAVE_QBSS;\n\t\tsta = &wil->sta[p1];\n\t\twmi_delba_rx(wil, sta->mid, p1, p2, p3);\n\t} else {\n\t\twil_err(wil, \"BACK: Unrecognized command \\\"%s\\\"\\n\", cmd);\n\t\treturn -EINVAL;\n\t}\n\n\treturn len;\n}\n\nstatic ssize_t wil_read_back(struct file *file, char __user *user_buf,\n\t\t\t     size_t count, loff_t *ppos)\n{\n\tstatic const char text[] = \"block ack control, write:\\n\"\n\t\" - \\\"add <ringid> <agg_size> <timeout>\\\" to trigger ADDBA\\n\"\n\t\"If missing, <timeout> defaults to 0\\n\"\n\t\" - \\\"del_tx <ringid> <reason>\\\" to trigger DELBA for Tx side\\n\"\n\t\" - \\\"del_rx <CID> <TID> <reason>\\\" to trigger DELBA for Rx side\\n\"\n\t\"If missing, <reason> set to \\\"STA_LEAVING\\\" (36)\\n\";\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, text,\n\t\t\t\t       sizeof(text));\n}\n\nstatic const struct file_operations fops_back = {\n\t.read = wil_read_back,\n\t.write = wil_write_back,\n\t.open  = simple_open,\n};\n\n \nstatic ssize_t wil_write_pmccfg(struct file *file, const char __user *buf,\n\t\t\t\tsize_t len, loff_t *ppos)\n{\n\tstruct wil6210_priv *wil = file->private_data;\n\tint rc;\n\tchar *kbuf = kmalloc(len + 1, GFP_KERNEL);\n\tchar cmd[9];\n\tint num_descs, desc_size;\n\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\trc = simple_write_to_buffer(kbuf, len, ppos, buf, len);\n\tif (rc != len) {\n\t\tkfree(kbuf);\n\t\treturn rc >= 0 ? -EIO : rc;\n\t}\n\n\tkbuf[len] = '\\0';\n\trc = sscanf(kbuf, \"%8s %d %d\", cmd, &num_descs, &desc_size);\n\tkfree(kbuf);\n\n\tif (rc < 0)\n\t\treturn rc;\n\n\tif (rc < 1) {\n\t\twil_err(wil, \"pmccfg: no params given\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (0 == strcmp(cmd, \"alloc\")) {\n\t\tif (rc != 3) {\n\t\t\twil_err(wil, \"pmccfg: alloc requires 2 params\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\twil_pmc_alloc(wil, num_descs, desc_size);\n\t} else if (0 == strcmp(cmd, \"free\")) {\n\t\tif (rc != 1) {\n\t\t\twil_err(wil, \"pmccfg: free does not have any params\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\twil_pmc_free(wil, true);\n\t} else {\n\t\twil_err(wil, \"pmccfg: Unrecognized command \\\"%s\\\"\\n\", cmd);\n\t\treturn -EINVAL;\n\t}\n\n\treturn len;\n}\n\nstatic ssize_t wil_read_pmccfg(struct file *file, char __user *user_buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct wil6210_priv *wil = file->private_data;\n\tchar text[256];\n\tchar help[] = \"pmc control, write:\\n\"\n\t\" - \\\"alloc <num descriptors> <descriptor_size>\\\" to allocate pmc\\n\"\n\t\" - \\\"free\\\" to free memory allocated for pmc\\n\";\n\n\tsnprintf(text, sizeof(text), \"Last command status: %d\\n\\n%s\",\n\t\t wil_pmc_last_cmd_status(wil), help);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, text,\n\t\t\t\t       strlen(text) + 1);\n}\n\nstatic const struct file_operations fops_pmccfg = {\n\t.read = wil_read_pmccfg,\n\t.write = wil_write_pmccfg,\n\t.open  = simple_open,\n};\n\nstatic const struct file_operations fops_pmcdata = {\n\t.open\t\t= simple_open,\n\t.read\t\t= wil_pmc_read,\n\t.llseek\t\t= wil_pmc_llseek,\n};\n\nstatic int wil_pmcring_seq_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, wil_pmcring_read, inode->i_private);\n}\n\nstatic const struct file_operations fops_pmcring = {\n\t.open\t\t= wil_pmcring_seq_open,\n\t.release\t= single_release,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n};\n\n \n \nstatic ssize_t wil_write_file_txmgmt(struct file *file, const char __user *buf,\n\t\t\t\t     size_t len, loff_t *ppos)\n{\n\tstruct wil6210_priv *wil = file->private_data;\n\tstruct wiphy *wiphy = wil_to_wiphy(wil);\n\tstruct wireless_dev *wdev = wil->main_ndev->ieee80211_ptr;\n\tstruct cfg80211_mgmt_tx_params params;\n\tint rc;\n\tvoid *frame;\n\n\tmemset(&params, 0, sizeof(params));\n\n\tif (!len)\n\t\treturn -EINVAL;\n\n\tframe = memdup_user(buf, len);\n\tif (IS_ERR(frame))\n\t\treturn PTR_ERR(frame);\n\n\tparams.buf = frame;\n\tparams.len = len;\n\n\trc = wil_cfg80211_mgmt_tx(wiphy, wdev, &params, NULL);\n\n\tkfree(frame);\n\twil_info(wil, \"-> %d\\n\", rc);\n\n\treturn len;\n}\n\nstatic const struct file_operations fops_txmgmt = {\n\t.write = wil_write_file_txmgmt,\n\t.open  = simple_open,\n};\n\n \nstatic ssize_t wil_write_file_wmi(struct file *file, const char __user *buf,\n\t\t\t\t  size_t len, loff_t *ppos)\n{\n\tstruct wil6210_priv *wil = file->private_data;\n\tstruct wil6210_vif *vif = ndev_to_vif(wil->main_ndev);\n\tstruct wmi_cmd_hdr *wmi;\n\tvoid *cmd;\n\tint cmdlen = len - sizeof(struct wmi_cmd_hdr);\n\tu16 cmdid;\n\tint rc1;\n\n\tif (cmdlen < 0 || *ppos != 0)\n\t\treturn -EINVAL;\n\n\twmi = memdup_user(buf, len);\n\tif (IS_ERR(wmi))\n\t\treturn PTR_ERR(wmi);\n\n\tcmd = (cmdlen > 0) ? &wmi[1] : NULL;\n\tcmdid = le16_to_cpu(wmi->command_id);\n\n\trc1 = wmi_send(wil, cmdid, vif->mid, cmd, cmdlen);\n\tkfree(wmi);\n\n\twil_info(wil, \"0x%04x[%d] -> %d\\n\", cmdid, cmdlen, rc1);\n\n\treturn len;\n}\n\nstatic const struct file_operations fops_wmi = {\n\t.write = wil_write_file_wmi,\n\t.open  = simple_open,\n};\n\nstatic void wil_seq_print_skb(struct seq_file *s, struct sk_buff *skb)\n{\n\tint i = 0;\n\tint len = skb_headlen(skb);\n\tvoid *p = skb->data;\n\tint nr_frags = skb_shinfo(skb)->nr_frags;\n\n\tseq_printf(s, \"    len = %d\\n\", len);\n\twil_seq_hexdump(s, p, len, \"      : \");\n\n\tif (nr_frags) {\n\t\tseq_printf(s, \"    nr_frags = %d\\n\", nr_frags);\n\t\tfor (i = 0; i < nr_frags; i++) {\n\t\t\tconst skb_frag_t *frag = &skb_shinfo(skb)->frags[i];\n\n\t\t\tlen = skb_frag_size(frag);\n\t\t\tp = skb_frag_address_safe(frag);\n\t\t\tseq_printf(s, \"    [%2d] : len = %d\\n\", i, len);\n\t\t\twil_seq_hexdump(s, p, len, \"      : \");\n\t\t}\n\t}\n}\n\n \nstatic int txdesc_show(struct seq_file *s, void *data)\n{\n\tstruct wil6210_priv *wil = s->private;\n\tstruct wil_ring *ring;\n\tbool tx;\n\tint ring_idx = dbg_ring_index;\n\tint txdesc_idx = dbg_txdesc_index;\n\tvolatile struct vring_tx_desc *d;\n\tvolatile u32 *u;\n\tstruct sk_buff *skb;\n\n\tif (wil->use_enhanced_dma_hw) {\n\t\t \n\t\tif (ring_idx >= WIL6210_MAX_TX_RINGS) {\n\t\t\tseq_printf(s, \"invalid ring index %d\\n\", ring_idx);\n\t\t\treturn 0;\n\t\t}\n\t\ttx = ring_idx > 0;  \n\t} else {\n\t\t \n\t\tif (ring_idx > WIL6210_MAX_TX_RINGS) {\n\t\t\tseq_printf(s, \"invalid ring index %d\\n\", ring_idx);\n\t\t\treturn 0;\n\t\t}\n\t\ttx = (ring_idx < WIL6210_MAX_TX_RINGS);\n\t}\n\n\tring = tx ? &wil->ring_tx[ring_idx] : &wil->ring_rx;\n\n\tif (!ring->va) {\n\t\tif (tx)\n\t\t\tseq_printf(s, \"No Tx[%2d] RING\\n\", ring_idx);\n\t\telse\n\t\t\tseq_puts(s, \"No Rx RING\\n\");\n\t\treturn 0;\n\t}\n\n\tif (txdesc_idx >= ring->size) {\n\t\tif (tx)\n\t\t\tseq_printf(s, \"[%2d] TxDesc index (%d) >= size (%d)\\n\",\n\t\t\t\t   ring_idx, txdesc_idx, ring->size);\n\t\telse\n\t\t\tseq_printf(s, \"RxDesc index (%d) >= size (%d)\\n\",\n\t\t\t\t   txdesc_idx, ring->size);\n\t\treturn 0;\n\t}\n\n\t \n\td = &ring->va[txdesc_idx].tx.legacy;\n\tu = (volatile u32 *)d;\n\tskb = NULL;\n\n\tif (wil->use_enhanced_dma_hw) {\n\t\tif (tx) {\n\t\t\tskb = ring->ctx ? ring->ctx[txdesc_idx].skb : NULL;\n\t\t} else if (wil->rx_buff_mgmt.buff_arr) {\n\t\t\tstruct wil_rx_enhanced_desc *rx_d =\n\t\t\t\t(struct wil_rx_enhanced_desc *)\n\t\t\t\t&ring->va[txdesc_idx].rx.enhanced;\n\t\t\tu16 buff_id = le16_to_cpu(rx_d->mac.buff_id);\n\n\t\t\tif (!wil_val_in_range(buff_id, 0,\n\t\t\t\t\t      wil->rx_buff_mgmt.size))\n\t\t\t\tseq_printf(s, \"invalid buff_id %d\\n\", buff_id);\n\t\t\telse\n\t\t\t\tskb = wil->rx_buff_mgmt.buff_arr[buff_id].skb;\n\t\t}\n\t} else {\n\t\tskb = ring->ctx[txdesc_idx].skb;\n\t}\n\tif (tx)\n\t\tseq_printf(s, \"Tx[%2d][%3d] = {\\n\", ring_idx,\n\t\t\t   txdesc_idx);\n\telse\n\t\tseq_printf(s, \"Rx[%3d] = {\\n\", txdesc_idx);\n\tseq_printf(s, \"  MAC = 0x%08x 0x%08x 0x%08x 0x%08x\\n\",\n\t\t   u[0], u[1], u[2], u[3]);\n\tseq_printf(s, \"  DMA = 0x%08x 0x%08x 0x%08x 0x%08x\\n\",\n\t\t   u[4], u[5], u[6], u[7]);\n\tseq_printf(s, \"  SKB = 0x%p\\n\", skb);\n\n\tif (skb) {\n\t\tskb_get(skb);\n\t\twil_seq_print_skb(s, skb);\n\t\tkfree_skb(skb);\n\t}\n\tseq_puts(s, \"}\\n\");\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(txdesc);\n\n \nstatic int status_msg_show(struct seq_file *s, void *data)\n{\n\tstruct wil6210_priv *wil = s->private;\n\tint sring_idx = dbg_sring_index;\n\tstruct wil_status_ring *sring;\n\tbool tx;\n\tu32 status_msg_idx = dbg_status_msg_index;\n\tu32 *u;\n\n\tif (sring_idx >= WIL6210_MAX_STATUS_RINGS) {\n\t\tseq_printf(s, \"invalid status ring index %d\\n\", sring_idx);\n\t\treturn 0;\n\t}\n\n\tsring = &wil->srings[sring_idx];\n\ttx = !sring->is_rx;\n\n\tif (!sring->va) {\n\t\tseq_printf(s, \"No %cX status ring\\n\", tx ? 'T' : 'R');\n\t\treturn 0;\n\t}\n\n\tif (status_msg_idx >= sring->size) {\n\t\tseq_printf(s, \"%cxDesc index (%d) >= size (%d)\\n\",\n\t\t\t   tx ? 'T' : 'R', status_msg_idx, sring->size);\n\t\treturn 0;\n\t}\n\n\tu = sring->va + (sring->elem_size * status_msg_idx);\n\n\tseq_printf(s, \"%cx[%d][%3d] = {\\n\",\n\t\t   tx ? 'T' : 'R', sring_idx, status_msg_idx);\n\n\tseq_printf(s, \"  0x%08x 0x%08x 0x%08x 0x%08x\\n\",\n\t\t   u[0], u[1], u[2], u[3]);\n\tif (!tx && !wil->use_compressed_rx_status)\n\t\tseq_printf(s, \"  0x%08x 0x%08x 0x%08x 0x%08x\\n\",\n\t\t\t   u[4], u[5], u[6], u[7]);\n\n\tseq_puts(s, \"}\\n\");\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(status_msg);\n\nstatic int wil_print_rx_buff(struct seq_file *s, struct list_head *lh)\n{\n\tstruct wil_rx_buff *it;\n\tint i = 0;\n\n\tlist_for_each_entry(it, lh, list) {\n\t\tif ((i % 16) == 0 && i != 0)\n\t\t\tseq_puts(s, \"\\n    \");\n\t\tseq_printf(s, \"[%4d] \", it->id);\n\t\ti++;\n\t}\n\tseq_printf(s, \"\\nNumber of buffers: %u\\n\", i);\n\n\treturn i;\n}\n\nstatic int rx_buff_mgmt_show(struct seq_file *s, void *data)\n{\n\tstruct wil6210_priv *wil = s->private;\n\tstruct wil_rx_buff_mgmt *rbm = &wil->rx_buff_mgmt;\n\tint num_active;\n\tint num_free;\n\n\tif (!rbm->buff_arr)\n\t\treturn -EINVAL;\n\n\tseq_printf(s, \"  size = %zu\\n\", rbm->size);\n\tseq_printf(s, \"  free_list_empty_cnt = %lu\\n\",\n\t\t   rbm->free_list_empty_cnt);\n\n\t \n\tseq_puts(s, \"  Active list:\\n\");\n\tnum_active = wil_print_rx_buff(s, &rbm->active);\n\tseq_puts(s, \"\\n  Free list:\\n\");\n\tnum_free = wil_print_rx_buff(s, &rbm->free);\n\n\tseq_printf(s, \"  Total number of buffers: %u\\n\",\n\t\t   num_active + num_free);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(rx_buff_mgmt);\n\n \nstatic char *wil_bfstatus_str(u32 status)\n{\n\tswitch (status) {\n\tcase 0:\n\t\treturn \"Failed\";\n\tcase 1:\n\t\treturn \"OK\";\n\tcase 2:\n\t\treturn \"Retrying\";\n\tdefault:\n\t\treturn \"??\";\n\t}\n}\n\nstatic bool is_all_zeros(void * const x_, size_t sz)\n{\n\t \n\tu32 *x = x_;\n\tint n;\n\n\tfor (n = 0; n < sz / sizeof(*x); n++)\n\t\tif (x[n])\n\t\t\treturn false;\n\n\treturn true;\n}\n\nstatic int bf_show(struct seq_file *s, void *data)\n{\n\tint rc;\n\tint i;\n\tstruct wil6210_priv *wil = s->private;\n\tstruct wil6210_vif *vif = ndev_to_vif(wil->main_ndev);\n\tstruct wmi_notify_req_cmd cmd = {\n\t\t.interval_usec = 0,\n\t};\n\tstruct {\n\t\tstruct wmi_cmd_hdr wmi;\n\t\tstruct wmi_notify_req_done_event evt;\n\t} __packed reply;\n\n\tmemset(&reply, 0, sizeof(reply));\n\n\tfor (i = 0; i < wil->max_assoc_sta; i++) {\n\t\tu32 status;\n\t\tu8 bf_mcs;\n\n\t\tcmd.cid = i;\n\t\trc = wmi_call(wil, WMI_NOTIFY_REQ_CMDID, vif->mid,\n\t\t\t      &cmd, sizeof(cmd),\n\t\t\t      WMI_NOTIFY_REQ_DONE_EVENTID, &reply,\n\t\t\t      sizeof(reply), WIL_WMI_CALL_GENERAL_TO_MS);\n\t\t \n\t\tif (rc || is_all_zeros(&reply.evt, sizeof(reply.evt)))\n\t\t\tcontinue;\n\n\t\tstatus = le32_to_cpu(reply.evt.status);\n\t\tbf_mcs = le16_to_cpu(reply.evt.bf_mcs);\n\t\tseq_printf(s, \"CID %d {\\n\"\n\t\t\t   \"  TSF = 0x%016llx\\n\"\n\t\t\t   \"  TxMCS = %s TxTpt = %4d\\n\"\n\t\t\t   \"  SQI = %4d\\n\"\n\t\t\t   \"  RSSI = %4d\\n\"\n\t\t\t   \"  Status = 0x%08x %s\\n\"\n\t\t\t   \"  Sectors(rx:tx) my %2d:%2d peer %2d:%2d\\n\"\n\t\t\t   \"  Goodput(rx:tx) %4d:%4d\\n\"\n\t\t\t   \"}\\n\",\n\t\t\t   i,\n\t\t\t   le64_to_cpu(reply.evt.tsf),\n\t\t\t   WIL_EXTENDED_MCS_CHECK(bf_mcs),\n\t\t\t   le32_to_cpu(reply.evt.tx_tpt),\n\t\t\t   reply.evt.sqi,\n\t\t\t   reply.evt.rssi,\n\t\t\t   status, wil_bfstatus_str(status),\n\t\t\t   le16_to_cpu(reply.evt.my_rx_sector),\n\t\t\t   le16_to_cpu(reply.evt.my_tx_sector),\n\t\t\t   le16_to_cpu(reply.evt.other_rx_sector),\n\t\t\t   le16_to_cpu(reply.evt.other_tx_sector),\n\t\t\t   le32_to_cpu(reply.evt.rx_goodput),\n\t\t\t   le32_to_cpu(reply.evt.tx_goodput));\n\t}\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(bf);\n\n \nstatic void print_temp(struct seq_file *s, const char *prefix, s32 t)\n{\n\tswitch (t) {\n\tcase 0:\n\tcase WMI_INVALID_TEMPERATURE:\n\t\tseq_printf(s, \"%s N/A\\n\", prefix);\n\tbreak;\n\tdefault:\n\t\tseq_printf(s, \"%s %s%d.%03d\\n\", prefix, (t < 0 ? \"-\" : \"\"),\n\t\t\t   abs(t / 1000), abs(t % 1000));\n\t\tbreak;\n\t}\n}\n\nstatic int temp_show(struct seq_file *s, void *data)\n{\n\tstruct wil6210_priv *wil = s->private;\n\tint rc, i;\n\n\tif (test_bit(WMI_FW_CAPABILITY_TEMPERATURE_ALL_RF,\n\t\t     wil->fw_capabilities)) {\n\t\tstruct wmi_temp_sense_all_done_event sense_all_evt;\n\n\t\twil_dbg_misc(wil,\n\t\t\t     \"WMI_FW_CAPABILITY_TEMPERATURE_ALL_RF is supported\");\n\t\trc = wmi_get_all_temperatures(wil, &sense_all_evt);\n\t\tif (rc) {\n\t\t\tseq_puts(s, \"Failed\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tprint_temp(s, \"T_mac   =\",\n\t\t\t   le32_to_cpu(sense_all_evt.baseband_t1000));\n\t\tseq_printf(s, \"Connected RFs [0x%08x]\\n\",\n\t\t\t   sense_all_evt.rf_bitmap);\n\t\tfor (i = 0; i < WMI_MAX_XIF_PORTS_NUM; i++) {\n\t\t\tseq_printf(s, \"RF[%d]   = \", i);\n\t\t\tprint_temp(s, \"\",\n\t\t\t\t   le32_to_cpu(sense_all_evt.rf_t1000[i]));\n\t\t}\n\t} else {\n\t\ts32 t_m, t_r;\n\n\t\twil_dbg_misc(wil,\n\t\t\t     \"WMI_FW_CAPABILITY_TEMPERATURE_ALL_RF is not supported\");\n\t\trc = wmi_get_temperature(wil, &t_m, &t_r);\n\t\tif (rc) {\n\t\t\tseq_puts(s, \"Failed\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tprint_temp(s, \"T_mac   =\", t_m);\n\t\tprint_temp(s, \"T_radio =\", t_r);\n\t}\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(temp);\n\n \nstatic int link_show(struct seq_file *s, void *data)\n{\n\tstruct wil6210_priv *wil = s->private;\n\tstruct station_info *sinfo;\n\tint i, rc = 0;\n\n\tsinfo = kzalloc(sizeof(*sinfo), GFP_KERNEL);\n\tif (!sinfo)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < wil->max_assoc_sta; i++) {\n\t\tstruct wil_sta_info *p = &wil->sta[i];\n\t\tchar *status = \"unknown\";\n\t\tstruct wil6210_vif *vif;\n\t\tu8 mid;\n\n\t\tswitch (p->status) {\n\t\tcase wil_sta_unused:\n\t\t\tstatus = \"unused   \";\n\t\t\tbreak;\n\t\tcase wil_sta_conn_pending:\n\t\t\tstatus = \"pending  \";\n\t\t\tbreak;\n\t\tcase wil_sta_connected:\n\t\t\tstatus = \"connected\";\n\t\t\tbreak;\n\t\t}\n\t\tmid = (p->status != wil_sta_unused) ? p->mid : U8_MAX;\n\t\tseq_printf(s, \"[%d][MID %d] %pM %s\\n\",\n\t\t\t   i, mid, p->addr, status);\n\n\t\tif (p->status != wil_sta_connected)\n\t\t\tcontinue;\n\n\t\tvif = (mid < GET_MAX_VIFS(wil)) ? wil->vifs[mid] : NULL;\n\t\tif (vif) {\n\t\t\trc = wil_cid_fill_sinfo(vif, i, sinfo);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\n\t\t\tseq_printf(s, \"  Tx_mcs = %s\\n\",\n\t\t\t\t   WIL_EXTENDED_MCS_CHECK(sinfo->txrate.mcs));\n\t\t\tseq_printf(s, \"  Rx_mcs = %s\\n\",\n\t\t\t\t   WIL_EXTENDED_MCS_CHECK(sinfo->rxrate.mcs));\n\t\t\tseq_printf(s, \"  SQ     = %d\\n\", sinfo->signal);\n\t\t} else {\n\t\t\tseq_puts(s, \"  INVALID MID\\n\");\n\t\t}\n\t}\n\nout:\n\tkfree(sinfo);\n\treturn rc;\n}\nDEFINE_SHOW_ATTRIBUTE(link);\n\n \nstatic int info_show(struct seq_file *s, void *data)\n{\n\tstruct wil6210_priv *wil = s->private;\n\tstruct net_device *ndev = wil->main_ndev;\n\tint is_ac = power_supply_is_system_supplied();\n\tint rx = atomic_xchg(&wil->isr_count_rx, 0);\n\tint tx = atomic_xchg(&wil->isr_count_tx, 0);\n\tstatic ulong rxf_old, txf_old;\n\tulong rxf = ndev->stats.rx_packets;\n\tulong txf = ndev->stats.tx_packets;\n\tunsigned int i;\n\n\t \n\tseq_printf(s, \"AC powered : %d\\n\", is_ac);\n\tseq_printf(s, \"Rx irqs:packets : %8d : %8ld\\n\", rx, rxf - rxf_old);\n\tseq_printf(s, \"Tx irqs:packets : %8d : %8ld\\n\", tx, txf - txf_old);\n\trxf_old = rxf;\n\ttxf_old = txf;\n\n#define CHECK_QSTATE(x) (state & BIT(__QUEUE_STATE_ ## x)) ? \\\n\t\" \" __stringify(x) : \"\"\n\n\tfor (i = 0; i < ndev->num_tx_queues; i++) {\n\t\tstruct netdev_queue *txq = netdev_get_tx_queue(ndev, i);\n\t\tunsigned long state = txq->state;\n\n\t\tseq_printf(s, \"Tx queue[%i] state : 0x%lx%s%s%s\\n\", i, state,\n\t\t\t   CHECK_QSTATE(DRV_XOFF),\n\t\t\t   CHECK_QSTATE(STACK_XOFF),\n\t\t\t   CHECK_QSTATE(FROZEN)\n\t\t\t  );\n\t}\n#undef CHECK_QSTATE\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(info);\n\n \n \nstatic ssize_t wil_read_file_recovery(struct file *file, char __user *user_buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct wil6210_priv *wil = file->private_data;\n\tchar buf[80];\n\tint n;\n\tstatic const char * const sstate[] = {\"idle\", \"pending\", \"running\"};\n\n\tn = snprintf(buf, sizeof(buf), \"mode = %s\\nstate = %s\\n\",\n\t\t     no_fw_recovery ? \"manual\" : \"auto\",\n\t\t     sstate[wil->recovery_state]);\n\n\tn = min_t(int, n, sizeof(buf));\n\n\treturn simple_read_from_buffer(user_buf, count, ppos,\n\t\t\t\t       buf, n);\n}\n\nstatic ssize_t wil_write_file_recovery(struct file *file,\n\t\t\t\t       const char __user *buf_,\n\t\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct wil6210_priv *wil = file->private_data;\n\tstatic const char run_command[] = \"run\";\n\tchar buf[sizeof(run_command) + 1];  \n\tssize_t rc;\n\n\tif (wil->recovery_state != fw_recovery_pending) {\n\t\twil_err(wil, \"No recovery pending\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (*ppos != 0) {\n\t\twil_err(wil, \"Offset [%d]\\n\", (int)*ppos);\n\t\treturn -EINVAL;\n\t}\n\n\tif (count > sizeof(buf)) {\n\t\twil_err(wil, \"Input too long, len = %d\\n\", (int)count);\n\t\treturn -EINVAL;\n\t}\n\n\trc = simple_write_to_buffer(buf, sizeof(buf) - 1, ppos, buf_, count);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tbuf[rc] = '\\0';\n\tif (0 == strcmp(buf, run_command))\n\t\twil_set_recovery_state(wil, fw_recovery_running);\n\telse\n\t\twil_err(wil, \"Bad recovery command \\\"%s\\\"\\n\", buf);\n\n\treturn rc;\n}\n\nstatic const struct file_operations fops_recovery = {\n\t.read = wil_read_file_recovery,\n\t.write = wil_write_file_recovery,\n\t.open  = simple_open,\n};\n\n \nstatic void wil_print_rxtid(struct seq_file *s, struct wil_tid_ampdu_rx *r)\n{\n\tint i;\n\tu16 index = ((r->head_seq_num - r->ssn) & 0xfff) % r->buf_size;\n\tunsigned long long drop_dup = r->drop_dup, drop_old = r->drop_old;\n\tunsigned long long drop_dup_mcast = r->drop_dup_mcast;\n\n\tseq_printf(s, \"([%2d]) 0x%03x [\", r->buf_size, r->head_seq_num);\n\tfor (i = 0; i < r->buf_size; i++) {\n\t\tif (i == index)\n\t\t\tseq_printf(s, \"%c\", r->reorder_buf[i] ? 'O' : '|');\n\t\telse\n\t\t\tseq_printf(s, \"%c\", r->reorder_buf[i] ? '*' : '_');\n\t}\n\tseq_printf(s,\n\t\t   \"] total %llu drop %llu (dup %llu + old %llu + dup mcast %llu) last 0x%03x\\n\",\n\t\t   r->total, drop_dup + drop_old + drop_dup_mcast, drop_dup,\n\t\t   drop_old, drop_dup_mcast, r->ssn_last_drop);\n}\n\nstatic void wil_print_rxtid_crypto(struct seq_file *s, int tid,\n\t\t\t\t   struct wil_tid_crypto_rx *c)\n{\n\tint i;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tstruct wil_tid_crypto_rx_single *cc = &c->key_id[i];\n\n\t\tif (cc->key_set)\n\t\t\tgoto has_keys;\n\t}\n\treturn;\n\nhas_keys:\n\tif (tid < WIL_STA_TID_NUM)\n\t\tseq_printf(s, \"  [%2d] PN\", tid);\n\telse\n\t\tseq_puts(s, \"  [GR] PN\");\n\n\tfor (i = 0; i < 4; i++) {\n\t\tstruct wil_tid_crypto_rx_single *cc = &c->key_id[i];\n\n\t\tseq_printf(s, \" [%i%s]%6phN\", i, cc->key_set ? \"+\" : \"-\",\n\t\t\t   cc->pn);\n\t}\n\tseq_puts(s, \"\\n\");\n}\n\nstatic int sta_show(struct seq_file *s, void *data)\n__acquires(&p->tid_rx_lock) __releases(&p->tid_rx_lock)\n{\n\tstruct wil6210_priv *wil = s->private;\n\tint i, tid, mcs;\n\n\tfor (i = 0; i < wil->max_assoc_sta; i++) {\n\t\tstruct wil_sta_info *p = &wil->sta[i];\n\t\tchar *status = \"unknown\";\n\t\tu8 aid = 0;\n\t\tu8 mid;\n\t\tbool sta_connected = false;\n\n\t\tswitch (p->status) {\n\t\tcase wil_sta_unused:\n\t\t\tstatus = \"unused   \";\n\t\t\tbreak;\n\t\tcase wil_sta_conn_pending:\n\t\t\tstatus = \"pending  \";\n\t\t\tbreak;\n\t\tcase wil_sta_connected:\n\t\t\tstatus = \"connected\";\n\t\t\taid = p->aid;\n\t\t\tbreak;\n\t\t}\n\t\tmid = (p->status != wil_sta_unused) ? p->mid : U8_MAX;\n\t\tif (mid < GET_MAX_VIFS(wil)) {\n\t\t\tstruct wil6210_vif *vif = wil->vifs[mid];\n\n\t\t\tif (vif->wdev.iftype == NL80211_IFTYPE_STATION &&\n\t\t\t    p->status == wil_sta_connected)\n\t\t\t\tsta_connected = true;\n\t\t}\n\t\t \n\t\tif (sta_connected)\n\t\t\tseq_printf(s, \"[%d] %pM connected (roam counter %d) MID %d AID %d\\n\",\n\t\t\t\t   i, p->addr, p->stats.ft_roams, mid, aid);\n\t\telse\n\t\t\tseq_printf(s, \"[%d] %pM %s MID %d AID %d\\n\", i,\n\t\t\t\t   p->addr, status, mid, aid);\n\n\t\tif (p->status == wil_sta_connected) {\n\t\t\tspin_lock_bh(&p->tid_rx_lock);\n\t\t\tfor (tid = 0; tid < WIL_STA_TID_NUM; tid++) {\n\t\t\t\tstruct wil_tid_ampdu_rx *r = p->tid_rx[tid];\n\t\t\t\tstruct wil_tid_crypto_rx *c =\n\t\t\t\t\t\t&p->tid_crypto_rx[tid];\n\n\t\t\t\tif (r) {\n\t\t\t\t\tseq_printf(s, \"  [%2d] \", tid);\n\t\t\t\t\twil_print_rxtid(s, r);\n\t\t\t\t}\n\n\t\t\t\twil_print_rxtid_crypto(s, tid, c);\n\t\t\t}\n\t\t\twil_print_rxtid_crypto(s, WIL_STA_TID_NUM,\n\t\t\t\t\t       &p->group_crypto_rx);\n\t\t\tspin_unlock_bh(&p->tid_rx_lock);\n\t\t\tseq_printf(s,\n\t\t\t\t   \"Rx invalid frame: non-data %lu, short %lu, large %lu, replay %lu\\n\",\n\t\t\t\t   p->stats.rx_non_data_frame,\n\t\t\t\t   p->stats.rx_short_frame,\n\t\t\t\t   p->stats.rx_large_frame,\n\t\t\t\t   p->stats.rx_replay);\n\t\t\tseq_printf(s,\n\t\t\t\t   \"mic error %lu, key error %lu, amsdu error %lu, csum error %lu\\n\",\n\t\t\t\t   p->stats.rx_mic_error,\n\t\t\t\t   p->stats.rx_key_error,\n\t\t\t\t   p->stats.rx_amsdu_error,\n\t\t\t\t   p->stats.rx_csum_err);\n\n\t\t\tseq_puts(s, \"Rx/MCS:\");\n\t\t\tfor (mcs = 0; mcs < ARRAY_SIZE(p->stats.rx_per_mcs);\n\t\t\t     mcs++)\n\t\t\t\tseq_printf(s, \" %lld\",\n\t\t\t\t\t   p->stats.rx_per_mcs[mcs]);\n\t\t\tseq_puts(s, \"\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(sta);\n\nstatic int mids_show(struct seq_file *s, void *data)\n{\n\tstruct wil6210_priv *wil = s->private;\n\tstruct wil6210_vif *vif;\n\tstruct net_device *ndev;\n\tint i;\n\n\tmutex_lock(&wil->vif_mutex);\n\tfor (i = 0; i < GET_MAX_VIFS(wil); i++) {\n\t\tvif = wil->vifs[i];\n\n\t\tif (vif) {\n\t\t\tndev = vif_to_ndev(vif);\n\t\t\tseq_printf(s, \"[%d] %pM %s\\n\", i, ndev->dev_addr,\n\t\t\t\t   ndev->name);\n\t\t} else {\n\t\t\tseq_printf(s, \"[%d] unused\\n\", i);\n\t\t}\n\t}\n\tmutex_unlock(&wil->vif_mutex);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(mids);\n\nstatic int wil_tx_latency_debugfs_show(struct seq_file *s, void *data)\n__acquires(&p->tid_rx_lock) __releases(&p->tid_rx_lock)\n{\n\tstruct wil6210_priv *wil = s->private;\n\tint i, bin;\n\n\tfor (i = 0; i < wil->max_assoc_sta; i++) {\n\t\tstruct wil_sta_info *p = &wil->sta[i];\n\t\tchar *status = \"unknown\";\n\t\tu8 aid = 0;\n\t\tu8 mid;\n\n\t\tif (!p->tx_latency_bins)\n\t\t\tcontinue;\n\n\t\tswitch (p->status) {\n\t\tcase wil_sta_unused:\n\t\t\tstatus = \"unused   \";\n\t\t\tbreak;\n\t\tcase wil_sta_conn_pending:\n\t\t\tstatus = \"pending  \";\n\t\t\tbreak;\n\t\tcase wil_sta_connected:\n\t\t\tstatus = \"connected\";\n\t\t\taid = p->aid;\n\t\t\tbreak;\n\t\t}\n\t\tmid = (p->status != wil_sta_unused) ? p->mid : U8_MAX;\n\t\tseq_printf(s, \"[%d] %pM %s MID %d AID %d\\n\", i, p->addr, status,\n\t\t\t   mid, aid);\n\n\t\tif (p->status == wil_sta_connected) {\n\t\t\tu64 num_packets = 0;\n\t\t\tu64 tx_latency_avg = p->stats.tx_latency_total_us;\n\n\t\t\tseq_puts(s, \"Tx/Latency bin:\");\n\t\t\tfor (bin = 0; bin < WIL_NUM_LATENCY_BINS; bin++) {\n\t\t\t\tseq_printf(s, \" %lld\",\n\t\t\t\t\t   p->tx_latency_bins[bin]);\n\t\t\t\tnum_packets += p->tx_latency_bins[bin];\n\t\t\t}\n\t\t\tseq_puts(s, \"\\n\");\n\t\t\tif (!num_packets)\n\t\t\t\tcontinue;\n\t\t\tdo_div(tx_latency_avg, num_packets);\n\t\t\tseq_printf(s, \"Tx/Latency min/avg/max (us): %d/%lld/%d\",\n\t\t\t\t   p->stats.tx_latency_min_us,\n\t\t\t\t   tx_latency_avg,\n\t\t\t\t   p->stats.tx_latency_max_us);\n\n\t\t\tseq_puts(s, \"\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int wil_tx_latency_seq_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, wil_tx_latency_debugfs_show,\n\t\t\t   inode->i_private);\n}\n\nstatic ssize_t wil_tx_latency_write(struct file *file, const char __user *buf,\n\t\t\t\t    size_t len, loff_t *ppos)\n{\n\tstruct seq_file *s = file->private_data;\n\tstruct wil6210_priv *wil = s->private;\n\tint val, rc, i;\n\tbool enable;\n\n\trc = kstrtoint_from_user(buf, len, 0, &val);\n\tif (rc) {\n\t\twil_err(wil, \"Invalid argument\\n\");\n\t\treturn rc;\n\t}\n\tif (val == 1)\n\t\t \n\t\tval = 500;\n\tif (val && (val < 50 || val > 1000)) {\n\t\twil_err(wil, \"Invalid resolution %d\\n\", val);\n\t\treturn -EINVAL;\n\t}\n\n\tenable = !!val;\n\tif (wil->tx_latency == enable)\n\t\treturn len;\n\n\twil_info(wil, \"%s TX latency measurements (resolution %dusec)\\n\",\n\t\t enable ? \"Enabling\" : \"Disabling\", val);\n\n\tif (enable) {\n\t\tsize_t sz = sizeof(u64) * WIL_NUM_LATENCY_BINS;\n\n\t\twil->tx_latency_res = val;\n\t\tfor (i = 0; i < wil->max_assoc_sta; i++) {\n\t\t\tstruct wil_sta_info *sta = &wil->sta[i];\n\n\t\t\tkfree(sta->tx_latency_bins);\n\t\t\tsta->tx_latency_bins = kzalloc(sz, GFP_KERNEL);\n\t\t\tif (!sta->tx_latency_bins)\n\t\t\t\treturn -ENOMEM;\n\t\t\tsta->stats.tx_latency_min_us = U32_MAX;\n\t\t\tsta->stats.tx_latency_max_us = 0;\n\t\t\tsta->stats.tx_latency_total_us = 0;\n\t\t}\n\t}\n\twil->tx_latency = enable;\n\n\treturn len;\n}\n\nstatic const struct file_operations fops_tx_latency = {\n\t.open\t\t= wil_tx_latency_seq_open,\n\t.release\t= single_release,\n\t.read\t\t= seq_read,\n\t.write\t\t= wil_tx_latency_write,\n\t.llseek\t\t= seq_lseek,\n};\n\nstatic void wil_link_stats_print_basic(struct wil6210_vif *vif,\n\t\t\t\t       struct seq_file *s,\n\t\t\t\t       struct wmi_link_stats_basic *basic)\n{\n\tchar per[5] = \"?\";\n\n\tif (basic->per_average != 0xff)\n\t\tsnprintf(per, sizeof(per), \"%d%%\", basic->per_average);\n\n\tseq_printf(s, \"CID %d {\\n\"\n\t\t   \"\\tTxMCS %s TxTpt %d\\n\"\n\t\t   \"\\tGoodput(rx:tx) %d:%d\\n\"\n\t\t   \"\\tRxBcastFrames %d\\n\"\n\t\t   \"\\tRSSI %d SQI %d SNR %d PER %s\\n\"\n\t\t   \"\\tRx RFC %d Ant num %d\\n\"\n\t\t   \"\\tSectors(rx:tx) my %d:%d peer %d:%d\\n\"\n\t\t   \"}\\n\",\n\t\t   basic->cid,\n\t\t   WIL_EXTENDED_MCS_CHECK(basic->bf_mcs),\n\t\t   le32_to_cpu(basic->tx_tpt),\n\t\t   le32_to_cpu(basic->rx_goodput),\n\t\t   le32_to_cpu(basic->tx_goodput),\n\t\t   le32_to_cpu(basic->rx_bcast_frames),\n\t\t   basic->rssi, basic->sqi, basic->snr, per,\n\t\t   basic->selected_rfc, basic->rx_effective_ant_num,\n\t\t   basic->my_rx_sector, basic->my_tx_sector,\n\t\t   basic->other_rx_sector, basic->other_tx_sector);\n}\n\nstatic void wil_link_stats_print_global(struct wil6210_priv *wil,\n\t\t\t\t\tstruct seq_file *s,\n\t\t\t\t\tstruct wmi_link_stats_global *global)\n{\n\tseq_printf(s, \"Frames(rx:tx) %d:%d\\n\"\n\t\t   \"BA Frames(rx:tx) %d:%d\\n\"\n\t\t   \"Beacons %d\\n\"\n\t\t   \"Rx Errors (MIC:CRC) %d:%d\\n\"\n\t\t   \"Tx Errors (no ack) %d\\n\",\n\t\t   le32_to_cpu(global->rx_frames),\n\t\t   le32_to_cpu(global->tx_frames),\n\t\t   le32_to_cpu(global->rx_ba_frames),\n\t\t   le32_to_cpu(global->tx_ba_frames),\n\t\t   le32_to_cpu(global->tx_beacons),\n\t\t   le32_to_cpu(global->rx_mic_errors),\n\t\t   le32_to_cpu(global->rx_crc_errors),\n\t\t   le32_to_cpu(global->tx_fail_no_ack));\n}\n\nstatic void wil_link_stats_debugfs_show_vif(struct wil6210_vif *vif,\n\t\t\t\t\t    struct seq_file *s)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tstruct wmi_link_stats_basic *stats;\n\tint i;\n\n\tif (!vif->fw_stats_ready) {\n\t\tseq_puts(s, \"no statistics\\n\");\n\t\treturn;\n\t}\n\n\tseq_printf(s, \"TSF %lld\\n\", vif->fw_stats_tsf);\n\tfor (i = 0; i < wil->max_assoc_sta; i++) {\n\t\tif (wil->sta[i].status == wil_sta_unused)\n\t\t\tcontinue;\n\t\tif (wil->sta[i].mid != vif->mid)\n\t\t\tcontinue;\n\n\t\tstats = &wil->sta[i].fw_stats_basic;\n\t\twil_link_stats_print_basic(vif, s, stats);\n\t}\n}\n\nstatic int wil_link_stats_debugfs_show(struct seq_file *s, void *data)\n{\n\tstruct wil6210_priv *wil = s->private;\n\tstruct wil6210_vif *vif;\n\tint i, rc;\n\n\trc = mutex_lock_interruptible(&wil->vif_mutex);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tfor (i = 0; i < GET_MAX_VIFS(wil); i++) {\n\t\tvif = wil->vifs[i];\n\n\t\tseq_printf(s, \"MID %d \", i);\n\t\tif (!vif) {\n\t\t\tseq_puts(s, \"unused\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\twil_link_stats_debugfs_show_vif(vif, s);\n\t}\n\n\tmutex_unlock(&wil->vif_mutex);\n\n\treturn 0;\n}\n\nstatic int wil_link_stats_seq_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, wil_link_stats_debugfs_show, inode->i_private);\n}\n\nstatic ssize_t wil_link_stats_write(struct file *file, const char __user *buf,\n\t\t\t\t    size_t len, loff_t *ppos)\n{\n\tstruct seq_file *s = file->private_data;\n\tstruct wil6210_priv *wil = s->private;\n\tint cid, interval, rc, i;\n\tstruct wil6210_vif *vif;\n\tchar *kbuf = kmalloc(len + 1, GFP_KERNEL);\n\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\trc = simple_write_to_buffer(kbuf, len, ppos, buf, len);\n\tif (rc != len) {\n\t\tkfree(kbuf);\n\t\treturn rc >= 0 ? -EIO : rc;\n\t}\n\n\tkbuf[len] = '\\0';\n\t \n\trc = sscanf(kbuf, \"%d %d\", &cid, &interval);\n\tkfree(kbuf);\n\tif (rc < 0)\n\t\treturn rc;\n\tif (rc < 2 || interval < 0)\n\t\treturn -EINVAL;\n\n\twil_info(wil, \"request link statistics, cid %d interval %d\\n\",\n\t\t cid, interval);\n\n\trc = mutex_lock_interruptible(&wil->vif_mutex);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (i = 0; i < GET_MAX_VIFS(wil); i++) {\n\t\tvif = wil->vifs[i];\n\t\tif (!vif)\n\t\t\tcontinue;\n\n\t\trc = wmi_link_stats_cfg(vif, WMI_LINK_STATS_TYPE_BASIC,\n\t\t\t\t\t(cid == -1 ? 0xff : cid), interval);\n\t\tif (rc)\n\t\t\twil_err(wil, \"link statistics failed for mid %d\\n\", i);\n\t}\n\tmutex_unlock(&wil->vif_mutex);\n\n\treturn len;\n}\n\nstatic const struct file_operations fops_link_stats = {\n\t.open\t\t= wil_link_stats_seq_open,\n\t.release\t= single_release,\n\t.read\t\t= seq_read,\n\t.write\t\t= wil_link_stats_write,\n\t.llseek\t\t= seq_lseek,\n};\n\nstatic int\nwil_link_stats_global_debugfs_show(struct seq_file *s, void *data)\n{\n\tstruct wil6210_priv *wil = s->private;\n\n\tif (!wil->fw_stats_global.ready)\n\t\treturn 0;\n\n\tseq_printf(s, \"TSF %lld\\n\", wil->fw_stats_global.tsf);\n\twil_link_stats_print_global(wil, s, &wil->fw_stats_global.stats);\n\n\treturn 0;\n}\n\nstatic int\nwil_link_stats_global_seq_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, wil_link_stats_global_debugfs_show,\n\t\t\t   inode->i_private);\n}\n\nstatic ssize_t\nwil_link_stats_global_write(struct file *file, const char __user *buf,\n\t\t\t    size_t len, loff_t *ppos)\n{\n\tstruct seq_file *s = file->private_data;\n\tstruct wil6210_priv *wil = s->private;\n\tint interval, rc;\n\tstruct wil6210_vif *vif = ndev_to_vif(wil->main_ndev);\n\n\t \n\trc = kstrtoint_from_user(buf, len, 0, &interval);\n\tif (rc || interval < 0) {\n\t\twil_err(wil, \"Invalid argument\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\twil_info(wil, \"request global link stats, interval %d\\n\", interval);\n\n\trc = wmi_link_stats_cfg(vif, WMI_LINK_STATS_TYPE_GLOBAL, 0, interval);\n\tif (rc)\n\t\twil_err(wil, \"global link stats failed %d\\n\", rc);\n\n\treturn rc ? rc : len;\n}\n\nstatic const struct file_operations fops_link_stats_global = {\n\t.open\t\t= wil_link_stats_global_seq_open,\n\t.release\t= single_release,\n\t.read\t\t= seq_read,\n\t.write\t\t= wil_link_stats_global_write,\n\t.llseek\t\t= seq_lseek,\n};\n\nstatic ssize_t wil_read_file_led_cfg(struct file *file, char __user *user_buf,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tchar buf[80];\n\tint n;\n\n\tn = snprintf(buf, sizeof(buf),\n\t\t     \"led_id is set to %d, echo 1 to enable, 0 to disable\\n\",\n\t\t     led_id);\n\n\tn = min_t(int, n, sizeof(buf));\n\n\treturn simple_read_from_buffer(user_buf, count, ppos,\n\t\t\t\t       buf, n);\n}\n\nstatic ssize_t wil_write_file_led_cfg(struct file *file,\n\t\t\t\t      const char __user *buf_,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct wil6210_priv *wil = file->private_data;\n\tint val;\n\tint rc;\n\n\trc = kstrtoint_from_user(buf_, count, 0, &val);\n\tif (rc) {\n\t\twil_err(wil, \"Invalid argument\\n\");\n\t\treturn rc;\n\t}\n\n\twil_info(wil, \"%s led %d\\n\", val ? \"Enabling\" : \"Disabling\", led_id);\n\trc = wmi_led_cfg(wil, val);\n\tif (rc) {\n\t\twil_info(wil, \"%s led %d failed\\n\",\n\t\t\t val ? \"Enabling\" : \"Disabling\", led_id);\n\t\treturn rc;\n\t}\n\n\treturn count;\n}\n\nstatic const struct file_operations fops_led_cfg = {\n\t.read = wil_read_file_led_cfg,\n\t.write = wil_write_file_led_cfg,\n\t.open  = simple_open,\n};\n\n \nstatic ssize_t wil_write_led_blink_time(struct file *file,\n\t\t\t\t\tconst char __user *buf,\n\t\t\t\t\tsize_t len, loff_t *ppos)\n{\n\tint rc;\n\tchar *kbuf = kmalloc(len + 1, GFP_KERNEL);\n\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\trc = simple_write_to_buffer(kbuf, len, ppos, buf, len);\n\tif (rc != len) {\n\t\tkfree(kbuf);\n\t\treturn rc >= 0 ? -EIO : rc;\n\t}\n\n\tkbuf[len] = '\\0';\n\trc = sscanf(kbuf, \"%d %d %d %d %d %d\",\n\t\t    &led_blink_time[WIL_LED_TIME_SLOW].on_ms,\n\t\t    &led_blink_time[WIL_LED_TIME_SLOW].off_ms,\n\t\t    &led_blink_time[WIL_LED_TIME_MED].on_ms,\n\t\t    &led_blink_time[WIL_LED_TIME_MED].off_ms,\n\t\t    &led_blink_time[WIL_LED_TIME_FAST].on_ms,\n\t\t    &led_blink_time[WIL_LED_TIME_FAST].off_ms);\n\tkfree(kbuf);\n\n\tif (rc < 0)\n\t\treturn rc;\n\tif (rc < 6)\n\t\treturn -EINVAL;\n\n\treturn len;\n}\n\nstatic ssize_t wil_read_led_blink_time(struct file *file, char __user *user_buf,\n\t\t\t\t       size_t count, loff_t *ppos)\n{\n\tstatic char text[400];\n\n\tsnprintf(text, sizeof(text),\n\t\t \"To set led blink on/off time variables write:\\n\"\n\t\t \"<blink_on_slow> <blink_off_slow> <blink_on_med> \"\n\t\t \"<blink_off_med> <blink_on_fast> <blink_off_fast>\\n\"\n\t\t \"The current values are:\\n\"\n\t\t \"%d %d %d %d %d %d\\n\",\n\t\t led_blink_time[WIL_LED_TIME_SLOW].on_ms,\n\t\t led_blink_time[WIL_LED_TIME_SLOW].off_ms,\n\t\t led_blink_time[WIL_LED_TIME_MED].on_ms,\n\t\t led_blink_time[WIL_LED_TIME_MED].off_ms,\n\t\t led_blink_time[WIL_LED_TIME_FAST].on_ms,\n\t\t led_blink_time[WIL_LED_TIME_FAST].off_ms);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, text,\n\t\t\t\t       sizeof(text));\n}\n\nstatic const struct file_operations fops_led_blink_time = {\n\t.read = wil_read_led_blink_time,\n\t.write = wil_write_led_blink_time,\n\t.open  = simple_open,\n};\n\n \nstatic int fw_capabilities_show(struct seq_file *s, void *data)\n{\n\tstruct wil6210_priv *wil = s->private;\n\n\tseq_printf(s, \"fw_capabilities : %*pb\\n\", WMI_FW_CAPABILITY_MAX,\n\t\t   wil->fw_capabilities);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(fw_capabilities);\n\n \nstatic int fw_version_show(struct seq_file *s, void *data)\n{\n\tstruct wil6210_priv *wil = s->private;\n\n\tif (wil->fw_version[0])\n\t\tseq_printf(s, \"%s\\n\", wil->fw_version);\n\telse\n\t\tseq_puts(s, \"N/A\\n\");\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(fw_version);\n\n \nstatic ssize_t wil_write_suspend_stats(struct file *file,\n\t\t\t\t       const char __user *buf,\n\t\t\t\t       size_t len, loff_t *ppos)\n{\n\tstruct wil6210_priv *wil = file->private_data;\n\n\tmemset(&wil->suspend_stats, 0, sizeof(wil->suspend_stats));\n\n\treturn len;\n}\n\nstatic ssize_t wil_read_suspend_stats(struct file *file,\n\t\t\t\t      char __user *user_buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct wil6210_priv *wil = file->private_data;\n\tchar *text;\n\tint n, ret, text_size = 500;\n\n\ttext = kmalloc(text_size, GFP_KERNEL);\n\tif (!text)\n\t\treturn -ENOMEM;\n\n\tn = snprintf(text, text_size,\n\t\t     \"Radio on suspend statistics:\\n\"\n\t\t     \"successful suspends:%ld failed suspends:%ld\\n\"\n\t\t     \"successful resumes:%ld failed resumes:%ld\\n\"\n\t\t     \"rejected by device:%ld\\n\"\n\t\t     \"Radio off suspend statistics:\\n\"\n\t\t     \"successful suspends:%ld failed suspends:%ld\\n\"\n\t\t     \"successful resumes:%ld failed resumes:%ld\\n\"\n\t\t     \"General statistics:\\n\"\n\t\t     \"rejected by host:%ld\\n\",\n\t\t     wil->suspend_stats.r_on.successful_suspends,\n\t\t     wil->suspend_stats.r_on.failed_suspends,\n\t\t     wil->suspend_stats.r_on.successful_resumes,\n\t\t     wil->suspend_stats.r_on.failed_resumes,\n\t\t     wil->suspend_stats.rejected_by_device,\n\t\t     wil->suspend_stats.r_off.successful_suspends,\n\t\t     wil->suspend_stats.r_off.failed_suspends,\n\t\t     wil->suspend_stats.r_off.successful_resumes,\n\t\t     wil->suspend_stats.r_off.failed_resumes,\n\t\t     wil->suspend_stats.rejected_by_host);\n\n\tn = min_t(int, n, text_size);\n\n\tret = simple_read_from_buffer(user_buf, count, ppos, text, n);\n\n\tkfree(text);\n\n\treturn ret;\n}\n\nstatic const struct file_operations fops_suspend_stats = {\n\t.read = wil_read_suspend_stats,\n\t.write = wil_write_suspend_stats,\n\t.open  = simple_open,\n};\n\n \nstatic ssize_t wil_compressed_rx_status_write(struct file *file,\n\t\t\t\t\t      const char __user *buf,\n\t\t\t\t\t      size_t len, loff_t *ppos)\n{\n\tstruct seq_file *s = file->private_data;\n\tstruct wil6210_priv *wil = s->private;\n\tint compressed_rx_status;\n\tint rc;\n\n\trc = kstrtoint_from_user(buf, len, 0, &compressed_rx_status);\n\tif (rc) {\n\t\twil_err(wil, \"Invalid argument\\n\");\n\t\treturn rc;\n\t}\n\n\tif (wil_has_active_ifaces(wil, true, false)) {\n\t\twil_err(wil, \"cannot change edma config after iface is up\\n\");\n\t\treturn -EPERM;\n\t}\n\n\twil_info(wil, \"%sable compressed_rx_status\\n\",\n\t\t compressed_rx_status ? \"En\" : \"Dis\");\n\n\twil->use_compressed_rx_status = compressed_rx_status;\n\n\treturn len;\n}\n\nstatic int\nwil_compressed_rx_status_show(struct seq_file *s, void *data)\n{\n\tstruct wil6210_priv *wil = s->private;\n\n\tseq_printf(s, \"%d\\n\", wil->use_compressed_rx_status);\n\n\treturn 0;\n}\n\nstatic int\nwil_compressed_rx_status_seq_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, wil_compressed_rx_status_show,\n\t\t\t   inode->i_private);\n}\n\nstatic const struct file_operations fops_compressed_rx_status = {\n\t.open  = wil_compressed_rx_status_seq_open,\n\t.release = single_release,\n\t.read = seq_read,\n\t.write = wil_compressed_rx_status_write,\n\t.llseek\t= seq_lseek,\n};\n\n \nstatic void wil6210_debugfs_init_blobs(struct wil6210_priv *wil,\n\t\t\t\t       struct dentry *dbg)\n{\n\tint i;\n\tchar name[32];\n\n\tfor (i = 0; i < ARRAY_SIZE(fw_mapping); i++) {\n\t\tstruct wil_blob_wrapper *wil_blob = &wil->blobs[i];\n\t\tstruct debugfs_blob_wrapper *blob = &wil_blob->blob;\n\t\tconst struct fw_map *map = &fw_mapping[i];\n\n\t\tif (!map->name)\n\t\t\tcontinue;\n\n\t\twil_blob->wil = wil;\n\t\tblob->data = (void * __force)wil->csr + HOSTADDR(map->host);\n\t\tblob->size = map->to - map->from;\n\t\tsnprintf(name, sizeof(name), \"blob_%s\", map->name);\n\t\twil_debugfs_create_ioblob(name, 0444, dbg, wil_blob);\n\t}\n}\n\n \nstatic const struct {\n\tconst char *name;\n\tumode_t mode;\n\tconst struct file_operations *fops;\n} dbg_files[] = {\n\t{\"mbox\",\t0444,\t\t&mbox_fops},\n\t{\"rings\",\t0444,\t\t&ring_fops},\n\t{\"stations\", 0444,\t\t&sta_fops},\n\t{\"mids\",\t0444,\t\t&mids_fops},\n\t{\"desc\",\t0444,\t\t&txdesc_fops},\n\t{\"bf\",\t\t0444,\t\t&bf_fops},\n\t{\"mem_val\",\t0644,\t\t&memread_fops},\n\t{\"rxon\",\t0244,\t\t&fops_rxon},\n\t{\"tx_mgmt\",\t0244,\t\t&fops_txmgmt},\n\t{\"wmi_send\", 0244,\t\t&fops_wmi},\n\t{\"back\",\t0644,\t\t&fops_back},\n\t{\"pmccfg\",\t0644,\t\t&fops_pmccfg},\n\t{\"pmcdata\",\t0444,\t\t&fops_pmcdata},\n\t{\"pmcring\",\t0444,\t\t&fops_pmcring},\n\t{\"temp\",\t0444,\t\t&temp_fops},\n\t{\"link\",\t0444,\t\t&link_fops},\n\t{\"info\",\t0444,\t\t&info_fops},\n\t{\"recovery\", 0644,\t\t&fops_recovery},\n\t{\"led_cfg\",\t0644,\t\t&fops_led_cfg},\n\t{\"led_blink_time\",\t0644,\t&fops_led_blink_time},\n\t{\"fw_capabilities\",\t0444,\t&fw_capabilities_fops},\n\t{\"fw_version\",\t0444,\t\t&fw_version_fops},\n\t{\"suspend_stats\",\t0644,\t&fops_suspend_stats},\n\t{\"compressed_rx_status\", 0644,\t&fops_compressed_rx_status},\n\t{\"srings\",\t0444,\t\t&srings_fops},\n\t{\"status_msg\",\t0444,\t\t&status_msg_fops},\n\t{\"rx_buff_mgmt\",\t0444,\t&rx_buff_mgmt_fops},\n\t{\"tx_latency\",\t0644,\t\t&fops_tx_latency},\n\t{\"link_stats\",\t0644,\t\t&fops_link_stats},\n\t{\"link_stats_global\",\t0644,\t&fops_link_stats_global},\n\t{\"rbufcap\",\t0244,\t\t&fops_rbufcap},\n};\n\nstatic void wil6210_debugfs_init_files(struct wil6210_priv *wil,\n\t\t\t\t       struct dentry *dbg)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(dbg_files); i++)\n\t\tdebugfs_create_file(dbg_files[i].name, dbg_files[i].mode, dbg,\n\t\t\t\t    wil, dbg_files[i].fops);\n}\n\n \nstatic const struct {\n\tconst char *name;\n\tu32 icr_off;\n} dbg_icr[] = {\n\t{\"USER_ICR\",\t\tHOSTADDR(RGF_USER_USER_ICR)},\n\t{\"DMA_EP_TX_ICR\",\tHOSTADDR(RGF_DMA_EP_TX_ICR)},\n\t{\"DMA_EP_RX_ICR\",\tHOSTADDR(RGF_DMA_EP_RX_ICR)},\n\t{\"DMA_EP_MISC_ICR\",\tHOSTADDR(RGF_DMA_EP_MISC_ICR)},\n};\n\nstatic void wil6210_debugfs_init_isr(struct wil6210_priv *wil,\n\t\t\t\t     struct dentry *dbg)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(dbg_icr); i++)\n\t\twil6210_debugfs_create_ISR(wil, dbg_icr[i].name, dbg,\n\t\t\t\t\t   dbg_icr[i].icr_off);\n}\n\n#define WIL_FIELD(name, mode, type) { __stringify(name), mode, \\\n\toffsetof(struct wil6210_priv, name), type}\n\n \nstatic const struct dbg_off dbg_wil_off[] = {\n\tWIL_FIELD(status[0],\t0644,\tdoff_ulong),\n\tWIL_FIELD(hw_version,\t0444,\tdoff_x32),\n\tWIL_FIELD(recovery_count, 0444,\tdoff_u32),\n\tWIL_FIELD(discovery_mode, 0644,\tdoff_u8),\n\tWIL_FIELD(chip_revision, 0444,\tdoff_u8),\n\tWIL_FIELD(abft_len, 0644,\t\tdoff_u8),\n\tWIL_FIELD(wakeup_trigger, 0644,\t\tdoff_u8),\n\tWIL_FIELD(ring_idle_trsh, 0644,\tdoff_u32),\n\tWIL_FIELD(num_rx_status_rings, 0644,\tdoff_u8),\n\tWIL_FIELD(rx_status_ring_order, 0644,\tdoff_u32),\n\tWIL_FIELD(tx_status_ring_order, 0644,\tdoff_u32),\n\tWIL_FIELD(rx_buff_id_count, 0644,\tdoff_u32),\n\tWIL_FIELD(amsdu_en, 0644,\tdoff_u8),\n\t{},\n};\n\nstatic const struct dbg_off dbg_wil_regs[] = {\n\t{\"RGF_MAC_MTRL_COUNTER_0\", 0444, HOSTADDR(RGF_MAC_MTRL_COUNTER_0),\n\t\tdoff_io32},\n\t{\"RGF_USER_USAGE_1\", 0444, HOSTADDR(RGF_USER_USAGE_1), doff_io32},\n\t{\"RGF_USER_USAGE_2\", 0444, HOSTADDR(RGF_USER_USAGE_2), doff_io32},\n\t{},\n};\n\n \nstatic const struct dbg_off dbg_statics[] = {\n\t{\"desc_index\",\t0644, (ulong)&dbg_txdesc_index, doff_u32},\n\t{\"ring_index\",\t0644, (ulong)&dbg_ring_index, doff_u32},\n\t{\"mem_addr\",\t0644, (ulong)&mem_addr, doff_u32},\n\t{\"led_polarity\", 0644, (ulong)&led_polarity, doff_u8},\n\t{\"status_index\", 0644, (ulong)&dbg_status_msg_index, doff_u32},\n\t{\"sring_index\",\t0644, (ulong)&dbg_sring_index, doff_u32},\n\t{\"drop_if_ring_full\", 0644, (ulong)&drop_if_ring_full, doff_u8},\n\t{},\n};\n\nstatic const int dbg_off_count = 4 * (ARRAY_SIZE(isr_off) - 1) +\n\t\t\t\tARRAY_SIZE(dbg_wil_regs) - 1 +\n\t\t\t\tARRAY_SIZE(pseudo_isr_off) - 1 +\n\t\t\t\tARRAY_SIZE(lgc_itr_cnt_off) - 1 +\n\t\t\t\tARRAY_SIZE(tx_itr_cnt_off) - 1 +\n\t\t\t\tARRAY_SIZE(rx_itr_cnt_off) - 1;\n\nint wil6210_debugfs_init(struct wil6210_priv *wil)\n{\n\tstruct dentry *dbg = wil->debug = debugfs_create_dir(WIL_NAME,\n\t\t\twil_to_wiphy(wil)->debugfsdir);\n\tif (IS_ERR_OR_NULL(dbg))\n\t\treturn -ENODEV;\n\n\twil->dbg_data.data_arr = kcalloc(dbg_off_count,\n\t\t\t\t\t sizeof(struct wil_debugfs_iomem_data),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!wil->dbg_data.data_arr) {\n\t\tdebugfs_remove_recursive(dbg);\n\t\twil->debug = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\twil->dbg_data.iomem_data_count = 0;\n\n\twil_pmc_init(wil);\n\n\twil6210_debugfs_init_files(wil, dbg);\n\twil6210_debugfs_init_isr(wil, dbg);\n\twil6210_debugfs_init_blobs(wil, dbg);\n\twil6210_debugfs_init_offset(wil, dbg, wil, dbg_wil_off);\n\twil6210_debugfs_init_offset(wil, dbg, (void * __force)wil->csr,\n\t\t\t\t    dbg_wil_regs);\n\twil6210_debugfs_init_offset(wil, dbg, NULL, dbg_statics);\n\n\twil6210_debugfs_create_pseudo_ISR(wil, dbg);\n\n\twil6210_debugfs_create_ITR_CNT(wil, dbg);\n\n\treturn 0;\n}\n\nvoid wil6210_debugfs_remove(struct wil6210_priv *wil)\n{\n\tint i;\n\n\tdebugfs_remove_recursive(wil->debug);\n\twil->debug = NULL;\n\n\tkfree(wil->dbg_data.data_arr);\n\tfor (i = 0; i < wil->max_assoc_sta; i++)\n\t\tkfree(wil->sta[i].tx_latency_bins);\n\n\t \n\twil_pmc_free(wil, false);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}