{
  "module_name": "pmc.c",
  "hash_id": "7c5a4ec74132d1316ab4340cfb4d25fd005346af2bf2941c4599a92019054de0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/wil6210/pmc.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include \"wmi.h\"\n#include \"wil6210.h\"\n#include \"txrx.h\"\n#include \"pmc.h\"\n\nstruct desc_alloc_info {\n\tdma_addr_t pa;\n\tvoid\t  *va;\n};\n\nstatic int wil_is_pmc_allocated(struct pmc_ctx *pmc)\n{\n\treturn !!pmc->pring_va;\n}\n\nvoid wil_pmc_init(struct wil6210_priv *wil)\n{\n\tmemset(&wil->pmc, 0, sizeof(struct pmc_ctx));\n\tmutex_init(&wil->pmc.lock);\n}\n\n \nvoid wil_pmc_alloc(struct wil6210_priv *wil,\n\t\t   int num_descriptors,\n\t\t   int descriptor_size)\n{\n\tu32 i;\n\tstruct pmc_ctx *pmc = &wil->pmc;\n\tstruct device *dev = wil_to_dev(wil);\n\tstruct wil6210_vif *vif = ndev_to_vif(wil->main_ndev);\n\tstruct wmi_pmc_cmd pmc_cmd = {0};\n\tint last_cmd_err = -ENOMEM;\n\n\tmutex_lock(&pmc->lock);\n\n\tif (wil_is_pmc_allocated(pmc)) {\n\t\t \n\t\twil_err(wil, \"ERROR pmc is already allocated\\n\");\n\t\tgoto no_release_err;\n\t}\n\tif ((num_descriptors <= 0) || (descriptor_size <= 0)) {\n\t\twil_err(wil,\n\t\t\t\"Invalid params num_descriptors(%d), descriptor_size(%d)\\n\",\n\t\t\tnum_descriptors, descriptor_size);\n\t\tlast_cmd_err = -EINVAL;\n\t\tgoto no_release_err;\n\t}\n\n\tif (num_descriptors > (1 << WIL_RING_SIZE_ORDER_MAX)) {\n\t\twil_err(wil,\n\t\t\t\"num_descriptors(%d) exceeds max ring size %d\\n\",\n\t\t\tnum_descriptors, 1 << WIL_RING_SIZE_ORDER_MAX);\n\t\tlast_cmd_err = -EINVAL;\n\t\tgoto no_release_err;\n\t}\n\n\tif (num_descriptors > INT_MAX / descriptor_size) {\n\t\twil_err(wil,\n\t\t\t\"Overflow in num_descriptors(%d)*descriptor_size(%d)\\n\",\n\t\t\tnum_descriptors, descriptor_size);\n\t\tlast_cmd_err = -EINVAL;\n\t\tgoto no_release_err;\n\t}\n\n\tpmc->num_descriptors = num_descriptors;\n\tpmc->descriptor_size = descriptor_size;\n\n\twil_dbg_misc(wil, \"pmc_alloc: %d descriptors x %d bytes each\\n\",\n\t\t     num_descriptors, descriptor_size);\n\n\t \n\tpmc->descriptors = kcalloc(num_descriptors,\n\t\t\t\t  sizeof(struct desc_alloc_info),\n\t\t\t\t  GFP_KERNEL);\n\tif (!pmc->descriptors) {\n\t\twil_err(wil, \"ERROR allocating pmc skb list\\n\");\n\t\tgoto no_release_err;\n\t}\n\n\twil_dbg_misc(wil, \"pmc_alloc: allocated descriptors info list %p\\n\",\n\t\t     pmc->descriptors);\n\n\t \n\tif (wil->dma_addr_size > 32)\n\t\tdma_set_mask_and_coherent(dev, DMA_BIT_MASK(32));\n\n\tpmc->pring_va = dma_alloc_coherent(dev,\n\t\t\tsizeof(struct vring_tx_desc) * num_descriptors,\n\t\t\t&pmc->pring_pa,\n\t\t\tGFP_KERNEL);\n\n\tif (wil->dma_addr_size > 32)\n\t\tdma_set_mask_and_coherent(dev,\n\t\t\t\t\t  DMA_BIT_MASK(wil->dma_addr_size));\n\n\twil_dbg_misc(wil,\n\t\t     \"pmc_alloc: allocated pring %p => %pad. %zd x %d = total %zd bytes\\n\",\n\t\t     pmc->pring_va, &pmc->pring_pa,\n\t\t     sizeof(struct vring_tx_desc),\n\t\t     num_descriptors,\n\t\t     sizeof(struct vring_tx_desc) * num_descriptors);\n\n\tif (!pmc->pring_va) {\n\t\twil_err(wil, \"ERROR allocating pmc pring\\n\");\n\t\tgoto release_pmc_skb_list;\n\t}\n\n\t \n\tfor (i = 0; i < num_descriptors; i++) {\n\t\tstruct vring_tx_desc *_d = &pmc->pring_va[i];\n\t\tstruct vring_tx_desc dd = {}, *d = &dd;\n\t\tint j = 0;\n\n\t\tpmc->descriptors[i].va = dma_alloc_coherent(dev,\n\t\t\tdescriptor_size,\n\t\t\t&pmc->descriptors[i].pa,\n\t\t\tGFP_KERNEL);\n\n\t\tif (unlikely(!pmc->descriptors[i].va)) {\n\t\t\twil_err(wil, \"ERROR allocating pmc descriptor %d\", i);\n\t\t\tgoto release_pmc_skbs;\n\t\t}\n\n\t\tfor (j = 0; j < descriptor_size / sizeof(u32); j++) {\n\t\t\tu32 *p = (u32 *)pmc->descriptors[i].va + j;\n\t\t\t*p = PCM_DATA_INVALID_DW_VAL | j;\n\t\t}\n\n\t\t \n\t\td->dma.addr.addr_low =\n\t\t\tcpu_to_le32(lower_32_bits(pmc->descriptors[i].pa));\n\t\td->dma.addr.addr_high =\n\t\t\tcpu_to_le16((u16)upper_32_bits(pmc->descriptors[i].pa));\n\t\td->dma.status = 0;  \n\t\td->dma.length = cpu_to_le16(descriptor_size);\n\t\td->dma.d0 = BIT(9) | RX_DMA_D0_CMD_DMA_IT;\n\t\t*_d = *d;\n\t}\n\n\twil_dbg_misc(wil, \"pmc_alloc: allocated successfully\\n\");\n\n\tpmc_cmd.op = WMI_PMC_ALLOCATE;\n\tpmc_cmd.ring_size = cpu_to_le16(pmc->num_descriptors);\n\tpmc_cmd.mem_base = cpu_to_le64(pmc->pring_pa);\n\n\twil_dbg_misc(wil, \"pmc_alloc: send WMI_PMC_CMD with ALLOCATE op\\n\");\n\tpmc->last_cmd_status = wmi_send(wil,\n\t\t\t\t\tWMI_PMC_CMDID,\n\t\t\t\t\tvif->mid,\n\t\t\t\t\t&pmc_cmd,\n\t\t\t\t\tsizeof(pmc_cmd));\n\tif (pmc->last_cmd_status) {\n\t\twil_err(wil,\n\t\t\t\"WMI_PMC_CMD with ALLOCATE op failed with status %d\",\n\t\t\tpmc->last_cmd_status);\n\t\tgoto release_pmc_skbs;\n\t}\n\n\tmutex_unlock(&pmc->lock);\n\n\treturn;\n\nrelease_pmc_skbs:\n\twil_err(wil, \"exit on error: Releasing skbs...\\n\");\n\tfor (i = 0; i < num_descriptors && pmc->descriptors[i].va; i++) {\n\t\tdma_free_coherent(dev,\n\t\t\t\t  descriptor_size,\n\t\t\t\t  pmc->descriptors[i].va,\n\t\t\t\t  pmc->descriptors[i].pa);\n\n\t\tpmc->descriptors[i].va = NULL;\n\t}\n\twil_err(wil, \"exit on error: Releasing pring...\\n\");\n\n\tdma_free_coherent(dev,\n\t\t\t  sizeof(struct vring_tx_desc) * num_descriptors,\n\t\t\t  pmc->pring_va,\n\t\t\t  pmc->pring_pa);\n\n\tpmc->pring_va = NULL;\n\nrelease_pmc_skb_list:\n\twil_err(wil, \"exit on error: Releasing descriptors info list...\\n\");\n\tkfree(pmc->descriptors);\n\tpmc->descriptors = NULL;\n\nno_release_err:\n\tpmc->last_cmd_status = last_cmd_err;\n\tmutex_unlock(&pmc->lock);\n}\n\n \nvoid wil_pmc_free(struct wil6210_priv *wil, int send_pmc_cmd)\n{\n\tstruct pmc_ctx *pmc = &wil->pmc;\n\tstruct device *dev = wil_to_dev(wil);\n\tstruct wil6210_vif *vif = ndev_to_vif(wil->main_ndev);\n\tstruct wmi_pmc_cmd pmc_cmd = {0};\n\n\tmutex_lock(&pmc->lock);\n\n\tpmc->last_cmd_status = 0;\n\n\tif (!wil_is_pmc_allocated(pmc)) {\n\t\twil_dbg_misc(wil,\n\t\t\t     \"pmc_free: Error, can't free - not allocated\\n\");\n\t\tpmc->last_cmd_status = -EPERM;\n\t\tmutex_unlock(&pmc->lock);\n\t\treturn;\n\t}\n\n\tif (send_pmc_cmd) {\n\t\twil_dbg_misc(wil, \"send WMI_PMC_CMD with RELEASE op\\n\");\n\t\tpmc_cmd.op = WMI_PMC_RELEASE;\n\t\tpmc->last_cmd_status =\n\t\t\t\twmi_send(wil, WMI_PMC_CMDID, vif->mid,\n\t\t\t\t\t &pmc_cmd, sizeof(pmc_cmd));\n\t\tif (pmc->last_cmd_status) {\n\t\t\twil_err(wil,\n\t\t\t\t\"WMI_PMC_CMD with RELEASE op failed, status %d\",\n\t\t\t\tpmc->last_cmd_status);\n\t\t\t \n\t\t}\n\t}\n\n\tif (pmc->pring_va) {\n\t\tsize_t buf_size = sizeof(struct vring_tx_desc) *\n\t\t\t\t  pmc->num_descriptors;\n\n\t\twil_dbg_misc(wil, \"pmc_free: free pring va %p\\n\",\n\t\t\t     pmc->pring_va);\n\t\tdma_free_coherent(dev, buf_size, pmc->pring_va, pmc->pring_pa);\n\n\t\tpmc->pring_va = NULL;\n\t} else {\n\t\tpmc->last_cmd_status = -ENOENT;\n\t}\n\n\tif (pmc->descriptors) {\n\t\tint i;\n\n\t\tfor (i = 0;\n\t\t     i < pmc->num_descriptors && pmc->descriptors[i].va; i++) {\n\t\t\tdma_free_coherent(dev,\n\t\t\t\t\t  pmc->descriptor_size,\n\t\t\t\t\t  pmc->descriptors[i].va,\n\t\t\t\t\t  pmc->descriptors[i].pa);\n\t\t\tpmc->descriptors[i].va = NULL;\n\t\t}\n\t\twil_dbg_misc(wil, \"pmc_free: free descriptor info %d/%d\\n\", i,\n\t\t\t     pmc->num_descriptors);\n\t\twil_dbg_misc(wil,\n\t\t\t     \"pmc_free: free pmc descriptors info list %p\\n\",\n\t\t\t     pmc->descriptors);\n\t\tkfree(pmc->descriptors);\n\t\tpmc->descriptors = NULL;\n\t} else {\n\t\tpmc->last_cmd_status = -ENOENT;\n\t}\n\n\tmutex_unlock(&pmc->lock);\n}\n\n \nint wil_pmc_last_cmd_status(struct wil6210_priv *wil)\n{\n\twil_dbg_misc(wil, \"pmc_last_cmd_status: status %d\\n\",\n\t\t     wil->pmc.last_cmd_status);\n\n\treturn wil->pmc.last_cmd_status;\n}\n\n \nssize_t wil_pmc_read(struct file *filp, char __user *buf, size_t count,\n\t\t     loff_t *f_pos)\n{\n\tstruct wil6210_priv *wil = filp->private_data;\n\tstruct pmc_ctx *pmc = &wil->pmc;\n\tsize_t retval = 0;\n\tunsigned long long idx;\n\tloff_t offset;\n\tsize_t pmc_size;\n\n\tmutex_lock(&pmc->lock);\n\n\tif (!wil_is_pmc_allocated(pmc)) {\n\t\twil_err(wil, \"error, pmc is not allocated!\\n\");\n\t\tpmc->last_cmd_status = -EPERM;\n\t\tmutex_unlock(&pmc->lock);\n\t\treturn -EPERM;\n\t}\n\n\tpmc_size = pmc->descriptor_size * pmc->num_descriptors;\n\n\twil_dbg_misc(wil,\n\t\t     \"pmc_read: size %u, pos %lld\\n\",\n\t\t     (u32)count, *f_pos);\n\n\tpmc->last_cmd_status = 0;\n\n\tidx = *f_pos;\n\tdo_div(idx, pmc->descriptor_size);\n\toffset = *f_pos - (idx * pmc->descriptor_size);\n\n\tif (*f_pos >= pmc_size) {\n\t\twil_dbg_misc(wil,\n\t\t\t     \"pmc_read: reached end of pmc buf: %lld >= %u\\n\",\n\t\t\t     *f_pos, (u32)pmc_size);\n\t\tpmc->last_cmd_status = -ERANGE;\n\t\tgoto out;\n\t}\n\n\twil_dbg_misc(wil,\n\t\t     \"pmc_read: read from pos %lld (descriptor %llu, offset %llu) %zu bytes\\n\",\n\t\t     *f_pos, idx, offset, count);\n\n\t \n\tretval = simple_read_from_buffer(buf,\n\t\t\t\t\t count,\n\t\t\t\t\t &offset,\n\t\t\t\t\t pmc->descriptors[idx].va,\n\t\t\t\t\t pmc->descriptor_size);\n\t*f_pos += retval;\nout:\n\tmutex_unlock(&pmc->lock);\n\n\treturn retval;\n}\n\nloff_t wil_pmc_llseek(struct file *filp, loff_t off, int whence)\n{\n\tloff_t newpos;\n\tstruct wil6210_priv *wil = filp->private_data;\n\tstruct pmc_ctx *pmc = &wil->pmc;\n\tsize_t pmc_size;\n\n\tmutex_lock(&pmc->lock);\n\n\tif (!wil_is_pmc_allocated(pmc)) {\n\t\twil_err(wil, \"error, pmc is not allocated!\\n\");\n\t\tpmc->last_cmd_status = -EPERM;\n\t\tmutex_unlock(&pmc->lock);\n\t\treturn -EPERM;\n\t}\n\n\tpmc_size = pmc->descriptor_size * pmc->num_descriptors;\n\n\tswitch (whence) {\n\tcase 0:  \n\t\tnewpos = off;\n\t\tbreak;\n\n\tcase 1:  \n\t\tnewpos = filp->f_pos + off;\n\t\tbreak;\n\n\tcase 2:  \n\t\tnewpos = pmc_size;\n\t\tbreak;\n\n\tdefault:  \n\t\tnewpos = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (newpos < 0) {\n\t\tnewpos = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (newpos > pmc_size)\n\t\tnewpos = pmc_size;\n\n\tfilp->f_pos = newpos;\n\nout:\n\tmutex_unlock(&pmc->lock);\n\n\treturn newpos;\n}\n\nint wil_pmcring_read(struct seq_file *s, void *data)\n{\n\tstruct wil6210_priv *wil = s->private;\n\tstruct pmc_ctx *pmc = &wil->pmc;\n\tsize_t pmc_ring_size =\n\t\tsizeof(struct vring_rx_desc) * pmc->num_descriptors;\n\n\tmutex_lock(&pmc->lock);\n\n\tif (!wil_is_pmc_allocated(pmc)) {\n\t\twil_err(wil, \"error, pmc is not allocated!\\n\");\n\t\tpmc->last_cmd_status = -EPERM;\n\t\tmutex_unlock(&pmc->lock);\n\t\treturn -EPERM;\n\t}\n\n\twil_dbg_misc(wil, \"pmcring_read: size %zu\\n\", pmc_ring_size);\n\n\tseq_write(s, pmc->pring_va, pmc_ring_size);\n\n\tmutex_unlock(&pmc->lock);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}