{
  "module_name": "rx_reorder.c",
  "hash_id": "f748dae07879fde1331cf537e8e3e0da7083c541a50761f3c1c0cd20fbd492a6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/wil6210/rx_reorder.c",
  "human_readable_source": "\n \n\n#include \"wil6210.h\"\n#include \"txrx.h\"\n\n#define SEQ_MODULO 0x1000\n#define SEQ_MASK   0xfff\n\nstatic inline int seq_less(u16 sq1, u16 sq2)\n{\n\treturn ((sq1 - sq2) & SEQ_MASK) > (SEQ_MODULO >> 1);\n}\n\nstatic inline u16 seq_inc(u16 sq)\n{\n\treturn (sq + 1) & SEQ_MASK;\n}\n\nstatic inline u16 seq_sub(u16 sq1, u16 sq2)\n{\n\treturn (sq1 - sq2) & SEQ_MASK;\n}\n\nstatic inline int reorder_index(struct wil_tid_ampdu_rx *r, u16 seq)\n{\n\treturn seq_sub(seq, r->ssn) % r->buf_size;\n}\n\nstatic void wil_release_reorder_frame(struct net_device *ndev,\n\t\t\t\t      struct wil_tid_ampdu_rx *r,\n\t\t\t\t      int index)\n{\n\tstruct sk_buff *skb = r->reorder_buf[index];\n\n\tif (!skb)\n\t\tgoto no_frame;\n\n\t \n\tr->stored_mpdu_num--;\n\tr->reorder_buf[index] = NULL;\n\twil_netif_rx_any(skb, ndev);\n\nno_frame:\n\tr->head_seq_num = seq_inc(r->head_seq_num);\n}\n\nstatic void wil_release_reorder_frames(struct net_device *ndev,\n\t\t\t\t       struct wil_tid_ampdu_rx *r,\n\t\t\t\t       u16 hseq)\n{\n\tint index;\n\n\t \n\twhile (seq_less(r->head_seq_num, hseq) && r->stored_mpdu_num) {\n\t\tindex = reorder_index(r, r->head_seq_num);\n\t\twil_release_reorder_frame(ndev, r, index);\n\t}\n\tr->head_seq_num = hseq;\n}\n\nstatic void wil_reorder_release(struct net_device *ndev,\n\t\t\t\tstruct wil_tid_ampdu_rx *r)\n{\n\tint index = reorder_index(r, r->head_seq_num);\n\n\twhile (r->reorder_buf[index]) {\n\t\twil_release_reorder_frame(ndev, r, index);\n\t\tindex = reorder_index(r, r->head_seq_num);\n\t}\n}\n\n \nvoid wil_rx_reorder(struct wil6210_priv *wil, struct sk_buff *skb)\n__acquires(&sta->tid_rx_lock) __releases(&sta->tid_rx_lock)\n{\n\tstruct wil6210_vif *vif;\n\tstruct net_device *ndev;\n\tint tid, cid, mid, mcast, retry;\n\tu16 seq;\n\tstruct wil_sta_info *sta;\n\tstruct wil_tid_ampdu_rx *r;\n\tu16 hseq;\n\tint index;\n\n\twil->txrx_ops.get_reorder_params(wil, skb, &tid, &cid, &mid, &seq,\n\t\t\t\t\t &mcast, &retry);\n\tsta = &wil->sta[cid];\n\n\twil_dbg_txrx(wil, \"MID %d CID %d TID %d Seq 0x%03x mcast %01x\\n\",\n\t\t     mid, cid, tid, seq, mcast);\n\n\tvif = wil->vifs[mid];\n\tif (unlikely(!vif)) {\n\t\twil_dbg_txrx(wil, \"invalid VIF, mid %d\\n\", mid);\n\t\tdev_kfree_skb(skb);\n\t\treturn;\n\t}\n\tndev = vif_to_ndev(vif);\n\n\tspin_lock(&sta->tid_rx_lock);\n\n\tr = sta->tid_rx[tid];\n\tif (!r) {\n\t\twil_netif_rx_any(skb, ndev);\n\t\tgoto out;\n\t}\n\n\tif (unlikely(mcast)) {\n\t\tif (retry && seq == r->mcast_last_seq) {\n\t\t\tr->drop_dup_mcast++;\n\t\t\twil_dbg_txrx(wil, \"Rx drop: dup mcast seq 0x%03x\\n\",\n\t\t\t\t     seq);\n\t\t\tdev_kfree_skb(skb);\n\t\t\tgoto out;\n\t\t}\n\t\tr->mcast_last_seq = seq;\n\t\twil_netif_rx_any(skb, ndev);\n\t\tgoto out;\n\t}\n\n\tr->total++;\n\thseq = r->head_seq_num;\n\n\t \n\tif (r->first_time) {\n\t\tr->first_time = false;\n\t\tif (seq != r->head_seq_num) {\n\t\t\tif (seq_less(seq, r->head_seq_num)) {\n\t\t\t\twil_err(wil,\n\t\t\t\t\t\"Error: frame with early sequence 0x%03x, should be 0x%03x. Waiting...\\n\",\n\t\t\t\t\tseq, r->head_seq_num);\n\t\t\t\tr->first_time = true;\n\t\t\t\twil_netif_rx_any(skb, ndev);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\twil_err(wil,\n\t\t\t\t\"Error: 1-st frame with wrong sequence 0x%03x, should be 0x%03x. Fixing...\\n\",\n\t\t\t\tseq, r->head_seq_num);\n\t\t\tr->head_seq_num = seq;\n\t\t\tr->ssn = seq;\n\t\t}\n\t}\n\n\t \n\tif (seq_less(seq, r->head_seq_num)) {\n\t\tr->ssn_last_drop = seq;\n\t\tr->drop_old++;\n\t\twil_dbg_txrx(wil, \"Rx drop: old seq 0x%03x head 0x%03x\\n\",\n\t\t\t     seq, r->head_seq_num);\n\t\tdev_kfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\t \n\tif (!seq_less(seq, r->head_seq_num + r->buf_size)) {\n\t\thseq = seq_inc(seq_sub(seq, r->buf_size));\n\t\t \n\t\twil_release_reorder_frames(ndev, r, hseq);\n\t}\n\n\t \n\n\tindex = reorder_index(r, seq);\n\n\t \n\tif (r->reorder_buf[index]) {\n\t\tr->drop_dup++;\n\t\twil_dbg_txrx(wil, \"Rx drop: dup seq 0x%03x\\n\", seq);\n\t\tdev_kfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\t \n\tif (seq == r->head_seq_num && r->stored_mpdu_num == 0) {\n\t\tr->head_seq_num = seq_inc(r->head_seq_num);\n\t\twil_netif_rx_any(skb, ndev);\n\t\tgoto out;\n\t}\n\n\t \n\tr->reorder_buf[index] = skb;\n\tr->stored_mpdu_num++;\n\twil_reorder_release(ndev, r);\n\nout:\n\tspin_unlock(&sta->tid_rx_lock);\n}\n\n \nvoid wil_rx_bar(struct wil6210_priv *wil, struct wil6210_vif *vif,\n\t\tu8 cid, u8 tid, u16 seq)\n{\n\tstruct wil_sta_info *sta = &wil->sta[cid];\n\tstruct net_device *ndev = vif_to_ndev(vif);\n\tstruct wil_tid_ampdu_rx *r;\n\n\tspin_lock(&sta->tid_rx_lock);\n\n\tr = sta->tid_rx[tid];\n\tif (!r) {\n\t\twil_err(wil, \"BAR for non-existing CID %d TID %d\\n\", cid, tid);\n\t\tgoto out;\n\t}\n\tif (seq_less(seq, r->head_seq_num)) {\n\t\twil_err(wil, \"BAR Seq 0x%03x preceding head 0x%03x\\n\",\n\t\t\tseq, r->head_seq_num);\n\t\tgoto out;\n\t}\n\twil_dbg_txrx(wil, \"BAR: CID %d MID %d TID %d Seq 0x%03x head 0x%03x\\n\",\n\t\t     cid, vif->mid, tid, seq, r->head_seq_num);\n\twil_release_reorder_frames(ndev, r, seq);\n\nout:\n\tspin_unlock(&sta->tid_rx_lock);\n}\n\nstruct wil_tid_ampdu_rx *wil_tid_ampdu_rx_alloc(struct wil6210_priv *wil,\n\t\t\t\t\t\tint size, u16 ssn)\n{\n\tstruct wil_tid_ampdu_rx *r = kzalloc(sizeof(*r), GFP_KERNEL);\n\n\tif (!r)\n\t\treturn NULL;\n\n\tr->reorder_buf =\n\t\tkcalloc(size, sizeof(struct sk_buff *), GFP_KERNEL);\n\tif (!r->reorder_buf) {\n\t\tkfree(r);\n\t\treturn NULL;\n\t}\n\n\tr->ssn = ssn;\n\tr->head_seq_num = ssn;\n\tr->buf_size = size;\n\tr->stored_mpdu_num = 0;\n\tr->first_time = true;\n\tr->mcast_last_seq = U16_MAX;\n\treturn r;\n}\n\nvoid wil_tid_ampdu_rx_free(struct wil6210_priv *wil,\n\t\t\t   struct wil_tid_ampdu_rx *r)\n{\n\tint i;\n\n\tif (!r)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < r->buf_size; i++)\n\t\tkfree_skb(r->reorder_buf[i]);\n\n\tkfree(r->reorder_buf);\n\tkfree(r);\n}\n\n \nstatic u16 wil_agg_size(struct wil6210_priv *wil, u16 req_agg_wsize)\n{\n\tu16 max_agg_size = min_t(u16, wil->max_agg_wsize, wil->max_ampdu_size /\n\t\t\t\t (mtu_max + WIL_MAX_MPDU_OVERHEAD));\n\n\tif (!req_agg_wsize)\n\t\treturn max_agg_size;\n\n\treturn min(max_agg_size, req_agg_wsize);\n}\n\n \nint wil_addba_rx_request(struct wil6210_priv *wil, u8 mid, u8 cid, u8 tid,\n\t\t\t u8 dialog_token, __le16 ba_param_set,\n\t\t\t __le16 ba_timeout, __le16 ba_seq_ctrl)\n__acquires(&sta->tid_rx_lock) __releases(&sta->tid_rx_lock)\n{\n\tu16 param_set = le16_to_cpu(ba_param_set);\n\tu16 agg_timeout = le16_to_cpu(ba_timeout);\n\tu16 seq_ctrl = le16_to_cpu(ba_seq_ctrl);\n\tstruct wil_sta_info *sta;\n\tu16 agg_wsize;\n\t \n\tu16 req_agg_wsize = WIL_GET_BITS(param_set, 6, 15);\n\tbool agg_amsdu = wil->use_enhanced_dma_hw &&\n\t\twil->use_rx_hw_reordering &&\n\t\ttest_bit(WMI_FW_CAPABILITY_AMSDU, wil->fw_capabilities) &&\n\t\twil->amsdu_en && (param_set & BIT(0));\n\tint ba_policy = param_set & BIT(1);\n\tu16 ssn = seq_ctrl >> 4;\n\tstruct wil_tid_ampdu_rx *r;\n\tint rc = 0;\n\n\tmight_sleep();\n\n\t \n\tif (cid >= wil->max_assoc_sta) {\n\t\twil_err(wil, \"BACK: invalid CID %d\\n\", cid);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tsta = &wil->sta[cid];\n\tif (sta->status != wil_sta_connected) {\n\t\twil_err(wil, \"BACK: CID %d not connected\\n\", cid);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\twil_dbg_wmi(wil,\n\t\t    \"ADDBA request for CID %d %pM TID %d size %d timeout %d AMSDU%s policy %d token %d SSN 0x%03x\\n\",\n\t\t    cid, sta->addr, tid, req_agg_wsize, agg_timeout,\n\t\t    agg_amsdu ? \"+\" : \"-\", !!ba_policy, dialog_token, ssn);\n\n\t \n\tif (req_agg_wsize == 0) {\n\t\twil_dbg_misc(wil, \"Suggest BACK wsize %d\\n\",\n\t\t\t     wil->max_agg_wsize);\n\t\tagg_wsize = wil->max_agg_wsize;\n\t} else {\n\t\tagg_wsize = min_t(u16, wil->max_agg_wsize, req_agg_wsize);\n\t}\n\n\trc = wil->txrx_ops.wmi_addba_rx_resp(wil, mid, cid, tid, dialog_token,\n\t\t\t\t\t     WLAN_STATUS_SUCCESS, agg_amsdu,\n\t\t\t\t\t     agg_wsize, agg_timeout);\n\tif (rc) {\n\t\twil_err(wil, \"do not apply ba, rc(%d)\\n\", rc);\n\t\tgoto out;\n\t}\n\n\t \n\tif (!wil->use_rx_hw_reordering) {\n\t\tr = wil_tid_ampdu_rx_alloc(wil, agg_wsize, ssn);\n\t\tspin_lock_bh(&sta->tid_rx_lock);\n\t\twil_tid_ampdu_rx_free(wil, sta->tid_rx[tid]);\n\t\tsta->tid_rx[tid] = r;\n\t\tspin_unlock_bh(&sta->tid_rx_lock);\n\t}\n\nout:\n\treturn rc;\n}\n\n \nint wil_addba_tx_request(struct wil6210_priv *wil, u8 ringid, u16 wsize)\n{\n\tu8 agg_wsize = wil_agg_size(wil, wsize);\n\tu16 agg_timeout = 0;\n\tstruct wil_ring_tx_data *txdata = &wil->ring_tx_data[ringid];\n\tint rc = 0;\n\n\tif (txdata->addba_in_progress) {\n\t\twil_dbg_misc(wil, \"ADDBA for vring[%d] already in progress\\n\",\n\t\t\t     ringid);\n\t\tgoto out;\n\t}\n\tif (txdata->agg_wsize) {\n\t\twil_dbg_misc(wil,\n\t\t\t     \"ADDBA for vring[%d] already done for wsize %d\\n\",\n\t\t\t     ringid, txdata->agg_wsize);\n\t\tgoto out;\n\t}\n\ttxdata->addba_in_progress = true;\n\trc = wmi_addba(wil, txdata->mid, ringid, agg_wsize, agg_timeout);\n\tif (rc) {\n\t\twil_err(wil, \"wmi_addba failed, rc (%d)\", rc);\n\t\ttxdata->addba_in_progress = false;\n\t}\n\nout:\n\treturn rc;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}