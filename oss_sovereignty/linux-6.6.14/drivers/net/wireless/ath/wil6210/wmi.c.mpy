{
  "module_name": "wmi.c",
  "hash_id": "f5bff29e05ac5cd6b848b877078660db1717ed561b37faf1483f69a95f2b9291",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/wil6210/wmi.c",
  "human_readable_source": "\n \n\n#include <linux/moduleparam.h>\n#include <linux/etherdevice.h>\n#include <linux/if_arp.h>\n\n#include \"wil6210.h\"\n#include \"txrx.h\"\n#include \"wmi.h\"\n#include \"trace.h\"\n\n \nuint max_assoc_sta = WIL6210_MAX_CID;\nmodule_param(max_assoc_sta, uint, 0444);\nMODULE_PARM_DESC(max_assoc_sta, \" Max number of stations associated to the AP\");\n\nint agg_wsize;  \nmodule_param(agg_wsize, int, 0644);\nMODULE_PARM_DESC(agg_wsize, \" Window size for Tx Block Ack after connect;\"\n\t\t \" 0 - use default; < 0 - don't auto-establish\");\n\nu8 led_id = WIL_LED_INVALID_ID;\nmodule_param(led_id, byte, 0444);\nMODULE_PARM_DESC(led_id,\n\t\t \" 60G device led enablement. Set the led ID (0-2) to enable\");\n\n#define WIL_WAIT_FOR_SUSPEND_RESUME_COMP 200\n#define WIL_WMI_PCP_STOP_TO_MS 5000\n\n \n\n \n\n \nconst struct fw_map sparrow_fw_mapping[] = {\n\t \n\t{0x000000, 0x040000, 0x8c0000, \"fw_code\", true, true},\n\t \n\t{0x800000, 0x808000, 0x900000, \"fw_data\", true, true},\n\t \n\t{0x840000, 0x860000, 0x908000, \"fw_peri\", true, true},\n\t \n\t{0x880000, 0x88a000, 0x880000, \"rgf\", true, true},\n\t \n\t{0x88a000, 0x88b000, 0x88a000, \"AGC_tbl\", true, true},\n\t \n\t{0x88b000, 0x88c000, 0x88b000, \"rgf_ext\", true, true},\n\t \n\t{0x88c000, 0x88c200, 0x88c000, \"mac_rgf_ext\", true, true},\n\t \n\t{0x8c0000, 0x949000, 0x8c0000, \"upper\", true, true},\n\t \n\t \n\t{0x000000, 0x020000, 0x920000, \"uc_code\", false, false},\n\t \n\t{0x800000, 0x804000, 0x940000, \"uc_data\", false, false},\n};\n\n \nconst struct fw_map sparrow_d0_mac_rgf_ext = {\n\t0x88c000, 0x88c500, 0x88c000, \"mac_rgf_ext\", true, true\n};\n\n \nconst struct fw_map talyn_fw_mapping[] = {\n\t \n\t{0x000000, 0x100000, 0x900000, \"fw_code\", true, true},\n\t \n\t{0x800000, 0x820000, 0xa00000, \"fw_data\", true, true},\n\t \n\t{0x840000, 0x858000, 0xa20000, \"fw_peri\", true, true},\n\t \n\t{0x880000, 0x88a000, 0x880000, \"rgf\", true, true},\n\t \n\t{0x88a000, 0x88b000, 0x88a000, \"AGC_tbl\", true, true},\n\t \n\t{0x88b000, 0x88c000, 0x88b000, \"rgf_ext\", true, true},\n\t \n\t{0x88c000, 0x88c540, 0x88c000, \"mac_rgf_ext\", true, true},\n\t \n\t{0x88d000, 0x88e000, 0x88d000, \"ext_user_rgf\", true, true},\n\t \n\t{0x8a0000, 0x8a1000, 0x8a0000, \"otp\", true, false},\n\t \n\t{0x8b0000, 0x8c0000, 0x8b0000, \"dma_ext_rgf\", true, true},\n\t \n\t{0x900000, 0xa80000, 0x900000, \"upper\", true, true},\n\t \n\t \n\t{0x000000, 0x040000, 0xa38000, \"uc_code\", false, false},\n\t \n\t{0x800000, 0x808000, 0xa78000, \"uc_data\", false, false},\n};\n\n \nconst struct fw_map talyn_mb_fw_mapping[] = {\n\t \n\t{0x000000, 0x0c0000, 0x900000, \"fw_code\", true, true},\n\t \n\t{0x800000, 0x820000, 0xa00000, \"fw_data\", true, true},\n\t \n\t{0x840000, 0x858000, 0xa20000, \"fw_peri\", true, true},\n\t \n\t{0x880000, 0x88a000, 0x880000, \"rgf\", true, true},\n\t \n\t{0x88a000, 0x88b000, 0x88a000, \"AGC_tbl\", true, true},\n\t \n\t{0x88b000, 0x88c000, 0x88b000, \"rgf_ext\", true, true},\n\t \n\t{0x88c000, 0x88c8d0, 0x88c000, \"mac_rgf_ext\", true, true},\n\t \n\t{0x88d000, 0x88e000, 0x88d000, \"ext_user_rgf\", true, true},\n\t \n\t{0x890000, 0x894000, 0x890000, \"sec_pka\", true, true},\n\t \n\t{0x898000, 0x898c18, 0x898000, \"sec_kdf_rgf\", true, true},\n\t \n\t{0x89a000, 0x89a84c, 0x89a000, \"sec_main\", true, true},\n\t \n\t{0x8a0000, 0x8a1000, 0x8a0000, \"otp\", true, false},\n\t \n\t{0x8b0000, 0x8c0000, 0x8b0000, \"dma_ext_rgf\", true, true},\n\t \n\t{0x8c0000, 0x8c0210, 0x8c0000, \"dum_user_rgf\", true, true},\n\t \n\t{0x8c2000, 0x8c2128, 0x8c2000, \"dma_ofu\", true, true},\n\t \n\t{0x8c3000, 0x8c3100, 0x8c3000, \"ucode_debug\", true, true},\n\t \n\t{0x900000, 0xa80000, 0x900000, \"upper\", true, true},\n\t \n\t \n\t{0x000000, 0x040000, 0xa38000, \"uc_code\", false, false},\n\t \n\t{0x800000, 0x808000, 0xa78000, \"uc_data\", false, false},\n};\n\nstruct fw_map fw_mapping[MAX_FW_MAPPING_TABLE_SIZE];\n\nstruct blink_on_off_time led_blink_time[] = {\n\t{WIL_LED_BLINK_ON_SLOW_MS, WIL_LED_BLINK_OFF_SLOW_MS},\n\t{WIL_LED_BLINK_ON_MED_MS, WIL_LED_BLINK_OFF_MED_MS},\n\t{WIL_LED_BLINK_ON_FAST_MS, WIL_LED_BLINK_OFF_FAST_MS},\n};\n\nstruct auth_no_hdr {\n\t__le16 auth_alg;\n\t__le16 auth_transaction;\n\t__le16 status_code;\n\t \n\tu8 variable[];\n} __packed;\n\nu8 led_polarity = LED_POLARITY_LOW_ACTIVE;\n\n \nstatic u32 wmi_addr_remap(u32 x)\n{\n\tuint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(fw_mapping); i++) {\n\t\tif (fw_mapping[i].fw &&\n\t\t    ((x >= fw_mapping[i].from) && (x < fw_mapping[i].to)))\n\t\t\treturn x + fw_mapping[i].host - fw_mapping[i].from;\n\t}\n\n\treturn 0;\n}\n\n \nstruct fw_map *wil_find_fw_mapping(const char *section)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(fw_mapping); i++)\n\t\tif (fw_mapping[i].name &&\n\t\t    !strcmp(section, fw_mapping[i].name))\n\t\t\treturn &fw_mapping[i];\n\n\treturn NULL;\n}\n\n \nvoid __iomem *wmi_buffer_block(struct wil6210_priv *wil, __le32 ptr_, u32 size)\n{\n\tu32 off;\n\tu32 ptr = le32_to_cpu(ptr_);\n\n\tif (ptr % 4)\n\t\treturn NULL;\n\n\tptr = wmi_addr_remap(ptr);\n\tif (ptr < WIL6210_FW_HOST_OFF)\n\t\treturn NULL;\n\n\toff = HOSTADDR(ptr);\n\tif (off > wil->bar_size - 4)\n\t\treturn NULL;\n\tif (size && ((off + size > wil->bar_size) || (off + size < off)))\n\t\treturn NULL;\n\n\treturn wil->csr + off;\n}\n\nvoid __iomem *wmi_buffer(struct wil6210_priv *wil, __le32 ptr_)\n{\n\treturn wmi_buffer_block(wil, ptr_, 0);\n}\n\n \nvoid __iomem *wmi_addr(struct wil6210_priv *wil, u32 ptr)\n{\n\tu32 off;\n\n\tif (ptr % 4)\n\t\treturn NULL;\n\n\tif (ptr < WIL6210_FW_HOST_OFF)\n\t\treturn NULL;\n\n\toff = HOSTADDR(ptr);\n\tif (off > wil->bar_size - 4)\n\t\treturn NULL;\n\n\treturn wil->csr + off;\n}\n\nint wmi_read_hdr(struct wil6210_priv *wil, __le32 ptr,\n\t\t struct wil6210_mbox_hdr *hdr)\n{\n\tvoid __iomem *src = wmi_buffer(wil, ptr);\n\n\tif (!src)\n\t\treturn -EINVAL;\n\n\twil_memcpy_fromio_32(hdr, src, sizeof(*hdr));\n\n\treturn 0;\n}\n\nstatic const char *cmdid2name(u16 cmdid)\n{\n\tswitch (cmdid) {\n\tcase WMI_NOTIFY_REQ_CMDID:\n\t\treturn \"WMI_NOTIFY_REQ_CMD\";\n\tcase WMI_START_SCAN_CMDID:\n\t\treturn \"WMI_START_SCAN_CMD\";\n\tcase WMI_CONNECT_CMDID:\n\t\treturn \"WMI_CONNECT_CMD\";\n\tcase WMI_DISCONNECT_CMDID:\n\t\treturn \"WMI_DISCONNECT_CMD\";\n\tcase WMI_SW_TX_REQ_CMDID:\n\t\treturn \"WMI_SW_TX_REQ_CMD\";\n\tcase WMI_GET_RF_SECTOR_PARAMS_CMDID:\n\t\treturn \"WMI_GET_RF_SECTOR_PARAMS_CMD\";\n\tcase WMI_SET_RF_SECTOR_PARAMS_CMDID:\n\t\treturn \"WMI_SET_RF_SECTOR_PARAMS_CMD\";\n\tcase WMI_GET_SELECTED_RF_SECTOR_INDEX_CMDID:\n\t\treturn \"WMI_GET_SELECTED_RF_SECTOR_INDEX_CMD\";\n\tcase WMI_SET_SELECTED_RF_SECTOR_INDEX_CMDID:\n\t\treturn \"WMI_SET_SELECTED_RF_SECTOR_INDEX_CMD\";\n\tcase WMI_BRP_SET_ANT_LIMIT_CMDID:\n\t\treturn \"WMI_BRP_SET_ANT_LIMIT_CMD\";\n\tcase WMI_TOF_SESSION_START_CMDID:\n\t\treturn \"WMI_TOF_SESSION_START_CMD\";\n\tcase WMI_AOA_MEAS_CMDID:\n\t\treturn \"WMI_AOA_MEAS_CMD\";\n\tcase WMI_PMC_CMDID:\n\t\treturn \"WMI_PMC_CMD\";\n\tcase WMI_TOF_GET_TX_RX_OFFSET_CMDID:\n\t\treturn \"WMI_TOF_GET_TX_RX_OFFSET_CMD\";\n\tcase WMI_TOF_SET_TX_RX_OFFSET_CMDID:\n\t\treturn \"WMI_TOF_SET_TX_RX_OFFSET_CMD\";\n\tcase WMI_VRING_CFG_CMDID:\n\t\treturn \"WMI_VRING_CFG_CMD\";\n\tcase WMI_BCAST_VRING_CFG_CMDID:\n\t\treturn \"WMI_BCAST_VRING_CFG_CMD\";\n\tcase WMI_TRAFFIC_SUSPEND_CMDID:\n\t\treturn \"WMI_TRAFFIC_SUSPEND_CMD\";\n\tcase WMI_TRAFFIC_RESUME_CMDID:\n\t\treturn \"WMI_TRAFFIC_RESUME_CMD\";\n\tcase WMI_ECHO_CMDID:\n\t\treturn \"WMI_ECHO_CMD\";\n\tcase WMI_SET_MAC_ADDRESS_CMDID:\n\t\treturn \"WMI_SET_MAC_ADDRESS_CMD\";\n\tcase WMI_LED_CFG_CMDID:\n\t\treturn \"WMI_LED_CFG_CMD\";\n\tcase WMI_PCP_START_CMDID:\n\t\treturn \"WMI_PCP_START_CMD\";\n\tcase WMI_PCP_STOP_CMDID:\n\t\treturn \"WMI_PCP_STOP_CMD\";\n\tcase WMI_SET_SSID_CMDID:\n\t\treturn \"WMI_SET_SSID_CMD\";\n\tcase WMI_GET_SSID_CMDID:\n\t\treturn \"WMI_GET_SSID_CMD\";\n\tcase WMI_SET_PCP_CHANNEL_CMDID:\n\t\treturn \"WMI_SET_PCP_CHANNEL_CMD\";\n\tcase WMI_GET_PCP_CHANNEL_CMDID:\n\t\treturn \"WMI_GET_PCP_CHANNEL_CMD\";\n\tcase WMI_P2P_CFG_CMDID:\n\t\treturn \"WMI_P2P_CFG_CMD\";\n\tcase WMI_PORT_ALLOCATE_CMDID:\n\t\treturn \"WMI_PORT_ALLOCATE_CMD\";\n\tcase WMI_PORT_DELETE_CMDID:\n\t\treturn \"WMI_PORT_DELETE_CMD\";\n\tcase WMI_START_LISTEN_CMDID:\n\t\treturn \"WMI_START_LISTEN_CMD\";\n\tcase WMI_START_SEARCH_CMDID:\n\t\treturn \"WMI_START_SEARCH_CMD\";\n\tcase WMI_DISCOVERY_STOP_CMDID:\n\t\treturn \"WMI_DISCOVERY_STOP_CMD\";\n\tcase WMI_DELETE_CIPHER_KEY_CMDID:\n\t\treturn \"WMI_DELETE_CIPHER_KEY_CMD\";\n\tcase WMI_ADD_CIPHER_KEY_CMDID:\n\t\treturn \"WMI_ADD_CIPHER_KEY_CMD\";\n\tcase WMI_SET_APPIE_CMDID:\n\t\treturn \"WMI_SET_APPIE_CMD\";\n\tcase WMI_CFG_RX_CHAIN_CMDID:\n\t\treturn \"WMI_CFG_RX_CHAIN_CMD\";\n\tcase WMI_TEMP_SENSE_CMDID:\n\t\treturn \"WMI_TEMP_SENSE_CMD\";\n\tcase WMI_DEL_STA_CMDID:\n\t\treturn \"WMI_DEL_STA_CMD\";\n\tcase WMI_DISCONNECT_STA_CMDID:\n\t\treturn \"WMI_DISCONNECT_STA_CMD\";\n\tcase WMI_RING_BA_EN_CMDID:\n\t\treturn \"WMI_RING_BA_EN_CMD\";\n\tcase WMI_RING_BA_DIS_CMDID:\n\t\treturn \"WMI_RING_BA_DIS_CMD\";\n\tcase WMI_RCP_DELBA_CMDID:\n\t\treturn \"WMI_RCP_DELBA_CMD\";\n\tcase WMI_RCP_ADDBA_RESP_CMDID:\n\t\treturn \"WMI_RCP_ADDBA_RESP_CMD\";\n\tcase WMI_RCP_ADDBA_RESP_EDMA_CMDID:\n\t\treturn \"WMI_RCP_ADDBA_RESP_EDMA_CMD\";\n\tcase WMI_PS_DEV_PROFILE_CFG_CMDID:\n\t\treturn \"WMI_PS_DEV_PROFILE_CFG_CMD\";\n\tcase WMI_SET_MGMT_RETRY_LIMIT_CMDID:\n\t\treturn \"WMI_SET_MGMT_RETRY_LIMIT_CMD\";\n\tcase WMI_GET_MGMT_RETRY_LIMIT_CMDID:\n\t\treturn \"WMI_GET_MGMT_RETRY_LIMIT_CMD\";\n\tcase WMI_ABORT_SCAN_CMDID:\n\t\treturn \"WMI_ABORT_SCAN_CMD\";\n\tcase WMI_NEW_STA_CMDID:\n\t\treturn \"WMI_NEW_STA_CMD\";\n\tcase WMI_SET_THERMAL_THROTTLING_CFG_CMDID:\n\t\treturn \"WMI_SET_THERMAL_THROTTLING_CFG_CMD\";\n\tcase WMI_GET_THERMAL_THROTTLING_CFG_CMDID:\n\t\treturn \"WMI_GET_THERMAL_THROTTLING_CFG_CMD\";\n\tcase WMI_LINK_MAINTAIN_CFG_WRITE_CMDID:\n\t\treturn \"WMI_LINK_MAINTAIN_CFG_WRITE_CMD\";\n\tcase WMI_LO_POWER_CALIB_FROM_OTP_CMDID:\n\t\treturn \"WMI_LO_POWER_CALIB_FROM_OTP_CMD\";\n\tcase WMI_START_SCHED_SCAN_CMDID:\n\t\treturn \"WMI_START_SCHED_SCAN_CMD\";\n\tcase WMI_STOP_SCHED_SCAN_CMDID:\n\t\treturn \"WMI_STOP_SCHED_SCAN_CMD\";\n\tcase WMI_TX_STATUS_RING_ADD_CMDID:\n\t\treturn \"WMI_TX_STATUS_RING_ADD_CMD\";\n\tcase WMI_RX_STATUS_RING_ADD_CMDID:\n\t\treturn \"WMI_RX_STATUS_RING_ADD_CMD\";\n\tcase WMI_TX_DESC_RING_ADD_CMDID:\n\t\treturn \"WMI_TX_DESC_RING_ADD_CMD\";\n\tcase WMI_RX_DESC_RING_ADD_CMDID:\n\t\treturn \"WMI_RX_DESC_RING_ADD_CMD\";\n\tcase WMI_BCAST_DESC_RING_ADD_CMDID:\n\t\treturn \"WMI_BCAST_DESC_RING_ADD_CMD\";\n\tcase WMI_CFG_DEF_RX_OFFLOAD_CMDID:\n\t\treturn \"WMI_CFG_DEF_RX_OFFLOAD_CMD\";\n\tcase WMI_LINK_STATS_CMDID:\n\t\treturn \"WMI_LINK_STATS_CMD\";\n\tcase WMI_SW_TX_REQ_EXT_CMDID:\n\t\treturn \"WMI_SW_TX_REQ_EXT_CMDID\";\n\tcase WMI_FT_AUTH_CMDID:\n\t\treturn \"WMI_FT_AUTH_CMD\";\n\tcase WMI_FT_REASSOC_CMDID:\n\t\treturn \"WMI_FT_REASSOC_CMD\";\n\tcase WMI_UPDATE_FT_IES_CMDID:\n\t\treturn \"WMI_UPDATE_FT_IES_CMD\";\n\tcase WMI_RBUFCAP_CFG_CMDID:\n\t\treturn \"WMI_RBUFCAP_CFG_CMD\";\n\tcase WMI_TEMP_SENSE_ALL_CMDID:\n\t\treturn \"WMI_TEMP_SENSE_ALL_CMDID\";\n\tcase WMI_SET_LINK_MONITOR_CMDID:\n\t\treturn \"WMI_SET_LINK_MONITOR_CMD\";\n\tdefault:\n\t\treturn \"Untracked CMD\";\n\t}\n}\n\nstatic const char *eventid2name(u16 eventid)\n{\n\tswitch (eventid) {\n\tcase WMI_NOTIFY_REQ_DONE_EVENTID:\n\t\treturn \"WMI_NOTIFY_REQ_DONE_EVENT\";\n\tcase WMI_DISCONNECT_EVENTID:\n\t\treturn \"WMI_DISCONNECT_EVENT\";\n\tcase WMI_SW_TX_COMPLETE_EVENTID:\n\t\treturn \"WMI_SW_TX_COMPLETE_EVENT\";\n\tcase WMI_GET_RF_SECTOR_PARAMS_DONE_EVENTID:\n\t\treturn \"WMI_GET_RF_SECTOR_PARAMS_DONE_EVENT\";\n\tcase WMI_SET_RF_SECTOR_PARAMS_DONE_EVENTID:\n\t\treturn \"WMI_SET_RF_SECTOR_PARAMS_DONE_EVENT\";\n\tcase WMI_GET_SELECTED_RF_SECTOR_INDEX_DONE_EVENTID:\n\t\treturn \"WMI_GET_SELECTED_RF_SECTOR_INDEX_DONE_EVENT\";\n\tcase WMI_SET_SELECTED_RF_SECTOR_INDEX_DONE_EVENTID:\n\t\treturn \"WMI_SET_SELECTED_RF_SECTOR_INDEX_DONE_EVENT\";\n\tcase WMI_BRP_SET_ANT_LIMIT_EVENTID:\n\t\treturn \"WMI_BRP_SET_ANT_LIMIT_EVENT\";\n\tcase WMI_FW_READY_EVENTID:\n\t\treturn \"WMI_FW_READY_EVENT\";\n\tcase WMI_TRAFFIC_RESUME_EVENTID:\n\t\treturn \"WMI_TRAFFIC_RESUME_EVENT\";\n\tcase WMI_TOF_GET_TX_RX_OFFSET_EVENTID:\n\t\treturn \"WMI_TOF_GET_TX_RX_OFFSET_EVENT\";\n\tcase WMI_TOF_SET_TX_RX_OFFSET_EVENTID:\n\t\treturn \"WMI_TOF_SET_TX_RX_OFFSET_EVENT\";\n\tcase WMI_VRING_CFG_DONE_EVENTID:\n\t\treturn \"WMI_VRING_CFG_DONE_EVENT\";\n\tcase WMI_READY_EVENTID:\n\t\treturn \"WMI_READY_EVENT\";\n\tcase WMI_RX_MGMT_PACKET_EVENTID:\n\t\treturn \"WMI_RX_MGMT_PACKET_EVENT\";\n\tcase WMI_TX_MGMT_PACKET_EVENTID:\n\t\treturn \"WMI_TX_MGMT_PACKET_EVENT\";\n\tcase WMI_SCAN_COMPLETE_EVENTID:\n\t\treturn \"WMI_SCAN_COMPLETE_EVENT\";\n\tcase WMI_ACS_PASSIVE_SCAN_COMPLETE_EVENTID:\n\t\treturn \"WMI_ACS_PASSIVE_SCAN_COMPLETE_EVENT\";\n\tcase WMI_CONNECT_EVENTID:\n\t\treturn \"WMI_CONNECT_EVENT\";\n\tcase WMI_EAPOL_RX_EVENTID:\n\t\treturn \"WMI_EAPOL_RX_EVENT\";\n\tcase WMI_BA_STATUS_EVENTID:\n\t\treturn \"WMI_BA_STATUS_EVENT\";\n\tcase WMI_RCP_ADDBA_REQ_EVENTID:\n\t\treturn \"WMI_RCP_ADDBA_REQ_EVENT\";\n\tcase WMI_DELBA_EVENTID:\n\t\treturn \"WMI_DELBA_EVENT\";\n\tcase WMI_RING_EN_EVENTID:\n\t\treturn \"WMI_RING_EN_EVENT\";\n\tcase WMI_DATA_PORT_OPEN_EVENTID:\n\t\treturn \"WMI_DATA_PORT_OPEN_EVENT\";\n\tcase WMI_AOA_MEAS_EVENTID:\n\t\treturn \"WMI_AOA_MEAS_EVENT\";\n\tcase WMI_TOF_SESSION_END_EVENTID:\n\t\treturn \"WMI_TOF_SESSION_END_EVENT\";\n\tcase WMI_TOF_GET_CAPABILITIES_EVENTID:\n\t\treturn \"WMI_TOF_GET_CAPABILITIES_EVENT\";\n\tcase WMI_TOF_SET_LCR_EVENTID:\n\t\treturn \"WMI_TOF_SET_LCR_EVENT\";\n\tcase WMI_TOF_SET_LCI_EVENTID:\n\t\treturn \"WMI_TOF_SET_LCI_EVENT\";\n\tcase WMI_TOF_FTM_PER_DEST_RES_EVENTID:\n\t\treturn \"WMI_TOF_FTM_PER_DEST_RES_EVENT\";\n\tcase WMI_TOF_CHANNEL_INFO_EVENTID:\n\t\treturn \"WMI_TOF_CHANNEL_INFO_EVENT\";\n\tcase WMI_TRAFFIC_SUSPEND_EVENTID:\n\t\treturn \"WMI_TRAFFIC_SUSPEND_EVENT\";\n\tcase WMI_ECHO_RSP_EVENTID:\n\t\treturn \"WMI_ECHO_RSP_EVENT\";\n\tcase WMI_LED_CFG_DONE_EVENTID:\n\t\treturn \"WMI_LED_CFG_DONE_EVENT\";\n\tcase WMI_PCP_STARTED_EVENTID:\n\t\treturn \"WMI_PCP_STARTED_EVENT\";\n\tcase WMI_PCP_STOPPED_EVENTID:\n\t\treturn \"WMI_PCP_STOPPED_EVENT\";\n\tcase WMI_GET_SSID_EVENTID:\n\t\treturn \"WMI_GET_SSID_EVENT\";\n\tcase WMI_GET_PCP_CHANNEL_EVENTID:\n\t\treturn \"WMI_GET_PCP_CHANNEL_EVENT\";\n\tcase WMI_P2P_CFG_DONE_EVENTID:\n\t\treturn \"WMI_P2P_CFG_DONE_EVENT\";\n\tcase WMI_PORT_ALLOCATED_EVENTID:\n\t\treturn \"WMI_PORT_ALLOCATED_EVENT\";\n\tcase WMI_PORT_DELETED_EVENTID:\n\t\treturn \"WMI_PORT_DELETED_EVENT\";\n\tcase WMI_LISTEN_STARTED_EVENTID:\n\t\treturn \"WMI_LISTEN_STARTED_EVENT\";\n\tcase WMI_SEARCH_STARTED_EVENTID:\n\t\treturn \"WMI_SEARCH_STARTED_EVENT\";\n\tcase WMI_DISCOVERY_STOPPED_EVENTID:\n\t\treturn \"WMI_DISCOVERY_STOPPED_EVENT\";\n\tcase WMI_CFG_RX_CHAIN_DONE_EVENTID:\n\t\treturn \"WMI_CFG_RX_CHAIN_DONE_EVENT\";\n\tcase WMI_TEMP_SENSE_DONE_EVENTID:\n\t\treturn \"WMI_TEMP_SENSE_DONE_EVENT\";\n\tcase WMI_RCP_ADDBA_RESP_SENT_EVENTID:\n\t\treturn \"WMI_RCP_ADDBA_RESP_SENT_EVENT\";\n\tcase WMI_PS_DEV_PROFILE_CFG_EVENTID:\n\t\treturn \"WMI_PS_DEV_PROFILE_CFG_EVENT\";\n\tcase WMI_SET_MGMT_RETRY_LIMIT_EVENTID:\n\t\treturn \"WMI_SET_MGMT_RETRY_LIMIT_EVENT\";\n\tcase WMI_GET_MGMT_RETRY_LIMIT_EVENTID:\n\t\treturn \"WMI_GET_MGMT_RETRY_LIMIT_EVENT\";\n\tcase WMI_SET_THERMAL_THROTTLING_CFG_EVENTID:\n\t\treturn \"WMI_SET_THERMAL_THROTTLING_CFG_EVENT\";\n\tcase WMI_GET_THERMAL_THROTTLING_CFG_EVENTID:\n\t\treturn \"WMI_GET_THERMAL_THROTTLING_CFG_EVENT\";\n\tcase WMI_LINK_MAINTAIN_CFG_WRITE_DONE_EVENTID:\n\t\treturn \"WMI_LINK_MAINTAIN_CFG_WRITE_DONE_EVENT\";\n\tcase WMI_LO_POWER_CALIB_FROM_OTP_EVENTID:\n\t\treturn \"WMI_LO_POWER_CALIB_FROM_OTP_EVENT\";\n\tcase WMI_START_SCHED_SCAN_EVENTID:\n\t\treturn \"WMI_START_SCHED_SCAN_EVENT\";\n\tcase WMI_STOP_SCHED_SCAN_EVENTID:\n\t\treturn \"WMI_STOP_SCHED_SCAN_EVENT\";\n\tcase WMI_SCHED_SCAN_RESULT_EVENTID:\n\t\treturn \"WMI_SCHED_SCAN_RESULT_EVENT\";\n\tcase WMI_TX_STATUS_RING_CFG_DONE_EVENTID:\n\t\treturn \"WMI_TX_STATUS_RING_CFG_DONE_EVENT\";\n\tcase WMI_RX_STATUS_RING_CFG_DONE_EVENTID:\n\t\treturn \"WMI_RX_STATUS_RING_CFG_DONE_EVENT\";\n\tcase WMI_TX_DESC_RING_CFG_DONE_EVENTID:\n\t\treturn \"WMI_TX_DESC_RING_CFG_DONE_EVENT\";\n\tcase WMI_RX_DESC_RING_CFG_DONE_EVENTID:\n\t\treturn \"WMI_RX_DESC_RING_CFG_DONE_EVENT\";\n\tcase WMI_CFG_DEF_RX_OFFLOAD_DONE_EVENTID:\n\t\treturn \"WMI_CFG_DEF_RX_OFFLOAD_DONE_EVENT\";\n\tcase WMI_LINK_STATS_CONFIG_DONE_EVENTID:\n\t\treturn \"WMI_LINK_STATS_CONFIG_DONE_EVENT\";\n\tcase WMI_LINK_STATS_EVENTID:\n\t\treturn \"WMI_LINK_STATS_EVENT\";\n\tcase WMI_COMMAND_NOT_SUPPORTED_EVENTID:\n\t\treturn \"WMI_COMMAND_NOT_SUPPORTED_EVENT\";\n\tcase WMI_FT_AUTH_STATUS_EVENTID:\n\t\treturn \"WMI_FT_AUTH_STATUS_EVENT\";\n\tcase WMI_FT_REASSOC_STATUS_EVENTID:\n\t\treturn \"WMI_FT_REASSOC_STATUS_EVENT\";\n\tcase WMI_RBUFCAP_CFG_EVENTID:\n\t\treturn \"WMI_RBUFCAP_CFG_EVENT\";\n\tcase WMI_TEMP_SENSE_ALL_DONE_EVENTID:\n\t\treturn \"WMI_TEMP_SENSE_ALL_DONE_EVENTID\";\n\tcase WMI_SET_LINK_MONITOR_EVENTID:\n\t\treturn \"WMI_SET_LINK_MONITOR_EVENT\";\n\tcase WMI_LINK_MONITOR_EVENTID:\n\t\treturn \"WMI_LINK_MONITOR_EVENT\";\n\tdefault:\n\t\treturn \"Untracked EVENT\";\n\t}\n}\n\nstatic int __wmi_send(struct wil6210_priv *wil, u16 cmdid, u8 mid,\n\t\t      void *buf, u16 len)\n{\n\tstruct {\n\t\tstruct wil6210_mbox_hdr hdr;\n\t\tstruct wmi_cmd_hdr wmi;\n\t} __packed cmd = {\n\t\t.hdr = {\n\t\t\t.type = WIL_MBOX_HDR_TYPE_WMI,\n\t\t\t.flags = 0,\n\t\t\t.len = cpu_to_le16(sizeof(cmd.wmi) + len),\n\t\t},\n\t\t.wmi = {\n\t\t\t.mid = mid,\n\t\t\t.command_id = cpu_to_le16(cmdid),\n\t\t},\n\t};\n\tstruct wil6210_mbox_ring *r = &wil->mbox_ctl.tx;\n\tstruct wil6210_mbox_ring_desc d_head;\n\tu32 next_head;\n\tvoid __iomem *dst;\n\tvoid __iomem *head = wmi_addr(wil, r->head);\n\tuint retry;\n\tint rc = 0;\n\n\tif (len > r->entry_size - sizeof(cmd)) {\n\t\twil_err(wil, \"WMI size too large: %d bytes, max is %d\\n\",\n\t\t\t(int)(sizeof(cmd) + len), r->entry_size);\n\t\treturn -ERANGE;\n\t}\n\n\tmight_sleep();\n\n\tif (!test_bit(wil_status_fwready, wil->status)) {\n\t\twil_err(wil, \"WMI: cannot send command while FW not ready\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\t \n\tif ((test_bit(wil_status_suspending, wil->status) ||\n\t     test_bit(wil_status_suspended, wil->status) ||\n\t     test_bit(wil_status_resuming, wil->status)) &&\n\t     ((cmdid != WMI_TRAFFIC_SUSPEND_CMDID) &&\n\t      (cmdid != WMI_TRAFFIC_RESUME_CMDID))) {\n\t\twil_err(wil, \"WMI: reject send_command during suspend\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!head) {\n\t\twil_err(wil, \"WMI head is garbage: 0x%08x\\n\", r->head);\n\t\treturn -EINVAL;\n\t}\n\n\twil_halp_vote(wil);\n\n\t \n\tfor (retry = 5; retry > 0; retry--) {\n\t\twil_memcpy_fromio_32(&d_head, head, sizeof(d_head));\n\t\tif (d_head.sync == 0)\n\t\t\tbreak;\n\t\tmsleep(20);\n\t}\n\tif (d_head.sync != 0) {\n\t\twil_err(wil, \"WMI head busy\\n\");\n\t\trc = -EBUSY;\n\t\tgoto out;\n\t}\n\t \n\tnext_head = r->base + ((r->head - r->base + sizeof(d_head)) % r->size);\n\twil_dbg_wmi(wil, \"Head 0x%08x -> 0x%08x\\n\", r->head, next_head);\n\t \n\tfor (retry = 5; retry > 0; retry--) {\n\t\tif (!test_bit(wil_status_fwready, wil->status)) {\n\t\t\twil_err(wil, \"WMI: cannot send command while FW not ready\\n\");\n\t\t\trc = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\t\tr->tail = wil_r(wil, RGF_MBOX +\n\t\t\t\toffsetof(struct wil6210_mbox_ctl, tx.tail));\n\t\tif (next_head != r->tail)\n\t\t\tbreak;\n\t\tmsleep(20);\n\t}\n\tif (next_head == r->tail) {\n\t\twil_err(wil, \"WMI ring full\\n\");\n\t\trc = -EBUSY;\n\t\tgoto out;\n\t}\n\tdst = wmi_buffer(wil, d_head.addr);\n\tif (!dst) {\n\t\twil_err(wil, \"invalid WMI buffer: 0x%08x\\n\",\n\t\t\tle32_to_cpu(d_head.addr));\n\t\trc = -EAGAIN;\n\t\tgoto out;\n\t}\n\tcmd.hdr.seq = cpu_to_le16(++wil->wmi_seq);\n\t \n\twil_dbg_wmi(wil, \"sending %s (0x%04x) [%d] mid %d\\n\",\n\t\t    cmdid2name(cmdid), cmdid, len, mid);\n\twil_hex_dump_wmi(\"Cmd \", DUMP_PREFIX_OFFSET, 16, 1, &cmd,\n\t\t\t sizeof(cmd), true);\n\twil_hex_dump_wmi(\"cmd \", DUMP_PREFIX_OFFSET, 16, 1, buf,\n\t\t\t len, true);\n\twil_memcpy_toio_32(dst, &cmd, sizeof(cmd));\n\twil_memcpy_toio_32(dst + sizeof(cmd), buf, len);\n\t \n\twil_w(wil, r->head + offsetof(struct wil6210_mbox_ring_desc, sync), 1);\n\t \n\twil_w(wil, RGF_MBOX + offsetof(struct wil6210_mbox_ctl, tx.head),\n\t      r->head = next_head);\n\n\ttrace_wil6210_wmi_cmd(&cmd.wmi, buf, len);\n\n\t \n\twil_w(wil, RGF_USER_USER_ICR + offsetof(struct RGF_ICR, ICS),\n\t      SW_INT_MBOX);\n\nout:\n\twil_halp_unvote(wil);\n\treturn rc;\n}\n\nint wmi_send(struct wil6210_priv *wil, u16 cmdid, u8 mid, void *buf, u16 len)\n{\n\tint rc;\n\n\tmutex_lock(&wil->wmi_mutex);\n\trc = __wmi_send(wil, cmdid, mid, buf, len);\n\tmutex_unlock(&wil->wmi_mutex);\n\n\treturn rc;\n}\n\n \nstatic void wmi_evt_ready(struct wil6210_vif *vif, int id, void *d, int len)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tstruct wiphy *wiphy = wil_to_wiphy(wil);\n\tstruct wmi_ready_event *evt = d;\n\tu8 fw_max_assoc_sta;\n\n\twil_info(wil, \"FW ver. %s(SW %d); MAC %pM; %d MID's\\n\",\n\t\t wil->fw_version, le32_to_cpu(evt->sw_version),\n\t\t evt->mac, evt->numof_additional_mids);\n\tif (evt->numof_additional_mids + 1 < wil->max_vifs) {\n\t\twil_err(wil, \"FW does not support enough MIDs (need %d)\",\n\t\t\twil->max_vifs - 1);\n\t\treturn;  \n\t}\n\t \n\tstrscpy(wiphy->fw_version, wil->fw_version, sizeof(wiphy->fw_version));\n\n\tif (len > offsetof(struct wmi_ready_event, rfc_read_calib_result)) {\n\t\twil_dbg_wmi(wil, \"rfc calibration result %d\\n\",\n\t\t\t    evt->rfc_read_calib_result);\n\t\twil->fw_calib_result = evt->rfc_read_calib_result;\n\t}\n\n\tfw_max_assoc_sta = WIL6210_RX_DESC_MAX_CID;\n\tif (len > offsetof(struct wmi_ready_event, max_assoc_sta) &&\n\t    evt->max_assoc_sta > 0) {\n\t\tfw_max_assoc_sta = evt->max_assoc_sta;\n\t\twil_dbg_wmi(wil, \"fw reported max assoc sta %d\\n\",\n\t\t\t    fw_max_assoc_sta);\n\n\t\tif (fw_max_assoc_sta > WIL6210_MAX_CID) {\n\t\t\twil_dbg_wmi(wil,\n\t\t\t\t    \"fw max assoc sta %d exceeds max driver supported %d\\n\",\n\t\t\t\t    fw_max_assoc_sta, WIL6210_MAX_CID);\n\t\t\tfw_max_assoc_sta = WIL6210_MAX_CID;\n\t\t}\n\t}\n\n\twil->max_assoc_sta = min_t(uint, max_assoc_sta, fw_max_assoc_sta);\n\twil_dbg_wmi(wil, \"setting max assoc sta to %d\\n\", wil->max_assoc_sta);\n\n\twil_set_recovery_state(wil, fw_recovery_idle);\n\tset_bit(wil_status_fwready, wil->status);\n\t \n\tcomplete(&wil->wmi_ready);\n}\n\nstatic void wmi_evt_rx_mgmt(struct wil6210_vif *vif, int id, void *d, int len)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tstruct wmi_rx_mgmt_packet_event *data = d;\n\tstruct wiphy *wiphy = wil_to_wiphy(wil);\n\tstruct ieee80211_mgmt *rx_mgmt_frame =\n\t\t\t(struct ieee80211_mgmt *)data->payload;\n\tint flen = len - offsetof(struct wmi_rx_mgmt_packet_event, payload);\n\tint ch_no;\n\tu32 freq;\n\tstruct ieee80211_channel *channel;\n\ts32 signal;\n\t__le16 fc;\n\tu32 d_len;\n\tu16 d_status;\n\n\tif (flen < 0) {\n\t\twil_err(wil, \"MGMT Rx: short event, len %d\\n\", len);\n\t\treturn;\n\t}\n\n\td_len = le32_to_cpu(data->info.len);\n\tif (d_len != flen) {\n\t\twil_err(wil,\n\t\t\t\"MGMT Rx: length mismatch, d_len %d should be %d\\n\",\n\t\t\td_len, flen);\n\t\treturn;\n\t}\n\n\tch_no = data->info.channel + 1;\n\tfreq = ieee80211_channel_to_frequency(ch_no, NL80211_BAND_60GHZ);\n\tchannel = ieee80211_get_channel(wiphy, freq);\n\tif (test_bit(WMI_FW_CAPABILITY_RSSI_REPORTING, wil->fw_capabilities))\n\t\tsignal = 100 * data->info.rssi;\n\telse\n\t\tsignal = data->info.sqi;\n\td_status = le16_to_cpu(data->info.status);\n\tfc = rx_mgmt_frame->frame_control;\n\n\twil_dbg_wmi(wil, \"MGMT Rx: channel %d MCS %s RSSI %d SQI %d%%\\n\",\n\t\t    data->info.channel, WIL_EXTENDED_MCS_CHECK(data->info.mcs),\n\t\t    data->info.rssi, data->info.sqi);\n\twil_dbg_wmi(wil, \"status 0x%04x len %d fc 0x%04x\\n\", d_status, d_len,\n\t\t    le16_to_cpu(fc));\n\twil_dbg_wmi(wil, \"qid %d mid %d cid %d\\n\",\n\t\t    data->info.qid, data->info.mid, data->info.cid);\n\twil_hex_dump_wmi(\"MGMT Rx \", DUMP_PREFIX_OFFSET, 16, 1, rx_mgmt_frame,\n\t\t\t d_len, true);\n\n\tif (!channel) {\n\t\twil_err(wil, \"Frame on unsupported channel\\n\");\n\t\treturn;\n\t}\n\n\tif (ieee80211_is_beacon(fc) || ieee80211_is_probe_resp(fc)) {\n\t\tstruct cfg80211_bss *bss;\n\t\tstruct cfg80211_inform_bss bss_data = {\n\t\t\t.chan = channel,\n\t\t\t.scan_width = NL80211_BSS_CHAN_WIDTH_20,\n\t\t\t.signal = signal,\n\t\t\t.boottime_ns = ktime_to_ns(ktime_get_boottime()),\n\t\t};\n\t\tu64 tsf = le64_to_cpu(rx_mgmt_frame->u.beacon.timestamp);\n\t\tu16 cap = le16_to_cpu(rx_mgmt_frame->u.beacon.capab_info);\n\t\tu16 bi = le16_to_cpu(rx_mgmt_frame->u.beacon.beacon_int);\n\t\tconst u8 *ie_buf = rx_mgmt_frame->u.beacon.variable;\n\t\tsize_t ie_len = d_len - offsetof(struct ieee80211_mgmt,\n\t\t\t\t\t\t u.beacon.variable);\n\t\twil_dbg_wmi(wil, \"Capability info : 0x%04x\\n\", cap);\n\t\twil_dbg_wmi(wil, \"TSF : 0x%016llx\\n\", tsf);\n\t\twil_dbg_wmi(wil, \"Beacon interval : %d\\n\", bi);\n\t\twil_hex_dump_wmi(\"IE \", DUMP_PREFIX_OFFSET, 16, 1, ie_buf,\n\t\t\t\t ie_len, true);\n\n\t\twil_dbg_wmi(wil, \"Capability info : 0x%04x\\n\", cap);\n\n\t\tbss = cfg80211_inform_bss_frame_data(wiphy, &bss_data,\n\t\t\t\t\t\t     rx_mgmt_frame,\n\t\t\t\t\t\t     d_len, GFP_KERNEL);\n\t\tif (bss) {\n\t\t\twil_dbg_wmi(wil, \"Added BSS %pM\\n\",\n\t\t\t\t    rx_mgmt_frame->bssid);\n\t\t\tcfg80211_put_bss(wiphy, bss);\n\t\t} else {\n\t\t\twil_err(wil, \"cfg80211_inform_bss_frame() failed\\n\");\n\t\t}\n\t} else {\n\t\tmutex_lock(&wil->vif_mutex);\n\t\tcfg80211_rx_mgmt(vif_to_radio_wdev(wil, vif), freq, signal,\n\t\t\t\t (void *)rx_mgmt_frame, d_len, 0);\n\t\tmutex_unlock(&wil->vif_mutex);\n\t}\n}\n\nstatic void wmi_evt_tx_mgmt(struct wil6210_vif *vif, int id, void *d, int len)\n{\n\tstruct wmi_tx_mgmt_packet_event *data = d;\n\tstruct ieee80211_mgmt *mgmt_frame =\n\t\t\t(struct ieee80211_mgmt *)data->payload;\n\tint flen = len - offsetof(struct wmi_tx_mgmt_packet_event, payload);\n\n\twil_hex_dump_wmi(\"MGMT Tx \", DUMP_PREFIX_OFFSET, 16, 1, mgmt_frame,\n\t\t\t flen, true);\n}\n\nstatic void wmi_evt_scan_complete(struct wil6210_vif *vif, int id,\n\t\t\t\t  void *d, int len)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\n\tmutex_lock(&wil->vif_mutex);\n\tif (vif->scan_request) {\n\t\tstruct wmi_scan_complete_event *data = d;\n\t\tint status = le32_to_cpu(data->status);\n\t\tstruct cfg80211_scan_info info = {\n\t\t\t.aborted = ((status != WMI_SCAN_SUCCESS) &&\n\t\t\t\t(status != WMI_SCAN_ABORT_REJECTED)),\n\t\t};\n\n\t\twil_dbg_wmi(wil, \"SCAN_COMPLETE(0x%08x)\\n\", status);\n\t\twil_dbg_misc(wil, \"Complete scan_request 0x%p aborted %d\\n\",\n\t\t\t     vif->scan_request, info.aborted);\n\t\tdel_timer_sync(&vif->scan_timer);\n\t\tcfg80211_scan_done(vif->scan_request, &info);\n\t\tif (vif->mid == 0)\n\t\t\twil->radio_wdev = wil->main_ndev->ieee80211_ptr;\n\t\tvif->scan_request = NULL;\n\t\twake_up_interruptible(&wil->wq);\n\t\tif (vif->p2p.pending_listen_wdev) {\n\t\t\twil_dbg_misc(wil, \"Scheduling delayed listen\\n\");\n\t\t\tschedule_work(&vif->p2p.delayed_listen_work);\n\t\t}\n\t} else {\n\t\twil_err(wil, \"SCAN_COMPLETE while not scanning\\n\");\n\t}\n\tmutex_unlock(&wil->vif_mutex);\n}\n\nstatic void wmi_evt_connect(struct wil6210_vif *vif, int id, void *d, int len)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tstruct net_device *ndev = vif_to_ndev(vif);\n\tstruct wireless_dev *wdev = vif_to_wdev(vif);\n\tstruct wmi_connect_event *evt = d;\n\tint ch;  \n\tstruct station_info *sinfo;\n\tu8 *assoc_req_ie, *assoc_resp_ie;\n\tsize_t assoc_req_ielen, assoc_resp_ielen;\n\t \n\tconst size_t assoc_req_ie_offset = sizeof(u16) * 2;\n\t \n\tconst size_t assoc_resp_ie_offset = sizeof(u16) * 3;\n\tint rc;\n\n\tif (len < sizeof(*evt)) {\n\t\twil_err(wil, \"Connect event too short : %d bytes\\n\", len);\n\t\treturn;\n\t}\n\tif (len != sizeof(*evt) + evt->beacon_ie_len + evt->assoc_req_len +\n\t\t   evt->assoc_resp_len) {\n\t\twil_err(wil,\n\t\t\t\"Connect event corrupted : %d != %d + %d + %d + %d\\n\",\n\t\t\tlen, (int)sizeof(*evt), evt->beacon_ie_len,\n\t\t\tevt->assoc_req_len, evt->assoc_resp_len);\n\t\treturn;\n\t}\n\tif (evt->cid >= wil->max_assoc_sta) {\n\t\twil_err(wil, \"Connect CID invalid : %d\\n\", evt->cid);\n\t\treturn;\n\t}\n\n\tch = evt->channel + 1;\n\twil_info(wil, \"Connect %pM channel [%d] cid %d aid %d\\n\",\n\t\t evt->bssid, ch, evt->cid, evt->aid);\n\twil_hex_dump_wmi(\"connect AI : \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t evt->assoc_info, len - sizeof(*evt), true);\n\n\t \n\tassoc_req_ie = &evt->assoc_info[evt->beacon_ie_len +\n\t\t\t\t\tassoc_req_ie_offset];\n\tassoc_req_ielen = evt->assoc_req_len - assoc_req_ie_offset;\n\tif (evt->assoc_req_len <= assoc_req_ie_offset) {\n\t\tassoc_req_ie = NULL;\n\t\tassoc_req_ielen = 0;\n\t}\n\n\tassoc_resp_ie = &evt->assoc_info[evt->beacon_ie_len +\n\t\t\t\t\t evt->assoc_req_len +\n\t\t\t\t\t assoc_resp_ie_offset];\n\tassoc_resp_ielen = evt->assoc_resp_len - assoc_resp_ie_offset;\n\tif (evt->assoc_resp_len <= assoc_resp_ie_offset) {\n\t\tassoc_resp_ie = NULL;\n\t\tassoc_resp_ielen = 0;\n\t}\n\n\tif (test_bit(wil_status_resetting, wil->status) ||\n\t    !test_bit(wil_status_fwready, wil->status)) {\n\t\twil_err(wil, \"status_resetting, cancel connect event, CID %d\\n\",\n\t\t\tevt->cid);\n\t\t \n\t\treturn;\n\t}\n\n\tmutex_lock(&wil->mutex);\n\n\tif ((wdev->iftype == NL80211_IFTYPE_STATION) ||\n\t    (wdev->iftype == NL80211_IFTYPE_P2P_CLIENT)) {\n\t\tif (!test_bit(wil_vif_fwconnecting, vif->status)) {\n\t\t\twil_err(wil, \"Not in connecting state\\n\");\n\t\t\tmutex_unlock(&wil->mutex);\n\t\t\treturn;\n\t\t}\n\t\tdel_timer_sync(&vif->connect_timer);\n\t} else if ((wdev->iftype == NL80211_IFTYPE_AP) ||\n\t\t   (wdev->iftype == NL80211_IFTYPE_P2P_GO)) {\n\t\tif (wil->sta[evt->cid].status != wil_sta_unused) {\n\t\t\twil_err(wil, \"AP: Invalid status %d for CID %d\\n\",\n\t\t\t\twil->sta[evt->cid].status, evt->cid);\n\t\t\tmutex_unlock(&wil->mutex);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tether_addr_copy(wil->sta[evt->cid].addr, evt->bssid);\n\twil->sta[evt->cid].mid = vif->mid;\n\twil->sta[evt->cid].status = wil_sta_conn_pending;\n\n\trc = wil_ring_init_tx(vif, evt->cid);\n\tif (rc) {\n\t\twil_err(wil, \"config tx vring failed for CID %d, rc (%d)\\n\",\n\t\t\tevt->cid, rc);\n\t\twmi_disconnect_sta(vif, wil->sta[evt->cid].addr,\n\t\t\t\t   WLAN_REASON_UNSPECIFIED, false);\n\t} else {\n\t\twil_info(wil, \"successful connection to CID %d\\n\", evt->cid);\n\t}\n\n\tif ((wdev->iftype == NL80211_IFTYPE_STATION) ||\n\t    (wdev->iftype == NL80211_IFTYPE_P2P_CLIENT)) {\n\t\tif (rc) {\n\t\t\tnetif_carrier_off(ndev);\n\t\t\twil6210_bus_request(wil, WIL_DEFAULT_BUS_REQUEST_KBPS);\n\t\t\twil_err(wil, \"cfg80211_connect_result with failure\\n\");\n\t\t\tcfg80211_connect_result(ndev, evt->bssid, NULL, 0,\n\t\t\t\t\t\tNULL, 0,\n\t\t\t\t\t\tWLAN_STATUS_UNSPECIFIED_FAILURE,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tstruct wiphy *wiphy = wil_to_wiphy(wil);\n\n\t\t\tcfg80211_ref_bss(wiphy, vif->bss);\n\t\t\tcfg80211_connect_bss(ndev, evt->bssid, vif->bss,\n\t\t\t\t\t     assoc_req_ie, assoc_req_ielen,\n\t\t\t\t\t     assoc_resp_ie, assoc_resp_ielen,\n\t\t\t\t\t     WLAN_STATUS_SUCCESS, GFP_KERNEL,\n\t\t\t\t\t     NL80211_TIMEOUT_UNSPECIFIED);\n\t\t}\n\t\tvif->bss = NULL;\n\t} else if ((wdev->iftype == NL80211_IFTYPE_AP) ||\n\t\t   (wdev->iftype == NL80211_IFTYPE_P2P_GO)) {\n\n\t\tif (rc) {\n\t\t\tif (disable_ap_sme)\n\t\t\t\t \n\t\t\t\tcfg80211_del_sta(ndev, evt->bssid, GFP_KERNEL);\n\t\t\tgoto out;\n\t\t}\n\n\t\tsinfo = kzalloc(sizeof(*sinfo), GFP_KERNEL);\n\t\tif (!sinfo) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsinfo->generation = wil->sinfo_gen++;\n\n\t\tif (assoc_req_ie) {\n\t\t\tsinfo->assoc_req_ies = assoc_req_ie;\n\t\t\tsinfo->assoc_req_ies_len = assoc_req_ielen;\n\t\t}\n\n\t\tcfg80211_new_sta(ndev, evt->bssid, sinfo, GFP_KERNEL);\n\n\t\tkfree(sinfo);\n\t} else {\n\t\twil_err(wil, \"unhandled iftype %d for CID %d\\n\", wdev->iftype,\n\t\t\tevt->cid);\n\t\tgoto out;\n\t}\n\n\twil->sta[evt->cid].status = wil_sta_connected;\n\twil->sta[evt->cid].aid = evt->aid;\n\tif (!test_and_set_bit(wil_vif_fwconnected, vif->status))\n\t\tatomic_inc(&wil->connected_vifs);\n\twil_update_net_queues_bh(wil, vif, NULL, false);\n\nout:\n\tif (rc) {\n\t\twil->sta[evt->cid].status = wil_sta_unused;\n\t\twil->sta[evt->cid].mid = U8_MAX;\n\t}\n\tclear_bit(wil_vif_fwconnecting, vif->status);\n\tmutex_unlock(&wil->mutex);\n}\n\nstatic void wmi_evt_disconnect(struct wil6210_vif *vif, int id,\n\t\t\t       void *d, int len)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tstruct wmi_disconnect_event *evt = d;\n\tu16 reason_code = le16_to_cpu(evt->protocol_reason_status);\n\n\twil_info(wil, \"Disconnect %pM reason [proto %d wmi %d]\\n\",\n\t\t evt->bssid, reason_code, evt->disconnect_reason);\n\n\twil->sinfo_gen++;\n\n\tif (test_bit(wil_status_resetting, wil->status) ||\n\t    !test_bit(wil_status_fwready, wil->status)) {\n\t\twil_err(wil, \"status_resetting, cancel disconnect event\\n\");\n\t\t \n\t\treturn;\n\t}\n\n\tmutex_lock(&wil->mutex);\n\twil6210_disconnect_complete(vif, evt->bssid, reason_code);\n\tif (disable_ap_sme) {\n\t\tstruct wireless_dev *wdev = vif_to_wdev(vif);\n\t\tstruct net_device *ndev = vif_to_ndev(vif);\n\n\t\t \n\t\tswitch (wdev->iftype) {\n\t\t \n\t\tcase NL80211_IFTYPE_AP:\n\t\tcase NL80211_IFTYPE_P2P_GO:\n\t\t\t \n\t\t\tcfg80211_cqm_pktloss_notify(ndev, evt->bssid, 0,\n\t\t\t\t\t\t    GFP_KERNEL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&wil->mutex);\n}\n\n \nstatic void wmi_evt_eapol_rx(struct wil6210_vif *vif, int id, void *d, int len)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tstruct net_device *ndev = vif_to_ndev(vif);\n\tstruct wmi_eapol_rx_event *evt = d;\n\tu16 eapol_len = le16_to_cpu(evt->eapol_len);\n\tint sz = eapol_len + ETH_HLEN;\n\tstruct sk_buff *skb;\n\tstruct ethhdr *eth;\n\tint cid;\n\tstruct wil_net_stats *stats = NULL;\n\n\twil_dbg_wmi(wil, \"EAPOL len %d from %pM MID %d\\n\", eapol_len,\n\t\t    evt->src_mac, vif->mid);\n\n\tcid = wil_find_cid(wil, vif->mid, evt->src_mac);\n\tif (cid >= 0)\n\t\tstats = &wil->sta[cid].stats;\n\n\tif (eapol_len > 196) {  \n\t\twil_err(wil, \"EAPOL too large\\n\");\n\t\treturn;\n\t}\n\n\tskb = alloc_skb(sz, GFP_KERNEL);\n\tif (!skb) {\n\t\twil_err(wil, \"Failed to allocate skb\\n\");\n\t\treturn;\n\t}\n\n\teth = skb_put(skb, ETH_HLEN);\n\tether_addr_copy(eth->h_dest, ndev->dev_addr);\n\tether_addr_copy(eth->h_source, evt->src_mac);\n\teth->h_proto = cpu_to_be16(ETH_P_PAE);\n\tskb_put_data(skb, evt->eapol, eapol_len);\n\tskb->protocol = eth_type_trans(skb, ndev);\n\tif (likely(netif_rx(skb) == NET_RX_SUCCESS)) {\n\t\tndev->stats.rx_packets++;\n\t\tndev->stats.rx_bytes += sz;\n\t\tif (stats) {\n\t\t\tstats->rx_packets++;\n\t\t\tstats->rx_bytes += sz;\n\t\t}\n\t} else {\n\t\tndev->stats.rx_dropped++;\n\t\tif (stats)\n\t\t\tstats->rx_dropped++;\n\t}\n}\n\nstatic void wmi_evt_ring_en(struct wil6210_vif *vif, int id, void *d, int len)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tstruct wmi_ring_en_event *evt = d;\n\tu8 vri = evt->ring_index;\n\tstruct wireless_dev *wdev = vif_to_wdev(vif);\n\tstruct wil_sta_info *sta;\n\tu8 cid;\n\tstruct key_params params;\n\n\twil_dbg_wmi(wil, \"Enable vring %d MID %d\\n\", vri, vif->mid);\n\n\tif (vri >= ARRAY_SIZE(wil->ring_tx)) {\n\t\twil_err(wil, \"Enable for invalid vring %d\\n\", vri);\n\t\treturn;\n\t}\n\n\tif (wdev->iftype != NL80211_IFTYPE_AP || !disable_ap_sme ||\n\t    test_bit(wil_vif_ft_roam, vif->status))\n\t\t \n\t\twil->ring_tx_data[vri].dot1x_open = true;\n\tif (vri == vif->bcast_ring)  \n\t\treturn;\n\n\tcid = wil->ring2cid_tid[vri][0];\n\tif (!wil_cid_valid(wil, cid)) {\n\t\twil_err(wil, \"invalid cid %d for vring %d\\n\", cid, vri);\n\t\treturn;\n\t}\n\n\t \n\tsta = &wil->sta[cid];\n\tif (test_bit(wil_vif_ft_roam, vif->status)) {\n\t\tmemset(&params, 0, sizeof(params));\n\t\twil_set_crypto_rx(0, WMI_KEY_USE_PAIRWISE, sta, &params);\n\t\tif (wdev->iftype != NL80211_IFTYPE_AP)\n\t\t\tclear_bit(wil_vif_ft_roam, vif->status);\n\t}\n\n\tif (agg_wsize >= 0)\n\t\twil_addba_tx_request(wil, vri, agg_wsize);\n}\n\nstatic void wmi_evt_ba_status(struct wil6210_vif *vif, int id,\n\t\t\t      void *d, int len)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tstruct wmi_ba_status_event *evt = d;\n\tstruct wil_ring_tx_data *txdata;\n\n\twil_dbg_wmi(wil, \"BACK[%d] %s {%d} timeout %d AMSDU%s\\n\",\n\t\t    evt->ringid,\n\t\t    evt->status == WMI_BA_AGREED ? \"OK\" : \"N/A\",\n\t\t    evt->agg_wsize, __le16_to_cpu(evt->ba_timeout),\n\t\t    evt->amsdu ? \"+\" : \"-\");\n\n\tif (evt->ringid >= WIL6210_MAX_TX_RINGS) {\n\t\twil_err(wil, \"invalid ring id %d\\n\", evt->ringid);\n\t\treturn;\n\t}\n\n\tif (evt->status != WMI_BA_AGREED) {\n\t\tevt->ba_timeout = 0;\n\t\tevt->agg_wsize = 0;\n\t\tevt->amsdu = 0;\n\t}\n\n\ttxdata = &wil->ring_tx_data[evt->ringid];\n\n\ttxdata->agg_timeout = le16_to_cpu(evt->ba_timeout);\n\ttxdata->agg_wsize = evt->agg_wsize;\n\ttxdata->agg_amsdu = evt->amsdu;\n\ttxdata->addba_in_progress = false;\n}\n\nstatic void wmi_evt_addba_rx_req(struct wil6210_vif *vif, int id,\n\t\t\t\t void *d, int len)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tu8 cid, tid;\n\tstruct wmi_rcp_addba_req_event *evt = d;\n\n\tif (evt->cidxtid != CIDXTID_EXTENDED_CID_TID) {\n\t\tparse_cidxtid(evt->cidxtid, &cid, &tid);\n\t} else {\n\t\tcid = evt->cid;\n\t\ttid = evt->tid;\n\t}\n\twil_addba_rx_request(wil, vif->mid, cid, tid, evt->dialog_token,\n\t\t\t     evt->ba_param_set, evt->ba_timeout,\n\t\t\t     evt->ba_seq_ctrl);\n}\n\nstatic void wmi_evt_delba(struct wil6210_vif *vif, int id, void *d, int len)\n__acquires(&sta->tid_rx_lock) __releases(&sta->tid_rx_lock)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tstruct wmi_delba_event *evt = d;\n\tu8 cid, tid;\n\tu16 reason = __le16_to_cpu(evt->reason);\n\tstruct wil_sta_info *sta;\n\tstruct wil_tid_ampdu_rx *r;\n\n\tmight_sleep();\n\n\tif (evt->cidxtid != CIDXTID_EXTENDED_CID_TID) {\n\t\tparse_cidxtid(evt->cidxtid, &cid, &tid);\n\t} else {\n\t\tcid = evt->cid;\n\t\ttid = evt->tid;\n\t}\n\n\tif (!wil_cid_valid(wil, cid)) {\n\t\twil_err(wil, \"DELBA: Invalid CID %d\\n\", cid);\n\t\treturn;\n\t}\n\n\twil_dbg_wmi(wil, \"DELBA MID %d CID %d TID %d from %s reason %d\\n\",\n\t\t    vif->mid, cid, tid,\n\t\t    evt->from_initiator ? \"originator\" : \"recipient\",\n\t\t    reason);\n\tif (!evt->from_initiator) {\n\t\tint i;\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(wil->ring2cid_tid); i++) {\n\t\t\tif (wil->ring2cid_tid[i][0] == cid &&\n\t\t\t    wil->ring2cid_tid[i][1] == tid) {\n\t\t\t\tstruct wil_ring_tx_data *txdata =\n\t\t\t\t\t&wil->ring_tx_data[i];\n\n\t\t\t\twil_dbg_wmi(wil, \"DELBA Tx vring %d\\n\", i);\n\t\t\t\ttxdata->agg_timeout = 0;\n\t\t\t\ttxdata->agg_wsize = 0;\n\t\t\t\ttxdata->addba_in_progress = false;\n\n\t\t\t\tbreak;  \n\t\t\t}\n\t\t}\n\t\tif (i >= ARRAY_SIZE(wil->ring2cid_tid))\n\t\t\twil_err(wil, \"DELBA: unable to find Tx vring\\n\");\n\t\treturn;\n\t}\n\n\tsta = &wil->sta[cid];\n\n\tspin_lock_bh(&sta->tid_rx_lock);\n\n\tr = sta->tid_rx[tid];\n\tsta->tid_rx[tid] = NULL;\n\twil_tid_ampdu_rx_free(wil, r);\n\n\tspin_unlock_bh(&sta->tid_rx_lock);\n}\n\nstatic void\nwmi_evt_sched_scan_result(struct wil6210_vif *vif, int id, void *d, int len)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tstruct wmi_sched_scan_result_event *data = d;\n\tstruct wiphy *wiphy = wil_to_wiphy(wil);\n\tstruct ieee80211_mgmt *rx_mgmt_frame =\n\t\t(struct ieee80211_mgmt *)data->payload;\n\tint flen = len - offsetof(struct wmi_sched_scan_result_event, payload);\n\tint ch_no;\n\tu32 freq;\n\tstruct ieee80211_channel *channel;\n\ts32 signal;\n\t__le16 fc;\n\tu32 d_len;\n\tstruct cfg80211_bss *bss;\n\tstruct cfg80211_inform_bss bss_data = {\n\t\t.scan_width = NL80211_BSS_CHAN_WIDTH_20,\n\t\t.boottime_ns = ktime_to_ns(ktime_get_boottime()),\n\t};\n\n\tif (flen < 0) {\n\t\twil_err(wil, \"sched scan result event too short, len %d\\n\",\n\t\t\tlen);\n\t\treturn;\n\t}\n\n\td_len = le32_to_cpu(data->info.len);\n\tif (d_len != flen) {\n\t\twil_err(wil,\n\t\t\t\"sched scan result length mismatch, d_len %d should be %d\\n\",\n\t\t\td_len, flen);\n\t\treturn;\n\t}\n\n\tfc = rx_mgmt_frame->frame_control;\n\tif (!ieee80211_is_probe_resp(fc)) {\n\t\twil_err(wil, \"sched scan result invalid frame, fc 0x%04x\\n\",\n\t\t\tfc);\n\t\treturn;\n\t}\n\n\tch_no = data->info.channel + 1;\n\tfreq = ieee80211_channel_to_frequency(ch_no, NL80211_BAND_60GHZ);\n\tchannel = ieee80211_get_channel(wiphy, freq);\n\tif (test_bit(WMI_FW_CAPABILITY_RSSI_REPORTING, wil->fw_capabilities))\n\t\tsignal = 100 * data->info.rssi;\n\telse\n\t\tsignal = data->info.sqi;\n\n\twil_dbg_wmi(wil, \"sched scan result: channel %d MCS %s RSSI %d\\n\",\n\t\t    data->info.channel, WIL_EXTENDED_MCS_CHECK(data->info.mcs),\n\t\t    data->info.rssi);\n\twil_dbg_wmi(wil, \"len %d qid %d mid %d cid %d\\n\",\n\t\t    d_len, data->info.qid, data->info.mid, data->info.cid);\n\twil_hex_dump_wmi(\"PROBE \", DUMP_PREFIX_OFFSET, 16, 1, rx_mgmt_frame,\n\t\t\t d_len, true);\n\n\tif (!channel) {\n\t\twil_err(wil, \"Frame on unsupported channel\\n\");\n\t\treturn;\n\t}\n\n\tbss_data.signal = signal;\n\tbss_data.chan = channel;\n\tbss = cfg80211_inform_bss_frame_data(wiphy, &bss_data, rx_mgmt_frame,\n\t\t\t\t\t     d_len, GFP_KERNEL);\n\tif (bss) {\n\t\twil_dbg_wmi(wil, \"Added BSS %pM\\n\", rx_mgmt_frame->bssid);\n\t\tcfg80211_put_bss(wiphy, bss);\n\t} else {\n\t\twil_err(wil, \"cfg80211_inform_bss_frame() failed\\n\");\n\t}\n\n\tcfg80211_sched_scan_results(wiphy, 0);\n}\n\nstatic void wil_link_stats_store_basic(struct wil6210_vif *vif,\n\t\t\t\t       struct wmi_link_stats_basic *basic)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tu8 cid = basic->cid;\n\tstruct wil_sta_info *sta;\n\n\tif (cid >= wil->max_assoc_sta) {\n\t\twil_err(wil, \"invalid cid %d\\n\", cid);\n\t\treturn;\n\t}\n\n\tsta = &wil->sta[cid];\n\tsta->fw_stats_basic = *basic;\n}\n\nstatic void wil_link_stats_store_global(struct wil6210_vif *vif,\n\t\t\t\t\tstruct wmi_link_stats_global *global)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\n\twil->fw_stats_global.stats = *global;\n}\n\nstatic void wmi_link_stats_parse(struct wil6210_vif *vif, u64 tsf,\n\t\t\t\t bool has_next, void *payload,\n\t\t\t\t size_t payload_size)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tsize_t hdr_size = sizeof(struct wmi_link_stats_record);\n\tsize_t stats_size, record_size, expected_size;\n\tstruct wmi_link_stats_record *hdr;\n\n\tif (payload_size < hdr_size) {\n\t\twil_err(wil, \"link stats wrong event size %zu\\n\", payload_size);\n\t\treturn;\n\t}\n\n\twhile (payload_size >= hdr_size) {\n\t\thdr = payload;\n\t\tstats_size = le16_to_cpu(hdr->record_size);\n\t\trecord_size = hdr_size + stats_size;\n\n\t\tif (payload_size < record_size) {\n\t\t\twil_err(wil, \"link stats payload ended unexpectedly, size %zu < %zu\\n\",\n\t\t\t\tpayload_size, record_size);\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (hdr->record_type_id) {\n\t\tcase WMI_LINK_STATS_TYPE_BASIC:\n\t\t\texpected_size = sizeof(struct wmi_link_stats_basic);\n\t\t\tif (stats_size < expected_size) {\n\t\t\t\twil_err(wil, \"link stats invalid basic record size %zu < %zu\\n\",\n\t\t\t\t\tstats_size, expected_size);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (vif->fw_stats_ready) {\n\t\t\t\t \n\t\t\t\tvif->fw_stats_tsf = 0;\n\t\t\t\tvif->fw_stats_ready = false;\n\t\t\t}\n\n\t\t\twil_link_stats_store_basic(vif, payload + hdr_size);\n\n\t\t\tif (!has_next) {\n\t\t\t\tvif->fw_stats_tsf = tsf;\n\t\t\t\tvif->fw_stats_ready = true;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase WMI_LINK_STATS_TYPE_GLOBAL:\n\t\t\texpected_size = sizeof(struct wmi_link_stats_global);\n\t\t\tif (stats_size < sizeof(struct wmi_link_stats_global)) {\n\t\t\t\twil_err(wil, \"link stats invalid global record size %zu < %zu\\n\",\n\t\t\t\t\tstats_size, expected_size);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (wil->fw_stats_global.ready) {\n\t\t\t\t \n\t\t\t\twil->fw_stats_global.tsf = 0;\n\t\t\t\twil->fw_stats_global.ready = false;\n\t\t\t}\n\n\t\t\twil_link_stats_store_global(vif, payload + hdr_size);\n\n\t\t\tif (!has_next) {\n\t\t\t\twil->fw_stats_global.tsf = tsf;\n\t\t\t\twil->fw_stats_global.ready = true;\n\t\t\t}\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tpayload += record_size;\n\t\tpayload_size -= record_size;\n\t}\n}\n\nstatic void\nwmi_evt_link_stats(struct wil6210_vif *vif, int id, void *d, int len)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tstruct wmi_link_stats_event *evt = d;\n\tsize_t payload_size;\n\n\tif (len < offsetof(struct wmi_link_stats_event, payload)) {\n\t\twil_err(wil, \"stats event way too short %d\\n\", len);\n\t\treturn;\n\t}\n\tpayload_size = le16_to_cpu(evt->payload_size);\n\tif (len < sizeof(struct wmi_link_stats_event) + payload_size) {\n\t\twil_err(wil, \"stats event too short %d\\n\", len);\n\t\treturn;\n\t}\n\n\twmi_link_stats_parse(vif, le64_to_cpu(evt->tsf), evt->has_next,\n\t\t\t     evt->payload, payload_size);\n}\n\n \nstatic int wil_find_cid_ringid_sta(struct wil6210_priv *wil,\n\t\t\t\t   struct wil6210_vif *vif,\n\t\t\t\t   int *cid,\n\t\t\t\t   int *ringid)\n{\n\tstruct wil_ring *ring;\n\tstruct wil_ring_tx_data *txdata;\n\tint min_ring_id = wil_get_min_tx_ring_id(wil);\n\tint i;\n\tu8 lcid;\n\n\tif (!(vif->wdev.iftype == NL80211_IFTYPE_STATION ||\n\t      vif->wdev.iftype == NL80211_IFTYPE_P2P_CLIENT)) {\n\t\twil_err(wil, \"invalid interface type %d\\n\", vif->wdev.iftype);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (i = min_ring_id; i < WIL6210_MAX_TX_RINGS; i++) {\n\t\tring = &wil->ring_tx[i];\n\t\ttxdata = &wil->ring_tx_data[i];\n\t\tif (!ring->va || !txdata->enabled || txdata->mid != vif->mid)\n\t\t\tcontinue;\n\n\t\tlcid = wil->ring2cid_tid[i][0];\n\t\tif (lcid >= wil->max_assoc_sta)  \n\t\t\tcontinue;\n\n\t\twil_dbg_wmi(wil, \"find sta -> ringid %d cid %d\\n\", i, lcid);\n\t\t*cid = lcid;\n\t\t*ringid = i;\n\t\treturn 0;\n\t}\n\n\twil_dbg_wmi(wil, \"find sta cid while no rings active?\\n\");\n\n\treturn -ENOENT;\n}\n\nstatic void\nwmi_evt_auth_status(struct wil6210_vif *vif, int id, void *d, int len)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tstruct net_device *ndev = vif_to_ndev(vif);\n\tstruct wmi_ft_auth_status_event *data = d;\n\tint ie_len = len - offsetof(struct wmi_ft_auth_status_event, ie_info);\n\tint rc, cid = 0, ringid = 0;\n\tstruct cfg80211_ft_event_params ft;\n\tu16 d_len;\n\t \n\tconst size_t auth_ie_offset = sizeof(u16) * 3;\n\tstruct auth_no_hdr *auth = (struct auth_no_hdr *)data->ie_info;\n\n\t \n\tif (ie_len >= 0 && data->status != WMI_FW_STATUS_SUCCESS) {\n\t\twil_err(wil, \"FT: auth failed. status %d\\n\", data->status);\n\t\tgoto fail;\n\t}\n\n\tif (ie_len < auth_ie_offset) {\n\t\twil_err(wil, \"FT: auth event too short, len %d\\n\", len);\n\t\tgoto fail;\n\t}\n\n\td_len = le16_to_cpu(data->ie_len);\n\tif (d_len != ie_len) {\n\t\twil_err(wil,\n\t\t\t\"FT: auth ie length mismatch, d_len %d should be %d\\n\",\n\t\t\td_len, ie_len);\n\t\tgoto fail;\n\t}\n\n\tif (!test_bit(wil_vif_ft_roam, wil->status)) {\n\t\twil_err(wil, \"FT: Not in roaming state\\n\");\n\t\tgoto fail;\n\t}\n\n\tif (le16_to_cpu(auth->auth_transaction) != 2) {\n\t\twil_err(wil, \"FT: auth error. auth_transaction %d\\n\",\n\t\t\tle16_to_cpu(auth->auth_transaction));\n\t\tgoto fail;\n\t}\n\n\tif (le16_to_cpu(auth->auth_alg) != WLAN_AUTH_FT) {\n\t\twil_err(wil, \"FT: auth error. auth_alg %d\\n\",\n\t\t\tle16_to_cpu(auth->auth_alg));\n\t\tgoto fail;\n\t}\n\n\twil_dbg_wmi(wil, \"FT: Auth to %pM successfully\\n\", data->mac_addr);\n\twil_hex_dump_wmi(\"FT Auth ies : \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t data->ie_info, d_len, true);\n\n\t \n\trc = wil_find_cid_ringid_sta(wil, vif, &cid, &ringid);\n\tif (rc) {\n\t\twil_err(wil, \"No valid cid found\\n\");\n\t\tgoto fail;\n\t}\n\n\tif (vif->privacy) {\n\t\t \n\t\trc = wmi_del_cipher_key(vif, 0, wil->sta[cid].addr,\n\t\t\t\t\tWMI_KEY_USE_PAIRWISE);\n\t\tif (rc) {\n\t\t\twil_err(wil, \"WMI_DELETE_CIPHER_KEY_CMD(PTK) failed\\n\");\n\t\t\tgoto fail;\n\t\t}\n\t\trc = wmi_del_cipher_key(vif, 0, wil->sta[cid].addr,\n\t\t\t\t\tWMI_KEY_USE_RX_GROUP);\n\t\tif (rc) {\n\t\t\twil_err(wil, \"WMI_DELETE_CIPHER_KEY_CMD(GTK) failed\\n\");\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tmemset(&ft, 0, sizeof(ft));\n\tft.ies = data->ie_info + auth_ie_offset;\n\tft.ies_len = d_len - auth_ie_offset;\n\tft.target_ap = data->mac_addr;\n\tcfg80211_ft_event(ndev, &ft);\n\n\treturn;\n\nfail:\n\twil6210_disconnect(vif, NULL, WLAN_REASON_PREV_AUTH_NOT_VALID);\n}\n\nstatic void\nwmi_evt_reassoc_status(struct wil6210_vif *vif, int id, void *d, int len)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tstruct net_device *ndev = vif_to_ndev(vif);\n\tstruct wiphy *wiphy = wil_to_wiphy(wil);\n\tstruct wmi_ft_reassoc_status_event *data = d;\n\tint ies_len = len - offsetof(struct wmi_ft_reassoc_status_event,\n\t\t\t\t     ie_info);\n\tint rc = -ENOENT, cid = 0, ringid = 0;\n\tint ch;  \n\tsize_t assoc_req_ie_len = 0, assoc_resp_ie_len = 0;\n\tu8 *assoc_req_ie = NULL, *assoc_resp_ie = NULL;\n\t \n\tconst size_t assoc_req_ie_offset = sizeof(u16) * 2 + ETH_ALEN;\n\t \n\tconst size_t assoc_resp_ie_offset = sizeof(u16) * 3;\n\tu16 d_len;\n\tint freq;\n\tstruct cfg80211_roam_info info;\n\n\tif (ies_len < 0) {\n\t\twil_err(wil, \"ft reassoc event too short, len %d\\n\", len);\n\t\tgoto fail;\n\t}\n\n\twil_dbg_wmi(wil, \"Reasoc Status event: status=%d, aid=%d\",\n\t\t    data->status, data->aid);\n\twil_dbg_wmi(wil, \"    mac_addr=%pM, beacon_ie_len=%d\",\n\t\t    data->mac_addr, data->beacon_ie_len);\n\twil_dbg_wmi(wil, \"    reassoc_req_ie_len=%d, reassoc_resp_ie_len=%d\",\n\t\t    le16_to_cpu(data->reassoc_req_ie_len),\n\t\t    le16_to_cpu(data->reassoc_resp_ie_len));\n\n\td_len = le16_to_cpu(data->beacon_ie_len) +\n\t\tle16_to_cpu(data->reassoc_req_ie_len) +\n\t\tle16_to_cpu(data->reassoc_resp_ie_len);\n\tif (d_len != ies_len) {\n\t\twil_err(wil,\n\t\t\t\"ft reassoc ie length mismatch, d_len %d should be %d\\n\",\n\t\t\td_len, ies_len);\n\t\tgoto fail;\n\t}\n\n\t \n\tif (data->status != WMI_FW_STATUS_SUCCESS) {\n\t\twil_err(wil, \"ft reassoc failed. status %d\\n\", data->status);\n\t\tgoto fail;\n\t}\n\n\t \n\trc = wil_find_cid_ringid_sta(wil, vif, &cid, &ringid);\n\tif (rc) {\n\t\twil_err(wil, \"No valid cid found\\n\");\n\t\tgoto fail;\n\t}\n\n\tch = data->channel + 1;\n\twil_info(wil, \"FT: Roam %pM channel [%d] cid %d aid %d\\n\",\n\t\t data->mac_addr, ch, cid, data->aid);\n\n\twil_hex_dump_wmi(\"reassoc AI : \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t data->ie_info, len - sizeof(*data), true);\n\n\t \n\tif (le16_to_cpu(data->reassoc_req_ie_len) > assoc_req_ie_offset) {\n\t\tassoc_req_ie = &data->ie_info[assoc_req_ie_offset];\n\t\tassoc_req_ie_len = le16_to_cpu(data->reassoc_req_ie_len) -\n\t\t\tassoc_req_ie_offset;\n\t}\n\tif (le16_to_cpu(data->reassoc_resp_ie_len) <= assoc_resp_ie_offset) {\n\t\twil_err(wil, \"FT: reassoc resp ie len is too short, len %d\\n\",\n\t\t\tle16_to_cpu(data->reassoc_resp_ie_len));\n\t\tgoto fail;\n\t}\n\n\tassoc_resp_ie = &data->ie_info[le16_to_cpu(data->reassoc_req_ie_len) +\n\t\tassoc_resp_ie_offset];\n\tassoc_resp_ie_len = le16_to_cpu(data->reassoc_resp_ie_len) -\n\t\tassoc_resp_ie_offset;\n\n\tif (test_bit(wil_status_resetting, wil->status) ||\n\t    !test_bit(wil_status_fwready, wil->status)) {\n\t\twil_err(wil, \"FT: status_resetting, cancel reassoc event\\n\");\n\t\t \n\t\treturn;\n\t}\n\n\tmutex_lock(&wil->mutex);\n\n\t \n\twil_dbg_wmi(wil,\n\t\t    \"ft modify tx config for connection CID %d ring %d\\n\",\n\t\t    cid, ringid);\n\n\trc = wil->txrx_ops.tx_ring_modify(vif, ringid, cid, 0);\n\tif (rc) {\n\t\twil_err(wil, \"modify TX for CID %d MID %d ring %d failed (%d)\\n\",\n\t\t\tcid, vif->mid, ringid, rc);\n\t\tmutex_unlock(&wil->mutex);\n\t\tgoto fail;\n\t}\n\n\t \n\twil->sta[cid].aid = data->aid;\n\twil->sta[cid].stats.ft_roams++;\n\tether_addr_copy(wil->sta[cid].addr, vif->bss->bssid);\n\tmutex_unlock(&wil->mutex);\n\tdel_timer_sync(&vif->connect_timer);\n\n\tcfg80211_ref_bss(wiphy, vif->bss);\n\tfreq = ieee80211_channel_to_frequency(ch, NL80211_BAND_60GHZ);\n\n\tmemset(&info, 0, sizeof(info));\n\tinfo.links[0].channel = ieee80211_get_channel(wiphy, freq);\n\tinfo.links[0].bss = vif->bss;\n\tinfo.req_ie = assoc_req_ie;\n\tinfo.req_ie_len = assoc_req_ie_len;\n\tinfo.resp_ie = assoc_resp_ie;\n\tinfo.resp_ie_len = assoc_resp_ie_len;\n\tcfg80211_roamed(ndev, &info, GFP_KERNEL);\n\tvif->bss = NULL;\n\n\treturn;\n\nfail:\n\twil6210_disconnect(vif, NULL, WLAN_REASON_PREV_AUTH_NOT_VALID);\n}\n\nstatic void\nwmi_evt_link_monitor(struct wil6210_vif *vif, int id, void *d, int len)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tstruct net_device *ndev = vif_to_ndev(vif);\n\tstruct wmi_link_monitor_event *evt = d;\n\tenum nl80211_cqm_rssi_threshold_event event_type;\n\n\tif (len < sizeof(*evt)) {\n\t\twil_err(wil, \"link monitor event too short %d\\n\", len);\n\t\treturn;\n\t}\n\n\twil_dbg_wmi(wil, \"link monitor event, type %d rssi %d (stored %d)\\n\",\n\t\t    evt->type, evt->rssi_level, wil->cqm_rssi_thold);\n\n\tif (evt->type != WMI_LINK_MONITOR_NOTIF_RSSI_THRESHOLD_EVT)\n\t\t \n\t\treturn;\n\n\tevent_type = (evt->rssi_level > wil->cqm_rssi_thold ?\n\t\t      NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH :\n\t\t      NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW);\n\tcfg80211_cqm_rssi_notify(ndev, event_type, evt->rssi_level, GFP_KERNEL);\n}\n\n \nstatic void wmi_evt_ignore(struct wil6210_vif *vif, int id, void *d, int len)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\n\twil_dbg_wmi(wil, \"Ignore event 0x%04x len %d\\n\", id, len);\n}\n\nstatic const struct {\n\tint eventid;\n\tvoid (*handler)(struct wil6210_vif *vif,\n\t\t\tint eventid, void *data, int data_len);\n} wmi_evt_handlers[] = {\n\t{WMI_READY_EVENTID,\t\twmi_evt_ready},\n\t{WMI_FW_READY_EVENTID,\t\t\twmi_evt_ignore},\n\t{WMI_RX_MGMT_PACKET_EVENTID,\twmi_evt_rx_mgmt},\n\t{WMI_TX_MGMT_PACKET_EVENTID,\t\twmi_evt_tx_mgmt},\n\t{WMI_SCAN_COMPLETE_EVENTID,\twmi_evt_scan_complete},\n\t{WMI_CONNECT_EVENTID,\t\twmi_evt_connect},\n\t{WMI_DISCONNECT_EVENTID,\twmi_evt_disconnect},\n\t{WMI_EAPOL_RX_EVENTID,\t\twmi_evt_eapol_rx},\n\t{WMI_BA_STATUS_EVENTID,\t\twmi_evt_ba_status},\n\t{WMI_RCP_ADDBA_REQ_EVENTID,\twmi_evt_addba_rx_req},\n\t{WMI_DELBA_EVENTID,\t\twmi_evt_delba},\n\t{WMI_RING_EN_EVENTID,\t\twmi_evt_ring_en},\n\t{WMI_DATA_PORT_OPEN_EVENTID,\t\twmi_evt_ignore},\n\t{WMI_SCHED_SCAN_RESULT_EVENTID,\t\twmi_evt_sched_scan_result},\n\t{WMI_LINK_STATS_EVENTID,\t\twmi_evt_link_stats},\n\t{WMI_FT_AUTH_STATUS_EVENTID,\t\twmi_evt_auth_status},\n\t{WMI_FT_REASSOC_STATUS_EVENTID,\t\twmi_evt_reassoc_status},\n\t{WMI_LINK_MONITOR_EVENTID,\t\twmi_evt_link_monitor},\n};\n\n \nvoid wmi_recv_cmd(struct wil6210_priv *wil)\n{\n\tstruct wil6210_mbox_ring_desc d_tail;\n\tstruct wil6210_mbox_hdr hdr;\n\tstruct wil6210_mbox_ring *r = &wil->mbox_ctl.rx;\n\tstruct pending_wmi_event *evt;\n\tu8 *cmd;\n\tvoid __iomem *src;\n\tulong flags;\n\tunsigned n;\n\tunsigned int num_immed_reply = 0;\n\n\tif (!test_bit(wil_status_mbox_ready, wil->status)) {\n\t\twil_err(wil, \"Reset in progress. Cannot handle WMI event\\n\");\n\t\treturn;\n\t}\n\n\tif (test_bit(wil_status_suspended, wil->status)) {\n\t\twil_err(wil, \"suspended. cannot handle WMI event\\n\");\n\t\treturn;\n\t}\n\n\tfor (n = 0;; n++) {\n\t\tu16 len;\n\t\tbool q;\n\t\tbool immed_reply = false;\n\n\t\tr->head = wil_r(wil, RGF_MBOX +\n\t\t\t\toffsetof(struct wil6210_mbox_ctl, rx.head));\n\t\tif (r->tail == r->head)\n\t\t\tbreak;\n\n\t\twil_dbg_wmi(wil, \"Mbox head %08x tail %08x\\n\",\n\t\t\t    r->head, r->tail);\n\t\t \n\t\twil_memcpy_fromio_32(&d_tail, wil->csr + HOSTADDR(r->tail),\n\t\t\t\t     sizeof(struct wil6210_mbox_ring_desc));\n\t\tif (d_tail.sync == 0) {\n\t\t\twil_err(wil, \"Mbox evt not owned by FW?\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (0 != wmi_read_hdr(wil, d_tail.addr, &hdr)) {\n\t\t\twil_err(wil, \"Mbox evt at 0x%08x?\\n\",\n\t\t\t\tle32_to_cpu(d_tail.addr));\n\t\t\tbreak;\n\t\t}\n\t\tlen = le16_to_cpu(hdr.len);\n\t\twil_dbg_wmi(wil, \"Mbox evt %04x %04x %04x %02x\\n\",\n\t\t\t    le16_to_cpu(hdr.seq), len, le16_to_cpu(hdr.type),\n\t\t\t    hdr.flags);\n\n\t\t \n\t\tsrc = wmi_buffer(wil, d_tail.addr) +\n\t\t      sizeof(struct wil6210_mbox_hdr);\n\t\tevt = kmalloc(ALIGN(offsetof(struct pending_wmi_event,\n\t\t\t\t\t     event.wmi) + len, 4),\n\t\t\t      GFP_KERNEL);\n\t\tif (!evt)\n\t\t\tbreak;\n\n\t\tevt->event.hdr = hdr;\n\t\tcmd = (void *)&evt->event.wmi;\n\t\twil_memcpy_fromio_32(cmd, src, len);\n\t\t \n\t\twil_w(wil, r->tail +\n\t\t      offsetof(struct wil6210_mbox_ring_desc, sync), 0);\n\t\t \n\t\tif ((hdr.type == WIL_MBOX_HDR_TYPE_WMI) &&\n\t\t    (len >= sizeof(struct wmi_cmd_hdr))) {\n\t\t\tstruct wmi_cmd_hdr *wmi = &evt->event.wmi;\n\t\t\tu16 id = le16_to_cpu(wmi->command_id);\n\t\t\tu8 mid = wmi->mid;\n\t\t\tu32 tstamp = le32_to_cpu(wmi->fw_timestamp);\n\t\t\tif (test_bit(wil_status_resuming, wil->status)) {\n\t\t\t\tif (id == WMI_TRAFFIC_RESUME_EVENTID)\n\t\t\t\t\tclear_bit(wil_status_resuming,\n\t\t\t\t\t\t  wil->status);\n\t\t\t\telse\n\t\t\t\t\twil_err(wil,\n\t\t\t\t\t\t\"WMI evt %d while resuming\\n\",\n\t\t\t\t\t\tid);\n\t\t\t}\n\t\t\tspin_lock_irqsave(&wil->wmi_ev_lock, flags);\n\t\t\tif (wil->reply_id && wil->reply_id == id &&\n\t\t\t    wil->reply_mid == mid) {\n\t\t\t\tif (wil->reply_buf) {\n\t\t\t\t\tmemcpy(wil->reply_buf, wmi,\n\t\t\t\t\t       min(len, wil->reply_size));\n\t\t\t\t\timmed_reply = true;\n\t\t\t\t}\n\t\t\t\tif (id == WMI_TRAFFIC_SUSPEND_EVENTID) {\n\t\t\t\t\twil_dbg_wmi(wil,\n\t\t\t\t\t\t    \"set suspend_resp_rcvd\\n\");\n\t\t\t\t\twil->suspend_resp_rcvd = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&wil->wmi_ev_lock, flags);\n\n\t\t\twil_dbg_wmi(wil, \"recv %s (0x%04x) MID %d @%d msec\\n\",\n\t\t\t\t    eventid2name(id), id, wmi->mid, tstamp);\n\t\t\ttrace_wil6210_wmi_event(wmi, &wmi[1],\n\t\t\t\t\t\tlen - sizeof(*wmi));\n\t\t}\n\t\twil_hex_dump_wmi(\"evt \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t\t &evt->event.hdr, sizeof(hdr) + len, true);\n\n\t\t \n\t\tr->tail = r->base + ((r->tail - r->base +\n\t\t\t  sizeof(struct wil6210_mbox_ring_desc)) % r->size);\n\t\twil_w(wil, RGF_MBOX +\n\t\t      offsetof(struct wil6210_mbox_ctl, rx.tail), r->tail);\n\n\t\tif (immed_reply) {\n\t\t\twil_dbg_wmi(wil, \"recv_cmd: Complete WMI 0x%04x\\n\",\n\t\t\t\t    wil->reply_id);\n\t\t\tkfree(evt);\n\t\t\tnum_immed_reply++;\n\t\t\tcomplete(&wil->wmi_call);\n\t\t} else {\n\t\t\t \n\t\t\tspin_lock_irqsave(&wil->wmi_ev_lock, flags);\n\t\t\tlist_add_tail(&evt->list, &wil->pending_wmi_ev);\n\t\t\tspin_unlock_irqrestore(&wil->wmi_ev_lock, flags);\n\t\t\tq = queue_work(wil->wmi_wq, &wil->wmi_event_worker);\n\t\t\twil_dbg_wmi(wil, \"queue_work -> %d\\n\", q);\n\t\t}\n\t}\n\t \n\twil_dbg_wmi(wil, \"recv_cmd: -> %d events queued, %d completed\\n\",\n\t\t    n - num_immed_reply, num_immed_reply);\n}\n\nint wmi_call(struct wil6210_priv *wil, u16 cmdid, u8 mid, void *buf, u16 len,\n\t     u16 reply_id, void *reply, u16 reply_size, int to_msec)\n{\n\tint rc;\n\tunsigned long remain;\n\tulong flags;\n\n\tmutex_lock(&wil->wmi_mutex);\n\n\tspin_lock_irqsave(&wil->wmi_ev_lock, flags);\n\twil->reply_id = reply_id;\n\twil->reply_mid = mid;\n\twil->reply_buf = reply;\n\twil->reply_size = reply_size;\n\treinit_completion(&wil->wmi_call);\n\tspin_unlock_irqrestore(&wil->wmi_ev_lock, flags);\n\n\trc = __wmi_send(wil, cmdid, mid, buf, len);\n\tif (rc)\n\t\tgoto out;\n\n\tremain = wait_for_completion_timeout(&wil->wmi_call,\n\t\t\t\t\t     msecs_to_jiffies(to_msec));\n\tif (0 == remain) {\n\t\twil_err(wil, \"wmi_call(0x%04x->0x%04x) timeout %d msec\\n\",\n\t\t\tcmdid, reply_id, to_msec);\n\t\trc = -ETIME;\n\t} else {\n\t\twil_dbg_wmi(wil,\n\t\t\t    \"wmi_call(0x%04x->0x%04x) completed in %d msec\\n\",\n\t\t\t    cmdid, reply_id,\n\t\t\t    to_msec - jiffies_to_msecs(remain));\n\t}\n\nout:\n\tspin_lock_irqsave(&wil->wmi_ev_lock, flags);\n\twil->reply_id = 0;\n\twil->reply_mid = U8_MAX;\n\twil->reply_buf = NULL;\n\twil->reply_size = 0;\n\tspin_unlock_irqrestore(&wil->wmi_ev_lock, flags);\n\n\tmutex_unlock(&wil->wmi_mutex);\n\n\treturn rc;\n}\n\nint wmi_echo(struct wil6210_priv *wil)\n{\n\tstruct wil6210_vif *vif = ndev_to_vif(wil->main_ndev);\n\tstruct wmi_echo_cmd cmd = {\n\t\t.value = cpu_to_le32(0x12345678),\n\t};\n\n\treturn wmi_call(wil, WMI_ECHO_CMDID, vif->mid, &cmd, sizeof(cmd),\n\t\t\tWMI_ECHO_RSP_EVENTID, NULL, 0,\n\t\t\tWIL_WMI_CALL_GENERAL_TO_MS);\n}\n\nint wmi_set_mac_address(struct wil6210_priv *wil, const void *addr)\n{\n\tstruct wil6210_vif *vif = ndev_to_vif(wil->main_ndev);\n\tstruct wmi_set_mac_address_cmd cmd;\n\n\tether_addr_copy(cmd.mac, addr);\n\n\twil_dbg_wmi(wil, \"Set MAC %pM\\n\", addr);\n\n\treturn wmi_send(wil, WMI_SET_MAC_ADDRESS_CMDID, vif->mid,\n\t\t\t&cmd, sizeof(cmd));\n}\n\nint wmi_led_cfg(struct wil6210_priv *wil, bool enable)\n{\n\tstruct wil6210_vif *vif = ndev_to_vif(wil->main_ndev);\n\tint rc = 0;\n\tstruct wmi_led_cfg_cmd cmd = {\n\t\t.led_mode = enable,\n\t\t.id = led_id,\n\t\t.slow_blink_cfg.blink_on =\n\t\t\tcpu_to_le32(led_blink_time[WIL_LED_TIME_SLOW].on_ms),\n\t\t.slow_blink_cfg.blink_off =\n\t\t\tcpu_to_le32(led_blink_time[WIL_LED_TIME_SLOW].off_ms),\n\t\t.medium_blink_cfg.blink_on =\n\t\t\tcpu_to_le32(led_blink_time[WIL_LED_TIME_MED].on_ms),\n\t\t.medium_blink_cfg.blink_off =\n\t\t\tcpu_to_le32(led_blink_time[WIL_LED_TIME_MED].off_ms),\n\t\t.fast_blink_cfg.blink_on =\n\t\t\tcpu_to_le32(led_blink_time[WIL_LED_TIME_FAST].on_ms),\n\t\t.fast_blink_cfg.blink_off =\n\t\t\tcpu_to_le32(led_blink_time[WIL_LED_TIME_FAST].off_ms),\n\t\t.led_polarity = led_polarity,\n\t};\n\tstruct {\n\t\tstruct wmi_cmd_hdr wmi;\n\t\tstruct wmi_led_cfg_done_event evt;\n\t} __packed reply = {\n\t\t.evt = {.status = cpu_to_le32(WMI_FW_STATUS_FAILURE)},\n\t};\n\n\tif (led_id == WIL_LED_INVALID_ID)\n\t\tgoto out;\n\n\tif (led_id > WIL_LED_MAX_ID) {\n\t\twil_err(wil, \"Invalid led id %d\\n\", led_id);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\twil_dbg_wmi(wil,\n\t\t    \"%s led %d\\n\",\n\t\t    enable ? \"enabling\" : \"disabling\", led_id);\n\n\trc = wmi_call(wil, WMI_LED_CFG_CMDID, vif->mid, &cmd, sizeof(cmd),\n\t\t      WMI_LED_CFG_DONE_EVENTID, &reply, sizeof(reply),\n\t\t      WIL_WMI_CALL_GENERAL_TO_MS);\n\tif (rc)\n\t\tgoto out;\n\n\tif (reply.evt.status) {\n\t\twil_err(wil, \"led %d cfg failed with status %d\\n\",\n\t\t\tled_id, le32_to_cpu(reply.evt.status));\n\t\trc = -EINVAL;\n\t}\n\nout:\n\treturn rc;\n}\n\nint wmi_rbufcap_cfg(struct wil6210_priv *wil, bool enable, u16 threshold)\n{\n\tstruct wil6210_vif *vif = ndev_to_vif(wil->main_ndev);\n\tint rc;\n\n\tstruct wmi_rbufcap_cfg_cmd cmd = {\n\t\t.enable = enable,\n\t\t.rx_desc_threshold = cpu_to_le16(threshold),\n\t};\n\tstruct {\n\t\tstruct wmi_cmd_hdr wmi;\n\t\tstruct wmi_rbufcap_cfg_event evt;\n\t} __packed reply = {\n\t\t.evt = {.status = WMI_FW_STATUS_FAILURE},\n\t};\n\n\trc = wmi_call(wil, WMI_RBUFCAP_CFG_CMDID, vif->mid, &cmd, sizeof(cmd),\n\t\t      WMI_RBUFCAP_CFG_EVENTID, &reply, sizeof(reply),\n\t\t      WIL_WMI_CALL_GENERAL_TO_MS);\n\tif (rc)\n\t\treturn rc;\n\n\tif (reply.evt.status != WMI_FW_STATUS_SUCCESS) {\n\t\twil_err(wil, \"RBUFCAP_CFG failed. status %d\\n\",\n\t\t\treply.evt.status);\n\t\trc = -EINVAL;\n\t}\n\n\treturn rc;\n}\n\nint wmi_pcp_start(struct wil6210_vif *vif, int bi, u8 wmi_nettype,\n\t\t  u8 chan, u8 wmi_edmg_chan, u8 hidden_ssid, u8 is_go)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tint rc;\n\n\tstruct wmi_pcp_start_cmd cmd = {\n\t\t.bcon_interval = cpu_to_le16(bi),\n\t\t.network_type = wmi_nettype,\n\t\t.disable_sec_offload = 1,\n\t\t.channel = chan - 1,\n\t\t.edmg_channel = wmi_edmg_chan,\n\t\t.pcp_max_assoc_sta = wil->max_assoc_sta,\n\t\t.hidden_ssid = hidden_ssid,\n\t\t.is_go = is_go,\n\t\t.ap_sme_offload_mode = disable_ap_sme ?\n\t\t\t\t       WMI_AP_SME_OFFLOAD_PARTIAL :\n\t\t\t\t       WMI_AP_SME_OFFLOAD_FULL,\n\t\t.abft_len = wil->abft_len,\n\t};\n\tstruct {\n\t\tstruct wmi_cmd_hdr wmi;\n\t\tstruct wmi_pcp_started_event evt;\n\t} __packed reply = {\n\t\t.evt = {.status = WMI_FW_STATUS_FAILURE},\n\t};\n\n\tif (!vif->privacy)\n\t\tcmd.disable_sec = 1;\n\n\tif ((cmd.pcp_max_assoc_sta > WIL6210_MAX_CID) ||\n\t    (cmd.pcp_max_assoc_sta <= 0)) {\n\t\twil_err(wil, \"unexpected max_assoc_sta %d\\n\",\n\t\t\tcmd.pcp_max_assoc_sta);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (disable_ap_sme &&\n\t    !test_bit(WMI_FW_CAPABILITY_AP_SME_OFFLOAD_PARTIAL,\n\t\t      wil->fw_capabilities)) {\n\t\twil_err(wil, \"disable_ap_sme not supported by FW\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\trc = wmi_call(wil, WMI_PCP_START_CMDID, vif->mid, &cmd, sizeof(cmd),\n\t\t      WMI_PCP_STARTED_EVENTID, &reply, sizeof(reply), 5000);\n\tif (rc)\n\t\treturn rc;\n\n\tif (reply.evt.status != WMI_FW_STATUS_SUCCESS)\n\t\trc = -EINVAL;\n\n\tif (wmi_nettype != WMI_NETTYPE_P2P)\n\t\t \n\t\twmi_led_cfg(wil, true);\n\n\treturn rc;\n}\n\nint wmi_pcp_stop(struct wil6210_vif *vif)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tint rc;\n\n\trc = wmi_led_cfg(wil, false);\n\tif (rc)\n\t\treturn rc;\n\n\treturn wmi_call(wil, WMI_PCP_STOP_CMDID, vif->mid, NULL, 0,\n\t\t\tWMI_PCP_STOPPED_EVENTID, NULL, 0,\n\t\t\tWIL_WMI_PCP_STOP_TO_MS);\n}\n\nint wmi_set_ssid(struct wil6210_vif *vif, u8 ssid_len, const void *ssid)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tstruct wmi_set_ssid_cmd cmd = {\n\t\t.ssid_len = cpu_to_le32(ssid_len),\n\t};\n\n\tif (ssid_len > sizeof(cmd.ssid))\n\t\treturn -EINVAL;\n\n\tmemcpy(cmd.ssid, ssid, ssid_len);\n\n\treturn wmi_send(wil, WMI_SET_SSID_CMDID, vif->mid, &cmd, sizeof(cmd));\n}\n\nint wmi_get_ssid(struct wil6210_vif *vif, u8 *ssid_len, void *ssid)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tint rc;\n\tstruct {\n\t\tstruct wmi_cmd_hdr wmi;\n\t\tstruct wmi_set_ssid_cmd cmd;\n\t} __packed reply;\n\tint len;  \n\n\tmemset(&reply, 0, sizeof(reply));\n\n\trc = wmi_call(wil, WMI_GET_SSID_CMDID, vif->mid, NULL, 0,\n\t\t      WMI_GET_SSID_EVENTID, &reply, sizeof(reply),\n\t\t      WIL_WMI_CALL_GENERAL_TO_MS);\n\tif (rc)\n\t\treturn rc;\n\n\tlen = le32_to_cpu(reply.cmd.ssid_len);\n\tif (len > sizeof(reply.cmd.ssid))\n\t\treturn -EINVAL;\n\n\t*ssid_len = len;\n\tmemcpy(ssid, reply.cmd.ssid, len);\n\n\treturn 0;\n}\n\nint wmi_set_channel(struct wil6210_priv *wil, int channel)\n{\n\tstruct wil6210_vif *vif = ndev_to_vif(wil->main_ndev);\n\tstruct wmi_set_pcp_channel_cmd cmd = {\n\t\t.channel = channel - 1,\n\t};\n\n\treturn wmi_send(wil, WMI_SET_PCP_CHANNEL_CMDID, vif->mid,\n\t\t\t&cmd, sizeof(cmd));\n}\n\nint wmi_get_channel(struct wil6210_priv *wil, int *channel)\n{\n\tstruct wil6210_vif *vif = ndev_to_vif(wil->main_ndev);\n\tint rc;\n\tstruct {\n\t\tstruct wmi_cmd_hdr wmi;\n\t\tstruct wmi_set_pcp_channel_cmd cmd;\n\t} __packed reply;\n\n\tmemset(&reply, 0, sizeof(reply));\n\n\trc = wmi_call(wil, WMI_GET_PCP_CHANNEL_CMDID, vif->mid, NULL, 0,\n\t\t      WMI_GET_PCP_CHANNEL_EVENTID, &reply, sizeof(reply),\n\t\t      WIL_WMI_CALL_GENERAL_TO_MS);\n\tif (rc)\n\t\treturn rc;\n\n\tif (reply.cmd.channel > 3)\n\t\treturn -EINVAL;\n\n\t*channel = reply.cmd.channel + 1;\n\n\treturn 0;\n}\n\nint wmi_p2p_cfg(struct wil6210_vif *vif, int channel, int bi)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tint rc;\n\tstruct wmi_p2p_cfg_cmd cmd = {\n\t\t.discovery_mode = WMI_DISCOVERY_MODE_PEER2PEER,\n\t\t.bcon_interval = cpu_to_le16(bi),\n\t\t.channel = channel - 1,\n\t};\n\tstruct {\n\t\tstruct wmi_cmd_hdr wmi;\n\t\tstruct wmi_p2p_cfg_done_event evt;\n\t} __packed reply = {\n\t\t.evt = {.status = WMI_FW_STATUS_FAILURE},\n\t};\n\n\twil_dbg_wmi(wil, \"sending WMI_P2P_CFG_CMDID\\n\");\n\n\trc = wmi_call(wil, WMI_P2P_CFG_CMDID, vif->mid, &cmd, sizeof(cmd),\n\t\t      WMI_P2P_CFG_DONE_EVENTID, &reply, sizeof(reply), 300);\n\tif (!rc && reply.evt.status != WMI_FW_STATUS_SUCCESS) {\n\t\twil_err(wil, \"P2P_CFG failed. status %d\\n\", reply.evt.status);\n\t\trc = -EINVAL;\n\t}\n\n\treturn rc;\n}\n\nint wmi_start_listen(struct wil6210_vif *vif)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tint rc;\n\tstruct {\n\t\tstruct wmi_cmd_hdr wmi;\n\t\tstruct wmi_listen_started_event evt;\n\t} __packed reply = {\n\t\t.evt = {.status = WMI_FW_STATUS_FAILURE},\n\t};\n\n\twil_dbg_wmi(wil, \"sending WMI_START_LISTEN_CMDID\\n\");\n\n\trc = wmi_call(wil, WMI_START_LISTEN_CMDID, vif->mid, NULL, 0,\n\t\t      WMI_LISTEN_STARTED_EVENTID, &reply, sizeof(reply), 300);\n\tif (!rc && reply.evt.status != WMI_FW_STATUS_SUCCESS) {\n\t\twil_err(wil, \"device failed to start listen. status %d\\n\",\n\t\t\treply.evt.status);\n\t\trc = -EINVAL;\n\t}\n\n\treturn rc;\n}\n\nint wmi_start_search(struct wil6210_vif *vif)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tint rc;\n\tstruct {\n\t\tstruct wmi_cmd_hdr wmi;\n\t\tstruct wmi_search_started_event evt;\n\t} __packed reply = {\n\t\t.evt = {.status = WMI_FW_STATUS_FAILURE},\n\t};\n\n\twil_dbg_wmi(wil, \"sending WMI_START_SEARCH_CMDID\\n\");\n\n\trc = wmi_call(wil, WMI_START_SEARCH_CMDID, vif->mid, NULL, 0,\n\t\t      WMI_SEARCH_STARTED_EVENTID, &reply, sizeof(reply), 300);\n\tif (!rc && reply.evt.status != WMI_FW_STATUS_SUCCESS) {\n\t\twil_err(wil, \"device failed to start search. status %d\\n\",\n\t\t\treply.evt.status);\n\t\trc = -EINVAL;\n\t}\n\n\treturn rc;\n}\n\nint wmi_stop_discovery(struct wil6210_vif *vif)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tint rc;\n\n\twil_dbg_wmi(wil, \"sending WMI_DISCOVERY_STOP_CMDID\\n\");\n\n\trc = wmi_call(wil, WMI_DISCOVERY_STOP_CMDID, vif->mid, NULL, 0,\n\t\t      WMI_DISCOVERY_STOPPED_EVENTID, NULL, 0,\n\t\t      WIL_WMI_CALL_GENERAL_TO_MS);\n\n\tif (rc)\n\t\twil_err(wil, \"Failed to stop discovery\\n\");\n\n\treturn rc;\n}\n\nint wmi_del_cipher_key(struct wil6210_vif *vif, u8 key_index,\n\t\t       const void *mac_addr, int key_usage)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tstruct wmi_delete_cipher_key_cmd cmd = {\n\t\t.key_index = key_index,\n\t};\n\n\tif (mac_addr)\n\t\tmemcpy(cmd.mac, mac_addr, WMI_MAC_LEN);\n\n\treturn wmi_send(wil, WMI_DELETE_CIPHER_KEY_CMDID, vif->mid,\n\t\t\t&cmd, sizeof(cmd));\n}\n\nint wmi_add_cipher_key(struct wil6210_vif *vif, u8 key_index,\n\t\t       const void *mac_addr, int key_len, const void *key,\n\t\t       int key_usage)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tstruct wmi_add_cipher_key_cmd cmd = {\n\t\t.key_index = key_index,\n\t\t.key_usage = key_usage,\n\t\t.key_len = key_len,\n\t};\n\n\tif (key_len > sizeof(cmd.key))\n\t\treturn -EINVAL;\n\n\t \n\tif ((key_len == 0 || !key) &&\n\t    key_usage != WMI_KEY_USE_APPLY_PTK)\n\t\treturn -EINVAL;\n\n\tif (key)\n\t\tmemcpy(cmd.key, key, key_len);\n\n\tif (mac_addr)\n\t\tmemcpy(cmd.mac, mac_addr, WMI_MAC_LEN);\n\n\treturn wmi_send(wil, WMI_ADD_CIPHER_KEY_CMDID, vif->mid,\n\t\t\t&cmd, sizeof(cmd));\n}\n\nint wmi_set_ie(struct wil6210_vif *vif, u8 type, u16 ie_len, const void *ie)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tstatic const char *const names[] = {\n\t\t[WMI_FRAME_BEACON]\t= \"BEACON\",\n\t\t[WMI_FRAME_PROBE_REQ]\t= \"PROBE_REQ\",\n\t\t[WMI_FRAME_PROBE_RESP]\t= \"WMI_FRAME_PROBE_RESP\",\n\t\t[WMI_FRAME_ASSOC_REQ]\t= \"WMI_FRAME_ASSOC_REQ\",\n\t\t[WMI_FRAME_ASSOC_RESP]\t= \"WMI_FRAME_ASSOC_RESP\",\n\t};\n\tint rc;\n\tu16 len = sizeof(struct wmi_set_appie_cmd) + ie_len;\n\tstruct wmi_set_appie_cmd *cmd;\n\n\tif (len < ie_len) {\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tcmd = kzalloc(len, GFP_KERNEL);\n\tif (!cmd) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tif (!ie)\n\t\tie_len = 0;\n\n\tcmd->mgmt_frm_type = type;\n\t \n\tcmd->ie_len = cpu_to_le16(ie_len);\n\tif (ie_len)\n\t\tmemcpy(cmd->ie_info, ie, ie_len);\n\trc = wmi_send(wil, WMI_SET_APPIE_CMDID, vif->mid, cmd, len);\n\tkfree(cmd);\nout:\n\tif (rc) {\n\t\tconst char *name = type < ARRAY_SIZE(names) ?\n\t\t\t\t   names[type] : \"??\";\n\t\twil_err(wil, \"set_ie(%d %s) failed : %d\\n\", type, name, rc);\n\t}\n\n\treturn rc;\n}\n\nint wmi_update_ft_ies(struct wil6210_vif *vif, u16 ie_len, const void *ie)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tu16 len;\n\tstruct wmi_update_ft_ies_cmd *cmd;\n\tint rc;\n\n\tif (!ie)\n\t\tie_len = 0;\n\n\tlen = sizeof(struct wmi_update_ft_ies_cmd) + ie_len;\n\tif (len < ie_len) {\n\t\twil_err(wil, \"wraparound. ie len %d\\n\", ie_len);\n\t\treturn -EINVAL;\n\t}\n\n\tcmd = kzalloc(len, GFP_KERNEL);\n\tif (!cmd) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tcmd->ie_len = cpu_to_le16(ie_len);\n\tif (ie_len)\n\t\tmemcpy(cmd->ie_info, ie, ie_len);\n\trc = wmi_send(wil, WMI_UPDATE_FT_IES_CMDID, vif->mid, cmd, len);\n\tkfree(cmd);\n\nout:\n\tif (rc)\n\t\twil_err(wil, \"update ft ies failed : %d\\n\", rc);\n\n\treturn rc;\n}\n\n \nint wmi_rxon(struct wil6210_priv *wil, bool on)\n{\n\tstruct wil6210_vif *vif = ndev_to_vif(wil->main_ndev);\n\tint rc;\n\tstruct {\n\t\tstruct wmi_cmd_hdr wmi;\n\t\tstruct wmi_listen_started_event evt;\n\t} __packed reply = {\n\t\t.evt = {.status = WMI_FW_STATUS_FAILURE},\n\t};\n\n\twil_info(wil, \"(%s)\\n\", on ? \"on\" : \"off\");\n\n\tif (on) {\n\t\trc = wmi_call(wil, WMI_START_LISTEN_CMDID, vif->mid, NULL, 0,\n\t\t\t      WMI_LISTEN_STARTED_EVENTID,\n\t\t\t      &reply, sizeof(reply),\n\t\t\t      WIL_WMI_CALL_GENERAL_TO_MS);\n\t\tif ((rc == 0) && (reply.evt.status != WMI_FW_STATUS_SUCCESS))\n\t\t\trc = -EINVAL;\n\t} else {\n\t\trc = wmi_call(wil, WMI_DISCOVERY_STOP_CMDID, vif->mid, NULL, 0,\n\t\t\t      WMI_DISCOVERY_STOPPED_EVENTID, NULL, 0,\n\t\t\t      WIL_WMI_CALL_GENERAL_TO_MS);\n\t}\n\n\treturn rc;\n}\n\nint wmi_rx_chain_add(struct wil6210_priv *wil, struct wil_ring *vring)\n{\n\tstruct net_device *ndev = wil->main_ndev;\n\tstruct wireless_dev *wdev = ndev->ieee80211_ptr;\n\tstruct wil6210_vif *vif = ndev_to_vif(ndev);\n\tstruct wmi_cfg_rx_chain_cmd cmd = {\n\t\t.action = WMI_RX_CHAIN_ADD,\n\t\t.rx_sw_ring = {\n\t\t\t.max_mpdu_size = cpu_to_le16(\n\t\t\t\twil_mtu2macbuf(wil->rx_buf_len)),\n\t\t\t.ring_mem_base = cpu_to_le64(vring->pa),\n\t\t\t.ring_size = cpu_to_le16(vring->size),\n\t\t},\n\t\t.mid = 0,  \n\t\t.decap_trans_type = WMI_DECAP_TYPE_802_3,\n\t\t.reorder_type = WMI_RX_SW_REORDER,\n\t\t.host_thrsh = cpu_to_le16(rx_ring_overflow_thrsh),\n\t};\n\tstruct {\n\t\tstruct wmi_cmd_hdr wmi;\n\t\tstruct wmi_cfg_rx_chain_done_event evt;\n\t} __packed evt;\n\tint rc;\n\n\tmemset(&evt, 0, sizeof(evt));\n\n\tif (wdev->iftype == NL80211_IFTYPE_MONITOR) {\n\t\tstruct ieee80211_channel *ch = wil->monitor_chandef.chan;\n\n\t\tcmd.sniffer_cfg.mode = cpu_to_le32(WMI_SNIFFER_ON);\n\t\tif (ch)\n\t\t\tcmd.sniffer_cfg.channel = ch->hw_value - 1;\n\t\tcmd.sniffer_cfg.phy_info_mode =\n\t\t\tcpu_to_le32(WMI_SNIFFER_PHY_INFO_DISABLED);\n\t\tcmd.sniffer_cfg.phy_support =\n\t\t\tcpu_to_le32((wil->monitor_flags & MONITOR_FLAG_CONTROL)\n\t\t\t\t    ? WMI_SNIFFER_CP : WMI_SNIFFER_BOTH_PHYS);\n\t} else {\n\t\t \n\t\tcmd.l3_l4_ctrl |= (1 << L3_L4_CTRL_TCPIP_CHECKSUM_EN_POS);\n\t}\n\n\tif (rx_align_2)\n\t\tcmd.l2_802_3_offload_ctrl |=\n\t\t\t\tL2_802_3_OFFLOAD_CTRL_SNAP_KEEP_MSK;\n\n\t \n\trc = wmi_call(wil, WMI_CFG_RX_CHAIN_CMDID, vif->mid, &cmd, sizeof(cmd),\n\t\t      WMI_CFG_RX_CHAIN_DONE_EVENTID, &evt, sizeof(evt), 2000);\n\tif (rc)\n\t\treturn rc;\n\n\tif (le32_to_cpu(evt.evt.status) != WMI_CFG_RX_CHAIN_SUCCESS)\n\t\trc = -EINVAL;\n\n\tvring->hwtail = le32_to_cpu(evt.evt.rx_ring_tail_ptr);\n\n\twil_dbg_misc(wil, \"Rx init: status %d tail 0x%08x\\n\",\n\t\t     le32_to_cpu(evt.evt.status), vring->hwtail);\n\n\treturn rc;\n}\n\nint wmi_get_temperature(struct wil6210_priv *wil, u32 *t_bb, u32 *t_rf)\n{\n\tstruct wil6210_vif *vif = ndev_to_vif(wil->main_ndev);\n\tint rc;\n\tstruct wmi_temp_sense_cmd cmd = {\n\t\t.measure_baseband_en = cpu_to_le32(!!t_bb),\n\t\t.measure_rf_en = cpu_to_le32(!!t_rf),\n\t\t.measure_mode = cpu_to_le32(TEMPERATURE_MEASURE_NOW),\n\t};\n\tstruct {\n\t\tstruct wmi_cmd_hdr wmi;\n\t\tstruct wmi_temp_sense_done_event evt;\n\t} __packed reply;\n\n\tmemset(&reply, 0, sizeof(reply));\n\n\trc = wmi_call(wil, WMI_TEMP_SENSE_CMDID, vif->mid, &cmd, sizeof(cmd),\n\t\t      WMI_TEMP_SENSE_DONE_EVENTID, &reply, sizeof(reply),\n\t\t      WIL_WMI_CALL_GENERAL_TO_MS);\n\tif (rc)\n\t\treturn rc;\n\n\tif (t_bb)\n\t\t*t_bb = le32_to_cpu(reply.evt.baseband_t1000);\n\tif (t_rf)\n\t\t*t_rf = le32_to_cpu(reply.evt.rf_t1000);\n\n\treturn 0;\n}\n\nint wmi_get_all_temperatures(struct wil6210_priv *wil,\n\t\t\t     struct wmi_temp_sense_all_done_event\n\t\t\t     *sense_all_evt)\n{\n\tstruct wil6210_vif *vif = ndev_to_vif(wil->main_ndev);\n\tint rc;\n\tstruct wmi_temp_sense_all_cmd cmd = {\n\t\t.measure_baseband_en = true,\n\t\t.measure_rf_en = true,\n\t\t.measure_mode = TEMPERATURE_MEASURE_NOW,\n\t};\n\tstruct {\n\t\tstruct wmi_cmd_hdr wmi;\n\t\tstruct wmi_temp_sense_all_done_event evt;\n\t} __packed reply;\n\n\tif (!sense_all_evt) {\n\t\twil_err(wil, \"Invalid sense_all_evt value\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemset(&reply, 0, sizeof(reply));\n\treply.evt.status = WMI_FW_STATUS_FAILURE;\n\trc = wmi_call(wil, WMI_TEMP_SENSE_ALL_CMDID, vif->mid, &cmd,\n\t\t      sizeof(cmd), WMI_TEMP_SENSE_ALL_DONE_EVENTID,\n\t\t      &reply, sizeof(reply), WIL_WMI_CALL_GENERAL_TO_MS);\n\tif (rc)\n\t\treturn rc;\n\n\tif (reply.evt.status == WMI_FW_STATUS_FAILURE) {\n\t\twil_err(wil, \"Failed getting TEMP_SENSE_ALL\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(sense_all_evt, &reply.evt, sizeof(reply.evt));\n\treturn 0;\n}\n\nint wmi_disconnect_sta(struct wil6210_vif *vif, const u8 *mac, u16 reason,\n\t\t       bool del_sta)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tint rc;\n\tstruct wmi_disconnect_sta_cmd disc_sta_cmd = {\n\t\t.disconnect_reason = cpu_to_le16(reason),\n\t};\n\tstruct wmi_del_sta_cmd del_sta_cmd = {\n\t\t.disconnect_reason = cpu_to_le16(reason),\n\t};\n\tstruct {\n\t\tstruct wmi_cmd_hdr wmi;\n\t\tstruct wmi_disconnect_event evt;\n\t} __packed reply;\n\n\twil_dbg_wmi(wil, \"disconnect_sta: (%pM, reason %d)\\n\", mac, reason);\n\n\tmemset(&reply, 0, sizeof(reply));\n\tvif->locally_generated_disc = true;\n\tif (del_sta) {\n\t\tether_addr_copy(del_sta_cmd.dst_mac, mac);\n\t\trc = wmi_call(wil, WMI_DEL_STA_CMDID, vif->mid, &del_sta_cmd,\n\t\t\t      sizeof(del_sta_cmd), WMI_DISCONNECT_EVENTID,\n\t\t\t      &reply, sizeof(reply), 1000);\n\t} else {\n\t\tether_addr_copy(disc_sta_cmd.dst_mac, mac);\n\t\trc = wmi_call(wil, WMI_DISCONNECT_STA_CMDID, vif->mid,\n\t\t\t      &disc_sta_cmd, sizeof(disc_sta_cmd),\n\t\t\t      WMI_DISCONNECT_EVENTID,\n\t\t\t      &reply, sizeof(reply), 1000);\n\t}\n\t \n\tif (rc) {\n\t\twil_fw_error_recovery(wil);\n\t\treturn rc;\n\t}\n\twil->sinfo_gen++;\n\n\treturn 0;\n}\n\nint wmi_addba(struct wil6210_priv *wil, u8 mid,\n\t      u8 ringid, u8 size, u16 timeout)\n{\n\tu8 amsdu = wil->use_enhanced_dma_hw && wil->use_rx_hw_reordering &&\n\t\ttest_bit(WMI_FW_CAPABILITY_AMSDU, wil->fw_capabilities) &&\n\t\twil->amsdu_en;\n\tstruct wmi_ring_ba_en_cmd cmd = {\n\t\t.ring_id = ringid,\n\t\t.agg_max_wsize = size,\n\t\t.ba_timeout = cpu_to_le16(timeout),\n\t\t.amsdu = amsdu,\n\t};\n\n\twil_dbg_wmi(wil, \"addba: (ring %d size %d timeout %d amsdu %d)\\n\",\n\t\t    ringid, size, timeout, amsdu);\n\n\treturn wmi_send(wil, WMI_RING_BA_EN_CMDID, mid, &cmd, sizeof(cmd));\n}\n\nint wmi_delba_tx(struct wil6210_priv *wil, u8 mid, u8 ringid, u16 reason)\n{\n\tstruct wmi_ring_ba_dis_cmd cmd = {\n\t\t.ring_id = ringid,\n\t\t.reason = cpu_to_le16(reason),\n\t};\n\n\twil_dbg_wmi(wil, \"delba_tx: (ring %d reason %d)\\n\", ringid, reason);\n\n\treturn wmi_send(wil, WMI_RING_BA_DIS_CMDID, mid, &cmd, sizeof(cmd));\n}\n\nint wmi_delba_rx(struct wil6210_priv *wil, u8 mid, u8 cid, u8 tid, u16 reason)\n{\n\tstruct wmi_rcp_delba_cmd cmd = {\n\t\t.reason = cpu_to_le16(reason),\n\t};\n\n\tif (cid >= WIL6210_RX_DESC_MAX_CID) {\n\t\tcmd.cidxtid = CIDXTID_EXTENDED_CID_TID;\n\t\tcmd.cid = cid;\n\t\tcmd.tid = tid;\n\t} else {\n\t\tcmd.cidxtid = mk_cidxtid(cid, tid);\n\t}\n\n\twil_dbg_wmi(wil, \"delba_rx: (CID %d TID %d reason %d)\\n\", cid,\n\t\t    tid, reason);\n\n\treturn wmi_send(wil, WMI_RCP_DELBA_CMDID, mid, &cmd, sizeof(cmd));\n}\n\nint wmi_addba_rx_resp(struct wil6210_priv *wil,\n\t\t      u8 mid, u8 cid, u8 tid, u8 token,\n\t\t      u16 status, bool amsdu, u16 agg_wsize, u16 timeout)\n{\n\tint rc;\n\tstruct wmi_rcp_addba_resp_cmd cmd = {\n\t\t.dialog_token = token,\n\t\t.status_code = cpu_to_le16(status),\n\t\t \n\t\t.ba_param_set = cpu_to_le16((amsdu ? 1 : 0) | (tid << 2) |\n\t\t\t\t\t    (agg_wsize << 6)),\n\t\t.ba_timeout = cpu_to_le16(timeout),\n\t};\n\tstruct {\n\t\tstruct wmi_cmd_hdr wmi;\n\t\tstruct wmi_rcp_addba_resp_sent_event evt;\n\t} __packed reply = {\n\t\t.evt = {.status = cpu_to_le16(WMI_FW_STATUS_FAILURE)},\n\t};\n\n\tif (cid >= WIL6210_RX_DESC_MAX_CID) {\n\t\tcmd.cidxtid = CIDXTID_EXTENDED_CID_TID;\n\t\tcmd.cid = cid;\n\t\tcmd.tid = tid;\n\t} else {\n\t\tcmd.cidxtid = mk_cidxtid(cid, tid);\n\t}\n\n\twil_dbg_wmi(wil,\n\t\t    \"ADDBA response for MID %d CID %d TID %d size %d timeout %d status %d AMSDU%s\\n\",\n\t\t    mid, cid, tid, agg_wsize,\n\t\t    timeout, status, amsdu ? \"+\" : \"-\");\n\n\trc = wmi_call(wil, WMI_RCP_ADDBA_RESP_CMDID, mid, &cmd, sizeof(cmd),\n\t\t      WMI_RCP_ADDBA_RESP_SENT_EVENTID, &reply, sizeof(reply),\n\t\t      WIL_WMI_CALL_GENERAL_TO_MS);\n\tif (rc)\n\t\treturn rc;\n\n\tif (reply.evt.status) {\n\t\twil_err(wil, \"ADDBA response failed with status %d\\n\",\n\t\t\tle16_to_cpu(reply.evt.status));\n\t\trc = -EINVAL;\n\t}\n\n\treturn rc;\n}\n\nint wmi_addba_rx_resp_edma(struct wil6210_priv *wil, u8 mid, u8 cid, u8 tid,\n\t\t\t   u8 token, u16 status, bool amsdu, u16 agg_wsize,\n\t\t\t   u16 timeout)\n{\n\tint rc;\n\tstruct wmi_rcp_addba_resp_edma_cmd cmd = {\n\t\t.cid = cid,\n\t\t.tid = tid,\n\t\t.dialog_token = token,\n\t\t.status_code = cpu_to_le16(status),\n\t\t \n\t\t.ba_param_set = cpu_to_le16((amsdu ? 1 : 0) | (tid << 2) |\n\t\t\t\t\t    (agg_wsize << 6)),\n\t\t.ba_timeout = cpu_to_le16(timeout),\n\t\t \n\t\t.status_ring_id = WIL_DEFAULT_RX_STATUS_RING_ID,\n\t};\n\tstruct {\n\t\tstruct wmi_cmd_hdr wmi;\n\t\tstruct wmi_rcp_addba_resp_sent_event evt;\n\t} __packed reply = {\n\t\t.evt = {.status = cpu_to_le16(WMI_FW_STATUS_FAILURE)},\n\t};\n\n\twil_dbg_wmi(wil,\n\t\t    \"ADDBA response for CID %d TID %d size %d timeout %d status %d AMSDU%s, sring_id %d\\n\",\n\t\t    cid, tid, agg_wsize, timeout, status, amsdu ? \"+\" : \"-\",\n\t\t    WIL_DEFAULT_RX_STATUS_RING_ID);\n\n\trc = wmi_call(wil, WMI_RCP_ADDBA_RESP_EDMA_CMDID, mid, &cmd,\n\t\t      sizeof(cmd), WMI_RCP_ADDBA_RESP_SENT_EVENTID, &reply,\n\t\t      sizeof(reply), WIL_WMI_CALL_GENERAL_TO_MS);\n\tif (rc)\n\t\treturn rc;\n\n\tif (reply.evt.status) {\n\t\twil_err(wil, \"ADDBA response failed with status %d\\n\",\n\t\t\tle16_to_cpu(reply.evt.status));\n\t\trc = -EINVAL;\n\t}\n\n\treturn rc;\n}\n\nint wmi_ps_dev_profile_cfg(struct wil6210_priv *wil,\n\t\t\t   enum wmi_ps_profile_type ps_profile)\n{\n\tstruct wil6210_vif *vif = ndev_to_vif(wil->main_ndev);\n\tint rc;\n\tstruct wmi_ps_dev_profile_cfg_cmd cmd = {\n\t\t.ps_profile = ps_profile,\n\t};\n\tstruct {\n\t\tstruct wmi_cmd_hdr wmi;\n\t\tstruct wmi_ps_dev_profile_cfg_event evt;\n\t} __packed reply = {\n\t\t.evt = {.status = cpu_to_le32(WMI_PS_CFG_CMD_STATUS_ERROR)},\n\t};\n\tu32 status;\n\n\twil_dbg_wmi(wil, \"Setting ps dev profile %d\\n\", ps_profile);\n\n\trc = wmi_call(wil, WMI_PS_DEV_PROFILE_CFG_CMDID, vif->mid,\n\t\t      &cmd, sizeof(cmd),\n\t\t      WMI_PS_DEV_PROFILE_CFG_EVENTID, &reply, sizeof(reply),\n\t\t      WIL_WMI_CALL_GENERAL_TO_MS);\n\tif (rc)\n\t\treturn rc;\n\n\tstatus = le32_to_cpu(reply.evt.status);\n\n\tif (status != WMI_PS_CFG_CMD_STATUS_SUCCESS) {\n\t\twil_err(wil, \"ps dev profile cfg failed with status %d\\n\",\n\t\t\tstatus);\n\t\trc = -EINVAL;\n\t}\n\n\treturn rc;\n}\n\nint wmi_set_mgmt_retry(struct wil6210_priv *wil, u8 retry_short)\n{\n\tstruct wil6210_vif *vif = ndev_to_vif(wil->main_ndev);\n\tint rc;\n\tstruct wmi_set_mgmt_retry_limit_cmd cmd = {\n\t\t.mgmt_retry_limit = retry_short,\n\t};\n\tstruct {\n\t\tstruct wmi_cmd_hdr wmi;\n\t\tstruct wmi_set_mgmt_retry_limit_event evt;\n\t} __packed reply = {\n\t\t.evt = {.status = WMI_FW_STATUS_FAILURE},\n\t};\n\n\twil_dbg_wmi(wil, \"Setting mgmt retry short %d\\n\", retry_short);\n\n\tif (!test_bit(WMI_FW_CAPABILITY_MGMT_RETRY_LIMIT, wil->fw_capabilities))\n\t\treturn -ENOTSUPP;\n\n\trc = wmi_call(wil, WMI_SET_MGMT_RETRY_LIMIT_CMDID, vif->mid,\n\t\t      &cmd, sizeof(cmd),\n\t\t      WMI_SET_MGMT_RETRY_LIMIT_EVENTID, &reply, sizeof(reply),\n\t\t      WIL_WMI_CALL_GENERAL_TO_MS);\n\tif (rc)\n\t\treturn rc;\n\n\tif (reply.evt.status != WMI_FW_STATUS_SUCCESS) {\n\t\twil_err(wil, \"set mgmt retry limit failed with status %d\\n\",\n\t\t\treply.evt.status);\n\t\trc = -EINVAL;\n\t}\n\n\treturn rc;\n}\n\nint wmi_get_mgmt_retry(struct wil6210_priv *wil, u8 *retry_short)\n{\n\tstruct wil6210_vif *vif = ndev_to_vif(wil->main_ndev);\n\tint rc;\n\tstruct {\n\t\tstruct wmi_cmd_hdr wmi;\n\t\tstruct wmi_get_mgmt_retry_limit_event evt;\n\t} __packed reply;\n\n\twil_dbg_wmi(wil, \"getting mgmt retry short\\n\");\n\n\tif (!test_bit(WMI_FW_CAPABILITY_MGMT_RETRY_LIMIT, wil->fw_capabilities))\n\t\treturn -ENOTSUPP;\n\n\tmemset(&reply, 0, sizeof(reply));\n\trc = wmi_call(wil, WMI_GET_MGMT_RETRY_LIMIT_CMDID, vif->mid, NULL, 0,\n\t\t      WMI_GET_MGMT_RETRY_LIMIT_EVENTID, &reply, sizeof(reply),\n\t\t      WIL_WMI_CALL_GENERAL_TO_MS);\n\tif (rc)\n\t\treturn rc;\n\n\tif (retry_short)\n\t\t*retry_short = reply.evt.mgmt_retry_limit;\n\n\treturn 0;\n}\n\nint wmi_abort_scan(struct wil6210_vif *vif)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tint rc;\n\n\twil_dbg_wmi(wil, \"sending WMI_ABORT_SCAN_CMDID\\n\");\n\n\trc = wmi_send(wil, WMI_ABORT_SCAN_CMDID, vif->mid, NULL, 0);\n\tif (rc)\n\t\twil_err(wil, \"Failed to abort scan (%d)\\n\", rc);\n\n\treturn rc;\n}\n\nint wmi_new_sta(struct wil6210_vif *vif, const u8 *mac, u8 aid)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tint rc;\n\tstruct wmi_new_sta_cmd cmd = {\n\t\t.aid = aid,\n\t};\n\n\twil_dbg_wmi(wil, \"new sta %pM, aid %d\\n\", mac, aid);\n\n\tether_addr_copy(cmd.dst_mac, mac);\n\n\trc = wmi_send(wil, WMI_NEW_STA_CMDID, vif->mid, &cmd, sizeof(cmd));\n\tif (rc)\n\t\twil_err(wil, \"Failed to send new sta (%d)\\n\", rc);\n\n\treturn rc;\n}\n\nvoid wmi_event_flush(struct wil6210_priv *wil)\n{\n\tulong flags;\n\tstruct pending_wmi_event *evt, *t;\n\n\twil_dbg_wmi(wil, \"event_flush\\n\");\n\n\tspin_lock_irqsave(&wil->wmi_ev_lock, flags);\n\n\tlist_for_each_entry_safe(evt, t, &wil->pending_wmi_ev, list) {\n\t\tlist_del(&evt->list);\n\t\tkfree(evt);\n\t}\n\n\tspin_unlock_irqrestore(&wil->wmi_ev_lock, flags);\n}\n\nstatic const char *suspend_status2name(u8 status)\n{\n\tswitch (status) {\n\tcase WMI_TRAFFIC_SUSPEND_REJECTED_LINK_NOT_IDLE:\n\t\treturn \"LINK_NOT_IDLE\";\n\tcase WMI_TRAFFIC_SUSPEND_REJECTED_DISCONNECT:\n\t\treturn \"DISCONNECT\";\n\tcase WMI_TRAFFIC_SUSPEND_REJECTED_OTHER:\n\t\treturn \"OTHER\";\n\tdefault:\n\t\treturn \"Untracked status\";\n\t}\n}\n\nint wmi_suspend(struct wil6210_priv *wil)\n{\n\tstruct wil6210_vif *vif = ndev_to_vif(wil->main_ndev);\n\tint rc;\n\tstruct wmi_traffic_suspend_cmd cmd = {\n\t\t.wakeup_trigger = wil->wakeup_trigger,\n\t};\n\tstruct {\n\t\tstruct wmi_cmd_hdr wmi;\n\t\tstruct wmi_traffic_suspend_event evt;\n\t} __packed reply = {\n\t\t.evt = {.status = WMI_TRAFFIC_SUSPEND_REJECTED_LINK_NOT_IDLE},\n\t};\n\n\tu32 suspend_to = WIL_WAIT_FOR_SUSPEND_RESUME_COMP;\n\n\twil->suspend_resp_rcvd = false;\n\twil->suspend_resp_comp = false;\n\n\trc = wmi_call(wil, WMI_TRAFFIC_SUSPEND_CMDID, vif->mid,\n\t\t      &cmd, sizeof(cmd),\n\t\t      WMI_TRAFFIC_SUSPEND_EVENTID, &reply, sizeof(reply),\n\t\t      suspend_to);\n\tif (rc) {\n\t\twil_err(wil, \"wmi_call for suspend req failed, rc=%d\\n\", rc);\n\t\tif (rc == -ETIME)\n\t\t\t \n\t\t\twil->suspend_stats.rejected_by_device++;\n\t\telse\n\t\t\twil->suspend_stats.rejected_by_host++;\n\t\tgoto out;\n\t}\n\n\twil_dbg_wmi(wil, \"waiting for suspend_response_completed\\n\");\n\n\trc = wait_event_interruptible_timeout(wil->wq,\n\t\t\t\t\t      wil->suspend_resp_comp,\n\t\t\t\t\t      msecs_to_jiffies(suspend_to));\n\tif (rc == 0) {\n\t\twil_err(wil, \"TO waiting for suspend_response_completed\\n\");\n\t\tif (wil->suspend_resp_rcvd)\n\t\t\t \n\t\t\twil->suspend_stats.rejected_by_host++;\n\t\telse\n\t\t\twil->suspend_stats.rejected_by_device++;\n\t\trc = -EBUSY;\n\t\tgoto out;\n\t}\n\n\twil_dbg_wmi(wil, \"suspend_response_completed rcvd\\n\");\n\tif (reply.evt.status != WMI_TRAFFIC_SUSPEND_APPROVED) {\n\t\twil_dbg_pm(wil, \"device rejected the suspend, %s\\n\",\n\t\t\t   suspend_status2name(reply.evt.status));\n\t\twil->suspend_stats.rejected_by_device++;\n\t}\n\trc = reply.evt.status;\n\nout:\n\twil->suspend_resp_rcvd = false;\n\twil->suspend_resp_comp = false;\n\n\treturn rc;\n}\n\nstatic void resume_triggers2string(u32 triggers, char *string, int str_size)\n{\n\tstring[0] = '\\0';\n\n\tif (!triggers) {\n\t\tstrlcat(string, \" UNKNOWN\", str_size);\n\t\treturn;\n\t}\n\n\tif (triggers & WMI_RESUME_TRIGGER_HOST)\n\t\tstrlcat(string, \" HOST\", str_size);\n\n\tif (triggers & WMI_RESUME_TRIGGER_UCAST_RX)\n\t\tstrlcat(string, \" UCAST_RX\", str_size);\n\n\tif (triggers & WMI_RESUME_TRIGGER_BCAST_RX)\n\t\tstrlcat(string, \" BCAST_RX\", str_size);\n\n\tif (triggers & WMI_RESUME_TRIGGER_WMI_EVT)\n\t\tstrlcat(string, \" WMI_EVT\", str_size);\n\n\tif (triggers & WMI_RESUME_TRIGGER_DISCONNECT)\n\t\tstrlcat(string, \" DISCONNECT\", str_size);\n}\n\nint wmi_resume(struct wil6210_priv *wil)\n{\n\tstruct wil6210_vif *vif = ndev_to_vif(wil->main_ndev);\n\tint rc;\n\tchar string[100];\n\tstruct {\n\t\tstruct wmi_cmd_hdr wmi;\n\t\tstruct wmi_traffic_resume_event evt;\n\t} __packed reply = {\n\t\t.evt = {.status = WMI_TRAFFIC_RESUME_FAILED,\n\t\t\t.resume_triggers =\n\t\t\t\tcpu_to_le32(WMI_RESUME_TRIGGER_UNKNOWN)},\n\t};\n\n\trc = wmi_call(wil, WMI_TRAFFIC_RESUME_CMDID, vif->mid, NULL, 0,\n\t\t      WMI_TRAFFIC_RESUME_EVENTID, &reply, sizeof(reply),\n\t\t      WIL_WAIT_FOR_SUSPEND_RESUME_COMP);\n\tif (rc)\n\t\treturn rc;\n\tresume_triggers2string(le32_to_cpu(reply.evt.resume_triggers), string,\n\t\t\t       sizeof(string));\n\twil_dbg_pm(wil, \"device resume %s, resume triggers:%s (0x%x)\\n\",\n\t\t   reply.evt.status ? \"failed\" : \"passed\", string,\n\t\t   le32_to_cpu(reply.evt.resume_triggers));\n\n\treturn reply.evt.status;\n}\n\nint wmi_port_allocate(struct wil6210_priv *wil, u8 mid,\n\t\t      const u8 *mac, enum nl80211_iftype iftype)\n{\n\tint rc;\n\tstruct wmi_port_allocate_cmd cmd = {\n\t\t.mid = mid,\n\t};\n\tstruct {\n\t\tstruct wmi_cmd_hdr wmi;\n\t\tstruct wmi_port_allocated_event evt;\n\t} __packed reply = {\n\t\t.evt = {.status = WMI_FW_STATUS_FAILURE},\n\t};\n\n\twil_dbg_misc(wil, \"port allocate, mid %d iftype %d, mac %pM\\n\",\n\t\t     mid, iftype, mac);\n\n\tether_addr_copy(cmd.mac, mac);\n\tswitch (iftype) {\n\tcase NL80211_IFTYPE_STATION:\n\t\tcmd.port_role = WMI_PORT_STA;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\t\tcmd.port_role = WMI_PORT_AP;\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tcmd.port_role = WMI_PORT_P2P_CLIENT;\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tcmd.port_role = WMI_PORT_P2P_GO;\n\t\tbreak;\n\t \n\tdefault:\n\t\twil_err(wil, \"unsupported iftype: %d\\n\", iftype);\n\t\treturn -EINVAL;\n\t}\n\n\trc = wmi_call(wil, WMI_PORT_ALLOCATE_CMDID, mid,\n\t\t      &cmd, sizeof(cmd),\n\t\t      WMI_PORT_ALLOCATED_EVENTID, &reply,\n\t\t      sizeof(reply), 300);\n\tif (rc) {\n\t\twil_err(wil, \"failed to allocate port, status %d\\n\", rc);\n\t\treturn rc;\n\t}\n\tif (reply.evt.status != WMI_FW_STATUS_SUCCESS) {\n\t\twil_err(wil, \"WMI_PORT_ALLOCATE returned status %d\\n\",\n\t\t\treply.evt.status);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint wmi_port_delete(struct wil6210_priv *wil, u8 mid)\n{\n\tint rc;\n\tstruct wmi_port_delete_cmd cmd = {\n\t\t.mid = mid,\n\t};\n\tstruct {\n\t\tstruct wmi_cmd_hdr wmi;\n\t\tstruct wmi_port_deleted_event evt;\n\t} __packed reply = {\n\t\t.evt = {.status = WMI_FW_STATUS_FAILURE},\n\t};\n\n\twil_dbg_misc(wil, \"port delete, mid %d\\n\", mid);\n\n\trc = wmi_call(wil, WMI_PORT_DELETE_CMDID, mid,\n\t\t      &cmd, sizeof(cmd),\n\t\t      WMI_PORT_DELETED_EVENTID, &reply,\n\t\t      sizeof(reply), 2000);\n\tif (rc) {\n\t\twil_err(wil, \"failed to delete port, status %d\\n\", rc);\n\t\treturn rc;\n\t}\n\tif (reply.evt.status != WMI_FW_STATUS_SUCCESS) {\n\t\twil_err(wil, \"WMI_PORT_DELETE returned status %d\\n\",\n\t\t\treply.evt.status);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic bool wmi_evt_call_handler(struct wil6210_vif *vif, int id,\n\t\t\t\t void *d, int len)\n{\n\tuint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(wmi_evt_handlers); i++) {\n\t\tif (wmi_evt_handlers[i].eventid == id) {\n\t\t\twmi_evt_handlers[i].handler(vif, id, d, len);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic void wmi_event_handle(struct wil6210_priv *wil,\n\t\t\t     struct wil6210_mbox_hdr *hdr)\n{\n\tu16 len = le16_to_cpu(hdr->len);\n\tstruct wil6210_vif *vif;\n\n\tif ((hdr->type == WIL_MBOX_HDR_TYPE_WMI) &&\n\t    (len >= sizeof(struct wmi_cmd_hdr))) {\n\t\tstruct wmi_cmd_hdr *wmi = (void *)(&hdr[1]);\n\t\tvoid *evt_data = (void *)(&wmi[1]);\n\t\tu16 id = le16_to_cpu(wmi->command_id);\n\t\tu8 mid = wmi->mid;\n\n\t\twil_dbg_wmi(wil, \"Handle %s (0x%04x) (reply_id 0x%04x,%d)\\n\",\n\t\t\t    eventid2name(id), id, wil->reply_id,\n\t\t\t    wil->reply_mid);\n\n\t\tif (mid == MID_BROADCAST)\n\t\t\tmid = 0;\n\t\tif (mid >= GET_MAX_VIFS(wil)) {\n\t\t\twil_dbg_wmi(wil, \"invalid mid %d, event skipped\\n\",\n\t\t\t\t    mid);\n\t\t\treturn;\n\t\t}\n\t\tvif = wil->vifs[mid];\n\t\tif (!vif) {\n\t\t\twil_dbg_wmi(wil, \"event for empty VIF(%d), skipped\\n\",\n\t\t\t\t    mid);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tif (wil->reply_id && wil->reply_id == id &&\n\t\t    wil->reply_mid == mid) {\n\t\t\tif (wil->reply_buf) {\n\t\t\t\t \n\t\t\t\twil_err(wil,\n\t\t\t\t\t\"Old event (%d, %s) while wmi_call is waiting. Drop it and Continue waiting\\n\",\n\t\t\t\t\tid, eventid2name(id));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\twmi_evt_call_handler(vif, id, evt_data,\n\t\t\t\t\t     len - sizeof(*wmi));\n\t\t\twil_dbg_wmi(wil, \"event_handle: Complete WMI 0x%04x\\n\",\n\t\t\t\t    id);\n\t\t\tcomplete(&wil->wmi_call);\n\t\t\treturn;\n\t\t}\n\t\t \n\t\t \n\t\tif (!wmi_evt_call_handler(vif, id, evt_data,\n\t\t\t\t\t  len - sizeof(*wmi))) {\n\t\t\twil_info(wil, \"Unhandled event 0x%04x\\n\", id);\n\t\t}\n\t} else {\n\t\twil_err(wil, \"Unknown event type\\n\");\n\t\tprint_hex_dump(KERN_ERR, \"evt?? \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t       hdr, sizeof(*hdr) + len, true);\n\t}\n}\n\n \nstatic struct list_head *next_wmi_ev(struct wil6210_priv *wil)\n{\n\tulong flags;\n\tstruct list_head *ret = NULL;\n\n\tspin_lock_irqsave(&wil->wmi_ev_lock, flags);\n\n\tif (!list_empty(&wil->pending_wmi_ev)) {\n\t\tret = wil->pending_wmi_ev.next;\n\t\tlist_del(ret);\n\t}\n\n\tspin_unlock_irqrestore(&wil->wmi_ev_lock, flags);\n\n\treturn ret;\n}\n\n \nvoid wmi_event_worker(struct work_struct *work)\n{\n\tstruct wil6210_priv *wil = container_of(work, struct wil6210_priv,\n\t\t\t\t\t\t wmi_event_worker);\n\tstruct pending_wmi_event *evt;\n\tstruct list_head *lh;\n\n\twil_dbg_wmi(wil, \"event_worker: Start\\n\");\n\twhile ((lh = next_wmi_ev(wil)) != NULL) {\n\t\tevt = list_entry(lh, struct pending_wmi_event, list);\n\t\twmi_event_handle(wil, &evt->event.hdr);\n\t\tkfree(evt);\n\t}\n\twil_dbg_wmi(wil, \"event_worker: Finished\\n\");\n}\n\nbool wil_is_wmi_idle(struct wil6210_priv *wil)\n{\n\tulong flags;\n\tstruct wil6210_mbox_ring *r = &wil->mbox_ctl.rx;\n\tbool rc = false;\n\n\tspin_lock_irqsave(&wil->wmi_ev_lock, flags);\n\n\t \n\tif (!list_empty(&wil->pending_wmi_ev)) {\n\t\twil_dbg_pm(wil, \"Pending WMI events in queue\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tif (wil->reply_id) {\n\t\twil_dbg_pm(wil, \"Pending WMI call\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tr->head = wil_r(wil, RGF_MBOX +\n\t\t\toffsetof(struct wil6210_mbox_ctl, rx.head));\n\tif (r->tail != r->head)\n\t\twil_dbg_pm(wil, \"Pending WMI mbox events\\n\");\n\telse\n\t\trc = true;\n\nout:\n\tspin_unlock_irqrestore(&wil->wmi_ev_lock, flags);\n\treturn rc;\n}\n\nstatic void\nwmi_sched_scan_set_ssids(struct wil6210_priv *wil,\n\t\t\t struct wmi_start_sched_scan_cmd *cmd,\n\t\t\t struct cfg80211_ssid *ssids, int n_ssids,\n\t\t\t struct cfg80211_match_set *match_sets,\n\t\t\t int n_match_sets)\n{\n\tint i;\n\n\tif (n_match_sets > WMI_MAX_PNO_SSID_NUM) {\n\t\twil_dbg_wmi(wil, \"too many match sets (%d), use first %d\\n\",\n\t\t\t    n_match_sets, WMI_MAX_PNO_SSID_NUM);\n\t\tn_match_sets = WMI_MAX_PNO_SSID_NUM;\n\t}\n\tcmd->num_of_ssids = n_match_sets;\n\n\tfor (i = 0; i < n_match_sets; i++) {\n\t\tstruct wmi_sched_scan_ssid_match *wmi_match =\n\t\t\t&cmd->ssid_for_match[i];\n\t\tstruct cfg80211_match_set *cfg_match = &match_sets[i];\n\t\tint j;\n\n\t\twmi_match->ssid_len = cfg_match->ssid.ssid_len;\n\t\tmemcpy(wmi_match->ssid, cfg_match->ssid.ssid,\n\t\t       min_t(u8, wmi_match->ssid_len, WMI_MAX_SSID_LEN));\n\t\twmi_match->rssi_threshold = S8_MIN;\n\t\tif (cfg_match->rssi_thold >= S8_MIN &&\n\t\t    cfg_match->rssi_thold <= S8_MAX)\n\t\t\twmi_match->rssi_threshold = cfg_match->rssi_thold;\n\n\t\tfor (j = 0; j < n_ssids; j++)\n\t\t\tif (wmi_match->ssid_len == ssids[j].ssid_len &&\n\t\t\t    memcmp(wmi_match->ssid, ssids[j].ssid,\n\t\t\t\t   wmi_match->ssid_len) == 0)\n\t\t\t\twmi_match->add_ssid_to_probe = true;\n\t}\n}\n\nstatic void\nwmi_sched_scan_set_channels(struct wil6210_priv *wil,\n\t\t\t    struct wmi_start_sched_scan_cmd *cmd,\n\t\t\t    u32 n_channels,\n\t\t\t    struct ieee80211_channel **channels)\n{\n\tint i;\n\n\tif (n_channels > WMI_MAX_CHANNEL_NUM) {\n\t\twil_dbg_wmi(wil, \"too many channels (%d), use first %d\\n\",\n\t\t\t    n_channels, WMI_MAX_CHANNEL_NUM);\n\t\tn_channels = WMI_MAX_CHANNEL_NUM;\n\t}\n\tcmd->num_of_channels = n_channels;\n\n\tfor (i = 0; i < n_channels; i++) {\n\t\tstruct ieee80211_channel *cfg_chan = channels[i];\n\n\t\tcmd->channel_list[i] = cfg_chan->hw_value - 1;\n\t}\n}\n\nstatic void\nwmi_sched_scan_set_plans(struct wil6210_priv *wil,\n\t\t\t struct wmi_start_sched_scan_cmd *cmd,\n\t\t\t struct cfg80211_sched_scan_plan *scan_plans,\n\t\t\t int n_scan_plans)\n{\n\tint i;\n\n\tif (n_scan_plans > WMI_MAX_PLANS_NUM) {\n\t\twil_dbg_wmi(wil, \"too many plans (%d), use first %d\\n\",\n\t\t\t    n_scan_plans, WMI_MAX_PLANS_NUM);\n\t\tn_scan_plans = WMI_MAX_PLANS_NUM;\n\t}\n\n\tfor (i = 0; i < n_scan_plans; i++) {\n\t\tstruct cfg80211_sched_scan_plan *cfg_plan = &scan_plans[i];\n\n\t\tcmd->scan_plans[i].interval_sec =\n\t\t\tcpu_to_le16(cfg_plan->interval);\n\t\tcmd->scan_plans[i].num_of_iterations =\n\t\t\tcpu_to_le16(cfg_plan->iterations);\n\t}\n}\n\nint wmi_start_sched_scan(struct wil6210_priv *wil,\n\t\t\t struct cfg80211_sched_scan_request *request)\n{\n\tstruct wil6210_vif *vif = ndev_to_vif(wil->main_ndev);\n\tint rc;\n\tstruct wmi_start_sched_scan_cmd cmd = {\n\t\t.min_rssi_threshold = S8_MIN,\n\t\t.initial_delay_sec = cpu_to_le16(request->delay),\n\t};\n\tstruct {\n\t\tstruct wmi_cmd_hdr wmi;\n\t\tstruct wmi_start_sched_scan_event evt;\n\t} __packed reply = {\n\t\t.evt = {.result = WMI_PNO_REJECT},\n\t};\n\n\tif (!test_bit(WMI_FW_CAPABILITY_PNO, wil->fw_capabilities))\n\t\treturn -ENOTSUPP;\n\n\tif (request->min_rssi_thold >= S8_MIN &&\n\t    request->min_rssi_thold <= S8_MAX)\n\t\tcmd.min_rssi_threshold = request->min_rssi_thold;\n\n\twmi_sched_scan_set_ssids(wil, &cmd, request->ssids, request->n_ssids,\n\t\t\t\t request->match_sets, request->n_match_sets);\n\twmi_sched_scan_set_channels(wil, &cmd,\n\t\t\t\t    request->n_channels, request->channels);\n\twmi_sched_scan_set_plans(wil, &cmd,\n\t\t\t\t request->scan_plans, request->n_scan_plans);\n\n\trc = wmi_call(wil, WMI_START_SCHED_SCAN_CMDID, vif->mid,\n\t\t      &cmd, sizeof(cmd),\n\t\t      WMI_START_SCHED_SCAN_EVENTID, &reply, sizeof(reply),\n\t\t      WIL_WMI_CALL_GENERAL_TO_MS);\n\tif (rc)\n\t\treturn rc;\n\n\tif (reply.evt.result != WMI_PNO_SUCCESS) {\n\t\twil_err(wil, \"start sched scan failed, result %d\\n\",\n\t\t\treply.evt.result);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint wmi_stop_sched_scan(struct wil6210_priv *wil)\n{\n\tstruct wil6210_vif *vif = ndev_to_vif(wil->main_ndev);\n\tint rc;\n\tstruct {\n\t\tstruct wmi_cmd_hdr wmi;\n\t\tstruct wmi_stop_sched_scan_event evt;\n\t} __packed reply = {\n\t\t.evt = {.result = WMI_PNO_REJECT},\n\t};\n\n\tif (!test_bit(WMI_FW_CAPABILITY_PNO, wil->fw_capabilities))\n\t\treturn -ENOTSUPP;\n\n\trc = wmi_call(wil, WMI_STOP_SCHED_SCAN_CMDID, vif->mid, NULL, 0,\n\t\t      WMI_STOP_SCHED_SCAN_EVENTID, &reply, sizeof(reply),\n\t\t      WIL_WMI_CALL_GENERAL_TO_MS);\n\tif (rc)\n\t\treturn rc;\n\n\tif (reply.evt.result != WMI_PNO_SUCCESS) {\n\t\twil_err(wil, \"stop sched scan failed, result %d\\n\",\n\t\t\treply.evt.result);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint wmi_mgmt_tx(struct wil6210_vif *vif, const u8 *buf, size_t len)\n{\n\tsize_t total;\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tstruct ieee80211_mgmt *mgmt_frame = (void *)buf;\n\tstruct wmi_sw_tx_req_cmd *cmd;\n\tstruct {\n\t\tstruct wmi_cmd_hdr wmi;\n\t\tstruct wmi_sw_tx_complete_event evt;\n\t} __packed evt = {\n\t\t.evt = {.status = WMI_FW_STATUS_FAILURE},\n\t};\n\tint rc;\n\n\twil_dbg_misc(wil, \"mgmt_tx mid %d\\n\", vif->mid);\n\twil_hex_dump_misc(\"mgmt tx frame \", DUMP_PREFIX_OFFSET, 16, 1, buf,\n\t\t\t  len, true);\n\n\tif (len < sizeof(struct ieee80211_hdr_3addr))\n\t\treturn -EINVAL;\n\n\ttotal = sizeof(*cmd) + len;\n\tif (total < len) {\n\t\twil_err(wil, \"mgmt_tx invalid len %zu\\n\", len);\n\t\treturn -EINVAL;\n\t}\n\n\tcmd = kmalloc(total, GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tmemcpy(cmd->dst_mac, mgmt_frame->da, WMI_MAC_LEN);\n\tcmd->len = cpu_to_le16(len);\n\tmemcpy(cmd->payload, buf, len);\n\n\trc = wmi_call(wil, WMI_SW_TX_REQ_CMDID, vif->mid, cmd, total,\n\t\t      WMI_SW_TX_COMPLETE_EVENTID, &evt, sizeof(evt), 2000);\n\tif (!rc && evt.evt.status != WMI_FW_STATUS_SUCCESS) {\n\t\twil_dbg_wmi(wil, \"mgmt_tx failed with status %d\\n\",\n\t\t\t    evt.evt.status);\n\t\trc = -EAGAIN;\n\t}\n\n\tkfree(cmd);\n\n\treturn rc;\n}\n\nint wmi_mgmt_tx_ext(struct wil6210_vif *vif, const u8 *buf, size_t len,\n\t\t    u8 channel, u16 duration_ms)\n{\n\tsize_t total;\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tstruct ieee80211_mgmt *mgmt_frame = (void *)buf;\n\tstruct wmi_sw_tx_req_ext_cmd *cmd;\n\tstruct {\n\t\tstruct wmi_cmd_hdr wmi;\n\t\tstruct wmi_sw_tx_complete_event evt;\n\t} __packed evt = {\n\t\t.evt = {.status = WMI_FW_STATUS_FAILURE},\n\t};\n\tint rc;\n\n\twil_dbg_wmi(wil, \"mgmt_tx_ext mid %d channel %d duration %d\\n\",\n\t\t    vif->mid, channel, duration_ms);\n\twil_hex_dump_wmi(\"mgmt_tx_ext frame \", DUMP_PREFIX_OFFSET, 16, 1, buf,\n\t\t\t len, true);\n\n\tif (len < sizeof(struct ieee80211_hdr_3addr)) {\n\t\twil_err(wil, \"short frame. len %zu\\n\", len);\n\t\treturn -EINVAL;\n\t}\n\n\ttotal = sizeof(*cmd) + len;\n\tif (total < len) {\n\t\twil_err(wil, \"mgmt_tx_ext invalid len %zu\\n\", len);\n\t\treturn -EINVAL;\n\t}\n\n\tcmd = kzalloc(total, GFP_KERNEL);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tmemcpy(cmd->dst_mac, mgmt_frame->da, WMI_MAC_LEN);\n\tcmd->len = cpu_to_le16(len);\n\tmemcpy(cmd->payload, buf, len);\n\tcmd->channel = channel - 1;\n\tcmd->duration_ms = cpu_to_le16(duration_ms);\n\n\trc = wmi_call(wil, WMI_SW_TX_REQ_EXT_CMDID, vif->mid, cmd, total,\n\t\t      WMI_SW_TX_COMPLETE_EVENTID, &evt, sizeof(evt), 2000);\n\tif (!rc && evt.evt.status != WMI_FW_STATUS_SUCCESS) {\n\t\twil_dbg_wmi(wil, \"mgmt_tx_ext failed with status %d\\n\",\n\t\t\t    evt.evt.status);\n\t\trc = -EAGAIN;\n\t}\n\n\tkfree(cmd);\n\n\treturn rc;\n}\n\nint wil_wmi_tx_sring_cfg(struct wil6210_priv *wil, int ring_id)\n{\n\tint rc;\n\tstruct wil6210_vif *vif = ndev_to_vif(wil->main_ndev);\n\tstruct wil_status_ring *sring = &wil->srings[ring_id];\n\tstruct wmi_tx_status_ring_add_cmd cmd = {\n\t\t.ring_cfg = {\n\t\t\t.ring_size = cpu_to_le16(sring->size),\n\t\t},\n\t\t.irq_index = WIL_TX_STATUS_IRQ_IDX\n\t};\n\tstruct {\n\t\tstruct wmi_cmd_hdr hdr;\n\t\tstruct wmi_tx_status_ring_cfg_done_event evt;\n\t} __packed reply = {\n\t\t.evt = {.status = WMI_FW_STATUS_FAILURE},\n\t};\n\n\tcmd.ring_cfg.ring_id = ring_id;\n\n\tcmd.ring_cfg.ring_mem_base = cpu_to_le64(sring->pa);\n\trc = wmi_call(wil, WMI_TX_STATUS_RING_ADD_CMDID, vif->mid, &cmd,\n\t\t      sizeof(cmd), WMI_TX_STATUS_RING_CFG_DONE_EVENTID,\n\t\t      &reply, sizeof(reply), WIL_WMI_CALL_GENERAL_TO_MS);\n\tif (rc) {\n\t\twil_err(wil, \"TX_STATUS_RING_ADD_CMD failed, rc %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tif (reply.evt.status != WMI_FW_STATUS_SUCCESS) {\n\t\twil_err(wil, \"TX_STATUS_RING_ADD_CMD failed, status %d\\n\",\n\t\t\treply.evt.status);\n\t\treturn -EINVAL;\n\t}\n\n\tsring->hwtail = le32_to_cpu(reply.evt.ring_tail_ptr);\n\n\treturn 0;\n}\n\nint wil_wmi_cfg_def_rx_offload(struct wil6210_priv *wil, u16 max_rx_pl_per_desc)\n{\n\tstruct net_device *ndev = wil->main_ndev;\n\tstruct wil6210_vif *vif = ndev_to_vif(ndev);\n\tint rc;\n\tstruct wmi_cfg_def_rx_offload_cmd cmd = {\n\t\t.max_msdu_size = cpu_to_le16(wil_mtu2macbuf(WIL_MAX_ETH_MTU)),\n\t\t.max_rx_pl_per_desc = cpu_to_le16(max_rx_pl_per_desc),\n\t\t.decap_trans_type = WMI_DECAP_TYPE_802_3,\n\t\t.l2_802_3_offload_ctrl = 0,\n\t\t.l3_l4_ctrl = 1 << L3_L4_CTRL_TCPIP_CHECKSUM_EN_POS,\n\t};\n\tstruct {\n\t\tstruct wmi_cmd_hdr hdr;\n\t\tstruct wmi_cfg_def_rx_offload_done_event evt;\n\t} __packed reply = {\n\t\t.evt = {.status = WMI_FW_STATUS_FAILURE},\n\t};\n\n\trc = wmi_call(wil, WMI_CFG_DEF_RX_OFFLOAD_CMDID, vif->mid, &cmd,\n\t\t      sizeof(cmd), WMI_CFG_DEF_RX_OFFLOAD_DONE_EVENTID, &reply,\n\t\t      sizeof(reply), WIL_WMI_CALL_GENERAL_TO_MS);\n\tif (rc) {\n\t\twil_err(wil, \"WMI_CFG_DEF_RX_OFFLOAD_CMD failed, rc %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tif (reply.evt.status != WMI_FW_STATUS_SUCCESS) {\n\t\twil_err(wil, \"WMI_CFG_DEF_RX_OFFLOAD_CMD failed, status %d\\n\",\n\t\t\treply.evt.status);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint wil_wmi_rx_sring_add(struct wil6210_priv *wil, u16 ring_id)\n{\n\tstruct net_device *ndev = wil->main_ndev;\n\tstruct wil6210_vif *vif = ndev_to_vif(ndev);\n\tstruct wil_status_ring *sring = &wil->srings[ring_id];\n\tint rc;\n\tstruct wmi_rx_status_ring_add_cmd cmd = {\n\t\t.ring_cfg = {\n\t\t\t.ring_size = cpu_to_le16(sring->size),\n\t\t\t.ring_id = ring_id,\n\t\t},\n\t\t.rx_msg_type = wil->use_compressed_rx_status ?\n\t\t\tWMI_RX_MSG_TYPE_COMPRESSED :\n\t\t\tWMI_RX_MSG_TYPE_EXTENDED,\n\t\t.irq_index = WIL_RX_STATUS_IRQ_IDX,\n\t};\n\tstruct {\n\t\tstruct wmi_cmd_hdr hdr;\n\t\tstruct wmi_rx_status_ring_cfg_done_event evt;\n\t} __packed reply = {\n\t\t.evt = {.status = WMI_FW_STATUS_FAILURE},\n\t};\n\n\tcmd.ring_cfg.ring_mem_base = cpu_to_le64(sring->pa);\n\trc = wmi_call(wil, WMI_RX_STATUS_RING_ADD_CMDID, vif->mid, &cmd,\n\t\t      sizeof(cmd), WMI_RX_STATUS_RING_CFG_DONE_EVENTID, &reply,\n\t\t      sizeof(reply), WIL_WMI_CALL_GENERAL_TO_MS);\n\tif (rc) {\n\t\twil_err(wil, \"RX_STATUS_RING_ADD_CMD failed, rc %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tif (reply.evt.status != WMI_FW_STATUS_SUCCESS) {\n\t\twil_err(wil, \"RX_STATUS_RING_ADD_CMD failed, status %d\\n\",\n\t\t\treply.evt.status);\n\t\treturn -EINVAL;\n\t}\n\n\tsring->hwtail = le32_to_cpu(reply.evt.ring_tail_ptr);\n\n\treturn 0;\n}\n\nint wil_wmi_rx_desc_ring_add(struct wil6210_priv *wil, int status_ring_id)\n{\n\tstruct net_device *ndev = wil->main_ndev;\n\tstruct wil6210_vif *vif = ndev_to_vif(ndev);\n\tstruct wil_ring *ring = &wil->ring_rx;\n\tint rc;\n\tstruct wmi_rx_desc_ring_add_cmd cmd = {\n\t\t.ring_cfg = {\n\t\t\t.ring_size = cpu_to_le16(ring->size),\n\t\t\t.ring_id = WIL_RX_DESC_RING_ID,\n\t\t},\n\t\t.status_ring_id = status_ring_id,\n\t\t.irq_index = WIL_RX_STATUS_IRQ_IDX,\n\t};\n\tstruct {\n\t\tstruct wmi_cmd_hdr hdr;\n\t\tstruct wmi_rx_desc_ring_cfg_done_event evt;\n\t} __packed reply = {\n\t\t.evt = {.status = WMI_FW_STATUS_FAILURE},\n\t};\n\n\tcmd.ring_cfg.ring_mem_base = cpu_to_le64(ring->pa);\n\tcmd.sw_tail_host_addr = cpu_to_le64(ring->edma_rx_swtail.pa);\n\trc = wmi_call(wil, WMI_RX_DESC_RING_ADD_CMDID, vif->mid, &cmd,\n\t\t      sizeof(cmd), WMI_RX_DESC_RING_CFG_DONE_EVENTID, &reply,\n\t\t      sizeof(reply), WIL_WMI_CALL_GENERAL_TO_MS);\n\tif (rc) {\n\t\twil_err(wil, \"WMI_RX_DESC_RING_ADD_CMD failed, rc %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tif (reply.evt.status != WMI_FW_STATUS_SUCCESS) {\n\t\twil_err(wil, \"WMI_RX_DESC_RING_ADD_CMD failed, status %d\\n\",\n\t\t\treply.evt.status);\n\t\treturn -EINVAL;\n\t}\n\n\tring->hwtail = le32_to_cpu(reply.evt.ring_tail_ptr);\n\n\treturn 0;\n}\n\nint wil_wmi_tx_desc_ring_add(struct wil6210_vif *vif, int ring_id, int cid,\n\t\t\t     int tid)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tint sring_id = wil->tx_sring_idx;  \n\tint rc;\n\tstruct wil_ring *ring = &wil->ring_tx[ring_id];\n\tstruct wil_ring_tx_data *txdata = &wil->ring_tx_data[ring_id];\n\tstruct wmi_tx_desc_ring_add_cmd cmd = {\n\t\t.ring_cfg = {\n\t\t\t.ring_size = cpu_to_le16(ring->size),\n\t\t\t.ring_id = ring_id,\n\t\t},\n\t\t.status_ring_id = sring_id,\n\t\t.cid = cid,\n\t\t.tid = tid,\n\t\t.encap_trans_type = WMI_VRING_ENC_TYPE_802_3,\n\t\t.max_msdu_size = cpu_to_le16(wil_mtu2macbuf(mtu_max)),\n\t\t.schd_params = {\n\t\t\t.priority = cpu_to_le16(0),\n\t\t\t.timeslot_us = cpu_to_le16(0xfff),\n\t\t}\n\t};\n\tstruct {\n\t\tstruct wmi_cmd_hdr hdr;\n\t\tstruct wmi_tx_desc_ring_cfg_done_event evt;\n\t} __packed reply = {\n\t\t.evt = {.status = WMI_FW_STATUS_FAILURE},\n\t};\n\n\tcmd.ring_cfg.ring_mem_base = cpu_to_le64(ring->pa);\n\trc = wmi_call(wil, WMI_TX_DESC_RING_ADD_CMDID, vif->mid, &cmd,\n\t\t      sizeof(cmd), WMI_TX_DESC_RING_CFG_DONE_EVENTID, &reply,\n\t\t      sizeof(reply), WIL_WMI_CALL_GENERAL_TO_MS);\n\tif (rc) {\n\t\twil_err(wil, \"WMI_TX_DESC_RING_ADD_CMD failed, rc %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tif (reply.evt.status != WMI_FW_STATUS_SUCCESS) {\n\t\twil_err(wil, \"WMI_TX_DESC_RING_ADD_CMD failed, status %d\\n\",\n\t\t\treply.evt.status);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_bh(&txdata->lock);\n\tring->hwtail = le32_to_cpu(reply.evt.ring_tail_ptr);\n\ttxdata->mid = vif->mid;\n\ttxdata->enabled = 1;\n\tspin_unlock_bh(&txdata->lock);\n\n\treturn 0;\n}\n\nint wil_wmi_bcast_desc_ring_add(struct wil6210_vif *vif, int ring_id)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tstruct wil_ring *ring = &wil->ring_tx[ring_id];\n\tint rc;\n\tstruct wmi_bcast_desc_ring_add_cmd cmd = {\n\t\t.ring_cfg = {\n\t\t\t.ring_size = cpu_to_le16(ring->size),\n\t\t\t.ring_id = ring_id,\n\t\t},\n\t\t.max_msdu_size = cpu_to_le16(wil_mtu2macbuf(mtu_max)),\n\t\t.status_ring_id = wil->tx_sring_idx,\n\t\t.encap_trans_type = WMI_VRING_ENC_TYPE_802_3,\n\t};\n\tstruct {\n\t\tstruct wmi_cmd_hdr hdr;\n\t\tstruct wmi_rx_desc_ring_cfg_done_event evt;\n\t} __packed reply = {\n\t\t.evt = {.status = WMI_FW_STATUS_FAILURE},\n\t};\n\tstruct wil_ring_tx_data *txdata = &wil->ring_tx_data[ring_id];\n\n\tcmd.ring_cfg.ring_mem_base = cpu_to_le64(ring->pa);\n\trc = wmi_call(wil, WMI_BCAST_DESC_RING_ADD_CMDID, vif->mid, &cmd,\n\t\t      sizeof(cmd), WMI_TX_DESC_RING_CFG_DONE_EVENTID, &reply,\n\t\t      sizeof(reply), WIL_WMI_CALL_GENERAL_TO_MS);\n\tif (rc) {\n\t\twil_err(wil, \"WMI_BCAST_DESC_RING_ADD_CMD failed, rc %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tif (reply.evt.status != WMI_FW_STATUS_SUCCESS) {\n\t\twil_err(wil, \"Broadcast Tx config failed, status %d\\n\",\n\t\t\treply.evt.status);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_bh(&txdata->lock);\n\tring->hwtail = le32_to_cpu(reply.evt.ring_tail_ptr);\n\ttxdata->mid = vif->mid;\n\ttxdata->enabled = 1;\n\tspin_unlock_bh(&txdata->lock);\n\n\treturn 0;\n}\n\nint wmi_link_stats_cfg(struct wil6210_vif *vif, u32 type, u8 cid, u32 interval)\n{\n\tstruct wil6210_priv *wil = vif_to_wil(vif);\n\tstruct wmi_link_stats_cmd cmd = {\n\t\t.record_type_mask = cpu_to_le32(type),\n\t\t.cid = cid,\n\t\t.action = WMI_LINK_STATS_SNAPSHOT,\n\t\t.interval_msec = cpu_to_le32(interval),\n\t};\n\tstruct {\n\t\tstruct wmi_cmd_hdr wmi;\n\t\tstruct wmi_link_stats_config_done_event evt;\n\t} __packed reply = {\n\t\t.evt = {.status = WMI_FW_STATUS_FAILURE},\n\t};\n\tint rc;\n\n\trc = wmi_call(wil, WMI_LINK_STATS_CMDID, vif->mid, &cmd, sizeof(cmd),\n\t\t      WMI_LINK_STATS_CONFIG_DONE_EVENTID, &reply,\n\t\t      sizeof(reply), WIL_WMI_CALL_GENERAL_TO_MS);\n\tif (rc) {\n\t\twil_err(wil, \"WMI_LINK_STATS_CMDID failed, rc %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tif (reply.evt.status != WMI_FW_STATUS_SUCCESS) {\n\t\twil_err(wil, \"Link statistics config failed, status %d\\n\",\n\t\t\treply.evt.status);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint wmi_set_cqm_rssi_config(struct wil6210_priv *wil,\n\t\t\t    s32 rssi_thold, u32 rssi_hyst)\n{\n\tstruct net_device *ndev = wil->main_ndev;\n\tstruct wil6210_vif *vif = ndev_to_vif(ndev);\n\tint rc;\n\tstruct {\n\t\tstruct wmi_set_link_monitor_cmd cmd;\n\t\ts8 rssi_thold;\n\t} __packed cmd = {\n\t\t.cmd = {\n\t\t\t.rssi_hyst = rssi_hyst,\n\t\t\t.rssi_thresholds_list_size = 1,\n\t\t},\n\t\t.rssi_thold = rssi_thold,\n\t};\n\tstruct {\n\t\tstruct wmi_cmd_hdr hdr;\n\t\tstruct wmi_set_link_monitor_event evt;\n\t} __packed reply = {\n\t\t.evt = {.status = WMI_FW_STATUS_FAILURE},\n\t};\n\n\tif (rssi_thold > S8_MAX || rssi_thold < S8_MIN || rssi_hyst > U8_MAX)\n\t\treturn -EINVAL;\n\n\trc = wmi_call(wil, WMI_SET_LINK_MONITOR_CMDID, vif->mid, &cmd,\n\t\t      sizeof(cmd), WMI_SET_LINK_MONITOR_EVENTID,\n\t\t      &reply, sizeof(reply), WIL_WMI_CALL_GENERAL_TO_MS);\n\tif (rc) {\n\t\twil_err(wil, \"WMI_SET_LINK_MONITOR_CMDID failed, rc %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tif (reply.evt.status != WMI_FW_STATUS_SUCCESS) {\n\t\twil_err(wil, \"WMI_SET_LINK_MONITOR_CMDID failed, status %d\\n\",\n\t\t\treply.evt.status);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}