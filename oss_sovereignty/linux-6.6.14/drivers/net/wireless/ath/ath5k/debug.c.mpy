{
  "module_name": "debug.c",
  "hash_id": "ae27e79d4d7b2e0d0e06d387d5effd9335b321cd27464518d32a91925ff95888",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath5k/debug.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/vmalloc.h>\n\n#include <linux/seq_file.h>\n#include <linux/list.h>\n#include \"debug.h\"\n#include \"ath5k.h\"\n#include \"reg.h\"\n#include \"base.h\"\n\nstatic unsigned int ath5k_debug;\nmodule_param_named(debug, ath5k_debug, uint, 0);\n\n\n \n\nstruct reg {\n\tconst char *name;\n\tint addr;\n};\n\n#define REG_STRUCT_INIT(r) { #r, r }\n\n \nstatic const struct reg regs[] = {\n\tREG_STRUCT_INIT(AR5K_CR),\n\tREG_STRUCT_INIT(AR5K_RXDP),\n\tREG_STRUCT_INIT(AR5K_CFG),\n\tREG_STRUCT_INIT(AR5K_IER),\n\tREG_STRUCT_INIT(AR5K_BCR),\n\tREG_STRUCT_INIT(AR5K_RTSD0),\n\tREG_STRUCT_INIT(AR5K_RTSD1),\n\tREG_STRUCT_INIT(AR5K_TXCFG),\n\tREG_STRUCT_INIT(AR5K_RXCFG),\n\tREG_STRUCT_INIT(AR5K_RXJLA),\n\tREG_STRUCT_INIT(AR5K_MIBC),\n\tREG_STRUCT_INIT(AR5K_TOPS),\n\tREG_STRUCT_INIT(AR5K_RXNOFRM),\n\tREG_STRUCT_INIT(AR5K_TXNOFRM),\n\tREG_STRUCT_INIT(AR5K_RPGTO),\n\tREG_STRUCT_INIT(AR5K_RFCNT),\n\tREG_STRUCT_INIT(AR5K_MISC),\n\tREG_STRUCT_INIT(AR5K_QCUDCU_CLKGT),\n\tREG_STRUCT_INIT(AR5K_ISR),\n\tREG_STRUCT_INIT(AR5K_PISR),\n\tREG_STRUCT_INIT(AR5K_SISR0),\n\tREG_STRUCT_INIT(AR5K_SISR1),\n\tREG_STRUCT_INIT(AR5K_SISR2),\n\tREG_STRUCT_INIT(AR5K_SISR3),\n\tREG_STRUCT_INIT(AR5K_SISR4),\n\tREG_STRUCT_INIT(AR5K_IMR),\n\tREG_STRUCT_INIT(AR5K_PIMR),\n\tREG_STRUCT_INIT(AR5K_SIMR0),\n\tREG_STRUCT_INIT(AR5K_SIMR1),\n\tREG_STRUCT_INIT(AR5K_SIMR2),\n\tREG_STRUCT_INIT(AR5K_SIMR3),\n\tREG_STRUCT_INIT(AR5K_SIMR4),\n\tREG_STRUCT_INIT(AR5K_DCM_ADDR),\n\tREG_STRUCT_INIT(AR5K_DCCFG),\n\tREG_STRUCT_INIT(AR5K_CCFG),\n\tREG_STRUCT_INIT(AR5K_CPC0),\n\tREG_STRUCT_INIT(AR5K_CPC1),\n\tREG_STRUCT_INIT(AR5K_CPC2),\n\tREG_STRUCT_INIT(AR5K_CPC3),\n\tREG_STRUCT_INIT(AR5K_CPCOVF),\n\tREG_STRUCT_INIT(AR5K_RESET_CTL),\n\tREG_STRUCT_INIT(AR5K_SLEEP_CTL),\n\tREG_STRUCT_INIT(AR5K_INTPEND),\n\tREG_STRUCT_INIT(AR5K_SFR),\n\tREG_STRUCT_INIT(AR5K_PCICFG),\n\tREG_STRUCT_INIT(AR5K_GPIOCR),\n\tREG_STRUCT_INIT(AR5K_GPIODO),\n\tREG_STRUCT_INIT(AR5K_SREV),\n};\n\nstatic void *reg_start(struct seq_file *seq, loff_t *pos)\n{\n\treturn *pos < ARRAY_SIZE(regs) ? (void *)&regs[*pos] : NULL;\n}\n\nstatic void reg_stop(struct seq_file *seq, void *p)\n{\n\t \n}\n\nstatic void *reg_next(struct seq_file *seq, void *p, loff_t *pos)\n{\n\t++*pos;\n\treturn *pos < ARRAY_SIZE(regs) ? (void *)&regs[*pos] : NULL;\n}\n\nstatic int reg_show(struct seq_file *seq, void *p)\n{\n\tstruct ath5k_hw *ah = seq->private;\n\tstruct reg *r = p;\n\tseq_printf(seq, \"%-25s0x%08x\\n\", r->name,\n\t\tath5k_hw_reg_read(ah, r->addr));\n\treturn 0;\n}\n\nstatic const struct seq_operations registers_sops = {\n\t.start = reg_start,\n\t.next  = reg_next,\n\t.stop  = reg_stop,\n\t.show  = reg_show\n};\n\nDEFINE_SEQ_ATTRIBUTE(registers);\n\n \n\nstatic ssize_t read_file_beacon(struct file *file, char __user *user_buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct ath5k_hw *ah = file->private_data;\n\tchar buf[500];\n\tunsigned int len = 0;\n\tunsigned int v;\n\tu64 tsf;\n\n\tv = ath5k_hw_reg_read(ah, AR5K_BEACON);\n\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\"%-24s0x%08x\\tintval: %d\\tTIM: 0x%x\\n\",\n\t\t\"AR5K_BEACON\", v, v & AR5K_BEACON_PERIOD,\n\t\t(v & AR5K_BEACON_TIM) >> AR5K_BEACON_TIM_S);\n\n\tlen += scnprintf(buf + len, sizeof(buf) - len, \"%-24s0x%08x\\n\",\n\t\t\"AR5K_LAST_TSTP\", ath5k_hw_reg_read(ah, AR5K_LAST_TSTP));\n\n\tlen += scnprintf(buf + len, sizeof(buf) - len, \"%-24s0x%08x\\n\\n\",\n\t\t\"AR5K_BEACON_CNT\", ath5k_hw_reg_read(ah, AR5K_BEACON_CNT));\n\n\tv = ath5k_hw_reg_read(ah, AR5K_TIMER0);\n\tlen += scnprintf(buf + len, sizeof(buf) - len, \"%-24s0x%08x\\tTU: %08x\\n\",\n\t\t\"AR5K_TIMER0 (TBTT)\", v, v);\n\n\tv = ath5k_hw_reg_read(ah, AR5K_TIMER1);\n\tlen += scnprintf(buf + len, sizeof(buf) - len, \"%-24s0x%08x\\tTU: %08x\\n\",\n\t\t\"AR5K_TIMER1 (DMA)\", v, v >> 3);\n\n\tv = ath5k_hw_reg_read(ah, AR5K_TIMER2);\n\tlen += scnprintf(buf + len, sizeof(buf) - len, \"%-24s0x%08x\\tTU: %08x\\n\",\n\t\t\"AR5K_TIMER2 (SWBA)\", v, v >> 3);\n\n\tv = ath5k_hw_reg_read(ah, AR5K_TIMER3);\n\tlen += scnprintf(buf + len, sizeof(buf) - len, \"%-24s0x%08x\\tTU: %08x\\n\",\n\t\t\"AR5K_TIMER3 (ATIM)\", v, v);\n\n\ttsf = ath5k_hw_get_tsf64(ah);\n\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\"TSF\\t\\t0x%016llx\\tTU: %08x\\n\",\n\t\t(unsigned long long)tsf, TSF_TO_TU(tsf));\n\n\tif (len > sizeof(buf))\n\t\tlen = sizeof(buf);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic ssize_t write_file_beacon(struct file *file,\n\t\t\t\t const char __user *userbuf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct ath5k_hw *ah = file->private_data;\n\tchar buf[20];\n\n\tcount = min_t(size_t, count, sizeof(buf) - 1);\n\tif (copy_from_user(buf, userbuf, count))\n\t\treturn -EFAULT;\n\n\tbuf[count] = '\\0';\n\tif (strncmp(buf, \"disable\", 7) == 0) {\n\t\tAR5K_REG_DISABLE_BITS(ah, AR5K_BEACON, AR5K_BEACON_ENABLE);\n\t\tpr_info(\"debugfs disable beacons\\n\");\n\t} else if (strncmp(buf, \"enable\", 6) == 0) {\n\t\tAR5K_REG_ENABLE_BITS(ah, AR5K_BEACON, AR5K_BEACON_ENABLE);\n\t\tpr_info(\"debugfs enable beacons\\n\");\n\t}\n\treturn count;\n}\n\nstatic const struct file_operations fops_beacon = {\n\t.read = read_file_beacon,\n\t.write = write_file_beacon,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\n\n \n\nstatic ssize_t write_file_reset(struct file *file,\n\t\t\t\t const char __user *userbuf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct ath5k_hw *ah = file->private_data;\n\tATH5K_DBG(ah, ATH5K_DEBUG_RESET, \"debug file triggered reset\\n\");\n\tieee80211_queue_work(ah->hw, &ah->reset_work);\n\treturn count;\n}\n\nstatic const struct file_operations fops_reset = {\n\t.write = write_file_reset,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = noop_llseek,\n};\n\n\n \n\nstatic const struct {\n\tenum ath5k_debug_level level;\n\tconst char *name;\n\tconst char *desc;\n} dbg_info[] = {\n\t{ ATH5K_DEBUG_RESET,\t\"reset\",\t\"reset and initialization\" },\n\t{ ATH5K_DEBUG_INTR,\t\"intr\",\t\t\"interrupt handling\" },\n\t{ ATH5K_DEBUG_MODE,\t\"mode\",\t\t\"mode init/setup\" },\n\t{ ATH5K_DEBUG_XMIT,\t\"xmit\",\t\t\"basic xmit operation\" },\n\t{ ATH5K_DEBUG_BEACON,\t\"beacon\",\t\"beacon handling\" },\n\t{ ATH5K_DEBUG_CALIBRATE, \"calib\",\t\"periodic calibration\" },\n\t{ ATH5K_DEBUG_TXPOWER,\t\"txpower\",\t\"transmit power setting\" },\n\t{ ATH5K_DEBUG_LED,\t\"led\",\t\t\"LED management\" },\n\t{ ATH5K_DEBUG_DUMPBANDS, \"dumpbands\",\t\"dump bands\" },\n\t{ ATH5K_DEBUG_DMA,\t\"dma\",\t\t\"dma start/stop\" },\n\t{ ATH5K_DEBUG_ANI,\t\"ani\",\t\t\"adaptive noise immunity\" },\n\t{ ATH5K_DEBUG_DESC,\t\"desc\",\t\t\"descriptor chains\" },\n\t{ ATH5K_DEBUG_ANY,\t\"all\",\t\t\"show all debug levels\" },\n};\n\nstatic ssize_t read_file_debug(struct file *file, char __user *user_buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct ath5k_hw *ah = file->private_data;\n\tchar buf[700];\n\tunsigned int len = 0;\n\tunsigned int i;\n\n\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\"DEBUG LEVEL: 0x%08x\\n\\n\", ah->debug.level);\n\n\tfor (i = 0; i < ARRAY_SIZE(dbg_info) - 1; i++) {\n\t\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\t\"%10s %c 0x%08x - %s\\n\", dbg_info[i].name,\n\t\t\tah->debug.level & dbg_info[i].level ? '+' : ' ',\n\t\t\tdbg_info[i].level, dbg_info[i].desc);\n\t}\n\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\"%10s %c 0x%08x - %s\\n\", dbg_info[i].name,\n\t\tah->debug.level == dbg_info[i].level ? '+' : ' ',\n\t\tdbg_info[i].level, dbg_info[i].desc);\n\n\tif (len > sizeof(buf))\n\t\tlen = sizeof(buf);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic ssize_t write_file_debug(struct file *file,\n\t\t\t\t const char __user *userbuf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct ath5k_hw *ah = file->private_data;\n\tunsigned int i;\n\tchar buf[20];\n\n\tcount = min_t(size_t, count, sizeof(buf) - 1);\n\tif (copy_from_user(buf, userbuf, count))\n\t\treturn -EFAULT;\n\n\tbuf[count] = '\\0';\n\tfor (i = 0; i < ARRAY_SIZE(dbg_info); i++) {\n\t\tif (strncmp(buf, dbg_info[i].name,\n\t\t\t\t\tstrlen(dbg_info[i].name)) == 0) {\n\t\t\tah->debug.level ^= dbg_info[i].level;  \n\t\t\tbreak;\n\t\t}\n\t}\n\treturn count;\n}\n\nstatic const struct file_operations fops_debug = {\n\t.read = read_file_debug,\n\t.write = write_file_debug,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\n\n \n\nstatic ssize_t read_file_antenna(struct file *file, char __user *user_buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct ath5k_hw *ah = file->private_data;\n\tchar buf[700];\n\tunsigned int len = 0;\n\tunsigned int i;\n\tunsigned int v;\n\n\tlen += scnprintf(buf + len, sizeof(buf) - len, \"antenna mode\\t%d\\n\",\n\t\tah->ah_ant_mode);\n\tlen += scnprintf(buf + len, sizeof(buf) - len, \"default antenna\\t%d\\n\",\n\t\tah->ah_def_ant);\n\tlen += scnprintf(buf + len, sizeof(buf) - len, \"tx antenna\\t%d\\n\",\n\t\tah->ah_tx_ant);\n\n\tlen += scnprintf(buf + len, sizeof(buf) - len, \"\\nANTENNA\\t\\tRX\\tTX\\n\");\n\tfor (i = 1; i < ARRAY_SIZE(ah->stats.antenna_rx); i++) {\n\t\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\t\"[antenna %d]\\t%d\\t%d\\n\",\n\t\t\ti, ah->stats.antenna_rx[i], ah->stats.antenna_tx[i]);\n\t}\n\tlen += scnprintf(buf + len, sizeof(buf) - len, \"[invalid]\\t%d\\t%d\\n\",\n\t\t\tah->stats.antenna_rx[0], ah->stats.antenna_tx[0]);\n\n\tv = ath5k_hw_reg_read(ah, AR5K_DEFAULT_ANTENNA);\n\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\t\"\\nAR5K_DEFAULT_ANTENNA\\t0x%08x\\n\", v);\n\n\tv = ath5k_hw_reg_read(ah, AR5K_STA_ID1);\n\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\"AR5K_STA_ID1_DEFAULT_ANTENNA\\t%d\\n\",\n\t\t(v & AR5K_STA_ID1_DEFAULT_ANTENNA) != 0);\n\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\"AR5K_STA_ID1_DESC_ANTENNA\\t%d\\n\",\n\t\t(v & AR5K_STA_ID1_DESC_ANTENNA) != 0);\n\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\"AR5K_STA_ID1_RTS_DEF_ANTENNA\\t%d\\n\",\n\t\t(v & AR5K_STA_ID1_RTS_DEF_ANTENNA) != 0);\n\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\"AR5K_STA_ID1_SELFGEN_DEF_ANT\\t%d\\n\",\n\t\t(v & AR5K_STA_ID1_SELFGEN_DEF_ANT) != 0);\n\n\tv = ath5k_hw_reg_read(ah, AR5K_PHY_AGCCTL);\n\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\"\\nAR5K_PHY_AGCCTL_OFDM_DIV_DIS\\t%d\\n\",\n\t\t(v & AR5K_PHY_AGCCTL_OFDM_DIV_DIS) != 0);\n\n\tv = ath5k_hw_reg_read(ah, AR5K_PHY_RESTART);\n\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\"AR5K_PHY_RESTART_DIV_GC\\t\\t%x\\n\",\n\t\t(v & AR5K_PHY_RESTART_DIV_GC) >> AR5K_PHY_RESTART_DIV_GC_S);\n\n\tv = ath5k_hw_reg_read(ah, AR5K_PHY_FAST_ANT_DIV);\n\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\"AR5K_PHY_FAST_ANT_DIV_EN\\t%d\\n\",\n\t\t(v & AR5K_PHY_FAST_ANT_DIV_EN) != 0);\n\n\tv = ath5k_hw_reg_read(ah, AR5K_PHY_ANT_SWITCH_TABLE_0);\n\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\t\"\\nAR5K_PHY_ANT_SWITCH_TABLE_0\\t0x%08x\\n\", v);\n\tv = ath5k_hw_reg_read(ah, AR5K_PHY_ANT_SWITCH_TABLE_1);\n\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\t\"AR5K_PHY_ANT_SWITCH_TABLE_1\\t0x%08x\\n\", v);\n\n\tif (len > sizeof(buf))\n\t\tlen = sizeof(buf);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic ssize_t write_file_antenna(struct file *file,\n\t\t\t\t const char __user *userbuf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct ath5k_hw *ah = file->private_data;\n\tunsigned int i;\n\tchar buf[20];\n\n\tcount = min_t(size_t, count, sizeof(buf) - 1);\n\tif (copy_from_user(buf, userbuf, count))\n\t\treturn -EFAULT;\n\n\tbuf[count] = '\\0';\n\tif (strncmp(buf, \"diversity\", 9) == 0) {\n\t\tath5k_hw_set_antenna_mode(ah, AR5K_ANTMODE_DEFAULT);\n\t\tpr_info(\"debug: enable diversity\\n\");\n\t} else if (strncmp(buf, \"fixed-a\", 7) == 0) {\n\t\tath5k_hw_set_antenna_mode(ah, AR5K_ANTMODE_FIXED_A);\n\t\tpr_info(\"debug: fixed antenna A\\n\");\n\t} else if (strncmp(buf, \"fixed-b\", 7) == 0) {\n\t\tath5k_hw_set_antenna_mode(ah, AR5K_ANTMODE_FIXED_B);\n\t\tpr_info(\"debug: fixed antenna B\\n\");\n\t} else if (strncmp(buf, \"clear\", 5) == 0) {\n\t\tfor (i = 0; i < ARRAY_SIZE(ah->stats.antenna_rx); i++) {\n\t\t\tah->stats.antenna_rx[i] = 0;\n\t\t\tah->stats.antenna_tx[i] = 0;\n\t\t}\n\t\tpr_info(\"debug: cleared antenna stats\\n\");\n\t}\n\treturn count;\n}\n\nstatic const struct file_operations fops_antenna = {\n\t.read = read_file_antenna,\n\t.write = write_file_antenna,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\n \n\nstatic ssize_t read_file_misc(struct file *file, char __user *user_buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct ath5k_hw *ah = file->private_data;\n\tchar buf[700];\n\tunsigned int len = 0;\n\tu32 filt = ath5k_hw_get_rx_filter(ah);\n\n\tlen += scnprintf(buf + len, sizeof(buf) - len, \"bssid-mask: %pM\\n\",\n\t\t\tah->bssidmask);\n\tlen += scnprintf(buf + len, sizeof(buf) - len, \"filter-flags: 0x%x \",\n\t\t\tfilt);\n\tif (filt & AR5K_RX_FILTER_UCAST)\n\t\tlen += scnprintf(buf + len, sizeof(buf) - len, \" UCAST\");\n\tif (filt & AR5K_RX_FILTER_MCAST)\n\t\tlen += scnprintf(buf + len, sizeof(buf) - len, \" MCAST\");\n\tif (filt & AR5K_RX_FILTER_BCAST)\n\t\tlen += scnprintf(buf + len, sizeof(buf) - len, \" BCAST\");\n\tif (filt & AR5K_RX_FILTER_CONTROL)\n\t\tlen += scnprintf(buf + len, sizeof(buf) - len, \" CONTROL\");\n\tif (filt & AR5K_RX_FILTER_BEACON)\n\t\tlen += scnprintf(buf + len, sizeof(buf) - len, \" BEACON\");\n\tif (filt & AR5K_RX_FILTER_PROM)\n\t\tlen += scnprintf(buf + len, sizeof(buf) - len, \" PROM\");\n\tif (filt & AR5K_RX_FILTER_XRPOLL)\n\t\tlen += scnprintf(buf + len, sizeof(buf) - len, \" XRPOLL\");\n\tif (filt & AR5K_RX_FILTER_PROBEREQ)\n\t\tlen += scnprintf(buf + len, sizeof(buf) - len, \" PROBEREQ\");\n\tif (filt & AR5K_RX_FILTER_PHYERR_5212)\n\t\tlen += scnprintf(buf + len, sizeof(buf) - len, \" PHYERR-5212\");\n\tif (filt & AR5K_RX_FILTER_RADARERR_5212)\n\t\tlen += scnprintf(buf + len, sizeof(buf) - len, \" RADARERR-5212\");\n\tif (filt & AR5K_RX_FILTER_PHYERR_5211)\n\t\tsnprintf(buf + len, sizeof(buf) - len, \" PHYERR-5211\");\n\tif (filt & AR5K_RX_FILTER_RADARERR_5211)\n\t\tlen += scnprintf(buf + len, sizeof(buf) - len, \" RADARERR-5211\");\n\n\tlen += scnprintf(buf + len, sizeof(buf) - len, \"\\nopmode: %s (%d)\\n\",\n\t\t\tath_opmode_to_string(ah->opmode), ah->opmode);\n\n\tif (len > sizeof(buf))\n\t\tlen = sizeof(buf);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic const struct file_operations fops_misc = {\n\t.read = read_file_misc,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n};\n\n\n \n\nstatic ssize_t read_file_frameerrors(struct file *file, char __user *user_buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct ath5k_hw *ah = file->private_data;\n\tstruct ath5k_statistics *st = &ah->stats;\n\tchar buf[700];\n\tunsigned int len = 0;\n\tint i;\n\n\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\t\"RX\\n---------------------\\n\");\n\tlen += scnprintf(buf + len, sizeof(buf) - len, \"CRC\\t%u\\t(%u%%)\\n\",\n\t\t\tst->rxerr_crc,\n\t\t\tst->rx_all_count > 0 ?\n\t\t\t\tst->rxerr_crc * 100 / st->rx_all_count : 0);\n\tlen += scnprintf(buf + len, sizeof(buf) - len, \"PHY\\t%u\\t(%u%%)\\n\",\n\t\t\tst->rxerr_phy,\n\t\t\tst->rx_all_count > 0 ?\n\t\t\t\tst->rxerr_phy * 100 / st->rx_all_count : 0);\n\tfor (i = 0; i < 32; i++) {\n\t\tif (st->rxerr_phy_code[i])\n\t\t\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\t\t\" phy_err[%u]\\t%u\\n\",\n\t\t\t\ti, st->rxerr_phy_code[i]);\n\t}\n\n\tlen += scnprintf(buf + len, sizeof(buf) - len, \"FIFO\\t%u\\t(%u%%)\\n\",\n\t\t\tst->rxerr_fifo,\n\t\t\tst->rx_all_count > 0 ?\n\t\t\t\tst->rxerr_fifo * 100 / st->rx_all_count : 0);\n\tlen += scnprintf(buf + len, sizeof(buf) - len, \"decrypt\\t%u\\t(%u%%)\\n\",\n\t\t\tst->rxerr_decrypt,\n\t\t\tst->rx_all_count > 0 ?\n\t\t\t\tst->rxerr_decrypt * 100 / st->rx_all_count : 0);\n\tlen += scnprintf(buf + len, sizeof(buf) - len, \"MIC\\t%u\\t(%u%%)\\n\",\n\t\t\tst->rxerr_mic,\n\t\t\tst->rx_all_count > 0 ?\n\t\t\t\tst->rxerr_mic * 100 / st->rx_all_count : 0);\n\tlen += scnprintf(buf + len, sizeof(buf) - len, \"process\\t%u\\t(%u%%)\\n\",\n\t\t\tst->rxerr_proc,\n\t\t\tst->rx_all_count > 0 ?\n\t\t\t\tst->rxerr_proc * 100 / st->rx_all_count : 0);\n\tlen += scnprintf(buf + len, sizeof(buf) - len, \"jumbo\\t%u\\t(%u%%)\\n\",\n\t\t\tst->rxerr_jumbo,\n\t\t\tst->rx_all_count > 0 ?\n\t\t\t\tst->rxerr_jumbo * 100 / st->rx_all_count : 0);\n\tlen += scnprintf(buf + len, sizeof(buf) - len, \"[RX all\\t%u]\\n\",\n\t\t\tst->rx_all_count);\n\tlen += scnprintf(buf + len, sizeof(buf) - len, \"RX-all-bytes\\t%u\\n\",\n\t\t\tst->rx_bytes_count);\n\n\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\t\"\\nTX\\n---------------------\\n\");\n\tlen += scnprintf(buf + len, sizeof(buf) - len, \"retry\\t%u\\t(%u%%)\\n\",\n\t\t\tst->txerr_retry,\n\t\t\tst->tx_all_count > 0 ?\n\t\t\t\tst->txerr_retry * 100 / st->tx_all_count : 0);\n\tlen += scnprintf(buf + len, sizeof(buf) - len, \"FIFO\\t%u\\t(%u%%)\\n\",\n\t\t\tst->txerr_fifo,\n\t\t\tst->tx_all_count > 0 ?\n\t\t\t\tst->txerr_fifo * 100 / st->tx_all_count : 0);\n\tlen += scnprintf(buf + len, sizeof(buf) - len, \"filter\\t%u\\t(%u%%)\\n\",\n\t\t\tst->txerr_filt,\n\t\t\tst->tx_all_count > 0 ?\n\t\t\t\tst->txerr_filt * 100 / st->tx_all_count : 0);\n\tlen += scnprintf(buf + len, sizeof(buf) - len, \"[TX all\\t%u]\\n\",\n\t\t\tst->tx_all_count);\n\tlen += scnprintf(buf + len, sizeof(buf) - len, \"TX-all-bytes\\t%u\\n\",\n\t\t\tst->tx_bytes_count);\n\n\tif (len > sizeof(buf))\n\t\tlen = sizeof(buf);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic ssize_t write_file_frameerrors(struct file *file,\n\t\t\t\t const char __user *userbuf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct ath5k_hw *ah = file->private_data;\n\tstruct ath5k_statistics *st = &ah->stats;\n\tchar buf[20];\n\n\tcount = min_t(size_t, count, sizeof(buf) - 1);\n\tif (copy_from_user(buf, userbuf, count))\n\t\treturn -EFAULT;\n\n\tbuf[count] = '\\0';\n\tif (strncmp(buf, \"clear\", 5) == 0) {\n\t\tst->rxerr_crc = 0;\n\t\tst->rxerr_phy = 0;\n\t\tst->rxerr_fifo = 0;\n\t\tst->rxerr_decrypt = 0;\n\t\tst->rxerr_mic = 0;\n\t\tst->rxerr_proc = 0;\n\t\tst->rxerr_jumbo = 0;\n\t\tst->rx_all_count = 0;\n\t\tst->txerr_retry = 0;\n\t\tst->txerr_fifo = 0;\n\t\tst->txerr_filt = 0;\n\t\tst->tx_all_count = 0;\n\t\tpr_info(\"debug: cleared frameerrors stats\\n\");\n\t}\n\treturn count;\n}\n\nstatic const struct file_operations fops_frameerrors = {\n\t.read = read_file_frameerrors,\n\t.write = write_file_frameerrors,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\n\n \n\nstatic ssize_t read_file_ani(struct file *file, char __user *user_buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct ath5k_hw *ah = file->private_data;\n\tstruct ath5k_statistics *st = &ah->stats;\n\tstruct ath5k_ani_state *as = &ah->ani_state;\n\n\tchar buf[700];\n\tunsigned int len = 0;\n\n\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\t\"HW has PHY error counters:\\t%s\\n\",\n\t\t\tah->ah_capabilities.cap_has_phyerr_counters ?\n\t\t\t\"yes\" : \"no\");\n\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\t\"HW max spur immunity level:\\t%d\\n\",\n\t\t\tas->max_spur_level);\n\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\"\\nANI state\\n--------------------------------------------\\n\");\n\tlen += scnprintf(buf + len, sizeof(buf) - len, \"operating mode:\\t\\t\\t\");\n\tswitch (as->ani_mode) {\n\tcase ATH5K_ANI_MODE_OFF:\n\t\tlen += scnprintf(buf + len, sizeof(buf) - len, \"OFF\\n\");\n\t\tbreak;\n\tcase ATH5K_ANI_MODE_MANUAL_LOW:\n\t\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\t\"MANUAL LOW\\n\");\n\t\tbreak;\n\tcase ATH5K_ANI_MODE_MANUAL_HIGH:\n\t\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\t\"MANUAL HIGH\\n\");\n\t\tbreak;\n\tcase ATH5K_ANI_MODE_AUTO:\n\t\tlen += scnprintf(buf + len, sizeof(buf) - len, \"AUTO\\n\");\n\t\tbreak;\n\tdefault:\n\t\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\t\"??? (not good)\\n\");\n\t\tbreak;\n\t}\n\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\t\"noise immunity level:\\t\\t%d\\n\",\n\t\t\tas->noise_imm_level);\n\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\t\"spur immunity level:\\t\\t%d\\n\",\n\t\t\tas->spur_level);\n\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\t\"firstep level:\\t\\t\\t%d\\n\",\n\t\t\tas->firstep_level);\n\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\t\"OFDM weak signal detection:\\t%s\\n\",\n\t\t\tas->ofdm_weak_sig ? \"on\" : \"off\");\n\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\t\"CCK weak signal detection:\\t%s\\n\",\n\t\t\tas->cck_weak_sig ? \"on\" : \"off\");\n\n\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\t\"\\nMIB INTERRUPTS:\\t\\t%u\\n\",\n\t\t\tst->mib_intr);\n\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\t\"beacon RSSI average:\\t%d\\n\",\n\t\t\t(int)ewma_beacon_rssi_read(&ah->ah_beacon_rssi_avg));\n\n#define CC_PRINT(_struct, _field) \\\n\t_struct._field, \\\n\t_struct.cycles > 0 ? \\\n\t_struct._field * 100 / _struct.cycles : 0\n\n\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\t\"profcnt tx\\t\\t%u\\t(%d%%)\\n\",\n\t\t\tCC_PRINT(as->last_cc, tx_frame));\n\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\t\"profcnt rx\\t\\t%u\\t(%d%%)\\n\",\n\t\t\tCC_PRINT(as->last_cc, rx_frame));\n\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\t\"profcnt busy\\t\\t%u\\t(%d%%)\\n\",\n\t\t\tCC_PRINT(as->last_cc, rx_busy));\n#undef CC_PRINT\n\tlen += scnprintf(buf + len, sizeof(buf) - len, \"profcnt cycles\\t\\t%u\\n\",\n\t\t\tas->last_cc.cycles);\n\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\t\"listen time\\t\\t%d\\tlast: %d\\n\",\n\t\t\tas->listen_time, as->last_listen);\n\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\t\"OFDM errors\\t\\t%u\\tlast: %u\\tsum: %u\\n\",\n\t\t\tas->ofdm_errors, as->last_ofdm_errors,\n\t\t\tas->sum_ofdm_errors);\n\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\t\"CCK errors\\t\\t%u\\tlast: %u\\tsum: %u\\n\",\n\t\t\tas->cck_errors, as->last_cck_errors,\n\t\t\tas->sum_cck_errors);\n\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\t\"AR5K_PHYERR_CNT1\\t%x\\t(=%d)\\n\",\n\t\t\tath5k_hw_reg_read(ah, AR5K_PHYERR_CNT1),\n\t\t\tATH5K_ANI_OFDM_TRIG_HIGH - (ATH5K_PHYERR_CNT_MAX -\n\t\t\tath5k_hw_reg_read(ah, AR5K_PHYERR_CNT1)));\n\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\t\"AR5K_PHYERR_CNT2\\t%x\\t(=%d)\\n\",\n\t\t\tath5k_hw_reg_read(ah, AR5K_PHYERR_CNT2),\n\t\t\tATH5K_ANI_CCK_TRIG_HIGH - (ATH5K_PHYERR_CNT_MAX -\n\t\t\tath5k_hw_reg_read(ah, AR5K_PHYERR_CNT2)));\n\n\tif (len > sizeof(buf))\n\t\tlen = sizeof(buf);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic ssize_t write_file_ani(struct file *file,\n\t\t\t\t const char __user *userbuf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct ath5k_hw *ah = file->private_data;\n\tchar buf[20];\n\n\tcount = min_t(size_t, count, sizeof(buf) - 1);\n\tif (copy_from_user(buf, userbuf, count))\n\t\treturn -EFAULT;\n\n\tbuf[count] = '\\0';\n\tif (strncmp(buf, \"sens-low\", 8) == 0) {\n\t\tath5k_ani_init(ah, ATH5K_ANI_MODE_MANUAL_HIGH);\n\t} else if (strncmp(buf, \"sens-high\", 9) == 0) {\n\t\tath5k_ani_init(ah, ATH5K_ANI_MODE_MANUAL_LOW);\n\t} else if (strncmp(buf, \"ani-off\", 7) == 0) {\n\t\tath5k_ani_init(ah, ATH5K_ANI_MODE_OFF);\n\t} else if (strncmp(buf, \"ani-on\", 6) == 0) {\n\t\tath5k_ani_init(ah, ATH5K_ANI_MODE_AUTO);\n\t} else if (strncmp(buf, \"noise-low\", 9) == 0) {\n\t\tath5k_ani_set_noise_immunity_level(ah, 0);\n\t} else if (strncmp(buf, \"noise-high\", 10) == 0) {\n\t\tath5k_ani_set_noise_immunity_level(ah,\n\t\t\t\t\t\t   ATH5K_ANI_MAX_NOISE_IMM_LVL);\n\t} else if (strncmp(buf, \"spur-low\", 8) == 0) {\n\t\tath5k_ani_set_spur_immunity_level(ah, 0);\n\t} else if (strncmp(buf, \"spur-high\", 9) == 0) {\n\t\tath5k_ani_set_spur_immunity_level(ah,\n\t\t\t\t\t\t  ah->ani_state.max_spur_level);\n\t} else if (strncmp(buf, \"fir-low\", 7) == 0) {\n\t\tath5k_ani_set_firstep_level(ah, 0);\n\t} else if (strncmp(buf, \"fir-high\", 8) == 0) {\n\t\tath5k_ani_set_firstep_level(ah, ATH5K_ANI_MAX_FIRSTEP_LVL);\n\t} else if (strncmp(buf, \"ofdm-off\", 8) == 0) {\n\t\tath5k_ani_set_ofdm_weak_signal_detection(ah, false);\n\t} else if (strncmp(buf, \"ofdm-on\", 7) == 0) {\n\t\tath5k_ani_set_ofdm_weak_signal_detection(ah, true);\n\t} else if (strncmp(buf, \"cck-off\", 7) == 0) {\n\t\tath5k_ani_set_cck_weak_signal_detection(ah, false);\n\t} else if (strncmp(buf, \"cck-on\", 6) == 0) {\n\t\tath5k_ani_set_cck_weak_signal_detection(ah, true);\n\t}\n\treturn count;\n}\n\nstatic const struct file_operations fops_ani = {\n\t.read = read_file_ani,\n\t.write = write_file_ani,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\n\n \n\nstatic ssize_t read_file_queue(struct file *file, char __user *user_buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct ath5k_hw *ah = file->private_data;\n\tchar buf[700];\n\tunsigned int len = 0;\n\n\tstruct ath5k_txq *txq;\n\tstruct ath5k_buf *bf, *bf0;\n\tint i, n;\n\n\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\t\"available txbuffers: %d\\n\", ah->txbuf_len);\n\n\tfor (i = 0; i < ARRAY_SIZE(ah->txqs); i++) {\n\t\ttxq = &ah->txqs[i];\n\n\t\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\t\"%02d: %ssetup\\n\", i, txq->setup ? \"\" : \"not \");\n\n\t\tif (!txq->setup)\n\t\t\tcontinue;\n\n\t\tn = 0;\n\t\tspin_lock_bh(&txq->lock);\n\t\tlist_for_each_entry_safe(bf, bf0, &txq->q, list)\n\t\t\tn++;\n\t\tspin_unlock_bh(&txq->lock);\n\n\t\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\t\t\"  len: %d bufs: %d\\n\", txq->txq_len, n);\n\t\tlen += scnprintf(buf + len, sizeof(buf) - len,\n\t\t\t\t\"  stuck: %d\\n\", txq->txq_stuck);\n\t}\n\n\tif (len > sizeof(buf))\n\t\tlen = sizeof(buf);\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, len);\n}\n\nstatic ssize_t write_file_queue(struct file *file,\n\t\t\t\t const char __user *userbuf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct ath5k_hw *ah = file->private_data;\n\tchar buf[20];\n\n\tcount = min_t(size_t, count, sizeof(buf) - 1);\n\tif (copy_from_user(buf, userbuf, count))\n\t\treturn -EFAULT;\n\n\tbuf[count] = '\\0';\n\tif (strncmp(buf, \"start\", 5) == 0)\n\t\tieee80211_wake_queues(ah->hw);\n\telse if (strncmp(buf, \"stop\", 4) == 0)\n\t\tieee80211_stop_queues(ah->hw);\n\n\treturn count;\n}\n\n\nstatic const struct file_operations fops_queue = {\n\t.read = read_file_queue,\n\t.write = write_file_queue,\n\t.open = simple_open,\n\t.owner = THIS_MODULE,\n\t.llseek = default_llseek,\n};\n\n \n\nstruct eeprom_private {\n\tu16 *buf;\n\tint len;\n};\n\nstatic int open_file_eeprom(struct inode *inode, struct file *file)\n{\n\tstruct eeprom_private *ep;\n\tstruct ath5k_hw *ah = inode->i_private;\n\tbool res;\n\tint i, ret;\n\tu32 eesize;\t \n\tu16 val, *buf;\n\n\t \n\n\tres = ath5k_hw_nvram_read(ah, AR5K_EEPROM_SIZE_UPPER, &val);\n\tif (!res)\n\t\treturn -EACCES;\n\n\tif (val == 0) {\n\t\teesize = AR5K_EEPROM_INFO_MAX + AR5K_EEPROM_INFO_BASE;\n\t} else {\n\t\teesize = (val & AR5K_EEPROM_SIZE_UPPER_MASK) <<\n\t\t\tAR5K_EEPROM_SIZE_ENDLOC_SHIFT;\n\t\tath5k_hw_nvram_read(ah, AR5K_EEPROM_SIZE_LOWER, &val);\n\t\teesize = eesize | val;\n\t}\n\n\tif (eesize > 4096)\n\t\treturn -EINVAL;\n\n\t \n\n\tbuf = vmalloc(array_size(eesize, 2));\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tfor (i = 0; i < eesize; ++i) {\n\t\tif (!ath5k_hw_nvram_read(ah, i, &val)) {\n\t\t\tret = -EIO;\n\t\t\tgoto freebuf;\n\t\t}\n\t\tbuf[i] = val;\n\t}\n\n\t \n\n\tep = kmalloc(sizeof(*ep), GFP_KERNEL);\n\tif (!ep) {\n\t\tret = -ENOMEM;\n\t\tgoto freebuf;\n\t}\n\n\tep->buf = buf;\n\tep->len = eesize * 2;\n\n\tfile->private_data = (void *)ep;\n\n\treturn 0;\n\nfreebuf:\n\tvfree(buf);\nerr:\n\treturn ret;\n\n}\n\nstatic ssize_t read_file_eeprom(struct file *file, char __user *user_buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct eeprom_private *ep = file->private_data;\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, ep->buf, ep->len);\n}\n\nstatic int release_file_eeprom(struct inode *inode, struct file *file)\n{\n\tstruct eeprom_private *ep = file->private_data;\n\n\tvfree(ep->buf);\n\tkfree(ep);\n\n\treturn 0;\n}\n\nstatic const struct file_operations fops_eeprom = {\n\t.open = open_file_eeprom,\n\t.read = read_file_eeprom,\n\t.release = release_file_eeprom,\n\t.owner = THIS_MODULE,\n};\n\n\nvoid\nath5k_debug_init_device(struct ath5k_hw *ah)\n{\n\tstruct dentry *phydir;\n\n\tah->debug.level = ath5k_debug;\n\n\tphydir = debugfs_create_dir(\"ath5k\", ah->hw->wiphy->debugfsdir);\n\n\tdebugfs_create_file(\"debug\", 0600, phydir, ah, &fops_debug);\n\tdebugfs_create_file(\"registers\", 0400, phydir, ah, &registers_fops);\n\tdebugfs_create_file(\"beacon\", 0600, phydir, ah, &fops_beacon);\n\tdebugfs_create_file(\"reset\", 0200, phydir, ah, &fops_reset);\n\tdebugfs_create_file(\"antenna\", 0600, phydir, ah, &fops_antenna);\n\tdebugfs_create_file(\"misc\", 0400, phydir, ah, &fops_misc);\n\tdebugfs_create_file(\"eeprom\", 0400, phydir, ah, &fops_eeprom);\n\tdebugfs_create_file(\"frameerrors\", 0600, phydir, ah, &fops_frameerrors);\n\tdebugfs_create_file(\"ani\", 0600, phydir, ah, &fops_ani);\n\tdebugfs_create_file(\"queue\", 0600, phydir, ah, &fops_queue);\n\tdebugfs_create_bool(\"32khz_clock\", 0600, phydir,\n\t\t\t    &ah->ah_use_32khz_clock);\n}\n\n \n\nvoid\nath5k_debug_dump_bands(struct ath5k_hw *ah)\n{\n\tunsigned int b, i;\n\n\tif (likely(!(ah->debug.level & ATH5K_DEBUG_DUMPBANDS)))\n\t\treturn;\n\n\tfor (b = 0; b < NUM_NL80211_BANDS; b++) {\n\t\tstruct ieee80211_supported_band *band = &ah->sbands[b];\n\t\tchar bname[6];\n\t\tswitch (band->band) {\n\t\tcase NL80211_BAND_2GHZ:\n\t\t\tstrcpy(bname, \"2 GHz\");\n\t\t\tbreak;\n\t\tcase NL80211_BAND_5GHZ:\n\t\t\tstrcpy(bname, \"5 GHz\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(KERN_DEBUG \"Band not supported: %d\\n\",\n\t\t\t\tband->band);\n\t\t\treturn;\n\t\t}\n\t\tprintk(KERN_DEBUG \"Band %s: channels %d, rates %d\\n\", bname,\n\t\t\t\tband->n_channels, band->n_bitrates);\n\t\tprintk(KERN_DEBUG \" channels:\\n\");\n\t\tfor (i = 0; i < band->n_channels; i++)\n\t\t\tprintk(KERN_DEBUG \"  %3d %d %.4x %.4x\\n\",\n\t\t\t\t\tieee80211_frequency_to_channel(\n\t\t\t\t\t\tband->channels[i].center_freq),\n\t\t\t\t\tband->channels[i].center_freq,\n\t\t\t\t\tband->channels[i].hw_value,\n\t\t\t\t\tband->channels[i].flags);\n\t\tprintk(KERN_DEBUG \" rates:\\n\");\n\t\tfor (i = 0; i < band->n_bitrates; i++)\n\t\t\tprintk(KERN_DEBUG \"  %4d %.4x %.4x %.4x\\n\",\n\t\t\t\t\tband->bitrates[i].bitrate,\n\t\t\t\t\tband->bitrates[i].hw_value,\n\t\t\t\t\tband->bitrates[i].flags,\n\t\t\t\t\tband->bitrates[i].hw_value_short);\n\t}\n}\n\nstatic inline void\nath5k_debug_printrxbuf(struct ath5k_buf *bf, int done,\n\t\t       struct ath5k_rx_status *rs)\n{\n\tstruct ath5k_desc *ds = bf->desc;\n\tstruct ath5k_hw_all_rx_desc *rd = &ds->ud.ds_rx;\n\n\tprintk(KERN_DEBUG \"R (%p %llx) %08x %08x %08x %08x %08x %08x %c\\n\",\n\t\tds, (unsigned long long)bf->daddr,\n\t\tds->ds_link, ds->ds_data,\n\t\trd->rx_ctl.rx_control_0, rd->rx_ctl.rx_control_1,\n\t\trd->rx_stat.rx_status_0, rd->rx_stat.rx_status_1,\n\t\t!done ? ' ' : (rs->rs_status == 0) ? '*' : '!');\n}\n\nvoid\nath5k_debug_printrxbuffs(struct ath5k_hw *ah)\n{\n\tstruct ath5k_desc *ds;\n\tstruct ath5k_buf *bf;\n\tstruct ath5k_rx_status rs = {};\n\tint status;\n\n\tif (likely(!(ah->debug.level & ATH5K_DEBUG_DESC)))\n\t\treturn;\n\n\tprintk(KERN_DEBUG \"rxdp %x, rxlink %p\\n\",\n\t\tath5k_hw_get_rxdp(ah), ah->rxlink);\n\n\tspin_lock_bh(&ah->rxbuflock);\n\tlist_for_each_entry(bf, &ah->rxbuf, list) {\n\t\tds = bf->desc;\n\t\tstatus = ah->ah_proc_rx_desc(ah, ds, &rs);\n\t\tif (!status)\n\t\t\tath5k_debug_printrxbuf(bf, status == 0, &rs);\n\t}\n\tspin_unlock_bh(&ah->rxbuflock);\n}\n\nvoid\nath5k_debug_printtxbuf(struct ath5k_hw *ah, struct ath5k_buf *bf)\n{\n\tstruct ath5k_desc *ds = bf->desc;\n\tstruct ath5k_hw_5212_tx_desc *td = &ds->ud.ds_tx5212;\n\tstruct ath5k_tx_status ts = {};\n\tint done;\n\n\tif (likely(!(ah->debug.level & ATH5K_DEBUG_DESC)))\n\t\treturn;\n\n\tdone = ah->ah_proc_tx_desc(ah, bf->desc, &ts);\n\n\tprintk(KERN_DEBUG \"T (%p %llx) %08x %08x %08x %08x %08x %08x %08x \"\n\t\t\"%08x %c\\n\", ds, (unsigned long long)bf->daddr, ds->ds_link,\n\t\tds->ds_data, td->tx_ctl.tx_control_0, td->tx_ctl.tx_control_1,\n\t\ttd->tx_ctl.tx_control_2, td->tx_ctl.tx_control_3,\n\t\ttd->tx_stat.tx_status_0, td->tx_stat.tx_status_1,\n\t\tdone ? ' ' : (ts.ts_status == 0) ? '*' : '!');\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}