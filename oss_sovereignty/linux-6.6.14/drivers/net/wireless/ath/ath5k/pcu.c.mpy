{
  "module_name": "pcu.c",
  "hash_id": "a3b4acfa409200b7f573c448e521ac676bf15b14725e85aae6736104939640f1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath5k/pcu.c",
  "human_readable_source": " \n\n \n\n#include <asm/unaligned.h>\n\n#include \"ath5k.h\"\n#include \"reg.h\"\n#include \"debug.h\"\n\n \n\n \nstatic const unsigned int ack_rates_high[] =\n \n \t{ 0,\n \t1,\n \t1,\n \t1,\n \t4,\n \t4,\n \t6,\n \t6,\n \t8,\n \t8,\n \t8,\n \t8 };\n\n \n\n \nint\nath5k_hw_get_frame_duration(struct ath5k_hw *ah, enum nl80211_band band,\n\t\tint len, struct ieee80211_rate *rate, bool shortpre)\n{\n\tint sifs, preamble, plcp_bits, sym_time;\n\tint bitrate, bits, symbols, symbol_bits;\n\tint dur;\n\n\t \n\tif (!ah->ah_bwmode) {\n\t\t__le16 raw_dur = ieee80211_generic_frame_duration(ah->hw,\n\t\t\t\t\tNULL, band, len, rate);\n\n\t\t \n\t\tdur = le16_to_cpu(raw_dur);\n\t\tif (shortpre)\n\t\t\tdur -= 96;\n\n\t\treturn dur;\n\t}\n\n\tbitrate = rate->bitrate;\n\tpreamble = AR5K_INIT_OFDM_PREAMPLE_TIME;\n\tplcp_bits = AR5K_INIT_OFDM_PLCP_BITS;\n\tsym_time = AR5K_INIT_OFDM_SYMBOL_TIME;\n\n\tswitch (ah->ah_bwmode) {\n\tcase AR5K_BWMODE_40MHZ:\n\t\tsifs = AR5K_INIT_SIFS_TURBO;\n\t\tpreamble = AR5K_INIT_OFDM_PREAMBLE_TIME_MIN;\n\t\tbreak;\n\tcase AR5K_BWMODE_10MHZ:\n\t\tsifs = AR5K_INIT_SIFS_HALF_RATE;\n\t\tpreamble *= 2;\n\t\tsym_time *= 2;\n\t\tbitrate = DIV_ROUND_UP(bitrate, 2);\n\t\tbreak;\n\tcase AR5K_BWMODE_5MHZ:\n\t\tsifs = AR5K_INIT_SIFS_QUARTER_RATE;\n\t\tpreamble *= 4;\n\t\tsym_time *= 4;\n\t\tbitrate = DIV_ROUND_UP(bitrate, 4);\n\t\tbreak;\n\tdefault:\n\t\tsifs = AR5K_INIT_SIFS_DEFAULT_BG;\n\t\tbreak;\n\t}\n\n\tbits = plcp_bits + (len << 3);\n\t \n\tsymbol_bits = bitrate * sym_time;\n\tsymbols = DIV_ROUND_UP(bits * 10, symbol_bits);\n\n\tdur = sifs + preamble + (sym_time * symbols);\n\n\treturn dur;\n}\n\n \nunsigned int\nath5k_hw_get_default_slottime(struct ath5k_hw *ah)\n{\n\tstruct ieee80211_channel *channel = ah->ah_current_channel;\n\tunsigned int slot_time;\n\n\tswitch (ah->ah_bwmode) {\n\tcase AR5K_BWMODE_40MHZ:\n\t\tslot_time = AR5K_INIT_SLOT_TIME_TURBO;\n\t\tbreak;\n\tcase AR5K_BWMODE_10MHZ:\n\t\tslot_time = AR5K_INIT_SLOT_TIME_HALF_RATE;\n\t\tbreak;\n\tcase AR5K_BWMODE_5MHZ:\n\t\tslot_time = AR5K_INIT_SLOT_TIME_QUARTER_RATE;\n\t\tbreak;\n\tcase AR5K_BWMODE_DEFAULT:\n\tdefault:\n\t\tslot_time = AR5K_INIT_SLOT_TIME_DEFAULT;\n\t\tif ((channel->hw_value == AR5K_MODE_11B) && !ah->ah_short_slot)\n\t\t\tslot_time = AR5K_INIT_SLOT_TIME_B;\n\t\tbreak;\n\t}\n\n\treturn slot_time;\n}\n\n \nunsigned int\nath5k_hw_get_default_sifs(struct ath5k_hw *ah)\n{\n\tstruct ieee80211_channel *channel = ah->ah_current_channel;\n\tunsigned int sifs;\n\n\tswitch (ah->ah_bwmode) {\n\tcase AR5K_BWMODE_40MHZ:\n\t\tsifs = AR5K_INIT_SIFS_TURBO;\n\t\tbreak;\n\tcase AR5K_BWMODE_10MHZ:\n\t\tsifs = AR5K_INIT_SIFS_HALF_RATE;\n\t\tbreak;\n\tcase AR5K_BWMODE_5MHZ:\n\t\tsifs = AR5K_INIT_SIFS_QUARTER_RATE;\n\t\tbreak;\n\tcase AR5K_BWMODE_DEFAULT:\n\tdefault:\n\t\tsifs = AR5K_INIT_SIFS_DEFAULT_BG;\n\t\tif (channel->band == NL80211_BAND_5GHZ)\n\t\t\tsifs = AR5K_INIT_SIFS_DEFAULT_A;\n\t\tbreak;\n\t}\n\n\treturn sifs;\n}\n\n \nvoid\nath5k_hw_update_mib_counters(struct ath5k_hw *ah)\n{\n\tstruct ath5k_statistics *stats = &ah->stats;\n\n\t \n\tstats->ack_fail += ath5k_hw_reg_read(ah, AR5K_ACK_FAIL);\n\tstats->rts_fail += ath5k_hw_reg_read(ah, AR5K_RTS_FAIL);\n\tstats->rts_ok += ath5k_hw_reg_read(ah, AR5K_RTS_OK);\n\tstats->fcs_error += ath5k_hw_reg_read(ah, AR5K_FCS_FAIL);\n\tstats->beacons += ath5k_hw_reg_read(ah, AR5K_BEACON_CNT);\n}\n\n\n \n\n \nstatic inline void\nath5k_hw_write_rate_duration(struct ath5k_hw *ah)\n{\n\tstruct ieee80211_rate *rate;\n\tunsigned int i;\n\t \n\tu8 band = NL80211_BAND_2GHZ;\n\n\t \n\tfor (i = 0; i < ah->sbands[band].n_bitrates; i++) {\n\t\tu32 reg;\n\t\tu16 tx_time;\n\n\t\tif (ah->ah_ack_bitrate_high)\n\t\t\trate = &ah->sbands[band].bitrates[ack_rates_high[i]];\n\t\t \n\t\telse if (i < 4)\n\t\t\trate = &ah->sbands[band].bitrates[0];\n\t\t \n\t\telse\n\t\t\trate = &ah->sbands[band].bitrates[4];\n\n\t\t \n\t\treg = AR5K_RATE_DUR(rate->hw_value);\n\n\t\t \n\t\ttx_time = ath5k_hw_get_frame_duration(ah, band, 10,\n\t\t\t\t\trate, false);\n\n\t\tath5k_hw_reg_write(ah, tx_time, reg);\n\n\t\tif (!(rate->flags & IEEE80211_RATE_SHORT_PREAMBLE))\n\t\t\tcontinue;\n\n\t\ttx_time = ath5k_hw_get_frame_duration(ah, band, 10, rate, true);\n\t\tath5k_hw_reg_write(ah, tx_time,\n\t\t\treg + (AR5K_SET_SHORT_PREAMBLE << 2));\n\t}\n}\n\n \nstatic int\nath5k_hw_set_ack_timeout(struct ath5k_hw *ah, unsigned int timeout)\n{\n\tif (ath5k_hw_clocktoh(ah, AR5K_REG_MS(0xffffffff, AR5K_TIME_OUT_ACK))\n\t\t\t<= timeout)\n\t\treturn -EINVAL;\n\n\tAR5K_REG_WRITE_BITS(ah, AR5K_TIME_OUT, AR5K_TIME_OUT_ACK,\n\t\tath5k_hw_htoclock(ah, timeout));\n\n\treturn 0;\n}\n\n \nstatic int\nath5k_hw_set_cts_timeout(struct ath5k_hw *ah, unsigned int timeout)\n{\n\tif (ath5k_hw_clocktoh(ah, AR5K_REG_MS(0xffffffff, AR5K_TIME_OUT_CTS))\n\t\t\t<= timeout)\n\t\treturn -EINVAL;\n\n\tAR5K_REG_WRITE_BITS(ah, AR5K_TIME_OUT, AR5K_TIME_OUT_CTS,\n\t\t\tath5k_hw_htoclock(ah, timeout));\n\n\treturn 0;\n}\n\n\n \n\n \nint\nath5k_hw_set_lladdr(struct ath5k_hw *ah, const u8 *mac)\n{\n\tstruct ath_common *common = ath5k_hw_common(ah);\n\tu32 low_id, high_id;\n\tu32 pcu_reg;\n\n\t \n\tmemcpy(common->macaddr, mac, ETH_ALEN);\n\n\tpcu_reg = ath5k_hw_reg_read(ah, AR5K_STA_ID1) & 0xffff0000;\n\n\tlow_id = get_unaligned_le32(mac);\n\thigh_id = get_unaligned_le16(mac + 4);\n\n\tath5k_hw_reg_write(ah, low_id, AR5K_STA_ID0);\n\tath5k_hw_reg_write(ah, pcu_reg | high_id, AR5K_STA_ID1);\n\n\treturn 0;\n}\n\n \nvoid\nath5k_hw_set_bssid(struct ath5k_hw *ah)\n{\n\tstruct ath_common *common = ath5k_hw_common(ah);\n\tu16 tim_offset = 0;\n\n\t \n\tif (ah->ah_version == AR5K_AR5212)\n\t\tath_hw_setbssidmask(common);\n\n\t \n\tath5k_hw_reg_write(ah,\n\t\t\t   get_unaligned_le32(common->curbssid),\n\t\t\t   AR5K_BSS_ID0);\n\tath5k_hw_reg_write(ah,\n\t\t\t   get_unaligned_le16(common->curbssid + 4) |\n\t\t\t   ((common->curaid & 0x3fff) << AR5K_BSS_ID1_AID_S),\n\t\t\t   AR5K_BSS_ID1);\n\n\tif (common->curaid == 0) {\n\t\tath5k_hw_disable_pspoll(ah);\n\t\treturn;\n\t}\n\n\tAR5K_REG_WRITE_BITS(ah, AR5K_BEACON, AR5K_BEACON_TIM,\n\t\t\t    tim_offset ? tim_offset + 4 : 0);\n\n\tath5k_hw_enable_pspoll(ah, NULL, 0);\n}\n\n \nvoid\nath5k_hw_set_bssid_mask(struct ath5k_hw *ah, const u8 *mask)\n{\n\tstruct ath_common *common = ath5k_hw_common(ah);\n\n\t \n\tmemcpy(common->bssidmask, mask, ETH_ALEN);\n\tif (ah->ah_version == AR5K_AR5212)\n\t\tath_hw_setbssidmask(common);\n}\n\n \nvoid\nath5k_hw_set_mcast_filter(struct ath5k_hw *ah, u32 filter0, u32 filter1)\n{\n\tath5k_hw_reg_write(ah, filter0, AR5K_MCAST_FILTER0);\n\tath5k_hw_reg_write(ah, filter1, AR5K_MCAST_FILTER1);\n}\n\n \nu32\nath5k_hw_get_rx_filter(struct ath5k_hw *ah)\n{\n\tu32 data, filter = 0;\n\n\tfilter = ath5k_hw_reg_read(ah, AR5K_RX_FILTER);\n\n\t \n\tif (ah->ah_version == AR5K_AR5212) {\n\t\tdata = ath5k_hw_reg_read(ah, AR5K_PHY_ERR_FIL);\n\n\t\tif (data & AR5K_PHY_ERR_FIL_RADAR)\n\t\t\tfilter |= AR5K_RX_FILTER_RADARERR;\n\t\tif (data & (AR5K_PHY_ERR_FIL_OFDM | AR5K_PHY_ERR_FIL_CCK))\n\t\t\tfilter |= AR5K_RX_FILTER_PHYERR;\n\t}\n\n\treturn filter;\n}\n\n \nvoid\nath5k_hw_set_rx_filter(struct ath5k_hw *ah, u32 filter)\n{\n\tu32 data = 0;\n\n\t \n\tif (ah->ah_version == AR5K_AR5212) {\n\t\tif (filter & AR5K_RX_FILTER_RADARERR)\n\t\t\tdata |= AR5K_PHY_ERR_FIL_RADAR;\n\t\tif (filter & AR5K_RX_FILTER_PHYERR)\n\t\t\tdata |= AR5K_PHY_ERR_FIL_OFDM | AR5K_PHY_ERR_FIL_CCK;\n\t}\n\n\t \n\tif (ah->ah_version == AR5K_AR5210 &&\n\t\t\t(filter & AR5K_RX_FILTER_RADARERR)) {\n\t\tfilter &= ~AR5K_RX_FILTER_RADARERR;\n\t\tfilter |= AR5K_RX_FILTER_PROM;\n\t}\n\n\t \n\tif (data)\n\t\tAR5K_REG_ENABLE_BITS(ah, AR5K_RXCFG, AR5K_RXCFG_ZLFDMA);\n\telse\n\t\tAR5K_REG_DISABLE_BITS(ah, AR5K_RXCFG, AR5K_RXCFG_ZLFDMA);\n\n\t \n\tath5k_hw_reg_write(ah, filter & 0xff, AR5K_RX_FILTER);\n\n\t \n\tif (ah->ah_version == AR5K_AR5212)\n\t\tath5k_hw_reg_write(ah, data, AR5K_PHY_ERR_FIL);\n\n}\n\n\n \n\n#define ATH5K_MAX_TSF_READ 10\n\n \nu64\nath5k_hw_get_tsf64(struct ath5k_hw *ah)\n{\n\tu32 tsf_lower, tsf_upper1, tsf_upper2;\n\tint i;\n\tunsigned long flags;\n\n\t \n\tlocal_irq_save(flags);\n\n\t \n\n\ttsf_upper1 = ath5k_hw_reg_read(ah, AR5K_TSF_U32);\n\tfor (i = 0; i < ATH5K_MAX_TSF_READ; i++) {\n\t\ttsf_lower = ath5k_hw_reg_read(ah, AR5K_TSF_L32);\n\t\ttsf_upper2 = ath5k_hw_reg_read(ah, AR5K_TSF_U32);\n\t\tif (tsf_upper2 == tsf_upper1)\n\t\t\tbreak;\n\t\ttsf_upper1 = tsf_upper2;\n\t}\n\n\tlocal_irq_restore(flags);\n\n\tWARN_ON(i == ATH5K_MAX_TSF_READ);\n\n\treturn ((u64)tsf_upper1 << 32) | tsf_lower;\n}\n\n#undef ATH5K_MAX_TSF_READ\n\n \nvoid\nath5k_hw_set_tsf64(struct ath5k_hw *ah, u64 tsf64)\n{\n\tath5k_hw_reg_write(ah, tsf64 & 0xffffffff, AR5K_TSF_L32);\n\tath5k_hw_reg_write(ah, (tsf64 >> 32) & 0xffffffff, AR5K_TSF_U32);\n}\n\n \nvoid\nath5k_hw_reset_tsf(struct ath5k_hw *ah)\n{\n\tu32 val;\n\n\tval = ath5k_hw_reg_read(ah, AR5K_BEACON) | AR5K_BEACON_RESET_TSF;\n\n\t \n\tath5k_hw_reg_write(ah, val, AR5K_BEACON);\n\tath5k_hw_reg_write(ah, val, AR5K_BEACON);\n}\n\n \nvoid\nath5k_hw_init_beacon_timers(struct ath5k_hw *ah, u32 next_beacon, u32 interval)\n{\n\tu32 timer1, timer2, timer3;\n\n\t \n\tswitch (ah->opmode) {\n\tcase NL80211_IFTYPE_MONITOR:\n\tcase NL80211_IFTYPE_STATION:\n\t\t \n\t\t \n\t\tif (ah->ah_version == AR5K_AR5210) {\n\t\t\ttimer1 = 0xffffffff;\n\t\t\ttimer2 = 0xffffffff;\n\t\t} else {\n\t\t\ttimer1 = 0x0000ffff;\n\t\t\ttimer2 = 0x0007ffff;\n\t\t}\n\t\t \n\t\tAR5K_REG_DISABLE_BITS(ah, AR5K_STA_ID1, AR5K_STA_ID1_PCF);\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tAR5K_REG_ENABLE_BITS(ah, AR5K_TXCFG, AR5K_TXCFG_ADHOC_BCN_ATIM);\n\t\tfallthrough;\n\tdefault:\n\t\t \n\t\ttimer1 = (next_beacon - AR5K_TUNE_DMA_BEACON_RESP) << 3;\n\t\ttimer2 = (next_beacon - AR5K_TUNE_SW_BEACON_RESP) << 3;\n\t\tbreak;\n\t}\n\n\t \n\ttimer3 = next_beacon + 1;\n\n\t \n\t \n\tif (ah->opmode == NL80211_IFTYPE_AP ||\n\t    ah->opmode == NL80211_IFTYPE_MESH_POINT)\n\t\tath5k_hw_reg_write(ah, 0, AR5K_TIMER0);\n\n\tath5k_hw_reg_write(ah, next_beacon, AR5K_TIMER0);\n\tath5k_hw_reg_write(ah, timer1, AR5K_TIMER1);\n\tath5k_hw_reg_write(ah, timer2, AR5K_TIMER2);\n\tath5k_hw_reg_write(ah, timer3, AR5K_TIMER3);\n\n\t \n\tif (interval & AR5K_BEACON_RESET_TSF)\n\t\tath5k_hw_reset_tsf(ah);\n\n\tath5k_hw_reg_write(ah, interval & (AR5K_BEACON_PERIOD |\n\t\t\t\t\tAR5K_BEACON_ENABLE),\n\t\t\t\t\t\tAR5K_BEACON);\n\n\t \n\tif (ah->ah_version == AR5K_AR5210)\n\t\tath5k_hw_reg_write(ah, AR5K_ISR_BMISS, AR5K_ISR);\n\telse\n\t\tath5k_hw_reg_write(ah, AR5K_ISR_BMISS, AR5K_PISR);\n\n\t \n\tAR5K_REG_DISABLE_BITS(ah, AR5K_STA_ID1, AR5K_STA_ID1_PWR_SV);\n\n}\n\n \nstatic inline bool\nath5k_check_timer_win(int a, int b, int window, int intval)\n{\n\t \n\tif ((b - a == window) ||\t\t\t\t \n\t    (a - b == intval - window) ||\t\t\t \n\t    ((a | 0x10000) - b == intval - window) ||\t\t \n\t    ((b | 0x10000) - a == window))\t\t\t \n\t\treturn true;  \n\treturn false;\n}\n\n \nbool\nath5k_hw_check_beacon_timers(struct ath5k_hw *ah, int intval)\n{\n\tunsigned int nbtt, atim, dma;\n\n\tnbtt = ath5k_hw_reg_read(ah, AR5K_TIMER0);\n\tatim = ath5k_hw_reg_read(ah, AR5K_TIMER3);\n\tdma = ath5k_hw_reg_read(ah, AR5K_TIMER1) >> 3;\n\n\t \n\n\tif (ath5k_check_timer_win(nbtt, atim, 1, intval) &&\n\t    ath5k_check_timer_win(dma, nbtt, AR5K_TUNE_DMA_BEACON_RESP,\n\t\t\t\t  intval))\n\t\treturn true;  \n\treturn false;\n}\n\n \nvoid\nath5k_hw_set_coverage_class(struct ath5k_hw *ah, u8 coverage_class)\n{\n\t \n\tint slot_time = ath5k_hw_get_default_slottime(ah) + 3 * coverage_class;\n\tint ack_timeout = ath5k_hw_get_default_sifs(ah) + slot_time;\n\tint cts_timeout = ack_timeout;\n\n\tath5k_hw_set_ifs_intervals(ah, slot_time);\n\tath5k_hw_set_ack_timeout(ah, ack_timeout);\n\tath5k_hw_set_cts_timeout(ah, cts_timeout);\n\n\tah->ah_coverage_class = coverage_class;\n}\n\n \n\n \nvoid\nath5k_hw_start_rx_pcu(struct ath5k_hw *ah)\n{\n\tAR5K_REG_DISABLE_BITS(ah, AR5K_DIAG_SW, AR5K_DIAG_SW_DIS_RX);\n}\n\n \nvoid\nath5k_hw_stop_rx_pcu(struct ath5k_hw *ah)\n{\n\tAR5K_REG_ENABLE_BITS(ah, AR5K_DIAG_SW, AR5K_DIAG_SW_DIS_RX);\n}\n\n \nint\nath5k_hw_set_opmode(struct ath5k_hw *ah, enum nl80211_iftype op_mode)\n{\n\tstruct ath_common *common = ath5k_hw_common(ah);\n\tu32 pcu_reg, beacon_reg, low_id, high_id;\n\n\tATH5K_DBG(ah, ATH5K_DEBUG_MODE, \"mode %d\\n\", op_mode);\n\n\t \n\tpcu_reg = ath5k_hw_reg_read(ah, AR5K_STA_ID1) & 0xffff0000;\n\tpcu_reg &= ~(AR5K_STA_ID1_ADHOC | AR5K_STA_ID1_AP\n\t\t\t| AR5K_STA_ID1_KEYSRCH_MODE\n\t\t\t| (ah->ah_version == AR5K_AR5210 ?\n\t\t\t(AR5K_STA_ID1_PWR_SV | AR5K_STA_ID1_NO_PSPOLL) : 0));\n\n\tbeacon_reg = 0;\n\n\tswitch (op_mode) {\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tpcu_reg |= AR5K_STA_ID1_ADHOC | AR5K_STA_ID1_KEYSRCH_MODE;\n\t\tbeacon_reg |= AR5K_BCR_ADHOC;\n\t\tif (ah->ah_version == AR5K_AR5210)\n\t\t\tpcu_reg |= AR5K_STA_ID1_NO_PSPOLL;\n\t\telse\n\t\t\tAR5K_REG_ENABLE_BITS(ah, AR5K_CFG, AR5K_CFG_IBSS);\n\t\tbreak;\n\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tpcu_reg |= AR5K_STA_ID1_AP | AR5K_STA_ID1_KEYSRCH_MODE;\n\t\tbeacon_reg |= AR5K_BCR_AP;\n\t\tif (ah->ah_version == AR5K_AR5210)\n\t\t\tpcu_reg |= AR5K_STA_ID1_NO_PSPOLL;\n\t\telse\n\t\t\tAR5K_REG_DISABLE_BITS(ah, AR5K_CFG, AR5K_CFG_IBSS);\n\t\tbreak;\n\n\tcase NL80211_IFTYPE_STATION:\n\t\tpcu_reg |= AR5K_STA_ID1_KEYSRCH_MODE\n\t\t\t| (ah->ah_version == AR5K_AR5210 ?\n\t\t\t\tAR5K_STA_ID1_PWR_SV : 0);\n\t\tfallthrough;\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tpcu_reg |= AR5K_STA_ID1_KEYSRCH_MODE\n\t\t\t| (ah->ah_version == AR5K_AR5210 ?\n\t\t\t\tAR5K_STA_ID1_NO_PSPOLL : 0);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tlow_id = get_unaligned_le32(common->macaddr);\n\thigh_id = get_unaligned_le16(common->macaddr + 4);\n\tath5k_hw_reg_write(ah, low_id, AR5K_STA_ID0);\n\tath5k_hw_reg_write(ah, pcu_reg | high_id, AR5K_STA_ID1);\n\n\t \n\tif (ah->ah_version == AR5K_AR5210)\n\t\tath5k_hw_reg_write(ah, beacon_reg, AR5K_BCR);\n\n\treturn 0;\n}\n\n \nvoid\nath5k_hw_pcu_init(struct ath5k_hw *ah, enum nl80211_iftype op_mode)\n{\n\t \n\tath5k_hw_set_bssid(ah);\n\n\t \n\tath5k_hw_set_opmode(ah, op_mode);\n\n\t \n\tif (ah->ah_version == AR5K_AR5212 &&\n\t\tah->nvifs)\n\t\tath5k_hw_write_rate_duration(ah);\n\n\t \n\tath5k_hw_reg_write(ah, (AR5K_TUNE_RSSI_THRES |\n\t\t\t\tAR5K_TUNE_BMISS_THRES <<\n\t\t\t\tAR5K_RSSI_THR_BMISS_S),\n\t\t\t\tAR5K_RSSI_THR);\n\n\t \n\tif (ah->ah_mac_srev >= AR5K_SREV_AR2413) {\n\t\tath5k_hw_reg_write(ah, 0x000100aa, AR5K_MIC_QOS_CTL);\n\t\tath5k_hw_reg_write(ah, 0x00003210, AR5K_MIC_QOS_SEL);\n\t}\n\n\t \n\tif (ah->ah_version == AR5K_AR5212) {\n\t\tath5k_hw_reg_write(ah,\n\t\t\tAR5K_REG_SM(2, AR5K_QOS_NOACK_2BIT_VALUES) |\n\t\t\tAR5K_REG_SM(5, AR5K_QOS_NOACK_BIT_OFFSET)  |\n\t\t\tAR5K_REG_SM(0, AR5K_QOS_NOACK_BYTE_OFFSET),\n\t\t\tAR5K_QOS_NOACK);\n\t}\n\n\t \n\tif (ah->ah_coverage_class > 0)\n\t\tath5k_hw_set_coverage_class(ah, ah->ah_coverage_class);\n\n\t \n\tif (ah->ah_version == AR5K_AR5212) {\n\t\tu32 val = AR5K_STA_ID1_BASE_RATE_11B | AR5K_STA_ID1_ACKCTS_6MB;\n\t\tif (ah->ah_ack_bitrate_high)\n\t\t\tAR5K_REG_DISABLE_BITS(ah, AR5K_STA_ID1, val);\n\t\telse\n\t\t\tAR5K_REG_ENABLE_BITS(ah, AR5K_STA_ID1, val);\n\t}\n\treturn;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}