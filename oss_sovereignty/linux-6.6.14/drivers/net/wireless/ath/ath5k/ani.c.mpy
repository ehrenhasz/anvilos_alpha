{
  "module_name": "ani.c",
  "hash_id": "3cf5382e68c3388ac3638ca5462d792c37b4f9ebcc8d18cc624b1a6c1dc69868",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath5k/ani.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include \"ath5k.h\"\n#include \"reg.h\"\n#include \"debug.h\"\n#include \"ani.h\"\n\n \n\n\n \n\n \nvoid\nath5k_ani_set_noise_immunity_level(struct ath5k_hw *ah, int level)\n{\n\t \n#if 0\n\tstatic const s8 lo[] = { -52, -56, -60, -64, -70 };\n\tstatic const s8 hi[] = { -18, -18, -16, -14, -12 };\n\tstatic const s8 sz[] = { -34, -41, -48, -55, -62 };\n\tstatic const s8 fr[] = { -70, -72, -75, -78, -80 };\n#else\n\tstatic const s8 lo[] = { -64, -70 };\n\tstatic const s8 hi[] = { -14, -12 };\n\tstatic const s8 sz[] = { -55, -62 };\n\tstatic const s8 fr[] = { -78, -80 };\n#endif\n\tif (level < 0 || level >= ARRAY_SIZE(sz)) {\n\t\tATH5K_ERR(ah, \"noise immunity level %d out of range\",\n\t\t\t  level);\n\t\treturn;\n\t}\n\n\tAR5K_REG_WRITE_BITS(ah, AR5K_PHY_DESIRED_SIZE,\n\t\t\t\tAR5K_PHY_DESIRED_SIZE_TOT, sz[level]);\n\tAR5K_REG_WRITE_BITS(ah, AR5K_PHY_AGCCOARSE,\n\t\t\t\tAR5K_PHY_AGCCOARSE_LO, lo[level]);\n\tAR5K_REG_WRITE_BITS(ah, AR5K_PHY_AGCCOARSE,\n\t\t\t\tAR5K_PHY_AGCCOARSE_HI, hi[level]);\n\tAR5K_REG_WRITE_BITS(ah, AR5K_PHY_SIG,\n\t\t\t\tAR5K_PHY_SIG_FIRPWR, fr[level]);\n\n\tah->ani_state.noise_imm_level = level;\n\tATH5K_DBG_UNLIMIT(ah, ATH5K_DEBUG_ANI, \"new level %d\", level);\n}\n\n \nvoid\nath5k_ani_set_spur_immunity_level(struct ath5k_hw *ah, int level)\n{\n\tstatic const int val[] = { 2, 4, 6, 8, 10, 12, 14, 16 };\n\n\tif (level < 0 || level >= ARRAY_SIZE(val) ||\n\t    level > ah->ani_state.max_spur_level) {\n\t\tATH5K_ERR(ah, \"spur immunity level %d out of range\",\n\t\t\t  level);\n\t\treturn;\n\t}\n\n\tAR5K_REG_WRITE_BITS(ah, AR5K_PHY_OFDM_SELFCORR,\n\t\tAR5K_PHY_OFDM_SELFCORR_CYPWR_THR1, val[level]);\n\n\tah->ani_state.spur_level = level;\n\tATH5K_DBG_UNLIMIT(ah, ATH5K_DEBUG_ANI, \"new level %d\", level);\n}\n\n \nvoid\nath5k_ani_set_firstep_level(struct ath5k_hw *ah, int level)\n{\n\tstatic const int val[] = { 0, 4, 8 };\n\n\tif (level < 0 || level >= ARRAY_SIZE(val)) {\n\t\tATH5K_ERR(ah, \"firstep level %d out of range\", level);\n\t\treturn;\n\t}\n\n\tAR5K_REG_WRITE_BITS(ah, AR5K_PHY_SIG,\n\t\t\t\tAR5K_PHY_SIG_FIRSTEP, val[level]);\n\n\tah->ani_state.firstep_level = level;\n\tATH5K_DBG_UNLIMIT(ah, ATH5K_DEBUG_ANI, \"new level %d\", level);\n}\n\n \nvoid\nath5k_ani_set_ofdm_weak_signal_detection(struct ath5k_hw *ah, bool on)\n{\n\tstatic const int m1l[] = { 127, 50 };\n\tstatic const int m2l[] = { 127, 40 };\n\tstatic const int m1[] = { 127, 0x4d };\n\tstatic const int m2[] = { 127, 0x40 };\n\tstatic const int m2cnt[] = { 31, 16 };\n\tstatic const int m2lcnt[] = { 63, 48 };\n\n\tAR5K_REG_WRITE_BITS(ah, AR5K_PHY_WEAK_OFDM_LOW_THR,\n\t\t\t\tAR5K_PHY_WEAK_OFDM_LOW_THR_M1, m1l[on]);\n\tAR5K_REG_WRITE_BITS(ah, AR5K_PHY_WEAK_OFDM_LOW_THR,\n\t\t\t\tAR5K_PHY_WEAK_OFDM_LOW_THR_M2, m2l[on]);\n\tAR5K_REG_WRITE_BITS(ah, AR5K_PHY_WEAK_OFDM_HIGH_THR,\n\t\t\t\tAR5K_PHY_WEAK_OFDM_HIGH_THR_M1, m1[on]);\n\tAR5K_REG_WRITE_BITS(ah, AR5K_PHY_WEAK_OFDM_HIGH_THR,\n\t\t\t\tAR5K_PHY_WEAK_OFDM_HIGH_THR_M2, m2[on]);\n\tAR5K_REG_WRITE_BITS(ah, AR5K_PHY_WEAK_OFDM_HIGH_THR,\n\t\t\tAR5K_PHY_WEAK_OFDM_HIGH_THR_M2_COUNT, m2cnt[on]);\n\tAR5K_REG_WRITE_BITS(ah, AR5K_PHY_WEAK_OFDM_LOW_THR,\n\t\t\tAR5K_PHY_WEAK_OFDM_LOW_THR_M2_COUNT, m2lcnt[on]);\n\n\tif (on)\n\t\tAR5K_REG_ENABLE_BITS(ah, AR5K_PHY_WEAK_OFDM_LOW_THR,\n\t\t\t\tAR5K_PHY_WEAK_OFDM_LOW_THR_SELFCOR_EN);\n\telse\n\t\tAR5K_REG_DISABLE_BITS(ah, AR5K_PHY_WEAK_OFDM_LOW_THR,\n\t\t\t\tAR5K_PHY_WEAK_OFDM_LOW_THR_SELFCOR_EN);\n\n\tah->ani_state.ofdm_weak_sig = on;\n\tATH5K_DBG_UNLIMIT(ah, ATH5K_DEBUG_ANI, \"turned %s\",\n\t\t\t  on ? \"on\" : \"off\");\n}\n\n \nvoid\nath5k_ani_set_cck_weak_signal_detection(struct ath5k_hw *ah, bool on)\n{\n\tstatic const int val[] = { 8, 6 };\n\tAR5K_REG_WRITE_BITS(ah, AR5K_PHY_CCK_CROSSCORR,\n\t\t\t\tAR5K_PHY_CCK_CROSSCORR_WEAK_SIG_THR, val[on]);\n\tah->ani_state.cck_weak_sig = on;\n\tATH5K_DBG_UNLIMIT(ah, ATH5K_DEBUG_ANI, \"turned %s\",\n\t\t\t  on ? \"on\" : \"off\");\n}\n\n\n \n\n \nstatic void\nath5k_ani_raise_immunity(struct ath5k_hw *ah, struct ath5k_ani_state *as,\n\t\t\t bool ofdm_trigger)\n{\n\tint rssi = ewma_beacon_rssi_read(&ah->ah_beacon_rssi_avg);\n\n\tATH5K_DBG_UNLIMIT(ah, ATH5K_DEBUG_ANI, \"raise immunity (%s)\",\n\t\tofdm_trigger ? \"ODFM\" : \"CCK\");\n\n\t \n\tif (as->noise_imm_level < ATH5K_ANI_MAX_NOISE_IMM_LVL) {\n\t\tath5k_ani_set_noise_immunity_level(ah, as->noise_imm_level + 1);\n\t\treturn;\n\t}\n\n\t \n\tif (ofdm_trigger &&\n\t    as->spur_level < ah->ani_state.max_spur_level) {\n\t\tath5k_ani_set_spur_immunity_level(ah, as->spur_level + 1);\n\t\treturn;\n\t}\n\n\t \n\tif (ah->opmode == NL80211_IFTYPE_AP) {\n\t\tif (as->firstep_level < ATH5K_ANI_MAX_FIRSTEP_LVL)\n\t\t\tath5k_ani_set_firstep_level(ah, as->firstep_level + 1);\n\t\treturn;\n\t}\n\n\t \n\n\t \n\n\tif (rssi > ATH5K_ANI_RSSI_THR_HIGH) {\n\t\tATH5K_DBG_UNLIMIT(ah, ATH5K_DEBUG_ANI,\n\t\t\t\t  \"beacon RSSI high\");\n\t\t \n\t\tif (ofdm_trigger && as->ofdm_weak_sig) {\n\t\t\tath5k_ani_set_ofdm_weak_signal_detection(ah, false);\n\t\t\tath5k_ani_set_spur_immunity_level(ah, 0);\n\t\t\treturn;\n\t\t}\n\t\t \n\t\tif (as->firstep_level < ATH5K_ANI_MAX_FIRSTEP_LVL) {\n\t\t\tath5k_ani_set_firstep_level(ah, as->firstep_level + 1);\n\t\t\treturn;\n\t\t}\n\t} else if (rssi > ATH5K_ANI_RSSI_THR_LOW) {\n\t\t \n\t\tATH5K_DBG_UNLIMIT(ah, ATH5K_DEBUG_ANI,\n\t\t\t\t  \"beacon RSSI mid\");\n\t\tif (ofdm_trigger && !as->ofdm_weak_sig)\n\t\t\tath5k_ani_set_ofdm_weak_signal_detection(ah, true);\n\t\tif (as->firstep_level < ATH5K_ANI_MAX_FIRSTEP_LVL)\n\t\t\tath5k_ani_set_firstep_level(ah, as->firstep_level + 1);\n\t\treturn;\n\t} else if (ah->ah_current_channel->band == NL80211_BAND_2GHZ) {\n\t\t \n\t\tATH5K_DBG_UNLIMIT(ah, ATH5K_DEBUG_ANI,\n\t\t\t\t  \"beacon RSSI low, 2GHz\");\n\t\tif (ofdm_trigger && as->ofdm_weak_sig)\n\t\t\tath5k_ani_set_ofdm_weak_signal_detection(ah, false);\n\t\tif (as->firstep_level > 0)\n\t\t\tath5k_ani_set_firstep_level(ah, 0);\n\t\treturn;\n\t}\n\n\t \n}\n\n \nstatic void\nath5k_ani_lower_immunity(struct ath5k_hw *ah, struct ath5k_ani_state *as)\n{\n\tint rssi = ewma_beacon_rssi_read(&ah->ah_beacon_rssi_avg);\n\n\tATH5K_DBG_UNLIMIT(ah, ATH5K_DEBUG_ANI, \"lower immunity\");\n\n\tif (ah->opmode == NL80211_IFTYPE_AP) {\n\t\t \n\t\tif (as->firstep_level > 0) {\n\t\t\tath5k_ani_set_firstep_level(ah, as->firstep_level - 1);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\t \n\t\tif (rssi > ATH5K_ANI_RSSI_THR_HIGH) {\n\t\t\t \n\t\t} else if (rssi > ATH5K_ANI_RSSI_THR_LOW) {\n\t\t\t \n\t\t\tif (!as->ofdm_weak_sig) {\n\t\t\t\tath5k_ani_set_ofdm_weak_signal_detection(ah,\n\t\t\t\t\t\t\t\t\t true);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (as->firstep_level > 0) {\n\t\t\t\tath5k_ani_set_firstep_level(ah,\n\t\t\t\t\t\t\tas->firstep_level - 1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (as->firstep_level > 0) {\n\t\t\t\tath5k_ani_set_firstep_level(ah,\n\t\t\t\t\t\t\tas->firstep_level - 1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (as->spur_level > 0) {\n\t\tath5k_ani_set_spur_immunity_level(ah, as->spur_level - 1);\n\t\treturn;\n\t}\n\n\t \n\tif (as->noise_imm_level > 0) {\n\t\tath5k_ani_set_noise_immunity_level(ah, as->noise_imm_level - 1);\n\t\treturn;\n\t}\n}\n\n \nstatic int\nath5k_hw_ani_get_listen_time(struct ath5k_hw *ah, struct ath5k_ani_state *as)\n{\n\tstruct ath_common *common = ath5k_hw_common(ah);\n\tint listen;\n\n\tspin_lock_bh(&common->cc_lock);\n\n\tath_hw_cycle_counters_update(common);\n\tmemcpy(&as->last_cc, &common->cc_ani, sizeof(as->last_cc));\n\n\t \n\tlisten = ath_hw_get_listen_time(common);\n\n\tspin_unlock_bh(&common->cc_lock);\n\n\treturn listen;\n}\n\n \nstatic int\nath5k_ani_save_and_clear_phy_errors(struct ath5k_hw *ah,\n\t\t\t\t    struct ath5k_ani_state *as)\n{\n\tunsigned int ofdm_err, cck_err;\n\n\tif (!ah->ah_capabilities.cap_has_phyerr_counters)\n\t\treturn 0;\n\n\tofdm_err = ath5k_hw_reg_read(ah, AR5K_PHYERR_CNT1);\n\tcck_err = ath5k_hw_reg_read(ah, AR5K_PHYERR_CNT2);\n\n\t \n\tath5k_hw_reg_write(ah, ATH5K_PHYERR_CNT_MAX - ATH5K_ANI_OFDM_TRIG_HIGH,\n\t\t\t   AR5K_PHYERR_CNT1);\n\tath5k_hw_reg_write(ah, ATH5K_PHYERR_CNT_MAX - ATH5K_ANI_CCK_TRIG_HIGH,\n\t\t\t   AR5K_PHYERR_CNT2);\n\n\tofdm_err = ATH5K_ANI_OFDM_TRIG_HIGH - (ATH5K_PHYERR_CNT_MAX - ofdm_err);\n\tcck_err = ATH5K_ANI_CCK_TRIG_HIGH - (ATH5K_PHYERR_CNT_MAX - cck_err);\n\n\t \n\tif (ofdm_err <= 0 && cck_err <= 0)\n\t\treturn 0;\n\n\t \n\tif (ofdm_err > 0) {\n\t\tas->ofdm_errors += ofdm_err;\n\t\tas->sum_ofdm_errors += ofdm_err;\n\t}\n\tif (cck_err > 0) {\n\t\tas->cck_errors += cck_err;\n\t\tas->sum_cck_errors += cck_err;\n\t}\n\treturn 1;\n}\n\n \nstatic void\nath5k_ani_period_restart(struct ath5k_ani_state *as)\n{\n\t \n\tas->last_ofdm_errors = as->ofdm_errors;\n\tas->last_cck_errors = as->cck_errors;\n\tas->last_listen = as->listen_time;\n\n\tas->ofdm_errors = 0;\n\tas->cck_errors = 0;\n\tas->listen_time = 0;\n}\n\n \nvoid\nath5k_ani_calibration(struct ath5k_hw *ah)\n{\n\tstruct ath5k_ani_state *as = &ah->ani_state;\n\tint listen, ofdm_high, ofdm_low, cck_high, cck_low;\n\n\t \n\tlisten = ath5k_hw_ani_get_listen_time(ah, as);\n\tas->listen_time += listen;\n\n\tif (as->ani_mode != ATH5K_ANI_MODE_AUTO)\n\t\treturn;\n\n\tath5k_ani_save_and_clear_phy_errors(ah, as);\n\n\tofdm_high = as->listen_time * ATH5K_ANI_OFDM_TRIG_HIGH / 1000;\n\tcck_high = as->listen_time * ATH5K_ANI_CCK_TRIG_HIGH / 1000;\n\tofdm_low = as->listen_time * ATH5K_ANI_OFDM_TRIG_LOW / 1000;\n\tcck_low = as->listen_time * ATH5K_ANI_CCK_TRIG_LOW / 1000;\n\n\tATH5K_DBG_UNLIMIT(ah, ATH5K_DEBUG_ANI,\n\t\t\"listen %d (now %d)\", as->listen_time, listen);\n\tATH5K_DBG_UNLIMIT(ah, ATH5K_DEBUG_ANI,\n\t\t\"check high ofdm %d/%d cck %d/%d\",\n\t\tas->ofdm_errors, ofdm_high, as->cck_errors, cck_high);\n\n\tif (as->ofdm_errors > ofdm_high || as->cck_errors > cck_high) {\n\t\t \n\t\tbool ofdm_flag = as->ofdm_errors > ofdm_high;\n\t\tath5k_ani_raise_immunity(ah, as, ofdm_flag);\n\t\tath5k_ani_period_restart(as);\n\n\t} else if (as->listen_time > 5 * ATH5K_ANI_LISTEN_PERIOD) {\n\t\t \n\t\tATH5K_DBG_UNLIMIT(ah, ATH5K_DEBUG_ANI,\n\t\t\t\"check low ofdm %d/%d cck %d/%d\",\n\t\t\tas->ofdm_errors, ofdm_low, as->cck_errors, cck_low);\n\n\t\tif (as->ofdm_errors <= ofdm_low && as->cck_errors <= cck_low)\n\t\t\tath5k_ani_lower_immunity(ah, as);\n\n\t\tath5k_ani_period_restart(as);\n\t}\n}\n\n\n \n\n \nvoid\nath5k_ani_mib_intr(struct ath5k_hw *ah)\n{\n\tstruct ath5k_ani_state *as = &ah->ani_state;\n\n\t \n\tif (!ah->ah_capabilities.cap_has_phyerr_counters)\n\t\treturn;\n\n\t \n\tath5k_hw_reg_write(ah, 0, AR5K_OFDM_FIL_CNT);\n\tath5k_hw_reg_write(ah, 0, AR5K_CCK_FIL_CNT);\n\n\tif (ah->ani_state.ani_mode != ATH5K_ANI_MODE_AUTO)\n\t\treturn;\n\n\t \n\tif (ath5k_ani_save_and_clear_phy_errors(ah, as) == 0)\n\t\treturn;\n\n\tif (as->ofdm_errors > ATH5K_ANI_OFDM_TRIG_HIGH ||\n\t    as->cck_errors > ATH5K_ANI_CCK_TRIG_HIGH)\n\t\ttasklet_schedule(&ah->ani_tasklet);\n}\n\n \nvoid\nath5k_ani_phy_error_report(struct ath5k_hw *ah,\n\t\t\t   enum ath5k_phy_error_code phyerr)\n{\n\tstruct ath5k_ani_state *as = &ah->ani_state;\n\n\tif (phyerr == AR5K_RX_PHY_ERROR_OFDM_TIMING) {\n\t\tas->ofdm_errors++;\n\t\tif (as->ofdm_errors > ATH5K_ANI_OFDM_TRIG_HIGH)\n\t\t\ttasklet_schedule(&ah->ani_tasklet);\n\t} else if (phyerr == AR5K_RX_PHY_ERROR_CCK_TIMING) {\n\t\tas->cck_errors++;\n\t\tif (as->cck_errors > ATH5K_ANI_CCK_TRIG_HIGH)\n\t\t\ttasklet_schedule(&ah->ani_tasklet);\n\t}\n}\n\n\n \n\n \nstatic void\nath5k_enable_phy_err_counters(struct ath5k_hw *ah)\n{\n\tath5k_hw_reg_write(ah, ATH5K_PHYERR_CNT_MAX - ATH5K_ANI_OFDM_TRIG_HIGH,\n\t\t\t   AR5K_PHYERR_CNT1);\n\tath5k_hw_reg_write(ah, ATH5K_PHYERR_CNT_MAX - ATH5K_ANI_CCK_TRIG_HIGH,\n\t\t\t   AR5K_PHYERR_CNT2);\n\tath5k_hw_reg_write(ah, AR5K_PHY_ERR_FIL_OFDM, AR5K_PHYERR_CNT1_MASK);\n\tath5k_hw_reg_write(ah, AR5K_PHY_ERR_FIL_CCK, AR5K_PHYERR_CNT2_MASK);\n\n\t \n\tath5k_hw_reg_write(ah, 0, AR5K_OFDM_FIL_CNT);\n\tath5k_hw_reg_write(ah, 0, AR5K_CCK_FIL_CNT);\n}\n\n \nstatic void\nath5k_disable_phy_err_counters(struct ath5k_hw *ah)\n{\n\tath5k_hw_reg_write(ah, 0, AR5K_PHYERR_CNT1);\n\tath5k_hw_reg_write(ah, 0, AR5K_PHYERR_CNT2);\n\tath5k_hw_reg_write(ah, 0, AR5K_PHYERR_CNT1_MASK);\n\tath5k_hw_reg_write(ah, 0, AR5K_PHYERR_CNT2_MASK);\n\n\t \n\tath5k_hw_reg_write(ah, 0, AR5K_OFDM_FIL_CNT);\n\tath5k_hw_reg_write(ah, 0, AR5K_CCK_FIL_CNT);\n}\n\n \nvoid\nath5k_ani_init(struct ath5k_hw *ah, enum ath5k_ani_mode mode)\n{\n\t \n\tif (ah->ah_version < AR5K_AR5212)\n\t\treturn;\n\n\tif (mode < ATH5K_ANI_MODE_OFF || mode > ATH5K_ANI_MODE_AUTO) {\n\t\tATH5K_ERR(ah, \"ANI mode %d out of range\", mode);\n\t\treturn;\n\t}\n\n\t \n\tmemset(&ah->ani_state, 0, sizeof(ah->ani_state));\n\n\t \n\tif (ah->ah_mac_srev < AR5K_SREV_AR2414)\n\t\tah->ani_state.max_spur_level = 7;\n\telse\n\t\tah->ani_state.max_spur_level = 2;\n\n\t \n\tif (mode == ATH5K_ANI_MODE_OFF) {\n\t\tATH5K_DBG_UNLIMIT(ah, ATH5K_DEBUG_ANI, \"ANI off\\n\");\n\t} else if (mode == ATH5K_ANI_MODE_MANUAL_LOW) {\n\t\tATH5K_DBG_UNLIMIT(ah, ATH5K_DEBUG_ANI,\n\t\t\t\"ANI manual low -> high sensitivity\\n\");\n\t\tath5k_ani_set_noise_immunity_level(ah, 0);\n\t\tath5k_ani_set_spur_immunity_level(ah, 0);\n\t\tath5k_ani_set_firstep_level(ah, 0);\n\t\tath5k_ani_set_ofdm_weak_signal_detection(ah, true);\n\t\tath5k_ani_set_cck_weak_signal_detection(ah, true);\n\t} else if (mode == ATH5K_ANI_MODE_MANUAL_HIGH) {\n\t\tATH5K_DBG_UNLIMIT(ah, ATH5K_DEBUG_ANI,\n\t\t\t\"ANI manual high -> low sensitivity\\n\");\n\t\tath5k_ani_set_noise_immunity_level(ah,\n\t\t\t\t\tATH5K_ANI_MAX_NOISE_IMM_LVL);\n\t\tath5k_ani_set_spur_immunity_level(ah,\n\t\t\t\t\tah->ani_state.max_spur_level);\n\t\tath5k_ani_set_firstep_level(ah, ATH5K_ANI_MAX_FIRSTEP_LVL);\n\t\tath5k_ani_set_ofdm_weak_signal_detection(ah, false);\n\t\tath5k_ani_set_cck_weak_signal_detection(ah, false);\n\t} else if (mode == ATH5K_ANI_MODE_AUTO) {\n\t\tATH5K_DBG_UNLIMIT(ah, ATH5K_DEBUG_ANI, \"ANI auto\\n\");\n\t\tath5k_ani_set_noise_immunity_level(ah, 0);\n\t\tath5k_ani_set_spur_immunity_level(ah, 0);\n\t\tath5k_ani_set_firstep_level(ah, 0);\n\t\tath5k_ani_set_ofdm_weak_signal_detection(ah, true);\n\t\tath5k_ani_set_cck_weak_signal_detection(ah, false);\n\t}\n\n\t \n\tif (mode == ATH5K_ANI_MODE_AUTO) {\n\t\tif (ah->ah_capabilities.cap_has_phyerr_counters)\n\t\t\tath5k_enable_phy_err_counters(ah);\n\t\telse\n\t\t\tath5k_hw_set_rx_filter(ah, ath5k_hw_get_rx_filter(ah) |\n\t\t\t\t\t\t   AR5K_RX_FILTER_PHYERR);\n\t} else {\n\t\tif (ah->ah_capabilities.cap_has_phyerr_counters)\n\t\t\tath5k_disable_phy_err_counters(ah);\n\t\telse\n\t\t\tath5k_hw_set_rx_filter(ah, ath5k_hw_get_rx_filter(ah) &\n\t\t\t\t\t\t   ~AR5K_RX_FILTER_PHYERR);\n\t}\n\n\tah->ani_state.ani_mode = mode;\n}\n\n\n \n\n#ifdef CONFIG_ATH5K_DEBUG\n\n \nvoid\nath5k_ani_print_counters(struct ath5k_hw *ah)\n{\n\t \n\tpr_notice(\"ACK fail\\t%d\\n\", ath5k_hw_reg_read(ah, AR5K_ACK_FAIL));\n\tpr_notice(\"RTS fail\\t%d\\n\", ath5k_hw_reg_read(ah, AR5K_RTS_FAIL));\n\tpr_notice(\"RTS success\\t%d\\n\", ath5k_hw_reg_read(ah, AR5K_RTS_OK));\n\tpr_notice(\"FCS error\\t%d\\n\", ath5k_hw_reg_read(ah, AR5K_FCS_FAIL));\n\n\t \n\tpr_notice(\"tx\\t%d\\n\", ath5k_hw_reg_read(ah, AR5K_PROFCNT_TX));\n\tpr_notice(\"rx\\t%d\\n\", ath5k_hw_reg_read(ah, AR5K_PROFCNT_RX));\n\tpr_notice(\"busy\\t%d\\n\", ath5k_hw_reg_read(ah, AR5K_PROFCNT_RXCLR));\n\tpr_notice(\"cycles\\t%d\\n\", ath5k_hw_reg_read(ah, AR5K_PROFCNT_CYCLE));\n\n\tpr_notice(\"AR5K_PHYERR_CNT1\\t%d\\n\",\n\t\t  ath5k_hw_reg_read(ah, AR5K_PHYERR_CNT1));\n\tpr_notice(\"AR5K_PHYERR_CNT2\\t%d\\n\",\n\t\t  ath5k_hw_reg_read(ah, AR5K_PHYERR_CNT2));\n\tpr_notice(\"AR5K_OFDM_FIL_CNT\\t%d\\n\",\n\t\t  ath5k_hw_reg_read(ah, AR5K_OFDM_FIL_CNT));\n\tpr_notice(\"AR5K_CCK_FIL_CNT\\t%d\\n\",\n\t\t  ath5k_hw_reg_read(ah, AR5K_CCK_FIL_CNT));\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}