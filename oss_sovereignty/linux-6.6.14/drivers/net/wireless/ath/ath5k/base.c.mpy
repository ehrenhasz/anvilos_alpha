{
  "module_name": "base.c",
  "hash_id": "e8ebc9743ed7d5a90a87c13763f719ca606b11bb5f8994f83456804816c61871",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath5k/base.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/hardirq.h>\n#include <linux/if.h>\n#include <linux/io.h>\n#include <linux/netdevice.h>\n#include <linux/cache.h>\n#include <linux/ethtool.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/etherdevice.h>\n#include <linux/nl80211.h>\n\n#include <net/cfg80211.h>\n#include <net/ieee80211_radiotap.h>\n\n#include <asm/unaligned.h>\n\n#include <net/mac80211.h>\n#include \"base.h\"\n#include \"reg.h\"\n#include \"debug.h\"\n#include \"ani.h\"\n#include \"ath5k.h\"\n#include \"../regd.h\"\n\n#define CREATE_TRACE_POINTS\n#include \"trace.h\"\n\nbool ath5k_modparam_nohwcrypt;\nmodule_param_named(nohwcrypt, ath5k_modparam_nohwcrypt, bool, 0444);\nMODULE_PARM_DESC(nohwcrypt, \"Disable hardware encryption.\");\n\nstatic bool modparam_fastchanswitch;\nmodule_param_named(fastchanswitch, modparam_fastchanswitch, bool, 0444);\nMODULE_PARM_DESC(fastchanswitch, \"Enable fast channel switching for AR2413/AR5413 radios.\");\n\nstatic bool ath5k_modparam_no_hw_rfkill_switch;\nmodule_param_named(no_hw_rfkill_switch, ath5k_modparam_no_hw_rfkill_switch,\n\t\t   bool, 0444);\nMODULE_PARM_DESC(no_hw_rfkill_switch, \"Ignore the GPIO RFKill switch state\");\n\n\n \nMODULE_AUTHOR(\"Jiri Slaby\");\nMODULE_AUTHOR(\"Nick Kossifidis\");\nMODULE_DESCRIPTION(\"Support for 5xxx series of Atheros 802.11 wireless LAN cards.\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n\nstatic int ath5k_init(struct ieee80211_hw *hw);\nstatic int ath5k_reset(struct ath5k_hw *ah, struct ieee80211_channel *chan,\n\t\t\t\t\t\t\t\tbool skip_pcu);\n\n \nstatic const struct ath5k_srev_name srev_names[] = {\n#ifdef CONFIG_ATH5K_AHB\n\t{ \"5312\",\tAR5K_VERSION_MAC,\tAR5K_SREV_AR5312_R2 },\n\t{ \"5312\",\tAR5K_VERSION_MAC,\tAR5K_SREV_AR5312_R7 },\n\t{ \"2313\",\tAR5K_VERSION_MAC,\tAR5K_SREV_AR2313_R8 },\n\t{ \"2315\",\tAR5K_VERSION_MAC,\tAR5K_SREV_AR2315_R6 },\n\t{ \"2315\",\tAR5K_VERSION_MAC,\tAR5K_SREV_AR2315_R7 },\n\t{ \"2317\",\tAR5K_VERSION_MAC,\tAR5K_SREV_AR2317_R1 },\n\t{ \"2317\",\tAR5K_VERSION_MAC,\tAR5K_SREV_AR2317_R2 },\n#else\n\t{ \"5210\",\tAR5K_VERSION_MAC,\tAR5K_SREV_AR5210 },\n\t{ \"5311\",\tAR5K_VERSION_MAC,\tAR5K_SREV_AR5311 },\n\t{ \"5311A\",\tAR5K_VERSION_MAC,\tAR5K_SREV_AR5311A },\n\t{ \"5311B\",\tAR5K_VERSION_MAC,\tAR5K_SREV_AR5311B },\n\t{ \"5211\",\tAR5K_VERSION_MAC,\tAR5K_SREV_AR5211 },\n\t{ \"5212\",\tAR5K_VERSION_MAC,\tAR5K_SREV_AR5212 },\n\t{ \"5213\",\tAR5K_VERSION_MAC,\tAR5K_SREV_AR5213 },\n\t{ \"5213A\",\tAR5K_VERSION_MAC,\tAR5K_SREV_AR5213A },\n\t{ \"2413\",\tAR5K_VERSION_MAC,\tAR5K_SREV_AR2413 },\n\t{ \"2414\",\tAR5K_VERSION_MAC,\tAR5K_SREV_AR2414 },\n\t{ \"5424\",\tAR5K_VERSION_MAC,\tAR5K_SREV_AR5424 },\n\t{ \"5413\",\tAR5K_VERSION_MAC,\tAR5K_SREV_AR5413 },\n\t{ \"5414\",\tAR5K_VERSION_MAC,\tAR5K_SREV_AR5414 },\n\t{ \"2415\",\tAR5K_VERSION_MAC,\tAR5K_SREV_AR2415 },\n\t{ \"5416\",\tAR5K_VERSION_MAC,\tAR5K_SREV_AR5416 },\n\t{ \"5418\",\tAR5K_VERSION_MAC,\tAR5K_SREV_AR5418 },\n\t{ \"2425\",\tAR5K_VERSION_MAC,\tAR5K_SREV_AR2425 },\n\t{ \"2417\",\tAR5K_VERSION_MAC,\tAR5K_SREV_AR2417 },\n#endif\n\t{ \"xxxxx\",\tAR5K_VERSION_MAC,\tAR5K_SREV_UNKNOWN },\n\t{ \"5110\",\tAR5K_VERSION_RAD,\tAR5K_SREV_RAD_5110 },\n\t{ \"5111\",\tAR5K_VERSION_RAD,\tAR5K_SREV_RAD_5111 },\n\t{ \"5111A\",\tAR5K_VERSION_RAD,\tAR5K_SREV_RAD_5111A },\n\t{ \"2111\",\tAR5K_VERSION_RAD,\tAR5K_SREV_RAD_2111 },\n\t{ \"5112\",\tAR5K_VERSION_RAD,\tAR5K_SREV_RAD_5112 },\n\t{ \"5112A\",\tAR5K_VERSION_RAD,\tAR5K_SREV_RAD_5112A },\n\t{ \"5112B\",\tAR5K_VERSION_RAD,\tAR5K_SREV_RAD_5112B },\n\t{ \"2112\",\tAR5K_VERSION_RAD,\tAR5K_SREV_RAD_2112 },\n\t{ \"2112A\",\tAR5K_VERSION_RAD,\tAR5K_SREV_RAD_2112A },\n\t{ \"2112B\",\tAR5K_VERSION_RAD,\tAR5K_SREV_RAD_2112B },\n\t{ \"2413\",\tAR5K_VERSION_RAD,\tAR5K_SREV_RAD_2413 },\n\t{ \"5413\",\tAR5K_VERSION_RAD,\tAR5K_SREV_RAD_5413 },\n\t{ \"5424\",\tAR5K_VERSION_RAD,\tAR5K_SREV_RAD_5424 },\n\t{ \"5133\",\tAR5K_VERSION_RAD,\tAR5K_SREV_RAD_5133 },\n#ifdef CONFIG_ATH5K_AHB\n\t{ \"2316\",\tAR5K_VERSION_RAD,\tAR5K_SREV_RAD_2316 },\n\t{ \"2317\",\tAR5K_VERSION_RAD,\tAR5K_SREV_RAD_2317 },\n#endif\n\t{ \"xxxxx\",\tAR5K_VERSION_RAD,\tAR5K_SREV_UNKNOWN },\n};\n\nstatic const struct ieee80211_rate ath5k_rates[] = {\n\t{ .bitrate = 10,\n\t  .hw_value = ATH5K_RATE_CODE_1M, },\n\t{ .bitrate = 20,\n\t  .hw_value = ATH5K_RATE_CODE_2M,\n\t  .hw_value_short = ATH5K_RATE_CODE_2M | AR5K_SET_SHORT_PREAMBLE,\n\t  .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 55,\n\t  .hw_value = ATH5K_RATE_CODE_5_5M,\n\t  .hw_value_short = ATH5K_RATE_CODE_5_5M | AR5K_SET_SHORT_PREAMBLE,\n\t  .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 110,\n\t  .hw_value = ATH5K_RATE_CODE_11M,\n\t  .hw_value_short = ATH5K_RATE_CODE_11M | AR5K_SET_SHORT_PREAMBLE,\n\t  .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 60,\n\t  .hw_value = ATH5K_RATE_CODE_6M,\n\t  .flags = IEEE80211_RATE_SUPPORTS_5MHZ |\n\t\t   IEEE80211_RATE_SUPPORTS_10MHZ },\n\t{ .bitrate = 90,\n\t  .hw_value = ATH5K_RATE_CODE_9M,\n\t  .flags = IEEE80211_RATE_SUPPORTS_5MHZ |\n\t\t   IEEE80211_RATE_SUPPORTS_10MHZ },\n\t{ .bitrate = 120,\n\t  .hw_value = ATH5K_RATE_CODE_12M,\n\t  .flags = IEEE80211_RATE_SUPPORTS_5MHZ |\n\t\t   IEEE80211_RATE_SUPPORTS_10MHZ },\n\t{ .bitrate = 180,\n\t  .hw_value = ATH5K_RATE_CODE_18M,\n\t  .flags = IEEE80211_RATE_SUPPORTS_5MHZ |\n\t\t   IEEE80211_RATE_SUPPORTS_10MHZ },\n\t{ .bitrate = 240,\n\t  .hw_value = ATH5K_RATE_CODE_24M,\n\t  .flags = IEEE80211_RATE_SUPPORTS_5MHZ |\n\t\t   IEEE80211_RATE_SUPPORTS_10MHZ },\n\t{ .bitrate = 360,\n\t  .hw_value = ATH5K_RATE_CODE_36M,\n\t  .flags = IEEE80211_RATE_SUPPORTS_5MHZ |\n\t\t   IEEE80211_RATE_SUPPORTS_10MHZ },\n\t{ .bitrate = 480,\n\t  .hw_value = ATH5K_RATE_CODE_48M,\n\t  .flags = IEEE80211_RATE_SUPPORTS_5MHZ |\n\t\t   IEEE80211_RATE_SUPPORTS_10MHZ },\n\t{ .bitrate = 540,\n\t  .hw_value = ATH5K_RATE_CODE_54M,\n\t  .flags = IEEE80211_RATE_SUPPORTS_5MHZ |\n\t\t   IEEE80211_RATE_SUPPORTS_10MHZ },\n};\n\nstatic inline u64 ath5k_extend_tsf(struct ath5k_hw *ah, u32 rstamp)\n{\n\tu64 tsf = ath5k_hw_get_tsf64(ah);\n\n\tif ((tsf & 0x7fff) < rstamp)\n\t\ttsf -= 0x8000;\n\n\treturn (tsf & ~0x7fff) | rstamp;\n}\n\nconst char *\nath5k_chip_name(enum ath5k_srev_type type, u_int16_t val)\n{\n\tconst char *name = \"xxxxx\";\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(srev_names); i++) {\n\t\tif (srev_names[i].sr_type != type)\n\t\t\tcontinue;\n\n\t\tif ((val & 0xf0) == srev_names[i].sr_val)\n\t\t\tname = srev_names[i].sr_name;\n\n\t\tif ((val & 0xff) == srev_names[i].sr_val) {\n\t\t\tname = srev_names[i].sr_name;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn name;\n}\nstatic unsigned int ath5k_ioread32(void *hw_priv, u32 reg_offset)\n{\n\tstruct ath5k_hw *ah = (struct ath5k_hw *) hw_priv;\n\treturn ath5k_hw_reg_read(ah, reg_offset);\n}\n\nstatic void ath5k_iowrite32(void *hw_priv, u32 val, u32 reg_offset)\n{\n\tstruct ath5k_hw *ah = (struct ath5k_hw *) hw_priv;\n\tath5k_hw_reg_write(ah, val, reg_offset);\n}\n\nstatic const struct ath_ops ath5k_common_ops = {\n\t.read = ath5k_ioread32,\n\t.write = ath5k_iowrite32,\n};\n\n \n\nstatic void ath5k_reg_notifier(struct wiphy *wiphy,\n\t\t\t       struct regulatory_request *request)\n{\n\tstruct ieee80211_hw *hw = wiphy_to_ieee80211_hw(wiphy);\n\tstruct ath5k_hw *ah = hw->priv;\n\tstruct ath_regulatory *regulatory = ath5k_hw_regulatory(ah);\n\n\tath_reg_notifier_apply(wiphy, request, regulatory);\n}\n\n \n\n \n#ifdef CONFIG_ATH5K_TEST_CHANNELS\nstatic bool ath5k_is_standard_channel(short chan, enum nl80211_band band)\n{\n\treturn true;\n}\n\n#else\nstatic bool ath5k_is_standard_channel(short chan, enum nl80211_band band)\n{\n\tif (band == NL80211_BAND_2GHZ && chan <= 14)\n\t\treturn true;\n\n\treturn\t \n\t\t(((chan & 3) == 0 && chan >= 36 && chan <= 64) ||\n\t\t \n\t\t((chan & 3) == 0 && chan >= 100 && chan <= 140) ||\n\t\t \n\t\t((chan & 3) == 1 && chan >= 149 && chan <= 165) ||\n\t\t \n\t\t(chan == 8 || chan == 12 || chan == 16) ||\n\t\t \n\t\t(chan == 184 || chan == 188 || chan == 192 || chan == 196));\n}\n#endif\n\nstatic unsigned int\nath5k_setup_channels(struct ath5k_hw *ah, struct ieee80211_channel *channels,\n\t\tunsigned int mode, unsigned int max)\n{\n\tunsigned int count, size, freq, ch;\n\tenum nl80211_band band;\n\n\tswitch (mode) {\n\tcase AR5K_MODE_11A:\n\t\t \n\t\tsize = 220;\n\t\tband = NL80211_BAND_5GHZ;\n\t\tbreak;\n\tcase AR5K_MODE_11B:\n\tcase AR5K_MODE_11G:\n\t\tsize = 26;\n\t\tband = NL80211_BAND_2GHZ;\n\t\tbreak;\n\tdefault:\n\t\tATH5K_WARN(ah, \"bad mode, not copying channels\\n\");\n\t\treturn 0;\n\t}\n\n\tcount = 0;\n\tfor (ch = 1; ch <= size && count < max; ch++) {\n\t\tfreq = ieee80211_channel_to_frequency(ch, band);\n\n\t\tif (freq == 0)  \n\t\t\tcontinue;\n\n\t\t \n\t\tchannels[count].center_freq = freq;\n\t\tchannels[count].band = band;\n\t\tchannels[count].hw_value = mode;\n\n\t\t \n\t\tif (!ath5k_channel_ok(ah, &channels[count]))\n\t\t\tcontinue;\n\n\t\tif (!ath5k_is_standard_channel(ch, band))\n\t\t\tcontinue;\n\n\t\tcount++;\n\t}\n\n\treturn count;\n}\n\nstatic void\nath5k_setup_rate_idx(struct ath5k_hw *ah, struct ieee80211_supported_band *b)\n{\n\tu8 i;\n\n\tfor (i = 0; i < AR5K_MAX_RATES; i++)\n\t\tah->rate_idx[b->band][i] = -1;\n\n\tfor (i = 0; i < b->n_bitrates; i++) {\n\t\tah->rate_idx[b->band][b->bitrates[i].hw_value] = i;\n\t\tif (b->bitrates[i].hw_value_short)\n\t\t\tah->rate_idx[b->band][b->bitrates[i].hw_value_short] = i;\n\t}\n}\n\nstatic int\nath5k_setup_bands(struct ieee80211_hw *hw)\n{\n\tstruct ath5k_hw *ah = hw->priv;\n\tstruct ieee80211_supported_band *sband;\n\tint max_c, count_c = 0;\n\tint i;\n\n\tBUILD_BUG_ON(ARRAY_SIZE(ah->sbands) < NUM_NL80211_BANDS);\n\tmax_c = ARRAY_SIZE(ah->channels);\n\n\t \n\tsband = &ah->sbands[NL80211_BAND_2GHZ];\n\tsband->band = NL80211_BAND_2GHZ;\n\tsband->bitrates = &ah->rates[NL80211_BAND_2GHZ][0];\n\n\tif (test_bit(AR5K_MODE_11G, ah->ah_capabilities.cap_mode)) {\n\t\t \n\t\tmemcpy(sband->bitrates, &ath5k_rates[0],\n\t\t       sizeof(struct ieee80211_rate) * 12);\n\t\tsband->n_bitrates = 12;\n\n\t\tsband->channels = ah->channels;\n\t\tsband->n_channels = ath5k_setup_channels(ah, sband->channels,\n\t\t\t\t\tAR5K_MODE_11G, max_c);\n\n\t\thw->wiphy->bands[NL80211_BAND_2GHZ] = sband;\n\t\tcount_c = sband->n_channels;\n\t\tmax_c -= count_c;\n\t} else if (test_bit(AR5K_MODE_11B, ah->ah_capabilities.cap_mode)) {\n\t\t \n\t\tmemcpy(sband->bitrates, &ath5k_rates[0],\n\t\t       sizeof(struct ieee80211_rate) * 4);\n\t\tsband->n_bitrates = 4;\n\n\t\t \n\t\tif (ah->ah_version == AR5K_AR5211) {\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tsband->bitrates[i].hw_value =\n\t\t\t\t\tsband->bitrates[i].hw_value & 0xF;\n\t\t\t\tsband->bitrates[i].hw_value_short =\n\t\t\t\t\tsband->bitrates[i].hw_value_short & 0xF;\n\t\t\t}\n\t\t}\n\n\t\tsband->channels = ah->channels;\n\t\tsband->n_channels = ath5k_setup_channels(ah, sband->channels,\n\t\t\t\t\tAR5K_MODE_11B, max_c);\n\n\t\thw->wiphy->bands[NL80211_BAND_2GHZ] = sband;\n\t\tcount_c = sband->n_channels;\n\t\tmax_c -= count_c;\n\t}\n\tath5k_setup_rate_idx(ah, sband);\n\n\t \n\tif (test_bit(AR5K_MODE_11A, ah->ah_capabilities.cap_mode)) {\n\t\tsband = &ah->sbands[NL80211_BAND_5GHZ];\n\t\tsband->band = NL80211_BAND_5GHZ;\n\t\tsband->bitrates = &ah->rates[NL80211_BAND_5GHZ][0];\n\n\t\tmemcpy(sband->bitrates, &ath5k_rates[4],\n\t\t       sizeof(struct ieee80211_rate) * 8);\n\t\tsband->n_bitrates = 8;\n\n\t\tsband->channels = &ah->channels[count_c];\n\t\tsband->n_channels = ath5k_setup_channels(ah, sband->channels,\n\t\t\t\t\tAR5K_MODE_11A, max_c);\n\n\t\thw->wiphy->bands[NL80211_BAND_5GHZ] = sband;\n\t}\n\tath5k_setup_rate_idx(ah, sband);\n\n\tath5k_debug_dump_bands(ah);\n\n\treturn 0;\n}\n\n \nint\nath5k_chan_set(struct ath5k_hw *ah, struct cfg80211_chan_def *chandef)\n{\n\tATH5K_DBG(ah, ATH5K_DEBUG_RESET,\n\t\t  \"channel set, resetting (%u -> %u MHz)\\n\",\n\t\t  ah->curchan->center_freq, chandef->chan->center_freq);\n\n\tswitch (chandef->width) {\n\tcase NL80211_CHAN_WIDTH_20:\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\t\tah->ah_bwmode = AR5K_BWMODE_DEFAULT;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_5:\n\t\tah->ah_bwmode = AR5K_BWMODE_5MHZ;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_10:\n\t\tah->ah_bwmode = AR5K_BWMODE_10MHZ;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\treturn ath5k_reset(ah, chandef->chan, true);\n}\n\nvoid ath5k_vif_iter(void *data, u8 *mac, struct ieee80211_vif *vif)\n{\n\tstruct ath5k_vif_iter_data *iter_data = data;\n\tint i;\n\tstruct ath5k_vif *avf = (void *)vif->drv_priv;\n\n\tif (iter_data->hw_macaddr)\n\t\tfor (i = 0; i < ETH_ALEN; i++)\n\t\t\titer_data->mask[i] &=\n\t\t\t\t~(iter_data->hw_macaddr[i] ^ mac[i]);\n\n\tif (!iter_data->found_active) {\n\t\titer_data->found_active = true;\n\t\tmemcpy(iter_data->active_mac, mac, ETH_ALEN);\n\t}\n\n\tif (iter_data->need_set_hw_addr && iter_data->hw_macaddr)\n\t\tif (ether_addr_equal(iter_data->hw_macaddr, mac))\n\t\t\titer_data->need_set_hw_addr = false;\n\n\tif (!iter_data->any_assoc) {\n\t\tif (avf->assoc)\n\t\t\titer_data->any_assoc = true;\n\t}\n\n\t \n\tif (avf->opmode == NL80211_IFTYPE_AP)\n\t\titer_data->opmode = NL80211_IFTYPE_AP;\n\telse {\n\t\tif (avf->opmode == NL80211_IFTYPE_STATION)\n\t\t\titer_data->n_stas++;\n\t\tif (iter_data->opmode == NL80211_IFTYPE_UNSPECIFIED)\n\t\t\titer_data->opmode = avf->opmode;\n\t}\n}\n\nvoid\nath5k_update_bssid_mask_and_opmode(struct ath5k_hw *ah,\n\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tstruct ath_common *common = ath5k_hw_common(ah);\n\tstruct ath5k_vif_iter_data iter_data;\n\tu32 rfilt;\n\n\t \n\titer_data.hw_macaddr = common->macaddr;\n\teth_broadcast_addr(iter_data.mask);\n\titer_data.found_active = false;\n\titer_data.need_set_hw_addr = true;\n\titer_data.opmode = NL80211_IFTYPE_UNSPECIFIED;\n\titer_data.n_stas = 0;\n\n\tif (vif)\n\t\tath5k_vif_iter(&iter_data, vif->addr, vif);\n\n\t \n\tieee80211_iterate_active_interfaces_atomic(\n\t\tah->hw, IEEE80211_IFACE_ITER_RESUME_ALL,\n\t\tath5k_vif_iter, &iter_data);\n\tmemcpy(ah->bssidmask, iter_data.mask, ETH_ALEN);\n\n\tah->opmode = iter_data.opmode;\n\tif (ah->opmode == NL80211_IFTYPE_UNSPECIFIED)\n\t\t \n\t\tah->opmode = NL80211_IFTYPE_STATION;\n\n\tath5k_hw_set_opmode(ah, ah->opmode);\n\tATH5K_DBG(ah, ATH5K_DEBUG_MODE, \"mode setup opmode %d (%s)\\n\",\n\t\t  ah->opmode, ath_opmode_to_string(ah->opmode));\n\n\tif (iter_data.need_set_hw_addr && iter_data.found_active)\n\t\tath5k_hw_set_lladdr(ah, iter_data.active_mac);\n\n\tif (ath5k_hw_hasbssidmask(ah))\n\t\tath5k_hw_set_bssid_mask(ah, ah->bssidmask);\n\n\t \n\tif (iter_data.n_stas > 1) {\n\t\t \n\t\tah->filter_flags |= AR5K_RX_FILTER_PROM;\n\t}\n\n\trfilt = ah->filter_flags;\n\tath5k_hw_set_rx_filter(ah, rfilt);\n\tATH5K_DBG(ah, ATH5K_DEBUG_MODE, \"RX filter 0x%x\\n\", rfilt);\n}\n\nstatic inline int\nath5k_hw_to_driver_rix(struct ath5k_hw *ah, int hw_rix)\n{\n\tint rix;\n\n\t \n\tif (WARN(hw_rix < 0 || hw_rix >= AR5K_MAX_RATES,\n\t\t\t\"hw_rix out of bounds: %x\\n\", hw_rix))\n\t\treturn 0;\n\n\trix = ah->rate_idx[ah->curchan->band][hw_rix];\n\tif (WARN(rix < 0, \"invalid hw_rix: %x\\n\", hw_rix))\n\t\trix = 0;\n\n\treturn rix;\n}\n\n \n\nstatic\nstruct sk_buff *ath5k_rx_skb_alloc(struct ath5k_hw *ah, dma_addr_t *skb_addr)\n{\n\tstruct ath_common *common = ath5k_hw_common(ah);\n\tstruct sk_buff *skb;\n\n\t \n\tskb = ath_rxbuf_alloc(common,\n\t\t\t      common->rx_bufsize,\n\t\t\t      GFP_ATOMIC);\n\n\tif (!skb) {\n\t\tATH5K_ERR(ah, \"can't alloc skbuff of size %u\\n\",\n\t\t\t\tcommon->rx_bufsize);\n\t\treturn NULL;\n\t}\n\n\t*skb_addr = dma_map_single(ah->dev,\n\t\t\t\t   skb->data, common->rx_bufsize,\n\t\t\t\t   DMA_FROM_DEVICE);\n\n\tif (unlikely(dma_mapping_error(ah->dev, *skb_addr))) {\n\t\tATH5K_ERR(ah, \"%s: DMA mapping failed\\n\", __func__);\n\t\tdev_kfree_skb(skb);\n\t\treturn NULL;\n\t}\n\treturn skb;\n}\n\nstatic int\nath5k_rxbuf_setup(struct ath5k_hw *ah, struct ath5k_buf *bf)\n{\n\tstruct sk_buff *skb = bf->skb;\n\tstruct ath5k_desc *ds;\n\tint ret;\n\n\tif (!skb) {\n\t\tskb = ath5k_rx_skb_alloc(ah, &bf->skbaddr);\n\t\tif (!skb)\n\t\t\treturn -ENOMEM;\n\t\tbf->skb = skb;\n\t}\n\n\t \n\tds = bf->desc;\n\tds->ds_link = bf->daddr;\t \n\tds->ds_data = bf->skbaddr;\n\tret = ath5k_hw_setup_rx_desc(ah, ds, ah->common.rx_bufsize, 0);\n\tif (ret) {\n\t\tATH5K_ERR(ah, \"%s: could not setup RX desc\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tif (ah->rxlink != NULL)\n\t\t*ah->rxlink = bf->daddr;\n\tah->rxlink = &ds->ds_link;\n\treturn 0;\n}\n\nstatic enum ath5k_pkt_type get_hw_packet_type(struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr;\n\tenum ath5k_pkt_type htype;\n\t__le16 fc;\n\n\thdr = (struct ieee80211_hdr *)skb->data;\n\tfc = hdr->frame_control;\n\n\tif (ieee80211_is_beacon(fc))\n\t\thtype = AR5K_PKT_TYPE_BEACON;\n\telse if (ieee80211_is_probe_resp(fc))\n\t\thtype = AR5K_PKT_TYPE_PROBE_RESP;\n\telse if (ieee80211_is_atim(fc))\n\t\thtype = AR5K_PKT_TYPE_ATIM;\n\telse if (ieee80211_is_pspoll(fc))\n\t\thtype = AR5K_PKT_TYPE_PSPOLL;\n\telse\n\t\thtype = AR5K_PKT_TYPE_NORMAL;\n\n\treturn htype;\n}\n\nstatic struct ieee80211_rate *\nath5k_get_rate(const struct ieee80211_hw *hw,\n\t       const struct ieee80211_tx_info *info,\n\t       struct ath5k_buf *bf, int idx)\n{\n\t \n\tif (bf->rates[idx].idx < 0) {\n\t\treturn NULL;\n\t}\n\n\treturn &hw->wiphy->bands[info->band]->bitrates[ bf->rates[idx].idx ];\n}\n\nstatic u16\nath5k_get_rate_hw_value(const struct ieee80211_hw *hw,\n\t\t\tconst struct ieee80211_tx_info *info,\n\t\t\tstruct ath5k_buf *bf, int idx)\n{\n\tstruct ieee80211_rate *rate;\n\tu16 hw_rate;\n\tu8 rc_flags;\n\n\trate = ath5k_get_rate(hw, info, bf, idx);\n\tif (!rate)\n\t\treturn 0;\n\n\trc_flags = bf->rates[idx].flags;\n\thw_rate = (rc_flags & IEEE80211_TX_RC_USE_SHORT_PREAMBLE) ?\n\t\t   rate->hw_value_short : rate->hw_value;\n\n\treturn hw_rate;\n}\n\nstatic bool ath5k_merge_ratetbl(struct ieee80211_sta *sta,\n\t\t\t\tstruct ath5k_buf *bf,\n\t\t\t\tstruct ieee80211_tx_info *tx_info)\n{\n\tstruct ieee80211_sta_rates *ratetbl;\n\tu8 i;\n\n\tif (!sta)\n\t\treturn false;\n\n\tratetbl = rcu_dereference(sta->rates);\n\tif (!ratetbl)\n\t\treturn false;\n\n\tif (tx_info->control.rates[0].idx < 0 ||\n\t    tx_info->control.rates[0].count == 0)\n\t{\n\t\ti = 0;\n\t} else {\n\t\tbf->rates[0] = tx_info->control.rates[0];\n\t\ti = 1;\n\t}\n\n\tfor ( ; i < IEEE80211_TX_MAX_RATES; i++) {\n\t\tbf->rates[i].idx = ratetbl->rate[i].idx;\n\t\tbf->rates[i].flags = ratetbl->rate[i].flags;\n\t\tif (tx_info->control.use_rts)\n\t\t\tbf->rates[i].count = ratetbl->rate[i].count_rts;\n\t\telse if (tx_info->control.use_cts_prot)\n\t\t\tbf->rates[i].count = ratetbl->rate[i].count_cts;\n\t\telse\n\t\t\tbf->rates[i].count = ratetbl->rate[i].count;\n\t}\n\n\treturn true;\n}\n\nstatic int\nath5k_txbuf_setup(struct ath5k_hw *ah, struct ath5k_buf *bf,\n\t\t  struct ath5k_txq *txq, int padsize,\n\t\t  struct ieee80211_tx_control *control)\n{\n\tstruct ath5k_desc *ds = bf->desc;\n\tstruct sk_buff *skb = bf->skb;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tunsigned int pktlen, flags, keyidx = AR5K_TXKEYIX_INVALID;\n\tstruct ieee80211_rate *rate;\n\tstruct ieee80211_sta *sta;\n\tunsigned int mrr_rate[3], mrr_tries[3];\n\tint i, ret;\n\tu16 hw_rate;\n\tu16 cts_rate = 0;\n\tu16 duration = 0;\n\tu8 rc_flags;\n\n\tflags = AR5K_TXDESC_INTREQ | AR5K_TXDESC_CLRDMASK;\n\n\t \n\tbf->skbaddr = dma_map_single(ah->dev, skb->data, skb->len,\n\t\t\tDMA_TO_DEVICE);\n\n\tif (dma_mapping_error(ah->dev, bf->skbaddr))\n\t\treturn -ENOSPC;\n\n\tif (control)\n\t\tsta = control->sta;\n\telse\n\t\tsta = NULL;\n\n\tif (!ath5k_merge_ratetbl(sta, bf, info)) {\n\t\tieee80211_get_tx_rates(info->control.vif,\n\t\t\t\t       sta, skb, bf->rates,\n\t\t\t\t       ARRAY_SIZE(bf->rates));\n\t}\n\n\trate = ath5k_get_rate(ah->hw, info, bf, 0);\n\n\tif (!rate) {\n\t\tret = -EINVAL;\n\t\tgoto err_unmap;\n\t}\n\n\tif (info->flags & IEEE80211_TX_CTL_NO_ACK)\n\t\tflags |= AR5K_TXDESC_NOACK;\n\n\trc_flags = bf->rates[0].flags;\n\n\thw_rate = ath5k_get_rate_hw_value(ah->hw, info, bf, 0);\n\n\tpktlen = skb->len;\n\n\t \n\tif (info->control.hw_key) {\n\t\tkeyidx = info->control.hw_key->hw_key_idx;\n\t\tpktlen += info->control.hw_key->icv_len;\n\t}\n\tif (rc_flags & IEEE80211_TX_RC_USE_RTS_CTS) {\n\t\tflags |= AR5K_TXDESC_RTSENA;\n\t\tcts_rate = ieee80211_get_rts_cts_rate(ah->hw, info)->hw_value;\n\t\tduration = le16_to_cpu(ieee80211_rts_duration(ah->hw,\n\t\t\tinfo->control.vif, pktlen, info));\n\t}\n\tif (rc_flags & IEEE80211_TX_RC_USE_CTS_PROTECT) {\n\t\tflags |= AR5K_TXDESC_CTSENA;\n\t\tcts_rate = ieee80211_get_rts_cts_rate(ah->hw, info)->hw_value;\n\t\tduration = le16_to_cpu(ieee80211_ctstoself_duration(ah->hw,\n\t\t\tinfo->control.vif, pktlen, info));\n\t}\n\n\tret = ah->ah_setup_tx_desc(ah, ds, pktlen,\n\t\tieee80211_get_hdrlen_from_skb(skb), padsize,\n\t\tget_hw_packet_type(skb),\n\t\t(ah->ah_txpower.txp_requested * 2),\n\t\thw_rate,\n\t\tbf->rates[0].count, keyidx, ah->ah_tx_ant, flags,\n\t\tcts_rate, duration);\n\tif (ret)\n\t\tgoto err_unmap;\n\n\t \n\tif (ah->ah_capabilities.cap_has_mrr_support) {\n\t\tmemset(mrr_rate, 0, sizeof(mrr_rate));\n\t\tmemset(mrr_tries, 0, sizeof(mrr_tries));\n\n\t\tfor (i = 0; i < 3; i++) {\n\n\t\t\trate = ath5k_get_rate(ah->hw, info, bf, i);\n\t\t\tif (!rate)\n\t\t\t\tbreak;\n\n\t\t\tmrr_rate[i] = ath5k_get_rate_hw_value(ah->hw, info, bf, i);\n\t\t\tmrr_tries[i] = bf->rates[i].count;\n\t\t}\n\n\t\tath5k_hw_setup_mrr_tx_desc(ah, ds,\n\t\t\tmrr_rate[0], mrr_tries[0],\n\t\t\tmrr_rate[1], mrr_tries[1],\n\t\t\tmrr_rate[2], mrr_tries[2]);\n\t}\n\n\tds->ds_link = 0;\n\tds->ds_data = bf->skbaddr;\n\n\tspin_lock_bh(&txq->lock);\n\tlist_add_tail(&bf->list, &txq->q);\n\ttxq->txq_len++;\n\tif (txq->link == NULL)  \n\t\tath5k_hw_set_txdp(ah, txq->qnum, bf->daddr);\n\telse  \n\t\t*txq->link = bf->daddr;\n\n\ttxq->link = &ds->ds_link;\n\tath5k_hw_start_tx_dma(ah, txq->qnum);\n\tspin_unlock_bh(&txq->lock);\n\n\treturn 0;\nerr_unmap:\n\tdma_unmap_single(ah->dev, bf->skbaddr, skb->len, DMA_TO_DEVICE);\n\treturn ret;\n}\n\n \n\nstatic int\nath5k_desc_alloc(struct ath5k_hw *ah)\n{\n\tstruct ath5k_desc *ds;\n\tstruct ath5k_buf *bf;\n\tdma_addr_t da;\n\tunsigned int i;\n\tint ret;\n\n\t \n\tah->desc_len = sizeof(struct ath5k_desc) *\n\t\t\t(ATH_TXBUF + ATH_RXBUF + ATH_BCBUF + 1);\n\n\tah->desc = dma_alloc_coherent(ah->dev, ah->desc_len,\n\t\t\t\t&ah->desc_daddr, GFP_KERNEL);\n\tif (ah->desc == NULL) {\n\t\tATH5K_ERR(ah, \"can't allocate descriptors\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tds = ah->desc;\n\tda = ah->desc_daddr;\n\tATH5K_DBG(ah, ATH5K_DEBUG_ANY, \"DMA map: %p (%zu) -> %llx\\n\",\n\t\tds, ah->desc_len, (unsigned long long)ah->desc_daddr);\n\n\tbf = kcalloc(1 + ATH_TXBUF + ATH_RXBUF + ATH_BCBUF,\n\t\t\tsizeof(struct ath5k_buf), GFP_KERNEL);\n\tif (bf == NULL) {\n\t\tATH5K_ERR(ah, \"can't allocate bufptr\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_free;\n\t}\n\tah->bufptr = bf;\n\n\tINIT_LIST_HEAD(&ah->rxbuf);\n\tfor (i = 0; i < ATH_RXBUF; i++, bf++, ds++, da += sizeof(*ds)) {\n\t\tbf->desc = ds;\n\t\tbf->daddr = da;\n\t\tlist_add_tail(&bf->list, &ah->rxbuf);\n\t}\n\n\tINIT_LIST_HEAD(&ah->txbuf);\n\tah->txbuf_len = ATH_TXBUF;\n\tfor (i = 0; i < ATH_TXBUF; i++, bf++, ds++, da += sizeof(*ds)) {\n\t\tbf->desc = ds;\n\t\tbf->daddr = da;\n\t\tlist_add_tail(&bf->list, &ah->txbuf);\n\t}\n\n\t \n\tINIT_LIST_HEAD(&ah->bcbuf);\n\tfor (i = 0; i < ATH_BCBUF; i++, bf++, ds++, da += sizeof(*ds)) {\n\t\tbf->desc = ds;\n\t\tbf->daddr = da;\n\t\tlist_add_tail(&bf->list, &ah->bcbuf);\n\t}\n\n\treturn 0;\nerr_free:\n\tdma_free_coherent(ah->dev, ah->desc_len, ah->desc, ah->desc_daddr);\nerr:\n\tah->desc = NULL;\n\treturn ret;\n}\n\nvoid\nath5k_txbuf_free_skb(struct ath5k_hw *ah, struct ath5k_buf *bf)\n{\n\tBUG_ON(!bf);\n\tif (!bf->skb)\n\t\treturn;\n\tdma_unmap_single(ah->dev, bf->skbaddr, bf->skb->len,\n\t\t\tDMA_TO_DEVICE);\n\tieee80211_free_txskb(ah->hw, bf->skb);\n\tbf->skb = NULL;\n\tbf->skbaddr = 0;\n\tbf->desc->ds_data = 0;\n}\n\nvoid\nath5k_rxbuf_free_skb(struct ath5k_hw *ah, struct ath5k_buf *bf)\n{\n\tstruct ath_common *common = ath5k_hw_common(ah);\n\n\tBUG_ON(!bf);\n\tif (!bf->skb)\n\t\treturn;\n\tdma_unmap_single(ah->dev, bf->skbaddr, common->rx_bufsize,\n\t\t\tDMA_FROM_DEVICE);\n\tdev_kfree_skb_any(bf->skb);\n\tbf->skb = NULL;\n\tbf->skbaddr = 0;\n\tbf->desc->ds_data = 0;\n}\n\nstatic void\nath5k_desc_free(struct ath5k_hw *ah)\n{\n\tstruct ath5k_buf *bf;\n\n\tlist_for_each_entry(bf, &ah->txbuf, list)\n\t\tath5k_txbuf_free_skb(ah, bf);\n\tlist_for_each_entry(bf, &ah->rxbuf, list)\n\t\tath5k_rxbuf_free_skb(ah, bf);\n\tlist_for_each_entry(bf, &ah->bcbuf, list)\n\t\tath5k_txbuf_free_skb(ah, bf);\n\n\t \n\tdma_free_coherent(ah->dev, ah->desc_len, ah->desc, ah->desc_daddr);\n\tah->desc = NULL;\n\tah->desc_daddr = 0;\n\n\tkfree(ah->bufptr);\n\tah->bufptr = NULL;\n}\n\n\n \n\nstatic struct ath5k_txq *\nath5k_txq_setup(struct ath5k_hw *ah,\n\t\tint qtype, int subtype)\n{\n\tstruct ath5k_txq *txq;\n\tstruct ath5k_txq_info qi = {\n\t\t.tqi_subtype = subtype,\n\t\t \n\t\t.tqi_aifs = AR5K_TUNE_AIFS,\n\t\t.tqi_cw_min = AR5K_TUNE_CWMIN,\n\t\t.tqi_cw_max = AR5K_TUNE_CWMAX\n\t};\n\tint qnum;\n\n\t \n\tqi.tqi_flags = AR5K_TXQ_FLAG_TXEOLINT_ENABLE |\n\t\t\t\tAR5K_TXQ_FLAG_TXDESCINT_ENABLE;\n\tqnum = ath5k_hw_setup_tx_queue(ah, qtype, &qi);\n\tif (qnum < 0) {\n\t\t \n\t\treturn ERR_PTR(qnum);\n\t}\n\ttxq = &ah->txqs[qnum];\n\tif (!txq->setup) {\n\t\ttxq->qnum = qnum;\n\t\ttxq->link = NULL;\n\t\tINIT_LIST_HEAD(&txq->q);\n\t\tspin_lock_init(&txq->lock);\n\t\ttxq->setup = true;\n\t\ttxq->txq_len = 0;\n\t\ttxq->txq_max = ATH5K_TXQ_LEN_MAX;\n\t\ttxq->txq_poll_mark = false;\n\t\ttxq->txq_stuck = 0;\n\t}\n\treturn &ah->txqs[qnum];\n}\n\nstatic int\nath5k_beaconq_setup(struct ath5k_hw *ah)\n{\n\tstruct ath5k_txq_info qi = {\n\t\t \n\t\t.tqi_aifs = AR5K_TUNE_AIFS,\n\t\t.tqi_cw_min = AR5K_TUNE_CWMIN,\n\t\t.tqi_cw_max = AR5K_TUNE_CWMAX,\n\t\t \n\t\t.tqi_flags = AR5K_TXQ_FLAG_TXDESCINT_ENABLE\n\t};\n\n\treturn ath5k_hw_setup_tx_queue(ah, AR5K_TX_QUEUE_BEACON, &qi);\n}\n\nstatic int\nath5k_beaconq_config(struct ath5k_hw *ah)\n{\n\tstruct ath5k_txq_info qi;\n\tint ret;\n\n\tret = ath5k_hw_get_tx_queueprops(ah, ah->bhalq, &qi);\n\tif (ret)\n\t\tgoto err;\n\n\tif (ah->opmode == NL80211_IFTYPE_AP ||\n\t    ah->opmode == NL80211_IFTYPE_MESH_POINT) {\n\t\t \n\t\tqi.tqi_aifs = 0;\n\t\tqi.tqi_cw_min = 0;\n\t\tqi.tqi_cw_max = 0;\n\t} else if (ah->opmode == NL80211_IFTYPE_ADHOC) {\n\t\t \n\t\tqi.tqi_aifs = 0;\n\t\tqi.tqi_cw_min = 0;\n\t\tqi.tqi_cw_max = 2 * AR5K_TUNE_CWMIN;\n\t}\n\n\tATH5K_DBG(ah, ATH5K_DEBUG_BEACON,\n\t\t\"beacon queueprops tqi_aifs:%d tqi_cw_min:%d tqi_cw_max:%d\\n\",\n\t\tqi.tqi_aifs, qi.tqi_cw_min, qi.tqi_cw_max);\n\n\tret = ath5k_hw_set_tx_queueprops(ah, ah->bhalq, &qi);\n\tif (ret) {\n\t\tATH5K_ERR(ah, \"%s: unable to update parameters for beacon \"\n\t\t\t\"hardware queue!\\n\", __func__);\n\t\tgoto err;\n\t}\n\tret = ath5k_hw_reset_tx_queue(ah, ah->bhalq);  \n\tif (ret)\n\t\tgoto err;\n\n\t \n\tret = ath5k_hw_get_tx_queueprops(ah, AR5K_TX_QUEUE_ID_CAB, &qi);\n\tif (ret)\n\t\tgoto err;\n\n\tqi.tqi_ready_time = (ah->bintval * 80) / 100;\n\tret = ath5k_hw_set_tx_queueprops(ah, AR5K_TX_QUEUE_ID_CAB, &qi);\n\tif (ret)\n\t\tgoto err;\n\n\tret = ath5k_hw_reset_tx_queue(ah, AR5K_TX_QUEUE_ID_CAB);\nerr:\n\treturn ret;\n}\n\n \nstatic void\nath5k_drain_tx_buffs(struct ath5k_hw *ah)\n{\n\tstruct ath5k_txq *txq;\n\tstruct ath5k_buf *bf, *bf0;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ah->txqs); i++) {\n\t\tif (ah->txqs[i].setup) {\n\t\t\ttxq = &ah->txqs[i];\n\t\t\tspin_lock_bh(&txq->lock);\n\t\t\tlist_for_each_entry_safe(bf, bf0, &txq->q, list) {\n\t\t\t\tath5k_debug_printtxbuf(ah, bf);\n\n\t\t\t\tath5k_txbuf_free_skb(ah, bf);\n\n\t\t\t\tspin_lock(&ah->txbuflock);\n\t\t\t\tlist_move_tail(&bf->list, &ah->txbuf);\n\t\t\t\tah->txbuf_len++;\n\t\t\t\ttxq->txq_len--;\n\t\t\t\tspin_unlock(&ah->txbuflock);\n\t\t\t}\n\t\t\ttxq->link = NULL;\n\t\t\ttxq->txq_poll_mark = false;\n\t\t\tspin_unlock_bh(&txq->lock);\n\t\t}\n\t}\n}\n\nstatic void\nath5k_txq_release(struct ath5k_hw *ah)\n{\n\tstruct ath5k_txq *txq = ah->txqs;\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ah->txqs); i++, txq++)\n\t\tif (txq->setup) {\n\t\t\tath5k_hw_release_tx_queue(ah, txq->qnum);\n\t\t\ttxq->setup = false;\n\t\t}\n}\n\n\n \n\n \nstatic int\nath5k_rx_start(struct ath5k_hw *ah)\n{\n\tstruct ath_common *common = ath5k_hw_common(ah);\n\tstruct ath5k_buf *bf;\n\tint ret;\n\n\tcommon->rx_bufsize = roundup(IEEE80211_MAX_FRAME_LEN, common->cachelsz);\n\n\tATH5K_DBG(ah, ATH5K_DEBUG_RESET, \"cachelsz %u rx_bufsize %u\\n\",\n\t\t  common->cachelsz, common->rx_bufsize);\n\n\tspin_lock_bh(&ah->rxbuflock);\n\tah->rxlink = NULL;\n\tlist_for_each_entry(bf, &ah->rxbuf, list) {\n\t\tret = ath5k_rxbuf_setup(ah, bf);\n\t\tif (ret != 0) {\n\t\t\tspin_unlock_bh(&ah->rxbuflock);\n\t\t\tgoto err;\n\t\t}\n\t}\n\tbf = list_first_entry(&ah->rxbuf, struct ath5k_buf, list);\n\tath5k_hw_set_rxdp(ah, bf->daddr);\n\tspin_unlock_bh(&ah->rxbuflock);\n\n\tath5k_hw_start_rx_dma(ah);\t \n\tath5k_update_bssid_mask_and_opmode(ah, NULL);  \n\tath5k_hw_start_rx_pcu(ah);\t \n\n\treturn 0;\nerr:\n\treturn ret;\n}\n\n \nstatic void\nath5k_rx_stop(struct ath5k_hw *ah)\n{\n\n\tath5k_hw_set_rx_filter(ah, 0);\t \n\tath5k_hw_stop_rx_pcu(ah);\t \n\n\tath5k_debug_printrxbuffs(ah);\n}\n\nstatic unsigned int\nath5k_rx_decrypted(struct ath5k_hw *ah, struct sk_buff *skb,\n\t\t   struct ath5k_rx_status *rs)\n{\n\tstruct ath_common *common = ath5k_hw_common(ah);\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\tunsigned int keyix, hlen;\n\n\tif (!(rs->rs_status & AR5K_RXERR_DECRYPT) &&\n\t\t\trs->rs_keyix != AR5K_RXKEYIX_INVALID)\n\t\treturn RX_FLAG_DECRYPTED;\n\n\t \n\thlen = ieee80211_hdrlen(hdr->frame_control);\n\tif (ieee80211_has_protected(hdr->frame_control) &&\n\t    !(rs->rs_status & AR5K_RXERR_DECRYPT) &&\n\t    skb->len >= hlen + 4) {\n\t\tkeyix = skb->data[hlen + 3] >> 6;\n\n\t\tif (test_bit(keyix, common->keymap))\n\t\t\treturn RX_FLAG_DECRYPTED;\n\t}\n\n\treturn 0;\n}\n\n\nstatic void\nath5k_check_ibss_tsf(struct ath5k_hw *ah, struct sk_buff *skb,\n\t\t     struct ieee80211_rx_status *rxs)\n{\n\tu64 tsf, bc_tstamp;\n\tu32 hw_tu;\n\tstruct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)skb->data;\n\n\tif (le16_to_cpu(mgmt->u.beacon.capab_info) & WLAN_CAPABILITY_IBSS) {\n\t\t \n\t\ttsf = ath5k_hw_get_tsf64(ah);\n\t\tbc_tstamp = le64_to_cpu(mgmt->u.beacon.timestamp);\n\t\thw_tu = TSF_TO_TU(tsf);\n\n\t\tATH5K_DBG_UNLIMIT(ah, ATH5K_DEBUG_BEACON,\n\t\t\t\"beacon %llx mactime %llx (diff %lld) tsf now %llx\\n\",\n\t\t\t(unsigned long long)bc_tstamp,\n\t\t\t(unsigned long long)rxs->mactime,\n\t\t\t(unsigned long long)(rxs->mactime - bc_tstamp),\n\t\t\t(unsigned long long)tsf);\n\n\t\t \n\t\tif (bc_tstamp > rxs->mactime) {\n\t\t\tATH5K_DBG_UNLIMIT(ah, ATH5K_DEBUG_BEACON,\n\t\t\t\t\"fixing mactime from %llx to %llx\\n\",\n\t\t\t\t(unsigned long long)rxs->mactime,\n\t\t\t\t(unsigned long long)tsf);\n\t\t\trxs->mactime = tsf;\n\t\t}\n\n\t\t \n\t\tif (hw_tu >= ah->nexttbtt)\n\t\t\tath5k_beacon_update_timers(ah, bc_tstamp);\n\n\t\t \n\t\tif (!ath5k_hw_check_beacon_timers(ah, ah->bintval)) {\n\t\t\tath5k_beacon_update_timers(ah, bc_tstamp);\n\t\t\tATH5K_DBG_UNLIMIT(ah, ATH5K_DEBUG_BEACON,\n\t\t\t\t\"fixed beacon timers after beacon receive\\n\");\n\t\t}\n\t}\n}\n\n \nstatic int ath5k_common_padpos(struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\t__le16 frame_control = hdr->frame_control;\n\tint padpos = 24;\n\n\tif (ieee80211_has_a4(frame_control))\n\t\tpadpos += ETH_ALEN;\n\n\tif (ieee80211_is_data_qos(frame_control))\n\t\tpadpos += IEEE80211_QOS_CTL_LEN;\n\n\treturn padpos;\n}\n\n \nstatic int ath5k_add_padding(struct sk_buff *skb)\n{\n\tint padpos = ath5k_common_padpos(skb);\n\tint padsize = padpos & 3;\n\n\tif (padsize && skb->len > padpos) {\n\n\t\tif (skb_headroom(skb) < padsize)\n\t\t\treturn -1;\n\n\t\tskb_push(skb, padsize);\n\t\tmemmove(skb->data, skb->data + padsize, padpos);\n\t\treturn padsize;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ath5k_remove_padding(struct sk_buff *skb)\n{\n\tint padpos = ath5k_common_padpos(skb);\n\tint padsize = padpos & 3;\n\n\tif (padsize && skb->len >= padpos + padsize) {\n\t\tmemmove(skb->data + padsize, skb->data, padpos);\n\t\tskb_pull(skb, padsize);\n\t\treturn padsize;\n\t}\n\n\treturn 0;\n}\n\nstatic void\nath5k_receive_frame(struct ath5k_hw *ah, struct sk_buff *skb,\n\t\t    struct ath5k_rx_status *rs)\n{\n\tstruct ieee80211_rx_status *rxs;\n\tstruct ath_common *common = ath5k_hw_common(ah);\n\n\tath5k_remove_padding(skb);\n\n\trxs = IEEE80211_SKB_RXCB(skb);\n\n\trxs->flag = 0;\n\tif (unlikely(rs->rs_status & AR5K_RXERR_MIC))\n\t\trxs->flag |= RX_FLAG_MMIC_ERROR;\n\tif (unlikely(rs->rs_status & AR5K_RXERR_CRC))\n\t\trxs->flag |= RX_FLAG_FAILED_FCS_CRC;\n\n\n\t \n\trxs->mactime = ath5k_extend_tsf(ah, rs->rs_tstamp);\n\trxs->flag |= RX_FLAG_MACTIME_END;\n\n\trxs->freq = ah->curchan->center_freq;\n\trxs->band = ah->curchan->band;\n\n\trxs->signal = ah->ah_noise_floor + rs->rs_rssi;\n\n\trxs->antenna = rs->rs_antenna;\n\n\tif (rs->rs_antenna > 0 && rs->rs_antenna < 5)\n\t\tah->stats.antenna_rx[rs->rs_antenna]++;\n\telse\n\t\tah->stats.antenna_rx[0]++;  \n\n\trxs->rate_idx = ath5k_hw_to_driver_rix(ah, rs->rs_rate);\n\trxs->flag |= ath5k_rx_decrypted(ah, skb, rs);\n\tswitch (ah->ah_bwmode) {\n\tcase AR5K_BWMODE_5MHZ:\n\t\trxs->bw = RATE_INFO_BW_5;\n\t\tbreak;\n\tcase AR5K_BWMODE_10MHZ:\n\t\trxs->bw = RATE_INFO_BW_10;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (rs->rs_rate ==\n\t    ah->sbands[ah->curchan->band].bitrates[rxs->rate_idx].hw_value_short)\n\t\trxs->enc_flags |= RX_ENC_FLAG_SHORTPRE;\n\n\ttrace_ath5k_rx(ah, skb);\n\n\tif (ath_is_mybeacon(common, (struct ieee80211_hdr *)skb->data)) {\n\t\tewma_beacon_rssi_add(&ah->ah_beacon_rssi_avg, rs->rs_rssi);\n\n\t\t \n\t\tif (ah->opmode == NL80211_IFTYPE_ADHOC)\n\t\t\tath5k_check_ibss_tsf(ah, skb, rxs);\n\t}\n\n\tieee80211_rx(ah->hw, skb);\n}\n\n \nstatic bool\nath5k_receive_frame_ok(struct ath5k_hw *ah, struct ath5k_rx_status *rs)\n{\n\tah->stats.rx_all_count++;\n\tah->stats.rx_bytes_count += rs->rs_datalen;\n\n\tif (unlikely(rs->rs_status)) {\n\t\tunsigned int filters;\n\n\t\tif (rs->rs_status & AR5K_RXERR_CRC)\n\t\t\tah->stats.rxerr_crc++;\n\t\tif (rs->rs_status & AR5K_RXERR_FIFO)\n\t\t\tah->stats.rxerr_fifo++;\n\t\tif (rs->rs_status & AR5K_RXERR_PHY) {\n\t\t\tah->stats.rxerr_phy++;\n\t\t\tif (rs->rs_phyerr > 0 && rs->rs_phyerr < 32)\n\t\t\t\tah->stats.rxerr_phy_code[rs->rs_phyerr]++;\n\n\t\t\t \n\t\t\tif (rs->rs_phyerr == AR5K_RX_PHY_ERROR_OFDM_RESTART ||\n\t\t\t    rs->rs_phyerr == AR5K_RX_PHY_ERROR_CCK_RESTART) {\n\t\t\t\trs->rs_status |= AR5K_RXERR_CRC;\n\t\t\t\trs->rs_status &= ~AR5K_RXERR_PHY;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (rs->rs_status & AR5K_RXERR_DECRYPT) {\n\t\t\t \n\t\t\tah->stats.rxerr_decrypt++;\n\t\t\tif (rs->rs_keyix == AR5K_RXKEYIX_INVALID &&\n\t\t\t    !(rs->rs_status & AR5K_RXERR_CRC))\n\t\t\t\treturn true;\n\t\t}\n\t\tif (rs->rs_status & AR5K_RXERR_MIC) {\n\t\t\tah->stats.rxerr_mic++;\n\t\t\treturn true;\n\t\t}\n\n\t\t \n\t\tfilters = AR5K_RXERR_DECRYPT;\n\t\tif (ah->fif_filter_flags & FIF_FCSFAIL)\n\t\t\tfilters |= AR5K_RXERR_CRC;\n\n\t\tif (rs->rs_status & ~filters)\n\t\t\treturn false;\n\t}\n\n\tif (unlikely(rs->rs_more)) {\n\t\tah->stats.rxerr_jumbo++;\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic void\nath5k_set_current_imask(struct ath5k_hw *ah)\n{\n\tenum ath5k_int imask;\n\tunsigned long flags;\n\n\tif (test_bit(ATH_STAT_RESET, ah->status))\n\t\treturn;\n\n\tspin_lock_irqsave(&ah->irqlock, flags);\n\timask = ah->imask;\n\tif (ah->rx_pending)\n\t\timask &= ~AR5K_INT_RX_ALL;\n\tif (ah->tx_pending)\n\t\timask &= ~AR5K_INT_TX_ALL;\n\tath5k_hw_set_imr(ah, imask);\n\tspin_unlock_irqrestore(&ah->irqlock, flags);\n}\n\nstatic void\nath5k_tasklet_rx(struct tasklet_struct *t)\n{\n\tstruct ath5k_rx_status rs = {};\n\tstruct sk_buff *skb, *next_skb;\n\tdma_addr_t next_skb_addr;\n\tstruct ath5k_hw *ah = from_tasklet(ah, t, rxtq);\n\tstruct ath_common *common = ath5k_hw_common(ah);\n\tstruct ath5k_buf *bf;\n\tstruct ath5k_desc *ds;\n\tint ret;\n\n\tspin_lock(&ah->rxbuflock);\n\tif (list_empty(&ah->rxbuf)) {\n\t\tATH5K_WARN(ah, \"empty rx buf pool\\n\");\n\t\tgoto unlock;\n\t}\n\tdo {\n\t\tbf = list_first_entry(&ah->rxbuf, struct ath5k_buf, list);\n\t\tBUG_ON(bf->skb == NULL);\n\t\tskb = bf->skb;\n\t\tds = bf->desc;\n\n\t\t \n\t\tif (ath5k_hw_get_rxdp(ah) == bf->daddr)\n\t\t\tbreak;\n\n\t\tret = ah->ah_proc_rx_desc(ah, ds, &rs);\n\t\tif (unlikely(ret == -EINPROGRESS))\n\t\t\tbreak;\n\t\telse if (unlikely(ret)) {\n\t\t\tATH5K_ERR(ah, \"error in processing rx descriptor\\n\");\n\t\t\tah->stats.rxerr_proc++;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ath5k_receive_frame_ok(ah, &rs)) {\n\t\t\tnext_skb = ath5k_rx_skb_alloc(ah, &next_skb_addr);\n\n\t\t\t \n\t\t\tif (!next_skb)\n\t\t\t\tgoto next;\n\n\t\t\tdma_unmap_single(ah->dev, bf->skbaddr,\n\t\t\t\t\t common->rx_bufsize,\n\t\t\t\t\t DMA_FROM_DEVICE);\n\n\t\t\tskb_put(skb, rs.rs_datalen);\n\n\t\t\tath5k_receive_frame(ah, skb, &rs);\n\n\t\t\tbf->skb = next_skb;\n\t\t\tbf->skbaddr = next_skb_addr;\n\t\t}\nnext:\n\t\tlist_move_tail(&bf->list, &ah->rxbuf);\n\t} while (ath5k_rxbuf_setup(ah, bf) == 0);\nunlock:\n\tspin_unlock(&ah->rxbuflock);\n\tah->rx_pending = false;\n\tath5k_set_current_imask(ah);\n}\n\n\n \n\nvoid\nath5k_tx_queue(struct ieee80211_hw *hw, struct sk_buff *skb,\n\t       struct ath5k_txq *txq, struct ieee80211_tx_control *control)\n{\n\tstruct ath5k_hw *ah = hw->priv;\n\tstruct ath5k_buf *bf;\n\tunsigned long flags;\n\tint padsize;\n\n\ttrace_ath5k_tx(ah, skb, txq);\n\n\t \n\tpadsize = ath5k_add_padding(skb);\n\tif (padsize < 0) {\n\t\tATH5K_ERR(ah, \"tx hdrlen not %%4: not enough\"\n\t\t\t  \" headroom to pad\");\n\t\tgoto drop_packet;\n\t}\n\n\tif (txq->txq_len >= txq->txq_max &&\n\t    txq->qnum <= AR5K_TX_QUEUE_ID_DATA_MAX)\n\t\tieee80211_stop_queue(hw, txq->qnum);\n\n\tspin_lock_irqsave(&ah->txbuflock, flags);\n\tif (list_empty(&ah->txbuf)) {\n\t\tATH5K_ERR(ah, \"no further txbuf available, dropping packet\\n\");\n\t\tspin_unlock_irqrestore(&ah->txbuflock, flags);\n\t\tieee80211_stop_queues(hw);\n\t\tgoto drop_packet;\n\t}\n\tbf = list_first_entry(&ah->txbuf, struct ath5k_buf, list);\n\tlist_del(&bf->list);\n\tah->txbuf_len--;\n\tif (list_empty(&ah->txbuf))\n\t\tieee80211_stop_queues(hw);\n\tspin_unlock_irqrestore(&ah->txbuflock, flags);\n\n\tbf->skb = skb;\n\n\tif (ath5k_txbuf_setup(ah, bf, txq, padsize, control)) {\n\t\tbf->skb = NULL;\n\t\tspin_lock_irqsave(&ah->txbuflock, flags);\n\t\tlist_add_tail(&bf->list, &ah->txbuf);\n\t\tah->txbuf_len++;\n\t\tspin_unlock_irqrestore(&ah->txbuflock, flags);\n\t\tgoto drop_packet;\n\t}\n\treturn;\n\ndrop_packet:\n\tieee80211_free_txskb(hw, skb);\n}\n\nstatic void\nath5k_tx_frame_completed(struct ath5k_hw *ah, struct sk_buff *skb,\n\t\t\t struct ath5k_txq *txq, struct ath5k_tx_status *ts,\n\t\t\t struct ath5k_buf *bf)\n{\n\tstruct ieee80211_tx_info *info;\n\tu8 tries[3];\n\tint i;\n\tint size = 0;\n\n\tah->stats.tx_all_count++;\n\tah->stats.tx_bytes_count += skb->len;\n\tinfo = IEEE80211_SKB_CB(skb);\n\n\tsize = min_t(int, sizeof(info->status.rates), sizeof(bf->rates));\n\tmemcpy(info->status.rates, bf->rates, size);\n\n\ttries[0] = info->status.rates[0].count;\n\ttries[1] = info->status.rates[1].count;\n\ttries[2] = info->status.rates[2].count;\n\n\tieee80211_tx_info_clear_status(info);\n\n\tfor (i = 0; i < ts->ts_final_idx; i++) {\n\t\tstruct ieee80211_tx_rate *r =\n\t\t\t&info->status.rates[i];\n\n\t\tr->count = tries[i];\n\t}\n\n\tinfo->status.rates[ts->ts_final_idx].count = ts->ts_final_retry;\n\tinfo->status.rates[ts->ts_final_idx + 1].idx = -1;\n\n\tif (unlikely(ts->ts_status)) {\n\t\tah->stats.ack_fail++;\n\t\tif (ts->ts_status & AR5K_TXERR_FILT) {\n\t\t\tinfo->flags |= IEEE80211_TX_STAT_TX_FILTERED;\n\t\t\tah->stats.txerr_filt++;\n\t\t}\n\t\tif (ts->ts_status & AR5K_TXERR_XRETRY)\n\t\t\tah->stats.txerr_retry++;\n\t\tif (ts->ts_status & AR5K_TXERR_FIFO)\n\t\t\tah->stats.txerr_fifo++;\n\t} else {\n\t\tinfo->flags |= IEEE80211_TX_STAT_ACK;\n\t\tinfo->status.ack_signal = ts->ts_rssi;\n\n\t\t \n\t\tinfo->status.rates[ts->ts_final_idx].count++;\n\t}\n\n\t \n\tath5k_remove_padding(skb);\n\n\tif (ts->ts_antenna > 0 && ts->ts_antenna < 5)\n\t\tah->stats.antenna_tx[ts->ts_antenna]++;\n\telse\n\t\tah->stats.antenna_tx[0]++;  \n\n\ttrace_ath5k_tx_complete(ah, skb, txq, ts);\n\tieee80211_tx_status(ah->hw, skb);\n}\n\nstatic void\nath5k_tx_processq(struct ath5k_hw *ah, struct ath5k_txq *txq)\n{\n\tstruct ath5k_tx_status ts = {};\n\tstruct ath5k_buf *bf, *bf0;\n\tstruct ath5k_desc *ds;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tspin_lock(&txq->lock);\n\tlist_for_each_entry_safe(bf, bf0, &txq->q, list) {\n\n\t\ttxq->txq_poll_mark = false;\n\n\t\t \n\t\tif (bf->skb != NULL) {\n\t\t\tds = bf->desc;\n\n\t\t\tret = ah->ah_proc_tx_desc(ah, ds, &ts);\n\t\t\tif (unlikely(ret == -EINPROGRESS))\n\t\t\t\tbreak;\n\t\t\telse if (unlikely(ret)) {\n\t\t\t\tATH5K_ERR(ah,\n\t\t\t\t\t\"error %d while processing \"\n\t\t\t\t\t\"queue %u\\n\", ret, txq->qnum);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tskb = bf->skb;\n\t\t\tbf->skb = NULL;\n\n\t\t\tdma_unmap_single(ah->dev, bf->skbaddr, skb->len,\n\t\t\t\t\tDMA_TO_DEVICE);\n\t\t\tath5k_tx_frame_completed(ah, skb, txq, &ts, bf);\n\t\t}\n\n\t\t \n\t\tif (ath5k_hw_get_txdp(ah, txq->qnum) != bf->daddr) {\n\t\t\tspin_lock(&ah->txbuflock);\n\t\t\tlist_move_tail(&bf->list, &ah->txbuf);\n\t\t\tah->txbuf_len++;\n\t\t\ttxq->txq_len--;\n\t\t\tspin_unlock(&ah->txbuflock);\n\t\t}\n\t}\n\tspin_unlock(&txq->lock);\n\tif (txq->txq_len < ATH5K_TXQ_LEN_LOW && txq->qnum < 4)\n\t\tieee80211_wake_queue(ah->hw, txq->qnum);\n}\n\nstatic void\nath5k_tasklet_tx(struct tasklet_struct *t)\n{\n\tint i;\n\tstruct ath5k_hw *ah = from_tasklet(ah, t, txtq);\n\n\tfor (i = 0; i < AR5K_NUM_TX_QUEUES; i++)\n\t\tif (ah->txqs[i].setup && (ah->ah_txq_isr_txok_all & BIT(i)))\n\t\t\tath5k_tx_processq(ah, &ah->txqs[i]);\n\n\tah->tx_pending = false;\n\tath5k_set_current_imask(ah);\n}\n\n\n \n\n \nstatic int\nath5k_beacon_setup(struct ath5k_hw *ah, struct ath5k_buf *bf)\n{\n\tstruct sk_buff *skb = bf->skb;\n\tstruct\tieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ath5k_desc *ds;\n\tint ret = 0;\n\tu8 antenna;\n\tu32 flags;\n\tconst int padsize = 0;\n\n\tbf->skbaddr = dma_map_single(ah->dev, skb->data, skb->len,\n\t\t\tDMA_TO_DEVICE);\n\tATH5K_DBG(ah, ATH5K_DEBUG_BEACON, \"skb %p [data %p len %u] \"\n\t\t\t\"skbaddr %llx\\n\", skb, skb->data, skb->len,\n\t\t\t(unsigned long long)bf->skbaddr);\n\n\tif (dma_mapping_error(ah->dev, bf->skbaddr)) {\n\t\tATH5K_ERR(ah, \"beacon DMA mapping failed\\n\");\n\t\tdev_kfree_skb_any(skb);\n\t\tbf->skb = NULL;\n\t\treturn -EIO;\n\t}\n\n\tds = bf->desc;\n\tantenna = ah->ah_tx_ant;\n\n\tflags = AR5K_TXDESC_NOACK;\n\tif (ah->opmode == NL80211_IFTYPE_ADHOC && ath5k_hw_hasveol(ah)) {\n\t\tds->ds_link = bf->daddr;\t \n\t\tflags |= AR5K_TXDESC_VEOL;\n\t} else\n\t\tds->ds_link = 0;\n\n\t \n\tif (ah->ah_ant_mode == AR5K_ANTMODE_SECTOR_AP)\n\t\tantenna = ah->bsent & 4 ? 2 : 1;\n\n\n\t \n\tds->ds_data = bf->skbaddr;\n\tret = ah->ah_setup_tx_desc(ah, ds, skb->len,\n\t\t\tieee80211_get_hdrlen_from_skb(skb), padsize,\n\t\t\tAR5K_PKT_TYPE_BEACON,\n\t\t\t(ah->ah_txpower.txp_requested * 2),\n\t\t\tieee80211_get_tx_rate(ah->hw, info)->hw_value,\n\t\t\t1, AR5K_TXKEYIX_INVALID,\n\t\t\tantenna, flags, 0, 0);\n\tif (ret)\n\t\tgoto err_unmap;\n\n\treturn 0;\nerr_unmap:\n\tdma_unmap_single(ah->dev, bf->skbaddr, skb->len, DMA_TO_DEVICE);\n\treturn ret;\n}\n\n \nint\nath5k_beacon_update(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\n{\n\tint ret;\n\tstruct ath5k_hw *ah = hw->priv;\n\tstruct ath5k_vif *avf;\n\tstruct sk_buff *skb;\n\n\tif (WARN_ON(!vif)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tskb = ieee80211_beacon_get(hw, vif, 0);\n\n\tif (!skb) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tavf = (void *)vif->drv_priv;\n\tath5k_txbuf_free_skb(ah, avf->bbuf);\n\tavf->bbuf->skb = skb;\n\tret = ath5k_beacon_setup(ah, avf->bbuf);\nout:\n\treturn ret;\n}\n\n \nstatic void\nath5k_beacon_send(struct ath5k_hw *ah)\n{\n\tstruct ieee80211_vif *vif;\n\tstruct ath5k_vif *avf;\n\tstruct ath5k_buf *bf;\n\tstruct sk_buff *skb;\n\tint err;\n\n\tATH5K_DBG_UNLIMIT(ah, ATH5K_DEBUG_BEACON, \"in beacon_send\\n\");\n\n\t \n\tif (unlikely(ath5k_hw_num_tx_pending(ah, ah->bhalq) != 0)) {\n\t\tah->bmisscount++;\n\t\tATH5K_DBG(ah, ATH5K_DEBUG_BEACON,\n\t\t\t\"missed %u consecutive beacons\\n\", ah->bmisscount);\n\t\tif (ah->bmisscount > 10) {\t \n\t\t\tATH5K_DBG(ah, ATH5K_DEBUG_BEACON,\n\t\t\t\t\"stuck beacon time (%u missed)\\n\",\n\t\t\t\tah->bmisscount);\n\t\t\tATH5K_DBG(ah, ATH5K_DEBUG_RESET,\n\t\t\t\t  \"stuck beacon, resetting\\n\");\n\t\t\tieee80211_queue_work(ah->hw, &ah->reset_work);\n\t\t}\n\t\treturn;\n\t}\n\tif (unlikely(ah->bmisscount != 0)) {\n\t\tATH5K_DBG(ah, ATH5K_DEBUG_BEACON,\n\t\t\t\"resume beacon xmit after %u misses\\n\",\n\t\t\tah->bmisscount);\n\t\tah->bmisscount = 0;\n\t}\n\n\tif ((ah->opmode == NL80211_IFTYPE_AP && ah->num_ap_vifs +\n\t\t\tah->num_mesh_vifs > 1) ||\n\t\t\tah->opmode == NL80211_IFTYPE_MESH_POINT) {\n\t\tu64 tsf = ath5k_hw_get_tsf64(ah);\n\t\tu32 tsftu = TSF_TO_TU(tsf);\n\t\tint slot = ((tsftu % ah->bintval) * ATH_BCBUF) / ah->bintval;\n\t\tvif = ah->bslot[(slot + 1) % ATH_BCBUF];\n\t\tATH5K_DBG(ah, ATH5K_DEBUG_BEACON,\n\t\t\t\"tsf %llx tsftu %x intval %u slot %u vif %p\\n\",\n\t\t\t(unsigned long long)tsf, tsftu, ah->bintval, slot, vif);\n\t} else  \n\t\tvif = ah->bslot[0];\n\n\tif (!vif)\n\t\treturn;\n\n\tavf = (void *)vif->drv_priv;\n\tbf = avf->bbuf;\n\n\t \n\tif (unlikely(ath5k_hw_stop_beacon_queue(ah, ah->bhalq))) {\n\t\tATH5K_WARN(ah, \"beacon queue %u didn't start/stop ?\\n\", ah->bhalq);\n\t\t \n\t}\n\n\t \n\tif (ah->opmode == NL80211_IFTYPE_AP ||\n\t    ah->opmode == NL80211_IFTYPE_MESH_POINT) {\n\t\terr = ath5k_beacon_update(ah->hw, vif);\n\t\tif (err)\n\t\t\treturn;\n\t}\n\n\tif (unlikely(bf->skb == NULL || ah->opmode == NL80211_IFTYPE_STATION ||\n\t\t     ah->opmode == NL80211_IFTYPE_MONITOR)) {\n\t\tATH5K_WARN(ah, \"bf=%p bf_skb=%p\\n\", bf, bf->skb);\n\t\treturn;\n\t}\n\n\ttrace_ath5k_tx(ah, bf->skb, &ah->txqs[ah->bhalq]);\n\n\tath5k_hw_set_txdp(ah, ah->bhalq, bf->daddr);\n\tath5k_hw_start_tx_dma(ah, ah->bhalq);\n\tATH5K_DBG(ah, ATH5K_DEBUG_BEACON, \"TXDP[%u] = %llx (%p)\\n\",\n\t\tah->bhalq, (unsigned long long)bf->daddr, bf->desc);\n\n\tskb = ieee80211_get_buffered_bc(ah->hw, vif);\n\twhile (skb) {\n\t\tath5k_tx_queue(ah->hw, skb, ah->cabq, NULL);\n\n\t\tif (ah->cabq->txq_len >= ah->cabq->txq_max)\n\t\t\tbreak;\n\n\t\tskb = ieee80211_get_buffered_bc(ah->hw, vif);\n\t}\n\n\tah->bsent++;\n}\n\n \nvoid\nath5k_beacon_update_timers(struct ath5k_hw *ah, u64 bc_tsf)\n{\n\tu32 nexttbtt, intval, hw_tu, bc_tu;\n\tu64 hw_tsf;\n\n\tintval = ah->bintval & AR5K_BEACON_PERIOD;\n\tif (ah->opmode == NL80211_IFTYPE_AP && ah->num_ap_vifs\n\t\t+ ah->num_mesh_vifs > 1) {\n\t\tintval /= ATH_BCBUF;\t \n\t\tif (intval < 15)\n\t\t\tATH5K_WARN(ah, \"intval %u is too low, min 15\\n\",\n\t\t\t\t   intval);\n\t}\n\tif (WARN_ON(!intval))\n\t\treturn;\n\n\t \n\tbc_tu = TSF_TO_TU(bc_tsf);\n\n\t \n\thw_tsf = ath5k_hw_get_tsf64(ah);\n\thw_tu = TSF_TO_TU(hw_tsf);\n\n#define FUDGE (AR5K_TUNE_SW_BEACON_RESP + 3)\n\t \n\n\tif (bc_tsf == -1) {\n\t\t \n\t\tnexttbtt = roundup(hw_tu + FUDGE, intval);\n\t} else if (bc_tsf == 0) {\n\t\t \n\t\tnexttbtt = intval;\n\t\tintval |= AR5K_BEACON_RESET_TSF;\n\t} else if (bc_tsf > hw_tsf) {\n\t\t \n\t\tATH5K_DBG_UNLIMIT(ah, ATH5K_DEBUG_BEACON,\n\t\t\t\"need to wait for HW TSF sync\\n\");\n\t\treturn;\n\t} else {\n\t\t \n\t\tnexttbtt = bc_tu + roundup(hw_tu + FUDGE - bc_tu, intval);\n\t}\n#undef FUDGE\n\n\tah->nexttbtt = nexttbtt;\n\n\tintval |= AR5K_BEACON_ENA;\n\tath5k_hw_init_beacon_timers(ah, nexttbtt, intval);\n\n\t \n\tif (bc_tsf == -1)\n\t\tATH5K_DBG_UNLIMIT(ah, ATH5K_DEBUG_BEACON,\n\t\t\t\"reconfigured timers based on HW TSF\\n\");\n\telse if (bc_tsf == 0)\n\t\tATH5K_DBG_UNLIMIT(ah, ATH5K_DEBUG_BEACON,\n\t\t\t\"reset HW TSF and timers\\n\");\n\telse\n\t\tATH5K_DBG_UNLIMIT(ah, ATH5K_DEBUG_BEACON,\n\t\t\t\"updated timers based on beacon TSF\\n\");\n\n\tATH5K_DBG_UNLIMIT(ah, ATH5K_DEBUG_BEACON,\n\t\t\t  \"bc_tsf %llx hw_tsf %llx bc_tu %u hw_tu %u nexttbtt %u\\n\",\n\t\t\t  (unsigned long long) bc_tsf,\n\t\t\t  (unsigned long long) hw_tsf, bc_tu, hw_tu, nexttbtt);\n\tATH5K_DBG_UNLIMIT(ah, ATH5K_DEBUG_BEACON, \"intval %u %s %s\\n\",\n\t\tintval & AR5K_BEACON_PERIOD,\n\t\tintval & AR5K_BEACON_ENA ? \"AR5K_BEACON_ENA\" : \"\",\n\t\tintval & AR5K_BEACON_RESET_TSF ? \"AR5K_BEACON_RESET_TSF\" : \"\");\n}\n\n \nvoid\nath5k_beacon_config(struct ath5k_hw *ah)\n{\n\tspin_lock_bh(&ah->block);\n\tah->bmisscount = 0;\n\tah->imask &= ~(AR5K_INT_BMISS | AR5K_INT_SWBA);\n\n\tif (ah->enable_beacon) {\n\t\t \n\t\tath5k_beaconq_config(ah);\n\n\t\tah->imask |= AR5K_INT_SWBA;\n\n\t\tif (ah->opmode == NL80211_IFTYPE_ADHOC) {\n\t\t\tif (ath5k_hw_hasveol(ah))\n\t\t\t\tath5k_beacon_send(ah);\n\t\t} else\n\t\t\tath5k_beacon_update_timers(ah, -1);\n\t} else {\n\t\tath5k_hw_stop_beacon_queue(ah, ah->bhalq);\n\t}\n\n\tath5k_hw_set_imr(ah, ah->imask);\n\tspin_unlock_bh(&ah->block);\n}\n\nstatic void ath5k_tasklet_beacon(struct tasklet_struct *t)\n{\n\tstruct ath5k_hw *ah = from_tasklet(ah, t, beacontq);\n\n\t \n\tif (ah->opmode == NL80211_IFTYPE_ADHOC) {\n\t\t \n\t\tu64 tsf = ath5k_hw_get_tsf64(ah);\n\t\tah->nexttbtt += ah->bintval;\n\t\tATH5K_DBG(ah, ATH5K_DEBUG_BEACON,\n\t\t\t\t\"SWBA nexttbtt: %x hw_tu: %x \"\n\t\t\t\t\"TSF: %llx\\n\",\n\t\t\t\tah->nexttbtt,\n\t\t\t\tTSF_TO_TU(tsf),\n\t\t\t\t(unsigned long long) tsf);\n\t} else {\n\t\tspin_lock(&ah->block);\n\t\tath5k_beacon_send(ah);\n\t\tspin_unlock(&ah->block);\n\t}\n}\n\n\n \n\nstatic void\nath5k_intr_calibration_poll(struct ath5k_hw *ah)\n{\n\tif (time_is_before_eq_jiffies(ah->ah_cal_next_ani) &&\n\t   !(ah->ah_cal_mask & AR5K_CALIBRATION_FULL) &&\n\t   !(ah->ah_cal_mask & AR5K_CALIBRATION_SHORT)) {\n\n\t\t \n\n\t\tah->ah_cal_next_ani = jiffies +\n\t\t\tmsecs_to_jiffies(ATH5K_TUNE_CALIBRATION_INTERVAL_ANI);\n\t\ttasklet_schedule(&ah->ani_tasklet);\n\n\t} else if (time_is_before_eq_jiffies(ah->ah_cal_next_short) &&\n\t\t!(ah->ah_cal_mask & AR5K_CALIBRATION_FULL) &&\n\t\t!(ah->ah_cal_mask & AR5K_CALIBRATION_SHORT)) {\n\n\t\t \n\n\t\tah->ah_cal_next_short = jiffies +\n\t\t\tmsecs_to_jiffies(ATH5K_TUNE_CALIBRATION_INTERVAL_SHORT);\n\t\tieee80211_queue_work(ah->hw, &ah->calib_work);\n\t}\n\t \n}\n\nstatic void\nath5k_schedule_rx(struct ath5k_hw *ah)\n{\n\tah->rx_pending = true;\n\ttasklet_schedule(&ah->rxtq);\n}\n\nstatic void\nath5k_schedule_tx(struct ath5k_hw *ah)\n{\n\tah->tx_pending = true;\n\ttasklet_schedule(&ah->txtq);\n}\n\nstatic irqreturn_t\nath5k_intr(int irq, void *dev_id)\n{\n\tstruct ath5k_hw *ah = dev_id;\n\tenum ath5k_int status;\n\tunsigned int counter = 1000;\n\n\n\t \n\tif (unlikely(test_bit(ATH_STAT_INVALID, ah->status) ||\n\t\t\t((ath5k_get_bus_type(ah) != ATH_AHB) &&\n\t\t\t!ath5k_hw_is_intr_pending(ah))))\n\t\treturn IRQ_NONE;\n\n\t \n\tdo {\n\t\tath5k_hw_get_isr(ah, &status);\t \n\n\t\tATH5K_DBG(ah, ATH5K_DEBUG_INTR, \"status 0x%x/0x%x\\n\",\n\t\t\t\tstatus, ah->imask);\n\n\t\t \n\t\tif (unlikely(status & AR5K_INT_FATAL)) {\n\n\t\t\tATH5K_DBG(ah, ATH5K_DEBUG_RESET,\n\t\t\t\t  \"fatal int, resetting\\n\");\n\t\t\tieee80211_queue_work(ah->hw, &ah->reset_work);\n\n\t\t \n\t\t} else if (unlikely(status & AR5K_INT_RXORN)) {\n\n\t\t\t \n\t\t\tah->stats.rxorn_intr++;\n\n\t\t\tif (ah->ah_mac_srev < AR5K_SREV_AR5212) {\n\t\t\t\tATH5K_DBG(ah, ATH5K_DEBUG_RESET,\n\t\t\t\t\t  \"rx overrun, resetting\\n\");\n\t\t\t\tieee80211_queue_work(ah->hw, &ah->reset_work);\n\t\t\t} else\n\t\t\t\tath5k_schedule_rx(ah);\n\n\t\t} else {\n\n\t\t\t \n\t\t\tif (status & AR5K_INT_SWBA)\n\t\t\t\ttasklet_hi_schedule(&ah->beacontq);\n\n\t\t\t \n\t\t\tif (status & AR5K_INT_RXEOL)\n\t\t\t\tah->stats.rxeol_intr++;\n\n\n\t\t\t \n\t\t\tif (status & AR5K_INT_TXURN)\n\t\t\t\tath5k_hw_update_tx_triglevel(ah, true);\n\n\t\t\t \n\t\t\tif (status & (AR5K_INT_RXOK | AR5K_INT_RXERR))\n\t\t\t\tath5k_schedule_rx(ah);\n\n\t\t\t \n\t\t\tif (status & (AR5K_INT_TXOK\n\t\t\t\t\t| AR5K_INT_TXDESC\n\t\t\t\t\t| AR5K_INT_TXERR\n\t\t\t\t\t| AR5K_INT_TXEOL))\n\t\t\t\tath5k_schedule_tx(ah);\n\n\t\t\t \n\n\t\t\t \n\t\t\tif (status & AR5K_INT_MIB) {\n\t\t\t\tah->stats.mib_intr++;\n\t\t\t\tath5k_hw_update_mib_counters(ah);\n\t\t\t\tath5k_ani_mib_intr(ah);\n\t\t\t}\n\n\t\t\t \n\t\t\tif (status & AR5K_INT_GPIO)\n\t\t\t\ttasklet_schedule(&ah->rf_kill.toggleq);\n\n\t\t}\n\n\t\tif (ath5k_get_bus_type(ah) == ATH_AHB)\n\t\t\tbreak;\n\n\t} while (ath5k_hw_is_intr_pending(ah) && --counter > 0);\n\n\t \n\tif (ah->rx_pending || ah->tx_pending)\n\t\tath5k_set_current_imask(ah);\n\n\tif (unlikely(!counter))\n\t\tATH5K_WARN(ah, \"too many interrupts, giving up for now\\n\");\n\n\t \n\tath5k_intr_calibration_poll(ah);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void\nath5k_calibrate_work(struct work_struct *work)\n{\n\tstruct ath5k_hw *ah = container_of(work, struct ath5k_hw,\n\t\tcalib_work);\n\n\t \n\tif (time_is_before_eq_jiffies(ah->ah_cal_next_full)) {\n\n\t\tah->ah_cal_next_full = jiffies +\n\t\t\tmsecs_to_jiffies(ATH5K_TUNE_CALIBRATION_INTERVAL_FULL);\n\t\tah->ah_cal_mask |= AR5K_CALIBRATION_FULL;\n\n\t\tATH5K_DBG(ah, ATH5K_DEBUG_CALIBRATE,\n\t\t\t\t\"running full calibration\\n\");\n\n\t\tif (ath5k_hw_gainf_calibrate(ah) == AR5K_RFGAIN_NEED_CHANGE) {\n\t\t\t \n\t\t\tATH5K_DBG(ah, ATH5K_DEBUG_RESET,\n\t\t\t\t\t\"got new rfgain, resetting\\n\");\n\t\t\tieee80211_queue_work(ah->hw, &ah->reset_work);\n\t\t}\n\t} else\n\t\tah->ah_cal_mask |= AR5K_CALIBRATION_SHORT;\n\n\n\tATH5K_DBG(ah, ATH5K_DEBUG_CALIBRATE, \"channel %u/%x\\n\",\n\t\tieee80211_frequency_to_channel(ah->curchan->center_freq),\n\t\tah->curchan->hw_value);\n\n\tif (ath5k_hw_phy_calibrate(ah, ah->curchan))\n\t\tATH5K_ERR(ah, \"calibration of channel %u failed\\n\",\n\t\t\tieee80211_frequency_to_channel(\n\t\t\t\tah->curchan->center_freq));\n\n\t \n\tif (ah->ah_cal_mask & AR5K_CALIBRATION_FULL)\n\t\tah->ah_cal_mask &= ~AR5K_CALIBRATION_FULL;\n\telse if (ah->ah_cal_mask & AR5K_CALIBRATION_SHORT)\n\t\tah->ah_cal_mask &= ~AR5K_CALIBRATION_SHORT;\n}\n\n\nstatic void\nath5k_tasklet_ani(struct tasklet_struct *t)\n{\n\tstruct ath5k_hw *ah = from_tasklet(ah, t, ani_tasklet);\n\n\tah->ah_cal_mask |= AR5K_CALIBRATION_ANI;\n\tath5k_ani_calibration(ah);\n\tah->ah_cal_mask &= ~AR5K_CALIBRATION_ANI;\n}\n\n\nstatic void\nath5k_tx_complete_poll_work(struct work_struct *work)\n{\n\tstruct ath5k_hw *ah = container_of(work, struct ath5k_hw,\n\t\t\ttx_complete_work.work);\n\tstruct ath5k_txq *txq;\n\tint i;\n\tbool needreset = false;\n\n\tif (!test_bit(ATH_STAT_STARTED, ah->status))\n\t\treturn;\n\n\tmutex_lock(&ah->lock);\n\n\tfor (i = 0; i < ARRAY_SIZE(ah->txqs); i++) {\n\t\tif (ah->txqs[i].setup) {\n\t\t\ttxq = &ah->txqs[i];\n\t\t\tspin_lock_bh(&txq->lock);\n\t\t\tif (txq->txq_len > 1) {\n\t\t\t\tif (txq->txq_poll_mark) {\n\t\t\t\t\tATH5K_DBG(ah, ATH5K_DEBUG_XMIT,\n\t\t\t\t\t\t  \"TX queue stuck %d\\n\",\n\t\t\t\t\t\t  txq->qnum);\n\t\t\t\t\tneedreset = true;\n\t\t\t\t\ttxq->txq_stuck++;\n\t\t\t\t\tspin_unlock_bh(&txq->lock);\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\ttxq->txq_poll_mark = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tspin_unlock_bh(&txq->lock);\n\t\t}\n\t}\n\n\tif (needreset) {\n\t\tATH5K_DBG(ah, ATH5K_DEBUG_RESET,\n\t\t\t  \"TX queues stuck, resetting\\n\");\n\t\tath5k_reset(ah, NULL, true);\n\t}\n\n\tmutex_unlock(&ah->lock);\n\n\tieee80211_queue_delayed_work(ah->hw, &ah->tx_complete_work,\n\t\tmsecs_to_jiffies(ATH5K_TX_COMPLETE_POLL_INT));\n}\n\n\n \n\nstatic const struct ieee80211_iface_limit if_limits[] = {\n\t{ .max = 2048,\t.types = BIT(NL80211_IFTYPE_STATION) },\n\t{ .max = 4,\t.types =\n#ifdef CONFIG_MAC80211_MESH\n\t\t\t\t BIT(NL80211_IFTYPE_MESH_POINT) |\n#endif\n\t\t\t\t BIT(NL80211_IFTYPE_AP) },\n};\n\nstatic const struct ieee80211_iface_combination if_comb = {\n\t.limits = if_limits,\n\t.n_limits = ARRAY_SIZE(if_limits),\n\t.max_interfaces = 2048,\n\t.num_different_channels = 1,\n};\n\nint\nath5k_init_ah(struct ath5k_hw *ah, const struct ath_bus_ops *bus_ops)\n{\n\tstruct ieee80211_hw *hw = ah->hw;\n\tstruct ath_common *common;\n\tint ret;\n\tint csz;\n\n\t \n\tSET_IEEE80211_DEV(hw, ah->dev);\n\tieee80211_hw_set(hw, SUPPORTS_RC_TABLE);\n\tieee80211_hw_set(hw, REPORTS_TX_ACK_STATUS);\n\tieee80211_hw_set(hw, MFP_CAPABLE);\n\tieee80211_hw_set(hw, SIGNAL_DBM);\n\tieee80211_hw_set(hw, RX_INCLUDES_FCS);\n\tieee80211_hw_set(hw, HOST_BROADCAST_PS_BUFFERING);\n\n\thw->wiphy->interface_modes =\n\t\tBIT(NL80211_IFTYPE_AP) |\n\t\tBIT(NL80211_IFTYPE_STATION) |\n\t\tBIT(NL80211_IFTYPE_ADHOC) |\n\t\tBIT(NL80211_IFTYPE_MESH_POINT);\n\n\thw->wiphy->iface_combinations = &if_comb;\n\thw->wiphy->n_iface_combinations = 1;\n\n\t \n\thw->wiphy->flags |= WIPHY_FLAG_IBSS_RSN;\n\n\thw->wiphy->flags |= WIPHY_FLAG_SUPPORTS_5_10_MHZ;\n\n\t \n\thw->wiphy->available_antennas_tx = 0x3;\n\thw->wiphy->available_antennas_rx = 0x3;\n\n\thw->extra_tx_headroom = 2;\n\n\twiphy_ext_feature_set(hw->wiphy, NL80211_EXT_FEATURE_CQM_RSSI_LIST);\n\n\t \n\t__set_bit(ATH_STAT_INVALID, ah->status);\n\n\tah->opmode = NL80211_IFTYPE_STATION;\n\tah->bintval = 1000;\n\tmutex_init(&ah->lock);\n\tspin_lock_init(&ah->rxbuflock);\n\tspin_lock_init(&ah->txbuflock);\n\tspin_lock_init(&ah->block);\n\tspin_lock_init(&ah->irqlock);\n\n\t \n\tret = request_irq(ah->irq, ath5k_intr, IRQF_SHARED, \"ath\", ah);\n\tif (ret) {\n\t\tATH5K_ERR(ah, \"request_irq failed\\n\");\n\t\tgoto err;\n\t}\n\n\tcommon = ath5k_hw_common(ah);\n\tcommon->ops = &ath5k_common_ops;\n\tcommon->bus_ops = bus_ops;\n\tcommon->ah = ah;\n\tcommon->hw = hw;\n\tcommon->priv = ah;\n\tcommon->clockrate = 40;\n\n\t \n\tath5k_read_cachesize(common, &csz);\n\tcommon->cachelsz = csz << 2;  \n\n\tspin_lock_init(&common->cc_lock);\n\n\t \n\tret = ath5k_hw_init(ah);\n\tif (ret)\n\t\tgoto err_irq;\n\n\t \n\tif (ah->ah_capabilities.cap_has_mrr_support) {\n\t\thw->max_rates = 4;\n\t\thw->max_rate_tries = max(AR5K_INIT_RETRY_SHORT,\n\t\t\t\t\t AR5K_INIT_RETRY_LONG);\n\t}\n\n\thw->vif_data_size = sizeof(struct ath5k_vif);\n\n\t \n\tret = ath5k_init(hw);\n\tif (ret)\n\t\tgoto err_ah;\n\n\tATH5K_INFO(ah, \"Atheros AR%s chip found (MAC: 0x%x, PHY: 0x%x)\\n\",\n\t\t\tath5k_chip_name(AR5K_VERSION_MAC, ah->ah_mac_srev),\n\t\t\t\t\tah->ah_mac_srev,\n\t\t\t\t\tah->ah_phy_revision);\n\n\tif (!ah->ah_single_chip) {\n\t\t \n\t\tif (ah->ah_radio_5ghz_revision &&\n\t\t\t!ah->ah_radio_2ghz_revision) {\n\t\t\t \n\t\t\tif (!test_bit(AR5K_MODE_11A,\n\t\t\t\tah->ah_capabilities.cap_mode)) {\n\t\t\t\tATH5K_INFO(ah, \"RF%s 2GHz radio found (0x%x)\\n\",\n\t\t\t\t\tath5k_chip_name(AR5K_VERSION_RAD,\n\t\t\t\t\t\tah->ah_radio_5ghz_revision),\n\t\t\t\t\t\tah->ah_radio_5ghz_revision);\n\t\t\t \n\t\t\t} else if (!test_bit(AR5K_MODE_11B,\n\t\t\t\tah->ah_capabilities.cap_mode)) {\n\t\t\t\tATH5K_INFO(ah, \"RF%s 5GHz radio found (0x%x)\\n\",\n\t\t\t\t\tath5k_chip_name(AR5K_VERSION_RAD,\n\t\t\t\t\t\tah->ah_radio_5ghz_revision),\n\t\t\t\t\t\tah->ah_radio_5ghz_revision);\n\t\t\t \n\t\t\t} else {\n\t\t\t\tATH5K_INFO(ah, \"RF%s multiband radio found\"\n\t\t\t\t\t\" (0x%x)\\n\",\n\t\t\t\t\tath5k_chip_name(AR5K_VERSION_RAD,\n\t\t\t\t\t\tah->ah_radio_5ghz_revision),\n\t\t\t\t\t\tah->ah_radio_5ghz_revision);\n\t\t\t}\n\t\t}\n\t\t \n\t\telse if (ah->ah_radio_5ghz_revision &&\n\t\t\t\tah->ah_radio_2ghz_revision) {\n\t\t\tATH5K_INFO(ah, \"RF%s 5GHz radio found (0x%x)\\n\",\n\t\t\t\tath5k_chip_name(AR5K_VERSION_RAD,\n\t\t\t\t\tah->ah_radio_5ghz_revision),\n\t\t\t\t\tah->ah_radio_5ghz_revision);\n\t\t\tATH5K_INFO(ah, \"RF%s 2GHz radio found (0x%x)\\n\",\n\t\t\t\tath5k_chip_name(AR5K_VERSION_RAD,\n\t\t\t\t\tah->ah_radio_2ghz_revision),\n\t\t\t\t\tah->ah_radio_2ghz_revision);\n\t\t}\n\t}\n\n\tath5k_debug_init_device(ah);\n\n\t \n\t__clear_bit(ATH_STAT_INVALID, ah->status);\n\n\treturn 0;\nerr_ah:\n\tath5k_hw_deinit(ah);\nerr_irq:\n\tfree_irq(ah->irq, ah);\nerr:\n\treturn ret;\n}\n\nstatic int\nath5k_stop_locked(struct ath5k_hw *ah)\n{\n\n\tATH5K_DBG(ah, ATH5K_DEBUG_RESET, \"invalid %u\\n\",\n\t\t\ttest_bit(ATH_STAT_INVALID, ah->status));\n\n\t \n\tieee80211_stop_queues(ah->hw);\n\n\tif (!test_bit(ATH_STAT_INVALID, ah->status)) {\n\t\tath5k_led_off(ah);\n\t\tath5k_hw_set_imr(ah, 0);\n\t\tsynchronize_irq(ah->irq);\n\t\tath5k_rx_stop(ah);\n\t\tath5k_hw_dma_stop(ah);\n\t\tath5k_drain_tx_buffs(ah);\n\t\tath5k_hw_phy_disable(ah);\n\t}\n\n\treturn 0;\n}\n\nint ath5k_start(struct ieee80211_hw *hw)\n{\n\tstruct ath5k_hw *ah = hw->priv;\n\tstruct ath_common *common = ath5k_hw_common(ah);\n\tint ret, i;\n\n\tmutex_lock(&ah->lock);\n\n\tATH5K_DBG(ah, ATH5K_DEBUG_RESET, \"mode %d\\n\", ah->opmode);\n\n\t \n\tath5k_stop_locked(ah);\n\n\t \n\tah->curchan = ah->hw->conf.chandef.chan;\n\tah->imask = AR5K_INT_RXOK\n\t\t| AR5K_INT_RXERR\n\t\t| AR5K_INT_RXEOL\n\t\t| AR5K_INT_RXORN\n\t\t| AR5K_INT_TXDESC\n\t\t| AR5K_INT_TXEOL\n\t\t| AR5K_INT_FATAL\n\t\t| AR5K_INT_GLOBAL\n\t\t| AR5K_INT_MIB;\n\n\tret = ath5k_reset(ah, NULL, false);\n\tif (ret)\n\t\tgoto done;\n\n\tif (!ath5k_modparam_no_hw_rfkill_switch)\n\t\tath5k_rfkill_hw_start(ah);\n\n\t \n\tfor (i = 0; i < common->keymax; i++)\n\t\tath_hw_keyreset(common, (u16) i);\n\n\t \n\tah->ah_ack_bitrate_high = true;\n\n\tfor (i = 0; i < ARRAY_SIZE(ah->bslot); i++)\n\t\tah->bslot[i] = NULL;\n\n\tret = 0;\ndone:\n\tmutex_unlock(&ah->lock);\n\n\tset_bit(ATH_STAT_STARTED, ah->status);\n\tieee80211_queue_delayed_work(ah->hw, &ah->tx_complete_work,\n\t\t\tmsecs_to_jiffies(ATH5K_TX_COMPLETE_POLL_INT));\n\n\treturn ret;\n}\n\nstatic void ath5k_stop_tasklets(struct ath5k_hw *ah)\n{\n\tah->rx_pending = false;\n\tah->tx_pending = false;\n\ttasklet_kill(&ah->rxtq);\n\ttasklet_kill(&ah->txtq);\n\ttasklet_kill(&ah->beacontq);\n\ttasklet_kill(&ah->ani_tasklet);\n}\n\n \nvoid ath5k_stop(struct ieee80211_hw *hw)\n{\n\tstruct ath5k_hw *ah = hw->priv;\n\tint ret;\n\n\tmutex_lock(&ah->lock);\n\tret = ath5k_stop_locked(ah);\n\tif (ret == 0 && !test_bit(ATH_STAT_INVALID, ah->status)) {\n\t\t \n\t\tret = ath5k_hw_on_hold(ah);\n\n\t\tATH5K_DBG(ah, ATH5K_DEBUG_RESET,\n\t\t\t\t\"putting device to sleep\\n\");\n\t}\n\n\tmutex_unlock(&ah->lock);\n\n\tath5k_stop_tasklets(ah);\n\n\tclear_bit(ATH_STAT_STARTED, ah->status);\n\tcancel_delayed_work_sync(&ah->tx_complete_work);\n\n\tif (!ath5k_modparam_no_hw_rfkill_switch)\n\t\tath5k_rfkill_hw_stop(ah);\n}\n\n \nstatic int\nath5k_reset(struct ath5k_hw *ah, struct ieee80211_channel *chan,\n\t\t\t\t\t\t\tbool skip_pcu)\n{\n\tstruct ath_common *common = ath5k_hw_common(ah);\n\tint ret, ani_mode;\n\tbool fast = chan && modparam_fastchanswitch ? 1 : 0;\n\n\tATH5K_DBG(ah, ATH5K_DEBUG_RESET, \"resetting\\n\");\n\n\t__set_bit(ATH_STAT_RESET, ah->status);\n\n\tath5k_hw_set_imr(ah, 0);\n\tsynchronize_irq(ah->irq);\n\tath5k_stop_tasklets(ah);\n\n\t \n\tani_mode = ah->ani_state.ani_mode;\n\tath5k_ani_init(ah, ATH5K_ANI_MODE_OFF);\n\n\t \n\tath5k_drain_tx_buffs(ah);\n\n\t \n\tath5k_hw_stop_rx_pcu(ah);\n\n\t \n\tret = ath5k_hw_dma_stop(ah);\n\n\t \n\tif (ret && fast) {\n\t\tATH5K_DBG(ah, ATH5K_DEBUG_RESET,\n\t\t\t  \"DMA didn't stop, falling back to normal reset\\n\");\n\t\tfast = false;\n\t}\n\n\tif (chan)\n\t\tah->curchan = chan;\n\n\tret = ath5k_hw_reset(ah, ah->opmode, ah->curchan, fast, skip_pcu);\n\tif (ret) {\n\t\tATH5K_ERR(ah, \"can't reset hardware (%d)\\n\", ret);\n\t\tgoto err;\n\t}\n\n\tret = ath5k_rx_start(ah);\n\tif (ret) {\n\t\tATH5K_ERR(ah, \"can't start recv logic\\n\");\n\t\tgoto err;\n\t}\n\n\tath5k_ani_init(ah, ani_mode);\n\n\t \n\tah->ah_cal_next_full = jiffies +\n\t\tmsecs_to_jiffies(ATH5K_TUNE_CALIBRATION_INTERVAL_FULL);\n\tah->ah_cal_next_ani = jiffies +\n\t\tmsecs_to_jiffies(ATH5K_TUNE_CALIBRATION_INTERVAL_ANI);\n\tah->ah_cal_next_short = jiffies +\n\t\tmsecs_to_jiffies(ATH5K_TUNE_CALIBRATION_INTERVAL_SHORT);\n\n\tewma_beacon_rssi_init(&ah->ah_beacon_rssi_avg);\n\n\t \n\tmemset(&ah->survey, 0, sizeof(ah->survey));\n\tspin_lock_bh(&common->cc_lock);\n\tath_hw_cycle_counters_update(common);\n\tmemset(&common->cc_survey, 0, sizeof(common->cc_survey));\n\tmemset(&common->cc_ani, 0, sizeof(common->cc_ani));\n\tspin_unlock_bh(&common->cc_lock);\n\n\t \n \n\n\t__clear_bit(ATH_STAT_RESET, ah->status);\n\n\tath5k_beacon_config(ah);\n\t \n\n\tieee80211_wake_queues(ah->hw);\n\n\treturn 0;\nerr:\n\treturn ret;\n}\n\nstatic void ath5k_reset_work(struct work_struct *work)\n{\n\tstruct ath5k_hw *ah = container_of(work, struct ath5k_hw,\n\t\treset_work);\n\n\tmutex_lock(&ah->lock);\n\tath5k_reset(ah, NULL, true);\n\tmutex_unlock(&ah->lock);\n}\n\nstatic int\nath5k_init(struct ieee80211_hw *hw)\n{\n\n\tstruct ath5k_hw *ah = hw->priv;\n\tstruct ath_regulatory *regulatory = ath5k_hw_regulatory(ah);\n\tstruct ath5k_txq *txq;\n\tu8 mac[ETH_ALEN] = {};\n\tint ret;\n\n\n\t \n\tret = ath5k_setup_bands(hw);\n\tif (ret) {\n\t\tATH5K_ERR(ah, \"can't get channels\\n\");\n\t\tgoto err;\n\t}\n\n\t \n\tret = ath5k_desc_alloc(ah);\n\tif (ret) {\n\t\tATH5K_ERR(ah, \"can't allocate descriptors\\n\");\n\t\tgoto err;\n\t}\n\n\t \n\tret = ath5k_beaconq_setup(ah);\n\tif (ret < 0) {\n\t\tATH5K_ERR(ah, \"can't setup a beacon xmit queue\\n\");\n\t\tgoto err_desc;\n\t}\n\tah->bhalq = ret;\n\tah->cabq = ath5k_txq_setup(ah, AR5K_TX_QUEUE_CAB, 0);\n\tif (IS_ERR(ah->cabq)) {\n\t\tATH5K_ERR(ah, \"can't setup cab queue\\n\");\n\t\tret = PTR_ERR(ah->cabq);\n\t\tgoto err_bhal;\n\t}\n\n\t \n\tif (ah->ah_capabilities.cap_queues.q_tx_num >= 6) {\n\t\t \n\t\ttxq = ath5k_txq_setup(ah, AR5K_TX_QUEUE_DATA, AR5K_WME_AC_VO);\n\t\tif (IS_ERR(txq)) {\n\t\t\tATH5K_ERR(ah, \"can't setup xmit queue\\n\");\n\t\t\tret = PTR_ERR(txq);\n\t\t\tgoto err_queues;\n\t\t}\n\t\ttxq = ath5k_txq_setup(ah, AR5K_TX_QUEUE_DATA, AR5K_WME_AC_VI);\n\t\tif (IS_ERR(txq)) {\n\t\t\tATH5K_ERR(ah, \"can't setup xmit queue\\n\");\n\t\t\tret = PTR_ERR(txq);\n\t\t\tgoto err_queues;\n\t\t}\n\t\ttxq = ath5k_txq_setup(ah, AR5K_TX_QUEUE_DATA, AR5K_WME_AC_BE);\n\t\tif (IS_ERR(txq)) {\n\t\t\tATH5K_ERR(ah, \"can't setup xmit queue\\n\");\n\t\t\tret = PTR_ERR(txq);\n\t\t\tgoto err_queues;\n\t\t}\n\t\ttxq = ath5k_txq_setup(ah, AR5K_TX_QUEUE_DATA, AR5K_WME_AC_BK);\n\t\tif (IS_ERR(txq)) {\n\t\t\tATH5K_ERR(ah, \"can't setup xmit queue\\n\");\n\t\t\tret = PTR_ERR(txq);\n\t\t\tgoto err_queues;\n\t\t}\n\t\thw->queues = 4;\n\t} else {\n\t\t \n\t\ttxq = ath5k_txq_setup(ah, AR5K_TX_QUEUE_DATA, AR5K_WME_AC_BE);\n\t\tif (IS_ERR(txq)) {\n\t\t\tATH5K_ERR(ah, \"can't setup xmit queue\\n\");\n\t\t\tret = PTR_ERR(txq);\n\t\t\tgoto err_queues;\n\t\t}\n\t\thw->queues = 1;\n\t}\n\n\ttasklet_setup(&ah->rxtq, ath5k_tasklet_rx);\n\ttasklet_setup(&ah->txtq, ath5k_tasklet_tx);\n\ttasklet_setup(&ah->beacontq, ath5k_tasklet_beacon);\n\ttasklet_setup(&ah->ani_tasklet, ath5k_tasklet_ani);\n\n\tINIT_WORK(&ah->reset_work, ath5k_reset_work);\n\tINIT_WORK(&ah->calib_work, ath5k_calibrate_work);\n\tINIT_DELAYED_WORK(&ah->tx_complete_work, ath5k_tx_complete_poll_work);\n\n\tret = ath5k_hw_common(ah)->bus_ops->eeprom_read_mac(ah, mac);\n\tif (ret) {\n\t\tATH5K_ERR(ah, \"unable to read address from EEPROM\\n\");\n\t\tgoto err_queues;\n\t}\n\n\tSET_IEEE80211_PERM_ADDR(hw, mac);\n\t \n\tath5k_update_bssid_mask_and_opmode(ah, NULL);\n\n\tregulatory->current_rd = ah->ah_capabilities.cap_eeprom.ee_regdomain;\n\tret = ath_regd_init(regulatory, hw->wiphy, ath5k_reg_notifier);\n\tif (ret) {\n\t\tATH5K_ERR(ah, \"can't initialize regulatory system\\n\");\n\t\tgoto err_queues;\n\t}\n\n\tret = ieee80211_register_hw(hw);\n\tif (ret) {\n\t\tATH5K_ERR(ah, \"can't register ieee80211 hw\\n\");\n\t\tgoto err_queues;\n\t}\n\n\tif (!ath_is_world_regd(regulatory))\n\t\tregulatory_hint(hw->wiphy, regulatory->alpha2);\n\n\tath5k_init_leds(ah);\n\n\tath5k_sysfs_register(ah);\n\n\treturn 0;\nerr_queues:\n\tath5k_txq_release(ah);\nerr_bhal:\n\tath5k_hw_release_tx_queue(ah, ah->bhalq);\nerr_desc:\n\tath5k_desc_free(ah);\nerr:\n\treturn ret;\n}\n\nvoid\nath5k_deinit_ah(struct ath5k_hw *ah)\n{\n\tstruct ieee80211_hw *hw = ah->hw;\n\n\t \n\tieee80211_unregister_hw(hw);\n\tath5k_desc_free(ah);\n\tath5k_txq_release(ah);\n\tath5k_hw_release_tx_queue(ah, ah->bhalq);\n\tath5k_unregister_leds(ah);\n\n\tath5k_sysfs_unregister(ah);\n\t \n\tath5k_hw_deinit(ah);\n\tfree_irq(ah->irq, ah);\n}\n\nbool\nath5k_any_vif_assoc(struct ath5k_hw *ah)\n{\n\tstruct ath5k_vif_iter_data iter_data;\n\titer_data.hw_macaddr = NULL;\n\titer_data.any_assoc = false;\n\titer_data.need_set_hw_addr = false;\n\titer_data.found_active = true;\n\n\tieee80211_iterate_active_interfaces_atomic(\n\t\tah->hw, IEEE80211_IFACE_ITER_RESUME_ALL,\n\t\tath5k_vif_iter, &iter_data);\n\treturn iter_data.any_assoc;\n}\n\nvoid\nath5k_set_beacon_filter(struct ieee80211_hw *hw, bool enable)\n{\n\tstruct ath5k_hw *ah = hw->priv;\n\tu32 rfilt;\n\trfilt = ath5k_hw_get_rx_filter(ah);\n\tif (enable)\n\t\trfilt |= AR5K_RX_FILTER_BEACON;\n\telse\n\t\trfilt &= ~AR5K_RX_FILTER_BEACON;\n\tath5k_hw_set_rx_filter(ah, rfilt);\n\tah->filter_flags = rfilt;\n}\n\nvoid _ath5k_printk(const struct ath5k_hw *ah, const char *level,\n\t\t   const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tif (ah && ah->hw)\n\t\tprintk(\"%s\" pr_fmt(\"%s: %pV\"),\n\t\t       level, wiphy_name(ah->hw->wiphy), &vaf);\n\telse\n\t\tprintk(\"%s\" pr_fmt(\"%pV\"), level, &vaf);\n\n\tva_end(args);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}