{
  "module_name": "pci.c",
  "hash_id": "e16ecaf40c7b364a3aa1677f35d6f5a6287a7058299635a32c67f9a1fd9e14eb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath5k/pci.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/nl80211.h>\n#include <linux/pci.h>\n#include <linux/etherdevice.h>\n#include <linux/module.h>\n#include \"../ath.h\"\n#include \"ath5k.h\"\n#include \"debug.h\"\n#include \"base.h\"\n#include \"reg.h\"\n\n \nstatic const struct pci_device_id ath5k_pci_id_table[] = {\n\t{ PCI_VDEVICE(ATHEROS, 0x0207) },  \n\t{ PCI_VDEVICE(ATHEROS, 0x0007) },  \n\t{ PCI_VDEVICE(ATHEROS, 0x0011) },  \n\t{ PCI_VDEVICE(ATHEROS, 0x0012) },  \n\t{ PCI_VDEVICE(ATHEROS, 0x0013) },  \n\t{ PCI_VDEVICE(3COM_2,  0x0013) },  \n\t{ PCI_VDEVICE(3COM,    0x0013) },  \n\t{ PCI_VDEVICE(ATHEROS, 0x1014) },  \n\t{ PCI_VDEVICE(ATHEROS, 0x0014) },  \n\t{ PCI_VDEVICE(ATHEROS, 0x0015) },  \n\t{ PCI_VDEVICE(ATHEROS, 0x0016) },  \n\t{ PCI_VDEVICE(ATHEROS, 0x0017) },  \n\t{ PCI_VDEVICE(ATHEROS, 0x0018) },  \n\t{ PCI_VDEVICE(ATHEROS, 0x0019) },  \n\t{ PCI_VDEVICE(ATHEROS, 0x001a) },  \n\t{ PCI_VDEVICE(ATHEROS, 0x001b) },  \n\t{ PCI_VDEVICE(ATHEROS, 0x001c) },  \n\t{ PCI_VDEVICE(ATHEROS, 0x001d) },  \n\t{ PCI_VDEVICE(ATHEROS, 0xff1b) },  \n\t{ 0 }\n};\nMODULE_DEVICE_TABLE(pci, ath5k_pci_id_table);\n\n \nstatic void ath5k_pci_read_cachesize(struct ath_common *common, int *csz)\n{\n\tstruct ath5k_hw *ah = (struct ath5k_hw *) common->priv;\n\tu8 u8tmp;\n\n\tpci_read_config_byte(ah->pdev, PCI_CACHE_LINE_SIZE, &u8tmp);\n\t*csz = (int)u8tmp;\n\n\t \n\n\tif (*csz == 0)\n\t\t*csz = L1_CACHE_BYTES >> 2;    \n}\n\n \nstatic bool\nath5k_pci_eeprom_read(struct ath_common *common, u32 offset, u16 *data)\n{\n\tstruct ath5k_hw *ah = (struct ath5k_hw *) common->ah;\n\tu32 status, timeout;\n\n\t \n\tif (ah->ah_version == AR5K_AR5210) {\n\t\tAR5K_REG_ENABLE_BITS(ah, AR5K_PCICFG, AR5K_PCICFG_EEAE);\n\t\t(void)ath5k_hw_reg_read(ah, AR5K_EEPROM_BASE + (4 * offset));\n\t} else {\n\t\tath5k_hw_reg_write(ah, offset, AR5K_EEPROM_BASE);\n\t\tAR5K_REG_ENABLE_BITS(ah, AR5K_EEPROM_CMD,\n\t\t\t\tAR5K_EEPROM_CMD_READ);\n\t}\n\n\tfor (timeout = AR5K_TUNE_REGISTER_TIMEOUT; timeout > 0; timeout--) {\n\t\tstatus = ath5k_hw_reg_read(ah, AR5K_EEPROM_STATUS);\n\t\tif (status & AR5K_EEPROM_STAT_RDDONE) {\n\t\t\tif (status & AR5K_EEPROM_STAT_RDERR)\n\t\t\t\treturn false;\n\t\t\t*data = (u16)(ath5k_hw_reg_read(ah, AR5K_EEPROM_DATA) &\n\t\t\t\t\t0xffff);\n\t\t\treturn true;\n\t\t}\n\t\tusleep_range(15, 20);\n\t}\n\n\treturn false;\n}\n\nint ath5k_hw_read_srev(struct ath5k_hw *ah)\n{\n\tah->ah_mac_srev = ath5k_hw_reg_read(ah, AR5K_SREV);\n\treturn 0;\n}\n\n \nstatic int ath5k_pci_eeprom_read_mac(struct ath5k_hw *ah, u8 *mac)\n{\n\tu8 mac_d[ETH_ALEN] = {};\n\tu32 total, offset;\n\tu16 data;\n\tint octet;\n\n\tAR5K_EEPROM_READ(0x20, data);\n\n\tfor (offset = 0x1f, octet = 0, total = 0; offset >= 0x1d; offset--) {\n\t\tAR5K_EEPROM_READ(offset, data);\n\n\t\ttotal += data;\n\t\tmac_d[octet + 1] = data & 0xff;\n\t\tmac_d[octet] = data >> 8;\n\t\toctet += 2;\n\t}\n\n\tif (!total || total == 3 * 0xffff)\n\t\treturn -EINVAL;\n\n\tmemcpy(mac, mac_d, ETH_ALEN);\n\n\treturn 0;\n}\n\n\n \nstatic const struct ath_bus_ops ath_pci_bus_ops = {\n\t.ath_bus_type = ATH_PCI,\n\t.read_cachesize = ath5k_pci_read_cachesize,\n\t.eeprom_read = ath5k_pci_eeprom_read,\n\t.eeprom_read_mac = ath5k_pci_eeprom_read_mac,\n};\n\n \n\nstatic int\nath5k_pci_probe(struct pci_dev *pdev,\n\t\tconst struct pci_device_id *id)\n{\n\tvoid __iomem *mem;\n\tstruct ath5k_hw *ah;\n\tstruct ieee80211_hw *hw;\n\tint ret;\n\tu8 csz;\n\n\t \n\tpci_disable_link_state(pdev, PCIE_LINK_STATE_L0S);\n\n\tret = pci_enable_device(pdev);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"can't enable device\\n\");\n\t\tgoto err;\n\t}\n\n\t \n\tret = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"32-bit DMA not available\\n\");\n\t\tgoto err_dis;\n\t}\n\n\t \n\tpci_read_config_byte(pdev, PCI_CACHE_LINE_SIZE, &csz);\n\tif (csz == 0) {\n\t\t \n\t\tcsz = L1_CACHE_BYTES >> 2;\n\t\tpci_write_config_byte(pdev, PCI_CACHE_LINE_SIZE, csz);\n\t}\n\t \n\tpci_write_config_byte(pdev, PCI_LATENCY_TIMER, 0xa8);\n\n\t \n\tpci_set_master(pdev);\n\n\t \n\tpci_write_config_byte(pdev, 0x41, 0);\n\n\tret = pci_request_region(pdev, 0, \"ath5k\");\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"cannot reserve PCI memory region\\n\");\n\t\tgoto err_dis;\n\t}\n\n\tmem = pci_iomap(pdev, 0, 0);\n\tif (!mem) {\n\t\tdev_err(&pdev->dev, \"cannot remap PCI memory region\\n\");\n\t\tret = -EIO;\n\t\tgoto err_reg;\n\t}\n\n\t \n\thw = ieee80211_alloc_hw(sizeof(*ah), &ath5k_hw_ops);\n\tif (hw == NULL) {\n\t\tdev_err(&pdev->dev, \"cannot allocate ieee80211_hw\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_map;\n\t}\n\n\tdev_info(&pdev->dev, \"registered as '%s'\\n\", wiphy_name(hw->wiphy));\n\n\tah = hw->priv;\n\tah->hw = hw;\n\tah->pdev = pdev;\n\tah->dev = &pdev->dev;\n\tah->irq = pdev->irq;\n\tah->devid = id->device;\n\tah->iobase = mem;  \n\n\t \n\tret = ath5k_init_ah(ah, &ath_pci_bus_ops);\n\tif (ret)\n\t\tgoto err_free;\n\n\t \n\tpci_set_drvdata(pdev, hw);\n\n\treturn 0;\nerr_free:\n\tieee80211_free_hw(hw);\nerr_map:\n\tpci_iounmap(pdev, mem);\nerr_reg:\n\tpci_release_region(pdev, 0);\nerr_dis:\n\tpci_disable_device(pdev);\nerr:\n\treturn ret;\n}\n\nstatic void\nath5k_pci_remove(struct pci_dev *pdev)\n{\n\tstruct ieee80211_hw *hw = pci_get_drvdata(pdev);\n\tstruct ath5k_hw *ah = hw->priv;\n\n\tath5k_deinit_ah(ah);\n\tpci_iounmap(pdev, ah->iobase);\n\tpci_release_region(pdev, 0);\n\tpci_disable_device(pdev);\n\tieee80211_free_hw(hw);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int ath5k_pci_suspend(struct device *dev)\n{\n\tstruct ieee80211_hw *hw = dev_get_drvdata(dev);\n\tstruct ath5k_hw *ah = hw->priv;\n\n\tath5k_led_off(ah);\n\treturn 0;\n}\n\nstatic int ath5k_pci_resume(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct ieee80211_hw *hw = pci_get_drvdata(pdev);\n\tstruct ath5k_hw *ah = hw->priv;\n\n\t \n\tpci_write_config_byte(pdev, 0x41, 0);\n\n\tath5k_led_enable(ah);\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(ath5k_pm_ops, ath5k_pci_suspend, ath5k_pci_resume);\n#define ATH5K_PM_OPS\t(&ath5k_pm_ops)\n#else\n#define ATH5K_PM_OPS\tNULL\n#endif  \n\nstatic struct pci_driver ath5k_pci_driver = {\n\t.name\t\t= KBUILD_MODNAME,\n\t.id_table\t= ath5k_pci_id_table,\n\t.probe\t\t= ath5k_pci_probe,\n\t.remove\t\t= ath5k_pci_remove,\n\t.driver.pm\t= ATH5K_PM_OPS,\n};\n\nmodule_pci_driver(ath5k_pci_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}