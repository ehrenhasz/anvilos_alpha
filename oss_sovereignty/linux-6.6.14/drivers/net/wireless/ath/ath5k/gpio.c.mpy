{
  "module_name": "gpio.c",
  "hash_id": "1a5509f873fb433891ccba4ea42687edb31399cc5f01403ef6cdb297883e9cc5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath5k/gpio.c",
  "human_readable_source": " \n\n \n\n#include \"ath5k.h\"\n#include \"reg.h\"\n#include \"debug.h\"\n\n\n \n\n\n \nvoid\nath5k_hw_set_ledstate(struct ath5k_hw *ah, unsigned int state)\n{\n\tu32 led;\n\t \n\tu32 led_5210;\n\n\t \n\tif (ah->ah_version != AR5K_AR5210)\n\t\tAR5K_REG_DISABLE_BITS(ah, AR5K_PCICFG,\n\t\t\tAR5K_PCICFG_LEDMODE |  AR5K_PCICFG_LED);\n\telse\n\t\tAR5K_REG_DISABLE_BITS(ah, AR5K_PCICFG, AR5K_PCICFG_LED);\n\n\t \n\tswitch (state) {\n\tcase AR5K_LED_SCAN:\n\tcase AR5K_LED_AUTH:\n\t\tled = AR5K_PCICFG_LEDMODE_PROP | AR5K_PCICFG_LED_PEND;\n\t\tled_5210 = AR5K_PCICFG_LED_PEND | AR5K_PCICFG_LED_BCTL;\n\t\tbreak;\n\n\tcase AR5K_LED_INIT:\n\t\tled = AR5K_PCICFG_LEDMODE_PROP | AR5K_PCICFG_LED_NONE;\n\t\tled_5210 = AR5K_PCICFG_LED_PEND;\n\t\tbreak;\n\n\tcase AR5K_LED_ASSOC:\n\tcase AR5K_LED_RUN:\n\t\tled = AR5K_PCICFG_LEDMODE_PROP | AR5K_PCICFG_LED_ASSOC;\n\t\tled_5210 = AR5K_PCICFG_LED_ASSOC;\n\t\tbreak;\n\n\tdefault:\n\t\tled = AR5K_PCICFG_LEDMODE_PROM | AR5K_PCICFG_LED_NONE;\n\t\tled_5210 = AR5K_PCICFG_LED_PEND;\n\t\tbreak;\n\t}\n\n\t \n\tif (ah->ah_version != AR5K_AR5210)\n\t\tAR5K_REG_ENABLE_BITS(ah, AR5K_PCICFG, led);\n\telse\n\t\tAR5K_REG_ENABLE_BITS(ah, AR5K_PCICFG, led_5210);\n}\n\n \nint\nath5k_hw_set_gpio_input(struct ath5k_hw *ah, u32 gpio)\n{\n\tif (gpio >= AR5K_NUM_GPIO)\n\t\treturn -EINVAL;\n\n\tath5k_hw_reg_write(ah,\n\t\t(ath5k_hw_reg_read(ah, AR5K_GPIOCR) & ~AR5K_GPIOCR_OUT(gpio))\n\t\t| AR5K_GPIOCR_IN(gpio), AR5K_GPIOCR);\n\n\treturn 0;\n}\n\n \nint\nath5k_hw_set_gpio_output(struct ath5k_hw *ah, u32 gpio)\n{\n\tif (gpio >= AR5K_NUM_GPIO)\n\t\treturn -EINVAL;\n\n\tath5k_hw_reg_write(ah,\n\t\t(ath5k_hw_reg_read(ah, AR5K_GPIOCR) & ~AR5K_GPIOCR_OUT(gpio))\n\t\t| AR5K_GPIOCR_OUT(gpio), AR5K_GPIOCR);\n\n\treturn 0;\n}\n\n \nu32\nath5k_hw_get_gpio(struct ath5k_hw *ah, u32 gpio)\n{\n\tif (gpio >= AR5K_NUM_GPIO)\n\t\treturn 0xffffffff;\n\n\t \n\treturn ((ath5k_hw_reg_read(ah, AR5K_GPIODI) & AR5K_GPIODI_M) >> gpio) &\n\t\t0x1;\n}\n\n \nint\nath5k_hw_set_gpio(struct ath5k_hw *ah, u32 gpio, u32 val)\n{\n\tu32 data;\n\n\tif (gpio >= AR5K_NUM_GPIO)\n\t\treturn -EINVAL;\n\n\t \n\tdata = ath5k_hw_reg_read(ah, AR5K_GPIODO);\n\n\tdata &= ~(1 << gpio);\n\tdata |= (val & 1) << gpio;\n\n\tath5k_hw_reg_write(ah, data, AR5K_GPIODO);\n\n\treturn 0;\n}\n\n \nvoid\nath5k_hw_set_gpio_intr(struct ath5k_hw *ah, unsigned int gpio,\n\t\tu32 interrupt_level)\n{\n\tu32 data;\n\n\tif (gpio >= AR5K_NUM_GPIO)\n\t\treturn;\n\n\t \n\tdata = (ath5k_hw_reg_read(ah, AR5K_GPIOCR) &\n\t\t~(AR5K_GPIOCR_INT_SEL(gpio) | AR5K_GPIOCR_INT_SELH |\n\t\tAR5K_GPIOCR_INT_ENA | AR5K_GPIOCR_OUT(gpio))) |\n\t\t(AR5K_GPIOCR_INT_SEL(gpio) | AR5K_GPIOCR_INT_ENA);\n\n\tath5k_hw_reg_write(ah, interrupt_level ? data :\n\t\t(data | AR5K_GPIOCR_INT_SELH), AR5K_GPIOCR);\n\n\tah->ah_imr |= AR5K_IMR_GPIO;\n\n\t \n\tAR5K_REG_ENABLE_BITS(ah, AR5K_PIMR, AR5K_IMR_GPIO);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}