{
  "module_name": "mac80211-ops.c",
  "hash_id": "84fd5a6f5555af4f1b87e2623657d040fb96dc6f8fac9744b139368069d61389",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath5k/mac80211-ops.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <net/mac80211.h>\n#include <asm/unaligned.h>\n\n#include \"ath5k.h\"\n#include \"base.h\"\n#include \"reg.h\"\n\n \n\nstatic void\nath5k_tx(struct ieee80211_hw *hw, struct ieee80211_tx_control *control,\n\t struct sk_buff *skb)\n{\n\tstruct ath5k_hw *ah = hw->priv;\n\tu16 qnum = skb_get_queue_mapping(skb);\n\n\tif (WARN_ON(qnum >= ah->ah_capabilities.cap_queues.q_tx_num)) {\n\t\tieee80211_free_txskb(hw, skb);\n\t\treturn;\n\t}\n\n\tath5k_tx_queue(hw, skb, &ah->txqs[qnum], control);\n}\n\n\nstatic int\nath5k_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\n{\n\tstruct ath5k_hw *ah = hw->priv;\n\tint ret;\n\tstruct ath5k_vif *avf = (void *)vif->drv_priv;\n\n\tmutex_lock(&ah->lock);\n\n\tif ((vif->type == NL80211_IFTYPE_AP ||\n\t     vif->type == NL80211_IFTYPE_ADHOC)\n\t    && (ah->num_ap_vifs + ah->num_adhoc_vifs) >= ATH_BCBUF) {\n\t\tret = -ELNRNG;\n\t\tgoto end;\n\t}\n\n\t \n\tif (ah->num_adhoc_vifs ||\n\t    (ah->nvifs && vif->type == NL80211_IFTYPE_ADHOC)) {\n\t\tATH5K_ERR(ah, \"Only one single ad-hoc interface is allowed.\\n\");\n\t\tret = -ELNRNG;\n\t\tgoto end;\n\t}\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tavf->opmode = vif->type;\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tgoto end;\n\t}\n\n\tah->nvifs++;\n\tATH5K_DBG(ah, ATH5K_DEBUG_MODE, \"add interface mode %d\\n\", avf->opmode);\n\n\t \n\tif ((avf->opmode == NL80211_IFTYPE_AP) ||\n\t    (avf->opmode == NL80211_IFTYPE_ADHOC) ||\n\t    (avf->opmode == NL80211_IFTYPE_MESH_POINT)) {\n\t\tint slot;\n\n\t\tWARN_ON(list_empty(&ah->bcbuf));\n\t\tavf->bbuf = list_first_entry(&ah->bcbuf, struct ath5k_buf,\n\t\t\t\t\t     list);\n\t\tlist_del(&avf->bbuf->list);\n\n\t\tavf->bslot = 0;\n\t\tfor (slot = 0; slot < ATH_BCBUF; slot++) {\n\t\t\tif (!ah->bslot[slot]) {\n\t\t\t\tavf->bslot = slot;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tBUG_ON(ah->bslot[avf->bslot] != NULL);\n\t\tah->bslot[avf->bslot] = vif;\n\t\tif (avf->opmode == NL80211_IFTYPE_AP)\n\t\t\tah->num_ap_vifs++;\n\t\telse if (avf->opmode == NL80211_IFTYPE_ADHOC)\n\t\t\tah->num_adhoc_vifs++;\n\t\telse if (avf->opmode == NL80211_IFTYPE_MESH_POINT)\n\t\t\tah->num_mesh_vifs++;\n\t}\n\n\t \n\tath5k_hw_set_lladdr(ah, vif->addr);\n\n\tath5k_update_bssid_mask_and_opmode(ah, vif);\n\tret = 0;\nend:\n\tmutex_unlock(&ah->lock);\n\treturn ret;\n}\n\n\nstatic void\nath5k_remove_interface(struct ieee80211_hw *hw,\n\t\t       struct ieee80211_vif *vif)\n{\n\tstruct ath5k_hw *ah = hw->priv;\n\tstruct ath5k_vif *avf = (void *)vif->drv_priv;\n\tunsigned int i;\n\n\tmutex_lock(&ah->lock);\n\tah->nvifs--;\n\n\tif (avf->bbuf) {\n\t\tath5k_txbuf_free_skb(ah, avf->bbuf);\n\t\tlist_add_tail(&avf->bbuf->list, &ah->bcbuf);\n\t\tfor (i = 0; i < ATH_BCBUF; i++) {\n\t\t\tif (ah->bslot[i] == vif) {\n\t\t\t\tah->bslot[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tavf->bbuf = NULL;\n\t}\n\tif (avf->opmode == NL80211_IFTYPE_AP)\n\t\tah->num_ap_vifs--;\n\telse if (avf->opmode == NL80211_IFTYPE_ADHOC)\n\t\tah->num_adhoc_vifs--;\n\telse if (avf->opmode == NL80211_IFTYPE_MESH_POINT)\n\t\tah->num_mesh_vifs--;\n\n\tath5k_update_bssid_mask_and_opmode(ah, NULL);\n\tmutex_unlock(&ah->lock);\n}\n\n\n \nstatic int\nath5k_config(struct ieee80211_hw *hw, u32 changed)\n{\n\tstruct ath5k_hw *ah = hw->priv;\n\tstruct ieee80211_conf *conf = &hw->conf;\n\tint ret = 0;\n\tint i;\n\n\tmutex_lock(&ah->lock);\n\n\tif (changed & IEEE80211_CONF_CHANGE_CHANNEL) {\n\t\tret = ath5k_chan_set(ah, &conf->chandef);\n\t\tif (ret < 0)\n\t\t\tgoto unlock;\n\t}\n\n\tif ((changed & IEEE80211_CONF_CHANGE_POWER) &&\n\t(ah->ah_txpower.txp_requested != conf->power_level)) {\n\t\tah->ah_txpower.txp_requested = conf->power_level;\n\n\t\t \n\t\tath5k_hw_set_txpower_limit(ah, (conf->power_level * 2));\n\t}\n\n\tif (changed & IEEE80211_CONF_CHANGE_RETRY_LIMITS) {\n\t\tah->ah_retry_long = conf->long_frame_max_tx_count;\n\t\tah->ah_retry_short = conf->short_frame_max_tx_count;\n\n\t\tfor (i = 0; i < ah->ah_capabilities.cap_queues.q_tx_num; i++)\n\t\t\tath5k_hw_set_tx_retry_limits(ah, i);\n\t}\n\n\t \n\tath5k_hw_set_antenna_mode(ah, ah->ah_ant_mode);\n\nunlock:\n\tmutex_unlock(&ah->lock);\n\treturn ret;\n}\n\n\nstatic void\nath5k_bss_info_changed(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t       struct ieee80211_bss_conf *bss_conf, u64 changes)\n{\n\tstruct ath5k_vif *avf = (void *)vif->drv_priv;\n\tstruct ath5k_hw *ah = hw->priv;\n\tstruct ath_common *common = ath5k_hw_common(ah);\n\n\tmutex_lock(&ah->lock);\n\n\tif (changes & BSS_CHANGED_BSSID) {\n\t\t \n\t\tmemcpy(common->curbssid, bss_conf->bssid, ETH_ALEN);\n\t\tcommon->curaid = 0;\n\t\tath5k_hw_set_bssid(ah);\n\t}\n\n\tif (changes & BSS_CHANGED_BEACON_INT)\n\t\tah->bintval = bss_conf->beacon_int;\n\n\tif (changes & BSS_CHANGED_ERP_SLOT) {\n\t\tint slot_time;\n\n\t\tah->ah_short_slot = bss_conf->use_short_slot;\n\t\tslot_time = ath5k_hw_get_default_slottime(ah) +\n\t\t\t    3 * ah->ah_coverage_class;\n\t\tath5k_hw_set_ifs_intervals(ah, slot_time);\n\t}\n\n\tif (changes & BSS_CHANGED_ASSOC) {\n\t\tavf->assoc = vif->cfg.assoc;\n\t\tif (vif->cfg.assoc)\n\t\t\tah->assoc = vif->cfg.assoc;\n\t\telse\n\t\t\tah->assoc = ath5k_any_vif_assoc(ah);\n\n\t\tif (ah->opmode == NL80211_IFTYPE_STATION)\n\t\t\tath5k_set_beacon_filter(hw, ah->assoc);\n\t\tath5k_hw_set_ledstate(ah, ah->assoc ?\n\t\t\tAR5K_LED_ASSOC : AR5K_LED_INIT);\n\t\tif (vif->cfg.assoc) {\n\t\t\tATH5K_DBG(ah, ATH5K_DEBUG_ANY,\n\t\t\t\t  \"Bss Info ASSOC %d, bssid: %pM\\n\",\n\t\t\t\t  vif->cfg.aid, common->curbssid);\n\t\t\tcommon->curaid = vif->cfg.aid;\n\t\t\tath5k_hw_set_bssid(ah);\n\t\t\t \n\t\t}\n\t}\n\n\tif (changes & BSS_CHANGED_BEACON) {\n\t\tspin_lock_bh(&ah->block);\n\t\tath5k_beacon_update(hw, vif);\n\t\tspin_unlock_bh(&ah->block);\n\t}\n\n\tif (changes & BSS_CHANGED_BEACON_ENABLED)\n\t\tah->enable_beacon = bss_conf->enable_beacon;\n\n\tif (changes & (BSS_CHANGED_BEACON | BSS_CHANGED_BEACON_ENABLED |\n\t\t       BSS_CHANGED_BEACON_INT))\n\t\tath5k_beacon_config(ah);\n\n\tmutex_unlock(&ah->lock);\n}\n\n\nstatic u64\nath5k_prepare_multicast(struct ieee80211_hw *hw,\n\t\t\tstruct netdev_hw_addr_list *mc_list)\n{\n\tu32 mfilt[2], val;\n\tu8 pos;\n\tstruct netdev_hw_addr *ha;\n\n\tmfilt[0] = 0;\n\tmfilt[1] = 0;\n\n\tnetdev_hw_addr_list_for_each(ha, mc_list) {\n\t\t \n\t\tval = get_unaligned_le32(ha->addr + 0);\n\t\tpos = (val >> 18) ^ (val >> 12) ^ (val >> 6) ^ val;\n\t\tval = get_unaligned_le32(ha->addr + 3);\n\t\tpos ^= (val >> 18) ^ (val >> 12) ^ (val >> 6) ^ val;\n\t\tpos &= 0x3f;\n\t\tmfilt[pos / 32] |= (1 << (pos % 32));\n\t\t \n\t\t \n\t}\n\n\treturn ((u64)(mfilt[1]) << 32) | mfilt[0];\n}\n\n\n \nstatic void\nath5k_configure_filter(struct ieee80211_hw *hw, unsigned int changed_flags,\n\t\t       unsigned int *new_flags, u64 multicast)\n{\n#define SUPPORTED_FIF_FLAGS \\\n\t(FIF_ALLMULTI | FIF_FCSFAIL | \\\n\tFIF_PLCPFAIL | FIF_CONTROL | FIF_OTHER_BSS | \\\n\tFIF_BCN_PRBRESP_PROMISC)\n\n\tstruct ath5k_hw *ah = hw->priv;\n\tu32 mfilt[2], rfilt;\n\tstruct ath5k_vif_iter_data iter_data;  \n\n\tmutex_lock(&ah->lock);\n\n\tmfilt[0] = multicast;\n\tmfilt[1] = multicast >> 32;\n\n\t \n\t*new_flags &= SUPPORTED_FIF_FLAGS;\n\n\t \n\trfilt = (ath5k_hw_get_rx_filter(ah) & (AR5K_RX_FILTER_PHYERR)) |\n\t\t(AR5K_RX_FILTER_UCAST | AR5K_RX_FILTER_BCAST |\n\t\tAR5K_RX_FILTER_MCAST);\n\n\t \n\tif (*new_flags & FIF_ALLMULTI) {\n\t\tmfilt[0] =  ~0;\n\t\tmfilt[1] =  ~0;\n\t}\n\n\t \n\tif (*new_flags & (FIF_FCSFAIL | FIF_PLCPFAIL))\n\t\trfilt |= AR5K_RX_FILTER_PHYERR;\n\n\t \n\tif ((*new_flags & FIF_BCN_PRBRESP_PROMISC) || (ah->nvifs > 1))\n\t\trfilt |= AR5K_RX_FILTER_BEACON;\n\n\t \n\tif (*new_flags & FIF_CONTROL)\n\t\trfilt |= AR5K_RX_FILTER_CONTROL;\n\n\t \n\n\t \n\n\tswitch (ah->opmode) {\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\trfilt |= AR5K_RX_FILTER_CONTROL |\n\t\t\t AR5K_RX_FILTER_BEACON |\n\t\t\t AR5K_RX_FILTER_PROBEREQ |\n\t\t\t AR5K_RX_FILTER_PROM;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_ADHOC:\n\t\trfilt |= AR5K_RX_FILTER_PROBEREQ |\n\t\t\t AR5K_RX_FILTER_BEACON;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (ah->assoc)\n\t\t\trfilt |= AR5K_RX_FILTER_BEACON;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\titer_data.hw_macaddr = NULL;\n\titer_data.n_stas = 0;\n\titer_data.need_set_hw_addr = false;\n\tieee80211_iterate_active_interfaces_atomic(\n\t\tah->hw, IEEE80211_IFACE_ITER_RESUME_ALL,\n\t\tath5k_vif_iter, &iter_data);\n\n\t \n\tif (iter_data.n_stas > 1) {\n\t\t \n\t\trfilt |= AR5K_RX_FILTER_PROM;\n\t}\n\n\t \n\tath5k_hw_set_rx_filter(ah, rfilt);\n\n\t \n\tath5k_hw_set_mcast_filter(ah, mfilt[0], mfilt[1]);\n\t \n\tah->filter_flags = rfilt;\n\t \n\tah->fif_filter_flags = *new_flags;\n\n\tmutex_unlock(&ah->lock);\n}\n\n\nstatic int\nath5k_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,\n\t      struct ieee80211_vif *vif, struct ieee80211_sta *sta,\n\t      struct ieee80211_key_conf *key)\n{\n\tstruct ath5k_hw *ah = hw->priv;\n\tstruct ath_common *common = ath5k_hw_common(ah);\n\tint ret = 0;\n\n\tif (ath5k_modparam_nohwcrypt)\n\t\treturn -EOPNOTSUPP;\n\n\tif (key->flags & IEEE80211_KEY_FLAG_RX_MGMT)\n\t\treturn -EOPNOTSUPP;\n\n\tif (vif->type == NL80211_IFTYPE_ADHOC &&\n\t    (key->cipher == WLAN_CIPHER_SUITE_TKIP ||\n\t     key->cipher == WLAN_CIPHER_SUITE_CCMP) &&\n\t    !(key->flags & IEEE80211_KEY_FLAG_PAIRWISE)) {\n\t\t \n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tswitch (key->cipher) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tif (common->crypt_caps & ATH_CRYPT_CAP_CIPHER_AESCCM)\n\t\t\tbreak;\n\t\treturn -EOPNOTSUPP;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmutex_lock(&ah->lock);\n\n\tswitch (cmd) {\n\tcase SET_KEY:\n\t\tret = ath_key_config(common, vif, sta, key);\n\t\tif (ret >= 0) {\n\t\t\tkey->hw_key_idx = ret;\n\t\t\t \n\t\t\tkey->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;\n\t\t\tif (key->cipher == WLAN_CIPHER_SUITE_TKIP)\n\t\t\t\tkey->flags |= IEEE80211_KEY_FLAG_GENERATE_MMIC;\n\t\t\tif (key->cipher == WLAN_CIPHER_SUITE_CCMP)\n\t\t\t\tkey->flags |= IEEE80211_KEY_FLAG_SW_MGMT_TX;\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\tcase DISABLE_KEY:\n\t\tath_key_delete(common, key->hw_key_idx);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\tmutex_unlock(&ah->lock);\n\treturn ret;\n}\n\n\nstatic void\nath5k_sw_scan_start(struct ieee80211_hw *hw,\n\t\t    struct ieee80211_vif *vif,\n\t\t    const u8 *mac_addr)\n{\n\tstruct ath5k_hw *ah = hw->priv;\n\tif (!ah->assoc)\n\t\tath5k_hw_set_ledstate(ah, AR5K_LED_SCAN);\n}\n\n\nstatic void\nath5k_sw_scan_complete(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\n{\n\tstruct ath5k_hw *ah = hw->priv;\n\tath5k_hw_set_ledstate(ah, ah->assoc ?\n\t\tAR5K_LED_ASSOC : AR5K_LED_INIT);\n}\n\n\nstatic int\nath5k_get_stats(struct ieee80211_hw *hw,\n\t\tstruct ieee80211_low_level_stats *stats)\n{\n\tstruct ath5k_hw *ah = hw->priv;\n\n\t \n\tath5k_hw_update_mib_counters(ah);\n\n\tstats->dot11ACKFailureCount = ah->stats.ack_fail;\n\tstats->dot11RTSFailureCount = ah->stats.rts_fail;\n\tstats->dot11RTSSuccessCount = ah->stats.rts_ok;\n\tstats->dot11FCSErrorCount = ah->stats.fcs_error;\n\n\treturn 0;\n}\n\n\nstatic int\nath5k_conf_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t      unsigned int link_id, u16 queue,\n\t      const struct ieee80211_tx_queue_params *params)\n{\n\tstruct ath5k_hw *ah = hw->priv;\n\tstruct ath5k_txq_info qi;\n\tint ret = 0;\n\n\tif (queue >= ah->ah_capabilities.cap_queues.q_tx_num)\n\t\treturn 0;\n\n\tmutex_lock(&ah->lock);\n\n\tath5k_hw_get_tx_queueprops(ah, queue, &qi);\n\n\tqi.tqi_aifs = params->aifs;\n\tqi.tqi_cw_min = params->cw_min;\n\tqi.tqi_cw_max = params->cw_max;\n\tqi.tqi_burst_time = params->txop * 32;\n\n\tATH5K_DBG(ah, ATH5K_DEBUG_ANY,\n\t\t  \"Configure tx [queue %d],  \"\n\t\t  \"aifs: %d, cw_min: %d, cw_max: %d, txop: %d\\n\",\n\t\t  queue, params->aifs, params->cw_min,\n\t\t  params->cw_max, params->txop);\n\n\tif (ath5k_hw_set_tx_queueprops(ah, queue, &qi)) {\n\t\tATH5K_ERR(ah,\n\t\t\t  \"Unable to update hardware queue %u!\\n\", queue);\n\t\tret = -EIO;\n\t} else\n\t\tath5k_hw_reset_tx_queue(ah, queue);\n\n\tmutex_unlock(&ah->lock);\n\n\treturn ret;\n}\n\n\nstatic u64\nath5k_get_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\n{\n\tstruct ath5k_hw *ah = hw->priv;\n\n\treturn ath5k_hw_get_tsf64(ah);\n}\n\n\nstatic void\nath5k_set_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif, u64 tsf)\n{\n\tstruct ath5k_hw *ah = hw->priv;\n\n\tath5k_hw_set_tsf64(ah, tsf);\n}\n\n\nstatic void\nath5k_reset_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\n{\n\tstruct ath5k_hw *ah = hw->priv;\n\n\t \n\tif (ah->opmode == NL80211_IFTYPE_ADHOC)\n\t\tath5k_beacon_update_timers(ah, 0);\n\telse\n\t\tath5k_hw_reset_tsf(ah);\n}\n\n\nstatic int\nath5k_get_survey(struct ieee80211_hw *hw, int idx, struct survey_info *survey)\n{\n\tstruct ath5k_hw *ah = hw->priv;\n\tstruct ieee80211_conf *conf = &hw->conf;\n\tstruct ath_common *common = ath5k_hw_common(ah);\n\tstruct ath_cycle_counters *cc = &common->cc_survey;\n\tunsigned int div = common->clockrate * 1000;\n\n\tif (idx != 0)\n\t\treturn -ENOENT;\n\n\tspin_lock_bh(&common->cc_lock);\n\tath_hw_cycle_counters_update(common);\n\tif (cc->cycles > 0) {\n\t\tah->survey.time += cc->cycles / div;\n\t\tah->survey.time_busy += cc->rx_busy / div;\n\t\tah->survey.time_rx += cc->rx_frame / div;\n\t\tah->survey.time_tx += cc->tx_frame / div;\n\t}\n\tmemset(cc, 0, sizeof(*cc));\n\tspin_unlock_bh(&common->cc_lock);\n\n\tmemcpy(survey, &ah->survey, sizeof(*survey));\n\n\tsurvey->channel = conf->chandef.chan;\n\tsurvey->noise = ah->ah_noise_floor;\n\tsurvey->filled = SURVEY_INFO_NOISE_DBM |\n\t\t\tSURVEY_INFO_IN_USE |\n\t\t\tSURVEY_INFO_TIME |\n\t\t\tSURVEY_INFO_TIME_BUSY |\n\t\t\tSURVEY_INFO_TIME_RX |\n\t\t\tSURVEY_INFO_TIME_TX;\n\n\treturn 0;\n}\n\n\n \nstatic void\nath5k_set_coverage_class(struct ieee80211_hw *hw, s16 coverage_class)\n{\n\tstruct ath5k_hw *ah = hw->priv;\n\n\tmutex_lock(&ah->lock);\n\tath5k_hw_set_coverage_class(ah, coverage_class);\n\tmutex_unlock(&ah->lock);\n}\n\n\nstatic int\nath5k_set_antenna(struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant)\n{\n\tstruct ath5k_hw *ah = hw->priv;\n\n\tif (tx_ant == 1 && rx_ant == 1)\n\t\tath5k_hw_set_antenna_mode(ah, AR5K_ANTMODE_FIXED_A);\n\telse if (tx_ant == 2 && rx_ant == 2)\n\t\tath5k_hw_set_antenna_mode(ah, AR5K_ANTMODE_FIXED_B);\n\telse if ((tx_ant & 3) == 3 && (rx_ant & 3) == 3)\n\t\tath5k_hw_set_antenna_mode(ah, AR5K_ANTMODE_DEFAULT);\n\telse\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\n\nstatic int\nath5k_get_antenna(struct ieee80211_hw *hw, u32 *tx_ant, u32 *rx_ant)\n{\n\tstruct ath5k_hw *ah = hw->priv;\n\n\tswitch (ah->ah_ant_mode) {\n\tcase AR5K_ANTMODE_FIXED_A:\n\t\t*tx_ant = 1; *rx_ant = 1; break;\n\tcase AR5K_ANTMODE_FIXED_B:\n\t\t*tx_ant = 2; *rx_ant = 2; break;\n\tcase AR5K_ANTMODE_DEFAULT:\n\t\t*tx_ant = 3; *rx_ant = 3; break;\n\t}\n\treturn 0;\n}\n\n\nstatic void ath5k_get_ringparam(struct ieee80211_hw *hw,\n\t\t\t\tu32 *tx, u32 *tx_max, u32 *rx, u32 *rx_max)\n{\n\tstruct ath5k_hw *ah = hw->priv;\n\n\t*tx = ah->txqs[AR5K_TX_QUEUE_ID_DATA_MIN].txq_max;\n\n\t*tx_max = ATH5K_TXQ_LEN_MAX;\n\t*rx = *rx_max = ATH_RXBUF;\n}\n\n\nstatic int ath5k_set_ringparam(struct ieee80211_hw *hw, u32 tx, u32 rx)\n{\n\tstruct ath5k_hw *ah = hw->priv;\n\tu16 qnum;\n\n\t \n\tif (rx != ATH_RXBUF)\n\t\treturn -EINVAL;\n\n\t \n\tif (!tx || tx > ATH5K_TXQ_LEN_MAX)\n\t\treturn -EINVAL;\n\n\tfor (qnum = 0; qnum < ARRAY_SIZE(ah->txqs); qnum++) {\n\t\tif (!ah->txqs[qnum].setup)\n\t\t\tcontinue;\n\t\tif (ah->txqs[qnum].qnum < AR5K_TX_QUEUE_ID_DATA_MIN ||\n\t\t    ah->txqs[qnum].qnum > AR5K_TX_QUEUE_ID_DATA_MAX)\n\t\t\tcontinue;\n\n\t\tah->txqs[qnum].txq_max = tx;\n\t\tif (ah->txqs[qnum].txq_len >= ah->txqs[qnum].txq_max)\n\t\t\tieee80211_stop_queue(hw, ah->txqs[qnum].qnum);\n\t}\n\n\treturn 0;\n}\n\n\nconst struct ieee80211_ops ath5k_hw_ops = {\n\t.tx\t\t\t= ath5k_tx,\n\t.wake_tx_queue\t\t= ieee80211_handle_wake_tx_queue,\n\t.start\t\t\t= ath5k_start,\n\t.stop\t\t\t= ath5k_stop,\n\t.add_interface\t\t= ath5k_add_interface,\n\t \n\t.remove_interface\t= ath5k_remove_interface,\n\t.config\t\t\t= ath5k_config,\n\t.bss_info_changed\t= ath5k_bss_info_changed,\n\t.prepare_multicast\t= ath5k_prepare_multicast,\n\t.configure_filter\t= ath5k_configure_filter,\n\t \n\t.set_key\t\t= ath5k_set_key,\n\t \n\t \n\t.sw_scan_start\t\t= ath5k_sw_scan_start,\n\t.sw_scan_complete\t= ath5k_sw_scan_complete,\n\t.get_stats\t\t= ath5k_get_stats,\n\t \n\t \n\t \n\t \n\t \n\t.conf_tx\t\t= ath5k_conf_tx,\n\t.get_tsf\t\t= ath5k_get_tsf,\n\t.set_tsf\t\t= ath5k_set_tsf,\n\t.reset_tsf\t\t= ath5k_reset_tsf,\n\t \n\t \n\t.get_survey\t\t= ath5k_get_survey,\n\t.set_coverage_class\t= ath5k_set_coverage_class,\n\t \n\t \n\t \n\t \n\t.set_antenna\t\t= ath5k_set_antenna,\n\t.get_antenna\t\t= ath5k_get_antenna,\n\t.set_ringparam\t\t= ath5k_set_ringparam,\n\t.get_ringparam\t\t= ath5k_get_ringparam,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}