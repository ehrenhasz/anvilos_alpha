{
  "module_name": "ahb.c",
  "hash_id": "d0e20f70416098caa5c94b7b40d806cb88df1f6eb9f59007616478a23ee40c0f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/ath5k/ahb.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/nl80211.h>\n#include <linux/platform_device.h>\n#include <linux/etherdevice.h>\n#include <ath25_platform.h>\n#include \"ath5k.h\"\n#include \"debug.h\"\n#include \"base.h\"\n#include \"reg.h\"\n\n \nstatic void ath5k_ahb_read_cachesize(struct ath_common *common, int *csz)\n{\n\t*csz = L1_CACHE_BYTES >> 2;\n}\n\nstatic bool\nath5k_ahb_eeprom_read(struct ath_common *common, u32 off, u16 *data)\n{\n\tstruct ath5k_hw *ah = common->priv;\n\tstruct platform_device *pdev = to_platform_device(ah->dev);\n\tstruct ar231x_board_config *bcfg = dev_get_platdata(&pdev->dev);\n\tu16 *eeprom, *eeprom_end;\n\n\teeprom = (u16 *) bcfg->radio;\n\teeprom_end = ((void *) bcfg->config) + BOARD_CONFIG_BUFSZ;\n\n\teeprom += off;\n\tif (eeprom > eeprom_end)\n\t\treturn false;\n\n\t*data = *eeprom;\n\treturn true;\n}\n\nint ath5k_hw_read_srev(struct ath5k_hw *ah)\n{\n\tstruct platform_device *pdev = to_platform_device(ah->dev);\n\tstruct ar231x_board_config *bcfg = dev_get_platdata(&pdev->dev);\n\tah->ah_mac_srev = bcfg->devid;\n\treturn 0;\n}\n\nstatic int ath5k_ahb_eeprom_read_mac(struct ath5k_hw *ah, u8 *mac)\n{\n\tstruct platform_device *pdev = to_platform_device(ah->dev);\n\tstruct ar231x_board_config *bcfg = dev_get_platdata(&pdev->dev);\n\tu8 *cfg_mac;\n\n\tif (to_platform_device(ah->dev)->id == 0)\n\t\tcfg_mac = bcfg->config->wlan0_mac;\n\telse\n\t\tcfg_mac = bcfg->config->wlan1_mac;\n\n\tmemcpy(mac, cfg_mac, ETH_ALEN);\n\treturn 0;\n}\n\nstatic const struct ath_bus_ops ath_ahb_bus_ops = {\n\t.ath_bus_type = ATH_AHB,\n\t.read_cachesize = ath5k_ahb_read_cachesize,\n\t.eeprom_read = ath5k_ahb_eeprom_read,\n\t.eeprom_read_mac = ath5k_ahb_eeprom_read_mac,\n};\n\n \nstatic int ath_ahb_probe(struct platform_device *pdev)\n{\n\tstruct ar231x_board_config *bcfg = dev_get_platdata(&pdev->dev);\n\tstruct ath5k_hw *ah;\n\tstruct ieee80211_hw *hw;\n\tstruct resource *res;\n\tvoid __iomem *mem;\n\tint irq;\n\tint ret = 0;\n\tu32 reg;\n\n\tif (!dev_get_platdata(&pdev->dev)) {\n\t\tdev_err(&pdev->dev, \"no platform data specified\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_out;\n\t}\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (res == NULL) {\n\t\tdev_err(&pdev->dev, \"no memory resource found\\n\");\n\t\tret = -ENXIO;\n\t\tgoto err_out;\n\t}\n\n\tmem = ioremap(res->start, resource_size(res));\n\tif (mem == NULL) {\n\t\tdev_err(&pdev->dev, \"ioremap failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto err_iounmap;\n\t}\n\n\thw = ieee80211_alloc_hw(sizeof(struct ath5k_hw), &ath5k_hw_ops);\n\tif (hw == NULL) {\n\t\tdev_err(&pdev->dev, \"no memory for ieee80211_hw\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_iounmap;\n\t}\n\n\tah = hw->priv;\n\tah->hw = hw;\n\tah->dev = &pdev->dev;\n\tah->iobase = mem;\n\tah->irq = irq;\n\tah->devid = bcfg->devid;\n\n\tif (bcfg->devid >= AR5K_SREV_AR2315_R6) {\n\t\t \n\t\treg = ioread32((void __iomem *) AR5K_AR2315_AHB_ARB_CTL);\n\t\treg |= AR5K_AR2315_AHB_ARB_CTL_WLAN;\n\t\tiowrite32(reg, (void __iomem *) AR5K_AR2315_AHB_ARB_CTL);\n\n\t\t \n\t\treg = ioread32((void __iomem *) AR5K_AR2315_BYTESWAP);\n\t\treg |= AR5K_AR2315_BYTESWAP_WMAC;\n\t\tiowrite32(reg, (void __iomem *) AR5K_AR2315_BYTESWAP);\n\t} else {\n\t\t \n\t\t \n\t\treg = ioread32((void __iomem *) AR5K_AR5312_ENABLE);\n\t\tif (to_platform_device(ah->dev)->id == 0)\n\t\t\treg |= AR5K_AR5312_ENABLE_WLAN0;\n\t\telse\n\t\t\treg |= AR5K_AR5312_ENABLE_WLAN1;\n\t\tiowrite32(reg, (void __iomem *) AR5K_AR5312_ENABLE);\n\n\t\t \n\t\tif (to_platform_device(ah->dev)->id == 0 &&\n\t\t    (bcfg->config->flags & (BD_WLAN0 | BD_WLAN1)) ==\n\t\t     (BD_WLAN1 | BD_WLAN0))\n\t\t\tah->ah_capabilities.cap_needs_2GHz_ovr = true;\n\t\telse\n\t\t\tah->ah_capabilities.cap_needs_2GHz_ovr = false;\n\t}\n\n\tret = ath5k_init_ah(ah, &ath_ahb_bus_ops);\n\tif (ret != 0) {\n\t\tdev_err(&pdev->dev, \"failed to attach device, err=%d\\n\", ret);\n\t\tret = -ENODEV;\n\t\tgoto err_free_hw;\n\t}\n\n\tplatform_set_drvdata(pdev, hw);\n\n\treturn 0;\n\n err_free_hw:\n\tieee80211_free_hw(hw);\n err_iounmap:\n        iounmap(mem);\n err_out:\n\treturn ret;\n}\n\nstatic int ath_ahb_remove(struct platform_device *pdev)\n{\n\tstruct ar231x_board_config *bcfg = dev_get_platdata(&pdev->dev);\n\tstruct ieee80211_hw *hw = platform_get_drvdata(pdev);\n\tstruct ath5k_hw *ah;\n\tu32 reg;\n\n\tif (!hw)\n\t\treturn 0;\n\n\tah = hw->priv;\n\n\tif (bcfg->devid >= AR5K_SREV_AR2315_R6) {\n\t\t \n\t\treg = ioread32((void __iomem *) AR5K_AR2315_AHB_ARB_CTL);\n\t\treg &= ~AR5K_AR2315_AHB_ARB_CTL_WLAN;\n\t\tiowrite32(reg, (void __iomem *) AR5K_AR2315_AHB_ARB_CTL);\n\t} else {\n\t\t \n\t\treg = ioread32((void __iomem *) AR5K_AR5312_ENABLE);\n\t\tif (to_platform_device(ah->dev)->id == 0)\n\t\t\treg &= ~AR5K_AR5312_ENABLE_WLAN0;\n\t\telse\n\t\t\treg &= ~AR5K_AR5312_ENABLE_WLAN1;\n\t\tiowrite32(reg, (void __iomem *) AR5K_AR5312_ENABLE);\n\t}\n\n\tath5k_deinit_ah(ah);\n\tiounmap(ah->iobase);\n\tieee80211_free_hw(hw);\n\n\treturn 0;\n}\n\nstatic struct platform_driver ath_ahb_driver = {\n\t.probe      = ath_ahb_probe,\n\t.remove     = ath_ahb_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"ar231x-wmac\",\n\t},\n};\n\nmodule_platform_driver(ath_ahb_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}