{
  "module_name": "smd.c",
  "hash_id": "f9120fd37b05a53812f1cd1caf12f5f6b1fee87b75ec7556e4466ca41e1254ba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/wcn36xx/smd.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/bitfield.h>\n#include <linux/etherdevice.h>\n#include <linux/firmware.h>\n#include <linux/bitops.h>\n#include <linux/rpmsg.h>\n#include \"smd.h\"\n#include \"firmware.h\"\n\nstruct wcn36xx_cfg_val {\n\tu32 cfg_id;\n\tu32 value;\n};\n\n#define WCN36XX_CFG_VAL(id, val) \\\n{ \\\n\t.cfg_id = WCN36XX_HAL_CFG_ ## id, \\\n\t.value = val \\\n}\n\nstatic struct wcn36xx_cfg_val wcn36xx_cfg_vals[] = {\n\tWCN36XX_CFG_VAL(CURRENT_TX_ANTENNA, 1),\n\tWCN36XX_CFG_VAL(CURRENT_RX_ANTENNA, 1),\n\tWCN36XX_CFG_VAL(LOW_GAIN_OVERRIDE, 0),\n\tWCN36XX_CFG_VAL(POWER_STATE_PER_CHAIN, 785),\n\tWCN36XX_CFG_VAL(CAL_PERIOD, 5),\n\tWCN36XX_CFG_VAL(CAL_CONTROL, 1),\n\tWCN36XX_CFG_VAL(PROXIMITY, 0),\n\tWCN36XX_CFG_VAL(NETWORK_DENSITY, 3),\n\tWCN36XX_CFG_VAL(MAX_MEDIUM_TIME, 6000),\n\tWCN36XX_CFG_VAL(MAX_MPDUS_IN_AMPDU, 64),\n\tWCN36XX_CFG_VAL(RTS_THRESHOLD, 2347),\n\tWCN36XX_CFG_VAL(SHORT_RETRY_LIMIT, 15),\n\tWCN36XX_CFG_VAL(LONG_RETRY_LIMIT, 15),\n\tWCN36XX_CFG_VAL(FRAGMENTATION_THRESHOLD, 8000),\n\tWCN36XX_CFG_VAL(DYNAMIC_THRESHOLD_ZERO, 5),\n\tWCN36XX_CFG_VAL(DYNAMIC_THRESHOLD_ONE, 10),\n\tWCN36XX_CFG_VAL(DYNAMIC_THRESHOLD_TWO, 15),\n\tWCN36XX_CFG_VAL(FIXED_RATE, 0),\n\tWCN36XX_CFG_VAL(RETRYRATE_POLICY, 4),\n\tWCN36XX_CFG_VAL(RETRYRATE_SECONDARY, 0),\n\tWCN36XX_CFG_VAL(RETRYRATE_TERTIARY, 0),\n\tWCN36XX_CFG_VAL(FORCE_POLICY_PROTECTION, 5),\n\tWCN36XX_CFG_VAL(FIXED_RATE_MULTICAST_24GHZ, 1),\n\tWCN36XX_CFG_VAL(FIXED_RATE_MULTICAST_5GHZ, 5),\n\tWCN36XX_CFG_VAL(DEFAULT_RATE_INDEX_5GHZ, 5),\n\tWCN36XX_CFG_VAL(MAX_BA_SESSIONS, 40),\n\tWCN36XX_CFG_VAL(PS_DATA_INACTIVITY_TIMEOUT, 200),\n\tWCN36XX_CFG_VAL(PS_ENABLE_BCN_FILTER, 1),\n\tWCN36XX_CFG_VAL(PS_ENABLE_RSSI_MONITOR, 1),\n\tWCN36XX_CFG_VAL(NUM_BEACON_PER_RSSI_AVERAGE, 20),\n\tWCN36XX_CFG_VAL(STATS_PERIOD, 10),\n\tWCN36XX_CFG_VAL(CFP_MAX_DURATION, 30000),\n\tWCN36XX_CFG_VAL(FRAME_TRANS_ENABLED, 0),\n\tWCN36XX_CFG_VAL(BA_THRESHOLD_HIGH, 128),\n\tWCN36XX_CFG_VAL(MAX_BA_BUFFERS, 2560),\n\tWCN36XX_CFG_VAL(DYNAMIC_PS_POLL_VALUE, 0),\n\tWCN36XX_CFG_VAL(TX_PWR_CTRL_ENABLE, 1),\n\tWCN36XX_CFG_VAL(ENABLE_CLOSE_LOOP, 1),\n\tWCN36XX_CFG_VAL(ENABLE_LPWR_IMG_TRANSITION, 0),\n\tWCN36XX_CFG_VAL(BTC_STATIC_LEN_LE_BT, 120000),\n\tWCN36XX_CFG_VAL(BTC_STATIC_LEN_LE_WLAN, 30000),\n\tWCN36XX_CFG_VAL(MAX_ASSOC_LIMIT, 10),\n\tWCN36XX_CFG_VAL(ENABLE_MCC_ADAPTIVE_SCHEDULER, 0),\n\tWCN36XX_CFG_VAL(ENABLE_DYNAMIC_RA_START_RATE, 133),  \n\tWCN36XX_CFG_VAL(LINK_FAIL_TX_CNT, 1000),\n};\n\nstatic struct wcn36xx_cfg_val wcn3680_cfg_vals[] = {\n\tWCN36XX_CFG_VAL(CURRENT_TX_ANTENNA, 1),\n\tWCN36XX_CFG_VAL(CURRENT_RX_ANTENNA, 1),\n\tWCN36XX_CFG_VAL(LOW_GAIN_OVERRIDE, 0),\n\tWCN36XX_CFG_VAL(POWER_STATE_PER_CHAIN, 785),\n\tWCN36XX_CFG_VAL(CAL_PERIOD, 5),\n\tWCN36XX_CFG_VAL(CAL_CONTROL, 1),\n\tWCN36XX_CFG_VAL(PROXIMITY, 0),\n\tWCN36XX_CFG_VAL(NETWORK_DENSITY, 3),\n\tWCN36XX_CFG_VAL(MAX_MEDIUM_TIME, 4096),\n\tWCN36XX_CFG_VAL(MAX_MPDUS_IN_AMPDU, 64),\n\tWCN36XX_CFG_VAL(RTS_THRESHOLD, 2347),\n\tWCN36XX_CFG_VAL(SHORT_RETRY_LIMIT, 15),\n\tWCN36XX_CFG_VAL(LONG_RETRY_LIMIT, 15),\n\tWCN36XX_CFG_VAL(FRAGMENTATION_THRESHOLD, 8000),\n\tWCN36XX_CFG_VAL(DYNAMIC_THRESHOLD_ZERO, 5),\n\tWCN36XX_CFG_VAL(DYNAMIC_THRESHOLD_ONE, 10),\n\tWCN36XX_CFG_VAL(DYNAMIC_THRESHOLD_TWO, 15),\n\tWCN36XX_CFG_VAL(FIXED_RATE, 0),\n\tWCN36XX_CFG_VAL(RETRYRATE_POLICY, 4),\n\tWCN36XX_CFG_VAL(RETRYRATE_SECONDARY, 0),\n\tWCN36XX_CFG_VAL(RETRYRATE_TERTIARY, 0),\n\tWCN36XX_CFG_VAL(FORCE_POLICY_PROTECTION, 5),\n\tWCN36XX_CFG_VAL(FIXED_RATE_MULTICAST_24GHZ, 1),\n\tWCN36XX_CFG_VAL(FIXED_RATE_MULTICAST_5GHZ, 5),\n\tWCN36XX_CFG_VAL(DEFAULT_RATE_INDEX_24GHZ, 1),\n\tWCN36XX_CFG_VAL(DEFAULT_RATE_INDEX_5GHZ, 5),\n\tWCN36XX_CFG_VAL(MAX_BA_SESSIONS, 40),\n\tWCN36XX_CFG_VAL(PS_DATA_INACTIVITY_TIMEOUT, 200),\n\tWCN36XX_CFG_VAL(PS_ENABLE_BCN_FILTER, 1),\n\tWCN36XX_CFG_VAL(PS_ENABLE_RSSI_MONITOR, 1),\n\tWCN36XX_CFG_VAL(NUM_BEACON_PER_RSSI_AVERAGE, 20),\n\tWCN36XX_CFG_VAL(STATS_PERIOD, 10),\n\tWCN36XX_CFG_VAL(CFP_MAX_DURATION, 30000),\n\tWCN36XX_CFG_VAL(FRAME_TRANS_ENABLED, 0),\n\tWCN36XX_CFG_VAL(BA_THRESHOLD_HIGH, 128),\n\tWCN36XX_CFG_VAL(MAX_BA_BUFFERS, 2560),\n\tWCN36XX_CFG_VAL(DYNAMIC_PS_POLL_VALUE, 0),\n\tWCN36XX_CFG_VAL(TX_PWR_CTRL_ENABLE, 1),\n\tWCN36XX_CFG_VAL(ENABLE_CLOSE_LOOP, 1),\n\tWCN36XX_CFG_VAL(ENABLE_LPWR_IMG_TRANSITION, 0),\n\tWCN36XX_CFG_VAL(BTC_STATIC_LEN_LE_BT, 120000),\n\tWCN36XX_CFG_VAL(BTC_STATIC_LEN_LE_WLAN, 30000),\n\tWCN36XX_CFG_VAL(MAX_ASSOC_LIMIT, 10),\n\tWCN36XX_CFG_VAL(ENABLE_MCC_ADAPTIVE_SCHEDULER, 0),\n\tWCN36XX_CFG_VAL(TDLS_PUAPSD_MASK, 0),\n\tWCN36XX_CFG_VAL(TDLS_PUAPSD_BUFFER_STA_CAPABLE, 1),\n\tWCN36XX_CFG_VAL(TDLS_PUAPSD_INACTIVITY_TIME, 0),\n\tWCN36XX_CFG_VAL(TDLS_PUAPSD_RX_FRAME_THRESHOLD, 10),\n\tWCN36XX_CFG_VAL(TDLS_OFF_CHANNEL_CAPABLE, 1),\n\tWCN36XX_CFG_VAL(ENABLE_ADAPTIVE_RX_DRAIN, 1),\n\tWCN36XX_CFG_VAL(FLEXCONNECT_POWER_FACTOR, 0),\n\tWCN36XX_CFG_VAL(ANTENNA_DIVERSITY, 3),\n\tWCN36XX_CFG_VAL(ATH_DISABLE, 0),\n\tWCN36XX_CFG_VAL(BTC_STATIC_OPP_WLAN_ACTIVE_WLAN_LEN, 60000),\n\tWCN36XX_CFG_VAL(BTC_STATIC_OPP_WLAN_ACTIVE_BT_LEN, 90000),\n\tWCN36XX_CFG_VAL(BTC_SAP_STATIC_OPP_ACTIVE_WLAN_LEN, 30000),\n\tWCN36XX_CFG_VAL(BTC_SAP_STATIC_OPP_ACTIVE_BT_LEN, 30000),\n\tWCN36XX_CFG_VAL(ASD_PROBE_INTERVAL, 50),\n\tWCN36XX_CFG_VAL(ASD_TRIGGER_THRESHOLD, -60),\n\tWCN36XX_CFG_VAL(ASD_RTT_RSSI_HYST_THRESHOLD, 3),\n\tWCN36XX_CFG_VAL(BTC_CTS2S_ON_STA_DURING_SCO, 0),\n\tWCN36XX_CFG_VAL(RA_FILTER_ENABLE, 0),\n\tWCN36XX_CFG_VAL(RA_RATE_LIMIT_INTERVAL, 60),\n\tWCN36XX_CFG_VAL(BTC_FATAL_HID_NSNIFF_BLK, 2),\n\tWCN36XX_CFG_VAL(BTC_CRITICAL_HID_NSNIFF_BLK, 1),\n\tWCN36XX_CFG_VAL(BTC_DYN_A2DP_TX_QUEUE_THOLD, 0),\n\tWCN36XX_CFG_VAL(BTC_DYN_OPP_TX_QUEUE_THOLD, 1),\n\tWCN36XX_CFG_VAL(MAX_UAPSD_CONSEC_SP, 10),\n\tWCN36XX_CFG_VAL(MAX_UAPSD_CONSEC_RX_CNT, 50),\n\tWCN36XX_CFG_VAL(MAX_UAPSD_CONSEC_TX_CNT, 50),\n\tWCN36XX_CFG_VAL(MAX_UAPSD_CONSEC_TX_CNT_MEAS_WINDOW, 500),\n\tWCN36XX_CFG_VAL(MAX_UAPSD_CONSEC_RX_CNT_MEAS_WINDOW, 500),\n\tWCN36XX_CFG_VAL(MAX_PSPOLL_IN_WMM_UAPSD_PS_MODE, 0),\n\tWCN36XX_CFG_VAL(MAX_UAPSD_INACTIVITY_INTERVALS, 10),\n\tWCN36XX_CFG_VAL(ENABLE_DYNAMIC_WMMPS, 1),\n\tWCN36XX_CFG_VAL(BURST_MODE_BE_TXOP_VALUE, 0),\n\tWCN36XX_CFG_VAL(ENABLE_DYNAMIC_RA_START_RATE, 136),\n\tWCN36XX_CFG_VAL(BTC_FAST_WLAN_CONN_PREF, 1),\n\tWCN36XX_CFG_VAL(ENABLE_RTSCTS_HTVHT, 0),\n\tWCN36XX_CFG_VAL(BTC_STATIC_OPP_WLAN_IDLE_WLAN_LEN, 30000),\n\tWCN36XX_CFG_VAL(BTC_STATIC_OPP_WLAN_IDLE_BT_LEN, 120000),\n\tWCN36XX_CFG_VAL(LINK_FAIL_TX_CNT, 1000),\n\tWCN36XX_CFG_VAL(TOGGLE_ARP_BDRATES, 0),\n\tWCN36XX_CFG_VAL(OPTIMIZE_CA_EVENT, 0),\n\tWCN36XX_CFG_VAL(EXT_SCAN_CONC_MODE, 0),\n\tWCN36XX_CFG_VAL(BAR_WAKEUP_HOST_DISABLE, 0),\n\tWCN36XX_CFG_VAL(SAR_BOFFSET_CORRECTION_ENABLE, 0),\n\tWCN36XX_CFG_VAL(BTC_DISABLE_WLAN_LINK_CRITICAL, 5),\n\tWCN36XX_CFG_VAL(DISABLE_SCAN_DURING_SCO, 2),\n\tWCN36XX_CFG_VAL(CONS_BCNMISS_COUNT, 0),\n\tWCN36XX_CFG_VAL(UNITS_OF_BCN_WAIT_TIME, 0),\n\tWCN36XX_CFG_VAL(TRIGGER_NULLFRAME_BEFORE_HB, 0),\n\tWCN36XX_CFG_VAL(ENABLE_POWERSAVE_OFFLOAD, 0),\n};\n\nstatic int put_cfg_tlv_u32(struct wcn36xx *wcn, size_t *len, u32 id, u32 value)\n{\n\tstruct wcn36xx_hal_cfg *entry;\n\tu32 *val;\n\n\tif (*len + sizeof(*entry) + sizeof(u32) >= WCN36XX_HAL_BUF_SIZE) {\n\t\twcn36xx_err(\"Not enough room for TLV entry\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tentry = (struct wcn36xx_hal_cfg *) (wcn->hal_buf + *len);\n\tentry->id = id;\n\tentry->len = sizeof(u32);\n\tentry->pad_bytes = 0;\n\tentry->reserve = 0;\n\n\tval = (u32 *) (entry + 1);\n\t*val = value;\n\n\t*len += sizeof(*entry) + sizeof(u32);\n\n\treturn 0;\n}\n\nstatic void wcn36xx_smd_set_bss_nw_type(struct wcn36xx *wcn,\n\t\tstruct ieee80211_sta *sta,\n\t\tstruct wcn36xx_hal_config_bss_params *bss_params)\n{\n\tif (NL80211_BAND_5GHZ == WCN36XX_BAND(wcn))\n\t\tbss_params->nw_type = WCN36XX_HAL_11A_NW_TYPE;\n\telse if (sta && sta->deflink.ht_cap.ht_supported)\n\t\tbss_params->nw_type = WCN36XX_HAL_11N_NW_TYPE;\n\telse if (sta && (sta->deflink.supp_rates[NL80211_BAND_2GHZ] & 0x7f))\n\t\tbss_params->nw_type = WCN36XX_HAL_11G_NW_TYPE;\n\telse\n\t\tbss_params->nw_type = WCN36XX_HAL_11B_NW_TYPE;\n}\n\nstatic inline u8 is_cap_supported(unsigned long caps, unsigned long flag)\n{\n\treturn caps & flag ? 1 : 0;\n}\n\nstatic void wcn36xx_smd_set_bss_ht_params(struct ieee80211_vif *vif,\n\t\tstruct ieee80211_sta *sta,\n\t\tstruct wcn36xx_hal_config_bss_params *bss_params)\n{\n\tif (sta && sta->deflink.ht_cap.ht_supported) {\n\t\tunsigned long caps = sta->deflink.ht_cap.cap;\n\n\t\tbss_params->ht = sta->deflink.ht_cap.ht_supported;\n\t\tbss_params->tx_channel_width_set = is_cap_supported(caps,\n\t\t\tIEEE80211_HT_CAP_SUP_WIDTH_20_40);\n\t\tbss_params->lsig_tx_op_protection_full_support =\n\t\t\tis_cap_supported(caps,\n\t\t\t\t\t IEEE80211_HT_CAP_LSIG_TXOP_PROT);\n\n\t\tbss_params->ht_oper_mode = vif->bss_conf.ht_operation_mode;\n\t\tbss_params->lln_non_gf_coexist =\n\t\t\t!!(vif->bss_conf.ht_operation_mode &\n\t\t\t   IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT);\n\t\t \n\t\tbss_params->dual_cts_protection = 0;\n\t\t \n\t\tbss_params->ht20_coexist = 0;\n\t}\n}\n\nstatic void\nwcn36xx_smd_set_bss_vht_params(struct ieee80211_vif *vif,\n\t\t\t       struct ieee80211_sta *sta,\n\t\t\t       struct wcn36xx_hal_config_bss_params_v1 *bss)\n{\n\tif (sta && sta->deflink.vht_cap.vht_supported)\n\t\tbss->vht_capable = 1;\n}\n\nstatic void wcn36xx_smd_set_sta_ht_params(struct ieee80211_sta *sta,\n\t\tstruct wcn36xx_hal_config_sta_params *sta_params)\n{\n\tif (sta->deflink.ht_cap.ht_supported) {\n\t\tunsigned long caps = sta->deflink.ht_cap.cap;\n\n\t\tsta_params->ht_capable = sta->deflink.ht_cap.ht_supported;\n\t\tsta_params->tx_channel_width_set = is_cap_supported(caps,\n\t\t\tIEEE80211_HT_CAP_SUP_WIDTH_20_40);\n\t\tsta_params->lsig_txop_protection = is_cap_supported(caps,\n\t\t\tIEEE80211_HT_CAP_LSIG_TXOP_PROT);\n\n\t\tsta_params->max_ampdu_size = sta->deflink.ht_cap.ampdu_factor;\n\t\tsta_params->max_ampdu_density = sta->deflink.ht_cap.ampdu_density;\n\t\t \n\t\tsta_params->max_amsdu_size = !is_cap_supported(caps,\n\t\t\tIEEE80211_HT_CAP_MAX_AMSDU);\n\t\tsta_params->sgi_20Mhz = is_cap_supported(caps,\n\t\t\tIEEE80211_HT_CAP_SGI_20);\n\t\tsta_params->sgi_40mhz =\tis_cap_supported(caps,\n\t\t\tIEEE80211_HT_CAP_SGI_40);\n\t\tsta_params->green_field_capable = is_cap_supported(caps,\n\t\t\tIEEE80211_HT_CAP_GRN_FLD);\n\t\tsta_params->delayed_ba_support = is_cap_supported(caps,\n\t\t\tIEEE80211_HT_CAP_DELAY_BA);\n\t\tsta_params->dsss_cck_mode_40mhz = is_cap_supported(caps,\n\t\t\tIEEE80211_HT_CAP_DSSSCCK40);\n\t}\n}\n\nstatic void wcn36xx_smd_set_sta_vht_params(struct wcn36xx *wcn,\n\t\tstruct ieee80211_sta *sta,\n\t\tstruct wcn36xx_hal_config_sta_params_v1 *sta_params)\n{\n\tif (sta->deflink.vht_cap.vht_supported) {\n\t\tunsigned long caps = sta->deflink.vht_cap.cap;\n\n\t\tsta_params->vht_capable = sta->deflink.vht_cap.vht_supported;\n\t\tsta_params->vht_ldpc_enabled =\n\t\t\tis_cap_supported(caps, IEEE80211_VHT_CAP_RXLDPC);\n\t\tif (wcn36xx_firmware_get_feat_caps(wcn->fw_feat_caps, MU_MIMO)) {\n\t\t\tsta_params->vht_tx_mu_beamformee_capable =\n\t\t\t\tis_cap_supported(caps, IEEE80211_VHT_CAP_MU_BEAMFORMER_CAPABLE);\n\t\t\tif (sta_params->vht_tx_mu_beamformee_capable)\n\t\t\t       sta_params->vht_tx_bf_enabled = 1;\n\t\t} else {\n\t\t\tsta_params->vht_tx_mu_beamformee_capable = 0;\n\t\t}\n\t\tsta_params->vht_tx_channel_width_set = 0;\n\t}\n}\n\nstatic void wcn36xx_smd_set_sta_ht_ldpc_params(struct ieee80211_sta *sta,\n\t\tstruct wcn36xx_hal_config_sta_params_v1 *sta_params)\n{\n\tif (sta->deflink.ht_cap.ht_supported) {\n\t\tsta_params->ht_ldpc_enabled =\n\t\t\tis_cap_supported(sta->deflink.ht_cap.cap,\n\t\t\t\t\t IEEE80211_HT_CAP_LDPC_CODING);\n\t}\n}\n\nstatic void wcn36xx_smd_set_sta_default_ht_params(\n\t\tstruct wcn36xx_hal_config_sta_params *sta_params)\n{\n\tsta_params->ht_capable = 1;\n\tsta_params->tx_channel_width_set = 1;\n\tsta_params->lsig_txop_protection = 1;\n\tsta_params->max_ampdu_size = 3;\n\tsta_params->max_ampdu_density = 5;\n\tsta_params->max_amsdu_size = 0;\n\tsta_params->sgi_20Mhz = 1;\n\tsta_params->sgi_40mhz = 1;\n\tsta_params->green_field_capable = 1;\n\tsta_params->delayed_ba_support = 0;\n\tsta_params->dsss_cck_mode_40mhz = 1;\n}\n\nstatic void wcn36xx_smd_set_sta_default_vht_params(struct wcn36xx *wcn,\n\t\tstruct wcn36xx_hal_config_sta_params_v1 *sta_params)\n{\n\tif (wcn->rf_id == RF_IRIS_WCN3680) {\n\t\tsta_params->vht_capable = 1;\n\t\tsta_params->vht_tx_mu_beamformee_capable = 1;\n\t} else {\n\t\tsta_params->vht_capable = 0;\n\t\tsta_params->vht_tx_mu_beamformee_capable = 0;\n\t}\n\n\tsta_params->vht_ldpc_enabled = 0;\n\tsta_params->vht_tx_channel_width_set = 0;\n\tsta_params->vht_tx_bf_enabled = 0;\n}\n\nstatic void wcn36xx_smd_set_sta_default_ht_ldpc_params(struct wcn36xx *wcn,\n\t\tstruct wcn36xx_hal_config_sta_params_v1 *sta_params)\n{\n\tif (wcn->rf_id == RF_IRIS_WCN3680)\n\t\tsta_params->ht_ldpc_enabled = 1;\n\telse\n\t\tsta_params->ht_ldpc_enabled = 0;\n}\n\nstatic void wcn36xx_smd_set_sta_params(struct wcn36xx *wcn,\n\t\tstruct ieee80211_vif *vif,\n\t\tstruct ieee80211_sta *sta,\n\t\tstruct wcn36xx_hal_config_sta_params *sta_params)\n{\n\tstruct wcn36xx_vif *vif_priv = wcn36xx_vif_to_priv(vif);\n\tstruct wcn36xx_sta *sta_priv = NULL;\n\tif (vif->type == NL80211_IFTYPE_ADHOC ||\n\t    vif->type == NL80211_IFTYPE_AP ||\n\t    vif->type == NL80211_IFTYPE_MESH_POINT) {\n\t\tsta_params->type = 1;\n\t\tsta_params->sta_index = WCN36XX_HAL_STA_INVALID_IDX;\n\t} else {\n\t\tsta_params->type = 0;\n\t\tsta_params->sta_index = vif_priv->self_sta_index;\n\t}\n\n\tsta_params->listen_interval = WCN36XX_LISTEN_INTERVAL(wcn);\n\n\t \n\tif (NL80211_IFTYPE_STATION == vif->type)\n\t\tmemcpy(&sta_params->mac, vif->addr, ETH_ALEN);\n\telse\n\t\tmemcpy(&sta_params->bssid, vif->addr, ETH_ALEN);\n\n\tsta_params->encrypt_type = vif_priv->encrypt_type;\n\tsta_params->short_preamble_supported = true;\n\n\tsta_params->rifs_mode = 0;\n\tsta_params->rmf = 0;\n\tsta_params->action = 0;\n\tsta_params->uapsd = 0;\n\tsta_params->mimo_ps = WCN36XX_HAL_HT_MIMO_PS_STATIC;\n\tsta_params->max_ampdu_duration = 0;\n\tsta_params->bssid_index = vif_priv->bss_index;\n\tsta_params->p2p = 0;\n\n\tif (sta) {\n\t\tsta_priv = wcn36xx_sta_to_priv(sta);\n\t\tif (NL80211_IFTYPE_STATION == vif->type)\n\t\t\tmemcpy(&sta_params->bssid, sta->addr, ETH_ALEN);\n\t\telse\n\t\t\tmemcpy(&sta_params->mac, sta->addr, ETH_ALEN);\n\t\tsta_params->wmm_enabled = sta->wme;\n\t\tsta_params->max_sp_len = sta->max_sp;\n\t\tsta_params->aid = sta_priv->aid;\n\t\twcn36xx_smd_set_sta_ht_params(sta, sta_params);\n\t\tmemcpy(&sta_params->supported_rates, &sta_priv->supported_rates,\n\t\t\tsizeof(struct wcn36xx_hal_supported_rates));\n\t} else {\n\t\twcn36xx_set_default_rates((struct wcn36xx_hal_supported_rates *)\n\t\t\t\t\t  &sta_params->supported_rates);\n\t\twcn36xx_smd_set_sta_default_ht_params(sta_params);\n\t}\n}\n\nstatic int wcn36xx_smd_send_and_wait(struct wcn36xx *wcn, size_t len)\n{\n\tint ret;\n\tunsigned long start;\n\tstruct wcn36xx_hal_msg_header *hdr =\n\t\t(struct wcn36xx_hal_msg_header *)wcn->hal_buf;\n\tu16 req_type = hdr->msg_type;\n\n\twcn36xx_dbg_dump(WCN36XX_DBG_SMD_DUMP, \"HAL >>> \", wcn->hal_buf, len);\n\n\tinit_completion(&wcn->hal_rsp_compl);\n\tstart = jiffies;\n\tret = rpmsg_send(wcn->smd_channel, wcn->hal_buf, len);\n\tif (ret) {\n\t\twcn36xx_err(\"HAL TX failed for req %d\\n\", req_type);\n\t\tgoto out;\n\t}\n\tif (wait_for_completion_timeout(&wcn->hal_rsp_compl,\n\t\tmsecs_to_jiffies(HAL_MSG_TIMEOUT)) <= 0) {\n\t\twcn36xx_err(\"Timeout! No SMD response to req %d in %dms\\n\",\n\t\t\t    req_type, HAL_MSG_TIMEOUT);\n\t\tret = -ETIME;\n\t\tgoto out;\n\t}\n\twcn36xx_dbg(WCN36XX_DBG_SMD,\n\t\t    \"SMD command (req %d, rsp %d) completed in %dms\\n\",\n\t\t    req_type, hdr->msg_type,\n\t\t    jiffies_to_msecs(jiffies - start));\nout:\n\treturn ret;\n}\n\n#define __INIT_HAL_MSG(msg_body, type, version) \\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tmemset(&(msg_body), 0, sizeof(msg_body));\t\t\\\n\t\t(msg_body).header.msg_type = type;\t\t\t\\\n\t\t(msg_body).header.msg_version = version;\t\t\\\n\t\t(msg_body).header.len = sizeof(msg_body);\t\t\\\n\t} while (0)\t\t\t\t\t\t\t\\\n\n#define INIT_HAL_MSG(msg_body, type)\t\\\n\t__INIT_HAL_MSG(msg_body, type, WCN36XX_HAL_MSG_VERSION0)\n\n#define INIT_HAL_MSG_V1(msg_body, type) \\\n\t__INIT_HAL_MSG(msg_body, type, WCN36XX_HAL_MSG_VERSION1)\n\n#define INIT_HAL_PTT_MSG(p_msg_body, ppt_msg_len) \\\n\tdo { \\\n\t\tmemset(p_msg_body, 0, sizeof(*p_msg_body) + ppt_msg_len); \\\n\t\tp_msg_body->header.msg_type = WCN36XX_HAL_PROCESS_PTT_REQ; \\\n\t\tp_msg_body->header.msg_version = WCN36XX_HAL_MSG_VERSION0; \\\n\t\tp_msg_body->header.len = sizeof(*p_msg_body) + ppt_msg_len; \\\n\t} while (0)\n\n#define PREPARE_HAL_BUF(send_buf, msg_body) \\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tmemcpy_and_pad(send_buf, msg_body.header.len,\t\\\n\t\t\t       &msg_body, sizeof(msg_body), 0);\t\\\n\t} while (0)\t\t\t\t\t\t\\\n\n#define PREPARE_HAL_PTT_MSG_BUF(send_buf, p_msg_body) \\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tmemcpy(send_buf, p_msg_body, p_msg_body->header.len); \\\n\t} while (0)\n\nstatic int wcn36xx_smd_rsp_status_check(void *buf, size_t len)\n{\n\tstruct wcn36xx_fw_msg_status_rsp *rsp;\n\n\tif (len < sizeof(struct wcn36xx_hal_msg_header) +\n\t    sizeof(struct wcn36xx_fw_msg_status_rsp))\n\t\treturn -EIO;\n\n\trsp = (struct wcn36xx_fw_msg_status_rsp *)\n\t\t(buf + sizeof(struct wcn36xx_hal_msg_header));\n\n\tif (WCN36XX_FW_MSG_RESULT_SUCCESS != rsp->status)\n\t\treturn rsp->status;\n\n\treturn 0;\n}\n\nint wcn36xx_smd_load_nv(struct wcn36xx *wcn)\n{\n\tstruct nv_data *nv_d;\n\tstruct wcn36xx_hal_nv_img_download_req_msg msg_body;\n\tint fw_bytes_left;\n\tint ret;\n\tu16 fm_offset = 0;\n\n\tif (!wcn->nv) {\n\t\tret = request_firmware(&wcn->nv, wcn->nv_file, wcn->dev);\n\t\tif (ret) {\n\t\t\twcn36xx_err(\"Failed to load nv file %s: %d\\n\",\n\t\t\t\t    wcn->nv_file, ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tnv_d = (struct nv_data *)wcn->nv->data;\n\tINIT_HAL_MSG(msg_body, WCN36XX_HAL_DOWNLOAD_NV_REQ);\n\n\tmsg_body.header.len += WCN36XX_NV_FRAGMENT_SIZE;\n\n\tmsg_body.frag_number = 0;\n\t \n\tmutex_lock(&wcn->hal_mutex);\n\n\tdo {\n\t\tfw_bytes_left = wcn->nv->size - fm_offset - 4;\n\t\tif (fw_bytes_left > WCN36XX_NV_FRAGMENT_SIZE) {\n\t\t\tmsg_body.last_fragment = 0;\n\t\t\tmsg_body.nv_img_buffer_size = WCN36XX_NV_FRAGMENT_SIZE;\n\t\t} else {\n\t\t\tmsg_body.last_fragment = 1;\n\t\t\tmsg_body.nv_img_buffer_size = fw_bytes_left;\n\n\t\t\t \n\t\t\tmsg_body.header.len = sizeof(msg_body) + fw_bytes_left;\n\n\t\t}\n\n\t\t \n\t\tmemcpy(wcn->hal_buf, &msg_body,\tsizeof(msg_body));\n\n\t\t \n\t\tmemcpy(wcn->hal_buf + sizeof(msg_body),\n\t\t       &nv_d->table + fm_offset,\n\t\t       msg_body.nv_img_buffer_size);\n\n\t\tret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t\tret = wcn36xx_smd_rsp_status_check(wcn->hal_buf,\n\t\t\t\t\t\t   wcn->hal_rsp_len);\n\t\tif (ret) {\n\t\t\twcn36xx_err(\"hal_load_nv response failed err=%d\\n\",\n\t\t\t\t    ret);\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tmsg_body.frag_number++;\n\t\tfm_offset += WCN36XX_NV_FRAGMENT_SIZE;\n\n\t} while (msg_body.last_fragment != 1);\n\nout_unlock:\n\tmutex_unlock(&wcn->hal_mutex);\nout:\treturn ret;\n}\n\nstatic int wcn36xx_smd_start_rsp(struct wcn36xx *wcn, void *buf, size_t len)\n{\n\tstruct wcn36xx_hal_mac_start_rsp_msg *rsp;\n\n\tif (len < sizeof(*rsp))\n\t\treturn -EIO;\n\n\trsp = (struct wcn36xx_hal_mac_start_rsp_msg *)buf;\n\n\tif (WCN36XX_FW_MSG_RESULT_SUCCESS != rsp->start_rsp_params.status)\n\t\treturn -EIO;\n\n\tmemcpy(wcn->crm_version, rsp->start_rsp_params.crm_version,\n\t       WCN36XX_HAL_VERSION_LENGTH);\n\tmemcpy(wcn->wlan_version, rsp->start_rsp_params.wlan_version,\n\t       WCN36XX_HAL_VERSION_LENGTH);\n\n\t \n\twcn->crm_version[WCN36XX_HAL_VERSION_LENGTH] = '\\0';\n\twcn->wlan_version[WCN36XX_HAL_VERSION_LENGTH] = '\\0';\n\n\twcn->fw_revision = rsp->start_rsp_params.version.revision;\n\twcn->fw_version = rsp->start_rsp_params.version.version;\n\twcn->fw_minor = rsp->start_rsp_params.version.minor;\n\twcn->fw_major = rsp->start_rsp_params.version.major;\n\n\tif (wcn->first_boot) {\n\t\twcn->first_boot = false;\n\t\twcn36xx_info(\"firmware WLAN version '%s' and CRM version '%s'\\n\",\n\t\t\t     wcn->wlan_version, wcn->crm_version);\n\n\t\twcn36xx_info(\"firmware API %u.%u.%u.%u, %u stations, %u bssids\\n\",\n\t\t\t     wcn->fw_major, wcn->fw_minor,\n\t\t\t     wcn->fw_version, wcn->fw_revision,\n\t\t\t     rsp->start_rsp_params.stations,\n\t\t\t     rsp->start_rsp_params.bssids);\n\t}\n\treturn 0;\n}\n\nint wcn36xx_smd_start(struct wcn36xx *wcn)\n{\n\tstruct wcn36xx_hal_mac_start_req_msg msg_body, *body;\n\tint ret;\n\tint i;\n\tsize_t len;\n\tint cfg_elements;\n\tstatic struct wcn36xx_cfg_val *cfg_vals;\n\n\tmutex_lock(&wcn->hal_mutex);\n\tINIT_HAL_MSG(msg_body, WCN36XX_HAL_START_REQ);\n\n\tmsg_body.params.type = DRIVER_TYPE_PRODUCTION;\n\tmsg_body.params.len = 0;\n\n\tPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\n\n\tbody = (struct wcn36xx_hal_mac_start_req_msg *)wcn->hal_buf;\n\tlen = body->header.len;\n\n\tif (wcn->rf_id == RF_IRIS_WCN3680) {\n\t\tcfg_vals = wcn3680_cfg_vals;\n\t\tcfg_elements = ARRAY_SIZE(wcn3680_cfg_vals);\n\t} else {\n\t\tcfg_vals = wcn36xx_cfg_vals;\n\t\tcfg_elements = ARRAY_SIZE(wcn36xx_cfg_vals);\n\t}\n\n\tfor (i = 0; i < cfg_elements; i++) {\n\t\tret = put_cfg_tlv_u32(wcn, &len, cfg_vals[i].cfg_id,\n\t\t\t\t      cfg_vals[i].value);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tbody->header.len = len;\n\tbody->params.len = len - sizeof(*body);\n\n\twcn36xx_dbg(WCN36XX_DBG_HAL, \"hal start type %d\\n\",\n\t\t    msg_body.params.type);\n\n\tret = wcn36xx_smd_send_and_wait(wcn, body->header.len);\n\tif (ret) {\n\t\twcn36xx_err(\"Sending hal_start failed\\n\");\n\t\tgoto out;\n\t}\n\n\tret = wcn36xx_smd_start_rsp(wcn, wcn->hal_buf, wcn->hal_rsp_len);\n\tif (ret) {\n\t\twcn36xx_err(\"hal_start response failed err=%d\\n\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tmutex_unlock(&wcn->hal_mutex);\n\treturn ret;\n}\n\nint wcn36xx_smd_stop(struct wcn36xx *wcn)\n{\n\tstruct wcn36xx_hal_mac_stop_req_msg msg_body;\n\tint ret;\n\n\tmutex_lock(&wcn->hal_mutex);\n\tINIT_HAL_MSG(msg_body, WCN36XX_HAL_STOP_REQ);\n\n\tmsg_body.stop_req_params.reason = HAL_STOP_TYPE_RF_KILL;\n\n\tPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\n\n\tret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\n\tif (ret) {\n\t\twcn36xx_err(\"Sending hal_stop failed\\n\");\n\t\tgoto out;\n\t}\n\tret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\n\tif (ret) {\n\t\twcn36xx_err(\"hal_stop response failed err=%d\\n\", ret);\n\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&wcn->hal_mutex);\n\treturn ret;\n}\n\nint wcn36xx_smd_init_scan(struct wcn36xx *wcn, enum wcn36xx_hal_sys_mode mode,\n\t\t\t  struct ieee80211_vif *vif)\n{\n\tstruct wcn36xx_vif *vif_priv = wcn36xx_vif_to_priv(vif);\n\tstruct wcn36xx_hal_init_scan_req_msg msg_body;\n\tint ret;\n\n\tmutex_lock(&wcn->hal_mutex);\n\tINIT_HAL_MSG(msg_body, WCN36XX_HAL_INIT_SCAN_REQ);\n\n\tmsg_body.mode = mode;\n\tif (vif_priv->bss_index != WCN36XX_HAL_BSS_INVALID_IDX) {\n\t\t \n\t\tmsg_body.frame_type = 2;\n\t\tmsg_body.notify = 1;\n\t\tmsg_body.scan_entry.bss_index[0] = vif_priv->bss_index;\n\t\tmsg_body.scan_entry.active_bss_count = 1;\n\t}\n\n\tPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\n\n\twcn36xx_dbg(WCN36XX_DBG_HAL, \"hal init scan mode %d\\n\", msg_body.mode);\n\n\tret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\n\tif (ret) {\n\t\twcn36xx_err(\"Sending hal_init_scan failed\\n\");\n\t\tgoto out;\n\t}\n\tret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\n\tif (ret) {\n\t\twcn36xx_err(\"hal_init_scan response failed err=%d\\n\", ret);\n\t\tgoto out;\n\t}\n\twcn->sw_scan_init = true;\nout:\n\tmutex_unlock(&wcn->hal_mutex);\n\treturn ret;\n}\n\nint wcn36xx_smd_start_scan(struct wcn36xx *wcn, u8 scan_channel)\n{\n\tstruct wcn36xx_hal_start_scan_req_msg msg_body;\n\tint ret;\n\n\tmutex_lock(&wcn->hal_mutex);\n\tINIT_HAL_MSG(msg_body, WCN36XX_HAL_START_SCAN_REQ);\n\n\tmsg_body.scan_channel = scan_channel;\n\n\tPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\n\n\twcn36xx_dbg(WCN36XX_DBG_HAL, \"hal start scan channel %d\\n\",\n\t\t    msg_body.scan_channel);\n\n\tret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\n\tif (ret) {\n\t\twcn36xx_err(\"Sending hal_start_scan failed\\n\");\n\t\tgoto out;\n\t}\n\tret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\n\tif (ret) {\n\t\twcn36xx_err(\"hal_start_scan response failed err=%d\\n\", ret);\n\t\tgoto out;\n\t}\n\twcn->sw_scan_channel = scan_channel;\nout:\n\tmutex_unlock(&wcn->hal_mutex);\n\treturn ret;\n}\n\nint wcn36xx_smd_end_scan(struct wcn36xx *wcn, u8 scan_channel)\n{\n\tstruct wcn36xx_hal_end_scan_req_msg msg_body;\n\tint ret;\n\n\tmutex_lock(&wcn->hal_mutex);\n\tINIT_HAL_MSG(msg_body, WCN36XX_HAL_END_SCAN_REQ);\n\n\tmsg_body.scan_channel = scan_channel;\n\n\tPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\n\n\twcn36xx_dbg(WCN36XX_DBG_HAL, \"hal end scan channel %d\\n\",\n\t\t    msg_body.scan_channel);\n\n\tret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\n\tif (ret) {\n\t\twcn36xx_err(\"Sending hal_end_scan failed\\n\");\n\t\tgoto out;\n\t}\n\tret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\n\tif (ret) {\n\t\twcn36xx_err(\"hal_end_scan response failed err=%d\\n\", ret);\n\t\tgoto out;\n\t}\n\twcn->sw_scan_channel = 0;\nout:\n\tmutex_unlock(&wcn->hal_mutex);\n\treturn ret;\n}\n\nint wcn36xx_smd_finish_scan(struct wcn36xx *wcn,\n\t\t\t    enum wcn36xx_hal_sys_mode mode,\n\t\t\t    struct ieee80211_vif *vif)\n{\n\tstruct wcn36xx_vif *vif_priv = wcn36xx_vif_to_priv(vif);\n\tstruct wcn36xx_hal_finish_scan_req_msg msg_body;\n\tint ret;\n\n\tmutex_lock(&wcn->hal_mutex);\n\tINIT_HAL_MSG(msg_body, WCN36XX_HAL_FINISH_SCAN_REQ);\n\n\tmsg_body.mode = mode;\n\tmsg_body.oper_channel = WCN36XX_HW_CHANNEL(wcn);\n\tif (vif_priv->bss_index != WCN36XX_HAL_BSS_INVALID_IDX) {\n\t\t \n\t\tmsg_body.notify = 1;\n\t\tmsg_body.frame_type = 2;\n\t\tmsg_body.scan_entry.bss_index[0] = vif_priv->bss_index;\n\t\tmsg_body.scan_entry.active_bss_count = 1;\n\t}\n\n\tPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\n\n\twcn36xx_dbg(WCN36XX_DBG_HAL, \"hal finish scan mode %d\\n\",\n\t\t    msg_body.mode);\n\n\tret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\n\tif (ret) {\n\t\twcn36xx_err(\"Sending hal_finish_scan failed\\n\");\n\t\tgoto out;\n\t}\n\tret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\n\tif (ret) {\n\t\twcn36xx_err(\"hal_finish_scan response failed err=%d\\n\", ret);\n\t\tgoto out;\n\t}\n\twcn->sw_scan_init = false;\nout:\n\tmutex_unlock(&wcn->hal_mutex);\n\treturn ret;\n}\n\nint wcn36xx_smd_start_hw_scan(struct wcn36xx *wcn, struct ieee80211_vif *vif,\n\t\t\t      struct cfg80211_scan_request *req)\n{\n\tstruct wcn36xx_vif *vif_priv = wcn36xx_vif_to_priv(vif);\n\tstruct wcn36xx_hal_start_scan_offload_req_msg *msg_body;\n\tint ret, i;\n\n\tif (req->ie_len > WCN36XX_MAX_SCAN_IE_LEN)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&wcn->hal_mutex);\n\tmsg_body = kzalloc(sizeof(*msg_body), GFP_KERNEL);\n\tif (!msg_body) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tINIT_HAL_MSG((*msg_body), WCN36XX_HAL_START_SCAN_OFFLOAD_REQ);\n\n\tmsg_body->scan_type = WCN36XX_HAL_SCAN_TYPE_ACTIVE;\n\tmsg_body->min_ch_time = 30;\n\tmsg_body->max_ch_time = 100;\n\tmsg_body->scan_hidden = 1;\n\tmemcpy(msg_body->mac, vif->addr, ETH_ALEN);\n\tmsg_body->bss_type = vif_priv->bss_type;\n\tmsg_body->p2p_search = vif->p2p;\n\n\tmsg_body->num_ssid = min_t(u8, req->n_ssids, ARRAY_SIZE(msg_body->ssids));\n\tfor (i = 0; i < msg_body->num_ssid; i++) {\n\t\tmsg_body->ssids[i].length = min_t(u8, req->ssids[i].ssid_len,\n\t\t\t\t\t\tsizeof(msg_body->ssids[i].ssid));\n\t\tmemcpy(msg_body->ssids[i].ssid, req->ssids[i].ssid,\n\t\t       msg_body->ssids[i].length);\n\t}\n\n\tmsg_body->num_channel = min_t(u8, req->n_channels,\n\t\t\t\t     sizeof(msg_body->channels));\n\tfor (i = 0; i < msg_body->num_channel; i++) {\n\t\tmsg_body->channels[i] =\n\t\t\tHW_VALUE_CHANNEL(req->channels[i]->hw_value);\n\t}\n\n\tmsg_body->header.len -= WCN36XX_MAX_SCAN_IE_LEN;\n\n\tif (req->ie_len > 0) {\n\t\tmsg_body->ie_len = req->ie_len;\n\t\tmsg_body->header.len += req->ie_len;\n\t\tmemcpy(msg_body->ie, req->ie, req->ie_len);\n\t}\n\n\tPREPARE_HAL_BUF(wcn->hal_buf, (*msg_body));\n\n\twcn36xx_dbg(WCN36XX_DBG_HAL,\n\t\t    \"hal start hw-scan (channels: %u; ssids: %u; p2p: %s)\\n\",\n\t\t    msg_body->num_channel, msg_body->num_ssid,\n\t\t    msg_body->p2p_search ? \"yes\" : \"no\");\n\n\tret = wcn36xx_smd_send_and_wait(wcn, msg_body->header.len);\n\tif (ret) {\n\t\twcn36xx_err(\"Sending hal_start_scan_offload failed\\n\");\n\t\tgoto out;\n\t}\n\tret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\n\tif (ret) {\n\t\twcn36xx_err(\"hal_start_scan_offload response failed err=%d\\n\",\n\t\t\t    ret);\n\t\tgoto out;\n\t}\nout:\n\tkfree(msg_body);\n\tmutex_unlock(&wcn->hal_mutex);\n\treturn ret;\n}\n\nint wcn36xx_smd_stop_hw_scan(struct wcn36xx *wcn)\n{\n\tstruct wcn36xx_hal_stop_scan_offload_req_msg msg_body;\n\tint ret;\n\n\tmutex_lock(&wcn->hal_mutex);\n\tINIT_HAL_MSG(msg_body, WCN36XX_HAL_STOP_SCAN_OFFLOAD_REQ);\n\tPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\n\n\twcn36xx_dbg(WCN36XX_DBG_HAL, \"hal stop hw-scan\\n\");\n\n\tret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\n\tif (ret) {\n\t\twcn36xx_err(\"Sending hal_stop_scan_offload failed\\n\");\n\t\tgoto out;\n\t}\n\tret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\n\tif (ret) {\n\t\twcn36xx_err(\"hal_stop_scan_offload response failed err=%d\\n\",\n\t\t\t    ret);\n\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&wcn->hal_mutex);\n\treturn ret;\n}\n\nint wcn36xx_smd_update_channel_list(struct wcn36xx *wcn, struct cfg80211_scan_request *req)\n{\n\tstruct wcn36xx_hal_update_channel_list_req_msg *msg_body;\n\tint ret, i;\n\n\tmsg_body = kzalloc(sizeof(*msg_body), GFP_KERNEL);\n\tif (!msg_body)\n\t\treturn -ENOMEM;\n\n\tINIT_HAL_MSG((*msg_body), WCN36XX_HAL_UPDATE_CHANNEL_LIST_REQ);\n\n\tmsg_body->num_channel = min_t(u8, req->n_channels, ARRAY_SIZE(msg_body->channels));\n\tfor (i = 0; i < msg_body->num_channel; i++) {\n\t\tstruct wcn36xx_hal_channel_param *param = &msg_body->channels[i];\n\t\tu32 min_power = WCN36XX_HAL_DEFAULT_MIN_POWER;\n\t\tu32 ant_gain = WCN36XX_HAL_DEFAULT_ANT_GAIN;\n\n\t\tparam->mhz = req->channels[i]->center_freq;\n\t\tparam->band_center_freq1 = req->channels[i]->center_freq;\n\t\tparam->band_center_freq2 = 0;\n\n\t\tif (req->channels[i]->flags & IEEE80211_CHAN_NO_IR)\n\t\t\tparam->channel_info |= WCN36XX_HAL_CHAN_INFO_FLAG_PASSIVE;\n\n\t\tif (req->channels[i]->flags & IEEE80211_CHAN_RADAR)\n\t\t\tparam->channel_info |= WCN36XX_HAL_CHAN_INFO_FLAG_DFS;\n\n\t\tif (req->channels[i]->band == NL80211_BAND_5GHZ) {\n\t\t\tparam->channel_info |= WCN36XX_HAL_CHAN_INFO_FLAG_HT;\n\t\t\tparam->channel_info |= WCN36XX_HAL_CHAN_INFO_FLAG_VHT;\n\t\t\tparam->channel_info |= WCN36XX_HAL_CHAN_INFO_PHY_11A;\n\t\t} else {\n\t\t\tparam->channel_info |= WCN36XX_HAL_CHAN_INFO_PHY_11BG;\n\t\t}\n\n\t\tif (min_power > req->channels[i]->max_power)\n\t\t\tmin_power = req->channels[i]->max_power;\n\n\t\tif (req->channels[i]->max_antenna_gain)\n\t\t\tant_gain = req->channels[i]->max_antenna_gain;\n\n\t\tu32p_replace_bits(&param->reg_info_1, min_power,\n\t\t\t\t  WCN36XX_HAL_CHAN_REG1_MIN_PWR_MASK);\n\t\tu32p_replace_bits(&param->reg_info_1, req->channels[i]->max_power,\n\t\t\t\t  WCN36XX_HAL_CHAN_REG1_MAX_PWR_MASK);\n\t\tu32p_replace_bits(&param->reg_info_1, req->channels[i]->max_reg_power,\n\t\t\t\t  WCN36XX_HAL_CHAN_REG1_REG_PWR_MASK);\n\t\tu32p_replace_bits(&param->reg_info_1, 0,\n\t\t\t\t  WCN36XX_HAL_CHAN_REG1_CLASS_ID_MASK);\n\t\tu32p_replace_bits(&param->reg_info_2, ant_gain,\n\t\t\t\t  WCN36XX_HAL_CHAN_REG2_ANT_GAIN_MASK);\n\n\t\twcn36xx_dbg(WCN36XX_DBG_HAL,\n\t\t\t    \"%s: freq=%u, channel_info=%08x, reg_info1=%08x, reg_info2=%08x\\n\",\n\t\t\t    __func__, param->mhz, param->channel_info, param->reg_info_1,\n\t\t\t    param->reg_info_2);\n\t}\n\n\tmutex_lock(&wcn->hal_mutex);\n\n\tPREPARE_HAL_BUF(wcn->hal_buf, (*msg_body));\n\n\tret = wcn36xx_smd_send_and_wait(wcn, msg_body->header.len);\n\tif (ret) {\n\t\twcn36xx_err(\"Sending hal_update_channel_list failed\\n\");\n\t\tgoto out;\n\t}\n\n\tret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\n\tif (ret) {\n\t\twcn36xx_err(\"hal_update_channel_list response failed err=%d\\n\", ret);\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(msg_body);\n\tmutex_unlock(&wcn->hal_mutex);\n\treturn ret;\n}\n\nstatic int wcn36xx_smd_switch_channel_rsp(void *buf, size_t len)\n{\n\tstruct wcn36xx_hal_switch_channel_rsp_msg *rsp;\n\tint ret;\n\n\tret = wcn36xx_smd_rsp_status_check(buf, len);\n\tif (ret)\n\t\treturn ret;\n\trsp = (struct wcn36xx_hal_switch_channel_rsp_msg *)buf;\n\twcn36xx_dbg(WCN36XX_DBG_HAL, \"channel switched to: %d, status: %d\\n\",\n\t\t    rsp->channel_number, rsp->status);\n\treturn ret;\n}\n\nint wcn36xx_smd_switch_channel(struct wcn36xx *wcn,\n\t\t\t       struct ieee80211_vif *vif, int ch)\n{\n\tstruct wcn36xx_hal_switch_channel_req_msg msg_body;\n\tint ret;\n\n\tmutex_lock(&wcn->hal_mutex);\n\tINIT_HAL_MSG(msg_body, WCN36XX_HAL_CH_SWITCH_REQ);\n\n\tmsg_body.channel_number = (u8)ch;\n\tmsg_body.tx_mgmt_power = 0xbf;\n\tmsg_body.max_tx_power = 0xbf;\n\tmemcpy(msg_body.self_sta_mac_addr, vif->addr, ETH_ALEN);\n\n\tPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\n\n\tret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\n\tif (ret) {\n\t\twcn36xx_err(\"Sending hal_switch_channel failed\\n\");\n\t\tgoto out;\n\t}\n\tret = wcn36xx_smd_switch_channel_rsp(wcn->hal_buf, wcn->hal_rsp_len);\n\tif (ret) {\n\t\twcn36xx_err(\"hal_switch_channel response failed err=%d\\n\", ret);\n\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&wcn->hal_mutex);\n\treturn ret;\n}\n\nstatic int wcn36xx_smd_process_ptt_msg_rsp(void *buf, size_t len,\n\t\t\t\t\t   void **p_ptt_rsp_msg)\n{\n\tstruct wcn36xx_hal_process_ptt_msg_rsp_msg *rsp;\n\tint ret;\n\n\tret = wcn36xx_smd_rsp_status_check(buf, len);\n\tif (ret)\n\t\treturn ret;\n\n\trsp = (struct wcn36xx_hal_process_ptt_msg_rsp_msg *)buf;\n\n\twcn36xx_dbg(WCN36XX_DBG_HAL, \"process ptt msg responded with length %d\\n\",\n\t\t    rsp->header.len);\n\twcn36xx_dbg_dump(WCN36XX_DBG_HAL_DUMP, \"HAL_PTT_MSG_RSP:\", rsp->ptt_msg,\n\t\t\t rsp->header.len - sizeof(rsp->ptt_msg_resp_status));\n\n\tif (rsp->header.len > 0) {\n\t\t*p_ptt_rsp_msg = kmemdup(rsp->ptt_msg, rsp->header.len,\n\t\t\t\t\t GFP_ATOMIC);\n\t\tif (!*p_ptt_rsp_msg)\n\t\t\treturn -ENOMEM;\n\t}\n\treturn ret;\n}\n\nint wcn36xx_smd_process_ptt_msg(struct wcn36xx *wcn,\n\t\t\t\tstruct ieee80211_vif *vif, void *ptt_msg, size_t len,\n\t\tvoid **ptt_rsp_msg)\n{\n\tstruct wcn36xx_hal_process_ptt_msg_req_msg *p_msg_body;\n\tint ret;\n\n\tmutex_lock(&wcn->hal_mutex);\n\tp_msg_body = kmalloc(\n\t\tsizeof(struct wcn36xx_hal_process_ptt_msg_req_msg) + len,\n\t\tGFP_ATOMIC);\n\tif (!p_msg_body) {\n\t\tret = -ENOMEM;\n\t\tgoto out_nomem;\n\t}\n\tINIT_HAL_PTT_MSG(p_msg_body, len);\n\n\tmemcpy(&p_msg_body->ptt_msg, ptt_msg, len);\n\n\tPREPARE_HAL_PTT_MSG_BUF(wcn->hal_buf, p_msg_body);\n\n\tret = wcn36xx_smd_send_and_wait(wcn, p_msg_body->header.len);\n\tif (ret) {\n\t\twcn36xx_err(\"Sending hal_process_ptt_msg failed\\n\");\n\t\tgoto out;\n\t}\n\tret = wcn36xx_smd_process_ptt_msg_rsp(wcn->hal_buf, wcn->hal_rsp_len,\n\t\t\t\t\t      ptt_rsp_msg);\n\tif (ret) {\n\t\twcn36xx_err(\"process_ptt_msg response failed err=%d\\n\", ret);\n\t\tgoto out;\n\t}\nout:\n\tkfree(p_msg_body);\nout_nomem:\n\tmutex_unlock(&wcn->hal_mutex);\n\treturn ret;\n}\n\nstatic int wcn36xx_smd_update_scan_params_rsp(void *buf, size_t len)\n{\n\tstruct wcn36xx_hal_update_scan_params_resp *rsp;\n\n\trsp = (struct wcn36xx_hal_update_scan_params_resp *)buf;\n\n\t \n\trsp->status &= (~(WCN36XX_FW_MSG_PNO_VERSION_MASK));\n\n\tif (WCN36XX_FW_MSG_RESULT_SUCCESS != rsp->status) {\n\t\twcn36xx_warn(\"error response from update scan\\n\");\n\t\treturn rsp->status;\n\t}\n\n\treturn 0;\n}\n\nint wcn36xx_smd_update_scan_params(struct wcn36xx *wcn,\n\t\t\t\t   u8 *channels, size_t channel_count)\n{\n\tstruct wcn36xx_hal_update_scan_params_req_ex msg_body;\n\tint ret;\n\n\tmutex_lock(&wcn->hal_mutex);\n\tINIT_HAL_MSG(msg_body, WCN36XX_HAL_UPDATE_SCAN_PARAM_REQ);\n\n\tmsg_body.dot11d_enabled\t= false;\n\tmsg_body.dot11d_resolved = true;\n\n\tmsg_body.channel_count = channel_count;\n\tmemcpy(msg_body.channels, channels, channel_count);\n\tmsg_body.active_min_ch_time = 60;\n\tmsg_body.active_max_ch_time = 120;\n\tmsg_body.passive_min_ch_time = 60;\n\tmsg_body.passive_max_ch_time = 110;\n\tmsg_body.state = PHY_SINGLE_CHANNEL_CENTERED;\n\n\tPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\n\n\twcn36xx_dbg(WCN36XX_DBG_HAL,\n\t\t    \"hal update scan params channel_count %d\\n\",\n\t\t    msg_body.channel_count);\n\n\tret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\n\tif (ret) {\n\t\twcn36xx_err(\"Sending hal_update_scan_params failed\\n\");\n\t\tgoto out;\n\t}\n\tret = wcn36xx_smd_update_scan_params_rsp(wcn->hal_buf,\n\t\t\t\t\t\t wcn->hal_rsp_len);\n\tif (ret) {\n\t\twcn36xx_err(\"hal_update_scan_params response failed err=%d\\n\",\n\t\t\t    ret);\n\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&wcn->hal_mutex);\n\treturn ret;\n}\n\nstatic int wcn36xx_smd_add_sta_self_rsp(struct wcn36xx *wcn,\n\t\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\t\tvoid *buf,\n\t\t\t\t\tsize_t len)\n{\n\tstruct wcn36xx_hal_add_sta_self_rsp_msg *rsp;\n\tstruct wcn36xx_vif *vif_priv = wcn36xx_vif_to_priv(vif);\n\n\tif (len < sizeof(*rsp))\n\t\treturn -EINVAL;\n\n\trsp = (struct wcn36xx_hal_add_sta_self_rsp_msg *)buf;\n\n\tif (rsp->status != WCN36XX_FW_MSG_RESULT_SUCCESS) {\n\t\twcn36xx_warn(\"hal add sta self failure: %d\\n\",\n\t\t\t     rsp->status);\n\t\treturn rsp->status;\n\t}\n\n\twcn36xx_dbg(WCN36XX_DBG_HAL,\n\t\t    \"hal add sta self status %d self_sta_index %d dpu_index %d\\n\",\n\t\t    rsp->status, rsp->self_sta_index, rsp->dpu_index);\n\n\tvif_priv->self_sta_index = rsp->self_sta_index;\n\tvif_priv->self_dpu_desc_index = rsp->dpu_index;\n\n\treturn 0;\n}\n\nint wcn36xx_smd_add_sta_self(struct wcn36xx *wcn, struct ieee80211_vif *vif)\n{\n\tstruct wcn36xx_hal_add_sta_self_req msg_body;\n\tint ret;\n\n\tmutex_lock(&wcn->hal_mutex);\n\tINIT_HAL_MSG(msg_body, WCN36XX_HAL_ADD_STA_SELF_REQ);\n\n\tmemcpy(&msg_body.self_addr, vif->addr, ETH_ALEN);\n\n\tPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\n\n\twcn36xx_dbg(WCN36XX_DBG_HAL,\n\t\t    \"hal add sta self self_addr %pM status %d\\n\",\n\t\t    msg_body.self_addr, msg_body.status);\n\n\tret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\n\tif (ret) {\n\t\twcn36xx_err(\"Sending hal_add_sta_self failed\\n\");\n\t\tgoto out;\n\t}\n\tret = wcn36xx_smd_add_sta_self_rsp(wcn,\n\t\t\t\t\t   vif,\n\t\t\t\t\t   wcn->hal_buf,\n\t\t\t\t\t   wcn->hal_rsp_len);\n\tif (ret) {\n\t\twcn36xx_err(\"hal_add_sta_self response failed err=%d\\n\", ret);\n\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&wcn->hal_mutex);\n\treturn ret;\n}\n\nint wcn36xx_smd_delete_sta_self(struct wcn36xx *wcn, u8 *addr)\n{\n\tstruct wcn36xx_hal_del_sta_self_req_msg msg_body;\n\tint ret;\n\n\tmutex_lock(&wcn->hal_mutex);\n\tINIT_HAL_MSG(msg_body, WCN36XX_HAL_DEL_STA_SELF_REQ);\n\n\tmemcpy(&msg_body.self_addr, addr, ETH_ALEN);\n\n\tPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\n\n\tret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\n\tif (ret) {\n\t\twcn36xx_err(\"Sending hal_delete_sta_self failed\\n\");\n\t\tgoto out;\n\t}\n\tret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\n\tif (ret) {\n\t\twcn36xx_err(\"hal_delete_sta_self response failed err=%d\\n\",\n\t\t\t    ret);\n\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&wcn->hal_mutex);\n\treturn ret;\n}\n\nint wcn36xx_smd_delete_sta(struct wcn36xx *wcn, u8 sta_index)\n{\n\tstruct wcn36xx_hal_delete_sta_req_msg msg_body;\n\tint ret;\n\n\tmutex_lock(&wcn->hal_mutex);\n\tINIT_HAL_MSG(msg_body, WCN36XX_HAL_DELETE_STA_REQ);\n\n\tmsg_body.sta_index = sta_index;\n\n\tPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\n\n\twcn36xx_dbg(WCN36XX_DBG_HAL,\n\t\t    \"hal delete sta sta_index %d\\n\",\n\t\t    msg_body.sta_index);\n\n\tret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\n\tif (ret) {\n\t\twcn36xx_err(\"Sending hal_delete_sta failed\\n\");\n\t\tgoto out;\n\t}\n\tret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\n\tif (ret) {\n\t\twcn36xx_err(\"hal_delete_sta response failed err=%d\\n\", ret);\n\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&wcn->hal_mutex);\n\treturn ret;\n}\n\nstatic int wcn36xx_smd_join_rsp(void *buf, size_t len)\n{\n\tstruct wcn36xx_hal_join_rsp_msg *rsp;\n\n\tif (wcn36xx_smd_rsp_status_check(buf, len))\n\t\treturn -EIO;\n\n\trsp = (struct wcn36xx_hal_join_rsp_msg *)buf;\n\n\twcn36xx_dbg(WCN36XX_DBG_HAL,\n\t\t    \"hal rsp join status %d tx_mgmt_power %d\\n\",\n\t\t    rsp->status, rsp->tx_mgmt_power);\n\n\treturn 0;\n}\n\nint wcn36xx_smd_join(struct wcn36xx *wcn, const u8 *bssid, u8 *vif, u8 ch)\n{\n\tstruct wcn36xx_hal_join_req_msg msg_body;\n\tint ret;\n\n\tmutex_lock(&wcn->hal_mutex);\n\tINIT_HAL_MSG(msg_body, WCN36XX_HAL_JOIN_REQ);\n\n\tmemcpy(&msg_body.bssid, bssid, ETH_ALEN);\n\tmemcpy(&msg_body.self_sta_mac_addr, vif, ETH_ALEN);\n\tmsg_body.channel = ch;\n\n\tif (conf_is_ht40_minus(&wcn->hw->conf))\n\t\tmsg_body.secondary_channel_offset =\n\t\t\tPHY_DOUBLE_CHANNEL_HIGH_PRIMARY;\n\telse if (conf_is_ht40_plus(&wcn->hw->conf))\n\t\tmsg_body.secondary_channel_offset =\n\t\t\tPHY_DOUBLE_CHANNEL_LOW_PRIMARY;\n\telse\n\t\tmsg_body.secondary_channel_offset =\n\t\t\tPHY_SINGLE_CHANNEL_CENTERED;\n\n\tmsg_body.link_state = WCN36XX_HAL_LINK_PREASSOC_STATE;\n\n\tmsg_body.max_tx_power = 0xbf;\n\tPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\n\n\twcn36xx_dbg(WCN36XX_DBG_HAL,\n\t\t    \"hal join req bssid %pM self_sta_mac_addr %pM channel %d link_state %d\\n\",\n\t\t    msg_body.bssid, msg_body.self_sta_mac_addr,\n\t\t    msg_body.channel, msg_body.link_state);\n\n\tret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\n\tif (ret) {\n\t\twcn36xx_err(\"Sending hal_join failed\\n\");\n\t\tgoto out;\n\t}\n\tret = wcn36xx_smd_join_rsp(wcn->hal_buf, wcn->hal_rsp_len);\n\tif (ret) {\n\t\twcn36xx_err(\"hal_join response failed err=%d\\n\", ret);\n\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&wcn->hal_mutex);\n\treturn ret;\n}\n\nint wcn36xx_smd_set_link_st(struct wcn36xx *wcn, const u8 *bssid,\n\t\t\t    const u8 *sta_mac,\n\t\t\t    enum wcn36xx_hal_link_state state)\n{\n\tstruct wcn36xx_hal_set_link_state_req_msg msg_body;\n\tint ret;\n\n\tmutex_lock(&wcn->hal_mutex);\n\tINIT_HAL_MSG(msg_body, WCN36XX_HAL_SET_LINK_ST_REQ);\n\n\tmemcpy(&msg_body.bssid, bssid, ETH_ALEN);\n\tmemcpy(&msg_body.self_mac_addr, sta_mac, ETH_ALEN);\n\tmsg_body.state = state;\n\n\tPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\n\n\twcn36xx_dbg(WCN36XX_DBG_HAL,\n\t\t    \"hal set link state bssid %pM self_mac_addr %pM state %d\\n\",\n\t\t    msg_body.bssid, msg_body.self_mac_addr, msg_body.state);\n\n\tret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\n\tif (ret) {\n\t\twcn36xx_err(\"Sending hal_set_link_st failed\\n\");\n\t\tgoto out;\n\t}\n\tret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\n\tif (ret) {\n\t\twcn36xx_err(\"hal_set_link_st response failed err=%d\\n\", ret);\n\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&wcn->hal_mutex);\n\treturn ret;\n}\n\nstatic void wcn36xx_smd_convert_sta_to_v1(struct wcn36xx *wcn,\n\t\t\tconst struct wcn36xx_hal_config_sta_params *orig,\n\t\t\tstruct wcn36xx_hal_config_sta_params_v1 *v1)\n{\n\t \n\tmemcpy(&v1->bssid, orig->bssid, ETH_ALEN);\n\tmemcpy(&v1->mac, orig->mac, ETH_ALEN);\n\tv1->aid = orig->aid;\n\tv1->type = orig->type;\n\tv1->short_preamble_supported = orig->short_preamble_supported;\n\tv1->listen_interval = orig->listen_interval;\n\tv1->wmm_enabled = orig->wmm_enabled;\n\tv1->ht_capable = orig->ht_capable;\n\tv1->tx_channel_width_set = orig->tx_channel_width_set;\n\tv1->rifs_mode = orig->rifs_mode;\n\tv1->lsig_txop_protection = orig->lsig_txop_protection;\n\tv1->max_ampdu_size = orig->max_ampdu_size;\n\tv1->max_ampdu_density = orig->max_ampdu_density;\n\tv1->sgi_40mhz = orig->sgi_40mhz;\n\tv1->sgi_20Mhz = orig->sgi_20Mhz;\n\tv1->rmf = orig->rmf;\n\tv1->encrypt_type = orig->encrypt_type;\n\tv1->action = orig->action;\n\tv1->uapsd = orig->uapsd;\n\tv1->max_sp_len = orig->max_sp_len;\n\tv1->green_field_capable = orig->green_field_capable;\n\tv1->mimo_ps = orig->mimo_ps;\n\tv1->delayed_ba_support = orig->delayed_ba_support;\n\tv1->max_ampdu_duration = orig->max_ampdu_duration;\n\tv1->dsss_cck_mode_40mhz = orig->dsss_cck_mode_40mhz;\n\tmemcpy(&v1->supported_rates, &orig->supported_rates,\n\t       sizeof(orig->supported_rates));\n\tv1->sta_index = orig->sta_index;\n\tv1->bssid_index = orig->bssid_index;\n\tv1->p2p = orig->p2p;\n}\n\nstatic void\nwcn36xx_smd_set_sta_params_v1(struct wcn36xx *wcn,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      struct ieee80211_sta *sta,\n\t\t\t      struct wcn36xx_hal_config_sta_params_v1 *sta_par)\n{\n\tstruct wcn36xx_sta *sta_priv = NULL;\n\tstruct wcn36xx_hal_config_sta_params sta_par_v0;\n\n\twcn36xx_smd_set_sta_params(wcn, vif, sta, &sta_par_v0);\n\twcn36xx_smd_convert_sta_to_v1(wcn, &sta_par_v0, sta_par);\n\n\tif (sta) {\n\t\tsta_priv = wcn36xx_sta_to_priv(sta);\n\t\twcn36xx_smd_set_sta_vht_params(wcn, sta, sta_par);\n\t\twcn36xx_smd_set_sta_ht_ldpc_params(sta, sta_par);\n\t\tmemcpy(&sta_par->supported_rates, &sta_priv->supported_rates,\n\t\t       sizeof(sta_par->supported_rates));\n\t} else {\n\t\twcn36xx_set_default_rates_v1(&sta_par->supported_rates);\n\t\twcn36xx_smd_set_sta_default_vht_params(wcn, sta_par);\n\t\twcn36xx_smd_set_sta_default_ht_ldpc_params(wcn, sta_par);\n\t}\n}\n\nstatic int wcn36xx_smd_config_sta_rsp(struct wcn36xx *wcn,\n\t\t\t\t      struct ieee80211_sta *sta,\n\t\t\t\t      void *buf,\n\t\t\t\t      size_t len)\n{\n\tstruct wcn36xx_hal_config_sta_rsp_msg *rsp;\n\tstruct config_sta_rsp_params *params;\n\tstruct wcn36xx_sta *sta_priv = wcn36xx_sta_to_priv(sta);\n\n\tif (len < sizeof(*rsp))\n\t\treturn -EINVAL;\n\n\trsp = (struct wcn36xx_hal_config_sta_rsp_msg *)buf;\n\tparams = &rsp->params;\n\n\tif (params->status != WCN36XX_FW_MSG_RESULT_SUCCESS) {\n\t\twcn36xx_warn(\"hal config sta response failure: %d\\n\",\n\t\t\t     params->status);\n\t\treturn -EIO;\n\t}\n\n\tsta_priv->sta_index = params->sta_index;\n\tsta_priv->dpu_desc_index = params->dpu_index;\n\tsta_priv->ucast_dpu_sign = params->uc_ucast_sig;\n\n\twcn36xx_dbg(WCN36XX_DBG_HAL,\n\t\t    \"hal config sta rsp status %d sta_index %d bssid_index %d uc_ucast_sig %d p2p %d\\n\",\n\t\t    params->status, params->sta_index, params->bssid_index,\n\t\t    params->uc_ucast_sig, params->p2p);\n\n\treturn 0;\n}\n\nstatic int wcn36xx_smd_config_sta_v1(struct wcn36xx *wcn,\n\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t     struct ieee80211_sta *sta)\n{\n\tstruct wcn36xx_hal_config_sta_req_msg_v1 msg_body;\n\tstruct wcn36xx_hal_config_sta_params_v1 *sta_params;\n\n\tif (wcn->rf_id == RF_IRIS_WCN3680) {\n\t\tINIT_HAL_MSG_V1(msg_body, WCN36XX_HAL_CONFIG_STA_REQ);\n\t} else {\n\t\tINIT_HAL_MSG(msg_body, WCN36XX_HAL_CONFIG_STA_REQ);\n\t\tmsg_body.header.len -= WCN36XX_DIFF_STA_PARAMS_V1_NOVHT;\n\t}\n\n\tsta_params = &msg_body.sta_params;\n\n\twcn36xx_smd_set_sta_params_v1(wcn, vif, sta, sta_params);\n\n\tPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\n\n\twcn36xx_dbg(WCN36XX_DBG_HAL,\n\t\t    \"hal config sta v1 action %d sta_index %d bssid_index %d bssid %pM type %d mac %pM aid %d\\n\",\n\t\t    sta_params->action, sta_params->sta_index, sta_params->bssid_index,\n\t\t    sta_params->bssid, sta_params->type, sta_params->mac, sta_params->aid);\n\n\treturn wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\n}\n\nstatic int wcn36xx_smd_config_sta_v0(struct wcn36xx *wcn,\n\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t     struct ieee80211_sta *sta)\n{\n\tstruct wcn36xx_hal_config_sta_req_msg msg;\n\tstruct wcn36xx_hal_config_sta_params *sta_params;\n\n\tINIT_HAL_MSG(msg, WCN36XX_HAL_CONFIG_STA_REQ);\n\n\tsta_params = &msg.sta_params;\n\n\twcn36xx_smd_set_sta_params(wcn, vif, sta, sta_params);\n\n\tPREPARE_HAL_BUF(wcn->hal_buf, msg);\n\n\twcn36xx_dbg(WCN36XX_DBG_HAL,\n\t\t    \"hal config sta action %d sta_index %d bssid_index %d bssid %pM type %d mac %pM aid %d\\n\",\n\t\t    sta_params->action, sta_params->sta_index,\n\t\t    sta_params->bssid_index, sta_params->bssid,\n\t\t    sta_params->type, sta_params->mac, sta_params->aid);\n\n\treturn wcn36xx_smd_send_and_wait(wcn, msg.header.len);\n}\n\nint wcn36xx_smd_config_sta(struct wcn36xx *wcn, struct ieee80211_vif *vif,\n\t\t\t   struct ieee80211_sta *sta)\n{\n\tint ret;\n\n\tmutex_lock(&wcn->hal_mutex);\n\n\tif (!wcn36xx_is_fw_version(wcn, 1, 2, 2, 24))\n\t\tret = wcn36xx_smd_config_sta_v1(wcn, vif, sta);\n\telse\n\t\tret = wcn36xx_smd_config_sta_v0(wcn, vif, sta);\n\n\tif (ret) {\n\t\twcn36xx_err(\"Sending hal_config_sta failed\\n\");\n\t\tgoto out;\n\t}\n\tret = wcn36xx_smd_config_sta_rsp(wcn,\n\t\t\t\t\t sta,\n\t\t\t\t\t wcn->hal_buf,\n\t\t\t\t\t wcn->hal_rsp_len);\n\tif (ret) {\n\t\twcn36xx_err(\"hal_config_sta response failed err=%d\\n\", ret);\n\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&wcn->hal_mutex);\n\treturn ret;\n}\n\nstatic void wcn36xx_smd_set_bss_params(struct wcn36xx *wcn,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       struct ieee80211_sta *sta,\n\t\t\t\t       const u8 *bssid,\n\t\t\t\t       bool update,\n\t\t\t\t       struct wcn36xx_hal_config_bss_params *bss)\n{\n\tstruct wcn36xx_vif *vif_priv = wcn36xx_vif_to_priv(vif);\n\n\tWARN_ON(is_zero_ether_addr(bssid));\n\n\tmemcpy(&bss->bssid, bssid, ETH_ALEN);\n\n\tmemcpy(bss->self_mac_addr, vif->addr, ETH_ALEN);\n\n\tif (vif->type == NL80211_IFTYPE_STATION) {\n\t\tbss->bss_type = WCN36XX_HAL_INFRASTRUCTURE_MODE;\n\n\t\t \n\t\tbss->oper_mode = 1;\n\t\tbss->wcn36xx_hal_persona = WCN36XX_HAL_STA_MODE;\n\t} else if (vif->type == NL80211_IFTYPE_AP ||\n\t\t   vif->type == NL80211_IFTYPE_MESH_POINT) {\n\t\tbss->bss_type = WCN36XX_HAL_INFRA_AP_MODE;\n\n\t\t \n\t\tbss->oper_mode = 0;\n\t\tbss->wcn36xx_hal_persona = WCN36XX_HAL_STA_SAP_MODE;\n\t} else if (vif->type == NL80211_IFTYPE_ADHOC) {\n\t\tbss->bss_type = WCN36XX_HAL_IBSS_MODE;\n\n\t\t \n\t\tbss->oper_mode = 1;\n\t} else {\n\t\twcn36xx_warn(\"Unknown type for bss config: %d\\n\", vif->type);\n\t}\n\n\tif (vif->type == NL80211_IFTYPE_STATION)\n\t\twcn36xx_smd_set_bss_nw_type(wcn, sta, bss);\n\telse\n\t\tbss->nw_type = WCN36XX_HAL_11N_NW_TYPE;\n\n\tbss->short_slot_time_supported = vif->bss_conf.use_short_slot;\n\tbss->lla_coexist = 0;\n\tbss->llb_coexist = 0;\n\tbss->llg_coexist = 0;\n\tbss->rifs_mode = 0;\n\tbss->beacon_interval = vif->bss_conf.beacon_int;\n\tbss->dtim_period = vif_priv->dtim_period;\n\n\twcn36xx_smd_set_bss_ht_params(vif, sta, bss);\n\n\tbss->oper_channel = WCN36XX_HW_CHANNEL(wcn);\n\n\tif (conf_is_ht40_minus(&wcn->hw->conf))\n\t\tbss->ext_channel = IEEE80211_HT_PARAM_CHA_SEC_BELOW;\n\telse if (conf_is_ht40_plus(&wcn->hw->conf))\n\t\tbss->ext_channel = IEEE80211_HT_PARAM_CHA_SEC_ABOVE;\n\telse\n\t\tbss->ext_channel = IEEE80211_HT_PARAM_CHA_SEC_NONE;\n\n\tbss->reserved = 0;\n\n\t \n\tbss->ssid.length = vif_priv->ssid.length;\n\tmemcpy(bss->ssid.ssid, vif_priv->ssid.ssid, vif_priv->ssid.length);\n\n\tbss->obss_prot_enabled = 0;\n\tbss->rmf = 0;\n\tbss->max_probe_resp_retry_limit = 0;\n\tbss->hidden_ssid = vif->bss_conf.hidden_ssid;\n\tbss->proxy_probe_resp = 0;\n\tbss->edca_params_valid = 0;\n\n\t \n\n\tbss->ext_set_sta_key_param_valid = 0;\n\n\t \n\n\tbss->spectrum_mgt_enable = 0;\n\tbss->tx_mgmt_power = 0;\n\tbss->max_tx_power = WCN36XX_MAX_POWER(wcn);\n\tbss->action = update;\n\n\tvif_priv->bss_type = bss->bss_type;\n}\n\nstatic int wcn36xx_smd_config_bss_v1(struct wcn36xx *wcn,\n\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t     struct ieee80211_sta *sta_80211,\n\t\t\t\t     const u8 *bssid,\n\t\t\t\t     bool update)\n{\n\tstruct wcn36xx_hal_config_bss_req_msg_v1 *msg_body;\n\tstruct wcn36xx_hal_config_bss_params_v1 *bss;\n\tstruct wcn36xx_hal_config_bss_params bss_v0;\n\tstruct wcn36xx_hal_config_sta_params_v1 *sta;\n\tstruct cfg80211_chan_def *chandef;\n\tint ret;\n\n\tmsg_body = kzalloc(sizeof(*msg_body), GFP_KERNEL);\n\tif (!msg_body)\n\t\treturn -ENOMEM;\n\n\tif (wcn->rf_id == RF_IRIS_WCN3680) {\n\t\tINIT_HAL_MSG_V1((*msg_body), WCN36XX_HAL_CONFIG_BSS_REQ);\n\t} else {\n\t\tINIT_HAL_MSG((*msg_body), WCN36XX_HAL_CONFIG_BSS_REQ);\n\t\tmsg_body->header.len -= WCN36XX_DIFF_BSS_PARAMS_V1_NOVHT;\n\t}\n\n\tbss = &msg_body->bss_params;\n\tsta = &bss->sta;\n\n\tmemset(&bss_v0, 0x00, sizeof(bss_v0));\n\twcn36xx_smd_set_bss_params(wcn, vif, sta_80211, bssid, update, &bss_v0);\n\twcn36xx_smd_set_sta_params_v1(wcn, vif, sta_80211, sta);\n\n\t \n\tmemcpy(bss->bssid, &bss_v0.bssid, ETH_ALEN);\n\tmemcpy(bss->self_mac_addr, &bss_v0.self_mac_addr, ETH_ALEN);\n\n\tbss->bss_type = bss_v0.bss_type;\n\tbss->oper_mode = bss_v0.oper_mode;\n\tbss->nw_type = bss_v0.nw_type;\n\n\tbss->short_slot_time_supported =\n\t\tbss_v0.short_slot_time_supported;\n\tbss->lla_coexist = bss_v0.lla_coexist;\n\tbss->llb_coexist = bss_v0.llb_coexist;\n\tbss->llg_coexist = bss_v0.llg_coexist;\n\tbss->ht20_coexist = bss_v0.ht20_coexist;\n\tbss->lln_non_gf_coexist = bss_v0.lln_non_gf_coexist;\n\n\tbss->lsig_tx_op_protection_full_support =\n\t\tbss_v0.lsig_tx_op_protection_full_support;\n\tbss->rifs_mode = bss_v0.rifs_mode;\n\tbss->beacon_interval = bss_v0.beacon_interval;\n\tbss->dtim_period = bss_v0.dtim_period;\n\tbss->tx_channel_width_set = bss_v0.tx_channel_width_set;\n\tbss->oper_channel = bss_v0.oper_channel;\n\n\tif (wcn->hw->conf.chandef.width == NL80211_CHAN_WIDTH_80) {\n\t\tchandef = &wcn->hw->conf.chandef;\n\t\tbss->ext_channel = HW_VALUE_PHY(chandef->chan->hw_value);\n\t} else {\n\t\tbss->ext_channel = bss_v0.ext_channel;\n\t}\n\n\tbss->reserved = bss_v0.reserved;\n\n\tmemcpy(&bss->ssid, &bss_v0.ssid,\n\t       sizeof(bss_v0.ssid));\n\n\tbss->action = bss_v0.action;\n\tbss->rateset = bss_v0.rateset;\n\tbss->ht = bss_v0.ht;\n\tbss->obss_prot_enabled = bss_v0.obss_prot_enabled;\n\tbss->rmf = bss_v0.rmf;\n\tbss->ht_oper_mode = bss_v0.ht_oper_mode;\n\tbss->dual_cts_protection = bss_v0.dual_cts_protection;\n\n\tbss->max_probe_resp_retry_limit =\n\t\tbss_v0.max_probe_resp_retry_limit;\n\tbss->hidden_ssid = bss_v0.hidden_ssid;\n\tbss->proxy_probe_resp =\tbss_v0.proxy_probe_resp;\n\tbss->edca_params_valid = bss_v0.edca_params_valid;\n\n\tmemcpy(&bss->acbe, &bss_v0.acbe,\n\t       sizeof(bss_v0.acbe));\n\tmemcpy(&bss->acbk, &bss_v0.acbk,\n\t       sizeof(bss_v0.acbk));\n\tmemcpy(&bss->acvi, &bss_v0.acvi,\n\t       sizeof(bss_v0.acvi));\n\tmemcpy(&bss->acvo, &bss_v0.acvo,\n\t       sizeof(bss_v0.acvo));\n\n\tbss->ext_set_sta_key_param_valid =\n\t\tbss_v0.ext_set_sta_key_param_valid;\n\n\tmemcpy(&bss->ext_set_sta_key_param,\n\t       &bss_v0.ext_set_sta_key_param,\n\t       sizeof(bss_v0.acvo));\n\n\tbss->wcn36xx_hal_persona = bss_v0.wcn36xx_hal_persona;\n\tbss->spectrum_mgt_enable = bss_v0.spectrum_mgt_enable;\n\tbss->tx_mgmt_power = bss_v0.tx_mgmt_power;\n\tbss->max_tx_power = bss_v0.max_tx_power;\n\n\twcn36xx_smd_set_bss_vht_params(vif, sta_80211, bss);\n\n\tPREPARE_HAL_BUF(wcn->hal_buf, (*msg_body));\n\n\twcn36xx_dbg(WCN36XX_DBG_HAL,\n\t\t    \"hal config bss v1 bssid %pM self_mac_addr %pM bss_type %d oper_mode %d nw_type %d\\n\",\n\t\t    bss->bssid, bss->self_mac_addr, bss->bss_type,\n\t\t    bss->oper_mode, bss->nw_type);\n\n\twcn36xx_dbg(WCN36XX_DBG_HAL,\n\t\t    \"- sta bssid %pM action %d sta_index %d bssid_index %d aid %d type %d mac %pM\\n\",\n\t\t    sta->bssid, sta->action, sta->sta_index,\n\t\t    sta->bssid_index, sta->aid, sta->type, sta->mac);\n\n\tret = wcn36xx_smd_send_and_wait(wcn, msg_body->header.len);\n\tkfree(msg_body);\n\n\treturn ret;\n}\n\nstatic int wcn36xx_smd_config_bss_v0(struct wcn36xx *wcn,\n\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t     struct ieee80211_sta *sta,\n\t\t\t\t     const u8 *bssid,\n\t\t\t\t     bool update)\n{\n\tstruct wcn36xx_hal_config_bss_req_msg *msg;\n\tstruct wcn36xx_hal_config_bss_params *bss;\n\tstruct wcn36xx_hal_config_sta_params *sta_params;\n\tint ret;\n\n\tmsg = kzalloc(sizeof(*msg), GFP_KERNEL);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tINIT_HAL_MSG((*msg), WCN36XX_HAL_CONFIG_BSS_REQ);\n\n\tbss = &msg->bss_params;\n\tsta_params = &bss->sta;\n\n\twcn36xx_smd_set_bss_params(wcn, vif, sta, bssid, update, bss);\n\twcn36xx_smd_set_sta_params(wcn, vif, sta, sta_params);\n\n\tPREPARE_HAL_BUF(wcn->hal_buf, (*msg));\n\n\twcn36xx_dbg(WCN36XX_DBG_HAL,\n\t\t    \"hal config bss bssid %pM self_mac_addr %pM bss_type %d oper_mode %d nw_type %d\\n\",\n\t\t    bss->bssid, bss->self_mac_addr, bss->bss_type,\n\t\t    bss->oper_mode, bss->nw_type);\n\n\twcn36xx_dbg(WCN36XX_DBG_HAL,\n\t\t    \"- sta bssid %pM action %d sta_index %d bssid_index %d aid %d type %d mac %pM\\n\",\n\t\t    sta_params->bssid, sta_params->action,\n\t\t    sta_params->sta_index, sta_params->bssid_index,\n\t\t    sta_params->aid, sta_params->type,\n\t\t    sta_params->mac);\n\n\tret = wcn36xx_smd_send_and_wait(wcn, msg->header.len);\n\tkfree(msg);\n\n\treturn ret;\n}\n\nstatic int wcn36xx_smd_config_bss_rsp(struct wcn36xx *wcn,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      struct ieee80211_sta *sta,\n\t\t\t\t      void *buf,\n\t\t\t\t      size_t len)\n{\n\tstruct wcn36xx_hal_config_bss_rsp_msg *rsp;\n\tstruct wcn36xx_hal_config_bss_rsp_params *params;\n\tstruct wcn36xx_vif *vif_priv = wcn36xx_vif_to_priv(vif);\n\n\tif (len < sizeof(*rsp))\n\t\treturn -EINVAL;\n\n\trsp = (struct wcn36xx_hal_config_bss_rsp_msg *)buf;\n\tparams = &rsp->bss_rsp_params;\n\n\tif (params->status != WCN36XX_FW_MSG_RESULT_SUCCESS) {\n\t\twcn36xx_warn(\"hal config bss response failure: %d\\n\",\n\t\t\t     params->status);\n\t\treturn -EIO;\n\t}\n\n\twcn36xx_dbg(WCN36XX_DBG_HAL,\n\t\t    \"hal config bss rsp status %d bss_idx %d dpu_desc_index %d\"\n\t\t    \" sta_idx %d self_idx %d bcast_idx %d mac %pM\"\n\t\t    \" power %d ucast_dpu_signature %d\\n\",\n\t\t    params->status, params->bss_index, params->dpu_desc_index,\n\t\t    params->bss_sta_index, params->bss_self_sta_index,\n\t\t    params->bss_bcast_sta_idx, params->mac,\n\t\t    params->tx_mgmt_power, params->ucast_dpu_signature);\n\n\tvif_priv->bss_index = params->bss_index;\n\n\tif (sta) {\n\t\tstruct wcn36xx_sta *sta_priv = wcn36xx_sta_to_priv(sta);\n\t\tsta_priv->bss_sta_index = params->bss_sta_index;\n\t\tsta_priv->bss_dpu_desc_index = params->dpu_desc_index;\n\t}\n\n\tvif_priv->self_ucast_dpu_sign = params->ucast_dpu_signature;\n\n\treturn 0;\n}\n\nint wcn36xx_smd_config_bss(struct wcn36xx *wcn, struct ieee80211_vif *vif,\n\t\t\t   struct ieee80211_sta *sta, const u8 *bssid,\n\t\t\t   bool update)\n{\n\tint ret;\n\n\tmutex_lock(&wcn->hal_mutex);\n\n\tif (!wcn36xx_is_fw_version(wcn, 1, 2, 2, 24))\n\t\tret = wcn36xx_smd_config_bss_v1(wcn, vif, sta, bssid, update);\n\telse\n\t\tret = wcn36xx_smd_config_bss_v0(wcn, vif, sta, bssid, update);\n\n\tif (ret) {\n\t\twcn36xx_err(\"Sending hal_config_bss failed\\n\");\n\t\tgoto out;\n\t}\n\tret = wcn36xx_smd_config_bss_rsp(wcn,\n\t\t\t\t\t vif,\n\t\t\t\t\t sta,\n\t\t\t\t\t wcn->hal_buf,\n\t\t\t\t\t wcn->hal_rsp_len);\n\tif (ret)\n\t\twcn36xx_err(\"hal_config_bss response failed err=%d\\n\", ret);\n\nout:\n\tmutex_unlock(&wcn->hal_mutex);\n\treturn ret;\n}\n\nint wcn36xx_smd_delete_bss(struct wcn36xx *wcn, struct ieee80211_vif *vif)\n{\n\tstruct wcn36xx_hal_delete_bss_req_msg msg_body;\n\tstruct wcn36xx_vif *vif_priv = wcn36xx_vif_to_priv(vif);\n\tint ret = 0;\n\n\tmutex_lock(&wcn->hal_mutex);\n\n\tif (vif_priv->bss_index == WCN36XX_HAL_BSS_INVALID_IDX)\n\t\tgoto out;\n\n\tINIT_HAL_MSG(msg_body, WCN36XX_HAL_DELETE_BSS_REQ);\n\n\tmsg_body.bss_index = vif_priv->bss_index;\n\n\tPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\n\n\twcn36xx_dbg(WCN36XX_DBG_HAL, \"hal delete bss %d\\n\", msg_body.bss_index);\n\n\tret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\n\tif (ret) {\n\t\twcn36xx_err(\"Sending hal_delete_bss failed\\n\");\n\t\tgoto out;\n\t}\n\tret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\n\tif (ret) {\n\t\twcn36xx_err(\"hal_delete_bss response failed err=%d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tvif_priv->bss_index = WCN36XX_HAL_BSS_INVALID_IDX;\nout:\n\tmutex_unlock(&wcn->hal_mutex);\n\treturn ret;\n}\n\nint wcn36xx_smd_send_beacon(struct wcn36xx *wcn, struct ieee80211_vif *vif,\n\t\t\t    struct sk_buff *skb_beacon, u16 tim_off,\n\t\t\t    u16 p2p_off)\n{\n\tstruct wcn36xx_hal_send_beacon_req_msg msg_body;\n\tint ret, pad, pvm_len;\n\n\tmutex_lock(&wcn->hal_mutex);\n\tINIT_HAL_MSG(msg_body, WCN36XX_HAL_SEND_BEACON_REQ);\n\n\tpvm_len = skb_beacon->data[tim_off + 1] - 3;\n\tpad = TIM_MIN_PVM_SIZE - pvm_len;\n\n\t \n\tif (vif->type == NL80211_IFTYPE_MESH_POINT)\n\t\tpad = 0;\n\n\tmsg_body.beacon_length = skb_beacon->len + pad;\n\t \n\tmsg_body.beacon_length6 = msg_body.beacon_length + 6;\n\n\tif (msg_body.beacon_length > BEACON_TEMPLATE_SIZE) {\n\t\twcn36xx_err(\"Beacon is too big: beacon size=%d\\n\",\n\t\t\t      msg_body.beacon_length);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tmemcpy(msg_body.beacon, skb_beacon->data, skb_beacon->len);\n\tmemcpy(msg_body.bssid, vif->addr, ETH_ALEN);\n\n\tif (pad > 0) {\n\t\t \n\t\twcn36xx_dbg(WCN36XX_DBG_HAL, \"Pad TIM PVM. %d bytes at %d\\n\",\n\t\t\t    pad, pvm_len);\n\t\tmemmove(&msg_body.beacon[tim_off + 5 + pvm_len + pad],\n\t\t\t&msg_body.beacon[tim_off + 5 + pvm_len],\n\t\t\tskb_beacon->len - (tim_off + 5 + pvm_len));\n\t\tmemset(&msg_body.beacon[tim_off + 5 + pvm_len], 0, pad);\n\t\tmsg_body.beacon[tim_off + 1] += pad;\n\t}\n\n\t \n\tif (vif->type == NL80211_IFTYPE_MESH_POINT)\n\t\t \n\t\tmsg_body.tim_ie_offset = 256;\n\telse\n\t\tmsg_body.tim_ie_offset = tim_off+4;\n\tmsg_body.p2p_ie_offset = p2p_off;\n\tPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\n\n\twcn36xx_dbg(WCN36XX_DBG_HAL,\n\t\t    \"hal send beacon beacon_length %d\\n\",\n\t\t    msg_body.beacon_length);\n\n\tret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\n\tif (ret) {\n\t\twcn36xx_err(\"Sending hal_send_beacon failed\\n\");\n\t\tgoto out;\n\t}\n\tret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\n\tif (ret) {\n\t\twcn36xx_err(\"hal_send_beacon response failed err=%d\\n\", ret);\n\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&wcn->hal_mutex);\n\treturn ret;\n}\n\nint wcn36xx_smd_update_proberesp_tmpl(struct wcn36xx *wcn,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct wcn36xx_hal_send_probe_resp_req_msg msg;\n\tint ret;\n\n\tmutex_lock(&wcn->hal_mutex);\n\tINIT_HAL_MSG(msg, WCN36XX_HAL_UPDATE_PROBE_RSP_TEMPLATE_REQ);\n\n\tif (skb->len > BEACON_TEMPLATE_SIZE) {\n\t\twcn36xx_warn(\"probe response template is too big: %d\\n\",\n\t\t\t     skb->len);\n\t\tret = -E2BIG;\n\t\tgoto out;\n\t}\n\n\tmsg.probe_resp_template_len = skb->len;\n\tmemcpy(&msg.probe_resp_template, skb->data, skb->len);\n\n\tmemcpy(msg.bssid, vif->addr, ETH_ALEN);\n\n\tPREPARE_HAL_BUF(wcn->hal_buf, msg);\n\n\twcn36xx_dbg(WCN36XX_DBG_HAL,\n\t\t    \"hal update probe rsp len %d bssid %pM\\n\",\n\t\t    msg.probe_resp_template_len, msg.bssid);\n\n\tret = wcn36xx_smd_send_and_wait(wcn, msg.header.len);\n\tif (ret) {\n\t\twcn36xx_err(\"Sending hal_update_proberesp_tmpl failed\\n\");\n\t\tgoto out;\n\t}\n\tret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\n\tif (ret) {\n\t\twcn36xx_err(\"hal_update_proberesp_tmpl response failed err=%d\\n\",\n\t\t\t    ret);\n\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&wcn->hal_mutex);\n\treturn ret;\n}\n\nint wcn36xx_smd_set_stakey(struct wcn36xx *wcn,\n\t\t\t   enum ani_ed_type enc_type,\n\t\t\t   u8 keyidx,\n\t\t\t   u8 keylen,\n\t\t\t   u8 *key,\n\t\t\t   u8 sta_index)\n{\n\tstruct wcn36xx_hal_set_sta_key_req_msg msg_body;\n\tint ret;\n\n\tmutex_lock(&wcn->hal_mutex);\n\tINIT_HAL_MSG(msg_body, WCN36XX_HAL_SET_STAKEY_REQ);\n\n\tmsg_body.set_sta_key_params.sta_index = sta_index;\n\tmsg_body.set_sta_key_params.enc_type = enc_type;\n\n\tif (enc_type == WCN36XX_HAL_ED_WEP104 ||\n\t    enc_type == WCN36XX_HAL_ED_WEP40) {\n\t\t \n\t\tmsg_body.set_sta_key_params.def_wep_idx = keyidx;\n\t\tmsg_body.set_sta_key_params.wep_type = 0;\n\t} else {\n\t\tmsg_body.set_sta_key_params.key[0].id = keyidx;\n\t\tmsg_body.set_sta_key_params.key[0].unicast = 1;\n\t\tmsg_body.set_sta_key_params.key[0].direction = WCN36XX_HAL_TX_RX;\n\t\tmsg_body.set_sta_key_params.key[0].pae_role = 0;\n\t\tmsg_body.set_sta_key_params.key[0].length = keylen;\n\t\tmemcpy(msg_body.set_sta_key_params.key[0].key, key, keylen);\n\t}\n\n\tmsg_body.set_sta_key_params.single_tid_rc = 1;\n\n\tPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\n\n\tret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\n\tif (ret) {\n\t\twcn36xx_err(\"Sending hal_set_stakey failed\\n\");\n\t\tgoto out;\n\t}\n\tret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\n\tif (ret) {\n\t\twcn36xx_err(\"hal_set_stakey response failed err=%d\\n\", ret);\n\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&wcn->hal_mutex);\n\treturn ret;\n}\n\nint wcn36xx_smd_set_bsskey(struct wcn36xx *wcn,\n\t\t\t   enum ani_ed_type enc_type,\n\t\t\t   u8 bssidx,\n\t\t\t   u8 keyidx,\n\t\t\t   u8 keylen,\n\t\t\t   u8 *key)\n{\n\tstruct wcn36xx_hal_set_bss_key_req_msg msg_body;\n\tint ret;\n\n\tmutex_lock(&wcn->hal_mutex);\n\tINIT_HAL_MSG(msg_body, WCN36XX_HAL_SET_BSSKEY_REQ);\n\tmsg_body.bss_idx = bssidx;\n\tmsg_body.enc_type = enc_type;\n\tmsg_body.num_keys = 1;\n\tmsg_body.keys[0].id = keyidx;\n\tmsg_body.keys[0].unicast = 0;\n\tmsg_body.keys[0].direction = WCN36XX_HAL_RX_ONLY;\n\tmsg_body.keys[0].pae_role = 0;\n\tmsg_body.keys[0].length = keylen;\n\tmemcpy(msg_body.keys[0].key, key, keylen);\n\n\tPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\n\n\tret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\n\tif (ret) {\n\t\twcn36xx_err(\"Sending hal_set_bsskey failed\\n\");\n\t\tgoto out;\n\t}\n\tret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\n\tif (ret) {\n\t\twcn36xx_err(\"hal_set_bsskey response failed err=%d\\n\", ret);\n\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&wcn->hal_mutex);\n\treturn ret;\n}\n\nint wcn36xx_smd_remove_stakey(struct wcn36xx *wcn,\n\t\t\t      enum ani_ed_type enc_type,\n\t\t\t      u8 keyidx,\n\t\t\t      u8 sta_index)\n{\n\tstruct wcn36xx_hal_remove_sta_key_req_msg msg_body;\n\tint ret;\n\n\tmutex_lock(&wcn->hal_mutex);\n\tINIT_HAL_MSG(msg_body, WCN36XX_HAL_RMV_STAKEY_REQ);\n\n\tmsg_body.sta_idx = sta_index;\n\tmsg_body.enc_type = enc_type;\n\tmsg_body.key_id = keyidx;\n\n\tPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\n\n\tret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\n\tif (ret) {\n\t\twcn36xx_err(\"Sending hal_remove_stakey failed\\n\");\n\t\tgoto out;\n\t}\n\tret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\n\tif (ret) {\n\t\twcn36xx_err(\"hal_remove_stakey response failed err=%d\\n\", ret);\n\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&wcn->hal_mutex);\n\treturn ret;\n}\n\nint wcn36xx_smd_remove_bsskey(struct wcn36xx *wcn,\n\t\t\t      enum ani_ed_type enc_type,\n\t\t\t      u8 bssidx,\n\t\t\t      u8 keyidx)\n{\n\tstruct wcn36xx_hal_remove_bss_key_req_msg msg_body;\n\tint ret;\n\n\tmutex_lock(&wcn->hal_mutex);\n\tINIT_HAL_MSG(msg_body, WCN36XX_HAL_RMV_BSSKEY_REQ);\n\tmsg_body.bss_idx = bssidx;\n\tmsg_body.enc_type = enc_type;\n\tmsg_body.key_id = keyidx;\n\n\tPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\n\n\tret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\n\tif (ret) {\n\t\twcn36xx_err(\"Sending hal_remove_bsskey failed\\n\");\n\t\tgoto out;\n\t}\n\tret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\n\tif (ret) {\n\t\twcn36xx_err(\"hal_remove_bsskey response failed err=%d\\n\", ret);\n\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&wcn->hal_mutex);\n\treturn ret;\n}\n\nint wcn36xx_smd_enter_bmps(struct wcn36xx *wcn, struct ieee80211_vif *vif)\n{\n\tstruct wcn36xx_hal_enter_bmps_req_msg msg_body;\n\tstruct wcn36xx_vif *vif_priv = wcn36xx_vif_to_priv(vif);\n\tint ret;\n\n\tmutex_lock(&wcn->hal_mutex);\n\tINIT_HAL_MSG(msg_body, WCN36XX_HAL_ENTER_BMPS_REQ);\n\n\tmsg_body.bss_index = vif_priv->bss_index;\n\tmsg_body.tbtt = vif->bss_conf.sync_tsf;\n\tmsg_body.dtim_period = vif_priv->dtim_period;\n\n\tPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\n\n\tret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\n\tif (ret) {\n\t\twcn36xx_err(\"Sending hal_enter_bmps failed\\n\");\n\t\tgoto out;\n\t}\n\tret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\n\tif (ret) {\n\t\twcn36xx_err(\"hal_enter_bmps response failed err=%d\\n\", ret);\n\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&wcn->hal_mutex);\n\treturn ret;\n}\n\nint wcn36xx_smd_exit_bmps(struct wcn36xx *wcn, struct ieee80211_vif *vif)\n{\n\tstruct wcn36xx_hal_exit_bmps_req_msg msg_body;\n\tstruct wcn36xx_vif *vif_priv = wcn36xx_vif_to_priv(vif);\n\tint ret;\n\n\tmutex_lock(&wcn->hal_mutex);\n\tINIT_HAL_MSG(msg_body, WCN36XX_HAL_EXIT_BMPS_REQ);\n\n\tmsg_body.bss_index = vif_priv->bss_index;\n\tmsg_body.send_data_null = 1;\n\n\tPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\n\n\tret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\n\tif (ret) {\n\t\twcn36xx_err(\"Sending hal_exit_bmps failed\\n\");\n\t\tgoto out;\n\t}\n\tret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\n\tif (ret) {\n\t\twcn36xx_err(\"hal_exit_bmps response failed err=%d\\n\", ret);\n\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&wcn->hal_mutex);\n\treturn ret;\n}\n\nint wcn36xx_smd_enter_imps(struct wcn36xx *wcn)\n{\n\tstruct wcn36xx_hal_enter_imps_req_msg msg_body;\n\tint ret;\n\n\tmutex_lock(&wcn->hal_mutex);\n\tINIT_HAL_MSG(msg_body, WCN36XX_HAL_ENTER_IMPS_REQ);\n\n\tPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\n\n\tret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\n\tif (ret) {\n\t\twcn36xx_err(\"Sending hal_enter_imps failed\\n\");\n\t\tgoto out;\n\t}\n\tret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\n\tif (ret) {\n\t\twcn36xx_err(\"hal_enter_imps response failed err=%d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\twcn36xx_dbg(WCN36XX_DBG_HAL, \"Entered idle mode\\n\");\nout:\n\tmutex_unlock(&wcn->hal_mutex);\n\treturn ret;\n}\n\nint wcn36xx_smd_exit_imps(struct wcn36xx *wcn)\n{\n\tstruct wcn36xx_hal_exit_imps_req_msg msg_body;\n\tint ret;\n\n\tmutex_lock(&wcn->hal_mutex);\n\tINIT_HAL_MSG(msg_body, WCN36XX_HAL_EXIT_IMPS_REQ);\n\n\tPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\n\n\tret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\n\tif (ret) {\n\t\twcn36xx_err(\"Sending hal_exit_imps failed\\n\");\n\t\tgoto out;\n\t}\n\tret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\n\tif (ret) {\n\t\twcn36xx_err(\"hal_exit_imps response failed err=%d\\n\", ret);\n\t\tgoto out;\n\t}\n\twcn36xx_dbg(WCN36XX_DBG_HAL, \"Exited idle mode\\n\");\nout:\n\tmutex_unlock(&wcn->hal_mutex);\n\treturn ret;\n}\n\nint wcn36xx_smd_set_power_params(struct wcn36xx *wcn, bool ignore_dtim)\n{\n\tstruct wcn36xx_hal_set_power_params_req_msg msg_body;\n\tint ret;\n\n\tmutex_lock(&wcn->hal_mutex);\n\tINIT_HAL_MSG(msg_body, WCN36XX_HAL_SET_POWER_PARAMS_REQ);\n\n\t \n\tif (ignore_dtim) {\n\t\tmsg_body.ignore_dtim = 1;\n\t\tmsg_body.dtim_period = 2;\n\t}\n\tmsg_body.listen_interval = WCN36XX_LISTEN_INTERVAL(wcn);\n\n\tPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\n\n\tret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\n\tif (ret) {\n\t\twcn36xx_err(\"Sending hal_set_power_params failed\\n\");\n\t\tgoto out;\n\t}\n\nout:\n\tmutex_unlock(&wcn->hal_mutex);\n\treturn ret;\n}\n\n \nint wcn36xx_smd_keep_alive_req(struct wcn36xx *wcn,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       int packet_type)\n{\n\tstruct wcn36xx_hal_keep_alive_req_msg msg_body;\n\tstruct wcn36xx_vif *vif_priv = wcn36xx_vif_to_priv(vif);\n\tint ret;\n\n\tmutex_lock(&wcn->hal_mutex);\n\tINIT_HAL_MSG(msg_body, WCN36XX_HAL_KEEP_ALIVE_REQ);\n\n\tif (packet_type == WCN36XX_HAL_KEEP_ALIVE_NULL_PKT) {\n\t\tmsg_body.bss_index = vif_priv->bss_index;\n\t\tmsg_body.packet_type = WCN36XX_HAL_KEEP_ALIVE_NULL_PKT;\n\t\tmsg_body.time_period = WCN36XX_KEEP_ALIVE_TIME_PERIOD;\n\t} else if (packet_type == WCN36XX_HAL_KEEP_ALIVE_UNSOLICIT_ARP_RSP) {\n\t\t \n\t} else {\n\t\twcn36xx_warn(\"unknown keep alive packet type %d\\n\", packet_type);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\n\n\tret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\n\tif (ret) {\n\t\twcn36xx_err(\"Sending hal_keep_alive failed\\n\");\n\t\tgoto out;\n\t}\n\tret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\n\tif (ret) {\n\t\twcn36xx_err(\"hal_keep_alive response failed err=%d\\n\", ret);\n\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&wcn->hal_mutex);\n\treturn ret;\n}\n\nint wcn36xx_smd_dump_cmd_req(struct wcn36xx *wcn, u32 arg1, u32 arg2,\n\t\t\t     u32 arg3, u32 arg4, u32 arg5)\n{\n\tstruct wcn36xx_hal_dump_cmd_req_msg msg_body;\n\tint ret;\n\n\tmutex_lock(&wcn->hal_mutex);\n\tINIT_HAL_MSG(msg_body, WCN36XX_HAL_DUMP_COMMAND_REQ);\n\n\tmsg_body.arg1 = arg1;\n\tmsg_body.arg2 = arg2;\n\tmsg_body.arg3 = arg3;\n\tmsg_body.arg4 = arg4;\n\tmsg_body.arg5 = arg5;\n\n\tPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\n\n\tret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\n\tif (ret) {\n\t\twcn36xx_err(\"Sending hal_dump_cmd failed\\n\");\n\t\tgoto out;\n\t}\n\tret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\n\tif (ret) {\n\t\twcn36xx_err(\"hal_dump_cmd response failed err=%d\\n\", ret);\n\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&wcn->hal_mutex);\n\treturn ret;\n}\n\nint wcn36xx_smd_feature_caps_exchange(struct wcn36xx *wcn)\n{\n\tstruct wcn36xx_hal_feat_caps_msg msg_body, *rsp;\n\tint ret, i;\n\n\tmutex_lock(&wcn->hal_mutex);\n\tINIT_HAL_MSG(msg_body, WCN36XX_HAL_FEATURE_CAPS_EXCHANGE_REQ);\n\n\twcn36xx_firmware_set_feat_caps(msg_body.feat_caps, STA_POWERSAVE);\n\tif (wcn->rf_id == RF_IRIS_WCN3680) {\n\t\twcn36xx_firmware_set_feat_caps(msg_body.feat_caps, DOT11AC);\n\t\twcn36xx_firmware_set_feat_caps(msg_body.feat_caps, WLAN_CH144);\n\t\twcn36xx_firmware_set_feat_caps(msg_body.feat_caps,\n\t\t\t\t\t       ANTENNA_DIVERSITY_SELECTION);\n\t}\n\n\tPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\n\n\tret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\n\tif (ret) {\n\t\twcn36xx_err(\"Sending hal_feature_caps_exchange failed\\n\");\n\t\tgoto out;\n\t}\n\tif (wcn->hal_rsp_len != sizeof(*rsp)) {\n\t\twcn36xx_err(\"Invalid hal_feature_caps_exchange response\");\n\t\tgoto out;\n\t}\n\n\trsp = (struct wcn36xx_hal_feat_caps_msg *) wcn->hal_buf;\n\n\tfor (i = 0; i < WCN36XX_HAL_CAPS_SIZE; i++)\n\t\twcn->fw_feat_caps[i] = rsp->feat_caps[i];\nout:\n\tmutex_unlock(&wcn->hal_mutex);\n\treturn ret;\n}\n\nstatic int wcn36xx_smd_add_ba_session_rsp(void *buf, int len, u8 *session)\n{\n\tstruct wcn36xx_hal_add_ba_session_rsp_msg *rsp;\n\n\tif (len < sizeof(*rsp))\n\t\treturn -EINVAL;\n\n\trsp = (struct wcn36xx_hal_add_ba_session_rsp_msg *)buf;\n\tif (rsp->status != WCN36XX_FW_MSG_RESULT_SUCCESS)\n\t\treturn rsp->status;\n\n\t*session = rsp->ba_session_id;\n\n\treturn 0;\n}\n\nint wcn36xx_smd_add_ba_session(struct wcn36xx *wcn,\n\t\tstruct ieee80211_sta *sta,\n\t\tu16 tid,\n\t\tu16 *ssn,\n\t\tu8 direction,\n\t\tu8 sta_index)\n{\n\tstruct wcn36xx_hal_add_ba_session_req_msg msg_body;\n\tu8 session_id;\n\tint ret;\n\n\tmutex_lock(&wcn->hal_mutex);\n\tINIT_HAL_MSG(msg_body, WCN36XX_HAL_ADD_BA_SESSION_REQ);\n\n\tmsg_body.sta_index = sta_index;\n\tmemcpy(&msg_body.mac_addr, sta->addr, ETH_ALEN);\n\tmsg_body.dialog_token = 0x10;\n\tmsg_body.tid = tid;\n\n\t \n\tmsg_body.policy = 1;\n\tmsg_body.buffer_size = WCN36XX_AGGR_BUFFER_SIZE;\n\tmsg_body.timeout = 0;\n\tif (ssn)\n\t\tmsg_body.ssn = *ssn;\n\tmsg_body.direction = direction;\n\n\tPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\n\n\tret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\n\tif (ret) {\n\t\twcn36xx_err(\"Sending hal_add_ba_session failed\\n\");\n\t\tgoto out;\n\t}\n\tret = wcn36xx_smd_add_ba_session_rsp(wcn->hal_buf, wcn->hal_rsp_len,\n\t\t\t\t\t     &session_id);\n\tif (ret) {\n\t\twcn36xx_err(\"hal_add_ba_session response failed err=%d\\n\", ret);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = session_id;\nout:\n\tmutex_unlock(&wcn->hal_mutex);\n\treturn ret;\n}\n\nint wcn36xx_smd_add_ba(struct wcn36xx *wcn, u8 session_id)\n{\n\tstruct wcn36xx_hal_add_ba_req_msg msg_body;\n\tint ret;\n\n\tmutex_lock(&wcn->hal_mutex);\n\tINIT_HAL_MSG(msg_body, WCN36XX_HAL_ADD_BA_REQ);\n\n\tmsg_body.session_id = session_id;\n\tmsg_body.win_size = WCN36XX_AGGR_BUFFER_SIZE;\n\n\tPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\n\n\tret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\n\tif (ret) {\n\t\twcn36xx_err(\"Sending hal_add_ba failed\\n\");\n\t\tgoto out;\n\t}\n\tret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\n\tif (ret) {\n\t\twcn36xx_err(\"hal_add_ba response failed err=%d\\n\", ret);\n\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&wcn->hal_mutex);\n\treturn ret;\n}\n\nint wcn36xx_smd_del_ba(struct wcn36xx *wcn, u16 tid, u8 direction, u8 sta_index)\n{\n\tstruct wcn36xx_hal_del_ba_req_msg msg_body;\n\tint ret;\n\n\tmutex_lock(&wcn->hal_mutex);\n\tINIT_HAL_MSG(msg_body, WCN36XX_HAL_DEL_BA_REQ);\n\n\tmsg_body.sta_index = sta_index;\n\tmsg_body.tid = tid;\n\tmsg_body.direction = direction;\n\tPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\n\n\tret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\n\tif (ret) {\n\t\twcn36xx_err(\"Sending hal_del_ba failed\\n\");\n\t\tgoto out;\n\t}\n\tret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\n\tif (ret) {\n\t\twcn36xx_err(\"hal_del_ba response failed err=%d\\n\", ret);\n\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&wcn->hal_mutex);\n\treturn ret;\n}\n\nint wcn36xx_smd_get_stats(struct wcn36xx *wcn, u8 sta_index, u32 stats_mask,\n\t\t\t  struct station_info *sinfo)\n{\n\tstruct wcn36xx_hal_stats_req_msg msg_body;\n\tstruct wcn36xx_hal_stats_rsp_msg *rsp;\n\tvoid *rsp_body;\n\tint ret;\n\n\tif (stats_mask & ~HAL_GLOBAL_CLASS_A_STATS_INFO) {\n\t\twcn36xx_err(\"stats_mask 0x%x contains unimplemented types\\n\",\n\t\t\t    stats_mask);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&wcn->hal_mutex);\n\tINIT_HAL_MSG(msg_body, WCN36XX_HAL_GET_STATS_REQ);\n\n\tmsg_body.sta_id = sta_index;\n\tmsg_body.stats_mask = stats_mask;\n\n\tPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\n\n\tret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\n\tif (ret) {\n\t\twcn36xx_err(\"sending hal_get_stats failed\\n\");\n\t\tgoto out;\n\t}\n\n\tret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\n\tif (ret) {\n\t\twcn36xx_err(\"hal_get_stats response failed err=%d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\trsp = (struct wcn36xx_hal_stats_rsp_msg *)wcn->hal_buf;\n\trsp_body = (wcn->hal_buf + sizeof(struct wcn36xx_hal_stats_rsp_msg));\n\n\tif (rsp->stats_mask != stats_mask) {\n\t\twcn36xx_err(\"stats_mask 0x%x differs from requested 0x%x\\n\",\n\t\t\t    rsp->stats_mask, stats_mask);\n\t\tgoto out;\n\t}\n\n\tif (rsp->stats_mask & HAL_GLOBAL_CLASS_A_STATS_INFO) {\n\t\tstruct ani_global_class_a_stats_info *stats_info = rsp_body;\n\n\t\twcn36xx_process_tx_rate(stats_info, &sinfo->txrate);\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_BITRATE);\n\t\trsp_body += sizeof(struct ani_global_class_a_stats_info);\n\t}\nout:\n\tmutex_unlock(&wcn->hal_mutex);\n\n\treturn ret;\n}\n\nstatic int wcn36xx_smd_trigger_ba_rsp(void *buf, int len, struct add_ba_info *ba_info)\n{\n\tstruct wcn36xx_hal_trigger_ba_rsp_candidate *candidate;\n\tstruct wcn36xx_hal_trigger_ba_rsp_msg *rsp;\n\tint i;\n\n\tif (len < sizeof(*rsp))\n\t\treturn -EINVAL;\n\n\trsp = (struct wcn36xx_hal_trigger_ba_rsp_msg *) buf;\n\n\tif (rsp->candidate_cnt < 1)\n\t\treturn rsp->status ? rsp->status : -EINVAL;\n\n\tcandidate = (struct wcn36xx_hal_trigger_ba_rsp_candidate *)(buf + sizeof(*rsp));\n\n\tfor (i = 0; i < STACFG_MAX_TC; i++) {\n\t\tba_info[i] = candidate->ba_info[i];\n\t}\n\n\treturn rsp->status;\n}\n\nint wcn36xx_smd_trigger_ba(struct wcn36xx *wcn, u8 sta_index, u16 tid, u16 *ssn)\n{\n\tstruct wcn36xx_hal_trigger_ba_req_msg msg_body;\n\tstruct wcn36xx_hal_trigger_ba_req_candidate *candidate;\n\tstruct add_ba_info ba_info[STACFG_MAX_TC];\n\tint ret;\n\n\tif (tid >= STACFG_MAX_TC)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&wcn->hal_mutex);\n\tINIT_HAL_MSG(msg_body, WCN36XX_HAL_TRIGGER_BA_REQ);\n\n\tmsg_body.session_id = 0;  \n\tmsg_body.candidate_cnt = 1;\n\tmsg_body.header.len += sizeof(*candidate);\n\tPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\n\n\tcandidate = (struct wcn36xx_hal_trigger_ba_req_candidate *)\n\t\t(wcn->hal_buf + sizeof(msg_body));\n\tcandidate->sta_index = sta_index;\n\tcandidate->tid_bitmap = 1 << tid;\n\n\tret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\n\tif (ret) {\n\t\twcn36xx_err(\"Sending hal_trigger_ba failed\\n\");\n\t\tgoto out;\n\t}\n\tret = wcn36xx_smd_trigger_ba_rsp(wcn->hal_buf, wcn->hal_rsp_len, ba_info);\n\tif (ret) {\n\t\twcn36xx_err(\"hal_trigger_ba response failed err=%d\\n\", ret);\n\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&wcn->hal_mutex);\n\n\tif (ssn)\n\t\t*ssn = ba_info[tid].starting_seq_num;\n\n\treturn ret;\n}\n\nstatic int wcn36xx_smd_tx_compl_ind(struct wcn36xx *wcn, void *buf, size_t len)\n{\n\tstruct wcn36xx_hal_tx_compl_ind_msg *rsp = buf;\n\n\tif (len != sizeof(*rsp)) {\n\t\twcn36xx_warn(\"Bad TX complete indication\\n\");\n\t\treturn -EIO;\n\t}\n\n\twcn36xx_dxe_tx_ack_ind(wcn, rsp->status);\n\n\treturn 0;\n}\n\nstatic int wcn36xx_smd_hw_scan_ind(struct wcn36xx *wcn, void *buf, size_t len)\n{\n\tstruct wcn36xx_hal_scan_offload_ind *rsp = buf;\n\tstruct cfg80211_scan_info scan_info = {};\n\n\tif (len != sizeof(*rsp)) {\n\t\twcn36xx_warn(\"Corrupted delete scan indication\\n\");\n\t\treturn -EIO;\n\t}\n\n\twcn36xx_dbg(WCN36XX_DBG_HAL, \"scan indication (type %x)\\n\", rsp->type);\n\n\tswitch (rsp->type) {\n\tcase WCN36XX_HAL_SCAN_IND_FAILED:\n\tcase WCN36XX_HAL_SCAN_IND_DEQUEUED:\n\t\tscan_info.aborted = true;\n\t\tfallthrough;\n\tcase WCN36XX_HAL_SCAN_IND_COMPLETED:\n\t\tmutex_lock(&wcn->scan_lock);\n\t\twcn->scan_req = NULL;\n\t\tif (wcn->scan_aborted)\n\t\t\tscan_info.aborted = true;\n\t\tmutex_unlock(&wcn->scan_lock);\n\t\tieee80211_scan_completed(wcn->hw, &scan_info);\n\t\tbreak;\n\tcase WCN36XX_HAL_SCAN_IND_STARTED:\n\tcase WCN36XX_HAL_SCAN_IND_FOREIGN_CHANNEL:\n\tcase WCN36XX_HAL_SCAN_IND_PREEMPTED:\n\tcase WCN36XX_HAL_SCAN_IND_RESTARTED:\n\t\tbreak;\n\tdefault:\n\t\twcn36xx_warn(\"Unknown scan indication type %x\\n\", rsp->type);\n\t}\n\n\treturn 0;\n}\n\nstatic int wcn36xx_smd_missed_beacon_ind(struct wcn36xx *wcn,\n\t\t\t\t\t void *buf,\n\t\t\t\t\t size_t len)\n{\n\tstruct wcn36xx_hal_missed_beacon_ind_msg *rsp = buf;\n\tstruct ieee80211_vif *vif = NULL;\n\tstruct wcn36xx_vif *tmp;\n\n\t \n\tif (wcn36xx_is_fw_version(wcn, 1, 2, 2, 24)) {\n\t\tlist_for_each_entry(tmp, &wcn->vif_list, list) {\n\t\t\twcn36xx_dbg(WCN36XX_DBG_HAL, \"beacon missed bss_index %d\\n\",\n\t\t\t\t    tmp->bss_index);\n\t\t\tvif = wcn36xx_priv_to_vif(tmp);\n\t\t\tieee80211_beacon_loss(vif);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (len != sizeof(*rsp)) {\n\t\twcn36xx_warn(\"Corrupted missed beacon indication\\n\");\n\t\treturn -EIO;\n\t}\n\n\tlist_for_each_entry(tmp, &wcn->vif_list, list) {\n\t\tif (tmp->bss_index == rsp->bss_index) {\n\t\t\twcn36xx_dbg(WCN36XX_DBG_HAL, \"beacon missed bss_index %d\\n\",\n\t\t\t\t    rsp->bss_index);\n\t\t\tvif = wcn36xx_priv_to_vif(tmp);\n\t\t\tieee80211_beacon_loss(vif);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\twcn36xx_warn(\"BSS index %d not found\\n\", rsp->bss_index);\n\treturn -ENOENT;\n}\n\nstatic int wcn36xx_smd_delete_sta_context_ind(struct wcn36xx *wcn,\n\t\t\t\t\t      void *buf,\n\t\t\t\t\t      size_t len)\n{\n\tstruct wcn36xx_hal_delete_sta_context_ind_msg *rsp = buf;\n\tstruct wcn36xx_vif *vif_priv;\n\tstruct ieee80211_vif *vif;\n\tstruct ieee80211_bss_conf *bss_conf;\n\tstruct ieee80211_sta *sta;\n\tbool found = false;\n\n\tif (len != sizeof(*rsp)) {\n\t\twcn36xx_warn(\"Corrupted delete sta indication\\n\");\n\t\treturn -EIO;\n\t}\n\n\twcn36xx_dbg(WCN36XX_DBG_HAL,\n\t\t    \"delete station indication %pM index %d reason %d\\n\",\n\t\t    rsp->addr2, rsp->sta_id, rsp->reason_code);\n\n\tlist_for_each_entry(vif_priv, &wcn->vif_list, list) {\n\t\trcu_read_lock();\n\t\tvif = wcn36xx_priv_to_vif(vif_priv);\n\n\t\tif (vif->type == NL80211_IFTYPE_STATION) {\n\t\t\t \n\t\t\tbss_conf = &vif->bss_conf;\n\t\t\tif (vif_priv->sta_assoc &&\n\t\t\t    !memcmp(bss_conf->bssid, rsp->addr2, ETH_ALEN)) {\n\t\t\t\tfound = true;\n\t\t\t\twcn36xx_dbg(WCN36XX_DBG_HAL,\n\t\t\t\t\t    \"connection loss bss_index %d\\n\",\n\t\t\t\t\t    vif_priv->bss_index);\n\t\t\t\tieee80211_connection_loss(vif);\n\t\t\t}\n\t\t} else {\n\t\t\tsta = ieee80211_find_sta(vif, rsp->addr2);\n\t\t\tif (sta) {\n\t\t\t\tfound = true;\n\t\t\t\tieee80211_report_low_ack(sta, 0);\n\t\t\t}\n\t\t}\n\n\t\trcu_read_unlock();\n\t\tif (found)\n\t\t\treturn 0;\n\t}\n\n\twcn36xx_warn(\"BSS or STA with addr %pM not found\\n\", rsp->addr2);\n\treturn -ENOENT;\n}\n\nstatic int wcn36xx_smd_print_reg_info_ind(struct wcn36xx *wcn,\n\t\t\t\t\t  void *buf,\n\t\t\t\t\t  size_t len)\n{\n\tstruct wcn36xx_hal_print_reg_info_ind *rsp = buf;\n\tint i;\n\n\tif (len < sizeof(*rsp)) {\n\t\twcn36xx_warn(\"Corrupted print reg info indication\\n\");\n\t\treturn -EIO;\n\t}\n\n\twcn36xx_dbg(WCN36XX_DBG_HAL,\n\t\t    \"reginfo indication, scenario: 0x%x reason: 0x%x\\n\",\n\t\t    rsp->scenario, rsp->reason);\n\n\tfor (i = 0; i < rsp->count; i++) {\n\t\twcn36xx_dbg(WCN36XX_DBG_HAL, \"\\t0x%x: 0x%x\\n\",\n\t\t\t    rsp->regs[i].addr, rsp->regs[i].value);\n\t}\n\n\treturn 0;\n}\n\nint wcn36xx_smd_update_cfg(struct wcn36xx *wcn, u32 cfg_id, u32 value)\n{\n\tstruct wcn36xx_hal_update_cfg_req_msg msg_body, *body;\n\tsize_t len;\n\tint ret;\n\n\tmutex_lock(&wcn->hal_mutex);\n\tINIT_HAL_MSG(msg_body, WCN36XX_HAL_UPDATE_CFG_REQ);\n\n\tPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\n\n\tbody = (struct wcn36xx_hal_update_cfg_req_msg *) wcn->hal_buf;\n\tlen = msg_body.header.len;\n\n\tput_cfg_tlv_u32(wcn, &len, cfg_id, value);\n\tbody->header.len = len;\n\tbody->len = len - sizeof(*body);\n\n\tret = wcn36xx_smd_send_and_wait(wcn, body->header.len);\n\tif (ret) {\n\t\twcn36xx_err(\"Sending hal_update_cfg failed\\n\");\n\t\tgoto out;\n\t}\n\tret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\n\tif (ret) {\n\t\twcn36xx_err(\"hal_update_cfg response failed err=%d\\n\", ret);\n\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&wcn->hal_mutex);\n\treturn ret;\n}\n\nint wcn36xx_smd_set_mc_list(struct wcn36xx *wcn,\n\t\t\t    struct ieee80211_vif *vif,\n\t\t\t    struct wcn36xx_hal_rcv_flt_mc_addr_list_type *fp)\n{\n\tstruct wcn36xx_vif *vif_priv = wcn36xx_vif_to_priv(vif);\n\tstruct wcn36xx_hal_rcv_flt_pkt_set_mc_list_req_msg *msg_body = NULL;\n\tint ret;\n\n\tmutex_lock(&wcn->hal_mutex);\n\n\tmsg_body = (struct wcn36xx_hal_rcv_flt_pkt_set_mc_list_req_msg *)\n\t\t   wcn->hal_buf;\n\tINIT_HAL_MSG(*msg_body, WCN36XX_HAL_8023_MULTICAST_LIST_REQ);\n\n\t \n\tif (fp)\n\t\tmemcpy(&msg_body->mc_addr_list, fp,\n\t\t       sizeof(msg_body->mc_addr_list));\n\telse\n\t\tmsg_body->mc_addr_list.mc_addr_count = 0;\n\n\tmsg_body->mc_addr_list.bss_index = vif_priv->bss_index;\n\n\tret = wcn36xx_smd_send_and_wait(wcn, msg_body->header.len);\n\tif (ret) {\n\t\twcn36xx_err(\"Sending HAL_8023_MULTICAST_LIST failed\\n\");\n\t\tgoto out;\n\t}\n\tret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\n\tif (ret) {\n\t\twcn36xx_err(\"HAL_8023_MULTICAST_LIST rsp failed err=%d\\n\", ret);\n\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&wcn->hal_mutex);\n\treturn ret;\n}\n\nint wcn36xx_smd_arp_offload(struct wcn36xx *wcn, struct ieee80211_vif *vif,\n\t\t\t    bool enable)\n{\n\tstruct wcn36xx_vif *vif_priv = wcn36xx_vif_to_priv(vif);\n\tstruct wcn36xx_hal_host_offload_req_msg msg_body;\n\tint ret;\n\n\tmutex_lock(&wcn->hal_mutex);\n\n\tINIT_HAL_MSG(msg_body, WCN36XX_HAL_HOST_OFFLOAD_REQ);\n\tmsg_body.host_offload_params.offload_type =\n\t\tWCN36XX_HAL_IPV4_ARP_REPLY_OFFLOAD;\n\tif (enable) {\n\t\tmsg_body.host_offload_params.enable =\n\t\t\tWCN36XX_HAL_OFFLOAD_ARP_AND_BCAST_FILTER_ENABLE;\n\t\tmemcpy(&msg_body.host_offload_params.u,\n\t\t       &vif->cfg.arp_addr_list[0], sizeof(__be32));\n\t}\n\tmsg_body.ns_offload_params.bss_index = vif_priv->bss_index;\n\n\tPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\n\n\tret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\n\tif (ret) {\n\t\twcn36xx_err(\"Sending host_offload_arp failed\\n\");\n\t\tgoto out;\n\t}\n\tret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\n\tif (ret) {\n\t\twcn36xx_err(\"host_offload_arp failed err=%d\\n\", ret);\n\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&wcn->hal_mutex);\n\treturn ret;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nint wcn36xx_smd_ipv6_ns_offload(struct wcn36xx *wcn, struct ieee80211_vif *vif,\n\t\t\t\tbool enable)\n{\n\tstruct wcn36xx_vif *vif_priv = wcn36xx_vif_to_priv(vif);\n\tstruct wcn36xx_hal_host_offload_req_msg msg_body;\n\tstruct wcn36xx_hal_ns_offload_params *ns_params;\n\tstruct wcn36xx_hal_host_offload_req *ho_params;\n\tint ret;\n\n\tmutex_lock(&wcn->hal_mutex);\n\n\tINIT_HAL_MSG(msg_body, WCN36XX_HAL_HOST_OFFLOAD_REQ);\n\tho_params = &msg_body.host_offload_params;\n\tns_params = &msg_body.ns_offload_params;\n\n\tho_params->offload_type = WCN36XX_HAL_IPV6_NS_OFFLOAD;\n\tif (enable) {\n\t\tho_params->enable =\n\t\t\tWCN36XX_HAL_OFFLOAD_NS_AND_MCAST_FILTER_ENABLE;\n\t\tif (vif_priv->num_target_ipv6_addrs) {\n\t\t\tmemcpy(&ho_params->u,\n\t\t\t       &vif_priv->target_ipv6_addrs[0].in6_u,\n\t\t\t       sizeof(struct in6_addr));\n\t\t\tmemcpy(&ns_params->target_ipv6_addr1,\n\t\t\t       &vif_priv->target_ipv6_addrs[0].in6_u,\n\t\t\t       sizeof(struct in6_addr));\n\t\t\tns_params->target_ipv6_addr1_valid = 1;\n\t\t}\n\t\tif (vif_priv->num_target_ipv6_addrs > 1) {\n\t\t\tmemcpy(&ns_params->target_ipv6_addr2,\n\t\t\t       &vif_priv->target_ipv6_addrs[1].in6_u,\n\t\t\t       sizeof(struct in6_addr));\n\t\t\tns_params->target_ipv6_addr2_valid = 1;\n\t\t}\n\t}\n\tmemcpy(&ns_params->self_addr, vif->addr, ETH_ALEN);\n\tns_params->bss_index = vif_priv->bss_index;\n\n\tPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\n\n\tret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\n\tif (ret) {\n\t\twcn36xx_err(\"Sending host_offload_arp failed\\n\");\n\t\tgoto out;\n\t}\n\tret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\n\tif (ret) {\n\t\twcn36xx_err(\"host_offload_arp failed err=%d\\n\", ret);\n\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&wcn->hal_mutex);\n\treturn ret;\n}\n#else\nint wcn36xx_smd_ipv6_ns_offload(struct wcn36xx *wcn, struct ieee80211_vif *vif,\n\t\t\t\tbool enable)\n{\n\treturn 0;\n}\n#endif\n\nint wcn36xx_smd_gtk_offload(struct wcn36xx *wcn, struct ieee80211_vif *vif,\n\t\t\t    bool enable)\n{\n\tstruct wcn36xx_vif *vif_priv = wcn36xx_vif_to_priv(vif);\n\tstruct wcn36xx_hal_gtk_offload_req_msg msg_body;\n\tint ret;\n\n\tmutex_lock(&wcn->hal_mutex);\n\n\tINIT_HAL_MSG(msg_body, WCN36XX_HAL_GTK_OFFLOAD_REQ);\n\n\tif (enable) {\n\t\tmemcpy(&msg_body.kek, vif_priv->rekey_data.kek, NL80211_KEK_LEN);\n\t\tmemcpy(&msg_body.kck, vif_priv->rekey_data.kck, NL80211_KCK_LEN);\n\t\tmsg_body.key_replay_counter =\n\t\t\tle64_to_cpu(vif_priv->rekey_data.replay_ctr);\n\t\tmsg_body.bss_index = vif_priv->bss_index;\n\t} else {\n\t\tmsg_body.flags = WCN36XX_HAL_GTK_OFFLOAD_FLAGS_DISABLE;\n\t}\n\n\tPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\n\n\tret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\n\tif (ret) {\n\t\twcn36xx_err(\"Sending host_offload_arp failed\\n\");\n\t\tgoto out;\n\t}\n\tret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\n\tif (ret) {\n\t\twcn36xx_err(\"host_offload_arp failed err=%d\\n\", ret);\n\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&wcn->hal_mutex);\n\treturn ret;\n}\n\nstatic int wcn36xx_smd_gtk_offload_get_info_rsp(struct wcn36xx *wcn,\n\t\t\t\t\t\tstruct ieee80211_vif *vif)\n{\n\tstruct wcn36xx_vif *vif_priv = wcn36xx_vif_to_priv(vif);\n\tstruct wcn36xx_hal_gtk_offload_get_info_rsp_msg *rsp;\n\t__be64 replay_ctr;\n\n\tif (wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len))\n\t\treturn -EIO;\n\n\trsp = (struct wcn36xx_hal_gtk_offload_get_info_rsp_msg *)wcn->hal_buf;\n\n\tif (rsp->bss_index != vif_priv->bss_index) {\n\t\twcn36xx_err(\"gtk_offload_info invalid response bss index %d\\n\",\n\t\t\t    rsp->bss_index);\n\t\treturn -ENOENT;\n\t}\n\n\tif (vif_priv->rekey_data.replay_ctr != cpu_to_le64(rsp->key_replay_counter)) {\n\t\treplay_ctr = cpu_to_be64(rsp->key_replay_counter);\n\t\tvif_priv->rekey_data.replay_ctr =\n\t\t\tcpu_to_le64(rsp->key_replay_counter);\n\t\tieee80211_gtk_rekey_notify(vif, vif->bss_conf.bssid,\n\t\t\t\t\t   (void *)&replay_ctr, GFP_KERNEL);\n\t\twcn36xx_dbg(WCN36XX_DBG_HAL,\n\t\t\t    \"GTK replay counter increment %llu\\n\",\n\t\t\t    rsp->key_replay_counter);\n\t}\n\n\twcn36xx_dbg(WCN36XX_DBG_HAL,\n\t\t    \"gtk offload info status %d last_rekey_status %d \"\n\t\t    \"replay_counter %llu total_rekey_count %d gtk_rekey_count %d \"\n\t\t    \"igtk_rekey_count %d bss_index %d\\n\",\n\t\t    rsp->status, rsp->last_rekey_status,\n\t\t    rsp->key_replay_counter, rsp->total_rekey_count,\n\t\t    rsp->gtk_rekey_count, rsp->igtk_rekey_count,\n\t\t    rsp->bss_index);\n\n\treturn 0;\n}\n\nint wcn36xx_smd_gtk_offload_get_info(struct wcn36xx *wcn,\n\t\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct wcn36xx_vif *vif_priv = wcn36xx_vif_to_priv(vif);\n\tstruct wcn36xx_hal_gtk_offload_get_info_req_msg msg_body;\n\tint ret;\n\n\tmutex_lock(&wcn->hal_mutex);\n\n\tINIT_HAL_MSG(msg_body, WCN36XX_HAL_GTK_OFFLOAD_GETINFO_REQ);\n\n\tmsg_body.bss_index = vif_priv->bss_index;\n\n\tPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\n\n\tret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\n\tif (ret) {\n\t\twcn36xx_err(\"Sending gtk_offload_get_info failed\\n\");\n\t\tgoto out;\n\t}\n\tret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\n\tif (ret) {\n\t\twcn36xx_err(\"gtk_offload_get_info failed err=%d\\n\", ret);\n\t\tgoto out;\n\t}\n\tret = wcn36xx_smd_gtk_offload_get_info_rsp(wcn, vif);\nout:\n\tmutex_unlock(&wcn->hal_mutex);\n\treturn ret;\n}\n\nint wcn36xx_smd_wlan_host_suspend_ind(struct wcn36xx *wcn)\n{\n\tstruct wcn36xx_hal_wlan_host_suspend_ind_msg msg_body;\n\tint ret;\n\n\tmutex_lock(&wcn->hal_mutex);\n\n\tINIT_HAL_MSG(msg_body, WCN36XX_HAL_HOST_SUSPEND_IND);\n\tmsg_body.configured_mcst_bcst_filter_setting = 0;\n\tmsg_body.active_session_count = 1;\n\tPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\n\n\tret = rpmsg_send(wcn->smd_channel, wcn->hal_buf, msg_body.header.len);\n\n\tmutex_unlock(&wcn->hal_mutex);\n\n\treturn ret;\n}\n\nint wcn36xx_smd_host_resume(struct wcn36xx *wcn)\n{\n\tstruct wcn36xx_hal_wlan_host_resume_req_msg msg_body;\n\tstruct wcn36xx_hal_host_resume_rsp_msg *rsp;\n\tint ret;\n\n\tmutex_lock(&wcn->hal_mutex);\n\n\tINIT_HAL_MSG(msg_body, WCN36XX_HAL_HOST_RESUME_REQ);\n\tmsg_body.configured_mcst_bcst_filter_setting = 0;\n\n\tPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\n\n\tret = wcn36xx_smd_send_and_wait(wcn, msg_body.header.len);\n\tif (ret) {\n\t\twcn36xx_err(\"Sending wlan_host_resume failed\\n\");\n\t\tgoto out;\n\t}\n\tret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\n\tif (ret) {\n\t\twcn36xx_err(\"wlan_host_resume err=%d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\trsp = (struct wcn36xx_hal_host_resume_rsp_msg *)wcn->hal_buf;\n\tif (rsp->status)\n\t\twcn36xx_warn(\"wlan_host_resume status=%d\\n\", rsp->status);\n\nout:\n\tmutex_unlock(&wcn->hal_mutex);\n\n\treturn ret;\n}\n\n#define BEACON_FILTER(eid, presence, offs, val, mask, ref_val) \\\n\t{\t\t\t\t\t\\\n\t\t.element_id = eid,\t\t\\\n\t\t.check_ie_presence = presence,\t\\\n\t\t.offset = offs,\t\t\t\\\n\t\t.value = val,\t\t\t\\\n\t\t.bitmask = mask,\t\t\\\n\t\t.ref = ref_val,\t\t\t\\\n\t}\n\nstatic const struct beacon_filter_ie bcn_filter_ies[] = {\n\tBEACON_FILTER(WLAN_EID_DS_PARAMS, 0, 0, 0,\n\t\t      WCN36XX_FILTER_IE_DS_CHANNEL_MASK, 0),\n\tBEACON_FILTER(WLAN_EID_ERP_INFO, 0, 0, 0,\n\t\t      WCN36XX_FILTER_IE_ERP_FILTER_MASK, 0),\n\tBEACON_FILTER(WLAN_EID_EDCA_PARAM_SET, 0, 0, 0,\n\t\t      WCN36XX_FILTER_IE_EDCA_FILTER_MASK, 0),\n\tBEACON_FILTER(WLAN_EID_QOS_CAPA, 0, 0, 0,\n\t\t      WCN36XX_FILTER_IE_QOS_FILTER_MASK, 0),\n\tBEACON_FILTER(WLAN_EID_CHANNEL_SWITCH, 1, 0, 0,\n\t\t      WCN36XX_FILTER_IE_CHANNEL_SWITCH_MASK, 0),\n\tBEACON_FILTER(WLAN_EID_HT_OPERATION, 0, 0, 0,\n\t\t      WCN36XX_FILTER_IE_HT_BYTE0_FILTER_MASK, 0),\n\tBEACON_FILTER(WLAN_EID_HT_OPERATION, 0, 2, 0,\n\t\t      WCN36XX_FILTER_IE_HT_BYTE2_FILTER_MASK, 0),\n\tBEACON_FILTER(WLAN_EID_HT_OPERATION, 0, 5, 0,\n\t\t      WCN36XX_FILTER_IE_HT_BYTE5_FILTER_MASK, 0),\n\tBEACON_FILTER(WLAN_EID_PWR_CONSTRAINT, 0, 0, 0,\n\t\t      WCN36XX_FILTER_IE_PWR_CONSTRAINT_MASK, 0),\n\tBEACON_FILTER(WLAN_EID_OPMODE_NOTIF, 0, 0, 0,\n\t\t      WCN36XX_FILTER_IE_OPMODE_NOTIF_MASK, 0),\n\tBEACON_FILTER(WLAN_EID_VHT_OPERATION, 0, 0, 0,\n\t\t      WCN36XX_FILTER_IE_VHTOP_CHWIDTH_MASK, 0),\n\tBEACON_FILTER(WLAN_EID_RSN, 1, 0, 0,\n\t\t      WCN36XX_FILTER_IE_RSN_MASK, 0),\n\tBEACON_FILTER(WLAN_EID_VENDOR_SPECIFIC, 1, 0, 0,\n\t\t      WCN36XX_FILTER_IE_VENDOR_MASK, 0),\n};\n\nint wcn36xx_smd_add_beacon_filter(struct wcn36xx *wcn,\n\t\t\t\t  struct ieee80211_vif *vif)\n{\n\tstruct wcn36xx_hal_add_bcn_filter_req_msg msg_body, *body;\n\tstruct wcn36xx_vif *vif_priv = wcn36xx_vif_to_priv(vif);\n\tu8 *payload;\n\tsize_t payload_size;\n\tint ret;\n\n\tif (!wcn36xx_firmware_get_feat_caps(wcn->fw_feat_caps, BCN_FILTER))\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&wcn->hal_mutex);\n\tINIT_HAL_MSG(msg_body, WCN36XX_HAL_ADD_BCN_FILTER_REQ);\n\n\tPREPARE_HAL_BUF(wcn->hal_buf, msg_body);\n\n\tbody = (struct wcn36xx_hal_add_bcn_filter_req_msg *)wcn->hal_buf;\n\tbody->capability_info = vif->bss_conf.assoc_capability;\n\tbody->capability_mask = WCN36XX_FILTER_CAPABILITY_MASK;\n\tbody->beacon_interval = vif->bss_conf.beacon_int;\n\tbody->ie_num = ARRAY_SIZE(bcn_filter_ies);\n\tbody->bss_index = vif_priv->bss_index;\n\n\tpayload = ((u8 *)body) + body->header.len;\n\tpayload_size = sizeof(bcn_filter_ies);\n\tmemcpy(payload, &bcn_filter_ies, payload_size);\n\n\tbody->header.len += payload_size;\n\n\tret = wcn36xx_smd_send_and_wait(wcn, body->header.len);\n\tif (ret) {\n\t\twcn36xx_err(\"Sending add bcn_filter failed\\n\");\n\t\tgoto out;\n\t}\n\n\tret = wcn36xx_smd_rsp_status_check(wcn->hal_buf, wcn->hal_rsp_len);\n\tif (ret) {\n\t\twcn36xx_err(\"add bcn filter response failed err=%d\\n\", ret);\n\t\tgoto out;\n\t}\nout:\n\tmutex_unlock(&wcn->hal_mutex);\n\treturn ret;\n}\n\nint wcn36xx_smd_rsp_process(struct rpmsg_device *rpdev,\n\t\t\t    void *buf, int len, void *priv, u32 addr)\n{\n\tconst struct wcn36xx_hal_msg_header *msg_header = buf;\n\tstruct ieee80211_hw *hw = priv;\n\tstruct wcn36xx *wcn = hw->priv;\n\tstruct wcn36xx_hal_ind_msg *msg_ind;\n\twcn36xx_dbg_dump(WCN36XX_DBG_SMD_DUMP, \"SMD <<< \", buf, len);\n\n\tswitch (msg_header->msg_type) {\n\tcase WCN36XX_HAL_START_RSP:\n\tcase WCN36XX_HAL_CONFIG_STA_RSP:\n\tcase WCN36XX_HAL_CONFIG_BSS_RSP:\n\tcase WCN36XX_HAL_ADD_STA_SELF_RSP:\n\tcase WCN36XX_HAL_STOP_RSP:\n\tcase WCN36XX_HAL_DEL_STA_SELF_RSP:\n\tcase WCN36XX_HAL_DELETE_STA_RSP:\n\tcase WCN36XX_HAL_INIT_SCAN_RSP:\n\tcase WCN36XX_HAL_START_SCAN_RSP:\n\tcase WCN36XX_HAL_END_SCAN_RSP:\n\tcase WCN36XX_HAL_FINISH_SCAN_RSP:\n\tcase WCN36XX_HAL_DOWNLOAD_NV_RSP:\n\tcase WCN36XX_HAL_DELETE_BSS_RSP:\n\tcase WCN36XX_HAL_SEND_BEACON_RSP:\n\tcase WCN36XX_HAL_SET_LINK_ST_RSP:\n\tcase WCN36XX_HAL_UPDATE_PROBE_RSP_TEMPLATE_RSP:\n\tcase WCN36XX_HAL_SET_BSSKEY_RSP:\n\tcase WCN36XX_HAL_SET_STAKEY_RSP:\n\tcase WCN36XX_HAL_RMV_STAKEY_RSP:\n\tcase WCN36XX_HAL_RMV_BSSKEY_RSP:\n\tcase WCN36XX_HAL_ENTER_BMPS_RSP:\n\tcase WCN36XX_HAL_SET_POWER_PARAMS_RSP:\n\tcase WCN36XX_HAL_EXIT_BMPS_RSP:\n\tcase WCN36XX_HAL_KEEP_ALIVE_RSP:\n\tcase WCN36XX_HAL_DUMP_COMMAND_RSP:\n\tcase WCN36XX_HAL_ADD_BA_SESSION_RSP:\n\tcase WCN36XX_HAL_ADD_BA_RSP:\n\tcase WCN36XX_HAL_DEL_BA_RSP:\n\tcase WCN36XX_HAL_GET_STATS_RSP:\n\tcase WCN36XX_HAL_TRIGGER_BA_RSP:\n\tcase WCN36XX_HAL_UPDATE_CFG_RSP:\n\tcase WCN36XX_HAL_JOIN_RSP:\n\tcase WCN36XX_HAL_UPDATE_SCAN_PARAM_RSP:\n\tcase WCN36XX_HAL_CH_SWITCH_RSP:\n\tcase WCN36XX_HAL_PROCESS_PTT_RSP:\n\tcase WCN36XX_HAL_FEATURE_CAPS_EXCHANGE_RSP:\n\tcase WCN36XX_HAL_8023_MULTICAST_LIST_RSP:\n\tcase WCN36XX_HAL_START_SCAN_OFFLOAD_RSP:\n\tcase WCN36XX_HAL_STOP_SCAN_OFFLOAD_RSP:\n\tcase WCN36XX_HAL_HOST_OFFLOAD_RSP:\n\tcase WCN36XX_HAL_GTK_OFFLOAD_RSP:\n\tcase WCN36XX_HAL_GTK_OFFLOAD_GETINFO_RSP:\n\tcase WCN36XX_HAL_HOST_RESUME_RSP:\n\tcase WCN36XX_HAL_ENTER_IMPS_RSP:\n\tcase WCN36XX_HAL_EXIT_IMPS_RSP:\n\tcase WCN36XX_HAL_UPDATE_CHANNEL_LIST_RSP:\n\tcase WCN36XX_HAL_ADD_BCN_FILTER_RSP:\n\t\tmemcpy(wcn->hal_buf, buf, len);\n\t\twcn->hal_rsp_len = len;\n\t\tcomplete(&wcn->hal_rsp_compl);\n\t\tbreak;\n\n\tcase WCN36XX_HAL_COEX_IND:\n\tcase WCN36XX_HAL_AVOID_FREQ_RANGE_IND:\n\tcase WCN36XX_HAL_DEL_BA_IND:\n\tcase WCN36XX_HAL_OTA_TX_COMPL_IND:\n\tcase WCN36XX_HAL_MISSED_BEACON_IND:\n\tcase WCN36XX_HAL_DELETE_STA_CONTEXT_IND:\n\tcase WCN36XX_HAL_PRINT_REG_INFO_IND:\n\tcase WCN36XX_HAL_SCAN_OFFLOAD_IND:\n\t\tmsg_ind = kmalloc(struct_size(msg_ind, msg, len), GFP_ATOMIC);\n\t\tif (!msg_ind) {\n\t\t\twcn36xx_err(\"Run out of memory while handling SMD_EVENT (%d)\\n\",\n\t\t\t\t    msg_header->msg_type);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tmsg_ind->msg_len = len;\n\t\tmemcpy(msg_ind->msg, buf, len);\n\n\t\tspin_lock(&wcn->hal_ind_lock);\n\t\tlist_add_tail(&msg_ind->list, &wcn->hal_ind_queue);\n\t\tqueue_work(wcn->hal_ind_wq, &wcn->hal_ind_work);\n\t\tspin_unlock(&wcn->hal_ind_lock);\n\t\twcn36xx_dbg(WCN36XX_DBG_HAL, \"indication arrived\\n\");\n\t\tbreak;\n\tdefault:\n\t\twcn36xx_err(\"SMD_EVENT (%d) not supported\\n\",\n\t\t\t      msg_header->msg_type);\n\t}\n\n\treturn 0;\n}\n\nstatic void wcn36xx_ind_smd_work(struct work_struct *work)\n{\n\tstruct wcn36xx *wcn =\n\t\tcontainer_of(work, struct wcn36xx, hal_ind_work);\n\n\tfor (;;) {\n\t\tstruct wcn36xx_hal_msg_header *msg_header;\n\t\tstruct wcn36xx_hal_ind_msg *hal_ind_msg;\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&wcn->hal_ind_lock, flags);\n\n\t\tif (list_empty(&wcn->hal_ind_queue)) {\n\t\t\tspin_unlock_irqrestore(&wcn->hal_ind_lock, flags);\n\t\t\treturn;\n\t\t}\n\n\t\thal_ind_msg = list_first_entry(&wcn->hal_ind_queue,\n\t\t\t\t\t       struct wcn36xx_hal_ind_msg,\n\t\t\t\t\t       list);\n\t\tlist_del(&hal_ind_msg->list);\n\t\tspin_unlock_irqrestore(&wcn->hal_ind_lock, flags);\n\n\t\tmsg_header = (struct wcn36xx_hal_msg_header *)hal_ind_msg->msg;\n\n\t\tswitch (msg_header->msg_type) {\n\t\tcase WCN36XX_HAL_COEX_IND:\n\t\tcase WCN36XX_HAL_DEL_BA_IND:\n\t\tcase WCN36XX_HAL_AVOID_FREQ_RANGE_IND:\n\t\t\tbreak;\n\t\tcase WCN36XX_HAL_OTA_TX_COMPL_IND:\n\t\t\twcn36xx_smd_tx_compl_ind(wcn,\n\t\t\t\t\t\t hal_ind_msg->msg,\n\t\t\t\t\t\t hal_ind_msg->msg_len);\n\t\t\tbreak;\n\t\tcase WCN36XX_HAL_MISSED_BEACON_IND:\n\t\t\twcn36xx_smd_missed_beacon_ind(wcn,\n\t\t\t\t\t\t      hal_ind_msg->msg,\n\t\t\t\t\t\t      hal_ind_msg->msg_len);\n\t\t\tbreak;\n\t\tcase WCN36XX_HAL_DELETE_STA_CONTEXT_IND:\n\t\t\twcn36xx_smd_delete_sta_context_ind(wcn,\n\t\t\t\t\t\t\t   hal_ind_msg->msg,\n\t\t\t\t\t\t\t   hal_ind_msg->msg_len);\n\t\t\tbreak;\n\t\tcase WCN36XX_HAL_PRINT_REG_INFO_IND:\n\t\t\twcn36xx_smd_print_reg_info_ind(wcn,\n\t\t\t\t\t\t       hal_ind_msg->msg,\n\t\t\t\t\t\t       hal_ind_msg->msg_len);\n\t\t\tbreak;\n\t\tcase WCN36XX_HAL_SCAN_OFFLOAD_IND:\n\t\t\twcn36xx_smd_hw_scan_ind(wcn, hal_ind_msg->msg,\n\t\t\t\t\t\thal_ind_msg->msg_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\twcn36xx_err(\"SMD_EVENT (%d) not supported\\n\",\n\t\t\t\t    msg_header->msg_type);\n\t\t}\n\n\t\tkfree(hal_ind_msg);\n\t}\n}\n\nint wcn36xx_smd_open(struct wcn36xx *wcn)\n{\n\twcn->hal_ind_wq = create_freezable_workqueue(\"wcn36xx_smd_ind\");\n\tif (!wcn->hal_ind_wq)\n\t\treturn -ENOMEM;\n\n\tINIT_WORK(&wcn->hal_ind_work, wcn36xx_ind_smd_work);\n\tINIT_LIST_HEAD(&wcn->hal_ind_queue);\n\tspin_lock_init(&wcn->hal_ind_lock);\n\n\treturn 0;\n}\n\nvoid wcn36xx_smd_close(struct wcn36xx *wcn)\n{\n\tstruct wcn36xx_hal_ind_msg *msg, *tmp;\n\n\tcancel_work_sync(&wcn->hal_ind_work);\n\tdestroy_workqueue(wcn->hal_ind_wq);\n\n\tlist_for_each_entry_safe(msg, tmp, &wcn->hal_ind_queue, list)\n\t\tkfree(msg);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}