{
  "module_name": "debug.c",
  "hash_id": "1a9b9851692620ef6655b3ac2a0f811d96926891f8d001fb9d7ab2febfc8fae3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/wcn36xx/debug.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/debugfs.h>\n#include <linux/uaccess.h>\n#include \"wcn36xx.h\"\n#include \"debug.h\"\n#include \"pmc.h\"\n#include \"firmware.h\"\n\n#ifdef CONFIG_WCN36XX_DEBUGFS\n\nstatic ssize_t read_file_bool_bmps(struct file *file, char __user *user_buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct wcn36xx *wcn = file->private_data;\n\tstruct wcn36xx_vif *vif_priv = NULL;\n\tstruct ieee80211_vif *vif = NULL;\n\tchar buf[3];\n\n\tlist_for_each_entry(vif_priv, &wcn->vif_list, list) {\n\t\t\tvif = wcn36xx_priv_to_vif(vif_priv);\n\t\t\tif (NL80211_IFTYPE_STATION == vif->type) {\n\t\t\t\tif (vif_priv->pw_state == WCN36XX_BMPS)\n\t\t\t\t\tbuf[0] = '1';\n\t\t\t\telse\n\t\t\t\t\tbuf[0] = '0';\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\tbuf[1] = '\\n';\n\tbuf[2] = 0x00;\n\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, 2);\n}\n\nstatic ssize_t write_file_bool_bmps(struct file *file,\n\t\t\t\t    const char __user *user_buf,\n\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct wcn36xx *wcn = file->private_data;\n\tstruct wcn36xx_vif *vif_priv = NULL;\n\tstruct ieee80211_vif *vif = NULL;\n\n\tchar buf[32];\n\tint buf_size;\n\n\tbuf_size = min(count, (sizeof(buf)-1));\n\tif (copy_from_user(buf, user_buf, buf_size))\n\t\treturn -EFAULT;\n\n\tswitch (buf[0]) {\n\tcase 'y':\n\tcase 'Y':\n\tcase '1':\n\t\tlist_for_each_entry(vif_priv, &wcn->vif_list, list) {\n\t\t\tvif = wcn36xx_priv_to_vif(vif_priv);\n\t\t\tif (NL80211_IFTYPE_STATION == vif->type) {\n\t\t\t\twcn36xx_enable_keep_alive_null_packet(wcn, vif);\n\t\t\t\twcn36xx_pmc_enter_bmps_state(wcn, vif);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'n':\n\tcase 'N':\n\tcase '0':\n\t\tlist_for_each_entry(vif_priv, &wcn->vif_list, list) {\n\t\t\tvif = wcn36xx_priv_to_vif(vif_priv);\n\t\t\tif (NL80211_IFTYPE_STATION == vif->type)\n\t\t\t\twcn36xx_pmc_exit_bmps_state(wcn, vif);\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn count;\n}\n\nstatic const struct file_operations fops_wcn36xx_bmps = {\n\t.open = simple_open,\n\t.read  =       read_file_bool_bmps,\n\t.write =       write_file_bool_bmps,\n};\n\nstatic ssize_t write_file_dump(struct file *file,\n\t\t\t\t    const char __user *user_buf,\n\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct wcn36xx *wcn = file->private_data;\n\tchar buf[255], *tmp;\n\tint buf_size;\n\tu32 arg[WCN36xx_MAX_DUMP_ARGS];\n\tint i;\n\n\tmemset(buf, 0, sizeof(buf));\n\tmemset(arg, 0, sizeof(arg));\n\n\tbuf_size = min(count, (sizeof(buf) - 1));\n\tif (copy_from_user(buf, user_buf, buf_size))\n\t\treturn -EFAULT;\n\n\ttmp = buf;\n\n\tfor (i = 0; i < WCN36xx_MAX_DUMP_ARGS; i++) {\n\t\tchar *begin;\n\t\tbegin = strsep(&tmp, \" \");\n\t\tif (begin == NULL)\n\t\t\tbreak;\n\n\t\tif (kstrtos32(begin, 0, &arg[i]) != 0)\n\t\t\tbreak;\n\t}\n\n\twcn36xx_info(\"DUMP args is %d %d %d %d %d\\n\", arg[0], arg[1], arg[2],\n\t\t     arg[3], arg[4]);\n\twcn36xx_smd_dump_cmd_req(wcn, arg[0], arg[1], arg[2], arg[3], arg[4]);\n\n\treturn count;\n}\n\nstatic const struct file_operations fops_wcn36xx_dump = {\n\t.open = simple_open,\n\t.write =       write_file_dump,\n};\n\nstatic ssize_t read_file_firmware_feature_caps(struct file *file,\n\t\t\t\t\t       char __user *user_buf,\n\t\t\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct wcn36xx *wcn = file->private_data;\n\tsize_t len = 0, buf_len = 2048;\n\tchar *buf;\n\tint i;\n\tint ret;\n\n\tbuf = kzalloc(buf_len, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&wcn->hal_mutex);\n\tfor (i = 0; i < MAX_FEATURE_SUPPORTED; i++) {\n\t\tif (wcn36xx_firmware_get_feat_caps(wcn->fw_feat_caps, i)) {\n\t\t\tlen += scnprintf(buf + len, buf_len - len, \"%s\\n\",\n\t\t\t\t\t wcn36xx_firmware_get_cap_name(i));\n\t\t}\n\t\tif (len >= buf_len)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&wcn->hal_mutex);\n\n\tret = simple_read_from_buffer(user_buf, count, ppos, buf, len);\n\tkfree(buf);\n\n\treturn ret;\n}\n\nstatic const struct file_operations fops_wcn36xx_firmware_feat_caps = {\n\t.open = simple_open,\n\t.read = read_file_firmware_feature_caps,\n};\n\n#define ADD_FILE(name, mode, fop, priv_data)\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tstruct dentry *d;\t\t\t\t\\\n\t\td = debugfs_create_file(__stringify(name),\t\\\n\t\t\t\t\tmode, dfs->rootdir,\t\\\n\t\t\t\t\tpriv_data, fop);\t\\\n\t\tdfs->file_##name.dentry = d;\t\t\t\\\n\t\tif (IS_ERR(d)) {\t\t\t\t\\\n\t\t\twcn36xx_warn(\"Create the debugfs entry failed\");\\\n\t\t\tdfs->file_##name.dentry = NULL;\t\t\\\n\t\t}\t\t\t\t\t\t\\\n\t} while (0)\n\n\nvoid wcn36xx_debugfs_init(struct wcn36xx *wcn)\n{\n\tstruct wcn36xx_dfs_entry *dfs = &wcn->dfs;\n\n\tdfs->rootdir = debugfs_create_dir(KBUILD_MODNAME,\n\t\t\t\t\t  wcn->hw->wiphy->debugfsdir);\n\tif (IS_ERR(dfs->rootdir)) {\n\t\twcn36xx_warn(\"Create the debugfs failed\\n\");\n\t\tdfs->rootdir = NULL;\n\t}\n\n\tADD_FILE(bmps_switcher, 0600, &fops_wcn36xx_bmps, wcn);\n\tADD_FILE(dump, 0200, &fops_wcn36xx_dump, wcn);\n\tADD_FILE(firmware_feat_caps, 0200,\n\t\t &fops_wcn36xx_firmware_feat_caps, wcn);\n}\n\nvoid wcn36xx_debugfs_exit(struct wcn36xx *wcn)\n{\n\tstruct wcn36xx_dfs_entry *dfs = &wcn->dfs;\n\tdebugfs_remove_recursive(dfs->rootdir);\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}