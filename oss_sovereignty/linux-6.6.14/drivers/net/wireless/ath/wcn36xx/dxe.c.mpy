{
  "module_name": "dxe.c",
  "hash_id": "385572eb94483e9ae69c2694155c6637d4c25529bb44c790179139862edfe1b1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/wcn36xx/dxe.c",
  "human_readable_source": " \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/interrupt.h>\n#include <linux/soc/qcom/smem_state.h>\n#include \"wcn36xx.h\"\n#include \"txrx.h\"\n\nstatic void wcn36xx_ccu_write_register(struct wcn36xx *wcn, int addr, int data)\n{\n\twcn36xx_dbg(WCN36XX_DBG_DXE,\n\t\t    \"wcn36xx_ccu_write_register: addr=%x, data=%x\\n\",\n\t\t    addr, data);\n\n\twritel(data, wcn->ccu_base + addr);\n}\n\nstatic void wcn36xx_dxe_write_register(struct wcn36xx *wcn, int addr, int data)\n{\n\twcn36xx_dbg(WCN36XX_DBG_DXE,\n\t\t    \"wcn36xx_dxe_write_register: addr=%x, data=%x\\n\",\n\t\t    addr, data);\n\n\twritel(data, wcn->dxe_base + addr);\n}\n\nstatic void wcn36xx_dxe_read_register(struct wcn36xx *wcn, int addr, int *data)\n{\n\t*data = readl(wcn->dxe_base + addr);\n\n\twcn36xx_dbg(WCN36XX_DBG_DXE,\n\t\t    \"wcn36xx_dxe_read_register: addr=%x, data=%x\\n\",\n\t\t    addr, *data);\n}\n\nstatic void wcn36xx_dxe_free_ctl_block(struct wcn36xx_dxe_ch *ch)\n{\n\tstruct wcn36xx_dxe_ctl *ctl = ch->head_blk_ctl, *next;\n\tint i;\n\n\tfor (i = 0; i < ch->desc_num && ctl; i++) {\n\t\tnext = ctl->next;\n\t\tkfree(ctl);\n\t\tctl = next;\n\t}\n}\n\nstatic int wcn36xx_dxe_allocate_ctl_block(struct wcn36xx_dxe_ch *ch)\n{\n\tstruct wcn36xx_dxe_ctl *prev_ctl = NULL;\n\tstruct wcn36xx_dxe_ctl *cur_ctl = NULL;\n\tint i;\n\n\tspin_lock_init(&ch->lock);\n\tfor (i = 0; i < ch->desc_num; i++) {\n\t\tcur_ctl = kzalloc(sizeof(*cur_ctl), GFP_KERNEL);\n\t\tif (!cur_ctl)\n\t\t\tgoto out_fail;\n\n\t\tcur_ctl->ctl_blk_order = i;\n\t\tif (i == 0) {\n\t\t\tch->head_blk_ctl = cur_ctl;\n\t\t\tch->tail_blk_ctl = cur_ctl;\n\t\t} else if (ch->desc_num - 1 == i) {\n\t\t\tprev_ctl->next = cur_ctl;\n\t\t\tcur_ctl->next = ch->head_blk_ctl;\n\t\t} else {\n\t\t\tprev_ctl->next = cur_ctl;\n\t\t}\n\t\tprev_ctl = cur_ctl;\n\t}\n\n\treturn 0;\n\nout_fail:\n\twcn36xx_dxe_free_ctl_block(ch);\n\treturn -ENOMEM;\n}\n\nint wcn36xx_dxe_alloc_ctl_blks(struct wcn36xx *wcn)\n{\n\tint ret;\n\n\twcn->dxe_tx_l_ch.ch_type = WCN36XX_DXE_CH_TX_L;\n\twcn->dxe_tx_h_ch.ch_type = WCN36XX_DXE_CH_TX_H;\n\twcn->dxe_rx_l_ch.ch_type = WCN36XX_DXE_CH_RX_L;\n\twcn->dxe_rx_h_ch.ch_type = WCN36XX_DXE_CH_RX_H;\n\n\twcn->dxe_tx_l_ch.desc_num = WCN36XX_DXE_CH_DESC_NUMB_TX_L;\n\twcn->dxe_tx_h_ch.desc_num = WCN36XX_DXE_CH_DESC_NUMB_TX_H;\n\twcn->dxe_rx_l_ch.desc_num = WCN36XX_DXE_CH_DESC_NUMB_RX_L;\n\twcn->dxe_rx_h_ch.desc_num = WCN36XX_DXE_CH_DESC_NUMB_RX_H;\n\n\twcn->dxe_tx_l_ch.dxe_wq =  WCN36XX_DXE_WQ_TX_L(wcn);\n\twcn->dxe_tx_h_ch.dxe_wq =  WCN36XX_DXE_WQ_TX_H(wcn);\n\n\twcn->dxe_tx_l_ch.ctrl_bd = WCN36XX_DXE_CTRL_TX_L_BD;\n\twcn->dxe_tx_h_ch.ctrl_bd = WCN36XX_DXE_CTRL_TX_H_BD;\n\n\twcn->dxe_tx_l_ch.ctrl_skb = WCN36XX_DXE_CTRL_TX_L_SKB;\n\twcn->dxe_tx_h_ch.ctrl_skb = WCN36XX_DXE_CTRL_TX_H_SKB;\n\n\twcn->dxe_tx_l_ch.reg_ctrl = WCN36XX_DXE_REG_CTL_TX_L;\n\twcn->dxe_tx_h_ch.reg_ctrl = WCN36XX_DXE_REG_CTL_TX_H;\n\n\twcn->dxe_tx_l_ch.def_ctrl = WCN36XX_DXE_CH_DEFAULT_CTL_TX_L;\n\twcn->dxe_tx_h_ch.def_ctrl = WCN36XX_DXE_CH_DEFAULT_CTL_TX_H;\n\n\t \n\tret = wcn36xx_dxe_allocate_ctl_block(&wcn->dxe_tx_l_ch);\n\tif (ret)\n\t\tgoto out_err;\n\tret = wcn36xx_dxe_allocate_ctl_block(&wcn->dxe_tx_h_ch);\n\tif (ret)\n\t\tgoto out_err;\n\tret = wcn36xx_dxe_allocate_ctl_block(&wcn->dxe_rx_l_ch);\n\tif (ret)\n\t\tgoto out_err;\n\tret = wcn36xx_dxe_allocate_ctl_block(&wcn->dxe_rx_h_ch);\n\tif (ret)\n\t\tgoto out_err;\n\n\t \n\tret = qcom_smem_state_update_bits(wcn->tx_enable_state,\n\t\t\t\t\t  WCN36XX_SMSM_WLAN_TX_ENABLE |\n\t\t\t\t\t  WCN36XX_SMSM_WLAN_TX_RINGS_EMPTY,\n\t\t\t\t\t  WCN36XX_SMSM_WLAN_TX_RINGS_EMPTY);\n\tif (ret)\n\t\tgoto out_err;\n\n\treturn 0;\n\nout_err:\n\twcn36xx_err(\"Failed to allocate DXE control blocks\\n\");\n\twcn36xx_dxe_free_ctl_blks(wcn);\n\treturn -ENOMEM;\n}\n\nvoid wcn36xx_dxe_free_ctl_blks(struct wcn36xx *wcn)\n{\n\twcn36xx_dxe_free_ctl_block(&wcn->dxe_tx_l_ch);\n\twcn36xx_dxe_free_ctl_block(&wcn->dxe_tx_h_ch);\n\twcn36xx_dxe_free_ctl_block(&wcn->dxe_rx_l_ch);\n\twcn36xx_dxe_free_ctl_block(&wcn->dxe_rx_h_ch);\n}\n\nstatic int wcn36xx_dxe_init_descs(struct wcn36xx *wcn, struct wcn36xx_dxe_ch *wcn_ch)\n{\n\tstruct device *dev = wcn->dev;\n\tstruct wcn36xx_dxe_desc *cur_dxe = NULL;\n\tstruct wcn36xx_dxe_desc *prev_dxe = NULL;\n\tstruct wcn36xx_dxe_ctl *cur_ctl = NULL;\n\tsize_t size;\n\tint i;\n\n\tsize = wcn_ch->desc_num * sizeof(struct wcn36xx_dxe_desc);\n\twcn_ch->cpu_addr = dma_alloc_coherent(dev, size, &wcn_ch->dma_addr,\n\t\t\t\t\t      GFP_KERNEL);\n\tif (!wcn_ch->cpu_addr)\n\t\treturn -ENOMEM;\n\n\tcur_dxe = (struct wcn36xx_dxe_desc *)wcn_ch->cpu_addr;\n\tcur_ctl = wcn_ch->head_blk_ctl;\n\n\tfor (i = 0; i < wcn_ch->desc_num; i++) {\n\t\tcur_ctl->desc = cur_dxe;\n\t\tcur_ctl->desc_phy_addr = wcn_ch->dma_addr +\n\t\t\ti * sizeof(struct wcn36xx_dxe_desc);\n\n\t\tswitch (wcn_ch->ch_type) {\n\t\tcase WCN36XX_DXE_CH_TX_L:\n\t\t\tcur_dxe->ctrl = WCN36XX_DXE_CTRL_TX_L;\n\t\t\tcur_dxe->dst_addr_l = WCN36XX_DXE_WQ_TX_L(wcn);\n\t\t\tbreak;\n\t\tcase WCN36XX_DXE_CH_TX_H:\n\t\t\tcur_dxe->ctrl = WCN36XX_DXE_CTRL_TX_H;\n\t\t\tcur_dxe->dst_addr_l = WCN36XX_DXE_WQ_TX_H(wcn);\n\t\t\tbreak;\n\t\tcase WCN36XX_DXE_CH_RX_L:\n\t\t\tcur_dxe->ctrl = WCN36XX_DXE_CTRL_RX_L;\n\t\t\tcur_dxe->src_addr_l = WCN36XX_DXE_WQ_RX_L;\n\t\t\tbreak;\n\t\tcase WCN36XX_DXE_CH_RX_H:\n\t\t\tcur_dxe->ctrl = WCN36XX_DXE_CTRL_RX_H;\n\t\t\tcur_dxe->src_addr_l = WCN36XX_DXE_WQ_RX_H;\n\t\t\tbreak;\n\t\t}\n\t\tif (0 == i) {\n\t\t\tcur_dxe->phy_next_l = 0;\n\t\t} else if ((0 < i) && (i < wcn_ch->desc_num - 1)) {\n\t\t\tprev_dxe->phy_next_l =\n\t\t\t\tcur_ctl->desc_phy_addr;\n\t\t} else if (i == (wcn_ch->desc_num - 1)) {\n\t\t\tprev_dxe->phy_next_l =\n\t\t\t\tcur_ctl->desc_phy_addr;\n\t\t\tcur_dxe->phy_next_l =\n\t\t\t\twcn_ch->head_blk_ctl->desc_phy_addr;\n\t\t}\n\t\tcur_ctl = cur_ctl->next;\n\t\tprev_dxe = cur_dxe;\n\t\tcur_dxe++;\n\t}\n\n\treturn 0;\n}\n\nstatic void wcn36xx_dxe_deinit_descs(struct device *dev, struct wcn36xx_dxe_ch *wcn_ch)\n{\n\tsize_t size;\n\n\tsize = wcn_ch->desc_num * sizeof(struct wcn36xx_dxe_desc);\n\tdma_free_coherent(dev, size,wcn_ch->cpu_addr, wcn_ch->dma_addr);\n}\n\nstatic void wcn36xx_dxe_init_tx_bd(struct wcn36xx_dxe_ch *ch,\n\t\t\t\t   struct wcn36xx_dxe_mem_pool *pool)\n{\n\tint i, chunk_size = pool->chunk_size;\n\tdma_addr_t bd_phy_addr = pool->phy_addr;\n\tvoid *bd_cpu_addr = pool->virt_addr;\n\tstruct wcn36xx_dxe_ctl *cur = ch->head_blk_ctl;\n\n\tfor (i = 0; i < ch->desc_num; i++) {\n\t\t \n\t\tif (!(i & 1)) {\n\t\t\tcur->bd_phy_addr = bd_phy_addr;\n\t\t\tcur->bd_cpu_addr = bd_cpu_addr;\n\t\t\tbd_phy_addr += chunk_size;\n\t\t\tbd_cpu_addr += chunk_size;\n\t\t} else {\n\t\t\tcur->bd_phy_addr = 0;\n\t\t\tcur->bd_cpu_addr = NULL;\n\t\t}\n\t\tcur = cur->next;\n\t}\n}\n\nstatic int wcn36xx_dxe_enable_ch_int(struct wcn36xx *wcn, u16 wcn_ch)\n{\n\tint reg_data = 0;\n\n\twcn36xx_dxe_read_register(wcn,\n\t\t\t\t  WCN36XX_DXE_INT_MASK_REG,\n\t\t\t\t  &reg_data);\n\n\treg_data |= wcn_ch;\n\n\twcn36xx_dxe_write_register(wcn,\n\t\t\t\t   WCN36XX_DXE_INT_MASK_REG,\n\t\t\t\t   (int)reg_data);\n\treturn 0;\n}\n\nstatic void wcn36xx_dxe_disable_ch_int(struct wcn36xx *wcn, u16 wcn_ch)\n{\n\tint reg_data = 0;\n\n\twcn36xx_dxe_read_register(wcn,\n\t\t\t\t  WCN36XX_DXE_INT_MASK_REG,\n\t\t\t\t  &reg_data);\n\n\treg_data &= ~wcn_ch;\n\n\twcn36xx_dxe_write_register(wcn,\n\t\t\t\t   WCN36XX_DXE_INT_MASK_REG,\n\t\t\t\t   (int)reg_data);\n}\n\nstatic int wcn36xx_dxe_fill_skb(struct device *dev,\n\t\t\t\tstruct wcn36xx_dxe_ctl *ctl,\n\t\t\t\tgfp_t gfp)\n{\n\tstruct wcn36xx_dxe_desc *dxe = ctl->desc;\n\tstruct sk_buff *skb;\n\n\tskb = alloc_skb(WCN36XX_PKT_SIZE, gfp);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tdxe->dst_addr_l = dma_map_single(dev,\n\t\t\t\t\t skb_tail_pointer(skb),\n\t\t\t\t\t WCN36XX_PKT_SIZE,\n\t\t\t\t\t DMA_FROM_DEVICE);\n\tif (dma_mapping_error(dev, dxe->dst_addr_l)) {\n\t\tdev_err(dev, \"unable to map skb\\n\");\n\t\tkfree_skb(skb);\n\t\treturn -ENOMEM;\n\t}\n\tctl->skb = skb;\n\n\treturn 0;\n}\n\nstatic int wcn36xx_dxe_ch_alloc_skb(struct wcn36xx *wcn,\n\t\t\t\t    struct wcn36xx_dxe_ch *wcn_ch)\n{\n\tint i;\n\tstruct wcn36xx_dxe_ctl *cur_ctl = NULL;\n\n\tcur_ctl = wcn_ch->head_blk_ctl;\n\n\tfor (i = 0; i < wcn_ch->desc_num; i++) {\n\t\twcn36xx_dxe_fill_skb(wcn->dev, cur_ctl, GFP_KERNEL);\n\t\tcur_ctl = cur_ctl->next;\n\t}\n\n\treturn 0;\n}\n\nstatic void wcn36xx_dxe_ch_free_skbs(struct wcn36xx *wcn,\n\t\t\t\t     struct wcn36xx_dxe_ch *wcn_ch)\n{\n\tstruct wcn36xx_dxe_ctl *cur = wcn_ch->head_blk_ctl;\n\tint i;\n\n\tfor (i = 0; i < wcn_ch->desc_num; i++) {\n\t\tkfree_skb(cur->skb);\n\t\tcur = cur->next;\n\t}\n}\n\nvoid wcn36xx_dxe_tx_ack_ind(struct wcn36xx *wcn, u32 status)\n{\n\tstruct ieee80211_tx_info *info;\n\tstruct sk_buff *skb;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&wcn->dxe_lock, flags);\n\tskb = wcn->tx_ack_skb;\n\twcn->tx_ack_skb = NULL;\n\tdel_timer(&wcn->tx_ack_timer);\n\tspin_unlock_irqrestore(&wcn->dxe_lock, flags);\n\n\tif (!skb) {\n\t\twcn36xx_warn(\"Spurious TX complete indication\\n\");\n\t\treturn;\n\t}\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\n\tif (status == 1)\n\t\tinfo->flags |= IEEE80211_TX_STAT_ACK;\n\telse\n\t\tinfo->flags &= ~IEEE80211_TX_STAT_ACK;\n\n\twcn36xx_dbg(WCN36XX_DBG_DXE, \"dxe tx ack status: %d\\n\", status);\n\n\tieee80211_tx_status_irqsafe(wcn->hw, skb);\n\tieee80211_wake_queues(wcn->hw);\n}\n\nstatic void wcn36xx_dxe_tx_timer(struct timer_list *t)\n{\n\tstruct wcn36xx *wcn = from_timer(wcn, t, tx_ack_timer);\n\tstruct ieee80211_tx_info *info;\n\tunsigned long flags;\n\tstruct sk_buff *skb;\n\n\t \n\twcn36xx_dbg(WCN36XX_DBG_DXE, \"TX timeout\\n\");\n\n\tspin_lock_irqsave(&wcn->dxe_lock, flags);\n\tskb = wcn->tx_ack_skb;\n\twcn->tx_ack_skb = NULL;\n\tspin_unlock_irqrestore(&wcn->dxe_lock, flags);\n\n\tif (!skb)\n\t\treturn;\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\tinfo->flags &= ~IEEE80211_TX_STAT_ACK;\n\tinfo->flags &= ~IEEE80211_TX_STAT_NOACK_TRANSMITTED;\n\n\tieee80211_tx_status_irqsafe(wcn->hw, skb);\n\tieee80211_wake_queues(wcn->hw);\n}\n\nstatic void reap_tx_dxes(struct wcn36xx *wcn, struct wcn36xx_dxe_ch *ch)\n{\n\tstruct wcn36xx_dxe_ctl *ctl;\n\tstruct ieee80211_tx_info *info;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&ch->lock, flags);\n\tctl = ch->tail_blk_ctl;\n\tdo {\n\t\tif (READ_ONCE(ctl->desc->ctrl) & WCN36xx_DXE_CTRL_VLD)\n\t\t\tbreak;\n\n\t\tif (ctl->skb &&\n\t\t    READ_ONCE(ctl->desc->ctrl) & WCN36xx_DXE_CTRL_EOP) {\n\t\t\tdma_unmap_single(wcn->dev, ctl->desc->src_addr_l,\n\t\t\t\t\t ctl->skb->len, DMA_TO_DEVICE);\n\t\t\tinfo = IEEE80211_SKB_CB(ctl->skb);\n\t\t\tif (info->flags & IEEE80211_TX_CTL_REQ_TX_STATUS) {\n\t\t\t\tif (info->flags & IEEE80211_TX_CTL_NO_ACK) {\n\t\t\t\t\tinfo->flags |= IEEE80211_TX_STAT_NOACK_TRANSMITTED;\n\t\t\t\t\tieee80211_tx_status_irqsafe(wcn->hw, ctl->skb);\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tspin_lock(&wcn->dxe_lock);\n\t\t\t\t\tif (WARN_ON(wcn->tx_ack_skb))\n\t\t\t\t\t\tieee80211_free_txskb(wcn->hw, wcn->tx_ack_skb);\n\t\t\t\t\twcn->tx_ack_skb = ctl->skb;  \n\t\t\t\t\tmod_timer(&wcn->tx_ack_timer, jiffies + HZ / 10);\n\t\t\t\t\tspin_unlock(&wcn->dxe_lock);\n\t\t\t\t}\n\t\t\t\t \n\t\t\t} else {\n\t\t\t\tieee80211_free_txskb(wcn->hw, ctl->skb);\n\t\t\t}\n\n\t\t\tif (wcn->queues_stopped) {\n\t\t\t\twcn->queues_stopped = false;\n\t\t\t\tieee80211_wake_queues(wcn->hw);\n\t\t\t}\n\n\t\t\tctl->skb = NULL;\n\t\t}\n\t\tctl = ctl->next;\n\t} while (ctl != ch->head_blk_ctl);\n\n\tch->tail_blk_ctl = ctl;\n\tspin_unlock_irqrestore(&ch->lock, flags);\n}\n\nstatic irqreturn_t wcn36xx_irq_tx_complete(int irq, void *dev)\n{\n\tstruct wcn36xx *wcn = (struct wcn36xx *)dev;\n\tint int_src, int_reason;\n\n\twcn36xx_dxe_read_register(wcn, WCN36XX_DXE_INT_SRC_RAW_REG, &int_src);\n\n\tif (int_src & WCN36XX_INT_MASK_CHAN_TX_H) {\n\t\twcn36xx_dxe_read_register(wcn,\n\t\t\t\t\t  WCN36XX_DXE_CH_STATUS_REG_ADDR_TX_H,\n\t\t\t\t\t  &int_reason);\n\n\t\twcn36xx_dxe_write_register(wcn,\n\t\t\t\t\t   WCN36XX_DXE_0_INT_CLR,\n\t\t\t\t\t   WCN36XX_INT_MASK_CHAN_TX_H);\n\n\t\tif (int_reason & WCN36XX_CH_STAT_INT_ERR_MASK ) {\n\t\t\twcn36xx_dxe_write_register(wcn,\n\t\t\t\t\t\t   WCN36XX_DXE_0_INT_ERR_CLR,\n\t\t\t\t\t\t   WCN36XX_INT_MASK_CHAN_TX_H);\n\n\t\t\twcn36xx_err(\"DXE IRQ reported error: 0x%x in high TX channel\\n\",\n\t\t\t\t\tint_src);\n\t\t}\n\n\t\tif (int_reason & WCN36XX_CH_STAT_INT_DONE_MASK) {\n\t\t\twcn36xx_dxe_write_register(wcn,\n\t\t\t\t\t\t   WCN36XX_DXE_0_INT_DONE_CLR,\n\t\t\t\t\t\t   WCN36XX_INT_MASK_CHAN_TX_H);\n\t\t}\n\n\t\tif (int_reason & WCN36XX_CH_STAT_INT_ED_MASK) {\n\t\t\twcn36xx_dxe_write_register(wcn,\n\t\t\t\t\t\t   WCN36XX_DXE_0_INT_ED_CLR,\n\t\t\t\t\t\t   WCN36XX_INT_MASK_CHAN_TX_H);\n\t\t}\n\n\t\twcn36xx_dbg(WCN36XX_DBG_DXE, \"dxe tx ready high, reason %08x\\n\",\n\t\t\t    int_reason);\n\n\t\tif (int_reason & (WCN36XX_CH_STAT_INT_DONE_MASK |\n\t\t\t\t  WCN36XX_CH_STAT_INT_ED_MASK)) {\n\t\t\treap_tx_dxes(wcn, &wcn->dxe_tx_h_ch);\n\t\t}\n\t}\n\n\tif (int_src & WCN36XX_INT_MASK_CHAN_TX_L) {\n\t\twcn36xx_dxe_read_register(wcn,\n\t\t\t\t\t  WCN36XX_DXE_CH_STATUS_REG_ADDR_TX_L,\n\t\t\t\t\t  &int_reason);\n\n\t\twcn36xx_dxe_write_register(wcn,\n\t\t\t\t\t   WCN36XX_DXE_0_INT_CLR,\n\t\t\t\t\t   WCN36XX_INT_MASK_CHAN_TX_L);\n\n\t\tif (int_reason & WCN36XX_CH_STAT_INT_ERR_MASK ) {\n\t\t\twcn36xx_dxe_write_register(wcn,\n\t\t\t\t\t\t   WCN36XX_DXE_0_INT_ERR_CLR,\n\t\t\t\t\t\t   WCN36XX_INT_MASK_CHAN_TX_L);\n\n\t\t\twcn36xx_err(\"DXE IRQ reported error: 0x%x in low TX channel\\n\",\n\t\t\t\t\tint_src);\n\t\t}\n\n\t\tif (int_reason & WCN36XX_CH_STAT_INT_DONE_MASK) {\n\t\t\twcn36xx_dxe_write_register(wcn,\n\t\t\t\t\t\t   WCN36XX_DXE_0_INT_DONE_CLR,\n\t\t\t\t\t\t   WCN36XX_INT_MASK_CHAN_TX_L);\n\t\t}\n\n\t\tif (int_reason & WCN36XX_CH_STAT_INT_ED_MASK) {\n\t\t\twcn36xx_dxe_write_register(wcn,\n\t\t\t\t\t\t   WCN36XX_DXE_0_INT_ED_CLR,\n\t\t\t\t\t\t   WCN36XX_INT_MASK_CHAN_TX_L);\n\t\t}\n\n\t\twcn36xx_dbg(WCN36XX_DBG_DXE, \"dxe tx ready low, reason %08x\\n\",\n\t\t\t    int_reason);\n\n\t\tif (int_reason & (WCN36XX_CH_STAT_INT_DONE_MASK |\n\t\t\t\t  WCN36XX_CH_STAT_INT_ED_MASK)) {\n\t\t\treap_tx_dxes(wcn, &wcn->dxe_tx_l_ch);\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t wcn36xx_irq_rx_ready(int irq, void *dev)\n{\n\tstruct wcn36xx *wcn = (struct wcn36xx *)dev;\n\n\twcn36xx_dxe_rx_frame(wcn);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int wcn36xx_dxe_request_irqs(struct wcn36xx *wcn)\n{\n\tint ret;\n\n\tret = request_irq(wcn->tx_irq, wcn36xx_irq_tx_complete,\n\t\t\t  IRQF_TRIGGER_HIGH, \"wcn36xx_tx\", wcn);\n\tif (ret) {\n\t\twcn36xx_err(\"failed to alloc tx irq\\n\");\n\t\tgoto out_err;\n\t}\n\n\tret = request_irq(wcn->rx_irq, wcn36xx_irq_rx_ready, IRQF_TRIGGER_HIGH,\n\t\t\t  \"wcn36xx_rx\", wcn);\n\tif (ret) {\n\t\twcn36xx_err(\"failed to alloc rx irq\\n\");\n\t\tgoto out_txirq;\n\t}\n\n\tenable_irq_wake(wcn->rx_irq);\n\n\treturn 0;\n\nout_txirq:\n\tfree_irq(wcn->tx_irq, wcn);\nout_err:\n\treturn ret;\n\n}\n\nstatic int wcn36xx_rx_handle_packets(struct wcn36xx *wcn,\n\t\t\t\t     struct wcn36xx_dxe_ch *ch,\n\t\t\t\t     u32 ctrl,\n\t\t\t\t     u32 en_mask,\n\t\t\t\t     u32 int_mask,\n\t\t\t\t     u32 status_reg)\n{\n\tstruct wcn36xx_dxe_desc *dxe;\n\tstruct wcn36xx_dxe_ctl *ctl;\n\tdma_addr_t  dma_addr;\n\tstruct sk_buff *skb;\n\tu32 int_reason;\n\tint ret;\n\n\twcn36xx_dxe_read_register(wcn, status_reg, &int_reason);\n\twcn36xx_dxe_write_register(wcn, WCN36XX_DXE_0_INT_CLR, int_mask);\n\n\tif (int_reason & WCN36XX_CH_STAT_INT_ERR_MASK) {\n\t\twcn36xx_dxe_write_register(wcn,\n\t\t\t\t\t   WCN36XX_DXE_0_INT_ERR_CLR,\n\t\t\t\t\t   int_mask);\n\n\t\twcn36xx_err(\"DXE IRQ reported error on RX channel\\n\");\n\t}\n\n\tif (int_reason & WCN36XX_CH_STAT_INT_DONE_MASK)\n\t\twcn36xx_dxe_write_register(wcn,\n\t\t\t\t\t   WCN36XX_DXE_0_INT_DONE_CLR,\n\t\t\t\t\t   int_mask);\n\n\tif (int_reason & WCN36XX_CH_STAT_INT_ED_MASK)\n\t\twcn36xx_dxe_write_register(wcn,\n\t\t\t\t\t   WCN36XX_DXE_0_INT_ED_CLR,\n\t\t\t\t\t   int_mask);\n\n\tif (!(int_reason & (WCN36XX_CH_STAT_INT_DONE_MASK |\n\t\t\t    WCN36XX_CH_STAT_INT_ED_MASK)))\n\t\treturn 0;\n\n\tspin_lock(&ch->lock);\n\n\tctl = ch->head_blk_ctl;\n\tdxe = ctl->desc;\n\n\twhile (!(READ_ONCE(dxe->ctrl) & WCN36xx_DXE_CTRL_VLD)) {\n\t\t \n\t\tdma_rmb();\n\n\t\t \n\t\tskb = ctl->skb;\n\t\tdma_addr = dxe->dst_addr_l;\n\t\tret = wcn36xx_dxe_fill_skb(wcn->dev, ctl, GFP_ATOMIC);\n\t\tif (0 == ret) {\n\t\t\t \n\t\t\tdma_unmap_single(wcn->dev, dma_addr, WCN36XX_PKT_SIZE,\n\t\t\t\t\tDMA_FROM_DEVICE);\n\t\t\twcn36xx_rx_skb(wcn, skb);\n\t\t}\n\t\t \n\n\t\t \n\t\tdma_wmb();\n\t\tdxe->ctrl = ctrl;\n\n\t\tctl = ctl->next;\n\t\tdxe = ctl->desc;\n\t}\n\twcn36xx_dxe_write_register(wcn, WCN36XX_DXE_ENCH_ADDR, en_mask);\n\n\tch->head_blk_ctl = ctl;\n\n\tspin_unlock(&ch->lock);\n\n\treturn 0;\n}\n\nvoid wcn36xx_dxe_rx_frame(struct wcn36xx *wcn)\n{\n\tint int_src;\n\n\twcn36xx_dxe_read_register(wcn, WCN36XX_DXE_INT_SRC_RAW_REG, &int_src);\n\n\t \n\tif (int_src & WCN36XX_DXE_INT_CH1_MASK)\n\t\twcn36xx_rx_handle_packets(wcn, &wcn->dxe_rx_l_ch,\n\t\t\t\t\t  WCN36XX_DXE_CTRL_RX_L,\n\t\t\t\t\t  WCN36XX_DXE_INT_CH1_MASK,\n\t\t\t\t\t  WCN36XX_INT_MASK_CHAN_RX_L,\n\t\t\t\t\t  WCN36XX_DXE_CH_STATUS_REG_ADDR_RX_L);\n\n\t \n\tif (int_src & WCN36XX_DXE_INT_CH3_MASK)\n\t\twcn36xx_rx_handle_packets(wcn, &wcn->dxe_rx_h_ch,\n\t\t\t\t\t  WCN36XX_DXE_CTRL_RX_H,\n\t\t\t\t\t  WCN36XX_DXE_INT_CH3_MASK,\n\t\t\t\t\t  WCN36XX_INT_MASK_CHAN_RX_H,\n\t\t\t\t\t  WCN36XX_DXE_CH_STATUS_REG_ADDR_RX_H);\n\n\tif (!int_src)\n\t\twcn36xx_warn(\"No DXE interrupt pending\\n\");\n}\n\nint wcn36xx_dxe_allocate_mem_pools(struct wcn36xx *wcn)\n{\n\tsize_t s;\n\tvoid *cpu_addr;\n\n\t \n\n\t \n\twcn->mgmt_mem_pool.chunk_size =\tWCN36XX_BD_CHUNK_SIZE +\n\t\t16 - (WCN36XX_BD_CHUNK_SIZE % 8);\n\n\ts = wcn->mgmt_mem_pool.chunk_size * WCN36XX_DXE_CH_DESC_NUMB_TX_H;\n\tcpu_addr = dma_alloc_coherent(wcn->dev, s,\n\t\t\t\t      &wcn->mgmt_mem_pool.phy_addr,\n\t\t\t\t      GFP_KERNEL);\n\tif (!cpu_addr)\n\t\tgoto out_err;\n\n\twcn->mgmt_mem_pool.virt_addr = cpu_addr;\n\n\t \n\n\t \n\twcn->data_mem_pool.chunk_size = WCN36XX_BD_CHUNK_SIZE +\n\t\t16 - (WCN36XX_BD_CHUNK_SIZE % 8);\n\n\ts = wcn->data_mem_pool.chunk_size * WCN36XX_DXE_CH_DESC_NUMB_TX_L;\n\tcpu_addr = dma_alloc_coherent(wcn->dev, s,\n\t\t\t\t      &wcn->data_mem_pool.phy_addr,\n\t\t\t\t      GFP_KERNEL);\n\tif (!cpu_addr)\n\t\tgoto out_err;\n\n\twcn->data_mem_pool.virt_addr = cpu_addr;\n\n\treturn 0;\n\nout_err:\n\twcn36xx_dxe_free_mem_pools(wcn);\n\twcn36xx_err(\"Failed to allocate BD mempool\\n\");\n\treturn -ENOMEM;\n}\n\nvoid wcn36xx_dxe_free_mem_pools(struct wcn36xx *wcn)\n{\n\tif (wcn->mgmt_mem_pool.virt_addr)\n\t\tdma_free_coherent(wcn->dev, wcn->mgmt_mem_pool.chunk_size *\n\t\t\t\t  WCN36XX_DXE_CH_DESC_NUMB_TX_H,\n\t\t\t\t  wcn->mgmt_mem_pool.virt_addr,\n\t\t\t\t  wcn->mgmt_mem_pool.phy_addr);\n\n\tif (wcn->data_mem_pool.virt_addr) {\n\t\tdma_free_coherent(wcn->dev, wcn->data_mem_pool.chunk_size *\n\t\t\t\t  WCN36XX_DXE_CH_DESC_NUMB_TX_L,\n\t\t\t\t  wcn->data_mem_pool.virt_addr,\n\t\t\t\t  wcn->data_mem_pool.phy_addr);\n\t}\n}\n\nint wcn36xx_dxe_tx_frame(struct wcn36xx *wcn,\n\t\t\t struct wcn36xx_vif *vif_priv,\n\t\t\t struct wcn36xx_tx_bd *bd,\n\t\t\t struct sk_buff *skb,\n\t\t\t bool is_low)\n{\n\tstruct wcn36xx_dxe_desc *desc_bd, *desc_skb;\n\tstruct wcn36xx_dxe_ctl *ctl_bd, *ctl_skb;\n\tstruct wcn36xx_dxe_ch *ch = NULL;\n\tunsigned long flags;\n\tint ret;\n\n\tch = is_low ? &wcn->dxe_tx_l_ch : &wcn->dxe_tx_h_ch;\n\n\tspin_lock_irqsave(&ch->lock, flags);\n\tctl_bd = ch->head_blk_ctl;\n\tctl_skb = ctl_bd->next;\n\n\t \n\tif (NULL != ctl_skb->skb) {\n\t\tieee80211_stop_queues(wcn->hw);\n\t\twcn->queues_stopped = true;\n\t\tspin_unlock_irqrestore(&ch->lock, flags);\n\t\treturn -EBUSY;\n\t}\n\n\tif (unlikely(ctl_skb->bd_cpu_addr)) {\n\t\twcn36xx_err(\"bd_cpu_addr cannot be NULL for skb DXE\\n\");\n\t\tret = -EINVAL;\n\t\tgoto unlock;\n\t}\n\n\tdesc_bd = ctl_bd->desc;\n\tdesc_skb = ctl_skb->desc;\n\n\tctl_bd->skb = NULL;\n\n\t \n\tmemcpy(ctl_bd->bd_cpu_addr, bd, sizeof(*bd));\n\n\t \n\tdesc_bd->src_addr_l = ctl_bd->bd_phy_addr;\n\tdesc_bd->dst_addr_l = ch->dxe_wq;\n\tdesc_bd->fr_len = sizeof(struct wcn36xx_tx_bd);\n\n\twcn36xx_dbg(WCN36XX_DBG_DXE, \"DXE TX\\n\");\n\n\twcn36xx_dbg_dump(WCN36XX_DBG_DXE_DUMP, \"DESC1 >>> \",\n\t\t\t (char *)desc_bd, sizeof(*desc_bd));\n\twcn36xx_dbg_dump(WCN36XX_DBG_DXE_DUMP,\n\t\t\t \"BD   >>> \", (char *)ctl_bd->bd_cpu_addr,\n\t\t\t sizeof(struct wcn36xx_tx_bd));\n\n\tdesc_skb->src_addr_l = dma_map_single(wcn->dev,\n\t\t\t\t\t      skb->data,\n\t\t\t\t\t      skb->len,\n\t\t\t\t\t      DMA_TO_DEVICE);\n\tif (dma_mapping_error(wcn->dev, desc_skb->src_addr_l)) {\n\t\tdev_err(wcn->dev, \"unable to DMA map src_addr_l\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto unlock;\n\t}\n\n\tctl_skb->skb = skb;\n\tdesc_skb->dst_addr_l = ch->dxe_wq;\n\tdesc_skb->fr_len = ctl_skb->skb->len;\n\n\twcn36xx_dbg_dump(WCN36XX_DBG_DXE_DUMP, \"DESC2 >>> \",\n\t\t\t (char *)desc_skb, sizeof(*desc_skb));\n\twcn36xx_dbg_dump(WCN36XX_DBG_DXE_DUMP, \"SKB   >>> \",\n\t\t\t (char *)ctl_skb->skb->data, ctl_skb->skb->len);\n\n\t \n\tch->head_blk_ctl = ctl_skb->next;\n\n\t \n\twmb();\n\tdesc_skb->ctrl = ch->ctrl_skb;\n\twmb();\n\tdesc_bd->ctrl = ch->ctrl_bd;\n\n\t \n\tif (is_low &&  vif_priv->pw_state == WCN36XX_BMPS) {\n\t\tqcom_smem_state_update_bits(wcn->tx_rings_empty_state,\n\t\t\t\t\t    WCN36XX_SMSM_WLAN_TX_ENABLE,\n\t\t\t\t\t    WCN36XX_SMSM_WLAN_TX_ENABLE);\n\t} else {\n\t\t \n\t\twcn36xx_dxe_write_register(wcn,\n\t\t\tch->reg_ctrl, ch->def_ctrl);\n\t}\n\n\tret = 0;\nunlock:\n\tspin_unlock_irqrestore(&ch->lock, flags);\n\treturn ret;\n}\n\nstatic bool _wcn36xx_dxe_tx_channel_is_empty(struct wcn36xx_dxe_ch *ch)\n{\n\tunsigned long flags;\n\tstruct wcn36xx_dxe_ctl *ctl_bd_start, *ctl_skb_start;\n\tstruct wcn36xx_dxe_ctl *ctl_bd, *ctl_skb;\n\tbool ret = true;\n\n\tspin_lock_irqsave(&ch->lock, flags);\n\n\t \n\tctl_bd_start = ch->head_blk_ctl;\n\tctl_bd = ctl_bd_start;\n\tctl_skb_start = ctl_bd_start->next;\n\tctl_skb = ctl_skb_start;\n\tdo {\n\t\tif (ctl_skb->skb) {\n\t\t\tret = false;\n\t\t\tgoto unlock;\n\t\t}\n\t\tctl_bd = ctl_skb->next;\n\t\tctl_skb = ctl_bd->next;\n\t} while (ctl_skb != ctl_skb_start);\n\nunlock:\n\tspin_unlock_irqrestore(&ch->lock, flags);\n\treturn ret;\n}\n\nint wcn36xx_dxe_tx_flush(struct wcn36xx *wcn)\n{\n\tint i = 0;\n\n\t \n\tdo {\n\t\tif (_wcn36xx_dxe_tx_channel_is_empty(&wcn->dxe_tx_l_ch) &&\n\t\t    _wcn36xx_dxe_tx_channel_is_empty(&wcn->dxe_tx_h_ch)) {\n\t\t\treturn 0;\n\t\t}\n\t\t \n\t\tusleep_range(1000, 1100);\n\t} while (++i < 100);\n\n\treturn -EBUSY;\n}\n\nint wcn36xx_dxe_init(struct wcn36xx *wcn)\n{\n\tint reg_data = 0, ret;\n\n\treg_data = WCN36XX_DXE_REG_RESET;\n\twcn36xx_dxe_write_register(wcn, WCN36XX_DXE_REG_CSR_RESET, reg_data);\n\n\t \n\treg_data = (WCN36XX_DXE_INT_CH3_MASK | WCN36XX_DXE_INT_CH1_MASK) << 16 |\n\t\t    WCN36XX_DXE_INT_CH0_MASK | WCN36XX_DXE_INT_CH4_MASK;\n\tif (wcn->is_pronto)\n\t\twcn36xx_ccu_write_register(wcn, WCN36XX_CCU_DXE_INT_SELECT_PRONTO, reg_data);\n\telse\n\t\twcn36xx_ccu_write_register(wcn, WCN36XX_CCU_DXE_INT_SELECT_RIVA, reg_data);\n\n\t \n\t \n\t \n\tret = wcn36xx_dxe_init_descs(wcn, &wcn->dxe_tx_l_ch);\n\tif (ret) {\n\t\tdev_err(wcn->dev, \"Error allocating descriptor\\n\");\n\t\treturn ret;\n\t}\n\twcn36xx_dxe_init_tx_bd(&wcn->dxe_tx_l_ch, &wcn->data_mem_pool);\n\n\t \n\twcn36xx_dxe_write_register(wcn, WCN36XX_DXE_CH_NEXT_DESC_ADDR_TX_L,\n\t\twcn->dxe_tx_l_ch.head_blk_ctl->desc_phy_addr);\n\n\t \n\twcn36xx_dxe_write_register(wcn,\n\t\tWCN36XX_DXE_CH_DEST_ADDR_TX_L,\n\t\tWCN36XX_DXE_WQ_TX_L(wcn));\n\n\twcn36xx_dxe_read_register(wcn, WCN36XX_DXE_REG_CH_EN, &reg_data);\n\n\t \n\t \n\t \n\tret = wcn36xx_dxe_init_descs(wcn, &wcn->dxe_tx_h_ch);\n\tif (ret) {\n\t\tdev_err(wcn->dev, \"Error allocating descriptor\\n\");\n\t\tgoto out_err_txh_ch;\n\t}\n\n\twcn36xx_dxe_init_tx_bd(&wcn->dxe_tx_h_ch, &wcn->mgmt_mem_pool);\n\n\t \n\twcn36xx_dxe_write_register(wcn, WCN36XX_DXE_CH_NEXT_DESC_ADDR_TX_H,\n\t\twcn->dxe_tx_h_ch.head_blk_ctl->desc_phy_addr);\n\n\t \n\twcn36xx_dxe_write_register(wcn,\n\t\tWCN36XX_DXE_CH_DEST_ADDR_TX_H,\n\t\tWCN36XX_DXE_WQ_TX_H(wcn));\n\n\twcn36xx_dxe_read_register(wcn, WCN36XX_DXE_REG_CH_EN, &reg_data);\n\n\t \n\t \n\t \n\tret = wcn36xx_dxe_init_descs(wcn, &wcn->dxe_rx_l_ch);\n\tif (ret) {\n\t\tdev_err(wcn->dev, \"Error allocating descriptor\\n\");\n\t\tgoto out_err_rxl_ch;\n\t}\n\n\t \n\twcn36xx_dxe_ch_alloc_skb(wcn, &wcn->dxe_rx_l_ch);\n\n\t \n\twcn36xx_dxe_write_register(wcn, WCN36XX_DXE_CH_NEXT_DESC_ADDR_RX_L,\n\t\twcn->dxe_rx_l_ch.head_blk_ctl->desc_phy_addr);\n\n\t \n\twcn36xx_dxe_write_register(wcn,\n\t\tWCN36XX_DXE_CH_SRC_ADDR_RX_L,\n\t\tWCN36XX_DXE_WQ_RX_L);\n\n\t \n\twcn36xx_dxe_write_register(wcn,\n\t\tWCN36XX_DXE_CH_DEST_ADDR_RX_L,\n\t\twcn->dxe_rx_l_ch.head_blk_ctl->desc->phy_next_l);\n\n\t \n\twcn36xx_dxe_write_register(wcn,\n\t\tWCN36XX_DXE_REG_CTL_RX_L,\n\t\tWCN36XX_DXE_CH_DEFAULT_CTL_RX_L);\n\n\t \n\t \n\t \n\tret = wcn36xx_dxe_init_descs(wcn, &wcn->dxe_rx_h_ch);\n\tif (ret) {\n\t\tdev_err(wcn->dev, \"Error allocating descriptor\\n\");\n\t\tgoto out_err_rxh_ch;\n\t}\n\n\t \n\twcn36xx_dxe_ch_alloc_skb(wcn, &wcn->dxe_rx_h_ch);\n\n\t \n\twcn36xx_dxe_write_register(wcn, WCN36XX_DXE_CH_NEXT_DESC_ADDR_RX_H,\n\t\twcn->dxe_rx_h_ch.head_blk_ctl->desc_phy_addr);\n\n\t \n\twcn36xx_dxe_write_register(wcn,\n\t\tWCN36XX_DXE_CH_SRC_ADDR_RX_H,\n\t\tWCN36XX_DXE_WQ_RX_H);\n\n\t \n\twcn36xx_dxe_write_register(wcn,\n\t\tWCN36XX_DXE_CH_DEST_ADDR_RX_H,\n\t\t wcn->dxe_rx_h_ch.head_blk_ctl->desc->phy_next_l);\n\n\t \n\twcn36xx_dxe_write_register(wcn,\n\t\tWCN36XX_DXE_REG_CTL_RX_H,\n\t\tWCN36XX_DXE_CH_DEFAULT_CTL_RX_H);\n\n\tret = wcn36xx_dxe_request_irqs(wcn);\n\tif (ret < 0)\n\t\tgoto out_err_irq;\n\n\ttimer_setup(&wcn->tx_ack_timer, wcn36xx_dxe_tx_timer, 0);\n\n\t \n\twcn36xx_dxe_enable_ch_int(wcn, WCN36XX_INT_MASK_CHAN_TX_L);\n\twcn36xx_dxe_enable_ch_int(wcn, WCN36XX_INT_MASK_CHAN_TX_H);\n\twcn36xx_dxe_enable_ch_int(wcn, WCN36XX_INT_MASK_CHAN_RX_L);\n\twcn36xx_dxe_enable_ch_int(wcn, WCN36XX_INT_MASK_CHAN_RX_H);\n\n\treturn 0;\n\nout_err_irq:\n\twcn36xx_dxe_deinit_descs(wcn->dev, &wcn->dxe_rx_h_ch);\nout_err_rxh_ch:\n\twcn36xx_dxe_deinit_descs(wcn->dev, &wcn->dxe_rx_l_ch);\nout_err_rxl_ch:\n\twcn36xx_dxe_deinit_descs(wcn->dev, &wcn->dxe_tx_h_ch);\nout_err_txh_ch:\n\twcn36xx_dxe_deinit_descs(wcn->dev, &wcn->dxe_tx_l_ch);\n\n\treturn ret;\n}\n\nvoid wcn36xx_dxe_deinit(struct wcn36xx *wcn)\n{\n\tint reg_data = 0;\n\n\t \n\twcn36xx_dxe_disable_ch_int(wcn, WCN36XX_INT_MASK_CHAN_RX_H);\n\twcn36xx_dxe_disable_ch_int(wcn, WCN36XX_INT_MASK_CHAN_RX_L);\n\twcn36xx_dxe_disable_ch_int(wcn, WCN36XX_INT_MASK_CHAN_TX_H);\n\twcn36xx_dxe_disable_ch_int(wcn, WCN36XX_INT_MASK_CHAN_TX_L);\n\n\tfree_irq(wcn->tx_irq, wcn);\n\tfree_irq(wcn->rx_irq, wcn);\n\tdel_timer(&wcn->tx_ack_timer);\n\n\tif (wcn->tx_ack_skb) {\n\t\tieee80211_tx_status_irqsafe(wcn->hw, wcn->tx_ack_skb);\n\t\twcn->tx_ack_skb = NULL;\n\t}\n\n\t \n\treg_data = WCN36XX_DXE_REG_RESET;\n\twcn36xx_dxe_write_register(wcn, WCN36XX_DXE_REG_CSR_RESET, reg_data);\n\n\twcn36xx_dxe_ch_free_skbs(wcn, &wcn->dxe_rx_l_ch);\n\twcn36xx_dxe_ch_free_skbs(wcn, &wcn->dxe_rx_h_ch);\n\n\twcn36xx_dxe_deinit_descs(wcn->dev, &wcn->dxe_tx_l_ch);\n\twcn36xx_dxe_deinit_descs(wcn->dev, &wcn->dxe_tx_h_ch);\n\twcn36xx_dxe_deinit_descs(wcn->dev, &wcn->dxe_rx_l_ch);\n\twcn36xx_dxe_deinit_descs(wcn->dev, &wcn->dxe_rx_h_ch);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}