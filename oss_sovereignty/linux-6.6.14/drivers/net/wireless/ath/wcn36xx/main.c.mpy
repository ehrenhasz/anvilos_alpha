{
  "module_name": "main.c",
  "hash_id": "3c63465f00208212387eff79c7ace805d61944e2fe6e64f4527eb89fce1d3374",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/ath/wcn36xx/main.c",
  "human_readable_source": " \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/firmware.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/rpmsg.h>\n#include <linux/soc/qcom/smem_state.h>\n#include <linux/soc/qcom/wcnss_ctrl.h>\n#include <net/ipv6.h>\n#include \"wcn36xx.h\"\n#include \"testmode.h\"\n#include \"firmware.h\"\n\nunsigned int wcn36xx_dbg_mask;\nmodule_param_named(debug_mask, wcn36xx_dbg_mask, uint, 0644);\nMODULE_PARM_DESC(debug_mask, \"Debugging mask\");\n\n#define CHAN2G(_freq, _idx) { \\\n\t.band = NL80211_BAND_2GHZ, \\\n\t.center_freq = (_freq), \\\n\t.hw_value = (_idx), \\\n\t.max_power = 25, \\\n}\n\n#define CHAN5G(_freq, _idx, _phy_val) { \\\n\t.band = NL80211_BAND_5GHZ, \\\n\t.center_freq = (_freq), \\\n\t.hw_value = (_phy_val) << HW_VALUE_PHY_SHIFT | HW_VALUE_CHANNEL(_idx), \\\n\t.max_power = 25, \\\n}\n\n \nstatic struct ieee80211_channel wcn_2ghz_channels[] = {\n\tCHAN2G(2412, 1),  \n\tCHAN2G(2417, 2),  \n\tCHAN2G(2422, 3),  \n\tCHAN2G(2427, 4),  \n\tCHAN2G(2432, 5),  \n\tCHAN2G(2437, 6),  \n\tCHAN2G(2442, 7),  \n\tCHAN2G(2447, 8),  \n\tCHAN2G(2452, 9),  \n\tCHAN2G(2457, 10),  \n\tCHAN2G(2462, 11),  \n\tCHAN2G(2467, 12),  \n\tCHAN2G(2472, 13),  \n\tCHAN2G(2484, 14)   \n\n};\n\nstatic struct ieee80211_channel wcn_5ghz_channels[] = {\n\tCHAN5G(5180, 36, PHY_QUADRUPLE_CHANNEL_20MHZ_LOW_40MHZ_LOW),\n\tCHAN5G(5200, 40, PHY_QUADRUPLE_CHANNEL_20MHZ_HIGH_40MHZ_LOW),\n\tCHAN5G(5220, 44, PHY_QUADRUPLE_CHANNEL_20MHZ_LOW_40MHZ_HIGH),\n\tCHAN5G(5240, 48, PHY_QUADRUPLE_CHANNEL_20MHZ_HIGH_40MHZ_HIGH),\n\tCHAN5G(5260, 52, PHY_QUADRUPLE_CHANNEL_20MHZ_LOW_40MHZ_LOW),\n\tCHAN5G(5280, 56, PHY_QUADRUPLE_CHANNEL_20MHZ_HIGH_40MHZ_LOW),\n\tCHAN5G(5300, 60, PHY_QUADRUPLE_CHANNEL_20MHZ_LOW_40MHZ_HIGH),\n\tCHAN5G(5320, 64, PHY_QUADRUPLE_CHANNEL_20MHZ_HIGH_40MHZ_HIGH),\n\tCHAN5G(5500, 100, PHY_QUADRUPLE_CHANNEL_20MHZ_LOW_40MHZ_LOW),\n\tCHAN5G(5520, 104, PHY_QUADRUPLE_CHANNEL_20MHZ_HIGH_40MHZ_LOW),\n\tCHAN5G(5540, 108, PHY_QUADRUPLE_CHANNEL_20MHZ_LOW_40MHZ_HIGH),\n\tCHAN5G(5560, 112, PHY_QUADRUPLE_CHANNEL_20MHZ_HIGH_40MHZ_HIGH),\n\tCHAN5G(5580, 116, PHY_QUADRUPLE_CHANNEL_20MHZ_LOW_40MHZ_LOW),\n\tCHAN5G(5600, 120, PHY_QUADRUPLE_CHANNEL_20MHZ_HIGH_40MHZ_LOW),\n\tCHAN5G(5620, 124, PHY_QUADRUPLE_CHANNEL_20MHZ_LOW_40MHZ_HIGH),\n\tCHAN5G(5640, 128, PHY_QUADRUPLE_CHANNEL_20MHZ_HIGH_40MHZ_HIGH),\n\tCHAN5G(5660, 132, PHY_QUADRUPLE_CHANNEL_20MHZ_LOW_40MHZ_LOW),\n\tCHAN5G(5680, 136, PHY_QUADRUPLE_CHANNEL_20MHZ_HIGH_40MHZ_LOW),\n\tCHAN5G(5700, 140, PHY_QUADRUPLE_CHANNEL_20MHZ_LOW_40MHZ_HIGH),\n\tCHAN5G(5720, 144, PHY_QUADRUPLE_CHANNEL_20MHZ_HIGH_40MHZ_HIGH),\n\tCHAN5G(5745, 149, PHY_QUADRUPLE_CHANNEL_20MHZ_LOW_40MHZ_LOW),\n\tCHAN5G(5765, 153, PHY_QUADRUPLE_CHANNEL_20MHZ_HIGH_40MHZ_LOW),\n\tCHAN5G(5785, 157, PHY_QUADRUPLE_CHANNEL_20MHZ_LOW_40MHZ_HIGH),\n\tCHAN5G(5805, 161, PHY_QUADRUPLE_CHANNEL_20MHZ_HIGH_40MHZ_HIGH),\n\tCHAN5G(5825, 165, 0)\n};\n\n#define RATE(_bitrate, _hw_rate, _flags) { \\\n\t.bitrate        = (_bitrate),                   \\\n\t.flags          = (_flags),                     \\\n\t.hw_value       = (_hw_rate),                   \\\n\t.hw_value_short = (_hw_rate)  \\\n}\n\nstatic struct ieee80211_rate wcn_2ghz_rates[] = {\n\tRATE(10, HW_RATE_INDEX_1MBPS, 0),\n\tRATE(20, HW_RATE_INDEX_2MBPS, IEEE80211_RATE_SHORT_PREAMBLE),\n\tRATE(55, HW_RATE_INDEX_5_5MBPS, IEEE80211_RATE_SHORT_PREAMBLE),\n\tRATE(110, HW_RATE_INDEX_11MBPS, IEEE80211_RATE_SHORT_PREAMBLE),\n\tRATE(60, HW_RATE_INDEX_6MBPS, 0),\n\tRATE(90, HW_RATE_INDEX_9MBPS, 0),\n\tRATE(120, HW_RATE_INDEX_12MBPS, 0),\n\tRATE(180, HW_RATE_INDEX_18MBPS, 0),\n\tRATE(240, HW_RATE_INDEX_24MBPS, 0),\n\tRATE(360, HW_RATE_INDEX_36MBPS, 0),\n\tRATE(480, HW_RATE_INDEX_48MBPS, 0),\n\tRATE(540, HW_RATE_INDEX_54MBPS, 0)\n};\n\nstatic struct ieee80211_rate wcn_5ghz_rates[] = {\n\tRATE(60, HW_RATE_INDEX_6MBPS, 0),\n\tRATE(90, HW_RATE_INDEX_9MBPS, 0),\n\tRATE(120, HW_RATE_INDEX_12MBPS, 0),\n\tRATE(180, HW_RATE_INDEX_18MBPS, 0),\n\tRATE(240, HW_RATE_INDEX_24MBPS, 0),\n\tRATE(360, HW_RATE_INDEX_36MBPS, 0),\n\tRATE(480, HW_RATE_INDEX_48MBPS, 0),\n\tRATE(540, HW_RATE_INDEX_54MBPS, 0)\n};\n\nstatic struct ieee80211_supported_band wcn_band_2ghz = {\n\t.channels\t= wcn_2ghz_channels,\n\t.n_channels\t= ARRAY_SIZE(wcn_2ghz_channels),\n\t.bitrates\t= wcn_2ghz_rates,\n\t.n_bitrates\t= ARRAY_SIZE(wcn_2ghz_rates),\n\t.ht_cap\t\t= {\n\t\t.cap =\tIEEE80211_HT_CAP_GRN_FLD |\n\t\t\tIEEE80211_HT_CAP_SGI_20 |\n\t\t\tIEEE80211_HT_CAP_DSSSCCK40 |\n\t\t\tIEEE80211_HT_CAP_LSIG_TXOP_PROT |\n\t\t\tIEEE80211_HT_CAP_SGI_40 |\n\t\t\tIEEE80211_HT_CAP_SUP_WIDTH_20_40,\n\t\t.ht_supported = true,\n\t\t.ampdu_factor = IEEE80211_HT_MAX_AMPDU_64K,\n\t\t.ampdu_density = IEEE80211_HT_MPDU_DENSITY_16,\n\t\t.mcs = {\n\t\t\t.rx_mask = { 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, },\n\t\t\t.rx_highest = cpu_to_le16(72),\n\t\t\t.tx_params = IEEE80211_HT_MCS_TX_DEFINED,\n\t\t}\n\t}\n};\n\nstatic struct ieee80211_supported_band wcn_band_5ghz = {\n\t.channels\t= wcn_5ghz_channels,\n\t.n_channels\t= ARRAY_SIZE(wcn_5ghz_channels),\n\t.bitrates\t= wcn_5ghz_rates,\n\t.n_bitrates\t= ARRAY_SIZE(wcn_5ghz_rates),\n\t.ht_cap\t\t= {\n\t\t.cap =\tIEEE80211_HT_CAP_GRN_FLD |\n\t\t\tIEEE80211_HT_CAP_SGI_20 |\n\t\t\tIEEE80211_HT_CAP_DSSSCCK40 |\n\t\t\tIEEE80211_HT_CAP_LSIG_TXOP_PROT |\n\t\t\tIEEE80211_HT_CAP_SGI_40 |\n\t\t\tIEEE80211_HT_CAP_SUP_WIDTH_20_40,\n\t\t.ht_supported = true,\n\t\t.ampdu_factor = IEEE80211_HT_MAX_AMPDU_64K,\n\t\t.ampdu_density = IEEE80211_HT_MPDU_DENSITY_16,\n\t\t.mcs = {\n\t\t\t.rx_mask = { 0xff, 0, 0, 0, 0, 0, 0, 0, 0, 0, },\n\t\t\t.rx_highest = cpu_to_le16(150),\n\t\t\t.tx_params = IEEE80211_HT_MCS_TX_DEFINED,\n\t\t}\n\t}\n};\n\n#ifdef CONFIG_PM\n\nstatic const struct wiphy_wowlan_support wowlan_support = {\n\t.flags = WIPHY_WOWLAN_ANY\t|\n\t\t WIPHY_WOWLAN_MAGIC_PKT\t|\n\t\t WIPHY_WOWLAN_SUPPORTS_GTK_REKEY\n};\n\n#endif\n\nstatic inline u8 get_sta_index(struct ieee80211_vif *vif,\n\t\t\t       struct wcn36xx_sta *sta_priv)\n{\n\treturn NL80211_IFTYPE_STATION == vif->type ?\n\t       sta_priv->bss_sta_index :\n\t       sta_priv->sta_index;\n}\n\nstatic void wcn36xx_feat_caps_info(struct wcn36xx *wcn)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_FEATURE_SUPPORTED; i++) {\n\t\tif (wcn36xx_firmware_get_feat_caps(wcn->fw_feat_caps, i)) {\n\t\t\twcn36xx_dbg(WCN36XX_DBG_MAC, \"FW Cap %s\\n\",\n\t\t\t\t    wcn36xx_firmware_get_cap_name(i));\n\t\t}\n\t}\n}\n\nstatic int wcn36xx_start(struct ieee80211_hw *hw)\n{\n\tstruct wcn36xx *wcn = hw->priv;\n\tint ret;\n\n\twcn36xx_dbg(WCN36XX_DBG_MAC, \"mac start\\n\");\n\n\t \n\tret = wcn36xx_smd_open(wcn);\n\tif (ret) {\n\t\twcn36xx_err(\"Failed to open smd channel: %d\\n\", ret);\n\t\tgoto out_err;\n\t}\n\n\t \n\tret = wcn36xx_dxe_allocate_mem_pools(wcn);\n\tif (ret) {\n\t\twcn36xx_err(\"Failed to alloc DXE mempool: %d\\n\", ret);\n\t\tgoto out_smd_close;\n\t}\n\n\tret = wcn36xx_dxe_alloc_ctl_blks(wcn);\n\tif (ret) {\n\t\twcn36xx_err(\"Failed to alloc DXE ctl blocks: %d\\n\", ret);\n\t\tgoto out_free_dxe_pool;\n\t}\n\n\tret = wcn36xx_smd_load_nv(wcn);\n\tif (ret) {\n\t\twcn36xx_err(\"Failed to push NV to chip\\n\");\n\t\tgoto out_free_dxe_ctl;\n\t}\n\n\tret = wcn36xx_smd_start(wcn);\n\tif (ret) {\n\t\twcn36xx_err(\"Failed to start chip\\n\");\n\t\tgoto out_free_dxe_ctl;\n\t}\n\n\tif (!wcn36xx_is_fw_version(wcn, 1, 2, 2, 24)) {\n\t\tret = wcn36xx_smd_feature_caps_exchange(wcn);\n\t\tif (ret)\n\t\t\twcn36xx_warn(\"Exchange feature caps failed\\n\");\n\t\telse\n\t\t\twcn36xx_feat_caps_info(wcn);\n\t}\n\n\t \n\tret = wcn36xx_dxe_init(wcn);\n\tif (ret) {\n\t\twcn36xx_err(\"DXE init failed\\n\");\n\t\tgoto out_smd_stop;\n\t}\n\n\twcn36xx_debugfs_init(wcn);\n\n\tINIT_LIST_HEAD(&wcn->vif_list);\n\tspin_lock_init(&wcn->dxe_lock);\n\tspin_lock_init(&wcn->survey_lock);\n\n\treturn 0;\n\nout_smd_stop:\n\twcn36xx_smd_stop(wcn);\nout_free_dxe_ctl:\n\twcn36xx_dxe_free_ctl_blks(wcn);\nout_free_dxe_pool:\n\twcn36xx_dxe_free_mem_pools(wcn);\nout_smd_close:\n\twcn36xx_smd_close(wcn);\nout_err:\n\treturn ret;\n}\n\nstatic void wcn36xx_stop(struct ieee80211_hw *hw)\n{\n\tstruct wcn36xx *wcn = hw->priv;\n\n\twcn36xx_dbg(WCN36XX_DBG_MAC, \"mac stop\\n\");\n\n\tmutex_lock(&wcn->scan_lock);\n\tif (wcn->scan_req) {\n\t\tstruct cfg80211_scan_info scan_info = {\n\t\t\t.aborted = true,\n\t\t};\n\n\t\tieee80211_scan_completed(wcn->hw, &scan_info);\n\t}\n\twcn->scan_req = NULL;\n\tmutex_unlock(&wcn->scan_lock);\n\n\twcn36xx_debugfs_exit(wcn);\n\twcn36xx_smd_stop(wcn);\n\twcn36xx_dxe_deinit(wcn);\n\twcn36xx_smd_close(wcn);\n\n\twcn36xx_dxe_free_mem_pools(wcn);\n\twcn36xx_dxe_free_ctl_blks(wcn);\n}\n\nstatic void wcn36xx_change_ps(struct wcn36xx *wcn, bool enable)\n{\n\tstruct ieee80211_vif *vif = NULL;\n\tstruct wcn36xx_vif *tmp;\n\n\tlist_for_each_entry(tmp, &wcn->vif_list, list) {\n\t\tvif = wcn36xx_priv_to_vif(tmp);\n\t\tif (enable && !wcn->sw_scan) {\n\t\t\tif (vif->cfg.ps)  \n\t\t\t\twcn36xx_pmc_enter_bmps_state(wcn, vif);\n\t\t} else {\n\t\t\twcn36xx_pmc_exit_bmps_state(wcn, vif);\n\t\t}\n\t}\n}\n\nstatic void wcn36xx_change_opchannel(struct wcn36xx *wcn, int ch)\n{\n\tstruct ieee80211_vif *vif = NULL;\n\tstruct wcn36xx_vif *tmp;\n\tstruct ieee80211_supported_band *band;\n\tstruct ieee80211_channel *channel = NULL;\n\tunsigned long flags;\n\tint i, j;\n\n\tfor (i = 0; i < ARRAY_SIZE(wcn->hw->wiphy->bands); i++) {\n\t\tband = wcn->hw->wiphy->bands[i];\n\t\tif (!band)\n\t\t\tbreak;\n\t\tfor (j = 0; j < band->n_channels; j++) {\n\t\t\tif (HW_VALUE_CHANNEL(band->channels[j].hw_value) == ch) {\n\t\t\t\tchannel = &band->channels[j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (channel)\n\t\t\tbreak;\n\t}\n\n\tif (!channel) {\n\t\twcn36xx_err(\"Cannot tune to channel %d\\n\", ch);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&wcn->survey_lock, flags);\n\twcn->band = band;\n\twcn->channel = channel;\n\tspin_unlock_irqrestore(&wcn->survey_lock, flags);\n\n\tlist_for_each_entry(tmp, &wcn->vif_list, list) {\n\t\tvif = wcn36xx_priv_to_vif(tmp);\n\t\twcn36xx_smd_switch_channel(wcn, vif, ch);\n\t}\n\n\treturn;\n}\n\nstatic int wcn36xx_config(struct ieee80211_hw *hw, u32 changed)\n{\n\tstruct wcn36xx *wcn = hw->priv;\n\tint ret;\n\n\twcn36xx_dbg(WCN36XX_DBG_MAC, \"mac config changed 0x%08x\\n\", changed);\n\n\tmutex_lock(&wcn->conf_mutex);\n\n\tif (changed & IEEE80211_CONF_CHANGE_CHANNEL) {\n\t\tint ch = WCN36XX_HW_CHANNEL(wcn);\n\t\twcn36xx_dbg(WCN36XX_DBG_MAC, \"wcn36xx_config channel switch=%d\\n\",\n\t\t\t    ch);\n\n\t\tif (wcn->sw_scan_opchannel == ch && wcn->sw_scan_channel) {\n\t\t\t \n\t\t\tif (wcn->sw_scan_channel)\n\t\t\t\twcn36xx_smd_end_scan(wcn, wcn->sw_scan_channel);\n\t\t\tif (wcn->sw_scan_init) {\n\t\t\t\twcn36xx_smd_finish_scan(wcn, HAL_SYS_MODE_SCAN,\n\t\t\t\t\t\t\twcn->sw_scan_vif);\n\t\t\t}\n\t\t} else if (wcn->sw_scan) {\n\t\t\t \n\t\t\tif (wcn->sw_scan_channel)\n\t\t\t\twcn36xx_smd_end_scan(wcn, wcn->sw_scan_channel);\n\t\t\tif (!wcn->sw_scan_init) {\n\t\t\t\t \n\t\t\t\tret = wcn36xx_smd_init_scan(wcn,\n\t\t\t\t\t\t\t    HAL_SYS_MODE_SCAN,\n\t\t\t\t\t\t\t    wcn->sw_scan_vif);\n\t\t\t\tif (ret) {\n\t\t\t\t\tmutex_unlock(&wcn->conf_mutex);\n\t\t\t\t\treturn -EIO;\n\t\t\t\t}\n\t\t\t}\n\t\t\twcn36xx_smd_start_scan(wcn, ch);\n\t\t} else {\n\t\t\twcn36xx_change_opchannel(wcn, ch);\n\t\t}\n\t}\n\n\tif (changed & IEEE80211_CONF_CHANGE_PS)\n\t\twcn36xx_change_ps(wcn, hw->conf.flags & IEEE80211_CONF_PS);\n\n\tif (changed & IEEE80211_CONF_CHANGE_IDLE) {\n\t\tif (hw->conf.flags & IEEE80211_CONF_IDLE)\n\t\t\twcn36xx_smd_enter_imps(wcn);\n\t\telse\n\t\t\twcn36xx_smd_exit_imps(wcn);\n\t}\n\n\tmutex_unlock(&wcn->conf_mutex);\n\n\treturn 0;\n}\n\nstatic void wcn36xx_configure_filter(struct ieee80211_hw *hw,\n\t\t\t\t     unsigned int changed,\n\t\t\t\t     unsigned int *total, u64 multicast)\n{\n\tstruct wcn36xx_hal_rcv_flt_mc_addr_list_type *fp;\n\tstruct wcn36xx *wcn = hw->priv;\n\tstruct wcn36xx_vif *tmp;\n\tstruct ieee80211_vif *vif = NULL;\n\n\twcn36xx_dbg(WCN36XX_DBG_MAC, \"mac configure filter\\n\");\n\n\tmutex_lock(&wcn->conf_mutex);\n\n\t*total &= FIF_ALLMULTI;\n\n\tfp = (void *)(unsigned long)multicast;\n\tlist_for_each_entry(tmp, &wcn->vif_list, list) {\n\t\tvif = wcn36xx_priv_to_vif(tmp);\n\n\t\t \n\t\tif (*total & FIF_ALLMULTI)\n\t\t\twcn36xx_smd_set_mc_list(wcn, vif, NULL);\n\t\telse if (NL80211_IFTYPE_STATION == vif->type && tmp->sta_assoc)\n\t\t\twcn36xx_smd_set_mc_list(wcn, vif, fp);\n\t}\n\n\tmutex_unlock(&wcn->conf_mutex);\n\tkfree(fp);\n}\n\nstatic u64 wcn36xx_prepare_multicast(struct ieee80211_hw *hw,\n\t\t\t\t     struct netdev_hw_addr_list *mc_list)\n{\n\tstruct wcn36xx_hal_rcv_flt_mc_addr_list_type *fp;\n\tstruct netdev_hw_addr *ha;\n\n\twcn36xx_dbg(WCN36XX_DBG_MAC, \"mac prepare multicast list\\n\");\n\tfp = kzalloc(sizeof(*fp), GFP_ATOMIC);\n\tif (!fp) {\n\t\twcn36xx_err(\"Out of memory setting filters.\\n\");\n\t\treturn 0;\n\t}\n\n\tfp->mc_addr_count = 0;\n\t \n\tif (netdev_hw_addr_list_count(mc_list) <=\n\t    WCN36XX_HAL_MAX_NUM_MULTICAST_ADDRESS) {\n\t\tnetdev_hw_addr_list_for_each(ha, mc_list) {\n\t\t\tmemcpy(fp->mc_addr[fp->mc_addr_count],\n\t\t\t\t\tha->addr, ETH_ALEN);\n\t\t\tfp->mc_addr_count++;\n\t\t}\n\t}\n\n\treturn (u64)(unsigned long)fp;\n}\n\nstatic void wcn36xx_tx(struct ieee80211_hw *hw,\n\t\t       struct ieee80211_tx_control *control,\n\t\t       struct sk_buff *skb)\n{\n\tstruct wcn36xx *wcn = hw->priv;\n\tstruct wcn36xx_sta *sta_priv = NULL;\n\n\tif (control->sta)\n\t\tsta_priv = wcn36xx_sta_to_priv(control->sta);\n\n\tif (wcn36xx_start_tx(wcn, sta_priv, skb))\n\t\tieee80211_free_txskb(wcn->hw, skb);\n}\n\nstatic int wcn36xx_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,\n\t\t\t   struct ieee80211_vif *vif,\n\t\t\t   struct ieee80211_sta *sta,\n\t\t\t   struct ieee80211_key_conf *key_conf)\n{\n\tstruct wcn36xx *wcn = hw->priv;\n\tstruct wcn36xx_vif *vif_priv = wcn36xx_vif_to_priv(vif);\n\tstruct wcn36xx_sta *sta_priv = sta ? wcn36xx_sta_to_priv(sta) : NULL;\n\tint ret = 0;\n\tu8 key[WLAN_MAX_KEY_LEN];\n\n\twcn36xx_dbg(WCN36XX_DBG_MAC, \"mac80211 set key\\n\");\n\twcn36xx_dbg(WCN36XX_DBG_MAC, \"Key: cmd=0x%x algo:0x%x, id:%d, len:%d flags 0x%x\\n\",\n\t\t    cmd, key_conf->cipher, key_conf->keyidx,\n\t\t    key_conf->keylen, key_conf->flags);\n\twcn36xx_dbg_dump(WCN36XX_DBG_MAC, \"KEY: \",\n\t\t\t key_conf->key,\n\t\t\t key_conf->keylen);\n\n\tmutex_lock(&wcn->conf_mutex);\n\n\tswitch (key_conf->cipher) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\tvif_priv->encrypt_type = WCN36XX_HAL_ED_WEP40;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\tvif_priv->encrypt_type = WCN36XX_HAL_ED_WEP104;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tvif_priv->encrypt_type = WCN36XX_HAL_ED_CCMP;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\tvif_priv->encrypt_type = WCN36XX_HAL_ED_TKIP;\n\t\tbreak;\n\tdefault:\n\t\twcn36xx_err(\"Unsupported key type 0x%x\\n\",\n\t\t\t      key_conf->cipher);\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tswitch (cmd) {\n\tcase SET_KEY:\n\t\tif (WCN36XX_HAL_ED_TKIP == vif_priv->encrypt_type) {\n\t\t\t \n\t\t\tmemcpy(key, key_conf->key, 16);\n\t\t\tmemcpy(key + 16, key_conf->key + 24, 8);\n\t\t\tmemcpy(key + 24, key_conf->key + 16, 8);\n\t\t} else {\n\t\t\tmemcpy(key, key_conf->key, key_conf->keylen);\n\t\t}\n\n\t\tif (IEEE80211_KEY_FLAG_PAIRWISE & key_conf->flags) {\n\t\t\tsta_priv->is_data_encrypted = true;\n\t\t\t \n\t\t\tif (NL80211_IFTYPE_STATION == vif->type) {\n\t\t\t\twcn36xx_smd_config_bss(wcn,\n\t\t\t\t\t\t       vif,\n\t\t\t\t\t\t       sta,\n\t\t\t\t\t\t       sta->addr,\n\t\t\t\t\t\t       true);\n\t\t\t\twcn36xx_smd_config_sta(wcn, vif, sta);\n\t\t\t}\n\n\t\t\twcn36xx_smd_set_stakey(wcn,\n\t\t\t\tvif_priv->encrypt_type,\n\t\t\t\tkey_conf->keyidx,\n\t\t\t\tkey_conf->keylen,\n\t\t\t\tkey,\n\t\t\t\tget_sta_index(vif, sta_priv));\n\t\t} else {\n\t\t\twcn36xx_smd_set_bsskey(wcn,\n\t\t\t\tvif_priv->encrypt_type,\n\t\t\t\tvif_priv->bss_index,\n\t\t\t\tkey_conf->keyidx,\n\t\t\t\tkey_conf->keylen,\n\t\t\t\tkey);\n\n\t\t\tif ((WLAN_CIPHER_SUITE_WEP40 == key_conf->cipher) ||\n\t\t\t    (WLAN_CIPHER_SUITE_WEP104 == key_conf->cipher)) {\n\t\t\t\tlist_for_each_entry(sta_priv,\n\t\t\t\t\t\t    &vif_priv->sta_list, list) {\n\t\t\t\t\tsta_priv->is_data_encrypted = true;\n\t\t\t\t\twcn36xx_smd_set_stakey(wcn,\n\t\t\t\t\t\tvif_priv->encrypt_type,\n\t\t\t\t\t\tkey_conf->keyidx,\n\t\t\t\t\t\tkey_conf->keylen,\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tget_sta_index(vif, sta_priv));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase DISABLE_KEY:\n\t\tif (!(IEEE80211_KEY_FLAG_PAIRWISE & key_conf->flags)) {\n\t\t\tif (vif_priv->bss_index != WCN36XX_HAL_BSS_INVALID_IDX)\n\t\t\t\twcn36xx_smd_remove_bsskey(wcn,\n\t\t\t\t\tvif_priv->encrypt_type,\n\t\t\t\t\tvif_priv->bss_index,\n\t\t\t\t\tkey_conf->keyidx);\n\n\t\t\tvif_priv->encrypt_type = WCN36XX_HAL_ED_NONE;\n\t\t} else {\n\t\t\tsta_priv->is_data_encrypted = false;\n\t\t\t \n\t\t\tif (sta_priv->aid)\n\t\t\t\twcn36xx_smd_remove_stakey(wcn,\n\t\t\t\t\tvif_priv->encrypt_type,\n\t\t\t\t\tkey_conf->keyidx,\n\t\t\t\t\tget_sta_index(vif, sta_priv));\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\twcn36xx_err(\"Unsupported key cmd 0x%x\\n\", cmd);\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\nout:\n\tmutex_unlock(&wcn->conf_mutex);\n\n\treturn ret;\n}\n\nstatic int wcn36xx_hw_scan(struct ieee80211_hw *hw,\n\t\t\t   struct ieee80211_vif *vif,\n\t\t\t   struct ieee80211_scan_request *hw_req)\n{\n\tstruct wcn36xx *wcn = hw->priv;\n\n\tif (!wcn36xx_firmware_get_feat_caps(wcn->fw_feat_caps, SCAN_OFFLOAD)) {\n\t\t \n\t\treturn 1;\n\t}\n\n\t \n\tif (hw_req->req.n_channels > 48) {\n\t\twcn36xx_warn(\"Offload scan aborted, n_channels=%u\",\n\t\t\t     hw_req->req.n_channels);\n\t\treturn 1;\n\t}\n\n\tmutex_lock(&wcn->scan_lock);\n\tif (wcn->scan_req) {\n\t\tmutex_unlock(&wcn->scan_lock);\n\t\treturn -EBUSY;\n\t}\n\n\twcn->scan_aborted = false;\n\twcn->scan_req = &hw_req->req;\n\n\tmutex_unlock(&wcn->scan_lock);\n\n\twcn36xx_smd_update_channel_list(wcn, &hw_req->req);\n\treturn wcn36xx_smd_start_hw_scan(wcn, vif, &hw_req->req);\n}\n\nstatic void wcn36xx_cancel_hw_scan(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tstruct wcn36xx *wcn = hw->priv;\n\n\tmutex_lock(&wcn->scan_lock);\n\twcn->scan_aborted = true;\n\tmutex_unlock(&wcn->scan_lock);\n\n\tif (wcn36xx_firmware_get_feat_caps(wcn->fw_feat_caps, SCAN_OFFLOAD)) {\n\t\t \n\t\twcn36xx_smd_stop_hw_scan(wcn);\n\t}\n}\n\nstatic void wcn36xx_sw_scan_start(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  const u8 *mac_addr)\n{\n\tstruct wcn36xx *wcn = hw->priv;\n\tstruct wcn36xx_vif *vif_priv = wcn36xx_vif_to_priv(vif);\n\n\twcn36xx_dbg(WCN36XX_DBG_MAC, \"sw_scan_start\");\n\n\twcn->sw_scan = true;\n\twcn->sw_scan_vif = vif;\n\twcn->sw_scan_channel = 0;\n\tif (vif_priv->sta_assoc)\n\t\twcn->sw_scan_opchannel = WCN36XX_HW_CHANNEL(wcn);\n\telse\n\t\twcn->sw_scan_opchannel = 0;\n}\n\nstatic void wcn36xx_sw_scan_complete(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct wcn36xx *wcn = hw->priv;\n\n\twcn36xx_dbg(WCN36XX_DBG_MAC, \"sw_scan_complete\");\n\n\t \n\tif (wcn->sw_scan_channel)\n\t\twcn36xx_smd_end_scan(wcn, wcn->sw_scan_channel);\n\tif (wcn->sw_scan_init) {\n\t\twcn36xx_smd_finish_scan(wcn, HAL_SYS_MODE_SCAN,\n\t\t\t\t\twcn->sw_scan_vif);\n\t}\n\twcn->sw_scan = false;\n\twcn->sw_scan_opchannel = 0;\n}\n\nstatic void wcn36xx_update_allowed_rates(struct ieee80211_sta *sta,\n\t\t\t\t\t enum nl80211_band band)\n{\n\tint i, size;\n\tu16 *rates_table;\n\tstruct wcn36xx_sta *sta_priv = wcn36xx_sta_to_priv(sta);\n\tu32 rates = sta->deflink.supp_rates[band];\n\n\tmemset(&sta_priv->supported_rates, 0,\n\t\tsizeof(sta_priv->supported_rates));\n\tsta_priv->supported_rates.op_rate_mode = STA_11n;\n\n\tsize = ARRAY_SIZE(sta_priv->supported_rates.dsss_rates);\n\trates_table = sta_priv->supported_rates.dsss_rates;\n\tif (band == NL80211_BAND_2GHZ) {\n\t\tfor (i = 0; i < size; i++) {\n\t\t\tif (rates & 0x01) {\n\t\t\t\trates_table[i] = wcn_2ghz_rates[i].hw_value;\n\t\t\t\trates = rates >> 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tsize = ARRAY_SIZE(sta_priv->supported_rates.ofdm_rates);\n\trates_table = sta_priv->supported_rates.ofdm_rates;\n\tfor (i = 0; i < size; i++) {\n\t\tif (rates & 0x01) {\n\t\t\trates_table[i] = wcn_5ghz_rates[i].hw_value;\n\t\t\trates = rates >> 1;\n\t\t}\n\t}\n\n\tif (sta->deflink.ht_cap.ht_supported) {\n\t\tBUILD_BUG_ON(sizeof(sta->deflink.ht_cap.mcs.rx_mask) >\n\t\t\t     sizeof(sta_priv->supported_rates.supported_mcs_set));\n\t\tmemcpy(sta_priv->supported_rates.supported_mcs_set,\n\t\t       sta->deflink.ht_cap.mcs.rx_mask,\n\t\t       sizeof(sta->deflink.ht_cap.mcs.rx_mask));\n\t}\n\n\tif (sta->deflink.vht_cap.vht_supported) {\n\t\tsta_priv->supported_rates.op_rate_mode = STA_11ac;\n\t\tsta_priv->supported_rates.vht_rx_mcs_map =\n\t\t\t\tsta->deflink.vht_cap.vht_mcs.rx_mcs_map;\n\t\tsta_priv->supported_rates.vht_tx_mcs_map =\n\t\t\t\tsta->deflink.vht_cap.vht_mcs.tx_mcs_map;\n\t}\n}\n\nvoid wcn36xx_set_default_rates(struct wcn36xx_hal_supported_rates *rates)\n{\n\tu16 ofdm_rates[WCN36XX_HAL_NUM_OFDM_RATES] = {\n\t\tHW_RATE_INDEX_6MBPS,\n\t\tHW_RATE_INDEX_9MBPS,\n\t\tHW_RATE_INDEX_12MBPS,\n\t\tHW_RATE_INDEX_18MBPS,\n\t\tHW_RATE_INDEX_24MBPS,\n\t\tHW_RATE_INDEX_36MBPS,\n\t\tHW_RATE_INDEX_48MBPS,\n\t\tHW_RATE_INDEX_54MBPS\n\t};\n\tu16 dsss_rates[WCN36XX_HAL_NUM_DSSS_RATES] = {\n\t\tHW_RATE_INDEX_1MBPS,\n\t\tHW_RATE_INDEX_2MBPS,\n\t\tHW_RATE_INDEX_5_5MBPS,\n\t\tHW_RATE_INDEX_11MBPS\n\t};\n\n\trates->op_rate_mode = STA_11n;\n\tmemcpy(rates->dsss_rates, dsss_rates,\n\t\tsizeof(*dsss_rates) * WCN36XX_HAL_NUM_DSSS_RATES);\n\tmemcpy(rates->ofdm_rates, ofdm_rates,\n\t\tsizeof(*ofdm_rates) * WCN36XX_HAL_NUM_OFDM_RATES);\n\trates->supported_mcs_set[0] = 0xFF;\n}\n\nvoid wcn36xx_set_default_rates_v1(struct wcn36xx_hal_supported_rates_v1 *rates)\n{\n\trates->op_rate_mode = STA_11ac;\n\trates->vht_rx_mcs_map = IEEE80211_VHT_MCS_SUPPORT_0_9;\n\trates->vht_tx_mcs_map = IEEE80211_VHT_MCS_SUPPORT_0_9;\n}\n\nstatic void wcn36xx_bss_info_changed(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t     struct ieee80211_bss_conf *bss_conf,\n\t\t\t\t     u64 changed)\n{\n\tstruct wcn36xx *wcn = hw->priv;\n\tstruct sk_buff *skb = NULL;\n\tu16 tim_off, tim_len;\n\tenum wcn36xx_hal_link_state link_state;\n\tstruct wcn36xx_vif *vif_priv = wcn36xx_vif_to_priv(vif);\n\n\twcn36xx_dbg(WCN36XX_DBG_MAC, \"mac bss info changed vif %p changed 0x%llx\\n\",\n\t\t    vif, changed);\n\n\tmutex_lock(&wcn->conf_mutex);\n\n\tif (changed & BSS_CHANGED_BEACON_INFO) {\n\t\twcn36xx_dbg(WCN36XX_DBG_MAC,\n\t\t\t    \"mac bss changed dtim period %d\\n\",\n\t\t\t    bss_conf->dtim_period);\n\n\t\tvif_priv->dtim_period = bss_conf->dtim_period;\n\t}\n\n\tif (changed & BSS_CHANGED_BSSID) {\n\t\twcn36xx_dbg(WCN36XX_DBG_MAC, \"mac bss changed_bssid %pM\\n\",\n\t\t\t    bss_conf->bssid);\n\n\t\tif (!is_zero_ether_addr(bss_conf->bssid)) {\n\t\t\tvif_priv->is_joining = true;\n\t\t\tvif_priv->bss_index = WCN36XX_HAL_BSS_INVALID_IDX;\n\t\t\twcn36xx_smd_set_link_st(wcn, bss_conf->bssid, vif->addr,\n\t\t\t\t\t\tWCN36XX_HAL_LINK_PREASSOC_STATE);\n\t\t\twcn36xx_smd_join(wcn, bss_conf->bssid,\n\t\t\t\t\t vif->addr, WCN36XX_HW_CHANNEL(wcn));\n\t\t\twcn36xx_smd_config_bss(wcn, vif, NULL,\n\t\t\t\t\t       bss_conf->bssid, false);\n\t\t} else {\n\t\t\tvif_priv->is_joining = false;\n\t\t\twcn36xx_smd_delete_bss(wcn, vif);\n\t\t\twcn36xx_smd_set_link_st(wcn, bss_conf->bssid, vif->addr,\n\t\t\t\t\t\tWCN36XX_HAL_LINK_IDLE_STATE);\n\t\t\tvif_priv->encrypt_type = WCN36XX_HAL_ED_NONE;\n\t\t}\n\t}\n\n\tif (changed & BSS_CHANGED_SSID) {\n\t\twcn36xx_dbg(WCN36XX_DBG_MAC,\n\t\t\t    \"mac bss changed ssid\\n\");\n\t\twcn36xx_dbg_dump(WCN36XX_DBG_MAC, \"ssid \",\n\t\t\t\t vif->cfg.ssid, vif->cfg.ssid_len);\n\n\t\tvif_priv->ssid.length = vif->cfg.ssid_len;\n\t\tmemcpy(&vif_priv->ssid.ssid,\n\t\t       vif->cfg.ssid,\n\t\t       vif->cfg.ssid_len);\n\t}\n\n\tif (changed & BSS_CHANGED_ASSOC) {\n\t\tvif_priv->is_joining = false;\n\t\tif (vif->cfg.assoc) {\n\t\t\tstruct ieee80211_sta *sta;\n\t\t\tstruct wcn36xx_sta *sta_priv;\n\n\t\t\twcn36xx_dbg(WCN36XX_DBG_MAC,\n\t\t\t\t    \"mac assoc bss %pM vif %pM AID=%d\\n\",\n\t\t\t\t     bss_conf->bssid,\n\t\t\t\t     vif->addr,\n\t\t\t\t     vif->cfg.aid);\n\n\t\t\tvif_priv->sta_assoc = true;\n\n\t\t\t \n\t\t\tsta = ieee80211_find_sta(vif, bss_conf->bssid);\n\t\t\tif (!sta) {\n\t\t\t\twcn36xx_err(\"sta %pM is not found\\n\",\n\t\t\t\t\t      bss_conf->bssid);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tsta_priv = wcn36xx_sta_to_priv(sta);\n\n\t\t\twcn36xx_update_allowed_rates(sta, WCN36XX_BAND(wcn));\n\n\t\t\twcn36xx_smd_set_link_st(wcn, bss_conf->bssid,\n\t\t\t\tvif->addr,\n\t\t\t\tWCN36XX_HAL_LINK_POSTASSOC_STATE);\n\t\t\twcn36xx_smd_config_bss(wcn, vif, sta,\n\t\t\t\t\t       bss_conf->bssid,\n\t\t\t\t\t       true);\n\t\t\tsta_priv->aid = vif->cfg.aid;\n\t\t\t \n\t\t\twcn36xx_smd_config_sta(wcn, vif, sta);\n\t\t\tif (vif->type == NL80211_IFTYPE_STATION)\n\t\t\t\twcn36xx_smd_add_beacon_filter(wcn, vif);\n\t\t\twcn36xx_enable_keep_alive_null_packet(wcn, vif);\n\t\t} else {\n\t\t\twcn36xx_dbg(WCN36XX_DBG_MAC,\n\t\t\t\t    \"disassociated bss %pM vif %pM AID=%d\\n\",\n\t\t\t\t    bss_conf->bssid,\n\t\t\t\t    vif->addr,\n\t\t\t\t    vif->cfg.aid);\n\t\t\tvif_priv->sta_assoc = false;\n\t\t\twcn36xx_smd_set_link_st(wcn,\n\t\t\t\t\t\tbss_conf->bssid,\n\t\t\t\t\t\tvif->addr,\n\t\t\t\t\t\tWCN36XX_HAL_LINK_IDLE_STATE);\n\t\t}\n\t}\n\n\tif (changed & BSS_CHANGED_AP_PROBE_RESP) {\n\t\twcn36xx_dbg(WCN36XX_DBG_MAC, \"mac bss changed ap probe resp\\n\");\n\t\tskb = ieee80211_proberesp_get(hw, vif);\n\t\tif (!skb) {\n\t\t\twcn36xx_err(\"failed to alloc probereq skb\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\twcn36xx_smd_update_proberesp_tmpl(wcn, vif, skb);\n\t\tdev_kfree_skb(skb);\n\t}\n\n\tif (changed & BSS_CHANGED_BEACON_ENABLED ||\n\t    changed & BSS_CHANGED_BEACON) {\n\t\twcn36xx_dbg(WCN36XX_DBG_MAC,\n\t\t\t    \"mac bss changed beacon enabled %d\\n\",\n\t\t\t    bss_conf->enable_beacon);\n\n\t\tif (bss_conf->enable_beacon) {\n\t\t\tvif_priv->dtim_period = bss_conf->dtim_period;\n\t\t\tvif_priv->bss_index = WCN36XX_HAL_BSS_INVALID_IDX;\n\t\t\twcn36xx_smd_config_bss(wcn, vif, NULL,\n\t\t\t\t\t       vif->addr, false);\n\t\t\tskb = ieee80211_beacon_get_tim(hw, vif, &tim_off,\n\t\t\t\t\t\t       &tim_len, 0);\n\t\t\tif (!skb) {\n\t\t\t\twcn36xx_err(\"failed to alloc beacon skb\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\twcn36xx_smd_send_beacon(wcn, vif, skb, tim_off, 0);\n\t\t\tdev_kfree_skb(skb);\n\n\t\t\tif (vif->type == NL80211_IFTYPE_ADHOC ||\n\t\t\t    vif->type == NL80211_IFTYPE_MESH_POINT)\n\t\t\t\tlink_state = WCN36XX_HAL_LINK_IBSS_STATE;\n\t\t\telse\n\t\t\t\tlink_state = WCN36XX_HAL_LINK_AP_STATE;\n\n\t\t\twcn36xx_smd_set_link_st(wcn, vif->addr, vif->addr,\n\t\t\t\t\t\tlink_state);\n\t\t} else {\n\t\t\twcn36xx_smd_delete_bss(wcn, vif);\n\t\t\twcn36xx_smd_set_link_st(wcn, vif->addr, vif->addr,\n\t\t\t\t\t\tWCN36XX_HAL_LINK_IDLE_STATE);\n\t\t}\n\t}\nout:\n\n\tmutex_unlock(&wcn->conf_mutex);\n}\n\n \nstatic int wcn36xx_set_rts_threshold(struct ieee80211_hw *hw, u32 value)\n{\n\tstruct wcn36xx *wcn = hw->priv;\n\twcn36xx_dbg(WCN36XX_DBG_MAC, \"mac set RTS threshold %d\\n\", value);\n\n\tmutex_lock(&wcn->conf_mutex);\n\twcn36xx_smd_update_cfg(wcn, WCN36XX_HAL_CFG_RTS_THRESHOLD, value);\n\tmutex_unlock(&wcn->conf_mutex);\n\n\treturn 0;\n}\n\nstatic void wcn36xx_remove_interface(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct wcn36xx *wcn = hw->priv;\n\tstruct wcn36xx_vif *vif_priv = wcn36xx_vif_to_priv(vif);\n\twcn36xx_dbg(WCN36XX_DBG_MAC, \"mac remove interface vif %p\\n\", vif);\n\n\tmutex_lock(&wcn->conf_mutex);\n\n\tlist_del(&vif_priv->list);\n\twcn36xx_smd_delete_sta_self(wcn, vif->addr);\n\n\tmutex_unlock(&wcn->conf_mutex);\n}\n\nstatic int wcn36xx_add_interface(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif)\n{\n\tstruct wcn36xx *wcn = hw->priv;\n\tstruct wcn36xx_vif *vif_priv = wcn36xx_vif_to_priv(vif);\n\n\twcn36xx_dbg(WCN36XX_DBG_MAC, \"mac add interface vif %p type %d\\n\",\n\t\t    vif, vif->type);\n\n\tif (!(NL80211_IFTYPE_STATION == vif->type ||\n\t      NL80211_IFTYPE_AP == vif->type ||\n\t      NL80211_IFTYPE_ADHOC == vif->type ||\n\t      NL80211_IFTYPE_MESH_POINT == vif->type)) {\n\t\twcn36xx_warn(\"Unsupported interface type requested: %d\\n\",\n\t\t\t     vif->type);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tmutex_lock(&wcn->conf_mutex);\n\n\tvif_priv->bss_index = WCN36XX_HAL_BSS_INVALID_IDX;\n\tINIT_LIST_HEAD(&vif_priv->sta_list);\n\tlist_add(&vif_priv->list, &wcn->vif_list);\n\twcn36xx_smd_add_sta_self(wcn, vif);\n\n\tmutex_unlock(&wcn->conf_mutex);\n\n\treturn 0;\n}\n\nstatic int wcn36xx_sta_add(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t   struct ieee80211_sta *sta)\n{\n\tstruct wcn36xx *wcn = hw->priv;\n\tstruct wcn36xx_vif *vif_priv = wcn36xx_vif_to_priv(vif);\n\tstruct wcn36xx_sta *sta_priv = wcn36xx_sta_to_priv(sta);\n\twcn36xx_dbg(WCN36XX_DBG_MAC, \"mac sta add vif %p sta %pM\\n\",\n\t\t    vif, sta->addr);\n\n\tmutex_lock(&wcn->conf_mutex);\n\n\tspin_lock_init(&sta_priv->ampdu_lock);\n\tsta_priv->vif = vif_priv;\n\tlist_add(&sta_priv->list, &vif_priv->sta_list);\n\n\t \n\tif (NL80211_IFTYPE_STATION != vif->type) {\n\t\twcn36xx_update_allowed_rates(sta, WCN36XX_BAND(wcn));\n\t\tsta_priv->aid = sta->aid;\n\t\twcn36xx_smd_config_sta(wcn, vif, sta);\n\t}\n\n\tmutex_unlock(&wcn->conf_mutex);\n\n\treturn 0;\n}\n\nstatic int wcn36xx_sta_remove(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      struct ieee80211_sta *sta)\n{\n\tstruct wcn36xx *wcn = hw->priv;\n\tstruct wcn36xx_sta *sta_priv = wcn36xx_sta_to_priv(sta);\n\n\twcn36xx_dbg(WCN36XX_DBG_MAC, \"mac sta remove vif %p sta %pM index %d\\n\",\n\t\t    vif, sta->addr, sta_priv->sta_index);\n\n\tmutex_lock(&wcn->conf_mutex);\n\n\tlist_del(&sta_priv->list);\n\twcn36xx_smd_delete_sta(wcn, sta_priv->sta_index);\n\tsta_priv->vif = NULL;\n\n\tmutex_unlock(&wcn->conf_mutex);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\n\nstatic struct ieee80211_vif *wcn36xx_get_first_assoc_vif(struct wcn36xx *wcn)\n{\n\tstruct wcn36xx_vif *vif_priv = NULL;\n\tstruct ieee80211_vif *vif = NULL;\n\n\tlist_for_each_entry(vif_priv, &wcn->vif_list, list) {\n\t\tif (vif_priv->sta_assoc) {\n\t\t\tvif = wcn36xx_priv_to_vif(vif_priv);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn vif;\n}\n\nstatic int wcn36xx_suspend(struct ieee80211_hw *hw, struct cfg80211_wowlan *wow)\n{\n\tstruct wcn36xx *wcn = hw->priv;\n\tstruct ieee80211_vif *vif = NULL;\n\tint ret = 0;\n\n\twcn36xx_dbg(WCN36XX_DBG_MAC, \"mac suspend\\n\");\n\n\tmutex_lock(&wcn->conf_mutex);\n\n\tvif = wcn36xx_get_first_assoc_vif(wcn);\n\tif (vif) {\n\t\tret = wcn36xx_smd_arp_offload(wcn, vif, true);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tret = wcn36xx_smd_ipv6_ns_offload(wcn, vif, true);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tret = wcn36xx_smd_gtk_offload(wcn, vif, true);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tret = wcn36xx_smd_set_power_params(wcn, true);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tret = wcn36xx_smd_wlan_host_suspend_ind(wcn);\n\t}\n\n\t \n\tdisable_irq(wcn->tx_irq);\n\tdisable_irq(wcn->rx_irq);\n\nout:\n\tmutex_unlock(&wcn->conf_mutex);\n\treturn ret;\n}\n\nstatic int wcn36xx_resume(struct ieee80211_hw *hw)\n{\n\tstruct wcn36xx *wcn = hw->priv;\n\tstruct ieee80211_vif *vif = NULL;\n\n\twcn36xx_dbg(WCN36XX_DBG_MAC, \"mac resume\\n\");\n\n\tmutex_lock(&wcn->conf_mutex);\n\tvif = wcn36xx_get_first_assoc_vif(wcn);\n\tif (vif) {\n\t\twcn36xx_smd_host_resume(wcn);\n\t\twcn36xx_smd_set_power_params(wcn, false);\n\t\twcn36xx_smd_gtk_offload_get_info(wcn, vif);\n\t\twcn36xx_smd_gtk_offload(wcn, vif, false);\n\t\twcn36xx_smd_ipv6_ns_offload(wcn, vif, false);\n\t\twcn36xx_smd_arp_offload(wcn, vif, false);\n\t}\n\n\tenable_irq(wcn->tx_irq);\n\tenable_irq(wcn->rx_irq);\n\n\tmutex_unlock(&wcn->conf_mutex);\n\n\treturn 0;\n}\n\nstatic void wcn36xx_set_rekey_data(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   struct cfg80211_gtk_rekey_data *data)\n{\n\tstruct wcn36xx *wcn = hw->priv;\n\tstruct wcn36xx_vif *vif_priv = wcn36xx_vif_to_priv(vif);\n\n\tmutex_lock(&wcn->conf_mutex);\n\n\tmemcpy(vif_priv->rekey_data.kek, data->kek, NL80211_KEK_LEN);\n\tmemcpy(vif_priv->rekey_data.kck, data->kck, NL80211_KCK_LEN);\n\tvif_priv->rekey_data.replay_ctr =\n\t\tcpu_to_le64(be64_to_cpup((__be64 *)data->replay_ctr));\n\tvif_priv->rekey_data.valid = true;\n\n\tmutex_unlock(&wcn->conf_mutex);\n}\n\n#endif\n\nstatic int wcn36xx_ampdu_action(struct ieee80211_hw *hw,\n\t\t    struct ieee80211_vif *vif,\n\t\t    struct ieee80211_ampdu_params *params)\n{\n\tstruct wcn36xx *wcn = hw->priv;\n\tstruct wcn36xx_sta *sta_priv = wcn36xx_sta_to_priv(params->sta);\n\tstruct ieee80211_sta *sta = params->sta;\n\tenum ieee80211_ampdu_mlme_action action = params->action;\n\tu16 tid = params->tid;\n\tu16 *ssn = &params->ssn;\n\tint ret = 0;\n\tint session;\n\n\twcn36xx_dbg(WCN36XX_DBG_MAC, \"mac ampdu action action %d tid %d\\n\",\n\t\t    action, tid);\n\n\tmutex_lock(&wcn->conf_mutex);\n\n\tswitch (action) {\n\tcase IEEE80211_AMPDU_RX_START:\n\t\tsta_priv->tid = tid;\n\t\tsession = wcn36xx_smd_add_ba_session(wcn, sta, tid, ssn, 0,\n\t\t\t\t\t\t     get_sta_index(vif, sta_priv));\n\t\tif (session < 0) {\n\t\t\tret = session;\n\t\t\tgoto out;\n\t\t}\n\t\twcn36xx_smd_add_ba(wcn, session);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_RX_STOP:\n\t\twcn36xx_smd_del_ba(wcn, tid, 0, get_sta_index(vif, sta_priv));\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_START:\n\t\tspin_lock_bh(&sta_priv->ampdu_lock);\n\t\tsta_priv->ampdu_state[tid] = WCN36XX_AMPDU_START;\n\t\tspin_unlock_bh(&sta_priv->ampdu_lock);\n\n\t\t \n\t\twcn36xx_dbg(WCN36XX_DBG_MAC, \"mac ampdu ssn = %u\\n\", *ssn);\n\t\twcn36xx_smd_trigger_ba(wcn, get_sta_index(vif, sta_priv), tid, ssn);\n\t\twcn36xx_dbg(WCN36XX_DBG_MAC, \"mac ampdu fw-ssn = %u\\n\", *ssn);\n\n\t\t \n\t\tsession = wcn36xx_smd_add_ba_session(wcn, sta, tid, ssn, 1,\n\t\t\t\t\t\t     get_sta_index(vif, sta_priv));\n\t\tif (session < 0) {\n\t\t\tret = session;\n\t\t\tgoto out;\n\t\t}\n\t\tret = IEEE80211_AMPDU_TX_START_IMMEDIATE;\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_OPERATIONAL:\n\t\tspin_lock_bh(&sta_priv->ampdu_lock);\n\t\tsta_priv->ampdu_state[tid] = WCN36XX_AMPDU_OPERATIONAL;\n\t\tspin_unlock_bh(&sta_priv->ampdu_lock);\n\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH:\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH_CONT:\n\tcase IEEE80211_AMPDU_TX_STOP_CONT:\n\t\tspin_lock_bh(&sta_priv->ampdu_lock);\n\t\tsta_priv->ampdu_state[tid] = WCN36XX_AMPDU_NONE;\n\t\tspin_unlock_bh(&sta_priv->ampdu_lock);\n\n\t\twcn36xx_smd_del_ba(wcn, tid, 1, get_sta_index(vif, sta_priv));\n\t\tieee80211_stop_tx_ba_cb_irqsafe(vif, sta->addr, tid);\n\t\tbreak;\n\tdefault:\n\t\twcn36xx_err(\"Unknown AMPDU action\\n\");\n\t}\n\nout:\n\tmutex_unlock(&wcn->conf_mutex);\n\n\treturn ret;\n}\n\n#if IS_ENABLED(CONFIG_IPV6)\nstatic void wcn36xx_ipv6_addr_change(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t     struct inet6_dev *idev)\n{\n\tstruct wcn36xx_vif *vif_priv = wcn36xx_vif_to_priv(vif);\n\tstruct inet6_ifaddr *ifa;\n\tint idx = 0;\n\n\tmemset(vif_priv->tentative_addrs, 0, sizeof(vif_priv->tentative_addrs));\n\n\tread_lock_bh(&idev->lock);\n\tlist_for_each_entry(ifa, &idev->addr_list, if_list) {\n\t\tvif_priv->target_ipv6_addrs[idx] = ifa->addr;\n\t\tif (ifa->flags & IFA_F_TENTATIVE)\n\t\t\t__set_bit(idx, vif_priv->tentative_addrs);\n\t\tidx++;\n\t\tif (idx >= WCN36XX_HAL_IPV6_OFFLOAD_ADDR_MAX)\n\t\t\tbreak;\n\t\twcn36xx_dbg(WCN36XX_DBG_MAC, \"%pI6 %s\\n\", &ifa->addr,\n\t\t\t    (ifa->flags & IFA_F_TENTATIVE) ? \"tentative\" : NULL);\n\t}\n\tread_unlock_bh(&idev->lock);\n\n\tvif_priv->num_target_ipv6_addrs = idx;\n}\n#endif\n\nstatic void wcn36xx_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t  u32 queues, bool drop)\n{\n\tstruct wcn36xx *wcn = hw->priv;\n\n\tif (wcn36xx_dxe_tx_flush(wcn)) {\n\t\twcn36xx_err(\"Failed to flush hardware tx queues\\n\");\n\t}\n}\n\nstatic int wcn36xx_get_survey(struct ieee80211_hw *hw, int idx,\n\t\t\t      struct survey_info *survey)\n{\n\tstruct wcn36xx *wcn = hw->priv;\n\tstruct ieee80211_supported_band *sband;\n\tstruct wcn36xx_chan_survey *chan_survey;\n\tint band_idx;\n\tunsigned long flags;\n\n\tsband = wcn->hw->wiphy->bands[NL80211_BAND_2GHZ];\n\tband_idx = idx;\n\tif (band_idx >= sband->n_channels) {\n\t\tband_idx -= sband->n_channels;\n\t\tsband = wcn->hw->wiphy->bands[NL80211_BAND_5GHZ];\n\t}\n\n\tif (!sband || band_idx >= sband->n_channels)\n\t\treturn -ENOENT;\n\n\tspin_lock_irqsave(&wcn->survey_lock, flags);\n\n\tchan_survey = &wcn->chan_survey[idx];\n\tsurvey->channel = &sband->channels[band_idx];\n\tsurvey->noise = chan_survey->rssi - chan_survey->snr;\n\tsurvey->filled = 0;\n\n\tif (chan_survey->rssi > -100 && chan_survey->rssi < 0)\n\t\tsurvey->filled |= SURVEY_INFO_NOISE_DBM;\n\n\tif (survey->channel == wcn->channel)\n\t\tsurvey->filled |= SURVEY_INFO_IN_USE;\n\n\tspin_unlock_irqrestore(&wcn->survey_lock, flags);\n\n\twcn36xx_dbg(WCN36XX_DBG_MAC,\n\t\t    \"ch %d rssi %d snr %d noise %d filled %x freq %d\\n\",\n\t\t    HW_VALUE_CHANNEL(survey->channel->hw_value),\n\t\t    chan_survey->rssi, chan_survey->snr, survey->noise,\n\t\t    survey->filled, survey->channel->center_freq);\n\n\treturn 0;\n}\n\nstatic void wcn36xx_sta_statistics(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t\t   struct ieee80211_sta *sta, struct station_info *sinfo)\n{\n\tstruct wcn36xx *wcn;\n\tu8 sta_index;\n\tint status;\n\n\twcn = hw->priv;\n\tsta_index = get_sta_index(vif, wcn36xx_sta_to_priv(sta));\n\tstatus = wcn36xx_smd_get_stats(wcn, sta_index, HAL_GLOBAL_CLASS_A_STATS_INFO, sinfo);\n\n\tif (status)\n\t\twcn36xx_err(\"wcn36xx_smd_get_stats failed\\n\");\n}\n\nstatic const struct ieee80211_ops wcn36xx_ops = {\n\t.start\t\t\t= wcn36xx_start,\n\t.stop\t\t\t= wcn36xx_stop,\n\t.add_interface\t\t= wcn36xx_add_interface,\n\t.remove_interface\t= wcn36xx_remove_interface,\n#ifdef CONFIG_PM\n\t.suspend\t\t= wcn36xx_suspend,\n\t.resume\t\t\t= wcn36xx_resume,\n\t.set_rekey_data\t\t= wcn36xx_set_rekey_data,\n#endif\n\t.config\t\t\t= wcn36xx_config,\n\t.prepare_multicast\t= wcn36xx_prepare_multicast,\n\t.configure_filter       = wcn36xx_configure_filter,\n\t.tx\t\t\t= wcn36xx_tx,\n\t.wake_tx_queue\t\t= ieee80211_handle_wake_tx_queue,\n\t.set_key\t\t= wcn36xx_set_key,\n\t.hw_scan\t\t= wcn36xx_hw_scan,\n\t.cancel_hw_scan\t\t= wcn36xx_cancel_hw_scan,\n\t.sw_scan_start\t\t= wcn36xx_sw_scan_start,\n\t.sw_scan_complete\t= wcn36xx_sw_scan_complete,\n\t.bss_info_changed\t= wcn36xx_bss_info_changed,\n\t.set_rts_threshold\t= wcn36xx_set_rts_threshold,\n\t.sta_add\t\t= wcn36xx_sta_add,\n\t.sta_remove\t\t= wcn36xx_sta_remove,\n\t.sta_statistics\t\t= wcn36xx_sta_statistics,\n\t.ampdu_action\t\t= wcn36xx_ampdu_action,\n#if IS_ENABLED(CONFIG_IPV6)\n\t.ipv6_addr_change\t= wcn36xx_ipv6_addr_change,\n#endif\n\t.flush\t\t\t= wcn36xx_flush,\n\t.get_survey\t\t= wcn36xx_get_survey,\n\n\tCFG80211_TESTMODE_CMD(wcn36xx_tm_cmd)\n};\n\nstatic void\nwcn36xx_set_ieee80211_vht_caps(struct ieee80211_sta_vht_cap *vht_cap)\n{\n\tvht_cap->vht_supported = true;\n\n\tvht_cap->cap = (IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_3895 |\n\t\t\tIEEE80211_VHT_CAP_SHORT_GI_80 |\n\t\t\tIEEE80211_VHT_CAP_RXSTBC_1 |\n\t\t\tIEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE |\n\t\t\tIEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE |\n\t\t\t3 << IEEE80211_VHT_CAP_BEAMFORMEE_STS_SHIFT |\n\t\t\t7 << IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_SHIFT);\n\n\tvht_cap->vht_mcs.rx_mcs_map =\n\t\tcpu_to_le16(IEEE80211_VHT_MCS_SUPPORT_0_9 |\n\t\t\t    IEEE80211_VHT_MCS_NOT_SUPPORTED << 2 |\n\t\t\t    IEEE80211_VHT_MCS_NOT_SUPPORTED << 4 |\n\t\t\t    IEEE80211_VHT_MCS_NOT_SUPPORTED << 6 |\n\t\t\t    IEEE80211_VHT_MCS_NOT_SUPPORTED << 8 |\n\t\t\t    IEEE80211_VHT_MCS_NOT_SUPPORTED << 10 |\n\t\t\t    IEEE80211_VHT_MCS_NOT_SUPPORTED << 12 |\n\t\t\t    IEEE80211_VHT_MCS_NOT_SUPPORTED << 14);\n\n\tvht_cap->vht_mcs.rx_highest = cpu_to_le16(433);\n\tvht_cap->vht_mcs.tx_highest = vht_cap->vht_mcs.rx_highest;\n\n\tvht_cap->vht_mcs.tx_mcs_map = vht_cap->vht_mcs.rx_mcs_map;\n}\n\nstatic int wcn36xx_init_ieee80211(struct wcn36xx *wcn)\n{\n\tstatic const u32 cipher_suites[] = {\n\t\tWLAN_CIPHER_SUITE_WEP40,\n\t\tWLAN_CIPHER_SUITE_WEP104,\n\t\tWLAN_CIPHER_SUITE_TKIP,\n\t\tWLAN_CIPHER_SUITE_CCMP,\n\t};\n\n\tieee80211_hw_set(wcn->hw, TIMING_BEACON_ONLY);\n\tieee80211_hw_set(wcn->hw, AMPDU_AGGREGATION);\n\tieee80211_hw_set(wcn->hw, SUPPORTS_PS);\n\tieee80211_hw_set(wcn->hw, SIGNAL_DBM);\n\tieee80211_hw_set(wcn->hw, HAS_RATE_CONTROL);\n\tieee80211_hw_set(wcn->hw, SINGLE_SCAN_ON_ALL_BANDS);\n\tieee80211_hw_set(wcn->hw, REPORTS_TX_ACK_STATUS);\n\n\twcn->hw->wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |\n\t\tBIT(NL80211_IFTYPE_AP) |\n\t\tBIT(NL80211_IFTYPE_ADHOC) |\n\t\tBIT(NL80211_IFTYPE_MESH_POINT);\n\n\twcn->hw->wiphy->bands[NL80211_BAND_2GHZ] = &wcn_band_2ghz;\n\tif (wcn->rf_id != RF_IRIS_WCN3620)\n\t\twcn->hw->wiphy->bands[NL80211_BAND_5GHZ] = &wcn_band_5ghz;\n\n\tif (wcn->rf_id == RF_IRIS_WCN3680)\n\t\twcn36xx_set_ieee80211_vht_caps(&wcn_band_5ghz.vht_cap);\n\n\twcn->hw->wiphy->max_scan_ssids = WCN36XX_MAX_SCAN_SSIDS;\n\twcn->hw->wiphy->max_scan_ie_len = WCN36XX_MAX_SCAN_IE_LEN;\n\n\twcn->hw->wiphy->cipher_suites = cipher_suites;\n\twcn->hw->wiphy->n_cipher_suites = ARRAY_SIZE(cipher_suites);\n\n#ifdef CONFIG_PM\n\twcn->hw->wiphy->wowlan = &wowlan_support;\n#endif\n\n\twcn->hw->max_listen_interval = 200;\n\n\twcn->hw->queues = 4;\n\n\tSET_IEEE80211_DEV(wcn->hw, wcn->dev);\n\n\twcn->hw->sta_data_size = sizeof(struct wcn36xx_sta);\n\twcn->hw->vif_data_size = sizeof(struct wcn36xx_vif);\n\n\twiphy_ext_feature_set(wcn->hw->wiphy,\n\t\t\t      NL80211_EXT_FEATURE_CQM_RSSI_LIST);\n\n\treturn 0;\n}\n\nstatic int wcn36xx_platform_get_resources(struct wcn36xx *wcn,\n\t\t\t\t\t  struct platform_device *pdev)\n{\n\tstruct device_node *mmio_node;\n\tstruct device_node *iris_node;\n\tint index;\n\tint ret;\n\n\t \n\tret = platform_get_irq_byname(pdev, \"tx\");\n\tif (ret < 0)\n\t\treturn ret;\n\twcn->tx_irq = ret;\n\n\t \n\tret = platform_get_irq_byname(pdev, \"rx\");\n\tif (ret < 0)\n\t\treturn ret;\n\twcn->rx_irq = ret;\n\n\t \n\twcn->tx_enable_state = qcom_smem_state_get(&pdev->dev,\n\t\t\t\"tx-enable\", &wcn->tx_enable_state_bit);\n\tif (IS_ERR(wcn->tx_enable_state)) {\n\t\twcn36xx_err(\"failed to get tx-enable state\\n\");\n\t\treturn PTR_ERR(wcn->tx_enable_state);\n\t}\n\n\t \n\twcn->tx_rings_empty_state = qcom_smem_state_get(&pdev->dev,\n\t\t\t\"tx-rings-empty\", &wcn->tx_rings_empty_state_bit);\n\tif (IS_ERR(wcn->tx_rings_empty_state)) {\n\t\twcn36xx_err(\"failed to get tx-rings-empty state\\n\");\n\t\treturn PTR_ERR(wcn->tx_rings_empty_state);\n\t}\n\n\tmmio_node = of_parse_phandle(pdev->dev.parent->of_node, \"qcom,mmio\", 0);\n\tif (!mmio_node) {\n\t\twcn36xx_err(\"failed to acquire qcom,mmio reference\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\twcn->is_pronto = !!of_device_is_compatible(mmio_node, \"qcom,pronto\");\n\twcn->is_pronto_v3 = !!of_device_is_compatible(mmio_node, \"qcom,pronto-v3-pil\");\n\n\t \n\tindex = of_property_match_string(mmio_node, \"reg-names\", \"ccu\");\n\twcn->ccu_base = of_iomap(mmio_node, index);\n\tif (!wcn->ccu_base) {\n\t\twcn36xx_err(\"failed to map ccu memory\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto put_mmio_node;\n\t}\n\n\t \n\tindex = of_property_match_string(mmio_node, \"reg-names\", \"dxe\");\n\twcn->dxe_base = of_iomap(mmio_node, index);\n\tif (!wcn->dxe_base) {\n\t\twcn36xx_err(\"failed to map dxe memory\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto unmap_ccu;\n\t}\n\n\t \n\tiris_node = of_get_child_by_name(mmio_node, \"iris\");\n\tif (iris_node) {\n\t\tif (of_device_is_compatible(iris_node, \"qcom,wcn3620\"))\n\t\t\twcn->rf_id = RF_IRIS_WCN3620;\n\t\tif (of_device_is_compatible(iris_node, \"qcom,wcn3660\") ||\n\t\t    of_device_is_compatible(iris_node, \"qcom,wcn3660b\"))\n\t\t\twcn->rf_id = RF_IRIS_WCN3660;\n\t\tif (of_device_is_compatible(iris_node, \"qcom,wcn3680\"))\n\t\t\twcn->rf_id = RF_IRIS_WCN3680;\n\t\tof_node_put(iris_node);\n\t}\n\n\tof_node_put(mmio_node);\n\treturn 0;\n\nunmap_ccu:\n\tiounmap(wcn->ccu_base);\nput_mmio_node:\n\tof_node_put(mmio_node);\n\treturn ret;\n}\n\nstatic int wcn36xx_probe(struct platform_device *pdev)\n{\n\tstruct ieee80211_hw *hw;\n\tstruct wcn36xx *wcn;\n\tvoid *wcnss;\n\tint ret;\n\tconst u8 *addr;\n\tint n_channels;\n\n\twcn36xx_dbg(WCN36XX_DBG_MAC, \"platform probe\\n\");\n\n\twcnss = dev_get_drvdata(pdev->dev.parent);\n\n\thw = ieee80211_alloc_hw(sizeof(struct wcn36xx), &wcn36xx_ops);\n\tif (!hw) {\n\t\twcn36xx_err(\"failed to alloc hw\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\tplatform_set_drvdata(pdev, hw);\n\twcn = hw->priv;\n\twcn->hw = hw;\n\twcn->dev = &pdev->dev;\n\twcn->first_boot = true;\n\tmutex_init(&wcn->conf_mutex);\n\tmutex_init(&wcn->hal_mutex);\n\tmutex_init(&wcn->scan_lock);\n\t__skb_queue_head_init(&wcn->amsdu);\n\n\twcn->hal_buf = devm_kmalloc(wcn->dev, WCN36XX_HAL_BUF_SIZE, GFP_KERNEL);\n\tif (!wcn->hal_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out_wq;\n\t}\n\n\tn_channels = wcn_band_2ghz.n_channels + wcn_band_5ghz.n_channels;\n\twcn->chan_survey = devm_kmalloc(wcn->dev, n_channels, GFP_KERNEL);\n\tif (!wcn->chan_survey) {\n\t\tret = -ENOMEM;\n\t\tgoto out_wq;\n\t}\n\n\tret = dma_set_mask_and_coherent(wcn->dev, DMA_BIT_MASK(32));\n\tif (ret < 0) {\n\t\twcn36xx_err(\"failed to set DMA mask: %d\\n\", ret);\n\t\tgoto out_wq;\n\t}\n\n\twcn->nv_file = WLAN_NV_FILE;\n\tret = of_property_read_string(wcn->dev->parent->of_node, \"firmware-name\", &wcn->nv_file);\n\tif (ret < 0 && ret != -EINVAL) {\n\t\twcn36xx_err(\"failed to read \\\"firmware-name\\\" property: %d\\n\", ret);\n\t\tgoto out_wq;\n\t}\n\n\twcn->smd_channel = qcom_wcnss_open_channel(wcnss, \"WLAN_CTRL\", wcn36xx_smd_rsp_process, hw);\n\tif (IS_ERR(wcn->smd_channel)) {\n\t\twcn36xx_err(\"failed to open WLAN_CTRL channel\\n\");\n\t\tret = PTR_ERR(wcn->smd_channel);\n\t\tgoto out_wq;\n\t}\n\n\taddr = of_get_property(pdev->dev.of_node, \"local-mac-address\", &ret);\n\tif (addr && ret != ETH_ALEN) {\n\t\twcn36xx_err(\"invalid local-mac-address\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_destroy_ept;\n\t} else if (addr) {\n\t\twcn36xx_info(\"mac address: %pM\\n\", addr);\n\t\tSET_IEEE80211_PERM_ADDR(wcn->hw, addr);\n\t}\n\n\tret = wcn36xx_platform_get_resources(wcn, pdev);\n\tif (ret)\n\t\tgoto out_destroy_ept;\n\n\twcn36xx_init_ieee80211(wcn);\n\tret = ieee80211_register_hw(wcn->hw);\n\tif (ret)\n\t\tgoto out_unmap;\n\n\treturn 0;\n\nout_unmap:\n\tiounmap(wcn->ccu_base);\n\tiounmap(wcn->dxe_base);\nout_destroy_ept:\n\trpmsg_destroy_ept(wcn->smd_channel);\nout_wq:\n\tieee80211_free_hw(hw);\nout_err:\n\treturn ret;\n}\n\nstatic int wcn36xx_remove(struct platform_device *pdev)\n{\n\tstruct ieee80211_hw *hw = platform_get_drvdata(pdev);\n\tstruct wcn36xx *wcn = hw->priv;\n\twcn36xx_dbg(WCN36XX_DBG_MAC, \"platform remove\\n\");\n\n\trelease_firmware(wcn->nv);\n\n\tieee80211_unregister_hw(hw);\n\n\tqcom_smem_state_put(wcn->tx_enable_state);\n\tqcom_smem_state_put(wcn->tx_rings_empty_state);\n\n\trpmsg_destroy_ept(wcn->smd_channel);\n\n\tiounmap(wcn->dxe_base);\n\tiounmap(wcn->ccu_base);\n\n\t__skb_queue_purge(&wcn->amsdu);\n\n\tmutex_destroy(&wcn->hal_mutex);\n\tieee80211_free_hw(hw);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id wcn36xx_of_match[] = {\n\t{ .compatible = \"qcom,wcnss-wlan\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, wcn36xx_of_match);\n\nstatic struct platform_driver wcn36xx_driver = {\n\t.probe      = wcn36xx_probe,\n\t.remove     = wcn36xx_remove,\n\t.driver         = {\n\t\t.name   = \"wcn36xx\",\n\t\t.of_match_table = wcn36xx_of_match,\n\t},\n};\n\nmodule_platform_driver(wcn36xx_driver);\n\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_AUTHOR(\"Eugene Krasnikov k.eugene.e@gmail.com\");\nMODULE_FIRMWARE(WLAN_NV_FILE);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}