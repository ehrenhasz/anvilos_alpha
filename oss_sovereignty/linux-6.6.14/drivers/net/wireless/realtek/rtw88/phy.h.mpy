{
  "module_name": "phy.h",
  "hash_id": "283744742af119140fb4ae3578257c4d967bfb9a4161767f1f7d17315165161f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtw88/phy.h",
  "human_readable_source": " \n \n\n#ifndef __RTW_PHY_H_\n#define __RTW_PHY_H_\n\n#include \"debug.h\"\n\nextern u8 rtw_cck_rates[];\nextern u8 rtw_ofdm_rates[];\nextern u8 rtw_ht_1s_rates[];\nextern u8 rtw_ht_2s_rates[];\nextern u8 rtw_vht_1s_rates[];\nextern u8 rtw_vht_2s_rates[];\nextern u8 *rtw_rate_section[];\nextern u8 rtw_rate_size[];\n\nvoid rtw_phy_init(struct rtw_dev *rtwdev);\nvoid rtw_phy_dynamic_mechanism(struct rtw_dev *rtwdev);\nu8 rtw_phy_rf_power_2_rssi(s8 *rf_power, u8 path_num);\nu32 rtw_phy_read_rf(struct rtw_dev *rtwdev, enum rtw_rf_path rf_path,\n\t\t    u32 addr, u32 mask);\nu32 rtw_phy_read_rf_sipi(struct rtw_dev *rtwdev, enum rtw_rf_path rf_path,\n\t\t\t u32 addr, u32 mask);\nbool rtw_phy_write_rf_reg_sipi(struct rtw_dev *rtwdev, enum rtw_rf_path rf_path,\n\t\t\t       u32 addr, u32 mask, u32 data);\nbool rtw_phy_write_rf_reg(struct rtw_dev *rtwdev, enum rtw_rf_path rf_path,\n\t\t\t  u32 addr, u32 mask, u32 data);\nbool rtw_phy_write_rf_reg_mix(struct rtw_dev *rtwdev, enum rtw_rf_path rf_path,\n\t\t\t      u32 addr, u32 mask, u32 data);\nvoid rtw_phy_setup_phy_cond(struct rtw_dev *rtwdev, u32 pkg);\nvoid rtw_parse_tbl_phy_cond(struct rtw_dev *rtwdev, const struct rtw_table *tbl);\nvoid rtw_parse_tbl_bb_pg(struct rtw_dev *rtwdev, const struct rtw_table *tbl);\nvoid rtw_parse_tbl_txpwr_lmt(struct rtw_dev *rtwdev, const struct rtw_table *tbl);\nvoid rtw_phy_cfg_mac(struct rtw_dev *rtwdev, const struct rtw_table *tbl,\n\t\t     u32 addr, u32 data);\nvoid rtw_phy_cfg_agc(struct rtw_dev *rtwdev, const struct rtw_table *tbl,\n\t\t     u32 addr, u32 data);\nvoid rtw_phy_cfg_bb(struct rtw_dev *rtwdev, const struct rtw_table *tbl,\n\t\t    u32 addr, u32 data);\nvoid rtw_phy_cfg_rf(struct rtw_dev *rtwdev, const struct rtw_table *tbl,\n\t\t    u32 addr, u32 data);\nvoid rtw_phy_init_tx_power(struct rtw_dev *rtwdev);\nvoid rtw_phy_load_tables(struct rtw_dev *rtwdev);\nu8 rtw_phy_get_tx_power_index(struct rtw_dev *rtwdev, u8 rf_path, u8 rate,\n\t\t\t      enum rtw_bandwidth bw, u8 channel, u8 regd);\nvoid rtw_phy_set_tx_power_level(struct rtw_dev *rtwdev, u8 channel);\nvoid rtw_phy_tx_power_by_rate_config(struct rtw_hal *hal);\nvoid rtw_phy_tx_power_limit_config(struct rtw_hal *hal);\nvoid rtw_phy_pwrtrack_avg(struct rtw_dev *rtwdev, u8 thermal, u8 path);\nbool rtw_phy_pwrtrack_thermal_changed(struct rtw_dev *rtwdev, u8 thermal,\n\t\t\t\t      u8 path);\nu8 rtw_phy_pwrtrack_get_delta(struct rtw_dev *rtwdev, u8 path);\ns8 rtw_phy_pwrtrack_get_pwridx(struct rtw_dev *rtwdev,\n\t\t\t       struct rtw_swing_table *swing_table,\n\t\t\t       u8 tbl_path, u8 therm_path, u8 delta);\nbool rtw_phy_pwrtrack_need_lck(struct rtw_dev *rtwdev);\nbool rtw_phy_pwrtrack_need_iqk(struct rtw_dev *rtwdev);\nvoid rtw_phy_config_swing_table(struct rtw_dev *rtwdev,\n\t\t\t\tstruct rtw_swing_table *swing_table);\nvoid rtw_phy_set_edcca_th(struct rtw_dev *rtwdev, u8 l2h, u8 h2l);\nvoid rtw_phy_adaptivity_set_mode(struct rtw_dev *rtwdev);\nvoid rtw_phy_parsing_cfo(struct rtw_dev *rtwdev,\n\t\t\t struct rtw_rx_pkt_stat *pkt_stat);\nvoid rtw_phy_tx_path_diversity(struct rtw_dev *rtwdev);\n\nstruct rtw_txpwr_lmt_cfg_pair {\n\tu8 regd;\n\tu8 band;\n\tu8 bw;\n\tu8 rs;\n\tu8 ch;\n\ts8 txpwr_lmt;\n};\n\nstruct rtw_phy_pg_cfg_pair {\n\tu32 band;\n\tu32 rf_path;\n\tu32 tx_num;\n\tu32 addr;\n\tu32 bitmask;\n\tu32 data;\n};\n\n#define RTW_DECL_TABLE_PHY_COND_CORE(name, cfg, path)\t\\\nconst struct rtw_table name ## _tbl = {\t\t\t\\\n\t.data = name,\t\t\t\t\t\\\n\t.size = ARRAY_SIZE(name),\t\t\t\\\n\t.parse = rtw_parse_tbl_phy_cond,\t\t\\\n\t.do_cfg = cfg,\t\t\t\t\t\\\n\t.rf_path = path,\t\t\t\t\\\n}\n\n#define RTW_DECL_TABLE_PHY_COND(name, cfg)\t\t\\\n\tRTW_DECL_TABLE_PHY_COND_CORE(name, cfg, 0)\n\n#define RTW_DECL_TABLE_RF_RADIO(name, path)\t\t\\\n\tRTW_DECL_TABLE_PHY_COND_CORE(name, rtw_phy_cfg_rf, RF_PATH_ ## path)\n\n#define RTW_DECL_TABLE_BB_PG(name)\t\t\t\\\nconst struct rtw_table name ## _tbl = {\t\t\t\\\n\t.data = name,\t\t\t\t\t\\\n\t.size = ARRAY_SIZE(name),\t\t\t\\\n\t.parse = rtw_parse_tbl_bb_pg,\t\t\t\\\n}\n\n#define RTW_DECL_TABLE_TXPWR_LMT(name)\t\t\t\\\nconst struct rtw_table name ## _tbl = {\t\t\t\\\n\t.data = name,\t\t\t\t\t\\\n\t.size = ARRAY_SIZE(name),\t\t\t\\\n\t.parse = rtw_parse_tbl_txpwr_lmt,\t\t\\\n}\n\nstatic inline const struct rtw_rfe_def *rtw_get_rfe_def(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\tconst struct rtw_rfe_def *rfe_def = NULL;\n\n\tif (chip->rfe_defs_size == 0)\n\t\treturn NULL;\n\n\tif (efuse->rfe_option < chip->rfe_defs_size)\n\t\trfe_def = &chip->rfe_defs[efuse->rfe_option];\n\n\trtw_dbg(rtwdev, RTW_DBG_PHY, \"use rfe_def[%d]\\n\", efuse->rfe_option);\n\treturn rfe_def;\n}\n\nstatic inline int rtw_check_supported_rfe(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_rfe_def *rfe_def = rtw_get_rfe_def(rtwdev);\n\n\tif (!rfe_def || !rfe_def->phy_pg_tbl || !rfe_def->txpwr_lmt_tbl) {\n\t\trtw_err(rtwdev, \"rfe %d isn't supported\\n\",\n\t\t\trtwdev->efuse.rfe_option);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nvoid rtw_phy_dig_write(struct rtw_dev *rtwdev, u8 igi);\n\nstruct rtw_power_params {\n\tu8 pwr_base;\n\ts8 pwr_offset;\n\ts8 pwr_limit;\n\ts8 pwr_remnant;\n\ts8 pwr_sar;\n};\n\nvoid\nrtw_get_tx_power_params(struct rtw_dev *rtwdev, u8 path,\n\t\t\tu8 rate, u8 bw, u8 ch, u8 regd,\n\t\t\tstruct rtw_power_params *pwr_param);\n\nenum rtw_phy_cck_pd_lv {\n\tCCK_PD_LV0,\n\tCCK_PD_LV1,\n\tCCK_PD_LV2,\n\tCCK_PD_LV3,\n\tCCK_PD_LV4,\n\tCCK_PD_LV_MAX,\n};\n\n#define\tMASKBYTE0\t\t0xff\n#define\tMASKBYTE1\t\t0xff00\n#define\tMASKBYTE2\t\t0xff0000\n#define\tMASKBYTE3\t\t0xff000000\n#define\tMASKHWORD\t\t0xffff0000\n#define\tMASKLWORD\t\t0x0000ffff\n#define\tMASKDWORD\t\t0xffffffff\n#define RFREG_MASK\t\t0xfffff\n\n#define\tMASK7BITS\t\t0x7f\n#define\tMASK12BITS\t\t0xfff\n#define\tMASKH4BITS\t\t0xf0000000\n#define\tMASK20BITS\t\t0xfffff\n#define\tMASK24BITS\t\t0xffffff\n\n#define MASKH3BYTES\t\t0xffffff00\n#define MASKL3BYTES\t\t0x00ffffff\n#define MASKBYTE2HIGHNIBBLE\t0x00f00000\n#define MASKBYTE3LOWNIBBLE\t0x0f000000\n#define\tMASKL3BYTES\t\t0x00ffffff\n\n#define CCK_FA_AVG_RESET 0xffffffff\n\n#define LSSI_READ_ADDR_MASK\t0x7f800000\n#define LSSI_READ_EDGE_MASK\t0x80000000\n#define LSSI_READ_DATA_MASK\t0xfffff\n\n#define RRSR_RATE_ORDER_MAX\t0xfffff\n#define RRSR_RATE_ORDER_CCK_LEN\t4\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}