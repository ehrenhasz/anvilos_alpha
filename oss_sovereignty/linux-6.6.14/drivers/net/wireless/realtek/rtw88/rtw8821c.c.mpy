{
  "module_name": "rtw8821c.c",
  "hash_id": "f896caed440c075f397ae3096e336a057b4adb170e79763f812fe5e7783ce39a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtw88/rtw8821c.c",
  "human_readable_source": "\n \n\n#include \"main.h\"\n#include \"coex.h\"\n#include \"fw.h\"\n#include \"tx.h\"\n#include \"rx.h\"\n#include \"phy.h\"\n#include \"rtw8821c.h\"\n#include \"rtw8821c_table.h\"\n#include \"mac.h\"\n#include \"reg.h\"\n#include \"debug.h\"\n#include \"bf.h\"\n#include \"regd.h\"\n\nstatic const s8 lna_gain_table_0[8] = {22, 8, -6, -22, -31, -40, -46, -52};\nstatic const s8 lna_gain_table_1[16] = {10, 6, 2, -2, -6, -10, -14, -17,\n\t\t\t\t\t-20, -24, -28, -31, -34, -37, -40, -44};\n\nstatic void rtw8821ce_efuse_parsing(struct rtw_efuse *efuse,\n\t\t\t\t    struct rtw8821c_efuse *map)\n{\n\tether_addr_copy(efuse->addr, map->e.mac_addr);\n}\n\nstatic void rtw8821cu_efuse_parsing(struct rtw_efuse *efuse,\n\t\t\t\t    struct rtw8821c_efuse *map)\n{\n\tether_addr_copy(efuse->addr, map->u.mac_addr);\n}\n\nstatic void rtw8821cs_efuse_parsing(struct rtw_efuse *efuse,\n\t\t\t\t    struct rtw8821c_efuse *map)\n{\n\tether_addr_copy(efuse->addr, map->s.mac_addr);\n}\n\nenum rtw8821ce_rf_set {\n\tSWITCH_TO_BTG,\n\tSWITCH_TO_WLG,\n\tSWITCH_TO_WLA,\n\tSWITCH_TO_BT,\n};\n\nstatic int rtw8821c_read_efuse(struct rtw_dev *rtwdev, u8 *log_map)\n{\n\tstruct rtw_hal *hal = &rtwdev->hal;\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\tstruct rtw8821c_efuse *map;\n\tint i;\n\n\tmap = (struct rtw8821c_efuse *)log_map;\n\n\tefuse->rfe_option = map->rfe_option & 0x1f;\n\tefuse->rf_board_option = map->rf_board_option;\n\tefuse->crystal_cap = map->xtal_k;\n\tefuse->pa_type_2g = map->pa_type;\n\tefuse->pa_type_5g = map->pa_type;\n\tefuse->lna_type_2g = map->lna_type_2g[0];\n\tefuse->lna_type_5g = map->lna_type_5g[0];\n\tefuse->channel_plan = map->channel_plan;\n\tefuse->country_code[0] = map->country_code[0];\n\tefuse->country_code[1] = map->country_code[1];\n\tefuse->bt_setting = map->rf_bt_setting;\n\tefuse->regd = map->rf_board_option & 0x7;\n\tefuse->thermal_meter[0] = map->thermal_meter;\n\tefuse->thermal_meter_k = map->thermal_meter;\n\tefuse->tx_bb_swing_setting_2g = map->tx_bb_swing_setting_2g;\n\tefuse->tx_bb_swing_setting_5g = map->tx_bb_swing_setting_5g;\n\n\thal->pkg_type = map->rfe_option & BIT(5) ? 1 : 0;\n\n\tswitch (efuse->rfe_option) {\n\tcase 0x2:\n\tcase 0x4:\n\tcase 0x7:\n\tcase 0xa:\n\tcase 0xc:\n\tcase 0xf:\n\t\thal->rfe_btg = true;\n\t\tbreak;\n\t}\n\n\tfor (i = 0; i < 4; i++)\n\t\tefuse->txpwr_idx_table[i] = map->txpwr_idx_table[i];\n\n\tif (rtwdev->efuse.rfe_option == 2 || rtwdev->efuse.rfe_option == 4)\n\t\tefuse->txpwr_idx_table[0].pwr_idx_2g = map->txpwr_idx_table[1].pwr_idx_2g;\n\n\tswitch (rtw_hci_type(rtwdev)) {\n\tcase RTW_HCI_TYPE_PCIE:\n\t\trtw8821ce_efuse_parsing(efuse, map);\n\t\tbreak;\n\tcase RTW_HCI_TYPE_USB:\n\t\trtw8821cu_efuse_parsing(efuse, map);\n\t\tbreak;\n\tcase RTW_HCI_TYPE_SDIO:\n\t\trtw8821cs_efuse_parsing(efuse, map);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic const u32 rtw8821c_txscale_tbl[] = {\n\t0x081, 0x088, 0x090, 0x099, 0x0a2, 0x0ac, 0x0b6, 0x0c0, 0x0cc, 0x0d8,\n\t0x0e5, 0x0f2, 0x101, 0x110, 0x120, 0x131, 0x143, 0x156, 0x16a, 0x180,\n\t0x197, 0x1af, 0x1c8, 0x1e3, 0x200, 0x21e, 0x23e, 0x261, 0x285, 0x2ab,\n\t0x2d3, 0x2fe, 0x32b, 0x35c, 0x38e, 0x3c4, 0x3fe\n};\n\nstatic u8 rtw8821c_get_swing_index(struct rtw_dev *rtwdev)\n{\n\tu8 i = 0;\n\tu32 swing, table_value;\n\n\tswing = rtw_read32_mask(rtwdev, REG_TXSCALE_A, 0xffe00000);\n\tfor (i = 0; i < ARRAY_SIZE(rtw8821c_txscale_tbl); i++) {\n\t\ttable_value = rtw8821c_txscale_tbl[i];\n\t\tif (swing == table_value)\n\t\t\tbreak;\n\t}\n\n\treturn i;\n}\n\nstatic void rtw8821c_pwrtrack_init(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tu8 swing_idx = rtw8821c_get_swing_index(rtwdev);\n\n\tif (swing_idx >= ARRAY_SIZE(rtw8821c_txscale_tbl))\n\t\tdm_info->default_ofdm_index = 24;\n\telse\n\t\tdm_info->default_ofdm_index = swing_idx;\n\n\tewma_thermal_init(&dm_info->avg_thermal[RF_PATH_A]);\n\tdm_info->delta_power_index[RF_PATH_A] = 0;\n\tdm_info->delta_power_index_last[RF_PATH_A] = 0;\n\tdm_info->pwr_trk_triggered = false;\n\tdm_info->pwr_trk_init_trigger = true;\n\tdm_info->thermal_meter_k = rtwdev->efuse.thermal_meter_k;\n}\n\nstatic void rtw8821c_phy_bf_init(struct rtw_dev *rtwdev)\n{\n\trtw_bf_phy_init(rtwdev);\n\t \n\trtw_write32(rtwdev, 0x1C94, 0xAFFFAFFF);\n}\n\nstatic void rtw8821c_phy_set_param(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_hal *hal = &rtwdev->hal;\n\tu8 crystal_cap, val;\n\n\t \n\tval = rtw_read8(rtwdev, REG_SYS_FUNC_EN);\n\tval |= BIT_FEN_PCIEA;\n\trtw_write8(rtwdev, REG_SYS_FUNC_EN, val);\n\n\t \n\tval |= BIT_FEN_BB_RSTB | BIT_FEN_BB_GLB_RST;\n\trtw_write8(rtwdev, REG_SYS_FUNC_EN, val);\n\tval &= ~(BIT_FEN_BB_RSTB | BIT_FEN_BB_GLB_RST);\n\trtw_write8(rtwdev, REG_SYS_FUNC_EN, val);\n\tval |= BIT_FEN_BB_RSTB | BIT_FEN_BB_GLB_RST;\n\trtw_write8(rtwdev, REG_SYS_FUNC_EN, val);\n\n\trtw_write8(rtwdev, REG_RF_CTRL,\n\t\t   BIT_RF_EN | BIT_RF_RSTB | BIT_RF_SDM_RSTB);\n\tusleep_range(10, 11);\n\trtw_write8(rtwdev, REG_WLRF1 + 3,\n\t\t   BIT_RF_EN | BIT_RF_RSTB | BIT_RF_SDM_RSTB);\n\tusleep_range(10, 11);\n\n\t \n\trtw_write32_clr(rtwdev, REG_RXPSEL, BIT_RX_PSEL_RST);\n\n\trtw_phy_load_tables(rtwdev);\n\n\tcrystal_cap = rtwdev->efuse.crystal_cap & 0x3F;\n\trtw_write32_mask(rtwdev, REG_AFE_XTAL_CTRL, 0x7e000000, crystal_cap);\n\trtw_write32_mask(rtwdev, REG_AFE_PLL_CTRL, 0x7e, crystal_cap);\n\trtw_write32_mask(rtwdev, REG_CCK0_FAREPORT, BIT(18) | BIT(22), 0);\n\n\t \n\trtw_write32_set(rtwdev, REG_RXPSEL, BIT_RX_PSEL_RST);\n\thal->ch_param[0] = rtw_read32_mask(rtwdev, REG_TXSF2, MASKDWORD);\n\thal->ch_param[1] = rtw_read32_mask(rtwdev, REG_TXSF6, MASKDWORD);\n\thal->ch_param[2] = rtw_read32_mask(rtwdev, REG_TXFILTER, MASKDWORD);\n\n\trtw_phy_init(rtwdev);\n\trtwdev->dm_info.cck_pd_default = rtw_read8(rtwdev, REG_CSRATIO) & 0x1f;\n\n\trtw8821c_pwrtrack_init(rtwdev);\n\n\trtw8821c_phy_bf_init(rtwdev);\n}\n\nstatic int rtw8821c_mac_init(struct rtw_dev *rtwdev)\n{\n\tu32 value32;\n\tu16 pre_txcnt;\n\n\t \n\trtw_write8(rtwdev, REG_AMPDU_MAX_TIME_V1, WLAN_AMPDU_MAX_TIME);\n\trtw_write8_set(rtwdev, REG_TX_HANG_CTRL, BIT_EN_EOF_V1);\n\tpre_txcnt = WLAN_PRE_TXCNT_TIME_TH | BIT_EN_PRECNT;\n\trtw_write8(rtwdev, REG_PRECNT_CTRL, (u8)(pre_txcnt & 0xFF));\n\trtw_write8(rtwdev, REG_PRECNT_CTRL + 1, (u8)(pre_txcnt >> 8));\n\tvalue32 = WLAN_RTS_LEN_TH | (WLAN_RTS_TX_TIME_TH << 8) |\n\t\t  (WLAN_MAX_AGG_PKT_LIMIT << 16) |\n\t\t  (WLAN_RTS_MAX_AGG_PKT_LIMIT << 24);\n\trtw_write32(rtwdev, REG_PROT_MODE_CTRL, value32);\n\trtw_write16(rtwdev, REG_BAR_MODE_CTRL + 2,\n\t\t    WLAN_BAR_RETRY_LIMIT | WLAN_RA_TRY_RATE_AGG_LIMIT << 8);\n\trtw_write8(rtwdev, REG_FAST_EDCA_VOVI_SETTING, FAST_EDCA_VO_TH);\n\trtw_write8(rtwdev, REG_FAST_EDCA_VOVI_SETTING + 2, FAST_EDCA_VI_TH);\n\trtw_write8(rtwdev, REG_FAST_EDCA_BEBK_SETTING, FAST_EDCA_BE_TH);\n\trtw_write8(rtwdev, REG_FAST_EDCA_BEBK_SETTING + 2, FAST_EDCA_BK_TH);\n\trtw_write8_set(rtwdev, REG_INIRTS_RATE_SEL, BIT(5));\n\n\t \n\trtw_write8_clr(rtwdev, REG_TIMER0_SRC_SEL, BIT_TSFT_SEL_TIMER0);\n\trtw_write16(rtwdev, REG_TXPAUSE, 0);\n\trtw_write8(rtwdev, REG_SLOT, WLAN_SLOT_TIME);\n\trtw_write8(rtwdev, REG_PIFS, WLAN_PIFS_TIME);\n\trtw_write32(rtwdev, REG_SIFS, WLAN_SIFS_CFG);\n\trtw_write16(rtwdev, REG_EDCA_VO_PARAM + 2, WLAN_VO_TXOP_LIMIT);\n\trtw_write16(rtwdev, REG_EDCA_VI_PARAM + 2, WLAN_VI_TXOP_LIMIT);\n\trtw_write32(rtwdev, REG_RD_NAV_NXT, WLAN_NAV_CFG);\n\trtw_write16(rtwdev, REG_RXTSF_OFFSET_CCK, WLAN_RX_TSF_CFG);\n\n\t \n\trtw_write8_set(rtwdev, REG_BCN_CTRL, BIT_EN_BCN_FUNCTION);\n\n\t \n\trtw_write32(rtwdev, REG_TBTT_PROHIBIT, WLAN_TBTT_TIME);\n\trtw_write8(rtwdev, REG_DRVERLYINT, WLAN_DRV_EARLY_INT);\n\trtw_write8(rtwdev, REG_BCNDMATIM, WLAN_BCN_DMA_TIME);\n\trtw_write8_clr(rtwdev, REG_TX_PTCL_CTRL + 1, BIT_SIFS_BK_EN >> 8);\n\n\t \n\trtw_write32(rtwdev, REG_RXFLTMAP0, WLAN_RX_FILTER0);\n\trtw_write16(rtwdev, REG_RXFLTMAP2, WLAN_RX_FILTER2);\n\trtw_write32(rtwdev, REG_RCR, WLAN_RCR_CFG);\n\trtw_write8(rtwdev, REG_RX_PKT_LIMIT, WLAN_RXPKT_MAX_SZ_512);\n\trtw_write8(rtwdev, REG_TCR + 2, WLAN_TX_FUNC_CFG2);\n\trtw_write8(rtwdev, REG_TCR + 1, WLAN_TX_FUNC_CFG1);\n\trtw_write8(rtwdev, REG_ACKTO_CCK, 0x40);\n\trtw_write8_set(rtwdev, REG_WMAC_TRXPTCL_CTL_H, BIT(1));\n\trtw_write8_set(rtwdev, REG_SND_PTCL_CTRL,\n\t\t       BIT_DIS_CHK_VHTSIGB_CRC);\n\trtw_write32(rtwdev, REG_WMAC_OPTION_FUNCTION + 8, WLAN_MAC_OPT_FUNC2);\n\trtw_write8(rtwdev, REG_WMAC_OPTION_FUNCTION + 4, WLAN_MAC_OPT_NORM_FUNC1);\n\n\treturn 0;\n}\n\nstatic void rtw8821c_cfg_ldo25(struct rtw_dev *rtwdev, bool enable)\n{\n\tu8 ldo_pwr;\n\n\tldo_pwr = rtw_read8(rtwdev, REG_LDO_EFUSE_CTRL + 3);\n\tldo_pwr = enable ? ldo_pwr | BIT(7) : ldo_pwr & ~BIT(7);\n\trtw_write8(rtwdev, REG_LDO_EFUSE_CTRL + 3, ldo_pwr);\n}\n\nstatic void rtw8821c_switch_rf_set(struct rtw_dev *rtwdev, u8 rf_set)\n{\n\tu32 reg;\n\n\trtw_write32_set(rtwdev, REG_DMEM_CTRL, BIT_WL_RST);\n\trtw_write32_set(rtwdev, REG_SYS_CTRL, BIT_FEN_EN);\n\n\treg = rtw_read32(rtwdev, REG_RFECTL);\n\tswitch (rf_set) {\n\tcase SWITCH_TO_BTG:\n\t\treg |= B_BTG_SWITCH;\n\t\treg &= ~(B_CTRL_SWITCH | B_WL_SWITCH | B_WLG_SWITCH |\n\t\t\t B_WLA_SWITCH);\n\t\trtw_write32_mask(rtwdev, REG_ENRXCCA, MASKBYTE2, BTG_CCA);\n\t\trtw_write32_mask(rtwdev, REG_ENTXCCK, MASKLWORD, BTG_LNA);\n\t\tbreak;\n\tcase SWITCH_TO_WLG:\n\t\treg |= B_WL_SWITCH | B_WLG_SWITCH;\n\t\treg &= ~(B_BTG_SWITCH | B_CTRL_SWITCH | B_WLA_SWITCH);\n\t\trtw_write32_mask(rtwdev, REG_ENRXCCA, MASKBYTE2, WLG_CCA);\n\t\trtw_write32_mask(rtwdev, REG_ENTXCCK, MASKLWORD, WLG_LNA);\n\t\tbreak;\n\tcase SWITCH_TO_WLA:\n\t\treg |= B_WL_SWITCH | B_WLA_SWITCH;\n\t\treg &= ~(B_BTG_SWITCH | B_CTRL_SWITCH | B_WLG_SWITCH);\n\t\tbreak;\n\tcase SWITCH_TO_BT:\n\tdefault:\n\t\tbreak;\n\t}\n\n\trtw_write32(rtwdev, REG_RFECTL, reg);\n}\n\nstatic void rtw8821c_set_channel_rf(struct rtw_dev *rtwdev, u8 channel, u8 bw)\n{\n\tstruct rtw_hal *hal = &rtwdev->hal;\n\tu32 rf_reg18;\n\n\trf_reg18 = rtw_read_rf(rtwdev, RF_PATH_A, 0x18, RFREG_MASK);\n\n\trf_reg18 &= ~(RF18_BAND_MASK | RF18_CHANNEL_MASK | RF18_RFSI_MASK |\n\t\t      RF18_BW_MASK);\n\n\trf_reg18 |= (channel <= 14 ? RF18_BAND_2G : RF18_BAND_5G);\n\trf_reg18 |= (channel & RF18_CHANNEL_MASK);\n\n\tif (channel >= 100 && channel <= 140)\n\t\trf_reg18 |= RF18_RFSI_GE;\n\telse if (channel > 140)\n\t\trf_reg18 |= RF18_RFSI_GT;\n\n\tswitch (bw) {\n\tcase RTW_CHANNEL_WIDTH_5:\n\tcase RTW_CHANNEL_WIDTH_10:\n\tcase RTW_CHANNEL_WIDTH_20:\n\tdefault:\n\t\trf_reg18 |= RF18_BW_20M;\n\t\tbreak;\n\tcase RTW_CHANNEL_WIDTH_40:\n\t\trf_reg18 |= RF18_BW_40M;\n\t\tbreak;\n\tcase RTW_CHANNEL_WIDTH_80:\n\t\trf_reg18 |= RF18_BW_80M;\n\t\tbreak;\n\t}\n\n\tif (channel <= 14) {\n\t\tif (hal->rfe_btg)\n\t\t\trtw8821c_switch_rf_set(rtwdev, SWITCH_TO_BTG);\n\t\telse\n\t\t\trtw8821c_switch_rf_set(rtwdev, SWITCH_TO_WLG);\n\t\trtw_write_rf(rtwdev, RF_PATH_A, RF_LUTDBG, BIT(6), 0x1);\n\t\trtw_write_rf(rtwdev, RF_PATH_A, 0x64, 0xf, 0xf);\n\t} else {\n\t\trtw8821c_switch_rf_set(rtwdev, SWITCH_TO_WLA);\n\t\trtw_write_rf(rtwdev, RF_PATH_A, RF_LUTDBG, BIT(6), 0x0);\n\t}\n\n\trtw_write_rf(rtwdev, RF_PATH_A, 0x18, RFREG_MASK, rf_reg18);\n\n\trtw_write_rf(rtwdev, RF_PATH_A, RF_XTALX2, BIT(19), 0);\n\trtw_write_rf(rtwdev, RF_PATH_A, RF_XTALX2, BIT(19), 1);\n}\n\nstatic void rtw8821c_set_channel_rxdfir(struct rtw_dev *rtwdev, u8 bw)\n{\n\tif (bw == RTW_CHANNEL_WIDTH_40) {\n\t\t \n\t\trtw_write32_mask(rtwdev, REG_ACBB0, BIT(29) | BIT(28), 0x2);\n\t\trtw_write32_mask(rtwdev, REG_ACBBRXFIR, BIT(29) | BIT(28), 0x2);\n\t\trtw_write32_mask(rtwdev, REG_TXDFIR, BIT(31), 0x0);\n\t\trtw_write32_mask(rtwdev, REG_CHFIR, BIT(31), 0x0);\n\t} else if (bw == RTW_CHANNEL_WIDTH_80) {\n\t\t \n\t\trtw_write32_mask(rtwdev, REG_ACBB0, BIT(29) | BIT(28), 0x2);\n\t\trtw_write32_mask(rtwdev, REG_ACBBRXFIR, BIT(29) | BIT(28), 0x1);\n\t\trtw_write32_mask(rtwdev, REG_TXDFIR, BIT(31), 0x0);\n\t\trtw_write32_mask(rtwdev, REG_CHFIR, BIT(31), 0x1);\n\t} else {\n\t\t \n\t\trtw_write32_mask(rtwdev, REG_ACBB0, BIT(29) | BIT(28), 0x2);\n\t\trtw_write32_mask(rtwdev, REG_ACBBRXFIR, BIT(29) | BIT(28), 0x2);\n\t\trtw_write32_mask(rtwdev, REG_TXDFIR, BIT(31), 0x1);\n\t\trtw_write32_mask(rtwdev, REG_CHFIR, BIT(31), 0x0);\n\t}\n}\n\nstatic void rtw8821c_set_channel_bb(struct rtw_dev *rtwdev, u8 channel, u8 bw,\n\t\t\t\t    u8 primary_ch_idx)\n{\n\tstruct rtw_hal *hal = &rtwdev->hal;\n\tu32 val32;\n\n\tif (channel <= 14) {\n\t\trtw_write32_mask(rtwdev, REG_RXPSEL, BIT(28), 0x1);\n\t\trtw_write32_mask(rtwdev, REG_CCK_CHECK, BIT(7), 0x0);\n\t\trtw_write32_mask(rtwdev, REG_ENTXCCK, BIT(18), 0x0);\n\t\trtw_write32_mask(rtwdev, REG_RXCCAMSK, 0x0000FC00, 15);\n\n\t\trtw_write32_mask(rtwdev, REG_TXSCALE_A, 0xf00, 0x0);\n\t\trtw_write32_mask(rtwdev, REG_CLKTRK, 0x1ffe0000, 0x96a);\n\t\tif (channel == 14) {\n\t\t\trtw_write32_mask(rtwdev, REG_TXSF2, MASKDWORD, 0x0000b81c);\n\t\t\trtw_write32_mask(rtwdev, REG_TXSF6, MASKLWORD, 0x0000);\n\t\t\trtw_write32_mask(rtwdev, REG_TXFILTER, MASKDWORD, 0x00003667);\n\t\t} else {\n\t\t\trtw_write32_mask(rtwdev, REG_TXSF2, MASKDWORD,\n\t\t\t\t\t hal->ch_param[0]);\n\t\t\trtw_write32_mask(rtwdev, REG_TXSF6, MASKLWORD,\n\t\t\t\t\t hal->ch_param[1] & MASKLWORD);\n\t\t\trtw_write32_mask(rtwdev, REG_TXFILTER, MASKDWORD,\n\t\t\t\t\t hal->ch_param[2]);\n\t\t}\n\t} else if (channel > 35) {\n\t\trtw_write32_mask(rtwdev, REG_ENTXCCK, BIT(18), 0x1);\n\t\trtw_write32_mask(rtwdev, REG_CCK_CHECK, BIT(7), 0x1);\n\t\trtw_write32_mask(rtwdev, REG_RXPSEL, BIT(28), 0x0);\n\t\trtw_write32_mask(rtwdev, REG_RXCCAMSK, 0x0000FC00, 15);\n\n\t\tif (channel >= 36 && channel <= 64)\n\t\t\trtw_write32_mask(rtwdev, REG_TXSCALE_A, 0xf00, 0x1);\n\t\telse if (channel >= 100 && channel <= 144)\n\t\t\trtw_write32_mask(rtwdev, REG_TXSCALE_A, 0xf00, 0x2);\n\t\telse if (channel >= 149)\n\t\t\trtw_write32_mask(rtwdev, REG_TXSCALE_A, 0xf00, 0x3);\n\n\t\tif (channel >= 36 && channel <= 48)\n\t\t\trtw_write32_mask(rtwdev, REG_CLKTRK, 0x1ffe0000, 0x494);\n\t\telse if (channel >= 52 && channel <= 64)\n\t\t\trtw_write32_mask(rtwdev, REG_CLKTRK, 0x1ffe0000, 0x453);\n\t\telse if (channel >= 100 && channel <= 116)\n\t\t\trtw_write32_mask(rtwdev, REG_CLKTRK, 0x1ffe0000, 0x452);\n\t\telse if (channel >= 118 && channel <= 177)\n\t\t\trtw_write32_mask(rtwdev, REG_CLKTRK, 0x1ffe0000, 0x412);\n\t}\n\n\tswitch (bw) {\n\tcase RTW_CHANNEL_WIDTH_20:\n\tdefault:\n\t\tval32 = rtw_read32_mask(rtwdev, REG_ADCCLK, MASKDWORD);\n\t\tval32 &= 0xffcffc00;\n\t\tval32 |= 0x10010000;\n\t\trtw_write32_mask(rtwdev, REG_ADCCLK, MASKDWORD, val32);\n\n\t\trtw_write32_mask(rtwdev, REG_ADC160, BIT(30), 0x1);\n\t\tbreak;\n\tcase RTW_CHANNEL_WIDTH_40:\n\t\tif (primary_ch_idx == 1)\n\t\t\trtw_write32_set(rtwdev, REG_RXSB, BIT(4));\n\t\telse\n\t\t\trtw_write32_clr(rtwdev, REG_RXSB, BIT(4));\n\n\t\tval32 = rtw_read32_mask(rtwdev, REG_ADCCLK, MASKDWORD);\n\t\tval32 &= 0xff3ff300;\n\t\tval32 |= 0x20020000 | ((primary_ch_idx & 0xf) << 2) |\n\t\t\t RTW_CHANNEL_WIDTH_40;\n\t\trtw_write32_mask(rtwdev, REG_ADCCLK, MASKDWORD, val32);\n\n\t\trtw_write32_mask(rtwdev, REG_ADC160, BIT(30), 0x1);\n\t\tbreak;\n\tcase RTW_CHANNEL_WIDTH_80:\n\t\tval32 = rtw_read32_mask(rtwdev, REG_ADCCLK, MASKDWORD);\n\t\tval32 &= 0xfcffcf00;\n\t\tval32 |= 0x40040000 | ((primary_ch_idx & 0xf) << 2) |\n\t\t\t RTW_CHANNEL_WIDTH_80;\n\t\trtw_write32_mask(rtwdev, REG_ADCCLK, MASKDWORD, val32);\n\n\t\trtw_write32_mask(rtwdev, REG_ADC160, BIT(30), 0x1);\n\t\tbreak;\n\tcase RTW_CHANNEL_WIDTH_5:\n\t\tval32 = rtw_read32_mask(rtwdev, REG_ADCCLK, MASKDWORD);\n\t\tval32 &= 0xefcefc00;\n\t\tval32 |= 0x200240;\n\t\trtw_write32_mask(rtwdev, REG_ADCCLK, MASKDWORD, val32);\n\n\t\trtw_write32_mask(rtwdev, REG_ADC160, BIT(30), 0x0);\n\t\trtw_write32_mask(rtwdev, REG_ADC40, BIT(31), 0x1);\n\t\tbreak;\n\tcase RTW_CHANNEL_WIDTH_10:\n\t\tval32 = rtw_read32_mask(rtwdev, REG_ADCCLK, MASKDWORD);\n\t\tval32 &= 0xefcefc00;\n\t\tval32 |= 0x300380;\n\t\trtw_write32_mask(rtwdev, REG_ADCCLK, MASKDWORD, val32);\n\n\t\trtw_write32_mask(rtwdev, REG_ADC160, BIT(30), 0x0);\n\t\trtw_write32_mask(rtwdev, REG_ADC40, BIT(31), 0x1);\n\t\tbreak;\n\t}\n}\n\nstatic u32 rtw8821c_get_bb_swing(struct rtw_dev *rtwdev, u8 channel)\n{\n\tstruct rtw_efuse efuse = rtwdev->efuse;\n\tu8 tx_bb_swing;\n\tu32 swing2setting[4] = {0x200, 0x16a, 0x101, 0x0b6};\n\n\ttx_bb_swing = channel <= 14 ? efuse.tx_bb_swing_setting_2g :\n\t\t\t\t      efuse.tx_bb_swing_setting_5g;\n\tif (tx_bb_swing > 9)\n\t\ttx_bb_swing = 0;\n\n\treturn swing2setting[(tx_bb_swing / 3)];\n}\n\nstatic void rtw8821c_set_channel_bb_swing(struct rtw_dev *rtwdev, u8 channel,\n\t\t\t\t\t  u8 bw, u8 primary_ch_idx)\n{\n\trtw_write32_mask(rtwdev, REG_TXSCALE_A, GENMASK(31, 21),\n\t\t\t rtw8821c_get_bb_swing(rtwdev, channel));\n\trtw8821c_pwrtrack_init(rtwdev);\n}\n\nstatic void rtw8821c_set_channel(struct rtw_dev *rtwdev, u8 channel, u8 bw,\n\t\t\t\t u8 primary_chan_idx)\n{\n\trtw8821c_set_channel_bb(rtwdev, channel, bw, primary_chan_idx);\n\trtw8821c_set_channel_bb_swing(rtwdev, channel, bw, primary_chan_idx);\n\trtw_set_channel_mac(rtwdev, channel, bw, primary_chan_idx);\n\trtw8821c_set_channel_rf(rtwdev, channel, bw);\n\trtw8821c_set_channel_rxdfir(rtwdev, bw);\n}\n\nstatic s8 get_cck_rx_pwr(struct rtw_dev *rtwdev, u8 lna_idx, u8 vga_idx)\n{\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\tconst s8 *lna_gain_table;\n\tint lna_gain_table_size;\n\ts8 rx_pwr_all = 0;\n\ts8 lna_gain = 0;\n\n\tif (efuse->rfe_option == 0) {\n\t\tlna_gain_table = lna_gain_table_0;\n\t\tlna_gain_table_size = ARRAY_SIZE(lna_gain_table_0);\n\t} else {\n\t\tlna_gain_table = lna_gain_table_1;\n\t\tlna_gain_table_size = ARRAY_SIZE(lna_gain_table_1);\n\t}\n\n\tif (lna_idx >= lna_gain_table_size) {\n\t\trtw_warn(rtwdev, \"incorrect lna index (%d)\\n\", lna_idx);\n\t\treturn -120;\n\t}\n\n\tlna_gain = lna_gain_table[lna_idx];\n\trx_pwr_all = lna_gain - 2 * vga_idx;\n\n\treturn rx_pwr_all;\n}\n\nstatic void query_phy_status_page0(struct rtw_dev *rtwdev, u8 *phy_status,\n\t\t\t\t   struct rtw_rx_pkt_stat *pkt_stat)\n{\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\ts8 rx_power;\n\tu8 lna_idx = 0;\n\tu8 vga_idx = 0;\n\n\tvga_idx = GET_PHY_STAT_P0_VGA(phy_status);\n\tlna_idx = FIELD_PREP(BIT_LNA_H_MASK, GET_PHY_STAT_P0_LNA_H(phy_status)) |\n\t\t  FIELD_PREP(BIT_LNA_L_MASK, GET_PHY_STAT_P0_LNA_L(phy_status));\n\trx_power = get_cck_rx_pwr(rtwdev, lna_idx, vga_idx);\n\n\tpkt_stat->rx_power[RF_PATH_A] = rx_power;\n\tpkt_stat->rssi = rtw_phy_rf_power_2_rssi(pkt_stat->rx_power, 1);\n\tdm_info->rssi[RF_PATH_A] = pkt_stat->rssi;\n\tpkt_stat->bw = RTW_CHANNEL_WIDTH_20;\n\tpkt_stat->signal_power = rx_power;\n}\n\nstatic void query_phy_status_page1(struct rtw_dev *rtwdev, u8 *phy_status,\n\t\t\t\t   struct rtw_rx_pkt_stat *pkt_stat)\n{\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tu8 rxsc, bw;\n\ts8 min_rx_power = -120;\n\n\tif (pkt_stat->rate > DESC_RATE11M && pkt_stat->rate < DESC_RATEMCS0)\n\t\trxsc = GET_PHY_STAT_P1_L_RXSC(phy_status);\n\telse\n\t\trxsc = GET_PHY_STAT_P1_HT_RXSC(phy_status);\n\n\tif (rxsc >= 1 && rxsc <= 8)\n\t\tbw = RTW_CHANNEL_WIDTH_20;\n\telse if (rxsc >= 9 && rxsc <= 12)\n\t\tbw = RTW_CHANNEL_WIDTH_40;\n\telse if (rxsc >= 13)\n\t\tbw = RTW_CHANNEL_WIDTH_80;\n\telse\n\t\tbw = GET_PHY_STAT_P1_RF_MODE(phy_status);\n\n\tpkt_stat->rx_power[RF_PATH_A] = GET_PHY_STAT_P1_PWDB_A(phy_status) - 110;\n\tpkt_stat->rssi = rtw_phy_rf_power_2_rssi(pkt_stat->rx_power, 1);\n\tdm_info->rssi[RF_PATH_A] = pkt_stat->rssi;\n\tpkt_stat->bw = bw;\n\tpkt_stat->signal_power = max(pkt_stat->rx_power[RF_PATH_A],\n\t\t\t\t     min_rx_power);\n}\n\nstatic void query_phy_status(struct rtw_dev *rtwdev, u8 *phy_status,\n\t\t\t     struct rtw_rx_pkt_stat *pkt_stat)\n{\n\tu8 page;\n\n\tpage = *phy_status & 0xf;\n\n\tswitch (page) {\n\tcase 0:\n\t\tquery_phy_status_page0(rtwdev, phy_status, pkt_stat);\n\t\tbreak;\n\tcase 1:\n\t\tquery_phy_status_page1(rtwdev, phy_status, pkt_stat);\n\t\tbreak;\n\tdefault:\n\t\trtw_warn(rtwdev, \"unused phy status page (%d)\\n\", page);\n\t\treturn;\n\t}\n}\n\nstatic void rtw8821c_query_rx_desc(struct rtw_dev *rtwdev, u8 *rx_desc,\n\t\t\t\t   struct rtw_rx_pkt_stat *pkt_stat,\n\t\t\t\t   struct ieee80211_rx_status *rx_status)\n{\n\tstruct ieee80211_hdr *hdr;\n\tu32 desc_sz = rtwdev->chip->rx_pkt_desc_sz;\n\tu8 *phy_status = NULL;\n\n\tmemset(pkt_stat, 0, sizeof(*pkt_stat));\n\n\tpkt_stat->phy_status = GET_RX_DESC_PHYST(rx_desc);\n\tpkt_stat->icv_err = GET_RX_DESC_ICV_ERR(rx_desc);\n\tpkt_stat->crc_err = GET_RX_DESC_CRC32(rx_desc);\n\tpkt_stat->decrypted = !GET_RX_DESC_SWDEC(rx_desc) &&\n\t\t\t      GET_RX_DESC_ENC_TYPE(rx_desc) != RX_DESC_ENC_NONE;\n\tpkt_stat->is_c2h = GET_RX_DESC_C2H(rx_desc);\n\tpkt_stat->pkt_len = GET_RX_DESC_PKT_LEN(rx_desc);\n\tpkt_stat->drv_info_sz = GET_RX_DESC_DRV_INFO_SIZE(rx_desc);\n\tpkt_stat->shift = GET_RX_DESC_SHIFT(rx_desc);\n\tpkt_stat->rate = GET_RX_DESC_RX_RATE(rx_desc);\n\tpkt_stat->cam_id = GET_RX_DESC_MACID(rx_desc);\n\tpkt_stat->ppdu_cnt = GET_RX_DESC_PPDU_CNT(rx_desc);\n\tpkt_stat->tsf_low = GET_RX_DESC_TSFL(rx_desc);\n\n\t \n\tpkt_stat->drv_info_sz *= 8;\n\n\t \n\tif (pkt_stat->is_c2h)\n\t\treturn;\n\n\thdr = (struct ieee80211_hdr *)(rx_desc + desc_sz + pkt_stat->shift +\n\t\t\t\t       pkt_stat->drv_info_sz);\n\tif (pkt_stat->phy_status) {\n\t\tphy_status = rx_desc + desc_sz + pkt_stat->shift;\n\t\tquery_phy_status(rtwdev, phy_status, pkt_stat);\n\t}\n\n\trtw_rx_fill_rx_status(rtwdev, pkt_stat, hdr, rx_status, phy_status);\n}\n\nstatic void\nrtw8821c_set_tx_power_index_by_rate(struct rtw_dev *rtwdev, u8 path, u8 rs)\n{\n\tstruct rtw_hal *hal = &rtwdev->hal;\n\tstatic const u32 offset_txagc[2] = {0x1d00, 0x1d80};\n\tstatic u32 phy_pwr_idx;\n\tu8 rate, rate_idx, pwr_index, shift;\n\tint j;\n\n\tfor (j = 0; j < rtw_rate_size[rs]; j++) {\n\t\trate = rtw_rate_section[rs][j];\n\t\tpwr_index = hal->tx_pwr_tbl[path][rate];\n\t\tshift = rate & 0x3;\n\t\tphy_pwr_idx |= ((u32)pwr_index << (shift * 8));\n\t\tif (shift == 0x3 || rate == DESC_RATEVHT1SS_MCS9) {\n\t\t\trate_idx = rate & 0xfc;\n\t\t\trtw_write32(rtwdev, offset_txagc[path] + rate_idx,\n\t\t\t\t    phy_pwr_idx);\n\t\t\tphy_pwr_idx = 0;\n\t\t}\n\t}\n}\n\nstatic void rtw8821c_set_tx_power_index(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_hal *hal = &rtwdev->hal;\n\tint rs, path;\n\n\tfor (path = 0; path < hal->rf_path_num; path++) {\n\t\tfor (rs = 0; rs < RTW_RATE_SECTION_MAX; rs++) {\n\t\t\tif (rs == RTW_RATE_SECTION_HT_2S ||\n\t\t\t    rs == RTW_RATE_SECTION_VHT_2S)\n\t\t\t\tcontinue;\n\t\t\trtw8821c_set_tx_power_index_by_rate(rtwdev, path, rs);\n\t\t}\n\t}\n}\n\nstatic void rtw8821c_false_alarm_statistics(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tu32 cck_enable;\n\tu32 cck_fa_cnt;\n\tu32 ofdm_fa_cnt;\n\tu32 crc32_cnt;\n\tu32 cca32_cnt;\n\n\tcck_enable = rtw_read32(rtwdev, REG_RXPSEL) & BIT(28);\n\tcck_fa_cnt = rtw_read16(rtwdev, REG_FA_CCK);\n\tofdm_fa_cnt = rtw_read16(rtwdev, REG_FA_OFDM);\n\n\tdm_info->cck_fa_cnt = cck_fa_cnt;\n\tdm_info->ofdm_fa_cnt = ofdm_fa_cnt;\n\tif (cck_enable)\n\t\tdm_info->total_fa_cnt += cck_fa_cnt;\n\tdm_info->total_fa_cnt = ofdm_fa_cnt;\n\n\tcrc32_cnt = rtw_read32(rtwdev, REG_CRC_CCK);\n\tdm_info->cck_ok_cnt = FIELD_GET(GENMASK(15, 0), crc32_cnt);\n\tdm_info->cck_err_cnt = FIELD_GET(GENMASK(31, 16), crc32_cnt);\n\n\tcrc32_cnt = rtw_read32(rtwdev, REG_CRC_OFDM);\n\tdm_info->ofdm_ok_cnt = FIELD_GET(GENMASK(15, 0), crc32_cnt);\n\tdm_info->ofdm_err_cnt = FIELD_GET(GENMASK(31, 16), crc32_cnt);\n\n\tcrc32_cnt = rtw_read32(rtwdev, REG_CRC_HT);\n\tdm_info->ht_ok_cnt = FIELD_GET(GENMASK(15, 0), crc32_cnt);\n\tdm_info->ht_err_cnt = FIELD_GET(GENMASK(31, 16), crc32_cnt);\n\n\tcrc32_cnt = rtw_read32(rtwdev, REG_CRC_VHT);\n\tdm_info->vht_ok_cnt = FIELD_GET(GENMASK(15, 0), crc32_cnt);\n\tdm_info->vht_err_cnt = FIELD_GET(GENMASK(31, 16), crc32_cnt);\n\n\tcca32_cnt = rtw_read32(rtwdev, REG_CCA_OFDM);\n\tdm_info->ofdm_cca_cnt = FIELD_GET(GENMASK(31, 16), cca32_cnt);\n\tdm_info->total_cca_cnt = dm_info->ofdm_cca_cnt;\n\tif (cck_enable) {\n\t\tcca32_cnt = rtw_read32(rtwdev, REG_CCA_CCK);\n\t\tdm_info->cck_cca_cnt = FIELD_GET(GENMASK(15, 0), cca32_cnt);\n\t\tdm_info->total_cca_cnt += dm_info->cck_cca_cnt;\n\t}\n\n\trtw_write32_set(rtwdev, REG_FAS, BIT(17));\n\trtw_write32_clr(rtwdev, REG_FAS, BIT(17));\n\trtw_write32_clr(rtwdev, REG_RXDESC, BIT(15));\n\trtw_write32_set(rtwdev, REG_RXDESC, BIT(15));\n\trtw_write32_set(rtwdev, REG_CNTRST, BIT(0));\n\trtw_write32_clr(rtwdev, REG_CNTRST, BIT(0));\n}\n\nstatic void rtw8821c_do_iqk(struct rtw_dev *rtwdev)\n{\n\tstatic int do_iqk_cnt;\n\tstruct rtw_iqk_para para = {.clear = 0, .segment_iqk = 0};\n\tu32 rf_reg, iqk_fail_mask;\n\tint counter;\n\tbool reload;\n\n\tif (rtw_is_assoc(rtwdev))\n\t\tpara.segment_iqk = 1;\n\n\trtw_fw_do_iqk(rtwdev, &para);\n\n\tfor (counter = 0; counter < 300; counter++) {\n\t\trf_reg = rtw_read_rf(rtwdev, RF_PATH_A, RF_DTXLOK, RFREG_MASK);\n\t\tif (rf_reg == 0xabcde)\n\t\t\tbreak;\n\t\tmsleep(20);\n\t}\n\trtw_write_rf(rtwdev, RF_PATH_A, RF_DTXLOK, RFREG_MASK, 0x0);\n\n\treload = !!rtw_read32_mask(rtwdev, REG_IQKFAILMSK, BIT(16));\n\tiqk_fail_mask = rtw_read32_mask(rtwdev, REG_IQKFAILMSK, GENMASK(7, 0));\n\trtw_dbg(rtwdev, RTW_DBG_PHY,\n\t\t\"iqk counter=%d reload=%d do_iqk_cnt=%d n_iqk_fail(mask)=0x%02x\\n\",\n\t\tcounter, reload, ++do_iqk_cnt, iqk_fail_mask);\n}\n\nstatic void rtw8821c_phy_calibration(struct rtw_dev *rtwdev)\n{\n\trtw8821c_do_iqk(rtwdev);\n}\n\n \nstatic void rtw8821c_coex_cfg_init(struct rtw_dev *rtwdev)\n{\n\t \n\trtw_write8_set(rtwdev, REG_BCN_CTRL, BIT_EN_BCN_FUNCTION);\n\n\t \n\trtw_write8_mask(rtwdev, REG_BT_TDMA_TIME, BIT_MASK_SAMPLE_RATE, 0x5);\n\n\t \n\trtw_write8(rtwdev, REG_BT_STAT_CTRL, BT_CNT_ENABLE);\n\n\t \n\trtw_write32_set(rtwdev, REG_GPIO_MUXCFG, BIT_BT_PTA_EN);\n\trtw_write32_set(rtwdev, REG_GPIO_MUXCFG, BIT_PO_BT_PTA_PINS);\n\n\t \n\trtw_write8_set(rtwdev, REG_QUEUE_CTRL, BIT_PTA_WL_TX_EN);\n\t \n\trtw_write8_clr(rtwdev, REG_QUEUE_CTRL, BIT_PTA_EDCCA_EN);\n\t \n\trtw_write16_set(rtwdev, REG_BT_COEX_V2, BIT_GNT_BT_POLARITY);\n\n\t \n\trtw_write8_mask(rtwdev, REG_BT_COEX_TABLE_H + 3, BIT_BCN_QUEUE,\n\t\t\tBCN_PRI_EN);\n}\n\nstatic void rtw8821c_coex_cfg_ant_switch(struct rtw_dev *rtwdev, u8 ctrl_type,\n\t\t\t\t\t u8 pos_type)\n{\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_dm *coex_dm = &coex->dm;\n\tstruct rtw_coex_rfe *coex_rfe = &coex->rfe;\n\tu32 switch_status = FIELD_PREP(CTRL_TYPE_MASK, ctrl_type) | pos_type;\n\tbool polarity_inverse;\n\tu8 regval = 0;\n\n\tif (switch_status == coex_dm->cur_switch_status)\n\t\treturn;\n\n\tif (coex_rfe->wlg_at_btg) {\n\t\tctrl_type = COEX_SWITCH_CTRL_BY_BBSW;\n\n\t\tif (coex_rfe->ant_switch_polarity)\n\t\t\tpos_type = COEX_SWITCH_TO_WLA;\n\t\telse\n\t\t\tpos_type = COEX_SWITCH_TO_WLG_BT;\n\t}\n\n\tcoex_dm->cur_switch_status = switch_status;\n\n\tif (coex_rfe->ant_switch_diversity &&\n\t    ctrl_type == COEX_SWITCH_CTRL_BY_BBSW)\n\t\tctrl_type = COEX_SWITCH_CTRL_BY_ANTDIV;\n\n\tpolarity_inverse = (coex_rfe->ant_switch_polarity == 1);\n\n\tswitch (ctrl_type) {\n\tdefault:\n\tcase COEX_SWITCH_CTRL_BY_BBSW:\n\t\trtw_write32_clr(rtwdev, REG_LED_CFG, BIT_DPDT_SEL_EN);\n\t\trtw_write32_set(rtwdev, REG_LED_CFG, BIT_DPDT_WL_SEL);\n\t\t \n\t\trtw_write8_mask(rtwdev, REG_RFE_CTRL8, BIT_MASK_RFE_SEL89,\n\t\t\t\tDPDT_CTRL_PIN);\n\n\t\tif (pos_type == COEX_SWITCH_TO_WLG_BT) {\n\t\t\tif (coex_rfe->rfe_module_type != 0x4 &&\n\t\t\t    coex_rfe->rfe_module_type != 0x2)\n\t\t\t\tregval = 0x3;\n\t\t\telse\n\t\t\t\tregval = (!polarity_inverse ? 0x2 : 0x1);\n\t\t} else if (pos_type == COEX_SWITCH_TO_WLG) {\n\t\t\tregval = (!polarity_inverse ? 0x2 : 0x1);\n\t\t} else {\n\t\t\tregval = (!polarity_inverse ? 0x1 : 0x2);\n\t\t}\n\n\t\trtw_write32_mask(rtwdev, REG_RFE_CTRL8, BIT_MASK_R_RFE_SEL_15,\n\t\t\t\t regval);\n\t\tbreak;\n\tcase COEX_SWITCH_CTRL_BY_PTA:\n\t\trtw_write32_clr(rtwdev, REG_LED_CFG, BIT_DPDT_SEL_EN);\n\t\trtw_write32_set(rtwdev, REG_LED_CFG, BIT_DPDT_WL_SEL);\n\t\t \n\t\trtw_write8_mask(rtwdev, REG_RFE_CTRL8, BIT_MASK_RFE_SEL89,\n\t\t\t\tPTA_CTRL_PIN);\n\n\t\tregval = (!polarity_inverse ? 0x2 : 0x1);\n\t\trtw_write32_mask(rtwdev, REG_RFE_CTRL8, BIT_MASK_R_RFE_SEL_15,\n\t\t\t\t regval);\n\t\tbreak;\n\tcase COEX_SWITCH_CTRL_BY_ANTDIV:\n\t\trtw_write32_clr(rtwdev, REG_LED_CFG, BIT_DPDT_SEL_EN);\n\t\trtw_write32_set(rtwdev, REG_LED_CFG, BIT_DPDT_WL_SEL);\n\t\trtw_write8_mask(rtwdev, REG_RFE_CTRL8, BIT_MASK_RFE_SEL89,\n\t\t\t\tANTDIC_CTRL_PIN);\n\t\tbreak;\n\tcase COEX_SWITCH_CTRL_BY_MAC:\n\t\trtw_write32_set(rtwdev, REG_LED_CFG, BIT_DPDT_SEL_EN);\n\n\t\tregval = (!polarity_inverse ? 0x0 : 0x1);\n\t\trtw_write8_mask(rtwdev, REG_PAD_CTRL1, BIT_SW_DPDT_SEL_DATA,\n\t\t\t\tregval);\n\t\tbreak;\n\tcase COEX_SWITCH_CTRL_BY_FW:\n\t\trtw_write32_clr(rtwdev, REG_LED_CFG, BIT_DPDT_SEL_EN);\n\t\trtw_write32_set(rtwdev, REG_LED_CFG, BIT_DPDT_WL_SEL);\n\t\tbreak;\n\tcase COEX_SWITCH_CTRL_BY_BT:\n\t\trtw_write32_clr(rtwdev, REG_LED_CFG, BIT_DPDT_SEL_EN);\n\t\trtw_write32_clr(rtwdev, REG_LED_CFG, BIT_DPDT_WL_SEL);\n\t\tbreak;\n\t}\n\n\tif (ctrl_type == COEX_SWITCH_CTRL_BY_BT) {\n\t\trtw_write8_clr(rtwdev, REG_CTRL_TYPE, BIT_CTRL_TYPE1);\n\t\trtw_write8_clr(rtwdev, REG_CTRL_TYPE, BIT_CTRL_TYPE2);\n\t} else {\n\t\trtw_write8_set(rtwdev, REG_CTRL_TYPE, BIT_CTRL_TYPE1);\n\t\trtw_write8_set(rtwdev, REG_CTRL_TYPE, BIT_CTRL_TYPE2);\n\t}\n}\n\nstatic void rtw8821c_coex_cfg_gnt_fix(struct rtw_dev *rtwdev)\n{}\n\nstatic void rtw8821c_coex_cfg_gnt_debug(struct rtw_dev *rtwdev)\n{\n\trtw_write32_clr(rtwdev, REG_PAD_CTRL1, BIT_BTGP_SPI_EN);\n\trtw_write32_clr(rtwdev, REG_PAD_CTRL1, BIT_BTGP_JTAG_EN);\n\trtw_write32_clr(rtwdev, REG_GPIO_MUXCFG, BIT_FSPI_EN);\n\trtw_write32_clr(rtwdev, REG_PAD_CTRL1, BIT_LED1DIS);\n\trtw_write32_clr(rtwdev, REG_SYS_SDIO_CTRL, BIT_SDIO_INT);\n\trtw_write32_clr(rtwdev, REG_SYS_SDIO_CTRL, BIT_DBG_GNT_WL_BT);\n}\n\nstatic void rtw8821c_coex_cfg_rfe_type(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_rfe *coex_rfe = &coex->rfe;\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\n\tcoex_rfe->rfe_module_type = efuse->rfe_option;\n\tcoex_rfe->ant_switch_polarity = 0;\n\tcoex_rfe->ant_switch_exist = true;\n\tcoex_rfe->wlg_at_btg = false;\n\n\tswitch (coex_rfe->rfe_module_type) {\n\tcase 0:\n\tcase 8:\n\tcase 1:\n\tcase 9:   \n\tdefault:  \n\t\tbreak;\n\tcase 2:\n\tcase 10:  \n\tcase 7:\n\tcase 15:  \n\t\tcoex_rfe->wlg_at_btg = true;\n\t\tbreak;\n\tcase 3:\n\tcase 11:  \n\t\tcoex_rfe->ant_switch_polarity = 1;\n\t\tbreak;\n\tcase 4:\n\tcase 12:  \n\t\tcoex_rfe->wlg_at_btg = true;\n\t\tcoex_rfe->ant_switch_polarity = 1;\n\t\tbreak;\n\tcase 5:\n\tcase 13:  \n\tcase 6:\n\tcase 14:  \n\t\tcoex_rfe->ant_switch_exist = false;\n\t\tbreak;\n\t}\n}\n\nstatic void rtw8821c_coex_cfg_wl_tx_power(struct rtw_dev *rtwdev, u8 wl_pwr)\n{\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_dm *coex_dm = &coex->dm;\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\tbool share_ant = efuse->share_ant;\n\n\tif (share_ant)\n\t\treturn;\n\n\tif (wl_pwr == coex_dm->cur_wl_pwr_lvl)\n\t\treturn;\n\n\tcoex_dm->cur_wl_pwr_lvl = wl_pwr;\n}\n\nstatic void rtw8821c_coex_cfg_wl_rx_gain(struct rtw_dev *rtwdev, bool low_gain)\n{}\n\nstatic void\nrtw8821c_txagc_swing_offset(struct rtw_dev *rtwdev, u8 pwr_idx_offset,\n\t\t\t    s8 pwr_idx_offset_lower,\n\t\t\t    s8 *txagc_idx, u8 *swing_idx)\n{\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\ts8 delta_pwr_idx = dm_info->delta_power_index[RF_PATH_A];\n\tu8 swing_upper_bound = dm_info->default_ofdm_index + 10;\n\tu8 swing_lower_bound = 0;\n\tu8 max_pwr_idx_offset = 0xf;\n\ts8 agc_index = 0;\n\tu8 swing_index = dm_info->default_ofdm_index;\n\n\tpwr_idx_offset = min_t(u8, pwr_idx_offset, max_pwr_idx_offset);\n\tpwr_idx_offset_lower = max_t(s8, pwr_idx_offset_lower, -15);\n\n\tif (delta_pwr_idx >= 0) {\n\t\tif (delta_pwr_idx <= pwr_idx_offset) {\n\t\t\tagc_index = delta_pwr_idx;\n\t\t\tswing_index = dm_info->default_ofdm_index;\n\t\t} else if (delta_pwr_idx > pwr_idx_offset) {\n\t\t\tagc_index = pwr_idx_offset;\n\t\t\tswing_index = dm_info->default_ofdm_index +\n\t\t\t\t\tdelta_pwr_idx - pwr_idx_offset;\n\t\t\tswing_index = min_t(u8, swing_index, swing_upper_bound);\n\t\t}\n\t} else if (delta_pwr_idx < 0) {\n\t\tif (delta_pwr_idx >= pwr_idx_offset_lower) {\n\t\t\tagc_index = delta_pwr_idx;\n\t\t\tswing_index = dm_info->default_ofdm_index;\n\t\t} else if (delta_pwr_idx < pwr_idx_offset_lower) {\n\t\t\tif (dm_info->default_ofdm_index >\n\t\t\t\t(pwr_idx_offset_lower - delta_pwr_idx))\n\t\t\t\tswing_index = dm_info->default_ofdm_index +\n\t\t\t\t\tdelta_pwr_idx - pwr_idx_offset_lower;\n\t\t\telse\n\t\t\t\tswing_index = swing_lower_bound;\n\n\t\t\tagc_index = pwr_idx_offset_lower;\n\t\t}\n\t}\n\n\tif (swing_index >= ARRAY_SIZE(rtw8821c_txscale_tbl)) {\n\t\trtw_warn(rtwdev, \"swing index overflow\\n\");\n\t\tswing_index = ARRAY_SIZE(rtw8821c_txscale_tbl) - 1;\n\t}\n\n\t*txagc_idx = agc_index;\n\t*swing_idx = swing_index;\n}\n\nstatic void rtw8821c_pwrtrack_set_pwr(struct rtw_dev *rtwdev, u8 pwr_idx_offset,\n\t\t\t\t      s8 pwr_idx_offset_lower)\n{\n\ts8 txagc_idx;\n\tu8 swing_idx;\n\n\trtw8821c_txagc_swing_offset(rtwdev, pwr_idx_offset, pwr_idx_offset_lower,\n\t\t\t\t    &txagc_idx, &swing_idx);\n\trtw_write32_mask(rtwdev, REG_TXAGCIDX, GENMASK(6, 1), txagc_idx);\n\trtw_write32_mask(rtwdev, REG_TXSCALE_A, GENMASK(31, 21),\n\t\t\t rtw8821c_txscale_tbl[swing_idx]);\n}\n\nstatic void rtw8821c_pwrtrack_set(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tu8 pwr_idx_offset, tx_pwr_idx;\n\ts8 pwr_idx_offset_lower;\n\tu8 channel = rtwdev->hal.current_channel;\n\tu8 band_width = rtwdev->hal.current_band_width;\n\tu8 regd = rtw_regd_get(rtwdev);\n\tu8 tx_rate = dm_info->tx_rate;\n\tu8 max_pwr_idx = rtwdev->chip->max_power_index;\n\n\ttx_pwr_idx = rtw_phy_get_tx_power_index(rtwdev, RF_PATH_A, tx_rate,\n\t\t\t\t\t\tband_width, channel, regd);\n\n\ttx_pwr_idx = min_t(u8, tx_pwr_idx, max_pwr_idx);\n\n\tpwr_idx_offset = max_pwr_idx - tx_pwr_idx;\n\tpwr_idx_offset_lower = 0 - tx_pwr_idx;\n\n\trtw8821c_pwrtrack_set_pwr(rtwdev, pwr_idx_offset, pwr_idx_offset_lower);\n}\n\nstatic void rtw8821c_phy_pwrtrack(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tstruct rtw_swing_table swing_table;\n\tu8 thermal_value, delta;\n\n\trtw_phy_config_swing_table(rtwdev, &swing_table);\n\n\tif (rtwdev->efuse.thermal_meter[0] == 0xff)\n\t\treturn;\n\n\tthermal_value = rtw_read_rf(rtwdev, RF_PATH_A, RF_T_METER, 0xfc00);\n\n\trtw_phy_pwrtrack_avg(rtwdev, thermal_value, RF_PATH_A);\n\n\tif (dm_info->pwr_trk_init_trigger)\n\t\tdm_info->pwr_trk_init_trigger = false;\n\telse if (!rtw_phy_pwrtrack_thermal_changed(rtwdev, thermal_value,\n\t\t\t\t\t\t   RF_PATH_A))\n\t\tgoto iqk;\n\n\tdelta = rtw_phy_pwrtrack_get_delta(rtwdev, RF_PATH_A);\n\n\tdelta = min_t(u8, delta, RTW_PWR_TRK_TBL_SZ - 1);\n\n\tdm_info->delta_power_index[RF_PATH_A] =\n\t\trtw_phy_pwrtrack_get_pwridx(rtwdev, &swing_table, RF_PATH_A,\n\t\t\t\t\t    RF_PATH_A, delta);\n\tif (dm_info->delta_power_index[RF_PATH_A] ==\n\t\t\tdm_info->delta_power_index_last[RF_PATH_A])\n\t\tgoto iqk;\n\telse\n\t\tdm_info->delta_power_index_last[RF_PATH_A] =\n\t\t\tdm_info->delta_power_index[RF_PATH_A];\n\trtw8821c_pwrtrack_set(rtwdev);\n\niqk:\n\tif (rtw_phy_pwrtrack_need_iqk(rtwdev))\n\t\trtw8821c_do_iqk(rtwdev);\n}\n\nstatic void rtw8821c_pwr_track(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\n\tif (efuse->power_track_type != 0)\n\t\treturn;\n\n\tif (!dm_info->pwr_trk_triggered) {\n\t\trtw_write_rf(rtwdev, RF_PATH_A, RF_T_METER,\n\t\t\t     GENMASK(17, 16), 0x03);\n\t\tdm_info->pwr_trk_triggered = true;\n\t\treturn;\n\t}\n\n\trtw8821c_phy_pwrtrack(rtwdev);\n\tdm_info->pwr_trk_triggered = false;\n}\n\nstatic void rtw8821c_bf_config_bfee_su(struct rtw_dev *rtwdev,\n\t\t\t\t       struct rtw_vif *vif,\n\t\t\t\t       struct rtw_bfee *bfee, bool enable)\n{\n\tif (enable)\n\t\trtw_bf_enable_bfee_su(rtwdev, vif, bfee);\n\telse\n\t\trtw_bf_remove_bfee_su(rtwdev, bfee);\n}\n\nstatic void rtw8821c_bf_config_bfee_mu(struct rtw_dev *rtwdev,\n\t\t\t\t       struct rtw_vif *vif,\n\t\t\t\t       struct rtw_bfee *bfee, bool enable)\n{\n\tif (enable)\n\t\trtw_bf_enable_bfee_mu(rtwdev, vif, bfee);\n\telse\n\t\trtw_bf_remove_bfee_mu(rtwdev, bfee);\n}\n\nstatic void rtw8821c_bf_config_bfee(struct rtw_dev *rtwdev, struct rtw_vif *vif,\n\t\t\t\t    struct rtw_bfee *bfee, bool enable)\n{\n\tif (bfee->role == RTW_BFEE_SU)\n\t\trtw8821c_bf_config_bfee_su(rtwdev, vif, bfee, enable);\n\telse if (bfee->role == RTW_BFEE_MU)\n\t\trtw8821c_bf_config_bfee_mu(rtwdev, vif, bfee, enable);\n\telse\n\t\trtw_warn(rtwdev, \"wrong bfee role\\n\");\n}\n\nstatic void rtw8821c_phy_cck_pd_set(struct rtw_dev *rtwdev, u8 new_lvl)\n{\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tu8 pd[CCK_PD_LV_MAX] = {3, 7, 13, 13, 13};\n\tu8 cck_n_rx;\n\n\trtw_dbg(rtwdev, RTW_DBG_PHY, \"lv: (%d) -> (%d)\\n\",\n\t\tdm_info->cck_pd_lv[RTW_CHANNEL_WIDTH_20][RF_PATH_A], new_lvl);\n\n\tif (dm_info->cck_pd_lv[RTW_CHANNEL_WIDTH_20][RF_PATH_A] == new_lvl)\n\t\treturn;\n\n\tcck_n_rx = (rtw_read8_mask(rtwdev, REG_CCK0_FAREPORT, BIT_CCK0_2RX) &&\n\t\t    rtw_read8_mask(rtwdev, REG_CCK0_FAREPORT, BIT_CCK0_MRC)) ? 2 : 1;\n\trtw_dbg(rtwdev, RTW_DBG_PHY,\n\t\t\"is_linked=%d, lv=%d, n_rx=%d, cs_ratio=0x%x, pd_th=0x%x, cck_fa_avg=%d\\n\",\n\t\trtw_is_assoc(rtwdev), new_lvl, cck_n_rx,\n\t\tdm_info->cck_pd_default + new_lvl * 2,\n\t\tpd[new_lvl], dm_info->cck_fa_avg);\n\n\tdm_info->cck_fa_avg = CCK_FA_AVG_RESET;\n\n\tdm_info->cck_pd_lv[RTW_CHANNEL_WIDTH_20][RF_PATH_A] = new_lvl;\n\trtw_write32_mask(rtwdev, REG_PWRTH, 0x3f0000, pd[new_lvl]);\n\trtw_write32_mask(rtwdev, REG_PWRTH2, 0x1f0000,\n\t\t\t dm_info->cck_pd_default + new_lvl * 2);\n}\n\nstatic void rtw8821c_fill_txdesc_checksum(struct rtw_dev *rtwdev,\n\t\t\t\t\t  struct rtw_tx_pkt_info *pkt_info,\n\t\t\t\t\t  u8 *txdesc)\n{\n\tfill_txdesc_checksum_common(txdesc, 16);\n}\n\nstatic struct rtw_pwr_seq_cmd trans_carddis_to_cardemu_8821c[] = {\n\t{0x0086,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_SDIO_MSK,\n\t RTW_PWR_ADDR_SDIO,\n\t RTW_PWR_CMD_WRITE, BIT(0), 0},\n\t{0x0086,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_SDIO_MSK,\n\t RTW_PWR_ADDR_SDIO,\n\t RTW_PWR_CMD_POLLING, BIT(1), BIT(1)},\n\t{0x004A,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_USB_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(0), 0},\n\t{0x0005,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(3) | BIT(4) | BIT(7), 0},\n\t{0x0300,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_PCI_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, 0xFF, 0},\n\t{0x0301,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_PCI_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, 0xFF, 0},\n\t{0xFFFF,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t 0,\n\t RTW_PWR_CMD_END, 0, 0},\n};\n\nstatic struct rtw_pwr_seq_cmd trans_cardemu_to_act_8821c[] = {\n\t{0x0020,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_USB_MSK | RTW_PWR_INTF_SDIO_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(0), BIT(0)},\n\t{0x0001,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_USB_MSK | RTW_PWR_INTF_SDIO_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_DELAY, 1, RTW_PWR_DELAY_MS},\n\t{0x0000,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_USB_MSK | RTW_PWR_INTF_SDIO_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(5), 0},\n\t{0x0005,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, (BIT(4) | BIT(3) | BIT(2)), 0},\n\t{0x0075,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_PCI_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(0), BIT(0)},\n\t{0x0006,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_POLLING, BIT(1), BIT(1)},\n\t{0x0075,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_PCI_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(0), 0},\n\t{0x0006,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(0), BIT(0)},\n\t{0x0005,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(7), 0},\n\t{0x0005,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, (BIT(4) | BIT(3)), 0},\n\t{0x10C3,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_USB_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(0), BIT(0)},\n\t{0x0005,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(0), BIT(0)},\n\t{0x0005,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_POLLING, BIT(0), 0},\n\t{0x0020,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(3), BIT(3)},\n\t{0x0074,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_PCI_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(5), BIT(5)},\n\t{0x0022,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_PCI_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(1), 0},\n\t{0x0062,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_PCI_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, (BIT(7) | BIT(6) | BIT(5)),\n\t (BIT(7) | BIT(6) | BIT(5))},\n\t{0x0061,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_PCI_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, (BIT(7) | BIT(6) | BIT(5)), 0},\n\t{0x007C,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(1), 0},\n\t{0xFFFF,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t 0,\n\t RTW_PWR_CMD_END, 0, 0},\n};\n\nstatic struct rtw_pwr_seq_cmd trans_act_to_cardemu_8821c[] = {\n\t{0x0093,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(3), 0},\n\t{0x001F,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, 0xFF, 0},\n\t{0x0049,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(1), 0},\n\t{0x0006,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(0), BIT(0)},\n\t{0x0002,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(1), 0},\n\t{0x10C3,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_USB_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(0), 0},\n\t{0x0005,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(1), BIT(1)},\n\t{0x0005,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_POLLING, BIT(1), 0},\n\t{0x0020,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(3), 0},\n\t{0x0000,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_USB_MSK | RTW_PWR_INTF_SDIO_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(5), BIT(5)},\n\t{0xFFFF,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t 0,\n\t RTW_PWR_CMD_END, 0, 0},\n};\n\nstatic struct rtw_pwr_seq_cmd trans_cardemu_to_carddis_8821c[] = {\n\t{0x0007,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_USB_MSK | RTW_PWR_INTF_SDIO_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, 0xFF, 0x20},\n\t{0x0067,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(5), 0},\n\t{0x0005,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_PCI_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(2), BIT(2)},\n\t{0x004A,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_USB_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(0), 0},\n\t{0x0067,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_SDIO_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(5), 0},\n\t{0x0067,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_SDIO_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(4), 0},\n\t{0x004F,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_SDIO_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(0), 0},\n\t{0x0067,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_SDIO_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(1), 0},\n\t{0x0046,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_SDIO_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(6), BIT(6)},\n\t{0x0067,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_SDIO_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(2), 0},\n\t{0x0046,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_SDIO_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(7), BIT(7)},\n\t{0x0062,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_SDIO_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(4), BIT(4)},\n\t{0x0081,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(7) | BIT(6), 0},\n\t{0x0005,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_USB_MSK | RTW_PWR_INTF_SDIO_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(3) | BIT(4), BIT(3)},\n\t{0x0086,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_SDIO_MSK,\n\t RTW_PWR_ADDR_SDIO,\n\t RTW_PWR_CMD_WRITE, BIT(0), BIT(0)},\n\t{0x0086,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_SDIO_MSK,\n\t RTW_PWR_ADDR_SDIO,\n\t RTW_PWR_CMD_POLLING, BIT(1), 0},\n\t{0x0090,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_USB_MSK | RTW_PWR_INTF_PCI_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(1), 0},\n\t{0x0044,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_SDIO_MSK,\n\t RTW_PWR_ADDR_SDIO,\n\t RTW_PWR_CMD_WRITE, 0xFF, 0},\n\t{0x0040,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_SDIO_MSK,\n\t RTW_PWR_ADDR_SDIO,\n\t RTW_PWR_CMD_WRITE, 0xFF, 0x90},\n\t{0x0041,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_SDIO_MSK,\n\t RTW_PWR_ADDR_SDIO,\n\t RTW_PWR_CMD_WRITE, 0xFF, 0x00},\n\t{0x0042,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_SDIO_MSK,\n\t RTW_PWR_ADDR_SDIO,\n\t RTW_PWR_CMD_WRITE, 0xFF, 0x04},\n\t{0xFFFF,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t 0,\n\t RTW_PWR_CMD_END, 0, 0},\n};\n\nstatic const struct rtw_pwr_seq_cmd *card_enable_flow_8821c[] = {\n\ttrans_carddis_to_cardemu_8821c,\n\ttrans_cardemu_to_act_8821c,\n\tNULL\n};\n\nstatic const struct rtw_pwr_seq_cmd *card_disable_flow_8821c[] = {\n\ttrans_act_to_cardemu_8821c,\n\ttrans_cardemu_to_carddis_8821c,\n\tNULL\n};\n\nstatic const struct rtw_intf_phy_para usb2_param_8821c[] = {\n\t{0xFFFF, 0x00,\n\t RTW_IP_SEL_PHY,\n\t RTW_INTF_PHY_CUT_ALL,\n\t RTW_INTF_PHY_PLATFORM_ALL},\n};\n\nstatic const struct rtw_intf_phy_para usb3_param_8821c[] = {\n\t{0xFFFF, 0x0000,\n\t RTW_IP_SEL_PHY,\n\t RTW_INTF_PHY_CUT_ALL,\n\t RTW_INTF_PHY_PLATFORM_ALL},\n};\n\nstatic const struct rtw_intf_phy_para pcie_gen1_param_8821c[] = {\n\t{0x0009, 0x6380,\n\t RTW_IP_SEL_PHY,\n\t RTW_INTF_PHY_CUT_ALL,\n\t RTW_INTF_PHY_PLATFORM_ALL},\n\t{0xFFFF, 0x0000,\n\t RTW_IP_SEL_PHY,\n\t RTW_INTF_PHY_CUT_ALL,\n\t RTW_INTF_PHY_PLATFORM_ALL},\n};\n\nstatic const struct rtw_intf_phy_para pcie_gen2_param_8821c[] = {\n\t{0xFFFF, 0x0000,\n\t RTW_IP_SEL_PHY,\n\t RTW_INTF_PHY_CUT_ALL,\n\t RTW_INTF_PHY_PLATFORM_ALL},\n};\n\nstatic const struct rtw_intf_phy_para_table phy_para_table_8821c = {\n\t.usb2_para\t= usb2_param_8821c,\n\t.usb3_para\t= usb3_param_8821c,\n\t.gen1_para\t= pcie_gen1_param_8821c,\n\t.gen2_para\t= pcie_gen2_param_8821c,\n\t.n_usb2_para\t= ARRAY_SIZE(usb2_param_8821c),\n\t.n_usb3_para\t= ARRAY_SIZE(usb2_param_8821c),\n\t.n_gen1_para\t= ARRAY_SIZE(pcie_gen1_param_8821c),\n\t.n_gen2_para\t= ARRAY_SIZE(pcie_gen2_param_8821c),\n};\n\nstatic const struct rtw_rfe_def rtw8821c_rfe_defs[] = {\n\t[0] = RTW_DEF_RFE(8821c, 0, 0),\n\t[2] = RTW_DEF_RFE_EXT(8821c, 0, 0, 2),\n\t[4] = RTW_DEF_RFE_EXT(8821c, 0, 0, 2),\n\t[6] = RTW_DEF_RFE(8821c, 0, 0),\n};\n\nstatic struct rtw_hw_reg rtw8821c_dig[] = {\n\t[0] = { .addr = 0xc50, .mask = 0x7f },\n};\n\nstatic const struct rtw_ltecoex_addr rtw8821c_ltecoex_addr = {\n\t.ctrl = LTECOEX_ACCESS_CTRL,\n\t.wdata = LTECOEX_WRITE_DATA,\n\t.rdata = LTECOEX_READ_DATA,\n};\n\nstatic struct rtw_page_table page_table_8821c[] = {\n\t \n\t{16, 16, 16, 14, 1},\n\t{16, 16, 16, 14, 1},\n\t{16, 16, 0, 0, 1},\n\t{16, 16, 16, 0, 1},\n\t{16, 16, 16, 14, 1},\n};\n\nstatic struct rtw_rqpn rqpn_table_8821c[] = {\n\t \n\t{RTW_DMA_MAPPING_NORMAL, RTW_DMA_MAPPING_NORMAL,\n\t RTW_DMA_MAPPING_LOW, RTW_DMA_MAPPING_LOW,\n\t RTW_DMA_MAPPING_EXTRA, RTW_DMA_MAPPING_HIGH},\n\t{RTW_DMA_MAPPING_NORMAL, RTW_DMA_MAPPING_NORMAL,\n\t RTW_DMA_MAPPING_LOW, RTW_DMA_MAPPING_LOW,\n\t RTW_DMA_MAPPING_EXTRA, RTW_DMA_MAPPING_HIGH},\n\t{RTW_DMA_MAPPING_NORMAL, RTW_DMA_MAPPING_NORMAL,\n\t RTW_DMA_MAPPING_NORMAL, RTW_DMA_MAPPING_HIGH,\n\t RTW_DMA_MAPPING_HIGH, RTW_DMA_MAPPING_HIGH},\n\t{RTW_DMA_MAPPING_NORMAL, RTW_DMA_MAPPING_NORMAL,\n\t RTW_DMA_MAPPING_LOW, RTW_DMA_MAPPING_LOW,\n\t RTW_DMA_MAPPING_HIGH, RTW_DMA_MAPPING_HIGH},\n\t{RTW_DMA_MAPPING_NORMAL, RTW_DMA_MAPPING_NORMAL,\n\t RTW_DMA_MAPPING_LOW, RTW_DMA_MAPPING_LOW,\n\t RTW_DMA_MAPPING_EXTRA, RTW_DMA_MAPPING_HIGH},\n};\n\nstatic struct rtw_prioq_addrs prioq_addrs_8821c = {\n\t.prio[RTW_DMA_MAPPING_EXTRA] = {\n\t\t.rsvd = REG_FIFOPAGE_INFO_4, .avail = REG_FIFOPAGE_INFO_4 + 2,\n\t},\n\t.prio[RTW_DMA_MAPPING_LOW] = {\n\t\t.rsvd = REG_FIFOPAGE_INFO_2, .avail = REG_FIFOPAGE_INFO_2 + 2,\n\t},\n\t.prio[RTW_DMA_MAPPING_NORMAL] = {\n\t\t.rsvd = REG_FIFOPAGE_INFO_3, .avail = REG_FIFOPAGE_INFO_3 + 2,\n\t},\n\t.prio[RTW_DMA_MAPPING_HIGH] = {\n\t\t.rsvd = REG_FIFOPAGE_INFO_1, .avail = REG_FIFOPAGE_INFO_1 + 2,\n\t},\n\t.wsize = true,\n};\n\nstatic struct rtw_chip_ops rtw8821c_ops = {\n\t.phy_set_param\t\t= rtw8821c_phy_set_param,\n\t.read_efuse\t\t= rtw8821c_read_efuse,\n\t.query_rx_desc\t\t= rtw8821c_query_rx_desc,\n\t.set_channel\t\t= rtw8821c_set_channel,\n\t.mac_init\t\t= rtw8821c_mac_init,\n\t.read_rf\t\t= rtw_phy_read_rf,\n\t.write_rf\t\t= rtw_phy_write_rf_reg_sipi,\n\t.set_antenna\t\t= NULL,\n\t.set_tx_power_index\t= rtw8821c_set_tx_power_index,\n\t.cfg_ldo25\t\t= rtw8821c_cfg_ldo25,\n\t.false_alarm_statistics\t= rtw8821c_false_alarm_statistics,\n\t.phy_calibration\t= rtw8821c_phy_calibration,\n\t.cck_pd_set\t\t= rtw8821c_phy_cck_pd_set,\n\t.pwr_track\t\t= rtw8821c_pwr_track,\n\t.config_bfee\t\t= rtw8821c_bf_config_bfee,\n\t.set_gid_table\t\t= rtw_bf_set_gid_table,\n\t.cfg_csi_rate\t\t= rtw_bf_cfg_csi_rate,\n\t.fill_txdesc_checksum\t= rtw8821c_fill_txdesc_checksum,\n\n\t.coex_set_init\t\t= rtw8821c_coex_cfg_init,\n\t.coex_set_ant_switch\t= rtw8821c_coex_cfg_ant_switch,\n\t.coex_set_gnt_fix\t= rtw8821c_coex_cfg_gnt_fix,\n\t.coex_set_gnt_debug\t= rtw8821c_coex_cfg_gnt_debug,\n\t.coex_set_rfe_type\t= rtw8821c_coex_cfg_rfe_type,\n\t.coex_set_wl_tx_power\t= rtw8821c_coex_cfg_wl_tx_power,\n\t.coex_set_wl_rx_gain\t= rtw8821c_coex_cfg_wl_rx_gain,\n};\n\n \nstatic const u8 wl_rssi_step_8821c[] = {101, 45, 101, 40};\nstatic const u8 bt_rssi_step_8821c[] = {101, 101, 101, 101};\n\n \nstatic const struct coex_table_para table_sant_8821c[] = {\n\t{0x55555555, 0x55555555},  \n\t{0x55555555, 0x55555555},\n\t{0x66555555, 0x66555555},\n\t{0xaaaaaaaa, 0xaaaaaaaa},\n\t{0x5a5a5a5a, 0x5a5a5a5a},\n\t{0xfafafafa, 0xfafafafa},  \n\t{0x6a5a5555, 0xaaaaaaaa},\n\t{0x6a5a56aa, 0x6a5a56aa},\n\t{0x6a5a5a5a, 0x6a5a5a5a},\n\t{0x66555555, 0x5a5a5a5a},\n\t{0x66555555, 0x6a5a5a5a},  \n\t{0x66555555, 0xaaaaaaaa},\n\t{0x66555555, 0x6a5a5aaa},\n\t{0x66555555, 0x6aaa6aaa},\n\t{0x66555555, 0x6a5a5aaa},\n\t{0x66555555, 0xaaaaaaaa},  \n\t{0xffff55ff, 0xfafafafa},\n\t{0xffff55ff, 0x6afa5afa},\n\t{0xaaffffaa, 0xfafafafa},\n\t{0xaa5555aa, 0x5a5a5a5a},\n\t{0xaa5555aa, 0x6a5a5a5a},  \n\t{0xaa5555aa, 0xaaaaaaaa},\n\t{0xffffffff, 0x55555555},\n\t{0xffffffff, 0x5a5a5a5a},\n\t{0xffffffff, 0x5a5a5a5a},\n\t{0xffffffff, 0x5a5a5aaa},  \n\t{0x55555555, 0x5a5a5a5a},\n\t{0x55555555, 0xaaaaaaaa},\n\t{0x66555555, 0x6a5a6a5a},\n\t{0x66556655, 0x66556655},\n\t{0x66556aaa, 0x6a5a6aaa},  \n\t{0xffffffff, 0x5aaa5aaa},\n\t{0x56555555, 0x5a5a5aaa}\n};\n\n \nstatic const struct coex_table_para table_nsant_8821c[] = {\n\t{0xffffffff, 0xffffffff},  \n\t{0xffff55ff, 0xfafafafa},\n\t{0x66555555, 0x66555555},\n\t{0xaaaaaaaa, 0xaaaaaaaa},\n\t{0x5a5a5a5a, 0x5a5a5a5a},\n\t{0xffffffff, 0xffffffff},  \n\t{0x5afa5afa, 0x5afa5afa},\n\t{0x55555555, 0xfafafafa},\n\t{0x66555555, 0xfafafafa},\n\t{0x66555555, 0x5a5a5a5a},\n\t{0x66555555, 0x6a5a5a5a},  \n\t{0x66555555, 0xaaaaaaaa},\n\t{0xffff55ff, 0xfafafafa},\n\t{0xffff55ff, 0x5afa5afa},\n\t{0xffff55ff, 0xaaaaaaaa},\n\t{0xffff55ff, 0xffff55ff},  \n\t{0xaaffffaa, 0x5afa5afa},\n\t{0xaaffffaa, 0xaaaaaaaa},\n\t{0xffffffff, 0xfafafafa},\n\t{0xffff55ff, 0xfafafafa},\n\t{0xffffffff, 0xaaaaaaaa},  \n\t{0xffff55ff, 0x5afa5afa},\n\t{0xffff55ff, 0x5afa5afa},\n\t{0x55ff55ff, 0x55ff55ff}\n};\n\n \nstatic const struct coex_tdma_para tdma_sant_8821c[] = {\n\t{ {0x00, 0x00, 0x00, 0x00, 0x00} },  \n\t{ {0x61, 0x45, 0x03, 0x11, 0x11} },  \n\t{ {0x61, 0x3a, 0x03, 0x11, 0x11} },\n\t{ {0x61, 0x35, 0x03, 0x11, 0x11} },\n\t{ {0x61, 0x20, 0x03, 0x11, 0x11} },\n\t{ {0x61, 0x3a, 0x03, 0x11, 0x11} },  \n\t{ {0x61, 0x45, 0x03, 0x11, 0x10} },\n\t{ {0x61, 0x35, 0x03, 0x11, 0x10} },\n\t{ {0x61, 0x30, 0x03, 0x11, 0x10} },\n\t{ {0x61, 0x20, 0x03, 0x11, 0x10} },\n\t{ {0x61, 0x10, 0x03, 0x11, 0x10} },  \n\t{ {0x61, 0x08, 0x03, 0x11, 0x15} },\n\t{ {0x61, 0x08, 0x03, 0x10, 0x14} },\n\t{ {0x51, 0x08, 0x03, 0x10, 0x54} },\n\t{ {0x51, 0x08, 0x03, 0x10, 0x55} },\n\t{ {0x51, 0x08, 0x07, 0x10, 0x54} },  \n\t{ {0x51, 0x45, 0x03, 0x10, 0x50} },\n\t{ {0x51, 0x3a, 0x03, 0x11, 0x50} },\n\t{ {0x51, 0x30, 0x03, 0x10, 0x50} },\n\t{ {0x51, 0x21, 0x03, 0x10, 0x50} },\n\t{ {0x51, 0x10, 0x03, 0x10, 0x50} },  \n\t{ {0x51, 0x4a, 0x03, 0x10, 0x50} },\n\t{ {0x51, 0x08, 0x03, 0x30, 0x54} },\n\t{ {0x55, 0x08, 0x03, 0x10, 0x54} },\n\t{ {0x65, 0x10, 0x03, 0x11, 0x10} },\n\t{ {0x51, 0x10, 0x03, 0x10, 0x51} },  \n\t{ {0x51, 0x21, 0x03, 0x10, 0x50} },\n\t{ {0x61, 0x08, 0x03, 0x11, 0x11} }\n};\n\n \nstatic const struct coex_tdma_para tdma_nsant_8821c[] = {\n\t{ {0x00, 0x00, 0x00, 0x40, 0x00} },  \n\t{ {0x61, 0x45, 0x03, 0x11, 0x11} },\n\t{ {0x61, 0x25, 0x03, 0x11, 0x11} },\n\t{ {0x61, 0x35, 0x03, 0x11, 0x11} },\n\t{ {0x61, 0x20, 0x03, 0x11, 0x11} },\n\t{ {0x61, 0x10, 0x03, 0x11, 0x11} },  \n\t{ {0x61, 0x45, 0x03, 0x11, 0x10} },\n\t{ {0x61, 0x30, 0x03, 0x11, 0x10} },\n\t{ {0x61, 0x30, 0x03, 0x11, 0x10} },\n\t{ {0x61, 0x20, 0x03, 0x11, 0x10} },\n\t{ {0x61, 0x10, 0x03, 0x11, 0x10} },  \n\t{ {0x61, 0x10, 0x03, 0x11, 0x11} },\n\t{ {0x61, 0x08, 0x03, 0x10, 0x14} },\n\t{ {0x51, 0x08, 0x03, 0x10, 0x54} },\n\t{ {0x51, 0x08, 0x03, 0x10, 0x55} },\n\t{ {0x51, 0x08, 0x07, 0x10, 0x54} },  \n\t{ {0x51, 0x45, 0x03, 0x10, 0x50} },\n\t{ {0x51, 0x3a, 0x03, 0x10, 0x50} },\n\t{ {0x51, 0x30, 0x03, 0x10, 0x50} },\n\t{ {0x51, 0x21, 0x03, 0x10, 0x50} },\n\t{ {0x51, 0x21, 0x03, 0x10, 0x50} },  \n\t{ {0x51, 0x10, 0x03, 0x10, 0x50} }\n};\n\nstatic const struct coex_5g_afh_map afh_5g_8821c[] = { {0, 0, 0} };\n\n \nstatic const struct coex_rf_para rf_para_tx_8821c[] = {\n\t{0, 0, false, 7},   \n\t{0, 20, false, 7},  \n\t{8, 17, true, 4},\n\t{7, 18, true, 4},\n\t{6, 19, true, 4},\n\t{5, 20, true, 4}\n};\n\nstatic const struct coex_rf_para rf_para_rx_8821c[] = {\n\t{0, 0, false, 7},   \n\t{0, 20, false, 7},  \n\t{3, 24, true, 5},\n\t{2, 26, true, 5},\n\t{1, 27, true, 5},\n\t{0, 28, true, 5}\n};\n\nstatic_assert(ARRAY_SIZE(rf_para_tx_8821c) == ARRAY_SIZE(rf_para_rx_8821c));\n\nstatic const u8 rtw8821c_pwrtrk_5gb_n[][RTW_PWR_TRK_TBL_SZ] = {\n\t{0, 1, 1, 2, 3, 3, 3, 4, 4, 5, 5, 6, 6, 6, 7, 8, 8, 8, 9, 9, 9, 10, 10,\n\t 11, 11, 12, 12, 12, 12, 12},\n\t{0, 1, 1, 1, 2, 3, 3, 4, 4, 5, 5, 5, 6, 6, 7, 8, 8, 9, 9, 10, 10, 11,\n\t 11, 12, 12, 12, 12, 12, 12, 12},\n\t{0, 1, 2, 2, 3, 4, 4, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 9, 10, 10, 11,\n\t 11, 12, 12, 12, 12, 12, 12},\n};\n\nstatic const u8 rtw8821c_pwrtrk_5gb_p[][RTW_PWR_TRK_TBL_SZ] = {\n\t{0, 1, 1, 2, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 11, 11,\n\t 12, 12, 12, 12, 12, 12, 12},\n\t{0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 5, 6, 7, 7, 8, 8, 9, 10, 10, 11, 11,\n\t 12, 12, 12, 12, 12, 12, 12, 12},\n\t{0, 1, 1, 1, 2, 3, 3, 3, 4, 4, 4, 5, 6, 6, 7, 7, 8, 8, 9, 10, 10, 11,\n\t 11, 12, 12, 12, 12, 12, 12, 12},\n};\n\nstatic const u8 rtw8821c_pwrtrk_5ga_n[][RTW_PWR_TRK_TBL_SZ] = {\n\t{0, 1, 1, 2, 3, 3, 3, 4, 4, 5, 5, 6, 6, 6, 7, 8, 8, 8, 9, 9, 9, 10, 10,\n\t 11, 11, 12, 12, 12, 12, 12},\n\t{0, 1, 1, 1, 2, 3, 3, 4, 4, 5, 5, 5, 6, 6, 7, 8, 8, 9, 9, 10, 10, 11,\n\t 11, 12, 12, 12, 12, 12, 12, 12},\n\t{0, 1, 2, 2, 3, 4, 4, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 9, 10, 10, 11,\n\t 11, 12, 12, 12, 12, 12, 12},\n};\n\nstatic const u8 rtw8821c_pwrtrk_5ga_p[][RTW_PWR_TRK_TBL_SZ] = {\n\t{0, 1, 1, 2, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 11, 11,\n\t 12, 12, 12, 12, 12, 12, 12},\n\t{0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 5, 6, 7, 7, 8, 8, 9, 10, 10, 11, 11,\n\t 12, 12, 12, 12, 12, 12, 12, 12},\n\t{0, 1, 1, 1, 2, 3, 3, 3, 4, 4, 4, 5, 6, 6, 7, 7, 8, 8, 9, 10, 10, 11,\n\t 11, 12, 12, 12, 12, 12, 12, 12},\n};\n\nstatic const u8 rtw8821c_pwrtrk_2gb_n[] = {\n\t0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4,\n\t4, 4, 5, 5, 5, 5, 6, 6, 6, 7, 7, 8, 8, 9\n};\n\nstatic const u8 rtw8821c_pwrtrk_2gb_p[] = {\n\t0, 1, 1, 1, 1, 2, 2, 2, 3, 3, 3, 3, 4, 4, 5, 5,\n\t5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 9, 9, 9, 9\n};\n\nstatic const u8 rtw8821c_pwrtrk_2ga_n[] = {\n\t0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4,\n\t4, 4, 5, 5, 5, 5, 6, 6, 6, 7, 7, 8, 8, 9\n};\n\nstatic const u8 rtw8821c_pwrtrk_2ga_p[] = {\n\t0, 1, 1, 1, 1, 2, 2, 2, 3, 3, 3, 3, 4, 4, 5, 5,\n\t5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 9, 9, 9, 9\n};\n\nstatic const u8 rtw8821c_pwrtrk_2g_cck_b_n[] = {\n\t0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4,\n\t4, 5, 5, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 9\n};\n\nstatic const u8 rtw8821c_pwrtrk_2g_cck_b_p[] = {\n\t0, 1, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5,\n\t5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 9, 9, 9, 9\n};\n\nstatic const u8 rtw8821c_pwrtrk_2g_cck_a_n[] = {\n\t0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4,\n\t4, 5, 5, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 9\n};\n\nstatic const u8 rtw8821c_pwrtrk_2g_cck_a_p[] = {\n\t0, 1, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5,\n\t5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 9, 9, 9, 9\n};\n\nstatic const struct rtw_pwr_track_tbl rtw8821c_rtw_pwr_track_tbl = {\n\t.pwrtrk_5gb_n[0] = rtw8821c_pwrtrk_5gb_n[0],\n\t.pwrtrk_5gb_n[1] = rtw8821c_pwrtrk_5gb_n[1],\n\t.pwrtrk_5gb_n[2] = rtw8821c_pwrtrk_5gb_n[2],\n\t.pwrtrk_5gb_p[0] = rtw8821c_pwrtrk_5gb_p[0],\n\t.pwrtrk_5gb_p[1] = rtw8821c_pwrtrk_5gb_p[1],\n\t.pwrtrk_5gb_p[2] = rtw8821c_pwrtrk_5gb_p[2],\n\t.pwrtrk_5ga_n[0] = rtw8821c_pwrtrk_5ga_n[0],\n\t.pwrtrk_5ga_n[1] = rtw8821c_pwrtrk_5ga_n[1],\n\t.pwrtrk_5ga_n[2] = rtw8821c_pwrtrk_5ga_n[2],\n\t.pwrtrk_5ga_p[0] = rtw8821c_pwrtrk_5ga_p[0],\n\t.pwrtrk_5ga_p[1] = rtw8821c_pwrtrk_5ga_p[1],\n\t.pwrtrk_5ga_p[2] = rtw8821c_pwrtrk_5ga_p[2],\n\t.pwrtrk_2gb_n = rtw8821c_pwrtrk_2gb_n,\n\t.pwrtrk_2gb_p = rtw8821c_pwrtrk_2gb_p,\n\t.pwrtrk_2ga_n = rtw8821c_pwrtrk_2ga_n,\n\t.pwrtrk_2ga_p = rtw8821c_pwrtrk_2ga_p,\n\t.pwrtrk_2g_cckb_n = rtw8821c_pwrtrk_2g_cck_b_n,\n\t.pwrtrk_2g_cckb_p = rtw8821c_pwrtrk_2g_cck_b_p,\n\t.pwrtrk_2g_ccka_n = rtw8821c_pwrtrk_2g_cck_a_n,\n\t.pwrtrk_2g_ccka_p = rtw8821c_pwrtrk_2g_cck_a_p,\n};\n\nstatic const struct rtw_reg_domain coex_info_hw_regs_8821c[] = {\n\t{0xCB0, MASKDWORD, RTW_REG_DOMAIN_MAC32},\n\t{0xCB4, MASKDWORD, RTW_REG_DOMAIN_MAC32},\n\t{0xCBA, MASKBYTE0, RTW_REG_DOMAIN_MAC8},\n\t{0, 0, RTW_REG_DOMAIN_NL},\n\t{0x430, MASKDWORD, RTW_REG_DOMAIN_MAC32},\n\t{0x434, MASKDWORD, RTW_REG_DOMAIN_MAC32},\n\t{0x42a, MASKLWORD, RTW_REG_DOMAIN_MAC16},\n\t{0x426, MASKBYTE0, RTW_REG_DOMAIN_MAC8},\n\t{0x45e, BIT(3), RTW_REG_DOMAIN_MAC8},\n\t{0x454, MASKLWORD, RTW_REG_DOMAIN_MAC16},\n\t{0, 0, RTW_REG_DOMAIN_NL},\n\t{0x4c, BIT(24) | BIT(23), RTW_REG_DOMAIN_MAC32},\n\t{0x64, BIT(0), RTW_REG_DOMAIN_MAC8},\n\t{0x4c6, BIT(4), RTW_REG_DOMAIN_MAC8},\n\t{0x40, BIT(5), RTW_REG_DOMAIN_MAC8},\n\t{0x1, RFREG_MASK, RTW_REG_DOMAIN_RF_A},\n\t{0, 0, RTW_REG_DOMAIN_NL},\n\t{0x550, MASKDWORD, RTW_REG_DOMAIN_MAC32},\n\t{0x522, MASKBYTE0, RTW_REG_DOMAIN_MAC8},\n\t{0x953, BIT(1), RTW_REG_DOMAIN_MAC8},\n\t{0xc50,  MASKBYTE0, RTW_REG_DOMAIN_MAC8},\n\t{0x60A, MASKBYTE0, RTW_REG_DOMAIN_MAC8},\n};\n\nconst struct rtw_chip_info rtw8821c_hw_spec = {\n\t.ops = &rtw8821c_ops,\n\t.id = RTW_CHIP_TYPE_8821C,\n\t.fw_name = \"rtw88/rtw8821c_fw.bin\",\n\t.wlan_cpu = RTW_WCPU_11AC,\n\t.tx_pkt_desc_sz = 48,\n\t.tx_buf_desc_sz = 16,\n\t.rx_pkt_desc_sz = 24,\n\t.rx_buf_desc_sz = 8,\n\t.phy_efuse_size = 512,\n\t.log_efuse_size = 512,\n\t.ptct_efuse_size = 96,\n\t.txff_size = 65536,\n\t.rxff_size = 16384,\n\t.rsvd_drv_pg_num = 8,\n\t.txgi_factor = 1,\n\t.is_pwr_by_rate_dec = true,\n\t.max_power_index = 0x3f,\n\t.csi_buf_pg_num = 0,\n\t.band = RTW_BAND_2G | RTW_BAND_5G,\n\t.page_size = TX_PAGE_SIZE,\n\t.dig_min = 0x1c,\n\t.ht_supported = true,\n\t.vht_supported = true,\n\t.lps_deep_mode_supported = BIT(LPS_DEEP_MODE_LCLK),\n\t.sys_func_en = 0xD8,\n\t.pwr_on_seq = card_enable_flow_8821c,\n\t.pwr_off_seq = card_disable_flow_8821c,\n\t.page_table = page_table_8821c,\n\t.rqpn_table = rqpn_table_8821c,\n\t.prioq_addrs = &prioq_addrs_8821c,\n\t.intf_table = &phy_para_table_8821c,\n\t.dig = rtw8821c_dig,\n\t.rf_base_addr = {0x2800, 0x2c00},\n\t.rf_sipi_addr = {0xc90, 0xe90},\n\t.ltecoex_addr = &rtw8821c_ltecoex_addr,\n\t.mac_tbl = &rtw8821c_mac_tbl,\n\t.agc_tbl = &rtw8821c_agc_tbl,\n\t.bb_tbl = &rtw8821c_bb_tbl,\n\t.rf_tbl = {&rtw8821c_rf_a_tbl},\n\t.rfe_defs = rtw8821c_rfe_defs,\n\t.rfe_defs_size = ARRAY_SIZE(rtw8821c_rfe_defs),\n\t.rx_ldpc = false,\n\t.pwr_track_tbl = &rtw8821c_rtw_pwr_track_tbl,\n\t.iqk_threshold = 8,\n\t.bfer_su_max_num = 2,\n\t.bfer_mu_max_num = 1,\n\t.ampdu_density = IEEE80211_HT_MPDU_DENSITY_2,\n\t.max_scan_ie_len = IEEE80211_MAX_DATA_LEN,\n\n\t.coex_para_ver = 0x19092746,\n\t.bt_desired_ver = 0x46,\n\t.scbd_support = true,\n\t.new_scbd10_def = false,\n\t.ble_hid_profile_support = false,\n\t.wl_mimo_ps_support = false,\n\t.pstdma_type = COEX_PSTDMA_FORCE_LPSOFF,\n\t.bt_rssi_type = COEX_BTRSSI_RATIO,\n\t.ant_isolation = 15,\n\t.rssi_tolerance = 2,\n\t.wl_rssi_step = wl_rssi_step_8821c,\n\t.bt_rssi_step = bt_rssi_step_8821c,\n\t.table_sant_num = ARRAY_SIZE(table_sant_8821c),\n\t.table_sant = table_sant_8821c,\n\t.table_nsant_num = ARRAY_SIZE(table_nsant_8821c),\n\t.table_nsant = table_nsant_8821c,\n\t.tdma_sant_num = ARRAY_SIZE(tdma_sant_8821c),\n\t.tdma_sant = tdma_sant_8821c,\n\t.tdma_nsant_num = ARRAY_SIZE(tdma_nsant_8821c),\n\t.tdma_nsant = tdma_nsant_8821c,\n\t.wl_rf_para_num = ARRAY_SIZE(rf_para_tx_8821c),\n\t.wl_rf_para_tx = rf_para_tx_8821c,\n\t.wl_rf_para_rx = rf_para_rx_8821c,\n\t.bt_afh_span_bw20 = 0x24,\n\t.bt_afh_span_bw40 = 0x36,\n\t.afh_5g_num = ARRAY_SIZE(afh_5g_8821c),\n\t.afh_5g = afh_5g_8821c,\n\n\t.coex_info_hw_regs_num = ARRAY_SIZE(coex_info_hw_regs_8821c),\n\t.coex_info_hw_regs = coex_info_hw_regs_8821c,\n};\nEXPORT_SYMBOL(rtw8821c_hw_spec);\n\nMODULE_FIRMWARE(\"rtw88/rtw8821c_fw.bin\");\n\nMODULE_AUTHOR(\"Realtek Corporation\");\nMODULE_DESCRIPTION(\"Realtek 802.11ac wireless 8821c driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}