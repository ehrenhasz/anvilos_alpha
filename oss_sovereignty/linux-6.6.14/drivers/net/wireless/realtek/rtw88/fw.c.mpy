{
  "module_name": "fw.c",
  "hash_id": "aad4c6c71aef109eb56bac5461a979e538afb430258c3ced6126639070a5a21c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtw88/fw.c",
  "human_readable_source": "\n \n\n#include <linux/iopoll.h>\n\n#include \"main.h\"\n#include \"coex.h\"\n#include \"fw.h\"\n#include \"tx.h\"\n#include \"reg.h\"\n#include \"sec.h\"\n#include \"debug.h\"\n#include \"util.h\"\n#include \"wow.h\"\n#include \"ps.h\"\n#include \"phy.h\"\n#include \"mac.h\"\n\nstatic void rtw_fw_c2h_cmd_handle_ext(struct rtw_dev *rtwdev,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct rtw_c2h_cmd *c2h;\n\tu8 sub_cmd_id;\n\n\tc2h = get_c2h_from_skb(skb);\n\tsub_cmd_id = c2h->payload[0];\n\n\tswitch (sub_cmd_id) {\n\tcase C2H_CCX_RPT:\n\t\trtw_tx_report_handle(rtwdev, skb, C2H_CCX_RPT);\n\t\tbreak;\n\tcase C2H_SCAN_STATUS_RPT:\n\t\trtw_hw_scan_status_report(rtwdev, skb);\n\t\tbreak;\n\tcase C2H_CHAN_SWITCH:\n\t\trtw_hw_scan_chan_switch(rtwdev, skb);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic u16 get_max_amsdu_len(u32 bit_rate)\n{\n\t \n\tif (bit_rate < 550)\n\t\treturn 1;\n\n\t \n\tif (bit_rate < 1800)\n\t\treturn 1200;\n\n\t \n\tif (bit_rate < 4000)\n\t\treturn 2600;\n\n\t \n\tif (bit_rate < 7000)\n\t\treturn 3500;\n\n\t \n\treturn 0;\n}\n\nstruct rtw_fw_iter_ra_data {\n\tstruct rtw_dev *rtwdev;\n\tu8 *payload;\n};\n\nstatic void rtw_fw_ra_report_iter(void *data, struct ieee80211_sta *sta)\n{\n\tstruct rtw_fw_iter_ra_data *ra_data = data;\n\tstruct rtw_sta_info *si = (struct rtw_sta_info *)sta->drv_priv;\n\tu8 mac_id, rate, sgi, bw;\n\tu8 mcs, nss;\n\tu32 bit_rate;\n\n\tmac_id = GET_RA_REPORT_MACID(ra_data->payload);\n\tif (si->mac_id != mac_id)\n\t\treturn;\n\n\tsi->ra_report.txrate.flags = 0;\n\n\trate = GET_RA_REPORT_RATE(ra_data->payload);\n\tsgi = GET_RA_REPORT_SGI(ra_data->payload);\n\tbw = GET_RA_REPORT_BW(ra_data->payload);\n\n\tif (rate < DESC_RATEMCS0) {\n\t\tsi->ra_report.txrate.legacy = rtw_desc_to_bitrate(rate);\n\t\tgoto legacy;\n\t}\n\n\trtw_desc_to_mcsrate(rate, &mcs, &nss);\n\tif (rate >= DESC_RATEVHT1SS_MCS0)\n\t\tsi->ra_report.txrate.flags |= RATE_INFO_FLAGS_VHT_MCS;\n\telse if (rate >= DESC_RATEMCS0)\n\t\tsi->ra_report.txrate.flags |= RATE_INFO_FLAGS_MCS;\n\n\tif (rate >= DESC_RATEMCS0) {\n\t\tsi->ra_report.txrate.mcs = mcs;\n\t\tsi->ra_report.txrate.nss = nss;\n\t}\n\n\tif (sgi)\n\t\tsi->ra_report.txrate.flags |= RATE_INFO_FLAGS_SHORT_GI;\n\n\tif (bw == RTW_CHANNEL_WIDTH_80)\n\t\tsi->ra_report.txrate.bw = RATE_INFO_BW_80;\n\telse if (bw == RTW_CHANNEL_WIDTH_40)\n\t\tsi->ra_report.txrate.bw = RATE_INFO_BW_40;\n\telse\n\t\tsi->ra_report.txrate.bw = RATE_INFO_BW_20;\n\nlegacy:\n\tbit_rate = cfg80211_calculate_bitrate(&si->ra_report.txrate);\n\n\tsi->ra_report.desc_rate = rate;\n\tsi->ra_report.bit_rate = bit_rate;\n\n\tsta->deflink.agg.max_rc_amsdu_len = get_max_amsdu_len(bit_rate);\n}\n\nstatic void rtw_fw_ra_report_handle(struct rtw_dev *rtwdev, u8 *payload,\n\t\t\t\t    u8 length)\n{\n\tstruct rtw_fw_iter_ra_data ra_data;\n\n\tif (WARN(length < 7, \"invalid ra report c2h length\\n\"))\n\t\treturn;\n\n\trtwdev->dm_info.tx_rate = GET_RA_REPORT_RATE(payload);\n\tra_data.rtwdev = rtwdev;\n\tra_data.payload = payload;\n\trtw_iterate_stas_atomic(rtwdev, rtw_fw_ra_report_iter, &ra_data);\n}\n\nstruct rtw_beacon_filter_iter_data {\n\tstruct rtw_dev *rtwdev;\n\tu8 *payload;\n};\n\nstatic void rtw_fw_bcn_filter_notify_vif_iter(void *data,\n\t\t\t\t\t      struct ieee80211_vif *vif)\n{\n\tstruct rtw_beacon_filter_iter_data *iter_data = data;\n\tstruct rtw_dev *rtwdev = iter_data->rtwdev;\n\tu8 *payload = iter_data->payload;\n\tu8 type = GET_BCN_FILTER_NOTIFY_TYPE(payload);\n\tu8 event = GET_BCN_FILTER_NOTIFY_EVENT(payload);\n\ts8 sig = (s8)GET_BCN_FILTER_NOTIFY_RSSI(payload);\n\n\tswitch (type) {\n\tcase BCN_FILTER_NOTIFY_SIGNAL_CHANGE:\n\t\tevent = event ? NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH :\n\t\t\tNL80211_CQM_RSSI_THRESHOLD_EVENT_LOW;\n\t\tieee80211_cqm_rssi_notify(vif, event, sig, GFP_KERNEL);\n\t\tbreak;\n\tcase BCN_FILTER_CONNECTION_LOSS:\n\t\tieee80211_connection_loss(vif);\n\t\tbreak;\n\tcase BCN_FILTER_CONNECTED:\n\t\trtwdev->beacon_loss = false;\n\t\tbreak;\n\tcase BCN_FILTER_NOTIFY_BEACON_LOSS:\n\t\trtwdev->beacon_loss = true;\n\t\trtw_leave_lps(rtwdev);\n\t\tbreak;\n\t}\n}\n\nstatic void rtw_fw_bcn_filter_notify(struct rtw_dev *rtwdev, u8 *payload,\n\t\t\t\t     u8 length)\n{\n\tstruct rtw_beacon_filter_iter_data dev_iter_data;\n\n\tdev_iter_data.rtwdev = rtwdev;\n\tdev_iter_data.payload = payload;\n\trtw_iterate_vifs(rtwdev, rtw_fw_bcn_filter_notify_vif_iter,\n\t\t\t &dev_iter_data);\n}\n\nstatic void rtw_fw_scan_result(struct rtw_dev *rtwdev, u8 *payload,\n\t\t\t       u8 length)\n{\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\n\tdm_info->scan_density = payload[0];\n\n\trtw_dbg(rtwdev, RTW_DBG_FW, \"scan.density = %x\\n\",\n\t\tdm_info->scan_density);\n}\n\nstatic void rtw_fw_adaptivity_result(struct rtw_dev *rtwdev, u8 *payload,\n\t\t\t\t     u8 length)\n{\n\tstruct rtw_hw_reg_offset *edcca_th = rtwdev->chip->edcca_th;\n\tstruct rtw_c2h_adaptivity *result = (struct rtw_c2h_adaptivity *)payload;\n\n\trtw_dbg(rtwdev, RTW_DBG_ADAPTIVITY,\n\t\t\"Adaptivity: density %x igi %x l2h_th_init %x l2h %x h2l %x option %x\\n\",\n\t\tresult->density, result->igi, result->l2h_th_init, result->l2h,\n\t\tresult->h2l, result->option);\n\n\trtw_dbg(rtwdev, RTW_DBG_ADAPTIVITY, \"Reg Setting: L2H %x H2L %x\\n\",\n\t\trtw_read32_mask(rtwdev, edcca_th[EDCCA_TH_L2H_IDX].hw_reg.addr,\n\t\t\t\tedcca_th[EDCCA_TH_L2H_IDX].hw_reg.mask),\n\t\trtw_read32_mask(rtwdev, edcca_th[EDCCA_TH_H2L_IDX].hw_reg.addr,\n\t\t\t\tedcca_th[EDCCA_TH_H2L_IDX].hw_reg.mask));\n\n\trtw_dbg(rtwdev, RTW_DBG_ADAPTIVITY, \"EDCCA Flag %s\\n\",\n\t\trtw_read32_mask(rtwdev, REG_EDCCA_REPORT, BIT_EDCCA_FLAG) ?\n\t\t\"Set\" : \"Unset\");\n}\n\nvoid rtw_fw_c2h_cmd_handle(struct rtw_dev *rtwdev, struct sk_buff *skb)\n{\n\tstruct rtw_c2h_cmd *c2h;\n\tu32 pkt_offset;\n\tu8 len;\n\n\tpkt_offset = *((u32 *)skb->cb);\n\tc2h = (struct rtw_c2h_cmd *)(skb->data + pkt_offset);\n\tlen = skb->len - pkt_offset - 2;\n\n\tmutex_lock(&rtwdev->mutex);\n\n\tif (!test_bit(RTW_FLAG_RUNNING, rtwdev->flags))\n\t\tgoto unlock;\n\n\tswitch (c2h->id) {\n\tcase C2H_CCX_TX_RPT:\n\t\trtw_tx_report_handle(rtwdev, skb, C2H_CCX_TX_RPT);\n\t\tbreak;\n\tcase C2H_BT_INFO:\n\t\trtw_coex_bt_info_notify(rtwdev, c2h->payload, len);\n\t\tbreak;\n\tcase C2H_BT_HID_INFO:\n\t\trtw_coex_bt_hid_info_notify(rtwdev, c2h->payload, len);\n\t\tbreak;\n\tcase C2H_WLAN_INFO:\n\t\trtw_coex_wl_fwdbginfo_notify(rtwdev, c2h->payload, len);\n\t\tbreak;\n\tcase C2H_BCN_FILTER_NOTIFY:\n\t\trtw_fw_bcn_filter_notify(rtwdev, c2h->payload, len);\n\t\tbreak;\n\tcase C2H_HALMAC:\n\t\trtw_fw_c2h_cmd_handle_ext(rtwdev, skb);\n\t\tbreak;\n\tcase C2H_RA_RPT:\n\t\trtw_fw_ra_report_handle(rtwdev, c2h->payload, len);\n\t\tbreak;\n\tdefault:\n\t\trtw_dbg(rtwdev, RTW_DBG_FW, \"C2H 0x%x isn't handled\\n\", c2h->id);\n\t\tbreak;\n\t}\n\nunlock:\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nvoid rtw_fw_c2h_cmd_rx_irqsafe(struct rtw_dev *rtwdev, u32 pkt_offset,\n\t\t\t       struct sk_buff *skb)\n{\n\tstruct rtw_c2h_cmd *c2h;\n\tu8 len;\n\n\tc2h = (struct rtw_c2h_cmd *)(skb->data + pkt_offset);\n\tlen = skb->len - pkt_offset - 2;\n\t*((u32 *)skb->cb) = pkt_offset;\n\n\trtw_dbg(rtwdev, RTW_DBG_FW, \"recv C2H, id=0x%02x, seq=0x%02x, len=%d\\n\",\n\t\tc2h->id, c2h->seq, len);\n\n\tswitch (c2h->id) {\n\tcase C2H_BT_MP_INFO:\n\t\trtw_coex_info_response(rtwdev, skb);\n\t\tbreak;\n\tcase C2H_WLAN_RFON:\n\t\tcomplete(&rtwdev->lps_leave_check);\n\t\tdev_kfree_skb_any(skb);\n\t\tbreak;\n\tcase C2H_SCAN_RESULT:\n\t\tcomplete(&rtwdev->fw_scan_density);\n\t\trtw_fw_scan_result(rtwdev, c2h->payload, len);\n\t\tdev_kfree_skb_any(skb);\n\t\tbreak;\n\tcase C2H_ADAPTIVITY:\n\t\trtw_fw_adaptivity_result(rtwdev, c2h->payload, len);\n\t\tdev_kfree_skb_any(skb);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\t*((u32 *)skb->cb) = pkt_offset;\n\t\tskb_queue_tail(&rtwdev->c2h_queue, skb);\n\t\tieee80211_queue_work(rtwdev->hw, &rtwdev->c2h_work);\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL(rtw_fw_c2h_cmd_rx_irqsafe);\n\nvoid rtw_fw_c2h_cmd_isr(struct rtw_dev *rtwdev)\n{\n\tif (rtw_read8(rtwdev, REG_MCU_TST_CFG) == VAL_FW_TRIGGER)\n\t\trtw_fw_recovery(rtwdev);\n\telse\n\t\trtw_warn(rtwdev, \"unhandled firmware c2h interrupt\\n\");\n}\nEXPORT_SYMBOL(rtw_fw_c2h_cmd_isr);\n\nstatic void rtw_fw_send_h2c_command_register(struct rtw_dev *rtwdev,\n\t\t\t\t\t     struct rtw_h2c_register *h2c)\n{\n\tu32 box_reg, box_ex_reg;\n\tu8 box_state, box;\n\tint ret;\n\n\trtw_dbg(rtwdev, RTW_DBG_FW, \"send H2C content %08x %08x\\n\", h2c->w0,\n\t\th2c->w1);\n\n\tlockdep_assert_held(&rtwdev->mutex);\n\n\tbox = rtwdev->h2c.last_box_num;\n\tswitch (box) {\n\tcase 0:\n\t\tbox_reg = REG_HMEBOX0;\n\t\tbox_ex_reg = REG_HMEBOX0_EX;\n\t\tbreak;\n\tcase 1:\n\t\tbox_reg = REG_HMEBOX1;\n\t\tbox_ex_reg = REG_HMEBOX1_EX;\n\t\tbreak;\n\tcase 2:\n\t\tbox_reg = REG_HMEBOX2;\n\t\tbox_ex_reg = REG_HMEBOX2_EX;\n\t\tbreak;\n\tcase 3:\n\t\tbox_reg = REG_HMEBOX3;\n\t\tbox_ex_reg = REG_HMEBOX3_EX;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"invalid h2c mail box number\\n\");\n\t\treturn;\n\t}\n\n\tret = read_poll_timeout_atomic(rtw_read8, box_state,\n\t\t\t\t       !((box_state >> box) & 0x1), 100, 3000,\n\t\t\t\t       false, rtwdev, REG_HMETFR);\n\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to send h2c command\\n\");\n\t\treturn;\n\t}\n\n\trtw_write32(rtwdev, box_ex_reg, h2c->w1);\n\trtw_write32(rtwdev, box_reg, h2c->w0);\n\n\tif (++rtwdev->h2c.last_box_num >= 4)\n\t\trtwdev->h2c.last_box_num = 0;\n}\n\nstatic void rtw_fw_send_h2c_command(struct rtw_dev *rtwdev,\n\t\t\t\t    u8 *h2c)\n{\n\tstruct rtw_h2c_cmd *h2c_cmd = (struct rtw_h2c_cmd *)h2c;\n\tu8 box;\n\tu8 box_state;\n\tu32 box_reg, box_ex_reg;\n\tint ret;\n\n\trtw_dbg(rtwdev, RTW_DBG_FW,\n\t\t\"send H2C content %02x%02x%02x%02x %02x%02x%02x%02x\\n\",\n\t\th2c[3], h2c[2], h2c[1], h2c[0],\n\t\th2c[7], h2c[6], h2c[5], h2c[4]);\n\n\tlockdep_assert_held(&rtwdev->mutex);\n\n\tbox = rtwdev->h2c.last_box_num;\n\tswitch (box) {\n\tcase 0:\n\t\tbox_reg = REG_HMEBOX0;\n\t\tbox_ex_reg = REG_HMEBOX0_EX;\n\t\tbreak;\n\tcase 1:\n\t\tbox_reg = REG_HMEBOX1;\n\t\tbox_ex_reg = REG_HMEBOX1_EX;\n\t\tbreak;\n\tcase 2:\n\t\tbox_reg = REG_HMEBOX2;\n\t\tbox_ex_reg = REG_HMEBOX2_EX;\n\t\tbreak;\n\tcase 3:\n\t\tbox_reg = REG_HMEBOX3;\n\t\tbox_ex_reg = REG_HMEBOX3_EX;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"invalid h2c mail box number\\n\");\n\t\treturn;\n\t}\n\n\tret = read_poll_timeout_atomic(rtw_read8, box_state,\n\t\t\t\t       !((box_state >> box) & 0x1), 100, 3000,\n\t\t\t\t       false, rtwdev, REG_HMETFR);\n\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to send h2c command\\n\");\n\t\treturn;\n\t}\n\n\trtw_write32(rtwdev, box_ex_reg, le32_to_cpu(h2c_cmd->msg_ext));\n\trtw_write32(rtwdev, box_reg, le32_to_cpu(h2c_cmd->msg));\n\n\tif (++rtwdev->h2c.last_box_num >= 4)\n\t\trtwdev->h2c.last_box_num = 0;\n}\n\nvoid rtw_fw_h2c_cmd_dbg(struct rtw_dev *rtwdev, u8 *h2c)\n{\n\trtw_fw_send_h2c_command(rtwdev, h2c);\n}\n\nstatic void rtw_fw_send_h2c_packet(struct rtw_dev *rtwdev, u8 *h2c_pkt)\n{\n\tint ret;\n\n\tlockdep_assert_held(&rtwdev->mutex);\n\n\tFW_OFFLOAD_H2C_SET_SEQ_NUM(h2c_pkt, rtwdev->h2c.seq);\n\tret = rtw_hci_write_data_h2c(rtwdev, h2c_pkt, H2C_PKT_SIZE);\n\tif (ret)\n\t\trtw_err(rtwdev, \"failed to send h2c packet\\n\");\n\trtwdev->h2c.seq++;\n}\n\nvoid\nrtw_fw_send_general_info(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_fifo_conf *fifo = &rtwdev->fifo;\n\tu8 h2c_pkt[H2C_PKT_SIZE] = {0};\n\tu16 total_size = H2C_PKT_HDR_SIZE + 4;\n\n\tif (rtw_chip_wcpu_11n(rtwdev))\n\t\treturn;\n\n\trtw_h2c_pkt_set_header(h2c_pkt, H2C_PKT_GENERAL_INFO);\n\n\tSET_PKT_H2C_TOTAL_LEN(h2c_pkt, total_size);\n\n\tGENERAL_INFO_SET_FW_TX_BOUNDARY(h2c_pkt,\n\t\t\t\t\tfifo->rsvd_fw_txbuf_addr -\n\t\t\t\t\tfifo->rsvd_boundary);\n\n\trtw_fw_send_h2c_packet(rtwdev, h2c_pkt);\n}\n\nvoid\nrtw_fw_send_phydm_info(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_hal *hal = &rtwdev->hal;\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\tu8 h2c_pkt[H2C_PKT_SIZE] = {0};\n\tu16 total_size = H2C_PKT_HDR_SIZE + 8;\n\tu8 fw_rf_type = 0;\n\n\tif (rtw_chip_wcpu_11n(rtwdev))\n\t\treturn;\n\n\tif (hal->rf_type == RF_1T1R)\n\t\tfw_rf_type = FW_RF_1T1R;\n\telse if (hal->rf_type == RF_2T2R)\n\t\tfw_rf_type = FW_RF_2T2R;\n\n\trtw_h2c_pkt_set_header(h2c_pkt, H2C_PKT_PHYDM_INFO);\n\n\tSET_PKT_H2C_TOTAL_LEN(h2c_pkt, total_size);\n\tPHYDM_INFO_SET_REF_TYPE(h2c_pkt, efuse->rfe_option);\n\tPHYDM_INFO_SET_RF_TYPE(h2c_pkt, fw_rf_type);\n\tPHYDM_INFO_SET_CUT_VER(h2c_pkt, hal->cut_version);\n\tPHYDM_INFO_SET_RX_ANT_STATUS(h2c_pkt, hal->antenna_tx);\n\tPHYDM_INFO_SET_TX_ANT_STATUS(h2c_pkt, hal->antenna_rx);\n\n\trtw_fw_send_h2c_packet(rtwdev, h2c_pkt);\n}\n\nvoid rtw_fw_do_iqk(struct rtw_dev *rtwdev, struct rtw_iqk_para *para)\n{\n\tu8 h2c_pkt[H2C_PKT_SIZE] = {0};\n\tu16 total_size = H2C_PKT_HDR_SIZE + 1;\n\n\trtw_h2c_pkt_set_header(h2c_pkt, H2C_PKT_IQK);\n\tSET_PKT_H2C_TOTAL_LEN(h2c_pkt, total_size);\n\tIQK_SET_CLEAR(h2c_pkt, para->clear);\n\tIQK_SET_SEGMENT_IQK(h2c_pkt, para->segment_iqk);\n\n\trtw_fw_send_h2c_packet(rtwdev, h2c_pkt);\n}\nEXPORT_SYMBOL(rtw_fw_do_iqk);\n\nvoid rtw_fw_inform_rfk_status(struct rtw_dev *rtwdev, bool start)\n{\n\tu8 h2c_pkt[H2C_PKT_SIZE] = {0};\n\n\tSET_H2C_CMD_ID_CLASS(h2c_pkt, H2C_CMD_WIFI_CALIBRATION);\n\n\tRFK_SET_INFORM_START(h2c_pkt, start);\n\n\trtw_fw_send_h2c_command(rtwdev, h2c_pkt);\n}\nEXPORT_SYMBOL(rtw_fw_inform_rfk_status);\n\nvoid rtw_fw_query_bt_info(struct rtw_dev *rtwdev)\n{\n\tu8 h2c_pkt[H2C_PKT_SIZE] = {0};\n\n\tSET_H2C_CMD_ID_CLASS(h2c_pkt, H2C_CMD_QUERY_BT_INFO);\n\n\tSET_QUERY_BT_INFO(h2c_pkt, true);\n\n\trtw_fw_send_h2c_command(rtwdev, h2c_pkt);\n}\n\nvoid rtw_fw_default_port(struct rtw_dev *rtwdev, struct rtw_vif *rtwvif)\n{\n\tstruct rtw_h2c_register h2c = {};\n\n\tif (rtwvif->net_type != RTW_NET_MGD_LINKED)\n\t\treturn;\n\n\t \n\trtw_leave_lps(rtwdev);\n\n\th2c.w0 = u32_encode_bits(H2C_CMD_DEFAULT_PORT, RTW_H2C_W0_CMDID) |\n\t\t u32_encode_bits(rtwvif->port, RTW_H2C_DEFAULT_PORT_W0_PORTID) |\n\t\t u32_encode_bits(rtwvif->mac_id, RTW_H2C_DEFAULT_PORT_W0_MACID);\n\n\trtw_fw_send_h2c_command_register(rtwdev, &h2c);\n}\n\nvoid rtw_fw_wl_ch_info(struct rtw_dev *rtwdev, u8 link, u8 ch, u8 bw)\n{\n\tu8 h2c_pkt[H2C_PKT_SIZE] = {0};\n\n\tSET_H2C_CMD_ID_CLASS(h2c_pkt, H2C_CMD_WL_CH_INFO);\n\n\tSET_WL_CH_INFO_LINK(h2c_pkt, link);\n\tSET_WL_CH_INFO_CHNL(h2c_pkt, ch);\n\tSET_WL_CH_INFO_BW(h2c_pkt, bw);\n\n\trtw_fw_send_h2c_command(rtwdev, h2c_pkt);\n}\n\nvoid rtw_fw_query_bt_mp_info(struct rtw_dev *rtwdev,\n\t\t\t     struct rtw_coex_info_req *req)\n{\n\tu8 h2c_pkt[H2C_PKT_SIZE] = {0};\n\n\tSET_H2C_CMD_ID_CLASS(h2c_pkt, H2C_CMD_QUERY_BT_MP_INFO);\n\n\tSET_BT_MP_INFO_SEQ(h2c_pkt, req->seq);\n\tSET_BT_MP_INFO_OP_CODE(h2c_pkt, req->op_code);\n\tSET_BT_MP_INFO_PARA1(h2c_pkt, req->para1);\n\tSET_BT_MP_INFO_PARA2(h2c_pkt, req->para2);\n\tSET_BT_MP_INFO_PARA3(h2c_pkt, req->para3);\n\n\trtw_fw_send_h2c_command(rtwdev, h2c_pkt);\n}\n\nvoid rtw_fw_force_bt_tx_power(struct rtw_dev *rtwdev, u8 bt_pwr_dec_lvl)\n{\n\tu8 h2c_pkt[H2C_PKT_SIZE] = {0};\n\tu8 index = 0 - bt_pwr_dec_lvl;\n\n\tSET_H2C_CMD_ID_CLASS(h2c_pkt, H2C_CMD_FORCE_BT_TX_POWER);\n\n\tSET_BT_TX_POWER_INDEX(h2c_pkt, index);\n\n\trtw_fw_send_h2c_command(rtwdev, h2c_pkt);\n}\n\nvoid rtw_fw_bt_ignore_wlan_action(struct rtw_dev *rtwdev, bool enable)\n{\n\tu8 h2c_pkt[H2C_PKT_SIZE] = {0};\n\n\tSET_H2C_CMD_ID_CLASS(h2c_pkt, H2C_CMD_IGNORE_WLAN_ACTION);\n\n\tSET_IGNORE_WLAN_ACTION_EN(h2c_pkt, enable);\n\n\trtw_fw_send_h2c_command(rtwdev, h2c_pkt);\n}\n\nvoid rtw_fw_coex_tdma_type(struct rtw_dev *rtwdev,\n\t\t\t   u8 para1, u8 para2, u8 para3, u8 para4, u8 para5)\n{\n\tu8 h2c_pkt[H2C_PKT_SIZE] = {0};\n\n\tSET_H2C_CMD_ID_CLASS(h2c_pkt, H2C_CMD_COEX_TDMA_TYPE);\n\n\tSET_COEX_TDMA_TYPE_PARA1(h2c_pkt, para1);\n\tSET_COEX_TDMA_TYPE_PARA2(h2c_pkt, para2);\n\tSET_COEX_TDMA_TYPE_PARA3(h2c_pkt, para3);\n\tSET_COEX_TDMA_TYPE_PARA4(h2c_pkt, para4);\n\tSET_COEX_TDMA_TYPE_PARA5(h2c_pkt, para5);\n\n\trtw_fw_send_h2c_command(rtwdev, h2c_pkt);\n}\n\nvoid rtw_fw_coex_query_hid_info(struct rtw_dev *rtwdev, u8 sub_id, u8 data)\n{\n\tu8 h2c_pkt[H2C_PKT_SIZE] = {0};\n\n\tSET_H2C_CMD_ID_CLASS(h2c_pkt, H2C_CMD_QUERY_BT_HID_INFO);\n\n\tSET_COEX_QUERY_HID_INFO_SUBID(h2c_pkt, sub_id);\n\tSET_COEX_QUERY_HID_INFO_DATA1(h2c_pkt, data);\n\n\trtw_fw_send_h2c_command(rtwdev, h2c_pkt);\n}\n\nvoid rtw_fw_bt_wifi_control(struct rtw_dev *rtwdev, u8 op_code, u8 *data)\n{\n\tu8 h2c_pkt[H2C_PKT_SIZE] = {0};\n\n\tSET_H2C_CMD_ID_CLASS(h2c_pkt, H2C_CMD_BT_WIFI_CONTROL);\n\n\tSET_BT_WIFI_CONTROL_OP_CODE(h2c_pkt, op_code);\n\n\tSET_BT_WIFI_CONTROL_DATA1(h2c_pkt, *data);\n\tSET_BT_WIFI_CONTROL_DATA2(h2c_pkt, *(data + 1));\n\tSET_BT_WIFI_CONTROL_DATA3(h2c_pkt, *(data + 2));\n\tSET_BT_WIFI_CONTROL_DATA4(h2c_pkt, *(data + 3));\n\tSET_BT_WIFI_CONTROL_DATA5(h2c_pkt, *(data + 4));\n\n\trtw_fw_send_h2c_command(rtwdev, h2c_pkt);\n}\n\nvoid rtw_fw_send_rssi_info(struct rtw_dev *rtwdev, struct rtw_sta_info *si)\n{\n\tu8 h2c_pkt[H2C_PKT_SIZE] = {0};\n\tu8 rssi = ewma_rssi_read(&si->avg_rssi);\n\tbool stbc_en = si->stbc_en ? true : false;\n\n\tSET_H2C_CMD_ID_CLASS(h2c_pkt, H2C_CMD_RSSI_MONITOR);\n\n\tSET_RSSI_INFO_MACID(h2c_pkt, si->mac_id);\n\tSET_RSSI_INFO_RSSI(h2c_pkt, rssi);\n\tSET_RSSI_INFO_STBC(h2c_pkt, stbc_en);\n\n\trtw_fw_send_h2c_command(rtwdev, h2c_pkt);\n}\n\nvoid rtw_fw_send_ra_info(struct rtw_dev *rtwdev, struct rtw_sta_info *si,\n\t\t\t bool reset_ra_mask)\n{\n\tu8 h2c_pkt[H2C_PKT_SIZE] = {0};\n\tbool disable_pt = true;\n\n\tSET_H2C_CMD_ID_CLASS(h2c_pkt, H2C_CMD_RA_INFO);\n\n\tSET_RA_INFO_MACID(h2c_pkt, si->mac_id);\n\tSET_RA_INFO_RATE_ID(h2c_pkt, si->rate_id);\n\tSET_RA_INFO_INIT_RA_LVL(h2c_pkt, si->init_ra_lv);\n\tSET_RA_INFO_SGI_EN(h2c_pkt, si->sgi_enable);\n\tSET_RA_INFO_BW_MODE(h2c_pkt, si->bw_mode);\n\tSET_RA_INFO_LDPC(h2c_pkt, !!si->ldpc_en);\n\tSET_RA_INFO_NO_UPDATE(h2c_pkt, !reset_ra_mask);\n\tSET_RA_INFO_VHT_EN(h2c_pkt, si->vht_enable);\n\tSET_RA_INFO_DIS_PT(h2c_pkt, disable_pt);\n\tSET_RA_INFO_RA_MASK0(h2c_pkt, (si->ra_mask & 0xff));\n\tSET_RA_INFO_RA_MASK1(h2c_pkt, (si->ra_mask & 0xff00) >> 8);\n\tSET_RA_INFO_RA_MASK2(h2c_pkt, (si->ra_mask & 0xff0000) >> 16);\n\tSET_RA_INFO_RA_MASK3(h2c_pkt, (si->ra_mask & 0xff000000) >> 24);\n\n\tsi->init_ra_lv = 0;\n\n\trtw_fw_send_h2c_command(rtwdev, h2c_pkt);\n}\n\nvoid rtw_fw_media_status_report(struct rtw_dev *rtwdev, u8 mac_id, bool connect)\n{\n\tu8 h2c_pkt[H2C_PKT_SIZE] = {0};\n\n\tSET_H2C_CMD_ID_CLASS(h2c_pkt, H2C_CMD_MEDIA_STATUS_RPT);\n\tMEDIA_STATUS_RPT_SET_OP_MODE(h2c_pkt, connect);\n\tMEDIA_STATUS_RPT_SET_MACID(h2c_pkt, mac_id);\n\n\trtw_fw_send_h2c_command(rtwdev, h2c_pkt);\n}\n\nvoid rtw_fw_update_wl_phy_info(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_traffic_stats *stats = &rtwdev->stats;\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tu8 h2c_pkt[H2C_PKT_SIZE] = {0};\n\n\tSET_H2C_CMD_ID_CLASS(h2c_pkt, H2C_CMD_WL_PHY_INFO);\n\tSET_WL_PHY_INFO_TX_TP(h2c_pkt, stats->tx_throughput);\n\tSET_WL_PHY_INFO_RX_TP(h2c_pkt, stats->rx_throughput);\n\tSET_WL_PHY_INFO_TX_RATE_DESC(h2c_pkt, dm_info->tx_rate);\n\tSET_WL_PHY_INFO_RX_RATE_DESC(h2c_pkt, dm_info->curr_rx_rate);\n\tSET_WL_PHY_INFO_RX_EVM(h2c_pkt, dm_info->rx_evm_dbm[RF_PATH_A]);\n\trtw_fw_send_h2c_command(rtwdev, h2c_pkt);\n}\n\nvoid rtw_fw_beacon_filter_config(struct rtw_dev *rtwdev, bool connect,\n\t\t\t\t struct ieee80211_vif *vif)\n{\n\tstruct ieee80211_bss_conf *bss_conf = &vif->bss_conf;\n\tstruct ieee80211_sta *sta = ieee80211_find_sta(vif, bss_conf->bssid);\n\tstatic const u8 rssi_min = 0, rssi_max = 100, rssi_offset = 100;\n\tstruct rtw_sta_info *si =\n\t\tsta ? (struct rtw_sta_info *)sta->drv_priv : NULL;\n\ts32 threshold = bss_conf->cqm_rssi_thold + rssi_offset;\n\tu8 h2c_pkt[H2C_PKT_SIZE] = {0};\n\n\tif (!rtw_fw_feature_check(&rtwdev->fw, FW_FEATURE_BCN_FILTER))\n\t\treturn;\n\n\tif (!connect) {\n\t\tSET_H2C_CMD_ID_CLASS(h2c_pkt, H2C_CMD_BCN_FILTER_OFFLOAD_P1);\n\t\tSET_BCN_FILTER_OFFLOAD_P1_ENABLE(h2c_pkt, connect);\n\t\trtw_fw_send_h2c_command(rtwdev, h2c_pkt);\n\n\t\treturn;\n\t}\n\n\tif (!si)\n\t\treturn;\n\n\tSET_H2C_CMD_ID_CLASS(h2c_pkt, H2C_CMD_BCN_FILTER_OFFLOAD_P0);\n\tether_addr_copy(&h2c_pkt[1], bss_conf->bssid);\n\trtw_fw_send_h2c_command(rtwdev, h2c_pkt);\n\n\tmemset(h2c_pkt, 0, sizeof(h2c_pkt));\n\tthreshold = clamp_t(s32, threshold, rssi_min, rssi_max);\n\tSET_H2C_CMD_ID_CLASS(h2c_pkt, H2C_CMD_BCN_FILTER_OFFLOAD_P1);\n\tSET_BCN_FILTER_OFFLOAD_P1_ENABLE(h2c_pkt, connect);\n\tSET_BCN_FILTER_OFFLOAD_P1_OFFLOAD_MODE(h2c_pkt,\n\t\t\t\t\t       BCN_FILTER_OFFLOAD_MODE_DEFAULT);\n\tSET_BCN_FILTER_OFFLOAD_P1_THRESHOLD(h2c_pkt, (u8)threshold);\n\tSET_BCN_FILTER_OFFLOAD_P1_BCN_LOSS_CNT(h2c_pkt, BCN_LOSS_CNT);\n\tSET_BCN_FILTER_OFFLOAD_P1_MACID(h2c_pkt, si->mac_id);\n\tSET_BCN_FILTER_OFFLOAD_P1_HYST(h2c_pkt, bss_conf->cqm_rssi_hyst);\n\tSET_BCN_FILTER_OFFLOAD_P1_BCN_INTERVAL(h2c_pkt, bss_conf->beacon_int);\n\trtw_fw_send_h2c_command(rtwdev, h2c_pkt);\n}\n\nvoid rtw_fw_set_pwr_mode(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_lps_conf *conf = &rtwdev->lps_conf;\n\tu8 h2c_pkt[H2C_PKT_SIZE] = {0};\n\n\tSET_H2C_CMD_ID_CLASS(h2c_pkt, H2C_CMD_SET_PWR_MODE);\n\n\tSET_PWR_MODE_SET_MODE(h2c_pkt, conf->mode);\n\tSET_PWR_MODE_SET_RLBM(h2c_pkt, conf->rlbm);\n\tSET_PWR_MODE_SET_SMART_PS(h2c_pkt, conf->smart_ps);\n\tSET_PWR_MODE_SET_AWAKE_INTERVAL(h2c_pkt, conf->awake_interval);\n\tSET_PWR_MODE_SET_PORT_ID(h2c_pkt, conf->port_id);\n\tSET_PWR_MODE_SET_PWR_STATE(h2c_pkt, conf->state);\n\n\trtw_fw_send_h2c_command(rtwdev, h2c_pkt);\n}\n\nvoid rtw_fw_set_keep_alive_cmd(struct rtw_dev *rtwdev, bool enable)\n{\n\tu8 h2c_pkt[H2C_PKT_SIZE] = {0};\n\tstruct rtw_fw_wow_keep_alive_para mode = {\n\t\t.adopt = true,\n\t\t.pkt_type = KEEP_ALIVE_NULL_PKT,\n\t\t.period = 5,\n\t};\n\n\tSET_H2C_CMD_ID_CLASS(h2c_pkt, H2C_CMD_KEEP_ALIVE);\n\tSET_KEEP_ALIVE_ENABLE(h2c_pkt, enable);\n\tSET_KEEP_ALIVE_ADOPT(h2c_pkt, mode.adopt);\n\tSET_KEEP_ALIVE_PKT_TYPE(h2c_pkt, mode.pkt_type);\n\tSET_KEEP_ALIVE_CHECK_PERIOD(h2c_pkt, mode.period);\n\n\trtw_fw_send_h2c_command(rtwdev, h2c_pkt);\n}\n\nvoid rtw_fw_set_disconnect_decision_cmd(struct rtw_dev *rtwdev, bool enable)\n{\n\tstruct rtw_wow_param *rtw_wow = &rtwdev->wow;\n\tu8 h2c_pkt[H2C_PKT_SIZE] = {0};\n\tstruct rtw_fw_wow_disconnect_para mode = {\n\t\t.adopt = true,\n\t\t.period = 30,\n\t\t.retry_count = 5,\n\t};\n\n\tSET_H2C_CMD_ID_CLASS(h2c_pkt, H2C_CMD_DISCONNECT_DECISION);\n\n\tif (test_bit(RTW_WOW_FLAG_EN_DISCONNECT, rtw_wow->flags)) {\n\t\tSET_DISCONNECT_DECISION_ENABLE(h2c_pkt, enable);\n\t\tSET_DISCONNECT_DECISION_ADOPT(h2c_pkt, mode.adopt);\n\t\tSET_DISCONNECT_DECISION_CHECK_PERIOD(h2c_pkt, mode.period);\n\t\tSET_DISCONNECT_DECISION_TRY_PKT_NUM(h2c_pkt, mode.retry_count);\n\t}\n\n\trtw_fw_send_h2c_command(rtwdev, h2c_pkt);\n}\n\nvoid rtw_fw_set_wowlan_ctrl_cmd(struct rtw_dev *rtwdev, bool enable)\n{\n\tstruct rtw_wow_param *rtw_wow = &rtwdev->wow;\n\tu8 h2c_pkt[H2C_PKT_SIZE] = {0};\n\n\tSET_H2C_CMD_ID_CLASS(h2c_pkt, H2C_CMD_WOWLAN);\n\n\tSET_WOWLAN_FUNC_ENABLE(h2c_pkt, enable);\n\tif (rtw_wow_mgd_linked(rtwdev)) {\n\t\tif (test_bit(RTW_WOW_FLAG_EN_MAGIC_PKT, rtw_wow->flags))\n\t\t\tSET_WOWLAN_MAGIC_PKT_ENABLE(h2c_pkt, enable);\n\t\tif (test_bit(RTW_WOW_FLAG_EN_DISCONNECT, rtw_wow->flags))\n\t\t\tSET_WOWLAN_DEAUTH_WAKEUP_ENABLE(h2c_pkt, enable);\n\t\tif (test_bit(RTW_WOW_FLAG_EN_REKEY_PKT, rtw_wow->flags))\n\t\t\tSET_WOWLAN_REKEY_WAKEUP_ENABLE(h2c_pkt, enable);\n\t\tif (rtw_wow->pattern_cnt)\n\t\t\tSET_WOWLAN_PATTERN_MATCH_ENABLE(h2c_pkt, enable);\n\t}\n\n\trtw_fw_send_h2c_command(rtwdev, h2c_pkt);\n}\n\nvoid rtw_fw_set_aoac_global_info_cmd(struct rtw_dev *rtwdev,\n\t\t\t\t     u8 pairwise_key_enc,\n\t\t\t\t     u8 group_key_enc)\n{\n\tu8 h2c_pkt[H2C_PKT_SIZE] = {0};\n\n\tSET_H2C_CMD_ID_CLASS(h2c_pkt, H2C_CMD_AOAC_GLOBAL_INFO);\n\n\tSET_AOAC_GLOBAL_INFO_PAIRWISE_ENC_ALG(h2c_pkt, pairwise_key_enc);\n\tSET_AOAC_GLOBAL_INFO_GROUP_ENC_ALG(h2c_pkt, group_key_enc);\n\n\trtw_fw_send_h2c_command(rtwdev, h2c_pkt);\n}\n\nvoid rtw_fw_set_remote_wake_ctrl_cmd(struct rtw_dev *rtwdev, bool enable)\n{\n\tu8 h2c_pkt[H2C_PKT_SIZE] = {0};\n\n\tSET_H2C_CMD_ID_CLASS(h2c_pkt, H2C_CMD_REMOTE_WAKE_CTRL);\n\n\tSET_REMOTE_WAKECTRL_ENABLE(h2c_pkt, enable);\n\n\tif (rtw_wow_no_link(rtwdev))\n\t\tSET_REMOTE_WAKE_CTRL_NLO_OFFLOAD_EN(h2c_pkt, enable);\n\n\trtw_fw_send_h2c_command(rtwdev, h2c_pkt);\n}\n\nstatic u8 rtw_get_rsvd_page_location(struct rtw_dev *rtwdev,\n\t\t\t\t     enum rtw_rsvd_packet_type type)\n{\n\tstruct rtw_rsvd_page *rsvd_pkt;\n\tu8 location = 0;\n\n\tlist_for_each_entry(rsvd_pkt, &rtwdev->rsvd_page_list, build_list) {\n\t\tif (type == rsvd_pkt->type)\n\t\t\tlocation = rsvd_pkt->page;\n\t}\n\n\treturn location;\n}\n\nvoid rtw_fw_set_nlo_info(struct rtw_dev *rtwdev, bool enable)\n{\n\tu8 h2c_pkt[H2C_PKT_SIZE] = {0};\n\tu8 loc_nlo;\n\n\tloc_nlo = rtw_get_rsvd_page_location(rtwdev, RSVD_NLO_INFO);\n\n\tSET_H2C_CMD_ID_CLASS(h2c_pkt, H2C_CMD_NLO_INFO);\n\n\tSET_NLO_FUN_EN(h2c_pkt, enable);\n\tif (enable) {\n\t\tif (rtw_get_lps_deep_mode(rtwdev) != LPS_DEEP_MODE_NONE)\n\t\t\tSET_NLO_PS_32K(h2c_pkt, enable);\n\t\tSET_NLO_IGNORE_SECURITY(h2c_pkt, enable);\n\t\tSET_NLO_LOC_NLO_INFO(h2c_pkt, loc_nlo);\n\t}\n\n\trtw_fw_send_h2c_command(rtwdev, h2c_pkt);\n}\n\nvoid rtw_fw_set_recover_bt_device(struct rtw_dev *rtwdev)\n{\n\tu8 h2c_pkt[H2C_PKT_SIZE] = {0};\n\n\tSET_H2C_CMD_ID_CLASS(h2c_pkt, H2C_CMD_RECOVER_BT_DEV);\n\tSET_RECOVER_BT_DEV_EN(h2c_pkt, 1);\n\n\trtw_fw_send_h2c_command(rtwdev, h2c_pkt);\n}\n\nvoid rtw_fw_set_pg_info(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_lps_conf *conf = &rtwdev->lps_conf;\n\tu8 h2c_pkt[H2C_PKT_SIZE] = {0};\n\tu8 loc_pg, loc_dpk;\n\n\tloc_pg = rtw_get_rsvd_page_location(rtwdev, RSVD_LPS_PG_INFO);\n\tloc_dpk = rtw_get_rsvd_page_location(rtwdev, RSVD_LPS_PG_DPK);\n\n\tSET_H2C_CMD_ID_CLASS(h2c_pkt, H2C_CMD_LPS_PG_INFO);\n\n\tLPS_PG_INFO_LOC(h2c_pkt, loc_pg);\n\tLPS_PG_DPK_LOC(h2c_pkt, loc_dpk);\n\tLPS_PG_SEC_CAM_EN(h2c_pkt, conf->sec_cam_backup);\n\tLPS_PG_PATTERN_CAM_EN(h2c_pkt, conf->pattern_cam_backup);\n\n\trtw_fw_send_h2c_command(rtwdev, h2c_pkt);\n}\n\nstatic u8 rtw_get_rsvd_page_probe_req_location(struct rtw_dev *rtwdev,\n\t\t\t\t\t       struct cfg80211_ssid *ssid)\n{\n\tstruct rtw_rsvd_page *rsvd_pkt;\n\tu8 location = 0;\n\n\tlist_for_each_entry(rsvd_pkt, &rtwdev->rsvd_page_list, build_list) {\n\t\tif (rsvd_pkt->type != RSVD_PROBE_REQ)\n\t\t\tcontinue;\n\t\tif ((!ssid && !rsvd_pkt->ssid) ||\n\t\t    rtw_ssid_equal(rsvd_pkt->ssid, ssid))\n\t\t\tlocation = rsvd_pkt->page;\n\t}\n\n\treturn location;\n}\n\nstatic u16 rtw_get_rsvd_page_probe_req_size(struct rtw_dev *rtwdev,\n\t\t\t\t\t    struct cfg80211_ssid *ssid)\n{\n\tstruct rtw_rsvd_page *rsvd_pkt;\n\tu16 size = 0;\n\n\tlist_for_each_entry(rsvd_pkt, &rtwdev->rsvd_page_list, build_list) {\n\t\tif (rsvd_pkt->type != RSVD_PROBE_REQ)\n\t\t\tcontinue;\n\t\tif ((!ssid && !rsvd_pkt->ssid) ||\n\t\t    rtw_ssid_equal(rsvd_pkt->ssid, ssid))\n\t\t\tsize = rsvd_pkt->probe_req_size;\n\t}\n\n\treturn size;\n}\n\nvoid rtw_send_rsvd_page_h2c(struct rtw_dev *rtwdev)\n{\n\tu8 h2c_pkt[H2C_PKT_SIZE] = {0};\n\tu8 location = 0;\n\n\tSET_H2C_CMD_ID_CLASS(h2c_pkt, H2C_CMD_RSVD_PAGE);\n\n\tlocation = rtw_get_rsvd_page_location(rtwdev, RSVD_PROBE_RESP);\n\t*(h2c_pkt + 1) = location;\n\trtw_dbg(rtwdev, RTW_DBG_FW, \"RSVD_PROBE_RESP loc: %d\\n\", location);\n\n\tlocation = rtw_get_rsvd_page_location(rtwdev, RSVD_PS_POLL);\n\t*(h2c_pkt + 2) = location;\n\trtw_dbg(rtwdev, RTW_DBG_FW, \"RSVD_PS_POLL loc: %d\\n\", location);\n\n\tlocation = rtw_get_rsvd_page_location(rtwdev, RSVD_NULL);\n\t*(h2c_pkt + 3) = location;\n\trtw_dbg(rtwdev, RTW_DBG_FW, \"RSVD_NULL loc: %d\\n\", location);\n\n\tlocation = rtw_get_rsvd_page_location(rtwdev, RSVD_QOS_NULL);\n\t*(h2c_pkt + 4) = location;\n\trtw_dbg(rtwdev, RTW_DBG_FW, \"RSVD_QOS_NULL loc: %d\\n\", location);\n\n\trtw_fw_send_h2c_command(rtwdev, h2c_pkt);\n}\n\nstatic struct sk_buff *rtw_nlo_info_get(struct ieee80211_hw *hw)\n{\n\tstruct rtw_dev *rtwdev = hw->priv;\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_pno_request *pno_req = &rtwdev->wow.pno_req;\n\tstruct rtw_nlo_info_hdr *nlo_hdr;\n\tstruct cfg80211_ssid *ssid;\n\tstruct sk_buff *skb;\n\tu8 *pos, loc;\n\tu32 size;\n\tint i;\n\n\tif (!pno_req->inited || !pno_req->match_set_cnt)\n\t\treturn NULL;\n\n\tsize = sizeof(struct rtw_nlo_info_hdr) + pno_req->match_set_cnt *\n\t\t      IEEE80211_MAX_SSID_LEN + chip->tx_pkt_desc_sz;\n\n\tskb = alloc_skb(size, GFP_KERNEL);\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, chip->tx_pkt_desc_sz);\n\n\tnlo_hdr = skb_put_zero(skb, sizeof(struct rtw_nlo_info_hdr));\n\n\tnlo_hdr->nlo_count = pno_req->match_set_cnt;\n\tnlo_hdr->hidden_ap_count = pno_req->match_set_cnt;\n\n\t \n\tmemset(nlo_hdr->pattern_check, 0xA5, FW_NLO_INFO_CHECK_SIZE);\n\n\tfor (i = 0; i < pno_req->match_set_cnt; i++)\n\t\tnlo_hdr->ssid_len[i] = pno_req->match_sets[i].ssid.ssid_len;\n\n\tfor (i = 0; i < pno_req->match_set_cnt; i++) {\n\t\tssid = &pno_req->match_sets[i].ssid;\n\t\tloc  = rtw_get_rsvd_page_probe_req_location(rtwdev, ssid);\n\t\tif (!loc) {\n\t\t\trtw_err(rtwdev, \"failed to get probe req rsvd loc\\n\");\n\t\t\tkfree_skb(skb);\n\t\t\treturn NULL;\n\t\t}\n\t\tnlo_hdr->location[i] = loc;\n\t}\n\n\tfor (i = 0; i < pno_req->match_set_cnt; i++) {\n\t\tpos = skb_put_zero(skb, IEEE80211_MAX_SSID_LEN);\n\t\tmemcpy(pos, pno_req->match_sets[i].ssid.ssid,\n\t\t       pno_req->match_sets[i].ssid.ssid_len);\n\t}\n\n\treturn skb;\n}\n\nstatic struct sk_buff *rtw_cs_channel_info_get(struct ieee80211_hw *hw)\n{\n\tstruct rtw_dev *rtwdev = hw->priv;\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_pno_request *pno_req = &rtwdev->wow.pno_req;\n\tstruct ieee80211_channel *channels = pno_req->channels;\n\tstruct sk_buff *skb;\n\tint count =  pno_req->channel_cnt;\n\tu8 *pos;\n\tint i = 0;\n\n\tskb = alloc_skb(4 * count + chip->tx_pkt_desc_sz, GFP_KERNEL);\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, chip->tx_pkt_desc_sz);\n\n\tfor (i = 0; i < count; i++) {\n\t\tpos = skb_put_zero(skb, 4);\n\n\t\tCHSW_INFO_SET_CH(pos, channels[i].hw_value);\n\n\t\tif (channels[i].flags & IEEE80211_CHAN_RADAR)\n\t\t\tCHSW_INFO_SET_ACTION_ID(pos, 0);\n\t\telse\n\t\t\tCHSW_INFO_SET_ACTION_ID(pos, 1);\n\t\tCHSW_INFO_SET_TIMEOUT(pos, 1);\n\t\tCHSW_INFO_SET_PRI_CH_IDX(pos, 1);\n\t\tCHSW_INFO_SET_BW(pos, 0);\n\t}\n\n\treturn skb;\n}\n\nstatic struct sk_buff *rtw_lps_pg_dpk_get(struct ieee80211_hw *hw)\n{\n\tstruct rtw_dev *rtwdev = hw->priv;\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_dpk_info *dpk_info = &rtwdev->dm_info.dpk_info;\n\tstruct rtw_lps_pg_dpk_hdr *dpk_hdr;\n\tstruct sk_buff *skb;\n\tu32 size;\n\n\tsize = chip->tx_pkt_desc_sz + sizeof(*dpk_hdr);\n\tskb = alloc_skb(size, GFP_KERNEL);\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, chip->tx_pkt_desc_sz);\n\tdpk_hdr = skb_put_zero(skb, sizeof(*dpk_hdr));\n\tdpk_hdr->dpk_ch = dpk_info->dpk_ch;\n\tdpk_hdr->dpk_path_ok = dpk_info->dpk_path_ok[0];\n\tmemcpy(dpk_hdr->dpk_txagc, dpk_info->dpk_txagc, 2);\n\tmemcpy(dpk_hdr->dpk_gs, dpk_info->dpk_gs, 4);\n\tmemcpy(dpk_hdr->coef, dpk_info->coef, 160);\n\n\treturn skb;\n}\n\nstatic struct sk_buff *rtw_lps_pg_info_get(struct ieee80211_hw *hw)\n{\n\tstruct rtw_dev *rtwdev = hw->priv;\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_lps_conf *conf = &rtwdev->lps_conf;\n\tstruct rtw_lps_pg_info_hdr *pg_info_hdr;\n\tstruct rtw_wow_param *rtw_wow = &rtwdev->wow;\n\tstruct sk_buff *skb;\n\tu32 size;\n\n\tsize = chip->tx_pkt_desc_sz + sizeof(*pg_info_hdr);\n\tskb = alloc_skb(size, GFP_KERNEL);\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, chip->tx_pkt_desc_sz);\n\tpg_info_hdr = skb_put_zero(skb, sizeof(*pg_info_hdr));\n\tpg_info_hdr->tx_bu_page_count = rtwdev->fifo.rsvd_drv_pg_num;\n\tpg_info_hdr->macid = find_first_bit(rtwdev->mac_id_map, RTW_MAX_MAC_ID_NUM);\n\tpg_info_hdr->sec_cam_count =\n\t\trtw_sec_cam_pg_backup(rtwdev, pg_info_hdr->sec_cam);\n\tpg_info_hdr->pattern_count = rtw_wow->pattern_cnt;\n\n\tconf->sec_cam_backup = pg_info_hdr->sec_cam_count != 0;\n\tconf->pattern_cam_backup = rtw_wow->pattern_cnt != 0;\n\n\treturn skb;\n}\n\nstatic struct sk_buff *rtw_get_rsvd_page_skb(struct ieee80211_hw *hw,\n\t\t\t\t\t     struct rtw_rsvd_page *rsvd_pkt)\n{\n\tstruct ieee80211_vif *vif;\n\tstruct rtw_vif *rtwvif;\n\tstruct sk_buff *skb_new;\n\tstruct cfg80211_ssid *ssid;\n\tu16 tim_offset = 0;\n\n\tif (rsvd_pkt->type == RSVD_DUMMY) {\n\t\tskb_new = alloc_skb(1, GFP_KERNEL);\n\t\tif (!skb_new)\n\t\t\treturn NULL;\n\n\t\tskb_put(skb_new, 1);\n\t\treturn skb_new;\n\t}\n\n\trtwvif = rsvd_pkt->rtwvif;\n\tif (!rtwvif)\n\t\treturn NULL;\n\n\tvif = rtwvif_to_vif(rtwvif);\n\n\tswitch (rsvd_pkt->type) {\n\tcase RSVD_BEACON:\n\t\tskb_new = ieee80211_beacon_get_tim(hw, vif, &tim_offset, NULL, 0);\n\t\trsvd_pkt->tim_offset = tim_offset;\n\t\tbreak;\n\tcase RSVD_PS_POLL:\n\t\tskb_new = ieee80211_pspoll_get(hw, vif);\n\t\tbreak;\n\tcase RSVD_PROBE_RESP:\n\t\tskb_new = ieee80211_proberesp_get(hw, vif);\n\t\tbreak;\n\tcase RSVD_NULL:\n\t\tskb_new = ieee80211_nullfunc_get(hw, vif, -1, false);\n\t\tbreak;\n\tcase RSVD_QOS_NULL:\n\t\tskb_new = ieee80211_nullfunc_get(hw, vif, -1, true);\n\t\tbreak;\n\tcase RSVD_LPS_PG_DPK:\n\t\tskb_new = rtw_lps_pg_dpk_get(hw);\n\t\tbreak;\n\tcase RSVD_LPS_PG_INFO:\n\t\tskb_new = rtw_lps_pg_info_get(hw);\n\t\tbreak;\n\tcase RSVD_PROBE_REQ:\n\t\tssid = (struct cfg80211_ssid *)rsvd_pkt->ssid;\n\t\tif (ssid)\n\t\t\tskb_new = ieee80211_probereq_get(hw, vif->addr,\n\t\t\t\t\t\t\t ssid->ssid,\n\t\t\t\t\t\t\t ssid->ssid_len, 0);\n\t\telse\n\t\t\tskb_new = ieee80211_probereq_get(hw, vif->addr, NULL, 0, 0);\n\t\tif (skb_new)\n\t\t\trsvd_pkt->probe_req_size = (u16)skb_new->len;\n\t\tbreak;\n\tcase RSVD_NLO_INFO:\n\t\tskb_new = rtw_nlo_info_get(hw);\n\t\tbreak;\n\tcase RSVD_CH_INFO:\n\t\tskb_new = rtw_cs_channel_info_get(hw);\n\t\tbreak;\n\tdefault:\n\t\treturn NULL;\n\t}\n\n\tif (!skb_new)\n\t\treturn NULL;\n\n\treturn skb_new;\n}\n\nstatic void rtw_fill_rsvd_page_desc(struct rtw_dev *rtwdev, struct sk_buff *skb,\n\t\t\t\t    enum rtw_rsvd_packet_type type)\n{\n\tstruct rtw_tx_pkt_info pkt_info = {0};\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tu8 *pkt_desc;\n\n\trtw_tx_rsvd_page_pkt_info_update(rtwdev, &pkt_info, skb, type);\n\tpkt_desc = skb_push(skb, chip->tx_pkt_desc_sz);\n\tmemset(pkt_desc, 0, chip->tx_pkt_desc_sz);\n\trtw_tx_fill_tx_desc(&pkt_info, skb);\n}\n\nstatic inline u8 rtw_len_to_page(unsigned int len, u8 page_size)\n{\n\treturn DIV_ROUND_UP(len, page_size);\n}\n\nstatic void rtw_rsvd_page_list_to_buf(struct rtw_dev *rtwdev, u8 page_size,\n\t\t\t\t      u8 page_margin, u32 page, u8 *buf,\n\t\t\t\t      struct rtw_rsvd_page *rsvd_pkt)\n{\n\tstruct sk_buff *skb = rsvd_pkt->skb;\n\n\tif (page >= 1)\n\t\tmemcpy(buf + page_margin + page_size * (page - 1),\n\t\t       skb->data, skb->len);\n\telse\n\t\tmemcpy(buf, skb->data, skb->len);\n}\n\nstatic struct rtw_rsvd_page *rtw_alloc_rsvd_page(struct rtw_dev *rtwdev,\n\t\t\t\t\t\t enum rtw_rsvd_packet_type type,\n\t\t\t\t\t\t bool txdesc)\n{\n\tstruct rtw_rsvd_page *rsvd_pkt = NULL;\n\n\trsvd_pkt = kzalloc(sizeof(*rsvd_pkt), GFP_KERNEL);\n\n\tif (!rsvd_pkt)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&rsvd_pkt->vif_list);\n\tINIT_LIST_HEAD(&rsvd_pkt->build_list);\n\trsvd_pkt->type = type;\n\trsvd_pkt->add_txdesc = txdesc;\n\n\treturn rsvd_pkt;\n}\n\nstatic void rtw_insert_rsvd_page(struct rtw_dev *rtwdev,\n\t\t\t\t struct rtw_vif *rtwvif,\n\t\t\t\t struct rtw_rsvd_page *rsvd_pkt)\n{\n\tlockdep_assert_held(&rtwdev->mutex);\n\n\tlist_add_tail(&rsvd_pkt->vif_list, &rtwvif->rsvd_page_list);\n}\n\nstatic void rtw_add_rsvd_page(struct rtw_dev *rtwdev,\n\t\t\t      struct rtw_vif *rtwvif,\n\t\t\t      enum rtw_rsvd_packet_type type,\n\t\t\t      bool txdesc)\n{\n\tstruct rtw_rsvd_page *rsvd_pkt;\n\n\trsvd_pkt = rtw_alloc_rsvd_page(rtwdev, type, txdesc);\n\tif (!rsvd_pkt) {\n\t\trtw_err(rtwdev, \"failed to alloc rsvd page %d\\n\", type);\n\t\treturn;\n\t}\n\n\trsvd_pkt->rtwvif = rtwvif;\n\trtw_insert_rsvd_page(rtwdev, rtwvif, rsvd_pkt);\n}\n\nstatic void rtw_add_rsvd_page_probe_req(struct rtw_dev *rtwdev,\n\t\t\t\t\tstruct rtw_vif *rtwvif,\n\t\t\t\t\tstruct cfg80211_ssid *ssid)\n{\n\tstruct rtw_rsvd_page *rsvd_pkt;\n\n\trsvd_pkt = rtw_alloc_rsvd_page(rtwdev, RSVD_PROBE_REQ, true);\n\tif (!rsvd_pkt) {\n\t\trtw_err(rtwdev, \"failed to alloc probe req rsvd page\\n\");\n\t\treturn;\n\t}\n\n\trsvd_pkt->rtwvif = rtwvif;\n\trsvd_pkt->ssid = ssid;\n\trtw_insert_rsvd_page(rtwdev, rtwvif, rsvd_pkt);\n}\n\nvoid rtw_remove_rsvd_page(struct rtw_dev *rtwdev,\n\t\t\t  struct rtw_vif *rtwvif)\n{\n\tstruct rtw_rsvd_page *rsvd_pkt, *tmp;\n\n\tlockdep_assert_held(&rtwdev->mutex);\n\n\t \n\tlist_for_each_entry_safe(rsvd_pkt, tmp, &rtwvif->rsvd_page_list,\n\t\t\t\t vif_list) {\n\t\tlist_del(&rsvd_pkt->vif_list);\n\t\tif (!list_empty(&rsvd_pkt->build_list))\n\t\t\tlist_del(&rsvd_pkt->build_list);\n\t\tkfree(rsvd_pkt);\n\t}\n}\n\nvoid rtw_add_rsvd_page_bcn(struct rtw_dev *rtwdev,\n\t\t\t   struct rtw_vif *rtwvif)\n{\n\tstruct ieee80211_vif *vif = rtwvif_to_vif(rtwvif);\n\n\tif (vif->type != NL80211_IFTYPE_AP &&\n\t    vif->type != NL80211_IFTYPE_ADHOC &&\n\t    vif->type != NL80211_IFTYPE_MESH_POINT) {\n\t\trtw_warn(rtwdev, \"Cannot add beacon rsvd page for %d\\n\",\n\t\t\t vif->type);\n\t\treturn;\n\t}\n\n\trtw_add_rsvd_page(rtwdev, rtwvif, RSVD_BEACON, false);\n}\n\nvoid rtw_add_rsvd_page_pno(struct rtw_dev *rtwdev,\n\t\t\t   struct rtw_vif *rtwvif)\n{\n\tstruct ieee80211_vif *vif = rtwvif_to_vif(rtwvif);\n\tstruct rtw_wow_param *rtw_wow = &rtwdev->wow;\n\tstruct rtw_pno_request *rtw_pno_req = &rtw_wow->pno_req;\n\tstruct cfg80211_ssid *ssid;\n\tint i;\n\n\tif (vif->type != NL80211_IFTYPE_STATION) {\n\t\trtw_warn(rtwdev, \"Cannot add PNO rsvd page for %d\\n\",\n\t\t\t vif->type);\n\t\treturn;\n\t}\n\n\tfor (i = 0 ; i < rtw_pno_req->match_set_cnt; i++) {\n\t\tssid = &rtw_pno_req->match_sets[i].ssid;\n\t\trtw_add_rsvd_page_probe_req(rtwdev, rtwvif, ssid);\n\t}\n\n\trtw_add_rsvd_page_probe_req(rtwdev, rtwvif, NULL);\n\trtw_add_rsvd_page(rtwdev, rtwvif, RSVD_NLO_INFO, false);\n\trtw_add_rsvd_page(rtwdev, rtwvif, RSVD_CH_INFO, true);\n}\n\nvoid rtw_add_rsvd_page_sta(struct rtw_dev *rtwdev,\n\t\t\t   struct rtw_vif *rtwvif)\n{\n\tstruct ieee80211_vif *vif = rtwvif_to_vif(rtwvif);\n\n\tif (vif->type != NL80211_IFTYPE_STATION) {\n\t\trtw_warn(rtwdev, \"Cannot add sta rsvd page for %d\\n\",\n\t\t\t vif->type);\n\t\treturn;\n\t}\n\n\trtw_add_rsvd_page(rtwdev, rtwvif, RSVD_PS_POLL, true);\n\trtw_add_rsvd_page(rtwdev, rtwvif, RSVD_QOS_NULL, true);\n\trtw_add_rsvd_page(rtwdev, rtwvif, RSVD_NULL, true);\n\trtw_add_rsvd_page(rtwdev, rtwvif, RSVD_LPS_PG_DPK, true);\n\trtw_add_rsvd_page(rtwdev, rtwvif, RSVD_LPS_PG_INFO, true);\n}\n\nint rtw_fw_write_data_rsvd_page(struct rtw_dev *rtwdev, u16 pg_addr,\n\t\t\t\tu8 *buf, u32 size)\n{\n\tu8 bckp[2];\n\tu8 val;\n\tu16 rsvd_pg_head;\n\tu32 bcn_valid_addr;\n\tu32 bcn_valid_mask;\n\tint ret;\n\n\tlockdep_assert_held(&rtwdev->mutex);\n\n\tif (!size)\n\t\treturn -EINVAL;\n\n\tif (rtw_chip_wcpu_11n(rtwdev)) {\n\t\trtw_write32_set(rtwdev, REG_DWBCN0_CTRL, BIT_BCN_VALID);\n\t} else {\n\t\tpg_addr &= BIT_MASK_BCN_HEAD_1_V1;\n\t\tpg_addr |= BIT_BCN_VALID_V1;\n\t\trtw_write16(rtwdev, REG_FIFOPAGE_CTRL_2, pg_addr);\n\t}\n\n\tval = rtw_read8(rtwdev, REG_CR + 1);\n\tbckp[0] = val;\n\tval |= BIT_ENSWBCN >> 8;\n\trtw_write8(rtwdev, REG_CR + 1, val);\n\n\tval = rtw_read8(rtwdev, REG_FWHW_TXQ_CTRL + 2);\n\tbckp[1] = val;\n\tval &= ~(BIT_EN_BCNQ_DL >> 16);\n\trtw_write8(rtwdev, REG_FWHW_TXQ_CTRL + 2, val);\n\n\tret = rtw_hci_write_data_rsvd_page(rtwdev, buf, size);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to write data to rsvd page\\n\");\n\t\tgoto restore;\n\t}\n\n\tif (rtw_chip_wcpu_11n(rtwdev)) {\n\t\tbcn_valid_addr = REG_DWBCN0_CTRL;\n\t\tbcn_valid_mask = BIT_BCN_VALID;\n\t} else {\n\t\tbcn_valid_addr = REG_FIFOPAGE_CTRL_2;\n\t\tbcn_valid_mask = BIT_BCN_VALID_V1;\n\t}\n\n\tif (!check_hw_ready(rtwdev, bcn_valid_addr, bcn_valid_mask, 1)) {\n\t\trtw_err(rtwdev, \"error beacon valid\\n\");\n\t\tret = -EBUSY;\n\t}\n\nrestore:\n\trsvd_pg_head = rtwdev->fifo.rsvd_boundary;\n\trtw_write16(rtwdev, REG_FIFOPAGE_CTRL_2,\n\t\t    rsvd_pg_head | BIT_BCN_VALID_V1);\n\trtw_write8(rtwdev, REG_FWHW_TXQ_CTRL + 2, bckp[1]);\n\trtw_write8(rtwdev, REG_CR + 1, bckp[0]);\n\n\treturn ret;\n}\n\nstatic int rtw_download_drv_rsvd_page(struct rtw_dev *rtwdev, u8 *buf, u32 size)\n{\n\tu32 pg_size;\n\tu32 pg_num = 0;\n\tu16 pg_addr = 0;\n\n\tpg_size = rtwdev->chip->page_size;\n\tpg_num = size / pg_size + ((size & (pg_size - 1)) ? 1 : 0);\n\tif (pg_num > rtwdev->fifo.rsvd_drv_pg_num)\n\t\treturn -ENOMEM;\n\n\tpg_addr = rtwdev->fifo.rsvd_drv_addr;\n\n\treturn rtw_fw_write_data_rsvd_page(rtwdev, pg_addr, buf, size);\n}\n\nstatic void __rtw_build_rsvd_page_reset(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_rsvd_page *rsvd_pkt, *tmp;\n\n\tlist_for_each_entry_safe(rsvd_pkt, tmp, &rtwdev->rsvd_page_list,\n\t\t\t\t build_list) {\n\t\tlist_del_init(&rsvd_pkt->build_list);\n\n\t\t \n\t\tif (rsvd_pkt->type == RSVD_DUMMY)\n\t\t\tkfree(rsvd_pkt);\n\t}\n}\n\nstatic void rtw_build_rsvd_page_iter(void *data, u8 *mac,\n\t\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct rtw_dev *rtwdev = data;\n\tstruct rtw_vif *rtwvif = (struct rtw_vif *)vif->drv_priv;\n\tstruct rtw_rsvd_page *rsvd_pkt;\n\n\t \n\tif (vif->type == NL80211_IFTYPE_AP && !rtwdev->ap_active)\n\t\treturn;\n\n\tlist_for_each_entry(rsvd_pkt, &rtwvif->rsvd_page_list, vif_list) {\n\t\tif (rsvd_pkt->type == RSVD_BEACON)\n\t\t\tlist_add(&rsvd_pkt->build_list,\n\t\t\t\t &rtwdev->rsvd_page_list);\n\t\telse\n\t\t\tlist_add_tail(&rsvd_pkt->build_list,\n\t\t\t\t      &rtwdev->rsvd_page_list);\n\t}\n}\n\nstatic int  __rtw_build_rsvd_page_from_vifs(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_rsvd_page *rsvd_pkt;\n\n\t__rtw_build_rsvd_page_reset(rtwdev);\n\n\t \n\trtw_iterate_vifs_atomic(rtwdev, rtw_build_rsvd_page_iter, rtwdev);\n\n\trsvd_pkt = list_first_entry_or_null(&rtwdev->rsvd_page_list,\n\t\t\t\t\t    struct rtw_rsvd_page, build_list);\n\tif (!rsvd_pkt) {\n\t\tWARN(1, \"Should not have an empty reserved page\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (rsvd_pkt->type != RSVD_BEACON) {\n\t\tstruct rtw_rsvd_page *dummy_pkt;\n\n\t\tdummy_pkt = rtw_alloc_rsvd_page(rtwdev, RSVD_DUMMY, false);\n\t\tif (!dummy_pkt) {\n\t\t\trtw_err(rtwdev, \"failed to alloc dummy rsvd page\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tlist_add(&dummy_pkt->build_list, &rtwdev->rsvd_page_list);\n\t}\n\n\treturn 0;\n}\n\nstatic u8 *rtw_build_rsvd_page(struct rtw_dev *rtwdev, u32 *size)\n{\n\tstruct ieee80211_hw *hw = rtwdev->hw;\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct sk_buff *iter;\n\tstruct rtw_rsvd_page *rsvd_pkt;\n\tu32 page = 0;\n\tu8 total_page = 0;\n\tu8 page_size, page_margin, tx_desc_sz;\n\tu8 *buf;\n\tint ret;\n\n\tpage_size = chip->page_size;\n\ttx_desc_sz = chip->tx_pkt_desc_sz;\n\tpage_margin = page_size - tx_desc_sz;\n\n\tret = __rtw_build_rsvd_page_from_vifs(rtwdev);\n\tif (ret) {\n\t\trtw_err(rtwdev,\n\t\t\t\"failed to build rsvd page from vifs, ret %d\\n\", ret);\n\t\treturn NULL;\n\t}\n\n\tlist_for_each_entry(rsvd_pkt, &rtwdev->rsvd_page_list, build_list) {\n\t\titer = rtw_get_rsvd_page_skb(hw, rsvd_pkt);\n\t\tif (!iter) {\n\t\t\trtw_err(rtwdev, \"failed to build rsvd packet\\n\");\n\t\t\tgoto release_skb;\n\t\t}\n\n\t\t \n\t\tif (rsvd_pkt->add_txdesc)\n\t\t\trtw_fill_rsvd_page_desc(rtwdev, iter, rsvd_pkt->type);\n\n\t\trsvd_pkt->skb = iter;\n\t\trsvd_pkt->page = total_page;\n\n\t\t \n\t\tif (total_page == 0) {\n\t\t\tif (rsvd_pkt->type != RSVD_BEACON &&\n\t\t\t    rsvd_pkt->type != RSVD_DUMMY) {\n\t\t\t\trtw_err(rtwdev, \"first page should be a beacon\\n\");\n\t\t\t\tgoto release_skb;\n\t\t\t}\n\t\t\ttotal_page += rtw_len_to_page(iter->len + tx_desc_sz,\n\t\t\t\t\t\t      page_size);\n\t\t} else {\n\t\t\ttotal_page += rtw_len_to_page(iter->len, page_size);\n\t\t}\n\t}\n\n\tif (total_page > rtwdev->fifo.rsvd_drv_pg_num) {\n\t\trtw_err(rtwdev, \"rsvd page over size: %d\\n\", total_page);\n\t\tgoto release_skb;\n\t}\n\n\t*size = (total_page - 1) * page_size + page_margin;\n\tbuf = kzalloc(*size, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto release_skb;\n\n\t \n\tlist_for_each_entry(rsvd_pkt, &rtwdev->rsvd_page_list, build_list) {\n\t\trtw_rsvd_page_list_to_buf(rtwdev, page_size, page_margin,\n\t\t\t\t\t  page, buf, rsvd_pkt);\n\t\tif (page == 0)\n\t\t\tpage += rtw_len_to_page(rsvd_pkt->skb->len +\n\t\t\t\t\t\ttx_desc_sz, page_size);\n\t\telse\n\t\t\tpage += rtw_len_to_page(rsvd_pkt->skb->len, page_size);\n\n\t\tkfree_skb(rsvd_pkt->skb);\n\t\trsvd_pkt->skb = NULL;\n\t}\n\n\treturn buf;\n\nrelease_skb:\n\tlist_for_each_entry(rsvd_pkt, &rtwdev->rsvd_page_list, build_list) {\n\t\tkfree_skb(rsvd_pkt->skb);\n\t\trsvd_pkt->skb = NULL;\n\t}\n\n\treturn NULL;\n}\n\nstatic int rtw_download_beacon(struct rtw_dev *rtwdev)\n{\n\tstruct ieee80211_hw *hw = rtwdev->hw;\n\tstruct rtw_rsvd_page *rsvd_pkt;\n\tstruct sk_buff *skb;\n\tint ret = 0;\n\n\trsvd_pkt = list_first_entry_or_null(&rtwdev->rsvd_page_list,\n\t\t\t\t\t    struct rtw_rsvd_page, build_list);\n\tif (!rsvd_pkt) {\n\t\trtw_err(rtwdev, \"failed to get rsvd page from build list\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tif (rsvd_pkt->type != RSVD_BEACON &&\n\t    rsvd_pkt->type != RSVD_DUMMY) {\n\t\trtw_err(rtwdev, \"invalid rsvd page type %d, should be beacon or dummy\\n\",\n\t\t\trsvd_pkt->type);\n\t\treturn -EINVAL;\n\t}\n\n\tskb = rtw_get_rsvd_page_skb(hw, rsvd_pkt);\n\tif (!skb) {\n\t\trtw_err(rtwdev, \"failed to get beacon skb\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = rtw_download_drv_rsvd_page(rtwdev, skb->data, skb->len);\n\tif (ret)\n\t\trtw_err(rtwdev, \"failed to download drv rsvd page\\n\");\n\n\tdev_kfree_skb(skb);\n\n\treturn ret;\n}\n\nint rtw_fw_download_rsvd_page(struct rtw_dev *rtwdev)\n{\n\tu8 *buf;\n\tu32 size;\n\tint ret;\n\n\tbuf = rtw_build_rsvd_page(rtwdev, &size);\n\tif (!buf) {\n\t\trtw_err(rtwdev, \"failed to build rsvd page pkt\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = rtw_download_drv_rsvd_page(rtwdev, buf, size);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to download drv rsvd page\\n\");\n\t\tgoto free;\n\t}\n\n\t \n\tret = rtw_download_beacon(rtwdev);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to download beacon\\n\");\n\t\tgoto free;\n\t}\n\nfree:\n\tkfree(buf);\n\n\treturn ret;\n}\n\nvoid rtw_fw_update_beacon_work(struct work_struct *work)\n{\n\tstruct rtw_dev *rtwdev = container_of(work, struct rtw_dev,\n\t\t\t\t\t      update_beacon_work);\n\n\tmutex_lock(&rtwdev->mutex);\n\trtw_fw_download_rsvd_page(rtwdev);\n\trtw_send_rsvd_page_h2c(rtwdev);\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nstatic void rtw_fw_read_fifo_page(struct rtw_dev *rtwdev, u32 offset, u32 size,\n\t\t\t\t  u32 *buf, u32 residue, u16 start_pg)\n{\n\tu32 i;\n\tu16 idx = 0;\n\tu16 ctl;\n\n\tctl = rtw_read16(rtwdev, REG_PKTBUF_DBG_CTRL) & 0xf000;\n\t \n\trtw_write32_set(rtwdev, REG_RCR, BIT_DISGCLK);\n\n\tdo {\n\t\trtw_write16(rtwdev, REG_PKTBUF_DBG_CTRL, start_pg | ctl);\n\n\t\tfor (i = FIFO_DUMP_ADDR + residue;\n\t\t     i < FIFO_DUMP_ADDR + FIFO_PAGE_SIZE; i += 4) {\n\t\t\tbuf[idx++] = rtw_read32(rtwdev, i);\n\t\t\tsize -= 4;\n\t\t\tif (size == 0)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tresidue = 0;\n\t\tstart_pg++;\n\t} while (size);\n\nout:\n\trtw_write16(rtwdev, REG_PKTBUF_DBG_CTRL, ctl);\n\t \n\trtw_write32_clr(rtwdev, REG_RCR, BIT_DISGCLK);\n}\n\nstatic void rtw_fw_read_fifo(struct rtw_dev *rtwdev, enum rtw_fw_fifo_sel sel,\n\t\t\t     u32 offset, u32 size, u32 *buf)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tu32 start_pg, residue;\n\n\tif (sel >= RTW_FW_FIFO_MAX) {\n\t\trtw_dbg(rtwdev, RTW_DBG_FW, \"wrong fw fifo sel\\n\");\n\t\treturn;\n\t}\n\tif (sel == RTW_FW_FIFO_SEL_RSVD_PAGE)\n\t\toffset += rtwdev->fifo.rsvd_boundary << TX_PAGE_SIZE_SHIFT;\n\tresidue = offset & (FIFO_PAGE_SIZE - 1);\n\tstart_pg = (offset >> FIFO_PAGE_SIZE_SHIFT) + chip->fw_fifo_addr[sel];\n\n\trtw_fw_read_fifo_page(rtwdev, offset, size, buf, residue, start_pg);\n}\n\nstatic bool rtw_fw_dump_check_size(struct rtw_dev *rtwdev,\n\t\t\t\t   enum rtw_fw_fifo_sel sel,\n\t\t\t\t   u32 start_addr, u32 size)\n{\n\tswitch (sel) {\n\tcase RTW_FW_FIFO_SEL_TX:\n\tcase RTW_FW_FIFO_SEL_RX:\n\t\tif ((start_addr + size) > rtwdev->chip->fw_fifo_addr[sel])\n\t\t\treturn false;\n\t\tfallthrough;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nint rtw_fw_dump_fifo(struct rtw_dev *rtwdev, u8 fifo_sel, u32 addr, u32 size,\n\t\t     u32 *buffer)\n{\n\tif (!rtwdev->chip->fw_fifo_addr[0]) {\n\t\trtw_dbg(rtwdev, RTW_DBG_FW, \"chip not support dump fw fifo\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tif (size == 0 || !buffer)\n\t\treturn -EINVAL;\n\n\tif (size & 0x3) {\n\t\trtw_dbg(rtwdev, RTW_DBG_FW, \"not 4byte alignment\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!rtw_fw_dump_check_size(rtwdev, fifo_sel, addr, size)) {\n\t\trtw_dbg(rtwdev, RTW_DBG_FW, \"fw fifo dump size overflow\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trtw_fw_read_fifo(rtwdev, fifo_sel, addr, size, buffer);\n\n\treturn 0;\n}\n\nstatic void __rtw_fw_update_pkt(struct rtw_dev *rtwdev, u8 pkt_id, u16 size,\n\t\t\t\tu8 location)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tu8 h2c_pkt[H2C_PKT_SIZE] = {0};\n\tu16 total_size = H2C_PKT_HDR_SIZE + H2C_PKT_UPDATE_PKT_LEN;\n\n\trtw_h2c_pkt_set_header(h2c_pkt, H2C_PKT_UPDATE_PKT);\n\n\tSET_PKT_H2C_TOTAL_LEN(h2c_pkt, total_size);\n\tUPDATE_PKT_SET_PKT_ID(h2c_pkt, pkt_id);\n\tUPDATE_PKT_SET_LOCATION(h2c_pkt, location);\n\n\t \n\tsize += chip->tx_pkt_desc_sz;\n\tUPDATE_PKT_SET_SIZE(h2c_pkt, size);\n\n\trtw_fw_send_h2c_packet(rtwdev, h2c_pkt);\n}\n\nvoid rtw_fw_update_pkt_probe_req(struct rtw_dev *rtwdev,\n\t\t\t\t struct cfg80211_ssid *ssid)\n{\n\tu8 loc;\n\tu16 size;\n\n\tloc = rtw_get_rsvd_page_probe_req_location(rtwdev, ssid);\n\tif (!loc) {\n\t\trtw_err(rtwdev, \"failed to get probe_req rsvd loc\\n\");\n\t\treturn;\n\t}\n\n\tsize = rtw_get_rsvd_page_probe_req_size(rtwdev, ssid);\n\tif (!size) {\n\t\trtw_err(rtwdev, \"failed to get probe_req rsvd size\\n\");\n\t\treturn;\n\t}\n\n\t__rtw_fw_update_pkt(rtwdev, RTW_PACKET_PROBE_REQ, size, loc);\n}\n\nvoid rtw_fw_channel_switch(struct rtw_dev *rtwdev, bool enable)\n{\n\tstruct rtw_pno_request *rtw_pno_req = &rtwdev->wow.pno_req;\n\tu8 h2c_pkt[H2C_PKT_SIZE] = {0};\n\tu16 total_size = H2C_PKT_HDR_SIZE + H2C_PKT_CH_SWITCH_LEN;\n\tu8 loc_ch_info;\n\tconst struct rtw_ch_switch_option cs_option = {\n\t\t.dest_ch_en = 1,\n\t\t.dest_ch = 1,\n\t\t.periodic_option = 2,\n\t\t.normal_period = 5,\n\t\t.normal_period_sel = 0,\n\t\t.normal_cycle = 10,\n\t\t.slow_period = 1,\n\t\t.slow_period_sel = 1,\n\t};\n\n\trtw_h2c_pkt_set_header(h2c_pkt, H2C_PKT_CH_SWITCH);\n\tSET_PKT_H2C_TOTAL_LEN(h2c_pkt, total_size);\n\n\tCH_SWITCH_SET_START(h2c_pkt, enable);\n\tCH_SWITCH_SET_DEST_CH_EN(h2c_pkt, cs_option.dest_ch_en);\n\tCH_SWITCH_SET_DEST_CH(h2c_pkt, cs_option.dest_ch);\n\tCH_SWITCH_SET_NORMAL_PERIOD(h2c_pkt, cs_option.normal_period);\n\tCH_SWITCH_SET_NORMAL_PERIOD_SEL(h2c_pkt, cs_option.normal_period_sel);\n\tCH_SWITCH_SET_SLOW_PERIOD(h2c_pkt, cs_option.slow_period);\n\tCH_SWITCH_SET_SLOW_PERIOD_SEL(h2c_pkt, cs_option.slow_period_sel);\n\tCH_SWITCH_SET_NORMAL_CYCLE(h2c_pkt, cs_option.normal_cycle);\n\tCH_SWITCH_SET_PERIODIC_OPT(h2c_pkt, cs_option.periodic_option);\n\n\tCH_SWITCH_SET_CH_NUM(h2c_pkt, rtw_pno_req->channel_cnt);\n\tCH_SWITCH_SET_INFO_SIZE(h2c_pkt, rtw_pno_req->channel_cnt * 4);\n\n\tloc_ch_info = rtw_get_rsvd_page_location(rtwdev, RSVD_CH_INFO);\n\tCH_SWITCH_SET_INFO_LOC(h2c_pkt, loc_ch_info);\n\n\trtw_fw_send_h2c_packet(rtwdev, h2c_pkt);\n}\n\nvoid rtw_fw_adaptivity(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tu8 h2c_pkt[H2C_PKT_SIZE] = {0};\n\n\tif (!rtw_edcca_enabled) {\n\t\tdm_info->edcca_mode = RTW_EDCCA_NORMAL;\n\t\trtw_dbg(rtwdev, RTW_DBG_ADAPTIVITY,\n\t\t\t\"EDCCA disabled by debugfs\\n\");\n\t}\n\n\tSET_H2C_CMD_ID_CLASS(h2c_pkt, H2C_CMD_ADAPTIVITY);\n\tSET_ADAPTIVITY_MODE(h2c_pkt, dm_info->edcca_mode);\n\tSET_ADAPTIVITY_OPTION(h2c_pkt, 1);\n\tSET_ADAPTIVITY_IGI(h2c_pkt, dm_info->igi_history[0]);\n\tSET_ADAPTIVITY_L2H(h2c_pkt, dm_info->l2h_th_ini);\n\tSET_ADAPTIVITY_DENSITY(h2c_pkt, dm_info->scan_density);\n\n\trtw_fw_send_h2c_command(rtwdev, h2c_pkt);\n}\n\nvoid rtw_fw_scan_notify(struct rtw_dev *rtwdev, bool start)\n{\n\tu8 h2c_pkt[H2C_PKT_SIZE] = {0};\n\n\tSET_H2C_CMD_ID_CLASS(h2c_pkt, H2C_CMD_SCAN);\n\tSET_SCAN_START(h2c_pkt, start);\n\n\trtw_fw_send_h2c_command(rtwdev, h2c_pkt);\n}\n\nstatic int rtw_append_probe_req_ie(struct rtw_dev *rtwdev, struct sk_buff *skb,\n\t\t\t\t   struct sk_buff_head *list, u8 *bands,\n\t\t\t\t   struct rtw_vif *rtwvif)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct ieee80211_scan_ies *ies = rtwvif->scan_ies;\n\tstruct sk_buff *new;\n\tu8 idx;\n\n\tfor (idx = NL80211_BAND_2GHZ; idx < NUM_NL80211_BANDS; idx++) {\n\t\tif (!(BIT(idx) & chip->band))\n\t\t\tcontinue;\n\t\tnew = skb_copy(skb, GFP_KERNEL);\n\t\tif (!new)\n\t\t\treturn -ENOMEM;\n\t\tskb_put_data(new, ies->ies[idx], ies->len[idx]);\n\t\tskb_put_data(new, ies->common_ies, ies->common_ie_len);\n\t\tskb_queue_tail(list, new);\n\t\t(*bands)++;\n\t}\n\n\treturn 0;\n}\n\nstatic int _rtw_hw_scan_update_probe_req(struct rtw_dev *rtwdev, u8 num_probes,\n\t\t\t\t\t struct sk_buff_head *probe_req_list)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct sk_buff *skb, *tmp;\n\tu8 page_offset = 1, *buf, page_size = chip->page_size;\n\tu16 pg_addr = rtwdev->fifo.rsvd_h2c_info_addr, loc;\n\tu16 buf_offset = page_size * page_offset;\n\tu8 tx_desc_sz = chip->tx_pkt_desc_sz;\n\tu8 page_cnt, pages;\n\tunsigned int pkt_len;\n\tint ret;\n\n\tif (rtw_fw_feature_ext_check(&rtwdev->fw, FW_FEATURE_EXT_OLD_PAGE_NUM))\n\t\tpage_cnt = RTW_OLD_PROBE_PG_CNT;\n\telse\n\t\tpage_cnt = RTW_PROBE_PG_CNT;\n\n\tpages = page_offset + num_probes * page_cnt;\n\n\tbuf = kzalloc(page_size * pages, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf_offset -= tx_desc_sz;\n\tskb_queue_walk_safe(probe_req_list, skb, tmp) {\n\t\tskb_unlink(skb, probe_req_list);\n\t\trtw_fill_rsvd_page_desc(rtwdev, skb, RSVD_PROBE_REQ);\n\t\tif (skb->len > page_size * page_cnt) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tmemcpy(buf + buf_offset, skb->data, skb->len);\n\t\tpkt_len = skb->len - tx_desc_sz;\n\t\tloc = pg_addr - rtwdev->fifo.rsvd_boundary + page_offset;\n\t\t__rtw_fw_update_pkt(rtwdev, RTW_PACKET_PROBE_REQ, pkt_len, loc);\n\n\t\tbuf_offset += page_cnt * page_size;\n\t\tpage_offset += page_cnt;\n\t\tkfree_skb(skb);\n\t}\n\n\tret = rtw_fw_write_data_rsvd_page(rtwdev, pg_addr, buf, buf_offset);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"Download probe request to firmware failed\\n\");\n\t\tgoto out;\n\t}\n\n\trtwdev->scan_info.probe_pg_size = page_offset;\nout:\n\tkfree(buf);\n\tskb_queue_walk_safe(probe_req_list, skb, tmp)\n\t\tkfree_skb(skb);\n\n\treturn ret;\n}\n\nstatic int rtw_hw_scan_update_probe_req(struct rtw_dev *rtwdev,\n\t\t\t\t\tstruct rtw_vif *rtwvif)\n{\n\tstruct cfg80211_scan_request *req = rtwvif->scan_req;\n\tstruct sk_buff_head list;\n\tstruct sk_buff *skb, *tmp;\n\tu8 num = req->n_ssids, i, bands = 0;\n\tint ret;\n\n\tskb_queue_head_init(&list);\n\tfor (i = 0; i < num; i++) {\n\t\tskb = ieee80211_probereq_get(rtwdev->hw, rtwvif->mac_addr,\n\t\t\t\t\t     req->ssids[i].ssid,\n\t\t\t\t\t     req->ssids[i].ssid_len,\n\t\t\t\t\t     req->ie_len);\n\t\tif (!skb) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = rtw_append_probe_req_ie(rtwdev, skb, &list, &bands,\n\t\t\t\t\t      rtwvif);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tkfree_skb(skb);\n\t}\n\n\treturn _rtw_hw_scan_update_probe_req(rtwdev, num * bands, &list);\n\nout:\n\tskb_queue_walk_safe(&list, skb, tmp)\n\t\tkfree_skb(skb);\n\n\treturn ret;\n}\n\nstatic int rtw_add_chan_info(struct rtw_dev *rtwdev, struct rtw_chan_info *info,\n\t\t\t     struct rtw_chan_list *list, u8 *buf)\n{\n\tu8 *chan = &buf[list->size];\n\tu8 info_size = RTW_CH_INFO_SIZE;\n\n\tif (list->size > list->buf_size)\n\t\treturn -ENOMEM;\n\n\tCH_INFO_SET_CH(chan, info->channel);\n\tCH_INFO_SET_PRI_CH_IDX(chan, info->pri_ch_idx);\n\tCH_INFO_SET_BW(chan, info->bw);\n\tCH_INFO_SET_TIMEOUT(chan, info->timeout);\n\tCH_INFO_SET_ACTION_ID(chan, info->action_id);\n\tCH_INFO_SET_EXTRA_INFO(chan, info->extra_info);\n\tif (info->extra_info) {\n\t\tEXTRA_CH_INFO_SET_ID(chan, RTW_SCAN_EXTRA_ID_DFS);\n\t\tEXTRA_CH_INFO_SET_INFO(chan, RTW_SCAN_EXTRA_ACTION_SCAN);\n\t\tEXTRA_CH_INFO_SET_SIZE(chan, RTW_EX_CH_INFO_SIZE -\n\t\t\t\t       RTW_EX_CH_INFO_HDR_SIZE);\n\t\tEXTRA_CH_INFO_SET_DFS_EXT_TIME(chan, RTW_DFS_CHAN_TIME);\n\t\tinfo_size += RTW_EX_CH_INFO_SIZE;\n\t}\n\tlist->size += info_size;\n\tlist->ch_num++;\n\n\treturn 0;\n}\n\nstatic int rtw_add_chan_list(struct rtw_dev *rtwdev, struct rtw_vif *rtwvif,\n\t\t\t     struct rtw_chan_list *list, u8 *buf)\n{\n\tstruct cfg80211_scan_request *req = rtwvif->scan_req;\n\tstruct rtw_fifo_conf *fifo = &rtwdev->fifo;\n\tstruct ieee80211_channel *channel;\n\tint i, ret = 0;\n\n\tfor (i = 0; i < req->n_channels; i++) {\n\t\tstruct rtw_chan_info ch_info = {0};\n\n\t\tchannel = req->channels[i];\n\t\tch_info.channel = channel->hw_value;\n\t\tch_info.bw = RTW_SCAN_WIDTH;\n\t\tch_info.pri_ch_idx = RTW_PRI_CH_IDX;\n\t\tch_info.timeout = req->duration_mandatory ?\n\t\t\t\t  req->duration : RTW_CHANNEL_TIME;\n\n\t\tif (channel->flags & (IEEE80211_CHAN_RADAR | IEEE80211_CHAN_NO_IR)) {\n\t\t\tch_info.action_id = RTW_CHANNEL_RADAR;\n\t\t\tch_info.extra_info = 1;\n\t\t\t \n\t\t\tch_info.timeout = ch_info.timeout > RTW_PASS_CHAN_TIME ?\n\t\t\t\t\t  ch_info.timeout : RTW_PASS_CHAN_TIME;\n\t\t} else {\n\t\t\tch_info.action_id = RTW_CHANNEL_ACTIVE;\n\t\t}\n\n\t\tret = rtw_add_chan_info(rtwdev, &ch_info, list, buf);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (list->size > fifo->rsvd_pg_num << TX_PAGE_SIZE_SHIFT) {\n\t\trtw_err(rtwdev, \"List exceeds rsvd page total size\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tlist->addr = fifo->rsvd_h2c_info_addr + rtwdev->scan_info.probe_pg_size;\n\tret = rtw_fw_write_data_rsvd_page(rtwdev, list->addr, buf, list->size);\n\tif (ret)\n\t\trtw_err(rtwdev, \"Download channel list failed\\n\");\n\n\treturn ret;\n}\n\nstatic void rtw_fw_set_scan_offload(struct rtw_dev *rtwdev,\n\t\t\t\t    struct rtw_ch_switch_option *opt,\n\t\t\t\t    struct rtw_vif *rtwvif,\n\t\t\t\t    struct rtw_chan_list *list)\n{\n\tstruct rtw_hw_scan_info *scan_info = &rtwdev->scan_info;\n\tstruct cfg80211_scan_request *req = rtwvif->scan_req;\n\tstruct rtw_fifo_conf *fifo = &rtwdev->fifo;\n\t \n\tu8 pkt_loc = fifo->rsvd_h2c_info_addr - fifo->rsvd_boundary + 1;\n\tbool random_seq = req->flags & NL80211_SCAN_FLAG_RANDOM_SN;\n\tu8 h2c_pkt[H2C_PKT_SIZE] = {0};\n\n\trtw_h2c_pkt_set_header(h2c_pkt, H2C_PKT_SCAN_OFFLOAD);\n\tSET_PKT_H2C_TOTAL_LEN(h2c_pkt, H2C_PKT_CH_SWITCH_LEN);\n\n\tSCAN_OFFLOAD_SET_START(h2c_pkt, opt->switch_en);\n\tSCAN_OFFLOAD_SET_BACK_OP_EN(h2c_pkt, opt->back_op_en);\n\tSCAN_OFFLOAD_SET_RANDOM_SEQ_EN(h2c_pkt, random_seq);\n\tSCAN_OFFLOAD_SET_NO_CCK_EN(h2c_pkt, req->no_cck);\n\tSCAN_OFFLOAD_SET_CH_NUM(h2c_pkt, list->ch_num);\n\tSCAN_OFFLOAD_SET_CH_INFO_SIZE(h2c_pkt, list->size);\n\tSCAN_OFFLOAD_SET_CH_INFO_LOC(h2c_pkt, list->addr - fifo->rsvd_boundary);\n\tSCAN_OFFLOAD_SET_OP_CH(h2c_pkt, scan_info->op_chan);\n\tSCAN_OFFLOAD_SET_OP_PRI_CH_IDX(h2c_pkt, scan_info->op_pri_ch_idx);\n\tSCAN_OFFLOAD_SET_OP_BW(h2c_pkt, scan_info->op_bw);\n\tSCAN_OFFLOAD_SET_OP_PORT_ID(h2c_pkt, rtwvif->port);\n\tSCAN_OFFLOAD_SET_OP_DWELL_TIME(h2c_pkt, req->duration_mandatory ?\n\t\t\t\t       req->duration : RTW_CHANNEL_TIME);\n\tSCAN_OFFLOAD_SET_OP_GAP_TIME(h2c_pkt, RTW_OFF_CHAN_TIME);\n\tSCAN_OFFLOAD_SET_SSID_NUM(h2c_pkt, req->n_ssids);\n\tSCAN_OFFLOAD_SET_PKT_LOC(h2c_pkt, pkt_loc);\n\n\trtw_fw_send_h2c_packet(rtwdev, h2c_pkt);\n}\n\nvoid rtw_hw_scan_start(struct rtw_dev *rtwdev, struct ieee80211_vif *vif,\n\t\t       struct ieee80211_scan_request *scan_req)\n{\n\tstruct rtw_vif *rtwvif = (struct rtw_vif *)vif->drv_priv;\n\tstruct cfg80211_scan_request *req = &scan_req->req;\n\tu8 mac_addr[ETH_ALEN];\n\n\trtwdev->scan_info.scanning_vif = vif;\n\trtwvif->scan_ies = &scan_req->ies;\n\trtwvif->scan_req = req;\n\n\tieee80211_stop_queues(rtwdev->hw);\n\trtw_leave_lps_deep(rtwdev);\n\trtw_hci_flush_all_queues(rtwdev, false);\n\trtw_mac_flush_all_queues(rtwdev, false);\n\tif (req->flags & NL80211_SCAN_FLAG_RANDOM_ADDR)\n\t\tget_random_mask_addr(mac_addr, req->mac_addr,\n\t\t\t\t     req->mac_addr_mask);\n\telse\n\t\tether_addr_copy(mac_addr, vif->addr);\n\n\trtw_core_scan_start(rtwdev, rtwvif, mac_addr, true);\n\n\trtwdev->hal.rcr &= ~BIT_CBSSID_BCN;\n\trtw_write32(rtwdev, REG_RCR, rtwdev->hal.rcr);\n}\n\nvoid rtw_hw_scan_complete(struct rtw_dev *rtwdev, struct ieee80211_vif *vif,\n\t\t\t  bool aborted)\n{\n\tstruct cfg80211_scan_info info = {\n\t\t.aborted = aborted,\n\t};\n\tstruct rtw_hw_scan_info *scan_info = &rtwdev->scan_info;\n\tstruct rtw_hal *hal = &rtwdev->hal;\n\tstruct rtw_vif *rtwvif;\n\tu8 chan = scan_info->op_chan;\n\n\tif (!vif)\n\t\treturn;\n\n\trtwdev->hal.rcr |= BIT_CBSSID_BCN;\n\trtw_write32(rtwdev, REG_RCR, rtwdev->hal.rcr);\n\n\trtw_core_scan_complete(rtwdev, vif, true);\n\n\trtwvif = (struct rtw_vif *)vif->drv_priv;\n\tif (chan)\n\t\trtw_store_op_chan(rtwdev, false);\n\trtw_phy_set_tx_power_level(rtwdev, hal->current_channel);\n\tieee80211_wake_queues(rtwdev->hw);\n\tieee80211_scan_completed(rtwdev->hw, &info);\n\n\trtwvif->scan_req = NULL;\n\trtwvif->scan_ies = NULL;\n\trtwdev->scan_info.scanning_vif = NULL;\n}\n\nstatic int rtw_hw_scan_prehandle(struct rtw_dev *rtwdev, struct rtw_vif *rtwvif,\n\t\t\t\t struct rtw_chan_list *list)\n{\n\tstruct cfg80211_scan_request *req = rtwvif->scan_req;\n\tint size = req->n_channels * (RTW_CH_INFO_SIZE + RTW_EX_CH_INFO_SIZE);\n\tu8 *buf;\n\tint ret;\n\n\tbuf = kmalloc(size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = rtw_hw_scan_update_probe_req(rtwdev, rtwvif);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"Update probe request failed\\n\");\n\t\tgoto out;\n\t}\n\n\tlist->buf_size = size;\n\tlist->size = 0;\n\tlist->ch_num = 0;\n\tret = rtw_add_chan_list(rtwdev, rtwvif, list, buf);\nout:\n\tkfree(buf);\n\n\treturn ret;\n}\n\nint rtw_hw_scan_offload(struct rtw_dev *rtwdev, struct ieee80211_vif *vif,\n\t\t\tbool enable)\n{\n\tstruct rtw_vif *rtwvif = vif ? (struct rtw_vif *)vif->drv_priv : NULL;\n\tstruct rtw_hw_scan_info *scan_info = &rtwdev->scan_info;\n\tstruct rtw_ch_switch_option cs_option = {0};\n\tstruct rtw_chan_list chan_list = {0};\n\tint ret = 0;\n\n\tif (!rtwvif)\n\t\treturn -EINVAL;\n\n\tcs_option.switch_en = enable;\n\tcs_option.back_op_en = scan_info->op_chan != 0;\n\tif (enable) {\n\t\tret = rtw_hw_scan_prehandle(rtwdev, rtwvif, &chan_list);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\trtw_fw_set_scan_offload(rtwdev, &cs_option, rtwvif, &chan_list);\nout:\n\tif (rtwdev->ap_active) {\n\t\tret = rtw_download_beacon(rtwdev);\n\t\tif (ret)\n\t\t\trtw_err(rtwdev, \"HW scan download beacon failed\\n\");\n\t}\n\n\treturn ret;\n}\n\nvoid rtw_hw_scan_abort(struct rtw_dev *rtwdev)\n{\n\tstruct ieee80211_vif *vif = rtwdev->scan_info.scanning_vif;\n\n\tif (!rtw_fw_feature_check(&rtwdev->fw, FW_FEATURE_SCAN_OFFLOAD))\n\t\treturn;\n\n\trtw_hw_scan_offload(rtwdev, vif, false);\n\trtw_hw_scan_complete(rtwdev, vif, true);\n}\n\nvoid rtw_hw_scan_status_report(struct rtw_dev *rtwdev, struct sk_buff *skb)\n{\n\tstruct ieee80211_vif *vif = rtwdev->scan_info.scanning_vif;\n\tstruct rtw_c2h_cmd *c2h;\n\tbool aborted;\n\tu8 rc;\n\n\tif (!test_bit(RTW_FLAG_SCANNING, rtwdev->flags))\n\t\treturn;\n\n\tc2h = get_c2h_from_skb(skb);\n\trc = GET_SCAN_REPORT_RETURN_CODE(c2h->payload);\n\taborted = rc != RTW_SCAN_REPORT_SUCCESS;\n\trtw_hw_scan_complete(rtwdev, vif, aborted);\n\n\tif (aborted)\n\t\trtw_dbg(rtwdev, RTW_DBG_HW_SCAN, \"HW scan aborted with code: %d\\n\", rc);\n}\n\nvoid rtw_store_op_chan(struct rtw_dev *rtwdev, bool backup)\n{\n\tstruct rtw_hw_scan_info *scan_info = &rtwdev->scan_info;\n\tstruct rtw_hal *hal = &rtwdev->hal;\n\tu8 band;\n\n\tif (backup) {\n\t\tscan_info->op_chan = hal->current_channel;\n\t\tscan_info->op_bw = hal->current_band_width;\n\t\tscan_info->op_pri_ch_idx = hal->current_primary_channel_index;\n\t\tscan_info->op_pri_ch = hal->primary_channel;\n\t} else {\n\t\tband = scan_info->op_chan > 14 ? RTW_BAND_5G : RTW_BAND_2G;\n\t\trtw_update_channel(rtwdev, scan_info->op_chan,\n\t\t\t\t   scan_info->op_pri_ch,\n\t\t\t\t   band, scan_info->op_bw);\n\t}\n}\n\nvoid rtw_clear_op_chan(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_hw_scan_info *scan_info = &rtwdev->scan_info;\n\n\tscan_info->op_chan = 0;\n\tscan_info->op_bw = 0;\n\tscan_info->op_pri_ch_idx = 0;\n\tscan_info->op_pri_ch = 0;\n}\n\nstatic bool rtw_is_op_chan(struct rtw_dev *rtwdev, u8 channel)\n{\n\tstruct rtw_hw_scan_info *scan_info = &rtwdev->scan_info;\n\n\treturn channel == scan_info->op_chan;\n}\n\nvoid rtw_hw_scan_chan_switch(struct rtw_dev *rtwdev, struct sk_buff *skb)\n{\n\tstruct rtw_hal *hal = &rtwdev->hal;\n\tstruct rtw_c2h_cmd *c2h;\n\tenum rtw_scan_notify_id id;\n\tu8 chan, band, status;\n\n\tif (!test_bit(RTW_FLAG_SCANNING, rtwdev->flags))\n\t\treturn;\n\n\tc2h = get_c2h_from_skb(skb);\n\tchan = GET_CHAN_SWITCH_CENTRAL_CH(c2h->payload);\n\tid = GET_CHAN_SWITCH_ID(c2h->payload);\n\tstatus = GET_CHAN_SWITCH_STATUS(c2h->payload);\n\n\tif (id == RTW_SCAN_NOTIFY_ID_POSTSWITCH) {\n\t\tband = chan > 14 ? RTW_BAND_5G : RTW_BAND_2G;\n\t\trtw_update_channel(rtwdev, chan, chan, band,\n\t\t\t\t   RTW_CHANNEL_WIDTH_20);\n\t\tif (rtw_is_op_chan(rtwdev, chan)) {\n\t\t\trtw_store_op_chan(rtwdev, false);\n\t\t\tieee80211_wake_queues(rtwdev->hw);\n\t\t\trtw_core_enable_beacon(rtwdev, true);\n\t\t}\n\t} else if (id == RTW_SCAN_NOTIFY_ID_PRESWITCH) {\n\t\tif (IS_CH_5G_BAND(chan)) {\n\t\t\trtw_coex_switchband_notify(rtwdev, COEX_SWITCH_TO_5G);\n\t\t} else if (IS_CH_2G_BAND(chan)) {\n\t\t\tu8 chan_type;\n\n\t\t\tif (test_bit(RTW_FLAG_SCANNING, rtwdev->flags))\n\t\t\t\tchan_type = COEX_SWITCH_TO_24G;\n\t\t\telse\n\t\t\t\tchan_type = COEX_SWITCH_TO_24G_NOFORSCAN;\n\t\t\trtw_coex_switchband_notify(rtwdev, chan_type);\n\t\t}\n\t\t \n\t\tif (!rtw_is_op_chan(rtwdev, chan) &&\n\t\t    rtw_is_op_chan(rtwdev, hal->current_channel)) {\n\t\t\trtw_core_enable_beacon(rtwdev, false);\n\t\t\tieee80211_stop_queues(rtwdev->hw);\n\t\t}\n\t}\n\n\trtw_dbg(rtwdev, RTW_DBG_HW_SCAN,\n\t\t\"Chan switch: %x, id: %x, status: %x\\n\", chan, id, status);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}