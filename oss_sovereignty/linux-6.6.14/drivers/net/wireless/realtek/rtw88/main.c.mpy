{
  "module_name": "main.c",
  "hash_id": "5ca3c712ba4f3b1ca92bc04684cc5c634e68294f6a824b68b59877259282fc5c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtw88/main.c",
  "human_readable_source": "\n \n\n#include <linux/devcoredump.h>\n\n#include \"main.h\"\n#include \"regd.h\"\n#include \"fw.h\"\n#include \"ps.h\"\n#include \"sec.h\"\n#include \"mac.h\"\n#include \"coex.h\"\n#include \"phy.h\"\n#include \"reg.h\"\n#include \"efuse.h\"\n#include \"tx.h\"\n#include \"debug.h\"\n#include \"bf.h\"\n#include \"sar.h\"\n#include \"sdio.h\"\n\nbool rtw_disable_lps_deep_mode;\nEXPORT_SYMBOL(rtw_disable_lps_deep_mode);\nbool rtw_bf_support = true;\nunsigned int rtw_debug_mask;\nEXPORT_SYMBOL(rtw_debug_mask);\n \nbool rtw_edcca_enabled = true;\n\nmodule_param_named(disable_lps_deep, rtw_disable_lps_deep_mode, bool, 0644);\nmodule_param_named(support_bf, rtw_bf_support, bool, 0644);\nmodule_param_named(debug_mask, rtw_debug_mask, uint, 0644);\n\nMODULE_PARM_DESC(disable_lps_deep, \"Set Y to disable Deep PS\");\nMODULE_PARM_DESC(support_bf, \"Set Y to enable beamformee support\");\nMODULE_PARM_DESC(debug_mask, \"Debugging mask\");\n\nstatic struct ieee80211_channel rtw_channeltable_2g[] = {\n\t{.center_freq = 2412, .hw_value = 1,},\n\t{.center_freq = 2417, .hw_value = 2,},\n\t{.center_freq = 2422, .hw_value = 3,},\n\t{.center_freq = 2427, .hw_value = 4,},\n\t{.center_freq = 2432, .hw_value = 5,},\n\t{.center_freq = 2437, .hw_value = 6,},\n\t{.center_freq = 2442, .hw_value = 7,},\n\t{.center_freq = 2447, .hw_value = 8,},\n\t{.center_freq = 2452, .hw_value = 9,},\n\t{.center_freq = 2457, .hw_value = 10,},\n\t{.center_freq = 2462, .hw_value = 11,},\n\t{.center_freq = 2467, .hw_value = 12,},\n\t{.center_freq = 2472, .hw_value = 13,},\n\t{.center_freq = 2484, .hw_value = 14,},\n};\n\nstatic struct ieee80211_channel rtw_channeltable_5g[] = {\n\t{.center_freq = 5180, .hw_value = 36,},\n\t{.center_freq = 5200, .hw_value = 40,},\n\t{.center_freq = 5220, .hw_value = 44,},\n\t{.center_freq = 5240, .hw_value = 48,},\n\t{.center_freq = 5260, .hw_value = 52,},\n\t{.center_freq = 5280, .hw_value = 56,},\n\t{.center_freq = 5300, .hw_value = 60,},\n\t{.center_freq = 5320, .hw_value = 64,},\n\t{.center_freq = 5500, .hw_value = 100,},\n\t{.center_freq = 5520, .hw_value = 104,},\n\t{.center_freq = 5540, .hw_value = 108,},\n\t{.center_freq = 5560, .hw_value = 112,},\n\t{.center_freq = 5580, .hw_value = 116,},\n\t{.center_freq = 5600, .hw_value = 120,},\n\t{.center_freq = 5620, .hw_value = 124,},\n\t{.center_freq = 5640, .hw_value = 128,},\n\t{.center_freq = 5660, .hw_value = 132,},\n\t{.center_freq = 5680, .hw_value = 136,},\n\t{.center_freq = 5700, .hw_value = 140,},\n\t{.center_freq = 5720, .hw_value = 144,},\n\t{.center_freq = 5745, .hw_value = 149,},\n\t{.center_freq = 5765, .hw_value = 153,},\n\t{.center_freq = 5785, .hw_value = 157,},\n\t{.center_freq = 5805, .hw_value = 161,},\n\t{.center_freq = 5825, .hw_value = 165,\n\t .flags = IEEE80211_CHAN_NO_HT40MINUS},\n};\n\nstatic struct ieee80211_rate rtw_ratetable[] = {\n\t{.bitrate = 10, .hw_value = 0x00,},\n\t{.bitrate = 20, .hw_value = 0x01,},\n\t{.bitrate = 55, .hw_value = 0x02,},\n\t{.bitrate = 110, .hw_value = 0x03,},\n\t{.bitrate = 60, .hw_value = 0x04,},\n\t{.bitrate = 90, .hw_value = 0x05,},\n\t{.bitrate = 120, .hw_value = 0x06,},\n\t{.bitrate = 180, .hw_value = 0x07,},\n\t{.bitrate = 240, .hw_value = 0x08,},\n\t{.bitrate = 360, .hw_value = 0x09,},\n\t{.bitrate = 480, .hw_value = 0x0a,},\n\t{.bitrate = 540, .hw_value = 0x0b,},\n};\n\nstatic const struct ieee80211_iface_limit rtw_iface_limits[] = {\n\t{\n\t\t.max = 1,\n\t\t.types = BIT(NL80211_IFTYPE_STATION),\n\t},\n\t{\n\t\t.max = 1,\n\t\t.types = BIT(NL80211_IFTYPE_AP),\n\t}\n};\n\nstatic const struct ieee80211_iface_combination rtw_iface_combs[] = {\n\t{\n\t\t.limits = rtw_iface_limits,\n\t\t.n_limits = ARRAY_SIZE(rtw_iface_limits),\n\t\t.max_interfaces = 2,\n\t\t.num_different_channels = 1,\n\t}\n};\n\nu16 rtw_desc_to_bitrate(u8 desc_rate)\n{\n\tstruct ieee80211_rate rate;\n\n\tif (WARN(desc_rate >= ARRAY_SIZE(rtw_ratetable), \"invalid desc rate\\n\"))\n\t\treturn 0;\n\n\trate = rtw_ratetable[desc_rate];\n\n\treturn rate.bitrate;\n}\n\nstatic struct ieee80211_supported_band rtw_band_2ghz = {\n\t.band = NL80211_BAND_2GHZ,\n\n\t.channels = rtw_channeltable_2g,\n\t.n_channels = ARRAY_SIZE(rtw_channeltable_2g),\n\n\t.bitrates = rtw_ratetable,\n\t.n_bitrates = ARRAY_SIZE(rtw_ratetable),\n\n\t.ht_cap = {0},\n\t.vht_cap = {0},\n};\n\nstatic struct ieee80211_supported_band rtw_band_5ghz = {\n\t.band = NL80211_BAND_5GHZ,\n\n\t.channels = rtw_channeltable_5g,\n\t.n_channels = ARRAY_SIZE(rtw_channeltable_5g),\n\n\t \n\t.bitrates = rtw_ratetable + 4,\n\t.n_bitrates = ARRAY_SIZE(rtw_ratetable) - 4,\n\n\t.ht_cap = {0},\n\t.vht_cap = {0},\n};\n\nstruct rtw_watch_dog_iter_data {\n\tstruct rtw_dev *rtwdev;\n\tstruct rtw_vif *rtwvif;\n};\n\nstatic void rtw_dynamic_csi_rate(struct rtw_dev *rtwdev, struct rtw_vif *rtwvif)\n{\n\tstruct rtw_bf_info *bf_info = &rtwdev->bf_info;\n\tu8 fix_rate_enable = 0;\n\tu8 new_csi_rate_idx;\n\n\tif (rtwvif->bfee.role != RTW_BFEE_SU &&\n\t    rtwvif->bfee.role != RTW_BFEE_MU)\n\t\treturn;\n\n\trtw_chip_cfg_csi_rate(rtwdev, rtwdev->dm_info.min_rssi,\n\t\t\t      bf_info->cur_csi_rpt_rate,\n\t\t\t      fix_rate_enable, &new_csi_rate_idx);\n\n\tif (new_csi_rate_idx != bf_info->cur_csi_rpt_rate)\n\t\tbf_info->cur_csi_rpt_rate = new_csi_rate_idx;\n}\n\nstatic void rtw_vif_watch_dog_iter(void *data, struct ieee80211_vif *vif)\n{\n\tstruct rtw_watch_dog_iter_data *iter_data = data;\n\tstruct rtw_vif *rtwvif = (struct rtw_vif *)vif->drv_priv;\n\n\tif (vif->type == NL80211_IFTYPE_STATION)\n\t\tif (vif->cfg.assoc)\n\t\t\titer_data->rtwvif = rtwvif;\n\n\trtw_dynamic_csi_rate(iter_data->rtwdev, rtwvif);\n\n\trtwvif->stats.tx_unicast = 0;\n\trtwvif->stats.rx_unicast = 0;\n\trtwvif->stats.tx_cnt = 0;\n\trtwvif->stats.rx_cnt = 0;\n}\n\n \nstatic void rtw_watch_dog_work(struct work_struct *work)\n{\n\tstruct rtw_dev *rtwdev = container_of(work, struct rtw_dev,\n\t\t\t\t\t      watch_dog_work.work);\n\tstruct rtw_traffic_stats *stats = &rtwdev->stats;\n\tstruct rtw_watch_dog_iter_data data = {};\n\tbool busy_traffic = test_bit(RTW_FLAG_BUSY_TRAFFIC, rtwdev->flags);\n\tbool ps_active;\n\n\tmutex_lock(&rtwdev->mutex);\n\n\tif (!test_bit(RTW_FLAG_RUNNING, rtwdev->flags))\n\t\tgoto unlock;\n\n\tieee80211_queue_delayed_work(rtwdev->hw, &rtwdev->watch_dog_work,\n\t\t\t\t     RTW_WATCH_DOG_DELAY_TIME);\n\n\tif (rtwdev->stats.tx_cnt > 100 || rtwdev->stats.rx_cnt > 100)\n\t\tset_bit(RTW_FLAG_BUSY_TRAFFIC, rtwdev->flags);\n\telse\n\t\tclear_bit(RTW_FLAG_BUSY_TRAFFIC, rtwdev->flags);\n\n\trtw_coex_wl_status_check(rtwdev);\n\trtw_coex_query_bt_hid_list(rtwdev);\n\n\tif (busy_traffic != test_bit(RTW_FLAG_BUSY_TRAFFIC, rtwdev->flags))\n\t\trtw_coex_wl_status_change_notify(rtwdev, 0);\n\n\tif (stats->tx_cnt > RTW_LPS_THRESHOLD ||\n\t    stats->rx_cnt > RTW_LPS_THRESHOLD)\n\t\tps_active = true;\n\telse\n\t\tps_active = false;\n\n\tewma_tp_add(&stats->tx_ewma_tp,\n\t\t    (u32)(stats->tx_unicast >> RTW_TP_SHIFT));\n\tewma_tp_add(&stats->rx_ewma_tp,\n\t\t    (u32)(stats->rx_unicast >> RTW_TP_SHIFT));\n\tstats->tx_throughput = ewma_tp_read(&stats->tx_ewma_tp);\n\tstats->rx_throughput = ewma_tp_read(&stats->rx_ewma_tp);\n\n\t \n\tstats->tx_unicast = 0;\n\tstats->rx_unicast = 0;\n\tstats->tx_cnt = 0;\n\tstats->rx_cnt = 0;\n\n\tif (test_bit(RTW_FLAG_SCANNING, rtwdev->flags))\n\t\tgoto unlock;\n\n\t \n\trtw_leave_lps(rtwdev);\n\n\trtw_phy_dynamic_mechanism(rtwdev);\n\n\tdata.rtwdev = rtwdev;\n\t \n\trtw_iterate_vifs(rtwdev, rtw_vif_watch_dog_iter, &data);\n\n\t \n\tif (rtwdev->ps_enabled && data.rtwvif && !ps_active &&\n\t    !rtwdev->beacon_loss && !rtwdev->ap_active)\n\t\trtw_enter_lps(rtwdev, data.rtwvif->port);\n\n\trtwdev->watch_dog_cnt++;\n\nunlock:\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nstatic void rtw_c2h_work(struct work_struct *work)\n{\n\tstruct rtw_dev *rtwdev = container_of(work, struct rtw_dev, c2h_work);\n\tstruct sk_buff *skb, *tmp;\n\n\tskb_queue_walk_safe(&rtwdev->c2h_queue, skb, tmp) {\n\t\tskb_unlink(skb, &rtwdev->c2h_queue);\n\t\trtw_fw_c2h_cmd_handle(rtwdev, skb);\n\t\tdev_kfree_skb_any(skb);\n\t}\n}\n\nstatic void rtw_ips_work(struct work_struct *work)\n{\n\tstruct rtw_dev *rtwdev = container_of(work, struct rtw_dev, ips_work);\n\n\tmutex_lock(&rtwdev->mutex);\n\tif (rtwdev->hw->conf.flags & IEEE80211_CONF_IDLE)\n\t\trtw_enter_ips(rtwdev);\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nstatic u8 rtw_acquire_macid(struct rtw_dev *rtwdev)\n{\n\tunsigned long mac_id;\n\n\tmac_id = find_first_zero_bit(rtwdev->mac_id_map, RTW_MAX_MAC_ID_NUM);\n\tif (mac_id < RTW_MAX_MAC_ID_NUM)\n\t\tset_bit(mac_id, rtwdev->mac_id_map);\n\n\treturn mac_id;\n}\n\nstatic void rtw_sta_rc_work(struct work_struct *work)\n{\n\tstruct rtw_sta_info *si = container_of(work, struct rtw_sta_info,\n\t\t\t\t\t       rc_work);\n\tstruct rtw_dev *rtwdev = si->rtwdev;\n\n\tmutex_lock(&rtwdev->mutex);\n\trtw_update_sta_info(rtwdev, si, true);\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nint rtw_sta_add(struct rtw_dev *rtwdev, struct ieee80211_sta *sta,\n\t\tstruct ieee80211_vif *vif)\n{\n\tstruct rtw_sta_info *si = (struct rtw_sta_info *)sta->drv_priv;\n\tstruct rtw_vif *rtwvif = (struct rtw_vif *)vif->drv_priv;\n\tint i;\n\n\tsi->mac_id = rtw_acquire_macid(rtwdev);\n\tif (si->mac_id >= RTW_MAX_MAC_ID_NUM)\n\t\treturn -ENOSPC;\n\n\tif (vif->type == NL80211_IFTYPE_STATION && vif->cfg.assoc == 0)\n\t\trtwvif->mac_id = si->mac_id;\n\tsi->rtwdev = rtwdev;\n\tsi->sta = sta;\n\tsi->vif = vif;\n\tsi->init_ra_lv = 1;\n\tewma_rssi_init(&si->avg_rssi);\n\tfor (i = 0; i < ARRAY_SIZE(sta->txq); i++)\n\t\trtw_txq_init(rtwdev, sta->txq[i]);\n\tINIT_WORK(&si->rc_work, rtw_sta_rc_work);\n\n\trtw_update_sta_info(rtwdev, si, true);\n\trtw_fw_media_status_report(rtwdev, si->mac_id, true);\n\n\trtwdev->sta_cnt++;\n\trtwdev->beacon_loss = false;\n\trtw_dbg(rtwdev, RTW_DBG_STATE, \"sta %pM joined with macid %d\\n\",\n\t\tsta->addr, si->mac_id);\n\n\treturn 0;\n}\n\nvoid rtw_sta_remove(struct rtw_dev *rtwdev, struct ieee80211_sta *sta,\n\t\t    bool fw_exist)\n{\n\tstruct rtw_sta_info *si = (struct rtw_sta_info *)sta->drv_priv;\n\tint i;\n\n\tcancel_work_sync(&si->rc_work);\n\n\trtw_release_macid(rtwdev, si->mac_id);\n\tif (fw_exist)\n\t\trtw_fw_media_status_report(rtwdev, si->mac_id, false);\n\n\tfor (i = 0; i < ARRAY_SIZE(sta->txq); i++)\n\t\trtw_txq_cleanup(rtwdev, sta->txq[i]);\n\n\tkfree(si->mask);\n\n\trtwdev->sta_cnt--;\n\trtw_dbg(rtwdev, RTW_DBG_STATE, \"sta %pM with macid %d left\\n\",\n\t\tsta->addr, si->mac_id);\n}\n\nstruct rtw_fwcd_hdr {\n\tu32 item;\n\tu32 size;\n\tu32 padding1;\n\tu32 padding2;\n} __packed;\n\nstatic int rtw_fwcd_prep(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_fwcd_desc *desc = &rtwdev->fw.fwcd_desc;\n\tconst struct rtw_fwcd_segs *segs = chip->fwcd_segs;\n\tu32 prep_size = chip->fw_rxff_size + sizeof(struct rtw_fwcd_hdr);\n\tu8 i;\n\n\tif (segs) {\n\t\tprep_size += segs->num * sizeof(struct rtw_fwcd_hdr);\n\n\t\tfor (i = 0; i < segs->num; i++)\n\t\t\tprep_size += segs->segs[i];\n\t}\n\n\tdesc->data = vmalloc(prep_size);\n\tif (!desc->data)\n\t\treturn -ENOMEM;\n\n\tdesc->size = prep_size;\n\tdesc->next = desc->data;\n\n\treturn 0;\n}\n\nstatic u8 *rtw_fwcd_next(struct rtw_dev *rtwdev, u32 item, u32 size)\n{\n\tstruct rtw_fwcd_desc *desc = &rtwdev->fw.fwcd_desc;\n\tstruct rtw_fwcd_hdr *hdr;\n\tu8 *next;\n\n\tif (!desc->data) {\n\t\trtw_dbg(rtwdev, RTW_DBG_FW, \"fwcd isn't prepared successfully\\n\");\n\t\treturn NULL;\n\t}\n\n\tnext = desc->next + sizeof(struct rtw_fwcd_hdr);\n\tif (next - desc->data + size > desc->size) {\n\t\trtw_dbg(rtwdev, RTW_DBG_FW, \"fwcd isn't prepared enough\\n\");\n\t\treturn NULL;\n\t}\n\n\thdr = (struct rtw_fwcd_hdr *)(desc->next);\n\thdr->item = item;\n\thdr->size = size;\n\thdr->padding1 = 0x01234567;\n\thdr->padding2 = 0x89abcdef;\n\tdesc->next = next + size;\n\n\treturn next;\n}\n\nstatic void rtw_fwcd_dump(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_fwcd_desc *desc = &rtwdev->fw.fwcd_desc;\n\n\trtw_dbg(rtwdev, RTW_DBG_FW, \"dump fwcd\\n\");\n\n\t \n\tdev_coredumpv(rtwdev->dev, desc->data, desc->size, GFP_KERNEL);\n}\n\nstatic void rtw_fwcd_free(struct rtw_dev *rtwdev, bool free_self)\n{\n\tstruct rtw_fwcd_desc *desc = &rtwdev->fw.fwcd_desc;\n\n\tif (free_self) {\n\t\trtw_dbg(rtwdev, RTW_DBG_FW, \"free fwcd by self\\n\");\n\t\tvfree(desc->data);\n\t}\n\n\tdesc->data = NULL;\n\tdesc->next = NULL;\n}\n\nstatic int rtw_fw_dump_crash_log(struct rtw_dev *rtwdev)\n{\n\tu32 size = rtwdev->chip->fw_rxff_size;\n\tu32 *buf;\n\tu8 seq;\n\n\tbuf = (u32 *)rtw_fwcd_next(rtwdev, RTW_FWCD_TLV, size);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tif (rtw_fw_dump_fifo(rtwdev, RTW_FW_FIFO_SEL_RXBUF_FW, 0, size, buf)) {\n\t\trtw_dbg(rtwdev, RTW_DBG_FW, \"dump fw fifo fail\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (GET_FW_DUMP_LEN(buf) == 0) {\n\t\trtw_dbg(rtwdev, RTW_DBG_FW, \"fw crash dump's length is 0\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tseq = GET_FW_DUMP_SEQ(buf);\n\tif (seq > 0) {\n\t\trtw_dbg(rtwdev, RTW_DBG_FW,\n\t\t\t\"fw crash dump's seq is wrong: %d\\n\", seq);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nint rtw_dump_fw(struct rtw_dev *rtwdev, const u32 ocp_src, u32 size,\n\t\tu32 fwcd_item)\n{\n\tu32 rxff = rtwdev->chip->fw_rxff_size;\n\tu32 dump_size, done_size = 0;\n\tu8 *buf;\n\tint ret;\n\n\tbuf = rtw_fwcd_next(rtwdev, fwcd_item, size);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\twhile (size) {\n\t\tdump_size = size > rxff ? rxff : size;\n\n\t\tret = rtw_ddma_to_fw_fifo(rtwdev, ocp_src + done_size,\n\t\t\t\t\t  dump_size);\n\t\tif (ret) {\n\t\t\trtw_err(rtwdev,\n\t\t\t\t\"ddma fw 0x%x [+0x%x] to fw fifo fail\\n\",\n\t\t\t\tocp_src, done_size);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = rtw_fw_dump_fifo(rtwdev, RTW_FW_FIFO_SEL_RXBUF_FW, 0,\n\t\t\t\t       dump_size, (u32 *)(buf + done_size));\n\t\tif (ret) {\n\t\t\trtw_err(rtwdev,\n\t\t\t\t\"dump fw 0x%x [+0x%x] from fw fifo fail\\n\",\n\t\t\t\tocp_src, done_size);\n\t\t\treturn ret;\n\t\t}\n\n\t\tsize -= dump_size;\n\t\tdone_size += dump_size;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rtw_dump_fw);\n\nint rtw_dump_reg(struct rtw_dev *rtwdev, const u32 addr, const u32 size)\n{\n\tu8 *buf;\n\tu32 i;\n\n\tif (addr & 0x3) {\n\t\tWARN(1, \"should be 4-byte aligned, addr = 0x%08x\\n\", addr);\n\t\treturn -EINVAL;\n\t}\n\n\tbuf = rtw_fwcd_next(rtwdev, RTW_FWCD_REG, size);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < size; i += 4)\n\t\t*(u32 *)(buf + i) = rtw_read32(rtwdev, addr + i);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rtw_dump_reg);\n\nvoid rtw_vif_assoc_changed(struct rtw_vif *rtwvif,\n\t\t\t   struct ieee80211_bss_conf *conf)\n{\n\tstruct ieee80211_vif *vif = NULL;\n\n\tif (conf)\n\t\tvif = container_of(conf, struct ieee80211_vif, bss_conf);\n\n\tif (conf && vif->cfg.assoc) {\n\t\trtwvif->aid = vif->cfg.aid;\n\t\trtwvif->net_type = RTW_NET_MGD_LINKED;\n\t} else {\n\t\trtwvif->aid = 0;\n\t\trtwvif->net_type = RTW_NET_NO_LINK;\n\t}\n}\n\nstatic void rtw_reset_key_iter(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       struct ieee80211_sta *sta,\n\t\t\t       struct ieee80211_key_conf *key,\n\t\t\t       void *data)\n{\n\tstruct rtw_dev *rtwdev = (struct rtw_dev *)data;\n\tstruct rtw_sec_desc *sec = &rtwdev->sec;\n\n\trtw_sec_clear_cam(rtwdev, sec, key->hw_key_idx);\n}\n\nstatic void rtw_reset_sta_iter(void *data, struct ieee80211_sta *sta)\n{\n\tstruct rtw_dev *rtwdev = (struct rtw_dev *)data;\n\n\tif (rtwdev->sta_cnt == 0) {\n\t\trtw_warn(rtwdev, \"sta count before reset should not be 0\\n\");\n\t\treturn;\n\t}\n\trtw_sta_remove(rtwdev, sta, false);\n}\n\nstatic void rtw_reset_vif_iter(void *data, u8 *mac, struct ieee80211_vif *vif)\n{\n\tstruct rtw_dev *rtwdev = (struct rtw_dev *)data;\n\tstruct rtw_vif *rtwvif = (struct rtw_vif *)vif->drv_priv;\n\n\trtw_bf_disassoc(rtwdev, vif, NULL);\n\trtw_vif_assoc_changed(rtwvif, NULL);\n\trtw_txq_cleanup(rtwdev, vif->txq);\n}\n\nvoid rtw_fw_recovery(struct rtw_dev *rtwdev)\n{\n\tif (!test_bit(RTW_FLAG_RESTARTING, rtwdev->flags))\n\t\tieee80211_queue_work(rtwdev->hw, &rtwdev->fw_recovery_work);\n}\n\nstatic void __fw_recovery_work(struct rtw_dev *rtwdev)\n{\n\tint ret = 0;\n\n\tset_bit(RTW_FLAG_RESTARTING, rtwdev->flags);\n\tclear_bit(RTW_FLAG_RESTART_TRIGGERING, rtwdev->flags);\n\n\tret = rtw_fwcd_prep(rtwdev);\n\tif (ret)\n\t\tgoto free;\n\tret = rtw_fw_dump_crash_log(rtwdev);\n\tif (ret)\n\t\tgoto free;\n\tret = rtw_chip_dump_fw_crash(rtwdev);\n\tif (ret)\n\t\tgoto free;\n\n\trtw_fwcd_dump(rtwdev);\nfree:\n\trtw_fwcd_free(rtwdev, !!ret);\n\trtw_write8(rtwdev, REG_MCU_TST_CFG, 0);\n\n\tWARN(1, \"firmware crash, start reset and recover\\n\");\n\n\trcu_read_lock();\n\trtw_iterate_keys_rcu(rtwdev, NULL, rtw_reset_key_iter, rtwdev);\n\trcu_read_unlock();\n\trtw_iterate_stas_atomic(rtwdev, rtw_reset_sta_iter, rtwdev);\n\trtw_iterate_vifs_atomic(rtwdev, rtw_reset_vif_iter, rtwdev);\n\tbitmap_zero(rtwdev->hw_port, RTW_PORT_NUM);\n\trtw_enter_ips(rtwdev);\n}\n\nstatic void rtw_fw_recovery_work(struct work_struct *work)\n{\n\tstruct rtw_dev *rtwdev = container_of(work, struct rtw_dev,\n\t\t\t\t\t      fw_recovery_work);\n\n\tmutex_lock(&rtwdev->mutex);\n\t__fw_recovery_work(rtwdev);\n\tmutex_unlock(&rtwdev->mutex);\n\n\tieee80211_restart_hw(rtwdev->hw);\n}\n\nstruct rtw_txq_ba_iter_data {\n};\n\nstatic void rtw_txq_ba_iter(void *data, struct ieee80211_sta *sta)\n{\n\tstruct rtw_sta_info *si = (struct rtw_sta_info *)sta->drv_priv;\n\tint ret;\n\tu8 tid;\n\n\ttid = find_first_bit(si->tid_ba, IEEE80211_NUM_TIDS);\n\twhile (tid != IEEE80211_NUM_TIDS) {\n\t\tclear_bit(tid, si->tid_ba);\n\t\tret = ieee80211_start_tx_ba_session(sta, tid, 0);\n\t\tif (ret == -EINVAL) {\n\t\t\tstruct ieee80211_txq *txq;\n\t\t\tstruct rtw_txq *rtwtxq;\n\n\t\t\ttxq = sta->txq[tid];\n\t\t\trtwtxq = (struct rtw_txq *)txq->drv_priv;\n\t\t\tset_bit(RTW_TXQ_BLOCK_BA, &rtwtxq->flags);\n\t\t}\n\n\t\ttid = find_first_bit(si->tid_ba, IEEE80211_NUM_TIDS);\n\t}\n}\n\nstatic void rtw_txq_ba_work(struct work_struct *work)\n{\n\tstruct rtw_dev *rtwdev = container_of(work, struct rtw_dev, ba_work);\n\tstruct rtw_txq_ba_iter_data data;\n\n\trtw_iterate_stas_atomic(rtwdev, rtw_txq_ba_iter, &data);\n}\n\nvoid rtw_set_rx_freq_band(struct rtw_rx_pkt_stat *pkt_stat, u8 channel)\n{\n\tif (IS_CH_2G_BAND(channel))\n\t\tpkt_stat->band = NL80211_BAND_2GHZ;\n\telse if (IS_CH_5G_BAND(channel))\n\t\tpkt_stat->band = NL80211_BAND_5GHZ;\n\telse\n\t\treturn;\n\n\tpkt_stat->freq = ieee80211_channel_to_frequency(channel, pkt_stat->band);\n}\nEXPORT_SYMBOL(rtw_set_rx_freq_band);\n\nvoid rtw_set_dtim_period(struct rtw_dev *rtwdev, int dtim_period)\n{\n\trtw_write32_set(rtwdev, REG_TCR, BIT_TCR_UPDATE_TIMIE);\n\trtw_write8(rtwdev, REG_DTIM_COUNTER_ROOT, dtim_period - 1);\n}\n\nvoid rtw_update_channel(struct rtw_dev *rtwdev, u8 center_channel,\n\t\t\tu8 primary_channel, enum rtw_supported_band band,\n\t\t\tenum rtw_bandwidth bandwidth)\n{\n\tenum nl80211_band nl_band = rtw_hw_to_nl80211_band(band);\n\tstruct rtw_hal *hal = &rtwdev->hal;\n\tu8 *cch_by_bw = hal->cch_by_bw;\n\tu32 center_freq, primary_freq;\n\tenum rtw_sar_bands sar_band;\n\tu8 primary_channel_idx;\n\n\tcenter_freq = ieee80211_channel_to_frequency(center_channel, nl_band);\n\tprimary_freq = ieee80211_channel_to_frequency(primary_channel, nl_band);\n\n\t \n\tcch_by_bw[RTW_CHANNEL_WIDTH_20] = primary_channel;\n\n\t \n\tcch_by_bw[bandwidth] = center_channel;\n\n\tswitch (bandwidth) {\n\tcase RTW_CHANNEL_WIDTH_20:\n\tdefault:\n\t\tprimary_channel_idx = RTW_SC_DONT_CARE;\n\t\tbreak;\n\tcase RTW_CHANNEL_WIDTH_40:\n\t\tif (primary_freq > center_freq)\n\t\t\tprimary_channel_idx = RTW_SC_20_UPPER;\n\t\telse\n\t\t\tprimary_channel_idx = RTW_SC_20_LOWER;\n\t\tbreak;\n\tcase RTW_CHANNEL_WIDTH_80:\n\t\tif (primary_freq > center_freq) {\n\t\t\tif (primary_freq - center_freq == 10)\n\t\t\t\tprimary_channel_idx = RTW_SC_20_UPPER;\n\t\t\telse\n\t\t\t\tprimary_channel_idx = RTW_SC_20_UPMOST;\n\n\t\t\t \n\t\t\tcch_by_bw[RTW_CHANNEL_WIDTH_40] = center_channel + 4;\n\t\t} else {\n\t\t\tif (center_freq - primary_freq == 10)\n\t\t\t\tprimary_channel_idx = RTW_SC_20_LOWER;\n\t\t\telse\n\t\t\t\tprimary_channel_idx = RTW_SC_20_LOWEST;\n\n\t\t\t \n\t\t\tcch_by_bw[RTW_CHANNEL_WIDTH_40] = center_channel - 4;\n\t\t}\n\t\tbreak;\n\t}\n\n\tswitch (center_channel) {\n\tcase 1 ... 14:\n\t\tsar_band = RTW_SAR_BAND_0;\n\t\tbreak;\n\tcase 36 ... 64:\n\t\tsar_band = RTW_SAR_BAND_1;\n\t\tbreak;\n\tcase 100 ... 144:\n\t\tsar_band = RTW_SAR_BAND_3;\n\t\tbreak;\n\tcase 149 ... 177:\n\t\tsar_band = RTW_SAR_BAND_4;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"unknown ch(%u) to SAR band\\n\", center_channel);\n\t\tsar_band = RTW_SAR_BAND_0;\n\t\tbreak;\n\t}\n\n\thal->current_primary_channel_index = primary_channel_idx;\n\thal->current_band_width = bandwidth;\n\thal->primary_channel = primary_channel;\n\thal->current_channel = center_channel;\n\thal->current_band_type = band;\n\thal->sar_band = sar_band;\n}\n\nvoid rtw_get_channel_params(struct cfg80211_chan_def *chandef,\n\t\t\t    struct rtw_channel_params *chan_params)\n{\n\tstruct ieee80211_channel *channel = chandef->chan;\n\tenum nl80211_chan_width width = chandef->width;\n\tu32 primary_freq, center_freq;\n\tu8 center_chan;\n\tu8 bandwidth = RTW_CHANNEL_WIDTH_20;\n\n\tcenter_chan = channel->hw_value;\n\tprimary_freq = channel->center_freq;\n\tcenter_freq = chandef->center_freq1;\n\n\tswitch (width) {\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\tcase NL80211_CHAN_WIDTH_20:\n\t\tbandwidth = RTW_CHANNEL_WIDTH_20;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_40:\n\t\tbandwidth = RTW_CHANNEL_WIDTH_40;\n\t\tif (primary_freq > center_freq)\n\t\t\tcenter_chan -= 2;\n\t\telse\n\t\t\tcenter_chan += 2;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_80:\n\t\tbandwidth = RTW_CHANNEL_WIDTH_80;\n\t\tif (primary_freq > center_freq) {\n\t\t\tif (primary_freq - center_freq == 10)\n\t\t\t\tcenter_chan -= 2;\n\t\t\telse\n\t\t\t\tcenter_chan -= 6;\n\t\t} else {\n\t\t\tif (center_freq - primary_freq == 10)\n\t\t\t\tcenter_chan += 2;\n\t\t\telse\n\t\t\t\tcenter_chan += 6;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tcenter_chan = 0;\n\t\tbreak;\n\t}\n\n\tchan_params->center_chan = center_chan;\n\tchan_params->bandwidth = bandwidth;\n\tchan_params->primary_chan = channel->hw_value;\n}\n\nvoid rtw_set_channel(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct ieee80211_hw *hw = rtwdev->hw;\n\tstruct rtw_hal *hal = &rtwdev->hal;\n\tstruct rtw_channel_params ch_param;\n\tu8 center_chan, primary_chan, bandwidth, band;\n\n\trtw_get_channel_params(&hw->conf.chandef, &ch_param);\n\tif (WARN(ch_param.center_chan == 0, \"Invalid channel\\n\"))\n\t\treturn;\n\n\tcenter_chan = ch_param.center_chan;\n\tprimary_chan = ch_param.primary_chan;\n\tbandwidth = ch_param.bandwidth;\n\tband = ch_param.center_chan > 14 ? RTW_BAND_5G : RTW_BAND_2G;\n\n\trtw_update_channel(rtwdev, center_chan, primary_chan, band, bandwidth);\n\n\tif (rtwdev->scan_info.op_chan)\n\t\trtw_store_op_chan(rtwdev, true);\n\n\tchip->ops->set_channel(rtwdev, center_chan, bandwidth,\n\t\t\t       hal->current_primary_channel_index);\n\n\tif (hal->current_band_type == RTW_BAND_5G) {\n\t\trtw_coex_switchband_notify(rtwdev, COEX_SWITCH_TO_5G);\n\t} else {\n\t\tif (test_bit(RTW_FLAG_SCANNING, rtwdev->flags))\n\t\t\trtw_coex_switchband_notify(rtwdev, COEX_SWITCH_TO_24G);\n\t\telse\n\t\t\trtw_coex_switchband_notify(rtwdev, COEX_SWITCH_TO_24G_NOFORSCAN);\n\t}\n\n\trtw_phy_set_tx_power_level(rtwdev, center_chan);\n\n\t \n\tif (!test_bit(RTW_FLAG_SCANNING, rtwdev->flags))\n\t\trtwdev->need_rfk = true;\n}\n\nvoid rtw_chip_prepare_tx(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\n\tif (rtwdev->need_rfk) {\n\t\trtwdev->need_rfk = false;\n\t\tchip->ops->phy_calibration(rtwdev);\n\t}\n}\n\nstatic void rtw_vif_write_addr(struct rtw_dev *rtwdev, u32 start, u8 *addr)\n{\n\tint i;\n\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\trtw_write8(rtwdev, start + i, addr[i]);\n}\n\nvoid rtw_vif_port_config(struct rtw_dev *rtwdev,\n\t\t\t struct rtw_vif *rtwvif,\n\t\t\t u32 config)\n{\n\tu32 addr, mask;\n\n\tif (config & PORT_SET_MAC_ADDR) {\n\t\taddr = rtwvif->conf->mac_addr.addr;\n\t\trtw_vif_write_addr(rtwdev, addr, rtwvif->mac_addr);\n\t}\n\tif (config & PORT_SET_BSSID) {\n\t\taddr = rtwvif->conf->bssid.addr;\n\t\trtw_vif_write_addr(rtwdev, addr, rtwvif->bssid);\n\t}\n\tif (config & PORT_SET_NET_TYPE) {\n\t\taddr = rtwvif->conf->net_type.addr;\n\t\tmask = rtwvif->conf->net_type.mask;\n\t\trtw_write32_mask(rtwdev, addr, mask, rtwvif->net_type);\n\t}\n\tif (config & PORT_SET_AID) {\n\t\taddr = rtwvif->conf->aid.addr;\n\t\tmask = rtwvif->conf->aid.mask;\n\t\trtw_write32_mask(rtwdev, addr, mask, rtwvif->aid);\n\t}\n\tif (config & PORT_SET_BCN_CTRL) {\n\t\taddr = rtwvif->conf->bcn_ctrl.addr;\n\t\tmask = rtwvif->conf->bcn_ctrl.mask;\n\t\trtw_write8_mask(rtwdev, addr, mask, rtwvif->bcn_ctrl);\n\t}\n}\n\nstatic u8 hw_bw_cap_to_bitamp(u8 bw_cap)\n{\n\tu8 bw = 0;\n\n\tswitch (bw_cap) {\n\tcase EFUSE_HW_CAP_IGNORE:\n\tcase EFUSE_HW_CAP_SUPP_BW80:\n\t\tbw |= BIT(RTW_CHANNEL_WIDTH_80);\n\t\tfallthrough;\n\tcase EFUSE_HW_CAP_SUPP_BW40:\n\t\tbw |= BIT(RTW_CHANNEL_WIDTH_40);\n\t\tfallthrough;\n\tdefault:\n\t\tbw |= BIT(RTW_CHANNEL_WIDTH_20);\n\t\tbreak;\n\t}\n\n\treturn bw;\n}\n\nstatic void rtw_hw_config_rf_ant_num(struct rtw_dev *rtwdev, u8 hw_ant_num)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_hal *hal = &rtwdev->hal;\n\n\tif (hw_ant_num == EFUSE_HW_CAP_IGNORE ||\n\t    hw_ant_num >= hal->rf_path_num)\n\t\treturn;\n\n\tswitch (hw_ant_num) {\n\tcase 1:\n\t\thal->rf_type = RF_1T1R;\n\t\thal->rf_path_num = 1;\n\t\tif (!chip->fix_rf_phy_num)\n\t\t\thal->rf_phy_num = hal->rf_path_num;\n\t\thal->antenna_tx = BB_PATH_A;\n\t\thal->antenna_rx = BB_PATH_A;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"invalid hw configuration from efuse\\n\");\n\t\tbreak;\n\t}\n}\n\nstatic u64 get_vht_ra_mask(struct ieee80211_sta *sta)\n{\n\tu64 ra_mask = 0;\n\tu16 mcs_map = le16_to_cpu(sta->deflink.vht_cap.vht_mcs.rx_mcs_map);\n\tu8 vht_mcs_cap;\n\tint i, nss;\n\n\t \n\tfor (i = 0, nss = 12; i < 4; i++, mcs_map >>= 2, nss += 10) {\n\t\tvht_mcs_cap = mcs_map & 0x3;\n\t\tswitch (vht_mcs_cap) {\n\t\tcase 2:  \n\t\t\tra_mask |= 0x3ffULL << nss;\n\t\t\tbreak;\n\t\tcase 1:  \n\t\t\tra_mask |= 0x1ffULL << nss;\n\t\t\tbreak;\n\t\tcase 0:  \n\t\t\tra_mask |= 0x0ffULL << nss;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ra_mask;\n}\n\nstatic u8 get_rate_id(u8 wireless_set, enum rtw_bandwidth bw_mode, u8 tx_num)\n{\n\tu8 rate_id = 0;\n\n\tswitch (wireless_set) {\n\tcase WIRELESS_CCK:\n\t\trate_id = RTW_RATEID_B_20M;\n\t\tbreak;\n\tcase WIRELESS_OFDM:\n\t\trate_id = RTW_RATEID_G;\n\t\tbreak;\n\tcase WIRELESS_CCK | WIRELESS_OFDM:\n\t\trate_id = RTW_RATEID_BG;\n\t\tbreak;\n\tcase WIRELESS_OFDM | WIRELESS_HT:\n\t\tif (tx_num == 1)\n\t\t\trate_id = RTW_RATEID_GN_N1SS;\n\t\telse if (tx_num == 2)\n\t\t\trate_id = RTW_RATEID_GN_N2SS;\n\t\telse if (tx_num == 3)\n\t\t\trate_id = RTW_RATEID_ARFR5_N_3SS;\n\t\tbreak;\n\tcase WIRELESS_CCK | WIRELESS_OFDM | WIRELESS_HT:\n\t\tif (bw_mode == RTW_CHANNEL_WIDTH_40) {\n\t\t\tif (tx_num == 1)\n\t\t\t\trate_id = RTW_RATEID_BGN_40M_1SS;\n\t\t\telse if (tx_num == 2)\n\t\t\t\trate_id = RTW_RATEID_BGN_40M_2SS;\n\t\t\telse if (tx_num == 3)\n\t\t\t\trate_id = RTW_RATEID_ARFR5_N_3SS;\n\t\t\telse if (tx_num == 4)\n\t\t\t\trate_id = RTW_RATEID_ARFR7_N_4SS;\n\t\t} else {\n\t\t\tif (tx_num == 1)\n\t\t\t\trate_id = RTW_RATEID_BGN_20M_1SS;\n\t\t\telse if (tx_num == 2)\n\t\t\t\trate_id = RTW_RATEID_BGN_20M_2SS;\n\t\t\telse if (tx_num == 3)\n\t\t\t\trate_id = RTW_RATEID_ARFR5_N_3SS;\n\t\t\telse if (tx_num == 4)\n\t\t\t\trate_id = RTW_RATEID_ARFR7_N_4SS;\n\t\t}\n\t\tbreak;\n\tcase WIRELESS_OFDM | WIRELESS_VHT:\n\t\tif (tx_num == 1)\n\t\t\trate_id = RTW_RATEID_ARFR1_AC_1SS;\n\t\telse if (tx_num == 2)\n\t\t\trate_id = RTW_RATEID_ARFR0_AC_2SS;\n\t\telse if (tx_num == 3)\n\t\t\trate_id = RTW_RATEID_ARFR4_AC_3SS;\n\t\telse if (tx_num == 4)\n\t\t\trate_id = RTW_RATEID_ARFR6_AC_4SS;\n\t\tbreak;\n\tcase WIRELESS_CCK | WIRELESS_OFDM | WIRELESS_VHT:\n\t\tif (bw_mode >= RTW_CHANNEL_WIDTH_80) {\n\t\t\tif (tx_num == 1)\n\t\t\t\trate_id = RTW_RATEID_ARFR1_AC_1SS;\n\t\t\telse if (tx_num == 2)\n\t\t\t\trate_id = RTW_RATEID_ARFR0_AC_2SS;\n\t\t\telse if (tx_num == 3)\n\t\t\t\trate_id = RTW_RATEID_ARFR4_AC_3SS;\n\t\t\telse if (tx_num == 4)\n\t\t\t\trate_id = RTW_RATEID_ARFR6_AC_4SS;\n\t\t} else {\n\t\t\tif (tx_num == 1)\n\t\t\t\trate_id = RTW_RATEID_ARFR2_AC_2G_1SS;\n\t\t\telse if (tx_num == 2)\n\t\t\t\trate_id = RTW_RATEID_ARFR3_AC_2G_2SS;\n\t\t\telse if (tx_num == 3)\n\t\t\t\trate_id = RTW_RATEID_ARFR4_AC_3SS;\n\t\t\telse if (tx_num == 4)\n\t\t\t\trate_id = RTW_RATEID_ARFR6_AC_4SS;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn rate_id;\n}\n\n#define RA_MASK_CCK_RATES\t0x0000f\n#define RA_MASK_OFDM_RATES\t0x00ff0\n#define RA_MASK_HT_RATES_1SS\t(0xff000ULL << 0)\n#define RA_MASK_HT_RATES_2SS\t(0xff000ULL << 8)\n#define RA_MASK_HT_RATES_3SS\t(0xff000ULL << 16)\n#define RA_MASK_HT_RATES\t(RA_MASK_HT_RATES_1SS | \\\n\t\t\t\t RA_MASK_HT_RATES_2SS | \\\n\t\t\t\t RA_MASK_HT_RATES_3SS)\n#define RA_MASK_VHT_RATES_1SS\t(0x3ff000ULL << 0)\n#define RA_MASK_VHT_RATES_2SS\t(0x3ff000ULL << 10)\n#define RA_MASK_VHT_RATES_3SS\t(0x3ff000ULL << 20)\n#define RA_MASK_VHT_RATES\t(RA_MASK_VHT_RATES_1SS | \\\n\t\t\t\t RA_MASK_VHT_RATES_2SS | \\\n\t\t\t\t RA_MASK_VHT_RATES_3SS)\n#define RA_MASK_CCK_IN_BG\t0x00005\n#define RA_MASK_CCK_IN_HT\t0x00005\n#define RA_MASK_CCK_IN_VHT\t0x00005\n#define RA_MASK_OFDM_IN_VHT\t0x00010\n#define RA_MASK_OFDM_IN_HT_2G\t0x00010\n#define RA_MASK_OFDM_IN_HT_5G\t0x00030\n\nstatic u64 rtw_rate_mask_rssi(struct rtw_sta_info *si, u8 wireless_set)\n{\n\tu8 rssi_level = si->rssi_level;\n\n\tif (wireless_set == WIRELESS_CCK)\n\t\treturn 0xffffffffffffffffULL;\n\n\tif (rssi_level == 0)\n\t\treturn 0xffffffffffffffffULL;\n\telse if (rssi_level == 1)\n\t\treturn 0xfffffffffffffff0ULL;\n\telse if (rssi_level == 2)\n\t\treturn 0xffffffffffffefe0ULL;\n\telse if (rssi_level == 3)\n\t\treturn 0xffffffffffffcfc0ULL;\n\telse if (rssi_level == 4)\n\t\treturn 0xffffffffffff8f80ULL;\n\telse\n\t\treturn 0xffffffffffff0f00ULL;\n}\n\nstatic u64 rtw_rate_mask_recover(u64 ra_mask, u64 ra_mask_bak)\n{\n\tif ((ra_mask & ~(RA_MASK_CCK_RATES | RA_MASK_OFDM_RATES)) == 0)\n\t\tra_mask |= (ra_mask_bak & ~(RA_MASK_CCK_RATES | RA_MASK_OFDM_RATES));\n\n\tif (ra_mask == 0)\n\t\tra_mask |= (ra_mask_bak & (RA_MASK_CCK_RATES | RA_MASK_OFDM_RATES));\n\n\treturn ra_mask;\n}\n\nstatic u64 rtw_rate_mask_cfg(struct rtw_dev *rtwdev, struct rtw_sta_info *si,\n\t\t\t     u64 ra_mask, bool is_vht_enable)\n{\n\tstruct rtw_hal *hal = &rtwdev->hal;\n\tconst struct cfg80211_bitrate_mask *mask = si->mask;\n\tu64 cfg_mask = GENMASK_ULL(63, 0);\n\tu8 band;\n\n\tif (!si->use_cfg_mask)\n\t\treturn ra_mask;\n\n\tband = hal->current_band_type;\n\tif (band == RTW_BAND_2G) {\n\t\tband = NL80211_BAND_2GHZ;\n\t\tcfg_mask = mask->control[band].legacy;\n\t} else if (band == RTW_BAND_5G) {\n\t\tband = NL80211_BAND_5GHZ;\n\t\tcfg_mask = u64_encode_bits(mask->control[band].legacy,\n\t\t\t\t\t   RA_MASK_OFDM_RATES);\n\t}\n\n\tif (!is_vht_enable) {\n\t\tif (ra_mask & RA_MASK_HT_RATES_1SS)\n\t\t\tcfg_mask |= u64_encode_bits(mask->control[band].ht_mcs[0],\n\t\t\t\t\t\t    RA_MASK_HT_RATES_1SS);\n\t\tif (ra_mask & RA_MASK_HT_RATES_2SS)\n\t\t\tcfg_mask |= u64_encode_bits(mask->control[band].ht_mcs[1],\n\t\t\t\t\t\t    RA_MASK_HT_RATES_2SS);\n\t} else {\n\t\tif (ra_mask & RA_MASK_VHT_RATES_1SS)\n\t\t\tcfg_mask |= u64_encode_bits(mask->control[band].vht_mcs[0],\n\t\t\t\t\t\t    RA_MASK_VHT_RATES_1SS);\n\t\tif (ra_mask & RA_MASK_VHT_RATES_2SS)\n\t\t\tcfg_mask |= u64_encode_bits(mask->control[band].vht_mcs[1],\n\t\t\t\t\t\t    RA_MASK_VHT_RATES_2SS);\n\t}\n\n\tra_mask &= cfg_mask;\n\n\treturn ra_mask;\n}\n\nvoid rtw_update_sta_info(struct rtw_dev *rtwdev, struct rtw_sta_info *si,\n\t\t\t bool reset_ra_mask)\n{\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tstruct ieee80211_sta *sta = si->sta;\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\tstruct rtw_hal *hal = &rtwdev->hal;\n\tu8 wireless_set;\n\tu8 bw_mode;\n\tu8 rate_id;\n\tu8 rf_type = RF_1T1R;\n\tu8 stbc_en = 0;\n\tu8 ldpc_en = 0;\n\tu8 tx_num = 1;\n\tu64 ra_mask = 0;\n\tu64 ra_mask_bak = 0;\n\tbool is_vht_enable = false;\n\tbool is_support_sgi = false;\n\n\tif (sta->deflink.vht_cap.vht_supported) {\n\t\tis_vht_enable = true;\n\t\tra_mask |= get_vht_ra_mask(sta);\n\t\tif (sta->deflink.vht_cap.cap & IEEE80211_VHT_CAP_RXSTBC_MASK)\n\t\t\tstbc_en = VHT_STBC_EN;\n\t\tif (sta->deflink.vht_cap.cap & IEEE80211_VHT_CAP_RXLDPC)\n\t\t\tldpc_en = VHT_LDPC_EN;\n\t} else if (sta->deflink.ht_cap.ht_supported) {\n\t\tra_mask |= (sta->deflink.ht_cap.mcs.rx_mask[1] << 20) |\n\t\t\t   (sta->deflink.ht_cap.mcs.rx_mask[0] << 12);\n\t\tif (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_RX_STBC)\n\t\t\tstbc_en = HT_STBC_EN;\n\t\tif (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_LDPC_CODING)\n\t\t\tldpc_en = HT_LDPC_EN;\n\t}\n\n\tif (efuse->hw_cap.nss == 1 || rtwdev->hal.txrx_1ss)\n\t\tra_mask &= RA_MASK_VHT_RATES_1SS | RA_MASK_HT_RATES_1SS;\n\n\tif (hal->current_band_type == RTW_BAND_5G) {\n\t\tra_mask |= (u64)sta->deflink.supp_rates[NL80211_BAND_5GHZ] << 4;\n\t\tra_mask_bak = ra_mask;\n\t\tif (sta->deflink.vht_cap.vht_supported) {\n\t\t\tra_mask &= RA_MASK_VHT_RATES | RA_MASK_OFDM_IN_VHT;\n\t\t\twireless_set = WIRELESS_OFDM | WIRELESS_VHT;\n\t\t} else if (sta->deflink.ht_cap.ht_supported) {\n\t\t\tra_mask &= RA_MASK_HT_RATES | RA_MASK_OFDM_IN_HT_5G;\n\t\t\twireless_set = WIRELESS_OFDM | WIRELESS_HT;\n\t\t} else {\n\t\t\twireless_set = WIRELESS_OFDM;\n\t\t}\n\t\tdm_info->rrsr_val_init = RRSR_INIT_5G;\n\t} else if (hal->current_band_type == RTW_BAND_2G) {\n\t\tra_mask |= sta->deflink.supp_rates[NL80211_BAND_2GHZ];\n\t\tra_mask_bak = ra_mask;\n\t\tif (sta->deflink.vht_cap.vht_supported) {\n\t\t\tra_mask &= RA_MASK_VHT_RATES | RA_MASK_CCK_IN_VHT |\n\t\t\t\t   RA_MASK_OFDM_IN_VHT;\n\t\t\twireless_set = WIRELESS_CCK | WIRELESS_OFDM |\n\t\t\t\t       WIRELESS_HT | WIRELESS_VHT;\n\t\t} else if (sta->deflink.ht_cap.ht_supported) {\n\t\t\tra_mask &= RA_MASK_HT_RATES | RA_MASK_CCK_IN_HT |\n\t\t\t\t   RA_MASK_OFDM_IN_HT_2G;\n\t\t\twireless_set = WIRELESS_CCK | WIRELESS_OFDM |\n\t\t\t\t       WIRELESS_HT;\n\t\t} else if (sta->deflink.supp_rates[0] <= 0xf) {\n\t\t\twireless_set = WIRELESS_CCK;\n\t\t} else {\n\t\t\tra_mask &= RA_MASK_OFDM_RATES | RA_MASK_CCK_IN_BG;\n\t\t\twireless_set = WIRELESS_CCK | WIRELESS_OFDM;\n\t\t}\n\t\tdm_info->rrsr_val_init = RRSR_INIT_2G;\n\t} else {\n\t\trtw_err(rtwdev, \"Unknown band type\\n\");\n\t\tra_mask_bak = ra_mask;\n\t\twireless_set = 0;\n\t}\n\n\tswitch (sta->deflink.bandwidth) {\n\tcase IEEE80211_STA_RX_BW_80:\n\t\tbw_mode = RTW_CHANNEL_WIDTH_80;\n\t\tis_support_sgi = sta->deflink.vht_cap.vht_supported &&\n\t\t\t\t (sta->deflink.vht_cap.cap & IEEE80211_VHT_CAP_SHORT_GI_80);\n\t\tbreak;\n\tcase IEEE80211_STA_RX_BW_40:\n\t\tbw_mode = RTW_CHANNEL_WIDTH_40;\n\t\tis_support_sgi = sta->deflink.ht_cap.ht_supported &&\n\t\t\t\t (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_SGI_40);\n\t\tbreak;\n\tdefault:\n\t\tbw_mode = RTW_CHANNEL_WIDTH_20;\n\t\tis_support_sgi = sta->deflink.ht_cap.ht_supported &&\n\t\t\t\t (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_SGI_20);\n\t\tbreak;\n\t}\n\n\tif (sta->deflink.vht_cap.vht_supported && ra_mask & 0xffc00000) {\n\t\ttx_num = 2;\n\t\trf_type = RF_2T2R;\n\t} else if (sta->deflink.ht_cap.ht_supported && ra_mask & 0xfff00000) {\n\t\ttx_num = 2;\n\t\trf_type = RF_2T2R;\n\t}\n\n\trate_id = get_rate_id(wireless_set, bw_mode, tx_num);\n\n\tra_mask &= rtw_rate_mask_rssi(si, wireless_set);\n\tra_mask = rtw_rate_mask_recover(ra_mask, ra_mask_bak);\n\tra_mask = rtw_rate_mask_cfg(rtwdev, si, ra_mask, is_vht_enable);\n\n\tsi->bw_mode = bw_mode;\n\tsi->stbc_en = stbc_en;\n\tsi->ldpc_en = ldpc_en;\n\tsi->rf_type = rf_type;\n\tsi->sgi_enable = is_support_sgi;\n\tsi->vht_enable = is_vht_enable;\n\tsi->ra_mask = ra_mask;\n\tsi->rate_id = rate_id;\n\n\trtw_fw_send_ra_info(rtwdev, si, reset_ra_mask);\n}\n\nstatic int rtw_wait_firmware_completion(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_fw_state *fw;\n\n\tfw = &rtwdev->fw;\n\twait_for_completion(&fw->completion);\n\tif (!fw->firmware)\n\t\treturn -EINVAL;\n\n\tif (chip->wow_fw_name) {\n\t\tfw = &rtwdev->wow_fw;\n\t\twait_for_completion(&fw->completion);\n\t\tif (!fw->firmware)\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic enum rtw_lps_deep_mode rtw_update_lps_deep_mode(struct rtw_dev *rtwdev,\n\t\t\t\t\t\t       struct rtw_fw_state *fw)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\n\tif (rtw_disable_lps_deep_mode || !chip->lps_deep_mode_supported ||\n\t    !fw->feature)\n\t\treturn LPS_DEEP_MODE_NONE;\n\n\tif ((chip->lps_deep_mode_supported & BIT(LPS_DEEP_MODE_PG)) &&\n\t    rtw_fw_feature_check(fw, FW_FEATURE_PG))\n\t\treturn LPS_DEEP_MODE_PG;\n\n\tif ((chip->lps_deep_mode_supported & BIT(LPS_DEEP_MODE_LCLK)) &&\n\t    rtw_fw_feature_check(fw, FW_FEATURE_LCLK))\n\t\treturn LPS_DEEP_MODE_LCLK;\n\n\treturn LPS_DEEP_MODE_NONE;\n}\n\nstatic int rtw_power_on(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_fw_state *fw = &rtwdev->fw;\n\tbool wifi_only;\n\tint ret;\n\n\tret = rtw_hci_setup(rtwdev);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to setup hci\\n\");\n\t\tgoto err;\n\t}\n\n\t \n\tret = rtw_mac_power_on(rtwdev);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to power on mac\\n\");\n\t\tgoto err;\n\t}\n\n\tret = rtw_wait_firmware_completion(rtwdev);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to wait firmware completion\\n\");\n\t\tgoto err_off;\n\t}\n\n\tret = rtw_download_firmware(rtwdev, fw);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to download firmware\\n\");\n\t\tgoto err_off;\n\t}\n\n\t \n\tret = rtw_mac_init(rtwdev);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to configure mac\\n\");\n\t\tgoto err_off;\n\t}\n\n\tchip->ops->phy_set_param(rtwdev);\n\n\tret = rtw_hci_start(rtwdev);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to start hci\\n\");\n\t\tgoto err_off;\n\t}\n\n\t \n\trtw_fw_send_general_info(rtwdev);\n\trtw_fw_send_phydm_info(rtwdev);\n\n\twifi_only = !rtwdev->efuse.btcoex;\n\trtw_coex_power_on_setting(rtwdev);\n\trtw_coex_init_hw_config(rtwdev, wifi_only);\n\n\treturn 0;\n\nerr_off:\n\trtw_mac_power_off(rtwdev);\n\nerr:\n\treturn ret;\n}\n\nvoid rtw_core_fw_scan_notify(struct rtw_dev *rtwdev, bool start)\n{\n\tif (!rtw_fw_feature_check(&rtwdev->fw, FW_FEATURE_NOTIFY_SCAN))\n\t\treturn;\n\n\tif (start) {\n\t\trtw_fw_scan_notify(rtwdev, true);\n\t} else {\n\t\treinit_completion(&rtwdev->fw_scan_density);\n\t\trtw_fw_scan_notify(rtwdev, false);\n\t\tif (!wait_for_completion_timeout(&rtwdev->fw_scan_density,\n\t\t\t\t\t\t SCAN_NOTIFY_TIMEOUT))\n\t\t\trtw_warn(rtwdev, \"firmware failed to report density after scan\\n\");\n\t}\n}\n\nvoid rtw_core_scan_start(struct rtw_dev *rtwdev, struct rtw_vif *rtwvif,\n\t\t\t const u8 *mac_addr, bool hw_scan)\n{\n\tu32 config = 0;\n\tint ret = 0;\n\n\trtw_leave_lps(rtwdev);\n\n\tif (hw_scan && (rtwdev->hw->conf.flags & IEEE80211_CONF_IDLE)) {\n\t\tret = rtw_leave_ips(rtwdev);\n\t\tif (ret) {\n\t\t\trtw_err(rtwdev, \"failed to leave idle state\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tether_addr_copy(rtwvif->mac_addr, mac_addr);\n\tconfig |= PORT_SET_MAC_ADDR;\n\trtw_vif_port_config(rtwdev, rtwvif, config);\n\n\trtw_coex_scan_notify(rtwdev, COEX_SCAN_START);\n\trtw_core_fw_scan_notify(rtwdev, true);\n\n\tset_bit(RTW_FLAG_DIG_DISABLE, rtwdev->flags);\n\tset_bit(RTW_FLAG_SCANNING, rtwdev->flags);\n}\n\nvoid rtw_core_scan_complete(struct rtw_dev *rtwdev, struct ieee80211_vif *vif,\n\t\t\t    bool hw_scan)\n{\n\tstruct rtw_vif *rtwvif = vif ? (struct rtw_vif *)vif->drv_priv : NULL;\n\tu32 config = 0;\n\n\tif (!rtwvif)\n\t\treturn;\n\n\tclear_bit(RTW_FLAG_SCANNING, rtwdev->flags);\n\tclear_bit(RTW_FLAG_DIG_DISABLE, rtwdev->flags);\n\n\trtw_core_fw_scan_notify(rtwdev, false);\n\n\tether_addr_copy(rtwvif->mac_addr, vif->addr);\n\tconfig |= PORT_SET_MAC_ADDR;\n\trtw_vif_port_config(rtwdev, rtwvif, config);\n\n\trtw_coex_scan_notify(rtwdev, COEX_SCAN_FINISH);\n\n\tif (hw_scan && (rtwdev->hw->conf.flags & IEEE80211_CONF_IDLE))\n\t\tieee80211_queue_work(rtwdev->hw, &rtwdev->ips_work);\n}\n\nint rtw_core_start(struct rtw_dev *rtwdev)\n{\n\tint ret;\n\n\tret = rtw_power_on(rtwdev);\n\tif (ret)\n\t\treturn ret;\n\n\trtw_sec_enable_sec_engine(rtwdev);\n\n\trtwdev->lps_conf.deep_mode = rtw_update_lps_deep_mode(rtwdev, &rtwdev->fw);\n\trtwdev->lps_conf.wow_deep_mode = rtw_update_lps_deep_mode(rtwdev, &rtwdev->wow_fw);\n\n\t \n\trtw_write32(rtwdev, REG_RCR, rtwdev->hal.rcr);\n\n\tieee80211_queue_delayed_work(rtwdev->hw, &rtwdev->watch_dog_work,\n\t\t\t\t     RTW_WATCH_DOG_DELAY_TIME);\n\n\tset_bit(RTW_FLAG_RUNNING, rtwdev->flags);\n\n\treturn 0;\n}\n\nstatic void rtw_power_off(struct rtw_dev *rtwdev)\n{\n\trtw_hci_stop(rtwdev);\n\trtw_coex_power_off_setting(rtwdev);\n\trtw_mac_power_off(rtwdev);\n}\n\nvoid rtw_core_stop(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\n\tclear_bit(RTW_FLAG_RUNNING, rtwdev->flags);\n\tclear_bit(RTW_FLAG_FW_RUNNING, rtwdev->flags);\n\n\tmutex_unlock(&rtwdev->mutex);\n\n\tcancel_work_sync(&rtwdev->c2h_work);\n\tcancel_work_sync(&rtwdev->update_beacon_work);\n\tcancel_delayed_work_sync(&rtwdev->watch_dog_work);\n\tcancel_delayed_work_sync(&coex->bt_relink_work);\n\tcancel_delayed_work_sync(&coex->bt_reenable_work);\n\tcancel_delayed_work_sync(&coex->defreeze_work);\n\tcancel_delayed_work_sync(&coex->wl_remain_work);\n\tcancel_delayed_work_sync(&coex->bt_remain_work);\n\tcancel_delayed_work_sync(&coex->wl_connecting_work);\n\tcancel_delayed_work_sync(&coex->bt_multi_link_remain_work);\n\tcancel_delayed_work_sync(&coex->wl_ccklock_work);\n\n\tmutex_lock(&rtwdev->mutex);\n\n\trtw_power_off(rtwdev);\n}\n\nstatic void rtw_init_ht_cap(struct rtw_dev *rtwdev,\n\t\t\t    struct ieee80211_sta_ht_cap *ht_cap)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\n\tht_cap->ht_supported = true;\n\tht_cap->cap = 0;\n\tht_cap->cap |= IEEE80211_HT_CAP_SGI_20 |\n\t\t\tIEEE80211_HT_CAP_MAX_AMSDU |\n\t\t\t(1 << IEEE80211_HT_CAP_RX_STBC_SHIFT);\n\n\tif (rtw_chip_has_rx_ldpc(rtwdev))\n\t\tht_cap->cap |= IEEE80211_HT_CAP_LDPC_CODING;\n\tif (rtw_chip_has_tx_stbc(rtwdev))\n\t\tht_cap->cap |= IEEE80211_HT_CAP_TX_STBC;\n\n\tif (efuse->hw_cap.bw & BIT(RTW_CHANNEL_WIDTH_40))\n\t\tht_cap->cap |= IEEE80211_HT_CAP_SUP_WIDTH_20_40 |\n\t\t\t\tIEEE80211_HT_CAP_DSSSCCK40 |\n\t\t\t\tIEEE80211_HT_CAP_SGI_40;\n\tht_cap->ampdu_factor = IEEE80211_HT_MAX_AMPDU_64K;\n\tht_cap->ampdu_density = chip->ampdu_density;\n\tht_cap->mcs.tx_params = IEEE80211_HT_MCS_TX_DEFINED;\n\tif (efuse->hw_cap.nss > 1) {\n\t\tht_cap->mcs.rx_mask[0] = 0xFF;\n\t\tht_cap->mcs.rx_mask[1] = 0xFF;\n\t\tht_cap->mcs.rx_mask[4] = 0x01;\n\t\tht_cap->mcs.rx_highest = cpu_to_le16(300);\n\t} else {\n\t\tht_cap->mcs.rx_mask[0] = 0xFF;\n\t\tht_cap->mcs.rx_mask[1] = 0x00;\n\t\tht_cap->mcs.rx_mask[4] = 0x01;\n\t\tht_cap->mcs.rx_highest = cpu_to_le16(150);\n\t}\n}\n\nstatic void rtw_init_vht_cap(struct rtw_dev *rtwdev,\n\t\t\t     struct ieee80211_sta_vht_cap *vht_cap)\n{\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\tu16 mcs_map;\n\t__le16 highest;\n\n\tif (efuse->hw_cap.ptcl != EFUSE_HW_CAP_IGNORE &&\n\t    efuse->hw_cap.ptcl != EFUSE_HW_CAP_PTCL_VHT)\n\t\treturn;\n\n\tvht_cap->vht_supported = true;\n\tvht_cap->cap = IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_11454 |\n\t\t       IEEE80211_VHT_CAP_SHORT_GI_80 |\n\t\t       IEEE80211_VHT_CAP_RXSTBC_1 |\n\t\t       IEEE80211_VHT_CAP_HTC_VHT |\n\t\t       IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK |\n\t\t       0;\n\tif (rtwdev->hal.rf_path_num > 1)\n\t\tvht_cap->cap |= IEEE80211_VHT_CAP_TXSTBC;\n\tvht_cap->cap |= IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE |\n\t\t\tIEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE;\n\tvht_cap->cap |= (rtwdev->hal.bfee_sts_cap <<\n\t\t\tIEEE80211_VHT_CAP_BEAMFORMEE_STS_SHIFT);\n\n\tif (rtw_chip_has_rx_ldpc(rtwdev))\n\t\tvht_cap->cap |= IEEE80211_VHT_CAP_RXLDPC;\n\n\tmcs_map = IEEE80211_VHT_MCS_SUPPORT_0_9 << 0 |\n\t\t  IEEE80211_VHT_MCS_NOT_SUPPORTED << 4 |\n\t\t  IEEE80211_VHT_MCS_NOT_SUPPORTED << 6 |\n\t\t  IEEE80211_VHT_MCS_NOT_SUPPORTED << 8 |\n\t\t  IEEE80211_VHT_MCS_NOT_SUPPORTED << 10 |\n\t\t  IEEE80211_VHT_MCS_NOT_SUPPORTED << 12 |\n\t\t  IEEE80211_VHT_MCS_NOT_SUPPORTED << 14;\n\tif (efuse->hw_cap.nss > 1) {\n\t\thighest = cpu_to_le16(780);\n\t\tmcs_map |= IEEE80211_VHT_MCS_SUPPORT_0_9 << 2;\n\t} else {\n\t\thighest = cpu_to_le16(390);\n\t\tmcs_map |= IEEE80211_VHT_MCS_NOT_SUPPORTED << 2;\n\t}\n\n\tvht_cap->vht_mcs.rx_mcs_map = cpu_to_le16(mcs_map);\n\tvht_cap->vht_mcs.tx_mcs_map = cpu_to_le16(mcs_map);\n\tvht_cap->vht_mcs.rx_highest = highest;\n\tvht_cap->vht_mcs.tx_highest = highest;\n}\n\nstatic u16 rtw_get_max_scan_ie_len(struct rtw_dev *rtwdev)\n{\n\tu16 len;\n\n\tlen = rtwdev->chip->max_scan_ie_len;\n\n\tif (!rtw_fw_feature_check(&rtwdev->fw, FW_FEATURE_SCAN_OFFLOAD) &&\n\t    rtwdev->chip->id == RTW_CHIP_TYPE_8822C)\n\t\tlen = IEEE80211_MAX_DATA_LEN;\n\telse if (rtw_fw_feature_ext_check(&rtwdev->fw, FW_FEATURE_EXT_OLD_PAGE_NUM))\n\t\tlen -= RTW_OLD_PROBE_PG_CNT * TX_PAGE_SIZE;\n\n\treturn len;\n}\n\nstatic void rtw_set_supported_band(struct ieee80211_hw *hw,\n\t\t\t\t   const struct rtw_chip_info *chip)\n{\n\tstruct rtw_dev *rtwdev = hw->priv;\n\tstruct ieee80211_supported_band *sband;\n\n\tif (chip->band & RTW_BAND_2G) {\n\t\tsband = kmemdup(&rtw_band_2ghz, sizeof(*sband), GFP_KERNEL);\n\t\tif (!sband)\n\t\t\tgoto err_out;\n\t\tif (chip->ht_supported)\n\t\t\trtw_init_ht_cap(rtwdev, &sband->ht_cap);\n\t\thw->wiphy->bands[NL80211_BAND_2GHZ] = sband;\n\t}\n\n\tif (chip->band & RTW_BAND_5G) {\n\t\tsband = kmemdup(&rtw_band_5ghz, sizeof(*sband), GFP_KERNEL);\n\t\tif (!sband)\n\t\t\tgoto err_out;\n\t\tif (chip->ht_supported)\n\t\t\trtw_init_ht_cap(rtwdev, &sband->ht_cap);\n\t\tif (chip->vht_supported)\n\t\t\trtw_init_vht_cap(rtwdev, &sband->vht_cap);\n\t\thw->wiphy->bands[NL80211_BAND_5GHZ] = sband;\n\t}\n\n\treturn;\n\nerr_out:\n\trtw_err(rtwdev, \"failed to set supported band\\n\");\n}\n\nstatic void rtw_unset_supported_band(struct ieee80211_hw *hw,\n\t\t\t\t     const struct rtw_chip_info *chip)\n{\n\tkfree(hw->wiphy->bands[NL80211_BAND_2GHZ]);\n\tkfree(hw->wiphy->bands[NL80211_BAND_5GHZ]);\n}\n\nstatic void rtw_vif_smps_iter(void *data, u8 *mac,\n\t\t\t      struct ieee80211_vif *vif)\n{\n\tstruct rtw_dev *rtwdev = (struct rtw_dev *)data;\n\n\tif (vif->type != NL80211_IFTYPE_STATION || !vif->cfg.assoc)\n\t\treturn;\n\n\tif (rtwdev->hal.txrx_1ss)\n\t\tieee80211_request_smps(vif, 0, IEEE80211_SMPS_STATIC);\n\telse\n\t\tieee80211_request_smps(vif, 0, IEEE80211_SMPS_OFF);\n}\n\nvoid rtw_set_txrx_1ss(struct rtw_dev *rtwdev, bool txrx_1ss)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_hal *hal = &rtwdev->hal;\n\n\tif (!chip->ops->config_txrx_mode || rtwdev->hal.txrx_1ss == txrx_1ss)\n\t\treturn;\n\n\trtwdev->hal.txrx_1ss = txrx_1ss;\n\tif (txrx_1ss)\n\t\tchip->ops->config_txrx_mode(rtwdev, BB_PATH_A, BB_PATH_A, false);\n\telse\n\t\tchip->ops->config_txrx_mode(rtwdev, hal->antenna_tx,\n\t\t\t\t\t    hal->antenna_rx, false);\n\trtw_iterate_vifs_atomic(rtwdev, rtw_vif_smps_iter, rtwdev);\n}\n\nstatic void __update_firmware_feature(struct rtw_dev *rtwdev,\n\t\t\t\t      struct rtw_fw_state *fw)\n{\n\tu32 feature;\n\tconst struct rtw_fw_hdr *fw_hdr =\n\t\t\t\t(const struct rtw_fw_hdr *)fw->firmware->data;\n\n\tfeature = le32_to_cpu(fw_hdr->feature);\n\tfw->feature = feature & FW_FEATURE_SIG ? feature : 0;\n\n\tif (rtwdev->chip->id == RTW_CHIP_TYPE_8822C &&\n\t    RTW_FW_SUIT_VER_CODE(rtwdev->fw) < RTW_FW_VER_CODE(9, 9, 13))\n\t\tfw->feature_ext |= FW_FEATURE_EXT_OLD_PAGE_NUM;\n}\n\nstatic void __update_firmware_info(struct rtw_dev *rtwdev,\n\t\t\t\t   struct rtw_fw_state *fw)\n{\n\tconst struct rtw_fw_hdr *fw_hdr =\n\t\t\t\t(const struct rtw_fw_hdr *)fw->firmware->data;\n\n\tfw->h2c_version = le16_to_cpu(fw_hdr->h2c_fmt_ver);\n\tfw->version = le16_to_cpu(fw_hdr->version);\n\tfw->sub_version = fw_hdr->subversion;\n\tfw->sub_index = fw_hdr->subindex;\n\n\t__update_firmware_feature(rtwdev, fw);\n}\n\nstatic void __update_firmware_info_legacy(struct rtw_dev *rtwdev,\n\t\t\t\t\t  struct rtw_fw_state *fw)\n{\n\tstruct rtw_fw_hdr_legacy *legacy =\n\t\t\t\t(struct rtw_fw_hdr_legacy *)fw->firmware->data;\n\n\tfw->h2c_version = 0;\n\tfw->version = le16_to_cpu(legacy->version);\n\tfw->sub_version = legacy->subversion1;\n\tfw->sub_index = legacy->subversion2;\n}\n\nstatic void update_firmware_info(struct rtw_dev *rtwdev,\n\t\t\t\t struct rtw_fw_state *fw)\n{\n\tif (rtw_chip_wcpu_11n(rtwdev))\n\t\t__update_firmware_info_legacy(rtwdev, fw);\n\telse\n\t\t__update_firmware_info(rtwdev, fw);\n}\n\nstatic void rtw_load_firmware_cb(const struct firmware *firmware, void *context)\n{\n\tstruct rtw_fw_state *fw = context;\n\tstruct rtw_dev *rtwdev = fw->rtwdev;\n\n\tif (!firmware || !firmware->data) {\n\t\trtw_err(rtwdev, \"failed to request firmware\\n\");\n\t\tcomplete_all(&fw->completion);\n\t\treturn;\n\t}\n\n\tfw->firmware = firmware;\n\tupdate_firmware_info(rtwdev, fw);\n\tcomplete_all(&fw->completion);\n\n\trtw_info(rtwdev, \"%sFirmware version %u.%u.%u, H2C version %u\\n\",\n\t\t fw->type == RTW_WOWLAN_FW ? \"WOW \" : \"\",\n\t\t fw->version, fw->sub_version, fw->sub_index, fw->h2c_version);\n}\n\nstatic int rtw_load_firmware(struct rtw_dev *rtwdev, enum rtw_fw_type type)\n{\n\tconst char *fw_name;\n\tstruct rtw_fw_state *fw;\n\tint ret;\n\n\tswitch (type) {\n\tcase RTW_WOWLAN_FW:\n\t\tfw = &rtwdev->wow_fw;\n\t\tfw_name = rtwdev->chip->wow_fw_name;\n\t\tbreak;\n\n\tcase RTW_NORMAL_FW:\n\t\tfw = &rtwdev->fw;\n\t\tfw_name = rtwdev->chip->fw_name;\n\t\tbreak;\n\n\tdefault:\n\t\trtw_warn(rtwdev, \"unsupported firmware type\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tfw->type = type;\n\tfw->rtwdev = rtwdev;\n\tinit_completion(&fw->completion);\n\n\tret = request_firmware_nowait(THIS_MODULE, true, fw_name, rtwdev->dev,\n\t\t\t\t      GFP_KERNEL, fw, rtw_load_firmware_cb);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to async firmware request\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int rtw_chip_parameter_setup(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_hal *hal = &rtwdev->hal;\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\n\tswitch (rtw_hci_type(rtwdev)) {\n\tcase RTW_HCI_TYPE_PCIE:\n\t\trtwdev->hci.rpwm_addr = 0x03d9;\n\t\trtwdev->hci.cpwm_addr = 0x03da;\n\t\tbreak;\n\tcase RTW_HCI_TYPE_SDIO:\n\t\trtwdev->hci.rpwm_addr = REG_SDIO_HRPWM1;\n\t\trtwdev->hci.cpwm_addr = REG_SDIO_HCPWM1_V2;\n\t\tbreak;\n\tcase RTW_HCI_TYPE_USB:\n\t\trtwdev->hci.rpwm_addr = 0xfe58;\n\t\trtwdev->hci.cpwm_addr = 0xfe57;\n\t\tbreak;\n\tdefault:\n\t\trtw_err(rtwdev, \"unsupported hci type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\thal->chip_version = rtw_read32(rtwdev, REG_SYS_CFG1);\n\thal->cut_version = BIT_GET_CHIP_VER(hal->chip_version);\n\thal->mp_chip = (hal->chip_version & BIT_RTL_ID) ? 0 : 1;\n\tif (hal->chip_version & BIT_RF_TYPE_ID) {\n\t\thal->rf_type = RF_2T2R;\n\t\thal->rf_path_num = 2;\n\t\thal->antenna_tx = BB_PATH_AB;\n\t\thal->antenna_rx = BB_PATH_AB;\n\t} else {\n\t\thal->rf_type = RF_1T1R;\n\t\thal->rf_path_num = 1;\n\t\thal->antenna_tx = BB_PATH_A;\n\t\thal->antenna_rx = BB_PATH_A;\n\t}\n\thal->rf_phy_num = chip->fix_rf_phy_num ? chip->fix_rf_phy_num :\n\t\t\t  hal->rf_path_num;\n\n\tefuse->physical_size = chip->phy_efuse_size;\n\tefuse->logical_size = chip->log_efuse_size;\n\tefuse->protect_size = chip->ptct_efuse_size;\n\n\t \n\trtwdev->hal.rcr |= BIT_VHT_DACK;\n\n\thal->bfee_sts_cap = 3;\n\n\treturn 0;\n}\n\nstatic int rtw_chip_efuse_enable(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_fw_state *fw = &rtwdev->fw;\n\tint ret;\n\n\tret = rtw_hci_setup(rtwdev);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to setup hci\\n\");\n\t\tgoto err;\n\t}\n\n\tret = rtw_mac_power_on(rtwdev);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to power on mac\\n\");\n\t\tgoto err;\n\t}\n\n\trtw_write8(rtwdev, REG_C2HEVT, C2H_HW_FEATURE_DUMP);\n\n\twait_for_completion(&fw->completion);\n\tif (!fw->firmware) {\n\t\tret = -EINVAL;\n\t\trtw_err(rtwdev, \"failed to load firmware\\n\");\n\t\tgoto err;\n\t}\n\n\tret = rtw_download_firmware(rtwdev, fw);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to download firmware\\n\");\n\t\tgoto err_off;\n\t}\n\n\treturn 0;\n\nerr_off:\n\trtw_mac_power_off(rtwdev);\n\nerr:\n\treturn ret;\n}\n\nstatic int rtw_dump_hw_feature(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\tu8 hw_feature[HW_FEATURE_LEN];\n\tu8 id;\n\tu8 bw;\n\tint i;\n\n\tid = rtw_read8(rtwdev, REG_C2HEVT);\n\tif (id != C2H_HW_FEATURE_REPORT) {\n\t\trtw_err(rtwdev, \"failed to read hw feature report\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tfor (i = 0; i < HW_FEATURE_LEN; i++)\n\t\thw_feature[i] = rtw_read8(rtwdev, REG_C2HEVT + 2 + i);\n\n\trtw_write8(rtwdev, REG_C2HEVT, 0);\n\n\tbw = GET_EFUSE_HW_CAP_BW(hw_feature);\n\tefuse->hw_cap.bw = hw_bw_cap_to_bitamp(bw);\n\tefuse->hw_cap.hci = GET_EFUSE_HW_CAP_HCI(hw_feature);\n\tefuse->hw_cap.nss = GET_EFUSE_HW_CAP_NSS(hw_feature);\n\tefuse->hw_cap.ptcl = GET_EFUSE_HW_CAP_PTCL(hw_feature);\n\tefuse->hw_cap.ant_num = GET_EFUSE_HW_CAP_ANT_NUM(hw_feature);\n\n\trtw_hw_config_rf_ant_num(rtwdev, efuse->hw_cap.ant_num);\n\n\tif (efuse->hw_cap.nss == EFUSE_HW_CAP_IGNORE ||\n\t    efuse->hw_cap.nss > rtwdev->hal.rf_path_num)\n\t\tefuse->hw_cap.nss = rtwdev->hal.rf_path_num;\n\n\trtw_dbg(rtwdev, RTW_DBG_EFUSE,\n\t\t\"hw cap: hci=0x%02x, bw=0x%02x, ptcl=0x%02x, ant_num=%d, nss=%d\\n\",\n\t\tefuse->hw_cap.hci, efuse->hw_cap.bw, efuse->hw_cap.ptcl,\n\t\tefuse->hw_cap.ant_num, efuse->hw_cap.nss);\n\n\treturn 0;\n}\n\nstatic void rtw_chip_efuse_disable(struct rtw_dev *rtwdev)\n{\n\trtw_hci_stop(rtwdev);\n\trtw_mac_power_off(rtwdev);\n}\n\nstatic int rtw_chip_efuse_info_setup(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\tint ret;\n\n\tmutex_lock(&rtwdev->mutex);\n\n\t \n\tret = rtw_chip_efuse_enable(rtwdev);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = rtw_parse_efuse_map(rtwdev);\n\tif (ret)\n\t\tgoto out_disable;\n\n\tret = rtw_dump_hw_feature(rtwdev);\n\tif (ret)\n\t\tgoto out_disable;\n\n\tret = rtw_check_supported_rfe(rtwdev);\n\tif (ret)\n\t\tgoto out_disable;\n\n\tif (efuse->crystal_cap == 0xff)\n\t\tefuse->crystal_cap = 0;\n\tif (efuse->pa_type_2g == 0xff)\n\t\tefuse->pa_type_2g = 0;\n\tif (efuse->pa_type_5g == 0xff)\n\t\tefuse->pa_type_5g = 0;\n\tif (efuse->lna_type_2g == 0xff)\n\t\tefuse->lna_type_2g = 0;\n\tif (efuse->lna_type_5g == 0xff)\n\t\tefuse->lna_type_5g = 0;\n\tif (efuse->channel_plan == 0xff)\n\t\tefuse->channel_plan = 0x7f;\n\tif (efuse->rf_board_option == 0xff)\n\t\tefuse->rf_board_option = 0;\n\tif (efuse->bt_setting & BIT(0))\n\t\tefuse->share_ant = true;\n\tif (efuse->regd == 0xff)\n\t\tefuse->regd = 0;\n\tif (efuse->tx_bb_swing_setting_2g == 0xff)\n\t\tefuse->tx_bb_swing_setting_2g = 0;\n\tif (efuse->tx_bb_swing_setting_5g == 0xff)\n\t\tefuse->tx_bb_swing_setting_5g = 0;\n\n\tefuse->btcoex = (efuse->rf_board_option & 0xe0) == 0x20;\n\tefuse->ext_pa_2g = efuse->pa_type_2g & BIT(4) ? 1 : 0;\n\tefuse->ext_lna_2g = efuse->lna_type_2g & BIT(3) ? 1 : 0;\n\tefuse->ext_pa_5g = efuse->pa_type_5g & BIT(0) ? 1 : 0;\n\tefuse->ext_lna_2g = efuse->lna_type_5g & BIT(3) ? 1 : 0;\n\nout_disable:\n\trtw_chip_efuse_disable(rtwdev);\n\nout_unlock:\n\tmutex_unlock(&rtwdev->mutex);\n\treturn ret;\n}\n\nstatic int rtw_chip_board_info_setup(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_hal *hal = &rtwdev->hal;\n\tconst struct rtw_rfe_def *rfe_def = rtw_get_rfe_def(rtwdev);\n\n\tif (!rfe_def)\n\t\treturn -ENODEV;\n\n\trtw_phy_setup_phy_cond(rtwdev, hal->pkg_type);\n\n\trtw_phy_init_tx_power(rtwdev);\n\tif (rfe_def->agc_btg_tbl)\n\t\trtw_load_table(rtwdev, rfe_def->agc_btg_tbl);\n\trtw_load_table(rtwdev, rfe_def->phy_pg_tbl);\n\trtw_load_table(rtwdev, rfe_def->txpwr_lmt_tbl);\n\trtw_phy_tx_power_by_rate_config(hal);\n\trtw_phy_tx_power_limit_config(hal);\n\n\treturn 0;\n}\n\nint rtw_chip_info_setup(struct rtw_dev *rtwdev)\n{\n\tint ret;\n\n\tret = rtw_chip_parameter_setup(rtwdev);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to setup chip parameters\\n\");\n\t\tgoto err_out;\n\t}\n\n\tret = rtw_chip_efuse_info_setup(rtwdev);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to setup chip efuse info\\n\");\n\t\tgoto err_out;\n\t}\n\n\tret = rtw_chip_board_info_setup(rtwdev);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to setup chip board info\\n\");\n\t\tgoto err_out;\n\t}\n\n\treturn 0;\n\nerr_out:\n\treturn ret;\n}\nEXPORT_SYMBOL(rtw_chip_info_setup);\n\nstatic void rtw_stats_init(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_traffic_stats *stats = &rtwdev->stats;\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tint i;\n\n\tewma_tp_init(&stats->tx_ewma_tp);\n\tewma_tp_init(&stats->rx_ewma_tp);\n\n\tfor (i = 0; i < RTW_EVM_NUM; i++)\n\t\tewma_evm_init(&dm_info->ewma_evm[i]);\n\tfor (i = 0; i < RTW_SNR_NUM; i++)\n\t\tewma_snr_init(&dm_info->ewma_snr[i]);\n}\n\nint rtw_core_init(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tint ret;\n\n\tINIT_LIST_HEAD(&rtwdev->rsvd_page_list);\n\tINIT_LIST_HEAD(&rtwdev->txqs);\n\n\ttimer_setup(&rtwdev->tx_report.purge_timer,\n\t\t    rtw_tx_report_purge_timer, 0);\n\trtwdev->tx_wq = alloc_workqueue(\"rtw_tx_wq\", WQ_UNBOUND | WQ_HIGHPRI, 0);\n\tif (!rtwdev->tx_wq) {\n\t\trtw_warn(rtwdev, \"alloc_workqueue rtw_tx_wq failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tINIT_DELAYED_WORK(&rtwdev->watch_dog_work, rtw_watch_dog_work);\n\tINIT_DELAYED_WORK(&coex->bt_relink_work, rtw_coex_bt_relink_work);\n\tINIT_DELAYED_WORK(&coex->bt_reenable_work, rtw_coex_bt_reenable_work);\n\tINIT_DELAYED_WORK(&coex->defreeze_work, rtw_coex_defreeze_work);\n\tINIT_DELAYED_WORK(&coex->wl_remain_work, rtw_coex_wl_remain_work);\n\tINIT_DELAYED_WORK(&coex->bt_remain_work, rtw_coex_bt_remain_work);\n\tINIT_DELAYED_WORK(&coex->wl_connecting_work, rtw_coex_wl_connecting_work);\n\tINIT_DELAYED_WORK(&coex->bt_multi_link_remain_work,\n\t\t\t  rtw_coex_bt_multi_link_remain_work);\n\tINIT_DELAYED_WORK(&coex->wl_ccklock_work, rtw_coex_wl_ccklock_work);\n\tINIT_WORK(&rtwdev->tx_work, rtw_tx_work);\n\tINIT_WORK(&rtwdev->c2h_work, rtw_c2h_work);\n\tINIT_WORK(&rtwdev->ips_work, rtw_ips_work);\n\tINIT_WORK(&rtwdev->fw_recovery_work, rtw_fw_recovery_work);\n\tINIT_WORK(&rtwdev->update_beacon_work, rtw_fw_update_beacon_work);\n\tINIT_WORK(&rtwdev->ba_work, rtw_txq_ba_work);\n\tskb_queue_head_init(&rtwdev->c2h_queue);\n\tskb_queue_head_init(&rtwdev->coex.queue);\n\tskb_queue_head_init(&rtwdev->tx_report.queue);\n\n\tspin_lock_init(&rtwdev->txq_lock);\n\tspin_lock_init(&rtwdev->tx_report.q_lock);\n\n\tmutex_init(&rtwdev->mutex);\n\tmutex_init(&rtwdev->hal.tx_power_mutex);\n\n\tinit_waitqueue_head(&rtwdev->coex.wait);\n\tinit_completion(&rtwdev->lps_leave_check);\n\tinit_completion(&rtwdev->fw_scan_density);\n\n\trtwdev->sec.total_cam_num = 32;\n\trtwdev->hal.current_channel = 1;\n\trtwdev->dm_info.fix_rate = U8_MAX;\n\tset_bit(RTW_BC_MC_MACID, rtwdev->mac_id_map);\n\n\trtw_stats_init(rtwdev);\n\n\t \n\trtwdev->hal.rcr = BIT_APP_FCS | BIT_APP_MIC | BIT_APP_ICV |\n\t\t\t  BIT_PKTCTL_DLEN | BIT_HTC_LOC_CTRL | BIT_APP_PHYSTS |\n\t\t\t  BIT_AB | BIT_AM | BIT_APM;\n\n\tret = rtw_load_firmware(rtwdev, RTW_NORMAL_FW);\n\tif (ret) {\n\t\trtw_warn(rtwdev, \"no firmware loaded\\n\");\n\t\tgoto out;\n\t}\n\n\tif (chip->wow_fw_name) {\n\t\tret = rtw_load_firmware(rtwdev, RTW_WOWLAN_FW);\n\t\tif (ret) {\n\t\t\trtw_warn(rtwdev, \"no wow firmware loaded\\n\");\n\t\t\twait_for_completion(&rtwdev->fw.completion);\n\t\t\tif (rtwdev->fw.firmware)\n\t\t\t\trelease_firmware(rtwdev->fw.firmware);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\treturn 0;\n\nout:\n\tdestroy_workqueue(rtwdev->tx_wq);\n\treturn ret;\n}\nEXPORT_SYMBOL(rtw_core_init);\n\nvoid rtw_core_deinit(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_fw_state *fw = &rtwdev->fw;\n\tstruct rtw_fw_state *wow_fw = &rtwdev->wow_fw;\n\tstruct rtw_rsvd_page *rsvd_pkt, *tmp;\n\tunsigned long flags;\n\n\trtw_wait_firmware_completion(rtwdev);\n\n\tif (fw->firmware)\n\t\trelease_firmware(fw->firmware);\n\n\tif (wow_fw->firmware)\n\t\trelease_firmware(wow_fw->firmware);\n\n\tdestroy_workqueue(rtwdev->tx_wq);\n\ttimer_delete_sync(&rtwdev->tx_report.purge_timer);\n\tspin_lock_irqsave(&rtwdev->tx_report.q_lock, flags);\n\tskb_queue_purge(&rtwdev->tx_report.queue);\n\tspin_unlock_irqrestore(&rtwdev->tx_report.q_lock, flags);\n\tskb_queue_purge(&rtwdev->coex.queue);\n\tskb_queue_purge(&rtwdev->c2h_queue);\n\n\tlist_for_each_entry_safe(rsvd_pkt, tmp, &rtwdev->rsvd_page_list,\n\t\t\t\t build_list) {\n\t\tlist_del(&rsvd_pkt->build_list);\n\t\tkfree(rsvd_pkt);\n\t}\n\n\tmutex_destroy(&rtwdev->mutex);\n\tmutex_destroy(&rtwdev->hal.tx_power_mutex);\n}\nEXPORT_SYMBOL(rtw_core_deinit);\n\nint rtw_register_hw(struct rtw_dev *rtwdev, struct ieee80211_hw *hw)\n{\n\tstruct rtw_hal *hal = &rtwdev->hal;\n\tint max_tx_headroom = 0;\n\tint ret;\n\n\tmax_tx_headroom = rtwdev->chip->tx_pkt_desc_sz;\n\n\tif (rtw_hci_type(rtwdev) == RTW_HCI_TYPE_SDIO)\n\t\tmax_tx_headroom += RTW_SDIO_DATA_PTR_ALIGN;\n\n\thw->extra_tx_headroom = max_tx_headroom;\n\thw->queues = IEEE80211_NUM_ACS;\n\thw->txq_data_size = sizeof(struct rtw_txq);\n\thw->sta_data_size = sizeof(struct rtw_sta_info);\n\thw->vif_data_size = sizeof(struct rtw_vif);\n\n\tieee80211_hw_set(hw, SIGNAL_DBM);\n\tieee80211_hw_set(hw, RX_INCLUDES_FCS);\n\tieee80211_hw_set(hw, AMPDU_AGGREGATION);\n\tieee80211_hw_set(hw, MFP_CAPABLE);\n\tieee80211_hw_set(hw, REPORTS_TX_ACK_STATUS);\n\tieee80211_hw_set(hw, SUPPORTS_PS);\n\tieee80211_hw_set(hw, SUPPORTS_DYNAMIC_PS);\n\tieee80211_hw_set(hw, SUPPORT_FAST_XMIT);\n\tieee80211_hw_set(hw, SUPPORTS_AMSDU_IN_AMPDU);\n\tieee80211_hw_set(hw, HAS_RATE_CONTROL);\n\tieee80211_hw_set(hw, TX_AMSDU);\n\tieee80211_hw_set(hw, SINGLE_SCAN_ON_ALL_BANDS);\n\n\thw->wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |\n\t\t\t\t     BIT(NL80211_IFTYPE_AP) |\n\t\t\t\t     BIT(NL80211_IFTYPE_ADHOC) |\n\t\t\t\t     BIT(NL80211_IFTYPE_MESH_POINT);\n\thw->wiphy->available_antennas_tx = hal->antenna_tx;\n\thw->wiphy->available_antennas_rx = hal->antenna_rx;\n\n\thw->wiphy->flags |= WIPHY_FLAG_SUPPORTS_TDLS |\n\t\t\t    WIPHY_FLAG_TDLS_EXTERNAL_SETUP;\n\n\thw->wiphy->features |= NL80211_FEATURE_SCAN_RANDOM_MAC_ADDR;\n\thw->wiphy->max_scan_ssids = RTW_SCAN_MAX_SSIDS;\n\thw->wiphy->max_scan_ie_len = rtw_get_max_scan_ie_len(rtwdev);\n\n\tif (rtwdev->chip->id == RTW_CHIP_TYPE_8822C) {\n\t\thw->wiphy->iface_combinations = rtw_iface_combs;\n\t\thw->wiphy->n_iface_combinations = ARRAY_SIZE(rtw_iface_combs);\n\t}\n\n\twiphy_ext_feature_set(hw->wiphy, NL80211_EXT_FEATURE_CAN_REPLACE_PTK0);\n\twiphy_ext_feature_set(hw->wiphy, NL80211_EXT_FEATURE_SCAN_RANDOM_SN);\n\twiphy_ext_feature_set(hw->wiphy, NL80211_EXT_FEATURE_SET_SCAN_DWELL);\n\n#ifdef CONFIG_PM\n\thw->wiphy->wowlan = rtwdev->chip->wowlan_stub;\n\thw->wiphy->max_sched_scan_ssids = rtwdev->chip->max_sched_scan_ssids;\n#endif\n\trtw_set_supported_band(hw, rtwdev->chip);\n\tSET_IEEE80211_PERM_ADDR(hw, rtwdev->efuse.addr);\n\n\thw->wiphy->sar_capa = &rtw_sar_capa;\n\n\tret = rtw_regd_init(rtwdev);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to init regd\\n\");\n\t\treturn ret;\n\t}\n\n\tret = ieee80211_register_hw(hw);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to register hw\\n\");\n\t\treturn ret;\n\t}\n\n\tret = rtw_regd_hint(rtwdev);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to hint regd\\n\");\n\t\treturn ret;\n\t}\n\n\trtw_debugfs_init(rtwdev);\n\n\trtwdev->bf_info.bfer_mu_cnt = 0;\n\trtwdev->bf_info.bfer_su_cnt = 0;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rtw_register_hw);\n\nvoid rtw_unregister_hw(struct rtw_dev *rtwdev, struct ieee80211_hw *hw)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\n\tieee80211_unregister_hw(hw);\n\trtw_unset_supported_band(hw, chip);\n}\nEXPORT_SYMBOL(rtw_unregister_hw);\n\nstatic\nvoid rtw_swap_reg_nbytes(struct rtw_dev *rtwdev, const struct rtw_hw_reg *reg1,\n\t\t\t const struct rtw_hw_reg *reg2, u8 nbytes)\n{\n\tu8 i;\n\n\tfor (i = 0; i < nbytes; i++) {\n\t\tu8 v1 = rtw_read8(rtwdev, reg1->addr + i);\n\t\tu8 v2 = rtw_read8(rtwdev, reg2->addr + i);\n\n\t\trtw_write8(rtwdev, reg1->addr + i, v2);\n\t\trtw_write8(rtwdev, reg2->addr + i, v1);\n\t}\n}\n\nstatic\nvoid rtw_swap_reg_mask(struct rtw_dev *rtwdev, const struct rtw_hw_reg *reg1,\n\t\t       const struct rtw_hw_reg *reg2)\n{\n\tu32 v1, v2;\n\n\tv1 = rtw_read32_mask(rtwdev, reg1->addr, reg1->mask);\n\tv2 = rtw_read32_mask(rtwdev, reg2->addr, reg2->mask);\n\trtw_write32_mask(rtwdev, reg2->addr, reg2->mask, v1);\n\trtw_write32_mask(rtwdev, reg1->addr, reg1->mask, v2);\n}\n\nstruct rtw_iter_port_switch_data {\n\tstruct rtw_dev *rtwdev;\n\tstruct rtw_vif *rtwvif_ap;\n};\n\nstatic void rtw_port_switch_iter(void *data, struct ieee80211_vif *vif)\n{\n\tstruct rtw_iter_port_switch_data *iter_data = data;\n\tstruct rtw_dev *rtwdev = iter_data->rtwdev;\n\tstruct rtw_vif *rtwvif_target = (struct rtw_vif *)vif->drv_priv;\n\tstruct rtw_vif *rtwvif_ap = iter_data->rtwvif_ap;\n\tconst struct rtw_hw_reg *reg1, *reg2;\n\n\tif (rtwvif_target->port != RTW_PORT_0)\n\t\treturn;\n\n\trtw_dbg(rtwdev, RTW_DBG_STATE, \"AP port switch from %d -> %d\\n\",\n\t\trtwvif_ap->port, rtwvif_target->port);\n\n\t \n\trtw_leave_lps(rtwdev);\n\n\treg1 = &rtwvif_ap->conf->net_type;\n\treg2 = &rtwvif_target->conf->net_type;\n\trtw_swap_reg_mask(rtwdev, reg1, reg2);\n\n\treg1 = &rtwvif_ap->conf->mac_addr;\n\treg2 = &rtwvif_target->conf->mac_addr;\n\trtw_swap_reg_nbytes(rtwdev, reg1, reg2, ETH_ALEN);\n\n\treg1 = &rtwvif_ap->conf->bssid;\n\treg2 = &rtwvif_target->conf->bssid;\n\trtw_swap_reg_nbytes(rtwdev, reg1, reg2, ETH_ALEN);\n\n\treg1 = &rtwvif_ap->conf->bcn_ctrl;\n\treg2 = &rtwvif_target->conf->bcn_ctrl;\n\trtw_swap_reg_nbytes(rtwdev, reg1, reg2, 1);\n\n\tswap(rtwvif_target->port, rtwvif_ap->port);\n\tswap(rtwvif_target->conf, rtwvif_ap->conf);\n\n\trtw_fw_default_port(rtwdev, rtwvif_target);\n}\n\nvoid rtw_core_port_switch(struct rtw_dev *rtwdev, struct ieee80211_vif *vif)\n{\n\tstruct rtw_vif *rtwvif = (struct rtw_vif *)vif->drv_priv;\n\tstruct rtw_iter_port_switch_data iter_data;\n\n\tif (vif->type != NL80211_IFTYPE_AP || rtwvif->port == RTW_PORT_0)\n\t\treturn;\n\n\titer_data.rtwdev = rtwdev;\n\titer_data.rtwvif_ap = rtwvif;\n\trtw_iterate_vifs(rtwdev, rtw_port_switch_iter, &iter_data);\n}\n\nstatic void rtw_check_sta_active_iter(void *data, struct ieee80211_vif *vif)\n{\n\tstruct rtw_vif *rtwvif = (struct rtw_vif *)vif->drv_priv;\n\tbool *active = data;\n\n\tif (*active)\n\t\treturn;\n\n\tif (vif->type != NL80211_IFTYPE_STATION)\n\t\treturn;\n\n\tif (vif->cfg.assoc || !is_zero_ether_addr(rtwvif->bssid))\n\t\t*active = true;\n}\n\nbool rtw_core_check_sta_active(struct rtw_dev *rtwdev)\n{\n\tbool sta_active = false;\n\n\trtw_iterate_vifs(rtwdev, rtw_check_sta_active_iter, &sta_active);\n\n\treturn rtwdev->ap_active || sta_active;\n}\n\nvoid rtw_core_enable_beacon(struct rtw_dev *rtwdev, bool enable)\n{\n\tif (!rtwdev->ap_active)\n\t\treturn;\n\n\tif (enable) {\n\t\trtw_write32_set(rtwdev, REG_BCN_CTRL, BIT_EN_BCN_FUNCTION);\n\t\trtw_write32_clr(rtwdev, REG_TXPAUSE, BIT_HIGH_QUEUE);\n\t} else {\n\t\trtw_write32_clr(rtwdev, REG_BCN_CTRL, BIT_EN_BCN_FUNCTION);\n\t\trtw_write32_set(rtwdev, REG_TXPAUSE, BIT_HIGH_QUEUE);\n\t}\n}\n\nMODULE_AUTHOR(\"Realtek Corporation\");\nMODULE_DESCRIPTION(\"Realtek 802.11ac wireless core module\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}