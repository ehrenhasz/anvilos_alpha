{
  "module_name": "phy.c",
  "hash_id": "20ff509def4714e45ff798f9e7123a8ebe41299889887d2c19cfe4269415449a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtw88/phy.c",
  "human_readable_source": "\n \n\n#include <linux/bcd.h>\n\n#include \"main.h\"\n#include \"reg.h\"\n#include \"fw.h\"\n#include \"phy.h\"\n#include \"debug.h\"\n#include \"regd.h\"\n#include \"sar.h\"\n\nstruct phy_cfg_pair {\n\tu32 addr;\n\tu32 data;\n};\n\nunion phy_table_tile {\n\tstruct rtw_phy_cond cond;\n\tstruct phy_cfg_pair cfg;\n};\n\nstatic const u32 db_invert_table[12][8] = {\n\t{10,\t\t13,\t\t16,\t\t20,\n\t 25,\t\t32,\t\t40,\t\t50},\n\t{64,\t\t80,\t\t101,\t\t128,\n\t 160,\t\t201,\t\t256,\t\t318},\n\t{401,\t\t505,\t\t635,\t\t800,\n\t 1007,\t\t1268,\t\t1596,\t\t2010},\n\t{316,\t\t398,\t\t501,\t\t631,\n\t 794,\t\t1000,\t\t1259,\t\t1585},\n\t{1995,\t\t2512,\t\t3162,\t\t3981,\n\t 5012,\t\t6310,\t\t7943,\t\t10000},\n\t{12589,\t\t15849,\t\t19953,\t\t25119,\n\t 31623,\t\t39811,\t\t50119,\t\t63098},\n\t{79433,\t\t100000,\t\t125893,\t\t158489,\n\t 199526,\t251189,\t\t316228,\t\t398107},\n\t{501187,\t630957,\t\t794328,\t\t1000000,\n\t 1258925,\t1584893,\t1995262,\t2511886},\n\t{3162278,\t3981072,\t5011872,\t6309573,\n\t 7943282,\t1000000,\t12589254,\t15848932},\n\t{19952623,\t25118864,\t31622777,\t39810717,\n\t 50118723,\t63095734,\t79432823,\t100000000},\n\t{125892541,\t158489319,\t199526232,\t251188643,\n\t 316227766,\t398107171,\t501187234,\t630957345},\n\t{794328235,\t1000000000,\t1258925412,\t1584893192,\n\t 1995262315,\t2511886432U,\t3162277660U,\t3981071706U}\n};\n\nu8 rtw_cck_rates[] = { DESC_RATE1M, DESC_RATE2M, DESC_RATE5_5M, DESC_RATE11M };\nu8 rtw_ofdm_rates[] = {\n\tDESC_RATE6M,  DESC_RATE9M,  DESC_RATE12M,\n\tDESC_RATE18M, DESC_RATE24M, DESC_RATE36M,\n\tDESC_RATE48M, DESC_RATE54M\n};\nu8 rtw_ht_1s_rates[] = {\n\tDESC_RATEMCS0, DESC_RATEMCS1, DESC_RATEMCS2,\n\tDESC_RATEMCS3, DESC_RATEMCS4, DESC_RATEMCS5,\n\tDESC_RATEMCS6, DESC_RATEMCS7\n};\nu8 rtw_ht_2s_rates[] = {\n\tDESC_RATEMCS8,  DESC_RATEMCS9,  DESC_RATEMCS10,\n\tDESC_RATEMCS11, DESC_RATEMCS12, DESC_RATEMCS13,\n\tDESC_RATEMCS14, DESC_RATEMCS15\n};\nu8 rtw_vht_1s_rates[] = {\n\tDESC_RATEVHT1SS_MCS0, DESC_RATEVHT1SS_MCS1,\n\tDESC_RATEVHT1SS_MCS2, DESC_RATEVHT1SS_MCS3,\n\tDESC_RATEVHT1SS_MCS4, DESC_RATEVHT1SS_MCS5,\n\tDESC_RATEVHT1SS_MCS6, DESC_RATEVHT1SS_MCS7,\n\tDESC_RATEVHT1SS_MCS8, DESC_RATEVHT1SS_MCS9\n};\nu8 rtw_vht_2s_rates[] = {\n\tDESC_RATEVHT2SS_MCS0, DESC_RATEVHT2SS_MCS1,\n\tDESC_RATEVHT2SS_MCS2, DESC_RATEVHT2SS_MCS3,\n\tDESC_RATEVHT2SS_MCS4, DESC_RATEVHT2SS_MCS5,\n\tDESC_RATEVHT2SS_MCS6, DESC_RATEVHT2SS_MCS7,\n\tDESC_RATEVHT2SS_MCS8, DESC_RATEVHT2SS_MCS9\n};\nu8 *rtw_rate_section[RTW_RATE_SECTION_MAX] = {\n\trtw_cck_rates, rtw_ofdm_rates,\n\trtw_ht_1s_rates, rtw_ht_2s_rates,\n\trtw_vht_1s_rates, rtw_vht_2s_rates\n};\nEXPORT_SYMBOL(rtw_rate_section);\n\nu8 rtw_rate_size[RTW_RATE_SECTION_MAX] = {\n\tARRAY_SIZE(rtw_cck_rates),\n\tARRAY_SIZE(rtw_ofdm_rates),\n\tARRAY_SIZE(rtw_ht_1s_rates),\n\tARRAY_SIZE(rtw_ht_2s_rates),\n\tARRAY_SIZE(rtw_vht_1s_rates),\n\tARRAY_SIZE(rtw_vht_2s_rates)\n};\nEXPORT_SYMBOL(rtw_rate_size);\n\nstatic const u8 rtw_cck_size = ARRAY_SIZE(rtw_cck_rates);\nstatic const u8 rtw_ofdm_size = ARRAY_SIZE(rtw_ofdm_rates);\nstatic const u8 rtw_ht_1s_size = ARRAY_SIZE(rtw_ht_1s_rates);\nstatic const u8 rtw_ht_2s_size = ARRAY_SIZE(rtw_ht_2s_rates);\nstatic const u8 rtw_vht_1s_size = ARRAY_SIZE(rtw_vht_1s_rates);\nstatic const u8 rtw_vht_2s_size = ARRAY_SIZE(rtw_vht_2s_rates);\n\nenum rtw_phy_band_type {\n\tPHY_BAND_2G\t= 0,\n\tPHY_BAND_5G\t= 1,\n};\n\nstatic void rtw_phy_cck_pd_init(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tu8 i, j;\n\n\tfor (i = 0; i <= RTW_CHANNEL_WIDTH_40; i++) {\n\t\tfor (j = 0; j < RTW_RF_PATH_MAX; j++)\n\t\t\tdm_info->cck_pd_lv[i][j] = CCK_PD_LV0;\n\t}\n\n\tdm_info->cck_fa_avg = CCK_FA_AVG_RESET;\n}\n\nvoid rtw_phy_set_edcca_th(struct rtw_dev *rtwdev, u8 l2h, u8 h2l)\n{\n\tstruct rtw_hw_reg_offset *edcca_th = rtwdev->chip->edcca_th;\n\n\trtw_write32_mask(rtwdev,\n\t\t\t edcca_th[EDCCA_TH_L2H_IDX].hw_reg.addr,\n\t\t\t edcca_th[EDCCA_TH_L2H_IDX].hw_reg.mask,\n\t\t\t l2h + edcca_th[EDCCA_TH_L2H_IDX].offset);\n\trtw_write32_mask(rtwdev,\n\t\t\t edcca_th[EDCCA_TH_H2L_IDX].hw_reg.addr,\n\t\t\t edcca_th[EDCCA_TH_H2L_IDX].hw_reg.mask,\n\t\t\t h2l + edcca_th[EDCCA_TH_H2L_IDX].offset);\n}\nEXPORT_SYMBOL(rtw_phy_set_edcca_th);\n\nvoid rtw_phy_adaptivity_set_mode(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\n\t \n\tif (!rtw_edcca_enabled) {\n\t\tdm_info->edcca_mode = RTW_EDCCA_NORMAL;\n\t\trtw_dbg(rtwdev, RTW_DBG_PHY, \"EDCCA disabled, cannot be set\\n\");\n\t\treturn;\n\t}\n\n\tswitch (rtwdev->regd.dfs_region) {\n\tcase NL80211_DFS_ETSI:\n\t\tdm_info->edcca_mode = RTW_EDCCA_ADAPTIVITY;\n\t\tdm_info->l2h_th_ini = chip->l2h_th_ini_ad;\n\t\tbreak;\n\tcase NL80211_DFS_JP:\n\t\tdm_info->edcca_mode = RTW_EDCCA_ADAPTIVITY;\n\t\tdm_info->l2h_th_ini = chip->l2h_th_ini_cs;\n\t\tbreak;\n\tdefault:\n\t\tdm_info->edcca_mode = RTW_EDCCA_NORMAL;\n\t\tbreak;\n\t}\n}\n\nstatic void rtw_phy_adaptivity_init(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\n\trtw_phy_adaptivity_set_mode(rtwdev);\n\tif (chip->ops->adaptivity_init)\n\t\tchip->ops->adaptivity_init(rtwdev);\n}\n\nstatic void rtw_phy_adaptivity(struct rtw_dev *rtwdev)\n{\n\tif (rtwdev->chip->ops->adaptivity)\n\t\trtwdev->chip->ops->adaptivity(rtwdev);\n}\n\nstatic void rtw_phy_cfo_init(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\n\tif (chip->ops->cfo_init)\n\t\tchip->ops->cfo_init(rtwdev);\n}\n\nstatic void rtw_phy_tx_path_div_init(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_path_div *path_div = &rtwdev->dm_path_div;\n\n\tpath_div->current_tx_path = rtwdev->chip->default_1ss_tx_path;\n\tpath_div->path_a_cnt = 0;\n\tpath_div->path_a_sum = 0;\n\tpath_div->path_b_cnt = 0;\n\tpath_div->path_b_sum = 0;\n}\n\nvoid rtw_phy_init(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tu32 addr, mask;\n\n\tdm_info->fa_history[3] = 0;\n\tdm_info->fa_history[2] = 0;\n\tdm_info->fa_history[1] = 0;\n\tdm_info->fa_history[0] = 0;\n\tdm_info->igi_bitmap = 0;\n\tdm_info->igi_history[3] = 0;\n\tdm_info->igi_history[2] = 0;\n\tdm_info->igi_history[1] = 0;\n\n\taddr = chip->dig[0].addr;\n\tmask = chip->dig[0].mask;\n\tdm_info->igi_history[0] = rtw_read32_mask(rtwdev, addr, mask);\n\trtw_phy_cck_pd_init(rtwdev);\n\n\tdm_info->iqk.done = false;\n\trtw_phy_adaptivity_init(rtwdev);\n\trtw_phy_cfo_init(rtwdev);\n\trtw_phy_tx_path_div_init(rtwdev);\n}\nEXPORT_SYMBOL(rtw_phy_init);\n\nvoid rtw_phy_dig_write(struct rtw_dev *rtwdev, u8 igi)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_hal *hal = &rtwdev->hal;\n\tu32 addr, mask;\n\tu8 path;\n\n\tif (chip->dig_cck) {\n\t\tconst struct rtw_hw_reg *dig_cck = &chip->dig_cck[0];\n\t\trtw_write32_mask(rtwdev, dig_cck->addr, dig_cck->mask, igi >> 1);\n\t}\n\n\tfor (path = 0; path < hal->rf_path_num; path++) {\n\t\taddr = chip->dig[path].addr;\n\t\tmask = chip->dig[path].mask;\n\t\trtw_write32_mask(rtwdev, addr, mask, igi);\n\t}\n}\n\nstatic void rtw_phy_stat_false_alarm(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\n\tchip->ops->false_alarm_statistics(rtwdev);\n}\n\n#define RA_FLOOR_TABLE_SIZE\t7\n#define RA_FLOOR_UP_GAP\t\t3\n\nstatic u8 rtw_phy_get_rssi_level(u8 old_level, u8 rssi)\n{\n\tu8 table[RA_FLOOR_TABLE_SIZE] = {20, 34, 38, 42, 46, 50, 100};\n\tu8 new_level = 0;\n\tint i;\n\n\tfor (i = 0; i < RA_FLOOR_TABLE_SIZE; i++)\n\t\tif (i >= old_level)\n\t\t\ttable[i] += RA_FLOOR_UP_GAP;\n\n\tfor (i = 0; i < RA_FLOOR_TABLE_SIZE; i++) {\n\t\tif (rssi < table[i]) {\n\t\t\tnew_level = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn new_level;\n}\n\nstruct rtw_phy_stat_iter_data {\n\tstruct rtw_dev *rtwdev;\n\tu8 min_rssi;\n};\n\nstatic void rtw_phy_stat_rssi_iter(void *data, struct ieee80211_sta *sta)\n{\n\tstruct rtw_phy_stat_iter_data *iter_data = data;\n\tstruct rtw_dev *rtwdev = iter_data->rtwdev;\n\tstruct rtw_sta_info *si = (struct rtw_sta_info *)sta->drv_priv;\n\tu8 rssi;\n\n\trssi = ewma_rssi_read(&si->avg_rssi);\n\tsi->rssi_level = rtw_phy_get_rssi_level(si->rssi_level, rssi);\n\n\trtw_fw_send_rssi_info(rtwdev, si);\n\n\titer_data->min_rssi = min_t(u8, rssi, iter_data->min_rssi);\n}\n\nstatic void rtw_phy_stat_rssi(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tstruct rtw_phy_stat_iter_data data = {};\n\n\tdata.rtwdev = rtwdev;\n\tdata.min_rssi = U8_MAX;\n\trtw_iterate_stas(rtwdev, rtw_phy_stat_rssi_iter, &data);\n\n\tdm_info->pre_min_rssi = dm_info->min_rssi;\n\tdm_info->min_rssi = data.min_rssi;\n}\n\nstatic void rtw_phy_stat_rate_cnt(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\n\tdm_info->last_pkt_count = dm_info->cur_pkt_count;\n\tmemset(&dm_info->cur_pkt_count, 0, sizeof(dm_info->cur_pkt_count));\n}\n\nstatic void rtw_phy_statistics(struct rtw_dev *rtwdev)\n{\n\trtw_phy_stat_rssi(rtwdev);\n\trtw_phy_stat_false_alarm(rtwdev);\n\trtw_phy_stat_rate_cnt(rtwdev);\n}\n\n#define DIG_PERF_FA_TH_LOW\t\t\t250\n#define DIG_PERF_FA_TH_HIGH\t\t\t500\n#define DIG_PERF_FA_TH_EXTRA_HIGH\t\t750\n#define DIG_PERF_MAX\t\t\t\t0x5a\n#define DIG_PERF_MID\t\t\t\t0x40\n#define DIG_CVRG_FA_TH_LOW\t\t\t2000\n#define DIG_CVRG_FA_TH_HIGH\t\t\t4000\n#define DIG_CVRG_FA_TH_EXTRA_HIGH\t\t5000\n#define DIG_CVRG_MAX\t\t\t\t0x2a\n#define DIG_CVRG_MID\t\t\t\t0x26\n#define DIG_CVRG_MIN\t\t\t\t0x1c\n#define DIG_RSSI_GAIN_OFFSET\t\t\t15\n\nstatic bool\nrtw_phy_dig_check_damping(struct rtw_dm_info *dm_info)\n{\n\tu16 fa_lo = DIG_PERF_FA_TH_LOW;\n\tu16 fa_hi = DIG_PERF_FA_TH_HIGH;\n\tu16 *fa_history;\n\tu8 *igi_history;\n\tu8 damping_rssi;\n\tu8 min_rssi;\n\tu8 diff;\n\tu8 igi_bitmap;\n\tbool damping = false;\n\n\tmin_rssi = dm_info->min_rssi;\n\tif (dm_info->damping) {\n\t\tdamping_rssi = dm_info->damping_rssi;\n\t\tdiff = min_rssi > damping_rssi ? min_rssi - damping_rssi :\n\t\t\t\t\t\t damping_rssi - min_rssi;\n\t\tif (diff > 3 || dm_info->damping_cnt++ > 20) {\n\t\t\tdm_info->damping = false;\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tigi_history = dm_info->igi_history;\n\tfa_history = dm_info->fa_history;\n\tigi_bitmap = dm_info->igi_bitmap & 0xf;\n\tswitch (igi_bitmap) {\n\tcase 5:\n\t\t \n\t\tif (igi_history[0] > igi_history[1] &&\n\t\t    igi_history[2] > igi_history[3] &&\n\t\t    igi_history[0] - igi_history[1] >= 2 &&\n\t\t    igi_history[2] - igi_history[3] >= 2 &&\n\t\t    fa_history[0] > fa_hi && fa_history[1] < fa_lo &&\n\t\t    fa_history[2] > fa_hi && fa_history[3] < fa_lo)\n\t\t\tdamping = true;\n\t\tbreak;\n\tcase 9:\n\t\t \n\t\tif (igi_history[0] > igi_history[1] &&\n\t\t    igi_history[3] > igi_history[2] &&\n\t\t    igi_history[0] - igi_history[1] >= 4 &&\n\t\t    igi_history[3] - igi_history[2] >= 2 &&\n\t\t    fa_history[0] > fa_hi && fa_history[1] < fa_lo &&\n\t\t    fa_history[2] < fa_lo && fa_history[3] > fa_hi)\n\t\t\tdamping = true;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\tif (damping) {\n\t\tdm_info->damping = true;\n\t\tdm_info->damping_cnt = 0;\n\t\tdm_info->damping_rssi = min_rssi;\n\t}\n\n\treturn damping;\n}\n\nstatic void rtw_phy_dig_get_boundary(struct rtw_dev *rtwdev,\n\t\t\t\t     struct rtw_dm_info *dm_info,\n\t\t\t\t     u8 *upper, u8 *lower, bool linked)\n{\n\tu8 dig_max, dig_min, dig_mid;\n\tu8 min_rssi;\n\n\tif (linked) {\n\t\tdig_max = DIG_PERF_MAX;\n\t\tdig_mid = DIG_PERF_MID;\n\t\tdig_min = rtwdev->chip->dig_min;\n\t\tmin_rssi = max_t(u8, dm_info->min_rssi, dig_min);\n\t} else {\n\t\tdig_max = DIG_CVRG_MAX;\n\t\tdig_mid = DIG_CVRG_MID;\n\t\tdig_min = DIG_CVRG_MIN;\n\t\tmin_rssi = dig_min;\n\t}\n\n\t \n\tdig_max = min_t(u8, dig_max, min_rssi + DIG_RSSI_GAIN_OFFSET);\n\n\t*lower = clamp_t(u8, min_rssi, dig_min, dig_mid);\n\t*upper = clamp_t(u8, *lower + DIG_RSSI_GAIN_OFFSET, dig_min, dig_max);\n}\n\nstatic void rtw_phy_dig_get_threshold(struct rtw_dm_info *dm_info,\n\t\t\t\t      u16 *fa_th, u8 *step, bool linked)\n{\n\tu8 min_rssi, pre_min_rssi;\n\n\tmin_rssi = dm_info->min_rssi;\n\tpre_min_rssi = dm_info->pre_min_rssi;\n\tstep[0] = 4;\n\tstep[1] = 3;\n\tstep[2] = 2;\n\n\tif (linked) {\n\t\tfa_th[0] = DIG_PERF_FA_TH_EXTRA_HIGH;\n\t\tfa_th[1] = DIG_PERF_FA_TH_HIGH;\n\t\tfa_th[2] = DIG_PERF_FA_TH_LOW;\n\t\tif (pre_min_rssi > min_rssi) {\n\t\t\tstep[0] = 6;\n\t\t\tstep[1] = 4;\n\t\t\tstep[2] = 2;\n\t\t}\n\t} else {\n\t\tfa_th[0] = DIG_CVRG_FA_TH_EXTRA_HIGH;\n\t\tfa_th[1] = DIG_CVRG_FA_TH_HIGH;\n\t\tfa_th[2] = DIG_CVRG_FA_TH_LOW;\n\t}\n}\n\nstatic void rtw_phy_dig_recorder(struct rtw_dm_info *dm_info, u8 igi, u16 fa)\n{\n\tu8 *igi_history;\n\tu16 *fa_history;\n\tu8 igi_bitmap;\n\tbool up;\n\n\tigi_bitmap = dm_info->igi_bitmap << 1 & 0xfe;\n\tigi_history = dm_info->igi_history;\n\tfa_history = dm_info->fa_history;\n\n\tup = igi > igi_history[0];\n\tigi_bitmap |= up;\n\n\tigi_history[3] = igi_history[2];\n\tigi_history[2] = igi_history[1];\n\tigi_history[1] = igi_history[0];\n\tigi_history[0] = igi;\n\n\tfa_history[3] = fa_history[2];\n\tfa_history[2] = fa_history[1];\n\tfa_history[1] = fa_history[0];\n\tfa_history[0] = fa;\n\n\tdm_info->igi_bitmap = igi_bitmap;\n}\n\nstatic void rtw_phy_dig(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tu8 upper_bound, lower_bound;\n\tu8 pre_igi, cur_igi;\n\tu16 fa_th[3], fa_cnt;\n\tu8 level;\n\tu8 step[3];\n\tbool linked;\n\n\tif (test_bit(RTW_FLAG_DIG_DISABLE, rtwdev->flags))\n\t\treturn;\n\n\tif (rtw_phy_dig_check_damping(dm_info))\n\t\treturn;\n\n\tlinked = !!rtwdev->sta_cnt;\n\n\tfa_cnt = dm_info->total_fa_cnt;\n\tpre_igi = dm_info->igi_history[0];\n\n\trtw_phy_dig_get_threshold(dm_info, fa_th, step, linked);\n\n\t \n\tcur_igi = pre_igi;\n\tfor (level = 0; level < 3; level++) {\n\t\tif (fa_cnt > fa_th[level]) {\n\t\t\tcur_igi += step[level];\n\t\t\tbreak;\n\t\t}\n\t}\n\tcur_igi -= 2;\n\n\t \n\trtw_phy_dig_get_boundary(rtwdev, dm_info, &upper_bound, &lower_bound,\n\t\t\t\t linked);\n\tcur_igi = clamp_t(u8, cur_igi, lower_bound, upper_bound);\n\n\t \n\trtw_phy_dig_recorder(dm_info, cur_igi, fa_cnt);\n\n\tif (cur_igi != pre_igi)\n\t\trtw_phy_dig_write(rtwdev, cur_igi);\n}\n\nstatic void rtw_phy_ra_info_update_iter(void *data, struct ieee80211_sta *sta)\n{\n\tstruct rtw_dev *rtwdev = data;\n\tstruct rtw_sta_info *si = (struct rtw_sta_info *)sta->drv_priv;\n\n\trtw_update_sta_info(rtwdev, si, false);\n}\n\nstatic void rtw_phy_ra_info_update(struct rtw_dev *rtwdev)\n{\n\tif (rtwdev->watch_dog_cnt & 0x3)\n\t\treturn;\n\n\trtw_iterate_stas(rtwdev, rtw_phy_ra_info_update_iter, rtwdev);\n}\n\nstatic u32 rtw_phy_get_rrsr_mask(struct rtw_dev *rtwdev, u8 rate_idx)\n{\n\tu8 rate_order;\n\n\trate_order = rate_idx;\n\n\tif (rate_idx >= DESC_RATEVHT4SS_MCS0)\n\t\trate_order -= DESC_RATEVHT4SS_MCS0;\n\telse if (rate_idx >= DESC_RATEVHT3SS_MCS0)\n\t\trate_order -= DESC_RATEVHT3SS_MCS0;\n\telse if (rate_idx >= DESC_RATEVHT2SS_MCS0)\n\t\trate_order -= DESC_RATEVHT2SS_MCS0;\n\telse if (rate_idx >= DESC_RATEVHT1SS_MCS0)\n\t\trate_order -= DESC_RATEVHT1SS_MCS0;\n\telse if (rate_idx >= DESC_RATEMCS24)\n\t\trate_order -= DESC_RATEMCS24;\n\telse if (rate_idx >= DESC_RATEMCS16)\n\t\trate_order -= DESC_RATEMCS16;\n\telse if (rate_idx >= DESC_RATEMCS8)\n\t\trate_order -= DESC_RATEMCS8;\n\telse if (rate_idx >= DESC_RATEMCS0)\n\t\trate_order -= DESC_RATEMCS0;\n\telse if (rate_idx >= DESC_RATE6M)\n\t\trate_order -= DESC_RATE6M;\n\telse\n\t\trate_order -= DESC_RATE1M;\n\n\tif (rate_idx >= DESC_RATEMCS0 || rate_order == 0)\n\t\trate_order++;\n\n\treturn GENMASK(rate_order + RRSR_RATE_ORDER_CCK_LEN - 1, 0);\n}\n\nstatic void rtw_phy_rrsr_mask_min_iter(void *data, struct ieee80211_sta *sta)\n{\n\tstruct rtw_dev *rtwdev = (struct rtw_dev *)data;\n\tstruct rtw_sta_info *si = (struct rtw_sta_info *)sta->drv_priv;\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tu32 mask = 0;\n\n\tmask = rtw_phy_get_rrsr_mask(rtwdev, si->ra_report.desc_rate);\n\tif (mask < dm_info->rrsr_mask_min)\n\t\tdm_info->rrsr_mask_min = mask;\n}\n\nstatic void rtw_phy_rrsr_update(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\n\tdm_info->rrsr_mask_min = RRSR_RATE_ORDER_MAX;\n\trtw_iterate_stas(rtwdev, rtw_phy_rrsr_mask_min_iter, rtwdev);\n\trtw_write32(rtwdev, REG_RRSR, dm_info->rrsr_val_init & dm_info->rrsr_mask_min);\n}\n\nstatic void rtw_phy_dpk_track(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\n\tif (chip->ops->dpk_track)\n\t\tchip->ops->dpk_track(rtwdev);\n}\n\nstruct rtw_rx_addr_match_data {\n\tstruct rtw_dev *rtwdev;\n\tstruct ieee80211_hdr *hdr;\n\tstruct rtw_rx_pkt_stat *pkt_stat;\n\tu8 *bssid;\n};\n\nstatic void rtw_phy_parsing_cfo_iter(void *data, u8 *mac,\n\t\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct rtw_rx_addr_match_data *iter_data = data;\n\tstruct rtw_dev *rtwdev = iter_data->rtwdev;\n\tstruct rtw_rx_pkt_stat *pkt_stat = iter_data->pkt_stat;\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tstruct rtw_cfo_track *cfo = &dm_info->cfo_track;\n\tu8 *bssid = iter_data->bssid;\n\tu8 i;\n\n\tif (!ether_addr_equal(vif->bss_conf.bssid, bssid))\n\t\treturn;\n\n\tfor (i = 0; i < rtwdev->hal.rf_path_num; i++) {\n\t\tcfo->cfo_tail[i] += pkt_stat->cfo_tail[i];\n\t\tcfo->cfo_cnt[i]++;\n\t}\n\n\tcfo->packet_count++;\n}\n\nvoid rtw_phy_parsing_cfo(struct rtw_dev *rtwdev,\n\t\t\t struct rtw_rx_pkt_stat *pkt_stat)\n{\n\tstruct ieee80211_hdr *hdr = pkt_stat->hdr;\n\tstruct rtw_rx_addr_match_data data = {};\n\n\tif (pkt_stat->crc_err || pkt_stat->icv_err || !pkt_stat->phy_status ||\n\t    ieee80211_is_ctl(hdr->frame_control))\n\t\treturn;\n\n\tdata.rtwdev = rtwdev;\n\tdata.hdr = hdr;\n\tdata.pkt_stat = pkt_stat;\n\tdata.bssid = get_hdr_bssid(hdr);\n\n\trtw_iterate_vifs_atomic(rtwdev, rtw_phy_parsing_cfo_iter, &data);\n}\nEXPORT_SYMBOL(rtw_phy_parsing_cfo);\n\nstatic void rtw_phy_cfo_track(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\n\tif (chip->ops->cfo_track)\n\t\tchip->ops->cfo_track(rtwdev);\n}\n\n#define CCK_PD_FA_LV1_MIN\t1000\n#define CCK_PD_FA_LV0_MAX\t500\n\nstatic u8 rtw_phy_cck_pd_lv_unlink(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tu32 cck_fa_avg = dm_info->cck_fa_avg;\n\n\tif (cck_fa_avg > CCK_PD_FA_LV1_MIN)\n\t\treturn CCK_PD_LV1;\n\n\tif (cck_fa_avg < CCK_PD_FA_LV0_MAX)\n\t\treturn CCK_PD_LV0;\n\n\treturn CCK_PD_LV_MAX;\n}\n\n#define CCK_PD_IGI_LV4_VAL 0x38\n#define CCK_PD_IGI_LV3_VAL 0x2a\n#define CCK_PD_IGI_LV2_VAL 0x24\n#define CCK_PD_RSSI_LV4_VAL 32\n#define CCK_PD_RSSI_LV3_VAL 32\n#define CCK_PD_RSSI_LV2_VAL 24\n\nstatic u8 rtw_phy_cck_pd_lv_link(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tu8 igi = dm_info->igi_history[0];\n\tu8 rssi = dm_info->min_rssi;\n\tu32 cck_fa_avg = dm_info->cck_fa_avg;\n\n\tif (igi > CCK_PD_IGI_LV4_VAL && rssi > CCK_PD_RSSI_LV4_VAL)\n\t\treturn CCK_PD_LV4;\n\tif (igi > CCK_PD_IGI_LV3_VAL && rssi > CCK_PD_RSSI_LV3_VAL)\n\t\treturn CCK_PD_LV3;\n\tif (igi > CCK_PD_IGI_LV2_VAL || rssi > CCK_PD_RSSI_LV2_VAL)\n\t\treturn CCK_PD_LV2;\n\tif (cck_fa_avg > CCK_PD_FA_LV1_MIN)\n\t\treturn CCK_PD_LV1;\n\tif (cck_fa_avg < CCK_PD_FA_LV0_MAX)\n\t\treturn CCK_PD_LV0;\n\n\treturn CCK_PD_LV_MAX;\n}\n\nstatic u8 rtw_phy_cck_pd_lv(struct rtw_dev *rtwdev)\n{\n\tif (!rtw_is_assoc(rtwdev))\n\t\treturn rtw_phy_cck_pd_lv_unlink(rtwdev);\n\telse\n\t\treturn rtw_phy_cck_pd_lv_link(rtwdev);\n}\n\nstatic void rtw_phy_cck_pd(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tu32 cck_fa = dm_info->cck_fa_cnt;\n\tu8 level;\n\n\tif (rtwdev->hal.current_band_type != RTW_BAND_2G)\n\t\treturn;\n\n\tif (dm_info->cck_fa_avg == CCK_FA_AVG_RESET)\n\t\tdm_info->cck_fa_avg = cck_fa;\n\telse\n\t\tdm_info->cck_fa_avg = (dm_info->cck_fa_avg * 3 + cck_fa) >> 2;\n\n\trtw_dbg(rtwdev, RTW_DBG_PHY, \"IGI=0x%x, rssi_min=%d, cck_fa=%d\\n\",\n\t\tdm_info->igi_history[0], dm_info->min_rssi,\n\t\tdm_info->fa_history[0]);\n\trtw_dbg(rtwdev, RTW_DBG_PHY, \"cck_fa_avg=%d, cck_pd_default=%d\\n\",\n\t\tdm_info->cck_fa_avg, dm_info->cck_pd_default);\n\n\tlevel = rtw_phy_cck_pd_lv(rtwdev);\n\n\tif (level >= CCK_PD_LV_MAX)\n\t\treturn;\n\n\tif (chip->ops->cck_pd_set)\n\t\tchip->ops->cck_pd_set(rtwdev, level);\n}\n\nstatic void rtw_phy_pwr_track(struct rtw_dev *rtwdev)\n{\n\trtwdev->chip->ops->pwr_track(rtwdev);\n}\n\nstatic void rtw_phy_ra_track(struct rtw_dev *rtwdev)\n{\n\trtw_fw_update_wl_phy_info(rtwdev);\n\trtw_phy_ra_info_update(rtwdev);\n\trtw_phy_rrsr_update(rtwdev);\n}\n\nvoid rtw_phy_dynamic_mechanism(struct rtw_dev *rtwdev)\n{\n\t \n\trtw_phy_statistics(rtwdev);\n\trtw_phy_dig(rtwdev);\n\trtw_phy_cck_pd(rtwdev);\n\trtw_phy_ra_track(rtwdev);\n\trtw_phy_tx_path_diversity(rtwdev);\n\trtw_phy_cfo_track(rtwdev);\n\trtw_phy_dpk_track(rtwdev);\n\trtw_phy_pwr_track(rtwdev);\n\n\tif (rtw_fw_feature_check(&rtwdev->fw, FW_FEATURE_ADAPTIVITY))\n\t\trtw_fw_adaptivity(rtwdev);\n\telse\n\t\trtw_phy_adaptivity(rtwdev);\n}\n\n#define FRAC_BITS 3\n\nstatic u8 rtw_phy_power_2_db(s8 power)\n{\n\tif (power <= -100 || power >= 20)\n\t\treturn 0;\n\telse if (power >= 0)\n\t\treturn 100;\n\telse\n\t\treturn 100 + power;\n}\n\nstatic u64 rtw_phy_db_2_linear(u8 power_db)\n{\n\tu8 i, j;\n\tu64 linear;\n\n\tif (power_db > 96)\n\t\tpower_db = 96;\n\telse if (power_db < 1)\n\t\treturn 1;\n\n\t \n\ti = (power_db - 1) >> 3;\n\tj = (power_db - 1) - (i << 3);\n\n\tlinear = db_invert_table[i][j];\n\tlinear = i > 2 ? linear << FRAC_BITS : linear;\n\n\treturn linear;\n}\n\nstatic u8 rtw_phy_linear_2_db(u64 linear)\n{\n\tu8 i;\n\tu8 j;\n\tu32 dB;\n\n\tfor (i = 0; i < 12; i++) {\n\t\tfor (j = 0; j < 8; j++) {\n\t\t\tif (i <= 2 && (linear << FRAC_BITS) <= db_invert_table[i][j])\n\t\t\t\tgoto cnt;\n\t\t\telse if (i > 2 && linear <= db_invert_table[i][j])\n\t\t\t\tgoto cnt;\n\t\t}\n\t}\n\n\treturn 96;  \n\ncnt:\n\tif (j == 0 && i == 0)\n\t\tgoto end;\n\n\tif (j == 0) {\n\t\tif (i != 3) {\n\t\t\tif (db_invert_table[i][0] - linear >\n\t\t\t    linear - db_invert_table[i - 1][7]) {\n\t\t\t\ti = i - 1;\n\t\t\t\tj = 7;\n\t\t\t}\n\t\t} else {\n\t\t\tif (db_invert_table[3][0] - linear >\n\t\t\t    linear - db_invert_table[2][7]) {\n\t\t\t\ti = 2;\n\t\t\t\tj = 7;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (db_invert_table[i][j] - linear >\n\t\t    linear - db_invert_table[i][j - 1]) {\n\t\t\tj = j - 1;\n\t\t}\n\t}\nend:\n\tdB = (i << 3) + j + 1;\n\n\treturn dB;\n}\n\nu8 rtw_phy_rf_power_2_rssi(s8 *rf_power, u8 path_num)\n{\n\ts8 power;\n\tu8 power_db;\n\tu64 linear;\n\tu64 sum = 0;\n\tu8 path;\n\n\tfor (path = 0; path < path_num; path++) {\n\t\tpower = rf_power[path];\n\t\tpower_db = rtw_phy_power_2_db(power);\n\t\tlinear = rtw_phy_db_2_linear(power_db);\n\t\tsum += linear;\n\t}\n\n\tsum = (sum + (1 << (FRAC_BITS - 1))) >> FRAC_BITS;\n\tswitch (path_num) {\n\tcase 2:\n\t\tsum >>= 1;\n\t\tbreak;\n\tcase 3:\n\t\tsum = ((sum) + ((sum) << 1) + ((sum) << 3)) >> 5;\n\t\tbreak;\n\tcase 4:\n\t\tsum >>= 2;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn rtw_phy_linear_2_db(sum);\n}\nEXPORT_SYMBOL(rtw_phy_rf_power_2_rssi);\n\nu32 rtw_phy_read_rf(struct rtw_dev *rtwdev, enum rtw_rf_path rf_path,\n\t\t    u32 addr, u32 mask)\n{\n\tstruct rtw_hal *hal = &rtwdev->hal;\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tconst u32 *base_addr = chip->rf_base_addr;\n\tu32 val, direct_addr;\n\n\tif (rf_path >= hal->rf_phy_num) {\n\t\trtw_err(rtwdev, \"unsupported rf path (%d)\\n\", rf_path);\n\t\treturn INV_RF_DATA;\n\t}\n\n\taddr &= 0xff;\n\tdirect_addr = base_addr[rf_path] + (addr << 2);\n\tmask &= RFREG_MASK;\n\n\tval = rtw_read32_mask(rtwdev, direct_addr, mask);\n\n\treturn val;\n}\nEXPORT_SYMBOL(rtw_phy_read_rf);\n\nu32 rtw_phy_read_rf_sipi(struct rtw_dev *rtwdev, enum rtw_rf_path rf_path,\n\t\t\t u32 addr, u32 mask)\n{\n\tstruct rtw_hal *hal = &rtwdev->hal;\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tconst struct rtw_rf_sipi_addr *rf_sipi_addr;\n\tconst struct rtw_rf_sipi_addr *rf_sipi_addr_a;\n\tu32 val32;\n\tu32 en_pi;\n\tu32 r_addr;\n\tu32 shift;\n\n\tif (rf_path >= hal->rf_phy_num) {\n\t\trtw_err(rtwdev, \"unsupported rf path (%d)\\n\", rf_path);\n\t\treturn INV_RF_DATA;\n\t}\n\n\tif (!chip->rf_sipi_read_addr) {\n\t\trtw_err(rtwdev, \"rf_sipi_read_addr isn't defined\\n\");\n\t\treturn INV_RF_DATA;\n\t}\n\n\trf_sipi_addr = &chip->rf_sipi_read_addr[rf_path];\n\trf_sipi_addr_a = &chip->rf_sipi_read_addr[RF_PATH_A];\n\n\taddr &= 0xff;\n\n\tval32 = rtw_read32(rtwdev, rf_sipi_addr->hssi_2);\n\tval32 = (val32 & ~LSSI_READ_ADDR_MASK) | (addr << 23);\n\trtw_write32(rtwdev, rf_sipi_addr->hssi_2, val32);\n\n\t \n\tval32 = rtw_read32(rtwdev, rf_sipi_addr_a->hssi_2);\n\trtw_write32(rtwdev, rf_sipi_addr_a->hssi_2, val32 & ~LSSI_READ_EDGE_MASK);\n\trtw_write32(rtwdev, rf_sipi_addr_a->hssi_2, val32 | LSSI_READ_EDGE_MASK);\n\n\tudelay(120);\n\n\ten_pi = rtw_read32_mask(rtwdev, rf_sipi_addr->hssi_1, BIT(8));\n\tr_addr = en_pi ? rf_sipi_addr->lssi_read_pi : rf_sipi_addr->lssi_read;\n\n\tval32 = rtw_read32_mask(rtwdev, r_addr, LSSI_READ_DATA_MASK);\n\n\tshift = __ffs(mask);\n\n\treturn (val32 & mask) >> shift;\n}\nEXPORT_SYMBOL(rtw_phy_read_rf_sipi);\n\nbool rtw_phy_write_rf_reg_sipi(struct rtw_dev *rtwdev, enum rtw_rf_path rf_path,\n\t\t\t       u32 addr, u32 mask, u32 data)\n{\n\tstruct rtw_hal *hal = &rtwdev->hal;\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tconst u32 *sipi_addr = chip->rf_sipi_addr;\n\tu32 data_and_addr;\n\tu32 old_data = 0;\n\tu32 shift;\n\n\tif (rf_path >= hal->rf_phy_num) {\n\t\trtw_err(rtwdev, \"unsupported rf path (%d)\\n\", rf_path);\n\t\treturn false;\n\t}\n\n\taddr &= 0xff;\n\tmask &= RFREG_MASK;\n\n\tif (mask != RFREG_MASK) {\n\t\told_data = chip->ops->read_rf(rtwdev, rf_path, addr, RFREG_MASK);\n\n\t\tif (old_data == INV_RF_DATA) {\n\t\t\trtw_err(rtwdev, \"Write fail, rf is disabled\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\tshift = __ffs(mask);\n\t\tdata = ((old_data) & (~mask)) | (data << shift);\n\t}\n\n\tdata_and_addr = ((addr << 20) | (data & 0x000fffff)) & 0x0fffffff;\n\n\trtw_write32(rtwdev, sipi_addr[rf_path], data_and_addr);\n\n\tudelay(13);\n\n\treturn true;\n}\nEXPORT_SYMBOL(rtw_phy_write_rf_reg_sipi);\n\nbool rtw_phy_write_rf_reg(struct rtw_dev *rtwdev, enum rtw_rf_path rf_path,\n\t\t\t  u32 addr, u32 mask, u32 data)\n{\n\tstruct rtw_hal *hal = &rtwdev->hal;\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tconst u32 *base_addr = chip->rf_base_addr;\n\tu32 direct_addr;\n\n\tif (rf_path >= hal->rf_phy_num) {\n\t\trtw_err(rtwdev, \"unsupported rf path (%d)\\n\", rf_path);\n\t\treturn false;\n\t}\n\n\taddr &= 0xff;\n\tdirect_addr = base_addr[rf_path] + (addr << 2);\n\tmask &= RFREG_MASK;\n\n\trtw_write32_mask(rtwdev, direct_addr, mask, data);\n\n\tudelay(1);\n\n\treturn true;\n}\n\nbool rtw_phy_write_rf_reg_mix(struct rtw_dev *rtwdev, enum rtw_rf_path rf_path,\n\t\t\t      u32 addr, u32 mask, u32 data)\n{\n\tif (addr != 0x00)\n\t\treturn rtw_phy_write_rf_reg(rtwdev, rf_path, addr, mask, data);\n\n\treturn rtw_phy_write_rf_reg_sipi(rtwdev, rf_path, addr, mask, data);\n}\nEXPORT_SYMBOL(rtw_phy_write_rf_reg_mix);\n\nvoid rtw_phy_setup_phy_cond(struct rtw_dev *rtwdev, u32 pkg)\n{\n\tstruct rtw_hal *hal = &rtwdev->hal;\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\tstruct rtw_phy_cond cond = {0};\n\n\tcond.cut = hal->cut_version ? hal->cut_version : 15;\n\tcond.pkg = pkg ? pkg : 15;\n\tcond.plat = 0x04;\n\tcond.rfe = efuse->rfe_option;\n\n\tswitch (rtw_hci_type(rtwdev)) {\n\tcase RTW_HCI_TYPE_USB:\n\t\tcond.intf = INTF_USB;\n\t\tbreak;\n\tcase RTW_HCI_TYPE_SDIO:\n\t\tcond.intf = INTF_SDIO;\n\t\tbreak;\n\tcase RTW_HCI_TYPE_PCIE:\n\tdefault:\n\t\tcond.intf = INTF_PCIE;\n\t\tbreak;\n\t}\n\n\thal->phy_cond = cond;\n\n\trtw_dbg(rtwdev, RTW_DBG_PHY, \"phy cond=0x%08x\\n\", *((u32 *)&hal->phy_cond));\n}\n\nstatic bool check_positive(struct rtw_dev *rtwdev, struct rtw_phy_cond cond)\n{\n\tstruct rtw_hal *hal = &rtwdev->hal;\n\tstruct rtw_phy_cond drv_cond = hal->phy_cond;\n\n\tif (cond.cut && cond.cut != drv_cond.cut)\n\t\treturn false;\n\n\tif (cond.pkg && cond.pkg != drv_cond.pkg)\n\t\treturn false;\n\n\tif (cond.intf && cond.intf != drv_cond.intf)\n\t\treturn false;\n\n\tif (cond.rfe != drv_cond.rfe)\n\t\treturn false;\n\n\treturn true;\n}\n\nvoid rtw_parse_tbl_phy_cond(struct rtw_dev *rtwdev, const struct rtw_table *tbl)\n{\n\tconst union phy_table_tile *p = tbl->data;\n\tconst union phy_table_tile *end = p + tbl->size / 2;\n\tstruct rtw_phy_cond pos_cond = {0};\n\tbool is_matched = true, is_skipped = false;\n\n\tBUILD_BUG_ON(sizeof(union phy_table_tile) != sizeof(struct phy_cfg_pair));\n\n\tfor (; p < end; p++) {\n\t\tif (p->cond.pos) {\n\t\t\tswitch (p->cond.branch) {\n\t\t\tcase BRANCH_ENDIF:\n\t\t\t\tis_matched = true;\n\t\t\t\tis_skipped = false;\n\t\t\t\tbreak;\n\t\t\tcase BRANCH_ELSE:\n\t\t\t\tis_matched = is_skipped ? false : true;\n\t\t\t\tbreak;\n\t\t\tcase BRANCH_IF:\n\t\t\tcase BRANCH_ELIF:\n\t\t\tdefault:\n\t\t\t\tpos_cond = p->cond;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (p->cond.neg) {\n\t\t\tif (!is_skipped) {\n\t\t\t\tif (check_positive(rtwdev, pos_cond)) {\n\t\t\t\t\tis_matched = true;\n\t\t\t\t\tis_skipped = true;\n\t\t\t\t} else {\n\t\t\t\t\tis_matched = false;\n\t\t\t\t\tis_skipped = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tis_matched = false;\n\t\t\t}\n\t\t} else if (is_matched) {\n\t\t\t(*tbl->do_cfg)(rtwdev, tbl, p->cfg.addr, p->cfg.data);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(rtw_parse_tbl_phy_cond);\n\n#define bcd_to_dec_pwr_by_rate(val, i) bcd2bin(val >> (i * 8))\n\nstatic u8 tbl_to_dec_pwr_by_rate(struct rtw_dev *rtwdev, u32 hex, u8 i)\n{\n\tif (rtwdev->chip->is_pwr_by_rate_dec)\n\t\treturn bcd_to_dec_pwr_by_rate(hex, i);\n\n\treturn (hex >> (i * 8)) & 0xFF;\n}\n\nstatic void\nrtw_phy_get_rate_values_of_txpwr_by_rate(struct rtw_dev *rtwdev,\n\t\t\t\t\t u32 addr, u32 mask, u32 val, u8 *rate,\n\t\t\t\t\t u8 *pwr_by_rate, u8 *rate_num)\n{\n\tint i;\n\n\tswitch (addr) {\n\tcase 0xE00:\n\tcase 0x830:\n\t\trate[0] = DESC_RATE6M;\n\t\trate[1] = DESC_RATE9M;\n\t\trate[2] = DESC_RATE12M;\n\t\trate[3] = DESC_RATE18M;\n\t\tfor (i = 0; i < 4; ++i)\n\t\t\tpwr_by_rate[i] = tbl_to_dec_pwr_by_rate(rtwdev, val, i);\n\t\t*rate_num = 4;\n\t\tbreak;\n\tcase 0xE04:\n\tcase 0x834:\n\t\trate[0] = DESC_RATE24M;\n\t\trate[1] = DESC_RATE36M;\n\t\trate[2] = DESC_RATE48M;\n\t\trate[3] = DESC_RATE54M;\n\t\tfor (i = 0; i < 4; ++i)\n\t\t\tpwr_by_rate[i] = tbl_to_dec_pwr_by_rate(rtwdev, val, i);\n\t\t*rate_num = 4;\n\t\tbreak;\n\tcase 0xE08:\n\t\trate[0] = DESC_RATE1M;\n\t\tpwr_by_rate[0] = bcd_to_dec_pwr_by_rate(val, 1);\n\t\t*rate_num = 1;\n\t\tbreak;\n\tcase 0x86C:\n\t\tif (mask == 0xffffff00) {\n\t\t\trate[0] = DESC_RATE2M;\n\t\t\trate[1] = DESC_RATE5_5M;\n\t\t\trate[2] = DESC_RATE11M;\n\t\t\tfor (i = 1; i < 4; ++i)\n\t\t\t\tpwr_by_rate[i - 1] =\n\t\t\t\t\ttbl_to_dec_pwr_by_rate(rtwdev, val, i);\n\t\t\t*rate_num = 3;\n\t\t} else if (mask == 0x000000ff) {\n\t\t\trate[0] = DESC_RATE11M;\n\t\t\tpwr_by_rate[0] = bcd_to_dec_pwr_by_rate(val, 0);\n\t\t\t*rate_num = 1;\n\t\t}\n\t\tbreak;\n\tcase 0xE10:\n\tcase 0x83C:\n\t\trate[0] = DESC_RATEMCS0;\n\t\trate[1] = DESC_RATEMCS1;\n\t\trate[2] = DESC_RATEMCS2;\n\t\trate[3] = DESC_RATEMCS3;\n\t\tfor (i = 0; i < 4; ++i)\n\t\t\tpwr_by_rate[i] = tbl_to_dec_pwr_by_rate(rtwdev, val, i);\n\t\t*rate_num = 4;\n\t\tbreak;\n\tcase 0xE14:\n\tcase 0x848:\n\t\trate[0] = DESC_RATEMCS4;\n\t\trate[1] = DESC_RATEMCS5;\n\t\trate[2] = DESC_RATEMCS6;\n\t\trate[3] = DESC_RATEMCS7;\n\t\tfor (i = 0; i < 4; ++i)\n\t\t\tpwr_by_rate[i] = tbl_to_dec_pwr_by_rate(rtwdev, val, i);\n\t\t*rate_num = 4;\n\t\tbreak;\n\tcase 0xE18:\n\tcase 0x84C:\n\t\trate[0] = DESC_RATEMCS8;\n\t\trate[1] = DESC_RATEMCS9;\n\t\trate[2] = DESC_RATEMCS10;\n\t\trate[3] = DESC_RATEMCS11;\n\t\tfor (i = 0; i < 4; ++i)\n\t\t\tpwr_by_rate[i] = tbl_to_dec_pwr_by_rate(rtwdev, val, i);\n\t\t*rate_num = 4;\n\t\tbreak;\n\tcase 0xE1C:\n\tcase 0x868:\n\t\trate[0] = DESC_RATEMCS12;\n\t\trate[1] = DESC_RATEMCS13;\n\t\trate[2] = DESC_RATEMCS14;\n\t\trate[3] = DESC_RATEMCS15;\n\t\tfor (i = 0; i < 4; ++i)\n\t\t\tpwr_by_rate[i] = tbl_to_dec_pwr_by_rate(rtwdev, val, i);\n\t\t*rate_num = 4;\n\t\tbreak;\n\tcase 0x838:\n\t\trate[0] = DESC_RATE1M;\n\t\trate[1] = DESC_RATE2M;\n\t\trate[2] = DESC_RATE5_5M;\n\t\tfor (i = 1; i < 4; ++i)\n\t\t\tpwr_by_rate[i - 1] = tbl_to_dec_pwr_by_rate(rtwdev,\n\t\t\t\t\t\t\t\t    val, i);\n\t\t*rate_num = 3;\n\t\tbreak;\n\tcase 0xC20:\n\tcase 0xE20:\n\tcase 0x1820:\n\tcase 0x1A20:\n\t\trate[0] = DESC_RATE1M;\n\t\trate[1] = DESC_RATE2M;\n\t\trate[2] = DESC_RATE5_5M;\n\t\trate[3] = DESC_RATE11M;\n\t\tfor (i = 0; i < 4; ++i)\n\t\t\tpwr_by_rate[i] = tbl_to_dec_pwr_by_rate(rtwdev, val, i);\n\t\t*rate_num = 4;\n\t\tbreak;\n\tcase 0xC24:\n\tcase 0xE24:\n\tcase 0x1824:\n\tcase 0x1A24:\n\t\trate[0] = DESC_RATE6M;\n\t\trate[1] = DESC_RATE9M;\n\t\trate[2] = DESC_RATE12M;\n\t\trate[3] = DESC_RATE18M;\n\t\tfor (i = 0; i < 4; ++i)\n\t\t\tpwr_by_rate[i] = tbl_to_dec_pwr_by_rate(rtwdev, val, i);\n\t\t*rate_num = 4;\n\t\tbreak;\n\tcase 0xC28:\n\tcase 0xE28:\n\tcase 0x1828:\n\tcase 0x1A28:\n\t\trate[0] = DESC_RATE24M;\n\t\trate[1] = DESC_RATE36M;\n\t\trate[2] = DESC_RATE48M;\n\t\trate[3] = DESC_RATE54M;\n\t\tfor (i = 0; i < 4; ++i)\n\t\t\tpwr_by_rate[i] = tbl_to_dec_pwr_by_rate(rtwdev, val, i);\n\t\t*rate_num = 4;\n\t\tbreak;\n\tcase 0xC2C:\n\tcase 0xE2C:\n\tcase 0x182C:\n\tcase 0x1A2C:\n\t\trate[0] = DESC_RATEMCS0;\n\t\trate[1] = DESC_RATEMCS1;\n\t\trate[2] = DESC_RATEMCS2;\n\t\trate[3] = DESC_RATEMCS3;\n\t\tfor (i = 0; i < 4; ++i)\n\t\t\tpwr_by_rate[i] = tbl_to_dec_pwr_by_rate(rtwdev, val, i);\n\t\t*rate_num = 4;\n\t\tbreak;\n\tcase 0xC30:\n\tcase 0xE30:\n\tcase 0x1830:\n\tcase 0x1A30:\n\t\trate[0] = DESC_RATEMCS4;\n\t\trate[1] = DESC_RATEMCS5;\n\t\trate[2] = DESC_RATEMCS6;\n\t\trate[3] = DESC_RATEMCS7;\n\t\tfor (i = 0; i < 4; ++i)\n\t\t\tpwr_by_rate[i] = tbl_to_dec_pwr_by_rate(rtwdev, val, i);\n\t\t*rate_num = 4;\n\t\tbreak;\n\tcase 0xC34:\n\tcase 0xE34:\n\tcase 0x1834:\n\tcase 0x1A34:\n\t\trate[0] = DESC_RATEMCS8;\n\t\trate[1] = DESC_RATEMCS9;\n\t\trate[2] = DESC_RATEMCS10;\n\t\trate[3] = DESC_RATEMCS11;\n\t\tfor (i = 0; i < 4; ++i)\n\t\t\tpwr_by_rate[i] = tbl_to_dec_pwr_by_rate(rtwdev, val, i);\n\t\t*rate_num = 4;\n\t\tbreak;\n\tcase 0xC38:\n\tcase 0xE38:\n\tcase 0x1838:\n\tcase 0x1A38:\n\t\trate[0] = DESC_RATEMCS12;\n\t\trate[1] = DESC_RATEMCS13;\n\t\trate[2] = DESC_RATEMCS14;\n\t\trate[3] = DESC_RATEMCS15;\n\t\tfor (i = 0; i < 4; ++i)\n\t\t\tpwr_by_rate[i] = tbl_to_dec_pwr_by_rate(rtwdev, val, i);\n\t\t*rate_num = 4;\n\t\tbreak;\n\tcase 0xC3C:\n\tcase 0xE3C:\n\tcase 0x183C:\n\tcase 0x1A3C:\n\t\trate[0] = DESC_RATEVHT1SS_MCS0;\n\t\trate[1] = DESC_RATEVHT1SS_MCS1;\n\t\trate[2] = DESC_RATEVHT1SS_MCS2;\n\t\trate[3] = DESC_RATEVHT1SS_MCS3;\n\t\tfor (i = 0; i < 4; ++i)\n\t\t\tpwr_by_rate[i] = tbl_to_dec_pwr_by_rate(rtwdev, val, i);\n\t\t*rate_num = 4;\n\t\tbreak;\n\tcase 0xC40:\n\tcase 0xE40:\n\tcase 0x1840:\n\tcase 0x1A40:\n\t\trate[0] = DESC_RATEVHT1SS_MCS4;\n\t\trate[1] = DESC_RATEVHT1SS_MCS5;\n\t\trate[2] = DESC_RATEVHT1SS_MCS6;\n\t\trate[3] = DESC_RATEVHT1SS_MCS7;\n\t\tfor (i = 0; i < 4; ++i)\n\t\t\tpwr_by_rate[i] = tbl_to_dec_pwr_by_rate(rtwdev, val, i);\n\t\t*rate_num = 4;\n\t\tbreak;\n\tcase 0xC44:\n\tcase 0xE44:\n\tcase 0x1844:\n\tcase 0x1A44:\n\t\trate[0] = DESC_RATEVHT1SS_MCS8;\n\t\trate[1] = DESC_RATEVHT1SS_MCS9;\n\t\trate[2] = DESC_RATEVHT2SS_MCS0;\n\t\trate[3] = DESC_RATEVHT2SS_MCS1;\n\t\tfor (i = 0; i < 4; ++i)\n\t\t\tpwr_by_rate[i] = tbl_to_dec_pwr_by_rate(rtwdev, val, i);\n\t\t*rate_num = 4;\n\t\tbreak;\n\tcase 0xC48:\n\tcase 0xE48:\n\tcase 0x1848:\n\tcase 0x1A48:\n\t\trate[0] = DESC_RATEVHT2SS_MCS2;\n\t\trate[1] = DESC_RATEVHT2SS_MCS3;\n\t\trate[2] = DESC_RATEVHT2SS_MCS4;\n\t\trate[3] = DESC_RATEVHT2SS_MCS5;\n\t\tfor (i = 0; i < 4; ++i)\n\t\t\tpwr_by_rate[i] = tbl_to_dec_pwr_by_rate(rtwdev, val, i);\n\t\t*rate_num = 4;\n\t\tbreak;\n\tcase 0xC4C:\n\tcase 0xE4C:\n\tcase 0x184C:\n\tcase 0x1A4C:\n\t\trate[0] = DESC_RATEVHT2SS_MCS6;\n\t\trate[1] = DESC_RATEVHT2SS_MCS7;\n\t\trate[2] = DESC_RATEVHT2SS_MCS8;\n\t\trate[3] = DESC_RATEVHT2SS_MCS9;\n\t\tfor (i = 0; i < 4; ++i)\n\t\t\tpwr_by_rate[i] = tbl_to_dec_pwr_by_rate(rtwdev, val, i);\n\t\t*rate_num = 4;\n\t\tbreak;\n\tcase 0xCD8:\n\tcase 0xED8:\n\tcase 0x18D8:\n\tcase 0x1AD8:\n\t\trate[0] = DESC_RATEMCS16;\n\t\trate[1] = DESC_RATEMCS17;\n\t\trate[2] = DESC_RATEMCS18;\n\t\trate[3] = DESC_RATEMCS19;\n\t\tfor (i = 0; i < 4; ++i)\n\t\t\tpwr_by_rate[i] = tbl_to_dec_pwr_by_rate(rtwdev, val, i);\n\t\t*rate_num = 4;\n\t\tbreak;\n\tcase 0xCDC:\n\tcase 0xEDC:\n\tcase 0x18DC:\n\tcase 0x1ADC:\n\t\trate[0] = DESC_RATEMCS20;\n\t\trate[1] = DESC_RATEMCS21;\n\t\trate[2] = DESC_RATEMCS22;\n\t\trate[3] = DESC_RATEMCS23;\n\t\tfor (i = 0; i < 4; ++i)\n\t\t\tpwr_by_rate[i] = tbl_to_dec_pwr_by_rate(rtwdev, val, i);\n\t\t*rate_num = 4;\n\t\tbreak;\n\tcase 0xCE0:\n\tcase 0xEE0:\n\tcase 0x18E0:\n\tcase 0x1AE0:\n\t\trate[0] = DESC_RATEVHT3SS_MCS0;\n\t\trate[1] = DESC_RATEVHT3SS_MCS1;\n\t\trate[2] = DESC_RATEVHT3SS_MCS2;\n\t\trate[3] = DESC_RATEVHT3SS_MCS3;\n\t\tfor (i = 0; i < 4; ++i)\n\t\t\tpwr_by_rate[i] = tbl_to_dec_pwr_by_rate(rtwdev, val, i);\n\t\t*rate_num = 4;\n\t\tbreak;\n\tcase 0xCE4:\n\tcase 0xEE4:\n\tcase 0x18E4:\n\tcase 0x1AE4:\n\t\trate[0] = DESC_RATEVHT3SS_MCS4;\n\t\trate[1] = DESC_RATEVHT3SS_MCS5;\n\t\trate[2] = DESC_RATEVHT3SS_MCS6;\n\t\trate[3] = DESC_RATEVHT3SS_MCS7;\n\t\tfor (i = 0; i < 4; ++i)\n\t\t\tpwr_by_rate[i] = tbl_to_dec_pwr_by_rate(rtwdev, val, i);\n\t\t*rate_num = 4;\n\t\tbreak;\n\tcase 0xCE8:\n\tcase 0xEE8:\n\tcase 0x18E8:\n\tcase 0x1AE8:\n\t\trate[0] = DESC_RATEVHT3SS_MCS8;\n\t\trate[1] = DESC_RATEVHT3SS_MCS9;\n\t\tfor (i = 0; i < 2; ++i)\n\t\t\tpwr_by_rate[i] = tbl_to_dec_pwr_by_rate(rtwdev, val, i);\n\t\t*rate_num = 2;\n\t\tbreak;\n\tdefault:\n\t\trtw_warn(rtwdev, \"invalid tx power index addr 0x%08x\\n\", addr);\n\t\tbreak;\n\t}\n}\n\nstatic void rtw_phy_store_tx_power_by_rate(struct rtw_dev *rtwdev,\n\t\t\t\t\t   u32 band, u32 rfpath, u32 txnum,\n\t\t\t\t\t   u32 regaddr, u32 bitmask, u32 data)\n{\n\tstruct rtw_hal *hal = &rtwdev->hal;\n\tu8 rate_num = 0;\n\tu8 rate;\n\tu8 rates[RTW_RF_PATH_MAX] = {0};\n\ts8 offset;\n\ts8 pwr_by_rate[RTW_RF_PATH_MAX] = {0};\n\tint i;\n\n\trtw_phy_get_rate_values_of_txpwr_by_rate(rtwdev, regaddr, bitmask, data,\n\t\t\t\t\t\t rates, pwr_by_rate, &rate_num);\n\n\tif (WARN_ON(rfpath >= RTW_RF_PATH_MAX ||\n\t\t    (band != PHY_BAND_2G && band != PHY_BAND_5G) ||\n\t\t    rate_num > RTW_RF_PATH_MAX))\n\t\treturn;\n\n\tfor (i = 0; i < rate_num; i++) {\n\t\toffset = pwr_by_rate[i];\n\t\trate = rates[i];\n\t\tif (band == PHY_BAND_2G)\n\t\t\thal->tx_pwr_by_rate_offset_2g[rfpath][rate] = offset;\n\t\telse if (band == PHY_BAND_5G)\n\t\t\thal->tx_pwr_by_rate_offset_5g[rfpath][rate] = offset;\n\t\telse\n\t\t\tcontinue;\n\t}\n}\n\nvoid rtw_parse_tbl_bb_pg(struct rtw_dev *rtwdev, const struct rtw_table *tbl)\n{\n\tconst struct rtw_phy_pg_cfg_pair *p = tbl->data;\n\tconst struct rtw_phy_pg_cfg_pair *end = p + tbl->size;\n\n\tfor (; p < end; p++) {\n\t\tif (p->addr == 0xfe || p->addr == 0xffe) {\n\t\t\tmsleep(50);\n\t\t\tcontinue;\n\t\t}\n\t\trtw_phy_store_tx_power_by_rate(rtwdev, p->band, p->rf_path,\n\t\t\t\t\t       p->tx_num, p->addr, p->bitmask,\n\t\t\t\t\t       p->data);\n\t}\n}\nEXPORT_SYMBOL(rtw_parse_tbl_bb_pg);\n\nstatic const u8 rtw_channel_idx_5g[RTW_MAX_CHANNEL_NUM_5G] = {\n\t36,  38,  40,  42,  44,  46,  48,  \n\t52,  54,  56,  58,  60,  62,  64,  \n\t100, 102, 104, 106, 108, 110, 112,  \n\t116, 118, 120, 122, 124, 126, 128,  \n\t132, 134, 136, 138, 140, 142, 144,  \n\t149, 151, 153, 155, 157, 159, 161,  \n\t165, 167, 169, 171, 173, 175, 177};  \n\nstatic int rtw_channel_to_idx(u8 band, u8 channel)\n{\n\tint ch_idx;\n\tu8 n_channel;\n\n\tif (band == PHY_BAND_2G) {\n\t\tch_idx = channel - 1;\n\t\tn_channel = RTW_MAX_CHANNEL_NUM_2G;\n\t} else if (band == PHY_BAND_5G) {\n\t\tn_channel = RTW_MAX_CHANNEL_NUM_5G;\n\t\tfor (ch_idx = 0; ch_idx < n_channel; ch_idx++)\n\t\t\tif (rtw_channel_idx_5g[ch_idx] == channel)\n\t\t\t\tbreak;\n\t} else {\n\t\treturn -1;\n\t}\n\n\tif (ch_idx >= n_channel)\n\t\treturn -1;\n\n\treturn ch_idx;\n}\n\nstatic void rtw_phy_set_tx_power_limit(struct rtw_dev *rtwdev, u8 regd, u8 band,\n\t\t\t\t       u8 bw, u8 rs, u8 ch, s8 pwr_limit)\n{\n\tstruct rtw_hal *hal = &rtwdev->hal;\n\tu8 max_power_index = rtwdev->chip->max_power_index;\n\ts8 ww;\n\tint ch_idx;\n\n\tpwr_limit = clamp_t(s8, pwr_limit,\n\t\t\t    -max_power_index, max_power_index);\n\tch_idx = rtw_channel_to_idx(band, ch);\n\n\tif (regd >= RTW_REGD_MAX || bw >= RTW_CHANNEL_WIDTH_MAX ||\n\t    rs >= RTW_RATE_SECTION_MAX || ch_idx < 0) {\n\t\tWARN(1,\n\t\t     \"wrong txpwr_lmt regd=%u, band=%u bw=%u, rs=%u, ch_idx=%u, pwr_limit=%d\\n\",\n\t\t     regd, band, bw, rs, ch_idx, pwr_limit);\n\t\treturn;\n\t}\n\n\tif (band == PHY_BAND_2G) {\n\t\thal->tx_pwr_limit_2g[regd][bw][rs][ch_idx] = pwr_limit;\n\t\tww = hal->tx_pwr_limit_2g[RTW_REGD_WW][bw][rs][ch_idx];\n\t\tww = min_t(s8, ww, pwr_limit);\n\t\thal->tx_pwr_limit_2g[RTW_REGD_WW][bw][rs][ch_idx] = ww;\n\t} else if (band == PHY_BAND_5G) {\n\t\thal->tx_pwr_limit_5g[regd][bw][rs][ch_idx] = pwr_limit;\n\t\tww = hal->tx_pwr_limit_5g[RTW_REGD_WW][bw][rs][ch_idx];\n\t\tww = min_t(s8, ww, pwr_limit);\n\t\thal->tx_pwr_limit_5g[RTW_REGD_WW][bw][rs][ch_idx] = ww;\n\t}\n}\n\n \nstatic void\nrtw_xref_5g_txpwr_lmt(struct rtw_dev *rtwdev, u8 regd,\n\t\t      u8 bw, u8 ch_idx, u8 rs_ht, u8 rs_vht)\n{\n\tstruct rtw_hal *hal = &rtwdev->hal;\n\tu8 max_power_index = rtwdev->chip->max_power_index;\n\ts8 lmt_ht = hal->tx_pwr_limit_5g[regd][bw][rs_ht][ch_idx];\n\ts8 lmt_vht = hal->tx_pwr_limit_5g[regd][bw][rs_vht][ch_idx];\n\n\tif (lmt_ht == lmt_vht)\n\t\treturn;\n\n\tif (lmt_ht == max_power_index)\n\t\thal->tx_pwr_limit_5g[regd][bw][rs_ht][ch_idx] = lmt_vht;\n\n\telse if (lmt_vht == max_power_index)\n\t\thal->tx_pwr_limit_5g[regd][bw][rs_vht][ch_idx] = lmt_ht;\n}\n\n \nstatic void\nrtw_xref_txpwr_lmt_by_rs(struct rtw_dev *rtwdev, u8 regd, u8 bw, u8 ch_idx)\n{\n\tu8 rs_idx, rs_ht, rs_vht;\n\tu8 rs_cmp[2][2] = {{RTW_RATE_SECTION_HT_1S, RTW_RATE_SECTION_VHT_1S},\n\t\t\t   {RTW_RATE_SECTION_HT_2S, RTW_RATE_SECTION_VHT_2S} };\n\n\tfor (rs_idx = 0; rs_idx < 2; rs_idx++) {\n\t\trs_ht = rs_cmp[rs_idx][0];\n\t\trs_vht = rs_cmp[rs_idx][1];\n\n\t\trtw_xref_5g_txpwr_lmt(rtwdev, regd, bw, ch_idx, rs_ht, rs_vht);\n\t}\n}\n\n \nstatic void\nrtw_xref_5g_txpwr_lmt_by_ch(struct rtw_dev *rtwdev, u8 regd, u8 bw)\n{\n\tu8 ch_idx;\n\n\tfor (ch_idx = 0; ch_idx < RTW_MAX_CHANNEL_NUM_5G; ch_idx++)\n\t\trtw_xref_txpwr_lmt_by_rs(rtwdev, regd, bw, ch_idx);\n}\n\n \nstatic void\nrtw_xref_txpwr_lmt_by_bw(struct rtw_dev *rtwdev, u8 regd)\n{\n\tu8 bw;\n\n\tfor (bw = RTW_CHANNEL_WIDTH_20; bw <= RTW_CHANNEL_WIDTH_40; bw++)\n\t\trtw_xref_5g_txpwr_lmt_by_ch(rtwdev, regd, bw);\n}\n\n \nstatic void rtw_xref_txpwr_lmt(struct rtw_dev *rtwdev)\n{\n\tu8 regd;\n\n\tfor (regd = 0; regd < RTW_REGD_MAX; regd++)\n\t\trtw_xref_txpwr_lmt_by_bw(rtwdev, regd);\n}\n\nstatic void\n__cfg_txpwr_lmt_by_alt(struct rtw_hal *hal, u8 regd, u8 regd_alt, u8 bw, u8 rs)\n{\n\tu8 ch;\n\n\tfor (ch = 0; ch < RTW_MAX_CHANNEL_NUM_2G; ch++)\n\t\thal->tx_pwr_limit_2g[regd][bw][rs][ch] =\n\t\t\thal->tx_pwr_limit_2g[regd_alt][bw][rs][ch];\n\n\tfor (ch = 0; ch < RTW_MAX_CHANNEL_NUM_5G; ch++)\n\t\thal->tx_pwr_limit_5g[regd][bw][rs][ch] =\n\t\t\thal->tx_pwr_limit_5g[regd_alt][bw][rs][ch];\n}\n\nstatic void\nrtw_cfg_txpwr_lmt_by_alt(struct rtw_dev *rtwdev, u8 regd, u8 regd_alt)\n{\n\tu8 bw, rs;\n\n\tfor (bw = 0; bw < RTW_CHANNEL_WIDTH_MAX; bw++)\n\t\tfor (rs = 0; rs < RTW_RATE_SECTION_MAX; rs++)\n\t\t\t__cfg_txpwr_lmt_by_alt(&rtwdev->hal, regd, regd_alt,\n\t\t\t\t\t       bw, rs);\n}\n\nvoid rtw_parse_tbl_txpwr_lmt(struct rtw_dev *rtwdev,\n\t\t\t     const struct rtw_table *tbl)\n{\n\tconst struct rtw_txpwr_lmt_cfg_pair *p = tbl->data;\n\tconst struct rtw_txpwr_lmt_cfg_pair *end = p + tbl->size;\n\tu32 regd_cfg_flag = 0;\n\tu8 regd_alt;\n\tu8 i;\n\n\tfor (; p < end; p++) {\n\t\tregd_cfg_flag |= BIT(p->regd);\n\t\trtw_phy_set_tx_power_limit(rtwdev, p->regd, p->band,\n\t\t\t\t\t   p->bw, p->rs, p->ch, p->txpwr_lmt);\n\t}\n\n\tfor (i = 0; i < RTW_REGD_MAX; i++) {\n\t\tif (i == RTW_REGD_WW)\n\t\t\tcontinue;\n\n\t\tif (regd_cfg_flag & BIT(i))\n\t\t\tcontinue;\n\n\t\trtw_dbg(rtwdev, RTW_DBG_REGD,\n\t\t\t\"txpwr regd %d does not be configured\\n\", i);\n\n\t\tif (rtw_regd_has_alt(i, &regd_alt) &&\n\t\t    regd_cfg_flag & BIT(regd_alt)) {\n\t\t\trtw_dbg(rtwdev, RTW_DBG_REGD,\n\t\t\t\t\"cfg txpwr regd %d by regd %d as alternative\\n\",\n\t\t\t\ti, regd_alt);\n\n\t\t\trtw_cfg_txpwr_lmt_by_alt(rtwdev, i, regd_alt);\n\t\t\tcontinue;\n\t\t}\n\n\t\trtw_dbg(rtwdev, RTW_DBG_REGD, \"cfg txpwr regd %d by WW\\n\", i);\n\t\trtw_cfg_txpwr_lmt_by_alt(rtwdev, i, RTW_REGD_WW);\n\t}\n\n\trtw_xref_txpwr_lmt(rtwdev);\n}\nEXPORT_SYMBOL(rtw_parse_tbl_txpwr_lmt);\n\nvoid rtw_phy_cfg_mac(struct rtw_dev *rtwdev, const struct rtw_table *tbl,\n\t\t     u32 addr, u32 data)\n{\n\trtw_write8(rtwdev, addr, data);\n}\nEXPORT_SYMBOL(rtw_phy_cfg_mac);\n\nvoid rtw_phy_cfg_agc(struct rtw_dev *rtwdev, const struct rtw_table *tbl,\n\t\t     u32 addr, u32 data)\n{\n\trtw_write32(rtwdev, addr, data);\n}\nEXPORT_SYMBOL(rtw_phy_cfg_agc);\n\nvoid rtw_phy_cfg_bb(struct rtw_dev *rtwdev, const struct rtw_table *tbl,\n\t\t    u32 addr, u32 data)\n{\n\tif (addr == 0xfe)\n\t\tmsleep(50);\n\telse if (addr == 0xfd)\n\t\tmdelay(5);\n\telse if (addr == 0xfc)\n\t\tmdelay(1);\n\telse if (addr == 0xfb)\n\t\tusleep_range(50, 60);\n\telse if (addr == 0xfa)\n\t\tudelay(5);\n\telse if (addr == 0xf9)\n\t\tudelay(1);\n\telse\n\t\trtw_write32(rtwdev, addr, data);\n}\nEXPORT_SYMBOL(rtw_phy_cfg_bb);\n\nvoid rtw_phy_cfg_rf(struct rtw_dev *rtwdev, const struct rtw_table *tbl,\n\t\t    u32 addr, u32 data)\n{\n\tif (addr == 0xffe) {\n\t\tmsleep(50);\n\t} else if (addr == 0xfe) {\n\t\tusleep_range(100, 110);\n\t} else {\n\t\trtw_write_rf(rtwdev, tbl->rf_path, addr, RFREG_MASK, data);\n\t\tudelay(1);\n\t}\n}\nEXPORT_SYMBOL(rtw_phy_cfg_rf);\n\nstatic void rtw_load_rfk_table(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_dpk_info *dpk_info = &rtwdev->dm_info.dpk_info;\n\n\tif (!chip->rfk_init_tbl)\n\t\treturn;\n\n\trtw_write32_mask(rtwdev, 0x1e24, BIT(17), 0x1);\n\trtw_write32_mask(rtwdev, 0x1cd0, BIT(28), 0x1);\n\trtw_write32_mask(rtwdev, 0x1cd0, BIT(29), 0x1);\n\trtw_write32_mask(rtwdev, 0x1cd0, BIT(30), 0x1);\n\trtw_write32_mask(rtwdev, 0x1cd0, BIT(31), 0x0);\n\n\trtw_load_table(rtwdev, chip->rfk_init_tbl);\n\n\tdpk_info->is_dpk_pwr_on = true;\n}\n\nvoid rtw_phy_load_tables(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tu8 rf_path;\n\n\trtw_load_table(rtwdev, chip->mac_tbl);\n\trtw_load_table(rtwdev, chip->bb_tbl);\n\trtw_load_table(rtwdev, chip->agc_tbl);\n\trtw_load_rfk_table(rtwdev);\n\n\tfor (rf_path = 0; rf_path < rtwdev->hal.rf_path_num; rf_path++) {\n\t\tconst struct rtw_table *tbl;\n\n\t\ttbl = chip->rf_tbl[rf_path];\n\t\trtw_load_table(rtwdev, tbl);\n\t}\n}\nEXPORT_SYMBOL(rtw_phy_load_tables);\n\nstatic u8 rtw_get_channel_group(u8 channel, u8 rate)\n{\n\tswitch (channel) {\n\tdefault:\n\t\tWARN_ON(1);\n\t\tfallthrough;\n\tcase 1:\n\tcase 2:\n\tcase 36:\n\tcase 38:\n\tcase 40:\n\tcase 42:\n\t\treturn 0;\n\tcase 3:\n\tcase 4:\n\tcase 5:\n\tcase 44:\n\tcase 46:\n\tcase 48:\n\tcase 50:\n\t\treturn 1;\n\tcase 6:\n\tcase 7:\n\tcase 8:\n\tcase 52:\n\tcase 54:\n\tcase 56:\n\tcase 58:\n\t\treturn 2;\n\tcase 9:\n\tcase 10:\n\tcase 11:\n\tcase 60:\n\tcase 62:\n\tcase 64:\n\t\treturn 3;\n\tcase 12:\n\tcase 13:\n\tcase 100:\n\tcase 102:\n\tcase 104:\n\tcase 106:\n\t\treturn 4;\n\tcase 14:\n\t\treturn rate <= DESC_RATE11M ? 5 : 4;\n\tcase 108:\n\tcase 110:\n\tcase 112:\n\tcase 114:\n\t\treturn 5;\n\tcase 116:\n\tcase 118:\n\tcase 120:\n\tcase 122:\n\t\treturn 6;\n\tcase 124:\n\tcase 126:\n\tcase 128:\n\tcase 130:\n\t\treturn 7;\n\tcase 132:\n\tcase 134:\n\tcase 136:\n\tcase 138:\n\t\treturn 8;\n\tcase 140:\n\tcase 142:\n\tcase 144:\n\t\treturn 9;\n\tcase 149:\n\tcase 151:\n\tcase 153:\n\tcase 155:\n\t\treturn 10;\n\tcase 157:\n\tcase 159:\n\tcase 161:\n\t\treturn 11;\n\tcase 165:\n\tcase 167:\n\tcase 169:\n\tcase 171:\n\t\treturn 12;\n\tcase 173:\n\tcase 175:\n\tcase 177:\n\t\treturn 13;\n\t}\n}\n\nstatic s8 rtw_phy_get_dis_dpd_by_rate_diff(struct rtw_dev *rtwdev, u16 rate)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\ts8 dpd_diff = 0;\n\n\tif (!chip->en_dis_dpd)\n\t\treturn 0;\n\n#define RTW_DPD_RATE_CHECK(_rate)\t\t\t\t\t\\\n\tcase DESC_RATE ## _rate:\t\t\t\t\t\\\n\tif (DIS_DPD_RATE ## _rate & chip->dpd_ratemask)\t\t\t\\\n\t\tdpd_diff = -6 * chip->txgi_factor;\t\t\t\\\n\tbreak\n\n\tswitch (rate) {\n\tRTW_DPD_RATE_CHECK(6M);\n\tRTW_DPD_RATE_CHECK(9M);\n\tRTW_DPD_RATE_CHECK(MCS0);\n\tRTW_DPD_RATE_CHECK(MCS1);\n\tRTW_DPD_RATE_CHECK(MCS8);\n\tRTW_DPD_RATE_CHECK(MCS9);\n\tRTW_DPD_RATE_CHECK(VHT1SS_MCS0);\n\tRTW_DPD_RATE_CHECK(VHT1SS_MCS1);\n\tRTW_DPD_RATE_CHECK(VHT2SS_MCS0);\n\tRTW_DPD_RATE_CHECK(VHT2SS_MCS1);\n\t}\n#undef RTW_DPD_RATE_CHECK\n\n\treturn dpd_diff;\n}\n\nstatic u8 rtw_phy_get_2g_tx_power_index(struct rtw_dev *rtwdev,\n\t\t\t\t\tstruct rtw_2g_txpwr_idx *pwr_idx_2g,\n\t\t\t\t\tenum rtw_bandwidth bandwidth,\n\t\t\t\t\tu8 rate, u8 group)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tu8 tx_power;\n\tbool mcs_rate;\n\tbool above_2ss;\n\tu8 factor = chip->txgi_factor;\n\n\tif (rate <= DESC_RATE11M)\n\t\ttx_power = pwr_idx_2g->cck_base[group];\n\telse\n\t\ttx_power = pwr_idx_2g->bw40_base[group];\n\n\tif (rate >= DESC_RATE6M && rate <= DESC_RATE54M)\n\t\ttx_power += pwr_idx_2g->ht_1s_diff.ofdm * factor;\n\n\tmcs_rate = (rate >= DESC_RATEMCS0 && rate <= DESC_RATEMCS15) ||\n\t\t   (rate >= DESC_RATEVHT1SS_MCS0 &&\n\t\t    rate <= DESC_RATEVHT2SS_MCS9);\n\tabove_2ss = (rate >= DESC_RATEMCS8 && rate <= DESC_RATEMCS15) ||\n\t\t    (rate >= DESC_RATEVHT2SS_MCS0);\n\n\tif (!mcs_rate)\n\t\treturn tx_power;\n\n\tswitch (bandwidth) {\n\tdefault:\n\t\tWARN_ON(1);\n\t\tfallthrough;\n\tcase RTW_CHANNEL_WIDTH_20:\n\t\ttx_power += pwr_idx_2g->ht_1s_diff.bw20 * factor;\n\t\tif (above_2ss)\n\t\t\ttx_power += pwr_idx_2g->ht_2s_diff.bw20 * factor;\n\t\tbreak;\n\tcase RTW_CHANNEL_WIDTH_40:\n\t\t \n\t\tif (above_2ss)\n\t\t\ttx_power += pwr_idx_2g->ht_2s_diff.bw40 * factor;\n\t\tbreak;\n\t}\n\n\treturn tx_power;\n}\n\nstatic u8 rtw_phy_get_5g_tx_power_index(struct rtw_dev *rtwdev,\n\t\t\t\t\tstruct rtw_5g_txpwr_idx *pwr_idx_5g,\n\t\t\t\t\tenum rtw_bandwidth bandwidth,\n\t\t\t\t\tu8 rate, u8 group)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tu8 tx_power;\n\tu8 upper, lower;\n\tbool mcs_rate;\n\tbool above_2ss;\n\tu8 factor = chip->txgi_factor;\n\n\ttx_power = pwr_idx_5g->bw40_base[group];\n\n\tmcs_rate = (rate >= DESC_RATEMCS0 && rate <= DESC_RATEMCS15) ||\n\t\t   (rate >= DESC_RATEVHT1SS_MCS0 &&\n\t\t    rate <= DESC_RATEVHT2SS_MCS9);\n\tabove_2ss = (rate >= DESC_RATEMCS8 && rate <= DESC_RATEMCS15) ||\n\t\t    (rate >= DESC_RATEVHT2SS_MCS0);\n\n\tif (!mcs_rate) {\n\t\ttx_power += pwr_idx_5g->ht_1s_diff.ofdm * factor;\n\t\treturn tx_power;\n\t}\n\n\tswitch (bandwidth) {\n\tdefault:\n\t\tWARN_ON(1);\n\t\tfallthrough;\n\tcase RTW_CHANNEL_WIDTH_20:\n\t\ttx_power += pwr_idx_5g->ht_1s_diff.bw20 * factor;\n\t\tif (above_2ss)\n\t\t\ttx_power += pwr_idx_5g->ht_2s_diff.bw20 * factor;\n\t\tbreak;\n\tcase RTW_CHANNEL_WIDTH_40:\n\t\t \n\t\tif (above_2ss)\n\t\t\ttx_power += pwr_idx_5g->ht_2s_diff.bw40 * factor;\n\t\tbreak;\n\tcase RTW_CHANNEL_WIDTH_80:\n\t\t \n\t\tlower = pwr_idx_5g->bw40_base[group];\n\t\tupper = pwr_idx_5g->bw40_base[group + 1];\n\n\t\ttx_power = (lower + upper) / 2;\n\t\ttx_power += pwr_idx_5g->vht_1s_diff.bw80 * factor;\n\t\tif (above_2ss)\n\t\t\ttx_power += pwr_idx_5g->vht_2s_diff.bw80 * factor;\n\t\tbreak;\n\t}\n\n\treturn tx_power;\n}\n\n \nstatic u8 rtw_phy_rate_to_rate_section(u8 rate)\n{\n\tif (rate >= DESC_RATE1M && rate <= DESC_RATE11M)\n\t\treturn RTW_RATE_SECTION_CCK;\n\telse if (rate >= DESC_RATE6M && rate <= DESC_RATE54M)\n\t\treturn RTW_RATE_SECTION_OFDM;\n\telse if (rate >= DESC_RATEMCS0 && rate <= DESC_RATEMCS7)\n\t\treturn RTW_RATE_SECTION_HT_1S;\n\telse if (rate >= DESC_RATEMCS8 && rate <= DESC_RATEMCS15)\n\t\treturn RTW_RATE_SECTION_HT_2S;\n\telse if (rate >= DESC_RATEVHT1SS_MCS0 && rate <= DESC_RATEVHT1SS_MCS9)\n\t\treturn RTW_RATE_SECTION_VHT_1S;\n\telse if (rate >= DESC_RATEVHT2SS_MCS0 && rate <= DESC_RATEVHT2SS_MCS9)\n\t\treturn RTW_RATE_SECTION_VHT_2S;\n\telse\n\t\treturn RTW_RATE_SECTION_MAX;\n}\n\nstatic s8 rtw_phy_get_tx_power_limit(struct rtw_dev *rtwdev, u8 band,\n\t\t\t\t     enum rtw_bandwidth bw, u8 rf_path,\n\t\t\t\t     u8 rate, u8 channel, u8 regd)\n{\n\tstruct rtw_hal *hal = &rtwdev->hal;\n\tu8 *cch_by_bw = hal->cch_by_bw;\n\ts8 power_limit = (s8)rtwdev->chip->max_power_index;\n\tu8 rs = rtw_phy_rate_to_rate_section(rate);\n\tint ch_idx;\n\tu8 cur_bw, cur_ch;\n\ts8 cur_lmt;\n\n\tif (regd > RTW_REGD_WW)\n\t\treturn power_limit;\n\n\tif (rs == RTW_RATE_SECTION_MAX)\n\t\tgoto err;\n\n\t \n\tif (rs == RTW_RATE_SECTION_CCK || rs == RTW_RATE_SECTION_OFDM)\n\t\tbw = RTW_CHANNEL_WIDTH_20;\n\n\t \n\tif (rs == RTW_RATE_SECTION_HT_1S || rs == RTW_RATE_SECTION_HT_2S)\n\t\tbw = min_t(u8, bw, RTW_CHANNEL_WIDTH_40);\n\n\t \n\tfor (cur_bw = RTW_CHANNEL_WIDTH_20; cur_bw <= bw; cur_bw++) {\n\t\tcur_ch = cch_by_bw[cur_bw];\n\n\t\tch_idx = rtw_channel_to_idx(band, cur_ch);\n\t\tif (ch_idx < 0)\n\t\t\tgoto err;\n\n\t\tcur_lmt = cur_ch <= RTW_MAX_CHANNEL_NUM_2G ?\n\t\t\thal->tx_pwr_limit_2g[regd][cur_bw][rs][ch_idx] :\n\t\t\thal->tx_pwr_limit_5g[regd][cur_bw][rs][ch_idx];\n\n\t\tpower_limit = min_t(s8, cur_lmt, power_limit);\n\t}\n\n\treturn power_limit;\n\nerr:\n\tWARN(1, \"invalid arguments, band=%d, bw=%d, path=%d, rate=%d, ch=%d\\n\",\n\t     band, bw, rf_path, rate, channel);\n\treturn (s8)rtwdev->chip->max_power_index;\n}\n\nstatic s8 rtw_phy_get_tx_power_sar(struct rtw_dev *rtwdev, u8 sar_band,\n\t\t\t\t   u8 rf_path, u8 rate)\n{\n\tu8 rs = rtw_phy_rate_to_rate_section(rate);\n\tstruct rtw_sar_arg arg = {\n\t\t.sar_band = sar_band,\n\t\t.path = rf_path,\n\t\t.rs = rs,\n\t};\n\n\tif (rs == RTW_RATE_SECTION_MAX)\n\t\tgoto err;\n\n\treturn rtw_query_sar(rtwdev, &arg);\n\nerr:\n\tWARN(1, \"invalid arguments, sar_band=%d, path=%d, rate=%d\\n\",\n\t     sar_band, rf_path, rate);\n\treturn (s8)rtwdev->chip->max_power_index;\n}\n\nvoid rtw_get_tx_power_params(struct rtw_dev *rtwdev, u8 path, u8 rate, u8 bw,\n\t\t\t     u8 ch, u8 regd, struct rtw_power_params *pwr_param)\n{\n\tstruct rtw_hal *hal = &rtwdev->hal;\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tstruct rtw_txpwr_idx *pwr_idx;\n\tu8 group, band;\n\tu8 *base = &pwr_param->pwr_base;\n\ts8 *offset = &pwr_param->pwr_offset;\n\ts8 *limit = &pwr_param->pwr_limit;\n\ts8 *remnant = &pwr_param->pwr_remnant;\n\ts8 *sar = &pwr_param->pwr_sar;\n\n\tpwr_idx = &rtwdev->efuse.txpwr_idx_table[path];\n\tgroup = rtw_get_channel_group(ch, rate);\n\n\t \n\tif (IS_CH_2G_BAND(ch)) {\n\t\tband = PHY_BAND_2G;\n\t\t*base = rtw_phy_get_2g_tx_power_index(rtwdev,\n\t\t\t\t\t\t      &pwr_idx->pwr_idx_2g,\n\t\t\t\t\t\t      bw, rate, group);\n\t\t*offset = hal->tx_pwr_by_rate_offset_2g[path][rate];\n\t} else {\n\t\tband = PHY_BAND_5G;\n\t\t*base = rtw_phy_get_5g_tx_power_index(rtwdev,\n\t\t\t\t\t\t      &pwr_idx->pwr_idx_5g,\n\t\t\t\t\t\t      bw, rate, group);\n\t\t*offset = hal->tx_pwr_by_rate_offset_5g[path][rate];\n\t}\n\n\t*limit = rtw_phy_get_tx_power_limit(rtwdev, band, bw, path,\n\t\t\t\t\t    rate, ch, regd);\n\t*remnant = (rate <= DESC_RATE11M ? dm_info->txagc_remnant_cck :\n\t\t    dm_info->txagc_remnant_ofdm);\n\t*sar = rtw_phy_get_tx_power_sar(rtwdev, hal->sar_band, path, rate);\n}\n\nu8\nrtw_phy_get_tx_power_index(struct rtw_dev *rtwdev, u8 rf_path, u8 rate,\n\t\t\t   enum rtw_bandwidth bandwidth, u8 channel, u8 regd)\n{\n\tstruct rtw_power_params pwr_param = {0};\n\tu8 tx_power;\n\ts8 offset;\n\n\trtw_get_tx_power_params(rtwdev, rf_path, rate, bandwidth,\n\t\t\t\tchannel, regd, &pwr_param);\n\n\ttx_power = pwr_param.pwr_base;\n\toffset = min3(pwr_param.pwr_offset,\n\t\t      pwr_param.pwr_limit,\n\t\t      pwr_param.pwr_sar);\n\n\tif (rtwdev->chip->en_dis_dpd)\n\t\toffset += rtw_phy_get_dis_dpd_by_rate_diff(rtwdev, rate);\n\n\ttx_power += offset + pwr_param.pwr_remnant;\n\n\tif (tx_power > rtwdev->chip->max_power_index)\n\t\ttx_power = rtwdev->chip->max_power_index;\n\n\treturn tx_power;\n}\nEXPORT_SYMBOL(rtw_phy_get_tx_power_index);\n\nstatic void rtw_phy_set_tx_power_index_by_rs(struct rtw_dev *rtwdev,\n\t\t\t\t\t     u8 ch, u8 path, u8 rs)\n{\n\tstruct rtw_hal *hal = &rtwdev->hal;\n\tu8 regd = rtw_regd_get(rtwdev);\n\tu8 *rates;\n\tu8 size;\n\tu8 rate;\n\tu8 pwr_idx;\n\tu8 bw;\n\tint i;\n\n\tif (rs >= RTW_RATE_SECTION_MAX)\n\t\treturn;\n\n\trates = rtw_rate_section[rs];\n\tsize = rtw_rate_size[rs];\n\tbw = hal->current_band_width;\n\tfor (i = 0; i < size; i++) {\n\t\trate = rates[i];\n\t\tpwr_idx = rtw_phy_get_tx_power_index(rtwdev, path, rate,\n\t\t\t\t\t\t     bw, ch, regd);\n\t\thal->tx_pwr_tbl[path][rate] = pwr_idx;\n\t}\n}\n\n \nstatic void rtw_phy_set_tx_power_level_by_path(struct rtw_dev *rtwdev,\n\t\t\t\t\t       u8 ch, u8 path)\n{\n\tstruct rtw_hal *hal = &rtwdev->hal;\n\tu8 rs;\n\n\t \n\tif (hal->current_band_type == RTW_BAND_2G)\n\t\trs = RTW_RATE_SECTION_CCK;\n\telse\n\t\trs = RTW_RATE_SECTION_OFDM;\n\n\tfor (; rs < RTW_RATE_SECTION_MAX; rs++)\n\t\trtw_phy_set_tx_power_index_by_rs(rtwdev, ch, path, rs);\n}\n\nvoid rtw_phy_set_tx_power_level(struct rtw_dev *rtwdev, u8 channel)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_hal *hal = &rtwdev->hal;\n\tu8 path;\n\n\tmutex_lock(&hal->tx_power_mutex);\n\n\tfor (path = 0; path < hal->rf_path_num; path++)\n\t\trtw_phy_set_tx_power_level_by_path(rtwdev, channel, path);\n\n\tchip->ops->set_tx_power_index(rtwdev);\n\tmutex_unlock(&hal->tx_power_mutex);\n}\nEXPORT_SYMBOL(rtw_phy_set_tx_power_level);\n\nstatic void\nrtw_phy_tx_power_by_rate_config_by_path(struct rtw_hal *hal, u8 path,\n\t\t\t\t\tu8 rs, u8 size, u8 *rates)\n{\n\tu8 rate;\n\tu8 base_idx, rate_idx;\n\ts8 base_2g, base_5g;\n\n\tif (rs >= RTW_RATE_SECTION_VHT_1S)\n\t\tbase_idx = rates[size - 3];\n\telse\n\t\tbase_idx = rates[size - 1];\n\tbase_2g = hal->tx_pwr_by_rate_offset_2g[path][base_idx];\n\tbase_5g = hal->tx_pwr_by_rate_offset_5g[path][base_idx];\n\thal->tx_pwr_by_rate_base_2g[path][rs] = base_2g;\n\thal->tx_pwr_by_rate_base_5g[path][rs] = base_5g;\n\tfor (rate = 0; rate < size; rate++) {\n\t\trate_idx = rates[rate];\n\t\thal->tx_pwr_by_rate_offset_2g[path][rate_idx] -= base_2g;\n\t\thal->tx_pwr_by_rate_offset_5g[path][rate_idx] -= base_5g;\n\t}\n}\n\nvoid rtw_phy_tx_power_by_rate_config(struct rtw_hal *hal)\n{\n\tu8 path;\n\n\tfor (path = 0; path < RTW_RF_PATH_MAX; path++) {\n\t\trtw_phy_tx_power_by_rate_config_by_path(hal, path,\n\t\t\t\tRTW_RATE_SECTION_CCK,\n\t\t\t\trtw_cck_size, rtw_cck_rates);\n\t\trtw_phy_tx_power_by_rate_config_by_path(hal, path,\n\t\t\t\tRTW_RATE_SECTION_OFDM,\n\t\t\t\trtw_ofdm_size, rtw_ofdm_rates);\n\t\trtw_phy_tx_power_by_rate_config_by_path(hal, path,\n\t\t\t\tRTW_RATE_SECTION_HT_1S,\n\t\t\t\trtw_ht_1s_size, rtw_ht_1s_rates);\n\t\trtw_phy_tx_power_by_rate_config_by_path(hal, path,\n\t\t\t\tRTW_RATE_SECTION_HT_2S,\n\t\t\t\trtw_ht_2s_size, rtw_ht_2s_rates);\n\t\trtw_phy_tx_power_by_rate_config_by_path(hal, path,\n\t\t\t\tRTW_RATE_SECTION_VHT_1S,\n\t\t\t\trtw_vht_1s_size, rtw_vht_1s_rates);\n\t\trtw_phy_tx_power_by_rate_config_by_path(hal, path,\n\t\t\t\tRTW_RATE_SECTION_VHT_2S,\n\t\t\t\trtw_vht_2s_size, rtw_vht_2s_rates);\n\t}\n}\n\nstatic void\n__rtw_phy_tx_power_limit_config(struct rtw_hal *hal, u8 regd, u8 bw, u8 rs)\n{\n\ts8 base;\n\tu8 ch;\n\n\tfor (ch = 0; ch < RTW_MAX_CHANNEL_NUM_2G; ch++) {\n\t\tbase = hal->tx_pwr_by_rate_base_2g[0][rs];\n\t\thal->tx_pwr_limit_2g[regd][bw][rs][ch] -= base;\n\t}\n\n\tfor (ch = 0; ch < RTW_MAX_CHANNEL_NUM_5G; ch++) {\n\t\tbase = hal->tx_pwr_by_rate_base_5g[0][rs];\n\t\thal->tx_pwr_limit_5g[regd][bw][rs][ch] -= base;\n\t}\n}\n\nvoid rtw_phy_tx_power_limit_config(struct rtw_hal *hal)\n{\n\tu8 regd, bw, rs;\n\n\t \n\thal->cch_by_bw[RTW_CHANNEL_WIDTH_20] = 1;\n\n\tfor (regd = 0; regd < RTW_REGD_MAX; regd++)\n\t\tfor (bw = 0; bw < RTW_CHANNEL_WIDTH_MAX; bw++)\n\t\t\tfor (rs = 0; rs < RTW_RATE_SECTION_MAX; rs++)\n\t\t\t\t__rtw_phy_tx_power_limit_config(hal, regd, bw, rs);\n}\n\nstatic void rtw_phy_init_tx_power_limit(struct rtw_dev *rtwdev,\n\t\t\t\t\tu8 regd, u8 bw, u8 rs)\n{\n\tstruct rtw_hal *hal = &rtwdev->hal;\n\ts8 max_power_index = (s8)rtwdev->chip->max_power_index;\n\tu8 ch;\n\n\t \n\tfor (ch = 0; ch < RTW_MAX_CHANNEL_NUM_2G; ch++)\n\t\thal->tx_pwr_limit_2g[regd][bw][rs][ch] = max_power_index;\n\n\t \n\tfor (ch = 0; ch < RTW_MAX_CHANNEL_NUM_5G; ch++)\n\t\thal->tx_pwr_limit_5g[regd][bw][rs][ch] = max_power_index;\n}\n\nvoid rtw_phy_init_tx_power(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_hal *hal = &rtwdev->hal;\n\tu8 regd, path, rate, rs, bw;\n\n\t \n\tfor (path = 0; path < RTW_RF_PATH_MAX; path++) {\n\t\tfor (rate = 0; rate < DESC_RATE_MAX; rate++) {\n\t\t\thal->tx_pwr_by_rate_offset_2g[path][rate] = 0;\n\t\t\thal->tx_pwr_by_rate_offset_5g[path][rate] = 0;\n\t\t}\n\t}\n\n\t \n\tfor (regd = 0; regd < RTW_REGD_MAX; regd++)\n\t\tfor (bw = 0; bw < RTW_CHANNEL_WIDTH_MAX; bw++)\n\t\t\tfor (rs = 0; rs < RTW_RATE_SECTION_MAX; rs++)\n\t\t\t\trtw_phy_init_tx_power_limit(rtwdev, regd, bw,\n\t\t\t\t\t\t\t    rs);\n}\n\nvoid rtw_phy_config_swing_table(struct rtw_dev *rtwdev,\n\t\t\t\tstruct rtw_swing_table *swing_table)\n{\n\tconst struct rtw_pwr_track_tbl *tbl = rtwdev->chip->pwr_track_tbl;\n\tu8 channel = rtwdev->hal.current_channel;\n\n\tif (IS_CH_2G_BAND(channel)) {\n\t\tif (rtwdev->dm_info.tx_rate <= DESC_RATE11M) {\n\t\t\tswing_table->p[RF_PATH_A] = tbl->pwrtrk_2g_ccka_p;\n\t\t\tswing_table->n[RF_PATH_A] = tbl->pwrtrk_2g_ccka_n;\n\t\t\tswing_table->p[RF_PATH_B] = tbl->pwrtrk_2g_cckb_p;\n\t\t\tswing_table->n[RF_PATH_B] = tbl->pwrtrk_2g_cckb_n;\n\t\t} else {\n\t\t\tswing_table->p[RF_PATH_A] = tbl->pwrtrk_2ga_p;\n\t\t\tswing_table->n[RF_PATH_A] = tbl->pwrtrk_2ga_n;\n\t\t\tswing_table->p[RF_PATH_B] = tbl->pwrtrk_2gb_p;\n\t\t\tswing_table->n[RF_PATH_B] = tbl->pwrtrk_2gb_n;\n\t\t}\n\t} else if (IS_CH_5G_BAND_1(channel) || IS_CH_5G_BAND_2(channel)) {\n\t\tswing_table->p[RF_PATH_A] = tbl->pwrtrk_5ga_p[RTW_PWR_TRK_5G_1];\n\t\tswing_table->n[RF_PATH_A] = tbl->pwrtrk_5ga_n[RTW_PWR_TRK_5G_1];\n\t\tswing_table->p[RF_PATH_B] = tbl->pwrtrk_5gb_p[RTW_PWR_TRK_5G_1];\n\t\tswing_table->n[RF_PATH_B] = tbl->pwrtrk_5gb_n[RTW_PWR_TRK_5G_1];\n\t} else if (IS_CH_5G_BAND_3(channel)) {\n\t\tswing_table->p[RF_PATH_A] = tbl->pwrtrk_5ga_p[RTW_PWR_TRK_5G_2];\n\t\tswing_table->n[RF_PATH_A] = tbl->pwrtrk_5ga_n[RTW_PWR_TRK_5G_2];\n\t\tswing_table->p[RF_PATH_B] = tbl->pwrtrk_5gb_p[RTW_PWR_TRK_5G_2];\n\t\tswing_table->n[RF_PATH_B] = tbl->pwrtrk_5gb_n[RTW_PWR_TRK_5G_2];\n\t} else if (IS_CH_5G_BAND_4(channel)) {\n\t\tswing_table->p[RF_PATH_A] = tbl->pwrtrk_5ga_p[RTW_PWR_TRK_5G_3];\n\t\tswing_table->n[RF_PATH_A] = tbl->pwrtrk_5ga_n[RTW_PWR_TRK_5G_3];\n\t\tswing_table->p[RF_PATH_B] = tbl->pwrtrk_5gb_p[RTW_PWR_TRK_5G_3];\n\t\tswing_table->n[RF_PATH_B] = tbl->pwrtrk_5gb_n[RTW_PWR_TRK_5G_3];\n\t} else {\n\t\tswing_table->p[RF_PATH_A] = tbl->pwrtrk_2ga_p;\n\t\tswing_table->n[RF_PATH_A] = tbl->pwrtrk_2ga_n;\n\t\tswing_table->p[RF_PATH_B] = tbl->pwrtrk_2gb_p;\n\t\tswing_table->n[RF_PATH_B] = tbl->pwrtrk_2gb_n;\n\t}\n}\nEXPORT_SYMBOL(rtw_phy_config_swing_table);\n\nvoid rtw_phy_pwrtrack_avg(struct rtw_dev *rtwdev, u8 thermal, u8 path)\n{\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\n\tewma_thermal_add(&dm_info->avg_thermal[path], thermal);\n\tdm_info->thermal_avg[path] =\n\t\tewma_thermal_read(&dm_info->avg_thermal[path]);\n}\nEXPORT_SYMBOL(rtw_phy_pwrtrack_avg);\n\nbool rtw_phy_pwrtrack_thermal_changed(struct rtw_dev *rtwdev, u8 thermal,\n\t\t\t\t      u8 path)\n{\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tu8 avg = ewma_thermal_read(&dm_info->avg_thermal[path]);\n\n\tif (avg == thermal)\n\t\treturn false;\n\n\treturn true;\n}\nEXPORT_SYMBOL(rtw_phy_pwrtrack_thermal_changed);\n\nu8 rtw_phy_pwrtrack_get_delta(struct rtw_dev *rtwdev, u8 path)\n{\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tu8 therm_avg, therm_efuse, therm_delta;\n\n\ttherm_avg = dm_info->thermal_avg[path];\n\ttherm_efuse = rtwdev->efuse.thermal_meter[path];\n\ttherm_delta = abs(therm_avg - therm_efuse);\n\n\treturn min_t(u8, therm_delta, RTW_PWR_TRK_TBL_SZ - 1);\n}\nEXPORT_SYMBOL(rtw_phy_pwrtrack_get_delta);\n\ns8 rtw_phy_pwrtrack_get_pwridx(struct rtw_dev *rtwdev,\n\t\t\t       struct rtw_swing_table *swing_table,\n\t\t\t       u8 tbl_path, u8 therm_path, u8 delta)\n{\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tconst u8 *delta_swing_table_idx_pos;\n\tconst u8 *delta_swing_table_idx_neg;\n\n\tif (delta >= RTW_PWR_TRK_TBL_SZ) {\n\t\trtw_warn(rtwdev, \"power track table overflow\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!swing_table) {\n\t\trtw_warn(rtwdev, \"swing table not configured\\n\");\n\t\treturn 0;\n\t}\n\n\tdelta_swing_table_idx_pos = swing_table->p[tbl_path];\n\tdelta_swing_table_idx_neg = swing_table->n[tbl_path];\n\n\tif (!delta_swing_table_idx_pos || !delta_swing_table_idx_neg) {\n\t\trtw_warn(rtwdev, \"invalid swing table index\\n\");\n\t\treturn 0;\n\t}\n\n\tif (dm_info->thermal_avg[therm_path] >\n\t    rtwdev->efuse.thermal_meter[therm_path])\n\t\treturn delta_swing_table_idx_pos[delta];\n\telse\n\t\treturn -delta_swing_table_idx_neg[delta];\n}\nEXPORT_SYMBOL(rtw_phy_pwrtrack_get_pwridx);\n\nbool rtw_phy_pwrtrack_need_lck(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tu8 delta_lck;\n\n\tdelta_lck = abs(dm_info->thermal_avg[0] - dm_info->thermal_meter_lck);\n\tif (delta_lck >= rtwdev->chip->lck_threshold) {\n\t\tdm_info->thermal_meter_lck = dm_info->thermal_avg[0];\n\t\treturn true;\n\t}\n\treturn false;\n}\nEXPORT_SYMBOL(rtw_phy_pwrtrack_need_lck);\n\nbool rtw_phy_pwrtrack_need_iqk(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tu8 delta_iqk;\n\n\tdelta_iqk = abs(dm_info->thermal_avg[0] - dm_info->thermal_meter_k);\n\tif (delta_iqk >= rtwdev->chip->iqk_threshold) {\n\t\tdm_info->thermal_meter_k = dm_info->thermal_avg[0];\n\t\treturn true;\n\t}\n\treturn false;\n}\nEXPORT_SYMBOL(rtw_phy_pwrtrack_need_iqk);\n\nstatic void rtw_phy_set_tx_path_by_reg(struct rtw_dev *rtwdev,\n\t\t\t\t       enum rtw_bb_path tx_path_sel_1ss)\n{\n\tstruct rtw_path_div *path_div = &rtwdev->dm_path_div;\n\tenum rtw_bb_path tx_path_sel_cck = tx_path_sel_1ss;\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\n\tif (tx_path_sel_1ss == path_div->current_tx_path)\n\t\treturn;\n\n\tpath_div->current_tx_path = tx_path_sel_1ss;\n\trtw_dbg(rtwdev, RTW_DBG_PATH_DIV, \"Switch TX path=%s\\n\",\n\t\ttx_path_sel_1ss == BB_PATH_A ? \"A\" : \"B\");\n\tchip->ops->config_tx_path(rtwdev, rtwdev->hal.antenna_tx,\n\t\t\t\t  tx_path_sel_1ss, tx_path_sel_cck, false);\n}\n\nstatic void rtw_phy_tx_path_div_select(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_path_div *path_div = &rtwdev->dm_path_div;\n\tenum rtw_bb_path path = path_div->current_tx_path;\n\ts32 rssi_a = 0, rssi_b = 0;\n\n\tif (path_div->path_a_cnt)\n\t\trssi_a = path_div->path_a_sum / path_div->path_a_cnt;\n\telse\n\t\trssi_a = 0;\n\tif (path_div->path_b_cnt)\n\t\trssi_b = path_div->path_b_sum / path_div->path_b_cnt;\n\telse\n\t\trssi_b = 0;\n\n\tif (rssi_a != rssi_b)\n\t\tpath = (rssi_a > rssi_b) ? BB_PATH_A : BB_PATH_B;\n\n\tpath_div->path_a_cnt = 0;\n\tpath_div->path_a_sum = 0;\n\tpath_div->path_b_cnt = 0;\n\tpath_div->path_b_sum = 0;\n\trtw_phy_set_tx_path_by_reg(rtwdev, path);\n}\n\nstatic void rtw_phy_tx_path_diversity_2ss(struct rtw_dev *rtwdev)\n{\n\tif (rtwdev->hal.antenna_rx != BB_PATH_AB) {\n\t\trtw_dbg(rtwdev, RTW_DBG_PATH_DIV,\n\t\t\t\"[Return] tx_Path_en=%d, rx_Path_en=%d\\n\",\n\t\t\trtwdev->hal.antenna_tx, rtwdev->hal.antenna_rx);\n\t\treturn;\n\t}\n\tif (rtwdev->sta_cnt == 0) {\n\t\trtw_dbg(rtwdev, RTW_DBG_PATH_DIV, \"No Link\\n\");\n\t\treturn;\n\t}\n\n\trtw_phy_tx_path_div_select(rtwdev);\n}\n\nvoid rtw_phy_tx_path_diversity(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\n\tif (!chip->path_div_supported)\n\t\treturn;\n\n\trtw_phy_tx_path_diversity_2ss(rtwdev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}