{
  "module_name": "rx.c",
  "hash_id": "c191151209ad9de036823cf6b4069646a58d8f0caee93d39b651fb8dfbd799d4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtw88/rx.c",
  "human_readable_source": "\n \n\n#include \"main.h\"\n#include \"rx.h\"\n#include \"ps.h\"\n#include \"debug.h\"\n#include \"fw.h\"\n\nvoid rtw_rx_stats(struct rtw_dev *rtwdev, struct ieee80211_vif *vif,\n\t\t  struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr;\n\tstruct rtw_vif *rtwvif;\n\n\thdr = (struct ieee80211_hdr *)skb->data;\n\n\tif (!ieee80211_is_data(hdr->frame_control))\n\t\treturn;\n\n\tif (!is_broadcast_ether_addr(hdr->addr1) &&\n\t    !is_multicast_ether_addr(hdr->addr1)) {\n\t\trtwdev->stats.rx_unicast += skb->len;\n\t\trtwdev->stats.rx_cnt++;\n\t\tif (vif) {\n\t\t\trtwvif = (struct rtw_vif *)vif->drv_priv;\n\t\t\trtwvif->stats.rx_unicast += skb->len;\n\t\t\trtwvif->stats.rx_cnt++;\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(rtw_rx_stats);\n\nstruct rtw_rx_addr_match_data {\n\tstruct rtw_dev *rtwdev;\n\tstruct ieee80211_hdr *hdr;\n\tstruct rtw_rx_pkt_stat *pkt_stat;\n\tu8 *bssid;\n};\n\nstatic void rtw_rx_phy_stat(struct rtw_dev *rtwdev,\n\t\t\t    struct rtw_rx_pkt_stat *pkt_stat,\n\t\t\t    struct ieee80211_hdr *hdr)\n{\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tstruct rtw_pkt_count *cur_pkt_cnt = &dm_info->cur_pkt_count;\n\tu8 rate_ss, rate_ss_evm, evm_id;\n\tu8 i, idx;\n\n\tdm_info->curr_rx_rate = pkt_stat->rate;\n\n\tif (ieee80211_is_beacon(hdr->frame_control))\n\t\tcur_pkt_cnt->num_bcn_pkt++;\n\n\tswitch (pkt_stat->rate) {\n\tcase DESC_RATE1M...DESC_RATE11M:\n\t\tgoto pkt_num;\n\tcase DESC_RATE6M...DESC_RATE54M:\n\t\trate_ss = 0;\n\t\trate_ss_evm = 1;\n\t\tevm_id = RTW_EVM_OFDM;\n\t\tbreak;\n\tcase DESC_RATEMCS0...DESC_RATEMCS7:\n\tcase DESC_RATEVHT1SS_MCS0...DESC_RATEVHT1SS_MCS9:\n\t\trate_ss = 1;\n\t\trate_ss_evm = 1;\n\t\tevm_id = RTW_EVM_1SS;\n\t\tbreak;\n\tcase DESC_RATEMCS8...DESC_RATEMCS15:\n\tcase DESC_RATEVHT2SS_MCS0...DESC_RATEVHT2SS_MCS9:\n\t\trate_ss = 2;\n\t\trate_ss_evm = 2;\n\t\tevm_id = RTW_EVM_2SS_A;\n\t\tbreak;\n\tdefault:\n\t\trtw_warn(rtwdev, \"unknown pkt rate = %d\\n\", pkt_stat->rate);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < rate_ss_evm; i++) {\n\t\tidx = evm_id + i;\n\t\tewma_evm_add(&dm_info->ewma_evm[idx],\n\t\t\t     dm_info->rx_evm_dbm[i]);\n\t}\n\n\tfor (i = 0; i < rtwdev->hal.rf_path_num; i++) {\n\t\tidx = RTW_SNR_OFDM_A + 4 * rate_ss + i;\n\t\tewma_snr_add(&dm_info->ewma_snr[idx],\n\t\t\t     dm_info->rx_snr[i]);\n\t}\npkt_num:\n\tcur_pkt_cnt->num_qry_pkt[pkt_stat->rate]++;\n}\n\nstatic void rtw_rx_addr_match_iter(void *data, u8 *mac,\n\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tstruct rtw_rx_addr_match_data *iter_data = data;\n\tstruct ieee80211_sta *sta;\n\tstruct ieee80211_hdr *hdr = iter_data->hdr;\n\tstruct rtw_dev *rtwdev = iter_data->rtwdev;\n\tstruct rtw_sta_info *si;\n\tstruct rtw_rx_pkt_stat *pkt_stat = iter_data->pkt_stat;\n\tu8 *bssid = iter_data->bssid;\n\n\tif (!ether_addr_equal(vif->bss_conf.bssid, bssid))\n\t\treturn;\n\n\tif (!(ether_addr_equal(vif->addr, hdr->addr1) ||\n\t      ieee80211_is_beacon(hdr->frame_control)))\n\t\treturn;\n\n\trtw_rx_phy_stat(rtwdev, pkt_stat, hdr);\n\tsta = ieee80211_find_sta_by_ifaddr(rtwdev->hw, hdr->addr2,\n\t\t\t\t\t   vif->addr);\n\tif (!sta)\n\t\treturn;\n\n\tsi = (struct rtw_sta_info *)sta->drv_priv;\n\tewma_rssi_add(&si->avg_rssi, pkt_stat->rssi);\n}\n\nstatic void rtw_rx_addr_match(struct rtw_dev *rtwdev,\n\t\t\t      struct rtw_rx_pkt_stat *pkt_stat,\n\t\t\t      struct ieee80211_hdr *hdr)\n{\n\tstruct rtw_rx_addr_match_data data = {};\n\n\tif (pkt_stat->crc_err || pkt_stat->icv_err || !pkt_stat->phy_status ||\n\t    ieee80211_is_ctl(hdr->frame_control))\n\t\treturn;\n\n\tdata.rtwdev = rtwdev;\n\tdata.hdr = hdr;\n\tdata.pkt_stat = pkt_stat;\n\tdata.bssid = get_hdr_bssid(hdr);\n\n\trtw_iterate_vifs_atomic(rtwdev, rtw_rx_addr_match_iter, &data);\n}\n\nstatic void rtw_set_rx_freq_by_pktstat(struct rtw_rx_pkt_stat *pkt_stat,\n\t\t\t\t       struct ieee80211_rx_status *rx_status)\n{\n\trx_status->freq = pkt_stat->freq;\n\trx_status->band = pkt_stat->band;\n}\n\nvoid rtw_rx_fill_rx_status(struct rtw_dev *rtwdev,\n\t\t\t   struct rtw_rx_pkt_stat *pkt_stat,\n\t\t\t   struct ieee80211_hdr *hdr,\n\t\t\t   struct ieee80211_rx_status *rx_status,\n\t\t\t   u8 *phy_status)\n{\n\tstruct ieee80211_hw *hw = rtwdev->hw;\n\tu8 path;\n\n\tmemset(rx_status, 0, sizeof(*rx_status));\n\trx_status->freq = hw->conf.chandef.chan->center_freq;\n\trx_status->band = hw->conf.chandef.chan->band;\n\tif (rtw_fw_feature_check(&rtwdev->fw, FW_FEATURE_SCAN_OFFLOAD) &&\n\t    test_bit(RTW_FLAG_SCANNING, rtwdev->flags))\n\t\trtw_set_rx_freq_by_pktstat(pkt_stat, rx_status);\n\tif (pkt_stat->crc_err)\n\t\trx_status->flag |= RX_FLAG_FAILED_FCS_CRC;\n\tif (pkt_stat->decrypted)\n\t\trx_status->flag |= RX_FLAG_DECRYPTED;\n\n\tif (pkt_stat->rate >= DESC_RATEVHT1SS_MCS0)\n\t\trx_status->encoding = RX_ENC_VHT;\n\telse if (pkt_stat->rate >= DESC_RATEMCS0)\n\t\trx_status->encoding = RX_ENC_HT;\n\n\tif (rx_status->band == NL80211_BAND_5GHZ &&\n\t    pkt_stat->rate >= DESC_RATE6M &&\n\t    pkt_stat->rate <= DESC_RATE54M) {\n\t\trx_status->rate_idx = pkt_stat->rate - DESC_RATE6M;\n\t} else if (rx_status->band == NL80211_BAND_2GHZ &&\n\t\t   pkt_stat->rate >= DESC_RATE1M &&\n\t\t   pkt_stat->rate <= DESC_RATE54M) {\n\t\trx_status->rate_idx = pkt_stat->rate - DESC_RATE1M;\n\t} else if (pkt_stat->rate >= DESC_RATEMCS0) {\n\t\trtw_desc_to_mcsrate(pkt_stat->rate, &rx_status->rate_idx,\n\t\t\t\t    &rx_status->nss);\n\t}\n\n\trx_status->flag |= RX_FLAG_MACTIME_START;\n\trx_status->mactime = pkt_stat->tsf_low;\n\n\tif (pkt_stat->bw == RTW_CHANNEL_WIDTH_80)\n\t\trx_status->bw = RATE_INFO_BW_80;\n\telse if (pkt_stat->bw == RTW_CHANNEL_WIDTH_40)\n\t\trx_status->bw = RATE_INFO_BW_40;\n\telse\n\t\trx_status->bw = RATE_INFO_BW_20;\n\n\trx_status->signal = pkt_stat->signal_power;\n\tfor (path = 0; path < rtwdev->hal.rf_path_num; path++) {\n\t\trx_status->chains |= BIT(path);\n\t\trx_status->chain_signal[path] = pkt_stat->rx_power[path];\n\t}\n\n\trtw_rx_addr_match(rtwdev, pkt_stat, hdr);\n}\nEXPORT_SYMBOL(rtw_rx_fill_rx_status);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}