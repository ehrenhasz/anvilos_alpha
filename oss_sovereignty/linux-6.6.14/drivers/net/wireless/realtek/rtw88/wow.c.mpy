{
  "module_name": "wow.c",
  "hash_id": "3ea06475bd69c151d4a95bcb20c4a6767ff338c82cfc5d0dafd407df16090cbe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtw88/wow.c",
  "human_readable_source": "\n \n\n#include \"main.h\"\n#include \"fw.h\"\n#include \"wow.h\"\n#include \"reg.h\"\n#include \"debug.h\"\n#include \"mac.h\"\n#include \"ps.h\"\n\nstatic void rtw_wow_show_wakeup_reason(struct rtw_dev *rtwdev)\n{\n\tstruct cfg80211_wowlan_nd_info nd_info;\n\tstruct cfg80211_wowlan_wakeup wakeup = {\n\t\t.pattern_idx = -1,\n\t};\n\tu8 reason;\n\n\treason = rtw_read8(rtwdev, REG_WOWLAN_WAKE_REASON);\n\n\tswitch (reason) {\n\tcase RTW_WOW_RSN_RX_DEAUTH:\n\t\twakeup.disconnect = true;\n\t\trtw_dbg(rtwdev, RTW_DBG_WOW, \"WOW: Rx deauth\\n\");\n\t\tbreak;\n\tcase RTW_WOW_RSN_DISCONNECT:\n\t\twakeup.disconnect = true;\n\t\trtw_dbg(rtwdev, RTW_DBG_WOW, \"WOW: AP is off\\n\");\n\t\tbreak;\n\tcase RTW_WOW_RSN_RX_MAGIC_PKT:\n\t\twakeup.magic_pkt = true;\n\t\trtw_dbg(rtwdev, RTW_DBG_WOW, \"WOW: Rx magic packet\\n\");\n\t\tbreak;\n\tcase RTW_WOW_RSN_RX_GTK_REKEY:\n\t\twakeup.gtk_rekey_failure = true;\n\t\trtw_dbg(rtwdev, RTW_DBG_WOW, \"WOW: Rx gtk rekey\\n\");\n\t\tbreak;\n\tcase RTW_WOW_RSN_RX_PATTERN_MATCH:\n\t\t \n\t\twakeup.pattern_idx = 0;\n\t\trtw_dbg(rtwdev, RTW_DBG_WOW, \"WOW: Rx pattern match packet\\n\");\n\t\tbreak;\n\tcase RTW_WOW_RSN_RX_NLO:\n\t\t \n\t\tnd_info.n_matches = 0;\n\t\twakeup.net_detect = &nd_info;\n\t\trtw_dbg(rtwdev, RTW_DBG_WOW, \"Rx NLO\\n\");\n\t\tbreak;\n\tdefault:\n\t\trtw_warn(rtwdev, \"Unknown wakeup reason %x\\n\", reason);\n\t\tieee80211_report_wowlan_wakeup(rtwdev->wow.wow_vif, NULL,\n\t\t\t\t\t       GFP_KERNEL);\n\t\treturn;\n\t}\n\tieee80211_report_wowlan_wakeup(rtwdev->wow.wow_vif, &wakeup,\n\t\t\t\t       GFP_KERNEL);\n}\n\nstatic void rtw_wow_pattern_write_cam(struct rtw_dev *rtwdev, u8 addr,\n\t\t\t\t      u32 wdata)\n{\n\trtw_write32(rtwdev, REG_WKFMCAM_RWD, wdata);\n\trtw_write32(rtwdev, REG_WKFMCAM_CMD, BIT_WKFCAM_POLLING_V1 |\n\t\t    BIT_WKFCAM_WE | BIT_WKFCAM_ADDR_V2(addr));\n\n\tif (!check_hw_ready(rtwdev, REG_WKFMCAM_CMD, BIT_WKFCAM_POLLING_V1, 0))\n\t\trtw_err(rtwdev, \"failed to write pattern cam\\n\");\n}\n\nstatic void rtw_wow_pattern_write_cam_ent(struct rtw_dev *rtwdev, u8 id,\n\t\t\t\t\t  struct rtw_wow_pattern *rtw_pattern)\n{\n\tint i;\n\tu8 addr;\n\tu32 wdata;\n\n\tfor (i = 0; i < RTW_MAX_PATTERN_MASK_SIZE / 4; i++) {\n\t\taddr = (id << 3) + i;\n\t\twdata = rtw_pattern->mask[i * 4];\n\t\twdata |= rtw_pattern->mask[i * 4 + 1] << 8;\n\t\twdata |= rtw_pattern->mask[i * 4 + 2] << 16;\n\t\twdata |= rtw_pattern->mask[i * 4 + 3] << 24;\n\t\trtw_wow_pattern_write_cam(rtwdev, addr, wdata);\n\t}\n\n\twdata = rtw_pattern->crc;\n\taddr = (id << 3) + RTW_MAX_PATTERN_MASK_SIZE / 4;\n\n\tswitch (rtw_pattern->type) {\n\tcase RTW_PATTERN_BROADCAST:\n\t\twdata |= BIT_WKFMCAM_BC | BIT_WKFMCAM_VALID;\n\t\tbreak;\n\tcase RTW_PATTERN_MULTICAST:\n\t\twdata |= BIT_WKFMCAM_MC | BIT_WKFMCAM_VALID;\n\t\tbreak;\n\tcase RTW_PATTERN_UNICAST:\n\t\twdata |= BIT_WKFMCAM_UC | BIT_WKFMCAM_VALID;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\trtw_wow_pattern_write_cam(rtwdev, addr, wdata);\n}\n\n \nstatic u16 __rtw_cal_crc16(u8 data, u16 crc)\n{\n\tu8 shift_in, data_bit;\n\tu8 crc_bit4, crc_bit11, crc_bit15;\n\tu16 crc_result;\n\tint index;\n\n\tfor (index = 0; index < 8; index++) {\n\t\tcrc_bit15 = ((crc & BIT(15)) ? 1 : 0);\n\t\tdata_bit = (data & (BIT(0) << index) ? 1 : 0);\n\t\tshift_in = crc_bit15 ^ data_bit;\n\n\t\tcrc_result = crc << 1;\n\n\t\tif (shift_in == 0)\n\t\t\tcrc_result &= (~BIT(0));\n\t\telse\n\t\t\tcrc_result |= BIT(0);\n\n\t\tcrc_bit11 = ((crc & BIT(11)) ? 1 : 0) ^ shift_in;\n\n\t\tif (crc_bit11 == 0)\n\t\t\tcrc_result &= (~BIT(12));\n\t\telse\n\t\t\tcrc_result |= BIT(12);\n\n\t\tcrc_bit4 = ((crc & BIT(4)) ? 1 : 0) ^ shift_in;\n\n\t\tif (crc_bit4 == 0)\n\t\t\tcrc_result &= (~BIT(5));\n\t\telse\n\t\t\tcrc_result |= BIT(5);\n\n\t\tcrc = crc_result;\n\t}\n\treturn crc;\n}\n\nstatic u16 rtw_calc_crc(u8 *pdata, int length)\n{\n\tu16 crc = 0xffff;\n\tint i;\n\n\tfor (i = 0; i < length; i++)\n\t\tcrc = __rtw_cal_crc16(pdata[i], crc);\n\n\t \n\treturn ~crc;\n}\n\nstatic void rtw_wow_pattern_generate(struct rtw_dev *rtwdev,\n\t\t\t\t     struct rtw_vif *rtwvif,\n\t\t\t\t     const struct cfg80211_pkt_pattern *pkt_pattern,\n\t\t\t\t     struct rtw_wow_pattern *rtw_pattern)\n{\n\tconst u8 *mask;\n\tconst u8 *pattern;\n\tu8 mask_hw[RTW_MAX_PATTERN_MASK_SIZE] = {0};\n\tu8 content[RTW_MAX_PATTERN_SIZE] = {0};\n\tu8 mac_addr[ETH_ALEN] = {0};\n\tu8 mask_len;\n\tu16 count;\n\tint len;\n\tint i;\n\n\tpattern = pkt_pattern->pattern;\n\tlen = pkt_pattern->pattern_len;\n\tmask = pkt_pattern->mask;\n\n\tether_addr_copy(mac_addr, rtwvif->mac_addr);\n\tmemset(rtw_pattern, 0, sizeof(*rtw_pattern));\n\n\tmask_len = DIV_ROUND_UP(len, 8);\n\n\tif (is_broadcast_ether_addr(pattern))\n\t\trtw_pattern->type = RTW_PATTERN_BROADCAST;\n\telse if (is_multicast_ether_addr(pattern))\n\t\trtw_pattern->type = RTW_PATTERN_MULTICAST;\n\telse if (ether_addr_equal(pattern, mac_addr))\n\t\trtw_pattern->type = RTW_PATTERN_UNICAST;\n\telse\n\t\trtw_pattern->type = RTW_PATTERN_INVALID;\n\n\t \n\n\t \n\tfor (i = 0; i < mask_len - 1; i++) {\n\t\tmask_hw[i] = u8_get_bits(mask[i], GENMASK(7, 6));\n\t\tmask_hw[i] |= u8_get_bits(mask[i + 1], GENMASK(5, 0)) << 2;\n\t}\n\tmask_hw[i] = u8_get_bits(mask[i], GENMASK(7, 6));\n\n\t \n\tmask_hw[0] &= (~GENMASK(5, 0));\n\n\tmemcpy(rtw_pattern->mask, mask_hw, RTW_MAX_PATTERN_MASK_SIZE);\n\n\t \n\tcount = 0;\n\tfor (i = 12; i < len; i++) {\n\t\tif ((mask[i / 8] >> (i % 8)) & 0x01) {\n\t\t\tcontent[count] = pattern[i];\n\t\t\tcount++;\n\t\t}\n\t}\n\n\trtw_pattern->crc = rtw_calc_crc(content, count);\n}\n\nstatic void rtw_wow_pattern_clear_cam(struct rtw_dev *rtwdev)\n{\n\tbool ret;\n\n\trtw_write32(rtwdev, REG_WKFMCAM_CMD, BIT_WKFCAM_POLLING_V1 |\n\t\t    BIT_WKFCAM_CLR_V1);\n\n\tret = check_hw_ready(rtwdev, REG_WKFMCAM_CMD, BIT_WKFCAM_POLLING_V1, 0);\n\tif (!ret)\n\t\trtw_err(rtwdev, \"failed to clean pattern cam\\n\");\n}\n\nstatic void rtw_wow_pattern_write(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_wow_param *rtw_wow = &rtwdev->wow;\n\tstruct rtw_wow_pattern *rtw_pattern = rtw_wow->patterns;\n\tint i = 0;\n\n\tfor (i = 0; i < rtw_wow->pattern_cnt; i++)\n\t\trtw_wow_pattern_write_cam_ent(rtwdev, i, rtw_pattern + i);\n}\n\nstatic void rtw_wow_pattern_clear(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_wow_param *rtw_wow = &rtwdev->wow;\n\n\trtw_wow_pattern_clear_cam(rtwdev);\n\n\trtw_wow->pattern_cnt = 0;\n\tmemset(rtw_wow->patterns, 0, sizeof(rtw_wow->patterns));\n}\n\nstatic void rtw_wow_bb_stop(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_wow_param *rtw_wow = &rtwdev->wow;\n\n\t \n\tmsleep(100);\n\n\tif (!rtw_read32_mask(rtwdev, REG_BCNQ_INFO, BIT_MGQ_CPU_EMPTY))\n\t\trtw_warn(rtwdev, \"Wrong status of MGQ_CPU empty!\\n\");\n\n\trtw_wow->txpause = rtw_read8(rtwdev, REG_TXPAUSE);\n\trtw_write8(rtwdev, REG_TXPAUSE, 0xff);\n\trtw_write8_clr(rtwdev, REG_SYS_FUNC_EN, BIT_FEN_BB_RSTB);\n}\n\nstatic void rtw_wow_bb_start(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_wow_param *rtw_wow = &rtwdev->wow;\n\n\trtw_write8_set(rtwdev, REG_SYS_FUNC_EN, BIT_FEN_BB_RSTB);\n\trtw_write8(rtwdev, REG_TXPAUSE, rtw_wow->txpause);\n}\n\nstatic void rtw_wow_rx_dma_stop(struct rtw_dev *rtwdev)\n{\n\t \n\tmsleep(100);\n\n\trtw_write32_set(rtwdev, REG_RXPKT_NUM, BIT_RW_RELEASE);\n\n\tif (!check_hw_ready(rtwdev, REG_RXPKT_NUM, BIT_RXDMA_IDLE, 1))\n\t\trtw_err(rtwdev, \"failed to stop rx dma\\n\");\n}\n\nstatic void rtw_wow_rx_dma_start(struct rtw_dev *rtwdev)\n{\n\trtw_write32_clr(rtwdev, REG_RXPKT_NUM, BIT_RW_RELEASE);\n}\n\nstatic int rtw_wow_check_fw_status(struct rtw_dev *rtwdev, bool wow_enable)\n{\n\tint ret;\n\tu8 check;\n\tu32 check_dis;\n\n\tif (wow_enable) {\n\t\tret = read_poll_timeout(rtw_read8, check, !check, 1000,\n\t\t\t\t\t100000, true, rtwdev,\n\t\t\t\t\tREG_WOWLAN_WAKE_REASON);\n\t\tif (ret)\n\t\t\tgoto wow_fail;\n\t} else {\n\t\tret = read_poll_timeout(rtw_read32_mask, check_dis,\n\t\t\t\t\t!check_dis, 1000, 100000, true, rtwdev,\n\t\t\t\t\tREG_FE1IMR, BIT_FS_RXDONE);\n\t\tif (ret)\n\t\t\tgoto wow_fail;\n\t\tret = read_poll_timeout(rtw_read32_mask, check_dis,\n\t\t\t\t\t!check_dis, 1000, 100000, false, rtwdev,\n\t\t\t\t\tREG_RXPKT_NUM, BIT_RW_RELEASE);\n\t\tif (ret)\n\t\t\tgoto wow_fail;\n\t}\n\n\treturn 0;\n\nwow_fail:\n\trtw_err(rtwdev, \"failed to check wow status %s\\n\",\n\t\twow_enable ? \"enabled\" : \"disabled\");\n\treturn -EBUSY;\n}\n\nstatic void rtw_wow_fw_security_type_iter(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t\t  struct ieee80211_sta *sta,\n\t\t\t\t\t  struct ieee80211_key_conf *key,\n\t\t\t\t\t  void *data)\n{\n\tstruct rtw_fw_key_type_iter_data *iter_data = data;\n\tstruct rtw_dev *rtwdev = hw->priv;\n\tu8 hw_key_type;\n\n\tif (vif != rtwdev->wow.wow_vif)\n\t\treturn;\n\n\tswitch (key->cipher) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\thw_key_type = RTW_CAM_WEP40;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\thw_key_type = RTW_CAM_WEP104;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\thw_key_type = RTW_CAM_TKIP;\n\t\tkey->flags |= IEEE80211_KEY_FLAG_GENERATE_MMIC;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\thw_key_type = RTW_CAM_AES;\n\t\tkey->flags |= IEEE80211_KEY_FLAG_SW_MGMT_TX;\n\t\tbreak;\n\tdefault:\n\t\trtw_err(rtwdev, \"Unsupported key type for wowlan mode: %#x\\n\",\n\t\t\tkey->cipher);\n\t\thw_key_type = 0;\n\t\tbreak;\n\t}\n\n\tif (sta)\n\t\titer_data->pairwise_key_type = hw_key_type;\n\telse\n\t\titer_data->group_key_type = hw_key_type;\n}\n\nstatic void rtw_wow_fw_security_type(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_fw_key_type_iter_data data = {};\n\tstruct ieee80211_vif *wow_vif = rtwdev->wow.wow_vif;\n\n\tdata.rtwdev = rtwdev;\n\trtw_iterate_keys(rtwdev, wow_vif,\n\t\t\t rtw_wow_fw_security_type_iter, &data);\n\trtw_fw_set_aoac_global_info_cmd(rtwdev, data.pairwise_key_type,\n\t\t\t\t\tdata.group_key_type);\n}\n\nstatic int rtw_wow_fw_start(struct rtw_dev *rtwdev)\n{\n\tif (rtw_wow_mgd_linked(rtwdev)) {\n\t\trtw_send_rsvd_page_h2c(rtwdev);\n\t\trtw_wow_pattern_write(rtwdev);\n\t\trtw_wow_fw_security_type(rtwdev);\n\t\trtw_fw_set_disconnect_decision_cmd(rtwdev, true);\n\t\trtw_fw_set_keep_alive_cmd(rtwdev, true);\n\t} else if (rtw_wow_no_link(rtwdev)) {\n\t\trtw_fw_set_nlo_info(rtwdev, true);\n\t\trtw_fw_update_pkt_probe_req(rtwdev, NULL);\n\t\trtw_fw_channel_switch(rtwdev, true);\n\t}\n\n\trtw_fw_set_wowlan_ctrl_cmd(rtwdev, true);\n\trtw_fw_set_remote_wake_ctrl_cmd(rtwdev, true);\n\n\treturn rtw_wow_check_fw_status(rtwdev, true);\n}\n\nstatic int rtw_wow_fw_stop(struct rtw_dev *rtwdev)\n{\n\tif (rtw_wow_mgd_linked(rtwdev)) {\n\t\trtw_fw_set_disconnect_decision_cmd(rtwdev, false);\n\t\trtw_fw_set_keep_alive_cmd(rtwdev, false);\n\t\trtw_wow_pattern_clear(rtwdev);\n\t} else if (rtw_wow_no_link(rtwdev)) {\n\t\trtw_fw_channel_switch(rtwdev, false);\n\t\trtw_fw_set_nlo_info(rtwdev, false);\n\t}\n\n\trtw_fw_set_wowlan_ctrl_cmd(rtwdev, false);\n\trtw_fw_set_remote_wake_ctrl_cmd(rtwdev, false);\n\n\treturn rtw_wow_check_fw_status(rtwdev, false);\n}\n\nstatic void rtw_wow_avoid_reset_mac(struct rtw_dev *rtwdev)\n{\n\t \n\tswitch (rtw_hci_type(rtwdev)) {\n\tcase RTW_HCI_TYPE_PCIE:\n\tcase RTW_HCI_TYPE_USB:\n\t\trtw_write8(rtwdev, REG_RSV_CTRL, BIT_WLOCK_1C_B6);\n\t\trtw_write8(rtwdev, REG_RSV_CTRL,\n\t\t\t   BIT_WLOCK_1C_B6 | BIT_R_DIS_PRST);\n\t\tbreak;\n\tdefault:\n\t\trtw_warn(rtwdev, \"Unsupported hci type to disable reset MAC\\n\");\n\t\tbreak;\n\t}\n}\n\nstatic void rtw_wow_fw_media_status_iter(void *data, struct ieee80211_sta *sta)\n{\n\tstruct rtw_sta_info *si = (struct rtw_sta_info *)sta->drv_priv;\n\tstruct rtw_fw_media_status_iter_data *iter_data = data;\n\tstruct rtw_dev *rtwdev = iter_data->rtwdev;\n\n\trtw_fw_media_status_report(rtwdev, si->mac_id, iter_data->connect);\n}\n\nstatic void rtw_wow_fw_media_status(struct rtw_dev *rtwdev, bool connect)\n{\n\tstruct rtw_fw_media_status_iter_data data;\n\n\tdata.rtwdev = rtwdev;\n\tdata.connect = connect;\n\n\trtw_iterate_stas_atomic(rtwdev, rtw_wow_fw_media_status_iter, &data);\n}\n\nstatic int rtw_wow_config_wow_fw_rsvd_page(struct rtw_dev *rtwdev)\n{\n\tstruct ieee80211_vif *wow_vif = rtwdev->wow.wow_vif;\n\tstruct rtw_vif *rtwvif = (struct rtw_vif *)wow_vif->drv_priv;\n\n\trtw_remove_rsvd_page(rtwdev, rtwvif);\n\n\tif (rtw_wow_no_link(rtwdev))\n\t\trtw_add_rsvd_page_pno(rtwdev, rtwvif);\n\telse\n\t\trtw_add_rsvd_page_sta(rtwdev, rtwvif);\n\n\treturn rtw_fw_download_rsvd_page(rtwdev);\n}\n\nstatic int rtw_wow_config_normal_fw_rsvd_page(struct rtw_dev *rtwdev)\n{\n\tstruct ieee80211_vif *wow_vif = rtwdev->wow.wow_vif;\n\tstruct rtw_vif *rtwvif = (struct rtw_vif *)wow_vif->drv_priv;\n\n\trtw_remove_rsvd_page(rtwdev, rtwvif);\n\trtw_add_rsvd_page_sta(rtwdev, rtwvif);\n\n\tif (rtw_wow_no_link(rtwdev))\n\t\treturn 0;\n\n\treturn rtw_fw_download_rsvd_page(rtwdev);\n}\n\nstatic int rtw_wow_swap_fw(struct rtw_dev *rtwdev, enum rtw_fw_type type)\n{\n\tstruct rtw_fw_state *fw;\n\tint ret;\n\n\tswitch (type) {\n\tcase RTW_WOWLAN_FW:\n\t\tfw = &rtwdev->wow_fw;\n\t\tbreak;\n\n\tcase RTW_NORMAL_FW:\n\t\tfw = &rtwdev->fw;\n\t\tbreak;\n\n\tdefault:\n\t\trtw_warn(rtwdev, \"unsupported firmware type to swap\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tret = rtw_download_firmware(rtwdev, fw);\n\tif (ret)\n\t\tgoto out;\n\n\trtw_fw_send_general_info(rtwdev);\n\trtw_fw_send_phydm_info(rtwdev);\n\trtw_wow_fw_media_status(rtwdev, true);\n\nout:\n\treturn ret;\n}\n\nstatic void rtw_wow_check_pno(struct rtw_dev *rtwdev,\n\t\t\t      struct cfg80211_sched_scan_request *nd_config)\n{\n\tstruct rtw_wow_param *rtw_wow = &rtwdev->wow;\n\tstruct rtw_pno_request *pno_req = &rtw_wow->pno_req;\n\tstruct ieee80211_channel *channel;\n\tint i, size;\n\n\tif (!nd_config->n_match_sets || !nd_config->n_channels)\n\t\tgoto err;\n\n\tpno_req->match_set_cnt = nd_config->n_match_sets;\n\tsize = sizeof(*pno_req->match_sets) * pno_req->match_set_cnt;\n\tpno_req->match_sets = kmemdup(nd_config->match_sets, size, GFP_KERNEL);\n\tif (!pno_req->match_sets)\n\t\tgoto err;\n\n\tpno_req->channel_cnt = nd_config->n_channels;\n\tsize = sizeof(*nd_config->channels[0]) * nd_config->n_channels;\n\tpno_req->channels = kmalloc(size, GFP_KERNEL);\n\tif (!pno_req->channels)\n\t\tgoto channel_err;\n\n\tfor (i = 0 ; i < pno_req->channel_cnt; i++) {\n\t\tchannel = pno_req->channels + i;\n\t\tmemcpy(channel, nd_config->channels[i], sizeof(*channel));\n\t}\n\n\tpno_req->scan_plan = *nd_config->scan_plans;\n\tpno_req->inited = true;\n\n\trtw_dbg(rtwdev, RTW_DBG_WOW, \"WOW: net-detect is enabled\\n\");\n\n\treturn;\n\nchannel_err:\n\tkfree(pno_req->match_sets);\n\nerr:\n\trtw_dbg(rtwdev, RTW_DBG_WOW, \"WOW: net-detect is disabled\\n\");\n}\n\nstatic int rtw_wow_leave_linked_ps(struct rtw_dev *rtwdev)\n{\n\tif (!test_bit(RTW_FLAG_WOWLAN, rtwdev->flags))\n\t\tcancel_delayed_work_sync(&rtwdev->watch_dog_work);\n\n\trtw_leave_lps(rtwdev);\n\n\treturn 0;\n}\n\nstatic int rtw_wow_leave_no_link_ps(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_wow_param *rtw_wow = &rtwdev->wow;\n\tint ret = 0;\n\n\tif (test_bit(RTW_FLAG_WOWLAN, rtwdev->flags)) {\n\t\tif (rtw_get_lps_deep_mode(rtwdev) != LPS_DEEP_MODE_NONE)\n\t\t\trtw_leave_lps_deep(rtwdev);\n\t} else {\n\t\tif (!test_bit(RTW_FLAG_POWERON, rtwdev->flags)) {\n\t\t\trtw_wow->ips_enabled = true;\n\t\t\tret = rtw_leave_ips(rtwdev);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int rtw_wow_leave_ps(struct rtw_dev *rtwdev)\n{\n\tint ret = 0;\n\n\tif (rtw_wow_mgd_linked(rtwdev))\n\t\tret = rtw_wow_leave_linked_ps(rtwdev);\n\telse if (rtw_wow_no_link(rtwdev))\n\t\tret = rtw_wow_leave_no_link_ps(rtwdev);\n\n\treturn ret;\n}\n\nstatic int rtw_wow_restore_ps(struct rtw_dev *rtwdev)\n{\n\tint ret = 0;\n\n\tif (rtw_wow_no_link(rtwdev) && rtwdev->wow.ips_enabled)\n\t\tret = rtw_enter_ips(rtwdev);\n\n\treturn ret;\n}\n\nstatic int rtw_wow_enter_linked_ps(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_wow_param *rtw_wow = &rtwdev->wow;\n\tstruct ieee80211_vif *wow_vif = rtw_wow->wow_vif;\n\tstruct rtw_vif *rtwvif = (struct rtw_vif *)wow_vif->drv_priv;\n\n\trtw_enter_lps(rtwdev, rtwvif->port);\n\n\treturn 0;\n}\n\nstatic int rtw_wow_enter_no_link_ps(struct rtw_dev *rtwdev)\n{\n\t \n\tset_bit(RTW_FLAG_LEISURE_PS_DEEP, rtwdev->flags);\n\n\treturn 0;\n}\n\nstatic int rtw_wow_enter_ps(struct rtw_dev *rtwdev)\n{\n\tint ret = 0;\n\n\tif (rtw_wow_mgd_linked(rtwdev))\n\t\tret = rtw_wow_enter_linked_ps(rtwdev);\n\telse if (rtw_wow_no_link(rtwdev) &&\n\t\t rtw_get_lps_deep_mode(rtwdev) != LPS_DEEP_MODE_NONE)\n\t\tret = rtw_wow_enter_no_link_ps(rtwdev);\n\n\treturn ret;\n}\n\nstatic void rtw_wow_stop_trx(struct rtw_dev *rtwdev)\n{\n\trtw_wow_bb_stop(rtwdev);\n\trtw_wow_rx_dma_stop(rtwdev);\n}\n\nstatic int rtw_wow_start(struct rtw_dev *rtwdev)\n{\n\tint ret;\n\n\tret = rtw_wow_fw_start(rtwdev);\n\tif (ret)\n\t\tgoto out;\n\n\trtw_hci_stop(rtwdev);\n\trtw_wow_bb_start(rtwdev);\n\trtw_wow_avoid_reset_mac(rtwdev);\n\nout:\n\treturn ret;\n}\n\nstatic int rtw_wow_enable(struct rtw_dev *rtwdev)\n{\n\tint ret = 0;\n\n\trtw_wow_stop_trx(rtwdev);\n\n\tret = rtw_wow_swap_fw(rtwdev, RTW_WOWLAN_FW);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to swap wow fw\\n\");\n\t\tgoto error;\n\t}\n\n\tset_bit(RTW_FLAG_WOWLAN, rtwdev->flags);\n\n\tret = rtw_wow_config_wow_fw_rsvd_page(rtwdev);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to download wowlan rsvd page\\n\");\n\t\tgoto error;\n\t}\n\n\tret = rtw_wow_start(rtwdev);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to start wow\\n\");\n\t\tgoto error;\n\t}\n\n\treturn ret;\n\nerror:\n\tclear_bit(RTW_FLAG_WOWLAN, rtwdev->flags);\n\treturn ret;\n}\n\nstatic int rtw_wow_stop(struct rtw_dev *rtwdev)\n{\n\tint ret;\n\n\t \n\tret = rtw_hci_setup(rtwdev);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to setup hci\\n\");\n\t\treturn ret;\n\t}\n\n\tret = rtw_hci_start(rtwdev);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to start hci\\n\");\n\t\treturn ret;\n\t}\n\n\tret = rtw_wow_fw_stop(rtwdev);\n\tif (ret)\n\t\trtw_err(rtwdev, \"failed to stop wowlan fw\\n\");\n\n\trtw_wow_bb_stop(rtwdev);\n\n\treturn ret;\n}\n\nstatic void rtw_wow_resume_trx(struct rtw_dev *rtwdev)\n{\n\trtw_wow_rx_dma_start(rtwdev);\n\trtw_wow_bb_start(rtwdev);\n\tieee80211_queue_delayed_work(rtwdev->hw, &rtwdev->watch_dog_work,\n\t\t\t\t     RTW_WATCH_DOG_DELAY_TIME);\n}\n\nstatic int rtw_wow_disable(struct rtw_dev *rtwdev)\n{\n\tint ret;\n\n\tclear_bit(RTW_FLAG_WOWLAN, rtwdev->flags);\n\n\tret = rtw_wow_stop(rtwdev);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to stop wow\\n\");\n\t\tgoto out;\n\t}\n\n\tret = rtw_wow_swap_fw(rtwdev, RTW_NORMAL_FW);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to swap normal fw\\n\");\n\t\tgoto out;\n\t}\n\n\tret = rtw_wow_config_normal_fw_rsvd_page(rtwdev);\n\tif (ret)\n\t\trtw_err(rtwdev, \"failed to download normal rsvd page\\n\");\n\nout:\n\trtw_wow_resume_trx(rtwdev);\n\treturn ret;\n}\n\nstatic void rtw_wow_vif_iter(void *data, u8 *mac, struct ieee80211_vif *vif)\n{\n\tstruct rtw_dev *rtwdev = data;\n\tstruct rtw_vif *rtwvif = (struct rtw_vif *)vif->drv_priv;\n\tstruct rtw_wow_param *rtw_wow = &rtwdev->wow;\n\n\t \n\tif (rtw_wow->wow_vif || vif->type != NL80211_IFTYPE_STATION)\n\t\treturn;\n\n\tswitch (rtwvif->net_type) {\n\tcase RTW_NET_MGD_LINKED:\n\t\trtw_wow->wow_vif = vif;\n\t\tbreak;\n\tcase RTW_NET_NO_LINK:\n\t\tif (rtw_wow->pno_req.inited)\n\t\t\trtwdev->wow.wow_vif = vif;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int rtw_wow_set_wakeups(struct rtw_dev *rtwdev,\n\t\t\t       struct cfg80211_wowlan *wowlan)\n{\n\tstruct rtw_wow_param *rtw_wow = &rtwdev->wow;\n\tstruct rtw_wow_pattern *rtw_patterns = rtw_wow->patterns;\n\tstruct rtw_vif *rtwvif;\n\tint i;\n\n\tif (wowlan->disconnect)\n\t\tset_bit(RTW_WOW_FLAG_EN_DISCONNECT, rtw_wow->flags);\n\tif (wowlan->magic_pkt)\n\t\tset_bit(RTW_WOW_FLAG_EN_MAGIC_PKT, rtw_wow->flags);\n\tif (wowlan->gtk_rekey_failure)\n\t\tset_bit(RTW_WOW_FLAG_EN_REKEY_PKT, rtw_wow->flags);\n\n\tif (wowlan->nd_config)\n\t\trtw_wow_check_pno(rtwdev, wowlan->nd_config);\n\n\trtw_iterate_vifs_atomic(rtwdev, rtw_wow_vif_iter, rtwdev);\n\tif (!rtw_wow->wow_vif)\n\t\treturn -EPERM;\n\n\trtwvif = (struct rtw_vif *)rtw_wow->wow_vif->drv_priv;\n\tif (wowlan->n_patterns && wowlan->patterns) {\n\t\trtw_wow->pattern_cnt = wowlan->n_patterns;\n\t\tfor (i = 0; i < wowlan->n_patterns; i++)\n\t\t\trtw_wow_pattern_generate(rtwdev, rtwvif,\n\t\t\t\t\t\t wowlan->patterns + i,\n\t\t\t\t\t\t rtw_patterns + i);\n\t}\n\n\treturn 0;\n}\n\nstatic void rtw_wow_clear_wakeups(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_wow_param *rtw_wow = &rtwdev->wow;\n\tstruct rtw_pno_request *pno_req = &rtw_wow->pno_req;\n\n\tif (pno_req->inited) {\n\t\tkfree(pno_req->channels);\n\t\tkfree(pno_req->match_sets);\n\t}\n\n\tmemset(rtw_wow, 0, sizeof(rtwdev->wow));\n}\n\nint rtw_wow_suspend(struct rtw_dev *rtwdev, struct cfg80211_wowlan *wowlan)\n{\n\tint ret = 0;\n\n\tret = rtw_wow_set_wakeups(rtwdev, wowlan);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to set wakeup event\\n\");\n\t\tgoto out;\n\t}\n\n\tret = rtw_wow_leave_ps(rtwdev);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to leave ps from normal mode\\n\");\n\t\tgoto out;\n\t}\n\n\tret = rtw_wow_enable(rtwdev);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to enable wow\\n\");\n\t\trtw_wow_restore_ps(rtwdev);\n\t\tgoto out;\n\t}\n\n\tret = rtw_wow_enter_ps(rtwdev);\n\tif (ret)\n\t\trtw_err(rtwdev, \"failed to enter ps for wow\\n\");\n\nout:\n\treturn ret;\n}\n\nint rtw_wow_resume(struct rtw_dev *rtwdev)\n{\n\tint ret;\n\n\t \n\tif (!test_bit(RTW_FLAG_WOWLAN, rtwdev->flags)) {\n\t\trtw_err(rtwdev, \"wow is not enabled\\n\");\n\t\tret = -EPERM;\n\t\tgoto out;\n\t}\n\n\tret = rtw_wow_leave_ps(rtwdev);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to leave ps from wowlan mode\\n\");\n\t\tgoto out;\n\t}\n\n\trtw_wow_show_wakeup_reason(rtwdev);\n\n\tret = rtw_wow_disable(rtwdev);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to disable wow\\n\");\n\t\tgoto out;\n\t}\n\n\tret = rtw_wow_restore_ps(rtwdev);\n\tif (ret)\n\t\trtw_err(rtwdev, \"failed to restore ps to normal mode\\n\");\n\nout:\n\trtw_wow_clear_wakeups(rtwdev);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}