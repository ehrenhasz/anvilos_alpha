{
  "module_name": "sec.c",
  "hash_id": "156754b96769a0cba6c1cdae0461d564fab196f06ab9361ad902065d8586ff2c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtw88/sec.c",
  "human_readable_source": "\n \n\n#include \"main.h\"\n#include \"sec.h\"\n#include \"reg.h\"\n\nint rtw_sec_get_free_cam(struct rtw_sec_desc *sec)\n{\n\t \n\tif (sec->default_key_search)\n\t\treturn find_next_zero_bit(sec->cam_map, RTW_MAX_SEC_CAM_NUM,\n\t\t\t\t\t  RTW_SEC_DEFAULT_KEY_NUM);\n\n\treturn find_first_zero_bit(sec->cam_map, RTW_MAX_SEC_CAM_NUM);\n}\n\nvoid rtw_sec_write_cam(struct rtw_dev *rtwdev,\n\t\t       struct rtw_sec_desc *sec,\n\t\t       struct ieee80211_sta *sta,\n\t\t       struct ieee80211_key_conf *key,\n\t\t       u8 hw_key_type, u8 hw_key_idx)\n{\n\tstruct rtw_cam_entry *cam = &sec->cam_table[hw_key_idx];\n\tu32 write_cmd;\n\tu32 command;\n\tu32 content;\n\tu32 addr;\n\tint i, j;\n\n\tset_bit(hw_key_idx, sec->cam_map);\n\tcam->valid = true;\n\tcam->group = !(key->flags & IEEE80211_KEY_FLAG_PAIRWISE);\n\tcam->hw_key_type = hw_key_type;\n\tcam->key = key;\n\tif (sta)\n\t\tether_addr_copy(cam->addr, sta->addr);\n\telse\n\t\teth_broadcast_addr(cam->addr);\n\n\twrite_cmd = RTW_SEC_CMD_WRITE_ENABLE | RTW_SEC_CMD_POLLING;\n\taddr = hw_key_idx << RTW_SEC_CAM_ENTRY_SHIFT;\n\tfor (i = 7; i >= 0; i--) {\n\t\tswitch (i) {\n\t\tcase 0:\n\t\t\tcontent = ((key->keyidx & 0x3))\t\t|\n\t\t\t\t  ((hw_key_type & 0x7)\t<< 2)\t|\n\t\t\t\t  (cam->group\t\t<< 6)\t|\n\t\t\t\t  (cam->valid\t\t<< 15)\t|\n\t\t\t\t  (cam->addr[0]\t\t<< 16)\t|\n\t\t\t\t  (cam->addr[1]\t\t<< 24);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tcontent = (cam->addr[2])\t\t|\n\t\t\t\t  (cam->addr[3]\t\t<< 8)\t|\n\t\t\t\t  (cam->addr[4]\t\t<< 16)\t|\n\t\t\t\t  (cam->addr[5]\t\t<< 24);\n\t\t\tbreak;\n\t\tcase 6:\n\t\tcase 7:\n\t\t\tcontent = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tj = (i - 2) << 2;\n\t\t\tcontent = (key->key[j])\t\t\t|\n\t\t\t\t  (key->key[j + 1]\t<< 8)\t|\n\t\t\t\t  (key->key[j + 2]\t<< 16)\t|\n\t\t\t\t  (key->key[j + 3]\t<< 24);\n\t\t\tbreak;\n\t\t}\n\n\t\tcommand = write_cmd | (addr + i);\n\t\trtw_write32(rtwdev, RTW_SEC_WRITE_REG, content);\n\t\trtw_write32(rtwdev, RTW_SEC_CMD_REG, command);\n\t}\n}\n\nvoid rtw_sec_clear_cam(struct rtw_dev *rtwdev,\n\t\t       struct rtw_sec_desc *sec,\n\t\t       u8 hw_key_idx)\n{\n\tstruct rtw_cam_entry *cam = &sec->cam_table[hw_key_idx];\n\tu32 write_cmd;\n\tu32 command;\n\tu32 addr;\n\n\tclear_bit(hw_key_idx, sec->cam_map);\n\tcam->valid = false;\n\tcam->key = NULL;\n\teth_zero_addr(cam->addr);\n\n\twrite_cmd = RTW_SEC_CMD_WRITE_ENABLE | RTW_SEC_CMD_POLLING;\n\taddr = hw_key_idx << RTW_SEC_CAM_ENTRY_SHIFT;\n\tcommand = write_cmd | addr;\n\trtw_write32(rtwdev, RTW_SEC_WRITE_REG, 0);\n\trtw_write32(rtwdev, RTW_SEC_CMD_REG, command);\n}\n\nu8 rtw_sec_cam_pg_backup(struct rtw_dev *rtwdev, u8 *used_cam)\n{\n\tstruct rtw_sec_desc *sec = &rtwdev->sec;\n\tu8 offset = 0;\n\tu8 count, n;\n\n\tif (!used_cam)\n\t\treturn 0;\n\n\tfor (count = 0; count < MAX_PG_CAM_BACKUP_NUM; count++) {\n\t\tn = find_next_bit(sec->cam_map, RTW_MAX_SEC_CAM_NUM, offset);\n\t\tif (n == RTW_MAX_SEC_CAM_NUM)\n\t\t\tbreak;\n\n\t\tused_cam[count] = n;\n\t\toffset = n + 1;\n\t}\n\n\treturn count;\n}\n\nvoid rtw_sec_enable_sec_engine(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_sec_desc *sec = &rtwdev->sec;\n\tu16 ctrl_reg;\n\tu16 sec_config;\n\n\t \n\tsec->default_key_search = true;\n\n\tctrl_reg = rtw_read16(rtwdev, REG_CR);\n\tctrl_reg |= RTW_SEC_ENGINE_EN;\n\trtw_write16(rtwdev, REG_CR, ctrl_reg);\n\n\tsec_config = rtw_read16(rtwdev, RTW_SEC_CONFIG);\n\n\tsec_config |= RTW_SEC_TX_DEC_EN | RTW_SEC_RX_DEC_EN;\n\tif (sec->default_key_search)\n\t\tsec_config |= RTW_SEC_TX_UNI_USE_DK | RTW_SEC_RX_UNI_USE_DK |\n\t\t\t      RTW_SEC_TX_BC_USE_DK | RTW_SEC_RX_BC_USE_DK;\n\n\trtw_write16(rtwdev, RTW_SEC_CONFIG, sec_config);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}