{
  "module_name": "rtw8822c.c",
  "hash_id": "7ba0f046deec7a4e46266142df22036b2d71350b9c1b9092dfee0e3fd51b8ae8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtw88/rtw8822c.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include \"main.h\"\n#include \"coex.h\"\n#include \"fw.h\"\n#include \"tx.h\"\n#include \"rx.h\"\n#include \"phy.h\"\n#include \"rtw8822c.h\"\n#include \"rtw8822c_table.h\"\n#include \"mac.h\"\n#include \"reg.h\"\n#include \"debug.h\"\n#include \"util.h\"\n#include \"bf.h\"\n#include \"efuse.h\"\n\n#define IQK_DONE_8822C 0xaa\n\nstatic void rtw8822c_config_trx_mode(struct rtw_dev *rtwdev, u8 tx_path,\n\t\t\t\t     u8 rx_path, bool is_tx2_path);\n\nstatic void rtw8822ce_efuse_parsing(struct rtw_efuse *efuse,\n\t\t\t\t    struct rtw8822c_efuse *map)\n{\n\tether_addr_copy(efuse->addr, map->e.mac_addr);\n}\n\nstatic void rtw8822cu_efuse_parsing(struct rtw_efuse *efuse,\n\t\t\t\t    struct rtw8822c_efuse *map)\n{\n\tether_addr_copy(efuse->addr, map->u.mac_addr);\n}\n\nstatic void rtw8822cs_efuse_parsing(struct rtw_efuse *efuse,\n\t\t\t\t    struct rtw8822c_efuse *map)\n{\n\tether_addr_copy(efuse->addr, map->s.mac_addr);\n}\n\nstatic int rtw8822c_read_efuse(struct rtw_dev *rtwdev, u8 *log_map)\n{\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\tstruct rtw8822c_efuse *map;\n\tint i;\n\n\tmap = (struct rtw8822c_efuse *)log_map;\n\n\tefuse->rfe_option = map->rfe_option;\n\tefuse->rf_board_option = map->rf_board_option;\n\tefuse->crystal_cap = map->xtal_k & XCAP_MASK;\n\tefuse->channel_plan = map->channel_plan;\n\tefuse->country_code[0] = map->country_code[0];\n\tefuse->country_code[1] = map->country_code[1];\n\tefuse->bt_setting = map->rf_bt_setting;\n\tefuse->regd = map->rf_board_option & 0x7;\n\tefuse->thermal_meter[RF_PATH_A] = map->path_a_thermal;\n\tefuse->thermal_meter[RF_PATH_B] = map->path_b_thermal;\n\tefuse->thermal_meter_k =\n\t\t\t(map->path_a_thermal + map->path_b_thermal) >> 1;\n\tefuse->power_track_type = (map->tx_pwr_calibrate_rate >> 4) & 0xf;\n\n\tfor (i = 0; i < 4; i++)\n\t\tefuse->txpwr_idx_table[i] = map->txpwr_idx_table[i];\n\n\tswitch (rtw_hci_type(rtwdev)) {\n\tcase RTW_HCI_TYPE_PCIE:\n\t\trtw8822ce_efuse_parsing(efuse, map);\n\t\tbreak;\n\tcase RTW_HCI_TYPE_USB:\n\t\trtw8822cu_efuse_parsing(efuse, map);\n\t\tbreak;\n\tcase RTW_HCI_TYPE_SDIO:\n\t\trtw8822cs_efuse_parsing(efuse, map);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic void rtw8822c_header_file_init(struct rtw_dev *rtwdev, bool pre)\n{\n\trtw_write32_set(rtwdev, REG_3WIRE, BIT_3WIRE_TX_EN | BIT_3WIRE_RX_EN);\n\trtw_write32_set(rtwdev, REG_3WIRE, BIT_3WIRE_PI_ON);\n\trtw_write32_set(rtwdev, REG_3WIRE2, BIT_3WIRE_TX_EN | BIT_3WIRE_RX_EN);\n\trtw_write32_set(rtwdev, REG_3WIRE2, BIT_3WIRE_PI_ON);\n\n\tif (pre)\n\t\trtw_write32_clr(rtwdev, REG_ENCCK, BIT_CCK_OFDM_BLK_EN);\n\telse\n\t\trtw_write32_set(rtwdev, REG_ENCCK, BIT_CCK_OFDM_BLK_EN);\n}\n\nstatic void rtw8822c_bb_reset(struct rtw_dev *rtwdev)\n{\n\trtw_write16_set(rtwdev, REG_SYS_FUNC_EN, BIT_FEN_BB_RSTB);\n\trtw_write16_clr(rtwdev, REG_SYS_FUNC_EN, BIT_FEN_BB_RSTB);\n\trtw_write16_set(rtwdev, REG_SYS_FUNC_EN, BIT_FEN_BB_RSTB);\n}\n\nstatic void rtw8822c_dac_backup_reg(struct rtw_dev *rtwdev,\n\t\t\t\t    struct rtw_backup_info *backup,\n\t\t\t\t    struct rtw_backup_info *backup_rf)\n{\n\tu32 path, i;\n\tu32 val;\n\tu32 reg;\n\tu32 rf_addr[DACK_RF_8822C] = {0x8f};\n\tu32 addrs[DACK_REG_8822C] = {0x180c, 0x1810, 0x410c, 0x4110,\n\t\t\t\t     0x1c3c, 0x1c24, 0x1d70, 0x9b4,\n\t\t\t\t     0x1a00, 0x1a14, 0x1d58, 0x1c38,\n\t\t\t\t     0x1e24, 0x1e28, 0x1860, 0x4160};\n\n\tfor (i = 0; i < DACK_REG_8822C; i++) {\n\t\tbackup[i].len = 4;\n\t\tbackup[i].reg = addrs[i];\n\t\tbackup[i].val = rtw_read32(rtwdev, addrs[i]);\n\t}\n\n\tfor (path = 0; path < DACK_PATH_8822C; path++) {\n\t\tfor (i = 0; i < DACK_RF_8822C; i++) {\n\t\t\treg = rf_addr[i];\n\t\t\tval = rtw_read_rf(rtwdev, path, reg, RFREG_MASK);\n\t\t\tbackup_rf[path * i + i].reg = reg;\n\t\t\tbackup_rf[path * i + i].val = val;\n\t\t}\n\t}\n}\n\nstatic void rtw8822c_dac_restore_reg(struct rtw_dev *rtwdev,\n\t\t\t\t     struct rtw_backup_info *backup,\n\t\t\t\t     struct rtw_backup_info *backup_rf)\n{\n\tu32 path, i;\n\tu32 val;\n\tu32 reg;\n\n\trtw_restore_reg(rtwdev, backup, DACK_REG_8822C);\n\n\tfor (path = 0; path < DACK_PATH_8822C; path++) {\n\t\tfor (i = 0; i < DACK_RF_8822C; i++) {\n\t\t\tval = backup_rf[path * i + i].val;\n\t\t\treg = backup_rf[path * i + i].reg;\n\t\t\trtw_write_rf(rtwdev, path, reg, RFREG_MASK, val);\n\t\t}\n\t}\n}\n\nstatic void rtw8822c_rf_minmax_cmp(struct rtw_dev *rtwdev, u32 value,\n\t\t\t\t   u32 *min, u32 *max)\n{\n\tif (value >= 0x200) {\n\t\tif (*min >= 0x200) {\n\t\t\tif (*min > value)\n\t\t\t\t*min = value;\n\t\t} else {\n\t\t\t*min = value;\n\t\t}\n\t\tif (*max >= 0x200) {\n\t\t\tif (*max < value)\n\t\t\t\t*max = value;\n\t\t}\n\t} else {\n\t\tif (*min < 0x200) {\n\t\t\tif (*min > value)\n\t\t\t\t*min = value;\n\t\t}\n\n\t\tif (*max  >= 0x200) {\n\t\t\t*max = value;\n\t\t} else {\n\t\t\tif (*max < value)\n\t\t\t\t*max = value;\n\t\t}\n\t}\n}\n\nstatic void __rtw8822c_dac_iq_sort(struct rtw_dev *rtwdev, u32 *v1, u32 *v2)\n{\n\tif (*v1 >= 0x200 && *v2 >= 0x200) {\n\t\tif (*v1 > *v2)\n\t\t\tswap(*v1, *v2);\n\t} else if (*v1 < 0x200 && *v2 < 0x200) {\n\t\tif (*v1 > *v2)\n\t\t\tswap(*v1, *v2);\n\t} else if (*v1 < 0x200 && *v2 >= 0x200) {\n\t\tswap(*v1, *v2);\n\t}\n}\n\nstatic void rtw8822c_dac_iq_sort(struct rtw_dev *rtwdev, u32 *iv, u32 *qv)\n{\n\tu32 i, j;\n\n\tfor (i = 0; i < DACK_SN_8822C - 1; i++) {\n\t\tfor (j = 0; j < (DACK_SN_8822C - 1 - i) ; j++) {\n\t\t\t__rtw8822c_dac_iq_sort(rtwdev, &iv[j], &iv[j + 1]);\n\t\t\t__rtw8822c_dac_iq_sort(rtwdev, &qv[j], &qv[j + 1]);\n\t\t}\n\t}\n}\n\nstatic void rtw8822c_dac_iq_offset(struct rtw_dev *rtwdev, u32 *vec, u32 *val)\n{\n\tu32 p, m, t, i;\n\n\tm = 0;\n\tp = 0;\n\tfor (i = 10; i < DACK_SN_8822C - 10; i++) {\n\t\tif (vec[i] > 0x200)\n\t\t\tm = (0x400 - vec[i]) + m;\n\t\telse\n\t\t\tp = vec[i] + p;\n\t}\n\n\tif (p > m) {\n\t\tt = p - m;\n\t\tt = t / (DACK_SN_8822C - 20);\n\t} else {\n\t\tt = m - p;\n\t\tt = t / (DACK_SN_8822C - 20);\n\t\tif (t != 0x0)\n\t\t\tt = 0x400 - t;\n\t}\n\n\t*val = t;\n}\n\nstatic u32 rtw8822c_get_path_write_addr(u8 path)\n{\n\tu32 base_addr;\n\n\tswitch (path) {\n\tcase RF_PATH_A:\n\t\tbase_addr = 0x1800;\n\t\tbreak;\n\tcase RF_PATH_B:\n\t\tbase_addr = 0x4100;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -1;\n\t}\n\n\treturn base_addr;\n}\n\nstatic u32 rtw8822c_get_path_read_addr(u8 path)\n{\n\tu32 base_addr;\n\n\tswitch (path) {\n\tcase RF_PATH_A:\n\t\tbase_addr = 0x2800;\n\t\tbreak;\n\tcase RF_PATH_B:\n\t\tbase_addr = 0x4500;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -1;\n\t}\n\n\treturn base_addr;\n}\n\nstatic bool rtw8822c_dac_iq_check(struct rtw_dev *rtwdev, u32 value)\n{\n\tbool ret = true;\n\n\tif ((value >= 0x200 && (0x400 - value) > 0x64) ||\n\t    (value < 0x200 && value > 0x64)) {\n\t\tret = false;\n\t\trtw_dbg(rtwdev, RTW_DBG_RFK, \"[DACK] Error overflow\\n\");\n\t}\n\n\treturn ret;\n}\n\nstatic void rtw8822c_dac_cal_iq_sample(struct rtw_dev *rtwdev, u32 *iv, u32 *qv)\n{\n\tu32 temp;\n\tint i = 0, cnt = 0;\n\n\twhile (i < DACK_SN_8822C && cnt < 10000) {\n\t\tcnt++;\n\t\ttemp = rtw_read32_mask(rtwdev, 0x2dbc, 0x3fffff);\n\t\tiv[i] = (temp & 0x3ff000) >> 12;\n\t\tqv[i] = temp & 0x3ff;\n\n\t\tif (rtw8822c_dac_iq_check(rtwdev, iv[i]) &&\n\t\t    rtw8822c_dac_iq_check(rtwdev, qv[i]))\n\t\t\ti++;\n\t}\n}\n\nstatic void rtw8822c_dac_cal_iq_search(struct rtw_dev *rtwdev,\n\t\t\t\t       u32 *iv, u32 *qv,\n\t\t\t\t       u32 *i_value, u32 *q_value)\n{\n\tu32 i_max = 0, q_max = 0, i_min = 0, q_min = 0;\n\tu32 i_delta, q_delta;\n\tu32 temp;\n\tint i, cnt = 0;\n\n\tdo {\n\t\ti_min = iv[0];\n\t\ti_max = iv[0];\n\t\tq_min = qv[0];\n\t\tq_max = qv[0];\n\t\tfor (i = 0; i < DACK_SN_8822C; i++) {\n\t\t\trtw8822c_rf_minmax_cmp(rtwdev, iv[i], &i_min, &i_max);\n\t\t\trtw8822c_rf_minmax_cmp(rtwdev, qv[i], &q_min, &q_max);\n\t\t}\n\n\t\tif (i_max < 0x200 && i_min < 0x200)\n\t\t\ti_delta = i_max - i_min;\n\t\telse if (i_max >= 0x200 && i_min >= 0x200)\n\t\t\ti_delta = i_max - i_min;\n\t\telse\n\t\t\ti_delta = i_max + (0x400 - i_min);\n\n\t\tif (q_max < 0x200 && q_min < 0x200)\n\t\t\tq_delta = q_max - q_min;\n\t\telse if (q_max >= 0x200 && q_min >= 0x200)\n\t\t\tq_delta = q_max - q_min;\n\t\telse\n\t\t\tq_delta = q_max + (0x400 - q_min);\n\n\t\trtw_dbg(rtwdev, RTW_DBG_RFK,\n\t\t\t\"[DACK] i: min=0x%08x, max=0x%08x, delta=0x%08x\\n\",\n\t\t\ti_min, i_max, i_delta);\n\t\trtw_dbg(rtwdev, RTW_DBG_RFK,\n\t\t\t\"[DACK] q: min=0x%08x, max=0x%08x, delta=0x%08x\\n\",\n\t\t\tq_min, q_max, q_delta);\n\n\t\trtw8822c_dac_iq_sort(rtwdev, iv, qv);\n\n\t\tif (i_delta > 5 || q_delta > 5) {\n\t\t\ttemp = rtw_read32_mask(rtwdev, 0x2dbc, 0x3fffff);\n\t\t\tiv[0] = (temp & 0x3ff000) >> 12;\n\t\t\tqv[0] = temp & 0x3ff;\n\t\t\ttemp = rtw_read32_mask(rtwdev, 0x2dbc, 0x3fffff);\n\t\t\tiv[DACK_SN_8822C - 1] = (temp & 0x3ff000) >> 12;\n\t\t\tqv[DACK_SN_8822C - 1] = temp & 0x3ff;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t} while (cnt++ < 100);\n\n\trtw8822c_dac_iq_offset(rtwdev, iv, i_value);\n\trtw8822c_dac_iq_offset(rtwdev, qv, q_value);\n}\n\nstatic void rtw8822c_dac_cal_rf_mode(struct rtw_dev *rtwdev,\n\t\t\t\t     u32 *i_value, u32 *q_value)\n{\n\tu32 iv[DACK_SN_8822C], qv[DACK_SN_8822C];\n\tu32 rf_a, rf_b;\n\n\trf_a = rtw_read_rf(rtwdev, RF_PATH_A, 0x0, RFREG_MASK);\n\trf_b = rtw_read_rf(rtwdev, RF_PATH_B, 0x0, RFREG_MASK);\n\n\trtw_dbg(rtwdev, RTW_DBG_RFK, \"[DACK] RF path-A=0x%05x\\n\", rf_a);\n\trtw_dbg(rtwdev, RTW_DBG_RFK, \"[DACK] RF path-B=0x%05x\\n\", rf_b);\n\n\trtw8822c_dac_cal_iq_sample(rtwdev, iv, qv);\n\trtw8822c_dac_cal_iq_search(rtwdev, iv, qv, i_value, q_value);\n}\n\nstatic void rtw8822c_dac_bb_setting(struct rtw_dev *rtwdev)\n{\n\trtw_write32_mask(rtwdev, 0x1d58, 0xff8, 0x1ff);\n\trtw_write32_mask(rtwdev, 0x1a00, 0x3, 0x2);\n\trtw_write32_mask(rtwdev, 0x1a14, 0x300, 0x3);\n\trtw_write32(rtwdev, 0x1d70, 0x7e7e7e7e);\n\trtw_write32_mask(rtwdev, 0x180c, 0x3, 0x0);\n\trtw_write32_mask(rtwdev, 0x410c, 0x3, 0x0);\n\trtw_write32(rtwdev, 0x1b00, 0x00000008);\n\trtw_write8(rtwdev, 0x1bcc, 0x3f);\n\trtw_write32(rtwdev, 0x1b00, 0x0000000a);\n\trtw_write8(rtwdev, 0x1bcc, 0x3f);\n\trtw_write32_mask(rtwdev, 0x1e24, BIT(31), 0x0);\n\trtw_write32_mask(rtwdev, 0x1e28, 0xf, 0x3);\n}\n\nstatic void rtw8822c_dac_cal_adc(struct rtw_dev *rtwdev,\n\t\t\t\t u8 path, u32 *adc_ic, u32 *adc_qc)\n{\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tu32 ic = 0, qc = 0, temp = 0;\n\tu32 base_addr;\n\tu32 path_sel;\n\tint i;\n\n\trtw_dbg(rtwdev, RTW_DBG_RFK, \"[DACK] ADCK path(%d)\\n\", path);\n\n\tbase_addr = rtw8822c_get_path_write_addr(path);\n\tswitch (path) {\n\tcase RF_PATH_A:\n\t\tpath_sel = 0xa0000;\n\t\tbreak;\n\tcase RF_PATH_B:\n\t\tpath_sel = 0x80000;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t \n\trtw_write32_mask(rtwdev, base_addr + 0x30, BIT(30), 0x0);\n\tif (path == RF_PATH_B)\n\t\trtw_write32(rtwdev, base_addr + 0x30, 0x30db8041);\n\trtw_write32(rtwdev, base_addr + 0x60, 0xf0040ff0);\n\trtw_write32(rtwdev, base_addr + 0x0c, 0xdff00220);\n\trtw_write32(rtwdev, base_addr + 0x10, 0x02dd08c4);\n\trtw_write32(rtwdev, base_addr + 0x0c, 0x10000260);\n\trtw_write_rf(rtwdev, RF_PATH_A, 0x0, RFREG_MASK, 0x10000);\n\trtw_write_rf(rtwdev, RF_PATH_B, 0x0, RFREG_MASK, 0x10000);\n\tfor (i = 0; i < 10; i++) {\n\t\trtw_dbg(rtwdev, RTW_DBG_RFK, \"[DACK] ADCK count=%d\\n\", i);\n\t\trtw_write32(rtwdev, 0x1c3c, path_sel + 0x8003);\n\t\trtw_write32(rtwdev, 0x1c24, 0x00010002);\n\t\trtw8822c_dac_cal_rf_mode(rtwdev, &ic, &qc);\n\t\trtw_dbg(rtwdev, RTW_DBG_RFK,\n\t\t\t\"[DACK] before: i=0x%x, q=0x%x\\n\", ic, qc);\n\n\t\t \n\t\tif (ic != 0x0) {\n\t\t\tic = 0x400 - ic;\n\t\t\t*adc_ic = ic;\n\t\t}\n\t\tif (qc != 0x0) {\n\t\t\tqc = 0x400 - qc;\n\t\t\t*adc_qc = qc;\n\t\t}\n\t\ttemp = (ic & 0x3ff) | ((qc & 0x3ff) << 10);\n\t\trtw_write32(rtwdev, base_addr + 0x68, temp);\n\t\tdm_info->dack_adck[path] = temp;\n\t\trtw_dbg(rtwdev, RTW_DBG_RFK, \"[DACK] ADCK 0x%08x=0x08%x\\n\",\n\t\t\tbase_addr + 0x68, temp);\n\t\t \n\t\trtw_write32(rtwdev, 0x1c3c, path_sel + 0x8103);\n\t\trtw8822c_dac_cal_rf_mode(rtwdev, &ic, &qc);\n\t\trtw_dbg(rtwdev, RTW_DBG_RFK,\n\t\t\t\"[DACK] after:  i=0x%08x, q=0x%08x\\n\", ic, qc);\n\t\tif (ic >= 0x200)\n\t\t\tic = 0x400 - ic;\n\t\tif (qc >= 0x200)\n\t\t\tqc = 0x400 - qc;\n\t\tif (ic < 5 && qc < 5)\n\t\t\tbreak;\n\t}\n\n\t \n\trtw_write32(rtwdev, 0x1c3c, 0x00000003);\n\trtw_write32(rtwdev, base_addr + 0x0c, 0x10000260);\n\trtw_write32(rtwdev, base_addr + 0x10, 0x02d508c4);\n\n\t \n\trtw_write_rf(rtwdev, path, 0x8f, BIT(13), 0x1);\n}\n\nstatic void rtw8822c_dac_cal_step1(struct rtw_dev *rtwdev, u8 path)\n{\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tu32 base_addr;\n\tu32 read_addr;\n\n\tbase_addr = rtw8822c_get_path_write_addr(path);\n\tread_addr = rtw8822c_get_path_read_addr(path);\n\n\trtw_write32(rtwdev, base_addr + 0x68, dm_info->dack_adck[path]);\n\trtw_write32(rtwdev, base_addr + 0x0c, 0xdff00220);\n\tif (path == RF_PATH_A) {\n\t\trtw_write32(rtwdev, base_addr + 0x60, 0xf0040ff0);\n\t\trtw_write32(rtwdev, 0x1c38, 0xffffffff);\n\t}\n\trtw_write32(rtwdev, base_addr + 0x10, 0x02d508c5);\n\trtw_write32(rtwdev, 0x9b4, 0xdb66db00);\n\trtw_write32(rtwdev, base_addr + 0xb0, 0x0a11fb88);\n\trtw_write32(rtwdev, base_addr + 0xbc, 0x0008ff81);\n\trtw_write32(rtwdev, base_addr + 0xc0, 0x0003d208);\n\trtw_write32(rtwdev, base_addr + 0xcc, 0x0a11fb88);\n\trtw_write32(rtwdev, base_addr + 0xd8, 0x0008ff81);\n\trtw_write32(rtwdev, base_addr + 0xdc, 0x0003d208);\n\trtw_write32(rtwdev, base_addr + 0xb8, 0x60000000);\n\tmdelay(2);\n\trtw_write32(rtwdev, base_addr + 0xbc, 0x000aff8d);\n\tmdelay(2);\n\trtw_write32(rtwdev, base_addr + 0xb0, 0x0a11fb89);\n\trtw_write32(rtwdev, base_addr + 0xcc, 0x0a11fb89);\n\tmdelay(1);\n\trtw_write32(rtwdev, base_addr + 0xb8, 0x62000000);\n\trtw_write32(rtwdev, base_addr + 0xd4, 0x62000000);\n\tmdelay(20);\n\tif (!check_hw_ready(rtwdev, read_addr + 0x08, 0x7fff80, 0xffff) ||\n\t    !check_hw_ready(rtwdev, read_addr + 0x34, 0x7fff80, 0xffff))\n\t\trtw_err(rtwdev, \"failed to wait for dack ready\\n\");\n\trtw_write32(rtwdev, base_addr + 0xb8, 0x02000000);\n\tmdelay(1);\n\trtw_write32(rtwdev, base_addr + 0xbc, 0x0008ff87);\n\trtw_write32(rtwdev, 0x9b4, 0xdb6db600);\n\trtw_write32(rtwdev, base_addr + 0x10, 0x02d508c5);\n\trtw_write32(rtwdev, base_addr + 0xbc, 0x0008ff87);\n\trtw_write32(rtwdev, base_addr + 0x60, 0xf0000000);\n}\n\nstatic void rtw8822c_dac_cal_step2(struct rtw_dev *rtwdev,\n\t\t\t\t   u8 path, u32 *ic_out, u32 *qc_out)\n{\n\tu32 base_addr;\n\tu32 ic, qc, ic_in, qc_in;\n\n\tbase_addr = rtw8822c_get_path_write_addr(path);\n\trtw_write32_mask(rtwdev, base_addr + 0xbc, 0xf0000000, 0x0);\n\trtw_write32_mask(rtwdev, base_addr + 0xc0, 0xf, 0x8);\n\trtw_write32_mask(rtwdev, base_addr + 0xd8, 0xf0000000, 0x0);\n\trtw_write32_mask(rtwdev, base_addr + 0xdc, 0xf, 0x8);\n\n\trtw_write32(rtwdev, 0x1b00, 0x00000008);\n\trtw_write8(rtwdev, 0x1bcc, 0x03f);\n\trtw_write32(rtwdev, base_addr + 0x0c, 0xdff00220);\n\trtw_write32(rtwdev, base_addr + 0x10, 0x02d508c5);\n\trtw_write32(rtwdev, 0x1c3c, 0x00088103);\n\n\trtw8822c_dac_cal_rf_mode(rtwdev, &ic_in, &qc_in);\n\tic = ic_in;\n\tqc = qc_in;\n\n\t \n\tif (ic != 0x0)\n\t\tic = 0x400 - ic;\n\tif (qc != 0x0)\n\t\tqc = 0x400 - qc;\n\tif (ic < 0x300) {\n\t\tic = ic * 2 * 6 / 5;\n\t\tic = ic + 0x80;\n\t} else {\n\t\tic = (0x400 - ic) * 2 * 6 / 5;\n\t\tic = 0x7f - ic;\n\t}\n\tif (qc < 0x300) {\n\t\tqc = qc * 2 * 6 / 5;\n\t\tqc = qc + 0x80;\n\t} else {\n\t\tqc = (0x400 - qc) * 2 * 6 / 5;\n\t\tqc = 0x7f - qc;\n\t}\n\n\t*ic_out = ic;\n\t*qc_out = qc;\n\n\trtw_dbg(rtwdev, RTW_DBG_RFK, \"[DACK] before i=0x%x, q=0x%x\\n\", ic_in, qc_in);\n\trtw_dbg(rtwdev, RTW_DBG_RFK, \"[DACK] after  i=0x%x, q=0x%x\\n\", ic, qc);\n}\n\nstatic void rtw8822c_dac_cal_step3(struct rtw_dev *rtwdev, u8 path,\n\t\t\t\t   u32 adc_ic, u32 adc_qc,\n\t\t\t\t   u32 *ic_in, u32 *qc_in,\n\t\t\t\t   u32 *i_out, u32 *q_out)\n{\n\tu32 base_addr;\n\tu32 read_addr;\n\tu32 ic, qc;\n\tu32 temp;\n\n\tbase_addr = rtw8822c_get_path_write_addr(path);\n\tread_addr = rtw8822c_get_path_read_addr(path);\n\tic = *ic_in;\n\tqc = *qc_in;\n\n\trtw_write32(rtwdev, base_addr + 0x0c, 0xdff00220);\n\trtw_write32(rtwdev, base_addr + 0x10, 0x02d508c5);\n\trtw_write32(rtwdev, 0x9b4, 0xdb66db00);\n\trtw_write32(rtwdev, base_addr + 0xb0, 0x0a11fb88);\n\trtw_write32(rtwdev, base_addr + 0xbc, 0xc008ff81);\n\trtw_write32(rtwdev, base_addr + 0xc0, 0x0003d208);\n\trtw_write32_mask(rtwdev, base_addr + 0xbc, 0xf0000000, ic & 0xf);\n\trtw_write32_mask(rtwdev, base_addr + 0xc0, 0xf, (ic & 0xf0) >> 4);\n\trtw_write32(rtwdev, base_addr + 0xcc, 0x0a11fb88);\n\trtw_write32(rtwdev, base_addr + 0xd8, 0xe008ff81);\n\trtw_write32(rtwdev, base_addr + 0xdc, 0x0003d208);\n\trtw_write32_mask(rtwdev, base_addr + 0xd8, 0xf0000000, qc & 0xf);\n\trtw_write32_mask(rtwdev, base_addr + 0xdc, 0xf, (qc & 0xf0) >> 4);\n\trtw_write32(rtwdev, base_addr + 0xb8, 0x60000000);\n\tmdelay(2);\n\trtw_write32_mask(rtwdev, base_addr + 0xbc, 0xe, 0x6);\n\tmdelay(2);\n\trtw_write32(rtwdev, base_addr + 0xb0, 0x0a11fb89);\n\trtw_write32(rtwdev, base_addr + 0xcc, 0x0a11fb89);\n\tmdelay(1);\n\trtw_write32(rtwdev, base_addr + 0xb8, 0x62000000);\n\trtw_write32(rtwdev, base_addr + 0xd4, 0x62000000);\n\tmdelay(20);\n\tif (!check_hw_ready(rtwdev, read_addr + 0x24, 0x07f80000, ic) ||\n\t    !check_hw_ready(rtwdev, read_addr + 0x50, 0x07f80000, qc))\n\t\trtw_err(rtwdev, \"failed to write IQ vector to hardware\\n\");\n\trtw_write32(rtwdev, base_addr + 0xb8, 0x02000000);\n\tmdelay(1);\n\trtw_write32_mask(rtwdev, base_addr + 0xbc, 0xe, 0x3);\n\trtw_write32(rtwdev, 0x9b4, 0xdb6db600);\n\n\t \n\ttemp = ((adc_ic + 0x10) & 0x3ff) | (((adc_qc + 0x10) & 0x3ff) << 10);\n\trtw_write32(rtwdev, base_addr + 0x68, temp);\n\trtw_write32(rtwdev, base_addr + 0x10, 0x02d508c5);\n\trtw_write32(rtwdev, base_addr + 0x60, 0xf0000000);\n\trtw8822c_dac_cal_rf_mode(rtwdev, &ic, &qc);\n\tif (ic >= 0x10)\n\t\tic = ic - 0x10;\n\telse\n\t\tic = 0x400 - (0x10 - ic);\n\n\tif (qc >= 0x10)\n\t\tqc = qc - 0x10;\n\telse\n\t\tqc = 0x400 - (0x10 - qc);\n\n\t*i_out = ic;\n\t*q_out = qc;\n\n\tif (ic >= 0x200)\n\t\tic = 0x400 - ic;\n\tif (qc >= 0x200)\n\t\tqc = 0x400 - qc;\n\n\t*ic_in = ic;\n\t*qc_in = qc;\n\n\trtw_dbg(rtwdev, RTW_DBG_RFK,\n\t\t\"[DACK] after  DACK i=0x%x, q=0x%x\\n\", *i_out, *q_out);\n}\n\nstatic void rtw8822c_dac_cal_step4(struct rtw_dev *rtwdev, u8 path)\n{\n\tu32 base_addr = rtw8822c_get_path_write_addr(path);\n\n\trtw_write32(rtwdev, base_addr + 0x68, 0x0);\n\trtw_write32(rtwdev, base_addr + 0x10, 0x02d508c4);\n\trtw_write32_mask(rtwdev, base_addr + 0xbc, 0x1, 0x0);\n\trtw_write32_mask(rtwdev, base_addr + 0x30, BIT(30), 0x1);\n}\n\nstatic void rtw8822c_dac_cal_backup_vec(struct rtw_dev *rtwdev,\n\t\t\t\t\tu8 path, u8 vec, u32 w_addr, u32 r_addr)\n{\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tu16 val;\n\tu32 i;\n\n\tif (WARN_ON(vec >= 2))\n\t\treturn;\n\n\tfor (i = 0; i < DACK_MSBK_BACKUP_NUM; i++) {\n\t\trtw_write32_mask(rtwdev, w_addr, 0xf0000000, i);\n\t\tval = (u16)rtw_read32_mask(rtwdev, r_addr, 0x7fc0000);\n\t\tdm_info->dack_msbk[path][vec][i] = val;\n\t}\n}\n\nstatic void rtw8822c_dac_cal_backup_path(struct rtw_dev *rtwdev, u8 path)\n{\n\tu32 w_off = 0x1c;\n\tu32 r_off = 0x2c;\n\tu32 w_addr, r_addr;\n\n\tif (WARN_ON(path >= 2))\n\t\treturn;\n\n\t \n\tw_addr = rtw8822c_get_path_write_addr(path) + 0xb0;\n\tr_addr = rtw8822c_get_path_read_addr(path) + 0x10;\n\trtw8822c_dac_cal_backup_vec(rtwdev, path, 0, w_addr, r_addr);\n\n\t \n\tw_addr = rtw8822c_get_path_write_addr(path) + 0xb0 + w_off;\n\tr_addr = rtw8822c_get_path_read_addr(path) + 0x10 + r_off;\n\trtw8822c_dac_cal_backup_vec(rtwdev, path, 1, w_addr, r_addr);\n}\n\nstatic void rtw8822c_dac_cal_backup_dck(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tu8 val;\n\n\tval = (u8)rtw_read32_mask(rtwdev, REG_DCKA_I_0, 0xf0000000);\n\tdm_info->dack_dck[RF_PATH_A][0][0] = val;\n\tval = (u8)rtw_read32_mask(rtwdev, REG_DCKA_I_1, 0xf);\n\tdm_info->dack_dck[RF_PATH_A][0][1] = val;\n\tval = (u8)rtw_read32_mask(rtwdev, REG_DCKA_Q_0, 0xf0000000);\n\tdm_info->dack_dck[RF_PATH_A][1][0] = val;\n\tval = (u8)rtw_read32_mask(rtwdev, REG_DCKA_Q_1, 0xf);\n\tdm_info->dack_dck[RF_PATH_A][1][1] = val;\n\n\tval = (u8)rtw_read32_mask(rtwdev, REG_DCKB_I_0, 0xf0000000);\n\tdm_info->dack_dck[RF_PATH_B][0][0] = val;\n\tval = (u8)rtw_read32_mask(rtwdev, REG_DCKB_I_1, 0xf);\n\tdm_info->dack_dck[RF_PATH_B][1][0] = val;\n\tval = (u8)rtw_read32_mask(rtwdev, REG_DCKB_Q_0, 0xf0000000);\n\tdm_info->dack_dck[RF_PATH_B][0][1] = val;\n\tval = (u8)rtw_read32_mask(rtwdev, REG_DCKB_Q_1, 0xf);\n\tdm_info->dack_dck[RF_PATH_B][1][1] = val;\n}\n\nstatic void rtw8822c_dac_cal_backup(struct rtw_dev *rtwdev)\n{\n\tu32 temp[3];\n\n\ttemp[0] = rtw_read32(rtwdev, 0x1860);\n\ttemp[1] = rtw_read32(rtwdev, 0x4160);\n\ttemp[2] = rtw_read32(rtwdev, 0x9b4);\n\n\t \n\trtw_write32(rtwdev, 0x9b4, 0xdb66db00);\n\n\t \n\trtw_write32_clr(rtwdev, 0x1830, BIT(30));\n\trtw_write32_mask(rtwdev, 0x1860, 0xfc000000, 0x3c);\n\trtw8822c_dac_cal_backup_path(rtwdev, RF_PATH_A);\n\n\t \n\trtw_write32_clr(rtwdev, 0x4130, BIT(30));\n\trtw_write32_mask(rtwdev, 0x4160, 0xfc000000, 0x3c);\n\trtw8822c_dac_cal_backup_path(rtwdev, RF_PATH_B);\n\n\trtw8822c_dac_cal_backup_dck(rtwdev);\n\trtw_write32_set(rtwdev, 0x1830, BIT(30));\n\trtw_write32_set(rtwdev, 0x4130, BIT(30));\n\n\trtw_write32(rtwdev, 0x1860, temp[0]);\n\trtw_write32(rtwdev, 0x4160, temp[1]);\n\trtw_write32(rtwdev, 0x9b4, temp[2]);\n}\n\nstatic void rtw8822c_dac_cal_restore_dck(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tu8 val;\n\n\trtw_write32_set(rtwdev, REG_DCKA_I_0, BIT(19));\n\tval = dm_info->dack_dck[RF_PATH_A][0][0];\n\trtw_write32_mask(rtwdev, REG_DCKA_I_0, 0xf0000000, val);\n\tval = dm_info->dack_dck[RF_PATH_A][0][1];\n\trtw_write32_mask(rtwdev, REG_DCKA_I_1, 0xf, val);\n\n\trtw_write32_set(rtwdev, REG_DCKA_Q_0, BIT(19));\n\tval = dm_info->dack_dck[RF_PATH_A][1][0];\n\trtw_write32_mask(rtwdev, REG_DCKA_Q_0, 0xf0000000, val);\n\tval = dm_info->dack_dck[RF_PATH_A][1][1];\n\trtw_write32_mask(rtwdev, REG_DCKA_Q_1, 0xf, val);\n\n\trtw_write32_set(rtwdev, REG_DCKB_I_0, BIT(19));\n\tval = dm_info->dack_dck[RF_PATH_B][0][0];\n\trtw_write32_mask(rtwdev, REG_DCKB_I_0, 0xf0000000, val);\n\tval = dm_info->dack_dck[RF_PATH_B][0][1];\n\trtw_write32_mask(rtwdev, REG_DCKB_I_1, 0xf, val);\n\n\trtw_write32_set(rtwdev, REG_DCKB_Q_0, BIT(19));\n\tval = dm_info->dack_dck[RF_PATH_B][1][0];\n\trtw_write32_mask(rtwdev, REG_DCKB_Q_0, 0xf0000000, val);\n\tval = dm_info->dack_dck[RF_PATH_B][1][1];\n\trtw_write32_mask(rtwdev, REG_DCKB_Q_1, 0xf, val);\n}\n\nstatic void rtw8822c_dac_cal_restore_prepare(struct rtw_dev *rtwdev)\n{\n\trtw_write32(rtwdev, 0x9b4, 0xdb66db00);\n\n\trtw_write32_mask(rtwdev, 0x18b0, BIT(27), 0x0);\n\trtw_write32_mask(rtwdev, 0x18cc, BIT(27), 0x0);\n\trtw_write32_mask(rtwdev, 0x41b0, BIT(27), 0x0);\n\trtw_write32_mask(rtwdev, 0x41cc, BIT(27), 0x0);\n\n\trtw_write32_mask(rtwdev, 0x1830, BIT(30), 0x0);\n\trtw_write32_mask(rtwdev, 0x1860, 0xfc000000, 0x3c);\n\trtw_write32_mask(rtwdev, 0x18b4, BIT(0), 0x1);\n\trtw_write32_mask(rtwdev, 0x18d0, BIT(0), 0x1);\n\n\trtw_write32_mask(rtwdev, 0x4130, BIT(30), 0x0);\n\trtw_write32_mask(rtwdev, 0x4160, 0xfc000000, 0x3c);\n\trtw_write32_mask(rtwdev, 0x41b4, BIT(0), 0x1);\n\trtw_write32_mask(rtwdev, 0x41d0, BIT(0), 0x1);\n\n\trtw_write32_mask(rtwdev, 0x18b0, 0xf00, 0x0);\n\trtw_write32_mask(rtwdev, 0x18c0, BIT(14), 0x0);\n\trtw_write32_mask(rtwdev, 0x18cc, 0xf00, 0x0);\n\trtw_write32_mask(rtwdev, 0x18dc, BIT(14), 0x0);\n\n\trtw_write32_mask(rtwdev, 0x18b0, BIT(0), 0x0);\n\trtw_write32_mask(rtwdev, 0x18cc, BIT(0), 0x0);\n\trtw_write32_mask(rtwdev, 0x18b0, BIT(0), 0x1);\n\trtw_write32_mask(rtwdev, 0x18cc, BIT(0), 0x1);\n\n\trtw8822c_dac_cal_restore_dck(rtwdev);\n\n\trtw_write32_mask(rtwdev, 0x18c0, 0x38000, 0x7);\n\trtw_write32_mask(rtwdev, 0x18dc, 0x38000, 0x7);\n\trtw_write32_mask(rtwdev, 0x41c0, 0x38000, 0x7);\n\trtw_write32_mask(rtwdev, 0x41dc, 0x38000, 0x7);\n\n\trtw_write32_mask(rtwdev, 0x18b8, BIT(26) | BIT(25), 0x1);\n\trtw_write32_mask(rtwdev, 0x18d4, BIT(26) | BIT(25), 0x1);\n\n\trtw_write32_mask(rtwdev, 0x41b0, 0xf00, 0x0);\n\trtw_write32_mask(rtwdev, 0x41c0, BIT(14), 0x0);\n\trtw_write32_mask(rtwdev, 0x41cc, 0xf00, 0x0);\n\trtw_write32_mask(rtwdev, 0x41dc, BIT(14), 0x0);\n\n\trtw_write32_mask(rtwdev, 0x41b0, BIT(0), 0x0);\n\trtw_write32_mask(rtwdev, 0x41cc, BIT(0), 0x0);\n\trtw_write32_mask(rtwdev, 0x41b0, BIT(0), 0x1);\n\trtw_write32_mask(rtwdev, 0x41cc, BIT(0), 0x1);\n\n\trtw_write32_mask(rtwdev, 0x41b8, BIT(26) | BIT(25), 0x1);\n\trtw_write32_mask(rtwdev, 0x41d4, BIT(26) | BIT(25), 0x1);\n}\n\nstatic bool rtw8822c_dac_cal_restore_wait(struct rtw_dev *rtwdev,\n\t\t\t\t\t  u32 target_addr, u32 toggle_addr)\n{\n\tu32 cnt = 0;\n\n\tdo {\n\t\trtw_write32_mask(rtwdev, toggle_addr, BIT(26) | BIT(25), 0x0);\n\t\trtw_write32_mask(rtwdev, toggle_addr, BIT(26) | BIT(25), 0x2);\n\n\t\tif (rtw_read32_mask(rtwdev, target_addr, 0xf) == 0x6)\n\t\t\treturn true;\n\n\t} while (cnt++ < 100);\n\n\treturn false;\n}\n\nstatic bool rtw8822c_dac_cal_restore_path(struct rtw_dev *rtwdev, u8 path)\n{\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tu32 w_off = 0x1c;\n\tu32 r_off = 0x2c;\n\tu32 w_i, r_i, w_q, r_q;\n\tu32 value;\n\tu32 i;\n\n\tw_i = rtw8822c_get_path_write_addr(path) + 0xb0;\n\tr_i = rtw8822c_get_path_read_addr(path) + 0x08;\n\tw_q = rtw8822c_get_path_write_addr(path) + 0xb0 + w_off;\n\tr_q = rtw8822c_get_path_read_addr(path) + 0x08 + r_off;\n\n\tif (!rtw8822c_dac_cal_restore_wait(rtwdev, r_i, w_i + 0x8))\n\t\treturn false;\n\n\tfor (i = 0; i < DACK_MSBK_BACKUP_NUM; i++) {\n\t\trtw_write32_mask(rtwdev, w_i + 0x4, BIT(2), 0x0);\n\t\tvalue = dm_info->dack_msbk[path][0][i];\n\t\trtw_write32_mask(rtwdev, w_i + 0x4, 0xff8, value);\n\t\trtw_write32_mask(rtwdev, w_i, 0xf0000000, i);\n\t\trtw_write32_mask(rtwdev, w_i + 0x4, BIT(2), 0x1);\n\t}\n\n\trtw_write32_mask(rtwdev, w_i + 0x4, BIT(2), 0x0);\n\n\tif (!rtw8822c_dac_cal_restore_wait(rtwdev, r_q, w_q + 0x8))\n\t\treturn false;\n\n\tfor (i = 0; i < DACK_MSBK_BACKUP_NUM; i++) {\n\t\trtw_write32_mask(rtwdev, w_q + 0x4, BIT(2), 0x0);\n\t\tvalue = dm_info->dack_msbk[path][1][i];\n\t\trtw_write32_mask(rtwdev, w_q + 0x4, 0xff8, value);\n\t\trtw_write32_mask(rtwdev, w_q, 0xf0000000, i);\n\t\trtw_write32_mask(rtwdev, w_q + 0x4, BIT(2), 0x1);\n\t}\n\trtw_write32_mask(rtwdev, w_q + 0x4, BIT(2), 0x0);\n\n\trtw_write32_mask(rtwdev, w_i + 0x8, BIT(26) | BIT(25), 0x0);\n\trtw_write32_mask(rtwdev, w_q + 0x8, BIT(26) | BIT(25), 0x0);\n\trtw_write32_mask(rtwdev, w_i + 0x4, BIT(0), 0x0);\n\trtw_write32_mask(rtwdev, w_q + 0x4, BIT(0), 0x0);\n\n\treturn true;\n}\n\nstatic bool __rtw8822c_dac_cal_restore(struct rtw_dev *rtwdev)\n{\n\tif (!rtw8822c_dac_cal_restore_path(rtwdev, RF_PATH_A))\n\t\treturn false;\n\n\tif (!rtw8822c_dac_cal_restore_path(rtwdev, RF_PATH_B))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool rtw8822c_dac_cal_restore(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tu32 temp[3];\n\n\t \n\tif (dm_info->dack_msbk[RF_PATH_A][0][0] == 0 &&\n\t    dm_info->dack_msbk[RF_PATH_A][1][0] == 0 &&\n\t    dm_info->dack_msbk[RF_PATH_B][0][0] == 0 &&\n\t    dm_info->dack_msbk[RF_PATH_B][1][0] == 0)\n\t\treturn false;\n\n\ttemp[0] = rtw_read32(rtwdev, 0x1860);\n\ttemp[1] = rtw_read32(rtwdev, 0x4160);\n\ttemp[2] = rtw_read32(rtwdev, 0x9b4);\n\n\trtw8822c_dac_cal_restore_prepare(rtwdev);\n\tif (!check_hw_ready(rtwdev, 0x2808, 0x7fff80, 0xffff) ||\n\t    !check_hw_ready(rtwdev, 0x2834, 0x7fff80, 0xffff) ||\n\t    !check_hw_ready(rtwdev, 0x4508, 0x7fff80, 0xffff) ||\n\t    !check_hw_ready(rtwdev, 0x4534, 0x7fff80, 0xffff))\n\t\treturn false;\n\n\tif (!__rtw8822c_dac_cal_restore(rtwdev)) {\n\t\trtw_err(rtwdev, \"failed to restore dack vectors\\n\");\n\t\treturn false;\n\t}\n\n\trtw_write32_mask(rtwdev, 0x1830, BIT(30), 0x1);\n\trtw_write32_mask(rtwdev, 0x4130, BIT(30), 0x1);\n\trtw_write32(rtwdev, 0x1860, temp[0]);\n\trtw_write32(rtwdev, 0x4160, temp[1]);\n\trtw_write32_mask(rtwdev, 0x18b0, BIT(27), 0x1);\n\trtw_write32_mask(rtwdev, 0x18cc, BIT(27), 0x1);\n\trtw_write32_mask(rtwdev, 0x41b0, BIT(27), 0x1);\n\trtw_write32_mask(rtwdev, 0x41cc, BIT(27), 0x1);\n\trtw_write32(rtwdev, 0x9b4, temp[2]);\n\n\treturn true;\n}\n\nstatic void rtw8822c_rf_dac_cal(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_backup_info backup_rf[DACK_RF_8822C * DACK_PATH_8822C];\n\tstruct rtw_backup_info backup[DACK_REG_8822C];\n\tu32 ic = 0, qc = 0, i;\n\tu32 i_a = 0x0, q_a = 0x0, i_b = 0x0, q_b = 0x0;\n\tu32 ic_a = 0x0, qc_a = 0x0, ic_b = 0x0, qc_b = 0x0;\n\tu32 adc_ic_a = 0x0, adc_qc_a = 0x0, adc_ic_b = 0x0, adc_qc_b = 0x0;\n\n\tif (rtw8822c_dac_cal_restore(rtwdev))\n\t\treturn;\n\n\t \n\n\trtw8822c_dac_backup_reg(rtwdev, backup, backup_rf);\n\n\trtw8822c_dac_bb_setting(rtwdev);\n\n\t \n\trtw8822c_dac_cal_adc(rtwdev, RF_PATH_A, &adc_ic_a, &adc_qc_a);\n\tfor (i = 0; i < 10; i++) {\n\t\trtw8822c_dac_cal_step1(rtwdev, RF_PATH_A);\n\t\trtw8822c_dac_cal_step2(rtwdev, RF_PATH_A, &ic, &qc);\n\t\tic_a = ic;\n\t\tqc_a = qc;\n\n\t\trtw8822c_dac_cal_step3(rtwdev, RF_PATH_A, adc_ic_a, adc_qc_a,\n\t\t\t\t       &ic, &qc, &i_a, &q_a);\n\n\t\tif (ic < 5 && qc < 5)\n\t\t\tbreak;\n\t}\n\trtw8822c_dac_cal_step4(rtwdev, RF_PATH_A);\n\n\t \n\trtw8822c_dac_cal_adc(rtwdev, RF_PATH_B, &adc_ic_b, &adc_qc_b);\n\tfor (i = 0; i < 10; i++) {\n\t\trtw8822c_dac_cal_step1(rtwdev, RF_PATH_B);\n\t\trtw8822c_dac_cal_step2(rtwdev, RF_PATH_B, &ic, &qc);\n\t\tic_b = ic;\n\t\tqc_b = qc;\n\n\t\trtw8822c_dac_cal_step3(rtwdev, RF_PATH_B, adc_ic_b, adc_qc_b,\n\t\t\t\t       &ic, &qc, &i_b, &q_b);\n\n\t\tif (ic < 5 && qc < 5)\n\t\t\tbreak;\n\t}\n\trtw8822c_dac_cal_step4(rtwdev, RF_PATH_B);\n\n\trtw_write32(rtwdev, 0x1b00, 0x00000008);\n\trtw_write32_mask(rtwdev, 0x4130, BIT(30), 0x1);\n\trtw_write8(rtwdev, 0x1bcc, 0x0);\n\trtw_write32(rtwdev, 0x1b00, 0x0000000a);\n\trtw_write8(rtwdev, 0x1bcc, 0x0);\n\n\trtw8822c_dac_restore_reg(rtwdev, backup, backup_rf);\n\n\t \n\trtw8822c_dac_cal_backup(rtwdev);\n\n\trtw_dbg(rtwdev, RTW_DBG_RFK, \"[DACK] path A: ic=0x%x, qc=0x%x\\n\", ic_a, qc_a);\n\trtw_dbg(rtwdev, RTW_DBG_RFK, \"[DACK] path B: ic=0x%x, qc=0x%x\\n\", ic_b, qc_b);\n\trtw_dbg(rtwdev, RTW_DBG_RFK, \"[DACK] path A: i=0x%x, q=0x%x\\n\", i_a, q_a);\n\trtw_dbg(rtwdev, RTW_DBG_RFK, \"[DACK] path B: i=0x%x, q=0x%x\\n\", i_b, q_b);\n}\n\nstatic void rtw8822c_rf_x2_check(struct rtw_dev *rtwdev)\n{\n\tu8 x2k_busy;\n\n\tmdelay(1);\n\tx2k_busy = rtw_read_rf(rtwdev, RF_PATH_A, 0xb8, BIT(15));\n\tif (x2k_busy == 1) {\n\t\trtw_write_rf(rtwdev, RF_PATH_A, 0xb8, RFREG_MASK, 0xC4440);\n\t\trtw_write_rf(rtwdev, RF_PATH_A, 0xba, RFREG_MASK, 0x6840D);\n\t\trtw_write_rf(rtwdev, RF_PATH_A, 0xb8, RFREG_MASK, 0x80440);\n\t\tmdelay(1);\n\t}\n}\n\nstatic void rtw8822c_set_power_trim(struct rtw_dev *rtwdev, s8 bb_gain[2][8])\n{\n#define RF_SET_POWER_TRIM(_path, _seq, _idx)\t\t\t\t\t\\\n\t\tdo {\t\t\t\t\t\t\t\t\\\n\t\t\trtw_write_rf(rtwdev, _path, 0x33, RFREG_MASK, _seq);\t\\\n\t\t\trtw_write_rf(rtwdev, _path, 0x3f, RFREG_MASK,\t\t\\\n\t\t\t\t     bb_gain[_path][_idx]);\t\t\t\\\n\t\t} while (0)\n\tu8 path;\n\n\tfor (path = 0; path < rtwdev->hal.rf_path_num; path++) {\n\t\trtw_write_rf(rtwdev, path, 0xee, BIT(19), 1);\n\t\tRF_SET_POWER_TRIM(path, 0x0, 0);\n\t\tRF_SET_POWER_TRIM(path, 0x1, 1);\n\t\tRF_SET_POWER_TRIM(path, 0x2, 2);\n\t\tRF_SET_POWER_TRIM(path, 0x3, 2);\n\t\tRF_SET_POWER_TRIM(path, 0x4, 3);\n\t\tRF_SET_POWER_TRIM(path, 0x5, 4);\n\t\tRF_SET_POWER_TRIM(path, 0x6, 5);\n\t\tRF_SET_POWER_TRIM(path, 0x7, 6);\n\t\tRF_SET_POWER_TRIM(path, 0x8, 7);\n\t\tRF_SET_POWER_TRIM(path, 0x9, 3);\n\t\tRF_SET_POWER_TRIM(path, 0xa, 4);\n\t\tRF_SET_POWER_TRIM(path, 0xb, 5);\n\t\tRF_SET_POWER_TRIM(path, 0xc, 6);\n\t\tRF_SET_POWER_TRIM(path, 0xd, 7);\n\t\tRF_SET_POWER_TRIM(path, 0xe, 7);\n\t\trtw_write_rf(rtwdev, path, 0xee, BIT(19), 0);\n\t}\n#undef RF_SET_POWER_TRIM\n}\n\nstatic void rtw8822c_power_trim(struct rtw_dev *rtwdev)\n{\n\tu8 pg_pwr = 0xff, i, path, idx;\n\ts8 bb_gain[2][8] = {};\n\tu16 rf_efuse_2g[3] = {PPG_2GL_TXAB, PPG_2GM_TXAB, PPG_2GH_TXAB};\n\tu16 rf_efuse_5g[2][5] = {{PPG_5GL1_TXA, PPG_5GL2_TXA, PPG_5GM1_TXA,\n\t\t\t\t  PPG_5GM2_TXA, PPG_5GH1_TXA},\n\t\t\t\t {PPG_5GL1_TXB, PPG_5GL2_TXB, PPG_5GM1_TXB,\n\t\t\t\t  PPG_5GM2_TXB, PPG_5GH1_TXB} };\n\tbool set = false;\n\n\tfor (i = 0; i < ARRAY_SIZE(rf_efuse_2g); i++) {\n\t\trtw_read8_physical_efuse(rtwdev, rf_efuse_2g[i], &pg_pwr);\n\t\tif (pg_pwr == EFUSE_READ_FAIL)\n\t\t\tcontinue;\n\t\tset = true;\n\t\tbb_gain[RF_PATH_A][i] = FIELD_GET(PPG_2G_A_MASK, pg_pwr);\n\t\tbb_gain[RF_PATH_B][i] = FIELD_GET(PPG_2G_B_MASK, pg_pwr);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(rf_efuse_5g[0]); i++) {\n\t\tfor (path = 0; path < rtwdev->hal.rf_path_num; path++) {\n\t\t\trtw_read8_physical_efuse(rtwdev, rf_efuse_5g[path][i],\n\t\t\t\t\t\t &pg_pwr);\n\t\t\tif (pg_pwr == EFUSE_READ_FAIL)\n\t\t\t\tcontinue;\n\t\t\tset = true;\n\t\t\tidx = i + ARRAY_SIZE(rf_efuse_2g);\n\t\t\tbb_gain[path][idx] = FIELD_GET(PPG_5G_MASK, pg_pwr);\n\t\t}\n\t}\n\tif (set)\n\t\trtw8822c_set_power_trim(rtwdev, bb_gain);\n\n\trtw_write32_mask(rtwdev, REG_DIS_DPD, DIS_DPD_MASK, DIS_DPD_RATEALL);\n}\n\nstatic void rtw8822c_thermal_trim(struct rtw_dev *rtwdev)\n{\n\tu16 rf_efuse[2] = {PPG_THERMAL_A, PPG_THERMAL_B};\n\tu8 pg_therm = 0xff, thermal[2] = {0}, path;\n\n\tfor (path = 0; path < rtwdev->hal.rf_path_num; path++) {\n\t\trtw_read8_physical_efuse(rtwdev, rf_efuse[path], &pg_therm);\n\t\tif (pg_therm == EFUSE_READ_FAIL)\n\t\t\treturn;\n\t\t \n\t\tthermal[path] = FIELD_GET(GENMASK(3, 1), pg_therm);\n\t\tthermal[path] |= FIELD_PREP(BIT(3), pg_therm & BIT(0));\n\t\trtw_write_rf(rtwdev, path, 0x43, RF_THEMAL_MASK, thermal[path]);\n\t}\n}\n\nstatic void rtw8822c_pa_bias(struct rtw_dev *rtwdev)\n{\n\tu16 rf_efuse_2g[2] = {PPG_PABIAS_2GA, PPG_PABIAS_2GB};\n\tu16 rf_efuse_5g[2] = {PPG_PABIAS_5GA, PPG_PABIAS_5GB};\n\tu8 pg_pa_bias = 0xff, path;\n\n\tfor (path = 0; path < rtwdev->hal.rf_path_num; path++) {\n\t\trtw_read8_physical_efuse(rtwdev, rf_efuse_2g[path],\n\t\t\t\t\t &pg_pa_bias);\n\t\tif (pg_pa_bias == EFUSE_READ_FAIL)\n\t\t\treturn;\n\t\tpg_pa_bias = FIELD_GET(PPG_PABIAS_MASK, pg_pa_bias);\n\t\trtw_write_rf(rtwdev, path, RF_PA, RF_PABIAS_2G_MASK, pg_pa_bias);\n\t}\n\tfor (path = 0; path < rtwdev->hal.rf_path_num; path++) {\n\t\trtw_read8_physical_efuse(rtwdev, rf_efuse_5g[path],\n\t\t\t\t\t &pg_pa_bias);\n\t\tpg_pa_bias = FIELD_GET(PPG_PABIAS_MASK, pg_pa_bias);\n\t\trtw_write_rf(rtwdev, path, RF_PA, RF_PABIAS_5G_MASK, pg_pa_bias);\n\t}\n}\n\nstatic void rtw8822c_rfk_handshake(struct rtw_dev *rtwdev, bool is_before_k)\n{\n\tstruct rtw_dm_info *dm = &rtwdev->dm_info;\n\tu8 u1b_tmp;\n\tu8 u4b_tmp;\n\tint ret;\n\n\tif (is_before_k) {\n\t\trtw_dbg(rtwdev, RTW_DBG_RFK,\n\t\t\t\"[RFK] WiFi / BT RFK handshake start!!\\n\");\n\n\t\tif (!dm->is_bt_iqk_timeout) {\n\t\t\tret = read_poll_timeout(rtw_read32_mask, u4b_tmp,\n\t\t\t\t\t\tu4b_tmp == 0, 20, 600000, false,\n\t\t\t\t\t\trtwdev, REG_PMC_DBG_CTRL1,\n\t\t\t\t\t\tBITS_PMC_BT_IQK_STS);\n\t\t\tif (ret) {\n\t\t\t\trtw_dbg(rtwdev, RTW_DBG_RFK,\n\t\t\t\t\t\"[RFK] Wait BT IQK finish timeout!!\\n\");\n\t\t\t\tdm->is_bt_iqk_timeout = true;\n\t\t\t}\n\t\t}\n\n\t\trtw_fw_inform_rfk_status(rtwdev, true);\n\n\t\tret = read_poll_timeout(rtw_read8_mask, u1b_tmp,\n\t\t\t\t\tu1b_tmp == 1, 20, 100000, false,\n\t\t\t\t\trtwdev, REG_ARFR4, BIT_WL_RFK);\n\t\tif (ret)\n\t\t\trtw_dbg(rtwdev, RTW_DBG_RFK,\n\t\t\t\t\"[RFK] Send WiFi RFK start H2C cmd FAIL!!\\n\");\n\t} else {\n\t\trtw_fw_inform_rfk_status(rtwdev, false);\n\t\tret = read_poll_timeout(rtw_read8_mask, u1b_tmp,\n\t\t\t\t\tu1b_tmp == 1, 20, 100000, false,\n\t\t\t\t\trtwdev, REG_ARFR4,\n\t\t\t\t\tBIT_WL_RFK);\n\t\tif (ret)\n\t\t\trtw_dbg(rtwdev, RTW_DBG_RFK,\n\t\t\t\t\"[RFK] Send WiFi RFK finish H2C cmd FAIL!!\\n\");\n\n\t\trtw_dbg(rtwdev, RTW_DBG_RFK,\n\t\t\t\"[RFK] WiFi / BT RFK handshake finish!!\\n\");\n\t}\n}\n\nstatic void rtw8822c_rfk_power_save(struct rtw_dev *rtwdev,\n\t\t\t\t    bool is_power_save)\n{\n\tu8 path;\n\n\tfor (path = 0; path < rtwdev->hal.rf_path_num; path++) {\n\t\trtw_write32_mask(rtwdev, REG_NCTL0, BIT_SEL_PATH, path);\n\t\trtw_write32_mask(rtwdev, REG_DPD_CTL1_S0, BIT_PS_EN,\n\t\t\t\t is_power_save ? 0 : 1);\n\t}\n}\n\nstatic void rtw8822c_txgapk_backup_bb_reg(struct rtw_dev *rtwdev, const u32 reg[],\n\t\t\t\t\t  u32 reg_backup[], u32 reg_num)\n{\n\tu32 i;\n\n\tfor (i = 0; i < reg_num; i++) {\n\t\treg_backup[i] = rtw_read32(rtwdev, reg[i]);\n\n\t\trtw_dbg(rtwdev, RTW_DBG_RFK, \"[TXGAPK] Backup BB 0x%x = 0x%x\\n\",\n\t\t\treg[i], reg_backup[i]);\n\t}\n}\n\nstatic void rtw8822c_txgapk_reload_bb_reg(struct rtw_dev *rtwdev,\n\t\t\t\t\t  const u32 reg[], u32 reg_backup[],\n\t\t\t\t\t  u32 reg_num)\n{\n\tu32 i;\n\n\tfor (i = 0; i < reg_num; i++) {\n\t\trtw_write32(rtwdev, reg[i], reg_backup[i]);\n\t\trtw_dbg(rtwdev, RTW_DBG_RFK, \"[TXGAPK] Reload BB 0x%x = 0x%x\\n\",\n\t\t\treg[i], reg_backup[i]);\n\t}\n}\n\nstatic bool check_rf_status(struct rtw_dev *rtwdev, u8 status)\n{\n\tu8 reg_rf0_a, reg_rf0_b;\n\n\treg_rf0_a = (u8)rtw_read_rf(rtwdev, RF_PATH_A,\n\t\t\t\t    RF_MODE_TRXAGC, BIT_RF_MODE);\n\treg_rf0_b = (u8)rtw_read_rf(rtwdev, RF_PATH_B,\n\t\t\t\t    RF_MODE_TRXAGC, BIT_RF_MODE);\n\n\tif (reg_rf0_a == status || reg_rf0_b == status)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void rtw8822c_txgapk_tx_pause(struct rtw_dev *rtwdev)\n{\n\tbool status;\n\tint ret;\n\n\trtw_write8(rtwdev, REG_TXPAUSE, BIT_AC_QUEUE);\n\trtw_write32_mask(rtwdev, REG_TX_FIFO, BIT_STOP_TX, 0x2);\n\n\tret = read_poll_timeout_atomic(check_rf_status, status, status,\n\t\t\t\t       2, 5000, false, rtwdev, 2);\n\tif (ret)\n\t\trtw_warn(rtwdev, \"failed to pause TX\\n\");\n\n\trtw_dbg(rtwdev, RTW_DBG_RFK, \"[TXGAPK] Tx pause!!\\n\");\n}\n\nstatic void rtw8822c_txgapk_bb_dpk(struct rtw_dev *rtwdev, u8 path)\n{\n\trtw_dbg(rtwdev, RTW_DBG_RFK, \"[TXGAPK] ======>%s\\n\", __func__);\n\n\trtw_write32_mask(rtwdev, REG_ENFN, BIT_IQK_DPK_EN, 0x1);\n\trtw_write32_mask(rtwdev, REG_CH_DELAY_EXTR2,\n\t\t\t BIT_IQK_DPK_CLOCK_SRC, 0x1);\n\trtw_write32_mask(rtwdev, REG_CH_DELAY_EXTR2,\n\t\t\t BIT_IQK_DPK_RESET_SRC, 0x1);\n\trtw_write32_mask(rtwdev, REG_CH_DELAY_EXTR2, BIT_EN_IOQ_IQK_DPK, 0x1);\n\trtw_write32_mask(rtwdev, REG_CH_DELAY_EXTR2, BIT_TST_IQK2SET_SRC, 0x0);\n\trtw_write32_mask(rtwdev, REG_CCA_OFF, BIT_CCA_ON_BY_PW, 0x1ff);\n\n\tif (path == RF_PATH_A) {\n\t\trtw_write32_mask(rtwdev, REG_RFTXEN_GCK_A,\n\t\t\t\t BIT_RFTXEN_GCK_FORCE_ON, 0x1);\n\t\trtw_write32_mask(rtwdev, REG_3WIRE, BIT_DIS_SHARERX_TXGAT, 0x1);\n\t\trtw_write32_mask(rtwdev, REG_DIS_SHARE_RX_A,\n\t\t\t\t BIT_TX_SCALE_0DB, 0x1);\n\t\trtw_write32_mask(rtwdev, REG_3WIRE, BIT_3WIRE_EN, 0x0);\n\t} else if (path == RF_PATH_B) {\n\t\trtw_write32_mask(rtwdev, REG_RFTXEN_GCK_B,\n\t\t\t\t BIT_RFTXEN_GCK_FORCE_ON, 0x1);\n\t\trtw_write32_mask(rtwdev, REG_3WIRE2,\n\t\t\t\t BIT_DIS_SHARERX_TXGAT, 0x1);\n\t\trtw_write32_mask(rtwdev, REG_DIS_SHARE_RX_B,\n\t\t\t\t BIT_TX_SCALE_0DB, 0x1);\n\t\trtw_write32_mask(rtwdev, REG_3WIRE2, BIT_3WIRE_EN, 0x0);\n\t}\n\trtw_write32_mask(rtwdev, REG_CCKSB, BIT_BBMODE, 0x2);\n}\n\nstatic void rtw8822c_txgapk_afe_dpk(struct rtw_dev *rtwdev, u8 path)\n{\n\tu32 reg;\n\n\trtw_dbg(rtwdev, RTW_DBG_RFK, \"[TXGAPK] ======>%s\\n\", __func__);\n\n\tif (path == RF_PATH_A) {\n\t\treg = REG_ANAPAR_A;\n\t} else if (path == RF_PATH_B) {\n\t\treg = REG_ANAPAR_B;\n\t} else {\n\t\trtw_err(rtwdev, \"[TXGAPK] unknown path %d!!\\n\", path);\n\t\treturn;\n\t}\n\n\trtw_write32_mask(rtwdev, REG_IQK_CTRL, MASKDWORD, MASKDWORD);\n\trtw_write32_mask(rtwdev, reg, MASKDWORD, 0x700f0001);\n\trtw_write32_mask(rtwdev, reg, MASKDWORD, 0x700f0001);\n\trtw_write32_mask(rtwdev, reg, MASKDWORD, 0x701f0001);\n\trtw_write32_mask(rtwdev, reg, MASKDWORD, 0x702f0001);\n\trtw_write32_mask(rtwdev, reg, MASKDWORD, 0x703f0001);\n\trtw_write32_mask(rtwdev, reg, MASKDWORD, 0x704f0001);\n\trtw_write32_mask(rtwdev, reg, MASKDWORD, 0x705f0001);\n\trtw_write32_mask(rtwdev, reg, MASKDWORD, 0x706f0001);\n\trtw_write32_mask(rtwdev, reg, MASKDWORD, 0x707f0001);\n\trtw_write32_mask(rtwdev, reg, MASKDWORD, 0x708f0001);\n\trtw_write32_mask(rtwdev, reg, MASKDWORD, 0x709f0001);\n\trtw_write32_mask(rtwdev, reg, MASKDWORD, 0x70af0001);\n\trtw_write32_mask(rtwdev, reg, MASKDWORD, 0x70bf0001);\n\trtw_write32_mask(rtwdev, reg, MASKDWORD, 0x70cf0001);\n\trtw_write32_mask(rtwdev, reg, MASKDWORD, 0x70df0001);\n\trtw_write32_mask(rtwdev, reg, MASKDWORD, 0x70ef0001);\n\trtw_write32_mask(rtwdev, reg, MASKDWORD, 0x70ff0001);\n\trtw_write32_mask(rtwdev, reg, MASKDWORD, 0x70ff0001);\n}\n\nstatic void rtw8822c_txgapk_afe_dpk_restore(struct rtw_dev *rtwdev, u8 path)\n{\n\tu32 reg;\n\n\trtw_dbg(rtwdev, RTW_DBG_RFK, \"[TXGAPK] ======>%s\\n\", __func__);\n\n\tif (path == RF_PATH_A) {\n\t\treg = REG_ANAPAR_A;\n\t} else if (path == RF_PATH_B) {\n\t\treg = REG_ANAPAR_B;\n\t} else {\n\t\trtw_err(rtwdev, \"[TXGAPK] unknown path %d!!\\n\", path);\n\t\treturn;\n\t}\n\trtw_write32_mask(rtwdev, REG_IQK_CTRL, MASKDWORD, 0xffa1005e);\n\trtw_write32_mask(rtwdev, reg, MASKDWORD, 0x700b8041);\n\trtw_write32_mask(rtwdev, reg, MASKDWORD, 0x70144041);\n\trtw_write32_mask(rtwdev, reg, MASKDWORD, 0x70244041);\n\trtw_write32_mask(rtwdev, reg, MASKDWORD, 0x70344041);\n\trtw_write32_mask(rtwdev, reg, MASKDWORD, 0x70444041);\n\trtw_write32_mask(rtwdev, reg, MASKDWORD, 0x705b8041);\n\trtw_write32_mask(rtwdev, reg, MASKDWORD, 0x70644041);\n\trtw_write32_mask(rtwdev, reg, MASKDWORD, 0x707b8041);\n\trtw_write32_mask(rtwdev, reg, MASKDWORD, 0x708b8041);\n\trtw_write32_mask(rtwdev, reg, MASKDWORD, 0x709b8041);\n\trtw_write32_mask(rtwdev, reg, MASKDWORD, 0x70ab8041);\n\trtw_write32_mask(rtwdev, reg, MASKDWORD, 0x70bb8041);\n\trtw_write32_mask(rtwdev, reg, MASKDWORD, 0x70cb8041);\n\trtw_write32_mask(rtwdev, reg, MASKDWORD, 0x70db8041);\n\trtw_write32_mask(rtwdev, reg, MASKDWORD, 0x70eb8041);\n\trtw_write32_mask(rtwdev, reg, MASKDWORD, 0x70fb8041);\n}\n\nstatic void rtw8822c_txgapk_bb_dpk_restore(struct rtw_dev *rtwdev, u8 path)\n{\n\trtw_dbg(rtwdev, RTW_DBG_RFK, \"[TXGAPK] ======>%s\\n\", __func__);\n\n\trtw_write_rf(rtwdev, path, RF_DEBUG, BIT_DE_TX_GAIN, 0x0);\n\trtw_write_rf(rtwdev, path, RF_DIS_BYPASS_TXBB, BIT_TIA_BYPASS, 0x0);\n\trtw_write_rf(rtwdev, path, RF_DIS_BYPASS_TXBB, BIT_TXBB, 0x0);\n\n\trtw_write32_mask(rtwdev, REG_NCTL0, BIT_SEL_PATH, 0x0);\n\trtw_write32_mask(rtwdev, REG_IQK_CTL1, BIT_TX_CFIR, 0x0);\n\trtw_write32_mask(rtwdev, REG_SINGLE_TONE_SW, BIT_IRQ_TEST_MODE, 0x0);\n\trtw_write32_mask(rtwdev, REG_R_CONFIG, MASKBYTE0, 0x00);\n\trtw_write32_mask(rtwdev, REG_NCTL0, BIT_SEL_PATH, 0x1);\n\trtw_write32_mask(rtwdev, REG_IQK_CTL1, BIT_TX_CFIR, 0x0);\n\trtw_write32_mask(rtwdev, REG_SINGLE_TONE_SW, BIT_IRQ_TEST_MODE, 0x0);\n\trtw_write32_mask(rtwdev, REG_R_CONFIG, MASKBYTE0, 0x00);\n\trtw_write32_mask(rtwdev, REG_NCTL0, BIT_SEL_PATH, 0x0);\n\trtw_write32_mask(rtwdev, REG_CCA_OFF, BIT_CCA_ON_BY_PW, 0x0);\n\n\tif (path == RF_PATH_A) {\n\t\trtw_write32_mask(rtwdev, REG_RFTXEN_GCK_A,\n\t\t\t\t BIT_RFTXEN_GCK_FORCE_ON, 0x0);\n\t\trtw_write32_mask(rtwdev, REG_3WIRE, BIT_DIS_SHARERX_TXGAT, 0x0);\n\t\trtw_write32_mask(rtwdev, REG_DIS_SHARE_RX_A,\n\t\t\t\t BIT_TX_SCALE_0DB, 0x0);\n\t\trtw_write32_mask(rtwdev, REG_3WIRE, BIT_3WIRE_EN, 0x3);\n\t} else if (path == RF_PATH_B) {\n\t\trtw_write32_mask(rtwdev, REG_RFTXEN_GCK_B,\n\t\t\t\t BIT_RFTXEN_GCK_FORCE_ON, 0x0);\n\t\trtw_write32_mask(rtwdev, REG_3WIRE2,\n\t\t\t\t BIT_DIS_SHARERX_TXGAT, 0x0);\n\t\trtw_write32_mask(rtwdev, REG_DIS_SHARE_RX_B,\n\t\t\t\t BIT_TX_SCALE_0DB, 0x0);\n\t\trtw_write32_mask(rtwdev, REG_3WIRE2, BIT_3WIRE_EN, 0x3);\n\t}\n\n\trtw_write32_mask(rtwdev, REG_CCKSB, BIT_BBMODE, 0x0);\n\trtw_write32_mask(rtwdev, REG_IQK_CTL1, BIT_CFIR_EN, 0x5);\n}\n\nstatic bool _rtw8822c_txgapk_gain_valid(struct rtw_dev *rtwdev, u32 gain)\n{\n\tif ((FIELD_GET(BIT_GAIN_TX_PAD_H, gain) >= 0xc) &&\n\t    (FIELD_GET(BIT_GAIN_TX_PAD_L, gain) >= 0xe))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void _rtw8822c_txgapk_write_gain_bb_table(struct rtw_dev *rtwdev,\n\t\t\t\t\t\t u8 band, u8 path)\n{\n\tstruct rtw_gapk_info *txgapk = &rtwdev->dm_info.gapk;\n\tu32 v, tmp_3f = 0;\n\tu8 gain, check_txgain;\n\n\trtw_write32_mask(rtwdev, REG_NCTL0, BIT_SEL_PATH, path);\n\n\tswitch (band) {\n\tcase RF_BAND_2G_OFDM:\n\t\trtw_write32_mask(rtwdev, REG_TABLE_SEL, BIT_Q_GAIN_SEL, 0x0);\n\t\tbreak;\n\tcase RF_BAND_5G_L:\n\t\trtw_write32_mask(rtwdev, REG_TABLE_SEL, BIT_Q_GAIN_SEL, 0x2);\n\t\tbreak;\n\tcase RF_BAND_5G_M:\n\t\trtw_write32_mask(rtwdev, REG_TABLE_SEL, BIT_Q_GAIN_SEL, 0x3);\n\t\tbreak;\n\tcase RF_BAND_5G_H:\n\t\trtw_write32_mask(rtwdev, REG_TABLE_SEL, BIT_Q_GAIN_SEL, 0x4);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\trtw_write32_mask(rtwdev, REG_TX_GAIN_SET, MASKBYTE0, 0x88);\n\n\tcheck_txgain = 0;\n\tfor (gain = 0; gain < RF_GAIN_NUM; gain++) {\n\t\tv = txgapk->rf3f_bp[band][gain][path];\n\t\tif (_rtw8822c_txgapk_gain_valid(rtwdev, v)) {\n\t\t\tif (!check_txgain) {\n\t\t\t\ttmp_3f = txgapk->rf3f_bp[band][gain][path];\n\t\t\t\tcheck_txgain = 1;\n\t\t\t}\n\t\t\trtw_dbg(rtwdev, RTW_DBG_RFK,\n\t\t\t\t\"[TXGAPK] tx_gain=0x%03X >= 0xCEX\\n\",\n\t\t\t\ttxgapk->rf3f_bp[band][gain][path]);\n\t\t} else {\n\t\t\ttmp_3f = txgapk->rf3f_bp[band][gain][path];\n\t\t}\n\n\t\trtw_write32_mask(rtwdev, REG_TABLE_SEL, BIT_Q_GAIN, tmp_3f);\n\t\trtw_write32_mask(rtwdev, REG_TABLE_SEL, BIT_I_GAIN, gain);\n\t\trtw_write32_mask(rtwdev, REG_TABLE_SEL, BIT_GAIN_RST, 0x1);\n\t\trtw_write32_mask(rtwdev, REG_TABLE_SEL, BIT_GAIN_RST, 0x0);\n\n\t\trtw_dbg(rtwdev, RTW_DBG_RFK,\n\t\t\t\"[TXGAPK] Band=%d 0x1b98[11:0]=0x%03X path=%d\\n\",\n\t\t\tband, tmp_3f, path);\n\t}\n}\n\nstatic void rtw8822c_txgapk_write_gain_bb_table(struct rtw_dev *rtwdev)\n{\n\tu8 path, band;\n\n\trtw_dbg(rtwdev, RTW_DBG_RFK, \"[TXGAPK] ======>%s channel=%d\\n\",\n\t\t__func__, rtwdev->dm_info.gapk.channel);\n\n\tfor (band = 0; band < RF_BAND_MAX; band++) {\n\t\tfor (path = 0; path < rtwdev->hal.rf_path_num; path++) {\n\t\t\t_rtw8822c_txgapk_write_gain_bb_table(rtwdev,\n\t\t\t\t\t\t\t     band, path);\n\t\t}\n\t}\n}\n\nstatic void rtw8822c_txgapk_read_offset(struct rtw_dev *rtwdev, u8 path)\n{\n\tstatic const u32 cfg1_1b00[2] = {0x00000d18, 0x00000d2a};\n\tstatic const u32 cfg2_1b00[2] = {0x00000d19, 0x00000d2b};\n\tstatic const u32 set_pi[2] = {REG_RSV_CTRL, REG_WLRF1};\n\tstatic const u32 path_setting[2] = {REG_ORITXCODE, REG_ORITXCODE2};\n\tstruct rtw_gapk_info *txgapk = &rtwdev->dm_info.gapk;\n\tu8 channel = txgapk->channel;\n\tu32 val;\n\tint i;\n\n\tif (path >= ARRAY_SIZE(cfg1_1b00) ||\n\t    path >= ARRAY_SIZE(cfg2_1b00) ||\n\t    path >= ARRAY_SIZE(set_pi) ||\n\t    path >= ARRAY_SIZE(path_setting)) {\n\t\trtw_warn(rtwdev, \"[TXGAPK] wrong path %d\\n\", path);\n\t\treturn;\n\t}\n\n\trtw_write32_mask(rtwdev, REG_ANTMAP0, BIT_ANT_PATH, path + 1);\n\trtw_write32_mask(rtwdev, REG_TXLGMAP, MASKDWORD, 0xe4e40000);\n\trtw_write32_mask(rtwdev, REG_TXANTSEG, BIT_ANTSEG, 0x3);\n\trtw_write32_mask(rtwdev, path_setting[path], MASK20BITS, 0x33312);\n\trtw_write32_mask(rtwdev, path_setting[path], BIT_PATH_EN, 0x1);\n\trtw_write32_mask(rtwdev, set_pi[path], BITS_RFC_DIRECT, 0x0);\n\trtw_write_rf(rtwdev, path, RF_LUTDBG, BIT_TXA_TANK, 0x1);\n\trtw_write_rf(rtwdev, path, RF_IDAC, BIT_TX_MODE, 0x820);\n\trtw_write32_mask(rtwdev, REG_NCTL0, BIT_SEL_PATH, path);\n\trtw_write32_mask(rtwdev, REG_IQKSTAT, MASKBYTE0, 0x0);\n\n\trtw_write32_mask(rtwdev, REG_TX_TONE_IDX, MASKBYTE0, 0x018);\n\tfsleep(1000);\n\tif (channel >= 1 && channel <= 14)\n\t\trtw_write32_mask(rtwdev, REG_R_CONFIG, MASKBYTE0, BIT_2G_SWING);\n\telse\n\t\trtw_write32_mask(rtwdev, REG_R_CONFIG, MASKBYTE0, BIT_5G_SWING);\n\tfsleep(1000);\n\n\trtw_write32_mask(rtwdev, REG_NCTL0, MASKDWORD, cfg1_1b00[path]);\n\trtw_write32_mask(rtwdev, REG_NCTL0, MASKDWORD, cfg2_1b00[path]);\n\n\tread_poll_timeout(rtw_read32_mask, val,\n\t\t\t  val == 0x55, 1000, 100000, false,\n\t\t\t  rtwdev, REG_RPT_CIP, BIT_RPT_CIP_STATUS);\n\n\trtw_write32_mask(rtwdev, set_pi[path], BITS_RFC_DIRECT, 0x2);\n\trtw_write32_mask(rtwdev, REG_NCTL0, BIT_SEL_PATH, path);\n\trtw_write32_mask(rtwdev, REG_RXSRAM_CTL, BIT_RPT_EN, 0x1);\n\trtw_write32_mask(rtwdev, REG_RXSRAM_CTL, BIT_RPT_SEL, 0x12);\n\trtw_write32_mask(rtwdev, REG_TX_GAIN_SET, BIT_GAPK_RPT_IDX, 0x3);\n\tval = rtw_read32(rtwdev, REG_STAT_RPT);\n\n\ttxgapk->offset[0][path] = (s8)FIELD_GET(BIT_GAPK_RPT0, val);\n\ttxgapk->offset[1][path] = (s8)FIELD_GET(BIT_GAPK_RPT1, val);\n\ttxgapk->offset[2][path] = (s8)FIELD_GET(BIT_GAPK_RPT2, val);\n\ttxgapk->offset[3][path] = (s8)FIELD_GET(BIT_GAPK_RPT3, val);\n\ttxgapk->offset[4][path] = (s8)FIELD_GET(BIT_GAPK_RPT4, val);\n\ttxgapk->offset[5][path] = (s8)FIELD_GET(BIT_GAPK_RPT5, val);\n\ttxgapk->offset[6][path] = (s8)FIELD_GET(BIT_GAPK_RPT6, val);\n\ttxgapk->offset[7][path] = (s8)FIELD_GET(BIT_GAPK_RPT7, val);\n\n\trtw_write32_mask(rtwdev, REG_TX_GAIN_SET, BIT_GAPK_RPT_IDX, 0x4);\n\tval = rtw_read32(rtwdev, REG_STAT_RPT);\n\n\ttxgapk->offset[8][path] = (s8)FIELD_GET(BIT_GAPK_RPT0, val);\n\ttxgapk->offset[9][path] = (s8)FIELD_GET(BIT_GAPK_RPT1, val);\n\n\tfor (i = 0; i < RF_HW_OFFSET_NUM; i++)\n\t\tif (txgapk->offset[i][path] & BIT(3))\n\t\t\ttxgapk->offset[i][path] = txgapk->offset[i][path] |\n\t\t\t\t\t\t  0xf0;\n\tfor (i = 0; i < RF_HW_OFFSET_NUM; i++)\n\t\trtw_dbg(rtwdev, RTW_DBG_RFK,\n\t\t\t\"[TXGAPK] offset %d %d path=%d\\n\",\n\t\t\ttxgapk->offset[i][path], i, path);\n}\n\nstatic void rtw8822c_txgapk_calculate_offset(struct rtw_dev *rtwdev, u8 path)\n{\n\tstatic const u32 bb_reg[] = {REG_ANTMAP0, REG_TXLGMAP, REG_TXANTSEG,\n\t\t\t\t     REG_ORITXCODE, REG_ORITXCODE2};\n\tstruct rtw_gapk_info *txgapk = &rtwdev->dm_info.gapk;\n\tu8 channel = txgapk->channel;\n\tu32 reg_backup[ARRAY_SIZE(bb_reg)] = {0};\n\n\trtw_dbg(rtwdev, RTW_DBG_RFK, \"[TXGAPK] ======>%s channel=%d\\n\",\n\t\t__func__, channel);\n\n\trtw8822c_txgapk_backup_bb_reg(rtwdev, bb_reg,\n\t\t\t\t      reg_backup, ARRAY_SIZE(bb_reg));\n\n\tif (channel >= 1 && channel <= 14) {\n\t\trtw_write32_mask(rtwdev,\n\t\t\t\t REG_SINGLE_TONE_SW, BIT_IRQ_TEST_MODE, 0x0);\n\t\trtw_write32_mask(rtwdev, REG_NCTL0, BIT_SEL_PATH, path);\n\t\trtw_write32_mask(rtwdev, REG_R_CONFIG, BIT_IQ_SWITCH, 0x3f);\n\t\trtw_write32_mask(rtwdev, REG_IQK_CTL1, BIT_TX_CFIR, 0x0);\n\t\trtw_write_rf(rtwdev, path, RF_DEBUG, BIT_DE_TX_GAIN, 0x1);\n\t\trtw_write_rf(rtwdev, path, RF_MODE_TRXAGC, RFREG_MASK, 0x5000f);\n\t\trtw_write_rf(rtwdev, path, RF_TX_GAIN_OFFSET, BIT_RF_GAIN, 0x0);\n\t\trtw_write_rf(rtwdev, path, RF_RXG_GAIN, BIT_RXG_GAIN, 0x1);\n\t\trtw_write_rf(rtwdev, path, RF_MODE_TRXAGC, BIT_RXAGC, 0x0f);\n\t\trtw_write_rf(rtwdev, path, RF_DEBUG, BIT_DE_TRXBW, 0x1);\n\t\trtw_write_rf(rtwdev, path, RF_BW_TRXBB, BIT_BW_TXBB, 0x1);\n\t\trtw_write_rf(rtwdev, path, RF_BW_TRXBB, BIT_BW_RXBB, 0x0);\n\t\trtw_write_rf(rtwdev, path, RF_EXT_TIA_BW, BIT_PW_EXT_TIA, 0x1);\n\n\t\trtw_write32_mask(rtwdev, REG_IQKSTAT, MASKBYTE0, 0x00);\n\t\trtw_write32_mask(rtwdev, REG_TABLE_SEL, BIT_Q_GAIN_SEL, 0x0);\n\n\t\trtw8822c_txgapk_read_offset(rtwdev, path);\n\t\trtw_dbg(rtwdev, RTW_DBG_RFK, \"=============================\\n\");\n\n\t} else {\n\t\trtw_write32_mask(rtwdev,\n\t\t\t\t REG_SINGLE_TONE_SW, BIT_IRQ_TEST_MODE, 0x0);\n\t\trtw_write32_mask(rtwdev, REG_NCTL0, BIT_SEL_PATH, path);\n\t\trtw_write32_mask(rtwdev, REG_R_CONFIG, BIT_IQ_SWITCH, 0x3f);\n\t\trtw_write32_mask(rtwdev, REG_IQK_CTL1, BIT_TX_CFIR, 0x0);\n\t\trtw_write_rf(rtwdev, path, RF_DEBUG, BIT_DE_TX_GAIN, 0x1);\n\t\trtw_write_rf(rtwdev, path, RF_MODE_TRXAGC, RFREG_MASK, 0x50011);\n\t\trtw_write_rf(rtwdev, path, RF_TXA_LB_SW, BIT_TXA_LB_ATT, 0x3);\n\t\trtw_write_rf(rtwdev, path, RF_TXA_LB_SW, BIT_LB_ATT, 0x3);\n\t\trtw_write_rf(rtwdev, path, RF_TXA_LB_SW, BIT_LB_SW, 0x1);\n\t\trtw_write_rf(rtwdev, path,\n\t\t\t     RF_RXA_MIX_GAIN, BIT_RXA_MIX_GAIN, 0x2);\n\t\trtw_write_rf(rtwdev, path, RF_MODE_TRXAGC, BIT_RXAGC, 0x12);\n\t\trtw_write_rf(rtwdev, path, RF_DEBUG, BIT_DE_TRXBW, 0x1);\n\t\trtw_write_rf(rtwdev, path, RF_BW_TRXBB, BIT_BW_RXBB, 0x0);\n\t\trtw_write_rf(rtwdev, path, RF_EXT_TIA_BW, BIT_PW_EXT_TIA, 0x1);\n\t\trtw_write_rf(rtwdev, path, RF_MODE_TRXAGC, BIT_RF_MODE, 0x5);\n\n\t\trtw_write32_mask(rtwdev, REG_IQKSTAT, MASKBYTE0, 0x0);\n\n\t\tif (channel >= 36 && channel <= 64)\n\t\t\trtw_write32_mask(rtwdev,\n\t\t\t\t\t REG_TABLE_SEL, BIT_Q_GAIN_SEL, 0x2);\n\t\telse if (channel >= 100 && channel <= 144)\n\t\t\trtw_write32_mask(rtwdev,\n\t\t\t\t\t REG_TABLE_SEL, BIT_Q_GAIN_SEL, 0x3);\n\t\telse if (channel >= 149 && channel <= 177)\n\t\t\trtw_write32_mask(rtwdev,\n\t\t\t\t\t REG_TABLE_SEL, BIT_Q_GAIN_SEL, 0x4);\n\n\t\trtw8822c_txgapk_read_offset(rtwdev, path);\n\t\trtw_dbg(rtwdev, RTW_DBG_RFK, \"=============================\\n\");\n\t}\n\trtw8822c_txgapk_reload_bb_reg(rtwdev, bb_reg,\n\t\t\t\t      reg_backup, ARRAY_SIZE(bb_reg));\n}\n\nstatic void rtw8822c_txgapk_rf_restore(struct rtw_dev *rtwdev, u8 path)\n{\n\trtw_dbg(rtwdev, RTW_DBG_RFK, \"[TXGAPK] ======>%s\\n\", __func__);\n\n\tif (path >= rtwdev->hal.rf_path_num)\n\t\treturn;\n\n\trtw_write_rf(rtwdev, path, RF_MODE_TRXAGC, BIT_RF_MODE, 0x3);\n\trtw_write_rf(rtwdev, path, RF_DEBUG, BIT_DE_TRXBW, 0x0);\n\trtw_write_rf(rtwdev, path, RF_EXT_TIA_BW, BIT_PW_EXT_TIA, 0x0);\n}\n\nstatic u32 rtw8822c_txgapk_cal_gain(struct rtw_dev *rtwdev, u32 gain, s8 offset)\n{\n\tu32 gain_x2, new_gain;\n\n\trtw_dbg(rtwdev, RTW_DBG_RFK, \"[TXGAPK] ======>%s\\n\", __func__);\n\n\tif (_rtw8822c_txgapk_gain_valid(rtwdev, gain)) {\n\t\tnew_gain = gain;\n\t\trtw_dbg(rtwdev, RTW_DBG_RFK,\n\t\t\t\"[TXGAPK] gain=0x%03X(>=0xCEX) offset=%d new_gain=0x%03X\\n\",\n\t\t\tgain, offset, new_gain);\n\t\treturn new_gain;\n\t}\n\n\tgain_x2 = (gain << 1) + offset;\n\tnew_gain = (gain_x2 >> 1) | (gain_x2 & BIT(0) ? BIT_GAIN_EXT : 0);\n\n\trtw_dbg(rtwdev, RTW_DBG_RFK,\n\t\t\"[TXGAPK] gain=0x%X offset=%d new_gain=0x%X\\n\",\n\t\tgain, offset, new_gain);\n\n\treturn new_gain;\n}\n\nstatic void rtw8822c_txgapk_write_tx_gain(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_gapk_info *txgapk = &rtwdev->dm_info.gapk;\n\tu32 i, j, tmp = 0x20, tmp_3f, v;\n\ts8 offset_tmp[RF_GAIN_NUM] = {0};\n\tu8 path, band = RF_BAND_2G_OFDM, channel = txgapk->channel;\n\n\trtw_dbg(rtwdev, RTW_DBG_RFK, \"[TXGAPK] ======>%s\\n\", __func__);\n\n\tif (channel >= 1 && channel <= 14) {\n\t\ttmp = 0x20;\n\t\tband = RF_BAND_2G_OFDM;\n\t} else if (channel >= 36 && channel <= 64) {\n\t\ttmp = 0x200;\n\t\tband = RF_BAND_5G_L;\n\t} else if (channel >= 100 && channel <= 144) {\n\t\ttmp = 0x280;\n\t\tband = RF_BAND_5G_M;\n\t} else if (channel >= 149 && channel <= 177) {\n\t\ttmp = 0x300;\n\t\tband = RF_BAND_5G_H;\n\t} else {\n\t\trtw_err(rtwdev, \"[TXGAPK] unknown channel %d!!\\n\", channel);\n\t\treturn;\n\t}\n\n\tfor (path = 0; path < rtwdev->hal.rf_path_num; path++) {\n\t\tfor (i = 0; i < RF_GAIN_NUM; i++) {\n\t\t\toffset_tmp[i] = 0;\n\t\t\tfor (j = i; j < RF_GAIN_NUM; j++) {\n\t\t\t\tv = txgapk->rf3f_bp[band][j][path];\n\t\t\t\tif (_rtw8822c_txgapk_gain_valid(rtwdev, v))\n\t\t\t\t\tcontinue;\n\n\t\t\t\toffset_tmp[i] += txgapk->offset[j][path];\n\t\t\t\ttxgapk->fianl_offset[i][path] = offset_tmp[i];\n\t\t\t}\n\n\t\t\tv = txgapk->rf3f_bp[band][i][path];\n\t\t\tif (_rtw8822c_txgapk_gain_valid(rtwdev, v)) {\n\t\t\t\trtw_dbg(rtwdev, RTW_DBG_RFK,\n\t\t\t\t\t\"[TXGAPK] tx_gain=0x%03X >= 0xCEX\\n\",\n\t\t\t\t\ttxgapk->rf3f_bp[band][i][path]);\n\t\t\t} else {\n\t\t\t\ttxgapk->rf3f_fs[path][i] = offset_tmp[i];\n\t\t\t\trtw_dbg(rtwdev, RTW_DBG_RFK,\n\t\t\t\t\t\"[TXGAPK] offset %d %d\\n\",\n\t\t\t\t\toffset_tmp[i], i);\n\t\t\t}\n\t\t}\n\n\t\trtw_write_rf(rtwdev, path, RF_LUTWE2, RFREG_MASK, 0x10000);\n\t\tfor (i = 0; i < RF_GAIN_NUM; i++) {\n\t\t\trtw_write_rf(rtwdev, path,\n\t\t\t\t     RF_LUTWA, RFREG_MASK, tmp + i);\n\n\t\t\ttmp_3f = rtw8822c_txgapk_cal_gain(rtwdev,\n\t\t\t\t\t\t\t  txgapk->rf3f_bp[band][i][path],\n\t\t\t\t\t\t\t  offset_tmp[i]);\n\t\t\trtw_write_rf(rtwdev, path, RF_LUTWD0,\n\t\t\t\t     BIT_GAIN_EXT | BIT_DATA_L, tmp_3f);\n\n\t\t\trtw_dbg(rtwdev, RTW_DBG_RFK,\n\t\t\t\t\"[TXGAPK] 0x33=0x%05X 0x3f=0x%04X\\n\",\n\t\t\t\ttmp + i, tmp_3f);\n\t\t}\n\t\trtw_write_rf(rtwdev, path, RF_LUTWE2, RFREG_MASK, 0x0);\n\t}\n}\n\nstatic void rtw8822c_txgapk_save_all_tx_gain_table(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_gapk_info *txgapk = &rtwdev->dm_info.gapk;\n\tstatic const u32 three_wire[2] = {REG_3WIRE, REG_3WIRE2};\n\tstatic const u8 ch_num[RF_BAND_MAX] = {1, 1, 36, 100, 149};\n\tstatic const u8 band_num[RF_BAND_MAX] = {0x0, 0x0, 0x1, 0x3, 0x5};\n\tstatic const u8 cck[RF_BAND_MAX] = {0x1, 0x0, 0x0, 0x0, 0x0};\n\tu8 path, band, gain, rf0_idx;\n\tu32 rf18, v;\n\n\tif (rtwdev->dm_info.dm_flags & BIT(RTW_DM_CAP_TXGAPK))\n\t\treturn;\n\n\trtw_dbg(rtwdev, RTW_DBG_RFK, \"[TXGAPK] ======>%s\\n\", __func__);\n\n\tif (txgapk->read_txgain == 1) {\n\t\trtw_dbg(rtwdev, RTW_DBG_RFK,\n\t\t\t\"[TXGAPK] Already Read txgapk->read_txgain return!!!\\n\");\n\t\trtw8822c_txgapk_write_gain_bb_table(rtwdev);\n\t\treturn;\n\t}\n\n\tfor (band = 0; band < RF_BAND_MAX; band++) {\n\t\tfor (path = 0; path < rtwdev->hal.rf_path_num; path++) {\n\t\t\trf18 = rtw_read_rf(rtwdev, path, RF_CFGCH, RFREG_MASK);\n\n\t\t\trtw_write32_mask(rtwdev,\n\t\t\t\t\t three_wire[path], BIT_3WIRE_EN, 0x0);\n\t\t\trtw_write_rf(rtwdev, path,\n\t\t\t\t     RF_CFGCH, MASKBYTE0, ch_num[band]);\n\t\t\trtw_write_rf(rtwdev, path,\n\t\t\t\t     RF_CFGCH, BIT_BAND, band_num[band]);\n\t\t\trtw_write_rf(rtwdev, path,\n\t\t\t\t     RF_BW_TRXBB, BIT_DBG_CCK_CCA, cck[band]);\n\t\t\trtw_write_rf(rtwdev, path,\n\t\t\t\t     RF_BW_TRXBB, BIT_TX_CCK_IND, cck[band]);\n\t\t\tgain = 0;\n\t\t\tfor (rf0_idx = 1; rf0_idx < 32; rf0_idx += 3) {\n\t\t\t\trtw_write_rf(rtwdev, path, RF_MODE_TRXAGC,\n\t\t\t\t\t     MASKBYTE0, rf0_idx);\n\t\t\t\tv = rtw_read_rf(rtwdev, path,\n\t\t\t\t\t\tRF_TX_RESULT, RFREG_MASK);\n\t\t\t\ttxgapk->rf3f_bp[band][gain][path] = v & BIT_DATA_L;\n\n\t\t\t\trtw_dbg(rtwdev, RTW_DBG_RFK,\n\t\t\t\t\t\"[TXGAPK] 0x5f=0x%03X band=%d path=%d\\n\",\n\t\t\t\t\ttxgapk->rf3f_bp[band][gain][path],\n\t\t\t\t\tband, path);\n\t\t\t\tgain++;\n\t\t\t}\n\t\t\trtw_write_rf(rtwdev, path, RF_CFGCH, RFREG_MASK, rf18);\n\t\t\trtw_write32_mask(rtwdev,\n\t\t\t\t\t three_wire[path], BIT_3WIRE_EN, 0x3);\n\t\t}\n\t}\n\trtw8822c_txgapk_write_gain_bb_table(rtwdev);\n\ttxgapk->read_txgain = 1;\n}\n\nstatic void rtw8822c_txgapk(struct rtw_dev *rtwdev)\n{\n\tstatic const u32 bb_reg[2] = {REG_TX_PTCL_CTRL, REG_TX_FIFO};\n\tstruct rtw_gapk_info *txgapk = &rtwdev->dm_info.gapk;\n\tu32 bb_reg_backup[2];\n\tu8 path;\n\n\trtw_dbg(rtwdev, RTW_DBG_RFK, \"[TXGAPK] ======>%s\\n\", __func__);\n\n\trtw8822c_txgapk_save_all_tx_gain_table(rtwdev);\n\n\tif (txgapk->read_txgain == 0) {\n\t\trtw_dbg(rtwdev, RTW_DBG_RFK,\n\t\t\t\"[TXGAPK] txgapk->read_txgain == 0 return!!!\\n\");\n\t\treturn;\n\t}\n\n\tif (rtwdev->efuse.power_track_type >= 4 &&\n\t    rtwdev->efuse.power_track_type <= 7) {\n\t\trtw_dbg(rtwdev, RTW_DBG_RFK,\n\t\t\t\"[TXGAPK] Normal Mode in TSSI mode. return!!!\\n\");\n\t\treturn;\n\t}\n\n\trtw8822c_txgapk_backup_bb_reg(rtwdev, bb_reg,\n\t\t\t\t      bb_reg_backup, ARRAY_SIZE(bb_reg));\n\trtw8822c_txgapk_tx_pause(rtwdev);\n\tfor (path = 0; path < rtwdev->hal.rf_path_num; path++) {\n\t\ttxgapk->channel = rtw_read_rf(rtwdev, path,\n\t\t\t\t\t      RF_CFGCH, RFREG_MASK) & MASKBYTE0;\n\t\trtw8822c_txgapk_bb_dpk(rtwdev, path);\n\t\trtw8822c_txgapk_afe_dpk(rtwdev, path);\n\t\trtw8822c_txgapk_calculate_offset(rtwdev, path);\n\t\trtw8822c_txgapk_rf_restore(rtwdev, path);\n\t\trtw8822c_txgapk_afe_dpk_restore(rtwdev, path);\n\t\trtw8822c_txgapk_bb_dpk_restore(rtwdev, path);\n\t}\n\trtw8822c_txgapk_write_tx_gain(rtwdev);\n\trtw8822c_txgapk_reload_bb_reg(rtwdev, bb_reg,\n\t\t\t\t      bb_reg_backup, ARRAY_SIZE(bb_reg));\n}\n\nstatic void rtw8822c_do_gapk(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_dm_info *dm = &rtwdev->dm_info;\n\n\tif (dm->dm_flags & BIT(RTW_DM_CAP_TXGAPK)) {\n\t\trtw_dbg(rtwdev, RTW_DBG_RFK, \"[TXGAPK] feature disable!!!\\n\");\n\t\treturn;\n\t}\n\trtw8822c_rfk_handshake(rtwdev, true);\n\trtw8822c_txgapk(rtwdev);\n\trtw8822c_rfk_handshake(rtwdev, false);\n}\n\nstatic void rtw8822c_rf_init(struct rtw_dev *rtwdev)\n{\n\trtw8822c_rf_dac_cal(rtwdev);\n\trtw8822c_rf_x2_check(rtwdev);\n\trtw8822c_thermal_trim(rtwdev);\n\trtw8822c_power_trim(rtwdev);\n\trtw8822c_pa_bias(rtwdev);\n}\n\nstatic void rtw8822c_pwrtrack_init(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tu8 path;\n\n\tfor (path = RF_PATH_A; path < RTW_RF_PATH_MAX; path++) {\n\t\tdm_info->delta_power_index[path] = 0;\n\t\tewma_thermal_init(&dm_info->avg_thermal[path]);\n\t\tdm_info->thermal_avg[path] = 0xff;\n\t}\n\n\tdm_info->pwr_trk_triggered = false;\n\tdm_info->thermal_meter_k = rtwdev->efuse.thermal_meter_k;\n\tdm_info->thermal_meter_lck = rtwdev->efuse.thermal_meter_k;\n}\n\nstatic void rtw8822c_phy_set_param(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tstruct rtw_hal *hal = &rtwdev->hal;\n\tu8 crystal_cap;\n\tu8 cck_gi_u_bnd_msb = 0;\n\tu8 cck_gi_u_bnd_lsb = 0;\n\tu8 cck_gi_l_bnd_msb = 0;\n\tu8 cck_gi_l_bnd_lsb = 0;\n\tbool is_tx2_path;\n\n\t \n\trtw_write8_set(rtwdev, REG_SYS_FUNC_EN,\n\t\t       BIT_FEN_BB_GLB_RST | BIT_FEN_BB_RSTB);\n\trtw_write8_set(rtwdev, REG_RF_CTRL,\n\t\t       BIT_RF_EN | BIT_RF_RSTB | BIT_RF_SDM_RSTB);\n\trtw_write32_set(rtwdev, REG_WLRF1, BIT_WLRF1_BBRF_EN);\n\n\t \n\trtw_write32_mask(rtwdev, REG_DIS_DPD, DIS_DPD_MASK, DIS_DPD_RATEALL);\n\n\t \n\trtw8822c_header_file_init(rtwdev, true);\n\n\trtw_phy_load_tables(rtwdev);\n\n\tcrystal_cap = rtwdev->efuse.crystal_cap & 0x7f;\n\trtw_write32_mask(rtwdev, REG_ANAPAR_XTAL_0, 0xfffc00,\n\t\t\t crystal_cap | (crystal_cap << 7));\n\n\t \n\trtw8822c_header_file_init(rtwdev, false);\n\n\tis_tx2_path = false;\n\trtw8822c_config_trx_mode(rtwdev, hal->antenna_tx, hal->antenna_rx,\n\t\t\t\t is_tx2_path);\n\trtw_phy_init(rtwdev);\n\n\tcck_gi_u_bnd_msb = (u8)rtw_read32_mask(rtwdev, 0x1a98, 0xc000);\n\tcck_gi_u_bnd_lsb = (u8)rtw_read32_mask(rtwdev, 0x1aa8, 0xf0000);\n\tcck_gi_l_bnd_msb = (u8)rtw_read32_mask(rtwdev, 0x1a98, 0xc0);\n\tcck_gi_l_bnd_lsb = (u8)rtw_read32_mask(rtwdev, 0x1a70, 0x0f000000);\n\n\tdm_info->cck_gi_u_bnd = ((cck_gi_u_bnd_msb << 4) | (cck_gi_u_bnd_lsb));\n\tdm_info->cck_gi_l_bnd = ((cck_gi_l_bnd_msb << 4) | (cck_gi_l_bnd_lsb));\n\n\trtw8822c_rf_init(rtwdev);\n\trtw8822c_pwrtrack_init(rtwdev);\n\n\trtw_bf_phy_init(rtwdev);\n}\n\n#define WLAN_TXQ_RPT_EN\t\t0x1F\n#define WLAN_SLOT_TIME\t\t0x09\n#define WLAN_PIFS_TIME\t\t0x1C\n#define WLAN_SIFS_CCK_CONT_TX\t0x0A\n#define WLAN_SIFS_OFDM_CONT_TX\t0x0E\n#define WLAN_SIFS_CCK_TRX\t0x0A\n#define WLAN_SIFS_OFDM_TRX\t0x10\n#define WLAN_NAV_MAX\t\t0xC8\n#define WLAN_RDG_NAV\t\t0x05\n#define WLAN_TXOP_NAV\t\t0x1B\n#define WLAN_CCK_RX_TSF\t\t0x30\n#define WLAN_OFDM_RX_TSF\t0x30\n#define WLAN_TBTT_PROHIBIT\t0x04  \n#define WLAN_TBTT_HOLD_TIME\t0x064  \n#define WLAN_DRV_EARLY_INT\t0x04\n#define WLAN_BCN_CTRL_CLT0\t0x10\n#define WLAN_BCN_DMA_TIME\t0x02\n#define WLAN_BCN_MAX_ERR\t0xFF\n#define WLAN_SIFS_CCK_DUR_TUNE\t0x0A\n#define WLAN_SIFS_OFDM_DUR_TUNE\t0x10\n#define WLAN_SIFS_CCK_CTX\t0x0A\n#define WLAN_SIFS_CCK_IRX\t0x0A\n#define WLAN_SIFS_OFDM_CTX\t0x0E\n#define WLAN_SIFS_OFDM_IRX\t0x0E\n#define WLAN_EIFS_DUR_TUNE\t0x40\n#define WLAN_EDCA_VO_PARAM\t0x002FA226\n#define WLAN_EDCA_VI_PARAM\t0x005EA328\n#define WLAN_EDCA_BE_PARAM\t0x005EA42B\n#define WLAN_EDCA_BK_PARAM\t0x0000A44F\n\n#define WLAN_RX_FILTER0\t\t0xFFFFFFFF\n#define WLAN_RX_FILTER2\t\t0xFFFF\n#define WLAN_RCR_CFG\t\t0xE400220E\n#define WLAN_RXPKT_MAX_SZ\t12288\n#define WLAN_RXPKT_MAX_SZ_512\t(WLAN_RXPKT_MAX_SZ >> 9)\n\n#define WLAN_AMPDU_MAX_TIME\t\t0x70\n#define WLAN_RTS_LEN_TH\t\t\t0xFF\n#define WLAN_RTS_TX_TIME_TH\t\t0x08\n#define WLAN_MAX_AGG_PKT_LIMIT\t\t0x3f\n#define WLAN_RTS_MAX_AGG_PKT_LIMIT\t0x3f\n#define WLAN_PRE_TXCNT_TIME_TH\t\t0x1E0\n#define FAST_EDCA_VO_TH\t\t0x06\n#define FAST_EDCA_VI_TH\t\t0x06\n#define FAST_EDCA_BE_TH\t\t0x06\n#define FAST_EDCA_BK_TH\t\t0x06\n#define WLAN_BAR_RETRY_LIMIT\t\t0x01\n#define WLAN_BAR_ACK_TYPE\t\t0x05\n#define WLAN_RA_TRY_RATE_AGG_LIMIT\t0x08\n#define WLAN_RESP_TXRATE\t\t0x84\n#define WLAN_ACK_TO\t\t\t0x21\n#define WLAN_ACK_TO_CCK\t\t\t0x6A\n#define WLAN_DATA_RATE_FB_CNT_1_4\t0x01000000\n#define WLAN_DATA_RATE_FB_CNT_5_8\t0x08070504\n#define WLAN_RTS_RATE_FB_CNT_5_8\t0x08070504\n#define WLAN_DATA_RATE_FB_RATE0\t\t0xFE01F010\n#define WLAN_DATA_RATE_FB_RATE0_H\t0x40000000\n#define WLAN_RTS_RATE_FB_RATE1\t\t0x003FF010\n#define WLAN_RTS_RATE_FB_RATE1_H\t0x40000000\n#define WLAN_RTS_RATE_FB_RATE4\t\t0x0600F010\n#define WLAN_RTS_RATE_FB_RATE4_H\t0x400003E0\n#define WLAN_RTS_RATE_FB_RATE5\t\t0x0600F015\n#define WLAN_RTS_RATE_FB_RATE5_H\t0x000000E0\n#define WLAN_MULTI_ADDR\t\t\t0xFFFFFFFF\n\n#define WLAN_TX_FUNC_CFG1\t\t0x30\n#define WLAN_TX_FUNC_CFG2\t\t0x30\n#define WLAN_MAC_OPT_NORM_FUNC1\t\t0x98\n#define WLAN_MAC_OPT_LB_FUNC1\t\t0x80\n#define WLAN_MAC_OPT_FUNC2\t\t0xb0810041\n#define WLAN_MAC_INT_MIG_CFG\t\t0x33330000\n\n#define WLAN_SIFS_CFG\t(WLAN_SIFS_CCK_CONT_TX | \\\n\t\t\t(WLAN_SIFS_OFDM_CONT_TX << BIT_SHIFT_SIFS_OFDM_CTX) | \\\n\t\t\t(WLAN_SIFS_CCK_TRX << BIT_SHIFT_SIFS_CCK_TRX) | \\\n\t\t\t(WLAN_SIFS_OFDM_TRX << BIT_SHIFT_SIFS_OFDM_TRX))\n\n#define WLAN_SIFS_DUR_TUNE\t(WLAN_SIFS_CCK_DUR_TUNE | \\\n\t\t\t\t(WLAN_SIFS_OFDM_DUR_TUNE << 8))\n\n#define WLAN_TBTT_TIME\t(WLAN_TBTT_PROHIBIT |\\\n\t\t\t(WLAN_TBTT_HOLD_TIME << BIT_SHIFT_TBTT_HOLD_TIME_AP))\n\n#define WLAN_NAV_CFG\t\t(WLAN_RDG_NAV | (WLAN_TXOP_NAV << 16))\n#define WLAN_RX_TSF_CFG\t\t(WLAN_CCK_RX_TSF | (WLAN_OFDM_RX_TSF) << 8)\n\n#define MAC_CLK_SPEED\t80  \n#define EFUSE_PCB_INFO_OFFSET\t0xCA\n\nstatic int rtw8822c_mac_init(struct rtw_dev *rtwdev)\n{\n\tu8 value8;\n\tu16 value16;\n\tu32 value32;\n\tu16 pre_txcnt;\n\n\t \n\tvalue8 = rtw_read8(rtwdev, REG_FWHW_TXQ_CTRL);\n\tvalue8 |= (BIT(7) & ~BIT(1) & ~BIT(2));\n\trtw_write8(rtwdev, REG_FWHW_TXQ_CTRL, value8);\n\trtw_write8(rtwdev, REG_FWHW_TXQ_CTRL + 1, WLAN_TXQ_RPT_EN);\n\t \n\trtw_write16(rtwdev, REG_SPEC_SIFS, WLAN_SIFS_DUR_TUNE);\n\trtw_write32(rtwdev, REG_SIFS, WLAN_SIFS_CFG);\n\trtw_write16(rtwdev, REG_RESP_SIFS_CCK,\n\t\t    WLAN_SIFS_CCK_CTX | WLAN_SIFS_CCK_IRX << 8);\n\trtw_write16(rtwdev, REG_RESP_SIFS_OFDM,\n\t\t    WLAN_SIFS_OFDM_CTX | WLAN_SIFS_OFDM_IRX << 8);\n\t \n\trtw_write32(rtwdev, REG_DARFRC, WLAN_DATA_RATE_FB_CNT_1_4);\n\trtw_write32(rtwdev, REG_DARFRCH, WLAN_DATA_RATE_FB_CNT_5_8);\n\trtw_write32(rtwdev, REG_RARFRCH, WLAN_RTS_RATE_FB_CNT_5_8);\n\trtw_write32(rtwdev, REG_ARFR0, WLAN_DATA_RATE_FB_RATE0);\n\trtw_write32(rtwdev, REG_ARFRH0, WLAN_DATA_RATE_FB_RATE0_H);\n\trtw_write32(rtwdev, REG_ARFR1_V1, WLAN_RTS_RATE_FB_RATE1);\n\trtw_write32(rtwdev, REG_ARFRH1_V1, WLAN_RTS_RATE_FB_RATE1_H);\n\trtw_write32(rtwdev, REG_ARFR4, WLAN_RTS_RATE_FB_RATE4);\n\trtw_write32(rtwdev, REG_ARFRH4, WLAN_RTS_RATE_FB_RATE4_H);\n\trtw_write32(rtwdev, REG_ARFR5, WLAN_RTS_RATE_FB_RATE5);\n\trtw_write32(rtwdev, REG_ARFRH5, WLAN_RTS_RATE_FB_RATE5_H);\n\t \n\trtw_write8(rtwdev, REG_AMPDU_MAX_TIME_V1, WLAN_AMPDU_MAX_TIME);\n\trtw_write8_set(rtwdev, REG_TX_HANG_CTRL, BIT_EN_EOF_V1);\n\tpre_txcnt = WLAN_PRE_TXCNT_TIME_TH | BIT_EN_PRECNT;\n\trtw_write8(rtwdev, REG_PRECNT_CTRL, (u8)(pre_txcnt & 0xFF));\n\trtw_write8(rtwdev, REG_PRECNT_CTRL + 1, (u8)(pre_txcnt >> 8));\n\tvalue32 = WLAN_RTS_LEN_TH | (WLAN_RTS_TX_TIME_TH << 8) |\n\t\t  (WLAN_MAX_AGG_PKT_LIMIT << 16) |\n\t\t  (WLAN_RTS_MAX_AGG_PKT_LIMIT << 24);\n\trtw_write32(rtwdev, REG_PROT_MODE_CTRL, value32);\n\trtw_write16(rtwdev, REG_BAR_MODE_CTRL + 2,\n\t\t    WLAN_BAR_RETRY_LIMIT | WLAN_RA_TRY_RATE_AGG_LIMIT << 8);\n\trtw_write8(rtwdev, REG_FAST_EDCA_VOVI_SETTING, FAST_EDCA_VO_TH);\n\trtw_write8(rtwdev, REG_FAST_EDCA_VOVI_SETTING + 2, FAST_EDCA_VI_TH);\n\trtw_write8(rtwdev, REG_FAST_EDCA_BEBK_SETTING, FAST_EDCA_BE_TH);\n\trtw_write8(rtwdev, REG_FAST_EDCA_BEBK_SETTING + 2, FAST_EDCA_BK_TH);\n\t \n\trtw_write8_clr(rtwdev, REG_LIFETIME_EN, BIT_BA_PARSER_EN);\n\trtw_write32_clr(rtwdev, REG_RRSR, BITS_RRSR_RSC);\n\n\t \n\trtw_write32(rtwdev, REG_EDCA_VO_PARAM, WLAN_EDCA_VO_PARAM);\n\trtw_write32(rtwdev, REG_EDCA_VI_PARAM, WLAN_EDCA_VI_PARAM);\n\trtw_write32(rtwdev, REG_EDCA_BE_PARAM, WLAN_EDCA_BE_PARAM);\n\trtw_write32(rtwdev, REG_EDCA_BK_PARAM, WLAN_EDCA_BK_PARAM);\n\trtw_write8(rtwdev, REG_PIFS, WLAN_PIFS_TIME);\n\trtw_write8_clr(rtwdev, REG_TX_PTCL_CTRL + 1, BIT_SIFS_BK_EN >> 8);\n\trtw_write8_set(rtwdev, REG_RD_CTRL + 1,\n\t\t       (BIT_DIS_TXOP_CFE | BIT_DIS_LSIG_CFE |\n\t\t\tBIT_DIS_STBC_CFE) >> 8);\n\n\t \n\trtw_write32_clr(rtwdev, REG_AFE_CTRL1, BIT_MAC_CLK_SEL);\n\trtw_write8(rtwdev, REG_USTIME_TSF, MAC_CLK_SPEED);\n\trtw_write8(rtwdev, REG_USTIME_EDCA, MAC_CLK_SPEED);\n\n\trtw_write8_set(rtwdev, REG_MISC_CTRL,\n\t\t       BIT_EN_FREE_CNT | BIT_DIS_SECOND_CCA);\n\trtw_write8_clr(rtwdev, REG_TIMER0_SRC_SEL, BIT_TSFT_SEL_TIMER0);\n\trtw_write16(rtwdev, REG_TXPAUSE, 0x0000);\n\trtw_write8(rtwdev, REG_SLOT, WLAN_SLOT_TIME);\n\trtw_write32(rtwdev, REG_RD_NAV_NXT, WLAN_NAV_CFG);\n\trtw_write16(rtwdev, REG_RXTSF_OFFSET_CCK, WLAN_RX_TSF_CFG);\n\t \n\trtw_write8_set(rtwdev, REG_BCN_CTRL, BIT_EN_BCN_FUNCTION);\n\t \n\trtw_write32(rtwdev, REG_TBTT_PROHIBIT, WLAN_TBTT_TIME);\n\trtw_write8(rtwdev, REG_DRVERLYINT, WLAN_DRV_EARLY_INT);\n\trtw_write8(rtwdev, REG_BCN_CTRL_CLINT0, WLAN_BCN_CTRL_CLT0);\n\trtw_write8(rtwdev, REG_BCNDMATIM, WLAN_BCN_DMA_TIME);\n\trtw_write8(rtwdev, REG_BCN_MAX_ERR, WLAN_BCN_MAX_ERR);\n\n\t \n\trtw_write32(rtwdev, REG_MAR, WLAN_MULTI_ADDR);\n\trtw_write32(rtwdev, REG_MAR + 4, WLAN_MULTI_ADDR);\n\trtw_write8(rtwdev, REG_BBPSF_CTRL + 2, WLAN_RESP_TXRATE);\n\trtw_write8(rtwdev, REG_ACKTO, WLAN_ACK_TO);\n\trtw_write8(rtwdev, REG_ACKTO_CCK, WLAN_ACK_TO_CCK);\n\trtw_write16(rtwdev, REG_EIFS, WLAN_EIFS_DUR_TUNE);\n\trtw_write8(rtwdev, REG_NAV_CTRL + 2, WLAN_NAV_MAX);\n\trtw_write8(rtwdev, REG_WMAC_TRXPTCL_CTL_H  + 2, WLAN_BAR_ACK_TYPE);\n\trtw_write32(rtwdev, REG_RXFLTMAP0, WLAN_RX_FILTER0);\n\trtw_write16(rtwdev, REG_RXFLTMAP2, WLAN_RX_FILTER2);\n\trtw_write32(rtwdev, REG_RCR, WLAN_RCR_CFG);\n\trtw_write8(rtwdev, REG_RX_PKT_LIMIT, WLAN_RXPKT_MAX_SZ_512);\n\trtw_write8(rtwdev, REG_TCR + 2, WLAN_TX_FUNC_CFG2);\n\trtw_write8(rtwdev, REG_TCR + 1, WLAN_TX_FUNC_CFG1);\n\trtw_write32_set(rtwdev, REG_GENERAL_OPTION, BIT_DUMMY_FCS_READY_MASK_EN);\n\trtw_write32(rtwdev, REG_WMAC_OPTION_FUNCTION + 8, WLAN_MAC_OPT_FUNC2);\n\trtw_write8(rtwdev, REG_WMAC_OPTION_FUNCTION_1, WLAN_MAC_OPT_NORM_FUNC1);\n\n\t \n\tvalue16 = rtw_read16(rtwdev, REG_RXPSF_CTRL + 2) & 0xF00F;\n\tvalue16 |= (BIT_RXGCK_VHT_FIFOTHR(1) | BIT_RXGCK_HT_FIFOTHR(1) |\n\t\t    BIT_RXGCK_OFDM_FIFOTHR(1) | BIT_RXGCK_CCK_FIFOTHR(1)) >> 16;\n\trtw_write16(rtwdev, REG_RXPSF_CTRL + 2, value16);\n\tvalue16 = 0;\n\tvalue16 = BIT_SET_RXPSF_PKTLENTHR(value16, 1);\n\tvalue16 |= BIT_RXPSF_CTRLEN | BIT_RXPSF_VHTCHKEN | BIT_RXPSF_HTCHKEN\n\t\t| BIT_RXPSF_OFDMCHKEN | BIT_RXPSF_CCKCHKEN\n\t\t| BIT_RXPSF_OFDMRST;\n\trtw_write16(rtwdev, REG_RXPSF_CTRL, value16);\n\trtw_write32(rtwdev, REG_RXPSF_TYPE_CTRL, 0xFFFFFFFF);\n\t \n\tvalue16 = rtw_read16(rtwdev, REG_RXPSF_CTRL);\n\tvalue16 &= ~(BIT_RXPSF_MHCHKEN | BIT_RXPSF_CCKRST |\n\t\t     BIT_RXPSF_CONT_ERRCHKEN);\n\tvalue16 = BIT_SET_RXPSF_ERRTHR(value16, 0x07);\n\trtw_write16(rtwdev, REG_RXPSF_CTRL, value16);\n\trtw_write8_set(rtwdev, REG_SND_PTCL_CTRL,\n\t\t       BIT_DIS_CHK_VHTSIGB_CRC);\n\n\t \n\trtw_write32(rtwdev, REG_INT_MIG, WLAN_MAC_INT_MIG_CFG);\n\n\treturn 0;\n}\n\n#define FWCD_SIZE_REG_8822C 0x2000\n#define FWCD_SIZE_DMEM_8822C 0x10000\n#define FWCD_SIZE_IMEM_8822C 0x10000\n#define FWCD_SIZE_EMEM_8822C 0x20000\n#define FWCD_SIZE_ROM_8822C 0x10000\n\nstatic const u32 __fwcd_segs_8822c[] = {\n\tFWCD_SIZE_REG_8822C,\n\tFWCD_SIZE_DMEM_8822C,\n\tFWCD_SIZE_IMEM_8822C,\n\tFWCD_SIZE_EMEM_8822C,\n\tFWCD_SIZE_ROM_8822C,\n};\n\nstatic const struct rtw_fwcd_segs rtw8822c_fwcd_segs = {\n\t.segs = __fwcd_segs_8822c,\n\t.num = ARRAY_SIZE(__fwcd_segs_8822c),\n};\n\nstatic int rtw8822c_dump_fw_crash(struct rtw_dev *rtwdev)\n{\n#define __dump_fw_8822c(_dev, _mem) \\\n\trtw_dump_fw(_dev, OCPBASE_ ## _mem ## _88XX, \\\n\t\t    FWCD_SIZE_ ## _mem ## _8822C, RTW_FWCD_ ## _mem)\n\tint ret;\n\n\tret = rtw_dump_reg(rtwdev, 0x0, FWCD_SIZE_REG_8822C);\n\tif (ret)\n\t\treturn ret;\n\tret = __dump_fw_8822c(rtwdev, DMEM);\n\tif (ret)\n\t\treturn ret;\n\tret = __dump_fw_8822c(rtwdev, IMEM);\n\tif (ret)\n\t\treturn ret;\n\tret = __dump_fw_8822c(rtwdev, EMEM);\n\tif (ret)\n\t\treturn ret;\n\tret = __dump_fw_8822c(rtwdev, ROM);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n\n#undef __dump_fw_8822c\n}\n\nstatic void rtw8822c_rstb_3wire(struct rtw_dev *rtwdev, bool enable)\n{\n\tif (enable) {\n\t\trtw_write32_mask(rtwdev, REG_RSTB, BIT_RSTB_3WIRE, 0x1);\n\t\trtw_write32_mask(rtwdev, REG_ANAPAR_A, BIT_ANAPAR_UPDATE, 0x1);\n\t\trtw_write32_mask(rtwdev, REG_ANAPAR_B, BIT_ANAPAR_UPDATE, 0x1);\n\t} else {\n\t\trtw_write32_mask(rtwdev, REG_RSTB, BIT_RSTB_3WIRE, 0x0);\n\t}\n}\n\nstatic void rtw8822c_set_channel_rf(struct rtw_dev *rtwdev, u8 channel, u8 bw)\n{\n#define RF18_BAND_MASK\t\t(BIT(16) | BIT(9) | BIT(8))\n#define RF18_BAND_2G\t\t(0)\n#define RF18_BAND_5G\t\t(BIT(16) | BIT(8))\n#define RF18_CHANNEL_MASK\t(MASKBYTE0)\n#define RF18_RFSI_MASK\t\t(BIT(18) | BIT(17))\n#define RF18_RFSI_GE_CH80\t(BIT(17))\n#define RF18_RFSI_GT_CH140\t(BIT(18))\n#define RF18_BW_MASK\t\t(BIT(13) | BIT(12))\n#define RF18_BW_20M\t\t(BIT(13) | BIT(12))\n#define RF18_BW_40M\t\t(BIT(13))\n#define RF18_BW_80M\t\t(BIT(12))\n\n\tu32 rf_reg18 = 0;\n\tu32 rf_rxbb = 0;\n\n\trf_reg18 = rtw_read_rf(rtwdev, RF_PATH_A, 0x18, RFREG_MASK);\n\n\trf_reg18 &= ~(RF18_BAND_MASK | RF18_CHANNEL_MASK | RF18_RFSI_MASK |\n\t\t      RF18_BW_MASK);\n\n\trf_reg18 |= (IS_CH_2G_BAND(channel) ? RF18_BAND_2G : RF18_BAND_5G);\n\trf_reg18 |= (channel & RF18_CHANNEL_MASK);\n\tif (IS_CH_5G_BAND_4(channel))\n\t\trf_reg18 |= RF18_RFSI_GT_CH140;\n\telse if (IS_CH_5G_BAND_3(channel))\n\t\trf_reg18 |= RF18_RFSI_GE_CH80;\n\n\tswitch (bw) {\n\tcase RTW_CHANNEL_WIDTH_5:\n\tcase RTW_CHANNEL_WIDTH_10:\n\tcase RTW_CHANNEL_WIDTH_20:\n\tdefault:\n\t\trf_reg18 |= RF18_BW_20M;\n\t\trf_rxbb = 0x18;\n\t\tbreak;\n\tcase RTW_CHANNEL_WIDTH_40:\n\t\t \n\t\trf_reg18 |= RF18_BW_40M;\n\t\trf_rxbb = 0x10;\n\t\tbreak;\n\tcase RTW_CHANNEL_WIDTH_80:\n\t\trf_reg18 |= RF18_BW_80M;\n\t\trf_rxbb = 0x8;\n\t\tbreak;\n\t}\n\n\trtw8822c_rstb_3wire(rtwdev, false);\n\n\trtw_write_rf(rtwdev, RF_PATH_A, RF_LUTWE2, 0x04, 0x01);\n\trtw_write_rf(rtwdev, RF_PATH_A, RF_LUTWA, 0x1f, 0x12);\n\trtw_write_rf(rtwdev, RF_PATH_A, RF_LUTWD0, 0xfffff, rf_rxbb);\n\trtw_write_rf(rtwdev, RF_PATH_A, RF_LUTWE2, 0x04, 0x00);\n\n\trtw_write_rf(rtwdev, RF_PATH_B, RF_LUTWE2, 0x04, 0x01);\n\trtw_write_rf(rtwdev, RF_PATH_B, RF_LUTWA, 0x1f, 0x12);\n\trtw_write_rf(rtwdev, RF_PATH_B, RF_LUTWD0, 0xfffff, rf_rxbb);\n\trtw_write_rf(rtwdev, RF_PATH_B, RF_LUTWE2, 0x04, 0x00);\n\n\trtw_write_rf(rtwdev, RF_PATH_A, RF_CFGCH, RFREG_MASK, rf_reg18);\n\trtw_write_rf(rtwdev, RF_PATH_B, RF_CFGCH, RFREG_MASK, rf_reg18);\n\n\trtw8822c_rstb_3wire(rtwdev, true);\n}\n\nstatic void rtw8822c_toggle_igi(struct rtw_dev *rtwdev)\n{\n\tu32 igi;\n\n\tigi = rtw_read32_mask(rtwdev, REG_RXIGI, 0x7f);\n\trtw_write32_mask(rtwdev, REG_RXIGI, 0x7f, igi - 2);\n\trtw_write32_mask(rtwdev, REG_RXIGI, 0x7f00, igi - 2);\n\trtw_write32_mask(rtwdev, REG_RXIGI, 0x7f, igi);\n\trtw_write32_mask(rtwdev, REG_RXIGI, 0x7f00, igi);\n}\n\nstatic void rtw8822c_set_channel_bb(struct rtw_dev *rtwdev, u8 channel, u8 bw,\n\t\t\t\t    u8 primary_ch_idx)\n{\n\tif (IS_CH_2G_BAND(channel)) {\n\t\trtw_write32_clr(rtwdev, REG_BGCTRL, BITS_RX_IQ_WEIGHT);\n\t\trtw_write32_set(rtwdev, REG_TXF4, BIT(20));\n\t\trtw_write32_clr(rtwdev, REG_CCK_CHECK, BIT_CHECK_CCK_EN);\n\t\trtw_write32_clr(rtwdev, REG_CCKTXONLY, BIT_BB_CCK_CHECK_EN);\n\t\trtw_write32_mask(rtwdev, REG_CCAMSK, 0x3F000000, 0xF);\n\n\t\tswitch (bw) {\n\t\tcase RTW_CHANNEL_WIDTH_20:\n\t\t\trtw_write32_mask(rtwdev, REG_RXAGCCTL0, BITS_RXAGC_CCK,\n\t\t\t\t\t 0x5);\n\t\t\trtw_write32_mask(rtwdev, REG_RXAGCCTL, BITS_RXAGC_CCK,\n\t\t\t\t\t 0x5);\n\t\t\trtw_write32_mask(rtwdev, REG_RXAGCCTL0, BITS_RXAGC_OFDM,\n\t\t\t\t\t 0x6);\n\t\t\trtw_write32_mask(rtwdev, REG_RXAGCCTL, BITS_RXAGC_OFDM,\n\t\t\t\t\t 0x6);\n\t\t\tbreak;\n\t\tcase RTW_CHANNEL_WIDTH_40:\n\t\t\trtw_write32_mask(rtwdev, REG_RXAGCCTL0, BITS_RXAGC_CCK,\n\t\t\t\t\t 0x4);\n\t\t\trtw_write32_mask(rtwdev, REG_RXAGCCTL, BITS_RXAGC_CCK,\n\t\t\t\t\t 0x4);\n\t\t\trtw_write32_mask(rtwdev, REG_RXAGCCTL0, BITS_RXAGC_OFDM,\n\t\t\t\t\t 0x0);\n\t\t\trtw_write32_mask(rtwdev, REG_RXAGCCTL, BITS_RXAGC_OFDM,\n\t\t\t\t\t 0x0);\n\t\t\tbreak;\n\t\t}\n\t\tif (channel == 13 || channel == 14)\n\t\t\trtw_write32_mask(rtwdev, REG_SCOTRK, 0xfff, 0x969);\n\t\telse if (channel == 11 || channel == 12)\n\t\t\trtw_write32_mask(rtwdev, REG_SCOTRK, 0xfff, 0x96a);\n\t\telse\n\t\t\trtw_write32_mask(rtwdev, REG_SCOTRK, 0xfff, 0x9aa);\n\t\tif (channel == 14) {\n\t\t\trtw_write32_mask(rtwdev, REG_TXF0, MASKHWORD, 0x3da0);\n\t\t\trtw_write32_mask(rtwdev, REG_TXF1, MASKDWORD,\n\t\t\t\t\t 0x4962c931);\n\t\t\trtw_write32_mask(rtwdev, REG_TXF2, MASKLWORD, 0x6aa3);\n\t\t\trtw_write32_mask(rtwdev, REG_TXF3, MASKHWORD, 0xaa7b);\n\t\t\trtw_write32_mask(rtwdev, REG_TXF4, MASKLWORD, 0xf3d7);\n\t\t\trtw_write32_mask(rtwdev, REG_TXF5, MASKDWORD, 0x0);\n\t\t\trtw_write32_mask(rtwdev, REG_TXF6, MASKDWORD,\n\t\t\t\t\t 0xff012455);\n\t\t\trtw_write32_mask(rtwdev, REG_TXF7, MASKDWORD, 0xffff);\n\t\t} else {\n\t\t\trtw_write32_mask(rtwdev, REG_TXF0, MASKHWORD, 0x5284);\n\t\t\trtw_write32_mask(rtwdev, REG_TXF1, MASKDWORD,\n\t\t\t\t\t 0x3e18fec8);\n\t\t\trtw_write32_mask(rtwdev, REG_TXF2, MASKLWORD, 0x0a88);\n\t\t\trtw_write32_mask(rtwdev, REG_TXF3, MASKHWORD, 0xacc4);\n\t\t\trtw_write32_mask(rtwdev, REG_TXF4, MASKLWORD, 0xc8b2);\n\t\t\trtw_write32_mask(rtwdev, REG_TXF5, MASKDWORD,\n\t\t\t\t\t 0x00faf0de);\n\t\t\trtw_write32_mask(rtwdev, REG_TXF6, MASKDWORD,\n\t\t\t\t\t 0x00122344);\n\t\t\trtw_write32_mask(rtwdev, REG_TXF7, MASKDWORD,\n\t\t\t\t\t 0x0fffffff);\n\t\t}\n\t\tif (channel == 13)\n\t\t\trtw_write32_mask(rtwdev, REG_TXDFIR0, 0x70, 0x3);\n\t\telse\n\t\t\trtw_write32_mask(rtwdev, REG_TXDFIR0, 0x70, 0x1);\n\t} else if (IS_CH_5G_BAND(channel)) {\n\t\trtw_write32_set(rtwdev, REG_CCKTXONLY, BIT_BB_CCK_CHECK_EN);\n\t\trtw_write32_set(rtwdev, REG_CCK_CHECK, BIT_CHECK_CCK_EN);\n\t\trtw_write32_set(rtwdev, REG_BGCTRL, BITS_RX_IQ_WEIGHT);\n\t\trtw_write32_clr(rtwdev, REG_TXF4, BIT(20));\n\t\trtw_write32_mask(rtwdev, REG_CCAMSK, 0x3F000000, 0x22);\n\t\trtw_write32_mask(rtwdev, REG_TXDFIR0, 0x70, 0x3);\n\t\tif (IS_CH_5G_BAND_1(channel) || IS_CH_5G_BAND_2(channel)) {\n\t\t\trtw_write32_mask(rtwdev, REG_RXAGCCTL0, BITS_RXAGC_OFDM,\n\t\t\t\t\t 0x1);\n\t\t\trtw_write32_mask(rtwdev, REG_RXAGCCTL, BITS_RXAGC_OFDM,\n\t\t\t\t\t 0x1);\n\t\t} else if (IS_CH_5G_BAND_3(channel)) {\n\t\t\trtw_write32_mask(rtwdev, REG_RXAGCCTL0, BITS_RXAGC_OFDM,\n\t\t\t\t\t 0x2);\n\t\t\trtw_write32_mask(rtwdev, REG_RXAGCCTL, BITS_RXAGC_OFDM,\n\t\t\t\t\t 0x2);\n\t\t} else if (IS_CH_5G_BAND_4(channel)) {\n\t\t\trtw_write32_mask(rtwdev, REG_RXAGCCTL0, BITS_RXAGC_OFDM,\n\t\t\t\t\t 0x3);\n\t\t\trtw_write32_mask(rtwdev, REG_RXAGCCTL, BITS_RXAGC_OFDM,\n\t\t\t\t\t 0x3);\n\t\t}\n\n\t\tif (channel >= 36 && channel <= 51)\n\t\t\trtw_write32_mask(rtwdev, REG_SCOTRK, 0xfff, 0x494);\n\t\telse if (channel >= 52 && channel <= 55)\n\t\t\trtw_write32_mask(rtwdev, REG_SCOTRK, 0xfff, 0x493);\n\t\telse if (channel >= 56 && channel <= 111)\n\t\t\trtw_write32_mask(rtwdev, REG_SCOTRK, 0xfff, 0x453);\n\t\telse if (channel >= 112 && channel <= 119)\n\t\t\trtw_write32_mask(rtwdev, REG_SCOTRK, 0xfff, 0x452);\n\t\telse if (channel >= 120 && channel <= 172)\n\t\t\trtw_write32_mask(rtwdev, REG_SCOTRK, 0xfff, 0x412);\n\t\telse if (channel >= 173 && channel <= 177)\n\t\t\trtw_write32_mask(rtwdev, REG_SCOTRK, 0xfff, 0x411);\n\t}\n\n\tswitch (bw) {\n\tcase RTW_CHANNEL_WIDTH_20:\n\t\trtw_write32_mask(rtwdev, REG_DFIRBW, 0x3FF0, 0x19B);\n\t\trtw_write32_mask(rtwdev, REG_TXBWCTL, 0xf, 0x0);\n\t\trtw_write32_mask(rtwdev, REG_TXBWCTL, 0xffc0, 0x0);\n\t\trtw_write32_mask(rtwdev, REG_TXCLK, 0x700, 0x7);\n\t\trtw_write32_mask(rtwdev, REG_TXCLK, 0x700000, 0x6);\n\t\trtw_write32_mask(rtwdev, REG_CCK_SOURCE, BIT_NBI_EN, 0x0);\n\t\trtw_write32_mask(rtwdev, REG_SBD, BITS_SUBTUNE, 0x1);\n\t\trtw_write32_mask(rtwdev, REG_PT_CHSMO, BIT_PT_OPT, 0x0);\n\t\tbreak;\n\tcase RTW_CHANNEL_WIDTH_40:\n\t\trtw_write32_mask(rtwdev, REG_CCKSB, BIT(4),\n\t\t\t\t (primary_ch_idx == RTW_SC_20_UPPER ? 1 : 0));\n\t\trtw_write32_mask(rtwdev, REG_TXBWCTL, 0xf, 0x5);\n\t\trtw_write32_mask(rtwdev, REG_TXBWCTL, 0xc0, 0x0);\n\t\trtw_write32_mask(rtwdev, REG_TXBWCTL, 0xff00,\n\t\t\t\t (primary_ch_idx | (primary_ch_idx << 4)));\n\t\trtw_write32_mask(rtwdev, REG_CCK_SOURCE, BIT_NBI_EN, 0x1);\n\t\trtw_write32_mask(rtwdev, REG_SBD, BITS_SUBTUNE, 0x1);\n\t\trtw_write32_mask(rtwdev, REG_PT_CHSMO, BIT_PT_OPT, 0x1);\n\t\tbreak;\n\tcase RTW_CHANNEL_WIDTH_80:\n\t\trtw_write32_mask(rtwdev, REG_TXBWCTL, 0xf, 0xa);\n\t\trtw_write32_mask(rtwdev, REG_TXBWCTL, 0xc0, 0x0);\n\t\trtw_write32_mask(rtwdev, REG_TXBWCTL, 0xff00,\n\t\t\t\t (primary_ch_idx | (primary_ch_idx << 4)));\n\t\trtw_write32_mask(rtwdev, REG_SBD, BITS_SUBTUNE, 0x6);\n\t\trtw_write32_mask(rtwdev, REG_PT_CHSMO, BIT_PT_OPT, 0x1);\n\t\tbreak;\n\tcase RTW_CHANNEL_WIDTH_5:\n\t\trtw_write32_mask(rtwdev, REG_DFIRBW, 0x3FF0, 0x2AB);\n\t\trtw_write32_mask(rtwdev, REG_TXBWCTL, 0xf, 0x0);\n\t\trtw_write32_mask(rtwdev, REG_TXBWCTL, 0xffc0, 0x1);\n\t\trtw_write32_mask(rtwdev, REG_TXCLK, 0x700, 0x4);\n\t\trtw_write32_mask(rtwdev, REG_TXCLK, 0x700000, 0x4);\n\t\trtw_write32_mask(rtwdev, REG_CCK_SOURCE, BIT_NBI_EN, 0x0);\n\t\trtw_write32_mask(rtwdev, REG_SBD, BITS_SUBTUNE, 0x1);\n\t\trtw_write32_mask(rtwdev, REG_PT_CHSMO, BIT_PT_OPT, 0x0);\n\t\tbreak;\n\tcase RTW_CHANNEL_WIDTH_10:\n\t\trtw_write32_mask(rtwdev, REG_DFIRBW, 0x3FF0, 0x2AB);\n\t\trtw_write32_mask(rtwdev, REG_TXBWCTL, 0xf, 0x0);\n\t\trtw_write32_mask(rtwdev, REG_TXBWCTL, 0xffc0, 0x2);\n\t\trtw_write32_mask(rtwdev, REG_TXCLK, 0x700, 0x6);\n\t\trtw_write32_mask(rtwdev, REG_TXCLK, 0x700000, 0x5);\n\t\trtw_write32_mask(rtwdev, REG_CCK_SOURCE, BIT_NBI_EN, 0x0);\n\t\trtw_write32_mask(rtwdev, REG_SBD, BITS_SUBTUNE, 0x1);\n\t\trtw_write32_mask(rtwdev, REG_PT_CHSMO, BIT_PT_OPT, 0x0);\n\t\tbreak;\n\t}\n}\n\nstatic void rtw8822c_set_channel(struct rtw_dev *rtwdev, u8 channel, u8 bw,\n\t\t\t\t u8 primary_chan_idx)\n{\n\trtw8822c_set_channel_bb(rtwdev, channel, bw, primary_chan_idx);\n\trtw_set_channel_mac(rtwdev, channel, bw, primary_chan_idx);\n\trtw8822c_set_channel_rf(rtwdev, channel, bw);\n\trtw8822c_toggle_igi(rtwdev);\n}\n\nstatic void rtw8822c_config_cck_rx_path(struct rtw_dev *rtwdev, u8 rx_path)\n{\n\tif (rx_path == BB_PATH_A || rx_path == BB_PATH_B) {\n\t\trtw_write32_mask(rtwdev, REG_CCANRX, 0x00060000, 0x0);\n\t\trtw_write32_mask(rtwdev, REG_CCANRX, 0x00600000, 0x0);\n\t} else if (rx_path == BB_PATH_AB) {\n\t\trtw_write32_mask(rtwdev, REG_CCANRX, 0x00600000, 0x1);\n\t\trtw_write32_mask(rtwdev, REG_CCANRX, 0x00060000, 0x1);\n\t}\n\n\tif (rx_path == BB_PATH_A)\n\t\trtw_write32_mask(rtwdev, REG_RXCCKSEL, 0x0f000000, 0x0);\n\telse if (rx_path == BB_PATH_B)\n\t\trtw_write32_mask(rtwdev, REG_RXCCKSEL, 0x0f000000, 0x5);\n\telse if (rx_path == BB_PATH_AB)\n\t\trtw_write32_mask(rtwdev, REG_RXCCKSEL, 0x0f000000, 0x1);\n}\n\nstatic void rtw8822c_config_ofdm_rx_path(struct rtw_dev *rtwdev, u8 rx_path)\n{\n\tif (rx_path == BB_PATH_A || rx_path == BB_PATH_B) {\n\t\trtw_write32_mask(rtwdev, REG_RXFNCTL, 0x300, 0x0);\n\t\trtw_write32_mask(rtwdev, REG_RXFNCTL, 0x600000, 0x0);\n\t\trtw_write32_mask(rtwdev, REG_AGCSWSH, BIT(17), 0x0);\n\t\trtw_write32_mask(rtwdev, REG_ANTWTPD, BIT(20), 0x0);\n\t\trtw_write32_mask(rtwdev, REG_MRCM, BIT(24), 0x0);\n\t} else if (rx_path == BB_PATH_AB) {\n\t\trtw_write32_mask(rtwdev, REG_RXFNCTL, 0x300, 0x1);\n\t\trtw_write32_mask(rtwdev, REG_RXFNCTL, 0x600000, 0x1);\n\t\trtw_write32_mask(rtwdev, REG_AGCSWSH, BIT(17), 0x1);\n\t\trtw_write32_mask(rtwdev, REG_ANTWTPD, BIT(20), 0x1);\n\t\trtw_write32_mask(rtwdev, REG_MRCM, BIT(24), 0x1);\n\t}\n\n\trtw_write32_mask(rtwdev, 0x824, 0x0f000000, rx_path);\n\trtw_write32_mask(rtwdev, 0x824, 0x000f0000, rx_path);\n}\n\nstatic void rtw8822c_config_rx_path(struct rtw_dev *rtwdev, u8 rx_path)\n{\n\trtw8822c_config_cck_rx_path(rtwdev, rx_path);\n\trtw8822c_config_ofdm_rx_path(rtwdev, rx_path);\n}\n\nstatic void rtw8822c_config_cck_tx_path(struct rtw_dev *rtwdev, u8 tx_path,\n\t\t\t\t\tbool is_tx2_path)\n{\n\tif (tx_path == BB_PATH_A) {\n\t\trtw_write32_mask(rtwdev, REG_RXCCKSEL, 0xf0000000, 0x8);\n\t} else if (tx_path == BB_PATH_B) {\n\t\trtw_write32_mask(rtwdev, REG_RXCCKSEL, 0xf0000000, 0x4);\n\t} else {\n\t\tif (is_tx2_path)\n\t\t\trtw_write32_mask(rtwdev, REG_RXCCKSEL, 0xf0000000, 0xc);\n\t\telse\n\t\t\trtw_write32_mask(rtwdev, REG_RXCCKSEL, 0xf0000000, 0x8);\n\t}\n\trtw8822c_bb_reset(rtwdev);\n}\n\nstatic void rtw8822c_config_ofdm_tx_path(struct rtw_dev *rtwdev, u8 tx_path,\n\t\t\t\t\t enum rtw_bb_path tx_path_sel_1ss)\n{\n\tif (tx_path == BB_PATH_A) {\n\t\trtw_write32_mask(rtwdev, REG_ANTMAP0, 0xff, 0x11);\n\t\trtw_write32_mask(rtwdev, REG_TXLGMAP, 0xff, 0x0);\n\t} else if (tx_path == BB_PATH_B) {\n\t\trtw_write32_mask(rtwdev, REG_ANTMAP0, 0xff, 0x12);\n\t\trtw_write32_mask(rtwdev, REG_TXLGMAP, 0xff, 0x0);\n\t} else {\n\t\tif (tx_path_sel_1ss == BB_PATH_AB) {\n\t\t\trtw_write32_mask(rtwdev, REG_ANTMAP0, 0xff, 0x33);\n\t\t\trtw_write32_mask(rtwdev, REG_TXLGMAP, 0xffff, 0x0404);\n\t\t} else if (tx_path_sel_1ss == BB_PATH_B) {\n\t\t\trtw_write32_mask(rtwdev, REG_ANTMAP0, 0xff, 0x32);\n\t\t\trtw_write32_mask(rtwdev, REG_TXLGMAP, 0xffff, 0x0400);\n\t\t} else if (tx_path_sel_1ss == BB_PATH_A) {\n\t\t\trtw_write32_mask(rtwdev, REG_ANTMAP0, 0xff, 0x31);\n\t\t\trtw_write32_mask(rtwdev, REG_TXLGMAP, 0xffff, 0x0400);\n\t\t}\n\t}\n\trtw8822c_bb_reset(rtwdev);\n}\n\nstatic void rtw8822c_config_tx_path(struct rtw_dev *rtwdev, u8 tx_path,\n\t\t\t\t    enum rtw_bb_path tx_path_sel_1ss,\n\t\t\t\t    enum rtw_bb_path tx_path_cck,\n\t\t\t\t    bool is_tx2_path)\n{\n\trtw8822c_config_cck_tx_path(rtwdev, tx_path_cck, is_tx2_path);\n\trtw8822c_config_ofdm_tx_path(rtwdev, tx_path, tx_path_sel_1ss);\n\trtw8822c_bb_reset(rtwdev);\n}\n\nstatic void rtw8822c_config_trx_mode(struct rtw_dev *rtwdev, u8 tx_path,\n\t\t\t\t     u8 rx_path, bool is_tx2_path)\n{\n\tif ((tx_path | rx_path) & BB_PATH_A)\n\t\trtw_write32_mask(rtwdev, REG_ORITXCODE, MASK20BITS, 0x33312);\n\telse\n\t\trtw_write32_mask(rtwdev, REG_ORITXCODE, MASK20BITS, 0x11111);\n\tif ((tx_path | rx_path) & BB_PATH_B)\n\t\trtw_write32_mask(rtwdev, REG_ORITXCODE2, MASK20BITS, 0x33312);\n\telse\n\t\trtw_write32_mask(rtwdev, REG_ORITXCODE2, MASK20BITS, 0x11111);\n\n\trtw8822c_config_rx_path(rtwdev, rx_path);\n\trtw8822c_config_tx_path(rtwdev, tx_path, BB_PATH_A, BB_PATH_A,\n\t\t\t\tis_tx2_path);\n\n\trtw8822c_toggle_igi(rtwdev);\n}\n\nstatic void query_phy_status_page0(struct rtw_dev *rtwdev, u8 *phy_status,\n\t\t\t\t   struct rtw_rx_pkt_stat *pkt_stat)\n{\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tu8 l_bnd, u_bnd;\n\tu8 gain_a, gain_b;\n\ts8 rx_power[RTW_RF_PATH_MAX];\n\ts8 min_rx_power = -120;\n\tu8 rssi;\n\tu8 channel;\n\tint path;\n\n\trx_power[RF_PATH_A] = GET_PHY_STAT_P0_PWDB_A(phy_status);\n\trx_power[RF_PATH_B] = GET_PHY_STAT_P0_PWDB_B(phy_status);\n\tl_bnd = dm_info->cck_gi_l_bnd;\n\tu_bnd = dm_info->cck_gi_u_bnd;\n\tgain_a = GET_PHY_STAT_P0_GAIN_A(phy_status);\n\tgain_b = GET_PHY_STAT_P0_GAIN_B(phy_status);\n\tif (gain_a < l_bnd)\n\t\trx_power[RF_PATH_A] += (l_bnd - gain_a) << 1;\n\telse if (gain_a > u_bnd)\n\t\trx_power[RF_PATH_A] -= (gain_a - u_bnd) << 1;\n\tif (gain_b < l_bnd)\n\t\trx_power[RF_PATH_B] += (l_bnd - gain_b) << 1;\n\telse if (gain_b > u_bnd)\n\t\trx_power[RF_PATH_B] -= (gain_b - u_bnd) << 1;\n\n\trx_power[RF_PATH_A] -= 110;\n\trx_power[RF_PATH_B] -= 110;\n\n\tchannel = GET_PHY_STAT_P0_CHANNEL(phy_status);\n\tif (channel == 0)\n\t\tchannel = rtwdev->hal.current_channel;\n\trtw_set_rx_freq_band(pkt_stat, channel);\n\n\tpkt_stat->rx_power[RF_PATH_A] = rx_power[RF_PATH_A];\n\tpkt_stat->rx_power[RF_PATH_B] = rx_power[RF_PATH_B];\n\n\tfor (path = 0; path <= rtwdev->hal.rf_path_num; path++) {\n\t\trssi = rtw_phy_rf_power_2_rssi(&pkt_stat->rx_power[path], 1);\n\t\tdm_info->rssi[path] = rssi;\n\t}\n\n\tpkt_stat->rssi = rtw_phy_rf_power_2_rssi(pkt_stat->rx_power, 1);\n\tpkt_stat->bw = RTW_CHANNEL_WIDTH_20;\n\tpkt_stat->signal_power = max(pkt_stat->rx_power[RF_PATH_A],\n\t\t\t\t     min_rx_power);\n}\n\nstatic void query_phy_status_page1(struct rtw_dev *rtwdev, u8 *phy_status,\n\t\t\t\t   struct rtw_rx_pkt_stat *pkt_stat)\n{\n\tstruct rtw_path_div *p_div = &rtwdev->dm_path_div;\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tu8 rxsc, bw;\n\ts8 min_rx_power = -120;\n\ts8 rx_evm;\n\tu8 evm_dbm = 0;\n\tu8 rssi;\n\tint path;\n\tu8 channel;\n\n\tif (pkt_stat->rate > DESC_RATE11M && pkt_stat->rate < DESC_RATEMCS0)\n\t\trxsc = GET_PHY_STAT_P1_L_RXSC(phy_status);\n\telse\n\t\trxsc = GET_PHY_STAT_P1_HT_RXSC(phy_status);\n\n\tif (rxsc >= 9 && rxsc <= 12)\n\t\tbw = RTW_CHANNEL_WIDTH_40;\n\telse if (rxsc >= 13)\n\t\tbw = RTW_CHANNEL_WIDTH_80;\n\telse\n\t\tbw = RTW_CHANNEL_WIDTH_20;\n\n\tchannel = GET_PHY_STAT_P1_CHANNEL(phy_status);\n\trtw_set_rx_freq_band(pkt_stat, channel);\n\n\tpkt_stat->rx_power[RF_PATH_A] = GET_PHY_STAT_P1_PWDB_A(phy_status) - 110;\n\tpkt_stat->rx_power[RF_PATH_B] = GET_PHY_STAT_P1_PWDB_B(phy_status) - 110;\n\tpkt_stat->rssi = rtw_phy_rf_power_2_rssi(pkt_stat->rx_power, 2);\n\tpkt_stat->bw = bw;\n\tpkt_stat->signal_power = max3(pkt_stat->rx_power[RF_PATH_A],\n\t\t\t\t      pkt_stat->rx_power[RF_PATH_B],\n\t\t\t\t      min_rx_power);\n\n\tdm_info->curr_rx_rate = pkt_stat->rate;\n\n\tpkt_stat->rx_evm[RF_PATH_A] = GET_PHY_STAT_P1_RXEVM_A(phy_status);\n\tpkt_stat->rx_evm[RF_PATH_B] = GET_PHY_STAT_P1_RXEVM_B(phy_status);\n\n\tpkt_stat->rx_snr[RF_PATH_A] = GET_PHY_STAT_P1_RXSNR_A(phy_status);\n\tpkt_stat->rx_snr[RF_PATH_B] = GET_PHY_STAT_P1_RXSNR_B(phy_status);\n\n\tpkt_stat->cfo_tail[RF_PATH_A] = GET_PHY_STAT_P1_CFO_TAIL_A(phy_status);\n\tpkt_stat->cfo_tail[RF_PATH_B] = GET_PHY_STAT_P1_CFO_TAIL_B(phy_status);\n\n\tfor (path = 0; path <= rtwdev->hal.rf_path_num; path++) {\n\t\trssi = rtw_phy_rf_power_2_rssi(&pkt_stat->rx_power[path], 1);\n\t\tdm_info->rssi[path] = rssi;\n\t\tif (path == RF_PATH_A) {\n\t\t\tp_div->path_a_sum += rssi;\n\t\t\tp_div->path_a_cnt++;\n\t\t} else if (path == RF_PATH_B) {\n\t\t\tp_div->path_b_sum += rssi;\n\t\t\tp_div->path_b_cnt++;\n\t\t}\n\t\tdm_info->rx_snr[path] = pkt_stat->rx_snr[path] >> 1;\n\t\tdm_info->cfo_tail[path] = (pkt_stat->cfo_tail[path] * 5) >> 1;\n\n\t\trx_evm = pkt_stat->rx_evm[path];\n\n\t\tif (rx_evm < 0) {\n\t\t\tif (rx_evm == S8_MIN)\n\t\t\t\tevm_dbm = 0;\n\t\t\telse\n\t\t\t\tevm_dbm = ((u8)-rx_evm >> 1);\n\t\t}\n\t\tdm_info->rx_evm_dbm[path] = evm_dbm;\n\t}\n\trtw_phy_parsing_cfo(rtwdev, pkt_stat);\n}\n\nstatic void query_phy_status(struct rtw_dev *rtwdev, u8 *phy_status,\n\t\t\t     struct rtw_rx_pkt_stat *pkt_stat)\n{\n\tu8 page;\n\n\tpage = *phy_status & 0xf;\n\n\tswitch (page) {\n\tcase 0:\n\t\tquery_phy_status_page0(rtwdev, phy_status, pkt_stat);\n\t\tbreak;\n\tcase 1:\n\t\tquery_phy_status_page1(rtwdev, phy_status, pkt_stat);\n\t\tbreak;\n\tdefault:\n\t\trtw_warn(rtwdev, \"unused phy status page (%d)\\n\", page);\n\t\treturn;\n\t}\n}\n\nstatic void rtw8822c_query_rx_desc(struct rtw_dev *rtwdev, u8 *rx_desc,\n\t\t\t\t   struct rtw_rx_pkt_stat *pkt_stat,\n\t\t\t\t   struct ieee80211_rx_status *rx_status)\n{\n\tstruct ieee80211_hdr *hdr;\n\tu32 desc_sz = rtwdev->chip->rx_pkt_desc_sz;\n\tu8 *phy_status = NULL;\n\n\tmemset(pkt_stat, 0, sizeof(*pkt_stat));\n\n\tpkt_stat->phy_status = GET_RX_DESC_PHYST(rx_desc);\n\tpkt_stat->icv_err = GET_RX_DESC_ICV_ERR(rx_desc);\n\tpkt_stat->crc_err = GET_RX_DESC_CRC32(rx_desc);\n\tpkt_stat->decrypted = !GET_RX_DESC_SWDEC(rx_desc) &&\n\t\t\t      GET_RX_DESC_ENC_TYPE(rx_desc) != RX_DESC_ENC_NONE;\n\tpkt_stat->is_c2h = GET_RX_DESC_C2H(rx_desc);\n\tpkt_stat->pkt_len = GET_RX_DESC_PKT_LEN(rx_desc);\n\tpkt_stat->drv_info_sz = GET_RX_DESC_DRV_INFO_SIZE(rx_desc);\n\tpkt_stat->shift = GET_RX_DESC_SHIFT(rx_desc);\n\tpkt_stat->rate = GET_RX_DESC_RX_RATE(rx_desc);\n\tpkt_stat->cam_id = GET_RX_DESC_MACID(rx_desc);\n\tpkt_stat->ppdu_cnt = GET_RX_DESC_PPDU_CNT(rx_desc);\n\tpkt_stat->tsf_low = GET_RX_DESC_TSFL(rx_desc);\n\n\t \n\tpkt_stat->drv_info_sz *= 8;\n\n\t \n\tif (pkt_stat->is_c2h)\n\t\treturn;\n\n\thdr = (struct ieee80211_hdr *)(rx_desc + desc_sz + pkt_stat->shift +\n\t\t\t\t       pkt_stat->drv_info_sz);\n\tpkt_stat->hdr = hdr;\n\tif (pkt_stat->phy_status) {\n\t\tphy_status = rx_desc + desc_sz + pkt_stat->shift;\n\t\tquery_phy_status(rtwdev, phy_status, pkt_stat);\n\t}\n\n\trtw_rx_fill_rx_status(rtwdev, pkt_stat, hdr, rx_status, phy_status);\n}\n\nstatic void\nrtw8822c_set_write_tx_power_ref(struct rtw_dev *rtwdev, u8 *tx_pwr_ref_cck,\n\t\t\t\tu8 *tx_pwr_ref_ofdm)\n{\n\tstruct rtw_hal *hal = &rtwdev->hal;\n\tu32 txref_cck[2] = {0x18a0, 0x41a0};\n\tu32 txref_ofdm[2] = {0x18e8, 0x41e8};\n\tu8 path;\n\n\tfor (path = 0; path < hal->rf_path_num; path++) {\n\t\trtw_write32_mask(rtwdev, 0x1c90, BIT(15), 0);\n\t\trtw_write32_mask(rtwdev, txref_cck[path], 0x7f0000,\n\t\t\t\t tx_pwr_ref_cck[path]);\n\t}\n\tfor (path = 0; path < hal->rf_path_num; path++) {\n\t\trtw_write32_mask(rtwdev, 0x1c90, BIT(15), 0);\n\t\trtw_write32_mask(rtwdev, txref_ofdm[path], 0x1fc00,\n\t\t\t\t tx_pwr_ref_ofdm[path]);\n\t}\n}\n\nstatic void rtw8822c_set_tx_power_diff(struct rtw_dev *rtwdev, u8 rate,\n\t\t\t\t       s8 *diff_idx)\n{\n\tu32 offset_txagc = 0x3a00;\n\tu8 rate_idx = rate & 0xfc;\n\tu8 pwr_idx[4];\n\tu32 phy_pwr_idx;\n\tint i;\n\n\tfor (i = 0; i < 4; i++)\n\t\tpwr_idx[i] = diff_idx[i] & 0x7f;\n\n\tphy_pwr_idx = pwr_idx[0] |\n\t\t      (pwr_idx[1] << 8) |\n\t\t      (pwr_idx[2] << 16) |\n\t\t      (pwr_idx[3] << 24);\n\n\trtw_write32_mask(rtwdev, 0x1c90, BIT(15), 0x0);\n\trtw_write32_mask(rtwdev, offset_txagc + rate_idx, MASKDWORD,\n\t\t\t phy_pwr_idx);\n}\n\nstatic void rtw8822c_set_tx_power_index(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_hal *hal = &rtwdev->hal;\n\tu8 rs, rate, j;\n\tu8 pwr_ref_cck[2] = {hal->tx_pwr_tbl[RF_PATH_A][DESC_RATE11M],\n\t\t\t     hal->tx_pwr_tbl[RF_PATH_B][DESC_RATE11M]};\n\tu8 pwr_ref_ofdm[2] = {hal->tx_pwr_tbl[RF_PATH_A][DESC_RATEMCS7],\n\t\t\t      hal->tx_pwr_tbl[RF_PATH_B][DESC_RATEMCS7]};\n\ts8 diff_a, diff_b;\n\tu8 pwr_a, pwr_b;\n\ts8 diff_idx[4];\n\n\trtw8822c_set_write_tx_power_ref(rtwdev, pwr_ref_cck, pwr_ref_ofdm);\n\tfor (rs = 0; rs < RTW_RATE_SECTION_MAX; rs++) {\n\t\tfor (j = 0; j < rtw_rate_size[rs]; j++) {\n\t\t\trate = rtw_rate_section[rs][j];\n\t\t\tpwr_a = hal->tx_pwr_tbl[RF_PATH_A][rate];\n\t\t\tpwr_b = hal->tx_pwr_tbl[RF_PATH_B][rate];\n\t\t\tif (rs == 0) {\n\t\t\t\tdiff_a = (s8)pwr_a - (s8)pwr_ref_cck[0];\n\t\t\t\tdiff_b = (s8)pwr_b - (s8)pwr_ref_cck[1];\n\t\t\t} else {\n\t\t\t\tdiff_a = (s8)pwr_a - (s8)pwr_ref_ofdm[0];\n\t\t\t\tdiff_b = (s8)pwr_b - (s8)pwr_ref_ofdm[1];\n\t\t\t}\n\t\t\tdiff_idx[rate % 4] = min(diff_a, diff_b);\n\t\t\tif (rate % 4 == 3)\n\t\t\t\trtw8822c_set_tx_power_diff(rtwdev, rate - 3,\n\t\t\t\t\t\t\t   diff_idx);\n\t\t}\n\t}\n}\n\nstatic int rtw8822c_set_antenna(struct rtw_dev *rtwdev,\n\t\t\t\tu32 antenna_tx,\n\t\t\t\tu32 antenna_rx)\n{\n\tstruct rtw_hal *hal = &rtwdev->hal;\n\n\tswitch (antenna_tx) {\n\tcase BB_PATH_A:\n\tcase BB_PATH_B:\n\tcase BB_PATH_AB:\n\t\tbreak;\n\tdefault:\n\t\trtw_warn(rtwdev, \"unsupported tx path 0x%x\\n\", antenna_tx);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (antenna_rx) {\n\tcase BB_PATH_A:\n\tcase BB_PATH_AB:\n\t\tbreak;\n\tdefault:\n\t\trtw_warn(rtwdev, \"unsupported rx path 0x%x\\n\", antenna_rx);\n\t\treturn -EINVAL;\n\t}\n\n\thal->antenna_tx = antenna_tx;\n\thal->antenna_rx = antenna_rx;\n\n\trtw8822c_config_trx_mode(rtwdev, antenna_tx, antenna_rx, false);\n\n\treturn 0;\n}\n\nstatic void rtw8822c_cfg_ldo25(struct rtw_dev *rtwdev, bool enable)\n{\n\tu8 ldo_pwr;\n\n\tldo_pwr = rtw_read8(rtwdev, REG_ANAPARLDO_POW_MAC);\n\tldo_pwr = enable ? ldo_pwr | BIT_LDOE25_PON : ldo_pwr & ~BIT_LDOE25_PON;\n\trtw_write8(rtwdev, REG_ANAPARLDO_POW_MAC, ldo_pwr);\n}\n\nstatic void rtw8822c_false_alarm_statistics(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tu32 cck_enable;\n\tu32 cck_fa_cnt;\n\tu32 crc32_cnt;\n\tu32 cca32_cnt;\n\tu32 ofdm_fa_cnt;\n\tu32 ofdm_fa_cnt1, ofdm_fa_cnt2, ofdm_fa_cnt3, ofdm_fa_cnt4, ofdm_fa_cnt5;\n\tu16 parity_fail, rate_illegal, crc8_fail, mcs_fail, sb_search_fail,\n\t    fast_fsync, crc8_fail_vhta, mcs_fail_vht;\n\n\tcck_enable = rtw_read32(rtwdev, REG_ENCCK) & BIT_CCK_BLK_EN;\n\tcck_fa_cnt = rtw_read16(rtwdev, REG_CCK_FACNT);\n\n\tofdm_fa_cnt1 = rtw_read32(rtwdev, REG_OFDM_FACNT1);\n\tofdm_fa_cnt2 = rtw_read32(rtwdev, REG_OFDM_FACNT2);\n\tofdm_fa_cnt3 = rtw_read32(rtwdev, REG_OFDM_FACNT3);\n\tofdm_fa_cnt4 = rtw_read32(rtwdev, REG_OFDM_FACNT4);\n\tofdm_fa_cnt5 = rtw_read32(rtwdev, REG_OFDM_FACNT5);\n\n\tparity_fail\t= FIELD_GET(GENMASK(31, 16), ofdm_fa_cnt1);\n\trate_illegal\t= FIELD_GET(GENMASK(15, 0), ofdm_fa_cnt2);\n\tcrc8_fail\t= FIELD_GET(GENMASK(31, 16), ofdm_fa_cnt2);\n\tcrc8_fail_vhta\t= FIELD_GET(GENMASK(15, 0), ofdm_fa_cnt3);\n\tmcs_fail\t= FIELD_GET(GENMASK(15, 0), ofdm_fa_cnt4);\n\tmcs_fail_vht\t= FIELD_GET(GENMASK(31, 16), ofdm_fa_cnt4);\n\tfast_fsync\t= FIELD_GET(GENMASK(15, 0), ofdm_fa_cnt5);\n\tsb_search_fail\t= FIELD_GET(GENMASK(31, 16), ofdm_fa_cnt5);\n\n\tofdm_fa_cnt = parity_fail + rate_illegal + crc8_fail + crc8_fail_vhta +\n\t\t      mcs_fail + mcs_fail_vht + fast_fsync + sb_search_fail;\n\n\tdm_info->cck_fa_cnt = cck_fa_cnt;\n\tdm_info->ofdm_fa_cnt = ofdm_fa_cnt;\n\tdm_info->total_fa_cnt = ofdm_fa_cnt;\n\tdm_info->total_fa_cnt += cck_enable ? cck_fa_cnt : 0;\n\n\tcrc32_cnt = rtw_read32(rtwdev, 0x2c04);\n\tdm_info->cck_ok_cnt = crc32_cnt & 0xffff;\n\tdm_info->cck_err_cnt = (crc32_cnt & 0xffff0000) >> 16;\n\tcrc32_cnt = rtw_read32(rtwdev, 0x2c14);\n\tdm_info->ofdm_ok_cnt = crc32_cnt & 0xffff;\n\tdm_info->ofdm_err_cnt = (crc32_cnt & 0xffff0000) >> 16;\n\tcrc32_cnt = rtw_read32(rtwdev, 0x2c10);\n\tdm_info->ht_ok_cnt = crc32_cnt & 0xffff;\n\tdm_info->ht_err_cnt = (crc32_cnt & 0xffff0000) >> 16;\n\tcrc32_cnt = rtw_read32(rtwdev, 0x2c0c);\n\tdm_info->vht_ok_cnt = crc32_cnt & 0xffff;\n\tdm_info->vht_err_cnt = (crc32_cnt & 0xffff0000) >> 16;\n\n\tcca32_cnt = rtw_read32(rtwdev, 0x2c08);\n\tdm_info->ofdm_cca_cnt = ((cca32_cnt & 0xffff0000) >> 16);\n\tdm_info->cck_cca_cnt = cca32_cnt & 0xffff;\n\tdm_info->total_cca_cnt = dm_info->ofdm_cca_cnt;\n\tif (cck_enable)\n\t\tdm_info->total_cca_cnt += dm_info->cck_cca_cnt;\n\n\trtw_write32_mask(rtwdev, REG_CCANRX, BIT_CCK_FA_RST, 0);\n\trtw_write32_mask(rtwdev, REG_CCANRX, BIT_CCK_FA_RST, 2);\n\trtw_write32_mask(rtwdev, REG_CCANRX, BIT_OFDM_FA_RST, 0);\n\trtw_write32_mask(rtwdev, REG_CCANRX, BIT_OFDM_FA_RST, 2);\n\n\t \n\trtw_write32_clr(rtwdev, REG_RX_BREAK, BIT_COM_RX_GCK_EN);\n\trtw_write32_set(rtwdev, REG_CNT_CTRL, BIT_ALL_CNT_RST);\n\trtw_write32_clr(rtwdev, REG_CNT_CTRL, BIT_ALL_CNT_RST);\n\trtw_write32_set(rtwdev, REG_RX_BREAK, BIT_COM_RX_GCK_EN);\n}\n\nstatic void rtw8822c_do_lck(struct rtw_dev *rtwdev)\n{\n\tu32 val;\n\n\trtw_write_rf(rtwdev, RF_PATH_A, RF_SYN_CTRL, RFREG_MASK, 0x80010);\n\trtw_write_rf(rtwdev, RF_PATH_A, RF_SYN_PFD, RFREG_MASK, 0x1F0FA);\n\tfsleep(1);\n\trtw_write_rf(rtwdev, RF_PATH_A, RF_AAC_CTRL, RFREG_MASK, 0x80000);\n\trtw_write_rf(rtwdev, RF_PATH_A, RF_SYN_AAC, RFREG_MASK, 0x80001);\n\tread_poll_timeout(rtw_read_rf, val, val != 0x1, 1000, 100000,\n\t\t\t  true, rtwdev, RF_PATH_A, RF_AAC_CTRL, 0x1000);\n\trtw_write_rf(rtwdev, RF_PATH_A, RF_SYN_PFD, RFREG_MASK, 0x1F0F8);\n\trtw_write_rf(rtwdev, RF_PATH_B, RF_SYN_CTRL, RFREG_MASK, 0x80010);\n\n\trtw_write_rf(rtwdev, RF_PATH_A, RF_FAST_LCK, RFREG_MASK, 0x0f000);\n\trtw_write_rf(rtwdev, RF_PATH_A, RF_FAST_LCK, RFREG_MASK, 0x4f000);\n\tfsleep(1);\n\trtw_write_rf(rtwdev, RF_PATH_A, RF_FAST_LCK, RFREG_MASK, 0x0f000);\n}\n\nstatic void rtw8822c_do_iqk(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_iqk_para para = {0};\n\tu8 iqk_chk;\n\tint ret;\n\n\tpara.clear = 1;\n\trtw_fw_do_iqk(rtwdev, &para);\n\n\tret = read_poll_timeout(rtw_read8, iqk_chk, iqk_chk == IQK_DONE_8822C,\n\t\t\t\t20000, 300000, false, rtwdev, REG_RPT_CIP);\n\tif (ret)\n\t\trtw_warn(rtwdev, \"failed to poll iqk status bit\\n\");\n\n\trtw_write8(rtwdev, REG_IQKSTAT, 0x0);\n}\n\n \nstatic void rtw8822c_coex_cfg_init(struct rtw_dev *rtwdev)\n{\n\t \n\trtw_write8_set(rtwdev, REG_BCN_CTRL, BIT_EN_BCN_FUNCTION);\n\n\t \n\t \n\trtw_write8_mask(rtwdev, REG_BT_TDMA_TIME, BIT_MASK_SAMPLE_RATE, 0x5);\n\n\t \n\trtw_write8(rtwdev, REG_BT_STAT_CTRL, 0x1);\n\n\t \n\trtw_write32_set(rtwdev, REG_GPIO_MUXCFG, BIT_BT_PTA_EN);\n\trtw_write32_set(rtwdev, REG_GPIO_MUXCFG, BIT_PO_BT_PTA_PINS);\n\n\t \n\trtw_write8_set(rtwdev, REG_QUEUE_CTRL, BIT_PTA_WL_TX_EN);\n\t \n\trtw_write8_clr(rtwdev, REG_QUEUE_CTRL, BIT_PTA_EDCCA_EN);\n\t \n\trtw_write16_set(rtwdev, REG_BT_COEX_V2, BIT_GNT_BT_POLARITY);\n\t \n\trtw_write8_clr(rtwdev, REG_DUMMY_PAGE4_V1, BIT_BTCCA_CTRL);\n\n\t \n\trtw_write_rf(rtwdev, RF_PATH_B, RF_MODOPT, 0xfffff, 0x40000);\n}\n\nstatic void rtw8822c_coex_cfg_gnt_fix(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\tu32 rf_0x1;\n\n\tif (coex_stat->gnt_workaround_state == coex_stat->wl_coex_mode)\n\t\treturn;\n\n\tcoex_stat->gnt_workaround_state = coex_stat->wl_coex_mode;\n\n\tif ((coex_stat->kt_ver == 0 && coex->under_5g) || coex->freerun)\n\t\trf_0x1 = 0x40021;\n\telse\n\t\trf_0x1 = 0x40000;\n\n\t \n\tif (efuse->share_ant)\n\t\trf_0x1 |= BIT(13);\n\n\trtw_write_rf(rtwdev, RF_PATH_B, 0x1, 0xfffff, rf_0x1);\n\n\t \n\tif (coex_stat->wl_coex_mode == COEX_WLINK_2GFREE) {\n\t\trtw_write8_mask(rtwdev, REG_ANAPAR + 2,\n\t\t\t\tBIT_ANAPAR_BTPS >> 16, 0);\n\t} else {\n\t\trtw_write8_mask(rtwdev, REG_ANAPAR + 2,\n\t\t\t\tBIT_ANAPAR_BTPS >> 16, 1);\n\t\trtw_write8_mask(rtwdev, REG_RSTB_SEL + 1,\n\t\t\t\tBIT_DAC_OFF_ENABLE, 0);\n\t\trtw_write8_mask(rtwdev, REG_RSTB_SEL + 3,\n\t\t\t\tBIT_DAC_OFF_ENABLE, 1);\n\t}\n\n\t \n\trtw_write8_mask(rtwdev, REG_IGN_GNTBT4,\n\t\t\tBIT_PI_IGNORE_GNT_BT, 1);\n\n\t \n\tif (coex_stat->wl_coex_mode == COEX_WLINK_2GFREE) {\n\t\trtw_write8_mask(rtwdev, REG_IGN_GNT_BT1,\n\t\t\t\tBIT_PI_IGNORE_GNT_BT, 1);\n\t\trtw_write8_mask(rtwdev, REG_NOMASK_TXBT,\n\t\t\t\tBIT_NOMASK_TXBT_ENABLE, 1);\n\t} else if (coex_stat->wl_coex_mode == COEX_WLINK_5G ||\n\t    coex->under_5g || !efuse->share_ant) {\n\t\tif (coex_stat->kt_ver >= 3) {\n\t\t\trtw_write8_mask(rtwdev, REG_IGN_GNT_BT1,\n\t\t\t\t\tBIT_PI_IGNORE_GNT_BT, 0);\n\t\t\trtw_write8_mask(rtwdev, REG_NOMASK_TXBT,\n\t\t\t\t\tBIT_NOMASK_TXBT_ENABLE, 1);\n\t\t} else {\n\t\t\trtw_write8_mask(rtwdev, REG_IGN_GNT_BT1,\n\t\t\t\t\tBIT_PI_IGNORE_GNT_BT, 1);\n\t\t}\n\t} else {\n\t\t \n\t\trtw_write8_mask(rtwdev, REG_IGN_GNT_BT1,\n\t\t\t\tBIT_PI_IGNORE_GNT_BT, 0);\n\t\tif (coex_stat->kt_ver >= 3) {\n\t\t\trtw_write8_mask(rtwdev, REG_NOMASK_TXBT,\n\t\t\t\t\tBIT_NOMASK_TXBT_ENABLE, 0);\n\t\t}\n\t}\n}\n\nstatic void rtw8822c_coex_cfg_gnt_debug(struct rtw_dev *rtwdev)\n{\n\trtw_write8_mask(rtwdev, REG_PAD_CTRL1 + 2, BIT_BTGP_SPI_EN >> 16, 0);\n\trtw_write8_mask(rtwdev, REG_PAD_CTRL1 + 3, BIT_BTGP_JTAG_EN >> 24, 0);\n\trtw_write8_mask(rtwdev, REG_GPIO_MUXCFG + 2, BIT_FSPI_EN >> 16, 0);\n\trtw_write8_mask(rtwdev, REG_PAD_CTRL1 + 1, BIT_LED1DIS >> 8, 0);\n\trtw_write8_mask(rtwdev, REG_SYS_SDIO_CTRL + 3, BIT_DBG_GNT_WL_BT >> 24, 0);\n}\n\nstatic void rtw8822c_coex_cfg_rfe_type(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_rfe *coex_rfe = &coex->rfe;\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\n\tcoex_rfe->rfe_module_type = rtwdev->efuse.rfe_option;\n\tcoex_rfe->ant_switch_polarity = 0;\n\tcoex_rfe->ant_switch_exist = false;\n\tcoex_rfe->ant_switch_with_bt = false;\n\tcoex_rfe->ant_switch_diversity = false;\n\n\tif (efuse->share_ant)\n\t\tcoex_rfe->wlg_at_btg = true;\n\telse\n\t\tcoex_rfe->wlg_at_btg = false;\n\n\t \n\trtw_coex_write_indirect_reg(rtwdev, LTE_COEX_CTRL, BIT_LTE_COEX_EN, 0x0);\n\trtw_coex_write_indirect_reg(rtwdev, LTE_WL_TRX_CTRL, MASKLWORD, 0xffff);\n\trtw_coex_write_indirect_reg(rtwdev, LTE_BT_TRX_CTRL, MASKLWORD, 0xffff);\n}\n\nstatic void rtw8822c_coex_cfg_wl_tx_power(struct rtw_dev *rtwdev, u8 wl_pwr)\n{\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_dm *coex_dm = &coex->dm;\n\n\tif (wl_pwr == coex_dm->cur_wl_pwr_lvl)\n\t\treturn;\n\n\tcoex_dm->cur_wl_pwr_lvl = wl_pwr;\n}\n\nstatic void rtw8822c_coex_cfg_wl_rx_gain(struct rtw_dev *rtwdev, bool low_gain)\n{\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_dm *coex_dm = &coex->dm;\n\n\tif (low_gain == coex_dm->cur_wl_rx_low_gain_en)\n\t\treturn;\n\n\tcoex_dm->cur_wl_rx_low_gain_en = low_gain;\n\n\tif (coex_dm->cur_wl_rx_low_gain_en) {\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], Hi-Li Table On!\\n\");\n\n\t\t \n\t\trtw_write_rf(rtwdev, RF_PATH_A, RF_RCKD, RFREG_MASK, 0x22);\n\t\trtw_write_rf(rtwdev, RF_PATH_A, RF_RCK, RFREG_MASK, 0x36);\n\t\trtw_write_rf(rtwdev, RF_PATH_B, RF_RCKD, RFREG_MASK, 0x22);\n\t\trtw_write_rf(rtwdev, RF_PATH_B, RF_RCK, RFREG_MASK, 0x36);\n\n\t} else {\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], Hi-Li Table Off!\\n\");\n\n\t\t \n\t\trtw_write_rf(rtwdev, RF_PATH_A, RF_RCKD, RFREG_MASK, 0x20);\n\t\trtw_write_rf(rtwdev, RF_PATH_A, RF_RCK, RFREG_MASK, 0x0);\n\t\trtw_write_rf(rtwdev, RF_PATH_B, RF_RCKD, RFREG_MASK, 0x20);\n\t\trtw_write_rf(rtwdev, RF_PATH_B, RF_RCK, RFREG_MASK, 0x0);\n\t}\n}\n\nstatic void rtw8822c_bf_enable_bfee_su(struct rtw_dev *rtwdev,\n\t\t\t\t       struct rtw_vif *vif,\n\t\t\t\t       struct rtw_bfee *bfee)\n{\n\tu8 csi_rsc = 0;\n\tu32 tmp6dc;\n\n\trtw_bf_enable_bfee_su(rtwdev, vif, bfee);\n\n\ttmp6dc = rtw_read32(rtwdev, REG_BBPSF_CTRL) |\n\t\t\t    BIT_WMAC_USE_NDPARATE |\n\t\t\t    (csi_rsc << 13);\n\tif (vif->net_type == RTW_NET_AP_MODE)\n\t\trtw_write32(rtwdev, REG_BBPSF_CTRL, tmp6dc | BIT(12));\n\telse\n\t\trtw_write32(rtwdev, REG_BBPSF_CTRL, tmp6dc & ~BIT(12));\n\n\trtw_write32(rtwdev, REG_CSI_RRSR, 0x550);\n}\n\nstatic void rtw8822c_bf_config_bfee_su(struct rtw_dev *rtwdev,\n\t\t\t\t       struct rtw_vif *vif,\n\t\t\t\t       struct rtw_bfee *bfee, bool enable)\n{\n\tif (enable)\n\t\trtw8822c_bf_enable_bfee_su(rtwdev, vif, bfee);\n\telse\n\t\trtw_bf_remove_bfee_su(rtwdev, bfee);\n}\n\nstatic void rtw8822c_bf_config_bfee_mu(struct rtw_dev *rtwdev,\n\t\t\t\t       struct rtw_vif *vif,\n\t\t\t\t       struct rtw_bfee *bfee, bool enable)\n{\n\tif (enable)\n\t\trtw_bf_enable_bfee_mu(rtwdev, vif, bfee);\n\telse\n\t\trtw_bf_remove_bfee_mu(rtwdev, bfee);\n}\n\nstatic void rtw8822c_bf_config_bfee(struct rtw_dev *rtwdev, struct rtw_vif *vif,\n\t\t\t\t    struct rtw_bfee *bfee, bool enable)\n{\n\tif (bfee->role == RTW_BFEE_SU)\n\t\trtw8822c_bf_config_bfee_su(rtwdev, vif, bfee, enable);\n\telse if (bfee->role == RTW_BFEE_MU)\n\t\trtw8822c_bf_config_bfee_mu(rtwdev, vif, bfee, enable);\n\telse\n\t\trtw_warn(rtwdev, \"wrong bfee role\\n\");\n}\n\nstruct dpk_cfg_pair {\n\tu32 addr;\n\tu32 bitmask;\n\tu32 data;\n};\n\nvoid rtw8822c_parse_tbl_dpk(struct rtw_dev *rtwdev,\n\t\t\t    const struct rtw_table *tbl)\n{\n\tconst struct dpk_cfg_pair *p = tbl->data;\n\tconst struct dpk_cfg_pair *end = p + tbl->size / 3;\n\n\tBUILD_BUG_ON(sizeof(struct dpk_cfg_pair) != sizeof(u32) * 3);\n\n\tfor (; p < end; p++)\n\t\trtw_write32_mask(rtwdev, p->addr, p->bitmask, p->data);\n}\n\nstatic void rtw8822c_dpk_set_gnt_wl(struct rtw_dev *rtwdev, bool is_before_k)\n{\n\tstruct rtw_dpk_info *dpk_info = &rtwdev->dm_info.dpk_info;\n\n\tif (is_before_k) {\n\t\tdpk_info->gnt_control = rtw_read32(rtwdev, 0x70);\n\t\tdpk_info->gnt_value = rtw_coex_read_indirect_reg(rtwdev, 0x38);\n\t\trtw_write32_mask(rtwdev, 0x70, BIT(26), 0x1);\n\t\trtw_coex_write_indirect_reg(rtwdev, 0x38, MASKBYTE1, 0x77);\n\t} else {\n\t\trtw_coex_write_indirect_reg(rtwdev, 0x38, MASKDWORD,\n\t\t\t\t\t    dpk_info->gnt_value);\n\t\trtw_write32(rtwdev, 0x70, dpk_info->gnt_control);\n\t}\n}\n\nstatic void\nrtw8822c_dpk_restore_registers(struct rtw_dev *rtwdev, u32 reg_num,\n\t\t\t       struct rtw_backup_info *bckp)\n{\n\trtw_restore_reg(rtwdev, bckp, reg_num);\n\trtw_write32_mask(rtwdev, REG_NCTL0, BIT_SUBPAGE, 0xc);\n\trtw_write32_mask(rtwdev, REG_RXSRAM_CTL, BIT_DPD_CLK, 0x4);\n}\n\nstatic void\nrtw8822c_dpk_backup_registers(struct rtw_dev *rtwdev, u32 *reg,\n\t\t\t      u32 reg_num, struct rtw_backup_info *bckp)\n{\n\tu32 i;\n\n\tfor (i = 0; i < reg_num; i++) {\n\t\tbckp[i].len = 4;\n\t\tbckp[i].reg = reg[i];\n\t\tbckp[i].val = rtw_read32(rtwdev, reg[i]);\n\t}\n}\n\nstatic void rtw8822c_dpk_backup_rf_registers(struct rtw_dev *rtwdev,\n\t\t\t\t\t     u32 *rf_reg,\n\t\t\t\t\t     u32 rf_reg_bak[][2])\n{\n\tu32 i;\n\n\tfor (i = 0; i < DPK_RF_REG_NUM; i++) {\n\t\trf_reg_bak[i][RF_PATH_A] = rtw_read_rf(rtwdev, RF_PATH_A,\n\t\t\t\t\t\t       rf_reg[i], RFREG_MASK);\n\t\trf_reg_bak[i][RF_PATH_B] = rtw_read_rf(rtwdev, RF_PATH_B,\n\t\t\t\t\t\t       rf_reg[i], RFREG_MASK);\n\t}\n}\n\nstatic void rtw8822c_dpk_reload_rf_registers(struct rtw_dev *rtwdev,\n\t\t\t\t\t     u32 *rf_reg,\n\t\t\t\t\t     u32 rf_reg_bak[][2])\n{\n\tu32 i;\n\n\tfor (i = 0; i < DPK_RF_REG_NUM; i++) {\n\t\trtw_write_rf(rtwdev, RF_PATH_A, rf_reg[i], RFREG_MASK,\n\t\t\t     rf_reg_bak[i][RF_PATH_A]);\n\t\trtw_write_rf(rtwdev, RF_PATH_B, rf_reg[i], RFREG_MASK,\n\t\t\t     rf_reg_bak[i][RF_PATH_B]);\n\t}\n}\n\nstatic void rtw8822c_dpk_information(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_dpk_info *dpk_info = &rtwdev->dm_info.dpk_info;\n\tu32  reg;\n\tu8 band_shift;\n\n\treg = rtw_read_rf(rtwdev, RF_PATH_A, 0x18, RFREG_MASK);\n\n\tband_shift = FIELD_GET(BIT(16), reg);\n\tdpk_info->dpk_band = 1 << band_shift;\n\tdpk_info->dpk_ch = FIELD_GET(0xff, reg);\n\tdpk_info->dpk_bw = FIELD_GET(0x3000, reg);\n}\n\nstatic void rtw8822c_dpk_rxbb_dc_cal(struct rtw_dev *rtwdev, u8 path)\n{\n\trtw_write_rf(rtwdev, path, 0x92, RFREG_MASK, 0x84800);\n\tudelay(5);\n\trtw_write_rf(rtwdev, path, 0x92, RFREG_MASK, 0x84801);\n\tusleep_range(600, 610);\n\trtw_write_rf(rtwdev, path, 0x92, RFREG_MASK, 0x84800);\n}\n\nstatic u8 rtw8822c_dpk_dc_corr_check(struct rtw_dev *rtwdev, u8 path)\n{\n\tu16 dc_i, dc_q;\n\tu8 corr_idx;\n\n\trtw_write32(rtwdev, REG_RXSRAM_CTL, 0x000900f0);\n\tdc_i = (u16)rtw_read32_mask(rtwdev, REG_STAT_RPT, GENMASK(27, 16));\n\tdc_q = (u16)rtw_read32_mask(rtwdev, REG_STAT_RPT, GENMASK(11, 0));\n\n\tif (dc_i & BIT(11))\n\t\tdc_i = 0x1000 - dc_i;\n\tif (dc_q & BIT(11))\n\t\tdc_q = 0x1000 - dc_q;\n\n\trtw_write32(rtwdev, REG_RXSRAM_CTL, 0x000000f0);\n\tcorr_idx = (u8)rtw_read32_mask(rtwdev, REG_STAT_RPT, GENMASK(7, 0));\n\trtw_read32_mask(rtwdev, REG_STAT_RPT, GENMASK(15, 8));\n\n\tif (dc_i > 200 || dc_q > 200 || corr_idx < 40 || corr_idx > 65)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n\n}\n\nstatic void rtw8822c_dpk_tx_pause(struct rtw_dev *rtwdev)\n{\n\tu8 reg_a, reg_b;\n\tu16 count = 0;\n\n\trtw_write8(rtwdev, 0x522, 0xff);\n\trtw_write32_mask(rtwdev, 0x1e70, 0xf, 0x2);\n\n\tdo {\n\t\treg_a = (u8)rtw_read_rf(rtwdev, RF_PATH_A, 0x00, 0xf0000);\n\t\treg_b = (u8)rtw_read_rf(rtwdev, RF_PATH_B, 0x00, 0xf0000);\n\t\tudelay(2);\n\t\tcount++;\n\t} while ((reg_a == 2 || reg_b == 2) && count < 2500);\n}\n\nstatic void rtw8822c_dpk_mac_bb_setting(struct rtw_dev *rtwdev)\n{\n\trtw8822c_dpk_tx_pause(rtwdev);\n\trtw_load_table(rtwdev, &rtw8822c_dpk_mac_bb_tbl);\n}\n\nstatic void rtw8822c_dpk_afe_setting(struct rtw_dev *rtwdev, bool is_do_dpk)\n{\n\tif (is_do_dpk)\n\t\trtw_load_table(rtwdev, &rtw8822c_dpk_afe_is_dpk_tbl);\n\telse\n\t\trtw_load_table(rtwdev, &rtw8822c_dpk_afe_no_dpk_tbl);\n}\n\nstatic void rtw8822c_dpk_pre_setting(struct rtw_dev *rtwdev)\n{\n\tu8 path;\n\n\tfor (path = 0; path < rtwdev->hal.rf_path_num; path++) {\n\t\trtw_write_rf(rtwdev, path, RF_RXAGC_OFFSET, RFREG_MASK, 0x0);\n\t\trtw_write32(rtwdev, REG_NCTL0, 0x8 | (path << 1));\n\t\tif (rtwdev->dm_info.dpk_info.dpk_band == RTW_BAND_2G)\n\t\t\trtw_write32(rtwdev, REG_DPD_CTL1_S1, 0x1f100000);\n\t\telse\n\t\t\trtw_write32(rtwdev, REG_DPD_CTL1_S1, 0x1f0d0000);\n\t\trtw_write32_mask(rtwdev, REG_DPD_LUT0, BIT_GLOSS_DB, 0x4);\n\t\trtw_write32_mask(rtwdev, REG_IQK_CTL1, BIT_TX_CFIR, 0x3);\n\t}\n\trtw_write32_mask(rtwdev, REG_NCTL0, BIT_SUBPAGE, 0xc);\n\trtw_write32(rtwdev, REG_DPD_CTL11, 0x3b23170b);\n\trtw_write32(rtwdev, REG_DPD_CTL12, 0x775f5347);\n}\n\nstatic u32 rtw8822c_dpk_rf_setting(struct rtw_dev *rtwdev, u8 path)\n{\n\tu32 ori_txbb;\n\n\trtw_write_rf(rtwdev, path, RF_MODE_TRXAGC, RFREG_MASK, 0x50017);\n\tori_txbb = rtw_read_rf(rtwdev, path, RF_TX_GAIN, RFREG_MASK);\n\n\trtw_write_rf(rtwdev, path, RF_DEBUG, BIT_DE_TX_GAIN, 0x1);\n\trtw_write_rf(rtwdev, path, RF_DEBUG, BIT_DE_PWR_TRIM, 0x1);\n\trtw_write_rf(rtwdev, path, RF_TX_GAIN_OFFSET, BIT_BB_GAIN, 0x0);\n\trtw_write_rf(rtwdev, path, RF_TX_GAIN, RFREG_MASK, ori_txbb);\n\n\tif (rtwdev->dm_info.dpk_info.dpk_band == RTW_BAND_2G) {\n\t\trtw_write_rf(rtwdev, path, RF_TX_GAIN_OFFSET, BIT_RF_GAIN, 0x1);\n\t\trtw_write_rf(rtwdev, path, RF_RXG_GAIN, BIT_RXG_GAIN, 0x0);\n\t} else {\n\t\trtw_write_rf(rtwdev, path, RF_TXA_LB_SW, BIT_TXA_LB_ATT, 0x0);\n\t\trtw_write_rf(rtwdev, path, RF_TXA_LB_SW, BIT_LB_ATT, 0x6);\n\t\trtw_write_rf(rtwdev, path, RF_TXA_LB_SW, BIT_LB_SW, 0x1);\n\t\trtw_write_rf(rtwdev, path, RF_RXA_MIX_GAIN, BIT_RXA_MIX_GAIN, 0);\n\t}\n\n\trtw_write_rf(rtwdev, path, RF_MODE_TRXAGC, BIT_RXAGC, 0xf);\n\trtw_write_rf(rtwdev, path, RF_DEBUG, BIT_DE_TRXBW, 0x1);\n\trtw_write_rf(rtwdev, path, RF_BW_TRXBB, BIT_BW_RXBB, 0x0);\n\n\tif (rtwdev->dm_info.dpk_info.dpk_bw == DPK_CHANNEL_WIDTH_80)\n\t\trtw_write_rf(rtwdev, path, RF_BW_TRXBB, BIT_BW_TXBB, 0x2);\n\telse\n\t\trtw_write_rf(rtwdev, path, RF_BW_TRXBB, BIT_BW_TXBB, 0x1);\n\n\trtw_write_rf(rtwdev, path, RF_EXT_TIA_BW, BIT(1), 0x1);\n\n\tusleep_range(100, 110);\n\n\treturn ori_txbb & 0x1f;\n}\n\nstatic u16 rtw8822c_dpk_get_cmd(struct rtw_dev *rtwdev, u8 action, u8 path)\n{\n\tu16 cmd;\n\tu8 bw = rtwdev->dm_info.dpk_info.dpk_bw == DPK_CHANNEL_WIDTH_80 ? 2 : 0;\n\n\tswitch (action) {\n\tcase RTW_DPK_GAIN_LOSS:\n\t\tcmd = 0x14 + path;\n\t\tbreak;\n\tcase RTW_DPK_DO_DPK:\n\t\tcmd = 0x16 + path + bw;\n\t\tbreak;\n\tcase RTW_DPK_DPK_ON:\n\t\tcmd = 0x1a + path;\n\t\tbreak;\n\tcase RTW_DPK_DAGC:\n\t\tcmd = 0x1c + path + bw;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn (cmd << 8) | 0x48;\n}\n\nstatic u8 rtw8822c_dpk_one_shot(struct rtw_dev *rtwdev, u8 path, u8 action)\n{\n\tu16 dpk_cmd;\n\tu8 result = 0;\n\n\trtw8822c_dpk_set_gnt_wl(rtwdev, true);\n\n\tif (action == RTW_DPK_CAL_PWR) {\n\t\trtw_write32_mask(rtwdev, REG_DPD_CTL0, BIT(12), 0x1);\n\t\trtw_write32_mask(rtwdev, REG_DPD_CTL0, BIT(12), 0x0);\n\t\trtw_write32_mask(rtwdev, REG_RXSRAM_CTL, BIT_RPT_SEL, 0x0);\n\t\tmsleep(10);\n\t\tif (!check_hw_ready(rtwdev, REG_STAT_RPT, BIT(31), 0x1)) {\n\t\t\tresult = 1;\n\t\t\trtw_dbg(rtwdev, RTW_DBG_RFK, \"[DPK] one-shot over 20ms\\n\");\n\t\t}\n\t} else {\n\t\trtw_write32_mask(rtwdev, REG_NCTL0, BIT_SUBPAGE,\n\t\t\t\t 0x8 | (path << 1));\n\t\trtw_write32_mask(rtwdev, REG_R_CONFIG, BIT_IQ_SWITCH, 0x9);\n\n\t\tdpk_cmd = rtw8822c_dpk_get_cmd(rtwdev, action, path);\n\t\trtw_write32(rtwdev, REG_NCTL0, dpk_cmd);\n\t\trtw_write32(rtwdev, REG_NCTL0, dpk_cmd + 1);\n\t\tmsleep(10);\n\t\tif (!check_hw_ready(rtwdev, 0x2d9c, 0xff, 0x55)) {\n\t\t\tresult = 1;\n\t\t\trtw_dbg(rtwdev, RTW_DBG_RFK, \"[DPK] one-shot over 20ms\\n\");\n\t\t}\n\t\trtw_write32_mask(rtwdev, REG_NCTL0, BIT_SUBPAGE,\n\t\t\t\t 0x8 | (path << 1));\n\t\trtw_write32_mask(rtwdev, REG_R_CONFIG, BIT_IQ_SWITCH, 0x0);\n\t}\n\n\trtw8822c_dpk_set_gnt_wl(rtwdev, false);\n\n\trtw_write8(rtwdev, 0x1b10, 0x0);\n\n\treturn result;\n}\n\nstatic u16 rtw8822c_dpk_dgain_read(struct rtw_dev *rtwdev, u8 path)\n{\n\tu16 dgain;\n\n\trtw_write32_mask(rtwdev, REG_NCTL0, BIT_SUBPAGE, 0xc);\n\trtw_write32_mask(rtwdev, REG_RXSRAM_CTL, 0x00ff0000, 0x0);\n\n\tdgain = (u16)rtw_read32_mask(rtwdev, REG_STAT_RPT, GENMASK(27, 16));\n\n\treturn dgain;\n}\n\nstatic u8 rtw8822c_dpk_thermal_read(struct rtw_dev *rtwdev, u8 path)\n{\n\trtw_write_rf(rtwdev, path, RF_T_METER, BIT(19), 0x1);\n\trtw_write_rf(rtwdev, path, RF_T_METER, BIT(19), 0x0);\n\trtw_write_rf(rtwdev, path, RF_T_METER, BIT(19), 0x1);\n\tudelay(15);\n\n\treturn (u8)rtw_read_rf(rtwdev, path, RF_T_METER, 0x0007e);\n}\n\nstatic u32 rtw8822c_dpk_pas_read(struct rtw_dev *rtwdev, u8 path)\n{\n\tu32 i_val, q_val;\n\n\trtw_write32(rtwdev, REG_NCTL0, 0x8 | (path << 1));\n\trtw_write32_mask(rtwdev, 0x1b48, BIT(14), 0x0);\n\trtw_write32(rtwdev, REG_RXSRAM_CTL, 0x00060001);\n\trtw_write32(rtwdev, 0x1b4c, 0x00000000);\n\trtw_write32(rtwdev, 0x1b4c, 0x00080000);\n\n\tq_val = rtw_read32_mask(rtwdev, REG_STAT_RPT, MASKHWORD);\n\ti_val = rtw_read32_mask(rtwdev, REG_STAT_RPT, MASKLWORD);\n\n\tif (i_val & BIT(15))\n\t\ti_val = 0x10000 - i_val;\n\tif (q_val & BIT(15))\n\t\tq_val = 0x10000 - q_val;\n\n\trtw_write32(rtwdev, 0x1b4c, 0x00000000);\n\n\treturn i_val * i_val + q_val * q_val;\n}\n\nstatic u32 rtw8822c_psd_log2base(u32 val)\n{\n\tu32 tmp, val_integerd_b, tindex;\n\tu32 result, val_fractiond_b;\n\tu32 table_fraction[21] = {0, 432, 332, 274, 232, 200, 174,\n\t\t\t\t  151, 132, 115, 100, 86, 74, 62, 51,\n\t\t\t\t  42, 32, 23, 15, 7, 0};\n\n\tif (val == 0)\n\t\treturn 0;\n\n\tval_integerd_b = __fls(val) + 1;\n\n\ttmp = (val * 100) / (1 << val_integerd_b);\n\ttindex = tmp / 5;\n\n\tif (tindex >= ARRAY_SIZE(table_fraction))\n\t\ttindex = ARRAY_SIZE(table_fraction) - 1;\n\n\tval_fractiond_b = table_fraction[tindex];\n\n\tresult = val_integerd_b * 100 - val_fractiond_b;\n\n\treturn result;\n}\n\nstatic u8 rtw8822c_dpk_gainloss_result(struct rtw_dev *rtwdev, u8 path)\n{\n\tu8 result;\n\n\trtw_write32_mask(rtwdev, REG_NCTL0, BIT_SUBPAGE, 0x8 | (path << 1));\n\trtw_write32_mask(rtwdev, 0x1b48, BIT(14), 0x1);\n\trtw_write32(rtwdev, REG_RXSRAM_CTL, 0x00060000);\n\n\tresult = (u8)rtw_read32_mask(rtwdev, REG_STAT_RPT, 0x000000f0);\n\n\trtw_write32_mask(rtwdev, 0x1b48, BIT(14), 0x0);\n\n\treturn result;\n}\n\nstatic u8 rtw8822c_dpk_agc_gain_chk(struct rtw_dev *rtwdev, u8 path,\n\t\t\t\t    u8 limited_pga)\n{\n\tu8 result = 0;\n\tu16 dgain;\n\n\trtw8822c_dpk_one_shot(rtwdev, path, RTW_DPK_DAGC);\n\tdgain = rtw8822c_dpk_dgain_read(rtwdev, path);\n\n\tif (dgain > 1535 && !limited_pga)\n\t\treturn RTW_DPK_GAIN_LESS;\n\telse if (dgain < 768 && !limited_pga)\n\t\treturn RTW_DPK_GAIN_LARGE;\n\telse\n\t\treturn result;\n}\n\nstatic u8 rtw8822c_dpk_agc_loss_chk(struct rtw_dev *rtwdev, u8 path)\n{\n\tu32 loss, loss_db;\n\n\tloss = rtw8822c_dpk_pas_read(rtwdev, path);\n\tif (loss < 0x4000000)\n\t\treturn RTW_DPK_GL_LESS;\n\tloss_db = 3 * rtw8822c_psd_log2base(loss >> 13) - 3870;\n\n\tif (loss_db > 1000)\n\t\treturn RTW_DPK_GL_LARGE;\n\telse if (loss_db < 250)\n\t\treturn RTW_DPK_GL_LESS;\n\telse\n\t\treturn RTW_DPK_AGC_OUT;\n}\n\nstruct rtw8822c_dpk_data {\n\tu8 txbb;\n\tu8 pga;\n\tu8 limited_pga;\n\tu8 agc_cnt;\n\tbool loss_only;\n\tbool gain_only;\n\tu8 path;\n};\n\nstatic u8 rtw8822c_gain_check_state(struct rtw_dev *rtwdev,\n\t\t\t\t    struct rtw8822c_dpk_data *data)\n{\n\tu8 state;\n\n\tdata->txbb = (u8)rtw_read_rf(rtwdev, data->path, RF_TX_GAIN,\n\t\t\t\t     BIT_GAIN_TXBB);\n\tdata->pga = (u8)rtw_read_rf(rtwdev, data->path, RF_MODE_TRXAGC,\n\t\t\t\t    BIT_RXAGC);\n\n\tif (data->loss_only) {\n\t\tstate = RTW_DPK_LOSS_CHECK;\n\t\tgoto check_end;\n\t}\n\n\tstate = rtw8822c_dpk_agc_gain_chk(rtwdev, data->path,\n\t\t\t\t\t  data->limited_pga);\n\tif (state == RTW_DPK_GAIN_CHECK && data->gain_only)\n\t\tstate = RTW_DPK_AGC_OUT;\n\telse if (state == RTW_DPK_GAIN_CHECK)\n\t\tstate = RTW_DPK_LOSS_CHECK;\n\ncheck_end:\n\tdata->agc_cnt++;\n\tif (data->agc_cnt >= 6)\n\t\tstate = RTW_DPK_AGC_OUT;\n\n\treturn state;\n}\n\nstatic u8 rtw8822c_gain_large_state(struct rtw_dev *rtwdev,\n\t\t\t\t    struct rtw8822c_dpk_data *data)\n{\n\tu8 pga = data->pga;\n\n\tif (pga > 0xe)\n\t\trtw_write_rf(rtwdev, data->path, RF_MODE_TRXAGC, BIT_RXAGC, 0xc);\n\telse if (pga > 0xb && pga < 0xf)\n\t\trtw_write_rf(rtwdev, data->path, RF_MODE_TRXAGC, BIT_RXAGC, 0x0);\n\telse if (pga < 0xc)\n\t\tdata->limited_pga = 1;\n\n\treturn RTW_DPK_GAIN_CHECK;\n}\n\nstatic u8 rtw8822c_gain_less_state(struct rtw_dev *rtwdev,\n\t\t\t\t   struct rtw8822c_dpk_data *data)\n{\n\tu8 pga = data->pga;\n\n\tif (pga < 0xc)\n\t\trtw_write_rf(rtwdev, data->path, RF_MODE_TRXAGC, BIT_RXAGC, 0xc);\n\telse if (pga > 0xb && pga < 0xf)\n\t\trtw_write_rf(rtwdev, data->path, RF_MODE_TRXAGC, BIT_RXAGC, 0xf);\n\telse if (pga > 0xe)\n\t\tdata->limited_pga = 1;\n\n\treturn RTW_DPK_GAIN_CHECK;\n}\n\nstatic u8 rtw8822c_gl_state(struct rtw_dev *rtwdev,\n\t\t\t    struct rtw8822c_dpk_data *data, u8 is_large)\n{\n\tu8 txbb_bound[] = {0x1f, 0};\n\n\tif (data->txbb == txbb_bound[is_large])\n\t\treturn RTW_DPK_AGC_OUT;\n\n\tif (is_large == 1)\n\t\tdata->txbb -= 2;\n\telse\n\t\tdata->txbb += 3;\n\n\trtw_write_rf(rtwdev, data->path, RF_TX_GAIN, BIT_GAIN_TXBB, data->txbb);\n\tdata->limited_pga = 0;\n\n\treturn RTW_DPK_GAIN_CHECK;\n}\n\nstatic u8 rtw8822c_gl_large_state(struct rtw_dev *rtwdev,\n\t\t\t\t  struct rtw8822c_dpk_data *data)\n{\n\treturn rtw8822c_gl_state(rtwdev, data, 1);\n}\n\nstatic u8 rtw8822c_gl_less_state(struct rtw_dev *rtwdev,\n\t\t\t\t struct rtw8822c_dpk_data *data)\n{\n\treturn rtw8822c_gl_state(rtwdev, data, 0);\n}\n\nstatic u8 rtw8822c_loss_check_state(struct rtw_dev *rtwdev,\n\t\t\t\t    struct rtw8822c_dpk_data *data)\n{\n\tu8 path = data->path;\n\tu8 state;\n\n\trtw8822c_dpk_one_shot(rtwdev, path, RTW_DPK_GAIN_LOSS);\n\tstate = rtw8822c_dpk_agc_loss_chk(rtwdev, path);\n\n\treturn state;\n}\n\nstatic u8 (*dpk_state[])(struct rtw_dev *rtwdev,\n\t\t\t  struct rtw8822c_dpk_data *data) = {\n\trtw8822c_gain_check_state, rtw8822c_gain_large_state,\n\trtw8822c_gain_less_state, rtw8822c_gl_large_state,\n\trtw8822c_gl_less_state, rtw8822c_loss_check_state };\n\nstatic u8 rtw8822c_dpk_pas_agc(struct rtw_dev *rtwdev, u8 path,\n\t\t\t       bool gain_only, bool loss_only)\n{\n\tstruct rtw8822c_dpk_data data = {0};\n\tu8 (*func)(struct rtw_dev *rtwdev, struct rtw8822c_dpk_data *data);\n\tu8 state = RTW_DPK_GAIN_CHECK;\n\n\tdata.loss_only = loss_only;\n\tdata.gain_only = gain_only;\n\tdata.path = path;\n\n\tfor (;;) {\n\t\tfunc = dpk_state[state];\n\t\tstate = func(rtwdev, &data);\n\t\tif (state == RTW_DPK_AGC_OUT)\n\t\t\tbreak;\n\t}\n\n\treturn data.txbb;\n}\n\nstatic bool rtw8822c_dpk_coef_iq_check(struct rtw_dev *rtwdev,\n\t\t\t\t       u16 coef_i, u16 coef_q)\n{\n\tif (coef_i == 0x1000 || coef_i == 0x0fff ||\n\t    coef_q == 0x1000 || coef_q == 0x0fff)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic u32 rtw8822c_dpk_coef_transfer(struct rtw_dev *rtwdev)\n{\n\tu32 reg = 0;\n\tu16 coef_i = 0, coef_q = 0;\n\n\treg = rtw_read32(rtwdev, REG_STAT_RPT);\n\n\tcoef_i = (u16)rtw_read32_mask(rtwdev, REG_STAT_RPT, MASKHWORD) & 0x1fff;\n\tcoef_q = (u16)rtw_read32_mask(rtwdev, REG_STAT_RPT, MASKLWORD) & 0x1fff;\n\n\tcoef_q = ((0x2000 - coef_q) & 0x1fff) - 1;\n\n\treg = (coef_i << 16) | coef_q;\n\n\treturn reg;\n}\n\nstatic const u32 rtw8822c_dpk_get_coef_tbl[] = {\n\t0x000400f0, 0x040400f0, 0x080400f0, 0x010400f0, 0x050400f0,\n\t0x090400f0, 0x020400f0, 0x060400f0, 0x0a0400f0, 0x030400f0,\n\t0x070400f0, 0x0b0400f0, 0x0c0400f0, 0x100400f0, 0x0d0400f0,\n\t0x110400f0, 0x0e0400f0, 0x120400f0, 0x0f0400f0, 0x130400f0,\n};\n\nstatic void rtw8822c_dpk_coef_tbl_apply(struct rtw_dev *rtwdev, u8 path)\n{\n\tstruct rtw_dpk_info *dpk_info = &rtwdev->dm_info.dpk_info;\n\tint i;\n\n\tfor (i = 0; i < 20; i++) {\n\t\trtw_write32(rtwdev, REG_RXSRAM_CTL,\n\t\t\t    rtw8822c_dpk_get_coef_tbl[i]);\n\t\tdpk_info->coef[path][i] = rtw8822c_dpk_coef_transfer(rtwdev);\n\t}\n}\n\nstatic void rtw8822c_dpk_get_coef(struct rtw_dev *rtwdev, u8 path)\n{\n\trtw_write32(rtwdev, REG_NCTL0, 0x0000000c);\n\n\tif (path == RF_PATH_A) {\n\t\trtw_write32_mask(rtwdev, REG_DPD_CTL0, BIT(24), 0x0);\n\t\trtw_write32(rtwdev, REG_DPD_CTL0_S0, 0x30000080);\n\t} else if (path == RF_PATH_B) {\n\t\trtw_write32_mask(rtwdev, REG_DPD_CTL0, BIT(24), 0x1);\n\t\trtw_write32(rtwdev, REG_DPD_CTL0_S1, 0x30000080);\n\t}\n\n\trtw8822c_dpk_coef_tbl_apply(rtwdev, path);\n}\n\nstatic u8 rtw8822c_dpk_coef_read(struct rtw_dev *rtwdev, u8 path)\n{\n\tstruct rtw_dpk_info *dpk_info = &rtwdev->dm_info.dpk_info;\n\tu8 addr, result = 1;\n\tu16 coef_i, coef_q;\n\n\tfor (addr = 0; addr < 20; addr++) {\n\t\tcoef_i = FIELD_GET(0x1fff0000, dpk_info->coef[path][addr]);\n\t\tcoef_q = FIELD_GET(0x1fff, dpk_info->coef[path][addr]);\n\n\t\tif (rtw8822c_dpk_coef_iq_check(rtwdev, coef_i, coef_q)) {\n\t\t\tresult = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}\n\nstatic void rtw8822c_dpk_coef_write(struct rtw_dev *rtwdev, u8 path, u8 result)\n{\n\tstruct rtw_dpk_info *dpk_info = &rtwdev->dm_info.dpk_info;\n\tu16 reg[DPK_RF_PATH_NUM] = {0x1b0c, 0x1b64};\n\tu32 coef;\n\tu8 addr;\n\n\trtw_write32(rtwdev, REG_NCTL0, 0x0000000c);\n\trtw_write32(rtwdev, REG_RXSRAM_CTL, 0x000000f0);\n\n\tfor (addr = 0; addr < 20; addr++) {\n\t\tif (result == 0) {\n\t\t\tif (addr == 3)\n\t\t\t\tcoef = 0x04001fff;\n\t\t\telse\n\t\t\t\tcoef = 0x00001fff;\n\t\t} else {\n\t\t\tcoef = dpk_info->coef[path][addr];\n\t\t}\n\t\trtw_write32(rtwdev, reg[path] + addr * 4, coef);\n\t}\n}\n\nstatic void rtw8822c_dpk_fill_result(struct rtw_dev *rtwdev, u32 dpk_txagc,\n\t\t\t\t     u8 path, u8 result)\n{\n\tstruct rtw_dpk_info *dpk_info = &rtwdev->dm_info.dpk_info;\n\n\trtw_write32_mask(rtwdev, REG_NCTL0, BIT_SUBPAGE, 0x8 | (path << 1));\n\n\tif (result)\n\t\trtw_write8(rtwdev, REG_DPD_AGC, (u8)(dpk_txagc - 6));\n\telse\n\t\trtw_write8(rtwdev, REG_DPD_AGC, 0x00);\n\n\tdpk_info->result[path] = result;\n\tdpk_info->dpk_txagc[path] = rtw_read8(rtwdev, REG_DPD_AGC);\n\n\trtw8822c_dpk_coef_write(rtwdev, path, result);\n}\n\nstatic u32 rtw8822c_dpk_gainloss(struct rtw_dev *rtwdev, u8 path)\n{\n\tstruct rtw_dpk_info *dpk_info = &rtwdev->dm_info.dpk_info;\n\tu8 tx_agc, tx_bb, ori_txbb, ori_txagc, tx_agc_search, t1, t2;\n\n\tori_txbb = rtw8822c_dpk_rf_setting(rtwdev, path);\n\tori_txagc = (u8)rtw_read_rf(rtwdev, path, RF_MODE_TRXAGC, BIT_TXAGC);\n\n\trtw8822c_dpk_rxbb_dc_cal(rtwdev, path);\n\trtw8822c_dpk_one_shot(rtwdev, path, RTW_DPK_DAGC);\n\trtw8822c_dpk_dgain_read(rtwdev, path);\n\n\tif (rtw8822c_dpk_dc_corr_check(rtwdev, path)) {\n\t\trtw8822c_dpk_rxbb_dc_cal(rtwdev, path);\n\t\trtw8822c_dpk_one_shot(rtwdev, path, RTW_DPK_DAGC);\n\t\trtw8822c_dpk_dc_corr_check(rtwdev, path);\n\t}\n\n\tt1 = rtw8822c_dpk_thermal_read(rtwdev, path);\n\ttx_bb = rtw8822c_dpk_pas_agc(rtwdev, path, false, true);\n\ttx_agc_search = rtw8822c_dpk_gainloss_result(rtwdev, path);\n\n\tif (tx_bb < tx_agc_search)\n\t\ttx_bb = 0;\n\telse\n\t\ttx_bb = tx_bb - tx_agc_search;\n\n\trtw_write_rf(rtwdev, path, RF_TX_GAIN, BIT_GAIN_TXBB, tx_bb);\n\n\ttx_agc = ori_txagc - (ori_txbb - tx_bb);\n\n\tt2 = rtw8822c_dpk_thermal_read(rtwdev, path);\n\n\tdpk_info->thermal_dpk_delta[path] = abs(t2 - t1);\n\n\treturn tx_agc;\n}\n\nstatic u8 rtw8822c_dpk_by_path(struct rtw_dev *rtwdev, u32 tx_agc, u8 path)\n{\n\tu8 result;\n\n\tresult = rtw8822c_dpk_one_shot(rtwdev, path, RTW_DPK_DO_DPK);\n\n\trtw_write32_mask(rtwdev, REG_NCTL0, BIT_SUBPAGE, 0x8 | (path << 1));\n\n\tresult = result | (u8)rtw_read32_mask(rtwdev, REG_DPD_CTL1_S0, BIT(26));\n\n\trtw_write_rf(rtwdev, path, RF_MODE_TRXAGC, RFREG_MASK, 0x33e14);\n\n\trtw8822c_dpk_get_coef(rtwdev, path);\n\n\treturn result;\n}\n\nstatic void rtw8822c_dpk_cal_gs(struct rtw_dev *rtwdev, u8 path)\n{\n\tstruct rtw_dpk_info *dpk_info = &rtwdev->dm_info.dpk_info;\n\tu32 tmp_gs = 0;\n\n\trtw_write32_mask(rtwdev, REG_NCTL0, BIT_SUBPAGE, 0x8 | (path << 1));\n\trtw_write32_mask(rtwdev, REG_IQK_CTL1, BIT_BYPASS_DPD, 0x0);\n\trtw_write32_mask(rtwdev, REG_IQK_CTL1, BIT_TX_CFIR, 0x0);\n\trtw_write32_mask(rtwdev, REG_R_CONFIG, BIT_IQ_SWITCH, 0x9);\n\trtw_write32_mask(rtwdev, REG_R_CONFIG, BIT_INNER_LB, 0x1);\n\trtw_write32_mask(rtwdev, REG_NCTL0, BIT_SUBPAGE, 0xc);\n\trtw_write32_mask(rtwdev, REG_RXSRAM_CTL, BIT_DPD_CLK, 0xf);\n\n\tif (path == RF_PATH_A) {\n\t\trtw_write32_mask(rtwdev, REG_DPD_CTL0_S0, BIT_GS_PWSF,\n\t\t\t\t 0x1066680);\n\t\trtw_write32_mask(rtwdev, REG_DPD_CTL1_S0, BIT_DPD_EN, 0x1);\n\t} else {\n\t\trtw_write32_mask(rtwdev, REG_DPD_CTL0_S1, BIT_GS_PWSF,\n\t\t\t\t 0x1066680);\n\t\trtw_write32_mask(rtwdev, REG_DPD_CTL1_S1, BIT_DPD_EN, 0x1);\n\t}\n\n\tif (dpk_info->dpk_bw == DPK_CHANNEL_WIDTH_80) {\n\t\trtw_write32(rtwdev, REG_DPD_CTL16, 0x80001310);\n\t\trtw_write32(rtwdev, REG_DPD_CTL16, 0x00001310);\n\t\trtw_write32(rtwdev, REG_DPD_CTL16, 0x810000db);\n\t\trtw_write32(rtwdev, REG_DPD_CTL16, 0x010000db);\n\t\trtw_write32(rtwdev, REG_DPD_CTL16, 0x0000b428);\n\t\trtw_write32(rtwdev, REG_DPD_CTL15,\n\t\t\t    0x05020000 | (BIT(path) << 28));\n\t} else {\n\t\trtw_write32(rtwdev, REG_DPD_CTL16, 0x8200190c);\n\t\trtw_write32(rtwdev, REG_DPD_CTL16, 0x0200190c);\n\t\trtw_write32(rtwdev, REG_DPD_CTL16, 0x8301ee14);\n\t\trtw_write32(rtwdev, REG_DPD_CTL16, 0x0301ee14);\n\t\trtw_write32(rtwdev, REG_DPD_CTL16, 0x0000b428);\n\t\trtw_write32(rtwdev, REG_DPD_CTL15,\n\t\t\t    0x05020008 | (BIT(path) << 28));\n\t}\n\n\trtw_write32_mask(rtwdev, REG_DPD_CTL0, MASKBYTE3, 0x8 | path);\n\n\trtw8822c_dpk_one_shot(rtwdev, path, RTW_DPK_CAL_PWR);\n\n\trtw_write32_mask(rtwdev, REG_DPD_CTL15, MASKBYTE3, 0x0);\n\trtw_write32_mask(rtwdev, REG_NCTL0, BIT_SUBPAGE, 0x8 | (path << 1));\n\trtw_write32_mask(rtwdev, REG_R_CONFIG, BIT_IQ_SWITCH, 0x0);\n\trtw_write32_mask(rtwdev, REG_R_CONFIG, BIT_INNER_LB, 0x0);\n\trtw_write32_mask(rtwdev, REG_NCTL0, BIT_SUBPAGE, 0xc);\n\n\tif (path == RF_PATH_A)\n\t\trtw_write32_mask(rtwdev, REG_DPD_CTL0_S0, BIT_GS_PWSF, 0x5b);\n\telse\n\t\trtw_write32_mask(rtwdev, REG_DPD_CTL0_S1, BIT_GS_PWSF, 0x5b);\n\n\trtw_write32_mask(rtwdev, REG_RXSRAM_CTL, BIT_RPT_SEL, 0x0);\n\n\ttmp_gs = (u16)rtw_read32_mask(rtwdev, REG_STAT_RPT, BIT_RPT_DGAIN);\n\ttmp_gs = (tmp_gs * 910) >> 10;\n\ttmp_gs = DIV_ROUND_CLOSEST(tmp_gs, 10);\n\n\tif (path == RF_PATH_A)\n\t\trtw_write32_mask(rtwdev, REG_DPD_CTL0_S0, BIT_GS_PWSF, tmp_gs);\n\telse\n\t\trtw_write32_mask(rtwdev, REG_DPD_CTL0_S1, BIT_GS_PWSF, tmp_gs);\n\n\tdpk_info->dpk_gs[path] = tmp_gs;\n}\n\nstatic void rtw8822c_dpk_cal_coef1(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_dpk_info *dpk_info = &rtwdev->dm_info.dpk_info;\n\tu32 offset[DPK_RF_PATH_NUM] = {0, 0x58};\n\tu32 i_scaling;\n\tu8 path;\n\n\trtw_write32_mask(rtwdev, REG_NCTL0, BIT_SUBPAGE, 0x0000000c);\n\trtw_write32(rtwdev, REG_RXSRAM_CTL, 0x000000f0);\n\trtw_write32(rtwdev, REG_NCTL0, 0x00001148);\n\trtw_write32(rtwdev, REG_NCTL0, 0x00001149);\n\n\tcheck_hw_ready(rtwdev, 0x2d9c, MASKBYTE0, 0x55);\n\n\trtw_write8(rtwdev, 0x1b10, 0x0);\n\trtw_write32_mask(rtwdev, REG_NCTL0, BIT_SUBPAGE, 0x0000000c);\n\n\tfor (path = 0; path < rtwdev->hal.rf_path_num; path++) {\n\t\ti_scaling = 0x16c00 / dpk_info->dpk_gs[path];\n\n\t\trtw_write32_mask(rtwdev, 0x1b18 + offset[path], MASKHWORD,\n\t\t\t\t i_scaling);\n\t\trtw_write32_mask(rtwdev, REG_DPD_CTL0_S0 + offset[path],\n\t\t\t\t GENMASK(31, 28), 0x9);\n\t\trtw_write32_mask(rtwdev, REG_DPD_CTL0_S0 + offset[path],\n\t\t\t\t GENMASK(31, 28), 0x1);\n\t\trtw_write32_mask(rtwdev, REG_DPD_CTL0_S0 + offset[path],\n\t\t\t\t GENMASK(31, 28), 0x0);\n\t\trtw_write32_mask(rtwdev, REG_DPD_CTL1_S0 + offset[path],\n\t\t\t\t BIT(14), 0x0);\n\t}\n}\n\nstatic void rtw8822c_dpk_on(struct rtw_dev *rtwdev, u8 path)\n{\n\tstruct rtw_dpk_info *dpk_info = &rtwdev->dm_info.dpk_info;\n\n\trtw8822c_dpk_one_shot(rtwdev, path, RTW_DPK_DPK_ON);\n\n\trtw_write32_mask(rtwdev, REG_NCTL0, BIT_SUBPAGE, 0x8 | (path << 1));\n\trtw_write32_mask(rtwdev, REG_IQK_CTL1, BIT_TX_CFIR, 0x0);\n\n\tif (test_bit(path, dpk_info->dpk_path_ok))\n\t\trtw8822c_dpk_cal_gs(rtwdev, path);\n}\n\nstatic bool rtw8822c_dpk_check_pass(struct rtw_dev *rtwdev, bool is_fail,\n\t\t\t\t    u32 dpk_txagc, u8 path)\n{\n\tbool result;\n\n\tif (!is_fail) {\n\t\tif (rtw8822c_dpk_coef_read(rtwdev, path))\n\t\t\tresult = true;\n\t\telse\n\t\t\tresult = false;\n\t} else {\n\t\tresult = false;\n\t}\n\n\trtw8822c_dpk_fill_result(rtwdev, dpk_txagc, path, result);\n\n\treturn result;\n}\n\nstatic void rtw8822c_dpk_result_reset(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_dpk_info *dpk_info = &rtwdev->dm_info.dpk_info;\n\tu8 path;\n\n\tfor (path = 0; path < rtwdev->hal.rf_path_num; path++) {\n\t\tclear_bit(path, dpk_info->dpk_path_ok);\n\t\trtw_write32_mask(rtwdev, REG_NCTL0, BIT_SUBPAGE,\n\t\t\t\t 0x8 | (path << 1));\n\t\trtw_write32_mask(rtwdev, 0x1b58, 0x0000007f, 0x0);\n\n\t\tdpk_info->dpk_txagc[path] = 0;\n\t\tdpk_info->result[path] = 0;\n\t\tdpk_info->dpk_gs[path] = 0x5b;\n\t\tdpk_info->pre_pwsf[path] = 0;\n\t\tdpk_info->thermal_dpk[path] = rtw8822c_dpk_thermal_read(rtwdev,\n\t\t\t\t\t\t\t\t\tpath);\n\t}\n}\n\nstatic void rtw8822c_dpk_calibrate(struct rtw_dev *rtwdev, u8 path)\n{\n\tstruct rtw_dpk_info *dpk_info = &rtwdev->dm_info.dpk_info;\n\tu32 dpk_txagc;\n\tu8 dpk_fail;\n\n\trtw_dbg(rtwdev, RTW_DBG_RFK, \"[DPK] s%d dpk start\\n\", path);\n\n\tdpk_txagc = rtw8822c_dpk_gainloss(rtwdev, path);\n\n\tdpk_fail = rtw8822c_dpk_by_path(rtwdev, dpk_txagc, path);\n\n\tif (!rtw8822c_dpk_check_pass(rtwdev, dpk_fail, dpk_txagc, path))\n\t\trtw_err(rtwdev, \"failed to do dpk calibration\\n\");\n\n\trtw_dbg(rtwdev, RTW_DBG_RFK, \"[DPK] s%d dpk finish\\n\", path);\n\n\tif (dpk_info->result[path])\n\t\tset_bit(path, dpk_info->dpk_path_ok);\n}\n\nstatic void rtw8822c_dpk_path_select(struct rtw_dev *rtwdev)\n{\n\trtw8822c_dpk_calibrate(rtwdev, RF_PATH_A);\n\trtw8822c_dpk_calibrate(rtwdev, RF_PATH_B);\n\trtw8822c_dpk_on(rtwdev, RF_PATH_A);\n\trtw8822c_dpk_on(rtwdev, RF_PATH_B);\n\trtw8822c_dpk_cal_coef1(rtwdev);\n}\n\nstatic void rtw8822c_dpk_enable_disable(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_dpk_info *dpk_info = &rtwdev->dm_info.dpk_info;\n\tu32 mask = BIT(15) | BIT(14);\n\n\trtw_write32_mask(rtwdev, REG_NCTL0, BIT_SUBPAGE, 0xc);\n\n\trtw_write32_mask(rtwdev, REG_DPD_CTL1_S0, BIT_DPD_EN,\n\t\t\t dpk_info->is_dpk_pwr_on);\n\trtw_write32_mask(rtwdev, REG_DPD_CTL1_S1, BIT_DPD_EN,\n\t\t\t dpk_info->is_dpk_pwr_on);\n\n\tif (test_bit(RF_PATH_A, dpk_info->dpk_path_ok)) {\n\t\trtw_write32_mask(rtwdev, REG_DPD_CTL1_S0, mask, 0x0);\n\t\trtw_write8(rtwdev, REG_DPD_CTL0_S0, dpk_info->dpk_gs[RF_PATH_A]);\n\t}\n\tif (test_bit(RF_PATH_B, dpk_info->dpk_path_ok)) {\n\t\trtw_write32_mask(rtwdev, REG_DPD_CTL1_S1, mask, 0x0);\n\t\trtw_write8(rtwdev, REG_DPD_CTL0_S1, dpk_info->dpk_gs[RF_PATH_B]);\n\t}\n}\n\nstatic void rtw8822c_dpk_reload_data(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_dpk_info *dpk_info = &rtwdev->dm_info.dpk_info;\n\tu8 path;\n\n\tif (!test_bit(RF_PATH_A, dpk_info->dpk_path_ok) &&\n\t    !test_bit(RF_PATH_B, dpk_info->dpk_path_ok) &&\n\t    dpk_info->dpk_ch == 0)\n\t\treturn;\n\n\tfor (path = 0; path < rtwdev->hal.rf_path_num; path++) {\n\t\trtw_write32_mask(rtwdev, REG_NCTL0, BIT_SUBPAGE,\n\t\t\t\t 0x8 | (path << 1));\n\t\tif (dpk_info->dpk_band == RTW_BAND_2G)\n\t\t\trtw_write32(rtwdev, REG_DPD_CTL1_S1, 0x1f100000);\n\t\telse\n\t\t\trtw_write32(rtwdev, REG_DPD_CTL1_S1, 0x1f0d0000);\n\n\t\trtw_write8(rtwdev, REG_DPD_AGC, dpk_info->dpk_txagc[path]);\n\n\t\trtw8822c_dpk_coef_write(rtwdev, path,\n\t\t\t\t\ttest_bit(path, dpk_info->dpk_path_ok));\n\n\t\trtw8822c_dpk_one_shot(rtwdev, path, RTW_DPK_DPK_ON);\n\n\t\trtw_write32_mask(rtwdev, REG_NCTL0, BIT_SUBPAGE, 0xc);\n\n\t\tif (path == RF_PATH_A)\n\t\t\trtw_write32_mask(rtwdev, REG_DPD_CTL0_S0, BIT_GS_PWSF,\n\t\t\t\t\t dpk_info->dpk_gs[path]);\n\t\telse\n\t\t\trtw_write32_mask(rtwdev, REG_DPD_CTL0_S1, BIT_GS_PWSF,\n\t\t\t\t\t dpk_info->dpk_gs[path]);\n\t}\n\trtw8822c_dpk_cal_coef1(rtwdev);\n}\n\nstatic bool rtw8822c_dpk_reload(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_dpk_info *dpk_info = &rtwdev->dm_info.dpk_info;\n\tu8 channel;\n\n\tdpk_info->is_reload = false;\n\n\tchannel = (u8)(rtw_read_rf(rtwdev, RF_PATH_A, 0x18, RFREG_MASK) & 0xff);\n\n\tif (channel == dpk_info->dpk_ch) {\n\t\trtw_dbg(rtwdev, RTW_DBG_RFK,\n\t\t\t\"[DPK] DPK reload for CH%d!!\\n\", dpk_info->dpk_ch);\n\t\trtw8822c_dpk_reload_data(rtwdev);\n\t\tdpk_info->is_reload = true;\n\t}\n\n\treturn dpk_info->is_reload;\n}\n\nstatic void rtw8822c_do_dpk(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_dpk_info *dpk_info = &rtwdev->dm_info.dpk_info;\n\tstruct rtw_backup_info bckp[DPK_BB_REG_NUM];\n\tu32 rf_reg_backup[DPK_RF_REG_NUM][DPK_RF_PATH_NUM];\n\tu32 bb_reg[DPK_BB_REG_NUM] = {\n\t\t0x520, 0x820, 0x824, 0x1c3c, 0x1d58, 0x1864,\n\t\t0x4164, 0x180c, 0x410c, 0x186c, 0x416c,\n\t\t0x1a14, 0x1e70, 0x80c, 0x1d70, 0x1e7c, 0x18a4, 0x41a4};\n\tu32 rf_reg[DPK_RF_REG_NUM] = {\n\t\t0x0, 0x1a, 0x55, 0x63, 0x87, 0x8f, 0xde};\n\tu8 path;\n\n\tif (!dpk_info->is_dpk_pwr_on) {\n\t\trtw_dbg(rtwdev, RTW_DBG_RFK, \"[DPK] Skip DPK due to DPD PWR off\\n\");\n\t\treturn;\n\t} else if (rtw8822c_dpk_reload(rtwdev)) {\n\t\treturn;\n\t}\n\n\tfor (path = RF_PATH_A; path < DPK_RF_PATH_NUM; path++)\n\t\tewma_thermal_init(&dpk_info->avg_thermal[path]);\n\n\trtw8822c_dpk_information(rtwdev);\n\n\trtw8822c_dpk_backup_registers(rtwdev, bb_reg, DPK_BB_REG_NUM, bckp);\n\trtw8822c_dpk_backup_rf_registers(rtwdev, rf_reg, rf_reg_backup);\n\n\trtw8822c_dpk_mac_bb_setting(rtwdev);\n\trtw8822c_dpk_afe_setting(rtwdev, true);\n\trtw8822c_dpk_pre_setting(rtwdev);\n\trtw8822c_dpk_result_reset(rtwdev);\n\trtw8822c_dpk_path_select(rtwdev);\n\trtw8822c_dpk_afe_setting(rtwdev, false);\n\trtw8822c_dpk_enable_disable(rtwdev);\n\n\trtw8822c_dpk_reload_rf_registers(rtwdev, rf_reg, rf_reg_backup);\n\tfor (path = 0; path < rtwdev->hal.rf_path_num; path++)\n\t\trtw8822c_dpk_rxbb_dc_cal(rtwdev, path);\n\trtw8822c_dpk_restore_registers(rtwdev, DPK_BB_REG_NUM, bckp);\n}\n\nstatic void rtw8822c_phy_calibration(struct rtw_dev *rtwdev)\n{\n\trtw8822c_rfk_power_save(rtwdev, false);\n\trtw8822c_do_gapk(rtwdev);\n\trtw8822c_do_iqk(rtwdev);\n\trtw8822c_do_dpk(rtwdev);\n\trtw8822c_rfk_power_save(rtwdev, true);\n}\n\nstatic void rtw8822c_dpk_track(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_dpk_info *dpk_info = &rtwdev->dm_info.dpk_info;\n\tu8 path;\n\tu8 thermal_value[DPK_RF_PATH_NUM] = {0};\n\ts8 offset[DPK_RF_PATH_NUM], delta_dpk[DPK_RF_PATH_NUM];\n\n\tif (dpk_info->thermal_dpk[0] == 0 && dpk_info->thermal_dpk[1] == 0)\n\t\treturn;\n\n\tfor (path = 0; path < DPK_RF_PATH_NUM; path++) {\n\t\tthermal_value[path] = rtw8822c_dpk_thermal_read(rtwdev, path);\n\t\tewma_thermal_add(&dpk_info->avg_thermal[path],\n\t\t\t\t thermal_value[path]);\n\t\tthermal_value[path] =\n\t\t\tewma_thermal_read(&dpk_info->avg_thermal[path]);\n\t\tdelta_dpk[path] = dpk_info->thermal_dpk[path] -\n\t\t\t\t  thermal_value[path];\n\t\toffset[path] = delta_dpk[path] -\n\t\t\t       dpk_info->thermal_dpk_delta[path];\n\t\toffset[path] &= 0x7f;\n\n\t\tif (offset[path] != dpk_info->pre_pwsf[path]) {\n\t\t\trtw_write32_mask(rtwdev, REG_NCTL0, BIT_SUBPAGE,\n\t\t\t\t\t 0x8 | (path << 1));\n\t\t\trtw_write32_mask(rtwdev, 0x1b58, GENMASK(6, 0),\n\t\t\t\t\t offset[path]);\n\t\t\tdpk_info->pre_pwsf[path] = offset[path];\n\t\t}\n\t}\n}\n\n#define XCAP_EXTEND(val) ({typeof(val) _v = (val); _v | _v << 7; })\nstatic void rtw8822c_set_crystal_cap_reg(struct rtw_dev *rtwdev, u8 crystal_cap)\n{\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tstruct rtw_cfo_track *cfo = &dm_info->cfo_track;\n\tu32 val = 0;\n\n\tval = XCAP_EXTEND(crystal_cap);\n\tcfo->crystal_cap = crystal_cap;\n\trtw_write32_mask(rtwdev, REG_ANAPAR_XTAL_0, BIT_XCAP_0, val);\n}\n\nstatic void rtw8822c_set_crystal_cap(struct rtw_dev *rtwdev, u8 crystal_cap)\n{\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tstruct rtw_cfo_track *cfo = &dm_info->cfo_track;\n\n\tif (cfo->crystal_cap == crystal_cap)\n\t\treturn;\n\n\trtw8822c_set_crystal_cap_reg(rtwdev, crystal_cap);\n}\n\nstatic void rtw8822c_cfo_tracking_reset(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tstruct rtw_cfo_track *cfo = &dm_info->cfo_track;\n\n\tcfo->is_adjust = true;\n\n\tif (cfo->crystal_cap > rtwdev->efuse.crystal_cap)\n\t\trtw8822c_set_crystal_cap(rtwdev, cfo->crystal_cap - 1);\n\telse if (cfo->crystal_cap < rtwdev->efuse.crystal_cap)\n\t\trtw8822c_set_crystal_cap(rtwdev, cfo->crystal_cap + 1);\n}\n\nstatic void rtw8822c_cfo_init(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tstruct rtw_cfo_track *cfo = &dm_info->cfo_track;\n\n\tcfo->crystal_cap = rtwdev->efuse.crystal_cap;\n\tcfo->is_adjust = true;\n}\n\n#define REPORT_TO_KHZ(val) ({typeof(val) _v = (val); (_v << 1) + (_v >> 1); })\nstatic s32 rtw8822c_cfo_calc_avg(struct rtw_dev *rtwdev, u8 path_num)\n{\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tstruct rtw_cfo_track *cfo = &dm_info->cfo_track;\n\ts32 cfo_avg, cfo_path_sum = 0, cfo_rpt_sum;\n\tu8 i;\n\n\tfor (i = 0; i < path_num; i++) {\n\t\tcfo_rpt_sum = REPORT_TO_KHZ(cfo->cfo_tail[i]);\n\n\t\tif (cfo->cfo_cnt[i])\n\t\t\tcfo_avg = cfo_rpt_sum / cfo->cfo_cnt[i];\n\t\telse\n\t\t\tcfo_avg = 0;\n\n\t\tcfo_path_sum += cfo_avg;\n\t}\n\n\tfor (i = 0; i < path_num; i++) {\n\t\tcfo->cfo_tail[i] = 0;\n\t\tcfo->cfo_cnt[i] = 0;\n\t}\n\n\treturn cfo_path_sum / path_num;\n}\n\nstatic void rtw8822c_cfo_need_adjust(struct rtw_dev *rtwdev, s32 cfo_avg)\n{\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tstruct rtw_cfo_track *cfo = &dm_info->cfo_track;\n\n\tif (!cfo->is_adjust) {\n\t\tif (abs(cfo_avg) > CFO_TRK_ENABLE_TH)\n\t\t\tcfo->is_adjust = true;\n\t} else {\n\t\tif (abs(cfo_avg) <= CFO_TRK_STOP_TH)\n\t\t\tcfo->is_adjust = false;\n\t}\n\n\tif (!rtw_coex_disabled(rtwdev)) {\n\t\tcfo->is_adjust = false;\n\t\trtw8822c_set_crystal_cap(rtwdev, rtwdev->efuse.crystal_cap);\n\t}\n}\n\nstatic void rtw8822c_cfo_track(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tstruct rtw_cfo_track *cfo = &dm_info->cfo_track;\n\tu8 path_num = rtwdev->hal.rf_path_num;\n\ts8 crystal_cap = cfo->crystal_cap;\n\ts32 cfo_avg = 0;\n\n\tif (rtwdev->sta_cnt != 1) {\n\t\trtw8822c_cfo_tracking_reset(rtwdev);\n\t\treturn;\n\t}\n\n\tif (cfo->packet_count == cfo->packet_count_pre)\n\t\treturn;\n\n\tcfo->packet_count_pre = cfo->packet_count;\n\tcfo_avg = rtw8822c_cfo_calc_avg(rtwdev, path_num);\n\trtw8822c_cfo_need_adjust(rtwdev, cfo_avg);\n\n\tif (cfo->is_adjust) {\n\t\tif (cfo_avg > CFO_TRK_ADJ_TH)\n\t\t\tcrystal_cap++;\n\t\telse if (cfo_avg < -CFO_TRK_ADJ_TH)\n\t\t\tcrystal_cap--;\n\n\t\tcrystal_cap = clamp_t(s8, crystal_cap, 0, XCAP_MASK);\n\t\trtw8822c_set_crystal_cap(rtwdev, (u8)crystal_cap);\n\t}\n}\n\nstatic const struct rtw_phy_cck_pd_reg\nrtw8822c_cck_pd_reg[RTW_CHANNEL_WIDTH_40 + 1][RTW_RF_PATH_MAX] = {\n\t{\n\t\t{0x1ac8, 0x00ff, 0x1ad0, 0x01f},\n\t\t{0x1ac8, 0xff00, 0x1ad0, 0x3e0}\n\t},\n\t{\n\t\t{0x1acc, 0x00ff, 0x1ad0, 0x01F00000},\n\t\t{0x1acc, 0xff00, 0x1ad0, 0x3E000000}\n\t},\n};\n\n#define RTW_CCK_PD_MAX 255\n#define RTW_CCK_CS_MAX 31\n#define RTW_CCK_CS_ERR1 27\n#define RTW_CCK_CS_ERR2 29\nstatic void\nrtw8822c_phy_cck_pd_set_reg(struct rtw_dev *rtwdev,\n\t\t\t    s8 pd_diff, s8 cs_diff, u8 bw, u8 nrx)\n{\n\tu32 pd, cs;\n\n\tif (WARN_ON(bw > RTW_CHANNEL_WIDTH_40 || nrx >= RTW_RF_PATH_MAX))\n\t\treturn;\n\n\tpd = rtw_read32_mask(rtwdev,\n\t\t\t     rtw8822c_cck_pd_reg[bw][nrx].reg_pd,\n\t\t\t     rtw8822c_cck_pd_reg[bw][nrx].mask_pd);\n\tcs = rtw_read32_mask(rtwdev,\n\t\t\t     rtw8822c_cck_pd_reg[bw][nrx].reg_cs,\n\t\t\t     rtw8822c_cck_pd_reg[bw][nrx].mask_cs);\n\tpd += pd_diff;\n\tcs += cs_diff;\n\tif (pd > RTW_CCK_PD_MAX)\n\t\tpd = RTW_CCK_PD_MAX;\n\tif (cs == RTW_CCK_CS_ERR1 || cs == RTW_CCK_CS_ERR2)\n\t\tcs++;\n\telse if (cs > RTW_CCK_CS_MAX)\n\t\tcs = RTW_CCK_CS_MAX;\n\trtw_write32_mask(rtwdev,\n\t\t\t rtw8822c_cck_pd_reg[bw][nrx].reg_pd,\n\t\t\t rtw8822c_cck_pd_reg[bw][nrx].mask_pd,\n\t\t\t pd);\n\trtw_write32_mask(rtwdev,\n\t\t\t rtw8822c_cck_pd_reg[bw][nrx].reg_cs,\n\t\t\t rtw8822c_cck_pd_reg[bw][nrx].mask_cs,\n\t\t\t cs);\n\n\trtw_dbg(rtwdev, RTW_DBG_PHY,\n\t\t\"is_linked=%d, bw=%d, nrx=%d, cs_ratio=0x%x, pd_th=0x%x\\n\",\n\t\trtw_is_assoc(rtwdev), bw, nrx, cs, pd);\n}\n\nstatic void rtw8822c_phy_cck_pd_set(struct rtw_dev *rtwdev, u8 new_lvl)\n{\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\ts8 pd_lvl[CCK_PD_LV_MAX] = {0, 2, 4, 6, 8};\n\ts8 cs_lvl[CCK_PD_LV_MAX] = {0, 2, 2, 2, 4};\n\tu8 cur_lvl;\n\tu8 nrx, bw;\n\n\tnrx = (u8)rtw_read32_mask(rtwdev, 0x1a2c, 0x60000);\n\tbw = (u8)rtw_read32_mask(rtwdev, 0x9b0, 0xc);\n\n\trtw_dbg(rtwdev, RTW_DBG_PHY, \"lv: (%d) -> (%d) bw=%d nr=%d cck_fa_avg=%d\\n\",\n\t\tdm_info->cck_pd_lv[bw][nrx], new_lvl, bw, nrx,\n\t\tdm_info->cck_fa_avg);\n\n\tif (dm_info->cck_pd_lv[bw][nrx] == new_lvl)\n\t\treturn;\n\n\tcur_lvl = dm_info->cck_pd_lv[bw][nrx];\n\n\t \n\tdm_info->cck_fa_avg = CCK_FA_AVG_RESET;\n\n\trtw8822c_phy_cck_pd_set_reg(rtwdev,\n\t\t\t\t    pd_lvl[new_lvl] - pd_lvl[cur_lvl],\n\t\t\t\t    cs_lvl[new_lvl] - cs_lvl[cur_lvl],\n\t\t\t\t    bw, nrx);\n\tdm_info->cck_pd_lv[bw][nrx] = new_lvl;\n}\n\n#define PWR_TRACK_MASK 0x7f\nstatic void rtw8822c_pwrtrack_set(struct rtw_dev *rtwdev, u8 rf_path)\n{\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\n\tswitch (rf_path) {\n\tcase RF_PATH_A:\n\t\trtw_write32_mask(rtwdev, 0x18a0, PWR_TRACK_MASK,\n\t\t\t\t dm_info->delta_power_index[rf_path]);\n\t\tbreak;\n\tcase RF_PATH_B:\n\t\trtw_write32_mask(rtwdev, 0x41a0, PWR_TRACK_MASK,\n\t\t\t\t dm_info->delta_power_index[rf_path]);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void rtw8822c_pwr_track_stats(struct rtw_dev *rtwdev, u8 path)\n{\n\tu8 thermal_value;\n\n\tif (rtwdev->efuse.thermal_meter[path] == 0xff)\n\t\treturn;\n\n\tthermal_value = rtw_read_rf(rtwdev, path, RF_T_METER, 0x7e);\n\trtw_phy_pwrtrack_avg(rtwdev, thermal_value, path);\n}\n\nstatic void rtw8822c_pwr_track_path(struct rtw_dev *rtwdev,\n\t\t\t\t    struct rtw_swing_table *swing_table,\n\t\t\t\t    u8 path)\n{\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tu8 delta;\n\n\tdelta = rtw_phy_pwrtrack_get_delta(rtwdev, path);\n\tdm_info->delta_power_index[path] =\n\t\trtw_phy_pwrtrack_get_pwridx(rtwdev, swing_table, path, path,\n\t\t\t\t\t    delta);\n\trtw8822c_pwrtrack_set(rtwdev, path);\n}\n\nstatic void __rtw8822c_pwr_track(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_swing_table swing_table;\n\tu8 i;\n\n\trtw_phy_config_swing_table(rtwdev, &swing_table);\n\n\tfor (i = 0; i < rtwdev->hal.rf_path_num; i++)\n\t\trtw8822c_pwr_track_stats(rtwdev, i);\n\tif (rtw_phy_pwrtrack_need_lck(rtwdev))\n\t\trtw8822c_do_lck(rtwdev);\n\tfor (i = 0; i < rtwdev->hal.rf_path_num; i++)\n\t\trtw8822c_pwr_track_path(rtwdev, &swing_table, i);\n}\n\nstatic void rtw8822c_pwr_track(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\n\tif (efuse->power_track_type != 0)\n\t\treturn;\n\n\tif (!dm_info->pwr_trk_triggered) {\n\t\trtw_write_rf(rtwdev, RF_PATH_A, RF_T_METER, BIT(19), 0x01);\n\t\trtw_write_rf(rtwdev, RF_PATH_A, RF_T_METER, BIT(19), 0x00);\n\t\trtw_write_rf(rtwdev, RF_PATH_A, RF_T_METER, BIT(19), 0x01);\n\n\t\trtw_write_rf(rtwdev, RF_PATH_B, RF_T_METER, BIT(19), 0x01);\n\t\trtw_write_rf(rtwdev, RF_PATH_B, RF_T_METER, BIT(19), 0x00);\n\t\trtw_write_rf(rtwdev, RF_PATH_B, RF_T_METER, BIT(19), 0x01);\n\n\t\tdm_info->pwr_trk_triggered = true;\n\t\treturn;\n\t}\n\n\t__rtw8822c_pwr_track(rtwdev);\n\tdm_info->pwr_trk_triggered = false;\n}\n\nstatic void rtw8822c_adaptivity_init(struct rtw_dev *rtwdev)\n{\n\trtw_phy_set_edcca_th(rtwdev, RTW8822C_EDCCA_MAX, RTW8822C_EDCCA_MAX);\n\n\t \n\trtw_write32_clr(rtwdev, REG_TX_PTCL_CTRL, BIT_DIS_EDCCA);\n\trtw_write32_set(rtwdev, REG_RD_CTRL, BIT_EDCCA_MSK_CNTDOWN_EN);\n\n\t \n\trtw_write32_clr(rtwdev, REG_EDCCA_DECISION, BIT_EDCCA_OPTION);\n}\n\nstatic void rtw8822c_adaptivity(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\ts8 l2h, h2l;\n\tu8 igi;\n\n\tigi = dm_info->igi_history[0];\n\tif (dm_info->edcca_mode == RTW_EDCCA_NORMAL) {\n\t\tl2h = max_t(s8, igi + EDCCA_IGI_L2H_DIFF, EDCCA_TH_L2H_LB);\n\t\th2l = l2h - EDCCA_L2H_H2L_DIFF_NORMAL;\n\t} else {\n\t\tif (igi < dm_info->l2h_th_ini - EDCCA_ADC_BACKOFF)\n\t\t\tl2h = igi + EDCCA_ADC_BACKOFF;\n\t\telse\n\t\t\tl2h = dm_info->l2h_th_ini;\n\t\th2l = l2h - EDCCA_L2H_H2L_DIFF;\n\t}\n\n\trtw_phy_set_edcca_th(rtwdev, l2h, h2l);\n}\n\nstatic void rtw8822c_fill_txdesc_checksum(struct rtw_dev *rtwdev,\n\t\t\t\t\t  struct rtw_tx_pkt_info *pkt_info,\n\t\t\t\t\t  u8 *txdesc)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tsize_t words;\n\n\twords = (pkt_info->pkt_offset * 8 + chip->tx_pkt_desc_sz) / 2;\n\n\tfill_txdesc_checksum_common(txdesc, words);\n}\n\nstatic const struct rtw_pwr_seq_cmd trans_carddis_to_cardemu_8822c[] = {\n\t{0x0086,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_SDIO_MSK,\n\t RTW_PWR_ADDR_SDIO,\n\t RTW_PWR_CMD_WRITE, BIT(0), 0},\n\t{0x0086,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_SDIO_MSK,\n\t RTW_PWR_ADDR_SDIO,\n\t RTW_PWR_CMD_POLLING, BIT(1), BIT(1)},\n\t{0x002E,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(2), BIT(2)},\n\t{0x002D,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(0), 0},\n\t{0x007F,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(7), 0},\n\t{0x004A,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_USB_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(0), 0},\n\t{0x0005,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(3) | BIT(4) | BIT(7), 0},\n\t{0xFFFF,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t 0,\n\t RTW_PWR_CMD_END, 0, 0},\n};\n\nstatic const struct rtw_pwr_seq_cmd trans_cardemu_to_act_8822c[] = {\n\t{0x0000,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_USB_MSK | RTW_PWR_INTF_SDIO_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(5), 0},\n\t{0x0005,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, (BIT(4) | BIT(3) | BIT(2)), 0},\n\t{0x0075,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_PCI_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(0), BIT(0)},\n\t{0x0006,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_POLLING, BIT(1), BIT(1)},\n\t{0x0075,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_PCI_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(0), 0},\n\t{0xFF1A,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_USB_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, 0xFF, 0},\n\t{0x002E,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(3), 0},\n\t{0x0006,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(0), BIT(0)},\n\t{0x0005,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, (BIT(4) | BIT(3)), 0},\n\t{0x1018,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(2), BIT(2)},\n\t{0x0005,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(0), BIT(0)},\n\t{0x0005,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_POLLING, BIT(0), 0},\n\t{0x0074,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_PCI_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(5), BIT(5)},\n\t{0x0071,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_PCI_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(4), 0},\n\t{0x0062,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_PCI_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, (BIT(7) | BIT(6) | BIT(5)),\n\t (BIT(7) | BIT(6) | BIT(5))},\n\t{0x0061,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_PCI_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, (BIT(7) | BIT(6) | BIT(5)), 0},\n\t{0x001F,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, (BIT(7) | BIT(6)), BIT(7)},\n\t{0x00EF,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, (BIT(7) | BIT(6)), BIT(7)},\n\t{0x1045,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(4), BIT(4)},\n\t{0x0010,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(2), BIT(2)},\n\t{0x1064,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(1), BIT(1)},\n\t{0xFFFF,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t 0,\n\t RTW_PWR_CMD_END, 0, 0},\n};\n\nstatic const struct rtw_pwr_seq_cmd trans_act_to_cardemu_8822c[] = {\n\t{0x0093,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(3), 0},\n\t{0x001F,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, 0xFF, 0},\n\t{0x00EF,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, 0xFF, 0},\n\t{0x1045,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(4), 0},\n\t{0xFF1A,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_USB_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, 0xFF, 0x30},\n\t{0x0049,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(1), 0},\n\t{0x0006,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(0), BIT(0)},\n\t{0x0002,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(1), 0},\n\t{0x0005,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(1), BIT(1)},\n\t{0x0005,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_POLLING, BIT(1), 0},\n\t{0x0000,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_USB_MSK | RTW_PWR_INTF_SDIO_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(5), BIT(5)},\n\t{0xFFFF,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t 0,\n\t RTW_PWR_CMD_END, 0, 0},\n};\n\nstatic const struct rtw_pwr_seq_cmd trans_cardemu_to_carddis_8822c[] = {\n\t{0x0005,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_SDIO_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(7), BIT(7)},\n\t{0x0007,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_USB_MSK | RTW_PWR_INTF_SDIO_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, 0xFF, 0x00},\n\t{0x0067,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(5), 0},\n\t{0x004A,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_USB_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(0), 0},\n\t{0x0081,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(7) | BIT(6), 0},\n\t{0x0090,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(1), 0},\n\t{0x0092,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_PCI_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, 0xFF, 0x20},\n\t{0x0093,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_PCI_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, 0xFF, 0x04},\n\t{0x0005,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_USB_MSK | RTW_PWR_INTF_SDIO_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(3) | BIT(4), BIT(3)},\n\t{0x0005,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_PCI_MSK,\n\t RTW_PWR_ADDR_MAC,\n\t RTW_PWR_CMD_WRITE, BIT(2), BIT(2)},\n\t{0x0086,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_SDIO_MSK,\n\t RTW_PWR_ADDR_SDIO,\n\t RTW_PWR_CMD_WRITE, BIT(0), BIT(0)},\n\t{0xFFFF,\n\t RTW_PWR_CUT_ALL_MSK,\n\t RTW_PWR_INTF_ALL_MSK,\n\t 0,\n\t RTW_PWR_CMD_END, 0, 0},\n};\n\nstatic const struct rtw_pwr_seq_cmd *card_enable_flow_8822c[] = {\n\ttrans_carddis_to_cardemu_8822c,\n\ttrans_cardemu_to_act_8822c,\n\tNULL\n};\n\nstatic const struct rtw_pwr_seq_cmd *card_disable_flow_8822c[] = {\n\ttrans_act_to_cardemu_8822c,\n\ttrans_cardemu_to_carddis_8822c,\n\tNULL\n};\n\nstatic const struct rtw_intf_phy_para usb2_param_8822c[] = {\n\t{0xFFFF, 0x00,\n\t RTW_IP_SEL_PHY,\n\t RTW_INTF_PHY_CUT_ALL,\n\t RTW_INTF_PHY_PLATFORM_ALL},\n};\n\nstatic const struct rtw_intf_phy_para usb3_param_8822c[] = {\n\t{0xFFFF, 0x0000,\n\t RTW_IP_SEL_PHY,\n\t RTW_INTF_PHY_CUT_ALL,\n\t RTW_INTF_PHY_PLATFORM_ALL},\n};\n\nstatic const struct rtw_intf_phy_para pcie_gen1_param_8822c[] = {\n\t{0xFFFF, 0x0000,\n\t RTW_IP_SEL_PHY,\n\t RTW_INTF_PHY_CUT_ALL,\n\t RTW_INTF_PHY_PLATFORM_ALL},\n};\n\nstatic const struct rtw_intf_phy_para pcie_gen2_param_8822c[] = {\n\t{0xFFFF, 0x0000,\n\t RTW_IP_SEL_PHY,\n\t RTW_INTF_PHY_CUT_ALL,\n\t RTW_INTF_PHY_PLATFORM_ALL},\n};\n\nstatic const struct rtw_intf_phy_para_table phy_para_table_8822c = {\n\t.usb2_para\t= usb2_param_8822c,\n\t.usb3_para\t= usb3_param_8822c,\n\t.gen1_para\t= pcie_gen1_param_8822c,\n\t.gen2_para\t= pcie_gen2_param_8822c,\n\t.n_usb2_para\t= ARRAY_SIZE(usb2_param_8822c),\n\t.n_usb3_para\t= ARRAY_SIZE(usb2_param_8822c),\n\t.n_gen1_para\t= ARRAY_SIZE(pcie_gen1_param_8822c),\n\t.n_gen2_para\t= ARRAY_SIZE(pcie_gen2_param_8822c),\n};\n\nstatic const struct rtw_rfe_def rtw8822c_rfe_defs[] = {\n\t[0] = RTW_DEF_RFE(8822c, 0, 0),\n\t[1] = RTW_DEF_RFE(8822c, 0, 0),\n\t[2] = RTW_DEF_RFE(8822c, 0, 0),\n\t[3] = RTW_DEF_RFE(8822c, 0, 0),\n\t[4] = RTW_DEF_RFE(8822c, 0, 0),\n\t[5] = RTW_DEF_RFE(8822c, 0, 5),\n\t[6] = RTW_DEF_RFE(8822c, 0, 0),\n};\n\nstatic const struct rtw_hw_reg rtw8822c_dig[] = {\n\t[0] = { .addr = 0x1d70, .mask = 0x7f },\n\t[1] = { .addr = 0x1d70, .mask = 0x7f00 },\n};\n\nstatic const struct rtw_ltecoex_addr rtw8822c_ltecoex_addr = {\n\t.ctrl = LTECOEX_ACCESS_CTRL,\n\t.wdata = LTECOEX_WRITE_DATA,\n\t.rdata = LTECOEX_READ_DATA,\n};\n\nstatic const struct rtw_page_table page_table_8822c[] = {\n\t{64, 64, 64, 64, 1},\n\t{64, 64, 64, 64, 1},\n\t{64, 64, 0, 0, 1},\n\t{64, 64, 64, 0, 1},\n\t{64, 64, 64, 64, 1},\n};\n\nstatic const struct rtw_rqpn rqpn_table_8822c[] = {\n\t{RTW_DMA_MAPPING_NORMAL, RTW_DMA_MAPPING_NORMAL,\n\t RTW_DMA_MAPPING_LOW, RTW_DMA_MAPPING_LOW,\n\t RTW_DMA_MAPPING_EXTRA, RTW_DMA_MAPPING_HIGH},\n\t{RTW_DMA_MAPPING_NORMAL, RTW_DMA_MAPPING_NORMAL,\n\t RTW_DMA_MAPPING_LOW, RTW_DMA_MAPPING_LOW,\n\t RTW_DMA_MAPPING_EXTRA, RTW_DMA_MAPPING_HIGH},\n\t{RTW_DMA_MAPPING_NORMAL, RTW_DMA_MAPPING_NORMAL,\n\t RTW_DMA_MAPPING_NORMAL, RTW_DMA_MAPPING_HIGH,\n\t RTW_DMA_MAPPING_HIGH, RTW_DMA_MAPPING_HIGH},\n\t{RTW_DMA_MAPPING_NORMAL, RTW_DMA_MAPPING_NORMAL,\n\t RTW_DMA_MAPPING_LOW, RTW_DMA_MAPPING_LOW,\n\t RTW_DMA_MAPPING_HIGH, RTW_DMA_MAPPING_HIGH},\n\t{RTW_DMA_MAPPING_NORMAL, RTW_DMA_MAPPING_NORMAL,\n\t RTW_DMA_MAPPING_LOW, RTW_DMA_MAPPING_LOW,\n\t RTW_DMA_MAPPING_EXTRA, RTW_DMA_MAPPING_HIGH},\n};\n\nstatic struct rtw_prioq_addrs prioq_addrs_8822c = {\n\t.prio[RTW_DMA_MAPPING_EXTRA] = {\n\t\t.rsvd = REG_FIFOPAGE_INFO_4, .avail = REG_FIFOPAGE_INFO_4 + 2,\n\t},\n\t.prio[RTW_DMA_MAPPING_LOW] = {\n\t\t.rsvd = REG_FIFOPAGE_INFO_2, .avail = REG_FIFOPAGE_INFO_2 + 2,\n\t},\n\t.prio[RTW_DMA_MAPPING_NORMAL] = {\n\t\t.rsvd = REG_FIFOPAGE_INFO_3, .avail = REG_FIFOPAGE_INFO_3 + 2,\n\t},\n\t.prio[RTW_DMA_MAPPING_HIGH] = {\n\t\t.rsvd = REG_FIFOPAGE_INFO_1, .avail = REG_FIFOPAGE_INFO_1 + 2,\n\t},\n\t.wsize = true,\n};\n\nstatic struct rtw_chip_ops rtw8822c_ops = {\n\t.phy_set_param\t\t= rtw8822c_phy_set_param,\n\t.read_efuse\t\t= rtw8822c_read_efuse,\n\t.query_rx_desc\t\t= rtw8822c_query_rx_desc,\n\t.set_channel\t\t= rtw8822c_set_channel,\n\t.mac_init\t\t= rtw8822c_mac_init,\n\t.dump_fw_crash\t\t= rtw8822c_dump_fw_crash,\n\t.read_rf\t\t= rtw_phy_read_rf,\n\t.write_rf\t\t= rtw_phy_write_rf_reg_mix,\n\t.set_tx_power_index\t= rtw8822c_set_tx_power_index,\n\t.set_antenna\t\t= rtw8822c_set_antenna,\n\t.cfg_ldo25\t\t= rtw8822c_cfg_ldo25,\n\t.false_alarm_statistics\t= rtw8822c_false_alarm_statistics,\n\t.dpk_track\t\t= rtw8822c_dpk_track,\n\t.phy_calibration\t= rtw8822c_phy_calibration,\n\t.cck_pd_set\t\t= rtw8822c_phy_cck_pd_set,\n\t.pwr_track\t\t= rtw8822c_pwr_track,\n\t.config_bfee\t\t= rtw8822c_bf_config_bfee,\n\t.set_gid_table\t\t= rtw_bf_set_gid_table,\n\t.cfg_csi_rate\t\t= rtw_bf_cfg_csi_rate,\n\t.adaptivity_init\t= rtw8822c_adaptivity_init,\n\t.adaptivity\t\t= rtw8822c_adaptivity,\n\t.cfo_init\t\t= rtw8822c_cfo_init,\n\t.cfo_track\t\t= rtw8822c_cfo_track,\n\t.config_tx_path\t\t= rtw8822c_config_tx_path,\n\t.config_txrx_mode\t= rtw8822c_config_trx_mode,\n\t.fill_txdesc_checksum\t= rtw8822c_fill_txdesc_checksum,\n\n\t.coex_set_init\t\t= rtw8822c_coex_cfg_init,\n\t.coex_set_ant_switch\t= NULL,\n\t.coex_set_gnt_fix\t= rtw8822c_coex_cfg_gnt_fix,\n\t.coex_set_gnt_debug\t= rtw8822c_coex_cfg_gnt_debug,\n\t.coex_set_rfe_type\t= rtw8822c_coex_cfg_rfe_type,\n\t.coex_set_wl_tx_power\t= rtw8822c_coex_cfg_wl_tx_power,\n\t.coex_set_wl_rx_gain\t= rtw8822c_coex_cfg_wl_rx_gain,\n};\n\n \nstatic const struct coex_table_para table_sant_8822c[] = {\n\t{0xffffffff, 0xffffffff},  \n\t{0x55555555, 0x55555555},\n\t{0x66555555, 0x66555555},\n\t{0xaaaaaaaa, 0xaaaaaaaa},\n\t{0x5a5a5a5a, 0x5a5a5a5a},\n\t{0xfafafafa, 0xfafafafa},  \n\t{0x6a5a5555, 0xaaaaaaaa},\n\t{0x6a5a56aa, 0x6a5a56aa},\n\t{0x6a5a5a5a, 0x6a5a5a5a},\n\t{0x66555555, 0x5a5a5a5a},\n\t{0x66555555, 0x6a5a5a5a},  \n\t{0x66555555, 0x6a5a5aaa},\n\t{0x66555555, 0x5a5a5aaa},\n\t{0x66555555, 0x6aaa5aaa},\n\t{0x66555555, 0xaaaa5aaa},\n\t{0x66555555, 0xaaaaaaaa},  \n\t{0xffff55ff, 0xfafafafa},\n\t{0xffff55ff, 0x6afa5afa},\n\t{0xaaffffaa, 0xfafafafa},\n\t{0xaa5555aa, 0x5a5a5a5a},\n\t{0xaa5555aa, 0x6a5a5a5a},  \n\t{0xaa5555aa, 0xaaaaaaaa},\n\t{0xffffffff, 0x5a5a5a5a},\n\t{0xffffffff, 0x5a5a5a5a},\n\t{0xffffffff, 0x55555555},\n\t{0xffffffff, 0x5a5a5aaa},  \n\t{0x55555555, 0x5a5a5a5a},\n\t{0x55555555, 0xaaaaaaaa},\n\t{0x55555555, 0x6a5a6a5a},\n\t{0x66556655, 0x66556655},\n\t{0x66556aaa, 0x6a5a6aaa},  \n\t{0xffffffff, 0x5aaa5aaa},\n\t{0x56555555, 0x5a5a5aaa},\n\t{0xdaffdaff, 0xdaffdaff},\n\t{0xddffddff, 0xddffddff},\n};\n\n \nstatic const struct coex_table_para table_nsant_8822c[] = {\n\t{0xffffffff, 0xffffffff},  \n\t{0x55555555, 0x55555555},\n\t{0x66555555, 0x66555555},\n\t{0xaaaaaaaa, 0xaaaaaaaa},\n\t{0x5a5a5a5a, 0x5a5a5a5a},\n\t{0xfafafafa, 0xfafafafa},  \n\t{0x5afa5afa, 0x5afa5afa},\n\t{0x55555555, 0xfafafafa},\n\t{0x66555555, 0xfafafafa},\n\t{0x66555555, 0x5a5a5a5a},\n\t{0x66555555, 0x6a5a5a5a},  \n\t{0x66555555, 0xaaaaaaaa},\n\t{0xffff55ff, 0xfafafafa},\n\t{0xffff55ff, 0x5afa5afa},\n\t{0xffff55ff, 0xaaaaaaaa},\n\t{0xffff55ff, 0xffff55ff},  \n\t{0xaaffffaa, 0x5afa5afa},\n\t{0xaaffffaa, 0xaaaaaaaa},\n\t{0xffffffff, 0xfafafafa},\n\t{0xffffffff, 0x5afa5afa},\n\t{0xffffffff, 0xaaaaaaaa},  \n\t{0x55ff55ff, 0x5afa5afa},\n\t{0x55ff55ff, 0xaaaaaaaa},\n\t{0x55ff55ff, 0x55ff55ff}\n};\n\n \nstatic const struct coex_tdma_para tdma_sant_8822c[] = {\n\t{ {0x00, 0x00, 0x00, 0x00, 0x00} },  \n\t{ {0x61, 0x45, 0x03, 0x11, 0x11} },  \n\t{ {0x61, 0x3a, 0x03, 0x11, 0x11} },\n\t{ {0x61, 0x30, 0x03, 0x11, 0x11} },\n\t{ {0x61, 0x20, 0x03, 0x11, 0x11} },\n\t{ {0x61, 0x10, 0x03, 0x11, 0x11} },  \n\t{ {0x61, 0x45, 0x03, 0x11, 0x10} },\n\t{ {0x61, 0x3a, 0x03, 0x11, 0x10} },\n\t{ {0x61, 0x30, 0x03, 0x11, 0x10} },\n\t{ {0x61, 0x20, 0x03, 0x11, 0x10} },\n\t{ {0x61, 0x10, 0x03, 0x11, 0x10} },  \n\t{ {0x61, 0x08, 0x03, 0x11, 0x14} },\n\t{ {0x61, 0x08, 0x03, 0x10, 0x14} },\n\t{ {0x51, 0x08, 0x03, 0x10, 0x54} },\n\t{ {0x51, 0x08, 0x03, 0x10, 0x55} },\n\t{ {0x51, 0x08, 0x07, 0x10, 0x54} },  \n\t{ {0x51, 0x45, 0x03, 0x10, 0x50} },\n\t{ {0x51, 0x3a, 0x03, 0x10, 0x50} },\n\t{ {0x51, 0x30, 0x03, 0x10, 0x50} },\n\t{ {0x51, 0x20, 0x03, 0x10, 0x50} },\n\t{ {0x51, 0x10, 0x03, 0x10, 0x50} },  \n\t{ {0x51, 0x4a, 0x03, 0x10, 0x50} },\n\t{ {0x51, 0x0c, 0x03, 0x10, 0x54} },\n\t{ {0x55, 0x08, 0x03, 0x10, 0x54} },\n\t{ {0x65, 0x10, 0x03, 0x11, 0x10} },\n\t{ {0x51, 0x10, 0x03, 0x10, 0x51} },  \n\t{ {0x51, 0x08, 0x03, 0x10, 0x50} },\n\t{ {0x61, 0x08, 0x03, 0x11, 0x11} }\n};\n\n \nstatic const struct coex_tdma_para tdma_nsant_8822c[] = {\n\t{ {0x00, 0x00, 0x00, 0x00, 0x00} },  \n\t{ {0x61, 0x45, 0x03, 0x11, 0x11} },\n\t{ {0x61, 0x3a, 0x03, 0x11, 0x11} },\n\t{ {0x61, 0x30, 0x03, 0x11, 0x11} },\n\t{ {0x61, 0x20, 0x03, 0x11, 0x11} },\n\t{ {0x61, 0x10, 0x03, 0x11, 0x11} },  \n\t{ {0x61, 0x45, 0x03, 0x11, 0x10} },\n\t{ {0x61, 0x3a, 0x03, 0x11, 0x10} },\n\t{ {0x61, 0x30, 0x03, 0x11, 0x10} },\n\t{ {0x61, 0x20, 0x03, 0x11, 0x10} },\n\t{ {0x61, 0x10, 0x03, 0x11, 0x10} },  \n\t{ {0x61, 0x08, 0x03, 0x11, 0x14} },\n\t{ {0x61, 0x08, 0x03, 0x10, 0x14} },\n\t{ {0x51, 0x08, 0x03, 0x10, 0x54} },\n\t{ {0x51, 0x08, 0x03, 0x10, 0x55} },\n\t{ {0x51, 0x08, 0x07, 0x10, 0x54} },  \n\t{ {0x51, 0x45, 0x03, 0x10, 0x50} },\n\t{ {0x51, 0x3a, 0x03, 0x10, 0x50} },\n\t{ {0x51, 0x30, 0x03, 0x10, 0x50} },\n\t{ {0x51, 0x20, 0x03, 0x10, 0x50} },\n\t{ {0x51, 0x10, 0x03, 0x10, 0x50} },  \n\t{ {0x51, 0x08, 0x03, 0x10, 0x50} }\n};\n\n \nstatic const u8 wl_rssi_step_8822c[] = {60, 50, 44, 30};\nstatic const u8 bt_rssi_step_8822c[] = {8, 15, 20, 25};\nstatic const struct coex_5g_afh_map afh_5g_8822c[] = { {0, 0, 0} };\n\n \nstatic const struct coex_rf_para rf_para_tx_8822c[] = {\n\t{0, 0, false, 7},   \n\t{0, 16, false, 7},  \n\t{8, 17, true, 4},\n\t{7, 18, true, 4},\n\t{6, 19, true, 4},\n\t{5, 20, true, 4},\n\t{0, 21, true, 4}    \n};\n\nstatic const struct coex_rf_para rf_para_rx_8822c[] = {\n\t{0, 0, false, 7},   \n\t{0, 16, false, 7},  \n\t{3, 24, true, 5},\n\t{2, 26, true, 5},\n\t{1, 27, true, 5},\n\t{0, 28, true, 5},\n\t{0, 28, true, 5}    \n};\n\nstatic_assert(ARRAY_SIZE(rf_para_tx_8822c) == ARRAY_SIZE(rf_para_rx_8822c));\n\nstatic const u8\nrtw8822c_pwrtrk_5gb_n[RTW_PWR_TRK_5G_NUM][RTW_PWR_TRK_TBL_SZ] = {\n\t{ 0,  1,  2,  3,  5,  6,  7,  8,  9, 10,\n\t 11, 12, 13, 14, 15, 16, 18, 19, 20, 21,\n\t 22, 23, 24, 25, 26, 27, 28, 29, 30, 32 },\n\t{ 0,  1,  2,  3,  5,  6,  7,  8,  9, 10,\n\t 11, 12, 13, 14, 15, 16, 18, 19, 20, 21,\n\t 22, 23, 24, 25, 26, 27, 28, 29, 30, 32 },\n\t{ 0,  1,  2,  3,  5,  6,  7,  8,  9, 10,\n\t 11, 12, 13, 14, 15, 16, 18, 19, 20, 21,\n\t 22, 23, 24, 25, 26, 27, 28, 29, 30, 32 },\n};\n\nstatic const u8\nrtw8822c_pwrtrk_5gb_p[RTW_PWR_TRK_5G_NUM][RTW_PWR_TRK_TBL_SZ] = {\n\t{ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9,\n\t 10, 10, 11, 12, 13, 14, 15, 16, 17, 18,\n\t 19, 20, 21, 22, 22, 23, 24, 25, 26, 27 },\n\t{ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9,\n\t 10, 10, 11, 12, 13, 14, 15, 16, 17, 18,\n\t 19, 20, 21, 22, 22, 23, 24, 25, 26, 27 },\n\t{ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9,\n\t 10, 10, 11, 12, 13, 14, 15, 16, 17, 18,\n\t 19, 20, 21, 22, 22, 23, 24, 25, 26, 27 },\n};\n\nstatic const u8\nrtw8822c_pwrtrk_5ga_n[RTW_PWR_TRK_5G_NUM][RTW_PWR_TRK_TBL_SZ] = {\n\t{ 0,  1,  2,  4,  5,  6,  7,  8,  9, 10,\n\t 11, 13, 14, 15, 16, 17, 18, 19, 20, 21,\n\t 23, 24, 25, 26, 27, 28, 29, 30, 31, 33 },\n\t{ 0,  1,  2,  4,  5,  6,  7,  8,  9, 10,\n\t 11, 13, 14, 15, 16, 17, 18, 19, 20, 21,\n\t 23, 24, 25, 26, 27, 28, 29, 30, 31, 33 },\n\t{ 0,  1,  2,  4,  5,  6,  7,  8,  9, 10,\n\t 11, 13, 14, 15, 16, 17, 18, 19, 20, 21,\n\t 23, 24, 25, 26, 27, 28, 29, 30, 31, 33 },\n};\n\nstatic const u8\nrtw8822c_pwrtrk_5ga_p[RTW_PWR_TRK_5G_NUM][RTW_PWR_TRK_TBL_SZ] = {\n\t{ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9,\n\t 10, 11, 12, 13, 14, 15, 16, 17, 18, 20,\n\t 21, 22, 23, 24, 25, 26, 27, 28, 29, 30 },\n\t{ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9,\n\t 10, 11, 12, 13, 14, 15, 16, 17, 18, 20,\n\t 21, 22, 23, 24, 25, 26, 27, 28, 29, 30 },\n\t{ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9,\n\t 10, 11, 12, 13, 14, 15, 16, 17, 18, 20,\n\t 21, 22, 23, 24, 25, 26, 27, 28, 29, 30 },\n};\n\nstatic const u8 rtw8822c_pwrtrk_2gb_n[RTW_PWR_TRK_TBL_SZ] = {\n\t 0,  1,  2,  3,  4,  4,  5,  6,  7,  8,\n\t 9,  9, 10, 11, 12, 13, 14, 15, 15, 16,\n\t17, 18, 19, 20, 20, 21, 22, 23, 24, 25\n};\n\nstatic const u8 rtw8822c_pwrtrk_2gb_p[RTW_PWR_TRK_TBL_SZ] = {\n\t 0,  1,  2,  3,  4,  5,  6,  7,  8,  9,\n\t10, 11, 12, 13, 14, 14, 15, 16, 17, 18,\n\t19, 20, 21, 22, 23, 24, 25, 26, 27, 28\n};\n\nstatic const u8 rtw8822c_pwrtrk_2ga_n[RTW_PWR_TRK_TBL_SZ] = {\n\t 0,  1,  2,  2,  3,  4,  4,  5,  6,  6,\n\t 7,  8,  8,  9,  9, 10, 11, 11, 12, 13,\n\t13, 14, 15, 15, 16, 17, 17, 18, 19, 19\n};\n\nstatic const u8 rtw8822c_pwrtrk_2ga_p[RTW_PWR_TRK_TBL_SZ] = {\n\t 0,  1,  2,  3,  4,  5,  6,  7,  8,  9,\n\t10, 11, 11, 12, 13, 14, 15, 16, 17, 18,\n\t19, 20, 21, 22, 23, 24, 25, 25, 26, 27\n};\n\nstatic const u8 rtw8822c_pwrtrk_2g_cck_b_n[RTW_PWR_TRK_TBL_SZ] = {\n\t 0,  1,  2,  3,  4,  5,  5,  6,  7,  8,\n\t 9, 10, 11, 11, 12, 13, 14, 15, 16, 17,\n\t17, 18, 19, 20, 21, 22, 23, 23, 24, 25\n};\n\nstatic const u8 rtw8822c_pwrtrk_2g_cck_b_p[RTW_PWR_TRK_TBL_SZ] = {\n\t 0,  1,  2,  3,  4,  5,  6,  7,  8,  9,\n\t10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n\t20, 21, 22, 23, 24, 25, 26, 27, 28, 29\n};\n\nstatic const u8 rtw8822c_pwrtrk_2g_cck_a_n[RTW_PWR_TRK_TBL_SZ] = {\n\t 0,  1,  2,  3,  3,  4,  5,  6,  6,  7,\n\t 8,  9,  9, 10, 11, 12, 12, 13, 14, 15,\n\t15, 16, 17, 18, 18, 19, 20, 21, 21, 22\n};\n\nstatic const u8 rtw8822c_pwrtrk_2g_cck_a_p[RTW_PWR_TRK_TBL_SZ] = {\n\t 0,  1,  2,  3,  4,  5,  5,  6,  7,  8,\n\t 9, 10, 11, 11, 12, 13, 14, 15, 16, 17,\n\t18, 18, 19, 20, 21, 22, 23, 24, 24, 25\n};\n\nstatic const struct rtw_pwr_track_tbl rtw8822c_rtw_pwr_track_tbl = {\n\t.pwrtrk_5gb_n[RTW_PWR_TRK_5G_1] = rtw8822c_pwrtrk_5gb_n[RTW_PWR_TRK_5G_1],\n\t.pwrtrk_5gb_n[RTW_PWR_TRK_5G_2] = rtw8822c_pwrtrk_5gb_n[RTW_PWR_TRK_5G_2],\n\t.pwrtrk_5gb_n[RTW_PWR_TRK_5G_3] = rtw8822c_pwrtrk_5gb_n[RTW_PWR_TRK_5G_3],\n\t.pwrtrk_5gb_p[RTW_PWR_TRK_5G_1] = rtw8822c_pwrtrk_5gb_p[RTW_PWR_TRK_5G_1],\n\t.pwrtrk_5gb_p[RTW_PWR_TRK_5G_2] = rtw8822c_pwrtrk_5gb_p[RTW_PWR_TRK_5G_2],\n\t.pwrtrk_5gb_p[RTW_PWR_TRK_5G_3] = rtw8822c_pwrtrk_5gb_p[RTW_PWR_TRK_5G_3],\n\t.pwrtrk_5ga_n[RTW_PWR_TRK_5G_1] = rtw8822c_pwrtrk_5ga_n[RTW_PWR_TRK_5G_1],\n\t.pwrtrk_5ga_n[RTW_PWR_TRK_5G_2] = rtw8822c_pwrtrk_5ga_n[RTW_PWR_TRK_5G_2],\n\t.pwrtrk_5ga_n[RTW_PWR_TRK_5G_3] = rtw8822c_pwrtrk_5ga_n[RTW_PWR_TRK_5G_3],\n\t.pwrtrk_5ga_p[RTW_PWR_TRK_5G_1] = rtw8822c_pwrtrk_5ga_p[RTW_PWR_TRK_5G_1],\n\t.pwrtrk_5ga_p[RTW_PWR_TRK_5G_2] = rtw8822c_pwrtrk_5ga_p[RTW_PWR_TRK_5G_2],\n\t.pwrtrk_5ga_p[RTW_PWR_TRK_5G_3] = rtw8822c_pwrtrk_5ga_p[RTW_PWR_TRK_5G_3],\n\t.pwrtrk_2gb_n = rtw8822c_pwrtrk_2gb_n,\n\t.pwrtrk_2gb_p = rtw8822c_pwrtrk_2gb_p,\n\t.pwrtrk_2ga_n = rtw8822c_pwrtrk_2ga_n,\n\t.pwrtrk_2ga_p = rtw8822c_pwrtrk_2ga_p,\n\t.pwrtrk_2g_cckb_n = rtw8822c_pwrtrk_2g_cck_b_n,\n\t.pwrtrk_2g_cckb_p = rtw8822c_pwrtrk_2g_cck_b_p,\n\t.pwrtrk_2g_ccka_n = rtw8822c_pwrtrk_2g_cck_a_n,\n\t.pwrtrk_2g_ccka_p = rtw8822c_pwrtrk_2g_cck_a_p,\n};\n\nstatic struct rtw_hw_reg_offset rtw8822c_edcca_th[] = {\n\t[EDCCA_TH_L2H_IDX] = {\n\t\t{.addr = 0x84c, .mask = MASKBYTE2}, .offset = 0x80\n\t},\n\t[EDCCA_TH_H2L_IDX] = {\n\t\t{.addr = 0x84c, .mask = MASKBYTE3}, .offset = 0x80\n\t},\n};\n\n#ifdef CONFIG_PM\nstatic const struct wiphy_wowlan_support rtw_wowlan_stub_8822c = {\n\t.flags = WIPHY_WOWLAN_MAGIC_PKT | WIPHY_WOWLAN_GTK_REKEY_FAILURE |\n\t\t WIPHY_WOWLAN_DISCONNECT | WIPHY_WOWLAN_SUPPORTS_GTK_REKEY |\n\t\t WIPHY_WOWLAN_NET_DETECT,\n\t.n_patterns = RTW_MAX_PATTERN_NUM,\n\t.pattern_max_len = RTW_MAX_PATTERN_SIZE,\n\t.pattern_min_len = 1,\n\t.max_nd_match_sets = 4,\n};\n#endif\n\nstatic const struct rtw_reg_domain coex_info_hw_regs_8822c[] = {\n\t{0x1860, BIT(3), RTW_REG_DOMAIN_MAC8},\n\t{0x4160, BIT(3), RTW_REG_DOMAIN_MAC8},\n\t{0x1c32, BIT(6), RTW_REG_DOMAIN_MAC8},\n\t{0x1c38, BIT(28), RTW_REG_DOMAIN_MAC32},\n\t{0, 0, RTW_REG_DOMAIN_NL},\n\t{0x430, MASKDWORD, RTW_REG_DOMAIN_MAC32},\n\t{0x434, MASKDWORD, RTW_REG_DOMAIN_MAC32},\n\t{0x42a, MASKLWORD, RTW_REG_DOMAIN_MAC16},\n\t{0x426, MASKBYTE0, RTW_REG_DOMAIN_MAC8},\n\t{0x45e, BIT(3), RTW_REG_DOMAIN_MAC8},\n\t{0x454, MASKLWORD, RTW_REG_DOMAIN_MAC16},\n\t{0, 0, RTW_REG_DOMAIN_NL},\n\t{0x4c, BIT(24) | BIT(23), RTW_REG_DOMAIN_MAC32},\n\t{0x64, BIT(0), RTW_REG_DOMAIN_MAC8},\n\t{0x4c6, BIT(4), RTW_REG_DOMAIN_MAC8},\n\t{0x40, BIT(5), RTW_REG_DOMAIN_MAC8},\n\t{0x1, RFREG_MASK, RTW_REG_DOMAIN_RF_B},\n\t{0, 0, RTW_REG_DOMAIN_NL},\n\t{0x550, MASKDWORD, RTW_REG_DOMAIN_MAC32},\n\t{0x522, MASKBYTE0, RTW_REG_DOMAIN_MAC8},\n\t{0x953, BIT(1), RTW_REG_DOMAIN_MAC8},\n\t{0xc50, MASKBYTE0, RTW_REG_DOMAIN_MAC8},\n};\n\nconst struct rtw_chip_info rtw8822c_hw_spec = {\n\t.ops = &rtw8822c_ops,\n\t.id = RTW_CHIP_TYPE_8822C,\n\t.fw_name = \"rtw88/rtw8822c_fw.bin\",\n\t.wlan_cpu = RTW_WCPU_11AC,\n\t.tx_pkt_desc_sz = 48,\n\t.tx_buf_desc_sz = 16,\n\t.rx_pkt_desc_sz = 24,\n\t.rx_buf_desc_sz = 8,\n\t.phy_efuse_size = 512,\n\t.log_efuse_size = 768,\n\t.ptct_efuse_size = 124,\n\t.txff_size = 262144,\n\t.rxff_size = 24576,\n\t.fw_rxff_size = 12288,\n\t.rsvd_drv_pg_num = 16,\n\t.txgi_factor = 2,\n\t.is_pwr_by_rate_dec = false,\n\t.max_power_index = 0x7f,\n\t.csi_buf_pg_num = 50,\n\t.band = RTW_BAND_2G | RTW_BAND_5G,\n\t.page_size = TX_PAGE_SIZE,\n\t.dig_min = 0x20,\n\t.default_1ss_tx_path = BB_PATH_A,\n\t.path_div_supported = true,\n\t.ht_supported = true,\n\t.vht_supported = true,\n\t.lps_deep_mode_supported = BIT(LPS_DEEP_MODE_LCLK) | BIT(LPS_DEEP_MODE_PG),\n\t.sys_func_en = 0xD8,\n\t.pwr_on_seq = card_enable_flow_8822c,\n\t.pwr_off_seq = card_disable_flow_8822c,\n\t.page_table = page_table_8822c,\n\t.rqpn_table = rqpn_table_8822c,\n\t.prioq_addrs = &prioq_addrs_8822c,\n\t.intf_table = &phy_para_table_8822c,\n\t.dig = rtw8822c_dig,\n\t.dig_cck = NULL,\n\t.rf_base_addr = {0x3c00, 0x4c00},\n\t.rf_sipi_addr = {0x1808, 0x4108},\n\t.ltecoex_addr = &rtw8822c_ltecoex_addr,\n\t.mac_tbl = &rtw8822c_mac_tbl,\n\t.agc_tbl = &rtw8822c_agc_tbl,\n\t.bb_tbl = &rtw8822c_bb_tbl,\n\t.rfk_init_tbl = &rtw8822c_array_mp_cal_init_tbl,\n\t.rf_tbl = {&rtw8822c_rf_b_tbl, &rtw8822c_rf_a_tbl},\n\t.rfe_defs = rtw8822c_rfe_defs,\n\t.rfe_defs_size = ARRAY_SIZE(rtw8822c_rfe_defs),\n\t.en_dis_dpd = true,\n\t.dpd_ratemask = DIS_DPD_RATEALL,\n\t.pwr_track_tbl = &rtw8822c_rtw_pwr_track_tbl,\n\t.iqk_threshold = 8,\n\t.lck_threshold = 8,\n\t.bfer_su_max_num = 2,\n\t.bfer_mu_max_num = 1,\n\t.rx_ldpc = true,\n\t.tx_stbc = true,\n\t.edcca_th = rtw8822c_edcca_th,\n\t.l2h_th_ini_cs = 60,\n\t.l2h_th_ini_ad = 45,\n\t.ampdu_density = IEEE80211_HT_MPDU_DENSITY_2,\n\n#ifdef CONFIG_PM\n\t.wow_fw_name = \"rtw88/rtw8822c_wow_fw.bin\",\n\t.wowlan_stub = &rtw_wowlan_stub_8822c,\n\t.max_sched_scan_ssids = 4,\n#endif\n\t.max_scan_ie_len = (RTW_PROBE_PG_CNT - 1) * TX_PAGE_SIZE,\n\t.coex_para_ver = 0x22020720,\n\t.bt_desired_ver = 0x20,\n\t.scbd_support = true,\n\t.new_scbd10_def = true,\n\t.ble_hid_profile_support = true,\n\t.wl_mimo_ps_support = true,\n\t.pstdma_type = COEX_PSTDMA_FORCE_LPSOFF,\n\t.bt_rssi_type = COEX_BTRSSI_DBM,\n\t.ant_isolation = 15,\n\t.rssi_tolerance = 2,\n\t.wl_rssi_step = wl_rssi_step_8822c,\n\t.bt_rssi_step = bt_rssi_step_8822c,\n\t.table_sant_num = ARRAY_SIZE(table_sant_8822c),\n\t.table_sant = table_sant_8822c,\n\t.table_nsant_num = ARRAY_SIZE(table_nsant_8822c),\n\t.table_nsant = table_nsant_8822c,\n\t.tdma_sant_num = ARRAY_SIZE(tdma_sant_8822c),\n\t.tdma_sant = tdma_sant_8822c,\n\t.tdma_nsant_num = ARRAY_SIZE(tdma_nsant_8822c),\n\t.tdma_nsant = tdma_nsant_8822c,\n\t.wl_rf_para_num = ARRAY_SIZE(rf_para_tx_8822c),\n\t.wl_rf_para_tx = rf_para_tx_8822c,\n\t.wl_rf_para_rx = rf_para_rx_8822c,\n\t.bt_afh_span_bw20 = 0x24,\n\t.bt_afh_span_bw40 = 0x36,\n\t.afh_5g_num = ARRAY_SIZE(afh_5g_8822c),\n\t.afh_5g = afh_5g_8822c,\n\n\t.coex_info_hw_regs_num = ARRAY_SIZE(coex_info_hw_regs_8822c),\n\t.coex_info_hw_regs = coex_info_hw_regs_8822c,\n\n\t.fw_fifo_addr = {0x780, 0x700, 0x780, 0x660, 0x650, 0x680},\n\t.fwcd_segs = &rtw8822c_fwcd_segs,\n};\nEXPORT_SYMBOL(rtw8822c_hw_spec);\n\nMODULE_FIRMWARE(\"rtw88/rtw8822c_fw.bin\");\nMODULE_FIRMWARE(\"rtw88/rtw8822c_wow_fw.bin\");\n\nMODULE_AUTHOR(\"Realtek Corporation\");\nMODULE_DESCRIPTION(\"Realtek 802.11ac wireless 8822c driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}