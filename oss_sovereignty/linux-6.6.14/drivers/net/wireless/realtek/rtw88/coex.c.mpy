{
  "module_name": "coex.c",
  "hash_id": "f4b5f07eddfe8ae2c371f2c93a8051db86eb81f7927824908b26d0e5c4ac362e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtw88/coex.c",
  "human_readable_source": "\n \n\n#include \"main.h\"\n#include \"coex.h\"\n#include \"fw.h\"\n#include \"ps.h\"\n#include \"debug.h\"\n#include \"reg.h\"\n#include \"phy.h\"\n\nstatic u8 rtw_coex_next_rssi_state(struct rtw_dev *rtwdev, u8 pre_state,\n\t\t\t\t   u8 rssi, u8 rssi_thresh)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tu8 tol = chip->rssi_tolerance;\n\tu8 next_state;\n\n\tif (pre_state == COEX_RSSI_STATE_LOW ||\n\t    pre_state == COEX_RSSI_STATE_STAY_LOW) {\n\t\tif (rssi >= (rssi_thresh + tol))\n\t\t\tnext_state = COEX_RSSI_STATE_HIGH;\n\t\telse\n\t\t\tnext_state = COEX_RSSI_STATE_STAY_LOW;\n\t} else {\n\t\tif (rssi < rssi_thresh)\n\t\t\tnext_state = COEX_RSSI_STATE_LOW;\n\t\telse\n\t\t\tnext_state = COEX_RSSI_STATE_STAY_HIGH;\n\t}\n\n\treturn next_state;\n}\n\nstatic void rtw_coex_limited_tx(struct rtw_dev *rtwdev,\n\t\t\t\tbool tx_limit_en, bool ampdu_limit_en)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\tu8 num_of_active_port = 1;\n\n\tif (!chip->scbd_support)\n\t\treturn;\n\n\t \n\tif (coex_stat->wl_tx_limit_en == tx_limit_en &&\n\t    coex_stat->wl_ampdu_limit_en == ampdu_limit_en)\n\t\treturn;\n\n\tif (!coex_stat->wl_tx_limit_en) {\n\t\tcoex_stat->darfrc = rtw_read32(rtwdev, REG_DARFRC);\n\t\tcoex_stat->darfrch = rtw_read32(rtwdev, REG_DARFRCH);\n\t\tcoex_stat->retry_limit = rtw_read16(rtwdev, REG_RETRY_LIMIT);\n\t}\n\n\tif (!coex_stat->wl_ampdu_limit_en)\n\t\tcoex_stat->ampdu_max_time =\n\t\t\t\trtw_read8(rtwdev, REG_AMPDU_MAX_TIME_V1);\n\n\tcoex_stat->wl_tx_limit_en = tx_limit_en;\n\tcoex_stat->wl_ampdu_limit_en = ampdu_limit_en;\n\n\tif (tx_limit_en) {\n\t\t \n\t\trtw_write8_set(rtwdev, REG_TX_HANG_CTRL, BIT_EN_GNT_BT_AWAKE);\n\n\t\t \n\t\tif (num_of_active_port <= 1)\n\t\t\trtw_write8_set(rtwdev, REG_LIFETIME_EN, 0xf);\n\t\trtw_write16(rtwdev, REG_RETRY_LIMIT, 0x0808);\n\n\t\t \n\t\trtw_write32(rtwdev, REG_DARFRC, 0x1000000);\n\t\trtw_write32(rtwdev, REG_DARFRCH, 0x4030201);\n\t} else {\n\t\trtw_write8_clr(rtwdev, REG_TX_HANG_CTRL, BIT_EN_GNT_BT_AWAKE);\n\t\trtw_write8_clr(rtwdev, REG_LIFETIME_EN, 0xf);\n\n\t\trtw_write16(rtwdev, REG_RETRY_LIMIT, coex_stat->retry_limit);\n\t\trtw_write32(rtwdev, REG_DARFRC, coex_stat->darfrc);\n\t\trtw_write32(rtwdev, REG_DARFRCH, coex_stat->darfrch);\n\t}\n\n\tif (ampdu_limit_en)\n\t\trtw_write8(rtwdev, REG_AMPDU_MAX_TIME_V1, 0x20);\n\telse\n\t\trtw_write8(rtwdev, REG_AMPDU_MAX_TIME_V1,\n\t\t\t   coex_stat->ampdu_max_time);\n}\n\nstatic void rtw_coex_limited_wl(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_dm *coex_dm = &coex->dm;\n\tbool tx_limit = false;\n\tbool tx_agg_ctrl = false;\n\n\tif (!coex->under_5g && coex_dm->bt_status != COEX_BTSTATUS_NCON_IDLE) {\n\t\ttx_limit = true;\n\t\ttx_agg_ctrl = true;\n\t}\n\n\trtw_coex_limited_tx(rtwdev, tx_limit, tx_agg_ctrl);\n}\n\nstatic bool rtw_coex_freerun_check(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_dm *coex_dm = &coex->dm;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\tu8 bt_rssi;\n\tu8 ant_distance = 10;\n\n\tif (coex_stat->bt_disabled)\n\t\treturn false;\n\n\tif (efuse->share_ant || ant_distance <= 5 || !coex_stat->wl_gl_busy)\n\t\treturn false;\n\n\tif (ant_distance >= 40 || coex_stat->bt_hid_pair_num >= 2)\n\t\treturn true;\n\n\t \n\tif (COEX_RSSI_HIGH(coex_dm->wl_rssi_state[1]) &&\n\t    COEX_RSSI_HIGH(coex_dm->bt_rssi_state[0]))\n\t\treturn true;\n\n\tif (coex_stat->wl_tput_dir == COEX_WL_TPUT_TX)\n\t\tbt_rssi = coex_dm->bt_rssi_state[0];\n\telse\n\t\tbt_rssi = coex_dm->bt_rssi_state[1];\n\n\tif (COEX_RSSI_HIGH(coex_dm->wl_rssi_state[3]) &&\n\t    COEX_RSSI_HIGH(bt_rssi) &&\n\t    coex_stat->cnt_wl[COEX_CNT_WL_SCANAP] <= 5)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void rtw_coex_wl_slot_extend(struct rtw_dev *rtwdev, bool enable)\n{\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\tu8 para[6] = {0};\n\n\tpara[0] = COEX_H2C69_WL_LEAKAP;\n\tpara[1] = PARA1_H2C69_DIS_5MS;\n\n\tif (enable)\n\t\tpara[1] = PARA1_H2C69_EN_5MS;\n\telse\n\t\tcoex_stat->cnt_wl[COEX_CNT_WL_5MS_NOEXTEND] = 0;\n\n\tcoex_stat->wl_slot_extend = enable;\n\trtw_fw_bt_wifi_control(rtwdev, para[0], &para[1]);\n}\n\nstatic void rtw_coex_wl_ccklock_action(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\n\tif (coex->manual_control || coex->stop_dm)\n\t\treturn;\n\n\n\tif (coex_stat->tdma_timer_base == 3 && coex_stat->wl_slot_extend) {\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\"[BTCoex], set h2c 0x69 opcode 12 to turn off 5ms WL slot extend!!\\n\");\n\t\trtw_coex_wl_slot_extend(rtwdev, false);\n\t\treturn;\n\t}\n\n\tif (coex_stat->wl_slot_extend && coex_stat->wl_force_lps_ctrl &&\n\t    !coex_stat->wl_cck_lock_ever) {\n\t\tif (coex_stat->wl_fw_dbg_info[7] <= 5)\n\t\t\tcoex_stat->cnt_wl[COEX_CNT_WL_5MS_NOEXTEND]++;\n\t\telse\n\t\t\tcoex_stat->cnt_wl[COEX_CNT_WL_5MS_NOEXTEND] = 0;\n\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\"[BTCoex], 5ms WL slot extend cnt = %d!!\\n\",\n\t\t\tcoex_stat->cnt_wl[COEX_CNT_WL_5MS_NOEXTEND]);\n\n\t\tif (coex_stat->cnt_wl[COEX_CNT_WL_5MS_NOEXTEND] == 7) {\n\t\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\t\"[BTCoex], set h2c 0x69 opcode 12 to turn off 5ms WL slot extend!!\\n\");\n\t\t\trtw_coex_wl_slot_extend(rtwdev, false);\n\t\t}\n\t} else if (!coex_stat->wl_slot_extend && coex_stat->wl_cck_lock) {\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\"[BTCoex], set h2c 0x69 opcode 12 to turn on 5ms WL slot extend!!\\n\");\n\n\t\trtw_coex_wl_slot_extend(rtwdev, true);\n\t}\n}\n\nstatic void rtw_coex_wl_ccklock_detect(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\tstruct rtw_coex_dm *coex_dm = &coex->dm;\n\n\tbool is_cck_lock_rate = false;\n\n\tif (coex_stat->wl_coex_mode != COEX_WLINK_2G1PORT &&\n\t    coex_stat->wl_coex_mode != COEX_WLINK_2GFREE)\n\t\treturn;\n\n\tif (coex_dm->bt_status == COEX_BTSTATUS_INQ_PAGE ||\n\t    coex_stat->bt_setup_link) {\n\t\tcoex_stat->wl_cck_lock = false;\n\t\tcoex_stat->wl_cck_lock_pre = false;\n\t\treturn;\n\t}\n\n\tif (coex_stat->wl_rx_rate <= COEX_CCK_2 ||\n\t    coex_stat->wl_rts_rx_rate <= COEX_CCK_2)\n\t\tis_cck_lock_rate = true;\n\n\tif (coex_stat->wl_connected && coex_stat->wl_gl_busy &&\n\t    COEX_RSSI_HIGH(coex_dm->wl_rssi_state[3]) &&\n\t    (coex_dm->bt_status == COEX_BTSTATUS_ACL_BUSY ||\n\t     coex_dm->bt_status == COEX_BTSTATUS_ACL_SCO_BUSY ||\n\t     coex_dm->bt_status == COEX_BTSTATUS_SCO_BUSY)) {\n\t\tif (is_cck_lock_rate) {\n\t\t\tcoex_stat->wl_cck_lock = true;\n\n\t\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\t\"[BTCoex], cck locking...\\n\");\n\n\t\t} else {\n\t\t\tcoex_stat->wl_cck_lock = false;\n\n\t\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\t\"[BTCoex], cck unlock...\\n\");\n\t\t}\n\t} else {\n\t\tcoex_stat->wl_cck_lock = false;\n\t}\n\n\t \n\tif (coex_stat->wl_cck_lock && !coex_stat->wl_cck_lock_pre)\n\t\tieee80211_queue_delayed_work(rtwdev->hw, &coex->wl_ccklock_work,\n\t\t\t\t\t     3 * HZ);\n\n\tcoex_stat->wl_cck_lock_pre = coex_stat->wl_cck_lock;\n}\n\nstatic void rtw_coex_wl_noisy_detect(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tu32 cnt_cck;\n\tbool wl_cck_lock = false;\n\n\t \n\tcnt_cck = dm_info->cck_ok_cnt + dm_info->cck_err_cnt;\n\n\tif (!coex_stat->wl_gl_busy && !wl_cck_lock) {\n\t\tif (cnt_cck > 250) {\n\t\t\tif (coex_stat->cnt_wl[COEX_CNT_WL_NOISY2] < 5)\n\t\t\t\tcoex_stat->cnt_wl[COEX_CNT_WL_NOISY2]++;\n\n\t\t\tif (coex_stat->cnt_wl[COEX_CNT_WL_NOISY2] == 5) {\n\t\t\t\tcoex_stat->cnt_wl[COEX_CNT_WL_NOISY0] = 0;\n\t\t\t\tcoex_stat->cnt_wl[COEX_CNT_WL_NOISY1] = 0;\n\t\t\t}\n\t\t} else if (cnt_cck < 100) {\n\t\t\tif (coex_stat->cnt_wl[COEX_CNT_WL_NOISY0] < 5)\n\t\t\t\tcoex_stat->cnt_wl[COEX_CNT_WL_NOISY0]++;\n\n\t\t\tif (coex_stat->cnt_wl[COEX_CNT_WL_NOISY0] == 5) {\n\t\t\t\tcoex_stat->cnt_wl[COEX_CNT_WL_NOISY1] = 0;\n\t\t\t\tcoex_stat->cnt_wl[COEX_CNT_WL_NOISY2] = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tif (coex_stat->cnt_wl[COEX_CNT_WL_NOISY1] < 5)\n\t\t\t\tcoex_stat->cnt_wl[COEX_CNT_WL_NOISY1]++;\n\n\t\t\tif (coex_stat->cnt_wl[COEX_CNT_WL_NOISY1] == 5) {\n\t\t\t\tcoex_stat->cnt_wl[COEX_CNT_WL_NOISY0] = 0;\n\t\t\t\tcoex_stat->cnt_wl[COEX_CNT_WL_NOISY2] = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (coex_stat->cnt_wl[COEX_CNT_WL_NOISY2] == 5)\n\t\t\tcoex_stat->wl_noisy_level = 2;\n\t\telse if (coex_stat->cnt_wl[COEX_CNT_WL_NOISY1] == 5)\n\t\t\tcoex_stat->wl_noisy_level = 1;\n\t\telse\n\t\t\tcoex_stat->wl_noisy_level = 0;\n\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], wl_noisy_level = %d\\n\",\n\t\t\tcoex_stat->wl_noisy_level);\n\t}\n}\n\nstatic void rtw_coex_tdma_timer_base(struct rtw_dev *rtwdev, u8 type)\n{\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\tu8 para[2] = {0};\n\tu8 times;\n\tu16 tbtt_interval = coex_stat->wl_beacon_interval;\n\n\tif (coex_stat->tdma_timer_base == type)\n\t\treturn;\n\n\tcoex_stat->tdma_timer_base = type;\n\n\tpara[0] = COEX_H2C69_TDMA_SLOT;\n\n\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], tbtt_interval = %d\\n\",\n\t\ttbtt_interval);\n\n\tif (type == TDMA_TIMER_TYPE_4SLOT && tbtt_interval < 120) {\n\t\tpara[1] = PARA1_H2C69_TDMA_4SLOT;  \n\t} else if (tbtt_interval < 80 && tbtt_interval > 0) {\n\t\ttimes = 100 / tbtt_interval;\n\t\tif (100 % tbtt_interval != 0)\n\t\t\ttimes++;\n\n\t\tpara[1] = FIELD_PREP(PARA1_H2C69_TBTT_TIMES, times);\n\t} else if (tbtt_interval >= 180) {\n\t\ttimes = tbtt_interval / 100;\n\t\tif (tbtt_interval % 100 <= 80)\n\t\t\ttimes--;\n\n\t\tpara[1] = FIELD_PREP(PARA1_H2C69_TBTT_TIMES, times) |\n\t\t\t  FIELD_PREP(PARA1_H2C69_TBTT_DIV100, 1);\n\t} else {\n\t\tpara[1] = PARA1_H2C69_TDMA_2SLOT;\n\t}\n\n\trtw_fw_bt_wifi_control(rtwdev, para[0], &para[1]);\n\n\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], %s(): h2c_0x69 = 0x%x\\n\",\n\t\t__func__, para[1]);\n\n\t \n\tif (coex_stat->tdma_timer_base == 3)\n\t\trtw_coex_wl_ccklock_action(rtwdev);\n}\n\nstatic void rtw_coex_set_wl_pri_mask(struct rtw_dev *rtwdev, u8 bitmap,\n\t\t\t\t     u8 data)\n{\n\tu32 addr;\n\n\taddr = REG_BT_COEX_TABLE_H + (bitmap / 8);\n\tbitmap = bitmap % 8;\n\n\trtw_write8_mask(rtwdev, addr, BIT(bitmap), data);\n}\n\nvoid rtw_coex_write_scbd(struct rtw_dev *rtwdev, u16 bitpos, bool set)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\tu16 val = 0x2;\n\n\tif (!chip->scbd_support)\n\t\treturn;\n\n\tval |= coex_stat->score_board;\n\n\t \n\tif (!chip->new_scbd10_def && (bitpos & COEX_SCBD_FIX2M)) {\n\t\tif (set)\n\t\t\tval &= ~COEX_SCBD_FIX2M;\n\t\telse\n\t\t\tval |= COEX_SCBD_FIX2M;\n\t} else {\n\t\tif (set)\n\t\t\tval |= bitpos;\n\t\telse\n\t\t\tval &= ~bitpos;\n\t}\n\n\tif (val != coex_stat->score_board) {\n\t\tcoex_stat->score_board = val;\n\t\tval |= BIT_BT_INT_EN;\n\t\trtw_write16(rtwdev, REG_WIFI_BT_INFO, val);\n\t}\n}\nEXPORT_SYMBOL(rtw_coex_write_scbd);\n\nstatic u16 rtw_coex_read_scbd(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\n\tif (!chip->scbd_support)\n\t\treturn 0;\n\n\treturn (rtw_read16(rtwdev, REG_WIFI_BT_INFO)) & ~(BIT_BT_INT_EN);\n}\n\nstatic void rtw_coex_check_rfk(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\tstruct rtw_coex_rfe *coex_rfe = &coex->rfe;\n\tu8 cnt = 0;\n\tu32 wait_cnt;\n\tbool btk, wlk;\n\n\tif (coex_rfe->wlg_at_btg && chip->scbd_support &&\n\t    coex_stat->bt_iqk_state != 0xff) {\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\"[BTCoex], (Before Ant Setup) Delay by IQK\\n\");\n\n\t\twait_cnt = COEX_RFK_TIMEOUT / COEX_MIN_DELAY;\n\t\tdo {\n\t\t\t \n\t\t\tbtk = !!(rtw_coex_read_scbd(rtwdev) & COEX_SCBD_BT_RFK);\n\n\t\t\t \n\t\t\twlk = !!(rtw_read8(rtwdev, REG_ARFR4) & BIT_WL_RFK);\n\n\t\t\tif (!btk && !wlk)\n\t\t\t\tbreak;\n\n\t\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\t\"[BTCoex], (Before Ant Setup) wlk = %d, btk = %d\\n\",\n\t\t\t\twlk, btk);\n\n\t\t\tmdelay(COEX_MIN_DELAY);\n\t\t} while (++cnt < wait_cnt);\n\n\t\tif (cnt >= wait_cnt)\n\t\t\tcoex_stat->bt_iqk_state = 0xff;\n\t}\n}\n\nstatic void rtw_coex_query_bt_info(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\n\tif (coex_stat->bt_disabled)\n\t\treturn;\n\n\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], %s()\\n\", __func__);\n\n\trtw_fw_query_bt_info(rtwdev);\n}\n\nstatic void rtw_coex_gnt_workaround(struct rtw_dev *rtwdev, bool force, u8 mode)\n{\n\trtw_coex_set_gnt_fix(rtwdev);\n}\n\nstatic void rtw_coex_monitor_bt_ctr(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\tu32 tmp;\n\n\ttmp = rtw_read32(rtwdev, REG_BT_ACT_STATISTICS);\n\tcoex_stat->hi_pri_tx = FIELD_GET(MASKLWORD, tmp);\n\tcoex_stat->hi_pri_rx = FIELD_GET(MASKHWORD, tmp);\n\n\ttmp = rtw_read32(rtwdev, REG_BT_ACT_STATISTICS_1);\n\tcoex_stat->lo_pri_tx = FIELD_GET(MASKLWORD, tmp);\n\tcoex_stat->lo_pri_rx = FIELD_GET(MASKHWORD, tmp);\n\n\trtw_write8(rtwdev, REG_BT_COEX_ENH_INTR_CTRL,\n\t\t   BIT_R_GRANTALL_WLMASK | BIT_STATIS_BT_EN);\n\n\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\"[BTCoex], Hi-Pri Rx/Tx: %d/%d, Lo-Pri Rx/Tx: %d/%d\\n\",\n\t\tcoex_stat->hi_pri_rx, coex_stat->hi_pri_tx,\n\t\tcoex_stat->lo_pri_rx, coex_stat->lo_pri_tx);\n}\n\nstatic void rtw_coex_monitor_bt_enable(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\tstruct rtw_coex_dm *coex_dm = &coex->dm;\n\tbool bt_disabled = false;\n\tu16 score_board;\n\n\tif (chip->scbd_support) {\n\t\tscore_board = rtw_coex_read_scbd(rtwdev);\n\t\tbt_disabled = !(score_board & COEX_SCBD_ONOFF);\n\t}\n\n\tif (coex_stat->bt_disabled != bt_disabled) {\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\"[BTCoex], BT state changed (%d) -> (%d)\\n\",\n\t\t\tcoex_stat->bt_disabled, bt_disabled);\n\n\t\tcoex_stat->bt_disabled = bt_disabled;\n\t\tcoex_stat->bt_ble_scan_type = 0;\n\t\tcoex_dm->cur_bt_lna_lvl = 0;\n\n\t\tif (!coex_stat->bt_disabled) {\n\t\t\tcoex_stat->bt_reenable = true;\n\t\t\tieee80211_queue_delayed_work(rtwdev->hw,\n\t\t\t\t\t\t     &coex->bt_reenable_work,\n\t\t\t\t\t\t     15 * HZ);\n\t\t} else {\n\t\t\tcoex_stat->bt_mailbox_reply = false;\n\t\t\tcoex_stat->bt_reenable = false;\n\t\t}\n\t}\n}\n\nstatic void rtw_coex_update_wl_link_info(struct rtw_dev *rtwdev, u8 reason)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\tstruct rtw_coex_dm *coex_dm = &coex->dm;\n\tstruct rtw_traffic_stats *stats = &rtwdev->stats;\n\tbool is_5G = false;\n\tbool wl_busy = false;\n\tbool scan = false, link = false;\n\tint i;\n\tu8 rssi_state;\n\tu8 rssi_step;\n\tu8 rssi;\n\n\tscan = test_bit(RTW_FLAG_SCANNING, rtwdev->flags);\n\tcoex_stat->wl_connected = !!rtwdev->sta_cnt;\n\n\twl_busy = test_bit(RTW_FLAG_BUSY_TRAFFIC, rtwdev->flags);\n\tif (wl_busy != coex_stat->wl_gl_busy) {\n\t\tif (wl_busy)\n\t\t\tcoex_stat->wl_gl_busy = true;\n\t\telse\n\t\t\tieee80211_queue_delayed_work(rtwdev->hw,\n\t\t\t\t\t\t     &coex->wl_remain_work,\n\t\t\t\t\t\t     12 * HZ);\n\t}\n\n\tif (stats->tx_throughput > stats->rx_throughput)\n\t\tcoex_stat->wl_tput_dir = COEX_WL_TPUT_TX;\n\telse\n\t\tcoex_stat->wl_tput_dir = COEX_WL_TPUT_RX;\n\n\tif (scan || link || reason == COEX_RSN_2GCONSTART ||\n\t    reason == COEX_RSN_2GSCANSTART || reason == COEX_RSN_2GSWITCHBAND)\n\t\tcoex_stat->wl_linkscan_proc = true;\n\telse\n\t\tcoex_stat->wl_linkscan_proc = false;\n\n\trtw_coex_wl_noisy_detect(rtwdev);\n\n\tfor (i = 0; i < 4; i++) {\n\t\trssi_state = coex_dm->wl_rssi_state[i];\n\t\trssi_step = chip->wl_rssi_step[i];\n\t\trssi = rtwdev->dm_info.min_rssi;\n\t\trssi_state = rtw_coex_next_rssi_state(rtwdev, rssi_state,\n\t\t\t\t\t\t      rssi, rssi_step);\n\t\tcoex_dm->wl_rssi_state[i] = rssi_state;\n\t}\n\n\tif (coex_stat->wl_linkscan_proc || coex_stat->wl_hi_pri_task1 ||\n\t    coex_stat->wl_hi_pri_task2 || coex_stat->wl_gl_busy)\n\t\trtw_coex_write_scbd(rtwdev, COEX_SCBD_SCAN, true);\n\telse\n\t\trtw_coex_write_scbd(rtwdev, COEX_SCBD_SCAN, false);\n\n\tswitch (reason) {\n\tcase COEX_RSN_5GSCANSTART:\n\tcase COEX_RSN_5GSWITCHBAND:\n\tcase COEX_RSN_5GCONSTART:\n\n\t\tis_5G = true;\n\t\tbreak;\n\tcase COEX_RSN_2GSCANSTART:\n\tcase COEX_RSN_2GSWITCHBAND:\n\tcase COEX_RSN_2GCONSTART:\n\n\t\tis_5G = false;\n\t\tbreak;\n\tdefault:\n\t\tif (rtwdev->hal.current_band_type == RTW_BAND_5G)\n\t\t\tis_5G = true;\n\t\telse\n\t\t\tis_5G = false;\n\t\tbreak;\n\t}\n\n\tcoex->under_5g = is_5G;\n}\n\nstatic inline u8 *get_payload_from_coex_resp(struct sk_buff *resp)\n{\n\tstruct rtw_c2h_cmd *c2h;\n\tu32 pkt_offset;\n\n\tpkt_offset = *((u32 *)resp->cb);\n\tc2h = (struct rtw_c2h_cmd *)(resp->data + pkt_offset);\n\n\treturn c2h->payload;\n}\n\nvoid rtw_coex_info_response(struct rtw_dev *rtwdev, struct sk_buff *skb)\n{\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tu8 *payload = get_payload_from_coex_resp(skb);\n\n\tif (payload[0] != COEX_RESP_ACK_BY_WL_FW) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn;\n\t}\n\n\tskb_queue_tail(&coex->queue, skb);\n\twake_up(&coex->wait);\n}\n\nstatic struct sk_buff *rtw_coex_info_request(struct rtw_dev *rtwdev,\n\t\t\t\t\t     struct rtw_coex_info_req *req)\n{\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct sk_buff *skb_resp = NULL;\n\n\tlockdep_assert_held(&rtwdev->mutex);\n\n\trtw_fw_query_bt_mp_info(rtwdev, req);\n\n\tif (!wait_event_timeout(coex->wait, !skb_queue_empty(&coex->queue),\n\t\t\t\tCOEX_REQUEST_TIMEOUT)) {\n\t\trtw_err(rtwdev, \"coex request time out\\n\");\n\t\tgoto out;\n\t}\n\n\tskb_resp = skb_dequeue(&coex->queue);\n\tif (!skb_resp) {\n\t\trtw_err(rtwdev, \"failed to get coex info response\\n\");\n\t\tgoto out;\n\t}\n\nout:\n\treturn skb_resp;\n}\n\nstatic bool rtw_coex_get_bt_scan_type(struct rtw_dev *rtwdev, u8 *scan_type)\n{\n\tstruct rtw_coex_info_req req = {0};\n\tstruct sk_buff *skb;\n\tu8 *payload;\n\n\treq.op_code = BT_MP_INFO_OP_SCAN_TYPE;\n\tskb = rtw_coex_info_request(rtwdev, &req);\n\tif (!skb)\n\t\treturn false;\n\n\tpayload = get_payload_from_coex_resp(skb);\n\t*scan_type = GET_COEX_RESP_BT_SCAN_TYPE(payload);\n\tdev_kfree_skb_any(skb);\n\treturn true;\n}\n\nstatic bool rtw_coex_set_lna_constrain_level(struct rtw_dev *rtwdev,\n\t\t\t\t\t     u8 lna_constrain_level)\n{\n\tstruct rtw_coex_info_req req = {0};\n\tstruct sk_buff *skb;\n\n\treq.op_code = BT_MP_INFO_OP_LNA_CONSTRAINT;\n\treq.para1 = lna_constrain_level;\n\tskb = rtw_coex_info_request(rtwdev, &req);\n\tif (!skb)\n\t\treturn false;\n\n\tdev_kfree_skb_any(skb);\n\treturn true;\n}\n\n#define case_BTSTATUS(src) \\\n\tcase COEX_BTSTATUS_##src: return #src\n\nstatic const char *rtw_coex_get_bt_status_string(u8 bt_status)\n{\n\tswitch (bt_status) {\n\tcase_BTSTATUS(NCON_IDLE);\n\tcase_BTSTATUS(CON_IDLE);\n\tcase_BTSTATUS(INQ_PAGE);\n\tcase_BTSTATUS(ACL_BUSY);\n\tcase_BTSTATUS(SCO_BUSY);\n\tcase_BTSTATUS(ACL_SCO_BUSY);\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n}\n\nstatic void rtw_coex_update_bt_link_info(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\tstruct rtw_coex_dm *coex_dm = &coex->dm;\n\tu8 i;\n\tu8 rssi_state;\n\tu8 rssi_step;\n\tu8 rssi;\n\n\t \n\tfor (i = 0; i < COEX_RSSI_STEP; i++) {\n\t\trssi_state = coex_dm->bt_rssi_state[i];\n\t\trssi_step = chip->bt_rssi_step[i];\n\t\trssi = coex_stat->bt_rssi;\n\t\trssi_state = rtw_coex_next_rssi_state(rtwdev, rssi_state, rssi,\n\t\t\t\t\t\t      rssi_step);\n\t\tcoex_dm->bt_rssi_state[i] = rssi_state;\n\t}\n\n\tif (coex_stat->bt_ble_scan_en &&\n\t    coex_stat->cnt_bt[COEX_CNT_BT_INFOUPDATE] % 3 == 0) {\n\t\tu8 scan_type;\n\n\t\tif (rtw_coex_get_bt_scan_type(rtwdev, &scan_type)) {\n\t\t\tcoex_stat->bt_ble_scan_type = scan_type;\n\t\t\tif ((coex_stat->bt_ble_scan_type & 0x1) == 0x1)\n\t\t\t\tcoex_stat->bt_init_scan = true;\n\t\t\telse\n\t\t\t\tcoex_stat->bt_init_scan = false;\n\t\t}\n\t}\n\n\tcoex_stat->bt_profile_num = 0;\n\n\t \n\tif (!(coex_stat->bt_info_lb2 & COEX_INFO_CONNECTION)) {\n\t\tcoex_stat->bt_link_exist = false;\n\t\tcoex_stat->bt_pan_exist = false;\n\t\tcoex_stat->bt_a2dp_exist = false;\n\t\tcoex_stat->bt_hid_exist = false;\n\t\tcoex_stat->bt_hfp_exist = false;\n\t} else {\n\t\t \n\t\tcoex_stat->bt_link_exist = true;\n\t\tif (coex_stat->bt_info_lb2 & COEX_INFO_FTP) {\n\t\t\tcoex_stat->bt_pan_exist = true;\n\t\t\tcoex_stat->bt_profile_num++;\n\t\t} else {\n\t\t\tcoex_stat->bt_pan_exist = false;\n\t\t}\n\n\t\tif (coex_stat->bt_info_lb2 & COEX_INFO_A2DP) {\n\t\t\tcoex_stat->bt_a2dp_exist = true;\n\t\t\tcoex_stat->bt_profile_num++;\n\t\t} else {\n\t\t\tcoex_stat->bt_a2dp_exist = false;\n\t\t}\n\n\t\tif (coex_stat->bt_info_lb2 & COEX_INFO_HID) {\n\t\t\tcoex_stat->bt_hid_exist = true;\n\t\t\tcoex_stat->bt_profile_num++;\n\t\t} else {\n\t\t\tcoex_stat->bt_hid_exist = false;\n\t\t}\n\n\t\tif (coex_stat->bt_info_lb2 & COEX_INFO_SCO_ESCO) {\n\t\t\tcoex_stat->bt_hfp_exist = true;\n\t\t\tcoex_stat->bt_profile_num++;\n\t\t} else {\n\t\t\tcoex_stat->bt_hfp_exist = false;\n\t\t}\n\t}\n\n\tif (coex_stat->bt_info_lb2 & COEX_INFO_INQ_PAGE) {\n\t\tcoex_dm->bt_status = COEX_BTSTATUS_INQ_PAGE;\n\t} else if (!(coex_stat->bt_info_lb2 & COEX_INFO_CONNECTION)) {\n\t\tcoex_dm->bt_status = COEX_BTSTATUS_NCON_IDLE;\n\t\tcoex_stat->bt_multi_link_remain = false;\n\t} else if (coex_stat->bt_info_lb2 == COEX_INFO_CONNECTION) {\n\t\tcoex_dm->bt_status = COEX_BTSTATUS_CON_IDLE;\n\t} else if ((coex_stat->bt_info_lb2 & COEX_INFO_SCO_ESCO) ||\n\t\t   (coex_stat->bt_info_lb2 & COEX_INFO_SCO_BUSY)) {\n\t\tif (coex_stat->bt_info_lb2 & COEX_INFO_ACL_BUSY)\n\t\t\tcoex_dm->bt_status = COEX_BTSTATUS_ACL_SCO_BUSY;\n\t\telse\n\t\t\tcoex_dm->bt_status = COEX_BTSTATUS_SCO_BUSY;\n\t} else if (coex_stat->bt_info_lb2 & COEX_INFO_ACL_BUSY) {\n\t\tcoex_dm->bt_status = COEX_BTSTATUS_ACL_BUSY;\n\t} else {\n\t\tcoex_dm->bt_status = COEX_BTSTATUS_MAX;\n\t}\n\n\tcoex_stat->cnt_bt[COEX_CNT_BT_INFOUPDATE]++;\n\n\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], %s(), %s!!!\\n\", __func__,\n\t\trtw_coex_get_bt_status_string(coex_dm->bt_status));\n}\n\nstatic void rtw_coex_update_wl_ch_info(struct rtw_dev *rtwdev, u8 type)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\tstruct rtw_coex_dm *coex_dm = &rtwdev->coex.dm;\n\tstruct rtw_coex_stat *coex_stat = &rtwdev->coex.stat;\n\tu8 link = 0;\n\tu8 center_chan = 0;\n\tu8 bw;\n\tint i;\n\n\tbw = rtwdev->hal.current_band_width;\n\n\tif (type != COEX_MEDIA_DISCONNECT)\n\t\tcenter_chan = rtwdev->hal.current_channel;\n\n\tif (center_chan == 0 ||\n\t    (efuse->share_ant && center_chan <= 14 &&\n\t     coex_stat->wl_coex_mode != COEX_WLINK_2GFREE)) {\n\t\tlink = 0;\n\t\tcenter_chan = 0;\n\t\tbw = 0;\n\t} else if (center_chan <= 14) {\n\t\tlink = 0x1;\n\n\t\tif (bw == RTW_CHANNEL_WIDTH_40)\n\t\t\tbw = chip->bt_afh_span_bw40;\n\t\telse\n\t\t\tbw = chip->bt_afh_span_bw20;\n\t} else if (chip->afh_5g_num > 1) {\n\t\tfor (i = 0; i < chip->afh_5g_num; i++) {\n\t\t\tif (center_chan == chip->afh_5g[i].wl_5g_ch) {\n\t\t\t\tlink = 0x3;\n\t\t\t\tcenter_chan = chip->afh_5g[i].bt_skip_ch;\n\t\t\t\tbw = chip->afh_5g[i].bt_skip_span;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tcoex_dm->wl_ch_info[0] = link;\n\tcoex_dm->wl_ch_info[1] = center_chan;\n\tcoex_dm->wl_ch_info[2] = bw;\n\n\trtw_fw_wl_ch_info(rtwdev, link, center_chan, bw);\n\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\"[BTCoex], %s: para[0:2] = 0x%x 0x%x 0x%x\\n\", __func__, link,\n\t\tcenter_chan, bw);\n}\n\nstatic void rtw_coex_set_bt_tx_power(struct rtw_dev *rtwdev, u8 bt_pwr_dec_lvl)\n{\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_dm *coex_dm = &coex->dm;\n\n\tif (bt_pwr_dec_lvl == coex_dm->cur_bt_pwr_lvl)\n\t\treturn;\n\n\tcoex_dm->cur_bt_pwr_lvl = bt_pwr_dec_lvl;\n\n\trtw_fw_force_bt_tx_power(rtwdev, bt_pwr_dec_lvl);\n}\n\nstatic void rtw_coex_set_bt_rx_gain(struct rtw_dev *rtwdev, u8 bt_lna_lvl)\n{\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_dm *coex_dm = &coex->dm;\n\n\tif (bt_lna_lvl == coex_dm->cur_bt_lna_lvl)\n\t\treturn;\n\n\tcoex_dm->cur_bt_lna_lvl = bt_lna_lvl;\n\n\t \n\tif (bt_lna_lvl < 7) {\n\t\trtw_coex_set_lna_constrain_level(rtwdev, bt_lna_lvl);\n\t\trtw_coex_write_scbd(rtwdev, COEX_SCBD_RXGAIN, true);\n\t} else {\n\t\trtw_coex_write_scbd(rtwdev, COEX_SCBD_RXGAIN, false);\n\t}\n\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], %s(): bt_rx_LNA_level = %d\\n\",\n\t\t__func__, bt_lna_lvl);\n}\n\nstatic void rtw_coex_set_rf_para(struct rtw_dev *rtwdev,\n\t\t\t\t struct coex_rf_para para)\n{\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\tu8 offset = 0;\n\n\tif (coex->freerun && coex_stat->cnt_wl[COEX_CNT_WL_SCANAP] <= 5)\n\t\toffset = 3;\n\n\trtw_coex_set_wl_tx_power(rtwdev, para.wl_pwr_dec_lvl);\n\trtw_coex_set_bt_tx_power(rtwdev, para.bt_pwr_dec_lvl + offset);\n\trtw_coex_set_wl_rx_gain(rtwdev, para.wl_low_gain_en);\n\trtw_coex_set_bt_rx_gain(rtwdev, para.bt_lna_lvl);\n}\n\nu32 rtw_coex_read_indirect_reg(struct rtw_dev *rtwdev, u16 addr)\n{\n\tu32 val;\n\n\tif (!ltecoex_read_reg(rtwdev, addr, &val)) {\n\t\trtw_err(rtwdev, \"failed to read indirect register\\n\");\n\t\treturn 0;\n\t}\n\n\treturn val;\n}\nEXPORT_SYMBOL(rtw_coex_read_indirect_reg);\n\nvoid rtw_coex_write_indirect_reg(struct rtw_dev *rtwdev, u16 addr,\n\t\t\t\t u32 mask, u32 val)\n{\n\tu32 shift = __ffs(mask);\n\tu32 tmp;\n\n\ttmp = rtw_coex_read_indirect_reg(rtwdev, addr);\n\ttmp = (tmp & (~mask)) | ((val << shift) & mask);\n\n\tif (!ltecoex_reg_write(rtwdev, addr, tmp))\n\t\trtw_err(rtwdev, \"failed to write indirect register\\n\");\n}\nEXPORT_SYMBOL(rtw_coex_write_indirect_reg);\n\nstatic void rtw_coex_coex_ctrl_owner(struct rtw_dev *rtwdev, bool wifi_control)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tconst struct rtw_hw_reg *btg_reg = chip->btg_reg;\n\n\tif (wifi_control) {\n\t\trtw_write8_set(rtwdev, REG_SYS_SDIO_CTRL + 3,\n\t\t\t       BIT_LTE_MUX_CTRL_PATH >> 24);\n\t\tif (btg_reg)\n\t\t\trtw_write8_set(rtwdev, btg_reg->addr, btg_reg->mask);\n\t} else {\n\t\trtw_write8_clr(rtwdev, REG_SYS_SDIO_CTRL + 3,\n\t\t\t       BIT_LTE_MUX_CTRL_PATH >> 24);\n\t\tif (btg_reg)\n\t\t\trtw_write8_clr(rtwdev, btg_reg->addr, btg_reg->mask);\n\t}\n}\n\nstatic void rtw_coex_set_gnt_bt(struct rtw_dev *rtwdev, u8 state)\n{\n\trtw_coex_write_indirect_reg(rtwdev, LTE_COEX_CTRL, 0xc000, state);\n\trtw_coex_write_indirect_reg(rtwdev, LTE_COEX_CTRL, 0x0c00, state);\n}\n\nstatic void rtw_coex_set_gnt_wl(struct rtw_dev *rtwdev, u8 state)\n{\n\trtw_coex_write_indirect_reg(rtwdev, LTE_COEX_CTRL, 0x3000, state);\n\trtw_coex_write_indirect_reg(rtwdev, LTE_COEX_CTRL, 0x0300, state);\n}\n\nstatic void rtw_coex_mimo_ps(struct rtw_dev *rtwdev, bool force, bool state)\n{\n\tstruct rtw_coex_stat *coex_stat = &rtwdev->coex.stat;\n\n\tif (!force && state == coex_stat->wl_mimo_ps)\n\t\treturn;\n\n\tcoex_stat->wl_mimo_ps = state;\n\n\trtw_set_txrx_1ss(rtwdev, state);\n\n\trtw_coex_update_wl_ch_info(rtwdev, (u8)coex_stat->wl_connected);\n\n\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\"[BTCoex], %s(): state = %d\\n\", __func__, state);\n}\n\nstatic void rtw_btc_wltoggle_table_a(struct rtw_dev *rtwdev, bool force,\n\t\t\t\t     u8 table_case)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\tu8 h2c_para[6] = {0};\n\tu32 table_wl = 0x5a5a5a5a;\n\n\th2c_para[0] = COEX_H2C69_TOGGLE_TABLE_A;\n\t \n\th2c_para[1] = 0x1;\n\n\tif (efuse->share_ant) {\n\t\tif (table_case < chip->table_sant_num)\n\t\t\ttable_wl = chip->table_sant[table_case].wl;\n\t} else {\n\t\tif (table_case < chip->table_nsant_num)\n\t\t\ttable_wl = chip->table_nsant[table_case].wl;\n\t}\n\n\t \n\th2c_para[2] = (u8)u32_get_bits(table_wl, GENMASK(7, 0));\n\th2c_para[3] = (u8)u32_get_bits(table_wl, GENMASK(15, 8));\n\th2c_para[4] = (u8)u32_get_bits(table_wl, GENMASK(23, 16));\n\th2c_para[5] = (u8)u32_get_bits(table_wl, GENMASK(31, 24));\n\n\trtw_fw_bt_wifi_control(rtwdev, h2c_para[0], &h2c_para[1]);\n\n\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\"[BTCoex], %s(): H2C = [%02x %02x %02x %02x %02x %02x]\\n\",\n\t\t__func__, h2c_para[0], h2c_para[1], h2c_para[2],\n\t\th2c_para[3], h2c_para[4], h2c_para[5]);\n}\n\n#define COEX_WL_SLOT_TOGLLE 0x5a5a5aaa\nstatic void rtw_btc_wltoggle_table_b(struct rtw_dev *rtwdev, bool force,\n\t\t\t\t     u8 interval, u32 table)\n{\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\tu8 cur_h2c_para[6] = {0};\n\tu8 i;\n\n\tcur_h2c_para[0] = COEX_H2C69_TOGGLE_TABLE_B;\n\tcur_h2c_para[1] = interval;\n\tcur_h2c_para[2] = (u8)u32_get_bits(table, GENMASK(7, 0));\n\tcur_h2c_para[3] = (u8)u32_get_bits(table, GENMASK(15, 8));\n\tcur_h2c_para[4] = (u8)u32_get_bits(table, GENMASK(23, 16));\n\tcur_h2c_para[5] = (u8)u32_get_bits(table, GENMASK(31, 24));\n\n\tcoex_stat->wl_toggle_interval = interval;\n\n\tfor (i = 0; i <= 5; i++)\n\t\tcoex_stat->wl_toggle_para[i] = cur_h2c_para[i];\n\n\trtw_fw_bt_wifi_control(rtwdev, cur_h2c_para[0], &cur_h2c_para[1]);\n\n\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\"[BTCoex], %s(): H2C = [%02x %02x %02x %02x %02x %02x]\\n\",\n\t\t__func__, cur_h2c_para[0], cur_h2c_para[1], cur_h2c_para[2],\n\t\tcur_h2c_para[3], cur_h2c_para[4], cur_h2c_para[5]);\n}\n\nstatic void rtw_coex_set_table(struct rtw_dev *rtwdev, bool force, u32 table0,\n\t\t\t       u32 table1)\n{\n#define DEF_BRK_TABLE_VAL 0xf0ffffff\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_dm *coex_dm = &coex->dm;\n\n\t \n\tif (!force && coex_dm->reason != COEX_RSN_LPS) {\n\t\tif (table0 == rtw_read32(rtwdev, REG_BT_COEX_TABLE0) &&\n\t\t    table1 == rtw_read32(rtwdev, REG_BT_COEX_TABLE1))\n\t\t\treturn;\n\t}\n\trtw_write32(rtwdev, REG_BT_COEX_TABLE0, table0);\n\trtw_write32(rtwdev, REG_BT_COEX_TABLE1, table1);\n\trtw_write32(rtwdev, REG_BT_COEX_BRK_TABLE, DEF_BRK_TABLE_VAL);\n\n\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\"[BTCoex], %s(): 0x6c0 = %x, 0x6c4 = %x\\n\", __func__, table0,\n\t\ttable1);\n}\n\nstatic void rtw_coex_table(struct rtw_dev *rtwdev, bool force, u8 type)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_dm *coex_dm = &coex->dm;\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\n\tcoex_dm->cur_table = type;\n\n\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], Coex_Table - %d\\n\", type);\n\n\tif (efuse->share_ant) {\n\t\tif (type < chip->table_sant_num)\n\t\t\trtw_coex_set_table(rtwdev, force,\n\t\t\t\t\t   chip->table_sant[type].bt,\n\t\t\t\t\t   chip->table_sant[type].wl);\n\t} else {\n\t\ttype = type - 100;\n\t\tif (type < chip->table_nsant_num)\n\t\t\trtw_coex_set_table(rtwdev, force,\n\t\t\t\t\t   chip->table_nsant[type].bt,\n\t\t\t\t\t   chip->table_nsant[type].wl);\n\t}\n\tif (coex_stat->wl_slot_toggle_change)\n\t\trtw_btc_wltoggle_table_a(rtwdev, true, type);\n}\n\nstatic void rtw_coex_ignore_wlan_act(struct rtw_dev *rtwdev, bool enable)\n{\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\n\tif (coex->manual_control || coex->stop_dm)\n\t\treturn;\n\n\trtw_fw_bt_ignore_wlan_action(rtwdev, enable);\n}\n\nstatic void rtw_coex_power_save_state(struct rtw_dev *rtwdev, u8 ps_type,\n\t\t\t\t      u8 lps_val, u8 rpwm_val)\n{\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\tu8 lps_mode = 0x0;\n\n\tlps_mode = rtwdev->lps_conf.mode;\n\n\tswitch (ps_type) {\n\tcase COEX_PS_WIFI_NATIVE:\n\t\t \n\t\tcoex_stat->wl_force_lps_ctrl = false;\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\"[BTCoex], %s(): COEX_PS_WIFI_NATIVE\\n\", __func__);\n\t\trtw_leave_lps(rtwdev);\n\t\tbreak;\n\tcase COEX_PS_LPS_OFF:\n\t\tcoex_stat->wl_force_lps_ctrl = true;\n\t\tif (lps_mode)\n\t\t\trtw_fw_coex_tdma_type(rtwdev, 0, 0, 0, 0, 0);\n\n\t\trtw_leave_lps(rtwdev);\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\"[BTCoex], %s(): COEX_PS_LPS_OFF\\n\", __func__);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void rtw_coex_set_tdma(struct rtw_dev *rtwdev, u8 byte1, u8 byte2,\n\t\t\t      u8 byte3, u8 byte4, u8 byte5)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_dm *coex_dm = &coex->dm;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\tu8 ps_type = COEX_PS_WIFI_NATIVE;\n\tbool ap_enable = false;\n\n\tif (ap_enable && (byte1 & BIT(4) && !(byte1 & BIT(5)))) {\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], %s(): AP mode\\n\",\n\t\t\t__func__);\n\n\t\tbyte1 &= ~BIT(4);\n\t\tbyte1 |= BIT(5);\n\n\t\tbyte5 |= BIT(5);\n\t\tbyte5 &= ~BIT(6);\n\n\t\tps_type = COEX_PS_WIFI_NATIVE;\n\t\trtw_coex_power_save_state(rtwdev, ps_type, 0x0, 0x0);\n\t} else if ((byte1 & BIT(4) && !(byte1 & BIT(5))) ||\n\t\t   coex_stat->wl_coex_mode == COEX_WLINK_2GFREE) {\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\"[BTCoex], %s(): Force LPS (byte1 = 0x%x)\\n\", __func__,\n\t\t\tbyte1);\n\n\t\tif (chip->pstdma_type == COEX_PSTDMA_FORCE_LPSOFF)\n\t\t\tps_type = COEX_PS_LPS_OFF;\n\t\telse\n\t\t\tps_type = COEX_PS_LPS_ON;\n\t\trtw_coex_power_save_state(rtwdev, ps_type, 0x50, 0x4);\n\t} else {\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\"[BTCoex], %s(): native power save (byte1 = 0x%x)\\n\",\n\t\t\t__func__, byte1);\n\n\t\tps_type = COEX_PS_WIFI_NATIVE;\n\t\trtw_coex_power_save_state(rtwdev, ps_type, 0x0, 0x0);\n\t}\n\n\tcoex_dm->ps_tdma_para[0] = byte1;\n\tcoex_dm->ps_tdma_para[1] = byte2;\n\tcoex_dm->ps_tdma_para[2] = byte3;\n\tcoex_dm->ps_tdma_para[3] = byte4;\n\tcoex_dm->ps_tdma_para[4] = byte5;\n\n\trtw_fw_coex_tdma_type(rtwdev, byte1, byte2, byte3, byte4, byte5);\n\n\tif (byte1 & BIT(2)) {\n\t\tcoex_stat->wl_slot_toggle = true;\n\t\tcoex_stat->wl_slot_toggle_change = false;\n\t} else {\n\t\tcoex_stat->wl_slot_toggle_change = coex_stat->wl_slot_toggle;\n\t\tcoex_stat->wl_slot_toggle = false;\n\t}\n}\n\nstatic void rtw_coex_tdma(struct rtw_dev *rtwdev, bool force, u32 tcase)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_dm *coex_dm = &coex->dm;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\tu8 n, type;\n\tbool turn_on;\n\tbool wl_busy = false;\n\n\tif (tcase & TDMA_4SLOT)  \n\t\trtw_coex_tdma_timer_base(rtwdev, TDMA_TIMER_TYPE_4SLOT);\n\telse\n\t\trtw_coex_tdma_timer_base(rtwdev, TDMA_TIMER_TYPE_2SLOT);\n\n\ttype = (u8)(tcase & 0xff);\n\n\tturn_on = (type == 0 || type == 100) ? false : true;\n\n\tif (!force && turn_on == coex_dm->cur_ps_tdma_on &&\n\t    type == coex_dm->cur_ps_tdma) {\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\"[BTCoex], Skip TDMA because no change TDMA(%s, %d)\\n\",\n\t\t\t(coex_dm->cur_ps_tdma_on ? \"on\" : \"off\"),\n\t\t\tcoex_dm->cur_ps_tdma);\n\n\t\treturn;\n\t}\n\twl_busy = test_bit(RTW_FLAG_BUSY_TRAFFIC, rtwdev->flags);\n\n\tif ((coex_stat->bt_a2dp_exist &&\n\t     (coex_stat->bt_inq_remain || coex_stat->bt_multi_link)) ||\n\t    !wl_busy)\n\t\trtw_coex_write_scbd(rtwdev, COEX_SCBD_TDMA, false);\n\telse\n\t\trtw_coex_write_scbd(rtwdev, COEX_SCBD_TDMA, true);\n\n\t \n\tcoex_dm->cur_ps_tdma_on = turn_on;\n\tcoex_dm->cur_ps_tdma = type;\n\n\tif (efuse->share_ant) {\n\t\tif (type < chip->tdma_sant_num)\n\t\t\trtw_coex_set_tdma(rtwdev,\n\t\t\t\t\t  chip->tdma_sant[type].para[0],\n\t\t\t\t\t  chip->tdma_sant[type].para[1],\n\t\t\t\t\t  chip->tdma_sant[type].para[2],\n\t\t\t\t\t  chip->tdma_sant[type].para[3],\n\t\t\t\t\t  chip->tdma_sant[type].para[4]);\n\t} else {\n\t\tn = type - 100;\n\t\tif (n < chip->tdma_nsant_num)\n\t\t\trtw_coex_set_tdma(rtwdev,\n\t\t\t\t\t  chip->tdma_nsant[n].para[0],\n\t\t\t\t\t  chip->tdma_nsant[n].para[1],\n\t\t\t\t\t  chip->tdma_nsant[n].para[2],\n\t\t\t\t\t  chip->tdma_nsant[n].para[3],\n\t\t\t\t\t  chip->tdma_nsant[n].para[4]);\n\t}\n\n\n\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], coex tdma type(%s, %d)\\n\",\n\t\tturn_on ? \"on\" : \"off\", type);\n}\n\nstatic void rtw_coex_set_ant_path(struct rtw_dev *rtwdev, bool force, u8 phase)\n{\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\tstruct rtw_coex_rfe *coex_rfe = &coex->rfe;\n\tstruct rtw_coex_dm *coex_dm = &coex->dm;\n\tu8 ctrl_type = COEX_SWITCH_CTRL_MAX;\n\tu8 pos_type = COEX_SWITCH_TO_MAX;\n\n\tif (!force && coex_dm->cur_ant_pos_type == phase)\n\t\treturn;\n\n\tcoex_dm->cur_ant_pos_type = phase;\n\n\t \n\trtw_coex_check_rfk(rtwdev);\n\n\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\"[BTCoex],  coex_stat->bt_disabled = 0x%x\\n\",\n\t\tcoex_stat->bt_disabled);\n\n\tswitch (phase) {\n\tcase COEX_SET_ANT_POWERON:\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\"[BTCoex], %s() - PHASE_COEX_POWERON\\n\", __func__);\n\t\t \n\t\tif (coex_stat->bt_disabled)\n\t\t\trtw_coex_coex_ctrl_owner(rtwdev, true);\n\t\telse\n\t\t\trtw_coex_coex_ctrl_owner(rtwdev, false);\n\n\t\tctrl_type = COEX_SWITCH_CTRL_BY_BBSW;\n\t\tpos_type = COEX_SWITCH_TO_BT;\n\t\tbreak;\n\tcase COEX_SET_ANT_INIT:\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\"[BTCoex], %s() - PHASE_COEX_INIT\\n\", __func__);\n\t\tif (coex_stat->bt_disabled) {\n\t\t\t \n\t\t\trtw_coex_set_gnt_bt(rtwdev, COEX_GNT_SET_SW_LOW);\n\n\t\t\t \n\t\t\trtw_coex_set_gnt_wl(rtwdev, COEX_GNT_SET_SW_HIGH);\n\t\t} else {\n\t\t\t \n\t\t\trtw_coex_set_gnt_bt(rtwdev, COEX_GNT_SET_SW_HIGH);\n\n\t\t\t \n\t\t\trtw_coex_set_gnt_wl(rtwdev, COEX_GNT_SET_SW_LOW);\n\t\t}\n\n\t\t \n\t\trtw_coex_coex_ctrl_owner(rtwdev, true);\n\n\t\tctrl_type = COEX_SWITCH_CTRL_BY_BBSW;\n\t\tpos_type = COEX_SWITCH_TO_BT;\n\t\tbreak;\n\tcase COEX_SET_ANT_WONLY:\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\"[BTCoex], %s() - PHASE_WLANONLY_INIT\\n\", __func__);\n\t\t \n\t\trtw_coex_set_gnt_bt(rtwdev, COEX_GNT_SET_SW_LOW);\n\n\t\t \n\t\trtw_coex_set_gnt_wl(rtwdev, COEX_GNT_SET_SW_HIGH);\n\n\t\t \n\t\trtw_coex_coex_ctrl_owner(rtwdev, true);\n\n\t\tctrl_type = COEX_SWITCH_CTRL_BY_BBSW;\n\t\tpos_type = COEX_SWITCH_TO_WLG;\n\t\tbreak;\n\tcase COEX_SET_ANT_WOFF:\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\"[BTCoex], %s() - PHASE_WLAN_OFF\\n\", __func__);\n\t\t \n\t\trtw_coex_coex_ctrl_owner(rtwdev, false);\n\n\t\tctrl_type = COEX_SWITCH_CTRL_BY_BT;\n\t\tpos_type = COEX_SWITCH_TO_NOCARE;\n\t\tbreak;\n\tcase COEX_SET_ANT_2G:\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\"[BTCoex], %s() - PHASE_2G_RUNTIME\\n\", __func__);\n\t\t \n\t\trtw_coex_set_gnt_bt(rtwdev, COEX_GNT_SET_HW_PTA);\n\n\t\t \n\t\trtw_coex_set_gnt_wl(rtwdev, COEX_GNT_SET_HW_PTA);\n\n\t\t \n\t\trtw_coex_coex_ctrl_owner(rtwdev, true);\n\n\t\tctrl_type = COEX_SWITCH_CTRL_BY_PTA;\n\t\tpos_type = COEX_SWITCH_TO_NOCARE;\n\t\tbreak;\n\tcase COEX_SET_ANT_5G:\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\"[BTCoex], %s() - PHASE_5G_RUNTIME\\n\", __func__);\n\n\t\t \n\t\trtw_coex_set_gnt_bt(rtwdev, COEX_GNT_SET_HW_PTA);\n\n\t\t \n\t\trtw_coex_set_gnt_wl(rtwdev, COEX_GNT_SET_SW_HIGH);\n\n\t\t \n\t\trtw_coex_coex_ctrl_owner(rtwdev, true);\n\n\t\tctrl_type = COEX_SWITCH_CTRL_BY_BBSW;\n\t\tpos_type = COEX_SWITCH_TO_WLA;\n\t\tbreak;\n\tcase COEX_SET_ANT_2G_FREERUN:\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\"[BTCoex], %s() - PHASE_2G_FREERUN\\n\", __func__);\n\n\t\t \n\t\trtw_coex_set_gnt_bt(rtwdev, COEX_GNT_SET_HW_PTA);\n\n\t\t \n\t\trtw_coex_set_gnt_wl(rtwdev, COEX_GNT_SET_SW_HIGH);\n\n\t\t \n\t\trtw_coex_coex_ctrl_owner(rtwdev, true);\n\n\t\tctrl_type = COEX_SWITCH_CTRL_BY_BBSW;\n\t\tpos_type = COEX_SWITCH_TO_WLG_BT;\n\t\tbreak;\n\tcase COEX_SET_ANT_2G_WLBT:\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\"[BTCoex], %s() - PHASE_2G_WLBT\\n\", __func__);\n\t\t \n\t\trtw_coex_set_gnt_bt(rtwdev, COEX_GNT_SET_HW_PTA);\n\n\t\t \n\t\trtw_coex_set_gnt_wl(rtwdev, COEX_GNT_SET_HW_PTA);\n\n\t\t \n\t\trtw_coex_coex_ctrl_owner(rtwdev, true);\n\n\t\tctrl_type = COEX_SWITCH_CTRL_BY_BBSW;\n\t\tpos_type = COEX_SWITCH_TO_WLG_BT;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"unknown phase when setting antenna path\\n\");\n\t\treturn;\n\t}\n\n\tif (ctrl_type < COEX_SWITCH_CTRL_MAX && pos_type < COEX_SWITCH_TO_MAX &&\n\t    coex_rfe->ant_switch_exist)\n\t\trtw_coex_set_ant_switch(rtwdev, ctrl_type, pos_type);\n}\n\n#define case_ALGO(src) \\\n\tcase COEX_ALGO_##src: return #src\n\nstatic const char *rtw_coex_get_algo_string(u8 algo)\n{\n\tswitch (algo) {\n\tcase_ALGO(NOPROFILE);\n\tcase_ALGO(HFP);\n\tcase_ALGO(HID);\n\tcase_ALGO(A2DP);\n\tcase_ALGO(PAN);\n\tcase_ALGO(A2DP_HID);\n\tcase_ALGO(A2DP_PAN);\n\tcase_ALGO(PAN_HID);\n\tcase_ALGO(A2DP_PAN_HID);\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n}\n\n#define case_BT_PROFILE(src) \\\n\tcase BPM_##src: return #src\n\nstatic const char *rtw_coex_get_bt_profile_string(u8 bt_profile)\n{\n\tswitch (bt_profile) {\n\tcase_BT_PROFILE(NOPROFILE);\n\tcase_BT_PROFILE(HFP);\n\tcase_BT_PROFILE(HID);\n\tcase_BT_PROFILE(A2DP);\n\tcase_BT_PROFILE(PAN);\n\tcase_BT_PROFILE(HID_HFP);\n\tcase_BT_PROFILE(A2DP_HFP);\n\tcase_BT_PROFILE(A2DP_HID);\n\tcase_BT_PROFILE(A2DP_HID_HFP);\n\tcase_BT_PROFILE(PAN_HFP);\n\tcase_BT_PROFILE(PAN_HID);\n\tcase_BT_PROFILE(PAN_HID_HFP);\n\tcase_BT_PROFILE(PAN_A2DP);\n\tcase_BT_PROFILE(PAN_A2DP_HFP);\n\tcase_BT_PROFILE(PAN_A2DP_HID);\n\tcase_BT_PROFILE(PAN_A2DP_HID_HFP);\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n}\n\nstatic u8 rtw_coex_algorithm(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\tu8 algorithm = COEX_ALGO_NOPROFILE;\n\tu8 profile_map = 0;\n\n\tif (coex_stat->bt_hfp_exist)\n\t\tprofile_map |= BPM_HFP;\n\tif (coex_stat->bt_hid_exist)\n\t\tprofile_map |= BPM_HID;\n\tif (coex_stat->bt_a2dp_exist)\n\t\tprofile_map |= BPM_A2DP;\n\tif (coex_stat->bt_pan_exist)\n\t\tprofile_map |= BPM_PAN;\n\n\tswitch (profile_map) {\n\tcase BPM_HFP:\n\t\talgorithm = COEX_ALGO_HFP;\n\t\tbreak;\n\tcase           BPM_HID:\n\tcase BPM_HFP + BPM_HID:\n\t\talgorithm = COEX_ALGO_HID;\n\t\tbreak;\n\tcase BPM_HFP           + BPM_A2DP:\n\tcase           BPM_HID + BPM_A2DP:\n\tcase BPM_HFP + BPM_HID + BPM_A2DP:\n\t\talgorithm = COEX_ALGO_A2DP_HID;\n\t\tbreak;\n\tcase BPM_HFP                      + BPM_PAN:\n\tcase           BPM_HID            + BPM_PAN:\n\tcase BPM_HFP + BPM_HID            + BPM_PAN:\n\t\talgorithm = COEX_ALGO_PAN_HID;\n\t\tbreak;\n\tcase BPM_HFP           + BPM_A2DP + BPM_PAN:\n\tcase           BPM_HID + BPM_A2DP + BPM_PAN:\n\tcase BPM_HFP + BPM_HID + BPM_A2DP + BPM_PAN:\n\t\talgorithm = COEX_ALGO_A2DP_PAN_HID;\n\t\tbreak;\n\tcase                                BPM_PAN:\n\t\talgorithm = COEX_ALGO_PAN;\n\t\tbreak;\n\tcase                     BPM_A2DP + BPM_PAN:\n\t\talgorithm = COEX_ALGO_A2DP_PAN;\n\t\tbreak;\n\tcase                     BPM_A2DP:\n\t\tif (coex_stat->bt_multi_link) {\n\t\t\tif (coex_stat->bt_hid_pair_num > 0)\n\t\t\t\talgorithm = COEX_ALGO_A2DP_HID;\n\t\t\telse\n\t\t\t\talgorithm = COEX_ALGO_A2DP_PAN;\n\t\t} else {\n\t\t\talgorithm = COEX_ALGO_A2DP;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\talgorithm = COEX_ALGO_NOPROFILE;\n\t\tbreak;\n\t}\n\n\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\"[BTCoex], BT Profile = %s => Algorithm = %s\\n\",\n\t\trtw_coex_get_bt_profile_string(profile_map),\n\t\trtw_coex_get_algo_string(algorithm));\n\treturn algorithm;\n}\n\nstatic void rtw_coex_action_coex_all_off(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\tu8 table_case, tdma_case;\n\n\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], %s()\\n\", __func__);\n\trtw_coex_set_rf_para(rtwdev, chip->wl_rf_para_rx[0]);\n\n\tif (efuse->share_ant) {\n\t\t \n\t\ttable_case = 2;\n\t\ttdma_case = 0;\n\t} else {\n\t\t \n\t\ttable_case = 100;\n\t\ttdma_case = 100;\n\t}\n\n\trtw_coex_table(rtwdev, false, table_case);\n\trtw_coex_tdma(rtwdev, false, tdma_case);\n}\n\nstatic void rtw_coex_action_freerun(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\tstruct rtw_coex_dm *coex_dm = &coex->dm;\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\tu8 level = 0;\n\tbool bt_afh_loss = true;\n\n\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], %s()\\n\", __func__);\n\n\tif (efuse->share_ant)\n\t\treturn;\n\n\tcoex->freerun = true;\n\n\tif (bt_afh_loss)\n\t\trtw_coex_update_wl_ch_info(rtwdev, COEX_MEDIA_CONNECT);\n\n\trtw_coex_set_ant_path(rtwdev, false, COEX_SET_ANT_2G_FREERUN);\n\n\trtw_coex_write_scbd(rtwdev, COEX_SCBD_FIX2M, false);\n\n\tif (COEX_RSSI_HIGH(coex_dm->wl_rssi_state[0]))\n\t\tlevel = 2;\n\telse if (COEX_RSSI_HIGH(coex_dm->wl_rssi_state[1]))\n\t\tlevel = 3;\n\telse if (COEX_RSSI_HIGH(coex_dm->wl_rssi_state[2]))\n\t\tlevel = 4;\n\telse\n\t\tlevel = 5;\n\n\tif (level > chip->wl_rf_para_num - 1)\n\t\tlevel = chip->wl_rf_para_num - 1;\n\n\tif (coex_stat->wl_tput_dir == COEX_WL_TPUT_TX)\n\t\trtw_coex_set_rf_para(rtwdev, chip->wl_rf_para_tx[level]);\n\telse\n\t\trtw_coex_set_rf_para(rtwdev, chip->wl_rf_para_rx[level]);\n\n\trtw_coex_table(rtwdev, false, 100);\n\trtw_coex_tdma(rtwdev, false, 100);\n}\n\nstatic void rtw_coex_action_rf4ce(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\tu8 table_case, tdma_case;\n\n\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], %s()\\n\", __func__);\n\n\trtw_coex_set_ant_path(rtwdev, false, COEX_SET_ANT_2G);\n\trtw_coex_set_rf_para(rtwdev, chip->wl_rf_para_rx[0]);\n\n\tif (efuse->share_ant) {\n\t\t \n\t\ttable_case = 9;\n\t\ttdma_case = 16;\n\t} else {\n\t\t \n\t\ttable_case = 100;\n\t\ttdma_case = 100;\n\t}\n\n\trtw_coex_table(rtwdev, false, table_case);\n\trtw_coex_tdma(rtwdev, false, tdma_case);\n}\n\nstatic void rtw_coex_action_bt_whql_test(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\tu8 table_case, tdma_case;\n\n\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], %s()\\n\", __func__);\n\n\trtw_coex_set_ant_path(rtwdev, false, COEX_SET_ANT_2G);\n\trtw_coex_set_rf_para(rtwdev, chip->wl_rf_para_rx[0]);\n\n\tif (efuse->share_ant) {\n\t\t \n\t\ttable_case = 2;\n\t\ttdma_case = 0;\n\t} else {\n\t\t \n\t\ttable_case = 100;\n\t\ttdma_case = 100;\n\t}\n\n\trtw_coex_table(rtwdev, false, table_case);\n\trtw_coex_tdma(rtwdev, false, tdma_case);\n}\n\nstatic void rtw_coex_action_bt_relink(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\tu8 table_case, tdma_case;\n\tu32 slot_type = 0;\n\n\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], %s()\\n\", __func__);\n\n\trtw_coex_set_ant_path(rtwdev, false, COEX_SET_ANT_2G);\n\trtw_coex_set_rf_para(rtwdev, chip->wl_rf_para_rx[0]);\n\n\tif (efuse->share_ant) {  \n\t\tif (coex_stat->wl_gl_busy) {\n\t\t\ttable_case = 26;\n\t\t\tif (coex_stat->bt_hid_exist &&\n\t\t\t    coex_stat->bt_profile_num == 1) {\n\t\t\t\tslot_type = TDMA_4SLOT;\n\t\t\t\ttdma_case = 20;\n\t\t\t} else {\n\t\t\t\ttdma_case = 20;\n\t\t\t}\n\t\t} else {\n\t\t\ttable_case = 1;\n\t\t\ttdma_case = 0;\n\t\t}\n\t} else {  \n\t\tif (coex_stat->wl_gl_busy)\n\t\t\ttable_case = 115;\n\t\telse\n\t\t\ttable_case = 100;\n\t\ttdma_case = 100;\n\t}\n\n\trtw_coex_table(rtwdev, false, table_case);\n\trtw_coex_tdma(rtwdev, false, tdma_case | slot_type);\n}\n\nstatic void rtw_coex_action_bt_idle(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\tstruct rtw_coex_dm *coex_dm = &coex->dm;\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\tstruct rtw_coex_rfe *coex_rfe = &coex->rfe;\n\tu8 table_case = 0xff, tdma_case = 0xff;\n\n\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], %s()\\n\", __func__);\n\trtw_coex_set_rf_para(rtwdev, chip->wl_rf_para_rx[0]);\n\n\tif (coex_rfe->ant_switch_with_bt &&\n\t    coex_dm->bt_status == COEX_BTSTATUS_NCON_IDLE) {\n\t\tif (efuse->share_ant &&\n\t\t    COEX_RSSI_HIGH(coex_dm->wl_rssi_state[3]) &&\n\t\t    coex_stat->wl_gl_busy) {\n\t\t\ttable_case = 0;\n\t\t\ttdma_case = 0;\n\t\t} else if (!efuse->share_ant) {\n\t\t\ttable_case = 100;\n\t\t\ttdma_case = 100;\n\t\t}\n\t}\n\n\tif (table_case != 0xff && tdma_case != 0xff) {\n\t\trtw_coex_set_ant_path(rtwdev, false, COEX_SET_ANT_2G_FREERUN);\n\t\tgoto exit;\n\t}\n\n\trtw_coex_set_ant_path(rtwdev, false, COEX_SET_ANT_2G);\n\n\tif (efuse->share_ant) {\n\t\t \n\t\tif (!coex_stat->wl_gl_busy) {\n\t\t\ttable_case = 10;\n\t\t\ttdma_case = 3;\n\t\t} else if (coex_dm->bt_status == COEX_BTSTATUS_NCON_IDLE) {\n\t\t\ttable_case = 11;\n\n\t\t\tif (coex_stat->lo_pri_rx + coex_stat->lo_pri_tx > 250)\n\t\t\t\ttdma_case = 17;\n\t\t\telse\n\t\t\t\ttdma_case = 7;\n\t\t} else {\n\t\t\ttable_case = 12;\n\t\t\ttdma_case = 7;\n\t\t}\n\t} else {\n\t\t \n\t\tif (!coex_stat->wl_gl_busy) {\n\t\t\ttable_case = 112;\n\t\t\ttdma_case = 104;\n\t\t} else if ((coex_stat->bt_ble_scan_type & 0x2) &&\n\t\t\t   coex_dm->bt_status == COEX_BTSTATUS_NCON_IDLE) {\n\t\t\ttable_case = 114;\n\t\t\ttdma_case = 103;\n\t\t} else {\n\t\t\ttable_case = 112;\n\t\t\ttdma_case = 103;\n\t\t}\n\t}\n\nexit:\n\trtw_coex_table(rtwdev, false, table_case);\n\trtw_coex_tdma(rtwdev, false, tdma_case);\n}\n\nstatic void rtw_coex_action_bt_inquiry(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\tbool wl_hi_pri = false;\n\tu8 table_case, tdma_case;\n\tu32 slot_type = 0;\n\n\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], %s()\\n\", __func__);\n\trtw_coex_set_ant_path(rtwdev, false, COEX_SET_ANT_2G);\n\trtw_coex_set_rf_para(rtwdev, chip->wl_rf_para_rx[0]);\n\n\tif (coex_stat->wl_linkscan_proc || coex_stat->wl_hi_pri_task1 ||\n\t    coex_stat->wl_hi_pri_task2)\n\t\twl_hi_pri = true;\n\n\tif (efuse->share_ant) {\n\t\t \n\t\tif (wl_hi_pri) {\n\t\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\t\"[BTCoex], bt inq/page +  wifi hi-pri task\\n\");\n\t\t\ttable_case = 15;\n\n\t\t\tif (coex_stat->bt_profile_num > 0)\n\t\t\t\ttdma_case = 10;\n\t\t\telse if (coex_stat->wl_hi_pri_task1)\n\t\t\t\ttdma_case = 6;\n\t\t\telse if (!coex_stat->bt_page)\n\t\t\t\ttdma_case = 8;\n\t\t\telse\n\t\t\t\ttdma_case = 9;\n\t\t} else if (coex_stat->wl_gl_busy) {\n\t\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\t\"[BTCoex], bt inq/page + wifi busy\\n\");\n\t\t\tif (coex_stat->bt_profile_num == 0) {\n\t\t\t\ttable_case = 12;\n\t\t\t\ttdma_case = 18;\n\t\t\t} else if (coex_stat->bt_profile_num == 1 &&\n\t\t\t\t   !coex_stat->bt_a2dp_exist) {\n\t\t\t\tslot_type = TDMA_4SLOT;\n\t\t\t\ttable_case = 12;\n\t\t\t\ttdma_case = 20;\n\t\t\t} else {\n\t\t\t\tslot_type = TDMA_4SLOT;\n\t\t\t\ttable_case = 12;\n\t\t\t\ttdma_case = 26;\n\t\t\t}\n\t\t} else if (coex_stat->wl_connected) {\n\t\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\t\"[BTCoex], bt inq/page + wifi connected\\n\");\n\t\t\ttable_case = 9;\n\t\t\ttdma_case = 27;\n\t\t} else {\n\t\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\t\"[BTCoex], bt inq/page + wifi not-connected\\n\");\n\t\t\ttable_case = 1;\n\t\t\ttdma_case = 0;\n\t\t}\n\t} else {\n\t\t \n\t\tif (wl_hi_pri) {\n\t\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\t\"[BTCoex], bt inq/page +  wifi hi-pri task\\n\");\n\t\t\ttable_case = 114;\n\n\t\t\tif (coex_stat->bt_profile_num > 0)\n\t\t\t\ttdma_case = 110;\n\t\t\telse if (coex_stat->wl_hi_pri_task1)\n\t\t\t\ttdma_case = 106;\n\t\t\telse if (!coex_stat->bt_page)\n\t\t\t\ttdma_case = 108;\n\t\t\telse\n\t\t\t\ttdma_case = 109;\n\t\t}  else if (coex_stat->wl_gl_busy) {\n\t\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\t\"[BTCoex], bt inq/page + wifi busy\\n\");\n\t\t\ttable_case = 114;\n\t\t\ttdma_case = 121;\n\t\t} else if (coex_stat->wl_connected) {\n\t\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\t\"[BTCoex], bt inq/page +  wifi connected\\n\");\n\t\t\ttable_case = 101;\n\t\t\ttdma_case = 100;\n\t\t} else {\n\t\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\t\"[BTCoex], bt inq/page +  wifi not-connected\\n\");\n\t\t\ttable_case = 101;\n\t\t\ttdma_case = 100;\n\t\t}\n\t}\n\n\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], wifi hi(%d), bt page(%d)\\n\",\n\t\twl_hi_pri, coex_stat->bt_page);\n\n\trtw_coex_table(rtwdev, false, table_case);\n\trtw_coex_tdma(rtwdev, false, tdma_case | slot_type);\n}\n\nstatic void rtw_coex_action_bt_game_hid(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\tstruct rtw_coex_dm *coex_dm = &coex->dm;\n\tu8 table_case, tdma_case;\n\n\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], %s()\\n\", __func__);\n\trtw_coex_set_ant_path(rtwdev, false, COEX_SET_ANT_2G);\n\n\tif (efuse->share_ant) {\n\t\tcoex_stat->wl_coex_mode = COEX_WLINK_2GFREE;\n\t\tif (coex_stat->bt_whck_test)\n\t\t\ttable_case = 2;\n\t\telse if (coex_stat->wl_linkscan_proc || coex_stat->bt_hid_exist)\n\t\t\ttable_case = 33;\n\t\telse if (coex_stat->bt_setup_link || coex_stat->bt_inq_page)\n\t\t\ttable_case = 0;\n\t\telse if (coex_stat->bt_a2dp_exist)\n\t\t\ttable_case = 34;\n\t\telse\n\t\t\ttable_case = 33;\n\n\t\ttdma_case = 0;\n\t} else {\n\t\tif (COEX_RSSI_HIGH(coex_dm->wl_rssi_state[1]))\n\t\t\ttdma_case = 112;\n\t\telse\n\t\t\ttdma_case = 113;\n\n\t\ttable_case = 121;\n\t}\n\n\tif (coex_stat->wl_coex_mode == COEX_WLINK_2GFREE) {\n\t\tif (coex_stat->wl_tput_dir == COEX_WL_TPUT_TX)\n\t\t\trtw_coex_set_rf_para(rtwdev, chip->wl_rf_para_tx[6]);\n\t\telse\n\t\t\trtw_coex_set_rf_para(rtwdev, chip->wl_rf_para_rx[5]);\n\t} else {\n\t\trtw_coex_set_rf_para(rtwdev, chip->wl_rf_para_rx[0]);\n\t}\n\n\trtw_coex_table(rtwdev, false, table_case);\n\trtw_coex_tdma(rtwdev, false, tdma_case);\n}\n\nstatic void rtw_coex_action_bt_hfp(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\tu8 table_case, tdma_case;\n\n\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], %s()\\n\", __func__);\n\trtw_coex_set_ant_path(rtwdev, false, COEX_SET_ANT_2G);\n\trtw_coex_set_rf_para(rtwdev, chip->wl_rf_para_rx[0]);\n\n\tif (efuse->share_ant) {\n\t\t \n\t\ttable_case = 10;\n\t\ttdma_case = 5;\n\t} else {\n\t\t \n\t\tif (coex_stat->bt_multi_link) {\n\t\t\ttable_case = 112;\n\t\t\ttdma_case = 117;\n\t\t} else {\n\t\t\ttable_case = 105;\n\t\t\ttdma_case = 100;\n\t\t}\n\t}\n\n\trtw_coex_table(rtwdev, false, table_case);\n\trtw_coex_tdma(rtwdev, false, tdma_case);\n}\n\nstatic void rtw_coex_action_bt_hid(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\tu8 table_case, tdma_case;\n\tu32 slot_type = 0;\n\tbool bt_multi_link_remain = false, is_toggle_table = false;\n\n\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], %s()\\n\", __func__);\n\trtw_coex_set_ant_path(rtwdev, false, COEX_SET_ANT_2G);\n\trtw_coex_set_rf_para(rtwdev, chip->wl_rf_para_rx[0]);\n\n\tif (efuse->share_ant) {\n\t\t \n\t\tif (coex_stat->bt_ble_exist) {\n\t\t\t \n\t\t\tif (coex_stat->cnt_wl[COEX_CNT_WL_SCANAP] > 5) {\n\t\t\t\ttable_case = 26;\n\t\t\t\ttdma_case = 2;\n\t\t\t} else {\n\t\t\t\ttable_case = 27;\n\t\t\t\ttdma_case = 9;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (coex_stat->bt_profile_num == 1 &&\n\t\t\t    (coex_stat->bt_multi_link ||\n\t\t\t    (coex_stat->lo_pri_rx +\n\t\t\t     coex_stat->lo_pri_tx > 360) ||\n\t\t\t     coex_stat->bt_slave ||\n\t\t\t     bt_multi_link_remain)) {\n\t\t\t\tslot_type = TDMA_4SLOT;\n\t\t\t\ttable_case = 12;\n\t\t\t\ttdma_case = 20;\n\t\t\t} else if (coex_stat->bt_a2dp_active) {\n\t\t\t\ttable_case = 9;\n\t\t\t\ttdma_case = 18;\n\t\t\t} else if (coex_stat->bt_418_hid_exist &&\n\t\t\t\t   coex_stat->wl_gl_busy) {\n\t\t\t\tis_toggle_table = true;\n\t\t\t\tslot_type = TDMA_4SLOT;\n\t\t\t\ttable_case = 9;\n\t\t\t\ttdma_case = 24;\n\t\t\t} else if (coex_stat->bt_ble_hid_exist &&\n\t\t\t\t   coex_stat->wl_gl_busy) {\n\t\t\t\ttable_case = 32;\n\t\t\t\ttdma_case = 9;\n\t\t\t} else {\n\t\t\t\ttable_case = 9;\n\t\t\t\ttdma_case = 9;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tif (coex_stat->bt_ble_exist) {\n\t\t\t \n\t\t\tif (coex_stat->cnt_wl[COEX_CNT_WL_SCANAP] > 5) {\n\t\t\t\ttable_case = 121;\n\t\t\t\ttdma_case = 102;\n\t\t\t} else {\n\t\t\t\ttable_case = 122;\n\t\t\t\ttdma_case = 109;\n\t\t\t}\n\t\t} else if (coex_stat->bt_a2dp_active) {\n\t\t\ttable_case = 113;\n\t\t\ttdma_case = 118;\n\t\t} else {\n\t\t\ttable_case = 113;\n\t\t\ttdma_case = 104;\n\t\t}\n\t}\n\n\trtw_coex_table(rtwdev, false, table_case);\n\tif (is_toggle_table) {\n\t\trtw_btc_wltoggle_table_a(rtwdev, true, table_case);\n\t\trtw_btc_wltoggle_table_b(rtwdev, false, 1, COEX_WL_SLOT_TOGLLE);\n\t}\n\n\trtw_coex_tdma(rtwdev, false, tdma_case | slot_type);\n}\n\nstatic void rtw_coex_action_bt_a2dp(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\tstruct rtw_coex_dm *coex_dm = &coex->dm;\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\tu8 table_case, tdma_case;\n\tu32 slot_type = 0;\n\n\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], %s()\\n\", __func__);\n\n\trtw_coex_set_ant_path(rtwdev, false, COEX_SET_ANT_2G);\n\trtw_coex_set_rf_para(rtwdev, chip->wl_rf_para_rx[0]);\n\n\tslot_type = TDMA_4SLOT;\n\n\tif (efuse->share_ant) {\n\t\t \n\t\tif (coex_stat->wl_gl_busy && coex_stat->wl_noisy_level == 0)\n\t\t\ttable_case = 12;\n\t\telse\n\t\t\ttable_case = 9;\n\n\t\tif (coex_stat->wl_connecting || !coex_stat->wl_gl_busy)\n\t\t\ttdma_case = 14;\n\t\telse\n\t\t\ttdma_case = 13;\n\t} else {\n\t\t \n\t\ttable_case = 112;\n\n\t\tif (COEX_RSSI_HIGH(coex_dm->wl_rssi_state[1]))\n\t\t\ttdma_case = 112;\n\t\telse\n\t\t\ttdma_case = 113;\n\t}\n\n\trtw_coex_table(rtwdev, false, table_case);\n\trtw_coex_tdma(rtwdev, false, tdma_case | slot_type);\n}\n\nstatic void rtw_coex_action_bt_a2dpsink(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\tu8 table_case, tdma_case;\n\tbool ap_enable = false;\n\n\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], %s()\\n\", __func__);\n\n\trtw_coex_set_ant_path(rtwdev, false, COEX_SET_ANT_2G);\n\trtw_coex_set_rf_para(rtwdev, chip->wl_rf_para_rx[0]);\n\n\tif (efuse->share_ant) {  \n\t\tif (ap_enable) {\n\t\t\ttable_case = 2;\n\t\t\ttdma_case = 0;\n\t\t} else if (coex_stat->wl_gl_busy) {\n\t\t\ttable_case = 28;\n\t\t\ttdma_case = 20;\n\t\t} else {\n\t\t\ttable_case = 28;\n\t\t\ttdma_case = 26;\n\t\t}\n\t} else {  \n\t\tif (ap_enable) {\n\t\t\ttable_case = 100;\n\t\t\ttdma_case = 100;\n\t\t} else {\n\t\t\ttable_case = 119;\n\t\t\ttdma_case = 120;\n\t\t}\n\t}\n\n\trtw_coex_table(rtwdev, false, table_case);\n\trtw_coex_tdma(rtwdev, false, tdma_case);\n}\n\nstatic void rtw_coex_action_bt_pan(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\tu8 table_case, tdma_case;\n\n\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], %s()\\n\", __func__);\n\trtw_coex_set_ant_path(rtwdev, false, COEX_SET_ANT_2G);\n\trtw_coex_set_rf_para(rtwdev, chip->wl_rf_para_rx[0]);\n\n\tif (efuse->share_ant) {\n\t\t \n\t\tif (coex_stat->wl_gl_busy && coex_stat->wl_noisy_level == 0)\n\t\t\ttable_case = 14;\n\t\telse\n\t\t\ttable_case = 10;\n\n\t\tif (coex_stat->wl_gl_busy)\n\t\t\ttdma_case = 17;\n\t\telse\n\t\t\ttdma_case = 20;\n\t} else {\n\t\t \n\t\ttable_case = 112;\n\n\t\tif (coex_stat->wl_gl_busy)\n\t\t\ttdma_case = 117;\n\t\telse\n\t\t\ttdma_case = 119;\n\t}\n\n\trtw_coex_table(rtwdev, false, table_case);\n\trtw_coex_tdma(rtwdev, false, tdma_case);\n}\n\nstatic void rtw_coex_action_bt_a2dp_hid(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\tstruct rtw_coex_dm *coex_dm = &coex->dm;\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\tu8 table_case, tdma_case, interval = 0;\n\tu32 slot_type = 0;\n\tbool is_toggle_table = false;\n\n\tslot_type = TDMA_4SLOT;\n\n\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], %s()\\n\", __func__);\n\trtw_coex_set_ant_path(rtwdev, false, COEX_SET_ANT_2G);\n\trtw_coex_set_rf_para(rtwdev, chip->wl_rf_para_rx[0]);\n\n\tif (efuse->share_ant) {\n\t\t \n\t\tif (coex_stat->bt_ble_exist) {\n\t\t\ttable_case = 26;  \n\t\t} else if (coex_stat->bt_418_hid_exist) {\n\t\t\ttable_case = 9;\n\t\t\tinterval = 1;\n\t\t} else {\n\t\t\ttable_case = 9;\n\t\t}\n\n\t\tif (coex_stat->wl_connecting || !coex_stat->wl_gl_busy) {\n\t\t\ttdma_case = 14;\n\t\t} else if (coex_stat->bt_418_hid_exist) {\n\t\t\tis_toggle_table = true;\n\t\t\ttdma_case = 23;\n\t\t} else {\n\t\t\ttdma_case = 13;\n\t\t}\n\t} else {\n\t\t \n\t\tif (coex_stat->bt_ble_exist)\n\t\t\ttable_case = 121;\n\t\telse\n\t\t\ttable_case = 113;\n\n\t\tif (COEX_RSSI_HIGH(coex_dm->wl_rssi_state[1]))\n\t\t\ttdma_case = 112;\n\t\telse\n\t\t\ttdma_case = 113;\n\t}\n\n\trtw_coex_table(rtwdev, false, table_case);\n\tif (is_toggle_table) {\n\t\trtw_btc_wltoggle_table_a(rtwdev, true, table_case);\n\t\trtw_btc_wltoggle_table_b(rtwdev, false, interval, COEX_WL_SLOT_TOGLLE);\n\t}\n\trtw_coex_tdma(rtwdev, false, tdma_case | slot_type);\n}\n\nstatic void rtw_coex_action_bt_a2dp_pan(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\tu8 table_case, tdma_case;\n\tbool wl_cpt_test = false, bt_cpt_test = false;\n\n\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], %s()\\n\", __func__);\n\n\trtw_coex_set_ant_path(rtwdev, false, COEX_SET_ANT_2G);\n\trtw_coex_set_rf_para(rtwdev, chip->wl_rf_para_rx[0]);\n\tif (efuse->share_ant) {\n\t\t \n\t\tif (wl_cpt_test) {\n\t\t\tif (coex_stat->wl_gl_busy) {\n\t\t\t\ttable_case = 20;\n\t\t\t\ttdma_case = 17;\n\t\t\t} else {\n\t\t\t\ttable_case = 10;\n\t\t\t\ttdma_case = 15;\n\t\t\t}\n\t\t} else if (bt_cpt_test) {\n\t\t\ttable_case = 26;\n\t\t\ttdma_case = 26;\n\t\t} else {\n\t\t\tif (coex_stat->wl_gl_busy &&\n\t\t\t    coex_stat->wl_noisy_level == 0)\n\t\t\t\ttable_case = 14;\n\t\t\telse\n\t\t\t\ttable_case = 10;\n\n\t\t\tif (coex_stat->wl_gl_busy)\n\t\t\t\ttdma_case = 15;\n\t\t\telse\n\t\t\t\ttdma_case = 20;\n\t\t}\n\t} else {\n\t\t \n\t\ttable_case = 112;\n\n\t\tif (coex_stat->wl_gl_busy)\n\t\t\ttdma_case = 115;\n\t\telse\n\t\t\ttdma_case = 120;\n\t}\n\n\tif (wl_cpt_test)\n\t\trtw_coex_set_rf_para(rtwdev, chip->wl_rf_para_rx[1]);\n\telse\n\t\trtw_coex_set_rf_para(rtwdev, chip->wl_rf_para_rx[0]);\n\n\trtw_coex_table(rtwdev, false, table_case);\n\trtw_coex_tdma(rtwdev, false, tdma_case);\n}\n\nstatic void rtw_coex_action_bt_pan_hid(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\tu8 table_case, tdma_case;\n\n\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], %s()\\n\", __func__);\n\n\trtw_coex_set_ant_path(rtwdev, false, COEX_SET_ANT_2G);\n\trtw_coex_set_rf_para(rtwdev, chip->wl_rf_para_rx[0]);\n\n\tif (efuse->share_ant) {\n\t\t \n\t\ttable_case = 9;\n\n\t\tif (coex_stat->wl_gl_busy)\n\t\t\ttdma_case = 18;\n\t\telse\n\t\t\ttdma_case = 19;\n\t} else {\n\t\t \n\t\ttable_case = 113;\n\n\t\tif (coex_stat->wl_gl_busy)\n\t\t\ttdma_case = 117;\n\t\telse\n\t\t\ttdma_case = 119;\n\t}\n\n\trtw_coex_table(rtwdev, false, table_case);\n\trtw_coex_tdma(rtwdev, false, tdma_case);\n}\n\nstatic void rtw_coex_action_bt_a2dp_pan_hid(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\tu8 table_case, tdma_case;\n\n\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], %s()\\n\", __func__);\n\trtw_coex_set_ant_path(rtwdev, false, COEX_SET_ANT_2G);\n\trtw_coex_set_rf_para(rtwdev, chip->wl_rf_para_rx[0]);\n\n\tif (efuse->share_ant) {\n\t\t \n\t\ttable_case = 10;\n\n\t\tif (coex_stat->wl_gl_busy)\n\t\t\ttdma_case = 15;\n\t\telse\n\t\t\ttdma_case = 20;\n\t} else {\n\t\t \n\t\ttable_case = 113;\n\n\t\tif (coex_stat->wl_gl_busy)\n\t\t\ttdma_case = 115;\n\t\telse\n\t\t\ttdma_case = 120;\n\t}\n\n\trtw_coex_table(rtwdev, false, table_case);\n\trtw_coex_tdma(rtwdev, false, tdma_case);\n}\n\nstatic void rtw_coex_action_wl_under5g(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\tu8 table_case, tdma_case;\n\n\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], %s()\\n\", __func__);\n\n\trtw_coex_set_ant_path(rtwdev, true, COEX_SET_ANT_5G);\n\trtw_coex_set_rf_para(rtwdev, chip->wl_rf_para_rx[0]);\n\n\trtw_coex_write_scbd(rtwdev, COEX_SCBD_FIX2M, false);\n\n\tif (coex_stat->bt_game_hid_exist && coex_stat->wl_linkscan_proc)\n\t\tcoex_stat->wl_coex_mode = COEX_WLINK_2GFREE;\n\n\tif (efuse->share_ant) {\n\t\t \n\t\ttable_case = 0;\n\t\ttdma_case = 0;\n\t} else {\n\t\t \n\t\ttable_case = 100;\n\t\ttdma_case = 100;\n\t}\n\n\trtw_coex_table(rtwdev, false, table_case);\n\trtw_coex_tdma(rtwdev, false, tdma_case);\n}\n\nstatic void rtw_coex_action_wl_only(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\tu8 table_case, tdma_case;\n\n\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], %s()\\n\", __func__);\n\trtw_coex_set_ant_path(rtwdev, false, COEX_SET_ANT_2G);\n\trtw_coex_set_rf_para(rtwdev, chip->wl_rf_para_rx[0]);\n\n\tif (efuse->share_ant) {\n\t\t \n\t\ttable_case = 2;\n\t\ttdma_case = 0;\n\t} else {\n\t\t \n\t\ttable_case = 100;\n\t\ttdma_case = 100;\n\t}\n\n\trtw_coex_table(rtwdev, false, table_case);\n\trtw_coex_tdma(rtwdev, false, tdma_case);\n}\n\nstatic void rtw_coex_action_wl_native_lps(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\tu8 table_case, tdma_case;\n\n\tif (coex->under_5g)\n\t\treturn;\n\n\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], %s()\\n\", __func__);\n\n\trtw_coex_set_ant_path(rtwdev, false, COEX_SET_ANT_2G);\n\n\tif (efuse->share_ant) {\n\t\t \n\t\ttable_case = 28;\n\t\ttdma_case = 0;\n\t} else {\n\t\t \n\t\ttable_case = 100;\n\t\ttdma_case = 100;\n\t}\n\n\tif (coex_stat->bt_game_hid_exist) {\n\t\tcoex_stat->wl_coex_mode = COEX_WLINK_2GFREE;\n\t\tif (coex_stat->wl_tput_dir == COEX_WL_TPUT_TX)\n\t\t\trtw_coex_set_rf_para(rtwdev, chip->wl_rf_para_tx[6]);\n\t\telse\n\t\t\trtw_coex_set_rf_para(rtwdev, chip->wl_rf_para_rx[5]);\n\t} else {\n\t\trtw_coex_set_rf_para(rtwdev, chip->wl_rf_para_rx[0]);\n\t}\n\n\trtw_coex_table(rtwdev, false, table_case);\n\trtw_coex_tdma(rtwdev, false, tdma_case);\n}\n\nstatic void rtw_coex_action_wl_linkscan(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\tu8 table_case, tdma_case;\n\tu32 slot_type = 0;\n\n\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], %s()\\n\", __func__);\n\trtw_coex_set_ant_path(rtwdev, false, COEX_SET_ANT_2G);\n\trtw_coex_set_rf_para(rtwdev, chip->wl_rf_para_rx[0]);\n\n\tif (efuse->share_ant) {  \n\t\tif (coex_stat->bt_a2dp_exist) {\n\t\t\tslot_type = TDMA_4SLOT;\n\t\t\ttdma_case = 11;\n\t\t\tif (coex_stat->wl_gl_busy)\n\t\t\t\ttable_case = 26;\n\t\t\telse\n\t\t\t\ttable_case = 9;\n\t\t} else {\n\t\t\ttable_case = 9;\n\t\t\ttdma_case = 7;\n\t\t}\n\t} else {  \n\t\tif (coex_stat->bt_a2dp_exist) {\n\t\t\tslot_type = TDMA_4SLOT;\n\t\t\ttable_case = 112;\n\t\t\ttdma_case = 111;\n\t\t} else {\n\t\t\ttable_case = 112;\n\t\t\ttdma_case = 107;\n\t\t}\n\t}\n\n\trtw_coex_table(rtwdev, false, table_case);\n\trtw_coex_tdma(rtwdev, false, tdma_case | slot_type);\n}\n\nstatic void rtw_coex_action_wl_not_connected(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\tu8 table_case, tdma_case;\n\n\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], %s()\\n\", __func__);\n\trtw_coex_set_ant_path(rtwdev, false, COEX_SET_ANT_2G);\n\trtw_coex_set_rf_para(rtwdev, chip->wl_rf_para_rx[0]);\n\n\tif (efuse->share_ant) {\n\t\t \n\t\ttable_case = 1;\n\t\ttdma_case = 0;\n\t} else {\n\t\t \n\t\ttable_case = 100;\n\t\ttdma_case = 100;\n\t}\n\n\trtw_coex_table(rtwdev, false, table_case);\n\trtw_coex_tdma(rtwdev, false, tdma_case);\n}\n\nstatic void rtw_coex_action_wl_connected(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\tu8 algorithm;\n\n\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], %s()\\n\", __func__);\n\n\talgorithm = rtw_coex_algorithm(rtwdev);\n\n\tswitch (algorithm) {\n\tcase COEX_ALGO_HFP:\n\t\trtw_coex_action_bt_hfp(rtwdev);\n\t\tbreak;\n\tcase COEX_ALGO_HID:\n\t\tif (rtw_coex_freerun_check(rtwdev))\n\t\t\trtw_coex_action_freerun(rtwdev);\n\t\telse\n\t\t\trtw_coex_action_bt_hid(rtwdev);\n\t\tbreak;\n\tcase COEX_ALGO_A2DP:\n\t\tif (rtw_coex_freerun_check(rtwdev))\n\t\t\trtw_coex_action_freerun(rtwdev);\n\t\telse if (coex_stat->bt_a2dp_sink)\n\t\t\trtw_coex_action_bt_a2dpsink(rtwdev);\n\t\telse\n\t\t\trtw_coex_action_bt_a2dp(rtwdev);\n\t\tbreak;\n\tcase COEX_ALGO_PAN:\n\t\trtw_coex_action_bt_pan(rtwdev);\n\t\tbreak;\n\tcase COEX_ALGO_A2DP_HID:\n\t\tif (rtw_coex_freerun_check(rtwdev))\n\t\t\trtw_coex_action_freerun(rtwdev);\n\t\telse\n\t\t\trtw_coex_action_bt_a2dp_hid(rtwdev);\n\t\tbreak;\n\tcase COEX_ALGO_A2DP_PAN:\n\t\trtw_coex_action_bt_a2dp_pan(rtwdev);\n\t\tbreak;\n\tcase COEX_ALGO_PAN_HID:\n\t\trtw_coex_action_bt_pan_hid(rtwdev);\n\t\tbreak;\n\tcase COEX_ALGO_A2DP_PAN_HID:\n\t\trtw_coex_action_bt_a2dp_pan_hid(rtwdev);\n\t\tbreak;\n\tdefault:\n\tcase COEX_ALGO_NOPROFILE:\n\t\trtw_coex_action_bt_idle(rtwdev);\n\t\tbreak;\n\t}\n}\n\nstatic void rtw_coex_run_coex(struct rtw_dev *rtwdev, u8 reason)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_dm *coex_dm = &coex->dm;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\tbool rf4ce_en = false;\n\n\tlockdep_assert_held(&rtwdev->mutex);\n\n\tif (!test_bit(RTW_FLAG_RUNNING, rtwdev->flags))\n\t\treturn;\n\n\tcoex_dm->reason = reason;\n\n\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], %s(): reason = %d\\n\", __func__,\n\t\treason);\n\n\t \n\trtw_coex_update_wl_link_info(rtwdev, reason);\n\n\trtw_coex_monitor_bt_enable(rtwdev);\n\n\tif (coex->manual_control) {\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\"[BTCoex], return for Manual CTRL!!\\n\");\n\t\treturn;\n\t}\n\n\tif (coex->stop_dm) {\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\"[BTCoex], return for Stop Coex DM!!\\n\");\n\t\treturn;\n\t}\n\n\tif (coex_stat->wl_under_ips) {\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\"[BTCoex], return for wifi is under IPS!!\\n\");\n\t\treturn;\n\t}\n\n\tif (coex->freeze && coex_dm->reason == COEX_RSN_BTINFO &&\n\t    !coex_stat->bt_setup_link) {\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\"[BTCoex], return for coex_freeze!!\\n\");\n\t\treturn;\n\t}\n\n\tcoex_stat->cnt_wl[COEX_CNT_WL_COEXRUN]++;\n\tcoex->freerun = false;\n\n\t \n\tif (coex->under_5g) {\n\t\tcoex_stat->wl_coex_mode = COEX_WLINK_5G;\n\t\trtw_coex_action_wl_under5g(rtwdev);\n\t\tgoto exit;\n\t}\n\n\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], WiFi is single-port 2G!!\\n\");\n\tcoex_stat->wl_coex_mode = COEX_WLINK_2G1PORT;\n\n\tif (coex_stat->bt_disabled) {\n\t\tif (coex_stat->wl_connected && rf4ce_en)\n\t\t\trtw_coex_action_rf4ce(rtwdev);\n\t\telse if (!coex_stat->wl_connected)\n\t\t\trtw_coex_action_wl_not_connected(rtwdev);\n\t\telse\n\t\t\trtw_coex_action_wl_only(rtwdev);\n\t\tgoto exit;\n\t}\n\n\tif (coex_stat->wl_under_lps && !coex_stat->wl_force_lps_ctrl) {\n\t\trtw_coex_action_wl_native_lps(rtwdev);\n\t\tgoto exit;\n\t}\n\n\tif (coex_stat->bt_game_hid_exist && coex_stat->wl_connected) {\n\t\trtw_coex_action_bt_game_hid(rtwdev);\n\t\tgoto exit;\n\t}\n\n\tif (coex_stat->bt_whck_test) {\n\t\trtw_coex_action_bt_whql_test(rtwdev);\n\t\tgoto exit;\n\t}\n\n\tif (coex_stat->bt_setup_link) {\n\t\trtw_coex_action_bt_relink(rtwdev);\n\t\tgoto exit;\n\t}\n\n\tif (coex_stat->bt_inq_page) {\n\t\trtw_coex_action_bt_inquiry(rtwdev);\n\t\tgoto exit;\n\t}\n\n\tif ((coex_dm->bt_status == COEX_BTSTATUS_NCON_IDLE ||\n\t     coex_dm->bt_status == COEX_BTSTATUS_CON_IDLE) &&\n\t     coex_stat->wl_connected) {\n\t\trtw_coex_action_bt_idle(rtwdev);\n\t\tgoto exit;\n\t}\n\n\tif (coex_stat->wl_linkscan_proc && !coex->freerun) {\n\t\trtw_coex_action_wl_linkscan(rtwdev);\n\t\tgoto exit;\n\t}\n\n\tif (coex_stat->wl_connected) {\n\t\trtw_coex_action_wl_connected(rtwdev);\n\t\tgoto exit;\n\t} else {\n\t\trtw_coex_action_wl_not_connected(rtwdev);\n\t\tgoto exit;\n\t}\n\nexit:\n\n\tif (chip->wl_mimo_ps_support) {\n\t\tif (coex_stat->wl_coex_mode == COEX_WLINK_2GFREE) {\n\t\t\tif (coex_dm->reason == COEX_RSN_2GMEDIA)\n\t\t\t\trtw_coex_mimo_ps(rtwdev, true, true);\n\t\t\telse\n\t\t\t\trtw_coex_mimo_ps(rtwdev, false, true);\n\t\t} else {\n\t\t\trtw_coex_mimo_ps(rtwdev, false, false);\n\t\t}\n\t}\n\n\trtw_coex_gnt_workaround(rtwdev, false, coex_stat->wl_coex_mode);\n\trtw_coex_limited_wl(rtwdev);\n}\n\nstatic void rtw_coex_init_coex_var(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\tstruct rtw_coex_dm *coex_dm = &coex->dm;\n\tu8 i;\n\n\tmemset(coex_dm, 0, sizeof(*coex_dm));\n\tmemset(coex_stat, 0, sizeof(*coex_stat));\n\n\tfor (i = 0; i < COEX_CNT_WL_MAX; i++)\n\t\tcoex_stat->cnt_wl[i] = 0;\n\n\tfor (i = 0; i < COEX_CNT_BT_MAX; i++)\n\t\tcoex_stat->cnt_bt[i] = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(coex_dm->bt_rssi_state); i++)\n\t\tcoex_dm->bt_rssi_state[i] = COEX_RSSI_STATE_LOW;\n\n\tfor (i = 0; i < ARRAY_SIZE(coex_dm->wl_rssi_state); i++)\n\t\tcoex_dm->wl_rssi_state[i] = COEX_RSSI_STATE_LOW;\n\n\tcoex_stat->wl_coex_mode = COEX_WLINK_MAX;\n\tcoex_stat->wl_rx_rate = DESC_RATE5_5M;\n\tcoex_stat->wl_rts_rx_rate = DESC_RATE5_5M;\n}\n\nstatic void __rtw_coex_init_hw_config(struct rtw_dev *rtwdev, bool wifi_only)\n{\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\n\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], %s()\\n\", __func__);\n\n\trtw_coex_init_coex_var(rtwdev);\n\n\tcoex_stat->kt_ver = u8_get_bits(rtw_read8(rtwdev, 0xf1), GENMASK(7, 4));\n\n\trtw_coex_monitor_bt_enable(rtwdev);\n\trtw_coex_wl_slot_extend(rtwdev, coex_stat->wl_slot_extend);\n\n\trtw_write8_set(rtwdev, REG_BCN_CTRL, BIT_EN_BCN_FUNCTION);\n\n\trtw_coex_set_rfe_type(rtwdev);\n\trtw_coex_set_init(rtwdev);\n\n\t \n\trtw_coex_set_wl_pri_mask(rtwdev, COEX_WLPRI_TX_RSP, 1);\n\n\t \n\trtw_coex_set_wl_pri_mask(rtwdev, COEX_WLPRI_TX_BEACON, 1);\n\n\t \n\trtw_coex_set_wl_pri_mask(rtwdev, COEX_WLPRI_TX_BEACONQ, 1);\n\n\t \n\tif (coex->wl_rf_off) {\n\t\trtw_coex_set_ant_path(rtwdev, true, COEX_SET_ANT_WOFF);\n\t\trtw_coex_write_scbd(rtwdev, COEX_SCBD_ALL, false);\n\t\tcoex->stop_dm = true;\n\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], %s(): RF Off\\n\",\n\t\t\t__func__);\n\t} else if (wifi_only) {\n\t\trtw_coex_set_ant_path(rtwdev, true, COEX_SET_ANT_WONLY);\n\t\trtw_coex_write_scbd(rtwdev, COEX_SCBD_ACTIVE | COEX_SCBD_ONOFF,\n\t\t\t\t    true);\n\t\tcoex->stop_dm = true;\n\t} else {\n\t\trtw_coex_set_ant_path(rtwdev, true, COEX_SET_ANT_INIT);\n\t\trtw_coex_write_scbd(rtwdev, COEX_SCBD_ACTIVE | COEX_SCBD_ONOFF,\n\t\t\t\t    true);\n\t\tcoex->stop_dm = false;\n\t\tcoex->freeze = true;\n\t}\n\n\t \n\trtw_coex_table(rtwdev, true, 1);\n\trtw_coex_tdma(rtwdev, true, 0);\n\trtw_coex_query_bt_info(rtwdev);\n}\n\nvoid rtw_coex_power_on_setting(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tu8 table_case = 1;\n\n\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], %s()\\n\", __func__);\n\n\tcoex->stop_dm = true;\n\tcoex->wl_rf_off = false;\n\n\t \n\trtw_write8_set(rtwdev, REG_SYS_FUNC_EN,\n\t\t       BIT_FEN_BB_GLB_RST | BIT_FEN_BB_RSTB);\n\n\trtw_coex_monitor_bt_enable(rtwdev);\n\trtw_coex_set_rfe_type(rtwdev);\n\n\t \n\trtw_coex_set_ant_path(rtwdev, true, COEX_SET_ANT_POWERON);\n\n\trtw_coex_table(rtwdev, true, table_case);\n\t \n\trtw_write8(rtwdev, 0xff1a, 0x0);\n\trtw_coex_set_gnt_debug(rtwdev);\n}\n\nvoid rtw_coex_power_off_setting(struct rtw_dev *rtwdev)\n{\n\trtw_write16(rtwdev, REG_WIFI_BT_INFO, BIT_BT_INT_EN);\n}\n\nvoid rtw_coex_init_hw_config(struct rtw_dev *rtwdev, bool wifi_only)\n{\n\t__rtw_coex_init_hw_config(rtwdev, wifi_only);\n}\n\nvoid rtw_coex_ips_notify(struct rtw_dev *rtwdev, u8 type)\n{\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\n\tif (coex->manual_control || coex->stop_dm)\n\t\treturn;\n\n\tif (type == COEX_IPS_ENTER) {\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], IPS ENTER notify\\n\");\n\n\t\tcoex_stat->wl_under_ips = true;\n\n\t\t \n\t\trtw_coex_write_scbd(rtwdev, COEX_SCBD_ALL, false);\n\n\t\trtw_coex_set_ant_path(rtwdev, true, COEX_SET_ANT_WOFF);\n\t\trtw_coex_action_coex_all_off(rtwdev);\n\t} else if (type == COEX_IPS_LEAVE) {\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], IPS LEAVE notify\\n\");\n\n\t\trtw_coex_write_scbd(rtwdev, COEX_SCBD_ACTIVE | COEX_SCBD_ONOFF, true);\n\t\t \n\t\t__rtw_coex_init_hw_config(rtwdev, false);\n\n\t\tcoex_stat->wl_under_ips = false;\n\t}\n}\n\nvoid rtw_coex_lps_notify(struct rtw_dev *rtwdev, u8 type)\n{\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\n\tif (coex->manual_control || coex->stop_dm)\n\t\treturn;\n\n\tif (type == COEX_LPS_ENABLE) {\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], LPS ENABLE notify\\n\");\n\n\t\tcoex_stat->wl_under_lps = true;\n\n\t\tif (coex_stat->wl_force_lps_ctrl) {\n\t\t\t \n\t\t\trtw_coex_write_scbd(rtwdev, COEX_SCBD_ACTIVE, true);\n\t\t} else {\n\t\t\t \n\t\t\trtw_coex_write_scbd(rtwdev, COEX_SCBD_ACTIVE, false);\n\t\t\trtw_coex_write_scbd(rtwdev, COEX_SCBD_WLBUSY, false);\n\n\t\t\trtw_coex_run_coex(rtwdev, COEX_RSN_LPS);\n\t\t}\n\t} else if (type == COEX_LPS_DISABLE) {\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], LPS DISABLE notify\\n\");\n\n\t\tcoex_stat->wl_under_lps = false;\n\n\t\t \n\t\trtw_coex_write_scbd(rtwdev, COEX_SCBD_ACTIVE, true);\n\n\t\tif (!coex_stat->wl_force_lps_ctrl)\n\t\t\trtw_coex_query_bt_info(rtwdev);\n\n\t\trtw_coex_run_coex(rtwdev, COEX_RSN_LPS);\n\t}\n}\n\nvoid rtw_coex_scan_notify(struct rtw_dev *rtwdev, u8 type)\n{\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\n\tif (coex->manual_control || coex->stop_dm)\n\t\treturn;\n\n\tcoex->freeze = false;\n\trtw_coex_write_scbd(rtwdev, COEX_SCBD_ACTIVE | COEX_SCBD_ONOFF, true);\n\n\tif (type == COEX_SCAN_START_5G) {\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\"[BTCoex], SCAN START notify (5G)\\n\");\n\n\t\trtw_coex_set_ant_path(rtwdev, true, COEX_SET_ANT_5G);\n\t\trtw_coex_run_coex(rtwdev, COEX_RSN_5GSCANSTART);\n\t} else if ((type == COEX_SCAN_START_2G) || (type == COEX_SCAN_START)) {\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\"[BTCoex], SCAN START notify (2G)\\n\");\n\n\t\tcoex_stat->wl_hi_pri_task2 = true;\n\n\t\t \n\t\trtw_coex_set_ant_path(rtwdev, true, COEX_SET_ANT_2G);\n\t\trtw_coex_run_coex(rtwdev, COEX_RSN_2GSCANSTART);\n\t} else {\n\t\tcoex_stat->cnt_wl[COEX_CNT_WL_SCANAP] = 30;  \n\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\"[BTCoex], SCAN FINISH notify (Scan-AP = %d)\\n\",\n\t\t\tcoex_stat->cnt_wl[COEX_CNT_WL_SCANAP]);\n\n\t\tcoex_stat->wl_hi_pri_task2 = false;\n\t\trtw_coex_run_coex(rtwdev, COEX_RSN_SCANFINISH);\n\t}\n}\n\nvoid rtw_coex_switchband_notify(struct rtw_dev *rtwdev, u8 type)\n{\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\n\tif (coex->manual_control || coex->stop_dm)\n\t\treturn;\n\n\tif (type == COEX_SWITCH_TO_5G) {\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], %s(): TO_5G\\n\",\n\t\t\t__func__);\n\t} else if (type == COEX_SWITCH_TO_24G_NOFORSCAN) {\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\"[BTCoex], %s(): TO_24G_NOFORSCAN\\n\", __func__);\n\t} else {\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], %s(): TO_2G\\n\",\n\t\t\t__func__);\n\t}\n\n\tif (type == COEX_SWITCH_TO_5G)\n\t\trtw_coex_run_coex(rtwdev, COEX_RSN_5GSWITCHBAND);\n\telse if (type == COEX_SWITCH_TO_24G_NOFORSCAN)\n\t\trtw_coex_run_coex(rtwdev, COEX_RSN_2GSWITCHBAND);\n\telse\n\t\trtw_coex_scan_notify(rtwdev, COEX_SCAN_START_2G);\n}\n\nvoid rtw_coex_connect_notify(struct rtw_dev *rtwdev, u8 type)\n{\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\n\tif (coex->manual_control || coex->stop_dm)\n\t\treturn;\n\n\trtw_coex_write_scbd(rtwdev, COEX_SCBD_ACTIVE | COEX_SCBD_ONOFF, true);\n\n\tif (type == COEX_ASSOCIATE_5G_START) {\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], %s(): 5G start\\n\",\n\t\t\t__func__);\n\n\t\trtw_coex_set_ant_path(rtwdev, true, COEX_SET_ANT_5G);\n\t\trtw_coex_run_coex(rtwdev, COEX_RSN_5GCONSTART);\n\t} else if (type == COEX_ASSOCIATE_5G_FINISH) {\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], %s(): 5G finish\\n\",\n\t\t\t__func__);\n\n\t\trtw_coex_set_ant_path(rtwdev, true, COEX_SET_ANT_5G);\n\t\trtw_coex_run_coex(rtwdev, COEX_RSN_5GCONFINISH);\n\t} else if (type == COEX_ASSOCIATE_START) {\n\t\tcoex_stat->wl_hi_pri_task1 = true;\n\t\tcoex_stat->wl_connecting = true;\n\t\tcoex_stat->cnt_wl[COEX_CNT_WL_CONNPKT] = 2;\n\t\tcoex_stat->wl_connecting = true;\n\t\tieee80211_queue_delayed_work(rtwdev->hw,\n\t\t\t\t\t     &coex->wl_connecting_work, 2 * HZ);\n\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], %s(): 2G start\\n\",\n\t\t\t__func__);\n\t\t \n\t\trtw_coex_set_ant_path(rtwdev, true, COEX_SET_ANT_2G);\n\n\t\trtw_coex_run_coex(rtwdev, COEX_RSN_2GCONSTART);\n\n\t\t \n\t\tcoex->freeze = true;\n\t\tieee80211_queue_delayed_work(rtwdev->hw, &coex->defreeze_work,\n\t\t\t\t\t     5 * HZ);\n\t} else {\n\t\tcoex_stat->wl_hi_pri_task1 = false;\n\t\tcoex->freeze = false;\n\t\tcoex_stat->wl_connecting = false;\n\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], %s(): 2G finish\\n\",\n\t\t\t__func__);\n\t\trtw_coex_run_coex(rtwdev, COEX_RSN_2GCONFINISH);\n\t}\n}\n\nvoid rtw_coex_media_status_notify(struct rtw_dev *rtwdev, u8 type)\n{\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\n\tif (coex->manual_control || coex->stop_dm)\n\t\treturn;\n\n\tif (type == COEX_MEDIA_CONNECT_5G) {\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], %s(): 5G\\n\", __func__);\n\n\t\trtw_coex_write_scbd(rtwdev, COEX_SCBD_ACTIVE, true);\n\n\t\trtw_coex_set_ant_path(rtwdev, true, COEX_SET_ANT_5G);\n\t\trtw_coex_run_coex(rtwdev, COEX_RSN_5GMEDIA);\n\t} else if (type == COEX_MEDIA_CONNECT) {\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], %s(): 2G\\n\", __func__);\n\n\t\tcoex_stat->wl_connecting = false;\n\n\t\trtw_coex_write_scbd(rtwdev, COEX_SCBD_ACTIVE, true);\n\n\t\t \n\t\trtw_coex_set_ant_path(rtwdev, true, COEX_SET_ANT_2G);\n\n\t\t \n\t\trtw_coex_set_wl_pri_mask(rtwdev, COEX_WLPRI_RX_CCK, 1);\n\t\trtw_coex_run_coex(rtwdev, COEX_RSN_2GMEDIA);\n\t} else {\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], %s(): disconnect!!\\n\",\n\t\t\t__func__);\n\t\trtw_coex_set_wl_pri_mask(rtwdev, COEX_WLPRI_RX_CCK, 0);\n\t\trtw_coex_run_coex(rtwdev, COEX_RSN_MEDIADISCON);\n\t}\n\n\trtw_coex_update_wl_ch_info(rtwdev, type);\n}\n\nvoid rtw_coex_bt_info_notify(struct rtw_dev *rtwdev, u8 *buf, u8 length)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\tstruct rtw_coex_dm *coex_dm = &coex->dm;\n\tu32 bt_relink_time;\n\tu8 i, rsp_source = 0, type;\n\tbool inq_page = false;\n\n\trsp_source = buf[0] & 0xf;\n\tif (rsp_source >= COEX_BTINFO_SRC_MAX)\n\t\treturn;\n\tcoex_stat->cnt_bt_info_c2h[rsp_source]++;\n\n\tif (rsp_source == COEX_BTINFO_SRC_BT_IQK) {\n\t\tcoex_stat->bt_iqk_state = buf[1];\n\t\tif (coex_stat->bt_iqk_state == 0)\n\t\t\tcoex_stat->cnt_bt[COEX_CNT_BT_IQK]++;\n\t\telse if (coex_stat->bt_iqk_state == 2)\n\t\t\tcoex_stat->cnt_bt[COEX_CNT_BT_IQKFAIL]++;\n\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\"[BTCoex], BT IQK by bt_info, data0 = 0x%02x\\n\",\n\t\t\tbuf[1]);\n\n\t\treturn;\n\t}\n\n\tif (rsp_source == COEX_BTINFO_SRC_BT_SCBD) {\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\"[BTCoex], BT Scoreboard change notify by WL FW c2h, 0xaa = 0x%02x, 0xab = 0x%02x\\n\",\n\t\t\tbuf[1], buf[2]);\n\n\t\trtw_coex_monitor_bt_enable(rtwdev);\n\t\tif (coex_stat->bt_disabled != coex_stat->bt_disabled_pre) {\n\t\t\tcoex_stat->bt_disabled_pre = coex_stat->bt_disabled;\n\t\t\trtw_coex_run_coex(rtwdev, COEX_RSN_BTINFO);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (rsp_source == COEX_BTINFO_SRC_H2C60) {\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\"[BTCoex], H2C 0x60 content replied by WL FW: H2C_0x60 = [%02x %02x %02x %02x %02x]\\n\",\n\t\t\tbuf[1], buf[2], buf[3], buf[4], buf[5]);\n\n\t\tfor (i = 1; i <= COEX_WL_TDMA_PARA_LENGTH; i++)\n\t\t\tcoex_dm->fw_tdma_para[i - 1] = buf[i];\n\t\treturn;\n\t}\n\n\tif (rsp_source == COEX_BTINFO_SRC_WL_FW) {\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\"[BTCoex], bt_info reply by WL FW\\n\");\n\n\t\trtw_coex_update_bt_link_info(rtwdev);\n\t\treturn;\n\t}\n\n\tif (rsp_source == COEX_BTINFO_SRC_BT_RSP ||\n\t    rsp_source == COEX_BTINFO_SRC_BT_ACT) {\n\t\tif (coex_stat->bt_disabled) {\n\t\t\tcoex_stat->bt_disabled = false;\n\t\t\tcoex_stat->bt_reenable = true;\n\t\t\tieee80211_queue_delayed_work(rtwdev->hw,\n\t\t\t\t\t\t     &coex->bt_reenable_work,\n\t\t\t\t\t\t     15 * HZ);\n\t\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\t\"[BTCoex], BT enable detected by bt_info\\n\");\n\t\t}\n\t}\n\n\tif (length != COEX_BTINFO_LENGTH) {\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\"[BTCoex], Bt_info length = %d invalid!!\\n\", length);\n\n\t\treturn;\n\t}\n\n\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\"[BTCoex], Bt_info[%d], len=%d, data=[%02x %02x %02x %02x %02x %02x]\\n\",\n\t\tbuf[0], length, buf[1], buf[2], buf[3], buf[4], buf[5], buf[6]);\n\n\tfor (i = 0; i < COEX_BTINFO_LENGTH; i++)\n\t\tcoex_stat->bt_info_c2h[rsp_source][i] = buf[i];\n\n\t \n\tif (coex_stat->bt_info_c2h[rsp_source][1] == coex_stat->bt_info_lb2 &&\n\t    coex_stat->bt_info_c2h[rsp_source][2] == coex_stat->bt_info_lb3 &&\n\t    coex_stat->bt_info_c2h[rsp_source][3] == coex_stat->bt_info_hb0 &&\n\t    coex_stat->bt_info_c2h[rsp_source][4] == coex_stat->bt_info_hb1 &&\n\t    coex_stat->bt_info_c2h[rsp_source][5] == coex_stat->bt_info_hb2 &&\n\t    coex_stat->bt_info_c2h[rsp_source][6] == coex_stat->bt_info_hb3) {\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\"[BTCoex], Return because Btinfo duplicate!!\\n\");\n\t\treturn;\n\t}\n\n\tcoex_stat->bt_info_lb2 = coex_stat->bt_info_c2h[rsp_source][1];\n\tcoex_stat->bt_info_lb3 = coex_stat->bt_info_c2h[rsp_source][2];\n\tcoex_stat->bt_info_hb0 = coex_stat->bt_info_c2h[rsp_source][3];\n\tcoex_stat->bt_info_hb1 = coex_stat->bt_info_c2h[rsp_source][4];\n\tcoex_stat->bt_info_hb2 = coex_stat->bt_info_c2h[rsp_source][5];\n\tcoex_stat->bt_info_hb3 = coex_stat->bt_info_c2h[rsp_source][6];\n\n\t \n\tcoex_stat->bt_whck_test = (coex_stat->bt_info_lb2 == 0xff);\n\n\tinq_page = ((coex_stat->bt_info_lb2 & BIT(2)) == BIT(2));\n\n\tif (inq_page != coex_stat->bt_inq_page) {\n\t\tcancel_delayed_work_sync(&coex->bt_remain_work);\n\t\tcoex_stat->bt_inq_page = inq_page;\n\n\t\tif (inq_page)\n\t\t\tcoex_stat->bt_inq_remain = true;\n\t\telse\n\t\t\tieee80211_queue_delayed_work(rtwdev->hw,\n\t\t\t\t\t\t     &coex->bt_remain_work,\n\t\t\t\t\t\t     4 * HZ);\n\t}\n\tcoex_stat->bt_acl_busy = ((coex_stat->bt_info_lb2 & BIT(3)) == BIT(3));\n\tif (chip->ble_hid_profile_support) {\n\t\tif (coex_stat->bt_info_lb2 & BIT(5)) {\n\t\t\tif (coex_stat->bt_info_hb1 & BIT(0)) {\n\t\t\t\t \n\t\t\t\tcoex_stat->bt_ble_hid_exist = true;\n\t\t\t} else {\n\t\t\t\tcoex_stat->bt_ble_hid_exist = false;\n\t\t\t}\n\t\t\tcoex_stat->bt_ble_exist = false;\n\t\t} else if (coex_stat->bt_info_hb1 & BIT(0)) {\n\t\t\t \n\t\t\tcoex_stat->bt_ble_hid_exist = false;\n\t\t\tcoex_stat->bt_ble_exist = true;\n\t\t} else {\n\t\t\tcoex_stat->bt_ble_hid_exist = false;\n\t\t\tcoex_stat->bt_ble_exist = false;\n\t\t}\n\t} else {\n\t\tif (coex_stat->bt_info_hb1 & BIT(0)) {\n\t\t\tif (coex_stat->bt_hid_slot == 1 &&\n\t\t\t    coex_stat->hi_pri_rx + 100 < coex_stat->hi_pri_tx &&\n\t\t\t    coex_stat->hi_pri_rx < 100) {\n\t\t\t\tcoex_stat->bt_ble_hid_exist = true;\n\t\t\t\tcoex_stat->bt_ble_exist = false;\n\t\t\t} else {\n\t\t\t\tcoex_stat->bt_ble_hid_exist = false;\n\t\t\t\tcoex_stat->bt_ble_exist = true;\n\t\t\t}\n\t\t} else {\n\t\t\tcoex_stat->bt_ble_hid_exist = false;\n\t\t\tcoex_stat->bt_ble_exist = false;\n\t\t}\n\t}\n\n\tcoex_stat->cnt_bt[COEX_CNT_BT_RETRY] = coex_stat->bt_info_lb3 & 0xf;\n\tif (coex_stat->cnt_bt[COEX_CNT_BT_RETRY] >= 1)\n\t\tcoex_stat->cnt_bt[COEX_CNT_BT_POPEVENT]++;\n\n\tcoex_stat->bt_fix_2M = ((coex_stat->bt_info_lb3 & BIT(4)) == BIT(4));\n\tcoex_stat->bt_inq = ((coex_stat->bt_info_lb3 & BIT(5)) == BIT(5));\n\tif (coex_stat->bt_inq)\n\t\tcoex_stat->cnt_bt[COEX_CNT_BT_INQ]++;\n\n\tcoex_stat->bt_page = ((coex_stat->bt_info_lb3 & BIT(7)) == BIT(7));\n\tif (coex_stat->bt_page)\n\t\tcoex_stat->cnt_bt[COEX_CNT_BT_PAGE]++;\n\n\t \n\tif (chip->bt_rssi_type == COEX_BTRSSI_RATIO) {\n\t\tcoex_stat->bt_rssi = coex_stat->bt_info_hb0 * 2 + 10;\n\t} else {\n\t\tif (coex_stat->bt_info_hb0 <= 127)\n\t\t\tcoex_stat->bt_rssi = 100;\n\t\telse if (256 - coex_stat->bt_info_hb0 <= 100)\n\t\t\tcoex_stat->bt_rssi = 100 - (256 - coex_stat->bt_info_hb0);\n\t\telse\n\t\t\tcoex_stat->bt_rssi = 0;\n\t}\n\n\tif (coex_stat->bt_info_hb1 & BIT(1))\n\t\tcoex_stat->cnt_bt[COEX_CNT_BT_REINIT]++;\n\n\tif (coex_stat->bt_info_hb1 & BIT(2)) {\n\t\tcoex_stat->cnt_bt[COEX_CNT_BT_SETUPLINK]++;\n\t\tcoex_stat->bt_setup_link = true;\n\t\tif (coex_stat->bt_reenable)\n\t\t\tbt_relink_time = 6 * HZ;\n\t\telse\n\t\t\tbt_relink_time = 1 * HZ;\n\n\t\tieee80211_queue_delayed_work(rtwdev->hw,\n\t\t\t\t\t     &coex->bt_relink_work,\n\t\t\t\t\t     bt_relink_time);\n\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\"[BTCoex], Re-Link start in BT info!!\\n\");\n\t}\n\n\tif (coex_stat->bt_info_hb1 & BIT(3))\n\t\tcoex_stat->cnt_bt[COEX_CNT_BT_IGNWLANACT]++;\n\n\tcoex_stat->bt_ble_voice = ((coex_stat->bt_info_hb1 & BIT(4)) == BIT(4));\n\tcoex_stat->bt_ble_scan_en = ((coex_stat->bt_info_hb1 & BIT(5)) == BIT(5));\n\tif (coex_stat->bt_info_hb1 & BIT(6))\n\t\tcoex_stat->cnt_bt[COEX_CNT_BT_ROLESWITCH]++;\n\n\tcoex_stat->bt_multi_link = ((coex_stat->bt_info_hb1 & BIT(7)) == BIT(7));\n\t \n\t \n\tif (!coex_stat->bt_multi_link && coex_stat->bt_multi_link_pre) {\n\t\tcoex_stat->bt_multi_link_remain = true;\n\t\tieee80211_queue_delayed_work(rtwdev->hw,\n\t\t\t\t\t     &coex->bt_multi_link_remain_work,\n\t\t\t\t\t     3 * HZ);\n\t}\n\tcoex_stat->bt_multi_link_pre = coex_stat->bt_multi_link;\n\n\t \n\tif (coex_stat->bt_info_hb1 & BIT(1)) {\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\"[BTCoex], BT Re-init, send wifi BW & Chnl to BT!!\\n\");\n\n\t\tif (coex_stat->wl_connected)\n\t\t\ttype = COEX_MEDIA_CONNECT;\n\t\telse\n\t\t\ttype = COEX_MEDIA_DISCONNECT;\n\t\trtw_coex_update_wl_ch_info(rtwdev, type);\n\t}\n\n\t \n\tif ((coex_stat->bt_info_hb1 & BIT(3)) &&\n\t    (!(coex_stat->bt_info_hb1 & BIT(2)))) {\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\"[BTCoex], BT ext info bit3 check, set BT NOT to ignore Wlan active!!\\n\");\n\t\trtw_coex_ignore_wlan_act(rtwdev, false);\n\t}\n\n\tcoex_stat->bt_opp_exist = ((coex_stat->bt_info_hb2 & BIT(0)) == BIT(0));\n\tif (coex_stat->bt_info_hb2 & BIT(1))\n\t\tcoex_stat->cnt_bt[COEX_CNT_BT_AFHUPDATE]++;\n\n\tcoex_stat->bt_a2dp_active = (coex_stat->bt_info_hb2 & BIT(2)) == BIT(2);\n\tcoex_stat->bt_slave = ((coex_stat->bt_info_hb2 & BIT(3)) == BIT(3));\n\tcoex_stat->bt_hid_slot = (coex_stat->bt_info_hb2 & 0x30) >> 4;\n\tcoex_stat->bt_hid_pair_num = (coex_stat->bt_info_hb2 & 0xc0) >> 6;\n\tif (coex_stat->bt_hid_pair_num > 0 && coex_stat->bt_hid_slot >= 2)\n\t\tcoex_stat->bt_418_hid_exist = true;\n\telse if (coex_stat->bt_hid_pair_num == 0 || coex_stat->bt_hid_slot == 1)\n\t\tcoex_stat->bt_418_hid_exist = false;\n\n\tif ((coex_stat->bt_info_lb2 & 0x49) == 0x49)\n\t\tcoex_stat->bt_a2dp_bitpool = (coex_stat->bt_info_hb3 & 0x7f);\n\telse\n\t\tcoex_stat->bt_a2dp_bitpool = 0;\n\n\tcoex_stat->bt_a2dp_sink = ((coex_stat->bt_info_hb3 & BIT(7)) == BIT(7));\n\n\trtw_coex_update_bt_link_info(rtwdev);\n\trtw_coex_run_coex(rtwdev, COEX_RSN_BTINFO);\n}\n\n#define COEX_BT_HIDINFO_MTK\t0x46\nstatic const u8 coex_bt_hidinfo_ps[] = {0x57, 0x69, 0x72};\nstatic const u8 coex_bt_hidinfo_xb[] = {0x58, 0x62, 0x6f};\n\nvoid rtw_coex_bt_hid_info_notify(struct rtw_dev *rtwdev, u8 *buf, u8 length)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\tstruct rtw_coex_hid *hidinfo;\n\tstruct rtw_coex_hid_info_a *hida;\n\tstruct rtw_coex_hid_handle_list *hl, *bhl;\n\tu8 sub_id = buf[2], gamehid_cnt = 0, handle, i;\n\tbool cur_game_hid_exist, complete;\n\n\tif (!chip->wl_mimo_ps_support &&\n\t    (sub_id == COEX_BT_HIDINFO_LIST || sub_id == COEX_BT_HIDINFO_A))\n\t\treturn;\n\n\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\"[BTCoex], HID info notify, sub_id = 0x%x\\n\", sub_id);\n\n\tswitch (sub_id) {\n\tcase COEX_BT_HIDINFO_LIST:\n\t\thl = &coex_stat->hid_handle_list;\n\t\tbhl = (struct rtw_coex_hid_handle_list *)buf;\n\t\tif (!memcmp(hl, bhl, sizeof(*hl)))\n\t\t\treturn;\n\t\tcoex_stat->hid_handle_list = *bhl;\n\t\tmemset(&coex_stat->hid_info, 0, sizeof(coex_stat->hid_info));\n\t\tfor (i = 0; i < COEX_BT_HIDINFO_HANDLE_NUM; i++) {\n\t\t\thidinfo = &coex_stat->hid_info[i];\n\t\t\tif (hl->handle[i] != COEX_BT_HIDINFO_NOTCON &&\n\t\t\t    hl->handle[i] != 0)\n\t\t\t\thidinfo->hid_handle = hl->handle[i];\n\t\t}\n\t\tbreak;\n\tcase COEX_BT_HIDINFO_A:\n\t\thida = (struct rtw_coex_hid_info_a *)buf;\n\t\thandle = hida->handle;\n\t\tfor (i = 0; i < COEX_BT_HIDINFO_HANDLE_NUM; i++) {\n\t\t\thidinfo = &coex_stat->hid_info[i];\n\t\t\tif (hidinfo->hid_handle == handle) {\n\t\t\t\thidinfo->hid_vendor = hida->vendor;\n\t\t\t\tmemcpy(hidinfo->hid_name, hida->name,\n\t\t\t\t       sizeof(hidinfo->hid_name));\n\t\t\t\thidinfo->hid_info_completed = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tfor (i = 0; i < COEX_BT_HIDINFO_HANDLE_NUM; i++) {\n\t\thidinfo = &coex_stat->hid_info[i];\n\t\tcomplete = hidinfo->hid_info_completed;\n\t\thandle = hidinfo->hid_handle;\n\t\tif (!complete || handle == COEX_BT_HIDINFO_NOTCON ||\n\t\t    handle == 0 || handle >= COEX_BT_BLE_HANDLE_THRS) {\n\t\t\thidinfo->is_game_hid = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (hidinfo->hid_vendor == COEX_BT_HIDINFO_MTK) {\n\t\t\tif ((memcmp(hidinfo->hid_name,\n\t\t\t\t    coex_bt_hidinfo_ps,\n\t\t\t\t    COEX_BT_HIDINFO_NAME)) == 0)\n\t\t\t\thidinfo->is_game_hid = true;\n\t\t\telse if ((memcmp(hidinfo->hid_name,\n\t\t\t\t\t coex_bt_hidinfo_xb,\n\t\t\t\t\t COEX_BT_HIDINFO_NAME)) == 0)\n\t\t\t\thidinfo->is_game_hid = true;\n\t\t\telse\n\t\t\t\thidinfo->is_game_hid = false;\n\t\t} else {\n\t\t\thidinfo->is_game_hid = false;\n\t\t}\n\t\tif (hidinfo->is_game_hid)\n\t\t\tgamehid_cnt++;\n\t}\n\n\tif (gamehid_cnt > 0)\n\t\tcur_game_hid_exist = true;\n\telse\n\t\tcur_game_hid_exist = false;\n\n\tif (cur_game_hid_exist != coex_stat->bt_game_hid_exist) {\n\t\tcoex_stat->bt_game_hid_exist = cur_game_hid_exist;\n\t\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\t\"[BTCoex], HID info changed!bt_game_hid_exist = %d!\\n\",\n\t\t\tcoex_stat->bt_game_hid_exist);\n\t\trtw_coex_run_coex(rtwdev, COEX_RSN_BTSTATUS);\n\t}\n}\n\nvoid rtw_coex_query_bt_hid_list(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\tstruct rtw_coex_hid *hidinfo;\n\tu8 i, handle;\n\tbool complete;\n\n\tif (!chip->wl_mimo_ps_support || coex_stat->wl_under_ips ||\n\t    (coex_stat->wl_under_lps && !coex_stat->wl_force_lps_ctrl))\n\t\treturn;\n\n\tif (!coex_stat->bt_hid_exist &&\n\t    !((coex_stat->bt_info_lb2 & COEX_INFO_CONNECTION) &&\n\t      (coex_stat->hi_pri_tx + coex_stat->hi_pri_rx >\n\t       COEX_BT_GAMEHID_CNT)))\n\t\treturn;\n\n\trtw_fw_coex_query_hid_info(rtwdev, COEX_BT_HIDINFO_LIST, 0);\n\n\tfor (i = 0; i < COEX_BT_HIDINFO_HANDLE_NUM; i++) {\n\t\thidinfo = &coex_stat->hid_info[i];\n\t\tcomplete = hidinfo->hid_info_completed;\n\t\thandle = hidinfo->hid_handle;\n\t\tif (handle == 0 || handle == COEX_BT_HIDINFO_NOTCON ||\n\t\t    handle >= COEX_BT_BLE_HANDLE_THRS || complete)\n\t\t\tcontinue;\n\n\t\trtw_fw_coex_query_hid_info(rtwdev,\n\t\t\t\t\t   COEX_BT_HIDINFO_A,\n\t\t\t\t\t   handle);\n\t}\n}\n\nvoid rtw_coex_wl_fwdbginfo_notify(struct rtw_dev *rtwdev, u8 *buf, u8 length)\n{\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\tu8 val;\n\tint i;\n\n\trtw_dbg(rtwdev, RTW_DBG_COEX,\n\t\t\"[BTCoex], WiFi Fw Dbg info = %8ph (len = %d)\\n\",\n\t\tbuf, length);\n\tif (WARN(length < 8, \"invalid wl info c2h length\\n\"))\n\t\treturn;\n\n\tif (buf[0] != 0x08)\n\t\treturn;\n\n\tfor (i = 1; i < 8; i++) {\n\t\tval = coex_stat->wl_fw_dbg_info_pre[i];\n\t\tif (buf[i] >= val)\n\t\t\tcoex_stat->wl_fw_dbg_info[i] = buf[i] - val;\n\t\telse\n\t\t\tcoex_stat->wl_fw_dbg_info[i] = 255 - val + buf[i];\n\n\t\tcoex_stat->wl_fw_dbg_info_pre[i] = buf[i];\n\t}\n\n\tcoex_stat->cnt_wl[COEX_CNT_WL_FW_NOTIFY]++;\n\trtw_coex_wl_ccklock_action(rtwdev);\n\trtw_coex_wl_ccklock_detect(rtwdev);\n}\n\nvoid rtw_coex_wl_status_change_notify(struct rtw_dev *rtwdev, u32 type)\n{\n\trtw_coex_run_coex(rtwdev, COEX_RSN_WLSTATUS);\n}\n\nvoid rtw_coex_wl_status_check(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_coex_stat *coex_stat = &rtwdev->coex.stat;\n\n\tif ((coex_stat->wl_under_lps && !coex_stat->wl_force_lps_ctrl) ||\n\t    coex_stat->wl_under_ips)\n\t\treturn;\n\n\trtw_coex_monitor_bt_ctr(rtwdev);\n}\n\nvoid rtw_coex_bt_relink_work(struct work_struct *work)\n{\n\tstruct rtw_dev *rtwdev = container_of(work, struct rtw_dev,\n\t\t\t\t\t      coex.bt_relink_work.work);\n\tstruct rtw_coex_stat *coex_stat = &rtwdev->coex.stat;\n\n\tmutex_lock(&rtwdev->mutex);\n\tcoex_stat->bt_setup_link = false;\n\trtw_coex_run_coex(rtwdev, COEX_RSN_WLSTATUS);\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nvoid rtw_coex_bt_reenable_work(struct work_struct *work)\n{\n\tstruct rtw_dev *rtwdev = container_of(work, struct rtw_dev,\n\t\t\t\t\t      coex.bt_reenable_work.work);\n\tstruct rtw_coex_stat *coex_stat = &rtwdev->coex.stat;\n\n\tmutex_lock(&rtwdev->mutex);\n\tcoex_stat->bt_reenable = false;\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nvoid rtw_coex_defreeze_work(struct work_struct *work)\n{\n\tstruct rtw_dev *rtwdev = container_of(work, struct rtw_dev,\n\t\t\t\t\t      coex.defreeze_work.work);\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &rtwdev->coex.stat;\n\n\tmutex_lock(&rtwdev->mutex);\n\tcoex->freeze = false;\n\tcoex_stat->wl_hi_pri_task1 = false;\n\trtw_coex_run_coex(rtwdev, COEX_RSN_WLSTATUS);\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nvoid rtw_coex_wl_remain_work(struct work_struct *work)\n{\n\tstruct rtw_dev *rtwdev = container_of(work, struct rtw_dev,\n\t\t\t\t\t      coex.wl_remain_work.work);\n\tstruct rtw_coex_stat *coex_stat = &rtwdev->coex.stat;\n\n\tmutex_lock(&rtwdev->mutex);\n\tcoex_stat->wl_gl_busy = test_bit(RTW_FLAG_BUSY_TRAFFIC, rtwdev->flags);\n\trtw_coex_run_coex(rtwdev, COEX_RSN_WLSTATUS);\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nvoid rtw_coex_bt_remain_work(struct work_struct *work)\n{\n\tstruct rtw_dev *rtwdev = container_of(work, struct rtw_dev,\n\t\t\t\t\t      coex.bt_remain_work.work);\n\tstruct rtw_coex_stat *coex_stat = &rtwdev->coex.stat;\n\n\tmutex_lock(&rtwdev->mutex);\n\tcoex_stat->bt_inq_remain = coex_stat->bt_inq_page;\n\trtw_coex_run_coex(rtwdev, COEX_RSN_BTSTATUS);\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nvoid rtw_coex_wl_connecting_work(struct work_struct *work)\n{\n\tstruct rtw_dev *rtwdev = container_of(work, struct rtw_dev,\n\t\t\t\t\t      coex.wl_connecting_work.work);\n\tstruct rtw_coex_stat *coex_stat = &rtwdev->coex.stat;\n\n\tmutex_lock(&rtwdev->mutex);\n\tcoex_stat->wl_connecting = false;\n\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], WL connecting stop!!\\n\");\n\trtw_coex_run_coex(rtwdev, COEX_RSN_WLSTATUS);\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nvoid rtw_coex_bt_multi_link_remain_work(struct work_struct *work)\n{\n\tstruct rtw_dev *rtwdev = container_of(work, struct rtw_dev,\n\t\tcoex.bt_multi_link_remain_work.work);\n\tstruct rtw_coex_stat *coex_stat = &rtwdev->coex.stat;\n\n\tmutex_lock(&rtwdev->mutex);\n\tcoex_stat->bt_multi_link_remain = false;\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nvoid rtw_coex_wl_ccklock_work(struct work_struct *work)\n{\n\tstruct rtw_dev *rtwdev = container_of(work, struct rtw_dev,\n\t\t\t\t\t      coex.wl_ccklock_work.work);\n\tstruct rtw_coex_stat *coex_stat = &rtwdev->coex.stat;\n\n\tmutex_lock(&rtwdev->mutex);\n\tcoex_stat->wl_cck_lock = false;\n\tmutex_unlock(&rtwdev->mutex);\n}\n\n#ifdef CONFIG_RTW88_DEBUGFS\n#define INFO_SIZE\t80\n\n#define case_BTINFO(src) \\\n\tcase COEX_BTINFO_SRC_##src: return #src\n\nstatic const char *rtw_coex_get_bt_info_src_string(u8 bt_info_src)\n{\n\tswitch (bt_info_src) {\n\tcase_BTINFO(WL_FW);\n\tcase_BTINFO(BT_RSP);\n\tcase_BTINFO(BT_ACT);\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n}\n\n#define case_RSN(src) \\\n\tcase COEX_RSN_##src: return #src\n\nstatic const char *rtw_coex_get_reason_string(u8 reason)\n{\n\tswitch (reason) {\n\tcase_RSN(2GSCANSTART);\n\tcase_RSN(5GSCANSTART);\n\tcase_RSN(SCANFINISH);\n\tcase_RSN(2GSWITCHBAND);\n\tcase_RSN(5GSWITCHBAND);\n\tcase_RSN(2GCONSTART);\n\tcase_RSN(5GCONSTART);\n\tcase_RSN(2GCONFINISH);\n\tcase_RSN(5GCONFINISH);\n\tcase_RSN(2GMEDIA);\n\tcase_RSN(5GMEDIA);\n\tcase_RSN(MEDIADISCON);\n\tcase_RSN(BTINFO);\n\tcase_RSN(LPS);\n\tcase_RSN(WLSTATUS);\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n}\n\nstatic u8 rtw_coex_get_table_index(struct rtw_dev *rtwdev, u32 wl_reg_6c0,\n\t\t\t\t   u32 wl_reg_6c4)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\tu8 ans = 0xFF;\n\tu8 n, i;\n\tu32 load_bt_val;\n\tu32 load_wl_val;\n\tbool share_ant = efuse->share_ant;\n\n\tif (share_ant)\n\t\tn = chip->table_sant_num;\n\telse\n\t\tn = chip->table_nsant_num;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (share_ant) {\n\t\t\tload_bt_val = chip->table_sant[i].bt;\n\t\t\tload_wl_val = chip->table_sant[i].wl;\n\t\t} else {\n\t\t\tload_bt_val = chip->table_nsant[i].bt;\n\t\t\tload_wl_val = chip->table_nsant[i].wl;\n\t\t}\n\n\t\tif (wl_reg_6c0 == load_bt_val &&\n\t\t    wl_reg_6c4 == load_wl_val) {\n\t\t\tans = i;\n\t\t\tif (!share_ant)\n\t\t\t\tans += 100;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nstatic u8 rtw_coex_get_tdma_index(struct rtw_dev *rtwdev, u8 *tdma_para)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\tu8 ans = 0xFF;\n\tu8 n, i, j;\n\tu8 load_cur_tab_val;\n\tbool valid = false;\n\tbool share_ant = efuse->share_ant;\n\n\tif (share_ant)\n\t\tn = chip->tdma_sant_num;\n\telse\n\t\tn = chip->tdma_nsant_num;\n\n\tfor (i = 0; i < n; i++) {\n\t\tvalid = false;\n\t\tfor (j = 0; j < 5; j++) {\n\t\t\tif (share_ant)\n\t\t\t\tload_cur_tab_val = chip->tdma_sant[i].para[j];\n\t\t\telse\n\t\t\t\tload_cur_tab_val = chip->tdma_nsant[i].para[j];\n\n\t\t\tif (*(tdma_para + j) != load_cur_tab_val)\n\t\t\t\tbreak;\n\n\t\t\tif (j == 4)\n\t\t\t\tvalid = true;\n\t\t}\n\t\tif (valid) {\n\t\t\tans = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nstatic int rtw_coex_addr_info(struct rtw_dev *rtwdev,\n\t\t\t      const struct rtw_reg_domain *reg,\n\t\t\t      char addr_info[], int n)\n{\n\tconst char *rf_prefix = \"\";\n\tconst char *sep = n == 0 ? \"\" : \"/ \";\n\tint ffs, fls;\n\tint max_fls;\n\n\tif (INFO_SIZE - n <= 0)\n\t\treturn 0;\n\n\tswitch (reg->domain) {\n\tcase RTW_REG_DOMAIN_MAC32:\n\t\tmax_fls = 31;\n\t\tbreak;\n\tcase RTW_REG_DOMAIN_MAC16:\n\t\tmax_fls = 15;\n\t\tbreak;\n\tcase RTW_REG_DOMAIN_MAC8:\n\t\tmax_fls = 7;\n\t\tbreak;\n\tcase RTW_REG_DOMAIN_RF_A:\n\tcase RTW_REG_DOMAIN_RF_B:\n\t\trf_prefix = \"RF_\";\n\t\tmax_fls = 19;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tffs = __ffs(reg->mask);\n\tfls = __fls(reg->mask);\n\n\tif (ffs == 0 && fls == max_fls)\n\t\treturn scnprintf(addr_info + n, INFO_SIZE - n, \"%s%s%x\",\n\t\t\t\t sep, rf_prefix, reg->addr);\n\telse if (ffs == fls)\n\t\treturn scnprintf(addr_info + n, INFO_SIZE - n, \"%s%s%x[%d]\",\n\t\t\t\t sep, rf_prefix, reg->addr, ffs);\n\telse\n\t\treturn scnprintf(addr_info + n, INFO_SIZE - n, \"%s%s%x[%d:%d]\",\n\t\t\t\t sep, rf_prefix, reg->addr, fls, ffs);\n}\n\nstatic int rtw_coex_val_info(struct rtw_dev *rtwdev,\n\t\t\t     const struct rtw_reg_domain *reg,\n\t\t\t     char val_info[], int n)\n{\n\tconst char *sep = n == 0 ? \"\" : \"/ \";\n\tu8 rf_path;\n\n\tif (INFO_SIZE - n <= 0)\n\t\treturn 0;\n\n\tswitch (reg->domain) {\n\tcase RTW_REG_DOMAIN_MAC32:\n\t\treturn scnprintf(val_info + n, INFO_SIZE - n, \"%s0x%x\", sep,\n\t\t\t\t rtw_read32_mask(rtwdev, reg->addr, reg->mask));\n\tcase RTW_REG_DOMAIN_MAC16:\n\t\treturn scnprintf(val_info + n, INFO_SIZE - n, \"%s0x%x\", sep,\n\t\t\t\t rtw_read16_mask(rtwdev, reg->addr, reg->mask));\n\tcase RTW_REG_DOMAIN_MAC8:\n\t\treturn scnprintf(val_info + n, INFO_SIZE - n, \"%s0x%x\", sep,\n\t\t\t\t rtw_read8_mask(rtwdev, reg->addr, reg->mask));\n\tcase RTW_REG_DOMAIN_RF_A:\n\t\trf_path = RF_PATH_A;\n\t\tbreak;\n\tcase RTW_REG_DOMAIN_RF_B:\n\t\trf_path = RF_PATH_B;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\t \n\treturn scnprintf(val_info + n, INFO_SIZE - n, \"%s0x%x\", sep,\n\t\t\t rtw_read_rf(rtwdev, rf_path, reg->addr, reg->mask));\n}\n\nstatic void rtw_coex_set_coexinfo_hw(struct rtw_dev *rtwdev, struct seq_file *m)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tconst struct rtw_reg_domain *reg;\n\tchar addr_info[INFO_SIZE];\n\tint n_addr = 0;\n\tchar val_info[INFO_SIZE];\n\tint n_val = 0;\n\tint i;\n\n\tfor (i = 0; i < chip->coex_info_hw_regs_num; i++) {\n\t\treg = &chip->coex_info_hw_regs[i];\n\n\t\tn_addr += rtw_coex_addr_info(rtwdev, reg, addr_info, n_addr);\n\t\tn_val += rtw_coex_val_info(rtwdev, reg, val_info, n_val);\n\n\t\tif (reg->domain == RTW_REG_DOMAIN_NL) {\n\t\t\tseq_printf(m, \"%-40s = %s\\n\", addr_info, val_info);\n\t\t\tn_addr = 0;\n\t\t\tn_val = 0;\n\t\t}\n\t}\n\n\tif (n_addr != 0 && n_val != 0)\n\t\tseq_printf(m, \"%-40s = %s\\n\", addr_info, val_info);\n}\n\nstatic bool rtw_coex_get_bt_reg(struct rtw_dev *rtwdev,\n\t\t\t\tu8 type, u16 addr, u16 *val)\n{\n\tstruct rtw_coex_info_req req = {0};\n\tstruct sk_buff *skb;\n\t__le16 le_addr;\n\tu8 *payload;\n\n\tle_addr = cpu_to_le16(addr);\n\treq.op_code = BT_MP_INFO_OP_READ_REG;\n\treq.para1 = type;\n\treq.para2 = le16_get_bits(le_addr, GENMASK(7, 0));\n\treq.para3 = le16_get_bits(le_addr, GENMASK(15, 8));\n\tskb = rtw_coex_info_request(rtwdev, &req);\n\tif (!skb) {\n\t\t*val = 0xeaea;\n\t\treturn false;\n\t}\n\n\tpayload = get_payload_from_coex_resp(skb);\n\t*val = GET_COEX_RESP_BT_REG_VAL(payload);\n\tdev_kfree_skb_any(skb);\n\n\treturn true;\n}\n\nstatic bool rtw_coex_get_bt_patch_version(struct rtw_dev *rtwdev,\n\t\t\t\t\t  u32 *patch_version)\n{\n\tstruct rtw_coex_info_req req = {0};\n\tstruct sk_buff *skb;\n\tu8 *payload;\n\n\treq.op_code = BT_MP_INFO_OP_PATCH_VER;\n\tskb = rtw_coex_info_request(rtwdev, &req);\n\tif (!skb)\n\t\treturn false;\n\n\tpayload = get_payload_from_coex_resp(skb);\n\t*patch_version = GET_COEX_RESP_BT_PATCH_VER(payload);\n\tdev_kfree_skb_any(skb);\n\n\treturn true;\n}\n\nstatic bool rtw_coex_get_bt_supported_version(struct rtw_dev *rtwdev,\n\t\t\t\t\t      u32 *supported_version)\n{\n\tstruct rtw_coex_info_req req = {0};\n\tstruct sk_buff *skb;\n\tu8 *payload;\n\n\treq.op_code = BT_MP_INFO_OP_SUPP_VER;\n\tskb = rtw_coex_info_request(rtwdev, &req);\n\tif (!skb)\n\t\treturn false;\n\n\tpayload = get_payload_from_coex_resp(skb);\n\t*supported_version = GET_COEX_RESP_BT_SUPP_VER(payload);\n\tdev_kfree_skb_any(skb);\n\n\treturn true;\n}\n\nstatic bool rtw_coex_get_bt_supported_feature(struct rtw_dev *rtwdev,\n\t\t\t\t\t      u32 *supported_feature)\n{\n\tstruct rtw_coex_info_req req = {0};\n\tstruct sk_buff *skb;\n\tu8 *payload;\n\n\treq.op_code = BT_MP_INFO_OP_SUPP_FEAT;\n\tskb = rtw_coex_info_request(rtwdev, &req);\n\tif (!skb)\n\t\treturn false;\n\n\tpayload = get_payload_from_coex_resp(skb);\n\t*supported_feature = GET_COEX_RESP_BT_SUPP_FEAT(payload);\n\tdev_kfree_skb_any(skb);\n\n\treturn true;\n}\n\nstruct rtw_coex_sta_stat_iter_data {\n\tstruct rtw_vif *rtwvif;\n\tstruct seq_file *file;\n};\n\nstatic void rtw_coex_sta_stat_iter(void *data, struct ieee80211_sta *sta)\n{\n\tstruct rtw_coex_sta_stat_iter_data *sta_iter_data = data;\n\tstruct rtw_vif *rtwvif = sta_iter_data->rtwvif;\n\tstruct rtw_sta_info *si = (struct rtw_sta_info *)sta->drv_priv;\n\tstruct seq_file *m = sta_iter_data->file;\n\tstruct ieee80211_vif *vif = rtwvif_to_vif(rtwvif);\n\tu8 rssi;\n\n\tif (si->vif != vif)\n\t\treturn;\n\n\trssi = ewma_rssi_read(&si->avg_rssi);\n\tseq_printf(m, \"\\tPeer %3d\\n\", si->mac_id);\n\tseq_printf(m, \"\\t\\t%-24s = %d\\n\", \"RSSI\", rssi);\n\tseq_printf(m, \"\\t\\t%-24s = %d\\n\", \"BW mode\", si->bw_mode);\n}\n\nstruct rtw_coex_vif_stat_iter_data {\n\tstruct rtw_dev *rtwdev;\n\tstruct seq_file *file;\n};\n\nstatic void rtw_coex_vif_stat_iter(void *data, u8 *mac,\n\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tstruct rtw_coex_vif_stat_iter_data *vif_iter_data = data;\n\tstruct rtw_coex_sta_stat_iter_data sta_iter_data;\n\tstruct rtw_dev *rtwdev = vif_iter_data->rtwdev;\n\tstruct rtw_vif *rtwvif = (struct rtw_vif *)vif->drv_priv;\n\tstruct seq_file *m = vif_iter_data->file;\n\tstruct ieee80211_bss_conf *bss_conf = &vif->bss_conf;\n\n\tseq_printf(m, \"Iface on Port (%d)\\n\", rtwvif->port);\n\tseq_printf(m, \"\\t%-32s = %d\\n\",\n\t\t   \"Beacon interval\", bss_conf->beacon_int);\n\tseq_printf(m, \"\\t%-32s = %d\\n\",\n\t\t   \"Network Type\", rtwvif->net_type);\n\n\tsta_iter_data.rtwvif = rtwvif;\n\tsta_iter_data.file = m;\n\trtw_iterate_stas_atomic(rtwdev, rtw_coex_sta_stat_iter,\n\t\t\t\t&sta_iter_data);\n}\n\n#define case_WLINK(src) \\\n\tcase COEX_WLINK_##src: return #src\n\nstatic const char *rtw_coex_get_wl_coex_mode(u8 coex_wl_link_mode)\n{\n\tswitch (coex_wl_link_mode) {\n\tcase_WLINK(2G1PORT);\n\tcase_WLINK(5G);\n\tcase_WLINK(2GFREE);\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n}\n\nvoid rtw_coex_display_coex_info(struct rtw_dev *rtwdev, struct seq_file *m)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\tstruct rtw_coex_dm *coex_dm = &coex->dm;\n\tstruct rtw_hal *hal = &rtwdev->hal;\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\tstruct rtw_fw_state *fw = &rtwdev->fw;\n\tstruct rtw_coex_vif_stat_iter_data vif_iter_data;\n\tu8 reason = coex_dm->reason;\n\tu8 sys_lte;\n\tu16 score_board_WB, score_board_BW;\n\tu32 wl_reg_6c0, wl_reg_6c4, wl_reg_6c8, wl_reg_778, wl_reg_6cc;\n\tu32 lte_coex, bt_coex;\n\tint i;\n\n\tscore_board_BW = rtw_coex_read_scbd(rtwdev);\n\tscore_board_WB = coex_stat->score_board;\n\twl_reg_6c0 = rtw_read32(rtwdev, REG_BT_COEX_TABLE0);\n\twl_reg_6c4 = rtw_read32(rtwdev, REG_BT_COEX_TABLE1);\n\twl_reg_6c8 = rtw_read32(rtwdev, REG_BT_COEX_BRK_TABLE);\n\twl_reg_6cc = rtw_read32(rtwdev, REG_BT_COEX_TABLE_H);\n\twl_reg_778 = rtw_read8(rtwdev, REG_BT_STAT_CTRL);\n\n\tsys_lte = rtw_read8(rtwdev, 0x73);\n\tlte_coex = rtw_coex_read_indirect_reg(rtwdev, 0x38);\n\tbt_coex = rtw_coex_read_indirect_reg(rtwdev, 0x54);\n\n\tif (!coex_stat->bt_disabled && !coex_stat->bt_mailbox_reply) {\n\t\trtw_coex_get_bt_supported_version(rtwdev,\n\t\t\t\t&coex_stat->bt_supported_version);\n\t\trtw_coex_get_bt_patch_version(rtwdev, &coex_stat->patch_ver);\n\t\trtw_coex_get_bt_supported_feature(rtwdev,\n\t\t\t\t&coex_stat->bt_supported_feature);\n\t\trtw_coex_get_bt_reg(rtwdev, 3, 0xae, &coex_stat->bt_reg_vendor_ae);\n\t\trtw_coex_get_bt_reg(rtwdev, 3, 0xac, &coex_stat->bt_reg_vendor_ac);\n\n\t\tif (coex_stat->patch_ver != 0)\n\t\t\tcoex_stat->bt_mailbox_reply = true;\n\t}\n\n\trtw_dbg(rtwdev, RTW_DBG_COEX, \"[BTCoex], %s()\\n\", __func__);\n\tseq_printf(m, \"**********************************************\\n\");\n\tseq_printf(m, \"\\t\\tBT Coexist info %x\\n\", chip->id);\n\tseq_printf(m, \"**********************************************\\n\");\n\n\tif (coex->manual_control) {\n\t\tseq_puts(m, \"============[Under Manual Control]============\\n\");\n\t\tseq_puts(m, \"==========================================\\n\");\n\n\t} else if (coex->stop_dm) {\n\t\tseq_puts(m, \"============[Coex is STOPPED]============\\n\");\n\t\tseq_puts(m, \"==========================================\\n\");\n\n\t} else if (coex->freeze) {\n\t\tseq_puts(m, \"============[coex_freeze]============\\n\");\n\t\tseq_puts(m, \"==========================================\\n\");\n\t}\n\n\tseq_printf(m, \"%-40s = %s/ %d\\n\",\n\t\t   \"Mech/ RFE\",\n\t\t   efuse->share_ant ? \"Shared\" : \"Non-Shared\",\n\t\t   efuse->rfe_option);\n\tseq_printf(m, \"%-40s = %08x/ 0x%02x/ 0x%08x %s\\n\",\n\t\t   \"Coex Ver/ BT Dez/ BT Rpt\",\n\t\t   chip->coex_para_ver, chip->bt_desired_ver,\n\t\t   coex_stat->bt_supported_version,\n\t\t   coex_stat->bt_disabled ? \"(BT disabled)\" :\n\t\t   coex_stat->bt_supported_version >= chip->bt_desired_ver ?\n\t\t   \"(Match)\" : \"(Mismatch)\");\n\tseq_printf(m, \"%-40s = %s/ %u/ %d\\n\",\n\t\t   \"Role/ RoleSwCnt/ IgnWL/ Feature\",\n\t\t   coex_stat->bt_slave ? \"Slave\" : \"Master\",\n\t\t   coex_stat->cnt_bt[COEX_CNT_BT_ROLESWITCH],\n\t\t   coex_dm->ignore_wl_act);\n\tseq_printf(m, \"%-40s = %u.%u/ 0x%x/ 0x%x/ %c\\n\",\n\t\t   \"WL FW/ BT FW/ BT FW Desired/ KT\",\n\t\t   fw->version, fw->sub_version,\n\t\t   coex_stat->patch_ver,\n\t\t   chip->wl_fw_desired_ver, coex_stat->kt_ver + 65);\n\tseq_printf(m, \"%-40s = %u/ %u/ %u/ ch-(%u)\\n\",\n\t\t   \"AFH Map\",\n\t\t   coex_dm->wl_ch_info[0], coex_dm->wl_ch_info[1],\n\t\t   coex_dm->wl_ch_info[2], hal->current_channel);\n\n\trtw_debugfs_get_simple_phy_info(m);\n\tseq_printf(m, \"**********************************************\\n\");\n\tseq_printf(m, \"\\t\\tBT Status\\n\");\n\tseq_printf(m, \"**********************************************\\n\");\n\tseq_printf(m, \"%-40s = %s/ %ddBm/ %u/ %u\\n\",\n\t\t   \"BT status/ rssi/ retry/ pop\",\n\t\t   coex_dm->bt_status == COEX_BTSTATUS_NCON_IDLE ? \"non-conn\" :\n\t\t   coex_dm->bt_status == COEX_BTSTATUS_CON_IDLE ? \"conn-idle\" : \"busy\",\n\t\t   coex_stat->bt_rssi - 100,\n\t\t   coex_stat->cnt_bt[COEX_CNT_BT_RETRY],\n\t\t   coex_stat->cnt_bt[COEX_CNT_BT_POPEVENT]);\n\tseq_printf(m, \"%-40s = %s%s%s%s%s (multi-link %d)\\n\",\n\t\t   \"Profiles\",\n\t\t   coex_stat->bt_a2dp_exist ? (coex_stat->bt_a2dp_sink ?\n\t\t\t\t\t       \"A2DP sink,\" : \"A2DP,\") : \"\",\n\t\t   coex_stat->bt_hfp_exist ? \"HFP,\" : \"\",\n\t\t   coex_stat->bt_hid_exist ?\n\t\t   (coex_stat->bt_ble_exist ? \"HID(RCU),\" :\n\t\t    coex_stat->bt_hid_slot >= 2 ? \"HID(4/18)\" :\n\t\t    coex_stat->bt_ble_hid_exist ? \"HID(BLE)\" :\n\t\t    \"HID(2/18),\") : \"\",\n\t\t   coex_stat->bt_pan_exist ? coex_stat->bt_opp_exist ?\n\t\t   \"OPP,\" : \"PAN,\" : \"\",\n\t\t   coex_stat->bt_ble_voice ? \"Voice,\" : \"\",\n\t\t   coex_stat->bt_multi_link);\n\tseq_printf(m, \"%-40s = %u/ %u/ %u/ 0x%08x\\n\",\n\t\t   \"Reinit/ Relink/ IgnWl/ Feature\",\n\t\t   coex_stat->cnt_bt[COEX_CNT_BT_REINIT],\n\t\t   coex_stat->cnt_bt[COEX_CNT_BT_SETUPLINK],\n\t\t   coex_stat->cnt_bt[COEX_CNT_BT_IGNWLANACT],\n\t\t   coex_stat->bt_supported_feature);\n\tseq_printf(m, \"%-40s = %u/ %u/ %u/ %u\\n\",\n\t\t   \"Page/ Inq/ iqk/ iqk fail\",\n\t\t   coex_stat->cnt_bt[COEX_CNT_BT_PAGE],\n\t\t   coex_stat->cnt_bt[COEX_CNT_BT_INQ],\n\t\t   coex_stat->cnt_bt[COEX_CNT_BT_IQK],\n\t\t   coex_stat->cnt_bt[COEX_CNT_BT_IQKFAIL]);\n\tseq_printf(m, \"%-40s = 0x%04x/ 0x%04x/ 0x%04x/ 0x%04x\\n\",\n\t\t   \"0xae/ 0xac/ score board (W->B)/ (B->W)\",\n\t\t   coex_stat->bt_reg_vendor_ae,\n\t\t   coex_stat->bt_reg_vendor_ac,\n\t\t   score_board_WB, score_board_BW);\n\tseq_printf(m, \"%-40s = %u/%u, %u/%u\\n\",\n\t\t   \"Hi-Pri TX/RX, Lo-Pri TX/RX\",\n\t\t   coex_stat->hi_pri_tx, coex_stat->hi_pri_rx,\n\t\t   coex_stat->lo_pri_tx, coex_stat->lo_pri_rx);\n\tfor (i = 0; i < COEX_BTINFO_SRC_BT_IQK; i++)\n\t\tseq_printf(m, \"%-40s = %7ph\\n\",\n\t\t\t   rtw_coex_get_bt_info_src_string(i),\n\t\t\t   coex_stat->bt_info_c2h[i]);\n\n\tseq_printf(m, \"**********************************************\\n\");\n\tseq_printf(m, \"\\t\\tWiFi Status\\n\");\n\tseq_printf(m, \"**********************************************\\n\");\n\tseq_printf(m, \"%-40s = %d\\n\",\n\t\t   \"Scanning\", test_bit(RTW_FLAG_SCANNING, rtwdev->flags));\n\tseq_printf(m, \"%-40s = %u/ TX %d Mbps/ RX %d Mbps\\n\",\n\t\t   \"G_busy/ TX/ RX\",\n\t\t   coex_stat->wl_gl_busy,\n\t\t   rtwdev->stats.tx_throughput, rtwdev->stats.rx_throughput);\n\tseq_printf(m, \"%-40s = %u/ %u/ %u\\n\",\n\t\t   \"IPS/ Low Power/ PS mode\",\n\t\t   !test_bit(RTW_FLAG_POWERON, rtwdev->flags),\n\t\t   test_bit(RTW_FLAG_LEISURE_PS_DEEP, rtwdev->flags),\n\t\t   rtwdev->lps_conf.mode);\n\n\tvif_iter_data.rtwdev = rtwdev;\n\tvif_iter_data.file = m;\n\trtw_iterate_vifs_atomic(rtwdev, rtw_coex_vif_stat_iter, &vif_iter_data);\n\n\tif (coex->manual_control) {\n\t\tseq_printf(m, \"**********************************************\\n\");\n\t\tseq_printf(m, \"\\t\\tMechanism (Under Manual)\\n\");\n\t\tseq_printf(m, \"**********************************************\\n\");\n\t\tseq_printf(m, \"%-40s = %5ph (%d)\\n\",\n\t\t\t   \"TDMA Now\",\n\t\t\t   coex_dm->fw_tdma_para,\n\t\t\t   rtw_coex_get_tdma_index(rtwdev,\n\t\t\t\t\t\t   &coex_dm->fw_tdma_para[0]));\n\t} else {\n\t\tseq_printf(m, \"**********************************************\\n\");\n\t\tseq_printf(m, \"\\t\\tMechanism\\n\");\n\t\tseq_printf(m, \"**********************************************\\n\");\n\t\tseq_printf(m, \"%-40s = %5ph (case-%d)\\n\",\n\t\t\t   \"TDMA\",\n\t\t\t   coex_dm->ps_tdma_para, coex_dm->cur_ps_tdma);\n\t}\n\tseq_printf(m, \"%-40s = %s/ %s/ %d\\n\",\n\t\t   \"Coex Mode/Free Run/Timer base\",\n\t\t   rtw_coex_get_wl_coex_mode(coex_stat->wl_coex_mode),\n\t\t   coex->freerun ? \"Yes\" : \"No\",\n\t\t   coex_stat->tdma_timer_base);\n\tseq_printf(m, \"%-40s = %d(%d)/ 0x%08x/ 0x%08x/ 0x%08x\\n\",\n\t\t   \"Table/ 0x6c0/ 0x6c4/ 0x6c8\",\n\t\t   coex_dm->cur_table,\n\t\t   rtw_coex_get_table_index(rtwdev, wl_reg_6c0, wl_reg_6c4),\n\t\t   wl_reg_6c0, wl_reg_6c4, wl_reg_6c8);\n\tseq_printf(m, \"%-40s = 0x%08x/ 0x%08x/ %d/ reason (%s)\\n\",\n\t\t   \"0x778/ 0x6cc/ Run Count/ Reason\",\n\t\t   wl_reg_778, wl_reg_6cc,\n\t\t   coex_stat->cnt_wl[COEX_CNT_WL_COEXRUN],\n\t\t   rtw_coex_get_reason_string(reason));\n\tseq_printf(m, \"%-40s = %3ph\\n\",\n\t\t   \"AFH Map to BT\",\n\t\t   coex_dm->wl_ch_info);\n\tseq_printf(m, \"%-40s = %s/ %d\\n\",\n\t\t   \"AntDiv/ BtCtrlLPS/ g_busy\",\n\t\t   coex_stat->wl_force_lps_ctrl ? \"On\" : \"Off\",\n\t\t   coex_stat->wl_gl_busy);\n\tseq_printf(m, \"%-40s = %u/ %u/ %u/ %u/ %u\\n\",\n\t\t   \"Null All/ Retry/ Ack/ BT Empty/ BT Late\",\n\t\t   coex_stat->wl_fw_dbg_info[1], coex_stat->wl_fw_dbg_info[2],\n\t\t   coex_stat->wl_fw_dbg_info[3], coex_stat->wl_fw_dbg_info[4],\n\t\t   coex_stat->wl_fw_dbg_info[5]);\n\tseq_printf(m, \"%-40s = %u/ %u/ %s/ %u\\n\",\n\t\t   \"Cnt TDMA Toggle/ Lk 5ms/ Lk 5ms on/ FW\",\n\t\t   coex_stat->wl_fw_dbg_info[6],\n\t\t   coex_stat->wl_fw_dbg_info[7],\n\t\t   coex_stat->wl_slot_extend ? \"Yes\" : \"No\",\n\t\t   coex_stat->cnt_wl[COEX_CNT_WL_FW_NOTIFY]);\n\tseq_printf(m, \"%-40s = %d/ %d/ %s/ %d\\n\",\n\t\t   \"WL_TxPw/ BT_TxPw/ WL_Rx/ BT_LNA_Lvl\",\n\t\t   coex_dm->cur_wl_pwr_lvl,\n\t\t   coex_dm->cur_bt_pwr_lvl,\n\t\t   coex_dm->cur_wl_rx_low_gain_en ? \"On\" : \"Off\",\n\t\t   coex_dm->cur_bt_lna_lvl);\n\n\tseq_printf(m, \"**********************************************\\n\");\n\tseq_printf(m, \"\\t\\tHW setting\\n\");\n\tseq_printf(m, \"**********************************************\\n\");\n\tseq_printf(m, \"%-40s = %s/ %s\\n\",\n\t\t   \"LTE Coex/ Path Owner\",\n\t\t   lte_coex & BIT(7) ? \"ON\" : \"OFF\",\n\t\t   sys_lte & BIT(2) ? \"WL\" : \"BT\");\n\tseq_printf(m, \"%-40s = RF:%s_BB:%s/ RF:%s_BB:%s/ %s\\n\",\n\t\t   \"GNT_WL_CTRL/ GNT_BT_CTRL/ Dbg\",\n\t\t   lte_coex & BIT(12) ? \"SW\" : \"HW\",\n\t\t   lte_coex & BIT(8) ? \"SW\" : \"HW\",\n\t\t   lte_coex & BIT(14) ? \"SW\" : \"HW\",\n\t\t   lte_coex & BIT(10) ? \"SW\" : \"HW\",\n\t\t   sys_lte & BIT(3) ? \"On\" : \"Off\");\n\tseq_printf(m, \"%-40s = %lu/ %lu\\n\",\n\t\t   \"GNT_WL/ GNT_BT\",\n\t\t   (bt_coex & BIT(2)) >> 2, (bt_coex & BIT(3)) >> 3);\n\tseq_printf(m, \"%-40s = %u/ %u/ %u/ %u\\n\",\n\t\t   \"CRC OK CCK/ OFDM/ HT/ VHT\",\n\t\t   dm_info->cck_ok_cnt, dm_info->ofdm_ok_cnt,\n\t\t   dm_info->ht_ok_cnt, dm_info->vht_ok_cnt);\n\tseq_printf(m, \"%-40s = %u/ %u/ %u/ %u\\n\",\n\t\t   \"CRC ERR CCK/ OFDM/ HT/ VHT\",\n\t\t   dm_info->cck_err_cnt, dm_info->ofdm_err_cnt,\n\t\t   dm_info->ht_err_cnt, dm_info->vht_err_cnt);\n\tseq_printf(m, \"%-40s = %s/ %s/ %s/ %u\\n\",\n\t\t   \"HiPr/ Locking/ Locked/ Noisy\",\n\t\t   coex_stat->wl_hi_pri_task1 ? \"Y\" : \"N\",\n\t\t   coex_stat->wl_cck_lock ? \"Y\" : \"N\",\n\t\t   coex_stat->wl_cck_lock_ever ? \"Y\" : \"N\",\n\t\t   coex_stat->wl_noisy_level);\n\n\trtw_coex_set_coexinfo_hw(rtwdev, m);\n\tseq_printf(m, \"%-40s = %d/ %d/ %d/ %d\\n\",\n\t\t   \"EVM A/ EVM B/ SNR A/ SNR B\",\n\t\t   -dm_info->rx_evm_dbm[RF_PATH_A],\n\t\t   -dm_info->rx_evm_dbm[RF_PATH_B],\n\t\t   -dm_info->rx_snr[RF_PATH_A],\n\t\t   -dm_info->rx_snr[RF_PATH_B]);\n\tseq_printf(m, \"%-40s = %d/ %d/ %d/ %d\\n\",\n\t\t   \"CCK-CCA/CCK-FA/OFDM-CCA/OFDM-FA\",\n\t\t   dm_info->cck_cca_cnt, dm_info->cck_fa_cnt,\n\t\t   dm_info->ofdm_cca_cnt, dm_info->ofdm_fa_cnt);\n\tseq_printf(m, \"%-40s = %d/ %d/ %d/ %d\\n\", \"CRC OK CCK/11g/11n/11ac\",\n\t\t   dm_info->cck_ok_cnt, dm_info->ofdm_ok_cnt,\n\t\t   dm_info->ht_ok_cnt, dm_info->vht_ok_cnt);\n\tseq_printf(m, \"%-40s = %d/ %d/ %d/ %d\\n\", \"CRC Err CCK/11g/11n/11ac\",\n\t\t   dm_info->cck_err_cnt, dm_info->ofdm_err_cnt,\n\t\t   dm_info->ht_err_cnt, dm_info->vht_err_cnt);\n\n}\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}