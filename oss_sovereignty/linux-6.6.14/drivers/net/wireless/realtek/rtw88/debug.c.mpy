{
  "module_name": "debug.c",
  "hash_id": "a235ed24df592ed3b846f57af11f28c1c1866781acfe889e063e653de47aa41a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtw88/debug.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include \"main.h\"\n#include \"coex.h\"\n#include \"sec.h\"\n#include \"fw.h\"\n#include \"debug.h\"\n#include \"phy.h\"\n#include \"reg.h\"\n#include \"ps.h\"\n#include \"regd.h\"\n\n#ifdef CONFIG_RTW88_DEBUGFS\n\nstruct rtw_debugfs_priv {\n\tstruct rtw_dev *rtwdev;\n\tint (*cb_read)(struct seq_file *m, void *v);\n\tssize_t (*cb_write)(struct file *filp, const char __user *buffer,\n\t\t\t    size_t count, loff_t *loff);\n\tunion {\n\t\tu32 cb_data;\n\t\tu8 *buf;\n\t\tstruct {\n\t\t\tu32 page_offset;\n\t\t\tu32 page_num;\n\t\t} rsvd_page;\n\t\tstruct {\n\t\t\tu8 rf_path;\n\t\t\tu32 rf_addr;\n\t\t\tu32 rf_mask;\n\t\t};\n\t\tstruct {\n\t\t\tu32 addr;\n\t\t\tu32 len;\n\t\t} read_reg;\n\t\tstruct {\n\t\t\tu8 bit;\n\t\t} dm_cap;\n\t};\n};\n\nstatic const char * const rtw_dm_cap_strs[] = {\n\t[RTW_DM_CAP_NA] = \"NA\",\n\t[RTW_DM_CAP_TXGAPK] = \"TXGAPK\",\n};\n\nstatic int rtw_debugfs_single_show(struct seq_file *m, void *v)\n{\n\tstruct rtw_debugfs_priv *debugfs_priv = m->private;\n\n\treturn debugfs_priv->cb_read(m, v);\n}\n\nstatic ssize_t rtw_debugfs_common_write(struct file *filp,\n\t\t\t\t\tconst char __user *buffer,\n\t\t\t\t\tsize_t count, loff_t *loff)\n{\n\tstruct rtw_debugfs_priv *debugfs_priv = filp->private_data;\n\n\treturn debugfs_priv->cb_write(filp, buffer, count, loff);\n}\n\nstatic ssize_t rtw_debugfs_single_write(struct file *filp,\n\t\t\t\t\tconst char __user *buffer,\n\t\t\t\t\tsize_t count, loff_t *loff)\n{\n\tstruct seq_file *seqpriv = (struct seq_file *)filp->private_data;\n\tstruct rtw_debugfs_priv *debugfs_priv = seqpriv->private;\n\n\treturn debugfs_priv->cb_write(filp, buffer, count, loff);\n}\n\nstatic int rtw_debugfs_single_open_rw(struct inode *inode, struct file *filp)\n{\n\treturn single_open(filp, rtw_debugfs_single_show, inode->i_private);\n}\n\nstatic int rtw_debugfs_close(struct inode *inode, struct file *filp)\n{\n\treturn 0;\n}\n\nstatic const struct file_operations file_ops_single_r = {\n\t.owner = THIS_MODULE,\n\t.open = rtw_debugfs_single_open_rw,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n};\n\nstatic const struct file_operations file_ops_single_rw = {\n\t.owner = THIS_MODULE,\n\t.open = rtw_debugfs_single_open_rw,\n\t.release = single_release,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.write = rtw_debugfs_single_write,\n};\n\nstatic const struct file_operations file_ops_common_write = {\n\t.owner = THIS_MODULE,\n\t.write = rtw_debugfs_common_write,\n\t.open = simple_open,\n\t.release = rtw_debugfs_close,\n};\n\nstatic int rtw_debugfs_get_read_reg(struct seq_file *m, void *v)\n{\n\tstruct rtw_debugfs_priv *debugfs_priv = m->private;\n\tstruct rtw_dev *rtwdev = debugfs_priv->rtwdev;\n\tu32 val, len, addr;\n\n\tlen = debugfs_priv->read_reg.len;\n\taddr = debugfs_priv->read_reg.addr;\n\tswitch (len) {\n\tcase 1:\n\t\tval = rtw_read8(rtwdev, addr);\n\t\tseq_printf(m, \"reg 0x%03x: 0x%02x\\n\", addr, val);\n\t\tbreak;\n\tcase 2:\n\t\tval = rtw_read16(rtwdev, addr);\n\t\tseq_printf(m, \"reg 0x%03x: 0x%04x\\n\", addr, val);\n\t\tbreak;\n\tcase 4:\n\t\tval = rtw_read32(rtwdev, addr);\n\t\tseq_printf(m, \"reg 0x%03x: 0x%08x\\n\", addr, val);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int rtw_debugfs_get_rf_read(struct seq_file *m, void *v)\n{\n\tstruct rtw_debugfs_priv *debugfs_priv = m->private;\n\tstruct rtw_dev *rtwdev = debugfs_priv->rtwdev;\n\tu32 val, addr, mask;\n\tu8 path;\n\n\tpath = debugfs_priv->rf_path;\n\taddr = debugfs_priv->rf_addr;\n\tmask = debugfs_priv->rf_mask;\n\n\tmutex_lock(&rtwdev->mutex);\n\tval = rtw_read_rf(rtwdev, path, addr, mask);\n\tmutex_unlock(&rtwdev->mutex);\n\n\tseq_printf(m, \"rf_read path:%d addr:0x%08x mask:0x%08x val=0x%08x\\n\",\n\t\t   path, addr, mask, val);\n\n\treturn 0;\n}\n\nstatic int rtw_debugfs_get_fix_rate(struct seq_file *m, void *v)\n{\n\tstruct rtw_debugfs_priv *debugfs_priv = m->private;\n\tstruct rtw_dev *rtwdev = debugfs_priv->rtwdev;\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tu8 fix_rate = dm_info->fix_rate;\n\n\tif (fix_rate >= DESC_RATE_MAX) {\n\t\tseq_printf(m, \"Fix rate disabled, fix_rate = %u\\n\", fix_rate);\n\t\treturn 0;\n\t}\n\n\tseq_printf(m, \"Data frames fixed at desc rate %u\\n\", fix_rate);\n\treturn 0;\n}\n\nstatic int rtw_debugfs_copy_from_user(char tmp[], int size,\n\t\t\t\t      const char __user *buffer, size_t count,\n\t\t\t\t      int num)\n{\n\tint tmp_len;\n\n\tmemset(tmp, 0, size);\n\n\tif (count < num)\n\t\treturn -EFAULT;\n\n\ttmp_len = (count > size - 1 ? size - 1 : count);\n\n\tif (copy_from_user(tmp, buffer, tmp_len))\n\t\treturn -EFAULT;\n\n\ttmp[tmp_len] = '\\0';\n\n\treturn 0;\n}\n\nstatic ssize_t rtw_debugfs_set_read_reg(struct file *filp,\n\t\t\t\t\tconst char __user *buffer,\n\t\t\t\t\tsize_t count, loff_t *loff)\n{\n\tstruct seq_file *seqpriv = (struct seq_file *)filp->private_data;\n\tstruct rtw_debugfs_priv *debugfs_priv = seqpriv->private;\n\tstruct rtw_dev *rtwdev = debugfs_priv->rtwdev;\n\tchar tmp[32 + 1];\n\tu32 addr, len;\n\tint num;\n\tint ret;\n\n\tret = rtw_debugfs_copy_from_user(tmp, sizeof(tmp), buffer, count, 2);\n\tif (ret)\n\t\treturn ret;\n\n\tnum = sscanf(tmp, \"%x %x\", &addr, &len);\n\n\tif (num !=  2)\n\t\treturn -EINVAL;\n\n\tif (len != 1 && len != 2 && len != 4) {\n\t\trtw_warn(rtwdev, \"read reg setting wrong len\\n\");\n\t\treturn -EINVAL;\n\t}\n\tdebugfs_priv->read_reg.addr = addr;\n\tdebugfs_priv->read_reg.len = len;\n\n\treturn count;\n}\n\nstatic int rtw_debugfs_get_dump_cam(struct seq_file *m, void *v)\n{\n\tstruct rtw_debugfs_priv *debugfs_priv = m->private;\n\tstruct rtw_dev *rtwdev = debugfs_priv->rtwdev;\n\tu32 val, command;\n\tu32 hw_key_idx = debugfs_priv->cb_data << RTW_SEC_CAM_ENTRY_SHIFT;\n\tu32 read_cmd = RTW_SEC_CMD_POLLING;\n\tint i;\n\n\tseq_printf(m, \"cam entry%d\\n\", debugfs_priv->cb_data);\n\tseq_puts(m, \"0x0      0x1      0x2     0x3     \");\n\tseq_puts(m, \"0x4     0x5\\n\");\n\tmutex_lock(&rtwdev->mutex);\n\tfor (i = 0; i <= 5; i++) {\n\t\tcommand = read_cmd | (hw_key_idx + i);\n\t\trtw_write32(rtwdev, RTW_SEC_CMD_REG, command);\n\t\tval = rtw_read32(rtwdev, RTW_SEC_READ_REG);\n\t\tseq_printf(m, \"%8.8x\", val);\n\t\tif (i < 2)\n\t\t\tseq_puts(m, \" \");\n\t}\n\tseq_puts(m, \"\\n\");\n\tmutex_unlock(&rtwdev->mutex);\n\treturn 0;\n}\n\nstatic int rtw_debugfs_get_rsvd_page(struct seq_file *m, void *v)\n{\n\tstruct rtw_debugfs_priv *debugfs_priv = m->private;\n\tstruct rtw_dev *rtwdev = debugfs_priv->rtwdev;\n\tu8 page_size = rtwdev->chip->page_size;\n\tu32 buf_size = debugfs_priv->rsvd_page.page_num * page_size;\n\tu32 offset = debugfs_priv->rsvd_page.page_offset * page_size;\n\tu8 *buf;\n\tint i;\n\tint ret;\n\n\tbuf = vzalloc(buf_size);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = rtw_fw_dump_fifo(rtwdev, RTW_FW_FIFO_SEL_RSVD_PAGE, offset,\n\t\t\t       buf_size, (u32 *)buf);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to dump rsvd page\\n\");\n\t\tvfree(buf);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0 ; i < buf_size ; i += 8) {\n\t\tif (i % page_size == 0)\n\t\t\tseq_printf(m, \"PAGE %d\\n\", (i + offset) / page_size);\n\t\tseq_printf(m, \"%8ph\\n\", buf + i);\n\t}\n\tvfree(buf);\n\n\treturn 0;\n}\n\nstatic ssize_t rtw_debugfs_set_rsvd_page(struct file *filp,\n\t\t\t\t\t const char __user *buffer,\n\t\t\t\t\t size_t count, loff_t *loff)\n{\n\tstruct seq_file *seqpriv = (struct seq_file *)filp->private_data;\n\tstruct rtw_debugfs_priv *debugfs_priv = seqpriv->private;\n\tstruct rtw_dev *rtwdev = debugfs_priv->rtwdev;\n\tchar tmp[32 + 1];\n\tu32 offset, page_num;\n\tint num;\n\tint ret;\n\n\tret = rtw_debugfs_copy_from_user(tmp, sizeof(tmp), buffer, count, 2);\n\tif (ret)\n\t\treturn ret;\n\n\tnum = sscanf(tmp, \"%d %d\", &offset, &page_num);\n\n\tif (num != 2) {\n\t\trtw_warn(rtwdev, \"invalid arguments\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdebugfs_priv->rsvd_page.page_offset = offset;\n\tdebugfs_priv->rsvd_page.page_num = page_num;\n\n\treturn count;\n}\n\nstatic ssize_t rtw_debugfs_set_single_input(struct file *filp,\n\t\t\t\t\t    const char __user *buffer,\n\t\t\t\t\t    size_t count, loff_t *loff)\n{\n\tstruct seq_file *seqpriv = (struct seq_file *)filp->private_data;\n\tstruct rtw_debugfs_priv *debugfs_priv = seqpriv->private;\n\tstruct rtw_dev *rtwdev = debugfs_priv->rtwdev;\n\tchar tmp[32 + 1];\n\tu32 input;\n\tint num;\n\tint ret;\n\n\tret = rtw_debugfs_copy_from_user(tmp, sizeof(tmp), buffer, count, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tnum = kstrtoint(tmp, 0, &input);\n\n\tif (num) {\n\t\trtw_warn(rtwdev, \"kstrtoint failed\\n\");\n\t\treturn num;\n\t}\n\n\tdebugfs_priv->cb_data = input;\n\n\treturn count;\n}\n\nstatic ssize_t rtw_debugfs_set_write_reg(struct file *filp,\n\t\t\t\t\t const char __user *buffer,\n\t\t\t\t\t size_t count, loff_t *loff)\n{\n\tstruct rtw_debugfs_priv *debugfs_priv = filp->private_data;\n\tstruct rtw_dev *rtwdev = debugfs_priv->rtwdev;\n\tchar tmp[32 + 1];\n\tu32 addr, val, len;\n\tint num;\n\tint ret;\n\n\tret = rtw_debugfs_copy_from_user(tmp, sizeof(tmp), buffer, count, 3);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tnum = sscanf(tmp, \"%x %x %x\", &addr, &val, &len);\n\n\tif (num !=  3)\n\t\treturn -EINVAL;\n\n\tswitch (len) {\n\tcase 1:\n\t\trtw_dbg(rtwdev, RTW_DBG_DEBUGFS,\n\t\t\t\"reg write8 0x%03x: 0x%08x\\n\", addr, val);\n\t\trtw_write8(rtwdev, addr, (u8)val);\n\t\tbreak;\n\tcase 2:\n\t\trtw_dbg(rtwdev, RTW_DBG_DEBUGFS,\n\t\t\t\"reg write16 0x%03x: 0x%08x\\n\", addr, val);\n\t\trtw_write16(rtwdev, addr, (u16)val);\n\t\tbreak;\n\tcase 4:\n\t\trtw_dbg(rtwdev, RTW_DBG_DEBUGFS,\n\t\t\t\"reg write32 0x%03x: 0x%08x\\n\", addr, val);\n\t\trtw_write32(rtwdev, addr, (u32)val);\n\t\tbreak;\n\tdefault:\n\t\trtw_dbg(rtwdev, RTW_DBG_DEBUGFS,\n\t\t\t\"error write length = %d\\n\", len);\n\t\tbreak;\n\t}\n\n\treturn count;\n}\n\nstatic ssize_t rtw_debugfs_set_h2c(struct file *filp,\n\t\t\t\t   const char __user *buffer,\n\t\t\t\t   size_t count, loff_t *loff)\n{\n\tstruct rtw_debugfs_priv *debugfs_priv = filp->private_data;\n\tstruct rtw_dev *rtwdev = debugfs_priv->rtwdev;\n\tchar tmp[32 + 1];\n\tu8 param[8];\n\tint num;\n\tint ret;\n\n\tret = rtw_debugfs_copy_from_user(tmp, sizeof(tmp), buffer, count, 3);\n\tif (ret)\n\t\treturn ret;\n\n\tnum = sscanf(tmp, \"%hhx,%hhx,%hhx,%hhx,%hhx,%hhx,%hhx,%hhx\",\n\t\t     &param[0], &param[1], &param[2], &param[3],\n\t\t     &param[4], &param[5], &param[6], &param[7]);\n\tif (num != 8) {\n\t\trtw_warn(rtwdev, \"invalid H2C command format for debug\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&rtwdev->mutex);\n\trtw_fw_h2c_cmd_dbg(rtwdev, param);\n\tmutex_unlock(&rtwdev->mutex);\n\n\treturn count;\n}\n\nstatic ssize_t rtw_debugfs_set_rf_write(struct file *filp,\n\t\t\t\t\tconst char __user *buffer,\n\t\t\t\t\tsize_t count, loff_t *loff)\n{\n\tstruct rtw_debugfs_priv *debugfs_priv = filp->private_data;\n\tstruct rtw_dev *rtwdev = debugfs_priv->rtwdev;\n\tchar tmp[32 + 1];\n\tu32 path, addr, mask, val;\n\tint num;\n\tint ret;\n\n\tret = rtw_debugfs_copy_from_user(tmp, sizeof(tmp), buffer, count, 4);\n\tif (ret)\n\t\treturn ret;\n\n\tnum = sscanf(tmp, \"%x %x %x %x\", &path, &addr, &mask, &val);\n\n\tif (num !=  4) {\n\t\trtw_warn(rtwdev, \"invalid args, [path] [addr] [mask] [val]\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&rtwdev->mutex);\n\trtw_write_rf(rtwdev, path, addr, mask, val);\n\tmutex_unlock(&rtwdev->mutex);\n\trtw_dbg(rtwdev, RTW_DBG_DEBUGFS,\n\t\t\"write_rf path:%d addr:0x%08x mask:0x%08x, val:0x%08x\\n\",\n\t\tpath, addr, mask, val);\n\n\treturn count;\n}\n\nstatic ssize_t rtw_debugfs_set_rf_read(struct file *filp,\n\t\t\t\t       const char __user *buffer,\n\t\t\t\t       size_t count, loff_t *loff)\n{\n\tstruct seq_file *seqpriv = (struct seq_file *)filp->private_data;\n\tstruct rtw_debugfs_priv *debugfs_priv = seqpriv->private;\n\tstruct rtw_dev *rtwdev = debugfs_priv->rtwdev;\n\tchar tmp[32 + 1];\n\tu32 path, addr, mask;\n\tint num;\n\tint ret;\n\n\tret = rtw_debugfs_copy_from_user(tmp, sizeof(tmp), buffer, count, 3);\n\tif (ret)\n\t\treturn ret;\n\n\tnum = sscanf(tmp, \"%x %x %x\", &path, &addr, &mask);\n\n\tif (num !=  3) {\n\t\trtw_warn(rtwdev, \"invalid args, [path] [addr] [mask] [val]\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdebugfs_priv->rf_path = path;\n\tdebugfs_priv->rf_addr = addr;\n\tdebugfs_priv->rf_mask = mask;\n\n\treturn count;\n}\n\nstatic ssize_t rtw_debugfs_set_fix_rate(struct file *filp,\n\t\t\t\t\tconst char __user *buffer,\n\t\t\t\t\tsize_t count, loff_t *loff)\n{\n\tstruct seq_file *seqpriv = (struct seq_file *)filp->private_data;\n\tstruct rtw_debugfs_priv *debugfs_priv = seqpriv->private;\n\tstruct rtw_dev *rtwdev = debugfs_priv->rtwdev;\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tu8 fix_rate;\n\tchar tmp[32 + 1];\n\tint ret;\n\n\tret = rtw_debugfs_copy_from_user(tmp, sizeof(tmp), buffer, count, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = kstrtou8(tmp, 0, &fix_rate);\n\tif (ret) {\n\t\trtw_warn(rtwdev, \"invalid args, [rate]\\n\");\n\t\treturn ret;\n\t}\n\n\tdm_info->fix_rate = fix_rate;\n\n\treturn count;\n}\n\nstatic int rtw_debug_get_mac_page(struct seq_file *m, void *v)\n{\n\tstruct rtw_debugfs_priv *debugfs_priv = m->private;\n\tstruct rtw_dev *rtwdev = debugfs_priv->rtwdev;\n\tu32 page = debugfs_priv->cb_data;\n\tint i, n;\n\tint max = 0xff;\n\n\trtw_read32(rtwdev, debugfs_priv->cb_data);\n\tfor (n = 0; n <= max; ) {\n\t\tseq_printf(m, \"\\n%8.8x  \", n + page);\n\t\tfor (i = 0; i < 4 && n <= max; i++, n += 4)\n\t\t\tseq_printf(m, \"%8.8x    \",\n\t\t\t\t   rtw_read32(rtwdev, (page | n)));\n\t}\n\tseq_puts(m, \"\\n\");\n\treturn 0;\n}\n\nstatic int rtw_debug_get_bb_page(struct seq_file *m, void *v)\n{\n\tstruct rtw_debugfs_priv *debugfs_priv = m->private;\n\tstruct rtw_dev *rtwdev = debugfs_priv->rtwdev;\n\tu32 page = debugfs_priv->cb_data;\n\tint i, n;\n\tint max = 0xff;\n\n\trtw_read32(rtwdev, debugfs_priv->cb_data);\n\tfor (n = 0; n <= max; ) {\n\t\tseq_printf(m, \"\\n%8.8x  \", n + page);\n\t\tfor (i = 0; i < 4 && n <= max; i++, n += 4)\n\t\t\tseq_printf(m, \"%8.8x    \",\n\t\t\t\t   rtw_read32(rtwdev, (page | n)));\n\t}\n\tseq_puts(m, \"\\n\");\n\treturn 0;\n}\n\nstatic int rtw_debug_get_rf_dump(struct seq_file *m, void *v)\n{\n\tstruct rtw_debugfs_priv *debugfs_priv = m->private;\n\tstruct rtw_dev *rtwdev = debugfs_priv->rtwdev;\n\tu32 addr, offset, data;\n\tu8 path;\n\n\tmutex_lock(&rtwdev->mutex);\n\n\tfor (path = 0; path < rtwdev->hal.rf_path_num; path++) {\n\t\tseq_printf(m, \"RF path:%d\\n\", path);\n\t\tfor (addr = 0; addr < 0x100; addr += 4) {\n\t\t\tseq_printf(m, \"%8.8x  \", addr);\n\t\t\tfor (offset = 0; offset < 4; offset++) {\n\t\t\t\tdata = rtw_read_rf(rtwdev, path, addr + offset,\n\t\t\t\t\t\t   0xffffffff);\n\t\t\t\tseq_printf(m, \"%8.8x    \", data);\n\t\t\t}\n\t\t\tseq_puts(m, \"\\n\");\n\t\t}\n\t\tseq_puts(m, \"\\n\");\n\t}\n\n\tmutex_unlock(&rtwdev->mutex);\n\n\treturn 0;\n}\n\nstatic void rtw_print_cck_rate_txt(struct seq_file *m, u8 rate)\n{\n\tstatic const char * const\n\tcck_rate[] = {\"1M\", \"2M\", \"5.5M\", \"11M\"};\n\tu8 idx = rate - DESC_RATE1M;\n\n\tseq_printf(m, \" CCK_%-5s\", cck_rate[idx]);\n}\n\nstatic void rtw_print_ofdm_rate_txt(struct seq_file *m, u8 rate)\n{\n\tstatic const char * const\n\tofdm_rate[] = {\"6M\", \"9M\", \"12M\", \"18M\", \"24M\", \"36M\", \"48M\", \"54M\"};\n\tu8 idx = rate - DESC_RATE6M;\n\n\tseq_printf(m, \" OFDM_%-4s\", ofdm_rate[idx]);\n}\n\nstatic void rtw_print_ht_rate_txt(struct seq_file *m, u8 rate)\n{\n\tu8 mcs_n = rate - DESC_RATEMCS0;\n\n\tseq_printf(m, \" MCS%-6u\", mcs_n);\n}\n\nstatic void rtw_print_vht_rate_txt(struct seq_file *m, u8 rate)\n{\n\tu8 idx = rate - DESC_RATEVHT1SS_MCS0;\n\tu8 n_ss, mcs_n;\n\n\t \n\tn_ss = 1 + idx / 10;\n\t \n\tmcs_n = idx % 10;\n\tseq_printf(m, \" VHT%uSMCS%u\", n_ss, mcs_n);\n}\n\nstatic void rtw_print_rate(struct seq_file *m, u8 rate)\n{\n\tswitch (rate) {\n\tcase DESC_RATE1M...DESC_RATE11M:\n\t\trtw_print_cck_rate_txt(m, rate);\n\t\tbreak;\n\tcase DESC_RATE6M...DESC_RATE54M:\n\t\trtw_print_ofdm_rate_txt(m, rate);\n\t\tbreak;\n\tcase DESC_RATEMCS0...DESC_RATEMCS15:\n\t\trtw_print_ht_rate_txt(m, rate);\n\t\tbreak;\n\tcase DESC_RATEVHT1SS_MCS0...DESC_RATEVHT2SS_MCS9:\n\t\trtw_print_vht_rate_txt(m, rate);\n\t\tbreak;\n\tdefault:\n\t\tseq_printf(m, \" Unknown rate=0x%x\\n\", rate);\n\t\tbreak;\n\t}\n}\n\n#define case_REGD(src) \\\n\tcase RTW_REGD_##src: return #src\n\nstatic const char *rtw_get_regd_string(u8 regd)\n{\n\tswitch (regd) {\n\tcase_REGD(FCC);\n\tcase_REGD(MKK);\n\tcase_REGD(ETSI);\n\tcase_REGD(IC);\n\tcase_REGD(KCC);\n\tcase_REGD(ACMA);\n\tcase_REGD(CHILE);\n\tcase_REGD(UKRAINE);\n\tcase_REGD(MEXICO);\n\tcase_REGD(CN);\n\tcase_REGD(WW);\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n}\n\nstatic int rtw_debugfs_get_tx_pwr_tbl(struct seq_file *m, void *v)\n{\n\tstruct rtw_debugfs_priv *debugfs_priv = m->private;\n\tstruct rtw_dev *rtwdev = debugfs_priv->rtwdev;\n\tstruct rtw_hal *hal = &rtwdev->hal;\n\tu8 path, rate, bw, ch, regd;\n\tstruct rtw_power_params pwr_param = {0};\n\n\tmutex_lock(&rtwdev->mutex);\n\tbw = hal->current_band_width;\n\tch = hal->current_channel;\n\tregd = rtw_regd_get(rtwdev);\n\n\tseq_printf(m, \"channel: %u\\n\", ch);\n\tseq_printf(m, \"bandwidth: %u\\n\", bw);\n\tseq_printf(m, \"regulatory: %s\\n\", rtw_get_regd_string(regd));\n\tseq_printf(m, \"%-4s %-10s %-9s %-9s (%-4s %-4s %-4s) %-4s\\n\",\n\t\t   \"path\", \"rate\", \"pwr\", \"base\", \"byr\", \"lmt\", \"sar\", \"rem\");\n\n\tmutex_lock(&hal->tx_power_mutex);\n\tfor (path = RF_PATH_A; path <= RF_PATH_B; path++) {\n\t\t \n\t\tif (hal->current_band_type == RTW_BAND_5G)\n\t\t\trate = DESC_RATE6M;\n\t\telse\n\t\t\trate = DESC_RATE1M;\n\n\t\t \n\t\tfor (; rate <= DESC_RATEVHT2SS_MCS9; rate++) {\n\t\t\t \n\t\t\tif (rate > DESC_RATEMCS15 &&\n\t\t\t    rate < DESC_RATEVHT1SS_MCS0)\n\t\t\t\tcontinue;\n\n\t\t\trtw_get_tx_power_params(rtwdev, path, rate, bw,\n\t\t\t\t\t\tch, regd, &pwr_param);\n\n\t\t\tseq_printf(m, \"%4c \", path + 'A');\n\t\t\trtw_print_rate(m, rate);\n\t\t\tseq_printf(m, \" %3u(0x%02x) %4u %4d (%4d %4d %4d) %4d\\n\",\n\t\t\t\t   hal->tx_pwr_tbl[path][rate],\n\t\t\t\t   hal->tx_pwr_tbl[path][rate],\n\t\t\t\t   pwr_param.pwr_base,\n\t\t\t\t   min3(pwr_param.pwr_offset,\n\t\t\t\t\tpwr_param.pwr_limit,\n\t\t\t\t\tpwr_param.pwr_sar),\n\t\t\t\t   pwr_param.pwr_offset, pwr_param.pwr_limit,\n\t\t\t\t   pwr_param.pwr_sar,\n\t\t\t\t   pwr_param.pwr_remnant);\n\t\t}\n\t}\n\n\tmutex_unlock(&hal->tx_power_mutex);\n\tmutex_unlock(&rtwdev->mutex);\n\n\treturn 0;\n}\n\nvoid rtw_debugfs_get_simple_phy_info(struct seq_file *m)\n{\n\tstruct rtw_debugfs_priv *debugfs_priv = m->private;\n\tstruct rtw_dev *rtwdev = debugfs_priv->rtwdev;\n\tstruct rtw_hal *hal = &rtwdev->hal;\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tstruct rtw_traffic_stats *stats = &rtwdev->stats;\n\n\tseq_printf(m, \"%-40s = %ddBm/ %d\\n\", \"RSSI/ STA Channel\",\n\t\t   dm_info->rssi[RF_PATH_A] - 100, hal->current_channel);\n\n\tseq_printf(m, \"TP {Tx, Rx} = {%u, %u}Mbps\\n\",\n\t\t   stats->tx_throughput, stats->rx_throughput);\n\n\tseq_puts(m, \"[Tx Rate] = \");\n\trtw_print_rate(m, dm_info->tx_rate);\n\tseq_printf(m, \"(0x%x)\\n\", dm_info->tx_rate);\n\n\tseq_puts(m, \"[Rx Rate] = \");\n\trtw_print_rate(m, dm_info->curr_rx_rate);\n\tseq_printf(m, \"(0x%x)\\n\", dm_info->curr_rx_rate);\n}\n\nstatic int rtw_debugfs_get_phy_info(struct seq_file *m, void *v)\n{\n\tstruct rtw_debugfs_priv *debugfs_priv = m->private;\n\tstruct rtw_dev *rtwdev = debugfs_priv->rtwdev;\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tstruct rtw_traffic_stats *stats = &rtwdev->stats;\n\tstruct rtw_pkt_count *last_cnt = &dm_info->last_pkt_count;\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\tstruct ewma_evm *ewma_evm = dm_info->ewma_evm;\n\tstruct ewma_snr *ewma_snr = dm_info->ewma_snr;\n\tu8 ss, rate_id;\n\n\tseq_puts(m, \"==========[Common Info]========\\n\");\n\tseq_printf(m, \"Is link = %c\\n\", rtw_is_assoc(rtwdev) ? 'Y' : 'N');\n\tseq_printf(m, \"Current CH(fc) = %u\\n\", rtwdev->hal.current_channel);\n\tseq_printf(m, \"Current BW = %u\\n\", rtwdev->hal.current_band_width);\n\tseq_printf(m, \"Current IGI = 0x%x\\n\", dm_info->igi_history[0]);\n\tseq_printf(m, \"TP {Tx, Rx} = {%u, %u}Mbps\\n\",\n\t\t   stats->tx_throughput, stats->rx_throughput);\n\tseq_printf(m, \"1SS for TX and RX = %c\\n\\n\", rtwdev->hal.txrx_1ss ?\n\t\t   'Y' : 'N');\n\n\tseq_puts(m, \"==========[Tx Phy Info]========\\n\");\n\tseq_puts(m, \"[Tx Rate] = \");\n\trtw_print_rate(m, dm_info->tx_rate);\n\tseq_printf(m, \"(0x%x)\\n\\n\", dm_info->tx_rate);\n\n\tseq_puts(m, \"==========[Rx Phy Info]========\\n\");\n\tseq_printf(m, \"[Rx Beacon Count] = %u\\n\", last_cnt->num_bcn_pkt);\n\tseq_puts(m, \"[Rx Rate] = \");\n\trtw_print_rate(m, dm_info->curr_rx_rate);\n\tseq_printf(m, \"(0x%x)\\n\", dm_info->curr_rx_rate);\n\n\tseq_puts(m, \"[Rx Rate Count]:\\n\");\n\tseq_printf(m, \" * CCK = {%u, %u, %u, %u}\\n\",\n\t\t   last_cnt->num_qry_pkt[DESC_RATE1M],\n\t\t   last_cnt->num_qry_pkt[DESC_RATE2M],\n\t\t   last_cnt->num_qry_pkt[DESC_RATE5_5M],\n\t\t   last_cnt->num_qry_pkt[DESC_RATE11M]);\n\n\tseq_printf(m, \" * OFDM = {%u, %u, %u, %u, %u, %u, %u, %u}\\n\",\n\t\t   last_cnt->num_qry_pkt[DESC_RATE6M],\n\t\t   last_cnt->num_qry_pkt[DESC_RATE9M],\n\t\t   last_cnt->num_qry_pkt[DESC_RATE12M],\n\t\t   last_cnt->num_qry_pkt[DESC_RATE18M],\n\t\t   last_cnt->num_qry_pkt[DESC_RATE24M],\n\t\t   last_cnt->num_qry_pkt[DESC_RATE36M],\n\t\t   last_cnt->num_qry_pkt[DESC_RATE48M],\n\t\t   last_cnt->num_qry_pkt[DESC_RATE54M]);\n\n\tfor (ss = 0; ss < efuse->hw_cap.nss; ss++) {\n\t\trate_id = DESC_RATEMCS0 + ss * 8;\n\t\tseq_printf(m, \" * HT_MCS[%u:%u] = {%u, %u, %u, %u, %u, %u, %u, %u}\\n\",\n\t\t\t   ss * 8, ss * 8 + 7,\n\t\t\t   last_cnt->num_qry_pkt[rate_id],\n\t\t\t   last_cnt->num_qry_pkt[rate_id + 1],\n\t\t\t   last_cnt->num_qry_pkt[rate_id + 2],\n\t\t\t   last_cnt->num_qry_pkt[rate_id + 3],\n\t\t\t   last_cnt->num_qry_pkt[rate_id + 4],\n\t\t\t   last_cnt->num_qry_pkt[rate_id + 5],\n\t\t\t   last_cnt->num_qry_pkt[rate_id + 6],\n\t\t\t   last_cnt->num_qry_pkt[rate_id + 7]);\n\t}\n\n\tfor (ss = 0; ss < efuse->hw_cap.nss; ss++) {\n\t\trate_id = DESC_RATEVHT1SS_MCS0 + ss * 10;\n\t\tseq_printf(m, \" * VHT_MCS-%uss MCS[0:9] = {%u, %u, %u, %u, %u, %u, %u, %u, %u, %u}\\n\",\n\t\t\t   ss + 1,\n\t\t\t   last_cnt->num_qry_pkt[rate_id],\n\t\t\t   last_cnt->num_qry_pkt[rate_id + 1],\n\t\t\t   last_cnt->num_qry_pkt[rate_id + 2],\n\t\t\t   last_cnt->num_qry_pkt[rate_id + 3],\n\t\t\t   last_cnt->num_qry_pkt[rate_id + 4],\n\t\t\t   last_cnt->num_qry_pkt[rate_id + 5],\n\t\t\t   last_cnt->num_qry_pkt[rate_id + 6],\n\t\t\t   last_cnt->num_qry_pkt[rate_id + 7],\n\t\t\t   last_cnt->num_qry_pkt[rate_id + 8],\n\t\t\t   last_cnt->num_qry_pkt[rate_id + 9]);\n\t}\n\n\tseq_printf(m, \"[RSSI(dBm)] = {%d, %d}\\n\",\n\t\t   dm_info->rssi[RF_PATH_A] - 100,\n\t\t   dm_info->rssi[RF_PATH_B] - 100);\n\tseq_printf(m, \"[Rx EVM(dB)] = {-%d, -%d}\\n\",\n\t\t   dm_info->rx_evm_dbm[RF_PATH_A],\n\t\t   dm_info->rx_evm_dbm[RF_PATH_B]);\n\tseq_printf(m, \"[Rx SNR] = {%d, %d}\\n\",\n\t\t   dm_info->rx_snr[RF_PATH_A],\n\t\t   dm_info->rx_snr[RF_PATH_B]);\n\tseq_printf(m, \"[CFO_tail(KHz)] = {%d, %d}\\n\",\n\t\t   dm_info->cfo_tail[RF_PATH_A],\n\t\t   dm_info->cfo_tail[RF_PATH_B]);\n\n\tif (dm_info->curr_rx_rate >= DESC_RATE11M) {\n\t\tseq_puts(m, \"[Rx Average Status]:\\n\");\n\t\tseq_printf(m, \" * OFDM, EVM: {-%d}, SNR: {%d}\\n\",\n\t\t\t   (u8)ewma_evm_read(&ewma_evm[RTW_EVM_OFDM]),\n\t\t\t   (u8)ewma_snr_read(&ewma_snr[RTW_SNR_OFDM_A]));\n\t\tseq_printf(m, \" * 1SS, EVM: {-%d}, SNR: {%d}\\n\",\n\t\t\t   (u8)ewma_evm_read(&ewma_evm[RTW_EVM_1SS]),\n\t\t\t   (u8)ewma_snr_read(&ewma_snr[RTW_SNR_1SS_A]));\n\t\tseq_printf(m, \" * 2SS, EVM: {-%d, -%d}, SNR: {%d, %d}\\n\",\n\t\t\t   (u8)ewma_evm_read(&ewma_evm[RTW_EVM_2SS_A]),\n\t\t\t   (u8)ewma_evm_read(&ewma_evm[RTW_EVM_2SS_B]),\n\t\t\t   (u8)ewma_snr_read(&ewma_snr[RTW_SNR_2SS_A]),\n\t\t\t   (u8)ewma_snr_read(&ewma_snr[RTW_SNR_2SS_B]));\n\t}\n\n\tseq_puts(m, \"[Rx Counter]:\\n\");\n\tseq_printf(m, \" * CCA (CCK, OFDM, Total) = (%u, %u, %u)\\n\",\n\t\t   dm_info->cck_cca_cnt,\n\t\t   dm_info->ofdm_cca_cnt,\n\t\t   dm_info->total_cca_cnt);\n\tseq_printf(m, \" * False Alarm (CCK, OFDM, Total) = (%u, %u, %u)\\n\",\n\t\t   dm_info->cck_fa_cnt,\n\t\t   dm_info->ofdm_fa_cnt,\n\t\t   dm_info->total_fa_cnt);\n\tseq_printf(m, \" * CCK cnt (ok, err) = (%u, %u)\\n\",\n\t\t   dm_info->cck_ok_cnt, dm_info->cck_err_cnt);\n\tseq_printf(m, \" * OFDM cnt (ok, err) = (%u, %u)\\n\",\n\t\t   dm_info->ofdm_ok_cnt, dm_info->ofdm_err_cnt);\n\tseq_printf(m, \" * HT cnt (ok, err) = (%u, %u)\\n\",\n\t\t   dm_info->ht_ok_cnt, dm_info->ht_err_cnt);\n\tseq_printf(m, \" * VHT cnt (ok, err) = (%u, %u)\\n\",\n\t\t   dm_info->vht_ok_cnt, dm_info->vht_err_cnt);\n\n\treturn 0;\n}\n\nstatic int rtw_debugfs_get_coex_info(struct seq_file *m, void *v)\n{\n\tstruct rtw_debugfs_priv *debugfs_priv = m->private;\n\tstruct rtw_dev *rtwdev = debugfs_priv->rtwdev;\n\n\tmutex_lock(&rtwdev->mutex);\n\trtw_coex_display_coex_info(rtwdev, m);\n\tmutex_unlock(&rtwdev->mutex);\n\n\treturn 0;\n}\n\nstatic ssize_t rtw_debugfs_set_coex_enable(struct file *filp,\n\t\t\t\t\t   const char __user *buffer,\n\t\t\t\t\t   size_t count, loff_t *loff)\n{\n\tstruct seq_file *seqpriv = (struct seq_file *)filp->private_data;\n\tstruct rtw_debugfs_priv *debugfs_priv = seqpriv->private;\n\tstruct rtw_dev *rtwdev = debugfs_priv->rtwdev;\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tchar tmp[32 + 1];\n\tbool enable;\n\tint ret;\n\n\tret = rtw_debugfs_copy_from_user(tmp, sizeof(tmp), buffer, count, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = kstrtobool(tmp, &enable);\n\tif (ret) {\n\t\trtw_warn(rtwdev, \"invalid arguments\\n\");\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&rtwdev->mutex);\n\tcoex->manual_control = !enable;\n\tmutex_unlock(&rtwdev->mutex);\n\n\treturn count;\n}\n\nstatic int rtw_debugfs_get_coex_enable(struct seq_file *m, void *v)\n{\n\tstruct rtw_debugfs_priv *debugfs_priv = m->private;\n\tstruct rtw_dev *rtwdev = debugfs_priv->rtwdev;\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\n\tseq_printf(m, \"coex mechanism %s\\n\",\n\t\t   coex->manual_control ? \"disabled\" : \"enabled\");\n\n\treturn 0;\n}\n\nstatic ssize_t rtw_debugfs_set_edcca_enable(struct file *filp,\n\t\t\t\t\t    const char __user *buffer,\n\t\t\t\t\t    size_t count, loff_t *loff)\n{\n\tstruct seq_file *seqpriv = (struct seq_file *)filp->private_data;\n\tstruct rtw_debugfs_priv *debugfs_priv = seqpriv->private;\n\tstruct rtw_dev *rtwdev = debugfs_priv->rtwdev;\n\tbool input;\n\tint err;\n\n\terr = kstrtobool_from_user(buffer, count, &input);\n\tif (err)\n\t\treturn err;\n\n\trtw_edcca_enabled = input;\n\trtw_phy_adaptivity_set_mode(rtwdev);\n\n\treturn count;\n}\n\nstatic int rtw_debugfs_get_edcca_enable(struct seq_file *m, void *v)\n{\n\tstruct rtw_debugfs_priv *debugfs_priv = m->private;\n\tstruct rtw_dev *rtwdev = debugfs_priv->rtwdev;\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\n\tseq_printf(m, \"EDCCA %s: EDCCA mode %d\\n\",\n\t\t   rtw_edcca_enabled ? \"enabled\" : \"disabled\",\n\t\t   dm_info->edcca_mode);\n\treturn 0;\n}\n\nstatic ssize_t rtw_debugfs_set_fw_crash(struct file *filp,\n\t\t\t\t\tconst char __user *buffer,\n\t\t\t\t\tsize_t count, loff_t *loff)\n{\n\tstruct seq_file *seqpriv = (struct seq_file *)filp->private_data;\n\tstruct rtw_debugfs_priv *debugfs_priv = seqpriv->private;\n\tstruct rtw_dev *rtwdev = debugfs_priv->rtwdev;\n\tchar tmp[32 + 1];\n\tbool input;\n\tint ret;\n\n\tret = rtw_debugfs_copy_from_user(tmp, sizeof(tmp), buffer, count, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = kstrtobool(tmp, &input);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\tif (!input)\n\t\treturn -EINVAL;\n\n\tif (test_bit(RTW_FLAG_RESTARTING, rtwdev->flags))\n\t\treturn -EINPROGRESS;\n\n\tmutex_lock(&rtwdev->mutex);\n\trtw_leave_lps_deep(rtwdev);\n\tset_bit(RTW_FLAG_RESTART_TRIGGERING, rtwdev->flags);\n\trtw_write8(rtwdev, REG_HRCV_MSG, 1);\n\tmutex_unlock(&rtwdev->mutex);\n\n\treturn count;\n}\n\nstatic int rtw_debugfs_get_fw_crash(struct seq_file *m, void *v)\n{\n\tstruct rtw_debugfs_priv *debugfs_priv = m->private;\n\tstruct rtw_dev *rtwdev = debugfs_priv->rtwdev;\n\n\tseq_printf(m, \"%d\\n\",\n\t\t   test_bit(RTW_FLAG_RESTART_TRIGGERING, rtwdev->flags) ||\n\t\t   test_bit(RTW_FLAG_RESTARTING, rtwdev->flags));\n\treturn 0;\n}\n\nstatic ssize_t rtw_debugfs_set_force_lowest_basic_rate(struct file *filp,\n\t\t\t\t\t\t       const char __user *buffer,\n\t\t\t\t\t\t       size_t count, loff_t *loff)\n{\n\tstruct seq_file *seqpriv = (struct seq_file *)filp->private_data;\n\tstruct rtw_debugfs_priv *debugfs_priv = seqpriv->private;\n\tstruct rtw_dev *rtwdev = debugfs_priv->rtwdev;\n\tbool input;\n\tint err;\n\n\terr = kstrtobool_from_user(buffer, count, &input);\n\tif (err)\n\t\treturn err;\n\n\tif (input)\n\t\tset_bit(RTW_FLAG_FORCE_LOWEST_RATE, rtwdev->flags);\n\telse\n\t\tclear_bit(RTW_FLAG_FORCE_LOWEST_RATE, rtwdev->flags);\n\n\treturn count;\n}\n\nstatic int rtw_debugfs_get_force_lowest_basic_rate(struct seq_file *m, void *v)\n{\n\tstruct rtw_debugfs_priv *debugfs_priv = m->private;\n\tstruct rtw_dev *rtwdev = debugfs_priv->rtwdev;\n\n\tseq_printf(m, \"force lowest basic rate: %d\\n\",\n\t\t   test_bit(RTW_FLAG_FORCE_LOWEST_RATE, rtwdev->flags));\n\n\treturn 0;\n}\n\nstatic ssize_t rtw_debugfs_set_dm_cap(struct file *filp,\n\t\t\t\t      const char __user *buffer,\n\t\t\t\t      size_t count, loff_t *loff)\n{\n\tstruct seq_file *seqpriv = (struct seq_file *)filp->private_data;\n\tstruct rtw_debugfs_priv *debugfs_priv = seqpriv->private;\n\tstruct rtw_dev *rtwdev = debugfs_priv->rtwdev;\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tint bit;\n\tbool en;\n\n\tif (kstrtoint_from_user(buffer, count, 10, &bit))\n\t\treturn -EINVAL;\n\n\ten = bit > 0;\n\tbit = abs(bit);\n\n\tif (bit >= RTW_DM_CAP_NUM) {\n\t\trtw_warn(rtwdev, \"unknown DM CAP %d\\n\", bit);\n\t\treturn -EINVAL;\n\t}\n\n\tif (en)\n\t\tdm_info->dm_flags &= ~BIT(bit);\n\telse\n\t\tdm_info->dm_flags |= BIT(bit);\n\n\tdebugfs_priv->dm_cap.bit = bit;\n\n\treturn count;\n}\n\nstatic void dump_gapk_status(struct rtw_dev *rtwdev, struct seq_file *m)\n{\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tstruct rtw_gapk_info *txgapk = &rtwdev->dm_info.gapk;\n\tint i, path;\n\tu32 val;\n\n\tseq_printf(m, \"\\n(%2d) %c%s\\n\\n\", RTW_DM_CAP_TXGAPK,\n\t\t   dm_info->dm_flags & BIT(RTW_DM_CAP_TXGAPK) ? '-' : '+',\n\t\t   rtw_dm_cap_strs[RTW_DM_CAP_TXGAPK]);\n\n\tmutex_lock(&rtwdev->mutex);\n\n\tfor (path = 0; path < rtwdev->hal.rf_path_num; path++) {\n\t\tval = rtw_read_rf(rtwdev, path, RF_GAINTX, RFREG_MASK);\n\t\tseq_printf(m, \"path %d:\\n0x%x = 0x%x\\n\", path, RF_GAINTX, val);\n\n\t\tfor (i = 0; i < RF_HW_OFFSET_NUM; i++)\n\t\t\tseq_printf(m, \"[TXGAPK] offset %d %d\\n\",\n\t\t\t\t   txgapk->rf3f_fs[path][i], i);\n\t\tseq_puts(m, \"\\n\");\n\t}\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nstatic int rtw_debugfs_get_dm_cap(struct seq_file *m, void *v)\n{\n\tstruct rtw_debugfs_priv *debugfs_priv = m->private;\n\tstruct rtw_dev *rtwdev = debugfs_priv->rtwdev;\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tint i;\n\n\tswitch (debugfs_priv->dm_cap.bit) {\n\tcase RTW_DM_CAP_TXGAPK:\n\t\tdump_gapk_status(rtwdev, m);\n\t\tbreak;\n\tdefault:\n\t\tfor (i = 1; i < RTW_DM_CAP_NUM; i++) {\n\t\t\tseq_printf(m, \"(%2d) %c%s\\n\", i,\n\t\t\t\t   dm_info->dm_flags & BIT(i) ? '-' : '+',\n\t\t\t\t   rtw_dm_cap_strs[i]);\n\t\t}\n\t\tbreak;\n\t}\n\tdebugfs_priv->dm_cap.bit = RTW_DM_CAP_NA;\n\treturn 0;\n}\n\n#define rtw_debug_impl_mac(page, addr)\t\t\t\t\\\nstatic struct rtw_debugfs_priv rtw_debug_priv_mac_ ##page = {\t\\\n\t.cb_read = rtw_debug_get_mac_page,\t\t\t\\\n\t.cb_data = addr,\t\t\t\t\t\\\n}\n\nrtw_debug_impl_mac(0, 0x0000);\nrtw_debug_impl_mac(1, 0x0100);\nrtw_debug_impl_mac(2, 0x0200);\nrtw_debug_impl_mac(3, 0x0300);\nrtw_debug_impl_mac(4, 0x0400);\nrtw_debug_impl_mac(5, 0x0500);\nrtw_debug_impl_mac(6, 0x0600);\nrtw_debug_impl_mac(7, 0x0700);\nrtw_debug_impl_mac(10, 0x1000);\nrtw_debug_impl_mac(11, 0x1100);\nrtw_debug_impl_mac(12, 0x1200);\nrtw_debug_impl_mac(13, 0x1300);\nrtw_debug_impl_mac(14, 0x1400);\nrtw_debug_impl_mac(15, 0x1500);\nrtw_debug_impl_mac(16, 0x1600);\nrtw_debug_impl_mac(17, 0x1700);\n\n#define rtw_debug_impl_bb(page, addr)\t\t\t\\\nstatic struct rtw_debugfs_priv rtw_debug_priv_bb_ ##page = {\t\\\n\t.cb_read = rtw_debug_get_bb_page,\t\t\t\\\n\t.cb_data = addr,\t\t\t\t\t\\\n}\n\nrtw_debug_impl_bb(8, 0x0800);\nrtw_debug_impl_bb(9, 0x0900);\nrtw_debug_impl_bb(a, 0x0a00);\nrtw_debug_impl_bb(b, 0x0b00);\nrtw_debug_impl_bb(c, 0x0c00);\nrtw_debug_impl_bb(d, 0x0d00);\nrtw_debug_impl_bb(e, 0x0e00);\nrtw_debug_impl_bb(f, 0x0f00);\nrtw_debug_impl_bb(18, 0x1800);\nrtw_debug_impl_bb(19, 0x1900);\nrtw_debug_impl_bb(1a, 0x1a00);\nrtw_debug_impl_bb(1b, 0x1b00);\nrtw_debug_impl_bb(1c, 0x1c00);\nrtw_debug_impl_bb(1d, 0x1d00);\nrtw_debug_impl_bb(1e, 0x1e00);\nrtw_debug_impl_bb(1f, 0x1f00);\nrtw_debug_impl_bb(2c, 0x2c00);\nrtw_debug_impl_bb(2d, 0x2d00);\nrtw_debug_impl_bb(40, 0x4000);\nrtw_debug_impl_bb(41, 0x4100);\n\nstatic struct rtw_debugfs_priv rtw_debug_priv_rf_dump = {\n\t.cb_read = rtw_debug_get_rf_dump,\n};\n\nstatic struct rtw_debugfs_priv rtw_debug_priv_tx_pwr_tbl = {\n\t.cb_read = rtw_debugfs_get_tx_pwr_tbl,\n};\n\nstatic struct rtw_debugfs_priv rtw_debug_priv_write_reg = {\n\t.cb_write = rtw_debugfs_set_write_reg,\n};\n\nstatic struct rtw_debugfs_priv rtw_debug_priv_h2c = {\n\t.cb_write = rtw_debugfs_set_h2c,\n};\n\nstatic struct rtw_debugfs_priv rtw_debug_priv_rf_write = {\n\t.cb_write = rtw_debugfs_set_rf_write,\n};\n\nstatic struct rtw_debugfs_priv rtw_debug_priv_rf_read = {\n\t.cb_write = rtw_debugfs_set_rf_read,\n\t.cb_read = rtw_debugfs_get_rf_read,\n};\n\nstatic struct rtw_debugfs_priv rtw_debug_priv_read_reg = {\n\t.cb_write = rtw_debugfs_set_read_reg,\n\t.cb_read = rtw_debugfs_get_read_reg,\n};\n\nstatic struct rtw_debugfs_priv rtw_debug_priv_fix_rate = {\n\t.cb_write = rtw_debugfs_set_fix_rate,\n\t.cb_read = rtw_debugfs_get_fix_rate,\n};\n\nstatic struct rtw_debugfs_priv rtw_debug_priv_dump_cam = {\n\t.cb_write = rtw_debugfs_set_single_input,\n\t.cb_read = rtw_debugfs_get_dump_cam,\n};\n\nstatic struct rtw_debugfs_priv rtw_debug_priv_rsvd_page = {\n\t.cb_write = rtw_debugfs_set_rsvd_page,\n\t.cb_read = rtw_debugfs_get_rsvd_page,\n};\n\nstatic struct rtw_debugfs_priv rtw_debug_priv_phy_info = {\n\t.cb_read = rtw_debugfs_get_phy_info,\n};\n\nstatic struct rtw_debugfs_priv rtw_debug_priv_coex_enable = {\n\t.cb_write = rtw_debugfs_set_coex_enable,\n\t.cb_read = rtw_debugfs_get_coex_enable,\n};\n\nstatic struct rtw_debugfs_priv rtw_debug_priv_coex_info = {\n\t.cb_read = rtw_debugfs_get_coex_info,\n};\n\nstatic struct rtw_debugfs_priv rtw_debug_priv_edcca_enable = {\n\t.cb_write = rtw_debugfs_set_edcca_enable,\n\t.cb_read = rtw_debugfs_get_edcca_enable,\n};\n\nstatic struct rtw_debugfs_priv rtw_debug_priv_fw_crash = {\n\t.cb_write = rtw_debugfs_set_fw_crash,\n\t.cb_read = rtw_debugfs_get_fw_crash,\n};\n\nstatic struct rtw_debugfs_priv rtw_debug_priv_force_lowest_basic_rate = {\n\t.cb_write = rtw_debugfs_set_force_lowest_basic_rate,\n\t.cb_read = rtw_debugfs_get_force_lowest_basic_rate,\n};\n\nstatic struct rtw_debugfs_priv rtw_debug_priv_dm_cap = {\n\t.cb_write = rtw_debugfs_set_dm_cap,\n\t.cb_read = rtw_debugfs_get_dm_cap,\n};\n\n#define rtw_debugfs_add_core(name, mode, fopname, parent)\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\trtw_debug_priv_ ##name.rtwdev = rtwdev;\t\t\t\\\n\t\tif (IS_ERR(debugfs_create_file(#name, mode,\t\t\\\n\t\t\t\t\t parent, &rtw_debug_priv_ ##name,\\\n\t\t\t\t\t &file_ops_ ##fopname)))\t\\\n\t\t\tpr_debug(\"Unable to initialize debugfs:%s\\n\",\t\\\n\t\t\t       #name);\t\t\t\t\t\\\n\t} while (0)\n\n#define rtw_debugfs_add_w(name)\t\t\t\t\t\t\\\n\trtw_debugfs_add_core(name, S_IFREG | 0222, common_write, debugfs_topdir)\n#define rtw_debugfs_add_rw(name)\t\t\t\t\t\\\n\trtw_debugfs_add_core(name, S_IFREG | 0666, single_rw, debugfs_topdir)\n#define rtw_debugfs_add_r(name)\t\t\t\t\t\t\\\n\trtw_debugfs_add_core(name, S_IFREG | 0444, single_r, debugfs_topdir)\n\nvoid rtw_debugfs_init(struct rtw_dev *rtwdev)\n{\n\tstruct dentry *debugfs_topdir;\n\n\tdebugfs_topdir = debugfs_create_dir(\"rtw88\",\n\t\t\t\t\t    rtwdev->hw->wiphy->debugfsdir);\n\trtw_debugfs_add_w(write_reg);\n\trtw_debugfs_add_rw(read_reg);\n\trtw_debugfs_add_w(rf_write);\n\trtw_debugfs_add_rw(rf_read);\n\trtw_debugfs_add_rw(fix_rate);\n\trtw_debugfs_add_rw(dump_cam);\n\trtw_debugfs_add_rw(rsvd_page);\n\trtw_debugfs_add_r(phy_info);\n\trtw_debugfs_add_r(coex_info);\n\trtw_debugfs_add_rw(coex_enable);\n\trtw_debugfs_add_w(h2c);\n\trtw_debugfs_add_r(mac_0);\n\trtw_debugfs_add_r(mac_1);\n\trtw_debugfs_add_r(mac_2);\n\trtw_debugfs_add_r(mac_3);\n\trtw_debugfs_add_r(mac_4);\n\trtw_debugfs_add_r(mac_5);\n\trtw_debugfs_add_r(mac_6);\n\trtw_debugfs_add_r(mac_7);\n\trtw_debugfs_add_r(bb_8);\n\trtw_debugfs_add_r(bb_9);\n\trtw_debugfs_add_r(bb_a);\n\trtw_debugfs_add_r(bb_b);\n\trtw_debugfs_add_r(bb_c);\n\trtw_debugfs_add_r(bb_d);\n\trtw_debugfs_add_r(bb_e);\n\trtw_debugfs_add_r(bb_f);\n\trtw_debugfs_add_r(mac_10);\n\trtw_debugfs_add_r(mac_11);\n\trtw_debugfs_add_r(mac_12);\n\trtw_debugfs_add_r(mac_13);\n\trtw_debugfs_add_r(mac_14);\n\trtw_debugfs_add_r(mac_15);\n\trtw_debugfs_add_r(mac_16);\n\trtw_debugfs_add_r(mac_17);\n\trtw_debugfs_add_r(bb_18);\n\trtw_debugfs_add_r(bb_19);\n\trtw_debugfs_add_r(bb_1a);\n\trtw_debugfs_add_r(bb_1b);\n\trtw_debugfs_add_r(bb_1c);\n\trtw_debugfs_add_r(bb_1d);\n\trtw_debugfs_add_r(bb_1e);\n\trtw_debugfs_add_r(bb_1f);\n\tif (rtwdev->chip->id == RTW_CHIP_TYPE_8822C) {\n\t\trtw_debugfs_add_r(bb_2c);\n\t\trtw_debugfs_add_r(bb_2d);\n\t\trtw_debugfs_add_r(bb_40);\n\t\trtw_debugfs_add_r(bb_41);\n\t}\n\trtw_debugfs_add_r(rf_dump);\n\trtw_debugfs_add_r(tx_pwr_tbl);\n\trtw_debugfs_add_rw(edcca_enable);\n\trtw_debugfs_add_rw(fw_crash);\n\trtw_debugfs_add_rw(force_lowest_basic_rate);\n\trtw_debugfs_add_rw(dm_cap);\n}\n\n#endif  \n\n#ifdef CONFIG_RTW88_DEBUG\n\nvoid __rtw_dbg(struct rtw_dev *rtwdev, enum rtw_debug_mask mask,\n\t       const char *fmt, ...)\n{\n\tstruct va_format vaf = {\n\t\t.fmt = fmt,\n\t};\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.va = &args;\n\n\tif (rtw_debug_mask & mask)\n\t\tdev_printk(KERN_DEBUG, rtwdev->dev, \"%pV\", &vaf);\n\n\tva_end(args);\n}\nEXPORT_SYMBOL(__rtw_dbg);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}