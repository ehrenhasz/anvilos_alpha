{
  "module_name": "tx.c",
  "hash_id": "c7d116eee8e15c707577a1888508121c9c41a006f5cdb01f5a85105ce4f8844c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtw88/tx.c",
  "human_readable_source": "\n \n\n#include \"main.h\"\n#include \"tx.h\"\n#include \"fw.h\"\n#include \"ps.h\"\n#include \"debug.h\"\n\nstatic\nvoid rtw_tx_stats(struct rtw_dev *rtwdev, struct ieee80211_vif *vif,\n\t\t  struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr;\n\tstruct rtw_vif *rtwvif;\n\n\thdr = (struct ieee80211_hdr *)skb->data;\n\n\tif (!ieee80211_is_data(hdr->frame_control))\n\t\treturn;\n\n\tif (!is_broadcast_ether_addr(hdr->addr1) &&\n\t    !is_multicast_ether_addr(hdr->addr1)) {\n\t\trtwdev->stats.tx_unicast += skb->len;\n\t\trtwdev->stats.tx_cnt++;\n\t\tif (vif) {\n\t\t\trtwvif = (struct rtw_vif *)vif->drv_priv;\n\t\t\trtwvif->stats.tx_unicast += skb->len;\n\t\t\trtwvif->stats.tx_cnt++;\n\t\t}\n\t}\n}\n\nvoid rtw_tx_fill_tx_desc(struct rtw_tx_pkt_info *pkt_info, struct sk_buff *skb)\n{\n\tstruct rtw_tx_desc *tx_desc = (struct rtw_tx_desc *)skb->data;\n\tbool more_data = false;\n\n\tif (pkt_info->qsel == TX_DESC_QSEL_HIGH)\n\t\tmore_data = true;\n\n\ttx_desc->w0 = le32_encode_bits(pkt_info->tx_pkt_size, RTW_TX_DESC_W0_TXPKTSIZE) |\n\t\t      le32_encode_bits(pkt_info->offset, RTW_TX_DESC_W0_OFFSET) |\n\t\t      le32_encode_bits(pkt_info->bmc, RTW_TX_DESC_W0_BMC) |\n\t\t      le32_encode_bits(pkt_info->ls, RTW_TX_DESC_W0_LS) |\n\t\t      le32_encode_bits(pkt_info->dis_qselseq, RTW_TX_DESC_W0_DISQSELSEQ);\n\n\ttx_desc->w1 = le32_encode_bits(pkt_info->qsel, RTW_TX_DESC_W1_QSEL) |\n\t\t      le32_encode_bits(pkt_info->rate_id, RTW_TX_DESC_W1_RATE_ID) |\n\t\t      le32_encode_bits(pkt_info->sec_type, RTW_TX_DESC_W1_SEC_TYPE) |\n\t\t      le32_encode_bits(pkt_info->pkt_offset, RTW_TX_DESC_W1_PKT_OFFSET) |\n\t\t      le32_encode_bits(more_data, RTW_TX_DESC_W1_MORE_DATA);\n\n\ttx_desc->w2 = le32_encode_bits(pkt_info->ampdu_en, RTW_TX_DESC_W2_AGG_EN) |\n\t\t      le32_encode_bits(pkt_info->report, RTW_TX_DESC_W2_SPE_RPT) |\n\t\t      le32_encode_bits(pkt_info->ampdu_density, RTW_TX_DESC_W2_AMPDU_DEN) |\n\t\t      le32_encode_bits(pkt_info->bt_null, RTW_TX_DESC_W2_BT_NULL);\n\n\ttx_desc->w3 = le32_encode_bits(pkt_info->hw_ssn_sel, RTW_TX_DESC_W3_HW_SSN_SEL) |\n\t\t      le32_encode_bits(pkt_info->use_rate, RTW_TX_DESC_W3_USE_RATE) |\n\t\t      le32_encode_bits(pkt_info->dis_rate_fallback, RTW_TX_DESC_W3_DISDATAFB) |\n\t\t      le32_encode_bits(pkt_info->rts, RTW_TX_DESC_W3_USE_RTS) |\n\t\t      le32_encode_bits(pkt_info->nav_use_hdr, RTW_TX_DESC_W3_NAVUSEHDR) |\n\t\t      le32_encode_bits(pkt_info->ampdu_factor, RTW_TX_DESC_W3_MAX_AGG_NUM);\n\n\ttx_desc->w4 = le32_encode_bits(pkt_info->rate, RTW_TX_DESC_W4_DATARATE);\n\n\ttx_desc->w5 = le32_encode_bits(pkt_info->short_gi, RTW_TX_DESC_W5_DATA_SHORT) |\n\t\t      le32_encode_bits(pkt_info->bw, RTW_TX_DESC_W5_DATA_BW) |\n\t\t      le32_encode_bits(pkt_info->ldpc, RTW_TX_DESC_W5_DATA_LDPC) |\n\t\t      le32_encode_bits(pkt_info->stbc, RTW_TX_DESC_W5_DATA_STBC);\n\n\ttx_desc->w6 = le32_encode_bits(pkt_info->sn, RTW_TX_DESC_W6_SW_DEFINE);\n\n\ttx_desc->w8 = le32_encode_bits(pkt_info->en_hwseq, RTW_TX_DESC_W8_EN_HWSEQ);\n\n\ttx_desc->w9 = le32_encode_bits(pkt_info->seq, RTW_TX_DESC_W9_SW_SEQ);\n\n\tif (pkt_info->rts) {\n\t\ttx_desc->w4 |= le32_encode_bits(DESC_RATE24M, RTW_TX_DESC_W4_RTSRATE);\n\t\ttx_desc->w5 |= le32_encode_bits(1, RTW_TX_DESC_W5_DATA_RTS_SHORT);\n\t}\n\n\tif (pkt_info->tim_offset)\n\t\ttx_desc->w9 |= le32_encode_bits(1, RTW_TX_DESC_W9_TIM_EN) |\n\t\t\t       le32_encode_bits(pkt_info->tim_offset, RTW_TX_DESC_W9_TIM_OFFSET);\n}\nEXPORT_SYMBOL(rtw_tx_fill_tx_desc);\n\nstatic u8 get_tx_ampdu_factor(struct ieee80211_sta *sta)\n{\n\tu8 exp = sta->deflink.ht_cap.ampdu_factor;\n\n\t \n\treturn (BIT(2) << exp) - 1;\n}\n\nstatic u8 get_tx_ampdu_density(struct ieee80211_sta *sta)\n{\n\treturn sta->deflink.ht_cap.ampdu_density;\n}\n\nstatic u8 get_highest_ht_tx_rate(struct rtw_dev *rtwdev,\n\t\t\t\t struct ieee80211_sta *sta)\n{\n\tu8 rate;\n\n\tif (rtwdev->hal.rf_type == RF_2T2R && sta->deflink.ht_cap.mcs.rx_mask[1] != 0)\n\t\trate = DESC_RATEMCS15;\n\telse\n\t\trate = DESC_RATEMCS7;\n\n\treturn rate;\n}\n\nstatic u8 get_highest_vht_tx_rate(struct rtw_dev *rtwdev,\n\t\t\t\t  struct ieee80211_sta *sta)\n{\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\tu8 rate;\n\tu16 tx_mcs_map;\n\n\ttx_mcs_map = le16_to_cpu(sta->deflink.vht_cap.vht_mcs.tx_mcs_map);\n\tif (efuse->hw_cap.nss == 1) {\n\t\tswitch (tx_mcs_map & 0x3) {\n\t\tcase IEEE80211_VHT_MCS_SUPPORT_0_7:\n\t\t\trate = DESC_RATEVHT1SS_MCS7;\n\t\t\tbreak;\n\t\tcase IEEE80211_VHT_MCS_SUPPORT_0_8:\n\t\t\trate = DESC_RATEVHT1SS_MCS8;\n\t\t\tbreak;\n\t\tdefault:\n\t\tcase IEEE80211_VHT_MCS_SUPPORT_0_9:\n\t\t\trate = DESC_RATEVHT1SS_MCS9;\n\t\t\tbreak;\n\t\t}\n\t} else if (efuse->hw_cap.nss >= 2) {\n\t\tswitch ((tx_mcs_map & 0xc) >> 2) {\n\t\tcase IEEE80211_VHT_MCS_SUPPORT_0_7:\n\t\t\trate = DESC_RATEVHT2SS_MCS7;\n\t\t\tbreak;\n\t\tcase IEEE80211_VHT_MCS_SUPPORT_0_8:\n\t\t\trate = DESC_RATEVHT2SS_MCS8;\n\t\t\tbreak;\n\t\tdefault:\n\t\tcase IEEE80211_VHT_MCS_SUPPORT_0_9:\n\t\t\trate = DESC_RATEVHT2SS_MCS9;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\trate = DESC_RATEVHT1SS_MCS9;\n\t}\n\n\treturn rate;\n}\n\nstatic void rtw_tx_report_enable(struct rtw_dev *rtwdev,\n\t\t\t\t struct rtw_tx_pkt_info *pkt_info)\n{\n\tstruct rtw_tx_report *tx_report = &rtwdev->tx_report;\n\n\t \n\tpkt_info->sn = (atomic_inc_return(&tx_report->sn) << 2) & 0xfc;\n\tpkt_info->report = true;\n}\n\nvoid rtw_tx_report_purge_timer(struct timer_list *t)\n{\n\tstruct rtw_dev *rtwdev = from_timer(rtwdev, t, tx_report.purge_timer);\n\tstruct rtw_tx_report *tx_report = &rtwdev->tx_report;\n\tunsigned long flags;\n\n\tif (skb_queue_len(&tx_report->queue) == 0)\n\t\treturn;\n\n\trtw_warn(rtwdev, \"failed to get tx report from firmware\\n\");\n\n\tspin_lock_irqsave(&tx_report->q_lock, flags);\n\tskb_queue_purge(&tx_report->queue);\n\tspin_unlock_irqrestore(&tx_report->q_lock, flags);\n}\n\nvoid rtw_tx_report_enqueue(struct rtw_dev *rtwdev, struct sk_buff *skb, u8 sn)\n{\n\tstruct rtw_tx_report *tx_report = &rtwdev->tx_report;\n\tunsigned long flags;\n\tu8 *drv_data;\n\n\t \n\tdrv_data = (u8 *)IEEE80211_SKB_CB(skb)->status.status_driver_data;\n\t*drv_data = sn;\n\n\tspin_lock_irqsave(&tx_report->q_lock, flags);\n\t__skb_queue_tail(&tx_report->queue, skb);\n\tspin_unlock_irqrestore(&tx_report->q_lock, flags);\n\n\tmod_timer(&tx_report->purge_timer, jiffies + RTW_TX_PROBE_TIMEOUT);\n}\nEXPORT_SYMBOL(rtw_tx_report_enqueue);\n\nstatic void rtw_tx_report_tx_status(struct rtw_dev *rtwdev,\n\t\t\t\t    struct sk_buff *skb, bool acked)\n{\n\tstruct ieee80211_tx_info *info;\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\tieee80211_tx_info_clear_status(info);\n\tif (acked)\n\t\tinfo->flags |= IEEE80211_TX_STAT_ACK;\n\telse\n\t\tinfo->flags &= ~IEEE80211_TX_STAT_ACK;\n\n\tieee80211_tx_status_irqsafe(rtwdev->hw, skb);\n}\n\nvoid rtw_tx_report_handle(struct rtw_dev *rtwdev, struct sk_buff *skb, int src)\n{\n\tstruct rtw_tx_report *tx_report = &rtwdev->tx_report;\n\tstruct rtw_c2h_cmd *c2h;\n\tstruct sk_buff *cur, *tmp;\n\tunsigned long flags;\n\tu8 sn, st;\n\tu8 *n;\n\n\tc2h = get_c2h_from_skb(skb);\n\n\tif (src == C2H_CCX_TX_RPT) {\n\t\tsn = GET_CCX_REPORT_SEQNUM_V0(c2h->payload);\n\t\tst = GET_CCX_REPORT_STATUS_V0(c2h->payload);\n\t} else {\n\t\tsn = GET_CCX_REPORT_SEQNUM_V1(c2h->payload);\n\t\tst = GET_CCX_REPORT_STATUS_V1(c2h->payload);\n\t}\n\n\tspin_lock_irqsave(&tx_report->q_lock, flags);\n\tskb_queue_walk_safe(&tx_report->queue, cur, tmp) {\n\t\tn = (u8 *)IEEE80211_SKB_CB(cur)->status.status_driver_data;\n\t\tif (*n == sn) {\n\t\t\t__skb_unlink(cur, &tx_report->queue);\n\t\t\trtw_tx_report_tx_status(rtwdev, cur, st == 0);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&tx_report->q_lock, flags);\n}\n\nstatic u8 rtw_get_mgmt_rate(struct rtw_dev *rtwdev, struct sk_buff *skb,\n\t\t\t    u8 lowest_rate, bool ignore_rate)\n{\n\tstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_vif *vif = tx_info->control.vif;\n\tbool force_lowest = test_bit(RTW_FLAG_FORCE_LOWEST_RATE, rtwdev->flags);\n\n\tif (!vif || !vif->bss_conf.basic_rates || ignore_rate || force_lowest)\n\t\treturn lowest_rate;\n\n\treturn __ffs(vif->bss_conf.basic_rates) + lowest_rate;\n}\n\nstatic void rtw_tx_pkt_info_update_rate(struct rtw_dev *rtwdev,\n\t\t\t\t\tstruct rtw_tx_pkt_info *pkt_info,\n\t\t\t\t\tstruct sk_buff *skb,\n\t\t\t\t\tbool ignore_rate)\n{\n\tif (rtwdev->hal.current_band_type == RTW_BAND_2G) {\n\t\tpkt_info->rate_id = RTW_RATEID_B_20M;\n\t\tpkt_info->rate = rtw_get_mgmt_rate(rtwdev, skb, DESC_RATE1M,\n\t\t\t\t\t\t   ignore_rate);\n\t} else {\n\t\tpkt_info->rate_id = RTW_RATEID_G;\n\t\tpkt_info->rate = rtw_get_mgmt_rate(rtwdev, skb, DESC_RATE6M,\n\t\t\t\t\t\t   ignore_rate);\n\t}\n\n\tpkt_info->use_rate = true;\n\tpkt_info->dis_rate_fallback = true;\n}\n\nstatic void rtw_tx_pkt_info_update_sec(struct rtw_dev *rtwdev,\n\t\t\t\t       struct rtw_tx_pkt_info *pkt_info,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tu8 sec_type = 0;\n\n\tif (info && info->control.hw_key) {\n\t\tstruct ieee80211_key_conf *key = info->control.hw_key;\n\n\t\tswitch (key->cipher) {\n\t\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\t\tsec_type = 0x01;\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\t\tsec_type = 0x03;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tpkt_info->sec_type = sec_type;\n}\n\nstatic void rtw_tx_mgmt_pkt_info_update(struct rtw_dev *rtwdev,\n\t\t\t\t\tstruct rtw_tx_pkt_info *pkt_info,\n\t\t\t\t\tstruct ieee80211_sta *sta,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\trtw_tx_pkt_info_update_rate(rtwdev, pkt_info, skb, false);\n\tpkt_info->dis_qselseq = true;\n\tpkt_info->en_hwseq = true;\n\tpkt_info->hw_ssn_sel = 0;\n\t \n}\n\nstatic void rtw_tx_data_pkt_info_update(struct rtw_dev *rtwdev,\n\t\t\t\t\tstruct rtw_tx_pkt_info *pkt_info,\n\t\t\t\t\tstruct ieee80211_sta *sta,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hw *hw = rtwdev->hw;\n\tstruct rtw_dm_info *dm_info = &rtwdev->dm_info;\n\tstruct rtw_sta_info *si;\n\tu8 fix_rate;\n\tu16 seq;\n\tu8 ampdu_factor = 0;\n\tu8 ampdu_density = 0;\n\tbool ampdu_en = false;\n\tu8 rate = DESC_RATE6M;\n\tu8 rate_id = 6;\n\tu8 bw = RTW_CHANNEL_WIDTH_20;\n\tbool stbc = false;\n\tbool ldpc = false;\n\n\tseq = (le16_to_cpu(hdr->seq_ctrl) & IEEE80211_SCTL_SEQ) >> 4;\n\n\t \n\tif (!sta)\n\t\tgoto out;\n\n\tif (info->flags & IEEE80211_TX_CTL_AMPDU) {\n\t\tampdu_en = true;\n\t\tampdu_factor = get_tx_ampdu_factor(sta);\n\t\tampdu_density = get_tx_ampdu_density(sta);\n\t}\n\n\tif (info->control.use_rts || skb->len > hw->wiphy->rts_threshold)\n\t\tpkt_info->rts = true;\n\n\tif (sta->deflink.vht_cap.vht_supported)\n\t\trate = get_highest_vht_tx_rate(rtwdev, sta);\n\telse if (sta->deflink.ht_cap.ht_supported)\n\t\trate = get_highest_ht_tx_rate(rtwdev, sta);\n\telse if (sta->deflink.supp_rates[0] <= 0xf)\n\t\trate = DESC_RATE11M;\n\telse\n\t\trate = DESC_RATE54M;\n\n\tsi = (struct rtw_sta_info *)sta->drv_priv;\n\n\tbw = si->bw_mode;\n\trate_id = si->rate_id;\n\tstbc = rtwdev->hal.txrx_1ss ? false : si->stbc_en;\n\tldpc = si->ldpc_en;\n\nout:\n\tpkt_info->seq = seq;\n\tpkt_info->ampdu_factor = ampdu_factor;\n\tpkt_info->ampdu_density = ampdu_density;\n\tpkt_info->ampdu_en = ampdu_en;\n\tpkt_info->rate = rate;\n\tpkt_info->rate_id = rate_id;\n\tpkt_info->bw = bw;\n\tpkt_info->stbc = stbc;\n\tpkt_info->ldpc = ldpc;\n\n\tfix_rate = dm_info->fix_rate;\n\tif (fix_rate < DESC_RATE_MAX) {\n\t\tpkt_info->rate = fix_rate;\n\t\tpkt_info->dis_rate_fallback = true;\n\t\tpkt_info->use_rate = true;\n\t}\n}\n\nvoid rtw_tx_pkt_info_update(struct rtw_dev *rtwdev,\n\t\t\t    struct rtw_tx_pkt_info *pkt_info,\n\t\t\t    struct ieee80211_sta *sta,\n\t\t\t    struct sk_buff *skb)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tstruct rtw_sta_info *si;\n\tstruct ieee80211_vif *vif = NULL;\n\t__le16 fc = hdr->frame_control;\n\tbool bmc;\n\n\tif (sta) {\n\t\tsi = (struct rtw_sta_info *)sta->drv_priv;\n\t\tvif = si->vif;\n\t}\n\n\tif (ieee80211_is_mgmt(fc) || ieee80211_is_nullfunc(fc))\n\t\trtw_tx_mgmt_pkt_info_update(rtwdev, pkt_info, sta, skb);\n\telse if (ieee80211_is_data(fc))\n\t\trtw_tx_data_pkt_info_update(rtwdev, pkt_info, sta, skb);\n\n\tbmc = is_broadcast_ether_addr(hdr->addr1) ||\n\t      is_multicast_ether_addr(hdr->addr1);\n\n\tif (info->flags & IEEE80211_TX_CTL_REQ_TX_STATUS)\n\t\trtw_tx_report_enable(rtwdev, pkt_info);\n\n\tpkt_info->bmc = bmc;\n\trtw_tx_pkt_info_update_sec(rtwdev, pkt_info, skb);\n\tpkt_info->tx_pkt_size = skb->len;\n\tpkt_info->offset = chip->tx_pkt_desc_sz;\n\tpkt_info->qsel = skb->priority;\n\tpkt_info->ls = true;\n\n\t \n\trtw_tx_stats(rtwdev, vif, skb);\n}\n\nvoid rtw_tx_rsvd_page_pkt_info_update(struct rtw_dev *rtwdev,\n\t\t\t\t      struct rtw_tx_pkt_info *pkt_info,\n\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t      enum rtw_rsvd_packet_type type)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tbool bmc;\n\n\t \n\tif (type != RSVD_BEACON && type != RSVD_DUMMY)\n\t\tpkt_info->qsel = TX_DESC_QSEL_MGMT;\n\n\trtw_tx_pkt_info_update_rate(rtwdev, pkt_info, skb, true);\n\n\tbmc = is_broadcast_ether_addr(hdr->addr1) ||\n\t      is_multicast_ether_addr(hdr->addr1);\n\tpkt_info->bmc = bmc;\n\tpkt_info->tx_pkt_size = skb->len;\n\tpkt_info->offset = chip->tx_pkt_desc_sz;\n\tpkt_info->ls = true;\n\tif (type == RSVD_PS_POLL) {\n\t\tpkt_info->nav_use_hdr = true;\n\t} else {\n\t\tpkt_info->dis_qselseq = true;\n\t\tpkt_info->en_hwseq = true;\n\t\tpkt_info->hw_ssn_sel = 0;\n\t}\n\tif (type == RSVD_QOS_NULL)\n\t\tpkt_info->bt_null = true;\n\n\tif (type == RSVD_BEACON) {\n\t\tstruct rtw_rsvd_page *rsvd_pkt;\n\t\tint hdr_len;\n\n\t\trsvd_pkt = list_first_entry_or_null(&rtwdev->rsvd_page_list,\n\t\t\t\t\t\t    struct rtw_rsvd_page,\n\t\t\t\t\t\t    build_list);\n\t\tif (rsvd_pkt && rsvd_pkt->tim_offset != 0) {\n\t\t\thdr_len = sizeof(struct ieee80211_hdr_3addr);\n\t\t\tpkt_info->tim_offset = rsvd_pkt->tim_offset - hdr_len;\n\t\t}\n\t}\n\n\trtw_tx_pkt_info_update_sec(rtwdev, pkt_info, skb);\n\n\t \n}\n\nstruct sk_buff *\nrtw_tx_write_data_rsvd_page_get(struct rtw_dev *rtwdev,\n\t\t\t\tstruct rtw_tx_pkt_info *pkt_info,\n\t\t\t\tu8 *buf, u32 size)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct sk_buff *skb;\n\tu32 tx_pkt_desc_sz;\n\tu32 length;\n\n\ttx_pkt_desc_sz = chip->tx_pkt_desc_sz;\n\tlength = size + tx_pkt_desc_sz;\n\tskb = dev_alloc_skb(length);\n\tif (!skb) {\n\t\trtw_err(rtwdev, \"failed to alloc write data rsvd page skb\\n\");\n\t\treturn NULL;\n\t}\n\n\tskb_reserve(skb, tx_pkt_desc_sz);\n\tskb_put_data(skb, buf, size);\n\trtw_tx_rsvd_page_pkt_info_update(rtwdev, pkt_info, skb, RSVD_BEACON);\n\n\treturn skb;\n}\nEXPORT_SYMBOL(rtw_tx_write_data_rsvd_page_get);\n\nstruct sk_buff *\nrtw_tx_write_data_h2c_get(struct rtw_dev *rtwdev,\n\t\t\t  struct rtw_tx_pkt_info *pkt_info,\n\t\t\t  u8 *buf, u32 size)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct sk_buff *skb;\n\tu32 tx_pkt_desc_sz;\n\tu32 length;\n\n\ttx_pkt_desc_sz = chip->tx_pkt_desc_sz;\n\tlength = size + tx_pkt_desc_sz;\n\tskb = dev_alloc_skb(length);\n\tif (!skb) {\n\t\trtw_err(rtwdev, \"failed to alloc write data h2c skb\\n\");\n\t\treturn NULL;\n\t}\n\n\tskb_reserve(skb, tx_pkt_desc_sz);\n\tskb_put_data(skb, buf, size);\n\tpkt_info->tx_pkt_size = size;\n\n\treturn skb;\n}\nEXPORT_SYMBOL(rtw_tx_write_data_h2c_get);\n\nvoid rtw_tx(struct rtw_dev *rtwdev,\n\t    struct ieee80211_tx_control *control,\n\t    struct sk_buff *skb)\n{\n\tstruct rtw_tx_pkt_info pkt_info = {0};\n\tint ret;\n\n\trtw_tx_pkt_info_update(rtwdev, &pkt_info, control->sta, skb);\n\tret = rtw_hci_tx_write(rtwdev, &pkt_info, skb);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to write TX skb to HCI\\n\");\n\t\tgoto out;\n\t}\n\n\trtw_hci_tx_kick_off(rtwdev);\n\n\treturn;\n\nout:\n\tieee80211_free_txskb(rtwdev->hw, skb);\n}\n\nstatic void rtw_txq_check_agg(struct rtw_dev *rtwdev,\n\t\t\t      struct rtw_txq *rtwtxq,\n\t\t\t      struct sk_buff *skb)\n{\n\tstruct ieee80211_txq *txq = rtwtxq_to_txq(rtwtxq);\n\tstruct ieee80211_tx_info *info;\n\tstruct rtw_sta_info *si;\n\n\tif (test_bit(RTW_TXQ_AMPDU, &rtwtxq->flags)) {\n\t\tinfo = IEEE80211_SKB_CB(skb);\n\t\tinfo->flags |= IEEE80211_TX_CTL_AMPDU;\n\t\treturn;\n\t}\n\n\tif (skb_get_queue_mapping(skb) == IEEE80211_AC_VO)\n\t\treturn;\n\n\tif (test_bit(RTW_TXQ_BLOCK_BA, &rtwtxq->flags))\n\t\treturn;\n\n\tif (unlikely(skb->protocol == cpu_to_be16(ETH_P_PAE)))\n\t\treturn;\n\n\tif (!txq->sta)\n\t\treturn;\n\n\tsi = (struct rtw_sta_info *)txq->sta->drv_priv;\n\tset_bit(txq->tid, si->tid_ba);\n\n\tieee80211_queue_work(rtwdev->hw, &rtwdev->ba_work);\n}\n\nstatic int rtw_txq_push_skb(struct rtw_dev *rtwdev,\n\t\t\t    struct rtw_txq *rtwtxq,\n\t\t\t    struct sk_buff *skb)\n{\n\tstruct ieee80211_txq *txq = rtwtxq_to_txq(rtwtxq);\n\tstruct rtw_tx_pkt_info pkt_info = {0};\n\tint ret;\n\n\trtw_txq_check_agg(rtwdev, rtwtxq, skb);\n\n\trtw_tx_pkt_info_update(rtwdev, &pkt_info, txq->sta, skb);\n\tret = rtw_hci_tx_write(rtwdev, &pkt_info, skb);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to write TX skb to HCI\\n\");\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic struct sk_buff *rtw_txq_dequeue(struct rtw_dev *rtwdev,\n\t\t\t\t       struct rtw_txq *rtwtxq)\n{\n\tstruct ieee80211_txq *txq = rtwtxq_to_txq(rtwtxq);\n\tstruct sk_buff *skb;\n\n\tskb = ieee80211_tx_dequeue(rtwdev->hw, txq);\n\tif (!skb)\n\t\treturn NULL;\n\n\treturn skb;\n}\n\nstatic void rtw_txq_push(struct rtw_dev *rtwdev,\n\t\t\t struct rtw_txq *rtwtxq,\n\t\t\t unsigned long frames)\n{\n\tstruct sk_buff *skb;\n\tint ret;\n\tint i;\n\n\trcu_read_lock();\n\n\tfor (i = 0; i < frames; i++) {\n\t\tskb = rtw_txq_dequeue(rtwdev, rtwtxq);\n\t\tif (!skb)\n\t\t\tbreak;\n\n\t\tret = rtw_txq_push_skb(rtwdev, rtwtxq, skb);\n\t\tif (ret) {\n\t\t\trtw_err(rtwdev, \"failed to pusk skb, ret %d\\n\", ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n}\n\nvoid __rtw_tx_work(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_txq *rtwtxq, *tmp;\n\n\tspin_lock_bh(&rtwdev->txq_lock);\n\n\tlist_for_each_entry_safe(rtwtxq, tmp, &rtwdev->txqs, list) {\n\t\tstruct ieee80211_txq *txq = rtwtxq_to_txq(rtwtxq);\n\t\tunsigned long frame_cnt;\n\t\tunsigned long byte_cnt;\n\n\t\tieee80211_txq_get_depth(txq, &frame_cnt, &byte_cnt);\n\t\trtw_txq_push(rtwdev, rtwtxq, frame_cnt);\n\n\t\tlist_del_init(&rtwtxq->list);\n\t}\n\n\trtw_hci_tx_kick_off(rtwdev);\n\n\tspin_unlock_bh(&rtwdev->txq_lock);\n}\n\nvoid rtw_tx_work(struct work_struct *w)\n{\n\tstruct rtw_dev *rtwdev = container_of(w, struct rtw_dev, tx_work);\n\n\t__rtw_tx_work(rtwdev);\n}\n\nvoid rtw_txq_init(struct rtw_dev *rtwdev, struct ieee80211_txq *txq)\n{\n\tstruct rtw_txq *rtwtxq;\n\n\tif (!txq)\n\t\treturn;\n\n\trtwtxq = (struct rtw_txq *)txq->drv_priv;\n\tINIT_LIST_HEAD(&rtwtxq->list);\n}\n\nvoid rtw_txq_cleanup(struct rtw_dev *rtwdev, struct ieee80211_txq *txq)\n{\n\tstruct rtw_txq *rtwtxq;\n\n\tif (!txq)\n\t\treturn;\n\n\trtwtxq = (struct rtw_txq *)txq->drv_priv;\n\tspin_lock_bh(&rtwdev->txq_lock);\n\tif (!list_empty(&rtwtxq->list))\n\t\tlist_del_init(&rtwtxq->list);\n\tspin_unlock_bh(&rtwdev->txq_lock);\n}\n\nstatic const enum rtw_tx_queue_type ac_to_hwq[] = {\n\t[IEEE80211_AC_VO] = RTW_TX_QUEUE_VO,\n\t[IEEE80211_AC_VI] = RTW_TX_QUEUE_VI,\n\t[IEEE80211_AC_BE] = RTW_TX_QUEUE_BE,\n\t[IEEE80211_AC_BK] = RTW_TX_QUEUE_BK,\n};\n\nstatic_assert(ARRAY_SIZE(ac_to_hwq) == IEEE80211_NUM_ACS);\n\nenum rtw_tx_queue_type rtw_tx_ac_to_hwq(enum ieee80211_ac_numbers ac)\n{\n\tif (WARN_ON(unlikely(ac >= IEEE80211_NUM_ACS)))\n\t\treturn RTW_TX_QUEUE_BE;\n\n\treturn ac_to_hwq[ac];\n}\nEXPORT_SYMBOL(rtw_tx_ac_to_hwq);\n\nenum rtw_tx_queue_type rtw_tx_queue_mapping(struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\t__le16 fc = hdr->frame_control;\n\tu8 q_mapping = skb_get_queue_mapping(skb);\n\tenum rtw_tx_queue_type queue;\n\n\tif (unlikely(ieee80211_is_beacon(fc)))\n\t\tqueue = RTW_TX_QUEUE_BCN;\n\telse if (unlikely(ieee80211_is_mgmt(fc) || ieee80211_is_ctl(fc)))\n\t\tqueue = RTW_TX_QUEUE_MGMT;\n\telse if (is_broadcast_ether_addr(hdr->addr1) ||\n\t\t is_multicast_ether_addr(hdr->addr1))\n\t\tqueue = RTW_TX_QUEUE_HI0;\n\telse if (WARN_ON_ONCE(q_mapping >= ARRAY_SIZE(ac_to_hwq)))\n\t\tqueue = ac_to_hwq[IEEE80211_AC_BE];\n\telse\n\t\tqueue = ac_to_hwq[q_mapping];\n\n\treturn queue;\n}\nEXPORT_SYMBOL(rtw_tx_queue_mapping);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}