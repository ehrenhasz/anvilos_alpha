{
  "module_name": "bf.c",
  "hash_id": "3bedf367e45f93de83d36ed59c15b56080aeeffec4bb8e832d95d219545994e6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtw88/bf.c",
  "human_readable_source": "\n \n\n#include \"main.h\"\n#include \"reg.h\"\n#include \"bf.h\"\n#include \"debug.h\"\n\nvoid rtw_bf_disassoc(struct rtw_dev *rtwdev, struct ieee80211_vif *vif,\n\t\t     struct ieee80211_bss_conf *bss_conf)\n{\n\tstruct rtw_vif *rtwvif = (struct rtw_vif *)vif->drv_priv;\n\tstruct rtw_bfee *bfee = &rtwvif->bfee;\n\tstruct rtw_bf_info *bfinfo = &rtwdev->bf_info;\n\n\tif (bfee->role == RTW_BFEE_NONE)\n\t\treturn;\n\n\tif (bfee->role == RTW_BFEE_MU)\n\t\tbfinfo->bfer_mu_cnt--;\n\telse if (bfee->role == RTW_BFEE_SU)\n\t\tbfinfo->bfer_su_cnt--;\n\n\trtw_chip_config_bfee(rtwdev, rtwvif, bfee, false);\n\n\tbfee->role = RTW_BFEE_NONE;\n}\n\nvoid rtw_bf_assoc(struct rtw_dev *rtwdev, struct ieee80211_vif *vif,\n\t\t  struct ieee80211_bss_conf *bss_conf)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct ieee80211_hw *hw = rtwdev->hw;\n\tstruct rtw_vif *rtwvif = (struct rtw_vif *)vif->drv_priv;\n\tstruct rtw_bfee *bfee = &rtwvif->bfee;\n\tstruct rtw_bf_info *bfinfo = &rtwdev->bf_info;\n\tstruct ieee80211_sta *sta;\n\tstruct ieee80211_sta_vht_cap *vht_cap;\n\tstruct ieee80211_sta_vht_cap *ic_vht_cap;\n\tconst u8 *bssid = bss_conf->bssid;\n\tu32 sound_dim;\n\tu8 i;\n\n\tif (!(chip->band & RTW_BAND_5G))\n\t\treturn;\n\n\trcu_read_lock();\n\n\tsta = ieee80211_find_sta(vif, bssid);\n\tif (!sta) {\n\t\trcu_read_unlock();\n\n\t\trtw_warn(rtwdev, \"failed to find station entry for bss %pM\\n\",\n\t\t\t bssid);\n\t\treturn;\n\t}\n\n\tic_vht_cap = &hw->wiphy->bands[NL80211_BAND_5GHZ]->vht_cap;\n\tvht_cap = &sta->deflink.vht_cap;\n\n\trcu_read_unlock();\n\n\tif ((ic_vht_cap->cap & IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE) &&\n\t    (vht_cap->cap & IEEE80211_VHT_CAP_MU_BEAMFORMER_CAPABLE)) {\n\t\tif (bfinfo->bfer_mu_cnt >= chip->bfer_mu_max_num) {\n\t\t\trtw_dbg(rtwdev, RTW_DBG_BF, \"mu bfer number over limit\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tether_addr_copy(bfee->mac_addr, bssid);\n\t\tbfee->role = RTW_BFEE_MU;\n\t\tbfee->p_aid = (bssid[5] << 1) | (bssid[4] >> 7);\n\t\tbfee->aid = vif->cfg.aid;\n\t\tbfinfo->bfer_mu_cnt++;\n\n\t\trtw_chip_config_bfee(rtwdev, rtwvif, bfee, true);\n\t} else if ((ic_vht_cap->cap & IEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE) &&\n\t\t   (vht_cap->cap & IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE)) {\n\t\tif (bfinfo->bfer_su_cnt >= chip->bfer_su_max_num) {\n\t\t\trtw_dbg(rtwdev, RTW_DBG_BF, \"su bfer number over limit\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tsound_dim = vht_cap->cap &\n\t\t\t    IEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_MASK;\n\t\tsound_dim >>= IEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_SHIFT;\n\n\t\tether_addr_copy(bfee->mac_addr, bssid);\n\t\tbfee->role = RTW_BFEE_SU;\n\t\tbfee->sound_dim = (u8)sound_dim;\n\t\tbfee->g_id = 0;\n\t\tbfee->p_aid = (bssid[5] << 1) | (bssid[4] >> 7);\n\t\tbfinfo->bfer_su_cnt++;\n\t\tfor (i = 0; i < chip->bfer_su_max_num; i++) {\n\t\t\tif (!test_bit(i, bfinfo->bfer_su_reg_maping)) {\n\t\t\t\tset_bit(i, bfinfo->bfer_su_reg_maping);\n\t\t\t\tbfee->su_reg_index = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\trtw_chip_config_bfee(rtwdev, rtwvif, bfee, true);\n\t}\n}\n\nvoid rtw_bf_init_bfer_entry_mu(struct rtw_dev *rtwdev,\n\t\t\t       struct mu_bfer_init_para *param)\n{\n\tu16 mu_bf_ctl = 0;\n\tu8 *addr = param->bfer_address;\n\tint i;\n\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\trtw_write8(rtwdev, REG_ASSOCIATED_BFMER0_INFO + i, addr[i]);\n\trtw_write16(rtwdev, REG_ASSOCIATED_BFMER0_INFO + 6, param->paid);\n\trtw_write16(rtwdev, REG_TX_CSI_RPT_PARAM_BW20, param->csi_para);\n\n\tmu_bf_ctl = rtw_read16(rtwdev, REG_WMAC_MU_BF_CTL) & 0xC000;\n\tmu_bf_ctl |= param->my_aid | (param->csi_length_sel << 12);\n\trtw_write16(rtwdev, REG_WMAC_MU_BF_CTL, mu_bf_ctl);\n}\n\nvoid rtw_bf_cfg_sounding(struct rtw_dev *rtwdev, struct rtw_vif *vif,\n\t\t\t enum rtw_trx_desc_rate rate)\n{\n\tu32 psf_ctl = 0;\n\tu8 csi_rsc = 0x1;\n\n\tpsf_ctl = rtw_read32(rtwdev, REG_BBPSF_CTRL) |\n\t\t  BIT_WMAC_USE_NDPARATE |\n\t\t  (csi_rsc << 13);\n\n\trtw_write8_mask(rtwdev, REG_SND_PTCL_CTRL, BIT_MASK_BEAMFORM,\n\t\t\tRTW_SND_CTRL_SOUNDING);\n\trtw_write8(rtwdev, REG_SND_PTCL_CTRL + 3, 0x26);\n\trtw_write8_clr(rtwdev, REG_RXFLTMAP1, BIT_RXFLTMAP1_BF_REPORT_POLL);\n\trtw_write8_clr(rtwdev, REG_RXFLTMAP4, BIT_RXFLTMAP4_BF_REPORT_POLL);\n\n\tif (vif->net_type == RTW_NET_AP_MODE)\n\t\trtw_write32(rtwdev, REG_BBPSF_CTRL, psf_ctl | BIT(12));\n\telse\n\t\trtw_write32(rtwdev, REG_BBPSF_CTRL, psf_ctl & ~BIT(12));\n}\n\nvoid rtw_bf_cfg_mu_bfee(struct rtw_dev *rtwdev, struct cfg_mumimo_para *param)\n{\n\tu8 mu_tbl_sel;\n\tu8 mu_valid;\n\n\tmu_valid = rtw_read8(rtwdev, REG_MU_TX_CTL) &\n\t\t   ~BIT_MASK_R_MU_TABLE_VALID;\n\n\trtw_write8(rtwdev, REG_MU_TX_CTL,\n\t\t   (mu_valid | BIT(0) | BIT(1)) & ~(BIT(7)));\n\n\tmu_tbl_sel = rtw_read8(rtwdev, REG_MU_TX_CTL + 1) & 0xF8;\n\n\trtw_write8(rtwdev, REG_MU_TX_CTL + 1, mu_tbl_sel);\n\trtw_write32(rtwdev, REG_MU_STA_GID_VLD, param->given_gid_tab[0]);\n\trtw_write32(rtwdev, REG_MU_STA_USER_POS_INFO, param->given_user_pos[0]);\n\trtw_write32(rtwdev, REG_MU_STA_USER_POS_INFO + 4,\n\t\t    param->given_user_pos[1]);\n\n\trtw_write8(rtwdev, REG_MU_TX_CTL + 1, mu_tbl_sel | 1);\n\trtw_write32(rtwdev, REG_MU_STA_GID_VLD, param->given_gid_tab[1]);\n\trtw_write32(rtwdev, REG_MU_STA_USER_POS_INFO, param->given_user_pos[2]);\n\trtw_write32(rtwdev, REG_MU_STA_USER_POS_INFO + 4,\n\t\t    param->given_user_pos[3]);\n}\n\nvoid rtw_bf_del_bfer_entry_mu(struct rtw_dev *rtwdev)\n{\n\trtw_write32(rtwdev, REG_ASSOCIATED_BFMER0_INFO, 0);\n\trtw_write32(rtwdev, REG_ASSOCIATED_BFMER0_INFO + 4, 0);\n\trtw_write16(rtwdev, REG_WMAC_MU_BF_CTL, 0);\n\trtw_write8(rtwdev, REG_MU_TX_CTL, 0);\n}\n\nvoid rtw_bf_del_sounding(struct rtw_dev *rtwdev)\n{\n\trtw_write8_mask(rtwdev, REG_SND_PTCL_CTRL, BIT_MASK_BEAMFORM, 0);\n}\n\nvoid rtw_bf_enable_bfee_su(struct rtw_dev *rtwdev, struct rtw_vif *vif,\n\t\t\t   struct rtw_bfee *bfee)\n{\n\tu8 nc_index = hweight8(rtwdev->hal.antenna_rx) - 1;\n\tu8 nr_index = bfee->sound_dim;\n\tu8 grouping = 0, codebookinfo = 1, coefficientsize = 3;\n\tu32 addr_bfer_info, addr_csi_rpt, csi_param;\n\tu8 i;\n\n\trtw_dbg(rtwdev, RTW_DBG_BF, \"config as an su bfee\\n\");\n\n\tswitch (bfee->su_reg_index) {\n\tcase 1:\n\t\taddr_bfer_info = REG_ASSOCIATED_BFMER1_INFO;\n\t\taddr_csi_rpt = REG_TX_CSI_RPT_PARAM_BW20 + 2;\n\t\tbreak;\n\tcase 0:\n\tdefault:\n\t\taddr_bfer_info = REG_ASSOCIATED_BFMER0_INFO;\n\t\taddr_csi_rpt = REG_TX_CSI_RPT_PARAM_BW20;\n\t\tbreak;\n\t}\n\n\t \n\trtw_write8_mask(rtwdev, REG_SND_PTCL_CTRL, BIT_MASK_BEAMFORM,\n\t\t\tRTW_SND_CTRL_SOUNDING);\n\n\t \n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\trtw_write8(rtwdev, addr_bfer_info + i, bfee->mac_addr[i]);\n\n\tcsi_param = (u16)((coefficientsize << 10) |\n\t\t\t  (codebookinfo << 8) |\n\t\t\t  (grouping << 6) |\n\t\t\t  (nr_index << 3) |\n\t\t\t  nc_index);\n\trtw_write16(rtwdev, addr_csi_rpt, csi_param);\n\n\t \n\trtw_write8(rtwdev, REG_SND_PTCL_CTRL + 3, RTW_NDP_RX_STANDBY_TIME);\n}\nEXPORT_SYMBOL(rtw_bf_enable_bfee_su);\n\n \nvoid rtw_bf_enable_bfee_mu(struct rtw_dev *rtwdev, struct rtw_vif *vif,\n\t\t\t   struct rtw_bfee *bfee)\n{\n\tstruct rtw_bf_info *bf_info = &rtwdev->bf_info;\n\tstruct mu_bfer_init_para param;\n\tu8 nc_index = hweight8(rtwdev->hal.antenna_rx) - 1;\n\tu8 nr_index = 1;\n\tu8 grouping = 0, codebookinfo = 1, coefficientsize = 0;\n\tu32 csi_param;\n\n\trtw_dbg(rtwdev, RTW_DBG_BF, \"config as an mu bfee\\n\");\n\n\tcsi_param = (u16)((coefficientsize << 10) |\n\t\t\t  (codebookinfo << 8) |\n\t\t\t  (grouping << 6) |\n\t\t\t  (nr_index << 3) |\n\t\t\t  nc_index);\n\n\trtw_dbg(rtwdev, RTW_DBG_BF, \"nc=%d nr=%d group=%d codebookinfo=%d coefficientsize=%d\\n\",\n\t\tnc_index, nr_index, grouping, codebookinfo,\n\t\tcoefficientsize);\n\n\tparam.paid = bfee->p_aid;\n\tparam.csi_para = csi_param;\n\tparam.my_aid = bfee->aid & 0xfff;\n\tparam.csi_length_sel = HAL_CSI_SEG_4K;\n\tether_addr_copy(param.bfer_address, bfee->mac_addr);\n\n\trtw_bf_init_bfer_entry_mu(rtwdev, &param);\n\n\tbf_info->cur_csi_rpt_rate = DESC_RATE6M;\n\trtw_bf_cfg_sounding(rtwdev, vif, DESC_RATE6M);\n\n\t \n\trtw_write16_set(rtwdev, REG_RXFLTMAP0, BIT_RXFLTMAP0_ACTIONNOACK);\n\n\t \n\trtw_write16_set(rtwdev, REG_RXFLTMAP1, BIT_RXFLTMAP1_BF);\n}\nEXPORT_SYMBOL(rtw_bf_enable_bfee_mu);\n\nvoid rtw_bf_remove_bfee_su(struct rtw_dev *rtwdev,\n\t\t\t   struct rtw_bfee *bfee)\n{\n\tstruct rtw_bf_info *bfinfo = &rtwdev->bf_info;\n\n\trtw_dbg(rtwdev, RTW_DBG_BF, \"remove as a su bfee\\n\");\n\trtw_write8_mask(rtwdev, REG_SND_PTCL_CTRL, BIT_MASK_BEAMFORM,\n\t\t\tRTW_SND_CTRL_REMOVE);\n\n\tswitch (bfee->su_reg_index) {\n\tcase 0:\n\t\trtw_write32(rtwdev, REG_ASSOCIATED_BFMER0_INFO, 0);\n\t\trtw_write16(rtwdev, REG_ASSOCIATED_BFMER0_INFO + 4, 0);\n\t\trtw_write16(rtwdev, REG_TX_CSI_RPT_PARAM_BW20, 0);\n\t\tbreak;\n\tcase 1:\n\t\trtw_write32(rtwdev, REG_ASSOCIATED_BFMER1_INFO, 0);\n\t\trtw_write16(rtwdev, REG_ASSOCIATED_BFMER1_INFO + 4, 0);\n\t\trtw_write16(rtwdev, REG_TX_CSI_RPT_PARAM_BW20 + 2, 0);\n\t\tbreak;\n\t}\n\n\tclear_bit(bfee->su_reg_index, bfinfo->bfer_su_reg_maping);\n\tbfee->su_reg_index = 0xFF;\n}\nEXPORT_SYMBOL(rtw_bf_remove_bfee_su);\n\nvoid rtw_bf_remove_bfee_mu(struct rtw_dev *rtwdev,\n\t\t\t   struct rtw_bfee *bfee)\n{\n\tstruct rtw_bf_info *bfinfo = &rtwdev->bf_info;\n\n\trtw_write8_mask(rtwdev, REG_SND_PTCL_CTRL, BIT_MASK_BEAMFORM,\n\t\t\tRTW_SND_CTRL_REMOVE);\n\n\trtw_bf_del_bfer_entry_mu(rtwdev);\n\n\tif (bfinfo->bfer_su_cnt == 0 && bfinfo->bfer_mu_cnt == 0)\n\t\trtw_bf_del_sounding(rtwdev);\n}\nEXPORT_SYMBOL(rtw_bf_remove_bfee_mu);\n\nvoid rtw_bf_set_gid_table(struct rtw_dev *rtwdev, struct ieee80211_vif *vif,\n\t\t\t  struct ieee80211_bss_conf *conf)\n{\n\tstruct rtw_vif *rtwvif = (struct rtw_vif *)vif->drv_priv;\n\tstruct rtw_bfee *bfee = &rtwvif->bfee;\n\tstruct cfg_mumimo_para param;\n\n\tif (bfee->role != RTW_BFEE_MU) {\n\t\trtw_dbg(rtwdev, RTW_DBG_BF, \"this vif is not mu bfee\\n\");\n\t\treturn;\n\t}\n\n\tparam.grouping_bitmap = 0;\n\tparam.mu_tx_en = 0;\n\tmemset(param.sounding_sts, 0, 6);\n\tmemcpy(param.given_gid_tab, conf->mu_group.membership, 8);\n\tmemcpy(param.given_user_pos, conf->mu_group.position, 16);\n\trtw_dbg(rtwdev, RTW_DBG_BF, \"STA0: gid_valid=0x%x, user_position_l=0x%x, user_position_h=0x%x\\n\",\n\t\tparam.given_gid_tab[0], param.given_user_pos[0],\n\t\tparam.given_user_pos[1]);\n\n\trtw_dbg(rtwdev, RTW_DBG_BF, \"STA1: gid_valid=0x%x, user_position_l=0x%x, user_position_h=0x%x\\n\",\n\t\tparam.given_gid_tab[1], param.given_user_pos[2],\n\t\tparam.given_user_pos[3]);\n\n\trtw_bf_cfg_mu_bfee(rtwdev, &param);\n}\nEXPORT_SYMBOL(rtw_bf_set_gid_table);\n\nvoid rtw_bf_phy_init(struct rtw_dev *rtwdev)\n{\n\tu8 tmp8;\n\tu32 tmp32;\n\tu8 retry_limit = 0xA;\n\tu8 ndpa_rate = 0x10;\n\tu8 ack_policy = 3;\n\n\ttmp32 = rtw_read32(rtwdev, REG_MU_TX_CTL);\n\t \n\ttmp32 |= BIT_MU_P1_WAIT_STATE_EN;\n\t \n\ttmp32 &= ~BIT_MASK_R_MU_RL;\n\ttmp32 |= (retry_limit << BIT_SHIFT_R_MU_RL) & BIT_MASK_R_MU_RL;\n\t \n\ttmp32 &= ~BIT_EN_MU_MIMO;\n\t \n\ttmp32 &= ~BIT_MASK_R_MU_TABLE_VALID;\n\trtw_write32(rtwdev, REG_MU_TX_CTL, tmp32);\n\n\t \n\ttmp8 = ack_policy << BIT_SHIFT_WMAC_TXMU_ACKPOLICY;\n\ttmp8 |= BIT_WMAC_TXMU_ACKPOLICY_EN;\n\trtw_write8(rtwdev, REG_WMAC_MU_BF_OPTION, tmp8);\n\n\t \n\trtw_write16(rtwdev, REG_WMAC_MU_BF_CTL, 0);\n\t \n\trtw_write32_set(rtwdev, REG_TXBF_CTRL, BIT_USE_NDPA_PARAMETER);\n\t \n\trtw_write8(rtwdev, REG_NDPA_OPT_CTRL, ndpa_rate);\n\n\trtw_write32_mask(rtwdev, REG_BBPSF_CTRL, BIT_MASK_CSI_RATE,\n\t\t\t DESC_RATE6M);\n}\nEXPORT_SYMBOL(rtw_bf_phy_init);\n\nvoid rtw_bf_cfg_csi_rate(struct rtw_dev *rtwdev, u8 rssi, u8 cur_rate,\n\t\t\t u8 fixrate_en, u8 *new_rate)\n{\n\tu32 csi_cfg;\n\tu16 cur_rrsr;\n\n\tcsi_cfg = rtw_read32(rtwdev, REG_BBPSF_CTRL) & ~BIT_MASK_CSI_RATE;\n\tcur_rrsr = rtw_read16(rtwdev, REG_RRSR);\n\n\tif (rssi >= 40) {\n\t\tif (cur_rate != DESC_RATE54M) {\n\t\t\tcur_rrsr |= BIT(DESC_RATE54M);\n\t\t\tcsi_cfg |= (DESC_RATE54M & BIT_MASK_CSI_RATE_VAL) <<\n\t\t\t\t   BIT_SHIFT_CSI_RATE;\n\t\t\trtw_write16(rtwdev, REG_RRSR, cur_rrsr);\n\t\t\trtw_write32(rtwdev, REG_BBPSF_CTRL, csi_cfg);\n\t\t}\n\t\t*new_rate = DESC_RATE54M;\n\t} else {\n\t\tif (cur_rate != DESC_RATE24M) {\n\t\t\tcur_rrsr &= ~BIT(DESC_RATE54M);\n\t\t\tcsi_cfg |= (DESC_RATE54M & BIT_MASK_CSI_RATE_VAL) <<\n\t\t\t\t   BIT_SHIFT_CSI_RATE;\n\t\t\trtw_write16(rtwdev, REG_RRSR, cur_rrsr);\n\t\t\trtw_write32(rtwdev, REG_BBPSF_CTRL, csi_cfg);\n\t\t}\n\t\t*new_rate = DESC_RATE24M;\n\t}\n}\nEXPORT_SYMBOL(rtw_bf_cfg_csi_rate);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}