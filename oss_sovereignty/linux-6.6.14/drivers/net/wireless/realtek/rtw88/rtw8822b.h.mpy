{
  "module_name": "rtw8822b.h",
  "hash_id": "f82b06eb420c1e5e5cafb08151fb449f1dd40ff01372cd58fa3a2513419d1236",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtw88/rtw8822b.h",
  "human_readable_source": " \n \n\n#ifndef __RTW8822B_H__\n#define __RTW8822B_H__\n\n#include <asm/byteorder.h>\n\n#define RCR_VHT_ACK\t\tBIT(26)\n\nstruct rtw8822bu_efuse {\n\tu8 res4[4];\t\t\t \n\tu8 usb_optional_function;\n\tu8 res5[0x1e];\n\tu8 res6[2];\n\tu8 serial[0x0b];\t\t \n\tu8 vid;\t\t\t\t \n\tu8 res7;\n\tu8 pid;\n\tu8 res8[4];\n\tu8 mac_addr[ETH_ALEN];\t\t \n\tu8 res9[2];\n\tu8 vendor_name[0x07];\n\tu8 res10[2];\n\tu8 device_name[0x14];\n\tu8 res11[0xcf];\n\tu8 package_type;\t\t \n\tu8 res12[0x4];\n};\n\nstruct rtw8822be_efuse {\n\tu8 mac_addr[ETH_ALEN];\t\t \n\tu8 vender_id[2];\n\tu8 device_id[2];\n\tu8 sub_vender_id[2];\n\tu8 sub_device_id[2];\n\tu8 pmc[2];\n\tu8 exp_device_cap[2];\n\tu8 msi_cap;\n\tu8 ltr_cap;\t\t\t \n\tu8 exp_link_control[2];\n\tu8 link_cap[4];\n\tu8 link_control[2];\n\tu8 serial_number[8];\n\tu8 res0:2;\t\t\t \n\tu8 ltr_en:1;\n\tu8 res1:2;\n\tu8 obff:2;\n\tu8 res2:3;\n\tu8 obff_cap:2;\n\tu8 res3:4;\n\tu8 res4[3];\n\tu8 class_code[3];\n\tu8 pci_pm_L1_2_supp:1;\n\tu8 pci_pm_L1_1_supp:1;\n\tu8 aspm_pm_L1_2_supp:1;\n\tu8 aspm_pm_L1_1_supp:1;\n\tu8 L1_pm_substates_supp:1;\n\tu8 res5:3;\n\tu8 port_common_mode_restore_time;\n\tu8 port_t_power_on_scale:2;\n\tu8 res6:1;\n\tu8 port_t_power_on_value:5;\n\tu8 res7;\n};\n\nstruct rtw8822bs_efuse {\n\tu8 res4[0x4a];\t\t\t \n\tu8 mac_addr[ETH_ALEN];\t\t \n} __packed;\n\nstruct rtw8822b_efuse {\n\t__le16 rtl_id;\n\tu8 res0[0x0e];\n\n\t \n\tstruct rtw_txpwr_idx txpwr_idx_table[4];\n\n\tu8 channel_plan;\t\t \n\tu8 xtal_k;\n\tu8 thermal_meter;\n\tu8 iqk_lck;\n\tu8 pa_type;\t\t\t \n\tu8 lna_type_2g[2];\t\t \n\tu8 lna_type_5g[2];\n\tu8 rf_board_option;\n\tu8 rf_feature_option;\n\tu8 rf_bt_setting;\n\tu8 eeprom_version;\n\tu8 eeprom_customer_id;\n\tu8 tx_bb_swing_setting_2g;\n\tu8 tx_bb_swing_setting_5g;\n\tu8 tx_pwr_calibrate_rate;\n\tu8 rf_antenna_option;\t\t \n\tu8 rfe_option;\n\tu8 country_code[2];\n\tu8 res[3];\n\tunion {\n\t\tstruct rtw8822be_efuse e;\n\t\tstruct rtw8822bu_efuse u;\n\t\tstruct rtw8822bs_efuse s;\n\t};\n};\n\nstatic inline void\n_rtw_write32s_mask(struct rtw_dev *rtwdev, u32 addr, u32 mask, u32 data)\n{\n\t \n\trtw_write32_mask(rtwdev, addr, mask, data);\n\trtw_write32_mask(rtwdev, addr + 0x200, mask, data);\n}\n\n#define rtw_write32s_mask(rtwdev, addr, mask, data)\t\t\t       \\\n\tdo {\t\t\t\t\t\t\t\t       \\\n\t\tBUILD_BUG_ON((addr) < 0xC00 || (addr) >= 0xD00);\t       \\\n\t\t\t\t\t\t\t\t\t       \\\n\t\t_rtw_write32s_mask(rtwdev, addr, mask, data);\t\t       \\\n\t} while (0)\n\n \n#define GET_PHY_STAT_P0_PWDB(phy_stat)                                         \\\n\tle32_get_bits(*((__le32 *)(phy_stat) + 0x00), GENMASK(15, 8))\n\n \n#define GET_PHY_STAT_P1_PWDB_A(phy_stat)                                       \\\n\tle32_get_bits(*((__le32 *)(phy_stat) + 0x00), GENMASK(15, 8))\n#define GET_PHY_STAT_P1_PWDB_B(phy_stat)                                       \\\n\tle32_get_bits(*((__le32 *)(phy_stat) + 0x00), GENMASK(23, 16))\n#define GET_PHY_STAT_P1_RF_MODE(phy_stat)                                      \\\n\tle32_get_bits(*((__le32 *)(phy_stat) + 0x03), GENMASK(29, 28))\n#define GET_PHY_STAT_P1_L_RXSC(phy_stat)                                       \\\n\tle32_get_bits(*((__le32 *)(phy_stat) + 0x01), GENMASK(11, 8))\n#define GET_PHY_STAT_P1_HT_RXSC(phy_stat)                                      \\\n\tle32_get_bits(*((__le32 *)(phy_stat) + 0x01), GENMASK(15, 12))\n#define GET_PHY_STAT_P1_RXEVM_A(phy_stat)                                      \\\n\tle32_get_bits(*((__le32 *)(phy_stat) + 0x04), GENMASK(7, 0))\n#define GET_PHY_STAT_P1_RXEVM_B(phy_stat)                                      \\\n\tle32_get_bits(*((__le32 *)(phy_stat) + 0x04), GENMASK(15, 8))\n#define GET_PHY_STAT_P1_CFO_TAIL_A(phy_stat)                                 \\\n\tle32_get_bits(*((__le32 *)(phy_stat) + 0x05), GENMASK(7, 0))\n#define GET_PHY_STAT_P1_CFO_TAIL_B(phy_stat)                                 \\\n\tle32_get_bits(*((__le32 *)(phy_stat) + 0x05), GENMASK(15, 8))\n#define GET_PHY_STAT_P1_RXSNR_A(phy_stat)                                      \\\n\tle32_get_bits(*((__le32 *)(phy_stat) + 0x06), GENMASK(7, 0))\n#define GET_PHY_STAT_P1_RXSNR_B(phy_stat)                                      \\\n\tle32_get_bits(*((__le32 *)(phy_stat) + 0x06), GENMASK(15, 8))\n\n#define RTW8822B_EDCCA_MAX\t0x7f\n#define RTW8822B_EDCCA_SRC_DEF\t1\n#define REG_HTSTFWT\t0x800\n#define REG_RXPSEL\t0x808\n#define BIT_RX_PSEL_RST\t\t(BIT(28) | BIT(29))\n#define REG_TXPSEL\t0x80c\n#define REG_RXCCAMSK\t0x814\n#define REG_CCASEL\t0x82c\n#define REG_PDMFTH\t0x830\n#define REG_CCA2ND\t0x838\n#define REG_L1WT\t0x83c\n#define REG_L1PKWT\t0x840\n#define REG_MRC\t\t0x850\n#define REG_CLKTRK\t0x860\n#define REG_EDCCA_POW_MA\t0x8a0\n#define BIT_MA_LEVEL\tGENMASK(1, 0)\n#define REG_ADCCLK\t0x8ac\n#define REG_ADC160\t0x8c4\n#define REG_ADC40\t0x8c8\n#define REG_EDCCA_DECISION\t0x8dc\n#define BIT_EDCCA_OPTION\tBIT(5)\n#define REG_CDDTXP\t0x93c\n#define REG_TXPSEL1\t0x940\n#define REG_EDCCA_SOURCE\t0x944\n#define BIT_SOURCE_OPTION\tGENMASK(29, 28)\n#define REG_ACBB0\t0x948\n#define REG_ACBBRXFIR\t0x94c\n#define REG_ACGG2TBL\t0x958\n#define REG_RXSB\t0xa00\n#define REG_ADCINI\t0xa04\n#define REG_TXSF2\t0xa24\n#define REG_TXSF6\t0xa28\n#define REG_RXDESC\t0xa2c\n#define REG_ENTXCCK\t0xa80\n#define REG_AGCTR_A\t0xc08\n#define REG_TXDFIR\t0xc20\n#define REG_RXIGI_A\t0xc50\n#define REG_TRSW\t0xca0\n#define REG_RFESEL0\t0xcb0\n#define REG_RFESEL8\t0xcb4\n#define REG_RFECTL\t0xcb8\n#define REG_RFEINV\t0xcbc\n#define REG_AGCTR_B\t0xe08\n#define REG_RXIGI_B\t0xe50\n#define REG_ANTWT\t0x1904\n#define REG_IQKFAILMSK\t0x1bf0\n\nextern const struct rtw_chip_info rtw8822b_hw_spec;\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}