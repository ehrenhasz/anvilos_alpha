{
  "module_name": "efuse.c",
  "hash_id": "16661f3c1b4e93b3ec75b8a2b5470aa310073e96eccc128f85224ad8b8911e0f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtw88/efuse.c",
  "human_readable_source": "\n \n\n#include <linux/iopoll.h>\n\n#include \"main.h\"\n#include \"efuse.h\"\n#include \"reg.h\"\n#include \"debug.h\"\n\n#define RTW_EFUSE_BANK_WIFI\t\t0x0\n\nstatic void switch_efuse_bank(struct rtw_dev *rtwdev)\n{\n\trtw_write32_mask(rtwdev, REG_LDO_EFUSE_CTRL, BIT_MASK_EFUSE_BANK_SEL,\n\t\t\t RTW_EFUSE_BANK_WIFI);\n}\n\n#define invalid_efuse_header(hdr1, hdr2) \\\n\t((hdr1) == 0xff || (((hdr1) & 0x1f) == 0xf && (hdr2) == 0xff))\n#define invalid_efuse_content(word_en, i) \\\n\t(((word_en) & BIT(i)) != 0x0)\n#define get_efuse_blk_idx_2_byte(hdr1, hdr2) \\\n\t((((hdr2) & 0xf0) >> 1) | (((hdr1) >> 5) & 0x07))\n#define get_efuse_blk_idx_1_byte(hdr1) \\\n\t(((hdr1) & 0xf0) >> 4)\n#define block_idx_to_logical_idx(blk_idx, i) \\\n\t(((blk_idx) << 3) + ((i) << 1))\n\n \nstatic int rtw_dump_logical_efuse_map(struct rtw_dev *rtwdev, u8 *phy_map,\n\t\t\t\t      u8 *log_map)\n{\n\tu32 physical_size = rtwdev->efuse.physical_size;\n\tu32 protect_size = rtwdev->efuse.protect_size;\n\tu32 logical_size = rtwdev->efuse.logical_size;\n\tu32 phy_idx, log_idx;\n\tu8 hdr1, hdr2;\n\tu8 blk_idx;\n\tu8 word_en;\n\tint i;\n\n\tfor (phy_idx = 0; phy_idx < physical_size - protect_size;) {\n\t\thdr1 = phy_map[phy_idx];\n\t\thdr2 = phy_map[phy_idx + 1];\n\t\tif (invalid_efuse_header(hdr1, hdr2))\n\t\t\tbreak;\n\n\t\tif ((hdr1 & 0x1f) == 0xf) {\n\t\t\t \n\t\t\tblk_idx = get_efuse_blk_idx_2_byte(hdr1, hdr2);\n\t\t\tword_en = hdr2 & 0xf;\n\t\t\tphy_idx += 2;\n\t\t} else {\n\t\t\t \n\t\t\tblk_idx = get_efuse_blk_idx_1_byte(hdr1);\n\t\t\tword_en = hdr1 & 0xf;\n\t\t\tphy_idx += 1;\n\t\t}\n\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tif (invalid_efuse_content(word_en, i))\n\t\t\t\tcontinue;\n\n\t\t\tlog_idx = block_idx_to_logical_idx(blk_idx, i);\n\t\t\tif (phy_idx + 1 > physical_size - protect_size ||\n\t\t\t    log_idx + 1 > logical_size)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tlog_map[log_idx] = phy_map[phy_idx];\n\t\t\tlog_map[log_idx + 1] = phy_map[phy_idx + 1];\n\t\t\tphy_idx += 2;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int rtw_dump_physical_efuse_map(struct rtw_dev *rtwdev, u8 *map)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tu32 size = rtwdev->efuse.physical_size;\n\tu32 efuse_ctl;\n\tu32 addr;\n\tu32 cnt;\n\n\trtw_chip_efuse_grant_on(rtwdev);\n\n\tswitch_efuse_bank(rtwdev);\n\n\t \n\tchip->ops->cfg_ldo25(rtwdev, false);\n\n\tefuse_ctl = rtw_read32(rtwdev, REG_EFUSE_CTRL);\n\n\tfor (addr = 0; addr < size; addr++) {\n\t\tefuse_ctl &= ~(BIT_MASK_EF_DATA | BITS_EF_ADDR);\n\t\tefuse_ctl |= (addr & BIT_MASK_EF_ADDR) << BIT_SHIFT_EF_ADDR;\n\t\trtw_write32(rtwdev, REG_EFUSE_CTRL, efuse_ctl & (~BIT_EF_FLAG));\n\n\t\tcnt = 1000000;\n\t\tdo {\n\t\t\tudelay(1);\n\t\t\tefuse_ctl = rtw_read32(rtwdev, REG_EFUSE_CTRL);\n\t\t\tif (--cnt == 0)\n\t\t\t\treturn -EBUSY;\n\t\t} while (!(efuse_ctl & BIT_EF_FLAG));\n\n\t\t*(map + addr) = (u8)(efuse_ctl & BIT_MASK_EF_DATA);\n\t}\n\n\trtw_chip_efuse_grant_off(rtwdev);\n\n\treturn 0;\n}\n\nint rtw_read8_physical_efuse(struct rtw_dev *rtwdev, u16 addr, u8 *data)\n{\n\tu32 efuse_ctl;\n\tint ret;\n\n\trtw_write32_mask(rtwdev, REG_EFUSE_CTRL, 0x3ff00, addr);\n\trtw_write32_clr(rtwdev, REG_EFUSE_CTRL, BIT_EF_FLAG);\n\n\tret = read_poll_timeout(rtw_read32, efuse_ctl, efuse_ctl & BIT_EF_FLAG,\n\t\t\t\t1000, 100000, false, rtwdev, REG_EFUSE_CTRL);\n\tif (ret) {\n\t\t*data = EFUSE_READ_FAIL;\n\t\treturn ret;\n\t}\n\n\t*data = rtw_read8(rtwdev, REG_EFUSE_CTRL);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rtw_read8_physical_efuse);\n\nint rtw_parse_efuse_map(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\tu32 phy_size = efuse->physical_size;\n\tu32 log_size = efuse->logical_size;\n\tu8 *phy_map = NULL;\n\tu8 *log_map = NULL;\n\tint ret = 0;\n\n\tphy_map = kmalloc(phy_size, GFP_KERNEL);\n\tlog_map = kmalloc(log_size, GFP_KERNEL);\n\tif (!phy_map || !log_map) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\tret = rtw_dump_physical_efuse_map(rtwdev, phy_map);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to dump efuse physical map\\n\");\n\t\tgoto out_free;\n\t}\n\n\tmemset(log_map, 0xff, log_size);\n\tret = rtw_dump_logical_efuse_map(rtwdev, phy_map, log_map);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to dump efuse logical map\\n\");\n\t\tgoto out_free;\n\t}\n\n\tret = chip->ops->read_efuse(rtwdev, log_map);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to read efuse map\\n\");\n\t\tgoto out_free;\n\t}\n\nout_free:\n\tkfree(log_map);\n\tkfree(phy_map);\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}