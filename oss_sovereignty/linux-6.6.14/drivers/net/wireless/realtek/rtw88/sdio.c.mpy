{
  "module_name": "sdio.c",
  "hash_id": "afe24d95bc61f637619aff2b31e535981a13e5bd1c8652e6da9695f40165d8cc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtw88/sdio.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/mmc/host.h>\n#include <linux/mmc/sdio_func.h>\n#include \"main.h\"\n#include \"debug.h\"\n#include \"fw.h\"\n#include \"ps.h\"\n#include \"reg.h\"\n#include \"rx.h\"\n#include \"sdio.h\"\n#include \"tx.h\"\n\n#define RTW_SDIO_INDIRECT_RW_RETRIES\t\t\t50\n\nstatic bool rtw_sdio_is_bus_addr(u32 addr)\n{\n\treturn !!(addr & RTW_SDIO_BUS_MSK);\n}\n\nstatic bool rtw_sdio_bus_claim_needed(struct rtw_sdio *rtwsdio)\n{\n\treturn !rtwsdio->irq_thread ||\n\t       rtwsdio->irq_thread != current;\n}\n\nstatic u32 rtw_sdio_to_bus_offset(struct rtw_dev *rtwdev, u32 addr)\n{\n\tswitch (addr & RTW_SDIO_BUS_MSK) {\n\tcase WLAN_IOREG_OFFSET:\n\t\taddr &= WLAN_IOREG_REG_MSK;\n\t\taddr |= FIELD_PREP(REG_SDIO_CMD_ADDR_MSK,\n\t\t\t\t   REG_SDIO_CMD_ADDR_MAC_REG);\n\t\tbreak;\n\tcase SDIO_LOCAL_OFFSET:\n\t\taddr &= SDIO_LOCAL_REG_MSK;\n\t\taddr |= FIELD_PREP(REG_SDIO_CMD_ADDR_MSK,\n\t\t\t\t   REG_SDIO_CMD_ADDR_SDIO_REG);\n\t\tbreak;\n\tdefault:\n\t\trtw_warn(rtwdev, \"Cannot convert addr 0x%08x to bus offset\",\n\t\t\t addr);\n\t}\n\n\treturn addr;\n}\n\nstatic bool rtw_sdio_use_memcpy_io(struct rtw_dev *rtwdev, u32 addr,\n\t\t\t\t   u8 alignment)\n{\n\treturn IS_ALIGNED(addr, alignment) &&\n\t       test_bit(RTW_FLAG_POWERON, rtwdev->flags);\n}\n\nstatic void rtw_sdio_writel(struct rtw_dev *rtwdev, u32 val, u32 addr,\n\t\t\t    int *err_ret)\n{\n\tstruct rtw_sdio *rtwsdio = (struct rtw_sdio *)rtwdev->priv;\n\tu8 buf[4];\n\tint i;\n\n\tif (rtw_sdio_use_memcpy_io(rtwdev, addr, 4)) {\n\t\tsdio_writel(rtwsdio->sdio_func, val, addr, err_ret);\n\t\treturn;\n\t}\n\n\t*(__le32 *)buf = cpu_to_le32(val);\n\n\tfor (i = 0; i < 4; i++) {\n\t\tsdio_writeb(rtwsdio->sdio_func, buf[i], addr + i, err_ret);\n\t\tif (*err_ret)\n\t\t\treturn;\n\t}\n}\n\nstatic void rtw_sdio_writew(struct rtw_dev *rtwdev, u16 val, u32 addr,\n\t\t\t    int *err_ret)\n{\n\tstruct rtw_sdio *rtwsdio = (struct rtw_sdio *)rtwdev->priv;\n\tu8 buf[2];\n\tint i;\n\n\t*(__le16 *)buf = cpu_to_le16(val);\n\n\tfor (i = 0; i < 2; i++) {\n\t\tsdio_writeb(rtwsdio->sdio_func, buf[i], addr + i, err_ret);\n\t\tif (*err_ret)\n\t\t\treturn;\n\t}\n}\n\nstatic u32 rtw_sdio_readl(struct rtw_dev *rtwdev, u32 addr, int *err_ret)\n{\n\tstruct rtw_sdio *rtwsdio = (struct rtw_sdio *)rtwdev->priv;\n\tu8 buf[4];\n\tint i;\n\n\tif (rtw_sdio_use_memcpy_io(rtwdev, addr, 4))\n\t\treturn sdio_readl(rtwsdio->sdio_func, addr, err_ret);\n\n\tfor (i = 0; i < 4; i++) {\n\t\tbuf[i] = sdio_readb(rtwsdio->sdio_func, addr + i, err_ret);\n\t\tif (*err_ret)\n\t\t\treturn 0;\n\t}\n\n\treturn le32_to_cpu(*(__le32 *)buf);\n}\n\nstatic u16 rtw_sdio_readw(struct rtw_dev *rtwdev, u32 addr, int *err_ret)\n{\n\tstruct rtw_sdio *rtwsdio = (struct rtw_sdio *)rtwdev->priv;\n\tu8 buf[2];\n\tint i;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tbuf[i] = sdio_readb(rtwsdio->sdio_func, addr + i, err_ret);\n\t\tif (*err_ret)\n\t\t\treturn 0;\n\t}\n\n\treturn le16_to_cpu(*(__le16 *)buf);\n}\n\nstatic u32 rtw_sdio_to_io_address(struct rtw_dev *rtwdev, u32 addr,\n\t\t\t\t  bool direct)\n{\n\tif (!direct)\n\t\treturn addr;\n\n\tif (!rtw_sdio_is_bus_addr(addr))\n\t\taddr |= WLAN_IOREG_OFFSET;\n\n\treturn rtw_sdio_to_bus_offset(rtwdev, addr);\n}\n\nstatic bool rtw_sdio_use_direct_io(struct rtw_dev *rtwdev, u32 addr)\n{\n\treturn !rtw_sdio_is_sdio30_supported(rtwdev) ||\n\t\trtw_sdio_is_bus_addr(addr);\n}\n\nstatic int rtw_sdio_indirect_reg_cfg(struct rtw_dev *rtwdev, u32 addr, u32 cfg)\n{\n\tstruct rtw_sdio *rtwsdio = (struct rtw_sdio *)rtwdev->priv;\n\tunsigned int retry;\n\tu32 reg_cfg;\n\tint ret;\n\tu8 tmp;\n\n\treg_cfg = rtw_sdio_to_bus_offset(rtwdev, REG_SDIO_INDIRECT_REG_CFG);\n\n\trtw_sdio_writel(rtwdev, addr | cfg | BIT_SDIO_INDIRECT_REG_CFG_UNK20,\n\t\t\treg_cfg, &ret);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (retry = 0; retry < RTW_SDIO_INDIRECT_RW_RETRIES; retry++) {\n\t\ttmp = sdio_readb(rtwsdio->sdio_func, reg_cfg + 2, &ret);\n\t\tif (!ret && (tmp & BIT(4)))\n\t\t\treturn 0;\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstatic u8 rtw_sdio_indirect_read8(struct rtw_dev *rtwdev, u32 addr,\n\t\t\t\t  int *err_ret)\n{\n\tstruct rtw_sdio *rtwsdio = (struct rtw_sdio *)rtwdev->priv;\n\tu32 reg_data;\n\n\t*err_ret = rtw_sdio_indirect_reg_cfg(rtwdev, addr,\n\t\t\t\t\t     BIT_SDIO_INDIRECT_REG_CFG_READ);\n\tif (*err_ret)\n\t\treturn 0;\n\n\treg_data = rtw_sdio_to_bus_offset(rtwdev, REG_SDIO_INDIRECT_REG_DATA);\n\treturn sdio_readb(rtwsdio->sdio_func, reg_data, err_ret);\n}\n\nstatic int rtw_sdio_indirect_read_bytes(struct rtw_dev *rtwdev, u32 addr,\n\t\t\t\t\tu8 *buf, int count)\n{\n\tint i, ret = 0;\n\n\tfor (i = 0; i < count; i++) {\n\t\tbuf[i] = rtw_sdio_indirect_read8(rtwdev, addr + i, &ret);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic u16 rtw_sdio_indirect_read16(struct rtw_dev *rtwdev, u32 addr,\n\t\t\t\t    int *err_ret)\n{\n\tu32 reg_data;\n\tu8 buf[2];\n\n\tif (!IS_ALIGNED(addr, 2)) {\n\t\t*err_ret = rtw_sdio_indirect_read_bytes(rtwdev, addr, buf, 2);\n\t\tif (*err_ret)\n\t\t\treturn 0;\n\n\t\treturn le16_to_cpu(*(__le16 *)buf);\n\t}\n\n\t*err_ret = rtw_sdio_indirect_reg_cfg(rtwdev, addr,\n\t\t\t\t\t     BIT_SDIO_INDIRECT_REG_CFG_READ);\n\tif (*err_ret)\n\t\treturn 0;\n\n\treg_data = rtw_sdio_to_bus_offset(rtwdev, REG_SDIO_INDIRECT_REG_DATA);\n\treturn rtw_sdio_readw(rtwdev, reg_data, err_ret);\n}\n\nstatic u32 rtw_sdio_indirect_read32(struct rtw_dev *rtwdev, u32 addr,\n\t\t\t\t    int *err_ret)\n{\n\tu32 reg_data;\n\tu8 buf[4];\n\n\tif (!IS_ALIGNED(addr, 4)) {\n\t\t*err_ret = rtw_sdio_indirect_read_bytes(rtwdev, addr, buf, 4);\n\t\tif (*err_ret)\n\t\t\treturn 0;\n\n\t\treturn le32_to_cpu(*(__le32 *)buf);\n\t}\n\n\t*err_ret = rtw_sdio_indirect_reg_cfg(rtwdev, addr,\n\t\t\t\t\t     BIT_SDIO_INDIRECT_REG_CFG_READ);\n\tif (*err_ret)\n\t\treturn 0;\n\n\treg_data = rtw_sdio_to_bus_offset(rtwdev, REG_SDIO_INDIRECT_REG_DATA);\n\treturn rtw_sdio_readl(rtwdev, reg_data, err_ret);\n}\n\nstatic u8 rtw_sdio_read8(struct rtw_dev *rtwdev, u32 addr)\n{\n\tstruct rtw_sdio *rtwsdio = (struct rtw_sdio *)rtwdev->priv;\n\tbool direct, bus_claim;\n\tint ret;\n\tu8 val;\n\n\tdirect = rtw_sdio_use_direct_io(rtwdev, addr);\n\taddr = rtw_sdio_to_io_address(rtwdev, addr, direct);\n\tbus_claim = rtw_sdio_bus_claim_needed(rtwsdio);\n\n\tif (bus_claim)\n\t\tsdio_claim_host(rtwsdio->sdio_func);\n\n\tif (direct)\n\t\tval = sdio_readb(rtwsdio->sdio_func, addr, &ret);\n\telse\n\t\tval = rtw_sdio_indirect_read8(rtwdev, addr, &ret);\n\n\tif (bus_claim)\n\t\tsdio_release_host(rtwsdio->sdio_func);\n\n\tif (ret)\n\t\trtw_warn(rtwdev, \"sdio read8 failed (0x%x): %d\", addr, ret);\n\n\treturn val;\n}\n\nstatic u16 rtw_sdio_read16(struct rtw_dev *rtwdev, u32 addr)\n{\n\tstruct rtw_sdio *rtwsdio = (struct rtw_sdio *)rtwdev->priv;\n\tbool direct, bus_claim;\n\tint ret;\n\tu16 val;\n\n\tdirect = rtw_sdio_use_direct_io(rtwdev, addr);\n\taddr = rtw_sdio_to_io_address(rtwdev, addr, direct);\n\tbus_claim = rtw_sdio_bus_claim_needed(rtwsdio);\n\n\tif (bus_claim)\n\t\tsdio_claim_host(rtwsdio->sdio_func);\n\n\tif (direct)\n\t\tval = rtw_sdio_readw(rtwdev, addr, &ret);\n\telse\n\t\tval = rtw_sdio_indirect_read16(rtwdev, addr, &ret);\n\n\tif (bus_claim)\n\t\tsdio_release_host(rtwsdio->sdio_func);\n\n\tif (ret)\n\t\trtw_warn(rtwdev, \"sdio read16 failed (0x%x): %d\", addr, ret);\n\n\treturn val;\n}\n\nstatic u32 rtw_sdio_read32(struct rtw_dev *rtwdev, u32 addr)\n{\n\tstruct rtw_sdio *rtwsdio = (struct rtw_sdio *)rtwdev->priv;\n\tbool direct, bus_claim;\n\tu32 val;\n\tint ret;\n\n\tdirect = rtw_sdio_use_direct_io(rtwdev, addr);\n\taddr = rtw_sdio_to_io_address(rtwdev, addr, direct);\n\tbus_claim = rtw_sdio_bus_claim_needed(rtwsdio);\n\n\tif (bus_claim)\n\t\tsdio_claim_host(rtwsdio->sdio_func);\n\n\tif (direct)\n\t\tval = rtw_sdio_readl(rtwdev, addr, &ret);\n\telse\n\t\tval = rtw_sdio_indirect_read32(rtwdev, addr, &ret);\n\n\tif (bus_claim)\n\t\tsdio_release_host(rtwsdio->sdio_func);\n\n\tif (ret)\n\t\trtw_warn(rtwdev, \"sdio read32 failed (0x%x): %d\", addr, ret);\n\n\treturn val;\n}\n\nstatic void rtw_sdio_indirect_write8(struct rtw_dev *rtwdev, u8 val, u32 addr,\n\t\t\t\t     int *err_ret)\n{\n\tstruct rtw_sdio *rtwsdio = (struct rtw_sdio *)rtwdev->priv;\n\tu32 reg_data;\n\n\treg_data = rtw_sdio_to_bus_offset(rtwdev, REG_SDIO_INDIRECT_REG_DATA);\n\tsdio_writeb(rtwsdio->sdio_func, val, reg_data, err_ret);\n\tif (*err_ret)\n\t\treturn;\n\n\t*err_ret = rtw_sdio_indirect_reg_cfg(rtwdev, addr,\n\t\t\t\t\t     BIT_SDIO_INDIRECT_REG_CFG_WRITE);\n}\n\nstatic void rtw_sdio_indirect_write16(struct rtw_dev *rtwdev, u16 val, u32 addr,\n\t\t\t\t      int *err_ret)\n{\n\tu32 reg_data;\n\n\tif (!IS_ALIGNED(addr, 2)) {\n\t\taddr = rtw_sdio_to_io_address(rtwdev, addr, true);\n\t\trtw_sdio_writew(rtwdev, val, addr, err_ret);\n\t\treturn;\n\t}\n\n\treg_data = rtw_sdio_to_bus_offset(rtwdev, REG_SDIO_INDIRECT_REG_DATA);\n\trtw_sdio_writew(rtwdev, val, reg_data, err_ret);\n\tif (*err_ret)\n\t\treturn;\n\n\t*err_ret = rtw_sdio_indirect_reg_cfg(rtwdev, addr,\n\t\t\t\t\t     BIT_SDIO_INDIRECT_REG_CFG_WRITE |\n\t\t\t\t\t     BIT_SDIO_INDIRECT_REG_CFG_WORD);\n}\n\nstatic void rtw_sdio_indirect_write32(struct rtw_dev *rtwdev, u32 val,\n\t\t\t\t      u32 addr, int *err_ret)\n{\n\tu32 reg_data;\n\n\tif (!IS_ALIGNED(addr, 4)) {\n\t\taddr = rtw_sdio_to_io_address(rtwdev, addr, true);\n\t\trtw_sdio_writel(rtwdev, val, addr, err_ret);\n\t\treturn;\n\t}\n\n\treg_data = rtw_sdio_to_bus_offset(rtwdev, REG_SDIO_INDIRECT_REG_DATA);\n\trtw_sdio_writel(rtwdev, val, reg_data, err_ret);\n\n\t*err_ret = rtw_sdio_indirect_reg_cfg(rtwdev, addr,\n\t\t\t\t\t     BIT_SDIO_INDIRECT_REG_CFG_WRITE |\n\t\t\t\t\t     BIT_SDIO_INDIRECT_REG_CFG_DWORD);\n}\n\nstatic void rtw_sdio_write8(struct rtw_dev *rtwdev, u32 addr, u8 val)\n{\n\tstruct rtw_sdio *rtwsdio = (struct rtw_sdio *)rtwdev->priv;\n\tbool direct, bus_claim;\n\tint ret;\n\n\tdirect = rtw_sdio_use_direct_io(rtwdev, addr);\n\taddr = rtw_sdio_to_io_address(rtwdev, addr, direct);\n\tbus_claim = rtw_sdio_bus_claim_needed(rtwsdio);\n\n\tif (bus_claim)\n\t\tsdio_claim_host(rtwsdio->sdio_func);\n\n\tif (direct)\n\t\tsdio_writeb(rtwsdio->sdio_func, val, addr, &ret);\n\telse\n\t\trtw_sdio_indirect_write8(rtwdev, val, addr, &ret);\n\n\tif (bus_claim)\n\t\tsdio_release_host(rtwsdio->sdio_func);\n\n\tif (ret)\n\t\trtw_warn(rtwdev, \"sdio write8 failed (0x%x): %d\", addr, ret);\n}\n\nstatic void rtw_sdio_write16(struct rtw_dev *rtwdev, u32 addr, u16 val)\n{\n\tstruct rtw_sdio *rtwsdio = (struct rtw_sdio *)rtwdev->priv;\n\tbool direct, bus_claim;\n\tint ret;\n\n\tdirect = rtw_sdio_use_direct_io(rtwdev, addr);\n\taddr = rtw_sdio_to_io_address(rtwdev, addr, direct);\n\tbus_claim = rtw_sdio_bus_claim_needed(rtwsdio);\n\n\tif (bus_claim)\n\t\tsdio_claim_host(rtwsdio->sdio_func);\n\n\tif (direct)\n\t\trtw_sdio_writew(rtwdev, val, addr, &ret);\n\telse\n\t\trtw_sdio_indirect_write16(rtwdev, val, addr, &ret);\n\n\tif (bus_claim)\n\t\tsdio_release_host(rtwsdio->sdio_func);\n\n\tif (ret)\n\t\trtw_warn(rtwdev, \"sdio write16 failed (0x%x): %d\", addr, ret);\n}\n\nstatic void rtw_sdio_write32(struct rtw_dev *rtwdev, u32 addr, u32 val)\n{\n\tstruct rtw_sdio *rtwsdio = (struct rtw_sdio *)rtwdev->priv;\n\tbool direct, bus_claim;\n\tint ret;\n\n\tdirect = rtw_sdio_use_direct_io(rtwdev, addr);\n\taddr = rtw_sdio_to_io_address(rtwdev, addr, direct);\n\tbus_claim = rtw_sdio_bus_claim_needed(rtwsdio);\n\n\tif (bus_claim)\n\t\tsdio_claim_host(rtwsdio->sdio_func);\n\n\tif (direct)\n\t\trtw_sdio_writel(rtwdev, val, addr, &ret);\n\telse\n\t\trtw_sdio_indirect_write32(rtwdev, val, addr, &ret);\n\n\tif (bus_claim)\n\t\tsdio_release_host(rtwsdio->sdio_func);\n\n\tif (ret)\n\t\trtw_warn(rtwdev, \"sdio write32 failed (0x%x): %d\", addr, ret);\n}\n\nstatic u32 rtw_sdio_get_tx_addr(struct rtw_dev *rtwdev, size_t size,\n\t\t\t\tenum rtw_tx_queue_type queue)\n{\n\tu32 txaddr;\n\n\tswitch (queue) {\n\tcase RTW_TX_QUEUE_BCN:\n\tcase RTW_TX_QUEUE_H2C:\n\tcase RTW_TX_QUEUE_HI0:\n\t\ttxaddr = FIELD_PREP(REG_SDIO_CMD_ADDR_MSK,\n\t\t\t\t    REG_SDIO_CMD_ADDR_TXFF_HIGH);\n\t\tbreak;\n\tcase RTW_TX_QUEUE_VI:\n\tcase RTW_TX_QUEUE_VO:\n\t\ttxaddr = FIELD_PREP(REG_SDIO_CMD_ADDR_MSK,\n\t\t\t\t    REG_SDIO_CMD_ADDR_TXFF_NORMAL);\n\t\tbreak;\n\tcase RTW_TX_QUEUE_BE:\n\tcase RTW_TX_QUEUE_BK:\n\t\ttxaddr = FIELD_PREP(REG_SDIO_CMD_ADDR_MSK,\n\t\t\t\t    REG_SDIO_CMD_ADDR_TXFF_LOW);\n\t\tbreak;\n\tcase RTW_TX_QUEUE_MGMT:\n\t\ttxaddr = FIELD_PREP(REG_SDIO_CMD_ADDR_MSK,\n\t\t\t\t    REG_SDIO_CMD_ADDR_TXFF_EXTRA);\n\t\tbreak;\n\tdefault:\n\t\trtw_warn(rtwdev, \"Unsupported queue for TX addr: 0x%02x\\n\",\n\t\t\t queue);\n\t\treturn 0;\n\t}\n\n\ttxaddr += DIV_ROUND_UP(size, 4);\n\n\treturn txaddr;\n};\n\nstatic int rtw_sdio_read_port(struct rtw_dev *rtwdev, u8 *buf, size_t count)\n{\n\tstruct rtw_sdio *rtwsdio = (struct rtw_sdio *)rtwdev->priv;\n\tstruct mmc_host *host = rtwsdio->sdio_func->card->host;\n\tbool bus_claim = rtw_sdio_bus_claim_needed(rtwsdio);\n\tu32 rxaddr = rtwsdio->rx_addr++;\n\tint ret = 0, err;\n\tsize_t bytes;\n\n\tif (bus_claim)\n\t\tsdio_claim_host(rtwsdio->sdio_func);\n\n\twhile (count > 0) {\n\t\tbytes = min_t(size_t, host->max_req_size, count);\n\n\t\terr = sdio_memcpy_fromio(rtwsdio->sdio_func, buf,\n\t\t\t\t\t RTW_SDIO_ADDR_RX_RX0FF_GEN(rxaddr),\n\t\t\t\t\t bytes);\n\t\tif (err) {\n\t\t\trtw_warn(rtwdev,\n\t\t\t\t \"Failed to read %zu byte(s) from SDIO port 0x%08x: %d\",\n\t\t\t\t bytes, rxaddr, err);\n\n\t\t\t  \n\t\t\tret = err;\n\n\t\t\t \n\t\t}\n\n\t\tcount -= bytes;\n\t\tbuf += bytes;\n\t}\n\n\tif (bus_claim)\n\t\tsdio_release_host(rtwsdio->sdio_func);\n\n\treturn ret;\n}\n\nstatic int rtw_sdio_check_free_txpg(struct rtw_dev *rtwdev, u8 queue,\n\t\t\t\t    size_t count)\n{\n\tunsigned int pages_free, pages_needed;\n\n\tif (rtw_chip_wcpu_11n(rtwdev)) {\n\t\tu32 free_txpg;\n\n\t\tfree_txpg = rtw_sdio_read32(rtwdev, REG_SDIO_FREE_TXPG);\n\n\t\tswitch (queue) {\n\t\tcase RTW_TX_QUEUE_BCN:\n\t\tcase RTW_TX_QUEUE_H2C:\n\t\tcase RTW_TX_QUEUE_HI0:\n\t\tcase RTW_TX_QUEUE_MGMT:\n\t\t\t \n\t\t\tpages_free = free_txpg & 0xff;\n\t\t\tbreak;\n\t\tcase RTW_TX_QUEUE_VI:\n\t\tcase RTW_TX_QUEUE_VO:\n\t\t\t \n\t\t\tpages_free = (free_txpg >> 8) & 0xff;\n\t\t\tbreak;\n\t\tcase RTW_TX_QUEUE_BE:\n\t\tcase RTW_TX_QUEUE_BK:\n\t\t\t \n\t\t\tpages_free = (free_txpg >> 16) & 0xff;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trtw_warn(rtwdev, \"Unknown mapping for queue %u\\n\", queue);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tpages_free += (free_txpg >> 24) & 0xff;\n\t} else {\n\t\tu32 free_txpg[3];\n\n\t\tfree_txpg[0] = rtw_sdio_read32(rtwdev, REG_SDIO_FREE_TXPG);\n\t\tfree_txpg[1] = rtw_sdio_read32(rtwdev, REG_SDIO_FREE_TXPG + 4);\n\t\tfree_txpg[2] = rtw_sdio_read32(rtwdev, REG_SDIO_FREE_TXPG + 8);\n\n\t\tswitch (queue) {\n\t\tcase RTW_TX_QUEUE_BCN:\n\t\tcase RTW_TX_QUEUE_H2C:\n\t\tcase RTW_TX_QUEUE_HI0:\n\t\t\t \n\t\t\tpages_free = free_txpg[0] & 0xfff;\n\t\t\tbreak;\n\t\tcase RTW_TX_QUEUE_VI:\n\t\tcase RTW_TX_QUEUE_VO:\n\t\t\t \n\t\t\tpages_free = (free_txpg[0] >> 16) & 0xfff;\n\t\t\tbreak;\n\t\tcase RTW_TX_QUEUE_BE:\n\t\tcase RTW_TX_QUEUE_BK:\n\t\t\t \n\t\t\tpages_free = free_txpg[1] & 0xfff;\n\t\t\tbreak;\n\t\tcase RTW_TX_QUEUE_MGMT:\n\t\t\t \n\t\t\tpages_free = free_txpg[2] & 0xfff;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trtw_warn(rtwdev, \"Unknown mapping for queue %u\\n\", queue);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tpages_free += (free_txpg[1] >> 16) & 0xfff;\n\t}\n\n\tpages_needed = DIV_ROUND_UP(count, rtwdev->chip->page_size);\n\n\tif (pages_needed > pages_free) {\n\t\trtw_dbg(rtwdev, RTW_DBG_SDIO,\n\t\t\t\"Not enough free pages (%u needed, %u free) in queue %u for %zu bytes\\n\",\n\t\t\tpages_needed, pages_free, queue, count);\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic int rtw_sdio_write_port(struct rtw_dev *rtwdev, struct sk_buff *skb,\n\t\t\t       enum rtw_tx_queue_type queue)\n{\n\tstruct rtw_sdio *rtwsdio = (struct rtw_sdio *)rtwdev->priv;\n\tbool bus_claim;\n\tsize_t txsize;\n\tu32 txaddr;\n\tint ret;\n\n\ttxaddr = rtw_sdio_get_tx_addr(rtwdev, skb->len, queue);\n\tif (!txaddr)\n\t\treturn -EINVAL;\n\n\ttxsize = sdio_align_size(rtwsdio->sdio_func, skb->len);\n\n\tret = rtw_sdio_check_free_txpg(rtwdev, queue, txsize);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!IS_ALIGNED((unsigned long)skb->data, RTW_SDIO_DATA_PTR_ALIGN))\n\t\trtw_warn(rtwdev, \"Got unaligned SKB in %s() for queue %u\\n\",\n\t\t\t __func__, queue);\n\n\tbus_claim = rtw_sdio_bus_claim_needed(rtwsdio);\n\n\tif (bus_claim)\n\t\tsdio_claim_host(rtwsdio->sdio_func);\n\n\tret = sdio_memcpy_toio(rtwsdio->sdio_func, txaddr, skb->data, txsize);\n\n\tif (bus_claim)\n\t\tsdio_release_host(rtwsdio->sdio_func);\n\n\tif (ret)\n\t\trtw_warn(rtwdev,\n\t\t\t \"Failed to write %zu byte(s) to SDIO port 0x%08x\",\n\t\t\t txsize, txaddr);\n\n\treturn ret;\n}\n\nstatic void rtw_sdio_init(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_sdio *rtwsdio = (struct rtw_sdio *)rtwdev->priv;\n\n\trtwsdio->irq_mask = REG_SDIO_HIMR_RX_REQUEST | REG_SDIO_HIMR_CPWM1;\n}\n\nstatic void rtw_sdio_enable_rx_aggregation(struct rtw_dev *rtwdev)\n{\n\tu8 size, timeout;\n\n\tif (rtw_chip_wcpu_11n(rtwdev)) {\n\t\tsize = 0x6;\n\t\ttimeout = 0x6;\n\t} else {\n\t\tsize = 0xff;\n\t\ttimeout = 0x1;\n\t}\n\n\t \n\trtw_write32_set(rtwdev, REG_RXDMA_AGG_PG_TH, BIT_EN_PRE_CALC);\n\n\trtw_write8_set(rtwdev, REG_TXDMA_PQ_MAP, BIT_RXDMA_AGG_EN);\n\n\trtw_write16(rtwdev, REG_RXDMA_AGG_PG_TH,\n\t\t    FIELD_PREP(BIT_RXDMA_AGG_PG_TH, size) |\n\t\t    FIELD_PREP(BIT_DMA_AGG_TO_V1, timeout));\n\n\trtw_write8_set(rtwdev, REG_RXDMA_MODE, BIT_DMA_MODE);\n}\n\nstatic void rtw_sdio_enable_interrupt(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_sdio *rtwsdio = (struct rtw_sdio *)rtwdev->priv;\n\n\trtw_write32(rtwdev, REG_SDIO_HIMR, rtwsdio->irq_mask);\n}\n\nstatic void rtw_sdio_disable_interrupt(struct rtw_dev *rtwdev)\n{\n\trtw_write32(rtwdev, REG_SDIO_HIMR, 0x0);\n}\n\nstatic u8 rtw_sdio_get_tx_qsel(struct rtw_dev *rtwdev, struct sk_buff *skb,\n\t\t\t       u8 queue)\n{\n\tswitch (queue) {\n\tcase RTW_TX_QUEUE_BCN:\n\t\treturn TX_DESC_QSEL_BEACON;\n\tcase RTW_TX_QUEUE_H2C:\n\t\treturn TX_DESC_QSEL_H2C;\n\tcase RTW_TX_QUEUE_MGMT:\n\t\tif (rtw_chip_wcpu_11n(rtwdev))\n\t\t\treturn TX_DESC_QSEL_HIGH;\n\t\telse\n\t\t\treturn TX_DESC_QSEL_MGMT;\n\tcase RTW_TX_QUEUE_HI0:\n\t\treturn TX_DESC_QSEL_HIGH;\n\tdefault:\n\t\treturn skb->priority;\n\t}\n}\n\nstatic int rtw_sdio_setup(struct rtw_dev *rtwdev)\n{\n\t \n\treturn 0;\n}\n\nstatic int rtw_sdio_start(struct rtw_dev *rtwdev)\n{\n\trtw_sdio_enable_rx_aggregation(rtwdev);\n\trtw_sdio_enable_interrupt(rtwdev);\n\n\treturn 0;\n}\n\nstatic void rtw_sdio_stop(struct rtw_dev *rtwdev)\n{\n\trtw_sdio_disable_interrupt(rtwdev);\n}\n\nstatic void rtw_sdio_deep_ps_enter(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_sdio *rtwsdio = (struct rtw_sdio *)rtwdev->priv;\n\tbool tx_empty = true;\n\tu8 queue;\n\n\tif (!rtw_fw_feature_check(&rtwdev->fw, FW_FEATURE_TX_WAKE)) {\n\t\t \n\t\tfor (queue = 0; queue < RTK_MAX_TX_QUEUE_NUM; queue++) {\n\t\t\t \n\t\t\tif (queue == RTW_TX_QUEUE_BCN ||\n\t\t\t    queue == RTW_TX_QUEUE_H2C)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (skb_queue_len(&rtwsdio->tx_queue[queue])) {\n\t\t\t\ttx_empty = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!tx_empty) {\n\t\trtw_dbg(rtwdev, RTW_DBG_PS,\n\t\t\t\"TX path not empty, cannot enter deep power save state\\n\");\n\t\treturn;\n\t}\n\n\tset_bit(RTW_FLAG_LEISURE_PS_DEEP, rtwdev->flags);\n\trtw_power_mode_change(rtwdev, true);\n}\n\nstatic void rtw_sdio_deep_ps_leave(struct rtw_dev *rtwdev)\n{\n\tif (test_and_clear_bit(RTW_FLAG_LEISURE_PS_DEEP, rtwdev->flags))\n\t\trtw_power_mode_change(rtwdev, false);\n}\n\nstatic void rtw_sdio_deep_ps(struct rtw_dev *rtwdev, bool enter)\n{\n\tif (enter && !test_bit(RTW_FLAG_LEISURE_PS_DEEP, rtwdev->flags))\n\t\trtw_sdio_deep_ps_enter(rtwdev);\n\n\tif (!enter && test_bit(RTW_FLAG_LEISURE_PS_DEEP, rtwdev->flags))\n\t\trtw_sdio_deep_ps_leave(rtwdev);\n}\n\nstatic void rtw_sdio_tx_kick_off(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_sdio *rtwsdio = (struct rtw_sdio *)rtwdev->priv;\n\n\tqueue_work(rtwsdio->txwq, &rtwsdio->tx_handler_data->work);\n}\n\nstatic void rtw_sdio_link_ps(struct rtw_dev *rtwdev, bool enter)\n{\n\t \n}\n\nstatic void rtw_sdio_interface_cfg(struct rtw_dev *rtwdev)\n{\n\tu32 val;\n\n\trtw_read32(rtwdev, REG_SDIO_FREE_TXPG);\n\n\tval = rtw_read32(rtwdev, REG_SDIO_TX_CTRL);\n\tval &= 0xfff8;\n\trtw_write32(rtwdev, REG_SDIO_TX_CTRL, val);\n}\n\nstatic struct rtw_sdio_tx_data *rtw_sdio_get_tx_data(struct sk_buff *skb)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\n\tBUILD_BUG_ON(sizeof(struct rtw_sdio_tx_data) >\n\t\t     sizeof(info->status.status_driver_data));\n\n\treturn (struct rtw_sdio_tx_data *)info->status.status_driver_data;\n}\n\nstatic void rtw_sdio_tx_skb_prepare(struct rtw_dev *rtwdev,\n\t\t\t\t    struct rtw_tx_pkt_info *pkt_info,\n\t\t\t\t    struct sk_buff *skb,\n\t\t\t\t    enum rtw_tx_queue_type queue)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tunsigned long data_addr, aligned_addr;\n\tsize_t offset;\n\tu8 *pkt_desc;\n\n\tpkt_desc = skb_push(skb, chip->tx_pkt_desc_sz);\n\n\tdata_addr = (unsigned long)pkt_desc;\n\taligned_addr = ALIGN(data_addr, RTW_SDIO_DATA_PTR_ALIGN);\n\n\tif (data_addr != aligned_addr) {\n\t\t \n\t\toffset = RTW_SDIO_DATA_PTR_ALIGN - (aligned_addr - data_addr);\n\n\t\tpkt_desc = skb_push(skb, offset);\n\n\t\t \n\t\tpkt_info->offset += offset;\n\t}\n\n\tmemset(pkt_desc, 0, chip->tx_pkt_desc_sz);\n\n\tpkt_info->qsel = rtw_sdio_get_tx_qsel(rtwdev, skb, queue);\n\n\trtw_tx_fill_tx_desc(pkt_info, skb);\n\trtw_tx_fill_txdesc_checksum(rtwdev, pkt_info, pkt_desc);\n}\n\nstatic int rtw_sdio_write_data(struct rtw_dev *rtwdev,\n\t\t\t       struct rtw_tx_pkt_info *pkt_info,\n\t\t\t       struct sk_buff *skb,\n\t\t\t       enum rtw_tx_queue_type queue)\n{\n\tint ret;\n\n\trtw_sdio_tx_skb_prepare(rtwdev, pkt_info, skb, queue);\n\n\tret = rtw_sdio_write_port(rtwdev, skb, queue);\n\tdev_kfree_skb_any(skb);\n\n\treturn ret;\n}\n\nstatic int rtw_sdio_write_data_rsvd_page(struct rtw_dev *rtwdev, u8 *buf,\n\t\t\t\t\t u32 size)\n{\n\tstruct rtw_tx_pkt_info pkt_info = {};\n\tstruct sk_buff *skb;\n\n\tskb = rtw_tx_write_data_rsvd_page_get(rtwdev, &pkt_info, buf, size);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\treturn rtw_sdio_write_data(rtwdev, &pkt_info, skb, RTW_TX_QUEUE_BCN);\n}\n\nstatic int rtw_sdio_write_data_h2c(struct rtw_dev *rtwdev, u8 *buf, u32 size)\n{\n\tstruct rtw_tx_pkt_info pkt_info = {};\n\tstruct sk_buff *skb;\n\n\tskb = rtw_tx_write_data_h2c_get(rtwdev, &pkt_info, buf, size);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\treturn rtw_sdio_write_data(rtwdev, &pkt_info, skb, RTW_TX_QUEUE_H2C);\n}\n\nstatic int rtw_sdio_tx_write(struct rtw_dev *rtwdev,\n\t\t\t     struct rtw_tx_pkt_info *pkt_info,\n\t\t\t     struct sk_buff *skb)\n{\n\tstruct rtw_sdio *rtwsdio = (struct rtw_sdio *)rtwdev->priv;\n\tenum rtw_tx_queue_type queue = rtw_tx_queue_mapping(skb);\n\tstruct rtw_sdio_tx_data *tx_data;\n\n\trtw_sdio_tx_skb_prepare(rtwdev, pkt_info, skb, queue);\n\n\ttx_data = rtw_sdio_get_tx_data(skb);\n\ttx_data->sn = pkt_info->sn;\n\n\tskb_queue_tail(&rtwsdio->tx_queue[queue], skb);\n\n\treturn 0;\n}\n\nstatic void rtw_sdio_tx_err_isr(struct rtw_dev *rtwdev)\n{\n\tu32 val = rtw_read32(rtwdev, REG_TXDMA_STATUS);\n\n\trtw_write32(rtwdev, REG_TXDMA_STATUS, val);\n}\n\nstatic void rtw_sdio_rx_skb(struct rtw_dev *rtwdev, struct sk_buff *skb,\n\t\t\t    u32 pkt_offset, struct rtw_rx_pkt_stat *pkt_stat,\n\t\t\t    struct ieee80211_rx_status *rx_status)\n{\n\t*IEEE80211_SKB_RXCB(skb) = *rx_status;\n\n\tif (pkt_stat->is_c2h) {\n\t\tskb_put(skb, pkt_stat->pkt_len + pkt_offset);\n\t\trtw_fw_c2h_cmd_rx_irqsafe(rtwdev, pkt_offset, skb);\n\t\treturn;\n\t}\n\n\tskb_put(skb, pkt_stat->pkt_len);\n\tskb_reserve(skb, pkt_offset);\n\n\trtw_rx_stats(rtwdev, pkt_stat->vif, skb);\n\n\tieee80211_rx_irqsafe(rtwdev->hw, skb);\n}\n\nstatic void rtw_sdio_rxfifo_recv(struct rtw_dev *rtwdev, u32 rx_len)\n{\n\tstruct rtw_sdio *rtwsdio = (struct rtw_sdio *)rtwdev->priv;\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tu32 pkt_desc_sz = chip->rx_pkt_desc_sz;\n\tstruct ieee80211_rx_status rx_status;\n\tstruct rtw_rx_pkt_stat pkt_stat;\n\tstruct sk_buff *skb, *split_skb;\n\tu32 pkt_offset, curr_pkt_len;\n\tsize_t bufsz;\n\tu8 *rx_desc;\n\tint ret;\n\n\tbufsz = sdio_align_size(rtwsdio->sdio_func, rx_len);\n\n\tskb = dev_alloc_skb(bufsz);\n\tif (!skb)\n\t\treturn;\n\n\tret = rtw_sdio_read_port(rtwdev, skb->data, bufsz);\n\tif (ret) {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn;\n\t}\n\n\twhile (true) {\n\t\trx_desc = skb->data;\n\t\tchip->ops->query_rx_desc(rtwdev, rx_desc, &pkt_stat,\n\t\t\t\t\t &rx_status);\n\t\tpkt_offset = pkt_desc_sz + pkt_stat.drv_info_sz +\n\t\t\t     pkt_stat.shift;\n\n\t\tcurr_pkt_len = ALIGN(pkt_offset + pkt_stat.pkt_len,\n\t\t\t\t     RTW_SDIO_DATA_PTR_ALIGN);\n\n\t\tif ((curr_pkt_len + pkt_desc_sz) >= rx_len) {\n\t\t\t \n\t\t\trtw_sdio_rx_skb(rtwdev, skb, pkt_offset, &pkt_stat,\n\t\t\t\t\t&rx_status);\n\t\t\tbreak;\n\t\t}\n\n\t\tsplit_skb = dev_alloc_skb(curr_pkt_len);\n\t\tif (!split_skb) {\n\t\t\trtw_sdio_rx_skb(rtwdev, skb, pkt_offset, &pkt_stat,\n\t\t\t\t\t&rx_status);\n\t\t\tbreak;\n\t\t}\n\n\t\tskb_copy_header(split_skb, skb);\n\t\tmemcpy(split_skb->data, skb->data, curr_pkt_len);\n\n\t\trtw_sdio_rx_skb(rtwdev, split_skb, pkt_offset, &pkt_stat,\n\t\t\t\t&rx_status);\n\n\t\t \n\t\tskb_reserve(skb, curr_pkt_len);\n\t\trx_len -= curr_pkt_len;\n\t}\n}\n\nstatic void rtw_sdio_rx_isr(struct rtw_dev *rtwdev)\n{\n\tu32 rx_len, hisr, total_rx_bytes = 0;\n\n\tdo {\n\t\tif (rtw_chip_wcpu_11n(rtwdev))\n\t\t\trx_len = rtw_read16(rtwdev, REG_SDIO_RX0_REQ_LEN);\n\t\telse\n\t\t\trx_len = rtw_read32(rtwdev, REG_SDIO_RX0_REQ_LEN);\n\n\t\tif (!rx_len)\n\t\t\tbreak;\n\n\t\trtw_sdio_rxfifo_recv(rtwdev, rx_len);\n\n\t\ttotal_rx_bytes += rx_len;\n\n\t\tif (rtw_chip_wcpu_11n(rtwdev)) {\n\t\t\t \n\t\t\thisr = rtw_read32(rtwdev, REG_SDIO_HISR);\n\t\t} else {\n\t\t\t \n\t\t\thisr = REG_SDIO_HISR_RX_REQUEST;\n\t\t}\n\t} while (total_rx_bytes < SZ_64K && hisr & REG_SDIO_HISR_RX_REQUEST);\n}\n\nstatic void rtw_sdio_handle_interrupt(struct sdio_func *sdio_func)\n{\n\tstruct ieee80211_hw *hw = sdio_get_drvdata(sdio_func);\n\tstruct rtw_sdio *rtwsdio;\n\tstruct rtw_dev *rtwdev;\n\tu32 hisr;\n\n\trtwdev = hw->priv;\n\trtwsdio = (struct rtw_sdio *)rtwdev->priv;\n\n\trtwsdio->irq_thread = current;\n\n\thisr = rtw_read32(rtwdev, REG_SDIO_HISR);\n\n\tif (hisr & REG_SDIO_HISR_TXERR)\n\t\trtw_sdio_tx_err_isr(rtwdev);\n\tif (hisr & REG_SDIO_HISR_RX_REQUEST) {\n\t\thisr &= ~REG_SDIO_HISR_RX_REQUEST;\n\t\trtw_sdio_rx_isr(rtwdev);\n\t}\n\n\trtw_write32(rtwdev, REG_SDIO_HISR, hisr);\n\n\trtwsdio->irq_thread = NULL;\n}\n\nstatic int __maybe_unused rtw_sdio_suspend(struct device *dev)\n{\n\tstruct sdio_func *func = dev_to_sdio_func(dev);\n\tstruct ieee80211_hw *hw = dev_get_drvdata(dev);\n\tstruct rtw_dev *rtwdev = hw->priv;\n\tint ret;\n\n\tret = sdio_set_host_pm_flags(func, MMC_PM_KEEP_POWER);\n\tif (ret)\n\t\trtw_err(rtwdev, \"Failed to host PM flag MMC_PM_KEEP_POWER\");\n\n\treturn ret;\n}\n\nstatic int __maybe_unused rtw_sdio_resume(struct device *dev)\n{\n\treturn 0;\n}\n\nSIMPLE_DEV_PM_OPS(rtw_sdio_pm_ops, rtw_sdio_suspend, rtw_sdio_resume);\nEXPORT_SYMBOL(rtw_sdio_pm_ops);\n\nstatic int rtw_sdio_claim(struct rtw_dev *rtwdev, struct sdio_func *sdio_func)\n{\n\tstruct rtw_sdio *rtwsdio = (struct rtw_sdio *)rtwdev->priv;\n\tint ret;\n\n\tsdio_claim_host(sdio_func);\n\n\tret = sdio_enable_func(sdio_func);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"Failed to enable SDIO func\");\n\t\tgoto err_release_host;\n\t}\n\n\tret = sdio_set_block_size(sdio_func, RTW_SDIO_BLOCK_SIZE);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"Failed to set SDIO block size to 512\");\n\t\tgoto err_disable_func;\n\t}\n\n\trtwsdio->sdio_func = sdio_func;\n\n\trtwsdio->sdio3_bus_mode = mmc_card_uhs(sdio_func->card);\n\n\tsdio_set_drvdata(sdio_func, rtwdev->hw);\n\tSET_IEEE80211_DEV(rtwdev->hw, &sdio_func->dev);\n\n\tsdio_release_host(sdio_func);\n\n\treturn 0;\n\nerr_disable_func:\n\tsdio_disable_func(sdio_func);\nerr_release_host:\n\tsdio_release_host(sdio_func);\n\treturn ret;\n}\n\nstatic void rtw_sdio_declaim(struct rtw_dev *rtwdev,\n\t\t\t     struct sdio_func *sdio_func)\n{\n\tsdio_claim_host(sdio_func);\n\tsdio_disable_func(sdio_func);\n\tsdio_release_host(sdio_func);\n}\n\nstatic struct rtw_hci_ops rtw_sdio_ops = {\n\t.tx_write = rtw_sdio_tx_write,\n\t.tx_kick_off = rtw_sdio_tx_kick_off,\n\t.setup = rtw_sdio_setup,\n\t.start = rtw_sdio_start,\n\t.stop = rtw_sdio_stop,\n\t.deep_ps = rtw_sdio_deep_ps,\n\t.link_ps = rtw_sdio_link_ps,\n\t.interface_cfg = rtw_sdio_interface_cfg,\n\n\t.read8 = rtw_sdio_read8,\n\t.read16 = rtw_sdio_read16,\n\t.read32 = rtw_sdio_read32,\n\t.write8 = rtw_sdio_write8,\n\t.write16 = rtw_sdio_write16,\n\t.write32 = rtw_sdio_write32,\n\t.write_data_rsvd_page = rtw_sdio_write_data_rsvd_page,\n\t.write_data_h2c = rtw_sdio_write_data_h2c,\n};\n\nstatic int rtw_sdio_request_irq(struct rtw_dev *rtwdev,\n\t\t\t\tstruct sdio_func *sdio_func)\n{\n\tint ret;\n\n\tsdio_claim_host(sdio_func);\n\tret = sdio_claim_irq(sdio_func, &rtw_sdio_handle_interrupt);\n\tsdio_release_host(sdio_func);\n\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to claim SDIO IRQ\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void rtw_sdio_indicate_tx_status(struct rtw_dev *rtwdev,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct rtw_sdio_tx_data *tx_data = rtw_sdio_get_tx_data(skb);\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hw *hw = rtwdev->hw;\n\n\t \n\tif (info->flags & IEEE80211_TX_CTL_REQ_TX_STATUS) {\n\t\trtw_tx_report_enqueue(rtwdev, skb, tx_data->sn);\n\t\treturn;\n\t}\n\n\t \n\tieee80211_tx_info_clear_status(info);\n\tif (info->flags & IEEE80211_TX_CTL_NO_ACK)\n\t\tinfo->flags |= IEEE80211_TX_STAT_NOACK_TRANSMITTED;\n\telse\n\t\tinfo->flags |= IEEE80211_TX_STAT_ACK;\n\n\tieee80211_tx_status_irqsafe(hw, skb);\n}\n\nstatic void rtw_sdio_process_tx_queue(struct rtw_dev *rtwdev,\n\t\t\t\t      enum rtw_tx_queue_type queue)\n{\n\tstruct rtw_sdio *rtwsdio = (struct rtw_sdio *)rtwdev->priv;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = skb_dequeue(&rtwsdio->tx_queue[queue]);\n\tif (!skb)\n\t\treturn;\n\n\tret = rtw_sdio_write_port(rtwdev, skb, queue);\n\tif (ret) {\n\t\tskb_queue_head(&rtwsdio->tx_queue[queue], skb);\n\t\treturn;\n\t}\n\n\tif (queue <= RTW_TX_QUEUE_VO)\n\t\trtw_sdio_indicate_tx_status(rtwdev, skb);\n\telse\n\t\tdev_kfree_skb_any(skb);\n}\n\nstatic void rtw_sdio_tx_handler(struct work_struct *work)\n{\n\tstruct rtw_sdio_work_data *work_data =\n\t\tcontainer_of(work, struct rtw_sdio_work_data, work);\n\tstruct rtw_sdio *rtwsdio;\n\tstruct rtw_dev *rtwdev;\n\tint limit, queue;\n\n\trtwdev = work_data->rtwdev;\n\trtwsdio = (struct rtw_sdio *)rtwdev->priv;\n\n\tif (!rtw_fw_feature_check(&rtwdev->fw, FW_FEATURE_TX_WAKE))\n\t\trtw_sdio_deep_ps_leave(rtwdev);\n\n\tfor (queue = RTK_MAX_TX_QUEUE_NUM - 1; queue >= 0; queue--) {\n\t\tfor (limit = 0; limit < 1000; limit++) {\n\t\t\trtw_sdio_process_tx_queue(rtwdev, queue);\n\n\t\t\tif (skb_queue_empty(&rtwsdio->tx_queue[queue]))\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void rtw_sdio_free_irq(struct rtw_dev *rtwdev,\n\t\t\t      struct sdio_func *sdio_func)\n{\n\tsdio_claim_host(sdio_func);\n\tsdio_release_irq(sdio_func);\n\tsdio_release_host(sdio_func);\n}\n\nstatic int rtw_sdio_init_tx(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_sdio *rtwsdio = (struct rtw_sdio *)rtwdev->priv;\n\tint i;\n\n\trtwsdio->txwq = create_singlethread_workqueue(\"rtw88_sdio: tx wq\");\n\tif (!rtwsdio->txwq) {\n\t\trtw_err(rtwdev, \"failed to create TX work queue\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < RTK_MAX_TX_QUEUE_NUM; i++)\n\t\tskb_queue_head_init(&rtwsdio->tx_queue[i]);\n\trtwsdio->tx_handler_data = kmalloc(sizeof(*rtwsdio->tx_handler_data),\n\t\t\t\t\t   GFP_KERNEL);\n\tif (!rtwsdio->tx_handler_data)\n\t\tgoto err_destroy_wq;\n\n\trtwsdio->tx_handler_data->rtwdev = rtwdev;\n\tINIT_WORK(&rtwsdio->tx_handler_data->work, rtw_sdio_tx_handler);\n\n\treturn 0;\n\nerr_destroy_wq:\n\tdestroy_workqueue(rtwsdio->txwq);\n\treturn -ENOMEM;\n}\n\nstatic void rtw_sdio_deinit_tx(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_sdio *rtwsdio = (struct rtw_sdio *)rtwdev->priv;\n\tint i;\n\n\tfor (i = 0; i < RTK_MAX_TX_QUEUE_NUM; i++)\n\t\tskb_queue_purge(&rtwsdio->tx_queue[i]);\n\n\tflush_workqueue(rtwsdio->txwq);\n\tdestroy_workqueue(rtwsdio->txwq);\n\tkfree(rtwsdio->tx_handler_data);\n}\n\nint rtw_sdio_probe(struct sdio_func *sdio_func,\n\t\t   const struct sdio_device_id *id)\n{\n\tstruct ieee80211_hw *hw;\n\tstruct rtw_dev *rtwdev;\n\tint drv_data_size;\n\tint ret;\n\n\tdrv_data_size = sizeof(struct rtw_dev) + sizeof(struct rtw_sdio);\n\thw = ieee80211_alloc_hw(drv_data_size, &rtw_ops);\n\tif (!hw) {\n\t\tdev_err(&sdio_func->dev, \"failed to allocate hw\");\n\t\treturn -ENOMEM;\n\t}\n\n\trtwdev = hw->priv;\n\trtwdev->hw = hw;\n\trtwdev->dev = &sdio_func->dev;\n\trtwdev->chip = (struct rtw_chip_info *)id->driver_data;\n\trtwdev->hci.ops = &rtw_sdio_ops;\n\trtwdev->hci.type = RTW_HCI_TYPE_SDIO;\n\n\tret = rtw_core_init(rtwdev);\n\tif (ret)\n\t\tgoto err_release_hw;\n\n\trtw_dbg(rtwdev, RTW_DBG_SDIO,\n\t\t\"rtw88 SDIO probe: vendor=0x%04x device=%04x class=%02x\",\n\t\tid->vendor, id->device, id->class);\n\n\tret = rtw_sdio_claim(rtwdev, sdio_func);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to claim SDIO device\");\n\t\tgoto err_deinit_core;\n\t}\n\n\trtw_sdio_init(rtwdev);\n\n\tret = rtw_sdio_init_tx(rtwdev);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to init SDIO TX queue\\n\");\n\t\tgoto err_sdio_declaim;\n\t}\n\n\tret = rtw_chip_info_setup(rtwdev);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to setup chip information\");\n\t\tgoto err_destroy_txwq;\n\t}\n\n\tret = rtw_sdio_request_irq(rtwdev, sdio_func);\n\tif (ret)\n\t\tgoto err_destroy_txwq;\n\n\tret = rtw_register_hw(rtwdev, hw);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to register hw\");\n\t\tgoto err_free_irq;\n\t}\n\n\treturn 0;\n\nerr_free_irq:\n\trtw_sdio_free_irq(rtwdev, sdio_func);\nerr_destroy_txwq:\n\trtw_sdio_deinit_tx(rtwdev);\nerr_sdio_declaim:\n\trtw_sdio_declaim(rtwdev, sdio_func);\nerr_deinit_core:\n\trtw_core_deinit(rtwdev);\nerr_release_hw:\n\tieee80211_free_hw(hw);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(rtw_sdio_probe);\n\nvoid rtw_sdio_remove(struct sdio_func *sdio_func)\n{\n\tstruct ieee80211_hw *hw = sdio_get_drvdata(sdio_func);\n\tstruct rtw_dev *rtwdev;\n\n\tif (!hw)\n\t\treturn;\n\n\trtwdev = hw->priv;\n\n\trtw_unregister_hw(rtwdev, hw);\n\trtw_sdio_disable_interrupt(rtwdev);\n\trtw_sdio_free_irq(rtwdev, sdio_func);\n\trtw_sdio_declaim(rtwdev, sdio_func);\n\trtw_sdio_deinit_tx(rtwdev);\n\trtw_core_deinit(rtwdev);\n\tieee80211_free_hw(hw);\n}\nEXPORT_SYMBOL(rtw_sdio_remove);\n\nvoid rtw_sdio_shutdown(struct device *dev)\n{\n\tstruct sdio_func *sdio_func = dev_to_sdio_func(dev);\n\tconst struct rtw_chip_info *chip;\n\tstruct ieee80211_hw *hw;\n\tstruct rtw_dev *rtwdev;\n\n\thw = sdio_get_drvdata(sdio_func);\n\tif (!hw)\n\t\treturn;\n\n\trtwdev = hw->priv;\n\tchip = rtwdev->chip;\n\n\tif (chip->ops->shutdown)\n\t\tchip->ops->shutdown(rtwdev);\n}\nEXPORT_SYMBOL(rtw_sdio_shutdown);\n\nMODULE_AUTHOR(\"Martin Blumenstingl\");\nMODULE_AUTHOR(\"Jernej Skrabec\");\nMODULE_DESCRIPTION(\"Realtek 802.11ac wireless SDIO driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}