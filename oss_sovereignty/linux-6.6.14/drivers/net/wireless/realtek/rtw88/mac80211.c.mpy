{
  "module_name": "mac80211.c",
  "hash_id": "151ee9af50afdb8fe8f647731ab438602461a51fbf596c2514e7627c55aedfac",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtw88/mac80211.c",
  "human_readable_source": "\n \n\n#include \"main.h\"\n#include \"sec.h\"\n#include \"tx.h\"\n#include \"fw.h\"\n#include \"mac.h\"\n#include \"coex.h\"\n#include \"ps.h\"\n#include \"reg.h\"\n#include \"bf.h\"\n#include \"debug.h\"\n#include \"wow.h\"\n#include \"sar.h\"\n\nstatic void rtw_ops_tx(struct ieee80211_hw *hw,\n\t\t       struct ieee80211_tx_control *control,\n\t\t       struct sk_buff *skb)\n{\n\tstruct rtw_dev *rtwdev = hw->priv;\n\n\tif (!test_bit(RTW_FLAG_RUNNING, rtwdev->flags)) {\n\t\tieee80211_free_txskb(hw, skb);\n\t\treturn;\n\t}\n\n\trtw_tx(rtwdev, control, skb);\n}\n\nstatic void rtw_ops_wake_tx_queue(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_txq *txq)\n{\n\tstruct rtw_dev *rtwdev = hw->priv;\n\tstruct rtw_txq *rtwtxq = (struct rtw_txq *)txq->drv_priv;\n\n\tif (!test_bit(RTW_FLAG_RUNNING, rtwdev->flags))\n\t\treturn;\n\n\tspin_lock_bh(&rtwdev->txq_lock);\n\tif (list_empty(&rtwtxq->list))\n\t\tlist_add_tail(&rtwtxq->list, &rtwdev->txqs);\n\tspin_unlock_bh(&rtwdev->txq_lock);\n\n\t \n\tif (txq->ac == IEEE80211_AC_VO)\n\t\t__rtw_tx_work(rtwdev);\n\telse\n\t\tqueue_work(rtwdev->tx_wq, &rtwdev->tx_work);\n}\n\nstatic int rtw_ops_start(struct ieee80211_hw *hw)\n{\n\tstruct rtw_dev *rtwdev = hw->priv;\n\tint ret;\n\n\tmutex_lock(&rtwdev->mutex);\n\tret = rtw_core_start(rtwdev);\n\tmutex_unlock(&rtwdev->mutex);\n\n\treturn ret;\n}\n\nstatic void rtw_ops_stop(struct ieee80211_hw *hw)\n{\n\tstruct rtw_dev *rtwdev = hw->priv;\n\n\tmutex_lock(&rtwdev->mutex);\n\trtw_core_stop(rtwdev);\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nstatic int rtw_ops_config(struct ieee80211_hw *hw, u32 changed)\n{\n\tstruct rtw_dev *rtwdev = hw->priv;\n\tint ret = 0;\n\n\t \n\tcancel_work_sync(&rtwdev->ips_work);\n\n\tmutex_lock(&rtwdev->mutex);\n\n\trtw_leave_lps_deep(rtwdev);\n\n\tif ((changed & IEEE80211_CONF_CHANGE_IDLE) &&\n\t    !(hw->conf.flags & IEEE80211_CONF_IDLE)) {\n\t\tret = rtw_leave_ips(rtwdev);\n\t\tif (ret) {\n\t\t\trtw_err(rtwdev, \"failed to leave idle state\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (changed & IEEE80211_CONF_CHANGE_CHANNEL)\n\t\trtw_set_channel(rtwdev);\n\n\tif ((changed & IEEE80211_CONF_CHANGE_IDLE) &&\n\t    (hw->conf.flags & IEEE80211_CONF_IDLE) &&\n\t    !test_bit(RTW_FLAG_SCANNING, rtwdev->flags))\n\t\trtw_enter_ips(rtwdev);\n\nout:\n\tmutex_unlock(&rtwdev->mutex);\n\treturn ret;\n}\n\nstatic const struct rtw_vif_port rtw_vif_port[] = {\n\t[0] = {\n\t\t.mac_addr\t= {.addr = 0x0610},\n\t\t.bssid\t\t= {.addr = 0x0618},\n\t\t.net_type\t= {.addr = 0x0100, .mask = 0x30000},\n\t\t.aid\t\t= {.addr = 0x06a8, .mask = 0x7ff},\n\t\t.bcn_ctrl\t= {.addr = 0x0550, .mask = 0xff},\n\t},\n\t[1] = {\n\t\t.mac_addr\t= {.addr = 0x0700},\n\t\t.bssid\t\t= {.addr = 0x0708},\n\t\t.net_type\t= {.addr = 0x0100, .mask = 0xc0000},\n\t\t.aid\t\t= {.addr = 0x0710, .mask = 0x7ff},\n\t\t.bcn_ctrl\t= {.addr = 0x0551, .mask = 0xff},\n\t},\n\t[2] = {\n\t\t.mac_addr\t= {.addr = 0x1620},\n\t\t.bssid\t\t= {.addr = 0x1628},\n\t\t.net_type\t= {.addr = 0x1100, .mask = 0x3},\n\t\t.aid\t\t= {.addr = 0x1600, .mask = 0x7ff},\n\t\t.bcn_ctrl\t= {.addr = 0x0578, .mask = 0xff},\n\t},\n\t[3] = {\n\t\t.mac_addr\t= {.addr = 0x1630},\n\t\t.bssid\t\t= {.addr = 0x1638},\n\t\t.net_type\t= {.addr = 0x1100, .mask = 0xc},\n\t\t.aid\t\t= {.addr = 0x1604, .mask = 0x7ff},\n\t\t.bcn_ctrl\t= {.addr = 0x0579, .mask = 0xff},\n\t},\n\t[4] = {\n\t\t.mac_addr\t= {.addr = 0x1640},\n\t\t.bssid\t\t= {.addr = 0x1648},\n\t\t.net_type\t= {.addr = 0x1100, .mask = 0x30},\n\t\t.aid\t\t= {.addr = 0x1608, .mask = 0x7ff},\n\t\t.bcn_ctrl\t= {.addr = 0x057a, .mask = 0xff},\n\t},\n};\n\nstatic int rtw_ops_add_interface(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif)\n{\n\tstruct rtw_dev *rtwdev = hw->priv;\n\tstruct rtw_vif *rtwvif = (struct rtw_vif *)vif->drv_priv;\n\tenum rtw_net_type net_type;\n\tu32 config = 0;\n\tu8 port;\n\tu8 bcn_ctrl = 0;\n\n\tif (rtw_fw_feature_check(&rtwdev->fw, FW_FEATURE_BCN_FILTER))\n\t\tvif->driver_flags |= IEEE80211_VIF_BEACON_FILTER |\n\t\t\t\t     IEEE80211_VIF_SUPPORTS_CQM_RSSI;\n\trtwvif->stats.tx_unicast = 0;\n\trtwvif->stats.rx_unicast = 0;\n\trtwvif->stats.tx_cnt = 0;\n\trtwvif->stats.rx_cnt = 0;\n\trtwvif->scan_req = NULL;\n\tmemset(&rtwvif->bfee, 0, sizeof(struct rtw_bfee));\n\trtw_txq_init(rtwdev, vif->txq);\n\tINIT_LIST_HEAD(&rtwvif->rsvd_page_list);\n\n\tmutex_lock(&rtwdev->mutex);\n\n\tport = find_first_zero_bit(rtwdev->hw_port, RTW_PORT_NUM);\n\tif (port >= RTW_PORT_NUM) {\n\t\tmutex_unlock(&rtwdev->mutex);\n\t\treturn -EINVAL;\n\t}\n\tset_bit(port, rtwdev->hw_port);\n\n\trtwvif->port = port;\n\trtwvif->conf = &rtw_vif_port[port];\n\trtw_leave_lps_deep(rtwdev);\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\trtw_add_rsvd_page_bcn(rtwdev, rtwvif);\n\t\tnet_type = RTW_NET_AP_MODE;\n\t\tbcn_ctrl = BIT_EN_BCN_FUNCTION | BIT_DIS_TSF_UDT;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\trtw_add_rsvd_page_bcn(rtwdev, rtwvif);\n\t\tnet_type = RTW_NET_AD_HOC;\n\t\tbcn_ctrl = BIT_EN_BCN_FUNCTION | BIT_DIS_TSF_UDT;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\trtw_add_rsvd_page_sta(rtwdev, rtwvif);\n\t\tnet_type = RTW_NET_NO_LINK;\n\t\tbcn_ctrl = BIT_EN_BCN_FUNCTION;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tclear_bit(rtwvif->port, rtwdev->hw_port);\n\t\tmutex_unlock(&rtwdev->mutex);\n\t\treturn -EINVAL;\n\t}\n\n\tether_addr_copy(rtwvif->mac_addr, vif->addr);\n\tconfig |= PORT_SET_MAC_ADDR;\n\trtwvif->net_type = net_type;\n\tconfig |= PORT_SET_NET_TYPE;\n\trtwvif->bcn_ctrl = bcn_ctrl;\n\tconfig |= PORT_SET_BCN_CTRL;\n\trtw_vif_port_config(rtwdev, rtwvif, config);\n\trtw_core_port_switch(rtwdev, vif);\n\trtw_recalc_lps(rtwdev, vif);\n\n\tmutex_unlock(&rtwdev->mutex);\n\n\trtw_dbg(rtwdev, RTW_DBG_STATE, \"start vif %pM on port %d\\n\", vif->addr, rtwvif->port);\n\treturn 0;\n}\n\nstatic void rtw_ops_remove_interface(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct rtw_dev *rtwdev = hw->priv;\n\tstruct rtw_vif *rtwvif = (struct rtw_vif *)vif->drv_priv;\n\tu32 config = 0;\n\n\trtw_dbg(rtwdev, RTW_DBG_STATE, \"stop vif %pM on port %d\\n\", vif->addr, rtwvif->port);\n\n\tmutex_lock(&rtwdev->mutex);\n\n\trtw_leave_lps_deep(rtwdev);\n\n\trtw_txq_cleanup(rtwdev, vif->txq);\n\trtw_remove_rsvd_page(rtwdev, rtwvif);\n\n\teth_zero_addr(rtwvif->mac_addr);\n\tconfig |= PORT_SET_MAC_ADDR;\n\trtwvif->net_type = RTW_NET_NO_LINK;\n\tconfig |= PORT_SET_NET_TYPE;\n\trtwvif->bcn_ctrl = 0;\n\tconfig |= PORT_SET_BCN_CTRL;\n\trtw_vif_port_config(rtwdev, rtwvif, config);\n\tclear_bit(rtwvif->port, rtwdev->hw_port);\n\trtw_recalc_lps(rtwdev, NULL);\n\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nstatic int rtw_ops_change_interface(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    enum nl80211_iftype type, bool p2p)\n{\n\tstruct rtw_dev *rtwdev = hw->priv;\n\n\trtw_dbg(rtwdev, RTW_DBG_STATE, \"change vif %pM (%d)->(%d), p2p (%d)->(%d)\\n\",\n\t\tvif->addr, vif->type, type, vif->p2p, p2p);\n\n\trtw_ops_remove_interface(hw, vif);\n\n\tvif->type = type;\n\tvif->p2p = p2p;\n\n\treturn rtw_ops_add_interface(hw, vif);\n}\n\nstatic void rtw_ops_configure_filter(struct ieee80211_hw *hw,\n\t\t\t\t     unsigned int changed_flags,\n\t\t\t\t     unsigned int *new_flags,\n\t\t\t\t     u64 multicast)\n{\n\tstruct rtw_dev *rtwdev = hw->priv;\n\n\t*new_flags &= FIF_ALLMULTI | FIF_OTHER_BSS | FIF_FCSFAIL |\n\t\t      FIF_BCN_PRBRESP_PROMISC;\n\n\tmutex_lock(&rtwdev->mutex);\n\n\trtw_leave_lps_deep(rtwdev);\n\n\tif (changed_flags & FIF_ALLMULTI) {\n\t\tif (*new_flags & FIF_ALLMULTI)\n\t\t\trtwdev->hal.rcr |= BIT_AM;\n\t\telse\n\t\t\trtwdev->hal.rcr &= ~(BIT_AM);\n\t}\n\tif (changed_flags & FIF_FCSFAIL) {\n\t\tif (*new_flags & FIF_FCSFAIL)\n\t\t\trtwdev->hal.rcr |= BIT_ACRC32;\n\t\telse\n\t\t\trtwdev->hal.rcr &= ~(BIT_ACRC32);\n\t}\n\tif (changed_flags & FIF_OTHER_BSS) {\n\t\tif (*new_flags & FIF_OTHER_BSS)\n\t\t\trtwdev->hal.rcr |= BIT_AAP;\n\t\telse\n\t\t\trtwdev->hal.rcr &= ~(BIT_AAP);\n\t}\n\tif (changed_flags & FIF_BCN_PRBRESP_PROMISC) {\n\t\tif (*new_flags & FIF_BCN_PRBRESP_PROMISC)\n\t\t\trtwdev->hal.rcr &= ~(BIT_CBSSID_BCN | BIT_CBSSID_DATA);\n\t\telse\n\t\t\trtwdev->hal.rcr |= BIT_CBSSID_BCN;\n\t}\n\n\trtw_dbg(rtwdev, RTW_DBG_RX,\n\t\t\"config rx filter, changed=0x%08x, new=0x%08x, rcr=0x%08x\\n\",\n\t\tchanged_flags, *new_flags, rtwdev->hal.rcr);\n\n\trtw_write32(rtwdev, REG_RCR, rtwdev->hal.rcr);\n\n\tmutex_unlock(&rtwdev->mutex);\n}\n\n \nstatic const u32 ac_to_edca_param[IEEE80211_NUM_ACS] = {\n\t[IEEE80211_AC_VO] = REG_EDCA_VO_PARAM,\n\t[IEEE80211_AC_VI] = REG_EDCA_VI_PARAM,\n\t[IEEE80211_AC_BE] = REG_EDCA_BE_PARAM,\n\t[IEEE80211_AC_BK] = REG_EDCA_BK_PARAM,\n};\n\nstatic u8 rtw_aifsn_to_aifs(struct rtw_dev *rtwdev,\n\t\t\t    struct rtw_vif *rtwvif, u8 aifsn)\n{\n\tstruct ieee80211_vif *vif = rtwvif_to_vif(rtwvif);\n\tu8 slot_time;\n\tu8 sifs;\n\n\tslot_time = vif->bss_conf.use_short_slot ? 9 : 20;\n\tsifs = rtwdev->hal.current_band_type == RTW_BAND_5G ? 16 : 10;\n\n\treturn aifsn * slot_time + sifs;\n}\n\nstatic void __rtw_conf_tx(struct rtw_dev *rtwdev,\n\t\t\t  struct rtw_vif *rtwvif, u16 ac)\n{\n\tstruct ieee80211_tx_queue_params *params = &rtwvif->tx_params[ac];\n\tu32 edca_param = ac_to_edca_param[ac];\n\tu8 ecw_max, ecw_min;\n\tu8 aifs;\n\n\t \n\tecw_max = ilog2(params->cw_max + 1);\n\tecw_min = ilog2(params->cw_min + 1);\n\taifs = rtw_aifsn_to_aifs(rtwdev, rtwvif, params->aifs);\n\trtw_write32_mask(rtwdev, edca_param, BIT_MASK_TXOP_LMT, params->txop);\n\trtw_write32_mask(rtwdev, edca_param, BIT_MASK_CWMAX, ecw_max);\n\trtw_write32_mask(rtwdev, edca_param, BIT_MASK_CWMIN, ecw_min);\n\trtw_write32_mask(rtwdev, edca_param, BIT_MASK_AIFS, aifs);\n}\n\nstatic void rtw_conf_tx(struct rtw_dev *rtwdev,\n\t\t\tstruct rtw_vif *rtwvif)\n{\n\tu16 ac;\n\n\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++)\n\t\t__rtw_conf_tx(rtwdev, rtwvif, ac);\n}\n\nstatic void rtw_ops_bss_info_changed(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t     struct ieee80211_bss_conf *conf,\n\t\t\t\t     u64 changed)\n{\n\tstruct rtw_dev *rtwdev = hw->priv;\n\tstruct rtw_vif *rtwvif = (struct rtw_vif *)vif->drv_priv;\n\tstruct rtw_coex *coex = &rtwdev->coex;\n\tstruct rtw_coex_stat *coex_stat = &coex->stat;\n\tu32 config = 0;\n\n\tmutex_lock(&rtwdev->mutex);\n\n\trtw_leave_lps_deep(rtwdev);\n\n\tif (changed & BSS_CHANGED_ASSOC) {\n\t\trtw_vif_assoc_changed(rtwvif, conf);\n\t\tif (vif->cfg.assoc) {\n\t\t\trtw_coex_connect_notify(rtwdev, COEX_ASSOCIATE_FINISH);\n\n\t\t\trtw_fw_download_rsvd_page(rtwdev);\n\t\t\trtw_send_rsvd_page_h2c(rtwdev);\n\t\t\trtw_fw_default_port(rtwdev, rtwvif);\n\t\t\trtw_coex_media_status_notify(rtwdev, vif->cfg.assoc);\n\t\t\tif (rtw_bf_support)\n\t\t\t\trtw_bf_assoc(rtwdev, vif, conf);\n\t\t} else {\n\t\t\trtw_leave_lps(rtwdev);\n\t\t\trtw_bf_disassoc(rtwdev, vif, conf);\n\t\t\t \n\t\t\tif (test_bit(RTW_FLAG_SCANNING, rtwdev->flags))\n\t\t\t\trtw_hw_scan_abort(rtwdev);\n\n\t\t}\n\n\t\tconfig |= PORT_SET_NET_TYPE;\n\t\tconfig |= PORT_SET_AID;\n\t}\n\n\tif (changed & BSS_CHANGED_BSSID) {\n\t\tether_addr_copy(rtwvif->bssid, conf->bssid);\n\t\tconfig |= PORT_SET_BSSID;\n\t\tif (!rtw_core_check_sta_active(rtwdev))\n\t\t\trtw_clear_op_chan(rtwdev);\n\t\telse\n\t\t\trtw_store_op_chan(rtwdev, true);\n\t}\n\n\tif (changed & BSS_CHANGED_BEACON_INT) {\n\t\tif (ieee80211_vif_type_p2p(vif) == NL80211_IFTYPE_STATION)\n\t\t\tcoex_stat->wl_beacon_interval = conf->beacon_int;\n\t}\n\n\tif (changed & BSS_CHANGED_BEACON) {\n\t\trtw_set_dtim_period(rtwdev, conf->dtim_period);\n\t\trtw_fw_download_rsvd_page(rtwdev);\n\t\trtw_send_rsvd_page_h2c(rtwdev);\n\t}\n\n\tif (changed & BSS_CHANGED_BEACON_ENABLED) {\n\t\tif (conf->enable_beacon)\n\t\t\trtw_write32_set(rtwdev, REG_FWHW_TXQ_CTRL,\n\t\t\t\t\tBIT_EN_BCNQ_DL);\n\t\telse\n\t\t\trtw_write32_clr(rtwdev, REG_FWHW_TXQ_CTRL,\n\t\t\t\t\tBIT_EN_BCNQ_DL);\n\t}\n\tif (changed & BSS_CHANGED_CQM)\n\t\trtw_fw_beacon_filter_config(rtwdev, true, vif);\n\n\tif (changed & BSS_CHANGED_MU_GROUPS)\n\t\trtw_chip_set_gid_table(rtwdev, vif, conf);\n\n\tif (changed & BSS_CHANGED_ERP_SLOT)\n\t\trtw_conf_tx(rtwdev, rtwvif);\n\n\tif (changed & BSS_CHANGED_PS)\n\t\trtw_recalc_lps(rtwdev, NULL);\n\n\trtw_vif_port_config(rtwdev, rtwvif, config);\n\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nstatic int rtw_ops_start_ap(struct ieee80211_hw *hw,\n\t\t\t    struct ieee80211_vif *vif,\n\t\t\t    struct ieee80211_bss_conf *link_conf)\n{\n\tstruct rtw_dev *rtwdev = hw->priv;\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\n\tmutex_lock(&rtwdev->mutex);\n\trtw_write32_set(rtwdev, REG_TCR, BIT_TCR_UPDATE_HGQMD);\n\trtwdev->ap_active = true;\n\trtw_store_op_chan(rtwdev, true);\n\tchip->ops->phy_calibration(rtwdev);\n\tmutex_unlock(&rtwdev->mutex);\n\n\treturn 0;\n}\n\nstatic void rtw_ops_stop_ap(struct ieee80211_hw *hw,\n\t\t\t    struct ieee80211_vif *vif,\n\t\t\t    struct ieee80211_bss_conf *link_conf)\n{\n\tstruct rtw_dev *rtwdev = hw->priv;\n\n\tmutex_lock(&rtwdev->mutex);\n\trtw_write32_clr(rtwdev, REG_TCR, BIT_TCR_UPDATE_HGQMD);\n\trtwdev->ap_active = false;\n\tif (!rtw_core_check_sta_active(rtwdev))\n\t\trtw_clear_op_chan(rtwdev);\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nstatic int rtw_ops_conf_tx(struct ieee80211_hw *hw,\n\t\t\t   struct ieee80211_vif *vif,\n\t\t\t   unsigned int link_id, u16 ac,\n\t\t\t   const struct ieee80211_tx_queue_params *params)\n{\n\tstruct rtw_dev *rtwdev = hw->priv;\n\tstruct rtw_vif *rtwvif = (struct rtw_vif *)vif->drv_priv;\n\n\tmutex_lock(&rtwdev->mutex);\n\n\trtw_leave_lps_deep(rtwdev);\n\n\trtwvif->tx_params[ac] = *params;\n\t__rtw_conf_tx(rtwdev, rtwvif, ac);\n\n\tmutex_unlock(&rtwdev->mutex);\n\n\treturn 0;\n}\n\nstatic int rtw_ops_sta_add(struct ieee80211_hw *hw,\n\t\t\t   struct ieee80211_vif *vif,\n\t\t\t   struct ieee80211_sta *sta)\n{\n\tstruct rtw_dev *rtwdev = hw->priv;\n\tint ret = 0;\n\n\tmutex_lock(&rtwdev->mutex);\n\tret = rtw_sta_add(rtwdev, sta, vif);\n\tmutex_unlock(&rtwdev->mutex);\n\n\treturn ret;\n}\n\nstatic int rtw_ops_sta_remove(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      struct ieee80211_sta *sta)\n{\n\tstruct rtw_dev *rtwdev = hw->priv;\n\n\tmutex_lock(&rtwdev->mutex);\n\trtw_fw_beacon_filter_config(rtwdev, false, vif);\n\trtw_sta_remove(rtwdev, sta, true);\n\tmutex_unlock(&rtwdev->mutex);\n\n\treturn 0;\n}\n\nstatic int rtw_ops_set_tim(struct ieee80211_hw *hw, struct ieee80211_sta *sta,\n\t\t\t   bool set)\n{\n\tstruct rtw_dev *rtwdev = hw->priv;\n\n\tieee80211_queue_work(hw, &rtwdev->update_beacon_work);\n\n\treturn 0;\n}\n\nstatic int rtw_ops_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,\n\t\t\t   struct ieee80211_vif *vif, struct ieee80211_sta *sta,\n\t\t\t   struct ieee80211_key_conf *key)\n{\n\tstruct rtw_dev *rtwdev = hw->priv;\n\tstruct rtw_sec_desc *sec = &rtwdev->sec;\n\tu8 hw_key_type;\n\tu8 hw_key_idx;\n\tint ret = 0;\n\n\tswitch (key->cipher) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\thw_key_type = RTW_CAM_WEP40;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\thw_key_type = RTW_CAM_WEP104;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\thw_key_type = RTW_CAM_TKIP;\n\t\tkey->flags |= IEEE80211_KEY_FLAG_GENERATE_MMIC;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\thw_key_type = RTW_CAM_AES;\n\t\tkey->flags |= IEEE80211_KEY_FLAG_SW_MGMT_TX;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\tcase WLAN_CIPHER_SUITE_BIP_CMAC_256:\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_128:\n\tcase WLAN_CIPHER_SUITE_BIP_GMAC_256:\n\tcase WLAN_CIPHER_SUITE_CCMP_256:\n\tcase WLAN_CIPHER_SUITE_GCMP:\n\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\t \n\t\treturn -EOPNOTSUPP;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\tmutex_lock(&rtwdev->mutex);\n\n\trtw_leave_lps_deep(rtwdev);\n\n\tif (key->flags & IEEE80211_KEY_FLAG_PAIRWISE) {\n\t\thw_key_idx = rtw_sec_get_free_cam(sec);\n\t} else {\n\t\t \n\t\thw_key_idx = key->keyidx;\n\t}\n\n\tif (hw_key_idx > sec->total_cam_num) {\n\t\tret = -ENOSPC;\n\t\tgoto out;\n\t}\n\n\tswitch (cmd) {\n\tcase SET_KEY:\n\t\t \n\t\tkey->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;\n\t\tkey->hw_key_idx = hw_key_idx;\n\t\trtw_sec_write_cam(rtwdev, sec, sta, key,\n\t\t\t\t  hw_key_type, hw_key_idx);\n\t\tbreak;\n\tcase DISABLE_KEY:\n\t\trtw_hci_flush_all_queues(rtwdev, false);\n\t\trtw_mac_flush_all_queues(rtwdev, false);\n\t\trtw_sec_clear_cam(rtwdev, sec, key->hw_key_idx);\n\t\tbreak;\n\t}\n\n\t \n\tif (rtw_get_lps_deep_mode(rtwdev) == LPS_DEEP_MODE_PG)\n\t\trtw_fw_download_rsvd_page(rtwdev);\n\nout:\n\tmutex_unlock(&rtwdev->mutex);\n\n\treturn ret;\n}\n\nstatic int rtw_ops_ampdu_action(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_ampdu_params *params)\n{\n\tstruct ieee80211_sta *sta = params->sta;\n\tu16 tid = params->tid;\n\tstruct ieee80211_txq *txq = sta->txq[tid];\n\tstruct rtw_txq *rtwtxq = (struct rtw_txq *)txq->drv_priv;\n\n\tswitch (params->action) {\n\tcase IEEE80211_AMPDU_TX_START:\n\t\treturn IEEE80211_AMPDU_TX_START_IMMEDIATE;\n\tcase IEEE80211_AMPDU_TX_STOP_CONT:\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH:\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH_CONT:\n\t\tclear_bit(RTW_TXQ_AMPDU, &rtwtxq->flags);\n\t\tieee80211_stop_tx_ba_cb_irqsafe(vif, sta->addr, tid);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_OPERATIONAL:\n\t\tset_bit(RTW_TXQ_AMPDU, &rtwtxq->flags);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_RX_START:\n\tcase IEEE80211_AMPDU_RX_STOP:\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic bool rtw_ops_can_aggregate_in_amsdu(struct ieee80211_hw *hw,\n\t\t\t\t\t   struct sk_buff *head,\n\t\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct rtw_dev *rtwdev = hw->priv;\n\tstruct rtw_hal *hal = &rtwdev->hal;\n\n\t \n\tif (hal->current_band_type == RTW_BAND_2G)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void rtw_ops_sw_scan_start(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  const u8 *mac_addr)\n{\n\tstruct rtw_dev *rtwdev = hw->priv;\n\tstruct rtw_vif *rtwvif = (struct rtw_vif *)vif->drv_priv;\n\n\tmutex_lock(&rtwdev->mutex);\n\trtw_core_scan_start(rtwdev, rtwvif, mac_addr, false);\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nstatic void rtw_ops_sw_scan_complete(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct rtw_dev *rtwdev = hw->priv;\n\n\tmutex_lock(&rtwdev->mutex);\n\trtw_core_scan_complete(rtwdev, vif, false);\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nstatic void rtw_ops_mgd_prepare_tx(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   struct ieee80211_prep_tx_info *info)\n{\n\tstruct rtw_dev *rtwdev = hw->priv;\n\n\tmutex_lock(&rtwdev->mutex);\n\trtw_leave_lps_deep(rtwdev);\n\trtw_coex_connect_notify(rtwdev, COEX_ASSOCIATE_START);\n\trtw_chip_prepare_tx(rtwdev);\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nstatic int rtw_ops_set_rts_threshold(struct ieee80211_hw *hw, u32 value)\n{\n\tstruct rtw_dev *rtwdev = hw->priv;\n\n\tmutex_lock(&rtwdev->mutex);\n\trtwdev->rts_threshold = value;\n\tmutex_unlock(&rtwdev->mutex);\n\n\treturn 0;\n}\n\nstatic void rtw_ops_sta_statistics(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   struct ieee80211_sta *sta,\n\t\t\t\t   struct station_info *sinfo)\n{\n\tstruct rtw_sta_info *si = (struct rtw_sta_info *)sta->drv_priv;\n\n\tsinfo->txrate = si->ra_report.txrate;\n\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_BITRATE);\n}\n\nstatic void rtw_ops_flush(struct ieee80211_hw *hw,\n\t\t\t  struct ieee80211_vif *vif,\n\t\t\t  u32 queues, bool drop)\n{\n\tstruct rtw_dev *rtwdev = hw->priv;\n\n\tmutex_lock(&rtwdev->mutex);\n\trtw_leave_lps_deep(rtwdev);\n\n\trtw_hci_flush_queues(rtwdev, queues, drop);\n\trtw_mac_flush_queues(rtwdev, queues, drop);\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nstruct rtw_iter_bitrate_mask_data {\n\tstruct rtw_dev *rtwdev;\n\tstruct ieee80211_vif *vif;\n\tconst struct cfg80211_bitrate_mask *mask;\n};\n\nstatic void rtw_ra_mask_info_update_iter(void *data, struct ieee80211_sta *sta)\n{\n\tstruct rtw_iter_bitrate_mask_data *br_data = data;\n\tstruct rtw_sta_info *si = (struct rtw_sta_info *)sta->drv_priv;\n\n\tif (si->vif != br_data->vif)\n\t\treturn;\n\n\t \n\tkfree(si->mask);\n\tsi->mask = kmemdup(br_data->mask, sizeof(struct cfg80211_bitrate_mask),\n\t\t\t   GFP_ATOMIC);\n\tif (!si->mask) {\n\t\tsi->use_cfg_mask = false;\n\t\treturn;\n\t}\n\n\tsi->use_cfg_mask = true;\n\trtw_update_sta_info(br_data->rtwdev, si, true);\n}\n\nstatic void rtw_ra_mask_info_update(struct rtw_dev *rtwdev,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    const struct cfg80211_bitrate_mask *mask)\n{\n\tstruct rtw_iter_bitrate_mask_data br_data;\n\n\tbr_data.rtwdev = rtwdev;\n\tbr_data.vif = vif;\n\tbr_data.mask = mask;\n\trtw_iterate_stas(rtwdev, rtw_ra_mask_info_update_iter, &br_data);\n}\n\nstatic int rtw_ops_set_bitrate_mask(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    const struct cfg80211_bitrate_mask *mask)\n{\n\tstruct rtw_dev *rtwdev = hw->priv;\n\n\tmutex_lock(&rtwdev->mutex);\n\trtw_ra_mask_info_update(rtwdev, vif, mask);\n\tmutex_unlock(&rtwdev->mutex);\n\n\treturn 0;\n}\n\nstatic int rtw_ops_set_antenna(struct ieee80211_hw *hw,\n\t\t\t       u32 tx_antenna,\n\t\t\t       u32 rx_antenna)\n{\n\tstruct rtw_dev *rtwdev = hw->priv;\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tint ret;\n\n\tif (!chip->ops->set_antenna)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&rtwdev->mutex);\n\tret = chip->ops->set_antenna(rtwdev, tx_antenna, rx_antenna);\n\tmutex_unlock(&rtwdev->mutex);\n\n\treturn ret;\n}\n\nstatic int rtw_ops_get_antenna(struct ieee80211_hw *hw,\n\t\t\t       u32 *tx_antenna,\n\t\t\t       u32 *rx_antenna)\n{\n\tstruct rtw_dev *rtwdev = hw->priv;\n\tstruct rtw_hal *hal = &rtwdev->hal;\n\n\t*tx_antenna = hal->antenna_tx;\n\t*rx_antenna = hal->antenna_rx;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int rtw_ops_suspend(struct ieee80211_hw *hw,\n\t\t\t   struct cfg80211_wowlan *wowlan)\n{\n\tstruct rtw_dev *rtwdev = hw->priv;\n\tint ret;\n\n\tmutex_lock(&rtwdev->mutex);\n\tret = rtw_wow_suspend(rtwdev, wowlan);\n\tif (ret)\n\t\trtw_err(rtwdev, \"failed to suspend for wow %d\\n\", ret);\n\tmutex_unlock(&rtwdev->mutex);\n\n\treturn ret ? 1 : 0;\n}\n\nstatic int rtw_ops_resume(struct ieee80211_hw *hw)\n{\n\tstruct rtw_dev *rtwdev = hw->priv;\n\tint ret;\n\n\tmutex_lock(&rtwdev->mutex);\n\tret = rtw_wow_resume(rtwdev);\n\tif (ret)\n\t\trtw_err(rtwdev, \"failed to resume for wow %d\\n\", ret);\n\tmutex_unlock(&rtwdev->mutex);\n\n\treturn ret ? 1 : 0;\n}\n\nstatic void rtw_ops_set_wakeup(struct ieee80211_hw *hw, bool enabled)\n{\n\tstruct rtw_dev *rtwdev = hw->priv;\n\n\tdevice_set_wakeup_enable(rtwdev->dev, enabled);\n}\n#endif\n\nstatic void rtw_reconfig_complete(struct ieee80211_hw *hw,\n\t\t\t\t  enum ieee80211_reconfig_type reconfig_type)\n{\n\tstruct rtw_dev *rtwdev = hw->priv;\n\n\tmutex_lock(&rtwdev->mutex);\n\tif (reconfig_type == IEEE80211_RECONFIG_TYPE_RESTART)\n\t\tclear_bit(RTW_FLAG_RESTARTING, rtwdev->flags);\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nstatic int rtw_ops_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t   struct ieee80211_scan_request *req)\n{\n\tstruct rtw_dev *rtwdev = hw->priv;\n\tint ret;\n\n\tif (!rtw_fw_feature_check(&rtwdev->fw, FW_FEATURE_SCAN_OFFLOAD))\n\t\treturn 1;\n\n\tif (test_bit(RTW_FLAG_SCANNING, rtwdev->flags))\n\t\treturn -EBUSY;\n\n\tmutex_lock(&rtwdev->mutex);\n\trtw_hw_scan_start(rtwdev, vif, req);\n\tret = rtw_hw_scan_offload(rtwdev, vif, true);\n\tif (ret) {\n\t\trtw_hw_scan_abort(rtwdev);\n\t\trtw_err(rtwdev, \"HW scan failed with status: %d\\n\", ret);\n\t}\n\tmutex_unlock(&rtwdev->mutex);\n\n\treturn ret;\n}\n\nstatic void rtw_ops_cancel_hw_scan(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tstruct rtw_dev *rtwdev = hw->priv;\n\n\tif (!rtw_fw_feature_check(&rtwdev->fw, FW_FEATURE_SCAN_OFFLOAD))\n\t\treturn;\n\n\tif (!test_bit(RTW_FLAG_SCANNING, rtwdev->flags))\n\t\treturn;\n\n\tmutex_lock(&rtwdev->mutex);\n\trtw_hw_scan_abort(rtwdev);\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nstatic int rtw_ops_set_sar_specs(struct ieee80211_hw *hw,\n\t\t\t\t const struct cfg80211_sar_specs *sar)\n{\n\tstruct rtw_dev *rtwdev = hw->priv;\n\n\tmutex_lock(&rtwdev->mutex);\n\trtw_set_sar_specs(rtwdev, sar);\n\tmutex_unlock(&rtwdev->mutex);\n\n\treturn 0;\n}\n\nstatic void rtw_ops_sta_rc_update(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  struct ieee80211_sta *sta, u32 changed)\n{\n\tstruct rtw_dev *rtwdev = hw->priv;\n\tstruct rtw_sta_info *si = (struct rtw_sta_info *)sta->drv_priv;\n\n\tif (changed & IEEE80211_RC_BW_CHANGED)\n\t\tieee80211_queue_work(rtwdev->hw, &si->rc_work);\n}\n\nconst struct ieee80211_ops rtw_ops = {\n\t.tx\t\t\t= rtw_ops_tx,\n\t.wake_tx_queue\t\t= rtw_ops_wake_tx_queue,\n\t.start\t\t\t= rtw_ops_start,\n\t.stop\t\t\t= rtw_ops_stop,\n\t.config\t\t\t= rtw_ops_config,\n\t.add_interface\t\t= rtw_ops_add_interface,\n\t.remove_interface\t= rtw_ops_remove_interface,\n\t.change_interface\t= rtw_ops_change_interface,\n\t.configure_filter\t= rtw_ops_configure_filter,\n\t.bss_info_changed\t= rtw_ops_bss_info_changed,\n\t.start_ap\t\t= rtw_ops_start_ap,\n\t.stop_ap\t\t= rtw_ops_stop_ap,\n\t.conf_tx\t\t= rtw_ops_conf_tx,\n\t.sta_add\t\t= rtw_ops_sta_add,\n\t.sta_remove\t\t= rtw_ops_sta_remove,\n\t.set_tim\t\t= rtw_ops_set_tim,\n\t.set_key\t\t= rtw_ops_set_key,\n\t.ampdu_action\t\t= rtw_ops_ampdu_action,\n\t.can_aggregate_in_amsdu\t= rtw_ops_can_aggregate_in_amsdu,\n\t.sw_scan_start\t\t= rtw_ops_sw_scan_start,\n\t.sw_scan_complete\t= rtw_ops_sw_scan_complete,\n\t.mgd_prepare_tx\t\t= rtw_ops_mgd_prepare_tx,\n\t.set_rts_threshold\t= rtw_ops_set_rts_threshold,\n\t.sta_statistics\t\t= rtw_ops_sta_statistics,\n\t.flush\t\t\t= rtw_ops_flush,\n\t.set_bitrate_mask\t= rtw_ops_set_bitrate_mask,\n\t.set_antenna\t\t= rtw_ops_set_antenna,\n\t.get_antenna\t\t= rtw_ops_get_antenna,\n\t.reconfig_complete\t= rtw_reconfig_complete,\n\t.hw_scan\t\t= rtw_ops_hw_scan,\n\t.cancel_hw_scan\t\t= rtw_ops_cancel_hw_scan,\n\t.sta_rc_update\t\t= rtw_ops_sta_rc_update,\n\t.set_sar_specs          = rtw_ops_set_sar_specs,\n#ifdef CONFIG_PM\n\t.suspend\t\t= rtw_ops_suspend,\n\t.resume\t\t\t= rtw_ops_resume,\n\t.set_wakeup\t\t= rtw_ops_set_wakeup,\n#endif\n};\nEXPORT_SYMBOL(rtw_ops);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}