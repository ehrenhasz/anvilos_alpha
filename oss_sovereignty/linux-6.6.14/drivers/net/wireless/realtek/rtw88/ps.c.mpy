{
  "module_name": "ps.c",
  "hash_id": "574740b634d411137a44dca54144ace37680e1327846c4010ccd290cd4be12ee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtw88/ps.c",
  "human_readable_source": "\n \n\n#include \"main.h\"\n#include \"reg.h\"\n#include \"fw.h\"\n#include \"ps.h\"\n#include \"mac.h\"\n#include \"coex.h\"\n#include \"debug.h\"\n\nstatic int rtw_ips_pwr_up(struct rtw_dev *rtwdev)\n{\n\tint ret;\n\n\tret = rtw_core_start(rtwdev);\n\tif (ret)\n\t\trtw_err(rtwdev, \"leave idle state failed\\n\");\n\n\trtw_coex_ips_notify(rtwdev, COEX_IPS_LEAVE);\n\trtw_set_channel(rtwdev);\n\n\treturn ret;\n}\n\nint rtw_enter_ips(struct rtw_dev *rtwdev)\n{\n\tif (!test_bit(RTW_FLAG_POWERON, rtwdev->flags))\n\t\treturn 0;\n\n\trtw_coex_ips_notify(rtwdev, COEX_IPS_ENTER);\n\n\trtw_core_stop(rtwdev);\n\trtw_hci_link_ps(rtwdev, true);\n\n\treturn 0;\n}\n\nstatic void rtw_restore_port_cfg_iter(void *data, struct ieee80211_vif *vif)\n{\n\tstruct rtw_dev *rtwdev = data;\n\tstruct rtw_vif *rtwvif = (struct rtw_vif *)vif->drv_priv;\n\tu32 config = ~0;\n\n\trtw_vif_port_config(rtwdev, rtwvif, config);\n}\n\nint rtw_leave_ips(struct rtw_dev *rtwdev)\n{\n\tint ret;\n\n\tif (test_bit(RTW_FLAG_POWERON, rtwdev->flags))\n\t\treturn 0;\n\n\trtw_hci_link_ps(rtwdev, false);\n\n\tret = rtw_ips_pwr_up(rtwdev);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to leave ips state\\n\");\n\t\treturn ret;\n\t}\n\n\trtw_iterate_vifs(rtwdev, rtw_restore_port_cfg_iter, rtwdev);\n\n\treturn 0;\n}\n\nvoid rtw_power_mode_change(struct rtw_dev *rtwdev, bool enter)\n{\n\tu8 request, confirm, polling;\n\tint ret;\n\n\trequest = rtw_read8(rtwdev, rtwdev->hci.rpwm_addr);\n\tconfirm = rtw_read8(rtwdev, rtwdev->hci.cpwm_addr);\n\n\t \n\trequest ^= request | BIT_RPWM_TOGGLE;\n\tif (enter) {\n\t\trequest |= POWER_MODE_LCLK;\n\t\tif (rtw_get_lps_deep_mode(rtwdev) == LPS_DEEP_MODE_PG)\n\t\t\trequest |= POWER_MODE_PG;\n\t}\n\t \n\trequest |= POWER_MODE_ACK;\n\n\tif (rtw_fw_feature_check(&rtwdev->fw, FW_FEATURE_TX_WAKE))\n\t\trequest |= POWER_TX_WAKE;\n\n\trtw_write8(rtwdev, rtwdev->hci.rpwm_addr, request);\n\n\t \n\tret = read_poll_timeout_atomic(rtw_read8, polling,\n\t\t\t\t       (polling ^ confirm) & BIT_RPWM_TOGGLE,\n\t\t\t\t       100, 15000, true, rtwdev,\n\t\t\t\t       rtwdev->hci.cpwm_addr);\n\tif (ret) {\n\t\t \n\t\tWARN(1, \"firmware failed to ack driver for %s Deep Power mode\\n\",\n\t\t     enter ? \"entering\" : \"leaving\");\n\t}\n}\nEXPORT_SYMBOL(rtw_power_mode_change);\n\nstatic void __rtw_leave_lps_deep(struct rtw_dev *rtwdev)\n{\n\trtw_hci_deep_ps(rtwdev, false);\n}\n\nstatic int __rtw_fw_leave_lps_check_reg(struct rtw_dev *rtwdev)\n{\n\tint i;\n\n\t \n\tfor (i = 0 ; i < LEAVE_LPS_TRY_CNT; i++) {\n\t\tif (rtw_read32_mask(rtwdev, REG_TCR, BIT_PWRMGT_HWDATA_EN) == 0)\n\t\t\treturn 0;\n\t\tmsleep(20);\n\t}\n\n\treturn -EBUSY;\n}\n\nstatic  int __rtw_fw_leave_lps_check_c2h(struct rtw_dev *rtwdev)\n{\n\tif (wait_for_completion_timeout(&rtwdev->lps_leave_check,\n\t\t\t\t\tLEAVE_LPS_TIMEOUT))\n\t\treturn 0;\n\treturn -EBUSY;\n}\n\nstatic void rtw_fw_leave_lps_check(struct rtw_dev *rtwdev)\n{\n\tbool ret = false;\n\tstruct rtw_fw_state *fw;\n\n\tif (test_bit(RTW_FLAG_WOWLAN, rtwdev->flags))\n\t\tfw = &rtwdev->wow_fw;\n\telse\n\t\tfw = &rtwdev->fw;\n\n\tif (rtw_fw_feature_check(fw, FW_FEATURE_LPS_C2H))\n\t\tret = __rtw_fw_leave_lps_check_c2h(rtwdev);\n\telse\n\t\tret = __rtw_fw_leave_lps_check_reg(rtwdev);\n\n\tif (ret) {\n\t\trtw_write32_clr(rtwdev, REG_TCR, BIT_PWRMGT_HWDATA_EN);\n\t\trtw_warn(rtwdev, \"firmware failed to leave lps state\\n\");\n\t}\n}\n\nstatic void rtw_fw_leave_lps_check_prepare(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_fw_state *fw;\n\n\tif (test_bit(RTW_FLAG_WOWLAN, rtwdev->flags))\n\t\tfw = &rtwdev->wow_fw;\n\telse\n\t\tfw = &rtwdev->fw;\n\n\tif (rtw_fw_feature_check(fw, FW_FEATURE_LPS_C2H))\n\t\treinit_completion(&rtwdev->lps_leave_check);\n}\n\nstatic void rtw_leave_lps_core(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_lps_conf *conf = &rtwdev->lps_conf;\n\n\tconf->state = RTW_ALL_ON;\n\tconf->awake_interval = 1;\n\tconf->rlbm = 0;\n\tconf->smart_ps = 0;\n\n\trtw_hci_link_ps(rtwdev, false);\n\trtw_fw_leave_lps_check_prepare(rtwdev);\n\trtw_fw_set_pwr_mode(rtwdev);\n\trtw_fw_leave_lps_check(rtwdev);\n\n\tclear_bit(RTW_FLAG_LEISURE_PS, rtwdev->flags);\n\n\trtw_coex_lps_notify(rtwdev, COEX_LPS_DISABLE);\n}\n\nenum rtw_lps_deep_mode rtw_get_lps_deep_mode(struct rtw_dev *rtwdev)\n{\n\tif (test_bit(RTW_FLAG_WOWLAN, rtwdev->flags))\n\t\treturn rtwdev->lps_conf.wow_deep_mode;\n\telse\n\t\treturn rtwdev->lps_conf.deep_mode;\n}\n\nstatic void __rtw_enter_lps_deep(struct rtw_dev *rtwdev)\n{\n\tif (rtw_get_lps_deep_mode(rtwdev) == LPS_DEEP_MODE_NONE)\n\t\treturn;\n\n\tif (!test_bit(RTW_FLAG_LEISURE_PS, rtwdev->flags)) {\n\t\trtw_dbg(rtwdev, RTW_DBG_PS,\n\t\t\t\"Should enter LPS before entering deep PS\\n\");\n\t\treturn;\n\t}\n\n\tif (rtw_get_lps_deep_mode(rtwdev) == LPS_DEEP_MODE_PG)\n\t\trtw_fw_set_pg_info(rtwdev);\n\n\trtw_hci_deep_ps(rtwdev, true);\n}\n\nstatic void rtw_enter_lps_core(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_lps_conf *conf = &rtwdev->lps_conf;\n\n\tconf->state = RTW_RF_OFF;\n\tconf->awake_interval = 1;\n\tconf->rlbm = 1;\n\tconf->smart_ps = 2;\n\n\trtw_coex_lps_notify(rtwdev, COEX_LPS_ENABLE);\n\n\trtw_fw_set_pwr_mode(rtwdev);\n\trtw_hci_link_ps(rtwdev, true);\n\n\tset_bit(RTW_FLAG_LEISURE_PS, rtwdev->flags);\n}\n\nstatic void __rtw_enter_lps(struct rtw_dev *rtwdev, u8 port_id)\n{\n\tstruct rtw_lps_conf *conf = &rtwdev->lps_conf;\n\n\tif (test_bit(RTW_FLAG_LEISURE_PS, rtwdev->flags))\n\t\treturn;\n\n\tconf->mode = RTW_MODE_LPS;\n\tconf->port_id = port_id;\n\n\trtw_enter_lps_core(rtwdev);\n}\n\nstatic void __rtw_leave_lps(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_lps_conf *conf = &rtwdev->lps_conf;\n\n\tif (test_and_clear_bit(RTW_FLAG_LEISURE_PS_DEEP, rtwdev->flags)) {\n\t\trtw_dbg(rtwdev, RTW_DBG_PS,\n\t\t\t\"Should leave deep PS before leaving LPS\\n\");\n\t\t__rtw_leave_lps_deep(rtwdev);\n\t}\n\n\tif (!test_bit(RTW_FLAG_LEISURE_PS, rtwdev->flags))\n\t\treturn;\n\n\tconf->mode = RTW_MODE_ACTIVE;\n\n\trtw_leave_lps_core(rtwdev);\n}\n\nvoid rtw_enter_lps(struct rtw_dev *rtwdev, u8 port_id)\n{\n\tlockdep_assert_held(&rtwdev->mutex);\n\n\tif (rtwdev->coex.stat.wl_force_lps_ctrl)\n\t\treturn;\n\n\t__rtw_enter_lps(rtwdev, port_id);\n\t__rtw_enter_lps_deep(rtwdev);\n}\n\nvoid rtw_leave_lps(struct rtw_dev *rtwdev)\n{\n\tlockdep_assert_held(&rtwdev->mutex);\n\n\t__rtw_leave_lps_deep(rtwdev);\n\t__rtw_leave_lps(rtwdev);\n}\n\nvoid rtw_leave_lps_deep(struct rtw_dev *rtwdev)\n{\n\tlockdep_assert_held(&rtwdev->mutex);\n\n\t__rtw_leave_lps_deep(rtwdev);\n}\n\nstruct rtw_vif_recalc_lps_iter_data {\n\tstruct rtw_dev *rtwdev;\n\tstruct ieee80211_vif *found_vif;\n\tint count;\n};\n\nstatic void __rtw_vif_recalc_lps(struct rtw_vif_recalc_lps_iter_data *data,\n\t\t\t\t struct ieee80211_vif *vif)\n{\n\tif (data->count < 0)\n\t\treturn;\n\n\tif (vif->type != NL80211_IFTYPE_STATION) {\n\t\tdata->count = -1;\n\t\treturn;\n\t}\n\n\tdata->count++;\n\tdata->found_vif = vif;\n}\n\nstatic void rtw_vif_recalc_lps_iter(void *data, struct ieee80211_vif *vif)\n{\n\t__rtw_vif_recalc_lps(data, vif);\n}\n\nvoid rtw_recalc_lps(struct rtw_dev *rtwdev, struct ieee80211_vif *new_vif)\n{\n\tstruct rtw_vif_recalc_lps_iter_data data = { .rtwdev = rtwdev };\n\n\tif (new_vif)\n\t\t__rtw_vif_recalc_lps(&data, new_vif);\n\trtw_iterate_vifs(rtwdev, rtw_vif_recalc_lps_iter, &data);\n\n\tif (data.count == 1 && data.found_vif->cfg.ps) {\n\t\trtwdev->ps_enabled = true;\n\t} else {\n\t\trtwdev->ps_enabled = false;\n\t\trtw_leave_lps(rtwdev);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}