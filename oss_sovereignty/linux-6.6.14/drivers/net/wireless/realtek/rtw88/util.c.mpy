{
  "module_name": "util.c",
  "hash_id": "5c08bc4d7e06f35da6928c3bb100cb9216eaab1d6f4ab54c01d1553e6befd486",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtw88/util.c",
  "human_readable_source": "\n \n\n#include \"main.h\"\n#include \"util.h\"\n#include \"reg.h\"\n\nbool check_hw_ready(struct rtw_dev *rtwdev, u32 addr, u32 mask, u32 target)\n{\n\tu32 cnt;\n\n\tfor (cnt = 0; cnt < 1000; cnt++) {\n\t\tif (rtw_read32_mask(rtwdev, addr, mask) == target)\n\t\t\treturn true;\n\n\t\tudelay(10);\n\t}\n\n\treturn false;\n}\nEXPORT_SYMBOL(check_hw_ready);\n\nbool ltecoex_read_reg(struct rtw_dev *rtwdev, u16 offset, u32 *val)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tconst struct rtw_ltecoex_addr *ltecoex = chip->ltecoex_addr;\n\n\tif (!check_hw_ready(rtwdev, ltecoex->ctrl, LTECOEX_READY, 1))\n\t\treturn false;\n\n\trtw_write32(rtwdev, ltecoex->ctrl, 0x800F0000 | offset);\n\t*val = rtw_read32(rtwdev, ltecoex->rdata);\n\n\treturn true;\n}\n\nbool ltecoex_reg_write(struct rtw_dev *rtwdev, u16 offset, u32 value)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tconst struct rtw_ltecoex_addr *ltecoex = chip->ltecoex_addr;\n\n\tif (!check_hw_ready(rtwdev, ltecoex->ctrl, LTECOEX_READY, 1))\n\t\treturn false;\n\n\trtw_write32(rtwdev, ltecoex->wdata, value);\n\trtw_write32(rtwdev, ltecoex->ctrl, 0xC00F0000 | offset);\n\n\treturn true;\n}\n\nvoid rtw_restore_reg(struct rtw_dev *rtwdev,\n\t\t     struct rtw_backup_info *bckp, u32 num)\n{\n\tu8 len;\n\tu32 reg;\n\tu32 val;\n\tint i;\n\n\tfor (i = 0; i < num; i++, bckp++) {\n\t\tlen = bckp->len;\n\t\treg = bckp->reg;\n\t\tval = bckp->val;\n\n\t\tswitch (len) {\n\t\tcase 1:\n\t\t\trtw_write8(rtwdev, reg, (u8)val);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\trtw_write16(rtwdev, reg, (u16)val);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\trtw_write32(rtwdev, reg, (u32)val);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(rtw_restore_reg);\n\nvoid rtw_desc_to_mcsrate(u16 rate, u8 *mcs, u8 *nss)\n{\n\tif (rate <= DESC_RATE54M)\n\t\treturn;\n\n\tif (rate >= DESC_RATEVHT1SS_MCS0 &&\n\t    rate <= DESC_RATEVHT1SS_MCS9) {\n\t\t*nss = 1;\n\t\t*mcs = rate - DESC_RATEVHT1SS_MCS0;\n\t} else if (rate >= DESC_RATEVHT2SS_MCS0 &&\n\t\t   rate <= DESC_RATEVHT2SS_MCS9) {\n\t\t*nss = 2;\n\t\t*mcs = rate - DESC_RATEVHT2SS_MCS0;\n\t} else if (rate >= DESC_RATEVHT3SS_MCS0 &&\n\t\t   rate <= DESC_RATEVHT3SS_MCS9) {\n\t\t*nss = 3;\n\t\t*mcs = rate - DESC_RATEVHT3SS_MCS0;\n\t} else if (rate >= DESC_RATEVHT4SS_MCS0 &&\n\t\t   rate <= DESC_RATEVHT4SS_MCS9) {\n\t\t*nss = 4;\n\t\t*mcs = rate - DESC_RATEVHT4SS_MCS0;\n\t} else if (rate >= DESC_RATEMCS0 &&\n\t\t   rate <= DESC_RATEMCS15) {\n\t\t*mcs = rate - DESC_RATEMCS0;\n\t}\n}\n\nstruct rtw_stas_entry {\n\tstruct list_head list;\n\tstruct ieee80211_sta *sta;\n};\n\nstruct rtw_iter_stas_data {\n\tstruct rtw_dev *rtwdev;\n\tstruct list_head list;\n};\n\nstatic void rtw_collect_sta_iter(void *data, struct ieee80211_sta *sta)\n{\n\tstruct rtw_iter_stas_data *iter_stas = data;\n\tstruct rtw_stas_entry *stas_entry;\n\n\tstas_entry = kmalloc(sizeof(*stas_entry), GFP_ATOMIC);\n\tif (!stas_entry)\n\t\treturn;\n\n\tstas_entry->sta = sta;\n\tlist_add_tail(&stas_entry->list, &iter_stas->list);\n}\n\nvoid rtw_iterate_stas(struct rtw_dev *rtwdev,\n\t\t      void (*iterator)(void *data,\n\t\t\t\t       struct ieee80211_sta *sta),\n\t\t      void *data)\n{\n\tstruct rtw_iter_stas_data iter_data;\n\tstruct rtw_stas_entry *sta_entry, *tmp;\n\n\t \n\tlockdep_assert_held(&rtwdev->mutex);\n\n\titer_data.rtwdev = rtwdev;\n\tINIT_LIST_HEAD(&iter_data.list);\n\n\tieee80211_iterate_stations_atomic(rtwdev->hw, rtw_collect_sta_iter,\n\t\t\t\t\t  &iter_data);\n\n\tlist_for_each_entry_safe(sta_entry, tmp, &iter_data.list,\n\t\t\t\t list) {\n\t\tlist_del_init(&sta_entry->list);\n\t\titerator(data, sta_entry->sta);\n\t\tkfree(sta_entry);\n\t}\n}\n\nstruct rtw_vifs_entry {\n\tstruct list_head list;\n\tstruct ieee80211_vif *vif;\n};\n\nstruct rtw_iter_vifs_data {\n\tstruct rtw_dev *rtwdev;\n\tstruct list_head list;\n};\n\nstatic void rtw_collect_vif_iter(void *data, u8 *mac, struct ieee80211_vif *vif)\n{\n\tstruct rtw_iter_vifs_data *iter_stas = data;\n\tstruct rtw_vifs_entry *vifs_entry;\n\n\tvifs_entry = kmalloc(sizeof(*vifs_entry), GFP_ATOMIC);\n\tif (!vifs_entry)\n\t\treturn;\n\n\tvifs_entry->vif = vif;\n\tlist_add_tail(&vifs_entry->list, &iter_stas->list);\n}\n\nvoid rtw_iterate_vifs(struct rtw_dev *rtwdev,\n\t\t      void (*iterator)(void *data, struct ieee80211_vif *vif),\n\t\t      void *data)\n{\n\tstruct rtw_iter_vifs_data iter_data;\n\tstruct rtw_vifs_entry *vif_entry, *tmp;\n\n\t \n\tlockdep_assert_held(&rtwdev->mutex);\n\n\titer_data.rtwdev = rtwdev;\n\tINIT_LIST_HEAD(&iter_data.list);\n\n\tieee80211_iterate_active_interfaces_atomic(rtwdev->hw,\n\t\t\t\t\t\t   IEEE80211_IFACE_ITER_NORMAL,\n\t\t\t\t\t\t   rtw_collect_vif_iter, &iter_data);\n\n\tlist_for_each_entry_safe(vif_entry, tmp, &iter_data.list,\n\t\t\t\t list) {\n\t\tlist_del_init(&vif_entry->list);\n\t\titerator(data, vif_entry->vif);\n\t\tkfree(vif_entry);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}