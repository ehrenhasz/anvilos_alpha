{
  "module_name": "usb.c",
  "hash_id": "8c8c8cb43af5ac9a6f450e1832ec013c39293d18c23ef656a90a867ce409627b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtw88/usb.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/usb.h>\n#include <linux/mutex.h>\n#include \"main.h\"\n#include \"debug.h\"\n#include \"reg.h\"\n#include \"tx.h\"\n#include \"rx.h\"\n#include \"fw.h\"\n#include \"ps.h\"\n#include \"usb.h\"\n\n#define RTW_USB_MAX_RXQ_LEN\t512\n\nstruct rtw_usb_txcb {\n\tstruct rtw_dev *rtwdev;\n\tstruct sk_buff_head tx_ack_queue;\n};\n\nstatic void rtw_usb_fill_tx_checksum(struct rtw_usb *rtwusb,\n\t\t\t\t     struct sk_buff *skb, int agg_num)\n{\n\tstruct rtw_tx_desc *tx_desc = (struct rtw_tx_desc *)skb->data;\n\tstruct rtw_dev *rtwdev = rtwusb->rtwdev;\n\tstruct rtw_tx_pkt_info pkt_info;\n\n\tle32p_replace_bits(&tx_desc->w7, agg_num, RTW_TX_DESC_W7_DMA_TXAGG_NUM);\n\tpkt_info.pkt_offset = le32_get_bits(tx_desc->w1, RTW_TX_DESC_W1_PKT_OFFSET);\n\trtw_tx_fill_txdesc_checksum(rtwdev, &pkt_info, skb->data);\n}\n\nstatic u32 rtw_usb_read(struct rtw_dev *rtwdev, u32 addr, u16 len)\n{\n\tstruct rtw_usb *rtwusb = rtw_get_usb_priv(rtwdev);\n\tstruct usb_device *udev = rtwusb->udev;\n\t__le32 *data;\n\tunsigned long flags;\n\tint idx, ret;\n\tstatic int count;\n\n\tspin_lock_irqsave(&rtwusb->usb_lock, flags);\n\n\tidx = rtwusb->usb_data_index;\n\trtwusb->usb_data_index = (idx + 1) & (RTW_USB_MAX_RXTX_COUNT - 1);\n\n\tspin_unlock_irqrestore(&rtwusb->usb_lock, flags);\n\n\tdata = &rtwusb->usb_data[idx];\n\n\tret = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\n\t\t\t      RTW_USB_CMD_REQ, RTW_USB_CMD_READ, addr,\n\t\t\t      RTW_USB_VENQT_CMD_IDX, data, len, 1000);\n\tif (ret < 0 && ret != -ENODEV && count++ < 4)\n\t\trtw_err(rtwdev, \"read register 0x%x failed with %d\\n\",\n\t\t\taddr, ret);\n\n\treturn le32_to_cpu(*data);\n}\n\nstatic u8 rtw_usb_read8(struct rtw_dev *rtwdev, u32 addr)\n{\n\treturn (u8)rtw_usb_read(rtwdev, addr, 1);\n}\n\nstatic u16 rtw_usb_read16(struct rtw_dev *rtwdev, u32 addr)\n{\n\treturn (u16)rtw_usb_read(rtwdev, addr, 2);\n}\n\nstatic u32 rtw_usb_read32(struct rtw_dev *rtwdev, u32 addr)\n{\n\treturn (u32)rtw_usb_read(rtwdev, addr, 4);\n}\n\nstatic void rtw_usb_write(struct rtw_dev *rtwdev, u32 addr, u32 val, int len)\n{\n\tstruct rtw_usb *rtwusb = (struct rtw_usb *)rtwdev->priv;\n\tstruct usb_device *udev = rtwusb->udev;\n\tunsigned long flags;\n\t__le32 *data;\n\tint idx, ret;\n\tstatic int count;\n\n\tspin_lock_irqsave(&rtwusb->usb_lock, flags);\n\n\tidx = rtwusb->usb_data_index;\n\trtwusb->usb_data_index = (idx + 1) & (RTW_USB_MAX_RXTX_COUNT - 1);\n\n\tspin_unlock_irqrestore(&rtwusb->usb_lock, flags);\n\n\tdata = &rtwusb->usb_data[idx];\n\n\t*data = cpu_to_le32(val);\n\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t      RTW_USB_CMD_REQ, RTW_USB_CMD_WRITE,\n\t\t\t      addr, 0, data, len, 30000);\n\tif (ret < 0 && ret != -ENODEV && count++ < 4)\n\t\trtw_err(rtwdev, \"write register 0x%x failed with %d\\n\",\n\t\t\taddr, ret);\n}\n\nstatic void rtw_usb_write8(struct rtw_dev *rtwdev, u32 addr, u8 val)\n{\n\trtw_usb_write(rtwdev, addr, val, 1);\n}\n\nstatic void rtw_usb_write16(struct rtw_dev *rtwdev, u32 addr, u16 val)\n{\n\trtw_usb_write(rtwdev, addr, val, 2);\n}\n\nstatic void rtw_usb_write32(struct rtw_dev *rtwdev, u32 addr, u32 val)\n{\n\trtw_usb_write(rtwdev, addr, val, 4);\n}\n\nstatic int dma_mapping_to_ep(enum rtw_dma_mapping dma_mapping)\n{\n\tswitch (dma_mapping) {\n\tcase RTW_DMA_MAPPING_HIGH:\n\t\treturn 0;\n\tcase RTW_DMA_MAPPING_NORMAL:\n\t\treturn 1;\n\tcase RTW_DMA_MAPPING_LOW:\n\t\treturn 2;\n\tcase RTW_DMA_MAPPING_EXTRA:\n\t\treturn 3;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int rtw_usb_parse(struct rtw_dev *rtwdev,\n\t\t\t struct usb_interface *interface)\n{\n\tstruct rtw_usb *rtwusb = rtw_get_usb_priv(rtwdev);\n\tstruct usb_host_interface *host_interface = &interface->altsetting[0];\n\tstruct usb_interface_descriptor *interface_desc = &host_interface->desc;\n\tstruct usb_endpoint_descriptor *endpoint;\n\tint num_out_pipes = 0;\n\tint i;\n\tu8 num;\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tconst struct rtw_rqpn *rqpn;\n\n\tfor (i = 0; i < interface_desc->bNumEndpoints; i++) {\n\t\tendpoint = &host_interface->endpoint[i].desc;\n\t\tnum = usb_endpoint_num(endpoint);\n\n\t\tif (usb_endpoint_dir_in(endpoint) &&\n\t\t    usb_endpoint_xfer_bulk(endpoint)) {\n\t\t\tif (rtwusb->pipe_in) {\n\t\t\t\trtw_err(rtwdev, \"IN pipes overflow\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\trtwusb->pipe_in = num;\n\t\t}\n\n\t\tif (usb_endpoint_dir_in(endpoint) &&\n\t\t    usb_endpoint_xfer_int(endpoint)) {\n\t\t\tif (rtwusb->pipe_interrupt) {\n\t\t\t\trtw_err(rtwdev, \"INT pipes overflow\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\trtwusb->pipe_interrupt = num;\n\t\t}\n\n\t\tif (usb_endpoint_dir_out(endpoint) &&\n\t\t    usb_endpoint_xfer_bulk(endpoint)) {\n\t\t\tif (num_out_pipes >= ARRAY_SIZE(rtwusb->out_ep)) {\n\t\t\t\trtw_err(rtwdev, \"OUT pipes overflow\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\trtwusb->out_ep[num_out_pipes++] = num;\n\t\t}\n\t}\n\n\trtwdev->hci.bulkout_num = num_out_pipes;\n\n\tif (num_out_pipes < 1 || num_out_pipes > 4) {\n\t\trtw_err(rtwdev, \"invalid number of endpoints %d\\n\", num_out_pipes);\n\t\treturn -EINVAL;\n\t}\n\n\trqpn = &chip->rqpn_table[num_out_pipes];\n\n\trtwusb->qsel_to_ep[TX_DESC_QSEL_TID0] = dma_mapping_to_ep(rqpn->dma_map_be);\n\trtwusb->qsel_to_ep[TX_DESC_QSEL_TID1] = dma_mapping_to_ep(rqpn->dma_map_bk);\n\trtwusb->qsel_to_ep[TX_DESC_QSEL_TID2] = dma_mapping_to_ep(rqpn->dma_map_bk);\n\trtwusb->qsel_to_ep[TX_DESC_QSEL_TID3] = dma_mapping_to_ep(rqpn->dma_map_be);\n\trtwusb->qsel_to_ep[TX_DESC_QSEL_TID4] = dma_mapping_to_ep(rqpn->dma_map_vi);\n\trtwusb->qsel_to_ep[TX_DESC_QSEL_TID5] = dma_mapping_to_ep(rqpn->dma_map_vi);\n\trtwusb->qsel_to_ep[TX_DESC_QSEL_TID6] = dma_mapping_to_ep(rqpn->dma_map_vo);\n\trtwusb->qsel_to_ep[TX_DESC_QSEL_TID7] = dma_mapping_to_ep(rqpn->dma_map_vo);\n\trtwusb->qsel_to_ep[TX_DESC_QSEL_TID8] = -EINVAL;\n\trtwusb->qsel_to_ep[TX_DESC_QSEL_TID9] = -EINVAL;\n\trtwusb->qsel_to_ep[TX_DESC_QSEL_TID10] = -EINVAL;\n\trtwusb->qsel_to_ep[TX_DESC_QSEL_TID11] = -EINVAL;\n\trtwusb->qsel_to_ep[TX_DESC_QSEL_TID12] = -EINVAL;\n\trtwusb->qsel_to_ep[TX_DESC_QSEL_TID13] = -EINVAL;\n\trtwusb->qsel_to_ep[TX_DESC_QSEL_TID14] = -EINVAL;\n\trtwusb->qsel_to_ep[TX_DESC_QSEL_TID15] = -EINVAL;\n\trtwusb->qsel_to_ep[TX_DESC_QSEL_BEACON] = dma_mapping_to_ep(rqpn->dma_map_hi);\n\trtwusb->qsel_to_ep[TX_DESC_QSEL_HIGH] = dma_mapping_to_ep(rqpn->dma_map_hi);\n\trtwusb->qsel_to_ep[TX_DESC_QSEL_MGMT] = dma_mapping_to_ep(rqpn->dma_map_mg);\n\trtwusb->qsel_to_ep[TX_DESC_QSEL_H2C] = dma_mapping_to_ep(rqpn->dma_map_hi);\n\n\treturn 0;\n}\n\nstatic void rtw_usb_write_port_tx_complete(struct urb *urb)\n{\n\tstruct rtw_usb_txcb *txcb = urb->context;\n\tstruct rtw_dev *rtwdev = txcb->rtwdev;\n\tstruct ieee80211_hw *hw = rtwdev->hw;\n\n\twhile (true) {\n\t\tstruct sk_buff *skb = skb_dequeue(&txcb->tx_ack_queue);\n\t\tstruct ieee80211_tx_info *info;\n\t\tstruct rtw_usb_tx_data *tx_data;\n\n\t\tif (!skb)\n\t\t\tbreak;\n\n\t\tinfo = IEEE80211_SKB_CB(skb);\n\t\ttx_data = rtw_usb_get_tx_data(skb);\n\n\t\t \n\t\tif (info->flags & IEEE80211_TX_CTL_REQ_TX_STATUS) {\n\t\t\trtw_tx_report_enqueue(rtwdev, skb, tx_data->sn);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tieee80211_tx_info_clear_status(info);\n\t\tif (info->flags & IEEE80211_TX_CTL_NO_ACK)\n\t\t\tinfo->flags |= IEEE80211_TX_STAT_NOACK_TRANSMITTED;\n\t\telse\n\t\t\tinfo->flags |= IEEE80211_TX_STAT_ACK;\n\n\t\tieee80211_tx_status_irqsafe(hw, skb);\n\t}\n\n\tkfree(txcb);\n}\n\nstatic int qsel_to_ep(struct rtw_usb *rtwusb, unsigned int qsel)\n{\n\tif (qsel >= ARRAY_SIZE(rtwusb->qsel_to_ep))\n\t\treturn -EINVAL;\n\n\treturn rtwusb->qsel_to_ep[qsel];\n}\n\nstatic int rtw_usb_write_port(struct rtw_dev *rtwdev, u8 qsel, struct sk_buff *skb,\n\t\t\t      usb_complete_t cb, void *context)\n{\n\tstruct rtw_usb *rtwusb = rtw_get_usb_priv(rtwdev);\n\tstruct usb_device *usbd = rtwusb->udev;\n\tstruct urb *urb;\n\tunsigned int pipe;\n\tint ret;\n\tint ep = qsel_to_ep(rtwusb, qsel);\n\n\tif (ep < 0)\n\t\treturn ep;\n\n\tpipe = usb_sndbulkpipe(usbd, rtwusb->out_ep[ep]);\n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\n\tusb_fill_bulk_urb(urb, usbd, pipe, skb->data, skb->len, cb, context);\n\turb->transfer_flags |= URB_ZERO_PACKET;\n\tret = usb_submit_urb(urb, GFP_ATOMIC);\n\n\tusb_free_urb(urb);\n\n\treturn ret;\n}\n\nstatic bool rtw_usb_tx_agg_skb(struct rtw_usb *rtwusb, struct sk_buff_head *list)\n{\n\tstruct rtw_dev *rtwdev = rtwusb->rtwdev;\n\tstruct rtw_tx_desc *tx_desc;\n\tstruct rtw_usb_txcb *txcb;\n\tstruct sk_buff *skb_head;\n\tstruct sk_buff *skb_iter;\n\tint agg_num = 0;\n\tunsigned int align_next = 0;\n\tu8 qsel;\n\n\tif (skb_queue_empty(list))\n\t\treturn false;\n\n\ttxcb = kmalloc(sizeof(*txcb), GFP_ATOMIC);\n\tif (!txcb)\n\t\treturn false;\n\n\ttxcb->rtwdev = rtwdev;\n\tskb_queue_head_init(&txcb->tx_ack_queue);\n\n\tskb_iter = skb_dequeue(list);\n\n\tif (skb_queue_empty(list)) {\n\t\tskb_head = skb_iter;\n\t\tgoto queue;\n\t}\n\n\tskb_head = dev_alloc_skb(RTW_USB_MAX_XMITBUF_SZ);\n\tif (!skb_head) {\n\t\tskb_head = skb_iter;\n\t\tgoto queue;\n\t}\n\n\twhile (skb_iter) {\n\t\tunsigned long flags;\n\n\t\tskb_put(skb_head, align_next);\n\t\tskb_put_data(skb_head, skb_iter->data, skb_iter->len);\n\n\t\talign_next = ALIGN(skb_iter->len, 8) - skb_iter->len;\n\n\t\tagg_num++;\n\n\t\tskb_queue_tail(&txcb->tx_ack_queue, skb_iter);\n\n\t\tspin_lock_irqsave(&list->lock, flags);\n\n\t\tskb_iter = skb_peek(list);\n\n\t\tif (skb_iter && skb_iter->len + skb_head->len <= RTW_USB_MAX_XMITBUF_SZ)\n\t\t\t__skb_unlink(skb_iter, list);\n\t\telse\n\t\t\tskb_iter = NULL;\n\t\tspin_unlock_irqrestore(&list->lock, flags);\n\t}\n\n\tif (agg_num > 1)\n\t\trtw_usb_fill_tx_checksum(rtwusb, skb_head, agg_num);\n\nqueue:\n\tskb_queue_tail(&txcb->tx_ack_queue, skb_head);\n\ttx_desc = (struct rtw_tx_desc *)skb_head->data;\n\tqsel = le32_get_bits(tx_desc->w1, RTW_TX_DESC_W1_QSEL);\n\n\trtw_usb_write_port(rtwdev, qsel, skb_head, rtw_usb_write_port_tx_complete, txcb);\n\n\treturn true;\n}\n\nstatic void rtw_usb_tx_handler(struct work_struct *work)\n{\n\tstruct rtw_usb *rtwusb = container_of(work, struct rtw_usb, tx_work);\n\tint i, limit;\n\n\tfor (i = ARRAY_SIZE(rtwusb->tx_queue) - 1; i >= 0; i--) {\n\t\tfor (limit = 0; limit < 200; limit++) {\n\t\t\tstruct sk_buff_head *list = &rtwusb->tx_queue[i];\n\n\t\t\tif (!rtw_usb_tx_agg_skb(rtwusb, list))\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void rtw_usb_tx_queue_purge(struct rtw_usb *rtwusb)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(rtwusb->tx_queue); i++)\n\t\tskb_queue_purge(&rtwusb->tx_queue[i]);\n}\n\nstatic void rtw_usb_write_port_complete(struct urb *urb)\n{\n\tstruct sk_buff *skb = urb->context;\n\n\tdev_kfree_skb_any(skb);\n}\n\nstatic int rtw_usb_write_data(struct rtw_dev *rtwdev,\n\t\t\t      struct rtw_tx_pkt_info *pkt_info,\n\t\t\t      u8 *buf)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct sk_buff *skb;\n\tunsigned int desclen, headsize, size;\n\tu8 qsel;\n\tint ret = 0;\n\n\tsize = pkt_info->tx_pkt_size;\n\tqsel = pkt_info->qsel;\n\tdesclen = chip->tx_pkt_desc_sz;\n\theadsize = pkt_info->offset ? pkt_info->offset : desclen;\n\n\tskb = dev_alloc_skb(headsize + size);\n\tif (unlikely(!skb))\n\t\treturn -ENOMEM;\n\n\tskb_reserve(skb, headsize);\n\tskb_put_data(skb, buf, size);\n\tskb_push(skb, headsize);\n\tmemset(skb->data, 0, headsize);\n\trtw_tx_fill_tx_desc(pkt_info, skb);\n\trtw_tx_fill_txdesc_checksum(rtwdev, pkt_info, skb->data);\n\n\tret = rtw_usb_write_port(rtwdev, qsel, skb,\n\t\t\t\t rtw_usb_write_port_complete, skb);\n\tif (unlikely(ret))\n\t\trtw_err(rtwdev, \"failed to do USB write, ret=%d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int rtw_usb_write_data_rsvd_page(struct rtw_dev *rtwdev, u8 *buf,\n\t\t\t\t\tu32 size)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_tx_pkt_info pkt_info = {0};\n\n\tpkt_info.tx_pkt_size = size;\n\tpkt_info.qsel = TX_DESC_QSEL_BEACON;\n\tpkt_info.offset = chip->tx_pkt_desc_sz;\n\n\treturn rtw_usb_write_data(rtwdev, &pkt_info, buf);\n}\n\nstatic int rtw_usb_write_data_h2c(struct rtw_dev *rtwdev, u8 *buf, u32 size)\n{\n\tstruct rtw_tx_pkt_info pkt_info = {0};\n\n\tpkt_info.tx_pkt_size = size;\n\tpkt_info.qsel = TX_DESC_QSEL_H2C;\n\n\treturn rtw_usb_write_data(rtwdev, &pkt_info, buf);\n}\n\nstatic u8 rtw_usb_tx_queue_mapping_to_qsel(struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\t__le16 fc = hdr->frame_control;\n\tu8 qsel;\n\n\tif (unlikely(ieee80211_is_mgmt(fc) || ieee80211_is_ctl(fc)))\n\t\tqsel = TX_DESC_QSEL_MGMT;\n\telse if (is_broadcast_ether_addr(hdr->addr1) ||\n\t\t is_multicast_ether_addr(hdr->addr1))\n\t\tqsel = TX_DESC_QSEL_HIGH;\n\telse if (skb_get_queue_mapping(skb) <= IEEE80211_AC_BK)\n\t\tqsel = skb->priority;\n\telse\n\t\tqsel = TX_DESC_QSEL_BEACON;\n\n\treturn qsel;\n}\n\nstatic int rtw_usb_tx_write(struct rtw_dev *rtwdev,\n\t\t\t    struct rtw_tx_pkt_info *pkt_info,\n\t\t\t    struct sk_buff *skb)\n{\n\tstruct rtw_usb *rtwusb = rtw_get_usb_priv(rtwdev);\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_usb_tx_data *tx_data;\n\tu8 *pkt_desc;\n\tint ep;\n\n\tpkt_info->qsel = rtw_usb_tx_queue_mapping_to_qsel(skb);\n\tpkt_desc = skb_push(skb, chip->tx_pkt_desc_sz);\n\tmemset(pkt_desc, 0, chip->tx_pkt_desc_sz);\n\tep = qsel_to_ep(rtwusb, pkt_info->qsel);\n\trtw_tx_fill_tx_desc(pkt_info, skb);\n\trtw_tx_fill_txdesc_checksum(rtwdev, pkt_info, skb->data);\n\ttx_data = rtw_usb_get_tx_data(skb);\n\ttx_data->sn = pkt_info->sn;\n\n\tskb_queue_tail(&rtwusb->tx_queue[ep], skb);\n\n\treturn 0;\n}\n\nstatic void rtw_usb_tx_kick_off(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_usb *rtwusb = rtw_get_usb_priv(rtwdev);\n\n\tqueue_work(rtwusb->txwq, &rtwusb->tx_work);\n}\n\nstatic void rtw_usb_rx_handler(struct work_struct *work)\n{\n\tstruct rtw_usb *rtwusb = container_of(work, struct rtw_usb, rx_work);\n\tstruct rtw_dev *rtwdev = rtwusb->rtwdev;\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_rx_pkt_stat pkt_stat;\n\tstruct ieee80211_rx_status rx_status;\n\tstruct sk_buff *skb;\n\tu32 pkt_desc_sz = chip->rx_pkt_desc_sz;\n\tu32 pkt_offset;\n\tu8 *rx_desc;\n\tint limit;\n\n\tfor (limit = 0; limit < 200; limit++) {\n\t\tskb = skb_dequeue(&rtwusb->rx_queue);\n\t\tif (!skb)\n\t\t\tbreak;\n\n\t\trx_desc = skb->data;\n\t\tchip->ops->query_rx_desc(rtwdev, rx_desc, &pkt_stat,\n\t\t\t\t\t &rx_status);\n\t\tpkt_offset = pkt_desc_sz + pkt_stat.drv_info_sz +\n\t\t\t     pkt_stat.shift;\n\n\t\tif (pkt_stat.is_c2h) {\n\t\t\tskb_put(skb, pkt_stat.pkt_len + pkt_offset);\n\t\t\trtw_fw_c2h_cmd_rx_irqsafe(rtwdev, pkt_offset, skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (skb_queue_len(&rtwusb->rx_queue) >= RTW_USB_MAX_RXQ_LEN) {\n\t\t\tdev_dbg_ratelimited(rtwdev->dev, \"failed to get rx_queue, overflow\\n\");\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tskb_put(skb, pkt_stat.pkt_len);\n\t\tskb_reserve(skb, pkt_offset);\n\t\tmemcpy(skb->cb, &rx_status, sizeof(rx_status));\n\t\tieee80211_rx_irqsafe(rtwdev->hw, skb);\n\t}\n}\n\nstatic void rtw_usb_read_port_complete(struct urb *urb);\n\nstatic void rtw_usb_rx_resubmit(struct rtw_usb *rtwusb, struct rx_usb_ctrl_block *rxcb)\n{\n\tstruct rtw_dev *rtwdev = rtwusb->rtwdev;\n\tint error;\n\n\trxcb->rx_skb = alloc_skb(RTW_USB_MAX_RECVBUF_SZ, GFP_ATOMIC);\n\tif (!rxcb->rx_skb)\n\t\treturn;\n\n\tusb_fill_bulk_urb(rxcb->rx_urb, rtwusb->udev,\n\t\t\t  usb_rcvbulkpipe(rtwusb->udev, rtwusb->pipe_in),\n\t\t\t  rxcb->rx_skb->data, RTW_USB_MAX_RECVBUF_SZ,\n\t\t\t  rtw_usb_read_port_complete, rxcb);\n\n\terror = usb_submit_urb(rxcb->rx_urb, GFP_ATOMIC);\n\tif (error) {\n\t\tkfree_skb(rxcb->rx_skb);\n\t\tif (error != -ENODEV)\n\t\t\trtw_err(rtwdev, \"Err sending rx data urb %d\\n\",\n\t\t\t\terror);\n\t}\n}\n\nstatic void rtw_usb_read_port_complete(struct urb *urb)\n{\n\tstruct rx_usb_ctrl_block *rxcb = urb->context;\n\tstruct rtw_dev *rtwdev = rxcb->rtwdev;\n\tstruct rtw_usb *rtwusb = rtw_get_usb_priv(rtwdev);\n\tstruct sk_buff *skb = rxcb->rx_skb;\n\n\tif (urb->status == 0) {\n\t\tif (urb->actual_length >= RTW_USB_MAX_RECVBUF_SZ ||\n\t\t    urb->actual_length < 24) {\n\t\t\trtw_err(rtwdev, \"failed to get urb length:%d\\n\",\n\t\t\t\turb->actual_length);\n\t\t\tif (skb)\n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t} else {\n\t\t\tskb_queue_tail(&rtwusb->rx_queue, skb);\n\t\t\tqueue_work(rtwusb->rxwq, &rtwusb->rx_work);\n\t\t}\n\t\trtw_usb_rx_resubmit(rtwusb, rxcb);\n\t} else {\n\t\tswitch (urb->status) {\n\t\tcase -EINVAL:\n\t\tcase -EPIPE:\n\t\tcase -ENODEV:\n\t\tcase -ESHUTDOWN:\n\t\tcase -ENOENT:\n\t\tcase -EPROTO:\n\t\tcase -EILSEQ:\n\t\tcase -ETIME:\n\t\tcase -ECOMM:\n\t\tcase -EOVERFLOW:\n\t\tcase -EINPROGRESS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trtw_err(rtwdev, \"status %d\\n\", urb->status);\n\t\t\tbreak;\n\t\t}\n\t\tif (skb)\n\t\t\tdev_kfree_skb_any(skb);\n\t}\n}\n\nstatic void rtw_usb_cancel_rx_bufs(struct rtw_usb *rtwusb)\n{\n\tstruct rx_usb_ctrl_block *rxcb;\n\tint i;\n\n\tfor (i = 0; i < RTW_USB_RXCB_NUM; i++) {\n\t\trxcb = &rtwusb->rx_cb[i];\n\t\tusb_kill_urb(rxcb->rx_urb);\n\t}\n}\n\nstatic void rtw_usb_free_rx_bufs(struct rtw_usb *rtwusb)\n{\n\tstruct rx_usb_ctrl_block *rxcb;\n\tint i;\n\n\tfor (i = 0; i < RTW_USB_RXCB_NUM; i++) {\n\t\trxcb = &rtwusb->rx_cb[i];\n\t\tusb_kill_urb(rxcb->rx_urb);\n\t\tusb_free_urb(rxcb->rx_urb);\n\t}\n}\n\nstatic int rtw_usb_alloc_rx_bufs(struct rtw_usb *rtwusb)\n{\n\tint i;\n\n\tfor (i = 0; i < RTW_USB_RXCB_NUM; i++) {\n\t\tstruct rx_usb_ctrl_block *rxcb = &rtwusb->rx_cb[i];\n\n\t\trxcb->rtwdev = rtwusb->rtwdev;\n\t\trxcb->rx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!rxcb->rx_urb)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\trtw_usb_free_rx_bufs(rtwusb);\n\treturn -ENOMEM;\n}\n\nstatic int rtw_usb_setup(struct rtw_dev *rtwdev)\n{\n\t \n\treturn 0;\n}\n\nstatic int rtw_usb_start(struct rtw_dev *rtwdev)\n{\n\treturn 0;\n}\n\nstatic void rtw_usb_stop(struct rtw_dev *rtwdev)\n{\n}\n\nstatic void rtw_usb_deep_ps(struct rtw_dev *rtwdev, bool enter)\n{\n\t \n}\n\nstatic void rtw_usb_link_ps(struct rtw_dev *rtwdev, bool enter)\n{\n\t \n}\n\nstatic void rtw_usb_interface_cfg(struct rtw_dev *rtwdev)\n{\n\t \n}\n\nstatic struct rtw_hci_ops rtw_usb_ops = {\n\t.tx_write = rtw_usb_tx_write,\n\t.tx_kick_off = rtw_usb_tx_kick_off,\n\t.setup = rtw_usb_setup,\n\t.start = rtw_usb_start,\n\t.stop = rtw_usb_stop,\n\t.deep_ps = rtw_usb_deep_ps,\n\t.link_ps = rtw_usb_link_ps,\n\t.interface_cfg = rtw_usb_interface_cfg,\n\n\t.write8  = rtw_usb_write8,\n\t.write16 = rtw_usb_write16,\n\t.write32 = rtw_usb_write32,\n\t.read8\t= rtw_usb_read8,\n\t.read16 = rtw_usb_read16,\n\t.read32 = rtw_usb_read32,\n\n\t.write_data_rsvd_page = rtw_usb_write_data_rsvd_page,\n\t.write_data_h2c = rtw_usb_write_data_h2c,\n};\n\nstatic int rtw_usb_init_rx(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_usb *rtwusb = rtw_get_usb_priv(rtwdev);\n\tint i;\n\n\trtwusb->rxwq = create_singlethread_workqueue(\"rtw88_usb: rx wq\");\n\tif (!rtwusb->rxwq) {\n\t\trtw_err(rtwdev, \"failed to create RX work queue\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tskb_queue_head_init(&rtwusb->rx_queue);\n\n\tINIT_WORK(&rtwusb->rx_work, rtw_usb_rx_handler);\n\n\tfor (i = 0; i < RTW_USB_RXCB_NUM; i++) {\n\t\tstruct rx_usb_ctrl_block *rxcb = &rtwusb->rx_cb[i];\n\n\t\trtw_usb_rx_resubmit(rtwusb, rxcb);\n\t}\n\n\treturn 0;\n}\n\nstatic void rtw_usb_deinit_rx(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_usb *rtwusb = rtw_get_usb_priv(rtwdev);\n\n\tskb_queue_purge(&rtwusb->rx_queue);\n\n\tflush_workqueue(rtwusb->rxwq);\n\tdestroy_workqueue(rtwusb->rxwq);\n}\n\nstatic int rtw_usb_init_tx(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_usb *rtwusb = rtw_get_usb_priv(rtwdev);\n\tint i;\n\n\trtwusb->txwq = create_singlethread_workqueue(\"rtw88_usb: tx wq\");\n\tif (!rtwusb->txwq) {\n\t\trtw_err(rtwdev, \"failed to create TX work queue\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(rtwusb->tx_queue); i++)\n\t\tskb_queue_head_init(&rtwusb->tx_queue[i]);\n\n\tINIT_WORK(&rtwusb->tx_work, rtw_usb_tx_handler);\n\n\treturn 0;\n}\n\nstatic void rtw_usb_deinit_tx(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_usb *rtwusb = rtw_get_usb_priv(rtwdev);\n\n\trtw_usb_tx_queue_purge(rtwusb);\n\tflush_workqueue(rtwusb->txwq);\n\tdestroy_workqueue(rtwusb->txwq);\n}\n\nstatic int rtw_usb_intf_init(struct rtw_dev *rtwdev,\n\t\t\t     struct usb_interface *intf)\n{\n\tstruct rtw_usb *rtwusb = rtw_get_usb_priv(rtwdev);\n\tstruct usb_device *udev = usb_get_dev(interface_to_usbdev(intf));\n\tint ret;\n\n\trtwusb->udev = udev;\n\tret = rtw_usb_parse(rtwdev, intf);\n\tif (ret)\n\t\treturn ret;\n\n\trtwusb->usb_data = kcalloc(RTW_USB_MAX_RXTX_COUNT, sizeof(u32),\n\t\t\t\t   GFP_KERNEL);\n\tif (!rtwusb->usb_data)\n\t\treturn -ENOMEM;\n\n\tusb_set_intfdata(intf, rtwdev->hw);\n\n\tSET_IEEE80211_DEV(rtwdev->hw, &intf->dev);\n\tspin_lock_init(&rtwusb->usb_lock);\n\n\treturn 0;\n}\n\nstatic void rtw_usb_intf_deinit(struct rtw_dev *rtwdev,\n\t\t\t\tstruct usb_interface *intf)\n{\n\tstruct rtw_usb *rtwusb = rtw_get_usb_priv(rtwdev);\n\n\tusb_put_dev(rtwusb->udev);\n\tkfree(rtwusb->usb_data);\n\tusb_set_intfdata(intf, NULL);\n}\n\nint rtw_usb_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstruct rtw_dev *rtwdev;\n\tstruct ieee80211_hw *hw;\n\tstruct rtw_usb *rtwusb;\n\tint drv_data_size;\n\tint ret;\n\n\tdrv_data_size = sizeof(struct rtw_dev) + sizeof(struct rtw_usb);\n\thw = ieee80211_alloc_hw(drv_data_size, &rtw_ops);\n\tif (!hw)\n\t\treturn -ENOMEM;\n\n\trtwdev = hw->priv;\n\trtwdev->hw = hw;\n\trtwdev->dev = &intf->dev;\n\trtwdev->chip = (struct rtw_chip_info *)id->driver_info;\n\trtwdev->hci.ops = &rtw_usb_ops;\n\trtwdev->hci.type = RTW_HCI_TYPE_USB;\n\n\trtwusb = rtw_get_usb_priv(rtwdev);\n\trtwusb->rtwdev = rtwdev;\n\n\tret = rtw_usb_alloc_rx_bufs(rtwusb);\n\tif (ret)\n\t\tgoto err_release_hw;\n\n\tret = rtw_core_init(rtwdev);\n\tif (ret)\n\t\tgoto err_free_rx_bufs;\n\n\tret = rtw_usb_intf_init(rtwdev, intf);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to init USB interface\\n\");\n\t\tgoto err_deinit_core;\n\t}\n\n\tret = rtw_usb_init_tx(rtwdev);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to init USB TX\\n\");\n\t\tgoto err_destroy_usb;\n\t}\n\n\tret = rtw_usb_init_rx(rtwdev);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to init USB RX\\n\");\n\t\tgoto err_destroy_txwq;\n\t}\n\n\tret = rtw_chip_info_setup(rtwdev);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to setup chip information\\n\");\n\t\tgoto err_destroy_rxwq;\n\t}\n\n\tret = rtw_register_hw(rtwdev, rtwdev->hw);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to register hw\\n\");\n\t\tgoto err_destroy_rxwq;\n\t}\n\n\treturn 0;\n\nerr_destroy_rxwq:\n\trtw_usb_deinit_rx(rtwdev);\n\nerr_destroy_txwq:\n\trtw_usb_deinit_tx(rtwdev);\n\nerr_destroy_usb:\n\trtw_usb_intf_deinit(rtwdev, intf);\n\nerr_deinit_core:\n\trtw_core_deinit(rtwdev);\n\nerr_free_rx_bufs:\n\trtw_usb_free_rx_bufs(rtwusb);\n\nerr_release_hw:\n\tieee80211_free_hw(hw);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(rtw_usb_probe);\n\nvoid rtw_usb_disconnect(struct usb_interface *intf)\n{\n\tstruct ieee80211_hw *hw = usb_get_intfdata(intf);\n\tstruct rtw_dev *rtwdev;\n\tstruct rtw_usb *rtwusb;\n\n\tif (!hw)\n\t\treturn;\n\n\trtwdev = hw->priv;\n\trtwusb = rtw_get_usb_priv(rtwdev);\n\n\trtw_usb_cancel_rx_bufs(rtwusb);\n\n\trtw_unregister_hw(rtwdev, hw);\n\trtw_usb_deinit_tx(rtwdev);\n\trtw_usb_deinit_rx(rtwdev);\n\n\tif (rtwusb->udev->state != USB_STATE_NOTATTACHED)\n\t\tusb_reset_device(rtwusb->udev);\n\n\trtw_usb_free_rx_bufs(rtwusb);\n\n\trtw_usb_intf_deinit(rtwdev, intf);\n\trtw_core_deinit(rtwdev);\n\tieee80211_free_hw(hw);\n}\nEXPORT_SYMBOL(rtw_usb_disconnect);\n\nMODULE_AUTHOR(\"Realtek Corporation\");\nMODULE_DESCRIPTION(\"Realtek USB 802.11ac wireless driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}