{
  "module_name": "mac.c",
  "hash_id": "29a273ee040dcbb944b38643b436719ad998ce8db9acd23f58b30ae8fde2c1a0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtw88/mac.c",
  "human_readable_source": "\n \n\n#include \"main.h\"\n#include \"mac.h\"\n#include \"reg.h\"\n#include \"fw.h\"\n#include \"debug.h\"\n#include \"sdio.h\"\n\nvoid rtw_set_channel_mac(struct rtw_dev *rtwdev, u8 channel, u8 bw,\n\t\t\t u8 primary_ch_idx)\n{\n\tu8 txsc40 = 0, txsc20 = 0;\n\tu32 value32;\n\tu8 value8;\n\n\ttxsc20 = primary_ch_idx;\n\tif (bw == RTW_CHANNEL_WIDTH_80) {\n\t\tif (txsc20 == RTW_SC_20_UPPER || txsc20 == RTW_SC_20_UPMOST)\n\t\t\ttxsc40 = RTW_SC_40_UPPER;\n\t\telse\n\t\t\ttxsc40 = RTW_SC_40_LOWER;\n\t}\n\trtw_write8(rtwdev, REG_DATA_SC,\n\t\t   BIT_TXSC_20M(txsc20) | BIT_TXSC_40M(txsc40));\n\n\tvalue32 = rtw_read32(rtwdev, REG_WMAC_TRXPTCL_CTL);\n\tvalue32 &= ~BIT_RFMOD;\n\tswitch (bw) {\n\tcase RTW_CHANNEL_WIDTH_80:\n\t\tvalue32 |= BIT_RFMOD_80M;\n\t\tbreak;\n\tcase RTW_CHANNEL_WIDTH_40:\n\t\tvalue32 |= BIT_RFMOD_40M;\n\t\tbreak;\n\tcase RTW_CHANNEL_WIDTH_20:\n\tdefault:\n\t\tbreak;\n\t}\n\trtw_write32(rtwdev, REG_WMAC_TRXPTCL_CTL, value32);\n\n\tif (rtw_chip_wcpu_11n(rtwdev))\n\t\treturn;\n\n\tvalue32 = rtw_read32(rtwdev, REG_AFE_CTRL1) & ~(BIT_MAC_CLK_SEL);\n\tvalue32 |= (MAC_CLK_HW_DEF_80M << BIT_SHIFT_MAC_CLK_SEL);\n\trtw_write32(rtwdev, REG_AFE_CTRL1, value32);\n\n\trtw_write8(rtwdev, REG_USTIME_TSF, MAC_CLK_SPEED);\n\trtw_write8(rtwdev, REG_USTIME_EDCA, MAC_CLK_SPEED);\n\n\tvalue8 = rtw_read8(rtwdev, REG_CCK_CHECK);\n\tvalue8 = value8 & ~BIT_CHECK_CCK_EN;\n\tif (IS_CH_5G_BAND(channel))\n\t\tvalue8 |= BIT_CHECK_CCK_EN;\n\trtw_write8(rtwdev, REG_CCK_CHECK, value8);\n}\nEXPORT_SYMBOL(rtw_set_channel_mac);\n\nstatic int rtw_mac_pre_system_cfg(struct rtw_dev *rtwdev)\n{\n\tunsigned int retry;\n\tu32 value32;\n\tu8 value8;\n\n\trtw_write8(rtwdev, REG_RSV_CTRL, 0);\n\n\tif (rtw_chip_wcpu_11n(rtwdev)) {\n\t\tif (rtw_read32(rtwdev, REG_SYS_CFG1) & BIT_LDO)\n\t\t\trtw_write8(rtwdev, REG_LDO_SWR_CTRL, LDO_SEL);\n\t\telse\n\t\t\trtw_write8(rtwdev, REG_LDO_SWR_CTRL, SPS_SEL);\n\t\treturn 0;\n\t}\n\n\tswitch (rtw_hci_type(rtwdev)) {\n\tcase RTW_HCI_TYPE_PCIE:\n\t\trtw_write32_set(rtwdev, REG_HCI_OPT_CTRL, BIT_USB_SUS_DIS);\n\t\tbreak;\n\tcase RTW_HCI_TYPE_SDIO:\n\t\trtw_write8_clr(rtwdev, REG_SDIO_HSUS_CTRL, BIT_HCI_SUS_REQ);\n\n\t\tfor (retry = 0; retry < RTW_PWR_POLLING_CNT; retry++) {\n\t\t\tif (rtw_read8(rtwdev, REG_SDIO_HSUS_CTRL) & BIT_HCI_RESUME_RDY)\n\t\t\t\tbreak;\n\n\t\t\tusleep_range(10, 50);\n\t\t}\n\n\t\tif (retry == RTW_PWR_POLLING_CNT) {\n\t\t\trtw_err(rtwdev, \"failed to poll REG_SDIO_HSUS_CTRL[1]\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\n\t\tif (rtw_sdio_is_sdio30_supported(rtwdev))\n\t\t\trtw_write8_set(rtwdev, REG_HCI_OPT_CTRL + 2,\n\t\t\t\t       BIT_SDIO_PAD_E5 >> 16);\n\t\telse\n\t\t\trtw_write8_clr(rtwdev, REG_HCI_OPT_CTRL + 2,\n\t\t\t\t       BIT_SDIO_PAD_E5 >> 16);\n\t\tbreak;\n\tcase RTW_HCI_TYPE_USB:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tvalue32 = rtw_read32(rtwdev, REG_PAD_CTRL1);\n\tvalue32 |= BIT_PAPE_WLBT_SEL | BIT_LNAON_WLBT_SEL;\n\trtw_write32(rtwdev, REG_PAD_CTRL1, value32);\n\n\tvalue32 = rtw_read32(rtwdev, REG_LED_CFG);\n\tvalue32 &= ~(BIT_PAPE_SEL_EN | BIT_LNAON_SEL_EN);\n\trtw_write32(rtwdev, REG_LED_CFG, value32);\n\n\tvalue32 = rtw_read32(rtwdev, REG_GPIO_MUXCFG);\n\tvalue32 |= BIT_WLRFE_4_5_EN;\n\trtw_write32(rtwdev, REG_GPIO_MUXCFG, value32);\n\n\t \n\tvalue8 = rtw_read8(rtwdev, REG_SYS_FUNC_EN);\n\tvalue8 &= ~(BIT_FEN_BB_RSTB | BIT_FEN_BB_GLB_RST);\n\trtw_write8(rtwdev, REG_SYS_FUNC_EN, value8);\n\n\tvalue8 = rtw_read8(rtwdev, REG_RF_CTRL);\n\tvalue8 &= ~(BIT_RF_SDM_RSTB | BIT_RF_RSTB | BIT_RF_EN);\n\trtw_write8(rtwdev, REG_RF_CTRL, value8);\n\n\tvalue32 = rtw_read32(rtwdev, REG_WLRF1);\n\tvalue32 &= ~BIT_WLRF1_BBRF_EN;\n\trtw_write32(rtwdev, REG_WLRF1, value32);\n\n\treturn 0;\n}\n\nstatic bool do_pwr_poll_cmd(struct rtw_dev *rtwdev, u32 addr, u32 mask, u32 target)\n{\n\tu32 val;\n\n\ttarget &= mask;\n\n\treturn read_poll_timeout_atomic(rtw_read8, val, (val & mask) == target,\n\t\t\t\t\t50, 50 * RTW_PWR_POLLING_CNT, false,\n\t\t\t\t\trtwdev, addr) == 0;\n}\n\nstatic int rtw_pwr_cmd_polling(struct rtw_dev *rtwdev,\n\t\t\t       const struct rtw_pwr_seq_cmd *cmd)\n{\n\tu8 value;\n\tu32 offset;\n\n\tif (cmd->base == RTW_PWR_ADDR_SDIO)\n\t\toffset = cmd->offset | SDIO_LOCAL_OFFSET;\n\telse\n\t\toffset = cmd->offset;\n\n\tif (do_pwr_poll_cmd(rtwdev, offset, cmd->mask, cmd->value))\n\t\treturn 0;\n\n\tif (rtw_hci_type(rtwdev) != RTW_HCI_TYPE_PCIE)\n\t\tgoto err;\n\n\t \n\tvalue = rtw_read8(rtwdev, REG_SYS_PW_CTRL);\n\tif (rtwdev->chip->id == RTW_CHIP_TYPE_8723D)\n\t\trtw_write8(rtwdev, REG_SYS_PW_CTRL, value & ~BIT_PFM_WOWL);\n\trtw_write8(rtwdev, REG_SYS_PW_CTRL, value | BIT_PFM_WOWL);\n\trtw_write8(rtwdev, REG_SYS_PW_CTRL, value & ~BIT_PFM_WOWL);\n\tif (rtwdev->chip->id == RTW_CHIP_TYPE_8723D)\n\t\trtw_write8(rtwdev, REG_SYS_PW_CTRL, value | BIT_PFM_WOWL);\n\n\tif (do_pwr_poll_cmd(rtwdev, offset, cmd->mask, cmd->value))\n\t\treturn 0;\n\nerr:\n\trtw_err(rtwdev, \"failed to poll offset=0x%x mask=0x%x value=0x%x\\n\",\n\t\toffset, cmd->mask, cmd->value);\n\treturn -EBUSY;\n}\n\nstatic int rtw_sub_pwr_seq_parser(struct rtw_dev *rtwdev, u8 intf_mask,\n\t\t\t\t  u8 cut_mask,\n\t\t\t\t  const struct rtw_pwr_seq_cmd *cmd)\n{\n\tconst struct rtw_pwr_seq_cmd *cur_cmd;\n\tu32 offset;\n\tu8 value;\n\n\tfor (cur_cmd = cmd; cur_cmd->cmd != RTW_PWR_CMD_END; cur_cmd++) {\n\t\tif (!(cur_cmd->intf_mask & intf_mask) ||\n\t\t    !(cur_cmd->cut_mask & cut_mask))\n\t\t\tcontinue;\n\n\t\tswitch (cur_cmd->cmd) {\n\t\tcase RTW_PWR_CMD_WRITE:\n\t\t\toffset = cur_cmd->offset;\n\n\t\t\tif (cur_cmd->base == RTW_PWR_ADDR_SDIO)\n\t\t\t\toffset |= SDIO_LOCAL_OFFSET;\n\n\t\t\tvalue = rtw_read8(rtwdev, offset);\n\t\t\tvalue &= ~cur_cmd->mask;\n\t\t\tvalue |= (cur_cmd->value & cur_cmd->mask);\n\t\t\trtw_write8(rtwdev, offset, value);\n\t\t\tbreak;\n\t\tcase RTW_PWR_CMD_POLLING:\n\t\t\tif (rtw_pwr_cmd_polling(rtwdev, cur_cmd))\n\t\t\t\treturn -EBUSY;\n\t\t\tbreak;\n\t\tcase RTW_PWR_CMD_DELAY:\n\t\t\tif (cur_cmd->value == RTW_PWR_DELAY_US)\n\t\t\t\tudelay(cur_cmd->offset);\n\t\t\telse\n\t\t\t\tmdelay(cur_cmd->offset);\n\t\t\tbreak;\n\t\tcase RTW_PWR_CMD_READ:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int rtw_pwr_seq_parser(struct rtw_dev *rtwdev,\n\t\t\t      const struct rtw_pwr_seq_cmd **cmd_seq)\n{\n\tu8 cut_mask;\n\tu8 intf_mask;\n\tu8 cut;\n\tu32 idx = 0;\n\tconst struct rtw_pwr_seq_cmd *cmd;\n\tint ret;\n\n\tcut = rtwdev->hal.cut_version;\n\tcut_mask = cut_version_to_mask(cut);\n\tswitch (rtw_hci_type(rtwdev)) {\n\tcase RTW_HCI_TYPE_PCIE:\n\t\tintf_mask = RTW_PWR_INTF_PCI_MSK;\n\t\tbreak;\n\tcase RTW_HCI_TYPE_USB:\n\t\tintf_mask = RTW_PWR_INTF_USB_MSK;\n\t\tbreak;\n\tcase RTW_HCI_TYPE_SDIO:\n\t\tintf_mask = RTW_PWR_INTF_SDIO_MSK;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tdo {\n\t\tcmd = cmd_seq[idx];\n\t\tif (!cmd)\n\t\t\tbreak;\n\n\t\tret = rtw_sub_pwr_seq_parser(rtwdev, intf_mask, cut_mask, cmd);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tidx++;\n\t} while (1);\n\n\treturn 0;\n}\n\nstatic int rtw_mac_power_switch(struct rtw_dev *rtwdev, bool pwr_on)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tconst struct rtw_pwr_seq_cmd **pwr_seq;\n\tu32 imr = 0;\n\tu8 rpwm;\n\tbool cur_pwr;\n\tint ret;\n\n\tif (rtw_chip_wcpu_11ac(rtwdev)) {\n\t\trpwm = rtw_read8(rtwdev, rtwdev->hci.rpwm_addr);\n\n\t\t \n\t\tif (rtw_read16(rtwdev, REG_MCUFW_CTRL) == 0xC078) {\n\t\t\trpwm = (rpwm ^ BIT_RPWM_TOGGLE) & BIT_RPWM_TOGGLE;\n\t\t\trtw_write8(rtwdev, rtwdev->hci.rpwm_addr, rpwm);\n\t\t}\n\t}\n\n\tif (rtw_read8(rtwdev, REG_CR) == 0xea)\n\t\tcur_pwr = false;\n\telse if (rtw_hci_type(rtwdev) == RTW_HCI_TYPE_USB &&\n\t\t (rtw_read8(rtwdev, REG_SYS_STATUS1 + 1) & BIT(0)))\n\t\tcur_pwr = false;\n\telse\n\t\tcur_pwr = true;\n\n\tif (pwr_on == cur_pwr)\n\t\treturn -EALREADY;\n\n\tif (rtw_hci_type(rtwdev) == RTW_HCI_TYPE_SDIO) {\n\t\timr = rtw_read32(rtwdev, REG_SDIO_HIMR);\n\t\trtw_write32(rtwdev, REG_SDIO_HIMR, 0);\n\t}\n\n\tif (!pwr_on)\n\t\tclear_bit(RTW_FLAG_POWERON, rtwdev->flags);\n\n\tpwr_seq = pwr_on ? chip->pwr_on_seq : chip->pwr_off_seq;\n\tret = rtw_pwr_seq_parser(rtwdev, pwr_seq);\n\n\tif (rtw_hci_type(rtwdev) == RTW_HCI_TYPE_SDIO)\n\t\trtw_write32(rtwdev, REG_SDIO_HIMR, imr);\n\n\tif (!ret && pwr_on)\n\t\tset_bit(RTW_FLAG_POWERON, rtwdev->flags);\n\n\treturn ret;\n}\n\nstatic int __rtw_mac_init_system_cfg(struct rtw_dev *rtwdev)\n{\n\tu8 sys_func_en = rtwdev->chip->sys_func_en;\n\tu8 value8;\n\tu32 value, tmp;\n\n\tvalue = rtw_read32(rtwdev, REG_CPU_DMEM_CON);\n\tvalue |= BIT_WL_PLATFORM_RST | BIT_DDMA_EN;\n\trtw_write32(rtwdev, REG_CPU_DMEM_CON, value);\n\n\trtw_write8_set(rtwdev, REG_SYS_FUNC_EN + 1, sys_func_en);\n\tvalue8 = (rtw_read8(rtwdev, REG_CR_EXT + 3) & 0xF0) | 0x0C;\n\trtw_write8(rtwdev, REG_CR_EXT + 3, value8);\n\n\t \n\ttmp = rtw_read32(rtwdev, REG_MCUFW_CTRL);\n\tif (tmp & BIT_BOOT_FSPI_EN) {\n\t\trtw_write32(rtwdev, REG_MCUFW_CTRL, tmp & (~BIT_BOOT_FSPI_EN));\n\t\tvalue = rtw_read32(rtwdev, REG_GPIO_MUXCFG) & (~BIT_FSPI_EN);\n\t\trtw_write32(rtwdev, REG_GPIO_MUXCFG, value);\n\t}\n\n\treturn 0;\n}\n\nstatic int __rtw_mac_init_system_cfg_legacy(struct rtw_dev *rtwdev)\n{\n\trtw_write8(rtwdev, REG_CR, 0xff);\n\tmdelay(2);\n\trtw_write8(rtwdev, REG_HWSEQ_CTRL, 0x7f);\n\tmdelay(2);\n\n\trtw_write8_set(rtwdev, REG_SYS_CLKR, BIT_WAKEPAD_EN);\n\trtw_write16_clr(rtwdev, REG_GPIO_MUXCFG, BIT_EN_SIC);\n\n\trtw_write16(rtwdev, REG_CR, 0x2ff);\n\n\treturn 0;\n}\n\nstatic int rtw_mac_init_system_cfg(struct rtw_dev *rtwdev)\n{\n\tif (rtw_chip_wcpu_11n(rtwdev))\n\t\treturn __rtw_mac_init_system_cfg_legacy(rtwdev);\n\n\treturn __rtw_mac_init_system_cfg(rtwdev);\n}\n\nint rtw_mac_power_on(struct rtw_dev *rtwdev)\n{\n\tint ret = 0;\n\n\tret = rtw_mac_pre_system_cfg(rtwdev);\n\tif (ret)\n\t\tgoto err;\n\n\tret = rtw_mac_power_switch(rtwdev, true);\n\tif (ret == -EALREADY) {\n\t\trtw_mac_power_switch(rtwdev, false);\n\n\t\tret = rtw_mac_pre_system_cfg(rtwdev);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tret = rtw_mac_power_switch(rtwdev, true);\n\t\tif (ret)\n\t\t\tgoto err;\n\t} else if (ret) {\n\t\tgoto err;\n\t}\n\n\tret = rtw_mac_init_system_cfg(rtwdev);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\trtw_err(rtwdev, \"mac power on failed\");\n\treturn ret;\n}\n\nvoid rtw_mac_power_off(struct rtw_dev *rtwdev)\n{\n\trtw_mac_power_switch(rtwdev, false);\n}\n\nstatic bool check_firmware_size(const u8 *data, u32 size)\n{\n\tconst struct rtw_fw_hdr *fw_hdr = (const struct rtw_fw_hdr *)data;\n\tu32 dmem_size;\n\tu32 imem_size;\n\tu32 emem_size;\n\tu32 real_size;\n\n\tdmem_size = le32_to_cpu(fw_hdr->dmem_size);\n\timem_size = le32_to_cpu(fw_hdr->imem_size);\n\temem_size = (fw_hdr->mem_usage & BIT(4)) ?\n\t\t    le32_to_cpu(fw_hdr->emem_size) : 0;\n\n\tdmem_size += FW_HDR_CHKSUM_SIZE;\n\timem_size += FW_HDR_CHKSUM_SIZE;\n\temem_size += emem_size ? FW_HDR_CHKSUM_SIZE : 0;\n\treal_size = FW_HDR_SIZE + dmem_size + imem_size + emem_size;\n\tif (real_size != size)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void wlan_cpu_enable(struct rtw_dev *rtwdev, bool enable)\n{\n\tif (enable) {\n\t\t \n\t\trtw_write8_set(rtwdev, REG_RSV_CTRL + 1, BIT_WLMCU_IOIF);\n\n\t\t \n\t\trtw_write8_set(rtwdev, REG_SYS_FUNC_EN + 1, BIT_FEN_CPUEN);\n\t} else {\n\t\t \n\t\trtw_write8_clr(rtwdev, REG_SYS_FUNC_EN + 1, BIT_FEN_CPUEN);\n\n\t\t \n\t\trtw_write8_clr(rtwdev, REG_RSV_CTRL + 1, BIT_WLMCU_IOIF);\n\t}\n}\n\n#define DLFW_RESTORE_REG_NUM 6\n\nstatic void download_firmware_reg_backup(struct rtw_dev *rtwdev,\n\t\t\t\t\t struct rtw_backup_info *bckp)\n{\n\tu8 tmp;\n\tu8 bckp_idx = 0;\n\n\t \n\tbckp[bckp_idx].len = 1;\n\tbckp[bckp_idx].reg = REG_TXDMA_PQ_MAP + 1;\n\tbckp[bckp_idx].val = rtw_read8(rtwdev, REG_TXDMA_PQ_MAP + 1);\n\tbckp_idx++;\n\ttmp = RTW_DMA_MAPPING_HIGH << 6;\n\trtw_write8(rtwdev, REG_TXDMA_PQ_MAP + 1, tmp);\n\n\t \n\tbckp[bckp_idx].len = 1;\n\tbckp[bckp_idx].reg = REG_CR;\n\tbckp[bckp_idx].val = rtw_read8(rtwdev, REG_CR);\n\tbckp_idx++;\n\tbckp[bckp_idx].len = 4;\n\tbckp[bckp_idx].reg = REG_H2CQ_CSR;\n\tbckp[bckp_idx].val = BIT_H2CQ_FULL;\n\tbckp_idx++;\n\ttmp = BIT_HCI_TXDMA_EN | BIT_TXDMA_EN;\n\trtw_write8(rtwdev, REG_CR, tmp);\n\trtw_write32(rtwdev, REG_H2CQ_CSR, BIT_H2CQ_FULL);\n\n\t \n\tbckp[bckp_idx].len = 2;\n\tbckp[bckp_idx].reg = REG_FIFOPAGE_INFO_1;\n\tbckp[bckp_idx].val = rtw_read16(rtwdev, REG_FIFOPAGE_INFO_1);\n\tbckp_idx++;\n\tbckp[bckp_idx].len = 4;\n\tbckp[bckp_idx].reg = REG_RQPN_CTRL_2;\n\tbckp[bckp_idx].val = rtw_read32(rtwdev, REG_RQPN_CTRL_2) | BIT_LD_RQPN;\n\tbckp_idx++;\n\trtw_write16(rtwdev, REG_FIFOPAGE_INFO_1, 0x200);\n\trtw_write32(rtwdev, REG_RQPN_CTRL_2, bckp[bckp_idx - 1].val);\n\n\tif (rtw_hci_type(rtwdev) == RTW_HCI_TYPE_SDIO)\n\t\trtw_read32(rtwdev, REG_SDIO_FREE_TXPG);\n\n\t \n\ttmp = rtw_read8(rtwdev, REG_BCN_CTRL);\n\tbckp[bckp_idx].len = 1;\n\tbckp[bckp_idx].reg = REG_BCN_CTRL;\n\tbckp[bckp_idx].val = tmp;\n\tbckp_idx++;\n\ttmp = (u8)((tmp & (~BIT_EN_BCN_FUNCTION)) | BIT_DIS_TSF_UDT);\n\trtw_write8(rtwdev, REG_BCN_CTRL, tmp);\n\n\tWARN(bckp_idx != DLFW_RESTORE_REG_NUM, \"wrong backup number\\n\");\n}\n\nstatic void download_firmware_reset_platform(struct rtw_dev *rtwdev)\n{\n\trtw_write8_clr(rtwdev, REG_CPU_DMEM_CON + 2, BIT_WL_PLATFORM_RST >> 16);\n\trtw_write8_clr(rtwdev, REG_SYS_CLK_CTRL + 1, BIT_CPU_CLK_EN >> 8);\n\trtw_write8_set(rtwdev, REG_CPU_DMEM_CON + 2, BIT_WL_PLATFORM_RST >> 16);\n\trtw_write8_set(rtwdev, REG_SYS_CLK_CTRL + 1, BIT_CPU_CLK_EN >> 8);\n}\n\nstatic void download_firmware_reg_restore(struct rtw_dev *rtwdev,\n\t\t\t\t\t  struct rtw_backup_info *bckp,\n\t\t\t\t\t  u8 bckp_num)\n{\n\trtw_restore_reg(rtwdev, bckp, bckp_num);\n}\n\n#define TX_DESC_SIZE 48\n\nstatic int send_firmware_pkt_rsvd_page(struct rtw_dev *rtwdev, u16 pg_addr,\n\t\t\t\t       const u8 *data, u32 size)\n{\n\tu8 *buf;\n\tint ret;\n\n\tbuf = kmemdup(data, size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = rtw_fw_write_data_rsvd_page(rtwdev, pg_addr, buf, size);\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic int\nsend_firmware_pkt(struct rtw_dev *rtwdev, u16 pg_addr, const u8 *data, u32 size)\n{\n\tint ret;\n\n\tif (rtw_hci_type(rtwdev) == RTW_HCI_TYPE_USB &&\n\t    !((size + TX_DESC_SIZE) & (512 - 1)))\n\t\tsize += 1;\n\n\tret = send_firmware_pkt_rsvd_page(rtwdev, pg_addr, data, size);\n\tif (ret)\n\t\trtw_err(rtwdev, \"failed to download rsvd page\\n\");\n\n\treturn ret;\n}\n\nstatic int\niddma_enable(struct rtw_dev *rtwdev, u32 src, u32 dst, u32 ctrl)\n{\n\trtw_write32(rtwdev, REG_DDMA_CH0SA, src);\n\trtw_write32(rtwdev, REG_DDMA_CH0DA, dst);\n\trtw_write32(rtwdev, REG_DDMA_CH0CTRL, ctrl);\n\n\tif (!check_hw_ready(rtwdev, REG_DDMA_CH0CTRL, BIT_DDMACH0_OWN, 0))\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\nstatic int iddma_download_firmware(struct rtw_dev *rtwdev, u32 src, u32 dst,\n\t\t\t\t   u32 len, u8 first)\n{\n\tu32 ch0_ctrl = BIT_DDMACH0_CHKSUM_EN | BIT_DDMACH0_OWN;\n\n\tif (!check_hw_ready(rtwdev, REG_DDMA_CH0CTRL, BIT_DDMACH0_OWN, 0))\n\t\treturn -EBUSY;\n\n\tch0_ctrl |= len & BIT_MASK_DDMACH0_DLEN;\n\tif (!first)\n\t\tch0_ctrl |= BIT_DDMACH0_CHKSUM_CONT;\n\n\tif (iddma_enable(rtwdev, src, dst, ch0_ctrl))\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\nint rtw_ddma_to_fw_fifo(struct rtw_dev *rtwdev, u32 ocp_src, u32 size)\n{\n\tu32 ch0_ctrl = BIT_DDMACH0_OWN | BIT_DDMACH0_DDMA_MODE;\n\n\tif (!check_hw_ready(rtwdev, REG_DDMA_CH0CTRL, BIT_DDMACH0_OWN, 0)) {\n\t\trtw_dbg(rtwdev, RTW_DBG_FW, \"busy to start ddma\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tch0_ctrl |= size & BIT_MASK_DDMACH0_DLEN;\n\n\tif (iddma_enable(rtwdev, ocp_src, OCPBASE_RXBUF_FW_88XX, ch0_ctrl)) {\n\t\trtw_dbg(rtwdev, RTW_DBG_FW, \"busy to complete ddma\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic bool\ncheck_fw_checksum(struct rtw_dev *rtwdev, u32 addr)\n{\n\tu8 fw_ctrl;\n\n\tfw_ctrl = rtw_read8(rtwdev, REG_MCUFW_CTRL);\n\n\tif (rtw_read32(rtwdev, REG_DDMA_CH0CTRL) & BIT_DDMACH0_CHKSUM_STS) {\n\t\tif (addr < OCPBASE_DMEM_88XX) {\n\t\t\tfw_ctrl |= BIT_IMEM_DW_OK;\n\t\t\tfw_ctrl &= ~BIT_IMEM_CHKSUM_OK;\n\t\t\trtw_write8(rtwdev, REG_MCUFW_CTRL, fw_ctrl);\n\t\t} else {\n\t\t\tfw_ctrl |= BIT_DMEM_DW_OK;\n\t\t\tfw_ctrl &= ~BIT_DMEM_CHKSUM_OK;\n\t\t\trtw_write8(rtwdev, REG_MCUFW_CTRL, fw_ctrl);\n\t\t}\n\n\t\trtw_err(rtwdev, \"invalid fw checksum\\n\");\n\n\t\treturn false;\n\t}\n\n\tif (addr < OCPBASE_DMEM_88XX) {\n\t\tfw_ctrl |= (BIT_IMEM_DW_OK | BIT_IMEM_CHKSUM_OK);\n\t\trtw_write8(rtwdev, REG_MCUFW_CTRL, fw_ctrl);\n\t} else {\n\t\tfw_ctrl |= (BIT_DMEM_DW_OK | BIT_DMEM_CHKSUM_OK);\n\t\trtw_write8(rtwdev, REG_MCUFW_CTRL, fw_ctrl);\n\t}\n\n\treturn true;\n}\n\nstatic int\ndownload_firmware_to_mem(struct rtw_dev *rtwdev, const u8 *data,\n\t\t\t u32 src, u32 dst, u32 size)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tu32 desc_size = chip->tx_pkt_desc_sz;\n\tu8 first_part;\n\tu32 mem_offset;\n\tu32 residue_size;\n\tu32 pkt_size;\n\tu32 max_size = 0x1000;\n\tu32 val;\n\tint ret;\n\n\tmem_offset = 0;\n\tfirst_part = 1;\n\tresidue_size = size;\n\n\tval = rtw_read32(rtwdev, REG_DDMA_CH0CTRL);\n\tval |= BIT_DDMACH0_RESET_CHKSUM_STS;\n\trtw_write32(rtwdev, REG_DDMA_CH0CTRL, val);\n\n\twhile (residue_size) {\n\t\tif (residue_size >= max_size)\n\t\t\tpkt_size = max_size;\n\t\telse\n\t\t\tpkt_size = residue_size;\n\n\t\tret = send_firmware_pkt(rtwdev, (u16)(src >> 7),\n\t\t\t\t\tdata + mem_offset, pkt_size);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = iddma_download_firmware(rtwdev, OCPBASE_TXBUF_88XX +\n\t\t\t\t\t      src + desc_size,\n\t\t\t\t\t      dst + mem_offset, pkt_size,\n\t\t\t\t\t      first_part);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tfirst_part = 0;\n\t\tmem_offset += pkt_size;\n\t\tresidue_size -= pkt_size;\n\t}\n\n\tif (!check_fw_checksum(rtwdev, dst))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int\nstart_download_firmware(struct rtw_dev *rtwdev, const u8 *data, u32 size)\n{\n\tconst struct rtw_fw_hdr *fw_hdr = (const struct rtw_fw_hdr *)data;\n\tconst u8 *cur_fw;\n\tu16 val;\n\tu32 imem_size;\n\tu32 dmem_size;\n\tu32 emem_size;\n\tu32 addr;\n\tint ret;\n\n\tdmem_size = le32_to_cpu(fw_hdr->dmem_size);\n\timem_size = le32_to_cpu(fw_hdr->imem_size);\n\temem_size = (fw_hdr->mem_usage & BIT(4)) ?\n\t\t    le32_to_cpu(fw_hdr->emem_size) : 0;\n\tdmem_size += FW_HDR_CHKSUM_SIZE;\n\timem_size += FW_HDR_CHKSUM_SIZE;\n\temem_size += emem_size ? FW_HDR_CHKSUM_SIZE : 0;\n\n\tval = (u16)(rtw_read16(rtwdev, REG_MCUFW_CTRL) & 0x3800);\n\tval |= BIT_MCUFWDL_EN;\n\trtw_write16(rtwdev, REG_MCUFW_CTRL, val);\n\n\tcur_fw = data + FW_HDR_SIZE;\n\taddr = le32_to_cpu(fw_hdr->dmem_addr);\n\taddr &= ~BIT(31);\n\tret = download_firmware_to_mem(rtwdev, cur_fw, 0, addr, dmem_size);\n\tif (ret)\n\t\treturn ret;\n\n\tcur_fw = data + FW_HDR_SIZE + dmem_size;\n\taddr = le32_to_cpu(fw_hdr->imem_addr);\n\taddr &= ~BIT(31);\n\tret = download_firmware_to_mem(rtwdev, cur_fw, 0, addr, imem_size);\n\tif (ret)\n\t\treturn ret;\n\n\tif (emem_size) {\n\t\tcur_fw = data + FW_HDR_SIZE + dmem_size + imem_size;\n\t\taddr = le32_to_cpu(fw_hdr->emem_addr);\n\t\taddr &= ~BIT(31);\n\t\tret = download_firmware_to_mem(rtwdev, cur_fw, 0, addr,\n\t\t\t\t\t       emem_size);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int download_firmware_validate(struct rtw_dev *rtwdev)\n{\n\tu32 fw_key;\n\n\tif (!check_hw_ready(rtwdev, REG_MCUFW_CTRL, FW_READY_MASK, FW_READY)) {\n\t\tfw_key = rtw_read32(rtwdev, REG_FW_DBG7) & FW_KEY_MASK;\n\t\tif (fw_key == ILLEGAL_KEY_GROUP)\n\t\t\trtw_err(rtwdev, \"invalid fw key\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void download_firmware_end_flow(struct rtw_dev *rtwdev)\n{\n\tu16 fw_ctrl;\n\n\trtw_write32(rtwdev, REG_TXDMA_STATUS, BTI_PAGE_OVF);\n\n\t \n\tfw_ctrl = rtw_read16(rtwdev, REG_MCUFW_CTRL);\n\tif ((fw_ctrl & BIT_CHECK_SUM_OK) != BIT_CHECK_SUM_OK)\n\t\treturn;\n\n\tfw_ctrl = (fw_ctrl | BIT_FW_DW_RDY) & ~BIT_MCUFWDL_EN;\n\trtw_write16(rtwdev, REG_MCUFW_CTRL, fw_ctrl);\n}\n\nstatic int __rtw_download_firmware(struct rtw_dev *rtwdev,\n\t\t\t\t   struct rtw_fw_state *fw)\n{\n\tstruct rtw_backup_info bckp[DLFW_RESTORE_REG_NUM];\n\tconst u8 *data = fw->firmware->data;\n\tu32 size = fw->firmware->size;\n\tu32 ltecoex_bckp;\n\tint ret;\n\n\tif (!check_firmware_size(data, size))\n\t\treturn -EINVAL;\n\n\tif (!ltecoex_read_reg(rtwdev, 0x38, &ltecoex_bckp))\n\t\treturn -EBUSY;\n\n\twlan_cpu_enable(rtwdev, false);\n\n\tdownload_firmware_reg_backup(rtwdev, bckp);\n\tdownload_firmware_reset_platform(rtwdev);\n\n\tret = start_download_firmware(rtwdev, data, size);\n\tif (ret)\n\t\tgoto dlfw_fail;\n\n\tdownload_firmware_reg_restore(rtwdev, bckp, DLFW_RESTORE_REG_NUM);\n\n\tdownload_firmware_end_flow(rtwdev);\n\n\twlan_cpu_enable(rtwdev, true);\n\n\tif (!ltecoex_reg_write(rtwdev, 0x38, ltecoex_bckp)) {\n\t\tret = -EBUSY;\n\t\tgoto dlfw_fail;\n\t}\n\n\tret = download_firmware_validate(rtwdev);\n\tif (ret)\n\t\tgoto dlfw_fail;\n\n\t \n\trtw_hci_setup(rtwdev);\n\n\trtwdev->h2c.last_box_num = 0;\n\trtwdev->h2c.seq = 0;\n\n\tset_bit(RTW_FLAG_FW_RUNNING, rtwdev->flags);\n\n\treturn 0;\n\ndlfw_fail:\n\t \n\trtw_write8_clr(rtwdev, REG_MCUFW_CTRL, BIT_MCUFWDL_EN);\n\trtw_write8_set(rtwdev, REG_SYS_FUNC_EN + 1, BIT_FEN_CPUEN);\n\n\treturn ret;\n}\n\nstatic void en_download_firmware_legacy(struct rtw_dev *rtwdev, bool en)\n{\n\tint try;\n\n\tif (en) {\n\t\twlan_cpu_enable(rtwdev, false);\n\t\twlan_cpu_enable(rtwdev, true);\n\n\t\trtw_write8_set(rtwdev, REG_MCUFW_CTRL, BIT_MCUFWDL_EN);\n\n\t\tfor (try = 0; try < 10; try++) {\n\t\t\tif (rtw_read8(rtwdev, REG_MCUFW_CTRL) & BIT_MCUFWDL_EN)\n\t\t\t\tgoto fwdl_ready;\n\t\t\trtw_write8_set(rtwdev, REG_MCUFW_CTRL, BIT_MCUFWDL_EN);\n\t\t\tmsleep(20);\n\t\t}\n\t\trtw_err(rtwdev, \"failed to check fw download ready\\n\");\nfwdl_ready:\n\t\trtw_write32_clr(rtwdev, REG_MCUFW_CTRL, BIT_ROM_DLEN);\n\t} else {\n\t\trtw_write8_clr(rtwdev, REG_MCUFW_CTRL, BIT_MCUFWDL_EN);\n\t}\n}\n\nstatic void\nwrite_firmware_page(struct rtw_dev *rtwdev, u32 page, const u8 *data, u32 size)\n{\n\tu32 val32;\n\tu32 block_nr;\n\tu32 remain_size;\n\tu32 write_addr = FW_START_ADDR_LEGACY;\n\tconst __le32 *ptr = (const __le32 *)data;\n\tu32 block;\n\t__le32 remain_data = 0;\n\n\tblock_nr = size >> DLFW_BLK_SIZE_SHIFT_LEGACY;\n\tremain_size = size & (DLFW_BLK_SIZE_LEGACY - 1);\n\n\tval32 = rtw_read32(rtwdev, REG_MCUFW_CTRL);\n\tval32 &= ~BIT_ROM_PGE;\n\tval32 |= (page << BIT_SHIFT_ROM_PGE) & BIT_ROM_PGE;\n\trtw_write32(rtwdev, REG_MCUFW_CTRL, val32);\n\n\tfor (block = 0; block < block_nr; block++) {\n\t\trtw_write32(rtwdev, write_addr, le32_to_cpu(*ptr));\n\n\t\twrite_addr += DLFW_BLK_SIZE_LEGACY;\n\t\tptr++;\n\t}\n\n\tif (remain_size) {\n\t\tmemcpy(&remain_data, ptr, remain_size);\n\t\trtw_write32(rtwdev, write_addr, le32_to_cpu(remain_data));\n\t}\n}\n\nstatic int\ndownload_firmware_legacy(struct rtw_dev *rtwdev, const u8 *data, u32 size)\n{\n\tu32 page;\n\tu32 total_page;\n\tu32 last_page_size;\n\n\tdata += sizeof(struct rtw_fw_hdr_legacy);\n\tsize -= sizeof(struct rtw_fw_hdr_legacy);\n\n\ttotal_page = size >> DLFW_PAGE_SIZE_SHIFT_LEGACY;\n\tlast_page_size = size & (DLFW_PAGE_SIZE_LEGACY - 1);\n\n\trtw_write8_set(rtwdev, REG_MCUFW_CTRL, BIT_FWDL_CHK_RPT);\n\n\tfor (page = 0; page < total_page; page++) {\n\t\twrite_firmware_page(rtwdev, page, data, DLFW_PAGE_SIZE_LEGACY);\n\t\tdata += DLFW_PAGE_SIZE_LEGACY;\n\t}\n\tif (last_page_size)\n\t\twrite_firmware_page(rtwdev, page, data, last_page_size);\n\n\tif (!check_hw_ready(rtwdev, REG_MCUFW_CTRL, BIT_FWDL_CHK_RPT, 1)) {\n\t\trtw_err(rtwdev, \"failed to check download firmware report\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int download_firmware_validate_legacy(struct rtw_dev *rtwdev)\n{\n\tu32 val32;\n\tint try;\n\n\tval32 = rtw_read32(rtwdev, REG_MCUFW_CTRL);\n\tval32 |= BIT_MCUFWDL_RDY;\n\tval32 &= ~BIT_WINTINI_RDY;\n\trtw_write32(rtwdev, REG_MCUFW_CTRL, val32);\n\n\twlan_cpu_enable(rtwdev, false);\n\twlan_cpu_enable(rtwdev, true);\n\n\tfor (try = 0; try < 10; try++) {\n\t\tval32 = rtw_read32(rtwdev, REG_MCUFW_CTRL);\n\t\tif ((val32 & FW_READY_LEGACY) == FW_READY_LEGACY)\n\t\t\treturn 0;\n\t\tmsleep(20);\n\t}\n\n\trtw_err(rtwdev, \"failed to validate firmware\\n\");\n\treturn -EINVAL;\n}\n\nstatic int __rtw_download_firmware_legacy(struct rtw_dev *rtwdev,\n\t\t\t\t\t  struct rtw_fw_state *fw)\n{\n\tint ret = 0;\n\n\ten_download_firmware_legacy(rtwdev, true);\n\tret = download_firmware_legacy(rtwdev, fw->firmware->data, fw->firmware->size);\n\ten_download_firmware_legacy(rtwdev, false);\n\tif (ret)\n\t\tgoto out;\n\n\tret = download_firmware_validate_legacy(rtwdev);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\trtw_hci_setup(rtwdev);\n\n\trtwdev->h2c.last_box_num = 0;\n\trtwdev->h2c.seq = 0;\n\n\tset_bit(RTW_FLAG_FW_RUNNING, rtwdev->flags);\n\nout:\n\treturn ret;\n}\n\nstatic\nint _rtw_download_firmware(struct rtw_dev *rtwdev, struct rtw_fw_state *fw)\n{\n\tif (rtw_chip_wcpu_11n(rtwdev))\n\t\treturn __rtw_download_firmware_legacy(rtwdev, fw);\n\n\treturn __rtw_download_firmware(rtwdev, fw);\n}\n\nint rtw_download_firmware(struct rtw_dev *rtwdev, struct rtw_fw_state *fw)\n{\n\tint ret;\n\n\tret = _rtw_download_firmware(rtwdev, fw);\n\tif (ret)\n\t\treturn ret;\n\n\tif (rtw_hci_type(rtwdev) == RTW_HCI_TYPE_PCIE &&\n\t    rtwdev->chip->id == RTW_CHIP_TYPE_8821C)\n\t\trtw_fw_set_recover_bt_device(rtwdev);\n\n\treturn 0;\n}\n\nstatic u32 get_priority_queues(struct rtw_dev *rtwdev, u32 queues)\n{\n\tconst struct rtw_rqpn *rqpn = rtwdev->fifo.rqpn;\n\tu32 prio_queues = 0;\n\n\tif (queues & BIT(IEEE80211_AC_VO))\n\t\tprio_queues |= BIT(rqpn->dma_map_vo);\n\tif (queues & BIT(IEEE80211_AC_VI))\n\t\tprio_queues |= BIT(rqpn->dma_map_vi);\n\tif (queues & BIT(IEEE80211_AC_BE))\n\t\tprio_queues |= BIT(rqpn->dma_map_be);\n\tif (queues & BIT(IEEE80211_AC_BK))\n\t\tprio_queues |= BIT(rqpn->dma_map_bk);\n\n\treturn prio_queues;\n}\n\nstatic void __rtw_mac_flush_prio_queue(struct rtw_dev *rtwdev,\n\t\t\t\t       u32 prio_queue, bool drop)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tconst struct rtw_prioq_addr *addr;\n\tbool wsize;\n\tu16 avail_page, rsvd_page;\n\tint i;\n\n\tif (prio_queue >= RTW_DMA_MAPPING_MAX)\n\t\treturn;\n\n\taddr = &chip->prioq_addrs->prio[prio_queue];\n\twsize = chip->prioq_addrs->wsize;\n\n\t \n\tfor (i = 0; i < 5; i++) {\n\t\trsvd_page = wsize ? rtw_read16(rtwdev, addr->rsvd) :\n\t\t\t\t     rtw_read8(rtwdev, addr->rsvd);\n\t\tavail_page = wsize ? rtw_read16(rtwdev, addr->avail) :\n\t\t\t\t      rtw_read8(rtwdev, addr->avail);\n\t\tif (rsvd_page == avail_page)\n\t\t\treturn;\n\n\t\tmsleep(20);\n\t}\n\n\t \n\tif (!drop)\n\t\trtw_warn(rtwdev, \"timed out to flush queue %d\\n\", prio_queue);\n}\n\nstatic void rtw_mac_flush_prio_queues(struct rtw_dev *rtwdev,\n\t\t\t\t      u32 prio_queues, bool drop)\n{\n\tu32 q;\n\n\tfor (q = 0; q < RTW_DMA_MAPPING_MAX; q++)\n\t\tif (prio_queues & BIT(q))\n\t\t\t__rtw_mac_flush_prio_queue(rtwdev, q, drop);\n}\n\nvoid rtw_mac_flush_queues(struct rtw_dev *rtwdev, u32 queues, bool drop)\n{\n\tu32 prio_queues = 0;\n\n\t \n\tif (queues == BIT(rtwdev->hw->queues) - 1 || !rtwdev->fifo.rqpn)\n\t\tprio_queues = BIT(RTW_DMA_MAPPING_MAX) - 1;\n\telse\n\t\tprio_queues = get_priority_queues(rtwdev, queues);\n\n\trtw_mac_flush_prio_queues(rtwdev, prio_queues, drop);\n}\n\nstatic int txdma_queue_mapping(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tconst struct rtw_rqpn *rqpn = NULL;\n\tu16 txdma_pq_map = 0;\n\n\tswitch (rtw_hci_type(rtwdev)) {\n\tcase RTW_HCI_TYPE_PCIE:\n\t\trqpn = &chip->rqpn_table[1];\n\t\tbreak;\n\tcase RTW_HCI_TYPE_USB:\n\t\tif (rtwdev->hci.bulkout_num == 2)\n\t\t\trqpn = &chip->rqpn_table[2];\n\t\telse if (rtwdev->hci.bulkout_num == 3)\n\t\t\trqpn = &chip->rqpn_table[3];\n\t\telse if (rtwdev->hci.bulkout_num == 4)\n\t\t\trqpn = &chip->rqpn_table[4];\n\t\telse\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase RTW_HCI_TYPE_SDIO:\n\t\trqpn = &chip->rqpn_table[0];\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\trtwdev->fifo.rqpn = rqpn;\n\ttxdma_pq_map |= BIT_TXDMA_HIQ_MAP(rqpn->dma_map_hi);\n\ttxdma_pq_map |= BIT_TXDMA_MGQ_MAP(rqpn->dma_map_mg);\n\ttxdma_pq_map |= BIT_TXDMA_BKQ_MAP(rqpn->dma_map_bk);\n\ttxdma_pq_map |= BIT_TXDMA_BEQ_MAP(rqpn->dma_map_be);\n\ttxdma_pq_map |= BIT_TXDMA_VIQ_MAP(rqpn->dma_map_vi);\n\ttxdma_pq_map |= BIT_TXDMA_VOQ_MAP(rqpn->dma_map_vo);\n\trtw_write16(rtwdev, REG_TXDMA_PQ_MAP, txdma_pq_map);\n\n\trtw_write8(rtwdev, REG_CR, 0);\n\trtw_write8(rtwdev, REG_CR, MAC_TRX_ENABLE);\n\tif (rtw_chip_wcpu_11ac(rtwdev))\n\t\trtw_write32(rtwdev, REG_H2CQ_CSR, BIT_H2CQ_FULL);\n\n\tif (rtw_hci_type(rtwdev) == RTW_HCI_TYPE_SDIO) {\n\t\trtw_read32(rtwdev, REG_SDIO_FREE_TXPG);\n\t\trtw_write32(rtwdev, REG_SDIO_TX_CTRL, 0);\n\t} else if (rtw_hci_type(rtwdev) == RTW_HCI_TYPE_USB) {\n\t\trtw_write8_set(rtwdev, REG_TXDMA_PQ_MAP, BIT_RXDMA_ARBBW_EN);\n\t}\n\n\treturn 0;\n}\n\nstatic int set_trx_fifo_info(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_fifo_conf *fifo = &rtwdev->fifo;\n\tu16 cur_pg_addr;\n\tu8 csi_buf_pg_num = chip->csi_buf_pg_num;\n\n\t \n\tfifo->rsvd_drv_pg_num = chip->rsvd_drv_pg_num;\n\tfifo->txff_pg_num = chip->txff_size >> 7;\n\tif (rtw_chip_wcpu_11n(rtwdev))\n\t\tfifo->rsvd_pg_num = fifo->rsvd_drv_pg_num;\n\telse\n\t\tfifo->rsvd_pg_num = fifo->rsvd_drv_pg_num +\n\t\t\t\t   RSVD_PG_H2C_EXTRAINFO_NUM +\n\t\t\t\t   RSVD_PG_H2C_STATICINFO_NUM +\n\t\t\t\t   RSVD_PG_H2CQ_NUM +\n\t\t\t\t   RSVD_PG_CPU_INSTRUCTION_NUM +\n\t\t\t\t   RSVD_PG_FW_TXBUF_NUM +\n\t\t\t\t   csi_buf_pg_num;\n\n\tif (fifo->rsvd_pg_num > fifo->txff_pg_num)\n\t\treturn -ENOMEM;\n\n\tfifo->acq_pg_num = fifo->txff_pg_num - fifo->rsvd_pg_num;\n\tfifo->rsvd_boundary = fifo->txff_pg_num - fifo->rsvd_pg_num;\n\n\tcur_pg_addr = fifo->txff_pg_num;\n\tif (rtw_chip_wcpu_11ac(rtwdev)) {\n\t\tcur_pg_addr -= csi_buf_pg_num;\n\t\tfifo->rsvd_csibuf_addr = cur_pg_addr;\n\t\tcur_pg_addr -= RSVD_PG_FW_TXBUF_NUM;\n\t\tfifo->rsvd_fw_txbuf_addr = cur_pg_addr;\n\t\tcur_pg_addr -= RSVD_PG_CPU_INSTRUCTION_NUM;\n\t\tfifo->rsvd_cpu_instr_addr = cur_pg_addr;\n\t\tcur_pg_addr -= RSVD_PG_H2CQ_NUM;\n\t\tfifo->rsvd_h2cq_addr = cur_pg_addr;\n\t\tcur_pg_addr -= RSVD_PG_H2C_STATICINFO_NUM;\n\t\tfifo->rsvd_h2c_sta_info_addr = cur_pg_addr;\n\t\tcur_pg_addr -= RSVD_PG_H2C_EXTRAINFO_NUM;\n\t\tfifo->rsvd_h2c_info_addr = cur_pg_addr;\n\t}\n\tcur_pg_addr -= fifo->rsvd_drv_pg_num;\n\tfifo->rsvd_drv_addr = cur_pg_addr;\n\n\tif (fifo->rsvd_boundary != fifo->rsvd_drv_addr) {\n\t\trtw_err(rtwdev, \"wrong rsvd driver address\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int __priority_queue_cfg(struct rtw_dev *rtwdev,\n\t\t\t\tconst struct rtw_page_table *pg_tbl,\n\t\t\t\tu16 pubq_num)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_fifo_conf *fifo = &rtwdev->fifo;\n\n\trtw_write16(rtwdev, REG_FIFOPAGE_INFO_1, pg_tbl->hq_num);\n\trtw_write16(rtwdev, REG_FIFOPAGE_INFO_2, pg_tbl->lq_num);\n\trtw_write16(rtwdev, REG_FIFOPAGE_INFO_3, pg_tbl->nq_num);\n\trtw_write16(rtwdev, REG_FIFOPAGE_INFO_4, pg_tbl->exq_num);\n\trtw_write16(rtwdev, REG_FIFOPAGE_INFO_5, pubq_num);\n\trtw_write32_set(rtwdev, REG_RQPN_CTRL_2, BIT_LD_RQPN);\n\n\trtw_write16(rtwdev, REG_FIFOPAGE_CTRL_2, fifo->rsvd_boundary);\n\trtw_write8_set(rtwdev, REG_FWHW_TXQ_CTRL + 2, BIT_EN_WR_FREE_TAIL >> 16);\n\n\trtw_write16(rtwdev, REG_BCNQ_BDNY_V1, fifo->rsvd_boundary);\n\trtw_write16(rtwdev, REG_FIFOPAGE_CTRL_2 + 2, fifo->rsvd_boundary);\n\trtw_write16(rtwdev, REG_BCNQ1_BDNY_V1, fifo->rsvd_boundary);\n\trtw_write32(rtwdev, REG_RXFF_BNDY, chip->rxff_size - C2H_PKT_BUF - 1);\n\trtw_write8_set(rtwdev, REG_AUTO_LLT_V1, BIT_AUTO_INIT_LLT_V1);\n\n\tif (!check_hw_ready(rtwdev, REG_AUTO_LLT_V1, BIT_AUTO_INIT_LLT_V1, 0))\n\t\treturn -EBUSY;\n\n\trtw_write8(rtwdev, REG_CR + 3, 0);\n\n\treturn 0;\n}\n\nstatic int __priority_queue_cfg_legacy(struct rtw_dev *rtwdev,\n\t\t\t\t       const struct rtw_page_table *pg_tbl,\n\t\t\t\t       u16 pubq_num)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_fifo_conf *fifo = &rtwdev->fifo;\n\tu32 val32;\n\n\tval32 = BIT_RQPN_NE(pg_tbl->nq_num, pg_tbl->exq_num);\n\trtw_write32(rtwdev, REG_RQPN_NPQ, val32);\n\tval32 = BIT_RQPN_HLP(pg_tbl->hq_num, pg_tbl->lq_num, pubq_num);\n\trtw_write32(rtwdev, REG_RQPN, val32);\n\n\trtw_write8(rtwdev, REG_TRXFF_BNDY, fifo->rsvd_boundary);\n\trtw_write16(rtwdev, REG_TRXFF_BNDY + 2, chip->rxff_size - REPORT_BUF - 1);\n\trtw_write8(rtwdev, REG_DWBCN0_CTRL + 1, fifo->rsvd_boundary);\n\trtw_write8(rtwdev, REG_BCNQ_BDNY, fifo->rsvd_boundary);\n\trtw_write8(rtwdev, REG_MGQ_BDNY, fifo->rsvd_boundary);\n\trtw_write8(rtwdev, REG_WMAC_LBK_BF_HD, fifo->rsvd_boundary);\n\n\trtw_write32_set(rtwdev, REG_AUTO_LLT, BIT_AUTO_INIT_LLT);\n\n\tif (!check_hw_ready(rtwdev, REG_AUTO_LLT, BIT_AUTO_INIT_LLT, 0))\n\t\treturn -EBUSY;\n\n\treturn 0;\n}\n\nstatic int priority_queue_cfg(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_fifo_conf *fifo = &rtwdev->fifo;\n\tconst struct rtw_page_table *pg_tbl = NULL;\n\tu16 pubq_num;\n\tint ret;\n\n\tret = set_trx_fifo_info(rtwdev);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (rtw_hci_type(rtwdev)) {\n\tcase RTW_HCI_TYPE_PCIE:\n\t\tpg_tbl = &chip->page_table[1];\n\t\tbreak;\n\tcase RTW_HCI_TYPE_USB:\n\t\tif (rtwdev->hci.bulkout_num == 2)\n\t\t\tpg_tbl = &chip->page_table[2];\n\t\telse if (rtwdev->hci.bulkout_num == 3)\n\t\t\tpg_tbl = &chip->page_table[3];\n\t\telse if (rtwdev->hci.bulkout_num == 4)\n\t\t\tpg_tbl = &chip->page_table[4];\n\t\telse\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase RTW_HCI_TYPE_SDIO:\n\t\tpg_tbl = &chip->page_table[0];\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tpubq_num = fifo->acq_pg_num - pg_tbl->hq_num - pg_tbl->lq_num -\n\t\t   pg_tbl->nq_num - pg_tbl->exq_num - pg_tbl->gapq_num;\n\tif (rtw_chip_wcpu_11n(rtwdev))\n\t\treturn __priority_queue_cfg_legacy(rtwdev, pg_tbl, pubq_num);\n\telse\n\t\treturn __priority_queue_cfg(rtwdev, pg_tbl, pubq_num);\n}\n\nstatic int init_h2c(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_fifo_conf *fifo = &rtwdev->fifo;\n\tu8 value8;\n\tu32 value32;\n\tu32 h2cq_addr;\n\tu32 h2cq_size;\n\tu32 h2cq_free;\n\tu32 wp, rp;\n\n\tif (rtw_chip_wcpu_11n(rtwdev))\n\t\treturn 0;\n\n\th2cq_addr = fifo->rsvd_h2cq_addr << TX_PAGE_SIZE_SHIFT;\n\th2cq_size = RSVD_PG_H2CQ_NUM << TX_PAGE_SIZE_SHIFT;\n\n\tvalue32 = rtw_read32(rtwdev, REG_H2C_HEAD);\n\tvalue32 = (value32 & 0xFFFC0000) | h2cq_addr;\n\trtw_write32(rtwdev, REG_H2C_HEAD, value32);\n\n\tvalue32 = rtw_read32(rtwdev, REG_H2C_READ_ADDR);\n\tvalue32 = (value32 & 0xFFFC0000) | h2cq_addr;\n\trtw_write32(rtwdev, REG_H2C_READ_ADDR, value32);\n\n\tvalue32 = rtw_read32(rtwdev, REG_H2C_TAIL);\n\tvalue32 &= 0xFFFC0000;\n\tvalue32 |= (h2cq_addr + h2cq_size);\n\trtw_write32(rtwdev, REG_H2C_TAIL, value32);\n\n\tvalue8 = rtw_read8(rtwdev, REG_H2C_INFO);\n\tvalue8 = (u8)((value8 & 0xFC) | 0x01);\n\trtw_write8(rtwdev, REG_H2C_INFO, value8);\n\n\tvalue8 = rtw_read8(rtwdev, REG_H2C_INFO);\n\tvalue8 = (u8)((value8 & 0xFB) | 0x04);\n\trtw_write8(rtwdev, REG_H2C_INFO, value8);\n\n\tvalue8 = rtw_read8(rtwdev, REG_TXDMA_OFFSET_CHK + 1);\n\tvalue8 = (u8)((value8 & 0x7f) | 0x80);\n\trtw_write8(rtwdev, REG_TXDMA_OFFSET_CHK + 1, value8);\n\n\twp = rtw_read32(rtwdev, REG_H2C_PKT_WRITEADDR) & 0x3FFFF;\n\trp = rtw_read32(rtwdev, REG_H2C_PKT_READADDR) & 0x3FFFF;\n\th2cq_free = wp >= rp ? h2cq_size - (wp - rp) : rp - wp;\n\n\tif (h2cq_size != h2cq_free) {\n\t\trtw_err(rtwdev, \"H2C queue mismatch\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int rtw_init_trx_cfg(struct rtw_dev *rtwdev)\n{\n\tint ret;\n\n\tret = txdma_queue_mapping(rtwdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = priority_queue_cfg(rtwdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = init_h2c(rtwdev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int rtw_drv_info_cfg(struct rtw_dev *rtwdev)\n{\n\tu8 value8;\n\n\trtw_write8(rtwdev, REG_RX_DRVINFO_SZ, PHY_STATUS_SIZE);\n\tif (rtw_chip_wcpu_11ac(rtwdev)) {\n\t\tvalue8 = rtw_read8(rtwdev, REG_TRXFF_BNDY + 1);\n\t\tvalue8 &= 0xF0;\n\t\t \n\t\tvalue8 |= 0xF;\n\t\trtw_write8(rtwdev, REG_TRXFF_BNDY + 1, value8);\n\t}\n\trtw_write32_set(rtwdev, REG_RCR, BIT_APP_PHYSTS);\n\trtw_write32_clr(rtwdev, REG_WMAC_OPTION_FUNCTION + 4, BIT(8) | BIT(9));\n\n\treturn 0;\n}\n\nint rtw_mac_init(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tint ret;\n\n\tret = rtw_init_trx_cfg(rtwdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = chip->ops->mac_init(rtwdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rtw_drv_info_cfg(rtwdev);\n\tif (ret)\n\t\treturn ret;\n\n\trtw_hci_interface_cfg(rtwdev);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}