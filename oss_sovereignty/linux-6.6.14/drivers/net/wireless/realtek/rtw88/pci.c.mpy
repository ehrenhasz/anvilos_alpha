{
  "module_name": "pci.c",
  "hash_id": "f8d8b4d0cb192f75c91334a6bdd0592dbaef15aa7b351c5205b9278b34a70ce6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtw88/pci.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/pci.h>\n#include \"main.h\"\n#include \"pci.h\"\n#include \"reg.h\"\n#include \"tx.h\"\n#include \"rx.h\"\n#include \"fw.h\"\n#include \"ps.h\"\n#include \"debug.h\"\n\nstatic bool rtw_disable_msi;\nstatic bool rtw_pci_disable_aspm;\nmodule_param_named(disable_msi, rtw_disable_msi, bool, 0644);\nmodule_param_named(disable_aspm, rtw_pci_disable_aspm, bool, 0644);\nMODULE_PARM_DESC(disable_msi, \"Set Y to disable MSI interrupt support\");\nMODULE_PARM_DESC(disable_aspm, \"Set Y to disable PCI ASPM support\");\n\nstatic u32 rtw_pci_tx_queue_idx_addr[] = {\n\t[RTW_TX_QUEUE_BK]\t= RTK_PCI_TXBD_IDX_BKQ,\n\t[RTW_TX_QUEUE_BE]\t= RTK_PCI_TXBD_IDX_BEQ,\n\t[RTW_TX_QUEUE_VI]\t= RTK_PCI_TXBD_IDX_VIQ,\n\t[RTW_TX_QUEUE_VO]\t= RTK_PCI_TXBD_IDX_VOQ,\n\t[RTW_TX_QUEUE_MGMT]\t= RTK_PCI_TXBD_IDX_MGMTQ,\n\t[RTW_TX_QUEUE_HI0]\t= RTK_PCI_TXBD_IDX_HI0Q,\n\t[RTW_TX_QUEUE_H2C]\t= RTK_PCI_TXBD_IDX_H2CQ,\n};\n\nstatic u8 rtw_pci_get_tx_qsel(struct sk_buff *skb,\n\t\t\t      enum rtw_tx_queue_type queue)\n{\n\tswitch (queue) {\n\tcase RTW_TX_QUEUE_BCN:\n\t\treturn TX_DESC_QSEL_BEACON;\n\tcase RTW_TX_QUEUE_H2C:\n\t\treturn TX_DESC_QSEL_H2C;\n\tcase RTW_TX_QUEUE_MGMT:\n\t\treturn TX_DESC_QSEL_MGMT;\n\tcase RTW_TX_QUEUE_HI0:\n\t\treturn TX_DESC_QSEL_HIGH;\n\tdefault:\n\t\treturn skb->priority;\n\t}\n};\n\nstatic u8 rtw_pci_read8(struct rtw_dev *rtwdev, u32 addr)\n{\n\tstruct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;\n\n\treturn readb(rtwpci->mmap + addr);\n}\n\nstatic u16 rtw_pci_read16(struct rtw_dev *rtwdev, u32 addr)\n{\n\tstruct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;\n\n\treturn readw(rtwpci->mmap + addr);\n}\n\nstatic u32 rtw_pci_read32(struct rtw_dev *rtwdev, u32 addr)\n{\n\tstruct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;\n\n\treturn readl(rtwpci->mmap + addr);\n}\n\nstatic void rtw_pci_write8(struct rtw_dev *rtwdev, u32 addr, u8 val)\n{\n\tstruct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;\n\n\twriteb(val, rtwpci->mmap + addr);\n}\n\nstatic void rtw_pci_write16(struct rtw_dev *rtwdev, u32 addr, u16 val)\n{\n\tstruct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;\n\n\twritew(val, rtwpci->mmap + addr);\n}\n\nstatic void rtw_pci_write32(struct rtw_dev *rtwdev, u32 addr, u32 val)\n{\n\tstruct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;\n\n\twritel(val, rtwpci->mmap + addr);\n}\n\nstatic void rtw_pci_free_tx_ring_skbs(struct rtw_dev *rtwdev,\n\t\t\t\t      struct rtw_pci_tx_ring *tx_ring)\n{\n\tstruct pci_dev *pdev = to_pci_dev(rtwdev->dev);\n\tstruct rtw_pci_tx_data *tx_data;\n\tstruct sk_buff *skb, *tmp;\n\tdma_addr_t dma;\n\n\t \n\tskb_queue_walk_safe(&tx_ring->queue, skb, tmp) {\n\t\t__skb_unlink(skb, &tx_ring->queue);\n\t\ttx_data = rtw_pci_get_tx_data(skb);\n\t\tdma = tx_data->dma;\n\n\t\tdma_unmap_single(&pdev->dev, dma, skb->len, DMA_TO_DEVICE);\n\t\tdev_kfree_skb_any(skb);\n\t}\n}\n\nstatic void rtw_pci_free_tx_ring(struct rtw_dev *rtwdev,\n\t\t\t\t struct rtw_pci_tx_ring *tx_ring)\n{\n\tstruct pci_dev *pdev = to_pci_dev(rtwdev->dev);\n\tu8 *head = tx_ring->r.head;\n\tu32 len = tx_ring->r.len;\n\tint ring_sz = len * tx_ring->r.desc_size;\n\n\trtw_pci_free_tx_ring_skbs(rtwdev, tx_ring);\n\n\t \n\tdma_free_coherent(&pdev->dev, ring_sz, head, tx_ring->r.dma);\n\ttx_ring->r.head = NULL;\n}\n\nstatic void rtw_pci_free_rx_ring_skbs(struct rtw_dev *rtwdev,\n\t\t\t\t      struct rtw_pci_rx_ring *rx_ring)\n{\n\tstruct pci_dev *pdev = to_pci_dev(rtwdev->dev);\n\tstruct sk_buff *skb;\n\tint buf_sz = RTK_PCI_RX_BUF_SIZE;\n\tdma_addr_t dma;\n\tint i;\n\n\tfor (i = 0; i < rx_ring->r.len; i++) {\n\t\tskb = rx_ring->buf[i];\n\t\tif (!skb)\n\t\t\tcontinue;\n\n\t\tdma = *((dma_addr_t *)skb->cb);\n\t\tdma_unmap_single(&pdev->dev, dma, buf_sz, DMA_FROM_DEVICE);\n\t\tdev_kfree_skb(skb);\n\t\trx_ring->buf[i] = NULL;\n\t}\n}\n\nstatic void rtw_pci_free_rx_ring(struct rtw_dev *rtwdev,\n\t\t\t\t struct rtw_pci_rx_ring *rx_ring)\n{\n\tstruct pci_dev *pdev = to_pci_dev(rtwdev->dev);\n\tu8 *head = rx_ring->r.head;\n\tint ring_sz = rx_ring->r.desc_size * rx_ring->r.len;\n\n\trtw_pci_free_rx_ring_skbs(rtwdev, rx_ring);\n\n\tdma_free_coherent(&pdev->dev, ring_sz, head, rx_ring->r.dma);\n}\n\nstatic void rtw_pci_free_trx_ring(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;\n\tstruct rtw_pci_tx_ring *tx_ring;\n\tstruct rtw_pci_rx_ring *rx_ring;\n\tint i;\n\n\tfor (i = 0; i < RTK_MAX_TX_QUEUE_NUM; i++) {\n\t\ttx_ring = &rtwpci->tx_rings[i];\n\t\trtw_pci_free_tx_ring(rtwdev, tx_ring);\n\t}\n\n\tfor (i = 0; i < RTK_MAX_RX_QUEUE_NUM; i++) {\n\t\trx_ring = &rtwpci->rx_rings[i];\n\t\trtw_pci_free_rx_ring(rtwdev, rx_ring);\n\t}\n}\n\nstatic int rtw_pci_init_tx_ring(struct rtw_dev *rtwdev,\n\t\t\t\tstruct rtw_pci_tx_ring *tx_ring,\n\t\t\t\tu8 desc_size, u32 len)\n{\n\tstruct pci_dev *pdev = to_pci_dev(rtwdev->dev);\n\tint ring_sz = desc_size * len;\n\tdma_addr_t dma;\n\tu8 *head;\n\n\tif (len > TRX_BD_IDX_MASK) {\n\t\trtw_err(rtwdev, \"len %d exceeds maximum TX entries\\n\", len);\n\t\treturn -EINVAL;\n\t}\n\n\thead = dma_alloc_coherent(&pdev->dev, ring_sz, &dma, GFP_KERNEL);\n\tif (!head) {\n\t\trtw_err(rtwdev, \"failed to allocate tx ring\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tskb_queue_head_init(&tx_ring->queue);\n\ttx_ring->r.head = head;\n\ttx_ring->r.dma = dma;\n\ttx_ring->r.len = len;\n\ttx_ring->r.desc_size = desc_size;\n\ttx_ring->r.wp = 0;\n\ttx_ring->r.rp = 0;\n\n\treturn 0;\n}\n\nstatic int rtw_pci_reset_rx_desc(struct rtw_dev *rtwdev, struct sk_buff *skb,\n\t\t\t\t struct rtw_pci_rx_ring *rx_ring,\n\t\t\t\t u32 idx, u32 desc_sz)\n{\n\tstruct pci_dev *pdev = to_pci_dev(rtwdev->dev);\n\tstruct rtw_pci_rx_buffer_desc *buf_desc;\n\tint buf_sz = RTK_PCI_RX_BUF_SIZE;\n\tdma_addr_t dma;\n\n\tif (!skb)\n\t\treturn -EINVAL;\n\n\tdma = dma_map_single(&pdev->dev, skb->data, buf_sz, DMA_FROM_DEVICE);\n\tif (dma_mapping_error(&pdev->dev, dma))\n\t\treturn -EBUSY;\n\n\t*((dma_addr_t *)skb->cb) = dma;\n\tbuf_desc = (struct rtw_pci_rx_buffer_desc *)(rx_ring->r.head +\n\t\t\t\t\t\t     idx * desc_sz);\n\tmemset(buf_desc, 0, sizeof(*buf_desc));\n\tbuf_desc->buf_size = cpu_to_le16(RTK_PCI_RX_BUF_SIZE);\n\tbuf_desc->dma = cpu_to_le32(dma);\n\n\treturn 0;\n}\n\nstatic void rtw_pci_sync_rx_desc_device(struct rtw_dev *rtwdev, dma_addr_t dma,\n\t\t\t\t\tstruct rtw_pci_rx_ring *rx_ring,\n\t\t\t\t\tu32 idx, u32 desc_sz)\n{\n\tstruct device *dev = rtwdev->dev;\n\tstruct rtw_pci_rx_buffer_desc *buf_desc;\n\tint buf_sz = RTK_PCI_RX_BUF_SIZE;\n\n\tdma_sync_single_for_device(dev, dma, buf_sz, DMA_FROM_DEVICE);\n\n\tbuf_desc = (struct rtw_pci_rx_buffer_desc *)(rx_ring->r.head +\n\t\t\t\t\t\t     idx * desc_sz);\n\tmemset(buf_desc, 0, sizeof(*buf_desc));\n\tbuf_desc->buf_size = cpu_to_le16(RTK_PCI_RX_BUF_SIZE);\n\tbuf_desc->dma = cpu_to_le32(dma);\n}\n\nstatic int rtw_pci_init_rx_ring(struct rtw_dev *rtwdev,\n\t\t\t\tstruct rtw_pci_rx_ring *rx_ring,\n\t\t\t\tu8 desc_size, u32 len)\n{\n\tstruct pci_dev *pdev = to_pci_dev(rtwdev->dev);\n\tstruct sk_buff *skb = NULL;\n\tdma_addr_t dma;\n\tu8 *head;\n\tint ring_sz = desc_size * len;\n\tint buf_sz = RTK_PCI_RX_BUF_SIZE;\n\tint i, allocated;\n\tint ret = 0;\n\n\thead = dma_alloc_coherent(&pdev->dev, ring_sz, &dma, GFP_KERNEL);\n\tif (!head) {\n\t\trtw_err(rtwdev, \"failed to allocate rx ring\\n\");\n\t\treturn -ENOMEM;\n\t}\n\trx_ring->r.head = head;\n\n\tfor (i = 0; i < len; i++) {\n\t\tskb = dev_alloc_skb(buf_sz);\n\t\tif (!skb) {\n\t\t\tallocated = i;\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tmemset(skb->data, 0, buf_sz);\n\t\trx_ring->buf[i] = skb;\n\t\tret = rtw_pci_reset_rx_desc(rtwdev, skb, rx_ring, i, desc_size);\n\t\tif (ret) {\n\t\t\tallocated = i;\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\trx_ring->r.dma = dma;\n\trx_ring->r.len = len;\n\trx_ring->r.desc_size = desc_size;\n\trx_ring->r.wp = 0;\n\trx_ring->r.rp = 0;\n\n\treturn 0;\n\nerr_out:\n\tfor (i = 0; i < allocated; i++) {\n\t\tskb = rx_ring->buf[i];\n\t\tif (!skb)\n\t\t\tcontinue;\n\t\tdma = *((dma_addr_t *)skb->cb);\n\t\tdma_unmap_single(&pdev->dev, dma, buf_sz, DMA_FROM_DEVICE);\n\t\tdev_kfree_skb_any(skb);\n\t\trx_ring->buf[i] = NULL;\n\t}\n\tdma_free_coherent(&pdev->dev, ring_sz, head, dma);\n\n\trtw_err(rtwdev, \"failed to init rx buffer\\n\");\n\n\treturn ret;\n}\n\nstatic int rtw_pci_init_trx_ring(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;\n\tstruct rtw_pci_tx_ring *tx_ring;\n\tstruct rtw_pci_rx_ring *rx_ring;\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tint i = 0, j = 0, tx_alloced = 0, rx_alloced = 0;\n\tint tx_desc_size, rx_desc_size;\n\tu32 len;\n\tint ret;\n\n\ttx_desc_size = chip->tx_buf_desc_sz;\n\n\tfor (i = 0; i < RTK_MAX_TX_QUEUE_NUM; i++) {\n\t\ttx_ring = &rtwpci->tx_rings[i];\n\t\tlen = max_num_of_tx_queue(i);\n\t\tret = rtw_pci_init_tx_ring(rtwdev, tx_ring, tx_desc_size, len);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\trx_desc_size = chip->rx_buf_desc_sz;\n\n\tfor (j = 0; j < RTK_MAX_RX_QUEUE_NUM; j++) {\n\t\trx_ring = &rtwpci->rx_rings[j];\n\t\tret = rtw_pci_init_rx_ring(rtwdev, rx_ring, rx_desc_size,\n\t\t\t\t\t   RTK_MAX_RX_DESC_NUM);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\treturn 0;\n\nout:\n\ttx_alloced = i;\n\tfor (i = 0; i < tx_alloced; i++) {\n\t\ttx_ring = &rtwpci->tx_rings[i];\n\t\trtw_pci_free_tx_ring(rtwdev, tx_ring);\n\t}\n\n\trx_alloced = j;\n\tfor (j = 0; j < rx_alloced; j++) {\n\t\trx_ring = &rtwpci->rx_rings[j];\n\t\trtw_pci_free_rx_ring(rtwdev, rx_ring);\n\t}\n\n\treturn ret;\n}\n\nstatic void rtw_pci_deinit(struct rtw_dev *rtwdev)\n{\n\trtw_pci_free_trx_ring(rtwdev);\n}\n\nstatic int rtw_pci_init(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;\n\tint ret = 0;\n\n\trtwpci->irq_mask[0] = IMR_HIGHDOK |\n\t\t\t      IMR_MGNTDOK |\n\t\t\t      IMR_BKDOK |\n\t\t\t      IMR_BEDOK |\n\t\t\t      IMR_VIDOK |\n\t\t\t      IMR_VODOK |\n\t\t\t      IMR_ROK |\n\t\t\t      IMR_BCNDMAINT_E |\n\t\t\t      IMR_C2HCMD |\n\t\t\t      0;\n\trtwpci->irq_mask[1] = IMR_TXFOVW |\n\t\t\t      0;\n\trtwpci->irq_mask[3] = IMR_H2CDOK |\n\t\t\t      0;\n\tspin_lock_init(&rtwpci->irq_lock);\n\tspin_lock_init(&rtwpci->hwirq_lock);\n\tret = rtw_pci_init_trx_ring(rtwdev);\n\n\treturn ret;\n}\n\nstatic void rtw_pci_reset_buf_desc(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;\n\tu32 len;\n\tu8 tmp;\n\tdma_addr_t dma;\n\n\ttmp = rtw_read8(rtwdev, RTK_PCI_CTRL + 3);\n\trtw_write8(rtwdev, RTK_PCI_CTRL + 3, tmp | 0xf7);\n\n\tdma = rtwpci->tx_rings[RTW_TX_QUEUE_BCN].r.dma;\n\trtw_write32(rtwdev, RTK_PCI_TXBD_DESA_BCNQ, dma);\n\n\tif (!rtw_chip_wcpu_11n(rtwdev)) {\n\t\tlen = rtwpci->tx_rings[RTW_TX_QUEUE_H2C].r.len;\n\t\tdma = rtwpci->tx_rings[RTW_TX_QUEUE_H2C].r.dma;\n\t\trtwpci->tx_rings[RTW_TX_QUEUE_H2C].r.rp = 0;\n\t\trtwpci->tx_rings[RTW_TX_QUEUE_H2C].r.wp = 0;\n\t\trtw_write16(rtwdev, RTK_PCI_TXBD_NUM_H2CQ, len & TRX_BD_IDX_MASK);\n\t\trtw_write32(rtwdev, RTK_PCI_TXBD_DESA_H2CQ, dma);\n\t}\n\n\tlen = rtwpci->tx_rings[RTW_TX_QUEUE_BK].r.len;\n\tdma = rtwpci->tx_rings[RTW_TX_QUEUE_BK].r.dma;\n\trtwpci->tx_rings[RTW_TX_QUEUE_BK].r.rp = 0;\n\trtwpci->tx_rings[RTW_TX_QUEUE_BK].r.wp = 0;\n\trtw_write16(rtwdev, RTK_PCI_TXBD_NUM_BKQ, len & TRX_BD_IDX_MASK);\n\trtw_write32(rtwdev, RTK_PCI_TXBD_DESA_BKQ, dma);\n\n\tlen = rtwpci->tx_rings[RTW_TX_QUEUE_BE].r.len;\n\tdma = rtwpci->tx_rings[RTW_TX_QUEUE_BE].r.dma;\n\trtwpci->tx_rings[RTW_TX_QUEUE_BE].r.rp = 0;\n\trtwpci->tx_rings[RTW_TX_QUEUE_BE].r.wp = 0;\n\trtw_write16(rtwdev, RTK_PCI_TXBD_NUM_BEQ, len & TRX_BD_IDX_MASK);\n\trtw_write32(rtwdev, RTK_PCI_TXBD_DESA_BEQ, dma);\n\n\tlen = rtwpci->tx_rings[RTW_TX_QUEUE_VO].r.len;\n\tdma = rtwpci->tx_rings[RTW_TX_QUEUE_VO].r.dma;\n\trtwpci->tx_rings[RTW_TX_QUEUE_VO].r.rp = 0;\n\trtwpci->tx_rings[RTW_TX_QUEUE_VO].r.wp = 0;\n\trtw_write16(rtwdev, RTK_PCI_TXBD_NUM_VOQ, len & TRX_BD_IDX_MASK);\n\trtw_write32(rtwdev, RTK_PCI_TXBD_DESA_VOQ, dma);\n\n\tlen = rtwpci->tx_rings[RTW_TX_QUEUE_VI].r.len;\n\tdma = rtwpci->tx_rings[RTW_TX_QUEUE_VI].r.dma;\n\trtwpci->tx_rings[RTW_TX_QUEUE_VI].r.rp = 0;\n\trtwpci->tx_rings[RTW_TX_QUEUE_VI].r.wp = 0;\n\trtw_write16(rtwdev, RTK_PCI_TXBD_NUM_VIQ, len & TRX_BD_IDX_MASK);\n\trtw_write32(rtwdev, RTK_PCI_TXBD_DESA_VIQ, dma);\n\n\tlen = rtwpci->tx_rings[RTW_TX_QUEUE_MGMT].r.len;\n\tdma = rtwpci->tx_rings[RTW_TX_QUEUE_MGMT].r.dma;\n\trtwpci->tx_rings[RTW_TX_QUEUE_MGMT].r.rp = 0;\n\trtwpci->tx_rings[RTW_TX_QUEUE_MGMT].r.wp = 0;\n\trtw_write16(rtwdev, RTK_PCI_TXBD_NUM_MGMTQ, len & TRX_BD_IDX_MASK);\n\trtw_write32(rtwdev, RTK_PCI_TXBD_DESA_MGMTQ, dma);\n\n\tlen = rtwpci->tx_rings[RTW_TX_QUEUE_HI0].r.len;\n\tdma = rtwpci->tx_rings[RTW_TX_QUEUE_HI0].r.dma;\n\trtwpci->tx_rings[RTW_TX_QUEUE_HI0].r.rp = 0;\n\trtwpci->tx_rings[RTW_TX_QUEUE_HI0].r.wp = 0;\n\trtw_write16(rtwdev, RTK_PCI_TXBD_NUM_HI0Q, len & TRX_BD_IDX_MASK);\n\trtw_write32(rtwdev, RTK_PCI_TXBD_DESA_HI0Q, dma);\n\n\tlen = rtwpci->rx_rings[RTW_RX_QUEUE_MPDU].r.len;\n\tdma = rtwpci->rx_rings[RTW_RX_QUEUE_MPDU].r.dma;\n\trtwpci->rx_rings[RTW_RX_QUEUE_MPDU].r.rp = 0;\n\trtwpci->rx_rings[RTW_RX_QUEUE_MPDU].r.wp = 0;\n\trtw_write16(rtwdev, RTK_PCI_RXBD_NUM_MPDUQ, len & TRX_BD_IDX_MASK);\n\trtw_write32(rtwdev, RTK_PCI_RXBD_DESA_MPDUQ, dma);\n\n\t \n\trtw_write32(rtwdev, RTK_PCI_TXBD_RWPTR_CLR, 0xffffffff);\n\n\t \n\tif (rtw_chip_wcpu_11ac(rtwdev))\n\t\trtw_write32_set(rtwdev, RTK_PCI_TXBD_H2CQ_CSR,\n\t\t\t\tBIT_CLR_H2CQ_HOST_IDX | BIT_CLR_H2CQ_HW_IDX);\n}\n\nstatic void rtw_pci_reset_trx_ring(struct rtw_dev *rtwdev)\n{\n\trtw_pci_reset_buf_desc(rtwdev);\n}\n\nstatic void rtw_pci_enable_interrupt(struct rtw_dev *rtwdev,\n\t\t\t\t     struct rtw_pci *rtwpci, bool exclude_rx)\n{\n\tunsigned long flags;\n\tu32 imr0_unmask = exclude_rx ? IMR_ROK : 0;\n\n\tspin_lock_irqsave(&rtwpci->hwirq_lock, flags);\n\n\trtw_write32(rtwdev, RTK_PCI_HIMR0, rtwpci->irq_mask[0] & ~imr0_unmask);\n\trtw_write32(rtwdev, RTK_PCI_HIMR1, rtwpci->irq_mask[1]);\n\tif (rtw_chip_wcpu_11ac(rtwdev))\n\t\trtw_write32(rtwdev, RTK_PCI_HIMR3, rtwpci->irq_mask[3]);\n\n\trtwpci->irq_enabled = true;\n\n\tspin_unlock_irqrestore(&rtwpci->hwirq_lock, flags);\n}\n\nstatic void rtw_pci_disable_interrupt(struct rtw_dev *rtwdev,\n\t\t\t\t      struct rtw_pci *rtwpci)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rtwpci->hwirq_lock, flags);\n\n\tif (!rtwpci->irq_enabled)\n\t\tgoto out;\n\n\trtw_write32(rtwdev, RTK_PCI_HIMR0, 0);\n\trtw_write32(rtwdev, RTK_PCI_HIMR1, 0);\n\tif (rtw_chip_wcpu_11ac(rtwdev))\n\t\trtw_write32(rtwdev, RTK_PCI_HIMR3, 0);\n\n\trtwpci->irq_enabled = false;\n\nout:\n\tspin_unlock_irqrestore(&rtwpci->hwirq_lock, flags);\n}\n\nstatic void rtw_pci_dma_reset(struct rtw_dev *rtwdev, struct rtw_pci *rtwpci)\n{\n\t \n\trtw_write32_set(rtwdev, RTK_PCI_CTRL,\n\t\t\tBIT_RST_TRXDMA_INTF | BIT_RX_TAG_EN);\n\trtwpci->rx_tag = 0;\n}\n\nstatic int rtw_pci_setup(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;\n\n\trtw_pci_reset_trx_ring(rtwdev);\n\trtw_pci_dma_reset(rtwdev, rtwpci);\n\n\treturn 0;\n}\n\nstatic void rtw_pci_dma_release(struct rtw_dev *rtwdev, struct rtw_pci *rtwpci)\n{\n\tstruct rtw_pci_tx_ring *tx_ring;\n\tenum rtw_tx_queue_type queue;\n\n\trtw_pci_reset_trx_ring(rtwdev);\n\tfor (queue = 0; queue < RTK_MAX_TX_QUEUE_NUM; queue++) {\n\t\ttx_ring = &rtwpci->tx_rings[queue];\n\t\trtw_pci_free_tx_ring_skbs(rtwdev, tx_ring);\n\t}\n}\n\nstatic void rtw_pci_napi_start(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;\n\n\tif (test_and_set_bit(RTW_PCI_FLAG_NAPI_RUNNING, rtwpci->flags))\n\t\treturn;\n\n\tnapi_enable(&rtwpci->napi);\n}\n\nstatic void rtw_pci_napi_stop(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;\n\n\tif (!test_and_clear_bit(RTW_PCI_FLAG_NAPI_RUNNING, rtwpci->flags))\n\t\treturn;\n\n\tnapi_synchronize(&rtwpci->napi);\n\tnapi_disable(&rtwpci->napi);\n}\n\nstatic int rtw_pci_start(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;\n\n\trtw_pci_napi_start(rtwdev);\n\n\tspin_lock_bh(&rtwpci->irq_lock);\n\trtwpci->running = true;\n\trtw_pci_enable_interrupt(rtwdev, rtwpci, false);\n\tspin_unlock_bh(&rtwpci->irq_lock);\n\n\treturn 0;\n}\n\nstatic void rtw_pci_stop(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;\n\tstruct pci_dev *pdev = rtwpci->pdev;\n\n\tspin_lock_bh(&rtwpci->irq_lock);\n\trtwpci->running = false;\n\trtw_pci_disable_interrupt(rtwdev, rtwpci);\n\tspin_unlock_bh(&rtwpci->irq_lock);\n\n\tsynchronize_irq(pdev->irq);\n\trtw_pci_napi_stop(rtwdev);\n\n\tspin_lock_bh(&rtwpci->irq_lock);\n\trtw_pci_dma_release(rtwdev, rtwpci);\n\tspin_unlock_bh(&rtwpci->irq_lock);\n}\n\nstatic void rtw_pci_deep_ps_enter(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;\n\tstruct rtw_pci_tx_ring *tx_ring;\n\tenum rtw_tx_queue_type queue;\n\tbool tx_empty = true;\n\n\tif (rtw_fw_feature_check(&rtwdev->fw, FW_FEATURE_TX_WAKE))\n\t\tgoto enter_deep_ps;\n\n\tlockdep_assert_held(&rtwpci->irq_lock);\n\n\t \n\tfor (queue = 0; queue < RTK_MAX_TX_QUEUE_NUM; queue++) {\n\t\t \n\t\tif (queue == RTW_TX_QUEUE_BCN ||\n\t\t    queue == RTW_TX_QUEUE_H2C)\n\t\t\tcontinue;\n\n\t\ttx_ring = &rtwpci->tx_rings[queue];\n\n\t\t \n\t\tif (skb_queue_len(&tx_ring->queue)) {\n\t\t\ttx_empty = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!tx_empty) {\n\t\trtw_dbg(rtwdev, RTW_DBG_PS,\n\t\t\t\"TX path not empty, cannot enter deep power save state\\n\");\n\t\treturn;\n\t}\nenter_deep_ps:\n\tset_bit(RTW_FLAG_LEISURE_PS_DEEP, rtwdev->flags);\n\trtw_power_mode_change(rtwdev, true);\n}\n\nstatic void rtw_pci_deep_ps_leave(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;\n\n\tlockdep_assert_held(&rtwpci->irq_lock);\n\n\tif (test_and_clear_bit(RTW_FLAG_LEISURE_PS_DEEP, rtwdev->flags))\n\t\trtw_power_mode_change(rtwdev, false);\n}\n\nstatic void rtw_pci_deep_ps(struct rtw_dev *rtwdev, bool enter)\n{\n\tstruct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;\n\n\tspin_lock_bh(&rtwpci->irq_lock);\n\n\tif (enter && !test_bit(RTW_FLAG_LEISURE_PS_DEEP, rtwdev->flags))\n\t\trtw_pci_deep_ps_enter(rtwdev);\n\n\tif (!enter && test_bit(RTW_FLAG_LEISURE_PS_DEEP, rtwdev->flags))\n\t\trtw_pci_deep_ps_leave(rtwdev);\n\n\tspin_unlock_bh(&rtwpci->irq_lock);\n}\n\nstatic void rtw_pci_release_rsvd_page(struct rtw_pci *rtwpci,\n\t\t\t\t      struct rtw_pci_tx_ring *ring)\n{\n\tstruct sk_buff *prev = skb_dequeue(&ring->queue);\n\tstruct rtw_pci_tx_data *tx_data;\n\tdma_addr_t dma;\n\n\tif (!prev)\n\t\treturn;\n\n\ttx_data = rtw_pci_get_tx_data(prev);\n\tdma = tx_data->dma;\n\tdma_unmap_single(&rtwpci->pdev->dev, dma, prev->len, DMA_TO_DEVICE);\n\tdev_kfree_skb_any(prev);\n}\n\nstatic void rtw_pci_dma_check(struct rtw_dev *rtwdev,\n\t\t\t      struct rtw_pci_rx_ring *rx_ring,\n\t\t\t      u32 idx)\n{\n\tstruct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_pci_rx_buffer_desc *buf_desc;\n\tu32 desc_sz = chip->rx_buf_desc_sz;\n\tu16 total_pkt_size;\n\n\tbuf_desc = (struct rtw_pci_rx_buffer_desc *)(rx_ring->r.head +\n\t\t\t\t\t\t     idx * desc_sz);\n\ttotal_pkt_size = le16_to_cpu(buf_desc->total_pkt_size);\n\n\t \n\tif (total_pkt_size != rtwpci->rx_tag)\n\t\trtw_warn(rtwdev, \"pci bus timeout, check dma status\\n\");\n\n\trtwpci->rx_tag = (rtwpci->rx_tag + 1) % RX_TAG_MAX;\n}\n\nstatic u32 __pci_get_hw_tx_ring_rp(struct rtw_dev *rtwdev, u8 pci_q)\n{\n\tu32 bd_idx_addr = rtw_pci_tx_queue_idx_addr[pci_q];\n\tu32 bd_idx = rtw_read16(rtwdev, bd_idx_addr + 2);\n\n\treturn FIELD_GET(TRX_BD_IDX_MASK, bd_idx);\n}\n\nstatic void __pci_flush_queue(struct rtw_dev *rtwdev, u8 pci_q, bool drop)\n{\n\tstruct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;\n\tstruct rtw_pci_tx_ring *ring = &rtwpci->tx_rings[pci_q];\n\tu32 cur_rp;\n\tu8 i;\n\n\t \n\tfor (i = 0; i < 30; i++) {\n\t\tcur_rp = __pci_get_hw_tx_ring_rp(rtwdev, pci_q);\n\t\tif (cur_rp == ring->r.wp)\n\t\t\treturn;\n\n\t\tudelay(1);\n\t}\n\n\tif (!drop)\n\t\trtw_warn(rtwdev, \"timed out to flush pci tx ring[%d]\\n\", pci_q);\n}\n\nstatic void __rtw_pci_flush_queues(struct rtw_dev *rtwdev, u32 pci_queues,\n\t\t\t\t   bool drop)\n{\n\tu8 q;\n\n\tfor (q = 0; q < RTK_MAX_TX_QUEUE_NUM; q++) {\n\t\t \n\t\tif (q == RTW_TX_QUEUE_BCN || q == RTW_TX_QUEUE_H2C ||\n\t\t    q == RTW_TX_QUEUE_HI0)\n\t\t\tcontinue;\n\n\t\tif (pci_queues & BIT(q))\n\t\t\t__pci_flush_queue(rtwdev, q, drop);\n\t}\n}\n\nstatic void rtw_pci_flush_queues(struct rtw_dev *rtwdev, u32 queues, bool drop)\n{\n\tu32 pci_queues = 0;\n\tu8 i;\n\n\t \n\tif (queues == BIT(rtwdev->hw->queues) - 1) {\n\t\tpci_queues = BIT(RTK_MAX_TX_QUEUE_NUM) - 1;\n\t} else {\n\t\tfor (i = 0; i < rtwdev->hw->queues; i++)\n\t\t\tif (queues & BIT(i))\n\t\t\t\tpci_queues |= BIT(rtw_tx_ac_to_hwq(i));\n\t}\n\n\t__rtw_pci_flush_queues(rtwdev, pci_queues, drop);\n}\n\nstatic void rtw_pci_tx_kick_off_queue(struct rtw_dev *rtwdev,\n\t\t\t\t      enum rtw_tx_queue_type queue)\n{\n\tstruct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;\n\tstruct rtw_pci_tx_ring *ring;\n\tu32 bd_idx;\n\n\tring = &rtwpci->tx_rings[queue];\n\tbd_idx = rtw_pci_tx_queue_idx_addr[queue];\n\n\tspin_lock_bh(&rtwpci->irq_lock);\n\tif (!rtw_fw_feature_check(&rtwdev->fw, FW_FEATURE_TX_WAKE))\n\t\trtw_pci_deep_ps_leave(rtwdev);\n\trtw_write16(rtwdev, bd_idx, ring->r.wp & TRX_BD_IDX_MASK);\n\tspin_unlock_bh(&rtwpci->irq_lock);\n}\n\nstatic void rtw_pci_tx_kick_off(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;\n\tenum rtw_tx_queue_type queue;\n\n\tfor (queue = 0; queue < RTK_MAX_TX_QUEUE_NUM; queue++)\n\t\tif (test_and_clear_bit(queue, rtwpci->tx_queued))\n\t\t\trtw_pci_tx_kick_off_queue(rtwdev, queue);\n}\n\nstatic int rtw_pci_tx_write_data(struct rtw_dev *rtwdev,\n\t\t\t\t struct rtw_tx_pkt_info *pkt_info,\n\t\t\t\t struct sk_buff *skb,\n\t\t\t\t enum rtw_tx_queue_type queue)\n{\n\tstruct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_pci_tx_ring *ring;\n\tstruct rtw_pci_tx_data *tx_data;\n\tdma_addr_t dma;\n\tu32 tx_pkt_desc_sz = chip->tx_pkt_desc_sz;\n\tu32 tx_buf_desc_sz = chip->tx_buf_desc_sz;\n\tu32 size;\n\tu32 psb_len;\n\tu8 *pkt_desc;\n\tstruct rtw_pci_tx_buffer_desc *buf_desc;\n\n\tring = &rtwpci->tx_rings[queue];\n\n\tsize = skb->len;\n\n\tif (queue == RTW_TX_QUEUE_BCN)\n\t\trtw_pci_release_rsvd_page(rtwpci, ring);\n\telse if (!avail_desc(ring->r.wp, ring->r.rp, ring->r.len))\n\t\treturn -ENOSPC;\n\n\tpkt_desc = skb_push(skb, chip->tx_pkt_desc_sz);\n\tmemset(pkt_desc, 0, tx_pkt_desc_sz);\n\tpkt_info->qsel = rtw_pci_get_tx_qsel(skb, queue);\n\trtw_tx_fill_tx_desc(pkt_info, skb);\n\tdma = dma_map_single(&rtwpci->pdev->dev, skb->data, skb->len,\n\t\t\t     DMA_TO_DEVICE);\n\tif (dma_mapping_error(&rtwpci->pdev->dev, dma))\n\t\treturn -EBUSY;\n\n\t \n\tbuf_desc = get_tx_buffer_desc(ring, tx_buf_desc_sz);\n\tmemset(buf_desc, 0, tx_buf_desc_sz);\n\tpsb_len = (skb->len - 1) / 128 + 1;\n\tif (queue == RTW_TX_QUEUE_BCN)\n\t\tpsb_len |= 1 << RTK_PCI_TXBD_OWN_OFFSET;\n\n\tbuf_desc[0].psb_len = cpu_to_le16(psb_len);\n\tbuf_desc[0].buf_size = cpu_to_le16(tx_pkt_desc_sz);\n\tbuf_desc[0].dma = cpu_to_le32(dma);\n\tbuf_desc[1].buf_size = cpu_to_le16(size);\n\tbuf_desc[1].dma = cpu_to_le32(dma + tx_pkt_desc_sz);\n\n\ttx_data = rtw_pci_get_tx_data(skb);\n\ttx_data->dma = dma;\n\ttx_data->sn = pkt_info->sn;\n\n\tspin_lock_bh(&rtwpci->irq_lock);\n\n\tskb_queue_tail(&ring->queue, skb);\n\n\tif (queue == RTW_TX_QUEUE_BCN)\n\t\tgoto out_unlock;\n\n\t \n\tset_bit(queue, rtwpci->tx_queued);\n\tif (++ring->r.wp >= ring->r.len)\n\t\tring->r.wp = 0;\n\nout_unlock:\n\tspin_unlock_bh(&rtwpci->irq_lock);\n\n\treturn 0;\n}\n\nstatic int rtw_pci_write_data_rsvd_page(struct rtw_dev *rtwdev, u8 *buf,\n\t\t\t\t\tu32 size)\n{\n\tstruct sk_buff *skb;\n\tstruct rtw_tx_pkt_info pkt_info = {0};\n\tu8 reg_bcn_work;\n\tint ret;\n\n\tskb = rtw_tx_write_data_rsvd_page_get(rtwdev, &pkt_info, buf, size);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tret = rtw_pci_tx_write_data(rtwdev, &pkt_info, skb, RTW_TX_QUEUE_BCN);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to write rsvd page data\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\treg_bcn_work = rtw_read8(rtwdev, RTK_PCI_TXBD_BCN_WORK);\n\treg_bcn_work |= BIT_PCI_BCNQ_FLAG;\n\trtw_write8(rtwdev, RTK_PCI_TXBD_BCN_WORK, reg_bcn_work);\n\n\treturn 0;\n}\n\nstatic int rtw_pci_write_data_h2c(struct rtw_dev *rtwdev, u8 *buf, u32 size)\n{\n\tstruct sk_buff *skb;\n\tstruct rtw_tx_pkt_info pkt_info = {0};\n\tint ret;\n\n\tskb = rtw_tx_write_data_h2c_get(rtwdev, &pkt_info, buf, size);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tret = rtw_pci_tx_write_data(rtwdev, &pkt_info, skb, RTW_TX_QUEUE_H2C);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to write h2c data\\n\");\n\t\treturn ret;\n\t}\n\n\trtw_pci_tx_kick_off_queue(rtwdev, RTW_TX_QUEUE_H2C);\n\n\treturn 0;\n}\n\nstatic int rtw_pci_tx_write(struct rtw_dev *rtwdev,\n\t\t\t    struct rtw_tx_pkt_info *pkt_info,\n\t\t\t    struct sk_buff *skb)\n{\n\tenum rtw_tx_queue_type queue = rtw_tx_queue_mapping(skb);\n\tstruct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;\n\tstruct rtw_pci_tx_ring *ring;\n\tint ret;\n\n\tret = rtw_pci_tx_write_data(rtwdev, pkt_info, skb, queue);\n\tif (ret)\n\t\treturn ret;\n\n\tring = &rtwpci->tx_rings[queue];\n\tspin_lock_bh(&rtwpci->irq_lock);\n\tif (avail_desc(ring->r.wp, ring->r.rp, ring->r.len) < 2) {\n\t\tieee80211_stop_queue(rtwdev->hw, skb_get_queue_mapping(skb));\n\t\tring->queue_stopped = true;\n\t}\n\tspin_unlock_bh(&rtwpci->irq_lock);\n\n\treturn 0;\n}\n\nstatic void rtw_pci_tx_isr(struct rtw_dev *rtwdev, struct rtw_pci *rtwpci,\n\t\t\t   u8 hw_queue)\n{\n\tstruct ieee80211_hw *hw = rtwdev->hw;\n\tstruct ieee80211_tx_info *info;\n\tstruct rtw_pci_tx_ring *ring;\n\tstruct rtw_pci_tx_data *tx_data;\n\tstruct sk_buff *skb;\n\tu32 count;\n\tu32 bd_idx_addr;\n\tu32 bd_idx, cur_rp, rp_idx;\n\tu16 q_map;\n\n\tring = &rtwpci->tx_rings[hw_queue];\n\n\tbd_idx_addr = rtw_pci_tx_queue_idx_addr[hw_queue];\n\tbd_idx = rtw_read32(rtwdev, bd_idx_addr);\n\tcur_rp = bd_idx >> 16;\n\tcur_rp &= TRX_BD_IDX_MASK;\n\trp_idx = ring->r.rp;\n\tif (cur_rp >= ring->r.rp)\n\t\tcount = cur_rp - ring->r.rp;\n\telse\n\t\tcount = ring->r.len - (ring->r.rp - cur_rp);\n\n\twhile (count--) {\n\t\tskb = skb_dequeue(&ring->queue);\n\t\tif (!skb) {\n\t\t\trtw_err(rtwdev, \"failed to dequeue %d skb TX queue %d, BD=0x%08x, rp %d -> %d\\n\",\n\t\t\t\tcount, hw_queue, bd_idx, ring->r.rp, cur_rp);\n\t\t\tbreak;\n\t\t}\n\t\ttx_data = rtw_pci_get_tx_data(skb);\n\t\tdma_unmap_single(&rtwpci->pdev->dev, tx_data->dma, skb->len,\n\t\t\t\t DMA_TO_DEVICE);\n\n\t\t \n\t\tif (hw_queue == RTW_TX_QUEUE_H2C) {\n\t\t\tdev_kfree_skb_irq(skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ring->queue_stopped &&\n\t\t    avail_desc(ring->r.wp, rp_idx, ring->r.len) > 4) {\n\t\t\tq_map = skb_get_queue_mapping(skb);\n\t\t\tieee80211_wake_queue(hw, q_map);\n\t\t\tring->queue_stopped = false;\n\t\t}\n\n\t\tif (++rp_idx >= ring->r.len)\n\t\t\trp_idx = 0;\n\n\t\tskb_pull(skb, rtwdev->chip->tx_pkt_desc_sz);\n\n\t\tinfo = IEEE80211_SKB_CB(skb);\n\n\t\t \n\t\tif (info->flags & IEEE80211_TX_CTL_REQ_TX_STATUS) {\n\t\t\trtw_tx_report_enqueue(rtwdev, skb, tx_data->sn);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (info->flags & IEEE80211_TX_CTL_NO_ACK)\n\t\t\tinfo->flags |= IEEE80211_TX_STAT_NOACK_TRANSMITTED;\n\t\telse\n\t\t\tinfo->flags |= IEEE80211_TX_STAT_ACK;\n\n\t\tieee80211_tx_info_clear_status(info);\n\t\tieee80211_tx_status_irqsafe(hw, skb);\n\t}\n\n\tring->r.rp = cur_rp;\n}\n\nstatic void rtw_pci_rx_isr(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;\n\tstruct napi_struct *napi = &rtwpci->napi;\n\n\tnapi_schedule(napi);\n}\n\nstatic int rtw_pci_get_hw_rx_ring_nr(struct rtw_dev *rtwdev,\n\t\t\t\t     struct rtw_pci *rtwpci)\n{\n\tstruct rtw_pci_rx_ring *ring;\n\tint count = 0;\n\tu32 tmp, cur_wp;\n\n\tring = &rtwpci->rx_rings[RTW_RX_QUEUE_MPDU];\n\ttmp = rtw_read32(rtwdev, RTK_PCI_RXBD_IDX_MPDUQ);\n\tcur_wp = u32_get_bits(tmp, TRX_BD_HW_IDX_MASK);\n\tif (cur_wp >= ring->r.wp)\n\t\tcount = cur_wp - ring->r.wp;\n\telse\n\t\tcount = ring->r.len - (ring->r.wp - cur_wp);\n\n\treturn count;\n}\n\nstatic u32 rtw_pci_rx_napi(struct rtw_dev *rtwdev, struct rtw_pci *rtwpci,\n\t\t\t   u8 hw_queue, u32 limit)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct napi_struct *napi = &rtwpci->napi;\n\tstruct rtw_pci_rx_ring *ring = &rtwpci->rx_rings[RTW_RX_QUEUE_MPDU];\n\tstruct rtw_rx_pkt_stat pkt_stat;\n\tstruct ieee80211_rx_status rx_status;\n\tstruct sk_buff *skb, *new;\n\tu32 cur_rp = ring->r.rp;\n\tu32 count, rx_done = 0;\n\tu32 pkt_offset;\n\tu32 pkt_desc_sz = chip->rx_pkt_desc_sz;\n\tu32 buf_desc_sz = chip->rx_buf_desc_sz;\n\tu32 new_len;\n\tu8 *rx_desc;\n\tdma_addr_t dma;\n\n\tcount = rtw_pci_get_hw_rx_ring_nr(rtwdev, rtwpci);\n\tcount = min(count, limit);\n\n\twhile (count--) {\n\t\trtw_pci_dma_check(rtwdev, ring, cur_rp);\n\t\tskb = ring->buf[cur_rp];\n\t\tdma = *((dma_addr_t *)skb->cb);\n\t\tdma_sync_single_for_cpu(rtwdev->dev, dma, RTK_PCI_RX_BUF_SIZE,\n\t\t\t\t\tDMA_FROM_DEVICE);\n\t\trx_desc = skb->data;\n\t\tchip->ops->query_rx_desc(rtwdev, rx_desc, &pkt_stat, &rx_status);\n\n\t\t \n\t\tpkt_offset = pkt_desc_sz + pkt_stat.drv_info_sz +\n\t\t\t     pkt_stat.shift;\n\n\t\t \n\t\tnew_len = pkt_stat.pkt_len + pkt_offset;\n\t\tnew = dev_alloc_skb(new_len);\n\t\tif (WARN_ONCE(!new, \"rx routine starvation\\n\"))\n\t\t\tgoto next_rp;\n\n\t\t \n\t\tskb_put_data(new, skb->data, new_len);\n\n\t\tif (pkt_stat.is_c2h) {\n\t\t\trtw_fw_c2h_cmd_rx_irqsafe(rtwdev, pkt_offset, new);\n\t\t} else {\n\t\t\t \n\t\t\tskb_pull(new, pkt_offset);\n\n\t\t\trtw_rx_stats(rtwdev, pkt_stat.vif, new);\n\t\t\tmemcpy(new->cb, &rx_status, sizeof(rx_status));\n\t\t\tieee80211_rx_napi(rtwdev->hw, NULL, new, napi);\n\t\t\trx_done++;\n\t\t}\n\nnext_rp:\n\t\t \n\t\trtw_pci_sync_rx_desc_device(rtwdev, dma, ring, cur_rp,\n\t\t\t\t\t    buf_desc_sz);\n\n\t\t \n\t\tif (++cur_rp >= ring->r.len)\n\t\t\tcur_rp = 0;\n\t}\n\n\tring->r.rp = cur_rp;\n\t \n\tring->r.wp = cur_rp;\n\trtw_write16(rtwdev, RTK_PCI_RXBD_IDX_MPDUQ, ring->r.rp);\n\n\treturn rx_done;\n}\n\nstatic void rtw_pci_irq_recognized(struct rtw_dev *rtwdev,\n\t\t\t\t   struct rtw_pci *rtwpci, u32 *irq_status)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rtwpci->hwirq_lock, flags);\n\n\tirq_status[0] = rtw_read32(rtwdev, RTK_PCI_HISR0);\n\tirq_status[1] = rtw_read32(rtwdev, RTK_PCI_HISR1);\n\tif (rtw_chip_wcpu_11ac(rtwdev))\n\t\tirq_status[3] = rtw_read32(rtwdev, RTK_PCI_HISR3);\n\telse\n\t\tirq_status[3] = 0;\n\tirq_status[0] &= rtwpci->irq_mask[0];\n\tirq_status[1] &= rtwpci->irq_mask[1];\n\tirq_status[3] &= rtwpci->irq_mask[3];\n\trtw_write32(rtwdev, RTK_PCI_HISR0, irq_status[0]);\n\trtw_write32(rtwdev, RTK_PCI_HISR1, irq_status[1]);\n\tif (rtw_chip_wcpu_11ac(rtwdev))\n\t\trtw_write32(rtwdev, RTK_PCI_HISR3, irq_status[3]);\n\n\tspin_unlock_irqrestore(&rtwpci->hwirq_lock, flags);\n}\n\nstatic irqreturn_t rtw_pci_interrupt_handler(int irq, void *dev)\n{\n\tstruct rtw_dev *rtwdev = dev;\n\tstruct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;\n\n\t \n\trtw_pci_disable_interrupt(rtwdev, rtwpci);\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic irqreturn_t rtw_pci_interrupt_threadfn(int irq, void *dev)\n{\n\tstruct rtw_dev *rtwdev = dev;\n\tstruct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;\n\tu32 irq_status[4];\n\tbool rx = false;\n\n\tspin_lock_bh(&rtwpci->irq_lock);\n\trtw_pci_irq_recognized(rtwdev, rtwpci, irq_status);\n\n\tif (irq_status[0] & IMR_MGNTDOK)\n\t\trtw_pci_tx_isr(rtwdev, rtwpci, RTW_TX_QUEUE_MGMT);\n\tif (irq_status[0] & IMR_HIGHDOK)\n\t\trtw_pci_tx_isr(rtwdev, rtwpci, RTW_TX_QUEUE_HI0);\n\tif (irq_status[0] & IMR_BEDOK)\n\t\trtw_pci_tx_isr(rtwdev, rtwpci, RTW_TX_QUEUE_BE);\n\tif (irq_status[0] & IMR_BKDOK)\n\t\trtw_pci_tx_isr(rtwdev, rtwpci, RTW_TX_QUEUE_BK);\n\tif (irq_status[0] & IMR_VODOK)\n\t\trtw_pci_tx_isr(rtwdev, rtwpci, RTW_TX_QUEUE_VO);\n\tif (irq_status[0] & IMR_VIDOK)\n\t\trtw_pci_tx_isr(rtwdev, rtwpci, RTW_TX_QUEUE_VI);\n\tif (irq_status[3] & IMR_H2CDOK)\n\t\trtw_pci_tx_isr(rtwdev, rtwpci, RTW_TX_QUEUE_H2C);\n\tif (irq_status[0] & IMR_ROK) {\n\t\trtw_pci_rx_isr(rtwdev);\n\t\trx = true;\n\t}\n\tif (unlikely(irq_status[0] & IMR_C2HCMD))\n\t\trtw_fw_c2h_cmd_isr(rtwdev);\n\n\t \n\tif (rtwpci->running)\n\t\trtw_pci_enable_interrupt(rtwdev, rtwpci, rx);\n\tspin_unlock_bh(&rtwpci->irq_lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int rtw_pci_io_mapping(struct rtw_dev *rtwdev,\n\t\t\t      struct pci_dev *pdev)\n{\n\tstruct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;\n\tunsigned long len;\n\tu8 bar_id = 2;\n\tint ret;\n\n\tret = pci_request_regions(pdev, KBUILD_MODNAME);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to request pci regions\\n\");\n\t\treturn ret;\n\t}\n\n\tlen = pci_resource_len(pdev, bar_id);\n\trtwpci->mmap = pci_iomap(pdev, bar_id, len);\n\tif (!rtwpci->mmap) {\n\t\tpci_release_regions(pdev);\n\t\trtw_err(rtwdev, \"failed to map pci memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void rtw_pci_io_unmapping(struct rtw_dev *rtwdev,\n\t\t\t\t struct pci_dev *pdev)\n{\n\tstruct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;\n\n\tif (rtwpci->mmap) {\n\t\tpci_iounmap(pdev, rtwpci->mmap);\n\t\tpci_release_regions(pdev);\n\t}\n}\n\nstatic void rtw_dbi_write8(struct rtw_dev *rtwdev, u16 addr, u8 data)\n{\n\tu16 write_addr;\n\tu16 remainder = addr & ~(BITS_DBI_WREN | BITS_DBI_ADDR_MASK);\n\tu8 flag;\n\tu8 cnt;\n\n\twrite_addr = addr & BITS_DBI_ADDR_MASK;\n\twrite_addr |= u16_encode_bits(BIT(remainder), BITS_DBI_WREN);\n\trtw_write8(rtwdev, REG_DBI_WDATA_V1 + remainder, data);\n\trtw_write16(rtwdev, REG_DBI_FLAG_V1, write_addr);\n\trtw_write8(rtwdev, REG_DBI_FLAG_V1 + 2, BIT_DBI_WFLAG >> 16);\n\n\tfor (cnt = 0; cnt < RTW_PCI_WR_RETRY_CNT; cnt++) {\n\t\tflag = rtw_read8(rtwdev, REG_DBI_FLAG_V1 + 2);\n\t\tif (flag == 0)\n\t\t\treturn;\n\n\t\tudelay(10);\n\t}\n\n\tWARN(flag, \"failed to write to DBI register, addr=0x%04x\\n\", addr);\n}\n\nstatic int rtw_dbi_read8(struct rtw_dev *rtwdev, u16 addr, u8 *value)\n{\n\tu16 read_addr = addr & BITS_DBI_ADDR_MASK;\n\tu8 flag;\n\tu8 cnt;\n\n\trtw_write16(rtwdev, REG_DBI_FLAG_V1, read_addr);\n\trtw_write8(rtwdev, REG_DBI_FLAG_V1 + 2, BIT_DBI_RFLAG >> 16);\n\n\tfor (cnt = 0; cnt < RTW_PCI_WR_RETRY_CNT; cnt++) {\n\t\tflag = rtw_read8(rtwdev, REG_DBI_FLAG_V1 + 2);\n\t\tif (flag == 0) {\n\t\t\tread_addr = REG_DBI_RDATA_V1 + (addr & 3);\n\t\t\t*value = rtw_read8(rtwdev, read_addr);\n\t\t\treturn 0;\n\t\t}\n\n\t\tudelay(10);\n\t}\n\n\tWARN(1, \"failed to read DBI register, addr=0x%04x\\n\", addr);\n\treturn -EIO;\n}\n\nstatic void rtw_mdio_write(struct rtw_dev *rtwdev, u8 addr, u16 data, bool g1)\n{\n\tu8 page;\n\tu8 wflag;\n\tu8 cnt;\n\n\trtw_write16(rtwdev, REG_MDIO_V1, data);\n\n\tpage = addr < RTW_PCI_MDIO_PG_SZ ? 0 : 1;\n\tpage += g1 ? RTW_PCI_MDIO_PG_OFFS_G1 : RTW_PCI_MDIO_PG_OFFS_G2;\n\trtw_write8(rtwdev, REG_PCIE_MIX_CFG, addr & BITS_MDIO_ADDR_MASK);\n\trtw_write8(rtwdev, REG_PCIE_MIX_CFG + 3, page);\n\trtw_write32_mask(rtwdev, REG_PCIE_MIX_CFG, BIT_MDIO_WFLAG_V1, 1);\n\n\tfor (cnt = 0; cnt < RTW_PCI_WR_RETRY_CNT; cnt++) {\n\t\twflag = rtw_read32_mask(rtwdev, REG_PCIE_MIX_CFG,\n\t\t\t\t\tBIT_MDIO_WFLAG_V1);\n\t\tif (wflag == 0)\n\t\t\treturn;\n\n\t\tudelay(10);\n\t}\n\n\tWARN(wflag, \"failed to write to MDIO register, addr=0x%02x\\n\", addr);\n}\n\nstatic void rtw_pci_clkreq_set(struct rtw_dev *rtwdev, bool enable)\n{\n\tu8 value;\n\tint ret;\n\n\tif (rtw_pci_disable_aspm)\n\t\treturn;\n\n\tret = rtw_dbi_read8(rtwdev, RTK_PCIE_LINK_CFG, &value);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to read CLKREQ_L1, ret=%d\", ret);\n\t\treturn;\n\t}\n\n\tif (enable)\n\t\tvalue |= BIT_CLKREQ_SW_EN;\n\telse\n\t\tvalue &= ~BIT_CLKREQ_SW_EN;\n\n\trtw_dbi_write8(rtwdev, RTK_PCIE_LINK_CFG, value);\n}\n\nstatic void rtw_pci_clkreq_pad_low(struct rtw_dev *rtwdev, bool enable)\n{\n\tu8 value;\n\tint ret;\n\n\tret = rtw_dbi_read8(rtwdev, RTK_PCIE_LINK_CFG, &value);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to read CLKREQ_L1, ret=%d\", ret);\n\t\treturn;\n\t}\n\n\tif (enable)\n\t\tvalue &= ~BIT_CLKREQ_N_PAD;\n\telse\n\t\tvalue |= BIT_CLKREQ_N_PAD;\n\n\trtw_dbi_write8(rtwdev, RTK_PCIE_LINK_CFG, value);\n}\n\nstatic void rtw_pci_aspm_set(struct rtw_dev *rtwdev, bool enable)\n{\n\tu8 value;\n\tint ret;\n\n\tif (rtw_pci_disable_aspm)\n\t\treturn;\n\n\tret = rtw_dbi_read8(rtwdev, RTK_PCIE_LINK_CFG, &value);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to read ASPM, ret=%d\", ret);\n\t\treturn;\n\t}\n\n\tif (enable)\n\t\tvalue |= BIT_L1_SW_EN;\n\telse\n\t\tvalue &= ~BIT_L1_SW_EN;\n\n\trtw_dbi_write8(rtwdev, RTK_PCIE_LINK_CFG, value);\n}\n\nstatic void rtw_pci_link_ps(struct rtw_dev *rtwdev, bool enter)\n{\n\tstruct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;\n\n\t \n\tif (!(rtwpci->link_ctrl & PCI_EXP_LNKCTL_ASPM_L1))\n\t\treturn;\n\n\tif ((enter && atomic_dec_if_positive(&rtwpci->link_usage) == 0) ||\n\t    (!enter && atomic_inc_return(&rtwpci->link_usage) == 1))\n\t\trtw_pci_aspm_set(rtwdev, enter);\n}\n\nstatic void rtw_pci_link_cfg(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;\n\tstruct pci_dev *pdev = rtwpci->pdev;\n\tu16 link_ctrl;\n\tint ret;\n\n\t \n\tif (chip->id == RTW_CHIP_TYPE_8822C)\n\t\trtw_dbi_write8(rtwdev, RTK_PCIE_CLKDLY_CTRL, 0);\n\n\t \n\tret = pcie_capability_read_word(pdev, PCI_EXP_LNKCTL, &link_ctrl);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to read PCI cap, ret=%d\\n\", ret);\n\t\treturn;\n\t}\n\n\tif (link_ctrl & PCI_EXP_LNKCTL_CLKREQ_EN)\n\t\trtw_pci_clkreq_set(rtwdev, true);\n\n\trtwpci->link_ctrl = link_ctrl;\n}\n\nstatic void rtw_pci_interface_cfg(struct rtw_dev *rtwdev)\n{\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\n\tswitch (chip->id) {\n\tcase RTW_CHIP_TYPE_8822C:\n\t\tif (rtwdev->hal.cut_version >= RTW_CHIP_VER_CUT_D)\n\t\t\trtw_write32_mask(rtwdev, REG_HCI_MIX_CFG,\n\t\t\t\t\t BIT_PCIE_EMAC_PDN_AUX_TO_FAST_CLK, 1);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void rtw_pci_phy_cfg(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct pci_dev *pdev = rtwpci->pdev;\n\tconst struct rtw_intf_phy_para *para;\n\tu16 cut;\n\tu16 value;\n\tu16 offset;\n\tint i;\n\tint ret;\n\n\tcut = BIT(0) << rtwdev->hal.cut_version;\n\n\tfor (i = 0; i < chip->intf_table->n_gen1_para; i++) {\n\t\tpara = &chip->intf_table->gen1_para[i];\n\t\tif (!(para->cut_mask & cut))\n\t\t\tcontinue;\n\t\tif (para->offset == 0xffff)\n\t\t\tbreak;\n\t\toffset = para->offset;\n\t\tvalue = para->value;\n\t\tif (para->ip_sel == RTW_IP_SEL_PHY)\n\t\t\trtw_mdio_write(rtwdev, offset, value, true);\n\t\telse\n\t\t\trtw_dbi_write8(rtwdev, offset, value);\n\t}\n\n\tfor (i = 0; i < chip->intf_table->n_gen2_para; i++) {\n\t\tpara = &chip->intf_table->gen2_para[i];\n\t\tif (!(para->cut_mask & cut))\n\t\t\tcontinue;\n\t\tif (para->offset == 0xffff)\n\t\t\tbreak;\n\t\toffset = para->offset;\n\t\tvalue = para->value;\n\t\tif (para->ip_sel == RTW_IP_SEL_PHY)\n\t\t\trtw_mdio_write(rtwdev, offset, value, false);\n\t\telse\n\t\t\trtw_dbi_write8(rtwdev, offset, value);\n\t}\n\n\trtw_pci_link_cfg(rtwdev);\n\n\t \n\tif (chip->id == RTW_CHIP_TYPE_8821C) {\n\t\tret = pcie_capability_set_word(pdev, PCI_EXP_DEVCTL2,\n\t\t\t\t\t       PCI_EXP_DEVCTL2_COMP_TMOUT_DIS);\n\t\tif (ret)\n\t\t\trtw_err(rtwdev, \"failed to set PCI cap, ret = %d\\n\",\n\t\t\t\tret);\n\t}\n}\n\nstatic int __maybe_unused rtw_pci_suspend(struct device *dev)\n{\n\tstruct ieee80211_hw *hw = dev_get_drvdata(dev);\n\tstruct rtw_dev *rtwdev = hw->priv;\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\n\tif (chip->id == RTW_CHIP_TYPE_8822C && efuse->rfe_option == 6)\n\t\trtw_pci_clkreq_pad_low(rtwdev, true);\n\treturn 0;\n}\n\nstatic int __maybe_unused rtw_pci_resume(struct device *dev)\n{\n\tstruct ieee80211_hw *hw = dev_get_drvdata(dev);\n\tstruct rtw_dev *rtwdev = hw->priv;\n\tconst struct rtw_chip_info *chip = rtwdev->chip;\n\tstruct rtw_efuse *efuse = &rtwdev->efuse;\n\n\tif (chip->id == RTW_CHIP_TYPE_8822C && efuse->rfe_option == 6)\n\t\trtw_pci_clkreq_pad_low(rtwdev, false);\n\treturn 0;\n}\n\nSIMPLE_DEV_PM_OPS(rtw_pm_ops, rtw_pci_suspend, rtw_pci_resume);\nEXPORT_SYMBOL(rtw_pm_ops);\n\nstatic int rtw_pci_claim(struct rtw_dev *rtwdev, struct pci_dev *pdev)\n{\n\tint ret;\n\n\tret = pci_enable_device(pdev);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to enable pci device\\n\");\n\t\treturn ret;\n\t}\n\n\tpci_set_master(pdev);\n\tpci_set_drvdata(pdev, rtwdev->hw);\n\tSET_IEEE80211_DEV(rtwdev->hw, &pdev->dev);\n\n\treturn 0;\n}\n\nstatic void rtw_pci_declaim(struct rtw_dev *rtwdev, struct pci_dev *pdev)\n{\n\tpci_disable_device(pdev);\n}\n\nstatic int rtw_pci_setup_resource(struct rtw_dev *rtwdev, struct pci_dev *pdev)\n{\n\tstruct rtw_pci *rtwpci;\n\tint ret;\n\n\trtwpci = (struct rtw_pci *)rtwdev->priv;\n\trtwpci->pdev = pdev;\n\n\t \n\tret = rtw_pci_io_mapping(rtwdev, pdev);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to request pci io region\\n\");\n\t\tgoto err_out;\n\t}\n\n\tret = rtw_pci_init(rtwdev);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to allocate pci resources\\n\");\n\t\tgoto err_io_unmap;\n\t}\n\n\treturn 0;\n\nerr_io_unmap:\n\trtw_pci_io_unmapping(rtwdev, pdev);\n\nerr_out:\n\treturn ret;\n}\n\nstatic void rtw_pci_destroy(struct rtw_dev *rtwdev, struct pci_dev *pdev)\n{\n\trtw_pci_deinit(rtwdev);\n\trtw_pci_io_unmapping(rtwdev, pdev);\n}\n\nstatic struct rtw_hci_ops rtw_pci_ops = {\n\t.tx_write = rtw_pci_tx_write,\n\t.tx_kick_off = rtw_pci_tx_kick_off,\n\t.flush_queues = rtw_pci_flush_queues,\n\t.setup = rtw_pci_setup,\n\t.start = rtw_pci_start,\n\t.stop = rtw_pci_stop,\n\t.deep_ps = rtw_pci_deep_ps,\n\t.link_ps = rtw_pci_link_ps,\n\t.interface_cfg = rtw_pci_interface_cfg,\n\n\t.read8 = rtw_pci_read8,\n\t.read16 = rtw_pci_read16,\n\t.read32 = rtw_pci_read32,\n\t.write8 = rtw_pci_write8,\n\t.write16 = rtw_pci_write16,\n\t.write32 = rtw_pci_write32,\n\t.write_data_rsvd_page = rtw_pci_write_data_rsvd_page,\n\t.write_data_h2c = rtw_pci_write_data_h2c,\n};\n\nstatic int rtw_pci_request_irq(struct rtw_dev *rtwdev, struct pci_dev *pdev)\n{\n\tunsigned int flags = PCI_IRQ_LEGACY;\n\tint ret;\n\n\tif (!rtw_disable_msi)\n\t\tflags |= PCI_IRQ_MSI;\n\n\tret = pci_alloc_irq_vectors(pdev, 1, 1, flags);\n\tif (ret < 0) {\n\t\trtw_err(rtwdev, \"failed to alloc PCI irq vectors\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_request_threaded_irq(rtwdev->dev, pdev->irq,\n\t\t\t\t\trtw_pci_interrupt_handler,\n\t\t\t\t\trtw_pci_interrupt_threadfn,\n\t\t\t\t\tIRQF_SHARED, KBUILD_MODNAME, rtwdev);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to request irq %d\\n\", ret);\n\t\tpci_free_irq_vectors(pdev);\n\t}\n\n\treturn ret;\n}\n\nstatic void rtw_pci_free_irq(struct rtw_dev *rtwdev, struct pci_dev *pdev)\n{\n\tdevm_free_irq(rtwdev->dev, pdev->irq, rtwdev);\n\tpci_free_irq_vectors(pdev);\n}\n\nstatic int rtw_pci_napi_poll(struct napi_struct *napi, int budget)\n{\n\tstruct rtw_pci *rtwpci = container_of(napi, struct rtw_pci, napi);\n\tstruct rtw_dev *rtwdev = container_of((void *)rtwpci, struct rtw_dev,\n\t\t\t\t\t      priv);\n\tint work_done = 0;\n\n\tif (rtwpci->rx_no_aspm)\n\t\trtw_pci_link_ps(rtwdev, false);\n\n\twhile (work_done < budget) {\n\t\tu32 work_done_once;\n\n\t\twork_done_once = rtw_pci_rx_napi(rtwdev, rtwpci, RTW_RX_QUEUE_MPDU,\n\t\t\t\t\t\t budget - work_done);\n\t\tif (work_done_once == 0)\n\t\t\tbreak;\n\t\twork_done += work_done_once;\n\t}\n\tif (work_done < budget) {\n\t\tnapi_complete_done(napi, work_done);\n\t\tspin_lock_bh(&rtwpci->irq_lock);\n\t\tif (rtwpci->running)\n\t\t\trtw_pci_enable_interrupt(rtwdev, rtwpci, false);\n\t\tspin_unlock_bh(&rtwpci->irq_lock);\n\t\t \n\t\tif (rtw_pci_get_hw_rx_ring_nr(rtwdev, rtwpci))\n\t\t\tnapi_schedule(napi);\n\t}\n\tif (rtwpci->rx_no_aspm)\n\t\trtw_pci_link_ps(rtwdev, true);\n\n\treturn work_done;\n}\n\nstatic void rtw_pci_napi_init(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;\n\n\tinit_dummy_netdev(&rtwpci->netdev);\n\tnetif_napi_add(&rtwpci->netdev, &rtwpci->napi, rtw_pci_napi_poll);\n}\n\nstatic void rtw_pci_napi_deinit(struct rtw_dev *rtwdev)\n{\n\tstruct rtw_pci *rtwpci = (struct rtw_pci *)rtwdev->priv;\n\n\trtw_pci_napi_stop(rtwdev);\n\tnetif_napi_del(&rtwpci->napi);\n}\n\nint rtw_pci_probe(struct pci_dev *pdev,\n\t\t  const struct pci_device_id *id)\n{\n\tstruct pci_dev *bridge = pci_upstream_bridge(pdev);\n\tstruct ieee80211_hw *hw;\n\tstruct rtw_dev *rtwdev;\n\tstruct rtw_pci *rtwpci;\n\tint drv_data_size;\n\tint ret;\n\n\tdrv_data_size = sizeof(struct rtw_dev) + sizeof(struct rtw_pci);\n\thw = ieee80211_alloc_hw(drv_data_size, &rtw_ops);\n\tif (!hw) {\n\t\tdev_err(&pdev->dev, \"failed to allocate hw\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\trtwdev = hw->priv;\n\trtwdev->hw = hw;\n\trtwdev->dev = &pdev->dev;\n\trtwdev->chip = (struct rtw_chip_info *)id->driver_data;\n\trtwdev->hci.ops = &rtw_pci_ops;\n\trtwdev->hci.type = RTW_HCI_TYPE_PCIE;\n\n\trtwpci = (struct rtw_pci *)rtwdev->priv;\n\tatomic_set(&rtwpci->link_usage, 1);\n\n\tret = rtw_core_init(rtwdev);\n\tif (ret)\n\t\tgoto err_release_hw;\n\n\trtw_dbg(rtwdev, RTW_DBG_PCI,\n\t\t\"rtw88 pci probe: vendor=0x%4.04X device=0x%4.04X rev=%d\\n\",\n\t\tpdev->vendor, pdev->device, pdev->revision);\n\n\tret = rtw_pci_claim(rtwdev, pdev);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to claim pci device\\n\");\n\t\tgoto err_deinit_core;\n\t}\n\n\tret = rtw_pci_setup_resource(rtwdev, pdev);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to setup pci resources\\n\");\n\t\tgoto err_pci_declaim;\n\t}\n\n\trtw_pci_napi_init(rtwdev);\n\n\tret = rtw_chip_info_setup(rtwdev);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to setup chip information\\n\");\n\t\tgoto err_destroy_pci;\n\t}\n\n\t \n\tif (rtwdev->chip->id == RTW_CHIP_TYPE_8821C && bridge->vendor == PCI_VENDOR_ID_INTEL)\n\t\trtwpci->rx_no_aspm = true;\n\n\trtw_pci_phy_cfg(rtwdev);\n\n\tret = rtw_register_hw(rtwdev, hw);\n\tif (ret) {\n\t\trtw_err(rtwdev, \"failed to register hw\\n\");\n\t\tgoto err_destroy_pci;\n\t}\n\n\tret = rtw_pci_request_irq(rtwdev, pdev);\n\tif (ret) {\n\t\tieee80211_unregister_hw(hw);\n\t\tgoto err_destroy_pci;\n\t}\n\n\treturn 0;\n\nerr_destroy_pci:\n\trtw_pci_napi_deinit(rtwdev);\n\trtw_pci_destroy(rtwdev, pdev);\n\nerr_pci_declaim:\n\trtw_pci_declaim(rtwdev, pdev);\n\nerr_deinit_core:\n\trtw_core_deinit(rtwdev);\n\nerr_release_hw:\n\tieee80211_free_hw(hw);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(rtw_pci_probe);\n\nvoid rtw_pci_remove(struct pci_dev *pdev)\n{\n\tstruct ieee80211_hw *hw = pci_get_drvdata(pdev);\n\tstruct rtw_dev *rtwdev;\n\tstruct rtw_pci *rtwpci;\n\n\tif (!hw)\n\t\treturn;\n\n\trtwdev = hw->priv;\n\trtwpci = (struct rtw_pci *)rtwdev->priv;\n\n\trtw_unregister_hw(rtwdev, hw);\n\trtw_pci_disable_interrupt(rtwdev, rtwpci);\n\trtw_pci_napi_deinit(rtwdev);\n\trtw_pci_destroy(rtwdev, pdev);\n\trtw_pci_declaim(rtwdev, pdev);\n\trtw_pci_free_irq(rtwdev, pdev);\n\trtw_core_deinit(rtwdev);\n\tieee80211_free_hw(hw);\n}\nEXPORT_SYMBOL(rtw_pci_remove);\n\nvoid rtw_pci_shutdown(struct pci_dev *pdev)\n{\n\tstruct ieee80211_hw *hw = pci_get_drvdata(pdev);\n\tstruct rtw_dev *rtwdev;\n\tconst struct rtw_chip_info *chip;\n\n\tif (!hw)\n\t\treturn;\n\n\trtwdev = hw->priv;\n\tchip = rtwdev->chip;\n\n\tif (chip->ops->shutdown)\n\t\tchip->ops->shutdown(rtwdev);\n\n\tpci_set_power_state(pdev, PCI_D3hot);\n}\nEXPORT_SYMBOL(rtw_pci_shutdown);\n\nMODULE_AUTHOR(\"Realtek Corporation\");\nMODULE_DESCRIPTION(\"Realtek PCI 802.11ac wireless driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}