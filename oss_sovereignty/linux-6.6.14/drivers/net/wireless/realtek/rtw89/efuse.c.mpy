{
  "module_name": "efuse.c",
  "hash_id": "c593df146450191d5c01d3bfd3dd6b11c58fd02a39f8f34a10b237efcf215932",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtw89/efuse.c",
  "human_readable_source": "\n \n\n#include \"debug.h\"\n#include \"efuse.h\"\n#include \"mac.h\"\n#include \"reg.h\"\n\n#define EF_FV_OFSET 0x5ea\n#define EF_CV_MASK GENMASK(7, 4)\n#define EF_CV_INV 15\n\nenum rtw89_efuse_bank {\n\tRTW89_EFUSE_BANK_WIFI,\n\tRTW89_EFUSE_BANK_BT,\n};\n\nstatic int rtw89_switch_efuse_bank(struct rtw89_dev *rtwdev,\n\t\t\t\t   enum rtw89_efuse_bank bank)\n{\n\tu8 val;\n\n\tif (rtwdev->chip->chip_id != RTL8852A)\n\t\treturn 0;\n\n\tval = rtw89_read32_mask(rtwdev, R_AX_EFUSE_CTRL_1,\n\t\t\t\tB_AX_EF_CELL_SEL_MASK);\n\tif (bank == val)\n\t\treturn 0;\n\n\trtw89_write32_mask(rtwdev, R_AX_EFUSE_CTRL_1, B_AX_EF_CELL_SEL_MASK,\n\t\t\t   bank);\n\n\tval = rtw89_read32_mask(rtwdev, R_AX_EFUSE_CTRL_1,\n\t\t\t\tB_AX_EF_CELL_SEL_MASK);\n\tif (bank == val)\n\t\treturn 0;\n\n\treturn -EBUSY;\n}\n\nstatic void rtw89_enable_otp_burst_mode(struct rtw89_dev *rtwdev, bool en)\n{\n\tif (en)\n\t\trtw89_write32_set(rtwdev, R_AX_EFUSE_CTRL_1_V1, B_AX_EF_BURST);\n\telse\n\t\trtw89_write32_clr(rtwdev, R_AX_EFUSE_CTRL_1_V1, B_AX_EF_BURST);\n}\n\nstatic void rtw89_enable_efuse_pwr_cut_ddv(struct rtw89_dev *rtwdev)\n{\n\tenum rtw89_core_chip_id chip_id = rtwdev->chip->chip_id;\n\tstruct rtw89_hal *hal = &rtwdev->hal;\n\n\tif (chip_id == RTL8852A)\n\t\treturn;\n\n\trtw89_write8_set(rtwdev, R_AX_PMC_DBG_CTRL2, B_AX_SYSON_DIS_PMCR_AX_WRMSK);\n\trtw89_write16_set(rtwdev, R_AX_SYS_ISO_CTRL, B_AX_PWC_EV2EF_B14);\n\n\tfsleep(1000);\n\n\trtw89_write16_set(rtwdev, R_AX_SYS_ISO_CTRL, B_AX_PWC_EV2EF_B15);\n\trtw89_write16_clr(rtwdev, R_AX_SYS_ISO_CTRL, B_AX_ISO_EB2CORE);\n\tif (chip_id == RTL8852B && hal->cv == CHIP_CAV)\n\t\trtw89_enable_otp_burst_mode(rtwdev, true);\n}\n\nstatic void rtw89_disable_efuse_pwr_cut_ddv(struct rtw89_dev *rtwdev)\n{\n\tenum rtw89_core_chip_id chip_id = rtwdev->chip->chip_id;\n\tstruct rtw89_hal *hal = &rtwdev->hal;\n\n\tif (chip_id == RTL8852A)\n\t\treturn;\n\n\tif (chip_id == RTL8852B && hal->cv == CHIP_CAV)\n\t\trtw89_enable_otp_burst_mode(rtwdev, false);\n\n\trtw89_write16_set(rtwdev, R_AX_SYS_ISO_CTRL, B_AX_ISO_EB2CORE);\n\trtw89_write16_clr(rtwdev, R_AX_SYS_ISO_CTRL, B_AX_PWC_EV2EF_B15);\n\n\tfsleep(1000);\n\n\trtw89_write16_clr(rtwdev, R_AX_SYS_ISO_CTRL, B_AX_PWC_EV2EF_B14);\n\trtw89_write8_clr(rtwdev, R_AX_PMC_DBG_CTRL2, B_AX_SYSON_DIS_PMCR_AX_WRMSK);\n}\n\nstatic int rtw89_dump_physical_efuse_map_ddv(struct rtw89_dev *rtwdev, u8 *map,\n\t\t\t\t\t     u32 dump_addr, u32 dump_size)\n{\n\tu32 efuse_ctl;\n\tu32 addr;\n\tint ret;\n\n\trtw89_enable_efuse_pwr_cut_ddv(rtwdev);\n\n\tfor (addr = dump_addr; addr < dump_addr + dump_size; addr++) {\n\t\tefuse_ctl = u32_encode_bits(addr, B_AX_EF_ADDR_MASK);\n\t\trtw89_write32(rtwdev, R_AX_EFUSE_CTRL, efuse_ctl & ~B_AX_EF_RDY);\n\n\t\tret = read_poll_timeout_atomic(rtw89_read32, efuse_ctl,\n\t\t\t\t\t       efuse_ctl & B_AX_EF_RDY, 1, 1000000,\n\t\t\t\t\t       true, rtwdev, R_AX_EFUSE_CTRL);\n\t\tif (ret)\n\t\t\treturn -EBUSY;\n\n\t\t*map++ = (u8)(efuse_ctl & 0xff);\n\t}\n\n\trtw89_disable_efuse_pwr_cut_ddv(rtwdev);\n\n\treturn 0;\n}\n\nstatic int rtw89_dump_physical_efuse_map_dav(struct rtw89_dev *rtwdev, u8 *map,\n\t\t\t\t\t     u32 dump_addr, u32 dump_size)\n{\n\tu32 addr;\n\tu8 val8;\n\tint err;\n\tint ret;\n\n\tfor (addr = dump_addr; addr < dump_addr + dump_size; addr++) {\n\t\tret = rtw89_mac_write_xtal_si(rtwdev, XTAL_SI_CTRL, 0x40, FULL_BIT_MASK);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = rtw89_mac_write_xtal_si(rtwdev, XTAL_SI_LOW_ADDR,\n\t\t\t\t\t      addr & 0xff, XTAL_SI_LOW_ADDR_MASK);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = rtw89_mac_write_xtal_si(rtwdev, XTAL_SI_CTRL, addr >> 8,\n\t\t\t\t\t      XTAL_SI_HIGH_ADDR_MASK);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = rtw89_mac_write_xtal_si(rtwdev, XTAL_SI_CTRL, 0,\n\t\t\t\t\t      XTAL_SI_MODE_SEL_MASK);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = read_poll_timeout_atomic(rtw89_mac_read_xtal_si, err,\n\t\t\t\t\t       !err && (val8 & XTAL_SI_RDY),\n\t\t\t\t\t       1, 10000, false,\n\t\t\t\t\t       rtwdev, XTAL_SI_CTRL, &val8);\n\t\tif (ret) {\n\t\t\trtw89_warn(rtwdev, \"failed to read dav efuse\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = rtw89_mac_read_xtal_si(rtwdev, XTAL_SI_READ_VAL, &val8);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\t*map++ = val8;\n\t}\n\n\treturn 0;\n}\n\nstatic int rtw89_dump_physical_efuse_map(struct rtw89_dev *rtwdev, u8 *map,\n\t\t\t\t\t u32 dump_addr, u32 dump_size, bool dav)\n{\n\tint ret;\n\n\tif (!map || dump_size == 0)\n\t\treturn 0;\n\n\trtw89_switch_efuse_bank(rtwdev, RTW89_EFUSE_BANK_WIFI);\n\n\tif (dav) {\n\t\tret = rtw89_dump_physical_efuse_map_dav(rtwdev, map, dump_addr, dump_size);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tret = rtw89_dump_physical_efuse_map_ddv(rtwdev, map, dump_addr, dump_size);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n#define invalid_efuse_header(hdr1, hdr2) \\\n\t((hdr1) == 0xff || (hdr2) == 0xff)\n#define invalid_efuse_content(word_en, i) \\\n\t(((word_en) & BIT(i)) != 0x0)\n#define get_efuse_blk_idx(hdr1, hdr2) \\\n\t((((hdr2) & 0xf0) >> 4) | (((hdr1) & 0x0f) << 4))\n#define block_idx_to_logical_idx(blk_idx, i) \\\n\t(((blk_idx) << 3) + ((i) << 1))\nstatic int rtw89_dump_logical_efuse_map(struct rtw89_dev *rtwdev, u8 *phy_map,\n\t\t\t\t\tu8 *log_map)\n{\n\tu32 physical_size = rtwdev->chip->physical_efuse_size;\n\tu32 logical_size = rtwdev->chip->logical_efuse_size;\n\tu8 sec_ctrl_size = rtwdev->chip->sec_ctrl_efuse_size;\n\tu32 phy_idx = sec_ctrl_size;\n\tu32 log_idx;\n\tu8 hdr1, hdr2;\n\tu8 blk_idx;\n\tu8 word_en;\n\tint i;\n\n\tif (!phy_map)\n\t\treturn 0;\n\n\twhile (phy_idx < physical_size - sec_ctrl_size) {\n\t\thdr1 = phy_map[phy_idx];\n\t\thdr2 = phy_map[phy_idx + 1];\n\t\tif (invalid_efuse_header(hdr1, hdr2))\n\t\t\tbreak;\n\n\t\tblk_idx = get_efuse_blk_idx(hdr1, hdr2);\n\t\tword_en = hdr2 & 0xf;\n\t\tphy_idx += 2;\n\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tif (invalid_efuse_content(word_en, i))\n\t\t\t\tcontinue;\n\n\t\t\tlog_idx = block_idx_to_logical_idx(blk_idx, i);\n\t\t\tif (phy_idx + 1 > physical_size - sec_ctrl_size - 1 ||\n\t\t\t    log_idx + 1 > logical_size)\n\t\t\t\treturn -EINVAL;\n\n\t\t\tlog_map[log_idx] = phy_map[phy_idx];\n\t\t\tlog_map[log_idx + 1] = phy_map[phy_idx + 1];\n\t\t\tphy_idx += 2;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint rtw89_parse_efuse_map(struct rtw89_dev *rtwdev)\n{\n\tu32 phy_size = rtwdev->chip->physical_efuse_size;\n\tu32 log_size = rtwdev->chip->logical_efuse_size;\n\tu32 dav_phy_size = rtwdev->chip->dav_phy_efuse_size;\n\tu32 dav_log_size = rtwdev->chip->dav_log_efuse_size;\n\tu32 full_log_size = log_size + dav_log_size;\n\tu8 *phy_map = NULL;\n\tu8 *log_map = NULL;\n\tu8 *dav_phy_map = NULL;\n\tu8 *dav_log_map = NULL;\n\tint ret;\n\n\tif (rtw89_read16(rtwdev, R_AX_SYS_WL_EFUSE_CTRL) & B_AX_AUTOLOAD_SUS)\n\t\trtwdev->efuse.valid = true;\n\telse\n\t\trtw89_warn(rtwdev, \"failed to check efuse autoload\\n\");\n\n\tphy_map = kmalloc(phy_size, GFP_KERNEL);\n\tlog_map = kmalloc(full_log_size, GFP_KERNEL);\n\tif (dav_phy_size && dav_log_size) {\n\t\tdav_phy_map = kmalloc(dav_phy_size, GFP_KERNEL);\n\t\tdav_log_map = log_map + log_size;\n\t}\n\n\tif (!phy_map || !log_map || (dav_phy_size && !dav_phy_map)) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\tret = rtw89_dump_physical_efuse_map(rtwdev, phy_map, 0, phy_size, false);\n\tif (ret) {\n\t\trtw89_warn(rtwdev, \"failed to dump efuse physical map\\n\");\n\t\tgoto out_free;\n\t}\n\tret = rtw89_dump_physical_efuse_map(rtwdev, dav_phy_map, 0, dav_phy_size, true);\n\tif (ret) {\n\t\trtw89_warn(rtwdev, \"failed to dump efuse dav physical map\\n\");\n\t\tgoto out_free;\n\t}\n\n\tmemset(log_map, 0xff, full_log_size);\n\tret = rtw89_dump_logical_efuse_map(rtwdev, phy_map, log_map);\n\tif (ret) {\n\t\trtw89_warn(rtwdev, \"failed to dump efuse logical map\\n\");\n\t\tgoto out_free;\n\t}\n\tret = rtw89_dump_logical_efuse_map(rtwdev, dav_phy_map, dav_log_map);\n\tif (ret) {\n\t\trtw89_warn(rtwdev, \"failed to dump efuse dav logical map\\n\");\n\t\tgoto out_free;\n\t}\n\n\trtw89_hex_dump(rtwdev, RTW89_DBG_FW, \"log_map: \", log_map, full_log_size);\n\n\tret = rtwdev->chip->ops->read_efuse(rtwdev, log_map);\n\tif (ret) {\n\t\trtw89_warn(rtwdev, \"failed to read efuse map\\n\");\n\t\tgoto out_free;\n\t}\n\nout_free:\n\tkfree(dav_phy_map);\n\tkfree(log_map);\n\tkfree(phy_map);\n\n\treturn ret;\n}\n\nint rtw89_parse_phycap_map(struct rtw89_dev *rtwdev)\n{\n\tu32 phycap_addr = rtwdev->chip->phycap_addr;\n\tu32 phycap_size = rtwdev->chip->phycap_size;\n\tu8 *phycap_map = NULL;\n\tint ret = 0;\n\n\tif (!phycap_size)\n\t\treturn 0;\n\n\tphycap_map = kmalloc(phycap_size, GFP_KERNEL);\n\tif (!phycap_map)\n\t\treturn -ENOMEM;\n\n\tret = rtw89_dump_physical_efuse_map(rtwdev, phycap_map,\n\t\t\t\t\t    phycap_addr, phycap_size, false);\n\tif (ret) {\n\t\trtw89_warn(rtwdev, \"failed to dump phycap map\\n\");\n\t\tgoto out_free;\n\t}\n\n\tret = rtwdev->chip->ops->read_phycap(rtwdev, phycap_map);\n\tif (ret) {\n\t\trtw89_warn(rtwdev, \"failed to read phycap map\\n\");\n\t\tgoto out_free;\n\t}\n\nout_free:\n\tkfree(phycap_map);\n\n\treturn ret;\n}\n\nint rtw89_read_efuse_ver(struct rtw89_dev *rtwdev, u8 *ecv)\n{\n\tint ret;\n\tu8 val;\n\n\tret = rtw89_dump_physical_efuse_map(rtwdev, &val, EF_FV_OFSET, 1, false);\n\tif (ret)\n\t\treturn ret;\n\n\t*ecv = u8_get_bits(val, EF_CV_MASK);\n\tif (*ecv == EF_CV_INV)\n\t\treturn -ENOENT;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rtw89_read_efuse_ver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}