{
  "module_name": "ser.c",
  "hash_id": "bf90548b0431aebde79bf00404933fa51fb12e46d35c1a55db96ed03ccc79efc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtw89/ser.c",
  "human_readable_source": "\n \n\n#include <linux/devcoredump.h>\n\n#include \"cam.h\"\n#include \"chan.h\"\n#include \"debug.h\"\n#include \"fw.h\"\n#include \"mac.h\"\n#include \"ps.h\"\n#include \"reg.h\"\n#include \"ser.h\"\n#include \"util.h\"\n\n#define SER_RECFG_TIMEOUT 1000\n\nenum ser_evt {\n\tSER_EV_NONE,\n\tSER_EV_STATE_IN,\n\tSER_EV_STATE_OUT,\n\tSER_EV_L1_RESET_PREPARE,  \n\tSER_EV_L1_RESET,  \n\tSER_EV_DO_RECOVERY,  \n\tSER_EV_MAC_RESET_DONE,  \n\tSER_EV_L2_RESET,\n\tSER_EV_L2_RECFG_DONE,\n\tSER_EV_L2_RECFG_TIMEOUT,\n\tSER_EV_M1_TIMEOUT,\n\tSER_EV_M3_TIMEOUT,\n\tSER_EV_FW_M5_TIMEOUT,\n\tSER_EV_L0_RESET,\n\tSER_EV_MAXX\n};\n\nenum ser_state {\n\tSER_IDLE_ST,\n\tSER_L1_RESET_PRE_ST,\n\tSER_RESET_TRX_ST,\n\tSER_DO_HCI_ST,\n\tSER_L2_RESET_ST,\n\tSER_ST_MAX_ST\n};\n\nstruct ser_msg {\n\tstruct list_head list;\n\tu8 event;\n};\n\nstruct state_ent {\n\tu8 state;\n\tchar *name;\n\tvoid (*st_func)(struct rtw89_ser *ser, u8 event);\n};\n\nstruct event_ent {\n\tu8 event;\n\tchar *name;\n};\n\nstatic char *ser_ev_name(struct rtw89_ser *ser, u8 event)\n{\n\tif (event < SER_EV_MAXX)\n\t\treturn ser->ev_tbl[event].name;\n\n\treturn \"err_ev_name\";\n}\n\nstatic char *ser_st_name(struct rtw89_ser *ser)\n{\n\tif (ser->state < SER_ST_MAX_ST)\n\t\treturn ser->st_tbl[ser->state].name;\n\n\treturn \"err_st_name\";\n}\n\n#define RTW89_DEF_SER_CD_TYPE(_name, _type, _size) \\\nstruct ser_cd_ ## _name { \\\n\tu32 type; \\\n\tu32 type_size; \\\n\tu64 padding; \\\n\tu8 data[_size]; \\\n} __packed; \\\nstatic void ser_cd_ ## _name ## _init(struct ser_cd_ ## _name *p) \\\n{ \\\n\tp->type = _type; \\\n\tp->type_size = sizeof(p->data); \\\n\tp->padding = 0x0123456789abcdef; \\\n}\n\nenum rtw89_ser_cd_type {\n\tRTW89_SER_CD_FW_RSVD_PLE\t= 0,\n\tRTW89_SER_CD_FW_BACKTRACE\t= 1,\n};\n\nRTW89_DEF_SER_CD_TYPE(fw_rsvd_ple,\n\t\t      RTW89_SER_CD_FW_RSVD_PLE,\n\t\t      RTW89_FW_RSVD_PLE_SIZE);\n\nRTW89_DEF_SER_CD_TYPE(fw_backtrace,\n\t\t      RTW89_SER_CD_FW_BACKTRACE,\n\t\t      RTW89_FW_BACKTRACE_MAX_SIZE);\n\nstruct rtw89_ser_cd_buffer {\n\tstruct ser_cd_fw_rsvd_ple fwple;\n\tstruct ser_cd_fw_backtrace fwbt;\n} __packed;\n\nstatic struct rtw89_ser_cd_buffer *rtw89_ser_cd_prep(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_ser_cd_buffer *buf;\n\n\tbuf = vzalloc(sizeof(*buf));\n\tif (!buf)\n\t\treturn NULL;\n\n\tser_cd_fw_rsvd_ple_init(&buf->fwple);\n\tser_cd_fw_backtrace_init(&buf->fwbt);\n\n\treturn buf;\n}\n\nstatic void rtw89_ser_cd_send(struct rtw89_dev *rtwdev,\n\t\t\t      struct rtw89_ser_cd_buffer *buf)\n{\n\trtw89_debug(rtwdev, RTW89_DBG_SER, \"SER sends core dump\\n\");\n\n\t \n\tdev_coredumpv(rtwdev->dev, buf, sizeof(*buf), GFP_KERNEL);\n}\n\nstatic void rtw89_ser_cd_free(struct rtw89_dev *rtwdev,\n\t\t\t      struct rtw89_ser_cd_buffer *buf, bool free_self)\n{\n\tif (!free_self)\n\t\treturn;\n\n\trtw89_debug(rtwdev, RTW89_DBG_SER, \"SER frees core dump by self\\n\");\n\n\t \n\tvfree(buf);\n}\n\nstatic void ser_state_run(struct rtw89_ser *ser, u8 evt)\n{\n\tstruct rtw89_dev *rtwdev = container_of(ser, struct rtw89_dev, ser);\n\n\trtw89_debug(rtwdev, RTW89_DBG_SER, \"ser: %s receive %s\\n\",\n\t\t    ser_st_name(ser), ser_ev_name(ser, evt));\n\n\tmutex_lock(&rtwdev->mutex);\n\trtw89_leave_lps(rtwdev);\n\tmutex_unlock(&rtwdev->mutex);\n\n\tser->st_tbl[ser->state].st_func(ser, evt);\n}\n\nstatic void ser_state_goto(struct rtw89_ser *ser, u8 new_state)\n{\n\tstruct rtw89_dev *rtwdev = container_of(ser, struct rtw89_dev, ser);\n\n\tif (ser->state == new_state || new_state >= SER_ST_MAX_ST)\n\t\treturn;\n\tser_state_run(ser, SER_EV_STATE_OUT);\n\n\trtw89_debug(rtwdev, RTW89_DBG_SER, \"ser: %s goto -> %s\\n\",\n\t\t    ser_st_name(ser), ser->st_tbl[new_state].name);\n\n\tser->state = new_state;\n\tser_state_run(ser, SER_EV_STATE_IN);\n}\n\nstatic struct ser_msg *__rtw89_ser_dequeue_msg(struct rtw89_ser *ser)\n{\n\tstruct ser_msg *msg;\n\n\tspin_lock_irq(&ser->msg_q_lock);\n\tmsg = list_first_entry_or_null(&ser->msg_q, struct ser_msg, list);\n\tif (msg)\n\t\tlist_del(&msg->list);\n\tspin_unlock_irq(&ser->msg_q_lock);\n\n\treturn msg;\n}\n\nstatic void rtw89_ser_hdl_work(struct work_struct *work)\n{\n\tstruct ser_msg *msg;\n\tstruct rtw89_ser *ser = container_of(work, struct rtw89_ser,\n\t\t\t\t\t     ser_hdl_work);\n\n\twhile ((msg = __rtw89_ser_dequeue_msg(ser))) {\n\t\tser_state_run(ser, msg->event);\n\t\tkfree(msg);\n\t}\n}\n\nstatic int ser_send_msg(struct rtw89_ser *ser, u8 event)\n{\n\tstruct rtw89_dev *rtwdev = container_of(ser, struct rtw89_dev, ser);\n\tstruct ser_msg *msg = NULL;\n\n\tif (test_bit(RTW89_SER_DRV_STOP_RUN, ser->flags))\n\t\treturn -EIO;\n\n\tmsg = kmalloc(sizeof(*msg), GFP_ATOMIC);\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tmsg->event = event;\n\n\tspin_lock_irq(&ser->msg_q_lock);\n\tlist_add(&msg->list, &ser->msg_q);\n\tspin_unlock_irq(&ser->msg_q_lock);\n\n\tieee80211_queue_work(rtwdev->hw, &ser->ser_hdl_work);\n\treturn 0;\n}\n\nstatic void rtw89_ser_alarm_work(struct work_struct *work)\n{\n\tstruct rtw89_ser *ser = container_of(work, struct rtw89_ser,\n\t\t\t\t\t     ser_alarm_work.work);\n\n\tser_send_msg(ser, ser->alarm_event);\n\tser->alarm_event = SER_EV_NONE;\n}\n\nstatic void ser_set_alarm(struct rtw89_ser *ser, u32 ms, u8 event)\n{\n\tstruct rtw89_dev *rtwdev = container_of(ser, struct rtw89_dev, ser);\n\n\tif (test_bit(RTW89_SER_DRV_STOP_RUN, ser->flags))\n\t\treturn;\n\n\tser->alarm_event = event;\n\tieee80211_queue_delayed_work(rtwdev->hw, &ser->ser_alarm_work,\n\t\t\t\t     msecs_to_jiffies(ms));\n}\n\nstatic void ser_del_alarm(struct rtw89_ser *ser)\n{\n\tcancel_delayed_work(&ser->ser_alarm_work);\n\tser->alarm_event = SER_EV_NONE;\n}\n\n \nstatic void drv_stop_tx(struct rtw89_ser *ser)\n{\n\tstruct rtw89_dev *rtwdev = container_of(ser, struct rtw89_dev, ser);\n\n\tieee80211_stop_queues(rtwdev->hw);\n\tset_bit(RTW89_SER_DRV_STOP_TX, ser->flags);\n}\n\nstatic void drv_stop_rx(struct rtw89_ser *ser)\n{\n\tstruct rtw89_dev *rtwdev = container_of(ser, struct rtw89_dev, ser);\n\n\tclear_bit(RTW89_FLAG_RUNNING, rtwdev->flags);\n\tset_bit(RTW89_SER_DRV_STOP_RX, ser->flags);\n}\n\nstatic void drv_trx_reset(struct rtw89_ser *ser)\n{\n\tstruct rtw89_dev *rtwdev = container_of(ser, struct rtw89_dev, ser);\n\n\trtw89_hci_reset(rtwdev);\n}\n\nstatic void drv_resume_tx(struct rtw89_ser *ser)\n{\n\tstruct rtw89_dev *rtwdev = container_of(ser, struct rtw89_dev, ser);\n\n\tif (!test_bit(RTW89_SER_DRV_STOP_TX, ser->flags))\n\t\treturn;\n\n\tieee80211_wake_queues(rtwdev->hw);\n\tclear_bit(RTW89_SER_DRV_STOP_TX, ser->flags);\n}\n\nstatic void drv_resume_rx(struct rtw89_ser *ser)\n{\n\tstruct rtw89_dev *rtwdev = container_of(ser, struct rtw89_dev, ser);\n\n\tif (!test_bit(RTW89_SER_DRV_STOP_RX, ser->flags))\n\t\treturn;\n\n\tset_bit(RTW89_FLAG_RUNNING, rtwdev->flags);\n\tclear_bit(RTW89_SER_DRV_STOP_RX, ser->flags);\n}\n\nstatic void ser_reset_vif(struct rtw89_dev *rtwdev, struct rtw89_vif *rtwvif)\n{\n\trtw89_core_release_bit_map(rtwdev->hw_port, rtwvif->port);\n\trtwvif->net_type = RTW89_NET_TYPE_NO_LINK;\n\trtwvif->trigger = false;\n\trtwvif->tdls_peer = 0;\n}\n\nstatic void ser_sta_deinit_cam_iter(void *data, struct ieee80211_sta *sta)\n{\n\tstruct rtw89_vif *rtwvif = (struct rtw89_vif *)data;\n\tstruct rtw89_dev *rtwdev = rtwvif->rtwdev;\n\tstruct rtw89_sta *rtwsta = (struct rtw89_sta *)sta->drv_priv;\n\n\tif (rtwvif->net_type == RTW89_NET_TYPE_AP_MODE || sta->tdls)\n\t\trtw89_cam_deinit_addr_cam(rtwdev, &rtwsta->addr_cam);\n\tif (sta->tdls)\n\t\trtw89_cam_deinit_bssid_cam(rtwdev, &rtwsta->bssid_cam);\n\n\tINIT_LIST_HEAD(&rtwsta->ba_cam_list);\n}\n\nstatic void ser_deinit_cam(struct rtw89_dev *rtwdev, struct rtw89_vif *rtwvif)\n{\n\tieee80211_iterate_stations_atomic(rtwdev->hw,\n\t\t\t\t\t  ser_sta_deinit_cam_iter,\n\t\t\t\t\t  rtwvif);\n\n\trtw89_cam_deinit(rtwdev, rtwvif);\n\n\tbitmap_zero(rtwdev->cam_info.ba_cam_map, RTW89_MAX_BA_CAM_NUM);\n}\n\nstatic void ser_reset_mac_binding(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_vif *rtwvif;\n\n\trtw89_cam_reset_keys(rtwdev);\n\trtw89_for_each_rtwvif(rtwdev, rtwvif)\n\t\tser_deinit_cam(rtwdev, rtwvif);\n\n\trtw89_core_release_all_bits_map(rtwdev->mac_id_map, RTW89_MAX_MAC_ID_NUM);\n\trtw89_for_each_rtwvif(rtwdev, rtwvif)\n\t\tser_reset_vif(rtwdev, rtwvif);\n\n\trtwdev->total_sta_assoc = 0;\n}\n\n \nstatic int hal_enable_dma(struct rtw89_ser *ser)\n{\n\tstruct rtw89_dev *rtwdev = container_of(ser, struct rtw89_dev, ser);\n\tint ret;\n\n\tif (!test_bit(RTW89_SER_HAL_STOP_DMA, ser->flags))\n\t\treturn 0;\n\n\tif (!rtwdev->hci.ops->mac_lv1_rcvy)\n\t\treturn -EIO;\n\n\tret = rtwdev->hci.ops->mac_lv1_rcvy(rtwdev, RTW89_LV1_RCVY_STEP_2);\n\tif (!ret)\n\t\tclear_bit(RTW89_SER_HAL_STOP_DMA, ser->flags);\n\n\treturn ret;\n}\n\nstatic int hal_stop_dma(struct rtw89_ser *ser)\n{\n\tstruct rtw89_dev *rtwdev = container_of(ser, struct rtw89_dev, ser);\n\tint ret;\n\n\tif (!rtwdev->hci.ops->mac_lv1_rcvy)\n\t\treturn -EIO;\n\n\tret = rtwdev->hci.ops->mac_lv1_rcvy(rtwdev, RTW89_LV1_RCVY_STEP_1);\n\tif (!ret)\n\t\tset_bit(RTW89_SER_HAL_STOP_DMA, ser->flags);\n\n\treturn ret;\n}\n\nstatic void hal_send_post_m0_event(struct rtw89_ser *ser)\n{\n\tstruct rtw89_dev *rtwdev = container_of(ser, struct rtw89_dev, ser);\n\n\trtw89_mac_set_err_status(rtwdev, MAC_AX_ERR_L1_RESET_START_DMAC);\n}\n\nstatic void hal_send_m2_event(struct rtw89_ser *ser)\n{\n\tstruct rtw89_dev *rtwdev = container_of(ser, struct rtw89_dev, ser);\n\n\trtw89_mac_set_err_status(rtwdev, MAC_AX_ERR_L1_DISABLE_EN);\n}\n\nstatic void hal_send_m4_event(struct rtw89_ser *ser)\n{\n\tstruct rtw89_dev *rtwdev = container_of(ser, struct rtw89_dev, ser);\n\n\trtw89_mac_set_err_status(rtwdev, MAC_AX_ERR_L1_RCVY_EN);\n}\n\n \nstatic void ser_idle_st_hdl(struct rtw89_ser *ser, u8 evt)\n{\n\tstruct rtw89_dev *rtwdev = container_of(ser, struct rtw89_dev, ser);\n\n\tswitch (evt) {\n\tcase SER_EV_STATE_IN:\n\t\trtw89_hci_recovery_complete(rtwdev);\n\t\tclear_bit(RTW89_FLAG_SER_HANDLING, rtwdev->flags);\n\t\tclear_bit(RTW89_FLAG_CRASH_SIMULATING, rtwdev->flags);\n\t\tbreak;\n\tcase SER_EV_L1_RESET_PREPARE:\n\t\tser_state_goto(ser, SER_L1_RESET_PRE_ST);\n\t\tbreak;\n\tcase SER_EV_L1_RESET:\n\t\tser_state_goto(ser, SER_RESET_TRX_ST);\n\t\tbreak;\n\tcase SER_EV_L2_RESET:\n\t\tser_state_goto(ser, SER_L2_RESET_ST);\n\t\tbreak;\n\tcase SER_EV_STATE_OUT:\n\t\tset_bit(RTW89_FLAG_SER_HANDLING, rtwdev->flags);\n\t\trtw89_hci_recovery_start(rtwdev);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void ser_l1_reset_pre_st_hdl(struct rtw89_ser *ser, u8 evt)\n{\n\tswitch (evt) {\n\tcase SER_EV_STATE_IN:\n\t\tser->prehandle_l1 = true;\n\t\thal_send_post_m0_event(ser);\n\t\tser_set_alarm(ser, 1000, SER_EV_M1_TIMEOUT);\n\t\tbreak;\n\tcase SER_EV_L1_RESET:\n\t\tser_state_goto(ser, SER_RESET_TRX_ST);\n\t\tbreak;\n\tcase SER_EV_M1_TIMEOUT:\n\t\tser_state_goto(ser, SER_L2_RESET_ST);\n\t\tbreak;\n\tcase SER_EV_STATE_OUT:\n\t\tser_del_alarm(ser);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void ser_reset_trx_st_hdl(struct rtw89_ser *ser, u8 evt)\n{\n\tstruct rtw89_dev *rtwdev = container_of(ser, struct rtw89_dev, ser);\n\n\tswitch (evt) {\n\tcase SER_EV_STATE_IN:\n\t\tcancel_delayed_work_sync(&rtwdev->track_work);\n\t\tdrv_stop_tx(ser);\n\n\t\tif (hal_stop_dma(ser)) {\n\t\t\tser_state_goto(ser, SER_L2_RESET_ST);\n\t\t\tbreak;\n\t\t}\n\n\t\tdrv_stop_rx(ser);\n\t\tdrv_trx_reset(ser);\n\n\t\t \n\t\thal_send_m2_event(ser);\n\n\t\t \n\t\tser_set_alarm(ser, 1000, SER_EV_M3_TIMEOUT);\n\t\tbreak;\n\n\tcase SER_EV_DO_RECOVERY:\n\t\tser_state_goto(ser, SER_DO_HCI_ST);\n\t\tbreak;\n\n\tcase SER_EV_M3_TIMEOUT:\n\t\tser_state_goto(ser, SER_L2_RESET_ST);\n\t\tbreak;\n\n\tcase SER_EV_STATE_OUT:\n\t\tser_del_alarm(ser);\n\t\thal_enable_dma(ser);\n\t\tdrv_resume_rx(ser);\n\t\tdrv_resume_tx(ser);\n\t\tieee80211_queue_delayed_work(rtwdev->hw, &rtwdev->track_work,\n\t\t\t\t\t     RTW89_TRACK_WORK_PERIOD);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void ser_do_hci_st_hdl(struct rtw89_ser *ser, u8 evt)\n{\n\tswitch (evt) {\n\tcase SER_EV_STATE_IN:\n\t\t \n\t\thal_send_m4_event(ser);\n\n\t\t \n\t\tser_set_alarm(ser, 1000, SER_EV_FW_M5_TIMEOUT);\n\t\tbreak;\n\n\tcase SER_EV_FW_M5_TIMEOUT:\n\t\tser_state_goto(ser, SER_L2_RESET_ST);\n\t\tbreak;\n\n\tcase SER_EV_MAC_RESET_DONE:\n\t\tser_state_goto(ser, SER_IDLE_ST);\n\t\tbreak;\n\n\tcase SER_EV_STATE_OUT:\n\t\tser_del_alarm(ser);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void ser_mac_mem_dump(struct rtw89_dev *rtwdev, u8 *buf,\n\t\t\t     u8 sel, u32 start_addr, u32 len)\n{\n\tconst struct rtw89_mac_gen_def *mac = rtwdev->chip->mac_def;\n\tu32 filter_model_addr = mac->filter_model_addr;\n\tu32 indir_access_addr = mac->indir_access_addr;\n\tu32 *ptr = (u32 *)buf;\n\tu32 base_addr, start_page, residue;\n\tu32 cnt = 0;\n\tu32 i;\n\n\tstart_page = start_addr / MAC_MEM_DUMP_PAGE_SIZE;\n\tresidue = start_addr % MAC_MEM_DUMP_PAGE_SIZE;\n\tbase_addr = mac->mem_base_addrs[sel];\n\tbase_addr += start_page * MAC_MEM_DUMP_PAGE_SIZE;\n\n\twhile (cnt < len) {\n\t\trtw89_write32(rtwdev, filter_model_addr, base_addr);\n\n\t\tfor (i = indir_access_addr + residue;\n\t\t     i < indir_access_addr + MAC_MEM_DUMP_PAGE_SIZE;\n\t\t     i += 4, ptr++) {\n\t\t\t*ptr = rtw89_read32(rtwdev, i);\n\t\t\tcnt += 4;\n\t\t\tif (cnt >= len)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tresidue = 0;\n\t\tbase_addr += MAC_MEM_DUMP_PAGE_SIZE;\n\t}\n}\n\nstatic void rtw89_ser_fw_rsvd_ple_dump(struct rtw89_dev *rtwdev, u8 *buf)\n{\n\tu32 start_addr = rtwdev->chip->rsvd_ple_ofst;\n\n\trtw89_debug(rtwdev, RTW89_DBG_SER,\n\t\t    \"dump mem for fw rsvd payload engine (start addr: 0x%x)\\n\",\n\t\t    start_addr);\n\tser_mac_mem_dump(rtwdev, buf, RTW89_MAC_MEM_SHARED_BUF, start_addr,\n\t\t\t RTW89_FW_RSVD_PLE_SIZE);\n}\n\nstruct __fw_backtrace_entry {\n\tu32 wcpu_addr;\n\tu32 size;\n\tu32 key;\n} __packed;\n\nstruct __fw_backtrace_info {\n\tu32 ra;\n\tu32 sp;\n} __packed;\n\nstatic_assert(RTW89_FW_BACKTRACE_INFO_SIZE ==\n\t      sizeof(struct __fw_backtrace_info));\n\nstatic int rtw89_ser_fw_backtrace_dump(struct rtw89_dev *rtwdev, u8 *buf,\n\t\t\t\t       const struct __fw_backtrace_entry *ent)\n{\n\tstruct __fw_backtrace_info *ptr = (struct __fw_backtrace_info *)buf;\n\tconst struct rtw89_mac_gen_def *mac = rtwdev->chip->mac_def;\n\tu32 filter_model_addr = mac->filter_model_addr;\n\tu32 indir_access_addr = mac->indir_access_addr;\n\tu32 fwbt_addr = ent->wcpu_addr & RTW89_WCPU_BASE_MASK;\n\tu32 fwbt_size = ent->size;\n\tu32 fwbt_key = ent->key;\n\tu32 i;\n\n\tif (fwbt_addr == 0) {\n\t\trtw89_warn(rtwdev, \"FW backtrace invalid address: 0x%x\\n\",\n\t\t\t   fwbt_addr);\n\t\treturn -EINVAL;\n\t}\n\n\tif (fwbt_key != RTW89_FW_BACKTRACE_KEY) {\n\t\trtw89_warn(rtwdev, \"FW backtrace invalid key: 0x%x\\n\",\n\t\t\t   fwbt_key);\n\t\treturn -EINVAL;\n\t}\n\n\tif (fwbt_size == 0 || !RTW89_VALID_FW_BACKTRACE_SIZE(fwbt_size) ||\n\t    fwbt_size > RTW89_FW_BACKTRACE_MAX_SIZE) {\n\t\trtw89_warn(rtwdev, \"FW backtrace invalid size: 0x%x\\n\",\n\t\t\t   fwbt_size);\n\t\treturn -EINVAL;\n\t}\n\n\trtw89_debug(rtwdev, RTW89_DBG_SER, \"dump fw backtrace start\\n\");\n\trtw89_write32(rtwdev, filter_model_addr, fwbt_addr);\n\n\tfor (i = indir_access_addr;\n\t     i < indir_access_addr + fwbt_size;\n\t     i += RTW89_FW_BACKTRACE_INFO_SIZE, ptr++) {\n\t\t*ptr = (struct __fw_backtrace_info){\n\t\t\t.ra = rtw89_read32(rtwdev, i),\n\t\t\t.sp = rtw89_read32(rtwdev, i + 4),\n\t\t};\n\t\trtw89_debug(rtwdev, RTW89_DBG_SER,\n\t\t\t    \"next sp: 0x%x, next ra: 0x%x\\n\",\n\t\t\t    ptr->sp, ptr->ra);\n\t}\n\n\trtw89_debug(rtwdev, RTW89_DBG_SER, \"dump fw backtrace end\\n\");\n\treturn 0;\n}\n\nstatic void ser_l2_reset_st_pre_hdl(struct rtw89_ser *ser)\n{\n\tstruct rtw89_dev *rtwdev = container_of(ser, struct rtw89_dev, ser);\n\tstruct rtw89_ser_cd_buffer *buf;\n\tstruct __fw_backtrace_entry fwbt_ent;\n\tint ret = 0;\n\n\tbuf = rtw89_ser_cd_prep(rtwdev);\n\tif (!buf) {\n\t\tret = -ENOMEM;\n\t\tgoto bottom;\n\t}\n\n\trtw89_ser_fw_rsvd_ple_dump(rtwdev, buf->fwple.data);\n\n\tfwbt_ent = *(struct __fw_backtrace_entry *)buf->fwple.data;\n\tret = rtw89_ser_fw_backtrace_dump(rtwdev, buf->fwbt.data, &fwbt_ent);\n\tif (ret)\n\t\tgoto bottom;\n\n\trtw89_ser_cd_send(rtwdev, buf);\n\nbottom:\n\trtw89_ser_cd_free(rtwdev, buf, !!ret);\n\n\tser_reset_mac_binding(rtwdev);\n\trtw89_core_stop(rtwdev);\n\trtw89_entity_init(rtwdev);\n\trtw89_fw_release_general_pkt_list(rtwdev, false);\n\tINIT_LIST_HEAD(&rtwdev->rtwvifs_list);\n}\n\nstatic void ser_l2_reset_st_hdl(struct rtw89_ser *ser, u8 evt)\n{\n\tstruct rtw89_dev *rtwdev = container_of(ser, struct rtw89_dev, ser);\n\n\tswitch (evt) {\n\tcase SER_EV_STATE_IN:\n\t\tmutex_lock(&rtwdev->mutex);\n\t\tser_l2_reset_st_pre_hdl(ser);\n\t\tmutex_unlock(&rtwdev->mutex);\n\n\t\tieee80211_restart_hw(rtwdev->hw);\n\t\tser_set_alarm(ser, SER_RECFG_TIMEOUT, SER_EV_L2_RECFG_TIMEOUT);\n\t\tbreak;\n\n\tcase SER_EV_L2_RECFG_TIMEOUT:\n\t\trtw89_info(rtwdev, \"Err: ser L2 re-config timeout\\n\");\n\t\tfallthrough;\n\tcase SER_EV_L2_RECFG_DONE:\n\t\tser_state_goto(ser, SER_IDLE_ST);\n\t\tbreak;\n\n\tcase SER_EV_STATE_OUT:\n\t\tser_del_alarm(ser);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic const struct event_ent ser_ev_tbl[] = {\n\t{SER_EV_NONE, \"SER_EV_NONE\"},\n\t{SER_EV_STATE_IN, \"SER_EV_STATE_IN\"},\n\t{SER_EV_STATE_OUT, \"SER_EV_STATE_OUT\"},\n\t{SER_EV_L1_RESET_PREPARE, \"SER_EV_L1_RESET_PREPARE pre-m0\"},\n\t{SER_EV_L1_RESET, \"SER_EV_L1_RESET m1\"},\n\t{SER_EV_DO_RECOVERY, \"SER_EV_DO_RECOVERY m3\"},\n\t{SER_EV_MAC_RESET_DONE, \"SER_EV_MAC_RESET_DONE m5\"},\n\t{SER_EV_L2_RESET, \"SER_EV_L2_RESET\"},\n\t{SER_EV_L2_RECFG_DONE, \"SER_EV_L2_RECFG_DONE\"},\n\t{SER_EV_L2_RECFG_TIMEOUT, \"SER_EV_L2_RECFG_TIMEOUT\"},\n\t{SER_EV_M1_TIMEOUT, \"SER_EV_M1_TIMEOUT\"},\n\t{SER_EV_M3_TIMEOUT, \"SER_EV_M3_TIMEOUT\"},\n\t{SER_EV_FW_M5_TIMEOUT, \"SER_EV_FW_M5_TIMEOUT\"},\n\t{SER_EV_L0_RESET, \"SER_EV_L0_RESET\"},\n\t{SER_EV_MAXX, \"SER_EV_MAX\"}\n};\n\nstatic const struct state_ent ser_st_tbl[] = {\n\t{SER_IDLE_ST, \"SER_IDLE_ST\", ser_idle_st_hdl},\n\t{SER_L1_RESET_PRE_ST, \"SER_L1_RESET_PRE_ST\", ser_l1_reset_pre_st_hdl},\n\t{SER_RESET_TRX_ST, \"SER_RESET_TRX_ST\", ser_reset_trx_st_hdl},\n\t{SER_DO_HCI_ST, \"SER_DO_HCI_ST\", ser_do_hci_st_hdl},\n\t{SER_L2_RESET_ST, \"SER_L2_RESET_ST\", ser_l2_reset_st_hdl}\n};\n\nint rtw89_ser_init(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_ser *ser = &rtwdev->ser;\n\n\tmemset(ser, 0, sizeof(*ser));\n\tINIT_LIST_HEAD(&ser->msg_q);\n\tser->state = SER_IDLE_ST;\n\tser->st_tbl = ser_st_tbl;\n\tser->ev_tbl = ser_ev_tbl;\n\n\tbitmap_zero(ser->flags, RTW89_NUM_OF_SER_FLAGS);\n\tspin_lock_init(&ser->msg_q_lock);\n\tINIT_WORK(&ser->ser_hdl_work, rtw89_ser_hdl_work);\n\tINIT_DELAYED_WORK(&ser->ser_alarm_work, rtw89_ser_alarm_work);\n\treturn 0;\n}\n\nint rtw89_ser_deinit(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_ser *ser = (struct rtw89_ser *)&rtwdev->ser;\n\n\tset_bit(RTW89_SER_DRV_STOP_RUN, ser->flags);\n\tcancel_delayed_work_sync(&ser->ser_alarm_work);\n\tcancel_work_sync(&ser->ser_hdl_work);\n\tclear_bit(RTW89_SER_DRV_STOP_RUN, ser->flags);\n\treturn 0;\n}\n\nvoid rtw89_ser_recfg_done(struct rtw89_dev *rtwdev)\n{\n\tser_send_msg(&rtwdev->ser, SER_EV_L2_RECFG_DONE);\n}\n\nint rtw89_ser_notify(struct rtw89_dev *rtwdev, u32 err)\n{\n\tu8 event = SER_EV_NONE;\n\n\trtw89_info(rtwdev, \"SER catches error: 0x%x\\n\", err);\n\n\tswitch (err) {\n\tcase MAC_AX_ERR_L1_PREERR_DMAC:  \n\t\tevent = SER_EV_L1_RESET_PREPARE;\n\t\tbreak;\n\tcase MAC_AX_ERR_L1_ERR_DMAC:\n\tcase MAC_AX_ERR_L0_PROMOTE_TO_L1:\n\t\tevent = SER_EV_L1_RESET;  \n\t\tbreak;\n\tcase MAC_AX_ERR_L1_RESET_DISABLE_DMAC_DONE:\n\t\tevent = SER_EV_DO_RECOVERY;  \n\t\tbreak;\n\tcase MAC_AX_ERR_L1_RESET_RECOVERY_DONE:\n\t\tevent = SER_EV_MAC_RESET_DONE;  \n\t\tbreak;\n\tcase MAC_AX_ERR_L0_ERR_CMAC0:\n\tcase MAC_AX_ERR_L0_ERR_CMAC1:\n\tcase MAC_AX_ERR_L0_RESET_DONE:\n\t\tevent = SER_EV_L0_RESET;\n\t\tbreak;\n\tdefault:\n\t\tif (err == MAC_AX_ERR_L1_PROMOTE_TO_L2 ||\n\t\t    (err >= MAC_AX_ERR_L2_ERR_AH_DMA &&\n\t\t     err <= MAC_AX_GET_ERR_MAX))\n\t\t\tevent = SER_EV_L2_RESET;\n\t\tbreak;\n\t}\n\n\tif (event == SER_EV_NONE) {\n\t\trtw89_warn(rtwdev, \"SER cannot recognize error: 0x%x\\n\", err);\n\t\treturn -EINVAL;\n\t}\n\n\tser_send_msg(&rtwdev->ser, event);\n\treturn 0;\n}\nEXPORT_SYMBOL(rtw89_ser_notify);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}