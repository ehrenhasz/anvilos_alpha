{
  "module_name": "rtw8851b.c",
  "hash_id": "b417aafd2ad58b414600ef3b499aa905461ac3608d860305e9b3d82f48235dcc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtw89/rtw8851b.c",
  "human_readable_source": "\n \n\n#include \"coex.h\"\n#include \"efuse.h\"\n#include \"fw.h\"\n#include \"mac.h\"\n#include \"phy.h\"\n#include \"reg.h\"\n#include \"rtw8851b.h\"\n#include \"rtw8851b_rfk.h\"\n#include \"rtw8851b_rfk_table.h\"\n#include \"rtw8851b_table.h\"\n#include \"txrx.h\"\n#include \"util.h\"\n\n#define RTW8851B_FW_FORMAT_MAX 0\n#define RTW8851B_FW_BASENAME \"rtw89/rtw8851b_fw\"\n#define RTW8851B_MODULE_FIRMWARE \\\n\tRTW8851B_FW_BASENAME \".bin\"\n\nstatic const struct rtw89_hfc_ch_cfg rtw8851b_hfc_chcfg_pcie[] = {\n\t{5, 343, grp_0},  \n\t{5, 343, grp_0},  \n\t{5, 343, grp_0},  \n\t{5, 343, grp_0},  \n\t{0, 0, grp_0},  \n\t{0, 0, grp_0},  \n\t{0, 0, grp_0},  \n\t{0, 0, grp_0},  \n\t{4, 344, grp_0},  \n\t{4, 344, grp_0},  \n\t{0, 0, grp_0},  \n\t{0, 0, grp_0},  \n\t{40, 0, 0}  \n};\n\nstatic const struct rtw89_hfc_pub_cfg rtw8851b_hfc_pubcfg_pcie = {\n\t448,  \n\t0,  \n\t448,  \n\t0  \n};\n\nstatic const struct rtw89_hfc_param_ini rtw8851b_hfc_param_ini_pcie[] = {\n\t[RTW89_QTA_SCC] = {rtw8851b_hfc_chcfg_pcie, &rtw8851b_hfc_pubcfg_pcie,\n\t\t\t   &rtw89_mac_size.hfc_preccfg_pcie, RTW89_HCIFC_POH},\n\t[RTW89_QTA_DLFW] = {NULL, NULL, &rtw89_mac_size.hfc_preccfg_pcie,\n\t\t\t    RTW89_HCIFC_POH},\n\t[RTW89_QTA_INVALID] = {NULL},\n};\n\nstatic const struct rtw89_dle_mem rtw8851b_dle_mem_pcie[] = {\n\t[RTW89_QTA_SCC] = {RTW89_QTA_SCC, &rtw89_mac_size.wde_size6,\n\t\t\t   &rtw89_mac_size.ple_size6, &rtw89_mac_size.wde_qt6,\n\t\t\t   &rtw89_mac_size.wde_qt6, &rtw89_mac_size.ple_qt18,\n\t\t\t   &rtw89_mac_size.ple_qt58},\n\t[RTW89_QTA_WOW] = {RTW89_QTA_WOW, &rtw89_mac_size.wde_size6,\n\t\t\t   &rtw89_mac_size.ple_size6, &rtw89_mac_size.wde_qt6,\n\t\t\t   &rtw89_mac_size.wde_qt6, &rtw89_mac_size.ple_qt18,\n\t\t\t   &rtw89_mac_size.ple_qt_51b_wow},\n\t[RTW89_QTA_DLFW] = {RTW89_QTA_DLFW, &rtw89_mac_size.wde_size9,\n\t\t\t    &rtw89_mac_size.ple_size8, &rtw89_mac_size.wde_qt4,\n\t\t\t    &rtw89_mac_size.wde_qt4, &rtw89_mac_size.ple_qt13,\n\t\t\t    &rtw89_mac_size.ple_qt13},\n\t[RTW89_QTA_INVALID] = {RTW89_QTA_INVALID, NULL, NULL, NULL, NULL, NULL,\n\t\t\t       NULL},\n};\n\nstatic const struct rtw89_reg3_def rtw8851b_btc_preagc_en_defs[] = {\n\t{0x46D0, GENMASK(1, 0), 0x3},\n\t{0x4AD4, GENMASK(31, 0), 0xf},\n\t{0x4688, GENMASK(23, 16), 0x80},\n\t{0x4688, GENMASK(31, 24), 0x80},\n\t{0x4694, GENMASK(7, 0), 0x80},\n\t{0x4694, GENMASK(15, 8), 0x80},\n\t{0x4AE4, GENMASK(11, 6), 0x34},\n\t{0x4AE4, GENMASK(17, 12), 0x0},\n\t{0x469C, GENMASK(31, 26), 0x34},\n};\n\nstatic DECLARE_PHY_REG3_TBL(rtw8851b_btc_preagc_en_defs);\n\nstatic const struct rtw89_reg3_def rtw8851b_btc_preagc_dis_defs[] = {\n\t{0x46D0, GENMASK(1, 0), 0x0},\n\t{0x4AD4, GENMASK(31, 0), 0x60},\n\t{0x4688, GENMASK(23, 16), 0x10},\n\t{0x4690, GENMASK(31, 24), 0x2a},\n\t{0x4694, GENMASK(15, 8), 0x2a},\n\t{0x4AE4, GENMASK(11, 6), 0x26},\n\t{0x4AE4, GENMASK(17, 12), 0x1e},\n\t{0x469C, GENMASK(31, 26), 0x26},\n};\n\nstatic DECLARE_PHY_REG3_TBL(rtw8851b_btc_preagc_dis_defs);\n\nstatic const u32 rtw8851b_h2c_regs[RTW89_H2CREG_MAX] = {\n\tR_AX_H2CREG_DATA0, R_AX_H2CREG_DATA1,  R_AX_H2CREG_DATA2,\n\tR_AX_H2CREG_DATA3\n};\n\nstatic const u32 rtw8851b_c2h_regs[RTW89_C2HREG_MAX] = {\n\tR_AX_C2HREG_DATA0, R_AX_C2HREG_DATA1, R_AX_C2HREG_DATA2,\n\tR_AX_C2HREG_DATA3\n};\n\nstatic const struct rtw89_page_regs rtw8851b_page_regs = {\n\t.hci_fc_ctrl\t= R_AX_HCI_FC_CTRL,\n\t.ch_page_ctrl\t= R_AX_CH_PAGE_CTRL,\n\t.ach_page_ctrl\t= R_AX_ACH0_PAGE_CTRL,\n\t.ach_page_info\t= R_AX_ACH0_PAGE_INFO,\n\t.pub_page_info3\t= R_AX_PUB_PAGE_INFO3,\n\t.pub_page_ctrl1\t= R_AX_PUB_PAGE_CTRL1,\n\t.pub_page_ctrl2\t= R_AX_PUB_PAGE_CTRL2,\n\t.pub_page_info1\t= R_AX_PUB_PAGE_INFO1,\n\t.pub_page_info2 = R_AX_PUB_PAGE_INFO2,\n\t.wp_page_ctrl1\t= R_AX_WP_PAGE_CTRL1,\n\t.wp_page_ctrl2\t= R_AX_WP_PAGE_CTRL2,\n\t.wp_page_info1\t= R_AX_WP_PAGE_INFO1,\n};\n\nstatic const struct rtw89_reg_def rtw8851b_dcfo_comp = {\n\tR_DCFO_COMP_S0_V2, B_DCFO_COMP_S0_MSK_V2\n};\n\nstatic const struct rtw89_imr_info rtw8851b_imr_info = {\n\t.wdrls_imr_set\t\t= B_AX_WDRLS_IMR_SET,\n\t.wsec_imr_reg\t\t= R_AX_SEC_DEBUG,\n\t.wsec_imr_set\t\t= B_AX_IMR_ERROR,\n\t.mpdu_tx_imr_set\t= 0,\n\t.mpdu_rx_imr_set\t= 0,\n\t.sta_sch_imr_set\t= B_AX_STA_SCHEDULER_IMR_SET,\n\t.txpktctl_imr_b0_reg\t= R_AX_TXPKTCTL_ERR_IMR_ISR,\n\t.txpktctl_imr_b0_clr\t= B_AX_TXPKTCTL_IMR_B0_CLR,\n\t.txpktctl_imr_b0_set\t= B_AX_TXPKTCTL_IMR_B0_SET,\n\t.txpktctl_imr_b1_reg\t= R_AX_TXPKTCTL_ERR_IMR_ISR_B1,\n\t.txpktctl_imr_b1_clr\t= B_AX_TXPKTCTL_IMR_B1_CLR,\n\t.txpktctl_imr_b1_set\t= B_AX_TXPKTCTL_IMR_B1_SET,\n\t.wde_imr_clr\t\t= B_AX_WDE_IMR_CLR,\n\t.wde_imr_set\t\t= B_AX_WDE_IMR_SET,\n\t.ple_imr_clr\t\t= B_AX_PLE_IMR_CLR,\n\t.ple_imr_set\t\t= B_AX_PLE_IMR_SET,\n\t.host_disp_imr_clr\t= B_AX_HOST_DISP_IMR_CLR,\n\t.host_disp_imr_set\t= B_AX_HOST_DISP_IMR_SET,\n\t.cpu_disp_imr_clr\t= B_AX_CPU_DISP_IMR_CLR,\n\t.cpu_disp_imr_set\t= B_AX_CPU_DISP_IMR_SET,\n\t.other_disp_imr_clr\t= B_AX_OTHER_DISP_IMR_CLR,\n\t.other_disp_imr_set\t= 0,\n\t.bbrpt_com_err_imr_reg\t= R_AX_BBRPT_COM_ERR_IMR_ISR,\n\t.bbrpt_chinfo_err_imr_reg = R_AX_BBRPT_CHINFO_ERR_IMR_ISR,\n\t.bbrpt_err_imr_set\t= 0,\n\t.bbrpt_dfs_err_imr_reg\t= R_AX_BBRPT_DFS_ERR_IMR_ISR,\n\t.ptcl_imr_clr\t\t= B_AX_PTCL_IMR_CLR_ALL,\n\t.ptcl_imr_set\t\t= B_AX_PTCL_IMR_SET,\n\t.cdma_imr_0_reg\t\t= R_AX_DLE_CTRL,\n\t.cdma_imr_0_clr\t\t= B_AX_DLE_IMR_CLR,\n\t.cdma_imr_0_set\t\t= B_AX_DLE_IMR_SET,\n\t.cdma_imr_1_reg\t\t= 0,\n\t.cdma_imr_1_clr\t\t= 0,\n\t.cdma_imr_1_set\t\t= 0,\n\t.phy_intf_imr_reg\t= R_AX_PHYINFO_ERR_IMR,\n\t.phy_intf_imr_clr\t= 0,\n\t.phy_intf_imr_set\t= 0,\n\t.rmac_imr_reg\t\t= R_AX_RMAC_ERR_ISR,\n\t.rmac_imr_clr\t\t= B_AX_RMAC_IMR_CLR,\n\t.rmac_imr_set\t\t= B_AX_RMAC_IMR_SET,\n\t.tmac_imr_reg\t\t= R_AX_TMAC_ERR_IMR_ISR,\n\t.tmac_imr_clr\t\t= B_AX_TMAC_IMR_CLR,\n\t.tmac_imr_set\t\t= B_AX_TMAC_IMR_SET,\n};\n\nstatic const struct rtw89_xtal_info rtw8851b_xtal_info = {\n\t.xcap_reg\t\t= R_AX_XTAL_ON_CTRL3,\n\t.sc_xo_mask\t\t= B_AX_XTAL_SC_XO_A_BLOCK_MASK,\n\t.sc_xi_mask\t\t= B_AX_XTAL_SC_XI_A_BLOCK_MASK,\n};\n\nstatic const struct rtw89_rrsr_cfgs rtw8851b_rrsr_cfgs = {\n\t.ref_rate = {R_AX_TRXPTCL_RRSR_CTL_0, B_AX_WMAC_RESP_REF_RATE_SEL, 0},\n\t.rsc = {R_AX_TRXPTCL_RRSR_CTL_0, B_AX_WMAC_RESP_RSC_MASK, 2},\n};\n\nstatic const struct rtw89_dig_regs rtw8851b_dig_regs = {\n\t.seg0_pd_reg = R_SEG0R_PD_V1,\n\t.pd_lower_bound_mask = B_SEG0R_PD_LOWER_BOUND_MSK,\n\t.pd_spatial_reuse_en = B_SEG0R_PD_SPATIAL_REUSE_EN_MSK_V1,\n\t.bmode_pd_reg = R_BMODE_PDTH_EN_V1,\n\t.bmode_cca_rssi_limit_en = B_BMODE_PDTH_LIMIT_EN_MSK_V1,\n\t.bmode_pd_lower_bound_reg = R_BMODE_PDTH_V1,\n\t.bmode_rssi_nocca_low_th_mask = B_BMODE_PDTH_LOWER_BOUND_MSK_V1,\n\t.p0_lna_init = {R_PATH0_LNA_INIT_V1, B_PATH0_LNA_INIT_IDX_MSK},\n\t.p1_lna_init = {R_PATH1_LNA_INIT_V1, B_PATH1_LNA_INIT_IDX_MSK},\n\t.p0_tia_init = {R_PATH0_TIA_INIT_V1, B_PATH0_TIA_INIT_IDX_MSK_V1},\n\t.p1_tia_init = {R_PATH1_TIA_INIT_V1, B_PATH1_TIA_INIT_IDX_MSK_V1},\n\t.p0_rxb_init = {R_PATH0_RXB_INIT_V1, B_PATH0_RXB_INIT_IDX_MSK_V1},\n\t.p1_rxb_init = {R_PATH1_RXB_INIT_V1, B_PATH1_RXB_INIT_IDX_MSK_V1},\n\t.p0_p20_pagcugc_en = {R_PATH0_P20_FOLLOW_BY_PAGCUGC_V2,\n\t\t\t      B_PATH0_P20_FOLLOW_BY_PAGCUGC_EN_MSK},\n\t.p0_s20_pagcugc_en = {R_PATH0_S20_FOLLOW_BY_PAGCUGC_V2,\n\t\t\t      B_PATH0_S20_FOLLOW_BY_PAGCUGC_EN_MSK},\n\t.p1_p20_pagcugc_en = {R_PATH1_P20_FOLLOW_BY_PAGCUGC_V2,\n\t\t\t      B_PATH1_P20_FOLLOW_BY_PAGCUGC_EN_MSK},\n\t.p1_s20_pagcugc_en = {R_PATH1_S20_FOLLOW_BY_PAGCUGC_V2,\n\t\t\t      B_PATH1_S20_FOLLOW_BY_PAGCUGC_EN_MSK},\n};\n\nstatic const struct rtw89_btc_rf_trx_para rtw89_btc_8851b_rf_ul[] = {\n\t{255, 0, 0, 7},  \n\t{255, 2, 0, 7},  \n\t{255, 0, 0, 7},  \n\t{255, 0, 0, 7},  \n\t{255, 0, 0, 7},  \n\t{255, 1, 0, 7},  \n\t{6, 1, 0, 7},\n\t{13, 1, 0, 7},\n\t{13, 1, 0, 7}\n};\n\nstatic const struct rtw89_btc_rf_trx_para rtw89_btc_8851b_rf_dl[] = {\n\t{255, 0, 0, 7},  \n\t{255, 2, 0, 7},  \n\t{255, 0, 0, 7},  \n\t{255, 0, 0, 7},  \n\t{255, 0, 0, 7},  \n\t{255, 1, 0, 7},  \n\t{255, 1, 0, 7},\n\t{255, 1, 0, 7},\n\t{255, 1, 0, 7}\n};\n\nstatic const struct rtw89_btc_fbtc_mreg rtw89_btc_8851b_mon_reg[] = {\n\tRTW89_DEF_FBTC_MREG(REG_MAC, 4, 0xda24),\n\tRTW89_DEF_FBTC_MREG(REG_MAC, 4, 0xda28),\n\tRTW89_DEF_FBTC_MREG(REG_MAC, 4, 0xda2c),\n\tRTW89_DEF_FBTC_MREG(REG_MAC, 4, 0xda30),\n\tRTW89_DEF_FBTC_MREG(REG_MAC, 4, 0xda4c),\n\tRTW89_DEF_FBTC_MREG(REG_MAC, 4, 0xda10),\n\tRTW89_DEF_FBTC_MREG(REG_MAC, 4, 0xda20),\n\tRTW89_DEF_FBTC_MREG(REG_MAC, 4, 0xda34),\n\tRTW89_DEF_FBTC_MREG(REG_MAC, 4, 0xcef4),\n\tRTW89_DEF_FBTC_MREG(REG_MAC, 4, 0x8424),\n\tRTW89_DEF_FBTC_MREG(REG_MAC, 4, 0xd200),\n\tRTW89_DEF_FBTC_MREG(REG_MAC, 4, 0xd220),\n\tRTW89_DEF_FBTC_MREG(REG_BB, 4, 0x980),\n\tRTW89_DEF_FBTC_MREG(REG_BB, 4, 0x4738),\n\tRTW89_DEF_FBTC_MREG(REG_BB, 4, 0x4688),\n\tRTW89_DEF_FBTC_MREG(REG_BB, 4, 0x4694),\n};\n\nstatic const u8 rtw89_btc_8851b_wl_rssi_thres[BTC_WL_RSSI_THMAX] = {70, 60, 50, 40};\nstatic const u8 rtw89_btc_8851b_bt_rssi_thres[BTC_BT_RSSI_THMAX] = {50, 40, 30, 20};\n\nstatic int rtw8851b_pwr_on_func(struct rtw89_dev *rtwdev)\n{\n\tu32 val32;\n\tu8 val8;\n\tu32 ret;\n\n\trtw89_write32_clr(rtwdev, R_AX_SYS_PW_CTRL, B_AX_AFSM_WLSUS_EN |\n\t\t\t\t\t\t    B_AX_AFSM_PCIE_SUS_EN);\n\trtw89_write32_set(rtwdev, R_AX_SYS_PW_CTRL, B_AX_DIS_WLBT_PDNSUSEN_SOPC);\n\trtw89_write32_set(rtwdev, R_AX_WLLPS_CTRL, B_AX_DIS_WLBT_LPSEN_LOPC);\n\trtw89_write32_clr(rtwdev, R_AX_SYS_PW_CTRL, B_AX_APDM_HPDN);\n\trtw89_write32_clr(rtwdev, R_AX_SYS_PW_CTRL, B_AX_APFM_SWLPS);\n\n\tret = read_poll_timeout(rtw89_read32, val32, val32 & B_AX_RDY_SYSPWR,\n\t\t\t\t1000, 20000, false, rtwdev, R_AX_SYS_PW_CTRL);\n\tif (ret)\n\t\treturn ret;\n\n\trtw89_write32_set(rtwdev, R_AX_SYS_PW_CTRL, B_AX_EN_WLON);\n\trtw89_write32_set(rtwdev, R_AX_SYS_PW_CTRL, B_AX_APFN_ONMAC);\n\n\tret = read_poll_timeout(rtw89_read32, val32, !(val32 & B_AX_APFN_ONMAC),\n\t\t\t\t1000, 20000, false, rtwdev, R_AX_SYS_PW_CTRL);\n\tif (ret)\n\t\treturn ret;\n\n\trtw89_write8_set(rtwdev, R_AX_PLATFORM_ENABLE, B_AX_PLATFORM_EN);\n\trtw89_write8_clr(rtwdev, R_AX_PLATFORM_ENABLE, B_AX_PLATFORM_EN);\n\trtw89_write8_set(rtwdev, R_AX_PLATFORM_ENABLE, B_AX_PLATFORM_EN);\n\trtw89_write8_clr(rtwdev, R_AX_PLATFORM_ENABLE, B_AX_PLATFORM_EN);\n\n\trtw89_write8_set(rtwdev, R_AX_PLATFORM_ENABLE, B_AX_PLATFORM_EN);\n\trtw89_write32_clr(rtwdev, R_AX_SYS_SDIO_CTRL, B_AX_PCIE_CALIB_EN_V1);\n\n\tret = rtw89_mac_write_xtal_si(rtwdev, XTAL_SI_ANAPAR_WL, XTAL_SI_OFF_WEI,\n\t\t\t\t      XTAL_SI_OFF_WEI);\n\tif (ret)\n\t\treturn ret;\n\tret = rtw89_mac_write_xtal_si(rtwdev, XTAL_SI_ANAPAR_WL, XTAL_SI_OFF_EI,\n\t\t\t\t      XTAL_SI_OFF_EI);\n\tif (ret)\n\t\treturn ret;\n\tret = rtw89_mac_write_xtal_si(rtwdev, XTAL_SI_ANAPAR_WL, 0, XTAL_SI_RFC2RF);\n\tif (ret)\n\t\treturn ret;\n\tret = rtw89_mac_write_xtal_si(rtwdev, XTAL_SI_ANAPAR_WL, XTAL_SI_PON_WEI,\n\t\t\t\t      XTAL_SI_PON_WEI);\n\tif (ret)\n\t\treturn ret;\n\tret = rtw89_mac_write_xtal_si(rtwdev, XTAL_SI_ANAPAR_WL, XTAL_SI_PON_EI,\n\t\t\t\t      XTAL_SI_PON_EI);\n\tif (ret)\n\t\treturn ret;\n\tret = rtw89_mac_write_xtal_si(rtwdev, XTAL_SI_ANAPAR_WL, 0, XTAL_SI_SRAM2RFC);\n\tif (ret)\n\t\treturn ret;\n\tret = rtw89_mac_write_xtal_si(rtwdev, XTAL_SI_SRAM_CTRL, 0, XTAL_SI_SRAM_DIS);\n\tif (ret)\n\t\treturn ret;\n\tret = rtw89_mac_write_xtal_si(rtwdev, XTAL_SI_XTAL_XMD_2, 0, XTAL_SI_LDO_LPS);\n\tif (ret)\n\t\treturn ret;\n\tret = rtw89_mac_write_xtal_si(rtwdev, XTAL_SI_XTAL_XMD_4, 0, XTAL_SI_LPS_CAP);\n\tif (ret)\n\t\treturn ret;\n\tret = rtw89_mac_write_xtal_si(rtwdev, XTAL_SI_XTAL_DRV, 0, XTAL_SI_DRV_LATCH);\n\tif (ret)\n\t\treturn ret;\n\n\trtw89_write32_set(rtwdev, R_AX_PMC_DBG_CTRL2, B_AX_SYSON_DIS_PMCR_AX_WRMSK);\n\trtw89_write32_set(rtwdev, R_AX_SYS_ISO_CTRL, B_AX_ISO_EB2CORE);\n\trtw89_write32_clr(rtwdev, R_AX_SYS_ISO_CTRL, B_AX_PWC_EV2EF_B15);\n\n\tfsleep(1000);\n\n\trtw89_write32_clr(rtwdev, R_AX_SYS_ISO_CTRL, B_AX_PWC_EV2EF_B14);\n\trtw89_write32_clr(rtwdev, R_AX_PMC_DBG_CTRL2, B_AX_SYSON_DIS_PMCR_AX_WRMSK);\n\trtw89_write32_set(rtwdev, R_AX_GPIO0_16_EECS_EESK_LED1_PULL_LOW_EN,\n\t\t\t  B_AX_GPIO10_PULL_LOW_EN | B_AX_GPIO16_PULL_LOW_EN_V1);\n\n\tif (rtwdev->hal.cv == CHIP_CAV) {\n\t\tret = rtw89_read_efuse_ver(rtwdev, &val8);\n\t\tif (!ret)\n\t\t\trtwdev->hal.cv = val8;\n\t}\n\n\trtw89_write32_clr(rtwdev, R_AX_WLAN_XTAL_SI_CONFIG,\n\t\t\t  B_AX_XTAL_SI_ADDR_NOT_CHK);\n\tif (rtwdev->hal.cv != CHIP_CAV) {\n\t\trtw89_write32_set(rtwdev, R_AX_SPSLDO_ON_CTRL1, B_AX_FPWMDELAY);\n\t\trtw89_write32_set(rtwdev, R_AX_SPSANA_ON_CTRL1, B_AX_FPWMDELAY);\n\t}\n\n\trtw89_write32_set(rtwdev, R_AX_DMAC_FUNC_EN,\n\t\t\t  B_AX_MAC_FUNC_EN | B_AX_DMAC_FUNC_EN | B_AX_MPDU_PROC_EN |\n\t\t\t  B_AX_WD_RLS_EN | B_AX_DLE_WDE_EN | B_AX_TXPKT_CTRL_EN |\n\t\t\t  B_AX_STA_SCH_EN | B_AX_DLE_PLE_EN | B_AX_PKT_BUF_EN |\n\t\t\t  B_AX_DMAC_TBL_EN | B_AX_PKT_IN_EN | B_AX_DLE_CPUIO_EN |\n\t\t\t  B_AX_DISPATCHER_EN | B_AX_BBRPT_EN | B_AX_MAC_SEC_EN |\n\t\t\t  B_AX_DMACREG_GCKEN);\n\trtw89_write32_set(rtwdev, R_AX_CMAC_FUNC_EN,\n\t\t\t  B_AX_CMAC_EN | B_AX_CMAC_TXEN | B_AX_CMAC_RXEN |\n\t\t\t  B_AX_FORCE_CMACREG_GCKEN | B_AX_PHYINTF_EN | B_AX_CMAC_DMA_EN |\n\t\t\t  B_AX_PTCLTOP_EN | B_AX_SCHEDULER_EN | B_AX_TMAC_EN |\n\t\t\t  B_AX_RMAC_EN);\n\n\trtw89_write32_mask(rtwdev, R_AX_EECS_EESK_FUNC_SEL, B_AX_PINMUX_EESK_FUNC_SEL_MASK,\n\t\t\t   PINMUX_EESK_FUNC_SEL_BT_LOG);\n\n\treturn 0;\n}\n\nstatic void rtw8851b_patch_swr_pfm2pwm(struct rtw89_dev *rtwdev)\n{\n\trtw89_write32_set(rtwdev, R_AX_SYS_PW_CTRL, B_AX_SOP_PWMM_DSWR);\n\trtw89_write32_set(rtwdev, R_AX_SYS_PW_CTRL, B_AX_SOP_ASWRM);\n\trtw89_write32_set(rtwdev, R_AX_WLLPS_CTRL, B_AX_LPSOP_DSWRM);\n\trtw89_write32_set(rtwdev, R_AX_WLLPS_CTRL, B_AX_LPSOP_ASWRM);\n}\n\nstatic int rtw8851b_pwr_off_func(struct rtw89_dev *rtwdev)\n{\n\tu32 val32;\n\tu32 ret;\n\n\tret = rtw89_mac_write_xtal_si(rtwdev, XTAL_SI_ANAPAR_WL, XTAL_SI_RFC2RF,\n\t\t\t\t      XTAL_SI_RFC2RF);\n\tif (ret)\n\t\treturn ret;\n\tret = rtw89_mac_write_xtal_si(rtwdev, XTAL_SI_ANAPAR_WL, 0, XTAL_SI_OFF_EI);\n\tif (ret)\n\t\treturn ret;\n\tret = rtw89_mac_write_xtal_si(rtwdev, XTAL_SI_ANAPAR_WL, 0, XTAL_SI_OFF_WEI);\n\tif (ret)\n\t\treturn ret;\n\tret = rtw89_mac_write_xtal_si(rtwdev, XTAL_SI_WL_RFC_S0, 0, XTAL_SI_RF00);\n\tif (ret)\n\t\treturn ret;\n\tret = rtw89_mac_write_xtal_si(rtwdev, XTAL_SI_ANAPAR_WL, XTAL_SI_SRAM2RFC,\n\t\t\t\t      XTAL_SI_SRAM2RFC);\n\tif (ret)\n\t\treturn ret;\n\tret = rtw89_mac_write_xtal_si(rtwdev, XTAL_SI_ANAPAR_WL, 0, XTAL_SI_PON_EI);\n\tif (ret)\n\t\treturn ret;\n\tret = rtw89_mac_write_xtal_si(rtwdev, XTAL_SI_ANAPAR_WL, 0, XTAL_SI_PON_WEI);\n\tif (ret)\n\t\treturn ret;\n\n\trtw89_write32_set(rtwdev, R_AX_WLAN_XTAL_SI_CONFIG,\n\t\t\t  B_AX_XTAL_SI_ADDR_NOT_CHK);\n\trtw89_write32_set(rtwdev, R_AX_SYS_PW_CTRL, B_AX_EN_WLON);\n\trtw89_write32_clr(rtwdev, R_AX_WLRF_CTRL, B_AX_AFC_AFEDIG);\n\trtw89_write8_clr(rtwdev, R_AX_SYS_FUNC_EN, B_AX_FEN_BB_GLB_RSTN | B_AX_FEN_BBRSTB);\n\n\trtw89_write32_set(rtwdev, R_AX_SYS_PW_CTRL, B_AX_APFM_OFFMAC);\n\n\tret = read_poll_timeout(rtw89_read32, val32, !(val32 & B_AX_APFM_OFFMAC),\n\t\t\t\t1000, 20000, false, rtwdev, R_AX_SYS_PW_CTRL);\n\tif (ret)\n\t\treturn ret;\n\n\trtw89_write32(rtwdev, R_AX_WLLPS_CTRL, SW_LPS_OPTION);\n\n\tif (rtwdev->hal.cv == CHIP_CAV) {\n\t\trtw8851b_patch_swr_pfm2pwm(rtwdev);\n\t} else {\n\t\trtw89_write32_set(rtwdev, R_AX_SPSLDO_ON_CTRL1, B_AX_FPWMDELAY);\n\t\trtw89_write32_set(rtwdev, R_AX_SPSANA_ON_CTRL1, B_AX_FPWMDELAY);\n\t}\n\n\trtw89_write32_set(rtwdev, R_AX_SYS_PW_CTRL, B_AX_APFM_SWLPS);\n\n\treturn 0;\n}\n\nstatic void rtw8851b_efuse_parsing(struct rtw89_efuse *efuse,\n\t\t\t\t   struct rtw8851b_efuse *map)\n{\n\tether_addr_copy(efuse->addr, map->e.mac_addr);\n\tefuse->rfe_type = map->rfe_type;\n\tefuse->xtal_cap = map->xtal_k;\n}\n\nstatic void rtw8851b_efuse_parsing_tssi(struct rtw89_dev *rtwdev,\n\t\t\t\t\tstruct rtw8851b_efuse *map)\n{\n\tstruct rtw89_tssi_info *tssi = &rtwdev->tssi;\n\tstruct rtw8851b_tssi_offset *ofst[] = {&map->path_a_tssi};\n\tu8 i, j;\n\n\ttssi->thermal[RF_PATH_A] = map->path_a_therm;\n\n\tfor (i = 0; i < RF_PATH_NUM_8851B; i++) {\n\t\tmemcpy(tssi->tssi_cck[i], ofst[i]->cck_tssi,\n\t\t       sizeof(ofst[i]->cck_tssi));\n\n\t\tfor (j = 0; j < TSSI_CCK_CH_GROUP_NUM; j++)\n\t\t\trtw89_debug(rtwdev, RTW89_DBG_TSSI,\n\t\t\t\t    \"[TSSI][EFUSE] path=%d cck[%d]=0x%x\\n\",\n\t\t\t\t    i, j, tssi->tssi_cck[i][j]);\n\n\t\tmemcpy(tssi->tssi_mcs[i], ofst[i]->bw40_tssi,\n\t\t       sizeof(ofst[i]->bw40_tssi));\n\t\tmemcpy(tssi->tssi_mcs[i] + TSSI_MCS_2G_CH_GROUP_NUM,\n\t\t       ofst[i]->bw40_1s_tssi_5g, sizeof(ofst[i]->bw40_1s_tssi_5g));\n\n\t\tfor (j = 0; j < TSSI_MCS_CH_GROUP_NUM; j++)\n\t\t\trtw89_debug(rtwdev, RTW89_DBG_TSSI,\n\t\t\t\t    \"[TSSI][EFUSE] path=%d mcs[%d]=0x%x\\n\",\n\t\t\t\t    i, j, tssi->tssi_mcs[i][j]);\n\t}\n}\n\nstatic bool _decode_efuse_gain(u8 data, s8 *high, s8 *low)\n{\n\tif (high)\n\t\t*high = sign_extend32(u8_get_bits(data, GENMASK(7,  4)), 3);\n\tif (low)\n\t\t*low = sign_extend32(u8_get_bits(data, GENMASK(3,  0)), 3);\n\n\treturn data != 0xff;\n}\n\nstatic void rtw8851b_efuse_parsing_gain_offset(struct rtw89_dev *rtwdev,\n\t\t\t\t\t       struct rtw8851b_efuse *map)\n{\n\tstruct rtw89_phy_efuse_gain *gain = &rtwdev->efuse_gain;\n\tbool valid = false;\n\n\tvalid |= _decode_efuse_gain(map->rx_gain_2g_cck,\n\t\t\t\t    &gain->offset[RF_PATH_A][RTW89_GAIN_OFFSET_2G_CCK],\n\t\t\t\t    NULL);\n\tvalid |= _decode_efuse_gain(map->rx_gain_2g_ofdm,\n\t\t\t\t    &gain->offset[RF_PATH_A][RTW89_GAIN_OFFSET_2G_OFDM],\n\t\t\t\t    NULL);\n\tvalid |= _decode_efuse_gain(map->rx_gain_5g_low,\n\t\t\t\t    &gain->offset[RF_PATH_A][RTW89_GAIN_OFFSET_5G_LOW],\n\t\t\t\t    NULL);\n\tvalid |= _decode_efuse_gain(map->rx_gain_5g_mid,\n\t\t\t\t    &gain->offset[RF_PATH_A][RTW89_GAIN_OFFSET_5G_MID],\n\t\t\t\t   NULL);\n\tvalid |= _decode_efuse_gain(map->rx_gain_5g_high,\n\t\t\t\t    &gain->offset[RF_PATH_A][RTW89_GAIN_OFFSET_5G_HIGH],\n\t\t\t\t    NULL);\n\n\tgain->offset_valid = valid;\n}\n\nstatic int rtw8851b_read_efuse(struct rtw89_dev *rtwdev, u8 *log_map)\n{\n\tstruct rtw89_efuse *efuse = &rtwdev->efuse;\n\tstruct rtw8851b_efuse *map;\n\n\tmap = (struct rtw8851b_efuse *)log_map;\n\n\tefuse->country_code[0] = map->country_code[0];\n\tefuse->country_code[1] = map->country_code[1];\n\trtw8851b_efuse_parsing_tssi(rtwdev, map);\n\trtw8851b_efuse_parsing_gain_offset(rtwdev, map);\n\n\tswitch (rtwdev->hci.type) {\n\tcase RTW89_HCI_TYPE_PCIE:\n\t\trtw8851b_efuse_parsing(efuse, map);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\trtw89_info(rtwdev, \"chip rfe_type is %d\\n\", efuse->rfe_type);\n\n\treturn 0;\n}\n\nstatic void rtw8851b_phycap_parsing_tssi(struct rtw89_dev *rtwdev, u8 *phycap_map)\n{\n\tstruct rtw89_tssi_info *tssi = &rtwdev->tssi;\n\tstatic const u32 tssi_trim_addr[RF_PATH_NUM_8851B] = {0x5D6};\n\tu32 addr = rtwdev->chip->phycap_addr;\n\tbool pg = false;\n\tu32 ofst;\n\tu8 i, j;\n\n\tfor (i = 0; i < RF_PATH_NUM_8851B; i++) {\n\t\tfor (j = 0; j < TSSI_TRIM_CH_GROUP_NUM; j++) {\n\t\t\t \n\t\t\tofst = tssi_trim_addr[i] - addr - j;\n\t\t\ttssi->tssi_trim[i][j] = phycap_map[ofst];\n\n\t\t\tif (phycap_map[ofst] != 0xff)\n\t\t\t\tpg = true;\n\t\t}\n\t}\n\n\tif (!pg) {\n\t\tmemset(tssi->tssi_trim, 0, sizeof(tssi->tssi_trim));\n\t\trtw89_debug(rtwdev, RTW89_DBG_TSSI,\n\t\t\t    \"[TSSI][TRIM] no PG, set all trim info to 0\\n\");\n\t}\n\n\tfor (i = 0; i < RF_PATH_NUM_8851B; i++)\n\t\tfor (j = 0; j < TSSI_TRIM_CH_GROUP_NUM; j++)\n\t\t\trtw89_debug(rtwdev, RTW89_DBG_TSSI,\n\t\t\t\t    \"[TSSI] path=%d idx=%d trim=0x%x addr=0x%x\\n\",\n\t\t\t\t    i, j, tssi->tssi_trim[i][j],\n\t\t\t\t    tssi_trim_addr[i] - j);\n}\n\nstatic void rtw8851b_phycap_parsing_thermal_trim(struct rtw89_dev *rtwdev,\n\t\t\t\t\t\t u8 *phycap_map)\n{\n\tstruct rtw89_power_trim_info *info = &rtwdev->pwr_trim;\n\tstatic const u32 thm_trim_addr[RF_PATH_NUM_8851B] = {0x5DF};\n\tu32 addr = rtwdev->chip->phycap_addr;\n\tu8 i;\n\n\tfor (i = 0; i < RF_PATH_NUM_8851B; i++) {\n\t\tinfo->thermal_trim[i] = phycap_map[thm_trim_addr[i] - addr];\n\n\t\trtw89_debug(rtwdev, RTW89_DBG_RFK,\n\t\t\t    \"[THERMAL][TRIM] path=%d thermal_trim=0x%x\\n\",\n\t\t\t    i, info->thermal_trim[i]);\n\n\t\tif (info->thermal_trim[i] != 0xff)\n\t\t\tinfo->pg_thermal_trim = true;\n\t}\n}\n\nstatic void rtw8851b_thermal_trim(struct rtw89_dev *rtwdev)\n{\n#define __thm_setting(raw)\t\t\t\t\\\n({\t\t\t\t\t\t\t\\\n\tu8 __v = (raw);\t\t\t\t\t\\\n\t((__v & 0x1) << 3) | ((__v & 0x1f) >> 1);\t\\\n})\n\tstruct rtw89_power_trim_info *info = &rtwdev->pwr_trim;\n\tu8 i, val;\n\n\tif (!info->pg_thermal_trim) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_RFK,\n\t\t\t    \"[THERMAL][TRIM] no PG, do nothing\\n\");\n\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < RF_PATH_NUM_8851B; i++) {\n\t\tval = __thm_setting(info->thermal_trim[i]);\n\t\trtw89_write_rf(rtwdev, i, RR_TM2, RR_TM2_OFF, val);\n\n\t\trtw89_debug(rtwdev, RTW89_DBG_RFK,\n\t\t\t    \"[THERMAL][TRIM] path=%d thermal_setting=0x%x\\n\",\n\t\t\t    i, val);\n\t}\n#undef __thm_setting\n}\n\nstatic void rtw8851b_phycap_parsing_pa_bias_trim(struct rtw89_dev *rtwdev,\n\t\t\t\t\t\t u8 *phycap_map)\n{\n\tstruct rtw89_power_trim_info *info = &rtwdev->pwr_trim;\n\tstatic const u32 pabias_trim_addr[] = {0x5DE};\n\tu32 addr = rtwdev->chip->phycap_addr;\n\tu8 i;\n\n\tfor (i = 0; i < RF_PATH_NUM_8851B; i++) {\n\t\tinfo->pa_bias_trim[i] = phycap_map[pabias_trim_addr[i] - addr];\n\n\t\trtw89_debug(rtwdev, RTW89_DBG_RFK,\n\t\t\t    \"[PA_BIAS][TRIM] path=%d pa_bias_trim=0x%x\\n\",\n\t\t\t    i, info->pa_bias_trim[i]);\n\n\t\tif (info->pa_bias_trim[i] != 0xff)\n\t\t\tinfo->pg_pa_bias_trim = true;\n\t}\n}\n\nstatic void rtw8851b_pa_bias_trim(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_power_trim_info *info = &rtwdev->pwr_trim;\n\tu8 pabias_2g, pabias_5g;\n\tu8 i;\n\n\tif (!info->pg_pa_bias_trim) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_RFK,\n\t\t\t    \"[PA_BIAS][TRIM] no PG, do nothing\\n\");\n\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < RF_PATH_NUM_8851B; i++) {\n\t\tpabias_2g = u8_get_bits(info->pa_bias_trim[i], GENMASK(3, 0));\n\t\tpabias_5g = u8_get_bits(info->pa_bias_trim[i], GENMASK(7, 4));\n\n\t\trtw89_debug(rtwdev, RTW89_DBG_RFK,\n\t\t\t    \"[PA_BIAS][TRIM] path=%d 2G=0x%x 5G=0x%x\\n\",\n\t\t\t    i, pabias_2g, pabias_5g);\n\n\t\trtw89_write_rf(rtwdev, i, RR_BIASA, RR_BIASA_TXG, pabias_2g);\n\t\trtw89_write_rf(rtwdev, i, RR_BIASA, RR_BIASA_TXA, pabias_5g);\n\t}\n}\n\nstatic void rtw8851b_phycap_parsing_gain_comp(struct rtw89_dev *rtwdev, u8 *phycap_map)\n{\n\tstatic const u32 comp_addrs[][RTW89_SUBBAND_2GHZ_5GHZ_NR] = {\n\t\t{0x5BB, 0x5BA, 0, 0x5B9, 0x5B8},\n\t};\n\tstruct rtw89_phy_efuse_gain *gain = &rtwdev->efuse_gain;\n\tu32 phycap_addr = rtwdev->chip->phycap_addr;\n\tbool valid = false;\n\tint path, i;\n\tu8 data;\n\n\tfor (path = 0; path < BB_PATH_NUM_8851B; path++)\n\t\tfor (i = 0; i < RTW89_SUBBAND_2GHZ_5GHZ_NR; i++) {\n\t\t\tif (comp_addrs[path][i] == 0)\n\t\t\t\tcontinue;\n\n\t\t\tdata = phycap_map[comp_addrs[path][i] - phycap_addr];\n\t\t\tvalid |= _decode_efuse_gain(data, NULL,\n\t\t\t\t\t\t    &gain->comp[path][i]);\n\t\t}\n\n\tgain->comp_valid = valid;\n}\n\nstatic int rtw8851b_read_phycap(struct rtw89_dev *rtwdev, u8 *phycap_map)\n{\n\trtw8851b_phycap_parsing_tssi(rtwdev, phycap_map);\n\trtw8851b_phycap_parsing_thermal_trim(rtwdev, phycap_map);\n\trtw8851b_phycap_parsing_pa_bias_trim(rtwdev, phycap_map);\n\trtw8851b_phycap_parsing_gain_comp(rtwdev, phycap_map);\n\n\treturn 0;\n}\n\nstatic void rtw8851b_set_bb_gpio(struct rtw89_dev *rtwdev, u8 gpio_idx, bool inv,\n\t\t\t\t u8 src_sel)\n{\n\tu32 addr, mask;\n\n\tif (gpio_idx >= 32)\n\t\treturn;\n\n\t \n\taddr = R_RFE_SEL0_A2 + (gpio_idx / 16) * sizeof(u32);\n\tmask = B_RFE_SEL0_MASK << (gpio_idx % 16) * 2;\n\n\trtw89_phy_write32_mask(rtwdev, addr, mask, RF_PATH_A);\n\trtw89_phy_write32_mask(rtwdev, R_RFE_INV0, BIT(gpio_idx), inv);\n\n\t \n\taddr = R_RFE_SEL0_BASE + (gpio_idx / 8) * sizeof(u32);\n\tmask = B_RFE_SEL0_SRC_MASK << (gpio_idx % 8) * 4;\n\n\trtw89_phy_write32_mask(rtwdev, addr, mask, src_sel);\n}\n\nstatic void rtw8851b_set_mac_gpio(struct rtw89_dev *rtwdev, u8 func)\n{\n\tstatic const struct rtw89_reg3_def func16 = {\n\t\tR_AX_GPIO16_23_FUNC_SEL, B_AX_PINMUX_GPIO16_FUNC_SEL_MASK, BIT(3)\n\t};\n\tstatic const struct rtw89_reg3_def func17 = {\n\t\tR_AX_GPIO16_23_FUNC_SEL, B_AX_PINMUX_GPIO17_FUNC_SEL_MASK, BIT(7) >> 4,\n\t};\n\tconst struct rtw89_reg3_def *def;\n\n\tswitch (func) {\n\tcase 16:\n\t\tdef = &func16;\n\t\tbreak;\n\tcase 17:\n\t\tdef = &func17;\n\t\tbreak;\n\tdefault:\n\t\trtw89_warn(rtwdev, \"undefined gpio func %d\\n\", func);\n\t\treturn;\n\t}\n\n\trtw89_write8_mask(rtwdev, def->addr, def->mask, def->data);\n}\n\nstatic void rtw8851b_rfe_gpio(struct rtw89_dev *rtwdev)\n{\n\tu8 rfe_type = rtwdev->efuse.rfe_type;\n\n\tif (rfe_type > 50)\n\t\treturn;\n\n\tif (rfe_type % 3 == 2) {\n\t\trtw8851b_set_bb_gpio(rtwdev, 16, true, RFE_SEL0_SRC_ANTSEL_0);\n\t\trtw8851b_set_bb_gpio(rtwdev, 17, false, RFE_SEL0_SRC_ANTSEL_0);\n\n\t\trtw8851b_set_mac_gpio(rtwdev, 16);\n\t\trtw8851b_set_mac_gpio(rtwdev, 17);\n\t}\n}\n\nstatic void rtw8851b_power_trim(struct rtw89_dev *rtwdev)\n{\n\trtw8851b_thermal_trim(rtwdev);\n\trtw8851b_pa_bias_trim(rtwdev);\n}\n\nstatic void rtw8851b_set_channel_mac(struct rtw89_dev *rtwdev,\n\t\t\t\t     const struct rtw89_chan *chan,\n\t\t\t\t     u8 mac_idx)\n{\n\tu32 sub_carr = rtw89_mac_reg_by_idx(rtwdev, R_AX_TX_SUB_CARRIER_VALUE, mac_idx);\n\tu32 chk_rate = rtw89_mac_reg_by_idx(rtwdev, R_AX_TXRATE_CHK, mac_idx);\n\tu32 rf_mod = rtw89_mac_reg_by_idx(rtwdev, R_AX_WMAC_RFMOD, mac_idx);\n\tu8 txsc20 = 0, txsc40 = 0;\n\n\tswitch (chan->band_width) {\n\tcase RTW89_CHANNEL_WIDTH_80:\n\t\ttxsc40 = rtw89_phy_get_txsc(rtwdev, chan, RTW89_CHANNEL_WIDTH_40);\n\t\tfallthrough;\n\tcase RTW89_CHANNEL_WIDTH_40:\n\t\ttxsc20 = rtw89_phy_get_txsc(rtwdev, chan, RTW89_CHANNEL_WIDTH_20);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (chan->band_width) {\n\tcase RTW89_CHANNEL_WIDTH_80:\n\t\trtw89_write8_mask(rtwdev, rf_mod, B_AX_WMAC_RFMOD_MASK, BIT(1));\n\t\trtw89_write32(rtwdev, sub_carr, txsc20 | (txsc40 << 4));\n\t\tbreak;\n\tcase RTW89_CHANNEL_WIDTH_40:\n\t\trtw89_write8_mask(rtwdev, rf_mod, B_AX_WMAC_RFMOD_MASK, BIT(0));\n\t\trtw89_write32(rtwdev, sub_carr, txsc20);\n\t\tbreak;\n\tcase RTW89_CHANNEL_WIDTH_20:\n\t\trtw89_write8_clr(rtwdev, rf_mod, B_AX_WMAC_RFMOD_MASK);\n\t\trtw89_write32(rtwdev, sub_carr, 0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (chan->channel > 14) {\n\t\trtw89_write8_clr(rtwdev, chk_rate, B_AX_BAND_MODE);\n\t\trtw89_write8_set(rtwdev, chk_rate,\n\t\t\t\t B_AX_CHECK_CCK_EN | B_AX_RTS_LIMIT_IN_OFDM6);\n\t} else {\n\t\trtw89_write8_set(rtwdev, chk_rate, B_AX_BAND_MODE);\n\t\trtw89_write8_clr(rtwdev, chk_rate,\n\t\t\t\t B_AX_CHECK_CCK_EN | B_AX_RTS_LIMIT_IN_OFDM6);\n\t}\n}\n\nstatic const u32 rtw8851b_sco_barker_threshold[14] = {\n\t0x1cfea, 0x1d0e1, 0x1d1d7, 0x1d2cd, 0x1d3c3, 0x1d4b9, 0x1d5b0, 0x1d6a6,\n\t0x1d79c, 0x1d892, 0x1d988, 0x1da7f, 0x1db75, 0x1ddc4\n};\n\nstatic const u32 rtw8851b_sco_cck_threshold[14] = {\n\t0x27de3, 0x27f35, 0x28088, 0x281da, 0x2832d, 0x2847f, 0x285d2, 0x28724,\n\t0x28877, 0x289c9, 0x28b1c, 0x28c6e, 0x28dc1, 0x290ed\n};\n\nstatic void rtw8851b_ctrl_sco_cck(struct rtw89_dev *rtwdev, u8 primary_ch)\n{\n\tu8 ch_element = primary_ch - 1;\n\n\trtw89_phy_write32_mask(rtwdev, R_RXSCOBC, B_RXSCOBC_TH,\n\t\t\t       rtw8851b_sco_barker_threshold[ch_element]);\n\trtw89_phy_write32_mask(rtwdev, R_RXSCOCCK, B_RXSCOCCK_TH,\n\t\t\t       rtw8851b_sco_cck_threshold[ch_element]);\n}\n\nstatic u8 rtw8851b_sco_mapping(u8 central_ch)\n{\n\tif (central_ch == 1)\n\t\treturn 109;\n\telse if (central_ch >= 2 && central_ch <= 6)\n\t\treturn 108;\n\telse if (central_ch >= 7 && central_ch <= 10)\n\t\treturn 107;\n\telse if (central_ch >= 11 && central_ch <= 14)\n\t\treturn 106;\n\telse if (central_ch == 36 || central_ch == 38)\n\t\treturn 51;\n\telse if (central_ch >= 40 && central_ch <= 58)\n\t\treturn 50;\n\telse if (central_ch >= 60 && central_ch <= 64)\n\t\treturn 49;\n\telse if (central_ch == 100 || central_ch == 102)\n\t\treturn 48;\n\telse if (central_ch >= 104 && central_ch <= 126)\n\t\treturn 47;\n\telse if (central_ch >= 128 && central_ch <= 151)\n\t\treturn 46;\n\telse if (central_ch >= 153 && central_ch <= 177)\n\t\treturn 45;\n\telse\n\t\treturn 0;\n}\n\nstruct rtw8851b_bb_gain {\n\tu32 gain_g[BB_PATH_NUM_8851B];\n\tu32 gain_a[BB_PATH_NUM_8851B];\n\tu32 gain_mask;\n};\n\nstatic const struct rtw8851b_bb_gain bb_gain_lna[LNA_GAIN_NUM] = {\n\t{ .gain_g = {0x4678}, .gain_a = {0x45DC},\n\t  .gain_mask = 0x00ff0000 },\n\t{ .gain_g = {0x4678}, .gain_a = {0x45DC},\n\t  .gain_mask = 0xff000000 },\n\t{ .gain_g = {0x467C}, .gain_a = {0x4660},\n\t  .gain_mask = 0x000000ff },\n\t{ .gain_g = {0x467C}, .gain_a = {0x4660},\n\t  .gain_mask = 0x0000ff00 },\n\t{ .gain_g = {0x467C}, .gain_a = {0x4660},\n\t  .gain_mask = 0x00ff0000 },\n\t{ .gain_g = {0x467C}, .gain_a = {0x4660},\n\t  .gain_mask = 0xff000000 },\n\t{ .gain_g = {0x4680}, .gain_a = {0x4664},\n\t  .gain_mask = 0x000000ff },\n};\n\nstatic const struct rtw8851b_bb_gain bb_gain_tia[TIA_GAIN_NUM] = {\n\t{ .gain_g = {0x4680}, .gain_a = {0x4664},\n\t  .gain_mask = 0x00ff0000 },\n\t{ .gain_g = {0x4680}, .gain_a = {0x4664},\n\t  .gain_mask = 0xff000000 },\n};\n\nstatic void rtw8851b_set_gain_error(struct rtw89_dev *rtwdev,\n\t\t\t\t    enum rtw89_subband subband,\n\t\t\t\t    enum rtw89_rf_path path)\n{\n\tconst struct rtw89_phy_bb_gain_info *gain = &rtwdev->bb_gain;\n\tu8 gain_band = rtw89_subband_to_bb_gain_band(subband);\n\ts32 val;\n\tu32 reg;\n\tu32 mask;\n\tint i;\n\n\tfor (i = 0; i < LNA_GAIN_NUM; i++) {\n\t\tif (subband == RTW89_CH_2G)\n\t\t\treg = bb_gain_lna[i].gain_g[path];\n\t\telse\n\t\t\treg = bb_gain_lna[i].gain_a[path];\n\n\t\tmask = bb_gain_lna[i].gain_mask;\n\t\tval = gain->lna_gain[gain_band][path][i];\n\t\trtw89_phy_write32_mask(rtwdev, reg, mask, val);\n\t}\n\n\tfor (i = 0; i < TIA_GAIN_NUM; i++) {\n\t\tif (subband == RTW89_CH_2G)\n\t\t\treg = bb_gain_tia[i].gain_g[path];\n\t\telse\n\t\t\treg = bb_gain_tia[i].gain_a[path];\n\n\t\tmask = bb_gain_tia[i].gain_mask;\n\t\tval = gain->tia_gain[gain_band][path][i];\n\t\trtw89_phy_write32_mask(rtwdev, reg, mask, val);\n\t}\n}\n\nstatic void rtw8851b_set_gain_offset(struct rtw89_dev *rtwdev,\n\t\t\t\t     enum rtw89_subband subband,\n\t\t\t\t     enum rtw89_phy_idx phy_idx)\n{\n\tstatic const u32 rssi_ofst_addr[] = {R_PATH0_G_TIA1_LNA6_OP1DB_V1};\n\tstatic const u32 gain_err_addr[] = {R_P0_AGC_RSVD};\n\tstruct rtw89_phy_efuse_gain *efuse_gain = &rtwdev->efuse_gain;\n\tenum rtw89_gain_offset gain_ofdm_band;\n\ts32 offset_ofdm, offset_cck;\n\ts32 offset_a;\n\ts32 tmp;\n\tu8 path;\n\n\tif (!efuse_gain->comp_valid)\n\t\tgoto next;\n\n\tfor (path = RF_PATH_A; path < BB_PATH_NUM_8851B; path++) {\n\t\ttmp = efuse_gain->comp[path][subband];\n\t\ttmp = clamp_t(s32, tmp << 2, S8_MIN, S8_MAX);\n\t\trtw89_phy_write32_mask(rtwdev, gain_err_addr[path], MASKBYTE0, tmp);\n\t}\n\nnext:\n\tif (!efuse_gain->offset_valid)\n\t\treturn;\n\n\tgain_ofdm_band = rtw89_subband_to_gain_offset_band_of_ofdm(subband);\n\n\toffset_a = -efuse_gain->offset[RF_PATH_A][gain_ofdm_band];\n\n\ttmp = -((offset_a << 2) + (efuse_gain->offset_base[RTW89_PHY_0] >> 2));\n\ttmp = clamp_t(s32, tmp, S8_MIN, S8_MAX);\n\trtw89_phy_write32_mask(rtwdev, rssi_ofst_addr[RF_PATH_A], B_PATH0_R_G_OFST_MASK, tmp);\n\n\toffset_ofdm = -efuse_gain->offset[RF_PATH_A][gain_ofdm_band];\n\toffset_cck = -efuse_gain->offset[RF_PATH_A][0];\n\n\ttmp = (offset_ofdm << 4) + efuse_gain->offset_base[RTW89_PHY_0];\n\ttmp = clamp_t(s32, tmp, S8_MIN, S8_MAX);\n\trtw89_phy_write32_idx(rtwdev, R_P0_RPL1, B_P0_RPL1_BIAS_MASK, tmp, phy_idx);\n\n\ttmp = (offset_ofdm << 4) + efuse_gain->rssi_base[RTW89_PHY_0];\n\ttmp = clamp_t(s32, tmp, S8_MIN, S8_MAX);\n\trtw89_phy_write32_idx(rtwdev, R_P1_RPL1, B_P0_RPL1_BIAS_MASK, tmp, phy_idx);\n\n\tif (subband == RTW89_CH_2G) {\n\t\ttmp = (offset_cck << 3) + (efuse_gain->offset_base[RTW89_PHY_0] >> 1);\n\t\ttmp = clamp_t(s32, tmp, S8_MIN >> 1, S8_MAX >> 1);\n\t\trtw89_phy_write32_mask(rtwdev, R_RX_RPL_OFST,\n\t\t\t\t       B_RX_RPL_OFST_CCK_MASK, tmp);\n\t}\n}\n\nstatic\nvoid rtw8851b_set_rxsc_rpl_comp(struct rtw89_dev *rtwdev, enum rtw89_subband subband)\n{\n\tconst struct rtw89_phy_bb_gain_info *gain = &rtwdev->bb_gain;\n\tu8 band = rtw89_subband_to_bb_gain_band(subband);\n\tu32 val;\n\n\tval = u32_encode_bits(gain->rpl_ofst_20[band][RF_PATH_A], B_P0_RPL1_20_MASK) |\n\t      u32_encode_bits(gain->rpl_ofst_40[band][RF_PATH_A][0], B_P0_RPL1_40_MASK) |\n\t      u32_encode_bits(gain->rpl_ofst_40[band][RF_PATH_A][1], B_P0_RPL1_41_MASK);\n\tval >>= B_P0_RPL1_SHIFT;\n\trtw89_phy_write32_mask(rtwdev, R_P0_RPL1, B_P0_RPL1_MASK, val);\n\trtw89_phy_write32_mask(rtwdev, R_P1_RPL1, B_P0_RPL1_MASK, val);\n\n\tval = u32_encode_bits(gain->rpl_ofst_40[band][RF_PATH_A][2], B_P0_RTL2_42_MASK) |\n\t      u32_encode_bits(gain->rpl_ofst_80[band][RF_PATH_A][0], B_P0_RTL2_80_MASK) |\n\t      u32_encode_bits(gain->rpl_ofst_80[band][RF_PATH_A][1], B_P0_RTL2_81_MASK) |\n\t      u32_encode_bits(gain->rpl_ofst_80[band][RF_PATH_A][10], B_P0_RTL2_8A_MASK);\n\trtw89_phy_write32(rtwdev, R_P0_RPL2, val);\n\trtw89_phy_write32(rtwdev, R_P1_RPL2, val);\n\n\tval = u32_encode_bits(gain->rpl_ofst_80[band][RF_PATH_A][2], B_P0_RTL3_82_MASK) |\n\t      u32_encode_bits(gain->rpl_ofst_80[band][RF_PATH_A][3], B_P0_RTL3_83_MASK) |\n\t      u32_encode_bits(gain->rpl_ofst_80[band][RF_PATH_A][4], B_P0_RTL3_84_MASK) |\n\t      u32_encode_bits(gain->rpl_ofst_80[band][RF_PATH_A][9], B_P0_RTL3_89_MASK);\n\trtw89_phy_write32(rtwdev, R_P0_RPL3, val);\n\trtw89_phy_write32(rtwdev, R_P1_RPL3, val);\n}\n\nstatic void rtw8851b_ctrl_ch(struct rtw89_dev *rtwdev,\n\t\t\t     const struct rtw89_chan *chan,\n\t\t\t     enum rtw89_phy_idx phy_idx)\n{\n\tu8 subband = chan->subband_type;\n\tu8 central_ch = chan->channel;\n\tbool is_2g = central_ch <= 14;\n\tu8 sco_comp;\n\n\tif (is_2g)\n\t\trtw89_phy_write32_idx(rtwdev, R_PATH0_BAND_SEL_V1,\n\t\t\t\t      B_PATH0_BAND_SEL_MSK_V1, 1, phy_idx);\n\telse\n\t\trtw89_phy_write32_idx(rtwdev, R_PATH0_BAND_SEL_V1,\n\t\t\t\t      B_PATH0_BAND_SEL_MSK_V1, 0, phy_idx);\n\t \n\tsco_comp = rtw8851b_sco_mapping(central_ch);\n\trtw89_phy_write32_idx(rtwdev, R_FC0_BW_V1, B_FC0_BW_INV, sco_comp, phy_idx);\n\n\tif (chan->band_type == RTW89_BAND_6G)\n\t\treturn;\n\n\t \n\tif (central_ch == 14) {\n\t\trtw89_phy_write32_mask(rtwdev, R_TXFIR0, B_TXFIR_C01, 0x3b13ff);\n\t\trtw89_phy_write32_mask(rtwdev, R_TXFIR2, B_TXFIR_C23, 0x1c42de);\n\t\trtw89_phy_write32_mask(rtwdev, R_TXFIR4, B_TXFIR_C45, 0xfdb0ad);\n\t\trtw89_phy_write32_mask(rtwdev, R_TXFIR6, B_TXFIR_C67, 0xf60f6e);\n\t\trtw89_phy_write32_mask(rtwdev, R_TXFIR8, B_TXFIR_C89, 0xfd8f92);\n\t\trtw89_phy_write32_mask(rtwdev, R_TXFIRA, B_TXFIR_CAB, 0x2d011);\n\t\trtw89_phy_write32_mask(rtwdev, R_TXFIRC, B_TXFIR_CCD, 0x1c02c);\n\t\trtw89_phy_write32_mask(rtwdev, R_TXFIRE, B_TXFIR_CEF, 0xfff00a);\n\t} else {\n\t\trtw89_phy_write32_mask(rtwdev, R_TXFIR0, B_TXFIR_C01, 0x3d23ff);\n\t\trtw89_phy_write32_mask(rtwdev, R_TXFIR2, B_TXFIR_C23, 0x29b354);\n\t\trtw89_phy_write32_mask(rtwdev, R_TXFIR4, B_TXFIR_C45, 0xfc1c8);\n\t\trtw89_phy_write32_mask(rtwdev, R_TXFIR6, B_TXFIR_C67, 0xfdb053);\n\t\trtw89_phy_write32_mask(rtwdev, R_TXFIR8, B_TXFIR_C89, 0xf86f9a);\n\t\trtw89_phy_write32_mask(rtwdev, R_TXFIRA, B_TXFIR_CAB, 0xfaef92);\n\t\trtw89_phy_write32_mask(rtwdev, R_TXFIRC, B_TXFIR_CCD, 0xfe5fcc);\n\t\trtw89_phy_write32_mask(rtwdev, R_TXFIRE, B_TXFIR_CEF, 0xffdff5);\n\t}\n\n\trtw8851b_set_gain_error(rtwdev, subband, RF_PATH_A);\n\trtw8851b_set_gain_offset(rtwdev, subband, phy_idx);\n\trtw8851b_set_rxsc_rpl_comp(rtwdev, subband);\n}\n\nstatic void rtw8851b_bw_setting(struct rtw89_dev *rtwdev, u8 bw)\n{\n\trtw89_phy_write32_mask(rtwdev, R_P0_CFCH_BW0, B_P0_CFCH_CTL, 0x8);\n\trtw89_phy_write32_mask(rtwdev, R_P0_CFCH_BW0, B_P0_CFCH_EN, 0x2);\n\trtw89_phy_write32_mask(rtwdev, R_P0_CFCH_BW0, B_P0_CFCH_BW0, 0x2);\n\trtw89_phy_write32_mask(rtwdev, R_P0_CFCH_BW1, B_P0_CFCH_BW1, 0x4);\n\trtw89_phy_write32_mask(rtwdev, R_DRCK, B_DRCK_MUL, 0xf);\n\trtw89_phy_write32_mask(rtwdev, R_ADCMOD, B_ADCMOD_LP, 0xa);\n\trtw89_phy_write32_mask(rtwdev, R_P0_RXCK, B_P0_RXCK_ADJ, 0x92);\n\n\tswitch (bw) {\n\tcase RTW89_CHANNEL_WIDTH_5:\n\t\trtw89_phy_write32_mask(rtwdev, R_DCIM, B_DCIM_FR, 0x1);\n\t\trtw89_phy_write32_mask(rtwdev, R_WDADC, B_WDADC_SEL, 0x0);\n\t\trtw89_phy_write32_mask(rtwdev, R_ADDCK0D, B_ADDCK_DS, 0x1);\n\t\tbreak;\n\tcase RTW89_CHANNEL_WIDTH_10:\n\t\trtw89_phy_write32_mask(rtwdev, R_DCIM, B_DCIM_FR, 0x1);\n\t\trtw89_phy_write32_mask(rtwdev, R_WDADC, B_WDADC_SEL, 0x1);\n\t\trtw89_phy_write32_mask(rtwdev, R_ADDCK0D, B_ADDCK_DS, 0x0);\n\t\tbreak;\n\tcase RTW89_CHANNEL_WIDTH_20:\n\t\trtw89_phy_write32_mask(rtwdev, R_DCIM, B_DCIM_FR, 0x2);\n\t\trtw89_phy_write32_mask(rtwdev, R_WDADC, B_WDADC_SEL, 0x2);\n\t\trtw89_phy_write32_mask(rtwdev, R_ADDCK0D, B_ADDCK_DS, 0x0);\n\t\tbreak;\n\tcase RTW89_CHANNEL_WIDTH_40:\n\t\trtw89_phy_write32_mask(rtwdev, R_DCIM, B_DCIM_FR, 0x2);\n\t\trtw89_phy_write32_mask(rtwdev, R_WDADC, B_WDADC_SEL, 0x2);\n\t\trtw89_phy_write32_mask(rtwdev, R_ADDCK0D, B_ADDCK_DS, 0x0);\n\t\tbreak;\n\tcase RTW89_CHANNEL_WIDTH_80:\n\t\trtw89_phy_write32_mask(rtwdev, R_DCIM, B_DCIM_FR, 0x0);\n\t\trtw89_phy_write32_mask(rtwdev, R_WDADC, B_WDADC_SEL, 0x2);\n\t\trtw89_phy_write32_mask(rtwdev, R_ADDCK0D, B_ADDCK_DS, 0x0);\n\t\tbreak;\n\tdefault:\n\t\trtw89_warn(rtwdev, \"Fail to set ADC\\n\");\n\t}\n}\n\nstatic void rtw8851b_ctrl_bw(struct rtw89_dev *rtwdev, u8 pri_ch, u8 bw,\n\t\t\t     enum rtw89_phy_idx phy_idx)\n{\n\tswitch (bw) {\n\tcase RTW89_CHANNEL_WIDTH_5:\n\t\trtw89_phy_write32_idx(rtwdev, R_FC0_BW_V1, B_FC0_BW_SET, 0x0, phy_idx);\n\t\trtw89_phy_write32_idx(rtwdev, R_CHBW_MOD_V1, B_CHBW_MOD_SBW, 0x1, phy_idx);\n\t\trtw89_phy_write32_idx(rtwdev, R_CHBW_MOD_V1, B_CHBW_MOD_PRICH, 0x0, phy_idx);\n\t\tbreak;\n\tcase RTW89_CHANNEL_WIDTH_10:\n\t\trtw89_phy_write32_idx(rtwdev, R_FC0_BW_V1, B_FC0_BW_SET, 0x0, phy_idx);\n\t\trtw89_phy_write32_idx(rtwdev, R_CHBW_MOD_V1, B_CHBW_MOD_SBW, 0x2, phy_idx);\n\t\trtw89_phy_write32_idx(rtwdev, R_CHBW_MOD_V1, B_CHBW_MOD_PRICH, 0x0, phy_idx);\n\t\tbreak;\n\tcase RTW89_CHANNEL_WIDTH_20:\n\t\trtw89_phy_write32_idx(rtwdev, R_FC0_BW_V1, B_FC0_BW_SET, 0x0, phy_idx);\n\t\trtw89_phy_write32_idx(rtwdev, R_CHBW_MOD_V1, B_CHBW_MOD_SBW, 0x0, phy_idx);\n\t\trtw89_phy_write32_idx(rtwdev, R_CHBW_MOD_V1, B_CHBW_MOD_PRICH, 0x0, phy_idx);\n\t\tbreak;\n\tcase RTW89_CHANNEL_WIDTH_40:\n\t\trtw89_phy_write32_idx(rtwdev, R_FC0_BW_V1, B_FC0_BW_SET, 0x1, phy_idx);\n\t\trtw89_phy_write32_idx(rtwdev, R_CHBW_MOD_V1, B_CHBW_MOD_SBW, 0x0, phy_idx);\n\t\trtw89_phy_write32_idx(rtwdev, R_CHBW_MOD_V1, B_CHBW_MOD_PRICH,\n\t\t\t\t      pri_ch, phy_idx);\n\t\t \n\t\tif (pri_ch == RTW89_SC_20_UPPER)\n\t\t\trtw89_phy_write32_mask(rtwdev, R_RXSC, B_RXSC_EN, 1);\n\t\telse\n\t\t\trtw89_phy_write32_mask(rtwdev, R_RXSC, B_RXSC_EN, 0);\n\n\t\tbreak;\n\tcase RTW89_CHANNEL_WIDTH_80:\n\t\trtw89_phy_write32_idx(rtwdev, R_FC0_BW_V1, B_FC0_BW_SET, 0x2, phy_idx);\n\t\trtw89_phy_write32_idx(rtwdev, R_CHBW_MOD_V1, B_CHBW_MOD_SBW, 0x0, phy_idx);\n\t\trtw89_phy_write32_idx(rtwdev, R_CHBW_MOD_V1, B_CHBW_MOD_PRICH,\n\t\t\t\t      pri_ch, phy_idx);\n\t\tbreak;\n\tdefault:\n\t\trtw89_warn(rtwdev, \"Fail to switch bw (bw:%d, pri ch:%d)\\n\", bw,\n\t\t\t   pri_ch);\n\t}\n\n\trtw8851b_bw_setting(rtwdev, bw);\n}\n\nstatic void rtw8851b_ctrl_cck_en(struct rtw89_dev *rtwdev, bool cck_en)\n{\n\tif (cck_en) {\n\t\trtw89_phy_write32_mask(rtwdev, R_RXCCA, B_RXCCA_DIS, 0);\n\t\trtw89_phy_write32_mask(rtwdev, R_PD_ARBITER_OFF,\n\t\t\t\t       B_PD_ARBITER_OFF, 0);\n\t\trtw89_phy_write32_mask(rtwdev, R_UPD_CLK_ADC, B_ENABLE_CCK, 1);\n\t} else {\n\t\trtw89_phy_write32_mask(rtwdev, R_RXCCA, B_RXCCA_DIS, 1);\n\t\trtw89_phy_write32_mask(rtwdev, R_PD_ARBITER_OFF,\n\t\t\t\t       B_PD_ARBITER_OFF, 1);\n\t\trtw89_phy_write32_mask(rtwdev, R_UPD_CLK_ADC, B_ENABLE_CCK, 0);\n\t}\n}\n\nstatic u32 rtw8851b_spur_freq(struct rtw89_dev *rtwdev,\n\t\t\t      const struct rtw89_chan *chan)\n{\n\tu8 center_chan = chan->channel;\n\n\tswitch (chan->band_type) {\n\tcase RTW89_BAND_5G:\n\t\tif (center_chan == 151 || center_chan == 153 ||\n\t\t    center_chan == 155 || center_chan == 163)\n\t\t\treturn 5760;\n\t\telse if (center_chan == 54 || center_chan == 58)\n\t\t\treturn 5280;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n#define CARRIER_SPACING_312_5 312500  \n#define CARRIER_SPACING_78_125 78125  \n#define MAX_TONE_NUM 2048\n\nstatic void rtw8851b_set_csi_tone_idx(struct rtw89_dev *rtwdev,\n\t\t\t\t      const struct rtw89_chan *chan,\n\t\t\t\t      enum rtw89_phy_idx phy_idx)\n{\n\tu32 spur_freq;\n\ts32 freq_diff, csi_idx, csi_tone_idx;\n\n\tspur_freq = rtw8851b_spur_freq(rtwdev, chan);\n\tif (spur_freq == 0) {\n\t\trtw89_phy_write32_idx(rtwdev, R_SEG0CSI_EN_V1, B_SEG0CSI_EN,\n\t\t\t\t      0, phy_idx);\n\t\treturn;\n\t}\n\n\tfreq_diff = (spur_freq - chan->freq) * 1000000;\n\tcsi_idx = s32_div_u32_round_closest(freq_diff, CARRIER_SPACING_78_125);\n\ts32_div_u32_round_down(csi_idx, MAX_TONE_NUM, &csi_tone_idx);\n\n\trtw89_phy_write32_idx(rtwdev, R_SEG0CSI_V1, B_SEG0CSI_IDX,\n\t\t\t      csi_tone_idx, phy_idx);\n\trtw89_phy_write32_idx(rtwdev, R_SEG0CSI_EN_V1, B_SEG0CSI_EN, 1, phy_idx);\n}\n\nstatic const struct rtw89_nbi_reg_def rtw8851b_nbi_reg_def = {\n\t.notch1_idx = {0x46E4, 0xFF},\n\t.notch1_frac_idx = {0x46E4, 0xC00},\n\t.notch1_en = {0x46E4, 0x1000},\n\t.notch2_idx = {0x47A4, 0xFF},\n\t.notch2_frac_idx = {0x47A4, 0xC00},\n\t.notch2_en = {0x47A4, 0x1000},\n};\n\nstatic void rtw8851b_set_nbi_tone_idx(struct rtw89_dev *rtwdev,\n\t\t\t\t      const struct rtw89_chan *chan)\n{\n\tconst struct rtw89_nbi_reg_def *nbi = &rtw8851b_nbi_reg_def;\n\ts32 nbi_frac_idx, nbi_frac_tone_idx;\n\ts32 nbi_idx, nbi_tone_idx;\n\tbool notch2_chk = false;\n\tu32 spur_freq, fc;\n\ts32 freq_diff;\n\n\tspur_freq = rtw8851b_spur_freq(rtwdev, chan);\n\tif (spur_freq == 0) {\n\t\trtw89_phy_write32_mask(rtwdev, nbi->notch1_en.addr,\n\t\t\t\t       nbi->notch1_en.mask, 0);\n\t\trtw89_phy_write32_mask(rtwdev, nbi->notch2_en.addr,\n\t\t\t\t       nbi->notch2_en.mask, 0);\n\t\treturn;\n\t}\n\n\tfc = chan->freq;\n\tif (chan->band_width == RTW89_CHANNEL_WIDTH_160) {\n\t\tfc = (spur_freq > fc) ? fc + 40 : fc - 40;\n\t\tif ((fc > spur_freq &&\n\t\t     chan->channel < chan->primary_channel) ||\n\t\t    (fc < spur_freq &&\n\t\t     chan->channel > chan->primary_channel))\n\t\t\tnotch2_chk = true;\n\t}\n\n\tfreq_diff = (spur_freq - fc) * 1000000;\n\tnbi_idx = s32_div_u32_round_down(freq_diff, CARRIER_SPACING_312_5,\n\t\t\t\t\t &nbi_frac_idx);\n\n\tif (chan->band_width == RTW89_CHANNEL_WIDTH_20) {\n\t\ts32_div_u32_round_down(nbi_idx + 32, 64, &nbi_tone_idx);\n\t} else {\n\t\tu16 tone_para = (chan->band_width == RTW89_CHANNEL_WIDTH_40) ?\n\t\t\t\t128 : 256;\n\n\t\ts32_div_u32_round_down(nbi_idx, tone_para, &nbi_tone_idx);\n\t}\n\tnbi_frac_tone_idx = s32_div_u32_round_closest(nbi_frac_idx,\n\t\t\t\t\t\t      CARRIER_SPACING_78_125);\n\n\tif (chan->band_width == RTW89_CHANNEL_WIDTH_160 && notch2_chk) {\n\t\trtw89_phy_write32_mask(rtwdev, nbi->notch2_idx.addr,\n\t\t\t\t       nbi->notch2_idx.mask, nbi_tone_idx);\n\t\trtw89_phy_write32_mask(rtwdev, nbi->notch2_frac_idx.addr,\n\t\t\t\t       nbi->notch2_frac_idx.mask, nbi_frac_tone_idx);\n\t\trtw89_phy_write32_mask(rtwdev, nbi->notch2_en.addr,\n\t\t\t\t       nbi->notch2_en.mask, 0);\n\t\trtw89_phy_write32_mask(rtwdev, nbi->notch2_en.addr,\n\t\t\t\t       nbi->notch2_en.mask, 1);\n\t\trtw89_phy_write32_mask(rtwdev, nbi->notch1_en.addr,\n\t\t\t\t       nbi->notch1_en.mask, 0);\n\t} else {\n\t\trtw89_phy_write32_mask(rtwdev, nbi->notch1_idx.addr,\n\t\t\t\t       nbi->notch1_idx.mask, nbi_tone_idx);\n\t\trtw89_phy_write32_mask(rtwdev, nbi->notch1_frac_idx.addr,\n\t\t\t\t       nbi->notch1_frac_idx.mask, nbi_frac_tone_idx);\n\t\trtw89_phy_write32_mask(rtwdev, nbi->notch1_en.addr,\n\t\t\t\t       nbi->notch1_en.mask, 0);\n\t\trtw89_phy_write32_mask(rtwdev, nbi->notch1_en.addr,\n\t\t\t\t       nbi->notch1_en.mask, 1);\n\t\trtw89_phy_write32_mask(rtwdev, nbi->notch2_en.addr,\n\t\t\t\t       nbi->notch2_en.mask, 0);\n\t}\n}\n\nstatic void rtw8851b_set_cfr(struct rtw89_dev *rtwdev, const struct rtw89_chan *chan)\n{\n\tif (chan->band_type == RTW89_BAND_2G &&\n\t    chan->band_width == RTW89_CHANNEL_WIDTH_20 &&\n\t    (chan->channel == 1 || chan->channel == 13)) {\n\t\trtw89_phy_write32_mask(rtwdev, R_PATH0_TX_CFR,\n\t\t\t\t       B_PATH0_TX_CFR_LGC0, 0xf8);\n\t\trtw89_phy_write32_mask(rtwdev, R_PATH0_TX_CFR,\n\t\t\t\t       B_PATH0_TX_CFR_LGC1, 0x120);\n\t\trtw89_phy_write32_mask(rtwdev, R_PATH0_TX_POLAR_CLIPPING,\n\t\t\t\t       B_PATH0_TX_POLAR_CLIPPING_LGC0, 0x0);\n\t\trtw89_phy_write32_mask(rtwdev, R_PATH0_TX_POLAR_CLIPPING,\n\t\t\t\t       B_PATH0_TX_POLAR_CLIPPING_LGC1, 0x3);\n\t} else {\n\t\trtw89_phy_write32_mask(rtwdev, R_PATH0_TX_CFR,\n\t\t\t\t       B_PATH0_TX_CFR_LGC0, 0x120);\n\t\trtw89_phy_write32_mask(rtwdev, R_PATH0_TX_CFR,\n\t\t\t\t       B_PATH0_TX_CFR_LGC1, 0x3ff);\n\t\trtw89_phy_write32_mask(rtwdev, R_PATH0_TX_POLAR_CLIPPING,\n\t\t\t\t       B_PATH0_TX_POLAR_CLIPPING_LGC0, 0x3);\n\t\trtw89_phy_write32_mask(rtwdev, R_PATH0_TX_POLAR_CLIPPING,\n\t\t\t\t       B_PATH0_TX_POLAR_CLIPPING_LGC1, 0x7);\n\t}\n}\n\nstatic void rtw8851b_5m_mask(struct rtw89_dev *rtwdev, const struct rtw89_chan *chan,\n\t\t\t     enum rtw89_phy_idx phy_idx)\n{\n\tu8 pri_ch = chan->pri_ch_idx;\n\tbool mask_5m_low;\n\tbool mask_5m_en;\n\n\tswitch (chan->band_width) {\n\tcase RTW89_CHANNEL_WIDTH_40:\n\t\t \n\t\tmask_5m_en = true;\n\t\tmask_5m_low = pri_ch == RTW89_SC_20_LOWER;\n\t\tbreak;\n\tcase RTW89_CHANNEL_WIDTH_80:\n\t\t \n\t\tmask_5m_en = pri_ch == RTW89_SC_20_UPMOST ||\n\t\t\t     pri_ch == RTW89_SC_20_LOWEST;\n\t\tmask_5m_low = pri_ch == RTW89_SC_20_LOWEST;\n\t\tbreak;\n\tdefault:\n\t\tmask_5m_en = false;\n\t\tbreak;\n\t}\n\n\tif (!mask_5m_en) {\n\t\trtw89_phy_write32_mask(rtwdev, R_PATH0_5MDET_V1, B_PATH0_5MDET_EN, 0x0);\n\t\trtw89_phy_write32_idx(rtwdev, R_ASSIGN_SBD_OPT_V1,\n\t\t\t\t      B_ASSIGN_SBD_OPT_EN_V1, 0x0, phy_idx);\n\t\treturn;\n\t}\n\n\tif (mask_5m_low) {\n\t\trtw89_phy_write32_mask(rtwdev, R_PATH0_5MDET_V1, B_PATH0_5MDET_TH, 0x5);\n\t\trtw89_phy_write32_mask(rtwdev, R_PATH0_5MDET_V1, B_PATH0_5MDET_EN, 0x1);\n\t\trtw89_phy_write32_mask(rtwdev, R_PATH0_5MDET_V1, B_PATH0_5MDET_SB2, 0x0);\n\t\trtw89_phy_write32_mask(rtwdev, R_PATH0_5MDET_V1, B_PATH0_5MDET_SB0, 0x1);\n\t} else {\n\t\trtw89_phy_write32_mask(rtwdev, R_PATH0_5MDET_V1, B_PATH0_5MDET_TH, 0x5);\n\t\trtw89_phy_write32_mask(rtwdev, R_PATH0_5MDET_V1, B_PATH0_5MDET_EN, 0x1);\n\t\trtw89_phy_write32_mask(rtwdev, R_PATH0_5MDET_V1, B_PATH0_5MDET_SB2, 0x1);\n\t\trtw89_phy_write32_mask(rtwdev, R_PATH0_5MDET_V1, B_PATH0_5MDET_SB0, 0x0);\n\t}\n\trtw89_phy_write32_idx(rtwdev, R_ASSIGN_SBD_OPT_V1,\n\t\t\t      B_ASSIGN_SBD_OPT_EN_V1, 0x1, phy_idx);\n}\n\nstatic void rtw8851b_bb_reset_all(struct rtw89_dev *rtwdev, enum rtw89_phy_idx phy_idx)\n{\n\trtw89_phy_write32_idx(rtwdev, R_S0_HW_SI_DIS, B_S0_HW_SI_DIS_W_R_TRIG, 0x7, phy_idx);\n\tfsleep(1);\n\trtw89_phy_write32_idx(rtwdev, R_RSTB_ASYNC, B_RSTB_ASYNC_ALL, 1, phy_idx);\n\trtw89_phy_write32_idx(rtwdev, R_RSTB_ASYNC, B_RSTB_ASYNC_ALL, 0, phy_idx);\n\trtw89_phy_write32_idx(rtwdev, R_S0_HW_SI_DIS, B_S0_HW_SI_DIS_W_R_TRIG, 0x0, phy_idx);\n\trtw89_phy_write32_idx(rtwdev, R_RSTB_ASYNC, B_RSTB_ASYNC_ALL, 1, phy_idx);\n}\n\nstatic void rtw8851b_bb_reset_en(struct rtw89_dev *rtwdev, enum rtw89_band band,\n\t\t\t\t enum rtw89_phy_idx phy_idx, bool en)\n{\n\tif (en) {\n\t\trtw89_phy_write32_idx(rtwdev, R_S0_HW_SI_DIS,\n\t\t\t\t      B_S0_HW_SI_DIS_W_R_TRIG, 0x0, phy_idx);\n\t\trtw89_phy_write32_idx(rtwdev, R_RSTB_ASYNC, B_RSTB_ASYNC_ALL, 1, phy_idx);\n\t\tif (band == RTW89_BAND_2G)\n\t\t\trtw89_phy_write32_mask(rtwdev, R_RXCCA, B_RXCCA_DIS, 0x0);\n\t\trtw89_phy_write32_mask(rtwdev, R_PD_CTRL, B_PD_HIT_DIS, 0x0);\n\t} else {\n\t\trtw89_phy_write32_mask(rtwdev, R_RXCCA, B_RXCCA_DIS, 0x1);\n\t\trtw89_phy_write32_mask(rtwdev, R_PD_CTRL, B_PD_HIT_DIS, 0x1);\n\t\trtw89_phy_write32_idx(rtwdev, R_S0_HW_SI_DIS,\n\t\t\t\t      B_S0_HW_SI_DIS_W_R_TRIG, 0x7, phy_idx);\n\t\tfsleep(1);\n\t\trtw89_phy_write32_idx(rtwdev, R_RSTB_ASYNC, B_RSTB_ASYNC_ALL, 0, phy_idx);\n\t}\n}\n\nstatic void rtw8851b_bb_reset(struct rtw89_dev *rtwdev,\n\t\t\t      enum rtw89_phy_idx phy_idx)\n{\n\trtw89_phy_write32_mask(rtwdev, R_P0_TXPW_RSTB,\n\t\t\t       B_P0_TXPW_RSTB_MANON | B_P0_TXPW_RSTB_TSSI, 0x1);\n\trtw89_phy_write32_set(rtwdev, R_P0_TSSI_TRK, B_P0_TSSI_TRK_EN);\n\trtw8851b_bb_reset_all(rtwdev, phy_idx);\n\trtw89_phy_write32_mask(rtwdev, R_P0_TXPW_RSTB,\n\t\t\t       B_P0_TXPW_RSTB_MANON | B_P0_TXPW_RSTB_TSSI, 0x3);\n\trtw89_phy_write32_clr(rtwdev, R_P0_TSSI_TRK, B_P0_TSSI_TRK_EN);\n}\n\nstatic\nvoid rtw8851b_bb_gpio_trsw(struct rtw89_dev *rtwdev, enum rtw89_rf_path path,\n\t\t\t   u8 tx_path_en, u8 trsw_tx,\n\t\t\t   u8 trsw_rx, u8 trsw_a, u8 trsw_b)\n{\n\tu32 mask_ofst = 16;\n\tu32 val;\n\n\tif (path != RF_PATH_A)\n\t\treturn;\n\n\tmask_ofst += (tx_path_en * 4 + trsw_tx * 2 + trsw_rx) * 2;\n\tval = u32_encode_bits(trsw_a, B_P0_TRSW_A) |\n\t      u32_encode_bits(trsw_b, B_P0_TRSW_B);\n\n\trtw89_phy_write32_mask(rtwdev, R_P0_TRSW,\n\t\t\t       (B_P0_TRSW_A | B_P0_TRSW_B) << mask_ofst, val);\n}\n\nstatic void rtw8851b_bb_gpio_init(struct rtw89_dev *rtwdev)\n{\n\trtw89_phy_write32_set(rtwdev, R_P0_TRSW, B_P0_TRSW_A);\n\trtw89_phy_write32_clr(rtwdev, R_P0_TRSW, B_P0_TRSW_X);\n\trtw89_phy_write32_clr(rtwdev, R_P0_TRSW, B_P0_TRSW_SO_A2);\n\trtw89_phy_write32(rtwdev, R_RFE_SEL0_BASE, 0x77777777);\n\trtw89_phy_write32(rtwdev, R_RFE_SEL32_BASE, 0x77777777);\n\n\trtw89_phy_write32(rtwdev, R_RFE_E_A2, 0xffffffff);\n\trtw89_phy_write32(rtwdev, R_RFE_O_SEL_A2, 0);\n\trtw89_phy_write32(rtwdev, R_RFE_SEL0_A2, 0);\n\trtw89_phy_write32(rtwdev, R_RFE_SEL32_A2, 0);\n\n\trtw8851b_bb_gpio_trsw(rtwdev, RF_PATH_A, 0, 0, 0, 0, 1);\n\trtw8851b_bb_gpio_trsw(rtwdev, RF_PATH_A, 0, 0, 1, 1, 0);\n\trtw8851b_bb_gpio_trsw(rtwdev, RF_PATH_A, 0, 1, 0, 1, 0);\n\trtw8851b_bb_gpio_trsw(rtwdev, RF_PATH_A, 0, 1, 1, 1, 0);\n\trtw8851b_bb_gpio_trsw(rtwdev, RF_PATH_A, 1, 0, 0, 0, 1);\n\trtw8851b_bb_gpio_trsw(rtwdev, RF_PATH_A, 1, 0, 1, 1, 0);\n\trtw8851b_bb_gpio_trsw(rtwdev, RF_PATH_A, 1, 1, 0, 1, 0);\n\trtw8851b_bb_gpio_trsw(rtwdev, RF_PATH_A, 1, 1, 1, 1, 0);\n}\n\nstatic void rtw8851b_bb_macid_ctrl_init(struct rtw89_dev *rtwdev,\n\t\t\t\t\tenum rtw89_phy_idx phy_idx)\n{\n\tu32 addr;\n\n\tfor (addr = R_AX_PWR_MACID_LMT_TABLE0;\n\t     addr <= R_AX_PWR_MACID_LMT_TABLE127; addr += 4)\n\t\trtw89_mac_txpwr_write32(rtwdev, phy_idx, addr, 0);\n}\n\nstatic void rtw8851b_bb_sethw(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_phy_efuse_gain *gain = &rtwdev->efuse_gain;\n\n\trtw89_phy_write32_clr(rtwdev, R_P0_EN_SOUND_WO_NDP, B_P0_EN_SOUND_WO_NDP);\n\n\trtw8851b_bb_macid_ctrl_init(rtwdev, RTW89_PHY_0);\n\trtw8851b_bb_gpio_init(rtwdev);\n\n\trtw89_write32_clr(rtwdev, R_AX_PWR_NORM_FORCE1, B_AX_FORCE_NTX_VALUE);\n\trtw89_write32_set(rtwdev, R_AX_PWR_NORM_FORCE1, B_AX_FORCE_NTX_EN);\n\n\t \n\tgain->offset_base[RTW89_PHY_0] =\n\t\trtw89_phy_read32_mask(rtwdev, R_P0_RPL1, B_P0_RPL1_BIAS_MASK);\n\tgain->rssi_base[RTW89_PHY_0] =\n\t\trtw89_phy_read32_mask(rtwdev, R_P1_RPL1, B_P0_RPL1_BIAS_MASK);\n}\n\nstatic void rtw8851b_set_channel_bb(struct rtw89_dev *rtwdev, const struct rtw89_chan *chan,\n\t\t\t\t    enum rtw89_phy_idx phy_idx)\n{\n\tu8 band = chan->band_type, chan_idx;\n\tbool cck_en = chan->channel <= 14;\n\tu8 pri_ch_idx = chan->pri_ch_idx;\n\n\tif (cck_en)\n\t\trtw8851b_ctrl_sco_cck(rtwdev,  chan->primary_channel);\n\n\trtw8851b_ctrl_ch(rtwdev, chan, phy_idx);\n\trtw8851b_ctrl_bw(rtwdev, pri_ch_idx, chan->band_width, phy_idx);\n\trtw8851b_ctrl_cck_en(rtwdev, cck_en);\n\trtw8851b_set_nbi_tone_idx(rtwdev, chan);\n\trtw8851b_set_csi_tone_idx(rtwdev, chan, phy_idx);\n\n\tif (chan->band_type == RTW89_BAND_5G) {\n\t\trtw89_phy_write32_mask(rtwdev, R_PATH0_BT_SHARE_V1,\n\t\t\t\t       B_PATH0_BT_SHARE_V1, 0x0);\n\t\trtw89_phy_write32_mask(rtwdev, R_PATH0_BTG_PATH_V1,\n\t\t\t\t       B_PATH0_BTG_PATH_V1, 0x0);\n\t\trtw89_phy_write32_mask(rtwdev, R_CHBW_MOD_V1, B_BT_SHARE, 0x0);\n\t\trtw89_phy_write32_mask(rtwdev, R_FC0_BW_V1, B_ANT_RX_BT_SEG0, 0x0);\n\t\trtw89_phy_write32_mask(rtwdev, R_BT_DYN_DC_EST_EN_V1,\n\t\t\t\t       B_BT_DYN_DC_EST_EN_MSK, 0x0);\n\t\trtw89_phy_write32_mask(rtwdev, R_GNT_BT_WGT_EN, B_GNT_BT_WGT_EN, 0x0);\n\t}\n\n\tchan_idx = rtw89_encode_chan_idx(rtwdev, chan->primary_channel, band);\n\trtw89_phy_write32_mask(rtwdev, R_MAC_PIN_SEL, B_CH_IDX_SEG0, chan_idx);\n\trtw8851b_5m_mask(rtwdev, chan, phy_idx);\n\trtw8851b_set_cfr(rtwdev, chan);\n\trtw8851b_bb_reset_all(rtwdev, phy_idx);\n}\n\nstatic void rtw8851b_set_channel(struct rtw89_dev *rtwdev,\n\t\t\t\t const struct rtw89_chan *chan,\n\t\t\t\t enum rtw89_mac_idx mac_idx,\n\t\t\t\t enum rtw89_phy_idx phy_idx)\n{\n\trtw8851b_set_channel_mac(rtwdev, chan, mac_idx);\n\trtw8851b_set_channel_bb(rtwdev, chan, phy_idx);\n\trtw8851b_set_channel_rf(rtwdev, chan, phy_idx);\n}\n\nstatic void rtw8851b_tssi_cont_en(struct rtw89_dev *rtwdev, bool en,\n\t\t\t\t  enum rtw89_rf_path path)\n{\n\tif (en) {\n\t\trtw89_phy_write32_mask(rtwdev, R_P0_TXPW_RSTB, B_P0_TXPW_RSTB_MANON, 0x0);\n\t\trtw89_phy_write32_mask(rtwdev, R_P0_TSSI_TRK, B_P0_TSSI_TRK_EN, 0x0);\n\t} else {\n\t\trtw89_phy_write32_mask(rtwdev, R_P0_TXPW_RSTB, B_P0_TXPW_RSTB_MANON, 0x1);\n\t\trtw89_phy_write32_mask(rtwdev, R_P0_TSSI_TRK, B_P0_TSSI_TRK_EN, 0x1);\n\t}\n}\n\nstatic void rtw8851b_tssi_cont_en_phyidx(struct rtw89_dev *rtwdev, bool en,\n\t\t\t\t\t u8 phy_idx)\n{\n\trtw8851b_tssi_cont_en(rtwdev, en, RF_PATH_A);\n}\n\nstatic void rtw8851b_adc_en(struct rtw89_dev *rtwdev, bool en)\n{\n\tif (en)\n\t\trtw89_phy_write32_mask(rtwdev, R_ADC_FIFO, B_ADC_FIFO_RST, 0x0);\n\telse\n\t\trtw89_phy_write32_mask(rtwdev, R_ADC_FIFO, B_ADC_FIFO_RST, 0xf);\n}\n\nstatic void rtw8851b_set_channel_help(struct rtw89_dev *rtwdev, bool enter,\n\t\t\t\t      struct rtw89_channel_help_params *p,\n\t\t\t\t      const struct rtw89_chan *chan,\n\t\t\t\t      enum rtw89_mac_idx mac_idx,\n\t\t\t\t      enum rtw89_phy_idx phy_idx)\n{\n\tif (enter) {\n\t\trtw89_chip_stop_sch_tx(rtwdev, RTW89_MAC_0, &p->tx_en, RTW89_SCH_TX_SEL_ALL);\n\t\trtw89_mac_cfg_ppdu_status(rtwdev, RTW89_MAC_0, false);\n\t\trtw8851b_tssi_cont_en_phyidx(rtwdev, false, RTW89_PHY_0);\n\t\trtw8851b_adc_en(rtwdev, false);\n\t\tfsleep(40);\n\t\trtw8851b_bb_reset_en(rtwdev, chan->band_type, phy_idx, false);\n\t} else {\n\t\trtw89_mac_cfg_ppdu_status(rtwdev, RTW89_MAC_0, true);\n\t\trtw8851b_adc_en(rtwdev, true);\n\t\trtw8851b_tssi_cont_en_phyidx(rtwdev, true, RTW89_PHY_0);\n\t\trtw8851b_bb_reset_en(rtwdev, chan->band_type, phy_idx, true);\n\t\trtw89_chip_resume_sch_tx(rtwdev, RTW89_MAC_0, p->tx_en);\n\t}\n}\n\nstatic void rtw8851b_rfk_init(struct rtw89_dev *rtwdev)\n{\n\trtwdev->is_tssi_mode[RF_PATH_A] = false;\n\trtwdev->is_tssi_mode[RF_PATH_B] = false;\n\trtw8851b_lck_init(rtwdev);\n\n\trtw8851b_dpk_init(rtwdev);\n\trtw8851b_aack(rtwdev);\n\trtw8851b_rck(rtwdev);\n\trtw8851b_dack(rtwdev);\n\trtw8851b_rx_dck(rtwdev, RTW89_PHY_0);\n}\n\nstatic void rtw8851b_rfk_channel(struct rtw89_dev *rtwdev)\n{\n\tenum rtw89_phy_idx phy_idx = RTW89_PHY_0;\n\n\trtw8851b_rx_dck(rtwdev, phy_idx);\n\trtw8851b_iqk(rtwdev, phy_idx);\n\trtw8851b_tssi(rtwdev, phy_idx, true);\n\trtw8851b_dpk(rtwdev, phy_idx);\n}\n\nstatic void rtw8851b_rfk_band_changed(struct rtw89_dev *rtwdev,\n\t\t\t\t      enum rtw89_phy_idx phy_idx)\n{\n\trtw8851b_tssi_scan(rtwdev, phy_idx);\n}\n\nstatic void rtw8851b_rfk_scan(struct rtw89_dev *rtwdev, bool start)\n{\n\trtw8851b_wifi_scan_notify(rtwdev, start, RTW89_PHY_0);\n}\n\nstatic void rtw8851b_rfk_track(struct rtw89_dev *rtwdev)\n{\n\trtw8851b_dpk_track(rtwdev);\n\trtw8851b_lck_track(rtwdev);\n}\n\nstatic u32 rtw8851b_bb_cal_txpwr_ref(struct rtw89_dev *rtwdev,\n\t\t\t\t     enum rtw89_phy_idx phy_idx, s16 ref)\n{\n\tconst u16 tssi_16dbm_cw = 0x12c;\n\tconst u8 base_cw_0db = 0x27;\n\tconst s8 ofst_int = 0;\n\ts16 pwr_s10_3;\n\ts16 rf_pwr_cw;\n\tu16 bb_pwr_cw;\n\tu32 pwr_cw;\n\tu32 tssi_ofst_cw;\n\n\tpwr_s10_3 = (ref << 1) + (s16)(ofst_int) + (s16)(base_cw_0db << 3);\n\tbb_pwr_cw = u16_get_bits(pwr_s10_3, GENMASK(2, 0));\n\trf_pwr_cw = u16_get_bits(pwr_s10_3, GENMASK(8, 3));\n\trf_pwr_cw = clamp_t(s16, rf_pwr_cw, 15, 63);\n\tpwr_cw = (rf_pwr_cw << 3) | bb_pwr_cw;\n\n\ttssi_ofst_cw = (u32)((s16)tssi_16dbm_cw + (ref << 1) - (16 << 3));\n\trtw89_debug(rtwdev, RTW89_DBG_TXPWR,\n\t\t    \"[TXPWR] tssi_ofst_cw=%d rf_cw=0x%x bb_cw=0x%x\\n\",\n\t\t    tssi_ofst_cw, rf_pwr_cw, bb_pwr_cw);\n\n\treturn u32_encode_bits(tssi_ofst_cw, B_DPD_TSSI_CW) |\n\t       u32_encode_bits(pwr_cw, B_DPD_PWR_CW) |\n\t       u32_encode_bits(ref, B_DPD_REF);\n}\n\nstatic void rtw8851b_set_txpwr_ref(struct rtw89_dev *rtwdev,\n\t\t\t\t   enum rtw89_phy_idx phy_idx)\n{\n\tstatic const u32 addr[RF_PATH_NUM_8851B] = {0x5800};\n\tconst u32 mask = B_DPD_TSSI_CW | B_DPD_PWR_CW | B_DPD_REF;\n\tconst u8 ofst_ofdm = 0x4;\n\tconst u8 ofst_cck = 0x8;\n\tconst s16 ref_ofdm = 0;\n\tconst s16 ref_cck = 0;\n\tu32 val;\n\tu8 i;\n\n\trtw89_debug(rtwdev, RTW89_DBG_TXPWR, \"[TXPWR] set txpwr reference\\n\");\n\n\trtw89_mac_txpwr_write32_mask(rtwdev, phy_idx, R_AX_PWR_RATE_CTRL,\n\t\t\t\t     B_AX_PWR_REF, 0x0);\n\n\trtw89_debug(rtwdev, RTW89_DBG_TXPWR, \"[TXPWR] set bb ofdm txpwr ref\\n\");\n\tval = rtw8851b_bb_cal_txpwr_ref(rtwdev, phy_idx, ref_ofdm);\n\n\tfor (i = 0; i < RF_PATH_NUM_8851B; i++)\n\t\trtw89_phy_write32_idx(rtwdev, addr[i] + ofst_ofdm, mask, val,\n\t\t\t\t      phy_idx);\n\n\trtw89_debug(rtwdev, RTW89_DBG_TXPWR, \"[TXPWR] set bb cck txpwr ref\\n\");\n\tval = rtw8851b_bb_cal_txpwr_ref(rtwdev, phy_idx, ref_cck);\n\n\tfor (i = 0; i < RF_PATH_NUM_8851B; i++)\n\t\trtw89_phy_write32_idx(rtwdev, addr[i] + ofst_cck, mask, val,\n\t\t\t\t      phy_idx);\n}\n\nstatic void rtw8851b_bb_set_tx_shape_dfir(struct rtw89_dev *rtwdev,\n\t\t\t\t\t  const struct rtw89_chan *chan,\n\t\t\t\t\t  u8 tx_shape_idx,\n\t\t\t\t\t  enum rtw89_phy_idx phy_idx)\n{\n#define __DFIR_CFG_ADDR(i) (R_TXFIR0 + ((i) << 2))\n#define __DFIR_CFG_MASK 0xffffffff\n#define __DFIR_CFG_NR 8\n#define __DECL_DFIR_PARAM(_name, _val...) \\\n\tstatic const u32 param_ ## _name[] = {_val}; \\\n\tstatic_assert(ARRAY_SIZE(param_ ## _name) == __DFIR_CFG_NR)\n\n\t__DECL_DFIR_PARAM(flat,\n\t\t\t  0x023D23FF, 0x0029B354, 0x000FC1C8, 0x00FDB053,\n\t\t\t  0x00F86F9A, 0x06FAEF92, 0x00FE5FCC, 0x00FFDFF5);\n\t__DECL_DFIR_PARAM(sharp,\n\t\t\t  0x023D83FF, 0x002C636A, 0x0013F204, 0x00008090,\n\t\t\t  0x00F87FB0, 0x06F99F83, 0x00FDBFBA, 0x00003FF5);\n\t__DECL_DFIR_PARAM(sharp_14,\n\t\t\t  0x023B13FF, 0x001C42DE, 0x00FDB0AD, 0x00F60F6E,\n\t\t\t  0x00FD8F92, 0x0602D011, 0x0001C02C, 0x00FFF00A);\n\tu8 ch = chan->channel;\n\tconst u32 *param;\n\tu32 addr;\n\tint i;\n\n\tif (ch > 14) {\n\t\trtw89_warn(rtwdev,\n\t\t\t   \"set tx shape dfir by unknown ch: %d on 2G\\n\", ch);\n\t\treturn;\n\t}\n\n\tif (ch == 14)\n\t\tparam = param_sharp_14;\n\telse\n\t\tparam = tx_shape_idx == 0 ? param_flat : param_sharp;\n\n\tfor (i = 0; i < __DFIR_CFG_NR; i++) {\n\t\taddr = __DFIR_CFG_ADDR(i);\n\t\trtw89_debug(rtwdev, RTW89_DBG_TXPWR,\n\t\t\t    \"set tx shape dfir: 0x%x: 0x%x\\n\", addr, param[i]);\n\t\trtw89_phy_write32_idx(rtwdev, addr, __DFIR_CFG_MASK, param[i],\n\t\t\t\t      phy_idx);\n\t}\n\n#undef __DECL_DFIR_PARAM\n#undef __DFIR_CFG_NR\n#undef __DFIR_CFG_MASK\n#undef __DECL_CFG_ADDR\n}\n\nstatic void rtw8851b_set_tx_shape(struct rtw89_dev *rtwdev,\n\t\t\t\t  const struct rtw89_chan *chan,\n\t\t\t\t  enum rtw89_phy_idx phy_idx)\n{\n\tu8 band = chan->band_type;\n\tu8 regd = rtw89_regd_get(rtwdev, band);\n\tu8 tx_shape_cck = rtw89_8851b_tx_shape[band][RTW89_RS_CCK][regd];\n\tu8 tx_shape_ofdm = rtw89_8851b_tx_shape[band][RTW89_RS_OFDM][regd];\n\n\tif (band == RTW89_BAND_2G)\n\t\trtw8851b_bb_set_tx_shape_dfir(rtwdev, chan, tx_shape_cck, phy_idx);\n\n\trtw89_phy_write32_mask(rtwdev, R_DCFO_OPT, B_TXSHAPE_TRIANGULAR_CFG,\n\t\t\t       tx_shape_ofdm);\n}\n\nstatic void rtw8851b_set_txpwr(struct rtw89_dev *rtwdev,\n\t\t\t       const struct rtw89_chan *chan,\n\t\t\t       enum rtw89_phy_idx phy_idx)\n{\n\trtw89_phy_set_txpwr_byrate(rtwdev, chan, phy_idx);\n\trtw89_phy_set_txpwr_offset(rtwdev, chan, phy_idx);\n\trtw8851b_set_tx_shape(rtwdev, chan, phy_idx);\n\trtw89_phy_set_txpwr_limit(rtwdev, chan, phy_idx);\n\trtw89_phy_set_txpwr_limit_ru(rtwdev, chan, phy_idx);\n}\n\nstatic void rtw8851b_set_txpwr_ctrl(struct rtw89_dev *rtwdev,\n\t\t\t\t    enum rtw89_phy_idx phy_idx)\n{\n\trtw8851b_set_txpwr_ref(rtwdev, phy_idx);\n}\n\nstatic\nvoid rtw8851b_set_txpwr_ul_tb_offset(struct rtw89_dev *rtwdev,\n\t\t\t\t     s8 pw_ofst, enum rtw89_mac_idx mac_idx)\n{\n\tu32 reg;\n\n\tif (pw_ofst < -16 || pw_ofst > 15) {\n\t\trtw89_warn(rtwdev, \"[ULTB] Err pwr_offset=%d\\n\", pw_ofst);\n\t\treturn;\n\t}\n\n\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_PWR_UL_TB_CTRL, mac_idx);\n\trtw89_write32_set(rtwdev, reg, B_AX_PWR_UL_TB_CTRL_EN);\n\n\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_PWR_UL_TB_1T, mac_idx);\n\trtw89_write32_mask(rtwdev, reg, B_AX_PWR_UL_TB_1T_MASK, pw_ofst);\n\n\tpw_ofst = max_t(s8, pw_ofst - 3, -16);\n\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_PWR_UL_TB_2T, mac_idx);\n\trtw89_write32_mask(rtwdev, reg, B_AX_PWR_UL_TB_2T_MASK, pw_ofst);\n}\n\nstatic int\nrtw8851b_init_txpwr_unit(struct rtw89_dev *rtwdev, enum rtw89_phy_idx phy_idx)\n{\n\tint ret;\n\n\tret = rtw89_mac_txpwr_write32(rtwdev, phy_idx, R_AX_PWR_UL_CTRL2, 0x07763333);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rtw89_mac_txpwr_write32(rtwdev, phy_idx, R_AX_PWR_COEXT_CTRL, 0x01ebf000);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rtw89_mac_txpwr_write32(rtwdev, phy_idx, R_AX_PWR_UL_CTRL0, 0x0002f8ff);\n\tif (ret)\n\t\treturn ret;\n\n\trtw8851b_set_txpwr_ul_tb_offset(rtwdev, 0, phy_idx == RTW89_PHY_1 ?\n\t\t\t\t\t\t   RTW89_MAC_1 : RTW89_MAC_0);\n\n\treturn 0;\n}\n\nstatic void rtw8851b_bb_ctrl_btc_preagc(struct rtw89_dev *rtwdev, bool bt_en)\n{\n\tconst struct rtw89_chan *chan = rtw89_chan_get(rtwdev, RTW89_SUB_ENTITY_0);\n\n\trtw89_phy_write_reg3_tbl(rtwdev, bt_en ? &rtw8851b_btc_preagc_en_defs_tbl :\n\t\t\t\t\t\t &rtw8851b_btc_preagc_dis_defs_tbl);\n\n\tif (!bt_en) {\n\t\tif (chan->band_type == RTW89_BAND_2G) {\n\t\t\trtw89_phy_write32_mask(rtwdev, R_PATH0_G_LNA6_OP1DB_V1,\n\t\t\t\t\t       B_PATH0_G_LNA6_OP1DB_V1, 0x20);\n\t\t\trtw89_phy_write32_mask(rtwdev, R_PATH0_G_TIA0_LNA6_OP1DB_V1,\n\t\t\t\t\t       B_PATH0_G_TIA0_LNA6_OP1DB_V1, 0x30);\n\t\t} else {\n\t\t\trtw89_phy_write32_mask(rtwdev, R_PATH0_G_LNA6_OP1DB_V1,\n\t\t\t\t\t       B_PATH0_G_LNA6_OP1DB_V1, 0x1a);\n\t\t\trtw89_phy_write32_mask(rtwdev, R_PATH0_G_TIA0_LNA6_OP1DB_V1,\n\t\t\t\t\t       B_PATH0_G_TIA0_LNA6_OP1DB_V1, 0x2a);\n\t\t}\n\t}\n}\n\nstatic void rtw8851b_ctrl_btg(struct rtw89_dev *rtwdev, bool btg)\n{\n\tconst struct rtw89_chan *chan = rtw89_chan_get(rtwdev, RTW89_SUB_ENTITY_0);\n\n\tif (btg) {\n\t\trtw89_phy_write32_mask(rtwdev, R_PATH0_BT_SHARE_V1,\n\t\t\t\t       B_PATH0_BT_SHARE_V1, 0x1);\n\t\trtw89_phy_write32_mask(rtwdev, R_PATH0_BTG_PATH_V1,\n\t\t\t\t       B_PATH0_BTG_PATH_V1, 0x1);\n\t\trtw89_phy_write32_mask(rtwdev, R_PATH0_G_LNA6_OP1DB_V1,\n\t\t\t\t       B_PATH0_G_LNA6_OP1DB_V1, 0x20);\n\t\trtw89_phy_write32_mask(rtwdev, R_PATH0_G_TIA0_LNA6_OP1DB_V1,\n\t\t\t\t       B_PATH0_G_TIA0_LNA6_OP1DB_V1, 0x30);\n\t\trtw89_phy_write32_mask(rtwdev, R_PMAC_GNT, B_PMAC_GNT_P1, 0x0);\n\t\trtw89_phy_write32_mask(rtwdev, R_CHBW_MOD_V1, B_BT_SHARE, 0x1);\n\t\trtw89_phy_write32_mask(rtwdev, R_FC0_BW_V1, B_ANT_RX_BT_SEG0, 0x1);\n\t\trtw89_phy_write32_mask(rtwdev, R_BT_DYN_DC_EST_EN_V1,\n\t\t\t\t       B_BT_DYN_DC_EST_EN_MSK, 0x1);\n\t\trtw89_phy_write32_mask(rtwdev, R_GNT_BT_WGT_EN, B_GNT_BT_WGT_EN, 0x1);\n\t} else {\n\t\trtw89_phy_write32_mask(rtwdev, R_PATH0_BT_SHARE_V1,\n\t\t\t\t       B_PATH0_BT_SHARE_V1, 0x0);\n\t\trtw89_phy_write32_mask(rtwdev, R_PATH0_BTG_PATH_V1,\n\t\t\t\t       B_PATH0_BTG_PATH_V1, 0x0);\n\t\tif (chan->band_type == RTW89_BAND_2G) {\n\t\t\trtw89_phy_write32_mask(rtwdev, R_PATH0_G_LNA6_OP1DB_V1,\n\t\t\t\t\t       B_PATH0_G_LNA6_OP1DB_V1, 0x80);\n\t\t\trtw89_phy_write32_mask(rtwdev, R_PATH0_G_TIA0_LNA6_OP1DB_V1,\n\t\t\t\t\t       B_PATH0_G_TIA0_LNA6_OP1DB_V1, 0x80);\n\t\t} else {\n\t\t\trtw89_phy_write32_mask(rtwdev, R_PATH0_G_LNA6_OP1DB_V1,\n\t\t\t\t\t       B_PATH0_G_LNA6_OP1DB_V1, 0x1a);\n\t\t\trtw89_phy_write32_mask(rtwdev, R_PATH0_G_TIA0_LNA6_OP1DB_V1,\n\t\t\t\t\t       B_PATH0_G_TIA0_LNA6_OP1DB_V1, 0x2a);\n\t\t}\n\t\trtw89_phy_write32_mask(rtwdev, R_PMAC_GNT, B_PMAC_GNT_P1, 0xc);\n\t\trtw89_phy_write32_mask(rtwdev, R_CHBW_MOD_V1, B_BT_SHARE, 0x0);\n\t\trtw89_phy_write32_mask(rtwdev, R_FC0_BW_V1, B_ANT_RX_BT_SEG0, 0x0);\n\t\trtw89_phy_write32_mask(rtwdev, R_BT_DYN_DC_EST_EN_V1,\n\t\t\t\t       B_BT_DYN_DC_EST_EN_MSK, 0x1);\n\t\trtw89_phy_write32_mask(rtwdev, R_GNT_BT_WGT_EN, B_GNT_BT_WGT_EN, 0x0);\n\t}\n}\n\nstatic void rtw8851b_bb_ctrl_rx_path(struct rtw89_dev *rtwdev,\n\t\t\t\t     enum rtw89_rf_path_bit rx_path)\n{\n\tconst struct rtw89_chan *chan = rtw89_chan_get(rtwdev, RTW89_SUB_ENTITY_0);\n\tu32 rst_mask0;\n\n\tif (rx_path == RF_A) {\n\t\trtw89_phy_write32_mask(rtwdev, R_CHBW_MOD_V1, B_ANT_RX_SEG0, 1);\n\t\trtw89_phy_write32_mask(rtwdev, R_FC0_BW_V1, B_ANT_RX_1RCCA_SEG0, 1);\n\t\trtw89_phy_write32_mask(rtwdev, R_FC0_BW_V1, B_ANT_RX_1RCCA_SEG1, 1);\n\t\trtw89_phy_write32_mask(rtwdev, R_RXHT_MCS_LIMIT, B_RXHT_MCS_LIMIT, 0);\n\t\trtw89_phy_write32_mask(rtwdev, R_RXVHT_MCS_LIMIT, B_RXVHT_MCS_LIMIT, 0);\n\t\trtw89_phy_write32_mask(rtwdev, R_RXHE, B_RXHE_USER_MAX, 4);\n\t\trtw89_phy_write32_mask(rtwdev, R_RXHE, B_RXHE_MAX_NSS, 0);\n\t\trtw89_phy_write32_mask(rtwdev, R_RXHE, B_RXHETB_MAX_NSS, 0);\n\t}\n\n\trtw8851b_set_gain_offset(rtwdev, chan->subband_type, RTW89_PHY_0);\n\n\trst_mask0 = B_P0_TXPW_RSTB_MANON | B_P0_TXPW_RSTB_TSSI;\n\tif (rx_path == RF_A) {\n\t\trtw89_phy_write32_mask(rtwdev, R_P0_TXPW_RSTB, rst_mask0, 1);\n\t\trtw89_phy_write32_mask(rtwdev, R_P0_TXPW_RSTB, rst_mask0, 3);\n\t}\n}\n\nstatic void rtw8851b_bb_cfg_txrx_path(struct rtw89_dev *rtwdev)\n{\n\trtw8851b_bb_ctrl_rx_path(rtwdev, RF_A);\n\n\tif (rtwdev->hal.rx_nss == 1) {\n\t\trtw89_phy_write32_mask(rtwdev, R_RXHT_MCS_LIMIT, B_RXHT_MCS_LIMIT, 0);\n\t\trtw89_phy_write32_mask(rtwdev, R_RXVHT_MCS_LIMIT, B_RXVHT_MCS_LIMIT, 0);\n\t\trtw89_phy_write32_mask(rtwdev, R_RXHE, B_RXHE_MAX_NSS, 0);\n\t\trtw89_phy_write32_mask(rtwdev, R_RXHE, B_RXHETB_MAX_NSS, 0);\n\t}\n\n\trtw89_phy_write32_idx(rtwdev, R_MAC_SEL, B_MAC_SEL_MOD, 0x0, RTW89_PHY_0);\n}\n\nstatic u8 rtw8851b_get_thermal(struct rtw89_dev *rtwdev, enum rtw89_rf_path rf_path)\n{\n\tif (rtwdev->is_tssi_mode[rf_path]) {\n\t\tu32 addr = R_TSSI_THER + (rf_path << 13);\n\n\t\treturn rtw89_phy_read32_mask(rtwdev, addr, B_TSSI_THER);\n\t}\n\n\trtw89_write_rf(rtwdev, rf_path, RR_TM, RR_TM_TRI, 0x1);\n\trtw89_write_rf(rtwdev, rf_path, RR_TM, RR_TM_TRI, 0x0);\n\trtw89_write_rf(rtwdev, rf_path, RR_TM, RR_TM_TRI, 0x1);\n\n\tfsleep(200);\n\n\treturn rtw89_read_rf(rtwdev, rf_path, RR_TM, RR_TM_VAL);\n}\n\nstatic void rtw8851b_btc_set_rfe(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_module *module = &btc->mdinfo;\n\n\tmodule->rfe_type = rtwdev->efuse.rfe_type;\n\tmodule->cv = rtwdev->hal.cv;\n\tmodule->bt_solo = 0;\n\tmodule->switch_type = BTC_SWITCH_INTERNAL;\n\tmodule->ant.isolation = 10;\n\tmodule->kt_ver_adie = rtwdev->hal.acv;\n\n\tif (module->rfe_type == 0)\n\t\treturn;\n\n\t \n\tmodule->ant.num = (module->rfe_type % 3 == 1) ? 1 : 2;\n\t \n\tmodule->ant.single_pos = RF_PATH_A;\n\tmodule->ant.btg_pos = RF_PATH_A;\n\tmodule->ant.stream_cnt = 1;\n\n\tif (module->ant.num == 1) {\n\t\tmodule->ant.type = BTC_ANT_SHARED;\n\t\tmodule->bt_pos = BTC_BT_BTG;\n\t\tmodule->wa_type = 1;\n\t\tmodule->ant.diversity = 0;\n\t} else {  \n\t\tmodule->ant.type = BTC_ANT_DEDICATED;\n\t\tmodule->bt_pos = BTC_BT_ALONE;\n\t\tmodule->switch_type = BTC_SWITCH_EXTERNAL;\n\t\tmodule->wa_type = 0;\n\t\tif (module->rfe_type % 3 == 2)\n\t\t\tmodule->ant.diversity = 1;\n\t}\n}\n\nstatic\nvoid rtw8851b_set_trx_mask(struct rtw89_dev *rtwdev, u8 path, u8 group, u32 val)\n{\n\tif (group > BTC_BT_SS_GROUP)\n\t\tgroup--;  \n\n\tif (rtwdev->btc.mdinfo.ant.type == BTC_ANT_SHARED)  \n\t\tgroup += 3;\n\n\trtw89_write_rf(rtwdev, path, RR_LUTWA, RFREG_MASK, group);\n\trtw89_write_rf(rtwdev, path, RR_LUTWD0, RFREG_MASK, val);\n}\n\nstatic void rtw8851b_btc_init_cfg(struct rtw89_dev *rtwdev)\n{\n\tstatic const struct rtw89_mac_ax_coex coex_params = {\n\t\t.pta_mode = RTW89_MAC_AX_COEX_RTK_MODE,\n\t\t.direction = RTW89_MAC_AX_COEX_INNER,\n\t};\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_module *module = &btc->mdinfo;\n\tstruct rtw89_btc_ant_info *ant = &module->ant;\n\tu8 path, path_min, path_max;\n\n\t \n\trtw89_mac_coex_init(rtwdev, &coex_params);\n\n\t \n\tchip->ops->btc_set_wl_pri(rtwdev, BTC_PRI_MASK_TX_RESP, true);\n\tchip->ops->btc_set_wl_pri(rtwdev, BTC_PRI_MASK_BEACON, true);\n\n\t \n\tif (ant->stream_cnt == 1) {\n\t\tpath_min = ant->single_pos;\n\t\tpath_max = path_min;\n\t} else {\n\t\tpath_min = RF_PATH_A;\n\t\tpath_max = RF_PATH_B;\n\t}\n\n\tfor (path = path_min; path <= path_max; path++) {\n\t\t \n\t\trtw89_write_rf(rtwdev, path, RR_WLSEL, RFREG_MASK, 0x0);\n\n\t\t \n\t\trtw89_write_rf(rtwdev, path, RR_LUTWE, RFREG_MASK, BIT(17));\n\n\t\t \n\t\trtw8851b_set_trx_mask(rtwdev, path, BTC_BT_SS_GROUP, 0x5ff);\n\n\t\t \n\t\trtw8851b_set_trx_mask(rtwdev, path, BTC_BT_RX_GROUP, 0x5df);\n\n\t\t \n\t\tif (ant->type == BTC_ANT_SHARED && ant->btg_pos == path)\n\t\t\trtw8851b_set_trx_mask(rtwdev, path, BTC_BT_TX_GROUP, 0x55f);\n\t\telse\n\t\t\trtw8851b_set_trx_mask(rtwdev, path, BTC_BT_TX_GROUP, 0x5ff);\n\n\t\t \n\t\trtw89_write_rf(rtwdev, path, RR_LUTWE, RFREG_MASK, 0);\n\t}\n\n\t \n\trtw89_write32(rtwdev, R_BTC_BREAK_TABLE, BTC_BREAK_PARAM);\n\n\t \n\trtw89_write32_set(rtwdev, R_AX_CSR_MODE, B_AX_BT_CNT_RST | B_AX_STATIS_BT_EN);\n\n\tbtc->cx.wl.status.map.init_ok = true;\n}\n\nstatic\nvoid rtw8851b_btc_set_wl_pri(struct rtw89_dev *rtwdev, u8 map, bool state)\n{\n\tu32 bitmap;\n\tu32 reg;\n\n\tswitch (map) {\n\tcase BTC_PRI_MASK_TX_RESP:\n\t\treg = R_BTC_BT_COEX_MSK_TABLE;\n\t\tbitmap = B_BTC_PRI_MASK_TX_RESP_V1;\n\t\tbreak;\n\tcase BTC_PRI_MASK_BEACON:\n\t\treg = R_AX_WL_PRI_MSK;\n\t\tbitmap = B_AX_PTA_WL_PRI_MASK_BCNQ;\n\t\tbreak;\n\tcase BTC_PRI_MASK_RX_CCK:\n\t\treg = R_BTC_BT_COEX_MSK_TABLE;\n\t\tbitmap = B_BTC_PRI_MASK_RXCCK_V1;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (state)\n\t\trtw89_write32_set(rtwdev, reg, bitmap);\n\telse\n\t\trtw89_write32_clr(rtwdev, reg, bitmap);\n}\n\nunion rtw8851b_btc_wl_txpwr_ctrl {\n\tu32 txpwr_val;\n\tstruct {\n\t\tunion {\n\t\t\tu16 ctrl_all_time;\n\t\t\tstruct {\n\t\t\t\ts16 data:9;\n\t\t\t\tu16 rsvd:6;\n\t\t\t\tu16 flag:1;\n\t\t\t} all_time;\n\t\t};\n\t\tunion {\n\t\t\tu16 ctrl_gnt_bt;\n\t\t\tstruct {\n\t\t\t\ts16 data:9;\n\t\t\t\tu16 rsvd:7;\n\t\t\t} gnt_bt;\n\t\t};\n\t};\n} __packed;\n\nstatic void\nrtw8851b_btc_set_wl_txpwr_ctrl(struct rtw89_dev *rtwdev, u32 txpwr_val)\n{\n\tunion rtw8851b_btc_wl_txpwr_ctrl arg = { .txpwr_val = txpwr_val };\n\ts32 val;\n\n#define __write_ctrl(_reg, _msk, _val, _en, _cond)\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tu32 _wrt = FIELD_PREP(_msk, _val);\t\t\t\\\n\tBUILD_BUG_ON(!!(_msk & _en));\t\t\t\t\\\n\tif (_cond)\t\t\t\t\t\t\\\n\t\t_wrt |= _en;\t\t\t\t\t\\\n\telse\t\t\t\t\t\t\t\\\n\t\t_wrt &= ~_en;\t\t\t\t\t\\\n\trtw89_mac_txpwr_write32_mask(rtwdev, RTW89_PHY_0, _reg,\t\\\n\t\t\t\t     _msk | _en, _wrt);\t\t\\\n} while (0)\n\n\tswitch (arg.ctrl_all_time) {\n\tcase 0xffff:\n\t\tval = 0;\n\t\tbreak;\n\tdefault:\n\t\tval = arg.all_time.data;\n\t\tbreak;\n\t}\n\n\t__write_ctrl(R_AX_PWR_RATE_CTRL, B_AX_FORCE_PWR_BY_RATE_VALUE_MASK,\n\t\t     val, B_AX_FORCE_PWR_BY_RATE_EN,\n\t\t     arg.ctrl_all_time != 0xffff);\n\n\tswitch (arg.ctrl_gnt_bt) {\n\tcase 0xffff:\n\t\tval = 0;\n\t\tbreak;\n\tdefault:\n\t\tval = arg.gnt_bt.data;\n\t\tbreak;\n\t}\n\n\t__write_ctrl(R_AX_PWR_COEXT_CTRL, B_AX_TXAGC_BT_MASK, val,\n\t\t     B_AX_TXAGC_BT_EN, arg.ctrl_gnt_bt != 0xffff);\n\n#undef __write_ctrl\n}\n\nstatic\ns8 rtw8851b_btc_get_bt_rssi(struct rtw89_dev *rtwdev, s8 val)\n{\n\tval = clamp_t(s8, val, -100, 0) + 100;\n\tval = min(val + 6, 100);  \n\n\treturn val;\n}\n\nstatic\nvoid rtw8851b_btc_update_bt_cnt(struct rtw89_dev *rtwdev)\n{\n\t \n}\n\nstatic void rtw8851b_btc_wl_s1_standby(struct rtw89_dev *rtwdev, bool state)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_ant_info *ant = &btc->mdinfo.ant;\n\n\trtw89_write_rf(rtwdev, ant->btg_pos, RR_LUTWE, RFREG_MASK, 0x80000);\n\trtw89_write_rf(rtwdev, ant->btg_pos, RR_LUTWA, RFREG_MASK, 0x1);\n\trtw89_write_rf(rtwdev, ant->btg_pos, RR_LUTWD1, RFREG_MASK, 0x110);\n\n\t \n\tif (state)\n\t\trtw89_write_rf(rtwdev, ant->btg_pos, RR_LUTWD0, RFREG_MASK, 0x179c);\n\telse\n\t\trtw89_write_rf(rtwdev, ant->btg_pos, RR_LUTWD0, RFREG_MASK, 0x208);\n\n\trtw89_write_rf(rtwdev, ant->btg_pos, RR_LUTWE, RFREG_MASK, 0x0);\n}\n\n#define LNA2_51B_MA 0x700\n\nstatic const struct rtw89_reg2_def btc_8851b_rf_0[] = {{0x2, 0x0}};\nstatic const struct rtw89_reg2_def btc_8851b_rf_1[] = {{0x2, 0x1}};\n\nstatic void rtw8851b_btc_set_wl_rx_gain(struct rtw89_dev *rtwdev, u32 level)\n{\n\t \n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_ant_info *ant = &btc->mdinfo.ant;\n\tconst struct rtw89_reg2_def *rf;\n\tu32 n, i, val;\n\n\tswitch (level) {\n\tcase 0:  \n\tdefault:\n\t\tbtc->dm.wl_lna2 = 0;\n\t\tbreak;\n\tcase 1:  \n\t\tbtc->dm.wl_lna2 = 0;\n\t\tbreak;\n\tcase 2:  \n\t\tbtc->dm.wl_lna2 = 1;\n\t\tbreak;\n\t}\n\n\tif (btc->dm.wl_lna2 == 0) {\n\t\trf = btc_8851b_rf_0;\n\t\tn = ARRAY_SIZE(btc_8851b_rf_0);\n\t} else {\n\t\trf = btc_8851b_rf_1;\n\t\tn = ARRAY_SIZE(btc_8851b_rf_1);\n\t}\n\n\tfor (i = 0; i < n; i++, rf++) {\n\t\tval = rf->data;\n\t\t \n\t\tif (btc->mdinfo.ant.type == BTC_ANT_DEDICATED)\n\t\t\tval |= 0x4;\n\n\t\trtw89_write_rf(rtwdev, ant->btg_pos, rf->addr, LNA2_51B_MA, val);\n\t}\n}\n\nstatic void rtw8851b_fill_freq_with_ppdu(struct rtw89_dev *rtwdev,\n\t\t\t\t\t struct rtw89_rx_phy_ppdu *phy_ppdu,\n\t\t\t\t\t struct ieee80211_rx_status *status)\n{\n\tu16 chan = phy_ppdu->chan_idx;\n\tenum nl80211_band band;\n\tu8 ch;\n\n\tif (chan == 0)\n\t\treturn;\n\n\trtw89_decode_chan_idx(rtwdev, chan, &ch, &band);\n\tstatus->freq = ieee80211_channel_to_frequency(ch, band);\n\tstatus->band = band;\n}\n\nstatic void rtw8851b_query_ppdu(struct rtw89_dev *rtwdev,\n\t\t\t\tstruct rtw89_rx_phy_ppdu *phy_ppdu,\n\t\t\t\tstruct ieee80211_rx_status *status)\n{\n\tu8 path;\n\tu8 *rx_power = phy_ppdu->rssi;\n\n\tstatus->signal = RTW89_RSSI_RAW_TO_DBM(rx_power[RF_PATH_A]);\n\n\tfor (path = 0; path < rtwdev->chip->rf_path_num; path++) {\n\t\tstatus->chains |= BIT(path);\n\t\tstatus->chain_signal[path] = RTW89_RSSI_RAW_TO_DBM(rx_power[path]);\n\t}\n\tif (phy_ppdu->valid)\n\t\trtw8851b_fill_freq_with_ppdu(rtwdev, phy_ppdu, status);\n}\n\nstatic int rtw8851b_mac_enable_bb_rf(struct rtw89_dev *rtwdev)\n{\n\tint ret;\n\n\trtw89_write8_set(rtwdev, R_AX_SYS_FUNC_EN,\n\t\t\t B_AX_FEN_BBRSTB | B_AX_FEN_BB_GLB_RSTN);\n\trtw89_write32_set(rtwdev, R_AX_WLRF_CTRL, B_AX_AFC_AFEDIG);\n\trtw89_write32_clr(rtwdev, R_AX_WLRF_CTRL, B_AX_AFC_AFEDIG);\n\trtw89_write32_set(rtwdev, R_AX_WLRF_CTRL, B_AX_AFC_AFEDIG);\n\n\tret = rtw89_mac_write_xtal_si(rtwdev, XTAL_SI_WL_RFC_S0, 0xC7,\n\t\t\t\t      FULL_BIT_MASK);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rtw89_mac_write_xtal_si(rtwdev, XTAL_SI_WL_RFC_S1, 0xC7,\n\t\t\t\t      FULL_BIT_MASK);\n\tif (ret)\n\t\treturn ret;\n\n\trtw89_write8(rtwdev, R_AX_PHYREG_SET, PHYREG_SET_XYN_CYCLE);\n\n\treturn 0;\n}\n\nstatic int rtw8851b_mac_disable_bb_rf(struct rtw89_dev *rtwdev)\n{\n\tu8 wl_rfc_s0;\n\tu8 wl_rfc_s1;\n\tint ret;\n\n\trtw89_write8_clr(rtwdev, R_AX_SYS_FUNC_EN,\n\t\t\t B_AX_FEN_BBRSTB | B_AX_FEN_BB_GLB_RSTN);\n\n\tret = rtw89_mac_read_xtal_si(rtwdev, XTAL_SI_WL_RFC_S0, &wl_rfc_s0);\n\tif (ret)\n\t\treturn ret;\n\twl_rfc_s0 &= ~XTAL_SI_RF00S_EN;\n\tret = rtw89_mac_write_xtal_si(rtwdev, XTAL_SI_WL_RFC_S0, wl_rfc_s0,\n\t\t\t\t      FULL_BIT_MASK);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rtw89_mac_read_xtal_si(rtwdev, XTAL_SI_WL_RFC_S1, &wl_rfc_s1);\n\tif (ret)\n\t\treturn ret;\n\twl_rfc_s1 &= ~XTAL_SI_RF10S_EN;\n\tret = rtw89_mac_write_xtal_si(rtwdev, XTAL_SI_WL_RFC_S1, wl_rfc_s1,\n\t\t\t\t      FULL_BIT_MASK);\n\treturn ret;\n}\n\nstatic const struct rtw89_chip_ops rtw8851b_chip_ops = {\n\t.enable_bb_rf\t\t= rtw8851b_mac_enable_bb_rf,\n\t.disable_bb_rf\t\t= rtw8851b_mac_disable_bb_rf,\n\t.bb_reset\t\t= rtw8851b_bb_reset,\n\t.bb_sethw\t\t= rtw8851b_bb_sethw,\n\t.read_rf\t\t= rtw89_phy_read_rf_v1,\n\t.write_rf\t\t= rtw89_phy_write_rf_v1,\n\t.set_channel\t\t= rtw8851b_set_channel,\n\t.set_channel_help\t= rtw8851b_set_channel_help,\n\t.read_efuse\t\t= rtw8851b_read_efuse,\n\t.read_phycap\t\t= rtw8851b_read_phycap,\n\t.fem_setup\t\t= NULL,\n\t.rfe_gpio\t\t= rtw8851b_rfe_gpio,\n\t.rfk_init\t\t= rtw8851b_rfk_init,\n\t.rfk_channel\t\t= rtw8851b_rfk_channel,\n\t.rfk_band_changed\t= rtw8851b_rfk_band_changed,\n\t.rfk_scan\t\t= rtw8851b_rfk_scan,\n\t.rfk_track\t\t= rtw8851b_rfk_track,\n\t.power_trim\t\t= rtw8851b_power_trim,\n\t.set_txpwr\t\t= rtw8851b_set_txpwr,\n\t.set_txpwr_ctrl\t\t= rtw8851b_set_txpwr_ctrl,\n\t.init_txpwr_unit\t= rtw8851b_init_txpwr_unit,\n\t.get_thermal\t\t= rtw8851b_get_thermal,\n\t.ctrl_btg\t\t= rtw8851b_ctrl_btg,\n\t.query_ppdu\t\t= rtw8851b_query_ppdu,\n\t.bb_ctrl_btc_preagc\t= rtw8851b_bb_ctrl_btc_preagc,\n\t.cfg_txrx_path\t\t= rtw8851b_bb_cfg_txrx_path,\n\t.set_txpwr_ul_tb_offset\t= rtw8851b_set_txpwr_ul_tb_offset,\n\t.pwr_on_func\t\t= rtw8851b_pwr_on_func,\n\t.pwr_off_func\t\t= rtw8851b_pwr_off_func,\n\t.query_rxdesc\t\t= rtw89_core_query_rxdesc,\n\t.fill_txdesc\t\t= rtw89_core_fill_txdesc,\n\t.fill_txdesc_fwcmd\t= rtw89_core_fill_txdesc,\n\t.cfg_ctrl_path\t\t= rtw89_mac_cfg_ctrl_path,\n\t.mac_cfg_gnt\t\t= rtw89_mac_cfg_gnt,\n\t.stop_sch_tx\t\t= rtw89_mac_stop_sch_tx,\n\t.resume_sch_tx\t\t= rtw89_mac_resume_sch_tx,\n\t.h2c_dctl_sec_cam\t= NULL,\n\n\t.btc_set_rfe\t\t= rtw8851b_btc_set_rfe,\n\t.btc_init_cfg\t\t= rtw8851b_btc_init_cfg,\n\t.btc_set_wl_pri\t\t= rtw8851b_btc_set_wl_pri,\n\t.btc_set_wl_txpwr_ctrl\t= rtw8851b_btc_set_wl_txpwr_ctrl,\n\t.btc_get_bt_rssi\t= rtw8851b_btc_get_bt_rssi,\n\t.btc_update_bt_cnt\t= rtw8851b_btc_update_bt_cnt,\n\t.btc_wl_s1_standby\t= rtw8851b_btc_wl_s1_standby,\n\t.btc_set_wl_rx_gain\t= rtw8851b_btc_set_wl_rx_gain,\n\t.btc_set_policy\t\t= rtw89_btc_set_policy_v1,\n};\n\n#ifdef CONFIG_PM\nstatic const struct wiphy_wowlan_support rtw_wowlan_stub_8851b = {\n\t.flags = WIPHY_WOWLAN_MAGIC_PKT | WIPHY_WOWLAN_DISCONNECT,\n\t.n_patterns = RTW89_MAX_PATTERN_NUM,\n\t.pattern_max_len = RTW89_MAX_PATTERN_SIZE,\n\t.pattern_min_len = 1,\n};\n#endif\n\nconst struct rtw89_chip_info rtw8851b_chip_info = {\n\t.chip_id\t\t= RTL8851B,\n\t.chip_gen\t\t= RTW89_CHIP_AX,\n\t.ops\t\t\t= &rtw8851b_chip_ops,\n\t.mac_def\t\t= &rtw89_mac_gen_ax,\n\t.phy_def\t\t= &rtw89_phy_gen_ax,\n\t.fw_basename\t\t= RTW8851B_FW_BASENAME,\n\t.fw_format_max\t\t= RTW8851B_FW_FORMAT_MAX,\n\t.try_ce_fw\t\t= true,\n\t.needed_fw_elms\t\t= 0,\n\t.fifo_size\t\t= 196608,\n\t.small_fifo_size\t= true,\n\t.dle_scc_rsvd_size\t= 98304,\n\t.max_amsdu_limit\t= 3500,\n\t.dis_2g_40m_ul_ofdma\t= true,\n\t.rsvd_ple_ofst\t\t= 0x2f800,\n\t.hfc_param_ini\t\t= rtw8851b_hfc_param_ini_pcie,\n\t.dle_mem\t\t= rtw8851b_dle_mem_pcie,\n\t.wde_qempty_acq_num     = 4,\n\t.wde_qempty_mgq_sel     = 4,\n\t.rf_base_addr\t\t= {0xe000},\n\t.pwr_on_seq\t\t= NULL,\n\t.pwr_off_seq\t\t= NULL,\n\t.bb_table\t\t= &rtw89_8851b_phy_bb_table,\n\t.bb_gain_table\t\t= &rtw89_8851b_phy_bb_gain_table,\n\t.rf_table\t\t= {&rtw89_8851b_phy_radioa_table,},\n\t.nctl_table\t\t= &rtw89_8851b_phy_nctl_table,\n\t.nctl_post_table\t= &rtw8851b_nctl_post_defs_tbl,\n\t.byr_table\t\t= &rtw89_8851b_byr_table,\n\t.dflt_parms\t\t= &rtw89_8851b_dflt_parms,\n\t.rfe_parms_conf\t\t= rtw89_8851b_rfe_parms_conf,\n\t.txpwr_factor_rf\t= 2,\n\t.txpwr_factor_mac\t= 1,\n\t.dig_table\t\t= NULL,\n\t.dig_regs\t\t= &rtw8851b_dig_regs,\n\t.tssi_dbw_table\t\t= NULL,\n\t.support_chanctx_num\t= 0,\n\t.support_bands\t\t= BIT(NL80211_BAND_2GHZ) |\n\t\t\t\t  BIT(NL80211_BAND_5GHZ),\n\t.support_bw160\t\t= false,\n\t.support_unii4\t\t= true,\n\t.support_ul_tb_ctrl\t= true,\n\t.hw_sec_hdr\t\t= false,\n\t.rf_path_num\t\t= 1,\n\t.tx_nss\t\t\t= 1,\n\t.rx_nss\t\t\t= 1,\n\t.acam_num\t\t= 32,\n\t.bcam_num\t\t= 20,\n\t.scam_num\t\t= 128,\n\t.bacam_num\t\t= 2,\n\t.bacam_dynamic_num\t= 4,\n\t.bacam_ver\t\t= RTW89_BACAM_V0,\n\t.sec_ctrl_efuse_size\t= 4,\n\t.physical_efuse_size\t= 1216,\n\t.logical_efuse_size\t= 2048,\n\t.limit_efuse_size\t= 1280,\n\t.dav_phy_efuse_size\t= 0,\n\t.dav_log_efuse_size\t= 0,\n\t.phycap_addr\t\t= 0x580,\n\t.phycap_size\t\t= 128,\n\t.para_ver\t\t= 0,\n\t.wlcx_desired\t\t= 0x06000000,\n\t.btcx_desired\t\t= 0x7,\n\t.scbd\t\t\t= 0x1,\n\t.mailbox\t\t= 0x1,\n\n\t.afh_guard_ch\t\t= 6,\n\t.wl_rssi_thres\t\t= rtw89_btc_8851b_wl_rssi_thres,\n\t.bt_rssi_thres\t\t= rtw89_btc_8851b_bt_rssi_thres,\n\t.rssi_tol\t\t= 2,\n\t.mon_reg_num\t\t= ARRAY_SIZE(rtw89_btc_8851b_mon_reg),\n\t.mon_reg\t\t= rtw89_btc_8851b_mon_reg,\n\t.rf_para_ulink_num\t= ARRAY_SIZE(rtw89_btc_8851b_rf_ul),\n\t.rf_para_ulink\t\t= rtw89_btc_8851b_rf_ul,\n\t.rf_para_dlink_num\t= ARRAY_SIZE(rtw89_btc_8851b_rf_dl),\n\t.rf_para_dlink\t\t= rtw89_btc_8851b_rf_dl,\n\t.ps_mode_supported\t= BIT(RTW89_PS_MODE_RFOFF) |\n\t\t\t\t  BIT(RTW89_PS_MODE_CLK_GATED),\n\t.low_power_hci_modes\t= 0,\n\t.h2c_cctl_func_id\t= H2C_FUNC_MAC_CCTLINFO_UD,\n\t.hci_func_en_addr\t= R_AX_HCI_FUNC_EN,\n\t.h2c_desc_size\t\t= sizeof(struct rtw89_txwd_body),\n\t.txwd_body_size\t\t= sizeof(struct rtw89_txwd_body),\n\t.h2c_ctrl_reg\t\t= R_AX_H2CREG_CTRL,\n\t.h2c_counter_reg\t= {R_AX_UDM1 + 1, B_AX_UDM1_HALMAC_H2C_DEQ_CNT_MASK >> 8},\n\t.h2c_regs\t\t= rtw8851b_h2c_regs,\n\t.c2h_ctrl_reg\t\t= R_AX_C2HREG_CTRL,\n\t.c2h_counter_reg\t= {R_AX_UDM1 + 1, B_AX_UDM1_HALMAC_C2H_ENQ_CNT_MASK >> 8},\n\t.c2h_regs\t\t= rtw8851b_c2h_regs,\n\t.page_regs\t\t= &rtw8851b_page_regs,\n\t.cfo_src_fd\t\t= true,\n\t.cfo_hw_comp\t\t= true,\n\t.dcfo_comp\t\t= &rtw8851b_dcfo_comp,\n\t.dcfo_comp_sft\t\t= 12,\n\t.imr_info\t\t= &rtw8851b_imr_info,\n\t.rrsr_cfgs\t\t= &rtw8851b_rrsr_cfgs,\n\t.bss_clr_map_reg\t= R_BSS_CLR_MAP_V1,\n\t.dma_ch_mask\t\t= BIT(RTW89_DMA_ACH4) | BIT(RTW89_DMA_ACH5) |\n\t\t\t\t  BIT(RTW89_DMA_ACH6) | BIT(RTW89_DMA_ACH7) |\n\t\t\t\t  BIT(RTW89_DMA_B1MG) | BIT(RTW89_DMA_B1HI),\n\t.edcca_lvl_reg\t\t= R_SEG0R_EDCCA_LVL_V1,\n#ifdef CONFIG_PM\n\t.wowlan_stub\t\t= &rtw_wowlan_stub_8851b,\n#endif\n\t.xtal_info\t\t= &rtw8851b_xtal_info,\n};\nEXPORT_SYMBOL(rtw8851b_chip_info);\n\nMODULE_FIRMWARE(RTW8851B_MODULE_FIRMWARE);\nMODULE_AUTHOR(\"Realtek Corporation\");\nMODULE_DESCRIPTION(\"Realtek 802.11ax wireless 8851B driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}