{
  "module_name": "core.c",
  "hash_id": "96149bcbb0430a5dec48c3252810e5ab7072eba6c8a1864fd53d45c5cb6cf779",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtw89/core.c",
  "human_readable_source": "\n \n#include <linux/ip.h>\n#include <linux/udp.h>\n\n#include \"cam.h\"\n#include \"chan.h\"\n#include \"coex.h\"\n#include \"core.h\"\n#include \"efuse.h\"\n#include \"fw.h\"\n#include \"mac.h\"\n#include \"phy.h\"\n#include \"ps.h\"\n#include \"reg.h\"\n#include \"sar.h\"\n#include \"ser.h\"\n#include \"txrx.h\"\n#include \"util.h\"\n\nstatic bool rtw89_disable_ps_mode;\nmodule_param_named(disable_ps_mode, rtw89_disable_ps_mode, bool, 0644);\nMODULE_PARM_DESC(disable_ps_mode, \"Set Y to disable low power mode\");\n\n#define RTW89_DEF_CHAN(_freq, _hw_val, _flags, _band)\t\\\n\t{ .center_freq = _freq, .hw_value = _hw_val, .flags = _flags, .band = _band, }\n#define RTW89_DEF_CHAN_2G(_freq, _hw_val)\t\\\n\tRTW89_DEF_CHAN(_freq, _hw_val, 0, NL80211_BAND_2GHZ)\n#define RTW89_DEF_CHAN_5G(_freq, _hw_val)\t\\\n\tRTW89_DEF_CHAN(_freq, _hw_val, 0, NL80211_BAND_5GHZ)\n#define RTW89_DEF_CHAN_5G_NO_HT40MINUS(_freq, _hw_val)\t\\\n\tRTW89_DEF_CHAN(_freq, _hw_val, IEEE80211_CHAN_NO_HT40MINUS, NL80211_BAND_5GHZ)\n#define RTW89_DEF_CHAN_6G(_freq, _hw_val)\t\\\n\tRTW89_DEF_CHAN(_freq, _hw_val, 0, NL80211_BAND_6GHZ)\n\nstatic struct ieee80211_channel rtw89_channels_2ghz[] = {\n\tRTW89_DEF_CHAN_2G(2412, 1),\n\tRTW89_DEF_CHAN_2G(2417, 2),\n\tRTW89_DEF_CHAN_2G(2422, 3),\n\tRTW89_DEF_CHAN_2G(2427, 4),\n\tRTW89_DEF_CHAN_2G(2432, 5),\n\tRTW89_DEF_CHAN_2G(2437, 6),\n\tRTW89_DEF_CHAN_2G(2442, 7),\n\tRTW89_DEF_CHAN_2G(2447, 8),\n\tRTW89_DEF_CHAN_2G(2452, 9),\n\tRTW89_DEF_CHAN_2G(2457, 10),\n\tRTW89_DEF_CHAN_2G(2462, 11),\n\tRTW89_DEF_CHAN_2G(2467, 12),\n\tRTW89_DEF_CHAN_2G(2472, 13),\n\tRTW89_DEF_CHAN_2G(2484, 14),\n};\n\nstatic struct ieee80211_channel rtw89_channels_5ghz[] = {\n\tRTW89_DEF_CHAN_5G(5180, 36),\n\tRTW89_DEF_CHAN_5G(5200, 40),\n\tRTW89_DEF_CHAN_5G(5220, 44),\n\tRTW89_DEF_CHAN_5G(5240, 48),\n\tRTW89_DEF_CHAN_5G(5260, 52),\n\tRTW89_DEF_CHAN_5G(5280, 56),\n\tRTW89_DEF_CHAN_5G(5300, 60),\n\tRTW89_DEF_CHAN_5G(5320, 64),\n\tRTW89_DEF_CHAN_5G(5500, 100),\n\tRTW89_DEF_CHAN_5G(5520, 104),\n\tRTW89_DEF_CHAN_5G(5540, 108),\n\tRTW89_DEF_CHAN_5G(5560, 112),\n\tRTW89_DEF_CHAN_5G(5580, 116),\n\tRTW89_DEF_CHAN_5G(5600, 120),\n\tRTW89_DEF_CHAN_5G(5620, 124),\n\tRTW89_DEF_CHAN_5G(5640, 128),\n\tRTW89_DEF_CHAN_5G(5660, 132),\n\tRTW89_DEF_CHAN_5G(5680, 136),\n\tRTW89_DEF_CHAN_5G(5700, 140),\n\tRTW89_DEF_CHAN_5G(5720, 144),\n\tRTW89_DEF_CHAN_5G(5745, 149),\n\tRTW89_DEF_CHAN_5G(5765, 153),\n\tRTW89_DEF_CHAN_5G(5785, 157),\n\tRTW89_DEF_CHAN_5G(5805, 161),\n\tRTW89_DEF_CHAN_5G_NO_HT40MINUS(5825, 165),\n\tRTW89_DEF_CHAN_5G(5845, 169),\n\tRTW89_DEF_CHAN_5G(5865, 173),\n\tRTW89_DEF_CHAN_5G(5885, 177),\n};\n\nstatic struct ieee80211_channel rtw89_channels_6ghz[] = {\n\tRTW89_DEF_CHAN_6G(5955, 1),\n\tRTW89_DEF_CHAN_6G(5975, 5),\n\tRTW89_DEF_CHAN_6G(5995, 9),\n\tRTW89_DEF_CHAN_6G(6015, 13),\n\tRTW89_DEF_CHAN_6G(6035, 17),\n\tRTW89_DEF_CHAN_6G(6055, 21),\n\tRTW89_DEF_CHAN_6G(6075, 25),\n\tRTW89_DEF_CHAN_6G(6095, 29),\n\tRTW89_DEF_CHAN_6G(6115, 33),\n\tRTW89_DEF_CHAN_6G(6135, 37),\n\tRTW89_DEF_CHAN_6G(6155, 41),\n\tRTW89_DEF_CHAN_6G(6175, 45),\n\tRTW89_DEF_CHAN_6G(6195, 49),\n\tRTW89_DEF_CHAN_6G(6215, 53),\n\tRTW89_DEF_CHAN_6G(6235, 57),\n\tRTW89_DEF_CHAN_6G(6255, 61),\n\tRTW89_DEF_CHAN_6G(6275, 65),\n\tRTW89_DEF_CHAN_6G(6295, 69),\n\tRTW89_DEF_CHAN_6G(6315, 73),\n\tRTW89_DEF_CHAN_6G(6335, 77),\n\tRTW89_DEF_CHAN_6G(6355, 81),\n\tRTW89_DEF_CHAN_6G(6375, 85),\n\tRTW89_DEF_CHAN_6G(6395, 89),\n\tRTW89_DEF_CHAN_6G(6415, 93),\n\tRTW89_DEF_CHAN_6G(6435, 97),\n\tRTW89_DEF_CHAN_6G(6455, 101),\n\tRTW89_DEF_CHAN_6G(6475, 105),\n\tRTW89_DEF_CHAN_6G(6495, 109),\n\tRTW89_DEF_CHAN_6G(6515, 113),\n\tRTW89_DEF_CHAN_6G(6535, 117),\n\tRTW89_DEF_CHAN_6G(6555, 121),\n\tRTW89_DEF_CHAN_6G(6575, 125),\n\tRTW89_DEF_CHAN_6G(6595, 129),\n\tRTW89_DEF_CHAN_6G(6615, 133),\n\tRTW89_DEF_CHAN_6G(6635, 137),\n\tRTW89_DEF_CHAN_6G(6655, 141),\n\tRTW89_DEF_CHAN_6G(6675, 145),\n\tRTW89_DEF_CHAN_6G(6695, 149),\n\tRTW89_DEF_CHAN_6G(6715, 153),\n\tRTW89_DEF_CHAN_6G(6735, 157),\n\tRTW89_DEF_CHAN_6G(6755, 161),\n\tRTW89_DEF_CHAN_6G(6775, 165),\n\tRTW89_DEF_CHAN_6G(6795, 169),\n\tRTW89_DEF_CHAN_6G(6815, 173),\n\tRTW89_DEF_CHAN_6G(6835, 177),\n\tRTW89_DEF_CHAN_6G(6855, 181),\n\tRTW89_DEF_CHAN_6G(6875, 185),\n\tRTW89_DEF_CHAN_6G(6895, 189),\n\tRTW89_DEF_CHAN_6G(6915, 193),\n\tRTW89_DEF_CHAN_6G(6935, 197),\n\tRTW89_DEF_CHAN_6G(6955, 201),\n\tRTW89_DEF_CHAN_6G(6975, 205),\n\tRTW89_DEF_CHAN_6G(6995, 209),\n\tRTW89_DEF_CHAN_6G(7015, 213),\n\tRTW89_DEF_CHAN_6G(7035, 217),\n\tRTW89_DEF_CHAN_6G(7055, 221),\n\tRTW89_DEF_CHAN_6G(7075, 225),\n\tRTW89_DEF_CHAN_6G(7095, 229),\n\tRTW89_DEF_CHAN_6G(7115, 233),\n};\n\nstatic struct ieee80211_rate rtw89_bitrates[] = {\n\t{ .bitrate = 10,  .hw_value = 0x00, },\n\t{ .bitrate = 20,  .hw_value = 0x01, },\n\t{ .bitrate = 55,  .hw_value = 0x02, },\n\t{ .bitrate = 110, .hw_value = 0x03, },\n\t{ .bitrate = 60,  .hw_value = 0x04, },\n\t{ .bitrate = 90,  .hw_value = 0x05, },\n\t{ .bitrate = 120, .hw_value = 0x06, },\n\t{ .bitrate = 180, .hw_value = 0x07, },\n\t{ .bitrate = 240, .hw_value = 0x08, },\n\t{ .bitrate = 360, .hw_value = 0x09, },\n\t{ .bitrate = 480, .hw_value = 0x0a, },\n\t{ .bitrate = 540, .hw_value = 0x0b, },\n};\n\nstatic const struct ieee80211_iface_limit rtw89_iface_limits[] = {\n\t{\n\t\t.max = 1,\n\t\t.types = BIT(NL80211_IFTYPE_STATION),\n\t},\n\t{\n\t\t.max = 1,\n\t\t.types = BIT(NL80211_IFTYPE_P2P_CLIENT) |\n\t\t\t BIT(NL80211_IFTYPE_P2P_GO) |\n\t\t\t BIT(NL80211_IFTYPE_AP),\n\t},\n};\n\nstatic const struct ieee80211_iface_combination rtw89_iface_combs[] = {\n\t{\n\t\t.limits = rtw89_iface_limits,\n\t\t.n_limits = ARRAY_SIZE(rtw89_iface_limits),\n\t\t.max_interfaces = 2,\n\t\t.num_different_channels = 1,\n\t}\n};\n\nbool rtw89_ra_report_to_bitrate(struct rtw89_dev *rtwdev, u8 rpt_rate, u16 *bitrate)\n{\n\tstruct ieee80211_rate rate;\n\n\tif (unlikely(rpt_rate >= ARRAY_SIZE(rtw89_bitrates))) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_UNEXP, \"invalid rpt rate %d\\n\", rpt_rate);\n\t\treturn false;\n\t}\n\n\trate = rtw89_bitrates[rpt_rate];\n\t*bitrate = rate.bitrate;\n\n\treturn true;\n}\n\nstatic const struct ieee80211_supported_band rtw89_sband_2ghz = {\n\t.band\t\t= NL80211_BAND_2GHZ,\n\t.channels\t= rtw89_channels_2ghz,\n\t.n_channels\t= ARRAY_SIZE(rtw89_channels_2ghz),\n\t.bitrates\t= rtw89_bitrates,\n\t.n_bitrates\t= ARRAY_SIZE(rtw89_bitrates),\n\t.ht_cap\t\t= {0},\n\t.vht_cap\t= {0},\n};\n\nstatic const struct ieee80211_supported_band rtw89_sband_5ghz = {\n\t.band\t\t= NL80211_BAND_5GHZ,\n\t.channels\t= rtw89_channels_5ghz,\n\t.n_channels\t= ARRAY_SIZE(rtw89_channels_5ghz),\n\n\t \n\t.bitrates\t= rtw89_bitrates + 4,\n\t.n_bitrates\t= ARRAY_SIZE(rtw89_bitrates) - 4,\n\t.ht_cap\t\t= {0},\n\t.vht_cap\t= {0},\n};\n\nstatic const struct ieee80211_supported_band rtw89_sband_6ghz = {\n\t.band\t\t= NL80211_BAND_6GHZ,\n\t.channels\t= rtw89_channels_6ghz,\n\t.n_channels\t= ARRAY_SIZE(rtw89_channels_6ghz),\n\n\t \n\t.bitrates\t= rtw89_bitrates + 4,\n\t.n_bitrates\t= ARRAY_SIZE(rtw89_bitrates) - 4,\n};\n\nstatic void rtw89_traffic_stats_accu(struct rtw89_dev *rtwdev,\n\t\t\t\t     struct rtw89_traffic_stats *stats,\n\t\t\t\t     struct sk_buff *skb, bool tx)\n{\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\n\tif (!ieee80211_is_data(hdr->frame_control))\n\t\treturn;\n\n\tif (is_broadcast_ether_addr(hdr->addr1) ||\n\t    is_multicast_ether_addr(hdr->addr1))\n\t\treturn;\n\n\tif (tx) {\n\t\tstats->tx_cnt++;\n\t\tstats->tx_unicast += skb->len;\n\t} else {\n\t\tstats->rx_cnt++;\n\t\tstats->rx_unicast += skb->len;\n\t}\n}\n\nvoid rtw89_get_default_chandef(struct cfg80211_chan_def *chandef)\n{\n\tcfg80211_chandef_create(chandef, &rtw89_channels_2ghz[0],\n\t\t\t\tNL80211_CHAN_NO_HT);\n}\n\nvoid rtw89_get_channel_params(const struct cfg80211_chan_def *chandef,\n\t\t\t      struct rtw89_chan *chan)\n{\n\tstruct ieee80211_channel *channel = chandef->chan;\n\tenum nl80211_chan_width width = chandef->width;\n\tu32 primary_freq, center_freq;\n\tu8 center_chan;\n\tu8 bandwidth = RTW89_CHANNEL_WIDTH_20;\n\tu32 offset;\n\tu8 band;\n\n\tcenter_chan = channel->hw_value;\n\tprimary_freq = channel->center_freq;\n\tcenter_freq = chandef->center_freq1;\n\n\tswitch (width) {\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\tcase NL80211_CHAN_WIDTH_20:\n\t\tbandwidth = RTW89_CHANNEL_WIDTH_20;\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_40:\n\t\tbandwidth = RTW89_CHANNEL_WIDTH_40;\n\t\tif (primary_freq > center_freq) {\n\t\t\tcenter_chan -= 2;\n\t\t} else {\n\t\t\tcenter_chan += 2;\n\t\t}\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_80:\n\tcase NL80211_CHAN_WIDTH_160:\n\t\tbandwidth = nl_to_rtw89_bandwidth(width);\n\t\tif (primary_freq > center_freq) {\n\t\t\toffset = (primary_freq - center_freq - 10) / 20;\n\t\t\tcenter_chan -= 2 + offset * 4;\n\t\t} else {\n\t\t\toffset = (center_freq - primary_freq - 10) / 20;\n\t\t\tcenter_chan += 2 + offset * 4;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tcenter_chan = 0;\n\t\tbreak;\n\t}\n\n\tswitch (channel->band) {\n\tdefault:\n\tcase NL80211_BAND_2GHZ:\n\t\tband = RTW89_BAND_2G;\n\t\tbreak;\n\tcase NL80211_BAND_5GHZ:\n\t\tband = RTW89_BAND_5G;\n\t\tbreak;\n\tcase NL80211_BAND_6GHZ:\n\t\tband = RTW89_BAND_6G;\n\t\tbreak;\n\t}\n\n\trtw89_chan_create(chan, center_chan, channel->hw_value, band, bandwidth);\n}\n\nvoid rtw89_core_set_chip_txpwr(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_hal *hal = &rtwdev->hal;\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tconst struct rtw89_chan *chan;\n\tenum rtw89_sub_entity_idx sub_entity_idx;\n\tenum rtw89_sub_entity_idx roc_idx;\n\tenum rtw89_phy_idx phy_idx;\n\tenum rtw89_entity_mode mode;\n\tbool entity_active;\n\n\tentity_active = rtw89_get_entity_state(rtwdev);\n\tif (!entity_active)\n\t\treturn;\n\n\tmode = rtw89_get_entity_mode(rtwdev);\n\tswitch (mode) {\n\tcase RTW89_ENTITY_MODE_SCC:\n\tcase RTW89_ENTITY_MODE_MCC:\n\t\tsub_entity_idx = RTW89_SUB_ENTITY_0;\n\t\tbreak;\n\tcase RTW89_ENTITY_MODE_MCC_PREPARE:\n\t\tsub_entity_idx = RTW89_SUB_ENTITY_1;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"Invalid ent mode: %d\\n\", mode);\n\t\treturn;\n\t}\n\n\troc_idx = atomic_read(&hal->roc_entity_idx);\n\tif (roc_idx != RTW89_SUB_ENTITY_IDLE)\n\t\tsub_entity_idx = roc_idx;\n\n\tphy_idx = RTW89_PHY_0;\n\tchan = rtw89_chan_get(rtwdev, sub_entity_idx);\n\tchip->ops->set_txpwr(rtwdev, chan, phy_idx);\n}\n\nvoid rtw89_set_channel(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_hal *hal = &rtwdev->hal;\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tconst struct rtw89_chan_rcd *chan_rcd;\n\tconst struct rtw89_chan *chan;\n\tenum rtw89_sub_entity_idx sub_entity_idx;\n\tenum rtw89_sub_entity_idx roc_idx;\n\tenum rtw89_mac_idx mac_idx;\n\tenum rtw89_phy_idx phy_idx;\n\tstruct rtw89_channel_help_params bak;\n\tenum rtw89_entity_mode mode;\n\tbool entity_active;\n\n\tentity_active = rtw89_get_entity_state(rtwdev);\n\n\tmode = rtw89_entity_recalc(rtwdev);\n\tswitch (mode) {\n\tcase RTW89_ENTITY_MODE_SCC:\n\tcase RTW89_ENTITY_MODE_MCC:\n\t\tsub_entity_idx = RTW89_SUB_ENTITY_0;\n\t\tbreak;\n\tcase RTW89_ENTITY_MODE_MCC_PREPARE:\n\t\tsub_entity_idx = RTW89_SUB_ENTITY_1;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"Invalid ent mode: %d\\n\", mode);\n\t\treturn;\n\t}\n\n\troc_idx = atomic_read(&hal->roc_entity_idx);\n\tif (roc_idx != RTW89_SUB_ENTITY_IDLE)\n\t\tsub_entity_idx = roc_idx;\n\n\tmac_idx = RTW89_MAC_0;\n\tphy_idx = RTW89_PHY_0;\n\n\tchan = rtw89_chan_get(rtwdev, sub_entity_idx);\n\tchan_rcd = rtw89_chan_rcd_get(rtwdev, sub_entity_idx);\n\n\trtw89_chip_set_channel_prepare(rtwdev, &bak, chan, mac_idx, phy_idx);\n\n\tchip->ops->set_channel(rtwdev, chan, mac_idx, phy_idx);\n\n\tchip->ops->set_txpwr(rtwdev, chan, phy_idx);\n\n\trtw89_chip_set_channel_done(rtwdev, &bak, chan, mac_idx, phy_idx);\n\n\tif (!entity_active || chan_rcd->band_changed) {\n\t\trtw89_btc_ntfy_switch_band(rtwdev, phy_idx, chan->band_type);\n\t\trtw89_chip_rfk_band_changed(rtwdev, phy_idx);\n\t}\n\n\trtw89_set_entity_state(rtwdev, true);\n}\n\nvoid rtw89_get_channel(struct rtw89_dev *rtwdev, struct rtw89_vif *rtwvif,\n\t\t       struct rtw89_chan *chan)\n{\n\tconst struct cfg80211_chan_def *chandef;\n\n\tchandef = rtw89_chandef_get(rtwdev, rtwvif->sub_entity_idx);\n\trtw89_get_channel_params(chandef, chan);\n}\n\nstatic enum rtw89_core_tx_type\nrtw89_core_get_tx_type(struct rtw89_dev *rtwdev,\n\t\t       struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\t__le16 fc = hdr->frame_control;\n\n\tif (ieee80211_is_mgmt(fc) || ieee80211_is_nullfunc(fc))\n\t\treturn RTW89_CORE_TX_TYPE_MGMT;\n\n\treturn RTW89_CORE_TX_TYPE_DATA;\n}\n\nstatic void\nrtw89_core_tx_update_ampdu_info(struct rtw89_dev *rtwdev,\n\t\t\t\tstruct rtw89_core_tx_request *tx_req,\n\t\t\t\tenum btc_pkt_type pkt_type)\n{\n\tstruct ieee80211_sta *sta = tx_req->sta;\n\tstruct rtw89_tx_desc_info *desc_info = &tx_req->desc_info;\n\tstruct sk_buff *skb = tx_req->skb;\n\tstruct rtw89_sta *rtwsta;\n\tu8 ampdu_num;\n\tu8 tid;\n\n\tif (pkt_type == PACKET_EAPOL) {\n\t\tdesc_info->bk = true;\n\t\treturn;\n\t}\n\n\tif (!(IEEE80211_SKB_CB(skb)->flags & IEEE80211_TX_CTL_AMPDU))\n\t\treturn;\n\n\tif (!sta) {\n\t\trtw89_warn(rtwdev, \"cannot set ampdu info without sta\\n\");\n\t\treturn;\n\t}\n\n\ttid = skb->priority & IEEE80211_QOS_CTL_TAG1D_MASK;\n\trtwsta = (struct rtw89_sta *)sta->drv_priv;\n\n\tampdu_num = (u8)((rtwsta->ampdu_params[tid].agg_num ?\n\t\t\t  rtwsta->ampdu_params[tid].agg_num :\n\t\t\t  4 << sta->deflink.ht_cap.ampdu_factor) - 1);\n\n\tdesc_info->agg_en = true;\n\tdesc_info->ampdu_density = sta->deflink.ht_cap.ampdu_density;\n\tdesc_info->ampdu_num = ampdu_num;\n}\n\nstatic void\nrtw89_core_tx_update_sec_key(struct rtw89_dev *rtwdev,\n\t\t\t     struct rtw89_core_tx_request *tx_req)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tstruct ieee80211_vif *vif = tx_req->vif;\n\tstruct ieee80211_sta *sta = tx_req->sta;\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211_key_conf *key;\n\tstruct rtw89_vif *rtwvif;\n\tstruct rtw89_sta *rtwsta = sta_to_rtwsta_safe(sta);\n\tstruct rtw89_addr_cam_entry *addr_cam;\n\tstruct rtw89_sec_cam_entry *sec_cam;\n\tstruct rtw89_tx_desc_info *desc_info = &tx_req->desc_info;\n\tstruct sk_buff *skb = tx_req->skb;\n\tu8 sec_type = RTW89_SEC_KEY_TYPE_NONE;\n\tu64 pn64;\n\n\tif (!vif) {\n\t\trtw89_warn(rtwdev, \"cannot set sec key without vif\\n\");\n\t\treturn;\n\t}\n\n\trtwvif = (struct rtw89_vif *)vif->drv_priv;\n\taddr_cam = rtw89_get_addr_cam_of(rtwvif, rtwsta);\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\tkey = info->control.hw_key;\n\tsec_cam = addr_cam->sec_entries[key->hw_key_idx];\n\tif (!sec_cam) {\n\t\trtw89_warn(rtwdev, \"sec cam entry is empty\\n\");\n\t\treturn;\n\t}\n\n\tswitch (key->cipher) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\tsec_type = RTW89_SEC_KEY_TYPE_WEP40;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\tsec_type = RTW89_SEC_KEY_TYPE_WEP104;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\tsec_type = RTW89_SEC_KEY_TYPE_TKIP;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tsec_type = RTW89_SEC_KEY_TYPE_CCMP128;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP_256:\n\t\tsec_type = RTW89_SEC_KEY_TYPE_CCMP256;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_GCMP:\n\t\tsec_type = RTW89_SEC_KEY_TYPE_GCMP128;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\tsec_type = RTW89_SEC_KEY_TYPE_GCMP256;\n\t\tbreak;\n\tdefault:\n\t\trtw89_warn(rtwdev, \"key cipher not supported %d\\n\", key->cipher);\n\t\treturn;\n\t}\n\n\tdesc_info->sec_en = true;\n\tdesc_info->sec_keyid = key->keyidx;\n\tdesc_info->sec_type = sec_type;\n\tdesc_info->sec_cam_idx = sec_cam->sec_cam_idx;\n\n\tif (!chip->hw_sec_hdr)\n\t\treturn;\n\n\tpn64 = atomic64_inc_return(&key->tx_pn);\n\tdesc_info->sec_seq[0] = pn64;\n\tdesc_info->sec_seq[1] = pn64 >> 8;\n\tdesc_info->sec_seq[2] = pn64 >> 16;\n\tdesc_info->sec_seq[3] = pn64 >> 24;\n\tdesc_info->sec_seq[4] = pn64 >> 32;\n\tdesc_info->sec_seq[5] = pn64 >> 40;\n\tdesc_info->wp_offset = 1;  \n}\n\nstatic u16 rtw89_core_get_mgmt_rate(struct rtw89_dev *rtwdev,\n\t\t\t\t    struct rtw89_core_tx_request *tx_req,\n\t\t\t\t    const struct rtw89_chan *chan)\n{\n\tstruct sk_buff *skb = tx_req->skb;\n\tstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_vif *vif = tx_info->control.vif;\n\tu16 lowest_rate;\n\n\tif (tx_info->flags & IEEE80211_TX_CTL_NO_CCK_RATE ||\n\t    (vif && vif->p2p))\n\t\tlowest_rate = RTW89_HW_RATE_OFDM6;\n\telse if (chan->band_type == RTW89_BAND_2G)\n\t\tlowest_rate = RTW89_HW_RATE_CCK1;\n\telse\n\t\tlowest_rate = RTW89_HW_RATE_OFDM6;\n\n\tif (!vif || !vif->bss_conf.basic_rates || !tx_req->sta)\n\t\treturn lowest_rate;\n\n\treturn __ffs(vif->bss_conf.basic_rates) + lowest_rate;\n}\n\nstatic u8 rtw89_core_tx_get_mac_id(struct rtw89_dev *rtwdev,\n\t\t\t\t   struct rtw89_core_tx_request *tx_req)\n{\n\tstruct ieee80211_vif *vif = tx_req->vif;\n\tstruct rtw89_vif *rtwvif = (struct rtw89_vif *)vif->drv_priv;\n\tstruct ieee80211_sta *sta = tx_req->sta;\n\tstruct rtw89_sta *rtwsta;\n\n\tif (!sta)\n\t\treturn rtwvif->mac_id;\n\n\trtwsta = (struct rtw89_sta *)sta->drv_priv;\n\treturn rtwsta->mac_id;\n}\n\nstatic void\nrtw89_core_tx_update_mgmt_info(struct rtw89_dev *rtwdev,\n\t\t\t       struct rtw89_core_tx_request *tx_req)\n{\n\tstruct ieee80211_vif *vif = tx_req->vif;\n\tstruct rtw89_vif *rtwvif = (struct rtw89_vif *)vif->drv_priv;\n\tstruct rtw89_tx_desc_info *desc_info = &tx_req->desc_info;\n\tconst struct rtw89_chan *chan = rtw89_chan_get(rtwdev,\n\t\t\t\t\t\t       rtwvif->sub_entity_idx);\n\tu8 qsel, ch_dma;\n\n\tqsel = desc_info->hiq ? RTW89_TX_QSEL_B0_HI : RTW89_TX_QSEL_B0_MGMT;\n\tch_dma = rtw89_core_get_ch_dma(rtwdev, qsel);\n\n\tdesc_info->qsel = qsel;\n\tdesc_info->ch_dma = ch_dma;\n\tdesc_info->port = desc_info->hiq ? rtwvif->port : 0;\n\tdesc_info->mac_id = rtw89_core_tx_get_mac_id(rtwdev, tx_req);\n\tdesc_info->hw_ssn_sel = RTW89_MGMT_HW_SSN_SEL;\n\tdesc_info->hw_seq_mode = RTW89_MGMT_HW_SEQ_MODE;\n\n\t \n\tdesc_info->en_wd_info = true;\n\tdesc_info->use_rate = true;\n\tdesc_info->dis_data_fb = true;\n\tdesc_info->data_rate = rtw89_core_get_mgmt_rate(rtwdev, tx_req, chan);\n\n\trtw89_debug(rtwdev, RTW89_DBG_TXRX,\n\t\t    \"tx mgmt frame with rate 0x%x on channel %d (band %d, bw %d)\\n\",\n\t\t    desc_info->data_rate, chan->channel, chan->band_type,\n\t\t    chan->band_width);\n}\n\nstatic void\nrtw89_core_tx_update_h2c_info(struct rtw89_dev *rtwdev,\n\t\t\t      struct rtw89_core_tx_request *tx_req)\n{\n\tstruct rtw89_tx_desc_info *desc_info = &tx_req->desc_info;\n\n\tdesc_info->is_bmc = false;\n\tdesc_info->wd_page = false;\n\tdesc_info->ch_dma = RTW89_DMA_H2C;\n}\n\nstatic void rtw89_core_get_no_ul_ofdma_htc(struct rtw89_dev *rtwdev, __le32 *htc,\n\t\t\t\t\t   const struct rtw89_chan *chan)\n{\n\tstatic const u8 rtw89_bandwidth_to_om[] = {\n\t\t[RTW89_CHANNEL_WIDTH_20] = HTC_OM_CHANNEL_WIDTH_20,\n\t\t[RTW89_CHANNEL_WIDTH_40] = HTC_OM_CHANNEL_WIDTH_40,\n\t\t[RTW89_CHANNEL_WIDTH_80] = HTC_OM_CHANNEL_WIDTH_80,\n\t\t[RTW89_CHANNEL_WIDTH_160] = HTC_OM_CHANNEL_WIDTH_160_OR_80_80,\n\t\t[RTW89_CHANNEL_WIDTH_80_80] = HTC_OM_CHANNEL_WIDTH_160_OR_80_80,\n\t};\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tstruct rtw89_hal *hal = &rtwdev->hal;\n\tu8 om_bandwidth;\n\n\tif (!chip->dis_2g_40m_ul_ofdma ||\n\t    chan->band_type != RTW89_BAND_2G ||\n\t    chan->band_width != RTW89_CHANNEL_WIDTH_40)\n\t\treturn;\n\n\tom_bandwidth = chan->band_width < ARRAY_SIZE(rtw89_bandwidth_to_om) ?\n\t\t       rtw89_bandwidth_to_om[chan->band_width] : 0;\n\t*htc = le32_encode_bits(RTW89_HTC_VARIANT_HE, RTW89_HTC_MASK_VARIANT) |\n\t       le32_encode_bits(RTW89_HTC_VARIANT_HE_CID_OM, RTW89_HTC_MASK_CTL_ID) |\n\t       le32_encode_bits(hal->rx_nss - 1, RTW89_HTC_MASK_HTC_OM_RX_NSS) |\n\t       le32_encode_bits(om_bandwidth, RTW89_HTC_MASK_HTC_OM_CH_WIDTH) |\n\t       le32_encode_bits(1, RTW89_HTC_MASK_HTC_OM_UL_MU_DIS) |\n\t       le32_encode_bits(hal->tx_nss - 1, RTW89_HTC_MASK_HTC_OM_TX_NSTS) |\n\t       le32_encode_bits(0, RTW89_HTC_MASK_HTC_OM_ER_SU_DIS) |\n\t       le32_encode_bits(0, RTW89_HTC_MASK_HTC_OM_DL_MU_MIMO_RR) |\n\t       le32_encode_bits(0, RTW89_HTC_MASK_HTC_OM_UL_MU_DATA_DIS);\n}\n\nstatic bool\n__rtw89_core_tx_check_he_qos_htc(struct rtw89_dev *rtwdev,\n\t\t\t\t struct rtw89_core_tx_request *tx_req,\n\t\t\t\t enum btc_pkt_type pkt_type)\n{\n\tstruct ieee80211_sta *sta = tx_req->sta;\n\tstruct rtw89_sta *rtwsta = sta_to_rtwsta_safe(sta);\n\tstruct sk_buff *skb = tx_req->skb;\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\t__le16 fc = hdr->frame_control;\n\n\t \n\tif (pkt_type < PACKET_MAX)\n\t\treturn false;\n\n\tif (!sta || !sta->deflink.he_cap.has_he)\n\t\treturn false;\n\n\tif (!ieee80211_is_data_qos(fc))\n\t\treturn false;\n\n\tif (skb_headroom(skb) < IEEE80211_HT_CTL_LEN)\n\t\treturn false;\n\n\tif (rtwsta && rtwsta->ra_report.might_fallback_legacy)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void\n__rtw89_core_tx_adjust_he_qos_htc(struct rtw89_dev *rtwdev,\n\t\t\t\t  struct rtw89_core_tx_request *tx_req)\n{\n\tstruct ieee80211_sta *sta = tx_req->sta;\n\tstruct rtw89_sta *rtwsta = (struct rtw89_sta *)sta->drv_priv;\n\tstruct sk_buff *skb = tx_req->skb;\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\t__le16 fc = hdr->frame_control;\n\tvoid *data;\n\t__le32 *htc;\n\tu8 *qc;\n\tint hdr_len;\n\n\thdr_len = ieee80211_has_a4(fc) ? 32 : 26;\n\tdata = skb_push(skb, IEEE80211_HT_CTL_LEN);\n\tmemmove(data, data + IEEE80211_HT_CTL_LEN, hdr_len);\n\n\thdr = data;\n\thtc = data + hdr_len;\n\thdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_ORDER);\n\t*htc = rtwsta->htc_template ? rtwsta->htc_template :\n\t       le32_encode_bits(RTW89_HTC_VARIANT_HE, RTW89_HTC_MASK_VARIANT) |\n\t       le32_encode_bits(RTW89_HTC_VARIANT_HE_CID_CAS, RTW89_HTC_MASK_CTL_ID);\n\n\tqc = data + hdr_len - IEEE80211_QOS_CTL_LEN;\n\tqc[0] |= IEEE80211_QOS_CTL_EOSP;\n}\n\nstatic void\nrtw89_core_tx_update_he_qos_htc(struct rtw89_dev *rtwdev,\n\t\t\t\tstruct rtw89_core_tx_request *tx_req,\n\t\t\t\tenum btc_pkt_type pkt_type)\n{\n\tstruct rtw89_tx_desc_info *desc_info = &tx_req->desc_info;\n\tstruct ieee80211_vif *vif = tx_req->vif;\n\tstruct rtw89_vif *rtwvif = (struct rtw89_vif *)vif->drv_priv;\n\n\tif (!__rtw89_core_tx_check_he_qos_htc(rtwdev, tx_req, pkt_type))\n\t\tgoto desc_bk;\n\n\t__rtw89_core_tx_adjust_he_qos_htc(rtwdev, tx_req);\n\n\tdesc_info->pkt_size += IEEE80211_HT_CTL_LEN;\n\tdesc_info->a_ctrl_bsr = true;\n\ndesc_bk:\n\tif (!rtwvif || rtwvif->last_a_ctrl == desc_info->a_ctrl_bsr)\n\t\treturn;\n\n\trtwvif->last_a_ctrl = desc_info->a_ctrl_bsr;\n\tdesc_info->bk = true;\n}\n\nstatic u16 rtw89_core_get_data_rate(struct rtw89_dev *rtwdev,\n\t\t\t\t    struct rtw89_core_tx_request *tx_req)\n{\n\tstruct ieee80211_vif *vif = tx_req->vif;\n\tstruct ieee80211_sta *sta = tx_req->sta;\n\tstruct rtw89_vif *rtwvif = (struct rtw89_vif *)vif->drv_priv;\n\tstruct rtw89_phy_rate_pattern *rate_pattern = &rtwvif->rate_pattern;\n\tenum rtw89_sub_entity_idx idx = rtwvif->sub_entity_idx;\n\tconst struct rtw89_chan *chan = rtw89_chan_get(rtwdev, idx);\n\tu16 lowest_rate;\n\n\tif (rate_pattern->enable)\n\t\treturn rate_pattern->rate;\n\n\tif (vif->p2p)\n\t\tlowest_rate = RTW89_HW_RATE_OFDM6;\n\telse if (chan->band_type == RTW89_BAND_2G)\n\t\tlowest_rate = RTW89_HW_RATE_CCK1;\n\telse\n\t\tlowest_rate = RTW89_HW_RATE_OFDM6;\n\n\tif (!sta || !sta->deflink.supp_rates[chan->band_type])\n\t\treturn lowest_rate;\n\n\treturn __ffs(sta->deflink.supp_rates[chan->band_type]) + lowest_rate;\n}\n\nstatic void\nrtw89_core_tx_update_data_info(struct rtw89_dev *rtwdev,\n\t\t\t       struct rtw89_core_tx_request *tx_req)\n{\n\tstruct ieee80211_vif *vif = tx_req->vif;\n\tstruct ieee80211_sta *sta = tx_req->sta;\n\tstruct rtw89_vif *rtwvif = (struct rtw89_vif *)vif->drv_priv;\n\tstruct rtw89_sta *rtwsta = sta_to_rtwsta_safe(sta);\n\tstruct rtw89_tx_desc_info *desc_info = &tx_req->desc_info;\n\tstruct sk_buff *skb = tx_req->skb;\n\tu8 tid, tid_indicate;\n\tu8 qsel, ch_dma;\n\n\ttid = skb->priority & IEEE80211_QOS_CTL_TAG1D_MASK;\n\ttid_indicate = rtw89_core_get_tid_indicate(rtwdev, tid);\n\tqsel = desc_info->hiq ? RTW89_TX_QSEL_B0_HI : rtw89_core_get_qsel(rtwdev, tid);\n\tch_dma = rtw89_core_get_ch_dma(rtwdev, qsel);\n\n\tdesc_info->ch_dma = ch_dma;\n\tdesc_info->tid_indicate = tid_indicate;\n\tdesc_info->qsel = qsel;\n\tdesc_info->mac_id = rtw89_core_tx_get_mac_id(rtwdev, tx_req);\n\tdesc_info->port = desc_info->hiq ? rtwvif->port : 0;\n\tdesc_info->er_cap = rtwsta ? rtwsta->er_cap : false;\n\n\t \n\tdesc_info->en_wd_info = true;\n\n\tif (IEEE80211_SKB_CB(skb)->control.hw_key)\n\t\trtw89_core_tx_update_sec_key(rtwdev, tx_req);\n\n\tdesc_info->data_retry_lowest_rate = rtw89_core_get_data_rate(rtwdev, tx_req);\n}\n\nstatic enum btc_pkt_type\nrtw89_core_tx_btc_spec_pkt_notify(struct rtw89_dev *rtwdev,\n\t\t\t\t  struct rtw89_core_tx_request *tx_req)\n{\n\tstruct sk_buff *skb = tx_req->skb;\n\tstruct udphdr *udphdr;\n\n\tif (IEEE80211_SKB_CB(skb)->control.flags & IEEE80211_TX_CTRL_PORT_CTRL_PROTO) {\n\t\tieee80211_queue_work(rtwdev->hw, &rtwdev->btc.eapol_notify_work);\n\t\treturn PACKET_EAPOL;\n\t}\n\n\tif (skb->protocol == htons(ETH_P_ARP)) {\n\t\tieee80211_queue_work(rtwdev->hw, &rtwdev->btc.arp_notify_work);\n\t\treturn PACKET_ARP;\n\t}\n\n\tif (skb->protocol == htons(ETH_P_IP) &&\n\t    ip_hdr(skb)->protocol == IPPROTO_UDP) {\n\t\tudphdr = udp_hdr(skb);\n\t\tif (((udphdr->source == htons(67) && udphdr->dest == htons(68)) ||\n\t\t     (udphdr->source == htons(68) && udphdr->dest == htons(67))) &&\n\t\t    skb->len > 282) {\n\t\t\tieee80211_queue_work(rtwdev->hw, &rtwdev->btc.dhcp_notify_work);\n\t\t\treturn PACKET_DHCP;\n\t\t}\n\t}\n\n\tif (skb->protocol == htons(ETH_P_IP) &&\n\t    ip_hdr(skb)->protocol == IPPROTO_ICMP) {\n\t\tieee80211_queue_work(rtwdev->hw, &rtwdev->btc.icmp_notify_work);\n\t\treturn PACKET_ICMP;\n\t}\n\n\treturn PACKET_MAX;\n}\n\nstatic void rtw89_core_tx_update_llc_hdr(struct rtw89_dev *rtwdev,\n\t\t\t\t\t struct rtw89_tx_desc_info *desc_info,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\t__le16 fc = hdr->frame_control;\n\n\tdesc_info->hdr_llc_len = ieee80211_hdrlen(fc);\n\tdesc_info->hdr_llc_len >>= 1;  \n}\n\nstatic void\nrtw89_core_tx_wake(struct rtw89_dev *rtwdev,\n\t\t   struct rtw89_core_tx_request *tx_req)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\n\tif (!RTW89_CHK_FW_FEATURE(TX_WAKE, &rtwdev->fw))\n\t\treturn;\n\n\tif (!test_bit(RTW89_FLAG_LOW_POWER_MODE, rtwdev->flags))\n\t\treturn;\n\n\tif (chip->chip_id != RTL8852C &&\n\t    tx_req->tx_type != RTW89_CORE_TX_TYPE_MGMT)\n\t\treturn;\n\n\trtw89_mac_notify_wake(rtwdev);\n}\n\nstatic void\nrtw89_core_tx_update_desc_info(struct rtw89_dev *rtwdev,\n\t\t\t       struct rtw89_core_tx_request *tx_req)\n{\n\tstruct rtw89_tx_desc_info *desc_info = &tx_req->desc_info;\n\tstruct sk_buff *skb = tx_req->skb;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr = (void *)skb->data;\n\tenum rtw89_core_tx_type tx_type;\n\tenum btc_pkt_type pkt_type;\n\tbool is_bmc;\n\tu16 seq;\n\n\tseq = (le16_to_cpu(hdr->seq_ctrl) & IEEE80211_SCTL_SEQ) >> 4;\n\tif (tx_req->tx_type != RTW89_CORE_TX_TYPE_FWCMD) {\n\t\ttx_type = rtw89_core_get_tx_type(rtwdev, skb);\n\t\ttx_req->tx_type = tx_type;\n\t}\n\tis_bmc = (is_broadcast_ether_addr(hdr->addr1) ||\n\t\t  is_multicast_ether_addr(hdr->addr1));\n\n\tdesc_info->seq = seq;\n\tdesc_info->pkt_size = skb->len;\n\tdesc_info->is_bmc = is_bmc;\n\tdesc_info->wd_page = true;\n\tdesc_info->hiq = info->flags & IEEE80211_TX_CTL_SEND_AFTER_DTIM;\n\n\tswitch (tx_req->tx_type) {\n\tcase RTW89_CORE_TX_TYPE_MGMT:\n\t\trtw89_core_tx_update_mgmt_info(rtwdev, tx_req);\n\t\tbreak;\n\tcase RTW89_CORE_TX_TYPE_DATA:\n\t\trtw89_core_tx_update_data_info(rtwdev, tx_req);\n\t\tpkt_type = rtw89_core_tx_btc_spec_pkt_notify(rtwdev, tx_req);\n\t\trtw89_core_tx_update_he_qos_htc(rtwdev, tx_req, pkt_type);\n\t\trtw89_core_tx_update_ampdu_info(rtwdev, tx_req, pkt_type);\n\t\trtw89_core_tx_update_llc_hdr(rtwdev, desc_info, skb);\n\t\tbreak;\n\tcase RTW89_CORE_TX_TYPE_FWCMD:\n\t\trtw89_core_tx_update_h2c_info(rtwdev, tx_req);\n\t\tbreak;\n\t}\n}\n\nvoid rtw89_core_tx_kick_off(struct rtw89_dev *rtwdev, u8 qsel)\n{\n\tu8 ch_dma;\n\n\tch_dma = rtw89_core_get_ch_dma(rtwdev, qsel);\n\n\trtw89_hci_tx_kick_off(rtwdev, ch_dma);\n}\n\nint rtw89_core_tx_kick_off_and_wait(struct rtw89_dev *rtwdev, struct sk_buff *skb,\n\t\t\t\t    int qsel, unsigned int timeout)\n{\n\tstruct rtw89_tx_skb_data *skb_data = RTW89_TX_SKB_CB(skb);\n\tstruct rtw89_tx_wait_info *wait;\n\tunsigned long time_left;\n\tint ret = 0;\n\n\twait = kzalloc(sizeof(*wait), GFP_KERNEL);\n\tif (!wait) {\n\t\trtw89_core_tx_kick_off(rtwdev, qsel);\n\t\treturn 0;\n\t}\n\n\tinit_completion(&wait->completion);\n\trcu_assign_pointer(skb_data->wait, wait);\n\n\trtw89_core_tx_kick_off(rtwdev, qsel);\n\ttime_left = wait_for_completion_timeout(&wait->completion,\n\t\t\t\t\t\tmsecs_to_jiffies(timeout));\n\tif (time_left == 0)\n\t\tret = -ETIMEDOUT;\n\telse if (!wait->tx_done)\n\t\tret = -EAGAIN;\n\n\trcu_assign_pointer(skb_data->wait, NULL);\n\tkfree_rcu(wait, rcu_head);\n\n\treturn ret;\n}\n\nint rtw89_h2c_tx(struct rtw89_dev *rtwdev,\n\t\t struct sk_buff *skb, bool fwdl)\n{\n\tstruct rtw89_core_tx_request tx_req = {0};\n\tu32 cnt;\n\tint ret;\n\n\tif (!test_bit(RTW89_FLAG_POWERON, rtwdev->flags)) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_FW,\n\t\t\t    \"ignore h2c due to power is off with firmware state=%d\\n\",\n\t\t\t    test_bit(RTW89_FLAG_FW_RDY, rtwdev->flags));\n\t\tdev_kfree_skb(skb);\n\t\treturn 0;\n\t}\n\n\ttx_req.skb = skb;\n\ttx_req.tx_type = RTW89_CORE_TX_TYPE_FWCMD;\n\tif (fwdl)\n\t\ttx_req.desc_info.fw_dl = true;\n\n\trtw89_core_tx_update_desc_info(rtwdev, &tx_req);\n\n\tif (!fwdl)\n\t\trtw89_hex_dump(rtwdev, RTW89_DBG_FW, \"H2C: \", skb->data, skb->len);\n\n\tcnt = rtw89_hci_check_and_reclaim_tx_resource(rtwdev, RTW89_TXCH_CH12);\n\tif (cnt == 0) {\n\t\trtw89_err(rtwdev, \"no tx fwcmd resource\\n\");\n\t\treturn -ENOSPC;\n\t}\n\n\tret = rtw89_hci_tx_write(rtwdev, &tx_req);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to transmit skb to HCI\\n\");\n\t\treturn ret;\n\t}\n\trtw89_hci_tx_kick_off(rtwdev, RTW89_TXCH_CH12);\n\n\treturn 0;\n}\n\nint rtw89_core_tx_write(struct rtw89_dev *rtwdev, struct ieee80211_vif *vif,\n\t\t\tstruct ieee80211_sta *sta, struct sk_buff *skb, int *qsel)\n{\n\tstruct rtw89_core_tx_request tx_req = {0};\n\tstruct rtw89_vif *rtwvif = (struct rtw89_vif *)vif->drv_priv;\n\tint ret;\n\n\ttx_req.skb = skb;\n\ttx_req.sta = sta;\n\ttx_req.vif = vif;\n\n\trtw89_traffic_stats_accu(rtwdev, &rtwdev->stats, skb, true);\n\trtw89_traffic_stats_accu(rtwdev, &rtwvif->stats, skb, true);\n\trtw89_core_tx_update_desc_info(rtwdev, &tx_req);\n\trtw89_core_tx_wake(rtwdev, &tx_req);\n\n\tret = rtw89_hci_tx_write(rtwdev, &tx_req);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to transmit skb to HCI\\n\");\n\t\treturn ret;\n\t}\n\n\tif (qsel)\n\t\t*qsel = tx_req.desc_info.qsel;\n\n\treturn 0;\n}\n\nstatic __le32 rtw89_build_txwd_body0(struct rtw89_tx_desc_info *desc_info)\n{\n\tu32 dword = FIELD_PREP(RTW89_TXWD_BODY0_WP_OFFSET, desc_info->wp_offset) |\n\t\t    FIELD_PREP(RTW89_TXWD_BODY0_WD_INFO_EN, desc_info->en_wd_info) |\n\t\t    FIELD_PREP(RTW89_TXWD_BODY0_CHANNEL_DMA, desc_info->ch_dma) |\n\t\t    FIELD_PREP(RTW89_TXWD_BODY0_HDR_LLC_LEN, desc_info->hdr_llc_len) |\n\t\t    FIELD_PREP(RTW89_TXWD_BODY0_WD_PAGE, desc_info->wd_page) |\n\t\t    FIELD_PREP(RTW89_TXWD_BODY0_FW_DL, desc_info->fw_dl) |\n\t\t    FIELD_PREP(RTW89_TXWD_BODY0_HW_SSN_SEL, desc_info->hw_ssn_sel) |\n\t\t    FIELD_PREP(RTW89_TXWD_BODY0_HW_SSN_MODE, desc_info->hw_seq_mode);\n\n\treturn cpu_to_le32(dword);\n}\n\nstatic __le32 rtw89_build_txwd_body0_v1(struct rtw89_tx_desc_info *desc_info)\n{\n\tu32 dword = FIELD_PREP(RTW89_TXWD_BODY0_WP_OFFSET_V1, desc_info->wp_offset) |\n\t\t    FIELD_PREP(RTW89_TXWD_BODY0_WD_INFO_EN, desc_info->en_wd_info) |\n\t\t    FIELD_PREP(RTW89_TXWD_BODY0_CHANNEL_DMA, desc_info->ch_dma) |\n\t\t    FIELD_PREP(RTW89_TXWD_BODY0_HDR_LLC_LEN, desc_info->hdr_llc_len) |\n\t\t    FIELD_PREP(RTW89_TXWD_BODY0_WD_PAGE, desc_info->wd_page) |\n\t\t    FIELD_PREP(RTW89_TXWD_BODY0_FW_DL, desc_info->fw_dl);\n\n\treturn cpu_to_le32(dword);\n}\n\nstatic __le32 rtw89_build_txwd_body1_v1(struct rtw89_tx_desc_info *desc_info)\n{\n\tu32 dword = FIELD_PREP(RTW89_TXWD_BODY1_ADDR_INFO_NUM, desc_info->addr_info_nr) |\n\t\t    FIELD_PREP(RTW89_TXWD_BODY1_SEC_KEYID, desc_info->sec_keyid) |\n\t\t    FIELD_PREP(RTW89_TXWD_BODY1_SEC_TYPE, desc_info->sec_type);\n\n\treturn cpu_to_le32(dword);\n}\n\nstatic __le32 rtw89_build_txwd_body2(struct rtw89_tx_desc_info *desc_info)\n{\n\tu32 dword = FIELD_PREP(RTW89_TXWD_BODY2_TID_INDICATE, desc_info->tid_indicate) |\n\t\t    FIELD_PREP(RTW89_TXWD_BODY2_QSEL, desc_info->qsel) |\n\t\t    FIELD_PREP(RTW89_TXWD_BODY2_TXPKT_SIZE, desc_info->pkt_size) |\n\t\t    FIELD_PREP(RTW89_TXWD_BODY2_MACID, desc_info->mac_id);\n\n\treturn cpu_to_le32(dword);\n}\n\nstatic __le32 rtw89_build_txwd_body3(struct rtw89_tx_desc_info *desc_info)\n{\n\tu32 dword = FIELD_PREP(RTW89_TXWD_BODY3_SW_SEQ, desc_info->seq) |\n\t\t    FIELD_PREP(RTW89_TXWD_BODY3_AGG_EN, desc_info->agg_en) |\n\t\t    FIELD_PREP(RTW89_TXWD_BODY3_BK, desc_info->bk);\n\n\treturn cpu_to_le32(dword);\n}\n\nstatic __le32 rtw89_build_txwd_body4(struct rtw89_tx_desc_info *desc_info)\n{\n\tu32 dword = FIELD_PREP(RTW89_TXWD_BODY4_SEC_IV_L0, desc_info->sec_seq[0]) |\n\t\t    FIELD_PREP(RTW89_TXWD_BODY4_SEC_IV_L1, desc_info->sec_seq[1]);\n\n\treturn cpu_to_le32(dword);\n}\n\nstatic __le32 rtw89_build_txwd_body5(struct rtw89_tx_desc_info *desc_info)\n{\n\tu32 dword = FIELD_PREP(RTW89_TXWD_BODY5_SEC_IV_H2, desc_info->sec_seq[2]) |\n\t\t    FIELD_PREP(RTW89_TXWD_BODY5_SEC_IV_H3, desc_info->sec_seq[3]) |\n\t\t    FIELD_PREP(RTW89_TXWD_BODY5_SEC_IV_H4, desc_info->sec_seq[4]) |\n\t\t    FIELD_PREP(RTW89_TXWD_BODY5_SEC_IV_H5, desc_info->sec_seq[5]);\n\n\treturn cpu_to_le32(dword);\n}\n\nstatic __le32 rtw89_build_txwd_body7_v1(struct rtw89_tx_desc_info *desc_info)\n{\n\tu32 dword = FIELD_PREP(RTW89_TXWD_BODY7_USE_RATE_V1, desc_info->use_rate) |\n\t\t    FIELD_PREP(RTW89_TXWD_BODY7_DATA_RATE, desc_info->data_rate);\n\n\treturn cpu_to_le32(dword);\n}\n\nstatic __le32 rtw89_build_txwd_info0(struct rtw89_tx_desc_info *desc_info)\n{\n\tu32 dword = FIELD_PREP(RTW89_TXWD_INFO0_USE_RATE, desc_info->use_rate) |\n\t\t    FIELD_PREP(RTW89_TXWD_INFO0_DATA_RATE, desc_info->data_rate) |\n\t\t    FIELD_PREP(RTW89_TXWD_INFO0_DISDATAFB, desc_info->dis_data_fb) |\n\t\t    FIELD_PREP(RTW89_TXWD_INFO0_MULTIPORT_ID, desc_info->port);\n\n\treturn cpu_to_le32(dword);\n}\n\nstatic __le32 rtw89_build_txwd_info0_v1(struct rtw89_tx_desc_info *desc_info)\n{\n\tu32 dword = FIELD_PREP(RTW89_TXWD_INFO0_DISDATAFB, desc_info->dis_data_fb) |\n\t\t    FIELD_PREP(RTW89_TXWD_INFO0_MULTIPORT_ID, desc_info->port) |\n\t\t    FIELD_PREP(RTW89_TXWD_INFO0_DATA_ER, desc_info->er_cap) |\n\t\t    FIELD_PREP(RTW89_TXWD_INFO0_DATA_BW_ER, 0);\n\n\treturn cpu_to_le32(dword);\n}\n\nstatic __le32 rtw89_build_txwd_info1(struct rtw89_tx_desc_info *desc_info)\n{\n\tu32 dword = FIELD_PREP(RTW89_TXWD_INFO1_MAX_AGGNUM, desc_info->ampdu_num) |\n\t\t    FIELD_PREP(RTW89_TXWD_INFO1_A_CTRL_BSR, desc_info->a_ctrl_bsr) |\n\t\t    FIELD_PREP(RTW89_TXWD_INFO1_DATA_RTY_LOWEST_RATE,\n\t\t\t       desc_info->data_retry_lowest_rate);\n\n\treturn cpu_to_le32(dword);\n}\n\nstatic __le32 rtw89_build_txwd_info2(struct rtw89_tx_desc_info *desc_info)\n{\n\tu32 dword = FIELD_PREP(RTW89_TXWD_INFO2_AMPDU_DENSITY, desc_info->ampdu_density) |\n\t\t    FIELD_PREP(RTW89_TXWD_INFO2_SEC_TYPE, desc_info->sec_type) |\n\t\t    FIELD_PREP(RTW89_TXWD_INFO2_SEC_HW_ENC, desc_info->sec_en) |\n\t\t    FIELD_PREP(RTW89_TXWD_INFO2_SEC_CAM_IDX, desc_info->sec_cam_idx);\n\n\treturn cpu_to_le32(dword);\n}\n\nstatic __le32 rtw89_build_txwd_info2_v1(struct rtw89_tx_desc_info *desc_info)\n{\n\tu32 dword = FIELD_PREP(RTW89_TXWD_INFO2_AMPDU_DENSITY, desc_info->ampdu_density) |\n\t\t    FIELD_PREP(RTW89_TXWD_INFO2_FORCE_KEY_EN, desc_info->sec_en) |\n\t\t    FIELD_PREP(RTW89_TXWD_INFO2_SEC_CAM_IDX, desc_info->sec_cam_idx);\n\n\treturn cpu_to_le32(dword);\n}\n\nstatic __le32 rtw89_build_txwd_info4(struct rtw89_tx_desc_info *desc_info)\n{\n\tu32 dword = FIELD_PREP(RTW89_TXWD_INFO4_RTS_EN, 1) |\n\t\t    FIELD_PREP(RTW89_TXWD_INFO4_HW_RTS_EN, 1);\n\n\treturn cpu_to_le32(dword);\n}\n\nvoid rtw89_core_fill_txdesc(struct rtw89_dev *rtwdev,\n\t\t\t    struct rtw89_tx_desc_info *desc_info,\n\t\t\t    void *txdesc)\n{\n\tstruct rtw89_txwd_body *txwd_body = (struct rtw89_txwd_body *)txdesc;\n\tstruct rtw89_txwd_info *txwd_info;\n\n\ttxwd_body->dword0 = rtw89_build_txwd_body0(desc_info);\n\ttxwd_body->dword2 = rtw89_build_txwd_body2(desc_info);\n\ttxwd_body->dword3 = rtw89_build_txwd_body3(desc_info);\n\n\tif (!desc_info->en_wd_info)\n\t\treturn;\n\n\ttxwd_info = (struct rtw89_txwd_info *)(txwd_body + 1);\n\ttxwd_info->dword0 = rtw89_build_txwd_info0(desc_info);\n\ttxwd_info->dword1 = rtw89_build_txwd_info1(desc_info);\n\ttxwd_info->dword2 = rtw89_build_txwd_info2(desc_info);\n\ttxwd_info->dword4 = rtw89_build_txwd_info4(desc_info);\n\n}\nEXPORT_SYMBOL(rtw89_core_fill_txdesc);\n\nvoid rtw89_core_fill_txdesc_v1(struct rtw89_dev *rtwdev,\n\t\t\t       struct rtw89_tx_desc_info *desc_info,\n\t\t\t       void *txdesc)\n{\n\tstruct rtw89_txwd_body_v1 *txwd_body = (struct rtw89_txwd_body_v1 *)txdesc;\n\tstruct rtw89_txwd_info *txwd_info;\n\n\ttxwd_body->dword0 = rtw89_build_txwd_body0_v1(desc_info);\n\ttxwd_body->dword1 = rtw89_build_txwd_body1_v1(desc_info);\n\ttxwd_body->dword2 = rtw89_build_txwd_body2(desc_info);\n\ttxwd_body->dword3 = rtw89_build_txwd_body3(desc_info);\n\tif (desc_info->sec_en) {\n\t\ttxwd_body->dword4 = rtw89_build_txwd_body4(desc_info);\n\t\ttxwd_body->dword5 = rtw89_build_txwd_body5(desc_info);\n\t}\n\ttxwd_body->dword7 = rtw89_build_txwd_body7_v1(desc_info);\n\n\tif (!desc_info->en_wd_info)\n\t\treturn;\n\n\ttxwd_info = (struct rtw89_txwd_info *)(txwd_body + 1);\n\ttxwd_info->dword0 = rtw89_build_txwd_info0_v1(desc_info);\n\ttxwd_info->dword1 = rtw89_build_txwd_info1(desc_info);\n\ttxwd_info->dword2 = rtw89_build_txwd_info2_v1(desc_info);\n\ttxwd_info->dword4 = rtw89_build_txwd_info4(desc_info);\n}\nEXPORT_SYMBOL(rtw89_core_fill_txdesc_v1);\n\nstatic __le32 rtw89_build_txwd_fwcmd0_v1(struct rtw89_tx_desc_info *desc_info)\n{\n\tu32 dword = FIELD_PREP(AX_RXD_RPKT_LEN_MASK, desc_info->pkt_size) |\n\t\t    FIELD_PREP(AX_RXD_RPKT_TYPE_MASK, desc_info->fw_dl ?\n\t\t\t\t\t\t      RTW89_CORE_RX_TYPE_FWDL :\n\t\t\t\t\t\t      RTW89_CORE_RX_TYPE_H2C);\n\n\treturn cpu_to_le32(dword);\n}\n\nvoid rtw89_core_fill_txdesc_fwcmd_v1(struct rtw89_dev *rtwdev,\n\t\t\t\t     struct rtw89_tx_desc_info *desc_info,\n\t\t\t\t     void *txdesc)\n{\n\tstruct rtw89_rxdesc_short *txwd_v1 = (struct rtw89_rxdesc_short *)txdesc;\n\n\ttxwd_v1->dword0 = rtw89_build_txwd_fwcmd0_v1(desc_info);\n}\nEXPORT_SYMBOL(rtw89_core_fill_txdesc_fwcmd_v1);\n\nstatic int rtw89_core_rx_process_mac_ppdu(struct rtw89_dev *rtwdev,\n\t\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t\t  struct rtw89_rx_phy_ppdu *phy_ppdu)\n{\n\tconst struct rtw89_rxinfo *rxinfo = (const struct rtw89_rxinfo *)skb->data;\n\tbool rx_cnt_valid = false;\n\tu8 plcp_size = 0;\n\tu8 usr_num = 0;\n\tu8 *phy_sts;\n\n\trx_cnt_valid = le32_get_bits(rxinfo->w0, RTW89_RXINFO_W0_RX_CNT_VLD);\n\tplcp_size = le32_get_bits(rxinfo->w1, RTW89_RXINFO_W1_PLCP_LEN) << 3;\n\tusr_num = le32_get_bits(rxinfo->w0, RTW89_RXINFO_W0_USR_NUM);\n\tif (usr_num > RTW89_PPDU_MAX_USR) {\n\t\trtw89_warn(rtwdev, \"Invalid user number in mac info\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tphy_sts = skb->data + RTW89_PPDU_MAC_INFO_SIZE;\n\tphy_sts += usr_num * RTW89_PPDU_MAC_INFO_USR_SIZE;\n\t \n\tif (usr_num & BIT(0))\n\t\tphy_sts += RTW89_PPDU_MAC_INFO_USR_SIZE;\n\tif (rx_cnt_valid)\n\t\tphy_sts += RTW89_PPDU_MAC_RX_CNT_SIZE;\n\tphy_sts += plcp_size;\n\n\tphy_ppdu->buf = phy_sts;\n\tphy_ppdu->len = skb->data + skb->len - phy_sts;\n\n\treturn 0;\n}\n\nstatic void rtw89_core_rx_process_phy_ppdu_iter(void *data,\n\t\t\t\t\t\tstruct ieee80211_sta *sta)\n{\n\tstruct rtw89_sta *rtwsta = (struct rtw89_sta *)sta->drv_priv;\n\tstruct rtw89_rx_phy_ppdu *phy_ppdu = (struct rtw89_rx_phy_ppdu *)data;\n\tstruct rtw89_dev *rtwdev = rtwsta->rtwdev;\n\tstruct rtw89_hal *hal = &rtwdev->hal;\n\tu8 ant_num = hal->ant_diversity ? 2 : rtwdev->chip->rf_path_num;\n\tu8 ant_pos = U8_MAX;\n\tu8 evm_pos = 0;\n\tint i;\n\n\tif (rtwsta->mac_id != phy_ppdu->mac_id || !phy_ppdu->to_self)\n\t\treturn;\n\n\tif (hal->ant_diversity && hal->antenna_rx) {\n\t\tant_pos = __ffs(hal->antenna_rx);\n\t\tevm_pos = ant_pos;\n\t}\n\n\tewma_rssi_add(&rtwsta->avg_rssi, phy_ppdu->rssi_avg);\n\n\tif (ant_pos < ant_num) {\n\t\tewma_rssi_add(&rtwsta->rssi[ant_pos], phy_ppdu->rssi[0]);\n\t} else {\n\t\tfor (i = 0; i < rtwdev->chip->rf_path_num; i++)\n\t\t\tewma_rssi_add(&rtwsta->rssi[i], phy_ppdu->rssi[i]);\n\t}\n\n\tif (phy_ppdu->ofdm.has) {\n\t\tewma_snr_add(&rtwsta->avg_snr, phy_ppdu->ofdm.avg_snr);\n\t\tewma_evm_add(&rtwsta->evm_min[evm_pos], phy_ppdu->ofdm.evm_min);\n\t\tewma_evm_add(&rtwsta->evm_max[evm_pos], phy_ppdu->ofdm.evm_max);\n\t}\n}\n\n#define VAR_LEN 0xff\n#define VAR_LEN_UNIT 8\nstatic u16 rtw89_core_get_phy_status_ie_len(struct rtw89_dev *rtwdev,\n\t\t\t\t\t    const struct rtw89_phy_sts_iehdr *iehdr)\n{\n\tstatic const u8 physts_ie_len_tab[32] = {\n\t\t16, 32, 24, 24, 8, 8, 8, 8, VAR_LEN, 8, VAR_LEN, 176, VAR_LEN,\n\t\tVAR_LEN, VAR_LEN, VAR_LEN, VAR_LEN, VAR_LEN, 16, 24, VAR_LEN,\n\t\tVAR_LEN, VAR_LEN, 0, 24, 24, 24, 24, 32, 32, 32, 32\n\t};\n\tu16 ie_len;\n\tu8 ie;\n\n\tie = le32_get_bits(iehdr->w0, RTW89_PHY_STS_IEHDR_TYPE);\n\tif (physts_ie_len_tab[ie] != VAR_LEN)\n\t\tie_len = physts_ie_len_tab[ie];\n\telse\n\t\tie_len = le32_get_bits(iehdr->w0, RTW89_PHY_STS_IEHDR_LEN) * VAR_LEN_UNIT;\n\n\treturn ie_len;\n}\n\nstatic void rtw89_core_parse_phy_status_ie01(struct rtw89_dev *rtwdev,\n\t\t\t\t\t     const struct rtw89_phy_sts_iehdr *iehdr,\n\t\t\t\t\t     struct rtw89_rx_phy_ppdu *phy_ppdu)\n{\n\tconst struct rtw89_phy_sts_ie0 *ie = (const struct rtw89_phy_sts_ie0 *)iehdr;\n\ts16 cfo;\n\tu32 t;\n\n\tphy_ppdu->chan_idx = le32_get_bits(ie->w0, RTW89_PHY_STS_IE01_W0_CH_IDX);\n\tif (phy_ppdu->rate < RTW89_HW_RATE_OFDM6)\n\t\treturn;\n\n\tif (!phy_ppdu->to_self)\n\t\treturn;\n\n\tphy_ppdu->ofdm.avg_snr = le32_get_bits(ie->w2, RTW89_PHY_STS_IE01_W2_AVG_SNR);\n\tphy_ppdu->ofdm.evm_max = le32_get_bits(ie->w2, RTW89_PHY_STS_IE01_W2_EVM_MAX);\n\tphy_ppdu->ofdm.evm_min = le32_get_bits(ie->w2, RTW89_PHY_STS_IE01_W2_EVM_MIN);\n\tphy_ppdu->ofdm.has = true;\n\n\t \n\tif (rtwdev->chip->cfo_src_fd) {\n\t\tt = le32_get_bits(ie->w1, RTW89_PHY_STS_IE01_W1_FD_CFO);\n\t\tcfo = sign_extend32(t, 11);\n\t} else {\n\t\tt = le32_get_bits(ie->w1, RTW89_PHY_STS_IE01_W1_PREMB_CFO);\n\t\tcfo = sign_extend32(t, 11);\n\t}\n\n\trtw89_phy_cfo_parse(rtwdev, cfo, phy_ppdu);\n}\n\nstatic int rtw89_core_process_phy_status_ie(struct rtw89_dev *rtwdev,\n\t\t\t\t\t    const struct rtw89_phy_sts_iehdr *iehdr,\n\t\t\t\t\t    struct rtw89_rx_phy_ppdu *phy_ppdu)\n{\n\tu8 ie;\n\n\tie = le32_get_bits(iehdr->w0, RTW89_PHY_STS_IEHDR_TYPE);\n\n\tswitch (ie) {\n\tcase RTW89_PHYSTS_IE01_CMN_OFDM:\n\t\trtw89_core_parse_phy_status_ie01(rtwdev, iehdr, phy_ppdu);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void rtw89_core_update_phy_ppdu(struct rtw89_rx_phy_ppdu *phy_ppdu)\n{\n\tconst struct rtw89_phy_sts_hdr *hdr = phy_ppdu->buf;\n\tu8 *rssi = phy_ppdu->rssi;\n\n\tphy_ppdu->ie = le32_get_bits(hdr->w0, RTW89_PHY_STS_HDR_W0_IE_MAP);\n\tphy_ppdu->rssi_avg = le32_get_bits(hdr->w0, RTW89_PHY_STS_HDR_W0_RSSI_AVG);\n\trssi[RF_PATH_A] = le32_get_bits(hdr->w1, RTW89_PHY_STS_HDR_W1_RSSI_A);\n\trssi[RF_PATH_B] = le32_get_bits(hdr->w1, RTW89_PHY_STS_HDR_W1_RSSI_B);\n\trssi[RF_PATH_C] = le32_get_bits(hdr->w1, RTW89_PHY_STS_HDR_W1_RSSI_C);\n\trssi[RF_PATH_D] = le32_get_bits(hdr->w1, RTW89_PHY_STS_HDR_W1_RSSI_D);\n}\n\nstatic int rtw89_core_rx_process_phy_ppdu(struct rtw89_dev *rtwdev,\n\t\t\t\t\t  struct rtw89_rx_phy_ppdu *phy_ppdu)\n{\n\tconst struct rtw89_phy_sts_hdr *hdr = phy_ppdu->buf;\n\tu32 len_from_header;\n\n\tlen_from_header = le32_get_bits(hdr->w0, RTW89_PHY_STS_HDR_W0_LEN) << 3;\n\n\tif (len_from_header != phy_ppdu->len) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_UNEXP, \"phy ppdu len mismatch\\n\");\n\t\treturn -EINVAL;\n\t}\n\trtw89_core_update_phy_ppdu(phy_ppdu);\n\n\treturn 0;\n}\n\nstatic int rtw89_core_rx_parse_phy_sts(struct rtw89_dev *rtwdev,\n\t\t\t\t       struct rtw89_rx_phy_ppdu *phy_ppdu)\n{\n\tu16 ie_len;\n\tvoid *pos, *end;\n\n\t \n\tif (phy_ppdu->ie < RTW89_CCK_PKT)\n\t\treturn -EINVAL;\n\n\tpos = phy_ppdu->buf + PHY_STS_HDR_LEN;\n\tend = phy_ppdu->buf + phy_ppdu->len;\n\twhile (pos < end) {\n\t\tconst struct rtw89_phy_sts_iehdr *iehdr = pos;\n\n\t\tie_len = rtw89_core_get_phy_status_ie_len(rtwdev, iehdr);\n\t\trtw89_core_process_phy_status_ie(rtwdev, iehdr, phy_ppdu);\n\t\tpos += ie_len;\n\t\tif (pos > end || ie_len == 0) {\n\t\t\trtw89_debug(rtwdev, RTW89_DBG_TXRX,\n\t\t\t\t    \"phy status parse failed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\trtw89_phy_antdiv_parse(rtwdev, phy_ppdu);\n\n\treturn 0;\n}\n\nstatic void rtw89_core_rx_process_phy_sts(struct rtw89_dev *rtwdev,\n\t\t\t\t\t  struct rtw89_rx_phy_ppdu *phy_ppdu)\n{\n\tint ret;\n\n\tret = rtw89_core_rx_parse_phy_sts(rtwdev, phy_ppdu);\n\tif (ret)\n\t\trtw89_debug(rtwdev, RTW89_DBG_TXRX, \"parse phy sts failed\\n\");\n\telse\n\t\tphy_ppdu->valid = true;\n\n\tieee80211_iterate_stations_atomic(rtwdev->hw,\n\t\t\t\t\t  rtw89_core_rx_process_phy_ppdu_iter,\n\t\t\t\t\t  phy_ppdu);\n}\n\nstatic u8 rtw89_rxdesc_to_nl_he_gi(struct rtw89_dev *rtwdev,\n\t\t\t\t   const struct rtw89_rx_desc_info *desc_info,\n\t\t\t\t   bool rx_status)\n{\n\tswitch (desc_info->gi_ltf) {\n\tcase RTW89_GILTF_SGI_4XHE08:\n\tcase RTW89_GILTF_2XHE08:\n\tcase RTW89_GILTF_1XHE08:\n\t\treturn NL80211_RATE_INFO_HE_GI_0_8;\n\tcase RTW89_GILTF_2XHE16:\n\tcase RTW89_GILTF_1XHE16:\n\t\treturn NL80211_RATE_INFO_HE_GI_1_6;\n\tcase RTW89_GILTF_LGI_4XHE32:\n\t\treturn NL80211_RATE_INFO_HE_GI_3_2;\n\tdefault:\n\t\trtw89_warn(rtwdev, \"invalid gi_ltf=%d\", desc_info->gi_ltf);\n\t\treturn rx_status ? NL80211_RATE_INFO_HE_GI_3_2 : U8_MAX;\n\t}\n}\n\nstatic bool rtw89_core_rx_ppdu_match(struct rtw89_dev *rtwdev,\n\t\t\t\t     struct rtw89_rx_desc_info *desc_info,\n\t\t\t\t     struct ieee80211_rx_status *status)\n{\n\tu8 band = desc_info->bb_sel ? RTW89_PHY_1 : RTW89_PHY_0;\n\tu8 data_rate_mode, bw, rate_idx = MASKBYTE0, gi_ltf;\n\tu16 data_rate;\n\tbool ret;\n\n\tdata_rate = desc_info->data_rate;\n\tdata_rate_mode = rtw89_get_data_rate_mode(rtwdev, data_rate);\n\tif (data_rate_mode == DATA_RATE_MODE_NON_HT) {\n\t\trate_idx = rtw89_get_data_not_ht_idx(rtwdev, data_rate);\n\t\t \n\t} else if (data_rate_mode == DATA_RATE_MODE_HT) {\n\t\trate_idx = rtw89_get_data_ht_mcs(rtwdev, data_rate);\n\t} else if (data_rate_mode == DATA_RATE_MODE_VHT) {\n\t\trate_idx = rtw89_get_data_mcs(rtwdev, data_rate);\n\t} else if (data_rate_mode == DATA_RATE_MODE_HE) {\n\t\trate_idx = rtw89_get_data_mcs(rtwdev, data_rate);\n\t} else {\n\t\trtw89_warn(rtwdev, \"invalid RX rate mode %d\\n\", data_rate_mode);\n\t}\n\n\tbw = rtw89_hw_to_rate_info_bw(desc_info->bw);\n\tgi_ltf = rtw89_rxdesc_to_nl_he_gi(rtwdev, desc_info, false);\n\tret = rtwdev->ppdu_sts.curr_rx_ppdu_cnt[band] == desc_info->ppdu_cnt &&\n\t      status->rate_idx == rate_idx &&\n\t      status->he_gi == gi_ltf &&\n\t      status->bw == bw;\n\n\treturn ret;\n}\n\nstruct rtw89_vif_rx_stats_iter_data {\n\tstruct rtw89_dev *rtwdev;\n\tstruct rtw89_rx_phy_ppdu *phy_ppdu;\n\tstruct rtw89_rx_desc_info *desc_info;\n\tstruct sk_buff *skb;\n\tconst u8 *bssid;\n};\n\nstatic void rtw89_stats_trigger_frame(struct rtw89_dev *rtwdev,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct rtw89_vif *rtwvif = (struct rtw89_vif *)vif->drv_priv;\n\tstruct ieee80211_trigger *tf = (struct ieee80211_trigger *)skb->data;\n\tu8 *pos, *end, type;\n\tu16 aid;\n\n\tif (!ether_addr_equal(vif->bss_conf.bssid, tf->ta) ||\n\t    rtwvif->wifi_role != RTW89_WIFI_ROLE_STATION ||\n\t    rtwvif->net_type == RTW89_NET_TYPE_NO_LINK)\n\t\treturn;\n\n\ttype = le64_get_bits(tf->common_info, IEEE80211_TRIGGER_TYPE_MASK);\n\tif (type != IEEE80211_TRIGGER_TYPE_BASIC)\n\t\treturn;\n\n\tend = (u8 *)tf + skb->len;\n\tpos = tf->variable;\n\n\twhile (end - pos >= RTW89_TF_BASIC_USER_INFO_SZ) {\n\t\taid = RTW89_GET_TF_USER_INFO_AID12(pos);\n\t\trtw89_debug(rtwdev, RTW89_DBG_TXRX,\n\t\t\t    \"[TF] aid: %d, ul_mcs: %d, rua: %d\\n\",\n\t\t\t    aid, RTW89_GET_TF_USER_INFO_UL_MCS(pos),\n\t\t\t    RTW89_GET_TF_USER_INFO_RUA(pos));\n\n\t\tif (aid == RTW89_TF_PAD)\n\t\t\tbreak;\n\n\t\tif (aid == vif->cfg.aid) {\n\t\t\trtwvif->stats.rx_tf_acc++;\n\t\t\trtwdev->stats.rx_tf_acc++;\n\t\t\tbreak;\n\t\t}\n\n\t\tpos += RTW89_TF_BASIC_USER_INFO_SZ;\n\t}\n}\n\nstatic void rtw89_cancel_6ghz_probe_work(struct work_struct *work)\n{\n\tstruct rtw89_dev *rtwdev = container_of(work, struct rtw89_dev,\n\t\t\t\t\t\tcancel_6ghz_probe_work);\n\tstruct list_head *pkt_list = rtwdev->scan_info.pkt_list;\n\tstruct rtw89_pktofld_info *info;\n\n\tmutex_lock(&rtwdev->mutex);\n\n\tif (!rtwdev->scanning)\n\t\tgoto out;\n\n\tlist_for_each_entry(info, &pkt_list[NL80211_BAND_6GHZ], list) {\n\t\tif (!info->cancel || !test_bit(info->id, rtwdev->pkt_offload))\n\t\t\tcontinue;\n\n\t\trtw89_fw_h2c_del_pkt_offload(rtwdev, info->id);\n\n\t\t \n\t}\n\nout:\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nstatic void rtw89_core_cancel_6ghz_probe_tx(struct rtw89_dev *rtwdev,\n\t\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct ieee80211_rx_status *rx_status = IEEE80211_SKB_RXCB(skb);\n\tstruct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)skb->data;\n\tstruct list_head *pkt_list = rtwdev->scan_info.pkt_list;\n\tstruct rtw89_pktofld_info *info;\n\tconst u8 *ies = mgmt->u.beacon.variable, *ssid_ie;\n\tbool queue_work = false;\n\n\tif (rx_status->band != NL80211_BAND_6GHZ)\n\t\treturn;\n\n\tssid_ie = cfg80211_find_ie(WLAN_EID_SSID, ies, skb->len);\n\n\tlist_for_each_entry(info, &pkt_list[NL80211_BAND_6GHZ], list) {\n\t\tif (ether_addr_equal(info->bssid, mgmt->bssid)) {\n\t\t\tinfo->cancel = true;\n\t\t\tqueue_work = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!ssid_ie || ssid_ie[1] != info->ssid_len || info->ssid_len == 0)\n\t\t\tcontinue;\n\n\t\tif (memcmp(&ssid_ie[2], info->ssid, info->ssid_len) == 0) {\n\t\t\tinfo->cancel = true;\n\t\t\tqueue_work = true;\n\t\t}\n\t}\n\n\tif (queue_work)\n\t\tieee80211_queue_work(rtwdev->hw, &rtwdev->cancel_6ghz_probe_work);\n}\n\nstatic void rtw89_vif_rx_stats_iter(void *data, u8 *mac,\n\t\t\t\t    struct ieee80211_vif *vif)\n{\n\tstruct rtw89_vif *rtwvif = (struct rtw89_vif *)vif->drv_priv;\n\tstruct rtw89_vif_rx_stats_iter_data *iter_data = data;\n\tstruct rtw89_dev *rtwdev = iter_data->rtwdev;\n\tstruct rtw89_pkt_stat *pkt_stat = &rtwdev->phystat.cur_pkt_stat;\n\tstruct rtw89_rx_desc_info *desc_info = iter_data->desc_info;\n\tstruct sk_buff *skb = iter_data->skb;\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tstruct rtw89_rx_phy_ppdu *phy_ppdu = iter_data->phy_ppdu;\n\tconst u8 *bssid = iter_data->bssid;\n\n\tif (rtwdev->scanning &&\n\t    (ieee80211_is_beacon(hdr->frame_control) ||\n\t     ieee80211_is_probe_resp(hdr->frame_control)))\n\t\trtw89_core_cancel_6ghz_probe_tx(rtwdev, skb);\n\n\tif (!vif->bss_conf.bssid)\n\t\treturn;\n\n\tif (ieee80211_is_trigger(hdr->frame_control)) {\n\t\trtw89_stats_trigger_frame(rtwdev, vif, skb);\n\t\treturn;\n\t}\n\n\tif (!ether_addr_equal(vif->bss_conf.bssid, bssid))\n\t\treturn;\n\n\tif (ieee80211_is_beacon(hdr->frame_control)) {\n\t\tif (vif->type == NL80211_IFTYPE_STATION)\n\t\t\trtw89_fw_h2c_rssi_offload(rtwdev, phy_ppdu);\n\t\tpkt_stat->beacon_nr++;\n\t}\n\n\tif (!ether_addr_equal(vif->addr, hdr->addr1))\n\t\treturn;\n\n\tif (desc_info->data_rate < RTW89_HW_RATE_NR)\n\t\tpkt_stat->rx_rate_cnt[desc_info->data_rate]++;\n\n\trtw89_traffic_stats_accu(rtwdev, &rtwvif->stats, skb, false);\n}\n\nstatic void rtw89_core_rx_stats(struct rtw89_dev *rtwdev,\n\t\t\t\tstruct rtw89_rx_phy_ppdu *phy_ppdu,\n\t\t\t\tstruct rtw89_rx_desc_info *desc_info,\n\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct rtw89_vif_rx_stats_iter_data iter_data;\n\n\trtw89_traffic_stats_accu(rtwdev, &rtwdev->stats, skb, false);\n\n\titer_data.rtwdev = rtwdev;\n\titer_data.phy_ppdu = phy_ppdu;\n\titer_data.desc_info = desc_info;\n\titer_data.skb = skb;\n\titer_data.bssid = get_hdr_bssid((struct ieee80211_hdr *)skb->data);\n\trtw89_iterate_vifs_bh(rtwdev, rtw89_vif_rx_stats_iter, &iter_data);\n}\n\nstatic void rtw89_correct_cck_chan(struct rtw89_dev *rtwdev,\n\t\t\t\t   struct ieee80211_rx_status *status)\n{\n\tconst struct rtw89_chan_rcd *rcd =\n\t\trtw89_chan_rcd_get(rtwdev, RTW89_SUB_ENTITY_0);\n\tu16 chan = rcd->prev_primary_channel;\n\tu8 band = rtw89_hw_to_nl80211_band(rcd->prev_band_type);\n\n\tif (status->band != NL80211_BAND_2GHZ &&\n\t    status->encoding == RX_ENC_LEGACY &&\n\t    status->rate_idx < RTW89_HW_RATE_OFDM6) {\n\t\tstatus->freq = ieee80211_channel_to_frequency(chan, band);\n\t\tstatus->band = band;\n\t}\n}\n\nstatic void rtw89_core_hw_to_sband_rate(struct ieee80211_rx_status *rx_status)\n{\n\tif (rx_status->band == NL80211_BAND_2GHZ ||\n\t    rx_status->encoding != RX_ENC_LEGACY)\n\t\treturn;\n\n\t \n\tif (rx_status->rate_idx < RTW89_HW_RATE_OFDM6) {\n\t\trx_status->rate_idx = 0;\n\t\treturn;\n\t}\n\n\t \n\trx_status->rate_idx -= 4;\n}\n\nstatic void rtw89_core_update_radiotap(struct rtw89_dev *rtwdev,\n\t\t\t\t       struct sk_buff *skb,\n\t\t\t\t       struct ieee80211_rx_status *rx_status)\n{\n\tstatic const struct ieee80211_radiotap_he known_he = {\n\t\t.data1 = cpu_to_le16(IEEE80211_RADIOTAP_HE_DATA1_DATA_MCS_KNOWN |\n\t\t\t\t     IEEE80211_RADIOTAP_HE_DATA1_BW_RU_ALLOC_KNOWN),\n\t\t.data2 = cpu_to_le16(IEEE80211_RADIOTAP_HE_DATA2_GI_KNOWN),\n\t};\n\tstruct ieee80211_radiotap_he *he;\n\n\tif (!(rtwdev->hw->conf.flags & IEEE80211_CONF_MONITOR))\n\t\treturn;\n\n\tif (rx_status->encoding == RX_ENC_HE) {\n\t\trx_status->flag |= RX_FLAG_RADIOTAP_HE;\n\t\the = skb_push(skb, sizeof(*he));\n\t\t*he = known_he;\n\t}\n}\n\nstatic void rtw89_core_rx_to_mac80211(struct rtw89_dev *rtwdev,\n\t\t\t\t      struct rtw89_rx_phy_ppdu *phy_ppdu,\n\t\t\t\t      struct rtw89_rx_desc_info *desc_info,\n\t\t\t\t      struct sk_buff *skb_ppdu,\n\t\t\t\t      struct ieee80211_rx_status *rx_status)\n{\n\tstruct napi_struct *napi = &rtwdev->napi;\n\n\t \n\tif (unlikely(!test_bit(NAPI_STATE_SCHED, &napi->state)))\n\t\tnapi = NULL;\n\n\trtw89_core_hw_to_sband_rate(rx_status);\n\trtw89_core_rx_stats(rtwdev, phy_ppdu, desc_info, skb_ppdu);\n\trtw89_core_update_radiotap(rtwdev, skb_ppdu, rx_status);\n\t \n\tlocal_bh_disable();\n\tieee80211_rx_napi(rtwdev->hw, NULL, skb_ppdu, napi);\n\tlocal_bh_enable();\n\trtwdev->napi_budget_countdown--;\n}\n\nstatic void rtw89_core_rx_pending_skb(struct rtw89_dev *rtwdev,\n\t\t\t\t      struct rtw89_rx_phy_ppdu *phy_ppdu,\n\t\t\t\t      struct rtw89_rx_desc_info *desc_info,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tu8 band = desc_info->bb_sel ? RTW89_PHY_1 : RTW89_PHY_0;\n\tint curr = rtwdev->ppdu_sts.curr_rx_ppdu_cnt[band];\n\tstruct sk_buff *skb_ppdu = NULL, *tmp;\n\tstruct ieee80211_rx_status *rx_status;\n\n\tif (curr > RTW89_MAX_PPDU_CNT)\n\t\treturn;\n\n\tskb_queue_walk_safe(&rtwdev->ppdu_sts.rx_queue[band], skb_ppdu, tmp) {\n\t\tskb_unlink(skb_ppdu, &rtwdev->ppdu_sts.rx_queue[band]);\n\t\trx_status = IEEE80211_SKB_RXCB(skb_ppdu);\n\t\tif (rtw89_core_rx_ppdu_match(rtwdev, desc_info, rx_status))\n\t\t\trtw89_chip_query_ppdu(rtwdev, phy_ppdu, rx_status);\n\t\trtw89_correct_cck_chan(rtwdev, rx_status);\n\t\trtw89_core_rx_to_mac80211(rtwdev, phy_ppdu, desc_info, skb_ppdu, rx_status);\n\t}\n}\n\nstatic void rtw89_core_rx_process_ppdu_sts(struct rtw89_dev *rtwdev,\n\t\t\t\t\t   struct rtw89_rx_desc_info *desc_info,\n\t\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct rtw89_rx_phy_ppdu phy_ppdu = {.buf = skb->data, .valid = false,\n\t\t\t\t\t     .len = skb->len,\n\t\t\t\t\t     .to_self = desc_info->addr1_match,\n\t\t\t\t\t     .rate = desc_info->data_rate,\n\t\t\t\t\t     .mac_id = desc_info->mac_id};\n\tint ret;\n\n\tif (desc_info->mac_info_valid)\n\t\trtw89_core_rx_process_mac_ppdu(rtwdev, skb, &phy_ppdu);\n\tret = rtw89_core_rx_process_phy_ppdu(rtwdev, &phy_ppdu);\n\tif (ret)\n\t\trtw89_debug(rtwdev, RTW89_DBG_TXRX, \"process ppdu failed\\n\");\n\n\trtw89_core_rx_process_phy_sts(rtwdev, &phy_ppdu);\n\trtw89_core_rx_pending_skb(rtwdev, &phy_ppdu, desc_info, skb);\n\tdev_kfree_skb_any(skb);\n}\n\nstatic void rtw89_core_rx_process_report(struct rtw89_dev *rtwdev,\n\t\t\t\t\t struct rtw89_rx_desc_info *desc_info,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tswitch (desc_info->pkt_type) {\n\tcase RTW89_CORE_RX_TYPE_C2H:\n\t\trtw89_fw_c2h_irqsafe(rtwdev, skb);\n\t\tbreak;\n\tcase RTW89_CORE_RX_TYPE_PPDU_STAT:\n\t\trtw89_core_rx_process_ppdu_sts(rtwdev, desc_info, skb);\n\t\tbreak;\n\tdefault:\n\t\trtw89_debug(rtwdev, RTW89_DBG_TXRX, \"unhandled pkt_type=%d\\n\",\n\t\t\t    desc_info->pkt_type);\n\t\tdev_kfree_skb_any(skb);\n\t\tbreak;\n\t}\n}\n\nvoid rtw89_core_query_rxdesc(struct rtw89_dev *rtwdev,\n\t\t\t     struct rtw89_rx_desc_info *desc_info,\n\t\t\t     u8 *data, u32 data_offset)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tstruct rtw89_rxdesc_short *rxd_s;\n\tstruct rtw89_rxdesc_long *rxd_l;\n\tu8 shift_len, drv_info_len;\n\n\trxd_s = (struct rtw89_rxdesc_short *)(data + data_offset);\n\tdesc_info->pkt_size = le32_get_bits(rxd_s->dword0, AX_RXD_RPKT_LEN_MASK);\n\tdesc_info->drv_info_size = le32_get_bits(rxd_s->dword0, AX_RXD_DRV_INFO_SIZE_MASK);\n\tdesc_info->long_rxdesc = le32_get_bits(rxd_s->dword0,  AX_RXD_LONG_RXD);\n\tdesc_info->pkt_type = le32_get_bits(rxd_s->dword0,  AX_RXD_RPKT_TYPE_MASK);\n\tdesc_info->mac_info_valid = le32_get_bits(rxd_s->dword0, AX_RXD_MAC_INFO_VLD);\n\tif (chip->chip_id == RTL8852C)\n\t\tdesc_info->bw = le32_get_bits(rxd_s->dword1, AX_RXD_BW_v1_MASK);\n\telse\n\t\tdesc_info->bw = le32_get_bits(rxd_s->dword1, AX_RXD_BW_MASK);\n\tdesc_info->data_rate = le32_get_bits(rxd_s->dword1, AX_RXD_RX_DATARATE_MASK);\n\tdesc_info->gi_ltf = le32_get_bits(rxd_s->dword1, AX_RXD_RX_GI_LTF_MASK);\n\tdesc_info->user_id = le32_get_bits(rxd_s->dword1, AX_RXD_USER_ID_MASK);\n\tdesc_info->sr_en = le32_get_bits(rxd_s->dword1, AX_RXD_SR_EN);\n\tdesc_info->ppdu_cnt = le32_get_bits(rxd_s->dword1, AX_RXD_PPDU_CNT_MASK);\n\tdesc_info->ppdu_type = le32_get_bits(rxd_s->dword1, AX_RXD_PPDU_TYPE_MASK);\n\tdesc_info->free_run_cnt = le32_get_bits(rxd_s->dword2, AX_RXD_FREERUN_CNT_MASK);\n\tdesc_info->icv_err = le32_get_bits(rxd_s->dword3, AX_RXD_ICV_ERR);\n\tdesc_info->crc32_err = le32_get_bits(rxd_s->dword3, AX_RXD_CRC32_ERR);\n\tdesc_info->hw_dec = le32_get_bits(rxd_s->dword3, AX_RXD_HW_DEC);\n\tdesc_info->sw_dec = le32_get_bits(rxd_s->dword3, AX_RXD_SW_DEC);\n\tdesc_info->addr1_match = le32_get_bits(rxd_s->dword3, AX_RXD_A1_MATCH);\n\n\tshift_len = desc_info->shift << 1;  \n\tdrv_info_len = desc_info->drv_info_size << 3;  \n\tdesc_info->offset = data_offset + shift_len + drv_info_len;\n\tif (desc_info->long_rxdesc)\n\t\tdesc_info->rxd_len = sizeof(struct rtw89_rxdesc_long);\n\telse\n\t\tdesc_info->rxd_len = sizeof(struct rtw89_rxdesc_short);\n\tdesc_info->ready = true;\n\n\tif (!desc_info->long_rxdesc)\n\t\treturn;\n\n\trxd_l = (struct rtw89_rxdesc_long *)(data + data_offset);\n\tdesc_info->frame_type = le32_get_bits(rxd_l->dword4, AX_RXD_TYPE_MASK);\n\tdesc_info->addr_cam_valid = le32_get_bits(rxd_l->dword5, AX_RXD_ADDR_CAM_VLD);\n\tdesc_info->addr_cam_id = le32_get_bits(rxd_l->dword5, AX_RXD_ADDR_CAM_MASK);\n\tdesc_info->sec_cam_id = le32_get_bits(rxd_l->dword5, AX_RXD_SEC_CAM_IDX_MASK);\n\tdesc_info->mac_id = le32_get_bits(rxd_l->dword5, AX_RXD_MAC_ID_MASK);\n\tdesc_info->rx_pl_id = le32_get_bits(rxd_l->dword5, AX_RXD_RX_PL_ID_MASK);\n}\nEXPORT_SYMBOL(rtw89_core_query_rxdesc);\n\nstruct rtw89_core_iter_rx_status {\n\tstruct rtw89_dev *rtwdev;\n\tstruct ieee80211_rx_status *rx_status;\n\tstruct rtw89_rx_desc_info *desc_info;\n\tu8 mac_id;\n};\n\nstatic\nvoid rtw89_core_stats_sta_rx_status_iter(void *data, struct ieee80211_sta *sta)\n{\n\tstruct rtw89_core_iter_rx_status *iter_data =\n\t\t\t\t(struct rtw89_core_iter_rx_status *)data;\n\tstruct ieee80211_rx_status *rx_status = iter_data->rx_status;\n\tstruct rtw89_sta *rtwsta = (struct rtw89_sta *)sta->drv_priv;\n\tstruct rtw89_rx_desc_info *desc_info = iter_data->desc_info;\n\tu8 mac_id = iter_data->mac_id;\n\n\tif (mac_id != rtwsta->mac_id)\n\t\treturn;\n\n\trtwsta->rx_status = *rx_status;\n\trtwsta->rx_hw_rate = desc_info->data_rate;\n}\n\nstatic void rtw89_core_stats_sta_rx_status(struct rtw89_dev *rtwdev,\n\t\t\t\t\t   struct rtw89_rx_desc_info *desc_info,\n\t\t\t\t\t   struct ieee80211_rx_status *rx_status)\n{\n\tstruct rtw89_core_iter_rx_status iter_data;\n\n\tif (!desc_info->addr1_match || !desc_info->long_rxdesc)\n\t\treturn;\n\n\tif (desc_info->frame_type != RTW89_RX_TYPE_DATA)\n\t\treturn;\n\n\titer_data.rtwdev = rtwdev;\n\titer_data.rx_status = rx_status;\n\titer_data.desc_info = desc_info;\n\titer_data.mac_id = desc_info->mac_id;\n\tieee80211_iterate_stations_atomic(rtwdev->hw,\n\t\t\t\t\t  rtw89_core_stats_sta_rx_status_iter,\n\t\t\t\t\t  &iter_data);\n}\n\nstatic void rtw89_core_update_rx_status(struct rtw89_dev *rtwdev,\n\t\t\t\t\tstruct rtw89_rx_desc_info *desc_info,\n\t\t\t\t\tstruct ieee80211_rx_status *rx_status)\n{\n\tconst struct cfg80211_chan_def *chandef =\n\t\trtw89_chandef_get(rtwdev, RTW89_SUB_ENTITY_0);\n\tu16 data_rate;\n\tu8 data_rate_mode;\n\n\t \n\trx_status->freq = chandef->chan->center_freq;\n\trx_status->band = chandef->chan->band;\n\n\tif (rtwdev->scanning &&\n\t    RTW89_CHK_FW_FEATURE(SCAN_OFFLOAD, &rtwdev->fw)) {\n\t\tconst struct rtw89_chan *cur = rtw89_scan_chan_get(rtwdev);\n\t\tu8 chan = cur->primary_channel;\n\t\tu8 band = cur->band_type;\n\t\tenum nl80211_band nl_band;\n\n\t\tnl_band = rtw89_hw_to_nl80211_band(band);\n\t\trx_status->freq = ieee80211_channel_to_frequency(chan, nl_band);\n\t\trx_status->band = nl_band;\n\t}\n\n\tif (desc_info->icv_err || desc_info->crc32_err)\n\t\trx_status->flag |= RX_FLAG_FAILED_FCS_CRC;\n\n\tif (desc_info->hw_dec &&\n\t    !(desc_info->sw_dec || desc_info->icv_err))\n\t\trx_status->flag |= RX_FLAG_DECRYPTED;\n\n\trx_status->bw = rtw89_hw_to_rate_info_bw(desc_info->bw);\n\n\tdata_rate = desc_info->data_rate;\n\tdata_rate_mode = rtw89_get_data_rate_mode(rtwdev, data_rate);\n\tif (data_rate_mode == DATA_RATE_MODE_NON_HT) {\n\t\trx_status->encoding = RX_ENC_LEGACY;\n\t\trx_status->rate_idx = rtw89_get_data_not_ht_idx(rtwdev, data_rate);\n\t\t \n\t} else if (data_rate_mode == DATA_RATE_MODE_HT) {\n\t\trx_status->encoding = RX_ENC_HT;\n\t\trx_status->rate_idx = rtw89_get_data_ht_mcs(rtwdev, data_rate);\n\t\tif (desc_info->gi_ltf)\n\t\t\trx_status->enc_flags |= RX_ENC_FLAG_SHORT_GI;\n\t} else if (data_rate_mode == DATA_RATE_MODE_VHT) {\n\t\trx_status->encoding = RX_ENC_VHT;\n\t\trx_status->rate_idx = rtw89_get_data_mcs(rtwdev, data_rate);\n\t\trx_status->nss = rtw89_get_data_nss(rtwdev, data_rate) + 1;\n\t\tif (desc_info->gi_ltf)\n\t\t\trx_status->enc_flags |= RX_ENC_FLAG_SHORT_GI;\n\t} else if (data_rate_mode == DATA_RATE_MODE_HE) {\n\t\trx_status->encoding = RX_ENC_HE;\n\t\trx_status->rate_idx = rtw89_get_data_mcs(rtwdev, data_rate);\n\t\trx_status->nss = rtw89_get_data_nss(rtwdev, data_rate) + 1;\n\t} else {\n\t\trtw89_warn(rtwdev, \"invalid RX rate mode %d\\n\", data_rate_mode);\n\t}\n\n\t \n\trx_status->he_gi = rtw89_rxdesc_to_nl_he_gi(rtwdev, desc_info, true);\n\trx_status->flag |= RX_FLAG_MACTIME_START;\n\trx_status->mactime = desc_info->free_run_cnt;\n\n\trtw89_core_stats_sta_rx_status(rtwdev, desc_info, rx_status);\n}\n\nstatic enum rtw89_ps_mode rtw89_update_ps_mode(struct rtw89_dev *rtwdev)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\n\tif (rtw89_disable_ps_mode || !chip->ps_mode_supported ||\n\t    RTW89_CHK_FW_FEATURE(NO_DEEP_PS, &rtwdev->fw))\n\t\treturn RTW89_PS_MODE_NONE;\n\n\tif ((chip->ps_mode_supported & BIT(RTW89_PS_MODE_PWR_GATED)) &&\n\t    !RTW89_CHK_FW_FEATURE(NO_LPS_PG, &rtwdev->fw))\n\t\treturn RTW89_PS_MODE_PWR_GATED;\n\n\tif (chip->ps_mode_supported & BIT(RTW89_PS_MODE_CLK_GATED))\n\t\treturn RTW89_PS_MODE_CLK_GATED;\n\n\tif (chip->ps_mode_supported & BIT(RTW89_PS_MODE_RFOFF))\n\t\treturn RTW89_PS_MODE_RFOFF;\n\n\treturn RTW89_PS_MODE_NONE;\n}\n\nstatic void rtw89_core_flush_ppdu_rx_queue(struct rtw89_dev *rtwdev,\n\t\t\t\t\t   struct rtw89_rx_desc_info *desc_info)\n{\n\tstruct rtw89_ppdu_sts_info *ppdu_sts = &rtwdev->ppdu_sts;\n\tu8 band = desc_info->bb_sel ? RTW89_PHY_1 : RTW89_PHY_0;\n\tstruct ieee80211_rx_status *rx_status;\n\tstruct sk_buff *skb_ppdu, *tmp;\n\n\tskb_queue_walk_safe(&ppdu_sts->rx_queue[band], skb_ppdu, tmp) {\n\t\tskb_unlink(skb_ppdu, &ppdu_sts->rx_queue[band]);\n\t\trx_status = IEEE80211_SKB_RXCB(skb_ppdu);\n\t\trtw89_core_rx_to_mac80211(rtwdev, NULL, desc_info, skb_ppdu, rx_status);\n\t}\n}\n\nvoid rtw89_core_rx(struct rtw89_dev *rtwdev,\n\t\t   struct rtw89_rx_desc_info *desc_info,\n\t\t   struct sk_buff *skb)\n{\n\tstruct ieee80211_rx_status *rx_status;\n\tstruct rtw89_ppdu_sts_info *ppdu_sts = &rtwdev->ppdu_sts;\n\tu8 ppdu_cnt = desc_info->ppdu_cnt;\n\tu8 band = desc_info->bb_sel ? RTW89_PHY_1 : RTW89_PHY_0;\n\n\tif (desc_info->pkt_type != RTW89_CORE_RX_TYPE_WIFI) {\n\t\trtw89_core_rx_process_report(rtwdev, desc_info, skb);\n\t\treturn;\n\t}\n\n\tif (ppdu_sts->curr_rx_ppdu_cnt[band] != ppdu_cnt) {\n\t\trtw89_core_flush_ppdu_rx_queue(rtwdev, desc_info);\n\t\tppdu_sts->curr_rx_ppdu_cnt[band] = ppdu_cnt;\n\t}\n\n\trx_status = IEEE80211_SKB_RXCB(skb);\n\tmemset(rx_status, 0, sizeof(*rx_status));\n\trtw89_core_update_rx_status(rtwdev, desc_info, rx_status);\n\tif (desc_info->long_rxdesc &&\n\t    BIT(desc_info->frame_type) & PPDU_FILTER_BITMAP)\n\t\tskb_queue_tail(&ppdu_sts->rx_queue[band], skb);\n\telse\n\t\trtw89_core_rx_to_mac80211(rtwdev, NULL, desc_info, skb, rx_status);\n}\nEXPORT_SYMBOL(rtw89_core_rx);\n\nvoid rtw89_core_napi_start(struct rtw89_dev *rtwdev)\n{\n\tif (test_and_set_bit(RTW89_FLAG_NAPI_RUNNING, rtwdev->flags))\n\t\treturn;\n\n\tnapi_enable(&rtwdev->napi);\n}\nEXPORT_SYMBOL(rtw89_core_napi_start);\n\nvoid rtw89_core_napi_stop(struct rtw89_dev *rtwdev)\n{\n\tif (!test_and_clear_bit(RTW89_FLAG_NAPI_RUNNING, rtwdev->flags))\n\t\treturn;\n\n\tnapi_synchronize(&rtwdev->napi);\n\tnapi_disable(&rtwdev->napi);\n}\nEXPORT_SYMBOL(rtw89_core_napi_stop);\n\nvoid rtw89_core_napi_init(struct rtw89_dev *rtwdev)\n{\n\tinit_dummy_netdev(&rtwdev->netdev);\n\tnetif_napi_add(&rtwdev->netdev, &rtwdev->napi,\n\t\t       rtwdev->hci.ops->napi_poll);\n}\nEXPORT_SYMBOL(rtw89_core_napi_init);\n\nvoid rtw89_core_napi_deinit(struct rtw89_dev *rtwdev)\n{\n\trtw89_core_napi_stop(rtwdev);\n\tnetif_napi_del(&rtwdev->napi);\n}\nEXPORT_SYMBOL(rtw89_core_napi_deinit);\n\nstatic void rtw89_core_ba_work(struct work_struct *work)\n{\n\tstruct rtw89_dev *rtwdev =\n\t\tcontainer_of(work, struct rtw89_dev, ba_work);\n\tstruct rtw89_txq *rtwtxq, *tmp;\n\tint ret;\n\n\tspin_lock_bh(&rtwdev->ba_lock);\n\tlist_for_each_entry_safe(rtwtxq, tmp, &rtwdev->ba_list, list) {\n\t\tstruct ieee80211_txq *txq = rtw89_txq_to_txq(rtwtxq);\n\t\tstruct ieee80211_sta *sta = txq->sta;\n\t\tstruct rtw89_sta *rtwsta = sta ? (struct rtw89_sta *)sta->drv_priv : NULL;\n\t\tu8 tid = txq->tid;\n\n\t\tif (!sta) {\n\t\t\trtw89_warn(rtwdev, \"cannot start BA without sta\\n\");\n\t\t\tgoto skip_ba_work;\n\t\t}\n\n\t\tif (rtwsta->disassoc) {\n\t\t\trtw89_debug(rtwdev, RTW89_DBG_TXRX,\n\t\t\t\t    \"cannot start BA with disassoc sta\\n\");\n\t\t\tgoto skip_ba_work;\n\t\t}\n\n\t\tret = ieee80211_start_tx_ba_session(sta, tid, 0);\n\t\tif (ret) {\n\t\t\trtw89_debug(rtwdev, RTW89_DBG_TXRX,\n\t\t\t\t    \"failed to setup BA session for %pM:%2d: %d\\n\",\n\t\t\t\t    sta->addr, tid, ret);\n\t\t\tif (ret == -EINVAL)\n\t\t\t\tset_bit(RTW89_TXQ_F_BLOCK_BA, &rtwtxq->flags);\n\t\t}\nskip_ba_work:\n\t\tlist_del_init(&rtwtxq->list);\n\t}\n\tspin_unlock_bh(&rtwdev->ba_lock);\n}\n\nstatic void rtw89_core_free_sta_pending_ba(struct rtw89_dev *rtwdev,\n\t\t\t\t\t   struct ieee80211_sta *sta)\n{\n\tstruct rtw89_txq *rtwtxq, *tmp;\n\n\tspin_lock_bh(&rtwdev->ba_lock);\n\tlist_for_each_entry_safe(rtwtxq, tmp, &rtwdev->ba_list, list) {\n\t\tstruct ieee80211_txq *txq = rtw89_txq_to_txq(rtwtxq);\n\n\t\tif (sta == txq->sta)\n\t\t\tlist_del_init(&rtwtxq->list);\n\t}\n\tspin_unlock_bh(&rtwdev->ba_lock);\n}\n\nstatic void rtw89_core_free_sta_pending_forbid_ba(struct rtw89_dev *rtwdev,\n\t\t\t\t\t\t  struct ieee80211_sta *sta)\n{\n\tstruct rtw89_txq *rtwtxq, *tmp;\n\n\tspin_lock_bh(&rtwdev->ba_lock);\n\tlist_for_each_entry_safe(rtwtxq, tmp, &rtwdev->forbid_ba_list, list) {\n\t\tstruct ieee80211_txq *txq = rtw89_txq_to_txq(rtwtxq);\n\n\t\tif (sta == txq->sta) {\n\t\t\tclear_bit(RTW89_TXQ_F_FORBID_BA, &rtwtxq->flags);\n\t\t\tlist_del_init(&rtwtxq->list);\n\t\t}\n\t}\n\tspin_unlock_bh(&rtwdev->ba_lock);\n}\n\nstatic void rtw89_core_free_sta_pending_roc_tx(struct rtw89_dev *rtwdev,\n\t\t\t\t\t       struct ieee80211_sta *sta)\n{\n\tstruct rtw89_sta *rtwsta = (struct rtw89_sta *)sta->drv_priv;\n\tstruct sk_buff *skb, *tmp;\n\n\tskb_queue_walk_safe(&rtwsta->roc_queue, skb, tmp) {\n\t\tskb_unlink(skb, &rtwsta->roc_queue);\n\t\tdev_kfree_skb_any(skb);\n\t}\n}\n\nstatic void rtw89_core_stop_tx_ba_session(struct rtw89_dev *rtwdev,\n\t\t\t\t\t  struct rtw89_txq *rtwtxq)\n{\n\tstruct ieee80211_txq *txq = rtw89_txq_to_txq(rtwtxq);\n\tstruct ieee80211_sta *sta = txq->sta;\n\tstruct rtw89_sta *rtwsta = sta_to_rtwsta_safe(sta);\n\n\tif (unlikely(!rtwsta) || unlikely(rtwsta->disassoc))\n\t\treturn;\n\n\tif (!test_bit(RTW89_TXQ_F_AMPDU, &rtwtxq->flags) ||\n\t    test_bit(RTW89_TXQ_F_FORBID_BA, &rtwtxq->flags))\n\t\treturn;\n\n\tspin_lock_bh(&rtwdev->ba_lock);\n\tif (!test_and_set_bit(RTW89_TXQ_F_FORBID_BA, &rtwtxq->flags))\n\t\tlist_add_tail(&rtwtxq->list, &rtwdev->forbid_ba_list);\n\tspin_unlock_bh(&rtwdev->ba_lock);\n\n\tieee80211_stop_tx_ba_session(sta, txq->tid);\n\tcancel_delayed_work(&rtwdev->forbid_ba_work);\n\tieee80211_queue_delayed_work(rtwdev->hw, &rtwdev->forbid_ba_work,\n\t\t\t\t     RTW89_FORBID_BA_TIMER);\n}\n\nstatic void rtw89_core_txq_check_agg(struct rtw89_dev *rtwdev,\n\t\t\t\t     struct rtw89_txq *rtwtxq,\n\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct ieee80211_hw *hw = rtwdev->hw;\n\tstruct ieee80211_txq *txq = rtw89_txq_to_txq(rtwtxq);\n\tstruct ieee80211_sta *sta = txq->sta;\n\tstruct rtw89_sta *rtwsta = sta ? (struct rtw89_sta *)sta->drv_priv : NULL;\n\n\tif (test_bit(RTW89_TXQ_F_FORBID_BA, &rtwtxq->flags))\n\t\treturn;\n\n\tif (unlikely(skb->protocol == cpu_to_be16(ETH_P_PAE))) {\n\t\trtw89_core_stop_tx_ba_session(rtwdev, rtwtxq);\n\t\treturn;\n\t}\n\n\tif (unlikely(!sta))\n\t\treturn;\n\n\tif (unlikely(test_bit(RTW89_TXQ_F_BLOCK_BA, &rtwtxq->flags)))\n\t\treturn;\n\n\tif (test_bit(RTW89_TXQ_F_AMPDU, &rtwtxq->flags)) {\n\t\tIEEE80211_SKB_CB(skb)->flags |= IEEE80211_TX_CTL_AMPDU;\n\t\treturn;\n\t}\n\n\tspin_lock_bh(&rtwdev->ba_lock);\n\tif (!rtwsta->disassoc && list_empty(&rtwtxq->list)) {\n\t\tlist_add_tail(&rtwtxq->list, &rtwdev->ba_list);\n\t\tieee80211_queue_work(hw, &rtwdev->ba_work);\n\t}\n\tspin_unlock_bh(&rtwdev->ba_lock);\n}\n\nstatic void rtw89_core_txq_push(struct rtw89_dev *rtwdev,\n\t\t\t\tstruct rtw89_txq *rtwtxq,\n\t\t\t\tunsigned long frame_cnt,\n\t\t\t\tunsigned long byte_cnt)\n{\n\tstruct ieee80211_txq *txq = rtw89_txq_to_txq(rtwtxq);\n\tstruct ieee80211_vif *vif = txq->vif;\n\tstruct ieee80211_sta *sta = txq->sta;\n\tstruct sk_buff *skb;\n\tunsigned long i;\n\tint ret;\n\n\trcu_read_lock();\n\tfor (i = 0; i < frame_cnt; i++) {\n\t\tskb = ieee80211_tx_dequeue_ni(rtwdev->hw, txq);\n\t\tif (!skb) {\n\t\t\trtw89_debug(rtwdev, RTW89_DBG_TXRX, \"dequeue a NULL skb\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\trtw89_core_txq_check_agg(rtwdev, rtwtxq, skb);\n\t\tret = rtw89_core_tx_write(rtwdev, vif, sta, skb, NULL);\n\t\tif (ret) {\n\t\t\trtw89_err(rtwdev, \"failed to push txq: %d\\n\", ret);\n\t\t\tieee80211_free_txskb(rtwdev->hw, skb);\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\trcu_read_unlock();\n}\n\nstatic u32 rtw89_check_and_reclaim_tx_resource(struct rtw89_dev *rtwdev, u8 tid)\n{\n\tu8 qsel, ch_dma;\n\n\tqsel = rtw89_core_get_qsel(rtwdev, tid);\n\tch_dma = rtw89_core_get_ch_dma(rtwdev, qsel);\n\n\treturn rtw89_hci_check_and_reclaim_tx_resource(rtwdev, ch_dma);\n}\n\nstatic bool rtw89_core_txq_agg_wait(struct rtw89_dev *rtwdev,\n\t\t\t\t    struct ieee80211_txq *txq,\n\t\t\t\t    unsigned long *frame_cnt,\n\t\t\t\t    bool *sched_txq, bool *reinvoke)\n{\n\tstruct rtw89_txq *rtwtxq = (struct rtw89_txq *)txq->drv_priv;\n\tstruct ieee80211_sta *sta = txq->sta;\n\tstruct rtw89_sta *rtwsta = sta ? (struct rtw89_sta *)sta->drv_priv : NULL;\n\n\tif (!sta || rtwsta->max_agg_wait <= 0)\n\t\treturn false;\n\n\tif (rtwdev->stats.tx_tfc_lv <= RTW89_TFC_MID)\n\t\treturn false;\n\n\tif (*frame_cnt > 1) {\n\t\t*frame_cnt -= 1;\n\t\t*sched_txq = true;\n\t\t*reinvoke = true;\n\t\trtwtxq->wait_cnt = 1;\n\t\treturn false;\n\t}\n\n\tif (*frame_cnt == 1 && rtwtxq->wait_cnt < rtwsta->max_agg_wait) {\n\t\t*reinvoke = true;\n\t\trtwtxq->wait_cnt++;\n\t\treturn true;\n\t}\n\n\trtwtxq->wait_cnt = 0;\n\treturn false;\n}\n\nstatic void rtw89_core_txq_schedule(struct rtw89_dev *rtwdev, u8 ac, bool *reinvoke)\n{\n\tstruct ieee80211_hw *hw = rtwdev->hw;\n\tstruct ieee80211_txq *txq;\n\tstruct rtw89_vif *rtwvif;\n\tstruct rtw89_txq *rtwtxq;\n\tunsigned long frame_cnt;\n\tunsigned long byte_cnt;\n\tu32 tx_resource;\n\tbool sched_txq;\n\n\tieee80211_txq_schedule_start(hw, ac);\n\twhile ((txq = ieee80211_next_txq(hw, ac))) {\n\t\trtwtxq = (struct rtw89_txq *)txq->drv_priv;\n\t\trtwvif = (struct rtw89_vif *)txq->vif->drv_priv;\n\n\t\tif (rtwvif->offchan) {\n\t\t\tieee80211_return_txq(hw, txq, true);\n\t\t\tcontinue;\n\t\t}\n\t\ttx_resource = rtw89_check_and_reclaim_tx_resource(rtwdev, txq->tid);\n\t\tsched_txq = false;\n\n\t\tieee80211_txq_get_depth(txq, &frame_cnt, &byte_cnt);\n\t\tif (rtw89_core_txq_agg_wait(rtwdev, txq, &frame_cnt, &sched_txq, reinvoke)) {\n\t\t\tieee80211_return_txq(hw, txq, true);\n\t\t\tcontinue;\n\t\t}\n\t\tframe_cnt = min_t(unsigned long, frame_cnt, tx_resource);\n\t\trtw89_core_txq_push(rtwdev, rtwtxq, frame_cnt, byte_cnt);\n\t\tieee80211_return_txq(hw, txq, sched_txq);\n\t\tif (frame_cnt != 0)\n\t\t\trtw89_core_tx_kick_off(rtwdev, rtw89_core_get_qsel(rtwdev, txq->tid));\n\n\t\t \n\t\tif (frame_cnt == tx_resource)\n\t\t\t*reinvoke = true;\n\t}\n\tieee80211_txq_schedule_end(hw, ac);\n}\n\nstatic void rtw89_ips_work(struct work_struct *work)\n{\n\tstruct rtw89_dev *rtwdev = container_of(work, struct rtw89_dev,\n\t\t\t\t\t\tips_work);\n\tmutex_lock(&rtwdev->mutex);\n\trtw89_enter_ips_by_hwflags(rtwdev);\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nstatic void rtw89_core_txq_work(struct work_struct *w)\n{\n\tstruct rtw89_dev *rtwdev = container_of(w, struct rtw89_dev, txq_work);\n\tbool reinvoke = false;\n\tu8 ac;\n\n\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++)\n\t\trtw89_core_txq_schedule(rtwdev, ac, &reinvoke);\n\n\tif (reinvoke) {\n\t\t \n\t\tmod_delayed_work(rtwdev->txq_wq, &rtwdev->txq_reinvoke_work, 1);\n\t}\n}\n\nstatic void rtw89_core_txq_reinvoke_work(struct work_struct *w)\n{\n\tstruct rtw89_dev *rtwdev = container_of(w, struct rtw89_dev,\n\t\t\t\t\t\ttxq_reinvoke_work.work);\n\n\tqueue_work(rtwdev->txq_wq, &rtwdev->txq_work);\n}\n\nstatic void rtw89_forbid_ba_work(struct work_struct *w)\n{\n\tstruct rtw89_dev *rtwdev = container_of(w, struct rtw89_dev,\n\t\t\t\t\t\tforbid_ba_work.work);\n\tstruct rtw89_txq *rtwtxq, *tmp;\n\n\tspin_lock_bh(&rtwdev->ba_lock);\n\tlist_for_each_entry_safe(rtwtxq, tmp, &rtwdev->forbid_ba_list, list) {\n\t\tclear_bit(RTW89_TXQ_F_FORBID_BA, &rtwtxq->flags);\n\t\tlist_del_init(&rtwtxq->list);\n\t}\n\tspin_unlock_bh(&rtwdev->ba_lock);\n}\n\nstatic void rtw89_core_sta_pending_tx_iter(void *data,\n\t\t\t\t\t   struct ieee80211_sta *sta)\n{\n\tstruct rtw89_sta *rtwsta = (struct rtw89_sta *)sta->drv_priv;\n\tstruct rtw89_vif *rtwvif_target = data, *rtwvif = rtwsta->rtwvif;\n\tstruct rtw89_dev *rtwdev = rtwvif->rtwdev;\n\tstruct ieee80211_vif *vif = rtwvif_to_vif(rtwvif);\n\tstruct sk_buff *skb, *tmp;\n\tint qsel, ret;\n\n\tif (rtwvif->sub_entity_idx != rtwvif_target->sub_entity_idx)\n\t\treturn;\n\n\tif (skb_queue_len(&rtwsta->roc_queue) == 0)\n\t\treturn;\n\n\tskb_queue_walk_safe(&rtwsta->roc_queue, skb, tmp) {\n\t\tskb_unlink(skb, &rtwsta->roc_queue);\n\n\t\tret = rtw89_core_tx_write(rtwdev, vif, sta, skb, &qsel);\n\t\tif (ret) {\n\t\t\trtw89_warn(rtwdev, \"pending tx failed with %d\\n\", ret);\n\t\t\tdev_kfree_skb_any(skb);\n\t\t} else {\n\t\t\trtw89_core_tx_kick_off(rtwdev, qsel);\n\t\t}\n\t}\n}\n\nstatic void rtw89_core_handle_sta_pending_tx(struct rtw89_dev *rtwdev,\n\t\t\t\t\t     struct rtw89_vif *rtwvif)\n{\n\tieee80211_iterate_stations_atomic(rtwdev->hw,\n\t\t\t\t\t  rtw89_core_sta_pending_tx_iter,\n\t\t\t\t\t  rtwvif);\n}\n\nstatic int rtw89_core_send_nullfunc(struct rtw89_dev *rtwdev,\n\t\t\t\t    struct rtw89_vif *rtwvif, bool qos, bool ps)\n{\n\tstruct ieee80211_vif *vif = rtwvif_to_vif(rtwvif);\n\tstruct ieee80211_sta *sta;\n\tstruct ieee80211_hdr *hdr;\n\tstruct sk_buff *skb;\n\tint ret, qsel;\n\n\tif (vif->type != NL80211_IFTYPE_STATION || !vif->cfg.assoc)\n\t\treturn 0;\n\n\trcu_read_lock();\n\tsta = ieee80211_find_sta(vif, vif->bss_conf.bssid);\n\tif (!sta) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tskb = ieee80211_nullfunc_get(rtwdev->hw, vif, -1, qos);\n\tif (!skb) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\thdr = (struct ieee80211_hdr *)skb->data;\n\tif (ps)\n\t\thdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_PM);\n\n\tret = rtw89_core_tx_write(rtwdev, vif, sta, skb, &qsel);\n\tif (ret) {\n\t\trtw89_warn(rtwdev, \"nullfunc transmit failed: %d\\n\", ret);\n\t\tdev_kfree_skb_any(skb);\n\t\tgoto out;\n\t}\n\n\trcu_read_unlock();\n\n\treturn rtw89_core_tx_kick_off_and_wait(rtwdev, skb, qsel,\n\t\t\t\t\t       RTW89_ROC_TX_TIMEOUT);\nout:\n\trcu_read_unlock();\n\n\treturn ret;\n}\n\nvoid rtw89_roc_start(struct rtw89_dev *rtwdev, struct rtw89_vif *rtwvif)\n{\n\tconst struct rtw89_mac_gen_def *mac = rtwdev->chip->mac_def;\n\tstruct ieee80211_hw *hw = rtwdev->hw;\n\tstruct rtw89_roc *roc = &rtwvif->roc;\n\tstruct cfg80211_chan_def roc_chan;\n\tstruct rtw89_vif *tmp;\n\tint ret;\n\n\tlockdep_assert_held(&rtwdev->mutex);\n\n\tieee80211_queue_delayed_work(hw, &rtwvif->roc.roc_work,\n\t\t\t\t     msecs_to_jiffies(rtwvif->roc.duration));\n\n\trtw89_leave_ips_by_hwflags(rtwdev);\n\trtw89_leave_lps(rtwdev);\n\n\tret = rtw89_core_send_nullfunc(rtwdev, rtwvif, true, true);\n\tif (ret)\n\t\trtw89_debug(rtwdev, RTW89_DBG_TXRX,\n\t\t\t    \"roc send null-1 failed: %d\\n\", ret);\n\n\trtw89_for_each_rtwvif(rtwdev, tmp)\n\t\tif (tmp->sub_entity_idx == rtwvif->sub_entity_idx)\n\t\t\ttmp->offchan = true;\n\n\tcfg80211_chandef_create(&roc_chan, &roc->chan, NL80211_CHAN_NO_HT);\n\trtw89_config_roc_chandef(rtwdev, rtwvif->sub_entity_idx, &roc_chan);\n\trtw89_set_channel(rtwdev);\n\trtw89_write32_clr(rtwdev,\n\t\t\t  rtw89_mac_reg_by_idx(rtwdev, mac->rx_fltr, RTW89_MAC_0),\n\t\t\t  B_AX_A_UC_CAM_MATCH | B_AX_A_BC_CAM_MATCH);\n\n\tieee80211_ready_on_channel(hw);\n}\n\nvoid rtw89_roc_end(struct rtw89_dev *rtwdev, struct rtw89_vif *rtwvif)\n{\n\tconst struct rtw89_mac_gen_def *mac = rtwdev->chip->mac_def;\n\tstruct ieee80211_hw *hw = rtwdev->hw;\n\tstruct rtw89_roc *roc = &rtwvif->roc;\n\tstruct rtw89_vif *tmp;\n\tint ret;\n\n\tlockdep_assert_held(&rtwdev->mutex);\n\n\tieee80211_remain_on_channel_expired(hw);\n\n\trtw89_leave_ips_by_hwflags(rtwdev);\n\trtw89_leave_lps(rtwdev);\n\n\trtw89_write32_mask(rtwdev,\n\t\t\t   rtw89_mac_reg_by_idx(rtwdev, mac->rx_fltr, RTW89_MAC_0),\n\t\t\t   B_AX_RX_FLTR_CFG_MASK,\n\t\t\t   rtwdev->hal.rx_fltr);\n\n\troc->state = RTW89_ROC_IDLE;\n\trtw89_config_roc_chandef(rtwdev, rtwvif->sub_entity_idx, NULL);\n\trtw89_set_channel(rtwdev);\n\tret = rtw89_core_send_nullfunc(rtwdev, rtwvif, true, false);\n\tif (ret)\n\t\trtw89_debug(rtwdev, RTW89_DBG_TXRX,\n\t\t\t    \"roc send null-0 failed: %d\\n\", ret);\n\n\trtw89_for_each_rtwvif(rtwdev, tmp)\n\t\tif (tmp->sub_entity_idx == rtwvif->sub_entity_idx)\n\t\t\ttmp->offchan = false;\n\n\trtw89_core_handle_sta_pending_tx(rtwdev, rtwvif);\n\tqueue_work(rtwdev->txq_wq, &rtwdev->txq_work);\n\n\tif (hw->conf.flags & IEEE80211_CONF_IDLE)\n\t\tieee80211_queue_delayed_work(hw, &roc->roc_work,\n\t\t\t\t\t     RTW89_ROC_IDLE_TIMEOUT);\n}\n\nvoid rtw89_roc_work(struct work_struct *work)\n{\n\tstruct rtw89_vif *rtwvif = container_of(work, struct rtw89_vif,\n\t\t\t\t\t\troc.roc_work.work);\n\tstruct rtw89_dev *rtwdev = rtwvif->rtwdev;\n\tstruct rtw89_roc *roc = &rtwvif->roc;\n\n\tmutex_lock(&rtwdev->mutex);\n\n\tswitch (roc->state) {\n\tcase RTW89_ROC_IDLE:\n\t\trtw89_enter_ips_by_hwflags(rtwdev);\n\t\tbreak;\n\tcase RTW89_ROC_MGMT:\n\tcase RTW89_ROC_NORMAL:\n\t\trtw89_roc_end(rtwdev, rtwvif);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nstatic enum rtw89_tfc_lv rtw89_get_traffic_level(struct rtw89_dev *rtwdev,\n\t\t\t\t\t\t u32 throughput, u64 cnt)\n{\n\tif (cnt < 100)\n\t\treturn RTW89_TFC_IDLE;\n\tif (throughput > 50)\n\t\treturn RTW89_TFC_HIGH;\n\tif (throughput > 10)\n\t\treturn RTW89_TFC_MID;\n\tif (throughput > 2)\n\t\treturn RTW89_TFC_LOW;\n\treturn RTW89_TFC_ULTRA_LOW;\n}\n\nstatic bool rtw89_traffic_stats_calc(struct rtw89_dev *rtwdev,\n\t\t\t\t     struct rtw89_traffic_stats *stats)\n{\n\tenum rtw89_tfc_lv tx_tfc_lv = stats->tx_tfc_lv;\n\tenum rtw89_tfc_lv rx_tfc_lv = stats->rx_tfc_lv;\n\n\tstats->tx_throughput_raw = (u32)(stats->tx_unicast >> RTW89_TP_SHIFT);\n\tstats->rx_throughput_raw = (u32)(stats->rx_unicast >> RTW89_TP_SHIFT);\n\n\tewma_tp_add(&stats->tx_ewma_tp, stats->tx_throughput_raw);\n\tewma_tp_add(&stats->rx_ewma_tp, stats->rx_throughput_raw);\n\n\tstats->tx_throughput = ewma_tp_read(&stats->tx_ewma_tp);\n\tstats->rx_throughput = ewma_tp_read(&stats->rx_ewma_tp);\n\tstats->tx_tfc_lv = rtw89_get_traffic_level(rtwdev, stats->tx_throughput,\n\t\t\t\t\t\t   stats->tx_cnt);\n\tstats->rx_tfc_lv = rtw89_get_traffic_level(rtwdev, stats->rx_throughput,\n\t\t\t\t\t\t   stats->rx_cnt);\n\tstats->tx_avg_len = stats->tx_cnt ?\n\t\t\t    DIV_ROUND_DOWN_ULL(stats->tx_unicast, stats->tx_cnt) : 0;\n\tstats->rx_avg_len = stats->rx_cnt ?\n\t\t\t    DIV_ROUND_DOWN_ULL(stats->rx_unicast, stats->rx_cnt) : 0;\n\n\tstats->tx_unicast = 0;\n\tstats->rx_unicast = 0;\n\tstats->tx_cnt = 0;\n\tstats->rx_cnt = 0;\n\tstats->rx_tf_periodic = stats->rx_tf_acc;\n\tstats->rx_tf_acc = 0;\n\n\tif (tx_tfc_lv != stats->tx_tfc_lv || rx_tfc_lv != stats->rx_tfc_lv)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool rtw89_traffic_stats_track(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_vif *rtwvif;\n\tbool tfc_changed;\n\n\ttfc_changed = rtw89_traffic_stats_calc(rtwdev, &rtwdev->stats);\n\trtw89_for_each_rtwvif(rtwdev, rtwvif) {\n\t\trtw89_traffic_stats_calc(rtwdev, &rtwvif->stats);\n\t\trtw89_fw_h2c_tp_offload(rtwdev, rtwvif);\n\t}\n\n\treturn tfc_changed;\n}\n\nstatic void rtw89_vif_enter_lps(struct rtw89_dev *rtwdev, struct rtw89_vif *rtwvif)\n{\n\tif ((rtwvif->wifi_role != RTW89_WIFI_ROLE_STATION &&\n\t     rtwvif->wifi_role != RTW89_WIFI_ROLE_P2P_CLIENT) ||\n\t    rtwvif->tdls_peer)\n\t\treturn;\n\n\tif (rtwvif->offchan)\n\t\treturn;\n\n\tif (rtwvif->stats.tx_tfc_lv == RTW89_TFC_IDLE &&\n\t    rtwvif->stats.rx_tfc_lv == RTW89_TFC_IDLE)\n\t\trtw89_enter_lps(rtwdev, rtwvif, true);\n}\n\nstatic void rtw89_enter_lps_track(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_vif *rtwvif;\n\n\trtw89_for_each_rtwvif(rtwdev, rtwvif)\n\t\trtw89_vif_enter_lps(rtwdev, rtwvif);\n}\n\nvoid rtw89_traffic_stats_init(struct rtw89_dev *rtwdev,\n\t\t\t      struct rtw89_traffic_stats *stats)\n{\n\tstats->tx_unicast = 0;\n\tstats->rx_unicast = 0;\n\tstats->tx_cnt = 0;\n\tstats->rx_cnt = 0;\n\tewma_tp_init(&stats->tx_ewma_tp);\n\tewma_tp_init(&stats->rx_ewma_tp);\n}\n\nstatic void rtw89_track_work(struct work_struct *work)\n{\n\tstruct rtw89_dev *rtwdev = container_of(work, struct rtw89_dev,\n\t\t\t\t\t\ttrack_work.work);\n\tbool tfc_changed;\n\n\tif (test_bit(RTW89_FLAG_FORBIDDEN_TRACK_WROK, rtwdev->flags))\n\t\treturn;\n\n\tmutex_lock(&rtwdev->mutex);\n\n\tif (!test_bit(RTW89_FLAG_RUNNING, rtwdev->flags))\n\t\tgoto out;\n\n\tieee80211_queue_delayed_work(rtwdev->hw, &rtwdev->track_work,\n\t\t\t\t     RTW89_TRACK_WORK_PERIOD);\n\n\ttfc_changed = rtw89_traffic_stats_track(rtwdev);\n\tif (rtwdev->scanning)\n\t\tgoto out;\n\n\trtw89_leave_lps(rtwdev);\n\n\tif (tfc_changed) {\n\t\trtw89_hci_recalc_int_mit(rtwdev);\n\t\trtw89_btc_ntfy_wl_sta(rtwdev);\n\t}\n\trtw89_mac_bf_monitor_track(rtwdev);\n\trtw89_phy_stat_track(rtwdev);\n\trtw89_phy_env_monitor_track(rtwdev);\n\trtw89_phy_dig(rtwdev);\n\trtw89_chip_rfk_track(rtwdev);\n\trtw89_phy_ra_update(rtwdev);\n\trtw89_phy_cfo_track(rtwdev);\n\trtw89_phy_tx_path_div_track(rtwdev);\n\trtw89_phy_antdiv_track(rtwdev);\n\trtw89_phy_ul_tb_ctrl_track(rtwdev);\n\trtw89_tas_track(rtwdev);\n\n\tif (rtwdev->lps_enabled && !rtwdev->btc.lps)\n\t\trtw89_enter_lps_track(rtwdev);\n\nout:\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nu8 rtw89_core_acquire_bit_map(unsigned long *addr, unsigned long size)\n{\n\tunsigned long bit;\n\n\tbit = find_first_zero_bit(addr, size);\n\tif (bit < size)\n\t\tset_bit(bit, addr);\n\n\treturn bit;\n}\n\nvoid rtw89_core_release_bit_map(unsigned long *addr, u8 bit)\n{\n\tclear_bit(bit, addr);\n}\n\nvoid rtw89_core_release_all_bits_map(unsigned long *addr, unsigned int nbits)\n{\n\tbitmap_zero(addr, nbits);\n}\n\nint rtw89_core_acquire_sta_ba_entry(struct rtw89_dev *rtwdev,\n\t\t\t\t    struct rtw89_sta *rtwsta, u8 tid, u8 *cam_idx)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tstruct rtw89_cam_info *cam_info = &rtwdev->cam_info;\n\tstruct rtw89_ba_cam_entry *entry = NULL, *tmp;\n\tu8 idx;\n\tint i;\n\n\tlockdep_assert_held(&rtwdev->mutex);\n\n\tidx = rtw89_core_acquire_bit_map(cam_info->ba_cam_map, chip->bacam_num);\n\tif (idx == chip->bacam_num) {\n\t\t \n\t\tif (tid != 0 && tid != 5)\n\t\t\treturn -ENOSPC;\n\n\t\tfor_each_set_bit(i, cam_info->ba_cam_map, chip->bacam_num) {\n\t\t\ttmp = &cam_info->ba_cam_entry[i];\n\t\t\tif (tmp->tid == 0 || tmp->tid == 5)\n\t\t\t\tcontinue;\n\n\t\t\tidx = i;\n\t\t\tentry = tmp;\n\t\t\tlist_del(&entry->list);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!entry)\n\t\t\treturn -ENOSPC;\n\t} else {\n\t\tentry = &cam_info->ba_cam_entry[idx];\n\t}\n\n\tentry->tid = tid;\n\tlist_add_tail(&entry->list, &rtwsta->ba_cam_list);\n\n\t*cam_idx = idx;\n\n\treturn 0;\n}\n\nint rtw89_core_release_sta_ba_entry(struct rtw89_dev *rtwdev,\n\t\t\t\t    struct rtw89_sta *rtwsta, u8 tid, u8 *cam_idx)\n{\n\tstruct rtw89_cam_info *cam_info = &rtwdev->cam_info;\n\tstruct rtw89_ba_cam_entry *entry = NULL, *tmp;\n\tu8 idx;\n\n\tlockdep_assert_held(&rtwdev->mutex);\n\n\tlist_for_each_entry_safe(entry, tmp, &rtwsta->ba_cam_list, list) {\n\t\tif (entry->tid != tid)\n\t\t\tcontinue;\n\n\t\tidx = entry - cam_info->ba_cam_entry;\n\t\tlist_del(&entry->list);\n\n\t\trtw89_core_release_bit_map(cam_info->ba_cam_map, idx);\n\t\t*cam_idx = idx;\n\t\treturn 0;\n\t}\n\n\treturn -ENOENT;\n}\n\n#define RTW89_TYPE_MAPPING(_type)\t\\\n\tcase NL80211_IFTYPE_ ## _type:\t\\\n\t\trtwvif->wifi_role = RTW89_WIFI_ROLE_ ## _type;\t\\\n\t\tbreak\nvoid rtw89_vif_type_mapping(struct ieee80211_vif *vif, bool assoc)\n{\n\tstruct rtw89_vif *rtwvif = (struct rtw89_vif *)vif->drv_priv;\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (vif->p2p)\n\t\t\trtwvif->wifi_role = RTW89_WIFI_ROLE_P2P_CLIENT;\n\t\telse\n\t\t\trtwvif->wifi_role = RTW89_WIFI_ROLE_STATION;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\t\tif (vif->p2p)\n\t\t\trtwvif->wifi_role = RTW89_WIFI_ROLE_P2P_GO;\n\t\telse\n\t\t\trtwvif->wifi_role = RTW89_WIFI_ROLE_AP;\n\t\tbreak;\n\tRTW89_TYPE_MAPPING(ADHOC);\n\tRTW89_TYPE_MAPPING(MONITOR);\n\tRTW89_TYPE_MAPPING(MESH_POINT);\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\trtwvif->net_type = RTW89_NET_TYPE_AP_MODE;\n\t\trtwvif->self_role = RTW89_SELF_ROLE_AP;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\trtwvif->net_type = RTW89_NET_TYPE_AD_HOC;\n\t\trtwvif->self_role = RTW89_SELF_ROLE_CLIENT;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (assoc) {\n\t\t\trtwvif->net_type = RTW89_NET_TYPE_INFRA;\n\t\t\trtwvif->trigger = vif->bss_conf.he_support;\n\t\t} else {\n\t\t\trtwvif->net_type = RTW89_NET_TYPE_NO_LINK;\n\t\t\trtwvif->trigger = false;\n\t\t}\n\t\trtwvif->self_role = RTW89_SELF_ROLE_CLIENT;\n\t\trtwvif->addr_cam.sec_ent_mode = RTW89_ADDR_CAM_SEC_NORMAL;\n\t\tbreak;\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n}\n\nint rtw89_core_sta_add(struct rtw89_dev *rtwdev,\n\t\t       struct ieee80211_vif *vif,\n\t\t       struct ieee80211_sta *sta)\n{\n\tstruct rtw89_vif *rtwvif = (struct rtw89_vif *)vif->drv_priv;\n\tstruct rtw89_sta *rtwsta = (struct rtw89_sta *)sta->drv_priv;\n\tstruct rtw89_hal *hal = &rtwdev->hal;\n\tu8 ant_num = hal->ant_diversity ? 2 : rtwdev->chip->rf_path_num;\n\tint i;\n\tint ret;\n\n\trtwsta->rtwdev = rtwdev;\n\trtwsta->rtwvif = rtwvif;\n\trtwsta->prev_rssi = 0;\n\tINIT_LIST_HEAD(&rtwsta->ba_cam_list);\n\tskb_queue_head_init(&rtwsta->roc_queue);\n\n\tfor (i = 0; i < ARRAY_SIZE(sta->txq); i++)\n\t\trtw89_core_txq_init(rtwdev, sta->txq[i]);\n\n\tewma_rssi_init(&rtwsta->avg_rssi);\n\tewma_snr_init(&rtwsta->avg_snr);\n\tfor (i = 0; i < ant_num; i++) {\n\t\tewma_rssi_init(&rtwsta->rssi[i]);\n\t\tewma_evm_init(&rtwsta->evm_min[i]);\n\t\tewma_evm_init(&rtwsta->evm_max[i]);\n\t}\n\n\tif (vif->type == NL80211_IFTYPE_STATION && !sta->tdls) {\n\t\t \n\t\trtwsta->mac_id = rtwvif->mac_id;\n\t\t \n\t\trtw89_reg_6ghz_power_recalc(rtwdev, rtwvif, true);\n\t\trtw89_btc_ntfy_role_info(rtwdev, rtwvif, rtwsta,\n\t\t\t\t\t BTC_ROLE_MSTS_STA_CONN_START);\n\t\trtw89_chip_rfk_channel(rtwdev);\n\t} else if (vif->type == NL80211_IFTYPE_AP || sta->tdls) {\n\t\trtwsta->mac_id = rtw89_core_acquire_bit_map(rtwdev->mac_id_map,\n\t\t\t\t\t\t\t    RTW89_MAX_MAC_ID_NUM);\n\t\tif (rtwsta->mac_id == RTW89_MAX_MAC_ID_NUM)\n\t\t\treturn -ENOSPC;\n\n\t\tret = rtw89_mac_set_macid_pause(rtwdev, rtwsta->mac_id, false);\n\t\tif (ret) {\n\t\t\trtw89_core_release_bit_map(rtwdev->mac_id_map, rtwsta->mac_id);\n\t\t\trtw89_warn(rtwdev, \"failed to send h2c macid pause\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = rtw89_fw_h2c_role_maintain(rtwdev, rtwvif, rtwsta,\n\t\t\t\t\t\t RTW89_ROLE_CREATE);\n\t\tif (ret) {\n\t\t\trtw89_core_release_bit_map(rtwdev->mac_id_map, rtwsta->mac_id);\n\t\t\trtw89_warn(rtwdev, \"failed to send h2c role info\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint rtw89_core_sta_disassoc(struct rtw89_dev *rtwdev,\n\t\t\t    struct ieee80211_vif *vif,\n\t\t\t    struct ieee80211_sta *sta)\n{\n\tstruct rtw89_vif *rtwvif = (struct rtw89_vif *)vif->drv_priv;\n\tstruct rtw89_sta *rtwsta = (struct rtw89_sta *)sta->drv_priv;\n\n\tif (vif->type == NL80211_IFTYPE_STATION)\n\t\trtw89_fw_h2c_set_bcn_fltr_cfg(rtwdev, vif, false);\n\n\trtwdev->total_sta_assoc--;\n\tif (sta->tdls)\n\t\trtwvif->tdls_peer--;\n\trtwsta->disassoc = true;\n\n\treturn 0;\n}\n\nint rtw89_core_sta_disconnect(struct rtw89_dev *rtwdev,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      struct ieee80211_sta *sta)\n{\n\tstruct rtw89_vif *rtwvif = (struct rtw89_vif *)vif->drv_priv;\n\tstruct rtw89_sta *rtwsta = (struct rtw89_sta *)sta->drv_priv;\n\tint ret;\n\n\trtw89_mac_bf_monitor_calc(rtwdev, sta, true);\n\trtw89_mac_bf_disassoc(rtwdev, vif, sta);\n\trtw89_core_free_sta_pending_ba(rtwdev, sta);\n\trtw89_core_free_sta_pending_forbid_ba(rtwdev, sta);\n\trtw89_core_free_sta_pending_roc_tx(rtwdev, sta);\n\n\tif (vif->type == NL80211_IFTYPE_AP || sta->tdls)\n\t\trtw89_cam_deinit_addr_cam(rtwdev, &rtwsta->addr_cam);\n\tif (sta->tdls)\n\t\trtw89_cam_deinit_bssid_cam(rtwdev, &rtwsta->bssid_cam);\n\n\tif (vif->type == NL80211_IFTYPE_STATION && !sta->tdls) {\n\t\trtw89_vif_type_mapping(vif, false);\n\t\trtw89_fw_release_general_pkt_list_vif(rtwdev, rtwvif, true);\n\t}\n\n\tret = rtw89_fw_h2c_assoc_cmac_tbl(rtwdev, vif, sta);\n\tif (ret) {\n\t\trtw89_warn(rtwdev, \"failed to send h2c cmac table\\n\");\n\t\treturn ret;\n\t}\n\n\tret = rtw89_fw_h2c_join_info(rtwdev, rtwvif, rtwsta, true);\n\tif (ret) {\n\t\trtw89_warn(rtwdev, \"failed to send h2c join info\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = rtw89_fw_h2c_cam(rtwdev, rtwvif, rtwsta, NULL);\n\tif (ret) {\n\t\trtw89_warn(rtwdev, \"failed to send h2c cam\\n\");\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nint rtw89_core_sta_assoc(struct rtw89_dev *rtwdev,\n\t\t\t struct ieee80211_vif *vif,\n\t\t\t struct ieee80211_sta *sta)\n{\n\tstruct rtw89_vif *rtwvif = (struct rtw89_vif *)vif->drv_priv;\n\tstruct rtw89_sta *rtwsta = (struct rtw89_sta *)sta->drv_priv;\n\tstruct rtw89_bssid_cam_entry *bssid_cam = rtw89_get_bssid_cam_of(rtwvif, rtwsta);\n\tconst struct rtw89_chan *chan = rtw89_chan_get(rtwdev,\n\t\t\t\t\t\t       rtwvif->sub_entity_idx);\n\tint ret;\n\n\tif (vif->type == NL80211_IFTYPE_AP || sta->tdls) {\n\t\tif (sta->tdls) {\n\t\t\tret = rtw89_cam_init_bssid_cam(rtwdev, rtwvif, bssid_cam, sta->addr);\n\t\t\tif (ret) {\n\t\t\t\trtw89_warn(rtwdev, \"failed to send h2c init bssid cam for TDLS\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tret = rtw89_cam_init_addr_cam(rtwdev, &rtwsta->addr_cam, bssid_cam);\n\t\tif (ret) {\n\t\t\trtw89_warn(rtwdev, \"failed to send h2c init addr cam\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = rtw89_fw_h2c_assoc_cmac_tbl(rtwdev, vif, sta);\n\tif (ret) {\n\t\trtw89_warn(rtwdev, \"failed to send h2c cmac table\\n\");\n\t\treturn ret;\n\t}\n\n\tret = rtw89_fw_h2c_join_info(rtwdev, rtwvif, rtwsta, false);\n\tif (ret) {\n\t\trtw89_warn(rtwdev, \"failed to send h2c join info\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tret = rtw89_fw_h2c_cam(rtwdev, rtwvif, rtwsta, NULL);\n\tif (ret) {\n\t\trtw89_warn(rtwdev, \"failed to send h2c cam\\n\");\n\t\treturn ret;\n\t}\n\n\trtwdev->total_sta_assoc++;\n\tif (sta->tdls)\n\t\trtwvif->tdls_peer++;\n\trtw89_phy_ra_assoc(rtwdev, sta);\n\trtw89_mac_bf_assoc(rtwdev, vif, sta);\n\trtw89_mac_bf_monitor_calc(rtwdev, sta, false);\n\n\tif (vif->type == NL80211_IFTYPE_STATION && !sta->tdls) {\n\t\tstruct ieee80211_bss_conf *bss_conf = &vif->bss_conf;\n\n\t\tif (bss_conf->he_support &&\n\t\t    !(bss_conf->he_oper.params & IEEE80211_HE_OPERATION_ER_SU_DISABLE))\n\t\t\trtwsta->er_cap = true;\n\n\t\trtw89_btc_ntfy_role_info(rtwdev, rtwvif, rtwsta,\n\t\t\t\t\t BTC_ROLE_MSTS_STA_CONN_END);\n\t\trtw89_core_get_no_ul_ofdma_htc(rtwdev, &rtwsta->htc_template, chan);\n\t\trtw89_phy_ul_tb_assoc(rtwdev, rtwvif);\n\n\t\tret = rtw89_fw_h2c_general_pkt(rtwdev, rtwvif, rtwsta->mac_id);\n\t\tif (ret) {\n\t\t\trtw89_warn(rtwdev, \"failed to send h2c general packet\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint rtw89_core_sta_remove(struct rtw89_dev *rtwdev,\n\t\t\t  struct ieee80211_vif *vif,\n\t\t\t  struct ieee80211_sta *sta)\n{\n\tstruct rtw89_vif *rtwvif = (struct rtw89_vif *)vif->drv_priv;\n\tstruct rtw89_sta *rtwsta = (struct rtw89_sta *)sta->drv_priv;\n\tint ret;\n\n\tif (vif->type == NL80211_IFTYPE_STATION && !sta->tdls) {\n\t\trtw89_reg_6ghz_power_recalc(rtwdev, rtwvif, false);\n\t\trtw89_btc_ntfy_role_info(rtwdev, rtwvif, rtwsta,\n\t\t\t\t\t BTC_ROLE_MSTS_STA_DIS_CONN);\n\t} else if (vif->type == NL80211_IFTYPE_AP || sta->tdls) {\n\t\trtw89_core_release_bit_map(rtwdev->mac_id_map, rtwsta->mac_id);\n\n\t\tret = rtw89_fw_h2c_role_maintain(rtwdev, rtwvif, rtwsta,\n\t\t\t\t\t\t RTW89_ROLE_REMOVE);\n\t\tif (ret) {\n\t\t\trtw89_warn(rtwdev, \"failed to send h2c role info\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void _rtw89_core_set_tid_config(struct rtw89_dev *rtwdev,\n\t\t\t\t       struct ieee80211_sta *sta,\n\t\t\t\t       struct cfg80211_tid_cfg *tid_conf)\n{\n\tstruct ieee80211_txq *txq;\n\tstruct rtw89_txq *rtwtxq;\n\tu32 mask = tid_conf->mask;\n\tu8 tids = tid_conf->tids;\n\tint tids_nbit = BITS_PER_BYTE;\n\tint i;\n\n\tfor (i = 0; i < tids_nbit; i++, tids >>= 1) {\n\t\tif (!tids)\n\t\t\tbreak;\n\n\t\tif (!(tids & BIT(0)))\n\t\t\tcontinue;\n\n\t\ttxq = sta->txq[i];\n\t\trtwtxq = (struct rtw89_txq *)txq->drv_priv;\n\n\t\tif (mask & BIT(NL80211_TID_CONFIG_ATTR_AMPDU_CTRL)) {\n\t\t\tif (tid_conf->ampdu == NL80211_TID_CONFIG_ENABLE) {\n\t\t\t\tclear_bit(RTW89_TXQ_F_FORBID_BA, &rtwtxq->flags);\n\t\t\t} else {\n\t\t\t\tif (test_bit(RTW89_TXQ_F_AMPDU, &rtwtxq->flags))\n\t\t\t\t\tieee80211_stop_tx_ba_session(sta, txq->tid);\n\t\t\t\tspin_lock_bh(&rtwdev->ba_lock);\n\t\t\t\tlist_del_init(&rtwtxq->list);\n\t\t\t\tset_bit(RTW89_TXQ_F_FORBID_BA, &rtwtxq->flags);\n\t\t\t\tspin_unlock_bh(&rtwdev->ba_lock);\n\t\t\t}\n\t\t}\n\n\t\tif (mask & BIT(NL80211_TID_CONFIG_ATTR_AMSDU_CTRL) && tids == 0xff) {\n\t\t\tif (tid_conf->amsdu == NL80211_TID_CONFIG_ENABLE)\n\t\t\t\tsta->max_amsdu_subframes = 0;\n\t\t\telse\n\t\t\t\tsta->max_amsdu_subframes = 1;\n\t\t}\n\t}\n}\n\nvoid rtw89_core_set_tid_config(struct rtw89_dev *rtwdev,\n\t\t\t       struct ieee80211_sta *sta,\n\t\t\t       struct cfg80211_tid_config *tid_config)\n{\n\tint i;\n\n\tfor (i = 0; i < tid_config->n_tid_conf; i++)\n\t\t_rtw89_core_set_tid_config(rtwdev, sta,\n\t\t\t\t\t   &tid_config->tid_conf[i]);\n}\n\nstatic void rtw89_init_ht_cap(struct rtw89_dev *rtwdev,\n\t\t\t      struct ieee80211_sta_ht_cap *ht_cap)\n{\n\tstatic const __le16 highest[RF_PATH_MAX] = {\n\t\tcpu_to_le16(150), cpu_to_le16(300), cpu_to_le16(450), cpu_to_le16(600),\n\t};\n\tstruct rtw89_hal *hal = &rtwdev->hal;\n\tu8 nss = hal->rx_nss;\n\tint i;\n\n\tht_cap->ht_supported = true;\n\tht_cap->cap = 0;\n\tht_cap->cap |= IEEE80211_HT_CAP_SGI_20 |\n\t\t       IEEE80211_HT_CAP_MAX_AMSDU |\n\t\t       IEEE80211_HT_CAP_TX_STBC |\n\t\t       (1 << IEEE80211_HT_CAP_RX_STBC_SHIFT);\n\tht_cap->cap |= IEEE80211_HT_CAP_LDPC_CODING;\n\tht_cap->cap |= IEEE80211_HT_CAP_SUP_WIDTH_20_40 |\n\t\t       IEEE80211_HT_CAP_DSSSCCK40 |\n\t\t       IEEE80211_HT_CAP_SGI_40;\n\tht_cap->ampdu_factor = IEEE80211_HT_MAX_AMPDU_64K;\n\tht_cap->ampdu_density = IEEE80211_HT_MPDU_DENSITY_NONE;\n\tht_cap->mcs.tx_params = IEEE80211_HT_MCS_TX_DEFINED;\n\tfor (i = 0; i < nss; i++)\n\t\tht_cap->mcs.rx_mask[i] = 0xFF;\n\tht_cap->mcs.rx_mask[4] = 0x01;\n\tht_cap->mcs.rx_highest = highest[nss - 1];\n}\n\nstatic void rtw89_init_vht_cap(struct rtw89_dev *rtwdev,\n\t\t\t       struct ieee80211_sta_vht_cap *vht_cap)\n{\n\tstatic const __le16 highest_bw80[RF_PATH_MAX] = {\n\t\tcpu_to_le16(433), cpu_to_le16(867), cpu_to_le16(1300), cpu_to_le16(1733),\n\t};\n\tstatic const __le16 highest_bw160[RF_PATH_MAX] = {\n\t\tcpu_to_le16(867), cpu_to_le16(1733), cpu_to_le16(2600), cpu_to_le16(3467),\n\t};\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tconst __le16 *highest = chip->support_bw160 ? highest_bw160 : highest_bw80;\n\tstruct rtw89_hal *hal = &rtwdev->hal;\n\tu16 tx_mcs_map = 0, rx_mcs_map = 0;\n\tu8 sts_cap = 3;\n\tint i;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (i < hal->tx_nss)\n\t\t\ttx_mcs_map |= IEEE80211_VHT_MCS_SUPPORT_0_9 << (i * 2);\n\t\telse\n\t\t\ttx_mcs_map |= IEEE80211_VHT_MCS_NOT_SUPPORTED << (i * 2);\n\t\tif (i < hal->rx_nss)\n\t\t\trx_mcs_map |= IEEE80211_VHT_MCS_SUPPORT_0_9 << (i * 2);\n\t\telse\n\t\t\trx_mcs_map |= IEEE80211_VHT_MCS_NOT_SUPPORTED << (i * 2);\n\t}\n\n\tvht_cap->vht_supported = true;\n\tvht_cap->cap = IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_11454 |\n\t\t       IEEE80211_VHT_CAP_SHORT_GI_80 |\n\t\t       IEEE80211_VHT_CAP_RXSTBC_1 |\n\t\t       IEEE80211_VHT_CAP_HTC_VHT |\n\t\t       IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK |\n\t\t       0;\n\tvht_cap->cap |= IEEE80211_VHT_CAP_TXSTBC;\n\tvht_cap->cap |= IEEE80211_VHT_CAP_RXLDPC;\n\tvht_cap->cap |= IEEE80211_VHT_CAP_MU_BEAMFORMEE_CAPABLE |\n\t\t\tIEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE;\n\tvht_cap->cap |= sts_cap << IEEE80211_VHT_CAP_BEAMFORMEE_STS_SHIFT;\n\tif (chip->support_bw160)\n\t\tvht_cap->cap |= IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ |\n\t\t\t\tIEEE80211_VHT_CAP_SHORT_GI_160;\n\tvht_cap->vht_mcs.rx_mcs_map = cpu_to_le16(rx_mcs_map);\n\tvht_cap->vht_mcs.tx_mcs_map = cpu_to_le16(tx_mcs_map);\n\tvht_cap->vht_mcs.rx_highest = highest[hal->rx_nss - 1];\n\tvht_cap->vht_mcs.tx_highest = highest[hal->tx_nss - 1];\n}\n\n#define RTW89_SBAND_IFTYPES_NR 2\n\nstatic void rtw89_init_he_cap(struct rtw89_dev *rtwdev,\n\t\t\t      enum nl80211_band band,\n\t\t\t      struct ieee80211_supported_band *sband)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tstruct rtw89_hal *hal = &rtwdev->hal;\n\tstruct ieee80211_sband_iftype_data *iftype_data;\n\tbool no_ng16 = (chip->chip_id == RTL8852A && hal->cv == CHIP_CBV) ||\n\t\t       (chip->chip_id == RTL8852B && hal->cv == CHIP_CAV);\n\tu16 mcs_map = 0;\n\tint i;\n\tint nss = hal->rx_nss;\n\tint idx = 0;\n\n\tiftype_data = kcalloc(RTW89_SBAND_IFTYPES_NR, sizeof(*iftype_data), GFP_KERNEL);\n\tif (!iftype_data)\n\t\treturn;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tif (i < nss)\n\t\t\tmcs_map |= IEEE80211_HE_MCS_SUPPORT_0_11 << (i * 2);\n\t\telse\n\t\t\tmcs_map |= IEEE80211_HE_MCS_NOT_SUPPORTED << (i * 2);\n\t}\n\n\tfor (i = 0; i < NUM_NL80211_IFTYPES; i++) {\n\t\tstruct ieee80211_sta_he_cap *he_cap;\n\t\tu8 *mac_cap_info;\n\t\tu8 *phy_cap_info;\n\n\t\tswitch (i) {\n\t\tcase NL80211_IFTYPE_STATION:\n\t\tcase NL80211_IFTYPE_AP:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (idx >= RTW89_SBAND_IFTYPES_NR) {\n\t\t\trtw89_warn(rtwdev, \"run out of iftype_data\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tiftype_data[idx].types_mask = BIT(i);\n\t\the_cap = &iftype_data[idx].he_cap;\n\t\tmac_cap_info = he_cap->he_cap_elem.mac_cap_info;\n\t\tphy_cap_info = he_cap->he_cap_elem.phy_cap_info;\n\n\t\the_cap->has_he = true;\n\t\tmac_cap_info[0] = IEEE80211_HE_MAC_CAP0_HTC_HE;\n\t\tif (i == NL80211_IFTYPE_STATION)\n\t\t\tmac_cap_info[1] = IEEE80211_HE_MAC_CAP1_TF_MAC_PAD_DUR_16US;\n\t\tmac_cap_info[2] = IEEE80211_HE_MAC_CAP2_ALL_ACK |\n\t\t\t\t  IEEE80211_HE_MAC_CAP2_BSR;\n\t\tmac_cap_info[3] = IEEE80211_HE_MAC_CAP3_MAX_AMPDU_LEN_EXP_EXT_2;\n\t\tif (i == NL80211_IFTYPE_AP)\n\t\t\tmac_cap_info[3] |= IEEE80211_HE_MAC_CAP3_OMI_CONTROL;\n\t\tmac_cap_info[4] = IEEE80211_HE_MAC_CAP4_OPS |\n\t\t\t\t  IEEE80211_HE_MAC_CAP4_AMSDU_IN_AMPDU;\n\t\tif (i == NL80211_IFTYPE_STATION)\n\t\t\tmac_cap_info[5] = IEEE80211_HE_MAC_CAP5_HT_VHT_TRIG_FRAME_RX;\n\t\tif (band == NL80211_BAND_2GHZ) {\n\t\t\tphy_cap_info[0] =\n\t\t\t\tIEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_IN_2G;\n\t\t} else {\n\t\t\tphy_cap_info[0] =\n\t\t\t\tIEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_40MHZ_80MHZ_IN_5G;\n\t\t\tif (chip->support_bw160)\n\t\t\t\tphy_cap_info[0] |= IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_160MHZ_IN_5G;\n\t\t}\n\t\tphy_cap_info[1] = IEEE80211_HE_PHY_CAP1_DEVICE_CLASS_A |\n\t\t\t\t  IEEE80211_HE_PHY_CAP1_LDPC_CODING_IN_PAYLOAD |\n\t\t\t\t  IEEE80211_HE_PHY_CAP1_HE_LTF_AND_GI_FOR_HE_PPDUS_0_8US;\n\t\tphy_cap_info[2] = IEEE80211_HE_PHY_CAP2_NDP_4x_LTF_AND_3_2US |\n\t\t\t\t  IEEE80211_HE_PHY_CAP2_STBC_TX_UNDER_80MHZ |\n\t\t\t\t  IEEE80211_HE_PHY_CAP2_STBC_RX_UNDER_80MHZ |\n\t\t\t\t  IEEE80211_HE_PHY_CAP2_DOPPLER_TX;\n\t\tphy_cap_info[3] = IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_RX_16_QAM;\n\t\tif (i == NL80211_IFTYPE_STATION)\n\t\t\tphy_cap_info[3] |= IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_TX_16_QAM |\n\t\t\t\t\t   IEEE80211_HE_PHY_CAP3_DCM_MAX_TX_NSS_2;\n\t\tif (i == NL80211_IFTYPE_AP)\n\t\t\tphy_cap_info[3] |= IEEE80211_HE_PHY_CAP3_RX_PARTIAL_BW_SU_IN_20MHZ_MU;\n\t\tphy_cap_info[4] = IEEE80211_HE_PHY_CAP4_SU_BEAMFORMEE |\n\t\t\t\t  IEEE80211_HE_PHY_CAP4_BEAMFORMEE_MAX_STS_UNDER_80MHZ_4;\n\t\tif (chip->support_bw160)\n\t\t\tphy_cap_info[4] |= IEEE80211_HE_PHY_CAP4_BEAMFORMEE_MAX_STS_ABOVE_80MHZ_4;\n\t\tphy_cap_info[5] = no_ng16 ? 0 :\n\t\t\t\t  IEEE80211_HE_PHY_CAP5_NG16_SU_FEEDBACK |\n\t\t\t\t  IEEE80211_HE_PHY_CAP5_NG16_MU_FEEDBACK;\n\t\tphy_cap_info[6] = IEEE80211_HE_PHY_CAP6_CODEBOOK_SIZE_42_SU |\n\t\t\t\t  IEEE80211_HE_PHY_CAP6_CODEBOOK_SIZE_75_MU |\n\t\t\t\t  IEEE80211_HE_PHY_CAP6_TRIG_SU_BEAMFORMING_FB |\n\t\t\t\t  IEEE80211_HE_PHY_CAP6_PARTIAL_BW_EXT_RANGE;\n\t\tphy_cap_info[7] = IEEE80211_HE_PHY_CAP7_POWER_BOOST_FACTOR_SUPP |\n\t\t\t\t  IEEE80211_HE_PHY_CAP7_HE_SU_MU_PPDU_4XLTF_AND_08_US_GI |\n\t\t\t\t  IEEE80211_HE_PHY_CAP7_MAX_NC_1;\n\t\tphy_cap_info[8] = IEEE80211_HE_PHY_CAP8_HE_ER_SU_PPDU_4XLTF_AND_08_US_GI |\n\t\t\t\t  IEEE80211_HE_PHY_CAP8_HE_ER_SU_1XLTF_AND_08_US_GI |\n\t\t\t\t  IEEE80211_HE_PHY_CAP8_DCM_MAX_RU_996;\n\t\tif (chip->support_bw160)\n\t\t\tphy_cap_info[8] |= IEEE80211_HE_PHY_CAP8_20MHZ_IN_160MHZ_HE_PPDU |\n\t\t\t\t\t   IEEE80211_HE_PHY_CAP8_80MHZ_IN_160MHZ_HE_PPDU;\n\t\tphy_cap_info[9] = IEEE80211_HE_PHY_CAP9_LONGER_THAN_16_SIGB_OFDM_SYM |\n\t\t\t\t  IEEE80211_HE_PHY_CAP9_RX_1024_QAM_LESS_THAN_242_TONE_RU |\n\t\t\t\t  IEEE80211_HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_WITH_COMP_SIGB |\n\t\t\t\t  IEEE80211_HE_PHY_CAP9_RX_FULL_BW_SU_USING_MU_WITH_NON_COMP_SIGB |\n\t\t\t\t  u8_encode_bits(IEEE80211_HE_PHY_CAP9_NOMINAL_PKT_PADDING_16US,\n\t\t\t\t\t\t IEEE80211_HE_PHY_CAP9_NOMINAL_PKT_PADDING_MASK);\n\t\tif (i == NL80211_IFTYPE_STATION)\n\t\t\tphy_cap_info[9] |= IEEE80211_HE_PHY_CAP9_TX_1024_QAM_LESS_THAN_242_TONE_RU;\n\t\the_cap->he_mcs_nss_supp.rx_mcs_80 = cpu_to_le16(mcs_map);\n\t\the_cap->he_mcs_nss_supp.tx_mcs_80 = cpu_to_le16(mcs_map);\n\t\tif (chip->support_bw160) {\n\t\t\the_cap->he_mcs_nss_supp.rx_mcs_160 = cpu_to_le16(mcs_map);\n\t\t\the_cap->he_mcs_nss_supp.tx_mcs_160 = cpu_to_le16(mcs_map);\n\t\t}\n\n\t\tif (band == NL80211_BAND_6GHZ) {\n\t\t\t__le16 capa;\n\n\t\t\tcapa = le16_encode_bits(IEEE80211_HT_MPDU_DENSITY_NONE,\n\t\t\t\t\t\tIEEE80211_HE_6GHZ_CAP_MIN_MPDU_START) |\n\t\t\t       le16_encode_bits(IEEE80211_VHT_MAX_AMPDU_1024K,\n\t\t\t\t\t\tIEEE80211_HE_6GHZ_CAP_MAX_AMPDU_LEN_EXP) |\n\t\t\t       le16_encode_bits(IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_11454,\n\t\t\t\t\t\tIEEE80211_HE_6GHZ_CAP_MAX_MPDU_LEN);\n\t\t\tiftype_data[idx].he_6ghz_capa.capa = capa;\n\t\t}\n\n\t\tidx++;\n\t}\n\n\tsband->iftype_data = iftype_data;\n\tsband->n_iftype_data = idx;\n}\n\nstatic int rtw89_core_set_supported_band(struct rtw89_dev *rtwdev)\n{\n\tstruct ieee80211_hw *hw = rtwdev->hw;\n\tstruct ieee80211_supported_band *sband_2ghz = NULL, *sband_5ghz = NULL;\n\tstruct ieee80211_supported_band *sband_6ghz = NULL;\n\tu32 size = sizeof(struct ieee80211_supported_band);\n\tu8 support_bands = rtwdev->chip->support_bands;\n\n\tif (support_bands & BIT(NL80211_BAND_2GHZ)) {\n\t\tsband_2ghz = kmemdup(&rtw89_sband_2ghz, size, GFP_KERNEL);\n\t\tif (!sband_2ghz)\n\t\t\tgoto err;\n\t\trtw89_init_ht_cap(rtwdev, &sband_2ghz->ht_cap);\n\t\trtw89_init_he_cap(rtwdev, NL80211_BAND_2GHZ, sband_2ghz);\n\t\thw->wiphy->bands[NL80211_BAND_2GHZ] = sband_2ghz;\n\t}\n\n\tif (support_bands & BIT(NL80211_BAND_5GHZ)) {\n\t\tsband_5ghz = kmemdup(&rtw89_sband_5ghz, size, GFP_KERNEL);\n\t\tif (!sband_5ghz)\n\t\t\tgoto err;\n\t\trtw89_init_ht_cap(rtwdev, &sband_5ghz->ht_cap);\n\t\trtw89_init_vht_cap(rtwdev, &sband_5ghz->vht_cap);\n\t\trtw89_init_he_cap(rtwdev, NL80211_BAND_5GHZ, sband_5ghz);\n\t\thw->wiphy->bands[NL80211_BAND_5GHZ] = sband_5ghz;\n\t}\n\n\tif (support_bands & BIT(NL80211_BAND_6GHZ)) {\n\t\tsband_6ghz = kmemdup(&rtw89_sband_6ghz, size, GFP_KERNEL);\n\t\tif (!sband_6ghz)\n\t\t\tgoto err;\n\t\trtw89_init_he_cap(rtwdev, NL80211_BAND_6GHZ, sband_6ghz);\n\t\thw->wiphy->bands[NL80211_BAND_6GHZ] = sband_6ghz;\n\t}\n\n\treturn 0;\n\nerr:\n\thw->wiphy->bands[NL80211_BAND_2GHZ] = NULL;\n\thw->wiphy->bands[NL80211_BAND_5GHZ] = NULL;\n\thw->wiphy->bands[NL80211_BAND_6GHZ] = NULL;\n\tif (sband_2ghz)\n\t\tkfree(sband_2ghz->iftype_data);\n\tif (sband_5ghz)\n\t\tkfree(sband_5ghz->iftype_data);\n\tif (sband_6ghz)\n\t\tkfree(sband_6ghz->iftype_data);\n\tkfree(sband_2ghz);\n\tkfree(sband_5ghz);\n\tkfree(sband_6ghz);\n\treturn -ENOMEM;\n}\n\nstatic void rtw89_core_clr_supported_band(struct rtw89_dev *rtwdev)\n{\n\tstruct ieee80211_hw *hw = rtwdev->hw;\n\n\tif (hw->wiphy->bands[NL80211_BAND_2GHZ])\n\t\tkfree(hw->wiphy->bands[NL80211_BAND_2GHZ]->iftype_data);\n\tif (hw->wiphy->bands[NL80211_BAND_5GHZ])\n\t\tkfree(hw->wiphy->bands[NL80211_BAND_5GHZ]->iftype_data);\n\tif (hw->wiphy->bands[NL80211_BAND_6GHZ])\n\t\tkfree(hw->wiphy->bands[NL80211_BAND_6GHZ]->iftype_data);\n\tkfree(hw->wiphy->bands[NL80211_BAND_2GHZ]);\n\tkfree(hw->wiphy->bands[NL80211_BAND_5GHZ]);\n\tkfree(hw->wiphy->bands[NL80211_BAND_6GHZ]);\n\thw->wiphy->bands[NL80211_BAND_2GHZ] = NULL;\n\thw->wiphy->bands[NL80211_BAND_5GHZ] = NULL;\n\thw->wiphy->bands[NL80211_BAND_6GHZ] = NULL;\n}\n\nstatic void rtw89_core_ppdu_sts_init(struct rtw89_dev *rtwdev)\n{\n\tint i;\n\n\tfor (i = 0; i < RTW89_PHY_MAX; i++)\n\t\tskb_queue_head_init(&rtwdev->ppdu_sts.rx_queue[i]);\n\tfor (i = 0; i < RTW89_PHY_MAX; i++)\n\t\trtwdev->ppdu_sts.curr_rx_ppdu_cnt[i] = U8_MAX;\n}\n\nvoid rtw89_core_update_beacon_work(struct work_struct *work)\n{\n\tstruct rtw89_dev *rtwdev;\n\tstruct rtw89_vif *rtwvif = container_of(work, struct rtw89_vif,\n\t\t\t\t\t\tupdate_beacon_work);\n\n\tif (rtwvif->net_type != RTW89_NET_TYPE_AP_MODE)\n\t\treturn;\n\n\trtwdev = rtwvif->rtwdev;\n\tmutex_lock(&rtwdev->mutex);\n\trtw89_fw_h2c_update_beacon(rtwdev, rtwvif);\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nint rtw89_wait_for_cond(struct rtw89_wait_info *wait, unsigned int cond)\n{\n\tstruct completion *cmpl = &wait->completion;\n\tunsigned long timeout;\n\tunsigned int cur;\n\n\tcur = atomic_cmpxchg(&wait->cond, RTW89_WAIT_COND_IDLE, cond);\n\tif (cur != RTW89_WAIT_COND_IDLE)\n\t\treturn -EBUSY;\n\n\ttimeout = wait_for_completion_timeout(cmpl, RTW89_WAIT_FOR_COND_TIMEOUT);\n\tif (timeout == 0) {\n\t\tatomic_set(&wait->cond, RTW89_WAIT_COND_IDLE);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tif (wait->data.err)\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nvoid rtw89_complete_cond(struct rtw89_wait_info *wait, unsigned int cond,\n\t\t\t const struct rtw89_completion_data *data)\n{\n\tunsigned int cur;\n\n\tcur = atomic_cmpxchg(&wait->cond, cond, RTW89_WAIT_COND_IDLE);\n\tif (cur != cond)\n\t\treturn;\n\n\twait->data = *data;\n\tcomplete(&wait->completion);\n}\n\nvoid rtw89_core_ntfy_btc_event(struct rtw89_dev *rtwdev, enum rtw89_btc_hmsg event)\n{\n\tu16 bt_req_len;\n\n\tswitch (event) {\n\tcase RTW89_BTC_HMSG_SET_BT_REQ_SLOT:\n\t\tbt_req_len = rtw89_coex_query_bt_req_len(rtwdev, RTW89_PHY_0);\n\t\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t\t    \"coex updates BT req len to %d TU\\n\", bt_req_len);\n\t\tbreak;\n\tdefault:\n\t\tif (event < NUM_OF_RTW89_BTC_HMSG)\n\t\t\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t\t\t    \"unhandled BTC HMSG event: %d\\n\", event);\n\t\telse\n\t\t\trtw89_warn(rtwdev,\n\t\t\t\t   \"unrecognized BTC HMSG event: %d\\n\", event);\n\t\tbreak;\n\t}\n}\n\nint rtw89_core_start(struct rtw89_dev *rtwdev)\n{\n\tint ret;\n\n\trtwdev->mac.qta_mode = RTW89_QTA_SCC;\n\tret = rtw89_mac_init(rtwdev);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"mac init fail, ret:%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\trtw89_btc_ntfy_poweron(rtwdev);\n\n\t \n\n\t \n\tret = rtw89_chip_disable_bb_rf(rtwdev);\n\tif (ret)\n\t\treturn ret;\n\tret = rtw89_chip_enable_bb_rf(rtwdev);\n\tif (ret)\n\t\treturn ret;\n\n\trtw89_phy_init_bb_reg(rtwdev);\n\trtw89_phy_init_rf_reg(rtwdev, false);\n\n\trtw89_btc_ntfy_init(rtwdev, BTC_MODE_NORMAL);\n\n\trtw89_phy_dm_init(rtwdev);\n\n\trtw89_mac_cfg_ppdu_status(rtwdev, RTW89_MAC_0, true);\n\trtw89_mac_update_rts_threshold(rtwdev, RTW89_MAC_0);\n\n\trtw89_tas_reset(rtwdev);\n\n\tret = rtw89_hci_start(rtwdev);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to start hci\\n\");\n\t\treturn ret;\n\t}\n\n\tieee80211_queue_delayed_work(rtwdev->hw, &rtwdev->track_work,\n\t\t\t\t     RTW89_TRACK_WORK_PERIOD);\n\n\tset_bit(RTW89_FLAG_RUNNING, rtwdev->flags);\n\n\trtw89_btc_ntfy_radio_state(rtwdev, BTC_RFCTRL_WL_ON);\n\trtw89_fw_h2c_fw_log(rtwdev, rtwdev->fw.log.enable);\n\trtw89_fw_h2c_init_ba_cam(rtwdev);\n\n\treturn 0;\n}\n\nvoid rtw89_core_stop(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\n\t \n\tif (!test_bit(RTW89_FLAG_RUNNING, rtwdev->flags))\n\t\treturn;\n\n\trtw89_btc_ntfy_radio_state(rtwdev, BTC_RFCTRL_WL_OFF);\n\n\tclear_bit(RTW89_FLAG_RUNNING, rtwdev->flags);\n\n\tmutex_unlock(&rtwdev->mutex);\n\n\tcancel_work_sync(&rtwdev->c2h_work);\n\tcancel_work_sync(&rtwdev->cancel_6ghz_probe_work);\n\tcancel_work_sync(&btc->eapol_notify_work);\n\tcancel_work_sync(&btc->arp_notify_work);\n\tcancel_work_sync(&btc->dhcp_notify_work);\n\tcancel_work_sync(&btc->icmp_notify_work);\n\tcancel_delayed_work_sync(&rtwdev->txq_reinvoke_work);\n\tcancel_delayed_work_sync(&rtwdev->track_work);\n\tcancel_delayed_work_sync(&rtwdev->chanctx_work);\n\tcancel_delayed_work_sync(&rtwdev->coex_act1_work);\n\tcancel_delayed_work_sync(&rtwdev->coex_bt_devinfo_work);\n\tcancel_delayed_work_sync(&rtwdev->coex_rfk_chk_work);\n\tcancel_delayed_work_sync(&rtwdev->cfo_track_work);\n\tcancel_delayed_work_sync(&rtwdev->forbid_ba_work);\n\tcancel_delayed_work_sync(&rtwdev->antdiv_work);\n\n\tmutex_lock(&rtwdev->mutex);\n\n\trtw89_btc_ntfy_poweroff(rtwdev);\n\trtw89_hci_flush_queues(rtwdev, BIT(rtwdev->hw->queues) - 1, true);\n\trtw89_mac_flush_txq(rtwdev, BIT(rtwdev->hw->queues) - 1, true);\n\trtw89_hci_stop(rtwdev);\n\trtw89_hci_deinit(rtwdev);\n\trtw89_mac_pwr_off(rtwdev);\n\trtw89_hci_reset(rtwdev);\n}\n\nint rtw89_core_init(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tu8 band;\n\n\tINIT_LIST_HEAD(&rtwdev->ba_list);\n\tINIT_LIST_HEAD(&rtwdev->forbid_ba_list);\n\tINIT_LIST_HEAD(&rtwdev->rtwvifs_list);\n\tINIT_LIST_HEAD(&rtwdev->early_h2c_list);\n\tfor (band = NL80211_BAND_2GHZ; band < NUM_NL80211_BANDS; band++) {\n\t\tif (!(rtwdev->chip->support_bands & BIT(band)))\n\t\t\tcontinue;\n\t\tINIT_LIST_HEAD(&rtwdev->scan_info.pkt_list[band]);\n\t}\n\tINIT_WORK(&rtwdev->ba_work, rtw89_core_ba_work);\n\tINIT_WORK(&rtwdev->txq_work, rtw89_core_txq_work);\n\tINIT_DELAYED_WORK(&rtwdev->txq_reinvoke_work, rtw89_core_txq_reinvoke_work);\n\tINIT_DELAYED_WORK(&rtwdev->track_work, rtw89_track_work);\n\tINIT_DELAYED_WORK(&rtwdev->chanctx_work, rtw89_chanctx_work);\n\tINIT_DELAYED_WORK(&rtwdev->coex_act1_work, rtw89_coex_act1_work);\n\tINIT_DELAYED_WORK(&rtwdev->coex_bt_devinfo_work, rtw89_coex_bt_devinfo_work);\n\tINIT_DELAYED_WORK(&rtwdev->coex_rfk_chk_work, rtw89_coex_rfk_chk_work);\n\tINIT_DELAYED_WORK(&rtwdev->cfo_track_work, rtw89_phy_cfo_track_work);\n\tINIT_DELAYED_WORK(&rtwdev->forbid_ba_work, rtw89_forbid_ba_work);\n\tINIT_DELAYED_WORK(&rtwdev->antdiv_work, rtw89_phy_antdiv_work);\n\trtwdev->txq_wq = alloc_workqueue(\"rtw89_tx_wq\", WQ_UNBOUND | WQ_HIGHPRI, 0);\n\tif (!rtwdev->txq_wq)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&rtwdev->ba_lock);\n\tspin_lock_init(&rtwdev->rpwm_lock);\n\tmutex_init(&rtwdev->mutex);\n\tmutex_init(&rtwdev->rf_mutex);\n\trtwdev->total_sta_assoc = 0;\n\n\trtw89_init_wait(&rtwdev->mcc.wait);\n\trtw89_init_wait(&rtwdev->mac.fw_ofld_wait);\n\n\tINIT_WORK(&rtwdev->c2h_work, rtw89_fw_c2h_work);\n\tINIT_WORK(&rtwdev->ips_work, rtw89_ips_work);\n\tINIT_WORK(&rtwdev->load_firmware_work, rtw89_load_firmware_work);\n\tINIT_WORK(&rtwdev->cancel_6ghz_probe_work, rtw89_cancel_6ghz_probe_work);\n\n\tskb_queue_head_init(&rtwdev->c2h_queue);\n\trtw89_core_ppdu_sts_init(rtwdev);\n\trtw89_traffic_stats_init(rtwdev, &rtwdev->stats);\n\n\trtwdev->hal.rx_fltr = DEFAULT_AX_RX_FLTR;\n\n\tINIT_WORK(&btc->eapol_notify_work, rtw89_btc_ntfy_eapol_packet_work);\n\tINIT_WORK(&btc->arp_notify_work, rtw89_btc_ntfy_arp_packet_work);\n\tINIT_WORK(&btc->dhcp_notify_work, rtw89_btc_ntfy_dhcp_packet_work);\n\tINIT_WORK(&btc->icmp_notify_work, rtw89_btc_ntfy_icmp_packet_work);\n\n\tinit_completion(&rtwdev->fw.req.completion);\n\n\tschedule_work(&rtwdev->load_firmware_work);\n\n\trtw89_ser_init(rtwdev);\n\trtw89_entity_init(rtwdev);\n\trtw89_tas_init(rtwdev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rtw89_core_init);\n\nvoid rtw89_core_deinit(struct rtw89_dev *rtwdev)\n{\n\trtw89_ser_deinit(rtwdev);\n\trtw89_unload_firmware(rtwdev);\n\trtw89_fw_free_all_early_h2c(rtwdev);\n\n\tdestroy_workqueue(rtwdev->txq_wq);\n\tmutex_destroy(&rtwdev->rf_mutex);\n\tmutex_destroy(&rtwdev->mutex);\n}\nEXPORT_SYMBOL(rtw89_core_deinit);\n\nvoid rtw89_core_scan_start(struct rtw89_dev *rtwdev, struct rtw89_vif *rtwvif,\n\t\t\t   const u8 *mac_addr, bool hw_scan)\n{\n\tconst struct rtw89_chan *chan = rtw89_chan_get(rtwdev,\n\t\t\t\t\t\t       rtwvif->sub_entity_idx);\n\n\trtwdev->scanning = true;\n\trtw89_leave_lps(rtwdev);\n\tif (hw_scan)\n\t\trtw89_leave_ips_by_hwflags(rtwdev);\n\n\tether_addr_copy(rtwvif->mac_addr, mac_addr);\n\trtw89_btc_ntfy_scan_start(rtwdev, RTW89_PHY_0, chan->band_type);\n\trtw89_chip_rfk_scan(rtwdev, true);\n\trtw89_hci_recalc_int_mit(rtwdev);\n\trtw89_phy_config_edcca(rtwdev, true);\n\n\trtw89_fw_h2c_cam(rtwdev, rtwvif, NULL, mac_addr);\n}\n\nvoid rtw89_core_scan_complete(struct rtw89_dev *rtwdev,\n\t\t\t      struct ieee80211_vif *vif, bool hw_scan)\n{\n\tstruct rtw89_vif *rtwvif = vif ? (struct rtw89_vif *)vif->drv_priv : NULL;\n\n\tif (!rtwvif)\n\t\treturn;\n\n\tether_addr_copy(rtwvif->mac_addr, vif->addr);\n\trtw89_fw_h2c_cam(rtwdev, rtwvif, NULL, NULL);\n\n\trtw89_chip_rfk_scan(rtwdev, false);\n\trtw89_btc_ntfy_scan_finish(rtwdev, RTW89_PHY_0);\n\trtw89_phy_config_edcca(rtwdev, false);\n\n\trtwdev->scanning = false;\n\trtwdev->dig.bypass_dig = true;\n\tif (hw_scan && (rtwdev->hw->conf.flags & IEEE80211_CONF_IDLE))\n\t\tieee80211_queue_work(rtwdev->hw, &rtwdev->ips_work);\n}\n\nstatic void rtw89_read_chip_ver(struct rtw89_dev *rtwdev)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tint ret;\n\tu8 val;\n\tu8 cv;\n\n\tcv = rtw89_read32_mask(rtwdev, R_AX_SYS_CFG1, B_AX_CHIP_VER_MASK);\n\tif (chip->chip_id == RTL8852A && cv <= CHIP_CBV) {\n\t\tif (rtw89_read32(rtwdev, R_AX_GPIO0_7_FUNC_SEL) == RTW89_R32_DEAD)\n\t\t\tcv = CHIP_CAV;\n\t\telse\n\t\t\tcv = CHIP_CBV;\n\t}\n\n\trtwdev->hal.cv = cv;\n\n\tif (chip->chip_id == RTL8852B || chip->chip_id == RTL8851B) {\n\t\tret = rtw89_mac_read_xtal_si(rtwdev, XTAL_SI_CV, &val);\n\t\tif (ret)\n\t\t\treturn;\n\n\t\trtwdev->hal.acv = u8_get_bits(val, XTAL_SI_ACV_MASK);\n\t}\n}\n\nstatic void rtw89_core_setup_phycap(struct rtw89_dev *rtwdev)\n{\n\trtwdev->hal.support_cckpd =\n\t\t!(rtwdev->chip->chip_id == RTL8852A && rtwdev->hal.cv <= CHIP_CBV) &&\n\t\t!(rtwdev->chip->chip_id == RTL8852B && rtwdev->hal.cv <= CHIP_CAV);\n\trtwdev->hal.support_igi =\n\t\trtwdev->chip->chip_id == RTL8852A && rtwdev->hal.cv <= CHIP_CBV;\n}\n\nstatic void rtw89_core_setup_rfe_parms(struct rtw89_dev *rtwdev)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tconst struct rtw89_rfe_parms_conf *conf = chip->rfe_parms_conf;\n\tstruct rtw89_efuse *efuse = &rtwdev->efuse;\n\tu8 rfe_type = efuse->rfe_type;\n\n\tif (!conf)\n\t\tgoto out;\n\n\twhile (conf->rfe_parms) {\n\t\tif (rfe_type == conf->rfe_type) {\n\t\t\trtwdev->rfe_parms = conf->rfe_parms;\n\t\t\treturn;\n\t\t}\n\t\tconf++;\n\t}\n\nout:\n\trtwdev->rfe_parms = chip->dflt_parms;\n}\n\nstatic int rtw89_chip_efuse_info_setup(struct rtw89_dev *rtwdev)\n{\n\tint ret;\n\n\tret = rtw89_mac_partial_init(rtwdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rtw89_parse_efuse_map(rtwdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rtw89_parse_phycap_map(rtwdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rtw89_mac_setup_phycap(rtwdev);\n\tif (ret)\n\t\treturn ret;\n\n\trtw89_core_setup_phycap(rtwdev);\n\trtw89_core_setup_rfe_parms(rtwdev);\n\n\trtw89_mac_pwr_off(rtwdev);\n\n\treturn 0;\n}\n\nstatic int rtw89_chip_board_info_setup(struct rtw89_dev *rtwdev)\n{\n\trtw89_chip_fem_setup(rtwdev);\n\n\treturn 0;\n}\n\nint rtw89_chip_info_setup(struct rtw89_dev *rtwdev)\n{\n\tint ret;\n\n\trtw89_read_chip_ver(rtwdev);\n\n\tret = rtw89_wait_firmware_completion(rtwdev);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to wait firmware completion\\n\");\n\t\treturn ret;\n\t}\n\n\tret = rtw89_fw_recognize(rtwdev);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to recognize firmware\\n\");\n\t\treturn ret;\n\t}\n\n\tret = rtw89_fw_recognize_elements(rtwdev);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to recognize firmware elements\\n\");\n\t\treturn ret;\n\t}\n\n\tret = rtw89_chip_efuse_info_setup(rtwdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rtw89_chip_board_info_setup(rtwdev);\n\tif (ret)\n\t\treturn ret;\n\n\trtwdev->ps_mode = rtw89_update_ps_mode(rtwdev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rtw89_chip_info_setup);\n\nstatic int rtw89_core_register_hw(struct rtw89_dev *rtwdev)\n{\n\tstruct ieee80211_hw *hw = rtwdev->hw;\n\tstruct rtw89_efuse *efuse = &rtwdev->efuse;\n\tstruct rtw89_hal *hal = &rtwdev->hal;\n\tint ret;\n\tint tx_headroom = IEEE80211_HT_CTL_LEN;\n\n\thw->vif_data_size = sizeof(struct rtw89_vif);\n\thw->sta_data_size = sizeof(struct rtw89_sta);\n\thw->txq_data_size = sizeof(struct rtw89_txq);\n\thw->chanctx_data_size = sizeof(struct rtw89_chanctx_cfg);\n\n\tSET_IEEE80211_PERM_ADDR(hw, efuse->addr);\n\n\thw->extra_tx_headroom = tx_headroom;\n\thw->queues = IEEE80211_NUM_ACS;\n\thw->max_rx_aggregation_subframes = RTW89_MAX_RX_AGG_NUM;\n\thw->max_tx_aggregation_subframes = RTW89_MAX_TX_AGG_NUM;\n\thw->uapsd_max_sp_len = IEEE80211_WMM_IE_STA_QOSINFO_SP_ALL;\n\n\tieee80211_hw_set(hw, SIGNAL_DBM);\n\tieee80211_hw_set(hw, HAS_RATE_CONTROL);\n\tieee80211_hw_set(hw, MFP_CAPABLE);\n\tieee80211_hw_set(hw, REPORTS_TX_ACK_STATUS);\n\tieee80211_hw_set(hw, AMPDU_AGGREGATION);\n\tieee80211_hw_set(hw, RX_INCLUDES_FCS);\n\tieee80211_hw_set(hw, TX_AMSDU);\n\tieee80211_hw_set(hw, SUPPORT_FAST_XMIT);\n\tieee80211_hw_set(hw, SUPPORTS_AMSDU_IN_AMPDU);\n\tieee80211_hw_set(hw, SUPPORTS_PS);\n\tieee80211_hw_set(hw, SUPPORTS_DYNAMIC_PS);\n\tieee80211_hw_set(hw, SINGLE_SCAN_ON_ALL_BANDS);\n\tieee80211_hw_set(hw, SUPPORTS_MULTI_BSSID);\n\tieee80211_hw_set(hw, WANT_MONITOR_VIF);\n\tif (RTW89_CHK_FW_FEATURE(BEACON_FILTER, &rtwdev->fw))\n\t\tieee80211_hw_set(hw, CONNECTION_MONITOR);\n\n\thw->wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |\n\t\t\t\t     BIT(NL80211_IFTYPE_AP) |\n\t\t\t\t     BIT(NL80211_IFTYPE_P2P_CLIENT) |\n\t\t\t\t     BIT(NL80211_IFTYPE_P2P_GO);\n\n\tif (hal->ant_diversity) {\n\t\thw->wiphy->available_antennas_tx = 0x3;\n\t\thw->wiphy->available_antennas_rx = 0x3;\n\t} else {\n\t\thw->wiphy->available_antennas_tx = BIT(rtwdev->chip->rf_path_num) - 1;\n\t\thw->wiphy->available_antennas_rx = BIT(rtwdev->chip->rf_path_num) - 1;\n\t}\n\n\thw->wiphy->flags |= WIPHY_FLAG_SUPPORTS_TDLS |\n\t\t\t    WIPHY_FLAG_TDLS_EXTERNAL_SETUP |\n\t\t\t    WIPHY_FLAG_AP_UAPSD | WIPHY_FLAG_SPLIT_SCAN_6GHZ;\n\thw->wiphy->features |= NL80211_FEATURE_SCAN_RANDOM_MAC_ADDR;\n\n\thw->wiphy->max_scan_ssids = RTW89_SCANOFLD_MAX_SSID;\n\thw->wiphy->max_scan_ie_len = RTW89_SCANOFLD_MAX_IE_LEN;\n\n#ifdef CONFIG_PM\n\thw->wiphy->wowlan = rtwdev->chip->wowlan_stub;\n#endif\n\n\thw->wiphy->tid_config_support.vif |= BIT(NL80211_TID_CONFIG_ATTR_AMPDU_CTRL);\n\thw->wiphy->tid_config_support.peer |= BIT(NL80211_TID_CONFIG_ATTR_AMPDU_CTRL);\n\thw->wiphy->tid_config_support.vif |= BIT(NL80211_TID_CONFIG_ATTR_AMSDU_CTRL);\n\thw->wiphy->tid_config_support.peer |= BIT(NL80211_TID_CONFIG_ATTR_AMSDU_CTRL);\n\thw->wiphy->max_remain_on_channel_duration = 1000;\n\n\twiphy_ext_feature_set(hw->wiphy, NL80211_EXT_FEATURE_CAN_REPLACE_PTK0);\n\n\tret = rtw89_core_set_supported_band(rtwdev);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to set supported band\\n\");\n\t\treturn ret;\n\t}\n\n\tret = rtw89_regd_setup(rtwdev);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to set up regd\\n\");\n\t\tgoto err_free_supported_band;\n\t}\n\n\thw->wiphy->sar_capa = &rtw89_sar_capa;\n\n\tret = ieee80211_register_hw(hw);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to register hw\\n\");\n\t\tgoto err_free_supported_band;\n\t}\n\n\tret = rtw89_regd_init(rtwdev, rtw89_regd_notifier);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to init regd\\n\");\n\t\tgoto err_unregister_hw;\n\t}\n\n\treturn 0;\n\nerr_unregister_hw:\n\tieee80211_unregister_hw(hw);\nerr_free_supported_band:\n\trtw89_core_clr_supported_band(rtwdev);\n\n\treturn ret;\n}\n\nstatic void rtw89_core_unregister_hw(struct rtw89_dev *rtwdev)\n{\n\tstruct ieee80211_hw *hw = rtwdev->hw;\n\n\tieee80211_unregister_hw(hw);\n\trtw89_core_clr_supported_band(rtwdev);\n}\n\nint rtw89_core_register(struct rtw89_dev *rtwdev)\n{\n\tint ret;\n\n\tret = rtw89_core_register_hw(rtwdev);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to register core hw\\n\");\n\t\treturn ret;\n\t}\n\n\trtw89_debugfs_init(rtwdev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rtw89_core_register);\n\nvoid rtw89_core_unregister(struct rtw89_dev *rtwdev)\n{\n\trtw89_core_unregister_hw(rtwdev);\n}\nEXPORT_SYMBOL(rtw89_core_unregister);\n\nstruct rtw89_dev *rtw89_alloc_ieee80211_hw(struct device *device,\n\t\t\t\t\t   u32 bus_data_size,\n\t\t\t\t\t   const struct rtw89_chip_info *chip)\n{\n\tstruct rtw89_fw_info early_fw = {};\n\tconst struct firmware *firmware;\n\tstruct ieee80211_hw *hw;\n\tstruct rtw89_dev *rtwdev;\n\tstruct ieee80211_ops *ops;\n\tu32 driver_data_size;\n\tint fw_format = -1;\n\tbool no_chanctx;\n\n\tfirmware = rtw89_early_fw_feature_recognize(device, chip, &early_fw, &fw_format);\n\n\tops = kmemdup(&rtw89_ops, sizeof(rtw89_ops), GFP_KERNEL);\n\tif (!ops)\n\t\tgoto err;\n\n\tno_chanctx = chip->support_chanctx_num == 0 ||\n\t\t     !RTW89_CHK_FW_FEATURE(SCAN_OFFLOAD, &early_fw) ||\n\t\t     !RTW89_CHK_FW_FEATURE(BEACON_FILTER, &early_fw);\n\n\tif (no_chanctx) {\n\t\tops->add_chanctx = NULL;\n\t\tops->remove_chanctx = NULL;\n\t\tops->change_chanctx = NULL;\n\t\tops->assign_vif_chanctx = NULL;\n\t\tops->unassign_vif_chanctx = NULL;\n\t\tops->remain_on_channel = NULL;\n\t\tops->cancel_remain_on_channel = NULL;\n\t}\n\n\tdriver_data_size = sizeof(struct rtw89_dev) + bus_data_size;\n\thw = ieee80211_alloc_hw(driver_data_size, ops);\n\tif (!hw)\n\t\tgoto err;\n\n\thw->wiphy->iface_combinations = rtw89_iface_combs;\n\thw->wiphy->n_iface_combinations = ARRAY_SIZE(rtw89_iface_combs);\n\n\trtwdev = hw->priv;\n\trtwdev->hw = hw;\n\trtwdev->dev = device;\n\trtwdev->ops = ops;\n\trtwdev->chip = chip;\n\trtwdev->fw.req.firmware = firmware;\n\trtwdev->fw.fw_format = fw_format;\n\n\trtw89_debug(rtwdev, RTW89_DBG_FW, \"probe driver %s chanctx\\n\",\n\t\t    no_chanctx ? \"without\" : \"with\");\n\n\treturn rtwdev;\n\nerr:\n\tkfree(ops);\n\trelease_firmware(firmware);\n\treturn NULL;\n}\nEXPORT_SYMBOL(rtw89_alloc_ieee80211_hw);\n\nvoid rtw89_free_ieee80211_hw(struct rtw89_dev *rtwdev)\n{\n\tkfree(rtwdev->ops);\n\trelease_firmware(rtwdev->fw.req.firmware);\n\tieee80211_free_hw(rtwdev->hw);\n}\nEXPORT_SYMBOL(rtw89_free_ieee80211_hw);\n\nMODULE_AUTHOR(\"Realtek Corporation\");\nMODULE_DESCRIPTION(\"Realtek 802.11ax wireless core module\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}