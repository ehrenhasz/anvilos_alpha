{
  "module_name": "chan.c",
  "hash_id": "09371b0ced468ed1a2a7329fc62b7055b8ec5883e763ab717e5602311a580074",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtw89/chan.c",
  "human_readable_source": "\n \n\n#include \"chan.h\"\n#include \"debug.h\"\n#include \"fw.h\"\n#include \"ps.h\"\n#include \"util.h\"\n\nstatic enum rtw89_subband rtw89_get_subband_type(enum rtw89_band band,\n\t\t\t\t\t\t u8 center_chan)\n{\n\tswitch (band) {\n\tdefault:\n\tcase RTW89_BAND_2G:\n\t\tswitch (center_chan) {\n\t\tdefault:\n\t\tcase 1 ... 14:\n\t\t\treturn RTW89_CH_2G;\n\t\t}\n\tcase RTW89_BAND_5G:\n\t\tswitch (center_chan) {\n\t\tdefault:\n\t\tcase 36 ... 64:\n\t\t\treturn RTW89_CH_5G_BAND_1;\n\t\tcase 100 ... 144:\n\t\t\treturn RTW89_CH_5G_BAND_3;\n\t\tcase 149 ... 177:\n\t\t\treturn RTW89_CH_5G_BAND_4;\n\t\t}\n\tcase RTW89_BAND_6G:\n\t\tswitch (center_chan) {\n\t\tdefault:\n\t\tcase 1 ... 29:\n\t\t\treturn RTW89_CH_6G_BAND_IDX0;\n\t\tcase 33 ... 61:\n\t\t\treturn RTW89_CH_6G_BAND_IDX1;\n\t\tcase 65 ... 93:\n\t\t\treturn RTW89_CH_6G_BAND_IDX2;\n\t\tcase 97 ... 125:\n\t\t\treturn RTW89_CH_6G_BAND_IDX3;\n\t\tcase 129 ... 157:\n\t\t\treturn RTW89_CH_6G_BAND_IDX4;\n\t\tcase 161 ... 189:\n\t\t\treturn RTW89_CH_6G_BAND_IDX5;\n\t\tcase 193 ... 221:\n\t\t\treturn RTW89_CH_6G_BAND_IDX6;\n\t\tcase 225 ... 253:\n\t\t\treturn RTW89_CH_6G_BAND_IDX7;\n\t\t}\n\t}\n}\n\nstatic enum rtw89_sc_offset rtw89_get_primary_chan_idx(enum rtw89_bandwidth bw,\n\t\t\t\t\t\t       u32 center_freq,\n\t\t\t\t\t\t       u32 primary_freq)\n{\n\tu8 primary_chan_idx;\n\tu32 offset;\n\n\tswitch (bw) {\n\tdefault:\n\tcase RTW89_CHANNEL_WIDTH_20:\n\t\tprimary_chan_idx = RTW89_SC_DONT_CARE;\n\t\tbreak;\n\tcase RTW89_CHANNEL_WIDTH_40:\n\t\tif (primary_freq > center_freq)\n\t\t\tprimary_chan_idx = RTW89_SC_20_UPPER;\n\t\telse\n\t\t\tprimary_chan_idx = RTW89_SC_20_LOWER;\n\t\tbreak;\n\tcase RTW89_CHANNEL_WIDTH_80:\n\tcase RTW89_CHANNEL_WIDTH_160:\n\t\tif (primary_freq > center_freq) {\n\t\t\toffset = (primary_freq - center_freq - 10) / 20;\n\t\t\tprimary_chan_idx = RTW89_SC_20_UPPER + offset * 2;\n\t\t} else {\n\t\t\toffset = (center_freq - primary_freq - 10) / 20;\n\t\t\tprimary_chan_idx = RTW89_SC_20_LOWER + offset * 2;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn primary_chan_idx;\n}\n\nvoid rtw89_chan_create(struct rtw89_chan *chan, u8 center_chan, u8 primary_chan,\n\t\t       enum rtw89_band band, enum rtw89_bandwidth bandwidth)\n{\n\tenum nl80211_band nl_band = rtw89_hw_to_nl80211_band(band);\n\tu32 center_freq, primary_freq;\n\n\tmemset(chan, 0, sizeof(*chan));\n\tchan->channel = center_chan;\n\tchan->primary_channel = primary_chan;\n\tchan->band_type = band;\n\tchan->band_width = bandwidth;\n\n\tcenter_freq = ieee80211_channel_to_frequency(center_chan, nl_band);\n\tprimary_freq = ieee80211_channel_to_frequency(primary_chan, nl_band);\n\n\tchan->freq = center_freq;\n\tchan->subband_type = rtw89_get_subband_type(band, center_chan);\n\tchan->pri_ch_idx = rtw89_get_primary_chan_idx(bandwidth, center_freq,\n\t\t\t\t\t\t      primary_freq);\n}\n\nbool rtw89_assign_entity_chan(struct rtw89_dev *rtwdev,\n\t\t\t      enum rtw89_sub_entity_idx idx,\n\t\t\t      const struct rtw89_chan *new)\n{\n\tstruct rtw89_hal *hal = &rtwdev->hal;\n\tstruct rtw89_chan *chan = &hal->sub[idx].chan;\n\tstruct rtw89_chan_rcd *rcd = &hal->sub[idx].rcd;\n\tbool band_changed;\n\n\trcd->prev_primary_channel = chan->primary_channel;\n\trcd->prev_band_type = chan->band_type;\n\tband_changed = new->band_type != chan->band_type;\n\trcd->band_changed = band_changed;\n\n\t*chan = *new;\n\treturn band_changed;\n}\n\nstatic void __rtw89_config_entity_chandef(struct rtw89_dev *rtwdev,\n\t\t\t\t\t  enum rtw89_sub_entity_idx idx,\n\t\t\t\t\t  const struct cfg80211_chan_def *chandef,\n\t\t\t\t\t  bool from_stack)\n{\n\tstruct rtw89_hal *hal = &rtwdev->hal;\n\n\thal->sub[idx].chandef = *chandef;\n\n\tif (from_stack)\n\t\tset_bit(idx, hal->entity_map);\n}\n\nvoid rtw89_config_entity_chandef(struct rtw89_dev *rtwdev,\n\t\t\t\t enum rtw89_sub_entity_idx idx,\n\t\t\t\t const struct cfg80211_chan_def *chandef)\n{\n\t__rtw89_config_entity_chandef(rtwdev, idx, chandef, true);\n}\n\nvoid rtw89_config_roc_chandef(struct rtw89_dev *rtwdev,\n\t\t\t      enum rtw89_sub_entity_idx idx,\n\t\t\t      const struct cfg80211_chan_def *chandef)\n{\n\tstruct rtw89_hal *hal = &rtwdev->hal;\n\tenum rtw89_sub_entity_idx cur;\n\n\tif (chandef) {\n\t\tcur = atomic_cmpxchg(&hal->roc_entity_idx,\n\t\t\t\t     RTW89_SUB_ENTITY_IDLE, idx);\n\t\tif (cur != RTW89_SUB_ENTITY_IDLE) {\n\t\t\trtw89_debug(rtwdev, RTW89_DBG_TXRX,\n\t\t\t\t    \"ROC still processing on entity %d\\n\", idx);\n\t\t\treturn;\n\t\t}\n\n\t\thal->roc_chandef = *chandef;\n\t} else {\n\t\tcur = atomic_cmpxchg(&hal->roc_entity_idx, idx,\n\t\t\t\t     RTW89_SUB_ENTITY_IDLE);\n\t\tif (cur == idx)\n\t\t\treturn;\n\n\t\tif (cur == RTW89_SUB_ENTITY_IDLE)\n\t\t\trtw89_debug(rtwdev, RTW89_DBG_TXRX,\n\t\t\t\t    \"ROC already finished on entity %d\\n\", idx);\n\t\telse\n\t\t\trtw89_debug(rtwdev, RTW89_DBG_TXRX,\n\t\t\t\t    \"ROC is processing on entity %d\\n\", cur);\n\t}\n}\n\nstatic void rtw89_config_default_chandef(struct rtw89_dev *rtwdev)\n{\n\tstruct cfg80211_chan_def chandef = {0};\n\n\trtw89_get_default_chandef(&chandef);\n\t__rtw89_config_entity_chandef(rtwdev, RTW89_SUB_ENTITY_0, &chandef, false);\n}\n\nvoid rtw89_entity_init(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_hal *hal = &rtwdev->hal;\n\n\tbitmap_zero(hal->entity_map, NUM_OF_RTW89_SUB_ENTITY);\n\tatomic_set(&hal->roc_entity_idx, RTW89_SUB_ENTITY_IDLE);\n\trtw89_config_default_chandef(rtwdev);\n}\n\nenum rtw89_entity_mode rtw89_entity_recalc(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_hal *hal = &rtwdev->hal;\n\tconst struct cfg80211_chan_def *chandef;\n\tenum rtw89_entity_mode mode;\n\tstruct rtw89_chan chan;\n\tu8 weight;\n\tu8 last;\n\tu8 idx;\n\n\tweight = bitmap_weight(hal->entity_map, NUM_OF_RTW89_SUB_ENTITY);\n\tswitch (weight) {\n\tdefault:\n\t\trtw89_warn(rtwdev, \"unknown ent chan weight: %d\\n\", weight);\n\t\tbitmap_zero(hal->entity_map, NUM_OF_RTW89_SUB_ENTITY);\n\t\tfallthrough;\n\tcase 0:\n\t\trtw89_config_default_chandef(rtwdev);\n\t\tfallthrough;\n\tcase 1:\n\t\tlast = RTW89_SUB_ENTITY_0;\n\t\tmode = RTW89_ENTITY_MODE_SCC;\n\t\tbreak;\n\tcase 2:\n\t\tlast = RTW89_SUB_ENTITY_1;\n\t\tmode = rtw89_get_entity_mode(rtwdev);\n\t\tif (mode == RTW89_ENTITY_MODE_MCC)\n\t\t\tbreak;\n\n\t\tmode = RTW89_ENTITY_MODE_MCC_PREPARE;\n\t\tbreak;\n\t}\n\n\tfor (idx = 0; idx <= last; idx++) {\n\t\tchandef = rtw89_chandef_get(rtwdev, idx);\n\t\trtw89_get_channel_params(chandef, &chan);\n\t\tif (chan.channel == 0) {\n\t\t\tWARN(1, \"Invalid channel on chanctx %d\\n\", idx);\n\t\t\treturn RTW89_ENTITY_MODE_INVALID;\n\t\t}\n\n\t\trtw89_assign_entity_chan(rtwdev, idx, &chan);\n\t}\n\n\trtw89_set_entity_mode(rtwdev, mode);\n\treturn mode;\n}\n\nstatic void rtw89_chanctx_notify(struct rtw89_dev *rtwdev,\n\t\t\t\t enum rtw89_chanctx_state state)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tconst struct rtw89_chanctx_listener *listener = chip->chanctx_listener;\n\tint i;\n\n\tif (!listener)\n\t\treturn;\n\n\tfor (i = 0; i < NUM_OF_RTW89_CHANCTX_CALLBACKS; i++) {\n\t\tif (!listener->callbacks[i])\n\t\t\tcontinue;\n\n\t\trtw89_debug(rtwdev, RTW89_DBG_CHAN,\n\t\t\t    \"chanctx notify listener: cb %d, state %d\\n\",\n\t\t\t    i, state);\n\n\t\tlistener->callbacks[i](rtwdev, state);\n\t}\n}\n\nstatic int rtw89_mcc_start(struct rtw89_dev *rtwdev)\n{\n\tif (rtwdev->scanning)\n\t\trtw89_hw_scan_abort(rtwdev, rtwdev->scan_info.scanning_vif);\n\n\trtw89_leave_lps(rtwdev);\n\n\trtw89_debug(rtwdev, RTW89_DBG_CHAN, \"MCC start\\n\");\n\trtw89_chanctx_notify(rtwdev, RTW89_CHANCTX_STATE_MCC_START);\n\treturn 0;\n}\n\nstatic void rtw89_mcc_stop(struct rtw89_dev *rtwdev)\n{\n\trtw89_debug(rtwdev, RTW89_DBG_CHAN, \"MCC stop\\n\");\n\trtw89_chanctx_notify(rtwdev, RTW89_CHANCTX_STATE_MCC_STOP);\n}\n\nvoid rtw89_chanctx_work(struct work_struct *work)\n{\n\tstruct rtw89_dev *rtwdev = container_of(work, struct rtw89_dev,\n\t\t\t\t\t\tchanctx_work.work);\n\tenum rtw89_entity_mode mode;\n\tint ret;\n\n\tmutex_lock(&rtwdev->mutex);\n\n\tmode = rtw89_get_entity_mode(rtwdev);\n\tswitch (mode) {\n\tcase RTW89_ENTITY_MODE_MCC_PREPARE:\n\t\trtw89_set_entity_mode(rtwdev, RTW89_ENTITY_MODE_MCC);\n\t\trtw89_set_channel(rtwdev);\n\n\t\tret = rtw89_mcc_start(rtwdev);\n\t\tif (ret)\n\t\t\trtw89_warn(rtwdev, \"failed to start MCC: %d\\n\", ret);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nvoid rtw89_queue_chanctx_work(struct rtw89_dev *rtwdev)\n{\n\tenum rtw89_entity_mode mode;\n\tu32 delay;\n\n\tmode = rtw89_get_entity_mode(rtwdev);\n\tswitch (mode) {\n\tdefault:\n\t\treturn;\n\tcase RTW89_ENTITY_MODE_MCC_PREPARE:\n\t\tdelay = ieee80211_tu_to_usec(RTW89_CHANCTX_TIME_MCC_PREPARE);\n\t\tbreak;\n\t}\n\n\trtw89_debug(rtwdev, RTW89_DBG_CHAN,\n\t\t    \"queue chanctx work for mode %d with delay %d us\\n\",\n\t\t    mode, delay);\n\tieee80211_queue_delayed_work(rtwdev->hw, &rtwdev->chanctx_work,\n\t\t\t\t     usecs_to_jiffies(delay));\n}\n\nint rtw89_chanctx_ops_add(struct rtw89_dev *rtwdev,\n\t\t\t  struct ieee80211_chanctx_conf *ctx)\n{\n\tstruct rtw89_hal *hal = &rtwdev->hal;\n\tstruct rtw89_chanctx_cfg *cfg = (struct rtw89_chanctx_cfg *)ctx->drv_priv;\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tu8 idx;\n\n\tidx = find_first_zero_bit(hal->entity_map, NUM_OF_RTW89_SUB_ENTITY);\n\tif (idx >= chip->support_chanctx_num)\n\t\treturn -ENOENT;\n\n\trtw89_config_entity_chandef(rtwdev, idx, &ctx->def);\n\trtw89_set_channel(rtwdev);\n\tcfg->idx = idx;\n\thal->sub[idx].cfg = cfg;\n\treturn 0;\n}\n\nvoid rtw89_chanctx_ops_remove(struct rtw89_dev *rtwdev,\n\t\t\t      struct ieee80211_chanctx_conf *ctx)\n{\n\tstruct rtw89_hal *hal = &rtwdev->hal;\n\tstruct rtw89_chanctx_cfg *cfg = (struct rtw89_chanctx_cfg *)ctx->drv_priv;\n\tenum rtw89_entity_mode mode;\n\tstruct rtw89_vif *rtwvif;\n\tu8 drop, roll;\n\n\tdrop = cfg->idx;\n\tif (drop != RTW89_SUB_ENTITY_0)\n\t\tgoto out;\n\n\troll = find_next_bit(hal->entity_map, NUM_OF_RTW89_SUB_ENTITY, drop + 1);\n\n\t \n\tif (roll == NUM_OF_RTW89_SUB_ENTITY)\n\t\tgoto out;\n\n\t \n\thal->sub[roll].cfg->idx = RTW89_SUB_ENTITY_0;\n\thal->sub[RTW89_SUB_ENTITY_0] = hal->sub[roll];\n\n\trtw89_for_each_rtwvif(rtwdev, rtwvif) {\n\t\tif (rtwvif->sub_entity_idx == roll)\n\t\t\trtwvif->sub_entity_idx = RTW89_SUB_ENTITY_0;\n\t}\n\n\tatomic_cmpxchg(&hal->roc_entity_idx, roll, RTW89_SUB_ENTITY_0);\n\n\tdrop = roll;\n\nout:\n\tmode = rtw89_get_entity_mode(rtwdev);\n\tswitch (mode) {\n\tcase RTW89_ENTITY_MODE_MCC:\n\t\trtw89_mcc_stop(rtwdev);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tclear_bit(drop, hal->entity_map);\n\trtw89_set_channel(rtwdev);\n}\n\nvoid rtw89_chanctx_ops_change(struct rtw89_dev *rtwdev,\n\t\t\t      struct ieee80211_chanctx_conf *ctx,\n\t\t\t      u32 changed)\n{\n\tstruct rtw89_chanctx_cfg *cfg = (struct rtw89_chanctx_cfg *)ctx->drv_priv;\n\tu8 idx = cfg->idx;\n\n\tif (changed & IEEE80211_CHANCTX_CHANGE_WIDTH) {\n\t\trtw89_config_entity_chandef(rtwdev, idx, &ctx->def);\n\t\trtw89_set_channel(rtwdev);\n\t}\n}\n\nint rtw89_chanctx_ops_assign_vif(struct rtw89_dev *rtwdev,\n\t\t\t\t struct rtw89_vif *rtwvif,\n\t\t\t\t struct ieee80211_chanctx_conf *ctx)\n{\n\tstruct rtw89_chanctx_cfg *cfg = (struct rtw89_chanctx_cfg *)ctx->drv_priv;\n\n\trtwvif->sub_entity_idx = cfg->idx;\n\treturn 0;\n}\n\nvoid rtw89_chanctx_ops_unassign_vif(struct rtw89_dev *rtwdev,\n\t\t\t\t    struct rtw89_vif *rtwvif,\n\t\t\t\t    struct ieee80211_chanctx_conf *ctx)\n{\n\trtwvif->sub_entity_idx = RTW89_SUB_ENTITY_0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}