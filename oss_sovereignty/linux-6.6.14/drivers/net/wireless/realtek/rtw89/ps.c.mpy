{
  "module_name": "ps.c",
  "hash_id": "046aad6340047142c14353f8738c9a4d010bc8acfdc4bf4dc8369af1d9d5627b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtw89/ps.c",
  "human_readable_source": "\n \n\n#include \"chan.h\"\n#include \"coex.h\"\n#include \"core.h\"\n#include \"debug.h\"\n#include \"fw.h\"\n#include \"mac.h\"\n#include \"ps.h\"\n#include \"reg.h\"\n#include \"util.h\"\n\nstatic int rtw89_fw_leave_lps_check(struct rtw89_dev *rtwdev, u8 macid)\n{\n\tu32 pwr_en_bit = 0xE;\n\tu32 chk_msk = pwr_en_bit << (4 * macid);\n\tu32 polling;\n\tint ret;\n\n\tret = read_poll_timeout_atomic(rtw89_read32_mask, polling, !polling,\n\t\t\t\t       1000, 50000, false, rtwdev,\n\t\t\t\t       R_AX_PPWRBIT_SETTING, chk_msk);\n\tif (ret) {\n\t\trtw89_info(rtwdev, \"rtw89: failed to leave lps state\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic void rtw89_ps_power_mode_change_with_hci(struct rtw89_dev *rtwdev,\n\t\t\t\t\t\tbool enter)\n{\n\tieee80211_stop_queues(rtwdev->hw);\n\trtwdev->hci.paused = true;\n\tflush_work(&rtwdev->txq_work);\n\tieee80211_wake_queues(rtwdev->hw);\n\n\trtw89_hci_pause(rtwdev, true);\n\trtw89_mac_power_mode_change(rtwdev, enter);\n\trtw89_hci_switch_mode(rtwdev, enter);\n\trtw89_hci_pause(rtwdev, false);\n\n\trtwdev->hci.paused = false;\n\n\tif (!enter) {\n\t\tlocal_bh_disable();\n\t\tnapi_schedule(&rtwdev->napi);\n\t\tlocal_bh_enable();\n\t}\n}\n\nstatic void rtw89_ps_power_mode_change(struct rtw89_dev *rtwdev, bool enter)\n{\n\tif (rtwdev->chip->low_power_hci_modes & BIT(rtwdev->ps_mode))\n\t\trtw89_ps_power_mode_change_with_hci(rtwdev, enter);\n\telse\n\t\trtw89_mac_power_mode_change(rtwdev, enter);\n}\n\nvoid __rtw89_enter_ps_mode(struct rtw89_dev *rtwdev, struct rtw89_vif *rtwvif)\n{\n\tif (rtwvif->wifi_role == RTW89_WIFI_ROLE_P2P_CLIENT)\n\t\treturn;\n\n\tif (!rtwdev->ps_mode)\n\t\treturn;\n\n\tif (test_and_set_bit(RTW89_FLAG_LOW_POWER_MODE, rtwdev->flags))\n\t\treturn;\n\n\trtw89_ps_power_mode_change(rtwdev, true);\n}\n\nvoid __rtw89_leave_ps_mode(struct rtw89_dev *rtwdev)\n{\n\tif (!rtwdev->ps_mode)\n\t\treturn;\n\n\tif (test_and_clear_bit(RTW89_FLAG_LOW_POWER_MODE, rtwdev->flags))\n\t\trtw89_ps_power_mode_change(rtwdev, false);\n}\n\nstatic void __rtw89_enter_lps(struct rtw89_dev *rtwdev, u8 mac_id)\n{\n\tstruct rtw89_lps_parm lps_param = {\n\t\t.macid = mac_id,\n\t\t.psmode = RTW89_MAC_AX_PS_MODE_LEGACY,\n\t\t.lastrpwm = RTW89_LAST_RPWM_PS,\n\t};\n\n\trtw89_btc_ntfy_radio_state(rtwdev, BTC_RFCTRL_FW_CTRL);\n\trtw89_fw_h2c_lps_parm(rtwdev, &lps_param);\n}\n\nstatic void __rtw89_leave_lps(struct rtw89_dev *rtwdev, u8 mac_id)\n{\n\tstruct rtw89_lps_parm lps_param = {\n\t\t.macid = mac_id,\n\t\t.psmode = RTW89_MAC_AX_PS_MODE_ACTIVE,\n\t\t.lastrpwm = RTW89_LAST_RPWM_ACTIVE,\n\t};\n\n\trtw89_fw_h2c_lps_parm(rtwdev, &lps_param);\n\trtw89_fw_leave_lps_check(rtwdev, 0);\n\trtw89_btc_ntfy_radio_state(rtwdev, BTC_RFCTRL_WL_ON);\n}\n\nvoid rtw89_leave_ps_mode(struct rtw89_dev *rtwdev)\n{\n\tlockdep_assert_held(&rtwdev->mutex);\n\n\t__rtw89_leave_ps_mode(rtwdev);\n}\n\nvoid rtw89_enter_lps(struct rtw89_dev *rtwdev, struct rtw89_vif *rtwvif,\n\t\t     bool ps_mode)\n{\n\tlockdep_assert_held(&rtwdev->mutex);\n\n\tif (test_and_set_bit(RTW89_FLAG_LEISURE_PS, rtwdev->flags))\n\t\treturn;\n\n\t__rtw89_enter_lps(rtwdev, rtwvif->mac_id);\n\tif (ps_mode)\n\t\t__rtw89_enter_ps_mode(rtwdev, rtwvif);\n}\n\nstatic void rtw89_leave_lps_vif(struct rtw89_dev *rtwdev, struct rtw89_vif *rtwvif)\n{\n\tif (rtwvif->wifi_role != RTW89_WIFI_ROLE_STATION &&\n\t    rtwvif->wifi_role != RTW89_WIFI_ROLE_P2P_CLIENT)\n\t\treturn;\n\n\t__rtw89_leave_lps(rtwdev, rtwvif->mac_id);\n}\n\nvoid rtw89_leave_lps(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_vif *rtwvif;\n\n\tlockdep_assert_held(&rtwdev->mutex);\n\n\tif (!test_and_clear_bit(RTW89_FLAG_LEISURE_PS, rtwdev->flags))\n\t\treturn;\n\n\t__rtw89_leave_ps_mode(rtwdev);\n\n\trtw89_for_each_rtwvif(rtwdev, rtwvif)\n\t\trtw89_leave_lps_vif(rtwdev, rtwvif);\n}\n\nvoid rtw89_enter_ips(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_vif *rtwvif;\n\n\tset_bit(RTW89_FLAG_INACTIVE_PS, rtwdev->flags);\n\n\tif (!test_bit(RTW89_FLAG_POWERON, rtwdev->flags))\n\t\treturn;\n\n\trtw89_for_each_rtwvif(rtwdev, rtwvif)\n\t\trtw89_mac_vif_deinit(rtwdev, rtwvif);\n\n\trtw89_core_stop(rtwdev);\n}\n\nvoid rtw89_leave_ips(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_vif *rtwvif;\n\tint ret;\n\n\tif (test_bit(RTW89_FLAG_POWERON, rtwdev->flags))\n\t\treturn;\n\n\tret = rtw89_core_start(rtwdev);\n\tif (ret)\n\t\trtw89_err(rtwdev, \"failed to leave idle state\\n\");\n\n\trtw89_set_channel(rtwdev);\n\n\trtw89_for_each_rtwvif(rtwdev, rtwvif)\n\t\trtw89_mac_vif_init(rtwdev, rtwvif);\n\n\tclear_bit(RTW89_FLAG_INACTIVE_PS, rtwdev->flags);\n}\n\nvoid rtw89_set_coex_ctrl_lps(struct rtw89_dev *rtwdev, bool btc_ctrl)\n{\n\tif (btc_ctrl)\n\t\trtw89_leave_lps(rtwdev);\n}\n\nstatic void rtw89_tsf32_toggle(struct rtw89_dev *rtwdev, struct rtw89_vif *rtwvif,\n\t\t\t       enum rtw89_p2pps_action act)\n{\n\tif (act == RTW89_P2P_ACT_UPDATE || act == RTW89_P2P_ACT_REMOVE)\n\t\treturn;\n\n\tif (act == RTW89_P2P_ACT_INIT)\n\t\trtw89_fw_h2c_tsf32_toggle(rtwdev, rtwvif, true);\n\telse if (act == RTW89_P2P_ACT_TERMINATE)\n\t\trtw89_fw_h2c_tsf32_toggle(rtwdev, rtwvif, false);\n}\n\nstatic void rtw89_p2p_disable_all_noa(struct rtw89_dev *rtwdev,\n\t\t\t\t      struct ieee80211_vif *vif)\n{\n\tstruct rtw89_vif *rtwvif = (struct rtw89_vif *)vif->drv_priv;\n\tenum rtw89_p2pps_action act;\n\tu8 noa_id;\n\n\tif (rtwvif->last_noa_nr == 0)\n\t\treturn;\n\n\tfor (noa_id = 0; noa_id < rtwvif->last_noa_nr; noa_id++) {\n\t\tif (noa_id == rtwvif->last_noa_nr - 1)\n\t\t\tact = RTW89_P2P_ACT_TERMINATE;\n\t\telse\n\t\t\tact = RTW89_P2P_ACT_REMOVE;\n\t\trtw89_tsf32_toggle(rtwdev, rtwvif, act);\n\t\trtw89_fw_h2c_p2p_act(rtwdev, vif, NULL, act, noa_id);\n\t}\n}\n\nstatic void rtw89_p2p_update_noa(struct rtw89_dev *rtwdev,\n\t\t\t\t struct ieee80211_vif *vif)\n{\n\tstruct rtw89_vif *rtwvif = (struct rtw89_vif *)vif->drv_priv;\n\tstruct ieee80211_p2p_noa_desc *desc;\n\tenum rtw89_p2pps_action act;\n\tu8 noa_id;\n\n\tfor (noa_id = 0; noa_id < RTW89_P2P_MAX_NOA_NUM; noa_id++) {\n\t\tdesc = &vif->bss_conf.p2p_noa_attr.desc[noa_id];\n\t\tif (!desc->count || !desc->duration)\n\t\t\tbreak;\n\n\t\tif (noa_id == 0)\n\t\t\tact = RTW89_P2P_ACT_INIT;\n\t\telse\n\t\t\tact = RTW89_P2P_ACT_UPDATE;\n\t\trtw89_tsf32_toggle(rtwdev, rtwvif, act);\n\t\trtw89_fw_h2c_p2p_act(rtwdev, vif, desc, act, noa_id);\n\t}\n\trtwvif->last_noa_nr = noa_id;\n}\n\nvoid rtw89_process_p2p_ps(struct rtw89_dev *rtwdev, struct ieee80211_vif *vif)\n{\n\trtw89_p2p_disable_all_noa(rtwdev, vif);\n\trtw89_p2p_update_noa(rtwdev, vif);\n}\n\nvoid rtw89_recalc_lps(struct rtw89_dev *rtwdev)\n{\n\tstruct ieee80211_vif *vif, *found_vif = NULL;\n\tstruct rtw89_vif *rtwvif;\n\tenum rtw89_entity_mode mode;\n\tint count = 0;\n\n\tmode = rtw89_get_entity_mode(rtwdev);\n\tif (mode == RTW89_ENTITY_MODE_MCC)\n\t\tgoto disable_lps;\n\n\trtw89_for_each_rtwvif(rtwdev, rtwvif) {\n\t\tvif = rtwvif_to_vif(rtwvif);\n\n\t\tif (vif->type != NL80211_IFTYPE_STATION) {\n\t\t\tcount = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tcount++;\n\t\tfound_vif = vif;\n\t}\n\n\tif (count == 1 && found_vif->cfg.ps) {\n\t\trtwdev->lps_enabled = true;\n\t\treturn;\n\t}\n\ndisable_lps:\n\trtw89_leave_lps(rtwdev);\n\trtwdev->lps_enabled = false;\n}\n\nvoid rtw89_p2p_noa_renew(struct rtw89_vif *rtwvif)\n{\n\tstruct rtw89_p2p_noa_setter *setter = &rtwvif->p2p_noa;\n\tstruct rtw89_p2p_noa_ie *ie = &setter->ie;\n\tstruct rtw89_p2p_ie_head *p2p_head = &ie->p2p_head;\n\tstruct rtw89_noa_attr_head *noa_head = &ie->noa_head;\n\n\tif (setter->noa_count) {\n\t\tsetter->noa_index++;\n\t\tsetter->noa_count = 0;\n\t}\n\n\tmemset(ie, 0, sizeof(*ie));\n\n\tp2p_head->eid = WLAN_EID_VENDOR_SPECIFIC;\n\tp2p_head->ie_len = 4 + sizeof(*noa_head);\n\tp2p_head->oui[0] = (WLAN_OUI_WFA >> 16) & 0xff;\n\tp2p_head->oui[1] = (WLAN_OUI_WFA >> 8) & 0xff;\n\tp2p_head->oui[2] = (WLAN_OUI_WFA >> 0) & 0xff;\n\tp2p_head->oui_type = WLAN_OUI_TYPE_WFA_P2P;\n\n\tnoa_head->attr_type = IEEE80211_P2P_ATTR_ABSENCE_NOTICE;\n\tnoa_head->attr_len = cpu_to_le16(2);\n\tnoa_head->index = setter->noa_index;\n\tnoa_head->oppps_ctwindow = 0;\n}\n\nvoid rtw89_p2p_noa_append(struct rtw89_vif *rtwvif,\n\t\t\t  const struct ieee80211_p2p_noa_desc *desc)\n{\n\tstruct rtw89_p2p_noa_setter *setter = &rtwvif->p2p_noa;\n\tstruct rtw89_p2p_noa_ie *ie = &setter->ie;\n\tstruct rtw89_p2p_ie_head *p2p_head = &ie->p2p_head;\n\tstruct rtw89_noa_attr_head *noa_head = &ie->noa_head;\n\n\tif (!desc->count || !desc->duration)\n\t\treturn;\n\n\tif (setter->noa_count >= RTW89_P2P_MAX_NOA_NUM)\n\t\treturn;\n\n\tp2p_head->ie_len += sizeof(*desc);\n\tle16_add_cpu(&noa_head->attr_len, sizeof(*desc));\n\n\tie->noa_desc[setter->noa_count++] = *desc;\n}\n\nu8 rtw89_p2p_noa_fetch(struct rtw89_vif *rtwvif, void **data)\n{\n\tstruct rtw89_p2p_noa_setter *setter = &rtwvif->p2p_noa;\n\tstruct rtw89_p2p_noa_ie *ie = &setter->ie;\n\tvoid *tail;\n\n\tif (!setter->noa_count)\n\t\treturn 0;\n\n\t*data = ie;\n\ttail = ie->noa_desc + setter->noa_count;\n\treturn tail - *data;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}