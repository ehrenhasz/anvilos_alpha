{
  "module_name": "mac80211.c",
  "hash_id": "5d029ff49d2814c84c7895ad388555d63481bdab50e91b2c59d60c81f2541f53",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtw89/mac80211.c",
  "human_readable_source": "\n \n\n#include \"cam.h\"\n#include \"chan.h\"\n#include \"coex.h\"\n#include \"debug.h\"\n#include \"fw.h\"\n#include \"mac.h\"\n#include \"phy.h\"\n#include \"ps.h\"\n#include \"reg.h\"\n#include \"sar.h\"\n#include \"ser.h\"\n#include \"util.h\"\n#include \"wow.h\"\n\nstatic void rtw89_ops_tx(struct ieee80211_hw *hw,\n\t\t\t struct ieee80211_tx_control *control,\n\t\t\t struct sk_buff *skb)\n{\n\tstruct rtw89_dev *rtwdev = hw->priv;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_vif *vif = info->control.vif;\n\tstruct rtw89_vif *rtwvif = (struct rtw89_vif *)vif->drv_priv;\n\tstruct ieee80211_sta *sta = control->sta;\n\tu32 flags = IEEE80211_SKB_CB(skb)->flags;\n\tint ret, qsel;\n\n\tif (rtwvif->offchan && !(flags & IEEE80211_TX_CTL_TX_OFFCHAN) && sta) {\n\t\tstruct rtw89_sta *rtwsta = (struct rtw89_sta *)sta->drv_priv;\n\n\t\trtw89_debug(rtwdev, RTW89_DBG_TXRX, \"ops_tx during offchan\\n\");\n\t\tskb_queue_tail(&rtwsta->roc_queue, skb);\n\t\treturn;\n\t}\n\n\tret = rtw89_core_tx_write(rtwdev, vif, sta, skb, &qsel);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to transmit skb: %d\\n\", ret);\n\t\tieee80211_free_txskb(hw, skb);\n\t\treturn;\n\t}\n\trtw89_core_tx_kick_off(rtwdev, qsel);\n}\n\nstatic void rtw89_ops_wake_tx_queue(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_txq *txq)\n{\n\tstruct rtw89_dev *rtwdev = hw->priv;\n\n\tieee80211_schedule_txq(hw, txq);\n\tqueue_work(rtwdev->txq_wq, &rtwdev->txq_work);\n}\n\nstatic int rtw89_ops_start(struct ieee80211_hw *hw)\n{\n\tstruct rtw89_dev *rtwdev = hw->priv;\n\tint ret;\n\n\tmutex_lock(&rtwdev->mutex);\n\tret = rtw89_core_start(rtwdev);\n\tmutex_unlock(&rtwdev->mutex);\n\n\treturn ret;\n}\n\nstatic void rtw89_ops_stop(struct ieee80211_hw *hw)\n{\n\tstruct rtw89_dev *rtwdev = hw->priv;\n\n\tmutex_lock(&rtwdev->mutex);\n\trtw89_core_stop(rtwdev);\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nstatic int rtw89_ops_config(struct ieee80211_hw *hw, u32 changed)\n{\n\tstruct rtw89_dev *rtwdev = hw->priv;\n\n\t \n\tcancel_work_sync(&rtwdev->ips_work);\n\n\tmutex_lock(&rtwdev->mutex);\n\trtw89_leave_ps_mode(rtwdev);\n\n\tif ((changed & IEEE80211_CONF_CHANGE_IDLE) &&\n\t    !(hw->conf.flags & IEEE80211_CONF_IDLE))\n\t\trtw89_leave_ips(rtwdev);\n\n\tif (changed & IEEE80211_CONF_CHANGE_CHANNEL) {\n\t\trtw89_config_entity_chandef(rtwdev, RTW89_SUB_ENTITY_0,\n\t\t\t\t\t    &hw->conf.chandef);\n\t\trtw89_set_channel(rtwdev);\n\t}\n\n\tif ((changed & IEEE80211_CONF_CHANGE_IDLE) &&\n\t    (hw->conf.flags & IEEE80211_CONF_IDLE) &&\n\t    !rtwdev->scanning)\n\t\trtw89_enter_ips(rtwdev);\n\n\tmutex_unlock(&rtwdev->mutex);\n\n\treturn 0;\n}\n\nstatic int rtw89_ops_add_interface(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tstruct rtw89_dev *rtwdev = hw->priv;\n\tstruct rtw89_vif *rtwvif = (struct rtw89_vif *)vif->drv_priv;\n\tint ret = 0;\n\n\trtw89_debug(rtwdev, RTW89_DBG_STATE, \"add vif %pM type %d, p2p %d\\n\",\n\t\t    vif->addr, vif->type, vif->p2p);\n\n\tmutex_lock(&rtwdev->mutex);\n\n\trtw89_leave_ips_by_hwflags(rtwdev);\n\n\tif (RTW89_CHK_FW_FEATURE(BEACON_FILTER, &rtwdev->fw))\n\t\tvif->driver_flags |= IEEE80211_VIF_BEACON_FILTER |\n\t\t\t\t     IEEE80211_VIF_SUPPORTS_CQM_RSSI;\n\n\trtwvif->rtwdev = rtwdev;\n\trtwvif->roc.state = RTW89_ROC_IDLE;\n\trtwvif->offchan = false;\n\tlist_add_tail(&rtwvif->list, &rtwdev->rtwvifs_list);\n\tINIT_WORK(&rtwvif->update_beacon_work, rtw89_core_update_beacon_work);\n\tINIT_DELAYED_WORK(&rtwvif->roc.roc_work, rtw89_roc_work);\n\trtw89_leave_ps_mode(rtwdev);\n\n\trtw89_traffic_stats_init(rtwdev, &rtwvif->stats);\n\trtw89_vif_type_mapping(vif, false);\n\trtwvif->port = rtw89_core_acquire_bit_map(rtwdev->hw_port,\n\t\t\t\t\t\t  RTW89_PORT_NUM);\n\tif (rtwvif->port == RTW89_PORT_NUM) {\n\t\tret = -ENOSPC;\n\t\tlist_del_init(&rtwvif->list);\n\t\tgoto out;\n\t}\n\n\trtwvif->bcn_hit_cond = 0;\n\trtwvif->mac_idx = RTW89_MAC_0;\n\trtwvif->phy_idx = RTW89_PHY_0;\n\trtwvif->sub_entity_idx = RTW89_SUB_ENTITY_0;\n\trtwvif->hit_rule = 0;\n\trtwvif->reg_6ghz_power = RTW89_REG_6GHZ_POWER_DFLT;\n\tether_addr_copy(rtwvif->mac_addr, vif->addr);\n\tINIT_LIST_HEAD(&rtwvif->general_pkt_list);\n\n\tret = rtw89_mac_add_vif(rtwdev, rtwvif);\n\tif (ret) {\n\t\trtw89_core_release_bit_map(rtwdev->hw_port, rtwvif->port);\n\t\tlist_del_init(&rtwvif->list);\n\t\tgoto out;\n\t}\n\n\trtw89_core_txq_init(rtwdev, vif->txq);\n\n\trtw89_btc_ntfy_role_info(rtwdev, rtwvif, NULL, BTC_ROLE_START);\n\n\trtw89_recalc_lps(rtwdev);\nout:\n\tmutex_unlock(&rtwdev->mutex);\n\n\treturn ret;\n}\n\nstatic void rtw89_ops_remove_interface(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_vif *vif)\n{\n\tstruct rtw89_dev *rtwdev = hw->priv;\n\tstruct rtw89_vif *rtwvif = (struct rtw89_vif *)vif->drv_priv;\n\n\trtw89_debug(rtwdev, RTW89_DBG_STATE, \"remove vif %pM type %d p2p %d\\n\",\n\t\t    vif->addr, vif->type, vif->p2p);\n\n\tcancel_work_sync(&rtwvif->update_beacon_work);\n\tcancel_delayed_work_sync(&rtwvif->roc.roc_work);\n\n\tmutex_lock(&rtwdev->mutex);\n\trtw89_leave_ps_mode(rtwdev);\n\trtw89_btc_ntfy_role_info(rtwdev, rtwvif, NULL, BTC_ROLE_STOP);\n\trtw89_mac_remove_vif(rtwdev, rtwvif);\n\trtw89_core_release_bit_map(rtwdev->hw_port, rtwvif->port);\n\tlist_del_init(&rtwvif->list);\n\trtw89_recalc_lps(rtwdev);\n\trtw89_enter_ips_by_hwflags(rtwdev);\n\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nstatic int rtw89_ops_change_interface(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      enum nl80211_iftype type, bool p2p)\n{\n\tstruct rtw89_dev *rtwdev = hw->priv;\n\tint ret;\n\n\tset_bit(RTW89_FLAG_CHANGING_INTERFACE, rtwdev->flags);\n\n\trtw89_debug(rtwdev, RTW89_DBG_STATE, \"change vif %pM (%d)->(%d), p2p (%d)->(%d)\\n\",\n\t\t    vif->addr, vif->type, type, vif->p2p, p2p);\n\n\trtw89_ops_remove_interface(hw, vif);\n\n\tvif->type = type;\n\tvif->p2p = p2p;\n\n\tret = rtw89_ops_add_interface(hw, vif);\n\tif (ret)\n\t\trtw89_warn(rtwdev, \"failed to change interface %d\\n\", ret);\n\n\tclear_bit(RTW89_FLAG_CHANGING_INTERFACE, rtwdev->flags);\n\n\treturn ret;\n}\n\nstatic void rtw89_ops_configure_filter(struct ieee80211_hw *hw,\n\t\t\t\t       unsigned int changed_flags,\n\t\t\t\t       unsigned int *new_flags,\n\t\t\t\t       u64 multicast)\n{\n\tstruct rtw89_dev *rtwdev = hw->priv;\n\tconst struct rtw89_mac_gen_def *mac = rtwdev->chip->mac_def;\n\n\tmutex_lock(&rtwdev->mutex);\n\trtw89_leave_ps_mode(rtwdev);\n\n\t*new_flags &= FIF_ALLMULTI | FIF_OTHER_BSS | FIF_FCSFAIL |\n\t\t      FIF_BCN_PRBRESP_PROMISC | FIF_PROBE_REQ;\n\n\tif (changed_flags & FIF_ALLMULTI) {\n\t\tif (*new_flags & FIF_ALLMULTI)\n\t\t\trtwdev->hal.rx_fltr &= ~B_AX_A_MC;\n\t\telse\n\t\t\trtwdev->hal.rx_fltr |= B_AX_A_MC;\n\t}\n\tif (changed_flags & FIF_FCSFAIL) {\n\t\tif (*new_flags & FIF_FCSFAIL)\n\t\t\trtwdev->hal.rx_fltr |= B_AX_A_CRC32_ERR;\n\t\telse\n\t\t\trtwdev->hal.rx_fltr &= ~B_AX_A_CRC32_ERR;\n\t}\n\tif (changed_flags & FIF_OTHER_BSS) {\n\t\tif (*new_flags & FIF_OTHER_BSS)\n\t\t\trtwdev->hal.rx_fltr &= ~B_AX_A_A1_MATCH;\n\t\telse\n\t\t\trtwdev->hal.rx_fltr |= B_AX_A_A1_MATCH;\n\t}\n\tif (changed_flags & FIF_BCN_PRBRESP_PROMISC) {\n\t\tif (*new_flags & FIF_BCN_PRBRESP_PROMISC) {\n\t\t\trtwdev->hal.rx_fltr &= ~B_AX_A_BCN_CHK_EN;\n\t\t\trtwdev->hal.rx_fltr &= ~B_AX_A_BC;\n\t\t\trtwdev->hal.rx_fltr &= ~B_AX_A_A1_MATCH;\n\t\t} else {\n\t\t\trtwdev->hal.rx_fltr |= B_AX_A_BCN_CHK_EN;\n\t\t\trtwdev->hal.rx_fltr |= B_AX_A_BC;\n\t\t\trtwdev->hal.rx_fltr |= B_AX_A_A1_MATCH;\n\t\t}\n\t}\n\tif (changed_flags & FIF_PROBE_REQ) {\n\t\tif (*new_flags & FIF_PROBE_REQ) {\n\t\t\trtwdev->hal.rx_fltr &= ~B_AX_A_BC_CAM_MATCH;\n\t\t\trtwdev->hal.rx_fltr &= ~B_AX_A_UC_CAM_MATCH;\n\t\t} else {\n\t\t\trtwdev->hal.rx_fltr |= B_AX_A_BC_CAM_MATCH;\n\t\t\trtwdev->hal.rx_fltr |= B_AX_A_UC_CAM_MATCH;\n\t\t}\n\t}\n\n\trtw89_write32_mask(rtwdev,\n\t\t\t   rtw89_mac_reg_by_idx(rtwdev, mac->rx_fltr, RTW89_MAC_0),\n\t\t\t   B_AX_RX_FLTR_CFG_MASK,\n\t\t\t   rtwdev->hal.rx_fltr);\n\tif (!rtwdev->dbcc_en)\n\t\tgoto out;\n\trtw89_write32_mask(rtwdev,\n\t\t\t   rtw89_mac_reg_by_idx(rtwdev, mac->rx_fltr, RTW89_MAC_1),\n\t\t\t   B_AX_RX_FLTR_CFG_MASK,\n\t\t\t   rtwdev->hal.rx_fltr);\n\nout:\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nstatic const u8 ac_to_fw_idx[IEEE80211_NUM_ACS] = {\n\t[IEEE80211_AC_VO] = 3,\n\t[IEEE80211_AC_VI] = 2,\n\t[IEEE80211_AC_BE] = 0,\n\t[IEEE80211_AC_BK] = 1,\n};\n\nstatic u8 rtw89_aifsn_to_aifs(struct rtw89_dev *rtwdev,\n\t\t\t      struct rtw89_vif *rtwvif, u8 aifsn)\n{\n\tstruct ieee80211_vif *vif = rtwvif_to_vif(rtwvif);\n\tconst struct rtw89_chan *chan = rtw89_chan_get(rtwdev,\n\t\t\t\t\t\t       rtwvif->sub_entity_idx);\n\tu8 slot_time;\n\tu8 sifs;\n\n\tslot_time = vif->bss_conf.use_short_slot ? 9 : 20;\n\tsifs = chan->band_type == RTW89_BAND_5G ? 16 : 10;\n\n\treturn aifsn * slot_time + sifs;\n}\n\nstatic void ____rtw89_conf_tx_edca(struct rtw89_dev *rtwdev,\n\t\t\t\t   struct rtw89_vif *rtwvif, u16 ac)\n{\n\tstruct ieee80211_tx_queue_params *params = &rtwvif->tx_params[ac];\n\tu32 val;\n\tu8 ecw_max, ecw_min;\n\tu8 aifs;\n\n\t \n\tecw_max = ilog2(params->cw_max + 1);\n\tecw_min = ilog2(params->cw_min + 1);\n\taifs = rtw89_aifsn_to_aifs(rtwdev, rtwvif, params->aifs);\n\tval = FIELD_PREP(FW_EDCA_PARAM_TXOPLMT_MSK, params->txop) |\n\t      FIELD_PREP(FW_EDCA_PARAM_CWMAX_MSK, ecw_max) |\n\t      FIELD_PREP(FW_EDCA_PARAM_CWMIN_MSK, ecw_min) |\n\t      FIELD_PREP(FW_EDCA_PARAM_AIFS_MSK, aifs);\n\trtw89_fw_h2c_set_edca(rtwdev, rtwvif, ac_to_fw_idx[ac], val);\n}\n\nstatic const u32 ac_to_mu_edca_param[IEEE80211_NUM_ACS] = {\n\t[IEEE80211_AC_VO] = R_AX_MUEDCA_VO_PARAM_0,\n\t[IEEE80211_AC_VI] = R_AX_MUEDCA_VI_PARAM_0,\n\t[IEEE80211_AC_BE] = R_AX_MUEDCA_BE_PARAM_0,\n\t[IEEE80211_AC_BK] = R_AX_MUEDCA_BK_PARAM_0,\n};\n\nstatic void ____rtw89_conf_tx_mu_edca(struct rtw89_dev *rtwdev,\n\t\t\t\t      struct rtw89_vif *rtwvif, u16 ac)\n{\n\tstruct ieee80211_tx_queue_params *params = &rtwvif->tx_params[ac];\n\tstruct ieee80211_he_mu_edca_param_ac_rec *mu_edca;\n\tu8 aifs, aifsn;\n\tu16 timer_32us;\n\tu32 reg;\n\tu32 val;\n\n\tif (!params->mu_edca)\n\t\treturn;\n\n\tmu_edca = &params->mu_edca_param_rec;\n\taifsn = FIELD_GET(GENMASK(3, 0), mu_edca->aifsn);\n\taifs = aifsn ? rtw89_aifsn_to_aifs(rtwdev, rtwvif, aifsn) : 0;\n\ttimer_32us = mu_edca->mu_edca_timer << 8;\n\n\tval = FIELD_PREP(B_AX_MUEDCA_BE_PARAM_0_TIMER_MASK, timer_32us) |\n\t      FIELD_PREP(B_AX_MUEDCA_BE_PARAM_0_CW_MASK, mu_edca->ecw_min_max) |\n\t      FIELD_PREP(B_AX_MUEDCA_BE_PARAM_0_AIFS_MASK, aifs);\n\treg = rtw89_mac_reg_by_idx(rtwdev, ac_to_mu_edca_param[ac], rtwvif->mac_idx);\n\trtw89_write32(rtwdev, reg, val);\n\n\trtw89_mac_set_hw_muedca_ctrl(rtwdev, rtwvif, true);\n}\n\nstatic void __rtw89_conf_tx(struct rtw89_dev *rtwdev,\n\t\t\t    struct rtw89_vif *rtwvif, u16 ac)\n{\n\t____rtw89_conf_tx_edca(rtwdev, rtwvif, ac);\n\t____rtw89_conf_tx_mu_edca(rtwdev, rtwvif, ac);\n}\n\nstatic void rtw89_conf_tx(struct rtw89_dev *rtwdev,\n\t\t\t  struct rtw89_vif *rtwvif)\n{\n\tu16 ac;\n\n\tfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++)\n\t\t__rtw89_conf_tx(rtwdev, rtwvif, ac);\n}\n\nstatic void rtw89_station_mode_sta_assoc(struct rtw89_dev *rtwdev,\n\t\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t\t struct ieee80211_bss_conf *conf)\n{\n\tstruct ieee80211_sta *sta;\n\n\tif (vif->type != NL80211_IFTYPE_STATION)\n\t\treturn;\n\n\tsta = ieee80211_find_sta(vif, conf->bssid);\n\tif (!sta) {\n\t\trtw89_err(rtwdev, \"can't find sta to set sta_assoc state\\n\");\n\t\treturn;\n\t}\n\n\trtw89_vif_type_mapping(vif, true);\n\n\trtw89_core_sta_assoc(rtwdev, vif, sta);\n}\n\nstatic void rtw89_ops_bss_info_changed(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       struct ieee80211_bss_conf *conf,\n\t\t\t\t       u64 changed)\n{\n\tstruct rtw89_dev *rtwdev = hw->priv;\n\tstruct rtw89_vif *rtwvif = (struct rtw89_vif *)vif->drv_priv;\n\n\tmutex_lock(&rtwdev->mutex);\n\trtw89_leave_ps_mode(rtwdev);\n\n\tif (changed & BSS_CHANGED_ASSOC) {\n\t\tif (vif->cfg.assoc) {\n\t\t\trtw89_station_mode_sta_assoc(rtwdev, vif, conf);\n\t\t\trtw89_phy_set_bss_color(rtwdev, vif);\n\t\t\trtw89_chip_cfg_txpwr_ul_tb_offset(rtwdev, vif);\n\t\t\trtw89_mac_port_update(rtwdev, rtwvif);\n\t\t\trtw89_mac_set_he_obss_narrow_bw_ru(rtwdev, vif);\n\n\t\t\trtw89_queue_chanctx_work(rtwdev);\n\t\t} else {\n\t\t\t \n\t\t\tif (rtwdev->scanning)\n\t\t\t\trtw89_hw_scan_abort(rtwdev, vif);\n\t\t}\n\t}\n\n\tif (changed & BSS_CHANGED_BSSID) {\n\t\tether_addr_copy(rtwvif->bssid, conf->bssid);\n\t\trtw89_cam_bssid_changed(rtwdev, rtwvif);\n\t\trtw89_fw_h2c_cam(rtwdev, rtwvif, NULL, NULL);\n\t}\n\n\tif (changed & BSS_CHANGED_BEACON)\n\t\trtw89_fw_h2c_update_beacon(rtwdev, rtwvif);\n\n\tif (changed & BSS_CHANGED_ERP_SLOT)\n\t\trtw89_conf_tx(rtwdev, rtwvif);\n\n\tif (changed & BSS_CHANGED_HE_BSS_COLOR)\n\t\trtw89_phy_set_bss_color(rtwdev, vif);\n\n\tif (changed & BSS_CHANGED_MU_GROUPS)\n\t\trtw89_mac_bf_set_gid_table(rtwdev, vif, conf);\n\n\tif (changed & BSS_CHANGED_P2P_PS)\n\t\trtw89_process_p2p_ps(rtwdev, vif);\n\n\tif (changed & BSS_CHANGED_CQM)\n\t\trtw89_fw_h2c_set_bcn_fltr_cfg(rtwdev, vif, true);\n\n\tif (changed & BSS_CHANGED_PS)\n\t\trtw89_recalc_lps(rtwdev);\n\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nstatic int rtw89_ops_start_ap(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      struct ieee80211_bss_conf *link_conf)\n{\n\tstruct rtw89_dev *rtwdev = hw->priv;\n\tstruct rtw89_vif *rtwvif = (struct rtw89_vif *)vif->drv_priv;\n\tconst struct rtw89_chan *chan;\n\n\tmutex_lock(&rtwdev->mutex);\n\n\tchan = rtw89_chan_get(rtwdev, rtwvif->sub_entity_idx);\n\tif (chan->band_type == RTW89_BAND_6G) {\n\t\tmutex_unlock(&rtwdev->mutex);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tether_addr_copy(rtwvif->bssid, vif->bss_conf.bssid);\n\trtw89_cam_bssid_changed(rtwdev, rtwvif);\n\trtw89_mac_port_update(rtwdev, rtwvif);\n\trtw89_fw_h2c_assoc_cmac_tbl(rtwdev, vif, NULL);\n\trtw89_fw_h2c_role_maintain(rtwdev, rtwvif, NULL, RTW89_ROLE_TYPE_CHANGE);\n\trtw89_fw_h2c_join_info(rtwdev, rtwvif, NULL, true);\n\trtw89_fw_h2c_cam(rtwdev, rtwvif, NULL, NULL);\n\trtw89_chip_rfk_channel(rtwdev);\n\n\trtw89_queue_chanctx_work(rtwdev);\n\tmutex_unlock(&rtwdev->mutex);\n\n\treturn 0;\n}\n\nstatic\nvoid rtw89_ops_stop_ap(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t       struct ieee80211_bss_conf *link_conf)\n{\n\tstruct rtw89_dev *rtwdev = hw->priv;\n\tstruct rtw89_vif *rtwvif = (struct rtw89_vif *)vif->drv_priv;\n\n\tmutex_lock(&rtwdev->mutex);\n\trtw89_mac_stop_ap(rtwdev, rtwvif);\n\trtw89_fw_h2c_assoc_cmac_tbl(rtwdev, vif, NULL);\n\trtw89_fw_h2c_join_info(rtwdev, rtwvif, NULL, true);\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nstatic int rtw89_ops_set_tim(struct ieee80211_hw *hw, struct ieee80211_sta *sta,\n\t\t\t     bool set)\n{\n\tstruct rtw89_dev *rtwdev = hw->priv;\n\tstruct rtw89_sta *rtwsta = (struct rtw89_sta *)sta->drv_priv;\n\tstruct rtw89_vif *rtwvif = rtwsta->rtwvif;\n\n\tieee80211_queue_work(rtwdev->hw, &rtwvif->update_beacon_work);\n\n\treturn 0;\n}\n\nstatic int rtw89_ops_conf_tx(struct ieee80211_hw *hw,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     unsigned int link_id, u16 ac,\n\t\t\t     const struct ieee80211_tx_queue_params *params)\n{\n\tstruct rtw89_dev *rtwdev = hw->priv;\n\tstruct rtw89_vif *rtwvif = (struct rtw89_vif *)vif->drv_priv;\n\n\tmutex_lock(&rtwdev->mutex);\n\trtw89_leave_ps_mode(rtwdev);\n\trtwvif->tx_params[ac] = *params;\n\t__rtw89_conf_tx(rtwdev, rtwvif, ac);\n\tmutex_unlock(&rtwdev->mutex);\n\n\treturn 0;\n}\n\nstatic int __rtw89_ops_sta_state(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct ieee80211_sta *sta,\n\t\t\t\t enum ieee80211_sta_state old_state,\n\t\t\t\t enum ieee80211_sta_state new_state)\n{\n\tstruct rtw89_dev *rtwdev = hw->priv;\n\n\tif (old_state == IEEE80211_STA_NOTEXIST &&\n\t    new_state == IEEE80211_STA_NONE)\n\t\treturn rtw89_core_sta_add(rtwdev, vif, sta);\n\n\tif (old_state == IEEE80211_STA_AUTH &&\n\t    new_state == IEEE80211_STA_ASSOC) {\n\t\tif (vif->type == NL80211_IFTYPE_STATION && !sta->tdls)\n\t\t\treturn 0;  \n\t\treturn rtw89_core_sta_assoc(rtwdev, vif, sta);\n\t}\n\n\tif (old_state == IEEE80211_STA_ASSOC &&\n\t    new_state == IEEE80211_STA_AUTH)\n\t\treturn rtw89_core_sta_disassoc(rtwdev, vif, sta);\n\n\tif (old_state == IEEE80211_STA_AUTH &&\n\t    new_state == IEEE80211_STA_NONE)\n\t\treturn rtw89_core_sta_disconnect(rtwdev, vif, sta);\n\n\tif (old_state == IEEE80211_STA_NONE &&\n\t    new_state == IEEE80211_STA_NOTEXIST)\n\t\treturn rtw89_core_sta_remove(rtwdev, vif, sta);\n\n\treturn 0;\n}\n\nstatic int rtw89_ops_sta_state(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       struct ieee80211_sta *sta,\n\t\t\t       enum ieee80211_sta_state old_state,\n\t\t\t       enum ieee80211_sta_state new_state)\n{\n\tstruct rtw89_dev *rtwdev = hw->priv;\n\tint ret;\n\n\tmutex_lock(&rtwdev->mutex);\n\trtw89_leave_ps_mode(rtwdev);\n\tret = __rtw89_ops_sta_state(hw, vif, sta, old_state, new_state);\n\tmutex_unlock(&rtwdev->mutex);\n\n\treturn ret;\n}\n\nstatic int rtw89_ops_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     struct ieee80211_sta *sta,\n\t\t\t     struct ieee80211_key_conf *key)\n{\n\tstruct rtw89_dev *rtwdev = hw->priv;\n\tint ret = 0;\n\n\tmutex_lock(&rtwdev->mutex);\n\trtw89_leave_ps_mode(rtwdev);\n\n\tswitch (cmd) {\n\tcase SET_KEY:\n\t\trtw89_btc_ntfy_specific_packet(rtwdev, PACKET_EAPOL_END);\n\t\tret = rtw89_cam_sec_key_add(rtwdev, vif, sta, key);\n\t\tif (ret && ret != -EOPNOTSUPP) {\n\t\t\trtw89_err(rtwdev, \"failed to add key to sec cam\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase DISABLE_KEY:\n\t\trtw89_hci_flush_queues(rtwdev, BIT(rtwdev->hw->queues) - 1,\n\t\t\t\t       false);\n\t\trtw89_mac_flush_txq(rtwdev, BIT(rtwdev->hw->queues) - 1, false);\n\t\tret = rtw89_cam_sec_key_del(rtwdev, vif, sta, key, true);\n\t\tif (ret) {\n\t\t\trtw89_err(rtwdev, \"failed to remove key from sec cam\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\t}\n\nout:\n\tmutex_unlock(&rtwdev->mutex);\n\n\treturn ret;\n}\n\nstatic int rtw89_ops_ampdu_action(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  struct ieee80211_ampdu_params *params)\n{\n\tstruct rtw89_dev *rtwdev = hw->priv;\n\tstruct ieee80211_sta *sta = params->sta;\n\tstruct rtw89_sta *rtwsta = (struct rtw89_sta *)sta->drv_priv;\n\tu16 tid = params->tid;\n\tstruct ieee80211_txq *txq = sta->txq[tid];\n\tstruct rtw89_txq *rtwtxq = (struct rtw89_txq *)txq->drv_priv;\n\n\tswitch (params->action) {\n\tcase IEEE80211_AMPDU_TX_START:\n\t\treturn IEEE80211_AMPDU_TX_START_IMMEDIATE;\n\tcase IEEE80211_AMPDU_TX_STOP_CONT:\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH:\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH_CONT:\n\t\tmutex_lock(&rtwdev->mutex);\n\t\tclear_bit(RTW89_TXQ_F_AMPDU, &rtwtxq->flags);\n\t\tmutex_unlock(&rtwdev->mutex);\n\t\tieee80211_stop_tx_ba_cb_irqsafe(vif, sta->addr, tid);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_OPERATIONAL:\n\t\tmutex_lock(&rtwdev->mutex);\n\t\tset_bit(RTW89_TXQ_F_AMPDU, &rtwtxq->flags);\n\t\trtwsta->ampdu_params[tid].agg_num = params->buf_size;\n\t\trtwsta->ampdu_params[tid].amsdu = params->amsdu;\n\t\trtw89_leave_ps_mode(rtwdev);\n\t\tmutex_unlock(&rtwdev->mutex);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_RX_START:\n\t\tmutex_lock(&rtwdev->mutex);\n\t\trtw89_fw_h2c_ba_cam(rtwdev, rtwsta, true, params);\n\t\tmutex_unlock(&rtwdev->mutex);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_RX_STOP:\n\t\tmutex_lock(&rtwdev->mutex);\n\t\trtw89_fw_h2c_ba_cam(rtwdev, rtwsta, false, params);\n\t\tmutex_unlock(&rtwdev->mutex);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int rtw89_ops_set_rts_threshold(struct ieee80211_hw *hw, u32 value)\n{\n\tstruct rtw89_dev *rtwdev = hw->priv;\n\n\tmutex_lock(&rtwdev->mutex);\n\trtw89_leave_ps_mode(rtwdev);\n\tif (test_bit(RTW89_FLAG_POWERON, rtwdev->flags))\n\t\trtw89_mac_update_rts_threshold(rtwdev, RTW89_MAC_0);\n\tmutex_unlock(&rtwdev->mutex);\n\n\treturn 0;\n}\n\nstatic void rtw89_ops_sta_statistics(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t     struct ieee80211_sta *sta,\n\t\t\t\t     struct station_info *sinfo)\n{\n\tstruct rtw89_sta *rtwsta = (struct rtw89_sta *)sta->drv_priv;\n\n\tsinfo->txrate = rtwsta->ra_report.txrate;\n\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_BITRATE);\n}\n\nstatic\nvoid __rtw89_drop_packets(struct rtw89_dev *rtwdev, struct ieee80211_vif *vif)\n{\n\tstruct rtw89_vif *rtwvif;\n\n\tif (vif) {\n\t\trtwvif = (struct rtw89_vif *)vif->drv_priv;\n\t\trtw89_mac_pkt_drop_vif(rtwdev, rtwvif);\n\t} else {\n\t\trtw89_for_each_rtwvif(rtwdev, rtwvif)\n\t\t\trtw89_mac_pkt_drop_vif(rtwdev, rtwvif);\n\t}\n}\n\nstatic void rtw89_ops_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t    u32 queues, bool drop)\n{\n\tstruct rtw89_dev *rtwdev = hw->priv;\n\n\tmutex_lock(&rtwdev->mutex);\n\trtw89_leave_lps(rtwdev);\n\trtw89_hci_flush_queues(rtwdev, queues, drop);\n\n\tif (drop && !RTW89_CHK_FW_FEATURE(NO_PACKET_DROP, &rtwdev->fw))\n\t\t__rtw89_drop_packets(rtwdev, vif);\n\telse\n\t\trtw89_mac_flush_txq(rtwdev, queues, drop);\n\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nstruct rtw89_iter_bitrate_mask_data {\n\tstruct rtw89_dev *rtwdev;\n\tstruct ieee80211_vif *vif;\n\tconst struct cfg80211_bitrate_mask *mask;\n};\n\nstatic void rtw89_ra_mask_info_update_iter(void *data, struct ieee80211_sta *sta)\n{\n\tstruct rtw89_iter_bitrate_mask_data *br_data = data;\n\tstruct rtw89_sta *rtwsta = (struct rtw89_sta *)sta->drv_priv;\n\tstruct ieee80211_vif *vif = rtwvif_to_vif(rtwsta->rtwvif);\n\n\tif (vif != br_data->vif || vif->p2p)\n\t\treturn;\n\n\trtwsta->use_cfg_mask = true;\n\trtwsta->mask = *br_data->mask;\n\trtw89_phy_ra_updata_sta(br_data->rtwdev, sta, IEEE80211_RC_SUPP_RATES_CHANGED);\n}\n\nstatic void rtw89_ra_mask_info_update(struct rtw89_dev *rtwdev,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      const struct cfg80211_bitrate_mask *mask)\n{\n\tstruct rtw89_iter_bitrate_mask_data br_data = { .rtwdev = rtwdev,\n\t\t\t\t\t\t\t.vif = vif,\n\t\t\t\t\t\t\t.mask = mask};\n\n\tieee80211_iterate_stations_atomic(rtwdev->hw, rtw89_ra_mask_info_update_iter,\n\t\t\t\t\t  &br_data);\n}\n\nstatic int rtw89_ops_set_bitrate_mask(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      const struct cfg80211_bitrate_mask *mask)\n{\n\tstruct rtw89_dev *rtwdev = hw->priv;\n\n\tmutex_lock(&rtwdev->mutex);\n\trtw89_phy_rate_pattern_vif(rtwdev, vif, mask);\n\trtw89_ra_mask_info_update(rtwdev, vif, mask);\n\tmutex_unlock(&rtwdev->mutex);\n\n\treturn 0;\n}\n\nstatic\nint rtw89_ops_set_antenna(struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant)\n{\n\tstruct rtw89_dev *rtwdev = hw->priv;\n\tstruct rtw89_hal *hal = &rtwdev->hal;\n\n\tif (hal->ant_diversity) {\n\t\tif (tx_ant != rx_ant || hweight32(tx_ant) != 1)\n\t\t\treturn -EINVAL;\n\t} else if (rx_ant != hw->wiphy->available_antennas_rx && rx_ant != hal->antenna_rx) {\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&rtwdev->mutex);\n\thal->antenna_tx = tx_ant;\n\thal->antenna_rx = rx_ant;\n\thal->tx_path_diversity = false;\n\thal->ant_diversity_fixed = true;\n\tmutex_unlock(&rtwdev->mutex);\n\n\treturn 0;\n}\n\nstatic\nint rtw89_ops_get_antenna(struct ieee80211_hw *hw,  u32 *tx_ant, u32 *rx_ant)\n{\n\tstruct rtw89_dev *rtwdev = hw->priv;\n\tstruct rtw89_hal *hal = &rtwdev->hal;\n\n\t*tx_ant = hal->antenna_tx;\n\t*rx_ant = hal->antenna_rx;\n\n\treturn 0;\n}\n\nstatic void rtw89_ops_sw_scan_start(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    const u8 *mac_addr)\n{\n\tstruct rtw89_dev *rtwdev = hw->priv;\n\tstruct rtw89_vif *rtwvif = (struct rtw89_vif *)vif->drv_priv;\n\n\tmutex_lock(&rtwdev->mutex);\n\trtw89_core_scan_start(rtwdev, rtwvif, mac_addr, false);\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nstatic void rtw89_ops_sw_scan_complete(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_vif *vif)\n{\n\tstruct rtw89_dev *rtwdev = hw->priv;\n\n\tmutex_lock(&rtwdev->mutex);\n\trtw89_core_scan_complete(rtwdev, vif, false);\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nstatic void rtw89_ops_reconfig_complete(struct ieee80211_hw *hw,\n\t\t\t\t\tenum ieee80211_reconfig_type reconfig_type)\n{\n\tstruct rtw89_dev *rtwdev = hw->priv;\n\n\tif (reconfig_type == IEEE80211_RECONFIG_TYPE_RESTART)\n\t\trtw89_ser_recfg_done(rtwdev);\n}\n\nstatic int rtw89_ops_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t     struct ieee80211_scan_request *req)\n{\n\tstruct rtw89_dev *rtwdev = hw->priv;\n\tstruct rtw89_vif *rtwvif = vif_to_rtwvif_safe(vif);\n\tint ret = 0;\n\n\tif (!RTW89_CHK_FW_FEATURE(SCAN_OFFLOAD, &rtwdev->fw))\n\t\treturn 1;\n\n\tif (rtwdev->scanning || rtwvif->offchan)\n\t\treturn -EBUSY;\n\n\tmutex_lock(&rtwdev->mutex);\n\trtw89_hw_scan_start(rtwdev, vif, req);\n\tret = rtw89_hw_scan_offload(rtwdev, vif, true);\n\tif (ret) {\n\t\trtw89_hw_scan_abort(rtwdev, vif);\n\t\trtw89_err(rtwdev, \"HW scan failed with status: %d\\n\", ret);\n\t}\n\tmutex_unlock(&rtwdev->mutex);\n\n\treturn ret;\n}\n\nstatic void rtw89_ops_cancel_hw_scan(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct rtw89_dev *rtwdev = hw->priv;\n\n\tif (!RTW89_CHK_FW_FEATURE(SCAN_OFFLOAD, &rtwdev->fw))\n\t\treturn;\n\n\tif (!rtwdev->scanning)\n\t\treturn;\n\n\tmutex_lock(&rtwdev->mutex);\n\trtw89_hw_scan_abort(rtwdev, vif);\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nstatic void rtw89_ops_sta_rc_update(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct ieee80211_sta *sta, u32 changed)\n{\n\tstruct rtw89_dev *rtwdev = hw->priv;\n\n\trtw89_phy_ra_updata_sta(rtwdev, sta, changed);\n}\n\nstatic int rtw89_ops_add_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_chanctx_conf *ctx)\n{\n\tstruct rtw89_dev *rtwdev = hw->priv;\n\tint ret;\n\n\tmutex_lock(&rtwdev->mutex);\n\tret = rtw89_chanctx_ops_add(rtwdev, ctx);\n\tmutex_unlock(&rtwdev->mutex);\n\n\treturn ret;\n}\n\nstatic void rtw89_ops_remove_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_chanctx_conf *ctx)\n{\n\tstruct rtw89_dev *rtwdev = hw->priv;\n\n\tmutex_lock(&rtwdev->mutex);\n\trtw89_chanctx_ops_remove(rtwdev, ctx);\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nstatic void rtw89_ops_change_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_chanctx_conf *ctx,\n\t\t\t\t     u32 changed)\n{\n\tstruct rtw89_dev *rtwdev = hw->priv;\n\n\tmutex_lock(&rtwdev->mutex);\n\trtw89_chanctx_ops_change(rtwdev, ctx, changed);\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nstatic int rtw89_ops_assign_vif_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\t\tstruct ieee80211_bss_conf *link_conf,\n\t\t\t\t\tstruct ieee80211_chanctx_conf *ctx)\n{\n\tstruct rtw89_dev *rtwdev = hw->priv;\n\tstruct rtw89_vif *rtwvif = (struct rtw89_vif *)vif->drv_priv;\n\tint ret;\n\n\tmutex_lock(&rtwdev->mutex);\n\tret = rtw89_chanctx_ops_assign_vif(rtwdev, rtwvif, ctx);\n\tmutex_unlock(&rtwdev->mutex);\n\n\treturn ret;\n}\n\nstatic void rtw89_ops_unassign_vif_chanctx(struct ieee80211_hw *hw,\n\t\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t\t   struct ieee80211_bss_conf *link_conf,\n\t\t\t\t\t   struct ieee80211_chanctx_conf *ctx)\n{\n\tstruct rtw89_dev *rtwdev = hw->priv;\n\tstruct rtw89_vif *rtwvif = (struct rtw89_vif *)vif->drv_priv;\n\n\tmutex_lock(&rtwdev->mutex);\n\trtw89_chanctx_ops_unassign_vif(rtwdev, rtwvif, ctx);\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nstatic int rtw89_ops_remain_on_channel(struct ieee80211_hw *hw,\n\t\t\t\t       struct ieee80211_vif *vif,\n\t\t\t\t       struct ieee80211_channel *chan,\n\t\t\t\t       int duration,\n\t\t\t\t       enum ieee80211_roc_type type)\n{\n\tstruct rtw89_dev *rtwdev = hw->priv;\n\tstruct rtw89_vif *rtwvif = vif_to_rtwvif_safe(vif);\n\tstruct rtw89_roc *roc = &rtwvif->roc;\n\n\tif (!vif)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&rtwdev->mutex);\n\n\tif (roc->state != RTW89_ROC_IDLE) {\n\t\tmutex_unlock(&rtwdev->mutex);\n\t\treturn -EBUSY;\n\t}\n\n\tif (rtwdev->scanning)\n\t\trtw89_hw_scan_abort(rtwdev, vif);\n\n\tif (type == IEEE80211_ROC_TYPE_MGMT_TX)\n\t\troc->state = RTW89_ROC_MGMT;\n\telse\n\t\troc->state = RTW89_ROC_NORMAL;\n\n\troc->duration = duration;\n\troc->chan = *chan;\n\troc->type = type;\n\n\trtw89_roc_start(rtwdev, rtwvif);\n\n\tmutex_unlock(&rtwdev->mutex);\n\n\treturn 0;\n}\n\nstatic int rtw89_ops_cancel_remain_on_channel(struct ieee80211_hw *hw,\n\t\t\t\t\t      struct ieee80211_vif *vif)\n{\n\tstruct rtw89_dev *rtwdev = hw->priv;\n\tstruct rtw89_vif *rtwvif = vif_to_rtwvif_safe(vif);\n\n\tif (!rtwvif)\n\t\treturn -EINVAL;\n\n\tcancel_delayed_work_sync(&rtwvif->roc.roc_work);\n\n\tmutex_lock(&rtwdev->mutex);\n\trtw89_roc_end(rtwdev, rtwvif);\n\tmutex_unlock(&rtwdev->mutex);\n\n\treturn 0;\n}\n\nstatic void rtw89_set_tid_config_iter(void *data, struct ieee80211_sta *sta)\n{\n\tstruct cfg80211_tid_config *tid_config = data;\n\tstruct rtw89_sta *rtwsta = (struct rtw89_sta *)sta->drv_priv;\n\tstruct rtw89_dev *rtwdev = rtwsta->rtwvif->rtwdev;\n\n\trtw89_core_set_tid_config(rtwdev, sta, tid_config);\n}\n\nstatic int rtw89_ops_set_tid_config(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct ieee80211_sta *sta,\n\t\t\t\t    struct cfg80211_tid_config *tid_config)\n{\n\tstruct rtw89_dev *rtwdev = hw->priv;\n\n\tmutex_lock(&rtwdev->mutex);\n\tif (sta)\n\t\trtw89_core_set_tid_config(rtwdev, sta, tid_config);\n\telse\n\t\tieee80211_iterate_stations_atomic(rtwdev->hw,\n\t\t\t\t\t\t  rtw89_set_tid_config_iter,\n\t\t\t\t\t\t  tid_config);\n\tmutex_unlock(&rtwdev->mutex);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\nstatic int rtw89_ops_suspend(struct ieee80211_hw *hw,\n\t\t\t     struct cfg80211_wowlan *wowlan)\n{\n\tstruct rtw89_dev *rtwdev = hw->priv;\n\tint ret;\n\n\tset_bit(RTW89_FLAG_FORBIDDEN_TRACK_WROK, rtwdev->flags);\n\tcancel_delayed_work_sync(&rtwdev->track_work);\n\n\tmutex_lock(&rtwdev->mutex);\n\tret = rtw89_wow_suspend(rtwdev, wowlan);\n\tmutex_unlock(&rtwdev->mutex);\n\n\tif (ret) {\n\t\trtw89_warn(rtwdev, \"failed to suspend for wow %d\\n\", ret);\n\t\tclear_bit(RTW89_FLAG_FORBIDDEN_TRACK_WROK, rtwdev->flags);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int rtw89_ops_resume(struct ieee80211_hw *hw)\n{\n\tstruct rtw89_dev *rtwdev = hw->priv;\n\tint ret;\n\n\tmutex_lock(&rtwdev->mutex);\n\tret = rtw89_wow_resume(rtwdev);\n\tif (ret)\n\t\trtw89_warn(rtwdev, \"failed to resume for wow %d\\n\", ret);\n\tmutex_unlock(&rtwdev->mutex);\n\n\tclear_bit(RTW89_FLAG_FORBIDDEN_TRACK_WROK, rtwdev->flags);\n\tieee80211_queue_delayed_work(rtwdev->hw, &rtwdev->track_work,\n\t\t\t\t     RTW89_TRACK_WORK_PERIOD);\n\n\treturn ret ? 1 : 0;\n}\n\nstatic void rtw89_ops_set_wakeup(struct ieee80211_hw *hw, bool enabled)\n{\n\tstruct rtw89_dev *rtwdev = hw->priv;\n\n\tdevice_set_wakeup_enable(rtwdev->dev, enabled);\n}\n#endif\n\nconst struct ieee80211_ops rtw89_ops = {\n\t.tx\t\t\t= rtw89_ops_tx,\n\t.wake_tx_queue\t\t= rtw89_ops_wake_tx_queue,\n\t.start\t\t\t= rtw89_ops_start,\n\t.stop\t\t\t= rtw89_ops_stop,\n\t.config\t\t\t= rtw89_ops_config,\n\t.add_interface\t\t= rtw89_ops_add_interface,\n\t.change_interface       = rtw89_ops_change_interface,\n\t.remove_interface\t= rtw89_ops_remove_interface,\n\t.configure_filter\t= rtw89_ops_configure_filter,\n\t.bss_info_changed\t= rtw89_ops_bss_info_changed,\n\t.start_ap\t\t= rtw89_ops_start_ap,\n\t.stop_ap\t\t= rtw89_ops_stop_ap,\n\t.set_tim\t\t= rtw89_ops_set_tim,\n\t.conf_tx\t\t= rtw89_ops_conf_tx,\n\t.sta_state\t\t= rtw89_ops_sta_state,\n\t.set_key\t\t= rtw89_ops_set_key,\n\t.ampdu_action\t\t= rtw89_ops_ampdu_action,\n\t.set_rts_threshold\t= rtw89_ops_set_rts_threshold,\n\t.sta_statistics\t\t= rtw89_ops_sta_statistics,\n\t.flush\t\t\t= rtw89_ops_flush,\n\t.set_bitrate_mask\t= rtw89_ops_set_bitrate_mask,\n\t.set_antenna\t\t= rtw89_ops_set_antenna,\n\t.get_antenna\t\t= rtw89_ops_get_antenna,\n\t.sw_scan_start\t\t= rtw89_ops_sw_scan_start,\n\t.sw_scan_complete\t= rtw89_ops_sw_scan_complete,\n\t.reconfig_complete\t= rtw89_ops_reconfig_complete,\n\t.hw_scan\t\t= rtw89_ops_hw_scan,\n\t.cancel_hw_scan\t\t= rtw89_ops_cancel_hw_scan,\n\t.add_chanctx\t\t= rtw89_ops_add_chanctx,\n\t.remove_chanctx\t\t= rtw89_ops_remove_chanctx,\n\t.change_chanctx\t\t= rtw89_ops_change_chanctx,\n\t.assign_vif_chanctx\t= rtw89_ops_assign_vif_chanctx,\n\t.unassign_vif_chanctx\t= rtw89_ops_unassign_vif_chanctx,\n\t.remain_on_channel\t\t= rtw89_ops_remain_on_channel,\n\t.cancel_remain_on_channel\t= rtw89_ops_cancel_remain_on_channel,\n\t.set_sar_specs\t\t= rtw89_ops_set_sar_specs,\n\t.sta_rc_update\t\t= rtw89_ops_sta_rc_update,\n\t.set_tid_config\t\t= rtw89_ops_set_tid_config,\n#ifdef CONFIG_PM\n\t.suspend\t\t= rtw89_ops_suspend,\n\t.resume\t\t\t= rtw89_ops_resume,\n\t.set_wakeup\t\t= rtw89_ops_set_wakeup,\n#endif\n};\nEXPORT_SYMBOL(rtw89_ops);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}