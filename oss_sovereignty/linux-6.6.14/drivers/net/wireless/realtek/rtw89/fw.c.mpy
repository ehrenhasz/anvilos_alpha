{
  "module_name": "fw.c",
  "hash_id": "5a6bf98b662dfae26328b5a4929d27ceb8b4f8c5f7b2ceb5d4b402763d0289dc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtw89/fw.c",
  "human_readable_source": "\n \n\n#include \"cam.h\"\n#include \"chan.h\"\n#include \"coex.h\"\n#include \"debug.h\"\n#include \"fw.h\"\n#include \"mac.h\"\n#include \"phy.h\"\n#include \"ps.h\"\n#include \"reg.h\"\n#include \"util.h\"\n\nstatic void rtw89_fw_c2h_cmd_handle(struct rtw89_dev *rtwdev,\n\t\t\t\t    struct sk_buff *skb);\nstatic int rtw89_h2c_tx_and_wait(struct rtw89_dev *rtwdev, struct sk_buff *skb,\n\t\t\t\t struct rtw89_wait_info *wait, unsigned int cond);\n\nstatic struct sk_buff *rtw89_fw_h2c_alloc_skb(struct rtw89_dev *rtwdev, u32 len,\n\t\t\t\t\t      bool header)\n{\n\tstruct sk_buff *skb;\n\tu32 header_len = 0;\n\tu32 h2c_desc_size = rtwdev->chip->h2c_desc_size;\n\n\tif (header)\n\t\theader_len = H2C_HEADER_LEN;\n\n\tskb = dev_alloc_skb(len + header_len + h2c_desc_size);\n\tif (!skb)\n\t\treturn NULL;\n\tskb_reserve(skb, header_len + h2c_desc_size);\n\tmemset(skb->data, 0, len);\n\n\treturn skb;\n}\n\nstruct sk_buff *rtw89_fw_h2c_alloc_skb_with_hdr(struct rtw89_dev *rtwdev, u32 len)\n{\n\treturn rtw89_fw_h2c_alloc_skb(rtwdev, len, true);\n}\n\nstruct sk_buff *rtw89_fw_h2c_alloc_skb_no_hdr(struct rtw89_dev *rtwdev, u32 len)\n{\n\treturn rtw89_fw_h2c_alloc_skb(rtwdev, len, false);\n}\n\nstatic u8 _fw_get_rdy(struct rtw89_dev *rtwdev)\n{\n\tu8 val = rtw89_read8(rtwdev, R_AX_WCPU_FW_CTRL);\n\n\treturn FIELD_GET(B_AX_WCPU_FWDL_STS_MASK, val);\n}\n\n#define FWDL_WAIT_CNT 400000\nint rtw89_fw_check_rdy(struct rtw89_dev *rtwdev)\n{\n\tu8 val;\n\tint ret;\n\n\tret = read_poll_timeout_atomic(_fw_get_rdy, val,\n\t\t\t\t       val == RTW89_FWDL_WCPU_FW_INIT_RDY,\n\t\t\t\t       1, FWDL_WAIT_CNT, false, rtwdev);\n\tif (ret) {\n\t\tswitch (val) {\n\t\tcase RTW89_FWDL_CHECKSUM_FAIL:\n\t\t\trtw89_err(rtwdev, \"fw checksum fail\\n\");\n\t\t\treturn -EINVAL;\n\n\t\tcase RTW89_FWDL_SECURITY_FAIL:\n\t\t\trtw89_err(rtwdev, \"fw security fail\\n\");\n\t\t\treturn -EINVAL;\n\n\t\tcase RTW89_FWDL_CV_NOT_MATCH:\n\t\t\trtw89_err(rtwdev, \"fw cv not match\\n\");\n\t\t\treturn -EINVAL;\n\n\t\tdefault:\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\tset_bit(RTW89_FLAG_FW_RDY, rtwdev->flags);\n\n\treturn 0;\n}\n\nstatic int rtw89_fw_hdr_parser_v0(struct rtw89_dev *rtwdev, const u8 *fw, u32 len,\n\t\t\t\t  struct rtw89_fw_bin_info *info)\n{\n\tconst struct rtw89_fw_hdr *fw_hdr = (const struct rtw89_fw_hdr *)fw;\n\tstruct rtw89_fw_hdr_section_info *section_info;\n\tconst struct rtw89_fw_dynhdr_hdr *fwdynhdr;\n\tconst struct rtw89_fw_hdr_section *section;\n\tconst u8 *fw_end = fw + len;\n\tconst u8 *bin;\n\tu32 base_hdr_len;\n\tu32 mssc_len = 0;\n\tu32 i;\n\n\tif (!info)\n\t\treturn -EINVAL;\n\n\tinfo->section_num = le32_get_bits(fw_hdr->w6, FW_HDR_W6_SEC_NUM);\n\tbase_hdr_len = struct_size(fw_hdr, sections, info->section_num);\n\tinfo->dynamic_hdr_en = le32_get_bits(fw_hdr->w7, FW_HDR_W7_DYN_HDR);\n\n\tif (info->dynamic_hdr_en) {\n\t\tinfo->hdr_len = le32_get_bits(fw_hdr->w3, FW_HDR_W3_LEN);\n\t\tinfo->dynamic_hdr_len = info->hdr_len - base_hdr_len;\n\t\tfwdynhdr = (const struct rtw89_fw_dynhdr_hdr *)(fw + base_hdr_len);\n\t\tif (le32_to_cpu(fwdynhdr->hdr_len) != info->dynamic_hdr_len) {\n\t\t\trtw89_err(rtwdev, \"[ERR]invalid fw dynamic header len\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tinfo->hdr_len = base_hdr_len;\n\t\tinfo->dynamic_hdr_len = 0;\n\t}\n\n\tbin = fw + info->hdr_len;\n\n\t \n\tsection_info = info->section_info;\n\tfor (i = 0; i < info->section_num; i++) {\n\t\tsection = &fw_hdr->sections[i];\n\t\tsection_info->type =\n\t\t\tle32_get_bits(section->w1, FWSECTION_HDR_W1_SECTIONTYPE);\n\t\tif (section_info->type == FWDL_SECURITY_SECTION_TYPE) {\n\t\t\tsection_info->mssc =\n\t\t\t\tle32_get_bits(section->w2, FWSECTION_HDR_W2_MSSC);\n\t\t\tmssc_len += section_info->mssc * FWDL_SECURITY_SIGLEN;\n\t\t} else {\n\t\t\tsection_info->mssc = 0;\n\t\t}\n\n\t\tsection_info->len = le32_get_bits(section->w1, FWSECTION_HDR_W1_SEC_SIZE);\n\t\tif (le32_get_bits(section->w1, FWSECTION_HDR_W1_CHECKSUM))\n\t\t\tsection_info->len += FWDL_SECTION_CHKSUM_LEN;\n\t\tsection_info->redl = le32_get_bits(section->w1, FWSECTION_HDR_W1_REDL);\n\t\tsection_info->dladdr =\n\t\t\tle32_get_bits(section->w0, FWSECTION_HDR_W0_DL_ADDR) & 0x1fffffff;\n\t\tsection_info->addr = bin;\n\t\tbin += section_info->len;\n\t\tsection_info++;\n\t}\n\n\tif (fw_end != bin + mssc_len) {\n\t\trtw89_err(rtwdev, \"[ERR]fw bin size\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int rtw89_fw_hdr_parser_v1(struct rtw89_dev *rtwdev, const u8 *fw, u32 len,\n\t\t\t\t  struct rtw89_fw_bin_info *info)\n{\n\tconst struct rtw89_fw_hdr_v1 *fw_hdr = (const struct rtw89_fw_hdr_v1 *)fw;\n\tstruct rtw89_fw_hdr_section_info *section_info;\n\tconst struct rtw89_fw_dynhdr_hdr *fwdynhdr;\n\tconst struct rtw89_fw_hdr_section_v1 *section;\n\tconst u8 *fw_end = fw + len;\n\tconst u8 *bin;\n\tu32 base_hdr_len;\n\tu32 mssc_len = 0;\n\tu32 i;\n\n\tinfo->section_num = le32_get_bits(fw_hdr->w6, FW_HDR_V1_W6_SEC_NUM);\n\tbase_hdr_len = struct_size(fw_hdr, sections, info->section_num);\n\tinfo->dynamic_hdr_en = le32_get_bits(fw_hdr->w7, FW_HDR_V1_W7_DYN_HDR);\n\n\tif (info->dynamic_hdr_en) {\n\t\tinfo->hdr_len = le32_get_bits(fw_hdr->w5, FW_HDR_V1_W5_HDR_SIZE);\n\t\tinfo->dynamic_hdr_len = info->hdr_len - base_hdr_len;\n\t\tfwdynhdr = (const struct rtw89_fw_dynhdr_hdr *)(fw + base_hdr_len);\n\t\tif (le32_to_cpu(fwdynhdr->hdr_len) != info->dynamic_hdr_len) {\n\t\t\trtw89_err(rtwdev, \"[ERR]invalid fw dynamic header len\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tinfo->hdr_len = base_hdr_len;\n\t\tinfo->dynamic_hdr_len = 0;\n\t}\n\n\tbin = fw + info->hdr_len;\n\n\t \n\tsection_info = info->section_info;\n\tfor (i = 0; i < info->section_num; i++) {\n\t\tsection = &fw_hdr->sections[i];\n\t\tsection_info->type =\n\t\t\tle32_get_bits(section->w1, FWSECTION_HDR_V1_W1_SECTIONTYPE);\n\t\tif (section_info->type == FWDL_SECURITY_SECTION_TYPE) {\n\t\t\tsection_info->mssc =\n\t\t\t\tle32_get_bits(section->w2, FWSECTION_HDR_V1_W2_MSSC);\n\t\t\tmssc_len += section_info->mssc * FWDL_SECURITY_SIGLEN;\n\t\t} else {\n\t\t\tsection_info->mssc = 0;\n\t\t}\n\n\t\tsection_info->len =\n\t\t\tle32_get_bits(section->w1, FWSECTION_HDR_V1_W1_SEC_SIZE);\n\t\tif (le32_get_bits(section->w1, FWSECTION_HDR_V1_W1_CHECKSUM))\n\t\t\tsection_info->len += FWDL_SECTION_CHKSUM_LEN;\n\t\tsection_info->redl = le32_get_bits(section->w1, FWSECTION_HDR_V1_W1_REDL);\n\t\tsection_info->dladdr =\n\t\t\tle32_get_bits(section->w0, FWSECTION_HDR_V1_W0_DL_ADDR);\n\t\tsection_info->addr = bin;\n\t\tbin += section_info->len;\n\t\tsection_info++;\n\t}\n\n\tif (fw_end != bin + mssc_len) {\n\t\trtw89_err(rtwdev, \"[ERR]fw bin size\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int rtw89_fw_hdr_parser(struct rtw89_dev *rtwdev,\n\t\t\t       const struct rtw89_fw_suit *fw_suit,\n\t\t\t       struct rtw89_fw_bin_info *info)\n{\n\tconst u8 *fw = fw_suit->data;\n\tu32 len = fw_suit->size;\n\n\tif (!fw || !len) {\n\t\trtw89_err(rtwdev, \"fw type %d isn't recognized\\n\", fw_suit->type);\n\t\treturn -ENOENT;\n\t}\n\n\tswitch (fw_suit->hdr_ver) {\n\tcase 0:\n\t\treturn rtw89_fw_hdr_parser_v0(rtwdev, fw, len, info);\n\tcase 1:\n\t\treturn rtw89_fw_hdr_parser_v1(rtwdev, fw, len, info);\n\tdefault:\n\t\treturn -ENOENT;\n\t}\n}\n\nstatic\nint rtw89_mfw_recognize(struct rtw89_dev *rtwdev, enum rtw89_fw_type type,\n\t\t\tstruct rtw89_fw_suit *fw_suit, bool nowarn)\n{\n\tstruct rtw89_fw_info *fw_info = &rtwdev->fw;\n\tconst struct firmware *firmware = fw_info->req.firmware;\n\tconst u8 *mfw = firmware->data;\n\tu32 mfw_len = firmware->size;\n\tconst struct rtw89_mfw_hdr *mfw_hdr = (const struct rtw89_mfw_hdr *)mfw;\n\tconst struct rtw89_mfw_info *mfw_info;\n\tint i;\n\n\tif (mfw_hdr->sig != RTW89_MFW_SIG) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_FW, \"use legacy firmware\\n\");\n\t\t \n\t\tif (type != RTW89_FW_NORMAL)\n\t\t\treturn -EINVAL;\n\t\tfw_suit->data = mfw;\n\t\tfw_suit->size = mfw_len;\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < mfw_hdr->fw_nr; i++) {\n\t\tmfw_info = &mfw_hdr->info[i];\n\t\tif (mfw_info->type == type) {\n\t\t\tif (mfw_info->cv == rtwdev->hal.cv && !mfw_info->mp)\n\t\t\t\tgoto found;\n\t\t\tif (type == RTW89_FW_LOGFMT)\n\t\t\t\tgoto found;\n\t\t}\n\t}\n\n\tif (!nowarn)\n\t\trtw89_err(rtwdev, \"no suitable firmware found\\n\");\n\treturn -ENOENT;\n\nfound:\n\tfw_suit->data = mfw + le32_to_cpu(mfw_info->shift);\n\tfw_suit->size = le32_to_cpu(mfw_info->size);\n\treturn 0;\n}\n\nstatic u32 rtw89_mfw_get_size(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_fw_info *fw_info = &rtwdev->fw;\n\tconst struct firmware *firmware = fw_info->req.firmware;\n\tconst struct rtw89_mfw_hdr *mfw_hdr =\n\t\t(const struct rtw89_mfw_hdr *)firmware->data;\n\tconst struct rtw89_mfw_info *mfw_info;\n\tu32 size;\n\n\tif (mfw_hdr->sig != RTW89_MFW_SIG) {\n\t\trtw89_warn(rtwdev, \"not mfw format\\n\");\n\t\treturn 0;\n\t}\n\n\tmfw_info = &mfw_hdr->info[mfw_hdr->fw_nr - 1];\n\tsize = le32_to_cpu(mfw_info->shift) + le32_to_cpu(mfw_info->size);\n\n\treturn size;\n}\n\nstatic void rtw89_fw_update_ver_v0(struct rtw89_dev *rtwdev,\n\t\t\t\t   struct rtw89_fw_suit *fw_suit,\n\t\t\t\t   const struct rtw89_fw_hdr *hdr)\n{\n\tfw_suit->major_ver = le32_get_bits(hdr->w1, FW_HDR_W1_MAJOR_VERSION);\n\tfw_suit->minor_ver = le32_get_bits(hdr->w1, FW_HDR_W1_MINOR_VERSION);\n\tfw_suit->sub_ver = le32_get_bits(hdr->w1, FW_HDR_W1_SUBVERSION);\n\tfw_suit->sub_idex = le32_get_bits(hdr->w1, FW_HDR_W1_SUBINDEX);\n\tfw_suit->commitid = le32_get_bits(hdr->w2, FW_HDR_W2_COMMITID);\n\tfw_suit->build_year = le32_get_bits(hdr->w5, FW_HDR_W5_YEAR);\n\tfw_suit->build_mon = le32_get_bits(hdr->w4, FW_HDR_W4_MONTH);\n\tfw_suit->build_date = le32_get_bits(hdr->w4, FW_HDR_W4_DATE);\n\tfw_suit->build_hour = le32_get_bits(hdr->w4, FW_HDR_W4_HOUR);\n\tfw_suit->build_min = le32_get_bits(hdr->w4, FW_HDR_W4_MIN);\n\tfw_suit->cmd_ver = le32_get_bits(hdr->w7, FW_HDR_W7_CMD_VERSERION);\n}\n\nstatic void rtw89_fw_update_ver_v1(struct rtw89_dev *rtwdev,\n\t\t\t\t   struct rtw89_fw_suit *fw_suit,\n\t\t\t\t   const struct rtw89_fw_hdr_v1 *hdr)\n{\n\tfw_suit->major_ver = le32_get_bits(hdr->w1, FW_HDR_V1_W1_MAJOR_VERSION);\n\tfw_suit->minor_ver = le32_get_bits(hdr->w1, FW_HDR_V1_W1_MINOR_VERSION);\n\tfw_suit->sub_ver = le32_get_bits(hdr->w1, FW_HDR_V1_W1_SUBVERSION);\n\tfw_suit->sub_idex = le32_get_bits(hdr->w1, FW_HDR_V1_W1_SUBINDEX);\n\tfw_suit->commitid = le32_get_bits(hdr->w2, FW_HDR_V1_W2_COMMITID);\n\tfw_suit->build_year = le32_get_bits(hdr->w5, FW_HDR_V1_W5_YEAR);\n\tfw_suit->build_mon = le32_get_bits(hdr->w4, FW_HDR_V1_W4_MONTH);\n\tfw_suit->build_date = le32_get_bits(hdr->w4, FW_HDR_V1_W4_DATE);\n\tfw_suit->build_hour = le32_get_bits(hdr->w4, FW_HDR_V1_W4_HOUR);\n\tfw_suit->build_min = le32_get_bits(hdr->w4, FW_HDR_V1_W4_MIN);\n\tfw_suit->cmd_ver = le32_get_bits(hdr->w7, FW_HDR_V1_W3_CMD_VERSERION);\n}\n\nstatic int rtw89_fw_update_ver(struct rtw89_dev *rtwdev,\n\t\t\t       enum rtw89_fw_type type,\n\t\t\t       struct rtw89_fw_suit *fw_suit)\n{\n\tconst struct rtw89_fw_hdr *v0 = (const struct rtw89_fw_hdr *)fw_suit->data;\n\tconst struct rtw89_fw_hdr_v1 *v1 = (const struct rtw89_fw_hdr_v1 *)fw_suit->data;\n\n\tif (type == RTW89_FW_LOGFMT)\n\t\treturn 0;\n\n\tfw_suit->type = type;\n\tfw_suit->hdr_ver = le32_get_bits(v0->w3, FW_HDR_W3_HDR_VER);\n\n\tswitch (fw_suit->hdr_ver) {\n\tcase 0:\n\t\trtw89_fw_update_ver_v0(rtwdev, fw_suit, v0);\n\t\tbreak;\n\tcase 1:\n\t\trtw89_fw_update_ver_v1(rtwdev, fw_suit, v1);\n\t\tbreak;\n\tdefault:\n\t\trtw89_err(rtwdev, \"Unknown firmware header version %u\\n\",\n\t\t\t  fw_suit->hdr_ver);\n\t\treturn -ENOENT;\n\t}\n\n\trtw89_info(rtwdev,\n\t\t   \"Firmware version %u.%u.%u.%u (%08x), cmd version %u, type %u\\n\",\n\t\t   fw_suit->major_ver, fw_suit->minor_ver, fw_suit->sub_ver,\n\t\t   fw_suit->sub_idex, fw_suit->commitid, fw_suit->cmd_ver, type);\n\n\treturn 0;\n}\n\nstatic\nint __rtw89_fw_recognize(struct rtw89_dev *rtwdev, enum rtw89_fw_type type,\n\t\t\t bool nowarn)\n{\n\tstruct rtw89_fw_suit *fw_suit = rtw89_fw_suit_get(rtwdev, type);\n\tint ret;\n\n\tret = rtw89_mfw_recognize(rtwdev, type, fw_suit, nowarn);\n\tif (ret)\n\t\treturn ret;\n\n\treturn rtw89_fw_update_ver(rtwdev, type, fw_suit);\n}\n\nstatic\nint __rtw89_fw_recognize_from_elm(struct rtw89_dev *rtwdev,\n\t\t\t\t  const struct rtw89_fw_element_hdr *elm,\n\t\t\t\t  const void *data)\n{\n\tenum rtw89_fw_type type = (enum rtw89_fw_type)data;\n\tstruct rtw89_fw_suit *fw_suit;\n\n\tfw_suit = rtw89_fw_suit_get(rtwdev, type);\n\tfw_suit->data = elm->u.common.contents;\n\tfw_suit->size = le32_to_cpu(elm->size);\n\n\treturn rtw89_fw_update_ver(rtwdev, type, fw_suit);\n}\n\n#define __DEF_FW_FEAT_COND(__cond, __op) \\\nstatic bool __fw_feat_cond_ ## __cond(u32 suit_ver_code, u32 comp_ver_code) \\\n{ \\\n\treturn suit_ver_code __op comp_ver_code; \\\n}\n\n__DEF_FW_FEAT_COND(ge, >=);  \n__DEF_FW_FEAT_COND(le, <=);  \n__DEF_FW_FEAT_COND(lt, <);  \n\nstruct __fw_feat_cfg {\n\tenum rtw89_core_chip_id chip_id;\n\tenum rtw89_fw_feature feature;\n\tu32 ver_code;\n\tbool (*cond)(u32 suit_ver_code, u32 comp_ver_code);\n};\n\n#define __CFG_FW_FEAT(_chip, _cond, _maj, _min, _sub, _idx, _feat) \\\n\t{ \\\n\t\t.chip_id = _chip, \\\n\t\t.feature = RTW89_FW_FEATURE_ ## _feat, \\\n\t\t.ver_code = RTW89_FW_VER_CODE(_maj, _min, _sub, _idx), \\\n\t\t.cond = __fw_feat_cond_ ## _cond, \\\n\t}\n\nstatic const struct __fw_feat_cfg fw_feat_tbl[] = {\n\t__CFG_FW_FEAT(RTL8851B, ge, 0, 29, 37, 1, TX_WAKE),\n\t__CFG_FW_FEAT(RTL8851B, ge, 0, 29, 37, 1, SCAN_OFFLOAD),\n\t__CFG_FW_FEAT(RTL8851B, ge, 0, 29, 41, 0, CRASH_TRIGGER),\n\t__CFG_FW_FEAT(RTL8852A, le, 0, 13, 29, 0, OLD_HT_RA_FORMAT),\n\t__CFG_FW_FEAT(RTL8852A, ge, 0, 13, 35, 0, SCAN_OFFLOAD),\n\t__CFG_FW_FEAT(RTL8852A, ge, 0, 13, 35, 0, TX_WAKE),\n\t__CFG_FW_FEAT(RTL8852A, ge, 0, 13, 36, 0, CRASH_TRIGGER),\n\t__CFG_FW_FEAT(RTL8852A, lt, 0, 13, 38, 0, NO_PACKET_DROP),\n\t__CFG_FW_FEAT(RTL8852B, ge, 0, 29, 26, 0, NO_LPS_PG),\n\t__CFG_FW_FEAT(RTL8852B, ge, 0, 29, 26, 0, TX_WAKE),\n\t__CFG_FW_FEAT(RTL8852B, ge, 0, 29, 29, 0, CRASH_TRIGGER),\n\t__CFG_FW_FEAT(RTL8852B, ge, 0, 29, 29, 0, SCAN_OFFLOAD),\n\t__CFG_FW_FEAT(RTL8852C, le, 0, 27, 33, 0, NO_DEEP_PS),\n\t__CFG_FW_FEAT(RTL8852C, ge, 0, 27, 34, 0, TX_WAKE),\n\t__CFG_FW_FEAT(RTL8852C, ge, 0, 27, 36, 0, SCAN_OFFLOAD),\n\t__CFG_FW_FEAT(RTL8852C, ge, 0, 27, 40, 0, CRASH_TRIGGER),\n\t__CFG_FW_FEAT(RTL8852C, ge, 0, 27, 56, 10, BEACON_FILTER),\n};\n\nstatic void rtw89_fw_iterate_feature_cfg(struct rtw89_fw_info *fw,\n\t\t\t\t\t const struct rtw89_chip_info *chip,\n\t\t\t\t\t u32 ver_code)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(fw_feat_tbl); i++) {\n\t\tconst struct __fw_feat_cfg *ent = &fw_feat_tbl[i];\n\n\t\tif (chip->chip_id != ent->chip_id)\n\t\t\tcontinue;\n\n\t\tif (ent->cond(ver_code, ent->ver_code))\n\t\t\tRTW89_SET_FW_FEATURE(ent->feature, fw);\n\t}\n}\n\nstatic void rtw89_fw_recognize_features(struct rtw89_dev *rtwdev)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tconst struct rtw89_fw_suit *fw_suit;\n\tu32 suit_ver_code;\n\n\tfw_suit = rtw89_fw_suit_get(rtwdev, RTW89_FW_NORMAL);\n\tsuit_ver_code = RTW89_FW_SUIT_VER_CODE(fw_suit);\n\n\trtw89_fw_iterate_feature_cfg(&rtwdev->fw, chip, suit_ver_code);\n}\n\nconst struct firmware *\nrtw89_early_fw_feature_recognize(struct device *device,\n\t\t\t\t const struct rtw89_chip_info *chip,\n\t\t\t\t struct rtw89_fw_info *early_fw,\n\t\t\t\t int *used_fw_format)\n{\n\tconst struct firmware *firmware;\n\tchar fw_name[64];\n\tint fw_format;\n\tu32 ver_code;\n\tint ret;\n\n\tfor (fw_format = chip->fw_format_max; fw_format >= 0; fw_format--) {\n\t\trtw89_fw_get_filename(fw_name, sizeof(fw_name),\n\t\t\t\t      chip->fw_basename, fw_format);\n\n\t\tret = request_firmware(&firmware, fw_name, device);\n\t\tif (!ret) {\n\t\t\tdev_info(device, \"loaded firmware %s\\n\", fw_name);\n\t\t\t*used_fw_format = fw_format;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret) {\n\t\tdev_err(device, \"failed to early request firmware: %d\\n\", ret);\n\t\treturn NULL;\n\t}\n\n\tver_code = rtw89_compat_fw_hdr_ver_code(firmware->data);\n\n\tif (!ver_code)\n\t\tgoto out;\n\n\trtw89_fw_iterate_feature_cfg(early_fw, chip, ver_code);\n\nout:\n\treturn firmware;\n}\n\nint rtw89_fw_recognize(struct rtw89_dev *rtwdev)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tint ret;\n\n\tif (chip->try_ce_fw) {\n\t\tret = __rtw89_fw_recognize(rtwdev, RTW89_FW_NORMAL_CE, true);\n\t\tif (!ret)\n\t\t\tgoto normal_done;\n\t}\n\n\tret = __rtw89_fw_recognize(rtwdev, RTW89_FW_NORMAL, false);\n\tif (ret)\n\t\treturn ret;\n\nnormal_done:\n\t \n\t__rtw89_fw_recognize(rtwdev, RTW89_FW_WOWLAN, false);\n\n\t \n\t__rtw89_fw_recognize(rtwdev, RTW89_FW_LOGFMT, true);\n\n\trtw89_fw_recognize_features(rtwdev);\n\n\trtw89_coex_recognize_ver(rtwdev);\n\n\treturn 0;\n}\n\nstatic\nint rtw89_build_phy_tbl_from_elm(struct rtw89_dev *rtwdev,\n\t\t\t\t const struct rtw89_fw_element_hdr *elm,\n\t\t\t\t const void *data)\n{\n\tstruct rtw89_fw_elm_info *elm_info = &rtwdev->fw.elm_info;\n\tstruct rtw89_phy_table *tbl;\n\tstruct rtw89_reg2_def *regs;\n\tenum rtw89_rf_path rf_path;\n\tu32 n_regs, i;\n\tu8 idx;\n\n\ttbl = kzalloc(sizeof(*tbl), GFP_KERNEL);\n\tif (!tbl)\n\t\treturn -ENOMEM;\n\n\tswitch (le32_to_cpu(elm->id)) {\n\tcase RTW89_FW_ELEMENT_ID_BB_REG:\n\t\telm_info->bb_tbl = tbl;\n\t\tbreak;\n\tcase RTW89_FW_ELEMENT_ID_BB_GAIN:\n\t\telm_info->bb_gain = tbl;\n\t\tbreak;\n\tcase RTW89_FW_ELEMENT_ID_RADIO_A:\n\tcase RTW89_FW_ELEMENT_ID_RADIO_B:\n\tcase RTW89_FW_ELEMENT_ID_RADIO_C:\n\tcase RTW89_FW_ELEMENT_ID_RADIO_D:\n\t\trf_path = (enum rtw89_rf_path)data;\n\t\tidx = elm->u.reg2.idx;\n\n\t\telm_info->rf_radio[idx] = tbl;\n\t\ttbl->rf_path = rf_path;\n\t\ttbl->config = rtw89_phy_config_rf_reg_v1;\n\t\tbreak;\n\tcase RTW89_FW_ELEMENT_ID_RF_NCTL:\n\t\telm_info->rf_nctl = tbl;\n\t\tbreak;\n\tdefault:\n\t\tkfree(tbl);\n\t\treturn -ENOENT;\n\t}\n\n\tn_regs = le32_to_cpu(elm->size) / sizeof(tbl->regs[0]);\n\tregs = kcalloc(n_regs, sizeof(tbl->regs[0]), GFP_KERNEL);\n\tif (!regs)\n\t\tgoto out;\n\n\tfor (i = 0; i < n_regs; i++) {\n\t\tregs[i].addr = le32_to_cpu(elm->u.reg2.regs[i].addr);\n\t\tregs[i].data = le32_to_cpu(elm->u.reg2.regs[i].data);\n\t}\n\n\ttbl->n_regs = n_regs;\n\ttbl->regs = regs;\n\n\treturn 0;\n\nout:\n\tkfree(tbl);\n\treturn -ENOMEM;\n}\n\nstruct rtw89_fw_element_handler {\n\tint (*fn)(struct rtw89_dev *rtwdev,\n\t\t  const struct rtw89_fw_element_hdr *elm, const void *data);\n\tconst void *data;\n\tconst char *name;\n};\n\nstatic const struct rtw89_fw_element_handler __fw_element_handlers[] = {\n\t[RTW89_FW_ELEMENT_ID_BBMCU0] = {__rtw89_fw_recognize_from_elm,\n\t\t\t\t\t(const void *)RTW89_FW_BBMCU0, NULL},\n\t[RTW89_FW_ELEMENT_ID_BBMCU1] = {__rtw89_fw_recognize_from_elm,\n\t\t\t\t\t(const void *)RTW89_FW_BBMCU1, NULL},\n\t[RTW89_FW_ELEMENT_ID_BB_REG] = {rtw89_build_phy_tbl_from_elm, NULL, \"BB\"},\n\t[RTW89_FW_ELEMENT_ID_BB_GAIN] = {rtw89_build_phy_tbl_from_elm, NULL, NULL},\n\t[RTW89_FW_ELEMENT_ID_RADIO_A] = {rtw89_build_phy_tbl_from_elm,\n\t\t\t\t\t (const void *)RF_PATH_A, \"radio A\"},\n\t[RTW89_FW_ELEMENT_ID_RADIO_B] = {rtw89_build_phy_tbl_from_elm,\n\t\t\t\t\t (const void *)RF_PATH_B, NULL},\n\t[RTW89_FW_ELEMENT_ID_RADIO_C] = {rtw89_build_phy_tbl_from_elm,\n\t\t\t\t\t (const void *)RF_PATH_C, NULL},\n\t[RTW89_FW_ELEMENT_ID_RADIO_D] = {rtw89_build_phy_tbl_from_elm,\n\t\t\t\t\t (const void *)RF_PATH_D, NULL},\n\t[RTW89_FW_ELEMENT_ID_RF_NCTL] = {rtw89_build_phy_tbl_from_elm, NULL, \"NCTL\"},\n};\n\nint rtw89_fw_recognize_elements(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_fw_info *fw_info = &rtwdev->fw;\n\tconst struct firmware *firmware = fw_info->req.firmware;\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tu32 unrecognized_elements = chip->needed_fw_elms;\n\tconst struct rtw89_fw_element_handler *handler;\n\tconst struct rtw89_fw_element_hdr *hdr;\n\tu32 elm_size;\n\tu32 elem_id;\n\tu32 offset;\n\tint ret;\n\n\tBUILD_BUG_ON(sizeof(chip->needed_fw_elms) * 8 < RTW89_FW_ELEMENT_ID_NUM);\n\n\toffset = rtw89_mfw_get_size(rtwdev);\n\toffset = ALIGN(offset, RTW89_FW_ELEMENT_ALIGN);\n\tif (offset == 0)\n\t\treturn -EINVAL;\n\n\twhile (offset + sizeof(*hdr) < firmware->size) {\n\t\thdr = (const struct rtw89_fw_element_hdr *)(firmware->data + offset);\n\n\t\telm_size = le32_to_cpu(hdr->size);\n\t\tif (offset + elm_size >= firmware->size) {\n\t\t\trtw89_warn(rtwdev, \"firmware element size exceeds\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\telem_id = le32_to_cpu(hdr->id);\n\t\tif (elem_id >= ARRAY_SIZE(__fw_element_handlers))\n\t\t\tgoto next;\n\n\t\thandler = &__fw_element_handlers[elem_id];\n\t\tif (!handler->fn)\n\t\t\tgoto next;\n\n\t\tret = handler->fn(rtwdev, hdr, handler->data);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (handler->name)\n\t\t\trtw89_info(rtwdev, \"Firmware element %s version: %4ph\\n\",\n\t\t\t\t   handler->name, hdr->ver);\n\n\t\tunrecognized_elements &= ~BIT(elem_id);\nnext:\n\t\toffset += sizeof(*hdr) + elm_size;\n\t\toffset = ALIGN(offset, RTW89_FW_ELEMENT_ALIGN);\n\t}\n\n\tif (unrecognized_elements) {\n\t\trtw89_err(rtwdev, \"Firmware elements 0x%08x are unrecognized\\n\",\n\t\t\t  unrecognized_elements);\n\t\treturn -ENOENT;\n\t}\n\n\treturn 0;\n}\n\nvoid rtw89_h2c_pkt_set_hdr(struct rtw89_dev *rtwdev, struct sk_buff *skb,\n\t\t\t   u8 type, u8 cat, u8 class, u8 func,\n\t\t\t   bool rack, bool dack, u32 len)\n{\n\tstruct fwcmd_hdr *hdr;\n\n\thdr = (struct fwcmd_hdr *)skb_push(skb, 8);\n\n\tif (!(rtwdev->fw.h2c_seq % 4))\n\t\track = true;\n\thdr->hdr0 = cpu_to_le32(FIELD_PREP(H2C_HDR_DEL_TYPE, type) |\n\t\t\t\tFIELD_PREP(H2C_HDR_CAT, cat) |\n\t\t\t\tFIELD_PREP(H2C_HDR_CLASS, class) |\n\t\t\t\tFIELD_PREP(H2C_HDR_FUNC, func) |\n\t\t\t\tFIELD_PREP(H2C_HDR_H2C_SEQ, rtwdev->fw.h2c_seq));\n\n\thdr->hdr1 = cpu_to_le32(FIELD_PREP(H2C_HDR_TOTAL_LEN,\n\t\t\t\t\t   len + H2C_HEADER_LEN) |\n\t\t\t\t(rack ? H2C_HDR_REC_ACK : 0) |\n\t\t\t\t(dack ? H2C_HDR_DONE_ACK : 0));\n\n\trtwdev->fw.h2c_seq++;\n}\n\nstatic void rtw89_h2c_pkt_set_hdr_fwdl(struct rtw89_dev *rtwdev,\n\t\t\t\t       struct sk_buff *skb,\n\t\t\t\t       u8 type, u8 cat, u8 class, u8 func,\n\t\t\t\t       u32 len)\n{\n\tstruct fwcmd_hdr *hdr;\n\n\thdr = (struct fwcmd_hdr *)skb_push(skb, 8);\n\n\thdr->hdr0 = cpu_to_le32(FIELD_PREP(H2C_HDR_DEL_TYPE, type) |\n\t\t\t\tFIELD_PREP(H2C_HDR_CAT, cat) |\n\t\t\t\tFIELD_PREP(H2C_HDR_CLASS, class) |\n\t\t\t\tFIELD_PREP(H2C_HDR_FUNC, func) |\n\t\t\t\tFIELD_PREP(H2C_HDR_H2C_SEQ, rtwdev->fw.h2c_seq));\n\n\thdr->hdr1 = cpu_to_le32(FIELD_PREP(H2C_HDR_TOTAL_LEN,\n\t\t\t\t\t   len + H2C_HEADER_LEN));\n}\n\nstatic int __rtw89_fw_download_hdr(struct rtw89_dev *rtwdev, const u8 *fw, u32 len)\n{\n\tstruct sk_buff *skb;\n\tu32 ret = 0;\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, len);\n\tif (!skb) {\n\t\trtw89_err(rtwdev, \"failed to alloc skb for fw hdr dl\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tskb_put_data(skb, fw, len);\n\tSET_FW_HDR_PART_SIZE(skb->data, FWDL_SECTION_PER_PKT_LEN);\n\trtw89_h2c_pkt_set_hdr_fwdl(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t\t   H2C_CAT_MAC, H2C_CL_MAC_FWDL,\n\t\t\t\t   H2C_FUNC_MAC_FWHDR_DL, len);\n\n\tret = rtw89_h2c_tx(rtwdev, skb, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to send h2c\\n\");\n\t\tret = -1;\n\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\tdev_kfree_skb_any(skb);\n\n\treturn ret;\n}\n\nstatic int rtw89_fw_download_hdr(struct rtw89_dev *rtwdev, const u8 *fw, u32 len)\n{\n\tu8 val;\n\tint ret;\n\n\tret = __rtw89_fw_download_hdr(rtwdev, fw, len);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"[ERR]FW header download\\n\");\n\t\treturn ret;\n\t}\n\n\tret = read_poll_timeout_atomic(rtw89_read8, val, val & B_AX_FWDL_PATH_RDY,\n\t\t\t\t       1, FWDL_WAIT_CNT, false,\n\t\t\t\t       rtwdev, R_AX_WCPU_FW_CTRL);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"[ERR]FWDL path ready\\n\");\n\t\treturn ret;\n\t}\n\n\trtw89_write32(rtwdev, R_AX_HALT_H2C_CTRL, 0);\n\trtw89_write32(rtwdev, R_AX_HALT_C2H_CTRL, 0);\n\n\treturn 0;\n}\n\nstatic int __rtw89_fw_download_main(struct rtw89_dev *rtwdev,\n\t\t\t\t    struct rtw89_fw_hdr_section_info *info)\n{\n\tstruct sk_buff *skb;\n\tconst u8 *section = info->addr;\n\tu32 residue_len = info->len;\n\tu32 pkt_len;\n\tint ret;\n\n\twhile (residue_len) {\n\t\tif (residue_len >= FWDL_SECTION_PER_PKT_LEN)\n\t\t\tpkt_len = FWDL_SECTION_PER_PKT_LEN;\n\t\telse\n\t\t\tpkt_len = residue_len;\n\n\t\tskb = rtw89_fw_h2c_alloc_skb_no_hdr(rtwdev, pkt_len);\n\t\tif (!skb) {\n\t\t\trtw89_err(rtwdev, \"failed to alloc skb for fw dl\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tskb_put_data(skb, section, pkt_len);\n\n\t\tret = rtw89_h2c_tx(rtwdev, skb, true);\n\t\tif (ret) {\n\t\t\trtw89_err(rtwdev, \"failed to send h2c\\n\");\n\t\t\tret = -1;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tsection += pkt_len;\n\t\tresidue_len -= pkt_len;\n\t}\n\n\treturn 0;\nfail:\n\tdev_kfree_skb_any(skb);\n\n\treturn ret;\n}\n\nstatic int rtw89_fw_download_main(struct rtw89_dev *rtwdev, const u8 *fw,\n\t\t\t\t  struct rtw89_fw_bin_info *info)\n{\n\tstruct rtw89_fw_hdr_section_info *section_info = info->section_info;\n\tu8 section_num = info->section_num;\n\tint ret;\n\n\twhile (section_num--) {\n\t\tret = __rtw89_fw_download_main(rtwdev, section_info);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tsection_info++;\n\t}\n\n\tmdelay(5);\n\n\tret = rtw89_fw_check_rdy(rtwdev);\n\tif (ret) {\n\t\trtw89_warn(rtwdev, \"download firmware fail\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void rtw89_fw_prog_cnt_dump(struct rtw89_dev *rtwdev)\n{\n\tu32 val32;\n\tu16 index;\n\n\trtw89_write32(rtwdev, R_AX_DBG_CTRL,\n\t\t      FIELD_PREP(B_AX_DBG_SEL0, FW_PROG_CNTR_DBG_SEL) |\n\t\t      FIELD_PREP(B_AX_DBG_SEL1, FW_PROG_CNTR_DBG_SEL));\n\trtw89_write32_mask(rtwdev, R_AX_SYS_STATUS1, B_AX_SEL_0XC0_MASK, MAC_DBG_SEL);\n\n\tfor (index = 0; index < 15; index++) {\n\t\tval32 = rtw89_read32(rtwdev, R_AX_DBG_PORT_SEL);\n\t\trtw89_err(rtwdev, \"[ERR]fw PC = 0x%x\\n\", val32);\n\t\tfsleep(10);\n\t}\n}\n\nstatic void rtw89_fw_dl_fail_dump(struct rtw89_dev *rtwdev)\n{\n\tu32 val32;\n\tu16 val16;\n\n\tval32 = rtw89_read32(rtwdev, R_AX_WCPU_FW_CTRL);\n\trtw89_err(rtwdev, \"[ERR]fwdl 0x1E0 = 0x%x\\n\", val32);\n\n\tval16 = rtw89_read16(rtwdev, R_AX_BOOT_DBG + 2);\n\trtw89_err(rtwdev, \"[ERR]fwdl 0x83F2 = 0x%x\\n\", val16);\n\n\trtw89_fw_prog_cnt_dump(rtwdev);\n}\n\nint rtw89_fw_download(struct rtw89_dev *rtwdev, enum rtw89_fw_type type)\n{\n\tstruct rtw89_fw_info *fw_info = &rtwdev->fw;\n\tstruct rtw89_fw_suit *fw_suit = rtw89_fw_suit_get(rtwdev, type);\n\tstruct rtw89_fw_bin_info info;\n\tu8 val;\n\tint ret;\n\n\trtw89_mac_disable_cpu(rtwdev);\n\tret = rtw89_mac_enable_cpu(rtwdev, 0, true);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rtw89_fw_hdr_parser(rtwdev, fw_suit, &info);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"parse fw header fail\\n\");\n\t\tgoto fwdl_err;\n\t}\n\n\tret = read_poll_timeout_atomic(rtw89_read8, val, val & B_AX_H2C_PATH_RDY,\n\t\t\t\t       1, FWDL_WAIT_CNT, false,\n\t\t\t\t       rtwdev, R_AX_WCPU_FW_CTRL);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"[ERR]H2C path ready\\n\");\n\t\tgoto fwdl_err;\n\t}\n\n\tret = rtw89_fw_download_hdr(rtwdev, fw_suit->data, info.hdr_len -\n\t\t\t\t\t\t\t   info.dynamic_hdr_len);\n\tif (ret) {\n\t\tret = -EBUSY;\n\t\tgoto fwdl_err;\n\t}\n\n\tret = rtw89_fw_download_main(rtwdev, fw_suit->data, &info);\n\tif (ret) {\n\t\tret = -EBUSY;\n\t\tgoto fwdl_err;\n\t}\n\n\tfw_info->h2c_seq = 0;\n\tfw_info->rec_seq = 0;\n\tfw_info->h2c_counter = 0;\n\tfw_info->c2h_counter = 0;\n\trtwdev->mac.rpwm_seq_num = RPWM_SEQ_NUM_MAX;\n\trtwdev->mac.cpwm_seq_num = CPWM_SEQ_NUM_MAX;\n\n\treturn ret;\n\nfwdl_err:\n\trtw89_fw_dl_fail_dump(rtwdev);\n\treturn ret;\n}\n\nint rtw89_wait_firmware_completion(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_fw_info *fw = &rtwdev->fw;\n\n\twait_for_completion(&fw->req.completion);\n\tif (!fw->req.firmware)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int rtw89_load_firmware_req(struct rtw89_dev *rtwdev,\n\t\t\t\t   struct rtw89_fw_req_info *req,\n\t\t\t\t   const char *fw_name, bool nowarn)\n{\n\tint ret;\n\n\tif (req->firmware) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_FW,\n\t\t\t    \"full firmware has been early requested\\n\");\n\t\tcomplete_all(&req->completion);\n\t\treturn 0;\n\t}\n\n\tif (nowarn)\n\t\tret = firmware_request_nowarn(&req->firmware, fw_name, rtwdev->dev);\n\telse\n\t\tret = request_firmware(&req->firmware, fw_name, rtwdev->dev);\n\n\tcomplete_all(&req->completion);\n\n\treturn ret;\n}\n\nvoid rtw89_load_firmware_work(struct work_struct *work)\n{\n\tstruct rtw89_dev *rtwdev =\n\t\tcontainer_of(work, struct rtw89_dev, load_firmware_work);\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tchar fw_name[64];\n\n\trtw89_fw_get_filename(fw_name, sizeof(fw_name),\n\t\t\t      chip->fw_basename, rtwdev->fw.fw_format);\n\n\trtw89_load_firmware_req(rtwdev, &rtwdev->fw.req, fw_name, false);\n}\n\nstatic void rtw89_free_phy_tbl_from_elm(struct rtw89_phy_table *tbl)\n{\n\tif (!tbl)\n\t\treturn;\n\n\tkfree(tbl->regs);\n\tkfree(tbl);\n}\n\nstatic void rtw89_unload_firmware_elements(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_fw_elm_info *elm_info = &rtwdev->fw.elm_info;\n\tint i;\n\n\trtw89_free_phy_tbl_from_elm(elm_info->bb_tbl);\n\trtw89_free_phy_tbl_from_elm(elm_info->bb_gain);\n\tfor (i = 0; i < ARRAY_SIZE(elm_info->rf_radio); i++)\n\t\trtw89_free_phy_tbl_from_elm(elm_info->rf_radio[i]);\n\trtw89_free_phy_tbl_from_elm(elm_info->rf_nctl);\n}\n\nvoid rtw89_unload_firmware(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_fw_info *fw = &rtwdev->fw;\n\n\tcancel_work_sync(&rtwdev->load_firmware_work);\n\n\tif (fw->req.firmware) {\n\t\trelease_firmware(fw->req.firmware);\n\n\t\t \n\t\tfw->req.firmware = NULL;\n\t}\n\n\tkfree(fw->log.fmts);\n\trtw89_unload_firmware_elements(rtwdev);\n}\n\nstatic u32 rtw89_fw_log_get_fmt_idx(struct rtw89_dev *rtwdev, u32 fmt_id)\n{\n\tstruct rtw89_fw_log *fw_log = &rtwdev->fw.log;\n\tu32 i;\n\n\tif (fmt_id > fw_log->last_fmt_id)\n\t\treturn 0;\n\n\tfor (i = 0; i < fw_log->fmt_count; i++) {\n\t\tif (le32_to_cpu(fw_log->fmt_ids[i]) == fmt_id)\n\t\t\treturn i;\n\t}\n\treturn 0;\n}\n\nstatic int rtw89_fw_log_create_fmts_dict(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_fw_log *log = &rtwdev->fw.log;\n\tconst struct rtw89_fw_logsuit_hdr *suit_hdr;\n\tstruct rtw89_fw_suit *suit = &log->suit;\n\tconst void *fmts_ptr, *fmts_end_ptr;\n\tu32 fmt_count;\n\tint i;\n\n\tsuit_hdr = (const struct rtw89_fw_logsuit_hdr *)suit->data;\n\tfmt_count = le32_to_cpu(suit_hdr->count);\n\tlog->fmt_ids = suit_hdr->ids;\n\tfmts_ptr = &suit_hdr->ids[fmt_count];\n\tfmts_end_ptr = suit->data + suit->size;\n\tlog->fmts = kcalloc(fmt_count, sizeof(char *), GFP_KERNEL);\n\tif (!log->fmts)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < fmt_count; i++) {\n\t\tfmts_ptr = memchr_inv(fmts_ptr, 0, fmts_end_ptr - fmts_ptr);\n\t\tif (!fmts_ptr)\n\t\t\tbreak;\n\n\t\t(*log->fmts)[i] = fmts_ptr;\n\t\tlog->last_fmt_id = le32_to_cpu(log->fmt_ids[i]);\n\t\tlog->fmt_count++;\n\t\tfmts_ptr += strlen(fmts_ptr);\n\t}\n\n\treturn 0;\n}\n\nint rtw89_fw_log_prepare(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_fw_log *log = &rtwdev->fw.log;\n\tstruct rtw89_fw_suit *suit = &log->suit;\n\n\tif (!suit || !suit->data) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_FW, \"no log format file\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (log->fmts)\n\t\treturn 0;\n\n\treturn rtw89_fw_log_create_fmts_dict(rtwdev);\n}\n\nstatic void rtw89_fw_log_dump_data(struct rtw89_dev *rtwdev,\n\t\t\t\t   const struct rtw89_fw_c2h_log_fmt *log_fmt,\n\t\t\t\t   u32 fmt_idx, u8 para_int, bool raw_data)\n{\n\tconst char *(*fmts)[] = rtwdev->fw.log.fmts;\n\tchar str_buf[RTW89_C2H_FW_LOG_STR_BUF_SIZE];\n\tu32 args[RTW89_C2H_FW_LOG_MAX_PARA_NUM] = {0};\n\tint i;\n\n\tif (log_fmt->argc > RTW89_C2H_FW_LOG_MAX_PARA_NUM) {\n\t\trtw89_warn(rtwdev, \"C2H log: Arg count is unexpected %d\\n\",\n\t\t\t   log_fmt->argc);\n\t\treturn;\n\t}\n\n\tif (para_int)\n\t\tfor (i = 0 ; i < log_fmt->argc; i++)\n\t\t\targs[i] = le32_to_cpu(log_fmt->u.argv[i]);\n\n\tif (raw_data) {\n\t\tif (para_int)\n\t\t\tsnprintf(str_buf, RTW89_C2H_FW_LOG_STR_BUF_SIZE,\n\t\t\t\t \"fw_enc(%d, %d, %d) %*ph\", le32_to_cpu(log_fmt->fmt_id),\n\t\t\t\t para_int, log_fmt->argc, (int)sizeof(args), args);\n\t\telse\n\t\t\tsnprintf(str_buf, RTW89_C2H_FW_LOG_STR_BUF_SIZE,\n\t\t\t\t \"fw_enc(%d, %d, %d, %s)\", le32_to_cpu(log_fmt->fmt_id),\n\t\t\t\t para_int, log_fmt->argc, log_fmt->u.raw);\n\t} else {\n\t\tsnprintf(str_buf, RTW89_C2H_FW_LOG_STR_BUF_SIZE, (*fmts)[fmt_idx],\n\t\t\t args[0x0], args[0x1], args[0x2], args[0x3], args[0x4],\n\t\t\t args[0x5], args[0x6], args[0x7], args[0x8], args[0x9],\n\t\t\t args[0xa], args[0xb], args[0xc], args[0xd], args[0xe],\n\t\t\t args[0xf]);\n\t}\n\n\trtw89_info(rtwdev, \"C2H log: %s\", str_buf);\n}\n\nvoid rtw89_fw_log_dump(struct rtw89_dev *rtwdev, u8 *buf, u32 len)\n{\n\tconst struct rtw89_fw_c2h_log_fmt *log_fmt;\n\tu8 para_int;\n\tu32 fmt_idx;\n\n\tif (len < RTW89_C2H_HEADER_LEN) {\n\t\trtw89_err(rtwdev, \"c2h log length is wrong!\\n\");\n\t\treturn;\n\t}\n\n\tbuf += RTW89_C2H_HEADER_LEN;\n\tlen -= RTW89_C2H_HEADER_LEN;\n\tlog_fmt = (const struct rtw89_fw_c2h_log_fmt *)buf;\n\n\tif (len < RTW89_C2H_FW_FORMATTED_LOG_MIN_LEN)\n\t\tgoto plain_log;\n\n\tif (log_fmt->signature != cpu_to_le16(RTW89_C2H_FW_LOG_SIGNATURE))\n\t\tgoto plain_log;\n\n\tif (!rtwdev->fw.log.fmts)\n\t\treturn;\n\n\tpara_int = u8_get_bits(log_fmt->feature, RTW89_C2H_FW_LOG_FEATURE_PARA_INT);\n\tfmt_idx = rtw89_fw_log_get_fmt_idx(rtwdev, le32_to_cpu(log_fmt->fmt_id));\n\n\tif (!para_int && log_fmt->argc != 0 && fmt_idx != 0)\n\t\trtw89_info(rtwdev, \"C2H log: %s%s\",\n\t\t\t   (*rtwdev->fw.log.fmts)[fmt_idx], log_fmt->u.raw);\n\telse if (fmt_idx != 0 && para_int)\n\t\trtw89_fw_log_dump_data(rtwdev, log_fmt, fmt_idx, para_int, false);\n\telse\n\t\trtw89_fw_log_dump_data(rtwdev, log_fmt, fmt_idx, para_int, true);\n\treturn;\n\nplain_log:\n\trtw89_info(rtwdev, \"C2H log: %.*s\", len, buf);\n\n}\n\n#define H2C_CAM_LEN 60\nint rtw89_fw_h2c_cam(struct rtw89_dev *rtwdev, struct rtw89_vif *rtwvif,\n\t\t     struct rtw89_sta *rtwsta, const u8 *scan_mac_addr)\n{\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, H2C_CAM_LEN);\n\tif (!skb) {\n\t\trtw89_err(rtwdev, \"failed to alloc skb for fw dl\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_put(skb, H2C_CAM_LEN);\n\trtw89_cam_fill_addr_cam_info(rtwdev, rtwvif, rtwsta, scan_mac_addr, skb->data);\n\trtw89_cam_fill_bssid_cam_info(rtwdev, rtwvif, rtwsta, skb->data);\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_MAC,\n\t\t\t      H2C_CL_MAC_ADDR_CAM_UPDATE,\n\t\t\t      H2C_FUNC_MAC_ADDR_CAM_UPD, 0, 1,\n\t\t\t      H2C_CAM_LEN);\n\n\tret = rtw89_h2c_tx(rtwdev, skb, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to send h2c\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\tdev_kfree_skb_any(skb);\n\n\treturn ret;\n}\n\n#define H2C_DCTL_SEC_CAM_LEN 68\nint rtw89_fw_h2c_dctl_sec_cam_v1(struct rtw89_dev *rtwdev,\n\t\t\t\t struct rtw89_vif *rtwvif,\n\t\t\t\t struct rtw89_sta *rtwsta)\n{\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, H2C_DCTL_SEC_CAM_LEN);\n\tif (!skb) {\n\t\trtw89_err(rtwdev, \"failed to alloc skb for dctl sec cam\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_put(skb, H2C_DCTL_SEC_CAM_LEN);\n\n\trtw89_cam_fill_dctl_sec_cam_info_v1(rtwdev, rtwvif, rtwsta, skb->data);\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_MAC,\n\t\t\t      H2C_CL_MAC_FR_EXCHG,\n\t\t\t      H2C_FUNC_MAC_DCTLINFO_UD_V1, 0, 0,\n\t\t\t      H2C_DCTL_SEC_CAM_LEN);\n\n\tret = rtw89_h2c_tx(rtwdev, skb, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to send h2c\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\tdev_kfree_skb_any(skb);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(rtw89_fw_h2c_dctl_sec_cam_v1);\n\n#define H2C_BA_CAM_LEN 8\nint rtw89_fw_h2c_ba_cam(struct rtw89_dev *rtwdev, struct rtw89_sta *rtwsta,\n\t\t\tbool valid, struct ieee80211_ampdu_params *params)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tstruct rtw89_vif *rtwvif = rtwsta->rtwvif;\n\tu8 macid = rtwsta->mac_id;\n\tstruct sk_buff *skb;\n\tu8 entry_idx;\n\tint ret;\n\n\tret = valid ?\n\t      rtw89_core_acquire_sta_ba_entry(rtwdev, rtwsta, params->tid, &entry_idx) :\n\t      rtw89_core_release_sta_ba_entry(rtwdev, rtwsta, params->tid, &entry_idx);\n\tif (ret) {\n\t\t \n\t\trtw89_debug(rtwdev, RTW89_DBG_TXRX,\n\t\t\t    \"failed to %s entry tid=%d for h2c ba cam\\n\",\n\t\t\t    valid ? \"alloc\" : \"free\", params->tid);\n\t\treturn 0;\n\t}\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, H2C_BA_CAM_LEN);\n\tif (!skb) {\n\t\trtw89_err(rtwdev, \"failed to alloc skb for h2c ba cam\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_put(skb, H2C_BA_CAM_LEN);\n\tSET_BA_CAM_MACID(skb->data, macid);\n\tif (chip->bacam_ver == RTW89_BACAM_V0_EXT)\n\t\tSET_BA_CAM_ENTRY_IDX_V1(skb->data, entry_idx);\n\telse\n\t\tSET_BA_CAM_ENTRY_IDX(skb->data, entry_idx);\n\tif (!valid)\n\t\tgoto end;\n\tSET_BA_CAM_VALID(skb->data, valid);\n\tSET_BA_CAM_TID(skb->data, params->tid);\n\tif (params->buf_size > 64)\n\t\tSET_BA_CAM_BMAP_SIZE(skb->data, 4);\n\telse\n\t\tSET_BA_CAM_BMAP_SIZE(skb->data, 0);\n\t \n\tSET_BA_CAM_INIT_REQ(skb->data, 1);\n\tSET_BA_CAM_SSN(skb->data, params->ssn);\n\n\tif (chip->bacam_ver == RTW89_BACAM_V0_EXT) {\n\t\tSET_BA_CAM_STD_EN(skb->data, 1);\n\t\tSET_BA_CAM_BAND(skb->data, rtwvif->mac_idx);\n\t}\n\nend:\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_MAC,\n\t\t\t      H2C_CL_BA_CAM,\n\t\t\t      H2C_FUNC_MAC_BA_CAM, 0, 1,\n\t\t\t      H2C_BA_CAM_LEN);\n\n\tret = rtw89_h2c_tx(rtwdev, skb, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to send h2c\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\tdev_kfree_skb_any(skb);\n\n\treturn ret;\n}\n\nstatic int rtw89_fw_h2c_init_ba_cam_v0_ext(struct rtw89_dev *rtwdev,\n\t\t\t\t\t   u8 entry_idx, u8 uid)\n{\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, H2C_BA_CAM_LEN);\n\tif (!skb) {\n\t\trtw89_err(rtwdev, \"failed to alloc skb for dynamic h2c ba cam\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_put(skb, H2C_BA_CAM_LEN);\n\n\tSET_BA_CAM_VALID(skb->data, 1);\n\tSET_BA_CAM_ENTRY_IDX_V1(skb->data, entry_idx);\n\tSET_BA_CAM_UID(skb->data, uid);\n\tSET_BA_CAM_BAND(skb->data, 0);\n\tSET_BA_CAM_STD_EN(skb->data, 0);\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_MAC,\n\t\t\t      H2C_CL_BA_CAM,\n\t\t\t      H2C_FUNC_MAC_BA_CAM, 0, 1,\n\t\t\t      H2C_BA_CAM_LEN);\n\n\tret = rtw89_h2c_tx(rtwdev, skb, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to send h2c\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\tdev_kfree_skb_any(skb);\n\n\treturn ret;\n}\n\nvoid rtw89_fw_h2c_init_dynamic_ba_cam_v0_ext(struct rtw89_dev *rtwdev)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tu8 entry_idx = chip->bacam_num;\n\tu8 uid = 0;\n\tint i;\n\n\tfor (i = 0; i < chip->bacam_dynamic_num; i++) {\n\t\trtw89_fw_h2c_init_ba_cam_v0_ext(rtwdev, entry_idx, uid);\n\t\tentry_idx++;\n\t\tuid++;\n\t}\n}\n\n#define H2C_LOG_CFG_LEN 12\nint rtw89_fw_h2c_fw_log(struct rtw89_dev *rtwdev, bool enable)\n{\n\tstruct sk_buff *skb;\n\tu32 comp = enable ? BIT(RTW89_FW_LOG_COMP_INIT) | BIT(RTW89_FW_LOG_COMP_TASK) |\n\t\t\t    BIT(RTW89_FW_LOG_COMP_PS) | BIT(RTW89_FW_LOG_COMP_ERROR) : 0;\n\tint ret;\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, H2C_LOG_CFG_LEN);\n\tif (!skb) {\n\t\trtw89_err(rtwdev, \"failed to alloc skb for fw log cfg\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tskb_put(skb, H2C_LOG_CFG_LEN);\n\tSET_LOG_CFG_LEVEL(skb->data, RTW89_FW_LOG_LEVEL_LOUD);\n\tSET_LOG_CFG_PATH(skb->data, BIT(RTW89_FW_LOG_LEVEL_C2H));\n\tSET_LOG_CFG_COMP(skb->data, comp);\n\tSET_LOG_CFG_COMP_EXT(skb->data, 0);\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_MAC,\n\t\t\t      H2C_CL_FW_INFO,\n\t\t\t      H2C_FUNC_LOG_CFG, 0, 0,\n\t\t\t      H2C_LOG_CFG_LEN);\n\n\tret = rtw89_h2c_tx(rtwdev, skb, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to send h2c\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\tdev_kfree_skb_any(skb);\n\n\treturn ret;\n}\n\nstatic int rtw89_fw_h2c_add_general_pkt(struct rtw89_dev *rtwdev,\n\t\t\t\t\tstruct rtw89_vif *rtwvif,\n\t\t\t\t\tenum rtw89_fw_pkt_ofld_type type,\n\t\t\t\t\tu8 *id)\n{\n\tstruct ieee80211_vif *vif = rtwvif_to_vif(rtwvif);\n\tstruct rtw89_pktofld_info *info;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tswitch (type) {\n\tcase RTW89_PKT_OFLD_TYPE_PS_POLL:\n\t\tskb = ieee80211_pspoll_get(rtwdev->hw, vif);\n\t\tbreak;\n\tcase RTW89_PKT_OFLD_TYPE_PROBE_RSP:\n\t\tskb = ieee80211_proberesp_get(rtwdev->hw, vif);\n\t\tbreak;\n\tcase RTW89_PKT_OFLD_TYPE_NULL_DATA:\n\t\tskb = ieee80211_nullfunc_get(rtwdev->hw, vif, -1, false);\n\t\tbreak;\n\tcase RTW89_PKT_OFLD_TYPE_QOS_NULL:\n\t\tskb = ieee80211_nullfunc_get(rtwdev->hw, vif, -1, true);\n\t\tbreak;\n\tdefault:\n\t\tgoto err;\n\t}\n\n\tif (!skb)\n\t\tgoto err;\n\n\tret = rtw89_fw_h2c_add_pkt_offload(rtwdev, &info->id, skb);\n\tkfree_skb(skb);\n\n\tif (ret)\n\t\tgoto err;\n\n\tlist_add_tail(&info->list, &rtwvif->general_pkt_list);\n\t*id = info->id;\n\treturn 0;\n\nerr:\n\tkfree(info);\n\treturn -ENOMEM;\n}\n\nvoid rtw89_fw_release_general_pkt_list_vif(struct rtw89_dev *rtwdev,\n\t\t\t\t\t   struct rtw89_vif *rtwvif, bool notify_fw)\n{\n\tstruct list_head *pkt_list = &rtwvif->general_pkt_list;\n\tstruct rtw89_pktofld_info *info, *tmp;\n\n\tlist_for_each_entry_safe(info, tmp, pkt_list, list) {\n\t\tif (notify_fw)\n\t\t\trtw89_fw_h2c_del_pkt_offload(rtwdev, info->id);\n\t\telse\n\t\t\trtw89_core_release_bit_map(rtwdev->pkt_offload, info->id);\n\t\tlist_del(&info->list);\n\t\tkfree(info);\n\t}\n}\n\nvoid rtw89_fw_release_general_pkt_list(struct rtw89_dev *rtwdev, bool notify_fw)\n{\n\tstruct rtw89_vif *rtwvif;\n\n\trtw89_for_each_rtwvif(rtwdev, rtwvif)\n\t\trtw89_fw_release_general_pkt_list_vif(rtwdev, rtwvif, notify_fw);\n}\n\n#define H2C_GENERAL_PKT_LEN 6\n#define H2C_GENERAL_PKT_ID_UND 0xff\nint rtw89_fw_h2c_general_pkt(struct rtw89_dev *rtwdev,\n\t\t\t     struct rtw89_vif *rtwvif, u8 macid)\n{\n\tu8 pkt_id_ps_poll = H2C_GENERAL_PKT_ID_UND;\n\tu8 pkt_id_null = H2C_GENERAL_PKT_ID_UND;\n\tu8 pkt_id_qos_null = H2C_GENERAL_PKT_ID_UND;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\trtw89_fw_h2c_add_general_pkt(rtwdev, rtwvif,\n\t\t\t\t     RTW89_PKT_OFLD_TYPE_PS_POLL, &pkt_id_ps_poll);\n\trtw89_fw_h2c_add_general_pkt(rtwdev, rtwvif,\n\t\t\t\t     RTW89_PKT_OFLD_TYPE_NULL_DATA, &pkt_id_null);\n\trtw89_fw_h2c_add_general_pkt(rtwdev, rtwvif,\n\t\t\t\t     RTW89_PKT_OFLD_TYPE_QOS_NULL, &pkt_id_qos_null);\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, H2C_GENERAL_PKT_LEN);\n\tif (!skb) {\n\t\trtw89_err(rtwdev, \"failed to alloc skb for fw dl\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_put(skb, H2C_GENERAL_PKT_LEN);\n\tSET_GENERAL_PKT_MACID(skb->data, macid);\n\tSET_GENERAL_PKT_PROBRSP_ID(skb->data, H2C_GENERAL_PKT_ID_UND);\n\tSET_GENERAL_PKT_PSPOLL_ID(skb->data, pkt_id_ps_poll);\n\tSET_GENERAL_PKT_NULL_ID(skb->data, pkt_id_null);\n\tSET_GENERAL_PKT_QOS_NULL_ID(skb->data, pkt_id_qos_null);\n\tSET_GENERAL_PKT_CTS2SELF_ID(skb->data, H2C_GENERAL_PKT_ID_UND);\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_MAC,\n\t\t\t      H2C_CL_FW_INFO,\n\t\t\t      H2C_FUNC_MAC_GENERAL_PKT, 0, 1,\n\t\t\t      H2C_GENERAL_PKT_LEN);\n\n\tret = rtw89_h2c_tx(rtwdev, skb, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to send h2c\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\tdev_kfree_skb_any(skb);\n\n\treturn ret;\n}\n\n#define H2C_LPS_PARM_LEN 8\nint rtw89_fw_h2c_lps_parm(struct rtw89_dev *rtwdev,\n\t\t\t  struct rtw89_lps_parm *lps_param)\n{\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, H2C_LPS_PARM_LEN);\n\tif (!skb) {\n\t\trtw89_err(rtwdev, \"failed to alloc skb for fw dl\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_put(skb, H2C_LPS_PARM_LEN);\n\n\tSET_LPS_PARM_MACID(skb->data, lps_param->macid);\n\tSET_LPS_PARM_PSMODE(skb->data, lps_param->psmode);\n\tSET_LPS_PARM_LASTRPWM(skb->data, lps_param->lastrpwm);\n\tSET_LPS_PARM_RLBM(skb->data, 1);\n\tSET_LPS_PARM_SMARTPS(skb->data, 1);\n\tSET_LPS_PARM_AWAKEINTERVAL(skb->data, 1);\n\tSET_LPS_PARM_VOUAPSD(skb->data, 0);\n\tSET_LPS_PARM_VIUAPSD(skb->data, 0);\n\tSET_LPS_PARM_BEUAPSD(skb->data, 0);\n\tSET_LPS_PARM_BKUAPSD(skb->data, 0);\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_MAC,\n\t\t\t      H2C_CL_MAC_PS,\n\t\t\t      H2C_FUNC_MAC_LPS_PARM, 0, 1,\n\t\t\t      H2C_LPS_PARM_LEN);\n\n\tret = rtw89_h2c_tx(rtwdev, skb, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to send h2c\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\tdev_kfree_skb_any(skb);\n\n\treturn ret;\n}\n\n#define H2C_P2P_ACT_LEN 20\nint rtw89_fw_h2c_p2p_act(struct rtw89_dev *rtwdev, struct ieee80211_vif *vif,\n\t\t\t struct ieee80211_p2p_noa_desc *desc,\n\t\t\t u8 act, u8 noa_id)\n{\n\tstruct rtw89_vif *rtwvif = (struct rtw89_vif *)vif->drv_priv;\n\tbool p2p_type_gc = rtwvif->wifi_role == RTW89_WIFI_ROLE_P2P_CLIENT;\n\tu8 ctwindow_oppps = vif->bss_conf.p2p_noa_attr.oppps_ctwindow;\n\tstruct sk_buff *skb;\n\tu8 *cmd;\n\tint ret;\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, H2C_P2P_ACT_LEN);\n\tif (!skb) {\n\t\trtw89_err(rtwdev, \"failed to alloc skb for h2c p2p act\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_put(skb, H2C_P2P_ACT_LEN);\n\tcmd = skb->data;\n\n\tRTW89_SET_FWCMD_P2P_MACID(cmd, rtwvif->mac_id);\n\tRTW89_SET_FWCMD_P2P_P2PID(cmd, 0);\n\tRTW89_SET_FWCMD_P2P_NOAID(cmd, noa_id);\n\tRTW89_SET_FWCMD_P2P_ACT(cmd, act);\n\tRTW89_SET_FWCMD_P2P_TYPE(cmd, p2p_type_gc);\n\tRTW89_SET_FWCMD_P2P_ALL_SLEP(cmd, 0);\n\tif (desc) {\n\t\tRTW89_SET_FWCMD_NOA_START_TIME(cmd, desc->start_time);\n\t\tRTW89_SET_FWCMD_NOA_INTERVAL(cmd, desc->interval);\n\t\tRTW89_SET_FWCMD_NOA_DURATION(cmd, desc->duration);\n\t\tRTW89_SET_FWCMD_NOA_COUNT(cmd, desc->count);\n\t\tRTW89_SET_FWCMD_NOA_CTWINDOW(cmd, ctwindow_oppps);\n\t}\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_MAC, H2C_CL_MAC_PS,\n\t\t\t      H2C_FUNC_P2P_ACT, 0, 0,\n\t\t\t      H2C_P2P_ACT_LEN);\n\n\tret = rtw89_h2c_tx(rtwdev, skb, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to send h2c\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\tdev_kfree_skb_any(skb);\n\n\treturn ret;\n}\n\nstatic void __rtw89_fw_h2c_set_tx_path(struct rtw89_dev *rtwdev,\n\t\t\t\t       struct sk_buff *skb)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tstruct rtw89_hal *hal = &rtwdev->hal;\n\tu8 ntx_path;\n\tu8 map_b;\n\n\tif (chip->rf_path_num == 1) {\n\t\tntx_path = RF_A;\n\t\tmap_b = 0;\n\t} else {\n\t\tntx_path = hal->antenna_tx ? hal->antenna_tx : RF_B;\n\t\tmap_b = hal->antenna_tx == RF_AB ? 1 : 0;\n\t}\n\n\tSET_CMC_TBL_NTX_PATH_EN(skb->data, ntx_path);\n\tSET_CMC_TBL_PATH_MAP_A(skb->data, 0);\n\tSET_CMC_TBL_PATH_MAP_B(skb->data, map_b);\n\tSET_CMC_TBL_PATH_MAP_C(skb->data, 0);\n\tSET_CMC_TBL_PATH_MAP_D(skb->data, 0);\n}\n\n#define H2C_CMC_TBL_LEN 68\nint rtw89_fw_h2c_default_cmac_tbl(struct rtw89_dev *rtwdev,\n\t\t\t\t  struct rtw89_vif *rtwvif)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tstruct sk_buff *skb;\n\tu8 macid = rtwvif->mac_id;\n\tint ret;\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, H2C_CMC_TBL_LEN);\n\tif (!skb) {\n\t\trtw89_err(rtwdev, \"failed to alloc skb for fw dl\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_put(skb, H2C_CMC_TBL_LEN);\n\tSET_CTRL_INFO_MACID(skb->data, macid);\n\tSET_CTRL_INFO_OPERATION(skb->data, 1);\n\tif (chip->h2c_cctl_func_id == H2C_FUNC_MAC_CCTLINFO_UD) {\n\t\tSET_CMC_TBL_TXPWR_MODE(skb->data, 0);\n\t\t__rtw89_fw_h2c_set_tx_path(rtwdev, skb);\n\t\tSET_CMC_TBL_ANTSEL_A(skb->data, 0);\n\t\tSET_CMC_TBL_ANTSEL_B(skb->data, 0);\n\t\tSET_CMC_TBL_ANTSEL_C(skb->data, 0);\n\t\tSET_CMC_TBL_ANTSEL_D(skb->data, 0);\n\t}\n\tSET_CMC_TBL_DOPPLER_CTRL(skb->data, 0);\n\tSET_CMC_TBL_TXPWR_TOLERENCE(skb->data, 0);\n\tif (rtwvif->net_type == RTW89_NET_TYPE_AP_MODE)\n\t\tSET_CMC_TBL_DATA_DCM(skb->data, 0);\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_MAC, H2C_CL_MAC_FR_EXCHG,\n\t\t\t      chip->h2c_cctl_func_id, 0, 1,\n\t\t\t      H2C_CMC_TBL_LEN);\n\n\tret = rtw89_h2c_tx(rtwdev, skb, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to send h2c\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\tdev_kfree_skb_any(skb);\n\n\treturn ret;\n}\n\nstatic void __get_sta_he_pkt_padding(struct rtw89_dev *rtwdev,\n\t\t\t\t     struct ieee80211_sta *sta, u8 *pads)\n{\n\tbool ppe_th;\n\tu8 ppe16, ppe8;\n\tu8 nss = min(sta->deflink.rx_nss, rtwdev->hal.tx_nss) - 1;\n\tu8 ppe_thres_hdr = sta->deflink.he_cap.ppe_thres[0];\n\tu8 ru_bitmap;\n\tu8 n, idx, sh;\n\tu16 ppe;\n\tint i;\n\n\tif (!sta->deflink.he_cap.has_he)\n\t\treturn;\n\n\tppe_th = FIELD_GET(IEEE80211_HE_PHY_CAP6_PPE_THRESHOLD_PRESENT,\n\t\t\t   sta->deflink.he_cap.he_cap_elem.phy_cap_info[6]);\n\tif (!ppe_th) {\n\t\tu8 pad;\n\n\t\tpad = FIELD_GET(IEEE80211_HE_PHY_CAP9_NOMINAL_PKT_PADDING_MASK,\n\t\t\t\tsta->deflink.he_cap.he_cap_elem.phy_cap_info[9]);\n\n\t\tfor (i = 0; i < RTW89_PPE_BW_NUM; i++)\n\t\t\tpads[i] = pad;\n\n\t\treturn;\n\t}\n\n\tru_bitmap = FIELD_GET(IEEE80211_PPE_THRES_RU_INDEX_BITMASK_MASK, ppe_thres_hdr);\n\tn = hweight8(ru_bitmap);\n\tn = 7 + (n * IEEE80211_PPE_THRES_INFO_PPET_SIZE * 2) * nss;\n\n\tfor (i = 0; i < RTW89_PPE_BW_NUM; i++) {\n\t\tif (!(ru_bitmap & BIT(i))) {\n\t\t\tpads[i] = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tidx = n >> 3;\n\t\tsh = n & 7;\n\t\tn += IEEE80211_PPE_THRES_INFO_PPET_SIZE * 2;\n\n\t\tppe = le16_to_cpu(*((__le16 *)&sta->deflink.he_cap.ppe_thres[idx]));\n\t\tppe16 = (ppe >> sh) & IEEE80211_PPE_THRES_NSS_MASK;\n\t\tsh += IEEE80211_PPE_THRES_INFO_PPET_SIZE;\n\t\tppe8 = (ppe >> sh) & IEEE80211_PPE_THRES_NSS_MASK;\n\n\t\tif (ppe16 != 7 && ppe8 == 7)\n\t\t\tpads[i] = 2;\n\t\telse if (ppe8 != 7)\n\t\t\tpads[i] = 1;\n\t\telse\n\t\t\tpads[i] = 0;\n\t}\n}\n\nint rtw89_fw_h2c_assoc_cmac_tbl(struct rtw89_dev *rtwdev,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_sta *sta)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tstruct rtw89_sta *rtwsta = sta_to_rtwsta_safe(sta);\n\tstruct rtw89_vif *rtwvif = (struct rtw89_vif *)vif->drv_priv;\n\tconst struct rtw89_chan *chan = rtw89_chan_get(rtwdev,\n\t\t\t\t\t\t       rtwvif->sub_entity_idx);\n\tstruct sk_buff *skb;\n\tu8 pads[RTW89_PPE_BW_NUM];\n\tu8 mac_id = rtwsta ? rtwsta->mac_id : rtwvif->mac_id;\n\tu16 lowest_rate;\n\tint ret;\n\n\tmemset(pads, 0, sizeof(pads));\n\tif (sta)\n\t\t__get_sta_he_pkt_padding(rtwdev, sta, pads);\n\n\tif (vif->p2p)\n\t\tlowest_rate = RTW89_HW_RATE_OFDM6;\n\telse if (chan->band_type == RTW89_BAND_2G)\n\t\tlowest_rate = RTW89_HW_RATE_CCK1;\n\telse\n\t\tlowest_rate = RTW89_HW_RATE_OFDM6;\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, H2C_CMC_TBL_LEN);\n\tif (!skb) {\n\t\trtw89_err(rtwdev, \"failed to alloc skb for fw dl\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_put(skb, H2C_CMC_TBL_LEN);\n\tSET_CTRL_INFO_MACID(skb->data, mac_id);\n\tSET_CTRL_INFO_OPERATION(skb->data, 1);\n\tSET_CMC_TBL_DISRTSFB(skb->data, 1);\n\tSET_CMC_TBL_DISDATAFB(skb->data, 1);\n\tSET_CMC_TBL_RTS_RTY_LOWEST_RATE(skb->data, lowest_rate);\n\tSET_CMC_TBL_RTS_TXCNT_LMT_SEL(skb->data, 0);\n\tSET_CMC_TBL_DATA_TXCNT_LMT_SEL(skb->data, 0);\n\tif (vif->type == NL80211_IFTYPE_STATION)\n\t\tSET_CMC_TBL_ULDL(skb->data, 1);\n\telse\n\t\tSET_CMC_TBL_ULDL(skb->data, 0);\n\tSET_CMC_TBL_MULTI_PORT_ID(skb->data, rtwvif->port);\n\tif (chip->h2c_cctl_func_id == H2C_FUNC_MAC_CCTLINFO_UD_V1) {\n\t\tSET_CMC_TBL_NOMINAL_PKT_PADDING_V1(skb->data, pads[RTW89_CHANNEL_WIDTH_20]);\n\t\tSET_CMC_TBL_NOMINAL_PKT_PADDING40_V1(skb->data, pads[RTW89_CHANNEL_WIDTH_40]);\n\t\tSET_CMC_TBL_NOMINAL_PKT_PADDING80_V1(skb->data, pads[RTW89_CHANNEL_WIDTH_80]);\n\t\tSET_CMC_TBL_NOMINAL_PKT_PADDING160_V1(skb->data, pads[RTW89_CHANNEL_WIDTH_160]);\n\t} else if (chip->h2c_cctl_func_id == H2C_FUNC_MAC_CCTLINFO_UD) {\n\t\tSET_CMC_TBL_NOMINAL_PKT_PADDING(skb->data, pads[RTW89_CHANNEL_WIDTH_20]);\n\t\tSET_CMC_TBL_NOMINAL_PKT_PADDING40(skb->data, pads[RTW89_CHANNEL_WIDTH_40]);\n\t\tSET_CMC_TBL_NOMINAL_PKT_PADDING80(skb->data, pads[RTW89_CHANNEL_WIDTH_80]);\n\t\tSET_CMC_TBL_NOMINAL_PKT_PADDING160(skb->data, pads[RTW89_CHANNEL_WIDTH_160]);\n\t}\n\tif (sta)\n\t\tSET_CMC_TBL_BSR_QUEUE_SIZE_FORMAT(skb->data,\n\t\t\t\t\t\t  sta->deflink.he_cap.has_he);\n\tif (rtwvif->net_type == RTW89_NET_TYPE_AP_MODE)\n\t\tSET_CMC_TBL_DATA_DCM(skb->data, 0);\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_MAC, H2C_CL_MAC_FR_EXCHG,\n\t\t\t      chip->h2c_cctl_func_id, 0, 1,\n\t\t\t      H2C_CMC_TBL_LEN);\n\n\tret = rtw89_h2c_tx(rtwdev, skb, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to send h2c\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\tdev_kfree_skb_any(skb);\n\n\treturn ret;\n}\n\nint rtw89_fw_h2c_txtime_cmac_tbl(struct rtw89_dev *rtwdev,\n\t\t\t\t struct rtw89_sta *rtwsta)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, H2C_CMC_TBL_LEN);\n\tif (!skb) {\n\t\trtw89_err(rtwdev, \"failed to alloc skb for fw dl\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_put(skb, H2C_CMC_TBL_LEN);\n\tSET_CTRL_INFO_MACID(skb->data, rtwsta->mac_id);\n\tSET_CTRL_INFO_OPERATION(skb->data, 1);\n\tif (rtwsta->cctl_tx_time) {\n\t\tSET_CMC_TBL_AMPDU_TIME_SEL(skb->data, 1);\n\t\tSET_CMC_TBL_AMPDU_MAX_TIME(skb->data, rtwsta->ampdu_max_time);\n\t}\n\tif (rtwsta->cctl_tx_retry_limit) {\n\t\tSET_CMC_TBL_DATA_TXCNT_LMT_SEL(skb->data, 1);\n\t\tSET_CMC_TBL_DATA_TX_CNT_LMT(skb->data, rtwsta->data_tx_cnt_lmt);\n\t}\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_MAC, H2C_CL_MAC_FR_EXCHG,\n\t\t\t      chip->h2c_cctl_func_id, 0, 1,\n\t\t\t      H2C_CMC_TBL_LEN);\n\n\tret = rtw89_h2c_tx(rtwdev, skb, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to send h2c\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\tdev_kfree_skb_any(skb);\n\n\treturn ret;\n}\n\nint rtw89_fw_h2c_txpath_cmac_tbl(struct rtw89_dev *rtwdev,\n\t\t\t\t struct rtw89_sta *rtwsta)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tif (chip->h2c_cctl_func_id != H2C_FUNC_MAC_CCTLINFO_UD)\n\t\treturn 0;\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, H2C_CMC_TBL_LEN);\n\tif (!skb) {\n\t\trtw89_err(rtwdev, \"failed to alloc skb for fw dl\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_put(skb, H2C_CMC_TBL_LEN);\n\tSET_CTRL_INFO_MACID(skb->data, rtwsta->mac_id);\n\tSET_CTRL_INFO_OPERATION(skb->data, 1);\n\n\t__rtw89_fw_h2c_set_tx_path(rtwdev, skb);\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_MAC, H2C_CL_MAC_FR_EXCHG,\n\t\t\t      H2C_FUNC_MAC_CCTLINFO_UD, 0, 1,\n\t\t\t      H2C_CMC_TBL_LEN);\n\n\tret = rtw89_h2c_tx(rtwdev, skb, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to send h2c\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\tdev_kfree_skb_any(skb);\n\n\treturn ret;\n}\n\n#define H2C_BCN_BASE_LEN 12\nint rtw89_fw_h2c_update_beacon(struct rtw89_dev *rtwdev,\n\t\t\t       struct rtw89_vif *rtwvif)\n{\n\tstruct ieee80211_vif *vif = rtwvif_to_vif(rtwvif);\n\tconst struct rtw89_chan *chan = rtw89_chan_get(rtwdev,\n\t\t\t\t\t\t       rtwvif->sub_entity_idx);\n\tstruct sk_buff *skb;\n\tstruct sk_buff *skb_beacon;\n\tu16 tim_offset;\n\tint bcn_total_len;\n\tu16 beacon_rate;\n\tvoid *noa_data;\n\tu8 noa_len;\n\tint ret;\n\n\tif (vif->p2p)\n\t\tbeacon_rate = RTW89_HW_RATE_OFDM6;\n\telse if (chan->band_type == RTW89_BAND_2G)\n\t\tbeacon_rate = RTW89_HW_RATE_CCK1;\n\telse\n\t\tbeacon_rate = RTW89_HW_RATE_OFDM6;\n\n\tskb_beacon = ieee80211_beacon_get_tim(rtwdev->hw, vif, &tim_offset,\n\t\t\t\t\t      NULL, 0);\n\tif (!skb_beacon) {\n\t\trtw89_err(rtwdev, \"failed to get beacon skb\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tnoa_len = rtw89_p2p_noa_fetch(rtwvif, &noa_data);\n\tif (noa_len &&\n\t    (noa_len <= skb_tailroom(skb_beacon) ||\n\t     pskb_expand_head(skb_beacon, 0, noa_len, GFP_KERNEL) == 0)) {\n\t\tskb_put_data(skb_beacon, noa_data, noa_len);\n\t}\n\n\tbcn_total_len = H2C_BCN_BASE_LEN + skb_beacon->len;\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, bcn_total_len);\n\tif (!skb) {\n\t\trtw89_err(rtwdev, \"failed to alloc skb for fw dl\\n\");\n\t\tdev_kfree_skb_any(skb_beacon);\n\t\treturn -ENOMEM;\n\t}\n\tskb_put(skb, H2C_BCN_BASE_LEN);\n\n\tSET_BCN_UPD_PORT(skb->data, rtwvif->port);\n\tSET_BCN_UPD_MBSSID(skb->data, 0);\n\tSET_BCN_UPD_BAND(skb->data, rtwvif->mac_idx);\n\tSET_BCN_UPD_GRP_IE_OFST(skb->data, tim_offset);\n\tSET_BCN_UPD_MACID(skb->data, rtwvif->mac_id);\n\tSET_BCN_UPD_SSN_SEL(skb->data, RTW89_MGMT_HW_SSN_SEL);\n\tSET_BCN_UPD_SSN_MODE(skb->data, RTW89_MGMT_HW_SEQ_MODE);\n\tSET_BCN_UPD_RATE(skb->data, beacon_rate);\n\n\tskb_put_data(skb, skb_beacon->data, skb_beacon->len);\n\tdev_kfree_skb_any(skb_beacon);\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_MAC, H2C_CL_MAC_FR_EXCHG,\n\t\t\t      H2C_FUNC_MAC_BCN_UPD, 0, 1,\n\t\t\t      bcn_total_len);\n\n\tret = rtw89_h2c_tx(rtwdev, skb, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to send h2c\\n\");\n\t\tdev_kfree_skb_any(skb);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n#define H2C_ROLE_MAINTAIN_LEN 4\nint rtw89_fw_h2c_role_maintain(struct rtw89_dev *rtwdev,\n\t\t\t       struct rtw89_vif *rtwvif,\n\t\t\t       struct rtw89_sta *rtwsta,\n\t\t\t       enum rtw89_upd_mode upd_mode)\n{\n\tstruct sk_buff *skb;\n\tu8 mac_id = rtwsta ? rtwsta->mac_id : rtwvif->mac_id;\n\tu8 self_role;\n\tint ret;\n\n\tif (rtwvif->net_type == RTW89_NET_TYPE_AP_MODE) {\n\t\tif (rtwsta)\n\t\t\tself_role = RTW89_SELF_ROLE_AP_CLIENT;\n\t\telse\n\t\t\tself_role = rtwvif->self_role;\n\t} else {\n\t\tself_role = rtwvif->self_role;\n\t}\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, H2C_ROLE_MAINTAIN_LEN);\n\tif (!skb) {\n\t\trtw89_err(rtwdev, \"failed to alloc skb for h2c join\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_put(skb, H2C_ROLE_MAINTAIN_LEN);\n\tSET_FWROLE_MAINTAIN_MACID(skb->data, mac_id);\n\tSET_FWROLE_MAINTAIN_SELF_ROLE(skb->data, self_role);\n\tSET_FWROLE_MAINTAIN_UPD_MODE(skb->data, upd_mode);\n\tSET_FWROLE_MAINTAIN_WIFI_ROLE(skb->data, rtwvif->wifi_role);\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_MAC, H2C_CL_MAC_MEDIA_RPT,\n\t\t\t      H2C_FUNC_MAC_FWROLE_MAINTAIN, 0, 1,\n\t\t\t      H2C_ROLE_MAINTAIN_LEN);\n\n\tret = rtw89_h2c_tx(rtwdev, skb, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to send h2c\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\tdev_kfree_skb_any(skb);\n\n\treturn ret;\n}\n\n#define H2C_JOIN_INFO_LEN 4\nint rtw89_fw_h2c_join_info(struct rtw89_dev *rtwdev, struct rtw89_vif *rtwvif,\n\t\t\t   struct rtw89_sta *rtwsta, bool dis_conn)\n{\n\tstruct sk_buff *skb;\n\tu8 mac_id = rtwsta ? rtwsta->mac_id : rtwvif->mac_id;\n\tu8 self_role = rtwvif->self_role;\n\tu8 net_type = rtwvif->net_type;\n\tint ret;\n\n\tif (net_type == RTW89_NET_TYPE_AP_MODE && rtwsta) {\n\t\tself_role = RTW89_SELF_ROLE_AP_CLIENT;\n\t\tnet_type = dis_conn ? RTW89_NET_TYPE_NO_LINK : net_type;\n\t}\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, H2C_JOIN_INFO_LEN);\n\tif (!skb) {\n\t\trtw89_err(rtwdev, \"failed to alloc skb for h2c join\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_put(skb, H2C_JOIN_INFO_LEN);\n\tSET_JOININFO_MACID(skb->data, mac_id);\n\tSET_JOININFO_OP(skb->data, dis_conn);\n\tSET_JOININFO_BAND(skb->data, rtwvif->mac_idx);\n\tSET_JOININFO_WMM(skb->data, rtwvif->wmm);\n\tSET_JOININFO_TGR(skb->data, rtwvif->trigger);\n\tSET_JOININFO_ISHESTA(skb->data, 0);\n\tSET_JOININFO_DLBW(skb->data, 0);\n\tSET_JOININFO_TF_MAC_PAD(skb->data, 0);\n\tSET_JOININFO_DL_T_PE(skb->data, 0);\n\tSET_JOININFO_PORT_ID(skb->data, rtwvif->port);\n\tSET_JOININFO_NET_TYPE(skb->data, net_type);\n\tSET_JOININFO_WIFI_ROLE(skb->data, rtwvif->wifi_role);\n\tSET_JOININFO_SELF_ROLE(skb->data, self_role);\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_MAC, H2C_CL_MAC_MEDIA_RPT,\n\t\t\t      H2C_FUNC_MAC_JOININFO, 0, 1,\n\t\t\t      H2C_JOIN_INFO_LEN);\n\n\tret = rtw89_h2c_tx(rtwdev, skb, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to send h2c\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\tdev_kfree_skb_any(skb);\n\n\treturn ret;\n}\n\nint rtw89_fw_h2c_macid_pause(struct rtw89_dev *rtwdev, u8 sh, u8 grp,\n\t\t\t     bool pause)\n{\n\tstruct rtw89_fw_macid_pause_grp h2c = {{0}};\n\tu8 len = sizeof(struct rtw89_fw_macid_pause_grp);\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, H2C_JOIN_INFO_LEN);\n\tif (!skb) {\n\t\trtw89_err(rtwdev, \"failed to alloc skb for h2c join\\n\");\n\t\treturn -ENOMEM;\n\t}\n\th2c.mask_grp[grp] = cpu_to_le32(BIT(sh));\n\tif (pause)\n\t\th2c.pause_grp[grp] = cpu_to_le32(BIT(sh));\n\tskb_put_data(skb, &h2c, len);\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_MAC, H2C_CL_MAC_FW_OFLD,\n\t\t\t      H2C_FUNC_MAC_MACID_PAUSE, 1, 0,\n\t\t\t      len);\n\n\tret = rtw89_h2c_tx(rtwdev, skb, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to send h2c\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\tdev_kfree_skb_any(skb);\n\n\treturn ret;\n}\n\n#define H2C_EDCA_LEN 12\nint rtw89_fw_h2c_set_edca(struct rtw89_dev *rtwdev, struct rtw89_vif *rtwvif,\n\t\t\t  u8 ac, u32 val)\n{\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, H2C_EDCA_LEN);\n\tif (!skb) {\n\t\trtw89_err(rtwdev, \"failed to alloc skb for h2c edca\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_put(skb, H2C_EDCA_LEN);\n\tRTW89_SET_EDCA_SEL(skb->data, 0);\n\tRTW89_SET_EDCA_BAND(skb->data, rtwvif->mac_idx);\n\tRTW89_SET_EDCA_WMM(skb->data, 0);\n\tRTW89_SET_EDCA_AC(skb->data, ac);\n\tRTW89_SET_EDCA_PARAM(skb->data, val);\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_MAC, H2C_CL_MAC_FW_OFLD,\n\t\t\t      H2C_FUNC_USR_EDCA, 0, 1,\n\t\t\t      H2C_EDCA_LEN);\n\n\tret = rtw89_h2c_tx(rtwdev, skb, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to send h2c\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\tdev_kfree_skb_any(skb);\n\n\treturn ret;\n}\n\n#define H2C_TSF32_TOGL_LEN 4\nint rtw89_fw_h2c_tsf32_toggle(struct rtw89_dev *rtwdev, struct rtw89_vif *rtwvif,\n\t\t\t      bool en)\n{\n\tstruct sk_buff *skb;\n\tu16 early_us = en ? 2000 : 0;\n\tu8 *cmd;\n\tint ret;\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, H2C_TSF32_TOGL_LEN);\n\tif (!skb) {\n\t\trtw89_err(rtwdev, \"failed to alloc skb for h2c p2p act\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_put(skb, H2C_TSF32_TOGL_LEN);\n\tcmd = skb->data;\n\n\tRTW89_SET_FWCMD_TSF32_TOGL_BAND(cmd, rtwvif->mac_idx);\n\tRTW89_SET_FWCMD_TSF32_TOGL_EN(cmd, en);\n\tRTW89_SET_FWCMD_TSF32_TOGL_PORT(cmd, rtwvif->port);\n\tRTW89_SET_FWCMD_TSF32_TOGL_EARLY(cmd, early_us);\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_MAC, H2C_CL_MAC_FW_OFLD,\n\t\t\t      H2C_FUNC_TSF32_TOGL, 0, 0,\n\t\t\t      H2C_TSF32_TOGL_LEN);\n\n\tret = rtw89_h2c_tx(rtwdev, skb, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to send h2c\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\tdev_kfree_skb_any(skb);\n\n\treturn ret;\n}\n\n#define H2C_OFLD_CFG_LEN 8\nint rtw89_fw_h2c_set_ofld_cfg(struct rtw89_dev *rtwdev)\n{\n\tstatic const u8 cfg[] = {0x09, 0x00, 0x00, 0x00, 0x5e, 0x00, 0x00, 0x00};\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, H2C_OFLD_CFG_LEN);\n\tif (!skb) {\n\t\trtw89_err(rtwdev, \"failed to alloc skb for h2c ofld\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_put_data(skb, cfg, H2C_OFLD_CFG_LEN);\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_MAC, H2C_CL_MAC_FW_OFLD,\n\t\t\t      H2C_FUNC_OFLD_CFG, 0, 1,\n\t\t\t      H2C_OFLD_CFG_LEN);\n\n\tret = rtw89_h2c_tx(rtwdev, skb, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to send h2c\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\tdev_kfree_skb_any(skb);\n\n\treturn ret;\n}\n\nint rtw89_fw_h2c_set_bcn_fltr_cfg(struct rtw89_dev *rtwdev,\n\t\t\t\t  struct ieee80211_vif *vif,\n\t\t\t\t  bool connect)\n{\n\tstruct rtw89_vif *rtwvif = vif_to_rtwvif_safe(vif);\n\tstruct ieee80211_bss_conf *bss_conf = vif ? &vif->bss_conf : NULL;\n\tstruct rtw89_h2c_bcnfltr *h2c;\n\tu32 len = sizeof(*h2c);\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tif (!RTW89_CHK_FW_FEATURE(BEACON_FILTER, &rtwdev->fw))\n\t\treturn -EINVAL;\n\n\tif (!rtwvif || !bss_conf || rtwvif->net_type != RTW89_NET_TYPE_INFRA)\n\t\treturn -EINVAL;\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, len);\n\tif (!skb) {\n\t\trtw89_err(rtwdev, \"failed to alloc skb for h2c bcn filter\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tskb_put(skb, len);\n\th2c = (struct rtw89_h2c_bcnfltr *)skb->data;\n\n\th2c->w0 = le32_encode_bits(connect, RTW89_H2C_BCNFLTR_W0_MON_RSSI) |\n\t\t  le32_encode_bits(connect, RTW89_H2C_BCNFLTR_W0_MON_BCN) |\n\t\t  le32_encode_bits(connect, RTW89_H2C_BCNFLTR_W0_MON_EN) |\n\t\t  le32_encode_bits(RTW89_BCN_FLTR_OFFLOAD_MODE_DEFAULT,\n\t\t\t\t   RTW89_H2C_BCNFLTR_W0_MODE) |\n\t\t  le32_encode_bits(RTW89_BCN_LOSS_CNT, RTW89_H2C_BCNFLTR_W0_BCN_LOSS_CNT) |\n\t\t  le32_encode_bits(bss_conf->cqm_rssi_hyst, RTW89_H2C_BCNFLTR_W0_RSSI_HYST) |\n\t\t  le32_encode_bits(bss_conf->cqm_rssi_thold + MAX_RSSI,\n\t\t\t\t   RTW89_H2C_BCNFLTR_W0_RSSI_THRESHOLD) |\n\t\t  le32_encode_bits(rtwvif->mac_id, RTW89_H2C_BCNFLTR_W0_MAC_ID);\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_MAC, H2C_CL_MAC_FW_OFLD,\n\t\t\t      H2C_FUNC_CFG_BCNFLTR, 0, 1, len);\n\n\tret = rtw89_h2c_tx(rtwdev, skb, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to send h2c\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\tdev_kfree_skb_any(skb);\n\n\treturn ret;\n}\n\nint rtw89_fw_h2c_rssi_offload(struct rtw89_dev *rtwdev,\n\t\t\t      struct rtw89_rx_phy_ppdu *phy_ppdu)\n{\n\tstruct rtw89_h2c_ofld_rssi *h2c;\n\tu32 len = sizeof(*h2c);\n\tstruct sk_buff *skb;\n\ts8 rssi;\n\tint ret;\n\n\tif (!RTW89_CHK_FW_FEATURE(BEACON_FILTER, &rtwdev->fw))\n\t\treturn -EINVAL;\n\n\tif (!phy_ppdu)\n\t\treturn -EINVAL;\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, len);\n\tif (!skb) {\n\t\trtw89_err(rtwdev, \"failed to alloc skb for h2c rssi\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\trssi = phy_ppdu->rssi_avg >> RSSI_FACTOR;\n\tskb_put(skb, len);\n\th2c = (struct rtw89_h2c_ofld_rssi *)skb->data;\n\n\th2c->w0 = le32_encode_bits(phy_ppdu->mac_id, RTW89_H2C_OFLD_RSSI_W0_MACID) |\n\t\t  le32_encode_bits(1, RTW89_H2C_OFLD_RSSI_W0_NUM);\n\th2c->w1 = le32_encode_bits(rssi, RTW89_H2C_OFLD_RSSI_W1_VAL);\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_MAC, H2C_CL_MAC_FW_OFLD,\n\t\t\t      H2C_FUNC_OFLD_RSSI, 0, 1, len);\n\n\tret = rtw89_h2c_tx(rtwdev, skb, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to send h2c\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\tdev_kfree_skb_any(skb);\n\n\treturn ret;\n}\n\nint rtw89_fw_h2c_tp_offload(struct rtw89_dev *rtwdev, struct rtw89_vif *rtwvif)\n{\n\tstruct rtw89_traffic_stats *stats = &rtwvif->stats;\n\tstruct rtw89_h2c_ofld *h2c;\n\tu32 len = sizeof(*h2c);\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tif (rtwvif->net_type != RTW89_NET_TYPE_INFRA)\n\t\treturn -EINVAL;\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, len);\n\tif (!skb) {\n\t\trtw89_err(rtwdev, \"failed to alloc skb for h2c tp\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tskb_put(skb, len);\n\th2c = (struct rtw89_h2c_ofld *)skb->data;\n\n\th2c->w0 = le32_encode_bits(rtwvif->mac_id, RTW89_H2C_OFLD_W0_MAC_ID) |\n\t\t  le32_encode_bits(stats->tx_throughput, RTW89_H2C_OFLD_W0_TX_TP) |\n\t\t  le32_encode_bits(stats->rx_throughput, RTW89_H2C_OFLD_W0_RX_TP);\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_MAC, H2C_CL_MAC_FW_OFLD,\n\t\t\t      H2C_FUNC_OFLD_TP, 0, 1, len);\n\n\tret = rtw89_h2c_tx(rtwdev, skb, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to send h2c\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\tdev_kfree_skb_any(skb);\n\n\treturn ret;\n}\n\nint rtw89_fw_h2c_ra(struct rtw89_dev *rtwdev, struct rtw89_ra_info *ra, bool csi)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tstruct rtw89_h2c_ra_v1 *h2c_v1;\n\tstruct rtw89_h2c_ra *h2c;\n\tu32 len = sizeof(*h2c);\n\tbool format_v1 = false;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tif (chip->chip_gen == RTW89_CHIP_BE) {\n\t\tlen = sizeof(*h2c_v1);\n\t\tformat_v1 = true;\n\t}\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, len);\n\tif (!skb) {\n\t\trtw89_err(rtwdev, \"failed to alloc skb for h2c join\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_put(skb, len);\n\th2c = (struct rtw89_h2c_ra *)skb->data;\n\trtw89_debug(rtwdev, RTW89_DBG_RA,\n\t\t    \"ra cmd msk: %llx \", ra->ra_mask);\n\n\th2c->w0 = le32_encode_bits(ra->mode_ctrl, RTW89_H2C_RA_W0_MODE) |\n\t\t  le32_encode_bits(ra->bw_cap, RTW89_H2C_RA_W0_BW_CAP) |\n\t\t  le32_encode_bits(ra->macid, RTW89_H2C_RA_W0_MACID) |\n\t\t  le32_encode_bits(ra->dcm_cap, RTW89_H2C_RA_W0_DCM) |\n\t\t  le32_encode_bits(ra->er_cap, RTW89_H2C_RA_W0_ER) |\n\t\t  le32_encode_bits(ra->init_rate_lv, RTW89_H2C_RA_W0_INIT_RATE_LV) |\n\t\t  le32_encode_bits(ra->upd_all, RTW89_H2C_RA_W0_UPD_ALL) |\n\t\t  le32_encode_bits(ra->en_sgi, RTW89_H2C_RA_W0_SGI) |\n\t\t  le32_encode_bits(ra->ldpc_cap, RTW89_H2C_RA_W0_LDPC) |\n\t\t  le32_encode_bits(ra->stbc_cap, RTW89_H2C_RA_W0_STBC) |\n\t\t  le32_encode_bits(ra->ss_num, RTW89_H2C_RA_W0_SS_NUM) |\n\t\t  le32_encode_bits(ra->giltf, RTW89_H2C_RA_W0_GILTF) |\n\t\t  le32_encode_bits(ra->upd_bw_nss_mask, RTW89_H2C_RA_W0_UPD_BW_NSS_MASK) |\n\t\t  le32_encode_bits(ra->upd_mask, RTW89_H2C_RA_W0_UPD_MASK);\n\th2c->w1 = le32_encode_bits(ra->ra_mask, RTW89_H2C_RA_W1_RAMASK_LO32);\n\th2c->w2 = le32_encode_bits(ra->ra_mask >> 32, RTW89_H2C_RA_W2_RAMASK_HI32);\n\th2c->w3 = le32_encode_bits(ra->fix_giltf_en, RTW89_H2C_RA_W3_FIX_GILTF_EN) |\n\t\t  le32_encode_bits(ra->fix_giltf, RTW89_H2C_RA_W3_FIX_GILTF);\n\n\tif (!format_v1)\n\t\tgoto csi;\n\n\th2c_v1 = (struct rtw89_h2c_ra_v1 *)h2c;\n\th2c_v1->w4 = le32_encode_bits(ra->mode_ctrl, RTW89_H2C_RA_V1_W4_MODE_EHT) |\n\t\t     le32_encode_bits(ra->bw_cap, RTW89_H2C_RA_V1_W4_BW_EHT);\n\ncsi:\n\tif (!csi)\n\t\tgoto done;\n\n\th2c->w2 |= le32_encode_bits(1, RTW89_H2C_RA_W2_BFEE_CSI_CTL);\n\th2c->w3 |= le32_encode_bits(ra->band_num, RTW89_H2C_RA_W3_BAND_NUM) |\n\t\t   le32_encode_bits(ra->cr_tbl_sel, RTW89_H2C_RA_W3_CR_TBL_SEL) |\n\t\t   le32_encode_bits(ra->fixed_csi_rate_en, RTW89_H2C_RA_W3_FIXED_CSI_RATE_EN) |\n\t\t   le32_encode_bits(ra->ra_csi_rate_en, RTW89_H2C_RA_W3_RA_CSI_RATE_EN) |\n\t\t   le32_encode_bits(ra->csi_mcs_ss_idx, RTW89_H2C_RA_W3_FIXED_CSI_MCS_SS_IDX) |\n\t\t   le32_encode_bits(ra->csi_mode, RTW89_H2C_RA_W3_FIXED_CSI_MODE) |\n\t\t   le32_encode_bits(ra->csi_gi_ltf, RTW89_H2C_RA_W3_FIXED_CSI_GI_LTF) |\n\t\t   le32_encode_bits(ra->csi_bw, RTW89_H2C_RA_W3_FIXED_CSI_BW);\n\ndone:\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_OUTSRC, H2C_CL_OUTSRC_RA,\n\t\t\t      H2C_FUNC_OUTSRC_RA_MACIDCFG, 0, 0,\n\t\t\t      len);\n\n\tret = rtw89_h2c_tx(rtwdev, skb, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to send h2c\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\tdev_kfree_skb_any(skb);\n\n\treturn ret;\n}\n\nint rtw89_fw_h2c_cxdrv_init(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_dm *dm = &btc->dm;\n\tstruct rtw89_btc_init_info *init_info = &dm->init_info;\n\tstruct rtw89_btc_module *module = &init_info->module;\n\tstruct rtw89_btc_ant_info *ant = &module->ant;\n\tstruct rtw89_h2c_cxinit *h2c;\n\tu32 len = sizeof(*h2c);\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, len);\n\tif (!skb) {\n\t\trtw89_err(rtwdev, \"failed to alloc skb for h2c cxdrv_init\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_put(skb, len);\n\th2c = (struct rtw89_h2c_cxinit *)skb->data;\n\n\th2c->hdr.type = CXDRVINFO_INIT;\n\th2c->hdr.len = len - H2C_LEN_CXDRVHDR;\n\n\th2c->ant_type = ant->type;\n\th2c->ant_num = ant->num;\n\th2c->ant_iso = ant->isolation;\n\th2c->ant_info =\n\t\tu8_encode_bits(ant->single_pos, RTW89_H2C_CXINIT_ANT_INFO_POS) |\n\t\tu8_encode_bits(ant->diversity, RTW89_H2C_CXINIT_ANT_INFO_DIVERSITY) |\n\t\tu8_encode_bits(ant->btg_pos, RTW89_H2C_CXINIT_ANT_INFO_BTG_POS) |\n\t\tu8_encode_bits(ant->stream_cnt, RTW89_H2C_CXINIT_ANT_INFO_STREAM_CNT);\n\n\th2c->mod_rfe = module->rfe_type;\n\th2c->mod_cv = module->cv;\n\th2c->mod_info =\n\t\tu8_encode_bits(module->bt_solo, RTW89_H2C_CXINIT_MOD_INFO_BT_SOLO) |\n\t\tu8_encode_bits(module->bt_pos, RTW89_H2C_CXINIT_MOD_INFO_BT_POS) |\n\t\tu8_encode_bits(module->switch_type, RTW89_H2C_CXINIT_MOD_INFO_SW_TYPE) |\n\t\tu8_encode_bits(module->wa_type, RTW89_H2C_CXINIT_MOD_INFO_WA_TYPE);\n\th2c->mod_adie_kt = module->kt_ver_adie;\n\th2c->wl_gch = init_info->wl_guard_ch;\n\n\th2c->info =\n\t\tu8_encode_bits(init_info->wl_only, RTW89_H2C_CXINIT_INFO_WL_ONLY) |\n\t\tu8_encode_bits(init_info->wl_init_ok, RTW89_H2C_CXINIT_INFO_WL_INITOK) |\n\t\tu8_encode_bits(init_info->dbcc_en, RTW89_H2C_CXINIT_INFO_DBCC_EN) |\n\t\tu8_encode_bits(init_info->cx_other, RTW89_H2C_CXINIT_INFO_CX_OTHER) |\n\t\tu8_encode_bits(init_info->bt_only, RTW89_H2C_CXINIT_INFO_BT_ONLY);\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_OUTSRC, BTFC_SET,\n\t\t\t      SET_DRV_INFO, 0, 0,\n\t\t\t      len);\n\n\tret = rtw89_h2c_tx(rtwdev, skb, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to send h2c\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\tdev_kfree_skb_any(skb);\n\n\treturn ret;\n}\n\n#define PORT_DATA_OFFSET 4\n#define H2C_LEN_CXDRVINFO_ROLE_DBCC_LEN 12\n#define H2C_LEN_CXDRVINFO_ROLE_SIZE(max_role_num) \\\n\t(4 + 12 * (max_role_num) + H2C_LEN_CXDRVHDR)\n\nint rtw89_fw_h2c_cxdrv_role(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tconst struct rtw89_btc_ver *ver = btc->ver;\n\tstruct rtw89_btc_wl_info *wl = &btc->cx.wl;\n\tstruct rtw89_btc_wl_role_info *role_info = &wl->role_info;\n\tstruct rtw89_btc_wl_role_info_bpos *bpos = &role_info->role_map.role;\n\tstruct rtw89_btc_wl_active_role *active = role_info->active_role;\n\tstruct sk_buff *skb;\n\tu32 len;\n\tu8 offset = 0;\n\tu8 *cmd;\n\tint ret;\n\tint i;\n\n\tlen = H2C_LEN_CXDRVINFO_ROLE_SIZE(ver->max_role_num);\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, len);\n\tif (!skb) {\n\t\trtw89_err(rtwdev, \"failed to alloc skb for h2c cxdrv_role\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_put(skb, len);\n\tcmd = skb->data;\n\n\tRTW89_SET_FWCMD_CXHDR_TYPE(cmd, CXDRVINFO_ROLE);\n\tRTW89_SET_FWCMD_CXHDR_LEN(cmd, len - H2C_LEN_CXDRVHDR);\n\n\tRTW89_SET_FWCMD_CXROLE_CONNECT_CNT(cmd, role_info->connect_cnt);\n\tRTW89_SET_FWCMD_CXROLE_LINK_MODE(cmd, role_info->link_mode);\n\n\tRTW89_SET_FWCMD_CXROLE_ROLE_NONE(cmd, bpos->none);\n\tRTW89_SET_FWCMD_CXROLE_ROLE_STA(cmd, bpos->station);\n\tRTW89_SET_FWCMD_CXROLE_ROLE_AP(cmd, bpos->ap);\n\tRTW89_SET_FWCMD_CXROLE_ROLE_VAP(cmd, bpos->vap);\n\tRTW89_SET_FWCMD_CXROLE_ROLE_ADHOC(cmd, bpos->adhoc);\n\tRTW89_SET_FWCMD_CXROLE_ROLE_ADHOC_MASTER(cmd, bpos->adhoc_master);\n\tRTW89_SET_FWCMD_CXROLE_ROLE_MESH(cmd, bpos->mesh);\n\tRTW89_SET_FWCMD_CXROLE_ROLE_MONITOR(cmd, bpos->moniter);\n\tRTW89_SET_FWCMD_CXROLE_ROLE_P2P_DEV(cmd, bpos->p2p_device);\n\tRTW89_SET_FWCMD_CXROLE_ROLE_P2P_GC(cmd, bpos->p2p_gc);\n\tRTW89_SET_FWCMD_CXROLE_ROLE_P2P_GO(cmd, bpos->p2p_go);\n\tRTW89_SET_FWCMD_CXROLE_ROLE_NAN(cmd, bpos->nan);\n\n\tfor (i = 0; i < RTW89_PORT_NUM; i++, active++) {\n\t\tRTW89_SET_FWCMD_CXROLE_ACT_CONNECTED(cmd, active->connected, i, offset);\n\t\tRTW89_SET_FWCMD_CXROLE_ACT_PID(cmd, active->pid, i, offset);\n\t\tRTW89_SET_FWCMD_CXROLE_ACT_PHY(cmd, active->phy, i, offset);\n\t\tRTW89_SET_FWCMD_CXROLE_ACT_NOA(cmd, active->noa, i, offset);\n\t\tRTW89_SET_FWCMD_CXROLE_ACT_BAND(cmd, active->band, i, offset);\n\t\tRTW89_SET_FWCMD_CXROLE_ACT_CLIENT_PS(cmd, active->client_ps, i, offset);\n\t\tRTW89_SET_FWCMD_CXROLE_ACT_BW(cmd, active->bw, i, offset);\n\t\tRTW89_SET_FWCMD_CXROLE_ACT_ROLE(cmd, active->role, i, offset);\n\t\tRTW89_SET_FWCMD_CXROLE_ACT_CH(cmd, active->ch, i, offset);\n\t\tRTW89_SET_FWCMD_CXROLE_ACT_TX_LVL(cmd, active->tx_lvl, i, offset);\n\t\tRTW89_SET_FWCMD_CXROLE_ACT_RX_LVL(cmd, active->rx_lvl, i, offset);\n\t\tRTW89_SET_FWCMD_CXROLE_ACT_TX_RATE(cmd, active->tx_rate, i, offset);\n\t\tRTW89_SET_FWCMD_CXROLE_ACT_RX_RATE(cmd, active->rx_rate, i, offset);\n\t}\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_OUTSRC, BTFC_SET,\n\t\t\t      SET_DRV_INFO, 0, 0,\n\t\t\t      len);\n\n\tret = rtw89_h2c_tx(rtwdev, skb, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to send h2c\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\tdev_kfree_skb_any(skb);\n\n\treturn ret;\n}\n\n#define H2C_LEN_CXDRVINFO_ROLE_SIZE_V1(max_role_num) \\\n\t(4 + 16 * (max_role_num) + H2C_LEN_CXDRVINFO_ROLE_DBCC_LEN + H2C_LEN_CXDRVHDR)\n\nint rtw89_fw_h2c_cxdrv_role_v1(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tconst struct rtw89_btc_ver *ver = btc->ver;\n\tstruct rtw89_btc_wl_info *wl = &btc->cx.wl;\n\tstruct rtw89_btc_wl_role_info_v1 *role_info = &wl->role_info_v1;\n\tstruct rtw89_btc_wl_role_info_bpos *bpos = &role_info->role_map.role;\n\tstruct rtw89_btc_wl_active_role_v1 *active = role_info->active_role_v1;\n\tstruct sk_buff *skb;\n\tu32 len;\n\tu8 *cmd, offset;\n\tint ret;\n\tint i;\n\n\tlen = H2C_LEN_CXDRVINFO_ROLE_SIZE_V1(ver->max_role_num);\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, len);\n\tif (!skb) {\n\t\trtw89_err(rtwdev, \"failed to alloc skb for h2c cxdrv_role\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_put(skb, len);\n\tcmd = skb->data;\n\n\tRTW89_SET_FWCMD_CXHDR_TYPE(cmd, CXDRVINFO_ROLE);\n\tRTW89_SET_FWCMD_CXHDR_LEN(cmd, len - H2C_LEN_CXDRVHDR);\n\n\tRTW89_SET_FWCMD_CXROLE_CONNECT_CNT(cmd, role_info->connect_cnt);\n\tRTW89_SET_FWCMD_CXROLE_LINK_MODE(cmd, role_info->link_mode);\n\n\tRTW89_SET_FWCMD_CXROLE_ROLE_NONE(cmd, bpos->none);\n\tRTW89_SET_FWCMD_CXROLE_ROLE_STA(cmd, bpos->station);\n\tRTW89_SET_FWCMD_CXROLE_ROLE_AP(cmd, bpos->ap);\n\tRTW89_SET_FWCMD_CXROLE_ROLE_VAP(cmd, bpos->vap);\n\tRTW89_SET_FWCMD_CXROLE_ROLE_ADHOC(cmd, bpos->adhoc);\n\tRTW89_SET_FWCMD_CXROLE_ROLE_ADHOC_MASTER(cmd, bpos->adhoc_master);\n\tRTW89_SET_FWCMD_CXROLE_ROLE_MESH(cmd, bpos->mesh);\n\tRTW89_SET_FWCMD_CXROLE_ROLE_MONITOR(cmd, bpos->moniter);\n\tRTW89_SET_FWCMD_CXROLE_ROLE_P2P_DEV(cmd, bpos->p2p_device);\n\tRTW89_SET_FWCMD_CXROLE_ROLE_P2P_GC(cmd, bpos->p2p_gc);\n\tRTW89_SET_FWCMD_CXROLE_ROLE_P2P_GO(cmd, bpos->p2p_go);\n\tRTW89_SET_FWCMD_CXROLE_ROLE_NAN(cmd, bpos->nan);\n\n\toffset = PORT_DATA_OFFSET;\n\tfor (i = 0; i < RTW89_PORT_NUM; i++, active++) {\n\t\tRTW89_SET_FWCMD_CXROLE_ACT_CONNECTED(cmd, active->connected, i, offset);\n\t\tRTW89_SET_FWCMD_CXROLE_ACT_PID(cmd, active->pid, i, offset);\n\t\tRTW89_SET_FWCMD_CXROLE_ACT_PHY(cmd, active->phy, i, offset);\n\t\tRTW89_SET_FWCMD_CXROLE_ACT_NOA(cmd, active->noa, i, offset);\n\t\tRTW89_SET_FWCMD_CXROLE_ACT_BAND(cmd, active->band, i, offset);\n\t\tRTW89_SET_FWCMD_CXROLE_ACT_CLIENT_PS(cmd, active->client_ps, i, offset);\n\t\tRTW89_SET_FWCMD_CXROLE_ACT_BW(cmd, active->bw, i, offset);\n\t\tRTW89_SET_FWCMD_CXROLE_ACT_ROLE(cmd, active->role, i, offset);\n\t\tRTW89_SET_FWCMD_CXROLE_ACT_CH(cmd, active->ch, i, offset);\n\t\tRTW89_SET_FWCMD_CXROLE_ACT_TX_LVL(cmd, active->tx_lvl, i, offset);\n\t\tRTW89_SET_FWCMD_CXROLE_ACT_RX_LVL(cmd, active->rx_lvl, i, offset);\n\t\tRTW89_SET_FWCMD_CXROLE_ACT_TX_RATE(cmd, active->tx_rate, i, offset);\n\t\tRTW89_SET_FWCMD_CXROLE_ACT_RX_RATE(cmd, active->rx_rate, i, offset);\n\t\tRTW89_SET_FWCMD_CXROLE_ACT_NOA_DUR(cmd, active->noa_duration, i, offset);\n\t}\n\n\toffset = len - H2C_LEN_CXDRVINFO_ROLE_DBCC_LEN;\n\tRTW89_SET_FWCMD_CXROLE_MROLE_TYPE(cmd, role_info->mrole_type, offset);\n\tRTW89_SET_FWCMD_CXROLE_MROLE_NOA(cmd, role_info->mrole_noa_duration, offset);\n\tRTW89_SET_FWCMD_CXROLE_DBCC_EN(cmd, role_info->dbcc_en, offset);\n\tRTW89_SET_FWCMD_CXROLE_DBCC_CHG(cmd, role_info->dbcc_chg, offset);\n\tRTW89_SET_FWCMD_CXROLE_DBCC_2G_PHY(cmd, role_info->dbcc_2g_phy, offset);\n\tRTW89_SET_FWCMD_CXROLE_LINK_MODE_CHG(cmd, role_info->link_mode_chg, offset);\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_OUTSRC, BTFC_SET,\n\t\t\t      SET_DRV_INFO, 0, 0,\n\t\t\t      len);\n\n\tret = rtw89_h2c_tx(rtwdev, skb, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to send h2c\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\tdev_kfree_skb_any(skb);\n\n\treturn ret;\n}\n\n#define H2C_LEN_CXDRVINFO_ROLE_SIZE_V2(max_role_num) \\\n\t(4 + 8 * (max_role_num) + H2C_LEN_CXDRVINFO_ROLE_DBCC_LEN + H2C_LEN_CXDRVHDR)\n\nint rtw89_fw_h2c_cxdrv_role_v2(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tconst struct rtw89_btc_ver *ver = btc->ver;\n\tstruct rtw89_btc_wl_info *wl = &btc->cx.wl;\n\tstruct rtw89_btc_wl_role_info_v2 *role_info = &wl->role_info_v2;\n\tstruct rtw89_btc_wl_role_info_bpos *bpos = &role_info->role_map.role;\n\tstruct rtw89_btc_wl_active_role_v2 *active = role_info->active_role_v2;\n\tstruct sk_buff *skb;\n\tu32 len;\n\tu8 *cmd, offset;\n\tint ret;\n\tint i;\n\n\tlen = H2C_LEN_CXDRVINFO_ROLE_SIZE_V2(ver->max_role_num);\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, len);\n\tif (!skb) {\n\t\trtw89_err(rtwdev, \"failed to alloc skb for h2c cxdrv_role\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_put(skb, len);\n\tcmd = skb->data;\n\n\tRTW89_SET_FWCMD_CXHDR_TYPE(cmd, CXDRVINFO_ROLE);\n\tRTW89_SET_FWCMD_CXHDR_LEN(cmd, len - H2C_LEN_CXDRVHDR);\n\n\tRTW89_SET_FWCMD_CXROLE_CONNECT_CNT(cmd, role_info->connect_cnt);\n\tRTW89_SET_FWCMD_CXROLE_LINK_MODE(cmd, role_info->link_mode);\n\n\tRTW89_SET_FWCMD_CXROLE_ROLE_NONE(cmd, bpos->none);\n\tRTW89_SET_FWCMD_CXROLE_ROLE_STA(cmd, bpos->station);\n\tRTW89_SET_FWCMD_CXROLE_ROLE_AP(cmd, bpos->ap);\n\tRTW89_SET_FWCMD_CXROLE_ROLE_VAP(cmd, bpos->vap);\n\tRTW89_SET_FWCMD_CXROLE_ROLE_ADHOC(cmd, bpos->adhoc);\n\tRTW89_SET_FWCMD_CXROLE_ROLE_ADHOC_MASTER(cmd, bpos->adhoc_master);\n\tRTW89_SET_FWCMD_CXROLE_ROLE_MESH(cmd, bpos->mesh);\n\tRTW89_SET_FWCMD_CXROLE_ROLE_MONITOR(cmd, bpos->moniter);\n\tRTW89_SET_FWCMD_CXROLE_ROLE_P2P_DEV(cmd, bpos->p2p_device);\n\tRTW89_SET_FWCMD_CXROLE_ROLE_P2P_GC(cmd, bpos->p2p_gc);\n\tRTW89_SET_FWCMD_CXROLE_ROLE_P2P_GO(cmd, bpos->p2p_go);\n\tRTW89_SET_FWCMD_CXROLE_ROLE_NAN(cmd, bpos->nan);\n\n\toffset = PORT_DATA_OFFSET;\n\tfor (i = 0; i < RTW89_PORT_NUM; i++, active++) {\n\t\tRTW89_SET_FWCMD_CXROLE_ACT_CONNECTED_V2(cmd, active->connected, i, offset);\n\t\tRTW89_SET_FWCMD_CXROLE_ACT_PID_V2(cmd, active->pid, i, offset);\n\t\tRTW89_SET_FWCMD_CXROLE_ACT_PHY_V2(cmd, active->phy, i, offset);\n\t\tRTW89_SET_FWCMD_CXROLE_ACT_NOA_V2(cmd, active->noa, i, offset);\n\t\tRTW89_SET_FWCMD_CXROLE_ACT_BAND_V2(cmd, active->band, i, offset);\n\t\tRTW89_SET_FWCMD_CXROLE_ACT_CLIENT_PS_V2(cmd, active->client_ps, i, offset);\n\t\tRTW89_SET_FWCMD_CXROLE_ACT_BW_V2(cmd, active->bw, i, offset);\n\t\tRTW89_SET_FWCMD_CXROLE_ACT_ROLE_V2(cmd, active->role, i, offset);\n\t\tRTW89_SET_FWCMD_CXROLE_ACT_CH_V2(cmd, active->ch, i, offset);\n\t\tRTW89_SET_FWCMD_CXROLE_ACT_NOA_DUR_V2(cmd, active->noa_duration, i, offset);\n\t}\n\n\toffset = len - H2C_LEN_CXDRVINFO_ROLE_DBCC_LEN;\n\tRTW89_SET_FWCMD_CXROLE_MROLE_TYPE(cmd, role_info->mrole_type, offset);\n\tRTW89_SET_FWCMD_CXROLE_MROLE_NOA(cmd, role_info->mrole_noa_duration, offset);\n\tRTW89_SET_FWCMD_CXROLE_DBCC_EN(cmd, role_info->dbcc_en, offset);\n\tRTW89_SET_FWCMD_CXROLE_DBCC_CHG(cmd, role_info->dbcc_chg, offset);\n\tRTW89_SET_FWCMD_CXROLE_DBCC_2G_PHY(cmd, role_info->dbcc_2g_phy, offset);\n\tRTW89_SET_FWCMD_CXROLE_LINK_MODE_CHG(cmd, role_info->link_mode_chg, offset);\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_OUTSRC, BTFC_SET,\n\t\t\t      SET_DRV_INFO, 0, 0,\n\t\t\t      len);\n\n\tret = rtw89_h2c_tx(rtwdev, skb, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to send h2c\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\tdev_kfree_skb_any(skb);\n\n\treturn ret;\n}\n\n#define H2C_LEN_CXDRVINFO_CTRL (4 + H2C_LEN_CXDRVHDR)\nint rtw89_fw_h2c_cxdrv_ctrl(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tconst struct rtw89_btc_ver *ver = btc->ver;\n\tstruct rtw89_btc_ctrl *ctrl = &btc->ctrl;\n\tstruct sk_buff *skb;\n\tu8 *cmd;\n\tint ret;\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, H2C_LEN_CXDRVINFO_CTRL);\n\tif (!skb) {\n\t\trtw89_err(rtwdev, \"failed to alloc skb for h2c cxdrv_ctrl\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_put(skb, H2C_LEN_CXDRVINFO_CTRL);\n\tcmd = skb->data;\n\n\tRTW89_SET_FWCMD_CXHDR_TYPE(cmd, CXDRVINFO_CTRL);\n\tRTW89_SET_FWCMD_CXHDR_LEN(cmd, H2C_LEN_CXDRVINFO_CTRL - H2C_LEN_CXDRVHDR);\n\n\tRTW89_SET_FWCMD_CXCTRL_MANUAL(cmd, ctrl->manual);\n\tRTW89_SET_FWCMD_CXCTRL_IGNORE_BT(cmd, ctrl->igno_bt);\n\tRTW89_SET_FWCMD_CXCTRL_ALWAYS_FREERUN(cmd, ctrl->always_freerun);\n\tif (ver->fcxctrl == 0)\n\t\tRTW89_SET_FWCMD_CXCTRL_TRACE_STEP(cmd, ctrl->trace_step);\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_OUTSRC, BTFC_SET,\n\t\t\t      SET_DRV_INFO, 0, 0,\n\t\t\t      H2C_LEN_CXDRVINFO_CTRL);\n\n\tret = rtw89_h2c_tx(rtwdev, skb, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to send h2c\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\tdev_kfree_skb_any(skb);\n\n\treturn ret;\n}\n\n#define H2C_LEN_CXDRVINFO_TRX (28 + H2C_LEN_CXDRVHDR)\nint rtw89_fw_h2c_cxdrv_trx(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_trx_info *trx = &btc->dm.trx_info;\n\tstruct sk_buff *skb;\n\tu8 *cmd;\n\tint ret;\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, H2C_LEN_CXDRVINFO_TRX);\n\tif (!skb) {\n\t\trtw89_err(rtwdev, \"failed to alloc skb for h2c cxdrv_trx\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_put(skb, H2C_LEN_CXDRVINFO_TRX);\n\tcmd = skb->data;\n\n\tRTW89_SET_FWCMD_CXHDR_TYPE(cmd, CXDRVINFO_TRX);\n\tRTW89_SET_FWCMD_CXHDR_LEN(cmd, H2C_LEN_CXDRVINFO_TRX - H2C_LEN_CXDRVHDR);\n\n\tRTW89_SET_FWCMD_CXTRX_TXLV(cmd, trx->tx_lvl);\n\tRTW89_SET_FWCMD_CXTRX_RXLV(cmd, trx->rx_lvl);\n\tRTW89_SET_FWCMD_CXTRX_WLRSSI(cmd, trx->wl_rssi);\n\tRTW89_SET_FWCMD_CXTRX_BTRSSI(cmd, trx->bt_rssi);\n\tRTW89_SET_FWCMD_CXTRX_TXPWR(cmd, trx->tx_power);\n\tRTW89_SET_FWCMD_CXTRX_RXGAIN(cmd, trx->rx_gain);\n\tRTW89_SET_FWCMD_CXTRX_BTTXPWR(cmd, trx->bt_tx_power);\n\tRTW89_SET_FWCMD_CXTRX_BTRXGAIN(cmd, trx->bt_rx_gain);\n\tRTW89_SET_FWCMD_CXTRX_CN(cmd, trx->cn);\n\tRTW89_SET_FWCMD_CXTRX_NHM(cmd, trx->nhm);\n\tRTW89_SET_FWCMD_CXTRX_BTPROFILE(cmd, trx->bt_profile);\n\tRTW89_SET_FWCMD_CXTRX_RSVD2(cmd, trx->rsvd2);\n\tRTW89_SET_FWCMD_CXTRX_TXRATE(cmd, trx->tx_rate);\n\tRTW89_SET_FWCMD_CXTRX_RXRATE(cmd, trx->rx_rate);\n\tRTW89_SET_FWCMD_CXTRX_TXTP(cmd, trx->tx_tp);\n\tRTW89_SET_FWCMD_CXTRX_RXTP(cmd, trx->rx_tp);\n\tRTW89_SET_FWCMD_CXTRX_RXERRRA(cmd, trx->rx_err_ratio);\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_OUTSRC, BTFC_SET,\n\t\t\t      SET_DRV_INFO, 0, 0,\n\t\t\t      H2C_LEN_CXDRVINFO_TRX);\n\n\tret = rtw89_h2c_tx(rtwdev, skb, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to send h2c\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\tdev_kfree_skb_any(skb);\n\n\treturn ret;\n}\n\n#define H2C_LEN_CXDRVINFO_RFK (4 + H2C_LEN_CXDRVHDR)\nint rtw89_fw_h2c_cxdrv_rfk(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_wl_info *wl = &btc->cx.wl;\n\tstruct rtw89_btc_wl_rfk_info *rfk_info = &wl->rfk_info;\n\tstruct sk_buff *skb;\n\tu8 *cmd;\n\tint ret;\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, H2C_LEN_CXDRVINFO_RFK);\n\tif (!skb) {\n\t\trtw89_err(rtwdev, \"failed to alloc skb for h2c cxdrv_ctrl\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_put(skb, H2C_LEN_CXDRVINFO_RFK);\n\tcmd = skb->data;\n\n\tRTW89_SET_FWCMD_CXHDR_TYPE(cmd, CXDRVINFO_RFK);\n\tRTW89_SET_FWCMD_CXHDR_LEN(cmd, H2C_LEN_CXDRVINFO_RFK - H2C_LEN_CXDRVHDR);\n\n\tRTW89_SET_FWCMD_CXRFK_STATE(cmd, rfk_info->state);\n\tRTW89_SET_FWCMD_CXRFK_PATH_MAP(cmd, rfk_info->path_map);\n\tRTW89_SET_FWCMD_CXRFK_PHY_MAP(cmd, rfk_info->phy_map);\n\tRTW89_SET_FWCMD_CXRFK_BAND(cmd, rfk_info->band);\n\tRTW89_SET_FWCMD_CXRFK_TYPE(cmd, rfk_info->type);\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_OUTSRC, BTFC_SET,\n\t\t\t      SET_DRV_INFO, 0, 0,\n\t\t\t      H2C_LEN_CXDRVINFO_RFK);\n\n\tret = rtw89_h2c_tx(rtwdev, skb, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to send h2c\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\tdev_kfree_skb_any(skb);\n\n\treturn ret;\n}\n\n#define H2C_LEN_PKT_OFLD 4\nint rtw89_fw_h2c_del_pkt_offload(struct rtw89_dev *rtwdev, u8 id)\n{\n\tstruct rtw89_wait_info *wait = &rtwdev->mac.fw_ofld_wait;\n\tstruct sk_buff *skb;\n\tunsigned int cond;\n\tu8 *cmd;\n\tint ret;\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, H2C_LEN_PKT_OFLD);\n\tif (!skb) {\n\t\trtw89_err(rtwdev, \"failed to alloc skb for h2c pkt offload\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_put(skb, H2C_LEN_PKT_OFLD);\n\tcmd = skb->data;\n\n\tRTW89_SET_FWCMD_PACKET_OFLD_PKT_IDX(cmd, id);\n\tRTW89_SET_FWCMD_PACKET_OFLD_PKT_OP(cmd, RTW89_PKT_OFLD_OP_DEL);\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_MAC, H2C_CL_MAC_FW_OFLD,\n\t\t\t      H2C_FUNC_PACKET_OFLD, 1, 1,\n\t\t\t      H2C_LEN_PKT_OFLD);\n\n\tcond = RTW89_FW_OFLD_WAIT_COND_PKT_OFLD(id, RTW89_PKT_OFLD_OP_DEL);\n\n\tret = rtw89_h2c_tx_and_wait(rtwdev, skb, wait, cond);\n\tif (ret < 0) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_FW,\n\t\t\t    \"failed to del pkt ofld: id %d, ret %d\\n\",\n\t\t\t    id, ret);\n\t\treturn ret;\n\t}\n\n\trtw89_core_release_bit_map(rtwdev->pkt_offload, id);\n\treturn 0;\n}\n\nint rtw89_fw_h2c_add_pkt_offload(struct rtw89_dev *rtwdev, u8 *id,\n\t\t\t\t struct sk_buff *skb_ofld)\n{\n\tstruct rtw89_wait_info *wait = &rtwdev->mac.fw_ofld_wait;\n\tstruct sk_buff *skb;\n\tunsigned int cond;\n\tu8 *cmd;\n\tu8 alloc_id;\n\tint ret;\n\n\talloc_id = rtw89_core_acquire_bit_map(rtwdev->pkt_offload,\n\t\t\t\t\t      RTW89_MAX_PKT_OFLD_NUM);\n\tif (alloc_id == RTW89_MAX_PKT_OFLD_NUM)\n\t\treturn -ENOSPC;\n\n\t*id = alloc_id;\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, H2C_LEN_PKT_OFLD + skb_ofld->len);\n\tif (!skb) {\n\t\trtw89_err(rtwdev, \"failed to alloc skb for h2c pkt offload\\n\");\n\t\trtw89_core_release_bit_map(rtwdev->pkt_offload, alloc_id);\n\t\treturn -ENOMEM;\n\t}\n\tskb_put(skb, H2C_LEN_PKT_OFLD);\n\tcmd = skb->data;\n\n\tRTW89_SET_FWCMD_PACKET_OFLD_PKT_IDX(cmd, alloc_id);\n\tRTW89_SET_FWCMD_PACKET_OFLD_PKT_OP(cmd, RTW89_PKT_OFLD_OP_ADD);\n\tRTW89_SET_FWCMD_PACKET_OFLD_PKT_LENGTH(cmd, skb_ofld->len);\n\tskb_put_data(skb, skb_ofld->data, skb_ofld->len);\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_MAC, H2C_CL_MAC_FW_OFLD,\n\t\t\t      H2C_FUNC_PACKET_OFLD, 1, 1,\n\t\t\t      H2C_LEN_PKT_OFLD + skb_ofld->len);\n\n\tcond = RTW89_FW_OFLD_WAIT_COND_PKT_OFLD(alloc_id, RTW89_PKT_OFLD_OP_ADD);\n\n\tret = rtw89_h2c_tx_and_wait(rtwdev, skb, wait, cond);\n\tif (ret < 0) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_FW,\n\t\t\t    \"failed to add pkt ofld: id %d, ret %d\\n\",\n\t\t\t    alloc_id, ret);\n\t\trtw89_core_release_bit_map(rtwdev->pkt_offload, alloc_id);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n#define H2C_LEN_SCAN_LIST_OFFLOAD 4\nint rtw89_fw_h2c_scan_list_offload(struct rtw89_dev *rtwdev, int len,\n\t\t\t\t   struct list_head *chan_list)\n{\n\tstruct rtw89_wait_info *wait = &rtwdev->mac.fw_ofld_wait;\n\tstruct rtw89_mac_chinfo *ch_info;\n\tstruct sk_buff *skb;\n\tint skb_len = H2C_LEN_SCAN_LIST_OFFLOAD + len * RTW89_MAC_CHINFO_SIZE;\n\tunsigned int cond;\n\tu8 *cmd;\n\tint ret;\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, skb_len);\n\tif (!skb) {\n\t\trtw89_err(rtwdev, \"failed to alloc skb for h2c scan list\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_put(skb, H2C_LEN_SCAN_LIST_OFFLOAD);\n\tcmd = skb->data;\n\n\tRTW89_SET_FWCMD_SCANOFLD_CH_NUM(cmd, len);\n\t \n\tRTW89_SET_FWCMD_SCANOFLD_CH_SIZE(cmd, RTW89_MAC_CHINFO_SIZE / 4);\n\n\tlist_for_each_entry(ch_info, chan_list, list) {\n\t\tcmd = skb_put(skb, RTW89_MAC_CHINFO_SIZE);\n\n\t\tRTW89_SET_FWCMD_CHINFO_PERIOD(cmd, ch_info->period);\n\t\tRTW89_SET_FWCMD_CHINFO_DWELL(cmd, ch_info->dwell_time);\n\t\tRTW89_SET_FWCMD_CHINFO_CENTER_CH(cmd, ch_info->central_ch);\n\t\tRTW89_SET_FWCMD_CHINFO_PRI_CH(cmd, ch_info->pri_ch);\n\t\tRTW89_SET_FWCMD_CHINFO_BW(cmd, ch_info->bw);\n\t\tRTW89_SET_FWCMD_CHINFO_ACTION(cmd, ch_info->notify_action);\n\t\tRTW89_SET_FWCMD_CHINFO_NUM_PKT(cmd, ch_info->num_pkt);\n\t\tRTW89_SET_FWCMD_CHINFO_TX(cmd, ch_info->tx_pkt);\n\t\tRTW89_SET_FWCMD_CHINFO_PAUSE_DATA(cmd, ch_info->pause_data);\n\t\tRTW89_SET_FWCMD_CHINFO_BAND(cmd, ch_info->ch_band);\n\t\tRTW89_SET_FWCMD_CHINFO_PKT_ID(cmd, ch_info->probe_id);\n\t\tRTW89_SET_FWCMD_CHINFO_DFS(cmd, ch_info->dfs_ch);\n\t\tRTW89_SET_FWCMD_CHINFO_TX_NULL(cmd, ch_info->tx_null);\n\t\tRTW89_SET_FWCMD_CHINFO_RANDOM(cmd, ch_info->rand_seq_num);\n\t\tRTW89_SET_FWCMD_CHINFO_PKT0(cmd, ch_info->pkt_id[0]);\n\t\tRTW89_SET_FWCMD_CHINFO_PKT1(cmd, ch_info->pkt_id[1]);\n\t\tRTW89_SET_FWCMD_CHINFO_PKT2(cmd, ch_info->pkt_id[2]);\n\t\tRTW89_SET_FWCMD_CHINFO_PKT3(cmd, ch_info->pkt_id[3]);\n\t\tRTW89_SET_FWCMD_CHINFO_PKT4(cmd, ch_info->pkt_id[4]);\n\t\tRTW89_SET_FWCMD_CHINFO_PKT5(cmd, ch_info->pkt_id[5]);\n\t\tRTW89_SET_FWCMD_CHINFO_PKT6(cmd, ch_info->pkt_id[6]);\n\t\tRTW89_SET_FWCMD_CHINFO_PKT7(cmd, ch_info->pkt_id[7]);\n\t}\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_MAC, H2C_CL_MAC_FW_OFLD,\n\t\t\t      H2C_FUNC_ADD_SCANOFLD_CH, 1, 1, skb_len);\n\n\tcond = RTW89_FW_OFLD_WAIT_COND(0, H2C_FUNC_ADD_SCANOFLD_CH);\n\n\tret = rtw89_h2c_tx_and_wait(rtwdev, skb, wait, cond);\n\tif (ret) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_FW, \"failed to add scan ofld ch\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint rtw89_fw_h2c_scan_offload(struct rtw89_dev *rtwdev,\n\t\t\t      struct rtw89_scan_option *option,\n\t\t\t      struct rtw89_vif *rtwvif)\n{\n\tstruct rtw89_wait_info *wait = &rtwdev->mac.fw_ofld_wait;\n\tstruct rtw89_chan *op = &rtwdev->scan_info.op_chan;\n\tstruct rtw89_h2c_scanofld *h2c;\n\tu32 len = sizeof(*h2c);\n\tstruct sk_buff *skb;\n\tunsigned int cond;\n\tint ret;\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, len);\n\tif (!skb) {\n\t\trtw89_err(rtwdev, \"failed to alloc skb for h2c scan offload\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_put(skb, len);\n\th2c = (struct rtw89_h2c_scanofld *)skb->data;\n\n\th2c->w0 = le32_encode_bits(rtwvif->mac_id, RTW89_H2C_SCANOFLD_W0_MACID) |\n\t\t  le32_encode_bits(rtwvif->port, RTW89_H2C_SCANOFLD_W0_PORT_ID) |\n\t\t  le32_encode_bits(RTW89_PHY_0, RTW89_H2C_SCANOFLD_W0_BAND) |\n\t\t  le32_encode_bits(option->enable, RTW89_H2C_SCANOFLD_W0_OPERATION);\n\n\th2c->w1 = le32_encode_bits(true, RTW89_H2C_SCANOFLD_W1_NOTIFY_END) |\n\t\t  le32_encode_bits(option->target_ch_mode,\n\t\t\t\t   RTW89_H2C_SCANOFLD_W1_TARGET_CH_MODE) |\n\t\t  le32_encode_bits(RTW89_SCAN_IMMEDIATE,\n\t\t\t\t   RTW89_H2C_SCANOFLD_W1_START_MODE) |\n\t\t  le32_encode_bits(RTW89_SCAN_ONCE, RTW89_H2C_SCANOFLD_W1_SCAN_TYPE);\n\n\tif (option->target_ch_mode) {\n\t\th2c->w1 |= le32_encode_bits(op->band_width,\n\t\t\t\t\t    RTW89_H2C_SCANOFLD_W1_TARGET_CH_BW) |\n\t\t\t   le32_encode_bits(op->primary_channel,\n\t\t\t\t\t    RTW89_H2C_SCANOFLD_W1_TARGET_PRI_CH) |\n\t\t\t   le32_encode_bits(op->channel,\n\t\t\t\t\t    RTW89_H2C_SCANOFLD_W1_TARGET_CENTRAL_CH);\n\t\th2c->w0 |= le32_encode_bits(op->band_type,\n\t\t\t\t\t    RTW89_H2C_SCANOFLD_W0_TARGET_CH_BAND);\n\t}\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_MAC, H2C_CL_MAC_FW_OFLD,\n\t\t\t      H2C_FUNC_SCANOFLD, 1, 1,\n\t\t\t      len);\n\n\tcond = RTW89_FW_OFLD_WAIT_COND(0, H2C_FUNC_SCANOFLD);\n\n\tret = rtw89_h2c_tx_and_wait(rtwdev, skb, wait, cond);\n\tif (ret) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_FW, \"failed to scan ofld\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint rtw89_fw_h2c_rf_reg(struct rtw89_dev *rtwdev,\n\t\t\tstruct rtw89_fw_h2c_rf_reg_info *info,\n\t\t\tu16 len, u8 page)\n{\n\tstruct sk_buff *skb;\n\tu8 class = info->rf_path == RF_PATH_A ?\n\t\t   H2C_CL_OUTSRC_RF_REG_A : H2C_CL_OUTSRC_RF_REG_B;\n\tint ret;\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, len);\n\tif (!skb) {\n\t\trtw89_err(rtwdev, \"failed to alloc skb for h2c rf reg\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_put_data(skb, info->rtw89_phy_config_rf_h2c[page], len);\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_OUTSRC, class, page, 0, 0,\n\t\t\t      len);\n\n\tret = rtw89_h2c_tx(rtwdev, skb, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to send h2c\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\tdev_kfree_skb_any(skb);\n\n\treturn ret;\n}\n\nint rtw89_fw_h2c_rf_ntfy_mcc(struct rtw89_dev *rtwdev)\n{\n\tconst struct rtw89_chan *chan = rtw89_chan_get(rtwdev, RTW89_SUB_ENTITY_0);\n\tstruct rtw89_rfk_mcc_info *rfk_mcc = &rtwdev->rfk_mcc;\n\tstruct rtw89_fw_h2c_rf_get_mccch *mccch;\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, sizeof(*mccch));\n\tif (!skb) {\n\t\trtw89_err(rtwdev, \"failed to alloc skb for h2c cxdrv_ctrl\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_put(skb, sizeof(*mccch));\n\tmccch = (struct rtw89_fw_h2c_rf_get_mccch *)skb->data;\n\n\tmccch->ch_0 = cpu_to_le32(rfk_mcc->ch[0]);\n\tmccch->ch_1 = cpu_to_le32(rfk_mcc->ch[1]);\n\tmccch->band_0 = cpu_to_le32(rfk_mcc->band[0]);\n\tmccch->band_1 = cpu_to_le32(rfk_mcc->band[1]);\n\tmccch->current_channel = cpu_to_le32(chan->channel);\n\tmccch->current_band_type = cpu_to_le32(chan->band_type);\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_OUTSRC, H2C_CL_OUTSRC_RF_FW_NOTIFY,\n\t\t\t      H2C_FUNC_OUTSRC_RF_GET_MCCCH, 0, 0,\n\t\t\t      sizeof(*mccch));\n\n\tret = rtw89_h2c_tx(rtwdev, skb, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to send h2c\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\tdev_kfree_skb_any(skb);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(rtw89_fw_h2c_rf_ntfy_mcc);\n\nint rtw89_fw_h2c_raw_with_hdr(struct rtw89_dev *rtwdev,\n\t\t\t      u8 h2c_class, u8 h2c_func, u8 *buf, u16 len,\n\t\t\t      bool rack, bool dack)\n{\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, len);\n\tif (!skb) {\n\t\trtw89_err(rtwdev, \"failed to alloc skb for raw with hdr\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_put_data(skb, buf, len);\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_OUTSRC, h2c_class, h2c_func, rack, dack,\n\t\t\t      len);\n\n\tret = rtw89_h2c_tx(rtwdev, skb, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to send h2c\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\tdev_kfree_skb_any(skb);\n\n\treturn ret;\n}\n\nint rtw89_fw_h2c_raw(struct rtw89_dev *rtwdev, const u8 *buf, u16 len)\n{\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = rtw89_fw_h2c_alloc_skb_no_hdr(rtwdev, len);\n\tif (!skb) {\n\t\trtw89_err(rtwdev, \"failed to alloc skb for h2c raw\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tskb_put_data(skb, buf, len);\n\n\tret = rtw89_h2c_tx(rtwdev, skb, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to send h2c\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\tdev_kfree_skb_any(skb);\n\n\treturn ret;\n}\n\nvoid rtw89_fw_send_all_early_h2c(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_early_h2c *early_h2c;\n\n\tlockdep_assert_held(&rtwdev->mutex);\n\n\tlist_for_each_entry(early_h2c, &rtwdev->early_h2c_list, list) {\n\t\trtw89_fw_h2c_raw(rtwdev, early_h2c->h2c, early_h2c->h2c_len);\n\t}\n}\n\nvoid rtw89_fw_free_all_early_h2c(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_early_h2c *early_h2c, *tmp;\n\n\tmutex_lock(&rtwdev->mutex);\n\tlist_for_each_entry_safe(early_h2c, tmp, &rtwdev->early_h2c_list, list) {\n\t\tlist_del(&early_h2c->list);\n\t\tkfree(early_h2c->h2c);\n\t\tkfree(early_h2c);\n\t}\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nstatic void rtw89_fw_c2h_parse_attr(struct sk_buff *c2h)\n{\n\tconst struct rtw89_c2h_hdr *hdr = (const struct rtw89_c2h_hdr *)c2h->data;\n\tstruct rtw89_fw_c2h_attr *attr = RTW89_SKB_C2H_CB(c2h);\n\n\tattr->category = le32_get_bits(hdr->w0, RTW89_C2H_HDR_W0_CATEGORY);\n\tattr->class = le32_get_bits(hdr->w0, RTW89_C2H_HDR_W0_CLASS);\n\tattr->func = le32_get_bits(hdr->w0, RTW89_C2H_HDR_W0_FUNC);\n\tattr->len = le32_get_bits(hdr->w1, RTW89_C2H_HDR_W1_LEN);\n}\n\nstatic bool rtw89_fw_c2h_chk_atomic(struct rtw89_dev *rtwdev,\n\t\t\t\t    struct sk_buff *c2h)\n{\n\tstruct rtw89_fw_c2h_attr *attr = RTW89_SKB_C2H_CB(c2h);\n\tu8 category = attr->category;\n\tu8 class = attr->class;\n\tu8 func = attr->func;\n\n\tswitch (category) {\n\tdefault:\n\t\treturn false;\n\tcase RTW89_C2H_CAT_MAC:\n\t\treturn rtw89_mac_c2h_chk_atomic(rtwdev, class, func);\n\t}\n}\n\nvoid rtw89_fw_c2h_irqsafe(struct rtw89_dev *rtwdev, struct sk_buff *c2h)\n{\n\trtw89_fw_c2h_parse_attr(c2h);\n\tif (!rtw89_fw_c2h_chk_atomic(rtwdev, c2h))\n\t\tgoto enqueue;\n\n\trtw89_fw_c2h_cmd_handle(rtwdev, c2h);\n\tdev_kfree_skb_any(c2h);\n\treturn;\n\nenqueue:\n\tskb_queue_tail(&rtwdev->c2h_queue, c2h);\n\tieee80211_queue_work(rtwdev->hw, &rtwdev->c2h_work);\n}\n\nstatic void rtw89_fw_c2h_cmd_handle(struct rtw89_dev *rtwdev,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct rtw89_fw_c2h_attr *attr = RTW89_SKB_C2H_CB(skb);\n\tu8 category = attr->category;\n\tu8 class = attr->class;\n\tu8 func = attr->func;\n\tu16 len = attr->len;\n\tbool dump = true;\n\n\tif (!test_bit(RTW89_FLAG_RUNNING, rtwdev->flags))\n\t\treturn;\n\n\tswitch (category) {\n\tcase RTW89_C2H_CAT_TEST:\n\t\tbreak;\n\tcase RTW89_C2H_CAT_MAC:\n\t\trtw89_mac_c2h_handle(rtwdev, skb, len, class, func);\n\t\tif (class == RTW89_MAC_C2H_CLASS_INFO &&\n\t\t    func == RTW89_MAC_C2H_FUNC_C2H_LOG)\n\t\t\tdump = false;\n\t\tbreak;\n\tcase RTW89_C2H_CAT_OUTSRC:\n\t\tif (class >= RTW89_PHY_C2H_CLASS_BTC_MIN &&\n\t\t    class <= RTW89_PHY_C2H_CLASS_BTC_MAX)\n\t\t\trtw89_btc_c2h_handle(rtwdev, skb, len, class, func);\n\t\telse\n\t\t\trtw89_phy_c2h_handle(rtwdev, skb, len, class, func);\n\t\tbreak;\n\t}\n\n\tif (dump)\n\t\trtw89_hex_dump(rtwdev, RTW89_DBG_FW, \"C2H: \", skb->data, skb->len);\n}\n\nvoid rtw89_fw_c2h_work(struct work_struct *work)\n{\n\tstruct rtw89_dev *rtwdev = container_of(work, struct rtw89_dev,\n\t\t\t\t\t\tc2h_work);\n\tstruct sk_buff *skb, *tmp;\n\n\tskb_queue_walk_safe(&rtwdev->c2h_queue, skb, tmp) {\n\t\tskb_unlink(skb, &rtwdev->c2h_queue);\n\t\tmutex_lock(&rtwdev->mutex);\n\t\trtw89_fw_c2h_cmd_handle(rtwdev, skb);\n\t\tmutex_unlock(&rtwdev->mutex);\n\t\tdev_kfree_skb_any(skb);\n\t}\n}\n\nstatic int rtw89_fw_write_h2c_reg(struct rtw89_dev *rtwdev,\n\t\t\t\t  struct rtw89_mac_h2c_info *info)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tstruct rtw89_fw_info *fw_info = &rtwdev->fw;\n\tconst u32 *h2c_reg = chip->h2c_regs;\n\tu8 i, val, len;\n\tint ret;\n\n\tret = read_poll_timeout(rtw89_read8, val, val == 0, 1000, 5000, false,\n\t\t\t\trtwdev, chip->h2c_ctrl_reg);\n\tif (ret) {\n\t\trtw89_warn(rtwdev, \"FW does not process h2c registers\\n\");\n\t\treturn ret;\n\t}\n\n\tlen = DIV_ROUND_UP(info->content_len + RTW89_H2CREG_HDR_LEN,\n\t\t\t   sizeof(info->u.h2creg[0]));\n\n\tu32p_replace_bits(&info->u.hdr.w0, info->id, RTW89_H2CREG_HDR_FUNC_MASK);\n\tu32p_replace_bits(&info->u.hdr.w0, len, RTW89_H2CREG_HDR_LEN_MASK);\n\n\tfor (i = 0; i < RTW89_H2CREG_MAX; i++)\n\t\trtw89_write32(rtwdev, h2c_reg[i], info->u.h2creg[i]);\n\n\tfw_info->h2c_counter++;\n\trtw89_write8_mask(rtwdev, chip->h2c_counter_reg.addr,\n\t\t\t  chip->h2c_counter_reg.mask, fw_info->h2c_counter);\n\trtw89_write8(rtwdev, chip->h2c_ctrl_reg, B_AX_H2CREG_TRIGGER);\n\n\treturn 0;\n}\n\nstatic int rtw89_fw_read_c2h_reg(struct rtw89_dev *rtwdev,\n\t\t\t\t struct rtw89_mac_c2h_info *info)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tstruct rtw89_fw_info *fw_info = &rtwdev->fw;\n\tconst u32 *c2h_reg = chip->c2h_regs;\n\tu32 ret;\n\tu8 i, val;\n\n\tinfo->id = RTW89_FWCMD_C2HREG_FUNC_NULL;\n\n\tret = read_poll_timeout_atomic(rtw89_read8, val, val, 1,\n\t\t\t\t       RTW89_C2H_TIMEOUT, false, rtwdev,\n\t\t\t\t       chip->c2h_ctrl_reg);\n\tif (ret) {\n\t\trtw89_warn(rtwdev, \"c2h reg timeout\\n\");\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < RTW89_C2HREG_MAX; i++)\n\t\tinfo->u.c2hreg[i] = rtw89_read32(rtwdev, c2h_reg[i]);\n\n\trtw89_write8(rtwdev, chip->c2h_ctrl_reg, 0);\n\n\tinfo->id = u32_get_bits(info->u.hdr.w0, RTW89_C2HREG_HDR_FUNC_MASK);\n\tinfo->content_len =\n\t\t(u32_get_bits(info->u.hdr.w0, RTW89_C2HREG_HDR_LEN_MASK) << 2) -\n\t\tRTW89_C2HREG_HDR_LEN;\n\n\tfw_info->c2h_counter++;\n\trtw89_write8_mask(rtwdev, chip->c2h_counter_reg.addr,\n\t\t\t  chip->c2h_counter_reg.mask, fw_info->c2h_counter);\n\n\treturn 0;\n}\n\nint rtw89_fw_msg_reg(struct rtw89_dev *rtwdev,\n\t\t     struct rtw89_mac_h2c_info *h2c_info,\n\t\t     struct rtw89_mac_c2h_info *c2h_info)\n{\n\tu32 ret;\n\n\tif (h2c_info && h2c_info->id != RTW89_FWCMD_H2CREG_FUNC_GET_FEATURE)\n\t\tlockdep_assert_held(&rtwdev->mutex);\n\n\tif (!h2c_info && !c2h_info)\n\t\treturn -EINVAL;\n\n\tif (!h2c_info)\n\t\tgoto recv_c2h;\n\n\tret = rtw89_fw_write_h2c_reg(rtwdev, h2c_info);\n\tif (ret)\n\t\treturn ret;\n\nrecv_c2h:\n\tif (!c2h_info)\n\t\treturn 0;\n\n\tret = rtw89_fw_read_c2h_reg(rtwdev, c2h_info);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nvoid rtw89_fw_st_dbg_dump(struct rtw89_dev *rtwdev)\n{\n\tif (!test_bit(RTW89_FLAG_POWERON, rtwdev->flags)) {\n\t\trtw89_err(rtwdev, \"[ERR]pwr is off\\n\");\n\t\treturn;\n\t}\n\n\trtw89_info(rtwdev, \"FW status = 0x%x\\n\", rtw89_read32(rtwdev, R_AX_UDM0));\n\trtw89_info(rtwdev, \"FW BADADDR = 0x%x\\n\", rtw89_read32(rtwdev, R_AX_UDM1));\n\trtw89_info(rtwdev, \"FW EPC/RA = 0x%x\\n\", rtw89_read32(rtwdev, R_AX_UDM2));\n\trtw89_info(rtwdev, \"FW MISC = 0x%x\\n\", rtw89_read32(rtwdev, R_AX_UDM3));\n\trtw89_info(rtwdev, \"R_AX_HALT_C2H = 0x%x\\n\",\n\t\t   rtw89_read32(rtwdev, R_AX_HALT_C2H));\n\trtw89_info(rtwdev, \"R_AX_SER_DBG_INFO = 0x%x\\n\",\n\t\t   rtw89_read32(rtwdev, R_AX_SER_DBG_INFO));\n\n\trtw89_fw_prog_cnt_dump(rtwdev);\n}\n\nstatic void rtw89_release_pkt_list(struct rtw89_dev *rtwdev)\n{\n\tstruct list_head *pkt_list = rtwdev->scan_info.pkt_list;\n\tstruct rtw89_pktofld_info *info, *tmp;\n\tu8 idx;\n\n\tfor (idx = NL80211_BAND_2GHZ; idx < NUM_NL80211_BANDS; idx++) {\n\t\tif (!(rtwdev->chip->support_bands & BIT(idx)))\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry_safe(info, tmp, &pkt_list[idx], list) {\n\t\t\tif (test_bit(info->id, rtwdev->pkt_offload))\n\t\t\t\trtw89_fw_h2c_del_pkt_offload(rtwdev, info->id);\n\t\t\tlist_del(&info->list);\n\t\t\tkfree(info);\n\t\t}\n\t}\n}\n\nstatic bool rtw89_is_6ghz_wildcard_probe_req(struct rtw89_dev *rtwdev,\n\t\t\t\t\t     struct rtw89_vif *rtwvif,\n\t\t\t\t\t     struct rtw89_pktofld_info *info,\n\t\t\t\t\t     enum nl80211_band band, u8 ssid_idx)\n{\n\tstruct cfg80211_scan_request *req = rtwvif->scan_req;\n\n\tif (band != NL80211_BAND_6GHZ)\n\t\treturn false;\n\n\tif (req->ssids[ssid_idx].ssid_len) {\n\t\tmemcpy(info->ssid, req->ssids[ssid_idx].ssid,\n\t\t       req->ssids[ssid_idx].ssid_len);\n\t\tinfo->ssid_len = req->ssids[ssid_idx].ssid_len;\n\t\treturn false;\n\t} else {\n\t\treturn true;\n\t}\n}\n\nstatic int rtw89_append_probe_req_ie(struct rtw89_dev *rtwdev,\n\t\t\t\t     struct rtw89_vif *rtwvif,\n\t\t\t\t     struct sk_buff *skb, u8 ssid_idx)\n{\n\tstruct rtw89_hw_scan_info *scan_info = &rtwdev->scan_info;\n\tstruct ieee80211_scan_ies *ies = rtwvif->scan_ies;\n\tstruct rtw89_pktofld_info *info;\n\tstruct sk_buff *new;\n\tint ret = 0;\n\tu8 band;\n\n\tfor (band = NL80211_BAND_2GHZ; band < NUM_NL80211_BANDS; band++) {\n\t\tif (!(rtwdev->chip->support_bands & BIT(band)))\n\t\t\tcontinue;\n\n\t\tnew = skb_copy(skb, GFP_KERNEL);\n\t\tif (!new) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tskb_put_data(new, ies->ies[band], ies->len[band]);\n\t\tskb_put_data(new, ies->common_ies, ies->common_ie_len);\n\n\t\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\t\tif (!info) {\n\t\t\tret = -ENOMEM;\n\t\t\tkfree_skb(new);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (rtw89_is_6ghz_wildcard_probe_req(rtwdev, rtwvif, info, band,\n\t\t\t\t\t\t     ssid_idx)) {\n\t\t\tkfree_skb(new);\n\t\t\tkfree(info);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = rtw89_fw_h2c_add_pkt_offload(rtwdev, &info->id, new);\n\t\tif (ret) {\n\t\t\tkfree_skb(new);\n\t\t\tkfree(info);\n\t\t\tgoto out;\n\t\t}\n\n\t\tlist_add_tail(&info->list, &scan_info->pkt_list[band]);\n\t\tkfree_skb(new);\n\t}\nout:\n\treturn ret;\n}\n\nstatic int rtw89_hw_scan_update_probe_req(struct rtw89_dev *rtwdev,\n\t\t\t\t\t  struct rtw89_vif *rtwvif)\n{\n\tstruct cfg80211_scan_request *req = rtwvif->scan_req;\n\tstruct sk_buff *skb;\n\tu8 num = req->n_ssids, i;\n\tint ret;\n\n\tfor (i = 0; i < num; i++) {\n\t\tskb = ieee80211_probereq_get(rtwdev->hw, rtwvif->mac_addr,\n\t\t\t\t\t     req->ssids[i].ssid,\n\t\t\t\t\t     req->ssids[i].ssid_len,\n\t\t\t\t\t     req->ie_len);\n\t\tif (!skb)\n\t\t\treturn -ENOMEM;\n\n\t\tret = rtw89_append_probe_req_ie(rtwdev, rtwvif, skb, i);\n\t\tkfree_skb(skb);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int rtw89_update_6ghz_rnr_chan(struct rtw89_dev *rtwdev,\n\t\t\t\t      struct cfg80211_scan_request *req,\n\t\t\t\t      struct rtw89_mac_chinfo *ch_info)\n{\n\tstruct ieee80211_vif *vif = rtwdev->scan_info.scanning_vif;\n\tstruct list_head *pkt_list = rtwdev->scan_info.pkt_list;\n\tstruct rtw89_vif *rtwvif = vif_to_rtwvif_safe(vif);\n\tstruct ieee80211_scan_ies *ies = rtwvif->scan_ies;\n\tstruct cfg80211_scan_6ghz_params *params;\n\tstruct rtw89_pktofld_info *info, *tmp;\n\tstruct ieee80211_hdr *hdr;\n\tstruct sk_buff *skb;\n\tbool found;\n\tint ret = 0;\n\tu8 i;\n\n\tif (!req->n_6ghz_params)\n\t\treturn 0;\n\n\tfor (i = 0; i < req->n_6ghz_params; i++) {\n\t\tparams = &req->scan_6ghz_params[i];\n\n\t\tif (req->channels[params->channel_idx]->hw_value !=\n\t\t    ch_info->pri_ch)\n\t\t\tcontinue;\n\n\t\tfound = false;\n\t\tlist_for_each_entry(tmp, &pkt_list[NL80211_BAND_6GHZ], list) {\n\t\t\tif (ether_addr_equal(tmp->bssid, params->bssid)) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (found)\n\t\t\tcontinue;\n\n\t\tskb = ieee80211_probereq_get(rtwdev->hw, rtwvif->mac_addr,\n\t\t\t\t\t     NULL, 0, req->ie_len);\n\t\tskb_put_data(skb, ies->ies[NL80211_BAND_6GHZ], ies->len[NL80211_BAND_6GHZ]);\n\t\tskb_put_data(skb, ies->common_ies, ies->common_ie_len);\n\t\thdr = (struct ieee80211_hdr *)skb->data;\n\t\tether_addr_copy(hdr->addr3, params->bssid);\n\n\t\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\t\tif (!info) {\n\t\t\tret = -ENOMEM;\n\t\t\tkfree_skb(skb);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = rtw89_fw_h2c_add_pkt_offload(rtwdev, &info->id, skb);\n\t\tif (ret) {\n\t\t\tkfree_skb(skb);\n\t\t\tkfree(info);\n\t\t\tgoto out;\n\t\t}\n\n\t\tether_addr_copy(info->bssid, params->bssid);\n\t\tinfo->channel_6ghz = req->channels[params->channel_idx]->hw_value;\n\t\tlist_add_tail(&info->list, &rtwdev->scan_info.pkt_list[NL80211_BAND_6GHZ]);\n\n\t\tch_info->tx_pkt = true;\n\t\tch_info->period = RTW89_CHANNEL_TIME_6G + RTW89_DWELL_TIME_6G;\n\n\t\tkfree_skb(skb);\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic void rtw89_hw_scan_add_chan(struct rtw89_dev *rtwdev, int chan_type,\n\t\t\t\t   int ssid_num,\n\t\t\t\t   struct rtw89_mac_chinfo *ch_info)\n{\n\tstruct rtw89_hw_scan_info *scan_info = &rtwdev->scan_info;\n\tstruct ieee80211_vif *vif = rtwdev->scan_info.scanning_vif;\n\tstruct rtw89_vif *rtwvif = (struct rtw89_vif *)vif->drv_priv;\n\tstruct cfg80211_scan_request *req = rtwvif->scan_req;\n\tstruct rtw89_chan *op = &rtwdev->scan_info.op_chan;\n\tstruct rtw89_pktofld_info *info;\n\tu8 band, probe_count = 0;\n\tint ret;\n\n\tch_info->notify_action = RTW89_SCANOFLD_DEBUG_MASK;\n\tch_info->dfs_ch = chan_type == RTW89_CHAN_DFS;\n\tch_info->bw = RTW89_SCAN_WIDTH;\n\tch_info->tx_pkt = true;\n\tch_info->cfg_tx_pwr = false;\n\tch_info->tx_pwr_idx = 0;\n\tch_info->tx_null = false;\n\tch_info->pause_data = false;\n\tch_info->probe_id = RTW89_SCANOFLD_PKT_NONE;\n\n\tif (ch_info->ch_band == RTW89_BAND_6G) {\n\t\tif ((ssid_num == 1 && req->ssids[0].ssid_len == 0) ||\n\t\t    !ch_info->is_psc) {\n\t\t\tch_info->tx_pkt = false;\n\t\t\tif (!req->duration_mandatory)\n\t\t\t\tch_info->period -= RTW89_DWELL_TIME_6G;\n\t\t}\n\t}\n\n\tret = rtw89_update_6ghz_rnr_chan(rtwdev, req, ch_info);\n\tif (ret)\n\t\trtw89_warn(rtwdev, \"RNR fails: %d\\n\", ret);\n\n\tif (ssid_num) {\n\t\tband = rtw89_hw_to_nl80211_band(ch_info->ch_band);\n\n\t\tlist_for_each_entry(info, &scan_info->pkt_list[band], list) {\n\t\t\tif (info->channel_6ghz &&\n\t\t\t    ch_info->pri_ch != info->channel_6ghz)\n\t\t\t\tcontinue;\n\t\t\tch_info->pkt_id[probe_count++] = info->id;\n\t\t\tif (probe_count >= RTW89_SCANOFLD_MAX_SSID)\n\t\t\t\tbreak;\n\t\t}\n\t\tch_info->num_pkt = probe_count;\n\t}\n\n\tswitch (chan_type) {\n\tcase RTW89_CHAN_OPERATE:\n\t\tch_info->central_ch = op->channel;\n\t\tch_info->pri_ch = op->primary_channel;\n\t\tch_info->ch_band = op->band_type;\n\t\tch_info->bw = op->band_width;\n\t\tch_info->tx_null = true;\n\t\tch_info->num_pkt = 0;\n\t\tbreak;\n\tcase RTW89_CHAN_DFS:\n\t\tif (ch_info->ch_band != RTW89_BAND_6G)\n\t\t\tch_info->period = max_t(u8, ch_info->period,\n\t\t\t\t\t\tRTW89_DFS_CHAN_TIME);\n\t\tch_info->dwell_time = RTW89_DWELL_TIME;\n\t\tbreak;\n\tcase RTW89_CHAN_ACTIVE:\n\t\tbreak;\n\tdefault:\n\t\trtw89_err(rtwdev, \"Channel type out of bound\\n\");\n\t}\n}\n\nstatic int rtw89_hw_scan_add_chan_list(struct rtw89_dev *rtwdev,\n\t\t\t\t       struct rtw89_vif *rtwvif, bool connected)\n{\n\tstruct cfg80211_scan_request *req = rtwvif->scan_req;\n\tstruct rtw89_mac_chinfo\t*ch_info, *tmp;\n\tstruct ieee80211_channel *channel;\n\tstruct list_head chan_list;\n\tbool random_seq = req->flags & NL80211_SCAN_FLAG_RANDOM_SN;\n\tint list_len, off_chan_time = 0;\n\tenum rtw89_chan_type type;\n\tint ret = 0;\n\tu32 idx;\n\n\tINIT_LIST_HEAD(&chan_list);\n\tfor (idx = rtwdev->scan_info.last_chan_idx, list_len = 0;\n\t     idx < req->n_channels && list_len < RTW89_SCAN_LIST_LIMIT;\n\t     idx++, list_len++) {\n\t\tchannel = req->channels[idx];\n\t\tch_info = kzalloc(sizeof(*ch_info), GFP_KERNEL);\n\t\tif (!ch_info) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (req->duration_mandatory)\n\t\t\tch_info->period = req->duration;\n\t\telse if (channel->band == NL80211_BAND_6GHZ)\n\t\t\tch_info->period = RTW89_CHANNEL_TIME_6G +\n\t\t\t\t\t  RTW89_DWELL_TIME_6G;\n\t\telse\n\t\t\tch_info->period = RTW89_CHANNEL_TIME;\n\n\t\tch_info->ch_band = rtw89_nl80211_to_hw_band(channel->band);\n\t\tch_info->central_ch = channel->hw_value;\n\t\tch_info->pri_ch = channel->hw_value;\n\t\tch_info->rand_seq_num = random_seq;\n\t\tch_info->is_psc = cfg80211_channel_is_psc(channel);\n\n\t\tif (channel->flags &\n\t\t    (IEEE80211_CHAN_RADAR | IEEE80211_CHAN_NO_IR))\n\t\t\ttype = RTW89_CHAN_DFS;\n\t\telse\n\t\t\ttype = RTW89_CHAN_ACTIVE;\n\t\trtw89_hw_scan_add_chan(rtwdev, type, req->n_ssids, ch_info);\n\n\t\tif (connected &&\n\t\t    off_chan_time + ch_info->period > RTW89_OFF_CHAN_TIME) {\n\t\t\ttmp = kzalloc(sizeof(*tmp), GFP_KERNEL);\n\t\t\tif (!tmp) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tkfree(ch_info);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\ttype = RTW89_CHAN_OPERATE;\n\t\t\ttmp->period = req->duration_mandatory ?\n\t\t\t\t      req->duration : RTW89_CHANNEL_TIME;\n\t\t\trtw89_hw_scan_add_chan(rtwdev, type, 0, tmp);\n\t\t\tlist_add_tail(&tmp->list, &chan_list);\n\t\t\toff_chan_time = 0;\n\t\t\tlist_len++;\n\t\t}\n\t\tlist_add_tail(&ch_info->list, &chan_list);\n\t\toff_chan_time += ch_info->period;\n\t}\n\trtwdev->scan_info.last_chan_idx = idx;\n\tret = rtw89_fw_h2c_scan_list_offload(rtwdev, list_len, &chan_list);\n\nout:\n\tlist_for_each_entry_safe(ch_info, tmp, &chan_list, list) {\n\t\tlist_del(&ch_info->list);\n\t\tkfree(ch_info);\n\t}\n\n\treturn ret;\n}\n\nstatic int rtw89_hw_scan_prehandle(struct rtw89_dev *rtwdev,\n\t\t\t\t   struct rtw89_vif *rtwvif, bool connected)\n{\n\tint ret;\n\n\tret = rtw89_hw_scan_update_probe_req(rtwdev, rtwvif);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"Update probe request failed\\n\");\n\t\tgoto out;\n\t}\n\tret = rtw89_hw_scan_add_chan_list(rtwdev, rtwvif, connected);\nout:\n\treturn ret;\n}\n\nvoid rtw89_hw_scan_start(struct rtw89_dev *rtwdev, struct ieee80211_vif *vif,\n\t\t\t struct ieee80211_scan_request *scan_req)\n{\n\tstruct rtw89_vif *rtwvif = (struct rtw89_vif *)vif->drv_priv;\n\tconst struct rtw89_mac_gen_def *mac = rtwdev->chip->mac_def;\n\tstruct cfg80211_scan_request *req = &scan_req->req;\n\tu32 rx_fltr = rtwdev->hal.rx_fltr;\n\tu8 mac_addr[ETH_ALEN];\n\n\trtw89_get_channel(rtwdev, rtwvif, &rtwdev->scan_info.op_chan);\n\trtwdev->scan_info.scanning_vif = vif;\n\trtwdev->scan_info.last_chan_idx = 0;\n\trtwvif->scan_ies = &scan_req->ies;\n\trtwvif->scan_req = req;\n\tieee80211_stop_queues(rtwdev->hw);\n\n\tif (req->flags & NL80211_SCAN_FLAG_RANDOM_ADDR)\n\t\tget_random_mask_addr(mac_addr, req->mac_addr,\n\t\t\t\t     req->mac_addr_mask);\n\telse\n\t\tether_addr_copy(mac_addr, vif->addr);\n\trtw89_core_scan_start(rtwdev, rtwvif, mac_addr, true);\n\n\trx_fltr &= ~B_AX_A_BCN_CHK_EN;\n\trx_fltr &= ~B_AX_A_BC;\n\trx_fltr &= ~B_AX_A_A1_MATCH;\n\trtw89_write32_mask(rtwdev,\n\t\t\t   rtw89_mac_reg_by_idx(rtwdev, mac->rx_fltr, RTW89_MAC_0),\n\t\t\t   B_AX_RX_FLTR_CFG_MASK,\n\t\t\t   rx_fltr);\n}\n\nvoid rtw89_hw_scan_complete(struct rtw89_dev *rtwdev, struct ieee80211_vif *vif,\n\t\t\t    bool aborted)\n{\n\tconst struct rtw89_mac_gen_def *mac = rtwdev->chip->mac_def;\n\tstruct rtw89_hw_scan_info *scan_info = &rtwdev->scan_info;\n\tstruct cfg80211_scan_info info = {\n\t\t.aborted = aborted,\n\t};\n\tstruct rtw89_vif *rtwvif;\n\n\tif (!vif)\n\t\treturn;\n\n\trtw89_write32_mask(rtwdev,\n\t\t\t   rtw89_mac_reg_by_idx(rtwdev, mac->rx_fltr, RTW89_MAC_0),\n\t\t\t   B_AX_RX_FLTR_CFG_MASK,\n\t\t\t   rtwdev->hal.rx_fltr);\n\n\trtw89_core_scan_complete(rtwdev, vif, true);\n\tieee80211_scan_completed(rtwdev->hw, &info);\n\tieee80211_wake_queues(rtwdev->hw);\n\n\trtw89_release_pkt_list(rtwdev);\n\trtwvif = (struct rtw89_vif *)vif->drv_priv;\n\trtwvif->scan_req = NULL;\n\trtwvif->scan_ies = NULL;\n\tscan_info->last_chan_idx = 0;\n\tscan_info->scanning_vif = NULL;\n\n\trtw89_set_channel(rtwdev);\n}\n\nvoid rtw89_hw_scan_abort(struct rtw89_dev *rtwdev, struct ieee80211_vif *vif)\n{\n\trtw89_hw_scan_offload(rtwdev, vif, false);\n\trtw89_hw_scan_complete(rtwdev, vif, true);\n}\n\nint rtw89_hw_scan_offload(struct rtw89_dev *rtwdev, struct ieee80211_vif *vif,\n\t\t\t  bool enable)\n{\n\tstruct rtw89_scan_option opt = {0};\n\tstruct rtw89_vif *rtwvif;\n\tbool connected;\n\tint ret = 0;\n\n\trtwvif = vif ? (struct rtw89_vif *)vif->drv_priv : NULL;\n\tif (!rtwvif)\n\t\treturn -EINVAL;\n\n\t \n\tconnected = !is_zero_ether_addr(rtwvif->bssid);\n\topt.enable = enable;\n\topt.target_ch_mode = connected;\n\tif (enable) {\n\t\tret = rtw89_hw_scan_prehandle(rtwdev, rtwvif, connected);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tret = rtw89_fw_h2c_scan_offload(rtwdev, &opt, rtwvif);\nout:\n\treturn ret;\n}\n\n#define H2C_FW_CPU_EXCEPTION_LEN 4\n#define H2C_FW_CPU_EXCEPTION_TYPE_DEF 0x5566\nint rtw89_fw_h2c_trigger_cpu_exception(struct rtw89_dev *rtwdev)\n{\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, H2C_FW_CPU_EXCEPTION_LEN);\n\tif (!skb) {\n\t\trtw89_err(rtwdev,\n\t\t\t  \"failed to alloc skb for fw cpu exception\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tskb_put(skb, H2C_FW_CPU_EXCEPTION_LEN);\n\tRTW89_SET_FWCMD_CPU_EXCEPTION_TYPE(skb->data,\n\t\t\t\t\t   H2C_FW_CPU_EXCEPTION_TYPE_DEF);\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_TEST,\n\t\t\t      H2C_CL_FW_STATUS_TEST,\n\t\t\t      H2C_FUNC_CPU_EXCEPTION, 0, 0,\n\t\t\t      H2C_FW_CPU_EXCEPTION_LEN);\n\n\tret = rtw89_h2c_tx(rtwdev, skb, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to send h2c\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\n\nfail:\n\tdev_kfree_skb_any(skb);\n\treturn ret;\n}\n\n#define H2C_PKT_DROP_LEN 24\nint rtw89_fw_h2c_pkt_drop(struct rtw89_dev *rtwdev,\n\t\t\t  const struct rtw89_pkt_drop_params *params)\n{\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, H2C_PKT_DROP_LEN);\n\tif (!skb) {\n\t\trtw89_err(rtwdev,\n\t\t\t  \"failed to alloc skb for packet drop\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tswitch (params->sel) {\n\tcase RTW89_PKT_DROP_SEL_MACID_BE_ONCE:\n\tcase RTW89_PKT_DROP_SEL_MACID_BK_ONCE:\n\tcase RTW89_PKT_DROP_SEL_MACID_VI_ONCE:\n\tcase RTW89_PKT_DROP_SEL_MACID_VO_ONCE:\n\tcase RTW89_PKT_DROP_SEL_BAND_ONCE:\n\t\tbreak;\n\tdefault:\n\t\trtw89_debug(rtwdev, RTW89_DBG_FW,\n\t\t\t    \"H2C of pkt drop might not fully support sel: %d yet\\n\",\n\t\t\t    params->sel);\n\t\tbreak;\n\t}\n\n\tskb_put(skb, H2C_PKT_DROP_LEN);\n\tRTW89_SET_FWCMD_PKT_DROP_SEL(skb->data, params->sel);\n\tRTW89_SET_FWCMD_PKT_DROP_MACID(skb->data, params->macid);\n\tRTW89_SET_FWCMD_PKT_DROP_BAND(skb->data, params->mac_band);\n\tRTW89_SET_FWCMD_PKT_DROP_PORT(skb->data, params->port);\n\tRTW89_SET_FWCMD_PKT_DROP_MBSSID(skb->data, params->mbssid);\n\tRTW89_SET_FWCMD_PKT_DROP_ROLE_A_INFO_TF_TRS(skb->data, params->tf_trs);\n\tRTW89_SET_FWCMD_PKT_DROP_MACID_BAND_SEL_0(skb->data,\n\t\t\t\t\t\t  params->macid_band_sel[0]);\n\tRTW89_SET_FWCMD_PKT_DROP_MACID_BAND_SEL_1(skb->data,\n\t\t\t\t\t\t  params->macid_band_sel[1]);\n\tRTW89_SET_FWCMD_PKT_DROP_MACID_BAND_SEL_2(skb->data,\n\t\t\t\t\t\t  params->macid_band_sel[2]);\n\tRTW89_SET_FWCMD_PKT_DROP_MACID_BAND_SEL_3(skb->data,\n\t\t\t\t\t\t  params->macid_band_sel[3]);\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_MAC,\n\t\t\t      H2C_CL_MAC_FW_OFLD,\n\t\t\t      H2C_FUNC_PKT_DROP, 0, 0,\n\t\t\t      H2C_PKT_DROP_LEN);\n\n\tret = rtw89_h2c_tx(rtwdev, skb, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to send h2c\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\n\nfail:\n\tdev_kfree_skb_any(skb);\n\treturn ret;\n}\n\n#define H2C_KEEP_ALIVE_LEN 4\nint rtw89_fw_h2c_keep_alive(struct rtw89_dev *rtwdev, struct rtw89_vif *rtwvif,\n\t\t\t    bool enable)\n{\n\tstruct sk_buff *skb;\n\tu8 pkt_id = 0;\n\tint ret;\n\n\tif (enable) {\n\t\tret = rtw89_fw_h2c_add_general_pkt(rtwdev, rtwvif,\n\t\t\t\t\t\t   RTW89_PKT_OFLD_TYPE_NULL_DATA,\n\t\t\t\t\t\t   &pkt_id);\n\t\tif (ret)\n\t\t\treturn -EPERM;\n\t}\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, H2C_KEEP_ALIVE_LEN);\n\tif (!skb) {\n\t\trtw89_err(rtwdev, \"failed to alloc skb for keep alive\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tskb_put(skb, H2C_KEEP_ALIVE_LEN);\n\n\tRTW89_SET_KEEP_ALIVE_ENABLE(skb->data, enable);\n\tRTW89_SET_KEEP_ALIVE_PKT_NULL_ID(skb->data, pkt_id);\n\tRTW89_SET_KEEP_ALIVE_PERIOD(skb->data, 5);\n\tRTW89_SET_KEEP_ALIVE_MACID(skb->data, rtwvif->mac_id);\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_MAC,\n\t\t\t      H2C_CL_MAC_WOW,\n\t\t\t      H2C_FUNC_KEEP_ALIVE, 0, 1,\n\t\t\t      H2C_KEEP_ALIVE_LEN);\n\n\tret = rtw89_h2c_tx(rtwdev, skb, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to send h2c\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\n\nfail:\n\tdev_kfree_skb_any(skb);\n\n\treturn ret;\n}\n\n#define H2C_DISCONNECT_DETECT_LEN 8\nint rtw89_fw_h2c_disconnect_detect(struct rtw89_dev *rtwdev,\n\t\t\t\t   struct rtw89_vif *rtwvif, bool enable)\n{\n\tstruct rtw89_wow_param *rtw_wow = &rtwdev->wow;\n\tstruct sk_buff *skb;\n\tu8 macid = rtwvif->mac_id;\n\tint ret;\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, H2C_DISCONNECT_DETECT_LEN);\n\tif (!skb) {\n\t\trtw89_err(rtwdev, \"failed to alloc skb for keep alive\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tskb_put(skb, H2C_DISCONNECT_DETECT_LEN);\n\n\tif (test_bit(RTW89_WOW_FLAG_EN_DISCONNECT, rtw_wow->flags)) {\n\t\tRTW89_SET_DISCONNECT_DETECT_ENABLE(skb->data, enable);\n\t\tRTW89_SET_DISCONNECT_DETECT_DISCONNECT(skb->data, !enable);\n\t\tRTW89_SET_DISCONNECT_DETECT_MAC_ID(skb->data, macid);\n\t\tRTW89_SET_DISCONNECT_DETECT_CHECK_PERIOD(skb->data, 100);\n\t\tRTW89_SET_DISCONNECT_DETECT_TRY_PKT_COUNT(skb->data, 5);\n\t}\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_MAC,\n\t\t\t      H2C_CL_MAC_WOW,\n\t\t\t      H2C_FUNC_DISCONNECT_DETECT, 0, 1,\n\t\t\t      H2C_DISCONNECT_DETECT_LEN);\n\n\tret = rtw89_h2c_tx(rtwdev, skb, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to send h2c\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\n\nfail:\n\tdev_kfree_skb_any(skb);\n\n\treturn ret;\n}\n\n#define H2C_WOW_GLOBAL_LEN 8\nint rtw89_fw_h2c_wow_global(struct rtw89_dev *rtwdev, struct rtw89_vif *rtwvif,\n\t\t\t    bool enable)\n{\n\tstruct sk_buff *skb;\n\tu8 macid = rtwvif->mac_id;\n\tint ret;\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, H2C_WOW_GLOBAL_LEN);\n\tif (!skb) {\n\t\trtw89_err(rtwdev, \"failed to alloc skb for keep alive\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tskb_put(skb, H2C_WOW_GLOBAL_LEN);\n\n\tRTW89_SET_WOW_GLOBAL_ENABLE(skb->data, enable);\n\tRTW89_SET_WOW_GLOBAL_MAC_ID(skb->data, macid);\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_MAC,\n\t\t\t      H2C_CL_MAC_WOW,\n\t\t\t      H2C_FUNC_WOW_GLOBAL, 0, 1,\n\t\t\t      H2C_WOW_GLOBAL_LEN);\n\n\tret = rtw89_h2c_tx(rtwdev, skb, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to send h2c\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\n\nfail:\n\tdev_kfree_skb_any(skb);\n\n\treturn ret;\n}\n\n#define H2C_WAKEUP_CTRL_LEN 4\nint rtw89_fw_h2c_wow_wakeup_ctrl(struct rtw89_dev *rtwdev,\n\t\t\t\t struct rtw89_vif *rtwvif,\n\t\t\t\t bool enable)\n{\n\tstruct rtw89_wow_param *rtw_wow = &rtwdev->wow;\n\tstruct sk_buff *skb;\n\tu8 macid = rtwvif->mac_id;\n\tint ret;\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, H2C_WAKEUP_CTRL_LEN);\n\tif (!skb) {\n\t\trtw89_err(rtwdev, \"failed to alloc skb for keep alive\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tskb_put(skb, H2C_WAKEUP_CTRL_LEN);\n\n\tif (rtw_wow->pattern_cnt)\n\t\tRTW89_SET_WOW_WAKEUP_CTRL_PATTERN_MATCH_ENABLE(skb->data, enable);\n\tif (test_bit(RTW89_WOW_FLAG_EN_MAGIC_PKT, rtw_wow->flags))\n\t\tRTW89_SET_WOW_WAKEUP_CTRL_MAGIC_ENABLE(skb->data, enable);\n\tif (test_bit(RTW89_WOW_FLAG_EN_DISCONNECT, rtw_wow->flags))\n\t\tRTW89_SET_WOW_WAKEUP_CTRL_DEAUTH_ENABLE(skb->data, enable);\n\n\tRTW89_SET_WOW_WAKEUP_CTRL_MAC_ID(skb->data, macid);\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_MAC,\n\t\t\t      H2C_CL_MAC_WOW,\n\t\t\t      H2C_FUNC_WAKEUP_CTRL, 0, 1,\n\t\t\t      H2C_WAKEUP_CTRL_LEN);\n\n\tret = rtw89_h2c_tx(rtwdev, skb, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to send h2c\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\n\nfail:\n\tdev_kfree_skb_any(skb);\n\n\treturn ret;\n}\n\n#define H2C_WOW_CAM_UPD_LEN 24\nint rtw89_fw_wow_cam_update(struct rtw89_dev *rtwdev,\n\t\t\t    struct rtw89_wow_cam_info *cam_info)\n{\n\tstruct sk_buff *skb;\n\tint ret;\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, H2C_WOW_CAM_UPD_LEN);\n\tif (!skb) {\n\t\trtw89_err(rtwdev, \"failed to alloc skb for keep alive\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tskb_put(skb, H2C_WOW_CAM_UPD_LEN);\n\n\tRTW89_SET_WOW_CAM_UPD_R_W(skb->data, cam_info->r_w);\n\tRTW89_SET_WOW_CAM_UPD_IDX(skb->data, cam_info->idx);\n\tif (cam_info->valid) {\n\t\tRTW89_SET_WOW_CAM_UPD_WKFM1(skb->data, cam_info->mask[0]);\n\t\tRTW89_SET_WOW_CAM_UPD_WKFM2(skb->data, cam_info->mask[1]);\n\t\tRTW89_SET_WOW_CAM_UPD_WKFM3(skb->data, cam_info->mask[2]);\n\t\tRTW89_SET_WOW_CAM_UPD_WKFM4(skb->data, cam_info->mask[3]);\n\t\tRTW89_SET_WOW_CAM_UPD_CRC(skb->data, cam_info->crc);\n\t\tRTW89_SET_WOW_CAM_UPD_NEGATIVE_PATTERN_MATCH(skb->data,\n\t\t\t\t\t\t\t     cam_info->negative_pattern_match);\n\t\tRTW89_SET_WOW_CAM_UPD_SKIP_MAC_HDR(skb->data,\n\t\t\t\t\t\t   cam_info->skip_mac_hdr);\n\t\tRTW89_SET_WOW_CAM_UPD_UC(skb->data, cam_info->uc);\n\t\tRTW89_SET_WOW_CAM_UPD_MC(skb->data, cam_info->mc);\n\t\tRTW89_SET_WOW_CAM_UPD_BC(skb->data, cam_info->bc);\n\t}\n\tRTW89_SET_WOW_CAM_UPD_VALID(skb->data, cam_info->valid);\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_MAC,\n\t\t\t      H2C_CL_MAC_WOW,\n\t\t\t      H2C_FUNC_WOW_CAM_UPD, 0, 1,\n\t\t\t      H2C_WOW_CAM_UPD_LEN);\n\n\tret = rtw89_h2c_tx(rtwdev, skb, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to send h2c\\n\");\n\t\tgoto fail;\n\t}\n\n\treturn 0;\nfail:\n\tdev_kfree_skb_any(skb);\n\n\treturn ret;\n}\n\n \nstatic int rtw89_h2c_tx_and_wait(struct rtw89_dev *rtwdev, struct sk_buff *skb,\n\t\t\t\t struct rtw89_wait_info *wait, unsigned int cond)\n{\n\tint ret;\n\n\tret = rtw89_h2c_tx(rtwdev, skb, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to send h2c\\n\");\n\t\tdev_kfree_skb_any(skb);\n\t\treturn -EBUSY;\n\t}\n\n\tif (test_bit(RTW89_FLAG_SER_HANDLING, rtwdev->flags))\n\t\treturn 1;\n\n\treturn rtw89_wait_for_cond(wait, cond);\n}\n\n#define H2C_ADD_MCC_LEN 16\nint rtw89_fw_h2c_add_mcc(struct rtw89_dev *rtwdev,\n\t\t\t const struct rtw89_fw_mcc_add_req *p)\n{\n\tstruct rtw89_wait_info *wait = &rtwdev->mcc.wait;\n\tstruct sk_buff *skb;\n\tunsigned int cond;\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, H2C_ADD_MCC_LEN);\n\tif (!skb) {\n\t\trtw89_err(rtwdev,\n\t\t\t  \"failed to alloc skb for add mcc\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tskb_put(skb, H2C_ADD_MCC_LEN);\n\tRTW89_SET_FWCMD_ADD_MCC_MACID(skb->data, p->macid);\n\tRTW89_SET_FWCMD_ADD_MCC_CENTRAL_CH_SEG0(skb->data, p->central_ch_seg0);\n\tRTW89_SET_FWCMD_ADD_MCC_CENTRAL_CH_SEG1(skb->data, p->central_ch_seg1);\n\tRTW89_SET_FWCMD_ADD_MCC_PRIMARY_CH(skb->data, p->primary_ch);\n\tRTW89_SET_FWCMD_ADD_MCC_BANDWIDTH(skb->data, p->bandwidth);\n\tRTW89_SET_FWCMD_ADD_MCC_GROUP(skb->data, p->group);\n\tRTW89_SET_FWCMD_ADD_MCC_C2H_RPT(skb->data, p->c2h_rpt);\n\tRTW89_SET_FWCMD_ADD_MCC_DIS_TX_NULL(skb->data, p->dis_tx_null);\n\tRTW89_SET_FWCMD_ADD_MCC_DIS_SW_RETRY(skb->data, p->dis_sw_retry);\n\tRTW89_SET_FWCMD_ADD_MCC_IN_CURR_CH(skb->data, p->in_curr_ch);\n\tRTW89_SET_FWCMD_ADD_MCC_SW_RETRY_COUNT(skb->data, p->sw_retry_count);\n\tRTW89_SET_FWCMD_ADD_MCC_TX_NULL_EARLY(skb->data, p->tx_null_early);\n\tRTW89_SET_FWCMD_ADD_MCC_BTC_IN_2G(skb->data, p->btc_in_2g);\n\tRTW89_SET_FWCMD_ADD_MCC_PTA_EN(skb->data, p->pta_en);\n\tRTW89_SET_FWCMD_ADD_MCC_RFK_BY_PASS(skb->data, p->rfk_by_pass);\n\tRTW89_SET_FWCMD_ADD_MCC_CH_BAND_TYPE(skb->data, p->ch_band_type);\n\tRTW89_SET_FWCMD_ADD_MCC_DURATION(skb->data, p->duration);\n\tRTW89_SET_FWCMD_ADD_MCC_COURTESY_EN(skb->data, p->courtesy_en);\n\tRTW89_SET_FWCMD_ADD_MCC_COURTESY_NUM(skb->data, p->courtesy_num);\n\tRTW89_SET_FWCMD_ADD_MCC_COURTESY_TARGET(skb->data, p->courtesy_target);\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_MAC,\n\t\t\t      H2C_CL_MCC,\n\t\t\t      H2C_FUNC_ADD_MCC, 0, 0,\n\t\t\t      H2C_ADD_MCC_LEN);\n\n\tcond = RTW89_MCC_WAIT_COND(p->group, H2C_FUNC_ADD_MCC);\n\treturn rtw89_h2c_tx_and_wait(rtwdev, skb, wait, cond);\n}\n\n#define H2C_START_MCC_LEN 12\nint rtw89_fw_h2c_start_mcc(struct rtw89_dev *rtwdev,\n\t\t\t   const struct rtw89_fw_mcc_start_req *p)\n{\n\tstruct rtw89_wait_info *wait = &rtwdev->mcc.wait;\n\tstruct sk_buff *skb;\n\tunsigned int cond;\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, H2C_START_MCC_LEN);\n\tif (!skb) {\n\t\trtw89_err(rtwdev,\n\t\t\t  \"failed to alloc skb for start mcc\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tskb_put(skb, H2C_START_MCC_LEN);\n\tRTW89_SET_FWCMD_START_MCC_GROUP(skb->data, p->group);\n\tRTW89_SET_FWCMD_START_MCC_BTC_IN_GROUP(skb->data, p->btc_in_group);\n\tRTW89_SET_FWCMD_START_MCC_OLD_GROUP_ACTION(skb->data, p->old_group_action);\n\tRTW89_SET_FWCMD_START_MCC_OLD_GROUP(skb->data, p->old_group);\n\tRTW89_SET_FWCMD_START_MCC_NOTIFY_CNT(skb->data, p->notify_cnt);\n\tRTW89_SET_FWCMD_START_MCC_NOTIFY_RXDBG_EN(skb->data, p->notify_rxdbg_en);\n\tRTW89_SET_FWCMD_START_MCC_MACID(skb->data, p->macid);\n\tRTW89_SET_FWCMD_START_MCC_TSF_LOW(skb->data, p->tsf_low);\n\tRTW89_SET_FWCMD_START_MCC_TSF_HIGH(skb->data, p->tsf_high);\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_MAC,\n\t\t\t      H2C_CL_MCC,\n\t\t\t      H2C_FUNC_START_MCC, 0, 0,\n\t\t\t      H2C_START_MCC_LEN);\n\n\tcond = RTW89_MCC_WAIT_COND(p->group, H2C_FUNC_START_MCC);\n\treturn rtw89_h2c_tx_and_wait(rtwdev, skb, wait, cond);\n}\n\n#define H2C_STOP_MCC_LEN 4\nint rtw89_fw_h2c_stop_mcc(struct rtw89_dev *rtwdev, u8 group, u8 macid,\n\t\t\t  bool prev_groups)\n{\n\tstruct rtw89_wait_info *wait = &rtwdev->mcc.wait;\n\tstruct sk_buff *skb;\n\tunsigned int cond;\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, H2C_STOP_MCC_LEN);\n\tif (!skb) {\n\t\trtw89_err(rtwdev,\n\t\t\t  \"failed to alloc skb for stop mcc\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tskb_put(skb, H2C_STOP_MCC_LEN);\n\tRTW89_SET_FWCMD_STOP_MCC_MACID(skb->data, macid);\n\tRTW89_SET_FWCMD_STOP_MCC_GROUP(skb->data, group);\n\tRTW89_SET_FWCMD_STOP_MCC_PREV_GROUPS(skb->data, prev_groups);\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_MAC,\n\t\t\t      H2C_CL_MCC,\n\t\t\t      H2C_FUNC_STOP_MCC, 0, 0,\n\t\t\t      H2C_STOP_MCC_LEN);\n\n\tcond = RTW89_MCC_WAIT_COND(group, H2C_FUNC_STOP_MCC);\n\treturn rtw89_h2c_tx_and_wait(rtwdev, skb, wait, cond);\n}\n\n#define H2C_DEL_MCC_GROUP_LEN 4\nint rtw89_fw_h2c_del_mcc_group(struct rtw89_dev *rtwdev, u8 group,\n\t\t\t       bool prev_groups)\n{\n\tstruct rtw89_wait_info *wait = &rtwdev->mcc.wait;\n\tstruct sk_buff *skb;\n\tunsigned int cond;\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, H2C_DEL_MCC_GROUP_LEN);\n\tif (!skb) {\n\t\trtw89_err(rtwdev,\n\t\t\t  \"failed to alloc skb for del mcc group\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tskb_put(skb, H2C_DEL_MCC_GROUP_LEN);\n\tRTW89_SET_FWCMD_DEL_MCC_GROUP_GROUP(skb->data, group);\n\tRTW89_SET_FWCMD_DEL_MCC_GROUP_PREV_GROUPS(skb->data, prev_groups);\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_MAC,\n\t\t\t      H2C_CL_MCC,\n\t\t\t      H2C_FUNC_DEL_MCC_GROUP, 0, 0,\n\t\t\t      H2C_DEL_MCC_GROUP_LEN);\n\n\tcond = RTW89_MCC_WAIT_COND(group, H2C_FUNC_DEL_MCC_GROUP);\n\treturn rtw89_h2c_tx_and_wait(rtwdev, skb, wait, cond);\n}\n\n#define H2C_RESET_MCC_GROUP_LEN 4\nint rtw89_fw_h2c_reset_mcc_group(struct rtw89_dev *rtwdev, u8 group)\n{\n\tstruct rtw89_wait_info *wait = &rtwdev->mcc.wait;\n\tstruct sk_buff *skb;\n\tunsigned int cond;\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, H2C_RESET_MCC_GROUP_LEN);\n\tif (!skb) {\n\t\trtw89_err(rtwdev,\n\t\t\t  \"failed to alloc skb for reset mcc group\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tskb_put(skb, H2C_RESET_MCC_GROUP_LEN);\n\tRTW89_SET_FWCMD_RESET_MCC_GROUP_GROUP(skb->data, group);\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_MAC,\n\t\t\t      H2C_CL_MCC,\n\t\t\t      H2C_FUNC_RESET_MCC_GROUP, 0, 0,\n\t\t\t      H2C_RESET_MCC_GROUP_LEN);\n\n\tcond = RTW89_MCC_WAIT_COND(group, H2C_FUNC_RESET_MCC_GROUP);\n\treturn rtw89_h2c_tx_and_wait(rtwdev, skb, wait, cond);\n}\n\n#define H2C_MCC_REQ_TSF_LEN 4\nint rtw89_fw_h2c_mcc_req_tsf(struct rtw89_dev *rtwdev,\n\t\t\t     const struct rtw89_fw_mcc_tsf_req *req,\n\t\t\t     struct rtw89_mac_mcc_tsf_rpt *rpt)\n{\n\tstruct rtw89_wait_info *wait = &rtwdev->mcc.wait;\n\tstruct rtw89_mac_mcc_tsf_rpt *tmp;\n\tstruct sk_buff *skb;\n\tunsigned int cond;\n\tint ret;\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, H2C_MCC_REQ_TSF_LEN);\n\tif (!skb) {\n\t\trtw89_err(rtwdev,\n\t\t\t  \"failed to alloc skb for mcc req tsf\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tskb_put(skb, H2C_MCC_REQ_TSF_LEN);\n\tRTW89_SET_FWCMD_MCC_REQ_TSF_GROUP(skb->data, req->group);\n\tRTW89_SET_FWCMD_MCC_REQ_TSF_MACID_X(skb->data, req->macid_x);\n\tRTW89_SET_FWCMD_MCC_REQ_TSF_MACID_Y(skb->data, req->macid_y);\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_MAC,\n\t\t\t      H2C_CL_MCC,\n\t\t\t      H2C_FUNC_MCC_REQ_TSF, 0, 0,\n\t\t\t      H2C_MCC_REQ_TSF_LEN);\n\n\tcond = RTW89_MCC_WAIT_COND(req->group, H2C_FUNC_MCC_REQ_TSF);\n\tret = rtw89_h2c_tx_and_wait(rtwdev, skb, wait, cond);\n\tif (ret)\n\t\treturn ret;\n\n\ttmp = (struct rtw89_mac_mcc_tsf_rpt *)wait->data.buf;\n\t*rpt = *tmp;\n\n\treturn 0;\n}\n\n#define H2C_MCC_MACID_BITMAP_DSC_LEN 4\nint rtw89_fw_h2c_mcc_macid_bitamp(struct rtw89_dev *rtwdev, u8 group, u8 macid,\n\t\t\t\t  u8 *bitmap)\n{\n\tstruct rtw89_wait_info *wait = &rtwdev->mcc.wait;\n\tstruct sk_buff *skb;\n\tunsigned int cond;\n\tu8 map_len;\n\tu8 h2c_len;\n\n\tBUILD_BUG_ON(RTW89_MAX_MAC_ID_NUM % 8);\n\tmap_len = RTW89_MAX_MAC_ID_NUM / 8;\n\th2c_len = H2C_MCC_MACID_BITMAP_DSC_LEN + map_len;\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, h2c_len);\n\tif (!skb) {\n\t\trtw89_err(rtwdev,\n\t\t\t  \"failed to alloc skb for mcc macid bitmap\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tskb_put(skb, h2c_len);\n\tRTW89_SET_FWCMD_MCC_MACID_BITMAP_GROUP(skb->data, group);\n\tRTW89_SET_FWCMD_MCC_MACID_BITMAP_MACID(skb->data, macid);\n\tRTW89_SET_FWCMD_MCC_MACID_BITMAP_BITMAP_LENGTH(skb->data, map_len);\n\tRTW89_SET_FWCMD_MCC_MACID_BITMAP_BITMAP(skb->data, bitmap, map_len);\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_MAC,\n\t\t\t      H2C_CL_MCC,\n\t\t\t      H2C_FUNC_MCC_MACID_BITMAP, 0, 0,\n\t\t\t      h2c_len);\n\n\tcond = RTW89_MCC_WAIT_COND(group, H2C_FUNC_MCC_MACID_BITMAP);\n\treturn rtw89_h2c_tx_and_wait(rtwdev, skb, wait, cond);\n}\n\n#define H2C_MCC_SYNC_LEN 4\nint rtw89_fw_h2c_mcc_sync(struct rtw89_dev *rtwdev, u8 group, u8 source,\n\t\t\t  u8 target, u8 offset)\n{\n\tstruct rtw89_wait_info *wait = &rtwdev->mcc.wait;\n\tstruct sk_buff *skb;\n\tunsigned int cond;\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, H2C_MCC_SYNC_LEN);\n\tif (!skb) {\n\t\trtw89_err(rtwdev,\n\t\t\t  \"failed to alloc skb for mcc sync\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tskb_put(skb, H2C_MCC_SYNC_LEN);\n\tRTW89_SET_FWCMD_MCC_SYNC_GROUP(skb->data, group);\n\tRTW89_SET_FWCMD_MCC_SYNC_MACID_SOURCE(skb->data, source);\n\tRTW89_SET_FWCMD_MCC_SYNC_MACID_TARGET(skb->data, target);\n\tRTW89_SET_FWCMD_MCC_SYNC_SYNC_OFFSET(skb->data, offset);\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_MAC,\n\t\t\t      H2C_CL_MCC,\n\t\t\t      H2C_FUNC_MCC_SYNC, 0, 0,\n\t\t\t      H2C_MCC_SYNC_LEN);\n\n\tcond = RTW89_MCC_WAIT_COND(group, H2C_FUNC_MCC_SYNC);\n\treturn rtw89_h2c_tx_and_wait(rtwdev, skb, wait, cond);\n}\n\n#define H2C_MCC_SET_DURATION_LEN 20\nint rtw89_fw_h2c_mcc_set_duration(struct rtw89_dev *rtwdev,\n\t\t\t\t  const struct rtw89_fw_mcc_duration *p)\n{\n\tstruct rtw89_wait_info *wait = &rtwdev->mcc.wait;\n\tstruct sk_buff *skb;\n\tunsigned int cond;\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, H2C_MCC_SET_DURATION_LEN);\n\tif (!skb) {\n\t\trtw89_err(rtwdev,\n\t\t\t  \"failed to alloc skb for mcc set duration\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tskb_put(skb, H2C_MCC_SET_DURATION_LEN);\n\tRTW89_SET_FWCMD_MCC_SET_DURATION_GROUP(skb->data, p->group);\n\tRTW89_SET_FWCMD_MCC_SET_DURATION_BTC_IN_GROUP(skb->data, p->btc_in_group);\n\tRTW89_SET_FWCMD_MCC_SET_DURATION_START_MACID(skb->data, p->start_macid);\n\tRTW89_SET_FWCMD_MCC_SET_DURATION_MACID_X(skb->data, p->macid_x);\n\tRTW89_SET_FWCMD_MCC_SET_DURATION_MACID_Y(skb->data, p->macid_y);\n\tRTW89_SET_FWCMD_MCC_SET_DURATION_START_TSF_LOW(skb->data,\n\t\t\t\t\t\t       p->start_tsf_low);\n\tRTW89_SET_FWCMD_MCC_SET_DURATION_START_TSF_HIGH(skb->data,\n\t\t\t\t\t\t\tp->start_tsf_high);\n\tRTW89_SET_FWCMD_MCC_SET_DURATION_DURATION_X(skb->data, p->duration_x);\n\tRTW89_SET_FWCMD_MCC_SET_DURATION_DURATION_Y(skb->data, p->duration_y);\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb, FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_MAC,\n\t\t\t      H2C_CL_MCC,\n\t\t\t      H2C_FUNC_MCC_SET_DURATION, 0, 0,\n\t\t\t      H2C_MCC_SET_DURATION_LEN);\n\n\tcond = RTW89_MCC_WAIT_COND(p->group, H2C_FUNC_MCC_SET_DURATION);\n\treturn rtw89_h2c_tx_and_wait(rtwdev, skb, wait, cond);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}