{
  "module_name": "mac.c",
  "hash_id": "40990819301e2fd76b2ac7d57cf66d3a003c57e1844a8129c11441a6e25902e2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtw89/mac.c",
  "human_readable_source": "\n \n\n#include \"cam.h\"\n#include \"chan.h\"\n#include \"debug.h\"\n#include \"fw.h\"\n#include \"mac.h\"\n#include \"pci.h\"\n#include \"ps.h\"\n#include \"reg.h\"\n#include \"util.h\"\n\nstatic const u32 rtw89_mac_mem_base_addrs_ax[RTW89_MAC_MEM_NUM] = {\n\t[RTW89_MAC_MEM_AXIDMA]\t        = AXIDMA_BASE_ADDR,\n\t[RTW89_MAC_MEM_SHARED_BUF]\t= SHARED_BUF_BASE_ADDR,\n\t[RTW89_MAC_MEM_DMAC_TBL]\t= DMAC_TBL_BASE_ADDR,\n\t[RTW89_MAC_MEM_SHCUT_MACHDR]\t= SHCUT_MACHDR_BASE_ADDR,\n\t[RTW89_MAC_MEM_STA_SCHED]\t= STA_SCHED_BASE_ADDR,\n\t[RTW89_MAC_MEM_RXPLD_FLTR_CAM]\t= RXPLD_FLTR_CAM_BASE_ADDR,\n\t[RTW89_MAC_MEM_SECURITY_CAM]\t= SECURITY_CAM_BASE_ADDR,\n\t[RTW89_MAC_MEM_WOW_CAM]\t\t= WOW_CAM_BASE_ADDR,\n\t[RTW89_MAC_MEM_CMAC_TBL]\t= CMAC_TBL_BASE_ADDR,\n\t[RTW89_MAC_MEM_ADDR_CAM]\t= ADDR_CAM_BASE_ADDR,\n\t[RTW89_MAC_MEM_BA_CAM]\t\t= BA_CAM_BASE_ADDR,\n\t[RTW89_MAC_MEM_BCN_IE_CAM0]\t= BCN_IE_CAM0_BASE_ADDR,\n\t[RTW89_MAC_MEM_BCN_IE_CAM1]\t= BCN_IE_CAM1_BASE_ADDR,\n\t[RTW89_MAC_MEM_TXD_FIFO_0]\t= TXD_FIFO_0_BASE_ADDR,\n\t[RTW89_MAC_MEM_TXD_FIFO_1]\t= TXD_FIFO_1_BASE_ADDR,\n\t[RTW89_MAC_MEM_TXDATA_FIFO_0]\t= TXDATA_FIFO_0_BASE_ADDR,\n\t[RTW89_MAC_MEM_TXDATA_FIFO_1]\t= TXDATA_FIFO_1_BASE_ADDR,\n\t[RTW89_MAC_MEM_CPU_LOCAL]\t= CPU_LOCAL_BASE_ADDR,\n\t[RTW89_MAC_MEM_BSSID_CAM]\t= BSSID_CAM_BASE_ADDR,\n\t[RTW89_MAC_MEM_TXD_FIFO_0_V1]\t= TXD_FIFO_0_BASE_ADDR_V1,\n\t[RTW89_MAC_MEM_TXD_FIFO_1_V1]\t= TXD_FIFO_1_BASE_ADDR_V1,\n};\n\nstatic void rtw89_mac_mem_write(struct rtw89_dev *rtwdev, u32 offset,\n\t\t\t\tu32 val, enum rtw89_mac_mem_sel sel)\n{\n\tconst struct rtw89_mac_gen_def *mac = rtwdev->chip->mac_def;\n\tu32 addr = mac->mem_base_addrs[sel] + offset;\n\n\trtw89_write32(rtwdev, mac->filter_model_addr, addr);\n\trtw89_write32(rtwdev, mac->indir_access_addr, val);\n}\n\nstatic u32 rtw89_mac_mem_read(struct rtw89_dev *rtwdev, u32 offset,\n\t\t\t      enum rtw89_mac_mem_sel sel)\n{\n\tconst struct rtw89_mac_gen_def *mac = rtwdev->chip->mac_def;\n\tu32 addr = mac->mem_base_addrs[sel] + offset;\n\n\trtw89_write32(rtwdev, mac->filter_model_addr, addr);\n\treturn rtw89_read32(rtwdev, mac->indir_access_addr);\n}\n\nint rtw89_mac_check_mac_en(struct rtw89_dev *rtwdev, u8 mac_idx,\n\t\t\t   enum rtw89_mac_hwmod_sel sel)\n{\n\tu32 val, r_val;\n\n\tif (sel == RTW89_DMAC_SEL) {\n\t\tr_val = rtw89_read32(rtwdev, R_AX_DMAC_FUNC_EN);\n\t\tval = (B_AX_MAC_FUNC_EN | B_AX_DMAC_FUNC_EN);\n\t} else if (sel == RTW89_CMAC_SEL && mac_idx == 0) {\n\t\tr_val = rtw89_read32(rtwdev, R_AX_CMAC_FUNC_EN);\n\t\tval = B_AX_CMAC_EN;\n\t} else if (sel == RTW89_CMAC_SEL && mac_idx == 1) {\n\t\tr_val = rtw89_read32(rtwdev, R_AX_SYS_ISO_CTRL_EXTEND);\n\t\tval = B_AX_CMAC1_FEN;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\tif (r_val == RTW89_R32_EA || r_val == RTW89_R32_DEAD ||\n\t    (val & r_val) != val)\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nint rtw89_mac_write_lte(struct rtw89_dev *rtwdev, const u32 offset, u32 val)\n{\n\tu8 lte_ctrl;\n\tint ret;\n\n\tret = read_poll_timeout(rtw89_read8, lte_ctrl, (lte_ctrl & BIT(5)) != 0,\n\t\t\t\t50, 50000, false, rtwdev, R_AX_LTE_CTRL + 3);\n\tif (ret)\n\t\trtw89_err(rtwdev, \"[ERR]lte not ready(W)\\n\");\n\n\trtw89_write32(rtwdev, R_AX_LTE_WDATA, val);\n\trtw89_write32(rtwdev, R_AX_LTE_CTRL, 0xC00F0000 | offset);\n\n\treturn ret;\n}\n\nint rtw89_mac_read_lte(struct rtw89_dev *rtwdev, const u32 offset, u32 *val)\n{\n\tu8 lte_ctrl;\n\tint ret;\n\n\tret = read_poll_timeout(rtw89_read8, lte_ctrl, (lte_ctrl & BIT(5)) != 0,\n\t\t\t\t50, 50000, false, rtwdev, R_AX_LTE_CTRL + 3);\n\tif (ret)\n\t\trtw89_err(rtwdev, \"[ERR]lte not ready(W)\\n\");\n\n\trtw89_write32(rtwdev, R_AX_LTE_CTRL, 0x800F0000 | offset);\n\t*val = rtw89_read32(rtwdev, R_AX_LTE_RDATA);\n\n\treturn ret;\n}\n\nstatic\nint dle_dfi_ctrl(struct rtw89_dev *rtwdev, struct rtw89_mac_dle_dfi_ctrl *ctrl)\n{\n\tu32 ctrl_reg, data_reg, ctrl_data;\n\tu32 val;\n\tint ret;\n\n\tswitch (ctrl->type) {\n\tcase DLE_CTRL_TYPE_WDE:\n\t\tctrl_reg = R_AX_WDE_DBG_FUN_INTF_CTL;\n\t\tdata_reg = R_AX_WDE_DBG_FUN_INTF_DATA;\n\t\tctrl_data = FIELD_PREP(B_AX_WDE_DFI_TRGSEL_MASK, ctrl->target) |\n\t\t\t    FIELD_PREP(B_AX_WDE_DFI_ADDR_MASK, ctrl->addr) |\n\t\t\t    B_AX_WDE_DFI_ACTIVE;\n\t\tbreak;\n\tcase DLE_CTRL_TYPE_PLE:\n\t\tctrl_reg = R_AX_PLE_DBG_FUN_INTF_CTL;\n\t\tdata_reg = R_AX_PLE_DBG_FUN_INTF_DATA;\n\t\tctrl_data = FIELD_PREP(B_AX_PLE_DFI_TRGSEL_MASK, ctrl->target) |\n\t\t\t    FIELD_PREP(B_AX_PLE_DFI_ADDR_MASK, ctrl->addr) |\n\t\t\t    B_AX_PLE_DFI_ACTIVE;\n\t\tbreak;\n\tdefault:\n\t\trtw89_warn(rtwdev, \"[ERR] dfi ctrl type %d\\n\", ctrl->type);\n\t\treturn -EINVAL;\n\t}\n\n\trtw89_write32(rtwdev, ctrl_reg, ctrl_data);\n\n\tret = read_poll_timeout_atomic(rtw89_read32, val, !(val & B_AX_WDE_DFI_ACTIVE),\n\t\t\t\t       1, 1000, false, rtwdev, ctrl_reg);\n\tif (ret) {\n\t\trtw89_warn(rtwdev, \"[ERR] dle dfi ctrl 0x%X set 0x%X timeout\\n\",\n\t\t\t   ctrl_reg, ctrl_data);\n\t\treturn ret;\n\t}\n\n\tctrl->out_data = rtw89_read32(rtwdev, data_reg);\n\treturn 0;\n}\n\nstatic int dle_dfi_quota(struct rtw89_dev *rtwdev,\n\t\t\t struct rtw89_mac_dle_dfi_quota *quota)\n{\n\tstruct rtw89_mac_dle_dfi_ctrl ctrl;\n\tint ret;\n\n\tctrl.type = quota->dle_type;\n\tctrl.target = DLE_DFI_TYPE_QUOTA;\n\tctrl.addr = quota->qtaid;\n\tret = dle_dfi_ctrl(rtwdev, &ctrl);\n\tif (ret) {\n\t\trtw89_warn(rtwdev, \"[ERR]dle_dfi_ctrl %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tquota->rsv_pgnum = FIELD_GET(B_AX_DLE_RSV_PGNUM, ctrl.out_data);\n\tquota->use_pgnum = FIELD_GET(B_AX_DLE_USE_PGNUM, ctrl.out_data);\n\treturn 0;\n}\n\nstatic int dle_dfi_qempty(struct rtw89_dev *rtwdev,\n\t\t\t  struct rtw89_mac_dle_dfi_qempty *qempty)\n{\n\tstruct rtw89_mac_dle_dfi_ctrl ctrl;\n\tu32 ret;\n\n\tctrl.type = qempty->dle_type;\n\tctrl.target = DLE_DFI_TYPE_QEMPTY;\n\tctrl.addr = qempty->grpsel;\n\tret = dle_dfi_ctrl(rtwdev, &ctrl);\n\tif (ret) {\n\t\trtw89_warn(rtwdev, \"[ERR]dle_dfi_ctrl %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tqempty->qempty = FIELD_GET(B_AX_DLE_QEMPTY_GRP, ctrl.out_data);\n\treturn 0;\n}\n\nstatic void dump_err_status_dispatcher(struct rtw89_dev *rtwdev)\n{\n\trtw89_info(rtwdev, \"R_AX_HOST_DISPATCHER_ALWAYS_IMR=0x%08x \",\n\t\t   rtw89_read32(rtwdev, R_AX_HOST_DISPATCHER_ERR_IMR));\n\trtw89_info(rtwdev, \"R_AX_HOST_DISPATCHER_ALWAYS_ISR=0x%08x\\n\",\n\t\t   rtw89_read32(rtwdev, R_AX_HOST_DISPATCHER_ERR_ISR));\n\trtw89_info(rtwdev, \"R_AX_CPU_DISPATCHER_ALWAYS_IMR=0x%08x \",\n\t\t   rtw89_read32(rtwdev, R_AX_CPU_DISPATCHER_ERR_IMR));\n\trtw89_info(rtwdev, \"R_AX_CPU_DISPATCHER_ALWAYS_ISR=0x%08x\\n\",\n\t\t   rtw89_read32(rtwdev, R_AX_CPU_DISPATCHER_ERR_ISR));\n\trtw89_info(rtwdev, \"R_AX_OTHER_DISPATCHER_ALWAYS_IMR=0x%08x \",\n\t\t   rtw89_read32(rtwdev, R_AX_OTHER_DISPATCHER_ERR_IMR));\n\trtw89_info(rtwdev, \"R_AX_OTHER_DISPATCHER_ALWAYS_ISR=0x%08x\\n\",\n\t\t   rtw89_read32(rtwdev, R_AX_OTHER_DISPATCHER_ERR_ISR));\n}\n\nstatic void rtw89_mac_dump_qta_lost(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_mac_dle_dfi_qempty qempty;\n\tstruct rtw89_mac_dle_dfi_quota quota;\n\tstruct rtw89_mac_dle_dfi_ctrl ctrl;\n\tu32 val, not_empty, i;\n\tint ret;\n\n\tqempty.dle_type = DLE_CTRL_TYPE_PLE;\n\tqempty.grpsel = 0;\n\tqempty.qempty = ~(u32)0;\n\tret = dle_dfi_qempty(rtwdev, &qempty);\n\tif (ret)\n\t\trtw89_warn(rtwdev, \"%s: query DLE fail\\n\", __func__);\n\telse\n\t\trtw89_info(rtwdev, \"DLE group0 empty: 0x%x\\n\", qempty.qempty);\n\n\tfor (not_empty = ~qempty.qempty, i = 0; not_empty != 0; not_empty >>= 1, i++) {\n\t\tif (!(not_empty & BIT(0)))\n\t\t\tcontinue;\n\t\tctrl.type = DLE_CTRL_TYPE_PLE;\n\t\tctrl.target = DLE_DFI_TYPE_QLNKTBL;\n\t\tctrl.addr = (QLNKTBL_ADDR_INFO_SEL_0 ? QLNKTBL_ADDR_INFO_SEL : 0) |\n\t\t\t    FIELD_PREP(QLNKTBL_ADDR_TBL_IDX_MASK, i);\n\t\tret = dle_dfi_ctrl(rtwdev, &ctrl);\n\t\tif (ret)\n\t\t\trtw89_warn(rtwdev, \"%s: query DLE fail\\n\", __func__);\n\t\telse\n\t\t\trtw89_info(rtwdev, \"qidx%d pktcnt = %ld\\n\", i,\n\t\t\t\t   FIELD_GET(QLNKTBL_DATA_SEL1_PKT_CNT_MASK,\n\t\t\t\t\t     ctrl.out_data));\n\t}\n\n\tquota.dle_type = DLE_CTRL_TYPE_PLE;\n\tquota.qtaid = 6;\n\tret = dle_dfi_quota(rtwdev, &quota);\n\tif (ret)\n\t\trtw89_warn(rtwdev, \"%s: query DLE fail\\n\", __func__);\n\telse\n\t\trtw89_info(rtwdev, \"quota6 rsv/use: 0x%x/0x%x\\n\",\n\t\t\t   quota.rsv_pgnum, quota.use_pgnum);\n\n\tval = rtw89_read32(rtwdev, R_AX_PLE_QTA6_CFG);\n\trtw89_info(rtwdev, \"[PLE][CMAC0_RX]min_pgnum=0x%lx\\n\",\n\t\t   FIELD_GET(B_AX_PLE_Q6_MIN_SIZE_MASK, val));\n\trtw89_info(rtwdev, \"[PLE][CMAC0_RX]max_pgnum=0x%lx\\n\",\n\t\t   FIELD_GET(B_AX_PLE_Q6_MAX_SIZE_MASK, val));\n\n\tdump_err_status_dispatcher(rtwdev);\n}\n\nstatic void rtw89_mac_dump_l0_to_l1(struct rtw89_dev *rtwdev,\n\t\t\t\t    enum mac_ax_err_info err)\n{\n\tu32 dbg, event;\n\n\tdbg = rtw89_read32(rtwdev, R_AX_SER_DBG_INFO);\n\tevent = FIELD_GET(B_AX_L0_TO_L1_EVENT_MASK, dbg);\n\n\tswitch (event) {\n\tcase MAC_AX_L0_TO_L1_RX_QTA_LOST:\n\t\trtw89_info(rtwdev, \"quota lost!\\n\");\n\t\trtw89_mac_dump_qta_lost(rtwdev);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void rtw89_mac_dump_dmac_err_status(struct rtw89_dev *rtwdev)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tu32 dmac_err;\n\tint i, ret;\n\n\tret = rtw89_mac_check_mac_en(rtwdev, 0, RTW89_DMAC_SEL);\n\tif (ret) {\n\t\trtw89_warn(rtwdev, \"[DMAC] : DMAC not enabled\\n\");\n\t\treturn;\n\t}\n\n\tdmac_err = rtw89_read32(rtwdev, R_AX_DMAC_ERR_ISR);\n\trtw89_info(rtwdev, \"R_AX_DMAC_ERR_ISR=0x%08x\\n\", dmac_err);\n\trtw89_info(rtwdev, \"R_AX_DMAC_ERR_IMR=0x%08x\\n\",\n\t\t   rtw89_read32(rtwdev, R_AX_DMAC_ERR_IMR));\n\n\tif (dmac_err) {\n\t\trtw89_info(rtwdev, \"R_AX_WDE_ERR_FLAG_CFG=0x%08x\\n\",\n\t\t\t   rtw89_read32(rtwdev, R_AX_WDE_ERR_FLAG_CFG_NUM1));\n\t\trtw89_info(rtwdev, \"R_AX_PLE_ERR_FLAG_CFG=0x%08x\\n\",\n\t\t\t   rtw89_read32(rtwdev, R_AX_PLE_ERR_FLAG_CFG_NUM1));\n\t\tif (chip->chip_id == RTL8852C) {\n\t\t\trtw89_info(rtwdev, \"R_AX_PLE_ERRFLAG_MSG=0x%08x\\n\",\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_PLE_ERRFLAG_MSG));\n\t\t\trtw89_info(rtwdev, \"R_AX_WDE_ERRFLAG_MSG=0x%08x\\n\",\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_WDE_ERRFLAG_MSG));\n\t\t\trtw89_info(rtwdev, \"R_AX_PLE_DBGERR_LOCKEN=0x%08x\\n\",\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_PLE_DBGERR_LOCKEN));\n\t\t\trtw89_info(rtwdev, \"R_AX_PLE_DBGERR_STS=0x%08x\\n\",\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_PLE_DBGERR_STS));\n\t\t}\n\t}\n\n\tif (dmac_err & B_AX_WDRLS_ERR_FLAG) {\n\t\trtw89_info(rtwdev, \"R_AX_WDRLS_ERR_IMR=0x%08x\\n\",\n\t\t\t   rtw89_read32(rtwdev, R_AX_WDRLS_ERR_IMR));\n\t\trtw89_info(rtwdev, \"R_AX_WDRLS_ERR_ISR=0x%08x\\n\",\n\t\t\t   rtw89_read32(rtwdev, R_AX_WDRLS_ERR_ISR));\n\t\tif (chip->chip_id == RTL8852C)\n\t\t\trtw89_info(rtwdev, \"R_AX_RPQ_RXBD_IDX=0x%08x\\n\",\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_RPQ_RXBD_IDX_V1));\n\t\telse\n\t\t\trtw89_info(rtwdev, \"R_AX_RPQ_RXBD_IDX=0x%08x\\n\",\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_RPQ_RXBD_IDX));\n\t}\n\n\tif (dmac_err & B_AX_WSEC_ERR_FLAG) {\n\t\tif (chip->chip_id == RTL8852C) {\n\t\t\trtw89_info(rtwdev, \"R_AX_SEC_ERR_IMR=0x%08x\\n\",\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_SEC_ERROR_FLAG_IMR));\n\t\t\trtw89_info(rtwdev, \"R_AX_SEC_ERR_ISR=0x%08x\\n\",\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_SEC_ERROR_FLAG));\n\t\t\trtw89_info(rtwdev, \"R_AX_SEC_ENG_CTRL=0x%08x\\n\",\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_SEC_ENG_CTRL));\n\t\t\trtw89_info(rtwdev, \"R_AX_SEC_MPDU_PROC=0x%08x\\n\",\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_SEC_MPDU_PROC));\n\t\t\trtw89_info(rtwdev, \"R_AX_SEC_CAM_ACCESS=0x%08x\\n\",\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_SEC_CAM_ACCESS));\n\t\t\trtw89_info(rtwdev, \"R_AX_SEC_CAM_RDATA=0x%08x\\n\",\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_SEC_CAM_RDATA));\n\t\t\trtw89_info(rtwdev, \"R_AX_SEC_DEBUG1=0x%08x\\n\",\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_SEC_DEBUG1));\n\t\t\trtw89_info(rtwdev, \"R_AX_SEC_TX_DEBUG=0x%08x\\n\",\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_SEC_TX_DEBUG));\n\t\t\trtw89_info(rtwdev, \"R_AX_SEC_RX_DEBUG=0x%08x\\n\",\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_SEC_RX_DEBUG));\n\n\t\t\trtw89_write32_mask(rtwdev, R_AX_DBG_CTRL,\n\t\t\t\t\t   B_AX_DBG_SEL0, 0x8B);\n\t\t\trtw89_write32_mask(rtwdev, R_AX_DBG_CTRL,\n\t\t\t\t\t   B_AX_DBG_SEL1, 0x8B);\n\t\t\trtw89_write32_mask(rtwdev, R_AX_SYS_STATUS1,\n\t\t\t\t\t   B_AX_SEL_0XC0_MASK, 1);\n\t\t\tfor (i = 0; i < 0x10; i++) {\n\t\t\t\trtw89_write32_mask(rtwdev, R_AX_SEC_ENG_CTRL,\n\t\t\t\t\t\t   B_AX_SEC_DBG_PORT_FIELD_MASK, i);\n\t\t\t\trtw89_info(rtwdev, \"sel=%x,R_AX_SEC_DEBUG2=0x%08x\\n\",\n\t\t\t\t\t   i, rtw89_read32(rtwdev, R_AX_SEC_DEBUG2));\n\t\t\t}\n\t\t} else {\n\t\t\trtw89_info(rtwdev, \"R_AX_SEC_ERR_IMR_ISR=0x%08x\\n\",\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_SEC_DEBUG));\n\t\t\trtw89_info(rtwdev, \"R_AX_SEC_ENG_CTRL=0x%08x\\n\",\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_SEC_ENG_CTRL));\n\t\t\trtw89_info(rtwdev, \"R_AX_SEC_MPDU_PROC=0x%08x\\n\",\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_SEC_MPDU_PROC));\n\t\t\trtw89_info(rtwdev, \"R_AX_SEC_CAM_ACCESS=0x%08x\\n\",\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_SEC_CAM_ACCESS));\n\t\t\trtw89_info(rtwdev, \"R_AX_SEC_CAM_RDATA=0x%08x\\n\",\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_SEC_CAM_RDATA));\n\t\t\trtw89_info(rtwdev, \"R_AX_SEC_CAM_WDATA=0x%08x\\n\",\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_SEC_CAM_WDATA));\n\t\t\trtw89_info(rtwdev, \"R_AX_SEC_TX_DEBUG=0x%08x\\n\",\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_SEC_TX_DEBUG));\n\t\t\trtw89_info(rtwdev, \"R_AX_SEC_RX_DEBUG=0x%08x\\n\",\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_SEC_RX_DEBUG));\n\t\t\trtw89_info(rtwdev, \"R_AX_SEC_TRX_PKT_CNT=0x%08x\\n\",\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_SEC_TRX_PKT_CNT));\n\t\t\trtw89_info(rtwdev, \"R_AX_SEC_TRX_BLK_CNT=0x%08x\\n\",\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_SEC_TRX_BLK_CNT));\n\t\t}\n\t}\n\n\tif (dmac_err & B_AX_MPDU_ERR_FLAG) {\n\t\trtw89_info(rtwdev, \"R_AX_MPDU_TX_ERR_IMR=0x%08x\\n\",\n\t\t\t   rtw89_read32(rtwdev, R_AX_MPDU_TX_ERR_IMR));\n\t\trtw89_info(rtwdev, \"R_AX_MPDU_TX_ERR_ISR=0x%08x\\n\",\n\t\t\t   rtw89_read32(rtwdev, R_AX_MPDU_TX_ERR_ISR));\n\t\trtw89_info(rtwdev, \"R_AX_MPDU_RX_ERR_IMR=0x%08x\\n\",\n\t\t\t   rtw89_read32(rtwdev, R_AX_MPDU_RX_ERR_IMR));\n\t\trtw89_info(rtwdev, \"R_AX_MPDU_RX_ERR_ISR=0x%08x\\n\",\n\t\t\t   rtw89_read32(rtwdev, R_AX_MPDU_RX_ERR_ISR));\n\t}\n\n\tif (dmac_err & B_AX_STA_SCHEDULER_ERR_FLAG) {\n\t\trtw89_info(rtwdev, \"R_AX_STA_SCHEDULER_ERR_IMR=0x%08x\\n\",\n\t\t\t   rtw89_read32(rtwdev, R_AX_STA_SCHEDULER_ERR_IMR));\n\t\trtw89_info(rtwdev, \"R_AX_STA_SCHEDULER_ERR_ISR=0x%08x\\n\",\n\t\t\t   rtw89_read32(rtwdev, R_AX_STA_SCHEDULER_ERR_ISR));\n\t}\n\n\tif (dmac_err & B_AX_WDE_DLE_ERR_FLAG) {\n\t\trtw89_info(rtwdev, \"R_AX_WDE_ERR_IMR=0x%08x\\n\",\n\t\t\t   rtw89_read32(rtwdev, R_AX_WDE_ERR_IMR));\n\t\trtw89_info(rtwdev, \"R_AX_WDE_ERR_ISR=0x%08x\\n\",\n\t\t\t   rtw89_read32(rtwdev, R_AX_WDE_ERR_ISR));\n\t\trtw89_info(rtwdev, \"R_AX_PLE_ERR_IMR=0x%08x\\n\",\n\t\t\t   rtw89_read32(rtwdev, R_AX_PLE_ERR_IMR));\n\t\trtw89_info(rtwdev, \"R_AX_PLE_ERR_FLAG_ISR=0x%08x\\n\",\n\t\t\t   rtw89_read32(rtwdev, R_AX_PLE_ERR_FLAG_ISR));\n\t}\n\n\tif (dmac_err & B_AX_TXPKTCTRL_ERR_FLAG) {\n\t\tif (chip->chip_id == RTL8852C) {\n\t\t\trtw89_info(rtwdev, \"R_AX_TXPKTCTL_B0_ERRFLAG_IMR=0x%08x\\n\",\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_TXPKTCTL_B0_ERRFLAG_IMR));\n\t\t\trtw89_info(rtwdev, \"R_AX_TXPKTCTL_B0_ERRFLAG_ISR=0x%08x\\n\",\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_TXPKTCTL_B0_ERRFLAG_ISR));\n\t\t\trtw89_info(rtwdev, \"R_AX_TXPKTCTL_B1_ERRFLAG_IMR=0x%08x\\n\",\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_TXPKTCTL_B1_ERRFLAG_IMR));\n\t\t\trtw89_info(rtwdev, \"R_AX_TXPKTCTL_B1_ERRFLAG_ISR=0x%08x\\n\",\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_TXPKTCTL_B1_ERRFLAG_ISR));\n\t\t} else {\n\t\t\trtw89_info(rtwdev, \"R_AX_TXPKTCTL_ERR_IMR_ISR=0x%08x\\n\",\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_TXPKTCTL_ERR_IMR_ISR));\n\t\t\trtw89_info(rtwdev, \"R_AX_TXPKTCTL_ERR_IMR_ISR_B1=0x%08x\\n\",\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_TXPKTCTL_ERR_IMR_ISR_B1));\n\t\t}\n\t}\n\n\tif (dmac_err & B_AX_PLE_DLE_ERR_FLAG) {\n\t\trtw89_info(rtwdev, \"R_AX_WDE_ERR_IMR=0x%08x\\n\",\n\t\t\t   rtw89_read32(rtwdev, R_AX_WDE_ERR_IMR));\n\t\trtw89_info(rtwdev, \"R_AX_WDE_ERR_ISR=0x%08x\\n\",\n\t\t\t   rtw89_read32(rtwdev, R_AX_WDE_ERR_ISR));\n\t\trtw89_info(rtwdev, \"R_AX_PLE_ERR_IMR=0x%08x\\n\",\n\t\t\t   rtw89_read32(rtwdev, R_AX_PLE_ERR_IMR));\n\t\trtw89_info(rtwdev, \"R_AX_PLE_ERR_FLAG_ISR=0x%08x\\n\",\n\t\t\t   rtw89_read32(rtwdev, R_AX_PLE_ERR_FLAG_ISR));\n\t\trtw89_info(rtwdev, \"R_AX_WD_CPUQ_OP_0=0x%08x\\n\",\n\t\t\t   rtw89_read32(rtwdev, R_AX_WD_CPUQ_OP_0));\n\t\trtw89_info(rtwdev, \"R_AX_WD_CPUQ_OP_1=0x%08x\\n\",\n\t\t\t   rtw89_read32(rtwdev, R_AX_WD_CPUQ_OP_1));\n\t\trtw89_info(rtwdev, \"R_AX_WD_CPUQ_OP_2=0x%08x\\n\",\n\t\t\t   rtw89_read32(rtwdev, R_AX_WD_CPUQ_OP_2));\n\t\trtw89_info(rtwdev, \"R_AX_WD_CPUQ_OP_STATUS=0x%08x\\n\",\n\t\t\t   rtw89_read32(rtwdev, R_AX_WD_CPUQ_OP_STATUS));\n\t\trtw89_info(rtwdev, \"R_AX_PL_CPUQ_OP_0=0x%08x\\n\",\n\t\t\t   rtw89_read32(rtwdev, R_AX_PL_CPUQ_OP_0));\n\t\trtw89_info(rtwdev, \"R_AX_PL_CPUQ_OP_1=0x%08x\\n\",\n\t\t\t   rtw89_read32(rtwdev, R_AX_PL_CPUQ_OP_1));\n\t\trtw89_info(rtwdev, \"R_AX_PL_CPUQ_OP_2=0x%08x\\n\",\n\t\t\t   rtw89_read32(rtwdev, R_AX_PL_CPUQ_OP_2));\n\t\trtw89_info(rtwdev, \"R_AX_PL_CPUQ_OP_STATUS=0x%08x\\n\",\n\t\t\t   rtw89_read32(rtwdev, R_AX_PL_CPUQ_OP_STATUS));\n\t\tif (chip->chip_id == RTL8852C) {\n\t\t\trtw89_info(rtwdev, \"R_AX_RX_CTRL0=0x%08x\\n\",\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_RX_CTRL0));\n\t\t\trtw89_info(rtwdev, \"R_AX_RX_CTRL1=0x%08x\\n\",\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_RX_CTRL1));\n\t\t\trtw89_info(rtwdev, \"R_AX_RX_CTRL2=0x%08x\\n\",\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_RX_CTRL2));\n\t\t} else {\n\t\t\trtw89_info(rtwdev, \"R_AX_RXDMA_PKT_INFO_0=0x%08x\\n\",\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_RXDMA_PKT_INFO_0));\n\t\t\trtw89_info(rtwdev, \"R_AX_RXDMA_PKT_INFO_1=0x%08x\\n\",\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_RXDMA_PKT_INFO_1));\n\t\t\trtw89_info(rtwdev, \"R_AX_RXDMA_PKT_INFO_2=0x%08x\\n\",\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_RXDMA_PKT_INFO_2));\n\t\t}\n\t}\n\n\tif (dmac_err & B_AX_PKTIN_ERR_FLAG) {\n\t\trtw89_info(rtwdev, \"R_AX_PKTIN_ERR_IMR=0x%08x\\n\",\n\t\t\t   rtw89_read32(rtwdev, R_AX_PKTIN_ERR_IMR));\n\t\trtw89_info(rtwdev, \"R_AX_PKTIN_ERR_ISR=0x%08x\\n\",\n\t\t\t   rtw89_read32(rtwdev, R_AX_PKTIN_ERR_ISR));\n\t}\n\n\tif (dmac_err & B_AX_DISPATCH_ERR_FLAG) {\n\t\trtw89_info(rtwdev, \"R_AX_HOST_DISPATCHER_ERR_IMR=0x%08x\\n\",\n\t\t\t   rtw89_read32(rtwdev, R_AX_HOST_DISPATCHER_ERR_IMR));\n\t\trtw89_info(rtwdev, \"R_AX_HOST_DISPATCHER_ERR_ISR=0x%08x\\n\",\n\t\t\t   rtw89_read32(rtwdev, R_AX_HOST_DISPATCHER_ERR_ISR));\n\t\trtw89_info(rtwdev, \"R_AX_CPU_DISPATCHER_ERR_IMR=0x%08x\\n\",\n\t\t\t   rtw89_read32(rtwdev, R_AX_CPU_DISPATCHER_ERR_IMR));\n\t\trtw89_info(rtwdev, \"R_AX_CPU_DISPATCHER_ERR_ISR=0x%08x\\n\",\n\t\t\t   rtw89_read32(rtwdev, R_AX_CPU_DISPATCHER_ERR_ISR));\n\t\trtw89_info(rtwdev, \"R_AX_OTHER_DISPATCHER_ERR_IMR=0x%08x\\n\",\n\t\t\t   rtw89_read32(rtwdev, R_AX_OTHER_DISPATCHER_ERR_IMR));\n\t\trtw89_info(rtwdev, \"R_AX_OTHER_DISPATCHER_ERR_ISR=0x%08x\\n\",\n\t\t\t   rtw89_read32(rtwdev, R_AX_OTHER_DISPATCHER_ERR_ISR));\n\t}\n\n\tif (dmac_err & B_AX_BBRPT_ERR_FLAG) {\n\t\tif (chip->chip_id == RTL8852C) {\n\t\t\trtw89_info(rtwdev, \"R_AX_BBRPT_COM_ERR_IMR=0x%08x\\n\",\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_BBRPT_COM_ERR_IMR));\n\t\t\trtw89_info(rtwdev, \"R_AX_BBRPT_COM_ERR_ISR=0x%08x\\n\",\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_BBRPT_COM_ERR_ISR));\n\t\t\trtw89_info(rtwdev, \"R_AX_BBRPT_CHINFO_ERR_ISR=0x%08x\\n\",\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_BBRPT_CHINFO_ERR_ISR));\n\t\t\trtw89_info(rtwdev, \"R_AX_BBRPT_CHINFO_ERR_IMR=0x%08x\\n\",\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_BBRPT_CHINFO_ERR_IMR));\n\t\t\trtw89_info(rtwdev, \"R_AX_BBRPT_DFS_ERR_IMR=0x%08x\\n\",\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_BBRPT_DFS_ERR_IMR));\n\t\t\trtw89_info(rtwdev, \"R_AX_BBRPT_DFS_ERR_ISR=0x%08x\\n\",\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_BBRPT_DFS_ERR_ISR));\n\t\t} else {\n\t\t\trtw89_info(rtwdev, \"R_AX_BBRPT_COM_ERR_IMR_ISR=0x%08x\\n\",\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_BBRPT_COM_ERR_IMR_ISR));\n\t\t\trtw89_info(rtwdev, \"R_AX_BBRPT_CHINFO_ERR_ISR=0x%08x\\n\",\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_BBRPT_CHINFO_ERR_ISR));\n\t\t\trtw89_info(rtwdev, \"R_AX_BBRPT_CHINFO_ERR_IMR=0x%08x\\n\",\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_BBRPT_CHINFO_ERR_IMR));\n\t\t\trtw89_info(rtwdev, \"R_AX_BBRPT_DFS_ERR_IMR=0x%08x\\n\",\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_BBRPT_DFS_ERR_IMR));\n\t\t\trtw89_info(rtwdev, \"R_AX_BBRPT_DFS_ERR_ISR=0x%08x\\n\",\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_BBRPT_DFS_ERR_ISR));\n\t\t}\n\t}\n\n\tif (dmac_err & B_AX_HAXIDMA_ERR_FLAG && chip->chip_id == RTL8852C) {\n\t\trtw89_info(rtwdev, \"R_AX_HAXIDMA_ERR_IMR=0x%08x\\n\",\n\t\t\t   rtw89_read32(rtwdev, R_AX_HAXI_IDCT_MSK));\n\t\trtw89_info(rtwdev, \"R_AX_HAXIDMA_ERR_ISR=0x%08x\\n\",\n\t\t\t   rtw89_read32(rtwdev, R_AX_HAXI_IDCT));\n\t}\n}\n\nstatic void rtw89_mac_dump_cmac_err_status(struct rtw89_dev *rtwdev,\n\t\t\t\t\t   u8 band)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tu32 offset = 0;\n\tu32 cmac_err;\n\tint ret;\n\n\tret = rtw89_mac_check_mac_en(rtwdev, band, RTW89_CMAC_SEL);\n\tif (ret) {\n\t\tif (band)\n\t\t\trtw89_warn(rtwdev, \"[CMAC] : CMAC1 not enabled\\n\");\n\t\telse\n\t\t\trtw89_warn(rtwdev, \"[CMAC] : CMAC0 not enabled\\n\");\n\t\treturn;\n\t}\n\n\tif (band)\n\t\toffset = RTW89_MAC_AX_BAND_REG_OFFSET;\n\n\tcmac_err = rtw89_read32(rtwdev, R_AX_CMAC_ERR_ISR + offset);\n\trtw89_info(rtwdev, \"R_AX_CMAC_ERR_ISR [%d]=0x%08x\\n\", band,\n\t\t   rtw89_read32(rtwdev, R_AX_CMAC_ERR_ISR + offset));\n\trtw89_info(rtwdev, \"R_AX_CMAC_FUNC_EN [%d]=0x%08x\\n\", band,\n\t\t   rtw89_read32(rtwdev, R_AX_CMAC_FUNC_EN + offset));\n\trtw89_info(rtwdev, \"R_AX_CK_EN [%d]=0x%08x\\n\", band,\n\t\t   rtw89_read32(rtwdev, R_AX_CK_EN + offset));\n\n\tif (cmac_err & B_AX_SCHEDULE_TOP_ERR_IND) {\n\t\trtw89_info(rtwdev, \"R_AX_SCHEDULE_ERR_IMR [%d]=0x%08x\\n\", band,\n\t\t\t   rtw89_read32(rtwdev, R_AX_SCHEDULE_ERR_IMR + offset));\n\t\trtw89_info(rtwdev, \"R_AX_SCHEDULE_ERR_ISR [%d]=0x%08x\\n\", band,\n\t\t\t   rtw89_read32(rtwdev, R_AX_SCHEDULE_ERR_ISR + offset));\n\t}\n\n\tif (cmac_err & B_AX_PTCL_TOP_ERR_IND) {\n\t\trtw89_info(rtwdev, \"R_AX_PTCL_IMR0 [%d]=0x%08x\\n\", band,\n\t\t\t   rtw89_read32(rtwdev, R_AX_PTCL_IMR0 + offset));\n\t\trtw89_info(rtwdev, \"R_AX_PTCL_ISR0 [%d]=0x%08x\\n\", band,\n\t\t\t   rtw89_read32(rtwdev, R_AX_PTCL_ISR0 + offset));\n\t}\n\n\tif (cmac_err & B_AX_DMA_TOP_ERR_IND) {\n\t\tif (chip->chip_id == RTL8852C) {\n\t\t\trtw89_info(rtwdev, \"R_AX_RX_ERR_FLAG [%d]=0x%08x\\n\", band,\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_RX_ERR_FLAG + offset));\n\t\t\trtw89_info(rtwdev, \"R_AX_RX_ERR_FLAG_IMR [%d]=0x%08x\\n\", band,\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_RX_ERR_FLAG_IMR + offset));\n\t\t} else {\n\t\t\trtw89_info(rtwdev, \"R_AX_DLE_CTRL [%d]=0x%08x\\n\", band,\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_DLE_CTRL + offset));\n\t\t}\n\t}\n\n\tif (cmac_err & B_AX_DMA_TOP_ERR_IND || cmac_err & B_AX_WMAC_RX_ERR_IND) {\n\t\tif (chip->chip_id == RTL8852C) {\n\t\t\trtw89_info(rtwdev, \"R_AX_PHYINFO_ERR_ISR [%d]=0x%08x\\n\", band,\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_PHYINFO_ERR_ISR + offset));\n\t\t\trtw89_info(rtwdev, \"R_AX_PHYINFO_ERR_IMR [%d]=0x%08x\\n\", band,\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_PHYINFO_ERR_IMR + offset));\n\t\t} else {\n\t\t\trtw89_info(rtwdev, \"R_AX_PHYINFO_ERR_IMR [%d]=0x%08x\\n\", band,\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_PHYINFO_ERR_IMR + offset));\n\t\t}\n\t}\n\n\tif (cmac_err & B_AX_TXPWR_CTRL_ERR_IND) {\n\t\trtw89_info(rtwdev, \"R_AX_TXPWR_IMR [%d]=0x%08x\\n\", band,\n\t\t\t   rtw89_read32(rtwdev, R_AX_TXPWR_IMR + offset));\n\t\trtw89_info(rtwdev, \"R_AX_TXPWR_ISR [%d]=0x%08x\\n\", band,\n\t\t\t   rtw89_read32(rtwdev, R_AX_TXPWR_ISR + offset));\n\t}\n\n\tif (cmac_err & B_AX_WMAC_TX_ERR_IND) {\n\t\tif (chip->chip_id == RTL8852C) {\n\t\t\trtw89_info(rtwdev, \"R_AX_TRXPTCL_ERROR_INDICA [%d]=0x%08x\\n\", band,\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_TRXPTCL_ERROR_INDICA + offset));\n\t\t\trtw89_info(rtwdev, \"R_AX_TRXPTCL_ERROR_INDICA_MASK [%d]=0x%08x\\n\", band,\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_TRXPTCL_ERROR_INDICA_MASK + offset));\n\t\t} else {\n\t\t\trtw89_info(rtwdev, \"R_AX_TMAC_ERR_IMR_ISR [%d]=0x%08x\\n\", band,\n\t\t\t\t   rtw89_read32(rtwdev, R_AX_TMAC_ERR_IMR_ISR + offset));\n\t\t}\n\t\trtw89_info(rtwdev, \"R_AX_DBGSEL_TRXPTCL [%d]=0x%08x\\n\", band,\n\t\t\t   rtw89_read32(rtwdev, R_AX_DBGSEL_TRXPTCL + offset));\n\t}\n\n\trtw89_info(rtwdev, \"R_AX_CMAC_ERR_IMR [%d]=0x%08x\\n\", band,\n\t\t   rtw89_read32(rtwdev, R_AX_CMAC_ERR_IMR + offset));\n}\n\nstatic void rtw89_mac_dump_err_status(struct rtw89_dev *rtwdev,\n\t\t\t\t      enum mac_ax_err_info err)\n{\n\tif (err != MAC_AX_ERR_L1_ERR_DMAC &&\n\t    err != MAC_AX_ERR_L0_PROMOTE_TO_L1 &&\n\t    err != MAC_AX_ERR_L0_ERR_CMAC0 &&\n\t    err != MAC_AX_ERR_L0_ERR_CMAC1 &&\n\t    err != MAC_AX_ERR_RXI300)\n\t\treturn;\n\n\trtw89_info(rtwdev, \"--->\\nerr=0x%x\\n\", err);\n\trtw89_info(rtwdev, \"R_AX_SER_DBG_INFO =0x%08x\\n\",\n\t\t   rtw89_read32(rtwdev, R_AX_SER_DBG_INFO));\n\n\trtw89_mac_dump_dmac_err_status(rtwdev);\n\trtw89_mac_dump_cmac_err_status(rtwdev, RTW89_MAC_0);\n\tif (rtwdev->dbcc_en)\n\t\trtw89_mac_dump_cmac_err_status(rtwdev, RTW89_MAC_1);\n\n\trtwdev->hci.ops->dump_err_status(rtwdev);\n\n\tif (err == MAC_AX_ERR_L0_PROMOTE_TO_L1)\n\t\trtw89_mac_dump_l0_to_l1(rtwdev, err);\n\n\trtw89_info(rtwdev, \"<---\\n\");\n}\n\nstatic bool rtw89_mac_suppress_log(struct rtw89_dev *rtwdev, u32 err)\n{\n\tstruct rtw89_ser *ser = &rtwdev->ser;\n\tu32 dmac_err, imr, isr;\n\tint ret;\n\n\tif (rtwdev->chip->chip_id == RTL8852C) {\n\t\tret = rtw89_mac_check_mac_en(rtwdev, 0, RTW89_DMAC_SEL);\n\t\tif (ret)\n\t\t\treturn true;\n\n\t\tif (err == MAC_AX_ERR_L1_ERR_DMAC) {\n\t\t\tdmac_err = rtw89_read32(rtwdev, R_AX_DMAC_ERR_ISR);\n\t\t\timr = rtw89_read32(rtwdev, R_AX_TXPKTCTL_B0_ERRFLAG_IMR);\n\t\t\tisr = rtw89_read32(rtwdev, R_AX_TXPKTCTL_B0_ERRFLAG_ISR);\n\n\t\t\tif ((dmac_err & B_AX_TXPKTCTRL_ERR_FLAG) &&\n\t\t\t    ((isr & imr) & B_AX_B0_ISR_ERR_CMDPSR_FRZTO)) {\n\t\t\t\tset_bit(RTW89_SER_SUPPRESS_LOG, ser->flags);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else if (err == MAC_AX_ERR_L1_RESET_DISABLE_DMAC_DONE) {\n\t\t\tif (test_bit(RTW89_SER_SUPPRESS_LOG, ser->flags))\n\t\t\t\treturn true;\n\t\t} else if (err == MAC_AX_ERR_L1_RESET_RECOVERY_DONE) {\n\t\t\tif (test_and_clear_bit(RTW89_SER_SUPPRESS_LOG, ser->flags))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nu32 rtw89_mac_get_err_status(struct rtw89_dev *rtwdev)\n{\n\tu32 err, err_scnr;\n\tint ret;\n\n\tret = read_poll_timeout(rtw89_read32, err, (err != 0), 1000, 100000,\n\t\t\t\tfalse, rtwdev, R_AX_HALT_C2H_CTRL);\n\tif (ret) {\n\t\trtw89_warn(rtwdev, \"Polling FW err status fail\\n\");\n\t\treturn ret;\n\t}\n\n\terr = rtw89_read32(rtwdev, R_AX_HALT_C2H);\n\trtw89_write32(rtwdev, R_AX_HALT_C2H_CTRL, 0);\n\n\terr_scnr = RTW89_ERROR_SCENARIO(err);\n\tif (err_scnr == RTW89_WCPU_CPU_EXCEPTION)\n\t\terr = MAC_AX_ERR_CPU_EXCEPTION;\n\telse if (err_scnr == RTW89_WCPU_ASSERTION)\n\t\terr = MAC_AX_ERR_ASSERTION;\n\telse if (err_scnr == RTW89_RXI300_ERROR)\n\t\terr = MAC_AX_ERR_RXI300;\n\n\tif (rtw89_mac_suppress_log(rtwdev, err))\n\t\treturn err;\n\n\trtw89_fw_st_dbg_dump(rtwdev);\n\trtw89_mac_dump_err_status(rtwdev, err);\n\n\treturn err;\n}\nEXPORT_SYMBOL(rtw89_mac_get_err_status);\n\nint rtw89_mac_set_err_status(struct rtw89_dev *rtwdev, u32 err)\n{\n\tstruct rtw89_ser *ser = &rtwdev->ser;\n\tu32 halt;\n\tint ret = 0;\n\n\tif (err > MAC_AX_SET_ERR_MAX) {\n\t\trtw89_err(rtwdev, \"Bad set-err-status value 0x%08x\\n\", err);\n\t\treturn -EINVAL;\n\t}\n\n\tret = read_poll_timeout(rtw89_read32, halt, (halt == 0x0), 1000,\n\t\t\t\t100000, false, rtwdev, R_AX_HALT_H2C_CTRL);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"FW doesn't receive previous msg\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\trtw89_write32(rtwdev, R_AX_HALT_H2C, err);\n\n\tif (ser->prehandle_l1 &&\n\t    (err == MAC_AX_ERR_L1_DISABLE_EN || err == MAC_AX_ERR_L1_RCVY_EN))\n\t\treturn 0;\n\n\trtw89_write32(rtwdev, R_AX_HALT_H2C_CTRL, B_AX_HALT_H2C_TRIGGER);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rtw89_mac_set_err_status);\n\nstatic int hfc_reset_param(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_hfc_param *param = &rtwdev->mac.hfc_param;\n\tstruct rtw89_hfc_param_ini param_ini = {NULL};\n\tu8 qta_mode = rtwdev->mac.dle_info.qta_mode;\n\n\tswitch (rtwdev->hci.type) {\n\tcase RTW89_HCI_TYPE_PCIE:\n\t\tparam_ini = rtwdev->chip->hfc_param_ini[qta_mode];\n\t\tparam->en = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (param_ini.pub_cfg)\n\t\tparam->pub_cfg = *param_ini.pub_cfg;\n\n\tif (param_ini.prec_cfg)\n\t\tparam->prec_cfg = *param_ini.prec_cfg;\n\n\tif (param_ini.ch_cfg)\n\t\tparam->ch_cfg = param_ini.ch_cfg;\n\n\tmemset(&param->ch_info, 0, sizeof(param->ch_info));\n\tmemset(&param->pub_info, 0, sizeof(param->pub_info));\n\tparam->mode = param_ini.mode;\n\n\treturn 0;\n}\n\nstatic int hfc_ch_cfg_chk(struct rtw89_dev *rtwdev, u8 ch)\n{\n\tstruct rtw89_hfc_param *param = &rtwdev->mac.hfc_param;\n\tconst struct rtw89_hfc_ch_cfg *ch_cfg = param->ch_cfg;\n\tconst struct rtw89_hfc_pub_cfg *pub_cfg = &param->pub_cfg;\n\tconst struct rtw89_hfc_prec_cfg *prec_cfg = &param->prec_cfg;\n\n\tif (ch >= RTW89_DMA_CH_NUM)\n\t\treturn -EINVAL;\n\n\tif ((ch_cfg[ch].min && ch_cfg[ch].min < prec_cfg->ch011_prec) ||\n\t    ch_cfg[ch].max > pub_cfg->pub_max)\n\t\treturn -EINVAL;\n\tif (ch_cfg[ch].grp >= grp_num)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int hfc_pub_info_chk(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_hfc_param *param = &rtwdev->mac.hfc_param;\n\tconst struct rtw89_hfc_pub_cfg *cfg = &param->pub_cfg;\n\tstruct rtw89_hfc_pub_info *info = &param->pub_info;\n\n\tif (info->g0_used + info->g1_used + info->pub_aval != cfg->pub_max) {\n\t\tif (rtwdev->chip->chip_id == RTL8852A)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\nstatic int hfc_pub_cfg_chk(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_hfc_param *param = &rtwdev->mac.hfc_param;\n\tconst struct rtw89_hfc_pub_cfg *pub_cfg = &param->pub_cfg;\n\n\tif (pub_cfg->grp0 + pub_cfg->grp1 != pub_cfg->pub_max)\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int hfc_ch_ctrl(struct rtw89_dev *rtwdev, u8 ch)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tconst struct rtw89_page_regs *regs = chip->page_regs;\n\tstruct rtw89_hfc_param *param = &rtwdev->mac.hfc_param;\n\tconst struct rtw89_hfc_ch_cfg *cfg = param->ch_cfg;\n\tint ret = 0;\n\tu32 val = 0;\n\n\tret = rtw89_mac_check_mac_en(rtwdev, RTW89_MAC_0, RTW89_DMAC_SEL);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hfc_ch_cfg_chk(rtwdev, ch);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ch > RTW89_DMA_B1HI)\n\t\treturn -EINVAL;\n\n\tval = u32_encode_bits(cfg[ch].min, B_AX_MIN_PG_MASK) |\n\t      u32_encode_bits(cfg[ch].max, B_AX_MAX_PG_MASK) |\n\t      (cfg[ch].grp ? B_AX_GRP : 0);\n\trtw89_write32(rtwdev, regs->ach_page_ctrl + ch * 4, val);\n\n\treturn 0;\n}\n\nstatic int hfc_upd_ch_info(struct rtw89_dev *rtwdev, u8 ch)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tconst struct rtw89_page_regs *regs = chip->page_regs;\n\tstruct rtw89_hfc_param *param = &rtwdev->mac.hfc_param;\n\tstruct rtw89_hfc_ch_info *info = param->ch_info;\n\tconst struct rtw89_hfc_ch_cfg *cfg = param->ch_cfg;\n\tu32 val;\n\tu32 ret;\n\n\tret = rtw89_mac_check_mac_en(rtwdev, RTW89_MAC_0, RTW89_DMAC_SEL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ch > RTW89_DMA_H2C)\n\t\treturn -EINVAL;\n\n\tval = rtw89_read32(rtwdev, regs->ach_page_info + ch * 4);\n\tinfo[ch].aval = u32_get_bits(val, B_AX_AVAL_PG_MASK);\n\tif (ch < RTW89_DMA_H2C)\n\t\tinfo[ch].used = u32_get_bits(val, B_AX_USE_PG_MASK);\n\telse\n\t\tinfo[ch].used = cfg[ch].min - info[ch].aval;\n\n\treturn 0;\n}\n\nstatic int hfc_pub_ctrl(struct rtw89_dev *rtwdev)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tconst struct rtw89_page_regs *regs = chip->page_regs;\n\tconst struct rtw89_hfc_pub_cfg *cfg = &rtwdev->mac.hfc_param.pub_cfg;\n\tu32 val;\n\tint ret;\n\n\tret = rtw89_mac_check_mac_en(rtwdev, RTW89_MAC_0, RTW89_DMAC_SEL);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hfc_pub_cfg_chk(rtwdev);\n\tif (ret)\n\t\treturn ret;\n\n\tval = u32_encode_bits(cfg->grp0, B_AX_PUBPG_G0_MASK) |\n\t      u32_encode_bits(cfg->grp1, B_AX_PUBPG_G1_MASK);\n\trtw89_write32(rtwdev, regs->pub_page_ctrl1, val);\n\n\tval = u32_encode_bits(cfg->wp_thrd, B_AX_WP_THRD_MASK);\n\trtw89_write32(rtwdev, regs->wp_page_ctrl2, val);\n\n\treturn 0;\n}\n\nstatic int hfc_upd_mix_info(struct rtw89_dev *rtwdev)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tconst struct rtw89_page_regs *regs = chip->page_regs;\n\tstruct rtw89_hfc_param *param = &rtwdev->mac.hfc_param;\n\tstruct rtw89_hfc_pub_cfg *pub_cfg = &param->pub_cfg;\n\tstruct rtw89_hfc_prec_cfg *prec_cfg = &param->prec_cfg;\n\tstruct rtw89_hfc_pub_info *info = &param->pub_info;\n\tu32 val;\n\tint ret;\n\n\tret = rtw89_mac_check_mac_en(rtwdev, RTW89_MAC_0, RTW89_DMAC_SEL);\n\tif (ret)\n\t\treturn ret;\n\n\tval = rtw89_read32(rtwdev, regs->pub_page_info1);\n\tinfo->g0_used = u32_get_bits(val, B_AX_G0_USE_PG_MASK);\n\tinfo->g1_used = u32_get_bits(val, B_AX_G1_USE_PG_MASK);\n\tval = rtw89_read32(rtwdev, regs->pub_page_info3);\n\tinfo->g0_aval = u32_get_bits(val, B_AX_G0_AVAL_PG_MASK);\n\tinfo->g1_aval = u32_get_bits(val, B_AX_G1_AVAL_PG_MASK);\n\tinfo->pub_aval =\n\t\tu32_get_bits(rtw89_read32(rtwdev, regs->pub_page_info2),\n\t\t\t     B_AX_PUB_AVAL_PG_MASK);\n\tinfo->wp_aval =\n\t\tu32_get_bits(rtw89_read32(rtwdev, regs->wp_page_info1),\n\t\t\t     B_AX_WP_AVAL_PG_MASK);\n\n\tval = rtw89_read32(rtwdev, regs->hci_fc_ctrl);\n\tparam->en = val & B_AX_HCI_FC_EN ? 1 : 0;\n\tparam->h2c_en = val & B_AX_HCI_FC_CH12_EN ? 1 : 0;\n\tparam->mode = u32_get_bits(val, B_AX_HCI_FC_MODE_MASK);\n\tprec_cfg->ch011_full_cond =\n\t\tu32_get_bits(val, B_AX_HCI_FC_WD_FULL_COND_MASK);\n\tprec_cfg->h2c_full_cond =\n\t\tu32_get_bits(val, B_AX_HCI_FC_CH12_FULL_COND_MASK);\n\tprec_cfg->wp_ch07_full_cond =\n\t\tu32_get_bits(val, B_AX_HCI_FC_WP_CH07_FULL_COND_MASK);\n\tprec_cfg->wp_ch811_full_cond =\n\t\tu32_get_bits(val, B_AX_HCI_FC_WP_CH811_FULL_COND_MASK);\n\n\tval = rtw89_read32(rtwdev, regs->ch_page_ctrl);\n\tprec_cfg->ch011_prec = u32_get_bits(val, B_AX_PREC_PAGE_CH011_MASK);\n\tprec_cfg->h2c_prec = u32_get_bits(val, B_AX_PREC_PAGE_CH12_MASK);\n\n\tval = rtw89_read32(rtwdev, regs->pub_page_ctrl2);\n\tpub_cfg->pub_max = u32_get_bits(val, B_AX_PUBPG_ALL_MASK);\n\n\tval = rtw89_read32(rtwdev, regs->wp_page_ctrl1);\n\tprec_cfg->wp_ch07_prec = u32_get_bits(val, B_AX_PREC_PAGE_WP_CH07_MASK);\n\tprec_cfg->wp_ch811_prec = u32_get_bits(val, B_AX_PREC_PAGE_WP_CH811_MASK);\n\n\tval = rtw89_read32(rtwdev, regs->wp_page_ctrl2);\n\tpub_cfg->wp_thrd = u32_get_bits(val, B_AX_WP_THRD_MASK);\n\n\tval = rtw89_read32(rtwdev, regs->pub_page_ctrl1);\n\tpub_cfg->grp0 = u32_get_bits(val, B_AX_PUBPG_G0_MASK);\n\tpub_cfg->grp1 = u32_get_bits(val, B_AX_PUBPG_G1_MASK);\n\n\tret = hfc_pub_info_chk(rtwdev);\n\tif (param->en && ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void hfc_h2c_cfg(struct rtw89_dev *rtwdev)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tconst struct rtw89_page_regs *regs = chip->page_regs;\n\tstruct rtw89_hfc_param *param = &rtwdev->mac.hfc_param;\n\tconst struct rtw89_hfc_prec_cfg *prec_cfg = &param->prec_cfg;\n\tu32 val;\n\n\tval = u32_encode_bits(prec_cfg->h2c_prec, B_AX_PREC_PAGE_CH12_MASK);\n\trtw89_write32(rtwdev, regs->ch_page_ctrl, val);\n\n\trtw89_write32_mask(rtwdev, regs->hci_fc_ctrl,\n\t\t\t   B_AX_HCI_FC_CH12_FULL_COND_MASK,\n\t\t\t   prec_cfg->h2c_full_cond);\n}\n\nstatic void hfc_mix_cfg(struct rtw89_dev *rtwdev)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tconst struct rtw89_page_regs *regs = chip->page_regs;\n\tstruct rtw89_hfc_param *param = &rtwdev->mac.hfc_param;\n\tconst struct rtw89_hfc_pub_cfg *pub_cfg = &param->pub_cfg;\n\tconst struct rtw89_hfc_prec_cfg *prec_cfg = &param->prec_cfg;\n\tu32 val;\n\n\tval = u32_encode_bits(prec_cfg->ch011_prec, B_AX_PREC_PAGE_CH011_MASK) |\n\t      u32_encode_bits(prec_cfg->h2c_prec, B_AX_PREC_PAGE_CH12_MASK);\n\trtw89_write32(rtwdev, regs->ch_page_ctrl, val);\n\n\tval = u32_encode_bits(pub_cfg->pub_max, B_AX_PUBPG_ALL_MASK);\n\trtw89_write32(rtwdev, regs->pub_page_ctrl2, val);\n\n\tval = u32_encode_bits(prec_cfg->wp_ch07_prec,\n\t\t\t      B_AX_PREC_PAGE_WP_CH07_MASK) |\n\t      u32_encode_bits(prec_cfg->wp_ch811_prec,\n\t\t\t      B_AX_PREC_PAGE_WP_CH811_MASK);\n\trtw89_write32(rtwdev, regs->wp_page_ctrl1, val);\n\n\tval = u32_replace_bits(rtw89_read32(rtwdev, regs->hci_fc_ctrl),\n\t\t\t       param->mode, B_AX_HCI_FC_MODE_MASK);\n\tval = u32_replace_bits(val, prec_cfg->ch011_full_cond,\n\t\t\t       B_AX_HCI_FC_WD_FULL_COND_MASK);\n\tval = u32_replace_bits(val, prec_cfg->h2c_full_cond,\n\t\t\t       B_AX_HCI_FC_CH12_FULL_COND_MASK);\n\tval = u32_replace_bits(val, prec_cfg->wp_ch07_full_cond,\n\t\t\t       B_AX_HCI_FC_WP_CH07_FULL_COND_MASK);\n\tval = u32_replace_bits(val, prec_cfg->wp_ch811_full_cond,\n\t\t\t       B_AX_HCI_FC_WP_CH811_FULL_COND_MASK);\n\trtw89_write32(rtwdev, regs->hci_fc_ctrl, val);\n}\n\nstatic void hfc_func_en(struct rtw89_dev *rtwdev, bool en, bool h2c_en)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tconst struct rtw89_page_regs *regs = chip->page_regs;\n\tstruct rtw89_hfc_param *param = &rtwdev->mac.hfc_param;\n\tu32 val;\n\n\tval = rtw89_read32(rtwdev, regs->hci_fc_ctrl);\n\tparam->en = en;\n\tparam->h2c_en = h2c_en;\n\tval = en ? (val | B_AX_HCI_FC_EN) : (val & ~B_AX_HCI_FC_EN);\n\tval = h2c_en ? (val | B_AX_HCI_FC_CH12_EN) :\n\t\t\t (val & ~B_AX_HCI_FC_CH12_EN);\n\trtw89_write32(rtwdev, regs->hci_fc_ctrl, val);\n}\n\nstatic int hfc_init(struct rtw89_dev *rtwdev, bool reset, bool en, bool h2c_en)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tu32 dma_ch_mask = chip->dma_ch_mask;\n\tu8 ch;\n\tu32 ret = 0;\n\n\tif (reset)\n\t\tret = hfc_reset_param(rtwdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rtw89_mac_check_mac_en(rtwdev, RTW89_MAC_0, RTW89_DMAC_SEL);\n\tif (ret)\n\t\treturn ret;\n\n\thfc_func_en(rtwdev, false, false);\n\n\tif (!en && h2c_en) {\n\t\thfc_h2c_cfg(rtwdev);\n\t\thfc_func_en(rtwdev, en, h2c_en);\n\t\treturn ret;\n\t}\n\n\tfor (ch = RTW89_DMA_ACH0; ch < RTW89_DMA_H2C; ch++) {\n\t\tif (dma_ch_mask & BIT(ch))\n\t\t\tcontinue;\n\t\tret = hfc_ch_ctrl(rtwdev, ch);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = hfc_pub_ctrl(rtwdev);\n\tif (ret)\n\t\treturn ret;\n\n\thfc_mix_cfg(rtwdev);\n\tif (en || h2c_en) {\n\t\thfc_func_en(rtwdev, en, h2c_en);\n\t\tudelay(10);\n\t}\n\tfor (ch = RTW89_DMA_ACH0; ch < RTW89_DMA_H2C; ch++) {\n\t\tif (dma_ch_mask & BIT(ch))\n\t\t\tcontinue;\n\t\tret = hfc_upd_ch_info(rtwdev, ch);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tret = hfc_upd_mix_info(rtwdev);\n\n\treturn ret;\n}\n\n#define PWR_POLL_CNT\t2000\nstatic int pwr_cmd_poll(struct rtw89_dev *rtwdev,\n\t\t\tconst struct rtw89_pwr_cfg *cfg)\n{\n\tu8 val = 0;\n\tint ret;\n\tu32 addr = cfg->base == PWR_INTF_MSK_SDIO ?\n\t\t   cfg->addr | SDIO_LOCAL_BASE_ADDR : cfg->addr;\n\n\tret = read_poll_timeout(rtw89_read8, val, !((val ^ cfg->val) & cfg->msk),\n\t\t\t\t1000, 1000 * PWR_POLL_CNT, false, rtwdev, addr);\n\n\tif (!ret)\n\t\treturn 0;\n\n\trtw89_warn(rtwdev, \"[ERR] Polling timeout\\n\");\n\trtw89_warn(rtwdev, \"[ERR] addr: %X, %X\\n\", addr, cfg->addr);\n\trtw89_warn(rtwdev, \"[ERR] val: %X, %X\\n\", val, cfg->val);\n\n\treturn -EBUSY;\n}\n\nstatic int rtw89_mac_sub_pwr_seq(struct rtw89_dev *rtwdev, u8 cv_msk,\n\t\t\t\t u8 intf_msk, const struct rtw89_pwr_cfg *cfg)\n{\n\tconst struct rtw89_pwr_cfg *cur_cfg;\n\tu32 addr;\n\tu8 val;\n\n\tfor (cur_cfg = cfg; cur_cfg->cmd != PWR_CMD_END; cur_cfg++) {\n\t\tif (!(cur_cfg->intf_msk & intf_msk) ||\n\t\t    !(cur_cfg->cv_msk & cv_msk))\n\t\t\tcontinue;\n\n\t\tswitch (cur_cfg->cmd) {\n\t\tcase PWR_CMD_WRITE:\n\t\t\taddr = cur_cfg->addr;\n\n\t\t\tif (cur_cfg->base == PWR_BASE_SDIO)\n\t\t\t\taddr |= SDIO_LOCAL_BASE_ADDR;\n\n\t\t\tval = rtw89_read8(rtwdev, addr);\n\t\t\tval &= ~(cur_cfg->msk);\n\t\t\tval |= (cur_cfg->val & cur_cfg->msk);\n\n\t\t\trtw89_write8(rtwdev, addr, val);\n\t\t\tbreak;\n\t\tcase PWR_CMD_POLL:\n\t\t\tif (pwr_cmd_poll(rtwdev, cur_cfg))\n\t\t\t\treturn -EBUSY;\n\t\t\tbreak;\n\t\tcase PWR_CMD_DELAY:\n\t\t\tif (cur_cfg->val == PWR_DELAY_US)\n\t\t\t\tudelay(cur_cfg->addr);\n\t\t\telse\n\t\t\t\tfsleep(cur_cfg->addr * 1000);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int rtw89_mac_pwr_seq(struct rtw89_dev *rtwdev,\n\t\t\t     const struct rtw89_pwr_cfg * const *cfg_seq)\n{\n\tint ret;\n\n\tfor (; *cfg_seq; cfg_seq++) {\n\t\tret = rtw89_mac_sub_pwr_seq(rtwdev, BIT(rtwdev->hal.cv),\n\t\t\t\t\t    PWR_INTF_MSK_PCIE, *cfg_seq);\n\t\tif (ret)\n\t\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic enum rtw89_rpwm_req_pwr_state\nrtw89_mac_get_req_pwr_state(struct rtw89_dev *rtwdev)\n{\n\tenum rtw89_rpwm_req_pwr_state state;\n\n\tswitch (rtwdev->ps_mode) {\n\tcase RTW89_PS_MODE_RFOFF:\n\t\tstate = RTW89_MAC_RPWM_REQ_PWR_STATE_BAND0_RFOFF;\n\t\tbreak;\n\tcase RTW89_PS_MODE_CLK_GATED:\n\t\tstate = RTW89_MAC_RPWM_REQ_PWR_STATE_CLK_GATED;\n\t\tbreak;\n\tcase RTW89_PS_MODE_PWR_GATED:\n\t\tstate = RTW89_MAC_RPWM_REQ_PWR_STATE_PWR_GATED;\n\t\tbreak;\n\tdefault:\n\t\tstate = RTW89_MAC_RPWM_REQ_PWR_STATE_ACTIVE;\n\t\tbreak;\n\t}\n\treturn state;\n}\n\nstatic void rtw89_mac_send_rpwm(struct rtw89_dev *rtwdev,\n\t\t\t\tenum rtw89_rpwm_req_pwr_state req_pwr_state,\n\t\t\t\tbool notify_wake)\n{\n\tu16 request;\n\n\tspin_lock_bh(&rtwdev->rpwm_lock);\n\n\trequest = rtw89_read16(rtwdev, R_AX_RPWM);\n\trequest ^= request | PS_RPWM_TOGGLE;\n\trequest |= req_pwr_state;\n\n\tif (notify_wake) {\n\t\trequest |= PS_RPWM_NOTIFY_WAKE;\n\t} else {\n\t\trtwdev->mac.rpwm_seq_num = (rtwdev->mac.rpwm_seq_num + 1) &\n\t\t\t\t\t    RPWM_SEQ_NUM_MAX;\n\t\trequest |= FIELD_PREP(PS_RPWM_SEQ_NUM,\n\t\t\t\t      rtwdev->mac.rpwm_seq_num);\n\n\t\tif (req_pwr_state < RTW89_MAC_RPWM_REQ_PWR_STATE_CLK_GATED)\n\t\t\trequest |= PS_RPWM_ACK;\n\t}\n\trtw89_write16(rtwdev, rtwdev->hci.rpwm_addr, request);\n\n\tspin_unlock_bh(&rtwdev->rpwm_lock);\n}\n\nstatic int rtw89_mac_check_cpwm_state(struct rtw89_dev *rtwdev,\n\t\t\t\t      enum rtw89_rpwm_req_pwr_state req_pwr_state)\n{\n\tbool request_deep_mode;\n\tbool in_deep_mode;\n\tu8 rpwm_req_num;\n\tu8 cpwm_rsp_seq;\n\tu8 cpwm_seq;\n\tu8 cpwm_status;\n\n\tif (req_pwr_state >= RTW89_MAC_RPWM_REQ_PWR_STATE_CLK_GATED)\n\t\trequest_deep_mode = true;\n\telse\n\t\trequest_deep_mode = false;\n\n\tif (rtw89_read32_mask(rtwdev, R_AX_LDM, B_AX_EN_32K))\n\t\tin_deep_mode = true;\n\telse\n\t\tin_deep_mode = false;\n\n\tif (request_deep_mode != in_deep_mode)\n\t\treturn -EPERM;\n\n\tif (request_deep_mode)\n\t\treturn 0;\n\n\trpwm_req_num = rtwdev->mac.rpwm_seq_num;\n\tcpwm_rsp_seq = rtw89_read16_mask(rtwdev, rtwdev->hci.cpwm_addr,\n\t\t\t\t\t PS_CPWM_RSP_SEQ_NUM);\n\n\tif (rpwm_req_num != cpwm_rsp_seq)\n\t\treturn -EPERM;\n\n\trtwdev->mac.cpwm_seq_num = (rtwdev->mac.cpwm_seq_num + 1) &\n\t\t\t\t    CPWM_SEQ_NUM_MAX;\n\n\tcpwm_seq = rtw89_read16_mask(rtwdev, rtwdev->hci.cpwm_addr, PS_CPWM_SEQ_NUM);\n\tif (cpwm_seq != rtwdev->mac.cpwm_seq_num)\n\t\treturn -EPERM;\n\n\tcpwm_status = rtw89_read16_mask(rtwdev, rtwdev->hci.cpwm_addr, PS_CPWM_STATE);\n\tif (cpwm_status != req_pwr_state)\n\t\treturn -EPERM;\n\n\treturn 0;\n}\n\nvoid rtw89_mac_power_mode_change(struct rtw89_dev *rtwdev, bool enter)\n{\n\tenum rtw89_rpwm_req_pwr_state state;\n\tunsigned long delay = enter ? 10 : 150;\n\tint ret;\n\tint i;\n\n\tif (enter)\n\t\tstate = rtw89_mac_get_req_pwr_state(rtwdev);\n\telse\n\t\tstate = RTW89_MAC_RPWM_REQ_PWR_STATE_ACTIVE;\n\n\tfor (i = 0; i < RPWM_TRY_CNT; i++) {\n\t\trtw89_mac_send_rpwm(rtwdev, state, false);\n\t\tret = read_poll_timeout_atomic(rtw89_mac_check_cpwm_state, ret,\n\t\t\t\t\t       !ret, delay, 15000, false,\n\t\t\t\t\t       rtwdev, state);\n\t\tif (!ret)\n\t\t\tbreak;\n\n\t\tif (i == RPWM_TRY_CNT - 1)\n\t\t\trtw89_err(rtwdev, \"firmware failed to ack for %s ps mode\\n\",\n\t\t\t\t  enter ? \"entering\" : \"leaving\");\n\t\telse\n\t\t\trtw89_debug(rtwdev, RTW89_DBG_UNEXP,\n\t\t\t\t    \"%d time firmware failed to ack for %s ps mode\\n\",\n\t\t\t\t    i + 1, enter ? \"entering\" : \"leaving\");\n\t}\n}\n\nvoid rtw89_mac_notify_wake(struct rtw89_dev *rtwdev)\n{\n\tenum rtw89_rpwm_req_pwr_state state;\n\n\tstate = rtw89_mac_get_req_pwr_state(rtwdev);\n\trtw89_mac_send_rpwm(rtwdev, state, true);\n}\n\nstatic int rtw89_mac_power_switch(struct rtw89_dev *rtwdev, bool on)\n{\n#define PWR_ACT 1\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tconst struct rtw89_pwr_cfg * const *cfg_seq;\n\tint (*cfg_func)(struct rtw89_dev *rtwdev);\n\tint ret;\n\tu8 val;\n\n\tif (on) {\n\t\tcfg_seq = chip->pwr_on_seq;\n\t\tcfg_func = chip->ops->pwr_on_func;\n\t} else {\n\t\tcfg_seq = chip->pwr_off_seq;\n\t\tcfg_func = chip->ops->pwr_off_func;\n\t}\n\n\tif (test_bit(RTW89_FLAG_FW_RDY, rtwdev->flags))\n\t\t__rtw89_leave_ps_mode(rtwdev);\n\n\tval = rtw89_read32_mask(rtwdev, R_AX_IC_PWR_STATE, B_AX_WLMAC_PWR_STE_MASK);\n\tif (on && val == PWR_ACT) {\n\t\trtw89_err(rtwdev, \"MAC has already powered on\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tret = cfg_func ? cfg_func(rtwdev) : rtw89_mac_pwr_seq(rtwdev, cfg_seq);\n\tif (ret)\n\t\treturn ret;\n\n\tif (on) {\n\t\tset_bit(RTW89_FLAG_POWERON, rtwdev->flags);\n\t\trtw89_write8(rtwdev, R_AX_SCOREBOARD + 3, MAC_AX_NOTIFY_TP_MAJOR);\n\t} else {\n\t\tclear_bit(RTW89_FLAG_POWERON, rtwdev->flags);\n\t\tclear_bit(RTW89_FLAG_FW_RDY, rtwdev->flags);\n\t\trtw89_write8(rtwdev, R_AX_SCOREBOARD + 3, MAC_AX_NOTIFY_PWR_MAJOR);\n\t\trtw89_set_entity_state(rtwdev, false);\n\t}\n\n\treturn 0;\n#undef PWR_ACT\n}\n\nvoid rtw89_mac_pwr_off(struct rtw89_dev *rtwdev)\n{\n\trtw89_mac_power_switch(rtwdev, false);\n}\n\nstatic int cmac_func_en(struct rtw89_dev *rtwdev, u8 mac_idx, bool en)\n{\n\tu32 func_en = 0;\n\tu32 ck_en = 0;\n\tu32 c1pc_en = 0;\n\tu32 addrl_func_en[] = {R_AX_CMAC_FUNC_EN, R_AX_CMAC_FUNC_EN_C1};\n\tu32 addrl_ck_en[] = {R_AX_CK_EN, R_AX_CK_EN_C1};\n\n\tfunc_en = B_AX_CMAC_EN | B_AX_CMAC_TXEN | B_AX_CMAC_RXEN |\n\t\t\tB_AX_PHYINTF_EN | B_AX_CMAC_DMA_EN | B_AX_PTCLTOP_EN |\n\t\t\tB_AX_SCHEDULER_EN | B_AX_TMAC_EN | B_AX_RMAC_EN |\n\t\t\tB_AX_CMAC_CRPRT;\n\tck_en = B_AX_CMAC_CKEN | B_AX_PHYINTF_CKEN | B_AX_CMAC_DMA_CKEN |\n\t\t      B_AX_PTCLTOP_CKEN | B_AX_SCHEDULER_CKEN | B_AX_TMAC_CKEN |\n\t\t      B_AX_RMAC_CKEN;\n\tc1pc_en = B_AX_R_SYM_WLCMAC1_PC_EN |\n\t\t\tB_AX_R_SYM_WLCMAC1_P1_PC_EN |\n\t\t\tB_AX_R_SYM_WLCMAC1_P2_PC_EN |\n\t\t\tB_AX_R_SYM_WLCMAC1_P3_PC_EN |\n\t\t\tB_AX_R_SYM_WLCMAC1_P4_PC_EN;\n\n\tif (en) {\n\t\tif (mac_idx == RTW89_MAC_1) {\n\t\t\trtw89_write32_set(rtwdev, R_AX_AFE_CTRL1, c1pc_en);\n\t\t\trtw89_write32_clr(rtwdev, R_AX_SYS_ISO_CTRL_EXTEND,\n\t\t\t\t\t  B_AX_R_SYM_ISO_CMAC12PP);\n\t\t\trtw89_write32_set(rtwdev, R_AX_SYS_ISO_CTRL_EXTEND,\n\t\t\t\t\t  B_AX_CMAC1_FEN);\n\t\t}\n\t\trtw89_write32_set(rtwdev, addrl_ck_en[mac_idx], ck_en);\n\t\trtw89_write32_set(rtwdev, addrl_func_en[mac_idx], func_en);\n\t} else {\n\t\trtw89_write32_clr(rtwdev, addrl_func_en[mac_idx], func_en);\n\t\trtw89_write32_clr(rtwdev, addrl_ck_en[mac_idx], ck_en);\n\t\tif (mac_idx == RTW89_MAC_1) {\n\t\t\trtw89_write32_clr(rtwdev, R_AX_SYS_ISO_CTRL_EXTEND,\n\t\t\t\t\t  B_AX_CMAC1_FEN);\n\t\t\trtw89_write32_set(rtwdev, R_AX_SYS_ISO_CTRL_EXTEND,\n\t\t\t\t\t  B_AX_R_SYM_ISO_CMAC12PP);\n\t\t\trtw89_write32_clr(rtwdev, R_AX_AFE_CTRL1, c1pc_en);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int dmac_func_en(struct rtw89_dev *rtwdev)\n{\n\tenum rtw89_core_chip_id chip_id = rtwdev->chip->chip_id;\n\tu32 val32;\n\n\tif (chip_id == RTL8852C)\n\t\tval32 = (B_AX_MAC_FUNC_EN | B_AX_DMAC_FUNC_EN |\n\t\t\t B_AX_MAC_SEC_EN | B_AX_DISPATCHER_EN |\n\t\t\t B_AX_DLE_CPUIO_EN | B_AX_PKT_IN_EN |\n\t\t\t B_AX_DMAC_TBL_EN | B_AX_PKT_BUF_EN |\n\t\t\t B_AX_STA_SCH_EN | B_AX_TXPKT_CTRL_EN |\n\t\t\t B_AX_WD_RLS_EN | B_AX_MPDU_PROC_EN |\n\t\t\t B_AX_DMAC_CRPRT | B_AX_H_AXIDMA_EN);\n\telse\n\t\tval32 = (B_AX_MAC_FUNC_EN | B_AX_DMAC_FUNC_EN |\n\t\t\t B_AX_MAC_SEC_EN | B_AX_DISPATCHER_EN |\n\t\t\t B_AX_DLE_CPUIO_EN | B_AX_PKT_IN_EN |\n\t\t\t B_AX_DMAC_TBL_EN | B_AX_PKT_BUF_EN |\n\t\t\t B_AX_STA_SCH_EN | B_AX_TXPKT_CTRL_EN |\n\t\t\t B_AX_WD_RLS_EN | B_AX_MPDU_PROC_EN |\n\t\t\t B_AX_DMAC_CRPRT);\n\trtw89_write32(rtwdev, R_AX_DMAC_FUNC_EN, val32);\n\n\tval32 = (B_AX_MAC_SEC_CLK_EN | B_AX_DISPATCHER_CLK_EN |\n\t\t B_AX_DLE_CPUIO_CLK_EN | B_AX_PKT_IN_CLK_EN |\n\t\t B_AX_STA_SCH_CLK_EN | B_AX_TXPKT_CTRL_CLK_EN |\n\t\t B_AX_WD_RLS_CLK_EN | B_AX_BBRPT_CLK_EN);\n\trtw89_write32(rtwdev, R_AX_DMAC_CLK_EN, val32);\n\n\treturn 0;\n}\n\nstatic int chip_func_en(struct rtw89_dev *rtwdev)\n{\n\tenum rtw89_core_chip_id chip_id = rtwdev->chip->chip_id;\n\n\tif (chip_id == RTL8852A || chip_id == RTL8852B)\n\t\trtw89_write32_set(rtwdev, R_AX_SPS_DIG_ON_CTRL0,\n\t\t\t\t  B_AX_OCP_L1_MASK);\n\n\treturn 0;\n}\n\nstatic int rtw89_mac_sys_init(struct rtw89_dev *rtwdev)\n{\n\tint ret;\n\n\tret = dmac_func_en(rtwdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = cmac_func_en(rtwdev, 0, true);\n\tif (ret)\n\t\treturn ret;\n\n\tret = chip_func_en(rtwdev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ret;\n}\n\nconst struct rtw89_mac_size_set rtw89_mac_size = {\n\t.hfc_preccfg_pcie = {2, 40, 0, 0, 1, 0, 0, 0},\n\t \n\t.wde_size0 = {RTW89_WDE_PG_64, 4095, 1,},\n\t \n\t.wde_size4 = {RTW89_WDE_PG_64, 0, 4096,},\n\t \n\t.wde_size6 = {RTW89_WDE_PG_64, 512, 0,},\n\t \n\t.wde_size7 = {RTW89_WDE_PG_64, 510, 2,},\n\t \n\t.wde_size9 = {RTW89_WDE_PG_64, 0, 1024,},\n\t \n\t.wde_size18 = {RTW89_WDE_PG_64, 0, 2048,},\n\t \n\t.wde_size19 = {RTW89_WDE_PG_64, 3328, 0,},\n\t \n\t.ple_size0 = {RTW89_PLE_PG_128, 1520, 16,},\n\t \n\t.ple_size4 = {RTW89_PLE_PG_128, 64, 1472,},\n\t \n\t.ple_size6 = {RTW89_PLE_PG_128, 496, 16,},\n\t \n\t.ple_size8 = {RTW89_PLE_PG_128, 64, 960,},\n\t \n\t.ple_size18 = {RTW89_PLE_PG_128, 2544, 16,},\n\t \n\t.ple_size19 = {RTW89_PLE_PG_128, 1904, 16,},\n\t \n\t.wde_qt0 = {3792, 196, 0, 107,},\n\t \n\t.wde_qt4 = {0, 0, 0, 0,},\n\t \n\t.wde_qt6 = {448, 48, 0, 16,},\n\t \n\t.wde_qt7 = {446, 48, 0, 16,},\n\t \n\t.wde_qt17 = {0, 0, 0,  0,},\n\t \n\t.wde_qt18 = {3228, 60, 0, 40,},\n\t \n\t.ple_qt4 = {264, 0, 16, 20, 26, 13, 356, 0, 32, 40, 8,},\n\t \n\t.ple_qt5 = {264, 0, 32, 20, 64, 13, 1101, 0, 64, 128, 120,},\n\t \n\t.ple_qt13 = {0, 0, 16, 48, 0, 0, 0, 0, 0, 0, 0,},\n\t \n\t.ple_qt18 = {147, 0, 16, 20, 17, 13, 89, 0, 32, 14, 8, 0,},\n\t \n\t.ple_qt44 = {0, 0, 16, 256, 0, 0, 0, 0, 0, 0, 0, 0,},\n\t \n\t.ple_qt45 = {0, 0, 32, 256, 0, 0, 0, 0, 0, 0, 0, 0,},\n\t \n\t.ple_qt46 = {525, 0, 16, 20, 13, 13, 178, 0, 32, 62, 8, 16,},\n\t \n\t.ple_qt47 = {525, 0, 32, 20, 1034, 13, 1199, 0, 1053, 62, 160, 1037,},\n\t \n\t.ple_qt58 = {147, 0, 16, 20, 157, 13, 229, 0, 172, 14, 24, 0,},\n\t \n\t.ple_qt_52a_wow = {264, 0, 32, 20, 64, 13, 1005, 0, 64, 128, 120,},\n\t \n\t.ple_qt_52b_wow = {147, 0, 16, 20, 157, 13, 133, 0, 172, 14, 24, 0,},\n\t \n\t.ple_qt_51b_wow = {147, 0, 16, 20, 157, 13, 133, 0, 172, 14, 24, 0,},\n};\nEXPORT_SYMBOL(rtw89_mac_size);\n\nstatic const struct rtw89_dle_mem *get_dle_mem_cfg(struct rtw89_dev *rtwdev,\n\t\t\t\t\t\t   enum rtw89_qta_mode mode)\n{\n\tstruct rtw89_mac_info *mac = &rtwdev->mac;\n\tconst struct rtw89_dle_mem *cfg;\n\n\tcfg = &rtwdev->chip->dle_mem[mode];\n\tif (!cfg)\n\t\treturn NULL;\n\n\tif (cfg->mode != mode) {\n\t\trtw89_warn(rtwdev, \"qta mode unmatch!\\n\");\n\t\treturn NULL;\n\t}\n\n\tmac->dle_info.ple_pg_size = cfg->ple_size->pge_size;\n\tmac->dle_info.qta_mode = mode;\n\tmac->dle_info.c0_rx_qta = cfg->ple_min_qt->cma0_dma;\n\tmac->dle_info.c1_rx_qta = cfg->ple_min_qt->cma1_dma;\n\n\treturn cfg;\n}\n\nstatic bool mac_is_txq_empty(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_mac_dle_dfi_qempty qempty;\n\tu32 qnum, qtmp, val32, msk32;\n\tint i, j, ret;\n\n\tqnum = rtwdev->chip->wde_qempty_acq_num;\n\tqempty.dle_type = DLE_CTRL_TYPE_WDE;\n\n\tfor (i = 0; i < qnum; i++) {\n\t\tqempty.grpsel = i;\n\t\tret = dle_dfi_qempty(rtwdev, &qempty);\n\t\tif (ret) {\n\t\t\trtw89_warn(rtwdev, \"dle dfi acq empty %d\\n\", ret);\n\t\t\treturn false;\n\t\t}\n\t\tqtmp = qempty.qempty;\n\t\tfor (j = 0 ; j < QEMP_ACQ_GRP_MACID_NUM; j++) {\n\t\t\tval32 = FIELD_GET(QEMP_ACQ_GRP_QSEL_MASK, qtmp);\n\t\t\tif (val32 != QEMP_ACQ_GRP_QSEL_MASK)\n\t\t\t\treturn false;\n\t\t\tqtmp >>= QEMP_ACQ_GRP_QSEL_SH;\n\t\t}\n\t}\n\n\tqempty.grpsel = rtwdev->chip->wde_qempty_mgq_sel;\n\tret = dle_dfi_qempty(rtwdev, &qempty);\n\tif (ret) {\n\t\trtw89_warn(rtwdev, \"dle dfi mgq empty %d\\n\", ret);\n\t\treturn false;\n\t}\n\tmsk32 = B_CMAC0_MGQ_NORMAL | B_CMAC0_MGQ_NO_PWRSAV | B_CMAC0_CPUMGQ;\n\tif ((qempty.qempty & msk32) != msk32)\n\t\treturn false;\n\n\tif (rtwdev->dbcc_en) {\n\t\tmsk32 |= B_CMAC1_MGQ_NORMAL | B_CMAC1_MGQ_NO_PWRSAV | B_CMAC1_CPUMGQ;\n\t\tif ((qempty.qempty & msk32) != msk32)\n\t\t\treturn false;\n\t}\n\n\tmsk32 = B_AX_WDE_EMPTY_QTA_DMAC_WLAN_CPU | B_AX_WDE_EMPTY_QTA_DMAC_DATA_CPU |\n\t\tB_AX_PLE_EMPTY_QTA_DMAC_WLAN_CPU | B_AX_PLE_EMPTY_QTA_DMAC_H2C |\n\t\tB_AX_WDE_EMPTY_QUE_OTHERS | B_AX_PLE_EMPTY_QUE_DMAC_MPDU_TX |\n\t\tB_AX_WDE_EMPTY_QTA_DMAC_CPUIO | B_AX_PLE_EMPTY_QTA_DMAC_CPUIO |\n\t\tB_AX_WDE_EMPTY_QUE_DMAC_PKTIN | B_AX_WDE_EMPTY_QTA_DMAC_HIF |\n\t\tB_AX_PLE_EMPTY_QUE_DMAC_SEC_TX | B_AX_WDE_EMPTY_QTA_DMAC_PKTIN |\n\t\tB_AX_PLE_EMPTY_QTA_DMAC_B0_TXPL | B_AX_PLE_EMPTY_QTA_DMAC_B1_TXPL |\n\t\tB_AX_PLE_EMPTY_QTA_DMAC_MPDU_TX;\n\tval32 = rtw89_read32(rtwdev, R_AX_DLE_EMPTY0);\n\n\treturn (val32 & msk32) == msk32;\n}\n\nstatic inline u32 dle_used_size(const struct rtw89_dle_size *wde,\n\t\t\t\tconst struct rtw89_dle_size *ple)\n{\n\treturn wde->pge_size * (wde->lnk_pge_num + wde->unlnk_pge_num) +\n\t       ple->pge_size * (ple->lnk_pge_num + ple->unlnk_pge_num);\n}\n\nstatic u32 dle_expected_used_size(struct rtw89_dev *rtwdev,\n\t\t\t\t  enum rtw89_qta_mode mode)\n{\n\tu32 size = rtwdev->chip->fifo_size;\n\n\tif (mode == RTW89_QTA_SCC)\n\t\tsize -= rtwdev->chip->dle_scc_rsvd_size;\n\n\treturn size;\n}\n\nstatic void dle_func_en(struct rtw89_dev *rtwdev, bool enable)\n{\n\tif (enable)\n\t\trtw89_write32_set(rtwdev, R_AX_DMAC_FUNC_EN,\n\t\t\t\t  B_AX_DLE_WDE_EN | B_AX_DLE_PLE_EN);\n\telse\n\t\trtw89_write32_clr(rtwdev, R_AX_DMAC_FUNC_EN,\n\t\t\t\t  B_AX_DLE_WDE_EN | B_AX_DLE_PLE_EN);\n}\n\nstatic void dle_clk_en(struct rtw89_dev *rtwdev, bool enable)\n{\n\tu32 val = B_AX_DLE_WDE_CLK_EN | B_AX_DLE_PLE_CLK_EN;\n\n\tif (enable) {\n\t\tif (rtwdev->chip->chip_id == RTL8851B)\n\t\t\tval |= B_AX_AXIDMA_CLK_EN;\n\t\trtw89_write32_set(rtwdev, R_AX_DMAC_CLK_EN, val);\n\t} else {\n\t\trtw89_write32_clr(rtwdev, R_AX_DMAC_CLK_EN, val);\n\t}\n}\n\nstatic int dle_mix_cfg(struct rtw89_dev *rtwdev, const struct rtw89_dle_mem *cfg)\n{\n\tconst struct rtw89_dle_size *size_cfg;\n\tu32 val;\n\tu8 bound = 0;\n\n\tval = rtw89_read32(rtwdev, R_AX_WDE_PKTBUF_CFG);\n\tsize_cfg = cfg->wde_size;\n\n\tswitch (size_cfg->pge_size) {\n\tdefault:\n\tcase RTW89_WDE_PG_64:\n\t\tval = u32_replace_bits(val, S_AX_WDE_PAGE_SEL_64,\n\t\t\t\t       B_AX_WDE_PAGE_SEL_MASK);\n\t\tbreak;\n\tcase RTW89_WDE_PG_128:\n\t\tval = u32_replace_bits(val, S_AX_WDE_PAGE_SEL_128,\n\t\t\t\t       B_AX_WDE_PAGE_SEL_MASK);\n\t\tbreak;\n\tcase RTW89_WDE_PG_256:\n\t\trtw89_err(rtwdev, \"[ERR]WDE DLE doesn't support 256 byte!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tval = u32_replace_bits(val, bound, B_AX_WDE_START_BOUND_MASK);\n\tval = u32_replace_bits(val, size_cfg->lnk_pge_num,\n\t\t\t       B_AX_WDE_FREE_PAGE_NUM_MASK);\n\trtw89_write32(rtwdev, R_AX_WDE_PKTBUF_CFG, val);\n\n\tval = rtw89_read32(rtwdev, R_AX_PLE_PKTBUF_CFG);\n\tbound = (size_cfg->lnk_pge_num + size_cfg->unlnk_pge_num)\n\t\t\t\t* size_cfg->pge_size / DLE_BOUND_UNIT;\n\tsize_cfg = cfg->ple_size;\n\n\tswitch (size_cfg->pge_size) {\n\tdefault:\n\tcase RTW89_PLE_PG_64:\n\t\trtw89_err(rtwdev, \"[ERR]PLE DLE doesn't support 64 byte!\\n\");\n\t\treturn -EINVAL;\n\tcase RTW89_PLE_PG_128:\n\t\tval = u32_replace_bits(val, S_AX_PLE_PAGE_SEL_128,\n\t\t\t\t       B_AX_PLE_PAGE_SEL_MASK);\n\t\tbreak;\n\tcase RTW89_PLE_PG_256:\n\t\tval = u32_replace_bits(val, S_AX_PLE_PAGE_SEL_256,\n\t\t\t\t       B_AX_PLE_PAGE_SEL_MASK);\n\t\tbreak;\n\t}\n\n\tval = u32_replace_bits(val, bound, B_AX_PLE_START_BOUND_MASK);\n\tval = u32_replace_bits(val, size_cfg->lnk_pge_num,\n\t\t\t       B_AX_PLE_FREE_PAGE_NUM_MASK);\n\trtw89_write32(rtwdev, R_AX_PLE_PKTBUF_CFG, val);\n\n\treturn 0;\n}\n\n#define INVALID_QT_WCPU U16_MAX\n#define SET_QUOTA_VAL(_min_x, _max_x, _module, _idx)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tval = u32_encode_bits(_min_x, B_AX_ ## _module ## _MIN_SIZE_MASK) | \\\n\t\t      u32_encode_bits(_max_x, B_AX_ ## _module ## _MAX_SIZE_MASK);  \\\n\t\trtw89_write32(rtwdev,\t\t\t\t\t\\\n\t\t\t      R_AX_ ## _module ## _QTA ## _idx ## _CFG,\t\\\n\t\t\t      val);\t\t\t\t\t\\\n\t} while (0)\n#define SET_QUOTA(_x, _module, _idx)\t\t\t\t\t\\\n\tSET_QUOTA_VAL(min_cfg->_x, max_cfg->_x, _module, _idx)\n\nstatic void wde_quota_cfg(struct rtw89_dev *rtwdev,\n\t\t\t  const struct rtw89_wde_quota *min_cfg,\n\t\t\t  const struct rtw89_wde_quota *max_cfg,\n\t\t\t  u16 ext_wde_min_qt_wcpu)\n{\n\tu16 min_qt_wcpu = ext_wde_min_qt_wcpu != INVALID_QT_WCPU ?\n\t\t\t  ext_wde_min_qt_wcpu : min_cfg->wcpu;\n\tu32 val;\n\n\tSET_QUOTA(hif, WDE, 0);\n\tSET_QUOTA_VAL(min_qt_wcpu, max_cfg->wcpu, WDE, 1);\n\tSET_QUOTA(pkt_in, WDE, 3);\n\tSET_QUOTA(cpu_io, WDE, 4);\n}\n\nstatic void ple_quota_cfg(struct rtw89_dev *rtwdev,\n\t\t\t  const struct rtw89_ple_quota *min_cfg,\n\t\t\t  const struct rtw89_ple_quota *max_cfg)\n{\n\tu32 val;\n\n\tSET_QUOTA(cma0_tx, PLE, 0);\n\tSET_QUOTA(cma1_tx, PLE, 1);\n\tSET_QUOTA(c2h, PLE, 2);\n\tSET_QUOTA(h2c, PLE, 3);\n\tSET_QUOTA(wcpu, PLE, 4);\n\tSET_QUOTA(mpdu_proc, PLE, 5);\n\tSET_QUOTA(cma0_dma, PLE, 6);\n\tSET_QUOTA(cma1_dma, PLE, 7);\n\tSET_QUOTA(bb_rpt, PLE, 8);\n\tSET_QUOTA(wd_rel, PLE, 9);\n\tSET_QUOTA(cpu_io, PLE, 10);\n\tif (rtwdev->chip->chip_id == RTL8852C)\n\t\tSET_QUOTA(tx_rpt, PLE, 11);\n}\n\nint rtw89_mac_resize_ple_rx_quota(struct rtw89_dev *rtwdev, bool wow)\n{\n\tconst struct rtw89_ple_quota *min_cfg, *max_cfg;\n\tconst struct rtw89_dle_mem *cfg;\n\tu32 val;\n\n\tif (rtwdev->chip->chip_id == RTL8852C)\n\t\treturn 0;\n\n\tif (rtwdev->mac.qta_mode != RTW89_QTA_SCC) {\n\t\trtw89_err(rtwdev, \"[ERR]support SCC mode only\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (wow)\n\t\tcfg = get_dle_mem_cfg(rtwdev, RTW89_QTA_WOW);\n\telse\n\t\tcfg = get_dle_mem_cfg(rtwdev, RTW89_QTA_SCC);\n\tif (!cfg) {\n\t\trtw89_err(rtwdev, \"[ERR]get_dle_mem_cfg\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmin_cfg = cfg->ple_min_qt;\n\tmax_cfg = cfg->ple_max_qt;\n\tSET_QUOTA(cma0_dma, PLE, 6);\n\tSET_QUOTA(cma1_dma, PLE, 7);\n\n\treturn 0;\n}\n#undef SET_QUOTA\n\nvoid rtw89_mac_hw_mgnt_sec(struct rtw89_dev *rtwdev, bool enable)\n{\n\tu32 msk32 = B_AX_UC_MGNT_DEC | B_AX_BMC_MGNT_DEC;\n\n\tif (enable)\n\t\trtw89_write32_set(rtwdev, R_AX_SEC_ENG_CTRL, msk32);\n\telse\n\t\trtw89_write32_clr(rtwdev, R_AX_SEC_ENG_CTRL, msk32);\n}\n\nstatic void dle_quota_cfg(struct rtw89_dev *rtwdev,\n\t\t\t  const struct rtw89_dle_mem *cfg,\n\t\t\t  u16 ext_wde_min_qt_wcpu)\n{\n\twde_quota_cfg(rtwdev, cfg->wde_min_qt, cfg->wde_max_qt, ext_wde_min_qt_wcpu);\n\tple_quota_cfg(rtwdev, cfg->ple_min_qt, cfg->ple_max_qt);\n}\n\nstatic int dle_init(struct rtw89_dev *rtwdev, enum rtw89_qta_mode mode,\n\t\t    enum rtw89_qta_mode ext_mode)\n{\n\tconst struct rtw89_dle_mem *cfg, *ext_cfg;\n\tu16 ext_wde_min_qt_wcpu = INVALID_QT_WCPU;\n\tint ret = 0;\n\tu32 ini;\n\n\tret = rtw89_mac_check_mac_en(rtwdev, RTW89_MAC_0, RTW89_DMAC_SEL);\n\tif (ret)\n\t\treturn ret;\n\n\tcfg = get_dle_mem_cfg(rtwdev, mode);\n\tif (!cfg) {\n\t\trtw89_err(rtwdev, \"[ERR]get_dle_mem_cfg\\n\");\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tif (mode == RTW89_QTA_DLFW) {\n\t\text_cfg = get_dle_mem_cfg(rtwdev, ext_mode);\n\t\tif (!ext_cfg) {\n\t\t\trtw89_err(rtwdev, \"[ERR]get_dle_ext_mem_cfg %d\\n\",\n\t\t\t\t  ext_mode);\n\t\t\tret = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\t\text_wde_min_qt_wcpu = ext_cfg->wde_min_qt->wcpu;\n\t}\n\n\tif (dle_used_size(cfg->wde_size, cfg->ple_size) !=\n\t    dle_expected_used_size(rtwdev, mode)) {\n\t\trtw89_err(rtwdev, \"[ERR]wd/dle mem cfg\\n\");\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tdle_func_en(rtwdev, false);\n\tdle_clk_en(rtwdev, true);\n\n\tret = dle_mix_cfg(rtwdev, cfg);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"[ERR] dle mix cfg\\n\");\n\t\tgoto error;\n\t}\n\tdle_quota_cfg(rtwdev, cfg, ext_wde_min_qt_wcpu);\n\n\tdle_func_en(rtwdev, true);\n\n\tret = read_poll_timeout(rtw89_read32, ini,\n\t\t\t\t(ini & WDE_MGN_INI_RDY) == WDE_MGN_INI_RDY, 1,\n\t\t\t\t2000, false, rtwdev, R_AX_WDE_INI_STATUS);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"[ERR]WDE cfg ready\\n\");\n\t\treturn ret;\n\t}\n\n\tret = read_poll_timeout(rtw89_read32, ini,\n\t\t\t\t(ini & WDE_MGN_INI_RDY) == WDE_MGN_INI_RDY, 1,\n\t\t\t\t2000, false, rtwdev, R_AX_PLE_INI_STATUS);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"[ERR]PLE cfg ready\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\nerror:\n\tdle_func_en(rtwdev, false);\n\trtw89_err(rtwdev, \"[ERR]trxcfg wde 0x8900 = %x\\n\",\n\t\t  rtw89_read32(rtwdev, R_AX_WDE_INI_STATUS));\n\trtw89_err(rtwdev, \"[ERR]trxcfg ple 0x8D00 = %x\\n\",\n\t\t  rtw89_read32(rtwdev, R_AX_PLE_INI_STATUS));\n\n\treturn ret;\n}\n\nstatic int preload_init_set(struct rtw89_dev *rtwdev, enum rtw89_mac_idx mac_idx,\n\t\t\t    enum rtw89_qta_mode mode)\n{\n\tu32 reg, max_preld_size, min_rsvd_size;\n\n\tmax_preld_size = (mac_idx == RTW89_MAC_0 ?\n\t\t\t  PRELD_B0_ENT_NUM : PRELD_B1_ENT_NUM) * PRELD_AMSDU_SIZE;\n\treg = mac_idx == RTW89_MAC_0 ?\n\t      R_AX_TXPKTCTL_B0_PRELD_CFG0 : R_AX_TXPKTCTL_B1_PRELD_CFG0;\n\trtw89_write32_mask(rtwdev, reg, B_AX_B0_PRELD_USEMAXSZ_MASK, max_preld_size);\n\trtw89_write32_set(rtwdev, reg, B_AX_B0_PRELD_FEN);\n\n\tmin_rsvd_size = PRELD_AMSDU_SIZE;\n\treg = mac_idx == RTW89_MAC_0 ?\n\t      R_AX_TXPKTCTL_B0_PRELD_CFG1 : R_AX_TXPKTCTL_B1_PRELD_CFG1;\n\trtw89_write32_mask(rtwdev, reg, B_AX_B0_PRELD_NXT_TXENDWIN_MASK, PRELD_NEXT_WND);\n\trtw89_write32_mask(rtwdev, reg, B_AX_B0_PRELD_NXT_RSVMINSZ_MASK, min_rsvd_size);\n\n\treturn 0;\n}\n\nstatic bool is_qta_poh(struct rtw89_dev *rtwdev)\n{\n\treturn rtwdev->hci.type == RTW89_HCI_TYPE_PCIE;\n}\n\nstatic int preload_init(struct rtw89_dev *rtwdev, enum rtw89_mac_idx mac_idx,\n\t\t\tenum rtw89_qta_mode mode)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\n\tif (chip->chip_id == RTL8852A || chip->chip_id == RTL8852B ||\n\t    chip->chip_id == RTL8851B || !is_qta_poh(rtwdev))\n\t\treturn 0;\n\n\treturn preload_init_set(rtwdev, mac_idx, mode);\n}\n\nstatic bool dle_is_txq_empty(struct rtw89_dev *rtwdev)\n{\n\tu32 msk32;\n\tu32 val32;\n\n\tmsk32 = B_AX_WDE_EMPTY_QUE_CMAC0_ALL_AC | B_AX_WDE_EMPTY_QUE_CMAC0_MBH |\n\t\tB_AX_WDE_EMPTY_QUE_CMAC1_MBH | B_AX_WDE_EMPTY_QUE_CMAC0_WMM0 |\n\t\tB_AX_WDE_EMPTY_QUE_CMAC0_WMM1 | B_AX_WDE_EMPTY_QUE_OTHERS |\n\t\tB_AX_PLE_EMPTY_QUE_DMAC_MPDU_TX | B_AX_PLE_EMPTY_QTA_DMAC_H2C |\n\t\tB_AX_PLE_EMPTY_QUE_DMAC_SEC_TX | B_AX_WDE_EMPTY_QUE_DMAC_PKTIN |\n\t\tB_AX_WDE_EMPTY_QTA_DMAC_HIF | B_AX_WDE_EMPTY_QTA_DMAC_WLAN_CPU |\n\t\tB_AX_WDE_EMPTY_QTA_DMAC_PKTIN | B_AX_WDE_EMPTY_QTA_DMAC_CPUIO |\n\t\tB_AX_PLE_EMPTY_QTA_DMAC_B0_TXPL |\n\t\tB_AX_PLE_EMPTY_QTA_DMAC_B1_TXPL |\n\t\tB_AX_PLE_EMPTY_QTA_DMAC_MPDU_TX |\n\t\tB_AX_PLE_EMPTY_QTA_DMAC_CPUIO |\n\t\tB_AX_WDE_EMPTY_QTA_DMAC_DATA_CPU |\n\t\tB_AX_PLE_EMPTY_QTA_DMAC_WLAN_CPU;\n\tval32 = rtw89_read32(rtwdev, R_AX_DLE_EMPTY0);\n\n\tif ((val32 & msk32) == msk32)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void _patch_ss2f_path(struct rtw89_dev *rtwdev)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\n\tif (chip->chip_id == RTL8852A || chip->chip_id == RTL8852B ||\n\t    chip->chip_id == RTL8851B)\n\t\treturn;\n\n\trtw89_write32_mask(rtwdev, R_AX_SS2FINFO_PATH, B_AX_SS_DEST_QUEUE_MASK,\n\t\t\t   SS2F_PATH_WLCPU);\n}\n\nstatic int sta_sch_init(struct rtw89_dev *rtwdev)\n{\n\tu32 p_val;\n\tu8 val;\n\tint ret;\n\n\tret = rtw89_mac_check_mac_en(rtwdev, RTW89_MAC_0, RTW89_DMAC_SEL);\n\tif (ret)\n\t\treturn ret;\n\n\tval = rtw89_read8(rtwdev, R_AX_SS_CTRL);\n\tval |= B_AX_SS_EN;\n\trtw89_write8(rtwdev, R_AX_SS_CTRL, val);\n\n\tret = read_poll_timeout(rtw89_read32, p_val, p_val & B_AX_SS_INIT_DONE_1,\n\t\t\t\t1, TRXCFG_WAIT_CNT, false, rtwdev, R_AX_SS_CTRL);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"[ERR]STA scheduler init\\n\");\n\t\treturn ret;\n\t}\n\n\trtw89_write32_set(rtwdev, R_AX_SS_CTRL, B_AX_SS_WARM_INIT_FLG);\n\trtw89_write32_clr(rtwdev, R_AX_SS_CTRL, B_AX_SS_NONEMPTY_SS2FINFO_EN);\n\n\t_patch_ss2f_path(rtwdev);\n\n\treturn 0;\n}\n\nstatic int mpdu_proc_init(struct rtw89_dev *rtwdev)\n{\n\tint ret;\n\n\tret = rtw89_mac_check_mac_en(rtwdev, RTW89_MAC_0, RTW89_DMAC_SEL);\n\tif (ret)\n\t\treturn ret;\n\n\trtw89_write32(rtwdev, R_AX_ACTION_FWD0, TRXCFG_MPDU_PROC_ACT_FRWD);\n\trtw89_write32(rtwdev, R_AX_TF_FWD, TRXCFG_MPDU_PROC_TF_FRWD);\n\trtw89_write32_set(rtwdev, R_AX_MPDU_PROC,\n\t\t\t  B_AX_APPEND_FCS | B_AX_A_ICV_ERR);\n\trtw89_write32(rtwdev, R_AX_CUT_AMSDU_CTRL, TRXCFG_MPDU_PROC_CUT_CTRL);\n\n\treturn 0;\n}\n\nstatic int sec_eng_init(struct rtw89_dev *rtwdev)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tu32 val = 0;\n\tint ret;\n\n\tret = rtw89_mac_check_mac_en(rtwdev, RTW89_MAC_0, RTW89_DMAC_SEL);\n\tif (ret)\n\t\treturn ret;\n\n\tval = rtw89_read32(rtwdev, R_AX_SEC_ENG_CTRL);\n\t \n\tval |= (B_AX_CLK_EN_CGCMP | B_AX_CLK_EN_WAPI | B_AX_CLK_EN_WEP_TKIP);\n\t \n\tval |= (B_AX_SEC_TX_ENC | B_AX_SEC_RX_DEC);\n\tval |= (B_AX_MC_DEC | B_AX_BC_DEC);\n\tif (chip->chip_id == RTL8852A || chip->chip_id == RTL8852B ||\n\t    chip->chip_id == RTL8851B)\n\t\tval &= ~B_AX_TX_PARTIAL_MODE;\n\trtw89_write32(rtwdev, R_AX_SEC_ENG_CTRL, val);\n\n\t \n\tval = rtw89_read32(rtwdev, R_AX_SEC_MPDU_PROC);\n\tval |= (B_AX_APPEND_ICV | B_AX_APPEND_MIC);\n\n\t \n\trtw89_write32(rtwdev, R_AX_SEC_MPDU_PROC, val);\n\n\tif (chip->chip_id == RTL8852C)\n\t\trtw89_write32_mask(rtwdev, R_AX_SEC_DEBUG1,\n\t\t\t\t   B_AX_TX_TIMEOUT_SEL_MASK, AX_TX_TO_VAL);\n\n\treturn 0;\n}\n\nstatic int dmac_init(struct rtw89_dev *rtwdev, u8 mac_idx)\n{\n\tint ret;\n\n\tret = dle_init(rtwdev, rtwdev->mac.qta_mode, RTW89_QTA_INVALID);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"[ERR]DLE init %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = preload_init(rtwdev, RTW89_MAC_0, rtwdev->mac.qta_mode);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"[ERR]preload init %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = hfc_init(rtwdev, true, true, true);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"[ERR]HCI FC init %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = sta_sch_init(rtwdev);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"[ERR]STA SCH init %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = mpdu_proc_init(rtwdev);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"[ERR]MPDU Proc init %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = sec_eng_init(rtwdev);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"[ERR]Security Engine init %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int addr_cam_init(struct rtw89_dev *rtwdev, u8 mac_idx)\n{\n\tu32 val, reg;\n\tu16 p_val;\n\tint ret;\n\n\tret = rtw89_mac_check_mac_en(rtwdev, mac_idx, RTW89_CMAC_SEL);\n\tif (ret)\n\t\treturn ret;\n\n\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_ADDR_CAM_CTRL, mac_idx);\n\n\tval = rtw89_read32(rtwdev, reg);\n\tval |= u32_encode_bits(0x7f, B_AX_ADDR_CAM_RANGE_MASK) |\n\t       B_AX_ADDR_CAM_CLR | B_AX_ADDR_CAM_EN;\n\trtw89_write32(rtwdev, reg, val);\n\n\tret = read_poll_timeout(rtw89_read16, p_val, !(p_val & B_AX_ADDR_CAM_CLR),\n\t\t\t\t1, TRXCFG_WAIT_CNT, false, rtwdev, reg);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"[ERR]ADDR_CAM reset\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int scheduler_init(struct rtw89_dev *rtwdev, u8 mac_idx)\n{\n\tu32 ret;\n\tu32 reg;\n\tu32 val;\n\n\tret = rtw89_mac_check_mac_en(rtwdev, mac_idx, RTW89_CMAC_SEL);\n\tif (ret)\n\t\treturn ret;\n\n\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_PREBKF_CFG_1, mac_idx);\n\tif (rtwdev->chip->chip_id == RTL8852C)\n\t\trtw89_write32_mask(rtwdev, reg, B_AX_SIFS_MACTXEN_T1_MASK,\n\t\t\t\t   SIFS_MACTXEN_T1_V1);\n\telse\n\t\trtw89_write32_mask(rtwdev, reg, B_AX_SIFS_MACTXEN_T1_MASK,\n\t\t\t\t   SIFS_MACTXEN_T1);\n\n\tif (rtwdev->chip->chip_id == RTL8852B || rtwdev->chip->chip_id == RTL8851B) {\n\t\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_SCH_EXT_CTRL, mac_idx);\n\t\trtw89_write32_set(rtwdev, reg, B_AX_PORT_RST_TSF_ADV);\n\t}\n\n\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_CCA_CFG_0, mac_idx);\n\trtw89_write32_clr(rtwdev, reg, B_AX_BTCCA_EN);\n\n\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_PREBKF_CFG_0, mac_idx);\n\tif (rtwdev->chip->chip_id == RTL8852C) {\n\t\tval = rtw89_read32_mask(rtwdev, R_AX_SEC_ENG_CTRL,\n\t\t\t\t\tB_AX_TX_PARTIAL_MODE);\n\t\tif (!val)\n\t\t\trtw89_write32_mask(rtwdev, reg, B_AX_PREBKF_TIME_MASK,\n\t\t\t\t\t   SCH_PREBKF_24US);\n\t} else {\n\t\trtw89_write32_mask(rtwdev, reg, B_AX_PREBKF_TIME_MASK,\n\t\t\t\t   SCH_PREBKF_24US);\n\t}\n\n\treturn 0;\n}\n\nint rtw89_mac_typ_fltr_opt(struct rtw89_dev *rtwdev,\n\t\t\t   enum rtw89_machdr_frame_type type,\n\t\t\t   enum rtw89_mac_fwd_target fwd_target,\n\t\t\t   u8 mac_idx)\n{\n\tu32 reg;\n\tu32 val;\n\n\tswitch (fwd_target) {\n\tcase RTW89_FWD_DONT_CARE:\n\t\tval = RX_FLTR_FRAME_DROP;\n\t\tbreak;\n\tcase RTW89_FWD_TO_HOST:\n\t\tval = RX_FLTR_FRAME_TO_HOST;\n\t\tbreak;\n\tcase RTW89_FWD_TO_WLAN_CPU:\n\t\tval = RX_FLTR_FRAME_TO_WLCPU;\n\t\tbreak;\n\tdefault:\n\t\trtw89_err(rtwdev, \"[ERR]set rx filter fwd target err\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (type) {\n\tcase RTW89_MGNT:\n\t\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_MGNT_FLTR, mac_idx);\n\t\tbreak;\n\tcase RTW89_CTRL:\n\t\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_CTRL_FLTR, mac_idx);\n\t\tbreak;\n\tcase RTW89_DATA:\n\t\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_DATA_FLTR, mac_idx);\n\t\tbreak;\n\tdefault:\n\t\trtw89_err(rtwdev, \"[ERR]set rx filter type err\\n\");\n\t\treturn -EINVAL;\n\t}\n\trtw89_write32(rtwdev, reg, val);\n\n\treturn 0;\n}\n\nstatic int rx_fltr_init(struct rtw89_dev *rtwdev, u8 mac_idx)\n{\n\tint ret, i;\n\tu32 mac_ftlr, plcp_ftlr;\n\n\tret = rtw89_mac_check_mac_en(rtwdev, mac_idx, RTW89_CMAC_SEL);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = RTW89_MGNT; i <= RTW89_DATA; i++) {\n\t\tret = rtw89_mac_typ_fltr_opt(rtwdev, i, RTW89_FWD_TO_HOST,\n\t\t\t\t\t     mac_idx);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tmac_ftlr = rtwdev->hal.rx_fltr;\n\tplcp_ftlr = B_AX_CCK_CRC_CHK | B_AX_CCK_SIG_CHK |\n\t\t    B_AX_LSIG_PARITY_CHK_EN | B_AX_SIGA_CRC_CHK |\n\t\t    B_AX_VHT_SU_SIGB_CRC_CHK | B_AX_VHT_MU_SIGB_CRC_CHK |\n\t\t    B_AX_HE_SIGB_CRC_CHK;\n\trtw89_write32(rtwdev, rtw89_mac_reg_by_idx(rtwdev, R_AX_RX_FLTR_OPT, mac_idx),\n\t\t      mac_ftlr);\n\trtw89_write16(rtwdev, rtw89_mac_reg_by_idx(rtwdev, R_AX_PLCP_HDR_FLTR, mac_idx),\n\t\t      plcp_ftlr);\n\n\treturn 0;\n}\n\nstatic void _patch_dis_resp_chk(struct rtw89_dev *rtwdev, u8 mac_idx)\n{\n\tu32 reg, val32;\n\tu32 b_rsp_chk_nav, b_rsp_chk_cca;\n\n\tb_rsp_chk_nav = B_AX_RSP_CHK_TXNAV | B_AX_RSP_CHK_INTRA_NAV |\n\t\t\tB_AX_RSP_CHK_BASIC_NAV;\n\tb_rsp_chk_cca = B_AX_RSP_CHK_SEC_CCA_80 | B_AX_RSP_CHK_SEC_CCA_40 |\n\t\t\tB_AX_RSP_CHK_SEC_CCA_20 | B_AX_RSP_CHK_BTCCA |\n\t\t\tB_AX_RSP_CHK_EDCCA | B_AX_RSP_CHK_CCA;\n\n\tswitch (rtwdev->chip->chip_id) {\n\tcase RTL8852A:\n\tcase RTL8852B:\n\t\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_RSP_CHK_SIG, mac_idx);\n\t\tval32 = rtw89_read32(rtwdev, reg) & ~b_rsp_chk_nav;\n\t\trtw89_write32(rtwdev, reg, val32);\n\n\t\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_TRXPTCL_RESP_0, mac_idx);\n\t\tval32 = rtw89_read32(rtwdev, reg) & ~b_rsp_chk_cca;\n\t\trtw89_write32(rtwdev, reg, val32);\n\t\tbreak;\n\tdefault:\n\t\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_RSP_CHK_SIG, mac_idx);\n\t\tval32 = rtw89_read32(rtwdev, reg) | b_rsp_chk_nav;\n\t\trtw89_write32(rtwdev, reg, val32);\n\n\t\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_TRXPTCL_RESP_0, mac_idx);\n\t\tval32 = rtw89_read32(rtwdev, reg) | b_rsp_chk_cca;\n\t\trtw89_write32(rtwdev, reg, val32);\n\t\tbreak;\n\t}\n}\n\nstatic int cca_ctrl_init(struct rtw89_dev *rtwdev, u8 mac_idx)\n{\n\tu32 val, reg;\n\tint ret;\n\n\tret = rtw89_mac_check_mac_en(rtwdev, mac_idx, RTW89_CMAC_SEL);\n\tif (ret)\n\t\treturn ret;\n\n\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_CCA_CONTROL, mac_idx);\n\tval = rtw89_read32(rtwdev, reg);\n\tval |= (B_AX_TB_CHK_BASIC_NAV | B_AX_TB_CHK_BTCCA |\n\t\tB_AX_TB_CHK_EDCCA | B_AX_TB_CHK_CCA_P20 |\n\t\tB_AX_SIFS_CHK_BTCCA | B_AX_SIFS_CHK_CCA_P20 |\n\t\tB_AX_CTN_CHK_INTRA_NAV |\n\t\tB_AX_CTN_CHK_BASIC_NAV | B_AX_CTN_CHK_BTCCA |\n\t\tB_AX_CTN_CHK_EDCCA | B_AX_CTN_CHK_CCA_S80 |\n\t\tB_AX_CTN_CHK_CCA_S40 | B_AX_CTN_CHK_CCA_S20 |\n\t\tB_AX_CTN_CHK_CCA_P20);\n\tval &= ~(B_AX_TB_CHK_TX_NAV | B_AX_TB_CHK_CCA_S80 |\n\t\t B_AX_TB_CHK_CCA_S40 | B_AX_TB_CHK_CCA_S20 |\n\t\t B_AX_SIFS_CHK_CCA_S80 | B_AX_SIFS_CHK_CCA_S40 |\n\t\t B_AX_SIFS_CHK_CCA_S20 | B_AX_CTN_CHK_TXNAV |\n\t\t B_AX_SIFS_CHK_EDCCA);\n\n\trtw89_write32(rtwdev, reg, val);\n\n\t_patch_dis_resp_chk(rtwdev, mac_idx);\n\n\treturn 0;\n}\n\nstatic int nav_ctrl_init(struct rtw89_dev *rtwdev)\n{\n\trtw89_write32_set(rtwdev, R_AX_WMAC_NAV_CTL, B_AX_WMAC_PLCP_UP_NAV_EN |\n\t\t\t\t\t\t     B_AX_WMAC_TF_UP_NAV_EN |\n\t\t\t\t\t\t     B_AX_WMAC_NAV_UPPER_EN);\n\trtw89_write32_mask(rtwdev, R_AX_WMAC_NAV_CTL, B_AX_WMAC_NAV_UPPER_MASK, NAV_25MS);\n\n\treturn 0;\n}\n\nstatic int spatial_reuse_init(struct rtw89_dev *rtwdev, u8 mac_idx)\n{\n\tu32 reg;\n\tint ret;\n\n\tret = rtw89_mac_check_mac_en(rtwdev, mac_idx, RTW89_CMAC_SEL);\n\tif (ret)\n\t\treturn ret;\n\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_RX_SR_CTRL, mac_idx);\n\trtw89_write8_clr(rtwdev, reg, B_AX_SR_EN);\n\n\treturn 0;\n}\n\nstatic int tmac_init(struct rtw89_dev *rtwdev, u8 mac_idx)\n{\n\tu32 reg;\n\tint ret;\n\n\tret = rtw89_mac_check_mac_en(rtwdev, mac_idx, RTW89_CMAC_SEL);\n\tif (ret)\n\t\treturn ret;\n\n\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_MAC_LOOPBACK, mac_idx);\n\trtw89_write32_clr(rtwdev, reg, B_AX_MACLBK_EN);\n\n\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_TCR0, mac_idx);\n\trtw89_write32_mask(rtwdev, reg, B_AX_TCR_UDF_THSD_MASK, TCR_UDF_THSD);\n\n\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_TXD_FIFO_CTRL, mac_idx);\n\trtw89_write32_mask(rtwdev, reg, B_AX_TXDFIFO_HIGH_MCS_THRE_MASK, TXDFIFO_HIGH_MCS_THRE);\n\trtw89_write32_mask(rtwdev, reg, B_AX_TXDFIFO_LOW_MCS_THRE_MASK, TXDFIFO_LOW_MCS_THRE);\n\n\treturn 0;\n}\n\nstatic int trxptcl_init(struct rtw89_dev *rtwdev, u8 mac_idx)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tconst struct rtw89_rrsr_cfgs *rrsr = chip->rrsr_cfgs;\n\tu32 reg, val, sifs;\n\tint ret;\n\n\tret = rtw89_mac_check_mac_en(rtwdev, mac_idx, RTW89_CMAC_SEL);\n\tif (ret)\n\t\treturn ret;\n\n\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_TRXPTCL_RESP_0, mac_idx);\n\tval = rtw89_read32(rtwdev, reg);\n\tval &= ~B_AX_WMAC_SPEC_SIFS_CCK_MASK;\n\tval |= FIELD_PREP(B_AX_WMAC_SPEC_SIFS_CCK_MASK, WMAC_SPEC_SIFS_CCK);\n\n\tswitch (rtwdev->chip->chip_id) {\n\tcase RTL8852A:\n\t\tsifs = WMAC_SPEC_SIFS_OFDM_52A;\n\t\tbreak;\n\tcase RTL8852B:\n\t\tsifs = WMAC_SPEC_SIFS_OFDM_52B;\n\t\tbreak;\n\tdefault:\n\t\tsifs = WMAC_SPEC_SIFS_OFDM_52C;\n\t\tbreak;\n\t}\n\tval &= ~B_AX_WMAC_SPEC_SIFS_OFDM_MASK;\n\tval |= FIELD_PREP(B_AX_WMAC_SPEC_SIFS_OFDM_MASK, sifs);\n\trtw89_write32(rtwdev, reg, val);\n\n\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_RXTRIG_TEST_USER_2, mac_idx);\n\trtw89_write32_set(rtwdev, reg, B_AX_RXTRIG_FCSCHK_EN);\n\n\treg = rtw89_mac_reg_by_idx(rtwdev, rrsr->ref_rate.addr, mac_idx);\n\trtw89_write32_mask(rtwdev, reg, rrsr->ref_rate.mask, rrsr->ref_rate.data);\n\treg = rtw89_mac_reg_by_idx(rtwdev, rrsr->rsc.addr, mac_idx);\n\trtw89_write32_mask(rtwdev, reg, rrsr->rsc.mask, rrsr->rsc.data);\n\n\treturn 0;\n}\n\nstatic void rst_bacam(struct rtw89_dev *rtwdev)\n{\n\tu32 val32;\n\tint ret;\n\n\trtw89_write32_mask(rtwdev, R_AX_RESPBA_CAM_CTRL, B_AX_BACAM_RST_MASK,\n\t\t\t   S_AX_BACAM_RST_ALL);\n\n\tret = read_poll_timeout_atomic(rtw89_read32_mask, val32, val32 == 0,\n\t\t\t\t       1, 1000, false,\n\t\t\t\t       rtwdev, R_AX_RESPBA_CAM_CTRL, B_AX_BACAM_RST_MASK);\n\tif (ret)\n\t\trtw89_warn(rtwdev, \"failed to reset BA CAM\\n\");\n}\n\nstatic int rmac_init(struct rtw89_dev *rtwdev, u8 mac_idx)\n{\n#define TRXCFG_RMAC_CCA_TO\t32\n#define TRXCFG_RMAC_DATA_TO\t15\n#define RX_MAX_LEN_UNIT 512\n#define PLD_RLS_MAX_PG 127\n#define RX_SPEC_MAX_LEN (11454 + RX_MAX_LEN_UNIT)\n\tint ret;\n\tu32 reg, rx_max_len, rx_qta;\n\tu16 val;\n\n\tret = rtw89_mac_check_mac_en(rtwdev, mac_idx, RTW89_CMAC_SEL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (mac_idx == RTW89_MAC_0)\n\t\trst_bacam(rtwdev);\n\n\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_RESPBA_CAM_CTRL, mac_idx);\n\trtw89_write8_set(rtwdev, reg, B_AX_SSN_SEL);\n\n\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_DLK_PROTECT_CTL, mac_idx);\n\tval = rtw89_read16(rtwdev, reg);\n\tval = u16_replace_bits(val, TRXCFG_RMAC_DATA_TO,\n\t\t\t       B_AX_RX_DLK_DATA_TIME_MASK);\n\tval = u16_replace_bits(val, TRXCFG_RMAC_CCA_TO,\n\t\t\t       B_AX_RX_DLK_CCA_TIME_MASK);\n\trtw89_write16(rtwdev, reg, val);\n\n\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_RCR, mac_idx);\n\trtw89_write8_mask(rtwdev, reg, B_AX_CH_EN_MASK, 0x1);\n\n\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_RX_FLTR_OPT, mac_idx);\n\tif (mac_idx == RTW89_MAC_0)\n\t\trx_qta = rtwdev->mac.dle_info.c0_rx_qta;\n\telse\n\t\trx_qta = rtwdev->mac.dle_info.c1_rx_qta;\n\trx_qta = min_t(u32, rx_qta, PLD_RLS_MAX_PG);\n\trx_max_len = rx_qta * rtwdev->mac.dle_info.ple_pg_size;\n\trx_max_len = min_t(u32, rx_max_len, RX_SPEC_MAX_LEN);\n\trx_max_len /= RX_MAX_LEN_UNIT;\n\trtw89_write32_mask(rtwdev, reg, B_AX_RX_MPDU_MAX_LEN_MASK, rx_max_len);\n\n\tif (rtwdev->chip->chip_id == RTL8852A &&\n\t    rtwdev->hal.cv == CHIP_CBV) {\n\t\trtw89_write16_mask(rtwdev,\n\t\t\t\t   rtw89_mac_reg_by_idx(rtwdev, R_AX_DLK_PROTECT_CTL, mac_idx),\n\t\t\t\t   B_AX_RX_DLK_CCA_TIME_MASK, 0);\n\t\trtw89_write16_set(rtwdev, rtw89_mac_reg_by_idx(rtwdev, R_AX_RCR, mac_idx),\n\t\t\t\t  BIT(12));\n\t}\n\n\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_PLCP_HDR_FLTR, mac_idx);\n\trtw89_write8_clr(rtwdev, reg, B_AX_VHT_SU_SIGB_CRC_CHK);\n\n\treturn ret;\n}\n\nstatic int cmac_com_init(struct rtw89_dev *rtwdev, u8 mac_idx)\n{\n\tenum rtw89_core_chip_id chip_id = rtwdev->chip->chip_id;\n\tu32 val, reg;\n\tint ret;\n\n\tret = rtw89_mac_check_mac_en(rtwdev, mac_idx, RTW89_CMAC_SEL);\n\tif (ret)\n\t\treturn ret;\n\n\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_TX_SUB_CARRIER_VALUE, mac_idx);\n\tval = rtw89_read32(rtwdev, reg);\n\tval = u32_replace_bits(val, 0, B_AX_TXSC_20M_MASK);\n\tval = u32_replace_bits(val, 0, B_AX_TXSC_40M_MASK);\n\tval = u32_replace_bits(val, 0, B_AX_TXSC_80M_MASK);\n\trtw89_write32(rtwdev, reg, val);\n\n\tif (chip_id == RTL8852A || chip_id == RTL8852B) {\n\t\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_PTCL_RRSR1, mac_idx);\n\t\trtw89_write32_mask(rtwdev, reg, B_AX_RRSR_RATE_EN_MASK, RRSR_OFDM_CCK_EN);\n\t}\n\n\treturn 0;\n}\n\nstatic bool is_qta_dbcc(struct rtw89_dev *rtwdev, enum rtw89_qta_mode mode)\n{\n\tconst struct rtw89_dle_mem *cfg;\n\n\tcfg = get_dle_mem_cfg(rtwdev, mode);\n\tif (!cfg) {\n\t\trtw89_err(rtwdev, \"[ERR]get_dle_mem_cfg\\n\");\n\t\treturn false;\n\t}\n\n\treturn (cfg->ple_min_qt->cma1_dma && cfg->ple_max_qt->cma1_dma);\n}\n\nstatic int ptcl_init(struct rtw89_dev *rtwdev, u8 mac_idx)\n{\n\tu32 val, reg;\n\tint ret;\n\n\tret = rtw89_mac_check_mac_en(rtwdev, mac_idx, RTW89_CMAC_SEL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (rtwdev->hci.type == RTW89_HCI_TYPE_PCIE) {\n\t\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_SIFS_SETTING, mac_idx);\n\t\tval = rtw89_read32(rtwdev, reg);\n\t\tval = u32_replace_bits(val, S_AX_CTS2S_TH_1K,\n\t\t\t\t       B_AX_HW_CTS2SELF_PKT_LEN_TH_MASK);\n\t\tval = u32_replace_bits(val, S_AX_CTS2S_TH_SEC_256B,\n\t\t\t\t       B_AX_HW_CTS2SELF_PKT_LEN_TH_TWW_MASK);\n\t\tval |= B_AX_HW_CTS2SELF_EN;\n\t\trtw89_write32(rtwdev, reg, val);\n\n\t\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_PTCL_FSM_MON, mac_idx);\n\t\tval = rtw89_read32(rtwdev, reg);\n\t\tval = u32_replace_bits(val, S_AX_PTCL_TO_2MS, B_AX_PTCL_TX_ARB_TO_THR_MASK);\n\t\tval &= ~B_AX_PTCL_TX_ARB_TO_MODE;\n\t\trtw89_write32(rtwdev, reg, val);\n\t}\n\n\tif (mac_idx == RTW89_MAC_0) {\n\t\trtw89_write8_set(rtwdev, R_AX_PTCL_COMMON_SETTING_0,\n\t\t\t\t B_AX_CMAC_TX_MODE_0 | B_AX_CMAC_TX_MODE_1);\n\t\trtw89_write8_clr(rtwdev, R_AX_PTCL_COMMON_SETTING_0,\n\t\t\t\t B_AX_PTCL_TRIGGER_SS_EN_0 |\n\t\t\t\t B_AX_PTCL_TRIGGER_SS_EN_1 |\n\t\t\t\t B_AX_PTCL_TRIGGER_SS_EN_UL);\n\t\trtw89_write8_mask(rtwdev, R_AX_PTCLRPT_FULL_HDL,\n\t\t\t\t  B_AX_SPE_RPT_PATH_MASK, FWD_TO_WLCPU);\n\t} else if (mac_idx == RTW89_MAC_1) {\n\t\trtw89_write8_mask(rtwdev, R_AX_PTCLRPT_FULL_HDL_C1,\n\t\t\t\t  B_AX_SPE_RPT_PATH_MASK, FWD_TO_WLCPU);\n\t}\n\n\treturn 0;\n}\n\nstatic int cmac_dma_init(struct rtw89_dev *rtwdev, u8 mac_idx)\n{\n\tenum rtw89_core_chip_id chip_id = rtwdev->chip->chip_id;\n\tu32 reg;\n\tint ret;\n\n\tif (chip_id != RTL8852B)\n\t\treturn 0;\n\n\tret = rtw89_mac_check_mac_en(rtwdev, mac_idx, RTW89_CMAC_SEL);\n\tif (ret)\n\t\treturn ret;\n\n\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_RXDMA_CTRL_0, mac_idx);\n\trtw89_write8_clr(rtwdev, reg, RX_FULL_MODE);\n\n\treturn 0;\n}\n\nstatic int cmac_init(struct rtw89_dev *rtwdev, u8 mac_idx)\n{\n\tint ret;\n\n\tret = scheduler_init(rtwdev, mac_idx);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"[ERR]CMAC%d SCH init %d\\n\", mac_idx, ret);\n\t\treturn ret;\n\t}\n\n\tret = addr_cam_init(rtwdev, mac_idx);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"[ERR]CMAC%d ADDR_CAM reset %d\\n\", mac_idx,\n\t\t\t  ret);\n\t\treturn ret;\n\t}\n\n\tret = rx_fltr_init(rtwdev, mac_idx);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"[ERR]CMAC%d RX filter init %d\\n\", mac_idx,\n\t\t\t  ret);\n\t\treturn ret;\n\t}\n\n\tret = cca_ctrl_init(rtwdev, mac_idx);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"[ERR]CMAC%d CCA CTRL init %d\\n\", mac_idx,\n\t\t\t  ret);\n\t\treturn ret;\n\t}\n\n\tret = nav_ctrl_init(rtwdev);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"[ERR]CMAC%d NAV CTRL init %d\\n\", mac_idx,\n\t\t\t  ret);\n\t\treturn ret;\n\t}\n\n\tret = spatial_reuse_init(rtwdev, mac_idx);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"[ERR]CMAC%d Spatial Reuse init %d\\n\",\n\t\t\t  mac_idx, ret);\n\t\treturn ret;\n\t}\n\n\tret = tmac_init(rtwdev, mac_idx);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"[ERR]CMAC%d TMAC init %d\\n\", mac_idx, ret);\n\t\treturn ret;\n\t}\n\n\tret = trxptcl_init(rtwdev, mac_idx);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"[ERR]CMAC%d TRXPTCL init %d\\n\", mac_idx, ret);\n\t\treturn ret;\n\t}\n\n\tret = rmac_init(rtwdev, mac_idx);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"[ERR]CMAC%d RMAC init %d\\n\", mac_idx, ret);\n\t\treturn ret;\n\t}\n\n\tret = cmac_com_init(rtwdev, mac_idx);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"[ERR]CMAC%d Com init %d\\n\", mac_idx, ret);\n\t\treturn ret;\n\t}\n\n\tret = ptcl_init(rtwdev, mac_idx);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"[ERR]CMAC%d PTCL init %d\\n\", mac_idx, ret);\n\t\treturn ret;\n\t}\n\n\tret = cmac_dma_init(rtwdev, mac_idx);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"[ERR]CMAC%d DMA init %d\\n\", mac_idx, ret);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int rtw89_mac_read_phycap(struct rtw89_dev *rtwdev,\n\t\t\t\t struct rtw89_mac_c2h_info *c2h_info)\n{\n\tstruct rtw89_mac_h2c_info h2c_info = {0};\n\tu32 ret;\n\n\th2c_info.id = RTW89_FWCMD_H2CREG_FUNC_GET_FEATURE;\n\th2c_info.content_len = 0;\n\n\tret = rtw89_fw_msg_reg(rtwdev, &h2c_info, c2h_info);\n\tif (ret)\n\t\treturn ret;\n\n\tif (c2h_info->id != RTW89_FWCMD_C2HREG_FUNC_PHY_CAP)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nint rtw89_mac_setup_phycap(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_efuse *efuse = &rtwdev->efuse;\n\tstruct rtw89_hal *hal = &rtwdev->hal;\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tstruct rtw89_mac_c2h_info c2h_info = {0};\n\tconst struct rtw89_c2hreg_phycap *phycap;\n\tu8 tx_nss;\n\tu8 rx_nss;\n\tu8 tx_ant;\n\tu8 rx_ant;\n\tu32 ret;\n\n\tret = rtw89_mac_read_phycap(rtwdev, &c2h_info);\n\tif (ret)\n\t\treturn ret;\n\n\tphycap = &c2h_info.u.phycap;\n\n\ttx_nss = u32_get_bits(phycap->w1, RTW89_C2HREG_PHYCAP_W1_TX_NSS);\n\trx_nss = u32_get_bits(phycap->w0, RTW89_C2HREG_PHYCAP_W0_RX_NSS);\n\ttx_ant = u32_get_bits(phycap->w3, RTW89_C2HREG_PHYCAP_W3_ANT_TX_NUM);\n\trx_ant = u32_get_bits(phycap->w3, RTW89_C2HREG_PHYCAP_W3_ANT_RX_NUM);\n\n\thal->tx_nss = tx_nss ? min_t(u8, tx_nss, chip->tx_nss) : chip->tx_nss;\n\thal->rx_nss = rx_nss ? min_t(u8, rx_nss, chip->rx_nss) : chip->rx_nss;\n\n\tif (tx_ant == 1)\n\t\thal->antenna_tx = RF_B;\n\tif (rx_ant == 1)\n\t\thal->antenna_rx = RF_B;\n\n\tif (tx_nss == 1 && tx_ant == 2 && rx_ant == 2) {\n\t\thal->antenna_tx = RF_B;\n\t\thal->tx_path_diversity = true;\n\t}\n\n\tif (chip->rf_path_num == 1) {\n\t\thal->antenna_tx = RF_A;\n\t\thal->antenna_rx = RF_A;\n\t\tif ((efuse->rfe_type % 3) == 2)\n\t\t\thal->ant_diversity = true;\n\t}\n\n\trtw89_debug(rtwdev, RTW89_DBG_FW,\n\t\t    \"phycap hal/phy/chip: tx_nss=0x%x/0x%x/0x%x rx_nss=0x%x/0x%x/0x%x\\n\",\n\t\t    hal->tx_nss, tx_nss, chip->tx_nss,\n\t\t    hal->rx_nss, rx_nss, chip->rx_nss);\n\trtw89_debug(rtwdev, RTW89_DBG_FW,\n\t\t    \"ant num/bitmap: tx=%d/0x%x rx=%d/0x%x\\n\",\n\t\t    tx_ant, hal->antenna_tx, rx_ant, hal->antenna_rx);\n\trtw89_debug(rtwdev, RTW89_DBG_FW, \"TX path diversity=%d\\n\", hal->tx_path_diversity);\n\trtw89_debug(rtwdev, RTW89_DBG_FW, \"Antenna diversity=%d\\n\", hal->ant_diversity);\n\n\treturn 0;\n}\n\nstatic int rtw89_hw_sch_tx_en_h2c(struct rtw89_dev *rtwdev, u8 band,\n\t\t\t\t  u16 tx_en_u16, u16 mask_u16)\n{\n\tu32 ret;\n\tstruct rtw89_mac_c2h_info c2h_info = {0};\n\tstruct rtw89_mac_h2c_info h2c_info = {0};\n\tstruct rtw89_h2creg_sch_tx_en *sch_tx_en = &h2c_info.u.sch_tx_en;\n\n\th2c_info.id = RTW89_FWCMD_H2CREG_FUNC_SCH_TX_EN;\n\th2c_info.content_len = sizeof(*sch_tx_en) - RTW89_H2CREG_HDR_LEN;\n\n\tu32p_replace_bits(&sch_tx_en->w0, tx_en_u16, RTW89_H2CREG_SCH_TX_EN_W0_EN);\n\tu32p_replace_bits(&sch_tx_en->w1, mask_u16, RTW89_H2CREG_SCH_TX_EN_W1_MASK);\n\tu32p_replace_bits(&sch_tx_en->w1, band, RTW89_H2CREG_SCH_TX_EN_W1_BAND);\n\n\tret = rtw89_fw_msg_reg(rtwdev, &h2c_info, &c2h_info);\n\tif (ret)\n\t\treturn ret;\n\n\tif (c2h_info.id != RTW89_FWCMD_C2HREG_FUNC_TX_PAUSE_RPT)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int rtw89_set_hw_sch_tx_en(struct rtw89_dev *rtwdev, u8 mac_idx,\n\t\t\t\t  u16 tx_en, u16 tx_en_mask)\n{\n\tu32 reg = rtw89_mac_reg_by_idx(rtwdev, R_AX_CTN_TXEN, mac_idx);\n\tu16 val;\n\tint ret;\n\n\tret = rtw89_mac_check_mac_en(rtwdev, mac_idx, RTW89_CMAC_SEL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (test_bit(RTW89_FLAG_FW_RDY, rtwdev->flags))\n\t\treturn rtw89_hw_sch_tx_en_h2c(rtwdev, mac_idx,\n\t\t\t\t\t      tx_en, tx_en_mask);\n\n\tval = rtw89_read16(rtwdev, reg);\n\tval = (val & ~tx_en_mask) | (tx_en & tx_en_mask);\n\trtw89_write16(rtwdev, reg, val);\n\n\treturn 0;\n}\n\nstatic int rtw89_set_hw_sch_tx_en_v1(struct rtw89_dev *rtwdev, u8 mac_idx,\n\t\t\t\t     u32 tx_en, u32 tx_en_mask)\n{\n\tu32 reg = rtw89_mac_reg_by_idx(rtwdev, R_AX_CTN_DRV_TXEN, mac_idx);\n\tu32 val;\n\tint ret;\n\n\tret = rtw89_mac_check_mac_en(rtwdev, mac_idx, RTW89_CMAC_SEL);\n\tif (ret)\n\t\treturn ret;\n\n\tval = rtw89_read32(rtwdev, reg);\n\tval = (val & ~tx_en_mask) | (tx_en & tx_en_mask);\n\trtw89_write32(rtwdev, reg, val);\n\n\treturn 0;\n}\n\nint rtw89_mac_stop_sch_tx(struct rtw89_dev *rtwdev, u8 mac_idx,\n\t\t\t  u32 *tx_en, enum rtw89_sch_tx_sel sel)\n{\n\tint ret;\n\n\t*tx_en = rtw89_read16(rtwdev,\n\t\t\t      rtw89_mac_reg_by_idx(rtwdev, R_AX_CTN_TXEN, mac_idx));\n\n\tswitch (sel) {\n\tcase RTW89_SCH_TX_SEL_ALL:\n\t\tret = rtw89_set_hw_sch_tx_en(rtwdev, mac_idx, 0,\n\t\t\t\t\t     B_AX_CTN_TXEN_ALL_MASK);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase RTW89_SCH_TX_SEL_HIQ:\n\t\tret = rtw89_set_hw_sch_tx_en(rtwdev, mac_idx,\n\t\t\t\t\t     0, B_AX_CTN_TXEN_HGQ);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase RTW89_SCH_TX_SEL_MG0:\n\t\tret = rtw89_set_hw_sch_tx_en(rtwdev, mac_idx,\n\t\t\t\t\t     0, B_AX_CTN_TXEN_MGQ);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase RTW89_SCH_TX_SEL_MACID:\n\t\tret = rtw89_set_hw_sch_tx_en(rtwdev, mac_idx, 0,\n\t\t\t\t\t     B_AX_CTN_TXEN_ALL_MASK);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rtw89_mac_stop_sch_tx);\n\nint rtw89_mac_stop_sch_tx_v1(struct rtw89_dev *rtwdev, u8 mac_idx,\n\t\t\t     u32 *tx_en, enum rtw89_sch_tx_sel sel)\n{\n\tint ret;\n\n\t*tx_en = rtw89_read32(rtwdev,\n\t\t\t      rtw89_mac_reg_by_idx(rtwdev, R_AX_CTN_DRV_TXEN, mac_idx));\n\n\tswitch (sel) {\n\tcase RTW89_SCH_TX_SEL_ALL:\n\t\tret = rtw89_set_hw_sch_tx_en_v1(rtwdev, mac_idx, 0,\n\t\t\t\t\t\tB_AX_CTN_TXEN_ALL_MASK_V1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase RTW89_SCH_TX_SEL_HIQ:\n\t\tret = rtw89_set_hw_sch_tx_en_v1(rtwdev, mac_idx,\n\t\t\t\t\t\t0, B_AX_CTN_TXEN_HGQ);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase RTW89_SCH_TX_SEL_MG0:\n\t\tret = rtw89_set_hw_sch_tx_en_v1(rtwdev, mac_idx,\n\t\t\t\t\t\t0, B_AX_CTN_TXEN_MGQ);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase RTW89_SCH_TX_SEL_MACID:\n\t\tret = rtw89_set_hw_sch_tx_en_v1(rtwdev, mac_idx, 0,\n\t\t\t\t\t\tB_AX_CTN_TXEN_ALL_MASK_V1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rtw89_mac_stop_sch_tx_v1);\n\nint rtw89_mac_resume_sch_tx(struct rtw89_dev *rtwdev, u8 mac_idx, u32 tx_en)\n{\n\tint ret;\n\n\tret = rtw89_set_hw_sch_tx_en(rtwdev, mac_idx, tx_en, B_AX_CTN_TXEN_ALL_MASK);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rtw89_mac_resume_sch_tx);\n\nint rtw89_mac_resume_sch_tx_v1(struct rtw89_dev *rtwdev, u8 mac_idx, u32 tx_en)\n{\n\tint ret;\n\n\tret = rtw89_set_hw_sch_tx_en_v1(rtwdev, mac_idx, tx_en,\n\t\t\t\t\tB_AX_CTN_TXEN_ALL_MASK_V1);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rtw89_mac_resume_sch_tx_v1);\n\nint rtw89_mac_dle_buf_req(struct rtw89_dev *rtwdev, u16 buf_len, bool wd, u16 *pkt_id)\n{\n\tu32 val, reg;\n\tint ret;\n\n\treg = wd ? R_AX_WD_BUF_REQ : R_AX_PL_BUF_REQ;\n\tval = buf_len;\n\tval |= B_AX_WD_BUF_REQ_EXEC;\n\trtw89_write32(rtwdev, reg, val);\n\n\treg = wd ? R_AX_WD_BUF_STATUS : R_AX_PL_BUF_STATUS;\n\n\tret = read_poll_timeout(rtw89_read32, val, val & B_AX_WD_BUF_STAT_DONE,\n\t\t\t\t1, 2000, false, rtwdev, reg);\n\tif (ret)\n\t\treturn ret;\n\n\t*pkt_id = FIELD_GET(B_AX_WD_BUF_STAT_PKTID_MASK, val);\n\tif (*pkt_id == S_WD_BUF_STAT_PKTID_INVALID)\n\t\treturn -ENOENT;\n\n\treturn 0;\n}\n\nint rtw89_mac_set_cpuio(struct rtw89_dev *rtwdev,\n\t\t\tstruct rtw89_cpuio_ctrl *ctrl_para, bool wd)\n{\n\tu32 val, cmd_type, reg;\n\tint ret;\n\n\tcmd_type = ctrl_para->cmd_type;\n\n\treg = wd ? R_AX_WD_CPUQ_OP_2 : R_AX_PL_CPUQ_OP_2;\n\tval = 0;\n\tval = u32_replace_bits(val, ctrl_para->start_pktid,\n\t\t\t       B_AX_WD_CPUQ_OP_STRT_PKTID_MASK);\n\tval = u32_replace_bits(val, ctrl_para->end_pktid,\n\t\t\t       B_AX_WD_CPUQ_OP_END_PKTID_MASK);\n\trtw89_write32(rtwdev, reg, val);\n\n\treg = wd ? R_AX_WD_CPUQ_OP_1 : R_AX_PL_CPUQ_OP_1;\n\tval = 0;\n\tval = u32_replace_bits(val, ctrl_para->src_pid,\n\t\t\t       B_AX_CPUQ_OP_SRC_PID_MASK);\n\tval = u32_replace_bits(val, ctrl_para->src_qid,\n\t\t\t       B_AX_CPUQ_OP_SRC_QID_MASK);\n\tval = u32_replace_bits(val, ctrl_para->dst_pid,\n\t\t\t       B_AX_CPUQ_OP_DST_PID_MASK);\n\tval = u32_replace_bits(val, ctrl_para->dst_qid,\n\t\t\t       B_AX_CPUQ_OP_DST_QID_MASK);\n\trtw89_write32(rtwdev, reg, val);\n\n\treg = wd ? R_AX_WD_CPUQ_OP_0 : R_AX_PL_CPUQ_OP_0;\n\tval = 0;\n\tval = u32_replace_bits(val, cmd_type,\n\t\t\t       B_AX_CPUQ_OP_CMD_TYPE_MASK);\n\tval = u32_replace_bits(val, ctrl_para->macid,\n\t\t\t       B_AX_CPUQ_OP_MACID_MASK);\n\tval = u32_replace_bits(val, ctrl_para->pkt_num,\n\t\t\t       B_AX_CPUQ_OP_PKTNUM_MASK);\n\tval |= B_AX_WD_CPUQ_OP_EXEC;\n\trtw89_write32(rtwdev, reg, val);\n\n\treg = wd ? R_AX_WD_CPUQ_OP_STATUS : R_AX_PL_CPUQ_OP_STATUS;\n\n\tret = read_poll_timeout(rtw89_read32, val, val & B_AX_WD_CPUQ_OP_STAT_DONE,\n\t\t\t\t1, 2000, false, rtwdev, reg);\n\tif (ret)\n\t\treturn ret;\n\n\tif (cmd_type == CPUIO_OP_CMD_GET_1ST_PID ||\n\t    cmd_type == CPUIO_OP_CMD_GET_NEXT_PID)\n\t\tctrl_para->pktid = FIELD_GET(B_AX_WD_CPUQ_OP_PKTID_MASK, val);\n\n\treturn 0;\n}\n\nstatic int dle_quota_change(struct rtw89_dev *rtwdev, enum rtw89_qta_mode mode)\n{\n\tconst struct rtw89_dle_mem *cfg;\n\tstruct rtw89_cpuio_ctrl ctrl_para = {0};\n\tu16 pkt_id;\n\tint ret;\n\n\tcfg = get_dle_mem_cfg(rtwdev, mode);\n\tif (!cfg) {\n\t\trtw89_err(rtwdev, \"[ERR]wd/dle mem cfg\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (dle_used_size(cfg->wde_size, cfg->ple_size) !=\n\t    dle_expected_used_size(rtwdev, mode)) {\n\t\trtw89_err(rtwdev, \"[ERR]wd/dle mem cfg\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdle_quota_cfg(rtwdev, cfg, INVALID_QT_WCPU);\n\n\tret = rtw89_mac_dle_buf_req(rtwdev, 0x20, true, &pkt_id);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"[ERR]WDE DLE buf req\\n\");\n\t\treturn ret;\n\t}\n\n\tctrl_para.cmd_type = CPUIO_OP_CMD_ENQ_TO_HEAD;\n\tctrl_para.start_pktid = pkt_id;\n\tctrl_para.end_pktid = pkt_id;\n\tctrl_para.pkt_num = 0;\n\tctrl_para.dst_pid = WDE_DLE_PORT_ID_WDRLS;\n\tctrl_para.dst_qid = WDE_DLE_QUEID_NO_REPORT;\n\tret = rtw89_mac_set_cpuio(rtwdev, &ctrl_para, true);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"[ERR]WDE DLE enqueue to head\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tret = rtw89_mac_dle_buf_req(rtwdev, 0x20, false, &pkt_id);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"[ERR]PLE DLE buf req\\n\");\n\t\treturn ret;\n\t}\n\n\tctrl_para.cmd_type = CPUIO_OP_CMD_ENQ_TO_HEAD;\n\tctrl_para.start_pktid = pkt_id;\n\tctrl_para.end_pktid = pkt_id;\n\tctrl_para.pkt_num = 0;\n\tctrl_para.dst_pid = PLE_DLE_PORT_ID_PLRLS;\n\tctrl_para.dst_qid = PLE_DLE_QUEID_NO_REPORT;\n\tret = rtw89_mac_set_cpuio(rtwdev, &ctrl_para, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"[ERR]PLE DLE enqueue to head\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}\n\nstatic int band_idle_ck_b(struct rtw89_dev *rtwdev, u8 mac_idx)\n{\n\tint ret;\n\tu32 reg;\n\tu8 val;\n\n\tret = rtw89_mac_check_mac_en(rtwdev, mac_idx, RTW89_CMAC_SEL);\n\tif (ret)\n\t\treturn ret;\n\n\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_PTCL_TX_CTN_SEL, mac_idx);\n\n\tret = read_poll_timeout(rtw89_read8, val,\n\t\t\t\t(val & B_AX_PTCL_TX_ON_STAT) == 0,\n\t\t\t\tSW_CVR_DUR_US,\n\t\t\t\tSW_CVR_DUR_US * PTCL_IDLE_POLL_CNT,\n\t\t\t\tfalse, rtwdev, reg);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int band1_enable(struct rtw89_dev *rtwdev)\n{\n\tint ret, i;\n\tu32 sleep_bak[4] = {0};\n\tu32 pause_bak[4] = {0};\n\tu32 tx_en;\n\n\tret = rtw89_chip_stop_sch_tx(rtwdev, 0, &tx_en, RTW89_SCH_TX_SEL_ALL);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"[ERR]stop sch tx %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < 4; i++) {\n\t\tsleep_bak[i] = rtw89_read32(rtwdev, R_AX_MACID_SLEEP_0 + i * 4);\n\t\tpause_bak[i] = rtw89_read32(rtwdev, R_AX_SS_MACID_PAUSE_0 + i * 4);\n\t\trtw89_write32(rtwdev, R_AX_MACID_SLEEP_0 + i * 4, U32_MAX);\n\t\trtw89_write32(rtwdev, R_AX_SS_MACID_PAUSE_0 + i * 4, U32_MAX);\n\t}\n\n\tret = band_idle_ck_b(rtwdev, 0);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"[ERR]tx idle poll %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = dle_quota_change(rtwdev, rtwdev->mac.qta_mode);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"[ERR]DLE quota change %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < 4; i++) {\n\t\trtw89_write32(rtwdev, R_AX_MACID_SLEEP_0 + i * 4, sleep_bak[i]);\n\t\trtw89_write32(rtwdev, R_AX_SS_MACID_PAUSE_0 + i * 4, pause_bak[i]);\n\t}\n\n\tret = rtw89_chip_resume_sch_tx(rtwdev, 0, tx_en);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"[ERR]CMAC1 resume sch tx %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = cmac_func_en(rtwdev, 1, true);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"[ERR]CMAC1 func en %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = cmac_init(rtwdev, 1);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"[ERR]CMAC1 init %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\trtw89_write32_set(rtwdev, R_AX_SYS_ISO_CTRL_EXTEND,\n\t\t\t  B_AX_R_SYM_FEN_WLBBFUN_1 | B_AX_R_SYM_FEN_WLBBGLB_1);\n\n\treturn 0;\n}\n\nstatic void rtw89_wdrls_imr_enable(struct rtw89_dev *rtwdev)\n{\n\tconst struct rtw89_imr_info *imr = rtwdev->chip->imr_info;\n\n\trtw89_write32_clr(rtwdev, R_AX_WDRLS_ERR_IMR, B_AX_WDRLS_IMR_EN_CLR);\n\trtw89_write32_set(rtwdev, R_AX_WDRLS_ERR_IMR, imr->wdrls_imr_set);\n}\n\nstatic void rtw89_wsec_imr_enable(struct rtw89_dev *rtwdev)\n{\n\tconst struct rtw89_imr_info *imr = rtwdev->chip->imr_info;\n\n\trtw89_write32_set(rtwdev, imr->wsec_imr_reg, imr->wsec_imr_set);\n}\n\nstatic void rtw89_mpdu_trx_imr_enable(struct rtw89_dev *rtwdev)\n{\n\tenum rtw89_core_chip_id chip_id = rtwdev->chip->chip_id;\n\tconst struct rtw89_imr_info *imr = rtwdev->chip->imr_info;\n\n\trtw89_write32_clr(rtwdev, R_AX_MPDU_TX_ERR_IMR,\n\t\t\t  B_AX_TX_GET_ERRPKTID_INT_EN |\n\t\t\t  B_AX_TX_NXT_ERRPKTID_INT_EN |\n\t\t\t  B_AX_TX_MPDU_SIZE_ZERO_INT_EN |\n\t\t\t  B_AX_TX_OFFSET_ERR_INT_EN |\n\t\t\t  B_AX_TX_HDR3_SIZE_ERR_INT_EN);\n\tif (chip_id == RTL8852C)\n\t\trtw89_write32_clr(rtwdev, R_AX_MPDU_TX_ERR_IMR,\n\t\t\t\t  B_AX_TX_ETH_TYPE_ERR_EN |\n\t\t\t\t  B_AX_TX_LLC_PRE_ERR_EN |\n\t\t\t\t  B_AX_TX_NW_TYPE_ERR_EN |\n\t\t\t\t  B_AX_TX_KSRCH_ERR_EN);\n\trtw89_write32_set(rtwdev, R_AX_MPDU_TX_ERR_IMR,\n\t\t\t  imr->mpdu_tx_imr_set);\n\n\trtw89_write32_clr(rtwdev, R_AX_MPDU_RX_ERR_IMR,\n\t\t\t  B_AX_GETPKTID_ERR_INT_EN |\n\t\t\t  B_AX_MHDRLEN_ERR_INT_EN |\n\t\t\t  B_AX_RPT_ERR_INT_EN);\n\trtw89_write32_set(rtwdev, R_AX_MPDU_RX_ERR_IMR,\n\t\t\t  imr->mpdu_rx_imr_set);\n}\n\nstatic void rtw89_sta_sch_imr_enable(struct rtw89_dev *rtwdev)\n{\n\tconst struct rtw89_imr_info *imr = rtwdev->chip->imr_info;\n\n\trtw89_write32_clr(rtwdev, R_AX_STA_SCHEDULER_ERR_IMR,\n\t\t\t  B_AX_SEARCH_HANG_TIMEOUT_INT_EN |\n\t\t\t  B_AX_RPT_HANG_TIMEOUT_INT_EN |\n\t\t\t  B_AX_PLE_B_PKTID_ERR_INT_EN);\n\trtw89_write32_set(rtwdev, R_AX_STA_SCHEDULER_ERR_IMR,\n\t\t\t  imr->sta_sch_imr_set);\n}\n\nstatic void rtw89_txpktctl_imr_enable(struct rtw89_dev *rtwdev)\n{\n\tconst struct rtw89_imr_info *imr = rtwdev->chip->imr_info;\n\n\trtw89_write32_clr(rtwdev, imr->txpktctl_imr_b0_reg,\n\t\t\t  imr->txpktctl_imr_b0_clr);\n\trtw89_write32_set(rtwdev, imr->txpktctl_imr_b0_reg,\n\t\t\t  imr->txpktctl_imr_b0_set);\n\trtw89_write32_clr(rtwdev, imr->txpktctl_imr_b1_reg,\n\t\t\t  imr->txpktctl_imr_b1_clr);\n\trtw89_write32_set(rtwdev, imr->txpktctl_imr_b1_reg,\n\t\t\t  imr->txpktctl_imr_b1_set);\n}\n\nstatic void rtw89_wde_imr_enable(struct rtw89_dev *rtwdev)\n{\n\tconst struct rtw89_imr_info *imr = rtwdev->chip->imr_info;\n\n\trtw89_write32_clr(rtwdev, R_AX_WDE_ERR_IMR, imr->wde_imr_clr);\n\trtw89_write32_set(rtwdev, R_AX_WDE_ERR_IMR, imr->wde_imr_set);\n}\n\nstatic void rtw89_ple_imr_enable(struct rtw89_dev *rtwdev)\n{\n\tconst struct rtw89_imr_info *imr = rtwdev->chip->imr_info;\n\n\trtw89_write32_clr(rtwdev, R_AX_PLE_ERR_IMR, imr->ple_imr_clr);\n\trtw89_write32_set(rtwdev, R_AX_PLE_ERR_IMR, imr->ple_imr_set);\n}\n\nstatic void rtw89_pktin_imr_enable(struct rtw89_dev *rtwdev)\n{\n\trtw89_write32_set(rtwdev, R_AX_PKTIN_ERR_IMR,\n\t\t\t  B_AX_PKTIN_GETPKTID_ERR_INT_EN);\n}\n\nstatic void rtw89_dispatcher_imr_enable(struct rtw89_dev *rtwdev)\n{\n\tconst struct rtw89_imr_info *imr = rtwdev->chip->imr_info;\n\n\trtw89_write32_clr(rtwdev, R_AX_HOST_DISPATCHER_ERR_IMR,\n\t\t\t  imr->host_disp_imr_clr);\n\trtw89_write32_set(rtwdev, R_AX_HOST_DISPATCHER_ERR_IMR,\n\t\t\t  imr->host_disp_imr_set);\n\trtw89_write32_clr(rtwdev, R_AX_CPU_DISPATCHER_ERR_IMR,\n\t\t\t  imr->cpu_disp_imr_clr);\n\trtw89_write32_set(rtwdev, R_AX_CPU_DISPATCHER_ERR_IMR,\n\t\t\t  imr->cpu_disp_imr_set);\n\trtw89_write32_clr(rtwdev, R_AX_OTHER_DISPATCHER_ERR_IMR,\n\t\t\t  imr->other_disp_imr_clr);\n\trtw89_write32_set(rtwdev, R_AX_OTHER_DISPATCHER_ERR_IMR,\n\t\t\t  imr->other_disp_imr_set);\n}\n\nstatic void rtw89_cpuio_imr_enable(struct rtw89_dev *rtwdev)\n{\n\trtw89_write32_clr(rtwdev, R_AX_CPUIO_ERR_IMR, B_AX_CPUIO_IMR_CLR);\n\trtw89_write32_set(rtwdev, R_AX_CPUIO_ERR_IMR, B_AX_CPUIO_IMR_SET);\n}\n\nstatic void rtw89_bbrpt_imr_enable(struct rtw89_dev *rtwdev)\n{\n\tconst struct rtw89_imr_info *imr = rtwdev->chip->imr_info;\n\n\trtw89_write32_set(rtwdev, imr->bbrpt_com_err_imr_reg,\n\t\t\t  B_AX_BBRPT_COM_NULL_PLPKTID_ERR_INT_EN);\n\trtw89_write32_clr(rtwdev, imr->bbrpt_chinfo_err_imr_reg,\n\t\t\t  B_AX_BBRPT_CHINFO_IMR_CLR);\n\trtw89_write32_set(rtwdev, imr->bbrpt_chinfo_err_imr_reg,\n\t\t\t  imr->bbrpt_err_imr_set);\n\trtw89_write32_set(rtwdev, imr->bbrpt_dfs_err_imr_reg,\n\t\t\t  B_AX_BBRPT_DFS_TO_ERR_INT_EN);\n\trtw89_write32_set(rtwdev, R_AX_LA_ERRFLAG, B_AX_LA_IMR_DATA_LOSS_ERR);\n}\n\nstatic void rtw89_scheduler_imr_enable(struct rtw89_dev *rtwdev, u8 mac_idx)\n{\n\tu32 reg;\n\n\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_SCHEDULE_ERR_IMR, mac_idx);\n\trtw89_write32_clr(rtwdev, reg, B_AX_SORT_NON_IDLE_ERR_INT_EN |\n\t\t\t\t       B_AX_FSM_TIMEOUT_ERR_INT_EN);\n\trtw89_write32_set(rtwdev, reg, B_AX_FSM_TIMEOUT_ERR_INT_EN);\n}\n\nstatic void rtw89_ptcl_imr_enable(struct rtw89_dev *rtwdev, u8 mac_idx)\n{\n\tconst struct rtw89_imr_info *imr = rtwdev->chip->imr_info;\n\tu32 reg;\n\n\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_PTCL_IMR0, mac_idx);\n\trtw89_write32_clr(rtwdev, reg, imr->ptcl_imr_clr);\n\trtw89_write32_set(rtwdev, reg, imr->ptcl_imr_set);\n}\n\nstatic void rtw89_cdma_imr_enable(struct rtw89_dev *rtwdev, u8 mac_idx)\n{\n\tconst struct rtw89_imr_info *imr = rtwdev->chip->imr_info;\n\tenum rtw89_core_chip_id chip_id = rtwdev->chip->chip_id;\n\tu32 reg;\n\n\treg = rtw89_mac_reg_by_idx(rtwdev, imr->cdma_imr_0_reg, mac_idx);\n\trtw89_write32_clr(rtwdev, reg, imr->cdma_imr_0_clr);\n\trtw89_write32_set(rtwdev, reg, imr->cdma_imr_0_set);\n\n\tif (chip_id == RTL8852C) {\n\t\treg = rtw89_mac_reg_by_idx(rtwdev, imr->cdma_imr_1_reg, mac_idx);\n\t\trtw89_write32_clr(rtwdev, reg, imr->cdma_imr_1_clr);\n\t\trtw89_write32_set(rtwdev, reg, imr->cdma_imr_1_set);\n\t}\n}\n\nstatic void rtw89_phy_intf_imr_enable(struct rtw89_dev *rtwdev, u8 mac_idx)\n{\n\tconst struct rtw89_imr_info *imr = rtwdev->chip->imr_info;\n\tu32 reg;\n\n\treg = rtw89_mac_reg_by_idx(rtwdev, imr->phy_intf_imr_reg, mac_idx);\n\trtw89_write32_clr(rtwdev, reg, imr->phy_intf_imr_clr);\n\trtw89_write32_set(rtwdev, reg, imr->phy_intf_imr_set);\n}\n\nstatic void rtw89_rmac_imr_enable(struct rtw89_dev *rtwdev, u8 mac_idx)\n{\n\tconst struct rtw89_imr_info *imr = rtwdev->chip->imr_info;\n\tu32 reg;\n\n\treg = rtw89_mac_reg_by_idx(rtwdev, imr->rmac_imr_reg, mac_idx);\n\trtw89_write32_clr(rtwdev, reg, imr->rmac_imr_clr);\n\trtw89_write32_set(rtwdev, reg, imr->rmac_imr_set);\n}\n\nstatic void rtw89_tmac_imr_enable(struct rtw89_dev *rtwdev, u8 mac_idx)\n{\n\tconst struct rtw89_imr_info *imr = rtwdev->chip->imr_info;\n\tu32 reg;\n\n\treg = rtw89_mac_reg_by_idx(rtwdev, imr->tmac_imr_reg, mac_idx);\n\trtw89_write32_clr(rtwdev, reg, imr->tmac_imr_clr);\n\trtw89_write32_set(rtwdev, reg, imr->tmac_imr_set);\n}\n\nstatic int rtw89_mac_enable_imr(struct rtw89_dev *rtwdev, u8 mac_idx,\n\t\t\t\tenum rtw89_mac_hwmod_sel sel)\n{\n\tint ret;\n\n\tret = rtw89_mac_check_mac_en(rtwdev, mac_idx, sel);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"MAC%d mac_idx%d is not ready\\n\",\n\t\t\t  sel, mac_idx);\n\t\treturn ret;\n\t}\n\n\tif (sel == RTW89_DMAC_SEL) {\n\t\trtw89_wdrls_imr_enable(rtwdev);\n\t\trtw89_wsec_imr_enable(rtwdev);\n\t\trtw89_mpdu_trx_imr_enable(rtwdev);\n\t\trtw89_sta_sch_imr_enable(rtwdev);\n\t\trtw89_txpktctl_imr_enable(rtwdev);\n\t\trtw89_wde_imr_enable(rtwdev);\n\t\trtw89_ple_imr_enable(rtwdev);\n\t\trtw89_pktin_imr_enable(rtwdev);\n\t\trtw89_dispatcher_imr_enable(rtwdev);\n\t\trtw89_cpuio_imr_enable(rtwdev);\n\t\trtw89_bbrpt_imr_enable(rtwdev);\n\t} else if (sel == RTW89_CMAC_SEL) {\n\t\trtw89_scheduler_imr_enable(rtwdev, mac_idx);\n\t\trtw89_ptcl_imr_enable(rtwdev, mac_idx);\n\t\trtw89_cdma_imr_enable(rtwdev, mac_idx);\n\t\trtw89_phy_intf_imr_enable(rtwdev, mac_idx);\n\t\trtw89_rmac_imr_enable(rtwdev, mac_idx);\n\t\trtw89_tmac_imr_enable(rtwdev, mac_idx);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void rtw89_mac_err_imr_ctrl(struct rtw89_dev *rtwdev, bool en)\n{\n\tenum rtw89_core_chip_id chip_id = rtwdev->chip->chip_id;\n\n\trtw89_write32(rtwdev, R_AX_DMAC_ERR_IMR,\n\t\t      en ? DMAC_ERR_IMR_EN : DMAC_ERR_IMR_DIS);\n\trtw89_write32(rtwdev, R_AX_CMAC_ERR_IMR,\n\t\t      en ? CMAC0_ERR_IMR_EN : CMAC0_ERR_IMR_DIS);\n\tif (chip_id != RTL8852B && rtwdev->mac.dle_info.c1_rx_qta)\n\t\trtw89_write32(rtwdev, R_AX_CMAC_ERR_IMR_C1,\n\t\t\t      en ? CMAC1_ERR_IMR_EN : CMAC1_ERR_IMR_DIS);\n}\n\nstatic int rtw89_mac_dbcc_enable(struct rtw89_dev *rtwdev, bool enable)\n{\n\tint ret = 0;\n\n\tif (enable) {\n\t\tret = band1_enable(rtwdev);\n\t\tif (ret) {\n\t\t\trtw89_err(rtwdev, \"[ERR] band1_enable %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = rtw89_mac_enable_imr(rtwdev, RTW89_MAC_1, RTW89_CMAC_SEL);\n\t\tif (ret) {\n\t\t\trtw89_err(rtwdev, \"[ERR] enable CMAC1 IMR %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\trtw89_err(rtwdev, \"[ERR] disable dbcc is not implemented not\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int set_host_rpr(struct rtw89_dev *rtwdev)\n{\n\tif (rtwdev->hci.type == RTW89_HCI_TYPE_PCIE) {\n\t\trtw89_write32_mask(rtwdev, R_AX_WDRLS_CFG,\n\t\t\t\t   B_AX_WDRLS_MODE_MASK, RTW89_RPR_MODE_POH);\n\t\trtw89_write32_set(rtwdev, R_AX_RLSRPT0_CFG0,\n\t\t\t\t  B_AX_RLSRPT0_FLTR_MAP_MASK);\n\t} else {\n\t\trtw89_write32_mask(rtwdev, R_AX_WDRLS_CFG,\n\t\t\t\t   B_AX_WDRLS_MODE_MASK, RTW89_RPR_MODE_STF);\n\t\trtw89_write32_clr(rtwdev, R_AX_RLSRPT0_CFG0,\n\t\t\t\t  B_AX_RLSRPT0_FLTR_MAP_MASK);\n\t}\n\n\trtw89_write32_mask(rtwdev, R_AX_RLSRPT0_CFG1, B_AX_RLSRPT0_AGGNUM_MASK, 30);\n\trtw89_write32_mask(rtwdev, R_AX_RLSRPT0_CFG1, B_AX_RLSRPT0_TO_MASK, 255);\n\n\treturn 0;\n}\n\nstatic int rtw89_mac_trx_init(struct rtw89_dev *rtwdev)\n{\n\tenum rtw89_qta_mode qta_mode = rtwdev->mac.qta_mode;\n\tint ret;\n\n\tret = dmac_init(rtwdev, 0);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"[ERR]DMAC init %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = cmac_init(rtwdev, 0);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"[ERR]CMAC%d init %d\\n\", 0, ret);\n\t\treturn ret;\n\t}\n\n\tif (is_qta_dbcc(rtwdev, qta_mode)) {\n\t\tret = rtw89_mac_dbcc_enable(rtwdev, true);\n\t\tif (ret) {\n\t\t\trtw89_err(rtwdev, \"[ERR]dbcc_enable init %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = rtw89_mac_enable_imr(rtwdev, RTW89_MAC_0, RTW89_DMAC_SEL);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"[ERR] enable DMAC IMR %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = rtw89_mac_enable_imr(rtwdev, RTW89_MAC_0, RTW89_CMAC_SEL);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"[ERR] to enable CMAC0 IMR %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\trtw89_mac_err_imr_ctrl(rtwdev, true);\n\n\tret = set_host_rpr(rtwdev);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"[ERR] set host rpr %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void rtw89_disable_fw_watchdog(struct rtw89_dev *rtwdev)\n{\n\tenum rtw89_core_chip_id chip_id = rtwdev->chip->chip_id;\n\tu32 val32;\n\n\tif (chip_id == RTL8852B || chip_id == RTL8851B) {\n\t\trtw89_write32_clr(rtwdev, R_AX_PLATFORM_ENABLE, B_AX_APB_WRAP_EN);\n\t\trtw89_write32_set(rtwdev, R_AX_PLATFORM_ENABLE, B_AX_APB_WRAP_EN);\n\t\treturn;\n\t}\n\n\trtw89_mac_mem_write(rtwdev, R_AX_WDT_CTRL,\n\t\t\t    WDT_CTRL_ALL_DIS, RTW89_MAC_MEM_CPU_LOCAL);\n\n\tval32 = rtw89_mac_mem_read(rtwdev, R_AX_WDT_STATUS, RTW89_MAC_MEM_CPU_LOCAL);\n\tval32 |= B_AX_FS_WDT_INT;\n\tval32 &= ~B_AX_FS_WDT_INT_MSK;\n\trtw89_mac_mem_write(rtwdev, R_AX_WDT_STATUS, val32, RTW89_MAC_MEM_CPU_LOCAL);\n}\n\nvoid rtw89_mac_disable_cpu(struct rtw89_dev *rtwdev)\n{\n\tclear_bit(RTW89_FLAG_FW_RDY, rtwdev->flags);\n\n\trtw89_write32_clr(rtwdev, R_AX_PLATFORM_ENABLE, B_AX_WCPU_EN);\n\trtw89_write32_clr(rtwdev, R_AX_WCPU_FW_CTRL, B_AX_WCPU_FWDL_EN |\n\t\t\t  B_AX_H2C_PATH_RDY | B_AX_FWDL_PATH_RDY);\n\trtw89_write32_clr(rtwdev, R_AX_SYS_CLK_CTRL, B_AX_CPU_CLK_EN);\n\n\trtw89_disable_fw_watchdog(rtwdev);\n\n\trtw89_write32_clr(rtwdev, R_AX_PLATFORM_ENABLE, B_AX_PLATFORM_EN);\n\trtw89_write32_set(rtwdev, R_AX_PLATFORM_ENABLE, B_AX_PLATFORM_EN);\n}\n\nint rtw89_mac_enable_cpu(struct rtw89_dev *rtwdev, u8 boot_reason, bool dlfw)\n{\n\tu32 val;\n\tint ret;\n\n\tif (rtw89_read32(rtwdev, R_AX_PLATFORM_ENABLE) & B_AX_WCPU_EN)\n\t\treturn -EFAULT;\n\n\trtw89_write32(rtwdev, R_AX_UDM1, 0);\n\trtw89_write32(rtwdev, R_AX_UDM2, 0);\n\trtw89_write32(rtwdev, R_AX_HALT_H2C_CTRL, 0);\n\trtw89_write32(rtwdev, R_AX_HALT_C2H_CTRL, 0);\n\trtw89_write32(rtwdev, R_AX_HALT_H2C, 0);\n\trtw89_write32(rtwdev, R_AX_HALT_C2H, 0);\n\n\trtw89_write32_set(rtwdev, R_AX_SYS_CLK_CTRL, B_AX_CPU_CLK_EN);\n\n\tval = rtw89_read32(rtwdev, R_AX_WCPU_FW_CTRL);\n\tval &= ~(B_AX_WCPU_FWDL_EN | B_AX_H2C_PATH_RDY | B_AX_FWDL_PATH_RDY);\n\tval = u32_replace_bits(val, RTW89_FWDL_INITIAL_STATE,\n\t\t\t       B_AX_WCPU_FWDL_STS_MASK);\n\n\tif (dlfw)\n\t\tval |= B_AX_WCPU_FWDL_EN;\n\n\trtw89_write32(rtwdev, R_AX_WCPU_FW_CTRL, val);\n\n\tif (rtwdev->chip->chip_id == RTL8852B)\n\t\trtw89_write32_mask(rtwdev, R_AX_SEC_CTRL,\n\t\t\t\t   B_AX_SEC_IDMEM_SIZE_CONFIG_MASK, 0x2);\n\n\trtw89_write16_mask(rtwdev, R_AX_BOOT_REASON, B_AX_BOOT_REASON_MASK,\n\t\t\t   boot_reason);\n\trtw89_write32_set(rtwdev, R_AX_PLATFORM_ENABLE, B_AX_WCPU_EN);\n\n\tif (!dlfw) {\n\t\tmdelay(5);\n\n\t\tret = rtw89_fw_check_rdy(rtwdev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int rtw89_mac_dmac_pre_init(struct rtw89_dev *rtwdev)\n{\n\tenum rtw89_core_chip_id chip_id = rtwdev->chip->chip_id;\n\tu32 val;\n\tint ret;\n\n\tif (chip_id == RTL8852C)\n\t\tval = B_AX_MAC_FUNC_EN | B_AX_DMAC_FUNC_EN | B_AX_DISPATCHER_EN |\n\t\t      B_AX_PKT_BUF_EN | B_AX_H_AXIDMA_EN;\n\telse\n\t\tval = B_AX_MAC_FUNC_EN | B_AX_DMAC_FUNC_EN | B_AX_DISPATCHER_EN |\n\t\t      B_AX_PKT_BUF_EN;\n\trtw89_write32(rtwdev, R_AX_DMAC_FUNC_EN, val);\n\n\tif (chip_id == RTL8851B)\n\t\tval = B_AX_DISPATCHER_CLK_EN | B_AX_AXIDMA_CLK_EN;\n\telse\n\t\tval = B_AX_DISPATCHER_CLK_EN;\n\trtw89_write32(rtwdev, R_AX_DMAC_CLK_EN, val);\n\n\tif (chip_id != RTL8852C)\n\t\tgoto dle;\n\n\tval = rtw89_read32(rtwdev, R_AX_HAXI_INIT_CFG1);\n\tval &= ~(B_AX_DMA_MODE_MASK | B_AX_STOP_AXI_MST);\n\tval |= FIELD_PREP(B_AX_DMA_MODE_MASK, DMA_MOD_PCIE_1B) |\n\t       B_AX_TXHCI_EN_V1 | B_AX_RXHCI_EN_V1;\n\trtw89_write32(rtwdev, R_AX_HAXI_INIT_CFG1, val);\n\n\trtw89_write32_clr(rtwdev, R_AX_HAXI_DMA_STOP1,\n\t\t\t  B_AX_STOP_ACH0 | B_AX_STOP_ACH1 | B_AX_STOP_ACH3 |\n\t\t\t  B_AX_STOP_ACH4 | B_AX_STOP_ACH5 | B_AX_STOP_ACH6 |\n\t\t\t  B_AX_STOP_ACH7 | B_AX_STOP_CH8 | B_AX_STOP_CH9 |\n\t\t\t  B_AX_STOP_CH12 | B_AX_STOP_ACH2);\n\trtw89_write32_clr(rtwdev, R_AX_HAXI_DMA_STOP2, B_AX_STOP_CH10 | B_AX_STOP_CH11);\n\trtw89_write32_set(rtwdev, R_AX_PLATFORM_ENABLE, B_AX_AXIDMA_EN);\n\ndle:\n\tret = dle_init(rtwdev, RTW89_QTA_DLFW, rtwdev->mac.qta_mode);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"[ERR]DLE pre init %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = hfc_init(rtwdev, true, false, true);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"[ERR]HCI FC pre init %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nint rtw89_mac_enable_bb_rf(struct rtw89_dev *rtwdev)\n{\n\trtw89_write8_set(rtwdev, R_AX_SYS_FUNC_EN,\n\t\t\t B_AX_FEN_BBRSTB | B_AX_FEN_BB_GLB_RSTN);\n\trtw89_write32_set(rtwdev, R_AX_WLRF_CTRL,\n\t\t\t  B_AX_WLRF1_CTRL_7 | B_AX_WLRF1_CTRL_1 |\n\t\t\t  B_AX_WLRF_CTRL_7 | B_AX_WLRF_CTRL_1);\n\trtw89_write8_set(rtwdev, R_AX_PHYREG_SET, PHYREG_SET_ALL_CYCLE);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rtw89_mac_enable_bb_rf);\n\nint rtw89_mac_disable_bb_rf(struct rtw89_dev *rtwdev)\n{\n\trtw89_write8_clr(rtwdev, R_AX_SYS_FUNC_EN,\n\t\t\t B_AX_FEN_BBRSTB | B_AX_FEN_BB_GLB_RSTN);\n\trtw89_write32_clr(rtwdev, R_AX_WLRF_CTRL,\n\t\t\t  B_AX_WLRF1_CTRL_7 | B_AX_WLRF1_CTRL_1 |\n\t\t\t  B_AX_WLRF_CTRL_7 | B_AX_WLRF_CTRL_1);\n\trtw89_write8_clr(rtwdev, R_AX_PHYREG_SET, PHYREG_SET_ALL_CYCLE);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rtw89_mac_disable_bb_rf);\n\nint rtw89_mac_partial_init(struct rtw89_dev *rtwdev)\n{\n\tint ret;\n\n\tret = rtw89_mac_power_switch(rtwdev, true);\n\tif (ret) {\n\t\trtw89_mac_power_switch(rtwdev, false);\n\t\tret = rtw89_mac_power_switch(rtwdev, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\trtw89_mac_ctrl_hci_dma_trx(rtwdev, true);\n\n\tret = rtw89_mac_dmac_pre_init(rtwdev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (rtwdev->hci.ops->mac_pre_init) {\n\t\tret = rtwdev->hci.ops->mac_pre_init(rtwdev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = rtw89_fw_download(rtwdev, RTW89_FW_NORMAL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nint rtw89_mac_init(struct rtw89_dev *rtwdev)\n{\n\tint ret;\n\n\tret = rtw89_mac_partial_init(rtwdev);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = rtw89_chip_enable_bb_rf(rtwdev);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = rtw89_mac_sys_init(rtwdev);\n\tif (ret)\n\t\tgoto fail;\n\n\tret = rtw89_mac_trx_init(rtwdev);\n\tif (ret)\n\t\tgoto fail;\n\n\tif (rtwdev->hci.ops->mac_post_init) {\n\t\tret = rtwdev->hci.ops->mac_post_init(rtwdev);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t}\n\n\trtw89_fw_send_all_early_h2c(rtwdev);\n\trtw89_fw_h2c_set_ofld_cfg(rtwdev);\n\n\treturn ret;\nfail:\n\trtw89_mac_power_switch(rtwdev, false);\n\n\treturn ret;\n}\n\nstatic void rtw89_mac_dmac_tbl_init(struct rtw89_dev *rtwdev, u8 macid)\n{\n\tu8 i;\n\n\tif (rtwdev->chip->chip_gen != RTW89_CHIP_AX)\n\t\treturn;\n\n\tfor (i = 0; i < 4; i++) {\n\t\trtw89_write32(rtwdev, R_AX_FILTER_MODEL_ADDR,\n\t\t\t      DMAC_TBL_BASE_ADDR + (macid << 4) + (i << 2));\n\t\trtw89_write32(rtwdev, R_AX_INDIR_ACCESS_ENTRY, 0);\n\t}\n}\n\nstatic void rtw89_mac_cmac_tbl_init(struct rtw89_dev *rtwdev, u8 macid)\n{\n\tif (rtwdev->chip->chip_gen != RTW89_CHIP_AX)\n\t\treturn;\n\n\trtw89_write32(rtwdev, R_AX_FILTER_MODEL_ADDR,\n\t\t      CMAC_TBL_BASE_ADDR + macid * CCTL_INFO_SIZE);\n\trtw89_write32(rtwdev, R_AX_INDIR_ACCESS_ENTRY, 0x4);\n\trtw89_write32(rtwdev, R_AX_INDIR_ACCESS_ENTRY + 4, 0x400A0004);\n\trtw89_write32(rtwdev, R_AX_INDIR_ACCESS_ENTRY + 8, 0);\n\trtw89_write32(rtwdev, R_AX_INDIR_ACCESS_ENTRY + 12, 0);\n\trtw89_write32(rtwdev, R_AX_INDIR_ACCESS_ENTRY + 16, 0);\n\trtw89_write32(rtwdev, R_AX_INDIR_ACCESS_ENTRY + 20, 0xE43000B);\n\trtw89_write32(rtwdev, R_AX_INDIR_ACCESS_ENTRY + 24, 0);\n\trtw89_write32(rtwdev, R_AX_INDIR_ACCESS_ENTRY + 28, 0xB8109);\n}\n\nint rtw89_mac_set_macid_pause(struct rtw89_dev *rtwdev, u8 macid, bool pause)\n{\n\tu8 sh =  FIELD_GET(GENMASK(4, 0), macid);\n\tu8 grp = macid >> 5;\n\tint ret;\n\n\t \n\tif (test_bit(RTW89_FLAG_CHANGING_INTERFACE, rtwdev->flags) &&\n\t    !test_bit(RTW89_FLAG_POWERON, rtwdev->flags))\n\t\treturn 0;\n\n\tret = rtw89_mac_check_mac_en(rtwdev, RTW89_MAC_0, RTW89_CMAC_SEL);\n\tif (ret)\n\t\treturn ret;\n\n\trtw89_fw_h2c_macid_pause(rtwdev, sh, grp, pause);\n\n\treturn 0;\n}\n\nstatic const struct rtw89_port_reg rtw_port_base = {\n\t.port_cfg = R_AX_PORT_CFG_P0,\n\t.tbtt_prohib = R_AX_TBTT_PROHIB_P0,\n\t.bcn_area = R_AX_BCN_AREA_P0,\n\t.bcn_early = R_AX_BCNERLYINT_CFG_P0,\n\t.tbtt_early = R_AX_TBTTERLYINT_CFG_P0,\n\t.tbtt_agg = R_AX_TBTT_AGG_P0,\n\t.bcn_space = R_AX_BCN_SPACE_CFG_P0,\n\t.bcn_forcetx = R_AX_BCN_FORCETX_P0,\n\t.bcn_err_cnt = R_AX_BCN_ERR_CNT_P0,\n\t.bcn_err_flag = R_AX_BCN_ERR_FLAG_P0,\n\t.dtim_ctrl = R_AX_DTIM_CTRL_P0,\n\t.tbtt_shift = R_AX_TBTT_SHIFT_P0,\n\t.bcn_cnt_tmr = R_AX_BCN_CNT_TMR_P0,\n\t.tsftr_l = R_AX_TSFTR_LOW_P0,\n\t.tsftr_h = R_AX_TSFTR_HIGH_P0\n};\n\n#define BCN_INTERVAL 100\n#define BCN_ERLY_DEF 160\n#define BCN_SETUP_DEF 2\n#define BCN_HOLD_DEF 200\n#define BCN_MASK_DEF 0\n#define TBTT_ERLY_DEF 5\n#define BCN_SET_UNIT 32\n#define BCN_ERLY_SET_DLY (10 * 2)\n\nstatic void rtw89_mac_port_cfg_func_sw(struct rtw89_dev *rtwdev,\n\t\t\t\t       struct rtw89_vif *rtwvif)\n{\n\tstruct ieee80211_vif *vif = rtwvif_to_vif(rtwvif);\n\tconst struct rtw89_port_reg *p = &rtw_port_base;\n\n\tif (!rtw89_read32_port_mask(rtwdev, rtwvif, p->port_cfg, B_AX_PORT_FUNC_EN))\n\t\treturn;\n\n\trtw89_write32_port_clr(rtwdev, rtwvif, p->tbtt_prohib, B_AX_TBTT_SETUP_MASK);\n\trtw89_write32_port_mask(rtwdev, rtwvif, p->tbtt_prohib, B_AX_TBTT_HOLD_MASK, 1);\n\trtw89_write16_port_clr(rtwdev, rtwvif, p->tbtt_early, B_AX_TBTTERLY_MASK);\n\trtw89_write16_port_clr(rtwdev, rtwvif, p->bcn_early, B_AX_BCNERLY_MASK);\n\n\tmsleep(vif->bss_conf.beacon_int + 1);\n\n\trtw89_write32_port_clr(rtwdev, rtwvif, p->port_cfg, B_AX_PORT_FUNC_EN |\n\t\t\t\t\t\t\t    B_AX_BRK_SETUP);\n\trtw89_write32_port_set(rtwdev, rtwvif, p->port_cfg, B_AX_TSFTR_RST);\n\trtw89_write32_port(rtwdev, rtwvif, p->bcn_cnt_tmr, 0);\n}\n\nstatic void rtw89_mac_port_cfg_tx_rpt(struct rtw89_dev *rtwdev,\n\t\t\t\t      struct rtw89_vif *rtwvif, bool en)\n{\n\tconst struct rtw89_port_reg *p = &rtw_port_base;\n\n\tif (en)\n\t\trtw89_write32_port_set(rtwdev, rtwvif, p->port_cfg, B_AX_TXBCN_RPT_EN);\n\telse\n\t\trtw89_write32_port_clr(rtwdev, rtwvif, p->port_cfg, B_AX_TXBCN_RPT_EN);\n}\n\nstatic void rtw89_mac_port_cfg_rx_rpt(struct rtw89_dev *rtwdev,\n\t\t\t\t      struct rtw89_vif *rtwvif, bool en)\n{\n\tconst struct rtw89_port_reg *p = &rtw_port_base;\n\n\tif (en)\n\t\trtw89_write32_port_set(rtwdev, rtwvif, p->port_cfg, B_AX_RXBCN_RPT_EN);\n\telse\n\t\trtw89_write32_port_clr(rtwdev, rtwvif, p->port_cfg, B_AX_RXBCN_RPT_EN);\n}\n\nstatic void rtw89_mac_port_cfg_net_type(struct rtw89_dev *rtwdev,\n\t\t\t\t\tstruct rtw89_vif *rtwvif)\n{\n\tconst struct rtw89_port_reg *p = &rtw_port_base;\n\n\trtw89_write32_port_mask(rtwdev, rtwvif, p->port_cfg, B_AX_NET_TYPE_MASK,\n\t\t\t\trtwvif->net_type);\n}\n\nstatic void rtw89_mac_port_cfg_bcn_prct(struct rtw89_dev *rtwdev,\n\t\t\t\t\tstruct rtw89_vif *rtwvif)\n{\n\tconst struct rtw89_port_reg *p = &rtw_port_base;\n\tbool en = rtwvif->net_type != RTW89_NET_TYPE_NO_LINK;\n\tu32 bits = B_AX_TBTT_PROHIB_EN | B_AX_BRK_SETUP;\n\n\tif (en)\n\t\trtw89_write32_port_set(rtwdev, rtwvif, p->port_cfg, bits);\n\telse\n\t\trtw89_write32_port_clr(rtwdev, rtwvif, p->port_cfg, bits);\n}\n\nstatic void rtw89_mac_port_cfg_rx_sw(struct rtw89_dev *rtwdev,\n\t\t\t\t     struct rtw89_vif *rtwvif)\n{\n\tconst struct rtw89_port_reg *p = &rtw_port_base;\n\tbool en = rtwvif->net_type == RTW89_NET_TYPE_INFRA ||\n\t\t  rtwvif->net_type == RTW89_NET_TYPE_AD_HOC;\n\tu32 bit = B_AX_RX_BSSID_FIT_EN;\n\n\tif (en)\n\t\trtw89_write32_port_set(rtwdev, rtwvif, p->port_cfg, bit);\n\telse\n\t\trtw89_write32_port_clr(rtwdev, rtwvif, p->port_cfg, bit);\n}\n\nstatic void rtw89_mac_port_cfg_rx_sync(struct rtw89_dev *rtwdev,\n\t\t\t\t       struct rtw89_vif *rtwvif)\n{\n\tconst struct rtw89_port_reg *p = &rtw_port_base;\n\tbool en = rtwvif->net_type == RTW89_NET_TYPE_INFRA ||\n\t\t  rtwvif->net_type == RTW89_NET_TYPE_AD_HOC;\n\n\tif (en)\n\t\trtw89_write32_port_set(rtwdev, rtwvif, p->port_cfg, B_AX_TSF_UDT_EN);\n\telse\n\t\trtw89_write32_port_clr(rtwdev, rtwvif, p->port_cfg, B_AX_TSF_UDT_EN);\n}\n\nstatic void rtw89_mac_port_cfg_tx_sw(struct rtw89_dev *rtwdev,\n\t\t\t\t     struct rtw89_vif *rtwvif)\n{\n\tconst struct rtw89_port_reg *p = &rtw_port_base;\n\tbool en = rtwvif->net_type == RTW89_NET_TYPE_AP_MODE ||\n\t\t  rtwvif->net_type == RTW89_NET_TYPE_AD_HOC;\n\n\tif (en)\n\t\trtw89_write32_port_set(rtwdev, rtwvif, p->port_cfg, B_AX_BCNTX_EN);\n\telse\n\t\trtw89_write32_port_clr(rtwdev, rtwvif, p->port_cfg, B_AX_BCNTX_EN);\n}\n\nstatic void rtw89_mac_port_cfg_bcn_intv(struct rtw89_dev *rtwdev,\n\t\t\t\t\tstruct rtw89_vif *rtwvif)\n{\n\tstruct ieee80211_vif *vif = rtwvif_to_vif(rtwvif);\n\tconst struct rtw89_port_reg *p = &rtw_port_base;\n\tu16 bcn_int = vif->bss_conf.beacon_int ? vif->bss_conf.beacon_int : BCN_INTERVAL;\n\n\trtw89_write32_port_mask(rtwdev, rtwvif, p->bcn_space, B_AX_BCN_SPACE_MASK,\n\t\t\t\tbcn_int);\n}\n\nstatic void rtw89_mac_port_cfg_hiq_win(struct rtw89_dev *rtwdev,\n\t\t\t\t       struct rtw89_vif *rtwvif)\n{\n\tstatic const u32 hiq_win_addr[RTW89_PORT_NUM] = {\n\t\tR_AX_P0MB_HGQ_WINDOW_CFG_0, R_AX_PORT_HGQ_WINDOW_CFG,\n\t\tR_AX_PORT_HGQ_WINDOW_CFG + 1, R_AX_PORT_HGQ_WINDOW_CFG + 2,\n\t\tR_AX_PORT_HGQ_WINDOW_CFG + 3,\n\t};\n\tu8 win = rtwvif->net_type == RTW89_NET_TYPE_AP_MODE ? 16 : 0;\n\tu8 port = rtwvif->port;\n\tu32 reg;\n\n\treg = rtw89_mac_reg_by_idx(rtwdev, hiq_win_addr[port], rtwvif->mac_idx);\n\trtw89_write8(rtwdev, reg, win);\n}\n\nstatic void rtw89_mac_port_cfg_hiq_dtim(struct rtw89_dev *rtwdev,\n\t\t\t\t\tstruct rtw89_vif *rtwvif)\n{\n\tstruct ieee80211_vif *vif = rtwvif_to_vif(rtwvif);\n\tconst struct rtw89_port_reg *p = &rtw_port_base;\n\tu32 addr;\n\n\taddr = rtw89_mac_reg_by_idx(rtwdev, R_AX_MD_TSFT_STMP_CTL, rtwvif->mac_idx);\n\trtw89_write8_set(rtwdev, addr, B_AX_UPD_HGQMD | B_AX_UPD_TIMIE);\n\n\trtw89_write16_port_mask(rtwdev, rtwvif, p->dtim_ctrl, B_AX_DTIM_NUM_MASK,\n\t\t\t\tvif->bss_conf.dtim_period);\n}\n\nstatic void rtw89_mac_port_cfg_bcn_setup_time(struct rtw89_dev *rtwdev,\n\t\t\t\t\t      struct rtw89_vif *rtwvif)\n{\n\tconst struct rtw89_port_reg *p = &rtw_port_base;\n\n\trtw89_write32_port_mask(rtwdev, rtwvif, p->tbtt_prohib,\n\t\t\t\tB_AX_TBTT_SETUP_MASK, BCN_SETUP_DEF);\n}\n\nstatic void rtw89_mac_port_cfg_bcn_hold_time(struct rtw89_dev *rtwdev,\n\t\t\t\t\t     struct rtw89_vif *rtwvif)\n{\n\tconst struct rtw89_port_reg *p = &rtw_port_base;\n\n\trtw89_write32_port_mask(rtwdev, rtwvif, p->tbtt_prohib,\n\t\t\t\tB_AX_TBTT_HOLD_MASK, BCN_HOLD_DEF);\n}\n\nstatic void rtw89_mac_port_cfg_bcn_mask_area(struct rtw89_dev *rtwdev,\n\t\t\t\t\t     struct rtw89_vif *rtwvif)\n{\n\tconst struct rtw89_port_reg *p = &rtw_port_base;\n\n\trtw89_write32_port_mask(rtwdev, rtwvif, p->bcn_area,\n\t\t\t\tB_AX_BCN_MSK_AREA_MASK, BCN_MASK_DEF);\n}\n\nstatic void rtw89_mac_port_cfg_tbtt_early(struct rtw89_dev *rtwdev,\n\t\t\t\t\t  struct rtw89_vif *rtwvif)\n{\n\tconst struct rtw89_port_reg *p = &rtw_port_base;\n\n\trtw89_write16_port_mask(rtwdev, rtwvif, p->tbtt_early,\n\t\t\t\tB_AX_TBTTERLY_MASK, TBTT_ERLY_DEF);\n}\n\nstatic void rtw89_mac_port_cfg_bss_color(struct rtw89_dev *rtwdev,\n\t\t\t\t\t struct rtw89_vif *rtwvif)\n{\n\tstruct ieee80211_vif *vif = rtwvif_to_vif(rtwvif);\n\tstatic const u32 masks[RTW89_PORT_NUM] = {\n\t\tB_AX_BSS_COLOB_AX_PORT_0_MASK, B_AX_BSS_COLOB_AX_PORT_1_MASK,\n\t\tB_AX_BSS_COLOB_AX_PORT_2_MASK, B_AX_BSS_COLOB_AX_PORT_3_MASK,\n\t\tB_AX_BSS_COLOB_AX_PORT_4_MASK,\n\t};\n\tu8 port = rtwvif->port;\n\tu32 reg_base;\n\tu32 reg;\n\tu8 bss_color;\n\n\tbss_color = vif->bss_conf.he_bss_color.color;\n\treg_base = port >= 4 ? R_AX_PTCL_BSS_COLOR_1 : R_AX_PTCL_BSS_COLOR_0;\n\treg = rtw89_mac_reg_by_idx(rtwdev, reg_base, rtwvif->mac_idx);\n\trtw89_write32_mask(rtwdev, reg, masks[port], bss_color);\n}\n\nstatic void rtw89_mac_port_cfg_mbssid(struct rtw89_dev *rtwdev,\n\t\t\t\t      struct rtw89_vif *rtwvif)\n{\n\tu8 port = rtwvif->port;\n\tu32 reg;\n\n\tif (rtwvif->net_type == RTW89_NET_TYPE_AP_MODE)\n\t\treturn;\n\n\tif (port == 0) {\n\t\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_MBSSID_CTRL, rtwvif->mac_idx);\n\t\trtw89_write32_clr(rtwdev, reg, B_AX_P0MB_ALL_MASK);\n\t}\n}\n\nstatic void rtw89_mac_port_cfg_hiq_drop(struct rtw89_dev *rtwdev,\n\t\t\t\t\tstruct rtw89_vif *rtwvif)\n{\n\tu8 port = rtwvif->port;\n\tu32 reg;\n\tu32 val;\n\n\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_MBSSID_DROP_0, rtwvif->mac_idx);\n\tval = rtw89_read32(rtwdev, reg);\n\tval &= ~FIELD_PREP(B_AX_PORT_DROP_4_0_MASK, BIT(port));\n\tif (port == 0)\n\t\tval &= ~BIT(0);\n\trtw89_write32(rtwdev, reg, val);\n}\n\nstatic void rtw89_mac_port_cfg_func_en(struct rtw89_dev *rtwdev,\n\t\t\t\t       struct rtw89_vif *rtwvif, bool enable)\n{\n\tconst struct rtw89_port_reg *p = &rtw_port_base;\n\n\tif (enable)\n\t\trtw89_write32_port_set(rtwdev, rtwvif, p->port_cfg,\n\t\t\t\t       B_AX_PORT_FUNC_EN);\n\telse\n\t\trtw89_write32_port_clr(rtwdev, rtwvif, p->port_cfg,\n\t\t\t\t       B_AX_PORT_FUNC_EN);\n}\n\nstatic void rtw89_mac_port_cfg_bcn_early(struct rtw89_dev *rtwdev,\n\t\t\t\t\t struct rtw89_vif *rtwvif)\n{\n\tconst struct rtw89_port_reg *p = &rtw_port_base;\n\n\trtw89_write32_port_mask(rtwdev, rtwvif, p->bcn_early, B_AX_BCNERLY_MASK,\n\t\t\t\tBCN_ERLY_DEF);\n}\n\nstatic void rtw89_mac_port_cfg_tbtt_shift(struct rtw89_dev *rtwdev,\n\t\t\t\t\t  struct rtw89_vif *rtwvif)\n{\n\tconst struct rtw89_port_reg *p = &rtw_port_base;\n\tu16 val;\n\n\tif (rtwdev->chip->chip_id != RTL8852C)\n\t\treturn;\n\n\tif (rtwvif->wifi_role != RTW89_WIFI_ROLE_P2P_CLIENT &&\n\t    rtwvif->wifi_role != RTW89_WIFI_ROLE_STATION)\n\t\treturn;\n\n\tval = FIELD_PREP(B_AX_TBTT_SHIFT_OFST_MAG, 1) |\n\t\t\t B_AX_TBTT_SHIFT_OFST_SIGN;\n\n\trtw89_write16_port_mask(rtwdev, rtwvif, p->tbtt_shift,\n\t\t\t\tB_AX_TBTT_SHIFT_OFST_MASK, val);\n}\n\nvoid rtw89_mac_port_tsf_sync(struct rtw89_dev *rtwdev,\n\t\t\t     struct rtw89_vif *rtwvif,\n\t\t\t     struct rtw89_vif *rtwvif_src,\n\t\t\t     u16 offset_tu)\n{\n\tu32 val, reg;\n\n\tval = RTW89_PORT_OFFSET_TU_TO_32US(offset_tu);\n\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_PORT0_TSF_SYNC + rtwvif->port * 4,\n\t\t\t\t   rtwvif->mac_idx);\n\n\trtw89_write32_mask(rtwdev, reg, B_AX_SYNC_PORT_SRC, rtwvif_src->port);\n\trtw89_write32_mask(rtwdev, reg, B_AX_SYNC_PORT_OFFSET_VAL, val);\n\trtw89_write32_set(rtwdev, reg, B_AX_SYNC_NOW);\n}\n\nstatic void rtw89_mac_port_tsf_sync_rand(struct rtw89_dev *rtwdev,\n\t\t\t\t\t struct rtw89_vif *rtwvif,\n\t\t\t\t\t struct rtw89_vif *rtwvif_src,\n\t\t\t\t\t u8 offset, int *n_offset)\n{\n\tif (rtwvif->net_type != RTW89_NET_TYPE_AP_MODE || rtwvif == rtwvif_src)\n\t\treturn;\n\n\t \n\toffset = offset - offset / 4 + get_random_u32() % (offset / 2);\n\trtw89_mac_port_tsf_sync(rtwdev, rtwvif, rtwvif_src,\n\t\t\t\t(*n_offset) * offset);\n\n\t(*n_offset)++;\n}\n\nstatic void rtw89_mac_port_tsf_resync_all(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_vif *src = NULL, *tmp;\n\tu8 offset = 100, vif_aps = 0;\n\tint n_offset = 1;\n\n\trtw89_for_each_rtwvif(rtwdev, tmp) {\n\t\tif (!src || tmp->net_type == RTW89_NET_TYPE_INFRA)\n\t\t\tsrc = tmp;\n\t\tif (tmp->net_type == RTW89_NET_TYPE_AP_MODE)\n\t\t\tvif_aps++;\n\t}\n\n\tif (vif_aps == 0)\n\t\treturn;\n\n\toffset /= (vif_aps + 1);\n\n\trtw89_for_each_rtwvif(rtwdev, tmp)\n\t\trtw89_mac_port_tsf_sync_rand(rtwdev, tmp, src, offset, &n_offset);\n}\n\nint rtw89_mac_vif_init(struct rtw89_dev *rtwdev, struct rtw89_vif *rtwvif)\n{\n\tint ret;\n\n\tret = rtw89_mac_port_update(rtwdev, rtwvif);\n\tif (ret)\n\t\treturn ret;\n\n\trtw89_mac_dmac_tbl_init(rtwdev, rtwvif->mac_id);\n\trtw89_mac_cmac_tbl_init(rtwdev, rtwvif->mac_id);\n\n\tret = rtw89_mac_set_macid_pause(rtwdev, rtwvif->mac_id, false);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rtw89_fw_h2c_role_maintain(rtwdev, rtwvif, NULL, RTW89_ROLE_CREATE);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rtw89_fw_h2c_join_info(rtwdev, rtwvif, NULL, true);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rtw89_cam_init(rtwdev, rtwvif);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rtw89_fw_h2c_cam(rtwdev, rtwvif, NULL, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rtw89_fw_h2c_default_cmac_tbl(rtwdev, rtwvif);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nint rtw89_mac_vif_deinit(struct rtw89_dev *rtwdev, struct rtw89_vif *rtwvif)\n{\n\tint ret;\n\n\tret = rtw89_fw_h2c_role_maintain(rtwdev, rtwvif, NULL, RTW89_ROLE_REMOVE);\n\tif (ret)\n\t\treturn ret;\n\n\trtw89_cam_deinit(rtwdev, rtwvif);\n\n\tret = rtw89_fw_h2c_cam(rtwdev, rtwvif, NULL, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nint rtw89_mac_port_update(struct rtw89_dev *rtwdev, struct rtw89_vif *rtwvif)\n{\n\tu8 port = rtwvif->port;\n\n\tif (port >= RTW89_PORT_NUM)\n\t\treturn -EINVAL;\n\n\trtw89_mac_port_cfg_func_sw(rtwdev, rtwvif);\n\trtw89_mac_port_cfg_tx_rpt(rtwdev, rtwvif, false);\n\trtw89_mac_port_cfg_rx_rpt(rtwdev, rtwvif, false);\n\trtw89_mac_port_cfg_net_type(rtwdev, rtwvif);\n\trtw89_mac_port_cfg_bcn_prct(rtwdev, rtwvif);\n\trtw89_mac_port_cfg_rx_sw(rtwdev, rtwvif);\n\trtw89_mac_port_cfg_rx_sync(rtwdev, rtwvif);\n\trtw89_mac_port_cfg_tx_sw(rtwdev, rtwvif);\n\trtw89_mac_port_cfg_bcn_intv(rtwdev, rtwvif);\n\trtw89_mac_port_cfg_hiq_win(rtwdev, rtwvif);\n\trtw89_mac_port_cfg_hiq_dtim(rtwdev, rtwvif);\n\trtw89_mac_port_cfg_hiq_drop(rtwdev, rtwvif);\n\trtw89_mac_port_cfg_bcn_setup_time(rtwdev, rtwvif);\n\trtw89_mac_port_cfg_bcn_hold_time(rtwdev, rtwvif);\n\trtw89_mac_port_cfg_bcn_mask_area(rtwdev, rtwvif);\n\trtw89_mac_port_cfg_tbtt_early(rtwdev, rtwvif);\n\trtw89_mac_port_cfg_tbtt_shift(rtwdev, rtwvif);\n\trtw89_mac_port_cfg_bss_color(rtwdev, rtwvif);\n\trtw89_mac_port_cfg_mbssid(rtwdev, rtwvif);\n\trtw89_mac_port_cfg_func_en(rtwdev, rtwvif, true);\n\trtw89_mac_port_tsf_resync_all(rtwdev);\n\tfsleep(BCN_ERLY_SET_DLY);\n\trtw89_mac_port_cfg_bcn_early(rtwdev, rtwvif);\n\n\treturn 0;\n}\n\nint rtw89_mac_port_get_tsf(struct rtw89_dev *rtwdev, struct rtw89_vif *rtwvif,\n\t\t\t   u64 *tsf)\n{\n\tconst struct rtw89_port_reg *p = &rtw_port_base;\n\tu32 tsf_low, tsf_high;\n\tint ret;\n\n\tret = rtw89_mac_check_mac_en(rtwdev, rtwvif->mac_idx, RTW89_CMAC_SEL);\n\tif (ret)\n\t\treturn ret;\n\n\ttsf_low = rtw89_read32_port(rtwdev, rtwvif, p->tsftr_l);\n\ttsf_high = rtw89_read32_port(rtwdev, rtwvif, p->tsftr_h);\n\t*tsf = (u64)tsf_high << 32 | tsf_low;\n\n\treturn 0;\n}\n\nstatic void rtw89_mac_check_he_obss_narrow_bw_ru_iter(struct wiphy *wiphy,\n\t\t\t\t\t\t      struct cfg80211_bss *bss,\n\t\t\t\t\t\t      void *data)\n{\n\tconst struct cfg80211_bss_ies *ies;\n\tconst struct element *elem;\n\tbool *tolerated = data;\n\n\trcu_read_lock();\n\ties = rcu_dereference(bss->ies);\n\telem = cfg80211_find_elem(WLAN_EID_EXT_CAPABILITY, ies->data,\n\t\t\t\t  ies->len);\n\n\tif (!elem || elem->datalen < 10 ||\n\t    !(elem->data[10] & WLAN_EXT_CAPA10_OBSS_NARROW_BW_RU_TOLERANCE_SUPPORT))\n\t\t*tolerated = false;\n\trcu_read_unlock();\n}\n\nvoid rtw89_mac_set_he_obss_narrow_bw_ru(struct rtw89_dev *rtwdev,\n\t\t\t\t\tstruct ieee80211_vif *vif)\n{\n\tstruct rtw89_vif *rtwvif = (struct rtw89_vif *)vif->drv_priv;\n\tstruct ieee80211_hw *hw = rtwdev->hw;\n\tbool tolerated = true;\n\tu32 reg;\n\n\tif (!vif->bss_conf.he_support || vif->type != NL80211_IFTYPE_STATION)\n\t\treturn;\n\n\tif (!(vif->bss_conf.chandef.chan->flags & IEEE80211_CHAN_RADAR))\n\t\treturn;\n\n\tcfg80211_bss_iter(hw->wiphy, &vif->bss_conf.chandef,\n\t\t\t  rtw89_mac_check_he_obss_narrow_bw_ru_iter,\n\t\t\t  &tolerated);\n\n\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_RXTRIG_TEST_USER_2, rtwvif->mac_idx);\n\tif (tolerated)\n\t\trtw89_write32_clr(rtwdev, reg, B_AX_RXTRIG_RU26_DIS);\n\telse\n\t\trtw89_write32_set(rtwdev, reg, B_AX_RXTRIG_RU26_DIS);\n}\n\nvoid rtw89_mac_stop_ap(struct rtw89_dev *rtwdev, struct rtw89_vif *rtwvif)\n{\n\trtw89_mac_port_cfg_func_en(rtwdev, rtwvif, false);\n}\n\nint rtw89_mac_add_vif(struct rtw89_dev *rtwdev, struct rtw89_vif *rtwvif)\n{\n\tint ret;\n\n\trtwvif->mac_id = rtw89_core_acquire_bit_map(rtwdev->mac_id_map,\n\t\t\t\t\t\t    RTW89_MAX_MAC_ID_NUM);\n\tif (rtwvif->mac_id == RTW89_MAX_MAC_ID_NUM)\n\t\treturn -ENOSPC;\n\n\tret = rtw89_mac_vif_init(rtwdev, rtwvif);\n\tif (ret)\n\t\tgoto release_mac_id;\n\n\treturn 0;\n\nrelease_mac_id:\n\trtw89_core_release_bit_map(rtwdev->mac_id_map, rtwvif->mac_id);\n\n\treturn ret;\n}\n\nint rtw89_mac_remove_vif(struct rtw89_dev *rtwdev, struct rtw89_vif *rtwvif)\n{\n\tint ret;\n\n\tret = rtw89_mac_vif_deinit(rtwdev, rtwvif);\n\trtw89_core_release_bit_map(rtwdev->mac_id_map, rtwvif->mac_id);\n\n\treturn ret;\n}\n\nstatic void\nrtw89_mac_c2h_macid_pause(struct rtw89_dev *rtwdev, struct sk_buff *c2h, u32 len)\n{\n}\n\nstatic bool rtw89_is_op_chan(struct rtw89_dev *rtwdev, u8 band, u8 channel)\n{\n\tconst struct rtw89_chan *op = &rtwdev->scan_info.op_chan;\n\n\treturn band == op->band_type && channel == op->primary_channel;\n}\n\nstatic void\nrtw89_mac_c2h_scanofld_rsp(struct rtw89_dev *rtwdev, struct sk_buff *c2h,\n\t\t\t   u32 len)\n{\n\tstruct ieee80211_vif *vif = rtwdev->scan_info.scanning_vif;\n\tstruct rtw89_vif *rtwvif = vif_to_rtwvif_safe(vif);\n\tstruct rtw89_chan new;\n\tu8 reason, status, tx_fail, band, actual_period;\n\tu32 last_chan = rtwdev->scan_info.last_chan_idx;\n\tu16 chan;\n\tint ret;\n\n\tif (!rtwvif)\n\t\treturn;\n\n\ttx_fail = RTW89_GET_MAC_C2H_SCANOFLD_TX_FAIL(c2h->data);\n\tstatus = RTW89_GET_MAC_C2H_SCANOFLD_STATUS(c2h->data);\n\tchan = RTW89_GET_MAC_C2H_SCANOFLD_PRI_CH(c2h->data);\n\treason = RTW89_GET_MAC_C2H_SCANOFLD_RSP(c2h->data);\n\tband = RTW89_GET_MAC_C2H_SCANOFLD_BAND(c2h->data);\n\tactual_period = RTW89_GET_MAC_C2H_ACTUAL_PERIOD(c2h->data);\n\n\tif (!(rtwdev->chip->support_bands & BIT(NL80211_BAND_6GHZ)))\n\t\tband = chan > 14 ? RTW89_BAND_5G : RTW89_BAND_2G;\n\n\trtw89_debug(rtwdev, RTW89_DBG_HW_SCAN,\n\t\t    \"band: %d, chan: %d, reason: %d, status: %d, tx_fail: %d, actual: %d\\n\",\n\t\t    band, chan, reason, status, tx_fail, actual_period);\n\n\tswitch (reason) {\n\tcase RTW89_SCAN_LEAVE_CH_NOTIFY:\n\t\tif (rtw89_is_op_chan(rtwdev, band, chan))\n\t\t\tieee80211_stop_queues(rtwdev->hw);\n\t\treturn;\n\tcase RTW89_SCAN_END_SCAN_NOTIFY:\n\t\tif (rtwvif && rtwvif->scan_req &&\n\t\t    last_chan < rtwvif->scan_req->n_channels) {\n\t\t\tret = rtw89_hw_scan_offload(rtwdev, vif, true);\n\t\t\tif (ret) {\n\t\t\t\trtw89_hw_scan_abort(rtwdev, vif);\n\t\t\t\trtw89_warn(rtwdev, \"HW scan failed: %d\\n\", ret);\n\t\t\t}\n\t\t} else {\n\t\t\trtw89_hw_scan_complete(rtwdev, vif, false);\n\t\t}\n\t\tbreak;\n\tcase RTW89_SCAN_ENTER_CH_NOTIFY:\n\t\tif (rtw89_is_op_chan(rtwdev, band, chan)) {\n\t\t\trtw89_assign_entity_chan(rtwdev, rtwvif->sub_entity_idx,\n\t\t\t\t\t\t &rtwdev->scan_info.op_chan);\n\t\t\tieee80211_wake_queues(rtwdev->hw);\n\t\t} else {\n\t\t\trtw89_chan_create(&new, chan, chan, band,\n\t\t\t\t\t  RTW89_CHANNEL_WIDTH_20);\n\t\t\trtw89_assign_entity_chan(rtwdev, rtwvif->sub_entity_idx,\n\t\t\t\t\t\t &new);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n}\n\nstatic void\nrtw89_mac_bcn_fltr_rpt(struct rtw89_dev *rtwdev, struct rtw89_vif *rtwvif,\n\t\t       struct sk_buff *skb)\n{\n\tstruct ieee80211_vif *vif = rtwvif_to_vif_safe(rtwvif);\n\tenum nl80211_cqm_rssi_threshold_event nl_event;\n\tconst struct rtw89_c2h_mac_bcnfltr_rpt *c2h =\n\t\t(const struct rtw89_c2h_mac_bcnfltr_rpt *)skb->data;\n\tu8 type, event, mac_id;\n\ts8 sig;\n\n\ttype = le32_get_bits(c2h->w2, RTW89_C2H_MAC_BCNFLTR_RPT_W2_TYPE);\n\tsig = le32_get_bits(c2h->w2, RTW89_C2H_MAC_BCNFLTR_RPT_W2_MA) - MAX_RSSI;\n\tevent = le32_get_bits(c2h->w2, RTW89_C2H_MAC_BCNFLTR_RPT_W2_EVENT);\n\tmac_id = le32_get_bits(c2h->w2, RTW89_C2H_MAC_BCNFLTR_RPT_W2_MACID);\n\n\tif (mac_id != rtwvif->mac_id)\n\t\treturn;\n\n\trtw89_debug(rtwdev, RTW89_DBG_FW,\n\t\t    \"C2H bcnfltr rpt macid: %d, type: %d, ma: %d, event: %d\\n\",\n\t\t    mac_id, type, sig, event);\n\n\tswitch (type) {\n\tcase RTW89_BCN_FLTR_BEACON_LOSS:\n\t\tif (!rtwdev->scanning && !rtwvif->offchan)\n\t\t\tieee80211_connection_loss(vif);\n\t\telse\n\t\t\trtw89_fw_h2c_set_bcn_fltr_cfg(rtwdev, vif, true);\n\t\treturn;\n\tcase RTW89_BCN_FLTR_NOTIFY:\n\t\tnl_event = NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH;\n\t\tbreak;\n\tcase RTW89_BCN_FLTR_RSSI:\n\t\tif (event == RTW89_BCN_FLTR_RSSI_LOW)\n\t\t\tnl_event = NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW;\n\t\telse if (event == RTW89_BCN_FLTR_RSSI_HIGH)\n\t\t\tnl_event = NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH;\n\t\telse\n\t\t\treturn;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tieee80211_cqm_rssi_notify(vif, nl_event, sig, GFP_KERNEL);\n}\n\nstatic void\nrtw89_mac_c2h_bcn_fltr_rpt(struct rtw89_dev *rtwdev, struct sk_buff *c2h,\n\t\t\t   u32 len)\n{\n\tstruct rtw89_vif *rtwvif;\n\n\trtw89_for_each_rtwvif(rtwdev, rtwvif)\n\t\trtw89_mac_bcn_fltr_rpt(rtwdev, rtwvif, c2h);\n}\n\nstatic void\nrtw89_mac_c2h_rec_ack(struct rtw89_dev *rtwdev, struct sk_buff *c2h, u32 len)\n{\n\t \n\n\trtw89_debug(rtwdev, RTW89_DBG_FW,\n\t\t    \"C2H rev ack recv, cat: %d, class: %d, func: %d, seq : %d\\n\",\n\t\t    RTW89_GET_MAC_C2H_REV_ACK_CAT(c2h->data),\n\t\t    RTW89_GET_MAC_C2H_REV_ACK_CLASS(c2h->data),\n\t\t    RTW89_GET_MAC_C2H_REV_ACK_FUNC(c2h->data),\n\t\t    RTW89_GET_MAC_C2H_REV_ACK_H2C_SEQ(c2h->data));\n}\n\nstatic void\nrtw89_mac_c2h_done_ack(struct rtw89_dev *rtwdev, struct sk_buff *skb_c2h, u32 len)\n{\n\t \n\tstruct rtw89_wait_info *fw_ofld_wait = &rtwdev->mac.fw_ofld_wait;\n\tconst struct rtw89_c2h_done_ack *c2h =\n\t\t(const struct rtw89_c2h_done_ack *)skb_c2h->data;\n\tu8 h2c_cat = le32_get_bits(c2h->w2, RTW89_C2H_DONE_ACK_W2_CAT);\n\tu8 h2c_class = le32_get_bits(c2h->w2, RTW89_C2H_DONE_ACK_W2_CLASS);\n\tu8 h2c_func = le32_get_bits(c2h->w2, RTW89_C2H_DONE_ACK_W2_FUNC);\n\tu8 h2c_return = le32_get_bits(c2h->w2, RTW89_C2H_DONE_ACK_W2_H2C_RETURN);\n\tu8 h2c_seq = le32_get_bits(c2h->w2, RTW89_C2H_DONE_ACK_W2_H2C_SEQ);\n\tstruct rtw89_completion_data data = {};\n\tunsigned int cond;\n\n\trtw89_debug(rtwdev, RTW89_DBG_FW,\n\t\t    \"C2H done ack recv, cat: %d, class: %d, func: %d, ret: %d, seq : %d\\n\",\n\t\t    h2c_cat, h2c_class, h2c_func, h2c_return, h2c_seq);\n\n\tif (h2c_cat != H2C_CAT_MAC)\n\t\treturn;\n\n\tswitch (h2c_class) {\n\tdefault:\n\t\treturn;\n\tcase H2C_CL_MAC_FW_OFLD:\n\t\tswitch (h2c_func) {\n\t\tdefault:\n\t\t\treturn;\n\t\tcase H2C_FUNC_ADD_SCANOFLD_CH:\n\t\tcase H2C_FUNC_SCANOFLD:\n\t\t\tcond = RTW89_FW_OFLD_WAIT_COND(0, h2c_func);\n\t\t\tbreak;\n\t\t}\n\n\t\tdata.err = !!h2c_return;\n\t\trtw89_complete_cond(fw_ofld_wait, cond, &data);\n\t\treturn;\n\t}\n}\n\nstatic void\nrtw89_mac_c2h_log(struct rtw89_dev *rtwdev, struct sk_buff *c2h, u32 len)\n{\n\trtw89_fw_log_dump(rtwdev, c2h->data, len);\n}\n\nstatic void\nrtw89_mac_c2h_bcn_cnt(struct rtw89_dev *rtwdev, struct sk_buff *c2h, u32 len)\n{\n}\n\nstatic void\nrtw89_mac_c2h_pkt_ofld_rsp(struct rtw89_dev *rtwdev, struct sk_buff *skb_c2h,\n\t\t\t   u32 len)\n{\n\tstruct rtw89_wait_info *wait = &rtwdev->mac.fw_ofld_wait;\n\tconst struct rtw89_c2h_pkt_ofld_rsp *c2h =\n\t\t(const struct rtw89_c2h_pkt_ofld_rsp *)skb_c2h->data;\n\tu16 pkt_len = le32_get_bits(c2h->w2, RTW89_C2H_PKT_OFLD_RSP_W2_PTK_LEN);\n\tu8 pkt_id = le32_get_bits(c2h->w2, RTW89_C2H_PKT_OFLD_RSP_W2_PTK_ID);\n\tu8 pkt_op = le32_get_bits(c2h->w2, RTW89_C2H_PKT_OFLD_RSP_W2_PTK_OP);\n\tstruct rtw89_completion_data data = {};\n\tunsigned int cond;\n\n\trtw89_debug(rtwdev, RTW89_DBG_FW, \"pkt ofld rsp: id %d op %d len %d\\n\",\n\t\t    pkt_id, pkt_op, pkt_len);\n\n\tdata.err = !pkt_len;\n\tcond = RTW89_FW_OFLD_WAIT_COND_PKT_OFLD(pkt_id, pkt_op);\n\n\trtw89_complete_cond(wait, cond, &data);\n}\n\nstatic void\nrtw89_mac_c2h_tsf32_toggle_rpt(struct rtw89_dev *rtwdev, struct sk_buff *c2h,\n\t\t\t       u32 len)\n{\n}\n\nstatic void\nrtw89_mac_c2h_mcc_rcv_ack(struct rtw89_dev *rtwdev, struct sk_buff *c2h, u32 len)\n{\n\tu8 group = RTW89_GET_MAC_C2H_MCC_RCV_ACK_GROUP(c2h->data);\n\tu8 func = RTW89_GET_MAC_C2H_MCC_RCV_ACK_H2C_FUNC(c2h->data);\n\n\tswitch (func) {\n\tcase H2C_FUNC_ADD_MCC:\n\tcase H2C_FUNC_START_MCC:\n\tcase H2C_FUNC_STOP_MCC:\n\tcase H2C_FUNC_DEL_MCC_GROUP:\n\tcase H2C_FUNC_RESET_MCC_GROUP:\n\tcase H2C_FUNC_MCC_REQ_TSF:\n\tcase H2C_FUNC_MCC_MACID_BITMAP:\n\tcase H2C_FUNC_MCC_SYNC:\n\tcase H2C_FUNC_MCC_SET_DURATION:\n\t\tbreak;\n\tdefault:\n\t\trtw89_debug(rtwdev, RTW89_DBG_CHAN,\n\t\t\t    \"invalid MCC C2H RCV ACK: func %d\\n\", func);\n\t\treturn;\n\t}\n\n\trtw89_debug(rtwdev, RTW89_DBG_CHAN,\n\t\t    \"MCC C2H RCV ACK: group %d, func %d\\n\", group, func);\n}\n\nstatic void\nrtw89_mac_c2h_mcc_req_ack(struct rtw89_dev *rtwdev, struct sk_buff *c2h, u32 len)\n{\n\tu8 group = RTW89_GET_MAC_C2H_MCC_REQ_ACK_GROUP(c2h->data);\n\tu8 func = RTW89_GET_MAC_C2H_MCC_REQ_ACK_H2C_FUNC(c2h->data);\n\tu8 retcode = RTW89_GET_MAC_C2H_MCC_REQ_ACK_H2C_RETURN(c2h->data);\n\tstruct rtw89_completion_data data = {};\n\tunsigned int cond;\n\tbool next = false;\n\n\tswitch (func) {\n\tcase H2C_FUNC_MCC_REQ_TSF:\n\t\tnext = true;\n\t\tbreak;\n\tcase H2C_FUNC_MCC_MACID_BITMAP:\n\tcase H2C_FUNC_MCC_SYNC:\n\tcase H2C_FUNC_MCC_SET_DURATION:\n\t\tbreak;\n\tcase H2C_FUNC_ADD_MCC:\n\tcase H2C_FUNC_START_MCC:\n\tcase H2C_FUNC_STOP_MCC:\n\tcase H2C_FUNC_DEL_MCC_GROUP:\n\tcase H2C_FUNC_RESET_MCC_GROUP:\n\tdefault:\n\t\trtw89_debug(rtwdev, RTW89_DBG_CHAN,\n\t\t\t    \"invalid MCC C2H REQ ACK: func %d\\n\", func);\n\t\treturn;\n\t}\n\n\trtw89_debug(rtwdev, RTW89_DBG_CHAN,\n\t\t    \"MCC C2H REQ ACK: group %d, func %d, return code %d\\n\",\n\t\t    group, func, retcode);\n\n\tif (!retcode && next)\n\t\treturn;\n\n\tdata.err = !!retcode;\n\tcond = RTW89_MCC_WAIT_COND(group, func);\n\trtw89_complete_cond(&rtwdev->mcc.wait, cond, &data);\n}\n\nstatic void\nrtw89_mac_c2h_mcc_tsf_rpt(struct rtw89_dev *rtwdev, struct sk_buff *c2h, u32 len)\n{\n\tu8 group = RTW89_GET_MAC_C2H_MCC_TSF_RPT_GROUP(c2h->data);\n\tstruct rtw89_completion_data data = {};\n\tstruct rtw89_mac_mcc_tsf_rpt *rpt;\n\tunsigned int cond;\n\n\trpt = (struct rtw89_mac_mcc_tsf_rpt *)data.buf;\n\trpt->macid_x = RTW89_GET_MAC_C2H_MCC_TSF_RPT_MACID_X(c2h->data);\n\trpt->macid_y = RTW89_GET_MAC_C2H_MCC_TSF_RPT_MACID_Y(c2h->data);\n\trpt->tsf_x_low = RTW89_GET_MAC_C2H_MCC_TSF_RPT_TSF_LOW_X(c2h->data);\n\trpt->tsf_x_high = RTW89_GET_MAC_C2H_MCC_TSF_RPT_TSF_HIGH_X(c2h->data);\n\trpt->tsf_y_low = RTW89_GET_MAC_C2H_MCC_TSF_RPT_TSF_LOW_Y(c2h->data);\n\trpt->tsf_y_high = RTW89_GET_MAC_C2H_MCC_TSF_RPT_TSF_HIGH_Y(c2h->data);\n\n\trtw89_debug(rtwdev, RTW89_DBG_CHAN,\n\t\t    \"MCC C2H TSF RPT: macid %d> %llu, macid %d> %llu\\n\",\n\t\t    rpt->macid_x, (u64)rpt->tsf_x_high << 32 | rpt->tsf_x_low,\n\t\t    rpt->macid_y, (u64)rpt->tsf_y_high << 32 | rpt->tsf_y_low);\n\n\tcond = RTW89_MCC_WAIT_COND(group, H2C_FUNC_MCC_REQ_TSF);\n\trtw89_complete_cond(&rtwdev->mcc.wait, cond, &data);\n}\n\nstatic void\nrtw89_mac_c2h_mcc_status_rpt(struct rtw89_dev *rtwdev, struct sk_buff *c2h, u32 len)\n{\n\tu8 group = RTW89_GET_MAC_C2H_MCC_STATUS_RPT_GROUP(c2h->data);\n\tu8 macid = RTW89_GET_MAC_C2H_MCC_STATUS_RPT_MACID(c2h->data);\n\tu8 status = RTW89_GET_MAC_C2H_MCC_STATUS_RPT_STATUS(c2h->data);\n\tu32 tsf_low = RTW89_GET_MAC_C2H_MCC_STATUS_RPT_TSF_LOW(c2h->data);\n\tu32 tsf_high = RTW89_GET_MAC_C2H_MCC_STATUS_RPT_TSF_HIGH(c2h->data);\n\tstruct rtw89_completion_data data = {};\n\tunsigned int cond;\n\tbool rsp = true;\n\tbool err;\n\tu8 func;\n\n\tswitch (status) {\n\tcase RTW89_MAC_MCC_ADD_ROLE_OK:\n\tcase RTW89_MAC_MCC_ADD_ROLE_FAIL:\n\t\tfunc = H2C_FUNC_ADD_MCC;\n\t\terr = status == RTW89_MAC_MCC_ADD_ROLE_FAIL;\n\t\tbreak;\n\tcase RTW89_MAC_MCC_START_GROUP_OK:\n\tcase RTW89_MAC_MCC_START_GROUP_FAIL:\n\t\tfunc = H2C_FUNC_START_MCC;\n\t\terr = status == RTW89_MAC_MCC_START_GROUP_FAIL;\n\t\tbreak;\n\tcase RTW89_MAC_MCC_STOP_GROUP_OK:\n\tcase RTW89_MAC_MCC_STOP_GROUP_FAIL:\n\t\tfunc = H2C_FUNC_STOP_MCC;\n\t\terr = status == RTW89_MAC_MCC_STOP_GROUP_FAIL;\n\t\tbreak;\n\tcase RTW89_MAC_MCC_DEL_GROUP_OK:\n\tcase RTW89_MAC_MCC_DEL_GROUP_FAIL:\n\t\tfunc = H2C_FUNC_DEL_MCC_GROUP;\n\t\terr = status == RTW89_MAC_MCC_DEL_GROUP_FAIL;\n\t\tbreak;\n\tcase RTW89_MAC_MCC_RESET_GROUP_OK:\n\tcase RTW89_MAC_MCC_RESET_GROUP_FAIL:\n\t\tfunc = H2C_FUNC_RESET_MCC_GROUP;\n\t\terr = status == RTW89_MAC_MCC_RESET_GROUP_FAIL;\n\t\tbreak;\n\tcase RTW89_MAC_MCC_SWITCH_CH_OK:\n\tcase RTW89_MAC_MCC_SWITCH_CH_FAIL:\n\tcase RTW89_MAC_MCC_TXNULL0_OK:\n\tcase RTW89_MAC_MCC_TXNULL0_FAIL:\n\tcase RTW89_MAC_MCC_TXNULL1_OK:\n\tcase RTW89_MAC_MCC_TXNULL1_FAIL:\n\tcase RTW89_MAC_MCC_SWITCH_EARLY:\n\tcase RTW89_MAC_MCC_TBTT:\n\tcase RTW89_MAC_MCC_DURATION_START:\n\tcase RTW89_MAC_MCC_DURATION_END:\n\t\trsp = false;\n\t\tbreak;\n\tdefault:\n\t\trtw89_debug(rtwdev, RTW89_DBG_CHAN,\n\t\t\t    \"invalid MCC C2H STS RPT: status %d\\n\", status);\n\t\treturn;\n\t}\n\n\trtw89_debug(rtwdev, RTW89_DBG_CHAN,\n\t\t    \"MCC C2H STS RPT: group %d, macid %d, status %d, tsf %llu\\n\",\n\t\t     group, macid, status, (u64)tsf_high << 32 | tsf_low);\n\n\tif (!rsp)\n\t\treturn;\n\n\tdata.err = err;\n\tcond = RTW89_MCC_WAIT_COND(group, func);\n\trtw89_complete_cond(&rtwdev->mcc.wait, cond, &data);\n}\n\nstatic\nvoid (* const rtw89_mac_c2h_ofld_handler[])(struct rtw89_dev *rtwdev,\n\t\t\t\t\t    struct sk_buff *c2h, u32 len) = {\n\t[RTW89_MAC_C2H_FUNC_EFUSE_DUMP] = NULL,\n\t[RTW89_MAC_C2H_FUNC_READ_RSP] = NULL,\n\t[RTW89_MAC_C2H_FUNC_PKT_OFLD_RSP] = rtw89_mac_c2h_pkt_ofld_rsp,\n\t[RTW89_MAC_C2H_FUNC_BCN_RESEND] = NULL,\n\t[RTW89_MAC_C2H_FUNC_MACID_PAUSE] = rtw89_mac_c2h_macid_pause,\n\t[RTW89_MAC_C2H_FUNC_SCANOFLD_RSP] = rtw89_mac_c2h_scanofld_rsp,\n\t[RTW89_MAC_C2H_FUNC_TSF32_TOGL_RPT] = rtw89_mac_c2h_tsf32_toggle_rpt,\n\t[RTW89_MAC_C2H_FUNC_BCNFLTR_RPT] = rtw89_mac_c2h_bcn_fltr_rpt,\n};\n\nstatic\nvoid (* const rtw89_mac_c2h_info_handler[])(struct rtw89_dev *rtwdev,\n\t\t\t\t\t    struct sk_buff *c2h, u32 len) = {\n\t[RTW89_MAC_C2H_FUNC_REC_ACK] = rtw89_mac_c2h_rec_ack,\n\t[RTW89_MAC_C2H_FUNC_DONE_ACK] = rtw89_mac_c2h_done_ack,\n\t[RTW89_MAC_C2H_FUNC_C2H_LOG] = rtw89_mac_c2h_log,\n\t[RTW89_MAC_C2H_FUNC_BCN_CNT] = rtw89_mac_c2h_bcn_cnt,\n};\n\nstatic\nvoid (* const rtw89_mac_c2h_mcc_handler[])(struct rtw89_dev *rtwdev,\n\t\t\t\t\t   struct sk_buff *c2h, u32 len) = {\n\t[RTW89_MAC_C2H_FUNC_MCC_RCV_ACK] = rtw89_mac_c2h_mcc_rcv_ack,\n\t[RTW89_MAC_C2H_FUNC_MCC_REQ_ACK] = rtw89_mac_c2h_mcc_req_ack,\n\t[RTW89_MAC_C2H_FUNC_MCC_TSF_RPT] = rtw89_mac_c2h_mcc_tsf_rpt,\n\t[RTW89_MAC_C2H_FUNC_MCC_STATUS_RPT] = rtw89_mac_c2h_mcc_status_rpt,\n};\n\nbool rtw89_mac_c2h_chk_atomic(struct rtw89_dev *rtwdev, u8 class, u8 func)\n{\n\tswitch (class) {\n\tdefault:\n\t\treturn false;\n\tcase RTW89_MAC_C2H_CLASS_INFO:\n\t\tswitch (func) {\n\t\tdefault:\n\t\t\treturn false;\n\t\tcase RTW89_MAC_C2H_FUNC_REC_ACK:\n\t\tcase RTW89_MAC_C2H_FUNC_DONE_ACK:\n\t\t\treturn true;\n\t\t}\n\tcase RTW89_MAC_C2H_CLASS_OFLD:\n\t\tswitch (func) {\n\t\tdefault:\n\t\t\treturn false;\n\t\tcase RTW89_MAC_C2H_FUNC_PKT_OFLD_RSP:\n\t\t\treturn true;\n\t\t}\n\tcase RTW89_MAC_C2H_CLASS_MCC:\n\t\treturn true;\n\t}\n}\n\nvoid rtw89_mac_c2h_handle(struct rtw89_dev *rtwdev, struct sk_buff *skb,\n\t\t\t  u32 len, u8 class, u8 func)\n{\n\tvoid (*handler)(struct rtw89_dev *rtwdev,\n\t\t\tstruct sk_buff *c2h, u32 len) = NULL;\n\n\tswitch (class) {\n\tcase RTW89_MAC_C2H_CLASS_INFO:\n\t\tif (func < RTW89_MAC_C2H_FUNC_INFO_MAX)\n\t\t\thandler = rtw89_mac_c2h_info_handler[func];\n\t\tbreak;\n\tcase RTW89_MAC_C2H_CLASS_OFLD:\n\t\tif (func < RTW89_MAC_C2H_FUNC_OFLD_MAX)\n\t\t\thandler = rtw89_mac_c2h_ofld_handler[func];\n\t\tbreak;\n\tcase RTW89_MAC_C2H_CLASS_MCC:\n\t\tif (func < NUM_OF_RTW89_MAC_C2H_FUNC_MCC)\n\t\t\thandler = rtw89_mac_c2h_mcc_handler[func];\n\t\tbreak;\n\tcase RTW89_MAC_C2H_CLASS_FWDBG:\n\t\treturn;\n\tdefault:\n\t\trtw89_info(rtwdev, \"c2h class %d not support\\n\", class);\n\t\treturn;\n\t}\n\tif (!handler) {\n\t\trtw89_info(rtwdev, \"c2h class %d func %d not support\\n\", class,\n\t\t\t   func);\n\t\treturn;\n\t}\n\thandler(rtwdev, skb, len);\n}\n\nbool rtw89_mac_get_txpwr_cr(struct rtw89_dev *rtwdev,\n\t\t\t    enum rtw89_phy_idx phy_idx,\n\t\t\t    u32 reg_base, u32 *cr)\n{\n\tconst struct rtw89_dle_mem *dle_mem = rtwdev->chip->dle_mem;\n\tenum rtw89_qta_mode mode = dle_mem->mode;\n\tu32 addr = rtw89_mac_reg_by_idx(rtwdev, reg_base, phy_idx);\n\n\tif (addr < R_AX_PWR_RATE_CTRL || addr > CMAC1_END_ADDR) {\n\t\trtw89_err(rtwdev, \"[TXPWR] addr=0x%x exceed txpwr cr\\n\",\n\t\t\t  addr);\n\t\tgoto error;\n\t}\n\n\tif (addr >= CMAC1_START_ADDR && addr <= CMAC1_END_ADDR)\n\t\tif (mode == RTW89_QTA_SCC) {\n\t\t\trtw89_err(rtwdev,\n\t\t\t\t  \"[TXPWR] addr=0x%x but hw not enable\\n\",\n\t\t\t\t  addr);\n\t\t\tgoto error;\n\t\t}\n\n\t*cr = addr;\n\treturn true;\n\nerror:\n\trtw89_err(rtwdev, \"[TXPWR] check txpwr cr 0x%x(phy%d) fail\\n\",\n\t\t  addr, phy_idx);\n\n\treturn false;\n}\nEXPORT_SYMBOL(rtw89_mac_get_txpwr_cr);\n\nint rtw89_mac_cfg_ppdu_status(struct rtw89_dev *rtwdev, u8 mac_idx, bool enable)\n{\n\tu32 reg = rtw89_mac_reg_by_idx(rtwdev, R_AX_PPDU_STAT, mac_idx);\n\tint ret;\n\n\tret = rtw89_mac_check_mac_en(rtwdev, mac_idx, RTW89_CMAC_SEL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!enable) {\n\t\trtw89_write32_clr(rtwdev, reg, B_AX_PPDU_STAT_RPT_EN);\n\t\treturn 0;\n\t}\n\n\trtw89_write32(rtwdev, reg, B_AX_PPDU_STAT_RPT_EN |\n\t\t\t\t   B_AX_APP_MAC_INFO_RPT |\n\t\t\t\t   B_AX_APP_RX_CNT_RPT | B_AX_APP_PLCP_HDR_RPT |\n\t\t\t\t   B_AX_PPDU_STAT_RPT_CRC32);\n\trtw89_write32_mask(rtwdev, R_AX_HW_RPT_FWD, B_AX_FWD_PPDU_STAT_MASK,\n\t\t\t   RTW89_PRPT_DEST_HOST);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rtw89_mac_cfg_ppdu_status);\n\nvoid rtw89_mac_update_rts_threshold(struct rtw89_dev *rtwdev, u8 mac_idx)\n{\n#define MAC_AX_TIME_TH_SH  5\n#define MAC_AX_LEN_TH_SH   4\n#define MAC_AX_TIME_TH_MAX 255\n#define MAC_AX_LEN_TH_MAX  255\n#define MAC_AX_TIME_TH_DEF 88\n#define MAC_AX_LEN_TH_DEF  4080\n\tstruct ieee80211_hw *hw = rtwdev->hw;\n\tu32 rts_threshold = hw->wiphy->rts_threshold;\n\tu32 time_th, len_th;\n\tu32 reg;\n\n\tif (rts_threshold == (u32)-1) {\n\t\ttime_th = MAC_AX_TIME_TH_DEF;\n\t\tlen_th = MAC_AX_LEN_TH_DEF;\n\t} else {\n\t\ttime_th = MAC_AX_TIME_TH_MAX << MAC_AX_TIME_TH_SH;\n\t\tlen_th = rts_threshold;\n\t}\n\n\ttime_th = min_t(u32, time_th >> MAC_AX_TIME_TH_SH, MAC_AX_TIME_TH_MAX);\n\tlen_th = min_t(u32, len_th >> MAC_AX_LEN_TH_SH, MAC_AX_LEN_TH_MAX);\n\n\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_AGG_LEN_HT_0, mac_idx);\n\trtw89_write16_mask(rtwdev, reg, B_AX_RTS_TXTIME_TH_MASK, time_th);\n\trtw89_write16_mask(rtwdev, reg, B_AX_RTS_LEN_TH_MASK, len_th);\n}\n\nvoid rtw89_mac_flush_txq(struct rtw89_dev *rtwdev, u32 queues, bool drop)\n{\n\tbool empty;\n\tint ret;\n\n\tif (!test_bit(RTW89_FLAG_POWERON, rtwdev->flags))\n\t\treturn;\n\n\tret = read_poll_timeout(dle_is_txq_empty, empty, empty,\n\t\t\t\t10000, 200000, false, rtwdev);\n\tif (ret && !drop && (rtwdev->total_sta_assoc || rtwdev->scanning))\n\t\trtw89_info(rtwdev, \"timed out to flush queues\\n\");\n}\n\nint rtw89_mac_coex_init(struct rtw89_dev *rtwdev, const struct rtw89_mac_ax_coex *coex)\n{\n\tu8 val;\n\tu16 val16;\n\tu32 val32;\n\tint ret;\n\n\trtw89_write8_set(rtwdev, R_AX_GPIO_MUXCFG, B_AX_ENBT);\n\tif (rtwdev->chip->chip_id != RTL8851B)\n\t\trtw89_write8_set(rtwdev, R_AX_BTC_FUNC_EN, B_AX_PTA_WL_TX_EN);\n\trtw89_write8_set(rtwdev, R_AX_BT_COEX_CFG_2 + 1, B_AX_GNT_BT_POLARITY >> 8);\n\trtw89_write8_set(rtwdev, R_AX_CSR_MODE, B_AX_STATIS_BT_EN | B_AX_WL_ACT_MSK);\n\trtw89_write8_set(rtwdev, R_AX_CSR_MODE + 2, B_AX_BT_CNT_RST >> 16);\n\tif (rtwdev->chip->chip_id != RTL8851B)\n\t\trtw89_write8_clr(rtwdev, R_AX_TRXPTCL_RESP_0 + 3, B_AX_RSP_CHK_BTCCA >> 24);\n\n\tval16 = rtw89_read16(rtwdev, R_AX_CCA_CFG_0);\n\tval16 = (val16 | B_AX_BTCCA_EN) & ~B_AX_BTCCA_BRK_TXOP_EN;\n\trtw89_write16(rtwdev, R_AX_CCA_CFG_0, val16);\n\n\tret = rtw89_mac_read_lte(rtwdev, R_AX_LTE_SW_CFG_2, &val32);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"Read R_AX_LTE_SW_CFG_2 fail!\\n\");\n\t\treturn ret;\n\t}\n\tval32 = val32 & B_AX_WL_RX_CTRL;\n\tret = rtw89_mac_write_lte(rtwdev, R_AX_LTE_SW_CFG_2, val32);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"Write R_AX_LTE_SW_CFG_2 fail!\\n\");\n\t\treturn ret;\n\t}\n\n\tswitch (coex->pta_mode) {\n\tcase RTW89_MAC_AX_COEX_RTK_MODE:\n\t\tval = rtw89_read8(rtwdev, R_AX_GPIO_MUXCFG);\n\t\tval &= ~B_AX_BTMODE_MASK;\n\t\tval |= FIELD_PREP(B_AX_BTMODE_MASK, MAC_AX_BT_MODE_0_3);\n\t\trtw89_write8(rtwdev, R_AX_GPIO_MUXCFG, val);\n\n\t\tval = rtw89_read8(rtwdev, R_AX_TDMA_MODE);\n\t\trtw89_write8(rtwdev, R_AX_TDMA_MODE, val | B_AX_RTK_BT_ENABLE);\n\n\t\tval = rtw89_read8(rtwdev, R_AX_BT_COEX_CFG_5);\n\t\tval &= ~B_AX_BT_RPT_SAMPLE_RATE_MASK;\n\t\tval |= FIELD_PREP(B_AX_BT_RPT_SAMPLE_RATE_MASK, MAC_AX_RTK_RATE);\n\t\trtw89_write8(rtwdev, R_AX_BT_COEX_CFG_5, val);\n\t\tbreak;\n\tcase RTW89_MAC_AX_COEX_CSR_MODE:\n\t\tval = rtw89_read8(rtwdev, R_AX_GPIO_MUXCFG);\n\t\tval &= ~B_AX_BTMODE_MASK;\n\t\tval |= FIELD_PREP(B_AX_BTMODE_MASK, MAC_AX_BT_MODE_2);\n\t\trtw89_write8(rtwdev, R_AX_GPIO_MUXCFG, val);\n\n\t\tval16 = rtw89_read16(rtwdev, R_AX_CSR_MODE);\n\t\tval16 &= ~B_AX_BT_PRI_DETECT_TO_MASK;\n\t\tval16 |= FIELD_PREP(B_AX_BT_PRI_DETECT_TO_MASK, MAC_AX_CSR_PRI_TO);\n\t\tval16 &= ~B_AX_BT_TRX_INIT_DETECT_MASK;\n\t\tval16 |= FIELD_PREP(B_AX_BT_TRX_INIT_DETECT_MASK, MAC_AX_CSR_TRX_TO);\n\t\tval16 &= ~B_AX_BT_STAT_DELAY_MASK;\n\t\tval16 |= FIELD_PREP(B_AX_BT_STAT_DELAY_MASK, MAC_AX_CSR_DELAY);\n\t\tval16 |= B_AX_ENHANCED_BT;\n\t\trtw89_write16(rtwdev, R_AX_CSR_MODE, val16);\n\n\t\trtw89_write8(rtwdev, R_AX_BT_COEX_CFG_2, MAC_AX_CSR_RATE);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (coex->direction) {\n\tcase RTW89_MAC_AX_COEX_INNER:\n\t\tval = rtw89_read8(rtwdev, R_AX_GPIO_MUXCFG + 1);\n\t\tval = (val & ~BIT(2)) | BIT(1);\n\t\trtw89_write8(rtwdev, R_AX_GPIO_MUXCFG + 1, val);\n\t\tbreak;\n\tcase RTW89_MAC_AX_COEX_OUTPUT:\n\t\tval = rtw89_read8(rtwdev, R_AX_GPIO_MUXCFG + 1);\n\t\tval = val | BIT(1) | BIT(0);\n\t\trtw89_write8(rtwdev, R_AX_GPIO_MUXCFG + 1, val);\n\t\tbreak;\n\tcase RTW89_MAC_AX_COEX_INPUT:\n\t\tval = rtw89_read8(rtwdev, R_AX_GPIO_MUXCFG + 1);\n\t\tval = val & ~(BIT(2) | BIT(1));\n\t\trtw89_write8(rtwdev, R_AX_GPIO_MUXCFG + 1, val);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rtw89_mac_coex_init);\n\nint rtw89_mac_coex_init_v1(struct rtw89_dev *rtwdev,\n\t\t\t   const struct rtw89_mac_ax_coex *coex)\n{\n\trtw89_write32_set(rtwdev, R_AX_BTC_CFG,\n\t\t\t  B_AX_BTC_EN | B_AX_BTG_LNA1_GAIN_SEL);\n\trtw89_write32_set(rtwdev, R_AX_BT_CNT_CFG, B_AX_BT_CNT_EN);\n\trtw89_write16_set(rtwdev, R_AX_CCA_CFG_0, B_AX_BTCCA_EN);\n\trtw89_write16_clr(rtwdev, R_AX_CCA_CFG_0, B_AX_BTCCA_BRK_TXOP_EN);\n\n\tswitch (coex->pta_mode) {\n\tcase RTW89_MAC_AX_COEX_RTK_MODE:\n\t\trtw89_write32_mask(rtwdev, R_AX_BTC_CFG, B_AX_BTC_MODE_MASK,\n\t\t\t\t   MAC_AX_RTK_MODE);\n\t\trtw89_write32_mask(rtwdev, R_AX_RTK_MODE_CFG_V1,\n\t\t\t\t   B_AX_SAMPLE_CLK_MASK, MAC_AX_RTK_RATE);\n\t\tbreak;\n\tcase RTW89_MAC_AX_COEX_CSR_MODE:\n\t\trtw89_write32_mask(rtwdev, R_AX_BTC_CFG, B_AX_BTC_MODE_MASK,\n\t\t\t\t   MAC_AX_CSR_MODE);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rtw89_mac_coex_init_v1);\n\nint rtw89_mac_cfg_gnt(struct rtw89_dev *rtwdev,\n\t\t      const struct rtw89_mac_ax_coex_gnt *gnt_cfg)\n{\n\tu32 val = 0, ret;\n\n\tif (gnt_cfg->band[0].gnt_bt)\n\t\tval |= B_AX_GNT_BT_RFC_S0_SW_VAL | B_AX_GNT_BT_BB_S0_SW_VAL;\n\n\tif (gnt_cfg->band[0].gnt_bt_sw_en)\n\t\tval |= B_AX_GNT_BT_RFC_S0_SW_CTRL | B_AX_GNT_BT_BB_S0_SW_CTRL;\n\n\tif (gnt_cfg->band[0].gnt_wl)\n\t\tval |= B_AX_GNT_WL_RFC_S0_SW_VAL | B_AX_GNT_WL_BB_S0_SW_VAL;\n\n\tif (gnt_cfg->band[0].gnt_wl_sw_en)\n\t\tval |= B_AX_GNT_WL_RFC_S0_SW_CTRL | B_AX_GNT_WL_BB_S0_SW_CTRL;\n\n\tif (gnt_cfg->band[1].gnt_bt)\n\t\tval |= B_AX_GNT_BT_RFC_S1_SW_VAL | B_AX_GNT_BT_BB_S1_SW_VAL;\n\n\tif (gnt_cfg->band[1].gnt_bt_sw_en)\n\t\tval |= B_AX_GNT_BT_RFC_S1_SW_CTRL | B_AX_GNT_BT_BB_S1_SW_CTRL;\n\n\tif (gnt_cfg->band[1].gnt_wl)\n\t\tval |= B_AX_GNT_WL_RFC_S1_SW_VAL | B_AX_GNT_WL_BB_S1_SW_VAL;\n\n\tif (gnt_cfg->band[1].gnt_wl_sw_en)\n\t\tval |= B_AX_GNT_WL_RFC_S1_SW_CTRL | B_AX_GNT_WL_BB_S1_SW_CTRL;\n\n\tret = rtw89_mac_write_lte(rtwdev, R_AX_LTE_SW_CFG_1, val);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"Write LTE fail!\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rtw89_mac_cfg_gnt);\n\nint rtw89_mac_cfg_gnt_v1(struct rtw89_dev *rtwdev,\n\t\t\t const struct rtw89_mac_ax_coex_gnt *gnt_cfg)\n{\n\tu32 val = 0;\n\n\tif (gnt_cfg->band[0].gnt_bt)\n\t\tval |= B_AX_GNT_BT_RFC_S0_VAL | B_AX_GNT_BT_RX_VAL |\n\t\t       B_AX_GNT_BT_TX_VAL;\n\telse\n\t\tval |= B_AX_WL_ACT_VAL;\n\n\tif (gnt_cfg->band[0].gnt_bt_sw_en)\n\t\tval |= B_AX_GNT_BT_RFC_S0_SWCTRL | B_AX_GNT_BT_RX_SWCTRL |\n\t\t       B_AX_GNT_BT_TX_SWCTRL | B_AX_WL_ACT_SWCTRL;\n\n\tif (gnt_cfg->band[0].gnt_wl)\n\t\tval |= B_AX_GNT_WL_RFC_S0_VAL | B_AX_GNT_WL_RX_VAL |\n\t\t       B_AX_GNT_WL_TX_VAL | B_AX_GNT_WL_BB_VAL;\n\n\tif (gnt_cfg->band[0].gnt_wl_sw_en)\n\t\tval |= B_AX_GNT_WL_RFC_S0_SWCTRL | B_AX_GNT_WL_RX_SWCTRL |\n\t\t       B_AX_GNT_WL_TX_SWCTRL | B_AX_GNT_WL_BB_SWCTRL;\n\n\tif (gnt_cfg->band[1].gnt_bt)\n\t\tval |= B_AX_GNT_BT_RFC_S1_VAL | B_AX_GNT_BT_RX_VAL |\n\t\t       B_AX_GNT_BT_TX_VAL;\n\telse\n\t\tval |= B_AX_WL_ACT_VAL;\n\n\tif (gnt_cfg->band[1].gnt_bt_sw_en)\n\t\tval |= B_AX_GNT_BT_RFC_S1_SWCTRL | B_AX_GNT_BT_RX_SWCTRL |\n\t\t       B_AX_GNT_BT_TX_SWCTRL | B_AX_WL_ACT_SWCTRL;\n\n\tif (gnt_cfg->band[1].gnt_wl)\n\t\tval |= B_AX_GNT_WL_RFC_S1_VAL | B_AX_GNT_WL_RX_VAL |\n\t\t       B_AX_GNT_WL_TX_VAL | B_AX_GNT_WL_BB_VAL;\n\n\tif (gnt_cfg->band[1].gnt_wl_sw_en)\n\t\tval |= B_AX_GNT_WL_RFC_S1_SWCTRL | B_AX_GNT_WL_RX_SWCTRL |\n\t\t       B_AX_GNT_WL_TX_SWCTRL | B_AX_GNT_WL_BB_SWCTRL;\n\n\trtw89_write32(rtwdev, R_AX_GNT_SW_CTRL, val);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rtw89_mac_cfg_gnt_v1);\n\nint rtw89_mac_cfg_plt(struct rtw89_dev *rtwdev, struct rtw89_mac_ax_plt *plt)\n{\n\tu32 reg;\n\tu16 val;\n\tint ret;\n\n\tret = rtw89_mac_check_mac_en(rtwdev, plt->band, RTW89_CMAC_SEL);\n\tif (ret)\n\t\treturn ret;\n\n\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_BT_PLT, plt->band);\n\tval = (plt->tx & RTW89_MAC_AX_PLT_LTE_RX ? B_AX_TX_PLT_GNT_LTE_RX : 0) |\n\t      (plt->tx & RTW89_MAC_AX_PLT_GNT_BT_TX ? B_AX_TX_PLT_GNT_BT_TX : 0) |\n\t      (plt->tx & RTW89_MAC_AX_PLT_GNT_BT_RX ? B_AX_TX_PLT_GNT_BT_RX : 0) |\n\t      (plt->tx & RTW89_MAC_AX_PLT_GNT_WL ? B_AX_TX_PLT_GNT_WL : 0) |\n\t      (plt->rx & RTW89_MAC_AX_PLT_LTE_RX ? B_AX_RX_PLT_GNT_LTE_RX : 0) |\n\t      (plt->rx & RTW89_MAC_AX_PLT_GNT_BT_TX ? B_AX_RX_PLT_GNT_BT_TX : 0) |\n\t      (plt->rx & RTW89_MAC_AX_PLT_GNT_BT_RX ? B_AX_RX_PLT_GNT_BT_RX : 0) |\n\t      (plt->rx & RTW89_MAC_AX_PLT_GNT_WL ? B_AX_RX_PLT_GNT_WL : 0) |\n\t      B_AX_PLT_EN;\n\trtw89_write16(rtwdev, reg, val);\n\n\treturn 0;\n}\n\nvoid rtw89_mac_cfg_sb(struct rtw89_dev *rtwdev, u32 val)\n{\n\tu32 fw_sb;\n\n\tfw_sb = rtw89_read32(rtwdev, R_AX_SCOREBOARD);\n\tfw_sb = FIELD_GET(B_MAC_AX_SB_FW_MASK, fw_sb);\n\tfw_sb = fw_sb & ~B_MAC_AX_BTGS1_NOTIFY;\n\tif (!test_bit(RTW89_FLAG_POWERON, rtwdev->flags))\n\t\tfw_sb = fw_sb | MAC_AX_NOTIFY_PWR_MAJOR;\n\telse\n\t\tfw_sb = fw_sb | MAC_AX_NOTIFY_TP_MAJOR;\n\tval = FIELD_GET(B_MAC_AX_SB_DRV_MASK, val);\n\tval = B_AX_TOGGLE |\n\t      FIELD_PREP(B_MAC_AX_SB_DRV_MASK, val) |\n\t      FIELD_PREP(B_MAC_AX_SB_FW_MASK, fw_sb);\n\trtw89_write32(rtwdev, R_AX_SCOREBOARD, val);\n\tfsleep(1000);  \n}\n\nu32 rtw89_mac_get_sb(struct rtw89_dev *rtwdev)\n{\n\treturn rtw89_read32(rtwdev, R_AX_SCOREBOARD);\n}\n\nint rtw89_mac_cfg_ctrl_path(struct rtw89_dev *rtwdev, bool wl)\n{\n\tu8 val = rtw89_read8(rtwdev, R_AX_SYS_SDIO_CTRL + 3);\n\n\tval = wl ? val | BIT(2) : val & ~BIT(2);\n\trtw89_write8(rtwdev, R_AX_SYS_SDIO_CTRL + 3, val);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rtw89_mac_cfg_ctrl_path);\n\nint rtw89_mac_cfg_ctrl_path_v1(struct rtw89_dev *rtwdev, bool wl)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_dm *dm = &btc->dm;\n\tstruct rtw89_mac_ax_gnt *g = dm->gnt.band;\n\tint i;\n\n\tif (wl)\n\t\treturn 0;\n\n\tfor (i = 0; i < RTW89_PHY_MAX; i++) {\n\t\tg[i].gnt_bt_sw_en = 1;\n\t\tg[i].gnt_bt = 1;\n\t\tg[i].gnt_wl_sw_en = 1;\n\t\tg[i].gnt_wl = 0;\n\t}\n\n\treturn rtw89_mac_cfg_gnt_v1(rtwdev, &dm->gnt);\n}\nEXPORT_SYMBOL(rtw89_mac_cfg_ctrl_path_v1);\n\nbool rtw89_mac_get_ctrl_path(struct rtw89_dev *rtwdev)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tu8 val = 0;\n\n\tif (chip->chip_id == RTL8852C)\n\t\treturn false;\n\telse if (chip->chip_id == RTL8852A || chip->chip_id == RTL8852B)\n\t\tval = rtw89_read8_mask(rtwdev, R_AX_SYS_SDIO_CTRL + 3,\n\t\t\t\t       B_AX_LTE_MUX_CTRL_PATH >> 24);\n\n\treturn !!val;\n}\n\nu16 rtw89_mac_get_plt_cnt(struct rtw89_dev *rtwdev, u8 band)\n{\n\tu32 reg;\n\tu16 cnt;\n\n\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_BT_PLT, band);\n\tcnt = rtw89_read32_mask(rtwdev, reg, B_AX_BT_PLT_PKT_CNT_MASK);\n\trtw89_write16_set(rtwdev, reg, B_AX_BT_PLT_RST);\n\n\treturn cnt;\n}\n\nstatic void rtw89_mac_bfee_standby_timer(struct rtw89_dev *rtwdev, u8 mac_idx,\n\t\t\t\t\t bool keep)\n{\n\tu32 reg;\n\n\trtw89_debug(rtwdev, RTW89_DBG_BF, \"set bfee standby_timer to %d\\n\", keep);\n\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_BFMEE_RESP_OPTION, mac_idx);\n\tif (keep) {\n\t\tset_bit(RTW89_FLAG_BFEE_TIMER_KEEP, rtwdev->flags);\n\t\trtw89_write32_mask(rtwdev, reg, B_AX_BFMEE_BFRP_RX_STANDBY_TIMER_MASK,\n\t\t\t\t   BFRP_RX_STANDBY_TIMER_KEEP);\n\t} else {\n\t\tclear_bit(RTW89_FLAG_BFEE_TIMER_KEEP, rtwdev->flags);\n\t\trtw89_write32_mask(rtwdev, reg, B_AX_BFMEE_BFRP_RX_STANDBY_TIMER_MASK,\n\t\t\t\t   BFRP_RX_STANDBY_TIMER_RELEASE);\n\t}\n}\n\nstatic void rtw89_mac_bfee_ctrl(struct rtw89_dev *rtwdev, u8 mac_idx, bool en)\n{\n\tu32 reg;\n\tu32 mask = B_AX_BFMEE_HT_NDPA_EN | B_AX_BFMEE_VHT_NDPA_EN |\n\t\t   B_AX_BFMEE_HE_NDPA_EN;\n\n\trtw89_debug(rtwdev, RTW89_DBG_BF, \"set bfee ndpa_en to %d\\n\", en);\n\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_BFMEE_RESP_OPTION, mac_idx);\n\tif (en) {\n\t\tset_bit(RTW89_FLAG_BFEE_EN, rtwdev->flags);\n\t\trtw89_write32_set(rtwdev, reg, mask);\n\t} else {\n\t\tclear_bit(RTW89_FLAG_BFEE_EN, rtwdev->flags);\n\t\trtw89_write32_clr(rtwdev, reg, mask);\n\t}\n}\n\nstatic int rtw89_mac_init_bfee(struct rtw89_dev *rtwdev, u8 mac_idx)\n{\n\tu32 reg;\n\tu32 val32;\n\tint ret;\n\n\tret = rtw89_mac_check_mac_en(rtwdev, mac_idx, RTW89_CMAC_SEL);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\t \n\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_BFMER_CTRL_0, mac_idx);\n\trtw89_write32_set(rtwdev, reg, B_AX_BFMER_NDP_BFEN);\n\n\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_TRXPTCL_RESP_CSI_RRSC, mac_idx);\n\trtw89_write32(rtwdev, reg, CSI_RRSC_BMAP);\n\n\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_BFMEE_RESP_OPTION, mac_idx);\n\tval32 = FIELD_PREP(B_AX_BFMEE_NDP_RX_STANDBY_TIMER_MASK, NDP_RX_STANDBY_TIMER);\n\trtw89_write32(rtwdev, reg, val32);\n\trtw89_mac_bfee_standby_timer(rtwdev, mac_idx, true);\n\trtw89_mac_bfee_ctrl(rtwdev, mac_idx, true);\n\n\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_TRXPTCL_RESP_CSI_CTRL_0, mac_idx);\n\trtw89_write32_set(rtwdev, reg, B_AX_BFMEE_BFPARAM_SEL |\n\t\t\t\t       B_AX_BFMEE_USE_NSTS |\n\t\t\t\t       B_AX_BFMEE_CSI_GID_SEL |\n\t\t\t\t       B_AX_BFMEE_CSI_FORCE_RETE_EN);\n\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_TRXPTCL_RESP_CSI_RATE, mac_idx);\n\trtw89_write32(rtwdev, reg,\n\t\t      u32_encode_bits(CSI_INIT_RATE_HT, B_AX_BFMEE_HT_CSI_RATE_MASK) |\n\t\t      u32_encode_bits(CSI_INIT_RATE_VHT, B_AX_BFMEE_VHT_CSI_RATE_MASK) |\n\t\t      u32_encode_bits(CSI_INIT_RATE_HE, B_AX_BFMEE_HE_CSI_RATE_MASK));\n\n\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_CSIRPT_OPTION, mac_idx);\n\trtw89_write32_set(rtwdev, reg,\n\t\t\t  B_AX_CSIPRT_VHTSU_AID_EN | B_AX_CSIPRT_HESU_AID_EN);\n\n\treturn 0;\n}\n\nstatic int rtw89_mac_set_csi_para_reg(struct rtw89_dev *rtwdev,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      struct ieee80211_sta *sta)\n{\n\tstruct rtw89_vif *rtwvif = (struct rtw89_vif *)vif->drv_priv;\n\tu8 mac_idx = rtwvif->mac_idx;\n\tu8 nc = 1, nr = 3, ng = 0, cb = 1, cs = 1, ldpc_en = 1, stbc_en = 1;\n\tu8 port_sel = rtwvif->port;\n\tu8 sound_dim = 3, t;\n\tu8 *phy_cap = sta->deflink.he_cap.he_cap_elem.phy_cap_info;\n\tu32 reg;\n\tu16 val;\n\tint ret;\n\n\tret = rtw89_mac_check_mac_en(rtwdev, mac_idx, RTW89_CMAC_SEL);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((phy_cap[3] & IEEE80211_HE_PHY_CAP3_SU_BEAMFORMER) ||\n\t    (phy_cap[4] & IEEE80211_HE_PHY_CAP4_MU_BEAMFORMER)) {\n\t\tldpc_en &= !!(phy_cap[1] & IEEE80211_HE_PHY_CAP1_LDPC_CODING_IN_PAYLOAD);\n\t\tstbc_en &= !!(phy_cap[2] & IEEE80211_HE_PHY_CAP2_STBC_RX_UNDER_80MHZ);\n\t\tt = FIELD_GET(IEEE80211_HE_PHY_CAP5_BEAMFORMEE_NUM_SND_DIM_UNDER_80MHZ_MASK,\n\t\t\t      phy_cap[5]);\n\t\tsound_dim = min(sound_dim, t);\n\t}\n\tif ((sta->deflink.vht_cap.cap & IEEE80211_VHT_CAP_MU_BEAMFORMER_CAPABLE) ||\n\t    (sta->deflink.vht_cap.cap & IEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE)) {\n\t\tldpc_en &= !!(sta->deflink.vht_cap.cap & IEEE80211_VHT_CAP_RXLDPC);\n\t\tstbc_en &= !!(sta->deflink.vht_cap.cap & IEEE80211_VHT_CAP_RXSTBC_MASK);\n\t\tt = FIELD_GET(IEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_MASK,\n\t\t\t      sta->deflink.vht_cap.cap);\n\t\tsound_dim = min(sound_dim, t);\n\t}\n\tnc = min(nc, sound_dim);\n\tnr = min(nr, sound_dim);\n\n\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_TRXPTCL_RESP_CSI_CTRL_0, mac_idx);\n\trtw89_write32_set(rtwdev, reg, B_AX_BFMEE_BFPARAM_SEL);\n\n\tval = FIELD_PREP(B_AX_BFMEE_CSIINFO0_NC_MASK, nc) |\n\t      FIELD_PREP(B_AX_BFMEE_CSIINFO0_NR_MASK, nr) |\n\t      FIELD_PREP(B_AX_BFMEE_CSIINFO0_NG_MASK, ng) |\n\t      FIELD_PREP(B_AX_BFMEE_CSIINFO0_CB_MASK, cb) |\n\t      FIELD_PREP(B_AX_BFMEE_CSIINFO0_CS_MASK, cs) |\n\t      FIELD_PREP(B_AX_BFMEE_CSIINFO0_LDPC_EN, ldpc_en) |\n\t      FIELD_PREP(B_AX_BFMEE_CSIINFO0_STBC_EN, stbc_en);\n\n\tif (port_sel == 0)\n\t\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_TRXPTCL_RESP_CSI_CTRL_0, mac_idx);\n\telse\n\t\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_TRXPTCL_RESP_CSI_CTRL_1, mac_idx);\n\n\trtw89_write16(rtwdev, reg, val);\n\n\treturn 0;\n}\n\nstatic int rtw89_mac_csi_rrsc(struct rtw89_dev *rtwdev,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      struct ieee80211_sta *sta)\n{\n\tstruct rtw89_vif *rtwvif = (struct rtw89_vif *)vif->drv_priv;\n\tu32 rrsc = BIT(RTW89_MAC_BF_RRSC_6M) | BIT(RTW89_MAC_BF_RRSC_24M);\n\tu32 reg;\n\tu8 mac_idx = rtwvif->mac_idx;\n\tint ret;\n\n\tret = rtw89_mac_check_mac_en(rtwdev, mac_idx, RTW89_CMAC_SEL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (sta->deflink.he_cap.has_he) {\n\t\trrsc |= (BIT(RTW89_MAC_BF_RRSC_HE_MSC0) |\n\t\t\t BIT(RTW89_MAC_BF_RRSC_HE_MSC3) |\n\t\t\t BIT(RTW89_MAC_BF_RRSC_HE_MSC5));\n\t}\n\tif (sta->deflink.vht_cap.vht_supported) {\n\t\trrsc |= (BIT(RTW89_MAC_BF_RRSC_VHT_MSC0) |\n\t\t\t BIT(RTW89_MAC_BF_RRSC_VHT_MSC3) |\n\t\t\t BIT(RTW89_MAC_BF_RRSC_VHT_MSC5));\n\t}\n\tif (sta->deflink.ht_cap.ht_supported) {\n\t\trrsc |= (BIT(RTW89_MAC_BF_RRSC_HT_MSC0) |\n\t\t\t BIT(RTW89_MAC_BF_RRSC_HT_MSC3) |\n\t\t\t BIT(RTW89_MAC_BF_RRSC_HT_MSC5));\n\t}\n\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_TRXPTCL_RESP_CSI_CTRL_0, mac_idx);\n\trtw89_write32_set(rtwdev, reg, B_AX_BFMEE_BFPARAM_SEL);\n\trtw89_write32_clr(rtwdev, reg, B_AX_BFMEE_CSI_FORCE_RETE_EN);\n\trtw89_write32(rtwdev,\n\t\t      rtw89_mac_reg_by_idx(rtwdev, R_AX_TRXPTCL_RESP_CSI_RRSC, mac_idx),\n\t\t      rrsc);\n\n\treturn 0;\n}\n\nvoid rtw89_mac_bf_assoc(struct rtw89_dev *rtwdev, struct ieee80211_vif *vif,\n\t\t\tstruct ieee80211_sta *sta)\n{\n\tstruct rtw89_vif *rtwvif = (struct rtw89_vif *)vif->drv_priv;\n\n\tif (rtw89_sta_has_beamformer_cap(sta)) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_BF,\n\t\t\t    \"initialize bfee for new association\\n\");\n\t\trtw89_mac_init_bfee(rtwdev, rtwvif->mac_idx);\n\t\trtw89_mac_set_csi_para_reg(rtwdev, vif, sta);\n\t\trtw89_mac_csi_rrsc(rtwdev, vif, sta);\n\t}\n}\n\nvoid rtw89_mac_bf_disassoc(struct rtw89_dev *rtwdev, struct ieee80211_vif *vif,\n\t\t\t   struct ieee80211_sta *sta)\n{\n\tstruct rtw89_vif *rtwvif = (struct rtw89_vif *)vif->drv_priv;\n\n\trtw89_mac_bfee_ctrl(rtwdev, rtwvif->mac_idx, false);\n}\n\nvoid rtw89_mac_bf_set_gid_table(struct rtw89_dev *rtwdev, struct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_bss_conf *conf)\n{\n\tstruct rtw89_vif *rtwvif = (struct rtw89_vif *)vif->drv_priv;\n\tu8 mac_idx = rtwvif->mac_idx;\n\t__le32 *p;\n\n\trtw89_debug(rtwdev, RTW89_DBG_BF, \"update bf GID table\\n\");\n\n\tp = (__le32 *)conf->mu_group.membership;\n\trtw89_write32(rtwdev,\n\t\t      rtw89_mac_reg_by_idx(rtwdev, R_AX_GID_POSITION_EN0, mac_idx),\n\t\t      le32_to_cpu(p[0]));\n\trtw89_write32(rtwdev,\n\t\t      rtw89_mac_reg_by_idx(rtwdev, R_AX_GID_POSITION_EN1, mac_idx),\n\t\t      le32_to_cpu(p[1]));\n\n\tp = (__le32 *)conf->mu_group.position;\n\trtw89_write32(rtwdev, rtw89_mac_reg_by_idx(rtwdev, R_AX_GID_POSITION0, mac_idx),\n\t\t      le32_to_cpu(p[0]));\n\trtw89_write32(rtwdev, rtw89_mac_reg_by_idx(rtwdev, R_AX_GID_POSITION1, mac_idx),\n\t\t      le32_to_cpu(p[1]));\n\trtw89_write32(rtwdev, rtw89_mac_reg_by_idx(rtwdev, R_AX_GID_POSITION2, mac_idx),\n\t\t      le32_to_cpu(p[2]));\n\trtw89_write32(rtwdev, rtw89_mac_reg_by_idx(rtwdev, R_AX_GID_POSITION3, mac_idx),\n\t\t      le32_to_cpu(p[3]));\n}\n\nstruct rtw89_mac_bf_monitor_iter_data {\n\tstruct rtw89_dev *rtwdev;\n\tstruct ieee80211_sta *down_sta;\n\tint count;\n};\n\nstatic\nvoid rtw89_mac_bf_monitor_calc_iter(void *data, struct ieee80211_sta *sta)\n{\n\tstruct rtw89_mac_bf_monitor_iter_data *iter_data =\n\t\t\t\t(struct rtw89_mac_bf_monitor_iter_data *)data;\n\tstruct ieee80211_sta *down_sta = iter_data->down_sta;\n\tint *count = &iter_data->count;\n\n\tif (down_sta == sta)\n\t\treturn;\n\n\tif (rtw89_sta_has_beamformer_cap(sta))\n\t\t(*count)++;\n}\n\nvoid rtw89_mac_bf_monitor_calc(struct rtw89_dev *rtwdev,\n\t\t\t       struct ieee80211_sta *sta, bool disconnect)\n{\n\tstruct rtw89_mac_bf_monitor_iter_data data;\n\n\tdata.rtwdev = rtwdev;\n\tdata.down_sta = disconnect ? sta : NULL;\n\tdata.count = 0;\n\tieee80211_iterate_stations_atomic(rtwdev->hw,\n\t\t\t\t\t  rtw89_mac_bf_monitor_calc_iter,\n\t\t\t\t\t  &data);\n\n\trtw89_debug(rtwdev, RTW89_DBG_BF, \"bfee STA count=%d\\n\", data.count);\n\tif (data.count)\n\t\tset_bit(RTW89_FLAG_BFEE_MON, rtwdev->flags);\n\telse\n\t\tclear_bit(RTW89_FLAG_BFEE_MON, rtwdev->flags);\n}\n\nvoid _rtw89_mac_bf_monitor_track(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_traffic_stats *stats = &rtwdev->stats;\n\tstruct rtw89_vif *rtwvif;\n\tbool en = stats->tx_tfc_lv <= stats->rx_tfc_lv;\n\tbool old = test_bit(RTW89_FLAG_BFEE_EN, rtwdev->flags);\n\tbool keep_timer = true;\n\tbool old_keep_timer;\n\n\told_keep_timer = test_bit(RTW89_FLAG_BFEE_TIMER_KEEP, rtwdev->flags);\n\n\tif (stats->tx_tfc_lv <= RTW89_TFC_LOW && stats->rx_tfc_lv <= RTW89_TFC_LOW)\n\t\tkeep_timer = false;\n\n\tif (keep_timer != old_keep_timer) {\n\t\trtw89_for_each_rtwvif(rtwdev, rtwvif)\n\t\t\trtw89_mac_bfee_standby_timer(rtwdev, rtwvif->mac_idx,\n\t\t\t\t\t\t     keep_timer);\n\t}\n\n\tif (en == old)\n\t\treturn;\n\n\trtw89_for_each_rtwvif(rtwdev, rtwvif)\n\t\trtw89_mac_bfee_ctrl(rtwdev, rtwvif->mac_idx, en);\n}\n\nstatic int\n__rtw89_mac_set_tx_time(struct rtw89_dev *rtwdev, struct rtw89_sta *rtwsta,\n\t\t\tu32 tx_time)\n{\n#define MAC_AX_DFLT_TX_TIME 5280\n\tu8 mac_idx = rtwsta->rtwvif->mac_idx;\n\tu32 max_tx_time = tx_time == 0 ? MAC_AX_DFLT_TX_TIME : tx_time;\n\tu32 reg;\n\tint ret = 0;\n\n\tif (rtwsta->cctl_tx_time) {\n\t\trtwsta->ampdu_max_time = (max_tx_time - 512) >> 9;\n\t\tret = rtw89_fw_h2c_txtime_cmac_tbl(rtwdev, rtwsta);\n\t} else {\n\t\tret = rtw89_mac_check_mac_en(rtwdev, mac_idx, RTW89_CMAC_SEL);\n\t\tif (ret) {\n\t\t\trtw89_warn(rtwdev, \"failed to check cmac in set txtime\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_AMPDU_AGG_LIMIT, mac_idx);\n\t\trtw89_write32_mask(rtwdev, reg, B_AX_AMPDU_MAX_TIME_MASK,\n\t\t\t\t   max_tx_time >> 5);\n\t}\n\n\treturn ret;\n}\n\nint rtw89_mac_set_tx_time(struct rtw89_dev *rtwdev, struct rtw89_sta *rtwsta,\n\t\t\t  bool resume, u32 tx_time)\n{\n\tint ret = 0;\n\n\tif (!resume) {\n\t\trtwsta->cctl_tx_time = true;\n\t\tret = __rtw89_mac_set_tx_time(rtwdev, rtwsta, tx_time);\n\t} else {\n\t\tret = __rtw89_mac_set_tx_time(rtwdev, rtwsta, tx_time);\n\t\trtwsta->cctl_tx_time = false;\n\t}\n\n\treturn ret;\n}\n\nint rtw89_mac_get_tx_time(struct rtw89_dev *rtwdev, struct rtw89_sta *rtwsta,\n\t\t\t  u32 *tx_time)\n{\n\tu8 mac_idx = rtwsta->rtwvif->mac_idx;\n\tu32 reg;\n\tint ret = 0;\n\n\tif (rtwsta->cctl_tx_time) {\n\t\t*tx_time = (rtwsta->ampdu_max_time + 1) << 9;\n\t} else {\n\t\tret = rtw89_mac_check_mac_en(rtwdev, mac_idx, RTW89_CMAC_SEL);\n\t\tif (ret) {\n\t\t\trtw89_warn(rtwdev, \"failed to check cmac in tx_time\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_AMPDU_AGG_LIMIT, mac_idx);\n\t\t*tx_time = rtw89_read32_mask(rtwdev, reg, B_AX_AMPDU_MAX_TIME_MASK) << 5;\n\t}\n\n\treturn ret;\n}\n\nint rtw89_mac_set_tx_retry_limit(struct rtw89_dev *rtwdev,\n\t\t\t\t struct rtw89_sta *rtwsta,\n\t\t\t\t bool resume, u8 tx_retry)\n{\n\tint ret = 0;\n\n\trtwsta->data_tx_cnt_lmt = tx_retry;\n\n\tif (!resume) {\n\t\trtwsta->cctl_tx_retry_limit = true;\n\t\tret = rtw89_fw_h2c_txtime_cmac_tbl(rtwdev, rtwsta);\n\t} else {\n\t\tret = rtw89_fw_h2c_txtime_cmac_tbl(rtwdev, rtwsta);\n\t\trtwsta->cctl_tx_retry_limit = false;\n\t}\n\n\treturn ret;\n}\n\nint rtw89_mac_get_tx_retry_limit(struct rtw89_dev *rtwdev,\n\t\t\t\t struct rtw89_sta *rtwsta, u8 *tx_retry)\n{\n\tu8 mac_idx = rtwsta->rtwvif->mac_idx;\n\tu32 reg;\n\tint ret = 0;\n\n\tif (rtwsta->cctl_tx_retry_limit) {\n\t\t*tx_retry = rtwsta->data_tx_cnt_lmt;\n\t} else {\n\t\tret = rtw89_mac_check_mac_en(rtwdev, mac_idx, RTW89_CMAC_SEL);\n\t\tif (ret) {\n\t\t\trtw89_warn(rtwdev, \"failed to check cmac in rty_lmt\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_TXCNT, mac_idx);\n\t\t*tx_retry = rtw89_read32_mask(rtwdev, reg, B_AX_L_TXCNT_LMT_MASK);\n\t}\n\n\treturn ret;\n}\n\nint rtw89_mac_set_hw_muedca_ctrl(struct rtw89_dev *rtwdev,\n\t\t\t\t struct rtw89_vif *rtwvif, bool en)\n{\n\tu8 mac_idx = rtwvif->mac_idx;\n\tu16 set = B_AX_MUEDCA_EN_0 | B_AX_SET_MUEDCATIMER_TF_0;\n\tu32 reg;\n\tu32 ret;\n\n\tret = rtw89_mac_check_mac_en(rtwdev, mac_idx, RTW89_CMAC_SEL);\n\tif (ret)\n\t\treturn ret;\n\n\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_MUEDCA_EN, mac_idx);\n\tif (en)\n\t\trtw89_write16_set(rtwdev, reg, set);\n\telse\n\t\trtw89_write16_clr(rtwdev, reg, set);\n\n\treturn 0;\n}\n\nint rtw89_mac_write_xtal_si(struct rtw89_dev *rtwdev, u8 offset, u8 val, u8 mask)\n{\n\tu32 val32;\n\tint ret;\n\n\tval32 = FIELD_PREP(B_AX_WL_XTAL_SI_ADDR_MASK, offset) |\n\t\tFIELD_PREP(B_AX_WL_XTAL_SI_DATA_MASK, val) |\n\t\tFIELD_PREP(B_AX_WL_XTAL_SI_BITMASK_MASK, mask) |\n\t\tFIELD_PREP(B_AX_WL_XTAL_SI_MODE_MASK, XTAL_SI_NORMAL_WRITE) |\n\t\tFIELD_PREP(B_AX_WL_XTAL_SI_CMD_POLL, 1);\n\trtw89_write32(rtwdev, R_AX_WLAN_XTAL_SI_CTRL, val32);\n\n\tret = read_poll_timeout(rtw89_read32, val32, !(val32 & B_AX_WL_XTAL_SI_CMD_POLL),\n\t\t\t\t50, 50000, false, rtwdev, R_AX_WLAN_XTAL_SI_CTRL);\n\tif (ret) {\n\t\trtw89_warn(rtwdev, \"xtal si not ready(W): offset=%x val=%x mask=%x\\n\",\n\t\t\t   offset, val, mask);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rtw89_mac_write_xtal_si);\n\nint rtw89_mac_read_xtal_si(struct rtw89_dev *rtwdev, u8 offset, u8 *val)\n{\n\tu32 val32;\n\tint ret;\n\n\tval32 = FIELD_PREP(B_AX_WL_XTAL_SI_ADDR_MASK, offset) |\n\t\tFIELD_PREP(B_AX_WL_XTAL_SI_DATA_MASK, 0x00) |\n\t\tFIELD_PREP(B_AX_WL_XTAL_SI_BITMASK_MASK, 0x00) |\n\t\tFIELD_PREP(B_AX_WL_XTAL_SI_MODE_MASK, XTAL_SI_NORMAL_READ) |\n\t\tFIELD_PREP(B_AX_WL_XTAL_SI_CMD_POLL, 1);\n\trtw89_write32(rtwdev, R_AX_WLAN_XTAL_SI_CTRL, val32);\n\n\tret = read_poll_timeout(rtw89_read32, val32, !(val32 & B_AX_WL_XTAL_SI_CMD_POLL),\n\t\t\t\t50, 50000, false, rtwdev, R_AX_WLAN_XTAL_SI_CTRL);\n\tif (ret) {\n\t\trtw89_warn(rtwdev, \"xtal si not ready(R): offset=%x\\n\", offset);\n\t\treturn ret;\n\t}\n\n\t*val = rtw89_read8(rtwdev, R_AX_WLAN_XTAL_SI_CTRL + 1);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rtw89_mac_read_xtal_si);\n\nstatic\nvoid rtw89_mac_pkt_drop_sta(struct rtw89_dev *rtwdev, struct rtw89_sta *rtwsta)\n{\n\tstatic const enum rtw89_pkt_drop_sel sels[] = {\n\t\tRTW89_PKT_DROP_SEL_MACID_BE_ONCE,\n\t\tRTW89_PKT_DROP_SEL_MACID_BK_ONCE,\n\t\tRTW89_PKT_DROP_SEL_MACID_VI_ONCE,\n\t\tRTW89_PKT_DROP_SEL_MACID_VO_ONCE,\n\t};\n\tstruct rtw89_vif *rtwvif = rtwsta->rtwvif;\n\tstruct rtw89_pkt_drop_params params = {0};\n\tint i;\n\n\tparams.mac_band = RTW89_MAC_0;\n\tparams.macid = rtwsta->mac_id;\n\tparams.port = rtwvif->port;\n\tparams.mbssid = 0;\n\tparams.tf_trs = rtwvif->trigger;\n\n\tfor (i = 0; i < ARRAY_SIZE(sels); i++) {\n\t\tparams.sel = sels[i];\n\t\trtw89_fw_h2c_pkt_drop(rtwdev, &params);\n\t}\n}\n\nstatic void rtw89_mac_pkt_drop_vif_iter(void *data, struct ieee80211_sta *sta)\n{\n\tstruct rtw89_sta *rtwsta = (struct rtw89_sta *)sta->drv_priv;\n\tstruct rtw89_vif *rtwvif = rtwsta->rtwvif;\n\tstruct rtw89_dev *rtwdev = rtwvif->rtwdev;\n\tstruct rtw89_vif *target = data;\n\n\tif (rtwvif != target)\n\t\treturn;\n\n\trtw89_mac_pkt_drop_sta(rtwdev, rtwsta);\n}\n\nvoid rtw89_mac_pkt_drop_vif(struct rtw89_dev *rtwdev, struct rtw89_vif *rtwvif)\n{\n\tieee80211_iterate_stations_atomic(rtwdev->hw,\n\t\t\t\t\t  rtw89_mac_pkt_drop_vif_iter,\n\t\t\t\t\t  rtwvif);\n}\n\nint rtw89_mac_ptk_drop_by_band_and_wait(struct rtw89_dev *rtwdev,\n\t\t\t\t\tenum rtw89_mac_idx band)\n{\n\tstruct rtw89_pkt_drop_params params = {0};\n\tbool empty;\n\tint i, ret = 0, try_cnt = 3;\n\n\tparams.mac_band = band;\n\tparams.sel = RTW89_PKT_DROP_SEL_BAND_ONCE;\n\n\tfor (i = 0; i < try_cnt; i++) {\n\t\tret = read_poll_timeout(mac_is_txq_empty, empty, empty, 50,\n\t\t\t\t\t50000, false, rtwdev);\n\t\tif (ret && !RTW89_CHK_FW_FEATURE(NO_PACKET_DROP, &rtwdev->fw))\n\t\t\trtw89_fw_h2c_pkt_drop(rtwdev, &params);\n\t\telse\n\t\t\treturn 0;\n\t}\n\treturn ret;\n}\n\nconst struct rtw89_mac_gen_def rtw89_mac_gen_ax = {\n\t.band1_offset = RTW89_MAC_AX_BAND_REG_OFFSET,\n\t.filter_model_addr = R_AX_FILTER_MODEL_ADDR,\n\t.indir_access_addr = R_AX_INDIR_ACCESS_ENTRY,\n\t.mem_base_addrs = rtw89_mac_mem_base_addrs_ax,\n\t.rx_fltr = R_AX_RX_FLTR_OPT,\n};\nEXPORT_SYMBOL(rtw89_mac_gen_ax);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}