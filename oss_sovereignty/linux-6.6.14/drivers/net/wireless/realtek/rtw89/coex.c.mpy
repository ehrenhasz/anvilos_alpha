{
  "module_name": "coex.c",
  "hash_id": "a7d4c7fd116debef986fe724ea19899c7ccf406e7abd13ad8701cf5d474330da",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtw89/coex.c",
  "human_readable_source": "\n \n\n#include \"coex.h\"\n#include \"debug.h\"\n#include \"fw.h\"\n#include \"mac.h\"\n#include \"ps.h\"\n#include \"reg.h\"\n\n#define RTW89_COEX_VERSION 0x07000113\n#define FCXDEF_STEP 50  \n\nenum btc_fbtc_tdma_template {\n\tCXTD_OFF = 0x0,\n\tCXTD_OFF_B2,\n\tCXTD_OFF_EXT,\n\tCXTD_FIX,\n\tCXTD_PFIX,\n\tCXTD_AUTO,\n\tCXTD_PAUTO,\n\tCXTD_AUTO2,\n\tCXTD_PAUTO2,\n\tCXTD_MAX,\n};\n\nenum btc_fbtc_tdma_type {\n\tCXTDMA_OFF = 0x0,\n\tCXTDMA_FIX = 0x1,\n\tCXTDMA_AUTO = 0x2,\n\tCXTDMA_AUTO2 = 0x3,\n\tCXTDMA_MAX\n};\n\nenum btc_fbtc_tdma_rx_flow_ctrl {\n\tCXFLC_OFF = 0x0,\n\tCXFLC_NULLP = 0x1,\n\tCXFLC_QOSNULL = 0x2,\n\tCXFLC_CTS = 0x3,\n\tCXFLC_MAX\n};\n\nenum btc_fbtc_tdma_wlan_tx_pause {\n\tCXTPS_OFF = 0x0,   \n\tCXTPS_ON = 0x1,\n\tCXTPS_MAX\n};\n\nenum btc_mlme_state {\n\tMLME_NO_LINK,\n\tMLME_LINKING,\n\tMLME_LINKED,\n};\n\n#define FCXONESLOT_VER 1\nstruct btc_fbtc_1slot {\n\tu8 fver;\n\tu8 sid;  \n\tstruct rtw89_btc_fbtc_slot slot;\n} __packed;\n\nstatic const struct rtw89_btc_fbtc_tdma t_def[] = {\n\t[CXTD_OFF]\t= { CXTDMA_OFF,    CXFLC_OFF, CXTPS_OFF, 0, 0, 0, 0, 0},\n\t[CXTD_OFF_B2]\t= { CXTDMA_OFF,    CXFLC_OFF, CXTPS_OFF, 0, 0, 1, 0, 0},\n\t[CXTD_OFF_EXT]\t= { CXTDMA_OFF,    CXFLC_OFF, CXTPS_OFF, 0, 0, 2, 0, 0},\n\t[CXTD_FIX]\t= { CXTDMA_FIX,    CXFLC_OFF, CXTPS_OFF, 0, 0, 0, 0, 0},\n\t[CXTD_PFIX]\t= { CXTDMA_FIX,  CXFLC_NULLP,  CXTPS_ON, 0, 5, 0, 0, 0},\n\t[CXTD_AUTO]\t= { CXTDMA_AUTO,   CXFLC_OFF, CXTPS_OFF, 0, 0, 0, 0, 0},\n\t[CXTD_PAUTO]\t= { CXTDMA_AUTO, CXFLC_NULLP,  CXTPS_ON, 0, 5, 0, 0, 0},\n\t[CXTD_AUTO2]\t= {CXTDMA_AUTO2,   CXFLC_OFF, CXTPS_OFF, 0, 0, 0, 0, 0},\n\t[CXTD_PAUTO2]\t= {CXTDMA_AUTO2, CXFLC_NULLP,  CXTPS_ON, 0, 5, 0, 0, 0}\n};\n\n#define __DEF_FBTC_SLOT(__dur, __cxtbl, __cxtype) \\\n\t{ .dur = cpu_to_le16(__dur), .cxtbl = cpu_to_le32(__cxtbl), \\\n\t  .cxtype = cpu_to_le16(__cxtype),}\n\nstatic const struct rtw89_btc_fbtc_slot s_def[] = {\n\t[CXST_OFF]\t= __DEF_FBTC_SLOT(100, 0x55555555, SLOT_MIX),\n\t[CXST_B2W]\t= __DEF_FBTC_SLOT(5,   0xea5a5a5a, SLOT_ISO),\n\t[CXST_W1]\t= __DEF_FBTC_SLOT(70,  0xea5a5a5a, SLOT_ISO),\n\t[CXST_W2]\t= __DEF_FBTC_SLOT(15,  0xea5a5a5a, SLOT_ISO),\n\t[CXST_W2B]\t= __DEF_FBTC_SLOT(15,  0xea5a5a5a, SLOT_ISO),\n\t[CXST_B1]\t= __DEF_FBTC_SLOT(250, 0xe5555555, SLOT_MIX),\n\t[CXST_B2]\t= __DEF_FBTC_SLOT(7,   0xea5a5a5a, SLOT_MIX),\n\t[CXST_B3]\t= __DEF_FBTC_SLOT(5,   0xe5555555, SLOT_MIX),\n\t[CXST_B4]\t= __DEF_FBTC_SLOT(50,  0xe5555555, SLOT_MIX),\n\t[CXST_LK]\t= __DEF_FBTC_SLOT(20,  0xea5a5a5a, SLOT_ISO),\n\t[CXST_BLK]\t= __DEF_FBTC_SLOT(500, 0x55555555, SLOT_MIX),\n\t[CXST_E2G]\t= __DEF_FBTC_SLOT(0,   0xea5a5a5a, SLOT_MIX),\n\t[CXST_E5G]\t= __DEF_FBTC_SLOT(0,   0xffffffff, SLOT_ISO),\n\t[CXST_EBT]\t= __DEF_FBTC_SLOT(0,   0xe5555555, SLOT_MIX),\n\t[CXST_ENULL]\t= __DEF_FBTC_SLOT(0,   0xaaaaaaaa, SLOT_ISO),\n\t[CXST_WLK]\t= __DEF_FBTC_SLOT(250, 0xea5a5a5a, SLOT_MIX),\n\t[CXST_W1FDD]\t= __DEF_FBTC_SLOT(50,  0xffffffff, SLOT_ISO),\n\t[CXST_B1FDD]\t= __DEF_FBTC_SLOT(50,  0xffffdfff, SLOT_ISO),\n};\n\nstatic const u32 cxtbl[] = {\n\t0xffffffff,  \n\t0xaaaaaaaa,  \n\t0xe5555555,  \n\t0xee555555,  \n\t0xd5555555,  \n\t0x5a5a5a5a,  \n\t0xfa5a5a5a,  \n\t0xda5a5a5a,  \n\t0xea5a5a5a,  \n\t0x6a5a5aaa,  \n\t0x6a5a6a5a,  \n\t0x6a5a6aaa,  \n\t0x6afa5afa,  \n\t0xaaaa5aaa,  \n\t0xaaffffaa,  \n\t0xaa5555aa,  \n\t0xfafafafa,  \n\t0xffffddff,  \n\t0xdaffdaff,  \n\t0xfafadafa,  \n\t0xea6a6a6a,  \n\t0xea55556a,  \n\t0xaafafafa,  \n\t0xfafaaafa,  \n\t0xfafffaff   \n};\n\nstatic const struct rtw89_btc_ver rtw89_btc_ver_defs[] = {\n\t \n\t{RTL8851B, RTW89_FW_VER_CODE(0, 29, 29, 0),\n\t .fcxbtcrpt = 105, .fcxtdma = 3,    .fcxslots = 1, .fcxcysta = 5,\n\t .fcxstep = 3,   .fcxnullsta = 2, .fcxmreg = 2,  .fcxgpiodbg = 1,\n\t .fcxbtver = 1,  .fcxbtscan = 2,  .fcxbtafh = 2, .fcxbtdevinfo = 1,\n\t .fwlrole = 1,   .frptmap = 3,    .fcxctrl = 1,\n\t .info_buf = 1800, .max_role_num = 6,\n\t},\n\t{RTL8852C, RTW89_FW_VER_CODE(0, 27, 57, 0),\n\t .fcxbtcrpt = 4, .fcxtdma = 3,    .fcxslots = 1, .fcxcysta = 3,\n\t .fcxstep = 3,   .fcxnullsta = 2, .fcxmreg = 1,  .fcxgpiodbg = 1,\n\t .fcxbtver = 1,  .fcxbtscan = 1,  .fcxbtafh = 2, .fcxbtdevinfo = 1,\n\t .fwlrole = 1,   .frptmap = 3,    .fcxctrl = 1,\n\t .info_buf = 1280, .max_role_num = 5,\n\t},\n\t{RTL8852C, RTW89_FW_VER_CODE(0, 27, 42, 0),\n\t .fcxbtcrpt = 4, .fcxtdma = 3,    .fcxslots = 1, .fcxcysta = 3,\n\t .fcxstep = 3,   .fcxnullsta = 2, .fcxmreg = 1,  .fcxgpiodbg = 1,\n\t .fcxbtver = 1,  .fcxbtscan = 1,  .fcxbtafh = 2, .fcxbtdevinfo = 1,\n\t .fwlrole = 1,   .frptmap = 2,    .fcxctrl = 1,\n\t .info_buf = 1280, .max_role_num = 5,\n\t},\n\t{RTL8852C, RTW89_FW_VER_CODE(0, 27, 0, 0),\n\t .fcxbtcrpt = 4, .fcxtdma = 3,    .fcxslots = 1, .fcxcysta = 3,\n\t .fcxstep = 3,   .fcxnullsta = 2, .fcxmreg = 1,  .fcxgpiodbg = 1,\n\t .fcxbtver = 1,  .fcxbtscan = 1,  .fcxbtafh = 1, .fcxbtdevinfo = 1,\n\t .fwlrole = 1,   .frptmap = 2,    .fcxctrl = 1,\n\t .info_buf = 1280, .max_role_num = 5,\n\t},\n\t{RTL8852B, RTW89_FW_VER_CODE(0, 29, 29, 0),\n\t .fcxbtcrpt = 105, .fcxtdma = 3,  .fcxslots = 1, .fcxcysta = 5,\n\t .fcxstep = 3,   .fcxnullsta = 2, .fcxmreg = 2,  .fcxgpiodbg = 1,\n\t .fcxbtver = 1,  .fcxbtscan = 2,  .fcxbtafh = 2, .fcxbtdevinfo = 1,\n\t .fwlrole = 1,   .frptmap = 3,    .fcxctrl = 1,\n\t .info_buf = 1800, .max_role_num = 6,\n\t},\n\t{RTL8852B, RTW89_FW_VER_CODE(0, 29, 14, 0),\n\t .fcxbtcrpt = 5, .fcxtdma = 3,    .fcxslots = 1, .fcxcysta = 4,\n\t .fcxstep = 3,   .fcxnullsta = 2, .fcxmreg = 1,  .fcxgpiodbg = 1,\n\t .fcxbtver = 1,  .fcxbtscan = 1,  .fcxbtafh = 2, .fcxbtdevinfo = 1,\n\t .fwlrole = 1,   .frptmap = 3,    .fcxctrl = 1,\n\t .info_buf = 1800, .max_role_num = 6,\n\t},\n\t{RTL8852B, RTW89_FW_VER_CODE(0, 27, 0, 0),\n\t .fcxbtcrpt = 4, .fcxtdma = 3,    .fcxslots = 1, .fcxcysta = 3,\n\t .fcxstep = 3,   .fcxnullsta = 2, .fcxmreg = 1,  .fcxgpiodbg = 1,\n\t .fcxbtver = 1,  .fcxbtscan = 1,  .fcxbtafh = 1, .fcxbtdevinfo = 1,\n\t .fwlrole = 1,   .frptmap = 1,    .fcxctrl = 1,\n\t .info_buf = 1280, .max_role_num = 5,\n\t},\n\t{RTL8852A, RTW89_FW_VER_CODE(0, 13, 37, 0),\n\t .fcxbtcrpt = 4, .fcxtdma = 3,    .fcxslots = 1, .fcxcysta = 3,\n\t .fcxstep = 3,   .fcxnullsta = 2, .fcxmreg = 1,  .fcxgpiodbg = 1,\n\t .fcxbtver = 1,  .fcxbtscan = 1,  .fcxbtafh = 2, .fcxbtdevinfo = 1,\n\t .fwlrole = 1,   .frptmap = 3,    .fcxctrl = 1,\n\t .info_buf = 1280, .max_role_num = 5,\n\t},\n\t{RTL8852A, RTW89_FW_VER_CODE(0, 13, 0, 0),\n\t .fcxbtcrpt = 1, .fcxtdma = 1,    .fcxslots = 1, .fcxcysta = 2,\n\t .fcxstep = 2,   .fcxnullsta = 1, .fcxmreg = 1,  .fcxgpiodbg = 1,\n\t .fcxbtver = 1,  .fcxbtscan = 1,  .fcxbtafh = 1, .fcxbtdevinfo = 1,\n\t .fwlrole = 0,   .frptmap = 0,    .fcxctrl = 0,\n\t .info_buf = 1024, .max_role_num = 5,\n\t},\n\n\t \n\t{0, RTW89_FW_VER_CODE(0, 0, 0, 0),\n\t .fcxbtcrpt = 1, .fcxtdma = 1,    .fcxslots = 1, .fcxcysta = 2,\n\t .fcxstep = 2,   .fcxnullsta = 1, .fcxmreg = 1,  .fcxgpiodbg = 1,\n\t .fcxbtver = 1,  .fcxbtscan = 1,  .fcxbtafh = 1, .fcxbtdevinfo = 1,\n\t .fwlrole = 0,   .frptmap = 0,    .fcxctrl = 0,\n\t .info_buf = 1024, .max_role_num = 5,\n\t},\n};\n\n#define RTW89_DEFAULT_BTC_VER_IDX (ARRAY_SIZE(rtw89_btc_ver_defs) - 1)\n\nstruct rtw89_btc_btf_tlv {\n\tu8 type;\n\tu8 len;\n\tu8 val[];\n} __packed;\n\nenum btc_btf_set_report_en {\n\tRPT_EN_TDMA,\n\tRPT_EN_CYCLE,\n\tRPT_EN_MREG,\n\tRPT_EN_BT_VER_INFO,\n\tRPT_EN_BT_SCAN_INFO,\n\tRPT_EN_BT_DEVICE_INFO,\n\tRPT_EN_BT_AFH_MAP,\n\tRPT_EN_BT_AFH_MAP_LE,\n\tRPT_EN_FW_STEP_INFO,\n\tRPT_EN_TEST,\n\tRPT_EN_WL_ALL,\n\tRPT_EN_BT_ALL,\n\tRPT_EN_ALL,\n\tRPT_EN_MONITER,\n};\n\n#define BTF_SET_REPORT_VER 1\nstruct rtw89_btc_btf_set_report {\n\tu8 fver;\n\t__le32 enable;\n\t__le32 para;\n} __packed;\n\n#define BTF_SET_SLOT_TABLE_VER 1\nstruct rtw89_btc_btf_set_slot_table {\n\tu8 fver;\n\tu8 tbl_num;\n\tu8 buf[];\n} __packed;\n\nstruct rtw89_btc_btf_set_mon_reg {\n\tu8 fver;\n\tu8 reg_num;\n\tu8 buf[];\n} __packed;\n\nenum btc_btf_set_cx_policy {\n\tCXPOLICY_TDMA = 0x0,\n\tCXPOLICY_SLOT = 0x1,\n\tCXPOLICY_TYPE = 0x2,\n\tCXPOLICY_MAX,\n};\n\nenum btc_b2w_scoreboard {\n\tBTC_BSCB_ACT = BIT(0),\n\tBTC_BSCB_ON = BIT(1),\n\tBTC_BSCB_WHQL = BIT(2),\n\tBTC_BSCB_BT_S1 = BIT(3),\n\tBTC_BSCB_A2DP_ACT = BIT(4),\n\tBTC_BSCB_RFK_RUN = BIT(5),\n\tBTC_BSCB_RFK_REQ = BIT(6),\n\tBTC_BSCB_LPS = BIT(7),\n\tBTC_BSCB_WLRFK = BIT(11),\n\tBTC_BSCB_BT_HILNA = BIT(13),\n\tBTC_BSCB_BT_CONNECT = BIT(16),\n\tBTC_BSCB_PATCH_CODE = BIT(30),\n\tBTC_BSCB_ALL = GENMASK(30, 0),\n};\n\nenum btc_phymap {\n\tBTC_PHY_0 = BIT(0),\n\tBTC_PHY_1 = BIT(1),\n\tBTC_PHY_ALL = BIT(0) | BIT(1),\n};\n\nenum btc_cx_state_map {\n\tBTC_WIDLE = 0,\n\tBTC_WBUSY_BNOSCAN,\n\tBTC_WBUSY_BSCAN,\n\tBTC_WSCAN_BNOSCAN,\n\tBTC_WSCAN_BSCAN,\n\tBTC_WLINKING\n};\n\nenum btc_ant_phase {\n\tBTC_ANT_WPOWERON = 0,\n\tBTC_ANT_WINIT,\n\tBTC_ANT_WONLY,\n\tBTC_ANT_WOFF,\n\tBTC_ANT_W2G,\n\tBTC_ANT_W5G,\n\tBTC_ANT_W25G,\n\tBTC_ANT_FREERUN,\n\tBTC_ANT_WRFK,\n\tBTC_ANT_BRFK,\n\tBTC_ANT_MAX\n};\n\nenum btc_plt {\n\tBTC_PLT_NONE = 0,\n\tBTC_PLT_LTE_RX = BIT(0),\n\tBTC_PLT_GNT_BT_TX = BIT(1),\n\tBTC_PLT_GNT_BT_RX = BIT(2),\n\tBTC_PLT_GNT_WL = BIT(3),\n\tBTC_PLT_BT = BIT(1) | BIT(2),\n\tBTC_PLT_ALL = 0xf\n};\n\nenum btc_cx_poicy_main_type {\n\tBTC_CXP_OFF = 0,\n\tBTC_CXP_OFFB,\n\tBTC_CXP_OFFE,\n\tBTC_CXP_FIX,\n\tBTC_CXP_PFIX,\n\tBTC_CXP_AUTO,\n\tBTC_CXP_PAUTO,\n\tBTC_CXP_AUTO2,\n\tBTC_CXP_PAUTO2,\n\tBTC_CXP_MANUAL,\n\tBTC_CXP_USERDEF0,\n\tBTC_CXP_MAIN_MAX\n};\n\nenum btc_cx_poicy_type {\n\t \n\tBTC_CXP_OFF_BT = (BTC_CXP_OFF << 8) | 0,\n\n\t \n\tBTC_CXP_OFF_WL = (BTC_CXP_OFF << 8) | 1,\n\n\t \n\tBTC_CXP_OFF_EQ0 = (BTC_CXP_OFF << 8) | 2,\n\n\t \n\tBTC_CXP_OFF_EQ1 = (BTC_CXP_OFF << 8) | 3,\n\n\t \n\tBTC_CXP_OFF_EQ2 = (BTC_CXP_OFF << 8) | 4,\n\n\t \n\tBTC_CXP_OFF_EQ3 = (BTC_CXP_OFF << 8) | 5,\n\n\t \n\tBTC_CXP_OFF_BWB0 = (BTC_CXP_OFF << 8) | 6,\n\n\t \n\tBTC_CXP_OFF_BWB1 = (BTC_CXP_OFF << 8) | 7,\n\n\t \n\tBTC_CXP_OFF_BWB2 = (BTC_CXP_OFF << 8) | 8,\n\n\t \n\tBTC_CXP_OFF_BWB3 = (BTC_CXP_OFF << 8) | 9,\n\n\t \n\tBTC_CXP_OFFB_BWB0 = (BTC_CXP_OFFB << 8) | 0,\n\n\t \n\tBTC_CXP_OFFE_DEF = (BTC_CXP_OFFE << 8) | 0,\n\n\t \n\tBTC_CXP_OFFE_DEF2 = (BTC_CXP_OFFE << 8) | 1,\n\n\t \n\tBTC_CXP_OFFE_2GBWISOB = (BTC_CXP_OFFE << 8) | 2,\n\n\t \n\tBTC_CXP_OFFE_2GISOB = (BTC_CXP_OFFE << 8) | 3,\n\n\t \n\tBTC_CXP_OFFE_2GBWMIXB = (BTC_CXP_OFFE << 8) | 4,\n\n\t \n\tBTC_CXP_OFFE_WL = (BTC_CXP_OFFE << 8) | 5,\n\n\t \n\tBTC_CXP_OFFE_2GBWMIXB2 = (BTC_CXP_OFFE << 8) | 6,\n\n\t \n\tBTC_CXP_FIX_TD3030 = (BTC_CXP_FIX << 8) | 0,\n\n\t \n\tBTC_CXP_FIX_TD5050 = (BTC_CXP_FIX << 8) | 1,\n\n\t \n\tBTC_CXP_FIX_TD2030 = (BTC_CXP_FIX << 8) | 2,\n\n\t \n\tBTC_CXP_FIX_TD4010 = (BTC_CXP_FIX << 8) | 3,\n\n\t \n\tBTC_CXP_FIX_TD7010 = (BTC_CXP_FIX << 8) | 4,\n\n\t \n\tBTC_CXP_FIX_TD2060 = (BTC_CXP_FIX << 8) | 5,\n\n\t \n\tBTC_CXP_FIX_TD3060 = (BTC_CXP_FIX << 8) | 6,\n\n\t \n\tBTC_CXP_FIX_TD2080 = (BTC_CXP_FIX << 8) | 7,\n\n\t \n\tBTC_CXP_FIX_TDW1B1 = (BTC_CXP_FIX << 8) | 8,\n\n\t \n\tBTC_CXP_FIX_TD4020 = (BTC_CXP_FIX << 8) | 9,\n\n\t \n\tBTC_CXP_FIX_TD4010ISO = (BTC_CXP_FIX << 8) | 10,\n\n\t \n\tBTC_CXP_PFIX_TD3030 = (BTC_CXP_PFIX << 8) | 0,\n\n\t \n\tBTC_CXP_PFIX_TD5050 = (BTC_CXP_PFIX << 8) | 1,\n\n\t \n\tBTC_CXP_PFIX_TD2030 = (BTC_CXP_PFIX << 8) | 2,\n\n\t \n\tBTC_CXP_PFIX_TD2060 = (BTC_CXP_PFIX << 8) | 3,\n\n\t \n\tBTC_CXP_PFIX_TD3070 = (BTC_CXP_PFIX << 8) | 4,\n\n\t \n\tBTC_CXP_PFIX_TD2080 = (BTC_CXP_PFIX << 8) | 5,\n\n\t \n\tBTC_CXP_PFIX_TDW1B1 = (BTC_CXP_PFIX << 8) | 6,\n\n\t \n\tBTC_CXP_AUTO_TD50B1 = (BTC_CXP_AUTO << 8) | 0,\n\n\t \n\tBTC_CXP_AUTO_TD60B1 = (BTC_CXP_AUTO << 8) | 1,\n\n\t \n\tBTC_CXP_AUTO_TD20B1 = (BTC_CXP_AUTO << 8) | 2,\n\n\t \n\tBTC_CXP_AUTO_TDW1B1 = (BTC_CXP_AUTO << 8) | 3,\n\n\t \n\tBTC_CXP_PAUTO_TD50B1 = (BTC_CXP_PAUTO << 8) | 0,\n\n\t \n\tBTC_CXP_PAUTO_TD60B1 = (BTC_CXP_PAUTO << 8) | 1,\n\n\t \n\tBTC_CXP_PAUTO_TD20B1 = (BTC_CXP_PAUTO << 8) | 2,\n\n\t \n\tBTC_CXP_PAUTO_TDW1B1 = (BTC_CXP_PAUTO << 8) | 3,\n\n\t \n\tBTC_CXP_AUTO2_TD3050 = (BTC_CXP_AUTO2 << 8) | 0,\n\n\t \n\tBTC_CXP_AUTO2_TD3070 = (BTC_CXP_AUTO2 << 8) | 1,\n\n\t \n\tBTC_CXP_AUTO2_TD5050 = (BTC_CXP_AUTO2 << 8) | 2,\n\n\t \n\tBTC_CXP_AUTO2_TD6060 = (BTC_CXP_AUTO2 << 8) | 3,\n\n\t \n\tBTC_CXP_AUTO2_TD2080 = (BTC_CXP_AUTO2 << 8) | 4,\n\n\t \n\tBTC_CXP_AUTO2_TDW1B4 = (BTC_CXP_AUTO2 << 8) | 5,\n\n\t \n\tBTC_CXP_PAUTO2_TD3050 = (BTC_CXP_PAUTO2 << 8) | 0,\n\n\t \n\tBTC_CXP_PAUTO2_TD3070 = (BTC_CXP_PAUTO2 << 8) | 1,\n\n\t \n\tBTC_CXP_PAUTO2_TD5050 = (BTC_CXP_PAUTO2 << 8) | 2,\n\n\t \n\tBTC_CXP_PAUTO2_TD6060 = (BTC_CXP_PAUTO2 << 8) | 3,\n\n\t \n\tBTC_CXP_PAUTO2_TD2080 = (BTC_CXP_PAUTO2 << 8) | 4,\n\n\t \n\tBTC_CXP_PAUTO2_TDW1B4 = (BTC_CXP_PAUTO2 << 8) | 5,\n\n\tBTC_CXP_MAX = 0xffff\n};\n\nenum btc_wl_rfk_result {\n\tBTC_WRFK_REJECT = 0,\n\tBTC_WRFK_ALLOW = 1,\n};\n\nenum btc_coex_info_map_en {\n\tBTC_COEX_INFO_CX = BIT(0),\n\tBTC_COEX_INFO_WL = BIT(1),\n\tBTC_COEX_INFO_BT = BIT(2),\n\tBTC_COEX_INFO_DM = BIT(3),\n\tBTC_COEX_INFO_MREG = BIT(4),\n\tBTC_COEX_INFO_SUMMARY = BIT(5),\n\tBTC_COEX_INFO_ALL = GENMASK(7, 0),\n};\n\n#define BTC_CXP_MASK GENMASK(15, 8)\n\nenum btc_w2b_scoreboard {\n\tBTC_WSCB_ACTIVE = BIT(0),\n\tBTC_WSCB_ON = BIT(1),\n\tBTC_WSCB_SCAN = BIT(2),\n\tBTC_WSCB_UNDERTEST = BIT(3),\n\tBTC_WSCB_RXGAIN = BIT(4),\n\tBTC_WSCB_WLBUSY = BIT(7),\n\tBTC_WSCB_EXTFEM = BIT(8),\n\tBTC_WSCB_TDMA = BIT(9),\n\tBTC_WSCB_FIX2M = BIT(10),\n\tBTC_WSCB_WLRFK = BIT(11),\n\tBTC_WSCB_RXSCAN_PRI = BIT(12),\n\tBTC_WSCB_BT_HILNA = BIT(13),\n\tBTC_WSCB_BTLOG = BIT(14),\n\tBTC_WSCB_ALL = GENMASK(23, 0),\n};\n\nenum btc_wl_link_mode {\n\tBTC_WLINK_NOLINK = 0x0,\n\tBTC_WLINK_2G_STA,\n\tBTC_WLINK_2G_AP,\n\tBTC_WLINK_2G_GO,\n\tBTC_WLINK_2G_GC,\n\tBTC_WLINK_2G_SCC,\n\tBTC_WLINK_2G_MCC,\n\tBTC_WLINK_25G_MCC,\n\tBTC_WLINK_25G_DBCC,\n\tBTC_WLINK_5G,\n\tBTC_WLINK_2G_NAN,\n\tBTC_WLINK_OTHER,\n\tBTC_WLINK_MAX\n};\n\nenum btc_wl_mrole_type {\n\tBTC_WLMROLE_NONE = 0x0,\n\tBTC_WLMROLE_STA_GC,\n\tBTC_WLMROLE_STA_GC_NOA,\n\tBTC_WLMROLE_STA_GO,\n\tBTC_WLMROLE_STA_GO_NOA,\n\tBTC_WLMROLE_STA_STA,\n\tBTC_WLMROLE_MAX\n};\n\nenum btc_bt_hid_type {\n\tBTC_HID_218 = BIT(0),\n\tBTC_HID_418 = BIT(1),\n\tBTC_HID_BLE = BIT(2),\n\tBTC_HID_RCU = BIT(3),\n\tBTC_HID_RCU_VOICE = BIT(4),\n\tBTC_HID_OTHER_LEGACY = BIT(5)\n};\n\nenum btc_reset_module {\n\tBTC_RESET_CX = BIT(0),\n\tBTC_RESET_DM = BIT(1),\n\tBTC_RESET_CTRL = BIT(2),\n\tBTC_RESET_CXDM = BIT(0) | BIT(1),\n\tBTC_RESET_BTINFO = BIT(3),\n\tBTC_RESET_MDINFO = BIT(4),\n\tBTC_RESET_ALL =  GENMASK(7, 0),\n};\n\nenum btc_gnt_state {\n\tBTC_GNT_HW\t= 0,\n\tBTC_GNT_SW_LO,\n\tBTC_GNT_SW_HI,\n\tBTC_GNT_MAX\n};\n\nenum btc_ctr_path {\n\tBTC_CTRL_BY_BT = 0,\n\tBTC_CTRL_BY_WL\n};\n\nenum btc_wl_max_tx_time {\n\tBTC_MAX_TX_TIME_L1 = 500,\n\tBTC_MAX_TX_TIME_L2 = 1000,\n\tBTC_MAX_TX_TIME_L3 = 2000,\n\tBTC_MAX_TX_TIME_DEF = 5280\n};\n\nenum btc_wl_max_tx_retry {\n\tBTC_MAX_TX_RETRY_L1 = 7,\n\tBTC_MAX_TX_RETRY_L2 = 15,\n\tBTC_MAX_TX_RETRY_DEF = 31,\n};\n\nenum btc_reason_and_action {\n\tBTC_RSN_NONE,\n\tBTC_RSN_NTFY_INIT,\n\tBTC_RSN_NTFY_SWBAND,\n\tBTC_RSN_NTFY_WL_STA,\n\tBTC_RSN_NTFY_RADIO_STATE,\n\tBTC_RSN_UPDATE_BT_SCBD,\n\tBTC_RSN_NTFY_WL_RFK,\n\tBTC_RSN_UPDATE_BT_INFO,\n\tBTC_RSN_NTFY_SCAN_START,\n\tBTC_RSN_NTFY_SCAN_FINISH,\n\tBTC_RSN_NTFY_SPECIFIC_PACKET,\n\tBTC_RSN_NTFY_POWEROFF,\n\tBTC_RSN_NTFY_ROLE_INFO,\n\tBTC_RSN_CMD_SET_COEX,\n\tBTC_RSN_ACT1_WORK,\n\tBTC_RSN_BT_DEVINFO_WORK,\n\tBTC_RSN_RFK_CHK_WORK,\n\tBTC_RSN_NUM,\n\tBTC_ACT_NONE = 100,\n\tBTC_ACT_WL_ONLY,\n\tBTC_ACT_WL_5G,\n\tBTC_ACT_WL_OTHER,\n\tBTC_ACT_WL_IDLE,\n\tBTC_ACT_WL_NC,\n\tBTC_ACT_WL_RFK,\n\tBTC_ACT_WL_INIT,\n\tBTC_ACT_WL_OFF,\n\tBTC_ACT_FREERUN,\n\tBTC_ACT_BT_WHQL,\n\tBTC_ACT_BT_RFK,\n\tBTC_ACT_BT_OFF,\n\tBTC_ACT_BT_IDLE,\n\tBTC_ACT_BT_HFP,\n\tBTC_ACT_BT_HID,\n\tBTC_ACT_BT_A2DP,\n\tBTC_ACT_BT_A2DPSINK,\n\tBTC_ACT_BT_PAN,\n\tBTC_ACT_BT_A2DP_HID,\n\tBTC_ACT_BT_A2DP_PAN,\n\tBTC_ACT_BT_PAN_HID,\n\tBTC_ACT_BT_A2DP_PAN_HID,\n\tBTC_ACT_WL_25G_MCC,\n\tBTC_ACT_WL_2G_MCC,\n\tBTC_ACT_WL_2G_SCC,\n\tBTC_ACT_WL_2G_AP,\n\tBTC_ACT_WL_2G_GO,\n\tBTC_ACT_WL_2G_GC,\n\tBTC_ACT_WL_2G_NAN,\n\tBTC_ACT_LAST,\n\tBTC_ACT_NUM = BTC_ACT_LAST - BTC_ACT_NONE,\n\tBTC_ACT_EXT_BIT = BIT(14),\n\tBTC_POLICY_EXT_BIT = BIT(15),\n};\n\n#define BTC_FREERUN_ANTISO_MIN 30\n#define BTC_TDMA_BTHID_MAX 2\n#define BTC_BLINK_NOCONNECT 0\n#define BTC_B1_MAX 250  \n\nstatic void _run_coex(struct rtw89_dev *rtwdev,\n\t\t      enum btc_reason_and_action reason);\nstatic void _write_scbd(struct rtw89_dev *rtwdev, u32 val, bool state);\nstatic void _update_bt_scbd(struct rtw89_dev *rtwdev, bool only_update);\n\nstatic void _send_fw_cmd(struct rtw89_dev *rtwdev, u8 h2c_class, u8 h2c_func,\n\t\t\t void *param, u16 len)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_btf_fwinfo *pfwinfo = &btc->fwinfo;\n\tstruct rtw89_btc_cx *cx = &btc->cx;\n\tstruct rtw89_btc_wl_info *wl = &cx->wl;\n\tint ret;\n\n\tif (!wl->status.map.init_ok) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t\t    \"[BTC], %s(): return by btc not init!!\\n\", __func__);\n\t\tpfwinfo->cnt_h2c_fail++;\n\t\treturn;\n\t} else if ((wl->status.map.rf_off_pre == BTC_LPS_RF_OFF &&\n\t\t    wl->status.map.rf_off == BTC_LPS_RF_OFF) ||\n\t\t   (wl->status.map.lps_pre == BTC_LPS_RF_OFF &&\n\t\t    wl->status.map.lps == BTC_LPS_RF_OFF)) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t\t    \"[BTC], %s(): return by wl off!!\\n\", __func__);\n\t\tpfwinfo->cnt_h2c_fail++;\n\t\treturn;\n\t}\n\n\tpfwinfo->cnt_h2c++;\n\n\tret = rtw89_fw_h2c_raw_with_hdr(rtwdev, h2c_class, h2c_func, param, len,\n\t\t\t\t\tfalse, true);\n\tif (ret != 0)\n\t\tpfwinfo->cnt_h2c_fail++;\n}\n\nstatic void _reset_btc_var(struct rtw89_dev *rtwdev, u8 type)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_cx *cx = &btc->cx;\n\tstruct rtw89_btc_wl_info *wl = &btc->cx.wl;\n\tstruct rtw89_btc_bt_info *bt = &btc->cx.bt;\n\tstruct rtw89_btc_bt_link_info *bt_linfo = &bt->link_info;\n\tstruct rtw89_btc_wl_link_info *wl_linfo = wl->link_info;\n\tu8 i;\n\n\trtw89_debug(rtwdev, RTW89_DBG_BTC, \"[BTC], %s\\n\", __func__);\n\n\tif (type & BTC_RESET_CX)\n\t\tmemset(cx, 0, sizeof(*cx));\n\telse if (type & BTC_RESET_BTINFO)  \n\t\tmemset(bt, 0, sizeof(*bt));\n\n\tif (type & BTC_RESET_CTRL) {\n\t\tmemset(&btc->ctrl, 0, sizeof(btc->ctrl));\n\t\tbtc->ctrl.trace_step = FCXDEF_STEP;\n\t}\n\n\t \n\tif (type & BTC_RESET_DM) {\n\t\tmemset(&btc->dm, 0, sizeof(btc->dm));\n\t\tmemset(bt_linfo->rssi_state, 0, sizeof(bt_linfo->rssi_state));\n\n\t\tfor (i = 0; i < RTW89_PORT_NUM; i++)\n\t\t\tmemset(wl_linfo[i].rssi_state, 0,\n\t\t\t       sizeof(wl_linfo[i].rssi_state));\n\n\t\t \n\t\tbtc->dm.tdma_now = t_def[CXTD_OFF];\n\t\tbtc->dm.tdma = t_def[CXTD_OFF];\n\t\tmemcpy(&btc->dm.slot_now, s_def, sizeof(btc->dm.slot_now));\n\t\tmemcpy(&btc->dm.slot, s_def, sizeof(btc->dm.slot));\n\n\t\tbtc->policy_len = 0;\n\t\tbtc->bt_req_len = 0;\n\n\t\tbtc->dm.coex_info_map = BTC_COEX_INFO_ALL;\n\t\tbtc->dm.wl_tx_limit.tx_time = BTC_MAX_TX_TIME_DEF;\n\t\tbtc->dm.wl_tx_limit.tx_retry = BTC_MAX_TX_RETRY_DEF;\n\t}\n\n\tif (type & BTC_RESET_MDINFO)\n\t\tmemset(&btc->mdinfo, 0, sizeof(btc->mdinfo));\n}\n\n#define BTC_RPT_HDR_SIZE 3\n#define BTC_CHK_WLSLOT_DRIFT_MAX 15\n#define BTC_CHK_BTSLOT_DRIFT_MAX 15\n#define BTC_CHK_HANG_MAX 3\n\nstatic void _chk_btc_err(struct rtw89_dev *rtwdev, u8 type, u32 cnt)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_cx *cx = &btc->cx;\n\tstruct rtw89_btc_dm *dm = &btc->dm;\n\tstruct rtw89_btc_bt_info *bt = &cx->bt;\n\n\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t    \"[BTC], %s(): type:%d cnt:%d\\n\",\n\t\t    __func__, type, cnt);\n\n\tswitch (type) {\n\tcase BTC_DCNT_RPT_HANG:\n\t\tif (dm->cnt_dm[BTC_DCNT_RPT] == cnt && btc->fwinfo.rpt_en_map)\n\t\t\tdm->cnt_dm[BTC_DCNT_RPT_HANG]++;\n\t\telse\n\t\t\tdm->cnt_dm[BTC_DCNT_RPT_HANG] = 0;\n\n\t\tif (dm->cnt_dm[BTC_DCNT_RPT_HANG] >= BTC_CHK_HANG_MAX)\n\t\t\tdm->error.map.wl_fw_hang = true;\n\t\telse\n\t\t\tdm->error.map.wl_fw_hang = false;\n\n\t\tdm->cnt_dm[BTC_DCNT_RPT] = cnt;\n\t\tbreak;\n\tcase BTC_DCNT_CYCLE_HANG:\n\t\tif (dm->cnt_dm[BTC_DCNT_CYCLE] == cnt &&\n\t\t    (dm->tdma_now.type != CXTDMA_OFF ||\n\t\t     dm->tdma_now.ext_ctrl == CXECTL_EXT))\n\t\t\tdm->cnt_dm[BTC_DCNT_CYCLE_HANG]++;\n\t\telse\n\t\t\tdm->cnt_dm[BTC_DCNT_CYCLE_HANG] = 0;\n\n\t\tif (dm->cnt_dm[BTC_DCNT_CYCLE_HANG] >= BTC_CHK_HANG_MAX)\n\t\t\tdm->error.map.cycle_hang = true;\n\t\telse\n\t\t\tdm->error.map.cycle_hang = false;\n\n\t\tdm->cnt_dm[BTC_DCNT_CYCLE] = cnt;\n\t\tbreak;\n\tcase BTC_DCNT_W1_HANG:\n\t\tif (dm->cnt_dm[BTC_DCNT_W1] == cnt &&\n\t\t    dm->tdma_now.type != CXTDMA_OFF)\n\t\t\tdm->cnt_dm[BTC_DCNT_W1_HANG]++;\n\t\telse\n\t\t\tdm->cnt_dm[BTC_DCNT_W1_HANG] = 0;\n\n\t\tif (dm->cnt_dm[BTC_DCNT_W1_HANG] >= BTC_CHK_HANG_MAX)\n\t\t\tdm->error.map.w1_hang = true;\n\t\telse\n\t\t\tdm->error.map.w1_hang = false;\n\n\t\tdm->cnt_dm[BTC_DCNT_W1] = cnt;\n\t\tbreak;\n\tcase BTC_DCNT_B1_HANG:\n\t\tif (dm->cnt_dm[BTC_DCNT_B1] == cnt &&\n\t\t    dm->tdma_now.type != CXTDMA_OFF)\n\t\t\tdm->cnt_dm[BTC_DCNT_B1_HANG]++;\n\t\telse\n\t\t\tdm->cnt_dm[BTC_DCNT_B1_HANG] = 0;\n\n\t\tif (dm->cnt_dm[BTC_DCNT_B1_HANG] >= BTC_CHK_HANG_MAX)\n\t\t\tdm->error.map.b1_hang = true;\n\t\telse\n\t\t\tdm->error.map.b1_hang = false;\n\n\t\tdm->cnt_dm[BTC_DCNT_B1] = cnt;\n\t\tbreak;\n\tcase BTC_DCNT_E2G_HANG:\n\t\tif (dm->cnt_dm[BTC_DCNT_E2G] == cnt &&\n\t\t    dm->tdma_now.ext_ctrl == CXECTL_EXT)\n\t\t\tdm->cnt_dm[BTC_DCNT_E2G_HANG]++;\n\t\telse\n\t\t\tdm->cnt_dm[BTC_DCNT_E2G_HANG] = 0;\n\n\t\tif (dm->cnt_dm[BTC_DCNT_E2G_HANG] >= BTC_CHK_HANG_MAX)\n\t\t\tdm->error.map.wl_e2g_hang = true;\n\t\telse\n\t\t\tdm->error.map.wl_e2g_hang = false;\n\n\t\tdm->cnt_dm[BTC_DCNT_E2G] = cnt;\n\t\tbreak;\n\tcase BTC_DCNT_TDMA_NONSYNC:\n\t\tif (cnt != 0)  \n\t\t\tdm->cnt_dm[BTC_DCNT_TDMA_NONSYNC]++;\n\t\telse\n\t\t\tdm->cnt_dm[BTC_DCNT_TDMA_NONSYNC] = 0;\n\n\t\tif (dm->cnt_dm[BTC_DCNT_TDMA_NONSYNC] >= BTC_CHK_HANG_MAX)\n\t\t\tdm->error.map.tdma_no_sync = true;\n\t\telse\n\t\t\tdm->error.map.tdma_no_sync = false;\n\t\tbreak;\n\tcase BTC_DCNT_SLOT_NONSYNC:\n\t\tif (cnt != 0)  \n\t\t\tdm->cnt_dm[BTC_DCNT_SLOT_NONSYNC]++;\n\t\telse\n\t\t\tdm->cnt_dm[BTC_DCNT_SLOT_NONSYNC] = 0;\n\n\t\tif (dm->cnt_dm[BTC_DCNT_SLOT_NONSYNC] >= BTC_CHK_HANG_MAX)\n\t\t\tdm->error.map.slot_no_sync = true;\n\t\telse\n\t\t\tdm->error.map.slot_no_sync = false;\n\t\tbreak;\n\tcase BTC_DCNT_BTCNT_HANG:\n\t\tcnt = cx->cnt_bt[BTC_BCNT_HIPRI_RX] +\n\t\t      cx->cnt_bt[BTC_BCNT_HIPRI_TX] +\n\t\t      cx->cnt_bt[BTC_BCNT_LOPRI_RX] +\n\t\t      cx->cnt_bt[BTC_BCNT_LOPRI_TX];\n\n\t\tif (cnt == 0)\n\t\t\tdm->cnt_dm[BTC_DCNT_BTCNT_HANG]++;\n\t\telse\n\t\t\tdm->cnt_dm[BTC_DCNT_BTCNT_HANG] = 0;\n\n\t\tif ((dm->cnt_dm[BTC_DCNT_BTCNT_HANG] >= BTC_CHK_HANG_MAX &&\n\t\t     bt->enable.now) || (!dm->cnt_dm[BTC_DCNT_BTCNT_HANG] &&\n\t\t     !bt->enable.now))\n\t\t\t_update_bt_scbd(rtwdev, false);\n\t\tbreak;\n\tcase BTC_DCNT_WL_SLOT_DRIFT:\n\t\tif (cnt >= BTC_CHK_WLSLOT_DRIFT_MAX)\n\t\t\tdm->cnt_dm[BTC_DCNT_WL_SLOT_DRIFT]++;\n\t\telse\n\t\t\tdm->cnt_dm[BTC_DCNT_WL_SLOT_DRIFT] = 0;\n\n\t\tif (dm->cnt_dm[BTC_DCNT_WL_SLOT_DRIFT] >= BTC_CHK_HANG_MAX)\n\t\t\tdm->error.map.wl_slot_drift = true;\n\t\telse\n\t\t\tdm->error.map.wl_slot_drift = false;\n\t\tbreak;\n\tcase BTC_DCNT_BT_SLOT_DRIFT:\n\t\tif (cnt >= BTC_CHK_BTSLOT_DRIFT_MAX)\n\t\t\tdm->cnt_dm[BTC_DCNT_BT_SLOT_DRIFT]++;\n\t\telse\n\t\t\tdm->cnt_dm[BTC_DCNT_BT_SLOT_DRIFT] = 0;\n\n\t\tif (dm->cnt_dm[BTC_DCNT_BT_SLOT_DRIFT] >= BTC_CHK_HANG_MAX)\n\t\t\tdm->error.map.bt_slot_drift = true;\n\t\telse\n\t\t\tdm->error.map.bt_slot_drift = false;\n\n\t\tbreak;\n\t}\n}\n\nstatic void _update_bt_report(struct rtw89_dev *rtwdev, u8 rpt_type, u8 *pfinfo)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tconst struct rtw89_btc_ver *ver = btc->ver;\n\tstruct rtw89_btc_bt_info *bt = &btc->cx.bt;\n\tstruct rtw89_btc_bt_link_info *bt_linfo = &bt->link_info;\n\tstruct rtw89_btc_bt_a2dp_desc *a2dp = &bt_linfo->a2dp_desc;\n\tstruct rtw89_btc_fbtc_btver *pver = NULL;\n\tstruct rtw89_btc_fbtc_btscan_v1 *pscan_v1;\n\tstruct rtw89_btc_fbtc_btscan_v2 *pscan_v2;\n\tstruct rtw89_btc_fbtc_btafh *pafh_v1 = NULL;\n\tstruct rtw89_btc_fbtc_btafh_v2 *pafh_v2 = NULL;\n\tstruct rtw89_btc_fbtc_btdevinfo *pdev = NULL;\n\tbool scan_update = true;\n\tint i;\n\n\tpver = (struct rtw89_btc_fbtc_btver *)pfinfo;\n\tpdev = (struct rtw89_btc_fbtc_btdevinfo *)pfinfo;\n\n\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t    \"[BTC], %s(): rpt_type:%d\\n\",\n\t\t    __func__, rpt_type);\n\n\tswitch (rpt_type) {\n\tcase BTC_RPT_TYPE_BT_VER:\n\t\tbt->ver_info.fw = le32_to_cpu(pver->fw_ver);\n\t\tbt->ver_info.fw_coex = le32_get_bits(pver->coex_ver, GENMASK(7, 0));\n\t\tbt->feature = le32_to_cpu(pver->feature);\n\t\tbreak;\n\tcase BTC_RPT_TYPE_BT_SCAN:\n\t\tif (ver->fcxbtscan == 1) {\n\t\t\tpscan_v1 = (struct rtw89_btc_fbtc_btscan_v1 *)pfinfo;\n\t\t\tfor (i = 0; i < BTC_SCAN_MAX1; i++) {\n\t\t\t\tbt->scan_info_v1[i] = pscan_v1->scan[i];\n\t\t\t\tif (bt->scan_info_v1[i].win == 0 &&\n\t\t\t\t    bt->scan_info_v1[i].intvl == 0)\n\t\t\t\t\tscan_update = false;\n\t\t\t}\n\t\t} else if (ver->fcxbtscan == 2) {\n\t\t\tpscan_v2 = (struct rtw89_btc_fbtc_btscan_v2 *)pfinfo;\n\t\t\tfor (i = 0; i < CXSCAN_MAX; i++) {\n\t\t\t\tbt->scan_info_v2[i] = pscan_v2->para[i];\n\t\t\t\tif ((pscan_v2->type & BIT(i)) &&\n\t\t\t\t    pscan_v2->para[i].win == 0 &&\n\t\t\t\t    pscan_v2->para[i].intvl == 0)\n\t\t\t\t\tscan_update = false;\n\t\t\t}\n\t\t}\n\t\tif (scan_update)\n\t\t\tbt->scan_info_update = 1;\n\t\tbreak;\n\tcase BTC_RPT_TYPE_BT_AFH:\n\t\tif (ver->fcxbtafh == 2) {\n\t\t\tpafh_v2 = (struct rtw89_btc_fbtc_btafh_v2 *)pfinfo;\n\t\t\tif (pafh_v2->map_type & RPT_BT_AFH_SEQ_LEGACY) {\n\t\t\t\tmemcpy(&bt_linfo->afh_map[0], pafh_v2->afh_l, 4);\n\t\t\t\tmemcpy(&bt_linfo->afh_map[4], pafh_v2->afh_m, 4);\n\t\t\t\tmemcpy(&bt_linfo->afh_map[8], pafh_v2->afh_h, 2);\n\t\t\t}\n\t\t\tif (pafh_v2->map_type & RPT_BT_AFH_SEQ_LE) {\n\t\t\t\tmemcpy(&bt_linfo->afh_map_le[0], pafh_v2->afh_le_a, 4);\n\t\t\t\tmemcpy(&bt_linfo->afh_map_le[4], pafh_v2->afh_le_b, 1);\n\t\t\t}\n\t\t} else if (ver->fcxbtafh == 1) {\n\t\t\tpafh_v1 = (struct rtw89_btc_fbtc_btafh *)pfinfo;\n\t\t\tmemcpy(&bt_linfo->afh_map[0], pafh_v1->afh_l, 4);\n\t\t\tmemcpy(&bt_linfo->afh_map[4], pafh_v1->afh_m, 4);\n\t\t\tmemcpy(&bt_linfo->afh_map[8], pafh_v1->afh_h, 2);\n\t\t}\n\t\tbreak;\n\tcase BTC_RPT_TYPE_BT_DEVICE:\n\t\ta2dp->device_name = le32_to_cpu(pdev->dev_name);\n\t\ta2dp->vendor_id = le16_to_cpu(pdev->vendor_id);\n\t\ta2dp->flush_time = le32_to_cpu(pdev->flush_time);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n#define BTC_LEAK_AP_TH 10\n#define BTC_CYSTA_CHK_PERIOD 100\n\nstruct rtw89_btc_prpt {\n\tu8 type;\n\t__le16 len;\n\tu8 content[];\n} __packed;\n\nstatic u32 _chk_btc_report(struct rtw89_dev *rtwdev,\n\t\t\t   struct rtw89_btc_btf_fwinfo *pfwinfo,\n\t\t\t   u8 *prptbuf, u32 index)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tconst struct rtw89_btc_ver *ver = btc->ver;\n\tstruct rtw89_btc_dm *dm = &btc->dm;\n\tstruct rtw89_btc_rpt_cmn_info *pcinfo = NULL;\n\tstruct rtw89_btc_wl_info *wl = &btc->cx.wl;\n\tstruct rtw89_btc_bt_info *bt = &btc->cx.bt;\n\tunion rtw89_btc_fbtc_rpt_ctrl_ver_info *prpt = NULL;\n\tunion rtw89_btc_fbtc_cysta_info *pcysta = NULL;\n\tstruct rtw89_btc_prpt *btc_prpt = NULL;\n\tvoid *rpt_content = NULL, *pfinfo = NULL;\n\tu8 rpt_type = 0;\n\tu16 wl_slot_set = 0, wl_slot_real = 0;\n\tu32 trace_step = btc->ctrl.trace_step, rpt_len = 0, diff_t = 0;\n\tu32 cnt_leak_slot, bt_slot_real, bt_slot_set, cnt_rx_imr;\n\tu8 i;\n\n\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t    \"[BTC], %s(): index:%d\\n\",\n\t\t    __func__, index);\n\n\tif (!prptbuf) {\n\t\tpfwinfo->err[BTFRE_INVALID_INPUT]++;\n\t\treturn 0;\n\t}\n\n\tbtc_prpt = (struct rtw89_btc_prpt *)&prptbuf[index];\n\trpt_type = btc_prpt->type;\n\trpt_len = le16_to_cpu(btc_prpt->len);\n\trpt_content = btc_prpt->content;\n\n\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t    \"[BTC], %s(): rpt_type:%d\\n\",\n\t\t    __func__, rpt_type);\n\n\tswitch (rpt_type) {\n\tcase BTC_RPT_TYPE_CTRL:\n\t\tpcinfo = &pfwinfo->rpt_ctrl.cinfo;\n\t\tprpt = &pfwinfo->rpt_ctrl.finfo;\n\t\tif (ver->fcxbtcrpt == 1) {\n\t\t\tpfinfo = &pfwinfo->rpt_ctrl.finfo.v1;\n\t\t\tpcinfo->req_len = sizeof(pfwinfo->rpt_ctrl.finfo.v1);\n\t\t} else if (ver->fcxbtcrpt == 4) {\n\t\t\tpfinfo = &pfwinfo->rpt_ctrl.finfo.v4;\n\t\t\tpcinfo->req_len = sizeof(pfwinfo->rpt_ctrl.finfo.v4);\n\t\t} else if (ver->fcxbtcrpt == 5) {\n\t\t\tpfinfo = &pfwinfo->rpt_ctrl.finfo.v5;\n\t\t\tpcinfo->req_len = sizeof(pfwinfo->rpt_ctrl.finfo.v5);\n\t\t} else if (ver->fcxbtcrpt == 105) {\n\t\t\tpfinfo = &pfwinfo->rpt_ctrl.finfo.v105;\n\t\t\tpcinfo->req_len = sizeof(pfwinfo->rpt_ctrl.finfo.v105);\n\t\t\tpcinfo->req_fver = 5;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tgoto err;\n\t\t}\n\t\tpcinfo->req_fver = ver->fcxbtcrpt;\n\t\tbreak;\n\tcase BTC_RPT_TYPE_TDMA:\n\t\tpcinfo = &pfwinfo->rpt_fbtc_tdma.cinfo;\n\t\tif (ver->fcxtdma == 1) {\n\t\t\tpfinfo = &pfwinfo->rpt_fbtc_tdma.finfo.v1;\n\t\t\tpcinfo->req_len = sizeof(pfwinfo->rpt_fbtc_tdma.finfo.v1);\n\t\t} else if (ver->fcxtdma == 3) {\n\t\t\tpfinfo = &pfwinfo->rpt_fbtc_tdma.finfo.v3;\n\t\t\tpcinfo->req_len = sizeof(pfwinfo->rpt_fbtc_tdma.finfo.v3);\n\t\t} else {\n\t\t\tgoto err;\n\t\t}\n\t\tpcinfo->req_fver = ver->fcxtdma;\n\t\tbreak;\n\tcase BTC_RPT_TYPE_SLOT:\n\t\tpcinfo = &pfwinfo->rpt_fbtc_slots.cinfo;\n\t\tpfinfo = &pfwinfo->rpt_fbtc_slots.finfo;\n\t\tpcinfo->req_len = sizeof(pfwinfo->rpt_fbtc_slots.finfo);\n\t\tpcinfo->req_fver = ver->fcxslots;\n\t\tbreak;\n\tcase BTC_RPT_TYPE_CYSTA:\n\t\tpcinfo = &pfwinfo->rpt_fbtc_cysta.cinfo;\n\t\tpcysta = &pfwinfo->rpt_fbtc_cysta.finfo;\n\t\tif (ver->fcxcysta == 2) {\n\t\t\tpfinfo = &pfwinfo->rpt_fbtc_cysta.finfo.v2;\n\t\t\tpcysta->v2 = pfwinfo->rpt_fbtc_cysta.finfo.v2;\n\t\t\tpcinfo->req_len = sizeof(pfwinfo->rpt_fbtc_cysta.finfo.v2);\n\t\t} else if (ver->fcxcysta == 3) {\n\t\t\tpfinfo = &pfwinfo->rpt_fbtc_cysta.finfo.v3;\n\t\t\tpcysta->v3 = pfwinfo->rpt_fbtc_cysta.finfo.v3;\n\t\t\tpcinfo->req_len = sizeof(pfwinfo->rpt_fbtc_cysta.finfo.v3);\n\t\t} else if (ver->fcxcysta == 4) {\n\t\t\tpfinfo = &pfwinfo->rpt_fbtc_cysta.finfo.v4;\n\t\t\tpcysta->v4 = pfwinfo->rpt_fbtc_cysta.finfo.v4;\n\t\t\tpcinfo->req_len = sizeof(pfwinfo->rpt_fbtc_cysta.finfo.v4);\n\t\t} else if (ver->fcxcysta == 5) {\n\t\t\tpfinfo = &pfwinfo->rpt_fbtc_cysta.finfo.v5;\n\t\t\tpcysta->v5 = pfwinfo->rpt_fbtc_cysta.finfo.v5;\n\t\t\tpcinfo->req_len = sizeof(pfwinfo->rpt_fbtc_cysta.finfo.v5);\n\t\t} else {\n\t\t\tgoto err;\n\t\t}\n\t\tpcinfo->req_fver = ver->fcxcysta;\n\t\tbreak;\n\tcase BTC_RPT_TYPE_STEP:\n\t\tpcinfo = &pfwinfo->rpt_fbtc_step.cinfo;\n\t\tif (ver->fcxstep == 2) {\n\t\t\tpfinfo = &pfwinfo->rpt_fbtc_step.finfo.v2;\n\t\t\tpcinfo->req_len = sizeof(pfwinfo->rpt_fbtc_step.finfo.v2.step[0]) *\n\t\t\t\t\t  trace_step +\n\t\t\t\t\t  offsetof(struct rtw89_btc_fbtc_steps_v2, step);\n\t\t} else if (ver->fcxstep == 3) {\n\t\t\tpfinfo = &pfwinfo->rpt_fbtc_step.finfo.v3;\n\t\t\tpcinfo->req_len = sizeof(pfwinfo->rpt_fbtc_step.finfo.v3.step[0]) *\n\t\t\t\t\t  trace_step +\n\t\t\t\t\t  offsetof(struct rtw89_btc_fbtc_steps_v3, step);\n\t\t} else {\n\t\t\tgoto err;\n\t\t}\n\t\tpcinfo->req_fver = ver->fcxstep;\n\t\tbreak;\n\tcase BTC_RPT_TYPE_NULLSTA:\n\t\tpcinfo = &pfwinfo->rpt_fbtc_nullsta.cinfo;\n\t\tif (ver->fcxnullsta == 1) {\n\t\t\tpfinfo = &pfwinfo->rpt_fbtc_nullsta.finfo.v1;\n\t\t\tpcinfo->req_len = sizeof(pfwinfo->rpt_fbtc_nullsta.finfo.v1);\n\t\t} else if (ver->fcxnullsta == 2) {\n\t\t\tpfinfo = &pfwinfo->rpt_fbtc_nullsta.finfo.v2;\n\t\t\tpcinfo->req_len = sizeof(pfwinfo->rpt_fbtc_nullsta.finfo.v2);\n\t\t} else {\n\t\t\tgoto err;\n\t\t}\n\t\tpcinfo->req_fver = ver->fcxnullsta;\n\t\tbreak;\n\tcase BTC_RPT_TYPE_MREG:\n\t\tpcinfo = &pfwinfo->rpt_fbtc_mregval.cinfo;\n\t\tif (ver->fcxmreg == 1) {\n\t\t\tpfinfo = &pfwinfo->rpt_fbtc_mregval.finfo.v1;\n\t\t\tpcinfo->req_len = sizeof(pfwinfo->rpt_fbtc_mregval.finfo.v1);\n\t\t} else if (ver->fcxmreg == 2) {\n\t\t\tpfinfo = &pfwinfo->rpt_fbtc_mregval.finfo.v2;\n\t\t\tpcinfo->req_len = sizeof(pfwinfo->rpt_fbtc_mregval.finfo.v2);\n\t\t} else {\n\t\t\tgoto err;\n\t\t}\n\t\tpcinfo->req_fver = ver->fcxmreg;\n\t\tbreak;\n\tcase BTC_RPT_TYPE_GPIO_DBG:\n\t\tpcinfo = &pfwinfo->rpt_fbtc_gpio_dbg.cinfo;\n\t\tpfinfo = &pfwinfo->rpt_fbtc_gpio_dbg.finfo;\n\t\tpcinfo->req_len = sizeof(pfwinfo->rpt_fbtc_gpio_dbg.finfo);\n\t\tpcinfo->req_fver = ver->fcxgpiodbg;\n\t\tbreak;\n\tcase BTC_RPT_TYPE_BT_VER:\n\t\tpcinfo = &pfwinfo->rpt_fbtc_btver.cinfo;\n\t\tpfinfo = &pfwinfo->rpt_fbtc_btver.finfo;\n\t\tpcinfo->req_len = sizeof(pfwinfo->rpt_fbtc_btver.finfo);\n\t\tpcinfo->req_fver = ver->fcxbtver;\n\t\tbreak;\n\tcase BTC_RPT_TYPE_BT_SCAN:\n\t\tpcinfo = &pfwinfo->rpt_fbtc_btscan.cinfo;\n\t\tif (ver->fcxbtscan == 1) {\n\t\t\tpfinfo = &pfwinfo->rpt_fbtc_btscan.finfo.v1;\n\t\t\tpcinfo->req_len = sizeof(pfwinfo->rpt_fbtc_btscan.finfo.v1);\n\t\t} else if (ver->fcxbtscan == 2) {\n\t\t\tpfinfo = &pfwinfo->rpt_fbtc_btscan.finfo.v2;\n\t\t\tpcinfo->req_len = sizeof(pfwinfo->rpt_fbtc_btscan.finfo.v2);\n\t\t}\n\t\tpcinfo->req_fver = ver->fcxbtscan;\n\t\tbreak;\n\tcase BTC_RPT_TYPE_BT_AFH:\n\t\tpcinfo = &pfwinfo->rpt_fbtc_btafh.cinfo;\n\t\tif (ver->fcxbtafh == 1) {\n\t\t\tpfinfo = &pfwinfo->rpt_fbtc_btafh.finfo.v1;\n\t\t\tpcinfo->req_len = sizeof(pfwinfo->rpt_fbtc_btafh.finfo.v1);\n\t\t} else if (ver->fcxbtafh == 2) {\n\t\t\tpfinfo = &pfwinfo->rpt_fbtc_btafh.finfo.v2;\n\t\t\tpcinfo->req_len = sizeof(pfwinfo->rpt_fbtc_btafh.finfo.v2);\n\t\t} else {\n\t\t\tgoto err;\n\t\t}\n\t\tpcinfo->req_fver = ver->fcxbtafh;\n\t\tbreak;\n\tcase BTC_RPT_TYPE_BT_DEVICE:\n\t\tpcinfo = &pfwinfo->rpt_fbtc_btdev.cinfo;\n\t\tpfinfo = &pfwinfo->rpt_fbtc_btdev.finfo;\n\t\tpcinfo->req_len = sizeof(pfwinfo->rpt_fbtc_btdev.finfo);\n\t\tpcinfo->req_fver = ver->fcxbtdevinfo;\n\t\tbreak;\n\tdefault:\n\t\tpfwinfo->err[BTFRE_UNDEF_TYPE]++;\n\t\treturn 0;\n\t}\n\n\tpcinfo->rx_len = rpt_len;\n\tpcinfo->rx_cnt++;\n\n\tif (rpt_len != pcinfo->req_len) {\n\t\tif (rpt_type < BTC_RPT_TYPE_MAX)\n\t\t\tpfwinfo->len_mismch |= (0x1 << rpt_type);\n\t\telse\n\t\t\tpfwinfo->len_mismch |= BIT(31);\n\t\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t\t    \"[BTC], %s(): %d rpt_len:%d!=req_len:%d\\n\",\n\t\t\t    __func__, rpt_type, rpt_len, pcinfo->req_len);\n\n\t\tpcinfo->valid = 0;\n\t\treturn 0;\n\t} else if (!pfinfo || !rpt_content || !pcinfo->req_len) {\n\t\tpfwinfo->err[BTFRE_EXCEPTION]++;\n\t\tpcinfo->valid = 0;\n\t\treturn 0;\n\t}\n\n\tmemcpy(pfinfo, rpt_content, pcinfo->req_len);\n\tpcinfo->valid = 1;\n\n\tswitch (rpt_type) {\n\tcase BTC_RPT_TYPE_CTRL:\n\t\tif (ver->fcxbtcrpt == 1) {\n\t\t\tprpt->v1 = pfwinfo->rpt_ctrl.finfo.v1;\n\t\t\tbtc->fwinfo.rpt_en_map = prpt->v1.rpt_enable;\n\t\t\twl->ver_info.fw_coex = prpt->v1.wl_fw_coex_ver;\n\t\t\twl->ver_info.fw = prpt->v1.wl_fw_ver;\n\t\t\tdm->wl_fw_cx_offload = !!prpt->v1.wl_fw_cx_offload;\n\n\t\t\t_chk_btc_err(rtwdev, BTC_DCNT_RPT_HANG,\n\t\t\t\t     pfwinfo->event[BTF_EVNT_RPT]);\n\n\t\t\t \n\t\t\tif (wl->status.map.lps != BTC_LPS_RF_OFF &&\n\t\t\t    !wl->status.map.rf_off) {\n\t\t\t\trtwdev->chip->ops->btc_update_bt_cnt(rtwdev);\n\t\t\t\t_chk_btc_err(rtwdev, BTC_DCNT_BTCNT_HANG, 0);\n\n\t\t\t\tbtc->cx.cnt_bt[BTC_BCNT_POLUT] =\n\t\t\t\t\trtw89_mac_get_plt_cnt(rtwdev,\n\t\t\t\t\t\t\t      RTW89_MAC_0);\n\t\t\t}\n\t\t} else if (ver->fcxbtcrpt == 4) {\n\t\t\tprpt->v4 = pfwinfo->rpt_ctrl.finfo.v4;\n\t\t\tbtc->fwinfo.rpt_en_map = le32_to_cpu(prpt->v4.rpt_info.en);\n\t\t\twl->ver_info.fw_coex = le32_to_cpu(prpt->v4.wl_fw_info.cx_ver);\n\t\t\twl->ver_info.fw = le32_to_cpu(prpt->v4.wl_fw_info.fw_ver);\n\t\t\tdm->wl_fw_cx_offload = !!le32_to_cpu(prpt->v4.wl_fw_info.cx_offload);\n\n\t\t\tfor (i = RTW89_PHY_0; i < RTW89_PHY_MAX; i++)\n\t\t\t\tmemcpy(&dm->gnt.band[i], &prpt->v4.gnt_val[i],\n\t\t\t\t       sizeof(dm->gnt.band[i]));\n\n\t\t\tbtc->cx.cnt_bt[BTC_BCNT_HIPRI_TX] =\n\t\t\t\tle32_to_cpu(prpt->v4.bt_cnt[BTC_BCNT_HI_TX]);\n\t\t\tbtc->cx.cnt_bt[BTC_BCNT_HIPRI_RX] =\n\t\t\t\tle32_to_cpu(prpt->v4.bt_cnt[BTC_BCNT_HI_RX]);\n\t\t\tbtc->cx.cnt_bt[BTC_BCNT_LOPRI_TX] =\n\t\t\t\tle32_to_cpu(prpt->v4.bt_cnt[BTC_BCNT_LO_TX]);\n\t\t\tbtc->cx.cnt_bt[BTC_BCNT_LOPRI_RX] =\n\t\t\t\tle32_to_cpu(prpt->v4.bt_cnt[BTC_BCNT_LO_RX]);\n\t\t\tbtc->cx.cnt_bt[BTC_BCNT_POLUT] =\n\t\t\t\tle32_to_cpu(prpt->v4.bt_cnt[BTC_BCNT_POLLUTED]);\n\n\t\t\t_chk_btc_err(rtwdev, BTC_DCNT_BTCNT_HANG, 0);\n\t\t\t_chk_btc_err(rtwdev, BTC_DCNT_RPT_HANG,\n\t\t\t\t     pfwinfo->event[BTF_EVNT_RPT]);\n\n\t\t\tif (le32_to_cpu(prpt->v4.bt_cnt[BTC_BCNT_RFK_TIMEOUT]) > 0)\n\t\t\t\tbt->rfk_info.map.timeout = 1;\n\t\t\telse\n\t\t\t\tbt->rfk_info.map.timeout = 0;\n\n\t\t\tdm->error.map.bt_rfk_timeout = bt->rfk_info.map.timeout;\n\t\t} else if (ver->fcxbtcrpt == 5) {\n\t\t\tprpt->v5 = pfwinfo->rpt_ctrl.finfo.v5;\n\t\t\tpfwinfo->rpt_en_map = le32_to_cpu(prpt->v5.rpt_info.en);\n\t\t\twl->ver_info.fw_coex = le32_to_cpu(prpt->v5.rpt_info.cx_ver);\n\t\t\twl->ver_info.fw = le32_to_cpu(prpt->v5.rpt_info.fw_ver);\n\t\t\tdm->wl_fw_cx_offload = 0;\n\n\t\t\tfor (i = RTW89_PHY_0; i < RTW89_PHY_MAX; i++)\n\t\t\t\tmemcpy(&dm->gnt.band[i], &prpt->v5.gnt_val[i][0],\n\t\t\t\t       sizeof(dm->gnt.band[i]));\n\n\t\t\tbtc->cx.cnt_bt[BTC_BCNT_HIPRI_TX] =\n\t\t\t\tle16_to_cpu(prpt->v5.bt_cnt[BTC_BCNT_HI_TX]);\n\t\t\tbtc->cx.cnt_bt[BTC_BCNT_HIPRI_RX] =\n\t\t\t\tle16_to_cpu(prpt->v5.bt_cnt[BTC_BCNT_HI_RX]);\n\t\t\tbtc->cx.cnt_bt[BTC_BCNT_LOPRI_TX] =\n\t\t\t\tle16_to_cpu(prpt->v5.bt_cnt[BTC_BCNT_LO_TX]);\n\t\t\tbtc->cx.cnt_bt[BTC_BCNT_LOPRI_RX] =\n\t\t\t\tle16_to_cpu(prpt->v5.bt_cnt[BTC_BCNT_LO_RX]);\n\t\t\tbtc->cx.cnt_bt[BTC_BCNT_POLUT] =\n\t\t\t\tle16_to_cpu(prpt->v5.bt_cnt[BTC_BCNT_POLLUTED]);\n\n\t\t\t_chk_btc_err(rtwdev, BTC_DCNT_BTCNT_HANG, 0);\n\t\t\t_chk_btc_err(rtwdev, BTC_DCNT_RPT_HANG,\n\t\t\t\t     pfwinfo->event[BTF_EVNT_RPT]);\n\n\t\t\tdm->error.map.bt_rfk_timeout = bt->rfk_info.map.timeout;\n\t\t} else if (ver->fcxbtcrpt == 105) {\n\t\t\tprpt->v105 = pfwinfo->rpt_ctrl.finfo.v105;\n\t\t\tpfwinfo->rpt_en_map = le32_to_cpu(prpt->v105.rpt_info.en);\n\t\t\twl->ver_info.fw_coex = le32_to_cpu(prpt->v105.rpt_info.cx_ver);\n\t\t\twl->ver_info.fw = le32_to_cpu(prpt->v105.rpt_info.fw_ver);\n\t\t\tdm->wl_fw_cx_offload = 0;\n\n\t\t\tfor (i = RTW89_PHY_0; i < RTW89_PHY_MAX; i++)\n\t\t\t\tmemcpy(&dm->gnt.band[i], &prpt->v105.gnt_val[i][0],\n\t\t\t\t       sizeof(dm->gnt.band[i]));\n\n\t\t\tbtc->cx.cnt_bt[BTC_BCNT_HIPRI_TX] =\n\t\t\t\tle16_to_cpu(prpt->v105.bt_cnt[BTC_BCNT_HI_TX_V105]);\n\t\t\tbtc->cx.cnt_bt[BTC_BCNT_HIPRI_RX] =\n\t\t\t\tle16_to_cpu(prpt->v105.bt_cnt[BTC_BCNT_HI_RX_V105]);\n\t\t\tbtc->cx.cnt_bt[BTC_BCNT_LOPRI_TX] =\n\t\t\t\tle16_to_cpu(prpt->v105.bt_cnt[BTC_BCNT_LO_TX_V105]);\n\t\t\tbtc->cx.cnt_bt[BTC_BCNT_LOPRI_RX] =\n\t\t\t\tle16_to_cpu(prpt->v105.bt_cnt[BTC_BCNT_LO_RX_V105]);\n\t\t\tbtc->cx.cnt_bt[BTC_BCNT_POLUT] =\n\t\t\t\tle16_to_cpu(prpt->v105.bt_cnt[BTC_BCNT_POLLUTED_V105]);\n\n\t\t\t_chk_btc_err(rtwdev, BTC_DCNT_BTCNT_HANG, 0);\n\t\t\t_chk_btc_err(rtwdev, BTC_DCNT_RPT_HANG,\n\t\t\t\t     pfwinfo->event[BTF_EVNT_RPT]);\n\n\t\t\tdm->error.map.bt_rfk_timeout = bt->rfk_info.map.timeout;\n\t\t} else {\n\t\t\tgoto err;\n\t\t}\n\t\tbreak;\n\tcase BTC_RPT_TYPE_TDMA:\n\t\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t\t    \"[BTC], %s(): check %d %zu\\n\", __func__,\n\t\t\t    BTC_DCNT_TDMA_NONSYNC,\n\t\t\t    sizeof(dm->tdma_now));\n\t\tif (ver->fcxtdma == 1)\n\t\t\t_chk_btc_err(rtwdev, BTC_DCNT_TDMA_NONSYNC,\n\t\t\t\t     memcmp(&dm->tdma_now,\n\t\t\t\t\t    &pfwinfo->rpt_fbtc_tdma.finfo.v1,\n\t\t\t\t\t    sizeof(dm->tdma_now)));\n\t\telse if (ver->fcxtdma == 3)\n\t\t\t_chk_btc_err(rtwdev, BTC_DCNT_TDMA_NONSYNC,\n\t\t\t\t     memcmp(&dm->tdma_now,\n\t\t\t\t\t    &pfwinfo->rpt_fbtc_tdma.finfo.v3.tdma,\n\t\t\t\t\t    sizeof(dm->tdma_now)));\n\t\telse\n\t\t\tgoto err;\n\t\tbreak;\n\tcase BTC_RPT_TYPE_SLOT:\n\t\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t\t    \"[BTC], %s(): check %d %zu\\n\",\n\t\t\t    __func__, BTC_DCNT_SLOT_NONSYNC,\n\t\t\t    sizeof(dm->slot_now));\n\t\t_chk_btc_err(rtwdev, BTC_DCNT_SLOT_NONSYNC,\n\t\t\t     memcmp(dm->slot_now,\n\t\t\t\t    pfwinfo->rpt_fbtc_slots.finfo.slot,\n\t\t\t\t    sizeof(dm->slot_now)));\n\t\tbreak;\n\tcase BTC_RPT_TYPE_CYSTA:\n\t\tif (ver->fcxcysta == 2) {\n\t\t\tif (le16_to_cpu(pcysta->v2.cycles) < BTC_CYSTA_CHK_PERIOD)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tif (le32_to_cpu(pcysta->v2.slot_cnt[CXST_LK]) != 0 &&\n\t\t\t    le32_to_cpu(pcysta->v2.leakrx_cnt) != 0 && dm->tdma_now.rxflctrl) {\n\t\t\t\tif (le32_to_cpu(pcysta->v2.slot_cnt[CXST_LK]) <\n\t\t\t\t    BTC_LEAK_AP_TH * le32_to_cpu(pcysta->v2.leakrx_cnt))\n\t\t\t\t\tdm->leak_ap = 1;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (dm->tdma_now.type == CXTDMA_OFF &&\n\t\t\t    dm->tdma_now.ext_ctrl == CXECTL_EXT)\n\t\t\t\twl_slot_set = le16_to_cpu(dm->slot_now[CXST_E2G].dur);\n\t\t\telse\n\t\t\t\twl_slot_set = le16_to_cpu(dm->slot_now[CXST_W1].dur);\n\n\t\t\tif (le16_to_cpu(pcysta->v2.tavg_cycle[CXT_WL]) > wl_slot_set) {\n\t\t\t\tdiff_t = le16_to_cpu(pcysta->v2.tavg_cycle[CXT_WL]) - wl_slot_set;\n\t\t\t\t_chk_btc_err(rtwdev,\n\t\t\t\t\t     BTC_DCNT_WL_SLOT_DRIFT, diff_t);\n\t\t\t}\n\n\t\t\t_chk_btc_err(rtwdev, BTC_DCNT_W1_HANG,\n\t\t\t\t     le32_to_cpu(pcysta->v2.slot_cnt[CXST_W1]));\n\t\t\t_chk_btc_err(rtwdev, BTC_DCNT_W1_HANG,\n\t\t\t\t     le32_to_cpu(pcysta->v2.slot_cnt[CXST_B1]));\n\t\t\t_chk_btc_err(rtwdev, BTC_DCNT_CYCLE_HANG,\n\t\t\t\t     le16_to_cpu(pcysta->v2.cycles));\n\t\t} else if (ver->fcxcysta == 3) {\n\t\t\tif (le16_to_cpu(pcysta->v3.cycles) < BTC_CYSTA_CHK_PERIOD)\n\t\t\t\tbreak;\n\n\t\t\tcnt_leak_slot = le32_to_cpu(pcysta->v3.slot_cnt[CXST_LK]);\n\t\t\tcnt_rx_imr = le32_to_cpu(pcysta->v3.leak_slot.cnt_rximr);\n\n\t\t\t \n\t\t\tif (cnt_leak_slot != 0 && cnt_rx_imr != 0 &&\n\t\t\t    dm->tdma_now.rxflctrl) {\n\t\t\t\tif (cnt_leak_slot < BTC_LEAK_AP_TH * cnt_rx_imr)\n\t\t\t\t\tdm->leak_ap = 1;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (dm->tdma_now.type == CXTDMA_OFF) {\n\t\t\t\twl_slot_set = le16_to_cpu(dm->slot_now[CXST_W1].dur);\n\t\t\t\twl_slot_real = le16_to_cpu(pcysta->v3.cycle_time.tavg[CXT_WL]);\n\t\t\t\tif (wl_slot_real > wl_slot_set) {\n\t\t\t\t\tdiff_t = wl_slot_real - wl_slot_set;\n\t\t\t\t\t_chk_btc_err(rtwdev, BTC_DCNT_WL_SLOT_DRIFT, diff_t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tif (dm->tdma_now.type == CXTDMA_OFF &&\n\t\t\t    dm->tdma_now.ext_ctrl == CXECTL_EXT &&\n\t\t\t    btc->bt_req_len != 0) {\n\t\t\t\tbt_slot_real = le16_to_cpu(pcysta->v3.cycle_time.tavg[CXT_BT]);\n\t\t\t\tif (btc->bt_req_len > bt_slot_real) {\n\t\t\t\t\tdiff_t = btc->bt_req_len - bt_slot_real;\n\t\t\t\t\t_chk_btc_err(rtwdev, BTC_DCNT_BT_SLOT_DRIFT, diff_t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_chk_btc_err(rtwdev, BTC_DCNT_W1_HANG,\n\t\t\t\t     le32_to_cpu(pcysta->v3.slot_cnt[CXST_W1]));\n\t\t\t_chk_btc_err(rtwdev, BTC_DCNT_B1_HANG,\n\t\t\t\t     le32_to_cpu(pcysta->v3.slot_cnt[CXST_B1]));\n\t\t\t_chk_btc_err(rtwdev, BTC_DCNT_CYCLE_HANG,\n\t\t\t\t     le16_to_cpu(pcysta->v3.cycles));\n\t\t} else if (ver->fcxcysta == 4) {\n\t\t\tif (le16_to_cpu(pcysta->v4.cycles) < BTC_CYSTA_CHK_PERIOD)\n\t\t\t\tbreak;\n\n\t\t\tcnt_leak_slot = le16_to_cpu(pcysta->v4.slot_cnt[CXST_LK]);\n\t\t\tcnt_rx_imr = le32_to_cpu(pcysta->v4.leak_slot.cnt_rximr);\n\n\t\t\t \n\t\t\tif (cnt_leak_slot != 0 && cnt_rx_imr != 0 &&\n\t\t\t    dm->tdma_now.rxflctrl) {\n\t\t\t\tif (cnt_leak_slot < BTC_LEAK_AP_TH * cnt_rx_imr)\n\t\t\t\t\tdm->leak_ap = 1;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (dm->tdma_now.type == CXTDMA_OFF) {\n\t\t\t\twl_slot_set = le16_to_cpu(dm->slot_now[CXST_W1].dur);\n\t\t\t\twl_slot_real = le16_to_cpu(pcysta->v4.cycle_time.tavg[CXT_WL]);\n\t\t\t\tif (wl_slot_real > wl_slot_set) {\n\t\t\t\t\tdiff_t = wl_slot_real - wl_slot_set;\n\t\t\t\t\t_chk_btc_err(rtwdev, BTC_DCNT_WL_SLOT_DRIFT, diff_t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tif (dm->tdma_now.type == CXTDMA_OFF &&\n\t\t\t    dm->tdma_now.ext_ctrl == CXECTL_EXT &&\n\t\t\t    btc->bt_req_len != 0) {\n\t\t\t\tbt_slot_real = le16_to_cpu(pcysta->v4.cycle_time.tavg[CXT_BT]);\n\n\t\t\t\tif (btc->bt_req_len > bt_slot_real) {\n\t\t\t\t\tdiff_t = btc->bt_req_len - bt_slot_real;\n\t\t\t\t\t_chk_btc_err(rtwdev, BTC_DCNT_BT_SLOT_DRIFT, diff_t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_chk_btc_err(rtwdev, BTC_DCNT_W1_HANG,\n\t\t\t\t     le16_to_cpu(pcysta->v4.slot_cnt[CXST_W1]));\n\t\t\t_chk_btc_err(rtwdev, BTC_DCNT_B1_HANG,\n\t\t\t\t     le16_to_cpu(pcysta->v4.slot_cnt[CXST_B1]));\n\t\t\t_chk_btc_err(rtwdev, BTC_DCNT_CYCLE_HANG,\n\t\t\t\t     le16_to_cpu(pcysta->v4.cycles));\n\t\t} else if (ver->fcxcysta == 5) {\n\t\t\tif (dm->fddt_train == BTC_FDDT_ENABLE)\n\t\t\t\tbreak;\n\t\t\tcnt_leak_slot = le16_to_cpu(pcysta->v5.slot_cnt[CXST_LK]);\n\t\t\tcnt_rx_imr = le32_to_cpu(pcysta->v5.leak_slot.cnt_rximr);\n\n\t\t\t \n\t\t\tif (cnt_leak_slot != 0 && cnt_rx_imr != 0 &&\n\t\t\t    dm->tdma_now.rxflctrl) {\n\t\t\t\tif (le16_to_cpu(pcysta->v5.cycles) >= BTC_CYSTA_CHK_PERIOD &&\n\t\t\t\t    cnt_leak_slot < BTC_LEAK_AP_TH * cnt_rx_imr)\n\t\t\t\t\tdm->leak_ap = 1;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (dm->tdma_now.type == CXTDMA_OFF) {\n\t\t\t\twl_slot_set = le16_to_cpu(dm->slot_now[CXST_W1].dur);\n\t\t\t\twl_slot_real = le16_to_cpu(pcysta->v5.cycle_time.tavg[CXT_WL]);\n\n\t\t\t\tif (wl_slot_real > wl_slot_set)\n\t\t\t\t\tdiff_t = wl_slot_real - wl_slot_set;\n\t\t\t\telse\n\t\t\t\t\tdiff_t = wl_slot_set - wl_slot_real;\n\t\t\t}\n\t\t\t_chk_btc_err(rtwdev, BTC_DCNT_WL_SLOT_DRIFT, diff_t);\n\n\t\t\t \n\t\t\tbt_slot_set = btc->bt_req_len;\n\t\t\tbt_slot_real = le16_to_cpu(pcysta->v5.cycle_time.tavg[CXT_BT]);\n\t\t\tdiff_t = 0;\n\t\t\tif (dm->tdma_now.type == CXTDMA_OFF &&\n\t\t\t    dm->tdma_now.ext_ctrl == CXECTL_EXT &&\n\t\t\t    bt_slot_set != 0) {\n\t\t\t\tif (bt_slot_set > bt_slot_real)\n\t\t\t\t\tdiff_t = bt_slot_set - bt_slot_real;\n\t\t\t\telse\n\t\t\t\t\tdiff_t = bt_slot_real - bt_slot_set;\n\t\t\t}\n\n\t\t\t_chk_btc_err(rtwdev, BTC_DCNT_BT_SLOT_DRIFT, diff_t);\n\t\t\t_chk_btc_err(rtwdev, BTC_DCNT_E2G_HANG,\n\t\t\t\t     le16_to_cpu(pcysta->v5.slot_cnt[CXST_E2G]));\n\t\t\t_chk_btc_err(rtwdev, BTC_DCNT_W1_HANG,\n\t\t\t\t     le16_to_cpu(pcysta->v5.slot_cnt[CXST_W1]));\n\t\t\t_chk_btc_err(rtwdev, BTC_DCNT_B1_HANG,\n\t\t\t\t     le16_to_cpu(pcysta->v5.slot_cnt[CXST_B1]));\n\t\t\t_chk_btc_err(rtwdev, BTC_DCNT_CYCLE_HANG,\n\t\t\t\t     le16_to_cpu(pcysta->v5.cycles));\n\t\t} else {\n\t\t\tgoto err;\n\t\t}\n\t\tbreak;\n\tcase BTC_RPT_TYPE_BT_VER:\n\tcase BTC_RPT_TYPE_BT_SCAN:\n\tcase BTC_RPT_TYPE_BT_AFH:\n\tcase BTC_RPT_TYPE_BT_DEVICE:\n\t\t_update_bt_report(rtwdev, rpt_type, pfinfo);\n\t\tbreak;\n\t}\n\treturn (rpt_len + BTC_RPT_HDR_SIZE);\n\nerr:\n\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t    \"[BTC], %s(): Undefined version for type=%d\\n\", __func__, rpt_type);\n\treturn 0;\n}\n\nstatic void _parse_btc_report(struct rtw89_dev *rtwdev,\n\t\t\t      struct rtw89_btc_btf_fwinfo *pfwinfo,\n\t\t\t      u8 *pbuf, u32 buf_len)\n{\n\tconst struct rtw89_btc_ver *ver = rtwdev->btc.ver;\n\tstruct rtw89_btc_prpt *btc_prpt = NULL;\n\tu32 index = 0, rpt_len = 0;\n\n\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t    \"[BTC], %s(): buf_len:%d\\n\",\n\t\t    __func__, buf_len);\n\n\twhile (pbuf) {\n\t\tbtc_prpt = (struct rtw89_btc_prpt *)&pbuf[index];\n\t\tif (index + 2 >= ver->info_buf)\n\t\t\tbreak;\n\t\t \n\t\trpt_len = le16_to_cpu(btc_prpt->len);\n\t\tif ((index + rpt_len + BTC_RPT_HDR_SIZE) > buf_len)\n\t\t\tbreak;\n\n\t\trpt_len = _chk_btc_report(rtwdev, pfwinfo, pbuf, index);\n\t\tif (!rpt_len)\n\t\t\tbreak;\n\t\tindex += rpt_len;\n\t}\n}\n\n#define BTC_TLV_HDR_LEN 2\n\nstatic void _append_tdma(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tconst struct rtw89_btc_ver *ver = btc->ver;\n\tstruct rtw89_btc_dm *dm = &btc->dm;\n\tstruct rtw89_btc_btf_tlv *tlv;\n\tstruct rtw89_btc_fbtc_tdma *v;\n\tstruct rtw89_btc_fbtc_tdma_v3 *v3;\n\tu16 len = btc->policy_len;\n\n\tif (!btc->update_policy_force &&\n\t    !memcmp(&dm->tdma, &dm->tdma_now, sizeof(dm->tdma))) {\n\t\trtw89_debug(rtwdev,\n\t\t\t    RTW89_DBG_BTC, \"[BTC], %s(): tdma no change!\\n\",\n\t\t\t    __func__);\n\t\treturn;\n\t}\n\n\ttlv = (struct rtw89_btc_btf_tlv *)&btc->policy[len];\n\ttlv->type = CXPOLICY_TDMA;\n\tif (ver->fcxtdma == 1) {\n\t\tv = (struct rtw89_btc_fbtc_tdma *)&tlv->val[0];\n\t\ttlv->len = sizeof(*v);\n\t\tmemcpy(v, &dm->tdma, sizeof(*v));\n\t\tbtc->policy_len += BTC_TLV_HDR_LEN + sizeof(*v);\n\t} else {\n\t\ttlv->len = sizeof(*v3);\n\t\tv3 = (struct rtw89_btc_fbtc_tdma_v3 *)&tlv->val[0];\n\t\tv3->fver = ver->fcxtdma;\n\t\tmemcpy(&v3->tdma, &dm->tdma, sizeof(v3->tdma));\n\t\tbtc->policy_len += BTC_TLV_HDR_LEN + sizeof(*v3);\n\t}\n\n\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t    \"[BTC], %s(): type:%d, rxflctrl=%d, txpause=%d, wtgle_n=%d, leak_n=%d, ext_ctrl=%d\\n\",\n\t\t    __func__, dm->tdma.type, dm->tdma.rxflctrl,\n\t\t    dm->tdma.txpause, dm->tdma.wtgle_n, dm->tdma.leak_n,\n\t\t    dm->tdma.ext_ctrl);\n}\n\nstatic void _append_slot(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_dm *dm = &btc->dm;\n\tstruct rtw89_btc_btf_tlv *tlv = NULL;\n\tstruct btc_fbtc_1slot *v = NULL;\n\tu16 len = 0;\n\tu8 i, cnt = 0;\n\n\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t    \"[BTC], %s(): A:btc->policy_len = %d\\n\",\n\t\t    __func__, btc->policy_len);\n\n\tfor (i = 0; i < CXST_MAX; i++) {\n\t\tif (!btc->update_policy_force &&\n\t\t    !memcmp(&dm->slot[i], &dm->slot_now[i],\n\t\t\t    sizeof(dm->slot[i])))\n\t\t\tcontinue;\n\n\t\tlen = btc->policy_len;\n\n\t\ttlv = (struct rtw89_btc_btf_tlv *)&btc->policy[len];\n\t\tv = (struct btc_fbtc_1slot *)&tlv->val[0];\n\t\ttlv->type = CXPOLICY_SLOT;\n\t\ttlv->len = sizeof(*v);\n\n\t\tv->fver = FCXONESLOT_VER;\n\t\tv->sid = i;\n\t\tv->slot = dm->slot[i];\n\n\t\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t\t    \"[BTC], %s(): slot-%d: dur=%d, table=0x%08x, type=%d\\n\",\n\t\t\t    __func__, i, dm->slot[i].dur, dm->slot[i].cxtbl,\n\t\t\t    dm->slot[i].cxtype);\n\t\tcnt++;\n\n\t\tbtc->policy_len += BTC_TLV_HDR_LEN  + sizeof(*v);\n\t}\n\n\tif (cnt > 0)\n\t\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t\t    \"[BTC], %s(): slot update (cnt=%d)!!\\n\",\n\t\t\t    __func__, cnt);\n}\n\nstatic u32 rtw89_btc_fw_rpt_ver(struct rtw89_dev *rtwdev, u32 rpt_map)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tconst struct rtw89_btc_ver *ver = btc->ver;\n\tu32 bit_map = 0;\n\n\tswitch (rpt_map) {\n\tcase RPT_EN_TDMA:\n\t\tbit_map = BIT(0);\n\t\tbreak;\n\tcase RPT_EN_CYCLE:\n\t\tbit_map = BIT(1);\n\t\tbreak;\n\tcase RPT_EN_MREG:\n\t\tbit_map = BIT(2);\n\t\tbreak;\n\tcase RPT_EN_BT_VER_INFO:\n\t\tbit_map = BIT(3);\n\t\tbreak;\n\tcase RPT_EN_BT_SCAN_INFO:\n\t\tbit_map = BIT(4);\n\t\tbreak;\n\tcase RPT_EN_BT_DEVICE_INFO:\n\t\tswitch (ver->frptmap) {\n\t\tcase 0:\n\t\tcase 1:\n\t\tcase 2:\n\t\t\tbit_map = BIT(6);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tbit_map = BIT(5);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase RPT_EN_BT_AFH_MAP:\n\t\tswitch (ver->frptmap) {\n\t\tcase 0:\n\t\tcase 1:\n\t\tcase 2:\n\t\t\tbit_map = BIT(5);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tbit_map = BIT(6);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase RPT_EN_BT_AFH_MAP_LE:\n\t\tswitch (ver->frptmap) {\n\t\tcase 2:\n\t\t\tbit_map = BIT(8);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tbit_map = BIT(7);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase RPT_EN_FW_STEP_INFO:\n\t\tswitch (ver->frptmap) {\n\t\tcase 1:\n\t\tcase 2:\n\t\t\tbit_map = BIT(7);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tbit_map = BIT(8);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase RPT_EN_TEST:\n\t\tbit_map = BIT(31);\n\t\tbreak;\n\tcase RPT_EN_WL_ALL:\n\t\tswitch (ver->frptmap) {\n\t\tcase 0:\n\t\tcase 1:\n\t\tcase 2:\n\t\t\tbit_map = GENMASK(2, 0);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tbit_map = GENMASK(2, 0) | BIT(8);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase RPT_EN_BT_ALL:\n\t\tswitch (ver->frptmap) {\n\t\tcase 0:\n\t\tcase 1:\n\t\t\tbit_map = GENMASK(6, 3);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tbit_map = GENMASK(6, 3) | BIT(8);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tbit_map = GENMASK(7, 3);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase RPT_EN_ALL:\n\t\tswitch (ver->frptmap) {\n\t\tcase 0:\n\t\t\tbit_map = GENMASK(6, 0);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tbit_map = GENMASK(7, 0);\n\t\t\tbreak;\n\t\tcase 2:\n\t\tcase 3:\n\t\t\tbit_map = GENMASK(8, 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase RPT_EN_MONITER:\n\t\tswitch (ver->frptmap) {\n\t\tcase 0:\n\t\tcase 1:\n\t\t\tbit_map = GENMASK(6, 2);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tbit_map = GENMASK(6, 2) | BIT(8);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tbit_map = GENMASK(8, 2);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn bit_map;\n}\n\nstatic void rtw89_btc_fw_en_rpt(struct rtw89_dev *rtwdev,\n\t\t\t\tu32 rpt_map, bool rpt_state)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_wl_smap *wl_smap = &btc->cx.wl.status.map;\n\tstruct rtw89_btc_btf_fwinfo *fwinfo = &btc->fwinfo;\n\tstruct rtw89_btc_btf_set_report r = {0};\n\tu32 val, bit_map;\n\n\tif ((wl_smap->rf_off || wl_smap->lps != BTC_LPS_OFF) && rpt_state != 0)\n\t\treturn;\n\n\tbit_map = rtw89_btc_fw_rpt_ver(rtwdev, rpt_map);\n\n\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t    \"[BTC], %s(): rpt_map=%x, rpt_state=%x\\n\",\n\t\t    __func__, rpt_map, rpt_state);\n\n\tif (rpt_state)\n\t\tval = fwinfo->rpt_en_map | bit_map;\n\telse\n\t\tval = fwinfo->rpt_en_map & ~bit_map;\n\n\tif (val == fwinfo->rpt_en_map)\n\t\treturn;\n\n\tfwinfo->rpt_en_map = val;\n\n\tr.fver = BTF_SET_REPORT_VER;\n\tr.enable = cpu_to_le32(val);\n\tr.para = cpu_to_le32(rpt_state);\n\n\t_send_fw_cmd(rtwdev, BTFC_SET, SET_REPORT_EN, &r, sizeof(r));\n}\n\nstatic void rtw89_btc_fw_set_slots(struct rtw89_dev *rtwdev, u8 num,\n\t\t\t\t   struct rtw89_btc_fbtc_slot *s)\n{\n\tstruct rtw89_btc_btf_set_slot_table *tbl = NULL;\n\tu8 *ptr = NULL;\n\tu16 n = 0;\n\n\tn = sizeof(*s) * num + sizeof(*tbl);\n\ttbl = kmalloc(n, GFP_KERNEL);\n\tif (!tbl)\n\t\treturn;\n\n\ttbl->fver = BTF_SET_SLOT_TABLE_VER;\n\ttbl->tbl_num = num;\n\tptr = &tbl->buf[0];\n\tmemcpy(ptr, s, num * sizeof(*s));\n\n\t_send_fw_cmd(rtwdev, BTFC_SET, SET_SLOT_TABLE, tbl, n);\n\n\tkfree(tbl);\n}\n\nstatic void btc_fw_set_monreg(struct rtw89_dev *rtwdev)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tconst struct rtw89_btc_ver *ver = rtwdev->btc.ver;\n\tstruct rtw89_btc_btf_set_mon_reg *monreg = NULL;\n\tu8 n, *ptr = NULL, ulen, cxmreg_max;\n\tu16 sz = 0;\n\n\tn = chip->mon_reg_num;\n\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t    \"[BTC], %s(): mon_reg_num=%d\\n\", __func__, n);\n\n\tif (ver->fcxmreg == 1)\n\t\tcxmreg_max = CXMREG_MAX;\n\telse if (ver->fcxmreg == 2)\n\t\tcxmreg_max = CXMREG_MAX_V2;\n\telse\n\t\treturn;\n\n\tif (n > cxmreg_max) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t\t    \"[BTC], %s(): mon reg count %d > %d\\n\",\n\t\t\t    __func__, n, cxmreg_max);\n\t\treturn;\n\t}\n\n\tulen = sizeof(struct rtw89_btc_fbtc_mreg);\n\tsz = (ulen * n) + sizeof(*monreg);\n\tmonreg = kmalloc(sz, GFP_KERNEL);\n\tif (!monreg)\n\t\treturn;\n\n\tmonreg->fver = ver->fcxmreg;\n\tmonreg->reg_num = n;\n\tptr = &monreg->buf[0];\n\tmemcpy(ptr, chip->mon_reg, n * ulen);\n\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t    \"[BTC], %s(): sz=%d ulen=%d n=%d\\n\",\n\t\t    __func__, sz, ulen, n);\n\n\t_send_fw_cmd(rtwdev, BTFC_SET, SET_MREG_TABLE, (u8 *)monreg, sz);\n\tkfree(monreg);\n\trtw89_btc_fw_en_rpt(rtwdev, RPT_EN_MREG, 1);\n}\n\nstatic void _update_dm_step(struct rtw89_dev *rtwdev,\n\t\t\t    enum btc_reason_and_action reason_or_action)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_dm *dm = &btc->dm;\n\n\t \n\tdm->dm_step.step[dm->dm_step.step_pos] = reason_or_action;\n\tdm->dm_step.step_pos++;\n\n\tif (dm->dm_step.step_pos >= ARRAY_SIZE(dm->dm_step.step)) {\n\t\tdm->dm_step.step_pos = 0;\n\t\tdm->dm_step.step_ov = true;\n\t}\n}\n\nstatic void _fw_set_policy(struct rtw89_dev *rtwdev, u16 policy_type,\n\t\t\t   enum btc_reason_and_action action)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_dm *dm = &btc->dm;\n\n\tdm->run_action = action;\n\n\t_update_dm_step(rtwdev, action | BTC_ACT_EXT_BIT);\n\t_update_dm_step(rtwdev, policy_type | BTC_POLICY_EXT_BIT);\n\n\tbtc->policy_len = 0;\n\tbtc->policy_type = policy_type;\n\n\t_append_tdma(rtwdev);\n\t_append_slot(rtwdev);\n\n\tif (btc->policy_len == 0 || btc->policy_len > RTW89_BTC_POLICY_MAXLEN)\n\t\treturn;\n\n\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t    \"[BTC], %s(): action = %d -> policy type/len: 0x%04x/%d\\n\",\n\t\t    __func__, action, policy_type, btc->policy_len);\n\n\tif (dm->tdma.rxflctrl == CXFLC_NULLP ||\n\t    dm->tdma.rxflctrl == CXFLC_QOSNULL)\n\t\tbtc->lps = 1;\n\telse\n\t\tbtc->lps = 0;\n\n\tif (btc->lps == 1)\n\t\trtw89_set_coex_ctrl_lps(rtwdev, btc->lps);\n\n\t_send_fw_cmd(rtwdev, BTFC_SET, SET_CX_POLICY,\n\t\t     btc->policy, btc->policy_len);\n\n\tmemcpy(&dm->tdma_now, &dm->tdma, sizeof(dm->tdma_now));\n\tmemcpy(&dm->slot_now, &dm->slot, sizeof(dm->slot_now));\n\n\tif (btc->update_policy_force)\n\t\tbtc->update_policy_force = false;\n\n\tif (btc->lps == 0)\n\t\trtw89_set_coex_ctrl_lps(rtwdev, btc->lps);\n}\n\nstatic void _fw_set_drv_info(struct rtw89_dev *rtwdev, u8 type)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tconst struct rtw89_btc_ver *ver = btc->ver;\n\tstruct rtw89_btc_dm *dm = &btc->dm;\n\tstruct rtw89_btc_wl_info *wl = &btc->cx.wl;\n\tstruct rtw89_btc_rf_trx_para rf_para = dm->rf_trx_para;\n\n\tswitch (type) {\n\tcase CXDRVINFO_INIT:\n\t\trtw89_fw_h2c_cxdrv_init(rtwdev);\n\t\tbreak;\n\tcase CXDRVINFO_ROLE:\n\t\tif (ver->fwlrole == 0)\n\t\t\trtw89_fw_h2c_cxdrv_role(rtwdev);\n\t\telse if (ver->fwlrole == 1)\n\t\t\trtw89_fw_h2c_cxdrv_role_v1(rtwdev);\n\t\telse if (ver->fwlrole == 2)\n\t\t\trtw89_fw_h2c_cxdrv_role_v2(rtwdev);\n\t\tbreak;\n\tcase CXDRVINFO_CTRL:\n\t\trtw89_fw_h2c_cxdrv_ctrl(rtwdev);\n\t\tbreak;\n\tcase CXDRVINFO_TRX:\n\t\tdm->trx_info.tx_power = u32_get_bits(rf_para.wl_tx_power,\n\t\t\t\t\t\t     RTW89_BTC_WL_DEF_TX_PWR);\n\t\tdm->trx_info.rx_gain = u32_get_bits(rf_para.wl_rx_gain,\n\t\t\t\t\t\t    RTW89_BTC_WL_DEF_TX_PWR);\n\t\tdm->trx_info.bt_tx_power = u32_get_bits(rf_para.bt_tx_power,\n\t\t\t\t\t\t\tRTW89_BTC_WL_DEF_TX_PWR);\n\t\tdm->trx_info.bt_rx_gain = u32_get_bits(rf_para.bt_rx_gain,\n\t\t\t\t\t\t       RTW89_BTC_WL_DEF_TX_PWR);\n\t\tdm->trx_info.cn = wl->cn_report;\n\t\tdm->trx_info.nhm = wl->nhm.pwr;\n\t\trtw89_fw_h2c_cxdrv_trx(rtwdev);\n\t\tbreak;\n\tcase CXDRVINFO_RFK:\n\t\trtw89_fw_h2c_cxdrv_rfk(rtwdev);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic\nvoid btc_fw_event(struct rtw89_dev *rtwdev, u8 evt_id, void *data, u32 len)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_btf_fwinfo *pfwinfo = &btc->fwinfo;\n\n\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t    \"[BTC], %s(): evt_id:%d len:%d\\n\",\n\t\t    __func__, evt_id, len);\n\n\tif (!len || !data)\n\t\treturn;\n\n\tswitch (evt_id) {\n\tcase BTF_EVNT_RPT:\n\t\t_parse_btc_report(rtwdev, pfwinfo, data, len);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void _set_gnt(struct rtw89_dev *rtwdev, u8 phy_map, u8 wl_state, u8 bt_state)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_dm *dm = &btc->dm;\n\tstruct rtw89_mac_ax_gnt *g = dm->gnt.band;\n\tu8 i;\n\n\tif (phy_map > BTC_PHY_ALL)\n\t\treturn;\n\n\tfor (i = 0; i < RTW89_PHY_MAX; i++) {\n\t\tif (!(phy_map & BIT(i)))\n\t\t\tcontinue;\n\n\t\tswitch (wl_state) {\n\t\tcase BTC_GNT_HW:\n\t\t\tg[i].gnt_wl_sw_en = 0;\n\t\t\tg[i].gnt_wl = 0;\n\t\t\tbreak;\n\t\tcase BTC_GNT_SW_LO:\n\t\t\tg[i].gnt_wl_sw_en = 1;\n\t\t\tg[i].gnt_wl = 0;\n\t\t\tbreak;\n\t\tcase BTC_GNT_SW_HI:\n\t\t\tg[i].gnt_wl_sw_en = 1;\n\t\t\tg[i].gnt_wl = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (bt_state) {\n\t\tcase BTC_GNT_HW:\n\t\t\tg[i].gnt_bt_sw_en = 0;\n\t\t\tg[i].gnt_bt = 0;\n\t\t\tbreak;\n\t\tcase BTC_GNT_SW_LO:\n\t\t\tg[i].gnt_bt_sw_en = 1;\n\t\t\tg[i].gnt_bt = 0;\n\t\t\tbreak;\n\t\tcase BTC_GNT_SW_HI:\n\t\t\tg[i].gnt_bt_sw_en = 1;\n\t\t\tg[i].gnt_bt = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trtw89_chip_mac_cfg_gnt(rtwdev, &dm->gnt);\n}\n\n#define BTC_TDMA_WLROLE_MAX 2\n\nstatic void _set_bt_ignore_wlan_act(struct rtw89_dev *rtwdev, u8 enable)\n{\n\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t    \"[BTC], %s(): set bt %s wlan_act\\n\", __func__,\n\t\t    enable ? \"ignore\" : \"do not ignore\");\n\n\t_send_fw_cmd(rtwdev, BTFC_SET, SET_BT_IGNORE_WLAN_ACT, &enable, 1);\n}\n\n#define WL_TX_POWER_NO_BTC_CTRL\tGENMASK(31, 0)\n#define WL_TX_POWER_ALL_TIME GENMASK(15, 0)\n#define WL_TX_POWER_WITH_BT GENMASK(31, 16)\n#define WL_TX_POWER_INT_PART GENMASK(8, 2)\n#define WL_TX_POWER_FRA_PART GENMASK(1, 0)\n#define B_BTC_WL_TX_POWER_SIGN BIT(7)\n#define B_TSSI_WL_TX_POWER_SIGN BIT(8)\n\nstatic void _set_wl_tx_power(struct rtw89_dev *rtwdev, u32 level)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_wl_info *wl = &btc->cx.wl;\n\tu32 pwr_val;\n\n\tif (wl->rf_para.tx_pwr_freerun == level)\n\t\treturn;\n\n\twl->rf_para.tx_pwr_freerun = level;\n\tbtc->dm.rf_trx_para.wl_tx_power = level;\n\n\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t    \"[BTC], %s(): level = %d\\n\",\n\t\t    __func__, level);\n\n\tif (level == RTW89_BTC_WL_DEF_TX_PWR) {\n\t\tpwr_val = WL_TX_POWER_NO_BTC_CTRL;\n\t} else {  \n\t\tpwr_val = FIELD_PREP(WL_TX_POWER_INT_PART, level);\n\t\tif (pwr_val > RTW89_BTC_WL_DEF_TX_PWR)\n\t\t\tpwr_val = RTW89_BTC_WL_DEF_TX_PWR;\n\n\t\tif (level & B_BTC_WL_TX_POWER_SIGN)\n\t\t\tpwr_val |= B_TSSI_WL_TX_POWER_SIGN;\n\t\tpwr_val |= WL_TX_POWER_WITH_BT;\n\t}\n\n\tchip->ops->btc_set_wl_txpwr_ctrl(rtwdev, pwr_val);\n}\n\nstatic void _set_wl_rx_gain(struct rtw89_dev *rtwdev, u32 level)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_wl_info *wl = &btc->cx.wl;\n\n\tif (wl->rf_para.rx_gain_freerun == level)\n\t\treturn;\n\n\twl->rf_para.rx_gain_freerun = level;\n\tbtc->dm.rf_trx_para.wl_rx_gain = level;\n\n\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t    \"[BTC], %s(): level = %d\\n\",\n\t\t    __func__, level);\n\n\tchip->ops->btc_set_wl_rx_gain(rtwdev, level);\n}\n\nstatic void _set_bt_tx_power(struct rtw89_dev *rtwdev, u8 level)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_bt_info *bt = &btc->cx.bt;\n\tu8 buf;\n\n\tif (bt->rf_para.tx_pwr_freerun == level)\n\t\treturn;\n\n\tbt->rf_para.tx_pwr_freerun = level;\n\tbtc->dm.rf_trx_para.bt_tx_power = level;\n\n\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t    \"[BTC], %s(): level = %d\\n\",\n\t\t    __func__, level);\n\n\tbuf = (s8)(-level);\n\t_send_fw_cmd(rtwdev, BTFC_SET, SET_BT_TX_PWR, &buf, 1);\n}\n\n#define BTC_BT_RX_NORMAL_LVL 7\n\nstatic void _set_bt_rx_gain(struct rtw89_dev *rtwdev, u8 level)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_bt_info *bt = &btc->cx.bt;\n\n\tif (bt->rf_para.rx_gain_freerun == level ||\n\t    level > BTC_BT_RX_NORMAL_LVL)\n\t\treturn;\n\n\tbt->rf_para.rx_gain_freerun = level;\n\tbtc->dm.rf_trx_para.bt_rx_gain = level;\n\n\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t    \"[BTC], %s(): level = %d\\n\",\n\t\t    __func__, level);\n\n\tif (level == BTC_BT_RX_NORMAL_LVL)\n\t\t_write_scbd(rtwdev, BTC_WSCB_RXGAIN, false);\n\telse\n\t\t_write_scbd(rtwdev, BTC_WSCB_RXGAIN, true);\n\n\t_send_fw_cmd(rtwdev, BTFC_SET, SET_BT_LNA_CONSTRAIN, &level, 1);\n}\n\nstatic void _set_rf_trx_para(struct rtw89_dev *rtwdev)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_dm *dm = &btc->dm;\n\tstruct rtw89_btc_wl_info *wl = &btc->cx.wl;\n\tstruct rtw89_btc_bt_info *bt = &btc->cx.bt;\n\tstruct rtw89_btc_bt_link_info *b = &bt->link_info;\n\tstruct rtw89_btc_rf_trx_para para;\n\tu32 wl_stb_chg = 0;\n\tu8 level_id = 0;\n\n\tif (!dm->freerun) {\n\t\t \n\t\tif ((btc->dm.wl_btg_rx && b->profile_cnt.now != 0) ||\n\t\t    dm->bt_only == 1)\n\t\t\tdm->trx_para_level = 1;\n\t\telse\n\t\t\tdm->trx_para_level = 0;\n\t}\n\n\tlevel_id = (u8)dm->trx_para_level;\n\n\tif (level_id >= chip->rf_para_dlink_num ||\n\t    level_id >= chip->rf_para_ulink_num) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t\t    \"[BTC], %s(): invalid level_id: %d\\n\",\n\t\t\t    __func__, level_id);\n\t\treturn;\n\t}\n\n\tif (wl->status.map.traffic_dir & BIT(RTW89_TFC_UL))\n\t\tpara = chip->rf_para_ulink[level_id];\n\telse\n\t\tpara = chip->rf_para_dlink[level_id];\n\n\tif (para.wl_tx_power != RTW89_BTC_WL_DEF_TX_PWR)\n\t\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t\t    \"[BTC], %s(): wl_tx_power=%d\\n\",\n\t\t\t    __func__, para.wl_tx_power);\n\t_set_wl_tx_power(rtwdev, para.wl_tx_power);\n\t_set_wl_rx_gain(rtwdev, para.wl_rx_gain);\n\t_set_bt_tx_power(rtwdev, para.bt_tx_power);\n\t_set_bt_rx_gain(rtwdev, para.bt_rx_gain);\n\n\tif (bt->enable.now == 0 || wl->status.map.rf_off == 1 ||\n\t    wl->status.map.lps == BTC_LPS_RF_OFF)\n\t\twl_stb_chg = 0;\n\telse\n\t\twl_stb_chg = 1;\n\n\tif (wl_stb_chg != dm->wl_stb_chg) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t\t    \"[BTC], %s(): wl_stb_chg=%d\\n\",\n\t\t\t    __func__, wl_stb_chg);\n\t\tdm->wl_stb_chg = wl_stb_chg;\n\t\tchip->ops->btc_wl_s1_standby(rtwdev, dm->wl_stb_chg);\n\t}\n}\n\nstatic void _update_btc_state_map(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_cx *cx = &btc->cx;\n\tstruct rtw89_btc_wl_info *wl = &cx->wl;\n\tstruct rtw89_btc_bt_info *bt = &cx->bt;\n\tstruct rtw89_btc_bt_link_info *bt_linfo = &bt->link_info;\n\n\tif (wl->status.map.connecting || wl->status.map._4way ||\n\t    wl->status.map.roaming) {\n\t\tcx->state_map = BTC_WLINKING;\n\t} else if (wl->status.map.scan) {  \n\t\tif (bt_linfo->status.map.inq_pag)\n\t\t\tcx->state_map = BTC_WSCAN_BSCAN;\n\t\telse\n\t\t\tcx->state_map = BTC_WSCAN_BNOSCAN;\n\t} else if (wl->status.map.busy) {  \n\t\tif (bt_linfo->status.map.inq_pag)\n\t\t\tcx->state_map = BTC_WBUSY_BSCAN;\n\t\telse\n\t\t\tcx->state_map = BTC_WBUSY_BNOSCAN;\n\t} else {  \n\t\tcx->state_map = BTC_WIDLE;\n\t}\n}\n\nstatic void _set_bt_afh_info(struct rtw89_dev *rtwdev)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tconst struct rtw89_btc_ver *ver = btc->ver;\n\tstruct rtw89_btc_wl_info *wl = &btc->cx.wl;\n\tstruct rtw89_btc_bt_info *bt = &btc->cx.bt;\n\tstruct rtw89_btc_bt_link_info *b = &bt->link_info;\n\tstruct rtw89_btc_wl_role_info *wl_rinfo = &wl->role_info;\n\tstruct rtw89_btc_wl_role_info_v1 *wl_rinfo_v1 = &wl->role_info_v1;\n\tstruct rtw89_btc_wl_role_info_v2 *wl_rinfo_v2 = &wl->role_info_v2;\n\tstruct rtw89_btc_wl_active_role *r;\n\tstruct rtw89_btc_wl_active_role_v1 *r1;\n\tstruct rtw89_btc_wl_active_role_v2 *r2;\n\tu8 en = 0, i, ch = 0, bw = 0;\n\tu8 mode, connect_cnt;\n\n\tif (btc->ctrl.manual || wl->status.map.scan)\n\t\treturn;\n\n\tif (ver->fwlrole == 0) {\n\t\tmode = wl_rinfo->link_mode;\n\t\tconnect_cnt = wl_rinfo->connect_cnt;\n\t} else if (ver->fwlrole == 1) {\n\t\tmode = wl_rinfo_v1->link_mode;\n\t\tconnect_cnt = wl_rinfo_v1->connect_cnt;\n\t} else if (ver->fwlrole == 2) {\n\t\tmode = wl_rinfo_v2->link_mode;\n\t\tconnect_cnt = wl_rinfo_v2->connect_cnt;\n\t} else {\n\t\treturn;\n\t}\n\n\tif (wl->status.map.rf_off || bt->whql_test ||\n\t    mode == BTC_WLINK_NOLINK || mode == BTC_WLINK_5G ||\n\t    connect_cnt > BTC_TDMA_WLROLE_MAX) {\n\t\ten = false;\n\t} else if (mode == BTC_WLINK_2G_MCC || mode == BTC_WLINK_2G_SCC) {\n\t\ten = true;\n\t\t \n\t\tfor (i = 0; i < RTW89_PORT_NUM; i++) {\n\t\t\tr = &wl_rinfo->active_role[i];\n\t\t\tr1 = &wl_rinfo_v1->active_role_v1[i];\n\t\t\tr2 = &wl_rinfo_v2->active_role_v2[i];\n\n\t\t\tif (ver->fwlrole == 0 &&\n\t\t\t    (r->role == RTW89_WIFI_ROLE_P2P_GO ||\n\t\t\t     r->role == RTW89_WIFI_ROLE_P2P_CLIENT)) {\n\t\t\t\tch = r->ch;\n\t\t\t\tbw = r->bw;\n\t\t\t\tbreak;\n\t\t\t} else if (ver->fwlrole == 1 &&\n\t\t\t\t   (r1->role == RTW89_WIFI_ROLE_P2P_GO ||\n\t\t\t\t    r1->role == RTW89_WIFI_ROLE_P2P_CLIENT)) {\n\t\t\t\tch = r1->ch;\n\t\t\t\tbw = r1->bw;\n\t\t\t\tbreak;\n\t\t\t} else if (ver->fwlrole == 2 &&\n\t\t\t\t   (r2->role == RTW89_WIFI_ROLE_P2P_GO ||\n\t\t\t\t    r2->role == RTW89_WIFI_ROLE_P2P_CLIENT)) {\n\t\t\t\tch = r2->ch;\n\t\t\t\tbw = r2->bw;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\ten = true;\n\t\t \n\t\tfor (i = 0; i < RTW89_PORT_NUM; i++) {\n\t\t\tr = &wl_rinfo->active_role[i];\n\t\t\tr1 = &wl_rinfo_v1->active_role_v1[i];\n\t\t\tr2 = &wl_rinfo_v2->active_role_v2[i];\n\n\t\t\tif (ver->fwlrole == 0 &&\n\t\t\t    r->connected && r->band == RTW89_BAND_2G) {\n\t\t\t\tch = r->ch;\n\t\t\t\tbw = r->bw;\n\t\t\t\tbreak;\n\t\t\t} else if (ver->fwlrole == 1 &&\n\t\t\t\t   r1->connected && r1->band == RTW89_BAND_2G) {\n\t\t\t\tch = r1->ch;\n\t\t\t\tbw = r1->bw;\n\t\t\t\tbreak;\n\t\t\t} else if (ver->fwlrole == 2 &&\n\t\t\t\t   r2->connected && r2->band == RTW89_BAND_2G) {\n\t\t\t\tch = r2->ch;\n\t\t\t\tbw = r2->bw;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tswitch (bw) {\n\tcase RTW89_CHANNEL_WIDTH_20:\n\t\tbw = 20 + chip->afh_guard_ch * 2;\n\t\tbreak;\n\tcase RTW89_CHANNEL_WIDTH_40:\n\t\tbw = 40 + chip->afh_guard_ch * 2;\n\t\tbreak;\n\tcase RTW89_CHANNEL_WIDTH_5:\n\t\tbw = 5 + chip->afh_guard_ch * 2;\n\t\tbreak;\n\tcase RTW89_CHANNEL_WIDTH_10:\n\t\tbw = 10 + chip->afh_guard_ch * 2;\n\t\tbreak;\n\tdefault:\n\t\tbw = 0;\n\t\ten = false;  \n\t\tbreak;\n\t}\n\n\tif (wl->afh_info.en == en &&\n\t    wl->afh_info.ch == ch &&\n\t    wl->afh_info.bw == bw &&\n\t    b->profile_cnt.last == b->profile_cnt.now) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t\t    \"[BTC], %s(): return because no change!\\n\",\n\t\t\t    __func__);\n\t\treturn;\n\t}\n\n\twl->afh_info.en = en;\n\twl->afh_info.ch = ch;\n\twl->afh_info.bw = bw;\n\n\t_send_fw_cmd(rtwdev, BTFC_SET, SET_BT_WL_CH_INFO, &wl->afh_info, 3);\n\n\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t    \"[BTC], %s(): en=%d, ch=%d, bw=%d\\n\",\n\t\t    __func__, en, ch, bw);\n\tbtc->cx.cnt_wl[BTC_WCNT_CH_UPDATE]++;\n}\n\nstatic bool _check_freerun(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_wl_info *wl = &btc->cx.wl;\n\tstruct rtw89_btc_bt_info *bt = &btc->cx.bt;\n\tstruct rtw89_btc_wl_role_info *wl_rinfo = &wl->role_info;\n\tstruct rtw89_btc_wl_role_info_v1 *wl_rinfo_v1 = &wl->role_info_v1;\n\tstruct rtw89_btc_bt_link_info *bt_linfo = &bt->link_info;\n\tstruct rtw89_btc_bt_hid_desc *hid = &bt_linfo->hid_desc;\n\n\tif (btc->mdinfo.ant.type == BTC_ANT_SHARED) {\n\t\tbtc->dm.trx_para_level = 0;\n\t\treturn false;\n\t}\n\n\t \n\tif (wl_rinfo->connect_cnt > BTC_TDMA_WLROLE_MAX ||\n\t    wl_rinfo_v1->connect_cnt > BTC_TDMA_WLROLE_MAX) {\n\t\tbtc->dm.trx_para_level = 5;\n\t\treturn true;\n\t}\n\n\tif (bt_linfo->profile_cnt.now == 0) {\n\t\tbtc->dm.trx_para_level = 5;\n\t\treturn true;\n\t}\n\n\tif (hid->pair_cnt > BTC_TDMA_BTHID_MAX) {\n\t\tbtc->dm.trx_para_level = 5;\n\t\treturn true;\n\t}\n\n\t \n\tif (btc->mdinfo.ant.isolation >= BTC_FREERUN_ANTISO_MIN) {\n\t\tbtc->dm.trx_para_level = 5;\n\t\treturn true;\n\t}\n\n\tif (!wl->status.map.busy) { \n\t\tbtc->dm.trx_para_level = 5;\n\t\treturn true;\n\t} else if (wl->rssi_level > 1) { \n\t\tbtc->dm.trx_para_level = 0;\n\t\treturn false;\n\t} else if (wl->status.map.traffic_dir & BIT(RTW89_TFC_UL)) {\n\t\tif (wl->rssi_level == 0 && bt_linfo->rssi > 31) {\n\t\t\tbtc->dm.trx_para_level = 6;\n\t\t\treturn true;\n\t\t} else if (wl->rssi_level == 1 && bt_linfo->rssi > 36) {\n\t\t\tbtc->dm.trx_para_level = 7;\n\t\t\treturn true;\n\t\t}\n\t\tbtc->dm.trx_para_level = 0;\n\t\treturn false;\n\t} else if (wl->status.map.traffic_dir & BIT(RTW89_TFC_DL)) {\n\t\tif (bt_linfo->rssi > 28) {\n\t\t\tbtc->dm.trx_para_level = 6;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tbtc->dm.trx_para_level = 0;\n\treturn false;\n}\n\n#define _tdma_set_flctrl(btc, flc) ({(btc)->dm.tdma.rxflctrl = flc; })\n#define _tdma_set_flctrl_role(btc, role) ({(btc)->dm.tdma.rxflctrl_role = role; })\n#define _tdma_set_tog(btc, wtg) ({(btc)->dm.tdma.wtgle_n = wtg; })\n#define _tdma_set_lek(btc, lek) ({(btc)->dm.tdma.leak_n = lek; })\n\n#define _slot_set(btc, sid, dura, tbl, type) \\\n\tdo { \\\n\t\ttypeof(sid) _sid = (sid); \\\n\t\ttypeof(btc) _btc = (btc); \\\n\t\t_btc->dm.slot[_sid].dur = cpu_to_le16(dura);\\\n\t\t_btc->dm.slot[_sid].cxtbl = cpu_to_le32(tbl); \\\n\t\t_btc->dm.slot[_sid].cxtype = cpu_to_le16(type); \\\n\t} while (0)\n\n#define _slot_set_dur(btc, sid, dura) (btc)->dm.slot[sid].dur = cpu_to_le16(dura)\n#define _slot_set_tbl(btc, sid, tbl) (btc)->dm.slot[sid].cxtbl = cpu_to_le32(tbl)\n#define _slot_set_type(btc, sid, type) (btc)->dm.slot[sid].cxtype = cpu_to_le16(type)\n\nstruct btc_btinfo_lb2 {\n\tu8 connect: 1;\n\tu8 sco_busy: 1;\n\tu8 inq_pag: 1;\n\tu8 acl_busy: 1;\n\tu8 hfp: 1;\n\tu8 hid: 1;\n\tu8 a2dp: 1;\n\tu8 pan: 1;\n};\n\nstruct btc_btinfo_lb3 {\n\tu8 retry: 4;\n\tu8 cqddr: 1;\n\tu8 inq: 1;\n\tu8 mesh_busy: 1;\n\tu8 pag: 1;\n};\n\nstruct btc_btinfo_hb0 {\n\ts8 rssi;\n};\n\nstruct btc_btinfo_hb1 {\n\tu8 ble_connect: 1;\n\tu8 reinit: 1;\n\tu8 relink: 1;\n\tu8 igno_wl: 1;\n\tu8 voice: 1;\n\tu8 ble_scan: 1;\n\tu8 role_sw: 1;\n\tu8 multi_link: 1;\n};\n\nstruct btc_btinfo_hb2 {\n\tu8 pan_active: 1;\n\tu8 afh_update: 1;\n\tu8 a2dp_active: 1;\n\tu8 slave: 1;\n\tu8 hid_slot: 2;\n\tu8 hid_cnt: 2;\n};\n\nstruct btc_btinfo_hb3 {\n\tu8 a2dp_bitpool: 6;\n\tu8 tx_3m: 1;\n\tu8 a2dp_sink: 1;\n};\n\nunion btc_btinfo {\n\tu8 val;\n\tstruct btc_btinfo_lb2 lb2;\n\tstruct btc_btinfo_lb3 lb3;\n\tstruct btc_btinfo_hb0 hb0;\n\tstruct btc_btinfo_hb1 hb1;\n\tstruct btc_btinfo_hb2 hb2;\n\tstruct btc_btinfo_hb3 hb3;\n};\n\nstatic void _set_policy(struct rtw89_dev *rtwdev, u16 policy_type,\n\t\t\tenum btc_reason_and_action action)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\n\tchip->ops->btc_set_policy(rtwdev, policy_type);\n\t_fw_set_policy(rtwdev, policy_type, action);\n}\n\n#define BTC_B1_MAX 250  \nvoid rtw89_btc_set_policy(struct rtw89_dev *rtwdev, u16 policy_type)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_dm *dm = &btc->dm;\n\tstruct rtw89_btc_fbtc_tdma *t = &dm->tdma;\n\tstruct rtw89_btc_fbtc_slot *s = dm->slot;\n\tu8 type;\n\tu32 tbl_w1, tbl_b1, tbl_b4;\n\n\tif (btc->mdinfo.ant.type == BTC_ANT_SHARED) {\n\t\tif (btc->cx.wl.status.map._4way)\n\t\t\ttbl_w1 = cxtbl[1];\n\t\telse\n\t\t\ttbl_w1 = cxtbl[8];\n\t\ttbl_b1 = cxtbl[3];\n\t\ttbl_b4 = cxtbl[3];\n\t} else {\n\t\ttbl_w1 = cxtbl[16];\n\t\ttbl_b1 = cxtbl[17];\n\t\ttbl_b4 = cxtbl[17];\n\t}\n\n\ttype = (u8)((policy_type & BTC_CXP_MASK) >> 8);\n\tbtc->bt_req_en = false;\n\n\tswitch (type) {\n\tcase BTC_CXP_USERDEF0:\n\t\t*t = t_def[CXTD_OFF];\n\t\ts[CXST_OFF] = s_def[CXST_OFF];\n\t\t_slot_set_tbl(btc, CXST_OFF, cxtbl[2]);\n\t\tbtc->update_policy_force = true;\n\t\tbreak;\n\tcase BTC_CXP_OFF:  \n\t\t_write_scbd(rtwdev, BTC_WSCB_TDMA, false);\n\t\t*t = t_def[CXTD_OFF];\n\t\ts[CXST_OFF] = s_def[CXST_OFF];\n\n\t\tswitch (policy_type) {\n\t\tcase BTC_CXP_OFF_BT:\n\t\t\t_slot_set_tbl(btc, CXST_OFF, cxtbl[2]);\n\t\t\tbreak;\n\t\tcase BTC_CXP_OFF_WL:\n\t\t\t_slot_set_tbl(btc, CXST_OFF, cxtbl[1]);\n\t\t\tbreak;\n\t\tcase BTC_CXP_OFF_EQ0:\n\t\t\t_slot_set_tbl(btc, CXST_OFF, cxtbl[0]);\n\t\t\tbreak;\n\t\tcase BTC_CXP_OFF_EQ1:\n\t\t\t_slot_set_tbl(btc, CXST_OFF, cxtbl[16]);\n\t\t\tbreak;\n\t\tcase BTC_CXP_OFF_EQ2:\n\t\t\t_slot_set_tbl(btc, CXST_OFF, cxtbl[17]);\n\t\t\tbreak;\n\t\tcase BTC_CXP_OFF_EQ3:\n\t\t\t_slot_set_tbl(btc, CXST_OFF, cxtbl[18]);\n\t\t\tbreak;\n\t\tcase BTC_CXP_OFF_BWB0:\n\t\t\t_slot_set_tbl(btc, CXST_OFF, cxtbl[5]);\n\t\t\tbreak;\n\t\tcase BTC_CXP_OFF_BWB1:\n\t\t\t_slot_set_tbl(btc, CXST_OFF, cxtbl[8]);\n\t\t\tbreak;\n\t\tcase BTC_CXP_OFF_BWB3:\n\t\t\t_slot_set_tbl(btc, CXST_OFF, cxtbl[6]);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase BTC_CXP_OFFB:  \n\t\t_write_scbd(rtwdev, BTC_WSCB_TDMA, false);\n\t\t*t = t_def[CXTD_OFF_B2];\n\t\ts[CXST_OFF] = s_def[CXST_OFF];\n\t\tswitch (policy_type) {\n\t\tcase BTC_CXP_OFFB_BWB0:\n\t\t\t_slot_set_tbl(btc, CXST_OFF, cxtbl[8]);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase BTC_CXP_OFFE:  \n\t\tbtc->bt_req_en = true;\n\t\t_write_scbd(rtwdev, BTC_WSCB_TDMA, true);\n\t\t*t = t_def[CXTD_OFF_EXT];\n\t\tswitch (policy_type) {\n\t\tcase BTC_CXP_OFFE_DEF:\n\t\t\ts[CXST_E2G] = s_def[CXST_E2G];\n\t\t\ts[CXST_E5G] = s_def[CXST_E5G];\n\t\t\ts[CXST_EBT] = s_def[CXST_EBT];\n\t\t\ts[CXST_ENULL] = s_def[CXST_ENULL];\n\t\t\tbreak;\n\t\tcase BTC_CXP_OFFE_DEF2:\n\t\t\t_slot_set(btc, CXST_E2G, 20, cxtbl[1], SLOT_ISO);\n\t\t\ts[CXST_E5G] = s_def[CXST_E5G];\n\t\t\ts[CXST_EBT] = s_def[CXST_EBT];\n\t\t\ts[CXST_ENULL] = s_def[CXST_ENULL];\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase BTC_CXP_FIX:  \n\t\t_write_scbd(rtwdev, BTC_WSCB_TDMA, true);\n\t\t*t = t_def[CXTD_FIX];\n\t\tswitch (policy_type) {\n\t\tcase BTC_CXP_FIX_TD3030:\n\t\t\t_slot_set(btc, CXST_W1, 30, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, 30, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_FIX_TD5050:\n\t\t\t_slot_set(btc, CXST_W1, 50, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, 50, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_FIX_TD2030:\n\t\t\t_slot_set(btc, CXST_W1, 20, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, 30, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_FIX_TD4010:\n\t\t\t_slot_set(btc, CXST_W1, 40, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, 10, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_FIX_TD4020:\n\t\t\t_slot_set(btc, CXST_W1, 40, cxtbl[1], SLOT_MIX);\n\t\t\t_slot_set(btc, CXST_B1, 20, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_FIX_TD7010:\n\t\t\t_slot_set(btc, CXST_W1, 70, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, 10, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_FIX_TD2060:\n\t\t\t_slot_set(btc, CXST_W1, 20, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, 60, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_FIX_TD3060:\n\t\t\t_slot_set(btc, CXST_W1, 30, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, 60, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_FIX_TD2080:\n\t\t\t_slot_set(btc, CXST_W1, 20, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, 80, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_FIX_TDW1B1:  \n\t\t\t_slot_set(btc, CXST_W1, dm->slot_dur[CXST_W1],\n\t\t\t\t  tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, dm->slot_dur[CXST_B1],\n\t\t\t\t  tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase BTC_CXP_PFIX:  \n\t\t_write_scbd(rtwdev, BTC_WSCB_TDMA, true);\n\t\t*t = t_def[CXTD_PFIX];\n\t\tif (btc->cx.wl.role_info.role_map.role.ap)\n\t\t\t_tdma_set_flctrl(btc, CXFLC_QOSNULL);\n\n\t\tswitch (policy_type) {\n\t\tcase BTC_CXP_PFIX_TD3030:\n\t\t\t_slot_set(btc, CXST_W1, 30, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, 30, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_PFIX_TD5050:\n\t\t\t_slot_set(btc, CXST_W1, 50, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, 50, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_PFIX_TD2030:\n\t\t\t_slot_set(btc, CXST_W1, 20, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, 30, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_PFIX_TD2060:\n\t\t\t_slot_set(btc, CXST_W1, 20, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, 60, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_PFIX_TD3070:\n\t\t\t_slot_set(btc, CXST_W1, 30, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, 60, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_PFIX_TD2080:\n\t\t\t_slot_set(btc, CXST_W1, 20, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, 80, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase BTC_CXP_AUTO:  \n\t\t_write_scbd(rtwdev, BTC_WSCB_TDMA, true);\n\t\t*t = t_def[CXTD_AUTO];\n\t\tswitch (policy_type) {\n\t\tcase BTC_CXP_AUTO_TD50B1:\n\t\t\t_slot_set(btc, CXST_W1, 50, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, BTC_B1_MAX, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_AUTO_TD60B1:\n\t\t\t_slot_set(btc, CXST_W1, 60, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, BTC_B1_MAX, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_AUTO_TD20B1:\n\t\t\t_slot_set(btc, CXST_W1, 20, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, BTC_B1_MAX, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_AUTO_TDW1B1:  \n\t\t\t_slot_set(btc, CXST_W1, dm->slot_dur[CXST_W1],\n\t\t\t\t  tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, dm->slot_dur[CXST_B1],\n\t\t\t\t  tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase BTC_CXP_PAUTO:  \n\t\t_write_scbd(rtwdev, BTC_WSCB_TDMA, true);\n\t\t*t = t_def[CXTD_PAUTO];\n\t\tswitch (policy_type) {\n\t\tcase BTC_CXP_PAUTO_TD50B1:\n\t\t\t_slot_set(btc, CXST_W1, 50, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, BTC_B1_MAX, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_PAUTO_TD60B1:\n\t\t\t_slot_set(btc, CXST_W1, 60, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, BTC_B1_MAX, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_PAUTO_TD20B1:\n\t\t\t_slot_set(btc, CXST_W1, 20, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, BTC_B1_MAX, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_PAUTO_TDW1B1:\n\t\t\t_slot_set(btc, CXST_W1, dm->slot_dur[CXST_W1],\n\t\t\t\t  tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, dm->slot_dur[CXST_B1],\n\t\t\t\t  tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase BTC_CXP_AUTO2:  \n\t\t_write_scbd(rtwdev, BTC_WSCB_TDMA, true);\n\t\t*t = t_def[CXTD_AUTO2];\n\t\tswitch (policy_type) {\n\t\tcase BTC_CXP_AUTO2_TD3050:\n\t\t\t_slot_set(btc, CXST_W1, 30, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B4, 50, tbl_b4, SLOT_MIX);\n\t\t\t_slot_set(btc, CXST_B1, BTC_B1_MAX, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_AUTO2_TD3070:\n\t\t\t_slot_set(btc, CXST_W1, 30, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B4, 70, tbl_b4, SLOT_MIX);\n\t\t\t_slot_set(btc, CXST_B1, BTC_B1_MAX, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_AUTO2_TD5050:\n\t\t\t_slot_set(btc, CXST_W1, 50, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B4, 50, tbl_b4, SLOT_MIX);\n\t\t\t_slot_set(btc, CXST_B1, BTC_B1_MAX, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_AUTO2_TD6060:\n\t\t\t_slot_set(btc, CXST_W1, 60, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B4, 60, tbl_b4, SLOT_MIX);\n\t\t\t_slot_set(btc, CXST_B1, BTC_B1_MAX, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_AUTO2_TD2080:\n\t\t\t_slot_set(btc, CXST_W1, 20, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B4, 80, tbl_b4, SLOT_MIX);\n\t\t\t_slot_set(btc, CXST_B1, BTC_B1_MAX, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_AUTO2_TDW1B4:  \n\t\t\t_slot_set(btc, CXST_W1, dm->slot_dur[CXST_W1],\n\t\t\t\t  tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B4, dm->slot_dur[CXST_B4],\n\t\t\t\t  tbl_b4, SLOT_MIX);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase BTC_CXP_PAUTO2:  \n\t\t_write_scbd(rtwdev, BTC_WSCB_TDMA, true);\n\t\t*t = t_def[CXTD_PAUTO2];\n\t\tswitch (policy_type) {\n\t\tcase BTC_CXP_PAUTO2_TD3050:\n\t\t\t_slot_set(btc, CXST_W1, 30, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B4, 50, tbl_b4, SLOT_MIX);\n\t\t\t_slot_set(btc, CXST_B1, BTC_B1_MAX, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_PAUTO2_TD3070:\n\t\t\t_slot_set(btc, CXST_W1, 30, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B4, 70, tbl_b4, SLOT_MIX);\n\t\t\t_slot_set(btc, CXST_B1, BTC_B1_MAX, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_PAUTO2_TD5050:\n\t\t\t_slot_set(btc, CXST_W1, 50, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B4, 50, tbl_b4, SLOT_MIX);\n\t\t\t_slot_set(btc, CXST_B1, BTC_B1_MAX, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_PAUTO2_TD6060:\n\t\t\t_slot_set(btc, CXST_W1, 60, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B4, 60, tbl_b4, SLOT_MIX);\n\t\t\t_slot_set(btc, CXST_B1, BTC_B1_MAX, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_PAUTO2_TD2080:\n\t\t\t_slot_set(btc, CXST_W1, 20, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B4, 80, tbl_b4, SLOT_MIX);\n\t\t\t_slot_set(btc, CXST_B1, BTC_B1_MAX, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_PAUTO2_TDW1B4:  \n\t\t\t_slot_set(btc, CXST_W1, dm->slot_dur[CXST_W1],\n\t\t\t\t  tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B4, dm->slot_dur[CXST_B4],\n\t\t\t\t  tbl_b4, SLOT_MIX);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL(rtw89_btc_set_policy);\n\nvoid rtw89_btc_set_policy_v1(struct rtw89_dev *rtwdev, u16 policy_type)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_dm *dm = &btc->dm;\n\tstruct rtw89_btc_fbtc_tdma *t = &dm->tdma;\n\tstruct rtw89_btc_fbtc_slot *s = dm->slot;\n\tstruct rtw89_btc_wl_role_info_v1 *wl_rinfo = &btc->cx.wl.role_info_v1;\n\tstruct rtw89_btc_bt_hid_desc *hid = &btc->cx.bt.link_info.hid_desc;\n\tstruct rtw89_btc_bt_hfp_desc *hfp = &btc->cx.bt.link_info.hfp_desc;\n\tu8 type, null_role;\n\tu32 tbl_w1, tbl_b1, tbl_b4;\n\n\ttype = FIELD_GET(BTC_CXP_MASK, policy_type);\n\n\tif (btc->mdinfo.ant.type == BTC_ANT_SHARED) {\n\t\tif (btc->cx.wl.status.map._4way)\n\t\t\ttbl_w1 = cxtbl[1];\n\t\telse if (hid->exist && hid->type == BTC_HID_218)\n\t\t\ttbl_w1 = cxtbl[7];  \n\t\telse\n\t\t\ttbl_w1 = cxtbl[8];\n\n\t\tif (dm->leak_ap &&\n\t\t    (type == BTC_CXP_PFIX || type == BTC_CXP_PAUTO2)) {\n\t\t\ttbl_b1 = cxtbl[3];\n\t\t\ttbl_b4 = cxtbl[3];\n\t\t} else if (hid->exist && hid->type == BTC_HID_218) {\n\t\t\ttbl_b1 = cxtbl[4];  \n\t\t\ttbl_b4 = cxtbl[4];\n\t\t} else {\n\t\t\ttbl_b1 = cxtbl[2];\n\t\t\ttbl_b4 = cxtbl[2];\n\t\t}\n\t} else {\n\t\ttbl_w1 = cxtbl[16];\n\t\ttbl_b1 = cxtbl[17];\n\t\ttbl_b4 = cxtbl[17];\n\t}\n\n\tbtc->bt_req_en = false;\n\n\tswitch (type) {\n\tcase BTC_CXP_USERDEF0:\n\t\tbtc->update_policy_force = true;\n\t\t*t = t_def[CXTD_OFF];\n\t\ts[CXST_OFF] = s_def[CXST_OFF];\n\t\t_slot_set_tbl(btc, CXST_OFF, cxtbl[2]);\n\t\tbreak;\n\tcase BTC_CXP_OFF:  \n\t\t_write_scbd(rtwdev, BTC_WSCB_TDMA, false);\n\t\t*t = t_def[CXTD_OFF];\n\t\ts[CXST_OFF] = s_def[CXST_OFF];\n\n\t\tswitch (policy_type) {\n\t\tcase BTC_CXP_OFF_BT:\n\t\t\t_slot_set_tbl(btc, CXST_OFF, cxtbl[2]);\n\t\t\tbreak;\n\t\tcase BTC_CXP_OFF_WL:\n\t\t\t_slot_set_tbl(btc, CXST_OFF, cxtbl[1]);\n\t\t\tbreak;\n\t\tcase BTC_CXP_OFF_EQ0:\n\t\t\t_slot_set_tbl(btc, CXST_OFF, cxtbl[0]);\n\t\t\t_slot_set_type(btc, CXST_OFF, SLOT_ISO);\n\t\t\tbreak;\n\t\tcase BTC_CXP_OFF_EQ1:\n\t\t\t_slot_set_tbl(btc, CXST_OFF, cxtbl[16]);\n\t\t\tbreak;\n\t\tcase BTC_CXP_OFF_EQ2:\n\t\t\t_slot_set_tbl(btc, CXST_OFF, cxtbl[0]);\n\t\t\tbreak;\n\t\tcase BTC_CXP_OFF_EQ3:\n\t\t\t_slot_set_tbl(btc, CXST_OFF, cxtbl[24]);\n\t\t\tbreak;\n\t\tcase BTC_CXP_OFF_BWB0:\n\t\t\t_slot_set_tbl(btc, CXST_OFF, cxtbl[5]);\n\t\t\tbreak;\n\t\tcase BTC_CXP_OFF_BWB1:\n\t\t\t_slot_set_tbl(btc, CXST_OFF, cxtbl[8]);\n\t\t\tbreak;\n\t\tcase BTC_CXP_OFF_BWB2:\n\t\t\t_slot_set_tbl(btc, CXST_OFF, cxtbl[7]);\n\t\t\tbreak;\n\t\tcase BTC_CXP_OFF_BWB3:\n\t\t\t_slot_set_tbl(btc, CXST_OFF, cxtbl[6]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase BTC_CXP_OFFB:  \n\t\t_write_scbd(rtwdev, BTC_WSCB_TDMA, false);\n\t\t*t = t_def[CXTD_OFF_B2];\n\t\ts[CXST_OFF] = s_def[CXST_OFF];\n\n\t\tswitch (policy_type) {\n\t\tcase BTC_CXP_OFFB_BWB0:\n\t\t\t_slot_set_tbl(btc, CXST_OFF, cxtbl[8]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase BTC_CXP_OFFE:  \n\t\tbtc->bt_req_en = true;\n\t\t_write_scbd(rtwdev, BTC_WSCB_TDMA, true);\n\t\t*t = t_def[CXTD_OFF_EXT];\n\n\t\t \n\t\tif (hid->exist || hfp->exist)\n\t\t\ttbl_w1 = cxtbl[16];\n\n\t\tswitch (policy_type) {\n\t\tcase BTC_CXP_OFFE_DEF:\n\t\t\ts[CXST_E2G] = s_def[CXST_E2G];\n\t\t\ts[CXST_E5G] = s_def[CXST_E5G];\n\t\t\ts[CXST_EBT] = s_def[CXST_EBT];\n\t\t\ts[CXST_ENULL] = s_def[CXST_ENULL];\n\t\t\tbreak;\n\t\tcase BTC_CXP_OFFE_DEF2:\n\t\t\t_slot_set(btc, CXST_E2G, 20, cxtbl[1], SLOT_ISO);\n\t\t\ts[CXST_E5G] = s_def[CXST_E5G];\n\t\t\ts[CXST_EBT] = s_def[CXST_EBT];\n\t\t\ts[CXST_ENULL] = s_def[CXST_ENULL];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\ts[CXST_OFF] = s_def[CXST_OFF];\n\t\tbreak;\n\tcase BTC_CXP_FIX:  \n\t\t_write_scbd(rtwdev, BTC_WSCB_TDMA, true);\n\t\t*t = t_def[CXTD_FIX];\n\n\t\tswitch (policy_type) {\n\t\tcase BTC_CXP_FIX_TD3030:\n\t\t\t_slot_set(btc, CXST_W1, 30, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, 30, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_FIX_TD5050:\n\t\t\t_slot_set(btc, CXST_W1, 50, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, 50, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_FIX_TD2030:\n\t\t\t_slot_set(btc, CXST_W1, 20, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, 30, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_FIX_TD4010:\n\t\t\t_slot_set(btc, CXST_W1, 40, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, 10, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_FIX_TD4010ISO:\n\t\t\t_slot_set(btc, CXST_W1, 40, cxtbl[1], SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, 10, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_FIX_TD4020:\n\t\t\t_slot_set(btc, CXST_W1, 40, cxtbl[1], SLOT_MIX);\n\t\t\t_slot_set(btc, CXST_B1, 20, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_FIX_TD7010:\n\t\t\t_slot_set(btc, CXST_W1, 70, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, 10, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_FIX_TD2060:\n\t\t\t_slot_set(btc, CXST_W1, 20, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, 60, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_FIX_TD3060:\n\t\t\t_slot_set(btc, CXST_W1, 30, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, 60, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_FIX_TD2080:\n\t\t\t_slot_set(btc, CXST_W1, 20, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, 80, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_FIX_TDW1B1:  \n\t\t\t_slot_set(btc, CXST_W1, dm->slot_dur[CXST_W1],\n\t\t\t\t  tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, dm->slot_dur[CXST_B1],\n\t\t\t\t  tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase BTC_CXP_PFIX:  \n\t\t_write_scbd(rtwdev, BTC_WSCB_TDMA, true);\n\t\t*t = t_def[CXTD_PFIX];\n\n\t\tswitch (policy_type) {\n\t\tcase BTC_CXP_PFIX_TD3030:\n\t\t\t_slot_set(btc, CXST_W1, 30, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, 30, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_PFIX_TD5050:\n\t\t\t_slot_set(btc, CXST_W1, 50, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, 50, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_PFIX_TD2030:\n\t\t\t_slot_set(btc, CXST_W1, 20, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, 30, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_PFIX_TD2060:\n\t\t\t_slot_set(btc, CXST_W1, 20, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, 60, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_PFIX_TD3070:\n\t\t\t_slot_set(btc, CXST_W1, 30, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, 60, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_PFIX_TD2080:\n\t\t\t_slot_set(btc, CXST_W1, 20, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, 80, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_PFIX_TDW1B1:  \n\t\t\t_slot_set(btc, CXST_W1, dm->slot_dur[CXST_W1],\n\t\t\t\t  tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, dm->slot_dur[CXST_B1],\n\t\t\t\t  tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase BTC_CXP_AUTO:  \n\t\t_write_scbd(rtwdev, BTC_WSCB_TDMA, true);\n\t\t*t = t_def[CXTD_AUTO];\n\n\t\tswitch (policy_type) {\n\t\tcase BTC_CXP_AUTO_TD50B1:\n\t\t\t_slot_set(btc, CXST_W1,  50, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, BTC_B1_MAX, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_AUTO_TD60B1:\n\t\t\t_slot_set(btc, CXST_W1,  60, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, BTC_B1_MAX, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_AUTO_TD20B1:\n\t\t\t_slot_set(btc, CXST_W1,  20, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, BTC_B1_MAX, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_AUTO_TDW1B1:  \n\t\t\t_slot_set(btc, CXST_W1, dm->slot_dur[CXST_W1],\n\t\t\t\t  tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, dm->slot_dur[CXST_B1],\n\t\t\t\t  tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase BTC_CXP_PAUTO:  \n\t\t_write_scbd(rtwdev, BTC_WSCB_TDMA, true);\n\t\t*t = t_def[CXTD_PAUTO];\n\n\t\tswitch (policy_type) {\n\t\tcase BTC_CXP_PAUTO_TD50B1:\n\t\t\t_slot_set(btc, CXST_W1,  50, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, BTC_B1_MAX, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_PAUTO_TD60B1:\n\t\t\t_slot_set(btc, CXST_W1,  60, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, BTC_B1_MAX, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_PAUTO_TD20B1:\n\t\t\t_slot_set(btc, CXST_W1,  20, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, BTC_B1_MAX, tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_PAUTO_TDW1B1:\n\t\t\t_slot_set(btc, CXST_W1, dm->slot_dur[CXST_W1],\n\t\t\t\t  tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, dm->slot_dur[CXST_B1],\n\t\t\t\t  tbl_b1, SLOT_MIX);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase BTC_CXP_AUTO2:  \n\t\t_write_scbd(rtwdev, BTC_WSCB_TDMA, true);\n\t\t*t = t_def[CXTD_AUTO2];\n\n\t\tswitch (policy_type) {\n\t\tcase BTC_CXP_AUTO2_TD3050:\n\t\t\t_slot_set(btc, CXST_W1,  30, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, BTC_B1_MAX, tbl_b1, SLOT_MIX);\n\t\t\t_slot_set(btc, CXST_B4,  50, tbl_b4, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_AUTO2_TD3070:\n\t\t\t_slot_set(btc, CXST_W1,  30, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, BTC_B1_MAX, tbl_b1, SLOT_MIX);\n\t\t\t_slot_set(btc, CXST_B4,  70, tbl_b4, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_AUTO2_TD5050:\n\t\t\t_slot_set(btc, CXST_W1,  50, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, BTC_B1_MAX, tbl_b1, SLOT_MIX);\n\t\t\t_slot_set(btc, CXST_B4,  50, tbl_b4, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_AUTO2_TD6060:\n\t\t\t_slot_set(btc, CXST_W1,  60, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, BTC_B1_MAX, tbl_b1, SLOT_MIX);\n\t\t\t_slot_set(btc, CXST_B4,  60, tbl_b4, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_AUTO2_TD2080:\n\t\t\t_slot_set(btc, CXST_W1,  20, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, BTC_B1_MAX, tbl_b1, SLOT_MIX);\n\t\t\t_slot_set(btc, CXST_B4,  80, tbl_b4, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_AUTO2_TDW1B4:  \n\t\t\t_slot_set(btc, CXST_W1, dm->slot_dur[CXST_W1],\n\t\t\t\t  tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, dm->slot_dur[CXST_B1],\n\t\t\t\t  tbl_b1, SLOT_MIX);\n\t\t\t_slot_set(btc, CXST_B4, dm->slot_dur[CXST_B4],\n\t\t\t\t  tbl_b4, SLOT_MIX);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase BTC_CXP_PAUTO2:  \n\t\t_write_scbd(rtwdev, BTC_WSCB_TDMA, true);\n\t\t*t = t_def[CXTD_PAUTO2];\n\n\t\tswitch (policy_type) {\n\t\tcase BTC_CXP_PAUTO2_TD3050:\n\t\t\t_slot_set(btc, CXST_W1,  30, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, BTC_B1_MAX, tbl_b1, SLOT_MIX);\n\t\t\t_slot_set(btc, CXST_B4,  50, tbl_b4, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_PAUTO2_TD3070:\n\t\t\t_slot_set(btc, CXST_W1,  30, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, BTC_B1_MAX, tbl_b1, SLOT_MIX);\n\t\t\t_slot_set(btc, CXST_B4,  70, tbl_b4, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_PAUTO2_TD5050:\n\t\t\t_slot_set(btc, CXST_W1,  50, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, BTC_B1_MAX, tbl_b1, SLOT_MIX);\n\t\t\t_slot_set(btc, CXST_B4,  50, tbl_b4, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_PAUTO2_TD6060:\n\t\t\t_slot_set(btc, CXST_W1,  60, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, BTC_B1_MAX, tbl_b1, SLOT_MIX);\n\t\t\t_slot_set(btc, CXST_B4,  60, tbl_b4, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_PAUTO2_TD2080:\n\t\t\t_slot_set(btc, CXST_W1,  20, tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, BTC_B1_MAX, tbl_b1, SLOT_MIX);\n\t\t\t_slot_set(btc, CXST_B4,  80, tbl_b4, SLOT_MIX);\n\t\t\tbreak;\n\t\tcase BTC_CXP_PAUTO2_TDW1B4:  \n\t\t\t_slot_set(btc, CXST_W1, dm->slot_dur[CXST_W1],\n\t\t\t\t  tbl_w1, SLOT_ISO);\n\t\t\t_slot_set(btc, CXST_B1, dm->slot_dur[CXST_B1],\n\t\t\t\t  tbl_b1, SLOT_MIX);\n\t\t\t_slot_set(btc, CXST_B4, dm->slot_dur[CXST_B4],\n\t\t\t\t  tbl_b4, SLOT_MIX);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (wl_rinfo->link_mode == BTC_WLINK_2G_SCC && dm->tdma.rxflctrl) {\n\t\tnull_role = FIELD_PREP(0x0f, dm->wl_scc.null_role1) |\n\t\t\t    FIELD_PREP(0xf0, dm->wl_scc.null_role2);\n\t\t_tdma_set_flctrl_role(btc, null_role);\n\t}\n\n\t \n\tif (dm->leak_ap && dm->tdma.leak_n > 1)\n\t\t_tdma_set_lek(btc, 1);\n\n\tif (dm->tdma_instant_excute) {\n\t\tbtc->dm.tdma.option_ctrl |= BIT(0);\n\t\tbtc->update_policy_force = true;\n\t}\n}\nEXPORT_SYMBOL(rtw89_btc_set_policy_v1);\n\nstatic void _set_bt_plut(struct rtw89_dev *rtwdev, u8 phy_map,\n\t\t\t u8 tx_val, u8 rx_val)\n{\n\tstruct rtw89_mac_ax_plt plt;\n\n\tplt.band = RTW89_MAC_0;\n\tplt.tx = tx_val;\n\tplt.rx = rx_val;\n\n\tif (phy_map & BTC_PHY_0)\n\t\trtw89_mac_cfg_plt(rtwdev, &plt);\n\n\tif (!rtwdev->dbcc_en)\n\t\treturn;\n\n\tplt.band = RTW89_MAC_1;\n\tif (phy_map & BTC_PHY_1)\n\t\trtw89_mac_cfg_plt(rtwdev, &plt);\n}\n\nstatic void _set_ant(struct rtw89_dev *rtwdev, bool force_exec,\n\t\t     u8 phy_map, u8 type)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_dm *dm = &btc->dm;\n\tstruct rtw89_btc_cx *cx = &btc->cx;\n\tstruct rtw89_btc_wl_info *wl = &btc->cx.wl;\n\tstruct rtw89_btc_bt_info *bt = &cx->bt;\n\tstruct rtw89_btc_wl_dbcc_info *wl_dinfo = &wl->dbcc_info;\n\tu8 gnt_wl_ctrl, gnt_bt_ctrl, plt_ctrl, i, b2g = 0;\n\tu32 ant_path_type;\n\n\tant_path_type = ((phy_map << 8) + type);\n\n\tif (btc->dm.run_reason == BTC_RSN_NTFY_POWEROFF ||\n\t    btc->dm.run_reason == BTC_RSN_NTFY_RADIO_STATE ||\n\t    btc->dm.run_reason == BTC_RSN_CMD_SET_COEX)\n\t\tforce_exec = FC_EXEC;\n\n\tif (!force_exec && ant_path_type == dm->set_ant_path) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t\t    \"[BTC], %s(): return by no change!!\\n\",\n\t\t\t     __func__);\n\t\treturn;\n\t} else if (bt->rfk_info.map.run) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t\t    \"[BTC], %s(): return by bt rfk!!\\n\", __func__);\n\t\treturn;\n\t} else if (btc->dm.run_reason != BTC_RSN_NTFY_WL_RFK &&\n\t\t   wl->rfk_info.state != BTC_WRFK_STOP) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t\t    \"[BTC], %s(): return by wl rfk!!\\n\", __func__);\n\t\treturn;\n\t}\n\n\tdm->set_ant_path = ant_path_type;\n\n\trtw89_debug(rtwdev,\n\t\t    RTW89_DBG_BTC,\n\t\t    \"[BTC], %s(): path=0x%x, set_type=0x%x\\n\",\n\t\t    __func__, phy_map, dm->set_ant_path & 0xff);\n\n\tswitch (type) {\n\tcase BTC_ANT_WPOWERON:\n\t\trtw89_chip_cfg_ctrl_path(rtwdev, BTC_CTRL_BY_BT);\n\t\tbreak;\n\tcase BTC_ANT_WINIT:\n\t\tif (bt->enable.now)\n\t\t\t_set_gnt(rtwdev, phy_map, BTC_GNT_SW_LO, BTC_GNT_SW_HI);\n\t\telse\n\t\t\t_set_gnt(rtwdev, phy_map, BTC_GNT_SW_HI, BTC_GNT_SW_LO);\n\n\t\trtw89_chip_cfg_ctrl_path(rtwdev, BTC_CTRL_BY_WL);\n\t\t_set_bt_plut(rtwdev, BTC_PHY_ALL, BTC_PLT_BT, BTC_PLT_BT);\n\t\tbreak;\n\tcase BTC_ANT_WONLY:\n\t\t_set_gnt(rtwdev, phy_map, BTC_GNT_SW_HI, BTC_GNT_SW_LO);\n\t\trtw89_chip_cfg_ctrl_path(rtwdev, BTC_CTRL_BY_WL);\n\t\t_set_bt_plut(rtwdev, BTC_PHY_ALL, BTC_PLT_NONE, BTC_PLT_NONE);\n\t\tbreak;\n\tcase BTC_ANT_WOFF:\n\t\trtw89_chip_cfg_ctrl_path(rtwdev, BTC_CTRL_BY_BT);\n\t\t_set_bt_plut(rtwdev, BTC_PHY_ALL, BTC_PLT_NONE, BTC_PLT_NONE);\n\t\tbreak;\n\tcase BTC_ANT_W2G:\n\t\trtw89_chip_cfg_ctrl_path(rtwdev, BTC_CTRL_BY_WL);\n\t\tif (rtwdev->dbcc_en) {\n\t\t\tfor (i = 0; i < RTW89_PHY_MAX; i++) {\n\t\t\t\tb2g = (wl_dinfo->real_band[i] == RTW89_BAND_2G);\n\n\t\t\t\tgnt_wl_ctrl = b2g ? BTC_GNT_HW : BTC_GNT_SW_HI;\n\t\t\t\tgnt_bt_ctrl = b2g ? BTC_GNT_HW : BTC_GNT_SW_HI;\n\t\t\t\t \n\t\t\t\tif (i == 1 &&\n\t\t\t\t    wl_dinfo->real_band[0] == RTW89_BAND_2G &&\n\t\t\t\t    wl_dinfo->real_band[1] == RTW89_BAND_5G)\n\t\t\t\t\tgnt_bt_ctrl = BTC_GNT_HW;\n\t\t\t\t_set_gnt(rtwdev, BIT(i), gnt_wl_ctrl, gnt_bt_ctrl);\n\t\t\t\tplt_ctrl = b2g ? BTC_PLT_BT : BTC_PLT_NONE;\n\t\t\t\t_set_bt_plut(rtwdev, BIT(i),\n\t\t\t\t\t     plt_ctrl, plt_ctrl);\n\t\t\t}\n\t\t} else {\n\t\t\t_set_gnt(rtwdev, phy_map, BTC_GNT_HW, BTC_GNT_HW);\n\t\t\t_set_bt_plut(rtwdev, BTC_PHY_ALL,\n\t\t\t\t     BTC_PLT_BT, BTC_PLT_BT);\n\t\t}\n\t\tbreak;\n\tcase BTC_ANT_W5G:\n\t\trtw89_chip_cfg_ctrl_path(rtwdev, BTC_CTRL_BY_WL);\n\t\t_set_gnt(rtwdev, phy_map, BTC_GNT_SW_HI, BTC_GNT_HW);\n\t\t_set_bt_plut(rtwdev, BTC_PHY_ALL, BTC_PLT_NONE, BTC_PLT_NONE);\n\t\tbreak;\n\tcase BTC_ANT_W25G:\n\t\trtw89_chip_cfg_ctrl_path(rtwdev, BTC_CTRL_BY_WL);\n\t\t_set_gnt(rtwdev, phy_map, BTC_GNT_HW, BTC_GNT_HW);\n\t\t_set_bt_plut(rtwdev, BTC_PHY_ALL,\n\t\t\t     BTC_PLT_GNT_WL, BTC_PLT_GNT_WL);\n\t\tbreak;\n\tcase BTC_ANT_FREERUN:\n\t\trtw89_chip_cfg_ctrl_path(rtwdev, BTC_CTRL_BY_WL);\n\t\t_set_gnt(rtwdev, phy_map, BTC_GNT_SW_HI, BTC_GNT_SW_HI);\n\t\t_set_bt_plut(rtwdev, BTC_PHY_ALL, BTC_PLT_NONE, BTC_PLT_NONE);\n\t\tbreak;\n\tcase BTC_ANT_WRFK:\n\t\trtw89_chip_cfg_ctrl_path(rtwdev, BTC_CTRL_BY_WL);\n\t\t_set_gnt(rtwdev, phy_map, BTC_GNT_SW_HI, BTC_GNT_SW_LO);\n\t\t_set_bt_plut(rtwdev, phy_map, BTC_PLT_NONE, BTC_PLT_NONE);\n\t\tbreak;\n\tcase BTC_ANT_BRFK:\n\t\trtw89_chip_cfg_ctrl_path(rtwdev, BTC_CTRL_BY_BT);\n\t\t_set_gnt(rtwdev, phy_map, BTC_GNT_SW_LO, BTC_GNT_SW_HI);\n\t\t_set_bt_plut(rtwdev, phy_map, BTC_PLT_NONE, BTC_PLT_NONE);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void _action_wl_only(struct rtw89_dev *rtwdev)\n{\n\t_set_ant(rtwdev, FC_EXEC, BTC_PHY_ALL, BTC_ANT_WONLY);\n\t_set_policy(rtwdev, BTC_CXP_OFF_BT, BTC_ACT_WL_ONLY);\n}\n\nstatic void _action_wl_init(struct rtw89_dev *rtwdev)\n{\n\trtw89_debug(rtwdev, RTW89_DBG_BTC, \"[BTC], %s(): !!\\n\", __func__);\n\n\t_set_ant(rtwdev, FC_EXEC, BTC_PHY_ALL, BTC_ANT_WINIT);\n\t_set_policy(rtwdev, BTC_CXP_OFF_BT, BTC_ACT_WL_INIT);\n}\n\nstatic void _action_wl_off(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_wl_info *wl = &btc->cx.wl;\n\n\trtw89_debug(rtwdev, RTW89_DBG_BTC, \"[BTC], %s(): !!\\n\", __func__);\n\n\tif (wl->status.map.rf_off || btc->dm.bt_only)\n\t\t_set_ant(rtwdev, NM_EXEC, BTC_PHY_ALL, BTC_ANT_WOFF);\n\n\t_set_policy(rtwdev, BTC_CXP_OFF_BT, BTC_ACT_WL_OFF);\n}\n\nstatic void _action_freerun(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\n\trtw89_debug(rtwdev, RTW89_DBG_BTC, \"[BTC], %s(): !!\\n\", __func__);\n\n\t_set_ant(rtwdev, FC_EXEC, BTC_PHY_ALL, BTC_ANT_FREERUN);\n\t_set_policy(rtwdev, BTC_CXP_OFF_BT, BTC_ACT_FREERUN);\n\n\tbtc->dm.freerun = true;\n}\n\nstatic void _action_bt_whql(struct rtw89_dev *rtwdev)\n{\n\trtw89_debug(rtwdev, RTW89_DBG_BTC, \"[BTC], %s(): !!\\n\", __func__);\n\n\t_set_ant(rtwdev, FC_EXEC, BTC_PHY_ALL, BTC_ANT_W2G);\n\t_set_policy(rtwdev, BTC_CXP_OFF_BT, BTC_ACT_BT_WHQL);\n}\n\nstatic void _action_bt_off(struct rtw89_dev *rtwdev)\n{\n\trtw89_debug(rtwdev, RTW89_DBG_BTC, \"[BTC], %s(): !!\\n\", __func__);\n\n\t_set_ant(rtwdev, FC_EXEC, BTC_PHY_ALL, BTC_ANT_WONLY);\n\t_set_policy(rtwdev, BTC_CXP_OFF_BT, BTC_ACT_BT_OFF);\n}\n\nstatic void _action_bt_idle(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_bt_link_info *b = &btc->cx.bt.link_info;\n\n\t_set_ant(rtwdev, NM_EXEC, BTC_PHY_ALL, BTC_ANT_W2G);\n\n\tif (btc->mdinfo.ant.type == BTC_ANT_SHARED) {  \n\t\tswitch (btc->cx.state_map) {\n\t\tcase BTC_WBUSY_BNOSCAN:  \n\t\t\tif (b->profile_cnt.now > 0)\n\t\t\t\t_set_policy(rtwdev, BTC_CXP_FIX_TD4010,\n\t\t\t\t\t    BTC_ACT_BT_IDLE);\n\t\t\telse\n\t\t\t\t_set_policy(rtwdev, BTC_CXP_FIX_TD4020,\n\t\t\t\t\t    BTC_ACT_BT_IDLE);\n\t\t\tbreak;\n\t\tcase BTC_WBUSY_BSCAN:  \n\t\t\t_set_policy(rtwdev, BTC_CXP_PFIX_TD5050,\n\t\t\t\t    BTC_ACT_BT_IDLE);\n\t\t\tbreak;\n\t\tcase BTC_WSCAN_BNOSCAN:  \n\t\t\tif (b->profile_cnt.now > 0)\n\t\t\t\t_set_policy(rtwdev, BTC_CXP_FIX_TD4010,\n\t\t\t\t\t    BTC_ACT_BT_IDLE);\n\t\t\telse\n\t\t\t\t_set_policy(rtwdev, BTC_CXP_FIX_TD4020,\n\t\t\t\t\t    BTC_ACT_BT_IDLE);\n\t\t\tbreak;\n\t\tcase BTC_WSCAN_BSCAN:  \n\t\t\t_set_policy(rtwdev, BTC_CXP_FIX_TD5050,\n\t\t\t\t    BTC_ACT_BT_IDLE);\n\t\t\tbreak;\n\t\tcase BTC_WLINKING:  \n\t\t\t_set_policy(rtwdev, BTC_CXP_FIX_TD7010,\n\t\t\t\t    BTC_ACT_BT_IDLE);\n\t\t\tbreak;\n\t\tcase BTC_WIDLE:   \n\t\t\t_set_policy(rtwdev, BTC_CXP_OFF_BWB1, BTC_ACT_BT_IDLE);\n\t\t\tbreak;\n\t\t}\n\t} else {  \n\t\t_set_policy(rtwdev, BTC_CXP_OFF_EQ0, BTC_ACT_BT_IDLE);\n\t}\n}\n\nstatic void _action_bt_hfp(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_wl_info *wl = &btc->cx.wl;\n\n\t_set_ant(rtwdev, NM_EXEC, BTC_PHY_ALL, BTC_ANT_W2G);\n\n\tif (btc->mdinfo.ant.type == BTC_ANT_SHARED) {\n\t\tif (btc->cx.wl.status.map._4way) {\n\t\t\t_set_policy(rtwdev, BTC_CXP_OFF_WL, BTC_ACT_BT_HFP);\n\t\t} else if (wl->status.map.traffic_dir & BIT(RTW89_TFC_UL)) {\n\t\t\tbtc->cx.bt.scan_rx_low_pri = true;\n\t\t\t_set_policy(rtwdev, BTC_CXP_OFF_BWB2, BTC_ACT_BT_HFP);\n\t\t} else {\n\t\t\t_set_policy(rtwdev, BTC_CXP_OFF_BWB1, BTC_ACT_BT_HFP);\n\t\t}\n\t} else {\n\t\t_set_policy(rtwdev, BTC_CXP_OFF_EQ2, BTC_ACT_BT_HFP);\n\t}\n}\n\nstatic void _action_bt_hid(struct rtw89_dev *rtwdev)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_wl_info *wl = &btc->cx.wl;\n\tstruct rtw89_btc_bt_info *bt = &btc->cx.bt;\n\tstruct rtw89_btc_bt_hid_desc *hid = &bt->link_info.hid_desc;\n\tu16 policy_type = BTC_CXP_OFF_BT;\n\n\t_set_ant(rtwdev, NM_EXEC, BTC_PHY_ALL, BTC_ANT_W2G);\n\n\tif (btc->mdinfo.ant.type == BTC_ANT_SHARED) {  \n\t\tif (wl->status.map._4way) {\n\t\t\tpolicy_type = BTC_CXP_OFF_WL;\n\t\t} else if (wl->status.map.traffic_dir & BIT(RTW89_TFC_UL)) {\n\t\t\tbtc->cx.bt.scan_rx_low_pri = true;\n\t\t\tif (hid->type & BTC_HID_BLE)\n\t\t\t\tpolicy_type = BTC_CXP_OFF_BWB0;\n\t\t\telse\n\t\t\t\tpolicy_type = BTC_CXP_OFF_BWB2;\n\t\t} else if (hid->type == BTC_HID_218) {\n\t\t\tbt->scan_rx_low_pri = true;\n\t\t\tpolicy_type = BTC_CXP_OFF_BWB2;\n\t\t} else if (chip->para_ver == 0x1) {\n\t\t\tpolicy_type = BTC_CXP_OFF_BWB3;\n\t\t} else {\n\t\t\tpolicy_type = BTC_CXP_OFF_BWB1;\n\t\t}\n\t} else {  \n\t\tpolicy_type = BTC_CXP_OFF_EQ3;\n\t}\n\n\t_set_policy(rtwdev, policy_type, BTC_ACT_BT_HID);\n}\n\nstatic void _action_bt_a2dp(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_bt_link_info *bt_linfo = &btc->cx.bt.link_info;\n\tstruct rtw89_btc_bt_a2dp_desc a2dp = bt_linfo->a2dp_desc;\n\tstruct rtw89_btc_dm *dm = &btc->dm;\n\n\t_set_ant(rtwdev, NM_EXEC, BTC_PHY_ALL, BTC_ANT_W2G);\n\n\tswitch (btc->cx.state_map) {\n\tcase BTC_WBUSY_BNOSCAN:  \n\t\tif (a2dp.vendor_id == 0x4c || dm->leak_ap) {\n\t\t\tdm->slot_dur[CXST_W1] = 40;\n\t\t\tdm->slot_dur[CXST_B1] = 200;\n\t\t\t_set_policy(rtwdev,\n\t\t\t\t    BTC_CXP_PAUTO_TDW1B1, BTC_ACT_BT_A2DP);\n\t\t} else {\n\t\t\t_set_policy(rtwdev,\n\t\t\t\t    BTC_CXP_PAUTO_TD50B1, BTC_ACT_BT_A2DP);\n\t\t}\n\t\tbreak;\n\tcase BTC_WBUSY_BSCAN:  \n\t\t_set_policy(rtwdev, BTC_CXP_PAUTO2_TD3050, BTC_ACT_BT_A2DP);\n\t\tbreak;\n\tcase BTC_WSCAN_BSCAN:  \n\t\t_set_policy(rtwdev, BTC_CXP_AUTO2_TD3050, BTC_ACT_BT_A2DP);\n\t\tbreak;\n\tcase BTC_WSCAN_BNOSCAN:  \n\tcase BTC_WLINKING:  \n\t\tif (a2dp.vendor_id == 0x4c || dm->leak_ap) {\n\t\t\tdm->slot_dur[CXST_W1] = 40;\n\t\t\tdm->slot_dur[CXST_B1] = 200;\n\t\t\t_set_policy(rtwdev, BTC_CXP_AUTO_TDW1B1,\n\t\t\t\t    BTC_ACT_BT_A2DP);\n\t\t} else {\n\t\t\t_set_policy(rtwdev, BTC_CXP_AUTO_TD50B1,\n\t\t\t\t    BTC_ACT_BT_A2DP);\n\t\t}\n\t\tbreak;\n\tcase BTC_WIDLE:   \n\t\t_set_policy(rtwdev, BTC_CXP_AUTO_TD20B1, BTC_ACT_BT_A2DP);\n\t\tbreak;\n\t}\n}\n\nstatic void _action_bt_a2dpsink(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\n\t_set_ant(rtwdev, NM_EXEC, BTC_PHY_ALL, BTC_ANT_W2G);\n\n\tswitch (btc->cx.state_map) {\n\tcase BTC_WBUSY_BNOSCAN:  \n\t\t_set_policy(rtwdev, BTC_CXP_PFIX_TD2030, BTC_ACT_BT_A2DPSINK);\n\t\tbreak;\n\tcase BTC_WBUSY_BSCAN:  \n\t\t_set_policy(rtwdev, BTC_CXP_PFIX_TD2060, BTC_ACT_BT_A2DPSINK);\n\t\tbreak;\n\tcase BTC_WSCAN_BNOSCAN:  \n\t\t_set_policy(rtwdev, BTC_CXP_FIX_TD2030, BTC_ACT_BT_A2DPSINK);\n\t\tbreak;\n\tcase BTC_WSCAN_BSCAN:  \n\t\t_set_policy(rtwdev, BTC_CXP_FIX_TD2060, BTC_ACT_BT_A2DPSINK);\n\t\tbreak;\n\tcase BTC_WLINKING:  \n\t\t_set_policy(rtwdev, BTC_CXP_FIX_TD3030, BTC_ACT_BT_A2DPSINK);\n\t\tbreak;\n\tcase BTC_WIDLE:  \n\t\t_set_policy(rtwdev, BTC_CXP_FIX_TD2080, BTC_ACT_BT_A2DPSINK);\n\t\tbreak;\n\t}\n}\n\nstatic void _action_bt_pan(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\n\t_set_ant(rtwdev, NM_EXEC, BTC_PHY_ALL, BTC_ANT_W2G);\n\n\tswitch (btc->cx.state_map) {\n\tcase BTC_WBUSY_BNOSCAN:  \n\t\t_set_policy(rtwdev, BTC_CXP_PFIX_TD5050, BTC_ACT_BT_PAN);\n\t\tbreak;\n\tcase BTC_WBUSY_BSCAN:  \n\t\t_set_policy(rtwdev, BTC_CXP_PFIX_TD3070, BTC_ACT_BT_PAN);\n\t\tbreak;\n\tcase BTC_WSCAN_BNOSCAN:  \n\t\t_set_policy(rtwdev, BTC_CXP_FIX_TD3030, BTC_ACT_BT_PAN);\n\t\tbreak;\n\tcase BTC_WSCAN_BSCAN:  \n\t\t_set_policy(rtwdev, BTC_CXP_FIX_TD3060, BTC_ACT_BT_PAN);\n\t\tbreak;\n\tcase BTC_WLINKING:  \n\t\t_set_policy(rtwdev, BTC_CXP_FIX_TD4020, BTC_ACT_BT_PAN);\n\t\tbreak;\n\tcase BTC_WIDLE:  \n\t\t_set_policy(rtwdev, BTC_CXP_PFIX_TD2080, BTC_ACT_BT_PAN);\n\t\tbreak;\n\t}\n}\n\nstatic void _action_bt_a2dp_hid(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_bt_link_info *bt_linfo = &btc->cx.bt.link_info;\n\tstruct rtw89_btc_bt_a2dp_desc a2dp = bt_linfo->a2dp_desc;\n\tstruct rtw89_btc_dm *dm = &btc->dm;\n\n\t_set_ant(rtwdev, NM_EXEC, BTC_PHY_ALL, BTC_ANT_W2G);\n\n\tswitch (btc->cx.state_map) {\n\tcase BTC_WBUSY_BNOSCAN:  \n\tcase BTC_WIDLE:   \n\t\tif (a2dp.vendor_id == 0x4c || dm->leak_ap) {\n\t\t\tdm->slot_dur[CXST_W1] = 40;\n\t\t\tdm->slot_dur[CXST_B1] = 200;\n\t\t\t_set_policy(rtwdev,\n\t\t\t\t    BTC_CXP_PAUTO_TDW1B1, BTC_ACT_BT_A2DP_HID);\n\t\t} else {\n\t\t\t_set_policy(rtwdev,\n\t\t\t\t    BTC_CXP_PAUTO_TD50B1, BTC_ACT_BT_A2DP_HID);\n\t\t}\n\t\tbreak;\n\tcase BTC_WBUSY_BSCAN:  \n\t\t_set_policy(rtwdev, BTC_CXP_PAUTO2_TD3050, BTC_ACT_BT_A2DP_HID);\n\t\tbreak;\n\n\tcase BTC_WSCAN_BSCAN:  \n\t\t_set_policy(rtwdev, BTC_CXP_AUTO2_TD3050, BTC_ACT_BT_A2DP_HID);\n\t\tbreak;\n\tcase BTC_WSCAN_BNOSCAN:  \n\tcase BTC_WLINKING:  \n\t\tif (a2dp.vendor_id == 0x4c || dm->leak_ap) {\n\t\t\tdm->slot_dur[CXST_W1] = 40;\n\t\t\tdm->slot_dur[CXST_B1] = 200;\n\t\t\t_set_policy(rtwdev, BTC_CXP_AUTO_TDW1B1,\n\t\t\t\t    BTC_ACT_BT_A2DP_HID);\n\t\t} else {\n\t\t\t_set_policy(rtwdev, BTC_CXP_AUTO_TD50B1,\n\t\t\t\t    BTC_ACT_BT_A2DP_HID);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void _action_bt_a2dp_pan(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\n\t_set_ant(rtwdev, NM_EXEC, BTC_PHY_ALL, BTC_ANT_W2G);\n\n\tswitch (btc->cx.state_map) {\n\tcase BTC_WBUSY_BNOSCAN:  \n\t\t_set_policy(rtwdev, BTC_CXP_PAUTO2_TD3070, BTC_ACT_BT_A2DP_PAN);\n\t\tbreak;\n\tcase BTC_WBUSY_BSCAN:  \n\t\t_set_policy(rtwdev, BTC_CXP_PAUTO2_TD3070, BTC_ACT_BT_A2DP_PAN);\n\t\tbreak;\n\tcase BTC_WSCAN_BNOSCAN:  \n\t\t_set_policy(rtwdev, BTC_CXP_AUTO2_TD5050, BTC_ACT_BT_A2DP_PAN);\n\t\tbreak;\n\tcase BTC_WSCAN_BSCAN:  \n\t\t_set_policy(rtwdev, BTC_CXP_AUTO2_TD3070, BTC_ACT_BT_A2DP_PAN);\n\t\tbreak;\n\tcase BTC_WLINKING:  \n\t\t_set_policy(rtwdev, BTC_CXP_AUTO2_TD3050, BTC_ACT_BT_A2DP_PAN);\n\t\tbreak;\n\tcase BTC_WIDLE:   \n\t\t_set_policy(rtwdev, BTC_CXP_PAUTO2_TD2080, BTC_ACT_BT_A2DP_PAN);\n\t\tbreak;\n\t}\n}\n\nstatic void _action_bt_pan_hid(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\n\t_set_ant(rtwdev, NM_EXEC, BTC_PHY_ALL, BTC_ANT_W2G);\n\n\tswitch (btc->cx.state_map) {\n\tcase BTC_WBUSY_BNOSCAN:  \n\t\t_set_policy(rtwdev, BTC_CXP_PFIX_TD3030, BTC_ACT_BT_PAN_HID);\n\t\tbreak;\n\tcase BTC_WBUSY_BSCAN:  \n\t\t_set_policy(rtwdev, BTC_CXP_PFIX_TD3070, BTC_ACT_BT_PAN_HID);\n\t\tbreak;\n\tcase BTC_WSCAN_BNOSCAN:  \n\t\t_set_policy(rtwdev, BTC_CXP_FIX_TD3030, BTC_ACT_BT_PAN_HID);\n\t\tbreak;\n\tcase BTC_WSCAN_BSCAN:  \n\t\t_set_policy(rtwdev, BTC_CXP_FIX_TD3060, BTC_ACT_BT_PAN_HID);\n\t\tbreak;\n\tcase BTC_WLINKING:  \n\t\t_set_policy(rtwdev, BTC_CXP_FIX_TD4010, BTC_ACT_BT_PAN_HID);\n\t\tbreak;\n\tcase BTC_WIDLE:  \n\t\t_set_policy(rtwdev, BTC_CXP_PFIX_TD2080, BTC_ACT_BT_PAN_HID);\n\t\tbreak;\n\t}\n}\n\nstatic void _action_bt_a2dp_pan_hid(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\n\t_set_ant(rtwdev, NM_EXEC, BTC_PHY_ALL, BTC_ANT_W2G);\n\n\tswitch (btc->cx.state_map) {\n\tcase BTC_WBUSY_BNOSCAN:  \n\t\t_set_policy(rtwdev, BTC_CXP_PAUTO2_TD3070,\n\t\t\t    BTC_ACT_BT_A2DP_PAN_HID);\n\t\tbreak;\n\tcase BTC_WBUSY_BSCAN:  \n\t\t_set_policy(rtwdev, BTC_CXP_PAUTO2_TD3070,\n\t\t\t    BTC_ACT_BT_A2DP_PAN_HID);\n\t\tbreak;\n\tcase BTC_WSCAN_BSCAN:  \n\t\t_set_policy(rtwdev, BTC_CXP_AUTO2_TD3070,\n\t\t\t    BTC_ACT_BT_A2DP_PAN_HID);\n\t\tbreak;\n\tcase BTC_WSCAN_BNOSCAN:  \n\tcase BTC_WLINKING:  \n\t\t_set_policy(rtwdev, BTC_CXP_AUTO2_TD3050,\n\t\t\t    BTC_ACT_BT_A2DP_PAN_HID);\n\t\tbreak;\n\tcase BTC_WIDLE:   \n\t\t_set_policy(rtwdev, BTC_CXP_PAUTO2_TD2080,\n\t\t\t    BTC_ACT_BT_A2DP_PAN_HID);\n\t\tbreak;\n\t}\n}\n\nstatic void _action_wl_5g(struct rtw89_dev *rtwdev)\n{\n\t_set_ant(rtwdev, NM_EXEC, BTC_PHY_ALL, BTC_ANT_W5G);\n\t_set_policy(rtwdev, BTC_CXP_OFF_EQ0, BTC_ACT_WL_5G);\n}\n\nstatic void _action_wl_other(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\n\t_set_ant(rtwdev, NM_EXEC, BTC_PHY_ALL, BTC_ANT_W2G);\n\n\tif (btc->mdinfo.ant.type == BTC_ANT_SHARED)\n\t\t_set_policy(rtwdev, BTC_CXP_OFFB_BWB0, BTC_ACT_WL_OTHER);\n\telse\n\t\t_set_policy(rtwdev, BTC_CXP_OFF_EQ0, BTC_ACT_WL_OTHER);\n}\n\nstatic void _action_wl_nc(struct rtw89_dev *rtwdev)\n{\n\t_set_ant(rtwdev, NM_EXEC, BTC_PHY_ALL, BTC_ANT_W2G);\n\t_set_policy(rtwdev, BTC_CXP_OFF_BT, BTC_ACT_WL_NC);\n}\n\nstatic void _action_wl_rfk(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_wl_rfk_info rfk = btc->cx.wl.rfk_info;\n\n\tif (rfk.state != BTC_WRFK_START)\n\t\treturn;\n\n\trtw89_debug(rtwdev, RTW89_DBG_BTC, \"[BTC], %s(): band = %d\\n\",\n\t\t    __func__, rfk.band);\n\n\t_set_ant(rtwdev, FC_EXEC, BTC_PHY_ALL, BTC_ANT_WRFK);\n\t_set_policy(rtwdev, BTC_CXP_OFF_WL, BTC_ACT_WL_RFK);\n}\n\nstatic void _set_btg_ctrl(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tconst struct rtw89_btc_ver *ver = btc->ver;\n\tstruct rtw89_btc_wl_info *wl = &btc->cx.wl;\n\tstruct rtw89_btc_wl_role_info *wl_rinfo = &wl->role_info;\n\tstruct rtw89_btc_wl_role_info_v1 *wl_rinfo_v1 = &wl->role_info_v1;\n\tstruct rtw89_btc_wl_role_info_v2 *wl_rinfo_v2 = &wl->role_info_v2;\n\tstruct rtw89_btc_wl_dbcc_info *wl_dinfo = &wl->dbcc_info;\n\tbool is_btg;\n\tu8 mode;\n\n\tif (btc->ctrl.manual)\n\t\treturn;\n\n\tif (ver->fwlrole == 0)\n\t\tmode = wl_rinfo->link_mode;\n\telse if (ver->fwlrole == 1)\n\t\tmode = wl_rinfo_v1->link_mode;\n\telse if (ver->fwlrole == 2)\n\t\tmode = wl_rinfo_v2->link_mode;\n\telse\n\t\treturn;\n\n\t \n\tif (mode == BTC_WLINK_5G)  \n\t\tis_btg = false;\n\telse if (mode == BTC_WLINK_25G_DBCC &&\n\t\t wl_dinfo->real_band[RTW89_PHY_1] != RTW89_BAND_2G)\n\t\tis_btg = false;\n\telse\n\t\tis_btg = true;\n\n\tif (btc->dm.run_reason != BTC_RSN_NTFY_INIT &&\n\t    is_btg == btc->dm.wl_btg_rx)\n\t\treturn;\n\n\tbtc->dm.wl_btg_rx = is_btg;\n\n\tif (mode == BTC_WLINK_25G_MCC)\n\t\treturn;\n\n\trtw89_ctrl_btg(rtwdev, is_btg);\n}\n\nstruct rtw89_txtime_data {\n\tstruct rtw89_dev *rtwdev;\n\tint type;\n\tu32 tx_time;\n\tu8 tx_retry;\n\tu16 enable;\n\tbool reenable;\n};\n\nstatic void rtw89_tx_time_iter(void *data, struct ieee80211_sta *sta)\n{\n\tstruct rtw89_sta *rtwsta = (struct rtw89_sta *)sta->drv_priv;\n\tstruct rtw89_txtime_data *iter_data =\n\t\t\t\t(struct rtw89_txtime_data *)data;\n\tstruct rtw89_dev *rtwdev = iter_data->rtwdev;\n\tstruct rtw89_vif *rtwvif = rtwsta->rtwvif;\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_cx *cx = &btc->cx;\n\tstruct rtw89_btc_wl_info *wl = &cx->wl;\n\tstruct rtw89_btc_wl_link_info *plink = NULL;\n\tu8 port = rtwvif->port;\n\tu32 tx_time = iter_data->tx_time;\n\tu8 tx_retry = iter_data->tx_retry;\n\tu16 enable = iter_data->enable;\n\tbool reenable = iter_data->reenable;\n\n\tplink = &wl->link_info[port];\n\n\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t    \"[BTC], %s(): port = %d\\n\", __func__, port);\n\n\tif (!plink->connected) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t\t    \"[BTC], %s(): connected = %d\\n\",\n\t\t\t    __func__, plink->connected);\n\t\treturn;\n\t}\n\n\t \n\tif (reenable) {\n\t\trtw89_mac_get_tx_time(rtwdev, rtwsta, &plink->tx_time);\n\t\trtw89_mac_get_tx_retry_limit(rtwdev, rtwsta, &plink->tx_retry);\n\t\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t\t    \"[BTC], %s(): reenable, tx_time=%d tx_retry= %d\\n\",\n\t\t\t    __func__, plink->tx_time, plink->tx_retry);\n\t}\n\n\t \n\tif (!enable) {\n\t\trtw89_mac_set_tx_time(rtwdev, rtwsta, true, plink->tx_time);\n\t\trtw89_mac_set_tx_retry_limit(rtwdev, rtwsta, true,\n\t\t\t\t\t     plink->tx_retry);\n\t\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t\t    \"[BTC], %s(): restore, tx_time=%d tx_retry= %d\\n\",\n\t\t\t    __func__, plink->tx_time, plink->tx_retry);\n\n\t} else {\n\t\trtw89_mac_set_tx_time(rtwdev, rtwsta, false, tx_time);\n\t\trtw89_mac_set_tx_retry_limit(rtwdev, rtwsta, false, tx_retry);\n\t\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t\t    \"[BTC], %s(): set, tx_time=%d tx_retry= %d\\n\",\n\t\t\t    __func__, tx_time, tx_retry);\n\t}\n}\n\nstatic void _set_wl_tx_limit(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tconst struct rtw89_btc_ver *ver = btc->ver;\n\tstruct rtw89_btc_cx *cx = &btc->cx;\n\tstruct rtw89_btc_dm *dm = &btc->dm;\n\tstruct rtw89_btc_wl_info *wl = &cx->wl;\n\tstruct rtw89_btc_bt_info *bt = &cx->bt;\n\tstruct rtw89_btc_bt_link_info *b = &bt->link_info;\n\tstruct rtw89_btc_bt_hfp_desc *hfp = &b->hfp_desc;\n\tstruct rtw89_btc_bt_hid_desc *hid = &b->hid_desc;\n\tstruct rtw89_btc_wl_role_info *wl_rinfo = &wl->role_info;\n\tstruct rtw89_btc_wl_role_info_v1 *wl_rinfo_v1 = &wl->role_info_v1;\n\tstruct rtw89_btc_wl_role_info_v2 *wl_rinfo_v2 = &wl->role_info_v2;\n\tstruct rtw89_txtime_data data = {.rtwdev = rtwdev};\n\tu8 mode;\n\tu8 tx_retry;\n\tu32 tx_time;\n\tu16 enable;\n\tbool reenable = false;\n\n\tif (btc->ctrl.manual)\n\t\treturn;\n\n\tif (ver->fwlrole == 0)\n\t\tmode = wl_rinfo->link_mode;\n\telse if (ver->fwlrole == 1)\n\t\tmode = wl_rinfo_v1->link_mode;\n\telse if (ver->fwlrole == 2)\n\t\tmode = wl_rinfo_v2->link_mode;\n\telse\n\t\treturn;\n\n\tif (btc->dm.freerun || btc->ctrl.igno_bt || b->profile_cnt.now == 0 ||\n\t    mode == BTC_WLINK_5G || mode == BTC_WLINK_NOLINK) {\n\t\tenable = 0;\n\t\ttx_time = BTC_MAX_TX_TIME_DEF;\n\t\ttx_retry = BTC_MAX_TX_RETRY_DEF;\n\t} else if ((hfp->exist && hid->exist) || hid->pair_cnt > 1) {\n\t\tenable = 1;\n\t\ttx_time = BTC_MAX_TX_TIME_L2;\n\t\ttx_retry = BTC_MAX_TX_RETRY_L1;\n\t} else if (hfp->exist || hid->exist) {\n\t\tenable = 1;\n\t\ttx_time = BTC_MAX_TX_TIME_L3;\n\t\ttx_retry = BTC_MAX_TX_RETRY_L1;\n\t} else {\n\t\tenable = 0;\n\t\ttx_time = BTC_MAX_TX_TIME_DEF;\n\t\ttx_retry = BTC_MAX_TX_RETRY_DEF;\n\t}\n\n\tif (dm->wl_tx_limit.enable == enable &&\n\t    dm->wl_tx_limit.tx_time == tx_time &&\n\t    dm->wl_tx_limit.tx_retry == tx_retry)\n\t\treturn;\n\n\tif (!dm->wl_tx_limit.enable && enable)\n\t\treenable = true;\n\n\tdm->wl_tx_limit.enable = enable;\n\tdm->wl_tx_limit.tx_time = tx_time;\n\tdm->wl_tx_limit.tx_retry = tx_retry;\n\n\tdata.enable = enable;\n\tdata.tx_time = tx_time;\n\tdata.tx_retry = tx_retry;\n\tdata.reenable = reenable;\n\n\tieee80211_iterate_stations_atomic(rtwdev->hw,\n\t\t\t\t\t  rtw89_tx_time_iter,\n\t\t\t\t\t  &data);\n}\n\nstatic void _set_bt_rx_agc(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tconst struct rtw89_btc_ver *ver = btc->ver;\n\tstruct rtw89_btc_wl_info *wl = &btc->cx.wl;\n\tstruct rtw89_btc_wl_role_info *wl_rinfo = &wl->role_info;\n\tstruct rtw89_btc_wl_role_info_v1 *wl_rinfo_v1 = &wl->role_info_v1;\n\tstruct rtw89_btc_wl_role_info_v2 *wl_rinfo_v2 = &wl->role_info_v2;\n\tstruct rtw89_btc_bt_info *bt = &btc->cx.bt;\n\tbool bt_hi_lna_rx = false;\n\tu8 mode;\n\n\tif (ver->fwlrole == 0)\n\t\tmode = wl_rinfo->link_mode;\n\telse if (ver->fwlrole == 1)\n\t\tmode = wl_rinfo_v1->link_mode;\n\telse if (ver->fwlrole == 2)\n\t\tmode = wl_rinfo_v2->link_mode;\n\telse\n\t\treturn;\n\n\tif (mode != BTC_WLINK_NOLINK && btc->dm.wl_btg_rx)\n\t\tbt_hi_lna_rx = true;\n\n\tif (bt_hi_lna_rx == bt->hi_lna_rx)\n\t\treturn;\n\n\t_write_scbd(rtwdev, BTC_WSCB_BT_HILNA, bt_hi_lna_rx);\n}\n\nstatic void _set_bt_rx_scan_pri(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_bt_info *bt = &btc->cx.bt;\n\n\t_write_scbd(rtwdev, BTC_WSCB_RXSCAN_PRI, (bool)(!!bt->scan_rx_low_pri));\n}\n\n \nstatic void _action_common(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_wl_info *wl = &btc->cx.wl;\n\n\t_set_btg_ctrl(rtwdev);\n\t_set_wl_tx_limit(rtwdev);\n\t_set_bt_afh_info(rtwdev);\n\t_set_bt_rx_agc(rtwdev);\n\t_set_rf_trx_para(rtwdev);\n\t_set_bt_rx_scan_pri(rtwdev);\n\n\tif (wl->scbd_change) {\n\t\trtw89_mac_cfg_sb(rtwdev, wl->scbd);\n\t\trtw89_debug(rtwdev, RTW89_DBG_BTC, \"[BTC], write scbd: 0x%08x\\n\",\n\t\t\t    wl->scbd);\n\t\twl->scbd_change = false;\n\t\tbtc->cx.cnt_wl[BTC_WCNT_SCBDUPDATE]++;\n\t}\n\tbtc->dm.tdma_instant_excute = 0;\n}\n\nstatic void _action_by_bt(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_bt_info *bt = &btc->cx.bt;\n\tstruct rtw89_btc_bt_link_info *bt_linfo = &bt->link_info;\n\tstruct rtw89_btc_bt_hid_desc hid = bt_linfo->hid_desc;\n\tstruct rtw89_btc_bt_a2dp_desc a2dp = bt_linfo->a2dp_desc;\n\tstruct rtw89_btc_bt_pan_desc pan = bt_linfo->pan_desc;\n\tu8 profile_map = 0;\n\n\tif (bt_linfo->hfp_desc.exist)\n\t\tprofile_map |= BTC_BT_HFP;\n\n\tif (bt_linfo->hid_desc.exist)\n\t\tprofile_map |= BTC_BT_HID;\n\n\tif (bt_linfo->a2dp_desc.exist)\n\t\tprofile_map |= BTC_BT_A2DP;\n\n\tif (bt_linfo->pan_desc.exist)\n\t\tprofile_map |= BTC_BT_PAN;\n\n\tswitch (profile_map) {\n\tcase BTC_BT_NOPROFILE:\n\t\tif (_check_freerun(rtwdev))\n\t\t\t_action_freerun(rtwdev);\n\t\telse if (pan.active)\n\t\t\t_action_bt_pan(rtwdev);\n\t\telse\n\t\t\t_action_bt_idle(rtwdev);\n\t\tbreak;\n\tcase BTC_BT_HFP:\n\t\tif (_check_freerun(rtwdev))\n\t\t\t_action_freerun(rtwdev);\n\t\telse\n\t\t\t_action_bt_hfp(rtwdev);\n\t\tbreak;\n\tcase BTC_BT_HFP | BTC_BT_HID:\n\tcase BTC_BT_HID:\n\t\tif (_check_freerun(rtwdev))\n\t\t\t_action_freerun(rtwdev);\n\t\telse\n\t\t\t_action_bt_hid(rtwdev);\n\t\tbreak;\n\tcase BTC_BT_A2DP:\n\t\tif (_check_freerun(rtwdev))\n\t\t\t_action_freerun(rtwdev);\n\t\telse if (a2dp.sink)\n\t\t\t_action_bt_a2dpsink(rtwdev);\n\t\telse if (bt_linfo->multi_link.now && !hid.pair_cnt)\n\t\t\t_action_bt_a2dp_pan(rtwdev);\n\t\telse\n\t\t\t_action_bt_a2dp(rtwdev);\n\t\tbreak;\n\tcase BTC_BT_PAN:\n\t\t_action_bt_pan(rtwdev);\n\t\tbreak;\n\tcase BTC_BT_A2DP | BTC_BT_HFP:\n\tcase BTC_BT_A2DP | BTC_BT_HID:\n\tcase BTC_BT_A2DP | BTC_BT_HFP | BTC_BT_HID:\n\t\tif (_check_freerun(rtwdev))\n\t\t\t_action_freerun(rtwdev);\n\t\telse\n\t\t\t_action_bt_a2dp_hid(rtwdev);\n\t\tbreak;\n\tcase BTC_BT_A2DP | BTC_BT_PAN:\n\t\t_action_bt_a2dp_pan(rtwdev);\n\t\tbreak;\n\tcase BTC_BT_PAN | BTC_BT_HFP:\n\tcase BTC_BT_PAN | BTC_BT_HID:\n\tcase BTC_BT_PAN | BTC_BT_HFP | BTC_BT_HID:\n\t\t_action_bt_pan_hid(rtwdev);\n\t\tbreak;\n\tcase BTC_BT_A2DP | BTC_BT_PAN | BTC_BT_HID:\n\tcase BTC_BT_A2DP | BTC_BT_PAN | BTC_BT_HFP:\n\tdefault:\n\t\t_action_bt_a2dp_pan_hid(rtwdev);\n\t\tbreak;\n\t}\n}\n\nstatic void _action_wl_2g_sta(struct rtw89_dev *rtwdev)\n{\n\t_action_by_bt(rtwdev);\n}\n\nstatic void _action_wl_scan(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_wl_info *wl = &btc->cx.wl;\n\tstruct rtw89_btc_wl_dbcc_info *wl_dinfo = &wl->dbcc_info;\n\n\tif (RTW89_CHK_FW_FEATURE(SCAN_OFFLOAD, &rtwdev->fw)) {\n\t\t_set_ant(rtwdev, NM_EXEC, BTC_PHY_ALL, BTC_ANT_W25G);\n\t\tif (btc->mdinfo.ant.type == BTC_ANT_SHARED)\n\t\t\t_set_policy(rtwdev, BTC_CXP_OFFE_DEF,\n\t\t\t\t    BTC_RSN_NTFY_SCAN_START);\n\t\telse\n\t\t\t_set_policy(rtwdev, BTC_CXP_OFF_EQ0,\n\t\t\t\t    BTC_RSN_NTFY_SCAN_START);\n\n\t\trtw89_debug(rtwdev, RTW89_DBG_BTC, \"[BTC], Scan offload!\\n\");\n\t} else if (rtwdev->dbcc_en) {\n\t\tif (wl_dinfo->real_band[RTW89_PHY_0] != RTW89_BAND_2G &&\n\t\t    wl_dinfo->real_band[RTW89_PHY_1] != RTW89_BAND_2G)\n\t\t\t_action_wl_5g(rtwdev);\n\t\telse\n\t\t\t_action_by_bt(rtwdev);\n\t} else {\n\t\tif (wl->scan_info.band[RTW89_PHY_0] != RTW89_BAND_2G)\n\t\t\t_action_wl_5g(rtwdev);\n\t\telse\n\t\t\t_action_by_bt(rtwdev);\n\t}\n}\n\nstatic void _action_wl_25g_mcc(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\n\t_set_ant(rtwdev, NM_EXEC, BTC_PHY_ALL, BTC_ANT_W25G);\n\n\tif (btc->mdinfo.ant.type == BTC_ANT_SHARED) {\n\t\tif (btc->cx.bt.link_info.profile_cnt.now == 0)\n\t\t\t_set_policy(rtwdev, BTC_CXP_OFFE_DEF2,\n\t\t\t\t    BTC_ACT_WL_25G_MCC);\n\t\telse\n\t\t\t_set_policy(rtwdev, BTC_CXP_OFFE_DEF,\n\t\t\t\t    BTC_ACT_WL_25G_MCC);\n\t} else {  \n\t\t_set_policy(rtwdev, BTC_CXP_OFF_EQ0, BTC_ACT_WL_25G_MCC);\n\t}\n}\n\nstatic void _action_wl_2g_mcc(struct rtw89_dev *rtwdev)\n{\tstruct rtw89_btc *btc = &rtwdev->btc;\n\n\t_set_ant(rtwdev, NM_EXEC, BTC_PHY_ALL, BTC_ANT_W2G);\n\n\tif (btc->mdinfo.ant.type == BTC_ANT_SHARED) {  \n\t\tif (btc->cx.bt.link_info.profile_cnt.now == 0)\n\t\t\t_set_policy(rtwdev, BTC_CXP_OFFE_DEF2,\n\t\t\t\t    BTC_ACT_WL_2G_MCC);\n\t\telse\n\t\t\t_set_policy(rtwdev, BTC_CXP_OFFE_DEF,\n\t\t\t\t    BTC_ACT_WL_2G_MCC);\n\t} else {  \n\t\t_set_policy(rtwdev, BTC_CXP_OFF_EQ0, BTC_ACT_WL_2G_MCC);\n\t}\n}\n\nstatic void _action_wl_2g_scc(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\n\t_set_ant(rtwdev, NM_EXEC, BTC_PHY_ALL, BTC_ANT_W2G);\n\n\tif (btc->mdinfo.ant.type == BTC_ANT_SHARED) {  \n\t\tif (btc->cx.bt.link_info.profile_cnt.now == 0)\n\t\t\t_set_policy(rtwdev,\n\t\t\t\t    BTC_CXP_OFFE_DEF2, BTC_ACT_WL_2G_SCC);\n\t\telse\n\t\t\t_set_policy(rtwdev,\n\t\t\t\t    BTC_CXP_OFFE_DEF, BTC_ACT_WL_2G_SCC);\n\t} else {  \n\t\t_set_policy(rtwdev, BTC_CXP_OFF_EQ0, BTC_ACT_WL_2G_SCC);\n\t}\n}\n\nstatic void _action_wl_2g_scc_v1(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_wl_info *wl = &btc->cx.wl;\n\tstruct rtw89_btc_bt_info *bt = &btc->cx.bt;\n\tstruct rtw89_btc_dm *dm = &btc->dm;\n\tstruct rtw89_btc_wl_role_info_v1 *wl_rinfo = &wl->role_info_v1;\n\tu16 policy_type = BTC_CXP_OFF_BT;\n\tu32 dur;\n\n\tif (btc->mdinfo.ant.type == BTC_ANT_DEDICATED) {\n\t\tpolicy_type = BTC_CXP_OFF_EQ0;\n\t} else {\n\t\t \n\t\tswitch (wl_rinfo->mrole_type) {\n\t\tcase BTC_WLMROLE_STA_GC:\n\t\t\tdm->wl_scc.null_role1 = RTW89_WIFI_ROLE_STATION;\n\t\t\tdm->wl_scc.null_role2 = RTW89_WIFI_ROLE_P2P_CLIENT;\n\t\t\tdm->wl_scc.ebt_null = 0;  \n\t\t\t_action_by_bt(rtwdev);\n\t\t\treturn;\n\t\tcase BTC_WLMROLE_STA_STA:\n\t\t\tdm->wl_scc.null_role1 = RTW89_WIFI_ROLE_STATION;\n\t\t\tdm->wl_scc.null_role2 = RTW89_WIFI_ROLE_STATION;\n\t\t\tdm->wl_scc.ebt_null = 0;  \n\t\t\t_action_by_bt(rtwdev);\n\t\t\treturn;\n\t\tcase BTC_WLMROLE_STA_GC_NOA:\n\t\tcase BTC_WLMROLE_STA_GO:\n\t\tcase BTC_WLMROLE_STA_GO_NOA:\n\t\t\tdm->wl_scc.null_role1 = RTW89_WIFI_ROLE_STATION;\n\t\t\tdm->wl_scc.null_role2 = RTW89_WIFI_ROLE_NONE;\n\t\t\tdur = wl_rinfo->mrole_noa_duration;\n\n\t\t\tif (wl->status.map._4way) {\n\t\t\t\tdm->wl_scc.ebt_null = 0;\n\t\t\t\tpolicy_type = BTC_CXP_OFFE_WL;\n\t\t\t} else if (bt->link_info.status.map.connect == 0) {\n\t\t\t\tdm->wl_scc.ebt_null = 0;\n\t\t\t\tpolicy_type = BTC_CXP_OFFE_2GISOB;\n\t\t\t} else if (bt->link_info.a2dp_desc.exist &&\n\t\t\t\t   dur < btc->bt_req_len) {\n\t\t\t\tdm->wl_scc.ebt_null = 1;  \n\t\t\t\tpolicy_type = BTC_CXP_OFFE_2GBWMIXB2;\n\t\t\t} else if (bt->link_info.a2dp_desc.exist ||\n\t\t\t\t   bt->link_info.pan_desc.exist) {\n\t\t\t\tdm->wl_scc.ebt_null = 1;  \n\t\t\t\tpolicy_type = BTC_CXP_OFFE_2GBWISOB;\n\t\t\t} else {\n\t\t\t\tdm->wl_scc.ebt_null = 0;\n\t\t\t\tpolicy_type = BTC_CXP_OFFE_2GBWISOB;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t_set_ant(rtwdev, NM_EXEC, BTC_PHY_ALL, BTC_ANT_W2G);\n\t_set_policy(rtwdev, policy_type, BTC_ACT_WL_2G_SCC);\n}\n\nstatic void _action_wl_2g_scc_v2(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_wl_info *wl = &btc->cx.wl;\n\tstruct rtw89_btc_bt_info *bt = &btc->cx.bt;\n\tstruct rtw89_btc_dm *dm = &btc->dm;\n\tstruct rtw89_btc_wl_role_info_v2 *wl_rinfo = &wl->role_info_v2;\n\tu16 policy_type = BTC_CXP_OFF_BT;\n\tu32 dur;\n\n\tif (btc->mdinfo.ant.type == BTC_ANT_DEDICATED) {\n\t\tpolicy_type = BTC_CXP_OFF_EQ0;\n\t} else {\n\t\t \n\t\tswitch (wl_rinfo->mrole_type) {\n\t\tcase BTC_WLMROLE_STA_GC:\n\t\t\tdm->wl_scc.null_role1 = RTW89_WIFI_ROLE_STATION;\n\t\t\tdm->wl_scc.null_role2 = RTW89_WIFI_ROLE_P2P_CLIENT;\n\t\t\tdm->wl_scc.ebt_null = 0;  \n\t\t\t_action_by_bt(rtwdev);\n\t\t\treturn;\n\t\tcase BTC_WLMROLE_STA_STA:\n\t\t\tdm->wl_scc.null_role1 = RTW89_WIFI_ROLE_STATION;\n\t\t\tdm->wl_scc.null_role2 = RTW89_WIFI_ROLE_STATION;\n\t\t\tdm->wl_scc.ebt_null = 0;  \n\t\t\t_action_by_bt(rtwdev);\n\t\t\treturn;\n\t\tcase BTC_WLMROLE_STA_GC_NOA:\n\t\tcase BTC_WLMROLE_STA_GO:\n\t\tcase BTC_WLMROLE_STA_GO_NOA:\n\t\t\tdm->wl_scc.null_role1 = RTW89_WIFI_ROLE_STATION;\n\t\t\tdm->wl_scc.null_role2 = RTW89_WIFI_ROLE_NONE;\n\t\t\tdur = wl_rinfo->mrole_noa_duration;\n\n\t\t\tif (wl->status.map._4way) {\n\t\t\t\tdm->wl_scc.ebt_null = 0;\n\t\t\t\tpolicy_type = BTC_CXP_OFFE_WL;\n\t\t\t} else if (bt->link_info.status.map.connect == 0) {\n\t\t\t\tdm->wl_scc.ebt_null = 0;\n\t\t\t\tpolicy_type = BTC_CXP_OFFE_2GISOB;\n\t\t\t} else if (bt->link_info.a2dp_desc.exist &&\n\t\t\t\t   dur < btc->bt_req_len) {\n\t\t\t\tdm->wl_scc.ebt_null = 1;  \n\t\t\t\tpolicy_type = BTC_CXP_OFFE_2GBWMIXB2;\n\t\t\t} else if (bt->link_info.a2dp_desc.exist ||\n\t\t\t\t   bt->link_info.pan_desc.exist) {\n\t\t\t\tdm->wl_scc.ebt_null = 1;  \n\t\t\t\tpolicy_type = BTC_CXP_OFFE_2GBWISOB;\n\t\t\t} else {\n\t\t\t\tdm->wl_scc.ebt_null = 0;\n\t\t\t\tpolicy_type = BTC_CXP_OFFE_2GBWISOB;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t_set_ant(rtwdev, NM_EXEC, BTC_PHY_ALL, BTC_ANT_W2G);\n\t_set_policy(rtwdev, policy_type, BTC_ACT_WL_2G_SCC);\n}\n\nstatic void _action_wl_2g_ap(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\n\t_set_ant(rtwdev, NM_EXEC, BTC_PHY_ALL, BTC_ANT_W2G);\n\n\tif (btc->mdinfo.ant.type == BTC_ANT_SHARED) {\n\t\tif (btc->cx.bt.link_info.profile_cnt.now == 0)\n\t\t\t_set_policy(rtwdev, BTC_CXP_OFFE_DEF2,\n\t\t\t\t    BTC_ACT_WL_2G_AP);\n\t\telse\n\t\t\t_set_policy(rtwdev, BTC_CXP_OFFE_DEF, BTC_ACT_WL_2G_AP);\n\t} else { \n\t\t_set_policy(rtwdev, BTC_CXP_OFF_EQ0, BTC_ACT_WL_2G_AP);\n\t}\n}\n\nstatic void _action_wl_2g_go(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\n\t_set_ant(rtwdev, NM_EXEC, BTC_PHY_ALL, BTC_ANT_W2G);\n\n\tif (btc->mdinfo.ant.type == BTC_ANT_SHARED) {  \n\t\tif (btc->cx.bt.link_info.profile_cnt.now == 0)\n\t\t\t_set_policy(rtwdev,\n\t\t\t\t    BTC_CXP_OFFE_DEF2, BTC_ACT_WL_2G_GO);\n\t\telse\n\t\t\t_set_policy(rtwdev,\n\t\t\t\t    BTC_CXP_OFFE_DEF, BTC_ACT_WL_2G_GO);\n\t} else {  \n\t\t_set_policy(rtwdev, BTC_CXP_OFF_EQ0, BTC_ACT_WL_2G_GO);\n\t}\n}\n\nstatic void _action_wl_2g_gc(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\n\t_set_ant(rtwdev, NM_EXEC, BTC_PHY_ALL, BTC_ANT_W2G);\n\n\tif (btc->mdinfo.ant.type == BTC_ANT_SHARED) {  \n\t\t_action_by_bt(rtwdev);\n\t} else { \n\t\t_set_policy(rtwdev, BTC_CXP_OFF_EQ0, BTC_ACT_WL_2G_GC);\n\t}\n}\n\nstatic void _action_wl_2g_nan(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\n\t_set_ant(rtwdev, NM_EXEC, BTC_PHY_ALL, BTC_ANT_W2G);\n\n\tif (btc->mdinfo.ant.type == BTC_ANT_SHARED) {  \n\t\tif (btc->cx.bt.link_info.profile_cnt.now == 0)\n\t\t\t_set_policy(rtwdev,\n\t\t\t\t    BTC_CXP_OFFE_DEF2, BTC_ACT_WL_2G_NAN);\n\t\telse\n\t\t\t_set_policy(rtwdev,\n\t\t\t\t    BTC_CXP_OFFE_DEF, BTC_ACT_WL_2G_NAN);\n\t} else {  \n\t\t_set_policy(rtwdev, BTC_CXP_OFF_EQ0, BTC_ACT_WL_2G_NAN);\n\t}\n}\n\nstatic u32 _read_scbd(struct rtw89_dev *rtwdev)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tu32 scbd_val = 0;\n\n\tif (!chip->scbd)\n\t\treturn 0;\n\n\tscbd_val = rtw89_mac_get_sb(rtwdev);\n\trtw89_debug(rtwdev, RTW89_DBG_BTC, \"[BTC], read scbd: 0x%08x\\n\",\n\t\t    scbd_val);\n\n\tbtc->cx.cnt_bt[BTC_BCNT_SCBDREAD]++;\n\treturn scbd_val;\n}\n\nstatic void _write_scbd(struct rtw89_dev *rtwdev, u32 val, bool state)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_wl_info *wl = &btc->cx.wl;\n\tu32 scbd_val = 0;\n\tu8 force_exec = false;\n\n\tif (!chip->scbd)\n\t\treturn;\n\n\tscbd_val = state ? wl->scbd | val : wl->scbd & ~val;\n\n\tif (val & BTC_WSCB_ACTIVE || val & BTC_WSCB_ON)\n\t\tforce_exec = true;\n\n\tif (scbd_val != wl->scbd || force_exec) {\n\t\twl->scbd = scbd_val;\n\t\twl->scbd_change = true;\n\t}\n}\n\nstatic u8\n_update_rssi_state(struct rtw89_dev *rtwdev, u8 pre_state, u8 rssi, u8 thresh)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tu8 next_state, tol = chip->rssi_tol;\n\n\tif (pre_state == BTC_RSSI_ST_LOW ||\n\t    pre_state == BTC_RSSI_ST_STAY_LOW) {\n\t\tif (rssi >= (thresh + tol))\n\t\t\tnext_state = BTC_RSSI_ST_HIGH;\n\t\telse\n\t\t\tnext_state = BTC_RSSI_ST_STAY_LOW;\n\t} else {\n\t\tif (rssi < thresh)\n\t\t\tnext_state = BTC_RSSI_ST_LOW;\n\t\telse\n\t\t\tnext_state = BTC_RSSI_ST_STAY_HIGH;\n\t}\n\n\treturn next_state;\n}\n\nstatic\nvoid _update_dbcc_band(struct rtw89_dev *rtwdev, enum rtw89_phy_idx phy_idx)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\n\tbtc->cx.wl.dbcc_info.real_band[phy_idx] =\n\t\tbtc->cx.wl.scan_info.phy_map & BIT(phy_idx) ?\n\t\tbtc->cx.wl.dbcc_info.scan_band[phy_idx] :\n\t\tbtc->cx.wl.dbcc_info.op_band[phy_idx];\n}\n\nstatic void _update_wl_info(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_wl_info *wl = &btc->cx.wl;\n\tstruct rtw89_btc_wl_link_info *wl_linfo = wl->link_info;\n\tstruct rtw89_btc_wl_role_info *wl_rinfo = &wl->role_info;\n\tstruct rtw89_btc_wl_dbcc_info *wl_dinfo = &wl->dbcc_info;\n\tu8 i, cnt_connect = 0, cnt_connecting = 0, cnt_active = 0;\n\tu8 cnt_2g = 0, cnt_5g = 0, phy;\n\tu32 wl_2g_ch[2] = {0}, wl_5g_ch[2] = {0};\n\tbool b2g = false, b5g = false, client_joined = false;\n\n\tmemset(wl_rinfo, 0, sizeof(*wl_rinfo));\n\n\tfor (i = 0; i < RTW89_PORT_NUM; i++) {\n\t\t \n\t\tif (!wl_linfo[i].active)\n\t\t\tcontinue;\n\n\t\tcnt_active++;\n\t\twl_rinfo->active_role[cnt_active - 1].role = wl_linfo[i].role;\n\t\twl_rinfo->active_role[cnt_active - 1].pid = wl_linfo[i].pid;\n\t\twl_rinfo->active_role[cnt_active - 1].phy = wl_linfo[i].phy;\n\t\twl_rinfo->active_role[cnt_active - 1].band = wl_linfo[i].band;\n\t\twl_rinfo->active_role[cnt_active - 1].noa = (u8)wl_linfo[i].noa;\n\t\twl_rinfo->active_role[cnt_active - 1].connected = 0;\n\n\t\twl->port_id[wl_linfo[i].role] = wl_linfo[i].pid;\n\n\t\tphy = wl_linfo[i].phy;\n\n\t\t \n\t\tif (rtwdev->dbcc_en && phy < RTW89_PHY_MAX) {\n\t\t\twl_dinfo->role[phy] = wl_linfo[i].role;\n\t\t\twl_dinfo->op_band[phy] = wl_linfo[i].band;\n\t\t\t_update_dbcc_band(rtwdev, phy);\n\t\t\t_fw_set_drv_info(rtwdev, CXDRVINFO_DBCC);\n\t\t}\n\n\t\tif (wl_linfo[i].connected == MLME_NO_LINK) {\n\t\t\tcontinue;\n\t\t} else if (wl_linfo[i].connected == MLME_LINKING) {\n\t\t\tcnt_connecting++;\n\t\t} else {\n\t\t\tcnt_connect++;\n\t\t\tif ((wl_linfo[i].role == RTW89_WIFI_ROLE_P2P_GO ||\n\t\t\t     wl_linfo[i].role == RTW89_WIFI_ROLE_AP) &&\n\t\t\t     wl_linfo[i].client_cnt > 1)\n\t\t\t\tclient_joined = true;\n\t\t}\n\n\t\twl_rinfo->role_map.val |= BIT(wl_linfo[i].role);\n\t\twl_rinfo->active_role[cnt_active - 1].ch = wl_linfo[i].ch;\n\t\twl_rinfo->active_role[cnt_active - 1].bw = wl_linfo[i].bw;\n\t\twl_rinfo->active_role[cnt_active - 1].connected = 1;\n\n\t\t \n\t\tif (wl_linfo[i].band != RTW89_BAND_2G) {\n\t\t\tif (cnt_5g <= ARRAY_SIZE(wl_5g_ch) - 1)\n\t\t\t\twl_5g_ch[cnt_5g] = wl_linfo[i].ch;\n\t\t\tcnt_5g++;\n\t\t\tb5g = true;\n\t\t} else {\n\t\t\tif (cnt_2g <= ARRAY_SIZE(wl_2g_ch) - 1)\n\t\t\t\twl_2g_ch[cnt_2g] = wl_linfo[i].ch;\n\t\t\tcnt_2g++;\n\t\t\tb2g = true;\n\t\t}\n\t}\n\n\twl_rinfo->connect_cnt = cnt_connect;\n\n\t \n\tif (cnt_connect == 0) {\n\t\twl_rinfo->link_mode = BTC_WLINK_NOLINK;\n\t\twl_rinfo->role_map.role.none = 1;\n\t} else if (!b2g && b5g) {\n\t\twl_rinfo->link_mode = BTC_WLINK_5G;\n\t} else if (wl_rinfo->role_map.role.nan) {\n\t\twl_rinfo->link_mode = BTC_WLINK_2G_NAN;\n\t} else if (cnt_connect > BTC_TDMA_WLROLE_MAX) {\n\t\twl_rinfo->link_mode = BTC_WLINK_OTHER;\n\t} else  if (b2g && b5g && cnt_connect == 2) {\n\t\tif (rtwdev->dbcc_en) {\n\t\t\tswitch (wl_dinfo->role[RTW89_PHY_0]) {\n\t\t\tcase RTW89_WIFI_ROLE_STATION:\n\t\t\t\twl_rinfo->link_mode = BTC_WLINK_2G_STA;\n\t\t\t\tbreak;\n\t\t\tcase RTW89_WIFI_ROLE_P2P_GO:\n\t\t\t\twl_rinfo->link_mode = BTC_WLINK_2G_GO;\n\t\t\t\tbreak;\n\t\t\tcase RTW89_WIFI_ROLE_P2P_CLIENT:\n\t\t\t\twl_rinfo->link_mode = BTC_WLINK_2G_GC;\n\t\t\t\tbreak;\n\t\t\tcase RTW89_WIFI_ROLE_AP:\n\t\t\t\twl_rinfo->link_mode = BTC_WLINK_2G_AP;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\twl_rinfo->link_mode = BTC_WLINK_OTHER;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\twl_rinfo->link_mode = BTC_WLINK_25G_MCC;\n\t\t}\n\t} else if (!b5g && cnt_connect == 2) {\n\t\tif (wl_rinfo->role_map.role.station &&\n\t\t    (wl_rinfo->role_map.role.p2p_go ||\n\t\t    wl_rinfo->role_map.role.p2p_gc ||\n\t\t    wl_rinfo->role_map.role.ap)) {\n\t\t\tif (wl_2g_ch[0] == wl_2g_ch[1])\n\t\t\t\twl_rinfo->link_mode = BTC_WLINK_2G_SCC;\n\t\t\telse\n\t\t\t\twl_rinfo->link_mode = BTC_WLINK_2G_MCC;\n\t\t} else {\n\t\t\twl_rinfo->link_mode = BTC_WLINK_2G_MCC;\n\t\t}\n\t} else if (!b5g && cnt_connect == 1) {\n\t\tif (wl_rinfo->role_map.role.station)\n\t\t\twl_rinfo->link_mode = BTC_WLINK_2G_STA;\n\t\telse if (wl_rinfo->role_map.role.ap)\n\t\t\twl_rinfo->link_mode = BTC_WLINK_2G_AP;\n\t\telse if (wl_rinfo->role_map.role.p2p_go)\n\t\t\twl_rinfo->link_mode = BTC_WLINK_2G_GO;\n\t\telse if (wl_rinfo->role_map.role.p2p_gc)\n\t\t\twl_rinfo->link_mode = BTC_WLINK_2G_GC;\n\t\telse\n\t\t\twl_rinfo->link_mode = BTC_WLINK_OTHER;\n\t}\n\n\t \n\tif (wl_rinfo->role_map.role.p2p_go || wl_rinfo->role_map.role.ap) {\n\t\tif (!client_joined) {\n\t\t\tif (wl_rinfo->link_mode == BTC_WLINK_2G_SCC ||\n\t\t\t    wl_rinfo->link_mode == BTC_WLINK_2G_MCC) {\n\t\t\t\twl_rinfo->link_mode = BTC_WLINK_2G_STA;\n\t\t\t\twl_rinfo->connect_cnt = 1;\n\t\t\t} else if (wl_rinfo->link_mode == BTC_WLINK_2G_GO ||\n\t\t\t\t wl_rinfo->link_mode == BTC_WLINK_2G_AP) {\n\t\t\t\twl_rinfo->link_mode = BTC_WLINK_NOLINK;\n\t\t\t\twl_rinfo->connect_cnt = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t    \"[BTC], cnt_connect = %d, connecting = %d, link_mode = %d\\n\",\n\t\t    cnt_connect, cnt_connecting, wl_rinfo->link_mode);\n\n\t_fw_set_drv_info(rtwdev, CXDRVINFO_ROLE);\n}\n\nstatic void _update_wl_info_v1(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_wl_info *wl = &btc->cx.wl;\n\tstruct rtw89_btc_wl_link_info *wl_linfo = wl->link_info;\n\tstruct rtw89_btc_wl_role_info_v1 *wl_rinfo = &wl->role_info_v1;\n\tstruct rtw89_btc_wl_dbcc_info *wl_dinfo = &wl->dbcc_info;\n\tu8 cnt_connect = 0, cnt_connecting = 0, cnt_active = 0;\n\tu8 cnt_2g = 0, cnt_5g = 0, phy;\n\tu32 wl_2g_ch[2] = {}, wl_5g_ch[2] = {};\n\tbool b2g = false, b5g = false, client_joined = false;\n\tu8 i;\n\n\tmemset(wl_rinfo, 0, sizeof(*wl_rinfo));\n\n\tfor (i = 0; i < RTW89_PORT_NUM; i++) {\n\t\tif (!wl_linfo[i].active)\n\t\t\tcontinue;\n\n\t\tcnt_active++;\n\t\twl_rinfo->active_role_v1[cnt_active - 1].role = wl_linfo[i].role;\n\t\twl_rinfo->active_role_v1[cnt_active - 1].pid = wl_linfo[i].pid;\n\t\twl_rinfo->active_role_v1[cnt_active - 1].phy = wl_linfo[i].phy;\n\t\twl_rinfo->active_role_v1[cnt_active - 1].band = wl_linfo[i].band;\n\t\twl_rinfo->active_role_v1[cnt_active - 1].noa = (u8)wl_linfo[i].noa;\n\t\twl_rinfo->active_role_v1[cnt_active - 1].connected = 0;\n\n\t\twl->port_id[wl_linfo[i].role] = wl_linfo[i].pid;\n\n\t\tphy = wl_linfo[i].phy;\n\n\t\tif (rtwdev->dbcc_en && phy < RTW89_PHY_MAX) {\n\t\t\twl_dinfo->role[phy] = wl_linfo[i].role;\n\t\t\twl_dinfo->op_band[phy] = wl_linfo[i].band;\n\t\t\t_update_dbcc_band(rtwdev, phy);\n\t\t\t_fw_set_drv_info(rtwdev, CXDRVINFO_DBCC);\n\t\t}\n\n\t\tif (wl_linfo[i].connected == MLME_NO_LINK) {\n\t\t\tcontinue;\n\t\t} else if (wl_linfo[i].connected == MLME_LINKING) {\n\t\t\tcnt_connecting++;\n\t\t} else {\n\t\t\tcnt_connect++;\n\t\t\tif ((wl_linfo[i].role == RTW89_WIFI_ROLE_P2P_GO ||\n\t\t\t     wl_linfo[i].role == RTW89_WIFI_ROLE_AP) &&\n\t\t\t     wl_linfo[i].client_cnt > 1)\n\t\t\t\tclient_joined = true;\n\t\t}\n\n\t\twl_rinfo->role_map.val |= BIT(wl_linfo[i].role);\n\t\twl_rinfo->active_role_v1[cnt_active - 1].ch = wl_linfo[i].ch;\n\t\twl_rinfo->active_role_v1[cnt_active - 1].bw = wl_linfo[i].bw;\n\t\twl_rinfo->active_role_v1[cnt_active - 1].connected = 1;\n\n\t\t \n\t\tif (wl_linfo[i].band != RTW89_BAND_2G) {\n\t\t\tif (cnt_5g <= ARRAY_SIZE(wl_5g_ch) - 1)\n\t\t\t\twl_5g_ch[cnt_5g] = wl_linfo[i].ch;\n\t\t\tcnt_5g++;\n\t\t\tb5g = true;\n\t\t} else {\n\t\t\tif (cnt_2g <= ARRAY_SIZE(wl_2g_ch) - 1)\n\t\t\t\twl_2g_ch[cnt_2g] = wl_linfo[i].ch;\n\t\t\tcnt_2g++;\n\t\t\tb2g = true;\n\t\t}\n\t}\n\n\twl_rinfo->connect_cnt = cnt_connect;\n\n\t \n\tif (cnt_connect == 0) {\n\t\twl_rinfo->link_mode = BTC_WLINK_NOLINK;\n\t\twl_rinfo->role_map.role.none = 1;\n\t} else if (!b2g && b5g) {\n\t\twl_rinfo->link_mode = BTC_WLINK_5G;\n\t} else if (wl_rinfo->role_map.role.nan) {\n\t\twl_rinfo->link_mode = BTC_WLINK_2G_NAN;\n\t} else if (cnt_connect > BTC_TDMA_WLROLE_MAX) {\n\t\twl_rinfo->link_mode = BTC_WLINK_OTHER;\n\t} else  if (b2g && b5g && cnt_connect == 2) {\n\t\tif (rtwdev->dbcc_en) {\n\t\t\tswitch (wl_dinfo->role[RTW89_PHY_0]) {\n\t\t\tcase RTW89_WIFI_ROLE_STATION:\n\t\t\t\twl_rinfo->link_mode = BTC_WLINK_2G_STA;\n\t\t\t\tbreak;\n\t\t\tcase RTW89_WIFI_ROLE_P2P_GO:\n\t\t\t\twl_rinfo->link_mode = BTC_WLINK_2G_GO;\n\t\t\t\tbreak;\n\t\t\tcase RTW89_WIFI_ROLE_P2P_CLIENT:\n\t\t\t\twl_rinfo->link_mode = BTC_WLINK_2G_GC;\n\t\t\t\tbreak;\n\t\t\tcase RTW89_WIFI_ROLE_AP:\n\t\t\t\twl_rinfo->link_mode = BTC_WLINK_2G_AP;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\twl_rinfo->link_mode = BTC_WLINK_OTHER;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\twl_rinfo->link_mode = BTC_WLINK_25G_MCC;\n\t\t}\n\t} else if (!b5g && cnt_connect == 2) {\n\t\tif (wl_rinfo->role_map.role.station &&\n\t\t    (wl_rinfo->role_map.role.p2p_go ||\n\t\t    wl_rinfo->role_map.role.p2p_gc ||\n\t\t    wl_rinfo->role_map.role.ap)) {\n\t\t\tif (wl_2g_ch[0] == wl_2g_ch[1])\n\t\t\t\twl_rinfo->link_mode = BTC_WLINK_2G_SCC;\n\t\t\telse\n\t\t\t\twl_rinfo->link_mode = BTC_WLINK_2G_MCC;\n\t\t} else {\n\t\t\twl_rinfo->link_mode = BTC_WLINK_2G_MCC;\n\t\t}\n\t} else if (!b5g && cnt_connect == 1) {\n\t\tif (wl_rinfo->role_map.role.station)\n\t\t\twl_rinfo->link_mode = BTC_WLINK_2G_STA;\n\t\telse if (wl_rinfo->role_map.role.ap)\n\t\t\twl_rinfo->link_mode = BTC_WLINK_2G_AP;\n\t\telse if (wl_rinfo->role_map.role.p2p_go)\n\t\t\twl_rinfo->link_mode = BTC_WLINK_2G_GO;\n\t\telse if (wl_rinfo->role_map.role.p2p_gc)\n\t\t\twl_rinfo->link_mode = BTC_WLINK_2G_GC;\n\t\telse\n\t\t\twl_rinfo->link_mode = BTC_WLINK_OTHER;\n\t}\n\n\t \n\tif (wl_rinfo->role_map.role.p2p_go || wl_rinfo->role_map.role.ap) {\n\t\tif (!client_joined) {\n\t\t\tif (wl_rinfo->link_mode == BTC_WLINK_2G_SCC ||\n\t\t\t    wl_rinfo->link_mode == BTC_WLINK_2G_MCC) {\n\t\t\t\twl_rinfo->link_mode = BTC_WLINK_2G_STA;\n\t\t\t\twl_rinfo->connect_cnt = 1;\n\t\t\t} else if (wl_rinfo->link_mode == BTC_WLINK_2G_GO ||\n\t\t\t\t wl_rinfo->link_mode == BTC_WLINK_2G_AP) {\n\t\t\t\twl_rinfo->link_mode = BTC_WLINK_NOLINK;\n\t\t\t\twl_rinfo->connect_cnt = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t    \"[BTC], cnt_connect = %d, connecting = %d, link_mode = %d\\n\",\n\t\t    cnt_connect, cnt_connecting, wl_rinfo->link_mode);\n\n\t_fw_set_drv_info(rtwdev, CXDRVINFO_ROLE);\n}\n\nstatic void _update_wl_info_v2(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_wl_info *wl = &btc->cx.wl;\n\tstruct rtw89_btc_wl_link_info *wl_linfo = wl->link_info;\n\tstruct rtw89_btc_wl_role_info_v2 *wl_rinfo = &wl->role_info_v2;\n\tstruct rtw89_btc_wl_dbcc_info *wl_dinfo = &wl->dbcc_info;\n\tu8 cnt_connect = 0, cnt_connecting = 0, cnt_active = 0;\n\tu8 cnt_2g = 0, cnt_5g = 0, phy;\n\tu32 wl_2g_ch[2] = {}, wl_5g_ch[2] = {};\n\tbool b2g = false, b5g = false, client_joined = false;\n\tu8 i;\n\n\tmemset(wl_rinfo, 0, sizeof(*wl_rinfo));\n\n\tfor (i = 0; i < RTW89_PORT_NUM; i++) {\n\t\tif (!wl_linfo[i].active)\n\t\t\tcontinue;\n\n\t\tcnt_active++;\n\t\twl_rinfo->active_role_v2[cnt_active - 1].role = wl_linfo[i].role;\n\t\twl_rinfo->active_role_v2[cnt_active - 1].pid = wl_linfo[i].pid;\n\t\twl_rinfo->active_role_v2[cnt_active - 1].phy = wl_linfo[i].phy;\n\t\twl_rinfo->active_role_v2[cnt_active - 1].band = wl_linfo[i].band;\n\t\twl_rinfo->active_role_v2[cnt_active - 1].noa = (u8)wl_linfo[i].noa;\n\t\twl_rinfo->active_role_v2[cnt_active - 1].connected = 0;\n\n\t\twl->port_id[wl_linfo[i].role] = wl_linfo[i].pid;\n\n\t\tphy = wl_linfo[i].phy;\n\n\t\tif (rtwdev->dbcc_en && phy < RTW89_PHY_MAX) {\n\t\t\twl_dinfo->role[phy] = wl_linfo[i].role;\n\t\t\twl_dinfo->op_band[phy] = wl_linfo[i].band;\n\t\t\t_update_dbcc_band(rtwdev, phy);\n\t\t\t_fw_set_drv_info(rtwdev, CXDRVINFO_DBCC);\n\t\t}\n\n\t\tif (wl_linfo[i].connected == MLME_NO_LINK) {\n\t\t\tcontinue;\n\t\t} else if (wl_linfo[i].connected == MLME_LINKING) {\n\t\t\tcnt_connecting++;\n\t\t} else {\n\t\t\tcnt_connect++;\n\t\t\tif ((wl_linfo[i].role == RTW89_WIFI_ROLE_P2P_GO ||\n\t\t\t     wl_linfo[i].role == RTW89_WIFI_ROLE_AP) &&\n\t\t\t     wl_linfo[i].client_cnt > 1)\n\t\t\t\tclient_joined = true;\n\t\t}\n\n\t\twl_rinfo->role_map.val |= BIT(wl_linfo[i].role);\n\t\twl_rinfo->active_role_v2[cnt_active - 1].ch = wl_linfo[i].ch;\n\t\twl_rinfo->active_role_v2[cnt_active - 1].bw = wl_linfo[i].bw;\n\t\twl_rinfo->active_role_v2[cnt_active - 1].connected = 1;\n\n\t\t \n\t\tif (wl_linfo[i].band != RTW89_BAND_2G) {\n\t\t\tif (cnt_5g <= ARRAY_SIZE(wl_5g_ch) - 1)\n\t\t\t\twl_5g_ch[cnt_5g] = wl_linfo[i].ch;\n\t\t\tcnt_5g++;\n\t\t\tb5g = true;\n\t\t} else {\n\t\t\tif (cnt_2g <= ARRAY_SIZE(wl_2g_ch) - 1)\n\t\t\t\twl_2g_ch[cnt_2g] = wl_linfo[i].ch;\n\t\t\tcnt_2g++;\n\t\t\tb2g = true;\n\t\t}\n\t}\n\n\twl_rinfo->connect_cnt = cnt_connect;\n\n\t \n\tif (cnt_connect == 0) {\n\t\twl_rinfo->link_mode = BTC_WLINK_NOLINK;\n\t\twl_rinfo->role_map.role.none = 1;\n\t} else if (!b2g && b5g) {\n\t\twl_rinfo->link_mode = BTC_WLINK_5G;\n\t} else if (wl_rinfo->role_map.role.nan) {\n\t\twl_rinfo->link_mode = BTC_WLINK_2G_NAN;\n\t} else if (cnt_connect > BTC_TDMA_WLROLE_MAX) {\n\t\twl_rinfo->link_mode = BTC_WLINK_OTHER;\n\t} else  if (b2g && b5g && cnt_connect == 2) {\n\t\tif (rtwdev->dbcc_en) {\n\t\t\tswitch (wl_dinfo->role[RTW89_PHY_0]) {\n\t\t\tcase RTW89_WIFI_ROLE_STATION:\n\t\t\t\twl_rinfo->link_mode = BTC_WLINK_2G_STA;\n\t\t\t\tbreak;\n\t\t\tcase RTW89_WIFI_ROLE_P2P_GO:\n\t\t\t\twl_rinfo->link_mode = BTC_WLINK_2G_GO;\n\t\t\t\tbreak;\n\t\t\tcase RTW89_WIFI_ROLE_P2P_CLIENT:\n\t\t\t\twl_rinfo->link_mode = BTC_WLINK_2G_GC;\n\t\t\t\tbreak;\n\t\t\tcase RTW89_WIFI_ROLE_AP:\n\t\t\t\twl_rinfo->link_mode = BTC_WLINK_2G_AP;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\twl_rinfo->link_mode = BTC_WLINK_OTHER;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\twl_rinfo->link_mode = BTC_WLINK_25G_MCC;\n\t\t}\n\t} else if (!b5g && cnt_connect == 2) {\n\t\tif (wl_rinfo->role_map.role.station &&\n\t\t    (wl_rinfo->role_map.role.p2p_go ||\n\t\t    wl_rinfo->role_map.role.p2p_gc ||\n\t\t    wl_rinfo->role_map.role.ap)) {\n\t\t\tif (wl_2g_ch[0] == wl_2g_ch[1])\n\t\t\t\twl_rinfo->link_mode = BTC_WLINK_2G_SCC;\n\t\t\telse\n\t\t\t\twl_rinfo->link_mode = BTC_WLINK_2G_MCC;\n\t\t} else {\n\t\t\twl_rinfo->link_mode = BTC_WLINK_2G_MCC;\n\t\t}\n\t} else if (!b5g && cnt_connect == 1) {\n\t\tif (wl_rinfo->role_map.role.station)\n\t\t\twl_rinfo->link_mode = BTC_WLINK_2G_STA;\n\t\telse if (wl_rinfo->role_map.role.ap)\n\t\t\twl_rinfo->link_mode = BTC_WLINK_2G_AP;\n\t\telse if (wl_rinfo->role_map.role.p2p_go)\n\t\t\twl_rinfo->link_mode = BTC_WLINK_2G_GO;\n\t\telse if (wl_rinfo->role_map.role.p2p_gc)\n\t\t\twl_rinfo->link_mode = BTC_WLINK_2G_GC;\n\t\telse\n\t\t\twl_rinfo->link_mode = BTC_WLINK_OTHER;\n\t}\n\n\t \n\tif (wl_rinfo->role_map.role.p2p_go || wl_rinfo->role_map.role.ap) {\n\t\tif (!client_joined) {\n\t\t\tif (wl_rinfo->link_mode == BTC_WLINK_2G_SCC ||\n\t\t\t    wl_rinfo->link_mode == BTC_WLINK_2G_MCC) {\n\t\t\t\twl_rinfo->link_mode = BTC_WLINK_2G_STA;\n\t\t\t\twl_rinfo->connect_cnt = 1;\n\t\t\t} else if (wl_rinfo->link_mode == BTC_WLINK_2G_GO ||\n\t\t\t\t wl_rinfo->link_mode == BTC_WLINK_2G_AP) {\n\t\t\t\twl_rinfo->link_mode = BTC_WLINK_NOLINK;\n\t\t\t\twl_rinfo->connect_cnt = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t    \"[BTC], cnt_connect = %d, connecting = %d, link_mode = %d\\n\",\n\t\t    cnt_connect, cnt_connecting, wl_rinfo->link_mode);\n\n\t_fw_set_drv_info(rtwdev, CXDRVINFO_ROLE);\n}\n\n#define BTC_CHK_HANG_MAX 3\n#define BTC_SCB_INV_VALUE GENMASK(31, 0)\n\nvoid rtw89_coex_act1_work(struct work_struct *work)\n{\n\tstruct rtw89_dev *rtwdev = container_of(work, struct rtw89_dev,\n\t\t\t\t\t\tcoex_act1_work.work);\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_dm *dm = &rtwdev->btc.dm;\n\tstruct rtw89_btc_cx *cx = &btc->cx;\n\tstruct rtw89_btc_wl_info *wl = &cx->wl;\n\n\tmutex_lock(&rtwdev->mutex);\n\trtw89_debug(rtwdev, RTW89_DBG_BTC, \"[BTC], %s(): enter\\n\", __func__);\n\tdm->cnt_notify[BTC_NCNT_TIMER]++;\n\tif (wl->status.map._4way)\n\t\twl->status.map._4way = false;\n\tif (wl->status.map.connecting)\n\t\twl->status.map.connecting = false;\n\n\t_run_coex(rtwdev, BTC_RSN_ACT1_WORK);\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nvoid rtw89_coex_bt_devinfo_work(struct work_struct *work)\n{\n\tstruct rtw89_dev *rtwdev = container_of(work, struct rtw89_dev,\n\t\t\t\t\t\tcoex_bt_devinfo_work.work);\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_dm *dm = &rtwdev->btc.dm;\n\tstruct rtw89_btc_bt_a2dp_desc *a2dp = &btc->cx.bt.link_info.a2dp_desc;\n\n\tmutex_lock(&rtwdev->mutex);\n\trtw89_debug(rtwdev, RTW89_DBG_BTC, \"[BTC], %s(): enter\\n\", __func__);\n\tdm->cnt_notify[BTC_NCNT_TIMER]++;\n\ta2dp->play_latency = 0;\n\t_run_coex(rtwdev, BTC_RSN_BT_DEVINFO_WORK);\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nvoid rtw89_coex_rfk_chk_work(struct work_struct *work)\n{\n\tstruct rtw89_dev *rtwdev = container_of(work, struct rtw89_dev,\n\t\t\t\t\t\tcoex_rfk_chk_work.work);\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_dm *dm = &rtwdev->btc.dm;\n\tstruct rtw89_btc_cx *cx = &btc->cx;\n\tstruct rtw89_btc_wl_info *wl = &cx->wl;\n\n\tmutex_lock(&rtwdev->mutex);\n\trtw89_debug(rtwdev, RTW89_DBG_BTC, \"[BTC], %s(): enter\\n\", __func__);\n\tdm->cnt_notify[BTC_NCNT_TIMER]++;\n\tif (wl->rfk_info.state != BTC_WRFK_STOP) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t\t    \"[BTC], %s(): RFK timeout\\n\", __func__);\n\t\tcx->cnt_wl[BTC_WCNT_RFK_TIMEOUT]++;\n\t\tdm->error.map.wl_rfk_timeout = true;\n\t\twl->rfk_info.state = BTC_WRFK_STOP;\n\t\t_write_scbd(rtwdev, BTC_WSCB_WLRFK, false);\n\t\t_run_coex(rtwdev, BTC_RSN_RFK_CHK_WORK);\n\t}\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nstatic void _update_bt_scbd(struct rtw89_dev *rtwdev, bool only_update)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_cx *cx = &btc->cx;\n\tstruct rtw89_btc_bt_info *bt = &btc->cx.bt;\n\tu32 val;\n\tbool status_change = false;\n\n\tif (!chip->scbd)\n\t\treturn;\n\n\trtw89_debug(rtwdev, RTW89_DBG_BTC, \"[BTC], %s\\n\", __func__);\n\n\tval = _read_scbd(rtwdev);\n\tif (val == BTC_SCB_INV_VALUE) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t\t    \"[BTC], %s(): return by invalid scbd value\\n\",\n\t\t\t    __func__);\n\t\treturn;\n\t}\n\n\tif (!(val & BTC_BSCB_ON) ||\n\t    btc->dm.cnt_dm[BTC_DCNT_BTCNT_HANG] >= BTC_CHK_HANG_MAX)\n\t\tbt->enable.now = 0;\n\telse\n\t\tbt->enable.now = 1;\n\n\tif (bt->enable.now != bt->enable.last)\n\t\tstatus_change = true;\n\n\t \n\tif (bt->enable.now && !bt->enable.last) {\n\t\t_reset_btc_var(rtwdev, BTC_RESET_BTINFO);\n\t\tcx->cnt_bt[BTC_BCNT_REENABLE]++;\n\t\tbt->enable.now = 1;\n\t}\n\n\tbt->enable.last = bt->enable.now;\n\tbt->scbd = val;\n\tbt->mbx_avl = !!(val & BTC_BSCB_ACT);\n\n\tif (bt->whql_test != !!(val & BTC_BSCB_WHQL))\n\t\tstatus_change = true;\n\n\tbt->whql_test = !!(val & BTC_BSCB_WHQL);\n\tbt->btg_type = val & BTC_BSCB_BT_S1 ? BTC_BT_BTG : BTC_BT_ALONE;\n\tbt->link_info.a2dp_desc.exist = !!(val & BTC_BSCB_A2DP_ACT);\n\n\t \n\tif (bt->rfk_info.map.run && !(val & BTC_BSCB_RFK_RUN))\n\t\tstatus_change = true;\n\n\tbt->rfk_info.map.run  = !!(val & BTC_BSCB_RFK_RUN);\n\tbt->rfk_info.map.req = !!(val & BTC_BSCB_RFK_REQ);\n\tbt->hi_lna_rx = !!(val & BTC_BSCB_BT_HILNA);\n\tbt->link_info.status.map.connect = !!(val & BTC_BSCB_BT_CONNECT);\n\tbt->run_patch_code = !!(val & BTC_BSCB_PATCH_CODE);\n\n\tif (!only_update && status_change)\n\t\t_run_coex(rtwdev, BTC_RSN_UPDATE_BT_SCBD);\n}\n\nstatic bool _chk_wl_rfk_request(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_cx *cx = &btc->cx;\n\tstruct rtw89_btc_bt_info *bt = &cx->bt;\n\n\t_update_bt_scbd(rtwdev, true);\n\n\tcx->cnt_wl[BTC_WCNT_RFK_REQ]++;\n\n\tif ((bt->rfk_info.map.run || bt->rfk_info.map.req) &&\n\t    !bt->rfk_info.map.timeout) {\n\t\tcx->cnt_wl[BTC_WCNT_RFK_REJECT]++;\n\t} else {\n\t\tcx->cnt_wl[BTC_WCNT_RFK_GO]++;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic\nvoid _run_coex(struct rtw89_dev *rtwdev, enum btc_reason_and_action reason)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tconst struct rtw89_btc_ver *ver = btc->ver;\n\tstruct rtw89_btc_dm *dm = &rtwdev->btc.dm;\n\tstruct rtw89_btc_cx *cx = &btc->cx;\n\tstruct rtw89_btc_wl_info *wl = &btc->cx.wl;\n\tstruct rtw89_btc_bt_info *bt = &btc->cx.bt;\n\tstruct rtw89_btc_wl_role_info *wl_rinfo = &wl->role_info;\n\tstruct rtw89_btc_wl_role_info_v1 *wl_rinfo_v1 = &wl->role_info_v1;\n\tstruct rtw89_btc_wl_role_info_v2 *wl_rinfo_v2 = &wl->role_info_v2;\n\tu8 mode;\n\n\tlockdep_assert_held(&rtwdev->mutex);\n\n\tdm->run_reason = reason;\n\t_update_dm_step(rtwdev, reason);\n\t_update_btc_state_map(rtwdev);\n\n\tif (ver->fwlrole == 0)\n\t\tmode = wl_rinfo->link_mode;\n\telse if (ver->fwlrole == 1)\n\t\tmode = wl_rinfo_v1->link_mode;\n\telse if (ver->fwlrole == 2)\n\t\tmode = wl_rinfo_v2->link_mode;\n\telse\n\t\treturn;\n\n\trtw89_debug(rtwdev, RTW89_DBG_BTC, \"[BTC], %s(): reason=%d, mode=%d\\n\",\n\t\t    __func__, reason, mode);\n\trtw89_debug(rtwdev, RTW89_DBG_BTC, \"[BTC], %s(): wl_only=%d, bt_only=%d\\n\",\n\t\t    __func__, dm->wl_only, dm->bt_only);\n\n\t \n\tif (btc->ctrl.manual) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t\t    \"[BTC], %s(): return for Manual CTRL!!\\n\",\n\t\t\t    __func__);\n\t\treturn;\n\t}\n\n\tif (btc->ctrl.igno_bt &&\n\t    (reason == BTC_RSN_UPDATE_BT_INFO ||\n\t     reason == BTC_RSN_UPDATE_BT_SCBD)) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t\t    \"[BTC], %s(): return for Stop Coex DM!!\\n\",\n\t\t\t    __func__);\n\t\treturn;\n\t}\n\n\tif (!wl->status.map.init_ok) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t\t    \"[BTC], %s(): return for WL init fail!!\\n\",\n\t\t\t    __func__);\n\t\treturn;\n\t}\n\n\tif (wl->status.map.rf_off_pre == wl->status.map.rf_off &&\n\t    wl->status.map.lps_pre == wl->status.map.lps &&\n\t    (reason == BTC_RSN_NTFY_POWEROFF ||\n\t    reason == BTC_RSN_NTFY_RADIO_STATE)) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t\t    \"[BTC], %s(): return for WL rf off state no change!!\\n\",\n\t\t\t    __func__);\n\t\treturn;\n\t}\n\n\tdm->cnt_dm[BTC_DCNT_RUN]++;\n\tdm->fddt_train = BTC_FDDT_DISABLE;\n\n\tif (btc->ctrl.always_freerun) {\n\t\t_action_freerun(rtwdev);\n\t\tbtc->ctrl.igno_bt = true;\n\t\tgoto exit;\n\t}\n\n\tif (dm->wl_only) {\n\t\t_action_wl_only(rtwdev);\n\t\tbtc->ctrl.igno_bt = true;\n\t\tgoto exit;\n\t}\n\n\tif (wl->status.map.rf_off || wl->status.map.lps || dm->bt_only) {\n\t\t_action_wl_off(rtwdev);\n\t\tbtc->ctrl.igno_bt = true;\n\t\tgoto exit;\n\t}\n\n\tbtc->ctrl.igno_bt = false;\n\tdm->freerun = false;\n\tbt->scan_rx_low_pri = false;\n\n\tif (reason == BTC_RSN_NTFY_INIT) {\n\t\t_action_wl_init(rtwdev);\n\t\tgoto exit;\n\t}\n\n\tif (!cx->bt.enable.now && !cx->other.type) {\n\t\t_action_bt_off(rtwdev);\n\t\tgoto exit;\n\t}\n\n\tif (cx->bt.whql_test) {\n\t\t_action_bt_whql(rtwdev);\n\t\tgoto exit;\n\t}\n\n\tif (wl->rfk_info.state != BTC_WRFK_STOP) {\n\t\t_action_wl_rfk(rtwdev);\n\t\tgoto exit;\n\t}\n\n\tif (cx->state_map == BTC_WLINKING) {\n\t\tif (mode == BTC_WLINK_NOLINK || mode == BTC_WLINK_2G_STA ||\n\t\t    mode == BTC_WLINK_5G) {\n\t\t\t_action_wl_scan(rtwdev);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\tif (wl->status.map.scan) {\n\t\t_action_wl_scan(rtwdev);\n\t\tgoto exit;\n\t}\n\n\tswitch (mode) {\n\tcase BTC_WLINK_NOLINK:\n\t\t_action_wl_nc(rtwdev);\n\t\tbreak;\n\tcase BTC_WLINK_2G_STA:\n\t\tif (wl->status.map.traffic_dir & BIT(RTW89_TFC_DL))\n\t\t\tbt->scan_rx_low_pri = true;\n\t\t_action_wl_2g_sta(rtwdev);\n\t\tbreak;\n\tcase BTC_WLINK_2G_AP:\n\t\tbt->scan_rx_low_pri = true;\n\t\t_action_wl_2g_ap(rtwdev);\n\t\tbreak;\n\tcase BTC_WLINK_2G_GO:\n\t\tbt->scan_rx_low_pri = true;\n\t\t_action_wl_2g_go(rtwdev);\n\t\tbreak;\n\tcase BTC_WLINK_2G_GC:\n\t\tbt->scan_rx_low_pri = true;\n\t\t_action_wl_2g_gc(rtwdev);\n\t\tbreak;\n\tcase BTC_WLINK_2G_SCC:\n\t\tbt->scan_rx_low_pri = true;\n\t\tif (ver->fwlrole == 0)\n\t\t\t_action_wl_2g_scc(rtwdev);\n\t\telse if (ver->fwlrole == 1)\n\t\t\t_action_wl_2g_scc_v1(rtwdev);\n\t\telse if (ver->fwlrole == 2)\n\t\t\t_action_wl_2g_scc_v2(rtwdev);\n\t\tbreak;\n\tcase BTC_WLINK_2G_MCC:\n\t\tbt->scan_rx_low_pri = true;\n\t\t_action_wl_2g_mcc(rtwdev);\n\t\tbreak;\n\tcase BTC_WLINK_25G_MCC:\n\t\tbt->scan_rx_low_pri = true;\n\t\t_action_wl_25g_mcc(rtwdev);\n\t\tbreak;\n\tcase BTC_WLINK_5G:\n\t\t_action_wl_5g(rtwdev);\n\t\tbreak;\n\tcase BTC_WLINK_2G_NAN:\n\t\t_action_wl_2g_nan(rtwdev);\n\t\tbreak;\n\tdefault:\n\t\t_action_wl_other(rtwdev);\n\t\tbreak;\n\t}\n\nexit:\n\trtw89_debug(rtwdev, RTW89_DBG_BTC, \"[BTC], %s(): exit\\n\", __func__);\n\t_action_common(rtwdev);\n}\n\nvoid rtw89_btc_ntfy_poweron(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\n\trtw89_debug(rtwdev, RTW89_DBG_BTC, \"[BTC], %s(): !!\\n\", __func__);\n\tbtc->dm.cnt_notify[BTC_NCNT_POWER_ON]++;\n}\n\nvoid rtw89_btc_ntfy_poweroff(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_wl_info *wl = &btc->cx.wl;\n\n\trtw89_debug(rtwdev, RTW89_DBG_BTC, \"[BTC], %s(): !!\\n\", __func__);\n\tbtc->dm.cnt_notify[BTC_NCNT_POWER_OFF]++;\n\n\tbtc->cx.wl.status.map.rf_off = 1;\n\tbtc->cx.wl.status.map.busy = 0;\n\twl->status.map.lps = BTC_LPS_OFF;\n\n\t_write_scbd(rtwdev, BTC_WSCB_ALL, false);\n\t_run_coex(rtwdev, BTC_RSN_NTFY_POWEROFF);\n\n\trtw89_btc_fw_en_rpt(rtwdev, RPT_EN_ALL, 0);\n\n\tbtc->cx.wl.status.map.rf_off_pre = btc->cx.wl.status.map.rf_off;\n}\n\nstatic void _set_init_info(struct rtw89_dev *rtwdev)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_dm *dm = &btc->dm;\n\tstruct rtw89_btc_wl_info *wl = &btc->cx.wl;\n\n\tdm->init_info.wl_only = (u8)dm->wl_only;\n\tdm->init_info.bt_only = (u8)dm->bt_only;\n\tdm->init_info.wl_init_ok = (u8)wl->status.map.init_ok;\n\tdm->init_info.dbcc_en = rtwdev->dbcc_en;\n\tdm->init_info.cx_other = btc->cx.other.type;\n\tdm->init_info.wl_guard_ch = chip->afh_guard_ch;\n\tdm->init_info.module = btc->mdinfo;\n}\n\nvoid rtw89_btc_ntfy_init(struct rtw89_dev *rtwdev, u8 mode)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_dm *dm = &rtwdev->btc.dm;\n\tstruct rtw89_btc_wl_info *wl = &btc->cx.wl;\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\n\t_reset_btc_var(rtwdev, BTC_RESET_ALL);\n\tbtc->dm.run_reason = BTC_RSN_NONE;\n\tbtc->dm.run_action = BTC_ACT_NONE;\n\tbtc->ctrl.igno_bt = true;\n\n\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t    \"[BTC], %s(): mode=%d\\n\", __func__, mode);\n\n\tdm->cnt_notify[BTC_NCNT_INIT_COEX]++;\n\tdm->wl_only = mode == BTC_MODE_WL ? 1 : 0;\n\tdm->bt_only = mode == BTC_MODE_BT ? 1 : 0;\n\twl->status.map.rf_off = mode == BTC_MODE_WLOFF ? 1 : 0;\n\n\tchip->ops->btc_set_rfe(rtwdev);\n\tchip->ops->btc_init_cfg(rtwdev);\n\n\tif (!wl->status.map.init_ok) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t\t    \"[BTC], %s(): return for WL init fail!!\\n\",\n\t\t\t    __func__);\n\t\tdm->error.map.init = true;\n\t\treturn;\n\t}\n\n\t_write_scbd(rtwdev,\n\t\t    BTC_WSCB_ACTIVE | BTC_WSCB_ON | BTC_WSCB_BTLOG, true);\n\t_update_bt_scbd(rtwdev, true);\n\tif (rtw89_mac_get_ctrl_path(rtwdev)) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t\t    \"[BTC], %s(): PTA owner warning!!\\n\",\n\t\t\t    __func__);\n\t\tdm->error.map.pta_owner = true;\n\t}\n\n\t_set_init_info(rtwdev);\n\t_set_wl_tx_power(rtwdev, RTW89_BTC_WL_DEF_TX_PWR);\n\trtw89_btc_fw_set_slots(rtwdev, CXST_MAX, dm->slot);\n\tbtc_fw_set_monreg(rtwdev);\n\t_fw_set_drv_info(rtwdev, CXDRVINFO_INIT);\n\t_fw_set_drv_info(rtwdev, CXDRVINFO_CTRL);\n\n\t_run_coex(rtwdev, BTC_RSN_NTFY_INIT);\n}\n\nvoid rtw89_btc_ntfy_scan_start(struct rtw89_dev *rtwdev, u8 phy_idx, u8 band)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_wl_info *wl = &btc->cx.wl;\n\n\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t    \"[BTC], %s(): phy_idx=%d, band=%d\\n\",\n\t\t    __func__, phy_idx, band);\n\tbtc->dm.cnt_notify[BTC_NCNT_SCAN_START]++;\n\twl->status.map.scan = true;\n\twl->scan_info.band[phy_idx] = band;\n\twl->scan_info.phy_map |= BIT(phy_idx);\n\t_fw_set_drv_info(rtwdev, CXDRVINFO_SCAN);\n\n\tif (rtwdev->dbcc_en) {\n\t\twl->dbcc_info.scan_band[phy_idx] = band;\n\t\t_update_dbcc_band(rtwdev, phy_idx);\n\t\t_fw_set_drv_info(rtwdev, CXDRVINFO_DBCC);\n\t}\n\n\t_run_coex(rtwdev, BTC_RSN_NTFY_SCAN_START);\n}\n\nvoid rtw89_btc_ntfy_scan_finish(struct rtw89_dev *rtwdev, u8 phy_idx)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_wl_info *wl = &btc->cx.wl;\n\n\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t    \"[BTC], %s(): phy_idx=%d\\n\", __func__, phy_idx);\n\tbtc->dm.cnt_notify[BTC_NCNT_SCAN_FINISH]++;\n\n\twl->status.map.scan = false;\n\twl->scan_info.phy_map &= ~BIT(phy_idx);\n\t_fw_set_drv_info(rtwdev, CXDRVINFO_SCAN);\n\n\tif (rtwdev->dbcc_en) {\n\t\t_update_dbcc_band(rtwdev, phy_idx);\n\t\t_fw_set_drv_info(rtwdev, CXDRVINFO_DBCC);\n\t}\n\n\t_run_coex(rtwdev, BTC_RSN_NTFY_SCAN_FINISH);\n}\n\nvoid rtw89_btc_ntfy_switch_band(struct rtw89_dev *rtwdev, u8 phy_idx, u8 band)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_wl_info *wl = &btc->cx.wl;\n\n\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t    \"[BTC], %s(): phy_idx=%d, band=%d\\n\",\n\t\t    __func__, phy_idx, band);\n\tbtc->dm.cnt_notify[BTC_NCNT_SWITCH_BAND]++;\n\n\twl->scan_info.band[phy_idx] = band;\n\twl->scan_info.phy_map |= BIT(phy_idx);\n\t_fw_set_drv_info(rtwdev, CXDRVINFO_SCAN);\n\n\tif (rtwdev->dbcc_en) {\n\t\twl->dbcc_info.scan_band[phy_idx] = band;\n\t\t_update_dbcc_band(rtwdev, phy_idx);\n\t\t_fw_set_drv_info(rtwdev, CXDRVINFO_DBCC);\n\t}\n\t_run_coex(rtwdev, BTC_RSN_NTFY_SWBAND);\n}\n\nvoid rtw89_btc_ntfy_specific_packet(struct rtw89_dev *rtwdev,\n\t\t\t\t    enum btc_pkt_type pkt_type)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_cx *cx = &btc->cx;\n\tstruct rtw89_btc_wl_info *wl = &cx->wl;\n\tstruct rtw89_btc_bt_link_info *b = &cx->bt.link_info;\n\tstruct rtw89_btc_bt_hfp_desc *hfp = &b->hfp_desc;\n\tstruct rtw89_btc_bt_hid_desc *hid = &b->hid_desc;\n\tu32 cnt;\n\tu32 delay = RTW89_COEX_ACT1_WORK_PERIOD;\n\tbool delay_work = false;\n\n\tswitch (pkt_type) {\n\tcase PACKET_DHCP:\n\t\tcnt = ++cx->cnt_wl[BTC_WCNT_DHCP];\n\t\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t\t    \"[BTC], %s(): DHCP cnt=%d\\n\", __func__, cnt);\n\t\twl->status.map.connecting = true;\n\t\tdelay_work = true;\n\t\tbreak;\n\tcase PACKET_EAPOL:\n\t\tcnt = ++cx->cnt_wl[BTC_WCNT_EAPOL];\n\t\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t\t    \"[BTC], %s(): EAPOL cnt=%d\\n\", __func__, cnt);\n\t\twl->status.map._4way = true;\n\t\tdelay_work = true;\n\t\tif (hfp->exist || hid->exist)\n\t\t\tdelay /= 2;\n\t\tbreak;\n\tcase PACKET_EAPOL_END:\n\t\tcnt = ++cx->cnt_wl[BTC_WCNT_EAPOL];\n\t\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t\t    \"[BTC], %s(): EAPOL_End cnt=%d\\n\",\n\t\t\t    __func__, cnt);\n\t\twl->status.map._4way = false;\n\t\tcancel_delayed_work(&rtwdev->coex_act1_work);\n\t\tbreak;\n\tcase PACKET_ARP:\n\t\tcnt = ++cx->cnt_wl[BTC_WCNT_ARP];\n\t\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t\t    \"[BTC], %s(): ARP cnt=%d\\n\", __func__, cnt);\n\t\treturn;\n\tcase PACKET_ICMP:\n\t\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t\t    \"[BTC], %s(): ICMP pkt\\n\", __func__);\n\t\treturn;\n\tdefault:\n\t\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t\t    \"[BTC], %s(): unknown packet type %d\\n\",\n\t\t\t    __func__, pkt_type);\n\t\treturn;\n\t}\n\n\tif (delay_work) {\n\t\tcancel_delayed_work(&rtwdev->coex_act1_work);\n\t\tieee80211_queue_delayed_work(rtwdev->hw,\n\t\t\t\t\t     &rtwdev->coex_act1_work, delay);\n\t}\n\n\tbtc->dm.cnt_notify[BTC_NCNT_SPECIAL_PACKET]++;\n\t_run_coex(rtwdev, BTC_RSN_NTFY_SPECIFIC_PACKET);\n}\n\nvoid rtw89_btc_ntfy_eapol_packet_work(struct work_struct *work)\n{\n\tstruct rtw89_dev *rtwdev = container_of(work, struct rtw89_dev,\n\t\t\t\t\t\tbtc.eapol_notify_work);\n\n\tmutex_lock(&rtwdev->mutex);\n\trtw89_leave_ps_mode(rtwdev);\n\trtw89_btc_ntfy_specific_packet(rtwdev, PACKET_EAPOL);\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nvoid rtw89_btc_ntfy_arp_packet_work(struct work_struct *work)\n{\n\tstruct rtw89_dev *rtwdev = container_of(work, struct rtw89_dev,\n\t\t\t\t\t\tbtc.arp_notify_work);\n\n\tmutex_lock(&rtwdev->mutex);\n\trtw89_btc_ntfy_specific_packet(rtwdev, PACKET_ARP);\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nvoid rtw89_btc_ntfy_dhcp_packet_work(struct work_struct *work)\n{\n\tstruct rtw89_dev *rtwdev = container_of(work, struct rtw89_dev,\n\t\t\t\t\t\tbtc.dhcp_notify_work);\n\n\tmutex_lock(&rtwdev->mutex);\n\trtw89_leave_ps_mode(rtwdev);\n\trtw89_btc_ntfy_specific_packet(rtwdev, PACKET_DHCP);\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nvoid rtw89_btc_ntfy_icmp_packet_work(struct work_struct *work)\n{\n\tstruct rtw89_dev *rtwdev = container_of(work, struct rtw89_dev,\n\t\t\t\t\t\tbtc.icmp_notify_work);\n\n\tmutex_lock(&rtwdev->mutex);\n\trtw89_leave_ps_mode(rtwdev);\n\trtw89_btc_ntfy_specific_packet(rtwdev, PACKET_ICMP);\n\tmutex_unlock(&rtwdev->mutex);\n}\n\n#define BT_PROFILE_PROTOCOL_MASK GENMASK(7, 4)\n\nstatic void _update_bt_info(struct rtw89_dev *rtwdev, u8 *buf, u32 len)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_cx *cx = &btc->cx;\n\tstruct rtw89_btc_bt_info *bt = &cx->bt;\n\tstruct rtw89_btc_bt_link_info *b = &bt->link_info;\n\tstruct rtw89_btc_bt_hfp_desc *hfp = &b->hfp_desc;\n\tstruct rtw89_btc_bt_hid_desc *hid = &b->hid_desc;\n\tstruct rtw89_btc_bt_a2dp_desc *a2dp = &b->a2dp_desc;\n\tstruct rtw89_btc_bt_pan_desc *pan = &b->pan_desc;\n\tunion btc_btinfo btinfo;\n\n\tif (buf[BTC_BTINFO_L1] != 6)\n\t\treturn;\n\n\tif (!memcmp(bt->raw_info, buf, BTC_BTINFO_MAX)) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t\t    \"[BTC], %s(): return by bt-info duplicate!!\\n\",\n\t\t\t    __func__);\n\t\tcx->cnt_bt[BTC_BCNT_INFOSAME]++;\n\t\treturn;\n\t}\n\n\tmemcpy(bt->raw_info, buf, BTC_BTINFO_MAX);\n\n\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t    \"[BTC], %s(): bt_info[2]=0x%02x\\n\",\n\t\t    __func__, bt->raw_info[2]);\n\n\t \n\tb->status.val = BTC_BLINK_NOCONNECT;\n\tb->profile_cnt.last = b->profile_cnt.now;\n\tb->relink.last = b->relink.now;\n\ta2dp->exist_last = a2dp->exist;\n\tb->multi_link.last = b->multi_link.now;\n\tbt->inq_pag.last = bt->inq_pag.now;\n\tb->profile_cnt.now = 0;\n\thid->type = 0;\n\n\t \n\tbtinfo.val = bt->raw_info[BTC_BTINFO_L2];\n\tb->status.map.connect = btinfo.lb2.connect;\n\tb->status.map.sco_busy = btinfo.lb2.sco_busy;\n\tb->status.map.acl_busy = btinfo.lb2.acl_busy;\n\tb->status.map.inq_pag = btinfo.lb2.inq_pag;\n\tbt->inq_pag.now = btinfo.lb2.inq_pag;\n\tcx->cnt_bt[BTC_BCNT_INQPAG] += !!(bt->inq_pag.now && !bt->inq_pag.last);\n\n\thfp->exist = btinfo.lb2.hfp;\n\tb->profile_cnt.now += (u8)hfp->exist;\n\thid->exist = btinfo.lb2.hid;\n\tb->profile_cnt.now += (u8)hid->exist;\n\ta2dp->exist = btinfo.lb2.a2dp;\n\tb->profile_cnt.now += (u8)a2dp->exist;\n\tpan->active = btinfo.lb2.pan;\n\tbtc->dm.trx_info.bt_profile = u32_get_bits(btinfo.val, BT_PROFILE_PROTOCOL_MASK);\n\n\t \n\tbtinfo.val = bt->raw_info[BTC_BTINFO_L3];\n\tif (btinfo.lb3.retry != 0)\n\t\tcx->cnt_bt[BTC_BCNT_RETRY]++;\n\tb->cqddr = btinfo.lb3.cqddr;\n\tcx->cnt_bt[BTC_BCNT_INQ] += !!(btinfo.lb3.inq && !bt->inq);\n\tbt->inq = btinfo.lb3.inq;\n\tcx->cnt_bt[BTC_BCNT_PAGE] += !!(btinfo.lb3.pag && !bt->pag);\n\tbt->pag = btinfo.lb3.pag;\n\n\tb->status.map.mesh_busy = btinfo.lb3.mesh_busy;\n\t \n\tbtinfo.val = bt->raw_info[BTC_BTINFO_H0];\n\t \n\tb->rssi = chip->ops->btc_get_bt_rssi(rtwdev, btinfo.hb0.rssi);\n\tbtc->dm.trx_info.bt_rssi = b->rssi;\n\n\t \n\tbtinfo.val = bt->raw_info[BTC_BTINFO_H1];\n\tb->status.map.ble_connect = btinfo.hb1.ble_connect;\n\tif (btinfo.hb1.ble_connect)\n\t\thid->type |= (hid->exist ? BTC_HID_BLE : BTC_HID_RCU);\n\n\tcx->cnt_bt[BTC_BCNT_REINIT] += !!(btinfo.hb1.reinit && !bt->reinit);\n\tbt->reinit = btinfo.hb1.reinit;\n\tcx->cnt_bt[BTC_BCNT_RELINK] += !!(btinfo.hb1.relink && !b->relink.now);\n\tb->relink.now = btinfo.hb1.relink;\n\tcx->cnt_bt[BTC_BCNT_IGNOWL] += !!(btinfo.hb1.igno_wl && !bt->igno_wl);\n\tbt->igno_wl = btinfo.hb1.igno_wl;\n\n\tif (bt->igno_wl && !cx->wl.status.map.rf_off)\n\t\t_set_bt_ignore_wlan_act(rtwdev, false);\n\n\thid->type |= (btinfo.hb1.voice ? BTC_HID_RCU_VOICE : 0);\n\tbt->ble_scan_en = btinfo.hb1.ble_scan;\n\n\tcx->cnt_bt[BTC_BCNT_ROLESW] += !!(btinfo.hb1.role_sw && !b->role_sw);\n\tb->role_sw = btinfo.hb1.role_sw;\n\n\tb->multi_link.now = btinfo.hb1.multi_link;\n\n\t \n\tbtinfo.val = bt->raw_info[BTC_BTINFO_H2];\n\tpan->exist = btinfo.hb2.pan_active;\n\tb->profile_cnt.now += (u8)pan->exist;\n\n\tcx->cnt_bt[BTC_BCNT_AFH] += !!(btinfo.hb2.afh_update && !b->afh_update);\n\tb->afh_update = btinfo.hb2.afh_update;\n\ta2dp->active = btinfo.hb2.a2dp_active;\n\tb->slave_role = btinfo.hb2.slave;\n\thid->slot_info = btinfo.hb2.hid_slot;\n\thid->pair_cnt = btinfo.hb2.hid_cnt;\n\thid->type |= (hid->slot_info == BTC_HID_218 ?\n\t\t      BTC_HID_218 : BTC_HID_418);\n\t \n\tbtinfo.val = bt->raw_info[BTC_BTINFO_H3];\n\ta2dp->bitpool = btinfo.hb3.a2dp_bitpool;\n\n\tif (b->tx_3m != (u32)btinfo.hb3.tx_3m)\n\t\tcx->cnt_bt[BTC_BCNT_RATECHG]++;\n\tb->tx_3m = (u32)btinfo.hb3.tx_3m;\n\n\ta2dp->sink = btinfo.hb3.a2dp_sink;\n\n\tif (!a2dp->exist_last && a2dp->exist) {\n\t\ta2dp->vendor_id = 0;\n\t\ta2dp->flush_time = 0;\n\t\ta2dp->play_latency = 1;\n\t\tieee80211_queue_delayed_work(rtwdev->hw,\n\t\t\t\t\t     &rtwdev->coex_bt_devinfo_work,\n\t\t\t\t\t     RTW89_COEX_BT_DEVINFO_WORK_PERIOD);\n\t}\n\n\t_run_coex(rtwdev, BTC_RSN_UPDATE_BT_INFO);\n}\n\nenum btc_wl_mode {\n\tBTC_WL_MODE_HT = 0,\n\tBTC_WL_MODE_VHT = 1,\n\tBTC_WL_MODE_HE = 2,\n\tBTC_WL_MODE_NUM,\n};\n\nvoid rtw89_btc_ntfy_role_info(struct rtw89_dev *rtwdev, struct rtw89_vif *rtwvif,\n\t\t\t      struct rtw89_sta *rtwsta, enum btc_role_state state)\n{\n\tconst struct rtw89_chan *chan = rtw89_chan_get(rtwdev,\n\t\t\t\t\t\t       rtwvif->sub_entity_idx);\n\tstruct ieee80211_vif *vif = rtwvif_to_vif(rtwvif);\n\tstruct ieee80211_sta *sta = rtwsta_to_sta(rtwsta);\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tconst struct rtw89_btc_ver *ver = btc->ver;\n\tstruct rtw89_btc_wl_info *wl = &btc->cx.wl;\n\tstruct rtw89_btc_wl_link_info r = {0};\n\tstruct rtw89_btc_wl_link_info *wlinfo = NULL;\n\tu8 mode = 0;\n\n\trtw89_debug(rtwdev, RTW89_DBG_BTC, \"[BTC], state=%d\\n\", state);\n\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t    \"[BTC], role is STA=%d\\n\",\n\t\t    vif->type == NL80211_IFTYPE_STATION);\n\trtw89_debug(rtwdev, RTW89_DBG_BTC, \"[BTC], port=%d\\n\", rtwvif->port);\n\trtw89_debug(rtwdev, RTW89_DBG_BTC, \"[BTC], band=%d ch=%d bw=%d\\n\",\n\t\t    chan->band_type, chan->channel, chan->band_width);\n\trtw89_debug(rtwdev, RTW89_DBG_BTC, \"[BTC], associated=%d\\n\",\n\t\t    state == BTC_ROLE_MSTS_STA_CONN_END);\n\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t    \"[BTC], bcn_period=%d dtim_period=%d\\n\",\n\t\t    vif->bss_conf.beacon_int, vif->bss_conf.dtim_period);\n\n\tif (rtwsta) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_BTC, \"[BTC], STA mac_id=%d\\n\",\n\t\t\t    rtwsta->mac_id);\n\n\t\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t\t    \"[BTC], STA support HE=%d VHT=%d HT=%d\\n\",\n\t\t\t    sta->deflink.he_cap.has_he,\n\t\t\t    sta->deflink.vht_cap.vht_supported,\n\t\t\t    sta->deflink.ht_cap.ht_supported);\n\t\tif (sta->deflink.he_cap.has_he)\n\t\t\tmode |= BIT(BTC_WL_MODE_HE);\n\t\tif (sta->deflink.vht_cap.vht_supported)\n\t\t\tmode |= BIT(BTC_WL_MODE_VHT);\n\t\tif (sta->deflink.ht_cap.ht_supported)\n\t\t\tmode |= BIT(BTC_WL_MODE_HT);\n\n\t\tr.mode = mode;\n\t}\n\n\tif (rtwvif->wifi_role >= RTW89_WIFI_ROLE_MLME_MAX)\n\t\treturn;\n\n\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t    \"[BTC], wifi_role=%d\\n\", rtwvif->wifi_role);\n\n\tr.role = rtwvif->wifi_role;\n\tr.phy = rtwvif->phy_idx;\n\tr.pid = rtwvif->port;\n\tr.active = true;\n\tr.connected = MLME_LINKED;\n\tr.bcn_period = vif->bss_conf.beacon_int;\n\tr.dtim_period = vif->bss_conf.dtim_period;\n\tr.band = chan->band_type;\n\tr.ch = chan->channel;\n\tr.bw = chan->band_width;\n\tether_addr_copy(r.mac_addr, rtwvif->mac_addr);\n\n\tif (rtwsta && vif->type == NL80211_IFTYPE_STATION)\n\t\tr.mac_id = rtwsta->mac_id;\n\n\tbtc->dm.cnt_notify[BTC_NCNT_ROLE_INFO]++;\n\n\twlinfo = &wl->link_info[r.pid];\n\n\tmemcpy(wlinfo, &r, sizeof(*wlinfo));\n\tif (ver->fwlrole == 0)\n\t\t_update_wl_info(rtwdev);\n\telse if (ver->fwlrole == 1)\n\t\t_update_wl_info_v1(rtwdev);\n\telse if (ver->fwlrole == 2)\n\t\t_update_wl_info_v2(rtwdev);\n\n\tif (wlinfo->role == RTW89_WIFI_ROLE_STATION &&\n\t    wlinfo->connected == MLME_NO_LINK)\n\t\tbtc->dm.leak_ap = 0;\n\n\tif (state == BTC_ROLE_MSTS_STA_CONN_START)\n\t\twl->status.map.connecting = 1;\n\telse\n\t\twl->status.map.connecting = 0;\n\n\tif (state == BTC_ROLE_MSTS_STA_DIS_CONN)\n\t\twl->status.map._4way = false;\n\n\t_run_coex(rtwdev, BTC_RSN_NTFY_ROLE_INFO);\n}\n\nvoid rtw89_btc_ntfy_radio_state(struct rtw89_dev *rtwdev, enum btc_rfctrl rf_state)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_wl_info *wl = &btc->cx.wl;\n\tu32 val;\n\n\trtw89_debug(rtwdev, RTW89_DBG_BTC, \"[BTC], %s(): rf_state = %d\\n\",\n\t\t    __func__, rf_state);\n\tbtc->dm.cnt_notify[BTC_NCNT_RADIO_STATE]++;\n\n\tswitch (rf_state) {\n\tcase BTC_RFCTRL_WL_OFF:\n\t\twl->status.map.rf_off = 1;\n\t\twl->status.map.lps = BTC_LPS_OFF;\n\t\twl->status.map.busy = 0;\n\t\tbreak;\n\tcase BTC_RFCTRL_FW_CTRL:\n\t\twl->status.map.rf_off = 0;\n\t\twl->status.map.lps = BTC_LPS_RF_OFF;\n\t\twl->status.map.busy = 0;\n\t\tbreak;\n\tcase BTC_RFCTRL_LPS_WL_ON:  \n\t\twl->status.map.rf_off = 0;\n\t\twl->status.map.lps = BTC_LPS_RF_ON;\n\t\twl->status.map.busy = 0;\n\t\tbreak;\n\tcase BTC_RFCTRL_WL_ON:\n\tdefault:\n\t\twl->status.map.rf_off = 0;\n\t\twl->status.map.lps = BTC_LPS_OFF;\n\t\tbreak;\n\t}\n\n\tif (rf_state == BTC_RFCTRL_WL_ON) {\n\t\trtw89_btc_fw_en_rpt(rtwdev, RPT_EN_MREG, true);\n\t\tval = BTC_WSCB_ACTIVE | BTC_WSCB_ON | BTC_WSCB_BTLOG;\n\t\t_write_scbd(rtwdev, val, true);\n\t\t_update_bt_scbd(rtwdev, true);\n\t\tchip->ops->btc_init_cfg(rtwdev);\n\t} else {\n\t\trtw89_btc_fw_en_rpt(rtwdev, RPT_EN_ALL, false);\n\t\tif (rf_state == BTC_RFCTRL_WL_OFF)\n\t\t\t_write_scbd(rtwdev, BTC_WSCB_ALL, false);\n\t\telse if (rf_state == BTC_RFCTRL_LPS_WL_ON &&\n\t\t\t wl->status.map.lps_pre != BTC_LPS_OFF)\n\t\t\t_update_bt_scbd(rtwdev, true);\n\t}\n\n\tbtc->dm.cnt_dm[BTC_DCNT_BTCNT_HANG] = 0;\n\tif (wl->status.map.lps_pre == BTC_LPS_OFF &&\n\t    wl->status.map.lps_pre != wl->status.map.lps)\n\t\tbtc->dm.tdma_instant_excute = 1;\n\telse\n\t\tbtc->dm.tdma_instant_excute = 0;\n\n\t_run_coex(rtwdev, BTC_RSN_NTFY_RADIO_STATE);\n\tbtc->dm.tdma_instant_excute = 0;\n\twl->status.map.rf_off_pre = wl->status.map.rf_off;\n\twl->status.map.lps_pre = wl->status.map.lps;\n}\n\nstatic bool _ntfy_wl_rfk(struct rtw89_dev *rtwdev, u8 phy_path,\n\t\t\t enum btc_wl_rfk_type type,\n\t\t\t enum btc_wl_rfk_state state)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_cx *cx = &btc->cx;\n\tstruct rtw89_btc_wl_info *wl = &cx->wl;\n\tbool result = BTC_WRFK_REJECT;\n\n\twl->rfk_info.type = type;\n\twl->rfk_info.path_map = FIELD_GET(BTC_RFK_PATH_MAP, phy_path);\n\twl->rfk_info.phy_map = FIELD_GET(BTC_RFK_PHY_MAP, phy_path);\n\twl->rfk_info.band = FIELD_GET(BTC_RFK_BAND_MAP, phy_path);\n\n\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t    \"[BTC], %s()_start: phy=0x%x, path=0x%x, type=%d, state=%d\\n\",\n\t\t    __func__, wl->rfk_info.phy_map, wl->rfk_info.path_map,\n\t\t    type, state);\n\n\tswitch (state) {\n\tcase BTC_WRFK_START:\n\t\tresult = _chk_wl_rfk_request(rtwdev);\n\t\twl->rfk_info.state = result ? BTC_WRFK_START : BTC_WRFK_STOP;\n\n\t\t_write_scbd(rtwdev, BTC_WSCB_WLRFK, result);\n\n\t\tbtc->dm.cnt_notify[BTC_NCNT_WL_RFK]++;\n\t\tbreak;\n\tcase BTC_WRFK_ONESHOT_START:\n\tcase BTC_WRFK_ONESHOT_STOP:\n\t\tif (wl->rfk_info.state == BTC_WRFK_STOP) {\n\t\t\tresult = BTC_WRFK_REJECT;\n\t\t} else {\n\t\t\tresult = BTC_WRFK_ALLOW;\n\t\t\twl->rfk_info.state = state;\n\t\t}\n\t\tbreak;\n\tcase BTC_WRFK_STOP:\n\t\tresult = BTC_WRFK_ALLOW;\n\t\twl->rfk_info.state = BTC_WRFK_STOP;\n\n\t\t_write_scbd(rtwdev, BTC_WSCB_WLRFK, false);\n\t\tcancel_delayed_work(&rtwdev->coex_rfk_chk_work);\n\t\tbreak;\n\tdefault:\n\t\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t\t    \"[BTC], %s() warning state=%d\\n\", __func__, state);\n\t\tbreak;\n\t}\n\n\tif (result == BTC_WRFK_ALLOW) {\n\t\tif (wl->rfk_info.state == BTC_WRFK_START ||\n\t\t    wl->rfk_info.state == BTC_WRFK_STOP)\n\t\t\t_run_coex(rtwdev, BTC_RSN_NTFY_WL_RFK);\n\n\t\tif (wl->rfk_info.state == BTC_WRFK_START)\n\t\t\tieee80211_queue_delayed_work(rtwdev->hw,\n\t\t\t\t\t\t     &rtwdev->coex_rfk_chk_work,\n\t\t\t\t\t\t     RTW89_COEX_RFK_CHK_WORK_PERIOD);\n\t}\n\n\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t    \"[BTC], %s()_finish: rfk_cnt=%d, result=%d\\n\",\n\t\t    __func__, btc->dm.cnt_notify[BTC_NCNT_WL_RFK], result);\n\n\treturn result == BTC_WRFK_ALLOW;\n}\n\nvoid rtw89_btc_ntfy_wl_rfk(struct rtw89_dev *rtwdev, u8 phy_map,\n\t\t\t   enum btc_wl_rfk_type type,\n\t\t\t   enum btc_wl_rfk_state state)\n{\n\tu8 band;\n\tbool allow;\n\tint ret;\n\n\tband = FIELD_GET(BTC_RFK_BAND_MAP, phy_map);\n\n\trtw89_debug(rtwdev, RTW89_DBG_RFK,\n\t\t    \"[RFK] RFK notify (%s / PHY%u / K_type = %u / path_idx = %lu / process = %s)\\n\",\n\t\t    band == RTW89_BAND_2G ? \"2G\" :\n\t\t    band == RTW89_BAND_5G ? \"5G\" : \"6G\",\n\t\t    !!(FIELD_GET(BTC_RFK_PHY_MAP, phy_map) & BIT(RTW89_PHY_1)),\n\t\t    type,\n\t\t    FIELD_GET(BTC_RFK_PATH_MAP, phy_map),\n\t\t    state == BTC_WRFK_STOP ? \"RFK_STOP\" :\n\t\t    state == BTC_WRFK_START ? \"RFK_START\" :\n\t\t    state == BTC_WRFK_ONESHOT_START ? \"ONE-SHOT_START\" :\n\t\t    \"ONE-SHOT_STOP\");\n\n\tif (state != BTC_WRFK_START || rtwdev->is_bt_iqk_timeout) {\n\t\t_ntfy_wl_rfk(rtwdev, phy_map, type, state);\n\t\treturn;\n\t}\n\n\tret = read_poll_timeout(_ntfy_wl_rfk, allow, allow, 40, 100000, false,\n\t\t\t\trtwdev, phy_map, type, state);\n\tif (ret) {\n\t\trtw89_warn(rtwdev, \"RFK notify timeout\\n\");\n\t\trtwdev->is_bt_iqk_timeout = true;\n\t}\n}\nEXPORT_SYMBOL(rtw89_btc_ntfy_wl_rfk);\n\nstruct rtw89_btc_wl_sta_iter_data {\n\tstruct rtw89_dev *rtwdev;\n\tu8 busy_all;\n\tu8 dir_all;\n\tu8 rssi_map_all;\n\tbool is_sta_change;\n\tbool is_traffic_change;\n};\n\nstatic void rtw89_btc_ntfy_wl_sta_iter(void *data, struct ieee80211_sta *sta)\n{\n\tstruct rtw89_btc_wl_sta_iter_data *iter_data =\n\t\t\t\t(struct rtw89_btc_wl_sta_iter_data *)data;\n\tstruct rtw89_dev *rtwdev = iter_data->rtwdev;\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_dm *dm = &btc->dm;\n\tconst struct rtw89_btc_ver *ver = btc->ver;\n\tstruct rtw89_btc_wl_info *wl = &btc->cx.wl;\n\tstruct rtw89_btc_wl_link_info *link_info = NULL;\n\tstruct rtw89_sta *rtwsta = (struct rtw89_sta *)sta->drv_priv;\n\tstruct rtw89_traffic_stats *link_info_t = NULL;\n\tstruct rtw89_vif *rtwvif = rtwsta->rtwvif;\n\tstruct rtw89_traffic_stats *stats = &rtwvif->stats;\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tstruct rtw89_btc_wl_role_info *r;\n\tstruct rtw89_btc_wl_role_info_v1 *r1;\n\tu32 last_tx_rate, last_rx_rate;\n\tu16 last_tx_lvl, last_rx_lvl;\n\tu8 port = rtwvif->port;\n\tu8 rssi;\n\tu8 busy = 0;\n\tu8 dir = 0;\n\tu8 rssi_map = 0;\n\tu8 i = 0;\n\tbool is_sta_change = false, is_traffic_change = false;\n\n\trssi = ewma_rssi_read(&rtwsta->avg_rssi) >> RSSI_FACTOR;\n\trtw89_debug(rtwdev, RTW89_DBG_BTC, \"[BTC], rssi=%d\\n\", rssi);\n\n\tlink_info = &wl->link_info[port];\n\tlink_info->stat.traffic = rtwvif->stats;\n\tlink_info_t = &link_info->stat.traffic;\n\n\tif (link_info->connected == MLME_NO_LINK) {\n\t\tlink_info->rx_rate_drop_cnt = 0;\n\t\treturn;\n\t}\n\n\tlink_info->stat.rssi = rssi;\n\tfor (i = 0; i < BTC_WL_RSSI_THMAX; i++) {\n\t\tlink_info->rssi_state[i] =\n\t\t\t_update_rssi_state(rtwdev,\n\t\t\t\t\t   link_info->rssi_state[i],\n\t\t\t\t\t   link_info->stat.rssi,\n\t\t\t\t\t   chip->wl_rssi_thres[i]);\n\t\tif (BTC_RSSI_LOW(link_info->rssi_state[i]))\n\t\t\trssi_map |= BIT(i);\n\n\t\tif (btc->mdinfo.ant.type == BTC_ANT_DEDICATED &&\n\t\t    BTC_RSSI_CHANGE(link_info->rssi_state[i]))\n\t\t\tis_sta_change = true;\n\t}\n\titer_data->rssi_map_all |= rssi_map;\n\n\tlast_tx_rate = link_info_t->tx_rate;\n\tlast_rx_rate = link_info_t->rx_rate;\n\tlast_tx_lvl = (u16)link_info_t->tx_tfc_lv;\n\tlast_rx_lvl = (u16)link_info_t->rx_tfc_lv;\n\n\tif (stats->tx_tfc_lv != RTW89_TFC_IDLE ||\n\t    stats->rx_tfc_lv != RTW89_TFC_IDLE)\n\t\tbusy = 1;\n\n\tif (stats->tx_tfc_lv > stats->rx_tfc_lv)\n\t\tdir = RTW89_TFC_UL;\n\telse\n\t\tdir = RTW89_TFC_DL;\n\n\tlink_info = &wl->link_info[port];\n\tif (link_info->busy != busy || link_info->dir != dir) {\n\t\tis_sta_change = true;\n\t\tlink_info->busy = busy;\n\t\tlink_info->dir = dir;\n\t}\n\n\titer_data->busy_all |= busy;\n\titer_data->dir_all |= BIT(dir);\n\n\tif (rtwsta->rx_hw_rate <= RTW89_HW_RATE_CCK2 &&\n\t    last_rx_rate > RTW89_HW_RATE_CCK2 &&\n\t    link_info_t->rx_tfc_lv > RTW89_TFC_IDLE)\n\t\tlink_info->rx_rate_drop_cnt++;\n\n\tif (last_tx_rate != rtwsta->ra_report.hw_rate ||\n\t    last_rx_rate != rtwsta->rx_hw_rate ||\n\t    last_tx_lvl != link_info_t->tx_tfc_lv ||\n\t    last_rx_lvl != link_info_t->rx_tfc_lv)\n\t\tis_traffic_change = true;\n\n\tlink_info_t->tx_rate = rtwsta->ra_report.hw_rate;\n\tlink_info_t->rx_rate = rtwsta->rx_hw_rate;\n\n\tif (link_info->role == RTW89_WIFI_ROLE_STATION ||\n\t    link_info->role == RTW89_WIFI_ROLE_P2P_CLIENT) {\n\t\tdm->trx_info.tx_rate = link_info_t->tx_rate;\n\t\tdm->trx_info.rx_rate = link_info_t->rx_rate;\n\t}\n\n\tif (ver->fwlrole == 0) {\n\t\tr = &wl->role_info;\n\t\tr->active_role[port].tx_lvl = stats->tx_tfc_lv;\n\t\tr->active_role[port].rx_lvl = stats->rx_tfc_lv;\n\t\tr->active_role[port].tx_rate = rtwsta->ra_report.hw_rate;\n\t\tr->active_role[port].rx_rate = rtwsta->rx_hw_rate;\n\t} else if (ver->fwlrole == 1) {\n\t\tr1 = &wl->role_info_v1;\n\t\tr1->active_role_v1[port].tx_lvl = stats->tx_tfc_lv;\n\t\tr1->active_role_v1[port].rx_lvl = stats->rx_tfc_lv;\n\t\tr1->active_role_v1[port].tx_rate = rtwsta->ra_report.hw_rate;\n\t\tr1->active_role_v1[port].rx_rate = rtwsta->rx_hw_rate;\n\t} else if (ver->fwlrole == 2) {\n\t\tdm->trx_info.tx_lvl = stats->tx_tfc_lv;\n\t\tdm->trx_info.rx_lvl = stats->rx_tfc_lv;\n\t\tdm->trx_info.tx_rate = rtwsta->ra_report.hw_rate;\n\t\tdm->trx_info.rx_rate = rtwsta->rx_hw_rate;\n\t}\n\n\tdm->trx_info.tx_tp = link_info_t->tx_throughput;\n\tdm->trx_info.rx_tp = link_info_t->rx_throughput;\n\n\tif (is_sta_change)\n\t\titer_data->is_sta_change = true;\n\n\tif (is_traffic_change)\n\t\titer_data->is_traffic_change = true;\n}\n\n#define BTC_NHM_CHK_INTVL 20\n\nvoid rtw89_btc_ntfy_wl_sta(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_dm *dm = &btc->dm;\n\tstruct rtw89_btc_wl_info *wl = &btc->cx.wl;\n\tstruct rtw89_btc_wl_sta_iter_data data = {.rtwdev = rtwdev};\n\tu8 i;\n\n\tieee80211_iterate_stations_atomic(rtwdev->hw,\n\t\t\t\t\t  rtw89_btc_ntfy_wl_sta_iter,\n\t\t\t\t\t  &data);\n\n\twl->rssi_level = 0;\n\tbtc->dm.cnt_notify[BTC_NCNT_WL_STA]++;\n\tfor (i = BTC_WL_RSSI_THMAX; i > 0; i--) {\n\t\t \n\t\tif (data.rssi_map_all & BIT(i - 1)) {\n\t\t\twl->rssi_level = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (dm->trx_info.wl_rssi != wl->rssi_level)\n\t\tdm->trx_info.wl_rssi = wl->rssi_level;\n\n\trtw89_debug(rtwdev, RTW89_DBG_BTC, \"[BTC], %s(): busy=%d\\n\",\n\t\t    __func__, !!wl->status.map.busy);\n\n\t_write_scbd(rtwdev, BTC_WSCB_WLBUSY, (!!wl->status.map.busy));\n\n\tif (data.is_traffic_change)\n\t\t_fw_set_drv_info(rtwdev, CXDRVINFO_ROLE);\n\tif (data.is_sta_change) {\n\t\twl->status.map.busy = data.busy_all;\n\t\twl->status.map.traffic_dir = data.dir_all;\n\t\t_run_coex(rtwdev, BTC_RSN_NTFY_WL_STA);\n\t} else if (btc->dm.cnt_notify[BTC_NCNT_WL_STA] >=\n\t\t   btc->dm.cnt_dm[BTC_DCNT_WL_STA_LAST] + BTC_NHM_CHK_INTVL) {\n\t\tbtc->dm.cnt_dm[BTC_DCNT_WL_STA_LAST] =\n\t\t\tbtc->dm.cnt_notify[BTC_NCNT_WL_STA];\n\t} else if (btc->dm.cnt_notify[BTC_NCNT_WL_STA] <\n\t\t   btc->dm.cnt_dm[BTC_DCNT_WL_STA_LAST]) {\n\t\tbtc->dm.cnt_dm[BTC_DCNT_WL_STA_LAST] =\n\t\tbtc->dm.cnt_notify[BTC_NCNT_WL_STA];\n\t}\n}\n\nvoid rtw89_btc_c2h_handle(struct rtw89_dev *rtwdev, struct sk_buff *skb,\n\t\t\t  u32 len, u8 class, u8 func)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_btf_fwinfo *pfwinfo = &btc->fwinfo;\n\tu8 *buf = &skb->data[RTW89_C2H_HEADER_LEN];\n\n\tlen -= RTW89_C2H_HEADER_LEN;\n\n\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t    \"[BTC], %s(): C2H BT len:%d class:%d fun:%d\\n\",\n\t\t    __func__, len, class, func);\n\n\tif (class != BTFC_FW_EVENT)\n\t\treturn;\n\n\tswitch (func) {\n\tcase BTF_EVNT_RPT:\n\tcase BTF_EVNT_BUF_OVERFLOW:\n\t\tpfwinfo->event[func]++;\n\t\t \n\t\tbtc_fw_event(rtwdev, func, buf, len);\n\t\tbreak;\n\tcase BTF_EVNT_BT_INFO:\n\t\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t\t    \"[BTC], handle C2H BT INFO with data %8ph\\n\", buf);\n\t\tbtc->cx.cnt_bt[BTC_BCNT_INFOUPDATE]++;\n\t\t_update_bt_info(rtwdev, buf, len);\n\t\tbreak;\n\tcase BTF_EVNT_BT_SCBD:\n\t\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t\t    \"[BTC], handle C2H BT SCBD with data %8ph\\n\", buf);\n\t\tbtc->cx.cnt_bt[BTC_BCNT_SCBDUPDATE]++;\n\t\t_update_bt_scbd(rtwdev, false);\n\t\tbreak;\n\tcase BTF_EVNT_BT_PSD:\n\t\tbreak;\n\tcase BTF_EVNT_BT_REG:\n\t\tbtc->dbg.rb_done = true;\n\t\tbtc->dbg.rb_val = le32_to_cpu(*((__le32 *)buf));\n\n\t\tbreak;\n\tcase BTF_EVNT_C2H_LOOPBACK:\n\t\tbtc->dbg.rb_done = true;\n\t\tbtc->dbg.rb_val = buf[0];\n\t\tbreak;\n\tcase BTF_EVNT_CX_RUNINFO:\n\t\tbtc->dm.cnt_dm[BTC_DCNT_CX_RUNINFO]++;\n\t\tbreak;\n\t}\n}\n\n#define BTC_CX_FW_OFFLOAD 0\n\nstatic void _show_cx_info(struct rtw89_dev *rtwdev, struct seq_file *m)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tstruct rtw89_hal *hal = &rtwdev->hal;\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_dm *dm = &btc->dm;\n\tstruct rtw89_btc_bt_info *bt = &btc->cx.bt;\n\tstruct rtw89_btc_wl_info *wl = &btc->cx.wl;\n\tu32 ver_main = 0, ver_sub = 0, ver_hotfix = 0, id_branch = 0;\n\n\tif (!(dm->coex_info_map & BTC_COEX_INFO_CX))\n\t\treturn;\n\n\tdm->cnt_notify[BTC_NCNT_SHOW_COEX_INFO]++;\n\n\tseq_printf(m, \"========== [BTC COEX INFO (%d)] ==========\\n\",\n\t\t   chip->chip_id);\n\n\tver_main = FIELD_GET(GENMASK(31, 24), RTW89_COEX_VERSION);\n\tver_sub = FIELD_GET(GENMASK(23, 16), RTW89_COEX_VERSION);\n\tver_hotfix = FIELD_GET(GENMASK(15, 8), RTW89_COEX_VERSION);\n\tid_branch = FIELD_GET(GENMASK(7, 0), RTW89_COEX_VERSION);\n\tseq_printf(m, \" %-15s : Coex:%d.%d.%d(branch:%d), \",\n\t\t   \"[coex_version]\", ver_main, ver_sub, ver_hotfix, id_branch);\n\n\tver_main = FIELD_GET(GENMASK(31, 24), wl->ver_info.fw_coex);\n\tver_sub = FIELD_GET(GENMASK(23, 16), wl->ver_info.fw_coex);\n\tver_hotfix = FIELD_GET(GENMASK(15, 8), wl->ver_info.fw_coex);\n\tid_branch = FIELD_GET(GENMASK(7, 0), wl->ver_info.fw_coex);\n\tseq_printf(m, \"WL_FW_coex:%d.%d.%d(branch:%d)\",\n\t\t   ver_main, ver_sub, ver_hotfix, id_branch);\n\n\tver_main = FIELD_GET(GENMASK(31, 24), chip->wlcx_desired);\n\tver_sub = FIELD_GET(GENMASK(23, 16), chip->wlcx_desired);\n\tver_hotfix = FIELD_GET(GENMASK(15, 8), chip->wlcx_desired);\n\tseq_printf(m, \"(%s, desired:%d.%d.%d), \",\n\t\t   (wl->ver_info.fw_coex >= chip->wlcx_desired ?\n\t\t   \"Match\" : \"Mismatch\"), ver_main, ver_sub, ver_hotfix);\n\n\tseq_printf(m, \"BT_FW_coex:%d(%s, desired:%d)\\n\",\n\t\t   bt->ver_info.fw_coex,\n\t\t   (bt->ver_info.fw_coex >= chip->btcx_desired ?\n\t\t   \"Match\" : \"Mismatch\"), chip->btcx_desired);\n\n\tif (bt->enable.now && bt->ver_info.fw == 0)\n\t\trtw89_btc_fw_en_rpt(rtwdev, RPT_EN_BT_VER_INFO, true);\n\telse\n\t\trtw89_btc_fw_en_rpt(rtwdev, RPT_EN_BT_VER_INFO, false);\n\n\tver_main = FIELD_GET(GENMASK(31, 24), wl->ver_info.fw);\n\tver_sub = FIELD_GET(GENMASK(23, 16), wl->ver_info.fw);\n\tver_hotfix = FIELD_GET(GENMASK(15, 8), wl->ver_info.fw);\n\tid_branch = FIELD_GET(GENMASK(7, 0), wl->ver_info.fw);\n\tseq_printf(m, \" %-15s : WL_FW:%d.%d.%d.%d, BT_FW:0x%x(%s)\\n\",\n\t\t   \"[sub_module]\",\n\t\t   ver_main, ver_sub, ver_hotfix, id_branch,\n\t\t   bt->ver_info.fw, bt->run_patch_code ? \"patch\" : \"ROM\");\n\n\tseq_printf(m, \" %-15s : cv:%x, rfe_type:0x%x, ant_iso:%d, ant_pg:%d, %s\",\n\t\t   \"[hw_info]\", btc->mdinfo.cv, btc->mdinfo.rfe_type,\n\t\t   btc->mdinfo.ant.isolation, btc->mdinfo.ant.num,\n\t\t   (btc->mdinfo.ant.num > 1 ? \"\" : (btc->mdinfo.ant.single_pos ?\n\t\t   \"1Ant_Pos:S1, \" : \"1Ant_Pos:S0, \")));\n\n\tseq_printf(m, \"3rd_coex:%d, dbcc:%d, tx_num:%d, rx_num:%d\\n\",\n\t\t   btc->cx.other.type, rtwdev->dbcc_en, hal->tx_nss,\n\t\t   hal->rx_nss);\n}\n\nstatic void _show_wl_role_info(struct rtw89_dev *rtwdev, struct seq_file *m)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_wl_link_info *plink = NULL;\n\tstruct rtw89_btc_wl_info *wl = &btc->cx.wl;\n\tstruct rtw89_btc_wl_dbcc_info *wl_dinfo = &wl->dbcc_info;\n\tstruct rtw89_traffic_stats *t;\n\tu8 i;\n\n\tif (rtwdev->dbcc_en) {\n\t\tseq_printf(m,\n\t\t\t   \" %-15s : PHY0_band(op:%d/scan:%d/real:%d), \",\n\t\t\t   \"[dbcc_info]\", wl_dinfo->op_band[RTW89_PHY_0],\n\t\t\t   wl_dinfo->scan_band[RTW89_PHY_0],\n\t\t\t   wl_dinfo->real_band[RTW89_PHY_0]);\n\t\tseq_printf(m,\n\t\t\t   \"PHY1_band(op:%d/scan:%d/real:%d)\\n\",\n\t\t\t   wl_dinfo->op_band[RTW89_PHY_1],\n\t\t\t   wl_dinfo->scan_band[RTW89_PHY_1],\n\t\t\t   wl_dinfo->real_band[RTW89_PHY_1]);\n\t}\n\n\tfor (i = 0; i < RTW89_PORT_NUM; i++) {\n\t\tplink = &btc->cx.wl.link_info[i];\n\n\t\tif (!plink->active)\n\t\t\tcontinue;\n\n\t\tseq_printf(m,\n\t\t\t   \" [port_%d]        : role=%d(phy-%d), connect=%d(client_cnt=%d), mode=%d, center_ch=%d, bw=%d\",\n\t\t\t   plink->pid, (u32)plink->role, plink->phy,\n\t\t\t   (u32)plink->connected, plink->client_cnt - 1,\n\t\t\t   (u32)plink->mode, plink->ch, (u32)plink->bw);\n\n\t\tif (plink->connected == MLME_NO_LINK)\n\t\t\tcontinue;\n\n\t\tseq_printf(m,\n\t\t\t   \", mac_id=%d, max_tx_time=%dus, max_tx_retry=%d\\n\",\n\t\t\t   plink->mac_id, plink->tx_time, plink->tx_retry);\n\n\t\tseq_printf(m,\n\t\t\t   \" [port_%d]        : rssi=-%ddBm(%d), busy=%d, dir=%s, \",\n\t\t\t   plink->pid, 110 - plink->stat.rssi,\n\t\t\t   plink->stat.rssi, plink->busy,\n\t\t\t   plink->dir == RTW89_TFC_UL ? \"UL\" : \"DL\");\n\n\t\tt = &plink->stat.traffic;\n\n\t\tseq_printf(m,\n\t\t\t   \"tx[rate:%d/busy_level:%d], \",\n\t\t\t   (u32)t->tx_rate, t->tx_tfc_lv);\n\n\t\tseq_printf(m, \"rx[rate:%d/busy_level:%d/drop:%d]\\n\",\n\t\t\t   (u32)t->rx_rate,\n\t\t\t   t->rx_tfc_lv, plink->rx_rate_drop_cnt);\n\t}\n}\n\nstatic void _show_wl_info(struct rtw89_dev *rtwdev, struct seq_file *m)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tconst struct rtw89_btc_ver *ver = btc->ver;\n\tstruct rtw89_btc_cx *cx = &btc->cx;\n\tstruct rtw89_btc_wl_info *wl = &cx->wl;\n\tstruct rtw89_btc_wl_role_info *wl_rinfo = &wl->role_info;\n\tstruct rtw89_btc_wl_role_info_v1 *wl_rinfo_v1 = &wl->role_info_v1;\n\tstruct rtw89_btc_wl_role_info_v2 *wl_rinfo_v2 = &wl->role_info_v2;\n\tu8 mode;\n\n\tif (!(btc->dm.coex_info_map & BTC_COEX_INFO_WL))\n\t\treturn;\n\n\tseq_puts(m, \"========== [WL Status] ==========\\n\");\n\n\tif (ver->fwlrole == 0)\n\t\tmode = wl_rinfo->link_mode;\n\telse if (ver->fwlrole == 1)\n\t\tmode = wl_rinfo_v1->link_mode;\n\telse if (ver->fwlrole == 2)\n\t\tmode = wl_rinfo_v2->link_mode;\n\telse\n\t\treturn;\n\n\tseq_printf(m, \" %-15s : link_mode:%d, \", \"[status]\", mode);\n\n\tseq_printf(m,\n\t\t   \"rf_off:%d, power_save:%d, scan:%s(band:%d/phy_map:0x%x), \",\n\t\t   wl->status.map.rf_off, wl->status.map.lps,\n\t\t   wl->status.map.scan ? \"Y\" : \"N\",\n\t\t   wl->scan_info.band[RTW89_PHY_0], wl->scan_info.phy_map);\n\n\tseq_printf(m,\n\t\t   \"connecting:%s, roam:%s, 4way:%s, init_ok:%s\\n\",\n\t\t   wl->status.map.connecting ? \"Y\" : \"N\",\n\t\t   wl->status.map.roaming ?  \"Y\" : \"N\",\n\t\t   wl->status.map._4way ? \"Y\" : \"N\",\n\t\t   wl->status.map.init_ok ? \"Y\" : \"N\");\n\n\t_show_wl_role_info(rtwdev, m);\n}\n\nenum btc_bt_a2dp_type {\n\tBTC_A2DP_LEGACY = 0,\n\tBTC_A2DP_TWS_SNIFF = 1,\n\tBTC_A2DP_TWS_RELAY = 2,\n};\n\nstatic void _show_bt_profile_info(struct rtw89_dev *rtwdev, struct seq_file *m)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_bt_link_info *bt_linfo = &btc->cx.bt.link_info;\n\tstruct rtw89_btc_bt_hfp_desc hfp = bt_linfo->hfp_desc;\n\tstruct rtw89_btc_bt_hid_desc hid = bt_linfo->hid_desc;\n\tstruct rtw89_btc_bt_a2dp_desc a2dp = bt_linfo->a2dp_desc;\n\tstruct rtw89_btc_bt_pan_desc pan = bt_linfo->pan_desc;\n\n\tif (hfp.exist) {\n\t\tseq_printf(m, \" %-15s : type:%s, sut_pwr:%d, golden-rx:%d\",\n\t\t\t   \"[HFP]\", (hfp.type == 0 ? \"SCO\" : \"eSCO\"),\n\t\t\t   bt_linfo->sut_pwr_level[0],\n\t\t\t   bt_linfo->golden_rx_shift[0]);\n\t}\n\n\tif (hid.exist) {\n\t\tseq_printf(m,\n\t\t\t   \"\\n\\r %-15s : type:%s%s%s%s%s pair-cnt:%d, sut_pwr:%d, golden-rx:%d\\n\",\n\t\t\t   \"[HID]\",\n\t\t\t   hid.type & BTC_HID_218 ? \"2/18,\" : \"\",\n\t\t\t   hid.type & BTC_HID_418 ? \"4/18,\" : \"\",\n\t\t\t   hid.type & BTC_HID_BLE ? \"BLE,\" : \"\",\n\t\t\t   hid.type & BTC_HID_RCU ? \"RCU,\" : \"\",\n\t\t\t   hid.type & BTC_HID_RCU_VOICE ? \"RCU-Voice,\" : \"\",\n\t\t\t   hid.pair_cnt, bt_linfo->sut_pwr_level[1],\n\t\t\t   bt_linfo->golden_rx_shift[1]);\n\t}\n\n\tif (a2dp.exist) {\n\t\tseq_printf(m,\n\t\t\t   \" %-15s : type:%s, bit-pool:%d, flush-time:%d, \",\n\t\t\t   \"[A2DP]\",\n\t\t\t   a2dp.type == BTC_A2DP_LEGACY ? \"Legacy\" : \"TWS\",\n\t\t\t    a2dp.bitpool, a2dp.flush_time);\n\n\t\tseq_printf(m,\n\t\t\t   \"vid:0x%x, Dev-name:0x%x, sut_pwr:%d, golden-rx:%d\\n\",\n\t\t\t   a2dp.vendor_id, a2dp.device_name,\n\t\t\t   bt_linfo->sut_pwr_level[2],\n\t\t\t   bt_linfo->golden_rx_shift[2]);\n\t}\n\n\tif (pan.exist) {\n\t\tseq_printf(m, \" %-15s : sut_pwr:%d, golden-rx:%d\\n\",\n\t\t\t   \"[PAN]\",\n\t\t\t   bt_linfo->sut_pwr_level[3],\n\t\t\t   bt_linfo->golden_rx_shift[3]);\n\t}\n}\n\nstatic void _show_bt_info(struct rtw89_dev *rtwdev, struct seq_file *m)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tconst struct rtw89_btc_ver *ver = btc->ver;\n\tstruct rtw89_btc_cx *cx = &btc->cx;\n\tstruct rtw89_btc_bt_info *bt = &cx->bt;\n\tstruct rtw89_btc_wl_info *wl = &cx->wl;\n\tstruct rtw89_btc_module *module = &btc->mdinfo;\n\tstruct rtw89_btc_bt_link_info *bt_linfo = &bt->link_info;\n\tu8 *afh = bt_linfo->afh_map;\n\tu8 *afh_le = bt_linfo->afh_map_le;\n\n\tif (!(btc->dm.coex_info_map & BTC_COEX_INFO_BT))\n\t\treturn;\n\n\tseq_puts(m, \"========== [BT Status] ==========\\n\");\n\n\tseq_printf(m, \" %-15s : enable:%s, btg:%s%s, connect:%s, \",\n\t\t   \"[status]\", bt->enable.now ? \"Y\" : \"N\",\n\t\t   bt->btg_type ? \"Y\" : \"N\",\n\t\t   (bt->enable.now && (bt->btg_type != module->bt_pos) ?\n\t\t   \"(efuse-mismatch!!)\" : \"\"),\n\t\t   (bt_linfo->status.map.connect ? \"Y\" : \"N\"));\n\n\tseq_printf(m, \"igno_wl:%s, mailbox_avl:%s, rfk_state:0x%x\\n\",\n\t\t   bt->igno_wl ? \"Y\" : \"N\",\n\t\t   bt->mbx_avl ? \"Y\" : \"N\", bt->rfk_info.val);\n\n\tseq_printf(m, \" %-15s : profile:%s%s%s%s%s \",\n\t\t   \"[profile]\",\n\t\t   (bt_linfo->profile_cnt.now == 0) ? \"None,\" : \"\",\n\t\t   bt_linfo->hfp_desc.exist ? \"HFP,\" : \"\",\n\t\t   bt_linfo->hid_desc.exist ? \"HID,\" : \"\",\n\t\t   bt_linfo->a2dp_desc.exist ?\n\t\t   (bt_linfo->a2dp_desc.sink ? \"A2DP_sink,\" : \"A2DP,\") : \"\",\n\t\t   bt_linfo->pan_desc.exist ? \"PAN,\" : \"\");\n\n\tseq_printf(m,\n\t\t   \"multi-link:%s, role:%s, ble-connect:%s, CQDDR:%s, A2DP_active:%s, PAN_active:%s\\n\",\n\t\t   bt_linfo->multi_link.now ? \"Y\" : \"N\",\n\t\t   bt_linfo->slave_role ? \"Slave\" : \"Master\",\n\t\t   bt_linfo->status.map.ble_connect ? \"Y\" : \"N\",\n\t\t   bt_linfo->cqddr ? \"Y\" : \"N\",\n\t\t   bt_linfo->a2dp_desc.active ? \"Y\" : \"N\",\n\t\t   bt_linfo->pan_desc.active ? \"Y\" : \"N\");\n\n\tseq_printf(m,\n\t\t   \" %-15s : rssi:%ddBm, tx_rate:%dM, %s%s%s\",\n\t\t   \"[link]\", bt_linfo->rssi - 100,\n\t\t   bt_linfo->tx_3m ? 3 : 2,\n\t\t   bt_linfo->status.map.inq_pag ? \" inq-page!!\" : \"\",\n\t\t   bt_linfo->status.map.acl_busy ? \" acl_busy!!\" : \"\",\n\t\t   bt_linfo->status.map.mesh_busy ? \" mesh_busy!!\" : \"\");\n\n\tseq_printf(m,\n\t\t   \"%s afh_map[%02x%02x_%02x%02x_%02x%02x_%02x%02x_%02x%02x], \",\n\t\t   bt_linfo->relink.now ? \" ReLink!!\" : \"\",\n\t\t   afh[0], afh[1], afh[2], afh[3], afh[4],\n\t\t   afh[5], afh[6], afh[7], afh[8], afh[9]);\n\n\tif (ver->fcxbtafh == 2 && bt_linfo->status.map.ble_connect)\n\t\tseq_printf(m,\n\t\t\t   \"LE[%02x%02x_%02x_%02x%02x]\",\n\t\t\t   afh_le[0], afh_le[1], afh_le[2],\n\t\t\t   afh_le[3], afh_le[4]);\n\n\tseq_printf(m, \"wl_ch_map[en:%d/ch:%d/bw:%d]\\n\",\n\t\t   wl->afh_info.en, wl->afh_info.ch, wl->afh_info.bw);\n\n\tseq_printf(m,\n\t\t   \" %-15s : retry:%d, relink:%d, rate_chg:%d, reinit:%d, reenable:%d, \",\n\t\t   \"[stat_cnt]\", cx->cnt_bt[BTC_BCNT_RETRY],\n\t\t   cx->cnt_bt[BTC_BCNT_RELINK], cx->cnt_bt[BTC_BCNT_RATECHG],\n\t\t   cx->cnt_bt[BTC_BCNT_REINIT], cx->cnt_bt[BTC_BCNT_REENABLE]);\n\n\tseq_printf(m,\n\t\t   \"role-switch:%d, afh:%d, inq_page:%d(inq:%d/page:%d), igno_wl:%d\\n\",\n\t\t   cx->cnt_bt[BTC_BCNT_ROLESW], cx->cnt_bt[BTC_BCNT_AFH],\n\t\t   cx->cnt_bt[BTC_BCNT_INQPAG], cx->cnt_bt[BTC_BCNT_INQ],\n\t\t   cx->cnt_bt[BTC_BCNT_PAGE], cx->cnt_bt[BTC_BCNT_IGNOWL]);\n\n\t_show_bt_profile_info(rtwdev, m);\n\n\tseq_printf(m,\n\t\t   \" %-15s : raw_data[%02x %02x %02x %02x %02x %02x] (type:%s/cnt:%d/same:%d)\\n\",\n\t\t   \"[bt_info]\", bt->raw_info[2], bt->raw_info[3],\n\t\t   bt->raw_info[4], bt->raw_info[5], bt->raw_info[6],\n\t\t   bt->raw_info[7],\n\t\t   bt->raw_info[0] == BTC_BTINFO_AUTO ? \"auto\" : \"reply\",\n\t\t   cx->cnt_bt[BTC_BCNT_INFOUPDATE],\n\t\t   cx->cnt_bt[BTC_BCNT_INFOSAME]);\n\n\tseq_printf(m,\n\t\t   \" %-15s : Hi-rx = %d, Hi-tx = %d, Lo-rx = %d, Lo-tx = %d (bt_polut_wl_tx = %d)\",\n\t\t   \"[trx_req_cnt]\", cx->cnt_bt[BTC_BCNT_HIPRI_RX],\n\t\t   cx->cnt_bt[BTC_BCNT_HIPRI_TX], cx->cnt_bt[BTC_BCNT_LOPRI_RX],\n\t\t   cx->cnt_bt[BTC_BCNT_LOPRI_TX], cx->cnt_bt[BTC_BCNT_POLUT]);\n\n\tif (!bt->scan_info_update) {\n\t\trtw89_btc_fw_en_rpt(rtwdev, RPT_EN_BT_SCAN_INFO, true);\n\t\tseq_puts(m, \"\\n\");\n\t} else {\n\t\trtw89_btc_fw_en_rpt(rtwdev, RPT_EN_BT_SCAN_INFO, false);\n\t\tif (ver->fcxbtscan == 1) {\n\t\t\tseq_printf(m,\n\t\t\t\t   \"(INQ:%d-%d/PAGE:%d-%d/LE:%d-%d/INIT:%d-%d)\",\n\t\t\t\t   le16_to_cpu(bt->scan_info_v1[BTC_SCAN_INQ].win),\n\t\t\t\t   le16_to_cpu(bt->scan_info_v1[BTC_SCAN_INQ].intvl),\n\t\t\t\t   le16_to_cpu(bt->scan_info_v1[BTC_SCAN_PAGE].win),\n\t\t\t\t   le16_to_cpu(bt->scan_info_v1[BTC_SCAN_PAGE].intvl),\n\t\t\t\t   le16_to_cpu(bt->scan_info_v1[BTC_SCAN_BLE].win),\n\t\t\t\t   le16_to_cpu(bt->scan_info_v1[BTC_SCAN_BLE].intvl),\n\t\t\t\t   le16_to_cpu(bt->scan_info_v1[BTC_SCAN_INIT].win),\n\t\t\t\t   le16_to_cpu(bt->scan_info_v1[BTC_SCAN_INIT].intvl));\n\t\t} else if (ver->fcxbtscan == 2) {\n\t\t\tseq_printf(m,\n\t\t\t\t   \"(BG:%d-%d/INIT:%d-%d/LE:%d-%d)\",\n\t\t\t\t   le16_to_cpu(bt->scan_info_v2[CXSCAN_BG].win),\n\t\t\t\t   le16_to_cpu(bt->scan_info_v2[CXSCAN_BG].intvl),\n\t\t\t\t   le16_to_cpu(bt->scan_info_v2[CXSCAN_INIT].win),\n\t\t\t\t   le16_to_cpu(bt->scan_info_v2[CXSCAN_INIT].intvl),\n\t\t\t\t   le16_to_cpu(bt->scan_info_v2[CXSCAN_LE].win),\n\t\t\t\t   le16_to_cpu(bt->scan_info_v2[CXSCAN_LE].intvl));\n\t\t}\n\t\tseq_puts(m, \"\\n\");\n\t}\n\n\tif (bt->enable.now && bt->ver_info.fw == 0)\n\t\trtw89_btc_fw_en_rpt(rtwdev, RPT_EN_BT_VER_INFO, true);\n\telse\n\t\trtw89_btc_fw_en_rpt(rtwdev, RPT_EN_BT_VER_INFO, false);\n\n\tif (bt_linfo->profile_cnt.now || bt_linfo->status.map.ble_connect)\n\t\trtw89_btc_fw_en_rpt(rtwdev, RPT_EN_BT_AFH_MAP, true);\n\telse\n\t\trtw89_btc_fw_en_rpt(rtwdev, RPT_EN_BT_AFH_MAP, false);\n\n\tif (ver->fcxbtafh == 2 && bt_linfo->status.map.ble_connect)\n\t\trtw89_btc_fw_en_rpt(rtwdev, RPT_EN_BT_AFH_MAP_LE, true);\n\telse\n\t\trtw89_btc_fw_en_rpt(rtwdev, RPT_EN_BT_AFH_MAP_LE, false);\n\n\tif (bt_linfo->a2dp_desc.exist &&\n\t    (bt_linfo->a2dp_desc.flush_time == 0 ||\n\t     bt_linfo->a2dp_desc.vendor_id == 0 ||\n\t     bt_linfo->a2dp_desc.play_latency == 1))\n\t\trtw89_btc_fw_en_rpt(rtwdev, RPT_EN_BT_DEVICE_INFO, true);\n\telse\n\t\trtw89_btc_fw_en_rpt(rtwdev, RPT_EN_BT_DEVICE_INFO, false);\n}\n\n#define CASE_BTC_RSN_STR(e) case BTC_RSN_ ## e: return #e\n#define CASE_BTC_ACT_STR(e) case BTC_ACT_ ## e | BTC_ACT_EXT_BIT: return #e\n#define CASE_BTC_POLICY_STR(e) \\\n\tcase BTC_CXP_ ## e | BTC_POLICY_EXT_BIT: return #e\n#define CASE_BTC_SLOT_STR(e) case CXST_ ## e: return #e\n#define CASE_BTC_EVT_STR(e) case CXEVNT_## e: return #e\n\nstatic const char *steps_to_str(u16 step)\n{\n\tswitch (step) {\n\tCASE_BTC_RSN_STR(NONE);\n\tCASE_BTC_RSN_STR(NTFY_INIT);\n\tCASE_BTC_RSN_STR(NTFY_SWBAND);\n\tCASE_BTC_RSN_STR(NTFY_WL_STA);\n\tCASE_BTC_RSN_STR(NTFY_RADIO_STATE);\n\tCASE_BTC_RSN_STR(UPDATE_BT_SCBD);\n\tCASE_BTC_RSN_STR(NTFY_WL_RFK);\n\tCASE_BTC_RSN_STR(UPDATE_BT_INFO);\n\tCASE_BTC_RSN_STR(NTFY_SCAN_START);\n\tCASE_BTC_RSN_STR(NTFY_SCAN_FINISH);\n\tCASE_BTC_RSN_STR(NTFY_SPECIFIC_PACKET);\n\tCASE_BTC_RSN_STR(NTFY_POWEROFF);\n\tCASE_BTC_RSN_STR(NTFY_ROLE_INFO);\n\tCASE_BTC_RSN_STR(CMD_SET_COEX);\n\tCASE_BTC_RSN_STR(ACT1_WORK);\n\tCASE_BTC_RSN_STR(BT_DEVINFO_WORK);\n\tCASE_BTC_RSN_STR(RFK_CHK_WORK);\n\n\tCASE_BTC_ACT_STR(NONE);\n\tCASE_BTC_ACT_STR(WL_ONLY);\n\tCASE_BTC_ACT_STR(WL_5G);\n\tCASE_BTC_ACT_STR(WL_OTHER);\n\tCASE_BTC_ACT_STR(WL_IDLE);\n\tCASE_BTC_ACT_STR(WL_NC);\n\tCASE_BTC_ACT_STR(WL_RFK);\n\tCASE_BTC_ACT_STR(WL_INIT);\n\tCASE_BTC_ACT_STR(WL_OFF);\n\tCASE_BTC_ACT_STR(FREERUN);\n\tCASE_BTC_ACT_STR(BT_WHQL);\n\tCASE_BTC_ACT_STR(BT_RFK);\n\tCASE_BTC_ACT_STR(BT_OFF);\n\tCASE_BTC_ACT_STR(BT_IDLE);\n\tCASE_BTC_ACT_STR(BT_HFP);\n\tCASE_BTC_ACT_STR(BT_HID);\n\tCASE_BTC_ACT_STR(BT_A2DP);\n\tCASE_BTC_ACT_STR(BT_A2DPSINK);\n\tCASE_BTC_ACT_STR(BT_PAN);\n\tCASE_BTC_ACT_STR(BT_A2DP_HID);\n\tCASE_BTC_ACT_STR(BT_A2DP_PAN);\n\tCASE_BTC_ACT_STR(BT_PAN_HID);\n\tCASE_BTC_ACT_STR(BT_A2DP_PAN_HID);\n\tCASE_BTC_ACT_STR(WL_25G_MCC);\n\tCASE_BTC_ACT_STR(WL_2G_MCC);\n\tCASE_BTC_ACT_STR(WL_2G_SCC);\n\tCASE_BTC_ACT_STR(WL_2G_AP);\n\tCASE_BTC_ACT_STR(WL_2G_GO);\n\tCASE_BTC_ACT_STR(WL_2G_GC);\n\tCASE_BTC_ACT_STR(WL_2G_NAN);\n\n\tCASE_BTC_POLICY_STR(OFF_BT);\n\tCASE_BTC_POLICY_STR(OFF_WL);\n\tCASE_BTC_POLICY_STR(OFF_EQ0);\n\tCASE_BTC_POLICY_STR(OFF_EQ1);\n\tCASE_BTC_POLICY_STR(OFF_EQ2);\n\tCASE_BTC_POLICY_STR(OFF_EQ3);\n\tCASE_BTC_POLICY_STR(OFF_BWB0);\n\tCASE_BTC_POLICY_STR(OFF_BWB1);\n\tCASE_BTC_POLICY_STR(OFF_BWB2);\n\tCASE_BTC_POLICY_STR(OFF_BWB3);\n\tCASE_BTC_POLICY_STR(OFFB_BWB0);\n\tCASE_BTC_POLICY_STR(OFFE_DEF);\n\tCASE_BTC_POLICY_STR(OFFE_DEF2);\n\tCASE_BTC_POLICY_STR(OFFE_2GBWISOB);\n\tCASE_BTC_POLICY_STR(OFFE_2GISOB);\n\tCASE_BTC_POLICY_STR(OFFE_2GBWMIXB);\n\tCASE_BTC_POLICY_STR(OFFE_WL);\n\tCASE_BTC_POLICY_STR(OFFE_2GBWMIXB2);\n\tCASE_BTC_POLICY_STR(FIX_TD3030);\n\tCASE_BTC_POLICY_STR(FIX_TD5050);\n\tCASE_BTC_POLICY_STR(FIX_TD2030);\n\tCASE_BTC_POLICY_STR(FIX_TD4010);\n\tCASE_BTC_POLICY_STR(FIX_TD7010);\n\tCASE_BTC_POLICY_STR(FIX_TD2060);\n\tCASE_BTC_POLICY_STR(FIX_TD3060);\n\tCASE_BTC_POLICY_STR(FIX_TD2080);\n\tCASE_BTC_POLICY_STR(FIX_TDW1B1);\n\tCASE_BTC_POLICY_STR(FIX_TD4020);\n\tCASE_BTC_POLICY_STR(FIX_TD4010ISO);\n\tCASE_BTC_POLICY_STR(PFIX_TD3030);\n\tCASE_BTC_POLICY_STR(PFIX_TD5050);\n\tCASE_BTC_POLICY_STR(PFIX_TD2030);\n\tCASE_BTC_POLICY_STR(PFIX_TD2060);\n\tCASE_BTC_POLICY_STR(PFIX_TD3070);\n\tCASE_BTC_POLICY_STR(PFIX_TD2080);\n\tCASE_BTC_POLICY_STR(PFIX_TDW1B1);\n\tCASE_BTC_POLICY_STR(AUTO_TD50B1);\n\tCASE_BTC_POLICY_STR(AUTO_TD60B1);\n\tCASE_BTC_POLICY_STR(AUTO_TD20B1);\n\tCASE_BTC_POLICY_STR(AUTO_TDW1B1);\n\tCASE_BTC_POLICY_STR(PAUTO_TD50B1);\n\tCASE_BTC_POLICY_STR(PAUTO_TD60B1);\n\tCASE_BTC_POLICY_STR(PAUTO_TD20B1);\n\tCASE_BTC_POLICY_STR(PAUTO_TDW1B1);\n\tCASE_BTC_POLICY_STR(AUTO2_TD3050);\n\tCASE_BTC_POLICY_STR(AUTO2_TD3070);\n\tCASE_BTC_POLICY_STR(AUTO2_TD5050);\n\tCASE_BTC_POLICY_STR(AUTO2_TD6060);\n\tCASE_BTC_POLICY_STR(AUTO2_TD2080);\n\tCASE_BTC_POLICY_STR(AUTO2_TDW1B4);\n\tCASE_BTC_POLICY_STR(PAUTO2_TD3050);\n\tCASE_BTC_POLICY_STR(PAUTO2_TD3070);\n\tCASE_BTC_POLICY_STR(PAUTO2_TD5050);\n\tCASE_BTC_POLICY_STR(PAUTO2_TD6060);\n\tCASE_BTC_POLICY_STR(PAUTO2_TD2080);\n\tCASE_BTC_POLICY_STR(PAUTO2_TDW1B4);\n\tdefault:\n\t\treturn \"unknown step\";\n\t}\n}\n\nstatic const char *id_to_slot(u32 id)\n{\n\tswitch (id) {\n\tCASE_BTC_SLOT_STR(OFF);\n\tCASE_BTC_SLOT_STR(B2W);\n\tCASE_BTC_SLOT_STR(W1);\n\tCASE_BTC_SLOT_STR(W2);\n\tCASE_BTC_SLOT_STR(W2B);\n\tCASE_BTC_SLOT_STR(B1);\n\tCASE_BTC_SLOT_STR(B2);\n\tCASE_BTC_SLOT_STR(B3);\n\tCASE_BTC_SLOT_STR(B4);\n\tCASE_BTC_SLOT_STR(LK);\n\tCASE_BTC_SLOT_STR(BLK);\n\tCASE_BTC_SLOT_STR(E2G);\n\tCASE_BTC_SLOT_STR(E5G);\n\tCASE_BTC_SLOT_STR(EBT);\n\tCASE_BTC_SLOT_STR(ENULL);\n\tCASE_BTC_SLOT_STR(WLK);\n\tCASE_BTC_SLOT_STR(W1FDD);\n\tCASE_BTC_SLOT_STR(B1FDD);\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\nstatic const char *id_to_evt(u32 id)\n{\n\tswitch (id) {\n\tCASE_BTC_EVT_STR(TDMA_ENTRY);\n\tCASE_BTC_EVT_STR(WL_TMR);\n\tCASE_BTC_EVT_STR(B1_TMR);\n\tCASE_BTC_EVT_STR(B2_TMR);\n\tCASE_BTC_EVT_STR(B3_TMR);\n\tCASE_BTC_EVT_STR(B4_TMR);\n\tCASE_BTC_EVT_STR(W2B_TMR);\n\tCASE_BTC_EVT_STR(B2W_TMR);\n\tCASE_BTC_EVT_STR(BCN_EARLY);\n\tCASE_BTC_EVT_STR(A2DP_EMPTY);\n\tCASE_BTC_EVT_STR(LK_END);\n\tCASE_BTC_EVT_STR(RX_ISR);\n\tCASE_BTC_EVT_STR(RX_FC0);\n\tCASE_BTC_EVT_STR(RX_FC1);\n\tCASE_BTC_EVT_STR(BT_RELINK);\n\tCASE_BTC_EVT_STR(BT_RETRY);\n\tCASE_BTC_EVT_STR(E2G);\n\tCASE_BTC_EVT_STR(E5G);\n\tCASE_BTC_EVT_STR(EBT);\n\tCASE_BTC_EVT_STR(ENULL);\n\tCASE_BTC_EVT_STR(DRV_WLK);\n\tCASE_BTC_EVT_STR(BCN_OK);\n\tCASE_BTC_EVT_STR(BT_CHANGE);\n\tCASE_BTC_EVT_STR(EBT_EXTEND);\n\tCASE_BTC_EVT_STR(E2G_NULL1);\n\tCASE_BTC_EVT_STR(B1FDD_TMR);\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\nstatic\nvoid seq_print_segment(struct seq_file *m, const char *prefix, u16 *data,\n\t\t       u8 len, u8 seg_len, u8 start_idx, u8 ring_len)\n{\n\tu8 i;\n\tu8 cur_index;\n\n\tfor (i = 0; i < len ; i++) {\n\t\tif ((i % seg_len) == 0)\n\t\t\tseq_printf(m, \" %-15s : \", prefix);\n\t\tcur_index = (start_idx + i) % ring_len;\n\t\tif (i % 3 == 0)\n\t\t\tseq_printf(m, \"-> %-20s\",\n\t\t\t\t   steps_to_str(*(data + cur_index)));\n\t\telse if (i % 3 == 1)\n\t\t\tseq_printf(m, \"-> %-15s\",\n\t\t\t\t   steps_to_str(*(data + cur_index)));\n\t\telse\n\t\t\tseq_printf(m, \"-> %-13s\",\n\t\t\t\t   steps_to_str(*(data + cur_index)));\n\t\tif (i == (len - 1) || (i % seg_len) == (seg_len - 1))\n\t\t\tseq_puts(m, \"\\n\");\n\t}\n}\n\nstatic void _show_dm_step(struct rtw89_dev *rtwdev, struct seq_file *m)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_dm *dm = &btc->dm;\n\tu8 start_idx;\n\tu8 len;\n\n\tlen = dm->dm_step.step_ov ? RTW89_BTC_DM_MAXSTEP : dm->dm_step.step_pos;\n\tstart_idx = dm->dm_step.step_ov ? dm->dm_step.step_pos : 0;\n\n\tseq_print_segment(m, \"[dm_steps]\", dm->dm_step.step, len, 6, start_idx,\n\t\t\t  ARRAY_SIZE(dm->dm_step.step));\n}\n\nstatic void _show_dm_info(struct rtw89_dev *rtwdev, struct seq_file *m)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_module *module = &btc->mdinfo;\n\tstruct rtw89_btc_dm *dm = &btc->dm;\n\tstruct rtw89_btc_wl_info *wl = &btc->cx.wl;\n\tstruct rtw89_btc_bt_info *bt = &btc->cx.bt;\n\n\tif (!(dm->coex_info_map & BTC_COEX_INFO_DM))\n\t\treturn;\n\n\tseq_printf(m, \"========== [Mechanism Status %s] ==========\\n\",\n\t\t   (btc->ctrl.manual ? \"(Manual)\" : \"(Auto)\"));\n\n\tseq_printf(m,\n\t\t   \" %-15s : type:%s, reason:%s(), action:%s(), ant_path:%ld, run_cnt:%d\\n\",\n\t\t   \"[status]\",\n\t\t   module->ant.type == BTC_ANT_SHARED ? \"shared\" : \"dedicated\",\n\t\t   steps_to_str(dm->run_reason),\n\t\t   steps_to_str(dm->run_action | BTC_ACT_EXT_BIT),\n\t\t   FIELD_GET(GENMASK(7, 0), dm->set_ant_path),\n\t\t   dm->cnt_dm[BTC_DCNT_RUN]);\n\n\t_show_dm_step(rtwdev, m);\n\n\tseq_printf(m, \" %-15s : wl_only:%d, bt_only:%d, igno_bt:%d, free_run:%d, wl_ps_ctrl:%d, wl_mimo_ps:%d, \",\n\t\t   \"[dm_flag]\", dm->wl_only, dm->bt_only, btc->ctrl.igno_bt,\n\t\t   dm->freerun, btc->lps, dm->wl_mimo_ps);\n\n\tseq_printf(m, \"leak_ap:%d, fw_offload:%s%s\\n\", dm->leak_ap,\n\t\t   (BTC_CX_FW_OFFLOAD ? \"Y\" : \"N\"),\n\t\t   (dm->wl_fw_cx_offload == BTC_CX_FW_OFFLOAD ?\n\t\t    \"\" : \"(Mismatch!!)\"));\n\n\tif (dm->rf_trx_para.wl_tx_power == 0xff)\n\t\tseq_printf(m,\n\t\t\t   \" %-15s : wl_rssi_lvl:%d, para_lvl:%d, wl_tx_pwr:orig, \",\n\t\t\t   \"[trx_ctrl]\", wl->rssi_level, dm->trx_para_level);\n\n\telse\n\t\tseq_printf(m,\n\t\t\t   \" %-15s : wl_rssi_lvl:%d, para_lvl:%d, wl_tx_pwr:%d, \",\n\t\t\t   \"[trx_ctrl]\", wl->rssi_level, dm->trx_para_level,\n\t\t\t   dm->rf_trx_para.wl_tx_power);\n\n\tseq_printf(m,\n\t\t   \"wl_rx_lvl:%d, bt_tx_pwr_dec:%d, bt_rx_lna:%d(%s-tbl), wl_btg_rx:%d\\n\",\n\t\t   dm->rf_trx_para.wl_rx_gain, dm->rf_trx_para.bt_tx_power,\n\t\t   dm->rf_trx_para.bt_rx_gain,\n\t\t   (bt->hi_lna_rx ? \"Hi\" : \"Ori\"), dm->wl_btg_rx);\n\n\tseq_printf(m,\n\t\t   \" %-15s : wl_tx_limit[en:%d/max_t:%dus/max_retry:%d], bt_slot_reg:%d-TU, bt_scan_rx_low_pri:%d\\n\",\n\t\t   \"[dm_ctrl]\", dm->wl_tx_limit.enable, dm->wl_tx_limit.tx_time,\n\t\t   dm->wl_tx_limit.tx_retry, btc->bt_req_len, bt->scan_rx_low_pri);\n}\n\nstatic void _show_error(struct rtw89_dev *rtwdev, struct seq_file *m)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tconst struct rtw89_btc_ver *ver = btc->ver;\n\tstruct rtw89_btc_btf_fwinfo *pfwinfo = &btc->fwinfo;\n\tunion rtw89_btc_fbtc_cysta_info *pcysta;\n\tu32 except_cnt, exception_map;\n\n\tpcysta = &pfwinfo->rpt_fbtc_cysta.finfo;\n\tif (ver->fcxcysta == 2) {\n\t\tpcysta->v2 = pfwinfo->rpt_fbtc_cysta.finfo.v2;\n\t\texcept_cnt = le32_to_cpu(pcysta->v2.except_cnt);\n\t\texception_map = le32_to_cpu(pcysta->v2.exception);\n\t} else if (ver->fcxcysta == 3) {\n\t\tpcysta->v3 = pfwinfo->rpt_fbtc_cysta.finfo.v3;\n\t\texcept_cnt = le32_to_cpu(pcysta->v3.except_cnt);\n\t\texception_map = le32_to_cpu(pcysta->v3.except_map);\n\t} else if (ver->fcxcysta == 4) {\n\t\tpcysta->v4 = pfwinfo->rpt_fbtc_cysta.finfo.v4;\n\t\texcept_cnt = pcysta->v4.except_cnt;\n\t\texception_map = le32_to_cpu(pcysta->v4.except_map);\n\t} else if (ver->fcxcysta == 5) {\n\t\tpcysta->v5 = pfwinfo->rpt_fbtc_cysta.finfo.v5;\n\t\texcept_cnt = pcysta->v5.except_cnt;\n\t\texception_map = le32_to_cpu(pcysta->v5.except_map);\n\t} else {\n\t\treturn;\n\t}\n\n\tif (pfwinfo->event[BTF_EVNT_BUF_OVERFLOW] == 0 && except_cnt == 0 &&\n\t    !pfwinfo->len_mismch && !pfwinfo->fver_mismch)\n\t\treturn;\n\n\tseq_printf(m, \" %-15s : \", \"[error]\");\n\n\tif (pfwinfo->event[BTF_EVNT_BUF_OVERFLOW]) {\n\t\tseq_printf(m,\n\t\t\t   \"overflow-cnt: %d, \",\n\t\t\t   pfwinfo->event[BTF_EVNT_BUF_OVERFLOW]);\n\t}\n\n\tif (pfwinfo->len_mismch) {\n\t\tseq_printf(m,\n\t\t\t   \"len-mismatch: 0x%x, \",\n\t\t\t   pfwinfo->len_mismch);\n\t}\n\n\tif (pfwinfo->fver_mismch) {\n\t\tseq_printf(m,\n\t\t\t   \"fver-mismatch: 0x%x, \",\n\t\t\t   pfwinfo->fver_mismch);\n\t}\n\n\t \n\tif (exception_map || except_cnt) {\n\t\tseq_printf(m,\n\t\t\t   \"exception-type: 0x%x, exception-cnt = %d\",\n\t\t\t   exception_map, except_cnt);\n\t}\n\tseq_puts(m, \"\\n\");\n}\n\nstatic void _show_fbtc_tdma(struct rtw89_dev *rtwdev, struct seq_file *m)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tconst struct rtw89_btc_ver *ver = btc->ver;\n\tstruct rtw89_btc_btf_fwinfo *pfwinfo = &btc->fwinfo;\n\tstruct rtw89_btc_rpt_cmn_info *pcinfo = NULL;\n\tstruct rtw89_btc_fbtc_tdma *t = NULL;\n\n\tpcinfo = &pfwinfo->rpt_fbtc_tdma.cinfo;\n\tif (!pcinfo->valid)\n\t\treturn;\n\n\tif (ver->fcxtdma == 1)\n\t\tt = &pfwinfo->rpt_fbtc_tdma.finfo.v1;\n\telse\n\t\tt = &pfwinfo->rpt_fbtc_tdma.finfo.v3.tdma;\n\n\tseq_printf(m,\n\t\t   \" %-15s : \", \"[tdma_policy]\");\n\tseq_printf(m,\n\t\t   \"type:%d, rx_flow_ctrl:%d, tx_pause:%d, \",\n\t\t   (u32)t->type,\n\t\t   t->rxflctrl, t->txpause);\n\n\tseq_printf(m,\n\t\t   \"wl_toggle_n:%d, leak_n:%d, ext_ctrl:%d, \",\n\t\t   t->wtgle_n, t->leak_n, t->ext_ctrl);\n\n\tseq_printf(m,\n\t\t   \"policy_type:%d\",\n\t\t   (u32)btc->policy_type);\n\n\tseq_puts(m, \"\\n\");\n}\n\nstatic void _show_fbtc_slots(struct rtw89_dev *rtwdev, struct seq_file *m)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_dm *dm = &btc->dm;\n\tstruct rtw89_btc_fbtc_slot *s;\n\tu8 i = 0;\n\n\tfor (i = 0; i < CXST_MAX; i++) {\n\t\ts = &dm->slot_now[i];\n\t\tif (i % 5 == 0)\n\t\t\tseq_printf(m,\n\t\t\t\t   \" %-15s : %5s[%03d/0x%x/%d]\",\n\t\t\t\t   \"[slot_list]\",\n\t\t\t\t   id_to_slot((u32)i),\n\t\t\t\t   s->dur, s->cxtbl, s->cxtype);\n\t\telse\n\t\t\tseq_printf(m,\n\t\t\t\t   \", %5s[%03d/0x%x/%d]\",\n\t\t\t\t   id_to_slot((u32)i),\n\t\t\t\t   s->dur, s->cxtbl, s->cxtype);\n\t\tif (i % 5 == 4)\n\t\t\tseq_puts(m, \"\\n\");\n\t}\n\tseq_puts(m, \"\\n\");\n}\n\nstatic void _show_fbtc_cysta_v2(struct rtw89_dev *rtwdev, struct seq_file *m)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_btf_fwinfo *pfwinfo = &btc->fwinfo;\n\tstruct rtw89_btc_dm *dm = &btc->dm;\n\tstruct rtw89_btc_bt_a2dp_desc *a2dp = &btc->cx.bt.link_info.a2dp_desc;\n\tstruct rtw89_btc_rpt_cmn_info *pcinfo = NULL;\n\tstruct rtw89_btc_fbtc_cysta_v2 *pcysta_le32 = NULL;\n\tunion rtw89_btc_fbtc_rxflct r;\n\tu8 i, cnt = 0, slot_pair;\n\tu16 cycle, c_begin, c_end, store_index;\n\n\tpcinfo = &pfwinfo->rpt_fbtc_cysta.cinfo;\n\tif (!pcinfo->valid)\n\t\treturn;\n\n\tpcysta_le32 = &pfwinfo->rpt_fbtc_cysta.finfo.v2;\n\tseq_printf(m,\n\t\t   \" %-15s : cycle:%d, bcn[all:%d/all_ok:%d/bt:%d/bt_ok:%d]\",\n\t\t   \"[cycle_cnt]\",\n\t\t   le16_to_cpu(pcysta_le32->cycles),\n\t\t   le32_to_cpu(pcysta_le32->bcn_cnt[CXBCN_ALL]),\n\t\t   le32_to_cpu(pcysta_le32->bcn_cnt[CXBCN_ALL_OK]),\n\t\t   le32_to_cpu(pcysta_le32->bcn_cnt[CXBCN_BT_SLOT]),\n\t\t   le32_to_cpu(pcysta_le32->bcn_cnt[CXBCN_BT_OK]));\n\n\tfor (i = 0; i < CXST_MAX; i++) {\n\t\tif (!le32_to_cpu(pcysta_le32->slot_cnt[i]))\n\t\t\tcontinue;\n\t\tseq_printf(m, \", %s:%d\", id_to_slot((u32)i),\n\t\t\t   le32_to_cpu(pcysta_le32->slot_cnt[i]));\n\t}\n\n\tif (dm->tdma_now.rxflctrl) {\n\t\tseq_printf(m, \", leak_rx:%d\",\n\t\t\t   le32_to_cpu(pcysta_le32->leakrx_cnt));\n\t}\n\n\tif (le32_to_cpu(pcysta_le32->collision_cnt)) {\n\t\tseq_printf(m, \", collision:%d\",\n\t\t\t   le32_to_cpu(pcysta_le32->collision_cnt));\n\t}\n\n\tif (le32_to_cpu(pcysta_le32->skip_cnt)) {\n\t\tseq_printf(m, \", skip:%d\",\n\t\t\t   le32_to_cpu(pcysta_le32->skip_cnt));\n\t}\n\tseq_puts(m, \"\\n\");\n\n\tseq_printf(m, \" %-15s : avg_t[wl:%d/bt:%d/lk:%d.%03d]\",\n\t\t   \"[cycle_time]\",\n\t\t   le16_to_cpu(pcysta_le32->tavg_cycle[CXT_WL]),\n\t\t   le16_to_cpu(pcysta_le32->tavg_cycle[CXT_BT]),\n\t\t   le16_to_cpu(pcysta_le32->tavg_lk) / 1000,\n\t\t   le16_to_cpu(pcysta_le32->tavg_lk) % 1000);\n\tseq_printf(m, \", max_t[wl:%d/bt:%d/lk:%d.%03d]\",\n\t\t   le16_to_cpu(pcysta_le32->tmax_cycle[CXT_WL]),\n\t\t   le16_to_cpu(pcysta_le32->tmax_cycle[CXT_BT]),\n\t\t   le16_to_cpu(pcysta_le32->tmax_lk) / 1000,\n\t\t   le16_to_cpu(pcysta_le32->tmax_lk) % 1000);\n\tseq_printf(m, \", maxdiff_t[wl:%d/bt:%d]\\n\",\n\t\t   le16_to_cpu(pcysta_le32->tmaxdiff_cycle[CXT_WL]),\n\t\t   le16_to_cpu(pcysta_le32->tmaxdiff_cycle[CXT_BT]));\n\n\tif (le16_to_cpu(pcysta_le32->cycles) <= 1)\n\t\treturn;\n\n\t \n\tslot_pair = BTC_CYCLE_SLOT_MAX / 2;\n\n\tif (le16_to_cpu(pcysta_le32->cycles) <= slot_pair)\n\t\tc_begin = 1;\n\telse\n\t\tc_begin = le16_to_cpu(pcysta_le32->cycles) - slot_pair + 1;\n\n\tc_end = le16_to_cpu(pcysta_le32->cycles);\n\n\tfor (cycle = c_begin; cycle <= c_end; cycle++) {\n\t\tcnt++;\n\t\tstore_index = ((cycle - 1) % slot_pair) * 2;\n\n\t\tif (cnt % (BTC_CYCLE_SLOT_MAX / 4) == 1)\n\t\t\tseq_printf(m,\n\t\t\t\t   \" %-15s : ->b%02d->w%02d\", \"[cycle_step]\",\n\t\t\t\t   le16_to_cpu(pcysta_le32->tslot_cycle[store_index]),\n\t\t\t\t   le16_to_cpu(pcysta_le32->tslot_cycle[store_index + 1]));\n\t\telse\n\t\t\tseq_printf(m,\n\t\t\t\t   \"->b%02d->w%02d\",\n\t\t\t\t   le16_to_cpu(pcysta_le32->tslot_cycle[store_index]),\n\t\t\t\t   le16_to_cpu(pcysta_le32->tslot_cycle[store_index + 1]));\n\t\tif (cnt % (BTC_CYCLE_SLOT_MAX / 4) == 0 || cnt == c_end)\n\t\t\tseq_puts(m, \"\\n\");\n\t}\n\n\tif (a2dp->exist) {\n\t\tseq_printf(m,\n\t\t\t   \" %-15s : a2dp_ept:%d, a2dp_late:%d\",\n\t\t\t   \"[a2dp_t_sta]\",\n\t\t\t   le16_to_cpu(pcysta_le32->a2dpept),\n\t\t\t   le16_to_cpu(pcysta_le32->a2dpeptto));\n\n\t\tseq_printf(m,\n\t\t\t   \", avg_t:%d, max_t:%d\",\n\t\t\t   le16_to_cpu(pcysta_le32->tavg_a2dpept),\n\t\t\t   le16_to_cpu(pcysta_le32->tmax_a2dpept));\n\t\tr.val = dm->tdma_now.rxflctrl;\n\n\t\tif (r.type && r.tgln_n) {\n\t\t\tseq_printf(m,\n\t\t\t\t   \", cycle[PSTDMA:%d/TDMA:%d], \",\n\t\t\t\t   le16_to_cpu(pcysta_le32->cycles_a2dp[CXT_FLCTRL_ON]),\n\t\t\t\t   le16_to_cpu(pcysta_le32->cycles_a2dp[CXT_FLCTRL_OFF]));\n\n\t\t\tseq_printf(m,\n\t\t\t\t   \"avg_t[PSTDMA:%d/TDMA:%d], \",\n\t\t\t\t   le16_to_cpu(pcysta_le32->tavg_a2dp[CXT_FLCTRL_ON]),\n\t\t\t\t   le16_to_cpu(pcysta_le32->tavg_a2dp[CXT_FLCTRL_OFF]));\n\n\t\t\tseq_printf(m,\n\t\t\t\t   \"max_t[PSTDMA:%d/TDMA:%d]\",\n\t\t\t\t   le16_to_cpu(pcysta_le32->tmax_a2dp[CXT_FLCTRL_ON]),\n\t\t\t\t   le16_to_cpu(pcysta_le32->tmax_a2dp[CXT_FLCTRL_OFF]));\n\t\t}\n\t\tseq_puts(m, \"\\n\");\n\t}\n}\n\nstatic void _show_fbtc_cysta_v3(struct rtw89_dev *rtwdev, struct seq_file *m)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_bt_a2dp_desc *a2dp = &btc->cx.bt.link_info.a2dp_desc;\n\tstruct rtw89_btc_btf_fwinfo *pfwinfo = &btc->fwinfo;\n\tstruct rtw89_btc_dm *dm = &btc->dm;\n\tstruct rtw89_btc_fbtc_a2dp_trx_stat *a2dp_trx;\n\tstruct rtw89_btc_fbtc_cysta_v3 *pcysta;\n\tstruct rtw89_btc_rpt_cmn_info *pcinfo;\n\tu8 i, cnt = 0, slot_pair, divide_cnt;\n\tu16 cycle, c_begin, c_end, store_index;\n\n\tpcinfo = &pfwinfo->rpt_fbtc_cysta.cinfo;\n\tif (!pcinfo->valid)\n\t\treturn;\n\n\tpcysta = &pfwinfo->rpt_fbtc_cysta.finfo.v3;\n\tseq_printf(m,\n\t\t   \" %-15s : cycle:%d, bcn[all:%d/all_ok:%d/bt:%d/bt_ok:%d]\",\n\t\t   \"[cycle_cnt]\",\n\t\t   le16_to_cpu(pcysta->cycles),\n\t\t   le32_to_cpu(pcysta->bcn_cnt[CXBCN_ALL]),\n\t\t   le32_to_cpu(pcysta->bcn_cnt[CXBCN_ALL_OK]),\n\t\t   le32_to_cpu(pcysta->bcn_cnt[CXBCN_BT_SLOT]),\n\t\t   le32_to_cpu(pcysta->bcn_cnt[CXBCN_BT_OK]));\n\n\tfor (i = 0; i < CXST_MAX; i++) {\n\t\tif (!le32_to_cpu(pcysta->slot_cnt[i]))\n\t\t\tcontinue;\n\n\t\tseq_printf(m, \", %s:%d\", id_to_slot(i),\n\t\t\t   le32_to_cpu(pcysta->slot_cnt[i]));\n\t}\n\n\tif (dm->tdma_now.rxflctrl)\n\t\tseq_printf(m, \", leak_rx:%d\", le32_to_cpu(pcysta->leak_slot.cnt_rximr));\n\n\tif (le32_to_cpu(pcysta->collision_cnt))\n\t\tseq_printf(m, \", collision:%d\", le32_to_cpu(pcysta->collision_cnt));\n\n\tif (le32_to_cpu(pcysta->skip_cnt))\n\t\tseq_printf(m, \", skip:%d\", le32_to_cpu(pcysta->skip_cnt));\n\n\tseq_puts(m, \"\\n\");\n\n\tseq_printf(m, \" %-15s : avg_t[wl:%d/bt:%d/lk:%d.%03d]\",\n\t\t   \"[cycle_time]\",\n\t\t   le16_to_cpu(pcysta->cycle_time.tavg[CXT_WL]),\n\t\t   le16_to_cpu(pcysta->cycle_time.tavg[CXT_BT]),\n\t\t   le16_to_cpu(pcysta->leak_slot.tavg) / 1000,\n\t\t   le16_to_cpu(pcysta->leak_slot.tavg) % 1000);\n\tseq_printf(m,\n\t\t   \", max_t[wl:%d/bt:%d/lk:%d.%03d]\",\n\t\t   le16_to_cpu(pcysta->cycle_time.tmax[CXT_WL]),\n\t\t   le16_to_cpu(pcysta->cycle_time.tmax[CXT_BT]),\n\t\t   le16_to_cpu(pcysta->leak_slot.tmax) / 1000,\n\t\t   le16_to_cpu(pcysta->leak_slot.tmax) % 1000);\n\tseq_printf(m,\n\t\t   \", maxdiff_t[wl:%d/bt:%d]\\n\",\n\t\t   le16_to_cpu(pcysta->cycle_time.tmaxdiff[CXT_WL]),\n\t\t   le16_to_cpu(pcysta->cycle_time.tmaxdiff[CXT_BT]));\n\n\tcycle = le16_to_cpu(pcysta->cycles);\n\tif (cycle <= 1)\n\t\treturn;\n\n\t \n\tslot_pair = BTC_CYCLE_SLOT_MAX / 2;\n\n\tif (cycle <= slot_pair)\n\t\tc_begin = 1;\n\telse\n\t\tc_begin = cycle - slot_pair + 1;\n\n\tc_end = cycle;\n\n\tif (a2dp->exist)\n\t\tdivide_cnt = 3;\n\telse\n\t\tdivide_cnt = BTC_CYCLE_SLOT_MAX / 4;\n\n\tfor (cycle = c_begin; cycle <= c_end; cycle++) {\n\t\tcnt++;\n\t\tstore_index = ((cycle - 1) % slot_pair) * 2;\n\n\t\tif (cnt % divide_cnt == 1)\n\t\t\tseq_printf(m, \" %-15s : \", \"[cycle_step]\");\n\n\t\tseq_printf(m, \"->b%02d\",\n\t\t\t   le16_to_cpu(pcysta->slot_step_time[store_index]));\n\t\tif (a2dp->exist) {\n\t\t\ta2dp_trx = &pcysta->a2dp_trx[store_index];\n\t\t\tseq_printf(m, \"(%d/%d/%dM/%d/%d/%d)\",\n\t\t\t\t   a2dp_trx->empty_cnt,\n\t\t\t\t   a2dp_trx->retry_cnt,\n\t\t\t\t   a2dp_trx->tx_rate ? 3 : 2,\n\t\t\t\t   a2dp_trx->tx_cnt,\n\t\t\t\t   a2dp_trx->ack_cnt,\n\t\t\t\t   a2dp_trx->nack_cnt);\n\t\t}\n\t\tseq_printf(m, \"->w%02d\",\n\t\t\t   le16_to_cpu(pcysta->slot_step_time[store_index + 1]));\n\t\tif (a2dp->exist) {\n\t\t\ta2dp_trx = &pcysta->a2dp_trx[store_index + 1];\n\t\t\tseq_printf(m, \"(%d/%d/%dM/%d/%d/%d)\",\n\t\t\t\t   a2dp_trx->empty_cnt,\n\t\t\t\t   a2dp_trx->retry_cnt,\n\t\t\t\t   a2dp_trx->tx_rate ? 3 : 2,\n\t\t\t\t   a2dp_trx->tx_cnt,\n\t\t\t\t   a2dp_trx->ack_cnt,\n\t\t\t\t   a2dp_trx->nack_cnt);\n\t\t}\n\t\tif (cnt % divide_cnt == 0 || cnt == c_end)\n\t\t\tseq_puts(m, \"\\n\");\n\t}\n\n\tif (a2dp->exist) {\n\t\tseq_printf(m, \" %-15s : a2dp_ept:%d, a2dp_late:%d\",\n\t\t\t   \"[a2dp_t_sta]\",\n\t\t\t   le16_to_cpu(pcysta->a2dp_ept.cnt),\n\t\t\t   le16_to_cpu(pcysta->a2dp_ept.cnt_timeout));\n\n\t\tseq_printf(m, \", avg_t:%d, max_t:%d\",\n\t\t\t   le16_to_cpu(pcysta->a2dp_ept.tavg),\n\t\t\t   le16_to_cpu(pcysta->a2dp_ept.tmax));\n\n\t\tseq_puts(m, \"\\n\");\n\t}\n}\n\nstatic void _show_fbtc_cysta_v4(struct rtw89_dev *rtwdev, struct seq_file *m)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_bt_a2dp_desc *a2dp = &btc->cx.bt.link_info.a2dp_desc;\n\tstruct rtw89_btc_btf_fwinfo *pfwinfo = &btc->fwinfo;\n\tstruct rtw89_btc_dm *dm = &btc->dm;\n\tstruct rtw89_btc_fbtc_a2dp_trx_stat_v4 *a2dp_trx;\n\tstruct rtw89_btc_fbtc_cysta_v4 *pcysta;\n\tstruct rtw89_btc_rpt_cmn_info *pcinfo;\n\tu8 i, cnt = 0, slot_pair, divide_cnt;\n\tu16 cycle, c_begin, c_end, store_index;\n\n\tpcinfo = &pfwinfo->rpt_fbtc_cysta.cinfo;\n\tif (!pcinfo->valid)\n\t\treturn;\n\n\tpcysta = &pfwinfo->rpt_fbtc_cysta.finfo.v4;\n\tseq_printf(m,\n\t\t   \" %-15s : cycle:%d, bcn[all:%d/all_ok:%d/bt:%d/bt_ok:%d]\",\n\t\t   \"[cycle_cnt]\",\n\t\t   le16_to_cpu(pcysta->cycles),\n\t\t   le16_to_cpu(pcysta->bcn_cnt[CXBCN_ALL]),\n\t\t   le16_to_cpu(pcysta->bcn_cnt[CXBCN_ALL_OK]),\n\t\t   le16_to_cpu(pcysta->bcn_cnt[CXBCN_BT_SLOT]),\n\t\t   le16_to_cpu(pcysta->bcn_cnt[CXBCN_BT_OK]));\n\n\tfor (i = 0; i < CXST_MAX; i++) {\n\t\tif (!le16_to_cpu(pcysta->slot_cnt[i]))\n\t\t\tcontinue;\n\n\t\tseq_printf(m, \", %s:%d\", id_to_slot(i),\n\t\t\t   le16_to_cpu(pcysta->slot_cnt[i]));\n\t}\n\n\tif (dm->tdma_now.rxflctrl)\n\t\tseq_printf(m, \", leak_rx:%d\",\n\t\t\t   le32_to_cpu(pcysta->leak_slot.cnt_rximr));\n\n\tif (pcysta->collision_cnt)\n\t\tseq_printf(m, \", collision:%d\", pcysta->collision_cnt);\n\n\tif (le16_to_cpu(pcysta->skip_cnt))\n\t\tseq_printf(m, \", skip:%d\",\n\t\t\t   le16_to_cpu(pcysta->skip_cnt));\n\n\tseq_puts(m, \"\\n\");\n\n\tseq_printf(m, \" %-15s : avg_t[wl:%d/bt:%d/lk:%d.%03d]\",\n\t\t   \"[cycle_time]\",\n\t\t   le16_to_cpu(pcysta->cycle_time.tavg[CXT_WL]),\n\t\t   le16_to_cpu(pcysta->cycle_time.tavg[CXT_BT]),\n\t\t   le16_to_cpu(pcysta->leak_slot.tavg) / 1000,\n\t\t   le16_to_cpu(pcysta->leak_slot.tavg) % 1000);\n\tseq_printf(m,\n\t\t   \", max_t[wl:%d/bt:%d/lk:%d.%03d]\",\n\t\t   le16_to_cpu(pcysta->cycle_time.tmax[CXT_WL]),\n\t\t   le16_to_cpu(pcysta->cycle_time.tmax[CXT_BT]),\n\t\t   le16_to_cpu(pcysta->leak_slot.tmax) / 1000,\n\t\t   le16_to_cpu(pcysta->leak_slot.tmax) % 1000);\n\tseq_printf(m,\n\t\t   \", maxdiff_t[wl:%d/bt:%d]\\n\",\n\t\t   le16_to_cpu(pcysta->cycle_time.tmaxdiff[CXT_WL]),\n\t\t   le16_to_cpu(pcysta->cycle_time.tmaxdiff[CXT_BT]));\n\n\tcycle = le16_to_cpu(pcysta->cycles);\n\tif (cycle <= 1)\n\t\treturn;\n\n\t \n\tslot_pair = BTC_CYCLE_SLOT_MAX / 2;\n\n\tif (cycle <= slot_pair)\n\t\tc_begin = 1;\n\telse\n\t\tc_begin = cycle - slot_pair + 1;\n\n\tc_end = cycle;\n\n\tif (a2dp->exist)\n\t\tdivide_cnt = 3;\n\telse\n\t\tdivide_cnt = BTC_CYCLE_SLOT_MAX / 4;\n\n\tfor (cycle = c_begin; cycle <= c_end; cycle++) {\n\t\tcnt++;\n\t\tstore_index = ((cycle - 1) % slot_pair) * 2;\n\n\t\tif (cnt % divide_cnt == 1)\n\t\t\tseq_printf(m, \" %-15s : \", \"[cycle_step]\");\n\n\t\tseq_printf(m, \"->b%02d\",\n\t\t\t   le16_to_cpu(pcysta->slot_step_time[store_index]));\n\t\tif (a2dp->exist) {\n\t\t\ta2dp_trx = &pcysta->a2dp_trx[store_index];\n\t\t\tseq_printf(m, \"(%d/%d/%dM/%d/%d/%d)\",\n\t\t\t\t   a2dp_trx->empty_cnt,\n\t\t\t\t   a2dp_trx->retry_cnt,\n\t\t\t\t   a2dp_trx->tx_rate ? 3 : 2,\n\t\t\t\t   a2dp_trx->tx_cnt,\n\t\t\t\t   a2dp_trx->ack_cnt,\n\t\t\t\t   a2dp_trx->nack_cnt);\n\t\t}\n\t\tseq_printf(m, \"->w%02d\",\n\t\t\t   le16_to_cpu(pcysta->slot_step_time[store_index + 1]));\n\t\tif (a2dp->exist) {\n\t\t\ta2dp_trx = &pcysta->a2dp_trx[store_index + 1];\n\t\t\tseq_printf(m, \"(%d/%d/%dM/%d/%d/%d)\",\n\t\t\t\t   a2dp_trx->empty_cnt,\n\t\t\t\t   a2dp_trx->retry_cnt,\n\t\t\t\t   a2dp_trx->tx_rate ? 3 : 2,\n\t\t\t\t   a2dp_trx->tx_cnt,\n\t\t\t\t   a2dp_trx->ack_cnt,\n\t\t\t\t   a2dp_trx->nack_cnt);\n\t\t}\n\t\tif (cnt % divide_cnt == 0 || cnt == c_end)\n\t\t\tseq_puts(m, \"\\n\");\n\t}\n\n\tif (a2dp->exist) {\n\t\tseq_printf(m, \" %-15s : a2dp_ept:%d, a2dp_late:%d\",\n\t\t\t   \"[a2dp_t_sta]\",\n\t\t\t   le16_to_cpu(pcysta->a2dp_ept.cnt),\n\t\t\t   le16_to_cpu(pcysta->a2dp_ept.cnt_timeout));\n\n\t\tseq_printf(m, \", avg_t:%d, max_t:%d\",\n\t\t\t   le16_to_cpu(pcysta->a2dp_ept.tavg),\n\t\t\t   le16_to_cpu(pcysta->a2dp_ept.tmax));\n\n\t\tseq_puts(m, \"\\n\");\n\t}\n}\n\nstatic void _show_fbtc_cysta_v5(struct rtw89_dev *rtwdev, struct seq_file *m)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_bt_a2dp_desc *a2dp = &btc->cx.bt.link_info.a2dp_desc;\n\tstruct rtw89_btc_btf_fwinfo *pfwinfo = &btc->fwinfo;\n\tstruct rtw89_btc_dm *dm = &btc->dm;\n\tstruct rtw89_btc_fbtc_a2dp_trx_stat_v4 *a2dp_trx;\n\tstruct rtw89_btc_fbtc_cysta_v5 *pcysta;\n\tstruct rtw89_btc_rpt_cmn_info *pcinfo;\n\tu8 i, cnt = 0, slot_pair, divide_cnt;\n\tu16 cycle, c_begin, c_end, store_index;\n\n\tpcinfo = &pfwinfo->rpt_fbtc_cysta.cinfo;\n\tif (!pcinfo->valid)\n\t\treturn;\n\n\tpcysta = &pfwinfo->rpt_fbtc_cysta.finfo.v5;\n\tseq_printf(m,\n\t\t   \" %-15s : cycle:%d, bcn[all:%d/all_ok:%d/bt:%d/bt_ok:%d]\",\n\t\t   \"[cycle_cnt]\",\n\t\t   le16_to_cpu(pcysta->cycles),\n\t\t   le16_to_cpu(pcysta->bcn_cnt[CXBCN_ALL]),\n\t\t   le16_to_cpu(pcysta->bcn_cnt[CXBCN_ALL_OK]),\n\t\t   le16_to_cpu(pcysta->bcn_cnt[CXBCN_BT_SLOT]),\n\t\t   le16_to_cpu(pcysta->bcn_cnt[CXBCN_BT_OK]));\n\n\tfor (i = 0; i < CXST_MAX; i++) {\n\t\tif (!le16_to_cpu(pcysta->slot_cnt[i]))\n\t\t\tcontinue;\n\n\t\tseq_printf(m, \", %s:%d\", id_to_slot(i),\n\t\t\t   le16_to_cpu(pcysta->slot_cnt[i]));\n\t}\n\n\tif (dm->tdma_now.rxflctrl)\n\t\tseq_printf(m, \", leak_rx:%d\",\n\t\t\t   le32_to_cpu(pcysta->leak_slot.cnt_rximr));\n\n\tif (pcysta->collision_cnt)\n\t\tseq_printf(m, \", collision:%d\", pcysta->collision_cnt);\n\n\tif (le16_to_cpu(pcysta->skip_cnt))\n\t\tseq_printf(m, \", skip:%d\",\n\t\t\t   le16_to_cpu(pcysta->skip_cnt));\n\n\tseq_puts(m, \"\\n\");\n\n\tseq_printf(m, \" %-15s : avg_t[wl:%d/bt:%d/lk:%d.%03d]\",\n\t\t   \"[cycle_time]\",\n\t\t   le16_to_cpu(pcysta->cycle_time.tavg[CXT_WL]),\n\t\t   le16_to_cpu(pcysta->cycle_time.tavg[CXT_BT]),\n\t\t   le16_to_cpu(pcysta->leak_slot.tavg) / 1000,\n\t\t   le16_to_cpu(pcysta->leak_slot.tavg) % 1000);\n\tseq_printf(m,\n\t\t   \", max_t[wl:%d/bt:%d/lk:%d.%03d]\\n\",\n\t\t   le16_to_cpu(pcysta->cycle_time.tmax[CXT_WL]),\n\t\t   le16_to_cpu(pcysta->cycle_time.tmax[CXT_BT]),\n\t\t   le16_to_cpu(pcysta->leak_slot.tmax) / 1000,\n\t\t   le16_to_cpu(pcysta->leak_slot.tmax) % 1000);\n\n\tcycle = le16_to_cpu(pcysta->cycles);\n\tif (cycle <= 1)\n\t\treturn;\n\n\t \n\tslot_pair = BTC_CYCLE_SLOT_MAX / 2;\n\n\tif (cycle <= slot_pair)\n\t\tc_begin = 1;\n\telse\n\t\tc_begin = cycle - slot_pair + 1;\n\n\tc_end = cycle;\n\n\tif (a2dp->exist)\n\t\tdivide_cnt = 3;\n\telse\n\t\tdivide_cnt = BTC_CYCLE_SLOT_MAX / 4;\n\n\tif (c_begin > c_end)\n\t\treturn;\n\n\tfor (cycle = c_begin; cycle <= c_end; cycle++) {\n\t\tcnt++;\n\t\tstore_index = ((cycle - 1) % slot_pair) * 2;\n\n\t\tif (cnt % divide_cnt == 1)\n\t\t\tseq_printf(m, \" %-15s : \", \"[cycle_step]\");\n\n\t\tseq_printf(m, \"->b%02d\",\n\t\t\t   le16_to_cpu(pcysta->slot_step_time[store_index]));\n\t\tif (a2dp->exist) {\n\t\t\ta2dp_trx = &pcysta->a2dp_trx[store_index];\n\t\t\tseq_printf(m, \"(%d/%d/%dM/%d/%d/%d)\",\n\t\t\t\t   a2dp_trx->empty_cnt,\n\t\t\t\t   a2dp_trx->retry_cnt,\n\t\t\t\t   a2dp_trx->tx_rate ? 3 : 2,\n\t\t\t\t   a2dp_trx->tx_cnt,\n\t\t\t\t   a2dp_trx->ack_cnt,\n\t\t\t\t   a2dp_trx->nack_cnt);\n\t\t}\n\t\tseq_printf(m, \"->w%02d\",\n\t\t\t   le16_to_cpu(pcysta->slot_step_time[store_index + 1]));\n\t\tif (a2dp->exist) {\n\t\t\ta2dp_trx = &pcysta->a2dp_trx[store_index + 1];\n\t\t\tseq_printf(m, \"(%d/%d/%dM/%d/%d/%d)\",\n\t\t\t\t   a2dp_trx->empty_cnt,\n\t\t\t\t   a2dp_trx->retry_cnt,\n\t\t\t\t   a2dp_trx->tx_rate ? 3 : 2,\n\t\t\t\t   a2dp_trx->tx_cnt,\n\t\t\t\t   a2dp_trx->ack_cnt,\n\t\t\t\t   a2dp_trx->nack_cnt);\n\t\t}\n\t\tif (cnt % divide_cnt == 0 || cnt == c_end)\n\t\t\tseq_puts(m, \"\\n\");\n\t}\n\n\tif (a2dp->exist) {\n\t\tseq_printf(m, \" %-15s : a2dp_ept:%d, a2dp_late:%d\",\n\t\t\t   \"[a2dp_t_sta]\",\n\t\t\t   le16_to_cpu(pcysta->a2dp_ept.cnt),\n\t\t\t   le16_to_cpu(pcysta->a2dp_ept.cnt_timeout));\n\n\t\tseq_printf(m, \", avg_t:%d, max_t:%d\",\n\t\t\t   le16_to_cpu(pcysta->a2dp_ept.tavg),\n\t\t\t   le16_to_cpu(pcysta->a2dp_ept.tmax));\n\n\t\tseq_puts(m, \"\\n\");\n\t}\n}\n\nstatic void _show_fbtc_nullsta(struct rtw89_dev *rtwdev, struct seq_file *m)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tconst struct rtw89_btc_ver *ver = btc->ver;\n\tstruct rtw89_btc_btf_fwinfo *pfwinfo = &btc->fwinfo;\n\tstruct rtw89_btc_rpt_cmn_info *pcinfo;\n\tunion rtw89_btc_fbtc_cynullsta_info *ns;\n\tu8 i = 0;\n\n\tif (!btc->dm.tdma_now.rxflctrl)\n\t\treturn;\n\n\tpcinfo = &pfwinfo->rpt_fbtc_nullsta.cinfo;\n\tif (!pcinfo->valid)\n\t\treturn;\n\n\tns = &pfwinfo->rpt_fbtc_nullsta.finfo;\n\tif (ver->fcxnullsta == 1) {\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tseq_printf(m, \" %-15s : \", \"[NULL-STA]\");\n\t\t\tseq_printf(m, \"null-%d\", i);\n\t\t\tseq_printf(m, \"[ok:%d/\",\n\t\t\t\t   le32_to_cpu(ns->v1.result[i][1]));\n\t\t\tseq_printf(m, \"fail:%d/\",\n\t\t\t\t   le32_to_cpu(ns->v1.result[i][0]));\n\t\t\tseq_printf(m, \"on_time:%d/\",\n\t\t\t\t   le32_to_cpu(ns->v1.result[i][2]));\n\t\t\tseq_printf(m, \"retry:%d/\",\n\t\t\t\t   le32_to_cpu(ns->v1.result[i][3]));\n\t\t\tseq_printf(m, \"avg_t:%d.%03d/\",\n\t\t\t\t   le32_to_cpu(ns->v1.avg_t[i]) / 1000,\n\t\t\t\t   le32_to_cpu(ns->v1.avg_t[i]) % 1000);\n\t\t\tseq_printf(m, \"max_t:%d.%03d]\\n\",\n\t\t\t\t   le32_to_cpu(ns->v1.max_t[i]) / 1000,\n\t\t\t\t   le32_to_cpu(ns->v1.max_t[i]) % 1000);\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tseq_printf(m, \" %-15s : \", \"[NULL-STA]\");\n\t\t\tseq_printf(m, \"null-%d\", i);\n\t\t\tseq_printf(m, \"[Tx:%d/\",\n\t\t\t\t   le32_to_cpu(ns->v2.result[i][4]));\n\t\t\tseq_printf(m, \"[ok:%d/\",\n\t\t\t\t   le32_to_cpu(ns->v2.result[i][1]));\n\t\t\tseq_printf(m, \"fail:%d/\",\n\t\t\t\t   le32_to_cpu(ns->v2.result[i][0]));\n\t\t\tseq_printf(m, \"on_time:%d/\",\n\t\t\t\t   le32_to_cpu(ns->v2.result[i][2]));\n\t\t\tseq_printf(m, \"retry:%d/\",\n\t\t\t\t   le32_to_cpu(ns->v2.result[i][3]));\n\t\t\tseq_printf(m, \"avg_t:%d.%03d/\",\n\t\t\t\t   le32_to_cpu(ns->v2.avg_t[i]) / 1000,\n\t\t\t\t   le32_to_cpu(ns->v2.avg_t[i]) % 1000);\n\t\t\tseq_printf(m, \"max_t:%d.%03d]\\n\",\n\t\t\t\t   le32_to_cpu(ns->v2.max_t[i]) / 1000,\n\t\t\t\t   le32_to_cpu(ns->v2.max_t[i]) % 1000);\n\t\t}\n\t}\n}\n\nstatic void _show_fbtc_step_v2(struct rtw89_dev *rtwdev, struct seq_file *m)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_btf_fwinfo *pfwinfo = &btc->fwinfo;\n\tstruct rtw89_btc_rpt_cmn_info *pcinfo = NULL;\n\tstruct rtw89_btc_fbtc_steps_v2 *pstep = NULL;\n\tu8 type, val, cnt = 0, state = 0;\n\tbool outloop = false;\n\tu16 i, diff_t, n_start = 0, n_stop = 0;\n\tu16 pos_old, pos_new;\n\n\tpcinfo = &pfwinfo->rpt_fbtc_step.cinfo;\n\tif (!pcinfo->valid)\n\t\treturn;\n\n\tpstep = &pfwinfo->rpt_fbtc_step.finfo.v2;\n\tpos_old = le16_to_cpu(pstep->pos_old);\n\tpos_new = le16_to_cpu(pstep->pos_new);\n\n\tif (pcinfo->req_fver != pstep->fver)\n\t\treturn;\n\n\t \n\tdo {\n\t\tswitch (state) {\n\t\tcase 0:\n\t\t\tn_start = pos_old;\n\t\t\tif (pos_new >=  pos_old)\n\t\t\t\tn_stop = pos_new;\n\t\t\telse\n\t\t\t\tn_stop = btc->ctrl.trace_step - 1;\n\n\t\t\tstate = 1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tfor (i = n_start; i <= n_stop; i++) {\n\t\t\t\ttype = pstep->step[i].type;\n\t\t\t\tval = pstep->step[i].val;\n\t\t\t\tdiff_t = le16_to_cpu(pstep->step[i].difft);\n\n\t\t\t\tif (type == CXSTEP_NONE || type >= CXSTEP_MAX)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif (cnt % 10 == 0)\n\t\t\t\t\tseq_printf(m, \" %-15s : \", \"[steps]\");\n\n\t\t\t\tseq_printf(m, \"-> %s(%02d)(%02d)\",\n\t\t\t\t\t   (type == CXSTEP_SLOT ? \"SLT\" :\n\t\t\t\t\t    \"EVT\"), (u32)val, diff_t);\n\t\t\t\tif (cnt % 10 == 9)\n\t\t\t\t\tseq_puts(m, \"\\n\");\n\t\t\t\tcnt++;\n\t\t\t}\n\n\t\t\tstate = 2;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (pos_new <  pos_old && n_start != 0) {\n\t\t\t\tn_start = 0;\n\t\t\t\tn_stop = pos_new;\n\t\t\t\tstate = 1;\n\t\t\t} else {\n\t\t\t\toutloop = true;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t} while (!outloop);\n}\n\nstatic void _show_fbtc_step_v3(struct rtw89_dev *rtwdev, struct seq_file *m)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_btf_fwinfo *pfwinfo = &btc->fwinfo;\n\tstruct rtw89_btc_rpt_cmn_info *pcinfo;\n\tstruct rtw89_btc_fbtc_steps_v3 *pstep;\n\tu32 i, n_begin, n_end, array_idx, cnt = 0;\n\tu8 type, val;\n\tu16 diff_t;\n\n\tif ((pfwinfo->rpt_en_map &\n\t     rtw89_btc_fw_rpt_ver(rtwdev, RPT_EN_FW_STEP_INFO)) == 0)\n\t\treturn;\n\n\tpcinfo = &pfwinfo->rpt_fbtc_step.cinfo;\n\tif (!pcinfo->valid)\n\t\treturn;\n\n\tpstep = &pfwinfo->rpt_fbtc_step.finfo.v3;\n\tif (pcinfo->req_fver != pstep->fver)\n\t\treturn;\n\n\tif (le32_to_cpu(pstep->cnt) <= FCXDEF_STEP)\n\t\tn_begin = 1;\n\telse\n\t\tn_begin = le32_to_cpu(pstep->cnt) - FCXDEF_STEP + 1;\n\n\tn_end = le32_to_cpu(pstep->cnt);\n\n\tif (n_begin > n_end)\n\t\treturn;\n\n\t \n\tfor (i = n_begin; i <= n_end; i++) {\n\t\tarray_idx = (i - 1) % FCXDEF_STEP;\n\t\ttype = pstep->step[array_idx].type;\n\t\tval = pstep->step[array_idx].val;\n\t\tdiff_t = le16_to_cpu(pstep->step[array_idx].difft);\n\n\t\tif (type == CXSTEP_NONE || type >= CXSTEP_MAX)\n\t\t\tcontinue;\n\n\t\tif (cnt % 10 == 0)\n\t\t\tseq_printf(m, \" %-15s : \", \"[steps]\");\n\n\t\tseq_printf(m, \"-> %s(%02d)\",\n\t\t\t   (type == CXSTEP_SLOT ?\n\t\t\t    id_to_slot((u32)val) :\n\t\t\t    id_to_evt((u32)val)), diff_t);\n\n\t\tif (cnt % 10 == 9)\n\t\t\tseq_puts(m, \"\\n\");\n\n\t\tcnt++;\n\t}\n}\n\nstatic void _show_fw_dm_msg(struct rtw89_dev *rtwdev, struct seq_file *m)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tconst struct rtw89_btc_ver *ver = btc->ver;\n\n\tif (!(btc->dm.coex_info_map & BTC_COEX_INFO_DM))\n\t\treturn;\n\n\t_show_error(rtwdev, m);\n\t_show_fbtc_tdma(rtwdev, m);\n\t_show_fbtc_slots(rtwdev, m);\n\n\tif (ver->fcxcysta == 2)\n\t\t_show_fbtc_cysta_v2(rtwdev, m);\n\telse if (ver->fcxcysta == 3)\n\t\t_show_fbtc_cysta_v3(rtwdev, m);\n\telse if (ver->fcxcysta == 4)\n\t\t_show_fbtc_cysta_v4(rtwdev, m);\n\telse if (ver->fcxcysta == 5)\n\t\t_show_fbtc_cysta_v5(rtwdev, m);\n\n\t_show_fbtc_nullsta(rtwdev, m);\n\n\tif (ver->fcxstep == 2)\n\t\t_show_fbtc_step_v2(rtwdev, m);\n\telse if (ver->fcxstep == 3)\n\t\t_show_fbtc_step_v3(rtwdev, m);\n\n}\n\nstatic void _get_gnt(struct rtw89_dev *rtwdev, struct rtw89_mac_ax_coex_gnt *gnt_cfg)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tstruct rtw89_mac_ax_gnt *gnt;\n\tu32 val, status;\n\n\tif (chip->chip_id == RTL8852A || chip->chip_id == RTL8852B) {\n\t\trtw89_mac_read_lte(rtwdev, R_AX_LTE_SW_CFG_1, &val);\n\t\trtw89_mac_read_lte(rtwdev, R_AX_GNT_VAL, &status);\n\n\t\tgnt = &gnt_cfg->band[0];\n\t\tgnt->gnt_bt_sw_en = !!(val & B_AX_GNT_BT_RFC_S0_SW_CTRL);\n\t\tgnt->gnt_bt = !!(status & B_AX_GNT_BT_RFC_S0_STA);\n\t\tgnt->gnt_wl_sw_en = !!(val & B_AX_GNT_WL_RFC_S0_SW_CTRL);\n\t\tgnt->gnt_wl = !!(status & B_AX_GNT_WL_RFC_S0_STA);\n\n\t\tgnt = &gnt_cfg->band[1];\n\t\tgnt->gnt_bt_sw_en = !!(val & B_AX_GNT_BT_RFC_S1_SW_CTRL);\n\t\tgnt->gnt_bt = !!(status & B_AX_GNT_BT_RFC_S1_STA);\n\t\tgnt->gnt_wl_sw_en = !!(val & B_AX_GNT_WL_RFC_S1_SW_CTRL);\n\t\tgnt->gnt_wl = !!(status & B_AX_GNT_WL_RFC_S1_STA);\n\t} else if (chip->chip_id == RTL8852C) {\n\t\tval = rtw89_read32(rtwdev, R_AX_GNT_SW_CTRL);\n\t\tstatus = rtw89_read32(rtwdev, R_AX_GNT_VAL_V1);\n\n\t\tgnt = &gnt_cfg->band[0];\n\t\tgnt->gnt_bt_sw_en = !!(val & B_AX_GNT_BT_RFC_S0_SWCTRL);\n\t\tgnt->gnt_bt = !!(status & B_AX_GNT_BT_RFC_S0);\n\t\tgnt->gnt_wl_sw_en = !!(val & B_AX_GNT_WL_RFC_S0_SWCTRL);\n\t\tgnt->gnt_wl = !!(status & B_AX_GNT_WL_RFC_S0);\n\n\t\tgnt = &gnt_cfg->band[1];\n\t\tgnt->gnt_bt_sw_en = !!(val & B_AX_GNT_BT_RFC_S1_SWCTRL);\n\t\tgnt->gnt_bt = !!(status & B_AX_GNT_BT_RFC_S1);\n\t\tgnt->gnt_wl_sw_en = !!(val & B_AX_GNT_WL_RFC_S1_SWCTRL);\n\t\tgnt->gnt_wl = !!(status & B_AX_GNT_WL_RFC_S1);\n\t} else {\n\t\treturn;\n\t}\n}\n\nstatic void _show_mreg_v1(struct rtw89_dev *rtwdev, struct seq_file *m)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_btf_fwinfo *pfwinfo = &btc->fwinfo;\n\tstruct rtw89_btc_rpt_cmn_info *pcinfo = NULL;\n\tstruct rtw89_btc_fbtc_mreg_val_v1 *pmreg = NULL;\n\tstruct rtw89_btc_fbtc_gpio_dbg *gdbg = NULL;\n\tstruct rtw89_btc_cx *cx = &btc->cx;\n\tstruct rtw89_btc_wl_info *wl = &btc->cx.wl;\n\tstruct rtw89_btc_bt_info *bt = &btc->cx.bt;\n\tstruct rtw89_mac_ax_coex_gnt gnt_cfg = {};\n\tstruct rtw89_mac_ax_gnt gnt;\n\tu8 i = 0, type = 0, cnt = 0;\n\tu32 val, offset;\n\n\tif (!(btc->dm.coex_info_map & BTC_COEX_INFO_MREG))\n\t\treturn;\n\n\tseq_puts(m, \"========== [HW Status] ==========\\n\");\n\n\tseq_printf(m,\n\t\t   \" %-15s : WL->BT:0x%08x(cnt:%d), BT->WL:0x%08x(total:%d, bt_update:%d)\\n\",\n\t\t   \"[scoreboard]\", wl->scbd, cx->cnt_wl[BTC_WCNT_SCBDUPDATE],\n\t\t   bt->scbd, cx->cnt_bt[BTC_BCNT_SCBDREAD],\n\t\t   cx->cnt_bt[BTC_BCNT_SCBDUPDATE]);\n\n\t \n\tif (!wl->status.map.lps && !wl->status.map.rf_off) {\n\t\tbtc->dm.pta_owner = rtw89_mac_get_ctrl_path(rtwdev);\n\n\t\t_get_gnt(rtwdev, &gnt_cfg);\n\t\tgnt = gnt_cfg.band[0];\n\t\tseq_printf(m,\n\t\t\t   \" %-15s : pta_owner:%s, phy-0[gnt_wl:%s-%d/gnt_bt:%s-%d], \",\n\t\t\t   \"[gnt_status]\",\n\t\t\t   chip->chip_id == RTL8852C ? \"HW\" :\n\t\t\t   btc->dm.pta_owner == BTC_CTRL_BY_WL ? \"WL\" : \"BT\",\n\t\t\t   gnt.gnt_wl_sw_en ? \"SW\" : \"HW\", gnt.gnt_wl,\n\t\t\t   gnt.gnt_bt_sw_en ? \"SW\" : \"HW\", gnt.gnt_bt);\n\n\t\tgnt = gnt_cfg.band[1];\n\t\tseq_printf(m, \"phy-1[gnt_wl:%s-%d/gnt_bt:%s-%d]\\n\",\n\t\t\t   gnt.gnt_wl_sw_en ? \"SW\" : \"HW\",\n\t\t\t   gnt.gnt_wl,\n\t\t\t   gnt.gnt_bt_sw_en ? \"SW\" : \"HW\",\n\t\t\t   gnt.gnt_bt);\n\t}\n\tpcinfo = &pfwinfo->rpt_fbtc_mregval.cinfo;\n\tif (!pcinfo->valid) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t\t    \"[BTC], %s(): stop due rpt_fbtc_mregval.cinfo\\n\",\n\t\t\t    __func__);\n\t\treturn;\n\t}\n\n\tpmreg = &pfwinfo->rpt_fbtc_mregval.finfo.v1;\n\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t    \"[BTC], %s(): rpt_fbtc_mregval reg_num = %d\\n\",\n\t\t    __func__, pmreg->reg_num);\n\n\tfor (i = 0; i < pmreg->reg_num; i++) {\n\t\ttype = (u8)le16_to_cpu(chip->mon_reg[i].type);\n\t\toffset = le32_to_cpu(chip->mon_reg[i].offset);\n\t\tval = le32_to_cpu(pmreg->mreg_val[i]);\n\n\t\tif (cnt % 6 == 0)\n\t\t\tseq_printf(m, \" %-15s : %d_0x%04x=0x%08x\",\n\t\t\t\t   \"[reg]\", (u32)type, offset, val);\n\t\telse\n\t\t\tseq_printf(m, \", %d_0x%04x=0x%08x\", (u32)type,\n\t\t\t\t   offset, val);\n\t\tif (cnt % 6 == 5)\n\t\t\tseq_puts(m, \"\\n\");\n\t\tcnt++;\n\n\t\tif (i >= pmreg->reg_num)\n\t\t\tseq_puts(m, \"\\n\");\n\t}\n\n\tpcinfo = &pfwinfo->rpt_fbtc_gpio_dbg.cinfo;\n\tif (!pcinfo->valid) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t\t    \"[BTC], %s(): stop due rpt_fbtc_gpio_dbg.cinfo\\n\",\n\t\t\t    __func__);\n\t\tseq_puts(m, \"\\n\");\n\t\treturn;\n\t}\n\n\tgdbg = &pfwinfo->rpt_fbtc_gpio_dbg.finfo;\n\tif (!gdbg->en_map)\n\t\treturn;\n\n\tseq_printf(m, \" %-15s : enable_map:0x%08x\",\n\t\t   \"[gpio_dbg]\", gdbg->en_map);\n\n\tfor (i = 0; i < BTC_DBG_MAX1; i++) {\n\t\tif (!(gdbg->en_map & BIT(i)))\n\t\t\tcontinue;\n\t\tseq_printf(m, \", %d->GPIO%d\", (u32)i, gdbg->gpio_map[i]);\n\t}\n\tseq_puts(m, \"\\n\");\n}\n\nstatic void _show_mreg_v2(struct rtw89_dev *rtwdev, struct seq_file *m)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_btf_fwinfo *pfwinfo = &btc->fwinfo;\n\tstruct rtw89_btc_rpt_cmn_info *pcinfo = NULL;\n\tstruct rtw89_btc_fbtc_mreg_val_v2 *pmreg = NULL;\n\tstruct rtw89_btc_fbtc_gpio_dbg *gdbg = NULL;\n\tstruct rtw89_btc_cx *cx = &btc->cx;\n\tstruct rtw89_btc_wl_info *wl = &btc->cx.wl;\n\tstruct rtw89_btc_bt_info *bt = &btc->cx.bt;\n\tstruct rtw89_mac_ax_coex_gnt gnt_cfg = {};\n\tstruct rtw89_mac_ax_gnt gnt;\n\tu8 i = 0, type = 0, cnt = 0;\n\tu32 val, offset;\n\n\tif (!(btc->dm.coex_info_map & BTC_COEX_INFO_MREG))\n\t\treturn;\n\n\tseq_puts(m, \"========== [HW Status] ==========\\n\");\n\n\tseq_printf(m,\n\t\t   \" %-15s : WL->BT:0x%08x(cnt:%d), BT->WL:0x%08x(total:%d, bt_update:%d)\\n\",\n\t\t   \"[scoreboard]\", wl->scbd, cx->cnt_wl[BTC_WCNT_SCBDUPDATE],\n\t\t   bt->scbd, cx->cnt_bt[BTC_BCNT_SCBDREAD],\n\t\t   cx->cnt_bt[BTC_BCNT_SCBDUPDATE]);\n\n\t \n\tif (!wl->status.map.lps && !wl->status.map.rf_off) {\n\t\tbtc->dm.pta_owner = rtw89_mac_get_ctrl_path(rtwdev);\n\n\t\t_get_gnt(rtwdev, &gnt_cfg);\n\t\tgnt = gnt_cfg.band[0];\n\t\tseq_printf(m,\n\t\t\t   \" %-15s : pta_owner:%s, phy-0[gnt_wl:%s-%d/gnt_bt:%s-%d], \",\n\t\t\t   \"[gnt_status]\",\n\t\t\t   chip->chip_id == RTL8852C ? \"HW\" :\n\t\t\t   btc->dm.pta_owner == BTC_CTRL_BY_WL ? \"WL\" : \"BT\",\n\t\t\t   gnt.gnt_wl_sw_en ? \"SW\" : \"HW\", gnt.gnt_wl,\n\t\t\t   gnt.gnt_bt_sw_en ? \"SW\" : \"HW\", gnt.gnt_bt);\n\n\t\tgnt = gnt_cfg.band[1];\n\t\tseq_printf(m, \"phy-1[gnt_wl:%s-%d/gnt_bt:%s-%d]\\n\",\n\t\t\t   gnt.gnt_wl_sw_en ? \"SW\" : \"HW\",\n\t\t\t   gnt.gnt_wl,\n\t\t\t   gnt.gnt_bt_sw_en ? \"SW\" : \"HW\",\n\t\t\t   gnt.gnt_bt);\n\t}\n\tpcinfo = &pfwinfo->rpt_fbtc_mregval.cinfo;\n\tif (!pcinfo->valid) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t\t    \"[BTC], %s(): stop due rpt_fbtc_mregval.cinfo\\n\",\n\t\t\t    __func__);\n\t\treturn;\n\t}\n\n\tpmreg = &pfwinfo->rpt_fbtc_mregval.finfo.v2;\n\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t    \"[BTC], %s(): rpt_fbtc_mregval reg_num = %d\\n\",\n\t\t    __func__, pmreg->reg_num);\n\n\tfor (i = 0; i < pmreg->reg_num; i++) {\n\t\ttype = (u8)le16_to_cpu(chip->mon_reg[i].type);\n\t\toffset = le32_to_cpu(chip->mon_reg[i].offset);\n\t\tval = le32_to_cpu(pmreg->mreg_val[i]);\n\n\t\tif (cnt % 6 == 0)\n\t\t\tseq_printf(m, \" %-15s : %d_0x%04x=0x%08x\",\n\t\t\t\t   \"[reg]\", (u32)type, offset, val);\n\t\telse\n\t\t\tseq_printf(m, \", %d_0x%04x=0x%08x\", (u32)type,\n\t\t\t\t   offset, val);\n\t\tif (cnt % 6 == 5)\n\t\t\tseq_puts(m, \"\\n\");\n\t\tcnt++;\n\n\t\tif (i >= pmreg->reg_num)\n\t\t\tseq_puts(m, \"\\n\");\n\t}\n\n\tpcinfo = &pfwinfo->rpt_fbtc_gpio_dbg.cinfo;\n\tif (!pcinfo->valid) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_BTC,\n\t\t\t    \"[BTC], %s(): stop due rpt_fbtc_gpio_dbg.cinfo\\n\",\n\t\t\t    __func__);\n\t\tseq_puts(m, \"\\n\");\n\t\treturn;\n\t}\n\n\tgdbg = &pfwinfo->rpt_fbtc_gpio_dbg.finfo;\n\tif (!gdbg->en_map)\n\t\treturn;\n\n\tseq_printf(m, \" %-15s : enable_map:0x%08x\",\n\t\t   \"[gpio_dbg]\", gdbg->en_map);\n\n\tfor (i = 0; i < BTC_DBG_MAX1; i++) {\n\t\tif (!(gdbg->en_map & BIT(i)))\n\t\t\tcontinue;\n\t\tseq_printf(m, \", %d->GPIO%d\", (u32)i, gdbg->gpio_map[i]);\n\t}\n\tseq_puts(m, \"\\n\");\n}\n\nstatic void _show_summary_v1(struct rtw89_dev *rtwdev, struct seq_file *m)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_btf_fwinfo *pfwinfo = &btc->fwinfo;\n\tstruct rtw89_btc_rpt_cmn_info *pcinfo = NULL;\n\tstruct rtw89_btc_fbtc_rpt_ctrl_v1 *prptctrl = NULL;\n\tstruct rtw89_btc_cx *cx = &btc->cx;\n\tstruct rtw89_btc_dm *dm = &btc->dm;\n\tstruct rtw89_btc_wl_info *wl = &cx->wl;\n\tstruct rtw89_btc_bt_info *bt = &cx->bt;\n\tu32 cnt_sum = 0, *cnt = btc->dm.cnt_notify;\n\tu8 i;\n\n\tif (!(dm->coex_info_map & BTC_COEX_INFO_SUMMARY))\n\t\treturn;\n\n\tseq_puts(m, \"========== [Statistics] ==========\\n\");\n\n\tpcinfo = &pfwinfo->rpt_ctrl.cinfo;\n\tif (pcinfo->valid && !wl->status.map.lps && !wl->status.map.rf_off) {\n\t\tprptctrl = &pfwinfo->rpt_ctrl.finfo.v1;\n\n\t\tseq_printf(m,\n\t\t\t   \" %-15s : h2c_cnt=%d(fail:%d, fw_recv:%d), c2h_cnt=%d(fw_send:%d), \",\n\t\t\t   \"[summary]\", pfwinfo->cnt_h2c,\n\t\t\t   pfwinfo->cnt_h2c_fail, prptctrl->h2c_cnt,\n\t\t\t   pfwinfo->cnt_c2h, prptctrl->c2h_cnt);\n\n\t\tseq_printf(m,\n\t\t\t   \"rpt_cnt=%d(fw_send:%d), rpt_map=0x%x, dm_error_map:0x%x\",\n\t\t\t   pfwinfo->event[BTF_EVNT_RPT], prptctrl->rpt_cnt,\n\t\t\t   prptctrl->rpt_enable, dm->error.val);\n\n\t\tif (dm->error.map.wl_fw_hang)\n\t\t\tseq_puts(m, \" (WL FW Hang!!)\");\n\t\tseq_puts(m, \"\\n\");\n\t\tseq_printf(m,\n\t\t\t   \" %-15s : send_ok:%d, send_fail:%d, recv:%d\",\n\t\t\t   \"[mailbox]\", prptctrl->mb_send_ok_cnt,\n\t\t\t   prptctrl->mb_send_fail_cnt, prptctrl->mb_recv_cnt);\n\n\t\tseq_printf(m,\n\t\t\t   \"(A2DP_empty:%d, A2DP_flowstop:%d, A2DP_full:%d)\\n\",\n\t\t\t   prptctrl->mb_a2dp_empty_cnt,\n\t\t\t   prptctrl->mb_a2dp_flct_cnt,\n\t\t\t   prptctrl->mb_a2dp_full_cnt);\n\n\t\tseq_printf(m,\n\t\t\t   \" %-15s : wl_rfk[req:%d/go:%d/reject:%d/timeout:%d]\",\n\t\t\t   \"[RFK]\", cx->cnt_wl[BTC_WCNT_RFK_REQ],\n\t\t\t   cx->cnt_wl[BTC_WCNT_RFK_GO],\n\t\t\t   cx->cnt_wl[BTC_WCNT_RFK_REJECT],\n\t\t\t   cx->cnt_wl[BTC_WCNT_RFK_TIMEOUT]);\n\n\t\tseq_printf(m,\n\t\t\t   \", bt_rfk[req:%d/go:%d/reject:%d/timeout:%d/fail:%d]\\n\",\n\t\t\t   prptctrl->bt_rfk_cnt[BTC_BCNT_RFK_REQ],\n\t\t\t   prptctrl->bt_rfk_cnt[BTC_BCNT_RFK_GO],\n\t\t\t   prptctrl->bt_rfk_cnt[BTC_BCNT_RFK_REJECT],\n\t\t\t   prptctrl->bt_rfk_cnt[BTC_BCNT_RFK_TIMEOUT],\n\t\t\t   prptctrl->bt_rfk_cnt[BTC_BCNT_RFK_FAIL]);\n\n\t\tif (prptctrl->bt_rfk_cnt[BTC_BCNT_RFK_TIMEOUT] > 0)\n\t\t\tbt->rfk_info.map.timeout = 1;\n\t\telse\n\t\t\tbt->rfk_info.map.timeout = 0;\n\n\t\tdm->error.map.wl_rfk_timeout = bt->rfk_info.map.timeout;\n\t} else {\n\t\tseq_printf(m,\n\t\t\t   \" %-15s : h2c_cnt=%d(fail:%d), c2h_cnt=%d, rpt_cnt=%d, rpt_map=0x%x\",\n\t\t\t   \"[summary]\", pfwinfo->cnt_h2c,\n\t\t\t   pfwinfo->cnt_h2c_fail, pfwinfo->cnt_c2h,\n\t\t\t   pfwinfo->event[BTF_EVNT_RPT],\n\t\t\t   btc->fwinfo.rpt_en_map);\n\t\tseq_puts(m, \" (WL FW report invalid!!)\\n\");\n\t}\n\n\tfor (i = 0; i < BTC_NCNT_NUM; i++)\n\t\tcnt_sum += dm->cnt_notify[i];\n\n\tseq_printf(m,\n\t\t   \" %-15s : total=%d, show_coex_info=%d, power_on=%d, init_coex=%d, \",\n\t\t   \"[notify_cnt]\", cnt_sum, cnt[BTC_NCNT_SHOW_COEX_INFO],\n\t\t   cnt[BTC_NCNT_POWER_ON], cnt[BTC_NCNT_INIT_COEX]);\n\n\tseq_printf(m,\n\t\t   \"power_off=%d, radio_state=%d, role_info=%d, wl_rfk=%d, wl_sta=%d\\n\",\n\t\t   cnt[BTC_NCNT_POWER_OFF], cnt[BTC_NCNT_RADIO_STATE],\n\t\t   cnt[BTC_NCNT_ROLE_INFO], cnt[BTC_NCNT_WL_RFK],\n\t\t   cnt[BTC_NCNT_WL_STA]);\n\n\tseq_printf(m,\n\t\t   \" %-15s : scan_start=%d, scan_finish=%d, switch_band=%d, special_pkt=%d, \",\n\t\t   \"[notify_cnt]\", cnt[BTC_NCNT_SCAN_START],\n\t\t   cnt[BTC_NCNT_SCAN_FINISH], cnt[BTC_NCNT_SWITCH_BAND],\n\t\t   cnt[BTC_NCNT_SPECIAL_PACKET]);\n\n\tseq_printf(m,\n\t\t   \"timer=%d, control=%d, customerize=%d\\n\",\n\t\t   cnt[BTC_NCNT_TIMER], cnt[BTC_NCNT_CONTROL],\n\t\t   cnt[BTC_NCNT_CUSTOMERIZE]);\n}\n\nstatic void _show_summary_v4(struct rtw89_dev *rtwdev, struct seq_file *m)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_btf_fwinfo *pfwinfo = &btc->fwinfo;\n\tstruct rtw89_btc_fbtc_rpt_ctrl_v4 *prptctrl;\n\tstruct rtw89_btc_rpt_cmn_info *pcinfo;\n\tstruct rtw89_btc_cx *cx = &btc->cx;\n\tstruct rtw89_btc_dm *dm = &btc->dm;\n\tstruct rtw89_btc_wl_info *wl = &cx->wl;\n\tstruct rtw89_btc_bt_info *bt = &cx->bt;\n\tu32 cnt_sum = 0, *cnt = btc->dm.cnt_notify;\n\tu8 i;\n\n\tif (!(dm->coex_info_map & BTC_COEX_INFO_SUMMARY))\n\t\treturn;\n\n\tseq_puts(m, \"========== [Statistics] ==========\\n\");\n\n\tpcinfo = &pfwinfo->rpt_ctrl.cinfo;\n\tif (pcinfo->valid && !wl->status.map.lps && !wl->status.map.rf_off) {\n\t\tprptctrl = &pfwinfo->rpt_ctrl.finfo.v4;\n\n\t\tseq_printf(m,\n\t\t\t   \" %-15s : h2c_cnt=%d(fail:%d, fw_recv:%d), c2h_cnt=%d(fw_send:%d), \",\n\t\t\t   \"[summary]\", pfwinfo->cnt_h2c,\n\t\t\t   pfwinfo->cnt_h2c_fail,\n\t\t\t   le32_to_cpu(prptctrl->rpt_info.cnt_h2c),\n\t\t\t   pfwinfo->cnt_c2h,\n\t\t\t   le32_to_cpu(prptctrl->rpt_info.cnt_c2h));\n\n\t\tseq_printf(m,\n\t\t\t   \"rpt_cnt=%d(fw_send:%d), rpt_map=0x%x, dm_error_map:0x%x\",\n\t\t\t   pfwinfo->event[BTF_EVNT_RPT],\n\t\t\t   le32_to_cpu(prptctrl->rpt_info.cnt),\n\t\t\t   le32_to_cpu(prptctrl->rpt_info.en),\n\t\t\t   dm->error.val);\n\n\t\tif (dm->error.map.wl_fw_hang)\n\t\t\tseq_puts(m, \" (WL FW Hang!!)\");\n\t\tseq_puts(m, \"\\n\");\n\t\tseq_printf(m,\n\t\t\t   \" %-15s : send_ok:%d, send_fail:%d, recv:%d, \",\n\t\t\t   \"[mailbox]\",\n\t\t\t   le32_to_cpu(prptctrl->bt_mbx_info.cnt_send_ok),\n\t\t\t   le32_to_cpu(prptctrl->bt_mbx_info.cnt_send_fail),\n\t\t\t   le32_to_cpu(prptctrl->bt_mbx_info.cnt_recv));\n\n\t\tseq_printf(m,\n\t\t\t   \"A2DP_empty:%d(stop:%d, tx:%d, ack:%d, nack:%d)\\n\",\n\t\t\t   le32_to_cpu(prptctrl->bt_mbx_info.a2dp.cnt_empty),\n\t\t\t   le32_to_cpu(prptctrl->bt_mbx_info.a2dp.cnt_flowctrl),\n\t\t\t   le32_to_cpu(prptctrl->bt_mbx_info.a2dp.cnt_tx),\n\t\t\t   le32_to_cpu(prptctrl->bt_mbx_info.a2dp.cnt_ack),\n\t\t\t   le32_to_cpu(prptctrl->bt_mbx_info.a2dp.cnt_nack));\n\n\t\tseq_printf(m,\n\t\t\t   \" %-15s : wl_rfk[req:%d/go:%d/reject:%d/timeout:%d]\",\n\t\t\t   \"[RFK]\", cx->cnt_wl[BTC_WCNT_RFK_REQ],\n\t\t\t   cx->cnt_wl[BTC_WCNT_RFK_GO],\n\t\t\t   cx->cnt_wl[BTC_WCNT_RFK_REJECT],\n\t\t\t   cx->cnt_wl[BTC_WCNT_RFK_TIMEOUT]);\n\n\t\tseq_printf(m,\n\t\t\t   \", bt_rfk[req:%d/go:%d/reject:%d/timeout:%d/fail:%d]\\n\",\n\t\t\t   le32_to_cpu(prptctrl->bt_cnt[BTC_BCNT_RFK_REQ]),\n\t\t\t   le32_to_cpu(prptctrl->bt_cnt[BTC_BCNT_RFK_GO]),\n\t\t\t   le32_to_cpu(prptctrl->bt_cnt[BTC_BCNT_RFK_REJECT]),\n\t\t\t   le32_to_cpu(prptctrl->bt_cnt[BTC_BCNT_RFK_TIMEOUT]),\n\t\t\t   le32_to_cpu(prptctrl->bt_cnt[BTC_BCNT_RFK_FAIL]));\n\n\t\tif (le32_to_cpu(prptctrl->bt_cnt[BTC_BCNT_RFK_TIMEOUT]) > 0)\n\t\t\tbt->rfk_info.map.timeout = 1;\n\t\telse\n\t\t\tbt->rfk_info.map.timeout = 0;\n\n\t\tdm->error.map.wl_rfk_timeout = bt->rfk_info.map.timeout;\n\t} else {\n\t\tseq_printf(m,\n\t\t\t   \" %-15s : h2c_cnt=%d(fail:%d), c2h_cnt=%d, rpt_cnt=%d, rpt_map=0x%x\",\n\t\t\t   \"[summary]\", pfwinfo->cnt_h2c,\n\t\t\t   pfwinfo->cnt_h2c_fail, pfwinfo->cnt_c2h,\n\t\t\t   pfwinfo->event[BTF_EVNT_RPT],\n\t\t\t   btc->fwinfo.rpt_en_map);\n\t\tseq_puts(m, \" (WL FW report invalid!!)\\n\");\n\t}\n\n\tfor (i = 0; i < BTC_NCNT_NUM; i++)\n\t\tcnt_sum += dm->cnt_notify[i];\n\n\tseq_printf(m,\n\t\t   \" %-15s : total=%d, show_coex_info=%d, power_on=%d, init_coex=%d, \",\n\t\t   \"[notify_cnt]\", cnt_sum, cnt[BTC_NCNT_SHOW_COEX_INFO],\n\t\t   cnt[BTC_NCNT_POWER_ON], cnt[BTC_NCNT_INIT_COEX]);\n\n\tseq_printf(m,\n\t\t   \"power_off=%d, radio_state=%d, role_info=%d, wl_rfk=%d, wl_sta=%d\\n\",\n\t\t   cnt[BTC_NCNT_POWER_OFF], cnt[BTC_NCNT_RADIO_STATE],\n\t\t   cnt[BTC_NCNT_ROLE_INFO], cnt[BTC_NCNT_WL_RFK],\n\t\t   cnt[BTC_NCNT_WL_STA]);\n\n\tseq_printf(m,\n\t\t   \" %-15s : scan_start=%d, scan_finish=%d, switch_band=%d, special_pkt=%d, \",\n\t\t   \"[notify_cnt]\", cnt[BTC_NCNT_SCAN_START],\n\t\t   cnt[BTC_NCNT_SCAN_FINISH], cnt[BTC_NCNT_SWITCH_BAND],\n\t\t   cnt[BTC_NCNT_SPECIAL_PACKET]);\n\n\tseq_printf(m,\n\t\t   \"timer=%d, control=%d, customerize=%d\\n\",\n\t\t   cnt[BTC_NCNT_TIMER], cnt[BTC_NCNT_CONTROL],\n\t\t   cnt[BTC_NCNT_CUSTOMERIZE]);\n}\n\nstatic void _show_summary_v5(struct rtw89_dev *rtwdev, struct seq_file *m)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_btf_fwinfo *pfwinfo = &btc->fwinfo;\n\tstruct rtw89_btc_fbtc_rpt_ctrl_v5 *prptctrl;\n\tstruct rtw89_btc_rpt_cmn_info *pcinfo;\n\tstruct rtw89_btc_cx *cx = &btc->cx;\n\tstruct rtw89_btc_dm *dm = &btc->dm;\n\tstruct rtw89_btc_wl_info *wl = &cx->wl;\n\tu32 cnt_sum = 0, *cnt = btc->dm.cnt_notify;\n\tu8 i;\n\n\tif (!(dm->coex_info_map & BTC_COEX_INFO_SUMMARY))\n\t\treturn;\n\n\tseq_puts(m, \"========== [Statistics] ==========\\n\");\n\n\tpcinfo = &pfwinfo->rpt_ctrl.cinfo;\n\tif (pcinfo->valid && !wl->status.map.lps && !wl->status.map.rf_off) {\n\t\tprptctrl = &pfwinfo->rpt_ctrl.finfo.v5;\n\n\t\tseq_printf(m,\n\t\t\t   \" %-15s : h2c_cnt=%d(fail:%d, fw_recv:%d), c2h_cnt=%d(fw_send:%d, len:%d), \",\n\t\t\t   \"[summary]\", pfwinfo->cnt_h2c, pfwinfo->cnt_h2c_fail,\n\t\t\t   le16_to_cpu(prptctrl->rpt_info.cnt_h2c),\n\t\t\t   pfwinfo->cnt_c2h,\n\t\t\t   le16_to_cpu(prptctrl->rpt_info.cnt_c2h),\n\t\t\t   le16_to_cpu(prptctrl->rpt_info.len_c2h));\n\n\t\tseq_printf(m,\n\t\t\t   \"rpt_cnt=%d(fw_send:%d), rpt_map=0x%x\",\n\t\t\t   pfwinfo->event[BTF_EVNT_RPT],\n\t\t\t   le16_to_cpu(prptctrl->rpt_info.cnt),\n\t\t\t   le32_to_cpu(prptctrl->rpt_info.en));\n\n\t\tif (dm->error.map.wl_fw_hang)\n\t\t\tseq_puts(m, \" (WL FW Hang!!)\");\n\t\tseq_puts(m, \"\\n\");\n\t\tseq_printf(m,\n\t\t\t   \" %-15s : send_ok:%d, send_fail:%d, recv:%d, \",\n\t\t\t   \"[mailbox]\",\n\t\t\t   le32_to_cpu(prptctrl->bt_mbx_info.cnt_send_ok),\n\t\t\t   le32_to_cpu(prptctrl->bt_mbx_info.cnt_send_fail),\n\t\t\t   le32_to_cpu(prptctrl->bt_mbx_info.cnt_recv));\n\n\t\tseq_printf(m,\n\t\t\t   \"A2DP_empty:%d(stop:%d, tx:%d, ack:%d, nack:%d)\\n\",\n\t\t\t   le32_to_cpu(prptctrl->bt_mbx_info.a2dp.cnt_empty),\n\t\t\t   le32_to_cpu(prptctrl->bt_mbx_info.a2dp.cnt_flowctrl),\n\t\t\t   le32_to_cpu(prptctrl->bt_mbx_info.a2dp.cnt_tx),\n\t\t\t   le32_to_cpu(prptctrl->bt_mbx_info.a2dp.cnt_ack),\n\t\t\t   le32_to_cpu(prptctrl->bt_mbx_info.a2dp.cnt_nack));\n\n\t\tseq_printf(m,\n\t\t\t   \" %-15s : wl_rfk[req:%d/go:%d/reject:%d/tout:%d]\",\n\t\t\t   \"[RFK/LPS]\", cx->cnt_wl[BTC_WCNT_RFK_REQ],\n\t\t\t   cx->cnt_wl[BTC_WCNT_RFK_GO],\n\t\t\t   cx->cnt_wl[BTC_WCNT_RFK_REJECT],\n\t\t\t   cx->cnt_wl[BTC_WCNT_RFK_TIMEOUT]);\n\n\t\tseq_printf(m,\n\t\t\t   \", bt_rfk[req:%d]\",\n\t\t\t   le16_to_cpu(prptctrl->bt_cnt[BTC_BCNT_RFK_REQ]));\n\n\t\tseq_printf(m,\n\t\t\t   \", AOAC[RF_on:%d/RF_off:%d]\",\n\t\t\t   le16_to_cpu(prptctrl->rpt_info.cnt_aoac_rf_on),\n\t\t\t   le16_to_cpu(prptctrl->rpt_info.cnt_aoac_rf_off));\n\t} else {\n\t\tseq_printf(m,\n\t\t\t   \" %-15s : h2c_cnt=%d(fail:%d), c2h_cnt=%d\",\n\t\t\t   \"[summary]\", pfwinfo->cnt_h2c,\n\t\t\t   pfwinfo->cnt_h2c_fail, pfwinfo->cnt_c2h);\n\t}\n\n\tif (!pcinfo->valid || pfwinfo->len_mismch || pfwinfo->fver_mismch ||\n\t    pfwinfo->err[BTFRE_EXCEPTION]) {\n\t\tseq_puts(m, \"\\n\");\n\t\tseq_printf(m,\n\t\t\t   \" %-15s : WL FW rpt error!![rpt_ctrl_valid:%d/len:\"\n\t\t\t   \"0x%x/ver:0x%x/ex:%d/lps=%d/rf_off=%d]\",\n\t\t\t   \"[ERROR]\", pcinfo->valid, pfwinfo->len_mismch,\n\t\t\t   pfwinfo->fver_mismch, pfwinfo->err[BTFRE_EXCEPTION],\n\t\t\t   wl->status.map.lps, wl->status.map.rf_off);\n\t}\n\n\tfor (i = 0; i < BTC_NCNT_NUM; i++)\n\t\tcnt_sum += dm->cnt_notify[i];\n\n\tseq_puts(m, \"\\n\");\n\tseq_printf(m,\n\t\t   \" %-15s : total=%d, show_coex_info=%d, power_on=%d, init_coex=%d, \",\n\t\t   \"[notify_cnt]\",\n\t\t   cnt_sum, cnt[BTC_NCNT_SHOW_COEX_INFO],\n\t\t   cnt[BTC_NCNT_POWER_ON], cnt[BTC_NCNT_INIT_COEX]);\n\n\tseq_printf(m,\n\t\t   \"power_off=%d, radio_state=%d, role_info=%d, wl_rfk=%d, wl_sta=%d\",\n\t\t   cnt[BTC_NCNT_POWER_OFF], cnt[BTC_NCNT_RADIO_STATE],\n\t\t   cnt[BTC_NCNT_ROLE_INFO], cnt[BTC_NCNT_WL_RFK],\n\t\t   cnt[BTC_NCNT_WL_STA]);\n\n\tseq_puts(m, \"\\n\");\n\tseq_printf(m,\n\t\t   \" %-15s : scan_start=%d, scan_finish=%d, switch_band=%d, special_pkt=%d, \",\n\t\t   \"[notify_cnt]\",\n\t\t   cnt[BTC_NCNT_SCAN_START], cnt[BTC_NCNT_SCAN_FINISH],\n\t\t   cnt[BTC_NCNT_SWITCH_BAND], cnt[BTC_NCNT_SPECIAL_PACKET]);\n\n\tseq_printf(m,\n\t\t   \"timer=%d, control=%d, customerize=%d\",\n\t\t   cnt[BTC_NCNT_TIMER], cnt[BTC_NCNT_CONTROL],\n\t\t   cnt[BTC_NCNT_CUSTOMERIZE]);\n}\n\nstatic void _show_summary_v105(struct rtw89_dev *rtwdev, struct seq_file *m)\n{\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tstruct rtw89_btc_btf_fwinfo *pfwinfo = &btc->fwinfo;\n\tstruct rtw89_btc_fbtc_rpt_ctrl_v105 *prptctrl;\n\tstruct rtw89_btc_rpt_cmn_info *pcinfo;\n\tstruct rtw89_btc_cx *cx = &btc->cx;\n\tstruct rtw89_btc_dm *dm = &btc->dm;\n\tstruct rtw89_btc_wl_info *wl = &cx->wl;\n\tu32 cnt_sum = 0, *cnt = btc->dm.cnt_notify;\n\tu8 i;\n\n\tif (!(dm->coex_info_map & BTC_COEX_INFO_SUMMARY))\n\t\treturn;\n\n\tseq_puts(m, \"========== [Statistics] ==========\\n\");\n\n\tpcinfo = &pfwinfo->rpt_ctrl.cinfo;\n\tif (pcinfo->valid && !wl->status.map.lps && !wl->status.map.rf_off) {\n\t\tprptctrl = &pfwinfo->rpt_ctrl.finfo.v105;\n\n\t\tseq_printf(m,\n\t\t\t   \" %-15s : h2c_cnt=%d(fail:%d, fw_recv:%d), c2h_cnt=%d(fw_send:%d, len:%d), \",\n\t\t\t   \"[summary]\", pfwinfo->cnt_h2c, pfwinfo->cnt_h2c_fail,\n\t\t\t   le16_to_cpu(prptctrl->rpt_info.cnt_h2c),\n\t\t\t   pfwinfo->cnt_c2h,\n\t\t\t   le16_to_cpu(prptctrl->rpt_info.cnt_c2h),\n\t\t\t   le16_to_cpu(prptctrl->rpt_info.len_c2h));\n\n\t\tseq_printf(m,\n\t\t\t   \"rpt_cnt=%d(fw_send:%d), rpt_map=0x%x\",\n\t\t\t   pfwinfo->event[BTF_EVNT_RPT],\n\t\t\t   le16_to_cpu(prptctrl->rpt_info.cnt),\n\t\t\t   le32_to_cpu(prptctrl->rpt_info.en));\n\n\t\tif (dm->error.map.wl_fw_hang)\n\t\t\tseq_puts(m, \" (WL FW Hang!!)\");\n\t\tseq_puts(m, \"\\n\");\n\t\tseq_printf(m,\n\t\t\t   \" %-15s : send_ok:%d, send_fail:%d, recv:%d, \",\n\t\t\t   \"[mailbox]\",\n\t\t\t   le32_to_cpu(prptctrl->bt_mbx_info.cnt_send_ok),\n\t\t\t   le32_to_cpu(prptctrl->bt_mbx_info.cnt_send_fail),\n\t\t\t   le32_to_cpu(prptctrl->bt_mbx_info.cnt_recv));\n\n\t\tseq_printf(m,\n\t\t\t   \"A2DP_empty:%d(stop:%d, tx:%d, ack:%d, nack:%d)\\n\",\n\t\t\t   le32_to_cpu(prptctrl->bt_mbx_info.a2dp.cnt_empty),\n\t\t\t   le32_to_cpu(prptctrl->bt_mbx_info.a2dp.cnt_flowctrl),\n\t\t\t   le32_to_cpu(prptctrl->bt_mbx_info.a2dp.cnt_tx),\n\t\t\t   le32_to_cpu(prptctrl->bt_mbx_info.a2dp.cnt_ack),\n\t\t\t   le32_to_cpu(prptctrl->bt_mbx_info.a2dp.cnt_nack));\n\n\t\tseq_printf(m,\n\t\t\t   \" %-15s : wl_rfk[req:%d/go:%d/reject:%d/tout:%d]\",\n\t\t\t   \"[RFK/LPS]\", cx->cnt_wl[BTC_WCNT_RFK_REQ],\n\t\t\t   cx->cnt_wl[BTC_WCNT_RFK_GO],\n\t\t\t   cx->cnt_wl[BTC_WCNT_RFK_REJECT],\n\t\t\t   cx->cnt_wl[BTC_WCNT_RFK_TIMEOUT]);\n\n\t\tseq_printf(m,\n\t\t\t   \", bt_rfk[req:%d]\",\n\t\t\t   le16_to_cpu(prptctrl->bt_cnt[BTC_BCNT_RFK_REQ]));\n\n\t\tseq_printf(m,\n\t\t\t   \", AOAC[RF_on:%d/RF_off:%d]\",\n\t\t\t   le16_to_cpu(prptctrl->rpt_info.cnt_aoac_rf_on),\n\t\t\t   le16_to_cpu(prptctrl->rpt_info.cnt_aoac_rf_off));\n\t} else {\n\t\tseq_printf(m,\n\t\t\t   \" %-15s : h2c_cnt=%d(fail:%d), c2h_cnt=%d\",\n\t\t\t   \"[summary]\", pfwinfo->cnt_h2c,\n\t\t\t   pfwinfo->cnt_h2c_fail, pfwinfo->cnt_c2h);\n\t}\n\n\tif (!pcinfo->valid || pfwinfo->len_mismch || pfwinfo->fver_mismch ||\n\t    pfwinfo->err[BTFRE_EXCEPTION]) {\n\t\tseq_puts(m, \"\\n\");\n\t\tseq_printf(m,\n\t\t\t   \" %-15s : WL FW rpt error!![rpt_ctrl_valid:%d/len:\"\n\t\t\t   \"0x%x/ver:0x%x/ex:%d/lps=%d/rf_off=%d]\",\n\t\t\t   \"[ERROR]\", pcinfo->valid, pfwinfo->len_mismch,\n\t\t\t   pfwinfo->fver_mismch, pfwinfo->err[BTFRE_EXCEPTION],\n\t\t\t   wl->status.map.lps, wl->status.map.rf_off);\n\t}\n\n\tfor (i = 0; i < BTC_NCNT_NUM; i++)\n\t\tcnt_sum += dm->cnt_notify[i];\n\n\tseq_puts(m, \"\\n\");\n\tseq_printf(m,\n\t\t   \" %-15s : total=%d, show_coex_info=%d, power_on=%d, init_coex=%d, \",\n\t\t   \"[notify_cnt]\",\n\t\t   cnt_sum, cnt[BTC_NCNT_SHOW_COEX_INFO],\n\t\t   cnt[BTC_NCNT_POWER_ON], cnt[BTC_NCNT_INIT_COEX]);\n\n\tseq_printf(m,\n\t\t   \"power_off=%d, radio_state=%d, role_info=%d, wl_rfk=%d, wl_sta=%d\",\n\t\t   cnt[BTC_NCNT_POWER_OFF], cnt[BTC_NCNT_RADIO_STATE],\n\t\t   cnt[BTC_NCNT_ROLE_INFO], cnt[BTC_NCNT_WL_RFK],\n\t\t   cnt[BTC_NCNT_WL_STA]);\n\n\tseq_puts(m, \"\\n\");\n\tseq_printf(m,\n\t\t   \" %-15s : scan_start=%d, scan_finish=%d, switch_band=%d, special_pkt=%d, \",\n\t\t   \"[notify_cnt]\",\n\t\t   cnt[BTC_NCNT_SCAN_START], cnt[BTC_NCNT_SCAN_FINISH],\n\t\t   cnt[BTC_NCNT_SWITCH_BAND], cnt[BTC_NCNT_SPECIAL_PACKET]);\n\n\tseq_printf(m,\n\t\t   \"timer=%d, control=%d, customerize=%d\",\n\t\t   cnt[BTC_NCNT_TIMER], cnt[BTC_NCNT_CONTROL],\n\t\t   cnt[BTC_NCNT_CUSTOMERIZE]);\n}\n\nvoid rtw89_btc_dump_info(struct rtw89_dev *rtwdev, struct seq_file *m)\n{\n\tstruct rtw89_fw_suit *fw_suit = &rtwdev->fw.normal;\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tconst struct rtw89_btc_ver *ver = btc->ver;\n\tstruct rtw89_btc_cx *cx = &btc->cx;\n\tstruct rtw89_btc_bt_info *bt = &cx->bt;\n\n\tseq_puts(m, \"=========================================\\n\");\n\tseq_printf(m, \"WL FW / BT FW\t\t%d.%d.%d.%d / NA\\n\",\n\t\t   fw_suit->major_ver, fw_suit->minor_ver,\n\t\t   fw_suit->sub_ver, fw_suit->sub_idex);\n\tseq_printf(m, \"manual\t\t\t%d\\n\", btc->ctrl.manual);\n\n\tseq_puts(m, \"=========================================\\n\");\n\n\tseq_printf(m, \"\\n\\r %-15s : raw_data[%02x %02x %02x %02x %02x %02x] (type:%s/cnt:%d/same:%d)\",\n\t\t   \"[bt_info]\",\n\t\t   bt->raw_info[2], bt->raw_info[3],\n\t\t   bt->raw_info[4], bt->raw_info[5],\n\t\t   bt->raw_info[6], bt->raw_info[7],\n\t\t   bt->raw_info[0] == BTC_BTINFO_AUTO ? \"auto\" : \"reply\",\n\t\t   cx->cnt_bt[BTC_BCNT_INFOUPDATE],\n\t\t   cx->cnt_bt[BTC_BCNT_INFOSAME]);\n\n\tseq_puts(m, \"\\n=========================================\\n\");\n\n\t_show_cx_info(rtwdev, m);\n\t_show_wl_info(rtwdev, m);\n\t_show_bt_info(rtwdev, m);\n\t_show_dm_info(rtwdev, m);\n\t_show_fw_dm_msg(rtwdev, m);\n\n\tif (ver->fcxmreg == 1)\n\t\t_show_mreg_v1(rtwdev, m);\n\telse if (ver->fcxmreg == 2)\n\t\t_show_mreg_v2(rtwdev, m);\n\n\tif (ver->fcxbtcrpt == 1)\n\t\t_show_summary_v1(rtwdev, m);\n\telse if (ver->fcxbtcrpt == 4)\n\t\t_show_summary_v4(rtwdev, m);\n\telse if (ver->fcxbtcrpt == 5)\n\t\t_show_summary_v5(rtwdev, m);\n\telse if (ver->fcxbtcrpt == 105)\n\t\t_show_summary_v105(rtwdev, m);\n}\n\nvoid rtw89_coex_recognize_ver(struct rtw89_dev *rtwdev)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tstruct rtw89_btc *btc = &rtwdev->btc;\n\tconst struct rtw89_btc_ver *btc_ver_def;\n\tconst struct rtw89_fw_suit *fw_suit;\n\tu32 suit_ver_code;\n\tint i;\n\n\tfw_suit = rtw89_fw_suit_get(rtwdev, RTW89_FW_NORMAL);\n\tsuit_ver_code = RTW89_FW_SUIT_VER_CODE(fw_suit);\n\n\tfor (i = 0; i < ARRAY_SIZE(rtw89_btc_ver_defs); i++) {\n\t\tbtc_ver_def = &rtw89_btc_ver_defs[i];\n\n\t\tif (chip->chip_id != btc_ver_def->chip_id)\n\t\t\tcontinue;\n\n\t\tif (suit_ver_code >= btc_ver_def->fw_ver_code) {\n\t\t\tbtc->ver = btc_ver_def;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tbtc->ver = &rtw89_btc_ver_defs[RTW89_DEFAULT_BTC_VER_IDX];\n\nout:\n\trtw89_debug(rtwdev, RTW89_DBG_BTC, \"[BTC] use version def[%d] = 0x%08x\\n\",\n\t\t    (int)(btc->ver - rtw89_btc_ver_defs), btc->ver->fw_ver_code);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}