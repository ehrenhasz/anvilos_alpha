{
  "module_name": "sar.c",
  "hash_id": "81caca5b7041b7df8363669bb4b5169220801caba82618815b06116f342084e8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtw89/sar.c",
  "human_readable_source": "\n \n\n#include \"acpi.h\"\n#include \"debug.h\"\n#include \"phy.h\"\n#include \"reg.h\"\n#include \"sar.h\"\n\n#define RTW89_TAS_FACTOR 2  \n#define RTW89_TAS_DPR_GAP (1 << RTW89_TAS_FACTOR)\n#define RTW89_TAS_DELTA (2 << RTW89_TAS_FACTOR)\n\nstatic enum rtw89_sar_subband rtw89_sar_get_subband(struct rtw89_dev *rtwdev,\n\t\t\t\t\t\t    u32 center_freq)\n{\n\tswitch (center_freq) {\n\tdefault:\n\t\trtw89_debug(rtwdev, RTW89_DBG_SAR,\n\t\t\t    \"center freq: %u to SAR subband is unhandled\\n\",\n\t\t\t    center_freq);\n\t\tfallthrough;\n\tcase 2412 ... 2484:\n\t\treturn RTW89_SAR_2GHZ_SUBBAND;\n\tcase 5180 ... 5320:\n\t\treturn RTW89_SAR_5GHZ_SUBBAND_1_2;\n\tcase 5500 ... 5720:\n\t\treturn RTW89_SAR_5GHZ_SUBBAND_2_E;\n\tcase 5745 ... 5825:\n\t\treturn RTW89_SAR_5GHZ_SUBBAND_3;\n\tcase 5955 ... 6155:\n\t\treturn RTW89_SAR_6GHZ_SUBBAND_5_L;\n\tcase 6175 ... 6415:\n\t\treturn RTW89_SAR_6GHZ_SUBBAND_5_H;\n\tcase 6435 ... 6515:\n\t\treturn RTW89_SAR_6GHZ_SUBBAND_6;\n\tcase 6535 ... 6695:\n\t\treturn RTW89_SAR_6GHZ_SUBBAND_7_L;\n\tcase 6715 ... 6855:\n\t\treturn RTW89_SAR_6GHZ_SUBBAND_7_H;\n\n\t \n\n\tcase 6895 ... 7115:\n\t\treturn RTW89_SAR_6GHZ_SUBBAND_8;\n\t}\n}\n\nstruct rtw89_sar_span {\n\tenum rtw89_sar_subband subband_low;\n\tenum rtw89_sar_subband subband_high;\n};\n\n#define RTW89_SAR_SPAN_VALID(span) ((span)->subband_high)\n\n#define RTW89_SAR_6GHZ_SPAN_HEAD 6145\n#define RTW89_SAR_6GHZ_SPAN_IDX(center_freq) \\\n\t((((int)(center_freq) - RTW89_SAR_6GHZ_SPAN_HEAD) / 5) / 2)\n\n#define RTW89_DECL_SAR_6GHZ_SPAN(center_freq, subband_l, subband_h) \\\n\t[RTW89_SAR_6GHZ_SPAN_IDX(center_freq)] = { \\\n\t\t.subband_low = RTW89_SAR_6GHZ_ ## subband_l, \\\n\t\t.subband_high = RTW89_SAR_6GHZ_ ## subband_h, \\\n\t}\n\n \nstatic const struct rtw89_sar_span rtw89_sar_overlapping_6ghz[] = {\n\tRTW89_DECL_SAR_6GHZ_SPAN(6145, SUBBAND_5_L, SUBBAND_5_H),\n\tRTW89_DECL_SAR_6GHZ_SPAN(6165, SUBBAND_5_L, SUBBAND_5_H),\n\tRTW89_DECL_SAR_6GHZ_SPAN(6185, SUBBAND_5_L, SUBBAND_5_H),\n\tRTW89_DECL_SAR_6GHZ_SPAN(6505, SUBBAND_6, SUBBAND_7_L),\n\tRTW89_DECL_SAR_6GHZ_SPAN(6525, SUBBAND_6, SUBBAND_7_L),\n\tRTW89_DECL_SAR_6GHZ_SPAN(6545, SUBBAND_6, SUBBAND_7_L),\n\tRTW89_DECL_SAR_6GHZ_SPAN(6665, SUBBAND_7_L, SUBBAND_7_H),\n\tRTW89_DECL_SAR_6GHZ_SPAN(6705, SUBBAND_7_L, SUBBAND_7_H),\n\tRTW89_DECL_SAR_6GHZ_SPAN(6825, SUBBAND_7_H, SUBBAND_8),\n\tRTW89_DECL_SAR_6GHZ_SPAN(6865, SUBBAND_7_H, SUBBAND_8),\n\tRTW89_DECL_SAR_6GHZ_SPAN(6875, SUBBAND_7_H, SUBBAND_8),\n\tRTW89_DECL_SAR_6GHZ_SPAN(6885, SUBBAND_7_H, SUBBAND_8),\n};\n\nstatic int rtw89_query_sar_config_common(struct rtw89_dev *rtwdev,\n\t\t\t\t\t u32 center_freq, s32 *cfg)\n{\n\tstruct rtw89_sar_cfg_common *rtwsar = &rtwdev->sar.cfg_common;\n\tconst struct rtw89_sar_span *span = NULL;\n\tenum rtw89_sar_subband subband_l, subband_h;\n\tint idx;\n\n\tif (center_freq >= RTW89_SAR_6GHZ_SPAN_HEAD) {\n\t\tidx = RTW89_SAR_6GHZ_SPAN_IDX(center_freq);\n\t\t \n\t\tif (idx >= 0 && idx < ARRAY_SIZE(rtw89_sar_overlapping_6ghz))\n\t\t\tspan = &rtw89_sar_overlapping_6ghz[idx];\n\t}\n\n\tif (span && RTW89_SAR_SPAN_VALID(span)) {\n\t\tsubband_l = span->subband_low;\n\t\tsubband_h = span->subband_high;\n\t} else {\n\t\tsubband_l = rtw89_sar_get_subband(rtwdev, center_freq);\n\t\tsubband_h = subband_l;\n\t}\n\n\trtw89_debug(rtwdev, RTW89_DBG_SAR,\n\t\t    \"center_freq %u: SAR subband {%u, %u}\\n\",\n\t\t    center_freq, subband_l, subband_h);\n\n\tif (!rtwsar->set[subband_l] && !rtwsar->set[subband_h])\n\t\treturn -ENODATA;\n\n\tif (!rtwsar->set[subband_l])\n\t\t*cfg = rtwsar->cfg[subband_h];\n\telse if (!rtwsar->set[subband_h])\n\t\t*cfg = rtwsar->cfg[subband_l];\n\telse\n\t\t*cfg = min(rtwsar->cfg[subband_l], rtwsar->cfg[subband_h]);\n\n\treturn 0;\n}\n\nstatic const\nstruct rtw89_sar_handler rtw89_sar_handlers[RTW89_SAR_SOURCE_NR] = {\n\t[RTW89_SAR_SOURCE_COMMON] = {\n\t\t.descr_sar_source = \"RTW89_SAR_SOURCE_COMMON\",\n\t\t.txpwr_factor_sar = 2,\n\t\t.query_sar_config = rtw89_query_sar_config_common,\n\t},\n};\n\n#define rtw89_sar_set_src(_dev, _src, _cfg_name, _cfg_data)\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\ttypeof(_src) _s = (_src);\t\t\t\t\\\n\t\ttypeof(_dev) _d = (_dev);\t\t\t\t\\\n\t\tBUILD_BUG_ON(!rtw89_sar_handlers[_s].descr_sar_source);\t\\\n\t\tBUILD_BUG_ON(!rtw89_sar_handlers[_s].query_sar_config);\t\\\n\t\tlockdep_assert_held(&_d->mutex);\t\t\t\\\n\t\t_d->sar._cfg_name = *(_cfg_data);\t\t\t\\\n\t\t_d->sar.src = _s;\t\t\t\t\t\\\n\t} while (0)\n\nstatic s8 rtw89_txpwr_sar_to_mac(struct rtw89_dev *rtwdev, u8 fct, s32 cfg)\n{\n\tconst u8 fct_mac = rtwdev->chip->txpwr_factor_mac;\n\ts32 cfg_mac;\n\n\tcfg_mac = fct > fct_mac ?\n\t\t  cfg >> (fct - fct_mac) : cfg << (fct_mac - fct);\n\n\treturn (s8)clamp_t(s32, cfg_mac,\n\t\t\t   RTW89_SAR_TXPWR_MAC_MIN,\n\t\t\t   RTW89_SAR_TXPWR_MAC_MAX);\n}\n\nstatic s8 rtw89_txpwr_tas_to_sar(const struct rtw89_sar_handler *sar_hdl,\n\t\t\t\t s8 cfg)\n{\n\tconst u8 fct = sar_hdl->txpwr_factor_sar;\n\n\tif (fct > RTW89_TAS_FACTOR)\n\t\treturn cfg << (fct - RTW89_TAS_FACTOR);\n\telse\n\t\treturn cfg >> (RTW89_TAS_FACTOR - fct);\n}\n\nstatic s8 rtw89_txpwr_sar_to_tas(const struct rtw89_sar_handler *sar_hdl,\n\t\t\t\t s8 cfg)\n{\n\tconst u8 fct = sar_hdl->txpwr_factor_sar;\n\n\tif (fct > RTW89_TAS_FACTOR)\n\t\treturn cfg >> (fct - RTW89_TAS_FACTOR);\n\telse\n\t\treturn cfg << (RTW89_TAS_FACTOR - fct);\n}\n\ns8 rtw89_query_sar(struct rtw89_dev *rtwdev, u32 center_freq)\n{\n\tconst enum rtw89_sar_sources src = rtwdev->sar.src;\n\t \n\tconst struct rtw89_sar_handler *sar_hdl = &rtw89_sar_handlers[src];\n\tstruct rtw89_tas_info *tas = &rtwdev->tas;\n\ts8 delta;\n\tint ret;\n\ts32 cfg;\n\tu8 fct;\n\n\tlockdep_assert_held(&rtwdev->mutex);\n\n\tif (src == RTW89_SAR_SOURCE_NONE)\n\t\treturn RTW89_SAR_TXPWR_MAC_MAX;\n\n\tret = sar_hdl->query_sar_config(rtwdev, center_freq, &cfg);\n\tif (ret)\n\t\treturn RTW89_SAR_TXPWR_MAC_MAX;\n\n\tif (tas->enable) {\n\t\tswitch (tas->state) {\n\t\tcase RTW89_TAS_STATE_DPR_OFF:\n\t\t\treturn RTW89_SAR_TXPWR_MAC_MAX;\n\t\tcase RTW89_TAS_STATE_DPR_ON:\n\t\t\tdelta = rtw89_txpwr_tas_to_sar(sar_hdl, tas->delta);\n\t\t\tcfg -= delta;\n\t\t\tbreak;\n\t\tcase RTW89_TAS_STATE_DPR_FORBID:\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfct = sar_hdl->txpwr_factor_sar;\n\n\treturn rtw89_txpwr_sar_to_mac(rtwdev, fct, cfg);\n}\n\nvoid rtw89_print_sar(struct seq_file *m, struct rtw89_dev *rtwdev, u32 center_freq)\n{\n\tconst enum rtw89_sar_sources src = rtwdev->sar.src;\n\t \n\tconst struct rtw89_sar_handler *sar_hdl = &rtw89_sar_handlers[src];\n\tconst u8 fct_mac = rtwdev->chip->txpwr_factor_mac;\n\tint ret;\n\ts32 cfg;\n\tu8 fct;\n\n\tlockdep_assert_held(&rtwdev->mutex);\n\n\tif (src == RTW89_SAR_SOURCE_NONE) {\n\t\tseq_puts(m, \"no SAR is applied\\n\");\n\t\treturn;\n\t}\n\n\tseq_printf(m, \"source: %d (%s)\\n\", src, sar_hdl->descr_sar_source);\n\n\tret = sar_hdl->query_sar_config(rtwdev, center_freq, &cfg);\n\tif (ret) {\n\t\tseq_printf(m, \"config: return code: %d\\n\", ret);\n\t\tseq_printf(m, \"assign: max setting: %d (unit: 1/%lu dBm)\\n\",\n\t\t\t   RTW89_SAR_TXPWR_MAC_MAX, BIT(fct_mac));\n\t\treturn;\n\t}\n\n\tfct = sar_hdl->txpwr_factor_sar;\n\n\tseq_printf(m, \"config: %d (unit: 1/%lu dBm)\\n\", cfg, BIT(fct));\n}\n\nvoid rtw89_print_tas(struct seq_file *m, struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_tas_info *tas = &rtwdev->tas;\n\n\tif (!tas->enable) {\n\t\tseq_puts(m, \"no TAS is applied\\n\");\n\t\treturn;\n\t}\n\n\tseq_printf(m, \"DPR gap: %d\\n\", tas->dpr_gap);\n\tseq_printf(m, \"TAS delta: %d\\n\", tas->delta);\n}\n\nstatic int rtw89_apply_sar_common(struct rtw89_dev *rtwdev,\n\t\t\t\t  const struct rtw89_sar_cfg_common *sar)\n{\n\tenum rtw89_sar_sources src;\n\tint ret = 0;\n\n\tmutex_lock(&rtwdev->mutex);\n\n\tsrc = rtwdev->sar.src;\n\tif (src != RTW89_SAR_SOURCE_NONE && src != RTW89_SAR_SOURCE_COMMON) {\n\t\trtw89_warn(rtwdev, \"SAR source: %d is in use\", src);\n\t\tret = -EBUSY;\n\t\tgoto exit;\n\t}\n\n\trtw89_sar_set_src(rtwdev, RTW89_SAR_SOURCE_COMMON, cfg_common, sar);\n\trtw89_core_set_chip_txpwr(rtwdev);\n\nexit:\n\tmutex_unlock(&rtwdev->mutex);\n\treturn ret;\n}\n\nstatic const struct cfg80211_sar_freq_ranges rtw89_common_sar_freq_ranges[] = {\n\t{ .start_freq = 2412, .end_freq = 2484, },\n\t{ .start_freq = 5180, .end_freq = 5320, },\n\t{ .start_freq = 5500, .end_freq = 5720, },\n\t{ .start_freq = 5745, .end_freq = 5825, },\n\t{ .start_freq = 5955, .end_freq = 6155, },\n\t{ .start_freq = 6175, .end_freq = 6415, },\n\t{ .start_freq = 6435, .end_freq = 6515, },\n\t{ .start_freq = 6535, .end_freq = 6695, },\n\t{ .start_freq = 6715, .end_freq = 6875, },\n\t{ .start_freq = 6875, .end_freq = 7115, },\n};\n\nstatic_assert(RTW89_SAR_SUBBAND_NR ==\n\t      ARRAY_SIZE(rtw89_common_sar_freq_ranges));\n\nconst struct cfg80211_sar_capa rtw89_sar_capa = {\n\t.type = NL80211_SAR_TYPE_POWER,\n\t.num_freq_ranges = ARRAY_SIZE(rtw89_common_sar_freq_ranges),\n\t.freq_ranges = rtw89_common_sar_freq_ranges,\n};\n\nint rtw89_ops_set_sar_specs(struct ieee80211_hw *hw,\n\t\t\t    const struct cfg80211_sar_specs *sar)\n{\n\tstruct rtw89_dev *rtwdev = hw->priv;\n\tstruct rtw89_sar_cfg_common sar_common = {0};\n\tu8 fct;\n\tu32 freq_start;\n\tu32 freq_end;\n\ts32 power;\n\tu32 i, idx;\n\n\tif (sar->type != NL80211_SAR_TYPE_POWER)\n\t\treturn -EINVAL;\n\n\tfct = rtw89_sar_handlers[RTW89_SAR_SOURCE_COMMON].txpwr_factor_sar;\n\n\tfor (i = 0; i < sar->num_sub_specs; i++) {\n\t\tidx = sar->sub_specs[i].freq_range_index;\n\t\tif (idx >= ARRAY_SIZE(rtw89_common_sar_freq_ranges))\n\t\t\treturn -EINVAL;\n\n\t\tfreq_start = rtw89_common_sar_freq_ranges[idx].start_freq;\n\t\tfreq_end = rtw89_common_sar_freq_ranges[idx].end_freq;\n\t\tpower = sar->sub_specs[i].power;\n\n\t\trtw89_debug(rtwdev, RTW89_DBG_SAR,\n\t\t\t    \"On freq %u to %u, set SAR limit %d (unit: 1/%lu dBm)\\n\",\n\t\t\t    freq_start, freq_end, power, BIT(fct));\n\n\t\tsar_common.set[idx] = true;\n\t\tsar_common.cfg[idx] = power;\n\t}\n\n\treturn rtw89_apply_sar_common(rtwdev, &sar_common);\n}\n\nstatic void rtw89_tas_state_update(struct rtw89_dev *rtwdev)\n{\n\tconst enum rtw89_sar_sources src = rtwdev->sar.src;\n\t \n\tconst struct rtw89_sar_handler *sar_hdl = &rtw89_sar_handlers[src];\n\tstruct rtw89_tas_info *tas = &rtwdev->tas;\n\ts32 txpwr_avg = tas->total_txpwr / RTW89_TAS_MAX_WINDOW / PERCENT;\n\ts32 dpr_on_threshold, dpr_off_threshold, cfg;\n\tenum rtw89_tas_state state = tas->state;\n\tconst struct rtw89_chan *chan;\n\tint ret;\n\n\tlockdep_assert_held(&rtwdev->mutex);\n\n\tif (src == RTW89_SAR_SOURCE_NONE)\n\t\treturn;\n\n\tchan = rtw89_chan_get(rtwdev, RTW89_SUB_ENTITY_0);\n\tret = sar_hdl->query_sar_config(rtwdev, chan->freq, &cfg);\n\tif (ret)\n\t\treturn;\n\n\tcfg = rtw89_txpwr_sar_to_tas(sar_hdl, cfg);\n\n\tif (tas->delta >= cfg) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_SAR,\n\t\t\t    \"TAS delta exceed SAR limit\\n\");\n\t\tstate = RTW89_TAS_STATE_DPR_FORBID;\n\t\tgoto out;\n\t}\n\n\tdpr_on_threshold = cfg;\n\tdpr_off_threshold = cfg - tas->dpr_gap;\n\trtw89_debug(rtwdev, RTW89_DBG_SAR,\n\t\t    \"DPR_ON thold: %d, DPR_OFF thold: %d, txpwr_avg: %d\\n\",\n\t\t    dpr_on_threshold, dpr_off_threshold, txpwr_avg);\n\n\tif (txpwr_avg >= dpr_on_threshold)\n\t\tstate = RTW89_TAS_STATE_DPR_ON;\n\telse if (txpwr_avg < dpr_off_threshold)\n\t\tstate = RTW89_TAS_STATE_DPR_OFF;\n\nout:\n\tif (tas->state == state)\n\t\treturn;\n\n\trtw89_debug(rtwdev, RTW89_DBG_SAR,\n\t\t    \"TAS old state: %d, new state: %d\\n\", tas->state, state);\n\ttas->state = state;\n\trtw89_core_set_chip_txpwr(rtwdev);\n}\n\nvoid rtw89_tas_init(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_tas_info *tas = &rtwdev->tas;\n\tint ret;\n\tu8 val;\n\n\tret = rtw89_acpi_evaluate_dsm(rtwdev, RTW89_ACPI_DSM_FUNC_TAS_EN, &val);\n\tif (ret) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_SAR,\n\t\t\t    \"acpi: cannot get TAS: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tswitch (val) {\n\tcase 0:\n\t\ttas->enable = false;\n\t\tbreak;\n\tcase 1:\n\t\ttas->enable = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!tas->enable) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_SAR, \"TAS not enable\\n\");\n\t\treturn;\n\t}\n\n\ttas->dpr_gap = RTW89_TAS_DPR_GAP;\n\ttas->delta = RTW89_TAS_DELTA;\n}\n\nvoid rtw89_tas_reset(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_tas_info *tas = &rtwdev->tas;\n\n\tif (!tas->enable)\n\t\treturn;\n\n\tmemset(&tas->txpwr_history, 0, sizeof(tas->txpwr_history));\n\ttas->total_txpwr = 0;\n\ttas->cur_idx = 0;\n\ttas->state = RTW89_TAS_STATE_DPR_OFF;\n}\n\nstatic const struct rtw89_reg_def txpwr_regs[] = {\n\t{R_PATH0_TXPWR, B_PATH0_TXPWR},\n\t{R_PATH1_TXPWR, B_PATH1_TXPWR},\n};\n\nvoid rtw89_tas_track(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_env_monitor_info *env = &rtwdev->env_monitor;\n\tconst enum rtw89_sar_sources src = rtwdev->sar.src;\n\tu8 max_nss_num = rtwdev->chip->rf_path_num;\n\tstruct rtw89_tas_info *tas = &rtwdev->tas;\n\ts16 tmp, txpwr, instant_txpwr = 0;\n\tu32 val;\n\tint i;\n\n\tif (!tas->enable || src == RTW89_SAR_SOURCE_NONE)\n\t\treturn;\n\n\tif (env->ccx_watchdog_result != RTW89_PHY_ENV_MON_IFS_CLM)\n\t\treturn;\n\n\tfor (i = 0; i < max_nss_num; i++) {\n\t\tval = rtw89_phy_read32_mask(rtwdev, txpwr_regs[i].addr,\n\t\t\t\t\t    txpwr_regs[i].mask);\n\t\ttmp = sign_extend32(val, 8);\n\t\tif (tmp <= 0)\n\t\t\treturn;\n\t\tinstant_txpwr += tmp;\n\t}\n\n\tinstant_txpwr /= max_nss_num;\n\t \n\ttxpwr = instant_txpwr * env->ifs_clm_tx_ratio;\n\ttas->total_txpwr += txpwr - tas->txpwr_history[tas->cur_idx];\n\ttas->txpwr_history[tas->cur_idx] = txpwr;\n\trtw89_debug(rtwdev, RTW89_DBG_SAR,\n\t\t    \"instant_txpwr: %d, tx_ratio: %d, txpwr: %d\\n\",\n\t\t    instant_txpwr, env->ifs_clm_tx_ratio, txpwr);\n\n\ttas->cur_idx = (tas->cur_idx + 1) % RTW89_TAS_MAX_WINDOW;\n\n\trtw89_tas_state_update(rtwdev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}