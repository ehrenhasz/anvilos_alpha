{
  "module_name": "phy.c",
  "hash_id": "92abde39c2252e3d1d4e5cc67fc34955b44bf63e35b739f24ce31e007b5df725",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtw89/phy.c",
  "human_readable_source": "\n \n\n#include \"coex.h\"\n#include \"debug.h\"\n#include \"fw.h\"\n#include \"mac.h\"\n#include \"phy.h\"\n#include \"ps.h\"\n#include \"reg.h\"\n#include \"sar.h\"\n#include \"txrx.h\"\n#include \"util.h\"\n\nstatic u16 get_max_amsdu_len(struct rtw89_dev *rtwdev,\n\t\t\t     const struct rtw89_ra_report *report)\n{\n\tu32 bit_rate = report->bit_rate;\n\n\t \n\tif (bit_rate < 550)\n\t\treturn 1;\n\n\t \n\tif (report->might_fallback_legacy)\n\t\treturn 1;\n\n\t \n\tif (bit_rate < 1800)\n\t\treturn 1200;\n\n\t \n\tif (bit_rate < 4000)\n\t\treturn 2600;\n\n\t \n\tif (bit_rate < 7000)\n\t\treturn 3500;\n\n\treturn rtwdev->chip->max_amsdu_limit;\n}\n\nstatic u64 get_mcs_ra_mask(u16 mcs_map, u8 highest_mcs, u8 gap)\n{\n\tu64 ra_mask = 0;\n\tu8 mcs_cap;\n\tint i, nss;\n\n\tfor (i = 0, nss = 12; i < 4; i++, mcs_map >>= 2, nss += 12) {\n\t\tmcs_cap = mcs_map & 0x3;\n\t\tswitch (mcs_cap) {\n\t\tcase 2:\n\t\t\tra_mask |= GENMASK_ULL(highest_mcs, 0) << nss;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tra_mask |= GENMASK_ULL(highest_mcs - gap, 0) << nss;\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\tra_mask |= GENMASK_ULL(highest_mcs - gap * 2, 0) << nss;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ra_mask;\n}\n\nstatic u64 get_he_ra_mask(struct ieee80211_sta *sta)\n{\n\tstruct ieee80211_sta_he_cap cap = sta->deflink.he_cap;\n\tu16 mcs_map;\n\n\tswitch (sta->deflink.bandwidth) {\n\tcase IEEE80211_STA_RX_BW_160:\n\t\tif (cap.he_cap_elem.phy_cap_info[0] &\n\t\t    IEEE80211_HE_PHY_CAP0_CHANNEL_WIDTH_SET_80PLUS80_MHZ_IN_5G)\n\t\t\tmcs_map = le16_to_cpu(cap.he_mcs_nss_supp.rx_mcs_80p80);\n\t\telse\n\t\t\tmcs_map = le16_to_cpu(cap.he_mcs_nss_supp.rx_mcs_160);\n\t\tbreak;\n\tdefault:\n\t\tmcs_map = le16_to_cpu(cap.he_mcs_nss_supp.rx_mcs_80);\n\t}\n\n\t \n\treturn get_mcs_ra_mask(mcs_map, 11, 2);\n}\n\n#define RA_FLOOR_TABLE_SIZE\t7\n#define RA_FLOOR_UP_GAP\t\t3\nstatic u64 rtw89_phy_ra_mask_rssi(struct rtw89_dev *rtwdev, u8 rssi,\n\t\t\t\t  u8 ratr_state)\n{\n\tu8 rssi_lv_t[RA_FLOOR_TABLE_SIZE] = {30, 44, 48, 52, 56, 60, 100};\n\tu8 rssi_lv = 0;\n\tu8 i;\n\n\trssi >>= 1;\n\tfor (i = 0; i < RA_FLOOR_TABLE_SIZE; i++) {\n\t\tif (i >= ratr_state)\n\t\t\trssi_lv_t[i] += RA_FLOOR_UP_GAP;\n\t\tif (rssi < rssi_lv_t[i]) {\n\t\t\trssi_lv = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (rssi_lv == 0)\n\t\treturn 0xffffffffffffffffULL;\n\telse if (rssi_lv == 1)\n\t\treturn 0xfffffffffffffff0ULL;\n\telse if (rssi_lv == 2)\n\t\treturn 0xffffffffffffefe0ULL;\n\telse if (rssi_lv == 3)\n\t\treturn 0xffffffffffffcfc0ULL;\n\telse if (rssi_lv == 4)\n\t\treturn 0xffffffffffff8f80ULL;\n\telse if (rssi_lv >= 5)\n\t\treturn 0xffffffffffff0f00ULL;\n\n\treturn 0xffffffffffffffffULL;\n}\n\nstatic u64 rtw89_phy_ra_mask_recover(u64 ra_mask, u64 ra_mask_bak)\n{\n\tif ((ra_mask & ~(RA_MASK_CCK_RATES | RA_MASK_OFDM_RATES)) == 0)\n\t\tra_mask |= (ra_mask_bak & ~(RA_MASK_CCK_RATES | RA_MASK_OFDM_RATES));\n\n\tif (ra_mask == 0)\n\t\tra_mask |= (ra_mask_bak & (RA_MASK_CCK_RATES | RA_MASK_OFDM_RATES));\n\n\treturn ra_mask;\n}\n\nstatic u64 rtw89_phy_ra_mask_cfg(struct rtw89_dev *rtwdev, struct rtw89_sta *rtwsta,\n\t\t\t\t const struct rtw89_chan *chan)\n{\n\tstruct ieee80211_sta *sta = rtwsta_to_sta(rtwsta);\n\tstruct cfg80211_bitrate_mask *mask = &rtwsta->mask;\n\tenum nl80211_band band;\n\tu64 cfg_mask;\n\n\tif (!rtwsta->use_cfg_mask)\n\t\treturn -1;\n\n\tswitch (chan->band_type) {\n\tcase RTW89_BAND_2G:\n\t\tband = NL80211_BAND_2GHZ;\n\t\tcfg_mask = u64_encode_bits(mask->control[NL80211_BAND_2GHZ].legacy,\n\t\t\t\t\t   RA_MASK_CCK_RATES | RA_MASK_OFDM_RATES);\n\t\tbreak;\n\tcase RTW89_BAND_5G:\n\t\tband = NL80211_BAND_5GHZ;\n\t\tcfg_mask = u64_encode_bits(mask->control[NL80211_BAND_5GHZ].legacy,\n\t\t\t\t\t   RA_MASK_OFDM_RATES);\n\t\tbreak;\n\tcase RTW89_BAND_6G:\n\t\tband = NL80211_BAND_6GHZ;\n\t\tcfg_mask = u64_encode_bits(mask->control[NL80211_BAND_6GHZ].legacy,\n\t\t\t\t\t   RA_MASK_OFDM_RATES);\n\t\tbreak;\n\tdefault:\n\t\trtw89_warn(rtwdev, \"unhandled band type %d\\n\", chan->band_type);\n\t\treturn -1;\n\t}\n\n\tif (sta->deflink.he_cap.has_he) {\n\t\tcfg_mask |= u64_encode_bits(mask->control[band].he_mcs[0],\n\t\t\t\t\t    RA_MASK_HE_1SS_RATES);\n\t\tcfg_mask |= u64_encode_bits(mask->control[band].he_mcs[1],\n\t\t\t\t\t    RA_MASK_HE_2SS_RATES);\n\t} else if (sta->deflink.vht_cap.vht_supported) {\n\t\tcfg_mask |= u64_encode_bits(mask->control[band].vht_mcs[0],\n\t\t\t\t\t    RA_MASK_VHT_1SS_RATES);\n\t\tcfg_mask |= u64_encode_bits(mask->control[band].vht_mcs[1],\n\t\t\t\t\t    RA_MASK_VHT_2SS_RATES);\n\t} else if (sta->deflink.ht_cap.ht_supported) {\n\t\tcfg_mask |= u64_encode_bits(mask->control[band].ht_mcs[0],\n\t\t\t\t\t    RA_MASK_HT_1SS_RATES);\n\t\tcfg_mask |= u64_encode_bits(mask->control[band].ht_mcs[1],\n\t\t\t\t\t    RA_MASK_HT_2SS_RATES);\n\t}\n\n\treturn cfg_mask;\n}\n\nstatic const u64\nrtw89_ra_mask_ht_rates[4] = {RA_MASK_HT_1SS_RATES, RA_MASK_HT_2SS_RATES,\n\t\t\t     RA_MASK_HT_3SS_RATES, RA_MASK_HT_4SS_RATES};\nstatic const u64\nrtw89_ra_mask_vht_rates[4] = {RA_MASK_VHT_1SS_RATES, RA_MASK_VHT_2SS_RATES,\n\t\t\t      RA_MASK_VHT_3SS_RATES, RA_MASK_VHT_4SS_RATES};\nstatic const u64\nrtw89_ra_mask_he_rates[4] = {RA_MASK_HE_1SS_RATES, RA_MASK_HE_2SS_RATES,\n\t\t\t     RA_MASK_HE_3SS_RATES, RA_MASK_HE_4SS_RATES};\n\nstatic void rtw89_phy_ra_gi_ltf(struct rtw89_dev *rtwdev,\n\t\t\t\tstruct rtw89_sta *rtwsta,\n\t\t\t\tconst struct rtw89_chan *chan,\n\t\t\t\tbool *fix_giltf_en, u8 *fix_giltf)\n{\n\tstruct cfg80211_bitrate_mask *mask = &rtwsta->mask;\n\tu8 band = chan->band_type;\n\tenum nl80211_band nl_band = rtw89_hw_to_nl80211_band(band);\n\tu8 he_gi = mask->control[nl_band].he_gi;\n\tu8 he_ltf = mask->control[nl_band].he_ltf;\n\n\tif (!rtwsta->use_cfg_mask)\n\t\treturn;\n\n\tif (he_ltf == 2 && he_gi == 2) {\n\t\t*fix_giltf = RTW89_GILTF_LGI_4XHE32;\n\t} else if (he_ltf == 2 && he_gi == 0) {\n\t\t*fix_giltf = RTW89_GILTF_SGI_4XHE08;\n\t} else if (he_ltf == 1 && he_gi == 1) {\n\t\t*fix_giltf = RTW89_GILTF_2XHE16;\n\t} else if (he_ltf == 1 && he_gi == 0) {\n\t\t*fix_giltf = RTW89_GILTF_2XHE08;\n\t} else if (he_ltf == 0 && he_gi == 1) {\n\t\t*fix_giltf = RTW89_GILTF_1XHE16;\n\t} else if (he_ltf == 0 && he_gi == 0) {\n\t\t*fix_giltf = RTW89_GILTF_1XHE08;\n\t} else {\n\t\t*fix_giltf_en = false;\n\t\treturn;\n\t}\n\n\t*fix_giltf_en = true;\n}\n\nstatic void rtw89_phy_ra_sta_update(struct rtw89_dev *rtwdev,\n\t\t\t\t    struct ieee80211_sta *sta, bool csi)\n{\n\tstruct rtw89_sta *rtwsta = (struct rtw89_sta *)sta->drv_priv;\n\tstruct rtw89_vif *rtwvif = rtwsta->rtwvif;\n\tstruct rtw89_phy_rate_pattern *rate_pattern = &rtwvif->rate_pattern;\n\tstruct rtw89_ra_info *ra = &rtwsta->ra;\n\tconst struct rtw89_chan *chan = rtw89_chan_get(rtwdev,\n\t\t\t\t\t\t       rtwvif->sub_entity_idx);\n\tstruct ieee80211_vif *vif = rtwvif_to_vif(rtwsta->rtwvif);\n\tconst u64 *high_rate_masks = rtw89_ra_mask_ht_rates;\n\tu8 rssi = ewma_rssi_read(&rtwsta->avg_rssi);\n\tu64 ra_mask = 0;\n\tu64 ra_mask_bak;\n\tu8 mode = 0;\n\tu8 csi_mode = RTW89_RA_RPT_MODE_LEGACY;\n\tu8 bw_mode = 0;\n\tu8 stbc_en = 0;\n\tu8 ldpc_en = 0;\n\tu8 fix_giltf = 0;\n\tu8 i;\n\tbool sgi = false;\n\tbool fix_giltf_en = false;\n\n\tmemset(ra, 0, sizeof(*ra));\n\t \n\tif (sta->deflink.he_cap.has_he) {\n\t\tmode |= RTW89_RA_MODE_HE;\n\t\tcsi_mode = RTW89_RA_RPT_MODE_HE;\n\t\tra_mask |= get_he_ra_mask(sta);\n\t\thigh_rate_masks = rtw89_ra_mask_he_rates;\n\t\tif (sta->deflink.he_cap.he_cap_elem.phy_cap_info[2] &\n\t\t    IEEE80211_HE_PHY_CAP2_STBC_RX_UNDER_80MHZ)\n\t\t\tstbc_en = 1;\n\t\tif (sta->deflink.he_cap.he_cap_elem.phy_cap_info[1] &\n\t\t    IEEE80211_HE_PHY_CAP1_LDPC_CODING_IN_PAYLOAD)\n\t\t\tldpc_en = 1;\n\t\trtw89_phy_ra_gi_ltf(rtwdev, rtwsta, chan, &fix_giltf_en, &fix_giltf);\n\t} else if (sta->deflink.vht_cap.vht_supported) {\n\t\tu16 mcs_map = le16_to_cpu(sta->deflink.vht_cap.vht_mcs.rx_mcs_map);\n\n\t\tmode |= RTW89_RA_MODE_VHT;\n\t\tcsi_mode = RTW89_RA_RPT_MODE_VHT;\n\t\t \n\t\tra_mask |= get_mcs_ra_mask(mcs_map, 9, 1);\n\t\thigh_rate_masks = rtw89_ra_mask_vht_rates;\n\t\tif (sta->deflink.vht_cap.cap & IEEE80211_VHT_CAP_RXSTBC_MASK)\n\t\t\tstbc_en = 1;\n\t\tif (sta->deflink.vht_cap.cap & IEEE80211_VHT_CAP_RXLDPC)\n\t\t\tldpc_en = 1;\n\t} else if (sta->deflink.ht_cap.ht_supported) {\n\t\tmode |= RTW89_RA_MODE_HT;\n\t\tcsi_mode = RTW89_RA_RPT_MODE_HT;\n\t\tra_mask |= ((u64)sta->deflink.ht_cap.mcs.rx_mask[3] << 48) |\n\t\t\t   ((u64)sta->deflink.ht_cap.mcs.rx_mask[2] << 36) |\n\t\t\t   (sta->deflink.ht_cap.mcs.rx_mask[1] << 24) |\n\t\t\t   (sta->deflink.ht_cap.mcs.rx_mask[0] << 12);\n\t\thigh_rate_masks = rtw89_ra_mask_ht_rates;\n\t\tif (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_RX_STBC)\n\t\t\tstbc_en = 1;\n\t\tif (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_LDPC_CODING)\n\t\t\tldpc_en = 1;\n\t}\n\n\tswitch (chan->band_type) {\n\tcase RTW89_BAND_2G:\n\t\tra_mask |= sta->deflink.supp_rates[NL80211_BAND_2GHZ];\n\t\tif (sta->deflink.supp_rates[NL80211_BAND_2GHZ] & 0xf)\n\t\t\tmode |= RTW89_RA_MODE_CCK;\n\t\tif (sta->deflink.supp_rates[NL80211_BAND_2GHZ] & 0xff0)\n\t\t\tmode |= RTW89_RA_MODE_OFDM;\n\t\tbreak;\n\tcase RTW89_BAND_5G:\n\t\tra_mask |= (u64)sta->deflink.supp_rates[NL80211_BAND_5GHZ] << 4;\n\t\tmode |= RTW89_RA_MODE_OFDM;\n\t\tbreak;\n\tcase RTW89_BAND_6G:\n\t\tra_mask |= (u64)sta->deflink.supp_rates[NL80211_BAND_6GHZ] << 4;\n\t\tmode |= RTW89_RA_MODE_OFDM;\n\t\tbreak;\n\tdefault:\n\t\trtw89_err(rtwdev, \"Unknown band type\\n\");\n\t\tbreak;\n\t}\n\n\tra_mask_bak = ra_mask;\n\n\tif (mode >= RTW89_RA_MODE_HT) {\n\t\tu64 mask = 0;\n\t\tfor (i = 0; i < rtwdev->hal.tx_nss; i++)\n\t\t\tmask |= high_rate_masks[i];\n\t\tif (mode & RTW89_RA_MODE_OFDM)\n\t\t\tmask |= RA_MASK_SUBOFDM_RATES;\n\t\tif (mode & RTW89_RA_MODE_CCK)\n\t\t\tmask |= RA_MASK_SUBCCK_RATES;\n\t\tra_mask &= mask;\n\t} else if (mode & RTW89_RA_MODE_OFDM) {\n\t\tra_mask &= (RA_MASK_OFDM_RATES | RA_MASK_SUBCCK_RATES);\n\t}\n\n\tif (mode != RTW89_RA_MODE_CCK)\n\t\tra_mask &= rtw89_phy_ra_mask_rssi(rtwdev, rssi, 0);\n\n\tra_mask = rtw89_phy_ra_mask_recover(ra_mask, ra_mask_bak);\n\tra_mask &= rtw89_phy_ra_mask_cfg(rtwdev, rtwsta, chan);\n\n\tswitch (sta->deflink.bandwidth) {\n\tcase IEEE80211_STA_RX_BW_160:\n\t\tbw_mode = RTW89_CHANNEL_WIDTH_160;\n\t\tsgi = sta->deflink.vht_cap.vht_supported &&\n\t\t      (sta->deflink.vht_cap.cap & IEEE80211_VHT_CAP_SHORT_GI_160);\n\t\tbreak;\n\tcase IEEE80211_STA_RX_BW_80:\n\t\tbw_mode = RTW89_CHANNEL_WIDTH_80;\n\t\tsgi = sta->deflink.vht_cap.vht_supported &&\n\t\t      (sta->deflink.vht_cap.cap & IEEE80211_VHT_CAP_SHORT_GI_80);\n\t\tbreak;\n\tcase IEEE80211_STA_RX_BW_40:\n\t\tbw_mode = RTW89_CHANNEL_WIDTH_40;\n\t\tsgi = sta->deflink.ht_cap.ht_supported &&\n\t\t      (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_SGI_40);\n\t\tbreak;\n\tdefault:\n\t\tbw_mode = RTW89_CHANNEL_WIDTH_20;\n\t\tsgi = sta->deflink.ht_cap.ht_supported &&\n\t\t      (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_SGI_20);\n\t\tbreak;\n\t}\n\n\tif (sta->deflink.he_cap.he_cap_elem.phy_cap_info[3] &\n\t    IEEE80211_HE_PHY_CAP3_DCM_MAX_CONST_RX_16_QAM)\n\t\tra->dcm_cap = 1;\n\n\tif (rate_pattern->enable && !vif->p2p) {\n\t\tra_mask = rtw89_phy_ra_mask_cfg(rtwdev, rtwsta, chan);\n\t\tra_mask &= rate_pattern->ra_mask;\n\t\tmode = rate_pattern->ra_mode;\n\t}\n\n\tra->bw_cap = bw_mode;\n\tra->er_cap = rtwsta->er_cap;\n\tra->mode_ctrl = mode;\n\tra->macid = rtwsta->mac_id;\n\tra->stbc_cap = stbc_en;\n\tra->ldpc_cap = ldpc_en;\n\tra->ss_num = min(sta->deflink.rx_nss, rtwdev->hal.tx_nss) - 1;\n\tra->en_sgi = sgi;\n\tra->ra_mask = ra_mask;\n\tra->fix_giltf_en = fix_giltf_en;\n\tra->fix_giltf = fix_giltf;\n\n\tif (!csi)\n\t\treturn;\n\n\tra->fixed_csi_rate_en = false;\n\tra->ra_csi_rate_en = true;\n\tra->cr_tbl_sel = false;\n\tra->band_num = rtwvif->phy_idx;\n\tra->csi_bw = bw_mode;\n\tra->csi_gi_ltf = RTW89_GILTF_LGI_4XHE32;\n\tra->csi_mcs_ss_idx = 5;\n\tra->csi_mode = csi_mode;\n}\n\nvoid rtw89_phy_ra_updata_sta(struct rtw89_dev *rtwdev, struct ieee80211_sta *sta,\n\t\t\t     u32 changed)\n{\n\tstruct rtw89_sta *rtwsta = (struct rtw89_sta *)sta->drv_priv;\n\tstruct rtw89_ra_info *ra = &rtwsta->ra;\n\n\trtw89_phy_ra_sta_update(rtwdev, sta, false);\n\n\tif (changed & IEEE80211_RC_SUPP_RATES_CHANGED)\n\t\tra->upd_mask = 1;\n\tif (changed & (IEEE80211_RC_BW_CHANGED | IEEE80211_RC_NSS_CHANGED))\n\t\tra->upd_bw_nss_mask = 1;\n\n\trtw89_debug(rtwdev, RTW89_DBG_RA,\n\t\t    \"ra updat: macid = %d, bw = %d, nss = %d, gi = %d %d\",\n\t\t    ra->macid,\n\t\t    ra->bw_cap,\n\t\t    ra->ss_num,\n\t\t    ra->en_sgi,\n\t\t    ra->giltf);\n\n\trtw89_fw_h2c_ra(rtwdev, ra, false);\n}\n\nstatic bool __check_rate_pattern(struct rtw89_phy_rate_pattern *next,\n\t\t\t\t u16 rate_base, u64 ra_mask, u8 ra_mode,\n\t\t\t\t u32 rate_ctrl, u32 ctrl_skip, bool force)\n{\n\tu8 n, c;\n\n\tif (rate_ctrl == ctrl_skip)\n\t\treturn true;\n\n\tn = hweight32(rate_ctrl);\n\tif (n == 0)\n\t\treturn true;\n\n\tif (force && n != 1)\n\t\treturn false;\n\n\tif (next->enable)\n\t\treturn false;\n\n\tc = __fls(rate_ctrl);\n\tnext->rate = rate_base + c;\n\tnext->ra_mode = ra_mode;\n\tnext->ra_mask = ra_mask;\n\tnext->enable = true;\n\n\treturn true;\n}\n\n#define RTW89_HW_RATE_BY_CHIP_GEN(rate) \\\n\t{ \\\n\t\t[RTW89_CHIP_AX] = RTW89_HW_RATE_ ## rate, \\\n\t\t[RTW89_CHIP_BE] = RTW89_HW_RATE_V1_ ## rate, \\\n\t}\n\nvoid rtw89_phy_rate_pattern_vif(struct rtw89_dev *rtwdev,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tconst struct cfg80211_bitrate_mask *mask)\n{\n\tstruct ieee80211_supported_band *sband;\n\tstruct rtw89_vif *rtwvif = (struct rtw89_vif *)vif->drv_priv;\n\tstruct rtw89_phy_rate_pattern next_pattern = {0};\n\tconst struct rtw89_chan *chan = rtw89_chan_get(rtwdev,\n\t\t\t\t\t\t       rtwvif->sub_entity_idx);\n\tstatic const u16 hw_rate_he[][RTW89_CHIP_GEN_NUM] = {\n\t\tRTW89_HW_RATE_BY_CHIP_GEN(HE_NSS1_MCS0),\n\t\tRTW89_HW_RATE_BY_CHIP_GEN(HE_NSS2_MCS0),\n\t\tRTW89_HW_RATE_BY_CHIP_GEN(HE_NSS3_MCS0),\n\t\tRTW89_HW_RATE_BY_CHIP_GEN(HE_NSS4_MCS0),\n\t};\n\tstatic const u16 hw_rate_vht[][RTW89_CHIP_GEN_NUM] = {\n\t\tRTW89_HW_RATE_BY_CHIP_GEN(VHT_NSS1_MCS0),\n\t\tRTW89_HW_RATE_BY_CHIP_GEN(VHT_NSS2_MCS0),\n\t\tRTW89_HW_RATE_BY_CHIP_GEN(VHT_NSS3_MCS0),\n\t\tRTW89_HW_RATE_BY_CHIP_GEN(VHT_NSS4_MCS0),\n\t};\n\tstatic const u16 hw_rate_ht[][RTW89_CHIP_GEN_NUM] = {\n\t\tRTW89_HW_RATE_BY_CHIP_GEN(MCS0),\n\t\tRTW89_HW_RATE_BY_CHIP_GEN(MCS8),\n\t\tRTW89_HW_RATE_BY_CHIP_GEN(MCS16),\n\t\tRTW89_HW_RATE_BY_CHIP_GEN(MCS24),\n\t};\n\tu8 band = chan->band_type;\n\tenum nl80211_band nl_band = rtw89_hw_to_nl80211_band(band);\n\tenum rtw89_chip_gen chip_gen = rtwdev->chip->chip_gen;\n\tu8 tx_nss = rtwdev->hal.tx_nss;\n\tu8 i;\n\n\tfor (i = 0; i < tx_nss; i++)\n\t\tif (!__check_rate_pattern(&next_pattern, hw_rate_he[i][chip_gen],\n\t\t\t\t\t  RA_MASK_HE_RATES, RTW89_RA_MODE_HE,\n\t\t\t\t\t  mask->control[nl_band].he_mcs[i],\n\t\t\t\t\t  0, true))\n\t\t\tgoto out;\n\n\tfor (i = 0; i < tx_nss; i++)\n\t\tif (!__check_rate_pattern(&next_pattern, hw_rate_vht[i][chip_gen],\n\t\t\t\t\t  RA_MASK_VHT_RATES, RTW89_RA_MODE_VHT,\n\t\t\t\t\t  mask->control[nl_band].vht_mcs[i],\n\t\t\t\t\t  0, true))\n\t\t\tgoto out;\n\n\tfor (i = 0; i < tx_nss; i++)\n\t\tif (!__check_rate_pattern(&next_pattern, hw_rate_ht[i][chip_gen],\n\t\t\t\t\t  RA_MASK_HT_RATES, RTW89_RA_MODE_HT,\n\t\t\t\t\t  mask->control[nl_band].ht_mcs[i],\n\t\t\t\t\t  0, true))\n\t\t\tgoto out;\n\n\t \n\tsband = rtwdev->hw->wiphy->bands[nl_band];\n\tif (band == RTW89_BAND_2G) {\n\t\tif (!__check_rate_pattern(&next_pattern, RTW89_HW_RATE_CCK1,\n\t\t\t\t\t  RA_MASK_CCK_RATES | RA_MASK_OFDM_RATES,\n\t\t\t\t\t  RTW89_RA_MODE_CCK | RTW89_RA_MODE_OFDM,\n\t\t\t\t\t  mask->control[nl_band].legacy,\n\t\t\t\t\t  BIT(sband->n_bitrates) - 1, false))\n\t\t\tgoto out;\n\t} else {\n\t\tif (!__check_rate_pattern(&next_pattern, RTW89_HW_RATE_OFDM6,\n\t\t\t\t\t  RA_MASK_OFDM_RATES, RTW89_RA_MODE_OFDM,\n\t\t\t\t\t  mask->control[nl_band].legacy,\n\t\t\t\t\t  BIT(sband->n_bitrates) - 1, false))\n\t\t\tgoto out;\n\t}\n\n\tif (!next_pattern.enable)\n\t\tgoto out;\n\n\trtwvif->rate_pattern = next_pattern;\n\trtw89_debug(rtwdev, RTW89_DBG_RA,\n\t\t    \"configure pattern: rate 0x%x, mask 0x%llx, mode 0x%x\\n\",\n\t\t    next_pattern.rate,\n\t\t    next_pattern.ra_mask,\n\t\t    next_pattern.ra_mode);\n\treturn;\n\nout:\n\trtwvif->rate_pattern.enable = false;\n\trtw89_debug(rtwdev, RTW89_DBG_RA, \"unset rate pattern\\n\");\n}\n\nstatic void rtw89_phy_ra_updata_sta_iter(void *data, struct ieee80211_sta *sta)\n{\n\tstruct rtw89_dev *rtwdev = (struct rtw89_dev *)data;\n\n\trtw89_phy_ra_updata_sta(rtwdev, sta, IEEE80211_RC_SUPP_RATES_CHANGED);\n}\n\nvoid rtw89_phy_ra_update(struct rtw89_dev *rtwdev)\n{\n\tieee80211_iterate_stations_atomic(rtwdev->hw,\n\t\t\t\t\t  rtw89_phy_ra_updata_sta_iter,\n\t\t\t\t\t  rtwdev);\n}\n\nvoid rtw89_phy_ra_assoc(struct rtw89_dev *rtwdev, struct ieee80211_sta *sta)\n{\n\tstruct rtw89_sta *rtwsta = (struct rtw89_sta *)sta->drv_priv;\n\tstruct rtw89_ra_info *ra = &rtwsta->ra;\n\tu8 rssi = ewma_rssi_read(&rtwsta->avg_rssi) >> RSSI_FACTOR;\n\tbool csi = rtw89_sta_has_beamformer_cap(sta);\n\n\trtw89_phy_ra_sta_update(rtwdev, sta, csi);\n\n\tif (rssi > 40)\n\t\tra->init_rate_lv = 1;\n\telse if (rssi > 20)\n\t\tra->init_rate_lv = 2;\n\telse if (rssi > 1)\n\t\tra->init_rate_lv = 3;\n\telse\n\t\tra->init_rate_lv = 0;\n\tra->upd_all = 1;\n\trtw89_debug(rtwdev, RTW89_DBG_RA,\n\t\t    \"ra assoc: macid = %d, mode = %d, bw = %d, nss = %d, lv = %d\",\n\t\t    ra->macid,\n\t\t    ra->mode_ctrl,\n\t\t    ra->bw_cap,\n\t\t    ra->ss_num,\n\t\t    ra->init_rate_lv);\n\trtw89_debug(rtwdev, RTW89_DBG_RA,\n\t\t    \"ra assoc: dcm = %d, er = %d, ldpc = %d, stbc = %d, gi = %d %d\",\n\t\t    ra->dcm_cap,\n\t\t    ra->er_cap,\n\t\t    ra->ldpc_cap,\n\t\t    ra->stbc_cap,\n\t\t    ra->en_sgi,\n\t\t    ra->giltf);\n\n\trtw89_fw_h2c_ra(rtwdev, ra, csi);\n}\n\nu8 rtw89_phy_get_txsc(struct rtw89_dev *rtwdev,\n\t\t      const struct rtw89_chan *chan,\n\t\t      enum rtw89_bandwidth dbw)\n{\n\tenum rtw89_bandwidth cbw = chan->band_width;\n\tu8 pri_ch = chan->primary_channel;\n\tu8 central_ch = chan->channel;\n\tu8 txsc_idx = 0;\n\tu8 tmp = 0;\n\n\tif (cbw == dbw || cbw == RTW89_CHANNEL_WIDTH_20)\n\t\treturn txsc_idx;\n\n\tswitch (cbw) {\n\tcase RTW89_CHANNEL_WIDTH_40:\n\t\ttxsc_idx = pri_ch > central_ch ? 1 : 2;\n\t\tbreak;\n\tcase RTW89_CHANNEL_WIDTH_80:\n\t\tif (dbw == RTW89_CHANNEL_WIDTH_20) {\n\t\t\tif (pri_ch > central_ch)\n\t\t\t\ttxsc_idx = (pri_ch - central_ch) >> 1;\n\t\t\telse\n\t\t\t\ttxsc_idx = ((central_ch - pri_ch) >> 1) + 1;\n\t\t} else {\n\t\t\ttxsc_idx = pri_ch > central_ch ? 9 : 10;\n\t\t}\n\t\tbreak;\n\tcase RTW89_CHANNEL_WIDTH_160:\n\t\tif (pri_ch > central_ch)\n\t\t\ttmp = (pri_ch - central_ch) >> 1;\n\t\telse\n\t\t\ttmp = ((central_ch - pri_ch) >> 1) + 1;\n\n\t\tif (dbw == RTW89_CHANNEL_WIDTH_20) {\n\t\t\ttxsc_idx = tmp;\n\t\t} else if (dbw == RTW89_CHANNEL_WIDTH_40) {\n\t\t\tif (tmp == 1 || tmp == 3)\n\t\t\t\ttxsc_idx = 9;\n\t\t\telse if (tmp == 5 || tmp == 7)\n\t\t\t\ttxsc_idx = 11;\n\t\t\telse if (tmp == 2 || tmp == 4)\n\t\t\t\ttxsc_idx = 10;\n\t\t\telse if (tmp == 6 || tmp == 8)\n\t\t\t\ttxsc_idx = 12;\n\t\t\telse\n\t\t\t\treturn 0xff;\n\t\t} else {\n\t\t\ttxsc_idx = pri_ch > central_ch ? 13 : 14;\n\t\t}\n\t\tbreak;\n\tcase RTW89_CHANNEL_WIDTH_80_80:\n\t\tif (dbw == RTW89_CHANNEL_WIDTH_20) {\n\t\t\tif (pri_ch > central_ch)\n\t\t\t\ttxsc_idx = (10 - (pri_ch - central_ch)) >> 1;\n\t\t\telse\n\t\t\t\ttxsc_idx = ((central_ch - pri_ch) >> 1) + 5;\n\t\t} else if (dbw == RTW89_CHANNEL_WIDTH_40) {\n\t\t\ttxsc_idx = pri_ch > central_ch ? 10 : 12;\n\t\t} else {\n\t\t\ttxsc_idx = 14;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn txsc_idx;\n}\nEXPORT_SYMBOL(rtw89_phy_get_txsc);\n\nstatic bool rtw89_phy_check_swsi_busy(struct rtw89_dev *rtwdev)\n{\n\treturn !!rtw89_phy_read32_mask(rtwdev, R_SWSI_V1, B_SWSI_W_BUSY_V1) ||\n\t       !!rtw89_phy_read32_mask(rtwdev, R_SWSI_V1, B_SWSI_R_BUSY_V1);\n}\n\nu32 rtw89_phy_read_rf(struct rtw89_dev *rtwdev, enum rtw89_rf_path rf_path,\n\t\t      u32 addr, u32 mask)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tconst u32 *base_addr = chip->rf_base_addr;\n\tu32 val, direct_addr;\n\n\tif (rf_path >= rtwdev->chip->rf_path_num) {\n\t\trtw89_err(rtwdev, \"unsupported rf path (%d)\\n\", rf_path);\n\t\treturn INV_RF_DATA;\n\t}\n\n\taddr &= 0xff;\n\tdirect_addr = base_addr[rf_path] + (addr << 2);\n\tmask &= RFREG_MASK;\n\n\tval = rtw89_phy_read32_mask(rtwdev, direct_addr, mask);\n\n\treturn val;\n}\nEXPORT_SYMBOL(rtw89_phy_read_rf);\n\nstatic u32 rtw89_phy_read_rf_a(struct rtw89_dev *rtwdev,\n\t\t\t       enum rtw89_rf_path rf_path, u32 addr, u32 mask)\n{\n\tbool busy;\n\tbool done;\n\tu32 val;\n\tint ret;\n\n\tret = read_poll_timeout_atomic(rtw89_phy_check_swsi_busy, busy, !busy,\n\t\t\t\t       1, 30, false, rtwdev);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"read rf busy swsi\\n\");\n\t\treturn INV_RF_DATA;\n\t}\n\n\tmask &= RFREG_MASK;\n\n\tval = FIELD_PREP(B_SWSI_READ_ADDR_PATH_V1, rf_path) |\n\t      FIELD_PREP(B_SWSI_READ_ADDR_ADDR_V1, addr);\n\trtw89_phy_write32_mask(rtwdev, R_SWSI_READ_ADDR_V1, B_SWSI_READ_ADDR_V1, val);\n\tudelay(2);\n\n\tret = read_poll_timeout_atomic(rtw89_phy_read32_mask, done, done, 1,\n\t\t\t\t       30, false, rtwdev, R_SWSI_V1,\n\t\t\t\t       B_SWSI_R_DATA_DONE_V1);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"read swsi busy\\n\");\n\t\treturn INV_RF_DATA;\n\t}\n\n\treturn rtw89_phy_read32_mask(rtwdev, R_SWSI_V1, mask);\n}\n\nu32 rtw89_phy_read_rf_v1(struct rtw89_dev *rtwdev, enum rtw89_rf_path rf_path,\n\t\t\t u32 addr, u32 mask)\n{\n\tbool ad_sel = FIELD_GET(RTW89_RF_ADDR_ADSEL_MASK, addr);\n\n\tif (rf_path >= rtwdev->chip->rf_path_num) {\n\t\trtw89_err(rtwdev, \"unsupported rf path (%d)\\n\", rf_path);\n\t\treturn INV_RF_DATA;\n\t}\n\n\tif (ad_sel)\n\t\treturn rtw89_phy_read_rf(rtwdev, rf_path, addr, mask);\n\telse\n\t\treturn rtw89_phy_read_rf_a(rtwdev, rf_path, addr, mask);\n}\nEXPORT_SYMBOL(rtw89_phy_read_rf_v1);\n\nbool rtw89_phy_write_rf(struct rtw89_dev *rtwdev, enum rtw89_rf_path rf_path,\n\t\t\tu32 addr, u32 mask, u32 data)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tconst u32 *base_addr = chip->rf_base_addr;\n\tu32 direct_addr;\n\n\tif (rf_path >= rtwdev->chip->rf_path_num) {\n\t\trtw89_err(rtwdev, \"unsupported rf path (%d)\\n\", rf_path);\n\t\treturn false;\n\t}\n\n\taddr &= 0xff;\n\tdirect_addr = base_addr[rf_path] + (addr << 2);\n\tmask &= RFREG_MASK;\n\n\trtw89_phy_write32_mask(rtwdev, direct_addr, mask, data);\n\n\t \n\tudelay(1);\n\n\treturn true;\n}\nEXPORT_SYMBOL(rtw89_phy_write_rf);\n\nstatic bool rtw89_phy_write_rf_a(struct rtw89_dev *rtwdev,\n\t\t\t\t enum rtw89_rf_path rf_path, u32 addr, u32 mask,\n\t\t\t\t u32 data)\n{\n\tu8 bit_shift;\n\tu32 val;\n\tbool busy, b_msk_en = false;\n\tint ret;\n\n\tret = read_poll_timeout_atomic(rtw89_phy_check_swsi_busy, busy, !busy,\n\t\t\t\t       1, 30, false, rtwdev);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"write rf busy swsi\\n\");\n\t\treturn false;\n\t}\n\n\tdata &= RFREG_MASK;\n\tmask &= RFREG_MASK;\n\n\tif (mask != RFREG_MASK) {\n\t\tb_msk_en = true;\n\t\trtw89_phy_write32_mask(rtwdev, R_SWSI_BIT_MASK_V1, RFREG_MASK,\n\t\t\t\t       mask);\n\t\tbit_shift = __ffs(mask);\n\t\tdata = (data << bit_shift) & RFREG_MASK;\n\t}\n\n\tval = FIELD_PREP(B_SWSI_DATA_BIT_MASK_EN_V1, b_msk_en) |\n\t      FIELD_PREP(B_SWSI_DATA_PATH_V1, rf_path) |\n\t      FIELD_PREP(B_SWSI_DATA_ADDR_V1, addr) |\n\t      FIELD_PREP(B_SWSI_DATA_VAL_V1, data);\n\n\trtw89_phy_write32_mask(rtwdev, R_SWSI_DATA_V1, MASKDWORD, val);\n\n\treturn true;\n}\n\nbool rtw89_phy_write_rf_v1(struct rtw89_dev *rtwdev, enum rtw89_rf_path rf_path,\n\t\t\t   u32 addr, u32 mask, u32 data)\n{\n\tbool ad_sel = FIELD_GET(RTW89_RF_ADDR_ADSEL_MASK, addr);\n\n\tif (rf_path >= rtwdev->chip->rf_path_num) {\n\t\trtw89_err(rtwdev, \"unsupported rf path (%d)\\n\", rf_path);\n\t\treturn false;\n\t}\n\n\tif (ad_sel)\n\t\treturn rtw89_phy_write_rf(rtwdev, rf_path, addr, mask, data);\n\telse\n\t\treturn rtw89_phy_write_rf_a(rtwdev, rf_path, addr, mask, data);\n}\nEXPORT_SYMBOL(rtw89_phy_write_rf_v1);\n\nstatic bool rtw89_chip_rf_v1(struct rtw89_dev *rtwdev)\n{\n\treturn rtwdev->chip->ops->write_rf == rtw89_phy_write_rf_v1;\n}\n\nstatic void rtw89_phy_bb_reset(struct rtw89_dev *rtwdev,\n\t\t\t       enum rtw89_phy_idx phy_idx)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\n\tchip->ops->bb_reset(rtwdev, phy_idx);\n}\n\nstatic void rtw89_phy_config_bb_reg(struct rtw89_dev *rtwdev,\n\t\t\t\t    const struct rtw89_reg2_def *reg,\n\t\t\t\t    enum rtw89_rf_path rf_path,\n\t\t\t\t    void *extra_data)\n{\n\tif (reg->addr == 0xfe)\n\t\tmdelay(50);\n\telse if (reg->addr == 0xfd)\n\t\tmdelay(5);\n\telse if (reg->addr == 0xfc)\n\t\tmdelay(1);\n\telse if (reg->addr == 0xfb)\n\t\tudelay(50);\n\telse if (reg->addr == 0xfa)\n\t\tudelay(5);\n\telse if (reg->addr == 0xf9)\n\t\tudelay(1);\n\telse\n\t\trtw89_phy_write32(rtwdev, reg->addr, reg->data);\n}\n\nunion rtw89_phy_bb_gain_arg {\n\tu32 addr;\n\tstruct {\n\t\tunion {\n\t\t\tu8 type;\n\t\t\tstruct {\n\t\t\t\tu8 rxsc_start:4;\n\t\t\t\tu8 bw:4;\n\t\t\t};\n\t\t};\n\t\tu8 path;\n\t\tu8 gain_band;\n\t\tu8 cfg_type;\n\t};\n} __packed;\n\nstatic void\nrtw89_phy_cfg_bb_gain_error(struct rtw89_dev *rtwdev,\n\t\t\t    union rtw89_phy_bb_gain_arg arg, u32 data)\n{\n\tstruct rtw89_phy_bb_gain_info *gain = &rtwdev->bb_gain;\n\tu8 type = arg.type;\n\tu8 path = arg.path;\n\tu8 gband = arg.gain_band;\n\tint i;\n\n\tswitch (type) {\n\tcase 0:\n\t\tfor (i = 0; i < 4; i++, data >>= 8)\n\t\t\tgain->lna_gain[gband][path][i] = data & 0xff;\n\t\tbreak;\n\tcase 1:\n\t\tfor (i = 4; i < 7; i++, data >>= 8)\n\t\t\tgain->lna_gain[gband][path][i] = data & 0xff;\n\t\tbreak;\n\tcase 2:\n\t\tfor (i = 0; i < 2; i++, data >>= 8)\n\t\t\tgain->tia_gain[gband][path][i] = data & 0xff;\n\t\tbreak;\n\tdefault:\n\t\trtw89_warn(rtwdev,\n\t\t\t   \"bb gain error {0x%x:0x%x} with unknown type: %d\\n\",\n\t\t\t   arg.addr, data, type);\n\t\tbreak;\n\t}\n}\n\nenum rtw89_phy_bb_rxsc_start_idx {\n\tRTW89_BB_RXSC_START_IDX_FULL = 0,\n\tRTW89_BB_RXSC_START_IDX_20 = 1,\n\tRTW89_BB_RXSC_START_IDX_20_1 = 5,\n\tRTW89_BB_RXSC_START_IDX_40 = 9,\n\tRTW89_BB_RXSC_START_IDX_80 = 13,\n};\n\nstatic void\nrtw89_phy_cfg_bb_rpl_ofst(struct rtw89_dev *rtwdev,\n\t\t\t  union rtw89_phy_bb_gain_arg arg, u32 data)\n{\n\tstruct rtw89_phy_bb_gain_info *gain = &rtwdev->bb_gain;\n\tu8 rxsc_start = arg.rxsc_start;\n\tu8 bw = arg.bw;\n\tu8 path = arg.path;\n\tu8 gband = arg.gain_band;\n\tu8 rxsc;\n\ts8 ofst;\n\tint i;\n\n\tswitch (bw) {\n\tcase RTW89_CHANNEL_WIDTH_20:\n\t\tgain->rpl_ofst_20[gband][path] = (s8)data;\n\t\tbreak;\n\tcase RTW89_CHANNEL_WIDTH_40:\n\t\tif (rxsc_start == RTW89_BB_RXSC_START_IDX_FULL) {\n\t\t\tgain->rpl_ofst_40[gband][path][0] = (s8)data;\n\t\t} else if (rxsc_start == RTW89_BB_RXSC_START_IDX_20) {\n\t\t\tfor (i = 0; i < 2; i++, data >>= 8) {\n\t\t\t\trxsc = RTW89_BB_RXSC_START_IDX_20 + i;\n\t\t\t\tofst = (s8)(data & 0xff);\n\t\t\t\tgain->rpl_ofst_40[gband][path][rxsc] = ofst;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase RTW89_CHANNEL_WIDTH_80:\n\t\tif (rxsc_start == RTW89_BB_RXSC_START_IDX_FULL) {\n\t\t\tgain->rpl_ofst_80[gband][path][0] = (s8)data;\n\t\t} else if (rxsc_start == RTW89_BB_RXSC_START_IDX_20) {\n\t\t\tfor (i = 0; i < 4; i++, data >>= 8) {\n\t\t\t\trxsc = RTW89_BB_RXSC_START_IDX_20 + i;\n\t\t\t\tofst = (s8)(data & 0xff);\n\t\t\t\tgain->rpl_ofst_80[gband][path][rxsc] = ofst;\n\t\t\t}\n\t\t} else if (rxsc_start == RTW89_BB_RXSC_START_IDX_40) {\n\t\t\tfor (i = 0; i < 2; i++, data >>= 8) {\n\t\t\t\trxsc = RTW89_BB_RXSC_START_IDX_40 + i;\n\t\t\t\tofst = (s8)(data & 0xff);\n\t\t\t\tgain->rpl_ofst_80[gband][path][rxsc] = ofst;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase RTW89_CHANNEL_WIDTH_160:\n\t\tif (rxsc_start == RTW89_BB_RXSC_START_IDX_FULL) {\n\t\t\tgain->rpl_ofst_160[gband][path][0] = (s8)data;\n\t\t} else if (rxsc_start == RTW89_BB_RXSC_START_IDX_20) {\n\t\t\tfor (i = 0; i < 4; i++, data >>= 8) {\n\t\t\t\trxsc = RTW89_BB_RXSC_START_IDX_20 + i;\n\t\t\t\tofst = (s8)(data & 0xff);\n\t\t\t\tgain->rpl_ofst_160[gband][path][rxsc] = ofst;\n\t\t\t}\n\t\t} else if (rxsc_start == RTW89_BB_RXSC_START_IDX_20_1) {\n\t\t\tfor (i = 0; i < 4; i++, data >>= 8) {\n\t\t\t\trxsc = RTW89_BB_RXSC_START_IDX_20_1 + i;\n\t\t\t\tofst = (s8)(data & 0xff);\n\t\t\t\tgain->rpl_ofst_160[gband][path][rxsc] = ofst;\n\t\t\t}\n\t\t} else if (rxsc_start == RTW89_BB_RXSC_START_IDX_40) {\n\t\t\tfor (i = 0; i < 4; i++, data >>= 8) {\n\t\t\t\trxsc = RTW89_BB_RXSC_START_IDX_40 + i;\n\t\t\t\tofst = (s8)(data & 0xff);\n\t\t\t\tgain->rpl_ofst_160[gband][path][rxsc] = ofst;\n\t\t\t}\n\t\t} else if (rxsc_start == RTW89_BB_RXSC_START_IDX_80) {\n\t\t\tfor (i = 0; i < 2; i++, data >>= 8) {\n\t\t\t\trxsc = RTW89_BB_RXSC_START_IDX_80 + i;\n\t\t\t\tofst = (s8)(data & 0xff);\n\t\t\t\tgain->rpl_ofst_160[gband][path][rxsc] = ofst;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\trtw89_warn(rtwdev,\n\t\t\t   \"bb rpl ofst {0x%x:0x%x} with unknown bw: %d\\n\",\n\t\t\t   arg.addr, data, bw);\n\t\tbreak;\n\t}\n}\n\nstatic void\nrtw89_phy_cfg_bb_gain_bypass(struct rtw89_dev *rtwdev,\n\t\t\t     union rtw89_phy_bb_gain_arg arg, u32 data)\n{\n\tstruct rtw89_phy_bb_gain_info *gain = &rtwdev->bb_gain;\n\tu8 type = arg.type;\n\tu8 path = arg.path;\n\tu8 gband = arg.gain_band;\n\tint i;\n\n\tswitch (type) {\n\tcase 0:\n\t\tfor (i = 0; i < 4; i++, data >>= 8)\n\t\t\tgain->lna_gain_bypass[gband][path][i] = data & 0xff;\n\t\tbreak;\n\tcase 1:\n\t\tfor (i = 4; i < 7; i++, data >>= 8)\n\t\t\tgain->lna_gain_bypass[gband][path][i] = data & 0xff;\n\t\tbreak;\n\tdefault:\n\t\trtw89_warn(rtwdev,\n\t\t\t   \"bb gain bypass {0x%x:0x%x} with unknown type: %d\\n\",\n\t\t\t   arg.addr, data, type);\n\t\tbreak;\n\t}\n}\n\nstatic void\nrtw89_phy_cfg_bb_gain_op1db(struct rtw89_dev *rtwdev,\n\t\t\t    union rtw89_phy_bb_gain_arg arg, u32 data)\n{\n\tstruct rtw89_phy_bb_gain_info *gain = &rtwdev->bb_gain;\n\tu8 type = arg.type;\n\tu8 path = arg.path;\n\tu8 gband = arg.gain_band;\n\tint i;\n\n\tswitch (type) {\n\tcase 0:\n\t\tfor (i = 0; i < 4; i++, data >>= 8)\n\t\t\tgain->lna_op1db[gband][path][i] = data & 0xff;\n\t\tbreak;\n\tcase 1:\n\t\tfor (i = 4; i < 7; i++, data >>= 8)\n\t\t\tgain->lna_op1db[gband][path][i] = data & 0xff;\n\t\tbreak;\n\tcase 2:\n\t\tfor (i = 0; i < 4; i++, data >>= 8)\n\t\t\tgain->tia_lna_op1db[gband][path][i] = data & 0xff;\n\t\tbreak;\n\tcase 3:\n\t\tfor (i = 4; i < 8; i++, data >>= 8)\n\t\t\tgain->tia_lna_op1db[gband][path][i] = data & 0xff;\n\t\tbreak;\n\tdefault:\n\t\trtw89_warn(rtwdev,\n\t\t\t   \"bb gain op1db {0x%x:0x%x} with unknown type: %d\\n\",\n\t\t\t   arg.addr, data, type);\n\t\tbreak;\n\t}\n}\n\nstatic void rtw89_phy_config_bb_gain(struct rtw89_dev *rtwdev,\n\t\t\t\t     const struct rtw89_reg2_def *reg,\n\t\t\t\t     enum rtw89_rf_path rf_path,\n\t\t\t\t     void *extra_data)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tunion rtw89_phy_bb_gain_arg arg = { .addr = reg->addr };\n\tstruct rtw89_efuse *efuse = &rtwdev->efuse;\n\n\tif (arg.gain_band >= RTW89_BB_GAIN_BAND_NR)\n\t\treturn;\n\n\tif (arg.path >= chip->rf_path_num)\n\t\treturn;\n\n\tif (arg.addr >= 0xf9 && arg.addr <= 0xfe) {\n\t\trtw89_warn(rtwdev, \"bb gain table with flow ctrl\\n\");\n\t\treturn;\n\t}\n\n\tswitch (arg.cfg_type) {\n\tcase 0:\n\t\trtw89_phy_cfg_bb_gain_error(rtwdev, arg, reg->data);\n\t\tbreak;\n\tcase 1:\n\t\trtw89_phy_cfg_bb_rpl_ofst(rtwdev, arg, reg->data);\n\t\tbreak;\n\tcase 2:\n\t\trtw89_phy_cfg_bb_gain_bypass(rtwdev, arg, reg->data);\n\t\tbreak;\n\tcase 3:\n\t\trtw89_phy_cfg_bb_gain_op1db(rtwdev, arg, reg->data);\n\t\tbreak;\n\tcase 4:\n\t\t \n\t\tif (efuse->rfe_type < 50)\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\trtw89_warn(rtwdev,\n\t\t\t   \"bb gain {0x%x:0x%x} with unknown cfg type: %d\\n\",\n\t\t\t   arg.addr, reg->data, arg.cfg_type);\n\t\tbreak;\n\t}\n}\n\nstatic void\nrtw89_phy_cofig_rf_reg_store(struct rtw89_dev *rtwdev,\n\t\t\t     const struct rtw89_reg2_def *reg,\n\t\t\t     enum rtw89_rf_path rf_path,\n\t\t\t     struct rtw89_fw_h2c_rf_reg_info *info)\n{\n\tu16 idx = info->curr_idx % RTW89_H2C_RF_PAGE_SIZE;\n\tu8 page = info->curr_idx / RTW89_H2C_RF_PAGE_SIZE;\n\n\tif (page >= RTW89_H2C_RF_PAGE_NUM) {\n\t\trtw89_warn(rtwdev, \"RF parameters exceed size. path=%d, idx=%d\",\n\t\t\t   rf_path, info->curr_idx);\n\t\treturn;\n\t}\n\n\tinfo->rtw89_phy_config_rf_h2c[page][idx] =\n\t\tcpu_to_le32((reg->addr << 20) | reg->data);\n\tinfo->curr_idx++;\n}\n\nstatic int rtw89_phy_config_rf_reg_fw(struct rtw89_dev *rtwdev,\n\t\t\t\t      struct rtw89_fw_h2c_rf_reg_info *info)\n{\n\tu16 remain = info->curr_idx;\n\tu16 len = 0;\n\tu8 i;\n\tint ret = 0;\n\n\tif (remain > RTW89_H2C_RF_PAGE_NUM * RTW89_H2C_RF_PAGE_SIZE) {\n\t\trtw89_warn(rtwdev,\n\t\t\t   \"rf reg h2c total len %d larger than %d\\n\",\n\t\t\t   remain, RTW89_H2C_RF_PAGE_NUM * RTW89_H2C_RF_PAGE_SIZE);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < RTW89_H2C_RF_PAGE_NUM && remain; i++, remain -= len) {\n\t\tlen = remain > RTW89_H2C_RF_PAGE_SIZE ? RTW89_H2C_RF_PAGE_SIZE : remain;\n\t\tret = rtw89_fw_h2c_rf_reg(rtwdev, info, len * 4, i);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\nout:\n\tinfo->curr_idx = 0;\n\n\treturn ret;\n}\n\nstatic void rtw89_phy_config_rf_reg_noio(struct rtw89_dev *rtwdev,\n\t\t\t\t\t const struct rtw89_reg2_def *reg,\n\t\t\t\t\t enum rtw89_rf_path rf_path,\n\t\t\t\t\t void *extra_data)\n{\n\tu32 addr = reg->addr;\n\n\tif (addr == 0xfe || addr == 0xfd || addr == 0xfc || addr == 0xfb ||\n\t    addr == 0xfa || addr == 0xf9)\n\t\treturn;\n\n\tif (rtw89_chip_rf_v1(rtwdev) && addr < 0x100)\n\t\treturn;\n\n\trtw89_phy_cofig_rf_reg_store(rtwdev, reg, rf_path,\n\t\t\t\t     (struct rtw89_fw_h2c_rf_reg_info *)extra_data);\n}\n\nstatic void rtw89_phy_config_rf_reg(struct rtw89_dev *rtwdev,\n\t\t\t\t    const struct rtw89_reg2_def *reg,\n\t\t\t\t    enum rtw89_rf_path rf_path,\n\t\t\t\t    void *extra_data)\n{\n\tif (reg->addr == 0xfe) {\n\t\tmdelay(50);\n\t} else if (reg->addr == 0xfd) {\n\t\tmdelay(5);\n\t} else if (reg->addr == 0xfc) {\n\t\tmdelay(1);\n\t} else if (reg->addr == 0xfb) {\n\t\tudelay(50);\n\t} else if (reg->addr == 0xfa) {\n\t\tudelay(5);\n\t} else if (reg->addr == 0xf9) {\n\t\tudelay(1);\n\t} else {\n\t\trtw89_write_rf(rtwdev, rf_path, reg->addr, 0xfffff, reg->data);\n\t\trtw89_phy_cofig_rf_reg_store(rtwdev, reg, rf_path,\n\t\t\t\t\t     (struct rtw89_fw_h2c_rf_reg_info *)extra_data);\n\t}\n}\n\nvoid rtw89_phy_config_rf_reg_v1(struct rtw89_dev *rtwdev,\n\t\t\t\tconst struct rtw89_reg2_def *reg,\n\t\t\t\tenum rtw89_rf_path rf_path,\n\t\t\t\tvoid *extra_data)\n{\n\trtw89_write_rf(rtwdev, rf_path, reg->addr, RFREG_MASK, reg->data);\n\n\tif (reg->addr < 0x100)\n\t\treturn;\n\n\trtw89_phy_cofig_rf_reg_store(rtwdev, reg, rf_path,\n\t\t\t\t     (struct rtw89_fw_h2c_rf_reg_info *)extra_data);\n}\nEXPORT_SYMBOL(rtw89_phy_config_rf_reg_v1);\n\nstatic int rtw89_phy_sel_headline(struct rtw89_dev *rtwdev,\n\t\t\t\t  const struct rtw89_phy_table *table,\n\t\t\t\t  u32 *headline_size, u32 *headline_idx,\n\t\t\t\t  u8 rfe, u8 cv)\n{\n\tconst struct rtw89_reg2_def *reg;\n\tu32 headline;\n\tu32 compare, target;\n\tu8 rfe_para, cv_para;\n\tu8 cv_max = 0;\n\tbool case_matched = false;\n\tu32 i;\n\n\tfor (i = 0; i < table->n_regs; i++) {\n\t\treg = &table->regs[i];\n\t\theadline = get_phy_headline(reg->addr);\n\t\tif (headline != PHY_HEADLINE_VALID)\n\t\t\tbreak;\n\t}\n\t*headline_size = i;\n\tif (*headline_size == 0)\n\t\treturn 0;\n\n\t \n\tcompare = get_phy_compare(rfe, cv);\n\tfor (i = 0; i < *headline_size; i++) {\n\t\treg = &table->regs[i];\n\t\ttarget = get_phy_target(reg->addr);\n\t\tif (target == compare) {\n\t\t\t*headline_idx = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tcompare = get_phy_compare(rfe, PHY_COND_DONT_CARE);\n\tfor (i = 0; i < *headline_size; i++) {\n\t\treg = &table->regs[i];\n\t\ttarget = get_phy_target(reg->addr);\n\t\tif (target == compare) {\n\t\t\t*headline_idx = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < *headline_size; i++) {\n\t\treg = &table->regs[i];\n\t\trfe_para = get_phy_cond_rfe(reg->addr);\n\t\tcv_para = get_phy_cond_cv(reg->addr);\n\t\tif (rfe_para == rfe) {\n\t\t\tif (cv_para >= cv_max) {\n\t\t\t\tcv_max = cv_para;\n\t\t\t\t*headline_idx = i;\n\t\t\t\tcase_matched = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (case_matched)\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < *headline_size; i++) {\n\t\treg = &table->regs[i];\n\t\trfe_para = get_phy_cond_rfe(reg->addr);\n\t\tcv_para = get_phy_cond_cv(reg->addr);\n\t\tif (rfe_para == PHY_COND_DONT_CARE) {\n\t\t\tif (cv_para >= cv_max) {\n\t\t\t\tcv_max = cv_para;\n\t\t\t\t*headline_idx = i;\n\t\t\t\tcase_matched = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (case_matched)\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\n\nstatic void rtw89_phy_init_reg(struct rtw89_dev *rtwdev,\n\t\t\t       const struct rtw89_phy_table *table,\n\t\t\t       void (*config)(struct rtw89_dev *rtwdev,\n\t\t\t\t\t      const struct rtw89_reg2_def *reg,\n\t\t\t\t\t      enum rtw89_rf_path rf_path,\n\t\t\t\t\t      void *data),\n\t\t\t       void *extra_data)\n{\n\tconst struct rtw89_reg2_def *reg;\n\tenum rtw89_rf_path rf_path = table->rf_path;\n\tu8 rfe = rtwdev->efuse.rfe_type;\n\tu8 cv = rtwdev->hal.cv;\n\tu32 i;\n\tu32 headline_size = 0, headline_idx = 0;\n\tu32 target = 0, cfg_target;\n\tu8 cond;\n\tbool is_matched = true;\n\tbool target_found = false;\n\tint ret;\n\n\tret = rtw89_phy_sel_headline(rtwdev, table, &headline_size,\n\t\t\t\t     &headline_idx, rfe, cv);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"invalid PHY package: %d/%d\\n\", rfe, cv);\n\t\treturn;\n\t}\n\n\tcfg_target = get_phy_target(table->regs[headline_idx].addr);\n\tfor (i = headline_size; i < table->n_regs; i++) {\n\t\treg = &table->regs[i];\n\t\tcond = get_phy_cond(reg->addr);\n\t\tswitch (cond) {\n\t\tcase PHY_COND_BRANCH_IF:\n\t\tcase PHY_COND_BRANCH_ELIF:\n\t\t\ttarget = get_phy_target(reg->addr);\n\t\t\tbreak;\n\t\tcase PHY_COND_BRANCH_ELSE:\n\t\t\tis_matched = false;\n\t\t\tif (!target_found) {\n\t\t\t\trtw89_warn(rtwdev, \"failed to load CR %x/%x\\n\",\n\t\t\t\t\t   reg->addr, reg->data);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PHY_COND_BRANCH_END:\n\t\t\tis_matched = true;\n\t\t\ttarget_found = false;\n\t\t\tbreak;\n\t\tcase PHY_COND_CHECK:\n\t\t\tif (target_found) {\n\t\t\t\tis_matched = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (target == cfg_target) {\n\t\t\t\tis_matched = true;\n\t\t\t\ttarget_found = true;\n\t\t\t} else {\n\t\t\t\tis_matched = false;\n\t\t\t\ttarget_found = false;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (is_matched)\n\t\t\t\tconfig(rtwdev, reg, rf_path, extra_data);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid rtw89_phy_init_bb_reg(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_fw_elm_info *elm_info = &rtwdev->fw.elm_info;\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tconst struct rtw89_phy_table *bb_table;\n\tconst struct rtw89_phy_table *bb_gain_table;\n\n\tbb_table = elm_info->bb_tbl ? elm_info->bb_tbl : chip->bb_table;\n\trtw89_phy_init_reg(rtwdev, bb_table, rtw89_phy_config_bb_reg, NULL);\n\trtw89_chip_init_txpwr_unit(rtwdev, RTW89_PHY_0);\n\n\tbb_gain_table = elm_info->bb_gain ? elm_info->bb_gain : chip->bb_gain_table;\n\tif (bb_gain_table)\n\t\trtw89_phy_init_reg(rtwdev, bb_gain_table,\n\t\t\t\t   rtw89_phy_config_bb_gain, NULL);\n\trtw89_phy_bb_reset(rtwdev, RTW89_PHY_0);\n}\n\nstatic u32 rtw89_phy_nctl_poll(struct rtw89_dev *rtwdev)\n{\n\trtw89_phy_write32(rtwdev, 0x8080, 0x4);\n\tudelay(1);\n\treturn rtw89_phy_read32(rtwdev, 0x8080);\n}\n\nvoid rtw89_phy_init_rf_reg(struct rtw89_dev *rtwdev, bool noio)\n{\n\tvoid (*config)(struct rtw89_dev *rtwdev, const struct rtw89_reg2_def *reg,\n\t\t       enum rtw89_rf_path rf_path, void *data);\n\tstruct rtw89_fw_elm_info *elm_info = &rtwdev->fw.elm_info;\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tconst struct rtw89_phy_table *rf_table;\n\tstruct rtw89_fw_h2c_rf_reg_info *rf_reg_info;\n\tu8 path;\n\n\trf_reg_info = kzalloc(sizeof(*rf_reg_info), GFP_KERNEL);\n\tif (!rf_reg_info)\n\t\treturn;\n\n\tfor (path = RF_PATH_A; path < chip->rf_path_num; path++) {\n\t\trf_table = elm_info->rf_radio[path] ?\n\t\t\t   elm_info->rf_radio[path] : chip->rf_table[path];\n\t\trf_reg_info->rf_path = rf_table->rf_path;\n\t\tif (noio)\n\t\t\tconfig = rtw89_phy_config_rf_reg_noio;\n\t\telse\n\t\t\tconfig = rf_table->config ? rf_table->config :\n\t\t\t\t rtw89_phy_config_rf_reg;\n\t\trtw89_phy_init_reg(rtwdev, rf_table, config, (void *)rf_reg_info);\n\t\tif (rtw89_phy_config_rf_reg_fw(rtwdev, rf_reg_info))\n\t\t\trtw89_warn(rtwdev, \"rf path %d reg h2c config failed\\n\",\n\t\t\t\t   rf_reg_info->rf_path);\n\t}\n\tkfree(rf_reg_info);\n}\n\nstatic void rtw89_phy_init_rf_nctl(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_fw_elm_info *elm_info = &rtwdev->fw.elm_info;\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tconst struct rtw89_phy_table *nctl_table;\n\tu32 val;\n\tint ret;\n\n\t \n\trtw89_phy_write32_set(rtwdev, R_IOQ_IQK_DPK, 0x3);\n\trtw89_phy_write32_set(rtwdev, R_GNT_BT_WGT_EN, 0x1);\n\trtw89_phy_write32_set(rtwdev, R_P0_PATH_RST, 0x8000000);\n\tif (chip->chip_id != RTL8851B)\n\t\trtw89_phy_write32_set(rtwdev, R_P1_PATH_RST, 0x8000000);\n\tif (chip->chip_id == RTL8852B)\n\t\trtw89_phy_write32_set(rtwdev, R_IOQ_IQK_DPK, 0x2);\n\n\t \n\trtw89_phy_write32(rtwdev, R_NCTL_CFG, 0x8);\n\n\tret = read_poll_timeout(rtw89_phy_nctl_poll, val, val == 0x4, 10,\n\t\t\t\t1000, false, rtwdev);\n\tif (ret)\n\t\trtw89_err(rtwdev, \"failed to poll nctl block\\n\");\n\n\tnctl_table = elm_info->rf_nctl ? elm_info->rf_nctl : chip->nctl_table;\n\trtw89_phy_init_reg(rtwdev, nctl_table, rtw89_phy_config_bb_reg, NULL);\n\n\tif (chip->nctl_post_table)\n\t\trtw89_rfk_parser(rtwdev, chip->nctl_post_table);\n}\n\nstatic u32 rtw89_phy0_phy1_offset(struct rtw89_dev *rtwdev, u32 addr)\n{\n\tu32 phy_page = addr >> 8;\n\tu32 ofst = 0;\n\n\tif (rtwdev->chip->chip_gen == RTW89_CHIP_BE)\n\t\treturn addr < 0x10000 ? 0x20000 : 0;\n\n\tswitch (phy_page) {\n\tcase 0x6:\n\tcase 0x7:\n\tcase 0x8:\n\tcase 0x9:\n\tcase 0xa:\n\tcase 0xb:\n\tcase 0xc:\n\tcase 0xd:\n\tcase 0x19:\n\tcase 0x1a:\n\tcase 0x1b:\n\t\tofst = 0x2000;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tofst = 0;\n\t\tbreak;\n\t}\n\n\tif (phy_page >= 0x40 && phy_page <= 0x4f)\n\t\tofst = 0x2000;\n\n\treturn ofst;\n}\n\nvoid rtw89_phy_write32_idx(struct rtw89_dev *rtwdev, u32 addr, u32 mask,\n\t\t\t   u32 data, enum rtw89_phy_idx phy_idx)\n{\n\tif (rtwdev->dbcc_en && phy_idx == RTW89_PHY_1)\n\t\taddr += rtw89_phy0_phy1_offset(rtwdev, addr);\n\trtw89_phy_write32_mask(rtwdev, addr, mask, data);\n}\nEXPORT_SYMBOL(rtw89_phy_write32_idx);\n\nu32 rtw89_phy_read32_idx(struct rtw89_dev *rtwdev, u32 addr, u32 mask,\n\t\t\t enum rtw89_phy_idx phy_idx)\n{\n\tif (rtwdev->dbcc_en && phy_idx == RTW89_PHY_1)\n\t\taddr += rtw89_phy0_phy1_offset(rtwdev, addr);\n\treturn rtw89_phy_read32_mask(rtwdev, addr, mask);\n}\nEXPORT_SYMBOL(rtw89_phy_read32_idx);\n\nvoid rtw89_phy_set_phy_regs(struct rtw89_dev *rtwdev, u32 addr, u32 mask,\n\t\t\t    u32 val)\n{\n\trtw89_phy_write32_idx(rtwdev, addr, mask, val, RTW89_PHY_0);\n\n\tif (!rtwdev->dbcc_en)\n\t\treturn;\n\n\trtw89_phy_write32_idx(rtwdev, addr, mask, val, RTW89_PHY_1);\n}\n\nvoid rtw89_phy_write_reg3_tbl(struct rtw89_dev *rtwdev,\n\t\t\t      const struct rtw89_phy_reg3_tbl *tbl)\n{\n\tconst struct rtw89_reg3_def *reg3;\n\tint i;\n\n\tfor (i = 0; i < tbl->size; i++) {\n\t\treg3 = &tbl->reg3[i];\n\t\trtw89_phy_write32_mask(rtwdev, reg3->addr, reg3->mask, reg3->data);\n\t}\n}\nEXPORT_SYMBOL(rtw89_phy_write_reg3_tbl);\n\nstatic const u8 rtw89_rs_idx_num[] = {\n\t[RTW89_RS_CCK] = RTW89_RATE_CCK_NUM,\n\t[RTW89_RS_OFDM] = RTW89_RATE_OFDM_NUM,\n\t[RTW89_RS_MCS] = RTW89_RATE_MCS_NUM,\n\t[RTW89_RS_HEDCM] = RTW89_RATE_HEDCM_NUM,\n\t[RTW89_RS_OFFSET] = RTW89_RATE_OFFSET_NUM,\n};\n\nstatic const u8 rtw89_rs_nss_num[] = {\n\t[RTW89_RS_CCK] = 1,\n\t[RTW89_RS_OFDM] = 1,\n\t[RTW89_RS_MCS] = RTW89_NSS_NUM,\n\t[RTW89_RS_HEDCM] = RTW89_NSS_HEDCM_NUM,\n\t[RTW89_RS_OFFSET] = 1,\n};\n\nstatic const u8 _byr_of_rs[] = {\n\t[RTW89_RS_CCK] = offsetof(struct rtw89_txpwr_byrate, cck),\n\t[RTW89_RS_OFDM] = offsetof(struct rtw89_txpwr_byrate, ofdm),\n\t[RTW89_RS_MCS] = offsetof(struct rtw89_txpwr_byrate, mcs),\n\t[RTW89_RS_HEDCM] = offsetof(struct rtw89_txpwr_byrate, hedcm),\n\t[RTW89_RS_OFFSET] = offsetof(struct rtw89_txpwr_byrate, offset),\n};\n\n#define _byr_seek(rs, raw) ((s8 *)(raw) + _byr_of_rs[rs])\n#define _byr_idx(rs, nss, idx) ((nss) * rtw89_rs_idx_num[rs] + (idx))\n#define _byr_chk(rs, nss, idx) \\\n\t((nss) < rtw89_rs_nss_num[rs] && (idx) < rtw89_rs_idx_num[rs])\n\nvoid rtw89_phy_load_txpwr_byrate(struct rtw89_dev *rtwdev,\n\t\t\t\t const struct rtw89_txpwr_table *tbl)\n{\n\tconst struct rtw89_txpwr_byrate_cfg *cfg = tbl->data;\n\tconst struct rtw89_txpwr_byrate_cfg *end = cfg + tbl->size;\n\ts8 *byr;\n\tu32 data;\n\tu8 i, idx;\n\n\tfor (; cfg < end; cfg++) {\n\t\tbyr = _byr_seek(cfg->rs, &rtwdev->byr[cfg->band]);\n\t\tdata = cfg->data;\n\n\t\tfor (i = 0; i < cfg->len; i++, data >>= 8) {\n\t\t\tidx = _byr_idx(cfg->rs, cfg->nss, (cfg->shf + i));\n\t\t\tbyr[idx] = (s8)(data & 0xff);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(rtw89_phy_load_txpwr_byrate);\n\n#define _phy_txpwr_rf_to_mac(rtwdev, txpwr_rf)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tconst struct rtw89_chip_info *__c = (rtwdev)->chip;\t\t\\\n\t(txpwr_rf) >> (__c->txpwr_factor_rf - __c->txpwr_factor_mac);\t\\\n})\n\nstatic\ns8 rtw89_phy_read_txpwr_byrate(struct rtw89_dev *rtwdev, u8 band,\n\t\t\t       const struct rtw89_rate_desc *rate_desc)\n{\n\ts8 *byr;\n\tu8 idx;\n\n\tif (rate_desc->rs == RTW89_RS_CCK)\n\t\tband = RTW89_BAND_2G;\n\n\tif (!_byr_chk(rate_desc->rs, rate_desc->nss, rate_desc->idx)) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_TXPWR,\n\t\t\t    \"[TXPWR] unknown byrate desc rs=%d nss=%d idx=%d\\n\",\n\t\t\t    rate_desc->rs, rate_desc->nss, rate_desc->idx);\n\n\t\treturn 0;\n\t}\n\n\tbyr = _byr_seek(rate_desc->rs, &rtwdev->byr[band]);\n\tidx = _byr_idx(rate_desc->rs, rate_desc->nss, rate_desc->idx);\n\n\treturn _phy_txpwr_rf_to_mac(rtwdev, byr[idx]);\n}\n\nstatic u8 rtw89_channel_6g_to_idx(struct rtw89_dev *rtwdev, u8 channel_6g)\n{\n\tswitch (channel_6g) {\n\tcase 1 ... 29:\n\t\treturn (channel_6g - 1) / 2;\n\tcase 33 ... 61:\n\t\treturn (channel_6g - 3) / 2;\n\tcase 65 ... 93:\n\t\treturn (channel_6g - 5) / 2;\n\tcase 97 ... 125:\n\t\treturn (channel_6g - 7) / 2;\n\tcase 129 ... 157:\n\t\treturn (channel_6g - 9) / 2;\n\tcase 161 ... 189:\n\t\treturn (channel_6g - 11) / 2;\n\tcase 193 ... 221:\n\t\treturn (channel_6g - 13) / 2;\n\tcase 225 ... 253:\n\t\treturn (channel_6g - 15) / 2;\n\tdefault:\n\t\trtw89_warn(rtwdev, \"unknown 6g channel: %d\\n\", channel_6g);\n\t\treturn 0;\n\t}\n}\n\nstatic u8 rtw89_channel_to_idx(struct rtw89_dev *rtwdev, u8 band, u8 channel)\n{\n\tif (band == RTW89_BAND_6G)\n\t\treturn rtw89_channel_6g_to_idx(rtwdev, channel);\n\n\tswitch (channel) {\n\tcase 1 ... 14:\n\t\treturn channel - 1;\n\tcase 36 ... 64:\n\t\treturn (channel - 36) / 2;\n\tcase 100 ... 144:\n\t\treturn ((channel - 100) / 2) + 15;\n\tcase 149 ... 177:\n\t\treturn ((channel - 149) / 2) + 38;\n\tdefault:\n\t\trtw89_warn(rtwdev, \"unknown channel: %d\\n\", channel);\n\t\treturn 0;\n\t}\n}\n\ns8 rtw89_phy_read_txpwr_limit(struct rtw89_dev *rtwdev, u8 band,\n\t\t\t      u8 bw, u8 ntx, u8 rs, u8 bf, u8 ch)\n{\n\tconst struct rtw89_rfe_parms *rfe_parms = rtwdev->rfe_parms;\n\tconst struct rtw89_txpwr_rule_2ghz *rule_2ghz = &rfe_parms->rule_2ghz;\n\tconst struct rtw89_txpwr_rule_5ghz *rule_5ghz = &rfe_parms->rule_5ghz;\n\tconst struct rtw89_txpwr_rule_6ghz *rule_6ghz = &rfe_parms->rule_6ghz;\n\tstruct rtw89_regulatory_info *regulatory = &rtwdev->regulatory;\n\tenum nl80211_band nl_band = rtw89_hw_to_nl80211_band(band);\n\tu32 freq = ieee80211_channel_to_frequency(ch, nl_band);\n\tu8 ch_idx = rtw89_channel_to_idx(rtwdev, band, ch);\n\tu8 regd = rtw89_regd_get(rtwdev, band);\n\tu8 reg6 = regulatory->reg_6ghz_power;\n\ts8 lmt = 0, sar;\n\n\tswitch (band) {\n\tcase RTW89_BAND_2G:\n\t\tlmt = (*rule_2ghz->lmt)[bw][ntx][rs][bf][regd][ch_idx];\n\t\tif (lmt)\n\t\t\tbreak;\n\n\t\tlmt = (*rule_2ghz->lmt)[bw][ntx][rs][bf][RTW89_WW][ch_idx];\n\t\tbreak;\n\tcase RTW89_BAND_5G:\n\t\tlmt = (*rule_5ghz->lmt)[bw][ntx][rs][bf][regd][ch_idx];\n\t\tif (lmt)\n\t\t\tbreak;\n\n\t\tlmt = (*rule_5ghz->lmt)[bw][ntx][rs][bf][RTW89_WW][ch_idx];\n\t\tbreak;\n\tcase RTW89_BAND_6G:\n\t\tlmt = (*rule_6ghz->lmt)[bw][ntx][rs][bf][regd][reg6][ch_idx];\n\t\tif (lmt)\n\t\t\tbreak;\n\n\t\tlmt = (*rule_6ghz->lmt)[bw][ntx][rs][bf][RTW89_WW]\n\t\t\t\t       [RTW89_REG_6GHZ_POWER_DFLT]\n\t\t\t\t       [ch_idx];\n\t\tbreak;\n\tdefault:\n\t\trtw89_warn(rtwdev, \"unknown band type: %d\\n\", band);\n\t\treturn 0;\n\t}\n\n\tlmt = _phy_txpwr_rf_to_mac(rtwdev, lmt);\n\tsar = rtw89_query_sar(rtwdev, freq);\n\n\treturn min(lmt, sar);\n}\nEXPORT_SYMBOL(rtw89_phy_read_txpwr_limit);\n\n#define __fill_txpwr_limit_nonbf_bf(ptr, band, bw, ntx, rs, ch)\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tu8 __i;\t\t\t\t\t\t\t\\\n\t\tfor (__i = 0; __i < RTW89_BF_NUM; __i++)\t\t\\\n\t\t\tptr[__i] = rtw89_phy_read_txpwr_limit(rtwdev,\t\\\n\t\t\t\t\t\t\t      band,\t\\\n\t\t\t\t\t\t\t      bw, ntx,\t\\\n\t\t\t\t\t\t\t      rs, __i,\t\\\n\t\t\t\t\t\t\t      (ch));\t\\\n\t} while (0)\n\nstatic void rtw89_phy_fill_txpwr_limit_20m(struct rtw89_dev *rtwdev,\n\t\t\t\t\t   struct rtw89_txpwr_limit *lmt,\n\t\t\t\t\t   u8 band, u8 ntx, u8 ch)\n{\n\t__fill_txpwr_limit_nonbf_bf(lmt->cck_20m, band, RTW89_CHANNEL_WIDTH_20,\n\t\t\t\t    ntx, RTW89_RS_CCK, ch);\n\t__fill_txpwr_limit_nonbf_bf(lmt->cck_40m, band, RTW89_CHANNEL_WIDTH_40,\n\t\t\t\t    ntx, RTW89_RS_CCK, ch);\n\t__fill_txpwr_limit_nonbf_bf(lmt->ofdm, band, RTW89_CHANNEL_WIDTH_20,\n\t\t\t\t    ntx, RTW89_RS_OFDM, ch);\n\t__fill_txpwr_limit_nonbf_bf(lmt->mcs_20m[0], band,\n\t\t\t\t    RTW89_CHANNEL_WIDTH_20,\n\t\t\t\t    ntx, RTW89_RS_MCS, ch);\n}\n\nstatic void rtw89_phy_fill_txpwr_limit_40m(struct rtw89_dev *rtwdev,\n\t\t\t\t\t   struct rtw89_txpwr_limit *lmt,\n\t\t\t\t\t   u8 band, u8 ntx, u8 ch, u8 pri_ch)\n{\n\t__fill_txpwr_limit_nonbf_bf(lmt->cck_20m, band, RTW89_CHANNEL_WIDTH_20,\n\t\t\t\t    ntx, RTW89_RS_CCK, ch - 2);\n\t__fill_txpwr_limit_nonbf_bf(lmt->cck_40m, band, RTW89_CHANNEL_WIDTH_40,\n\t\t\t\t    ntx, RTW89_RS_CCK, ch);\n\t__fill_txpwr_limit_nonbf_bf(lmt->ofdm, band, RTW89_CHANNEL_WIDTH_20,\n\t\t\t\t    ntx, RTW89_RS_OFDM, pri_ch);\n\t__fill_txpwr_limit_nonbf_bf(lmt->mcs_20m[0], band,\n\t\t\t\t    RTW89_CHANNEL_WIDTH_20,\n\t\t\t\t    ntx, RTW89_RS_MCS, ch - 2);\n\t__fill_txpwr_limit_nonbf_bf(lmt->mcs_20m[1], band,\n\t\t\t\t    RTW89_CHANNEL_WIDTH_20,\n\t\t\t\t    ntx, RTW89_RS_MCS, ch + 2);\n\t__fill_txpwr_limit_nonbf_bf(lmt->mcs_40m[0], band,\n\t\t\t\t    RTW89_CHANNEL_WIDTH_40,\n\t\t\t\t    ntx, RTW89_RS_MCS, ch);\n}\n\nstatic void rtw89_phy_fill_txpwr_limit_80m(struct rtw89_dev *rtwdev,\n\t\t\t\t\t   struct rtw89_txpwr_limit *lmt,\n\t\t\t\t\t   u8 band, u8 ntx, u8 ch, u8 pri_ch)\n{\n\ts8 val_0p5_n[RTW89_BF_NUM];\n\ts8 val_0p5_p[RTW89_BF_NUM];\n\tu8 i;\n\n\t__fill_txpwr_limit_nonbf_bf(lmt->ofdm, band, RTW89_CHANNEL_WIDTH_20,\n\t\t\t\t    ntx, RTW89_RS_OFDM, pri_ch);\n\t__fill_txpwr_limit_nonbf_bf(lmt->mcs_20m[0], band,\n\t\t\t\t    RTW89_CHANNEL_WIDTH_20,\n\t\t\t\t    ntx, RTW89_RS_MCS, ch - 6);\n\t__fill_txpwr_limit_nonbf_bf(lmt->mcs_20m[1], band,\n\t\t\t\t    RTW89_CHANNEL_WIDTH_20,\n\t\t\t\t    ntx, RTW89_RS_MCS, ch - 2);\n\t__fill_txpwr_limit_nonbf_bf(lmt->mcs_20m[2], band,\n\t\t\t\t    RTW89_CHANNEL_WIDTH_20,\n\t\t\t\t    ntx, RTW89_RS_MCS, ch + 2);\n\t__fill_txpwr_limit_nonbf_bf(lmt->mcs_20m[3], band,\n\t\t\t\t    RTW89_CHANNEL_WIDTH_20,\n\t\t\t\t    ntx, RTW89_RS_MCS, ch + 6);\n\t__fill_txpwr_limit_nonbf_bf(lmt->mcs_40m[0], band,\n\t\t\t\t    RTW89_CHANNEL_WIDTH_40,\n\t\t\t\t    ntx, RTW89_RS_MCS, ch - 4);\n\t__fill_txpwr_limit_nonbf_bf(lmt->mcs_40m[1], band,\n\t\t\t\t    RTW89_CHANNEL_WIDTH_40,\n\t\t\t\t    ntx, RTW89_RS_MCS, ch + 4);\n\t__fill_txpwr_limit_nonbf_bf(lmt->mcs_80m[0], band,\n\t\t\t\t    RTW89_CHANNEL_WIDTH_80,\n\t\t\t\t    ntx, RTW89_RS_MCS, ch);\n\n\t__fill_txpwr_limit_nonbf_bf(val_0p5_n, band, RTW89_CHANNEL_WIDTH_40,\n\t\t\t\t    ntx, RTW89_RS_MCS, ch - 4);\n\t__fill_txpwr_limit_nonbf_bf(val_0p5_p, band, RTW89_CHANNEL_WIDTH_40,\n\t\t\t\t    ntx, RTW89_RS_MCS, ch + 4);\n\n\tfor (i = 0; i < RTW89_BF_NUM; i++)\n\t\tlmt->mcs_40m_0p5[i] = min_t(s8, val_0p5_n[i], val_0p5_p[i]);\n}\n\nstatic void rtw89_phy_fill_txpwr_limit_160m(struct rtw89_dev *rtwdev,\n\t\t\t\t\t    struct rtw89_txpwr_limit *lmt,\n\t\t\t\t\t    u8 band, u8 ntx, u8 ch, u8 pri_ch)\n{\n\ts8 val_0p5_n[RTW89_BF_NUM];\n\ts8 val_0p5_p[RTW89_BF_NUM];\n\ts8 val_2p5_n[RTW89_BF_NUM];\n\ts8 val_2p5_p[RTW89_BF_NUM];\n\tu8 i;\n\n\t \n\t__fill_txpwr_limit_nonbf_bf(lmt->ofdm, band, RTW89_CHANNEL_WIDTH_20,\n\t\t\t\t    ntx, RTW89_RS_OFDM, pri_ch);\n\n\t \n\t__fill_txpwr_limit_nonbf_bf(lmt->mcs_20m[0], band,\n\t\t\t\t    RTW89_CHANNEL_WIDTH_20,\n\t\t\t\t    ntx, RTW89_RS_MCS, ch - 14);\n\t__fill_txpwr_limit_nonbf_bf(lmt->mcs_20m[1], band,\n\t\t\t\t    RTW89_CHANNEL_WIDTH_20,\n\t\t\t\t    ntx, RTW89_RS_MCS, ch - 10);\n\t__fill_txpwr_limit_nonbf_bf(lmt->mcs_20m[2], band,\n\t\t\t\t    RTW89_CHANNEL_WIDTH_20,\n\t\t\t\t    ntx, RTW89_RS_MCS, ch - 6);\n\t__fill_txpwr_limit_nonbf_bf(lmt->mcs_20m[3], band,\n\t\t\t\t    RTW89_CHANNEL_WIDTH_20,\n\t\t\t\t    ntx, RTW89_RS_MCS, ch - 2);\n\t__fill_txpwr_limit_nonbf_bf(lmt->mcs_20m[4], band,\n\t\t\t\t    RTW89_CHANNEL_WIDTH_20,\n\t\t\t\t    ntx, RTW89_RS_MCS, ch + 2);\n\t__fill_txpwr_limit_nonbf_bf(lmt->mcs_20m[5], band,\n\t\t\t\t    RTW89_CHANNEL_WIDTH_20,\n\t\t\t\t    ntx, RTW89_RS_MCS, ch + 6);\n\t__fill_txpwr_limit_nonbf_bf(lmt->mcs_20m[6], band,\n\t\t\t\t    RTW89_CHANNEL_WIDTH_20,\n\t\t\t\t    ntx, RTW89_RS_MCS, ch + 10);\n\t__fill_txpwr_limit_nonbf_bf(lmt->mcs_20m[7], band,\n\t\t\t\t    RTW89_CHANNEL_WIDTH_20,\n\t\t\t\t    ntx, RTW89_RS_MCS, ch + 14);\n\n\t \n\t__fill_txpwr_limit_nonbf_bf(lmt->mcs_40m[0], band,\n\t\t\t\t    RTW89_CHANNEL_WIDTH_40,\n\t\t\t\t    ntx, RTW89_RS_MCS, ch - 12);\n\t__fill_txpwr_limit_nonbf_bf(lmt->mcs_40m[1], band,\n\t\t\t\t    RTW89_CHANNEL_WIDTH_40,\n\t\t\t\t    ntx, RTW89_RS_MCS, ch - 4);\n\t__fill_txpwr_limit_nonbf_bf(lmt->mcs_40m[2], band,\n\t\t\t\t    RTW89_CHANNEL_WIDTH_40,\n\t\t\t\t    ntx, RTW89_RS_MCS, ch + 4);\n\t__fill_txpwr_limit_nonbf_bf(lmt->mcs_40m[3], band,\n\t\t\t\t    RTW89_CHANNEL_WIDTH_40,\n\t\t\t\t    ntx, RTW89_RS_MCS, ch + 12);\n\n\t \n\t__fill_txpwr_limit_nonbf_bf(lmt->mcs_80m[0], band,\n\t\t\t\t    RTW89_CHANNEL_WIDTH_80,\n\t\t\t\t    ntx, RTW89_RS_MCS, ch - 8);\n\t__fill_txpwr_limit_nonbf_bf(lmt->mcs_80m[1], band,\n\t\t\t\t    RTW89_CHANNEL_WIDTH_80,\n\t\t\t\t    ntx, RTW89_RS_MCS, ch + 8);\n\n\t \n\t__fill_txpwr_limit_nonbf_bf(lmt->mcs_160m, band,\n\t\t\t\t    RTW89_CHANNEL_WIDTH_160,\n\t\t\t\t    ntx, RTW89_RS_MCS, ch);\n\n\t \n\t__fill_txpwr_limit_nonbf_bf(val_0p5_n, band, RTW89_CHANNEL_WIDTH_40,\n\t\t\t\t    ntx, RTW89_RS_MCS, ch - 4);\n\t__fill_txpwr_limit_nonbf_bf(val_0p5_p, band, RTW89_CHANNEL_WIDTH_40,\n\t\t\t\t    ntx, RTW89_RS_MCS, ch + 4);\n\n\tfor (i = 0; i < RTW89_BF_NUM; i++)\n\t\tlmt->mcs_40m_0p5[i] = min_t(s8, val_0p5_n[i], val_0p5_p[i]);\n\n\t \n\t__fill_txpwr_limit_nonbf_bf(val_2p5_n, band, RTW89_CHANNEL_WIDTH_40,\n\t\t\t\t    ntx, RTW89_RS_MCS, ch - 8);\n\t__fill_txpwr_limit_nonbf_bf(val_2p5_p, band, RTW89_CHANNEL_WIDTH_40,\n\t\t\t\t    ntx, RTW89_RS_MCS, ch + 8);\n\n\tfor (i = 0; i < RTW89_BF_NUM; i++)\n\t\tlmt->mcs_40m_2p5[i] = min_t(s8, val_2p5_n[i], val_2p5_p[i]);\n}\n\nstatic\nvoid rtw89_phy_fill_txpwr_limit(struct rtw89_dev *rtwdev,\n\t\t\t\tconst struct rtw89_chan *chan,\n\t\t\t\tstruct rtw89_txpwr_limit *lmt,\n\t\t\t\tu8 ntx)\n{\n\tu8 band = chan->band_type;\n\tu8 pri_ch = chan->primary_channel;\n\tu8 ch = chan->channel;\n\tu8 bw = chan->band_width;\n\n\tmemset(lmt, 0, sizeof(*lmt));\n\n\tswitch (bw) {\n\tcase RTW89_CHANNEL_WIDTH_20:\n\t\trtw89_phy_fill_txpwr_limit_20m(rtwdev, lmt, band, ntx, ch);\n\t\tbreak;\n\tcase RTW89_CHANNEL_WIDTH_40:\n\t\trtw89_phy_fill_txpwr_limit_40m(rtwdev, lmt, band, ntx, ch,\n\t\t\t\t\t       pri_ch);\n\t\tbreak;\n\tcase RTW89_CHANNEL_WIDTH_80:\n\t\trtw89_phy_fill_txpwr_limit_80m(rtwdev, lmt, band, ntx, ch,\n\t\t\t\t\t       pri_ch);\n\t\tbreak;\n\tcase RTW89_CHANNEL_WIDTH_160:\n\t\trtw89_phy_fill_txpwr_limit_160m(rtwdev, lmt, band, ntx, ch,\n\t\t\t\t\t\tpri_ch);\n\t\tbreak;\n\t}\n}\n\nstatic s8 rtw89_phy_read_txpwr_limit_ru(struct rtw89_dev *rtwdev, u8 band,\n\t\t\t\t\tu8 ru, u8 ntx, u8 ch)\n{\n\tconst struct rtw89_rfe_parms *rfe_parms = rtwdev->rfe_parms;\n\tconst struct rtw89_txpwr_rule_2ghz *rule_2ghz = &rfe_parms->rule_2ghz;\n\tconst struct rtw89_txpwr_rule_5ghz *rule_5ghz = &rfe_parms->rule_5ghz;\n\tconst struct rtw89_txpwr_rule_6ghz *rule_6ghz = &rfe_parms->rule_6ghz;\n\tstruct rtw89_regulatory_info *regulatory = &rtwdev->regulatory;\n\tenum nl80211_band nl_band = rtw89_hw_to_nl80211_band(band);\n\tu32 freq = ieee80211_channel_to_frequency(ch, nl_band);\n\tu8 ch_idx = rtw89_channel_to_idx(rtwdev, band, ch);\n\tu8 regd = rtw89_regd_get(rtwdev, band);\n\tu8 reg6 = regulatory->reg_6ghz_power;\n\ts8 lmt_ru = 0, sar;\n\n\tswitch (band) {\n\tcase RTW89_BAND_2G:\n\t\tlmt_ru = (*rule_2ghz->lmt_ru)[ru][ntx][regd][ch_idx];\n\t\tif (lmt_ru)\n\t\t\tbreak;\n\n\t\tlmt_ru = (*rule_2ghz->lmt_ru)[ru][ntx][RTW89_WW][ch_idx];\n\t\tbreak;\n\tcase RTW89_BAND_5G:\n\t\tlmt_ru = (*rule_5ghz->lmt_ru)[ru][ntx][regd][ch_idx];\n\t\tif (lmt_ru)\n\t\t\tbreak;\n\n\t\tlmt_ru = (*rule_5ghz->lmt_ru)[ru][ntx][RTW89_WW][ch_idx];\n\t\tbreak;\n\tcase RTW89_BAND_6G:\n\t\tlmt_ru = (*rule_6ghz->lmt_ru)[ru][ntx][regd][reg6][ch_idx];\n\t\tif (lmt_ru)\n\t\t\tbreak;\n\n\t\tlmt_ru = (*rule_6ghz->lmt_ru)[ru][ntx][RTW89_WW]\n\t\t\t\t\t     [RTW89_REG_6GHZ_POWER_DFLT]\n\t\t\t\t\t     [ch_idx];\n\t\tbreak;\n\tdefault:\n\t\trtw89_warn(rtwdev, \"unknown band type: %d\\n\", band);\n\t\treturn 0;\n\t}\n\n\tlmt_ru = _phy_txpwr_rf_to_mac(rtwdev, lmt_ru);\n\tsar = rtw89_query_sar(rtwdev, freq);\n\n\treturn min(lmt_ru, sar);\n}\n\nstatic void\nrtw89_phy_fill_txpwr_limit_ru_20m(struct rtw89_dev *rtwdev,\n\t\t\t\t  struct rtw89_txpwr_limit_ru *lmt_ru,\n\t\t\t\t  u8 band, u8 ntx, u8 ch)\n{\n\tlmt_ru->ru26[0] = rtw89_phy_read_txpwr_limit_ru(rtwdev, band,\n\t\t\t\t\t\t\tRTW89_RU26,\n\t\t\t\t\t\t\tntx, ch);\n\tlmt_ru->ru52[0] = rtw89_phy_read_txpwr_limit_ru(rtwdev, band,\n\t\t\t\t\t\t\tRTW89_RU52,\n\t\t\t\t\t\t\tntx, ch);\n\tlmt_ru->ru106[0] = rtw89_phy_read_txpwr_limit_ru(rtwdev, band,\n\t\t\t\t\t\t\t RTW89_RU106,\n\t\t\t\t\t\t\t ntx, ch);\n}\n\nstatic void\nrtw89_phy_fill_txpwr_limit_ru_40m(struct rtw89_dev *rtwdev,\n\t\t\t\t  struct rtw89_txpwr_limit_ru *lmt_ru,\n\t\t\t\t  u8 band, u8 ntx, u8 ch)\n{\n\tlmt_ru->ru26[0] = rtw89_phy_read_txpwr_limit_ru(rtwdev, band,\n\t\t\t\t\t\t\tRTW89_RU26,\n\t\t\t\t\t\t\tntx, ch - 2);\n\tlmt_ru->ru26[1] = rtw89_phy_read_txpwr_limit_ru(rtwdev, band,\n\t\t\t\t\t\t\tRTW89_RU26,\n\t\t\t\t\t\t\tntx, ch + 2);\n\tlmt_ru->ru52[0] = rtw89_phy_read_txpwr_limit_ru(rtwdev, band,\n\t\t\t\t\t\t\tRTW89_RU52,\n\t\t\t\t\t\t\tntx, ch - 2);\n\tlmt_ru->ru52[1] = rtw89_phy_read_txpwr_limit_ru(rtwdev, band,\n\t\t\t\t\t\t\tRTW89_RU52,\n\t\t\t\t\t\t\tntx, ch + 2);\n\tlmt_ru->ru106[0] = rtw89_phy_read_txpwr_limit_ru(rtwdev, band,\n\t\t\t\t\t\t\t RTW89_RU106,\n\t\t\t\t\t\t\t ntx, ch - 2);\n\tlmt_ru->ru106[1] = rtw89_phy_read_txpwr_limit_ru(rtwdev, band,\n\t\t\t\t\t\t\t RTW89_RU106,\n\t\t\t\t\t\t\t ntx, ch + 2);\n}\n\nstatic void\nrtw89_phy_fill_txpwr_limit_ru_80m(struct rtw89_dev *rtwdev,\n\t\t\t\t  struct rtw89_txpwr_limit_ru *lmt_ru,\n\t\t\t\t  u8 band, u8 ntx, u8 ch)\n{\n\tlmt_ru->ru26[0] = rtw89_phy_read_txpwr_limit_ru(rtwdev, band,\n\t\t\t\t\t\t\tRTW89_RU26,\n\t\t\t\t\t\t\tntx, ch - 6);\n\tlmt_ru->ru26[1] = rtw89_phy_read_txpwr_limit_ru(rtwdev, band,\n\t\t\t\t\t\t\tRTW89_RU26,\n\t\t\t\t\t\t\tntx, ch - 2);\n\tlmt_ru->ru26[2] = rtw89_phy_read_txpwr_limit_ru(rtwdev, band,\n\t\t\t\t\t\t\tRTW89_RU26,\n\t\t\t\t\t\t\tntx, ch + 2);\n\tlmt_ru->ru26[3] = rtw89_phy_read_txpwr_limit_ru(rtwdev, band,\n\t\t\t\t\t\t\tRTW89_RU26,\n\t\t\t\t\t\t\tntx, ch + 6);\n\tlmt_ru->ru52[0] = rtw89_phy_read_txpwr_limit_ru(rtwdev, band,\n\t\t\t\t\t\t\tRTW89_RU52,\n\t\t\t\t\t\t\tntx, ch - 6);\n\tlmt_ru->ru52[1] = rtw89_phy_read_txpwr_limit_ru(rtwdev, band,\n\t\t\t\t\t\t\tRTW89_RU52,\n\t\t\t\t\t\t\tntx, ch - 2);\n\tlmt_ru->ru52[2] = rtw89_phy_read_txpwr_limit_ru(rtwdev, band,\n\t\t\t\t\t\t\tRTW89_RU52,\n\t\t\t\t\t\t\tntx, ch + 2);\n\tlmt_ru->ru52[3] = rtw89_phy_read_txpwr_limit_ru(rtwdev, band,\n\t\t\t\t\t\t\tRTW89_RU52,\n\t\t\t\t\t\t\tntx, ch + 6);\n\tlmt_ru->ru106[0] = rtw89_phy_read_txpwr_limit_ru(rtwdev, band,\n\t\t\t\t\t\t\t RTW89_RU106,\n\t\t\t\t\t\t\t ntx, ch - 6);\n\tlmt_ru->ru106[1] = rtw89_phy_read_txpwr_limit_ru(rtwdev, band,\n\t\t\t\t\t\t\t RTW89_RU106,\n\t\t\t\t\t\t\t ntx, ch - 2);\n\tlmt_ru->ru106[2] = rtw89_phy_read_txpwr_limit_ru(rtwdev, band,\n\t\t\t\t\t\t\t RTW89_RU106,\n\t\t\t\t\t\t\t ntx, ch + 2);\n\tlmt_ru->ru106[3] = rtw89_phy_read_txpwr_limit_ru(rtwdev, band,\n\t\t\t\t\t\t\t RTW89_RU106,\n\t\t\t\t\t\t\t ntx, ch + 6);\n}\n\nstatic void\nrtw89_phy_fill_txpwr_limit_ru_160m(struct rtw89_dev *rtwdev,\n\t\t\t\t   struct rtw89_txpwr_limit_ru *lmt_ru,\n\t\t\t\t   u8 band, u8 ntx, u8 ch)\n{\n\tstatic const int ofst[] = { -14, -10, -6, -2, 2, 6, 10, 14 };\n\tint i;\n\n\tstatic_assert(ARRAY_SIZE(ofst) == RTW89_RU_SEC_NUM);\n\tfor (i = 0; i < RTW89_RU_SEC_NUM; i++) {\n\t\tlmt_ru->ru26[i] = rtw89_phy_read_txpwr_limit_ru(rtwdev, band,\n\t\t\t\t\t\t\t\tRTW89_RU26,\n\t\t\t\t\t\t\t\tntx,\n\t\t\t\t\t\t\t\tch + ofst[i]);\n\t\tlmt_ru->ru52[i] = rtw89_phy_read_txpwr_limit_ru(rtwdev, band,\n\t\t\t\t\t\t\t\tRTW89_RU52,\n\t\t\t\t\t\t\t\tntx,\n\t\t\t\t\t\t\t\tch + ofst[i]);\n\t\tlmt_ru->ru106[i] = rtw89_phy_read_txpwr_limit_ru(rtwdev, band,\n\t\t\t\t\t\t\t\t RTW89_RU106,\n\t\t\t\t\t\t\t\t ntx,\n\t\t\t\t\t\t\t\t ch + ofst[i]);\n\t}\n}\n\nstatic\nvoid rtw89_phy_fill_txpwr_limit_ru(struct rtw89_dev *rtwdev,\n\t\t\t\t   const struct rtw89_chan *chan,\n\t\t\t\t   struct rtw89_txpwr_limit_ru *lmt_ru,\n\t\t\t\t   u8 ntx)\n{\n\tu8 band = chan->band_type;\n\tu8 ch = chan->channel;\n\tu8 bw = chan->band_width;\n\n\tmemset(lmt_ru, 0, sizeof(*lmt_ru));\n\n\tswitch (bw) {\n\tcase RTW89_CHANNEL_WIDTH_20:\n\t\trtw89_phy_fill_txpwr_limit_ru_20m(rtwdev, lmt_ru, band, ntx,\n\t\t\t\t\t\t  ch);\n\t\tbreak;\n\tcase RTW89_CHANNEL_WIDTH_40:\n\t\trtw89_phy_fill_txpwr_limit_ru_40m(rtwdev, lmt_ru, band, ntx,\n\t\t\t\t\t\t  ch);\n\t\tbreak;\n\tcase RTW89_CHANNEL_WIDTH_80:\n\t\trtw89_phy_fill_txpwr_limit_ru_80m(rtwdev, lmt_ru, band, ntx,\n\t\t\t\t\t\t  ch);\n\t\tbreak;\n\tcase RTW89_CHANNEL_WIDTH_160:\n\t\trtw89_phy_fill_txpwr_limit_ru_160m(rtwdev, lmt_ru, band, ntx,\n\t\t\t\t\t\t   ch);\n\t\tbreak;\n\t}\n}\n\nvoid rtw89_phy_set_txpwr_byrate(struct rtw89_dev *rtwdev,\n\t\t\t\tconst struct rtw89_chan *chan,\n\t\t\t\tenum rtw89_phy_idx phy_idx)\n{\n\tu8 max_nss_num = rtwdev->chip->rf_path_num;\n\tstatic const u8 rs[] = {\n\t\tRTW89_RS_CCK,\n\t\tRTW89_RS_OFDM,\n\t\tRTW89_RS_MCS,\n\t\tRTW89_RS_HEDCM,\n\t};\n\tstruct rtw89_rate_desc cur;\n\tu8 band = chan->band_type;\n\tu8 ch = chan->channel;\n\tu32 addr, val;\n\ts8 v[4] = {};\n\tu8 i;\n\n\trtw89_debug(rtwdev, RTW89_DBG_TXPWR,\n\t\t    \"[TXPWR] set txpwr byrate with ch=%d\\n\", ch);\n\n\tBUILD_BUG_ON(rtw89_rs_idx_num[RTW89_RS_CCK] % 4);\n\tBUILD_BUG_ON(rtw89_rs_idx_num[RTW89_RS_OFDM] % 4);\n\tBUILD_BUG_ON(rtw89_rs_idx_num[RTW89_RS_MCS] % 4);\n\tBUILD_BUG_ON(rtw89_rs_idx_num[RTW89_RS_HEDCM] % 4);\n\n\taddr = R_AX_PWR_BY_RATE;\n\tfor (cur.nss = 0; cur.nss < max_nss_num; cur.nss++) {\n\t\tfor (i = 0; i < ARRAY_SIZE(rs); i++) {\n\t\t\tif (cur.nss >= rtw89_rs_nss_num[rs[i]])\n\t\t\t\tcontinue;\n\n\t\t\tcur.rs = rs[i];\n\t\t\tfor (cur.idx = 0; cur.idx < rtw89_rs_idx_num[rs[i]];\n\t\t\t     cur.idx++) {\n\t\t\t\tv[cur.idx % 4] =\n\t\t\t\t\trtw89_phy_read_txpwr_byrate(rtwdev,\n\t\t\t\t\t\t\t\t    band,\n\t\t\t\t\t\t\t\t    &cur);\n\n\t\t\t\tif ((cur.idx + 1) % 4)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tval = FIELD_PREP(GENMASK(7, 0), v[0]) |\n\t\t\t\t      FIELD_PREP(GENMASK(15, 8), v[1]) |\n\t\t\t\t      FIELD_PREP(GENMASK(23, 16), v[2]) |\n\t\t\t\t      FIELD_PREP(GENMASK(31, 24), v[3]);\n\n\t\t\t\trtw89_mac_txpwr_write32(rtwdev, phy_idx, addr,\n\t\t\t\t\t\t\tval);\n\t\t\t\taddr += 4;\n\t\t\t}\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(rtw89_phy_set_txpwr_byrate);\n\nvoid rtw89_phy_set_txpwr_offset(struct rtw89_dev *rtwdev,\n\t\t\t\tconst struct rtw89_chan *chan,\n\t\t\t\tenum rtw89_phy_idx phy_idx)\n{\n\tstruct rtw89_rate_desc desc = {\n\t\t.nss = RTW89_NSS_1,\n\t\t.rs = RTW89_RS_OFFSET,\n\t};\n\tu8 band = chan->band_type;\n\ts8 v[RTW89_RATE_OFFSET_NUM] = {};\n\tu32 val;\n\n\trtw89_debug(rtwdev, RTW89_DBG_TXPWR, \"[TXPWR] set txpwr offset\\n\");\n\n\tfor (desc.idx = 0; desc.idx < RTW89_RATE_OFFSET_NUM; desc.idx++)\n\t\tv[desc.idx] = rtw89_phy_read_txpwr_byrate(rtwdev, band, &desc);\n\n\tBUILD_BUG_ON(RTW89_RATE_OFFSET_NUM != 5);\n\tval = FIELD_PREP(GENMASK(3, 0), v[0]) |\n\t      FIELD_PREP(GENMASK(7, 4), v[1]) |\n\t      FIELD_PREP(GENMASK(11, 8), v[2]) |\n\t      FIELD_PREP(GENMASK(15, 12), v[3]) |\n\t      FIELD_PREP(GENMASK(19, 16), v[4]);\n\n\trtw89_mac_txpwr_write32_mask(rtwdev, phy_idx, R_AX_PWR_RATE_OFST_CTRL,\n\t\t\t\t     GENMASK(19, 0), val);\n}\nEXPORT_SYMBOL(rtw89_phy_set_txpwr_offset);\n\nvoid rtw89_phy_set_txpwr_limit(struct rtw89_dev *rtwdev,\n\t\t\t       const struct rtw89_chan *chan,\n\t\t\t       enum rtw89_phy_idx phy_idx)\n{\n\tu8 max_ntx_num = rtwdev->chip->rf_path_num;\n\tstruct rtw89_txpwr_limit lmt;\n\tu8 ch = chan->channel;\n\tu8 bw = chan->band_width;\n\tconst s8 *ptr;\n\tu32 addr, val;\n\tu8 i, j;\n\n\trtw89_debug(rtwdev, RTW89_DBG_TXPWR,\n\t\t    \"[TXPWR] set txpwr limit with ch=%d bw=%d\\n\", ch, bw);\n\n\tBUILD_BUG_ON(sizeof(struct rtw89_txpwr_limit) !=\n\t\t     RTW89_TXPWR_LMT_PAGE_SIZE);\n\n\taddr = R_AX_PWR_LMT;\n\tfor (i = 0; i < max_ntx_num; i++) {\n\t\trtw89_phy_fill_txpwr_limit(rtwdev, chan, &lmt, i);\n\n\t\tptr = (s8 *)&lmt;\n\t\tfor (j = 0; j < RTW89_TXPWR_LMT_PAGE_SIZE;\n\t\t     j += 4, addr += 4, ptr += 4) {\n\t\t\tval = FIELD_PREP(GENMASK(7, 0), ptr[0]) |\n\t\t\t      FIELD_PREP(GENMASK(15, 8), ptr[1]) |\n\t\t\t      FIELD_PREP(GENMASK(23, 16), ptr[2]) |\n\t\t\t      FIELD_PREP(GENMASK(31, 24), ptr[3]);\n\n\t\t\trtw89_mac_txpwr_write32(rtwdev, phy_idx, addr, val);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(rtw89_phy_set_txpwr_limit);\n\nvoid rtw89_phy_set_txpwr_limit_ru(struct rtw89_dev *rtwdev,\n\t\t\t\t  const struct rtw89_chan *chan,\n\t\t\t\t  enum rtw89_phy_idx phy_idx)\n{\n\tu8 max_ntx_num = rtwdev->chip->rf_path_num;\n\tstruct rtw89_txpwr_limit_ru lmt_ru;\n\tu8 ch = chan->channel;\n\tu8 bw = chan->band_width;\n\tconst s8 *ptr;\n\tu32 addr, val;\n\tu8 i, j;\n\n\trtw89_debug(rtwdev, RTW89_DBG_TXPWR,\n\t\t    \"[TXPWR] set txpwr limit ru with ch=%d bw=%d\\n\", ch, bw);\n\n\tBUILD_BUG_ON(sizeof(struct rtw89_txpwr_limit_ru) !=\n\t\t     RTW89_TXPWR_LMT_RU_PAGE_SIZE);\n\n\taddr = R_AX_PWR_RU_LMT;\n\tfor (i = 0; i < max_ntx_num; i++) {\n\t\trtw89_phy_fill_txpwr_limit_ru(rtwdev, chan, &lmt_ru, i);\n\n\t\tptr = (s8 *)&lmt_ru;\n\t\tfor (j = 0; j < RTW89_TXPWR_LMT_RU_PAGE_SIZE;\n\t\t     j += 4, addr += 4, ptr += 4) {\n\t\t\tval = FIELD_PREP(GENMASK(7, 0), ptr[0]) |\n\t\t\t      FIELD_PREP(GENMASK(15, 8), ptr[1]) |\n\t\t\t      FIELD_PREP(GENMASK(23, 16), ptr[2]) |\n\t\t\t      FIELD_PREP(GENMASK(31, 24), ptr[3]);\n\n\t\t\trtw89_mac_txpwr_write32(rtwdev, phy_idx, addr, val);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(rtw89_phy_set_txpwr_limit_ru);\n\nstruct rtw89_phy_iter_ra_data {\n\tstruct rtw89_dev *rtwdev;\n\tstruct sk_buff *c2h;\n};\n\nstatic void rtw89_phy_c2h_ra_rpt_iter(void *data, struct ieee80211_sta *sta)\n{\n\tstruct rtw89_phy_iter_ra_data *ra_data = (struct rtw89_phy_iter_ra_data *)data;\n\tstruct rtw89_dev *rtwdev = ra_data->rtwdev;\n\tstruct rtw89_sta *rtwsta = (struct rtw89_sta *)sta->drv_priv;\n\tconst struct rtw89_c2h_ra_rpt *c2h =\n\t\t(const struct rtw89_c2h_ra_rpt *)ra_data->c2h->data;\n\tstruct rtw89_ra_report *ra_report = &rtwsta->ra_report;\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tbool format_v1 = chip->chip_gen == RTW89_CHIP_BE;\n\tu8 mode, rate, bw, giltf, mac_id;\n\tu16 legacy_bitrate;\n\tbool valid;\n\tu8 mcs = 0;\n\tu8 t;\n\n\tmac_id = le32_get_bits(c2h->w2, RTW89_C2H_RA_RPT_W2_MACID);\n\tif (mac_id != rtwsta->mac_id)\n\t\treturn;\n\n\trate = le32_get_bits(c2h->w3, RTW89_C2H_RA_RPT_W3_MCSNSS);\n\tbw = le32_get_bits(c2h->w3, RTW89_C2H_RA_RPT_W3_BW);\n\tgiltf = le32_get_bits(c2h->w3, RTW89_C2H_RA_RPT_W3_GILTF);\n\tmode = le32_get_bits(c2h->w3, RTW89_C2H_RA_RPT_W3_MD_SEL);\n\n\tif (format_v1) {\n\t\tt = le32_get_bits(c2h->w2, RTW89_C2H_RA_RPT_W2_MCSNSS_B7);\n\t\trate |= u8_encode_bits(t, BIT(7));\n\t\tt = le32_get_bits(c2h->w3, RTW89_C2H_RA_RPT_W3_BW_B2);\n\t\tbw |= u8_encode_bits(t, BIT(2));\n\t\tt = le32_get_bits(c2h->w3, RTW89_C2H_RA_RPT_W3_MD_SEL_B2);\n\t\tmode |= u8_encode_bits(t, BIT(2));\n\t}\n\n\tif (mode == RTW89_RA_RPT_MODE_LEGACY) {\n\t\tvalid = rtw89_ra_report_to_bitrate(rtwdev, rate, &legacy_bitrate);\n\t\tif (!valid)\n\t\t\treturn;\n\t}\n\n\tmemset(&ra_report->txrate, 0, sizeof(ra_report->txrate));\n\n\tswitch (mode) {\n\tcase RTW89_RA_RPT_MODE_LEGACY:\n\t\tra_report->txrate.legacy = legacy_bitrate;\n\t\tbreak;\n\tcase RTW89_RA_RPT_MODE_HT:\n\t\tra_report->txrate.flags |= RATE_INFO_FLAGS_MCS;\n\t\tif (RTW89_CHK_FW_FEATURE(OLD_HT_RA_FORMAT, &rtwdev->fw))\n\t\t\trate = RTW89_MK_HT_RATE(FIELD_GET(RTW89_RA_RATE_MASK_NSS, rate),\n\t\t\t\t\t\tFIELD_GET(RTW89_RA_RATE_MASK_MCS, rate));\n\t\telse\n\t\t\trate = FIELD_GET(RTW89_RA_RATE_MASK_HT_MCS, rate);\n\t\tra_report->txrate.mcs = rate;\n\t\tif (giltf)\n\t\t\tra_report->txrate.flags |= RATE_INFO_FLAGS_SHORT_GI;\n\t\tmcs = ra_report->txrate.mcs & 0x07;\n\t\tbreak;\n\tcase RTW89_RA_RPT_MODE_VHT:\n\t\tra_report->txrate.flags |= RATE_INFO_FLAGS_VHT_MCS;\n\t\tra_report->txrate.mcs = format_v1 ?\n\t\t\tu8_get_bits(rate, RTW89_RA_RATE_MASK_MCS_V1) :\n\t\t\tu8_get_bits(rate, RTW89_RA_RATE_MASK_MCS);\n\t\tra_report->txrate.nss = format_v1 ?\n\t\t\tu8_get_bits(rate, RTW89_RA_RATE_MASK_NSS_V1) + 1 :\n\t\t\tu8_get_bits(rate, RTW89_RA_RATE_MASK_NSS) + 1;\n\t\tif (giltf)\n\t\t\tra_report->txrate.flags |= RATE_INFO_FLAGS_SHORT_GI;\n\t\tmcs = ra_report->txrate.mcs;\n\t\tbreak;\n\tcase RTW89_RA_RPT_MODE_HE:\n\t\tra_report->txrate.flags |= RATE_INFO_FLAGS_HE_MCS;\n\t\tra_report->txrate.mcs = format_v1 ?\n\t\t\tu8_get_bits(rate, RTW89_RA_RATE_MASK_MCS_V1) :\n\t\t\tu8_get_bits(rate, RTW89_RA_RATE_MASK_MCS);\n\t\tra_report->txrate.nss  = format_v1 ?\n\t\t\tu8_get_bits(rate, RTW89_RA_RATE_MASK_NSS_V1) + 1 :\n\t\t\tu8_get_bits(rate, RTW89_RA_RATE_MASK_NSS) + 1;\n\t\tif (giltf == RTW89_GILTF_2XHE08 || giltf == RTW89_GILTF_1XHE08)\n\t\t\tra_report->txrate.he_gi = NL80211_RATE_INFO_HE_GI_0_8;\n\t\telse if (giltf == RTW89_GILTF_2XHE16 || giltf == RTW89_GILTF_1XHE16)\n\t\t\tra_report->txrate.he_gi = NL80211_RATE_INFO_HE_GI_1_6;\n\t\telse\n\t\t\tra_report->txrate.he_gi = NL80211_RATE_INFO_HE_GI_3_2;\n\t\tmcs = ra_report->txrate.mcs;\n\t\tbreak;\n\t}\n\n\tra_report->txrate.bw = rtw89_hw_to_rate_info_bw(bw);\n\tra_report->bit_rate = cfg80211_calculate_bitrate(&ra_report->txrate);\n\tra_report->hw_rate = format_v1 ?\n\t\t\t     u16_encode_bits(mode, RTW89_HW_RATE_V1_MASK_MOD) |\n\t\t\t     u16_encode_bits(rate, RTW89_HW_RATE_V1_MASK_VAL) :\n\t\t\t     u16_encode_bits(mode, RTW89_HW_RATE_MASK_MOD) |\n\t\t\t     u16_encode_bits(rate, RTW89_HW_RATE_MASK_VAL);\n\tra_report->might_fallback_legacy = mcs <= 2;\n\tsta->deflink.agg.max_rc_amsdu_len = get_max_amsdu_len(rtwdev, ra_report);\n\trtwsta->max_agg_wait = sta->deflink.agg.max_rc_amsdu_len / 1500 - 1;\n}\n\nstatic void\nrtw89_phy_c2h_ra_rpt(struct rtw89_dev *rtwdev, struct sk_buff *c2h, u32 len)\n{\n\tstruct rtw89_phy_iter_ra_data ra_data;\n\n\tra_data.rtwdev = rtwdev;\n\tra_data.c2h = c2h;\n\tieee80211_iterate_stations_atomic(rtwdev->hw,\n\t\t\t\t\t  rtw89_phy_c2h_ra_rpt_iter,\n\t\t\t\t\t  &ra_data);\n}\n\nstatic\nvoid (* const rtw89_phy_c2h_ra_handler[])(struct rtw89_dev *rtwdev,\n\t\t\t\t\t  struct sk_buff *c2h, u32 len) = {\n\t[RTW89_PHY_C2H_FUNC_STS_RPT] = rtw89_phy_c2h_ra_rpt,\n\t[RTW89_PHY_C2H_FUNC_MU_GPTBL_RPT] = NULL,\n\t[RTW89_PHY_C2H_FUNC_TXSTS] = NULL,\n};\n\nvoid rtw89_phy_c2h_handle(struct rtw89_dev *rtwdev, struct sk_buff *skb,\n\t\t\t  u32 len, u8 class, u8 func)\n{\n\tvoid (*handler)(struct rtw89_dev *rtwdev,\n\t\t\tstruct sk_buff *c2h, u32 len) = NULL;\n\n\tswitch (class) {\n\tcase RTW89_PHY_C2H_CLASS_RA:\n\t\tif (func < RTW89_PHY_C2H_FUNC_RA_MAX)\n\t\t\thandler = rtw89_phy_c2h_ra_handler[func];\n\t\tbreak;\n\tcase RTW89_PHY_C2H_CLASS_DM:\n\t\tif (func == RTW89_PHY_C2H_DM_FUNC_LOWRT_RTY)\n\t\t\treturn;\n\t\tfallthrough;\n\tdefault:\n\t\trtw89_info(rtwdev, \"c2h class %d not support\\n\", class);\n\t\treturn;\n\t}\n\tif (!handler) {\n\t\trtw89_info(rtwdev, \"c2h class %d func %d not support\\n\", class,\n\t\t\t   func);\n\t\treturn;\n\t}\n\thandler(rtwdev, skb, len);\n}\n\nstatic u8 rtw89_phy_cfo_get_xcap_reg(struct rtw89_dev *rtwdev, bool sc_xo)\n{\n\tconst struct rtw89_xtal_info *xtal = rtwdev->chip->xtal_info;\n\tu32 reg_mask;\n\n\tif (sc_xo)\n\t\treg_mask = xtal->sc_xo_mask;\n\telse\n\t\treg_mask = xtal->sc_xi_mask;\n\n\treturn (u8)rtw89_read32_mask(rtwdev, xtal->xcap_reg, reg_mask);\n}\n\nstatic void rtw89_phy_cfo_set_xcap_reg(struct rtw89_dev *rtwdev, bool sc_xo,\n\t\t\t\t       u8 val)\n{\n\tconst struct rtw89_xtal_info *xtal = rtwdev->chip->xtal_info;\n\tu32 reg_mask;\n\n\tif (sc_xo)\n\t\treg_mask = xtal->sc_xo_mask;\n\telse\n\t\treg_mask = xtal->sc_xi_mask;\n\n\trtw89_write32_mask(rtwdev, xtal->xcap_reg, reg_mask, val);\n}\n\nstatic void rtw89_phy_cfo_set_crystal_cap(struct rtw89_dev *rtwdev,\n\t\t\t\t\t  u8 crystal_cap, bool force)\n{\n\tstruct rtw89_cfo_tracking_info *cfo = &rtwdev->cfo_tracking;\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tu8 sc_xi_val, sc_xo_val;\n\n\tif (!force && cfo->crystal_cap == crystal_cap)\n\t\treturn;\n\tcrystal_cap = clamp_t(u8, crystal_cap, 0, 127);\n\tif (chip->chip_id == RTL8852A || chip->chip_id == RTL8851B) {\n\t\trtw89_phy_cfo_set_xcap_reg(rtwdev, true, crystal_cap);\n\t\trtw89_phy_cfo_set_xcap_reg(rtwdev, false, crystal_cap);\n\t\tsc_xo_val = rtw89_phy_cfo_get_xcap_reg(rtwdev, true);\n\t\tsc_xi_val = rtw89_phy_cfo_get_xcap_reg(rtwdev, false);\n\t} else {\n\t\trtw89_mac_write_xtal_si(rtwdev, XTAL_SI_XTAL_SC_XO,\n\t\t\t\t\tcrystal_cap, XTAL_SC_XO_MASK);\n\t\trtw89_mac_write_xtal_si(rtwdev, XTAL_SI_XTAL_SC_XI,\n\t\t\t\t\tcrystal_cap, XTAL_SC_XI_MASK);\n\t\trtw89_mac_read_xtal_si(rtwdev, XTAL_SI_XTAL_SC_XO, &sc_xo_val);\n\t\trtw89_mac_read_xtal_si(rtwdev, XTAL_SI_XTAL_SC_XI, &sc_xi_val);\n\t}\n\tcfo->crystal_cap = sc_xi_val;\n\tcfo->x_cap_ofst = (s8)((int)cfo->crystal_cap - cfo->def_x_cap);\n\n\trtw89_debug(rtwdev, RTW89_DBG_CFO, \"Set sc_xi=0x%x\\n\", sc_xi_val);\n\trtw89_debug(rtwdev, RTW89_DBG_CFO, \"Set sc_xo=0x%x\\n\", sc_xo_val);\n\trtw89_debug(rtwdev, RTW89_DBG_CFO, \"Get xcap_ofst=%d\\n\",\n\t\t    cfo->x_cap_ofst);\n\trtw89_debug(rtwdev, RTW89_DBG_CFO, \"Set xcap OK\\n\");\n}\n\nstatic void rtw89_phy_cfo_reset(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_cfo_tracking_info *cfo = &rtwdev->cfo_tracking;\n\tu8 cap;\n\n\tcfo->def_x_cap = cfo->crystal_cap_default & B_AX_XTAL_SC_MASK;\n\tcfo->is_adjust = false;\n\tif (cfo->crystal_cap == cfo->def_x_cap)\n\t\treturn;\n\tcap = cfo->crystal_cap;\n\tcap += (cap > cfo->def_x_cap ? -1 : 1);\n\trtw89_phy_cfo_set_crystal_cap(rtwdev, cap, false);\n\trtw89_debug(rtwdev, RTW89_DBG_CFO,\n\t\t    \"(0x%x) approach to dflt_val=(0x%x)\\n\", cfo->crystal_cap,\n\t\t    cfo->def_x_cap);\n}\n\nstatic void rtw89_dcfo_comp(struct rtw89_dev *rtwdev, s32 curr_cfo)\n{\n\tconst struct rtw89_reg_def *dcfo_comp = rtwdev->chip->dcfo_comp;\n\tbool is_linked = rtwdev->total_sta_assoc > 0;\n\ts32 cfo_avg_312;\n\ts32 dcfo_comp_val;\n\tint sign;\n\n\tif (!is_linked) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_CFO, \"DCFO: is_linked=%d\\n\",\n\t\t\t    is_linked);\n\t\treturn;\n\t}\n\trtw89_debug(rtwdev, RTW89_DBG_CFO, \"DCFO: curr_cfo=%d\\n\", curr_cfo);\n\tif (curr_cfo == 0)\n\t\treturn;\n\tdcfo_comp_val = rtw89_phy_read32_mask(rtwdev, R_DCFO, B_DCFO);\n\tsign = curr_cfo > 0 ? 1 : -1;\n\tcfo_avg_312 = curr_cfo / 625 + sign * dcfo_comp_val;\n\trtw89_debug(rtwdev, RTW89_DBG_CFO, \"avg_cfo_312=%d step\\n\", cfo_avg_312);\n\tif (rtwdev->chip->chip_id == RTL8852A && rtwdev->hal.cv == CHIP_CBV)\n\t\tcfo_avg_312 = -cfo_avg_312;\n\trtw89_phy_set_phy_regs(rtwdev, dcfo_comp->addr, dcfo_comp->mask,\n\t\t\t       cfo_avg_312);\n}\n\nstatic void rtw89_dcfo_comp_init(struct rtw89_dev *rtwdev)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\n\trtw89_phy_set_phy_regs(rtwdev, R_DCFO_OPT, B_DCFO_OPT_EN, 1);\n\trtw89_phy_set_phy_regs(rtwdev, R_DCFO_WEIGHT, B_DCFO_WEIGHT_MSK, 8);\n\n\tif (chip->cfo_hw_comp)\n\t\trtw89_write32_mask(rtwdev, R_AX_PWR_UL_CTRL2,\n\t\t\t\t   B_AX_PWR_UL_CFO_MASK, 0x6);\n\telse\n\t\trtw89_write32_clr(rtwdev, R_AX_PWR_UL_CTRL2, B_AX_PWR_UL_CFO_MASK);\n}\n\nstatic void rtw89_phy_cfo_init(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_cfo_tracking_info *cfo = &rtwdev->cfo_tracking;\n\tstruct rtw89_efuse *efuse = &rtwdev->efuse;\n\n\tcfo->crystal_cap_default = efuse->xtal_cap & B_AX_XTAL_SC_MASK;\n\tcfo->crystal_cap = cfo->crystal_cap_default;\n\tcfo->def_x_cap = cfo->crystal_cap;\n\tcfo->x_cap_ub = min_t(int, cfo->def_x_cap + CFO_BOUND, 0x7f);\n\tcfo->x_cap_lb = max_t(int, cfo->def_x_cap - CFO_BOUND, 0x1);\n\tcfo->is_adjust = false;\n\tcfo->divergence_lock_en = false;\n\tcfo->x_cap_ofst = 0;\n\tcfo->lock_cnt = 0;\n\tcfo->rtw89_multi_cfo_mode = RTW89_TP_BASED_AVG_MODE;\n\tcfo->apply_compensation = false;\n\tcfo->residual_cfo_acc = 0;\n\trtw89_debug(rtwdev, RTW89_DBG_CFO, \"Default xcap=%0x\\n\",\n\t\t    cfo->crystal_cap_default);\n\trtw89_phy_cfo_set_crystal_cap(rtwdev, cfo->crystal_cap_default, true);\n\trtw89_phy_set_phy_regs(rtwdev, R_DCFO, B_DCFO, 1);\n\trtw89_dcfo_comp_init(rtwdev);\n\tcfo->cfo_timer_ms = 2000;\n\tcfo->cfo_trig_by_timer_en = false;\n\tcfo->phy_cfo_trk_cnt = 0;\n\tcfo->phy_cfo_status = RTW89_PHY_DCFO_STATE_NORMAL;\n\tcfo->cfo_ul_ofdma_acc_mode = RTW89_CFO_UL_OFDMA_ACC_ENABLE;\n}\n\nstatic void rtw89_phy_cfo_crystal_cap_adjust(struct rtw89_dev *rtwdev,\n\t\t\t\t\t     s32 curr_cfo)\n{\n\tstruct rtw89_cfo_tracking_info *cfo = &rtwdev->cfo_tracking;\n\ts8 crystal_cap = cfo->crystal_cap;\n\ts32 cfo_abs = abs(curr_cfo);\n\tint sign;\n\n\tif (!cfo->is_adjust) {\n\t\tif (cfo_abs > CFO_TRK_ENABLE_TH)\n\t\t\tcfo->is_adjust = true;\n\t} else {\n\t\tif (cfo_abs < CFO_TRK_STOP_TH)\n\t\t\tcfo->is_adjust = false;\n\t}\n\tif (!cfo->is_adjust) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_CFO, \"Stop CFO tracking\\n\");\n\t\treturn;\n\t}\n\tsign = curr_cfo > 0 ? 1 : -1;\n\tif (cfo_abs > CFO_TRK_STOP_TH_4)\n\t\tcrystal_cap += 7 * sign;\n\telse if (cfo_abs > CFO_TRK_STOP_TH_3)\n\t\tcrystal_cap += 5 * sign;\n\telse if (cfo_abs > CFO_TRK_STOP_TH_2)\n\t\tcrystal_cap += 3 * sign;\n\telse if (cfo_abs > CFO_TRK_STOP_TH_1)\n\t\tcrystal_cap += 1 * sign;\n\telse\n\t\treturn;\n\trtw89_phy_cfo_set_crystal_cap(rtwdev, (u8)crystal_cap, false);\n\trtw89_debug(rtwdev, RTW89_DBG_CFO,\n\t\t    \"X_cap{Curr,Default}={0x%x,0x%x}\\n\",\n\t\t    cfo->crystal_cap, cfo->def_x_cap);\n}\n\nstatic s32 rtw89_phy_average_cfo_calc(struct rtw89_dev *rtwdev)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tstruct rtw89_cfo_tracking_info *cfo = &rtwdev->cfo_tracking;\n\ts32 cfo_khz_all = 0;\n\ts32 cfo_cnt_all = 0;\n\ts32 cfo_all_avg = 0;\n\tu8 i;\n\n\tif (rtwdev->total_sta_assoc != 1)\n\t\treturn 0;\n\trtw89_debug(rtwdev, RTW89_DBG_CFO, \"one_entry_only\\n\");\n\tfor (i = 0; i < CFO_TRACK_MAX_USER; i++) {\n\t\tif (cfo->cfo_cnt[i] == 0)\n\t\t\tcontinue;\n\t\tcfo_khz_all += cfo->cfo_tail[i];\n\t\tcfo_cnt_all += cfo->cfo_cnt[i];\n\t\tcfo_all_avg = phy_div(cfo_khz_all, cfo_cnt_all);\n\t\tcfo->pre_cfo_avg[i] = cfo->cfo_avg[i];\n\t\tcfo->dcfo_avg = phy_div(cfo_khz_all << chip->dcfo_comp_sft,\n\t\t\t\t\tcfo_cnt_all);\n\t}\n\trtw89_debug(rtwdev, RTW89_DBG_CFO,\n\t\t    \"CFO track for macid = %d\\n\", i);\n\trtw89_debug(rtwdev, RTW89_DBG_CFO,\n\t\t    \"Total cfo=%dK, pkt_cnt=%d, avg_cfo=%dK\\n\",\n\t\t    cfo_khz_all, cfo_cnt_all, cfo_all_avg);\n\treturn cfo_all_avg;\n}\n\nstatic s32 rtw89_phy_multi_sta_cfo_calc(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_cfo_tracking_info *cfo = &rtwdev->cfo_tracking;\n\tstruct rtw89_traffic_stats *stats = &rtwdev->stats;\n\ts32 target_cfo = 0;\n\ts32 cfo_khz_all = 0;\n\ts32 cfo_khz_all_tp_wgt = 0;\n\ts32 cfo_avg = 0;\n\ts32 max_cfo_lb = BIT(31);\n\ts32 min_cfo_ub = GENMASK(30, 0);\n\tu16 cfo_cnt_all = 0;\n\tu8 active_entry_cnt = 0;\n\tu8 sta_cnt = 0;\n\tu32 tp_all = 0;\n\tu8 i;\n\tu8 cfo_tol = 0;\n\n\trtw89_debug(rtwdev, RTW89_DBG_CFO, \"Multi entry cfo_trk\\n\");\n\tif (cfo->rtw89_multi_cfo_mode == RTW89_PKT_BASED_AVG_MODE) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_CFO, \"Pkt based avg mode\\n\");\n\t\tfor (i = 0; i < CFO_TRACK_MAX_USER; i++) {\n\t\t\tif (cfo->cfo_cnt[i] == 0)\n\t\t\t\tcontinue;\n\t\t\tcfo_khz_all += cfo->cfo_tail[i];\n\t\t\tcfo_cnt_all += cfo->cfo_cnt[i];\n\t\t\tcfo_avg = phy_div(cfo_khz_all, (s32)cfo_cnt_all);\n\t\t\trtw89_debug(rtwdev, RTW89_DBG_CFO,\n\t\t\t\t    \"Msta cfo=%d, pkt_cnt=%d, avg_cfo=%d\\n\",\n\t\t\t\t    cfo_khz_all, cfo_cnt_all, cfo_avg);\n\t\t\ttarget_cfo = cfo_avg;\n\t\t}\n\t} else if (cfo->rtw89_multi_cfo_mode == RTW89_ENTRY_BASED_AVG_MODE) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_CFO, \"Entry based avg mode\\n\");\n\t\tfor (i = 0; i < CFO_TRACK_MAX_USER; i++) {\n\t\t\tif (cfo->cfo_cnt[i] == 0)\n\t\t\t\tcontinue;\n\t\t\tcfo->cfo_avg[i] = phy_div(cfo->cfo_tail[i],\n\t\t\t\t\t\t  (s32)cfo->cfo_cnt[i]);\n\t\t\tcfo_khz_all += cfo->cfo_avg[i];\n\t\t\trtw89_debug(rtwdev, RTW89_DBG_CFO,\n\t\t\t\t    \"Macid=%d, cfo_avg=%d\\n\", i,\n\t\t\t\t    cfo->cfo_avg[i]);\n\t\t}\n\t\tsta_cnt = rtwdev->total_sta_assoc;\n\t\tcfo_avg = phy_div(cfo_khz_all, (s32)sta_cnt);\n\t\trtw89_debug(rtwdev, RTW89_DBG_CFO,\n\t\t\t    \"Msta cfo_acc=%d, ent_cnt=%d, avg_cfo=%d\\n\",\n\t\t\t    cfo_khz_all, sta_cnt, cfo_avg);\n\t\ttarget_cfo = cfo_avg;\n\t} else if (cfo->rtw89_multi_cfo_mode == RTW89_TP_BASED_AVG_MODE) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_CFO, \"TP based avg mode\\n\");\n\t\tcfo_tol = cfo->sta_cfo_tolerance;\n\t\tfor (i = 0; i < CFO_TRACK_MAX_USER; i++) {\n\t\t\tsta_cnt++;\n\t\t\tif (cfo->cfo_cnt[i] != 0) {\n\t\t\t\tcfo->cfo_avg[i] = phy_div(cfo->cfo_tail[i],\n\t\t\t\t\t\t\t  (s32)cfo->cfo_cnt[i]);\n\t\t\t\tactive_entry_cnt++;\n\t\t\t} else {\n\t\t\t\tcfo->cfo_avg[i] = cfo->pre_cfo_avg[i];\n\t\t\t}\n\t\t\tmax_cfo_lb = max(cfo->cfo_avg[i] - cfo_tol, max_cfo_lb);\n\t\t\tmin_cfo_ub = min(cfo->cfo_avg[i] + cfo_tol, min_cfo_ub);\n\t\t\tcfo_khz_all += cfo->cfo_avg[i];\n\t\t\t \n\t\t\trtw89_debug(rtwdev, RTW89_DBG_CFO,\n\t\t\t\t    \"[%d] cfo_avg=%d, tp=tbd\\n\",\n\t\t\t\t    i, cfo->cfo_avg[i]);\n\t\t\tif (sta_cnt >= rtwdev->total_sta_assoc)\n\t\t\t\tbreak;\n\t\t}\n\t\ttp_all = stats->rx_throughput;  \n\t\tcfo_avg =  phy_div(cfo_khz_all_tp_wgt, (s32)tp_all);\n\n\t\trtw89_debug(rtwdev, RTW89_DBG_CFO, \"Assoc sta cnt=%d\\n\",\n\t\t\t    sta_cnt);\n\t\trtw89_debug(rtwdev, RTW89_DBG_CFO, \"Active sta cnt=%d\\n\",\n\t\t\t    active_entry_cnt);\n\t\trtw89_debug(rtwdev, RTW89_DBG_CFO,\n\t\t\t    \"Msta cfo with tp_wgt=%d, avg_cfo=%d\\n\",\n\t\t\t    cfo_khz_all_tp_wgt, cfo_avg);\n\t\trtw89_debug(rtwdev, RTW89_DBG_CFO, \"cfo_lb=%d,cfo_ub=%d\\n\",\n\t\t\t    max_cfo_lb, min_cfo_ub);\n\t\tif (max_cfo_lb <= min_cfo_ub) {\n\t\t\trtw89_debug(rtwdev, RTW89_DBG_CFO,\n\t\t\t\t    \"cfo win_size=%d\\n\",\n\t\t\t\t    min_cfo_ub - max_cfo_lb);\n\t\t\ttarget_cfo = clamp(cfo_avg, max_cfo_lb, min_cfo_ub);\n\t\t} else {\n\t\t\trtw89_debug(rtwdev, RTW89_DBG_CFO,\n\t\t\t\t    \"No intersection of cfo tolerance windows\\n\");\n\t\t\ttarget_cfo = phy_div(cfo_khz_all, (s32)sta_cnt);\n\t\t}\n\t\tfor (i = 0; i < CFO_TRACK_MAX_USER; i++)\n\t\t\tcfo->pre_cfo_avg[i] = cfo->cfo_avg[i];\n\t}\n\trtw89_debug(rtwdev, RTW89_DBG_CFO, \"Target cfo=%d\\n\", target_cfo);\n\treturn target_cfo;\n}\n\nstatic void rtw89_phy_cfo_statistics_reset(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_cfo_tracking_info *cfo = &rtwdev->cfo_tracking;\n\n\tmemset(&cfo->cfo_tail, 0, sizeof(cfo->cfo_tail));\n\tmemset(&cfo->cfo_cnt, 0, sizeof(cfo->cfo_cnt));\n\tcfo->packet_count = 0;\n\tcfo->packet_count_pre = 0;\n\tcfo->cfo_avg_pre = 0;\n}\n\nstatic void rtw89_phy_cfo_dm(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_cfo_tracking_info *cfo = &rtwdev->cfo_tracking;\n\ts32 new_cfo = 0;\n\tbool x_cap_update = false;\n\tu8 pre_x_cap = cfo->crystal_cap;\n\tu8 dcfo_comp_sft = rtwdev->chip->dcfo_comp_sft;\n\n\tcfo->dcfo_avg = 0;\n\trtw89_debug(rtwdev, RTW89_DBG_CFO, \"CFO:total_sta_assoc=%d\\n\",\n\t\t    rtwdev->total_sta_assoc);\n\tif (rtwdev->total_sta_assoc == 0) {\n\t\trtw89_phy_cfo_reset(rtwdev);\n\t\treturn;\n\t}\n\tif (cfo->packet_count == 0) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_CFO, \"Pkt cnt = 0\\n\");\n\t\treturn;\n\t}\n\tif (cfo->packet_count == cfo->packet_count_pre) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_CFO, \"Pkt cnt doesn't change\\n\");\n\t\treturn;\n\t}\n\tif (rtwdev->total_sta_assoc == 1)\n\t\tnew_cfo = rtw89_phy_average_cfo_calc(rtwdev);\n\telse\n\t\tnew_cfo = rtw89_phy_multi_sta_cfo_calc(rtwdev);\n\tif (new_cfo == 0) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_CFO, \"curr_cfo=0\\n\");\n\t\treturn;\n\t}\n\tif (cfo->divergence_lock_en) {\n\t\tcfo->lock_cnt++;\n\t\tif (cfo->lock_cnt > CFO_PERIOD_CNT) {\n\t\t\tcfo->divergence_lock_en = false;\n\t\t\tcfo->lock_cnt = 0;\n\t\t} else {\n\t\t\trtw89_phy_cfo_reset(rtwdev);\n\t\t}\n\t\treturn;\n\t}\n\tif (cfo->crystal_cap >= cfo->x_cap_ub ||\n\t    cfo->crystal_cap <= cfo->x_cap_lb) {\n\t\tcfo->divergence_lock_en = true;\n\t\trtw89_phy_cfo_reset(rtwdev);\n\t\treturn;\n\t}\n\n\trtw89_phy_cfo_crystal_cap_adjust(rtwdev, new_cfo);\n\tcfo->cfo_avg_pre = new_cfo;\n\tcfo->dcfo_avg_pre = cfo->dcfo_avg;\n\tx_cap_update =  cfo->crystal_cap != pre_x_cap;\n\trtw89_debug(rtwdev, RTW89_DBG_CFO, \"Xcap_up=%d\\n\", x_cap_update);\n\trtw89_debug(rtwdev, RTW89_DBG_CFO, \"Xcap: D:%x C:%x->%x, ofst=%d\\n\",\n\t\t    cfo->def_x_cap, pre_x_cap, cfo->crystal_cap,\n\t\t    cfo->x_cap_ofst);\n\tif (x_cap_update) {\n\t\tif (cfo->dcfo_avg > 0)\n\t\t\tcfo->dcfo_avg -= CFO_SW_COMP_FINE_TUNE << dcfo_comp_sft;\n\t\telse\n\t\t\tcfo->dcfo_avg += CFO_SW_COMP_FINE_TUNE << dcfo_comp_sft;\n\t}\n\trtw89_dcfo_comp(rtwdev, cfo->dcfo_avg);\n\trtw89_phy_cfo_statistics_reset(rtwdev);\n}\n\nvoid rtw89_phy_cfo_track_work(struct work_struct *work)\n{\n\tstruct rtw89_dev *rtwdev = container_of(work, struct rtw89_dev,\n\t\t\t\t\t\tcfo_track_work.work);\n\tstruct rtw89_cfo_tracking_info *cfo = &rtwdev->cfo_tracking;\n\n\tmutex_lock(&rtwdev->mutex);\n\tif (!cfo->cfo_trig_by_timer_en)\n\t\tgoto out;\n\trtw89_leave_ps_mode(rtwdev);\n\trtw89_phy_cfo_dm(rtwdev);\n\tieee80211_queue_delayed_work(rtwdev->hw, &rtwdev->cfo_track_work,\n\t\t\t\t     msecs_to_jiffies(cfo->cfo_timer_ms));\nout:\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nstatic void rtw89_phy_cfo_start_work(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_cfo_tracking_info *cfo = &rtwdev->cfo_tracking;\n\n\tieee80211_queue_delayed_work(rtwdev->hw, &rtwdev->cfo_track_work,\n\t\t\t\t     msecs_to_jiffies(cfo->cfo_timer_ms));\n}\n\nvoid rtw89_phy_cfo_track(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_cfo_tracking_info *cfo = &rtwdev->cfo_tracking;\n\tstruct rtw89_traffic_stats *stats = &rtwdev->stats;\n\tbool is_ul_ofdma = false, ofdma_acc_en = false;\n\n\tif (stats->rx_tf_periodic > CFO_TF_CNT_TH)\n\t\tis_ul_ofdma = true;\n\tif (cfo->cfo_ul_ofdma_acc_mode == RTW89_CFO_UL_OFDMA_ACC_ENABLE &&\n\t    is_ul_ofdma)\n\t\tofdma_acc_en = true;\n\n\tswitch (cfo->phy_cfo_status) {\n\tcase RTW89_PHY_DCFO_STATE_NORMAL:\n\t\tif (stats->tx_throughput >= CFO_TP_UPPER) {\n\t\t\tcfo->phy_cfo_status = RTW89_PHY_DCFO_STATE_ENHANCE;\n\t\t\tcfo->cfo_trig_by_timer_en = true;\n\t\t\tcfo->cfo_timer_ms = CFO_COMP_PERIOD;\n\t\t\trtw89_phy_cfo_start_work(rtwdev);\n\t\t}\n\t\tbreak;\n\tcase RTW89_PHY_DCFO_STATE_ENHANCE:\n\t\tif (stats->tx_throughput <= CFO_TP_LOWER)\n\t\t\tcfo->phy_cfo_status = RTW89_PHY_DCFO_STATE_NORMAL;\n\t\telse if (ofdma_acc_en &&\n\t\t\t cfo->phy_cfo_trk_cnt >= CFO_PERIOD_CNT)\n\t\t\tcfo->phy_cfo_status = RTW89_PHY_DCFO_STATE_HOLD;\n\t\telse\n\t\t\tcfo->phy_cfo_trk_cnt++;\n\n\t\tif (cfo->phy_cfo_status == RTW89_PHY_DCFO_STATE_NORMAL) {\n\t\t\tcfo->phy_cfo_trk_cnt = 0;\n\t\t\tcfo->cfo_trig_by_timer_en = false;\n\t\t}\n\t\tbreak;\n\tcase RTW89_PHY_DCFO_STATE_HOLD:\n\t\tif (stats->tx_throughput <= CFO_TP_LOWER) {\n\t\t\tcfo->phy_cfo_status = RTW89_PHY_DCFO_STATE_NORMAL;\n\t\t\tcfo->phy_cfo_trk_cnt = 0;\n\t\t\tcfo->cfo_trig_by_timer_en = false;\n\t\t} else {\n\t\t\tcfo->phy_cfo_trk_cnt++;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tcfo->phy_cfo_status = RTW89_PHY_DCFO_STATE_NORMAL;\n\t\tcfo->phy_cfo_trk_cnt = 0;\n\t\tbreak;\n\t}\n\trtw89_debug(rtwdev, RTW89_DBG_CFO,\n\t\t    \"[CFO]WatchDog tp=%d,state=%d,timer_en=%d,trk_cnt=%d,thermal=%ld\\n\",\n\t\t    stats->tx_throughput, cfo->phy_cfo_status,\n\t\t    cfo->cfo_trig_by_timer_en, cfo->phy_cfo_trk_cnt,\n\t\t    ewma_thermal_read(&rtwdev->phystat.avg_thermal[0]));\n\tif (cfo->cfo_trig_by_timer_en)\n\t\treturn;\n\trtw89_phy_cfo_dm(rtwdev);\n}\n\nvoid rtw89_phy_cfo_parse(struct rtw89_dev *rtwdev, s16 cfo_val,\n\t\t\t struct rtw89_rx_phy_ppdu *phy_ppdu)\n{\n\tstruct rtw89_cfo_tracking_info *cfo = &rtwdev->cfo_tracking;\n\tu8 macid = phy_ppdu->mac_id;\n\n\tif (macid >= CFO_TRACK_MAX_USER) {\n\t\trtw89_warn(rtwdev, \"mac_id %d is out of range\\n\", macid);\n\t\treturn;\n\t}\n\n\tcfo->cfo_tail[macid] += cfo_val;\n\tcfo->cfo_cnt[macid]++;\n\tcfo->packet_count++;\n}\n\nvoid rtw89_phy_ul_tb_assoc(struct rtw89_dev *rtwdev, struct rtw89_vif *rtwvif)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tconst struct rtw89_chan *chan = rtw89_chan_get(rtwdev,\n\t\t\t\t\t\t       rtwvif->sub_entity_idx);\n\tstruct rtw89_phy_ul_tb_info *ul_tb_info = &rtwdev->ul_tb_info;\n\n\tif (!chip->support_ul_tb_ctrl)\n\t\treturn;\n\n\trtwvif->def_tri_idx =\n\t\trtw89_phy_read32_mask(rtwdev, R_DCFO_OPT, B_TXSHAPE_TRIANGULAR_CFG);\n\n\tif (chip->chip_id == RTL8852B && rtwdev->hal.cv > CHIP_CBV)\n\t\trtwvif->dyn_tb_bedge_en = false;\n\telse if (chan->band_type >= RTW89_BAND_5G &&\n\t\t chan->band_width >= RTW89_CHANNEL_WIDTH_40)\n\t\trtwvif->dyn_tb_bedge_en = true;\n\telse\n\t\trtwvif->dyn_tb_bedge_en = false;\n\n\trtw89_debug(rtwdev, RTW89_DBG_UL_TB,\n\t\t    \"[ULTB] def_if_bandedge=%d, def_tri_idx=%d\\n\",\n\t\t    ul_tb_info->def_if_bandedge, rtwvif->def_tri_idx);\n\trtw89_debug(rtwdev, RTW89_DBG_UL_TB,\n\t\t    \"[ULTB] dyn_tb_begde_en=%d, dyn_tb_tri_en=%d\\n\",\n\t\t    rtwvif->dyn_tb_bedge_en, ul_tb_info->dyn_tb_tri_en);\n}\n\nstruct rtw89_phy_ul_tb_check_data {\n\tbool valid;\n\tbool high_tf_client;\n\tbool low_tf_client;\n\tbool dyn_tb_bedge_en;\n\tu8 def_tri_idx;\n};\n\nstatic\nvoid rtw89_phy_ul_tb_ctrl_check(struct rtw89_dev *rtwdev,\n\t\t\t\tstruct rtw89_vif *rtwvif,\n\t\t\t\tstruct rtw89_phy_ul_tb_check_data *ul_tb_data)\n{\n\tstruct rtw89_traffic_stats *stats = &rtwdev->stats;\n\tstruct ieee80211_vif *vif = rtwvif_to_vif(rtwvif);\n\n\tif (rtwvif->wifi_role != RTW89_WIFI_ROLE_STATION)\n\t\treturn;\n\n\tif (!vif->cfg.assoc)\n\t\treturn;\n\n\tif (stats->rx_tf_periodic > UL_TB_TF_CNT_L2H_TH)\n\t\tul_tb_data->high_tf_client = true;\n\telse if (stats->rx_tf_periodic < UL_TB_TF_CNT_H2L_TH)\n\t\tul_tb_data->low_tf_client = true;\n\n\tul_tb_data->valid = true;\n\tul_tb_data->def_tri_idx = rtwvif->def_tri_idx;\n\tul_tb_data->dyn_tb_bedge_en = rtwvif->dyn_tb_bedge_en;\n}\n\nvoid rtw89_phy_ul_tb_ctrl_track(struct rtw89_dev *rtwdev)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tstruct rtw89_phy_ul_tb_info *ul_tb_info = &rtwdev->ul_tb_info;\n\tstruct rtw89_phy_ul_tb_check_data ul_tb_data = {};\n\tstruct rtw89_vif *rtwvif;\n\n\tif (!chip->support_ul_tb_ctrl)\n\t\treturn;\n\n\tif (rtwdev->total_sta_assoc != 1)\n\t\treturn;\n\n\trtw89_for_each_rtwvif(rtwdev, rtwvif)\n\t\trtw89_phy_ul_tb_ctrl_check(rtwdev, rtwvif, &ul_tb_data);\n\n\tif (!ul_tb_data.valid)\n\t\treturn;\n\n\tif (ul_tb_data.dyn_tb_bedge_en) {\n\t\tif (ul_tb_data.high_tf_client) {\n\t\t\trtw89_phy_write32_mask(rtwdev, R_BANDEDGE, B_BANDEDGE_EN, 0);\n\t\t\trtw89_debug(rtwdev, RTW89_DBG_UL_TB,\n\t\t\t\t    \"[ULTB] Turn off if_bandedge\\n\");\n\t\t} else if (ul_tb_data.low_tf_client) {\n\t\t\trtw89_phy_write32_mask(rtwdev, R_BANDEDGE, B_BANDEDGE_EN,\n\t\t\t\t\t       ul_tb_info->def_if_bandedge);\n\t\t\trtw89_debug(rtwdev, RTW89_DBG_UL_TB,\n\t\t\t\t    \"[ULTB] Set to default if_bandedge = %d\\n\",\n\t\t\t\t    ul_tb_info->def_if_bandedge);\n\t\t}\n\t}\n\n\tif (ul_tb_info->dyn_tb_tri_en) {\n\t\tif (ul_tb_data.high_tf_client) {\n\t\t\trtw89_phy_write32_mask(rtwdev, R_DCFO_OPT,\n\t\t\t\t\t       B_TXSHAPE_TRIANGULAR_CFG, 0);\n\t\t\trtw89_debug(rtwdev, RTW89_DBG_UL_TB,\n\t\t\t\t    \"[ULTB] Turn off Tx triangle\\n\");\n\t\t} else if (ul_tb_data.low_tf_client) {\n\t\t\trtw89_phy_write32_mask(rtwdev, R_DCFO_OPT,\n\t\t\t\t\t       B_TXSHAPE_TRIANGULAR_CFG,\n\t\t\t\t\t       ul_tb_data.def_tri_idx);\n\t\t\trtw89_debug(rtwdev, RTW89_DBG_UL_TB,\n\t\t\t\t    \"[ULTB] Set to default tx_shap_idx = %d\\n\",\n\t\t\t\t    ul_tb_data.def_tri_idx);\n\t\t}\n\t}\n}\n\nstatic void rtw89_phy_ul_tb_info_init(struct rtw89_dev *rtwdev)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tstruct rtw89_phy_ul_tb_info *ul_tb_info = &rtwdev->ul_tb_info;\n\n\tif (!chip->support_ul_tb_ctrl)\n\t\treturn;\n\n\tul_tb_info->dyn_tb_tri_en = true;\n\tul_tb_info->def_if_bandedge =\n\t\trtw89_phy_read32_mask(rtwdev, R_BANDEDGE, B_BANDEDGE_EN);\n}\n\nstatic\nvoid rtw89_phy_antdiv_sts_instance_reset(struct rtw89_antdiv_stats *antdiv_sts)\n{\n\tewma_rssi_init(&antdiv_sts->cck_rssi_avg);\n\tewma_rssi_init(&antdiv_sts->ofdm_rssi_avg);\n\tewma_rssi_init(&antdiv_sts->non_legacy_rssi_avg);\n\tantdiv_sts->pkt_cnt_cck = 0;\n\tantdiv_sts->pkt_cnt_ofdm = 0;\n\tantdiv_sts->pkt_cnt_non_legacy = 0;\n\tantdiv_sts->evm = 0;\n}\n\nstatic void rtw89_phy_antdiv_sts_instance_add(struct rtw89_dev *rtwdev,\n\t\t\t\t\t      struct rtw89_rx_phy_ppdu *phy_ppdu,\n\t\t\t\t\t      struct rtw89_antdiv_stats *stats)\n{\n\tif (rtw89_get_data_rate_mode(rtwdev, phy_ppdu->rate) == DATA_RATE_MODE_NON_HT) {\n\t\tif (phy_ppdu->rate < RTW89_HW_RATE_OFDM6) {\n\t\t\tewma_rssi_add(&stats->cck_rssi_avg, phy_ppdu->rssi_avg);\n\t\t\tstats->pkt_cnt_cck++;\n\t\t} else {\n\t\t\tewma_rssi_add(&stats->ofdm_rssi_avg, phy_ppdu->rssi_avg);\n\t\t\tstats->pkt_cnt_ofdm++;\n\t\t\tstats->evm += phy_ppdu->ofdm.evm_min;\n\t\t}\n\t} else {\n\t\tewma_rssi_add(&stats->non_legacy_rssi_avg, phy_ppdu->rssi_avg);\n\t\tstats->pkt_cnt_non_legacy++;\n\t\tstats->evm += phy_ppdu->ofdm.evm_min;\n\t}\n}\n\nstatic u8 rtw89_phy_antdiv_sts_instance_get_rssi(struct rtw89_antdiv_stats *stats)\n{\n\tif (stats->pkt_cnt_non_legacy >= stats->pkt_cnt_cck &&\n\t    stats->pkt_cnt_non_legacy >= stats->pkt_cnt_ofdm)\n\t\treturn ewma_rssi_read(&stats->non_legacy_rssi_avg);\n\telse if (stats->pkt_cnt_ofdm >= stats->pkt_cnt_cck &&\n\t\t stats->pkt_cnt_ofdm >= stats->pkt_cnt_non_legacy)\n\t\treturn ewma_rssi_read(&stats->ofdm_rssi_avg);\n\telse\n\t\treturn ewma_rssi_read(&stats->cck_rssi_avg);\n}\n\nstatic u8 rtw89_phy_antdiv_sts_instance_get_evm(struct rtw89_antdiv_stats *stats)\n{\n\treturn phy_div(stats->evm, stats->pkt_cnt_non_legacy + stats->pkt_cnt_ofdm);\n}\n\nvoid rtw89_phy_antdiv_parse(struct rtw89_dev *rtwdev,\n\t\t\t    struct rtw89_rx_phy_ppdu *phy_ppdu)\n{\n\tstruct rtw89_antdiv_info *antdiv = &rtwdev->antdiv;\n\tstruct rtw89_hal *hal = &rtwdev->hal;\n\n\tif (!hal->ant_diversity || hal->ant_diversity_fixed)\n\t\treturn;\n\n\trtw89_phy_antdiv_sts_instance_add(rtwdev, phy_ppdu, &antdiv->target_stats);\n\n\tif (!antdiv->get_stats)\n\t\treturn;\n\n\tif (hal->antenna_rx == RF_A)\n\t\trtw89_phy_antdiv_sts_instance_add(rtwdev, phy_ppdu, &antdiv->main_stats);\n\telse if (hal->antenna_rx == RF_B)\n\t\trtw89_phy_antdiv_sts_instance_add(rtwdev, phy_ppdu, &antdiv->aux_stats);\n}\n\nstatic void rtw89_phy_antdiv_reg_init(struct rtw89_dev *rtwdev)\n{\n\trtw89_phy_write32_idx(rtwdev, R_P0_TRSW, B_P0_ANT_TRAIN_EN,\n\t\t\t      0x0, RTW89_PHY_0);\n\trtw89_phy_write32_idx(rtwdev, R_P0_TRSW, B_P0_TX_ANT_SEL,\n\t\t\t      0x0, RTW89_PHY_0);\n\n\trtw89_phy_write32_idx(rtwdev, R_P0_ANT_SW, B_P0_TRSW_TX_EXTEND,\n\t\t\t      0x0, RTW89_PHY_0);\n\trtw89_phy_write32_idx(rtwdev, R_P0_ANT_SW, B_P0_HW_ANTSW_DIS_BY_GNT_BT,\n\t\t\t      0x0, RTW89_PHY_0);\n\n\trtw89_phy_write32_idx(rtwdev, R_P0_TRSW, B_P0_BT_FORCE_ANTIDX_EN,\n\t\t\t      0x0, RTW89_PHY_0);\n\n\trtw89_phy_write32_idx(rtwdev, R_RFSW_CTRL_ANT0_BASE, B_RFSW_CTRL_ANT_MAPPING,\n\t\t\t      0x0100, RTW89_PHY_0);\n\n\trtw89_phy_write32_idx(rtwdev, R_P0_ANTSEL, B_P0_ANTSEL_BTG_TRX,\n\t\t\t      0x1, RTW89_PHY_0);\n\trtw89_phy_write32_idx(rtwdev, R_P0_ANTSEL, B_P0_ANTSEL_HW_CTRL,\n\t\t\t      0x0, RTW89_PHY_0);\n\trtw89_phy_write32_idx(rtwdev, R_P0_ANTSEL, B_P0_ANTSEL_SW_2G,\n\t\t\t      0x0, RTW89_PHY_0);\n\trtw89_phy_write32_idx(rtwdev, R_P0_ANTSEL, B_P0_ANTSEL_SW_5G,\n\t\t\t      0x0, RTW89_PHY_0);\n}\n\nstatic void rtw89_phy_antdiv_sts_reset(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_antdiv_info *antdiv = &rtwdev->antdiv;\n\n\trtw89_phy_antdiv_sts_instance_reset(&antdiv->target_stats);\n\trtw89_phy_antdiv_sts_instance_reset(&antdiv->main_stats);\n\trtw89_phy_antdiv_sts_instance_reset(&antdiv->aux_stats);\n}\n\nstatic void rtw89_phy_antdiv_init(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_antdiv_info *antdiv = &rtwdev->antdiv;\n\tstruct rtw89_hal *hal = &rtwdev->hal;\n\n\tif (!hal->ant_diversity)\n\t\treturn;\n\n\tantdiv->get_stats = false;\n\tantdiv->rssi_pre = 0;\n\trtw89_phy_antdiv_sts_reset(rtwdev);\n\trtw89_phy_antdiv_reg_init(rtwdev);\n}\n\nstatic void rtw89_phy_stat_thermal_update(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_phy_stat *phystat = &rtwdev->phystat;\n\tint i;\n\tu8 th;\n\n\tfor (i = 0; i < rtwdev->chip->rf_path_num; i++) {\n\t\tth = rtw89_chip_get_thermal(rtwdev, i);\n\t\tif (th)\n\t\t\tewma_thermal_add(&phystat->avg_thermal[i], th);\n\n\t\trtw89_debug(rtwdev, RTW89_DBG_RFK_TRACK,\n\t\t\t    \"path(%d) thermal cur=%u avg=%ld\", i, th,\n\t\t\t    ewma_thermal_read(&phystat->avg_thermal[i]));\n\t}\n}\n\nstruct rtw89_phy_iter_rssi_data {\n\tstruct rtw89_dev *rtwdev;\n\tstruct rtw89_phy_ch_info *ch_info;\n\tbool rssi_changed;\n};\n\nstatic void rtw89_phy_stat_rssi_update_iter(void *data,\n\t\t\t\t\t    struct ieee80211_sta *sta)\n{\n\tstruct rtw89_sta *rtwsta = (struct rtw89_sta *)sta->drv_priv;\n\tstruct rtw89_phy_iter_rssi_data *rssi_data =\n\t\t\t\t\t(struct rtw89_phy_iter_rssi_data *)data;\n\tstruct rtw89_phy_ch_info *ch_info = rssi_data->ch_info;\n\tunsigned long rssi_curr;\n\n\trssi_curr = ewma_rssi_read(&rtwsta->avg_rssi);\n\n\tif (rssi_curr < ch_info->rssi_min) {\n\t\tch_info->rssi_min = rssi_curr;\n\t\tch_info->rssi_min_macid = rtwsta->mac_id;\n\t}\n\n\tif (rtwsta->prev_rssi == 0) {\n\t\trtwsta->prev_rssi = rssi_curr;\n\t} else if (abs((int)rtwsta->prev_rssi - (int)rssi_curr) > (3 << RSSI_FACTOR)) {\n\t\trtwsta->prev_rssi = rssi_curr;\n\t\trssi_data->rssi_changed = true;\n\t}\n}\n\nstatic void rtw89_phy_stat_rssi_update(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_phy_iter_rssi_data rssi_data = {0};\n\n\trssi_data.rtwdev = rtwdev;\n\trssi_data.ch_info = &rtwdev->ch_info;\n\trssi_data.ch_info->rssi_min = U8_MAX;\n\tieee80211_iterate_stations_atomic(rtwdev->hw,\n\t\t\t\t\t  rtw89_phy_stat_rssi_update_iter,\n\t\t\t\t\t  &rssi_data);\n\tif (rssi_data.rssi_changed)\n\t\trtw89_btc_ntfy_wl_sta(rtwdev);\n}\n\nstatic void rtw89_phy_stat_init(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_phy_stat *phystat = &rtwdev->phystat;\n\tint i;\n\n\tfor (i = 0; i < rtwdev->chip->rf_path_num; i++)\n\t\tewma_thermal_init(&phystat->avg_thermal[i]);\n\n\trtw89_phy_stat_thermal_update(rtwdev);\n\n\tmemset(&phystat->cur_pkt_stat, 0, sizeof(phystat->cur_pkt_stat));\n\tmemset(&phystat->last_pkt_stat, 0, sizeof(phystat->last_pkt_stat));\n}\n\nvoid rtw89_phy_stat_track(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_phy_stat *phystat = &rtwdev->phystat;\n\n\trtw89_phy_stat_thermal_update(rtwdev);\n\trtw89_phy_stat_rssi_update(rtwdev);\n\n\tphystat->last_pkt_stat = phystat->cur_pkt_stat;\n\tmemset(&phystat->cur_pkt_stat, 0, sizeof(phystat->cur_pkt_stat));\n}\n\nstatic u16 rtw89_phy_ccx_us_to_idx(struct rtw89_dev *rtwdev, u32 time_us)\n{\n\tstruct rtw89_env_monitor_info *env = &rtwdev->env_monitor;\n\n\treturn time_us >> (ilog2(CCX_US_BASE_RATIO) + env->ccx_unit_idx);\n}\n\nstatic u32 rtw89_phy_ccx_idx_to_us(struct rtw89_dev *rtwdev, u16 idx)\n{\n\tstruct rtw89_env_monitor_info *env = &rtwdev->env_monitor;\n\n\treturn idx << (ilog2(CCX_US_BASE_RATIO) + env->ccx_unit_idx);\n}\n\nstatic void rtw89_phy_ccx_top_setting_init(struct rtw89_dev *rtwdev)\n{\n\tconst struct rtw89_phy_gen_def *phy = rtwdev->chip->phy_def;\n\tstruct rtw89_env_monitor_info *env = &rtwdev->env_monitor;\n\tconst struct rtw89_ccx_regs *ccx = phy->ccx;\n\n\tenv->ccx_manual_ctrl = false;\n\tenv->ccx_ongoing = false;\n\tenv->ccx_rac_lv = RTW89_RAC_RELEASE;\n\tenv->ccx_period = 0;\n\tenv->ccx_unit_idx = RTW89_CCX_32_US;\n\n\trtw89_phy_set_phy_regs(rtwdev, ccx->setting_addr, ccx->en_mask, 1);\n\trtw89_phy_set_phy_regs(rtwdev, ccx->setting_addr, ccx->trig_opt_mask, 1);\n\trtw89_phy_set_phy_regs(rtwdev, ccx->setting_addr, ccx->measurement_trig_mask, 1);\n\trtw89_phy_set_phy_regs(rtwdev, ccx->setting_addr, ccx->edcca_opt_mask,\n\t\t\t       RTW89_CCX_EDCCA_BW20_0);\n}\n\nstatic u16 rtw89_phy_ccx_get_report(struct rtw89_dev *rtwdev, u16 report,\n\t\t\t\t    u16 score)\n{\n\tstruct rtw89_env_monitor_info *env = &rtwdev->env_monitor;\n\tu32 numer = 0;\n\tu16 ret = 0;\n\n\tnumer = report * score + (env->ccx_period >> 1);\n\tif (env->ccx_period)\n\t\tret = numer / env->ccx_period;\n\n\treturn ret >= score ? score - 1 : ret;\n}\n\nstatic void rtw89_phy_ccx_ms_to_period_unit(struct rtw89_dev *rtwdev,\n\t\t\t\t\t    u16 time_ms, u32 *period,\n\t\t\t\t\t    u32 *unit_idx)\n{\n\tu32 idx;\n\tu8 quotient;\n\n\tif (time_ms >= CCX_MAX_PERIOD)\n\t\ttime_ms = CCX_MAX_PERIOD;\n\n\tquotient = CCX_MAX_PERIOD_UNIT * time_ms / CCX_MAX_PERIOD;\n\n\tif (quotient < 4)\n\t\tidx = RTW89_CCX_4_US;\n\telse if (quotient < 8)\n\t\tidx = RTW89_CCX_8_US;\n\telse if (quotient < 16)\n\t\tidx = RTW89_CCX_16_US;\n\telse\n\t\tidx = RTW89_CCX_32_US;\n\n\t*unit_idx = idx;\n\t*period = (time_ms * MS_TO_4US_RATIO) >> idx;\n\n\trtw89_debug(rtwdev, RTW89_DBG_PHY_TRACK,\n\t\t    \"[Trigger Time] period:%d, unit_idx:%d\\n\",\n\t\t    *period, *unit_idx);\n}\n\nstatic void rtw89_phy_ccx_racing_release(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_env_monitor_info *env = &rtwdev->env_monitor;\n\n\trtw89_debug(rtwdev, RTW89_DBG_PHY_TRACK,\n\t\t    \"lv:(%d)->(0)\\n\", env->ccx_rac_lv);\n\n\tenv->ccx_ongoing = false;\n\tenv->ccx_rac_lv = RTW89_RAC_RELEASE;\n\tenv->ifs_clm_app = RTW89_IFS_CLM_BACKGROUND;\n}\n\nstatic bool rtw89_phy_ifs_clm_th_update_check(struct rtw89_dev *rtwdev,\n\t\t\t\t\t      struct rtw89_ccx_para_info *para)\n{\n\tstruct rtw89_env_monitor_info *env = &rtwdev->env_monitor;\n\tbool is_update = env->ifs_clm_app != para->ifs_clm_app;\n\tu8 i = 0;\n\tu16 *ifs_th_l = env->ifs_clm_th_l;\n\tu16 *ifs_th_h = env->ifs_clm_th_h;\n\tu32 ifs_th0_us = 0, ifs_th_times = 0;\n\tu32 ifs_th_h_us[RTW89_IFS_CLM_NUM] = {0};\n\n\tif (!is_update)\n\t\tgoto ifs_update_finished;\n\n\tswitch (para->ifs_clm_app) {\n\tcase RTW89_IFS_CLM_INIT:\n\tcase RTW89_IFS_CLM_BACKGROUND:\n\tcase RTW89_IFS_CLM_ACS:\n\tcase RTW89_IFS_CLM_DBG:\n\tcase RTW89_IFS_CLM_DIG:\n\tcase RTW89_IFS_CLM_TDMA_DIG:\n\t\tifs_th0_us = IFS_CLM_TH0_UPPER;\n\t\tifs_th_times = IFS_CLM_TH_MUL;\n\t\tbreak;\n\tcase RTW89_IFS_CLM_DBG_MANUAL:\n\t\tifs_th0_us = para->ifs_clm_manual_th0;\n\t\tifs_th_times = para->ifs_clm_manual_th_times;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tifs_th_l[IFS_CLM_TH_START_IDX] = 0;\n\tifs_th_h_us[IFS_CLM_TH_START_IDX] = ifs_th0_us;\n\tifs_th_h[IFS_CLM_TH_START_IDX] = rtw89_phy_ccx_us_to_idx(rtwdev,\n\t\t\t\t\t\t\t\t ifs_th0_us);\n\tfor (i = 1; i < RTW89_IFS_CLM_NUM; i++) {\n\t\tifs_th_l[i] = ifs_th_h[i - 1] + 1;\n\t\tifs_th_h_us[i] = ifs_th_h_us[i - 1] * ifs_th_times;\n\t\tifs_th_h[i] = rtw89_phy_ccx_us_to_idx(rtwdev, ifs_th_h_us[i]);\n\t}\n\nifs_update_finished:\n\tif (!is_update)\n\t\trtw89_debug(rtwdev, RTW89_DBG_PHY_TRACK,\n\t\t\t    \"No need to update IFS_TH\\n\");\n\n\treturn is_update;\n}\n\nstatic void rtw89_phy_ifs_clm_set_th_reg(struct rtw89_dev *rtwdev)\n{\n\tconst struct rtw89_phy_gen_def *phy = rtwdev->chip->phy_def;\n\tstruct rtw89_env_monitor_info *env = &rtwdev->env_monitor;\n\tconst struct rtw89_ccx_regs *ccx = phy->ccx;\n\tu8 i = 0;\n\n\trtw89_phy_set_phy_regs(rtwdev, ccx->ifs_t1_addr, ccx->ifs_t1_th_l_mask,\n\t\t\t       env->ifs_clm_th_l[0]);\n\trtw89_phy_set_phy_regs(rtwdev, ccx->ifs_t2_addr, ccx->ifs_t2_th_l_mask,\n\t\t\t       env->ifs_clm_th_l[1]);\n\trtw89_phy_set_phy_regs(rtwdev, ccx->ifs_t3_addr, ccx->ifs_t3_th_l_mask,\n\t\t\t       env->ifs_clm_th_l[2]);\n\trtw89_phy_set_phy_regs(rtwdev, ccx->ifs_t4_addr, ccx->ifs_t4_th_l_mask,\n\t\t\t       env->ifs_clm_th_l[3]);\n\n\trtw89_phy_set_phy_regs(rtwdev, ccx->ifs_t1_addr, ccx->ifs_t1_th_h_mask,\n\t\t\t       env->ifs_clm_th_h[0]);\n\trtw89_phy_set_phy_regs(rtwdev, ccx->ifs_t2_addr, ccx->ifs_t2_th_h_mask,\n\t\t\t       env->ifs_clm_th_h[1]);\n\trtw89_phy_set_phy_regs(rtwdev, ccx->ifs_t3_addr, ccx->ifs_t3_th_h_mask,\n\t\t\t       env->ifs_clm_th_h[2]);\n\trtw89_phy_set_phy_regs(rtwdev, ccx->ifs_t4_addr, ccx->ifs_t4_th_h_mask,\n\t\t\t       env->ifs_clm_th_h[3]);\n\n\tfor (i = 0; i < RTW89_IFS_CLM_NUM; i++)\n\t\trtw89_debug(rtwdev, RTW89_DBG_PHY_TRACK,\n\t\t\t    \"Update IFS_T%d_th{low, high} : {%d, %d}\\n\",\n\t\t\t    i + 1, env->ifs_clm_th_l[i], env->ifs_clm_th_h[i]);\n}\n\nstatic void rtw89_phy_ifs_clm_setting_init(struct rtw89_dev *rtwdev)\n{\n\tconst struct rtw89_phy_gen_def *phy = rtwdev->chip->phy_def;\n\tstruct rtw89_env_monitor_info *env = &rtwdev->env_monitor;\n\tconst struct rtw89_ccx_regs *ccx = phy->ccx;\n\tstruct rtw89_ccx_para_info para = {0};\n\n\tenv->ifs_clm_app = RTW89_IFS_CLM_BACKGROUND;\n\tenv->ifs_clm_mntr_time = 0;\n\n\tpara.ifs_clm_app = RTW89_IFS_CLM_INIT;\n\tif (rtw89_phy_ifs_clm_th_update_check(rtwdev, &para))\n\t\trtw89_phy_ifs_clm_set_th_reg(rtwdev);\n\n\trtw89_phy_set_phy_regs(rtwdev, ccx->ifs_cnt_addr, ccx->ifs_collect_en_mask, true);\n\trtw89_phy_set_phy_regs(rtwdev, ccx->ifs_t1_addr, ccx->ifs_t1_en_mask, true);\n\trtw89_phy_set_phy_regs(rtwdev, ccx->ifs_t2_addr, ccx->ifs_t2_en_mask, true);\n\trtw89_phy_set_phy_regs(rtwdev, ccx->ifs_t3_addr, ccx->ifs_t3_en_mask, true);\n\trtw89_phy_set_phy_regs(rtwdev, ccx->ifs_t4_addr, ccx->ifs_t4_en_mask, true);\n}\n\nstatic int rtw89_phy_ccx_racing_ctrl(struct rtw89_dev *rtwdev,\n\t\t\t\t     enum rtw89_env_racing_lv level)\n{\n\tstruct rtw89_env_monitor_info *env = &rtwdev->env_monitor;\n\tint ret = 0;\n\n\tif (level >= RTW89_RAC_MAX_NUM) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_PHY_TRACK,\n\t\t\t    \"[WARNING] Wrong LV=%d\\n\", level);\n\t\treturn -EINVAL;\n\t}\n\n\trtw89_debug(rtwdev, RTW89_DBG_PHY_TRACK,\n\t\t    \"ccx_ongoing=%d, level:(%d)->(%d)\\n\", env->ccx_ongoing,\n\t\t    env->ccx_rac_lv, level);\n\n\tif (env->ccx_ongoing) {\n\t\tif (level <= env->ccx_rac_lv)\n\t\t\tret = -EINVAL;\n\t\telse\n\t\t\tenv->ccx_ongoing = false;\n\t}\n\n\tif (ret == 0)\n\t\tenv->ccx_rac_lv = level;\n\n\trtw89_debug(rtwdev, RTW89_DBG_PHY_TRACK, \"ccx racing success=%d\\n\",\n\t\t    !ret);\n\n\treturn ret;\n}\n\nstatic void rtw89_phy_ccx_trigger(struct rtw89_dev *rtwdev)\n{\n\tconst struct rtw89_phy_gen_def *phy = rtwdev->chip->phy_def;\n\tstruct rtw89_env_monitor_info *env = &rtwdev->env_monitor;\n\tconst struct rtw89_ccx_regs *ccx = phy->ccx;\n\n\trtw89_phy_set_phy_regs(rtwdev, ccx->ifs_cnt_addr, ccx->ifs_clm_cnt_clear_mask, 0);\n\trtw89_phy_set_phy_regs(rtwdev, ccx->setting_addr, ccx->measurement_trig_mask, 0);\n\trtw89_phy_set_phy_regs(rtwdev, ccx->ifs_cnt_addr, ccx->ifs_clm_cnt_clear_mask, 1);\n\trtw89_phy_set_phy_regs(rtwdev, ccx->setting_addr, ccx->measurement_trig_mask, 1);\n\n\tenv->ccx_ongoing = true;\n}\n\nstatic void rtw89_phy_ifs_clm_get_utility(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_env_monitor_info *env = &rtwdev->env_monitor;\n\tu8 i = 0;\n\tu32 res = 0;\n\n\tenv->ifs_clm_tx_ratio =\n\t\trtw89_phy_ccx_get_report(rtwdev, env->ifs_clm_tx, PERCENT);\n\tenv->ifs_clm_edcca_excl_cca_ratio =\n\t\trtw89_phy_ccx_get_report(rtwdev, env->ifs_clm_edcca_excl_cca,\n\t\t\t\t\t PERCENT);\n\tenv->ifs_clm_cck_fa_ratio =\n\t\trtw89_phy_ccx_get_report(rtwdev, env->ifs_clm_cckfa, PERCENT);\n\tenv->ifs_clm_ofdm_fa_ratio =\n\t\trtw89_phy_ccx_get_report(rtwdev, env->ifs_clm_ofdmfa, PERCENT);\n\tenv->ifs_clm_cck_cca_excl_fa_ratio =\n\t\trtw89_phy_ccx_get_report(rtwdev, env->ifs_clm_cckcca_excl_fa,\n\t\t\t\t\t PERCENT);\n\tenv->ifs_clm_ofdm_cca_excl_fa_ratio =\n\t\trtw89_phy_ccx_get_report(rtwdev, env->ifs_clm_ofdmcca_excl_fa,\n\t\t\t\t\t PERCENT);\n\tenv->ifs_clm_cck_fa_permil =\n\t\trtw89_phy_ccx_get_report(rtwdev, env->ifs_clm_cckfa, PERMIL);\n\tenv->ifs_clm_ofdm_fa_permil =\n\t\trtw89_phy_ccx_get_report(rtwdev, env->ifs_clm_ofdmfa, PERMIL);\n\n\tfor (i = 0; i < RTW89_IFS_CLM_NUM; i++) {\n\t\tif (env->ifs_clm_his[i] > ENV_MNTR_IFSCLM_HIS_MAX) {\n\t\t\tenv->ifs_clm_ifs_avg[i] = ENV_MNTR_FAIL_DWORD;\n\t\t} else {\n\t\t\tenv->ifs_clm_ifs_avg[i] =\n\t\t\t\trtw89_phy_ccx_idx_to_us(rtwdev,\n\t\t\t\t\t\t\tenv->ifs_clm_avg[i]);\n\t\t}\n\n\t\tres = rtw89_phy_ccx_idx_to_us(rtwdev, env->ifs_clm_cca[i]);\n\t\tres += env->ifs_clm_his[i] >> 1;\n\t\tif (env->ifs_clm_his[i])\n\t\t\tres /= env->ifs_clm_his[i];\n\t\telse\n\t\t\tres = 0;\n\t\tenv->ifs_clm_cca_avg[i] = res;\n\t}\n\n\trtw89_debug(rtwdev, RTW89_DBG_PHY_TRACK,\n\t\t    \"IFS-CLM ratio {Tx, EDCCA_exclu_cca} = {%d, %d}\\n\",\n\t\t    env->ifs_clm_tx_ratio, env->ifs_clm_edcca_excl_cca_ratio);\n\trtw89_debug(rtwdev, RTW89_DBG_PHY_TRACK,\n\t\t    \"IFS-CLM FA ratio {CCK, OFDM} = {%d, %d}\\n\",\n\t\t    env->ifs_clm_cck_fa_ratio, env->ifs_clm_ofdm_fa_ratio);\n\trtw89_debug(rtwdev, RTW89_DBG_PHY_TRACK,\n\t\t    \"IFS-CLM FA permil {CCK, OFDM} = {%d, %d}\\n\",\n\t\t    env->ifs_clm_cck_fa_permil, env->ifs_clm_ofdm_fa_permil);\n\trtw89_debug(rtwdev, RTW89_DBG_PHY_TRACK,\n\t\t    \"IFS-CLM CCA_exclu_FA ratio {CCK, OFDM} = {%d, %d}\\n\",\n\t\t    env->ifs_clm_cck_cca_excl_fa_ratio,\n\t\t    env->ifs_clm_ofdm_cca_excl_fa_ratio);\n\trtw89_debug(rtwdev, RTW89_DBG_PHY_TRACK,\n\t\t    \"Time:[his, ifs_avg(us), cca_avg(us)]\\n\");\n\tfor (i = 0; i < RTW89_IFS_CLM_NUM; i++)\n\t\trtw89_debug(rtwdev, RTW89_DBG_PHY_TRACK, \"T%d:[%d, %d, %d]\\n\",\n\t\t\t    i + 1, env->ifs_clm_his[i], env->ifs_clm_ifs_avg[i],\n\t\t\t    env->ifs_clm_cca_avg[i]);\n}\n\nstatic bool rtw89_phy_ifs_clm_get_result(struct rtw89_dev *rtwdev)\n{\n\tconst struct rtw89_phy_gen_def *phy = rtwdev->chip->phy_def;\n\tstruct rtw89_env_monitor_info *env = &rtwdev->env_monitor;\n\tconst struct rtw89_ccx_regs *ccx = phy->ccx;\n\tu8 i = 0;\n\n\tif (rtw89_phy_read32_mask(rtwdev, ccx->ifs_total_addr,\n\t\t\t\t  ccx->ifs_cnt_done_mask) == 0) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_PHY_TRACK,\n\t\t\t    \"Get IFS_CLM report Fail\\n\");\n\t\treturn false;\n\t}\n\n\tenv->ifs_clm_tx =\n\t\trtw89_phy_read32_mask(rtwdev, ccx->ifs_clm_tx_cnt_addr,\n\t\t\t\t      ccx->ifs_clm_tx_cnt_msk);\n\tenv->ifs_clm_edcca_excl_cca =\n\t\trtw89_phy_read32_mask(rtwdev, ccx->ifs_clm_tx_cnt_addr,\n\t\t\t\t      ccx->ifs_clm_edcca_excl_cca_fa_mask);\n\tenv->ifs_clm_cckcca_excl_fa =\n\t\trtw89_phy_read32_mask(rtwdev, ccx->ifs_clm_cca_addr,\n\t\t\t\t      ccx->ifs_clm_cckcca_excl_fa_mask);\n\tenv->ifs_clm_ofdmcca_excl_fa =\n\t\trtw89_phy_read32_mask(rtwdev, ccx->ifs_clm_cca_addr,\n\t\t\t\t      ccx->ifs_clm_ofdmcca_excl_fa_mask);\n\tenv->ifs_clm_cckfa =\n\t\trtw89_phy_read32_mask(rtwdev, ccx->ifs_clm_fa_addr,\n\t\t\t\t      ccx->ifs_clm_cck_fa_mask);\n\tenv->ifs_clm_ofdmfa =\n\t\trtw89_phy_read32_mask(rtwdev, ccx->ifs_clm_fa_addr,\n\t\t\t\t      ccx->ifs_clm_ofdm_fa_mask);\n\n\tenv->ifs_clm_his[0] =\n\t\trtw89_phy_read32_mask(rtwdev, ccx->ifs_his_addr,\n\t\t\t\t      ccx->ifs_t1_his_mask);\n\tenv->ifs_clm_his[1] =\n\t\trtw89_phy_read32_mask(rtwdev, ccx->ifs_his_addr,\n\t\t\t\t      ccx->ifs_t2_his_mask);\n\tenv->ifs_clm_his[2] =\n\t\trtw89_phy_read32_mask(rtwdev, ccx->ifs_his_addr,\n\t\t\t\t      ccx->ifs_t3_his_mask);\n\tenv->ifs_clm_his[3] =\n\t\trtw89_phy_read32_mask(rtwdev, ccx->ifs_his_addr,\n\t\t\t\t      ccx->ifs_t4_his_mask);\n\n\tenv->ifs_clm_avg[0] =\n\t\trtw89_phy_read32_mask(rtwdev, ccx->ifs_avg_l_addr,\n\t\t\t\t      ccx->ifs_t1_avg_mask);\n\tenv->ifs_clm_avg[1] =\n\t\trtw89_phy_read32_mask(rtwdev, ccx->ifs_avg_l_addr,\n\t\t\t\t      ccx->ifs_t2_avg_mask);\n\tenv->ifs_clm_avg[2] =\n\t\trtw89_phy_read32_mask(rtwdev, ccx->ifs_avg_h_addr,\n\t\t\t\t      ccx->ifs_t3_avg_mask);\n\tenv->ifs_clm_avg[3] =\n\t\trtw89_phy_read32_mask(rtwdev, ccx->ifs_avg_h_addr,\n\t\t\t\t      ccx->ifs_t4_avg_mask);\n\n\tenv->ifs_clm_cca[0] =\n\t\trtw89_phy_read32_mask(rtwdev, ccx->ifs_cca_l_addr,\n\t\t\t\t      ccx->ifs_t1_cca_mask);\n\tenv->ifs_clm_cca[1] =\n\t\trtw89_phy_read32_mask(rtwdev, ccx->ifs_cca_l_addr,\n\t\t\t\t      ccx->ifs_t2_cca_mask);\n\tenv->ifs_clm_cca[2] =\n\t\trtw89_phy_read32_mask(rtwdev, ccx->ifs_cca_h_addr,\n\t\t\t\t      ccx->ifs_t3_cca_mask);\n\tenv->ifs_clm_cca[3] =\n\t\trtw89_phy_read32_mask(rtwdev, ccx->ifs_cca_h_addr,\n\t\t\t\t      ccx->ifs_t4_cca_mask);\n\n\tenv->ifs_clm_total_ifs =\n\t\trtw89_phy_read32_mask(rtwdev, ccx->ifs_total_addr,\n\t\t\t\t      ccx->ifs_total_mask);\n\n\trtw89_debug(rtwdev, RTW89_DBG_PHY_TRACK, \"IFS-CLM total_ifs = %d\\n\",\n\t\t    env->ifs_clm_total_ifs);\n\trtw89_debug(rtwdev, RTW89_DBG_PHY_TRACK,\n\t\t    \"{Tx, EDCCA_exclu_cca} = {%d, %d}\\n\",\n\t\t    env->ifs_clm_tx, env->ifs_clm_edcca_excl_cca);\n\trtw89_debug(rtwdev, RTW89_DBG_PHY_TRACK,\n\t\t    \"IFS-CLM FA{CCK, OFDM} = {%d, %d}\\n\",\n\t\t    env->ifs_clm_cckfa, env->ifs_clm_ofdmfa);\n\trtw89_debug(rtwdev, RTW89_DBG_PHY_TRACK,\n\t\t    \"IFS-CLM CCA_exclu_FA{CCK, OFDM} = {%d, %d}\\n\",\n\t\t    env->ifs_clm_cckcca_excl_fa, env->ifs_clm_ofdmcca_excl_fa);\n\n\trtw89_debug(rtwdev, RTW89_DBG_PHY_TRACK, \"Time:[his, avg, cca]\\n\");\n\tfor (i = 0; i < RTW89_IFS_CLM_NUM; i++)\n\t\trtw89_debug(rtwdev, RTW89_DBG_PHY_TRACK,\n\t\t\t    \"T%d:[%d, %d, %d]\\n\", i + 1, env->ifs_clm_his[i],\n\t\t\t    env->ifs_clm_avg[i], env->ifs_clm_cca[i]);\n\n\trtw89_phy_ifs_clm_get_utility(rtwdev);\n\n\treturn true;\n}\n\nstatic int rtw89_phy_ifs_clm_set(struct rtw89_dev *rtwdev,\n\t\t\t\t struct rtw89_ccx_para_info *para)\n{\n\tconst struct rtw89_phy_gen_def *phy = rtwdev->chip->phy_def;\n\tstruct rtw89_env_monitor_info *env = &rtwdev->env_monitor;\n\tconst struct rtw89_ccx_regs *ccx = phy->ccx;\n\tu32 period = 0;\n\tu32 unit_idx = 0;\n\n\tif (para->mntr_time == 0) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_PHY_TRACK,\n\t\t\t    \"[WARN] MNTR_TIME is 0\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (rtw89_phy_ccx_racing_ctrl(rtwdev, para->rac_lv))\n\t\treturn -EINVAL;\n\n\tif (para->mntr_time != env->ifs_clm_mntr_time) {\n\t\trtw89_phy_ccx_ms_to_period_unit(rtwdev, para->mntr_time,\n\t\t\t\t\t\t&period, &unit_idx);\n\t\trtw89_phy_set_phy_regs(rtwdev, ccx->ifs_cnt_addr,\n\t\t\t\t       ccx->ifs_clm_period_mask, period);\n\t\trtw89_phy_set_phy_regs(rtwdev, ccx->ifs_cnt_addr,\n\t\t\t\t       ccx->ifs_clm_cnt_unit_mask,\n\t\t\t\t       unit_idx);\n\n\t\trtw89_debug(rtwdev, RTW89_DBG_PHY_TRACK,\n\t\t\t    \"Update IFS-CLM time ((%d)) -> ((%d))\\n\",\n\t\t\t    env->ifs_clm_mntr_time, para->mntr_time);\n\n\t\tenv->ifs_clm_mntr_time = para->mntr_time;\n\t\tenv->ccx_period = (u16)period;\n\t\tenv->ccx_unit_idx = (u8)unit_idx;\n\t}\n\n\tif (rtw89_phy_ifs_clm_th_update_check(rtwdev, para)) {\n\t\tenv->ifs_clm_app = para->ifs_clm_app;\n\t\trtw89_phy_ifs_clm_set_th_reg(rtwdev);\n\t}\n\n\treturn 0;\n}\n\nvoid rtw89_phy_env_monitor_track(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_env_monitor_info *env = &rtwdev->env_monitor;\n\tstruct rtw89_ccx_para_info para = {0};\n\tu8 chk_result = RTW89_PHY_ENV_MON_CCX_FAIL;\n\n\tenv->ccx_watchdog_result = RTW89_PHY_ENV_MON_CCX_FAIL;\n\tif (env->ccx_manual_ctrl) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_PHY_TRACK,\n\t\t\t    \"CCX in manual ctrl\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (rtw89_phy_ifs_clm_get_result(rtwdev))\n\t\tenv->ccx_watchdog_result |= RTW89_PHY_ENV_MON_IFS_CLM;\n\n\trtw89_phy_ccx_racing_release(rtwdev);\n\tpara.mntr_time = 1900;\n\tpara.rac_lv = RTW89_RAC_LV_1;\n\tpara.ifs_clm_app = RTW89_IFS_CLM_BACKGROUND;\n\n\tif (rtw89_phy_ifs_clm_set(rtwdev, &para) == 0)\n\t\tchk_result |= RTW89_PHY_ENV_MON_IFS_CLM;\n\tif (chk_result)\n\t\trtw89_phy_ccx_trigger(rtwdev);\n\n\trtw89_debug(rtwdev, RTW89_DBG_PHY_TRACK,\n\t\t    \"get_result=0x%x, chk_result:0x%x\\n\",\n\t\t    env->ccx_watchdog_result, chk_result);\n}\n\nstatic bool rtw89_physts_ie_page_valid(enum rtw89_phy_status_bitmap *ie_page)\n{\n\tif (*ie_page >= RTW89_PHYSTS_BITMAP_NUM ||\n\t    *ie_page == RTW89_RSVD_9)\n\t\treturn false;\n\telse if (*ie_page > RTW89_RSVD_9)\n\t\t*ie_page -= 1;\n\n\treturn true;\n}\n\nstatic u32 rtw89_phy_get_ie_bitmap_addr(enum rtw89_phy_status_bitmap ie_page)\n{\n\tstatic const u8 ie_page_shift = 2;\n\n\treturn R_PHY_STS_BITMAP_ADDR_START + (ie_page << ie_page_shift);\n}\n\nstatic u32 rtw89_physts_get_ie_bitmap(struct rtw89_dev *rtwdev,\n\t\t\t\t      enum rtw89_phy_status_bitmap ie_page)\n{\n\tu32 addr;\n\n\tif (!rtw89_physts_ie_page_valid(&ie_page))\n\t\treturn 0;\n\n\taddr = rtw89_phy_get_ie_bitmap_addr(ie_page);\n\n\treturn rtw89_phy_read32(rtwdev, addr);\n}\n\nstatic void rtw89_physts_set_ie_bitmap(struct rtw89_dev *rtwdev,\n\t\t\t\t       enum rtw89_phy_status_bitmap ie_page,\n\t\t\t\t       u32 val)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tu32 addr;\n\n\tif (!rtw89_physts_ie_page_valid(&ie_page))\n\t\treturn;\n\n\tif (chip->chip_id == RTL8852A)\n\t\tval &= B_PHY_STS_BITMAP_MSK_52A;\n\n\taddr = rtw89_phy_get_ie_bitmap_addr(ie_page);\n\trtw89_phy_write32(rtwdev, addr, val);\n}\n\nstatic void rtw89_physts_enable_ie_bitmap(struct rtw89_dev *rtwdev,\n\t\t\t\t\t  enum rtw89_phy_status_bitmap bitmap,\n\t\t\t\t\t  enum rtw89_phy_status_ie_type ie,\n\t\t\t\t\t  bool enable)\n{\n\tu32 val = rtw89_physts_get_ie_bitmap(rtwdev, bitmap);\n\n\tif (enable)\n\t\tval |= BIT(ie);\n\telse\n\t\tval &= ~BIT(ie);\n\n\trtw89_physts_set_ie_bitmap(rtwdev, bitmap, val);\n}\n\nstatic void rtw89_physts_enable_fail_report(struct rtw89_dev *rtwdev,\n\t\t\t\t\t    bool enable,\n\t\t\t\t\t    enum rtw89_phy_idx phy_idx)\n{\n\tconst struct rtw89_phy_gen_def *phy = rtwdev->chip->phy_def;\n\tconst struct rtw89_physts_regs *physts = phy->physts;\n\n\tif (enable) {\n\t\trtw89_phy_write32_clr(rtwdev, physts->setting_addr,\n\t\t\t\t      physts->dis_trigger_fail_mask);\n\t\trtw89_phy_write32_clr(rtwdev, physts->setting_addr,\n\t\t\t\t      physts->dis_trigger_brk_mask);\n\t} else {\n\t\trtw89_phy_write32_set(rtwdev, physts->setting_addr,\n\t\t\t\t      physts->dis_trigger_fail_mask);\n\t\trtw89_phy_write32_set(rtwdev, physts->setting_addr,\n\t\t\t\t      physts->dis_trigger_brk_mask);\n\t}\n}\n\nstatic void rtw89_physts_parsing_init(struct rtw89_dev *rtwdev)\n{\n\tu8 i;\n\n\trtw89_physts_enable_fail_report(rtwdev, false, RTW89_PHY_0);\n\n\tfor (i = 0; i < RTW89_PHYSTS_BITMAP_NUM; i++) {\n\t\tif (i >= RTW89_CCK_PKT)\n\t\t\trtw89_physts_enable_ie_bitmap(rtwdev, i,\n\t\t\t\t\t\t      RTW89_PHYSTS_IE09_FTR_0,\n\t\t\t\t\t\t      true);\n\t\tif ((i >= RTW89_CCK_BRK && i <= RTW89_VHT_MU) ||\n\t\t    (i >= RTW89_RSVD_9 && i <= RTW89_CCK_PKT))\n\t\t\tcontinue;\n\t\trtw89_physts_enable_ie_bitmap(rtwdev, i,\n\t\t\t\t\t      RTW89_PHYSTS_IE24_OFDM_TD_PATH_A,\n\t\t\t\t\t      true);\n\t}\n\trtw89_physts_enable_ie_bitmap(rtwdev, RTW89_VHT_PKT,\n\t\t\t\t      RTW89_PHYSTS_IE13_DL_MU_DEF, true);\n\trtw89_physts_enable_ie_bitmap(rtwdev, RTW89_HE_PKT,\n\t\t\t\t      RTW89_PHYSTS_IE13_DL_MU_DEF, true);\n\n\t \n\trtw89_physts_enable_ie_bitmap(rtwdev, RTW89_CCK_PKT,\n\t\t\t\t      RTW89_PHYSTS_IE01_CMN_OFDM, true);\n}\n\nstatic void rtw89_phy_dig_read_gain_table(struct rtw89_dev *rtwdev, int type)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tstruct rtw89_dig_info *dig = &rtwdev->dig;\n\tconst struct rtw89_phy_dig_gain_cfg *cfg;\n\tconst char *msg;\n\tu8 i;\n\ts8 gain_base;\n\ts8 *gain_arr;\n\tu32 tmp;\n\n\tswitch (type) {\n\tcase RTW89_DIG_GAIN_LNA_G:\n\t\tgain_arr = dig->lna_gain_g;\n\t\tgain_base = LNA0_GAIN;\n\t\tcfg = chip->dig_table->cfg_lna_g;\n\t\tmsg = \"lna_gain_g\";\n\t\tbreak;\n\tcase RTW89_DIG_GAIN_TIA_G:\n\t\tgain_arr = dig->tia_gain_g;\n\t\tgain_base = TIA0_GAIN_G;\n\t\tcfg = chip->dig_table->cfg_tia_g;\n\t\tmsg = \"tia_gain_g\";\n\t\tbreak;\n\tcase RTW89_DIG_GAIN_LNA_A:\n\t\tgain_arr = dig->lna_gain_a;\n\t\tgain_base = LNA0_GAIN;\n\t\tcfg = chip->dig_table->cfg_lna_a;\n\t\tmsg = \"lna_gain_a\";\n\t\tbreak;\n\tcase RTW89_DIG_GAIN_TIA_A:\n\t\tgain_arr = dig->tia_gain_a;\n\t\tgain_base = TIA0_GAIN_A;\n\t\tcfg = chip->dig_table->cfg_tia_a;\n\t\tmsg = \"tia_gain_a\";\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < cfg->size; i++) {\n\t\ttmp = rtw89_phy_read32_mask(rtwdev, cfg->table[i].addr,\n\t\t\t\t\t    cfg->table[i].mask);\n\t\ttmp >>= DIG_GAIN_SHIFT;\n\t\tgain_arr[i] = sign_extend32(tmp, U4_MAX_BIT) + gain_base;\n\t\tgain_base += DIG_GAIN;\n\n\t\trtw89_debug(rtwdev, RTW89_DBG_DIG, \"%s[%d]=%d\\n\",\n\t\t\t    msg, i, gain_arr[i]);\n\t}\n}\n\nstatic void rtw89_phy_dig_update_gain_para(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_dig_info *dig = &rtwdev->dig;\n\tu32 tmp;\n\tu8 i;\n\n\tif (!rtwdev->hal.support_igi)\n\t\treturn;\n\n\ttmp = rtw89_phy_read32_mask(rtwdev, R_PATH0_IB_PKPW,\n\t\t\t\t    B_PATH0_IB_PKPW_MSK);\n\tdig->ib_pkpwr = sign_extend32(tmp >> DIG_GAIN_SHIFT, U8_MAX_BIT);\n\tdig->ib_pbk = rtw89_phy_read32_mask(rtwdev, R_PATH0_IB_PBK,\n\t\t\t\t\t    B_PATH0_IB_PBK_MSK);\n\trtw89_debug(rtwdev, RTW89_DBG_DIG, \"ib_pkpwr=%d, ib_pbk=%d\\n\",\n\t\t    dig->ib_pkpwr, dig->ib_pbk);\n\n\tfor (i = RTW89_DIG_GAIN_LNA_G; i < RTW89_DIG_GAIN_MAX; i++)\n\t\trtw89_phy_dig_read_gain_table(rtwdev, i);\n}\n\nstatic const u8 rssi_nolink = 22;\nstatic const u8 igi_rssi_th[IGI_RSSI_TH_NUM] = {68, 84, 90, 98, 104};\nstatic const u16 fa_th_2g[FA_TH_NUM] = {22, 44, 66, 88};\nstatic const u16 fa_th_5g[FA_TH_NUM] = {4, 8, 12, 16};\nstatic const u16 fa_th_nolink[FA_TH_NUM] = {196, 352, 440, 528};\n\nstatic void rtw89_phy_dig_update_rssi_info(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_phy_ch_info *ch_info = &rtwdev->ch_info;\n\tstruct rtw89_dig_info *dig = &rtwdev->dig;\n\tbool is_linked = rtwdev->total_sta_assoc > 0;\n\n\tif (is_linked) {\n\t\tdig->igi_rssi = ch_info->rssi_min >> 1;\n\t} else {\n\t\trtw89_debug(rtwdev, RTW89_DBG_DIG, \"RSSI update : NO Link\\n\");\n\t\tdig->igi_rssi = rssi_nolink;\n\t}\n}\n\nstatic void rtw89_phy_dig_update_para(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_dig_info *dig = &rtwdev->dig;\n\tconst struct rtw89_chan *chan = rtw89_chan_get(rtwdev, RTW89_SUB_ENTITY_0);\n\tbool is_linked = rtwdev->total_sta_assoc > 0;\n\tconst u16 *fa_th_src = NULL;\n\n\tswitch (chan->band_type) {\n\tcase RTW89_BAND_2G:\n\t\tdig->lna_gain = dig->lna_gain_g;\n\t\tdig->tia_gain = dig->tia_gain_g;\n\t\tfa_th_src = is_linked ? fa_th_2g : fa_th_nolink;\n\t\tdig->force_gaincode_idx_en = false;\n\t\tdig->dyn_pd_th_en = true;\n\t\tbreak;\n\tcase RTW89_BAND_5G:\n\tdefault:\n\t\tdig->lna_gain = dig->lna_gain_a;\n\t\tdig->tia_gain = dig->tia_gain_a;\n\t\tfa_th_src = is_linked ? fa_th_5g : fa_th_nolink;\n\t\tdig->force_gaincode_idx_en = true;\n\t\tdig->dyn_pd_th_en = true;\n\t\tbreak;\n\t}\n\tmemcpy(dig->fa_th, fa_th_src, sizeof(dig->fa_th));\n\tmemcpy(dig->igi_rssi_th, igi_rssi_th, sizeof(dig->igi_rssi_th));\n}\n\nstatic const u8 pd_low_th_offset = 20, dynamic_igi_min = 0x20;\nstatic const u8 igi_max_performance_mode = 0x5a;\nstatic const u8 dynamic_pd_threshold_max;\n\nstatic void rtw89_phy_dig_para_reset(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_dig_info *dig = &rtwdev->dig;\n\n\tdig->cur_gaincode.lna_idx = LNA_IDX_MAX;\n\tdig->cur_gaincode.tia_idx = TIA_IDX_MAX;\n\tdig->cur_gaincode.rxb_idx = RXB_IDX_MAX;\n\tdig->force_gaincode.lna_idx = LNA_IDX_MAX;\n\tdig->force_gaincode.tia_idx = TIA_IDX_MAX;\n\tdig->force_gaincode.rxb_idx = RXB_IDX_MAX;\n\n\tdig->dyn_igi_max = igi_max_performance_mode;\n\tdig->dyn_igi_min = dynamic_igi_min;\n\tdig->dyn_pd_th_max = dynamic_pd_threshold_max;\n\tdig->pd_low_th_ofst = pd_low_th_offset;\n\tdig->is_linked_pre = false;\n}\n\nstatic void rtw89_phy_dig_init(struct rtw89_dev *rtwdev)\n{\n\trtw89_phy_dig_update_gain_para(rtwdev);\n\trtw89_phy_dig_reset(rtwdev);\n}\n\nstatic u8 rtw89_phy_dig_lna_idx_by_rssi(struct rtw89_dev *rtwdev, u8 rssi)\n{\n\tstruct rtw89_dig_info *dig = &rtwdev->dig;\n\tu8 lna_idx;\n\n\tif (rssi < dig->igi_rssi_th[0])\n\t\tlna_idx = RTW89_DIG_GAIN_LNA_IDX6;\n\telse if (rssi < dig->igi_rssi_th[1])\n\t\tlna_idx = RTW89_DIG_GAIN_LNA_IDX5;\n\telse if (rssi < dig->igi_rssi_th[2])\n\t\tlna_idx = RTW89_DIG_GAIN_LNA_IDX4;\n\telse if (rssi < dig->igi_rssi_th[3])\n\t\tlna_idx = RTW89_DIG_GAIN_LNA_IDX3;\n\telse if (rssi < dig->igi_rssi_th[4])\n\t\tlna_idx = RTW89_DIG_GAIN_LNA_IDX2;\n\telse\n\t\tlna_idx = RTW89_DIG_GAIN_LNA_IDX1;\n\n\treturn lna_idx;\n}\n\nstatic u8 rtw89_phy_dig_tia_idx_by_rssi(struct rtw89_dev *rtwdev, u8 rssi)\n{\n\tstruct rtw89_dig_info *dig = &rtwdev->dig;\n\tu8 tia_idx;\n\n\tif (rssi < dig->igi_rssi_th[0])\n\t\ttia_idx = RTW89_DIG_GAIN_TIA_IDX1;\n\telse\n\t\ttia_idx = RTW89_DIG_GAIN_TIA_IDX0;\n\n\treturn tia_idx;\n}\n\n#define IB_PBK_BASE 110\n#define WB_RSSI_BASE 10\nstatic u8 rtw89_phy_dig_rxb_idx_by_rssi(struct rtw89_dev *rtwdev, u8 rssi,\n\t\t\t\t\tstruct rtw89_agc_gaincode_set *set)\n{\n\tstruct rtw89_dig_info *dig = &rtwdev->dig;\n\ts8 lna_gain = dig->lna_gain[set->lna_idx];\n\ts8 tia_gain = dig->tia_gain[set->tia_idx];\n\ts32 wb_rssi = rssi + lna_gain + tia_gain;\n\ts32 rxb_idx_tmp = IB_PBK_BASE + WB_RSSI_BASE;\n\tu8 rxb_idx;\n\n\trxb_idx_tmp += dig->ib_pkpwr - dig->ib_pbk - wb_rssi;\n\trxb_idx = clamp_t(s32, rxb_idx_tmp, RXB_IDX_MIN, RXB_IDX_MAX);\n\n\trtw89_debug(rtwdev, RTW89_DBG_DIG, \"wb_rssi=%03d, rxb_idx_tmp=%03d\\n\",\n\t\t    wb_rssi, rxb_idx_tmp);\n\n\treturn rxb_idx;\n}\n\nstatic void rtw89_phy_dig_gaincode_by_rssi(struct rtw89_dev *rtwdev, u8 rssi,\n\t\t\t\t\t   struct rtw89_agc_gaincode_set *set)\n{\n\tset->lna_idx = rtw89_phy_dig_lna_idx_by_rssi(rtwdev, rssi);\n\tset->tia_idx = rtw89_phy_dig_tia_idx_by_rssi(rtwdev, rssi);\n\tset->rxb_idx = rtw89_phy_dig_rxb_idx_by_rssi(rtwdev, rssi, set);\n\n\trtw89_debug(rtwdev, RTW89_DBG_DIG,\n\t\t    \"final_rssi=%03d, (lna,tia,rab)=(%d,%d,%02d)\\n\",\n\t\t    rssi, set->lna_idx, set->tia_idx, set->rxb_idx);\n}\n\n#define IGI_OFFSET_MAX 25\n#define IGI_OFFSET_MUL 2\nstatic void rtw89_phy_dig_igi_offset_by_env(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_dig_info *dig = &rtwdev->dig;\n\tstruct rtw89_env_monitor_info *env = &rtwdev->env_monitor;\n\tenum rtw89_dig_noisy_level noisy_lv;\n\tu8 igi_offset = dig->fa_rssi_ofst;\n\tu16 fa_ratio = 0;\n\n\tfa_ratio = env->ifs_clm_cck_fa_permil + env->ifs_clm_ofdm_fa_permil;\n\n\tif (fa_ratio < dig->fa_th[0])\n\t\tnoisy_lv = RTW89_DIG_NOISY_LEVEL0;\n\telse if (fa_ratio < dig->fa_th[1])\n\t\tnoisy_lv = RTW89_DIG_NOISY_LEVEL1;\n\telse if (fa_ratio < dig->fa_th[2])\n\t\tnoisy_lv = RTW89_DIG_NOISY_LEVEL2;\n\telse if (fa_ratio < dig->fa_th[3])\n\t\tnoisy_lv = RTW89_DIG_NOISY_LEVEL3;\n\telse\n\t\tnoisy_lv = RTW89_DIG_NOISY_LEVEL_MAX;\n\n\tif (noisy_lv == RTW89_DIG_NOISY_LEVEL0 && igi_offset < 2)\n\t\tigi_offset = 0;\n\telse\n\t\tigi_offset += noisy_lv * IGI_OFFSET_MUL;\n\n\tigi_offset = min_t(u8, igi_offset, IGI_OFFSET_MAX);\n\tdig->fa_rssi_ofst = igi_offset;\n\n\trtw89_debug(rtwdev, RTW89_DBG_DIG,\n\t\t    \"fa_th: [+6 (%d) +4 (%d) +2 (%d) 0 (%d) -2 ]\\n\",\n\t\t    dig->fa_th[3], dig->fa_th[2], dig->fa_th[1], dig->fa_th[0]);\n\n\trtw89_debug(rtwdev, RTW89_DBG_DIG,\n\t\t    \"fa(CCK,OFDM,ALL)=(%d,%d,%d)%%, noisy_lv=%d, ofst=%d\\n\",\n\t\t    env->ifs_clm_cck_fa_permil, env->ifs_clm_ofdm_fa_permil,\n\t\t    env->ifs_clm_cck_fa_permil + env->ifs_clm_ofdm_fa_permil,\n\t\t    noisy_lv, igi_offset);\n}\n\nstatic void rtw89_phy_dig_set_lna_idx(struct rtw89_dev *rtwdev, u8 lna_idx)\n{\n\tconst struct rtw89_dig_regs *dig_regs = rtwdev->chip->dig_regs;\n\n\trtw89_phy_write32_mask(rtwdev, dig_regs->p0_lna_init.addr,\n\t\t\t       dig_regs->p0_lna_init.mask, lna_idx);\n\trtw89_phy_write32_mask(rtwdev, dig_regs->p1_lna_init.addr,\n\t\t\t       dig_regs->p1_lna_init.mask, lna_idx);\n}\n\nstatic void rtw89_phy_dig_set_tia_idx(struct rtw89_dev *rtwdev, u8 tia_idx)\n{\n\tconst struct rtw89_dig_regs *dig_regs = rtwdev->chip->dig_regs;\n\n\trtw89_phy_write32_mask(rtwdev, dig_regs->p0_tia_init.addr,\n\t\t\t       dig_regs->p0_tia_init.mask, tia_idx);\n\trtw89_phy_write32_mask(rtwdev, dig_regs->p1_tia_init.addr,\n\t\t\t       dig_regs->p1_tia_init.mask, tia_idx);\n}\n\nstatic void rtw89_phy_dig_set_rxb_idx(struct rtw89_dev *rtwdev, u8 rxb_idx)\n{\n\tconst struct rtw89_dig_regs *dig_regs = rtwdev->chip->dig_regs;\n\n\trtw89_phy_write32_mask(rtwdev, dig_regs->p0_rxb_init.addr,\n\t\t\t       dig_regs->p0_rxb_init.mask, rxb_idx);\n\trtw89_phy_write32_mask(rtwdev, dig_regs->p1_rxb_init.addr,\n\t\t\t       dig_regs->p1_rxb_init.mask, rxb_idx);\n}\n\nstatic void rtw89_phy_dig_set_igi_cr(struct rtw89_dev *rtwdev,\n\t\t\t\t     const struct rtw89_agc_gaincode_set set)\n{\n\trtw89_phy_dig_set_lna_idx(rtwdev, set.lna_idx);\n\trtw89_phy_dig_set_tia_idx(rtwdev, set.tia_idx);\n\trtw89_phy_dig_set_rxb_idx(rtwdev, set.rxb_idx);\n\n\trtw89_debug(rtwdev, RTW89_DBG_DIG, \"Set (lna,tia,rxb)=((%d,%d,%02d))\\n\",\n\t\t    set.lna_idx, set.tia_idx, set.rxb_idx);\n}\n\nstatic void rtw89_phy_dig_sdagc_follow_pagc_config(struct rtw89_dev *rtwdev,\n\t\t\t\t\t\t   bool enable)\n{\n\tconst struct rtw89_dig_regs *dig_regs = rtwdev->chip->dig_regs;\n\n\trtw89_phy_write32_mask(rtwdev, dig_regs->p0_p20_pagcugc_en.addr,\n\t\t\t       dig_regs->p0_p20_pagcugc_en.mask, enable);\n\trtw89_phy_write32_mask(rtwdev, dig_regs->p0_s20_pagcugc_en.addr,\n\t\t\t       dig_regs->p0_s20_pagcugc_en.mask, enable);\n\trtw89_phy_write32_mask(rtwdev, dig_regs->p1_p20_pagcugc_en.addr,\n\t\t\t       dig_regs->p1_p20_pagcugc_en.mask, enable);\n\trtw89_phy_write32_mask(rtwdev, dig_regs->p1_s20_pagcugc_en.addr,\n\t\t\t       dig_regs->p1_s20_pagcugc_en.mask, enable);\n\n\trtw89_debug(rtwdev, RTW89_DBG_DIG, \"sdagc_follow_pagc=%d\\n\", enable);\n}\n\nstatic void rtw89_phy_dig_config_igi(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_dig_info *dig = &rtwdev->dig;\n\n\tif (!rtwdev->hal.support_igi)\n\t\treturn;\n\n\tif (dig->force_gaincode_idx_en) {\n\t\trtw89_phy_dig_set_igi_cr(rtwdev, dig->force_gaincode);\n\t\trtw89_debug(rtwdev, RTW89_DBG_DIG,\n\t\t\t    \"Force gaincode index enabled.\\n\");\n\t} else {\n\t\trtw89_phy_dig_gaincode_by_rssi(rtwdev, dig->igi_fa_rssi,\n\t\t\t\t\t       &dig->cur_gaincode);\n\t\trtw89_phy_dig_set_igi_cr(rtwdev, dig->cur_gaincode);\n\t}\n}\n\nstatic void rtw89_phy_dig_dyn_pd_th(struct rtw89_dev *rtwdev, u8 rssi,\n\t\t\t\t    bool enable)\n{\n\tconst struct rtw89_chan *chan = rtw89_chan_get(rtwdev, RTW89_SUB_ENTITY_0);\n\tconst struct rtw89_dig_regs *dig_regs = rtwdev->chip->dig_regs;\n\tenum rtw89_bandwidth cbw = chan->band_width;\n\tstruct rtw89_dig_info *dig = &rtwdev->dig;\n\tu8 final_rssi = 0, under_region = dig->pd_low_th_ofst;\n\tu8 ofdm_cca_th;\n\ts8 cck_cca_th;\n\tu32 pd_val = 0;\n\n\tunder_region += PD_TH_SB_FLTR_CMP_VAL;\n\n\tswitch (cbw) {\n\tcase RTW89_CHANNEL_WIDTH_40:\n\t\tunder_region += PD_TH_BW40_CMP_VAL;\n\t\tbreak;\n\tcase RTW89_CHANNEL_WIDTH_80:\n\t\tunder_region += PD_TH_BW80_CMP_VAL;\n\t\tbreak;\n\tcase RTW89_CHANNEL_WIDTH_160:\n\t\tunder_region += PD_TH_BW160_CMP_VAL;\n\t\tbreak;\n\tcase RTW89_CHANNEL_WIDTH_20:\n\t\tfallthrough;\n\tdefault:\n\t\tunder_region += PD_TH_BW20_CMP_VAL;\n\t\tbreak;\n\t}\n\n\tdig->dyn_pd_th_max = dig->igi_rssi;\n\n\tfinal_rssi = min_t(u8, rssi, dig->igi_rssi);\n\tofdm_cca_th = clamp_t(u8, final_rssi, PD_TH_MIN_RSSI + under_region,\n\t\t\t      PD_TH_MAX_RSSI + under_region);\n\n\tif (enable) {\n\t\tpd_val = (ofdm_cca_th - under_region - PD_TH_MIN_RSSI) >> 1;\n\t\trtw89_debug(rtwdev, RTW89_DBG_DIG,\n\t\t\t    \"igi=%d, ofdm_ccaTH=%d, backoff=%d, PD_low=%d\\n\",\n\t\t\t    final_rssi, ofdm_cca_th, under_region, pd_val);\n\t} else {\n\t\trtw89_debug(rtwdev, RTW89_DBG_DIG,\n\t\t\t    \"Dynamic PD th disabled, Set PD_low_bd=0\\n\");\n\t}\n\n\trtw89_phy_write32_mask(rtwdev, dig_regs->seg0_pd_reg,\n\t\t\t       dig_regs->pd_lower_bound_mask, pd_val);\n\trtw89_phy_write32_mask(rtwdev, dig_regs->seg0_pd_reg,\n\t\t\t       dig_regs->pd_spatial_reuse_en, enable);\n\n\tif (!rtwdev->hal.support_cckpd)\n\t\treturn;\n\n\tcck_cca_th = max_t(s8, final_rssi - under_region, CCKPD_TH_MIN_RSSI);\n\tpd_val = (u32)(cck_cca_th - IGI_RSSI_MAX);\n\n\trtw89_debug(rtwdev, RTW89_DBG_DIG,\n\t\t    \"igi=%d, cck_ccaTH=%d, backoff=%d, cck_PD_low=((%d))dB\\n\",\n\t\t    final_rssi, cck_cca_th, under_region, pd_val);\n\n\trtw89_phy_write32_mask(rtwdev, dig_regs->bmode_pd_reg,\n\t\t\t       dig_regs->bmode_cca_rssi_limit_en, enable);\n\trtw89_phy_write32_mask(rtwdev, dig_regs->bmode_pd_lower_bound_reg,\n\t\t\t       dig_regs->bmode_rssi_nocca_low_th_mask, pd_val);\n}\n\nvoid rtw89_phy_dig_reset(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_dig_info *dig = &rtwdev->dig;\n\n\tdig->bypass_dig = false;\n\trtw89_phy_dig_para_reset(rtwdev);\n\trtw89_phy_dig_set_igi_cr(rtwdev, dig->force_gaincode);\n\trtw89_phy_dig_dyn_pd_th(rtwdev, rssi_nolink, false);\n\trtw89_phy_dig_sdagc_follow_pagc_config(rtwdev, false);\n\trtw89_phy_dig_update_para(rtwdev);\n}\n\n#define IGI_RSSI_MIN 10\nvoid rtw89_phy_dig(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_dig_info *dig = &rtwdev->dig;\n\tbool is_linked = rtwdev->total_sta_assoc > 0;\n\n\tif (unlikely(dig->bypass_dig)) {\n\t\tdig->bypass_dig = false;\n\t\treturn;\n\t}\n\n\tif (!dig->is_linked_pre && is_linked) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_DIG, \"First connected\\n\");\n\t\trtw89_phy_dig_update_para(rtwdev);\n\t} else if (dig->is_linked_pre && !is_linked) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_DIG, \"First disconnected\\n\");\n\t\trtw89_phy_dig_update_para(rtwdev);\n\t}\n\tdig->is_linked_pre = is_linked;\n\n\trtw89_phy_dig_igi_offset_by_env(rtwdev);\n\trtw89_phy_dig_update_rssi_info(rtwdev);\n\n\tdig->dyn_igi_min = (dig->igi_rssi > IGI_RSSI_MIN) ?\n\t\t\t    dig->igi_rssi - IGI_RSSI_MIN : 0;\n\tdig->dyn_igi_max = dig->dyn_igi_min + IGI_OFFSET_MAX;\n\tdig->igi_fa_rssi = dig->dyn_igi_min + dig->fa_rssi_ofst;\n\n\tdig->igi_fa_rssi = clamp(dig->igi_fa_rssi, dig->dyn_igi_min,\n\t\t\t\t dig->dyn_igi_max);\n\n\trtw89_debug(rtwdev, RTW89_DBG_DIG,\n\t\t    \"rssi=%03d, dyn(max,min)=(%d,%d), final_rssi=%d\\n\",\n\t\t    dig->igi_rssi, dig->dyn_igi_max, dig->dyn_igi_min,\n\t\t    dig->igi_fa_rssi);\n\n\trtw89_phy_dig_config_igi(rtwdev);\n\n\trtw89_phy_dig_dyn_pd_th(rtwdev, dig->igi_fa_rssi, dig->dyn_pd_th_en);\n\n\tif (dig->dyn_pd_th_en && dig->igi_fa_rssi > dig->dyn_pd_th_max)\n\t\trtw89_phy_dig_sdagc_follow_pagc_config(rtwdev, true);\n\telse\n\t\trtw89_phy_dig_sdagc_follow_pagc_config(rtwdev, false);\n}\n\nstatic void rtw89_phy_tx_path_div_sta_iter(void *data, struct ieee80211_sta *sta)\n{\n\tstruct rtw89_sta *rtwsta = (struct rtw89_sta *)sta->drv_priv;\n\tstruct rtw89_dev *rtwdev = rtwsta->rtwdev;\n\tstruct rtw89_vif *rtwvif = rtwsta->rtwvif;\n\tstruct rtw89_hal *hal = &rtwdev->hal;\n\tbool *done = data;\n\tu8 rssi_a, rssi_b;\n\tu32 candidate;\n\n\tif (rtwvif->wifi_role != RTW89_WIFI_ROLE_STATION || sta->tdls)\n\t\treturn;\n\n\tif (*done)\n\t\treturn;\n\n\t*done = true;\n\n\trssi_a = ewma_rssi_read(&rtwsta->rssi[RF_PATH_A]);\n\trssi_b = ewma_rssi_read(&rtwsta->rssi[RF_PATH_B]);\n\n\tif (rssi_a > rssi_b + RTW89_TX_DIV_RSSI_RAW_TH)\n\t\tcandidate = RF_A;\n\telse if (rssi_b > rssi_a + RTW89_TX_DIV_RSSI_RAW_TH)\n\t\tcandidate = RF_B;\n\telse\n\t\treturn;\n\n\tif (hal->antenna_tx == candidate)\n\t\treturn;\n\n\thal->antenna_tx = candidate;\n\trtw89_fw_h2c_txpath_cmac_tbl(rtwdev, rtwsta);\n\n\tif (hal->antenna_tx == RF_A) {\n\t\trtw89_phy_write32_mask(rtwdev, R_P0_RFMODE, B_P0_RFMODE_MUX, 0x12);\n\t\trtw89_phy_write32_mask(rtwdev, R_P1_RFMODE, B_P1_RFMODE_MUX, 0x11);\n\t} else if (hal->antenna_tx == RF_B) {\n\t\trtw89_phy_write32_mask(rtwdev, R_P0_RFMODE, B_P0_RFMODE_MUX, 0x11);\n\t\trtw89_phy_write32_mask(rtwdev, R_P1_RFMODE, B_P1_RFMODE_MUX, 0x12);\n\t}\n}\n\nvoid rtw89_phy_tx_path_div_track(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_hal *hal = &rtwdev->hal;\n\tbool done = false;\n\n\tif (!hal->tx_path_diversity)\n\t\treturn;\n\n\tieee80211_iterate_stations_atomic(rtwdev->hw,\n\t\t\t\t\t  rtw89_phy_tx_path_div_sta_iter,\n\t\t\t\t\t  &done);\n}\n\n#define ANTDIV_MAIN 0\n#define ANTDIV_AUX 1\n\nstatic void rtw89_phy_antdiv_set_ant(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_hal *hal = &rtwdev->hal;\n\tu8 default_ant, optional_ant;\n\n\tif (!hal->ant_diversity || hal->antenna_tx == 0)\n\t\treturn;\n\n\tif (hal->antenna_tx == RF_B) {\n\t\tdefault_ant = ANTDIV_AUX;\n\t\toptional_ant = ANTDIV_MAIN;\n\t} else {\n\t\tdefault_ant = ANTDIV_MAIN;\n\t\toptional_ant = ANTDIV_AUX;\n\t}\n\n\trtw89_phy_write32_idx(rtwdev, R_P0_ANTSEL, B_P0_ANTSEL_CGCS_CTRL,\n\t\t\t      default_ant, RTW89_PHY_0);\n\trtw89_phy_write32_idx(rtwdev, R_P0_ANTSEL, B_P0_ANTSEL_RX_ORI,\n\t\t\t      default_ant, RTW89_PHY_0);\n\trtw89_phy_write32_idx(rtwdev, R_P0_ANTSEL, B_P0_ANTSEL_RX_ALT,\n\t\t\t      optional_ant, RTW89_PHY_0);\n\trtw89_phy_write32_idx(rtwdev, R_P0_ANTSEL, B_P0_ANTSEL_TX_ORI,\n\t\t\t      default_ant, RTW89_PHY_0);\n}\n\nstatic void rtw89_phy_swap_hal_antenna(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_hal *hal = &rtwdev->hal;\n\n\thal->antenna_rx = hal->antenna_rx == RF_A ? RF_B : RF_A;\n\thal->antenna_tx = hal->antenna_rx;\n}\n\nstatic void rtw89_phy_antdiv_decision_state(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_antdiv_info *antdiv = &rtwdev->antdiv;\n\tstruct rtw89_hal *hal = &rtwdev->hal;\n\tbool no_change = false;\n\tu8 main_rssi, aux_rssi;\n\tu8 main_evm, aux_evm;\n\tu32 candidate;\n\n\tantdiv->get_stats = false;\n\tantdiv->training_count = 0;\n\n\tmain_rssi = rtw89_phy_antdiv_sts_instance_get_rssi(&antdiv->main_stats);\n\tmain_evm = rtw89_phy_antdiv_sts_instance_get_evm(&antdiv->main_stats);\n\taux_rssi = rtw89_phy_antdiv_sts_instance_get_rssi(&antdiv->aux_stats);\n\taux_evm = rtw89_phy_antdiv_sts_instance_get_evm(&antdiv->aux_stats);\n\n\tif (main_evm > aux_evm + ANTDIV_EVM_DIFF_TH)\n\t\tcandidate = RF_A;\n\telse if (aux_evm > main_evm + ANTDIV_EVM_DIFF_TH)\n\t\tcandidate = RF_B;\n\telse if (main_rssi > aux_rssi + RTW89_TX_DIV_RSSI_RAW_TH)\n\t\tcandidate = RF_A;\n\telse if (aux_rssi > main_rssi + RTW89_TX_DIV_RSSI_RAW_TH)\n\t\tcandidate = RF_B;\n\telse\n\t\tno_change = true;\n\n\tif (no_change) {\n\t\t \n\t\trtw89_phy_swap_hal_antenna(rtwdev);\n\t\treturn;\n\t}\n\n\thal->antenna_tx = candidate;\n\thal->antenna_rx = candidate;\n}\n\nstatic void rtw89_phy_antdiv_training_state(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_antdiv_info *antdiv = &rtwdev->antdiv;\n\tu64 state_period;\n\n\tif (antdiv->training_count % 2 == 0) {\n\t\tif (antdiv->training_count == 0)\n\t\t\trtw89_phy_antdiv_sts_reset(rtwdev);\n\n\t\tantdiv->get_stats = true;\n\t\tstate_period = msecs_to_jiffies(ANTDIV_TRAINNING_INTVL);\n\t} else {\n\t\tantdiv->get_stats = false;\n\t\tstate_period = msecs_to_jiffies(ANTDIV_DELAY);\n\n\t\trtw89_phy_swap_hal_antenna(rtwdev);\n\t\trtw89_phy_antdiv_set_ant(rtwdev);\n\t}\n\n\tantdiv->training_count++;\n\tieee80211_queue_delayed_work(rtwdev->hw, &rtwdev->antdiv_work,\n\t\t\t\t     state_period);\n}\n\nvoid rtw89_phy_antdiv_work(struct work_struct *work)\n{\n\tstruct rtw89_dev *rtwdev = container_of(work, struct rtw89_dev,\n\t\t\t\t\t\tantdiv_work.work);\n\tstruct rtw89_antdiv_info *antdiv = &rtwdev->antdiv;\n\n\tmutex_lock(&rtwdev->mutex);\n\n\tif (antdiv->training_count <= ANTDIV_TRAINNING_CNT) {\n\t\trtw89_phy_antdiv_training_state(rtwdev);\n\t} else {\n\t\trtw89_phy_antdiv_decision_state(rtwdev);\n\t\trtw89_phy_antdiv_set_ant(rtwdev);\n\t}\n\n\tmutex_unlock(&rtwdev->mutex);\n}\n\nvoid rtw89_phy_antdiv_track(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_antdiv_info *antdiv = &rtwdev->antdiv;\n\tstruct rtw89_hal *hal = &rtwdev->hal;\n\tu8 rssi, rssi_pre;\n\n\tif (!hal->ant_diversity || hal->ant_diversity_fixed)\n\t\treturn;\n\n\trssi = rtw89_phy_antdiv_sts_instance_get_rssi(&antdiv->target_stats);\n\trssi_pre = antdiv->rssi_pre;\n\tantdiv->rssi_pre = rssi;\n\trtw89_phy_antdiv_sts_instance_reset(&antdiv->target_stats);\n\n\tif (abs((int)rssi - (int)rssi_pre) < ANTDIV_RSSI_DIFF_TH)\n\t\treturn;\n\n\tantdiv->training_count = 0;\n\tieee80211_queue_delayed_work(rtwdev->hw, &rtwdev->antdiv_work, 0);\n}\n\nstatic void rtw89_phy_env_monitor_init(struct rtw89_dev *rtwdev)\n{\n\trtw89_phy_ccx_top_setting_init(rtwdev);\n\trtw89_phy_ifs_clm_setting_init(rtwdev);\n}\n\nvoid rtw89_phy_dm_init(struct rtw89_dev *rtwdev)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\n\trtw89_phy_stat_init(rtwdev);\n\n\trtw89_chip_bb_sethw(rtwdev);\n\n\trtw89_phy_env_monitor_init(rtwdev);\n\trtw89_physts_parsing_init(rtwdev);\n\trtw89_phy_dig_init(rtwdev);\n\trtw89_phy_cfo_init(rtwdev);\n\trtw89_phy_ul_tb_info_init(rtwdev);\n\trtw89_phy_antdiv_init(rtwdev);\n\trtw89_chip_rfe_gpio(rtwdev);\n\trtw89_phy_antdiv_set_ant(rtwdev);\n\n\trtw89_phy_init_rf_nctl(rtwdev);\n\trtw89_chip_rfk_init(rtwdev);\n\trtw89_load_txpwr_table(rtwdev, chip->byr_table);\n\trtw89_chip_set_txpwr_ctrl(rtwdev);\n\trtw89_chip_power_trim(rtwdev);\n\trtw89_chip_cfg_txrx_path(rtwdev);\n}\n\nvoid rtw89_phy_set_bss_color(struct rtw89_dev *rtwdev, struct ieee80211_vif *vif)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tenum rtw89_phy_idx phy_idx = RTW89_PHY_0;\n\tu8 bss_color;\n\n\tif (!vif->bss_conf.he_support || !vif->cfg.assoc)\n\t\treturn;\n\n\tbss_color = vif->bss_conf.he_bss_color.color;\n\n\trtw89_phy_write32_idx(rtwdev, chip->bss_clr_map_reg, B_BSS_CLR_MAP_VLD0, 0x1,\n\t\t\t      phy_idx);\n\trtw89_phy_write32_idx(rtwdev, chip->bss_clr_map_reg, B_BSS_CLR_MAP_TGT,\n\t\t\t      bss_color, phy_idx);\n\trtw89_phy_write32_idx(rtwdev, chip->bss_clr_map_reg, B_BSS_CLR_MAP_STAID,\n\t\t\t      vif->cfg.aid, phy_idx);\n}\n\nstatic void\n_rfk_write_rf(struct rtw89_dev *rtwdev, const struct rtw89_reg5_def *def)\n{\n\trtw89_write_rf(rtwdev, def->path, def->addr, def->mask, def->data);\n}\n\nstatic void\n_rfk_write32_mask(struct rtw89_dev *rtwdev, const struct rtw89_reg5_def *def)\n{\n\trtw89_phy_write32_mask(rtwdev, def->addr, def->mask, def->data);\n}\n\nstatic void\n_rfk_write32_set(struct rtw89_dev *rtwdev, const struct rtw89_reg5_def *def)\n{\n\trtw89_phy_write32_set(rtwdev, def->addr, def->mask);\n}\n\nstatic void\n_rfk_write32_clr(struct rtw89_dev *rtwdev, const struct rtw89_reg5_def *def)\n{\n\trtw89_phy_write32_clr(rtwdev, def->addr, def->mask);\n}\n\nstatic void\n_rfk_delay(struct rtw89_dev *rtwdev, const struct rtw89_reg5_def *def)\n{\n\tudelay(def->data);\n}\n\nstatic void\n(*_rfk_handler[])(struct rtw89_dev *rtwdev, const struct rtw89_reg5_def *def) = {\n\t[RTW89_RFK_F_WRF] = _rfk_write_rf,\n\t[RTW89_RFK_F_WM] = _rfk_write32_mask,\n\t[RTW89_RFK_F_WS] = _rfk_write32_set,\n\t[RTW89_RFK_F_WC] = _rfk_write32_clr,\n\t[RTW89_RFK_F_DELAY] = _rfk_delay,\n};\n\nstatic_assert(ARRAY_SIZE(_rfk_handler) == RTW89_RFK_F_NUM);\n\nvoid\nrtw89_rfk_parser(struct rtw89_dev *rtwdev, const struct rtw89_rfk_tbl *tbl)\n{\n\tconst struct rtw89_reg5_def *p = tbl->defs;\n\tconst struct rtw89_reg5_def *end = tbl->defs + tbl->size;\n\n\tfor (; p < end; p++)\n\t\t_rfk_handler[p->flag](rtwdev, p);\n}\nEXPORT_SYMBOL(rtw89_rfk_parser);\n\n#define RTW89_TSSI_FAST_MODE_NUM 4\n\nstatic const struct rtw89_reg_def rtw89_tssi_fastmode_regs_flat[RTW89_TSSI_FAST_MODE_NUM] = {\n\t{0xD934, 0xff0000},\n\t{0xD934, 0xff000000},\n\t{0xD938, 0xff},\n\t{0xD934, 0xff00},\n};\n\nstatic const struct rtw89_reg_def rtw89_tssi_fastmode_regs_level[RTW89_TSSI_FAST_MODE_NUM] = {\n\t{0xD930, 0xff0000},\n\t{0xD930, 0xff000000},\n\t{0xD934, 0xff},\n\t{0xD930, 0xff00},\n};\n\nstatic\nvoid rtw89_phy_tssi_ctrl_set_fast_mode_cfg(struct rtw89_dev *rtwdev,\n\t\t\t\t\t   enum rtw89_mac_idx mac_idx,\n\t\t\t\t\t   enum rtw89_tssi_bandedge_cfg bandedge_cfg,\n\t\t\t\t\t   u32 val)\n{\n\tconst struct rtw89_reg_def *regs;\n\tu32 reg;\n\tint i;\n\n\tif (bandedge_cfg == RTW89_TSSI_BANDEDGE_FLAT)\n\t\tregs = rtw89_tssi_fastmode_regs_flat;\n\telse\n\t\tregs = rtw89_tssi_fastmode_regs_level;\n\n\tfor (i = 0; i < RTW89_TSSI_FAST_MODE_NUM; i++) {\n\t\treg = rtw89_mac_reg_by_idx(rtwdev, regs[i].addr, mac_idx);\n\t\trtw89_write32_mask(rtwdev, reg, regs[i].mask, val);\n\t}\n}\n\nstatic const struct rtw89_reg_def rtw89_tssi_bandedge_regs_flat[RTW89_TSSI_SBW_NUM] = {\n\t{0xD91C, 0xff000000},\n\t{0xD920, 0xff},\n\t{0xD920, 0xff00},\n\t{0xD920, 0xff0000},\n\t{0xD920, 0xff000000},\n\t{0xD924, 0xff},\n\t{0xD924, 0xff00},\n\t{0xD914, 0xff000000},\n\t{0xD918, 0xff},\n\t{0xD918, 0xff00},\n\t{0xD918, 0xff0000},\n\t{0xD918, 0xff000000},\n\t{0xD91C, 0xff},\n\t{0xD91C, 0xff00},\n\t{0xD91C, 0xff0000},\n};\n\nstatic const struct rtw89_reg_def rtw89_tssi_bandedge_regs_level[RTW89_TSSI_SBW_NUM] = {\n\t{0xD910, 0xff},\n\t{0xD910, 0xff00},\n\t{0xD910, 0xff0000},\n\t{0xD910, 0xff000000},\n\t{0xD914, 0xff},\n\t{0xD914, 0xff00},\n\t{0xD914, 0xff0000},\n\t{0xD908, 0xff},\n\t{0xD908, 0xff00},\n\t{0xD908, 0xff0000},\n\t{0xD908, 0xff000000},\n\t{0xD90C, 0xff},\n\t{0xD90C, 0xff00},\n\t{0xD90C, 0xff0000},\n\t{0xD90C, 0xff000000},\n};\n\nvoid rtw89_phy_tssi_ctrl_set_bandedge_cfg(struct rtw89_dev *rtwdev,\n\t\t\t\t\t  enum rtw89_mac_idx mac_idx,\n\t\t\t\t\t  enum rtw89_tssi_bandedge_cfg bandedge_cfg)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tconst struct rtw89_reg_def *regs;\n\tconst u32 *data;\n\tu32 reg;\n\tint i;\n\n\tif (bandedge_cfg >= RTW89_TSSI_CFG_NUM)\n\t\treturn;\n\n\tif (bandedge_cfg == RTW89_TSSI_BANDEDGE_FLAT)\n\t\tregs = rtw89_tssi_bandedge_regs_flat;\n\telse\n\t\tregs = rtw89_tssi_bandedge_regs_level;\n\n\tdata = chip->tssi_dbw_table->data[bandedge_cfg];\n\n\tfor (i = 0; i < RTW89_TSSI_SBW_NUM; i++) {\n\t\treg = rtw89_mac_reg_by_idx(rtwdev, regs[i].addr, mac_idx);\n\t\trtw89_write32_mask(rtwdev, reg, regs[i].mask, data[i]);\n\t}\n\n\treg = rtw89_mac_reg_by_idx(rtwdev, R_AX_BANDEDGE_CFG, mac_idx);\n\trtw89_write32_mask(rtwdev, reg, B_AX_BANDEDGE_CFG_IDX_MASK, bandedge_cfg);\n\n\trtw89_phy_tssi_ctrl_set_fast_mode_cfg(rtwdev, mac_idx, bandedge_cfg,\n\t\t\t\t\t      data[RTW89_TSSI_SBW20]);\n}\nEXPORT_SYMBOL(rtw89_phy_tssi_ctrl_set_bandedge_cfg);\n\nstatic\nconst u8 rtw89_ch_base_table[16] = {1, 0xff,\n\t\t\t\t    36, 100, 132, 149, 0xff,\n\t\t\t\t    1, 33, 65, 97, 129, 161, 193, 225, 0xff};\n#define RTW89_CH_BASE_IDX_2G\t\t0\n#define RTW89_CH_BASE_IDX_5G_FIRST\t2\n#define RTW89_CH_BASE_IDX_5G_LAST\t5\n#define RTW89_CH_BASE_IDX_6G_FIRST\t7\n#define RTW89_CH_BASE_IDX_6G_LAST\t14\n\n#define RTW89_CH_BASE_IDX_MASK\t\tGENMASK(7, 4)\n#define RTW89_CH_OFFSET_MASK\t\tGENMASK(3, 0)\n\nu8 rtw89_encode_chan_idx(struct rtw89_dev *rtwdev, u8 central_ch, u8 band)\n{\n\tu8 chan_idx;\n\tu8 last, first;\n\tu8 idx;\n\n\tswitch (band) {\n\tcase RTW89_BAND_2G:\n\t\tchan_idx = FIELD_PREP(RTW89_CH_BASE_IDX_MASK, RTW89_CH_BASE_IDX_2G) |\n\t\t\t   FIELD_PREP(RTW89_CH_OFFSET_MASK, central_ch);\n\t\treturn chan_idx;\n\tcase RTW89_BAND_5G:\n\t\tfirst = RTW89_CH_BASE_IDX_5G_FIRST;\n\t\tlast = RTW89_CH_BASE_IDX_5G_LAST;\n\t\tbreak;\n\tcase RTW89_BAND_6G:\n\t\tfirst = RTW89_CH_BASE_IDX_6G_FIRST;\n\t\tlast = RTW89_CH_BASE_IDX_6G_LAST;\n\t\tbreak;\n\tdefault:\n\t\trtw89_warn(rtwdev, \"Unsupported band %d\\n\", band);\n\t\treturn 0;\n\t}\n\n\tfor (idx = last; idx >= first; idx--)\n\t\tif (central_ch >= rtw89_ch_base_table[idx])\n\t\t\tbreak;\n\n\tif (idx < first) {\n\t\trtw89_warn(rtwdev, \"Unknown band %d channel %d\\n\", band, central_ch);\n\t\treturn 0;\n\t}\n\n\tchan_idx = FIELD_PREP(RTW89_CH_BASE_IDX_MASK, idx) |\n\t\t   FIELD_PREP(RTW89_CH_OFFSET_MASK,\n\t\t\t      (central_ch - rtw89_ch_base_table[idx]) >> 1);\n\treturn chan_idx;\n}\nEXPORT_SYMBOL(rtw89_encode_chan_idx);\n\nvoid rtw89_decode_chan_idx(struct rtw89_dev *rtwdev, u8 chan_idx,\n\t\t\t   u8 *ch, enum nl80211_band *band)\n{\n\tu8 idx, offset;\n\n\tidx = FIELD_GET(RTW89_CH_BASE_IDX_MASK, chan_idx);\n\toffset = FIELD_GET(RTW89_CH_OFFSET_MASK, chan_idx);\n\n\tif (idx == RTW89_CH_BASE_IDX_2G) {\n\t\t*band = NL80211_BAND_2GHZ;\n\t\t*ch = offset;\n\t\treturn;\n\t}\n\n\t*band = idx <= RTW89_CH_BASE_IDX_5G_LAST ? NL80211_BAND_5GHZ : NL80211_BAND_6GHZ;\n\t*ch = rtw89_ch_base_table[idx] + (offset << 1);\n}\nEXPORT_SYMBOL(rtw89_decode_chan_idx);\n\n#define EDCCA_DEFAULT 249\nvoid rtw89_phy_config_edcca(struct rtw89_dev *rtwdev, bool scan)\n{\n\tu32 reg = rtwdev->chip->edcca_lvl_reg;\n\tstruct rtw89_hal *hal = &rtwdev->hal;\n\tu32 val;\n\n\tif (scan) {\n\t\thal->edcca_bak = rtw89_phy_read32(rtwdev, reg);\n\t\tval = hal->edcca_bak;\n\t\tu32p_replace_bits(&val, EDCCA_DEFAULT, B_SEG0R_EDCCA_LVL_A_MSK);\n\t\tu32p_replace_bits(&val, EDCCA_DEFAULT, B_SEG0R_EDCCA_LVL_P_MSK);\n\t\tu32p_replace_bits(&val, EDCCA_DEFAULT, B_SEG0R_PPDU_LVL_MSK);\n\t\trtw89_phy_write32(rtwdev, reg, val);\n\t} else {\n\t\trtw89_phy_write32(rtwdev, reg, hal->edcca_bak);\n\t}\n}\n\nstatic const struct rtw89_ccx_regs rtw89_ccx_regs_ax = {\n\t.setting_addr = R_CCX,\n\t.edcca_opt_mask = B_CCX_EDCCA_OPT_MSK,\n\t.measurement_trig_mask = B_MEASUREMENT_TRIG_MSK,\n\t.trig_opt_mask = B_CCX_TRIG_OPT_MSK,\n\t.en_mask = B_CCX_EN_MSK,\n\t.ifs_cnt_addr = R_IFS_COUNTER,\n\t.ifs_clm_period_mask = B_IFS_CLM_PERIOD_MSK,\n\t.ifs_clm_cnt_unit_mask = B_IFS_CLM_COUNTER_UNIT_MSK,\n\t.ifs_clm_cnt_clear_mask = B_IFS_COUNTER_CLR_MSK,\n\t.ifs_collect_en_mask = B_IFS_COLLECT_EN,\n\t.ifs_t1_addr = R_IFS_T1,\n\t.ifs_t1_th_h_mask = B_IFS_T1_TH_HIGH_MSK,\n\t.ifs_t1_en_mask = B_IFS_T1_EN_MSK,\n\t.ifs_t1_th_l_mask = B_IFS_T1_TH_LOW_MSK,\n\t.ifs_t2_addr = R_IFS_T2,\n\t.ifs_t2_th_h_mask = B_IFS_T2_TH_HIGH_MSK,\n\t.ifs_t2_en_mask = B_IFS_T2_EN_MSK,\n\t.ifs_t2_th_l_mask = B_IFS_T2_TH_LOW_MSK,\n\t.ifs_t3_addr = R_IFS_T3,\n\t.ifs_t3_th_h_mask = B_IFS_T3_TH_HIGH_MSK,\n\t.ifs_t3_en_mask = B_IFS_T3_EN_MSK,\n\t.ifs_t3_th_l_mask = B_IFS_T3_TH_LOW_MSK,\n\t.ifs_t4_addr = R_IFS_T4,\n\t.ifs_t4_th_h_mask = B_IFS_T4_TH_HIGH_MSK,\n\t.ifs_t4_en_mask = B_IFS_T4_EN_MSK,\n\t.ifs_t4_th_l_mask = B_IFS_T4_TH_LOW_MSK,\n\t.ifs_clm_tx_cnt_addr = R_IFS_CLM_TX_CNT,\n\t.ifs_clm_edcca_excl_cca_fa_mask = B_IFS_CLM_EDCCA_EXCLUDE_CCA_FA_MSK,\n\t.ifs_clm_tx_cnt_msk = B_IFS_CLM_TX_CNT_MSK,\n\t.ifs_clm_cca_addr = R_IFS_CLM_CCA,\n\t.ifs_clm_ofdmcca_excl_fa_mask = B_IFS_CLM_OFDMCCA_EXCLUDE_FA_MSK,\n\t.ifs_clm_cckcca_excl_fa_mask = B_IFS_CLM_CCKCCA_EXCLUDE_FA_MSK,\n\t.ifs_clm_fa_addr = R_IFS_CLM_FA,\n\t.ifs_clm_ofdm_fa_mask = B_IFS_CLM_OFDM_FA_MSK,\n\t.ifs_clm_cck_fa_mask = B_IFS_CLM_CCK_FA_MSK,\n\t.ifs_his_addr = R_IFS_HIS,\n\t.ifs_t4_his_mask = B_IFS_T4_HIS_MSK,\n\t.ifs_t3_his_mask = B_IFS_T3_HIS_MSK,\n\t.ifs_t2_his_mask = B_IFS_T2_HIS_MSK,\n\t.ifs_t1_his_mask = B_IFS_T1_HIS_MSK,\n\t.ifs_avg_l_addr = R_IFS_AVG_L,\n\t.ifs_t2_avg_mask = B_IFS_T2_AVG_MSK,\n\t.ifs_t1_avg_mask = B_IFS_T1_AVG_MSK,\n\t.ifs_avg_h_addr = R_IFS_AVG_H,\n\t.ifs_t4_avg_mask = B_IFS_T4_AVG_MSK,\n\t.ifs_t3_avg_mask = B_IFS_T3_AVG_MSK,\n\t.ifs_cca_l_addr = R_IFS_CCA_L,\n\t.ifs_t2_cca_mask = B_IFS_T2_CCA_MSK,\n\t.ifs_t1_cca_mask = B_IFS_T1_CCA_MSK,\n\t.ifs_cca_h_addr = R_IFS_CCA_H,\n\t.ifs_t4_cca_mask = B_IFS_T4_CCA_MSK,\n\t.ifs_t3_cca_mask = B_IFS_T3_CCA_MSK,\n\t.ifs_total_addr = R_IFSCNT,\n\t.ifs_cnt_done_mask = B_IFSCNT_DONE_MSK,\n\t.ifs_total_mask = B_IFSCNT_TOTAL_CNT_MSK,\n};\n\nstatic const struct rtw89_physts_regs rtw89_physts_regs_ax = {\n\t.setting_addr = R_PLCP_HISTOGRAM,\n\t.dis_trigger_fail_mask = B_STS_DIS_TRIG_BY_FAIL,\n\t.dis_trigger_brk_mask = B_STS_DIS_TRIG_BY_BRK,\n};\n\nconst struct rtw89_phy_gen_def rtw89_phy_gen_ax = {\n\t.cr_base = 0x10000,\n\t.ccx = &rtw89_ccx_regs_ax,\n\t.physts = &rtw89_physts_regs_ax,\n};\nEXPORT_SYMBOL(rtw89_phy_gen_ax);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}