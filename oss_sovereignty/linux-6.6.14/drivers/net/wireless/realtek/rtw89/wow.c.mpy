{
  "module_name": "wow.c",
  "hash_id": "4e1579d71141f4865c3145a823a9bd69619c33d57553be6b39487ad40b346c2b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtw89/wow.c",
  "human_readable_source": "\n \n#include \"cam.h\"\n#include \"core.h\"\n#include \"debug.h\"\n#include \"fw.h\"\n#include \"mac.h\"\n#include \"phy.h\"\n#include \"ps.h\"\n#include \"reg.h\"\n#include \"util.h\"\n#include \"wow.h\"\n\nstatic void rtw89_wow_leave_deep_ps(struct rtw89_dev *rtwdev)\n{\n\t__rtw89_leave_ps_mode(rtwdev);\n}\n\nstatic void rtw89_wow_enter_deep_ps(struct rtw89_dev *rtwdev)\n{\n\tstruct ieee80211_vif *wow_vif = rtwdev->wow.wow_vif;\n\tstruct rtw89_vif *rtwvif = (struct rtw89_vif *)wow_vif->drv_priv;\n\n\t__rtw89_enter_ps_mode(rtwdev, rtwvif);\n}\n\nstatic void rtw89_wow_enter_lps(struct rtw89_dev *rtwdev)\n{\n\tstruct ieee80211_vif *wow_vif = rtwdev->wow.wow_vif;\n\tstruct rtw89_vif *rtwvif = (struct rtw89_vif *)wow_vif->drv_priv;\n\n\trtw89_enter_lps(rtwdev, rtwvif, false);\n}\n\nstatic void rtw89_wow_leave_lps(struct rtw89_dev *rtwdev)\n{\n\trtw89_leave_lps(rtwdev);\n}\n\nstatic int rtw89_wow_config_mac(struct rtw89_dev *rtwdev, bool enable_wow)\n{\n\tconst struct rtw89_mac_gen_def *mac = rtwdev->chip->mac_def;\n\tint ret;\n\n\tif (enable_wow) {\n\t\tret = rtw89_mac_resize_ple_rx_quota(rtwdev, true);\n\t\tif (ret) {\n\t\t\trtw89_err(rtwdev, \"[ERR]patch rx qta %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\trtw89_write32_set(rtwdev, R_AX_RX_FUNCTION_STOP, B_AX_HDR_RX_STOP);\n\t\trtw89_write32_clr(rtwdev, mac->rx_fltr, B_AX_SNIFFER_MODE);\n\t\trtw89_mac_cfg_ppdu_status(rtwdev, RTW89_MAC_0, false);\n\t\trtw89_write32(rtwdev, R_AX_ACTION_FWD0, 0);\n\t\trtw89_write32(rtwdev, R_AX_ACTION_FWD1, 0);\n\t\trtw89_write32(rtwdev, R_AX_TF_FWD, 0);\n\t\trtw89_write32(rtwdev, R_AX_HW_RPT_FWD, 0);\n\t} else {\n\t\tret = rtw89_mac_resize_ple_rx_quota(rtwdev, false);\n\t\tif (ret) {\n\t\t\trtw89_err(rtwdev, \"[ERR]patch rx qta %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\trtw89_write32_clr(rtwdev, R_AX_RX_FUNCTION_STOP, B_AX_HDR_RX_STOP);\n\t\trtw89_mac_cfg_ppdu_status(rtwdev, RTW89_MAC_0, true);\n\t\trtw89_write32(rtwdev, R_AX_ACTION_FWD0, TRXCFG_MPDU_PROC_ACT_FRWD);\n\t\trtw89_write32(rtwdev, R_AX_TF_FWD, TRXCFG_MPDU_PROC_TF_FRWD);\n\t}\n\n\treturn 0;\n}\n\nstatic void rtw89_wow_set_rx_filter(struct rtw89_dev *rtwdev, bool enable)\n{\n\tenum rtw89_mac_fwd_target fwd_target = enable ?\n\t\t\t\t\t       RTW89_FWD_DONT_CARE :\n\t\t\t\t\t       RTW89_FWD_TO_HOST;\n\n\trtw89_mac_typ_fltr_opt(rtwdev, RTW89_MGNT, fwd_target, RTW89_MAC_0);\n\trtw89_mac_typ_fltr_opt(rtwdev, RTW89_CTRL, fwd_target, RTW89_MAC_0);\n\trtw89_mac_typ_fltr_opt(rtwdev, RTW89_DATA, fwd_target, RTW89_MAC_0);\n}\n\nstatic void rtw89_wow_show_wakeup_reason(struct rtw89_dev *rtwdev)\n{\n\tenum rtw89_core_chip_id chip_id = rtwdev->chip->chip_id;\n\tstruct cfg80211_wowlan_nd_info nd_info;\n\tstruct cfg80211_wowlan_wakeup wakeup = {\n\t\t.pattern_idx = -1,\n\t};\n\tu32 wow_reason_reg;\n\tu8 reason;\n\n\tif (chip_id == RTL8852A || chip_id == RTL8852B || chip_id == RTL8851B)\n\t\twow_reason_reg = R_AX_C2HREG_DATA3 + 3;\n\telse\n\t\twow_reason_reg = R_AX_C2HREG_DATA3_V1 + 3;\n\n\treason = rtw89_read8(rtwdev, wow_reason_reg);\n\n\tswitch (reason) {\n\tcase RTW89_WOW_RSN_RX_DEAUTH:\n\t\twakeup.disconnect = true;\n\t\trtw89_debug(rtwdev, RTW89_DBG_WOW, \"WOW: Rx deauth\\n\");\n\t\tbreak;\n\tcase RTW89_WOW_RSN_DISCONNECT:\n\t\twakeup.disconnect = true;\n\t\trtw89_debug(rtwdev, RTW89_DBG_WOW, \"WOW: AP is off\\n\");\n\t\tbreak;\n\tcase RTW89_WOW_RSN_RX_MAGIC_PKT:\n\t\twakeup.magic_pkt = true;\n\t\trtw89_debug(rtwdev, RTW89_DBG_WOW, \"WOW: Rx magic packet\\n\");\n\t\tbreak;\n\tcase RTW89_WOW_RSN_RX_GTK_REKEY:\n\t\twakeup.gtk_rekey_failure = true;\n\t\trtw89_debug(rtwdev, RTW89_DBG_WOW, \"WOW: Rx gtk rekey\\n\");\n\t\tbreak;\n\tcase RTW89_WOW_RSN_RX_PATTERN_MATCH:\n\t\t \n\t\twakeup.pattern_idx = 0;\n\t\trtw89_debug(rtwdev, RTW89_DBG_WOW, \"WOW: Rx pattern match packet\\n\");\n\t\tbreak;\n\tcase RTW89_WOW_RSN_RX_NLO:\n\t\t \n\t\tnd_info.n_matches = 0;\n\t\twakeup.net_detect = &nd_info;\n\t\trtw89_debug(rtwdev, RTW89_DBG_WOW, \"Rx NLO\\n\");\n\t\tbreak;\n\tdefault:\n\t\trtw89_warn(rtwdev, \"Unknown wakeup reason %x\\n\", reason);\n\t\tieee80211_report_wowlan_wakeup(rtwdev->wow.wow_vif, NULL,\n\t\t\t\t\t       GFP_KERNEL);\n\t\treturn;\n\t}\n\n\tieee80211_report_wowlan_wakeup(rtwdev->wow.wow_vif, &wakeup,\n\t\t\t\t       GFP_KERNEL);\n}\n\nstatic void rtw89_wow_vif_iter(struct rtw89_dev *rtwdev, struct rtw89_vif *rtwvif)\n{\n\tstruct rtw89_wow_param *rtw_wow = &rtwdev->wow;\n\tstruct ieee80211_vif *vif = rtwvif_to_vif(rtwvif);\n\n\t \n\tif (rtw_wow->wow_vif || vif->type != NL80211_IFTYPE_STATION)\n\t\treturn;\n\n\tswitch (rtwvif->net_type) {\n\tcase RTW89_NET_TYPE_INFRA:\n\t\trtw_wow->wow_vif = vif;\n\t\tbreak;\n\tcase RTW89_NET_TYPE_NO_LINK:\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic u16 __rtw89_cal_crc16(u8 data, u16 crc)\n{\n\tu8 shift_in, data_bit;\n\tu8 crc_bit4, crc_bit11, crc_bit15;\n\tu16 crc_result;\n\tint index;\n\n\tfor (index = 0; index < 8; index++) {\n\t\tcrc_bit15 = crc & BIT(15) ? 1 : 0;\n\t\tdata_bit = data & BIT(index) ? 1 : 0;\n\t\tshift_in = crc_bit15 ^ data_bit;\n\n\t\tcrc_result = crc << 1;\n\n\t\tif (shift_in == 0)\n\t\t\tcrc_result &= ~BIT(0);\n\t\telse\n\t\t\tcrc_result |= BIT(0);\n\n\t\tcrc_bit11 = (crc & BIT(11) ? 1 : 0) ^ shift_in;\n\n\t\tif (crc_bit11 == 0)\n\t\t\tcrc_result &= ~BIT(12);\n\t\telse\n\t\t\tcrc_result |= BIT(12);\n\n\t\tcrc_bit4 = (crc & BIT(4) ? 1 : 0) ^ shift_in;\n\n\t\tif (crc_bit4 == 0)\n\t\t\tcrc_result &= ~BIT(5);\n\t\telse\n\t\t\tcrc_result |= BIT(5);\n\n\t\tcrc = crc_result;\n\t}\n\treturn crc;\n}\n\nstatic u16 rtw89_calc_crc(u8 *pdata, int length)\n{\n\tu16 crc = 0xffff;\n\tint i;\n\n\tfor (i = 0; i < length; i++)\n\t\tcrc = __rtw89_cal_crc16(pdata[i], crc);\n\n\t \n\treturn ~crc;\n}\n\nstatic int rtw89_wow_pattern_get_type(struct rtw89_vif *rtwvif,\n\t\t\t\t      struct rtw89_wow_cam_info *rtw_pattern,\n\t\t\t\t      const u8 *pattern, u8 da_mask)\n{\n\tu8 da[ETH_ALEN];\n\n\tether_addr_copy_mask(da, pattern, da_mask);\n\n\t \n\n\tif (is_broadcast_ether_addr(da))\n\t\trtw_pattern->bc = true;\n\telse if (is_multicast_ether_addr(da))\n\t\trtw_pattern->mc = true;\n\telse if (ether_addr_equal(da, rtwvif->mac_addr) &&\n\t\t da_mask == GENMASK(5, 0))\n\t\trtw_pattern->uc = true;\n\telse if (!da_mask)  \n\t\treturn 0;\n\telse\n\t\treturn -EPERM;\n\n\treturn 0;\n}\n\nstatic int rtw89_wow_pattern_generate(struct rtw89_dev *rtwdev,\n\t\t\t\t      struct rtw89_vif *rtwvif,\n\t\t\t\t      const struct cfg80211_pkt_pattern *pkt_pattern,\n\t\t\t\t      struct rtw89_wow_cam_info *rtw_pattern)\n{\n\tu8 mask_hw[RTW89_MAX_PATTERN_MASK_SIZE * 4] = {0};\n\tu8 content[RTW89_MAX_PATTERN_SIZE] = {0};\n\tconst u8 *mask;\n\tconst u8 *pattern;\n\tu8 mask_len;\n\tu16 count;\n\tu32 len;\n\tint i, ret;\n\n\tpattern = pkt_pattern->pattern;\n\tlen = pkt_pattern->pattern_len;\n\tmask = pkt_pattern->mask;\n\tmask_len = DIV_ROUND_UP(len, 8);\n\tmemset(rtw_pattern, 0, sizeof(*rtw_pattern));\n\n\tret = rtw89_wow_pattern_get_type(rtwvif, rtw_pattern, pattern,\n\t\t\t\t\t mask[0] & GENMASK(5, 0));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\t \n\tfor (i = 0; i < mask_len - 1; i++) {\n\t\tmask_hw[i] = u8_get_bits(mask[i], GENMASK(7, 6)) |\n\t\t\t     u8_get_bits(mask[i + 1], GENMASK(5, 0)) << 2;\n\t}\n\tmask_hw[i] = u8_get_bits(mask[i], GENMASK(7, 6));\n\n\t \n\tmask_hw[0] &= ~GENMASK(5, 0);\n\n\tmemcpy(rtw_pattern->mask, mask_hw, sizeof(rtw_pattern->mask));\n\n\t \n\tcount = 0;\n\tfor (i = 12; i < len; i++) {\n\t\tif ((mask[i / 8] >> (i % 8)) & 0x01) {\n\t\t\tcontent[count] = pattern[i];\n\t\t\tcount++;\n\t\t}\n\t}\n\n\trtw_pattern->crc = rtw89_calc_crc(content, count);\n\n\treturn 0;\n}\n\nstatic int rtw89_wow_parse_patterns(struct rtw89_dev *rtwdev,\n\t\t\t\t    struct rtw89_vif *rtwvif,\n\t\t\t\t    struct cfg80211_wowlan *wowlan)\n{\n\tstruct rtw89_wow_param *rtw_wow = &rtwdev->wow;\n\tstruct rtw89_wow_cam_info *rtw_pattern = rtw_wow->patterns;\n\tint i;\n\tint ret;\n\n\tif (!wowlan->n_patterns || !wowlan->patterns)\n\t\treturn 0;\n\n\tfor (i = 0; i < wowlan->n_patterns; i++) {\n\t\trtw_pattern = &rtw_wow->patterns[i];\n\t\tret = rtw89_wow_pattern_generate(rtwdev, rtwvif,\n\t\t\t\t\t\t &wowlan->patterns[i],\n\t\t\t\t\t\t rtw_pattern);\n\t\tif (ret) {\n\t\t\trtw89_err(rtwdev, \"failed to generate pattern(%d)\\n\", i);\n\t\t\trtw_wow->pattern_cnt = 0;\n\t\t\treturn ret;\n\t\t}\n\n\t\trtw_pattern->r_w = true;\n\t\trtw_pattern->idx = i;\n\t\trtw_pattern->negative_pattern_match = false;\n\t\trtw_pattern->skip_mac_hdr = true;\n\t\trtw_pattern->valid = true;\n\t}\n\trtw_wow->pattern_cnt = wowlan->n_patterns;\n\n\treturn 0;\n}\n\nstatic void rtw89_wow_pattern_clear_cam(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_wow_param *rtw_wow = &rtwdev->wow;\n\tstruct rtw89_wow_cam_info *rtw_pattern = rtw_wow->patterns;\n\tint i = 0;\n\n\tfor (i = 0; i < rtw_wow->pattern_cnt; i++) {\n\t\trtw_pattern = &rtw_wow->patterns[i];\n\t\trtw_pattern->valid = false;\n\t\trtw89_fw_wow_cam_update(rtwdev, rtw_pattern);\n\t}\n}\n\nstatic void rtw89_wow_pattern_write(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_wow_param *rtw_wow = &rtwdev->wow;\n\tstruct rtw89_wow_cam_info *rtw_pattern = rtw_wow->patterns;\n\tint i;\n\n\tfor (i = 0; i < rtw_wow->pattern_cnt; i++)\n\t\trtw89_fw_wow_cam_update(rtwdev, rtw_pattern + i);\n}\n\nstatic void rtw89_wow_pattern_clear(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_wow_param *rtw_wow = &rtwdev->wow;\n\n\trtw89_wow_pattern_clear_cam(rtwdev);\n\n\trtw_wow->pattern_cnt = 0;\n\tmemset(rtw_wow->patterns, 0, sizeof(rtw_wow->patterns));\n}\n\nstatic void rtw89_wow_clear_wakeups(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_wow_param *rtw_wow = &rtwdev->wow;\n\n\trtw_wow->wow_vif = NULL;\n\trtw89_core_release_all_bits_map(rtw_wow->flags, RTW89_WOW_FLAG_NUM);\n\trtw_wow->pattern_cnt = 0;\n}\n\nstatic int rtw89_wow_set_wakeups(struct rtw89_dev *rtwdev,\n\t\t\t\t struct cfg80211_wowlan *wowlan)\n{\n\tstruct rtw89_wow_param *rtw_wow = &rtwdev->wow;\n\tstruct rtw89_vif *rtwvif;\n\n\tif (wowlan->disconnect)\n\t\tset_bit(RTW89_WOW_FLAG_EN_DISCONNECT, rtw_wow->flags);\n\tif (wowlan->magic_pkt)\n\t\tset_bit(RTW89_WOW_FLAG_EN_MAGIC_PKT, rtw_wow->flags);\n\n\trtw89_for_each_rtwvif(rtwdev, rtwvif)\n\t\trtw89_wow_vif_iter(rtwdev, rtwvif);\n\n\tif (!rtw_wow->wow_vif)\n\t\treturn -EPERM;\n\n\trtwvif = (struct rtw89_vif *)rtw_wow->wow_vif->drv_priv;\n\treturn rtw89_wow_parse_patterns(rtwdev, rtwvif, wowlan);\n}\n\nstatic int rtw89_wow_cfg_wake(struct rtw89_dev *rtwdev, bool wow)\n{\n\tstruct rtw89_wow_param *rtw_wow = &rtwdev->wow;\n\tstruct ieee80211_vif *wow_vif = rtw_wow->wow_vif;\n\tstruct rtw89_vif *rtwvif = (struct rtw89_vif *)wow_vif->drv_priv;\n\tstruct ieee80211_sta *wow_sta;\n\tstruct rtw89_sta *rtwsta = NULL;\n\tint ret;\n\n\twow_sta = ieee80211_find_sta(wow_vif, rtwvif->bssid);\n\tif (wow_sta)\n\t\trtwsta = (struct rtw89_sta *)wow_sta->drv_priv;\n\n\tif (wow) {\n\t\tif (rtw_wow->pattern_cnt)\n\t\t\trtwvif->wowlan_pattern = true;\n\t\tif (test_bit(RTW89_WOW_FLAG_EN_MAGIC_PKT, rtw_wow->flags))\n\t\t\trtwvif->wowlan_magic = true;\n\t} else {\n\t\trtwvif->wowlan_pattern = false;\n\t\trtwvif->wowlan_magic = false;\n\t}\n\n\tret = rtw89_fw_h2c_wow_wakeup_ctrl(rtwdev, rtwvif, wow);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to fw wow wakeup ctrl\\n\");\n\t\treturn ret;\n\t}\n\n\tif (wow) {\n\t\tret = rtw89_chip_h2c_dctl_sec_cam(rtwdev, rtwvif, rtwsta);\n\t\tif (ret) {\n\t\t\trtw89_err(rtwdev, \"failed to update dctl cam sec entry: %d\\n\",\n\t\t\t\t  ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = rtw89_fw_h2c_cam(rtwdev, rtwvif, rtwsta, NULL);\n\tif (ret) {\n\t\trtw89_warn(rtwdev, \"failed to send h2c cam\\n\");\n\t\treturn ret;\n\t}\n\n\tret = rtw89_fw_h2c_wow_global(rtwdev, rtwvif, wow);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to fw wow global\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int rtw89_wow_check_fw_status(struct rtw89_dev *rtwdev, bool wow_enable)\n{\n\tu8 polling;\n\tint ret;\n\n\tret = read_poll_timeout_atomic(rtw89_read8_mask, polling,\n\t\t\t\t       wow_enable == !!polling,\n\t\t\t\t       50, 50000, false, rtwdev,\n\t\t\t\t       R_AX_WOW_CTRL, B_AX_WOW_WOWEN);\n\tif (ret)\n\t\trtw89_err(rtwdev, \"failed to check wow status %s\\n\",\n\t\t\t  wow_enable ? \"enabled\" : \"disabled\");\n\treturn ret;\n}\n\nstatic int rtw89_wow_swap_fw(struct rtw89_dev *rtwdev, bool wow)\n{\n\tenum rtw89_fw_type fw_type = wow ? RTW89_FW_WOWLAN : RTW89_FW_NORMAL;\n\tstruct rtw89_wow_param *rtw_wow = &rtwdev->wow;\n\tstruct ieee80211_vif *wow_vif = rtw_wow->wow_vif;\n\tstruct rtw89_vif *rtwvif = (struct rtw89_vif *)wow_vif->drv_priv;\n\tstruct ieee80211_sta *wow_sta;\n\tstruct rtw89_sta *rtwsta = NULL;\n\tbool is_conn = true;\n\tint ret;\n\n\trtw89_hci_disable_intr(rtwdev);\n\n\twow_sta = ieee80211_find_sta(wow_vif, rtwvif->bssid);\n\tif (wow_sta)\n\t\trtwsta = (struct rtw89_sta *)wow_sta->drv_priv;\n\telse\n\t\tis_conn = false;\n\n\tret = rtw89_fw_download(rtwdev, fw_type);\n\tif (ret) {\n\t\trtw89_warn(rtwdev, \"download fw failed\\n\");\n\t\treturn ret;\n\t}\n\n\trtw89_phy_init_rf_reg(rtwdev, true);\n\n\tret = rtw89_fw_h2c_role_maintain(rtwdev, rtwvif, rtwsta,\n\t\t\t\t\t RTW89_ROLE_FW_RESTORE);\n\tif (ret) {\n\t\trtw89_warn(rtwdev, \"failed to send h2c role maintain\\n\");\n\t\treturn ret;\n\t}\n\n\tret = rtw89_fw_h2c_assoc_cmac_tbl(rtwdev, wow_vif, wow_sta);\n\tif (ret) {\n\t\trtw89_warn(rtwdev, \"failed to send h2c assoc cmac tbl\\n\");\n\t\treturn ret;\n\t}\n\n\tif (!is_conn)\n\t\trtw89_cam_reset_keys(rtwdev);\n\n\tret = rtw89_fw_h2c_join_info(rtwdev, rtwvif, rtwsta, !is_conn);\n\tif (ret) {\n\t\trtw89_warn(rtwdev, \"failed to send h2c join info\\n\");\n\t\treturn ret;\n\t}\n\n\tret = rtw89_fw_h2c_cam(rtwdev, rtwvif, rtwsta, NULL);\n\tif (ret) {\n\t\trtw89_warn(rtwdev, \"failed to send h2c cam\\n\");\n\t\treturn ret;\n\t}\n\n\tif (is_conn) {\n\t\tret = rtw89_fw_h2c_general_pkt(rtwdev, rtwvif, rtwsta->mac_id);\n\t\tif (ret) {\n\t\t\trtw89_warn(rtwdev, \"failed to send h2c general packet\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\trtw89_phy_ra_assoc(rtwdev, wow_sta);\n\t\trtw89_phy_set_bss_color(rtwdev, wow_vif);\n\t\trtw89_chip_cfg_txpwr_ul_tb_offset(rtwdev, wow_vif);\n\t}\n\n\trtw89_mac_hw_mgnt_sec(rtwdev, wow);\n\trtw89_hci_enable_intr(rtwdev);\n\n\treturn 0;\n}\n\nstatic int rtw89_wow_enable_trx_pre(struct rtw89_dev *rtwdev)\n{\n\tint ret;\n\n\trtw89_hci_ctrl_txdma_ch(rtwdev, false);\n\trtw89_hci_ctrl_txdma_fw_ch(rtwdev, true);\n\n\trtw89_mac_ptk_drop_by_band_and_wait(rtwdev, RTW89_MAC_0);\n\n\tret = rtw89_hci_poll_txdma_ch(rtwdev);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"txdma ch busy\\n\");\n\t\treturn ret;\n\t}\n\trtw89_wow_set_rx_filter(rtwdev, true);\n\n\tret = rtw89_mac_cfg_ppdu_status(rtwdev, RTW89_MAC_0, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"cfg ppdu status\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int rtw89_wow_enable_trx_post(struct rtw89_dev *rtwdev)\n{\n\tint ret;\n\n\trtw89_hci_disable_intr(rtwdev);\n\trtw89_hci_ctrl_trxhci(rtwdev, false);\n\n\tret = rtw89_hci_poll_txdma_ch(rtwdev);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to poll txdma ch idle pcie\\n\");\n\t\treturn ret;\n\t}\n\n\tret = rtw89_wow_config_mac(rtwdev, true);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to config mac\\n\");\n\t\treturn ret;\n\t}\n\n\trtw89_wow_set_rx_filter(rtwdev, false);\n\trtw89_hci_reset(rtwdev);\n\n\treturn 0;\n}\n\nstatic int rtw89_wow_disable_trx_pre(struct rtw89_dev *rtwdev)\n{\n\tint ret;\n\n\trtw89_hci_clr_idx_all(rtwdev);\n\n\tret = rtw89_hci_rst_bdram(rtwdev);\n\tif (ret) {\n\t\trtw89_warn(rtwdev, \"reset bdram busy\\n\");\n\t\treturn ret;\n\t}\n\n\trtw89_hci_ctrl_trxhci(rtwdev, true);\n\trtw89_hci_ctrl_txdma_ch(rtwdev, true);\n\n\tret = rtw89_wow_config_mac(rtwdev, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to config mac\\n\");\n\t\treturn ret;\n\t}\n\trtw89_hci_enable_intr(rtwdev);\n\n\treturn 0;\n}\n\nstatic int rtw89_wow_disable_trx_post(struct rtw89_dev *rtwdev)\n{\n\tint ret;\n\n\tret = rtw89_mac_cfg_ppdu_status(rtwdev, RTW89_MAC_0, true);\n\tif (ret)\n\t\trtw89_err(rtwdev, \"cfg ppdu status\\n\");\n\n\treturn ret;\n}\n\nstatic int rtw89_wow_fw_start(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_wow_param *rtw_wow = &rtwdev->wow;\n\tstruct rtw89_vif *rtwvif = (struct rtw89_vif *)rtw_wow->wow_vif->drv_priv;\n\tint ret;\n\n\trtw89_wow_pattern_write(rtwdev);\n\n\tret = rtw89_fw_h2c_keep_alive(rtwdev, rtwvif, true);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"wow: failed to enable keep alive\\n\");\n\t\treturn ret;\n\t}\n\n\tret = rtw89_fw_h2c_disconnect_detect(rtwdev, rtwvif, true);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"wow: failed to enable disconnect detect\\n\");\n\t\tgoto out;\n\t}\n\n\tret = rtw89_wow_cfg_wake(rtwdev, true);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"wow: failed to config wake\\n\");\n\t\tgoto out;\n\t}\n\n\tret = rtw89_wow_check_fw_status(rtwdev, true);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"wow: failed to check enable fw ready\\n\");\n\t\tgoto out;\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic int rtw89_wow_fw_stop(struct rtw89_dev *rtwdev)\n{\n\tstruct rtw89_wow_param *rtw_wow = &rtwdev->wow;\n\tstruct rtw89_vif *rtwvif = (struct rtw89_vif *)rtw_wow->wow_vif->drv_priv;\n\tint ret;\n\n\trtw89_wow_pattern_clear(rtwdev);\n\n\tret = rtw89_fw_h2c_keep_alive(rtwdev, rtwvif, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"wow: failed to disable keep alive\\n\");\n\t\tgoto out;\n\t}\n\n\tret = rtw89_fw_h2c_disconnect_detect(rtwdev, rtwvif, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"wow: failed to disable disconnect detect\\n\");\n\t\tgoto out;\n\t}\n\n\tret = rtw89_wow_cfg_wake(rtwdev, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"wow: failed to disable config wake\\n\");\n\t\tgoto out;\n\t}\n\n\trtw89_fw_release_general_pkt_list(rtwdev, true);\n\n\tret = rtw89_wow_check_fw_status(rtwdev, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"wow: failed to check disable fw ready\\n\");\n\t\tgoto out;\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic int rtw89_wow_enable(struct rtw89_dev *rtwdev)\n{\n\tint ret;\n\n\tset_bit(RTW89_FLAG_WOWLAN, rtwdev->flags);\n\n\tret = rtw89_wow_enable_trx_pre(rtwdev);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"wow: failed to enable trx_pre\\n\");\n\t\tgoto out;\n\t}\n\n\trtw89_fw_release_general_pkt_list(rtwdev, true);\n\n\tret = rtw89_wow_swap_fw(rtwdev, true);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"wow: failed to swap to wow fw\\n\");\n\t\tgoto out;\n\t}\n\n\tret = rtw89_wow_fw_start(rtwdev);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"wow: failed to let wow fw start\\n\");\n\t\tgoto out;\n\t}\n\n\trtw89_wow_enter_lps(rtwdev);\n\n\tret = rtw89_wow_enable_trx_post(rtwdev);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"wow: failed to enable trx_post\\n\");\n\t\tgoto out;\n\t}\n\n\treturn 0;\n\nout:\n\tclear_bit(RTW89_FLAG_WOWLAN, rtwdev->flags);\n\treturn ret;\n}\n\nstatic int rtw89_wow_disable(struct rtw89_dev *rtwdev)\n{\n\tint ret;\n\n\tret = rtw89_wow_disable_trx_pre(rtwdev);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"wow: failed to disable trx_pre\\n\");\n\t\tgoto out;\n\t}\n\n\trtw89_wow_leave_lps(rtwdev);\n\n\tret = rtw89_wow_fw_stop(rtwdev);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"wow: failed to swap to normal fw\\n\");\n\t\tgoto out;\n\t}\n\n\tret = rtw89_wow_swap_fw(rtwdev, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"wow: failed to disable trx_post\\n\");\n\t\tgoto out;\n\t}\n\n\tret = rtw89_wow_disable_trx_post(rtwdev);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"wow: failed to disable trx_pre\\n\");\n\t\tgoto out;\n\t}\n\nout:\n\tclear_bit(RTW89_FLAG_WOWLAN, rtwdev->flags);\n\treturn ret;\n}\n\nint rtw89_wow_resume(struct rtw89_dev *rtwdev)\n{\n\tint ret;\n\n\tif (!test_bit(RTW89_FLAG_WOWLAN, rtwdev->flags)) {\n\t\trtw89_err(rtwdev, \"wow is not enabled\\n\");\n\t\tret = -EPERM;\n\t\tgoto out;\n\t}\n\n\tif (!rtw89_mac_get_power_state(rtwdev)) {\n\t\trtw89_err(rtwdev, \"chip is no power when resume\\n\");\n\t\tret = -EPERM;\n\t\tgoto out;\n\t}\n\n\trtw89_wow_leave_deep_ps(rtwdev);\n\n\trtw89_wow_show_wakeup_reason(rtwdev);\n\n\tret = rtw89_wow_disable(rtwdev);\n\tif (ret)\n\t\trtw89_err(rtwdev, \"failed to disable wow\\n\");\n\nout:\n\trtw89_wow_clear_wakeups(rtwdev);\n\treturn ret;\n}\n\nint rtw89_wow_suspend(struct rtw89_dev *rtwdev, struct cfg80211_wowlan *wowlan)\n{\n\tint ret;\n\n\tret = rtw89_wow_set_wakeups(rtwdev, wowlan);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to set wakeup event\\n\");\n\t\treturn ret;\n\t}\n\n\trtw89_wow_leave_lps(rtwdev);\n\n\tret = rtw89_wow_enable(rtwdev);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to enable wow\\n\");\n\t\treturn ret;\n\t}\n\n\trtw89_wow_enter_deep_ps(rtwdev);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}