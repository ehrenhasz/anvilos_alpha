{
  "module_name": "cam.c",
  "hash_id": "f77c9927ef8629879698a298728accd15b499e560c7fb5d1bea7e89f1e36a763",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtw89/cam.c",
  "human_readable_source": "\n \n\n#include \"cam.h\"\n#include \"debug.h\"\n#include \"fw.h\"\n#include \"mac.h\"\n\nstatic struct sk_buff *\nrtw89_cam_get_sec_key_cmd(struct rtw89_dev *rtwdev,\n\t\t\t  struct rtw89_sec_cam_entry *sec_cam,\n\t\t\t  bool ext_key)\n{\n\tstruct sk_buff *skb;\n\tu32 cmd_len = H2C_SEC_CAM_LEN;\n\tu32 key32[4];\n\tu8 *cmd;\n\tint i, j;\n\n\tskb = rtw89_fw_h2c_alloc_skb_with_hdr(rtwdev, cmd_len);\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_put_zero(skb, cmd_len);\n\n\tfor (i = 0; i < 4; i++) {\n\t\tj = i * 4;\n\t\tj += ext_key ? 16 : 0;\n\t\tkey32[i] = FIELD_PREP(GENMASK(7, 0), sec_cam->key[j + 0]) |\n\t\t\t   FIELD_PREP(GENMASK(15, 8), sec_cam->key[j + 1]) |\n\t\t\t   FIELD_PREP(GENMASK(23, 16), sec_cam->key[j + 2]) |\n\t\t\t   FIELD_PREP(GENMASK(31, 24), sec_cam->key[j + 3]);\n\t}\n\n\tcmd = skb->data;\n\tRTW89_SET_FWCMD_SEC_IDX(cmd, sec_cam->sec_cam_idx + (ext_key ? 1 : 0));\n\tRTW89_SET_FWCMD_SEC_OFFSET(cmd, sec_cam->offset);\n\tRTW89_SET_FWCMD_SEC_LEN(cmd, sec_cam->len);\n\tRTW89_SET_FWCMD_SEC_TYPE(cmd, sec_cam->type);\n\tRTW89_SET_FWCMD_SEC_EXT_KEY(cmd, ext_key);\n\tRTW89_SET_FWCMD_SEC_SPP_MODE(cmd, sec_cam->spp_mode);\n\tRTW89_SET_FWCMD_SEC_KEY0(cmd, key32[0]);\n\tRTW89_SET_FWCMD_SEC_KEY1(cmd, key32[1]);\n\tRTW89_SET_FWCMD_SEC_KEY2(cmd, key32[2]);\n\tRTW89_SET_FWCMD_SEC_KEY3(cmd, key32[3]);\n\n\treturn skb;\n}\n\nstatic int rtw89_cam_send_sec_key_cmd(struct rtw89_dev *rtwdev,\n\t\t\t\t      struct rtw89_sec_cam_entry *sec_cam)\n{\n\tstruct sk_buff *skb, *ext_skb;\n\tint ret;\n\n\tskb = rtw89_cam_get_sec_key_cmd(rtwdev, sec_cam, false);\n\tif (!skb) {\n\t\trtw89_err(rtwdev, \"failed to get sec key command\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, skb,\n\t\t\t      FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_MAC,\n\t\t\t      H2C_CL_MAC_SEC_CAM,\n\t\t\t      H2C_FUNC_MAC_SEC_UPD, 1, 0,\n\t\t\t      H2C_SEC_CAM_LEN);\n\tret = rtw89_h2c_tx(rtwdev, skb, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to send sec key h2c: %d\\n\", ret);\n\t\tdev_kfree_skb(skb);\n\t\treturn ret;\n\t}\n\n\tif (!sec_cam->ext_key)\n\t\treturn 0;\n\n\text_skb = rtw89_cam_get_sec_key_cmd(rtwdev, sec_cam, true);\n\tif (!ext_skb) {\n\t\trtw89_err(rtwdev, \"failed to get ext sec key command\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\trtw89_h2c_pkt_set_hdr(rtwdev, ext_skb,\n\t\t\t      FWCMD_TYPE_H2C,\n\t\t\t      H2C_CAT_MAC,\n\t\t\t      H2C_CL_MAC_SEC_CAM,\n\t\t\t      H2C_FUNC_MAC_SEC_UPD,\n\t\t\t      1, 0, H2C_SEC_CAM_LEN);\n\tret = rtw89_h2c_tx(rtwdev, ext_skb, false);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to send ext sec key h2c: %d\\n\", ret);\n\t\tdev_kfree_skb(ext_skb);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int rtw89_cam_get_avail_sec_cam(struct rtw89_dev *rtwdev,\n\t\t\t\t       u8 *sec_cam_idx, bool ext_key)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tstruct rtw89_cam_info *cam_info = &rtwdev->cam_info;\n\tu8 sec_cam_num = chip->scam_num;\n\tu8 idx = 0;\n\n\tif (!ext_key) {\n\t\tidx = find_first_zero_bit(cam_info->sec_cam_map, sec_cam_num);\n\t\tif (idx >= sec_cam_num)\n\t\t\treturn -EBUSY;\n\n\t\tset_bit(idx, cam_info->sec_cam_map);\n\t\t*sec_cam_idx = idx;\n\n\t\treturn 0;\n\t}\n\nagain:\n\tidx = find_next_zero_bit(cam_info->sec_cam_map, sec_cam_num, idx);\n\tif (idx >= sec_cam_num - 1)\n\t\treturn -EBUSY;\n\t \n\tif (test_bit(idx + 1, cam_info->sec_cam_map)) {\n\t\tidx++;\n\t\tgoto again;\n\t}\n\n\tset_bit(idx, cam_info->sec_cam_map);\n\tset_bit(idx + 1, cam_info->sec_cam_map);\n\t*sec_cam_idx = idx;\n\n\treturn 0;\n}\n\nstatic int rtw89_cam_get_addr_cam_key_idx(struct rtw89_addr_cam_entry *addr_cam,\n\t\t\t\t\t  struct rtw89_sec_cam_entry *sec_cam,\n\t\t\t\t\t  struct ieee80211_key_conf *key,\n\t\t\t\t\t  u8 *key_idx)\n{\n\tu8 idx;\n\n\t \n\tswitch (addr_cam->sec_ent_mode) {\n\tcase RTW89_ADDR_CAM_SEC_NONE:\n\t\treturn -EINVAL;\n\tcase RTW89_ADDR_CAM_SEC_ALL_UNI:\n\t\tif (!(key->flags & IEEE80211_KEY_FLAG_PAIRWISE))\n\t\t\treturn -EINVAL;\n\t\tidx = find_first_zero_bit(addr_cam->sec_cam_map,\n\t\t\t\t\t  RTW89_SEC_CAM_IN_ADDR_CAM);\n\t\tif (idx >= RTW89_SEC_CAM_IN_ADDR_CAM)\n\t\t\treturn -EBUSY;\n\t\t*key_idx = idx;\n\t\tbreak;\n\tcase RTW89_ADDR_CAM_SEC_NORMAL:\n\t\tif (sec_cam->type == RTW89_SEC_KEY_TYPE_BIP_CCMP128) {\n\t\t\tidx = find_next_zero_bit(addr_cam->sec_cam_map,\n\t\t\t\t\t\t RTW89_SEC_CAM_IN_ADDR_CAM, 5);\n\t\t\tif (idx > 6)\n\t\t\t\treturn -EBUSY;\n\t\t\t*key_idx = idx;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (key->flags & IEEE80211_KEY_FLAG_PAIRWISE) {\n\t\t\tidx = find_next_zero_bit(addr_cam->sec_cam_map,\n\t\t\t\t\t\t RTW89_SEC_CAM_IN_ADDR_CAM, 0);\n\t\t\tif (idx > 1)\n\t\t\t\treturn -EBUSY;\n\t\t\t*key_idx = idx;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tidx = find_next_zero_bit(addr_cam->sec_cam_map,\n\t\t\t\t\t RTW89_SEC_CAM_IN_ADDR_CAM, 2);\n\t\tif (idx > 4)\n\t\t\treturn -EBUSY;\n\t\t*key_idx = idx;\n\t\tbreak;\n\tcase RTW89_ADDR_CAM_SEC_4GROUP:\n\t\tif (sec_cam->type == RTW89_SEC_KEY_TYPE_BIP_CCMP128) {\n\t\t\tif (test_bit(6, addr_cam->sec_cam_map))\n\t\t\t\treturn -EINVAL;\n\t\t\t*key_idx = 6;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (key->flags & IEEE80211_KEY_FLAG_PAIRWISE) {\n\t\t\tidx = find_next_zero_bit(addr_cam->sec_cam_map,\n\t\t\t\t\t\t RTW89_SEC_CAM_IN_ADDR_CAM, 0);\n\t\t\tif (idx > 1)\n\t\t\t\treturn -EBUSY;\n\t\t\t*key_idx = idx;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tidx = find_next_zero_bit(addr_cam->sec_cam_map,\n\t\t\t\t\t RTW89_SEC_CAM_IN_ADDR_CAM, 2);\n\t\tif (idx > 5)\n\t\t\treturn -EBUSY;\n\t\t*key_idx = idx;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int rtw89_cam_attach_sec_cam(struct rtw89_dev *rtwdev,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct ieee80211_sta *sta,\n\t\t\t\t    struct ieee80211_key_conf *key,\n\t\t\t\t    struct rtw89_sec_cam_entry *sec_cam)\n{\n\tstruct rtw89_sta *rtwsta = sta_to_rtwsta_safe(sta);\n\tstruct rtw89_vif *rtwvif;\n\tstruct rtw89_addr_cam_entry *addr_cam;\n\tu8 key_idx = 0;\n\tint ret;\n\n\tif (!vif) {\n\t\trtw89_err(rtwdev, \"No iface for adding sec cam\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trtwvif = (struct rtw89_vif *)vif->drv_priv;\n\taddr_cam = rtw89_get_addr_cam_of(rtwvif, rtwsta);\n\tret = rtw89_cam_get_addr_cam_key_idx(addr_cam, sec_cam, key, &key_idx);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to get addr cam key idx %d, %d\\n\",\n\t\t\t  addr_cam->sec_ent_mode, sec_cam->type);\n\t\treturn ret;\n\t}\n\n\tkey->hw_key_idx = key_idx;\n\taddr_cam->sec_ent_keyid[key_idx] = key->keyidx;\n\taddr_cam->sec_ent[key_idx] = sec_cam->sec_cam_idx;\n\taddr_cam->sec_entries[key_idx] = sec_cam;\n\tset_bit(key_idx, addr_cam->sec_cam_map);\n\tret = rtw89_chip_h2c_dctl_sec_cam(rtwdev, rtwvif, rtwsta);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to update dctl cam sec entry: %d\\n\",\n\t\t\t  ret);\n\t\treturn ret;\n\t}\n\tret = rtw89_fw_h2c_cam(rtwdev, rtwvif, rtwsta, NULL);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to update addr cam sec entry: %d\\n\",\n\t\t\t  ret);\n\t\tclear_bit(key_idx, addr_cam->sec_cam_map);\n\t\taddr_cam->sec_entries[key_idx] = NULL;\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int rtw89_cam_sec_key_install(struct rtw89_dev *rtwdev,\n\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t     struct ieee80211_sta *sta,\n\t\t\t\t     struct ieee80211_key_conf *key,\n\t\t\t\t     u8 hw_key_type, bool ext_key)\n{\n\tstruct rtw89_sec_cam_entry *sec_cam = NULL;\n\tstruct rtw89_cam_info *cam_info = &rtwdev->cam_info;\n\tu8 sec_cam_idx;\n\tint ret;\n\n\t \n\tif (key->keylen > 32) {\n\t\trtw89_err(rtwdev, \"invalid sec key length %d\\n\", key->keylen);\n\t\treturn -EINVAL;\n\t}\n\n\tret = rtw89_cam_get_avail_sec_cam(rtwdev, &sec_cam_idx, ext_key);\n\tif (ret) {\n\t\trtw89_warn(rtwdev, \"no available sec cam: %d ext: %d\\n\",\n\t\t\t   ret, ext_key);\n\t\treturn ret;\n\t}\n\n\tsec_cam = kzalloc(sizeof(*sec_cam), GFP_KERNEL);\n\tif (!sec_cam) {\n\t\tret = -ENOMEM;\n\t\tgoto err_release_cam;\n\t}\n\n\tsec_cam->sec_cam_idx = sec_cam_idx;\n\tsec_cam->type = hw_key_type;\n\tsec_cam->len = RTW89_SEC_CAM_LEN;\n\tsec_cam->ext_key = ext_key;\n\tmemcpy(sec_cam->key, key->key, key->keylen);\n\tret = rtw89_cam_send_sec_key_cmd(rtwdev, sec_cam);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to send sec key cmd: %d\\n\", ret);\n\t\tgoto err_release_cam;\n\t}\n\n\t \n\tret = rtw89_cam_attach_sec_cam(rtwdev, vif, sta, key, sec_cam);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to attach sec cam: %d\\n\", ret);\n\t\tgoto err_release_cam;\n\t}\n\n\treturn 0;\n\nerr_release_cam:\n\tkfree(sec_cam);\n\tclear_bit(sec_cam_idx, cam_info->sec_cam_map);\n\tif (ext_key)\n\t\tclear_bit(sec_cam_idx + 1, cam_info->sec_cam_map);\n\n\treturn ret;\n}\n\nint rtw89_cam_sec_key_add(struct rtw89_dev *rtwdev,\n\t\t\t  struct ieee80211_vif *vif,\n\t\t\t  struct ieee80211_sta *sta,\n\t\t\t  struct ieee80211_key_conf *key)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tu8 hw_key_type;\n\tbool ext_key = false;\n\tint ret;\n\n\tswitch (key->cipher) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\thw_key_type = RTW89_SEC_KEY_TYPE_WEP40;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\thw_key_type = RTW89_SEC_KEY_TYPE_WEP104;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\thw_key_type = RTW89_SEC_KEY_TYPE_CCMP128;\n\t\tkey->flags |= IEEE80211_KEY_FLAG_SW_MGMT_TX;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP_256:\n\t\thw_key_type = RTW89_SEC_KEY_TYPE_CCMP256;\n\t\tkey->flags |= IEEE80211_KEY_FLAG_SW_MGMT_TX;\n\t\text_key = true;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_GCMP:\n\t\thw_key_type = RTW89_SEC_KEY_TYPE_GCMP128;\n\t\tkey->flags |= IEEE80211_KEY_FLAG_SW_MGMT_TX;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_GCMP_256:\n\t\thw_key_type = RTW89_SEC_KEY_TYPE_GCMP256;\n\t\tkey->flags |= IEEE80211_KEY_FLAG_SW_MGMT_TX;\n\t\text_key = true;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!chip->hw_sec_hdr)\n\t\tkey->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;\n\n\tret = rtw89_cam_sec_key_install(rtwdev, vif, sta, key, hw_key_type,\n\t\t\t\t\text_key);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to install key type %d ext %d: %d\\n\",\n\t\t\t  hw_key_type, ext_key, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint rtw89_cam_sec_key_del(struct rtw89_dev *rtwdev,\n\t\t\t  struct ieee80211_vif *vif,\n\t\t\t  struct ieee80211_sta *sta,\n\t\t\t  struct ieee80211_key_conf *key,\n\t\t\t  bool inform_fw)\n{\n\tstruct rtw89_sta *rtwsta = sta_to_rtwsta_safe(sta);\n\tstruct rtw89_cam_info *cam_info = &rtwdev->cam_info;\n\tstruct rtw89_vif *rtwvif;\n\tstruct rtw89_addr_cam_entry *addr_cam;\n\tstruct rtw89_sec_cam_entry *sec_cam;\n\tu8 key_idx = key->hw_key_idx;\n\tu8 sec_cam_idx;\n\tint ret = 0;\n\n\tif (!vif) {\n\t\trtw89_err(rtwdev, \"No iface for deleting sec cam\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trtwvif = (struct rtw89_vif *)vif->drv_priv;\n\taddr_cam = rtw89_get_addr_cam_of(rtwvif, rtwsta);\n\tsec_cam = addr_cam->sec_entries[key_idx];\n\tif (!sec_cam)\n\t\treturn -EINVAL;\n\n\t \n\tclear_bit(key_idx, addr_cam->sec_cam_map);\n\taddr_cam->sec_entries[key_idx] = NULL;\n\tif (inform_fw) {\n\t\tret = rtw89_chip_h2c_dctl_sec_cam(rtwdev, rtwvif, rtwsta);\n\t\tif (ret)\n\t\t\trtw89_err(rtwdev, \"failed to update dctl cam del key: %d\\n\", ret);\n\t\tret = rtw89_fw_h2c_cam(rtwdev, rtwvif, rtwsta, NULL);\n\t\tif (ret)\n\t\t\trtw89_err(rtwdev, \"failed to update cam del key: %d\\n\", ret);\n\t}\n\n\t \n\tsec_cam_idx = sec_cam->sec_cam_idx;\n\tclear_bit(sec_cam_idx, cam_info->sec_cam_map);\n\tif (sec_cam->ext_key)\n\t\tclear_bit(sec_cam_idx + 1, cam_info->sec_cam_map);\n\n\tkfree(sec_cam);\n\n\treturn ret;\n}\n\nstatic void rtw89_cam_reset_key_iter(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t     struct ieee80211_sta *sta,\n\t\t\t\t     struct ieee80211_key_conf *key,\n\t\t\t\t     void *data)\n{\n\tstruct rtw89_dev *rtwdev = (struct rtw89_dev *)data;\n\n\trtw89_cam_sec_key_del(rtwdev, vif, sta, key, false);\n}\n\nvoid rtw89_cam_deinit_addr_cam(struct rtw89_dev *rtwdev,\n\t\t\t       struct rtw89_addr_cam_entry *addr_cam)\n{\n\tstruct rtw89_cam_info *cam_info = &rtwdev->cam_info;\n\n\taddr_cam->valid = false;\n\tclear_bit(addr_cam->addr_cam_idx, cam_info->addr_cam_map);\n}\n\nvoid rtw89_cam_deinit_bssid_cam(struct rtw89_dev *rtwdev,\n\t\t\t\tstruct rtw89_bssid_cam_entry *bssid_cam)\n{\n\tstruct rtw89_cam_info *cam_info = &rtwdev->cam_info;\n\n\tbssid_cam->valid = false;\n\tclear_bit(bssid_cam->bssid_cam_idx, cam_info->bssid_cam_map);\n}\n\nvoid rtw89_cam_deinit(struct rtw89_dev *rtwdev, struct rtw89_vif *rtwvif)\n{\n\tstruct rtw89_addr_cam_entry *addr_cam = &rtwvif->addr_cam;\n\tstruct rtw89_bssid_cam_entry *bssid_cam = &rtwvif->bssid_cam;\n\n\trtw89_cam_deinit_addr_cam(rtwdev, addr_cam);\n\trtw89_cam_deinit_bssid_cam(rtwdev, bssid_cam);\n}\n\nvoid rtw89_cam_reset_keys(struct rtw89_dev *rtwdev)\n{\n\trcu_read_lock();\n\tieee80211_iter_keys_rcu(rtwdev->hw, NULL, rtw89_cam_reset_key_iter, rtwdev);\n\trcu_read_unlock();\n}\n\nstatic int rtw89_cam_get_avail_addr_cam(struct rtw89_dev *rtwdev,\n\t\t\t\t\tu8 *addr_cam_idx)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tstruct rtw89_cam_info *cam_info = &rtwdev->cam_info;\n\tu8 addr_cam_num = chip->acam_num;\n\tu8 idx;\n\n\tidx = find_first_zero_bit(cam_info->addr_cam_map, addr_cam_num);\n\tif (idx >= addr_cam_num)\n\t\treturn -EBUSY;\n\n\tset_bit(idx, cam_info->addr_cam_map);\n\t*addr_cam_idx = idx;\n\n\treturn 0;\n}\n\nint rtw89_cam_init_addr_cam(struct rtw89_dev *rtwdev,\n\t\t\t    struct rtw89_addr_cam_entry *addr_cam,\n\t\t\t    const struct rtw89_bssid_cam_entry *bssid_cam)\n{\n\tu8 addr_cam_idx;\n\tint i;\n\tint ret;\n\n\tif (unlikely(addr_cam->valid)) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_FW,\n\t\t\t    \"addr cam is already valid; skip init\\n\");\n\t\treturn 0;\n\t}\n\n\tret = rtw89_cam_get_avail_addr_cam(rtwdev, &addr_cam_idx);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to get available addr cam\\n\");\n\t\treturn ret;\n\t}\n\n\taddr_cam->addr_cam_idx = addr_cam_idx;\n\taddr_cam->len = ADDR_CAM_ENT_SIZE;\n\taddr_cam->offset = 0;\n\taddr_cam->valid = true;\n\taddr_cam->addr_mask = 0;\n\taddr_cam->mask_sel = RTW89_NO_MSK;\n\taddr_cam->sec_ent_mode = RTW89_ADDR_CAM_SEC_NORMAL;\n\tbitmap_zero(addr_cam->sec_cam_map, RTW89_SEC_CAM_IN_ADDR_CAM);\n\n\tfor (i = 0; i < RTW89_SEC_CAM_IN_ADDR_CAM; i++) {\n\t\taddr_cam->sec_ent_keyid[i] = 0;\n\t\taddr_cam->sec_ent[i] = 0;\n\t}\n\n\t \n\taddr_cam->bssid_cam_idx = bssid_cam->bssid_cam_idx;\n\n\treturn 0;\n}\n\nstatic int rtw89_cam_get_avail_bssid_cam(struct rtw89_dev *rtwdev,\n\t\t\t\t\t u8 *bssid_cam_idx)\n{\n\tconst struct rtw89_chip_info *chip = rtwdev->chip;\n\tstruct rtw89_cam_info *cam_info = &rtwdev->cam_info;\n\tu8 bssid_cam_num = chip->bcam_num;\n\tu8 idx;\n\n\tidx = find_first_zero_bit(cam_info->bssid_cam_map, bssid_cam_num);\n\tif (idx >= bssid_cam_num)\n\t\treturn -EBUSY;\n\n\tset_bit(idx, cam_info->bssid_cam_map);\n\t*bssid_cam_idx = idx;\n\n\treturn 0;\n}\n\nint rtw89_cam_init_bssid_cam(struct rtw89_dev *rtwdev,\n\t\t\t     struct rtw89_vif *rtwvif,\n\t\t\t     struct rtw89_bssid_cam_entry *bssid_cam,\n\t\t\t     const u8 *bssid)\n{\n\tu8 bssid_cam_idx;\n\tint ret;\n\n\tif (unlikely(bssid_cam->valid)) {\n\t\trtw89_debug(rtwdev, RTW89_DBG_FW,\n\t\t\t    \"bssid cam is already valid; skip init\\n\");\n\t\treturn 0;\n\t}\n\n\tret = rtw89_cam_get_avail_bssid_cam(rtwdev, &bssid_cam_idx);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to get available bssid cam\\n\");\n\t\treturn ret;\n\t}\n\n\tbssid_cam->bssid_cam_idx = bssid_cam_idx;\n\tbssid_cam->phy_idx = rtwvif->phy_idx;\n\tbssid_cam->len = BSSID_CAM_ENT_SIZE;\n\tbssid_cam->offset = 0;\n\tbssid_cam->valid = true;\n\tether_addr_copy(bssid_cam->bssid, bssid);\n\n\treturn 0;\n}\n\nvoid rtw89_cam_bssid_changed(struct rtw89_dev *rtwdev, struct rtw89_vif *rtwvif)\n{\n\tstruct rtw89_bssid_cam_entry *bssid_cam = &rtwvif->bssid_cam;\n\n\tether_addr_copy(bssid_cam->bssid, rtwvif->bssid);\n}\n\nint rtw89_cam_init(struct rtw89_dev *rtwdev, struct rtw89_vif *rtwvif)\n{\n\tstruct rtw89_addr_cam_entry *addr_cam = &rtwvif->addr_cam;\n\tstruct rtw89_bssid_cam_entry *bssid_cam = &rtwvif->bssid_cam;\n\tint ret;\n\n\tret = rtw89_cam_init_bssid_cam(rtwdev, rtwvif, bssid_cam, rtwvif->bssid);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to init bssid cam\\n\");\n\t\treturn ret;\n\t}\n\n\tret = rtw89_cam_init_addr_cam(rtwdev, addr_cam, bssid_cam);\n\tif (ret) {\n\t\trtw89_err(rtwdev, \"failed to init addr cam\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint rtw89_cam_fill_bssid_cam_info(struct rtw89_dev *rtwdev,\n\t\t\t\t  struct rtw89_vif *rtwvif,\n\t\t\t\t  struct rtw89_sta *rtwsta, u8 *cmd)\n{\n\tstruct ieee80211_vif *vif = rtwvif_to_vif(rtwvif);\n\tstruct rtw89_bssid_cam_entry *bssid_cam = rtw89_get_bssid_cam_of(rtwvif, rtwsta);\n\tu8 bss_color = vif->bss_conf.he_bss_color.color;\n\tu8 bss_mask;\n\n\tif (vif->bss_conf.nontransmitted)\n\t\tbss_mask = RTW89_BSSID_MATCH_5_BYTES;\n\telse\n\t\tbss_mask = RTW89_BSSID_MATCH_ALL;\n\n\tFWCMD_SET_ADDR_BSSID_IDX(cmd, bssid_cam->bssid_cam_idx);\n\tFWCMD_SET_ADDR_BSSID_OFFSET(cmd, bssid_cam->offset);\n\tFWCMD_SET_ADDR_BSSID_LEN(cmd, bssid_cam->len);\n\tFWCMD_SET_ADDR_BSSID_VALID(cmd, bssid_cam->valid);\n\tFWCMD_SET_ADDR_BSSID_MASK(cmd, bss_mask);\n\tFWCMD_SET_ADDR_BSSID_BB_SEL(cmd, bssid_cam->phy_idx);\n\tFWCMD_SET_ADDR_BSSID_BSS_COLOR(cmd, bss_color);\n\n\tFWCMD_SET_ADDR_BSSID_BSSID0(cmd, bssid_cam->bssid[0]);\n\tFWCMD_SET_ADDR_BSSID_BSSID1(cmd, bssid_cam->bssid[1]);\n\tFWCMD_SET_ADDR_BSSID_BSSID2(cmd, bssid_cam->bssid[2]);\n\tFWCMD_SET_ADDR_BSSID_BSSID3(cmd, bssid_cam->bssid[3]);\n\tFWCMD_SET_ADDR_BSSID_BSSID4(cmd, bssid_cam->bssid[4]);\n\tFWCMD_SET_ADDR_BSSID_BSSID5(cmd, bssid_cam->bssid[5]);\n\n\treturn 0;\n}\n\nstatic u8 rtw89_cam_addr_hash(u8 start, const u8 *addr)\n{\n\tu8 hash = 0;\n\tu8 i;\n\n\tfor (i = start; i < ETH_ALEN; i++)\n\t\thash ^= addr[i];\n\n\treturn hash;\n}\n\nvoid rtw89_cam_fill_addr_cam_info(struct rtw89_dev *rtwdev,\n\t\t\t\t  struct rtw89_vif *rtwvif,\n\t\t\t\t  struct rtw89_sta *rtwsta,\n\t\t\t\t  const u8 *scan_mac_addr,\n\t\t\t\t  u8 *cmd)\n{\n\tstruct ieee80211_vif *vif = rtwvif_to_vif(rtwvif);\n\tstruct rtw89_addr_cam_entry *addr_cam = rtw89_get_addr_cam_of(rtwvif, rtwsta);\n\tstruct ieee80211_sta *sta = rtwsta_to_sta_safe(rtwsta);\n\tconst u8 *sma = scan_mac_addr ? scan_mac_addr : rtwvif->mac_addr;\n\tu8 sma_hash, tma_hash, addr_msk_start;\n\tu8 sma_start = 0;\n\tu8 tma_start = 0;\n\tu8 *tma = sta ? sta->addr : rtwvif->bssid;\n\n\tif (addr_cam->addr_mask != 0) {\n\t\taddr_msk_start = __ffs(addr_cam->addr_mask);\n\t\tif (addr_cam->mask_sel == RTW89_SMA)\n\t\t\tsma_start = addr_msk_start;\n\t\telse if (addr_cam->mask_sel == RTW89_TMA)\n\t\t\ttma_start = addr_msk_start;\n\t}\n\tsma_hash = rtw89_cam_addr_hash(sma_start, sma);\n\ttma_hash = rtw89_cam_addr_hash(tma_start, tma);\n\n\tFWCMD_SET_ADDR_IDX(cmd, addr_cam->addr_cam_idx);\n\tFWCMD_SET_ADDR_OFFSET(cmd, addr_cam->offset);\n\tFWCMD_SET_ADDR_LEN(cmd, addr_cam->len);\n\n\tFWCMD_SET_ADDR_VALID(cmd, addr_cam->valid);\n\tFWCMD_SET_ADDR_NET_TYPE(cmd, rtwvif->net_type);\n\tFWCMD_SET_ADDR_BCN_HIT_COND(cmd, rtwvif->bcn_hit_cond);\n\tFWCMD_SET_ADDR_HIT_RULE(cmd, rtwvif->hit_rule);\n\tFWCMD_SET_ADDR_BB_SEL(cmd, rtwvif->phy_idx);\n\tFWCMD_SET_ADDR_ADDR_MASK(cmd, addr_cam->addr_mask);\n\tFWCMD_SET_ADDR_MASK_SEL(cmd, addr_cam->mask_sel);\n\tFWCMD_SET_ADDR_SMA_HASH(cmd, sma_hash);\n\tFWCMD_SET_ADDR_TMA_HASH(cmd, tma_hash);\n\n\tFWCMD_SET_ADDR_BSSID_CAM_IDX(cmd, addr_cam->bssid_cam_idx);\n\n\tFWCMD_SET_ADDR_SMA0(cmd, sma[0]);\n\tFWCMD_SET_ADDR_SMA1(cmd, sma[1]);\n\tFWCMD_SET_ADDR_SMA2(cmd, sma[2]);\n\tFWCMD_SET_ADDR_SMA3(cmd, sma[3]);\n\tFWCMD_SET_ADDR_SMA4(cmd, sma[4]);\n\tFWCMD_SET_ADDR_SMA5(cmd, sma[5]);\n\n\tFWCMD_SET_ADDR_TMA0(cmd, tma[0]);\n\tFWCMD_SET_ADDR_TMA1(cmd, tma[1]);\n\tFWCMD_SET_ADDR_TMA2(cmd, tma[2]);\n\tFWCMD_SET_ADDR_TMA3(cmd, tma[3]);\n\tFWCMD_SET_ADDR_TMA4(cmd, tma[4]);\n\tFWCMD_SET_ADDR_TMA5(cmd, tma[5]);\n\n\tFWCMD_SET_ADDR_PORT_INT(cmd, rtwvif->port);\n\tFWCMD_SET_ADDR_TSF_SYNC(cmd, rtwvif->port);\n\tFWCMD_SET_ADDR_TF_TRS(cmd, rtwvif->trigger);\n\tFWCMD_SET_ADDR_LSIG_TXOP(cmd, rtwvif->lsig_txop);\n\tFWCMD_SET_ADDR_TGT_IND(cmd, rtwvif->tgt_ind);\n\tFWCMD_SET_ADDR_FRM_TGT_IND(cmd, rtwvif->frm_tgt_ind);\n\tFWCMD_SET_ADDR_MACID(cmd, rtwsta ? rtwsta->mac_id : rtwvif->mac_id);\n\tif (rtwvif->net_type == RTW89_NET_TYPE_INFRA)\n\t\tFWCMD_SET_ADDR_AID12(cmd, vif->cfg.aid & 0xfff);\n\telse if (rtwvif->net_type == RTW89_NET_TYPE_AP_MODE)\n\t\tFWCMD_SET_ADDR_AID12(cmd, sta ? sta->aid & 0xfff : 0);\n\tFWCMD_SET_ADDR_WOL_PATTERN(cmd, rtwvif->wowlan_pattern);\n\tFWCMD_SET_ADDR_WOL_UC(cmd, rtwvif->wowlan_uc);\n\tFWCMD_SET_ADDR_WOL_MAGIC(cmd, rtwvif->wowlan_magic);\n\tFWCMD_SET_ADDR_WAPI(cmd, addr_cam->wapi);\n\tFWCMD_SET_ADDR_SEC_ENT_MODE(cmd, addr_cam->sec_ent_mode);\n\tFWCMD_SET_ADDR_SEC_ENT0_KEYID(cmd, addr_cam->sec_ent_keyid[0]);\n\tFWCMD_SET_ADDR_SEC_ENT1_KEYID(cmd, addr_cam->sec_ent_keyid[1]);\n\tFWCMD_SET_ADDR_SEC_ENT2_KEYID(cmd, addr_cam->sec_ent_keyid[2]);\n\tFWCMD_SET_ADDR_SEC_ENT3_KEYID(cmd, addr_cam->sec_ent_keyid[3]);\n\tFWCMD_SET_ADDR_SEC_ENT4_KEYID(cmd, addr_cam->sec_ent_keyid[4]);\n\tFWCMD_SET_ADDR_SEC_ENT5_KEYID(cmd, addr_cam->sec_ent_keyid[5]);\n\tFWCMD_SET_ADDR_SEC_ENT6_KEYID(cmd, addr_cam->sec_ent_keyid[6]);\n\n\tFWCMD_SET_ADDR_SEC_ENT_VALID(cmd, addr_cam->sec_cam_map[0] & 0xff);\n\tFWCMD_SET_ADDR_SEC_ENT0(cmd, addr_cam->sec_ent[0]);\n\tFWCMD_SET_ADDR_SEC_ENT1(cmd, addr_cam->sec_ent[1]);\n\tFWCMD_SET_ADDR_SEC_ENT2(cmd, addr_cam->sec_ent[2]);\n\tFWCMD_SET_ADDR_SEC_ENT3(cmd, addr_cam->sec_ent[3]);\n\tFWCMD_SET_ADDR_SEC_ENT4(cmd, addr_cam->sec_ent[4]);\n\tFWCMD_SET_ADDR_SEC_ENT5(cmd, addr_cam->sec_ent[5]);\n\tFWCMD_SET_ADDR_SEC_ENT6(cmd, addr_cam->sec_ent[6]);\n}\n\nvoid rtw89_cam_fill_dctl_sec_cam_info_v1(struct rtw89_dev *rtwdev,\n\t\t\t\t\t struct rtw89_vif *rtwvif,\n\t\t\t\t\t struct rtw89_sta *rtwsta,\n\t\t\t\t\t u8 *cmd)\n{\n\tstruct rtw89_addr_cam_entry *addr_cam = rtw89_get_addr_cam_of(rtwvif, rtwsta);\n\n\tSET_DCTL_MACID_V1(cmd, rtwsta ? rtwsta->mac_id : rtwvif->mac_id);\n\tSET_DCTL_OPERATION_V1(cmd, 1);\n\n\tSET_DCTL_SEC_ENT0_KEYID_V1(cmd, addr_cam->sec_ent_keyid[0]);\n\tSET_DCTL_SEC_ENT1_KEYID_V1(cmd, addr_cam->sec_ent_keyid[1]);\n\tSET_DCTL_SEC_ENT2_KEYID_V1(cmd, addr_cam->sec_ent_keyid[2]);\n\tSET_DCTL_SEC_ENT3_KEYID_V1(cmd, addr_cam->sec_ent_keyid[3]);\n\tSET_DCTL_SEC_ENT4_KEYID_V1(cmd, addr_cam->sec_ent_keyid[4]);\n\tSET_DCTL_SEC_ENT5_KEYID_V1(cmd, addr_cam->sec_ent_keyid[5]);\n\tSET_DCTL_SEC_ENT6_KEYID_V1(cmd, addr_cam->sec_ent_keyid[6]);\n\n\tSET_DCTL_SEC_ENT_VALID_V1(cmd, addr_cam->sec_cam_map[0] & 0xff);\n\tSET_DCTL_SEC_ENT0_V1(cmd, addr_cam->sec_ent[0]);\n\tSET_DCTL_SEC_ENT1_V1(cmd, addr_cam->sec_ent[1]);\n\tSET_DCTL_SEC_ENT2_V1(cmd, addr_cam->sec_ent[2]);\n\tSET_DCTL_SEC_ENT3_V1(cmd, addr_cam->sec_ent[3]);\n\tSET_DCTL_SEC_ENT4_V1(cmd, addr_cam->sec_ent[4]);\n\tSET_DCTL_SEC_ENT5_V1(cmd, addr_cam->sec_ent[5]);\n\tSET_DCTL_SEC_ENT6_V1(cmd, addr_cam->sec_ent[6]);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}