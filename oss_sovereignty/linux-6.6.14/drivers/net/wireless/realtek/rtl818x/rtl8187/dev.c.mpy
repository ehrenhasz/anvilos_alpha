{
  "module_name": "dev.c",
  "hash_id": "6dfc42ec28317d75f9943b8c866769ee7e6871145bacb6ffbd8aa5c00ad12986",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtl818x/rtl8187/dev.c",
  "human_readable_source": "\n \n\n#include <linux/usb.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/etherdevice.h>\n#include <linux/eeprom_93cx6.h>\n#include <linux/module.h>\n#include <net/mac80211.h>\n\n#include \"rtl8187.h\"\n#include \"rtl8225.h\"\n#ifdef CONFIG_RTL8187_LEDS\n#include \"leds.h\"\n#endif\n#include \"rfkill.h\"\n\nMODULE_AUTHOR(\"Michael Wu <flamingice@sourmilk.net>\");\nMODULE_AUTHOR(\"Andrea Merello <andrea.merello@gmail.com>\");\nMODULE_AUTHOR(\"Herton Ronaldo Krzesinski <herton@mandriva.com.br>\");\nMODULE_AUTHOR(\"Hin-Tak Leung <htl10@users.sourceforge.net>\");\nMODULE_AUTHOR(\"Larry Finger <Larry.Finger@lwfinger.net>\");\nMODULE_DESCRIPTION(\"RTL8187/RTL8187B USB wireless driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic const struct usb_device_id rtl8187_table[] = {\n\t \n\t{USB_DEVICE(0x0b05, 0x171d), .driver_info = DEVICE_RTL8187},\n\t \n\t{USB_DEVICE(0x050d, 0x705e), .driver_info = DEVICE_RTL8187B},\n\t \n\t{USB_DEVICE(0x0bda, 0x8187), .driver_info = DEVICE_RTL8187},\n\t{USB_DEVICE(0x0bda, 0x8189), .driver_info = DEVICE_RTL8187B},\n\t{USB_DEVICE(0x0bda, 0x8197), .driver_info = DEVICE_RTL8187B},\n\t{USB_DEVICE(0x0bda, 0x8198), .driver_info = DEVICE_RTL8187B},\n\t \n\t{USB_DEVICE(0x0769, 0x11F2), .driver_info = DEVICE_RTL8187},\n\t \n\t{USB_DEVICE(0x0789, 0x010C), .driver_info = DEVICE_RTL8187},\n\t \n\t{USB_DEVICE(0x0846, 0x6100), .driver_info = DEVICE_RTL8187},\n\t{USB_DEVICE(0x0846, 0x6a00), .driver_info = DEVICE_RTL8187},\n\t{USB_DEVICE(0x0846, 0x4260), .driver_info = DEVICE_RTL8187B},\n\t \n\t{USB_DEVICE(0x03f0, 0xca02), .driver_info = DEVICE_RTL8187},\n\t \n\t{USB_DEVICE(0x0df6, 0x000d), .driver_info = DEVICE_RTL8187},\n\t{USB_DEVICE(0x0df6, 0x0028), .driver_info = DEVICE_RTL8187B},\n\t{USB_DEVICE(0x0df6, 0x0029), .driver_info = DEVICE_RTL8187B},\n\t \n\t{USB_DEVICE(0x114B, 0x0150), .driver_info = DEVICE_RTL8187},\n\t \n\t{USB_DEVICE(0x1371, 0x9401), .driver_info = DEVICE_RTL8187},\n\t \n\t{USB_DEVICE(0x13d1, 0xabe6), .driver_info = DEVICE_RTL8187},\n\t \n\t{USB_DEVICE(0x18E8, 0x6232), .driver_info = DEVICE_RTL8187},\n\t \n\t{USB_DEVICE(0x1b75, 0x8187), .driver_info = DEVICE_RTL8187},\n\t \n\t{USB_DEVICE(0x1737, 0x0073), .driver_info = DEVICE_RTL8187B},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(usb, rtl8187_table);\n\nstatic const struct ieee80211_rate rtl818x_rates[] = {\n\t{ .bitrate = 10, .hw_value = 0, },\n\t{ .bitrate = 20, .hw_value = 1, },\n\t{ .bitrate = 55, .hw_value = 2, },\n\t{ .bitrate = 110, .hw_value = 3, },\n\t{ .bitrate = 60, .hw_value = 4, },\n\t{ .bitrate = 90, .hw_value = 5, },\n\t{ .bitrate = 120, .hw_value = 6, },\n\t{ .bitrate = 180, .hw_value = 7, },\n\t{ .bitrate = 240, .hw_value = 8, },\n\t{ .bitrate = 360, .hw_value = 9, },\n\t{ .bitrate = 480, .hw_value = 10, },\n\t{ .bitrate = 540, .hw_value = 11, },\n};\n\nstatic const struct ieee80211_channel rtl818x_channels[] = {\n\t{ .center_freq = 2412 },\n\t{ .center_freq = 2417 },\n\t{ .center_freq = 2422 },\n\t{ .center_freq = 2427 },\n\t{ .center_freq = 2432 },\n\t{ .center_freq = 2437 },\n\t{ .center_freq = 2442 },\n\t{ .center_freq = 2447 },\n\t{ .center_freq = 2452 },\n\t{ .center_freq = 2457 },\n\t{ .center_freq = 2462 },\n\t{ .center_freq = 2467 },\n\t{ .center_freq = 2472 },\n\t{ .center_freq = 2484 },\n};\n\nstatic void rtl8187_iowrite_async_cb(struct urb *urb)\n{\n\tkfree(urb->context);\n}\n\nstatic void rtl8187_iowrite_async(struct rtl8187_priv *priv, __le16 addr,\n\t\t\t\t  void *data, u16 len)\n{\n\tstruct usb_ctrlrequest *dr;\n\tstruct urb *urb;\n\tstruct rtl8187_async_write_data {\n\t\tu8 data[4];\n\t\tstruct usb_ctrlrequest dr;\n\t} *buf;\n\tint rc;\n\n\tbuf = kmalloc(sizeof(*buf), GFP_ATOMIC);\n\tif (!buf)\n\t\treturn;\n\n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb) {\n\t\tkfree(buf);\n\t\treturn;\n\t}\n\n\tdr = &buf->dr;\n\n\tdr->bRequestType = RTL8187_REQT_WRITE;\n\tdr->bRequest = RTL8187_REQ_SET_REG;\n\tdr->wValue = addr;\n\tdr->wIndex = 0;\n\tdr->wLength = cpu_to_le16(len);\n\n\tmemcpy(buf, data, len);\n\n\tusb_fill_control_urb(urb, priv->udev, usb_sndctrlpipe(priv->udev, 0),\n\t\t\t     (unsigned char *)dr, buf, len,\n\t\t\t     rtl8187_iowrite_async_cb, buf);\n\tusb_anchor_urb(urb, &priv->anchored);\n\trc = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (rc < 0) {\n\t\tkfree(buf);\n\t\tusb_unanchor_urb(urb);\n\t}\n\tusb_free_urb(urb);\n}\n\nstatic inline void rtl818x_iowrite32_async(struct rtl8187_priv *priv,\n\t\t\t\t\t   __le32 *addr, u32 val)\n{\n\t__le32 buf = cpu_to_le32(val);\n\n\trtl8187_iowrite_async(priv, cpu_to_le16((unsigned long)addr),\n\t\t\t      &buf, sizeof(buf));\n}\n\nvoid rtl8187_write_phy(struct ieee80211_hw *dev, u8 addr, u32 data)\n{\n\tstruct rtl8187_priv *priv = dev->priv;\n\n\tdata <<= 8;\n\tdata |= addr | 0x80;\n\n\trtl818x_iowrite8(priv, &priv->map->PHY[3], (data >> 24) & 0xFF);\n\trtl818x_iowrite8(priv, &priv->map->PHY[2], (data >> 16) & 0xFF);\n\trtl818x_iowrite8(priv, &priv->map->PHY[1], (data >> 8) & 0xFF);\n\trtl818x_iowrite8(priv, &priv->map->PHY[0], data & 0xFF);\n}\n\nstatic void rtl8187_tx_cb(struct urb *urb)\n{\n\tstruct sk_buff *skb = (struct sk_buff *)urb->context;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hw *hw = info->rate_driver_data[0];\n\tstruct rtl8187_priv *priv = hw->priv;\n\n\tskb_pull(skb, priv->is_rtl8187b ? sizeof(struct rtl8187b_tx_hdr) :\n\t\t\t\t\t  sizeof(struct rtl8187_tx_hdr));\n\tieee80211_tx_info_clear_status(info);\n\n\tif (!(urb->status) && !(info->flags & IEEE80211_TX_CTL_NO_ACK)) {\n\t\tif (priv->is_rtl8187b) {\n\t\t\tskb_queue_tail(&priv->b_tx_status.queue, skb);\n\n\t\t\t \n\t\t\twhile (skb_queue_len(&priv->b_tx_status.queue) > 5) {\n\t\t\t\tstruct sk_buff *old_skb;\n\n\t\t\t\tdev_dbg(&priv->udev->dev,\n\t\t\t\t\t\"transmit status queue full\\n\");\n\n\t\t\t\told_skb = skb_dequeue(&priv->b_tx_status.queue);\n\t\t\t\tieee80211_tx_status_irqsafe(hw, old_skb);\n\t\t\t}\n\t\t\treturn;\n\t\t} else {\n\t\t\tinfo->flags |= IEEE80211_TX_STAT_ACK;\n\t\t}\n\t}\n\tif (priv->is_rtl8187b)\n\t\tieee80211_tx_status_irqsafe(hw, skb);\n\telse {\n\t\t \n\t\tskb_queue_tail(&priv->b_tx_status.queue, skb);\n\t\tieee80211_queue_delayed_work(hw, &priv->work, 0);\n\t}\n}\n\nstatic void rtl8187_tx(struct ieee80211_hw *dev,\n\t\t       struct ieee80211_tx_control *control,\n\t\t       struct sk_buff *skb)\n{\n\tstruct rtl8187_priv *priv = dev->priv;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *tx_hdr =\t(struct ieee80211_hdr *)(skb->data);\n\tunsigned int ep;\n\tvoid *buf;\n\tstruct urb *urb;\n\t__le16 rts_dur = 0;\n\tu32 flags;\n\tint rc;\n\n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tflags = skb->len;\n\tflags |= RTL818X_TX_DESC_FLAG_NO_ENC;\n\n\tflags |= ieee80211_get_tx_rate(dev, info)->hw_value << 24;\n\tif (ieee80211_has_morefrags(tx_hdr->frame_control))\n\t\tflags |= RTL818X_TX_DESC_FLAG_MOREFRAG;\n\n\t \n\tif (info->control.rates[0].flags & IEEE80211_TX_RC_USE_RTS_CTS) {\n\t\tflags |= RTL818X_TX_DESC_FLAG_RTS;\n\t\tflags |= ieee80211_get_rts_cts_rate(dev, info)->hw_value << 19;\n\t\trts_dur = ieee80211_rts_duration(dev, priv->vif,\n\t\t\t\t\t\t skb->len, info);\n\t} else if (info->control.rates[0].flags & IEEE80211_TX_RC_USE_CTS_PROTECT) {\n\t\tflags |= RTL818X_TX_DESC_FLAG_RTS | RTL818X_TX_DESC_FLAG_CTS;\n\t\tflags |= ieee80211_get_rts_cts_rate(dev, info)->hw_value << 19;\n\t\trts_dur = ieee80211_ctstoself_duration(dev, priv->vif,\n\t\t\t\t\t\t skb->len, info);\n\t}\n\n\tif (info->flags & IEEE80211_TX_CTL_ASSIGN_SEQ) {\n\t\tif (info->flags & IEEE80211_TX_CTL_FIRST_FRAGMENT)\n\t\t\tpriv->seqno += 0x10;\n\t\ttx_hdr->seq_ctrl &= cpu_to_le16(IEEE80211_SCTL_FRAG);\n\t\ttx_hdr->seq_ctrl |= cpu_to_le16(priv->seqno);\n\t}\n\n\tif (!priv->is_rtl8187b) {\n\t\tstruct rtl8187_tx_hdr *hdr = skb_push(skb, sizeof(*hdr));\n\t\thdr->flags = cpu_to_le32(flags);\n\t\thdr->len = 0;\n\t\thdr->rts_duration = rts_dur;\n\t\thdr->retry = cpu_to_le32((info->control.rates[0].count - 1) << 8);\n\t\tbuf = hdr;\n\n\t\tep = 2;\n\t} else {\n\t\t \n\t\tunsigned int epmap[4] = { 6, 7, 5, 4 };\n\t\tu16 fc = le16_to_cpu(tx_hdr->frame_control);\n\n\t\tstruct rtl8187b_tx_hdr *hdr = skb_push(skb, sizeof(*hdr));\n\t\tstruct ieee80211_rate *txrate =\n\t\t\tieee80211_get_tx_rate(dev, info);\n\t\tmemset(hdr, 0, sizeof(*hdr));\n\t\thdr->flags = cpu_to_le32(flags);\n\t\thdr->rts_duration = rts_dur;\n\t\thdr->retry = cpu_to_le32((info->control.rates[0].count - 1) << 8);\n\t\thdr->tx_duration =\n\t\t\tieee80211_generic_frame_duration(dev, priv->vif,\n\t\t\t\t\t\t\t info->band,\n\t\t\t\t\t\t\t skb->len, txrate);\n\t\tbuf = hdr;\n\n\t\tif ((fc & IEEE80211_FCTL_FTYPE) == IEEE80211_FTYPE_MGMT)\n\t\t\tep = 12;\n\t\telse\n\t\t\tep = epmap[skb_get_queue_mapping(skb)];\n\t}\n\n\tinfo->rate_driver_data[0] = dev;\n\tinfo->rate_driver_data[1] = urb;\n\n\tusb_fill_bulk_urb(urb, priv->udev, usb_sndbulkpipe(priv->udev, ep),\n\t\t\t  buf, skb->len, rtl8187_tx_cb, skb);\n\turb->transfer_flags |= URB_ZERO_PACKET;\n\tusb_anchor_urb(urb, &priv->anchored);\n\trc = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (rc < 0) {\n\t\tusb_unanchor_urb(urb);\n\t\tkfree_skb(skb);\n\t}\n\tusb_free_urb(urb);\n}\n\nstatic void rtl8187_rx_cb(struct urb *urb)\n{\n\tstruct sk_buff *skb = (struct sk_buff *)urb->context;\n\tstruct rtl8187_rx_info *info = (struct rtl8187_rx_info *)skb->cb;\n\tstruct ieee80211_hw *dev = info->dev;\n\tstruct rtl8187_priv *priv = dev->priv;\n\tstruct ieee80211_rx_status rx_status = { 0 };\n\tint rate, signal;\n\tu32 flags;\n\tunsigned long f;\n\n\tspin_lock_irqsave(&priv->rx_queue.lock, f);\n\t__skb_unlink(skb, &priv->rx_queue);\n\tspin_unlock_irqrestore(&priv->rx_queue.lock, f);\n\tskb_put(skb, urb->actual_length);\n\n\tif (unlikely(urb->status)) {\n\t\tdev_kfree_skb_irq(skb);\n\t\treturn;\n\t}\n\n\tif (!priv->is_rtl8187b) {\n\t\tstruct rtl8187_rx_hdr *hdr =\n\t\t\t(typeof(hdr))(skb_tail_pointer(skb) - sizeof(*hdr));\n\t\tflags = le32_to_cpu(hdr->flags);\n\t\t \n\t\tsignal = -4 - ((27 * hdr->agc) >> 6);\n\t\trx_status.antenna = (hdr->signal >> 7) & 1;\n\t\trx_status.mactime = le64_to_cpu(hdr->mac_time);\n\t} else {\n\t\tstruct rtl8187b_rx_hdr *hdr =\n\t\t\t(typeof(hdr))(skb_tail_pointer(skb) - sizeof(*hdr));\n\t\t \n\t\tflags = le32_to_cpu(hdr->flags);\n\t\tsignal = 14 - hdr->agc / 2;\n\t\trx_status.antenna = (hdr->rssi >> 7) & 1;\n\t\trx_status.mactime = le64_to_cpu(hdr->mac_time);\n\t}\n\n\trx_status.signal = signal;\n\tpriv->signal = signal;\n\trate = (flags >> 20) & 0xF;\n\tskb_trim(skb, flags & 0x0FFF);\n\trx_status.rate_idx = rate;\n\trx_status.freq = dev->conf.chandef.chan->center_freq;\n\trx_status.band = dev->conf.chandef.chan->band;\n\trx_status.flag |= RX_FLAG_MACTIME_START;\n\tif (flags & RTL818X_RX_DESC_FLAG_SPLCP)\n\t\trx_status.enc_flags |= RX_ENC_FLAG_SHORTPRE;\n\tif (flags & RTL818X_RX_DESC_FLAG_CRC32_ERR)\n\t\trx_status.flag |= RX_FLAG_FAILED_FCS_CRC;\n\tmemcpy(IEEE80211_SKB_RXCB(skb), &rx_status, sizeof(rx_status));\n\tieee80211_rx_irqsafe(dev, skb);\n\n\tskb = dev_alloc_skb(RTL8187_MAX_RX);\n\tif (unlikely(!skb)) {\n\t\t \n\t\treturn;\n\t}\n\n\tinfo = (struct rtl8187_rx_info *)skb->cb;\n\tinfo->urb = urb;\n\tinfo->dev = dev;\n\turb->transfer_buffer = skb_tail_pointer(skb);\n\turb->context = skb;\n\tskb_queue_tail(&priv->rx_queue, skb);\n\n\tusb_anchor_urb(urb, &priv->anchored);\n\tif (usb_submit_urb(urb, GFP_ATOMIC)) {\n\t\tusb_unanchor_urb(urb);\n\t\tskb_unlink(skb, &priv->rx_queue);\n\t\tdev_kfree_skb_irq(skb);\n\t}\n}\n\nstatic int rtl8187_init_urbs(struct ieee80211_hw *dev)\n{\n\tstruct rtl8187_priv *priv = dev->priv;\n\tstruct urb *entry = NULL;\n\tstruct sk_buff *skb;\n\tstruct rtl8187_rx_info *info;\n\tint ret = 0;\n\n\twhile (skb_queue_len(&priv->rx_queue) < 32) {\n\t\tskb = __dev_alloc_skb(RTL8187_MAX_RX, GFP_KERNEL);\n\t\tif (!skb) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t\tentry = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!entry) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t\tusb_fill_bulk_urb(entry, priv->udev,\n\t\t\t\t  usb_rcvbulkpipe(priv->udev,\n\t\t\t\t  priv->is_rtl8187b ? 3 : 1),\n\t\t\t\t  skb_tail_pointer(skb),\n\t\t\t\t  RTL8187_MAX_RX, rtl8187_rx_cb, skb);\n\t\tinfo = (struct rtl8187_rx_info *)skb->cb;\n\t\tinfo->urb = entry;\n\t\tinfo->dev = dev;\n\t\tskb_queue_tail(&priv->rx_queue, skb);\n\t\tusb_anchor_urb(entry, &priv->anchored);\n\t\tret = usb_submit_urb(entry, GFP_KERNEL);\n\t\tif (ret) {\n\t\t\tskb_unlink(skb, &priv->rx_queue);\n\t\t\tusb_unanchor_urb(entry);\n\t\t\tusb_put_urb(entry);\n\t\t\tgoto err;\n\t\t}\n\t\tusb_put_urb(entry);\n\t}\n\treturn ret;\n\nerr:\n\tkfree_skb(skb);\n\tusb_kill_anchored_urbs(&priv->anchored);\n\treturn ret;\n}\n\nstatic void rtl8187b_status_cb(struct urb *urb)\n{\n\tstruct ieee80211_hw *hw = (struct ieee80211_hw *)urb->context;\n\tstruct rtl8187_priv *priv = hw->priv;\n\tu64 val;\n\tunsigned int cmd_type;\n\n\tif (unlikely(urb->status))\n\t\treturn;\n\n\t \n\tval = le64_to_cpu(priv->b_tx_status.buf);\n\n\tcmd_type = (val >> 30) & 0x3;\n\tif (cmd_type == 1) {\n\t\tunsigned int pkt_rc, seq_no;\n\t\tbool tok;\n\t\tstruct sk_buff *skb, *iter;\n\t\tstruct ieee80211_hdr *ieee80211hdr;\n\t\tunsigned long flags;\n\n\t\tpkt_rc = val & 0xFF;\n\t\ttok = val & (1 << 15);\n\t\tseq_no = (val >> 16) & 0xFFF;\n\n\t\tspin_lock_irqsave(&priv->b_tx_status.queue.lock, flags);\n\t\tskb = NULL;\n\t\tskb_queue_reverse_walk(&priv->b_tx_status.queue, iter) {\n\t\t\tieee80211hdr = (struct ieee80211_hdr *)iter->data;\n\n\t\t\t \n\t\t\tif ((le16_to_cpu(ieee80211hdr->seq_ctrl)\n\t\t\t     & 0xFFF) == seq_no) {\n\t\t\t\tskb = iter;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (skb) {\n\t\t\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\n\t\t\t__skb_unlink(skb, &priv->b_tx_status.queue);\n\t\t\tif (tok)\n\t\t\t\tinfo->flags |= IEEE80211_TX_STAT_ACK;\n\t\t\tinfo->status.rates[0].count = pkt_rc + 1;\n\n\t\t\tieee80211_tx_status_irqsafe(hw, skb);\n\t\t}\n\t\tspin_unlock_irqrestore(&priv->b_tx_status.queue.lock, flags);\n\t}\n\n\tusb_anchor_urb(urb, &priv->anchored);\n\tif (usb_submit_urb(urb, GFP_ATOMIC))\n\t\tusb_unanchor_urb(urb);\n}\n\nstatic int rtl8187b_init_status_urb(struct ieee80211_hw *dev)\n{\n\tstruct rtl8187_priv *priv = dev->priv;\n\tstruct urb *entry;\n\tint ret = 0;\n\n\tentry = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\n\tusb_fill_bulk_urb(entry, priv->udev, usb_rcvbulkpipe(priv->udev, 9),\n\t\t\t  &priv->b_tx_status.buf, sizeof(priv->b_tx_status.buf),\n\t\t\t  rtl8187b_status_cb, dev);\n\n\tusb_anchor_urb(entry, &priv->anchored);\n\tret = usb_submit_urb(entry, GFP_KERNEL);\n\tif (ret)\n\t\tusb_unanchor_urb(entry);\n\tusb_free_urb(entry);\n\n\treturn ret;\n}\n\nstatic void rtl8187_set_anaparam(struct rtl8187_priv *priv, bool rfon)\n{\n\tu32 anaparam, anaparam2;\n\tu8 anaparam3, reg;\n\n\tif (!priv->is_rtl8187b) {\n\t\tif (rfon) {\n\t\t\tanaparam = RTL8187_RTL8225_ANAPARAM_ON;\n\t\t\tanaparam2 = RTL8187_RTL8225_ANAPARAM2_ON;\n\t\t} else {\n\t\t\tanaparam = RTL8187_RTL8225_ANAPARAM_OFF;\n\t\t\tanaparam2 = RTL8187_RTL8225_ANAPARAM2_OFF;\n\t\t}\n\t} else {\n\t\tif (rfon) {\n\t\t\tanaparam = RTL8187B_RTL8225_ANAPARAM_ON;\n\t\t\tanaparam2 = RTL8187B_RTL8225_ANAPARAM2_ON;\n\t\t\tanaparam3 = RTL8187B_RTL8225_ANAPARAM3_ON;\n\t\t} else {\n\t\t\tanaparam = RTL8187B_RTL8225_ANAPARAM_OFF;\n\t\t\tanaparam2 = RTL8187B_RTL8225_ANAPARAM2_OFF;\n\t\t\tanaparam3 = RTL8187B_RTL8225_ANAPARAM3_OFF;\n\t\t}\n\t}\n\n\trtl818x_iowrite8(priv, &priv->map->EEPROM_CMD,\n\t\t\t RTL818X_EEPROM_CMD_CONFIG);\n\treg = rtl818x_ioread8(priv, &priv->map->CONFIG3);\n\treg |= RTL818X_CONFIG3_ANAPARAM_WRITE;\n\trtl818x_iowrite8(priv, &priv->map->CONFIG3, reg);\n\trtl818x_iowrite32(priv, &priv->map->ANAPARAM, anaparam);\n\trtl818x_iowrite32(priv, &priv->map->ANAPARAM2, anaparam2);\n\tif (priv->is_rtl8187b)\n\t\trtl818x_iowrite8(priv, &priv->map->ANAPARAM3A, anaparam3);\n\treg &= ~RTL818X_CONFIG3_ANAPARAM_WRITE;\n\trtl818x_iowrite8(priv, &priv->map->CONFIG3, reg);\n\trtl818x_iowrite8(priv, &priv->map->EEPROM_CMD,\n\t\t\t RTL818X_EEPROM_CMD_NORMAL);\n}\n\nstatic int rtl8187_cmd_reset(struct ieee80211_hw *dev)\n{\n\tstruct rtl8187_priv *priv = dev->priv;\n\tu8 reg;\n\tint i;\n\n\treg = rtl818x_ioread8(priv, &priv->map->CMD);\n\treg &= (1 << 1);\n\treg |= RTL818X_CMD_RESET;\n\trtl818x_iowrite8(priv, &priv->map->CMD, reg);\n\n\ti = 10;\n\tdo {\n\t\tmsleep(2);\n\t\tif (!(rtl818x_ioread8(priv, &priv->map->CMD) &\n\t\t      RTL818X_CMD_RESET))\n\t\t\tbreak;\n\t} while (--i);\n\n\tif (!i) {\n\t\twiphy_err(dev->wiphy, \"Reset timeout!\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\trtl818x_iowrite8(priv, &priv->map->EEPROM_CMD, RTL818X_EEPROM_CMD_LOAD);\n\n\ti = 10;\n\tdo {\n\t\tmsleep(4);\n\t\tif (!(rtl818x_ioread8(priv, &priv->map->EEPROM_CMD) &\n\t\t      RTL818X_EEPROM_CMD_CONFIG))\n\t\t\tbreak;\n\t} while (--i);\n\n\tif (!i) {\n\t\twiphy_err(dev->wiphy, \"eeprom reset timeout!\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic int rtl8187_init_hw(struct ieee80211_hw *dev)\n{\n\tstruct rtl8187_priv *priv = dev->priv;\n\tu8 reg;\n\tint res;\n\n\t \n\trtl8187_set_anaparam(priv, true);\n\n\trtl818x_iowrite16(priv, &priv->map->INT_MASK, 0);\n\n\tmsleep(200);\n\trtl818x_iowrite8(priv, (u8 *)0xFE18, 0x10);\n\trtl818x_iowrite8(priv, (u8 *)0xFE18, 0x11);\n\trtl818x_iowrite8(priv, (u8 *)0xFE18, 0x00);\n\tmsleep(200);\n\n\tres = rtl8187_cmd_reset(dev);\n\tif (res)\n\t\treturn res;\n\n\trtl8187_set_anaparam(priv, true);\n\n\t \n\trtl818x_iowrite16(priv, &priv->map->RFPinsSelect, 0);\n\trtl818x_iowrite8(priv, &priv->map->GPIO0, 0);\n\n\trtl818x_iowrite16(priv, &priv->map->RFPinsSelect, (4 << 8));\n\trtl818x_iowrite8(priv, &priv->map->GPIO0, 1);\n\trtl818x_iowrite8(priv, &priv->map->GP_ENABLE, 0);\n\n\trtl818x_iowrite8(priv, &priv->map->EEPROM_CMD, RTL818X_EEPROM_CMD_CONFIG);\n\n\trtl818x_iowrite16(priv, (__le16 *)0xFFF4, 0xFFFF);\n\treg = rtl818x_ioread8(priv, &priv->map->CONFIG1);\n\treg &= 0x3F;\n\treg |= 0x80;\n\trtl818x_iowrite8(priv, &priv->map->CONFIG1, reg);\n\n\trtl818x_iowrite8(priv, &priv->map->EEPROM_CMD, RTL818X_EEPROM_CMD_NORMAL);\n\n\trtl818x_iowrite32(priv, &priv->map->INT_TIMEOUT, 0);\n\trtl818x_iowrite8(priv, &priv->map->WPA_CONF, 0);\n\trtl818x_iowrite8(priv, &priv->map->RATE_FALLBACK, 0);\n\n\t \n\trtl818x_iowrite8(priv, &priv->map->RESP_RATE, (8 << 4) | 0);\n\trtl818x_iowrite16(priv, &priv->map->BRSR, 0x01F3);\n\n\t \n\trtl818x_iowrite16(priv, &priv->map->RFPinsSelect, 0);\n\trtl818x_iowrite8(priv, &priv->map->GPIO0, 0);\n\treg = rtl818x_ioread8(priv, (u8 *)0xFE53);\n\trtl818x_iowrite8(priv, (u8 *)0xFE53, reg | (1 << 7));\n\trtl818x_iowrite16(priv, &priv->map->RFPinsSelect, (4 << 8));\n\trtl818x_iowrite8(priv, &priv->map->GPIO0, 0x20);\n\trtl818x_iowrite8(priv, &priv->map->GP_ENABLE, 0);\n\trtl818x_iowrite16(priv, &priv->map->RFPinsOutput, 0x80);\n\trtl818x_iowrite16(priv, &priv->map->RFPinsSelect, 0x80);\n\trtl818x_iowrite16(priv, &priv->map->RFPinsEnable, 0x80);\n\tmsleep(100);\n\n\trtl818x_iowrite32(priv, &priv->map->RF_TIMING, 0x000a8008);\n\trtl818x_iowrite16(priv, &priv->map->BRSR, 0xFFFF);\n\trtl818x_iowrite32(priv, &priv->map->RF_PARA, 0x00100044);\n\trtl818x_iowrite8(priv, &priv->map->EEPROM_CMD,\n\t\t\t RTL818X_EEPROM_CMD_CONFIG);\n\trtl818x_iowrite8(priv, &priv->map->CONFIG3, 0x44);\n\trtl818x_iowrite8(priv, &priv->map->EEPROM_CMD,\n\t\t\t RTL818X_EEPROM_CMD_NORMAL);\n\trtl818x_iowrite16(priv, &priv->map->RFPinsEnable, 0x1FF7);\n\tmsleep(100);\n\n\tpriv->rf->init(dev);\n\n\trtl818x_iowrite16(priv, &priv->map->BRSR, 0x01F3);\n\treg = rtl818x_ioread8(priv, &priv->map->PGSELECT) & ~1;\n\trtl818x_iowrite8(priv, &priv->map->PGSELECT, reg | 1);\n\trtl818x_iowrite16(priv, (__le16 *)0xFFFE, 0x10);\n\trtl818x_iowrite8(priv, &priv->map->TALLY_SEL, 0x80);\n\trtl818x_iowrite8(priv, (u8 *)0xFFFF, 0x60);\n\trtl818x_iowrite8(priv, &priv->map->PGSELECT, reg);\n\n\treturn 0;\n}\n\nstatic const u8 rtl8187b_reg_table[][3] = {\n\t{0xF0, 0x32, 0}, {0xF1, 0x32, 0}, {0xF2, 0x00, 0}, {0xF3, 0x00, 0},\n\t{0xF4, 0x32, 0}, {0xF5, 0x43, 0}, {0xF6, 0x00, 0}, {0xF7, 0x00, 0},\n\t{0xF8, 0x46, 0}, {0xF9, 0xA4, 0}, {0xFA, 0x00, 0}, {0xFB, 0x00, 0},\n\t{0xFC, 0x96, 0}, {0xFD, 0xA4, 0}, {0xFE, 0x00, 0}, {0xFF, 0x00, 0},\n\n\t{0x58, 0x4B, 1}, {0x59, 0x00, 1}, {0x5A, 0x4B, 1}, {0x5B, 0x00, 1},\n\t{0x60, 0x4B, 1}, {0x61, 0x09, 1}, {0x62, 0x4B, 1}, {0x63, 0x09, 1},\n\t{0xCE, 0x0F, 1}, {0xCF, 0x00, 1}, {0xF0, 0x4E, 1}, {0xF1, 0x01, 1},\n\t{0xF2, 0x02, 1}, {0xF3, 0x03, 1}, {0xF4, 0x04, 1}, {0xF5, 0x05, 1},\n\t{0xF6, 0x06, 1}, {0xF7, 0x07, 1}, {0xF8, 0x08, 1},\n\n\t{0x4E, 0x00, 2}, {0x0C, 0x04, 2}, {0x21, 0x61, 2}, {0x22, 0x68, 2},\n\t{0x23, 0x6F, 2}, {0x24, 0x76, 2}, {0x25, 0x7D, 2}, {0x26, 0x84, 2},\n\t{0x27, 0x8D, 2}, {0x4D, 0x08, 2}, {0x50, 0x05, 2}, {0x51, 0xF5, 2},\n\t{0x52, 0x04, 2}, {0x53, 0xA0, 2}, {0x54, 0x1F, 2}, {0x55, 0x23, 2},\n\t{0x56, 0x45, 2}, {0x57, 0x67, 2}, {0x58, 0x08, 2}, {0x59, 0x08, 2},\n\t{0x5A, 0x08, 2}, {0x5B, 0x08, 2}, {0x60, 0x08, 2}, {0x61, 0x08, 2},\n\t{0x62, 0x08, 2}, {0x63, 0x08, 2}, {0x64, 0xCF, 2},\n\n\t{0x5B, 0x40, 0}, {0x84, 0x88, 0}, {0x85, 0x24, 0}, {0x88, 0x54, 0},\n\t{0x8B, 0xB8, 0}, {0x8C, 0x07, 0}, {0x8D, 0x00, 0}, {0x94, 0x1B, 0},\n\t{0x95, 0x12, 0}, {0x96, 0x00, 0}, {0x97, 0x06, 0}, {0x9D, 0x1A, 0},\n\t{0x9F, 0x10, 0}, {0xB4, 0x22, 0}, {0xBE, 0x80, 0}, {0xDB, 0x00, 0},\n\t{0xEE, 0x00, 0}, {0x4C, 0x00, 2},\n\n\t{0x9F, 0x00, 3}, {0x8C, 0x01, 0}, {0x8D, 0x10, 0}, {0x8E, 0x08, 0},\n\t{0x8F, 0x00, 0}\n};\n\nstatic int rtl8187b_init_hw(struct ieee80211_hw *dev)\n{\n\tstruct rtl8187_priv *priv = dev->priv;\n\tint res, i;\n\tu8 reg;\n\n\trtl8187_set_anaparam(priv, true);\n\n\t \n\trtl818x_iowrite8(priv, (u8 *)0xFF61, 0x10);\n\treg = rtl818x_ioread8(priv, (u8 *)0xFF62);\n\trtl818x_iowrite8(priv, (u8 *)0xFF62, reg & ~(1 << 5));\n\trtl818x_iowrite8(priv, (u8 *)0xFF62, reg | (1 << 5));\n\n\tres = rtl8187_cmd_reset(dev);\n\tif (res)\n\t\treturn res;\n\n\trtl8187_set_anaparam(priv, true);\n\n\t \n\trtl818x_iowrite16(priv, (__le16 *)0xFF34, 0x0FFF);\n\n\treg = rtl818x_ioread8(priv, &priv->map->CW_CONF);\n\treg |= RTL818X_CW_CONF_PERPACKET_RETRY;\n\trtl818x_iowrite8(priv, &priv->map->CW_CONF, reg);\n\n\t \n\trtl818x_iowrite16_idx(priv, (__le16 *)0xFFE0, 0x0FFF, 1);\n\trtl818x_iowrite8_idx(priv, (u8 *)0xFFE2, 0x00, 1);\n\n\trtl818x_iowrite16_idx(priv, (__le16 *)0xFFD4, 0xFFFF, 1);\n\n\trtl818x_iowrite8(priv, &priv->map->EEPROM_CMD,\n\t\t\t RTL818X_EEPROM_CMD_CONFIG);\n\treg = rtl818x_ioread8(priv, &priv->map->CONFIG1);\n\trtl818x_iowrite8(priv, &priv->map->CONFIG1, (reg & 0x3F) | 0x80);\n\trtl818x_iowrite8(priv, &priv->map->EEPROM_CMD,\n\t\t\t RTL818X_EEPROM_CMD_NORMAL);\n\n\trtl818x_iowrite8(priv, &priv->map->WPA_CONF, 0);\n\tfor (i = 0; i < ARRAY_SIZE(rtl8187b_reg_table); i++) {\n\t\trtl818x_iowrite8_idx(priv,\n\t\t\t\t     (u8 *)(uintptr_t)\n\t\t\t\t     (rtl8187b_reg_table[i][0] | 0xFF00),\n\t\t\t\t     rtl8187b_reg_table[i][1],\n\t\t\t\t     rtl8187b_reg_table[i][2]);\n\t}\n\n\trtl818x_iowrite16(priv, &priv->map->TID_AC_MAP, 0xFA50);\n\trtl818x_iowrite16(priv, &priv->map->INT_MIG, 0);\n\n\trtl818x_iowrite32_idx(priv, (__le32 *)0xFFF0, 0, 1);\n\trtl818x_iowrite32_idx(priv, (__le32 *)0xFFF4, 0, 1);\n\trtl818x_iowrite8_idx(priv, (u8 *)0xFFF8, 0, 1);\n\n\trtl818x_iowrite32(priv, &priv->map->RF_TIMING, 0x00004001);\n\n\t \n\trtl818x_iowrite16_idx(priv, (__le16 *)0xFF72, 0x569A, 2);\n\n\trtl818x_iowrite16(priv, &priv->map->RFPinsOutput, 0x0480);\n\trtl818x_iowrite16(priv, &priv->map->RFPinsSelect, 0x2488);\n\trtl818x_iowrite16(priv, &priv->map->RFPinsEnable, 0x1FFF);\n\tmsleep(100);\n\n\tpriv->rf->init(dev);\n\n\treg = RTL818X_CMD_TX_ENABLE | RTL818X_CMD_RX_ENABLE;\n\trtl818x_iowrite8(priv, &priv->map->CMD, reg);\n\trtl818x_iowrite16(priv, &priv->map->INT_MASK, 0xFFFF);\n\n\trtl818x_iowrite8(priv, (u8 *)0xFE41, 0xF4);\n\trtl818x_iowrite8(priv, (u8 *)0xFE40, 0x00);\n\trtl818x_iowrite8(priv, (u8 *)0xFE42, 0x00);\n\trtl818x_iowrite8(priv, (u8 *)0xFE42, 0x01);\n\trtl818x_iowrite8(priv, (u8 *)0xFE40, 0x0F);\n\trtl818x_iowrite8(priv, (u8 *)0xFE42, 0x00);\n\trtl818x_iowrite8(priv, (u8 *)0xFE42, 0x01);\n\n\treg = rtl818x_ioread8(priv, (u8 *)0xFFDB);\n\trtl818x_iowrite8(priv, (u8 *)0xFFDB, reg | (1 << 2));\n\trtl818x_iowrite16_idx(priv, (__le16 *)0xFF72, 0x59FA, 3);\n\trtl818x_iowrite16_idx(priv, (__le16 *)0xFF74, 0x59D2, 3);\n\trtl818x_iowrite16_idx(priv, (__le16 *)0xFF76, 0x59D2, 3);\n\trtl818x_iowrite16_idx(priv, (__le16 *)0xFF78, 0x19FA, 3);\n\trtl818x_iowrite16_idx(priv, (__le16 *)0xFF7A, 0x19FA, 3);\n\trtl818x_iowrite16_idx(priv, (__le16 *)0xFF7C, 0x00D0, 3);\n\trtl818x_iowrite8(priv, (u8 *)0xFF61, 0);\n\trtl818x_iowrite8_idx(priv, (u8 *)0xFF80, 0x0F, 1);\n\trtl818x_iowrite8_idx(priv, (u8 *)0xFF83, 0x03, 1);\n\trtl818x_iowrite8(priv, (u8 *)0xFFDA, 0x10);\n\trtl818x_iowrite8_idx(priv, (u8 *)0xFF4D, 0x08, 2);\n\n\trtl818x_iowrite32(priv, &priv->map->HSSI_PARA, 0x0600321B);\n\n\trtl818x_iowrite16_idx(priv, (__le16 *)0xFFEC, 0x0800, 1);\n\n\tpriv->slot_time = 0x9;\n\tpriv->aifsn[0] = 2;  \n\tpriv->aifsn[1] = 2;  \n\tpriv->aifsn[2] = 7;  \n\tpriv->aifsn[3] = 3;  \n\trtl818x_iowrite8(priv, &priv->map->ACM_CONTROL, 0);\n\n\t \n\trtl818x_iowrite8(priv, &priv->map->MSR, RTL818X_MSR_ENEDCA);\n\n\treturn 0;\n}\n\nstatic void rtl8187_work(struct work_struct *work)\n{\n\t \n\tstruct rtl8187_priv *priv = container_of(work, struct rtl8187_priv,\n\t\t\t\t    work.work);\n\tstruct ieee80211_tx_info *info;\n\tstruct ieee80211_hw *dev = priv->dev;\n\tstatic u16 retry;\n\tu16 tmp;\n\tu16 avg_retry;\n\tint length;\n\n\tmutex_lock(&priv->conf_mutex);\n\ttmp = rtl818x_ioread16(priv, (__le16 *)0xFFFA);\n\tlength = skb_queue_len(&priv->b_tx_status.queue);\n\tif (unlikely(!length))\n\t\tlength = 1;\n\tif (unlikely(tmp < retry))\n\t\ttmp = retry;\n\tavg_retry = (tmp - retry) / length;\n\twhile (skb_queue_len(&priv->b_tx_status.queue) > 0) {\n\t\tstruct sk_buff *old_skb;\n\n\t\told_skb = skb_dequeue(&priv->b_tx_status.queue);\n\t\tinfo = IEEE80211_SKB_CB(old_skb);\n\t\tinfo->status.rates[0].count = avg_retry + 1;\n\t\tif (info->status.rates[0].count > RETRY_COUNT)\n\t\t\tinfo->flags &= ~IEEE80211_TX_STAT_ACK;\n\t\tieee80211_tx_status_irqsafe(dev, old_skb);\n\t}\n\tretry = tmp;\n\tmutex_unlock(&priv->conf_mutex);\n}\n\nstatic int rtl8187_start(struct ieee80211_hw *dev)\n{\n\tstruct rtl8187_priv *priv = dev->priv;\n\tu32 reg;\n\tint ret;\n\n\tmutex_lock(&priv->conf_mutex);\n\n\tret = (!priv->is_rtl8187b) ? rtl8187_init_hw(dev) :\n\t\t\t\t     rtl8187b_init_hw(dev);\n\tif (ret)\n\t\tgoto rtl8187_start_exit;\n\n\tinit_usb_anchor(&priv->anchored);\n\tpriv->dev = dev;\n\n\tif (priv->is_rtl8187b) {\n\t\treg = RTL818X_RX_CONF_MGMT |\n\t\t      RTL818X_RX_CONF_DATA |\n\t\t      RTL818X_RX_CONF_BROADCAST |\n\t\t      RTL818X_RX_CONF_NICMAC |\n\t\t      RTL818X_RX_CONF_BSSID |\n\t\t      (7 << 13  ) |\n\t\t      (7 << 10  ) |\n\t\t      RTL818X_RX_CONF_RX_AUTORESETPHY |\n\t\t      RTL818X_RX_CONF_ONLYERLPKT;\n\t\tpriv->rx_conf = reg;\n\t\trtl818x_iowrite32(priv, &priv->map->RX_CONF, reg);\n\n\t\treg = rtl818x_ioread8(priv, &priv->map->TX_AGC_CTL);\n\t\treg &= ~RTL818X_TX_AGC_CTL_PERPACKET_GAIN;\n\t\treg &= ~RTL818X_TX_AGC_CTL_PERPACKET_ANTSEL;\n\t\treg &= ~RTL818X_TX_AGC_CTL_FEEDBACK_ANT;\n\t\trtl818x_iowrite8(priv, &priv->map->TX_AGC_CTL, reg);\n\n\t\trtl818x_iowrite32(priv, &priv->map->TX_CONF,\n\t\t\t\t  RTL818X_TX_CONF_HW_SEQNUM |\n\t\t\t\t  RTL818X_TX_CONF_DISREQQSIZE |\n\t\t\t\t  (RETRY_COUNT << 8   ) |\n\t\t\t\t  (RETRY_COUNT << 0   ) |\n\t\t\t\t  (7 << 21  ));\n\t\tret = rtl8187_init_urbs(dev);\n\t\tif (ret)\n\t\t\tgoto rtl8187_start_exit;\n\t\tret = rtl8187b_init_status_urb(dev);\n\t\tif (ret)\n\t\t\tusb_kill_anchored_urbs(&priv->anchored);\n\t\tgoto rtl8187_start_exit;\n\t}\n\n\trtl818x_iowrite16(priv, &priv->map->INT_MASK, 0xFFFF);\n\n\trtl818x_iowrite32(priv, &priv->map->MAR[0], ~0);\n\trtl818x_iowrite32(priv, &priv->map->MAR[1], ~0);\n\n\tret = rtl8187_init_urbs(dev);\n\tif (ret)\n\t\tgoto rtl8187_start_exit;\n\n\treg = RTL818X_RX_CONF_ONLYERLPKT |\n\t      RTL818X_RX_CONF_RX_AUTORESETPHY |\n\t      RTL818X_RX_CONF_BSSID |\n\t      RTL818X_RX_CONF_MGMT |\n\t      RTL818X_RX_CONF_DATA |\n\t      (7 << 13  ) |\n\t      (7 << 10  ) |\n\t      RTL818X_RX_CONF_BROADCAST |\n\t      RTL818X_RX_CONF_NICMAC;\n\n\tpriv->rx_conf = reg;\n\trtl818x_iowrite32(priv, &priv->map->RX_CONF, reg);\n\n\treg = rtl818x_ioread8(priv, &priv->map->CW_CONF);\n\treg &= ~RTL818X_CW_CONF_PERPACKET_CW;\n\treg |= RTL818X_CW_CONF_PERPACKET_RETRY;\n\trtl818x_iowrite8(priv, &priv->map->CW_CONF, reg);\n\n\treg = rtl818x_ioread8(priv, &priv->map->TX_AGC_CTL);\n\treg &= ~RTL818X_TX_AGC_CTL_PERPACKET_GAIN;\n\treg &= ~RTL818X_TX_AGC_CTL_PERPACKET_ANTSEL;\n\treg &= ~RTL818X_TX_AGC_CTL_FEEDBACK_ANT;\n\trtl818x_iowrite8(priv, &priv->map->TX_AGC_CTL, reg);\n\n\treg  = RTL818X_TX_CONF_CW_MIN |\n\t       (7 << 21  ) |\n\t       RTL818X_TX_CONF_NO_ICV;\n\trtl818x_iowrite32(priv, &priv->map->TX_CONF, reg);\n\n\treg = rtl818x_ioread8(priv, &priv->map->CMD);\n\treg |= RTL818X_CMD_TX_ENABLE;\n\treg |= RTL818X_CMD_RX_ENABLE;\n\trtl818x_iowrite8(priv, &priv->map->CMD, reg);\n\tINIT_DELAYED_WORK(&priv->work, rtl8187_work);\n\nrtl8187_start_exit:\n\tmutex_unlock(&priv->conf_mutex);\n\treturn ret;\n}\n\nstatic void rtl8187_stop(struct ieee80211_hw *dev)\n{\n\tstruct rtl8187_priv *priv = dev->priv;\n\tstruct sk_buff *skb;\n\tu32 reg;\n\n\tmutex_lock(&priv->conf_mutex);\n\trtl818x_iowrite16(priv, &priv->map->INT_MASK, 0);\n\n\treg = rtl818x_ioread8(priv, &priv->map->CMD);\n\treg &= ~RTL818X_CMD_TX_ENABLE;\n\treg &= ~RTL818X_CMD_RX_ENABLE;\n\trtl818x_iowrite8(priv, &priv->map->CMD, reg);\n\n\tpriv->rf->stop(dev);\n\trtl8187_set_anaparam(priv, false);\n\n\trtl818x_iowrite8(priv, &priv->map->EEPROM_CMD, RTL818X_EEPROM_CMD_CONFIG);\n\treg = rtl818x_ioread8(priv, &priv->map->CONFIG4);\n\trtl818x_iowrite8(priv, &priv->map->CONFIG4, reg | RTL818X_CONFIG4_VCOOFF);\n\trtl818x_iowrite8(priv, &priv->map->EEPROM_CMD, RTL818X_EEPROM_CMD_NORMAL);\n\n\twhile ((skb = skb_dequeue(&priv->b_tx_status.queue)))\n\t\tdev_kfree_skb_any(skb);\n\n\tusb_kill_anchored_urbs(&priv->anchored);\n\tmutex_unlock(&priv->conf_mutex);\n\n\tif (!priv->is_rtl8187b)\n\t\tcancel_delayed_work_sync(&priv->work);\n}\n\nstatic u64 rtl8187_get_tsf(struct ieee80211_hw *dev, struct ieee80211_vif *vif)\n{\n\tstruct rtl8187_priv *priv = dev->priv;\n\n\treturn rtl818x_ioread32(priv, &priv->map->TSFT[0]) |\n\t       (u64)(rtl818x_ioread32(priv, &priv->map->TSFT[1])) << 32;\n}\n\n\nstatic void rtl8187_beacon_work(struct work_struct *work)\n{\n\tstruct rtl8187_vif *vif_priv =\n\t\tcontainer_of(work, struct rtl8187_vif, beacon_work.work);\n\tstruct ieee80211_vif *vif =\n\t\tcontainer_of((void *)vif_priv, struct ieee80211_vif, drv_priv);\n\tstruct ieee80211_hw *dev = vif_priv->dev;\n\tstruct ieee80211_mgmt *mgmt;\n\tstruct sk_buff *skb;\n\n\t \n\tif (ieee80211_queue_stopped(dev, 0))\n\t\tgoto resched;\n\n\t \n\tskb = ieee80211_beacon_get(dev, vif, 0);\n\tif (!skb)\n\t\tgoto resched;\n\n\t \n\tmgmt = (struct ieee80211_mgmt *)skb->data;\n\tmgmt->u.beacon.timestamp = cpu_to_le64(rtl8187_get_tsf(dev, vif));\n\n\t \n\tskb_set_queue_mapping(skb, 0);\n\n\trtl8187_tx(dev, NULL, skb);\n\nresched:\n\t \n\tschedule_delayed_work(&vif_priv->beacon_work,\n\t\t\tusecs_to_jiffies(1024 * vif->bss_conf.beacon_int));\n}\n\n\nstatic int rtl8187_add_interface(struct ieee80211_hw *dev,\n\t\t\t\t struct ieee80211_vif *vif)\n{\n\tstruct rtl8187_priv *priv = dev->priv;\n\tstruct rtl8187_vif *vif_priv;\n\tint i;\n\tint ret = -EOPNOTSUPP;\n\n\tmutex_lock(&priv->conf_mutex);\n\tif (priv->vif)\n\t\tgoto exit;\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tbreak;\n\tdefault:\n\t\tgoto exit;\n\t}\n\n\tret = 0;\n\tpriv->vif = vif;\n\n\t \n\tvif_priv = (struct rtl8187_vif *)&vif->drv_priv;\n\tvif_priv->dev = dev;\n\tINIT_DELAYED_WORK(&vif_priv->beacon_work, rtl8187_beacon_work);\n\tvif_priv->enable_beacon = false;\n\n\n\trtl818x_iowrite8(priv, &priv->map->EEPROM_CMD, RTL818X_EEPROM_CMD_CONFIG);\n\tfor (i = 0; i < ETH_ALEN; i++)\n\t\trtl818x_iowrite8(priv, &priv->map->MAC[i],\n\t\t\t\t ((u8 *)vif->addr)[i]);\n\trtl818x_iowrite8(priv, &priv->map->EEPROM_CMD, RTL818X_EEPROM_CMD_NORMAL);\n\nexit:\n\tmutex_unlock(&priv->conf_mutex);\n\treturn ret;\n}\n\nstatic void rtl8187_remove_interface(struct ieee80211_hw *dev,\n\t\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct rtl8187_priv *priv = dev->priv;\n\tmutex_lock(&priv->conf_mutex);\n\tpriv->vif = NULL;\n\tmutex_unlock(&priv->conf_mutex);\n}\n\nstatic int rtl8187_config(struct ieee80211_hw *dev, u32 changed)\n{\n\tstruct rtl8187_priv *priv = dev->priv;\n\tstruct ieee80211_conf *conf = &dev->conf;\n\tu32 reg;\n\n\tmutex_lock(&priv->conf_mutex);\n\treg = rtl818x_ioread32(priv, &priv->map->TX_CONF);\n\t \n\trtl818x_iowrite32(priv, &priv->map->TX_CONF,\n\t\t\t  reg | RTL818X_TX_CONF_LOOPBACK_MAC);\n\tpriv->rf->set_chan(dev, conf);\n\tmsleep(10);\n\trtl818x_iowrite32(priv, &priv->map->TX_CONF, reg);\n\n\trtl818x_iowrite16(priv, &priv->map->ATIM_WND, 2);\n\trtl818x_iowrite16(priv, &priv->map->ATIMTR_INTERVAL, 100);\n\trtl818x_iowrite16(priv, &priv->map->BEACON_INTERVAL, 100);\n\trtl818x_iowrite16(priv, &priv->map->BEACON_INTERVAL_TIME, 100);\n\tmutex_unlock(&priv->conf_mutex);\n\treturn 0;\n}\n\n \nstatic __le32 *rtl8187b_ac_addr[4] = {\n\t(__le32 *) 0xFFF0,  \n\t(__le32 *) 0xFFF4,  \n\t(__le32 *) 0xFFFC,  \n\t(__le32 *) 0xFFF8,  \n};\n\n#define SIFS_TIME 0xa\n\nstatic void rtl8187_conf_erp(struct rtl8187_priv *priv, bool use_short_slot,\n\t\t\t     bool use_short_preamble)\n{\n\tif (priv->is_rtl8187b) {\n\t\tu8 difs, eifs;\n\t\tu16 ack_timeout;\n\t\tint queue;\n\n\t\tif (use_short_slot) {\n\t\t\tpriv->slot_time = 0x9;\n\t\t\tdifs = 0x1c;\n\t\t\teifs = 0x53;\n\t\t} else {\n\t\t\tpriv->slot_time = 0x14;\n\t\t\tdifs = 0x32;\n\t\t\teifs = 0x5b;\n\t\t}\n\t\trtl818x_iowrite8(priv, &priv->map->SIFS, 0x22);\n\t\trtl818x_iowrite8(priv, &priv->map->SLOT, priv->slot_time);\n\t\trtl818x_iowrite8(priv, &priv->map->DIFS, difs);\n\n\t\t \n\t\trtl818x_iowrite8(priv, (u8 *)&priv->map->BRSR + 1, eifs);\n\n\t\t \n\t\tack_timeout = 112 + 48 + difs;\n\t\tif (use_short_preamble)\n\t\t\tack_timeout += 72;\n\t\telse\n\t\t\tack_timeout += 144;\n\t\trtl818x_iowrite8(priv, &priv->map->CARRIER_SENSE_COUNTER,\n\t\t\t\t DIV_ROUND_UP(ack_timeout, 4));\n\n\t\tfor (queue = 0; queue < 4; queue++)\n\t\t\trtl818x_iowrite8(priv, (u8 *) rtl8187b_ac_addr[queue],\n\t\t\t\t\t priv->aifsn[queue] * priv->slot_time +\n\t\t\t\t\t SIFS_TIME);\n\t} else {\n\t\trtl818x_iowrite8(priv, &priv->map->SIFS, 0x22);\n\t\tif (use_short_slot) {\n\t\t\trtl818x_iowrite8(priv, &priv->map->SLOT, 0x9);\n\t\t\trtl818x_iowrite8(priv, &priv->map->DIFS, 0x14);\n\t\t\trtl818x_iowrite8(priv, &priv->map->EIFS, 91 - 0x14);\n\t\t} else {\n\t\t\trtl818x_iowrite8(priv, &priv->map->SLOT, 0x14);\n\t\t\trtl818x_iowrite8(priv, &priv->map->DIFS, 0x24);\n\t\t\trtl818x_iowrite8(priv, &priv->map->EIFS, 91 - 0x24);\n\t\t}\n\t}\n}\n\nstatic void rtl8187_bss_info_changed(struct ieee80211_hw *dev,\n\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t     struct ieee80211_bss_conf *info,\n\t\t\t\t     u64 changed)\n{\n\tstruct rtl8187_priv *priv = dev->priv;\n\tstruct rtl8187_vif *vif_priv;\n\tint i;\n\tu8 reg;\n\n\tvif_priv = (struct rtl8187_vif *)&vif->drv_priv;\n\n\tif (changed & BSS_CHANGED_BSSID) {\n\t\tmutex_lock(&priv->conf_mutex);\n\t\tfor (i = 0; i < ETH_ALEN; i++)\n\t\t\trtl818x_iowrite8(priv, &priv->map->BSSID[i],\n\t\t\t\t\t info->bssid[i]);\n\n\t\tif (priv->is_rtl8187b)\n\t\t\treg = RTL818X_MSR_ENEDCA;\n\t\telse\n\t\t\treg = 0;\n\n\t\tif (is_valid_ether_addr(info->bssid)) {\n\t\t\tif (vif->type == NL80211_IFTYPE_ADHOC)\n\t\t\t\treg |= RTL818X_MSR_ADHOC;\n\t\t\telse\n\t\t\t\treg |= RTL818X_MSR_INFRA;\n\t\t}\n\t\telse\n\t\t\treg |= RTL818X_MSR_NO_LINK;\n\n\t\trtl818x_iowrite8(priv, &priv->map->MSR, reg);\n\n\t\tmutex_unlock(&priv->conf_mutex);\n\t}\n\n\tif (changed & (BSS_CHANGED_ERP_SLOT | BSS_CHANGED_ERP_PREAMBLE))\n\t\trtl8187_conf_erp(priv, info->use_short_slot,\n\t\t\t\t info->use_short_preamble);\n\n\tif (changed & BSS_CHANGED_BEACON_ENABLED)\n\t\tvif_priv->enable_beacon = info->enable_beacon;\n\n\tif (changed & (BSS_CHANGED_BEACON_ENABLED | BSS_CHANGED_BEACON)) {\n\t\tcancel_delayed_work_sync(&vif_priv->beacon_work);\n\t\tif (vif_priv->enable_beacon)\n\t\t\tschedule_work(&vif_priv->beacon_work.work);\n\t}\n\n}\n\nstatic u64 rtl8187_prepare_multicast(struct ieee80211_hw *dev,\n\t\t\t\t     struct netdev_hw_addr_list *mc_list)\n{\n\treturn netdev_hw_addr_list_count(mc_list);\n}\n\nstatic void rtl8187_configure_filter(struct ieee80211_hw *dev,\n\t\t\t\t     unsigned int changed_flags,\n\t\t\t\t     unsigned int *total_flags,\n\t\t\t\t     u64 multicast)\n{\n\tstruct rtl8187_priv *priv = dev->priv;\n\n\tif (changed_flags & FIF_FCSFAIL)\n\t\tpriv->rx_conf ^= RTL818X_RX_CONF_FCS;\n\tif (changed_flags & FIF_CONTROL)\n\t\tpriv->rx_conf ^= RTL818X_RX_CONF_CTRL;\n\tif (*total_flags & FIF_OTHER_BSS ||\n\t    *total_flags & FIF_ALLMULTI || multicast > 0)\n\t\tpriv->rx_conf |= RTL818X_RX_CONF_MONITOR;\n\telse\n\t\tpriv->rx_conf &= ~RTL818X_RX_CONF_MONITOR;\n\n\t*total_flags = 0;\n\n\tif (priv->rx_conf & RTL818X_RX_CONF_FCS)\n\t\t*total_flags |= FIF_FCSFAIL;\n\tif (priv->rx_conf & RTL818X_RX_CONF_CTRL)\n\t\t*total_flags |= FIF_CONTROL;\n\tif (priv->rx_conf & RTL818X_RX_CONF_MONITOR) {\n\t\t*total_flags |= FIF_OTHER_BSS;\n\t\t*total_flags |= FIF_ALLMULTI;\n\t}\n\n\trtl818x_iowrite32_async(priv, &priv->map->RX_CONF, priv->rx_conf);\n}\n\nstatic int rtl8187_conf_tx(struct ieee80211_hw *dev,\n\t\t\t   struct ieee80211_vif *vif,\n\t\t\t   unsigned int link_id, u16 queue,\n\t\t\t   const struct ieee80211_tx_queue_params *params)\n{\n\tstruct rtl8187_priv *priv = dev->priv;\n\tu8 cw_min, cw_max;\n\n\tif (queue > 3)\n\t\treturn -EINVAL;\n\n\tcw_min = fls(params->cw_min);\n\tcw_max = fls(params->cw_max);\n\n\tif (priv->is_rtl8187b) {\n\t\tpriv->aifsn[queue] = params->aifs;\n\n\t\t \n\t\trtl818x_iowrite32(priv, rtl8187b_ac_addr[queue],\n\t\t\t\t  (params->txop << 16) | (cw_max << 12) |\n\t\t\t\t  (cw_min << 8) | (params->aifs *\n\t\t\t\t  priv->slot_time + SIFS_TIME));\n\t} else {\n\t\tif (queue != 0)\n\t\t\treturn -EINVAL;\n\n\t\trtl818x_iowrite8(priv, &priv->map->CW_VAL,\n\t\t\t\t cw_min | (cw_max << 4));\n\t}\n\treturn 0;\n}\n\n\nstatic const struct ieee80211_ops rtl8187_ops = {\n\t.tx\t\t\t= rtl8187_tx,\n\t.wake_tx_queue\t\t= ieee80211_handle_wake_tx_queue,\n\t.start\t\t\t= rtl8187_start,\n\t.stop\t\t\t= rtl8187_stop,\n\t.add_interface\t\t= rtl8187_add_interface,\n\t.remove_interface\t= rtl8187_remove_interface,\n\t.config\t\t\t= rtl8187_config,\n\t.bss_info_changed\t= rtl8187_bss_info_changed,\n\t.prepare_multicast\t= rtl8187_prepare_multicast,\n\t.configure_filter\t= rtl8187_configure_filter,\n\t.conf_tx\t\t= rtl8187_conf_tx,\n\t.rfkill_poll\t\t= rtl8187_rfkill_poll,\n\t.get_tsf\t\t= rtl8187_get_tsf,\n};\n\nstatic void rtl8187_eeprom_register_read(struct eeprom_93cx6 *eeprom)\n{\n\tstruct ieee80211_hw *dev = eeprom->data;\n\tstruct rtl8187_priv *priv = dev->priv;\n\tu8 reg = rtl818x_ioread8(priv, &priv->map->EEPROM_CMD);\n\n\teeprom->reg_data_in = reg & RTL818X_EEPROM_CMD_WRITE;\n\teeprom->reg_data_out = reg & RTL818X_EEPROM_CMD_READ;\n\teeprom->reg_data_clock = reg & RTL818X_EEPROM_CMD_CK;\n\teeprom->reg_chip_select = reg & RTL818X_EEPROM_CMD_CS;\n}\n\nstatic void rtl8187_eeprom_register_write(struct eeprom_93cx6 *eeprom)\n{\n\tstruct ieee80211_hw *dev = eeprom->data;\n\tstruct rtl8187_priv *priv = dev->priv;\n\tu8 reg = RTL818X_EEPROM_CMD_PROGRAM;\n\n\tif (eeprom->reg_data_in)\n\t\treg |= RTL818X_EEPROM_CMD_WRITE;\n\tif (eeprom->reg_data_out)\n\t\treg |= RTL818X_EEPROM_CMD_READ;\n\tif (eeprom->reg_data_clock)\n\t\treg |= RTL818X_EEPROM_CMD_CK;\n\tif (eeprom->reg_chip_select)\n\t\treg |= RTL818X_EEPROM_CMD_CS;\n\n\trtl818x_iowrite8(priv, &priv->map->EEPROM_CMD, reg);\n\tudelay(10);\n}\n\nstatic int rtl8187_probe(struct usb_interface *intf,\n\t\t\t\t   const struct usb_device_id *id)\n{\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct ieee80211_hw *dev;\n\tstruct rtl8187_priv *priv;\n\tstruct eeprom_93cx6 eeprom;\n\tstruct ieee80211_channel *channel;\n\tconst char *chip_name;\n\tu16 txpwr, reg;\n\tu16 product_id = le16_to_cpu(udev->descriptor.idProduct);\n\tint err, i;\n\tu8 mac_addr[ETH_ALEN];\n\n\tdev = ieee80211_alloc_hw(sizeof(*priv), &rtl8187_ops);\n\tif (!dev) {\n\t\tprintk(KERN_ERR \"rtl8187: ieee80211 alloc failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv = dev->priv;\n\tpriv->is_rtl8187b = (id->driver_info == DEVICE_RTL8187B);\n\n\t \n\tpriv->io_dmabuf = kmalloc(sizeof(*priv->io_dmabuf), GFP_KERNEL);\n\tif (!priv->io_dmabuf) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free_dev;\n\t}\n\tmutex_init(&priv->io_mutex);\n\tmutex_init(&priv->conf_mutex);\n\n\tSET_IEEE80211_DEV(dev, &intf->dev);\n\tusb_set_intfdata(intf, dev);\n\tpriv->udev = udev;\n\n\tusb_get_dev(udev);\n\n\tskb_queue_head_init(&priv->rx_queue);\n\n\tBUILD_BUG_ON(sizeof(priv->channels) != sizeof(rtl818x_channels));\n\tBUILD_BUG_ON(sizeof(priv->rates) != sizeof(rtl818x_rates));\n\n\tmemcpy(priv->channels, rtl818x_channels, sizeof(rtl818x_channels));\n\tmemcpy(priv->rates, rtl818x_rates, sizeof(rtl818x_rates));\n\tpriv->map = (struct rtl818x_csr *)0xFF00;\n\n\tpriv->band.band = NL80211_BAND_2GHZ;\n\tpriv->band.channels = priv->channels;\n\tpriv->band.n_channels = ARRAY_SIZE(rtl818x_channels);\n\tpriv->band.bitrates = priv->rates;\n\tpriv->band.n_bitrates = ARRAY_SIZE(rtl818x_rates);\n\tdev->wiphy->bands[NL80211_BAND_2GHZ] = &priv->band;\n\n\n\tieee80211_hw_set(dev, RX_INCLUDES_FCS);\n\tieee80211_hw_set(dev, HOST_BROADCAST_PS_BUFFERING);\n\tieee80211_hw_set(dev, SIGNAL_DBM);\n\t \n\tdev->max_rates = 1;\n\tdev->max_rate_tries = RETRY_COUNT;\n\n\teeprom.data = dev;\n\teeprom.register_read = rtl8187_eeprom_register_read;\n\teeprom.register_write = rtl8187_eeprom_register_write;\n\tif (rtl818x_ioread32(priv, &priv->map->RX_CONF) & (1 << 6))\n\t\teeprom.width = PCI_EEPROM_WIDTH_93C66;\n\telse\n\t\teeprom.width = PCI_EEPROM_WIDTH_93C46;\n\n\trtl818x_iowrite8(priv, &priv->map->EEPROM_CMD, RTL818X_EEPROM_CMD_CONFIG);\n\tudelay(10);\n\n\teeprom_93cx6_multiread(&eeprom, RTL8187_EEPROM_MAC_ADDR,\n\t\t\t       (__le16 __force *)mac_addr, 3);\n\tif (!is_valid_ether_addr(mac_addr)) {\n\t\tprintk(KERN_WARNING \"rtl8187: Invalid hwaddr! Using randomly \"\n\t\t       \"generated MAC address\\n\");\n\t\teth_random_addr(mac_addr);\n\t}\n\tSET_IEEE80211_PERM_ADDR(dev, mac_addr);\n\n\tchannel = priv->channels;\n\tfor (i = 0; i < 3; i++) {\n\t\teeprom_93cx6_read(&eeprom, RTL8187_EEPROM_TXPWR_CHAN_1 + i,\n\t\t\t\t  &txpwr);\n\t\t(*channel++).hw_value = txpwr & 0xFF;\n\t\t(*channel++).hw_value = txpwr >> 8;\n\t}\n\tfor (i = 0; i < 2; i++) {\n\t\teeprom_93cx6_read(&eeprom, RTL8187_EEPROM_TXPWR_CHAN_4 + i,\n\t\t\t\t  &txpwr);\n\t\t(*channel++).hw_value = txpwr & 0xFF;\n\t\t(*channel++).hw_value = txpwr >> 8;\n\t}\n\n\teeprom_93cx6_read(&eeprom, RTL8187_EEPROM_TXPWR_BASE,\n\t\t\t  &priv->txpwr_base);\n\n\treg = rtl818x_ioread8(priv, &priv->map->PGSELECT) & ~1;\n\trtl818x_iowrite8(priv, &priv->map->PGSELECT, reg | 1);\n\t \n\tpriv->asic_rev = rtl818x_ioread8(priv, (u8 *)0xFFFE) & 0x3;\n\trtl818x_iowrite8(priv, &priv->map->PGSELECT, reg);\n\trtl818x_iowrite8(priv, &priv->map->EEPROM_CMD, RTL818X_EEPROM_CMD_NORMAL);\n\n\tif (!priv->is_rtl8187b) {\n\t\tu32 reg32;\n\t\treg32 = rtl818x_ioread32(priv, &priv->map->TX_CONF);\n\t\treg32 &= RTL818X_TX_CONF_HWVER_MASK;\n\t\tswitch (reg32) {\n\t\tcase RTL818X_TX_CONF_R8187vD_B:\n\t\t\t \n\t\t\tchip_name = \"RTL8187BvB(early)\";\n\t\t\tpriv->is_rtl8187b = 1;\n\t\t\tpriv->hw_rev = RTL8187BvB;\n\t\t\tbreak;\n\t\tcase RTL818X_TX_CONF_R8187vD:\n\t\t\tchip_name = \"RTL8187vD\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tchip_name = \"RTL8187vB (default)\";\n\t\t}\n       } else {\n\t\t \n\t\t \n\t\tswitch (rtl818x_ioread8(priv, (u8 *)0xFFE1)) {\n\t\tcase RTL818X_R8187B_B:\n\t\t\tchip_name = \"RTL8187BvB\";\n\t\t\tpriv->hw_rev = RTL8187BvB;\n\t\t\tbreak;\n\t\tcase RTL818X_R8187B_D:\n\t\t\tchip_name = \"RTL8187BvD\";\n\t\t\tpriv->hw_rev = RTL8187BvD;\n\t\t\tbreak;\n\t\tcase RTL818X_R8187B_E:\n\t\t\tchip_name = \"RTL8187BvE\";\n\t\t\tpriv->hw_rev = RTL8187BvE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tchip_name = \"RTL8187BvB (default)\";\n\t\t\tpriv->hw_rev = RTL8187BvB;\n\t\t}\n\t}\n\n\tif (!priv->is_rtl8187b) {\n\t\tfor (i = 0; i < 2; i++) {\n\t\t\teeprom_93cx6_read(&eeprom,\n\t\t\t\t\t  RTL8187_EEPROM_TXPWR_CHAN_6 + i,\n\t\t\t\t\t  &txpwr);\n\t\t\t(*channel++).hw_value = txpwr & 0xFF;\n\t\t\t(*channel++).hw_value = txpwr >> 8;\n\t\t}\n\t} else {\n\t\teeprom_93cx6_read(&eeprom, RTL8187_EEPROM_TXPWR_CHAN_6,\n\t\t\t\t  &txpwr);\n\t\t(*channel++).hw_value = txpwr & 0xFF;\n\n\t\teeprom_93cx6_read(&eeprom, 0x0A, &txpwr);\n\t\t(*channel++).hw_value = txpwr & 0xFF;\n\n\t\teeprom_93cx6_read(&eeprom, 0x1C, &txpwr);\n\t\t(*channel++).hw_value = txpwr & 0xFF;\n\t\t(*channel++).hw_value = txpwr >> 8;\n\t}\n\t \n\tpriv->rfkill_mask = RFKILL_MASK_8187_89_97;\n\tif (product_id == 0x8197 || product_id == 0x8198) {\n\t\teeprom_93cx6_read(&eeprom, RTL8187_EEPROM_SELECT_GPIO, &reg);\n\t\tif (reg & 0xFF00)\n\t\t\tpriv->rfkill_mask = RFKILL_MASK_8198;\n\t}\n\tdev->vif_data_size = sizeof(struct rtl8187_vif);\n\tdev->wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |\n\t\t\t\t      BIT(NL80211_IFTYPE_ADHOC) ;\n\n\twiphy_ext_feature_set(dev->wiphy, NL80211_EXT_FEATURE_CQM_RSSI_LIST);\n\n\tif ((id->driver_info == DEVICE_RTL8187) && priv->is_rtl8187b)\n\t\tprintk(KERN_INFO \"rtl8187: inconsistency between id with OEM\"\n\t\t       \" info!\\n\");\n\n\tpriv->rf = rtl8187_detect_rf(dev);\n\tdev->extra_tx_headroom = (!priv->is_rtl8187b) ?\n\t\t\t\t  sizeof(struct rtl8187_tx_hdr) :\n\t\t\t\t  sizeof(struct rtl8187b_tx_hdr);\n\tif (!priv->is_rtl8187b)\n\t\tdev->queues = 1;\n\telse\n\t\tdev->queues = 4;\n\n\terr = ieee80211_register_hw(dev);\n\tif (err) {\n\t\tprintk(KERN_ERR \"rtl8187: Cannot register device\\n\");\n\t\tgoto err_free_dmabuf;\n\t}\n\tskb_queue_head_init(&priv->b_tx_status.queue);\n\n\twiphy_info(dev->wiphy, \"hwaddr %pM, %s V%d + %s, rfkill mask %d\\n\",\n\t\t   mac_addr, chip_name, priv->asic_rev, priv->rf->name,\n\t\t   priv->rfkill_mask);\n\n#ifdef CONFIG_RTL8187_LEDS\n\teeprom_93cx6_read(&eeprom, 0x3F, &reg);\n\treg &= 0xFF;\n\trtl8187_leds_init(dev, reg);\n#endif\n\trtl8187_rfkill_init(dev);\n\n\treturn 0;\n\n err_free_dmabuf:\n\tkfree(priv->io_dmabuf);\n\tusb_set_intfdata(intf, NULL);\n\tusb_put_dev(udev);\n err_free_dev:\n\tieee80211_free_hw(dev);\n\treturn err;\n}\n\nstatic void rtl8187_disconnect(struct usb_interface *intf)\n{\n\tstruct ieee80211_hw *dev = usb_get_intfdata(intf);\n\tstruct rtl8187_priv *priv;\n\n\tif (!dev)\n\t\treturn;\n\n#ifdef CONFIG_RTL8187_LEDS\n\trtl8187_leds_exit(dev);\n#endif\n\trtl8187_rfkill_exit(dev);\n\tieee80211_unregister_hw(dev);\n\n\tpriv = dev->priv;\n\tusb_reset_device(priv->udev);\n\tusb_put_dev(interface_to_usbdev(intf));\n\tkfree(priv->io_dmabuf);\n\tieee80211_free_hw(dev);\n}\n\nstatic struct usb_driver rtl8187_driver = {\n\t.name\t\t= KBUILD_MODNAME,\n\t.id_table\t= rtl8187_table,\n\t.probe\t\t= rtl8187_probe,\n\t.disconnect\t= rtl8187_disconnect,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(rtl8187_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}