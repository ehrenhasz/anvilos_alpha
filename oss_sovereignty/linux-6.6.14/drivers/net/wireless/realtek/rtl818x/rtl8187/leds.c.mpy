{
  "module_name": "leds.c",
  "hash_id": "5f59eca52fac3dc21d49bdb2744b485a92e67a38736a4869bb6821c8a52cf557",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtl818x/rtl8187/leds.c",
  "human_readable_source": "\n \n\n#ifdef CONFIG_RTL8187_LEDS\n\n#include <net/mac80211.h>\n#include <linux/usb.h>\n#include <linux/eeprom_93cx6.h>\n\n#include \"rtl8187.h\"\n#include \"leds.h\"\n\nstatic void led_turn_on(struct work_struct *work)\n{\n\t \n\tu8 reg;\n\tstruct rtl8187_priv *priv = container_of(work, struct rtl8187_priv,\n\t\t\t\t    led_on.work);\n\tstruct rtl8187_led *led = &priv->led_tx;\n\n\t \n\tif (!priv->vif || priv->vif->type == NL80211_IFTYPE_UNSPECIFIED)\n\t\treturn ;\n\n\t \n\tif (!led->dev)\n\t\treturn;\n\tmutex_lock(&priv->conf_mutex);\n\tswitch (led->ledpin) {\n\tcase LED_PIN_GPIO0:\n\t\trtl818x_iowrite8(priv, &priv->map->GPIO0, 0x01);\n\t\trtl818x_iowrite8(priv, &priv->map->GP_ENABLE, 0x00);\n\t\tbreak;\n\tcase LED_PIN_LED0:\n\t\treg = rtl818x_ioread8(priv, &priv->map->PGSELECT) & ~(1 << 4);\n\t\trtl818x_iowrite8(priv, &priv->map->PGSELECT, reg);\n\t\tbreak;\n\tcase LED_PIN_LED1:\n\t\treg = rtl818x_ioread8(priv, &priv->map->PGSELECT) & ~(1 << 5);\n\t\trtl818x_iowrite8(priv, &priv->map->PGSELECT, reg);\n\t\tbreak;\n\tcase LED_PIN_HW:\n\tdefault:\n\t\tbreak;\n\t}\n\tmutex_unlock(&priv->conf_mutex);\n}\n\nstatic void led_turn_off(struct work_struct *work)\n{\n\t \n\tu8 reg;\n\tstruct rtl8187_priv *priv = container_of(work, struct rtl8187_priv,\n\t\t\t\t    led_off.work);\n\tstruct rtl8187_led *led = &priv->led_tx;\n\n\t \n\tif (!priv->vif || priv->vif->type == NL80211_IFTYPE_UNSPECIFIED)\n\t\treturn ;\n\n\t \n\tif (!led->dev)\n\t\treturn;\n\tmutex_lock(&priv->conf_mutex);\n\tswitch (led->ledpin) {\n\tcase LED_PIN_GPIO0:\n\t\trtl818x_iowrite8(priv, &priv->map->GPIO0, 0x01);\n\t\trtl818x_iowrite8(priv, &priv->map->GP_ENABLE, 0x01);\n\t\tbreak;\n\tcase LED_PIN_LED0:\n\t\treg = rtl818x_ioread8(priv, &priv->map->PGSELECT) | (1 << 4);\n\t\trtl818x_iowrite8(priv, &priv->map->PGSELECT, reg);\n\t\tbreak;\n\tcase LED_PIN_LED1:\n\t\treg = rtl818x_ioread8(priv, &priv->map->PGSELECT) | (1 << 5);\n\t\trtl818x_iowrite8(priv, &priv->map->PGSELECT, reg);\n\t\tbreak;\n\tcase LED_PIN_HW:\n\tdefault:\n\t\tbreak;\n\t}\n\tmutex_unlock(&priv->conf_mutex);\n}\n\n \nstatic void rtl8187_led_brightness_set(struct led_classdev *led_dev,\n\t\t\t\t   enum led_brightness brightness)\n{\n\tstruct rtl8187_led *led = container_of(led_dev, struct rtl8187_led,\n\t\t\t\t\t       led_dev);\n\tstruct ieee80211_hw *hw = led->dev;\n\tstruct rtl8187_priv *priv;\n\tstatic bool radio_on;\n\n\tif (!hw)\n\t\treturn;\n\tpriv = hw->priv;\n\tif (led->is_radio) {\n\t\tif (brightness == LED_FULL) {\n\t\t\tieee80211_queue_delayed_work(hw, &priv->led_on, 0);\n\t\t\tradio_on = true;\n\t\t} else if (radio_on) {\n\t\t\tradio_on = false;\n\t\t\tcancel_delayed_work(&priv->led_on);\n\t\t\tieee80211_queue_delayed_work(hw, &priv->led_off, 0);\n\t\t}\n\t} else if (radio_on) {\n\t\tif (brightness == LED_OFF) {\n\t\t\tieee80211_queue_delayed_work(hw, &priv->led_off, 0);\n\t\t\t \n\t\t\tieee80211_queue_delayed_work(hw, &priv->led_on,\n\t\t\t\t\t\t     HZ / 20);\n\t\t} else\n\t\t\tieee80211_queue_delayed_work(hw, &priv->led_on, 0);\n\t}\n}\n\nstatic int rtl8187_register_led(struct ieee80211_hw *dev,\n\t\t\t\tstruct rtl8187_led *led, const char *name,\n\t\t\t\tconst char *default_trigger, u8 ledpin,\n\t\t\t\tbool is_radio)\n{\n\tint err;\n\tstruct rtl8187_priv *priv = dev->priv;\n\n\tif (led->dev)\n\t\treturn -EEXIST;\n\tif (!default_trigger)\n\t\treturn -EINVAL;\n\tled->dev = dev;\n\tled->ledpin = ledpin;\n\tled->is_radio = is_radio;\n\tstrscpy(led->name, name, sizeof(led->name));\n\n\tled->led_dev.name = led->name;\n\tled->led_dev.default_trigger = default_trigger;\n\tled->led_dev.brightness_set = rtl8187_led_brightness_set;\n\n\terr = led_classdev_register(&priv->udev->dev, &led->led_dev);\n\tif (err) {\n\t\tprintk(KERN_INFO \"LEDs: Failed to register %s\\n\", name);\n\t\tled->dev = NULL;\n\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic void rtl8187_unregister_led(struct rtl8187_led *led)\n{\n\tstruct ieee80211_hw *hw = led->dev;\n\tstruct rtl8187_priv *priv = hw->priv;\n\n\tled_classdev_unregister(&led->led_dev);\n\tflush_delayed_work(&priv->led_off);\n\tled->dev = NULL;\n}\n\nvoid rtl8187_leds_init(struct ieee80211_hw *dev, u16 custid)\n{\n\tstruct rtl8187_priv *priv = dev->priv;\n\tchar name[RTL8187_LED_MAX_NAME_LEN + 1];\n\tu8 ledpin;\n\tint err;\n\n\t \n\tprintk(KERN_INFO \"rtl8187: Customer ID is 0x%02X\\n\", custid);\n\tswitch (custid) {\n\tcase EEPROM_CID_RSVD0:\n\tcase EEPROM_CID_RSVD1:\n\tcase EEPROM_CID_SERCOMM_PS:\n\tcase EEPROM_CID_QMI:\n\tcase EEPROM_CID_DELL:\n\tcase EEPROM_CID_TOSHIBA:\n\t\tledpin = LED_PIN_GPIO0;\n\t\tbreak;\n\tcase EEPROM_CID_ALPHA0:\n\t\tledpin = LED_PIN_LED0;\n\t\tbreak;\n\tcase EEPROM_CID_HW:\n\t\tledpin = LED_PIN_HW;\n\t\tbreak;\n\tdefault:\n\t\tledpin = LED_PIN_GPIO0;\n\t}\n\n\tINIT_DELAYED_WORK(&priv->led_on, led_turn_on);\n\tINIT_DELAYED_WORK(&priv->led_off, led_turn_off);\n\n\tsnprintf(name, sizeof(name),\n\t\t \"rtl8187-%s::radio\", wiphy_name(dev->wiphy));\n\terr = rtl8187_register_led(dev, &priv->led_radio, name,\n\t\t\t ieee80211_get_radio_led_name(dev), ledpin, true);\n\tif (err)\n\t\treturn;\n\n\tsnprintf(name, sizeof(name),\n\t\t \"rtl8187-%s::tx\", wiphy_name(dev->wiphy));\n\terr = rtl8187_register_led(dev, &priv->led_tx, name,\n\t\t\t ieee80211_get_tx_led_name(dev), ledpin, false);\n\tif (err)\n\t\tgoto err_tx;\n\n\tsnprintf(name, sizeof(name),\n\t\t \"rtl8187-%s::rx\", wiphy_name(dev->wiphy));\n\terr = rtl8187_register_led(dev, &priv->led_rx, name,\n\t\t\t ieee80211_get_rx_led_name(dev), ledpin, false);\n\tif (!err)\n\t\treturn;\n\n\t \n\trtl8187_unregister_led(&priv->led_tx);\nerr_tx:\n\trtl8187_unregister_led(&priv->led_radio);\n}\n\nvoid rtl8187_leds_exit(struct ieee80211_hw *dev)\n{\n\tstruct rtl8187_priv *priv = dev->priv;\n\n\trtl8187_unregister_led(&priv->led_radio);\n\trtl8187_unregister_led(&priv->led_rx);\n\trtl8187_unregister_led(&priv->led_tx);\n\tcancel_delayed_work_sync(&priv->led_off);\n\tcancel_delayed_work_sync(&priv->led_on);\n}\n#endif  \n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}