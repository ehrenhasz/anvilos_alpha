{
  "module_name": "dev.c",
  "hash_id": "78958cc84b4900e8c6b6ab5aaf539a4fa535aebd2748fffc1c0e6757744ea404",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtl818x/rtl8180/dev.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/etherdevice.h>\n#include <linux/eeprom_93cx6.h>\n#include <linux/module.h>\n#include <net/mac80211.h>\n\n#include \"rtl8180.h\"\n#include \"rtl8225.h\"\n#include \"sa2400.h\"\n#include \"max2820.h\"\n#include \"grf5101.h\"\n#include \"rtl8225se.h\"\n\nMODULE_AUTHOR(\"Michael Wu <flamingice@sourmilk.net>\");\nMODULE_AUTHOR(\"Andrea Merello <andrea.merello@gmail.com>\");\nMODULE_DESCRIPTION(\"RTL8180 / RTL8185 / RTL8187SE PCI wireless driver\");\nMODULE_LICENSE(\"GPL\");\n\nstatic const struct pci_device_id rtl8180_table[] = {\n\n\t \n\t{ PCI_DEVICE(PCI_VENDOR_ID_REALTEK, 0x8199) },\n\n\t \n\t{ PCI_DEVICE(PCI_VENDOR_ID_REALTEK, 0x8185) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_BELKIN, 0x700f) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_BELKIN, 0x701f) },\n\n\t \n\t{ PCI_DEVICE(PCI_VENDOR_ID_REALTEK, 0x8180) },\n\t{ PCI_DEVICE(0x1799, 0x6001) },\n\t{ PCI_DEVICE(0x1799, 0x6020) },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_DLINK, 0x3300) },\n\t{ PCI_DEVICE(0x1186, 0x3301) },\n\t{ PCI_DEVICE(0x1432, 0x7106) },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(pci, rtl8180_table);\n\nstatic const struct ieee80211_rate rtl818x_rates[] = {\n\t{ .bitrate = 10, .hw_value = 0, },\n\t{ .bitrate = 20, .hw_value = 1, },\n\t{ .bitrate = 55, .hw_value = 2, },\n\t{ .bitrate = 110, .hw_value = 3, },\n\t{ .bitrate = 60, .hw_value = 4, },\n\t{ .bitrate = 90, .hw_value = 5, },\n\t{ .bitrate = 120, .hw_value = 6, },\n\t{ .bitrate = 180, .hw_value = 7, },\n\t{ .bitrate = 240, .hw_value = 8, },\n\t{ .bitrate = 360, .hw_value = 9, },\n\t{ .bitrate = 480, .hw_value = 10, },\n\t{ .bitrate = 540, .hw_value = 11, },\n};\n\nstatic const struct ieee80211_channel rtl818x_channels[] = {\n\t{ .center_freq = 2412 },\n\t{ .center_freq = 2417 },\n\t{ .center_freq = 2422 },\n\t{ .center_freq = 2427 },\n\t{ .center_freq = 2432 },\n\t{ .center_freq = 2437 },\n\t{ .center_freq = 2442 },\n\t{ .center_freq = 2447 },\n\t{ .center_freq = 2452 },\n\t{ .center_freq = 2457 },\n\t{ .center_freq = 2462 },\n\t{ .center_freq = 2467 },\n\t{ .center_freq = 2472 },\n\t{ .center_freq = 2484 },\n};\n\n \n\nstatic const int rtl8187se_queues_map[RTL8187SE_NR_TX_QUEUES] = {5, 4, 3, 2, 7};\n\n \n\nstatic const int rtl8180_queues_map[RTL8180_NR_TX_QUEUES] = {4, 7};\n\n \nstatic const u8 rtl8187se_lna_gain[4] = {02, 17, 29, 39};\n\nvoid rtl8180_write_phy(struct ieee80211_hw *dev, u8 addr, u32 data)\n{\n\tstruct rtl8180_priv *priv = dev->priv;\n\tint i = 10;\n\tu32 buf;\n\n\tbuf = (data << 8) | addr;\n\n\trtl818x_iowrite32(priv, (__le32 __iomem *)&priv->map->PHY[0], buf | 0x80);\n\twhile (i--) {\n\t\trtl818x_iowrite32(priv, (__le32 __iomem *)&priv->map->PHY[0], buf);\n\t\tif (rtl818x_ioread8(priv, &priv->map->PHY[2]) == (data & 0xFF))\n\t\t\treturn;\n\t}\n}\n\nstatic void rtl8180_handle_rx(struct ieee80211_hw *dev)\n{\n\tstruct rtl8180_priv *priv = dev->priv;\n\tstruct rtl818x_rx_cmd_desc *cmd_desc;\n\tunsigned int count = 32;\n\tu8 agc, sq;\n\ts8 signal = 1;\n\tdma_addr_t mapping;\n\n\twhile (count--) {\n\t\tvoid *entry = priv->rx_ring + priv->rx_idx * priv->rx_ring_sz;\n\t\tstruct sk_buff *skb = priv->rx_buf[priv->rx_idx];\n\t\tu32 flags, flags2, flags3 = 0;\n\t\tu64 tsft;\n\n\t\tif (priv->chip_family == RTL818X_CHIP_FAMILY_RTL8187SE) {\n\t\t\tstruct rtl8187se_rx_desc *desc = entry;\n\n\t\t\tflags = le32_to_cpu(desc->flags);\n\t\t\t \n\t\t\trmb();\n\t\t\tflags3 = le32_to_cpu(desc->flags3);\n\t\t\tflags2 = le32_to_cpu(desc->flags2);\n\t\t\ttsft = le64_to_cpu(desc->tsft);\n\t\t} else {\n\t\t\tstruct rtl8180_rx_desc *desc = entry;\n\n\t\t\tflags = le32_to_cpu(desc->flags);\n\t\t\t \n\t\t\trmb();\n\t\t\tflags2 = le32_to_cpu(desc->flags2);\n\t\t\ttsft = le64_to_cpu(desc->tsft);\n\t\t}\n\n\t\tif (flags & RTL818X_RX_DESC_FLAG_OWN)\n\t\t\treturn;\n\n\t\tif (unlikely(flags & (RTL818X_RX_DESC_FLAG_DMA_FAIL |\n\t\t\t\t      RTL818X_RX_DESC_FLAG_FOF |\n\t\t\t\t      RTL818X_RX_DESC_FLAG_RX_ERR)))\n\t\t\tgoto done;\n\t\telse {\n\t\t\tstruct ieee80211_rx_status rx_status = {0};\n\t\t\tstruct sk_buff *new_skb = dev_alloc_skb(MAX_RX_SIZE);\n\n\t\t\tif (unlikely(!new_skb))\n\t\t\t\tgoto done;\n\n\t\t\tmapping = dma_map_single(&priv->pdev->dev,\n\t\t\t\t\t\t skb_tail_pointer(new_skb),\n\t\t\t\t\t\t MAX_RX_SIZE, DMA_FROM_DEVICE);\n\n\t\t\tif (dma_mapping_error(&priv->pdev->dev, mapping)) {\n\t\t\t\tkfree_skb(new_skb);\n\t\t\t\tdev_err(&priv->pdev->dev, \"RX DMA map error\\n\");\n\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tdma_unmap_single(&priv->pdev->dev,\n\t\t\t\t\t *((dma_addr_t *)skb->cb),\n\t\t\t\t\t MAX_RX_SIZE, DMA_FROM_DEVICE);\n\t\t\tskb_put(skb, flags & 0xFFF);\n\n\t\t\trx_status.antenna = (flags2 >> 15) & 1;\n\t\t\trx_status.rate_idx = (flags >> 20) & 0xF;\n\t\t\tagc = (flags2 >> 17) & 0x7F;\n\n\t\t\tswitch (priv->chip_family) {\n\t\t\tcase RTL818X_CHIP_FAMILY_RTL8185:\n\t\t\t\tif (rx_status.rate_idx > 3)\n\t\t\t\t\tsignal = -clamp_t(u8, agc, 25, 90) - 9;\n\t\t\t\telse\n\t\t\t\t\tsignal = -clamp_t(u8, agc, 30, 95);\n\t\t\t\tbreak;\n\t\t\tcase RTL818X_CHIP_FAMILY_RTL8180:\n\t\t\t\tsq = flags2 & 0xff;\n\t\t\t\tsignal = priv->rf->calc_rssi(agc, sq);\n\t\t\t\tbreak;\n\t\t\tcase RTL818X_CHIP_FAMILY_RTL8187SE:\n\t\t\t\t \n\t\t\t\tif (rx_status.rate_idx > 3) {\n\t\t\t\t\tsignal = (s8)((flags3 >> 16) & 0xff);\n\t\t\t\t\tsignal = signal / 2 - 41;\n\t\t\t\t} else {\n\t\t\t\t\tint idx, bb;\n\n\t\t\t\t\tidx = (agc & 0x60) >> 5;\n\t\t\t\t\tbb = (agc & 0x1F) * 2;\n\t\t\t\t\t \n\t\t\t\t\tsignal = 4 - bb - rtl8187se_lna_gain[idx];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trx_status.signal = signal;\n\t\t\trx_status.freq = dev->conf.chandef.chan->center_freq;\n\t\t\trx_status.band = dev->conf.chandef.chan->band;\n\t\t\trx_status.mactime = tsft;\n\t\t\trx_status.flag |= RX_FLAG_MACTIME_START;\n\t\t\tif (flags & RTL818X_RX_DESC_FLAG_SPLCP)\n\t\t\t\trx_status.enc_flags |= RX_ENC_FLAG_SHORTPRE;\n\t\t\tif (flags & RTL818X_RX_DESC_FLAG_CRC32_ERR)\n\t\t\t\trx_status.flag |= RX_FLAG_FAILED_FCS_CRC;\n\n\t\t\tmemcpy(IEEE80211_SKB_RXCB(skb), &rx_status, sizeof(rx_status));\n\t\t\tieee80211_rx_irqsafe(dev, skb);\n\n\t\t\tskb = new_skb;\n\t\t\tpriv->rx_buf[priv->rx_idx] = skb;\n\t\t\t*((dma_addr_t *) skb->cb) = mapping;\n\t\t}\n\n\tdone:\n\t\tcmd_desc = entry;\n\t\tcmd_desc->rx_buf = cpu_to_le32(*((dma_addr_t *)skb->cb));\n\t\tcmd_desc->flags = cpu_to_le32(RTL818X_RX_DESC_FLAG_OWN |\n\t\t\t\t\t   MAX_RX_SIZE);\n\t\tif (priv->rx_idx == 31)\n\t\t\tcmd_desc->flags |=\n\t\t\t\tcpu_to_le32(RTL818X_RX_DESC_FLAG_EOR);\n\t\tpriv->rx_idx = (priv->rx_idx + 1) % 32;\n\t}\n}\n\nstatic void rtl8180_handle_tx(struct ieee80211_hw *dev, unsigned int prio)\n{\n\tstruct rtl8180_priv *priv = dev->priv;\n\tstruct rtl8180_tx_ring *ring = &priv->tx_ring[prio];\n\n\twhile (skb_queue_len(&ring->queue)) {\n\t\tstruct rtl8180_tx_desc *entry = &ring->desc[ring->idx];\n\t\tstruct sk_buff *skb;\n\t\tstruct ieee80211_tx_info *info;\n\t\tu32 flags = le32_to_cpu(entry->flags);\n\n\t\tif (flags & RTL818X_TX_DESC_FLAG_OWN)\n\t\t\treturn;\n\n\t\tring->idx = (ring->idx + 1) % ring->entries;\n\t\tskb = __skb_dequeue(&ring->queue);\n\t\tdma_unmap_single(&priv->pdev->dev, le32_to_cpu(entry->tx_buf),\n\t\t\t\t skb->len, DMA_TO_DEVICE);\n\n\t\tinfo = IEEE80211_SKB_CB(skb);\n\t\tieee80211_tx_info_clear_status(info);\n\n\t\tif (!(info->flags & IEEE80211_TX_CTL_NO_ACK) &&\n\t\t    (flags & RTL818X_TX_DESC_FLAG_TX_OK))\n\t\t\tinfo->flags |= IEEE80211_TX_STAT_ACK;\n\n\t\tinfo->status.rates[0].count = (flags & 0xFF) + 1;\n\n\t\tieee80211_tx_status_irqsafe(dev, skb);\n\t\tif (ring->entries - skb_queue_len(&ring->queue) == 2)\n\t\t\tieee80211_wake_queue(dev, prio);\n\t}\n}\n\nstatic irqreturn_t rtl8187se_interrupt(int irq, void *dev_id)\n{\n\tstruct ieee80211_hw *dev = dev_id;\n\tstruct rtl8180_priv *priv = dev->priv;\n\tu32 reg;\n\tunsigned long flags;\n\tstatic int desc_err;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\t \n\treg = rtl818x_ioread32(priv, &priv->map->INT_STATUS_SE);\n\tif (unlikely(reg == 0xFFFFFFFF)) {\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\trtl818x_iowrite32(priv, &priv->map->INT_STATUS_SE, reg);\n\n\tif (reg & IMR_TIMEOUT1)\n\t\trtl818x_iowrite32(priv, &priv->map->INT_TIMEOUT, 0);\n\n\tif (reg & (IMR_TBDOK | IMR_TBDER))\n\t\trtl8180_handle_tx(dev, 4);\n\n\tif (reg & (IMR_TVODOK | IMR_TVODER))\n\t\trtl8180_handle_tx(dev, 0);\n\n\tif (reg & (IMR_TVIDOK | IMR_TVIDER))\n\t\trtl8180_handle_tx(dev, 1);\n\n\tif (reg & (IMR_TBEDOK | IMR_TBEDER))\n\t\trtl8180_handle_tx(dev, 2);\n\n\tif (reg & (IMR_TBKDOK | IMR_TBKDER))\n\t\trtl8180_handle_tx(dev, 3);\n\n\tif (reg & (IMR_ROK | IMR_RER | RTL818X_INT_SE_RX_DU | IMR_RQOSOK))\n\t\trtl8180_handle_rx(dev);\n\t \n\tif ((reg & RTL818X_INT_SE_RX_DU) && desc_err++ > 2)\n\t\tif (net_ratelimit())\n\t\t\twiphy_err(dev->wiphy, \"No RX DMA Descriptor avail\\n\");\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t rtl8180_interrupt(int irq, void *dev_id)\n{\n\tstruct ieee80211_hw *dev = dev_id;\n\tstruct rtl8180_priv *priv = dev->priv;\n\tu16 reg;\n\n\tspin_lock(&priv->lock);\n\treg = rtl818x_ioread16(priv, &priv->map->INT_STATUS);\n\tif (unlikely(reg == 0xFFFF)) {\n\t\tspin_unlock(&priv->lock);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\trtl818x_iowrite16(priv, &priv->map->INT_STATUS, reg);\n\n\tif (reg & (RTL818X_INT_TXB_OK | RTL818X_INT_TXB_ERR))\n\t\trtl8180_handle_tx(dev, 1);\n\n\tif (reg & (RTL818X_INT_TXL_OK | RTL818X_INT_TXL_ERR))\n\t\trtl8180_handle_tx(dev, 0);\n\n\tif (reg & (RTL818X_INT_RX_OK | RTL818X_INT_RX_ERR))\n\t\trtl8180_handle_rx(dev);\n\n\tspin_unlock(&priv->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void rtl8180_tx(struct ieee80211_hw *dev,\n\t\t       struct ieee80211_tx_control *control,\n\t\t       struct sk_buff *skb)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tstruct rtl8180_priv *priv = dev->priv;\n\tstruct rtl8180_tx_ring *ring;\n\tstruct rtl8180_tx_desc *entry;\n\tunsigned int prio = 0;\n\tunsigned long flags;\n\tunsigned int idx, hw_prio;\n\n\tdma_addr_t mapping;\n\tu32 tx_flags;\n\tu8 rc_flags;\n\tu16 plcp_len = 0;\n\t__le16 rts_duration = 0;\n\t \n\tu16 frame_duration = 0;\n\n\t \n\tif (dev->queues > IEEE80211_AC_BK)\n\t\tprio = skb_get_queue_mapping(skb);\n\tring = &priv->tx_ring[prio];\n\n\tmapping = dma_map_single(&priv->pdev->dev, skb->data, skb->len,\n\t\t\t\t DMA_TO_DEVICE);\n\n\tif (dma_mapping_error(&priv->pdev->dev, mapping)) {\n\t\tkfree_skb(skb);\n\t\tdev_err(&priv->pdev->dev, \"TX DMA mapping error\\n\");\n\t\treturn;\n\t}\n\n\ttx_flags = RTL818X_TX_DESC_FLAG_OWN | RTL818X_TX_DESC_FLAG_FS |\n\t\t   RTL818X_TX_DESC_FLAG_LS |\n\t\t   (ieee80211_get_tx_rate(dev, info)->hw_value << 24) |\n\t\t   skb->len;\n\n\tif (priv->chip_family != RTL818X_CHIP_FAMILY_RTL8180)\n\t\ttx_flags |= RTL818X_TX_DESC_FLAG_DMA |\n\t\t\t    RTL818X_TX_DESC_FLAG_NO_ENC;\n\n\trc_flags = info->control.rates[0].flags;\n\n\t \n\tif (rc_flags & IEEE80211_TX_RC_USE_RTS_CTS) {\n\t\ttx_flags |= RTL818X_TX_DESC_FLAG_RTS;\n\t\ttx_flags |= ieee80211_get_rts_cts_rate(dev, info)->hw_value << 19;\n\t\trts_duration = ieee80211_rts_duration(dev, priv->vif,\n\t\t\t\t\t\tskb->len, info);\n\t} else if (rc_flags & IEEE80211_TX_RC_USE_CTS_PROTECT) {\n\t\ttx_flags |= RTL818X_TX_DESC_FLAG_RTS | RTL818X_TX_DESC_FLAG_CTS;\n\t\ttx_flags |= ieee80211_get_rts_cts_rate(dev, info)->hw_value << 19;\n\t\trts_duration = ieee80211_ctstoself_duration(dev, priv->vif,\n\t\t\t\t\t\tskb->len, info);\n\t}\n\n\tif (priv->chip_family == RTL818X_CHIP_FAMILY_RTL8180) {\n\t\tunsigned int remainder;\n\n\t\tplcp_len = DIV_ROUND_UP(16 * (skb->len + 4),\n\t\t\t\t(ieee80211_get_tx_rate(dev, info)->bitrate * 2) / 10);\n\t\tremainder = (16 * (skb->len + 4)) %\n\t\t\t    ((ieee80211_get_tx_rate(dev, info)->bitrate * 2) / 10);\n\t\tif (remainder <= 6)\n\t\t\tplcp_len |= 1 << 15;\n\t}\n\n\tif (priv->chip_family == RTL818X_CHIP_FAMILY_RTL8187SE) {\n\t\t__le16 duration;\n\t\t \n\t\tduration = ieee80211_generic_frame_duration(dev, priv->vif,\n\t\t\t\t\tNL80211_BAND_2GHZ, skb->len,\n\t\t\t\t\tieee80211_get_tx_rate(dev, info));\n\n\t\tframe_duration =  priv->ack_time + le16_to_cpu(duration);\n\t}\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tif (info->flags & IEEE80211_TX_CTL_ASSIGN_SEQ) {\n\t\tif (info->flags & IEEE80211_TX_CTL_FIRST_FRAGMENT)\n\t\t\tpriv->seqno += 0x10;\n\t\thdr->seq_ctrl &= cpu_to_le16(IEEE80211_SCTL_FRAG);\n\t\thdr->seq_ctrl |= cpu_to_le16(priv->seqno);\n\t}\n\n\tidx = (ring->idx + skb_queue_len(&ring->queue)) % ring->entries;\n\tentry = &ring->desc[idx];\n\n\tif (priv->chip_family == RTL818X_CHIP_FAMILY_RTL8187SE) {\n\t\tentry->frame_duration = cpu_to_le16(frame_duration);\n\t\tentry->frame_len_se = cpu_to_le16(skb->len);\n\n\t\t \n\t\tentry->flags3 = cpu_to_le16(1<<4);\n\t} else\n\t\tentry->frame_len = cpu_to_le32(skb->len);\n\n\tentry->rts_duration = rts_duration;\n\tentry->plcp_len = cpu_to_le16(plcp_len);\n\tentry->tx_buf = cpu_to_le32(mapping);\n\n\tentry->retry_limit = info->control.rates[0].count - 1;\n\n\t \n\twmb();\n\tentry->flags = cpu_to_le32(tx_flags);\n\t \n\twmb();\n\n\t__skb_queue_tail(&ring->queue, skb);\n\tif (ring->entries - skb_queue_len(&ring->queue) < 2)\n\t\tieee80211_stop_queue(dev, prio);\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tif (priv->chip_family == RTL818X_CHIP_FAMILY_RTL8187SE) {\n\t\t \n\t\thw_prio = rtl8187se_queues_map[prio];\n\t\trtl818x_iowrite8(priv, &priv->map->TX_DMA_POLLING,\n\t\t\t (1 << hw_prio));\n\t} else {\n\t\thw_prio = rtl8180_queues_map[prio];\n\t\trtl818x_iowrite8(priv, &priv->map->TX_DMA_POLLING,\n\t\t\t (1 << hw_prio) |  \n\t\t\t (1<<1) | (1<<2)); \n\t}\n}\n\nstatic void rtl8180_set_anaparam3(struct rtl8180_priv *priv, u16 anaparam3)\n{\n\tu8 reg;\n\n\trtl818x_iowrite8(priv, &priv->map->EEPROM_CMD,\n\t\t\t RTL818X_EEPROM_CMD_CONFIG);\n\n\treg = rtl818x_ioread8(priv, &priv->map->CONFIG3);\n\trtl818x_iowrite8(priv, &priv->map->CONFIG3,\n\t\t reg | RTL818X_CONFIG3_ANAPARAM_WRITE);\n\n\trtl818x_iowrite16(priv, &priv->map->ANAPARAM3, anaparam3);\n\n\trtl818x_iowrite8(priv, &priv->map->CONFIG3,\n\t\t reg & ~RTL818X_CONFIG3_ANAPARAM_WRITE);\n\n\trtl818x_iowrite8(priv, &priv->map->EEPROM_CMD,\n\t\t\t RTL818X_EEPROM_CMD_NORMAL);\n}\n\nvoid rtl8180_set_anaparam2(struct rtl8180_priv *priv, u32 anaparam2)\n{\n\tu8 reg;\n\n\trtl818x_iowrite8(priv, &priv->map->EEPROM_CMD,\n\t\t\t RTL818X_EEPROM_CMD_CONFIG);\n\n\treg = rtl818x_ioread8(priv, &priv->map->CONFIG3);\n\trtl818x_iowrite8(priv, &priv->map->CONFIG3,\n\t\t reg | RTL818X_CONFIG3_ANAPARAM_WRITE);\n\n\trtl818x_iowrite32(priv, &priv->map->ANAPARAM2, anaparam2);\n\n\trtl818x_iowrite8(priv, &priv->map->CONFIG3,\n\t\t reg & ~RTL818X_CONFIG3_ANAPARAM_WRITE);\n\n\trtl818x_iowrite8(priv, &priv->map->EEPROM_CMD,\n\t\t\t RTL818X_EEPROM_CMD_NORMAL);\n}\n\nvoid rtl8180_set_anaparam(struct rtl8180_priv *priv, u32 anaparam)\n{\n\tu8 reg;\n\n\trtl818x_iowrite8(priv, &priv->map->EEPROM_CMD, RTL818X_EEPROM_CMD_CONFIG);\n\treg = rtl818x_ioread8(priv, &priv->map->CONFIG3);\n\trtl818x_iowrite8(priv, &priv->map->CONFIG3,\n\t\t reg | RTL818X_CONFIG3_ANAPARAM_WRITE);\n\trtl818x_iowrite32(priv, &priv->map->ANAPARAM, anaparam);\n\trtl818x_iowrite8(priv, &priv->map->CONFIG3,\n\t\t reg & ~RTL818X_CONFIG3_ANAPARAM_WRITE);\n\trtl818x_iowrite8(priv, &priv->map->EEPROM_CMD, RTL818X_EEPROM_CMD_NORMAL);\n}\n\nstatic void rtl8187se_mac_config(struct ieee80211_hw *dev)\n{\n\tstruct rtl8180_priv *priv = dev->priv;\n\tu8 reg;\n\n\trtl818x_iowrite32(priv, REG_ADDR4(0x1F0), 0);\n\trtl818x_ioread32(priv, REG_ADDR4(0x1F0));\n\trtl818x_iowrite32(priv, REG_ADDR4(0x1F4), 0);\n\trtl818x_ioread32(priv, REG_ADDR4(0x1F4));\n\trtl818x_iowrite8(priv, REG_ADDR1(0x1F8), 0);\n\trtl818x_ioread8(priv, REG_ADDR1(0x1F8));\n\t \n\treg = rtl818x_ioread8(priv, &priv->map->PHY_PR);\n\trtl818x_iowrite8(priv, &priv->map->PHY_PR, reg | 0x04);\n\t \n\trtl818x_iowrite16(priv, PI_DATA_REG, 0x1000);\n\trtl818x_iowrite16(priv, SI_DATA_REG, 0x1000);\n\t \n\trtl818x_iowrite16(priv, REG_ADDR2(0x370), 0x0560);\n\trtl818x_iowrite16(priv, REG_ADDR2(0x372), 0x0560);\n\trtl818x_iowrite16(priv, REG_ADDR2(0x374), 0x0DA4);\n\trtl818x_iowrite16(priv, REG_ADDR2(0x376), 0x0DA4);\n\trtl818x_iowrite16(priv, REG_ADDR2(0x378), 0x0560);\n\trtl818x_iowrite16(priv, REG_ADDR2(0x37A), 0x0560);\n\trtl818x_iowrite16(priv, REG_ADDR2(0x37C), 0x00EC);\n\trtl818x_iowrite16(priv, REG_ADDR2(0x37E), 0x00EC);\n\trtl818x_iowrite8(priv, REG_ADDR1(0x24E), 0x01);\n\t \n\trtl818x_iowrite8(priv, REG_ADDR1(0x0A), 0x72);\n}\n\nstatic void rtl8187se_set_antenna_config(struct ieee80211_hw *dev, u8 def_ant,\n\t\t\t\t\t bool diversity)\n{\n\tstruct rtl8180_priv *priv = dev->priv;\n\n\trtl8225_write_phy_cck(dev, 0x0C, 0x09);\n\tif (diversity) {\n\t\tif (def_ant == 1) {\n\t\t\trtl818x_iowrite8(priv, &priv->map->TX_ANTENNA, 0x00);\n\t\t\trtl8225_write_phy_cck(dev, 0x11, 0xBB);\n\t\t\trtl8225_write_phy_cck(dev, 0x01, 0xC7);\n\t\t\trtl8225_write_phy_ofdm(dev, 0x0D, 0x54);\n\t\t\trtl8225_write_phy_ofdm(dev, 0x18, 0xB2);\n\t\t} else {  \n\t\t\trtl818x_iowrite8(priv, &priv->map->TX_ANTENNA, 0x03);\n\t\t\trtl8225_write_phy_cck(dev, 0x11, 0x9B);\n\t\t\trtl8225_write_phy_cck(dev, 0x01, 0xC7);\n\t\t\trtl8225_write_phy_ofdm(dev, 0x0D, 0x5C);\n\t\t\trtl8225_write_phy_ofdm(dev, 0x18, 0xB2);\n\t\t}\n\t} else {  \n\t\tif (def_ant == 1) {\n\t\t\trtl818x_iowrite8(priv, &priv->map->TX_ANTENNA, 0x00);\n\t\t\trtl8225_write_phy_cck(dev, 0x11, 0xBB);\n\t\t\trtl8225_write_phy_cck(dev, 0x01, 0x47);\n\t\t\trtl8225_write_phy_ofdm(dev, 0x0D, 0x54);\n\t\t\trtl8225_write_phy_ofdm(dev, 0x18, 0x32);\n\t\t} else {  \n\t\t\trtl818x_iowrite8(priv, &priv->map->TX_ANTENNA, 0x03);\n\t\t\trtl8225_write_phy_cck(dev, 0x11, 0x9B);\n\t\t\trtl8225_write_phy_cck(dev, 0x01, 0x47);\n\t\t\trtl8225_write_phy_ofdm(dev, 0x0D, 0x5C);\n\t\t\trtl8225_write_phy_ofdm(dev, 0x18, 0x32);\n\t\t}\n\t}\n\t \n}\n\nstatic void rtl8180_int_enable(struct ieee80211_hw *dev)\n{\n\tstruct rtl8180_priv *priv = dev->priv;\n\n\tif (priv->chip_family == RTL818X_CHIP_FAMILY_RTL8187SE) {\n\t\trtl818x_iowrite32(priv, &priv->map->IMR,\n\t\t\t  IMR_TBDER | IMR_TBDOK |\n\t\t\t  IMR_TVODER | IMR_TVODOK |\n\t\t\t  IMR_TVIDER | IMR_TVIDOK |\n\t\t\t  IMR_TBEDER | IMR_TBEDOK |\n\t\t\t  IMR_TBKDER | IMR_TBKDOK |\n\t\t\t  IMR_RDU | IMR_RER |\n\t\t\t  IMR_ROK | IMR_RQOSOK);\n\t} else {\n\t\trtl818x_iowrite16(priv, &priv->map->INT_MASK, 0xFFFF);\n\t}\n}\n\nstatic void rtl8180_int_disable(struct ieee80211_hw *dev)\n{\n\tstruct rtl8180_priv *priv = dev->priv;\n\n\tif (priv->chip_family == RTL818X_CHIP_FAMILY_RTL8187SE) {\n\t\trtl818x_iowrite32(priv, &priv->map->IMR, 0);\n\t} else {\n\t\trtl818x_iowrite16(priv, &priv->map->INT_MASK, 0);\n\t}\n}\n\nstatic void rtl8180_conf_basic_rates(struct ieee80211_hw *dev,\n\t\t\t    u32 basic_mask)\n{\n\tstruct rtl8180_priv *priv = dev->priv;\n\tu16 reg;\n\tu32 resp_mask;\n\tu8 basic_max;\n\tu8 resp_max, resp_min;\n\n\tresp_mask = basic_mask;\n\t \n\tif ((resp_mask & 0xf) == resp_mask)\n\t\tresp_mask |= 0x150;  \n\n\tswitch (priv->chip_family) {\n\n\tcase RTL818X_CHIP_FAMILY_RTL8180:\n\t\t \n\t\tbasic_max = fls(basic_mask) - 1;\n\t\treg = rtl818x_ioread16(priv, &priv->map->BRSR);\n\t\treg &= ~3;\n\t\treg |= basic_max;\n\t\trtl818x_iowrite16(priv, &priv->map->BRSR, reg);\n\t\tbreak;\n\n\tcase RTL818X_CHIP_FAMILY_RTL8185:\n\t\tresp_max = fls(resp_mask) - 1;\n\t\tresp_min = ffs(resp_mask) - 1;\n\t\t \n\t\trtl818x_iowrite16(priv, &priv->map->BRSR, basic_mask);\n\t\trtl818x_iowrite8(priv, &priv->map->RESP_RATE, (resp_max << 4) |\n\t\t\t\tresp_min);\n\t\tbreak;\n\n\tcase RTL818X_CHIP_FAMILY_RTL8187SE:\n\t\t \n\t\trtl818x_iowrite16(priv, &priv->map->BRSR_8187SE, resp_mask);\n\t\tbreak;\n\t}\n}\n\nstatic void rtl8180_config_cardbus(struct ieee80211_hw *dev)\n{\n\tstruct rtl8180_priv *priv = dev->priv;\n\tu16 reg16;\n\tu8 reg8;\n\n\treg8 = rtl818x_ioread8(priv, &priv->map->CONFIG3);\n\treg8 |= 1 << 1;\n\trtl818x_iowrite8(priv, &priv->map->CONFIG3, reg8);\n\n\tif (priv->chip_family == RTL818X_CHIP_FAMILY_RTL8187SE) {\n\t\trtl818x_iowrite16(priv, FEMR_SE, 0xffff);\n\t} else {\n\t\treg16 = rtl818x_ioread16(priv, &priv->map->FEMR);\n\t\treg16 |= (1 << 15) | (1 << 14) | (1 << 4);\n\t\trtl818x_iowrite16(priv, &priv->map->FEMR, reg16);\n\t}\n\n}\n\nstatic int rtl8180_init_hw(struct ieee80211_hw *dev)\n{\n\tstruct rtl8180_priv *priv = dev->priv;\n\tu16 reg;\n\tu32 reg32;\n\n\trtl818x_iowrite8(priv, &priv->map->CMD, 0);\n\trtl818x_ioread8(priv, &priv->map->CMD);\n\tmsleep(10);\n\n\t \n\trtl8180_int_disable(dev);\n\trtl818x_ioread8(priv, &priv->map->CMD);\n\n\treg = rtl818x_ioread8(priv, &priv->map->CMD);\n\treg &= (1 << 1);\n\treg |= RTL818X_CMD_RESET;\n\trtl818x_iowrite8(priv, &priv->map->CMD, RTL818X_CMD_RESET);\n\trtl818x_ioread8(priv, &priv->map->CMD);\n\tmsleep(200);\n\n\t \n\tif (rtl818x_ioread8(priv, &priv->map->CMD) & RTL818X_CMD_RESET) {\n\t\twiphy_err(dev->wiphy, \"reset timeout!\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\trtl818x_iowrite8(priv, &priv->map->EEPROM_CMD, RTL818X_EEPROM_CMD_LOAD);\n\trtl818x_ioread8(priv, &priv->map->CMD);\n\tmsleep(200);\n\n\tif (rtl818x_ioread8(priv, &priv->map->CONFIG3) & (1 << 3)) {\n\t\trtl8180_config_cardbus(dev);\n\t}\n\n\tif (priv->chip_family == RTL818X_CHIP_FAMILY_RTL8187SE)\n\t\trtl818x_iowrite8(priv, &priv->map->MSR, RTL818X_MSR_ENEDCA);\n\telse\n\t\trtl818x_iowrite8(priv, &priv->map->MSR, 0);\n\n\tif (priv->chip_family == RTL818X_CHIP_FAMILY_RTL8180)\n\t\trtl8180_set_anaparam(priv, priv->anaparam);\n\n\trtl818x_iowrite32(priv, &priv->map->RDSAR, priv->rx_ring_dma);\n\t \n\tif (priv->chip_family != RTL818X_CHIP_FAMILY_RTL8187SE) {\n\t\trtl818x_iowrite32(priv, &priv->map->TBDA,\n\t\t\t\t  priv->tx_ring[1].dma);\n\t\trtl818x_iowrite32(priv, &priv->map->TLPDA,\n\t\t\t\t  priv->tx_ring[0].dma);\n\t} else {\n\t\trtl818x_iowrite32(priv, &priv->map->TBDA,\n\t\t\t\t  priv->tx_ring[4].dma);\n\t\trtl818x_iowrite32(priv, &priv->map->TVODA,\n\t\t\t\t  priv->tx_ring[0].dma);\n\t\trtl818x_iowrite32(priv, &priv->map->TVIDA,\n\t\t\t\t  priv->tx_ring[1].dma);\n\t\trtl818x_iowrite32(priv, &priv->map->TBEDA,\n\t\t\t\t  priv->tx_ring[2].dma);\n\t\trtl818x_iowrite32(priv, &priv->map->TBKDA,\n\t\t\t\t  priv->tx_ring[3].dma);\n\t}\n\n\t \n\trtl818x_iowrite8(priv, &priv->map->EEPROM_CMD, RTL818X_EEPROM_CMD_CONFIG);\n\treg = rtl818x_ioread8(priv, &priv->map->CONFIG2);\n\trtl818x_iowrite8(priv, &priv->map->CONFIG2, reg & ~(1 << 3));\n\tif (priv->chip_family == RTL818X_CHIP_FAMILY_RTL8185) {\n\t\treg = rtl818x_ioread8(priv, &priv->map->CONFIG2);\n\t\trtl818x_iowrite8(priv, &priv->map->CONFIG2, reg | (1 << 4));\n\t}\n\trtl818x_iowrite8(priv, &priv->map->EEPROM_CMD, RTL818X_EEPROM_CMD_NORMAL);\n\n\t \n\n\t \n\n\trtl818x_iowrite32(priv, &priv->map->INT_TIMEOUT, 0);\n\n\tif (priv->chip_family != RTL818X_CHIP_FAMILY_RTL8180) {\n\t\trtl818x_iowrite8(priv, &priv->map->WPA_CONF, 0);\n\t\trtl818x_iowrite8(priv, &priv->map->RATE_FALLBACK, 0);\n\t} else {\n\t\trtl818x_iowrite8(priv, &priv->map->SECURITY, 0);\n\n\t\trtl818x_iowrite8(priv, &priv->map->PHY_DELAY, 0x6);\n\t\trtl818x_iowrite8(priv, &priv->map->CARRIER_SENSE_COUNTER, 0x4C);\n\t}\n\n\tif (priv->chip_family == RTL818X_CHIP_FAMILY_RTL8185) {\n\t\t \n\t\treg = rtl818x_ioread8(priv, &priv->map->GP_ENABLE);\n\t\trtl818x_iowrite8(priv, &priv->map->GP_ENABLE, reg & ~(1 << 6));\n\t\trtl818x_iowrite8(priv, &priv->map->EEPROM_CMD, RTL818X_EEPROM_CMD_CONFIG);\n\t\treg = rtl818x_ioread8(priv, &priv->map->CONFIG3);\n\t\trtl818x_iowrite8(priv, &priv->map->CONFIG3, reg | (1 << 2));\n\t\trtl818x_iowrite8(priv, &priv->map->EEPROM_CMD, RTL818X_EEPROM_CMD_NORMAL);\n\t\t \n\t\tif (priv->map_pio) {\n\t\t\tu8 reg;\n\n\t\t\treg = rtl818x_ioread8(priv, &priv->map->PGSELECT);\n\t\t\trtl818x_iowrite8(priv, &priv->map->PGSELECT, reg | 1);\n\t\t\trtl818x_iowrite8(priv, REG_ADDR1(0xff), 0x35);\n\t\t\trtl818x_iowrite8(priv, &priv->map->PGSELECT, reg);\n\t\t} else\n\t\t\trtl818x_iowrite8(priv, REG_ADDR1(0x1ff), 0x35);\n\t}\n\n\tif (priv->chip_family == RTL818X_CHIP_FAMILY_RTL8187SE) {\n\n\t\t \n\t\trtl818x_iowrite16(priv, ARFR, 0xFFF);\n\t\trtl818x_ioread16(priv, ARFR);\n\n\t\t \n\t\trtl818x_iowrite8(priv, &priv->map->TPPOLL_STOP,\n\t\t\t       RTL818x_TPPOLL_STOP_MG | RTL818x_TPPOLL_STOP_HI);\n\n\t\trtl818x_iowrite8(priv, &priv->map->ACM_CONTROL, 0x00);\n\t\trtl818x_iowrite16(priv, &priv->map->TID_AC_MAP, 0xFA50);\n\n\t\trtl818x_iowrite16(priv, &priv->map->INT_MIG, 0);\n\n\t\t \n\t\trtl8187se_mac_config(dev);\n\n\t\trtl818x_iowrite16(priv, RFSW_CTRL, 0x569A);\n\t\trtl818x_ioread16(priv, RFSW_CTRL);\n\n\t\trtl8180_set_anaparam(priv, RTL8225SE_ANAPARAM_ON);\n\t\trtl8180_set_anaparam2(priv, RTL8225SE_ANAPARAM2_ON);\n\t\trtl8180_set_anaparam3(priv, RTL8225SE_ANAPARAM3);\n\n\n\t\trtl818x_iowrite8(priv, &priv->map->CONFIG5,\n\t\t\t    rtl818x_ioread8(priv, &priv->map->CONFIG5) & 0x7F);\n\n\t\t \n\t\trtl818x_iowrite8(priv, &priv->map->PGSELECT,\n\t\t\t    rtl818x_ioread8(priv, &priv->map->PGSELECT) | 0x08);\n\n\t\trtl818x_iowrite16(priv, &priv->map->RFPinsOutput, 0x0480);\n\t\trtl818x_iowrite16(priv, &priv->map->RFPinsEnable, 0x1BFF);\n\t\trtl818x_iowrite16(priv, &priv->map->RFPinsSelect, 0x2488);\n\n\t\trtl818x_iowrite32(priv, &priv->map->RF_TIMING, 0x4003);\n\n\t\t \n\t\treg32 = rtl818x_ioread32(priv, &priv->map->RF_PARA);\n\t\treg32 &= 0x00ffff00;\n\t\treg32 |= 0xb8000054;\n\t\trtl818x_iowrite32(priv, &priv->map->RF_PARA, reg32);\n\t} else\n\t\t \n\t\trtl818x_iowrite8(priv, &priv->map->TX_DMA_POLLING,\n\t\t\t    (1<<1) | (1<<2));\n\n\tpriv->rf->init(dev);\n\n\t \n\tif (priv->chip_family == RTL818X_CHIP_FAMILY_RTL8180)\n\t\trtl8180_conf_basic_rates(dev, 0x3);\n\telse\n\t\trtl8180_conf_basic_rates(dev, 0x1f3);\n\n\tif (priv->chip_family == RTL818X_CHIP_FAMILY_RTL8187SE)\n\t\trtl8187se_set_antenna_config(dev,\n\t\t\t\t\t     priv->antenna_diversity_default,\n\t\t\t\t\t     priv->antenna_diversity_en);\n\treturn 0;\n}\n\nstatic int rtl8180_init_rx_ring(struct ieee80211_hw *dev)\n{\n\tstruct rtl8180_priv *priv = dev->priv;\n\tstruct rtl818x_rx_cmd_desc *entry;\n\tint i;\n\n\tif (priv->chip_family == RTL818X_CHIP_FAMILY_RTL8187SE)\n\t\tpriv->rx_ring_sz = sizeof(struct rtl8187se_rx_desc);\n\telse\n\t\tpriv->rx_ring_sz = sizeof(struct rtl8180_rx_desc);\n\n\tpriv->rx_ring = dma_alloc_coherent(&priv->pdev->dev,\n\t\t\t\t\t   priv->rx_ring_sz * 32,\n\t\t\t\t\t   &priv->rx_ring_dma, GFP_KERNEL);\n\tif (!priv->rx_ring || (unsigned long)priv->rx_ring & 0xFF) {\n\t\twiphy_err(dev->wiphy, \"Cannot allocate RX ring\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv->rx_idx = 0;\n\n\tfor (i = 0; i < 32; i++) {\n\t\tstruct sk_buff *skb = dev_alloc_skb(MAX_RX_SIZE);\n\t\tdma_addr_t *mapping;\n\t\tentry = priv->rx_ring + priv->rx_ring_sz*i;\n\t\tif (!skb) {\n\t\t\tdma_free_coherent(&priv->pdev->dev,\n\t\t\t\t\t  priv->rx_ring_sz * 32,\n\t\t\t\t\t  priv->rx_ring, priv->rx_ring_dma);\n\t\t\twiphy_err(dev->wiphy, \"Cannot allocate RX skb\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tpriv->rx_buf[i] = skb;\n\t\tmapping = (dma_addr_t *)skb->cb;\n\t\t*mapping = dma_map_single(&priv->pdev->dev,\n\t\t\t\t\t  skb_tail_pointer(skb), MAX_RX_SIZE,\n\t\t\t\t\t  DMA_FROM_DEVICE);\n\n\t\tif (dma_mapping_error(&priv->pdev->dev, *mapping)) {\n\t\t\tkfree_skb(skb);\n\t\t\tdma_free_coherent(&priv->pdev->dev,\n\t\t\t\t\t  priv->rx_ring_sz * 32,\n\t\t\t\t\t  priv->rx_ring, priv->rx_ring_dma);\n\t\t\twiphy_err(dev->wiphy, \"Cannot map DMA for RX skb\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tentry->rx_buf = cpu_to_le32(*mapping);\n\t\tentry->flags = cpu_to_le32(RTL818X_RX_DESC_FLAG_OWN |\n\t\t\t\t\t   MAX_RX_SIZE);\n\t}\n\tentry->flags |= cpu_to_le32(RTL818X_RX_DESC_FLAG_EOR);\n\treturn 0;\n}\n\nstatic void rtl8180_free_rx_ring(struct ieee80211_hw *dev)\n{\n\tstruct rtl8180_priv *priv = dev->priv;\n\tint i;\n\n\tfor (i = 0; i < 32; i++) {\n\t\tstruct sk_buff *skb = priv->rx_buf[i];\n\t\tif (!skb)\n\t\t\tcontinue;\n\n\t\tdma_unmap_single(&priv->pdev->dev, *((dma_addr_t *)skb->cb),\n\t\t\t\t MAX_RX_SIZE, DMA_FROM_DEVICE);\n\t\tkfree_skb(skb);\n\t}\n\n\tdma_free_coherent(&priv->pdev->dev, priv->rx_ring_sz * 32,\n\t\t\t  priv->rx_ring, priv->rx_ring_dma);\n\tpriv->rx_ring = NULL;\n}\n\nstatic int rtl8180_init_tx_ring(struct ieee80211_hw *dev,\n\t\t\t\tunsigned int prio, unsigned int entries)\n{\n\tstruct rtl8180_priv *priv = dev->priv;\n\tstruct rtl8180_tx_desc *ring;\n\tdma_addr_t dma;\n\tint i;\n\n\tring = dma_alloc_coherent(&priv->pdev->dev, sizeof(*ring) * entries,\n\t\t\t\t  &dma, GFP_KERNEL);\n\tif (!ring || (unsigned long)ring & 0xFF) {\n\t\twiphy_err(dev->wiphy, \"Cannot allocate TX ring (prio = %d)\\n\",\n\t\t\t  prio);\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv->tx_ring[prio].desc = ring;\n\tpriv->tx_ring[prio].dma = dma;\n\tpriv->tx_ring[prio].idx = 0;\n\tpriv->tx_ring[prio].entries = entries;\n\tskb_queue_head_init(&priv->tx_ring[prio].queue);\n\n\tfor (i = 0; i < entries; i++)\n\t\tring[i].next_tx_desc =\n\t\t\tcpu_to_le32((u32)dma + ((i + 1) % entries) * sizeof(*ring));\n\n\treturn 0;\n}\n\nstatic void rtl8180_free_tx_ring(struct ieee80211_hw *dev, unsigned int prio)\n{\n\tstruct rtl8180_priv *priv = dev->priv;\n\tstruct rtl8180_tx_ring *ring = &priv->tx_ring[prio];\n\n\twhile (skb_queue_len(&ring->queue)) {\n\t\tstruct rtl8180_tx_desc *entry = &ring->desc[ring->idx];\n\t\tstruct sk_buff *skb = __skb_dequeue(&ring->queue);\n\n\t\tdma_unmap_single(&priv->pdev->dev, le32_to_cpu(entry->tx_buf),\n\t\t\t\t skb->len, DMA_TO_DEVICE);\n\t\tkfree_skb(skb);\n\t\tring->idx = (ring->idx + 1) % ring->entries;\n\t}\n\n\tdma_free_coherent(&priv->pdev->dev,\n\t\t\t  sizeof(*ring->desc) * ring->entries, ring->desc,\n\t\t\t  ring->dma);\n\tring->desc = NULL;\n}\n\nstatic int rtl8180_start(struct ieee80211_hw *dev)\n{\n\tstruct rtl8180_priv *priv = dev->priv;\n\tint ret, i;\n\tu32 reg;\n\n\tret = rtl8180_init_rx_ring(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < (dev->queues + 1); i++)\n\t\tif ((ret = rtl8180_init_tx_ring(dev, i, 16)))\n\t\t\tgoto err_free_rings;\n\n\tret = rtl8180_init_hw(dev);\n\tif (ret)\n\t\tgoto err_free_rings;\n\n\tif (priv->chip_family == RTL818X_CHIP_FAMILY_RTL8187SE) {\n\t\tret = request_irq(priv->pdev->irq, rtl8187se_interrupt,\n\t\t\t  IRQF_SHARED, KBUILD_MODNAME, dev);\n\t} else {\n\t\tret = request_irq(priv->pdev->irq, rtl8180_interrupt,\n\t\t\t  IRQF_SHARED, KBUILD_MODNAME, dev);\n\t}\n\n\tif (ret) {\n\t\twiphy_err(dev->wiphy, \"failed to register IRQ handler\\n\");\n\t\tgoto err_free_rings;\n\t}\n\n\trtl8180_int_enable(dev);\n\n\t \n\tif (priv->chip_family != RTL818X_CHIP_FAMILY_RTL8187SE) {\n\t\trtl818x_iowrite32(priv, &priv->map->MAR[0], ~0);\n\t\trtl818x_iowrite32(priv, &priv->map->MAR[1], ~0);\n\t}\n\n\treg = RTL818X_RX_CONF_ONLYERLPKT |\n\t      RTL818X_RX_CONF_RX_AUTORESETPHY |\n\t      RTL818X_RX_CONF_MGMT |\n\t      RTL818X_RX_CONF_DATA |\n\t      (7 << 8  ) |\n\t      RTL818X_RX_CONF_BROADCAST |\n\t      RTL818X_RX_CONF_NICMAC;\n\n\tif (priv->chip_family == RTL818X_CHIP_FAMILY_RTL8185)\n\t\treg |= RTL818X_RX_CONF_CSDM1 | RTL818X_RX_CONF_CSDM2;\n\telse if (priv->chip_family == RTL818X_CHIP_FAMILY_RTL8180) {\n\t\treg |= (priv->rfparam & RF_PARAM_CARRIERSENSE1)\n\t\t\t? RTL818X_RX_CONF_CSDM1 : 0;\n\t\treg |= (priv->rfparam & RF_PARAM_CARRIERSENSE2)\n\t\t\t? RTL818X_RX_CONF_CSDM2 : 0;\n\t} else {\n\t\treg &= ~(RTL818X_RX_CONF_CSDM1 | RTL818X_RX_CONF_CSDM2);\n\t}\n\n\tpriv->rx_conf = reg;\n\trtl818x_iowrite32(priv, &priv->map->RX_CONF, reg);\n\n\tif (priv->chip_family != RTL818X_CHIP_FAMILY_RTL8180) {\n\t\treg = rtl818x_ioread8(priv, &priv->map->CW_CONF);\n\n\t\t \n\t\treg &= ~RTL818X_CW_CONF_PERPACKET_CW;\n\t\t \n\t\treg |= RTL818X_CW_CONF_PERPACKET_RETRY;\n\t\trtl818x_iowrite8(priv, &priv->map->CW_CONF, reg);\n\n\t\treg = rtl818x_ioread8(priv, &priv->map->TX_AGC_CTL);\n\t\t \n\t\treg &= ~RTL818X_TX_AGC_CTL_PERPACKET_GAIN;\n\t\treg &= ~RTL818X_TX_AGC_CTL_PERPACKET_ANTSEL;\n\t\treg |=  RTL818X_TX_AGC_CTL_FEEDBACK_ANT;\n\t\trtl818x_iowrite8(priv, &priv->map->TX_AGC_CTL, reg);\n\n\t\t \n\t\trtl818x_iowrite8(priv, (u8 __iomem *)priv->map + 0xec, 0x3f);\n\t}\n\n\treg = rtl818x_ioread32(priv, &priv->map->TX_CONF);\n\treg |= (6 << 21  ) |\n\t       RTL818X_TX_CONF_NO_ICV;\n\n\tif (priv->chip_family == RTL818X_CHIP_FAMILY_RTL8187SE)\n\t\treg |= 1<<30;   \n\n\tif (priv->chip_family != RTL818X_CHIP_FAMILY_RTL8180)\n\t\treg &= ~RTL818X_TX_CONF_PROBE_DTS;\n\telse\n\t\treg &= ~RTL818X_TX_CONF_HW_SEQNUM;\n\n\treg &= ~RTL818X_TX_CONF_DISCW;\n\n\t \n\treg &= ~RTL818X_TX_CONF_SAT_HWPLCP;\n\n\trtl818x_iowrite32(priv, &priv->map->TX_CONF, reg);\n\n\treg = rtl818x_ioread8(priv, &priv->map->CMD);\n\treg |= RTL818X_CMD_RX_ENABLE;\n\treg |= RTL818X_CMD_TX_ENABLE;\n\trtl818x_iowrite8(priv, &priv->map->CMD, reg);\n\n\treturn 0;\n\n err_free_rings:\n\trtl8180_free_rx_ring(dev);\n\tfor (i = 0; i < (dev->queues + 1); i++)\n\t\tif (priv->tx_ring[i].desc)\n\t\t\trtl8180_free_tx_ring(dev, i);\n\n\treturn ret;\n}\n\nstatic void rtl8180_stop(struct ieee80211_hw *dev)\n{\n\tstruct rtl8180_priv *priv = dev->priv;\n\tu8 reg;\n\tint i;\n\n\trtl8180_int_disable(dev);\n\n\treg = rtl818x_ioread8(priv, &priv->map->CMD);\n\treg &= ~RTL818X_CMD_TX_ENABLE;\n\treg &= ~RTL818X_CMD_RX_ENABLE;\n\trtl818x_iowrite8(priv, &priv->map->CMD, reg);\n\n\tpriv->rf->stop(dev);\n\n\trtl818x_iowrite8(priv, &priv->map->EEPROM_CMD, RTL818X_EEPROM_CMD_CONFIG);\n\treg = rtl818x_ioread8(priv, &priv->map->CONFIG4);\n\trtl818x_iowrite8(priv, &priv->map->CONFIG4, reg | RTL818X_CONFIG4_VCOOFF);\n\trtl818x_iowrite8(priv, &priv->map->EEPROM_CMD, RTL818X_EEPROM_CMD_NORMAL);\n\n\tfree_irq(priv->pdev->irq, dev);\n\n\trtl8180_free_rx_ring(dev);\n\tfor (i = 0; i < (dev->queues + 1); i++)\n\t\trtl8180_free_tx_ring(dev, i);\n}\n\nstatic u64 rtl8180_get_tsf(struct ieee80211_hw *dev,\n\t\t\t   struct ieee80211_vif *vif)\n{\n\tstruct rtl8180_priv *priv = dev->priv;\n\n\treturn rtl818x_ioread32(priv, &priv->map->TSFT[0]) |\n\t       (u64)(rtl818x_ioread32(priv, &priv->map->TSFT[1])) << 32;\n}\n\nstatic void rtl8180_beacon_work(struct work_struct *work)\n{\n\tstruct rtl8180_vif *vif_priv =\n\t\tcontainer_of(work, struct rtl8180_vif, beacon_work.work);\n\tstruct ieee80211_vif *vif =\n\t\tcontainer_of((void *)vif_priv, struct ieee80211_vif, drv_priv);\n\tstruct ieee80211_hw *dev = vif_priv->dev;\n\tstruct ieee80211_mgmt *mgmt;\n\tstruct sk_buff *skb;\n\n\t \n\tif (ieee80211_queue_stopped(dev, 0))\n\t\tgoto resched;\n\n\t \n\tskb = ieee80211_beacon_get(dev, vif, 0);\n\tif (!skb)\n\t\tgoto resched;\n\n\t \n\tmgmt = (struct ieee80211_mgmt *)skb->data;\n\tmgmt->u.beacon.timestamp = cpu_to_le64(rtl8180_get_tsf(dev, vif));\n\n\t \n\tskb_set_queue_mapping(skb, 0);\n\n\trtl8180_tx(dev, NULL, skb);\n\nresched:\n\t \n\tschedule_delayed_work(&vif_priv->beacon_work,\n\t\t\tusecs_to_jiffies(1024 * vif->bss_conf.beacon_int));\n}\n\nstatic int rtl8180_add_interface(struct ieee80211_hw *dev,\n\t\t\t\t struct ieee80211_vif *vif)\n{\n\tstruct rtl8180_priv *priv = dev->priv;\n\tstruct rtl8180_vif *vif_priv;\n\n\t \n\tif (priv->vif)\n\t\treturn -EBUSY;\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tpriv->vif = vif;\n\n\t \n\tvif_priv = (struct rtl8180_vif *)&vif->drv_priv;\n\tvif_priv->dev = dev;\n\tINIT_DELAYED_WORK(&vif_priv->beacon_work, rtl8180_beacon_work);\n\tvif_priv->enable_beacon = false;\n\n\trtl818x_iowrite8(priv, &priv->map->EEPROM_CMD, RTL818X_EEPROM_CMD_CONFIG);\n\trtl818x_iowrite32(priv, (__le32 __iomem *)&priv->map->MAC[0],\n\t\t\t  le32_to_cpu(*(__le32 *)vif->addr));\n\trtl818x_iowrite16(priv, (__le16 __iomem *)&priv->map->MAC[4],\n\t\t\t  le16_to_cpu(*(__le16 *)(vif->addr + 4)));\n\trtl818x_iowrite8(priv, &priv->map->EEPROM_CMD, RTL818X_EEPROM_CMD_NORMAL);\n\n\treturn 0;\n}\n\nstatic void rtl8180_remove_interface(struct ieee80211_hw *dev,\n\t\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct rtl8180_priv *priv = dev->priv;\n\tpriv->vif = NULL;\n}\n\nstatic int rtl8180_config(struct ieee80211_hw *dev, u32 changed)\n{\n\tstruct rtl8180_priv *priv = dev->priv;\n\tstruct ieee80211_conf *conf = &dev->conf;\n\n\tpriv->rf->set_chan(dev, conf);\n\n\treturn 0;\n}\n\nstatic void rtl8187se_conf_ac_parm(struct ieee80211_hw *dev, u8 queue)\n{\n\tconst struct ieee80211_tx_queue_params *params;\n\tstruct rtl8180_priv *priv = dev->priv;\n\n\t \n\tu32 ac_param;\n\n\tu8 aifs;\n\tu8 txop;\n\tu8 cw_min, cw_max;\n\n\tparams = &priv->queue_param[queue];\n\n\tcw_min = fls(params->cw_min);\n\tcw_max = fls(params->cw_max);\n\n\taifs = 10 + params->aifs * priv->slot_time;\n\n\t \n\ttxop = params->txop;\n\n\tac_param = txop << AC_PARAM_TXOP_LIMIT_SHIFT |\n\t\tcw_max << AC_PARAM_ECW_MAX_SHIFT |\n\t\tcw_min << AC_PARAM_ECW_MIN_SHIFT |\n\t\taifs << AC_PARAM_AIFS_SHIFT;\n\n\tswitch (queue) {\n\tcase IEEE80211_AC_BK:\n\t\trtl818x_iowrite32(priv, &priv->map->AC_BK_PARAM, ac_param);\n\t\tbreak;\n\tcase IEEE80211_AC_BE:\n\t\trtl818x_iowrite32(priv, &priv->map->AC_BE_PARAM, ac_param);\n\t\tbreak;\n\tcase IEEE80211_AC_VI:\n\t\trtl818x_iowrite32(priv, &priv->map->AC_VI_PARAM, ac_param);\n\t\tbreak;\n\tcase IEEE80211_AC_VO:\n\t\trtl818x_iowrite32(priv, &priv->map->AC_VO_PARAM, ac_param);\n\t\tbreak;\n\t}\n}\n\nstatic int rtl8180_conf_tx(struct ieee80211_hw *dev,\n\t\t\t    struct ieee80211_vif *vif,\n\t\t\t    unsigned int link_id, u16 queue,\n\t\t\t    const struct ieee80211_tx_queue_params *params)\n{\n\tstruct rtl8180_priv *priv = dev->priv;\n\tu8 cw_min, cw_max;\n\n\t \n\tif (priv->chip_family == RTL818X_CHIP_FAMILY_RTL8180)\n\t\treturn 0;\n\n\tcw_min = fls(params->cw_min);\n\tcw_max = fls(params->cw_max);\n\n\tif (priv->chip_family == RTL818X_CHIP_FAMILY_RTL8187SE) {\n\t\tpriv->queue_param[queue] = *params;\n\t\trtl8187se_conf_ac_parm(dev, queue);\n\t} else\n\t\trtl818x_iowrite8(priv, &priv->map->CW_VAL,\n\t\t\t\t (cw_max << 4) | cw_min);\n\treturn 0;\n}\n\nstatic void rtl8180_conf_erp(struct ieee80211_hw *dev,\n\t\t\t    struct ieee80211_bss_conf *info)\n{\n\tstruct rtl8180_priv *priv = dev->priv;\n\tu8 sifs, difs;\n\tint eifs;\n\tu8 hw_eifs;\n\n\t \n\tif (priv->chip_family == RTL818X_CHIP_FAMILY_RTL8180)\n\t\treturn;\n\n\t \n\tsifs = 0x22;\n\n\tif (info->use_short_slot)\n\t\tpriv->slot_time = 9;\n\telse\n\t\tpriv->slot_time = 20;\n\n\t \n\tdifs = 10 + 2 * priv->slot_time;\n\teifs = 10 + difs + priv->ack_time;\n\n\t \n\thw_eifs = DIV_ROUND_UP(eifs, 4);\n\n\n\trtl818x_iowrite8(priv, &priv->map->SLOT, priv->slot_time);\n\trtl818x_iowrite8(priv, &priv->map->SIFS, sifs);\n\trtl818x_iowrite8(priv, &priv->map->DIFS, difs);\n\n\t \n\trtl818x_iowrite8(priv, &priv->map->CARRIER_SENSE_COUNTER, hw_eifs);\n\n\tif (priv->chip_family == RTL818X_CHIP_FAMILY_RTL8187SE)\n\t\trtl818x_iowrite8(priv, &priv->map->EIFS_8187SE, hw_eifs);\n\telse if (priv->chip_family == RTL818X_CHIP_FAMILY_RTL8185) {\n\t\t \n\t\thw_eifs = DIV_ROUND_UP(eifs - difs, 4);\n\n\t\trtl818x_iowrite8(priv, &priv->map->EIFS, hw_eifs);\n\t}\n}\n\nstatic void rtl8180_bss_info_changed(struct ieee80211_hw *dev,\n\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t     struct ieee80211_bss_conf *info,\n\t\t\t\t     u64 changed)\n{\n\tstruct rtl8180_priv *priv = dev->priv;\n\tstruct rtl8180_vif *vif_priv;\n\tint i;\n\tu8 reg;\n\n\tvif_priv = (struct rtl8180_vif *)&vif->drv_priv;\n\n\tif (changed & BSS_CHANGED_BSSID) {\n\t\trtl818x_iowrite16(priv, (__le16 __iomem *)&priv->map->BSSID[0],\n\t\t\t\t  le16_to_cpu(*(__le16 *)info->bssid));\n\t\trtl818x_iowrite32(priv, (__le32 __iomem *)&priv->map->BSSID[2],\n\t\t\t\t  le32_to_cpu(*(__le32 *)(info->bssid + 2)));\n\n\t\tif (is_valid_ether_addr(info->bssid)) {\n\t\t\tif (vif->type == NL80211_IFTYPE_ADHOC)\n\t\t\t\treg = RTL818X_MSR_ADHOC;\n\t\t\telse\n\t\t\t\treg = RTL818X_MSR_INFRA;\n\t\t} else\n\t\t\treg = RTL818X_MSR_NO_LINK;\n\n\t\tif (priv->chip_family == RTL818X_CHIP_FAMILY_RTL8187SE)\n\t\t\treg |= RTL818X_MSR_ENEDCA;\n\n\t\trtl818x_iowrite8(priv, &priv->map->MSR, reg);\n\t}\n\n\tif (changed & BSS_CHANGED_BASIC_RATES)\n\t\trtl8180_conf_basic_rates(dev, info->basic_rates);\n\n\tif (changed & (BSS_CHANGED_ERP_SLOT | BSS_CHANGED_ERP_PREAMBLE)) {\n\n\t\t \n\t\tpriv->ack_time =\n\t\t\tle16_to_cpu(ieee80211_generic_frame_duration(dev,\n\t\t\t\t\tpriv->vif,\n\t\t\t\t\tNL80211_BAND_2GHZ, 10,\n\t\t\t\t\t&priv->rates[0])) - 10;\n\n\t\trtl8180_conf_erp(dev, info);\n\n\t\t \n\t\tif (priv->chip_family == RTL818X_CHIP_FAMILY_RTL8187SE) {\n\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\trtl8187se_conf_ac_parm(dev, i);\n\t\t}\n\t}\n\n\tif (changed & BSS_CHANGED_BEACON_ENABLED)\n\t\tvif_priv->enable_beacon = info->enable_beacon;\n\n\tif (changed & (BSS_CHANGED_BEACON_ENABLED | BSS_CHANGED_BEACON)) {\n\t\tcancel_delayed_work_sync(&vif_priv->beacon_work);\n\t\tif (vif_priv->enable_beacon)\n\t\t\tschedule_work(&vif_priv->beacon_work.work);\n\t}\n}\n\nstatic u64 rtl8180_prepare_multicast(struct ieee80211_hw *dev,\n\t\t\t\t     struct netdev_hw_addr_list *mc_list)\n{\n\treturn netdev_hw_addr_list_count(mc_list);\n}\n\nstatic void rtl8180_configure_filter(struct ieee80211_hw *dev,\n\t\t\t\t     unsigned int changed_flags,\n\t\t\t\t     unsigned int *total_flags,\n\t\t\t\t     u64 multicast)\n{\n\tstruct rtl8180_priv *priv = dev->priv;\n\n\tif (changed_flags & FIF_FCSFAIL)\n\t\tpriv->rx_conf ^= RTL818X_RX_CONF_FCS;\n\tif (changed_flags & FIF_CONTROL)\n\t\tpriv->rx_conf ^= RTL818X_RX_CONF_CTRL;\n\tif (changed_flags & FIF_OTHER_BSS)\n\t\tpriv->rx_conf ^= RTL818X_RX_CONF_MONITOR;\n\tif (*total_flags & FIF_ALLMULTI || multicast > 0)\n\t\tpriv->rx_conf |= RTL818X_RX_CONF_MULTICAST;\n\telse\n\t\tpriv->rx_conf &= ~RTL818X_RX_CONF_MULTICAST;\n\n\t*total_flags = 0;\n\n\tif (priv->rx_conf & RTL818X_RX_CONF_FCS)\n\t\t*total_flags |= FIF_FCSFAIL;\n\tif (priv->rx_conf & RTL818X_RX_CONF_CTRL)\n\t\t*total_flags |= FIF_CONTROL;\n\tif (priv->rx_conf & RTL818X_RX_CONF_MONITOR)\n\t\t*total_flags |= FIF_OTHER_BSS;\n\tif (priv->rx_conf & RTL818X_RX_CONF_MULTICAST)\n\t\t*total_flags |= FIF_ALLMULTI;\n\n\trtl818x_iowrite32(priv, &priv->map->RX_CONF, priv->rx_conf);\n}\n\nstatic const struct ieee80211_ops rtl8180_ops = {\n\t.tx\t\t\t= rtl8180_tx,\n\t.wake_tx_queue\t\t= ieee80211_handle_wake_tx_queue,\n\t.start\t\t\t= rtl8180_start,\n\t.stop\t\t\t= rtl8180_stop,\n\t.add_interface\t\t= rtl8180_add_interface,\n\t.remove_interface\t= rtl8180_remove_interface,\n\t.config\t\t\t= rtl8180_config,\n\t.bss_info_changed\t= rtl8180_bss_info_changed,\n\t.conf_tx\t\t= rtl8180_conf_tx,\n\t.prepare_multicast\t= rtl8180_prepare_multicast,\n\t.configure_filter\t= rtl8180_configure_filter,\n\t.get_tsf\t\t= rtl8180_get_tsf,\n};\n\nstatic void rtl8180_eeprom_register_read(struct eeprom_93cx6 *eeprom)\n{\n\tstruct rtl8180_priv *priv = eeprom->data;\n\tu8 reg = rtl818x_ioread8(priv, &priv->map->EEPROM_CMD);\n\n\teeprom->reg_data_in = reg & RTL818X_EEPROM_CMD_WRITE;\n\teeprom->reg_data_out = reg & RTL818X_EEPROM_CMD_READ;\n\teeprom->reg_data_clock = reg & RTL818X_EEPROM_CMD_CK;\n\teeprom->reg_chip_select = reg & RTL818X_EEPROM_CMD_CS;\n}\n\nstatic void rtl8180_eeprom_register_write(struct eeprom_93cx6 *eeprom)\n{\n\tstruct rtl8180_priv *priv = eeprom->data;\n\tu8 reg = 2 << 6;\n\n\tif (eeprom->reg_data_in)\n\t\treg |= RTL818X_EEPROM_CMD_WRITE;\n\tif (eeprom->reg_data_out)\n\t\treg |= RTL818X_EEPROM_CMD_READ;\n\tif (eeprom->reg_data_clock)\n\t\treg |= RTL818X_EEPROM_CMD_CK;\n\tif (eeprom->reg_chip_select)\n\t\treg |= RTL818X_EEPROM_CMD_CS;\n\n\trtl818x_iowrite8(priv, &priv->map->EEPROM_CMD, reg);\n\trtl818x_ioread8(priv, &priv->map->EEPROM_CMD);\n\tudelay(10);\n}\n\nstatic void rtl8180_eeprom_read(struct rtl8180_priv *priv)\n{\n\tstruct eeprom_93cx6 eeprom;\n\tint eeprom_cck_table_adr;\n\tu16 eeprom_val;\n\tint i;\n\n\teeprom.data = priv;\n\teeprom.register_read = rtl8180_eeprom_register_read;\n\teeprom.register_write = rtl8180_eeprom_register_write;\n\tif (rtl818x_ioread32(priv, &priv->map->RX_CONF) & (1 << 6))\n\t\teeprom.width = PCI_EEPROM_WIDTH_93C66;\n\telse\n\t\teeprom.width = PCI_EEPROM_WIDTH_93C46;\n\n\trtl818x_iowrite8(priv, &priv->map->EEPROM_CMD,\n\t\t\tRTL818X_EEPROM_CMD_PROGRAM);\n\trtl818x_ioread8(priv, &priv->map->EEPROM_CMD);\n\tudelay(10);\n\n\teeprom_93cx6_read(&eeprom, 0x06, &eeprom_val);\n\teeprom_val &= 0xFF;\n\tpriv->rf_type = eeprom_val;\n\n\teeprom_93cx6_read(&eeprom, 0x17, &eeprom_val);\n\tpriv->csthreshold = eeprom_val >> 8;\n\n\teeprom_93cx6_multiread(&eeprom, 0x7, (__le16 *)priv->mac_addr, 3);\n\n\tif (priv->chip_family == RTL818X_CHIP_FAMILY_RTL8187SE)\n\t\teeprom_cck_table_adr = 0x30;\n\telse\n\t\teeprom_cck_table_adr = 0x10;\n\n\t \n\tfor (i = 0; i < 14; i += 2) {\n\t\tu16 txpwr;\n\t\teeprom_93cx6_read(&eeprom, eeprom_cck_table_adr + (i >> 1),\n\t\t\t\t&txpwr);\n\t\tpriv->channels[i].hw_value = txpwr & 0xFF;\n\t\tpriv->channels[i + 1].hw_value = txpwr >> 8;\n\t}\n\n\t \n\tif (priv->chip_family != RTL818X_CHIP_FAMILY_RTL8180) {\n\t\tfor (i = 0; i < 14; i += 2) {\n\t\t\tu16 txpwr;\n\t\t\teeprom_93cx6_read(&eeprom, 0x20 + (i >> 1), &txpwr);\n\t\t\tpriv->channels[i].hw_value |= (txpwr & 0xFF) << 8;\n\t\t\tpriv->channels[i + 1].hw_value |= txpwr & 0xFF00;\n\t\t}\n\t}\n\n\tif (priv->chip_family == RTL818X_CHIP_FAMILY_RTL8180) {\n\t\t__le32 anaparam;\n\t\teeprom_93cx6_multiread(&eeprom, 0xD, (__le16 *)&anaparam, 2);\n\t\tpriv->anaparam = le32_to_cpu(anaparam);\n\t\teeprom_93cx6_read(&eeprom, 0x19, &priv->rfparam);\n\t}\n\n\tif (priv->chip_family == RTL818X_CHIP_FAMILY_RTL8187SE) {\n\t\teeprom_93cx6_read(&eeprom, 0x3F, &eeprom_val);\n\t\tpriv->antenna_diversity_en = !!(eeprom_val & 0x100);\n\t\tpriv->antenna_diversity_default = (eeprom_val & 0xC00) == 0x400;\n\n\t\teeprom_93cx6_read(&eeprom, 0x7C, &eeprom_val);\n\t\tpriv->xtal_out = eeprom_val & 0xF;\n\t\tpriv->xtal_in = (eeprom_val & 0xF0) >> 4;\n\t\tpriv->xtal_cal = !!(eeprom_val & 0x1000);\n\t\tpriv->thermal_meter_val = (eeprom_val & 0xF00) >> 8;\n\t\tpriv->thermal_meter_en = !!(eeprom_val & 0x2000);\n\t}\n\n\trtl818x_iowrite8(priv, &priv->map->EEPROM_CMD,\n\t\t\tRTL818X_EEPROM_CMD_NORMAL);\n}\n\nstatic int rtl8180_probe(struct pci_dev *pdev,\n\t\t\t\t   const struct pci_device_id *id)\n{\n\tstruct ieee80211_hw *dev;\n\tstruct rtl8180_priv *priv;\n\tunsigned long mem_len;\n\tunsigned int io_len;\n\tint err;\n\tconst char *chip_name, *rf_name = NULL;\n\tu32 reg;\n\n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s (rtl8180): Cannot enable new PCI device\\n\",\n\t\t       pci_name(pdev));\n\t\treturn err;\n\t}\n\n\terr = pci_request_regions(pdev, KBUILD_MODNAME);\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s (rtl8180): Cannot obtain PCI resources\\n\",\n\t\t       pci_name(pdev));\n\t\tgoto err_disable_dev;\n\t}\n\n\tio_len = pci_resource_len(pdev, 0);\n\tmem_len = pci_resource_len(pdev, 1);\n\n\tif (mem_len < sizeof(struct rtl818x_csr) ||\n\t    io_len < sizeof(struct rtl818x_csr)) {\n\t\tprintk(KERN_ERR \"%s (rtl8180): Too short PCI resources\\n\",\n\t\t       pci_name(pdev));\n\t\terr = -ENOMEM;\n\t\tgoto err_free_reg;\n\t}\n\n\tif ((err = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32))) ||\n\t    (err = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32)))) {\n\t\tprintk(KERN_ERR \"%s (rtl8180): No suitable DMA available\\n\",\n\t\t       pci_name(pdev));\n\t\tgoto err_free_reg;\n\t}\n\n\tpci_set_master(pdev);\n\n\tdev = ieee80211_alloc_hw(sizeof(*priv), &rtl8180_ops);\n\tif (!dev) {\n\t\tprintk(KERN_ERR \"%s (rtl8180): ieee80211 alloc failed\\n\",\n\t\t       pci_name(pdev));\n\t\terr = -ENOMEM;\n\t\tgoto err_free_reg;\n\t}\n\n\tpriv = dev->priv;\n\tpriv->pdev = pdev;\n\n\tdev->max_rates = 1;\n\tSET_IEEE80211_DEV(dev, &pdev->dev);\n\tpci_set_drvdata(pdev, dev);\n\n\tpriv->map_pio = false;\n\tpriv->map = pci_iomap(pdev, 1, mem_len);\n\tif (!priv->map) {\n\t\tpriv->map = pci_iomap(pdev, 0, io_len);\n\t\tpriv->map_pio = true;\n\t}\n\n\tif (!priv->map) {\n\t\tdev_err(&pdev->dev, \"Cannot map device memory/PIO\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto err_free_dev;\n\t}\n\n\tBUILD_BUG_ON(sizeof(priv->channels) != sizeof(rtl818x_channels));\n\tBUILD_BUG_ON(sizeof(priv->rates) != sizeof(rtl818x_rates));\n\n\tmemcpy(priv->channels, rtl818x_channels, sizeof(rtl818x_channels));\n\tmemcpy(priv->rates, rtl818x_rates, sizeof(rtl818x_rates));\n\n\tpriv->band.band = NL80211_BAND_2GHZ;\n\tpriv->band.channels = priv->channels;\n\tpriv->band.n_channels = ARRAY_SIZE(rtl818x_channels);\n\tpriv->band.bitrates = priv->rates;\n\tpriv->band.n_bitrates = 4;\n\tdev->wiphy->bands[NL80211_BAND_2GHZ] = &priv->band;\n\n\tieee80211_hw_set(dev, HOST_BROADCAST_PS_BUFFERING);\n\tieee80211_hw_set(dev, RX_INCLUDES_FCS);\n\n\tdev->vif_data_size = sizeof(struct rtl8180_vif);\n\tdev->wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |\n\t\t\t\t\tBIT(NL80211_IFTYPE_ADHOC);\n\tdev->max_signal = 65;\n\n\treg = rtl818x_ioread32(priv, &priv->map->TX_CONF);\n\treg &= RTL818X_TX_CONF_HWVER_MASK;\n\tswitch (reg) {\n\tcase RTL818X_TX_CONF_R8180_ABCD:\n\t\tchip_name = \"RTL8180\";\n\t\tpriv->chip_family = RTL818X_CHIP_FAMILY_RTL8180;\n\t\tbreak;\n\n\tcase RTL818X_TX_CONF_R8180_F:\n\t\tchip_name = \"RTL8180vF\";\n\t\tpriv->chip_family = RTL818X_CHIP_FAMILY_RTL8180;\n\t\tbreak;\n\n\tcase RTL818X_TX_CONF_R8185_ABC:\n\t\tchip_name = \"RTL8185\";\n\t\tpriv->chip_family = RTL818X_CHIP_FAMILY_RTL8185;\n\t\tbreak;\n\n\tcase RTL818X_TX_CONF_R8185_D:\n\t\tchip_name = \"RTL8185vD\";\n\t\tpriv->chip_family = RTL818X_CHIP_FAMILY_RTL8185;\n\t\tbreak;\n\n\tcase RTL818X_TX_CONF_RTL8187SE:\n\t\tchip_name = \"RTL8187SE\";\n\t\tif (priv->map_pio) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"MMIO failed. PIO not supported on RTL8187SE\\n\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_iounmap;\n\t\t}\n\t\tpriv->chip_family = RTL818X_CHIP_FAMILY_RTL8187SE;\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(KERN_ERR \"%s (rtl8180): Unknown chip! (0x%x)\\n\",\n\t\t       pci_name(pdev), reg >> 25);\n\t\terr = -ENODEV;\n\t\tgoto err_iounmap;\n\t}\n\n\t \n\tif (priv->chip_family == RTL818X_CHIP_FAMILY_RTL8187SE)\n\t\tdev->queues = RTL8187SE_NR_TX_QUEUES - 1;\n\telse\n\t\tdev->queues = RTL8180_NR_TX_QUEUES - 1;\n\n\tif (priv->chip_family != RTL818X_CHIP_FAMILY_RTL8180) {\n\t\tpriv->band.n_bitrates = ARRAY_SIZE(rtl818x_rates);\n\t\tpci_try_set_mwi(pdev);\n\t}\n\n\tif (priv->chip_family != RTL818X_CHIP_FAMILY_RTL8180)\n\t\tieee80211_hw_set(dev, SIGNAL_DBM);\n\telse\n\t\tieee80211_hw_set(dev, SIGNAL_UNSPEC);\n\n\twiphy_ext_feature_set(dev->wiphy, NL80211_EXT_FEATURE_CQM_RSSI_LIST);\n\n\trtl8180_eeprom_read(priv);\n\n\tswitch (priv->rf_type) {\n\tcase 1:\trf_name = \"Intersil\";\n\t\tbreak;\n\tcase 2:\trf_name = \"RFMD\";\n\t\tbreak;\n\tcase 3:\tpriv->rf = &sa2400_rf_ops;\n\t\tbreak;\n\tcase 4:\tpriv->rf = &max2820_rf_ops;\n\t\tbreak;\n\tcase 5:\tpriv->rf = &grf5101_rf_ops;\n\t\tbreak;\n\tcase 9:\n\t\tif (priv->chip_family == RTL818X_CHIP_FAMILY_RTL8187SE)\n\t\t\tpriv->rf = rtl8187se_detect_rf(dev);\n\t\telse\n\t\t\tpriv->rf = rtl8180_detect_rf(dev);\n\t\tbreak;\n\tcase 10:\n\t\trf_name = \"RTL8255\";\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"%s (rtl8180): Unknown RF! (0x%x)\\n\",\n\t\t       pci_name(pdev), priv->rf_type);\n\t\terr = -ENODEV;\n\t\tgoto err_iounmap;\n\t}\n\n\tif (!priv->rf) {\n\t\tprintk(KERN_ERR \"%s (rtl8180): %s RF frontend not supported!\\n\",\n\t\t       pci_name(pdev), rf_name);\n\t\terr = -ENODEV;\n\t\tgoto err_iounmap;\n\t}\n\n\tif (!is_valid_ether_addr(priv->mac_addr)) {\n\t\tprintk(KERN_WARNING \"%s (rtl8180): Invalid hwaddr! Using\"\n\t\t       \" randomly generated MAC addr\\n\", pci_name(pdev));\n\t\teth_random_addr(priv->mac_addr);\n\t}\n\tSET_IEEE80211_PERM_ADDR(dev, priv->mac_addr);\n\n\tspin_lock_init(&priv->lock);\n\n\terr = ieee80211_register_hw(dev);\n\tif (err) {\n\t\tprintk(KERN_ERR \"%s (rtl8180): Cannot register device\\n\",\n\t\t       pci_name(pdev));\n\t\tgoto err_iounmap;\n\t}\n\n\twiphy_info(dev->wiphy, \"hwaddr %pm, %s + %s\\n\",\n\t\t   priv->mac_addr, chip_name, priv->rf->name);\n\n\treturn 0;\n\n err_iounmap:\n\tpci_iounmap(pdev, priv->map);\n\n err_free_dev:\n\tieee80211_free_hw(dev);\n\n err_free_reg:\n\tpci_release_regions(pdev);\n\n err_disable_dev:\n\tpci_disable_device(pdev);\n\treturn err;\n}\n\nstatic void rtl8180_remove(struct pci_dev *pdev)\n{\n\tstruct ieee80211_hw *dev = pci_get_drvdata(pdev);\n\tstruct rtl8180_priv *priv;\n\n\tif (!dev)\n\t\treturn;\n\n\tieee80211_unregister_hw(dev);\n\n\tpriv = dev->priv;\n\n\tpci_iounmap(pdev, priv->map);\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n\tieee80211_free_hw(dev);\n}\n\n#define rtl8180_suspend NULL\n#define rtl8180_resume NULL\n\nstatic SIMPLE_DEV_PM_OPS(rtl8180_pm_ops, rtl8180_suspend, rtl8180_resume);\n\nstatic struct pci_driver rtl8180_driver = {\n\t.name\t\t= KBUILD_MODNAME,\n\t.id_table\t= rtl8180_table,\n\t.probe\t\t= rtl8180_probe,\n\t.remove\t\t= rtl8180_remove,\n\t.driver.pm\t= &rtl8180_pm_ops,\n};\n\nmodule_pci_driver(rtl8180_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}