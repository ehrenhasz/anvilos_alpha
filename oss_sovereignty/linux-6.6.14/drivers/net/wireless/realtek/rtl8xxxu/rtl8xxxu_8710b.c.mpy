{
  "module_name": "rtl8xxxu_8710b.c",
  "hash_id": "48fc00a966e79e0e514eb004d0e4867a149ef96387ea0e6870481641dfad4d3c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu_8710b.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/usb.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/wireless.h>\n#include <linux/firmware.h>\n#include <linux/moduleparam.h>\n#include <net/mac80211.h>\n#include \"rtl8xxxu.h\"\n#include \"rtl8xxxu_regs.h\"\n\nstatic const struct rtl8xxxu_reg8val rtl8710b_mac_init_table[] = {\n\t{0x421, 0x0F}, {0x428, 0x0A}, {0x429, 0x10}, {0x430, 0x00},\n\t{0x431, 0x00}, {0x432, 0x00}, {0x433, 0x01}, {0x434, 0x04},\n\t{0x435, 0x05}, {0x436, 0x07}, {0x437, 0x08}, {0x43C, 0x04},\n\t{0x43D, 0x05}, {0x43E, 0x07}, {0x43F, 0x08}, {0x440, 0x5D},\n\t{0x441, 0x01}, {0x442, 0x00}, {0x444, 0x10}, {0x445, 0x00},\n\t{0x446, 0x00}, {0x447, 0x00}, {0x448, 0x00}, {0x449, 0xF0},\n\t{0x44A, 0x0F}, {0x44B, 0x3E}, {0x44C, 0x10}, {0x44D, 0x00},\n\t{0x44E, 0x00}, {0x44F, 0x00}, {0x450, 0x00}, {0x451, 0xF0},\n\t{0x452, 0x0F}, {0x453, 0x00}, {0x456, 0x5E}, {0x460, 0x66},\n\t{0x461, 0x66}, {0x4C8, 0xFF}, {0x4C9, 0x08}, {0x4CC, 0xFF},\n\t{0x4CD, 0xFF}, {0x4CE, 0x01}, {0x500, 0x26}, {0x501, 0xA2},\n\t{0x502, 0x2F}, {0x503, 0x00}, {0x504, 0x28}, {0x505, 0xA3},\n\t{0x506, 0x5E}, {0x507, 0x00}, {0x508, 0x2B}, {0x509, 0xA4},\n\t{0x50A, 0x5E}, {0x50B, 0x00}, {0x50C, 0x4F}, {0x50D, 0xA4},\n\t{0x50E, 0x00}, {0x50F, 0x00}, {0x512, 0x1C}, {0x514, 0x0A},\n\t{0x516, 0x0A}, {0x525, 0x4F}, {0x550, 0x10}, {0x551, 0x10},\n\t{0x559, 0x02}, {0x55C, 0x28}, {0x55D, 0xFF}, {0x605, 0x30},\n\t{0x608, 0x0E}, {0x609, 0x2A}, {0x620, 0xFF}, {0x621, 0xFF},\n\t{0x622, 0xFF}, {0x623, 0xFF}, {0x624, 0xFF}, {0x625, 0xFF},\n\t{0x626, 0xFF}, {0x627, 0xFF}, {0x638, 0x28}, {0x63C, 0x0A},\n\t{0x63D, 0x0A}, {0x63E, 0x0C}, {0x63F, 0x0C}, {0x640, 0x40},\n\t{0x642, 0x40}, {0x643, 0x00}, {0x652, 0xC8}, {0x66A, 0xB0},\n\t{0x66E, 0x05}, {0x700, 0x21}, {0x701, 0x43}, {0x702, 0x65},\n\t{0x703, 0x87}, {0x708, 0x21}, {0x709, 0x43}, {0x70A, 0x65},\n\t{0x70B, 0x87},\n\t{0xffff, 0xff},\n};\n\n \nstatic const struct rtl8xxxu_reg32val rtl8710bu_qfn48m_u_phy_init_table[] = {\n\t{0x800, 0x80045700}, {0x804, 0x00000001},\n\t{0x808, 0x00FC8000}, {0x80C, 0x0000000A},\n\t{0x810, 0x10001331}, {0x814, 0x020C3D10},\n\t{0x818, 0x00200385}, {0x81C, 0x00000000},\n\t{0x820, 0x01000100}, {0x824, 0x00390204},\n\t{0x828, 0x00000000}, {0x82C, 0x00000000},\n\t{0x830, 0x00000000}, {0x834, 0x00000000},\n\t{0x838, 0x00000000}, {0x83C, 0x00000000},\n\t{0x840, 0x00010000}, {0x844, 0x00000000},\n\t{0x848, 0x00000000}, {0x84C, 0x00000000},\n\t{0x850, 0x00030000}, {0x854, 0x00000000},\n\t{0x858, 0x7E1A569A}, {0x85C, 0x569A569A},\n\t{0x860, 0x00000130}, {0x864, 0x20000000},\n\t{0x868, 0x00000000}, {0x86C, 0x27272700},\n\t{0x870, 0x00050000}, {0x874, 0x25005000},\n\t{0x878, 0x00000808}, {0x87C, 0x004F0201},\n\t{0x880, 0xB0000B1E}, {0x884, 0x00000007},\n\t{0x888, 0x00000000}, {0x88C, 0xCCC400C0},\n\t{0x890, 0x00000800}, {0x894, 0xFFFFFFFE},\n\t{0x898, 0x40302010}, {0x89C, 0x00706050},\n\t{0x900, 0x00000000}, {0x904, 0x00000023},\n\t{0x908, 0x00000000}, {0x90C, 0x81121111},\n\t{0x910, 0x00000402}, {0x914, 0x00000201},\n\t{0x920, 0x18C6318C}, {0x924, 0x0000018C},\n\t{0x948, 0x99000000}, {0x94C, 0x00000010},\n\t{0x950, 0x00003000}, {0x954, 0x5A880000},\n\t{0x958, 0x4BC6D87A}, {0x95C, 0x04EB9B79},\n\t{0x96C, 0x00000003}, {0x970, 0x00000000},\n\t{0x974, 0x00000000}, {0x978, 0x00000000},\n\t{0x97C, 0x13000000}, {0x980, 0x00000000},\n\t{0xA00, 0x00D046C8}, {0xA04, 0x80FF800C},\n\t{0xA08, 0x84838300}, {0xA0C, 0x2E20100F},\n\t{0xA10, 0x9500BB78}, {0xA14, 0x1114D028},\n\t{0xA18, 0x00881117}, {0xA1C, 0x89140F00},\n\t{0xA20, 0xE82C0001}, {0xA24, 0x64B80C1C},\n\t{0xA28, 0x00008810}, {0xA2C, 0x00D30000},\n\t{0xA70, 0x101FBF00}, {0xA74, 0x00000007},\n\t{0xA78, 0x00000900}, {0xA7C, 0x225B0606},\n\t{0xA80, 0x218075B1}, {0xA84, 0x00200000},\n\t{0xA88, 0x040C0000}, {0xA8C, 0x12345678},\n\t{0xA90, 0xABCDEF00}, {0xA94, 0x001B1B89},\n\t{0xA98, 0x00000000}, {0xA9C, 0x80020000},\n\t{0xAA0, 0x00000000}, {0xAA4, 0x0000000C},\n\t{0xAA8, 0xCA110058}, {0xAAC, 0x01235667},\n\t{0xAB0, 0x00000000}, {0xAB4, 0x20201402},\n\t{0xB2C, 0x00000000}, {0xC00, 0x48071D40},\n\t{0xC04, 0x03A05611}, {0xC08, 0x000000E4},\n\t{0xC0C, 0x6C6C6C6C}, {0xC10, 0x18800000},\n\t{0xC14, 0x40000100}, {0xC18, 0x08800000},\n\t{0xC1C, 0x40000100}, {0xC20, 0x00000000},\n\t{0xC24, 0x00000000}, {0xC28, 0x00000000},\n\t{0xC2C, 0x00000000}, {0xC30, 0x69E9AC4A},\n\t{0xC34, 0x31000040}, {0xC38, 0x21688080},\n\t{0xC3C, 0x0000170C}, {0xC40, 0x1F78403F},\n\t{0xC44, 0x00010036}, {0xC48, 0xEC020107},\n\t{0xC4C, 0x007F037F}, {0xC50, 0x69553420},\n\t{0xC54, 0x43BC0094}, {0xC58, 0x00013169},\n\t{0xC5C, 0x00250492}, {0xC60, 0x00280A00},\n\t{0xC64, 0x7112848B}, {0xC68, 0x47C074FF},\n\t{0xC6C, 0x00000036}, {0xC70, 0x2C7F000D},\n\t{0xC74, 0x020600DB}, {0xC78, 0x0000001F},\n\t{0xC7C, 0x00B91612}, {0xC80, 0x390000E4},\n\t{0xC84, 0x11F60000}, {0xC88, 0x1051B75F},\n\t{0xC8C, 0x20200109}, {0xC90, 0x00091521},\n\t{0xC94, 0x00000000}, {0xC98, 0x00121820},\n\t{0xC9C, 0x00007F7F}, {0xCA0, 0x00011000},\n\t{0xCA4, 0x800000A0}, {0xCA8, 0x84E6C606},\n\t{0xCAC, 0x00000060}, {0xCB0, 0x00000000},\n\t{0xCB4, 0x00000000}, {0xCB8, 0x00000000},\n\t{0xCBC, 0x28000000}, {0xCC0, 0x1051B75F},\n\t{0xCC4, 0x00000109}, {0xCC8, 0x000442D6},\n\t{0xCCC, 0x00000000}, {0xCD0, 0x000001C8},\n\t{0xCD4, 0x001C8000}, {0xCD8, 0x00000100},\n\t{0xCDC, 0x40100000}, {0xCE0, 0x00222220},\n\t{0xCE4, 0x10000000}, {0xCE8, 0x37644302},\n\t{0xCEC, 0x2F97D40C}, {0xD00, 0x04030740},\n\t{0xD04, 0x40020401}, {0xD08, 0x0000907F},\n\t{0xD0C, 0x20010201}, {0xD10, 0xA0633333},\n\t{0xD14, 0x3333BC53}, {0xD18, 0x7A8F5B6F},\n\t{0xD2C, 0xCB979975}, {0xD30, 0x00000000},\n\t{0xD34, 0x40608000}, {0xD38, 0x88000000},\n\t{0xD3C, 0xC0127353}, {0xD40, 0x00000000},\n\t{0xD44, 0x00000000}, {0xD48, 0x00000000},\n\t{0xD4C, 0x00000000}, {0xD50, 0x00006528},\n\t{0xD54, 0x00000000}, {0xD58, 0x00000282},\n\t{0xD5C, 0x30032064}, {0xD60, 0x4653DE68},\n\t{0xD64, 0x04518A3C}, {0xD68, 0x00002101},\n\t{0xE00, 0x2D2D2D2D}, {0xE04, 0x2D2D2D2D},\n\t{0xE08, 0x0390272D}, {0xE10, 0x2D2D2D2D},\n\t{0xE14, 0x2D2D2D2D}, {0xE18, 0x2D2D2D2D},\n\t{0xE1C, 0x2D2D2D2D}, {0xE28, 0x00000000},\n\t{0xE30, 0x1000DC1F}, {0xE34, 0x10008C1F},\n\t{0xE38, 0x02140102}, {0xE3C, 0x681604C2},\n\t{0xE40, 0x01007C00}, {0xE44, 0x01004800},\n\t{0xE48, 0xFB000000}, {0xE4C, 0x000028D1},\n\t{0xE50, 0x1000DC1F}, {0xE54, 0x10008C1F},\n\t{0xE58, 0x02140102}, {0xE5C, 0x28160D05},\n\t{0xE60, 0x0000C008}, {0xE68, 0x001B25A4},\n\t{0xE64, 0x281600A0}, {0xE6C, 0x01C00010},\n\t{0xE70, 0x01C00010}, {0xE74, 0x02000010},\n\t{0xE78, 0x02000010}, {0xE7C, 0x02000010},\n\t{0xE80, 0x02000010}, {0xE84, 0x01C00010},\n\t{0xE88, 0x02000010}, {0xE8C, 0x01C00010},\n\t{0xED0, 0x01C00010}, {0xED4, 0x01C00010},\n\t{0xED8, 0x01C00010}, {0xEDC, 0x00000010},\n\t{0xEE0, 0x00000010}, {0xEEC, 0x03C00010},\n\t{0xF14, 0x00000003}, {0xF00, 0x00100300},\n\t{0xF08, 0x0000800B}, {0xF0C, 0x0000F007},\n\t{0xF10, 0x0000A487}, {0xF1C, 0x80000064},\n\t{0xF38, 0x00030155}, {0xF3C, 0x0000003A},\n\t{0xF4C, 0x13000000}, {0xF50, 0x00000000},\n\t{0xF18, 0x00000000},\n\t{0xffff, 0xffffffff},\n};\n\n \nstatic const struct rtl8xxxu_reg32val rtl8710bu_qfn48m_s_phy_init_table[] = {\n\t{0x800, 0x80045700}, {0x804, 0x00000001},\n\t{0x808, 0x00FC8000}, {0x80C, 0x0000000A},\n\t{0x810, 0x10001331}, {0x814, 0x020C3D10},\n\t{0x818, 0x00200385}, {0x81C, 0x00000000},\n\t{0x820, 0x01000100}, {0x824, 0x00390204},\n\t{0x828, 0x00000000}, {0x82C, 0x00000000},\n\t{0x830, 0x00000000}, {0x834, 0x00000000},\n\t{0x838, 0x00000000}, {0x83C, 0x00000000},\n\t{0x840, 0x00010000}, {0x844, 0x00000000},\n\t{0x848, 0x00000000}, {0x84C, 0x00000000},\n\t{0x850, 0x00030000}, {0x854, 0x00000000},\n\t{0x858, 0x7E1A569A}, {0x85C, 0x569A569A},\n\t{0x860, 0x00000130}, {0x864, 0x20000000},\n\t{0x868, 0x00000000}, {0x86C, 0x27272700},\n\t{0x870, 0x00050000}, {0x874, 0x25005000},\n\t{0x878, 0x00000808}, {0x87C, 0x004F0201},\n\t{0x880, 0xB0000B1E}, {0x884, 0x00000007},\n\t{0x888, 0x00000000}, {0x88C, 0xCCC400C0},\n\t{0x890, 0x00000800}, {0x894, 0xFFFFFFFE},\n\t{0x898, 0x40302010}, {0x89C, 0x00706050},\n\t{0x900, 0x00000000}, {0x904, 0x00000023},\n\t{0x908, 0x00000000}, {0x90C, 0x81121111},\n\t{0x910, 0x00000402}, {0x914, 0x00000201},\n\t{0x920, 0x18C6318C}, {0x924, 0x0000018C},\n\t{0x948, 0x99000000}, {0x94C, 0x00000010},\n\t{0x950, 0x00003000}, {0x954, 0x5A880000},\n\t{0x958, 0x4BC6D87A}, {0x95C, 0x04EB9B79},\n\t{0x96C, 0x00000003}, {0x970, 0x00000000},\n\t{0x974, 0x00000000}, {0x978, 0x00000000},\n\t{0x97C, 0x13000000}, {0x980, 0x00000000},\n\t{0xA00, 0x00D046C8}, {0xA04, 0x80FF800C},\n\t{0xA08, 0x84838300}, {0xA0C, 0x2A20100F},\n\t{0xA10, 0x9500BB78}, {0xA14, 0x1114D028},\n\t{0xA18, 0x00881117}, {0xA1C, 0x89140F00},\n\t{0xA20, 0xE82C0001}, {0xA24, 0x64B80C1C},\n\t{0xA28, 0x00008810}, {0xA2C, 0x00D30000},\n\t{0xA70, 0x101FBF00}, {0xA74, 0x00000007},\n\t{0xA78, 0x00000900}, {0xA7C, 0x225B0606},\n\t{0xA80, 0x218075B1}, {0xA84, 0x00200000},\n\t{0xA88, 0x040C0000}, {0xA8C, 0x12345678},\n\t{0xA90, 0xABCDEF00}, {0xA94, 0x001B1B89},\n\t{0xA98, 0x00000000}, {0xA9C, 0x80020000},\n\t{0xAA0, 0x00000000}, {0xAA4, 0x0000000C},\n\t{0xAA8, 0xCA110058}, {0xAAC, 0x01235667},\n\t{0xAB0, 0x00000000}, {0xAB4, 0x20201402},\n\t{0xB2C, 0x00000000}, {0xC00, 0x48071D40},\n\t{0xC04, 0x03A05611}, {0xC08, 0x000000E4},\n\t{0xC0C, 0x6C6C6C6C}, {0xC10, 0x18800000},\n\t{0xC14, 0x40000100}, {0xC18, 0x08800000},\n\t{0xC1C, 0x40000100}, {0xC20, 0x00000000},\n\t{0xC24, 0x00000000}, {0xC28, 0x00000000},\n\t{0xC2C, 0x00000000}, {0xC30, 0x69E9AC4A},\n\t{0xC34, 0x31000040}, {0xC38, 0x21688080},\n\t{0xC3C, 0x0000170C}, {0xC40, 0x1F78403F},\n\t{0xC44, 0x00010036}, {0xC48, 0xEC020107},\n\t{0xC4C, 0x007F037F}, {0xC50, 0x69553420},\n\t{0xC54, 0x43BC0094}, {0xC58, 0x00013169},\n\t{0xC5C, 0x00250492}, {0xC60, 0x00280A00},\n\t{0xC64, 0x7112848B}, {0xC68, 0x47C074FF},\n\t{0xC6C, 0x00000036}, {0xC70, 0x2C7F000D},\n\t{0xC74, 0x020600DB}, {0xC78, 0x0000001F},\n\t{0xC7C, 0x00B91612}, {0xC80, 0x390000E4},\n\t{0xC84, 0x11F60000}, {0xC88, 0x1051B75F},\n\t{0xC8C, 0x20200109}, {0xC90, 0x00091521},\n\t{0xC94, 0x00000000}, {0xC98, 0x00121820},\n\t{0xC9C, 0x00007F7F}, {0xCA0, 0x00011000},\n\t{0xCA4, 0x800000A0}, {0xCA8, 0x84E6C606},\n\t{0xCAC, 0x00000060}, {0xCB0, 0x00000000},\n\t{0xCB4, 0x00000000}, {0xCB8, 0x00000000},\n\t{0xCBC, 0x28000000}, {0xCC0, 0x1051B75F},\n\t{0xCC4, 0x00000109}, {0xCC8, 0x000442D6},\n\t{0xCCC, 0x00000000}, {0xCD0, 0x000001C8},\n\t{0xCD4, 0x001C8000}, {0xCD8, 0x00000100},\n\t{0xCDC, 0x40100000}, {0xCE0, 0x00222220},\n\t{0xCE4, 0x10000000}, {0xCE8, 0x37644302},\n\t{0xCEC, 0x2F97D40C}, {0xD00, 0x04030740},\n\t{0xD04, 0x40020401}, {0xD08, 0x0000907F},\n\t{0xD0C, 0x20010201}, {0xD10, 0xA0633333},\n\t{0xD14, 0x3333BC53}, {0xD18, 0x7A8F5B6F},\n\t{0xD2C, 0xCB979975}, {0xD30, 0x00000000},\n\t{0xD34, 0x40608000}, {0xD38, 0x88000000},\n\t{0xD3C, 0xC0127353}, {0xD40, 0x00000000},\n\t{0xD44, 0x00000000}, {0xD48, 0x00000000},\n\t{0xD4C, 0x00000000}, {0xD50, 0x00006528},\n\t{0xD54, 0x00000000}, {0xD58, 0x00000282},\n\t{0xD5C, 0x30032064}, {0xD60, 0x4653DE68},\n\t{0xD64, 0x04518A3C}, {0xD68, 0x00002101},\n\t{0xE00, 0x2D2D2D2D}, {0xE04, 0x2D2D2D2D},\n\t{0xE08, 0x0390272D}, {0xE10, 0x2D2D2D2D},\n\t{0xE14, 0x2D2D2D2D}, {0xE18, 0x2D2D2D2D},\n\t{0xE1C, 0x2D2D2D2D}, {0xE28, 0x00000000},\n\t{0xE30, 0x1000DC1F}, {0xE34, 0x10008C1F},\n\t{0xE38, 0x02140102}, {0xE3C, 0x681604C2},\n\t{0xE40, 0x01007C00}, {0xE44, 0x01004800},\n\t{0xE48, 0xFB000000}, {0xE4C, 0x000028D1},\n\t{0xE50, 0x1000DC1F}, {0xE54, 0x10008C1F},\n\t{0xE58, 0x02140102}, {0xE5C, 0x28160D05},\n\t{0xE60, 0x0000C008}, {0xE68, 0x001B25A4},\n\t{0xE64, 0x281600A0}, {0xE6C, 0x01C00010},\n\t{0xE70, 0x01C00010}, {0xE74, 0x02000010},\n\t{0xE78, 0x02000010}, {0xE7C, 0x02000010},\n\t{0xE80, 0x02000010}, {0xE84, 0x01C00010},\n\t{0xE88, 0x02000010}, {0xE8C, 0x01C00010},\n\t{0xED0, 0x01C00010}, {0xED4, 0x01C00010},\n\t{0xED8, 0x01C00010}, {0xEDC, 0x00000010},\n\t{0xEE0, 0x00000010}, {0xEEC, 0x03C00010},\n\t{0xF14, 0x00000003}, {0xF00, 0x00100300},\n\t{0xF08, 0x0000800B}, {0xF0C, 0x0000F007},\n\t{0xF10, 0x0000A487}, {0xF1C, 0x80000064},\n\t{0xF38, 0x00030155}, {0xF3C, 0x0000003A},\n\t{0xF4C, 0x13000000}, {0xF50, 0x00000000},\n\t{0xF18, 0x00000000},\n\t{0xffff, 0xffffffff},\n};\n\nstatic const struct rtl8xxxu_reg32val rtl8710b_agc_table[] = {\n\t{0xC78, 0xFC000001}, {0xC78, 0xFB010001},\n\t{0xC78, 0xFA020001}, {0xC78, 0xF9030001},\n\t{0xC78, 0xF8040001}, {0xC78, 0xF7050001},\n\t{0xC78, 0xF6060001}, {0xC78, 0xF5070001},\n\t{0xC78, 0xF4080001}, {0xC78, 0xF3090001},\n\t{0xC78, 0xF20A0001}, {0xC78, 0xF10B0001},\n\t{0xC78, 0xF00C0001}, {0xC78, 0xEF0D0001},\n\t{0xC78, 0xEE0E0001}, {0xC78, 0xED0F0001},\n\t{0xC78, 0xEC100001}, {0xC78, 0xEB110001},\n\t{0xC78, 0xEA120001}, {0xC78, 0xE9130001},\n\t{0xC78, 0xE8140001}, {0xC78, 0xE7150001},\n\t{0xC78, 0xE6160001}, {0xC78, 0xE5170001},\n\t{0xC78, 0xE4180001}, {0xC78, 0xE3190001},\n\t{0xC78, 0xE21A0001}, {0xC78, 0xE11B0001},\n\t{0xC78, 0xE01C0001}, {0xC78, 0xC31D0001},\n\t{0xC78, 0xC21E0001}, {0xC78, 0xC11F0001},\n\t{0xC78, 0xC0200001}, {0xC78, 0xA3210001},\n\t{0xC78, 0xA2220001}, {0xC78, 0xA1230001},\n\t{0xC78, 0xA0240001}, {0xC78, 0x86250001},\n\t{0xC78, 0x85260001}, {0xC78, 0x84270001},\n\t{0xC78, 0x83280001}, {0xC78, 0x82290001},\n\t{0xC78, 0x812A0001}, {0xC78, 0x802B0001},\n\t{0xC78, 0x632C0001}, {0xC78, 0x622D0001},\n\t{0xC78, 0x612E0001}, {0xC78, 0x602F0001},\n\t{0xC78, 0x42300001}, {0xC78, 0x41310001},\n\t{0xC78, 0x40320001}, {0xC78, 0x23330001},\n\t{0xC78, 0x22340001}, {0xC78, 0x21350001},\n\t{0xC78, 0x20360001}, {0xC78, 0x02370001},\n\t{0xC78, 0x01380001}, {0xC78, 0x00390001},\n\t{0xC78, 0x003A0001}, {0xC78, 0x003B0001},\n\t{0xC78, 0x003C0001}, {0xC78, 0x003D0001},\n\t{0xC78, 0x003E0001}, {0xC78, 0x003F0001},\n\t{0xC78, 0xF7400001}, {0xC78, 0xF7410001},\n\t{0xC78, 0xF7420001}, {0xC78, 0xF7430001},\n\t{0xC78, 0xF7440001}, {0xC78, 0xF7450001},\n\t{0xC78, 0xF7460001}, {0xC78, 0xF7470001},\n\t{0xC78, 0xF7480001}, {0xC78, 0xF6490001},\n\t{0xC78, 0xF34A0001}, {0xC78, 0xF24B0001},\n\t{0xC78, 0xF14C0001}, {0xC78, 0xF04D0001},\n\t{0xC78, 0xD14E0001}, {0xC78, 0xD04F0001},\n\t{0xC78, 0xB5500001}, {0xC78, 0xB4510001},\n\t{0xC78, 0xB3520001}, {0xC78, 0xB2530001},\n\t{0xC78, 0xB1540001}, {0xC78, 0xB0550001},\n\t{0xC78, 0xAF560001}, {0xC78, 0xAE570001},\n\t{0xC78, 0xAD580001}, {0xC78, 0xAC590001},\n\t{0xC78, 0xAB5A0001}, {0xC78, 0xAA5B0001},\n\t{0xC78, 0xA95C0001}, {0xC78, 0xA85D0001},\n\t{0xC78, 0xA75E0001}, {0xC78, 0xA65F0001},\n\t{0xC78, 0xA5600001}, {0xC78, 0xA4610001},\n\t{0xC78, 0xA3620001}, {0xC78, 0xA2630001},\n\t{0xC78, 0xA1640001}, {0xC78, 0xA0650001},\n\t{0xC78, 0x87660001}, {0xC78, 0x86670001},\n\t{0xC78, 0x85680001}, {0xC78, 0x84690001},\n\t{0xC78, 0x836A0001}, {0xC78, 0x826B0001},\n\t{0xC78, 0x816C0001}, {0xC78, 0x806D0001},\n\t{0xC78, 0x636E0001}, {0xC78, 0x626F0001},\n\t{0xC78, 0x61700001}, {0xC78, 0x60710001},\n\t{0xC78, 0x42720001}, {0xC78, 0x41730001},\n\t{0xC78, 0x40740001}, {0xC78, 0x23750001},\n\t{0xC78, 0x22760001}, {0xC78, 0x21770001},\n\t{0xC78, 0x20780001}, {0xC78, 0x03790001},\n\t{0xC78, 0x027A0001}, {0xC78, 0x017B0001},\n\t{0xC78, 0x007C0001}, {0xC78, 0x007D0001},\n\t{0xC78, 0x007E0001}, {0xC78, 0x007F0001},\n\t{0xC50, 0x69553422}, {0xC50, 0x69553420},\n\t{0xffff, 0xffffffff}\n};\n\nstatic const struct rtl8xxxu_rfregval rtl8710bu_qfn48m_u_radioa_init_table[] = {\n\t{0x00, 0x00030000}, {0x08, 0x00008400},\n\t{0x17, 0x00000000}, {0x18, 0x00000C01},\n\t{0x19, 0x000739D2}, {0x1C, 0x00000C4C},\n\t{0x1B, 0x00000C6C}, {0x1E, 0x00080009},\n\t{0x1F, 0x00000880}, {0x2F, 0x0001A060},\n\t{0x3F, 0x00015000}, {0x42, 0x000060C0},\n\t{0x57, 0x000D0000}, {0x58, 0x000C0160},\n\t{0x67, 0x00001552}, {0x83, 0x00000000},\n\t{0xB0, 0x000FF9F0}, {0xB1, 0x00010018},\n\t{0xB2, 0x00054C00}, {0xB4, 0x0004486B},\n\t{0xB5, 0x0000112A}, {0xB6, 0x0000053E},\n\t{0xB7, 0x00014408}, {0xB8, 0x00010200},\n\t{0xB9, 0x00080801}, {0xBA, 0x00040001},\n\t{0xBB, 0x00000400}, {0xBF, 0x000C0000},\n\t{0xC2, 0x00002400}, {0xC3, 0x00000009},\n\t{0xC4, 0x00040C91}, {0xC5, 0x00099999},\n\t{0xC6, 0x000000A3}, {0xC7, 0x00088820},\n\t{0xC8, 0x00076C06}, {0xC9, 0x00000000},\n\t{0xCA, 0x00080000}, {0xDF, 0x00000180},\n\t{0xEF, 0x000001A8}, {0x3D, 0x00000003},\n\t{0x3D, 0x00080003}, {0x51, 0x000F1E69},\n\t{0x52, 0x000FBF6C}, {0x53, 0x0000032F},\n\t{0x54, 0x00055007}, {0x56, 0x000517F0},\n\t{0x35, 0x000000F4}, {0x35, 0x00000179},\n\t{0x35, 0x000002F4}, {0x36, 0x00000BF8},\n\t{0x36, 0x00008BF8}, {0x36, 0x00010BF8},\n\t{0x36, 0x00018BF8}, {0x18, 0x00000C01},\n\t{0x5A, 0x00048000}, {0x5A, 0x00048000},\n\t{0x34, 0x0000ADF5}, {0x34, 0x00009DF2},\n\t{0x34, 0x00008DEF}, {0x34, 0x00007DEC},\n\t{0x34, 0x00006DE9}, {0x34, 0x00005CEC},\n\t{0x34, 0x00004CE9}, {0x34, 0x00003C6C},\n\t{0x34, 0x00002C69}, {0x34, 0x0000106E},\n\t{0x34, 0x0000006B}, {0x84, 0x00048000},\n\t{0x87, 0x00000065}, {0x8E, 0x00065540},\n\t{0xDF, 0x00000110}, {0x86, 0x0000002A},\n\t{0x8F, 0x00088000}, {0x81, 0x0003FD80},\n\t{0xEF, 0x00082000}, {0x3B, 0x000F0F00},\n\t{0x3B, 0x000E0E00}, {0x3B, 0x000DFE00},\n\t{0x3B, 0x000C0D00}, {0x3B, 0x000B0C00},\n\t{0x3B, 0x000A0500}, {0x3B, 0x00090400},\n\t{0x3B, 0x00080000}, {0x3B, 0x00070F00},\n\t{0x3B, 0x00060E00}, {0x3B, 0x00050A00},\n\t{0x3B, 0x00040D00}, {0x3B, 0x00030C00},\n\t{0x3B, 0x00020500}, {0x3B, 0x00010400},\n\t{0x3B, 0x00000000}, {0xEF, 0x00080000},\n\t{0xEF, 0x00088000}, {0x3B, 0x00000170},\n\t{0x3B, 0x000C0030}, {0xEF, 0x00080000},\n\t{0xEF, 0x00080000}, {0x30, 0x00010000},\n\t{0x31, 0x0000000F}, {0x32, 0x00047EFE},\n\t{0xEF, 0x00000000}, {0x00, 0x00010159},\n\t{0x18, 0x0000FC01}, {0xFE, 0x00000000},\n\t{0x00, 0x00033D95},\n\t{0xff, 0xffffffff}\n};\n\nstatic const struct rtl8xxxu_rfregval rtl8710bu_qfn48m_s_radioa_init_table[] = {\n\t{0x00, 0x00030000}, {0x08, 0x00008400},\n\t{0x17, 0x00000000}, {0x18, 0x00000C01},\n\t{0x19, 0x000739D2}, {0x1C, 0x00000C4C},\n\t{0x1B, 0x00000C6C}, {0x1E, 0x00080009},\n\t{0x1F, 0x00000880}, {0x2F, 0x0001A060},\n\t{0x3F, 0x00015000}, {0x42, 0x000060C0},\n\t{0x57, 0x000D0000}, {0x58, 0x000C0160},\n\t{0x67, 0x00001552}, {0x83, 0x00000000},\n\t{0xB0, 0x000FF9F0}, {0xB1, 0x00010018},\n\t{0xB2, 0x00054C00}, {0xB4, 0x0004486B},\n\t{0xB5, 0x0000112A}, {0xB6, 0x0000053E},\n\t{0xB7, 0x00014408}, {0xB8, 0x00010200},\n\t{0xB9, 0x00080801}, {0xBA, 0x00040001},\n\t{0xBB, 0x00000400}, {0xBF, 0x000C0000},\n\t{0xC2, 0x00002400}, {0xC3, 0x00000009},\n\t{0xC4, 0x00040C91}, {0xC5, 0x00099999},\n\t{0xC6, 0x000000A3}, {0xC7, 0x00088820},\n\t{0xC8, 0x00076C06}, {0xC9, 0x00000000},\n\t{0xCA, 0x00080000}, {0xDF, 0x00000180},\n\t{0xEF, 0x000001A8}, {0x3D, 0x00000003},\n\t{0x3D, 0x00080003}, {0x51, 0x000F1E69},\n\t{0x52, 0x000FBF6C}, {0x53, 0x0000032F},\n\t{0x54, 0x00055007}, {0x56, 0x000517F0},\n\t{0x35, 0x000000F4}, {0x35, 0x00000179},\n\t{0x35, 0x000002F4}, {0x36, 0x00000BF8},\n\t{0x36, 0x00008BF8}, {0x36, 0x00010BF8},\n\t{0x36, 0x00018BF8}, {0x18, 0x00000C01},\n\t{0x5A, 0x00048000}, {0x5A, 0x00048000},\n\t{0x34, 0x0000ADF5}, {0x34, 0x00009DF2},\n\t{0x34, 0x00008DEF}, {0x34, 0x00007DEC},\n\t{0x34, 0x00006DE9}, {0x34, 0x00005CEC},\n\t{0x34, 0x00004CE9}, {0x34, 0x00003C6C},\n\t{0x34, 0x00002C69}, {0x34, 0x0000106E},\n\t{0x34, 0x0000006B}, {0x84, 0x00048000},\n\t{0x87, 0x00000065}, {0x8E, 0x00065540},\n\t{0xDF, 0x00000110}, {0x86, 0x0000002A},\n\t{0x8F, 0x00088000}, {0x81, 0x0003FD80},\n\t{0xEF, 0x00082000}, {0x3B, 0x000F0F00},\n\t{0x3B, 0x000E0E00}, {0x3B, 0x000DFE00},\n\t{0x3B, 0x000C0D00}, {0x3B, 0x000B0C00},\n\t{0x3B, 0x000A0500}, {0x3B, 0x00090400},\n\t{0x3B, 0x00080000}, {0x3B, 0x00070F00},\n\t{0x3B, 0x00060E00}, {0x3B, 0x00050A00},\n\t{0x3B, 0x00040D00}, {0x3B, 0x00030C00},\n\t{0x3B, 0x00020500}, {0x3B, 0x00010400},\n\t{0x3B, 0x00000000}, {0xEF, 0x00080000},\n\t{0xEF, 0x00088000}, {0x3B, 0x000000B0},\n\t{0x3B, 0x000C0030}, {0xEF, 0x00080000},\n\t{0xEF, 0x00080000}, {0x30, 0x00010000},\n\t{0x31, 0x0000000F}, {0x32, 0x00047EFE},\n\t{0xEF, 0x00000000}, {0x00, 0x00010159},\n\t{0x18, 0x0000FC01}, {0xFE, 0x00000000},\n\t{0x00, 0x00033D95},\n\t{0xff, 0xffffffff}\n};\n\nstatic u32 rtl8710b_indirect_read32(struct rtl8xxxu_priv *priv, u32 addr)\n{\n\tstruct device *dev = &priv->udev->dev;\n\tu32 val32, value = 0xffffffff;\n\tu8 polling_count = 0xff;\n\n\tif (!IS_ALIGNED(addr, 4)) {\n\t\tdev_warn(dev, \"%s: Aborting because 0x%x is not a multiple of 4.\\n\",\n\t\t\t __func__, addr);\n\t\treturn value;\n\t}\n\n\tmutex_lock(&priv->syson_indirect_access_mutex);\n\n\trtl8xxxu_write32(priv, REG_USB_HOST_INDIRECT_ADDR_8710B, addr);\n\trtl8xxxu_write32(priv, REG_EFUSE_INDIRECT_CTRL_8710B, NORMAL_REG_READ_OFFSET);\n\n\tdo\n\t\tval32 = rtl8xxxu_read32(priv, REG_EFUSE_INDIRECT_CTRL_8710B);\n\twhile ((val32 & BIT(31)) && (--polling_count > 0));\n\n\tif (polling_count == 0)\n\t\tdev_warn(dev, \"%s: Failed to read from 0x%x, 0x806c = 0x%x\\n\",\n\t\t\t __func__, addr, val32);\n\telse\n\t\tvalue = rtl8xxxu_read32(priv, REG_USB_HOST_INDIRECT_DATA_8710B);\n\n\tmutex_unlock(&priv->syson_indirect_access_mutex);\n\n\tif (rtl8xxxu_debug & RTL8XXXU_DEBUG_REG_READ)\n\t\tdev_info(dev, \"%s(%04x) = 0x%08x\\n\", __func__, addr, value);\n\n\treturn value;\n}\n\nstatic void rtl8710b_indirect_write32(struct rtl8xxxu_priv *priv, u32 addr, u32 val)\n{\n\tstruct device *dev = &priv->udev->dev;\n\tu8 polling_count = 0xff;\n\tu32 val32;\n\n\tif (!IS_ALIGNED(addr, 4)) {\n\t\tdev_warn(dev, \"%s: Aborting because 0x%x is not a multiple of 4.\\n\",\n\t\t\t __func__, addr);\n\t\treturn;\n\t}\n\n\tmutex_lock(&priv->syson_indirect_access_mutex);\n\n\trtl8xxxu_write32(priv, REG_USB_HOST_INDIRECT_ADDR_8710B, addr);\n\trtl8xxxu_write32(priv, REG_USB_HOST_INDIRECT_DATA_8710B, val);\n\trtl8xxxu_write32(priv, REG_EFUSE_INDIRECT_CTRL_8710B, NORMAL_REG_WRITE_OFFSET);\n\n\tdo\n\t\tval32 = rtl8xxxu_read32(priv, REG_EFUSE_INDIRECT_CTRL_8710B);\n\twhile ((val32 & BIT(31)) && (--polling_count > 0));\n\n\tif (polling_count == 0)\n\t\tdev_warn(dev, \"%s: Failed to write 0x%x to 0x%x, 0x806c = 0x%x\\n\",\n\t\t\t __func__, val, addr, val32);\n\n\tmutex_unlock(&priv->syson_indirect_access_mutex);\n\n\tif (rtl8xxxu_debug & RTL8XXXU_DEBUG_REG_WRITE)\n\t\tdev_info(dev, \"%s(%04x) = 0x%08x\\n\", __func__, addr, val);\n}\n\nstatic u32 rtl8710b_read_syson_reg(struct rtl8xxxu_priv *priv, u32 addr)\n{\n\treturn rtl8710b_indirect_read32(priv, addr | SYSON_REG_BASE_ADDR_8710B);\n}\n\nstatic void rtl8710b_write_syson_reg(struct rtl8xxxu_priv *priv, u32 addr, u32 val)\n{\n\trtl8710b_indirect_write32(priv, addr | SYSON_REG_BASE_ADDR_8710B, val);\n}\n\nstatic int rtl8710b_read_efuse8(struct rtl8xxxu_priv *priv, u16 offset, u8 *data)\n{\n\tu32 val32;\n\tint i;\n\n\t \n\trtl8xxxu_write32(priv, REG_USB_HOST_INDIRECT_ADDR_8710B, offset);\n\n\trtl8xxxu_write32(priv, REG_EFUSE_INDIRECT_CTRL_8710B, EFUSE_READ_OFFSET);\n\n\t \n\tval32 = rtl8xxxu_read32(priv, REG_EFUSE_INDIRECT_CTRL_8710B);\n\tfor (i = 0; i < RTL8XXXU_MAX_REG_POLL; i++) {\n\t\tval32 = rtl8xxxu_read32(priv, REG_EFUSE_INDIRECT_CTRL_8710B);\n\t\tif (!(val32 & BIT(31)))\n\t\t\tbreak;\n\t}\n\n\tif (i == RTL8XXXU_MAX_REG_POLL)\n\t\treturn -EIO;\n\n\tval32 = rtl8xxxu_read32(priv, REG_USB_HOST_INDIRECT_DATA_8710B);\n\n\t*data = val32 & 0xff;\n\treturn 0;\n}\n\n#define EEPROM_PACKAGE_TYPE_8710B\t0xF8\n#define PACKAGE_QFN48M_U\t\t0xee\n#define PACKAGE_QFN48M_S\t\t0xfe\n\nstatic int rtl8710bu_identify_chip(struct rtl8xxxu_priv *priv)\n{\n\tstruct device *dev = &priv->udev->dev;\n\tu32 cfg0, cfg2, vendor;\n\tu8 package_type = 0x7;  \n\n\tsprintf(priv->chip_name, \"8710BU\");\n\tpriv->rtl_chip = RTL8710B;\n\tpriv->rf_paths = 1;\n\tpriv->rx_paths = 1;\n\tpriv->tx_paths = 1;\n\tpriv->has_wifi = 1;\n\n\tcfg0 = rtl8710b_read_syson_reg(priv, REG_SYS_SYSTEM_CFG0_8710B);\n\tpriv->chip_cut = cfg0 & 0xf;\n\n\tif (cfg0 & BIT(16)) {\n\t\tdev_info(dev, \"%s: Unsupported test chip\\n\", __func__);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tvendor = u32_get_bits(cfg0, 0xc0);\n\n\t \n\tswitch (vendor) {\n\tcase 0:\n\t\tsprintf(priv->chip_vendor, \"SMIC\");\n\t\tpriv->vendor_smic = 1;\n\t\tbreak;\n\tcase 1:\n\t\tsprintf(priv->chip_vendor, \"TSMC\");\n\t\tbreak;\n\tcase 2:\n\t\tsprintf(priv->chip_vendor, \"UMC\");\n\t\tpriv->vendor_umc = 1;\n\t\tbreak;\n\tdefault:\n\t\tsprintf(priv->chip_vendor, \"unknown\");\n\t\tbreak;\n\t}\n\n\trtl8710b_read_efuse8(priv, EEPROM_PACKAGE_TYPE_8710B, &package_type);\n\n\tif (package_type == 0xff) {\n\t\tdev_warn(dev, \"Package type is undefined. Assuming it based on the vendor.\\n\");\n\n\t\tif (priv->vendor_umc) {\n\t\t\tpackage_type = PACKAGE_QFN48M_U;\n\t\t} else if (priv->vendor_smic) {\n\t\t\tpackage_type = PACKAGE_QFN48M_S;\n\t\t} else {\n\t\t\tdev_warn(dev, \"The vendor is neither UMC nor SMIC. Assuming the package type is QFN48M_U.\\n\");\n\n\t\t\t \n\t\t\tpackage_type = PACKAGE_QFN48M_U;\n\t\t}\n\t} else if (package_type != PACKAGE_QFN48M_S &&\n\t\t   package_type != PACKAGE_QFN48M_U) {\n\t\tdev_warn(dev, \"Failed to read the package type. Assuming it's the default QFN48M_U.\\n\");\n\n\t\t \n\t\tpackage_type = PACKAGE_QFN48M_U;\n\t}\n\n\tpriv->package_type = package_type;\n\n\tdev_dbg(dev, \"Package type: 0x%x\\n\", package_type);\n\n\tcfg2 = rtl8710b_read_syson_reg(priv, REG_SYS_SYSTEM_CFG2_8710B);\n\tpriv->rom_rev = cfg2 & 0xf;\n\n\treturn rtl8xxxu_config_endpoints_no_sie(priv);\n}\n\nstatic void rtl8710b_revise_cck_tx_psf(struct rtl8xxxu_priv *priv, u8 channel)\n{\n\tif (channel == 13) {\n\t\t \n\t\trtl8xxxu_write32(priv, REG_CCK0_TX_FILTER2, 0x64B80C1C);\n\t\trtl8xxxu_write32(priv, REG_CCK0_DEBUG_PORT, 0x00008810);\n\t\trtl8xxxu_write32(priv, REG_CCK0_TX_FILTER3, 0x01235667);\n\t\t \n\t\trtl8xxxu_write32(priv, REG_CCK0_TX_FILTER1, 0xd1d80001);\n\t} else if (channel == 14) {\n\t\t \n\t\trtl8xxxu_write32(priv, REG_CCK0_TX_FILTER2, 0x0000B81C);\n\t\trtl8xxxu_write32(priv, REG_CCK0_DEBUG_PORT, 0x00000000);\n\t\trtl8xxxu_write32(priv, REG_CCK0_TX_FILTER3, 0x00003667);\n\t\t \n\t\trtl8xxxu_write32(priv, REG_CCK0_TX_FILTER1, 0xE82C0001);\n\t} else {\n\t\t \n\t\trtl8xxxu_write32(priv, REG_CCK0_TX_FILTER2, 0x64B80C1C);\n\t\trtl8xxxu_write32(priv, REG_CCK0_DEBUG_PORT, 0x00008810);\n\t\trtl8xxxu_write32(priv, REG_CCK0_TX_FILTER3, 0x01235667);\n\t\trtl8xxxu_write32(priv, REG_CCK0_TX_FILTER1, 0xE82C0001);\n\t}\n}\n\nstatic void rtl8710bu_config_channel(struct ieee80211_hw *hw)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tbool ht40 = conf_is_ht40(&hw->conf);\n\tu8 channel, subchannel = 0;\n\tbool sec_ch_above = 0;\n\tu32 val32;\n\tu16 val16;\n\n\tchannel = (u8)hw->conf.chandef.chan->hw_value;\n\n\tif (conf_is_ht40_plus(&hw->conf)) {\n\t\tsec_ch_above = 1;\n\t\tchannel += 2;\n\t\tsubchannel = 2;\n\t} else if (conf_is_ht40_minus(&hw->conf)) {\n\t\tsec_ch_above = 0;\n\t\tchannel -= 2;\n\t\tsubchannel = 1;\n\t}\n\n\t \n\tval32 = rtl8xxxu_read_rfreg(priv, RF_A, RF6052_REG_MODE_AG);\n\tu32p_replace_bits(&val32, channel, MODE_AG_CHANNEL_MASK);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_MODE_AG, val32);\n\n\trtl8710b_revise_cck_tx_psf(priv, channel);\n\n\t \n\tval16 = rtl8xxxu_read16(priv, REG_WMAC_TRXPTCL_CTL);\n\tval16 &= ~WMAC_TRXPTCL_CTL_BW_MASK;\n\tif (ht40)\n\t\tval16 |= WMAC_TRXPTCL_CTL_BW_40;\n\trtl8xxxu_write16(priv, REG_WMAC_TRXPTCL_CTL, val16);\n\n\trtl8xxxu_write8(priv, REG_DATA_SUBCHANNEL, subchannel);\n\n\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_RF_MODE);\n\tu32p_replace_bits(&val32, ht40, FPGA_RF_MODE);\n\trtl8xxxu_write32(priv, REG_FPGA0_RF_MODE, val32);\n\n\tval32 = rtl8xxxu_read32(priv, REG_FPGA1_RF_MODE);\n\tu32p_replace_bits(&val32, ht40, FPGA_RF_MODE);\n\trtl8xxxu_write32(priv, REG_FPGA1_RF_MODE, val32);\n\n\tif (ht40) {\n\t\t \n\t\tval32 = rtl8xxxu_read32(priv, REG_CCK0_SYSTEM);\n\t\tu32p_replace_bits(&val32, !sec_ch_above, CCK0_SIDEBAND);\n\t\trtl8xxxu_write32(priv, REG_CCK0_SYSTEM, val32);\n\t}\n\n\t \n\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_RF_MODE);\n\tval32 |= GENMASK(10, 8);\n\trtl8xxxu_write32(priv, REG_FPGA0_RF_MODE, val32);\n\n\t \n\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_RF_MODE);\n\tval32 |= BIT(14) | BIT(12);\n\tval32 &= ~BIT(13);\n\trtl8xxxu_write32(priv, REG_FPGA0_RF_MODE, val32);\n\n\t \n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_TX_PSDO_NOISE_WEIGHT);\n\tval32 &= ~GENMASK(31, 30);\n\trtl8xxxu_write32(priv, REG_OFDM0_TX_PSDO_NOISE_WEIGHT, val32);\n\n\t \n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_TX_PSDO_NOISE_WEIGHT);\n\tval32 &= ~BIT(29);\n\tval32 |= BIT(28);\n\trtl8xxxu_write32(priv, REG_OFDM0_TX_PSDO_NOISE_WEIGHT, val32);\n\n\t \n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_XA_RX_AFE);\n\tval32 &= ~BIT(29);\n\tval32 |= BIT(28);\n\trtl8xxxu_write32(priv, REG_OFDM0_XA_RX_AFE, val32);\n\n\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_XB_RF_INT_OE);\n\tval32 &= ~BIT(30);\n\tval32 |= BIT(29);\n\trtl8xxxu_write32(priv, REG_FPGA0_XB_RF_INT_OE, val32);\n\n\tif (ht40) {\n\t\tval32 = rtl8xxxu_read32(priv, REG_OFDM_RX_DFIR);\n\t\tval32 &= ~BIT(19);\n\t\trtl8xxxu_write32(priv, REG_OFDM_RX_DFIR, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_OFDM_RX_DFIR);\n\t\tval32 &= ~GENMASK(23, 20);\n\t\trtl8xxxu_write32(priv, REG_OFDM_RX_DFIR, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_OFDM_RX_DFIR);\n\t\tval32 &= ~GENMASK(27, 24);\n\t\trtl8xxxu_write32(priv, REG_OFDM_RX_DFIR, val32);\n\n\t\t \n\t\tval32 = rtl8xxxu_read_rfreg(priv, RF_A, RF6052_REG_MODE_AG);\n\t\tval32 &= ~MODE_AG_BW_MASK;\n\t\tval32 |= MODE_AG_BW_40MHZ_8723B;\n\t\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_MODE_AG, val32);\n\t} else {\n\t\tval32 = rtl8xxxu_read32(priv, REG_OFDM_RX_DFIR);\n\t\tval32 |= BIT(19);\n\t\trtl8xxxu_write32(priv, REG_OFDM_RX_DFIR, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_OFDM_RX_DFIR);\n\t\tval32 &= ~GENMASK(23, 20);\n\t\tval32 |= BIT(23);\n\t\trtl8xxxu_write32(priv, REG_OFDM_RX_DFIR, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_OFDM_RX_DFIR);\n\t\tval32 &= ~GENMASK(27, 24);\n\t\tval32 |= BIT(27) | BIT(25);\n\t\trtl8xxxu_write32(priv, REG_OFDM_RX_DFIR, val32);\n\n\t\t \n\t\tval32 = rtl8xxxu_read_rfreg(priv, RF_A, RF6052_REG_MODE_AG);\n\t\tval32 &= ~MODE_AG_BW_MASK;\n\t\tval32 |= MODE_AG_BW_20MHZ_8723B;\n\t\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_MODE_AG, val32);\n\t}\n}\n\nstatic void rtl8710bu_init_aggregation(struct rtl8xxxu_priv *priv)\n{\n\tu32 agg_rx;\n\tu8 agg_ctrl;\n\n\t \n\tagg_ctrl = rtl8xxxu_read8(priv, REG_TRXDMA_CTRL);\n\tagg_ctrl &= ~TRXDMA_CTRL_RXDMA_AGG_EN;\n\n\tagg_rx = rtl8xxxu_read32(priv, REG_RXDMA_AGG_PG_TH);\n\tagg_rx &= ~RXDMA_USB_AGG_ENABLE;\n\tagg_rx &= ~0xFF0F;  \n\n\trtl8xxxu_write8(priv, REG_TRXDMA_CTRL, agg_ctrl);\n\trtl8xxxu_write32(priv, REG_RXDMA_AGG_PG_TH, agg_rx);\n}\n\nstatic void rtl8710bu_init_statistics(struct rtl8xxxu_priv *priv)\n{\n\tu32 val32;\n\n\t \n\trtl8xxxu_write16(priv, REG_NHM_TIMER_8723B + 2, 0xc350);\n\trtl8xxxu_write16(priv, REG_NHM_TH9_TH10_8723B + 2, 0xffff);\n\trtl8xxxu_write32(priv, REG_NHM_TH3_TO_TH0_8723B, 0xffffff50);\n\trtl8xxxu_write32(priv, REG_NHM_TH7_TO_TH4_8723B, 0xffffffff);\n\n\t \n\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_IQK);\n\tval32 |= 0xff;\n\trtl8xxxu_write32(priv, REG_FPGA0_IQK, val32);\n\n\t \n\tval32 = rtl8xxxu_read32(priv, REG_NHM_TH9_TH10_8723B);\n\tval32 &= ~(BIT(8) | BIT(9) | BIT(10));\n\tval32 |= BIT(8);\n\trtl8xxxu_write32(priv, REG_NHM_TH9_TH10_8723B, val32);\n\n\t \n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_FA_RSTC);\n\tval32 |= BIT(7);\n\trtl8xxxu_write32(priv, REG_OFDM0_FA_RSTC, val32);\n}\n\nstatic int rtl8710b_read_efuse(struct rtl8xxxu_priv *priv)\n{\n\tstruct device *dev = &priv->udev->dev;\n\tu8 val8, word_mask, header, extheader;\n\tu16 efuse_addr, offset;\n\tint i, ret = 0;\n\tu32 val32;\n\n\tval32 = rtl8710b_read_syson_reg(priv, REG_SYS_EEPROM_CTRL0_8710B);\n\tpriv->boot_eeprom = u32_get_bits(val32, EEPROM_BOOT);\n\tpriv->has_eeprom = u32_get_bits(val32, EEPROM_ENABLE);\n\n\t \n\tmemset(priv->efuse_wifi.raw, 0xff, EFUSE_MAP_LEN);\n\n\tefuse_addr = 0;\n\twhile (efuse_addr < EFUSE_REAL_CONTENT_LEN_8723A) {\n\t\tu16 map_addr;\n\n\t\tret = rtl8710b_read_efuse8(priv, efuse_addr++, &header);\n\t\tif (ret || header == 0xff)\n\t\t\tgoto exit;\n\n\t\tif ((header & 0x1f) == 0x0f) {\t \n\t\t\toffset = (header & 0xe0) >> 5;\n\n\t\t\tret = rtl8710b_read_efuse8(priv, efuse_addr++, &extheader);\n\t\t\tif (ret)\n\t\t\t\tgoto exit;\n\n\t\t\t \n\t\t\tif ((extheader & 0x0f) == 0x0f)\n\t\t\t\tcontinue;\n\n\t\t\toffset |= ((extheader & 0xf0) >> 1);\n\t\t\tword_mask = extheader & 0x0f;\n\t\t} else {\n\t\t\toffset = (header >> 4) & 0x0f;\n\t\t\tword_mask = header & 0x0f;\n\t\t}\n\n\t\t \n\n\t\t \n\t\tmap_addr = offset * 8;\n\t\tfor (i = 0; i < EFUSE_MAX_WORD_UNIT; i++) {\n\t\t\t \n\t\t\tif (word_mask & BIT(i)) {\n\t\t\t\tmap_addr += 2;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tret = rtl8710b_read_efuse8(priv, efuse_addr++, &val8);\n\t\t\tif (ret)\n\t\t\t\tgoto exit;\n\t\t\tif (map_addr >= EFUSE_MAP_LEN - 1) {\n\t\t\t\tdev_warn(dev, \"%s: Illegal map_addr (%04x), efuse corrupt!\\n\",\n\t\t\t\t\t __func__, map_addr);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tpriv->efuse_wifi.raw[map_addr++] = val8;\n\n\t\t\tret = rtl8710b_read_efuse8(priv, efuse_addr++, &val8);\n\t\t\tif (ret)\n\t\t\t\tgoto exit;\n\t\t\tpriv->efuse_wifi.raw[map_addr++] = val8;\n\t\t}\n\t}\n\nexit:\n\n\treturn ret;\n}\n\nstatic int rtl8710bu_parse_efuse(struct rtl8xxxu_priv *priv)\n{\n\tstruct rtl8710bu_efuse *efuse = &priv->efuse_wifi.efuse8710bu;\n\n\tif (efuse->rtl_id != cpu_to_le16(0x8195))\n\t\treturn -EINVAL;\n\n\tether_addr_copy(priv->mac_addr, efuse->mac_addr);\n\n\tmemcpy(priv->cck_tx_power_index_A, efuse->tx_power_index_A.cck_base,\n\t       sizeof(efuse->tx_power_index_A.cck_base));\n\n\tmemcpy(priv->ht40_1s_tx_power_index_A,\n\t       efuse->tx_power_index_A.ht40_base,\n\t       sizeof(efuse->tx_power_index_A.ht40_base));\n\n\tpriv->ofdm_tx_power_diff[0].a = efuse->tx_power_index_A.ht20_ofdm_1s_diff.a;\n\tpriv->ht20_tx_power_diff[0].a = efuse->tx_power_index_A.ht20_ofdm_1s_diff.b;\n\n\tpriv->default_crystal_cap = efuse->xtal_k & 0x3f;\n\n\treturn 0;\n}\n\nstatic int rtl8710bu_load_firmware(struct rtl8xxxu_priv *priv)\n{\n\tif (priv->vendor_smic) {\n\t\treturn rtl8xxxu_load_firmware(priv, \"rtlwifi/rtl8710bufw_SMIC.bin\");\n\t} else if (priv->vendor_umc) {\n\t\treturn rtl8xxxu_load_firmware(priv, \"rtlwifi/rtl8710bufw_UMC.bin\");\n\t} else {\n\t\tdev_err(&priv->udev->dev, \"We have no suitable firmware for this chip.\\n\");\n\t\treturn -1;\n\t}\n}\n\nstatic void rtl8710bu_init_phy_bb(struct rtl8xxxu_priv *priv)\n{\n\tconst struct rtl8xxxu_reg32val *phy_init_table;\n\tu32 val32;\n\n\t \n\tval32 = rtl8xxxu_read32(priv, REG_SYS_FUNC_8710B);\n\tval32 |= GENMASK(17, 16) | GENMASK(26, 24);\n\trtl8xxxu_write32(priv, REG_SYS_FUNC_8710B, val32);\n\n\tif (priv->package_type == PACKAGE_QFN48M_U)\n\t\tphy_init_table = rtl8710bu_qfn48m_u_phy_init_table;\n\telse\n\t\tphy_init_table = rtl8710bu_qfn48m_s_phy_init_table;\n\n\trtl8xxxu_init_phy_regs(priv, phy_init_table);\n\n\trtl8xxxu_init_phy_regs(priv, rtl8710b_agc_table);\n}\n\nstatic int rtl8710bu_init_phy_rf(struct rtl8xxxu_priv *priv)\n{\n\tconst struct rtl8xxxu_rfregval *radioa_init_table;\n\n\tif (priv->package_type == PACKAGE_QFN48M_U)\n\t\tradioa_init_table = rtl8710bu_qfn48m_u_radioa_init_table;\n\telse\n\t\tradioa_init_table = rtl8710bu_qfn48m_s_radioa_init_table;\n\n\treturn rtl8xxxu_init_phy_rf(priv, radioa_init_table, RF_A);\n}\n\nstatic int rtl8710bu_iqk_path_a(struct rtl8xxxu_priv *priv, u32 *lok_result)\n{\n\tu32 reg_eac, reg_e94, reg_e9c, val32, path_sel_bb;\n\tint result = 0;\n\n\tpath_sel_bb = rtl8xxxu_read32(priv, REG_S0S1_PATH_SWITCH);\n\n\trtl8xxxu_write32(priv, REG_S0S1_PATH_SWITCH, 0x99000000);\n\n\t \n\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_IQK);\n\tu32p_replace_bits(&val32, 0, 0xffffff00);\n\trtl8xxxu_write32(priv, REG_FPGA0_IQK, val32);\n\n\t \n\tval32 = rtl8xxxu_read_rfreg(priv, RF_A, RF6052_REG_WE_LUT);\n\tval32 |= 0x80000;\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_WE_LUT, val32);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_RCK_OS, 0x20000);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_TXPA_G1, 0x0000f);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_TXPA_G2, 0x07ff7);\n\n\t \n\tval32 = rtl8xxxu_read_rfreg(priv, RF_A, RF6052_REG_GAIN_CCA);\n\tval32 |= BIT(11);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_GAIN_CCA, val32);\n\tval32 = rtl8xxxu_read_rfreg(priv, RF_A, RF6052_REG_PAD_TXG);\n\tu32p_replace_bits(&val32, 0x1ed, 0x00fff);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_PAD_TXG, val32);\n\n\t \n\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_IQK);\n\tu32p_replace_bits(&val32, 0x808000, 0xffffff00);\n\trtl8xxxu_write32(priv, REG_FPGA0_IQK, val32);\n\n\t \n\trtl8xxxu_write32(priv, REG_TX_IQK_TONE_A, 0x18008c1c);\n\trtl8xxxu_write32(priv, REG_RX_IQK_TONE_A, 0x38008c1c);\n\n\trtl8xxxu_write32(priv, REG_TX_IQK_PI_A, 0x821403ff);\n\trtl8xxxu_write32(priv, REG_RX_IQK_PI_A, 0x28160c06);\n\n\t \n\trtl8xxxu_write32(priv, REG_IQK_AGC_RSP, 0x02002911);\n\n\t \n\trtl8xxxu_write32(priv, REG_IQK_AGC_PTS, 0xfa000000);\n\trtl8xxxu_write32(priv, REG_IQK_AGC_PTS, 0xf8000000);\n\n\tmdelay(10);\n\n\trtl8xxxu_write32(priv, REG_S0S1_PATH_SWITCH, path_sel_bb);\n\n\t \n\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_IQK);\n\tu32p_replace_bits(&val32, 0, 0xffffff00);\n\trtl8xxxu_write32(priv, REG_FPGA0_IQK, val32);\n\n\tval32 = rtl8xxxu_read_rfreg(priv, RF_A, RF6052_REG_GAIN_CCA);\n\tval32 &= ~BIT(11);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_GAIN_CCA, val32);\n\n\t \n\t*lok_result = rtl8xxxu_read_rfreg(priv, RF_A, RF6052_REG_TXM_IDAC);\n\n\t \n\treg_eac = rtl8xxxu_read32(priv, REG_RX_POWER_AFTER_IQK_A_2);\n\treg_e94 = rtl8xxxu_read32(priv, REG_TX_POWER_BEFORE_IQK_A);\n\treg_e9c = rtl8xxxu_read32(priv, REG_TX_POWER_AFTER_IQK_A);\n\n\tif (!(reg_eac & BIT(28)) &&\n\t    ((reg_e94 & 0x03ff0000) != 0x01420000) &&\n\t    ((reg_e9c & 0x03ff0000) != 0x00420000))\n\t\tresult |= 0x01;\n\n\treturn result;\n}\n\nstatic int rtl8710bu_rx_iqk_path_a(struct rtl8xxxu_priv *priv, u32 lok_result)\n{\n\tu32 reg_ea4, reg_eac, reg_e94, reg_e9c, val32, path_sel_bb, tmp;\n\tint result = 0;\n\n\tpath_sel_bb = rtl8xxxu_read32(priv, REG_S0S1_PATH_SWITCH);\n\n\trtl8xxxu_write32(priv, REG_S0S1_PATH_SWITCH, 0x99000000);\n\n\t \n\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_IQK);\n\tu32p_replace_bits(&val32, 0, 0xffffff00);\n\trtl8xxxu_write32(priv, REG_FPGA0_IQK, val32);\n\n\t \n\tval32 = rtl8xxxu_read_rfreg(priv, RF_A, RF6052_REG_WE_LUT);\n\tval32 |= 0x80000;\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_WE_LUT, val32);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_RCK_OS, 0x30000);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_TXPA_G1, 0x0000f);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_TXPA_G2, 0xf1173);\n\n\t \n\tval32 = rtl8xxxu_read_rfreg(priv, RF_A, RF6052_REG_GAIN_CCA);\n\tval32 |= BIT(11);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_GAIN_CCA, val32);\n\tval32 = rtl8xxxu_read_rfreg(priv, RF_A, RF6052_REG_PAD_TXG);\n\tu32p_replace_bits(&val32, 0xf, 0x003e0);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_PAD_TXG, val32);\n\n\t \n\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_IQK);\n\tu32p_replace_bits(&val32, 0x808000, 0xffffff00);\n\trtl8xxxu_write32(priv, REG_FPGA0_IQK, val32);\n\n\t \n\trtl8xxxu_write32(priv, REG_TX_IQK_TONE_A, 0x18008c1c);\n\trtl8xxxu_write32(priv, REG_RX_IQK_TONE_A, 0x38008c1c);\n\n\trtl8xxxu_write32(priv, REG_TX_IQK_PI_A, 0x8216129f);\n\trtl8xxxu_write32(priv, REG_RX_IQK_PI_A, 0x28160c00);\n\n\t \n\trtl8xxxu_write32(priv, REG_TX_IQK, 0x01007c00);\n\trtl8xxxu_write32(priv, REG_RX_IQK, 0x01004800);\n\n\t \n\trtl8xxxu_write32(priv, REG_IQK_AGC_RSP, 0x0046a911);\n\n\t \n\trtl8xxxu_write32(priv, REG_IQK_AGC_PTS, 0xf9000000);\n\trtl8xxxu_write32(priv, REG_IQK_AGC_PTS, 0xf8000000);\n\n\tmdelay(10);\n\n\t \n\treg_eac = rtl8xxxu_read32(priv, REG_RX_POWER_AFTER_IQK_A_2);\n\treg_e94 = rtl8xxxu_read32(priv, REG_TX_POWER_BEFORE_IQK_A);\n\treg_e9c = rtl8xxxu_read32(priv, REG_TX_POWER_AFTER_IQK_A);\n\n\tif (!(reg_eac & BIT(28)) &&\n\t    ((reg_e94 & 0x03ff0000) != 0x01420000) &&\n\t    ((reg_e9c & 0x03ff0000) != 0x00420000)) {\n\t\tresult |= 0x01;\n\t} else {  \n\n\t\t \n\t\trtl8xxxu_write32(priv, REG_S0S1_PATH_SWITCH, path_sel_bb);\n\n\t\t \n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_IQK);\n\t\tu32p_replace_bits(&val32, 0, 0xffffff00);\n\t\trtl8xxxu_write32(priv, REG_FPGA0_IQK, val32);\n\n\t\tval32 = rtl8xxxu_read_rfreg(priv, RF_A, RF6052_REG_GAIN_CCA);\n\t\tval32 &= ~BIT(11);\n\t\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_GAIN_CCA, val32);\n\n\t\treturn result;\n\t}\n\n\tval32 = 0x80007c00 | (reg_e94 & 0x3ff0000) | ((reg_e9c & 0x3ff0000) >> 16);\n\trtl8xxxu_write32(priv, REG_TX_IQK, val32);\n\n\t \n\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_IQK);\n\tu32p_replace_bits(&val32, 0, 0xffffff00);\n\trtl8xxxu_write32(priv, REG_FPGA0_IQK, val32);\n\n\tval32 = rtl8xxxu_read_rfreg(priv, RF_A, RF6052_REG_WE_LUT);\n\tval32 |= 0x80000;\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_WE_LUT, val32);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_RCK_OS, 0x30000);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_TXPA_G1, 0x0000f);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_TXPA_G2, 0xf7ff2);\n\n\t \n\tval32 = rtl8xxxu_read_rfreg(priv, RF_A, RF6052_REG_GAIN_CCA);\n\tval32 |= BIT(11);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_GAIN_CCA, val32);\n\tval32 = rtl8xxxu_read_rfreg(priv, RF_A, RF6052_REG_PAD_TXG);\n\tu32p_replace_bits(&val32, 0x2a, 0x00fff);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_PAD_TXG, val32);\n\n\t \n\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_IQK);\n\tu32p_replace_bits(&val32, 0x808000, 0xffffff00);\n\trtl8xxxu_write32(priv, REG_FPGA0_IQK, val32);\n\n\t \n\trtl8xxxu_write32(priv, REG_RX_IQK, 0x01004800);\n\n\t \n\trtl8xxxu_write32(priv, REG_TX_IQK_TONE_A, 0x38008c1c);\n\trtl8xxxu_write32(priv, REG_RX_IQK_TONE_A, 0x18008c1c);\n\n\trtl8xxxu_write32(priv, REG_RX_IQK_PI_A, 0x2816169f);\n\n\t \n\trtl8xxxu_write32(priv, REG_IQK_AGC_RSP, 0x0046a911);\n\n\t \n\trtl8xxxu_write32(priv, REG_IQK_AGC_PTS, 0xf9000000);\n\trtl8xxxu_write32(priv, REG_IQK_AGC_PTS, 0xf8000000);\n\n\tmdelay(10);\n\n\t \n\trtl8xxxu_write32(priv, REG_S0S1_PATH_SWITCH, path_sel_bb);\n\n\t \n\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_IQK);\n\tu32p_replace_bits(&val32, 0, 0xffffff00);\n\trtl8xxxu_write32(priv, REG_FPGA0_IQK, val32);\n\n\tval32 = rtl8xxxu_read_rfreg(priv, RF_A, RF6052_REG_GAIN_CCA);\n\tval32 &= ~BIT(11);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_GAIN_CCA, val32);\n\n\t \n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_TXM_IDAC, lok_result);\n\n\t \n\treg_eac = rtl8xxxu_read32(priv, REG_RX_POWER_AFTER_IQK_A_2);\n\treg_ea4 = rtl8xxxu_read32(priv, REG_RX_POWER_BEFORE_IQK_A_2);\n\n\ttmp = (reg_eac & 0x03ff0000) >> 16;\n\tif ((tmp & 0x200) > 0)\n\t\ttmp = 0x400 - tmp;\n\n\tif (!(reg_eac & BIT(27)) &&\n\t    ((reg_ea4 & 0x03ff0000) != 0x01320000) &&\n\t    ((reg_eac & 0x03ff0000) != 0x00360000) &&\n\t    (((reg_ea4 & 0x03ff0000) >> 16) < 0x11a) &&\n\t    (((reg_ea4 & 0x03ff0000) >> 16) > 0xe6) &&\n\t    (tmp < 0x1a))\n\t\tresult |= 0x02;\n\n\treturn result;\n}\n\nstatic void rtl8710bu_phy_iqcalibrate(struct rtl8xxxu_priv *priv,\n\t\t\t\t      int result[][8], int t)\n{\n\tstruct device *dev = &priv->udev->dev;\n\tu32 i, val32, rx_initial_gain, lok_result;\n\tu32 path_sel_bb, path_sel_rf;\n\tint path_a_ok;\n\tint retry = 2;\n\tstatic const u32 adda_regs[RTL8XXXU_ADDA_REGS] = {\n\t\tREG_FPGA0_XCD_SWITCH_CTRL, REG_BLUETOOTH,\n\t\tREG_RX_WAIT_CCA, REG_TX_CCK_RFON,\n\t\tREG_TX_CCK_BBON, REG_TX_OFDM_RFON,\n\t\tREG_TX_OFDM_BBON, REG_TX_TO_RX,\n\t\tREG_TX_TO_TX, REG_RX_CCK,\n\t\tREG_RX_OFDM, REG_RX_WAIT_RIFS,\n\t\tREG_RX_TO_RX, REG_STANDBY,\n\t\tREG_SLEEP, REG_PMPD_ANAEN\n\t};\n\tstatic const u32 iqk_mac_regs[RTL8XXXU_MAC_REGS] = {\n\t\tREG_TXPAUSE, REG_BEACON_CTRL,\n\t\tREG_BEACON_CTRL_1, REG_GPIO_MUXCFG\n\t};\n\tstatic const u32 iqk_bb_regs[RTL8XXXU_BB_REGS] = {\n\t\tREG_OFDM0_TRX_PATH_ENABLE, REG_OFDM0_TR_MUX_PAR,\n\t\tREG_FPGA0_XCD_RF_SW_CTRL, REG_CONFIG_ANT_A, REG_CONFIG_ANT_B,\n\t\tREG_FPGA0_XAB_RF_SW_CTRL, REG_FPGA0_XA_RF_INT_OE,\n\t\tREG_FPGA0_XB_RF_INT_OE, REG_CCK0_AFE_SETTING\n\t};\n\n\t \n\n\trx_initial_gain = rtl8xxxu_read32(priv, REG_OFDM0_XA_AGC_CORE1);\n\n\tif (t == 0) {\n\t\t \n\t\trtl8xxxu_save_regs(priv, adda_regs, priv->adda_backup,\n\t\t\t\t   RTL8XXXU_ADDA_REGS);\n\t\trtl8xxxu_save_mac_regs(priv, iqk_mac_regs, priv->mac_backup);\n\t\trtl8xxxu_save_regs(priv, iqk_bb_regs,\n\t\t\t\t   priv->bb_backup, RTL8XXXU_BB_REGS);\n\t}\n\n\trtl8xxxu_path_adda_on(priv, adda_regs, true);\n\n\tif (t == 0) {\n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_XA_HSSI_PARM1);\n\t\tpriv->pi_enabled = u32_get_bits(val32, FPGA0_HSSI_PARM1_PI);\n\t}\n\n\tif (!priv->pi_enabled) {\n\t\t \n\t\trtl8xxxu_write32(priv, REG_FPGA0_XA_HSSI_PARM1, 0x01000100);\n\t\trtl8xxxu_write32(priv, REG_FPGA0_XB_HSSI_PARM1, 0x01000100);\n\t}\n\n\t \n\tval32 = rtl8xxxu_read32(priv, REG_TX_PTCL_CTRL);\n\tval32 |= 0x00ff0000;\n\trtl8xxxu_write32(priv, REG_TX_PTCL_CTRL, val32);\n\n\t \n\tpath_sel_bb = rtl8xxxu_read32(priv, REG_S0S1_PATH_SWITCH);\n\tpath_sel_rf = rtl8xxxu_read_rfreg(priv, RF_A, RF6052_REG_S0S1);\n\n\t \n\tval32 = rtl8xxxu_read32(priv, REG_CCK0_AFE_SETTING);\n\tval32 |= 0x0f000000;\n\trtl8xxxu_write32(priv, REG_CCK0_AFE_SETTING, val32);\n\trtl8xxxu_write32(priv, REG_RX_WAIT_CCA, 0x03c00010);\n\trtl8xxxu_write32(priv, REG_OFDM0_TRX_PATH_ENABLE, 0x03a05601);\n\trtl8xxxu_write32(priv, REG_OFDM0_TR_MUX_PAR, 0x000800e4);\n\trtl8xxxu_write32(priv, REG_FPGA0_XCD_RF_SW_CTRL, 0x25204000);\n\n\t \n\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_IQK);\n\tu32p_replace_bits(&val32, 0x808000, 0xffffff00);\n\trtl8xxxu_write32(priv, REG_FPGA0_IQK, val32);\n\trtl8xxxu_write32(priv, REG_TX_IQK, 0x01007c00);\n\trtl8xxxu_write32(priv, REG_RX_IQK, 0x01004800);\n\n\tfor (i = 0; i < retry; i++) {\n\t\tpath_a_ok = rtl8710bu_iqk_path_a(priv, &lok_result);\n\n\t\tif (path_a_ok == 0x01) {\n\t\t\tval32 = rtl8xxxu_read32(priv, REG_TX_POWER_BEFORE_IQK_A);\n\t\t\tresult[t][0] = (val32 >> 16) & 0x3ff;\n\n\t\t\tval32 = rtl8xxxu_read32(priv, REG_TX_POWER_AFTER_IQK_A);\n\t\t\tresult[t][1] = (val32 >> 16) & 0x3ff;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tresult[t][0] = 0x100;\n\t\t\tresult[t][1] = 0x0;\n\t\t}\n\t}\n\n\tfor (i = 0; i < retry; i++) {\n\t\tpath_a_ok = rtl8710bu_rx_iqk_path_a(priv, lok_result);\n\n\t\tif (path_a_ok == 0x03) {\n\t\t\tval32 = rtl8xxxu_read32(priv, REG_RX_POWER_BEFORE_IQK_A_2);\n\t\t\tresult[t][2] = (val32 >> 16) & 0x3ff;\n\n\t\t\tval32 = rtl8xxxu_read32(priv, REG_RX_POWER_AFTER_IQK_A_2);\n\t\t\tresult[t][3] = (val32 >> 16) & 0x3ff;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tresult[t][2] = 0x100;\n\t\t\tresult[t][3] = 0x0;\n\t\t}\n\t}\n\n\tif (!path_a_ok)\n\t\tdev_warn(dev, \"%s: Path A IQK failed!\\n\", __func__);\n\n\t \n\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_IQK);\n\tu32p_replace_bits(&val32, 0, 0xffffff00);\n\trtl8xxxu_write32(priv, REG_FPGA0_IQK, val32);\n\n\tif (t == 0)\n\t\treturn;\n\n\t \n\trtl8xxxu_restore_regs(priv, adda_regs, priv->adda_backup, RTL8XXXU_ADDA_REGS);\n\n\t \n\trtl8xxxu_restore_mac_regs(priv, iqk_mac_regs, priv->mac_backup);\n\n\t \n\trtl8xxxu_restore_regs(priv, iqk_bb_regs, priv->bb_backup, RTL8XXXU_BB_REGS);\n\n\t \n\trtl8xxxu_write32(priv, REG_S0S1_PATH_SWITCH, path_sel_bb);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_S0S1, path_sel_rf);\n\n\t \n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_XA_AGC_CORE1);\n\tu32p_replace_bits(&val32, 0x50, 0x000000ff);\n\trtl8xxxu_write32(priv, REG_OFDM0_XA_AGC_CORE1, val32);\n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_XA_AGC_CORE1);\n\tu32p_replace_bits(&val32, rx_initial_gain & 0xff, 0x000000ff);\n\trtl8xxxu_write32(priv, REG_OFDM0_XA_AGC_CORE1, val32);\n\n\t \n\trtl8xxxu_write32(priv, REG_TX_IQK_TONE_A, 0x01008c00);\n\trtl8xxxu_write32(priv, REG_RX_IQK_TONE_A, 0x01008c00);\n}\n\nstatic void rtl8710bu_phy_iq_calibrate(struct rtl8xxxu_priv *priv)\n{\n\tstruct device *dev = &priv->udev->dev;\n\tint result[4][8];  \n\tint i, candidate;\n\tbool path_a_ok;\n\ts32 reg_e94, reg_e9c, reg_ea4, reg_eac;\n\ts32 reg_tmp = 0;\n\tbool simu;\n\tu32 path_sel_bb;\n\n\t \n\tpath_sel_bb = rtl8xxxu_read32(priv, REG_S0S1_PATH_SWITCH);\n\n\tmemset(result, 0, sizeof(result));\n\tcandidate = -1;\n\n\tpath_a_ok = false;\n\n\tfor (i = 0; i < 3; i++) {\n\t\trtl8710bu_phy_iqcalibrate(priv, result, i);\n\n\t\tif (i == 1) {\n\t\t\tsimu = rtl8xxxu_gen2_simularity_compare(priv, result, 0, 1);\n\t\t\tif (simu) {\n\t\t\t\tcandidate = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (i == 2) {\n\t\t\tsimu = rtl8xxxu_gen2_simularity_compare(priv, result, 0, 2);\n\t\t\tif (simu) {\n\t\t\t\tcandidate = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tsimu = rtl8xxxu_gen2_simularity_compare(priv, result, 1, 2);\n\t\t\tif (simu) {\n\t\t\t\tcandidate = 1;\n\t\t\t} else {\n\t\t\t\tfor (i = 0; i < 8; i++)\n\t\t\t\t\treg_tmp += result[3][i];\n\n\t\t\t\tif (reg_tmp)\n\t\t\t\t\tcandidate = 3;\n\t\t\t\telse\n\t\t\t\t\tcandidate = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (candidate >= 0) {\n\t\treg_e94 = result[candidate][0];\n\t\treg_e9c = result[candidate][1];\n\t\treg_ea4 = result[candidate][2];\n\t\treg_eac = result[candidate][3];\n\n\t\tdev_dbg(dev, \"%s: candidate is %x\\n\", __func__, candidate);\n\t\tdev_dbg(dev, \"%s: e94=%x e9c=%x ea4=%x eac=%x\\n\",\n\t\t\t__func__, reg_e94, reg_e9c, reg_ea4, reg_eac);\n\n\t\tpath_a_ok = true;\n\n\t\tif (reg_e94)\n\t\t\trtl8xxxu_fill_iqk_matrix_a(priv, path_a_ok, result,\n\t\t\t\t\t\t   candidate, (reg_ea4 == 0));\n\t}\n\n\trtl8xxxu_save_regs(priv, rtl8xxxu_iqk_phy_iq_bb_reg,\n\t\t\t   priv->bb_recovery_backup, RTL8XXXU_BB_REGS);\n\n\trtl8xxxu_write32(priv, REG_S0S1_PATH_SWITCH, path_sel_bb);\n}\n\nstatic int rtl8710b_emu_to_active(struct rtl8xxxu_priv *priv)\n{\n\tu8 val8;\n\tint count, ret = 0;\n\n\t \n\tval8 = rtl8xxxu_read8(priv, 0x5d);\n\tval8 &= ~BIT(0);\n\trtl8xxxu_write8(priv, 0x5d, val8);\n\n\tval8 = rtl8xxxu_read8(priv, REG_SYS_FUNC_8710B);\n\tval8 |= BIT(0);\n\trtl8xxxu_write8(priv, REG_SYS_FUNC_8710B, val8);\n\n\trtl8xxxu_write8(priv, 0x56, 0x0e);\n\n\tval8 = rtl8xxxu_read8(priv, 0x20);\n\tval8 |= BIT(0);\n\trtl8xxxu_write8(priv, 0x20, val8);\n\n\tfor (count = RTL8XXXU_MAX_REG_POLL; count; count--) {\n\t\tval8 = rtl8xxxu_read8(priv, 0x20);\n\t\tif (!(val8 & BIT(0)))\n\t\t\tbreak;\n\n\t\tudelay(10);\n\t}\n\n\tif (!count)\n\t\tret = -EBUSY;\n\n\treturn ret;\n}\n\nstatic int rtl8710bu_active_to_emu(struct rtl8xxxu_priv *priv)\n{\n\tu8 val8;\n\tu32 val32;\n\tint count, ret = 0;\n\n\t \n\tval32 = rtl8xxxu_read32(priv, REG_SYS_FUNC_8710B);\n\tval32 &= ~GENMASK(26, 24);\n\trtl8xxxu_write32(priv, REG_SYS_FUNC_8710B, val32);\n\n\t \n\tval32 = rtl8xxxu_read32(priv, REG_SYS_FUNC_8710B);\n\tval32 &= ~GENMASK(17, 16);\n\trtl8xxxu_write32(priv, REG_SYS_FUNC_8710B, val32);\n\n\t \n\tval8 = rtl8xxxu_read8(priv, 0x20);\n\tval8 |= BIT(1);\n\trtl8xxxu_write8(priv, 0x20, val8);\n\n\tfor (count = RTL8XXXU_MAX_REG_POLL; count; count--) {\n\t\tval8 = rtl8xxxu_read8(priv, 0x20);\n\t\tif ((val8 & BIT(1)) == 0) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tudelay(10);\n\t}\n\n\tif (!count)\n\t\tret = -EBUSY;\n\n\treturn ret;\n}\n\nstatic int rtl8710bu_active_to_lps(struct rtl8xxxu_priv *priv)\n{\n\tstruct device *dev = &priv->udev->dev;\n\tu8 val8;\n\tu16 val16;\n\tu32 val32;\n\tint retry, retval;\n\n\t \n\trtl8xxxu_write8(priv, REG_TXPAUSE, 0xff);\n\n\tretry = 100;\n\tretval = -EBUSY;\n\t \n\tdo {\n\t\tval32 = rtl8xxxu_read32(priv, REG_SCH_TX_CMD);\n\t\tif (!val32) {\n\t\t\tretval = 0;\n\t\t\tbreak;\n\t\t}\n\t\tudelay(10);\n\t} while (retry--);\n\n\tif (!retry) {\n\t\tdev_warn(dev, \"Failed to flush TX queue\\n\");\n\t\tretval = -EBUSY;\n\t\treturn retval;\n\t}\n\n\t \n\tval8 = rtl8xxxu_read8(priv, REG_SYS_FUNC);\n\tval8 &= ~SYS_FUNC_BBRSTB;\n\trtl8xxxu_write8(priv, REG_SYS_FUNC, val8);\n\n\tudelay(2);\n\n\t \n\tval8 = rtl8xxxu_read8(priv, REG_SYS_FUNC);\n\tval8 &= ~SYS_FUNC_BB_GLB_RSTN;\n\trtl8xxxu_write8(priv, REG_SYS_FUNC, val8);\n\n\t \n\tval16 = rtl8xxxu_read16(priv, REG_CR);\n\tval16 &= 0xff00;\n\tval16 |= CR_HCI_RXDMA_ENABLE | CR_HCI_TXDMA_ENABLE;\n\tval16 &= ~CR_SECURITY_ENABLE;\n\trtl8xxxu_write16(priv, REG_CR, val16);\n\n\t \n\tval8 = rtl8xxxu_read8(priv, REG_DUAL_TSF_RST);\n\tval8 |= DUAL_TSF_TX_OK;\n\trtl8xxxu_write8(priv, REG_DUAL_TSF_RST, val8);\n\n\treturn retval;\n}\n\nstatic int rtl8710bu_power_on(struct rtl8xxxu_priv *priv)\n{\n\tu32 val32;\n\tu16 val16;\n\tu8 val8;\n\tint ret;\n\n\trtl8xxxu_write8(priv, REG_USB_ACCESS_TIMEOUT, 0x80);\n\n\tval8 = rtl8xxxu_read8(priv, REG_SYS_ISO_CTRL);\n\tval8 &= ~BIT(5);\n\trtl8xxxu_write8(priv, REG_SYS_ISO_CTRL, val8);\n\n\tval8 = rtl8xxxu_read8(priv, REG_SYS_FUNC_8710B);\n\tval8 |= BIT(0);\n\trtl8xxxu_write8(priv, REG_SYS_FUNC_8710B, val8);\n\n\tval8 = rtl8xxxu_read8(priv, 0x20);\n\tval8 |= BIT(0);\n\trtl8xxxu_write8(priv, 0x20, val8);\n\n\trtl8xxxu_write8(priv, REG_AFE_CTRL_8710B, 0);\n\n\tval8 = rtl8xxxu_read8(priv, REG_WL_STATUS_8710B);\n\tval8 |= BIT(1);\n\trtl8xxxu_write8(priv, REG_WL_STATUS_8710B, val8);\n\n\tret = rtl8710b_emu_to_active(priv);\n\tif (ret)\n\t\treturn ret;\n\n\trtl8xxxu_write16(priv, REG_CR, 0);\n\n\tval16 = rtl8xxxu_read16(priv, REG_CR);\n\n\tval16 |= CR_HCI_TXDMA_ENABLE | CR_HCI_RXDMA_ENABLE |\n\t\t CR_TXDMA_ENABLE | CR_RXDMA_ENABLE |\n\t\t CR_PROTOCOL_ENABLE | CR_SCHEDULE_ENABLE |\n\t\t CR_SECURITY_ENABLE | CR_CALTIMER_ENABLE;\n\trtl8xxxu_write16(priv, REG_CR, val16);\n\n\t \n\tval8 = rtl8xxxu_read8(priv, REG_HWSEQ_CTRL);\n\tval8 |= 0x7f;\n\trtl8xxxu_write8(priv, REG_HWSEQ_CTRL, val8);\n\n\tudelay(2);\n\n\t \n\n\tval8 = rtl8xxxu_read8(priv, 0xfef9);\n\tval8 &= ~BIT(0);\n\trtl8xxxu_write8(priv, 0xfef9, val8);\n\n\t \n\tval32 = rtl8710b_read_syson_reg(priv, 0x138);\n\tval32 &= ~BIT(5);\n\trtl8710b_write_syson_reg(priv, 0x138, val32);\n\n\treturn ret;\n}\n\nstatic void rtl8710bu_power_off(struct rtl8xxxu_priv *priv)\n{\n\tu32 val32;\n\tu8 val8;\n\n\trtl8xxxu_flush_fifo(priv);\n\n\trtl8xxxu_write32(priv, REG_HISR0_8710B, 0xffffffff);\n\trtl8xxxu_write32(priv, REG_HIMR0_8710B, 0x0);\n\n\t \n\tval32 = rtl8710b_read_syson_reg(priv, 0x138);\n\tval32 |= BIT(5);\n\trtl8710b_write_syson_reg(priv, 0x138, val32);\n\n\t \n\trtl8xxxu_write8(priv, REG_CR, 0x00);\n\n\trtl8710bu_active_to_lps(priv);\n\n\t \n\tval8 = rtl8xxxu_read8(priv, REG_8051FW_CTRL_V1_8710B + 3);\n\tval8 &= ~BIT(0);\n\trtl8xxxu_write8(priv, REG_8051FW_CTRL_V1_8710B + 3, val8);\n\n\t \n\trtl8xxxu_write8(priv, REG_8051FW_CTRL_V1_8710B, 0x00);\n\n\trtl8710bu_active_to_emu(priv);\n}\n\nstatic void rtl8710b_reset_8051(struct rtl8xxxu_priv *priv)\n{\n\tu8 val8;\n\n\tval8 = rtl8xxxu_read8(priv, REG_8051FW_CTRL_V1_8710B + 3);\n\tval8 &= ~BIT(0);\n\trtl8xxxu_write8(priv, REG_8051FW_CTRL_V1_8710B + 3, val8);\n\n\tudelay(50);\n\n\tval8 = rtl8xxxu_read8(priv, REG_8051FW_CTRL_V1_8710B + 3);\n\tval8 |= BIT(0);\n\trtl8xxxu_write8(priv, REG_8051FW_CTRL_V1_8710B + 3, val8);\n}\n\nstatic void rtl8710b_enable_rf(struct rtl8xxxu_priv *priv)\n{\n\tu32 val32;\n\n\trtl8xxxu_write8(priv, REG_RF_CTRL, RF_ENABLE | RF_RSTB | RF_SDMRSTB);\n\n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_TRX_PATH_ENABLE);\n\tval32 &= ~(OFDM_RF_PATH_RX_MASK | OFDM_RF_PATH_TX_MASK);\n\tval32 |= OFDM_RF_PATH_RX_A | OFDM_RF_PATH_TX_A;\n\trtl8xxxu_write32(priv, REG_OFDM0_TRX_PATH_ENABLE, val32);\n\n\trtl8xxxu_write8(priv, REG_TXPAUSE, 0x00);\n}\n\nstatic void rtl8710b_disable_rf(struct rtl8xxxu_priv *priv)\n{\n\tu32 val32;\n\n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_TRX_PATH_ENABLE);\n\tval32 &= ~OFDM_RF_PATH_TX_MASK;\n\trtl8xxxu_write32(priv, REG_OFDM0_TRX_PATH_ENABLE, val32);\n\n\t \n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_AC, 0);\n}\n\nstatic void rtl8710b_usb_quirks(struct rtl8xxxu_priv *priv)\n{\n\tu16 val16;\n\n\trtl8xxxu_gen2_usb_quirks(priv);\n\n\tval16 = rtl8xxxu_read16(priv, REG_CR);\n\tval16 |= (CR_MAC_TX_ENABLE | CR_MAC_RX_ENABLE);\n\trtl8xxxu_write16(priv, REG_CR, val16);\n}\n\n#define XTAL1\tGENMASK(29, 24)\n#define XTAL0\tGENMASK(23, 18)\n\nstatic void rtl8710b_set_crystal_cap(struct rtl8xxxu_priv *priv, u8 crystal_cap)\n{\n\tstruct rtl8xxxu_cfo_tracking *cfo = &priv->cfo_tracking;\n\tu32 val32;\n\n\tif (crystal_cap == cfo->crystal_cap)\n\t\treturn;\n\n\tval32 = rtl8710b_read_syson_reg(priv, REG_SYS_XTAL_CTRL0_8710B);\n\n\tdev_dbg(&priv->udev->dev,\n\t\t\"%s: Adjusting crystal cap from 0x%x (actually 0x%x 0x%x) to 0x%x\\n\",\n\t\t__func__,\n\t\tcfo->crystal_cap,\n\t\tu32_get_bits(val32, XTAL1),\n\t\tu32_get_bits(val32, XTAL0),\n\t\tcrystal_cap);\n\n\tu32p_replace_bits(&val32, crystal_cap, XTAL1);\n\tu32p_replace_bits(&val32, crystal_cap, XTAL0);\n\trtl8710b_write_syson_reg(priv, REG_SYS_XTAL_CTRL0_8710B, val32);\n\n\tcfo->crystal_cap = crystal_cap;\n}\n\nstatic s8 rtl8710b_cck_rssi(struct rtl8xxxu_priv *priv, struct rtl8723au_phy_stats *phy_stats)\n{\n\tstruct jaguar2_phy_stats_type0 *phy_stats0 = (struct jaguar2_phy_stats_type0 *)phy_stats;\n\tu8 lna_idx = (phy_stats0->lna_h << 3) | phy_stats0->lna_l;\n\tu8 vga_idx = phy_stats0->vga;\n\ts8 rx_pwr_all = 0x00;\n\n\tswitch (lna_idx) {\n\tcase 7:\n\t\trx_pwr_all = -52 - (2 * vga_idx);\n\t\tbreak;\n\tcase 6:\n\t\trx_pwr_all = -42 - (2 * vga_idx);\n\t\tbreak;\n\tcase 5:\n\t\trx_pwr_all = -36 - (2 * vga_idx);\n\t\tbreak;\n\tcase 3:\n\t\trx_pwr_all = -12 - (2 * vga_idx);\n\t\tbreak;\n\tcase 2:\n\t\trx_pwr_all = 0 - (2 * vga_idx);\n\t\tbreak;\n\tdefault:\n\t\trx_pwr_all = 0;\n\t\tbreak;\n\t}\n\n\treturn rx_pwr_all;\n}\n\nstruct rtl8xxxu_fileops rtl8710bu_fops = {\n\t.identify_chip = rtl8710bu_identify_chip,\n\t.parse_efuse = rtl8710bu_parse_efuse,\n\t.load_firmware = rtl8710bu_load_firmware,\n\t.power_on = rtl8710bu_power_on,\n\t.power_off = rtl8710bu_power_off,\n\t.read_efuse = rtl8710b_read_efuse,\n\t.reset_8051 = rtl8710b_reset_8051,\n\t.llt_init = rtl8xxxu_auto_llt_table,\n\t.init_phy_bb = rtl8710bu_init_phy_bb,\n\t.init_phy_rf = rtl8710bu_init_phy_rf,\n\t.phy_lc_calibrate = rtl8188f_phy_lc_calibrate,\n\t.phy_iq_calibrate = rtl8710bu_phy_iq_calibrate,\n\t.config_channel = rtl8710bu_config_channel,\n\t.parse_rx_desc = rtl8xxxu_parse_rxdesc24,\n\t.parse_phystats = jaguar2_rx_parse_phystats,\n\t.init_aggregation = rtl8710bu_init_aggregation,\n\t.init_statistics = rtl8710bu_init_statistics,\n\t.init_burst = rtl8xxxu_init_burst,\n\t.enable_rf = rtl8710b_enable_rf,\n\t.disable_rf = rtl8710b_disable_rf,\n\t.usb_quirks = rtl8710b_usb_quirks,\n\t.set_tx_power = rtl8188f_set_tx_power,\n\t.update_rate_mask = rtl8xxxu_gen2_update_rate_mask,\n\t.report_connect = rtl8xxxu_gen2_report_connect,\n\t.report_rssi = rtl8xxxu_gen2_report_rssi,\n\t.fill_txdesc = rtl8xxxu_fill_txdesc_v2,\n\t.set_crystal_cap = rtl8710b_set_crystal_cap,\n\t.cck_rssi = rtl8710b_cck_rssi,\n\t.writeN_block_size = 4,\n\t.rx_desc_size = sizeof(struct rtl8xxxu_rxdesc24),\n\t.tx_desc_size = sizeof(struct rtl8xxxu_txdesc40),\n\t.has_tx_report = 1,\n\t.gen2_thermal_meter = 1,\n\t.needs_full_init = 1,\n\t.init_reg_rxfltmap = 1,\n\t.init_reg_pkt_life_time = 1,\n\t.init_reg_hmtfr = 1,\n\t.ampdu_max_time = 0x5e,\n\t \n\t.ustime_tsf_edca = 0x28,\n\t.max_aggr_num = 0x0c14,\n\t.supports_ap = 1,\n\t.max_macid_num = 16,\n\t.adda_1t_init = 0x03c00016,\n\t.adda_1t_path_on = 0x03c00016,\n\t.trxff_boundary = 0x3f7f,\n\t.pbp_rx = PBP_PAGE_SIZE_256,\n\t.pbp_tx = PBP_PAGE_SIZE_256,\n\t.mactable = rtl8710b_mac_init_table,\n\t.total_page_num = TX_TOTAL_PAGE_NUM_8723B,\n\t.page_num_hi = TX_PAGE_NUM_HI_PQ_8723B,\n\t.page_num_lo = TX_PAGE_NUM_LO_PQ_8723B,\n\t.page_num_norm = TX_PAGE_NUM_NORM_PQ_8723B,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}