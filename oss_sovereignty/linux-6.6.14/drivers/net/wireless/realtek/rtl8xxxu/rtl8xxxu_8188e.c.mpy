{
  "module_name": "rtl8xxxu_8188e.c",
  "hash_id": "8d1931e3db1d407ff292caa4bf38d291db5d0d092623c08a749d672e08ff5a92",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu_8188e.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/usb.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/wireless.h>\n#include <linux/firmware.h>\n#include <linux/moduleparam.h>\n#include <net/mac80211.h>\n#include \"rtl8xxxu.h\"\n#include \"rtl8xxxu_regs.h\"\n\nstatic const struct rtl8xxxu_reg8val rtl8188e_mac_init_table[] = {\n\t{0x026, 0x41}, {0x027, 0x35}, {0x040, 0x00}, {0x421, 0x0f},\n\t{0x428, 0x0a}, {0x429, 0x10}, {0x430, 0x00}, {0x431, 0x01},\n\t{0x432, 0x02}, {0x433, 0x04}, {0x434, 0x05}, {0x435, 0x06},\n\t{0x436, 0x07}, {0x437, 0x08}, {0x438, 0x00}, {0x439, 0x00},\n\t{0x43a, 0x01}, {0x43b, 0x02}, {0x43c, 0x04}, {0x43d, 0x05},\n\t{0x43e, 0x06}, {0x43f, 0x07}, {0x440, 0x5d}, {0x441, 0x01},\n\t{0x442, 0x00}, {0x444, 0x15}, {0x445, 0xf0}, {0x446, 0x0f},\n\t{0x447, 0x00}, {0x458, 0x41}, {0x459, 0xa8}, {0x45a, 0x72},\n\t{0x45b, 0xb9}, {0x460, 0x66}, {0x461, 0x66}, {0x480, 0x08},\n\t{0x4c8, 0xff}, {0x4c9, 0x08}, {0x4cc, 0xff}, {0x4cd, 0xff},\n\t{0x4ce, 0x01}, {0x4d3, 0x01}, {0x500, 0x26}, {0x501, 0xa2},\n\t{0x502, 0x2f}, {0x503, 0x00}, {0x504, 0x28}, {0x505, 0xa3},\n\t{0x506, 0x5e}, {0x507, 0x00}, {0x508, 0x2b}, {0x509, 0xa4},\n\t{0x50a, 0x5e}, {0x50b, 0x00}, {0x50c, 0x4f}, {0x50d, 0xa4},\n\t{0x50e, 0x00}, {0x50f, 0x00}, {0x512, 0x1c}, {0x514, 0x0a},\n\t{0x516, 0x0a}, {0x525, 0x4f}, {0x550, 0x10}, {0x551, 0x10},\n\t{0x559, 0x02}, {0x55d, 0xff}, {0x605, 0x30}, {0x608, 0x0e},\n\t{0x609, 0x2a}, {0x620, 0xff}, {0x621, 0xff}, {0x622, 0xff},\n\t{0x623, 0xff}, {0x624, 0xff}, {0x625, 0xff}, {0x626, 0xff},\n\t{0x627, 0xff}, {0x63c, 0x08}, {0x63d, 0x08}, {0x63e, 0x0c},\n\t{0x63f, 0x0c}, {0x640, 0x40}, {0x652, 0x20}, {0x66e, 0x05},\n\t{0x700, 0x21}, {0x701, 0x43}, {0x702, 0x65}, {0x703, 0x87},\n\t{0x708, 0x21}, {0x709, 0x43}, {0x70a, 0x65}, {0x70b, 0x87},\n\t{0xffff, 0xff},\n};\n\nstatic const struct rtl8xxxu_reg32val rtl8188eu_phy_init_table[] = {\n\t{0x800, 0x80040000}, {0x804, 0x00000003},\n\t{0x808, 0x0000fc00}, {0x80c, 0x0000000a},\n\t{0x810, 0x10001331}, {0x814, 0x020c3d10},\n\t{0x818, 0x02200385}, {0x81c, 0x00000000},\n\t{0x820, 0x01000100}, {0x824, 0x00390204},\n\t{0x828, 0x00000000}, {0x82c, 0x00000000},\n\t{0x830, 0x00000000}, {0x834, 0x00000000},\n\t{0x838, 0x00000000}, {0x83c, 0x00000000},\n\t{0x840, 0x00010000}, {0x844, 0x00000000},\n\t{0x848, 0x00000000}, {0x84c, 0x00000000},\n\t{0x850, 0x00000000}, {0x854, 0x00000000},\n\t{0x858, 0x569a11a9}, {0x85c, 0x01000014},\n\t{0x860, 0x66f60110}, {0x864, 0x061f0649},\n\t{0x868, 0x00000000}, {0x86c, 0x27272700},\n\t{0x870, 0x07000760}, {0x874, 0x25004000},\n\t{0x878, 0x00000808}, {0x87c, 0x00000000},\n\t{0x880, 0xb0000c1c}, {0x884, 0x00000001},\n\t{0x888, 0x00000000}, {0x88c, 0xccc000c0},\n\t{0x890, 0x00000800}, {0x894, 0xfffffffe},\n\t{0x898, 0x40302010}, {0x89c, 0x00706050},\n\t{0x900, 0x00000000}, {0x904, 0x00000023},\n\t{0x908, 0x00000000}, {0x90c, 0x81121111},\n\t{0x910, 0x00000002}, {0x914, 0x00000201},\n\t{0xa00, 0x00d047c8}, {0xa04, 0x80ff800c},\n\t{0xa08, 0x8c838300}, {0xa0c, 0x2e7f120f},\n\t{0xa10, 0x9500bb7e}, {0xa14, 0x1114d028},\n\t{0xa18, 0x00881117}, {0xa1c, 0x89140f00},\n\t{0xa20, 0x1a1b0000}, {0xa24, 0x090e1317},\n\t{0xa28, 0x00000204}, {0xa2c, 0x00d30000},\n\t{0xa70, 0x101fbf00}, {0xa74, 0x00000007},\n\t{0xa78, 0x00000900}, {0xa7c, 0x225b0606},\n\t{0xa80, 0x218075b1}, {0xb2c, 0x80000000},\n\t{0xc00, 0x48071d40}, {0xc04, 0x03a05611},\n\t{0xc08, 0x000000e4}, {0xc0c, 0x6c6c6c6c},\n\t{0xc10, 0x08800000}, {0xc14, 0x40000100},\n\t{0xc18, 0x08800000}, {0xc1c, 0x40000100},\n\t{0xc20, 0x00000000}, {0xc24, 0x00000000},\n\t{0xc28, 0x00000000}, {0xc2c, 0x00000000},\n\t{0xc30, 0x69e9ac47}, {0xc34, 0x469652af},\n\t{0xc38, 0x49795994}, {0xc3c, 0x0a97971c},\n\t{0xc40, 0x1f7c403f}, {0xc44, 0x000100b7},\n\t{0xc48, 0xec020107}, {0xc4c, 0x007f037f},\n\t{0xc50, 0x69553420}, {0xc54, 0x43bc0094},\n\t{0xc58, 0x00013169}, {0xc5c, 0x00250492},\n\t{0xc60, 0x00000000}, {0xc64, 0x7112848b},\n\t{0xc68, 0x47c00bff}, {0xc6c, 0x00000036},\n\t{0xc70, 0x2c7f000d}, {0xc74, 0x020610db},\n\t{0xc78, 0x0000001f}, {0xc7c, 0x00b91612},\n\t{0xc80, 0x390000e4}, {0xc84, 0x21f60000},\n\t{0xc88, 0x40000100}, {0xc8c, 0x20200000},\n\t{0xc90, 0x00091521}, {0xc94, 0x00000000},\n\t{0xc98, 0x00121820}, {0xc9c, 0x00007f7f},\n\t{0xca0, 0x00000000}, {0xca4, 0x000300a0},\n\t{0xca8, 0x00000000}, {0xcac, 0x00000000},\n\t{0xcb0, 0x00000000}, {0xcb4, 0x00000000},\n\t{0xcb8, 0x00000000}, {0xcbc, 0x28000000},\n\t{0xcc0, 0x00000000}, {0xcc4, 0x00000000},\n\t{0xcc8, 0x00000000}, {0xccc, 0x00000000},\n\t{0xcd0, 0x00000000}, {0xcd4, 0x00000000},\n\t{0xcd8, 0x64b22427}, {0xcdc, 0x00766932},\n\t{0xce0, 0x00222222}, {0xce4, 0x00000000},\n\t{0xce8, 0x37644302}, {0xcec, 0x2f97d40c},\n\t{0xd00, 0x00000740}, {0xd04, 0x00020401},\n\t{0xd08, 0x0000907f}, {0xd0c, 0x20010201},\n\t{0xd10, 0xa0633333}, {0xd14, 0x3333bc43},\n\t{0xd18, 0x7a8f5b6f}, {0xd2c, 0xcc979975},\n\t{0xd30, 0x00000000}, {0xd34, 0x80608000},\n\t{0xd38, 0x00000000}, {0xd3c, 0x00127353},\n\t{0xd40, 0x00000000}, {0xd44, 0x00000000},\n\t{0xd48, 0x00000000}, {0xd4c, 0x00000000},\n\t{0xd50, 0x6437140a}, {0xd54, 0x00000000},\n\t{0xd58, 0x00000282}, {0xd5c, 0x30032064},\n\t{0xd60, 0x4653de68}, {0xd64, 0x04518a3c},\n\t{0xd68, 0x00002101}, {0xd6c, 0x2a201c16},\n\t{0xd70, 0x1812362e}, {0xd74, 0x322c2220},\n\t{0xd78, 0x000e3c24}, {0xe00, 0x2d2d2d2d},\n\t{0xe04, 0x2d2d2d2d}, {0xe08, 0x0390272d},\n\t{0xe10, 0x2d2d2d2d}, {0xe14, 0x2d2d2d2d},\n\t{0xe18, 0x2d2d2d2d}, {0xe1c, 0x2d2d2d2d},\n\t{0xe28, 0x00000000}, {0xe30, 0x1000dc1f},\n\t{0xe34, 0x10008c1f}, {0xe38, 0x02140102},\n\t{0xe3c, 0x681604c2}, {0xe40, 0x01007c00},\n\t{0xe44, 0x01004800}, {0xe48, 0xfb000000},\n\t{0xe4c, 0x000028d1}, {0xe50, 0x1000dc1f},\n\t{0xe54, 0x10008c1f}, {0xe58, 0x02140102},\n\t{0xe5c, 0x28160d05}, {0xe60, 0x00000048},\n\t{0xe68, 0x001b25a4}, {0xe6c, 0x00c00014},\n\t{0xe70, 0x00c00014}, {0xe74, 0x01000014},\n\t{0xe78, 0x01000014}, {0xe7c, 0x01000014},\n\t{0xe80, 0x01000014}, {0xe84, 0x00c00014},\n\t{0xe88, 0x01000014}, {0xe8c, 0x00c00014},\n\t{0xed0, 0x00c00014}, {0xed4, 0x00c00014},\n\t{0xed8, 0x00c00014}, {0xedc, 0x00000014},\n\t{0xee0, 0x00000014}, {0xee8, 0x21555448},\n\t{0xeec, 0x01c00014}, {0xf14, 0x00000003},\n\t{0xf4c, 0x00000000}, {0xf00, 0x00000300},\n\t{0xffff, 0xffffffff},\n};\n\nstatic const struct rtl8xxxu_reg32val rtl8188e_agc_table[] = {\n\t{0xc78, 0xfb000001}, {0xc78, 0xfb010001},\n\t{0xc78, 0xfb020001}, {0xc78, 0xfb030001},\n\t{0xc78, 0xfb040001}, {0xc78, 0xfb050001},\n\t{0xc78, 0xfa060001}, {0xc78, 0xf9070001},\n\t{0xc78, 0xf8080001}, {0xc78, 0xf7090001},\n\t{0xc78, 0xf60a0001}, {0xc78, 0xf50b0001},\n\t{0xc78, 0xf40c0001}, {0xc78, 0xf30d0001},\n\t{0xc78, 0xf20e0001}, {0xc78, 0xf10f0001},\n\t{0xc78, 0xf0100001}, {0xc78, 0xef110001},\n\t{0xc78, 0xee120001}, {0xc78, 0xed130001},\n\t{0xc78, 0xec140001}, {0xc78, 0xeb150001},\n\t{0xc78, 0xea160001}, {0xc78, 0xe9170001},\n\t{0xc78, 0xe8180001}, {0xc78, 0xe7190001},\n\t{0xc78, 0xe61a0001}, {0xc78, 0xe51b0001},\n\t{0xc78, 0xe41c0001}, {0xc78, 0xe31d0001},\n\t{0xc78, 0xe21e0001}, {0xc78, 0xe11f0001},\n\t{0xc78, 0x8a200001}, {0xc78, 0x89210001},\n\t{0xc78, 0x88220001}, {0xc78, 0x87230001},\n\t{0xc78, 0x86240001}, {0xc78, 0x85250001},\n\t{0xc78, 0x84260001}, {0xc78, 0x83270001},\n\t{0xc78, 0x82280001}, {0xc78, 0x6b290001},\n\t{0xc78, 0x6a2a0001}, {0xc78, 0x692b0001},\n\t{0xc78, 0x682c0001}, {0xc78, 0x672d0001},\n\t{0xc78, 0x662e0001}, {0xc78, 0x652f0001},\n\t{0xc78, 0x64300001}, {0xc78, 0x63310001},\n\t{0xc78, 0x62320001}, {0xc78, 0x61330001},\n\t{0xc78, 0x46340001}, {0xc78, 0x45350001},\n\t{0xc78, 0x44360001}, {0xc78, 0x43370001},\n\t{0xc78, 0x42380001}, {0xc78, 0x41390001},\n\t{0xc78, 0x403a0001}, {0xc78, 0x403b0001},\n\t{0xc78, 0x403c0001}, {0xc78, 0x403d0001},\n\t{0xc78, 0x403e0001}, {0xc78, 0x403f0001},\n\t{0xc78, 0xfb400001}, {0xc78, 0xfb410001},\n\t{0xc78, 0xfb420001}, {0xc78, 0xfb430001},\n\t{0xc78, 0xfb440001}, {0xc78, 0xfb450001},\n\t{0xc78, 0xfb460001}, {0xc78, 0xfb470001},\n\t{0xc78, 0xfb480001}, {0xc78, 0xfa490001},\n\t{0xc78, 0xf94a0001}, {0xc78, 0xf84b0001},\n\t{0xc78, 0xf74c0001}, {0xc78, 0xf64d0001},\n\t{0xc78, 0xf54e0001}, {0xc78, 0xf44f0001},\n\t{0xc78, 0xf3500001}, {0xc78, 0xf2510001},\n\t{0xc78, 0xf1520001}, {0xc78, 0xf0530001},\n\t{0xc78, 0xef540001}, {0xc78, 0xee550001},\n\t{0xc78, 0xed560001}, {0xc78, 0xec570001},\n\t{0xc78, 0xeb580001}, {0xc78, 0xea590001},\n\t{0xc78, 0xe95a0001}, {0xc78, 0xe85b0001},\n\t{0xc78, 0xe75c0001}, {0xc78, 0xe65d0001},\n\t{0xc78, 0xe55e0001}, {0xc78, 0xe45f0001},\n\t{0xc78, 0xe3600001}, {0xc78, 0xe2610001},\n\t{0xc78, 0xc3620001}, {0xc78, 0xc2630001},\n\t{0xc78, 0xc1640001}, {0xc78, 0x8b650001},\n\t{0xc78, 0x8a660001}, {0xc78, 0x89670001},\n\t{0xc78, 0x88680001}, {0xc78, 0x87690001},\n\t{0xc78, 0x866a0001}, {0xc78, 0x856b0001},\n\t{0xc78, 0x846c0001}, {0xc78, 0x676d0001},\n\t{0xc78, 0x666e0001}, {0xc78, 0x656f0001},\n\t{0xc78, 0x64700001}, {0xc78, 0x63710001},\n\t{0xc78, 0x62720001}, {0xc78, 0x61730001},\n\t{0xc78, 0x60740001}, {0xc78, 0x46750001},\n\t{0xc78, 0x45760001}, {0xc78, 0x44770001},\n\t{0xc78, 0x43780001}, {0xc78, 0x42790001},\n\t{0xc78, 0x417a0001}, {0xc78, 0x407b0001},\n\t{0xc78, 0x407c0001}, {0xc78, 0x407d0001},\n\t{0xc78, 0x407e0001}, {0xc78, 0x407f0001},\n\t{0xc50, 0x69553422}, {0xc50, 0x69553420},\n\t{0xffff, 0xffffffff}\n};\n\nstatic const struct rtl8xxxu_rfregval rtl8188eu_radioa_init_table[] = {\n\t{0x00, 0x00030000}, {0x08, 0x00084000},\n\t{0x18, 0x00000407}, {0x19, 0x00000012},\n\t{0x1e, 0x00080009}, {0x1f, 0x00000880},\n\t{0x2f, 0x0001a060}, {0x3f, 0x00000000},\n\t{0x42, 0x000060c0}, {0x57, 0x000d0000},\n\t{0x58, 0x000be180}, {0x67, 0x00001552},\n\t{0x83, 0x00000000}, {0xb0, 0x000ff8fc},\n\t{0xb1, 0x00054400}, {0xb2, 0x000ccc19},\n\t{0xb4, 0x00043003}, {0xb6, 0x0004953e},\n\t{0xb7, 0x0001c718}, {0xb8, 0x000060ff},\n\t{0xb9, 0x00080001}, {0xba, 0x00040000},\n\t{0xbb, 0x00000400}, {0xbf, 0x000c0000},\n\t{0xc2, 0x00002400}, {0xc3, 0x00000009},\n\t{0xc4, 0x00040c91}, {0xc5, 0x00099999},\n\t{0xc6, 0x000000a3}, {0xc7, 0x00088820},\n\t{0xc8, 0x00076c06}, {0xc9, 0x00000000},\n\t{0xca, 0x00080000}, {0xdf, 0x00000180},\n\t{0xef, 0x000001a0}, {0x51, 0x0006b27d},\n\t{0x52, 0x0007e49d},\t \n\t{0x53, 0x00000073}, {0x56, 0x00051ff3},\n\t{0x35, 0x00000086}, {0x35, 0x00000186},\n\t{0x35, 0x00000286}, {0x36, 0x00001c25},\n\t{0x36, 0x00009c25}, {0x36, 0x00011c25},\n\t{0x36, 0x00019c25}, {0xb6, 0x00048538},\n\t{0x18, 0x00000c07}, {0x5a, 0x0004bd00},\n\t{0x19, 0x000739d0}, {0x34, 0x0000adf3},\n\t{0x34, 0x00009df0}, {0x34, 0x00008ded},\n\t{0x34, 0x00007dea}, {0x34, 0x00006de7},\n\t{0x34, 0x000054ee}, {0x34, 0x000044eb},\n\t{0x34, 0x000034e8}, {0x34, 0x0000246b},\n\t{0x34, 0x00001468}, {0x34, 0x0000006d},\n\t{0x00, 0x00030159}, {0x84, 0x00068200},\n\t{0x86, 0x000000ce}, {0x87, 0x00048a00},\n\t{0x8e, 0x00065540}, {0x8f, 0x00088000},\n\t{0xef, 0x000020a0}, {0x3b, 0x000f02b0},\n\t{0x3b, 0x000ef7b0}, {0x3b, 0x000d4fb0},\n\t{0x3b, 0x000cf060}, {0x3b, 0x000b0090},\n\t{0x3b, 0x000a0080}, {0x3b, 0x00090080},\n\t{0x3b, 0x0008f780}, {0x3b, 0x000722b0},\n\t{0x3b, 0x0006f7b0}, {0x3b, 0x00054fb0},\n\t{0x3b, 0x0004f060}, {0x3b, 0x00030090},\n\t{0x3b, 0x00020080}, {0x3b, 0x00010080},\n\t{0x3b, 0x0000f780}, {0xef, 0x000000a0},\n\t{0x00, 0x00010159}, {0x18, 0x0000f407},\n\t{0xFE, 0x00000000}, {0xFE, 0x00000000},\n\t{0x1F, 0x00080003}, {0xFE, 0x00000000},\n\t{0xFE, 0x00000000}, {0x1E, 0x00000001},\n\t{0x1F, 0x00080000}, {0x00, 0x00033e60},\n\t{0xff, 0xffffffff}\n};\n\n#define PERENTRY\t\t23\n#define RETRYSIZE\t\t5\n#define RATESIZE\t\t28\n#define TX_RPT2_ITEM_SIZE\t8\n\nstatic const u8 retry_penalty[PERENTRY][RETRYSIZE + 1] = {\n\t{5, 4, 3, 2, 0, 3},  \n\t{6, 5, 4, 3, 0, 4},  \n\t{6, 5, 4, 2, 0, 4},  \n\t{8, 7, 6, 4, 0, 6},  \n\t{10, 9, 8, 6, 0, 8},  \n\t{10, 9, 8, 4, 0, 8},  \n\t{10, 9, 8, 2, 0, 8},  \n\t{10, 9, 8, 0, 0, 8},  \n\t{18, 17, 16, 8, 0, 16},  \n\t{26, 25, 24, 16, 0, 24},  \n\t{34, 33, 32, 24, 0, 32},  \n\t{34, 31, 28, 20, 0, 32},  \n\t{34, 31, 27, 18, 0, 32},  \n\t{34, 31, 26, 16, 0, 32},  \n\t{34, 30, 22, 16, 0, 32},  \n\t{34, 30, 24, 16, 0, 32},  \n\t{49, 46, 40, 16, 0, 48},  \n\t{49, 45, 32, 0, 0, 48},  \n\t{49, 45, 22, 18, 0, 48},  \n\t{49, 40, 24, 16, 0, 48},  \n\t{49, 32, 18, 12, 0, 48},  \n\t{49, 22, 18, 14, 0, 48},  \n\t{49, 16, 16, 0, 0, 48}  \n};\n\nstatic const u8 pt_penalty[RETRYSIZE + 1] = {34, 31, 30, 24, 0, 32};\n\nstatic const u8 retry_penalty_idx_normal[2][RATESIZE] = {\n\t{  \n\t\t4, 4, 4, 5,\n\t\t4, 4, 5, 7, 7, 7, 8, 0x0a,\n\t\t4, 4, 4, 4, 6, 0x0a, 0x0b, 0x0d,\n\t\t5, 5, 7, 7, 8, 0x0b, 0x0d, 0x0f\n\t},\n\t{  \n\t\t0x0a, 0x0a, 0x0b, 0x0c,\n\t\t0x0a, 0x0a, 0x0b, 0x0c, 0x0d, 0x10, 0x13, 0x13,\n\t\t0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x11, 0x13, 0x13,\n\t\t9, 9, 9, 9, 0x0c, 0x0e, 0x11, 0x13\n\t}\n};\n\nstatic const u8 retry_penalty_idx_cut_i[2][RATESIZE] = {\n\t{  \n\t\t4, 4, 4, 5,\n\t\t4, 4, 5, 7, 7, 7, 8, 0x0a,\n\t\t4, 4, 4, 4, 6, 0x0a, 0x0b, 0x0d,\n\t\t5, 5, 7, 7, 8, 0x0b, 0x0d, 0x0f\n\t},\n\t{  \n\t\t0x0a, 0x0a, 0x0b, 0x0c,\n\t\t0x0a, 0x0a, 0x0b, 0x0c, 0x0d, 0x10, 0x13, 0x13,\n\t\t0x06, 0x07, 0x08, 0x0d, 0x0e, 0x11, 0x11, 0x11,\n\t\t9, 9, 9, 9, 0x0c, 0x0e, 0x11, 0x13\n\t}\n};\n\nstatic const u8 retry_penalty_up_idx_normal[RATESIZE] = {\n\t0x0c, 0x0d, 0x0d, 0x0f,\n\t0x0d, 0x0e, 0x0f, 0x0f, 0x10, 0x12, 0x13, 0x14,\n\t0x0f, 0x10, 0x10, 0x12, 0x12, 0x13, 0x14, 0x15,\n\t0x11, 0x11, 0x12, 0x13, 0x13, 0x13, 0x14, 0x15\n};\n\nstatic const u8 retry_penalty_up_idx_cut_i[RATESIZE] = {\n\t0x0c, 0x0d, 0x0d, 0x0f,\n\t0x0d, 0x0e, 0x0f, 0x0f, 0x10, 0x12, 0x13, 0x14,\n\t0x0b, 0x0b, 0x11, 0x11, 0x12, 0x12, 0x12, 0x12,\n\t0x11, 0x11, 0x12, 0x13, 0x13, 0x13, 0x14, 0x15\n};\n\nstatic const u8 rssi_threshold[RATESIZE] = {\n\t0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0x24, 0x26, 0x2a,\n\t0x18, 0x1a, 0x1d, 0x1f, 0x21, 0x27, 0x29, 0x2a,\n\t0, 0, 0, 0x1f, 0x23, 0x28, 0x2a, 0x2c\n};\n\nstatic const u16 n_threshold_high[RATESIZE] = {\n\t4, 4, 8, 16,\n\t24, 36, 48, 72, 96, 144, 192, 216,\n\t60, 80, 100, 160, 240, 400, 600, 800,\n\t300, 320, 480, 720, 1000, 1200, 1600, 2000\n};\n\nstatic const u16 n_threshold_low[RATESIZE] = {\n\t2, 2, 4, 8,\n\t12, 18, 24, 36, 48, 72, 96, 108,\n\t30, 40, 50, 80, 120, 200, 300, 400,\n\t150, 160, 240, 360, 500, 600, 800, 1000\n};\n\nstatic const u8 dropping_necessary[RATESIZE] = {\n\t1, 1, 1, 1,\n\t1, 2, 3, 4, 5, 6, 7, 8,\n\t1, 2, 3, 4, 5, 6, 7, 8,\n\t5, 6, 7, 8, 9, 10, 11, 12\n};\n\nstatic const u8 pending_for_rate_up_fail[5] = {2, 10, 24, 40, 60};\n\nstatic const u16 dynamic_tx_rpt_timing[6] = {\n\t0x186a, 0x30d4, 0x493e, 0x61a8, 0x7a12, 0x927c  \n};\n\nenum rtl8188e_tx_rpt_timing {\n\tDEFAULT_TIMING = 0,\n\tINCREASE_TIMING,\n\tDECREASE_TIMING\n};\n\nstatic int rtl8188eu_identify_chip(struct rtl8xxxu_priv *priv)\n{\n\tstruct device *dev = &priv->udev->dev;\n\tu32 sys_cfg, vendor;\n\tint ret = 0;\n\n\tstrscpy(priv->chip_name, \"8188EU\", sizeof(priv->chip_name));\n\tpriv->rtl_chip = RTL8188E;\n\tpriv->rf_paths = 1;\n\tpriv->rx_paths = 1;\n\tpriv->tx_paths = 1;\n\tpriv->has_wifi = 1;\n\n\tsys_cfg = rtl8xxxu_read32(priv, REG_SYS_CFG);\n\tpriv->chip_cut = u32_get_bits(sys_cfg, SYS_CFG_CHIP_VERSION_MASK);\n\tif (sys_cfg & SYS_CFG_TRP_VAUX_EN) {\n\t\tdev_info(dev, \"Unsupported test chip\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tif (priv->chip_cut == 8) {\n\t\tdev_info(dev, \"RTL8188EU cut I is not supported. Please complain about it at linux-wireless@vger.kernel.org.\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tvendor = sys_cfg & SYS_CFG_VENDOR_ID;\n\trtl8xxxu_identify_vendor_1bit(priv, vendor);\n\n\tret = rtl8xxxu_config_endpoints_no_sie(priv);\n\n\treturn ret;\n}\n\nstatic void rtl8188eu_config_channel(struct ieee80211_hw *hw)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tu32 val32, rsr;\n\tu8 opmode;\n\tint sec_ch_above, channel;\n\tint i;\n\n\topmode = rtl8xxxu_read8(priv, REG_BW_OPMODE);\n\trsr = rtl8xxxu_read32(priv, REG_RESPONSE_RATE_SET);\n\tchannel = hw->conf.chandef.chan->hw_value;\n\n\tswitch (hw->conf.chandef.width) {\n\tcase NL80211_CHAN_WIDTH_20_NOHT:\n\tcase NL80211_CHAN_WIDTH_20:\n\t\topmode |= BW_OPMODE_20MHZ;\n\t\trtl8xxxu_write8(priv, REG_BW_OPMODE, opmode);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_RF_MODE);\n\t\tval32 &= ~FPGA_RF_MODE;\n\t\trtl8xxxu_write32(priv, REG_FPGA0_RF_MODE, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA1_RF_MODE);\n\t\tval32 &= ~FPGA_RF_MODE;\n\t\trtl8xxxu_write32(priv, REG_FPGA1_RF_MODE, val32);\n\t\tbreak;\n\tcase NL80211_CHAN_WIDTH_40:\n\t\tif (hw->conf.chandef.center_freq1 >\n\t\t    hw->conf.chandef.chan->center_freq) {\n\t\t\tsec_ch_above = 1;\n\t\t\tchannel += 2;\n\t\t} else {\n\t\t\tsec_ch_above = 0;\n\t\t\tchannel -= 2;\n\t\t}\n\n\t\topmode &= ~BW_OPMODE_20MHZ;\n\t\trtl8xxxu_write8(priv, REG_BW_OPMODE, opmode);\n\t\trsr &= ~RSR_RSC_BANDWIDTH_40M;\n\t\tif (sec_ch_above)\n\t\t\trsr |= RSR_RSC_LOWER_SUB_CHANNEL;\n\t\telse\n\t\t\trsr |= RSR_RSC_UPPER_SUB_CHANNEL;\n\t\trtl8xxxu_write32(priv, REG_RESPONSE_RATE_SET, rsr);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_RF_MODE);\n\t\tval32 |= FPGA_RF_MODE;\n\t\trtl8xxxu_write32(priv, REG_FPGA0_RF_MODE, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA1_RF_MODE);\n\t\tval32 |= FPGA_RF_MODE;\n\t\trtl8xxxu_write32(priv, REG_FPGA1_RF_MODE, val32);\n\n\t\t \n\t\tval32 = rtl8xxxu_read32(priv, REG_CCK0_SYSTEM);\n\t\tval32 &= ~CCK0_SIDEBAND;\n\t\tif (!sec_ch_above)\n\t\t\tval32 |= CCK0_SIDEBAND;\n\t\trtl8xxxu_write32(priv, REG_CCK0_SYSTEM, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_OFDM1_LSTF);\n\t\tval32 &= ~OFDM_LSTF_PRIME_CH_MASK;  \n\t\tif (sec_ch_above)\n\t\t\tval32 |= OFDM_LSTF_PRIME_CH_LOW;\n\t\telse\n\t\t\tval32 |= OFDM_LSTF_PRIME_CH_HIGH;\n\t\trtl8xxxu_write32(priv, REG_OFDM1_LSTF, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_POWER_SAVE);\n\t\tval32 &= ~(FPGA0_PS_LOWER_CHANNEL | FPGA0_PS_UPPER_CHANNEL);\n\t\tif (sec_ch_above)\n\t\t\tval32 |= FPGA0_PS_UPPER_CHANNEL;\n\t\telse\n\t\t\tval32 |= FPGA0_PS_LOWER_CHANNEL;\n\t\trtl8xxxu_write32(priv, REG_FPGA0_POWER_SAVE, val32);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tfor (i = RF_A; i < priv->rf_paths; i++) {\n\t\tval32 = rtl8xxxu_read_rfreg(priv, i, RF6052_REG_MODE_AG);\n\t\tu32p_replace_bits(&val32, channel, MODE_AG_CHANNEL_MASK);\n\t\trtl8xxxu_write_rfreg(priv, i, RF6052_REG_MODE_AG, val32);\n\t}\n\n\tfor (i = RF_A; i < priv->rf_paths; i++) {\n\t\tval32 = rtl8xxxu_read_rfreg(priv, i, RF6052_REG_MODE_AG);\n\t\tval32 &= ~MODE_AG_BW_MASK;\n\t\tif (hw->conf.chandef.width == NL80211_CHAN_WIDTH_40)\n\t\t\tval32 |= MODE_AG_BW_40MHZ_8723B;\n\t\telse\n\t\t\tval32 |= MODE_AG_BW_20MHZ_8723B;\n\t\trtl8xxxu_write_rfreg(priv, i, RF6052_REG_MODE_AG, val32);\n\t}\n}\n\nstatic void rtl8188eu_init_aggregation(struct rtl8xxxu_priv *priv)\n{\n\tu8 agg_ctrl, usb_spec;\n\n\tusb_spec = rtl8xxxu_read8(priv, REG_USB_SPECIAL_OPTION);\n\tusb_spec &= ~USB_SPEC_USB_AGG_ENABLE;\n\trtl8xxxu_write8(priv, REG_USB_SPECIAL_OPTION, usb_spec);\n\n\tagg_ctrl = rtl8xxxu_read8(priv, REG_TRXDMA_CTRL);\n\tagg_ctrl &= ~TRXDMA_CTRL_RXDMA_AGG_EN;\n\trtl8xxxu_write8(priv, REG_TRXDMA_CTRL, agg_ctrl);\n}\n\nstatic int rtl8188eu_parse_efuse(struct rtl8xxxu_priv *priv)\n{\n\tstruct rtl8188eu_efuse *efuse = &priv->efuse_wifi.efuse8188eu;\n\n\tif (efuse->rtl_id != cpu_to_le16(0x8129))\n\t\treturn -EINVAL;\n\n\tether_addr_copy(priv->mac_addr, efuse->mac_addr);\n\n\tmemcpy(priv->cck_tx_power_index_A, efuse->tx_power_index_A.cck_base,\n\t       sizeof(efuse->tx_power_index_A.cck_base));\n\n\tmemcpy(priv->ht40_1s_tx_power_index_A,\n\t       efuse->tx_power_index_A.ht40_base,\n\t       sizeof(efuse->tx_power_index_A.ht40_base));\n\n\tpriv->default_crystal_cap = efuse->xtal_k & 0x3f;\n\n\treturn 0;\n}\n\nstatic void rtl8188eu_reset_8051(struct rtl8xxxu_priv *priv)\n{\n\tu16 sys_func;\n\n\tsys_func = rtl8xxxu_read16(priv, REG_SYS_FUNC);\n\tsys_func &= ~SYS_FUNC_CPU_ENABLE;\n\trtl8xxxu_write16(priv, REG_SYS_FUNC, sys_func);\n\n\tsys_func |= SYS_FUNC_CPU_ENABLE;\n\trtl8xxxu_write16(priv, REG_SYS_FUNC, sys_func);\n}\n\nstatic int rtl8188eu_load_firmware(struct rtl8xxxu_priv *priv)\n{\n\tconst char *fw_name;\n\tint ret;\n\n\tfw_name = \"rtlwifi/rtl8188eufw.bin\";\n\n\tret = rtl8xxxu_load_firmware(priv, fw_name);\n\n\treturn ret;\n}\n\nstatic void rtl8188eu_init_phy_bb(struct rtl8xxxu_priv *priv)\n{\n\tu8 val8;\n\tu16 val16;\n\n\tval16 = rtl8xxxu_read16(priv, REG_SYS_FUNC);\n\tval16 |= SYS_FUNC_BB_GLB_RSTN | SYS_FUNC_BBRSTB | SYS_FUNC_DIO_RF;\n\trtl8xxxu_write16(priv, REG_SYS_FUNC, val16);\n\n\t \n\tval8 = RF_ENABLE | RF_RSTB | RF_SDMRSTB;\n\trtl8xxxu_write8(priv, REG_RF_CTRL, val8);\n\n\tval8 = SYS_FUNC_USBA | SYS_FUNC_USBD |\n\t       SYS_FUNC_BB_GLB_RSTN | SYS_FUNC_BBRSTB;\n\trtl8xxxu_write8(priv, REG_SYS_FUNC, val8);\n\n\trtl8xxxu_init_phy_regs(priv, rtl8188eu_phy_init_table);\n\trtl8xxxu_init_phy_regs(priv, rtl8188e_agc_table);\n}\n\nstatic int rtl8188eu_init_phy_rf(struct rtl8xxxu_priv *priv)\n{\n\treturn rtl8xxxu_init_phy_rf(priv, rtl8188eu_radioa_init_table, RF_A);\n}\n\nstatic int rtl8188eu_iqk_path_a(struct rtl8xxxu_priv *priv)\n{\n\tu32 reg_eac, reg_e94, reg_e9c;\n\tint result = 0;\n\n\t \n\trtl8xxxu_write32(priv, REG_TX_IQK_TONE_A, 0x10008c1c);\n\trtl8xxxu_write32(priv, REG_RX_IQK_TONE_A, 0x30008c1c);\n\n\trtl8xxxu_write32(priv, REG_TX_IQK_PI_A, 0x8214032a);\n\trtl8xxxu_write32(priv, REG_RX_IQK_PI_A, 0x28160000);\n\n\t \n\trtl8xxxu_write32(priv, REG_IQK_AGC_RSP, 0x00462911);\n\n\t \n\trtl8xxxu_write32(priv, REG_IQK_AGC_PTS, 0xf9000000);\n\trtl8xxxu_write32(priv, REG_IQK_AGC_PTS, 0xf8000000);\n\n\tmdelay(10);\n\n\t \n\treg_eac = rtl8xxxu_read32(priv, REG_RX_POWER_AFTER_IQK_A_2);\n\treg_e94 = rtl8xxxu_read32(priv, REG_TX_POWER_BEFORE_IQK_A);\n\treg_e9c = rtl8xxxu_read32(priv, REG_TX_POWER_AFTER_IQK_A);\n\n\tif (!(reg_eac & BIT(28)) &&\n\t    ((reg_e94 & 0x03ff0000) != 0x01420000) &&\n\t    ((reg_e9c & 0x03ff0000) != 0x00420000))\n\t\tresult |= 0x01;\n\n\treturn result;\n}\n\nstatic int rtl8188eu_rx_iqk_path_a(struct rtl8xxxu_priv *priv)\n{\n\tu32 reg_ea4, reg_eac, reg_e94, reg_e9c, val32;\n\tint result = 0;\n\n\t \n\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_IQK);\n\tu32p_replace_bits(&val32, 0, 0xffffff00);\n\trtl8xxxu_write32(priv, REG_FPGA0_IQK, val32);\n\n\t \n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_WE_LUT, 0x800a0);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_RCK_OS, 0x30000);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_TXPA_G1, 0x0000f);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_TXPA_G2, 0xf117b);\n\n\t \n\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_IQK);\n\tu32p_replace_bits(&val32, 0x808000, 0xffffff00);\n\trtl8xxxu_write32(priv, REG_FPGA0_IQK, val32);\n\n\t \n\trtl8xxxu_write32(priv, REG_TX_IQK, 0x01007c00);\n\trtl8xxxu_write32(priv, REG_RX_IQK, 0x81004800);\n\n\t \n\trtl8xxxu_write32(priv, REG_TX_IQK_TONE_A, 0x10008c1c);\n\trtl8xxxu_write32(priv, REG_RX_IQK_TONE_A, 0x30008c1c);\n\n\trtl8xxxu_write32(priv, REG_TX_IQK_PI_A, 0x82160804);\n\trtl8xxxu_write32(priv, REG_RX_IQK_PI_A, 0x28160000);\n\n\t \n\trtl8xxxu_write32(priv, REG_IQK_AGC_RSP, 0x0046a911);\n\n\t \n\trtl8xxxu_write32(priv, REG_IQK_AGC_PTS, 0xf9000000);\n\trtl8xxxu_write32(priv, REG_IQK_AGC_PTS, 0xf8000000);\n\n\tmdelay(10);\n\n\t \n\treg_eac = rtl8xxxu_read32(priv, REG_RX_POWER_AFTER_IQK_A_2);\n\treg_e94 = rtl8xxxu_read32(priv, REG_TX_POWER_BEFORE_IQK_A);\n\treg_e9c = rtl8xxxu_read32(priv, REG_TX_POWER_AFTER_IQK_A);\n\n\tif (!(reg_eac & BIT(28)) &&\n\t    ((reg_e94 & 0x03ff0000) != 0x01420000) &&\n\t    ((reg_e9c & 0x03ff0000) != 0x00420000))\n\t\tresult |= 0x01;\n\telse\n\t\tgoto out;\n\n\tval32 = 0x80007c00 |\n\t\t(reg_e94 & 0x03ff0000) | ((reg_e9c >> 16) & 0x03ff);\n\trtl8xxxu_write32(priv, REG_TX_IQK, val32);\n\n\t \n\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_IQK);\n\tu32p_replace_bits(&val32, 0, 0xffffff00);\n\trtl8xxxu_write32(priv, REG_FPGA0_IQK, val32);\n\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_WE_LUT, 0x800a0);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_RCK_OS, 0x30000);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_TXPA_G1, 0x0000f);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_TXPA_G2, 0xf7ffa);\n\n\t \n\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_IQK);\n\tu32p_replace_bits(&val32, 0x808000, 0xffffff00);\n\trtl8xxxu_write32(priv, REG_FPGA0_IQK, val32);\n\n\t \n\trtl8xxxu_write32(priv, REG_RX_IQK, 0x01004800);\n\n\t \n\trtl8xxxu_write32(priv, REG_TX_IQK_TONE_A, 0x30008c1c);\n\trtl8xxxu_write32(priv, REG_RX_IQK_TONE_A, 0x10008c1c);\n\n\trtl8xxxu_write32(priv, REG_TX_IQK_PI_A, 0x82160c05);\n\trtl8xxxu_write32(priv, REG_RX_IQK_PI_A, 0x28160c05);\n\n\t \n\trtl8xxxu_write32(priv, REG_IQK_AGC_RSP, 0x0046a911);\n\n\t \n\trtl8xxxu_write32(priv, REG_IQK_AGC_PTS, 0xf9000000);\n\trtl8xxxu_write32(priv, REG_IQK_AGC_PTS, 0xf8000000);\n\n\tmdelay(10);\n\n\treg_eac = rtl8xxxu_read32(priv, REG_RX_POWER_AFTER_IQK_A_2);\n\treg_ea4 = rtl8xxxu_read32(priv, REG_RX_POWER_BEFORE_IQK_A_2);\n\n\tif (!(reg_eac & BIT(27)) &&\n\t    ((reg_ea4 & 0x03ff0000) != 0x01320000) &&\n\t    ((reg_eac & 0x03ff0000) != 0x00360000))\n\t\tresult |= 0x02;\n\telse\n\t\tdev_warn(&priv->udev->dev, \"%s: Path A RX IQK failed!\\n\",\n\t\t\t __func__);\n\nout:\n\treturn result;\n}\n\nstatic void rtl8188eu_phy_iqcalibrate(struct rtl8xxxu_priv *priv,\n\t\t\t\t      int result[][8], int t)\n{\n\tstruct device *dev = &priv->udev->dev;\n\tu32 i, val32;\n\tint path_a_ok;\n\tint retry = 2;\n\tstatic const u32 adda_regs[RTL8XXXU_ADDA_REGS] = {\n\t\tREG_FPGA0_XCD_SWITCH_CTRL, REG_BLUETOOTH,\n\t\tREG_RX_WAIT_CCA, REG_TX_CCK_RFON,\n\t\tREG_TX_CCK_BBON, REG_TX_OFDM_RFON,\n\t\tREG_TX_OFDM_BBON, REG_TX_TO_RX,\n\t\tREG_TX_TO_TX, REG_RX_CCK,\n\t\tREG_RX_OFDM, REG_RX_WAIT_RIFS,\n\t\tREG_RX_TO_RX, REG_STANDBY,\n\t\tREG_SLEEP, REG_PMPD_ANAEN\n\t};\n\tstatic const u32 iqk_mac_regs[RTL8XXXU_MAC_REGS] = {\n\t\tREG_TXPAUSE, REG_BEACON_CTRL,\n\t\tREG_BEACON_CTRL_1, REG_GPIO_MUXCFG\n\t};\n\tstatic const u32 iqk_bb_regs[RTL8XXXU_BB_REGS] = {\n\t\tREG_OFDM0_TRX_PATH_ENABLE, REG_OFDM0_TR_MUX_PAR,\n\t\tREG_FPGA0_XCD_RF_SW_CTRL, REG_CONFIG_ANT_A, REG_CONFIG_ANT_B,\n\t\tREG_FPGA0_XAB_RF_SW_CTRL, REG_FPGA0_XA_RF_INT_OE,\n\t\tREG_FPGA0_XB_RF_INT_OE, REG_CCK0_AFE_SETTING\n\t};\n\n\t \n\n\tif (t == 0) {\n\t\t \n\t\trtl8xxxu_save_regs(priv, adda_regs, priv->adda_backup,\n\t\t\t\t   RTL8XXXU_ADDA_REGS);\n\t\trtl8xxxu_save_mac_regs(priv, iqk_mac_regs, priv->mac_backup);\n\t\trtl8xxxu_save_regs(priv, iqk_bb_regs,\n\t\t\t\t   priv->bb_backup, RTL8XXXU_BB_REGS);\n\t}\n\n\trtl8xxxu_path_adda_on(priv, adda_regs, true);\n\n\tif (t == 0) {\n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_XA_HSSI_PARM1);\n\t\tpriv->pi_enabled = u32_get_bits(val32, FPGA0_HSSI_PARM1_PI);\n\t}\n\n\tif (!priv->pi_enabled) {\n\t\t \n\t\trtl8xxxu_write32(priv, REG_FPGA0_XA_HSSI_PARM1, 0x01000100);\n\t\trtl8xxxu_write32(priv, REG_FPGA0_XB_HSSI_PARM1, 0x01000100);\n\t}\n\n\t \n\trtl8xxxu_mac_calibration(priv, iqk_mac_regs, priv->mac_backup);\n\n\tval32 = rtl8xxxu_read32(priv, REG_CCK0_AFE_SETTING);\n\tu32p_replace_bits(&val32, 0xf, 0x0f000000);\n\trtl8xxxu_write32(priv, REG_CCK0_AFE_SETTING, val32);\n\n\trtl8xxxu_write32(priv, REG_OFDM0_TRX_PATH_ENABLE, 0x03a05600);\n\trtl8xxxu_write32(priv, REG_OFDM0_TR_MUX_PAR, 0x000800e4);\n\trtl8xxxu_write32(priv, REG_FPGA0_XCD_RF_SW_CTRL, 0x22204000);\n\n\tif (!priv->no_pape) {\n\t\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_XAB_RF_SW_CTRL);\n\t\tval32 |= (FPGA0_RF_PAPE |\n\t\t\t  (FPGA0_RF_PAPE << FPGA0_RF_BD_CTRL_SHIFT));\n\t\trtl8xxxu_write32(priv, REG_FPGA0_XAB_RF_SW_CTRL, val32);\n\t}\n\n\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_XA_RF_INT_OE);\n\tval32 &= ~BIT(10);\n\trtl8xxxu_write32(priv, REG_FPGA0_XA_RF_INT_OE, val32);\n\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_XB_RF_INT_OE);\n\tval32 &= ~BIT(10);\n\trtl8xxxu_write32(priv, REG_FPGA0_XB_RF_INT_OE, val32);\n\n\t \n\trtl8xxxu_write32(priv, REG_CONFIG_ANT_A, 0x0f600000);\n\n\t \n\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_IQK);\n\tu32p_replace_bits(&val32, 0x808000, 0xffffff00);\n\trtl8xxxu_write32(priv, REG_FPGA0_IQK, val32);\n\trtl8xxxu_write32(priv, REG_TX_IQK, 0x01007c00);\n\trtl8xxxu_write32(priv, REG_RX_IQK, 0x81004800);\n\n\tfor (i = 0; i < retry; i++) {\n\t\tpath_a_ok = rtl8188eu_iqk_path_a(priv);\n\t\tif (path_a_ok == 0x01) {\n\t\t\tval32 = rtl8xxxu_read32(priv,\n\t\t\t\t\t\tREG_TX_POWER_BEFORE_IQK_A);\n\t\t\tresult[t][0] = (val32 >> 16) & 0x3ff;\n\t\t\tval32 = rtl8xxxu_read32(priv,\n\t\t\t\t\t\tREG_TX_POWER_AFTER_IQK_A);\n\t\t\tresult[t][1] = (val32 >> 16) & 0x3ff;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!path_a_ok)\n\t\tdev_dbg(dev, \"%s: Path A TX IQK failed!\\n\", __func__);\n\n\tfor (i = 0; i < retry; i++) {\n\t\tpath_a_ok = rtl8188eu_rx_iqk_path_a(priv);\n\t\tif (path_a_ok == 0x03) {\n\t\t\tval32 = rtl8xxxu_read32(priv,\n\t\t\t\t\t\tREG_RX_POWER_BEFORE_IQK_A_2);\n\t\t\tresult[t][2] = (val32 >> 16) & 0x3ff;\n\t\t\tval32 = rtl8xxxu_read32(priv,\n\t\t\t\t\t\tREG_RX_POWER_AFTER_IQK_A_2);\n\t\t\tresult[t][3] = (val32 >> 16) & 0x3ff;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!path_a_ok)\n\t\tdev_dbg(dev, \"%s: Path A RX IQK failed!\\n\", __func__);\n\n\t \n\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_IQK);\n\tu32p_replace_bits(&val32, 0, 0xffffff00);\n\trtl8xxxu_write32(priv, REG_FPGA0_IQK, val32);\n\n\tif (t == 0)\n\t\treturn;\n\n\tif (!priv->pi_enabled) {\n\t\t \n\t\trtl8xxxu_write32(priv, REG_FPGA0_XA_HSSI_PARM1, 0x01000000);\n\t\trtl8xxxu_write32(priv, REG_FPGA0_XB_HSSI_PARM1, 0x01000000);\n\t}\n\n\t \n\trtl8xxxu_restore_regs(priv, adda_regs, priv->adda_backup,\n\t\t\t      RTL8XXXU_ADDA_REGS);\n\n\t \n\trtl8xxxu_restore_mac_regs(priv, iqk_mac_regs, priv->mac_backup);\n\n\t \n\trtl8xxxu_restore_regs(priv, iqk_bb_regs,\n\t\t\t      priv->bb_backup, RTL8XXXU_BB_REGS);\n\n\t \n\trtl8xxxu_write32(priv, REG_FPGA0_XA_LSSI_PARM, 0x00032ed3);\n\n\t \n\trtl8xxxu_write32(priv, REG_TX_IQK_TONE_A, 0x01008c00);\n\trtl8xxxu_write32(priv, REG_RX_IQK_TONE_A, 0x01008c00);\n}\n\nstatic void rtl8188eu_phy_iq_calibrate(struct rtl8xxxu_priv *priv)\n{\n\tstruct device *dev = &priv->udev->dev;\n\tint result[4][8];\t \n\tint i, candidate;\n\tbool path_a_ok;\n\tu32 reg_e94, reg_e9c, reg_ea4, reg_eac;\n\tu32 reg_eb4, reg_ebc, reg_ec4, reg_ecc;\n\tbool simu;\n\n\tmemset(result, 0, sizeof(result));\n\tresult[3][0] = 0x100;\n\tresult[3][2] = 0x100;\n\tresult[3][4] = 0x100;\n\tresult[3][6] = 0x100;\n\n\tcandidate = -1;\n\n\tpath_a_ok = false;\n\n\tfor (i = 0; i < 3; i++) {\n\t\trtl8188eu_phy_iqcalibrate(priv, result, i);\n\n\t\tif (i == 1) {\n\t\t\tsimu = rtl8xxxu_simularity_compare(priv,\n\t\t\t\t\t\t\t   result, 0, 1);\n\t\t\tif (simu) {\n\t\t\t\tcandidate = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (i == 2) {\n\t\t\tsimu = rtl8xxxu_simularity_compare(priv,\n\t\t\t\t\t\t\t   result, 0, 2);\n\t\t\tif (simu) {\n\t\t\t\tcandidate = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tsimu = rtl8xxxu_simularity_compare(priv,\n\t\t\t\t\t\t\t   result, 1, 2);\n\t\t\tif (simu)\n\t\t\t\tcandidate = 1;\n\t\t\telse\n\t\t\t\tcandidate = 3;\n\t\t}\n\t}\n\n\tif (candidate >= 0) {\n\t\treg_e94 = result[candidate][0];\n\t\tpriv->rege94 =  reg_e94;\n\t\treg_e9c = result[candidate][1];\n\t\tpriv->rege9c = reg_e9c;\n\t\treg_ea4 = result[candidate][2];\n\t\treg_eac = result[candidate][3];\n\t\treg_eb4 = result[candidate][4];\n\t\tpriv->regeb4 = reg_eb4;\n\t\treg_ebc = result[candidate][5];\n\t\tpriv->regebc = reg_ebc;\n\t\treg_ec4 = result[candidate][6];\n\t\treg_ecc = result[candidate][7];\n\t\tdev_dbg(dev, \"%s: candidate is %x\\n\", __func__, candidate);\n\t\tdev_dbg(dev,\n\t\t\t\"%s: e94=%x e9c=%x ea4=%x eac=%x eb4=%x ebc=%x ec4=%x ecc=%x\\n\",\n\t\t\t__func__, reg_e94, reg_e9c, reg_ea4, reg_eac,\n\t\t\treg_eb4, reg_ebc, reg_ec4, reg_ecc);\n\t\tpath_a_ok = true;\n\t} else {\n\t\treg_e94 = 0x100;\n\t\treg_eb4 = 0x100;\n\t\tpriv->rege94 = 0x100;\n\t\tpriv->regeb4 = 0x100;\n\t\treg_e9c = 0x0;\n\t\treg_ebc = 0x0;\n\t\tpriv->rege9c = 0x0;\n\t\tpriv->regebc = 0x0;\n\t}\n\n\tif (reg_e94 && candidate >= 0)\n\t\trtl8xxxu_fill_iqk_matrix_a(priv, path_a_ok, result,\n\t\t\t\t\t   candidate, (reg_ea4 == 0));\n\n\trtl8xxxu_save_regs(priv, rtl8xxxu_iqk_phy_iq_bb_reg,\n\t\t\t   priv->bb_recovery_backup, RTL8XXXU_BB_REGS);\n}\n\nstatic void rtl8188e_disabled_to_emu(struct rtl8xxxu_priv *priv)\n{\n\tu16 val16;\n\n\tval16 = rtl8xxxu_read16(priv, REG_APS_FSMCO);\n\tval16 &= ~(APS_FSMCO_HW_SUSPEND | APS_FSMCO_PCIE);\n\trtl8xxxu_write16(priv, REG_APS_FSMCO, val16);\n}\n\nstatic int rtl8188e_emu_to_active(struct rtl8xxxu_priv *priv)\n{\n\tu8 val8;\n\tu32 val32;\n\tu16 val16;\n\tint count, ret = 0;\n\n\t \n\tfor (count = RTL8XXXU_MAX_REG_POLL; count; count--) {\n\t\tval32 = rtl8xxxu_read32(priv, REG_APS_FSMCO);\n\t\tif (val32 & BIT(17))\n\t\t\tbreak;\n\n\t\tudelay(10);\n\t}\n\n\tif (!count) {\n\t\tret = -EBUSY;\n\t\tgoto exit;\n\t}\n\n\t \n\tval8 = rtl8xxxu_read8(priv, REG_SYS_FUNC);\n\tval8 &= ~(SYS_FUNC_BBRSTB | SYS_FUNC_BB_GLB_RSTN);\n\trtl8xxxu_write8(priv, REG_SYS_FUNC, val8);\n\n\t \n\tval32 = rtl8xxxu_read32(priv, REG_AFE_XTAL_CTRL);\n\tval32 |= BIT(23);\n\trtl8xxxu_write32(priv, REG_AFE_XTAL_CTRL, val32);\n\n\t \n\tval16 = rtl8xxxu_read16(priv, REG_APS_FSMCO);\n\tval16 &= ~APS_FSMCO_HW_POWERDOWN;\n\trtl8xxxu_write16(priv, REG_APS_FSMCO, val16);\n\n\t \n\tval16 = rtl8xxxu_read16(priv, REG_APS_FSMCO);\n\tval16 &= ~(APS_FSMCO_HW_SUSPEND | APS_FSMCO_PCIE);\n\trtl8xxxu_write16(priv, REG_APS_FSMCO, val16);\n\n\t \n\tval32 = rtl8xxxu_read32(priv, REG_APS_FSMCO);\n\tval32 |= APS_FSMCO_MAC_ENABLE;\n\trtl8xxxu_write32(priv, REG_APS_FSMCO, val32);\n\n\tfor (count = RTL8XXXU_MAX_REG_POLL; count; count--) {\n\t\tval32 = rtl8xxxu_read32(priv, REG_APS_FSMCO);\n\t\tif ((val32 & APS_FSMCO_MAC_ENABLE) == 0) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tudelay(10);\n\t}\n\n\tif (!count) {\n\t\tret = -EBUSY;\n\t\tgoto exit;\n\t}\n\n\t \n\tval8 = rtl8xxxu_read8(priv, REG_LPLDO_CTRL);\n\tval8 &= ~BIT(4);\n\trtl8xxxu_write8(priv, REG_LPLDO_CTRL, val8);\n\nexit:\n\treturn ret;\n}\n\nstatic int rtl8188eu_active_to_emu(struct rtl8xxxu_priv *priv)\n{\n\tu8 val8;\n\n\t \n\tval8 = rtl8xxxu_read8(priv, REG_RF_CTRL);\n\tval8 &= ~RF_ENABLE;\n\trtl8xxxu_write8(priv, REG_RF_CTRL, val8);\n\n\t \n\tval8 = rtl8xxxu_read8(priv, REG_LPLDO_CTRL);\n\tval8 |= BIT(4);\n\trtl8xxxu_write8(priv, REG_LPLDO_CTRL, val8);\n\n\treturn 0;\n}\n\nstatic int rtl8188eu_emu_to_disabled(struct rtl8xxxu_priv *priv)\n{\n\tu32 val32;\n\tu16 val16;\n\tu8 val8;\n\n\tval32 = rtl8xxxu_read32(priv, REG_AFE_XTAL_CTRL);\n\tval32 |= BIT(23);\n\trtl8xxxu_write32(priv, REG_AFE_XTAL_CTRL, val32);\n\n\tval16 = rtl8xxxu_read16(priv, REG_APS_FSMCO);\n\tval16 &= ~APS_FSMCO_PCIE;\n\tval16 |= APS_FSMCO_HW_SUSPEND;\n\trtl8xxxu_write16(priv, REG_APS_FSMCO, val16);\n\n\trtl8xxxu_write8(priv, REG_APS_FSMCO + 3, 0x00);\n\n\tval8 = rtl8xxxu_read8(priv, REG_GPIO_MUXCFG + 1);\n\tval8 &= ~BIT(4);\n\trtl8xxxu_write8(priv, REG_GPIO_MUXCFG + 1, val8);\n\n\t \n\tval8 = rtl8xxxu_read8(priv, 0xfe10);\n\tval8 |= BIT(4);\n\trtl8xxxu_write8(priv, 0xfe10, val8);\n\n\treturn 0;\n}\n\nstatic int rtl8188eu_active_to_lps(struct rtl8xxxu_priv *priv)\n{\n\tstruct device *dev = &priv->udev->dev;\n\tu8 val8;\n\tu16 val16;\n\tu32 val32;\n\tint retry, retval;\n\n\trtl8xxxu_write8(priv, REG_TXPAUSE, 0x7f);\n\n\tretry = 100;\n\tretval = -EBUSY;\n\t \n\tdo {\n\t\tval32 = rtl8xxxu_read32(priv, REG_SCH_TX_CMD);\n\t\tif (!val32) {\n\t\t\tretval = 0;\n\t\t\tbreak;\n\t\t}\n\t} while (retry--);\n\n\tif (!retry) {\n\t\tdev_warn(dev, \"Failed to flush TX queue\\n\");\n\t\tretval = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t \n\tval8 = rtl8xxxu_read8(priv, REG_SYS_FUNC);\n\tval8 &= ~SYS_FUNC_BBRSTB;\n\trtl8xxxu_write8(priv, REG_SYS_FUNC, val8);\n\n\tudelay(2);\n\n\t \n\tval16 = rtl8xxxu_read16(priv, REG_CR);\n\tval16 |= 0xff;\n\tval16 &= ~(CR_MAC_TX_ENABLE | CR_MAC_RX_ENABLE | CR_SECURITY_ENABLE);\n\trtl8xxxu_write16(priv, REG_CR, val16);\n\n\tval8 = rtl8xxxu_read8(priv, REG_DUAL_TSF_RST);\n\tval8 |= DUAL_TSF_TX_OK;\n\trtl8xxxu_write8(priv, REG_DUAL_TSF_RST, val8);\n\nout:\n\treturn retval;\n}\n\nstatic int rtl8188eu_power_on(struct rtl8xxxu_priv *priv)\n{\n\tu16 val16;\n\tint ret;\n\n\trtl8188e_disabled_to_emu(priv);\n\n\tret = rtl8188e_emu_to_active(priv);\n\tif (ret)\n\t\tgoto exit;\n\n\t \n\tval16 = (CR_HCI_TXDMA_ENABLE | CR_HCI_RXDMA_ENABLE |\n\t\t CR_TXDMA_ENABLE | CR_RXDMA_ENABLE |\n\t\t CR_PROTOCOL_ENABLE | CR_SCHEDULE_ENABLE |\n\t\t CR_SECURITY_ENABLE | CR_CALTIMER_ENABLE);\n\trtl8xxxu_write16(priv, REG_CR, val16);\n\nexit:\n\treturn ret;\n}\n\nstatic void rtl8188eu_power_off(struct rtl8xxxu_priv *priv)\n{\n\tu8 val8;\n\tu16 val16;\n\n\trtl8xxxu_flush_fifo(priv);\n\n\tval8 = rtl8xxxu_read8(priv, REG_TX_REPORT_CTRL);\n\tval8 &= ~TX_REPORT_CTRL_TIMER_ENABLE;\n\trtl8xxxu_write8(priv, REG_TX_REPORT_CTRL, val8);\n\n\t \n\trtl8xxxu_write8(priv, REG_RF_CTRL, 0x00);\n\n\trtl8188eu_active_to_lps(priv);\n\n\t \n\tif (rtl8xxxu_read8(priv, REG_MCU_FW_DL) & MCU_FW_RAM_SEL)\n\t\trtl8xxxu_firmware_self_reset(priv);\n\n\t \n\tval16 = rtl8xxxu_read16(priv, REG_SYS_FUNC);\n\tval16 &= ~SYS_FUNC_CPU_ENABLE;\n\trtl8xxxu_write16(priv, REG_SYS_FUNC, val16);\n\n\t \n\trtl8xxxu_write8(priv, REG_MCU_FW_DL, 0x00);\n\n\t \n\tval8 = rtl8xxxu_read8(priv, REG_32K_CTRL);\n\tval8 &= ~BIT(0);\n\trtl8xxxu_write8(priv, REG_32K_CTRL, val8);\n\n\trtl8188eu_active_to_emu(priv);\n\trtl8188eu_emu_to_disabled(priv);\n\n\t \n\tval8 = rtl8xxxu_read8(priv, REG_RSV_CTRL + 1);\n\tval8 &= ~BIT(3);\n\trtl8xxxu_write8(priv, REG_RSV_CTRL + 1, val8);\n\n\tval8 = rtl8xxxu_read8(priv, REG_RSV_CTRL + 1);\n\tval8 |= BIT(3);\n\trtl8xxxu_write8(priv, REG_RSV_CTRL + 1, val8);\n\n\t \n\tval8 = rtl8xxxu_read8(priv, REG_GPIO_PIN_CTRL);\n\t \n\trtl8xxxu_write8(priv, REG_GPIO_PIN_CTRL + 1, val8);\n\trtl8xxxu_write8(priv, REG_GPIO_PIN_CTRL + 2, 0xff);\n\n\tval8 = rtl8xxxu_read8(priv, REG_GPIO_IO_SEL);\n\trtl8xxxu_write8(priv, REG_GPIO_IO_SEL, val8 << 4);\n\tval8 = rtl8xxxu_read8(priv, REG_GPIO_IO_SEL + 1);\n\trtl8xxxu_write8(priv, REG_GPIO_IO_SEL + 1, val8 | 0x0f);\n\n\t \n\trtl8xxxu_write32(priv, REG_PAD_CTRL1, 0x00080808);\n\n\trtl8xxxu_write8(priv, REG_RSV_CTRL, 0x00);\n\n\trtl8xxxu_write32(priv, REG_GPIO_MUXCFG, 0x00000000);\n}\n\nstatic void rtl8188e_enable_rf(struct rtl8xxxu_priv *priv)\n{\n\tu32 val32;\n\n\trtl8xxxu_write8(priv, REG_RF_CTRL, RF_ENABLE | RF_RSTB | RF_SDMRSTB);\n\n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_TRX_PATH_ENABLE);\n\tval32 &= ~(OFDM_RF_PATH_RX_MASK | OFDM_RF_PATH_TX_MASK);\n\tval32 |= OFDM_RF_PATH_RX_A | OFDM_RF_PATH_TX_A;\n\trtl8xxxu_write32(priv, REG_OFDM0_TRX_PATH_ENABLE, val32);\n\n\trtl8xxxu_write8(priv, REG_TXPAUSE, 0x00);\n}\n\nstatic void rtl8188e_disable_rf(struct rtl8xxxu_priv *priv)\n{\n\tu32 val32;\n\n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_TRX_PATH_ENABLE);\n\tval32 &= ~OFDM_RF_PATH_TX_MASK;\n\trtl8xxxu_write32(priv, REG_OFDM0_TRX_PATH_ENABLE, val32);\n\n\t \n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_AC, 0);\n\n\trtl8188eu_active_to_emu(priv);\n}\n\nstatic void rtl8188e_usb_quirks(struct rtl8xxxu_priv *priv)\n{\n\tu16 val16;\n\n\t \n\tval16 = rtl8xxxu_read16(priv, REG_CR);\n\tval16 |= (CR_MAC_TX_ENABLE | CR_MAC_RX_ENABLE);\n\trtl8xxxu_write16(priv, REG_CR, val16);\n\n\trtl8xxxu_gen2_usb_quirks(priv);\n\n\t \n\trtl8xxxu_write8(priv, REG_EARLY_MODE_CONTROL_8188E + 3, 0x01);\n}\n\nstatic s8 rtl8188e_cck_rssi(struct rtl8xxxu_priv *priv, struct rtl8723au_phy_stats *phy_stats)\n{\n\t \n\tstatic const s8 lna_gain_table_0[8] = {17, -1, -13, -29, -32, -35, -38, -41};\n\t \n\tstatic const s8 lna_gain_table_1[8] = {29, 20, 12, 3, -6, -15, -24, -33};\n\n\tu8 cck_agc_rpt = phy_stats->cck_agc_rpt_ofdm_cfosho_a;\n\ts8 rx_pwr_all = 0x00;\n\tu8 vga_idx, lna_idx;\n\ts8 lna_gain = 0;\n\n\tlna_idx = u8_get_bits(cck_agc_rpt, CCK_AGC_RPT_LNA_IDX_MASK);\n\tvga_idx = u8_get_bits(cck_agc_rpt, CCK_AGC_RPT_VGA_IDX_MASK);\n\n\tif (priv->chip_cut >= 8)    \n\t\tlna_gain = lna_gain_table_0[lna_idx];\n\telse  \n\t\tlna_gain = lna_gain_table_1[lna_idx];\n\n\trx_pwr_all = lna_gain - (2 * vga_idx);\n\n\treturn rx_pwr_all;\n}\n\nstatic int rtl8188eu_led_brightness_set(struct led_classdev *led_cdev,\n\t\t\t\t\tenum led_brightness brightness)\n{\n\tstruct rtl8xxxu_priv *priv = container_of(led_cdev,\n\t\t\t\t\t\t  struct rtl8xxxu_priv,\n\t\t\t\t\t\t  led_cdev);\n\tu8 ledcfg = rtl8xxxu_read8(priv, REG_LEDCFG2);\n\n\tif (brightness == LED_OFF) {\n\t\tledcfg &= ~LEDCFG2_HW_LED_CONTROL;\n\t\tledcfg |= LEDCFG2_SW_LED_CONTROL | LEDCFG2_SW_LED_DISABLE;\n\t} else if (brightness == LED_ON) {\n\t\tledcfg &= ~(LEDCFG2_HW_LED_CONTROL | LEDCFG2_SW_LED_DISABLE);\n\t\tledcfg |= LEDCFG2_SW_LED_CONTROL;\n\t} else if (brightness == RTL8XXXU_HW_LED_CONTROL) {\n\t\tledcfg &= ~LEDCFG2_SW_LED_DISABLE;\n\t\tledcfg |= LEDCFG2_HW_LED_CONTROL | LEDCFG2_HW_LED_ENABLE;\n\t}\n\n\trtl8xxxu_write8(priv, REG_LEDCFG2, ledcfg);\n\n\treturn 0;\n}\n\nstatic void rtl8188e_set_tx_rpt_timing(struct rtl8xxxu_ra_info *ra, u8 timing)\n{\n\tu8 idx;\n\n\tfor (idx = 0; idx < 5; idx++)\n\t\tif (dynamic_tx_rpt_timing[idx] == ra->rpt_time)\n\t\t\tbreak;\n\n\tif (timing == DEFAULT_TIMING) {\n\t\tidx = 0;  \n\t} else if (timing == INCREASE_TIMING) {\n\t\tif (idx < 5)\n\t\t\tidx++;\n\t} else if (timing == DECREASE_TIMING) {\n\t\tif (idx > 0)\n\t\t\tidx--;\n\t}\n\n\tra->rpt_time = dynamic_tx_rpt_timing[idx];\n}\n\nstatic void rtl8188e_rate_down(struct rtl8xxxu_ra_info *ra)\n{\n\tu8 rate_id = ra->pre_rate;\n\tu8 lowest_rate = ra->lowest_rate;\n\tu8 highest_rate = ra->highest_rate;\n\ts8 i;\n\n\tif (rate_id > highest_rate) {\n\t\trate_id = highest_rate;\n\t} else if (ra->rate_sgi) {\n\t\tra->rate_sgi = 0;\n\t} else if (rate_id > lowest_rate) {\n\t\tif (rate_id > 0) {\n\t\t\tfor (i = rate_id - 1; i >= lowest_rate; i--) {\n\t\t\t\tif (ra->ra_use_rate & BIT(i)) {\n\t\t\t\t\trate_id = i;\n\t\t\t\t\tgoto rate_down_finish;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (rate_id <= lowest_rate) {\n\t\trate_id = lowest_rate;\n\t}\n\nrate_down_finish:\n\tif (ra->ra_waiting_counter == 1) {\n\t\tra->ra_waiting_counter++;\n\t\tra->ra_pending_counter++;\n\t} else if (ra->ra_waiting_counter > 1) {\n\t\tra->ra_waiting_counter = 0;\n\t\tra->ra_pending_counter = 0;\n\t}\n\n\tif (ra->ra_pending_counter >= 4)\n\t\tra->ra_pending_counter = 4;\n\n\tra->ra_drop_after_down = 1;\n\n\tra->decision_rate = rate_id;\n\n\trtl8188e_set_tx_rpt_timing(ra, DECREASE_TIMING);\n}\n\nstatic void rtl8188e_rate_up(struct rtl8xxxu_ra_info *ra)\n{\n\tu8 rate_id = ra->pre_rate;\n\tu8 highest_rate = ra->highest_rate;\n\tu8 i;\n\n\tif (ra->ra_waiting_counter == 1) {\n\t\tra->ra_waiting_counter = 0;\n\t\tra->ra_pending_counter = 0;\n\t} else if (ra->ra_waiting_counter > 1) {\n\t\tra->pre_rssi_sta_ra = ra->rssi_sta_ra;\n\t\tgoto rate_up_finish;\n\t}\n\n\trtl8188e_set_tx_rpt_timing(ra, DEFAULT_TIMING);\n\n\tif (rate_id < highest_rate) {\n\t\tfor (i = rate_id + 1; i <= highest_rate; i++) {\n\t\t\tif (ra->ra_use_rate & BIT(i)) {\n\t\t\t\trate_id = i;\n\t\t\t\tgoto rate_up_finish;\n\t\t\t}\n\t\t}\n\t} else if (rate_id == highest_rate) {\n\t\tif (ra->sgi_enable && !ra->rate_sgi)\n\t\t\tra->rate_sgi = 1;\n\t\telse if (!ra->sgi_enable)\n\t\t\tra->rate_sgi = 0;\n\t} else {  \n\t\trate_id = highest_rate;\n\t}\n\nrate_up_finish:\n\tif (ra->ra_waiting_counter == (4 + pending_for_rate_up_fail[ra->ra_pending_counter]))\n\t\tra->ra_waiting_counter = 0;\n\telse\n\t\tra->ra_waiting_counter++;\n\n\tra->decision_rate = rate_id;\n}\n\nstatic void rtl8188e_reset_ra_counter(struct rtl8xxxu_ra_info *ra)\n{\n\tu8 rate_id = ra->decision_rate;\n\n\tra->nsc_up = (n_threshold_high[rate_id] + n_threshold_low[rate_id]) >> 1;\n\tra->nsc_down = (n_threshold_high[rate_id] + n_threshold_low[rate_id]) >> 1;\n}\n\nstatic void rtl8188e_rate_decision(struct rtl8xxxu_ra_info *ra)\n{\n\tstruct rtl8xxxu_priv *priv = container_of(ra, struct rtl8xxxu_priv, ra_info);\n\tconst u8 *retry_penalty_idx_0;\n\tconst u8 *retry_penalty_idx_1;\n\tconst u8 *retry_penalty_up_idx;\n\tu8 rate_id, penalty_id1, penalty_id2;\n\tint i;\n\n\tif (ra->total == 0)\n\t\treturn;\n\n\tif (ra->ra_drop_after_down) {\n\t\tra->ra_drop_after_down--;\n\n\t\trtl8188e_reset_ra_counter(ra);\n\n\t\treturn;\n\t}\n\n\tif (priv->chip_cut == 8) {  \n\t\tretry_penalty_idx_0 = retry_penalty_idx_cut_i[0];\n\t\tretry_penalty_idx_1 = retry_penalty_idx_cut_i[1];\n\t\tretry_penalty_up_idx = retry_penalty_up_idx_cut_i;\n\t} else {\n\t\tretry_penalty_idx_0 = retry_penalty_idx_normal[0];\n\t\tretry_penalty_idx_1 = retry_penalty_idx_normal[1];\n\t\tretry_penalty_up_idx = retry_penalty_up_idx_normal;\n\t}\n\n\tif (ra->rssi_sta_ra < (ra->pre_rssi_sta_ra - 3) ||\n\t    ra->rssi_sta_ra > (ra->pre_rssi_sta_ra + 3)) {\n\t\tra->pre_rssi_sta_ra = ra->rssi_sta_ra;\n\t\tra->ra_waiting_counter = 0;\n\t\tra->ra_pending_counter = 0;\n\t}\n\n\t \n\tif (ra->pre_rate > ra->highest_rate)\n\t\trate_id = ra->highest_rate;\n\telse\n\t\trate_id = ra->pre_rate;\n\n\t \n\tif (ra->rssi_sta_ra > rssi_threshold[rate_id])\n\t\tpenalty_id1 = retry_penalty_idx_0[rate_id];\n\telse\n\t\tpenalty_id1 = retry_penalty_idx_1[rate_id];\n\n\tfor (i = 0; i < 5; i++)\n\t\tra->nsc_down += ra->retry[i] * retry_penalty[penalty_id1][i];\n\n\tif (ra->nsc_down > (ra->total * retry_penalty[penalty_id1][5]))\n\t\tra->nsc_down -= ra->total * retry_penalty[penalty_id1][5];\n\telse\n\t\tra->nsc_down = 0;\n\n\t \n\tpenalty_id2 = retry_penalty_up_idx[rate_id];\n\n\tfor (i = 0; i < 5; i++)\n\t\tra->nsc_up += ra->retry[i] * retry_penalty[penalty_id2][i];\n\n\tif (ra->nsc_up > (ra->total * retry_penalty[penalty_id2][5]))\n\t\tra->nsc_up -= ra->total * retry_penalty[penalty_id2][5];\n\telse\n\t\tra->nsc_up = 0;\n\n\tif (ra->nsc_down < n_threshold_low[rate_id] ||\n\t    ra->drop > dropping_necessary[rate_id]) {\n\t\trtl8188e_rate_down(ra);\n\n\t\trtl8xxxu_update_ra_report(&priv->ra_report, ra->decision_rate,\n\t\t\t\t\t  ra->rate_sgi, priv->ra_report.txrate.bw);\n\t} else if (ra->nsc_up > n_threshold_high[rate_id]) {\n\t\trtl8188e_rate_up(ra);\n\n\t\trtl8xxxu_update_ra_report(&priv->ra_report, ra->decision_rate,\n\t\t\t\t\t  ra->rate_sgi, priv->ra_report.txrate.bw);\n\t}\n\n\tif (ra->decision_rate == ra->pre_rate)\n\t\tra->dynamic_tx_rpt_timing_counter++;\n\telse\n\t\tra->dynamic_tx_rpt_timing_counter = 0;\n\n\tif (ra->dynamic_tx_rpt_timing_counter >= 4) {\n\t\t \n\t\trtl8188e_set_tx_rpt_timing(ra, INCREASE_TIMING);\n\t\tra->dynamic_tx_rpt_timing_counter = 0;\n\t}\n\n\tra->pre_rate = ra->decision_rate;\n\n\trtl8188e_reset_ra_counter(ra);\n}\n\nstatic void rtl8188e_power_training_try_state(struct rtl8xxxu_ra_info *ra)\n{\n\tra->pt_try_state = 0;\n\tswitch (ra->pt_mode_ss) {\n\tcase 3:\n\t\tif (ra->decision_rate >= DESC_RATE_MCS13)\n\t\t\tra->pt_try_state = 1;\n\t\tbreak;\n\tcase 2:\n\t\tif (ra->decision_rate >= DESC_RATE_MCS5)\n\t\t\tra->pt_try_state = 1;\n\t\tbreak;\n\tcase 1:\n\t\tif (ra->decision_rate >= DESC_RATE_48M)\n\t\t\tra->pt_try_state = 1;\n\t\tbreak;\n\tcase 0:\n\t\tif (ra->decision_rate >= DESC_RATE_11M)\n\t\t\tra->pt_try_state = 1;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (ra->rssi_sta_ra < 48) {\n\t\tra->pt_stage = 0;\n\t} else if (ra->pt_try_state == 1) {\n\t\tif ((ra->pt_stop_count >= 10) ||\n\t\t    (ra->pt_pre_rssi > ra->rssi_sta_ra + 5) ||\n\t\t    (ra->pt_pre_rssi < ra->rssi_sta_ra - 5) ||\n\t\t    (ra->decision_rate != ra->pt_pre_rate)) {\n\t\t\tif (ra->pt_stage == 0)\n\t\t\t\tra->pt_stage = 1;\n\t\t\telse if (ra->pt_stage == 1)\n\t\t\t\tra->pt_stage = 3;\n\t\t\telse\n\t\t\t\tra->pt_stage = 5;\n\n\t\t\tra->pt_pre_rssi = ra->rssi_sta_ra;\n\t\t\tra->pt_stop_count = 0;\n\t\t} else {\n\t\t\tra->ra_stage = 0;\n\t\t\tra->pt_stop_count++;\n\t\t}\n\t} else {\n\t\tra->pt_stage = 0;\n\t\tra->ra_stage = 0;\n\t}\n\n\tra->pt_pre_rate = ra->decision_rate;\n\n\t \n\t \n\t \n\tif (1) {\n\t\tra->pt_stage = 0;\n\t\tra->ra_stage = 0;\n\t\tra->pt_stop_count = 0;\n\t}\n}\n\nstatic void rtl8188e_power_training_decision(struct rtl8xxxu_ra_info *ra)\n{\n\tu8 temp_stage;\n\tu32 numsc;\n\tu32 num_total;\n\tu8 stage_id;\n\tu8 j;\n\n\tnumsc = 0;\n\tnum_total = ra->total * pt_penalty[5];\n\tfor (j = 0; j <= 4; j++) {\n\t\tnumsc += ra->retry[j] * pt_penalty[j];\n\n\t\tif (numsc > num_total)\n\t\t\tbreak;\n\t}\n\n\tj >>= 1;\n\ttemp_stage = (ra->pt_stage + 1) >> 1;\n\tif (temp_stage > j)\n\t\tstage_id = temp_stage - j;\n\telse\n\t\tstage_id = 0;\n\n\tra->pt_smooth_factor = (ra->pt_smooth_factor >> 1) +\n\t\t\t       (ra->pt_smooth_factor >> 2) +\n\t\t\t       stage_id * 16 + 2;\n\tif (ra->pt_smooth_factor > 192)\n\t\tra->pt_smooth_factor = 192;\n\tstage_id = ra->pt_smooth_factor >> 6;\n\ttemp_stage = stage_id * 2;\n\tif (temp_stage != 0)\n\t\ttemp_stage--;\n\tif (ra->drop > 3)\n\t\ttemp_stage = 0;\n\tra->pt_stage = temp_stage;\n}\n\nvoid rtl8188e_handle_ra_tx_report2(struct rtl8xxxu_priv *priv, struct sk_buff *skb)\n{\n\tu32 *_rx_desc = (u32 *)(skb->data - sizeof(struct rtl8xxxu_rxdesc16));\n\tstruct rtl8xxxu_rxdesc16 *rx_desc = (struct rtl8xxxu_rxdesc16 *)_rx_desc;\n\tstruct device *dev = &priv->udev->dev;\n\tstruct rtl8xxxu_ra_info *ra = &priv->ra_info;\n\tu32 tx_rpt_len = rx_desc->pktlen & 0x3ff;\n\tu32 items = tx_rpt_len / TX_RPT2_ITEM_SIZE;\n\tu64 macid_valid = ((u64)_rx_desc[5] << 32) | _rx_desc[4];\n\tu32 macid;\n\tu8 *rpt = skb->data;\n\tbool valid;\n\tu16 min_rpt_time = 0x927c;\n\n\tdev_dbg(dev, \"%s: len: %d items: %d\\n\", __func__, tx_rpt_len, items);\n\n\t \n\tif (!priv->vif || priv->vif->type == NL80211_IFTYPE_STATION)\n\t\titems = 1;\n\n\tfor (macid = 0; macid < items; macid++) {\n\t\tvalid = false;\n\n\t\tif (macid < 64)\n\t\t\tvalid = macid_valid & BIT(macid);\n\n\t\tif (valid) {\n\t\t\tra->retry[0] = le16_to_cpu(*(__le16 *)rpt);\n\t\t\tra->retry[1] = rpt[2];\n\t\t\tra->retry[2] = rpt[3];\n\t\t\tra->retry[3] = rpt[4];\n\t\t\tra->retry[4] = rpt[5];\n\t\t\tra->drop = rpt[6];\n\t\t\tra->total = ra->retry[0] + ra->retry[1] + ra->retry[2] +\n\t\t\t\t    ra->retry[3] + ra->retry[4] + ra->drop;\n\n\t\t\tif (ra->total > 0) {\n\t\t\t\tif (ra->ra_stage < 5)\n\t\t\t\t\trtl8188e_rate_decision(ra);\n\t\t\t\telse if (ra->ra_stage == 5)\n\t\t\t\t\trtl8188e_power_training_try_state(ra);\n\t\t\t\telse  \n\t\t\t\t\trtl8188e_power_training_decision(ra);\n\n\t\t\t\tif (ra->ra_stage <= 5)\n\t\t\t\t\tra->ra_stage++;\n\t\t\t\telse\n\t\t\t\t\tra->ra_stage = 0;\n\t\t\t}\n\t\t} else if (macid == 0) {\n\t\t\tdev_warn(dev, \"%s: TX report item 0 not valid\\n\", __func__);\n\t\t}\n\n\t\tdev_dbg(dev, \"%s:  valid: %d retry: %d %d %d %d %d drop: %d\\n\",\n\t\t\t__func__, valid,\n\t\t\tra->retry[0], ra->retry[1], ra->retry[2],\n\t\t\tra->retry[3], ra->retry[4], ra->drop);\n\n\t\tif (min_rpt_time > ra->rpt_time)\n\t\t\tmin_rpt_time = ra->rpt_time;\n\n\t\trpt += TX_RPT2_ITEM_SIZE;\n\t}\n\n\tif (min_rpt_time != ra->pre_min_rpt_time) {\n\t\trtl8xxxu_write16(priv, REG_TX_REPORT_TIME, min_rpt_time);\n\t\tra->pre_min_rpt_time = min_rpt_time;\n\t}\n}\n\nstatic void rtl8188e_arfb_refresh(struct rtl8xxxu_ra_info *ra)\n{\n\ts8 i;\n\n\tra->ra_use_rate = ra->rate_mask;\n\n\t \n\tif (ra->ra_use_rate) {\n\t\tfor (i = RATESIZE; i >= 0; i--) {\n\t\t\tif (ra->ra_use_rate & BIT(i)) {\n\t\t\t\tra->highest_rate = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tra->highest_rate = 0;\n\t}\n\n\t \n\tif (ra->ra_use_rate) {\n\t\tfor (i = 0; i < RATESIZE; i++) {\n\t\t\tif (ra->ra_use_rate & BIT(i)) {\n\t\t\t\tra->lowest_rate = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tra->lowest_rate = 0;\n\t}\n\n\tif (ra->highest_rate > DESC_RATE_MCS7)\n\t\tra->pt_mode_ss = 3;\n\telse if (ra->highest_rate > DESC_RATE_54M)\n\t\tra->pt_mode_ss = 2;\n\telse if (ra->highest_rate > DESC_RATE_11M)\n\t\tra->pt_mode_ss = 1;\n\telse\n\t\tra->pt_mode_ss = 0;\n}\n\nstatic void\nrtl8188e_update_rate_mask(struct rtl8xxxu_priv *priv,\n\t\t\t  u32 ramask, u8 rateid, int sgi, int txbw_40mhz,\n\t\t\t  u8 macid)\n{\n\tstruct rtl8xxxu_ra_info *ra = &priv->ra_info;\n\n\tra->rate_id = rateid;\n\tra->rate_mask = ramask;\n\tra->sgi_enable = sgi;\n\n\trtl8188e_arfb_refresh(ra);\n}\n\nstatic void rtl8188e_ra_set_rssi(struct rtl8xxxu_priv *priv, u8 macid, u8 rssi)\n{\n\tpriv->ra_info.rssi_sta_ra = rssi;\n}\n\nvoid rtl8188e_ra_info_init_all(struct rtl8xxxu_ra_info *ra)\n{\n\tra->decision_rate = DESC_RATE_MCS7;\n\tra->pre_rate = DESC_RATE_MCS7;\n\tra->highest_rate = DESC_RATE_MCS7;\n\tra->lowest_rate = 0;\n\tra->rate_id = 0;\n\tra->rate_mask = 0xfffff;\n\tra->rssi_sta_ra = 0;\n\tra->pre_rssi_sta_ra = 0;\n\tra->sgi_enable = 0;\n\tra->ra_use_rate = 0xfffff;\n\tra->nsc_down = (n_threshold_high[DESC_RATE_MCS7] + n_threshold_low[DESC_RATE_MCS7]) / 2;\n\tra->nsc_up = (n_threshold_high[DESC_RATE_MCS7] + n_threshold_low[DESC_RATE_MCS7]) / 2;\n\tra->rate_sgi = 0;\n\tra->rpt_time = 0x927c;\n\tra->drop = 0;\n\tra->retry[0] = 0;\n\tra->retry[1] = 0;\n\tra->retry[2] = 0;\n\tra->retry[3] = 0;\n\tra->retry[4] = 0;\n\tra->total = 0;\n\tra->ra_waiting_counter = 0;\n\tra->ra_pending_counter = 0;\n\tra->ra_drop_after_down = 0;\n\n\tra->pt_try_state = 0;\n\tra->pt_stage = 5;\n\tra->pt_smooth_factor = 192;\n\tra->pt_stop_count = 0;\n\tra->pt_pre_rate = 0;\n\tra->pt_pre_rssi = 0;\n\tra->pt_mode_ss = 0;\n\tra->ra_stage = 0;\n}\n\nstruct rtl8xxxu_fileops rtl8188eu_fops = {\n\t.identify_chip = rtl8188eu_identify_chip,\n\t.parse_efuse = rtl8188eu_parse_efuse,\n\t.load_firmware = rtl8188eu_load_firmware,\n\t.power_on = rtl8188eu_power_on,\n\t.power_off = rtl8188eu_power_off,\n\t.read_efuse = rtl8xxxu_read_efuse,\n\t.reset_8051 = rtl8188eu_reset_8051,\n\t.llt_init = rtl8xxxu_init_llt_table,\n\t.init_phy_bb = rtl8188eu_init_phy_bb,\n\t.init_phy_rf = rtl8188eu_init_phy_rf,\n\t.phy_lc_calibrate = rtl8723a_phy_lc_calibrate,\n\t.phy_iq_calibrate = rtl8188eu_phy_iq_calibrate,\n\t.config_channel = rtl8188eu_config_channel,\n\t.parse_rx_desc = rtl8xxxu_parse_rxdesc16,\n\t.parse_phystats = rtl8723au_rx_parse_phystats,\n\t.init_aggregation = rtl8188eu_init_aggregation,\n\t.enable_rf = rtl8188e_enable_rf,\n\t.disable_rf = rtl8188e_disable_rf,\n\t.usb_quirks = rtl8188e_usb_quirks,\n\t.set_tx_power = rtl8188f_set_tx_power,\n\t.update_rate_mask = rtl8188e_update_rate_mask,\n\t.report_connect = rtl8xxxu_gen2_report_connect,\n\t.report_rssi = rtl8188e_ra_set_rssi,\n\t.fill_txdesc = rtl8xxxu_fill_txdesc_v3,\n\t.set_crystal_cap = rtl8188f_set_crystal_cap,\n\t.cck_rssi = rtl8188e_cck_rssi,\n\t.led_classdev_brightness_set = rtl8188eu_led_brightness_set,\n\t.writeN_block_size = 128,\n\t.rx_desc_size = sizeof(struct rtl8xxxu_rxdesc16),\n\t.tx_desc_size = sizeof(struct rtl8xxxu_txdesc32),\n\t.has_tx_report = 1,\n\t.init_reg_pkt_life_time = 1,\n\t.gen2_thermal_meter = 1,\n\t.adda_1t_init = 0x0b1b25a0,\n\t.adda_1t_path_on = 0x0bdb25a0,\n\t \n\t.trxff_boundary = 0x25ff,\n\t.pbp_rx = PBP_PAGE_SIZE_128,\n\t.pbp_tx = PBP_PAGE_SIZE_128,\n\t.mactable = rtl8188e_mac_init_table,\n\t.total_page_num = TX_TOTAL_PAGE_NUM_8188E,\n\t.page_num_hi = TX_PAGE_NUM_HI_PQ_8188E,\n\t.page_num_lo = TX_PAGE_NUM_LO_PQ_8188E,\n\t.page_num_norm = TX_PAGE_NUM_NORM_PQ_8188E,\n\t.last_llt_entry = 175,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}