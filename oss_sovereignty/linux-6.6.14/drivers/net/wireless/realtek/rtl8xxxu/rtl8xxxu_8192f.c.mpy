{
  "module_name": "rtl8xxxu_8192f.c",
  "hash_id": "2f40cad9df976312ee7521b2e7562205a2b2fb0f815ede33c0aa1b7f15e4f85d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu_8192f.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/usb.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/wireless.h>\n#include <linux/firmware.h>\n#include <linux/moduleparam.h>\n#include <net/mac80211.h>\n#include \"rtl8xxxu.h\"\n#include \"rtl8xxxu_regs.h\"\n\nstatic const struct rtl8xxxu_reg8val rtl8192f_mac_init_table[] = {\n\t{0x420, 0x00},\t{0x422, 0x78},\t{0x428, 0x0a},\t{0x429, 0x10},\n\t{0x430, 0x00},\t{0x431, 0x00},\t{0x432, 0x00},\t{0x433, 0x01},\n\t{0x434, 0x04},\t{0x435, 0x05},\t{0x436, 0x07},\t{0x437, 0x08},\n\t{0x43c, 0x04},\t{0x43d, 0x05},\t{0x43e, 0x07},\t{0x43f, 0x08},\n\t{0x440, 0x5d},\t{0x441, 0x01},\t{0x442, 0x00},\t{0x444, 0x10},\n\t{0x445, 0xf0},\t{0x446, 0x0e},\t{0x447, 0x1f},\t{0x448, 0x00},\n\t{0x449, 0x00},\t{0x44a, 0x00},\t{0x44b, 0x00},\t{0x44c, 0x10},\n\t{0x44d, 0xf0},\t{0x44e, 0x0e},\t{0x44f, 0x00},\t{0x450, 0x00},\n\t{0x451, 0x00},\t{0x452, 0x00},\t{0x453, 0x00},\t{0x480, 0x20},\n\t{0x49c, 0x30},\t{0x49d, 0xf0},\t{0x49e, 0x03},\t{0x49f, 0x3e},\n\t{0x4a0, 0x00},\t{0x4a1, 0x00},\t{0x4a2, 0x00},\t{0x4a3, 0x00},\n\t{0x4a4, 0x15},\t{0x4a5, 0xf0},\t{0x4a6, 0x01},\t{0x4a7, 0x0e},\n\t{0x4a8, 0xe0},\t{0x4a9, 0x00},\t{0x4aa, 0x00},\t{0x4ab, 0x00},\n\t{0x2448, 0x06},\t{0x244a, 0x06},\t{0x244c, 0x06},\t{0x244e, 0x06},\n\t{0x4c7, 0x80},\t{0x4c8, 0xff},\t{0x4c9, 0x08},\t{0x4ca, 0x3c},\n\t{0x4cb, 0x3c},\t{0x4cc, 0xff},\t{0x4cd, 0xff},\t{0x4ce, 0x01},\n\t{0x500, 0x26},\t{0x501, 0xa2},\t{0x502, 0x2f},\t{0x503, 0x00},\n\t{0x504, 0x28},\t{0x505, 0xa3},\t{0x506, 0x5e},\t{0x507, 0x00},\n\t{0x508, 0x2b},\t{0x509, 0xa4},\t{0x50a, 0x5e},\t{0x50b, 0x00},\n\t{0x50c, 0x4f},\t{0x50d, 0xa4},\t{0x50e, 0x00},\t{0x50f, 0x00},\n\t{0x512, 0x1c},\t{0x514, 0x0a},\t{0x516, 0x0a},\t{0x521, 0x2f},\n\t{0x525, 0x0f},\t{0x550, 0x10},\t{0x551, 0x10},\t{0x559, 0x02},\n\t{0x55c, 0x50},\t{0x55d, 0xff},\t{0x605, 0x30},\t{0x608, 0x0e},\n\t{0x609, 0x2a},\t{0x60c, 0x18},\t{0x620, 0xff},\t{0x621, 0xff},\n\t{0x622, 0xff},\t{0x623, 0xff},\t{0x624, 0xff},\t{0x625, 0xff},\n\t{0x626, 0xff},\t{0x627, 0xff},\t{0x638, 0x50},\t{0x63c, 0x0a},\n\t{0x63d, 0x0a},\t{0x63e, 0x0e},\t{0x63f, 0x0e},\t{0x640, 0x40},\n\t{0x642, 0x40},\t{0x643, 0x00},\t{0x652, 0xc8},\t{0x66e, 0x05},\n\t{0x6a0, 0xff},\t{0x6a1, 0xff},\t{0x6a2, 0xff},\t{0x6a3, 0xff},\n\t{0x6a4, 0xff},\t{0x6a5, 0xff},\t{0x6de, 0x84},\t{0x700, 0x21},\n\t{0x701, 0x43},\t{0x702, 0x65},\t{0x703, 0x87},\t{0x708, 0x21},\n\t{0x709, 0x43},\t{0x70a, 0x65},\t{0x70b, 0x87},\t{0x718, 0x40},\n\t{0x7c0, 0x38},\t{0x7c2, 0x0f},\t{0x7c3, 0xc0},\t{0x073, 0x04},\n\t{0x7c4, 0x77},\t{0x024, 0xc7},\t{0x7ec, 0xff},\t{0x7ed, 0xff},\n\t{0x7ee, 0xff},\t{0x7ef, 0xff},\n\t{0xffff, 0xff},\n};\n\n \nstatic const struct rtl8xxxu_reg32val rtl8192fu_phy_init_table[] = {\n\t{0x800, 0x80006C00},\t{0x804, 0x00004001},\n\t{0x808, 0x0000FC00},\t{0x80C, 0x00000000},\n\t{0x810, 0x20200322},\t{0x814, 0x020C3910},\n\t{0x818, 0x00000385},\t{0x81C, 0x07000000},\n\t{0x820, 0x01000100},\t{0x824, 0x00390204},\n\t{0x828, 0x01000100},\t{0x82C, 0x00390204},\n\t{0x830, 0x25252525},\t{0x834, 0x25252525},\n\t{0x838, 0x25252525},\t{0x83C, 0x25252525},\n\t{0x840, 0x00010000},\t{0x844, 0x00010000},\n\t{0x848, 0x25252525},\t{0x84C, 0x25252525},\n\t{0x850, 0x00031FE0},\t{0x854, 0x00000000},\n\t{0x858, 0x569A569A},\t{0x85C, 0x00400040},\n\t{0x860, 0x66F60000},\t{0x864, 0x061F0000},\n\t{0x868, 0x25252525},\t{0x86C, 0x25252525},\n\t{0x870, 0x00000300},\t{0x874, 0x04003400},\n\t{0x878, 0x08080808},\t{0x87C, 0x004F0201},\n\t{0x880, 0xD8001402},\t{0x884, 0xC0000120},\n\t{0x888, 0x00000000},\t{0x88C, 0xCC0000C0},\n\t{0x890, 0x00000000},\t{0x894, 0xFFFFFFFE},\n\t{0x898, 0x40302010},\t{0x89C, 0x00706050},\n\t{0x900, 0x00000000},\t{0x904, 0x00000023},\n\t{0x908, 0x00000F00},\t{0x90C, 0x81121313},\n\t{0x910, 0x024C0000},\t{0x914, 0x00000000},\n\t{0x918, 0x00000000},\t{0x91C, 0x00000000},\n\t{0x920, 0x00000000},\t{0x924, 0x00000000},\n\t{0x928, 0x00000000},\t{0x92C, 0x00000000},\n\t{0x930, 0x88000000},\t{0x934, 0x00000245},\n\t{0x938, 0x00024588},\t{0x93C, 0x00000000},\n\t{0x940, 0x000007FF},\t{0x944, 0x3F3F0000},\n\t{0x948, 0x000001A3},\t{0x94C, 0x20200008},\n\t{0x950, 0x00338A98},\t{0x954, 0x00000000},\n\t{0x958, 0xCBCAD87A},\t{0x95C, 0x06EB5735},\n\t{0x960, 0x00000000},\t{0x964, 0x00000000},\n\t{0x968, 0x00000000},\t{0x96C, 0x00000003},\n\t{0x970, 0x00000000},\t{0x974, 0x00000000},\n\t{0x978, 0x00000000},\t{0x97C, 0x10030000},\n\t{0x980, 0x00000000},\t{0x984, 0x02800280},\n\t{0x988, 0x020A5704},\t{0x98C, 0x1461C826},\n\t{0x990, 0x0001469E},\t{0x994, 0x008858D1},\n\t{0x998, 0x400086C9},\t{0x99C, 0x44444242},\n\t{0x9A0, 0x00000000},\t{0x9A4, 0x00000000},\n\t{0x9A8, 0x00000000},\t{0x9AC, 0xC0000000},\n\t{0xA00, 0x00D047C8},\t{0xA04, 0xC1FF0008},\n\t{0xA08, 0x88838300},\t{0xA0C, 0x2E20100F},\n\t{0xA10, 0x9500BB78},\t{0xA14, 0x11144028},\n\t{0xA18, 0x00881117},\t{0xA1C, 0x89140F00},\n\t{0xA20, 0xE82C0001},\t{0xA24, 0x64B80C1C},\n\t{0xA28, 0x00158810},\t{0xA2C, 0x10BB8000},\n\t{0xA70, 0x00008000},\t{0xA74, 0x80800100},\n\t{0xA78, 0x000089F0},\t{0xA7C, 0x225B0606},\n\t{0xA80, 0x20803210},\t{0xA84, 0x00200200},\n\t{0xA88, 0x00000000},\t{0xA8C, 0x00000000},\n\t{0xA90, 0x00000000},\t{0xA94, 0x00000000},\n\t{0xA98, 0x00000000},\t{0xA9C, 0x00460000},\n\t{0xAA0, 0x00000000},\t{0xAA4, 0x00020014},\n\t{0xAA8, 0xBA0A0008},\t{0xAAC, 0x01235667},\n\t{0xAB0, 0x00000000},\t{0xAB4, 0x00201402},\n\t{0xAB8, 0x0000001C},\t{0xABC, 0x0000F7FF},\n\t{0xAC0, 0xD4C0A742},\t{0xAC4, 0x00000000},\n\t{0xAC8, 0x00000F08},\t{0xACC, 0x00000F07},\n\t{0xAD0, 0xA1052A10},\t{0xAD4, 0x0D9D8452},\n\t{0xAD8, 0x9E024024},\t{0xADC, 0x0023C001},\n\t{0xAE0, 0x00000391},\t{0xB2C, 0x00000000},\n\t{0xC00, 0x00000080},\t{0xC04, 0x6F005433},\n\t{0xC08, 0x000004E4},\t{0xC0C, 0x6C6C6C6C},\n\t{0xC10, 0x22000000},\t{0xC14, 0x40000100},\n\t{0xC18, 0x22000000},\t{0xC1C, 0x40000100},\n\t{0xC20, 0x00000000},\t{0xC24, 0x40000100},\n\t{0xC28, 0x00000000},\t{0xC2C, 0x40000100},\n\t{0xC30, 0x0401E809},\t{0xC34, 0x30000020},\n\t{0xC38, 0x23808080},\t{0xC3C, 0x00002F44},\n\t{0xC40, 0x1CF8403F},\t{0xC44, 0x000100C7},\n\t{0xC48, 0xEC060106},\t{0xC4C, 0x007F037F},\n\t{0xC50, 0x00E48020},\t{0xC54, 0x04008017},\n\t{0xC58, 0x00000020},\t{0xC5C, 0x00708492},\n\t{0xC60, 0x09280200},\t{0xC64, 0x5014838B},\n\t{0xC68, 0x47C006C7},\t{0xC6C, 0x00000035},\n\t{0xC70, 0x00001007},\t{0xC74, 0x02815269},\n\t{0xC78, 0x0FE07F1F},\t{0xC7C, 0x00B91612},\n\t{0xC80, 0x40000100},\t{0xC84, 0x32000000},\n\t{0xC88, 0x40000100},\t{0xC8C, 0xA0240000},\n\t{0xC90, 0x400E161E},\t{0xC94, 0x00000F00},\n\t{0xC98, 0x400E161E},\t{0xC9C, 0x0000BDC8},\n\t{0xCA0, 0x00000000},\t{0xCA4, 0x098300A0},\n\t{0xCA8, 0x00006B00},\t{0xCAC, 0x87F45B1A},\n\t{0xCB0, 0x0000002D},\t{0xCB4, 0x00000000},\n\t{0xCB8, 0x00000000},\t{0xCBC, 0x28100200},\n\t{0xCC0, 0x0010A3D0},\t{0xCC4, 0x00000F7D},\n\t{0xCC8, 0x00000000},\t{0xCCC, 0x00000000},\n\t{0xCD0, 0x593659AD},\t{0xCD4, 0xB7545121},\n\t{0xCD8, 0x64B22427},\t{0xCDC, 0x00766932},\n\t{0xCE0, 0x40201000},\t{0xCE4, 0x00000000},\n\t{0xCE8, 0x40E04407},\t{0xCEC, 0x2E572000},\n\t{0xD00, 0x000D8780},\t{0xD04, 0x40020403},\n\t{0xD08, 0x0002907F},\t{0xD0C, 0x20010201},\n\t{0xD10, 0x06288888},\t{0xD14, 0x8888367B},\n\t{0xD18, 0x7D806DB3},\t{0xD1C, 0x0000007F},\n\t{0xD20, 0x567600B8},\t{0xD24, 0x0000018B},\n\t{0xD28, 0xD513FF7D},\t{0xD2C, 0xCC979975},\n\t{0xD30, 0x04928000},\t{0xD34, 0x40608000},\n\t{0xD38, 0x88DDA000},\t{0xD3C, 0x00026EE2},\n\t{0xD50, 0x67270001},\t{0xD54, 0x20500000},\n\t{0xD58, 0x16161616},\t{0xD5C, 0x71F20064},\n\t{0xD60, 0x4653DA60},\t{0xD64, 0x3E718A3C},\n\t{0xD68, 0x00000183},\t{0xD7C, 0x00000000},\n\t{0xD80, 0x50000000},\t{0xD84, 0x31310400},\n\t{0xD88, 0xF5B50000},\t{0xD8C, 0x00000000},\n\t{0xD90, 0x00000000},\t{0xD94, 0x44BBBB44},\n\t{0xD98, 0x44BB44FF},\t{0xD9C, 0x06033688},\n\t{0xE00, 0x25252525},\t{0xE04, 0x25252525},\n\t{0xE08, 0x25252525},\t{0xE10, 0x25252525},\n\t{0xE14, 0x25252525},\t{0xE18, 0x25252525},\n\t{0xE1C, 0x25252525},\t{0xE20, 0x00000000},\n\t{0xE24, 0x00200000},\t{0xE28, 0x00000000},\n\t{0xE2C, 0x00000000},\t{0xE30, 0x01007C00},\n\t{0xE34, 0x01004800},\t{0xE38, 0x10008C0F},\n\t{0xE3C, 0x3C008C0F},\t{0xE40, 0x01007C00},\n\t{0xE44, 0x00000000},\t{0xE48, 0x00000000},\n\t{0xE4C, 0x00000000},\t{0xE50, 0x01007C00},\n\t{0xE54, 0x01004800},\t{0xE58, 0x10008C0F},\n\t{0xE5C, 0x3C008C0F},\t{0xE60, 0x02100000},\n\t{0xE64, 0xBBBBBBBB},\t{0xE68, 0x40404040},\n\t{0xE6C, 0x80408040},\t{0xE70, 0x80408040},\n\t{0xE74, 0x40404040},\t{0xE78, 0x00400040},\n\t{0xE7C, 0x40404040},\t{0xE80, 0x00FF0000},\n\t{0xE84, 0x80408040},\t{0xE88, 0x40404040},\n\t{0xE8C, 0x80408040},\t{0xED0, 0x80408040},\n\t{0xED4, 0x80408040},\t{0xED8, 0x80408040},\n\t{0xEDC, 0xC040C040},\t{0xEE0, 0xC040C040},\n\t{0xEE4, 0x00400040},\t{0xEE8, 0xD8001402},\n\t{0xEEC, 0xC0000120},\t{0xEF0, 0x02000B09},\n\t{0xEF4, 0x00000001},\t{0xEF8, 0x00000000},\n\t{0xF00, 0x00000300},\t{0xF04, 0x00000002},\n\t{0xF08, 0x00007D0C},\t{0xF0C, 0x0000A907},\n\t{0xF10, 0x00005807},\t{0xF14, 0x00000003},\n\t{0xF18, 0x07D003E8},\t{0xF1C, 0x8000001F},\n\t{0xF20, 0x00000000},\t{0xF24, 0x00000000},\n\t{0xF28, 0x00000000},\t{0xF2C, 0x00000000},\n\t{0xF30, 0x00000000},\t{0xF34, 0x00000000},\n\t{0xF38, 0x00030055},\t{0xF3C, 0x0000003A},\n\t{0xF40, 0x00000002},\t{0xF44, 0x00000000},\n\t{0xF48, 0x00000000},\t{0xF4C, 0x0B000000},\n\t{0xF50, 0x00000000},\n\t{0xffff, 0xffffffff},\n};\n\nstatic const struct rtl8xxxu_reg32val rtl8192f_agc_table[] = {\n\t{0xC78, 0x0FA0001F}, {0xC78, 0x0FA0011F},\n\t{0xC78, 0x0FA0021F}, {0xC78, 0x0FA0031F},\n\t{0xC78, 0x0FA0041F}, {0xC78, 0x0FA0051F},\n\t{0xC78, 0x0F90061F}, {0xC78, 0x0F80071F},\n\t{0xC78, 0x0F70081F}, {0xC78, 0x0F60091F},\n\t{0xC78, 0x0F500A1F}, {0xC78, 0x0F400B1F},\n\t{0xC78, 0x0F300C1F}, {0xC78, 0x0F200D1F},\n\t{0xC78, 0x0F100E1F}, {0xC78, 0x0F000F1F},\n\t{0xC78, 0x0EF0101F}, {0xC78, 0x0EE0111F},\n\t{0xC78, 0x0ED0121F}, {0xC78, 0x0EC0131F},\n\t{0xC78, 0x0EB0141F}, {0xC78, 0x0EA0151F},\n\t{0xC78, 0x0E90161F}, {0xC78, 0x0E80171F},\n\t{0xC78, 0x0E70181F}, {0xC78, 0x0E60191F},\n\t{0xC78, 0x0E501A1F}, {0xC78, 0x0E401B1F},\n\t{0xC78, 0x0E301C1F}, {0xC78, 0x0C701D1F},\n\t{0xC78, 0x0C601E1F}, {0xC78, 0x0C501F1F},\n\t{0xC78, 0x0C40201F}, {0xC78, 0x0C30211F},\n\t{0xC78, 0x0A60221F}, {0xC78, 0x0A50231F},\n\t{0xC78, 0x0A40241F}, {0xC78, 0x0A30251F},\n\t{0xC78, 0x0860261F}, {0xC78, 0x0850271F},\n\t{0xC78, 0x0840281F}, {0xC78, 0x0830291F},\n\t{0xC78, 0x06702A1F}, {0xC78, 0x06602B1F},\n\t{0xC78, 0x06502C1F}, {0xC78, 0x06402D1F},\n\t{0xC78, 0x06302E1F}, {0xC78, 0x04602F1F},\n\t{0xC78, 0x0450301F}, {0xC78, 0x0440311F},\n\t{0xC78, 0x0430321F}, {0xC78, 0x0260331F},\n\t{0xC78, 0x0250341F}, {0xC78, 0x0240351F},\n\t{0xC78, 0x0230361F}, {0xC78, 0x0050371F},\n\t{0xC78, 0x0040381F}, {0xC78, 0x0030391F},\n\t{0xC78, 0x00203A1F}, {0xC78, 0x00103B1F},\n\t{0xC78, 0x00003C1F}, {0xC78, 0x00003D1F},\n\t{0xC78, 0x00003E1F}, {0xC78, 0x00003F1F},\n\n\t{0xC78, 0x0FA0401F}, {0xC78, 0x0FA0411F},\n\t{0xC78, 0x0FA0421F}, {0xC78, 0x0FA0431F},\n\t{0xC78, 0x0F90441F}, {0xC78, 0x0F80451F},\n\t{0xC78, 0x0F70461F}, {0xC78, 0x0F60471F},\n\t{0xC78, 0x0F50481F}, {0xC78, 0x0F40491F},\n\t{0xC78, 0x0F304A1F}, {0xC78, 0x0F204B1F},\n\t{0xC78, 0x0F104C1F}, {0xC78, 0x0F004D1F},\n\t{0xC78, 0x0EF04E1F}, {0xC78, 0x0EE04F1F},\n\t{0xC78, 0x0ED0501F}, {0xC78, 0x0EC0511F},\n\t{0xC78, 0x0EB0521F}, {0xC78, 0x0EA0531F},\n\t{0xC78, 0x0E90541F}, {0xC78, 0x0E80551F},\n\t{0xC78, 0x0E70561F}, {0xC78, 0x0E60571F},\n\t{0xC78, 0x0E50581F}, {0xC78, 0x0E40591F},\n\t{0xC78, 0x0E305A1F}, {0xC78, 0x0E205B1F},\n\t{0xC78, 0x0E105C1F}, {0xC78, 0x0C505D1F},\n\t{0xC78, 0x0C405E1F}, {0xC78, 0x0C305F1F},\n\t{0xC78, 0x0C20601F}, {0xC78, 0x0C10611F},\n\t{0xC78, 0x0A40621F}, {0xC78, 0x0A30631F},\n\t{0xC78, 0x0A20641F}, {0xC78, 0x0A10651F},\n\t{0xC78, 0x0840661F}, {0xC78, 0x0830671F},\n\t{0xC78, 0x0820681F}, {0xC78, 0x0810691F},\n\t{0xC78, 0x06506A1F}, {0xC78, 0x06406B1F},\n\t{0xC78, 0x06306C1F}, {0xC78, 0x06206D1F},\n\t{0xC78, 0x06106E1F}, {0xC78, 0x04406F1F},\n\t{0xC78, 0x0430701F}, {0xC78, 0x0420711F},\n\t{0xC78, 0x0410721F}, {0xC78, 0x0240731F},\n\t{0xC78, 0x0230741F}, {0xC78, 0x0220751F},\n\t{0xC78, 0x0210761F}, {0xC78, 0x0030771F},\n\t{0xC78, 0x0020781F}, {0xC78, 0x0010791F},\n\t{0xC78, 0x00007A1F}, {0xC78, 0x00007B1F},\n\t{0xC78, 0x00007C1F}, {0xC78, 0x00007D1F},\n\t{0xC78, 0x00007E1F}, {0xC78, 0x00007F1F},\n\n\t{0xC78, 0x0FA0801F}, {0xC78, 0x0FA0811F},\n\t{0xC78, 0x0FA0821F}, {0xC78, 0x0FA0831F},\n\t{0xC78, 0x0FA0841F}, {0xC78, 0x0FA0851F},\n\t{0xC78, 0x0F90861F}, {0xC78, 0x0F80871F},\n\t{0xC78, 0x0F70881F}, {0xC78, 0x0F60891F},\n\t{0xC78, 0x0F508A1F}, {0xC78, 0x0F408B1F},\n\t{0xC78, 0x0F308C1F}, {0xC78, 0x0F208D1F},\n\t{0xC78, 0x0F108E1F}, {0xC78, 0x0B908F1F},\n\t{0xC78, 0x0B80901F}, {0xC78, 0x0B70911F},\n\t{0xC78, 0x0B60921F}, {0xC78, 0x0B50931F},\n\t{0xC78, 0x0B40941F}, {0xC78, 0x0B30951F},\n\t{0xC78, 0x0B20961F}, {0xC78, 0x0B10971F},\n\t{0xC78, 0x0B00981F}, {0xC78, 0x0AF0991F},\n\t{0xC78, 0x0AE09A1F}, {0xC78, 0x0AD09B1F},\n\t{0xC78, 0x0AC09C1F}, {0xC78, 0x0AB09D1F},\n\t{0xC78, 0x0AA09E1F}, {0xC78, 0x0A909F1F},\n\t{0xC78, 0x0A80A01F}, {0xC78, 0x0A70A11F},\n\t{0xC78, 0x0A60A21F}, {0xC78, 0x0A50A31F},\n\t{0xC78, 0x0A40A41F}, {0xC78, 0x0A30A51F},\n\t{0xC78, 0x0A20A61F}, {0xC78, 0x0A10A71F},\n\t{0xC78, 0x0A00A81F}, {0xC78, 0x0830A91F},\n\t{0xC78, 0x0820AA1F}, {0xC78, 0x0810AB1F},\n\t{0xC78, 0x0800AC1F}, {0xC78, 0x0640AD1F},\n\t{0xC78, 0x0630AE1F}, {0xC78, 0x0620AF1F},\n\t{0xC78, 0x0610B01F}, {0xC78, 0x0600B11F},\n\t{0xC78, 0x0430B21F}, {0xC78, 0x0420B31F},\n\t{0xC78, 0x0410B41F}, {0xC78, 0x0400B51F},\n\t{0xC78, 0x0230B61F}, {0xC78, 0x0220B71F},\n\t{0xC78, 0x0210B81F}, {0xC78, 0x0200B91F},\n\t{0xC78, 0x0000BA1F}, {0xC78, 0x0000BB1F},\n\t{0xC78, 0x0000BC1F}, {0xC78, 0x0000BD1F},\n\t{0xC78, 0x0000BE1F}, {0xC78, 0x0000BF1F},\n\t{0xC50, 0x00E48024}, {0xC50, 0x00E48020},\n\t{0xffff, 0xffffffff}\n};\n\nstatic const struct rtl8xxxu_rfregval rtl8192fu_radioa_init_table[] = {\n\t{0x00, 0x30000}, {0x18, 0x0FC07}, {0x81, 0x0FC00}, {0x82, 0x003C0},\n\t{0x84, 0x00005}, {0x86, 0xA33A5}, {0x87, 0x00000}, {0x88, 0x58010},\n\t{0x8E, 0x64540}, {0x8F, 0x282D8}, {0x51, 0x02C06}, {0x52, 0x7A007},\n\t{0x53, 0x10061}, {0x54, 0x60018}, {0x55, 0x82020}, {0x56, 0x08CC6},\n\t{0x57, 0x2CC00}, {0x58, 0x00000}, {0x5A, 0x50000}, {0x5B, 0x00006},\n\t{0x5C, 0x00015}, {0x65, 0x20000}, {0x6E, 0x38319}, {0xF5, 0x43180},\n\t{0xEF, 0x00002}, {0x33, 0x00301}, {0x33, 0x1032A}, {0x33, 0x2032A},\n\t{0xEF, 0x00000}, {0xDF, 0x00002}, {0x35, 0x00000}, {0xF0, 0x08008},\n\t{0xEF, 0x00800}, {0x33, 0x0040E}, {0x33, 0x04845}, {0x33, 0x08848},\n\t{0x33, 0x0C84B}, {0x33, 0x1088A}, {0x33, 0x14C50}, {0x33, 0x18C8E},\n\t{0x33, 0x1CCCD}, {0x33, 0x20CD0}, {0x33, 0x24CD3}, {0x33, 0x28CD6},\n\t{0x33, 0x4002B}, {0x33, 0x4402E}, {0x33, 0x48846}, {0x33, 0x4C849},\n\t{0x33, 0x50888}, {0x33, 0x54CC6}, {0x33, 0x58CC9}, {0x33, 0x5CCCC},\n\t{0x33, 0x60CCF}, {0x33, 0x64CD2}, {0x33, 0x68CD5}, {0xEF, 0x00000},\n\t{0xEF, 0x00400}, {0x33, 0x01C23}, {0x33, 0x05C23}, {0x33, 0x09D23},\n\t{0x33, 0x0DD23}, {0x33, 0x11FA3}, {0x33, 0x15FA3}, {0x33, 0x19FAB},\n\t{0x33, 0x1DFAB}, {0xEF, 0x00000}, {0xEF, 0x00200}, {0x33, 0x00030},\n\t{0x33, 0x04030}, {0x33, 0x08030}, {0x33, 0x0C030}, {0x33, 0x10030},\n\t{0x33, 0x14030}, {0x33, 0x18030}, {0x33, 0x1C030}, {0x33, 0x20030},\n\t{0x33, 0x24030}, {0x33, 0x28030}, {0x33, 0x2C030}, {0x33, 0x30030},\n\t{0x33, 0x34030}, {0x33, 0x38030}, {0x33, 0x3C030}, {0xEF, 0x00000},\n\t{0xEF, 0x00100}, {0x33, 0x44001}, {0x33, 0x48001}, {0x33, 0x4C001},\n\t{0x33, 0x50001}, {0x33, 0x54001}, {0x33, 0x58001}, {0x33, 0x5C001},\n\t{0x33, 0x60001}, {0x33, 0x64001}, {0x33, 0x68001}, {0x33, 0x6C001},\n\t{0x33, 0x70001}, {0x33, 0x74001}, {0x33, 0x78001}, {0x33, 0x04000},\n\t{0x33, 0x08000}, {0x33, 0x0C000}, {0x33, 0x10000}, {0x33, 0x14000},\n\t{0x33, 0x18001}, {0x33, 0x1C002}, {0x33, 0x20002}, {0x33, 0x24002},\n\t{0x33, 0x28002}, {0x33, 0x2C002}, {0x33, 0x30002}, {0x33, 0x34002},\n\t{0x33, 0x38002}, {0xEF, 0x00000}, {0x84, 0x00000}, {0xEF, 0x80010},\n\t{0x30, 0x20000}, {0x31, 0x0006F}, {0x32, 0x01FF7}, {0xEF, 0x00000},\n\t{0x84, 0x00000}, {0xEF, 0x80000}, {0x30, 0x30000}, {0x31, 0x0006F},\n\t{0x32, 0xF1DF3}, {0xEF, 0x00000}, {0x84, 0x00000}, {0xEF, 0x80000},\n\t{0x30, 0x38000}, {0x31, 0x0006F}, {0x32, 0xF1FF2}, {0xEF, 0x00000},\n\t{0x1B, 0x746CE}, {0xEF, 0x20000}, {0x33, 0x30000}, {0x33, 0x38000},\n\t{0x33, 0x70000}, {0x33, 0x78000}, {0xEF, 0x00000}, {0xDF, 0x08000},\n\t{0xB0, 0xFFBCB}, {0xB3, 0x06000}, {0xB7, 0x18DF0}, {0xB8, 0x38FF0},\n\t{0xC9, 0x00600}, {0xDF, 0x00000}, {0xB1, 0x33B8F}, {0xB2, 0x33762},\n\t{0xB4, 0x141F0}, {0xB5, 0x14080}, {0xB6, 0x12425}, {0xB9, 0xC0008},\n\t{0xBA, 0x40005}, {0xC2, 0x02C01}, {0xC3, 0x0000B}, {0xC4, 0x81E2F},\n\t{0xC5, 0x5C28F}, {0xC6, 0x000A0}, {0xCA, 0x02000}, {0xFE, 0x00000},\n\t{0x18, 0x08C07}, {0xFE, 0x00000}, {0xFE, 0x00000}, {0xFE, 0x00000},\n\t{0x00, 0x31DD5},\n\t{0xff, 0xffffffff}\n};\n\nstatic const struct rtl8xxxu_rfregval rtl8192fu_radiob_init_table[] = {\n\t{0x00, 0x30000}, {0x81, 0x0FC00}, {0x82, 0x003C0}, {0x84, 0x00005},\n\t{0x86, 0xA33A5}, {0x87, 0x00000}, {0x88, 0x58010}, {0x8E, 0x64540},\n\t{0x8F, 0x282D8}, {0x51, 0x02C06}, {0x52, 0x7A007}, {0x53, 0x10061},\n\t{0x54, 0x60018}, {0x55, 0x82020}, {0x56, 0x08CC6}, {0x57, 0x2CC00},\n\t{0x58, 0x00000}, {0x5A, 0x50000}, {0x5B, 0x00006}, {0x5C, 0x00015},\n\t{0x65, 0x20000}, {0x6E, 0x38319}, {0xF5, 0x43180}, {0xEF, 0x00002},\n\t{0x33, 0x00301}, {0x33, 0x1032A}, {0x33, 0x2032A}, {0xEF, 0x00000},\n\t{0xDF, 0x00002}, {0x35, 0x00000}, {0xF0, 0x08008}, {0xEF, 0x00800},\n\t{0x33, 0x0040E}, {0x33, 0x04845}, {0x33, 0x08848}, {0x33, 0x0C84B},\n\t{0x33, 0x1088A}, {0x33, 0x14CC8}, {0x33, 0x18CCB}, {0x33, 0x1CCCE},\n\t{0x33, 0x20CD1}, {0x33, 0x24CD4}, {0x33, 0x28CD7}, {0x33, 0x4002B},\n\t{0x33, 0x4402E}, {0x33, 0x48846}, {0x33, 0x4C849}, {0x33, 0x50888},\n\t{0x33, 0x54CC6}, {0x33, 0x58CC9}, {0x33, 0x5CCCC}, {0x33, 0x60CCF},\n\t{0x33, 0x64CD2}, {0x33, 0x68CD5}, {0xEF, 0x00000}, {0xEF, 0x00400},\n\t{0x33, 0x01D23}, {0x33, 0x05D23}, {0x33, 0x09FA3}, {0x33, 0x0DFA3},\n\t{0x33, 0x11D2B}, {0x33, 0x15D2B}, {0x33, 0x19FAB}, {0x33, 0x1DFAB},\n\t{0xEF, 0x00000}, {0xEF, 0x00200}, {0x33, 0x00030}, {0x33, 0x04030},\n\t{0x33, 0x08030}, {0x33, 0x0C030}, {0x33, 0x10030}, {0x33, 0x14030},\n\t{0x33, 0x18030}, {0x33, 0x1C030}, {0x33, 0x20030}, {0x33, 0x24030},\n\t{0x33, 0x28030}, {0x33, 0x2C030}, {0x33, 0x30030}, {0x33, 0x34030},\n\t{0x33, 0x38030}, {0x33, 0x3C030}, {0xEF, 0x00000}, {0xEF, 0x00100},\n\t{0x33, 0x44000}, {0x33, 0x48000}, {0x33, 0x4C000}, {0x33, 0x50000},\n\t{0x33, 0x54000}, {0x33, 0x58000}, {0x33, 0x5C000}, {0x33, 0x60000},\n\t{0x33, 0x64000}, {0x33, 0x68000}, {0x33, 0x6C000}, {0x33, 0x70000},\n\t{0x33, 0x74000}, {0x33, 0x78000}, {0x33, 0x04000}, {0x33, 0x08000},\n\t{0x33, 0x0C000}, {0x33, 0x10000}, {0x33, 0x14000}, {0x33, 0x18000},\n\t{0x33, 0x1C001}, {0x33, 0x20001}, {0x33, 0x24001}, {0x33, 0x28001},\n\t{0x33, 0x2C001}, {0x33, 0x30001}, {0x33, 0x34001}, {0x33, 0x38001},\n\t{0xEF, 0x00000}, {0x84, 0x00000}, {0xEF, 0x80010}, {0x30, 0x20000},\n\t{0x31, 0x0006F}, {0x32, 0x01FF7}, {0xEF, 0x00000}, {0x84, 0x00000},\n\t{0xEF, 0x80000}, {0x30, 0x30000}, {0x31, 0x0006F}, {0x32, 0xF1DF3},\n\t{0xEF, 0x00000}, {0x84, 0x00000}, {0xEF, 0x80000}, {0x30, 0x38000},\n\t{0x31, 0x0006F}, {0x32, 0xF1FF2}, {0xEF, 0x00000}, {0x1B, 0x746CE},\n\t{0xEF, 0x20000}, {0x33, 0x30000}, {0x33, 0x38000}, {0x33, 0x70000},\n\t{0x33, 0x78000}, {0xEF, 0x00000}, {0x00, 0x31DD5},\n\t{0xff, 0xffffffff}\n};\n\nstatic int rtl8192fu_identify_chip(struct rtl8xxxu_priv *priv)\n{\n\tstruct device *dev = &priv->udev->dev;\n\tu32 sys_cfg, vendor, val32;\n\n\tstrscpy(priv->chip_name, \"8192FU\", sizeof(priv->chip_name));\n\tpriv->rtl_chip = RTL8192F;\n\tpriv->rf_paths = 2;\n\tpriv->rx_paths = 2;\n\tpriv->tx_paths = 2;\n\n\tsys_cfg = rtl8xxxu_read32(priv, REG_SYS_CFG);\n\tpriv->chip_cut = u32_get_bits(sys_cfg, SYS_CFG_CHIP_VERSION_MASK);\n\tif (sys_cfg & SYS_CFG_TRP_VAUX_EN) {\n\t\tdev_info(dev, \"Unsupported test chip\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tval32 = rtl8xxxu_read32(priv, REG_MULTI_FUNC_CTRL);\n\tpriv->has_wifi = u32_get_bits(val32, MULTI_WIFI_FUNC_EN);\n\tpriv->has_bluetooth = u32_get_bits(val32, MULTI_BT_FUNC_EN);\n\tpriv->has_gps = u32_get_bits(val32, MULTI_GPS_FUNC_EN);\n\tpriv->is_multi_func = 1;\n\n\tvendor = sys_cfg & SYS_CFG_VENDOR_ID;\n\trtl8xxxu_identify_vendor_1bit(priv, vendor);\n\n\tval32 = rtl8xxxu_read32(priv, REG_GPIO_OUTSTS);\n\tpriv->rom_rev = u32_get_bits(val32, GPIO_RF_RL_ID);\n\n\treturn rtl8xxxu_config_endpoints_no_sie(priv);\n}\n\nstatic void\nrtl8192f_set_tx_power(struct rtl8xxxu_priv *priv, int channel, bool ht40)\n{\n\tu8 cck, ofdmbase, mcsbase;\n\tu32 val32, ofdm, mcs;\n\tint group, cck_group;\n\n\trtl8188f_channel_to_group(channel, &group, &cck_group);\n\n\tcck = priv->cck_tx_power_index_A[cck_group];\n\n\trtl8xxxu_write32_mask(priv, REG_TX_AGC_A_CCK1_MCS32, 0x00007f00, cck);\n\n\tval32 = (cck << 16) | (cck << 8) | cck;\n\trtl8xxxu_write32_mask(priv, REG_TX_AGC_B_CCK11_A_CCK2_11,\n\t\t\t      0x7f7f7f00, val32);\n\n\tofdmbase = priv->ht40_1s_tx_power_index_A[group];\n\tofdmbase += priv->ofdm_tx_power_diff[RF_A].a;\n\tofdm = ofdmbase | ofdmbase << 8 | ofdmbase << 16 | ofdmbase << 24;\n\n\trtl8xxxu_write32_mask(priv, REG_TX_AGC_A_RATE18_06, 0x7f7f7f7f, ofdm);\n\trtl8xxxu_write32_mask(priv, REG_TX_AGC_A_RATE54_24, 0x7f7f7f7f, ofdm);\n\n\tmcsbase = priv->ht40_1s_tx_power_index_A[group];\n\tif (ht40)\n\t\tmcsbase += priv->ht40_tx_power_diff[RF_A].a;\n\telse\n\t\tmcsbase += priv->ht20_tx_power_diff[RF_A].a;\n\tmcs = mcsbase | mcsbase << 8 | mcsbase << 16 | mcsbase << 24;\n\n\trtl8xxxu_write32_mask(priv, REG_TX_AGC_A_MCS03_MCS00, 0x7f7f7f7f, mcs);\n\trtl8xxxu_write32_mask(priv, REG_TX_AGC_A_MCS07_MCS04, 0x7f7f7f7f, mcs);\n\trtl8xxxu_write32_mask(priv, REG_TX_AGC_A_MCS11_MCS08, 0x7f7f7f7f, mcs);\n\trtl8xxxu_write32_mask(priv, REG_TX_AGC_A_MCS15_MCS12, 0x7f7f7f7f, mcs);\n\n\tif (priv->tx_paths == 1)\n\t\treturn;\n\n\tcck = priv->cck_tx_power_index_B[cck_group];\n\n\tval32 = (cck << 16) | (cck << 8) | cck;\n\trtl8xxxu_write32_mask(priv, REG_TX_AGC_B_CCK1_55_MCS32,\n\t\t\t      0x7f7f7f00, val32);\n\n\trtl8xxxu_write32_mask(priv, REG_TX_AGC_B_CCK11_A_CCK2_11,\n\t\t\t      0x0000007f, cck);\n\n\tofdmbase = priv->ht40_1s_tx_power_index_B[group];\n\tofdmbase += priv->ofdm_tx_power_diff[RF_B].b;\n\tofdm = ofdmbase | ofdmbase << 8 | ofdmbase << 16 | ofdmbase << 24;\n\n\trtl8xxxu_write32_mask(priv, REG_TX_AGC_B_RATE18_06, 0x7f7f7f7f, ofdm);\n\trtl8xxxu_write32_mask(priv, REG_TX_AGC_B_RATE54_24, 0x7f7f7f7f, ofdm);\n\n\tmcsbase = priv->ht40_1s_tx_power_index_B[group];\n\tif (ht40)\n\t\tmcsbase += priv->ht40_tx_power_diff[RF_B].b;\n\telse\n\t\tmcsbase += priv->ht20_tx_power_diff[RF_B].b;\n\tmcs = mcsbase | mcsbase << 8 | mcsbase << 16 | mcsbase << 24;\n\n\trtl8xxxu_write32_mask(priv, REG_TX_AGC_B_MCS03_MCS00, 0x7f7f7f7f, mcs);\n\trtl8xxxu_write32_mask(priv, REG_TX_AGC_B_MCS07_MCS04, 0x7f7f7f7f, mcs);\n\trtl8xxxu_write32_mask(priv, REG_TX_AGC_B_MCS11_MCS08, 0x7f7f7f7f, mcs);\n\trtl8xxxu_write32_mask(priv, REG_TX_AGC_B_MCS15_MCS12, 0x7f7f7f7f, mcs);\n}\n\nstatic void rtl8192f_revise_cck_tx_psf(struct rtl8xxxu_priv *priv, u8 channel)\n{\n\tif (channel == 13) {\n\t\t \n\t\trtl8xxxu_write32(priv, REG_CCK0_TX_FILTER1, 0xf8fe0001);\n\t\t \n\t\trtl8xxxu_write32(priv, REG_CCK0_TX_FILTER2, 0x64B80C1C);\n\t\trtl8xxxu_write16(priv, REG_CCK0_DEBUG_PORT, 0x8810);\n\t\trtl8xxxu_write32(priv, REG_CCK0_TX_FILTER3, 0x01235667);\n\t} else if (channel == 14) {\n\t\t \n\t\trtl8xxxu_write32(priv, REG_CCK0_TX_FILTER1, 0xE82C0001);\n\t\t \n\t\trtl8xxxu_write32(priv, REG_CCK0_TX_FILTER2, 0x0000B81C);\n\t\trtl8xxxu_write16(priv, REG_CCK0_DEBUG_PORT, 0x0000);\n\t\trtl8xxxu_write32(priv, REG_CCK0_TX_FILTER3, 0x00003667);\n\t} else {\n\t\t \n\t\trtl8xxxu_write32(priv, REG_CCK0_TX_FILTER1, 0xE82C0001);\n\t\trtl8xxxu_write32(priv, REG_CCK0_TX_FILTER2, 0x64B80C1C);\n\t\trtl8xxxu_write16(priv, REG_CCK0_DEBUG_PORT, 0x8810);\n\t\trtl8xxxu_write32(priv, REG_CCK0_TX_FILTER3, 0x01235667);\n\t}\n}\n\nstatic void rtl8192fu_config_kfree(struct rtl8xxxu_priv *priv, u8 channel)\n{\n\tu8 bb_gain[3] = { EFUSE_UNDEFINED, EFUSE_UNDEFINED, EFUSE_UNDEFINED };\n\tu8 bb_gain_path_mask[2] = { 0x0f, 0xf0 };\n\tenum rtl8xxxu_rfpath rfpath;\n\tu8 bb_gain_for_path;\n\tu8 channel_idx = 0;\n\n\tif (channel >= 1 && channel <= 3)\n\t\tchannel_idx = 0;\n\tif (channel >= 4 && channel <= 9)\n\t\tchannel_idx = 1;\n\tif (channel >= 10 && channel <= 14)\n\t\tchannel_idx = 2;\n\n\trtl8xxxu_read_efuse8(priv, 0x1ee, &bb_gain[1]);\n\trtl8xxxu_read_efuse8(priv, 0x1ec, &bb_gain[0]);\n\trtl8xxxu_read_efuse8(priv, 0x1ea, &bb_gain[2]);\n\n\tif (bb_gain[1] == EFUSE_UNDEFINED)\n\t\treturn;\n\n\tif (bb_gain[0] == EFUSE_UNDEFINED)\n\t\tbb_gain[0] = bb_gain[1];\n\n\tif (bb_gain[2] == EFUSE_UNDEFINED)\n\t\tbb_gain[2] = bb_gain[1];\n\n\tfor (rfpath = RF_A; rfpath < priv->rf_paths; rfpath++) {\n\t\t \n\t\trtl8xxxu_write_rfreg_mask(priv, rfpath, RF6052_REG_UNKNOWN_55,\n\t\t\t\t\t  BIT(5), 1);\n\n\t\t \n\t\trtl8xxxu_write_rfreg_mask(priv, rfpath, RF6052_REG_GAIN_CTRL,\n\t\t\t\t\t  BIT(18), 1);\n\n\t\t \n\t\trtl8xxxu_write_rfreg_mask(priv, rfpath, RF6052_REG_GAIN_CCA,\n\t\t\t\t\t  BIT(7), 1);\n\n\t\t \n\t\trtl8xxxu_write_rfreg_mask(priv, rfpath, RF6052_REG_WE_LUT, BIT(7), 1);\n\n\t\tbb_gain_for_path = (bb_gain[channel_idx] & bb_gain_path_mask[rfpath]);\n\t\tbb_gain_for_path >>= __ffs(bb_gain_path_mask[rfpath]);\n\n\t\trtl8xxxu_write_rfreg_mask(priv, rfpath, RF6052_REG_TXPA_G3,\n\t\t\t\t\t  0x70000, channel_idx * 2);\n\t\trtl8xxxu_write_rfreg_mask(priv, rfpath, RF6052_REG_TXPA_G3,\n\t\t\t\t\t  0x3f, bb_gain_for_path);\n\n\t\trtl8xxxu_write_rfreg_mask(priv, rfpath, RF6052_REG_TXPA_G3,\n\t\t\t\t\t  0x70000, channel_idx * 2 + 1);\n\t\trtl8xxxu_write_rfreg_mask(priv, rfpath, RF6052_REG_TXPA_G3,\n\t\t\t\t\t  0x3f, bb_gain_for_path);\n\n\t\t \n\t\trtl8xxxu_write_rfreg_mask(priv, rfpath, RF6052_REG_GAIN_CCA,\n\t\t\t\t\t  BIT(7), 0);\n\n\t\t \n\t\trtl8xxxu_write_rfreg_mask(priv, rfpath, RF6052_REG_WE_LUT, BIT(7), 0);\n\t}\n}\n\nstatic void rtl8192fu_config_channel(struct ieee80211_hw *hw)\n{\n\tstruct rtl8xxxu_priv *priv = hw->priv;\n\tbool ht40 = conf_is_ht40(&hw->conf);\n\tu8 channel, subchannel = 0;\n\tbool sec_ch_above = 0;\n\tu32 val32;\n\n\tchannel = (u8)hw->conf.chandef.chan->hw_value;\n\n\tif (conf_is_ht40_plus(&hw->conf)) {\n\t\tsec_ch_above = 1;\n\t\tchannel += 2;\n\t\tsubchannel = 2;\n\t} else if (conf_is_ht40_minus(&hw->conf)) {\n\t\tsec_ch_above = 0;\n\t\tchannel -= 2;\n\t\tsubchannel = 1;\n\t}\n\n\tval32 = rtl8xxxu_read_rfreg(priv, RF_A, RF6052_REG_MODE_AG);\n\n\trtl8192f_revise_cck_tx_psf(priv, channel);\n\n\t \n\tval32 &= ~(BIT(18) | BIT(17));  \n\tu32p_replace_bits(&val32, channel, 0xff);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_MODE_AG, val32);\n\tif (priv->rf_paths > 1)\n\t\trtl8xxxu_write_rfreg(priv, RF_B, RF6052_REG_MODE_AG, val32);\n\n\trtl8192fu_config_kfree(priv, channel);\n\n\trtl8xxxu_write8(priv, REG_DATA_SUBCHANNEL, subchannel);\n\n\t \n\trtl8xxxu_write32_clear(priv, REG_OFDM0_TX_PSDO_NOISE_WEIGHT, GENMASK(31, 30));\n\n\trtl8xxxu_write32_mask(priv, REG_FPGA0_RF_MODE, FPGA_RF_MODE, ht40);\n\trtl8xxxu_write32_mask(priv, REG_FPGA1_RF_MODE, FPGA_RF_MODE, ht40);\n\n\t \n\trtl8xxxu_write32_mask(priv, REG_FPGA0_RF_MODE, GENMASK(10, 8), 4);\n\n\t \n\trtl8xxxu_write32_mask(priv, REG_FPGA0_RF_MODE, BIT(13) | BIT(12), 2);\n\n\t \n\trtl8xxxu_write32_mask(priv, REG_ANTDIV_PARA1, BIT(27) | BIT(26), 2);\n\n\tif (ht40)\n\t\t \n\t\trtl8xxxu_write32_mask(priv, REG_CCK0_SYSTEM,\n\t\t\t\t      CCK0_SIDEBAND, !sec_ch_above);\n\n\t \n\trtl8xxxu_write32_set(priv, REG_FPGA0_RF_MODE, FPGA_RF_MODE_CCK);\n\n\t \n\tval32 = rtl8xxxu_read_rfreg(priv, RF_A, RF6052_REG_MODE_AG);\n\tval32 &= ~MODE_AG_BW_MASK;\n\tif (ht40)\n\t\tval32 |= MODE_AG_BW_40MHZ_8723B;\n\telse\n\t\tval32 |= MODE_AG_BW_20MHZ_8723B;\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_MODE_AG, val32);\n\tif (priv->rf_paths > 1)\n\t\trtl8xxxu_write_rfreg(priv, RF_B, RF6052_REG_MODE_AG, val32);\n\n\t \n\trtl8xxxu_write32_mask(priv, REG_TAP_UPD_97F, BIT(21) | BIT(20), 2);\n\n\trtl8xxxu_write32_mask(priv, REG_DOWNSAM_FACTOR, BIT(29) | BIT(28), 2);\n\n\tif (ht40)\n\t\tval32 = 0x3;\n\telse\n\t\tval32 = 0x1a3;\n\trtl8xxxu_write32_mask(priv, REG_RX_DFIR_MOD_97F, 0x1ff, val32);\n}\n\nstatic void rtl8192fu_init_aggregation(struct rtl8xxxu_priv *priv)\n{\n\tu32 agg_rx;\n\tu8 agg_ctrl;\n\n\t \n\tagg_ctrl = rtl8xxxu_read8(priv, REG_TRXDMA_CTRL);\n\tagg_ctrl &= ~TRXDMA_CTRL_RXDMA_AGG_EN;\n\n\tagg_rx = rtl8xxxu_read32(priv, REG_RXDMA_AGG_PG_TH);\n\tagg_rx &= ~RXDMA_USB_AGG_ENABLE;\n\tagg_rx &= ~0xFF0F;  \n\n\trtl8xxxu_write8(priv, REG_TRXDMA_CTRL, agg_ctrl);\n\trtl8xxxu_write32(priv, REG_RXDMA_AGG_PG_TH, agg_rx);\n}\n\nstatic int rtl8192fu_parse_efuse(struct rtl8xxxu_priv *priv)\n{\n\tstruct rtl8192fu_efuse *efuse = &priv->efuse_wifi.efuse8192fu;\n\tint i;\n\n\tif (efuse->rtl_id != cpu_to_le16(0x8129))\n\t\treturn -EINVAL;\n\n\tether_addr_copy(priv->mac_addr, efuse->mac_addr);\n\n\tmemcpy(priv->cck_tx_power_index_A, efuse->tx_power_index_A.cck_base,\n\t       sizeof(efuse->tx_power_index_A.cck_base));\n\tmemcpy(priv->cck_tx_power_index_B, efuse->tx_power_index_B.cck_base,\n\t       sizeof(efuse->tx_power_index_B.cck_base));\n\n\tmemcpy(priv->ht40_1s_tx_power_index_A,\n\t       efuse->tx_power_index_A.ht40_base,\n\t       sizeof(efuse->tx_power_index_A.ht40_base));\n\tmemcpy(priv->ht40_1s_tx_power_index_B,\n\t       efuse->tx_power_index_B.ht40_base,\n\t       sizeof(efuse->tx_power_index_B.ht40_base));\n\n\tpriv->ht20_tx_power_diff[0].a =\n\t\tefuse->tx_power_index_A.ht20_ofdm_1s_diff.b;\n\tpriv->ht20_tx_power_diff[0].b =\n\t\tefuse->tx_power_index_B.ht20_ofdm_1s_diff.b;\n\n\tpriv->ht40_tx_power_diff[0].a = 0;\n\tpriv->ht40_tx_power_diff[0].b = 0;\n\n\tfor (i = 1; i < RTL8723B_TX_COUNT; i++) {\n\t\tpriv->ofdm_tx_power_diff[i].a =\n\t\t\tefuse->tx_power_index_A.pwr_diff[i - 1].ofdm;\n\t\tpriv->ofdm_tx_power_diff[i].b =\n\t\t\tefuse->tx_power_index_B.pwr_diff[i - 1].ofdm;\n\n\t\tpriv->ht20_tx_power_diff[i].a =\n\t\t\tefuse->tx_power_index_A.pwr_diff[i - 1].ht20;\n\t\tpriv->ht20_tx_power_diff[i].b =\n\t\t\tefuse->tx_power_index_B.pwr_diff[i - 1].ht20;\n\n\t\tpriv->ht40_tx_power_diff[i].a =\n\t\t\tefuse->tx_power_index_A.pwr_diff[i - 1].ht40;\n\t\tpriv->ht40_tx_power_diff[i].b =\n\t\t\tefuse->tx_power_index_B.pwr_diff[i - 1].ht40;\n\t}\n\n\tpriv->default_crystal_cap = efuse->xtal_k & 0x3f;\n\n\tpriv->rfe_type = efuse->rfe_option & 0x1f;\n\n\tif (priv->rfe_type != 5 && priv->rfe_type != 1)\n\t\tdev_warn(&priv->udev->dev,\n\t\t\t \"%s: RFE type %d was not tested. Please send an email to linux-wireless@vger.kernel.org about this.\\n\",\n\t\t\t __func__, priv->rfe_type);\n\n\treturn 0;\n}\n\nstatic int rtl8192fu_load_firmware(struct rtl8xxxu_priv *priv)\n{\n\treturn rtl8xxxu_load_firmware(priv, \"rtlwifi/rtl8192fufw.bin\");\n}\n\nstatic void rtl8192fu_init_phy_bb(struct rtl8xxxu_priv *priv)\n{\n\t \n\trtl8xxxu_write16_set(priv, REG_SYS_FUNC,\n\t\t\t     SYS_FUNC_BBRSTB | SYS_FUNC_BB_GLB_RSTN);\n\n\trtl8xxxu_write8(priv, REG_RF_CTRL, RF_ENABLE | RF_RSTB | RF_SDMRSTB);\n\n\t \n\trtl8xxxu_write8(priv, REG_LDOHCI12_CTRL, 0xf);\n\trtl8xxxu_write8(priv, REG_SYS_SWR_CTRL2 + 1, 0xe9);\n\n\trtl8xxxu_init_phy_regs(priv, rtl8192fu_phy_init_table);\n\n\trtl8xxxu_init_phy_regs(priv, rtl8192f_agc_table);\n}\n\nstatic int rtl8192fu_init_phy_rf(struct rtl8xxxu_priv *priv)\n{\n\tint ret;\n\n\tret = rtl8xxxu_init_phy_rf(priv, rtl8192fu_radioa_init_table, RF_A);\n\tif (ret)\n\t\treturn ret;\n\n\treturn rtl8xxxu_init_phy_rf(priv, rtl8192fu_radiob_init_table, RF_B);\n}\n\nstatic void rtl8192f_phy_lc_calibrate(struct rtl8xxxu_priv *priv)\n{\n\tu32 backup_mask = BIT(31) | BIT(30);\n\tu32 backup;\n\tu32 val32;\n\n\t \n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_TX_PSDO_NOISE_WEIGHT);\n\tbackup = u32_get_bits(val32, backup_mask);\n\n\tu32p_replace_bits(&val32, 0, backup_mask);\n\trtl8xxxu_write32(priv, REG_OFDM0_TX_PSDO_NOISE_WEIGHT, val32);\n\n\trtl8188f_phy_lc_calibrate(priv);\n\n\t \n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_TX_PSDO_NOISE_WEIGHT);\n\tu32p_replace_bits(&val32, backup, backup_mask);\n\trtl8xxxu_write32(priv, REG_OFDM0_TX_PSDO_NOISE_WEIGHT, val32);\n\n\t \n\trtl8xxxu_write32_clear(priv, REG_FPGA0_RF_MODE, FPGA_RF_MODE_OFDM);\n\trtl8xxxu_write32_set(priv, REG_FPGA0_RF_MODE, FPGA_RF_MODE_OFDM);\n}\n\nstatic int rtl8192fu_iqk_path_a(struct rtl8xxxu_priv *priv)\n{\n\tu32 reg_eac, reg_e94, reg_e9c, val32;\n\tu32 rf_0x58_i, rf_0x58_q;\n\tu8 rfe = priv->rfe_type;\n\tint result = 0;\n\tint ktime, i;\n\n\t \n\trtl8xxxu_write32_mask(priv, REG_FPGA0_IQK, 0xffffff00, 0);\n\n\trtl8xxxu_write32(priv, REG_FPGA0_ANALOG4, 0xccf000c0);\n\trtl8xxxu_write32(priv, REG_ANAPWR1, 0x44ffbb44);\n\trtl8xxxu_write32(priv, REG_RX_WAIT_CCA, 0x00400040);\n\trtl8xxxu_write32(priv, REG_OFDM0_TRX_PATH_ENABLE, 0x6f005403);\n\trtl8xxxu_write32(priv, REG_OFDM0_TR_MUX_PAR, 0x000804e4);\n\trtl8xxxu_write32(priv, REG_FPGA0_XCD_RF_SW_CTRL, 0x04203400);\n\trtl8xxxu_write32(priv, REG_FPGA0_XA_HSSI_PARM1, 0x01000100);\n\n\trtl8xxxu_write_rfreg_mask(priv, RF_A, RF6052_REG_GAIN_CCA, BIT(4), 1);\n\trtl8xxxu_write_rfreg_mask(priv, RF_A, RF6052_REG_GAIN_CCA, BIT(11), 1);\n\tif (rfe == 7 || rfe == 8 || rfe == 9 || rfe == 12)\n\t\tval32 = 0x30;\n\telse\n\t\tval32 = 0xe9;\n\trtl8xxxu_write_rfreg_mask(priv, RF_A, RF6052_REG_PAD_TXG, 0x003ff, val32);\n\n\trtl8xxxu_write32_mask(priv, REG_FPGA0_IQK, 0xffffff00, 0x808000);\n\n\t \n\trtl8xxxu_write32(priv, REG_TX_IQK_TONE_A, 0x18008c1c);\n\trtl8xxxu_write32(priv, REG_RX_IQK_TONE_A, 0x38008c1c);\n\trtl8xxxu_write32(priv, REG_TX_IQK_TONE_B, 0x38008c1c);\n\trtl8xxxu_write32(priv, REG_RX_IQK_TONE_B, 0x38008c1c);\n\n\trtl8xxxu_write32(priv, REG_TX_IQK_PI_A, 0x8214000f);\n\trtl8xxxu_write32(priv, REG_RX_IQK_PI_A, 0x28140000);\n\n\trtl8xxxu_write32(priv, REG_TX_IQK, 0x01007c00);\n\trtl8xxxu_write32(priv, REG_RX_IQK, 0x01004800);\n\n\t \n\trtl8xxxu_write32(priv, REG_IQK_AGC_RSP, 0x00e62911);\n\n\t \n\trtl8xxxu_write32(priv, REG_IQK_AGC_PTS, 0xfa005800);\n\trtl8xxxu_write32(priv, REG_IQK_AGC_PTS, 0xf8005800);\n\n\tmdelay(15);\n\n\tktime = 0;\n\twhile (rtl8xxxu_read32(priv, REG_IQK_RPT_TXA) == 0 && ktime < 21) {\n\t\tmdelay(5);\n\t\tktime += 5;\n\t}\n\n\t \n\treg_eac = rtl8xxxu_read32(priv, REG_RX_POWER_AFTER_IQK_A_2);\n\treg_e94 = rtl8xxxu_read32(priv, REG_TX_POWER_BEFORE_IQK_A);\n\treg_e9c = rtl8xxxu_read32(priv, REG_TX_POWER_AFTER_IQK_A);\n\n\t \n\trtl8xxxu_write32_mask(priv, REG_FPGA0_IQK, 0xffffff00, 0);\n\n\trtl8xxxu_write_rfreg_mask(priv, RF_A, RF6052_REG_WE_LUT, BIT(4), 1);\n\n\tval32 = rtl8xxxu_read_rfreg(priv, RF_A, RF6052_REG_TXMOD);\n\trf_0x58_i = u32_get_bits(val32, 0xfc000);\n\trf_0x58_q = u32_get_bits(val32, 0x003f0);\n\n\tfor (i = 0; i < 8; i++) {\n\t\trtl8xxxu_write_rfreg_mask(priv, RF_A, RF6052_REG_TXPA_G3,\n\t\t\t\t\t  0x1c000, i);\n\t\trtl8xxxu_write_rfreg_mask(priv, RF_A, RF6052_REG_TXPA_G3,\n\t\t\t\t\t  0x00fc0, rf_0x58_i);\n\t\trtl8xxxu_write_rfreg_mask(priv, RF_A, RF6052_REG_TXPA_G3,\n\t\t\t\t\t  0x0003f, rf_0x58_q);\n\t}\n\n\trtl8xxxu_write_rfreg_mask(priv, RF_A, RF6052_REG_AC, BIT(14), 0);\n\trtl8xxxu_write_rfreg_mask(priv, RF_A, RF6052_REG_WE_LUT, BIT(4), 0);\n\trtl8xxxu_write_rfreg_mask(priv, RF_A, RF6052_REG_GAIN_CCA, 0x00810, 0);\n\n\tif (!(reg_eac & BIT(28)) &&\n\t    ((reg_e94 & 0x03ff0000) != 0x01420000) &&\n\t    ((reg_e9c & 0x03ff0000) != 0x00420000))\n\t\tresult |= 0x01;\n\n\treturn result;\n}\n\nstatic int rtl8192fu_rx_iqk_path_a(struct rtl8xxxu_priv *priv)\n{\n\tu32 reg_ea4, reg_eac, reg_e94, reg_e9c, val32;\n\tint result = 0;\n\tint ktime;\n\n\t \n\trtl8xxxu_write32_mask(priv, REG_FPGA0_IQK, 0xffffff00, 0);\n\n\t \n\trtl8xxxu_write_rfreg_mask(priv, RF_A, RF6052_REG_GAIN_CCA, BIT(1), 1);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_GAIN_P1, 0);\n\trtl8xxxu_write_rfreg_mask(priv, RF_A, RF6052_REG_GAIN_CCA, BIT(11), 1);\n\trtl8xxxu_write_rfreg_mask(priv, RF_A, RF6052_REG_PAD_TXG, 0x003ff, 0x27);\n\n\t \n\trtl8xxxu_write32_mask(priv, REG_FPGA0_IQK, 0xffffff00, 0x808000);\n\n\t \n\trtl8xxxu_write32(priv, REG_TX_IQK_TONE_A, 0x18008c1c);\n\trtl8xxxu_write32(priv, REG_RX_IQK_TONE_A, 0x38008c1c);\n\trtl8xxxu_write32(priv, REG_TX_IQK_TONE_B, 0x38008c1c);\n\trtl8xxxu_write32(priv, REG_RX_IQK_TONE_B, 0x38008c1c);\n\n\trtl8xxxu_write32(priv, REG_TX_IQK_PI_A, 0x82160027);\n\trtl8xxxu_write32(priv, REG_RX_IQK_PI_A, 0x28160000);\n\n\t \n\trtl8xxxu_write32(priv, REG_TX_IQK, 0x01007c00);\n\trtl8xxxu_write32(priv, REG_RX_IQK, 0x01004800);\n\n\t \n\trtl8xxxu_write32(priv, REG_IQK_AGC_RSP, 0x0086a911);\n\n\t \n\trtl8xxxu_write32(priv, REG_IQK_AGC_PTS, 0xfa005800);\n\trtl8xxxu_write32(priv, REG_IQK_AGC_PTS, 0xf8005800);\n\n\tmdelay(15);\n\n\tktime = 0;\n\twhile (rtl8xxxu_read32(priv, REG_IQK_RPT_TXA) == 0 && ktime < 21) {\n\t\tmdelay(5);\n\t\tktime += 5;\n\t}\n\n\t \n\treg_eac = rtl8xxxu_read32(priv, REG_RX_POWER_AFTER_IQK_A_2);\n\treg_e94 = rtl8xxxu_read32(priv, REG_TX_POWER_BEFORE_IQK_A);\n\treg_e9c = rtl8xxxu_read32(priv, REG_TX_POWER_AFTER_IQK_A);\n\n\tif (!(reg_eac & BIT(28)) &&\n\t    ((reg_e94 & 0x03ff0000) != 0x01420000) &&\n\t    ((reg_e9c & 0x03ff0000) != 0x00420000)) {\n\t\tresult |= 0x01;\n\t} else {  \n\t\t \n\t\trtl8xxxu_write32_mask(priv, REG_FPGA0_IQK, 0xffffff00, 0);\n\n\t\trtl8xxxu_write_rfreg_mask(priv, RF_A, RF6052_REG_GAIN_CCA,\n\t\t\t\t\t  BIT(11), 0);\n\n\t\treturn result;\n\t}\n\n\tval32 = 0x80007c00 | (reg_e94 & 0x3ff0000) | ((reg_e9c & 0x3ff0000) >> 16);\n\trtl8xxxu_write32(priv, REG_TX_IQK, val32);\n\n\t \n\trtl8xxxu_write32_mask(priv, REG_FPGA0_IQK, 0xffffff00, 0);\n\n\t \n\trtl8xxxu_write_rfreg_mask(priv, RF_A, RF6052_REG_GAIN_CCA, BIT(1), 1);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_GAIN_P1, 0);\n\trtl8xxxu_write_rfreg_mask(priv, RF_A, RF6052_REG_GAIN_CCA, BIT(11), 1);\n\trtl8xxxu_write_rfreg_mask(priv, RF_A, RF6052_REG_PAD_TXG, 0x003ff, 0x1e0);\n\n\trtl8xxxu_write32(priv, REG_FPGA0_ANALOG4, 0xccf000c0);\n\trtl8xxxu_write32(priv, REG_ANAPWR1, 0x44ffbb44);\n\trtl8xxxu_write32(priv, REG_RX_WAIT_CCA, 0x00400040);\n\trtl8xxxu_write32(priv, REG_OFDM0_TRX_PATH_ENABLE, 0x6f005403);\n\trtl8xxxu_write32(priv, REG_OFDM0_TR_MUX_PAR, 0x000804e4);\n\trtl8xxxu_write32(priv, REG_FPGA0_XCD_RF_SW_CTRL, 0x04203400);\n\trtl8xxxu_write32(priv, REG_FPGA0_XA_HSSI_PARM1, 0x01000100);\n\n\t \n\trtl8xxxu_write32_mask(priv, REG_FPGA0_IQK, 0xffffff00, 0x808000);\n\n\t \n\trtl8xxxu_write32(priv, REG_TX_IQK_TONE_A, 0x38008c1c);\n\trtl8xxxu_write32(priv, REG_RX_IQK_TONE_A, 0x18008c1c);\n\trtl8xxxu_write32(priv, REG_TX_IQK_TONE_B, 0x38008c1c);\n\trtl8xxxu_write32(priv, REG_RX_IQK_TONE_B, 0x38008c1c);\n\n\trtl8xxxu_write32(priv, REG_TX_IQK_PI_A, 0x82170000);\n\trtl8xxxu_write32(priv, REG_RX_IQK_PI_A, 0x28170000);\n\n\t \n\trtl8xxxu_write32(priv, REG_RX_IQK, 0x01004800);\n\n\t \n\trtl8xxxu_write32(priv, REG_IQK_AGC_RSP, 0x0046a8d1);\n\n\t \n\trtl8xxxu_write32(priv, REG_IQK_AGC_PTS, 0xfa005800);\n\trtl8xxxu_write32(priv, REG_IQK_AGC_PTS, 0xf8005800);\n\n\tmdelay(15);\n\n\tktime = 0;\n\twhile (rtl8xxxu_read32(priv, REG_IQK_RPT_RXA) == 0 && ktime < 21) {\n\t\tmdelay(5);\n\t\tktime += 5;\n\t}\n\n\t \n\treg_eac = rtl8xxxu_read32(priv, REG_RX_POWER_AFTER_IQK_A_2);\n\treg_ea4 = rtl8xxxu_read32(priv, REG_RX_POWER_BEFORE_IQK_A_2);\n\n\t \n\trtl8xxxu_write32_mask(priv, REG_FPGA0_IQK, 0xffffff00, 0);\n\n\trtl8xxxu_write_rfreg_mask(priv, RF_A, RF6052_REG_GAIN_CCA, BIT(11), 0);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_GAIN_P1, 0x02000);\n\n\tif (!(reg_eac & BIT(27)) &&\n\t    ((reg_ea4 & 0x03ff0000) != 0x01320000) &&\n\t    ((reg_eac & 0x03ff0000) != 0x00360000))\n\t\tresult |= 0x02;\n\n\treturn result;\n}\n\nstatic int rtl8192fu_iqk_path_b(struct rtl8xxxu_priv *priv)\n{\n\tu32 reg_eac, reg_eb4, reg_ebc, val32;\n\tu32 rf_0x58_i, rf_0x58_q;\n\tu8 rfe = priv->rfe_type;\n\tint result = 0;\n\tint ktime, i;\n\n\t \n\trtl8xxxu_write32_mask(priv, REG_FPGA0_IQK, 0xffffff00, 0);\n\n\trtl8xxxu_write32(priv, REG_FPGA0_ANALOG4, 0xccf000c0);\n\trtl8xxxu_write32(priv, REG_ANAPWR1, 0x44ffbb44);\n\trtl8xxxu_write32(priv, REG_RX_WAIT_CCA, 0x00400040);\n\trtl8xxxu_write32(priv, REG_OFDM0_TRX_PATH_ENABLE, 0x6f005403);\n\trtl8xxxu_write32(priv, REG_OFDM0_TR_MUX_PAR, 0x000804e4);\n\trtl8xxxu_write32(priv, REG_FPGA0_XCD_RF_SW_CTRL, 0x04203400);\n\trtl8xxxu_write32(priv, REG_FPGA0_XA_HSSI_PARM1, 0x01000000);\n\n\trtl8xxxu_write_rfreg_mask(priv, RF_B, RF6052_REG_GAIN_CCA, BIT(4), 1);\n\trtl8xxxu_write_rfreg_mask(priv, RF_B, RF6052_REG_GAIN_CCA, BIT(11), 1);\n\tif (rfe == 7 || rfe == 8 || rfe == 9 || rfe == 12)\n\t\trtl8xxxu_write_rfreg_mask(priv, RF_B, RF6052_REG_PAD_TXG,\n\t\t\t\t\t  0x003ff, 0x30);\n\telse\n\t\trtl8xxxu_write_rfreg_mask(priv, RF_B, RF6052_REG_PAD_TXG,\n\t\t\t\t\t  0x00fff, 0xe9);\n\n\trtl8xxxu_write32_mask(priv, REG_FPGA0_IQK, 0xffffff00, 0x808000);\n\n\t \n\trtl8xxxu_write32(priv, REG_TX_IQK_TONE_A, 0x38008c1c);\n\trtl8xxxu_write32(priv, REG_RX_IQK_TONE_A, 0x38008c1c);\n\trtl8xxxu_write32(priv, REG_TX_IQK_TONE_B, 0x18008c1c);\n\trtl8xxxu_write32(priv, REG_RX_IQK_TONE_B, 0x38008c1c);\n\n\trtl8xxxu_write32(priv, REG_TX_IQK_PI_B, 0x8214000F);\n\trtl8xxxu_write32(priv, REG_RX_IQK_PI_B, 0x28140000);\n\n\trtl8xxxu_write32(priv, REG_TX_IQK, 0x01007c00);\n\trtl8xxxu_write32(priv, REG_RX_IQK, 0x01004800);\n\n\t \n\trtl8xxxu_write32(priv, REG_IQK_AGC_RSP, 0x00e62911);\n\n\t \n\trtl8xxxu_write32(priv, REG_IQK_AGC_PTS, 0xfa005800);\n\trtl8xxxu_write32(priv, REG_IQK_AGC_PTS, 0xf8005800);\n\n\tmdelay(15);\n\n\tktime = 0;\n\twhile (rtl8xxxu_read32(priv, REG_IQK_RPT_TXB) == 0 && ktime < 21) {\n\t\tmdelay(5);\n\t\tktime += 5;\n\t}\n\n\t \n\treg_eac = rtl8xxxu_read32(priv, REG_RX_POWER_AFTER_IQK_A_2);\n\treg_eb4 = rtl8xxxu_read32(priv, REG_TX_POWER_BEFORE_IQK_B);\n\treg_ebc = rtl8xxxu_read32(priv, REG_TX_POWER_AFTER_IQK_B);\n\n\t \n\trtl8xxxu_write32_mask(priv, REG_FPGA0_IQK, 0xffffff00, 0);\n\n\trtl8xxxu_write_rfreg_mask(priv, RF_B, RF6052_REG_WE_LUT, BIT(4), 1);\n\n\tval32 = rtl8xxxu_read_rfreg(priv, RF_B, RF6052_REG_TXMOD);\n\trf_0x58_i = u32_get_bits(val32, 0xfc000);\n\trf_0x58_q = u32_get_bits(val32, 0x003f0);\n\n\tfor (i = 0; i < 8; i++) {\n\t\trtl8xxxu_write_rfreg_mask(priv, RF_B, RF6052_REG_TXPA_G3,\n\t\t\t\t\t  0x1c000, i);\n\t\trtl8xxxu_write_rfreg_mask(priv, RF_B, RF6052_REG_TXPA_G3,\n\t\t\t\t\t  0x00fc0, rf_0x58_i);\n\t\trtl8xxxu_write_rfreg_mask(priv, RF_B, RF6052_REG_TXPA_G3,\n\t\t\t\t\t  0x0003f, rf_0x58_q);\n\t}\n\n\trtl8xxxu_write_rfreg_mask(priv, RF_B, RF6052_REG_AC, BIT(14), 0);\n\trtl8xxxu_write_rfreg_mask(priv, RF_B, RF6052_REG_WE_LUT, BIT(4), 0);\n\trtl8xxxu_write_rfreg_mask(priv, RF_B, RF6052_REG_GAIN_CCA, 0x00810, 0);\n\n\tif (!(reg_eac & BIT(31)) &&\n\t    ((reg_eb4 & 0x03ff0000) != 0x01420000) &&\n\t    ((reg_ebc & 0x03ff0000) != 0x00420000))\n\t\tresult |= 0x01;\n\telse\n\t\tdev_warn(&priv->udev->dev, \"%s: Path B IQK failed!\\n\",\n\t\t\t __func__);\n\n\treturn result;\n}\n\nstatic int rtl8192fu_rx_iqk_path_b(struct rtl8xxxu_priv *priv)\n{\n\tu32 reg_eac, reg_eb4, reg_ebc, reg_ec4, reg_ecc, val32;\n\tint result = 0;\n\tint ktime;\n\n\t \n\trtl8xxxu_write32_mask(priv, REG_FPGA0_IQK, 0xffffff00, 0);\n\n\trtl8xxxu_write_rfreg_mask(priv, RF_B, RF6052_REG_GAIN_CCA, BIT(1), 1);\n\trtl8xxxu_write_rfreg(priv, RF_B, RF6052_REG_GAIN_P1, 0);\n\trtl8xxxu_write_rfreg_mask(priv, RF_B, RF6052_REG_GAIN_CCA, BIT(11), 1);\n\trtl8xxxu_write_rfreg_mask(priv, RF_B, RF6052_REG_PAD_TXG, 0x003ff, 0x67);\n\n\trtl8xxxu_write32(priv, REG_FPGA0_ANALOG4, 0xccf000c0);\n\trtl8xxxu_write32(priv, REG_ANAPWR1, 0x44ffbb44);\n\trtl8xxxu_write32(priv, REG_RX_WAIT_CCA, 0x00400040);\n\trtl8xxxu_write32(priv, REG_OFDM0_TRX_PATH_ENABLE, 0x6f005403);\n\trtl8xxxu_write32(priv, REG_OFDM0_TR_MUX_PAR, 0x000804e4);\n\trtl8xxxu_write32(priv, REG_FPGA0_XCD_RF_SW_CTRL, 0x04203400);\n\trtl8xxxu_write32(priv, REG_FPGA0_XA_HSSI_PARM1, 0x01000000);\n\n\trtl8xxxu_write32_mask(priv, REG_FPGA0_IQK, 0xffffff00, 0x808000);\n\n\t \n\trtl8xxxu_write32(priv, REG_TX_IQK_TONE_A, 0x38008c1c);\n\trtl8xxxu_write32(priv, REG_RX_IQK_TONE_A, 0x38008c1c);\n\trtl8xxxu_write32(priv, REG_TX_IQK_TONE_B, 0x18008c1c);\n\trtl8xxxu_write32(priv, REG_RX_IQK_TONE_B, 0x38008c1c);\n\n\trtl8xxxu_write32(priv, REG_TX_IQK_PI_B, 0x82160027);\n\trtl8xxxu_write32(priv, REG_RX_IQK_PI_B, 0x28160000);\n\n\t \n\trtl8xxxu_write32(priv, REG_IQK_AGC_RSP, 0x0086a911);\n\n\t \n\trtl8xxxu_write32(priv, REG_IQK_AGC_PTS, 0xfa005800);\n\trtl8xxxu_write32(priv, REG_IQK_AGC_PTS, 0xf8005800);\n\n\tmdelay(15);\n\n\tktime = 0;\n\twhile (rtl8xxxu_read32(priv, REG_IQK_RPT_TXB) == 0 && ktime < 21) {\n\t\tmdelay(5);\n\t\tktime += 5;\n\t}\n\n\t \n\treg_eac = rtl8xxxu_read32(priv, REG_RX_POWER_AFTER_IQK_A_2);\n\treg_eb4 = rtl8xxxu_read32(priv, REG_TX_POWER_BEFORE_IQK_B);\n\treg_ebc = rtl8xxxu_read32(priv, REG_TX_POWER_AFTER_IQK_B);\n\n\tif (!(reg_eac & BIT(31)) &&\n\t    ((reg_eb4 & 0x03ff0000) != 0x01420000) &&\n\t    ((reg_ebc & 0x03ff0000) != 0x00420000)) {\n\t\tresult |= 0x01;\n\t} else {\n\t\t \n\t\trtl8xxxu_write32_mask(priv, REG_FPGA0_IQK, 0xffffff00, 0);\n\n\t\trtl8xxxu_write_rfreg_mask(priv, RF_B, RF6052_REG_GAIN_CCA,\n\t\t\t\t\t  BIT(11), 0);\n\n\t\treturn result;\n\t}\n\n\tval32 = 0x80007c00 | (reg_eb4 & 0x03ff0000) | ((reg_ebc >> 16) & 0x03ff);\n\trtl8xxxu_write32(priv, REG_TX_IQK, val32);\n\n\t \n\trtl8xxxu_write32_mask(priv, REG_FPGA0_IQK, 0xffffff00, 0);\n\n\trtl8xxxu_write_rfreg_mask(priv, RF_B, RF6052_REG_GAIN_CCA, BIT(1), 1);\n\trtl8xxxu_write_rfreg(priv, RF_B, RF6052_REG_GAIN_P1, 0);\n\trtl8xxxu_write_rfreg_mask(priv, RF_B, RF6052_REG_GAIN_CCA, BIT(11), 1);\n\trtl8xxxu_write_rfreg_mask(priv, RF_B, RF6052_REG_PAD_TXG, 0x003ff, 0x1e0);\n\n\trtl8xxxu_write32(priv, REG_FPGA0_ANALOG4, 0xccf000c0);\n\trtl8xxxu_write32(priv, REG_ANAPWR1, 0x44ffbb44);\n\trtl8xxxu_write32(priv, REG_RX_WAIT_CCA, 0x00400040);\n\trtl8xxxu_write32(priv, REG_OFDM0_TRX_PATH_ENABLE, 0x6f005403);\n\trtl8xxxu_write32(priv, REG_OFDM0_TR_MUX_PAR, 0x000804e4);\n\trtl8xxxu_write32(priv, REG_FPGA0_XCD_RF_SW_CTRL, 0x04203400);\n\trtl8xxxu_write32(priv, REG_FPGA0_XA_HSSI_PARM1, 0x01000000);\n\n\trtl8xxxu_write32_mask(priv, REG_FPGA0_IQK, 0xffffff00, 0x808000);\n\n\t \n\trtl8xxxu_write32(priv, REG_TX_IQK_TONE_A, 0x38008c1c);\n\trtl8xxxu_write32(priv, REG_RX_IQK_TONE_A, 0x38008c1c);\n\trtl8xxxu_write32(priv, REG_TX_IQK_TONE_B, 0x38008c1c);\n\trtl8xxxu_write32(priv, REG_RX_IQK_TONE_B, 0x18008c1c);\n\n\trtl8xxxu_write32(priv, REG_TX_IQK_PI_B, 0x82170000);\n\trtl8xxxu_write32(priv, REG_RX_IQK_PI_B, 0x28170000);\n\n\t \n\trtl8xxxu_write32(priv, REG_RX_IQK, 0x01004800);\n\n\t \n\trtl8xxxu_write32(priv, REG_IQK_AGC_RSP, 0x0046a911);\n\n\t \n\trtl8xxxu_write32(priv, REG_IQK_AGC_PTS, 0xfa005800);\n\trtl8xxxu_write32(priv, REG_IQK_AGC_PTS, 0xf8005800);\n\n\tmdelay(15);\n\n\tktime = 0;\n\twhile (rtl8xxxu_read32(priv, REG_IQK_RPT_RXB) == 0 && ktime < 21) {\n\t\tmdelay(5);\n\t\tktime += 5;\n\t}\n\n\treg_eac = rtl8xxxu_read32(priv, REG_RX_POWER_AFTER_IQK_A_2);\n\treg_ec4 = rtl8xxxu_read32(priv, REG_RX_POWER_BEFORE_IQK_B_2);\n\treg_ecc = rtl8xxxu_read32(priv, REG_RX_POWER_AFTER_IQK_B_2);\n\n\trtl8xxxu_write32_mask(priv, REG_FPGA0_IQK, 0xffffff00, 0);\n\trtl8xxxu_write32(priv, REG_FPGA0_XA_HSSI_PARM1, 0x01000100);\n\n\trtl8xxxu_write_rfreg_mask(priv, RF_B, RF6052_REG_GAIN_CCA, BIT(11), 0);\n\trtl8xxxu_write_rfreg_mask(priv, RF_B, RF6052_REG_GAIN_CCA, BIT(1), 0);\n\trtl8xxxu_write_rfreg(priv, RF_B, RF6052_REG_GAIN_P1, 0x02000);\n\n\tif (!(reg_eac & BIT(30)) &&\n\t    ((reg_ec4 & 0x03ff0000) != 0x01320000) &&\n\t    ((reg_ecc & 0x03ff0000) != 0x00360000))\n\t\tresult |= 0x02;\n\telse\n\t\tdev_warn(&priv->udev->dev, \"%s: Path B RX IQK failed!\\n\",\n\t\t\t __func__);\n\n\treturn result;\n}\n\nstatic void rtl8192fu_phy_iqcalibrate(struct rtl8xxxu_priv *priv,\n\t\t\t\t      int result[][8], int t)\n{\n\tstatic const u32 adda_regs[2] = {\n\t\tREG_ANAPWR1, REG_RX_WAIT_CCA\n\t};\n\tstatic const u32 iqk_mac_regs[RTL8XXXU_MAC_REGS] = {\n\t\tREG_TXPAUSE, REG_BEACON_CTRL,\n\t\tREG_BEACON_CTRL_1, REG_GPIO_MUXCFG\n\t};\n\tstatic const u32 iqk_bb_regs[RTL8XXXU_BB_REGS] = {\n\t\tREG_OFDM0_TRX_PATH_ENABLE, REG_OFDM0_TR_MUX_PAR,\n\t\tREG_FPGA0_XCD_RF_SW_CTRL, REG_CONFIG_ANT_A, REG_CONFIG_ANT_B,\n\t\tREG_DPDT_CTRL, REG_RFE_CTRL_ANTA_SRC,\n\t\tREG_RFE_CTRL_ANT_SRC2, REG_CCK0_AFE_SETTING\n\t};\n\tu32 rx_initial_gain_a, rx_initial_gain_b;\n\tstruct device *dev = &priv->udev->dev;\n\tint path_a_ok, path_b_ok;\n\tu8 rfe = priv->rfe_type;\n\tint retry = 2;\n\tu32 i, val32;\n\n\t \n\n\trtl8xxxu_write32_mask(priv, REG_FPGA0_IQK, 0xffffff00, 0);\n\n\trx_initial_gain_a = rtl8xxxu_read32(priv, REG_OFDM0_XA_AGC_CORE1);\n\trx_initial_gain_b = rtl8xxxu_read32(priv, REG_OFDM0_XB_AGC_CORE1);\n\n\tif (t == 0) {\n\t\t \n\t\trtl8xxxu_save_regs(priv, adda_regs, priv->adda_backup,\n\t\t\t\t   ARRAY_SIZE(adda_regs));\n\t\trtl8xxxu_save_mac_regs(priv, iqk_mac_regs, priv->mac_backup);\n\t\trtl8xxxu_save_regs(priv, iqk_bb_regs,\n\t\t\t\t   priv->bb_backup, RTL8XXXU_BB_REGS);\n\t}\n\n\t \n\trtl8xxxu_write32_set(priv, REG_FPGA0_XCD_RF_PARM, BIT(31));\n\n\t \n\trtl8xxxu_write8(priv, REG_TXPAUSE, 0xff);\n\trtl8xxxu_write8_clear(priv, REG_GPIO_MUXCFG, GPIO_MUXCFG_IO_SEL_ENBT);\n\n\tif (rfe == 7 || rfe == 8 || rfe == 9 || rfe == 12) {\n\t\t \n\t\t \n\t\trtl8xxxu_write32_mask(priv, REG_RFE_CTRL_ANTA_SRC, 0xF, 0x7);\n\t\trtl8xxxu_write32_mask(priv, REG_DPDT_CTRL, 0x1, 0x0);\n\n\t\trtl8xxxu_write32_mask(priv, REG_RFE_CTRL_ANTA_SRC, 0xF00, 0x7);\n\t\trtl8xxxu_write32_mask(priv, REG_DPDT_CTRL, 0x4, 0x0);\n\n\t\trtl8xxxu_write32_mask(priv, REG_RFE_CTRL_ANTA_SRC, 0xF000, 0x7);\n\t\trtl8xxxu_write32_mask(priv, REG_DPDT_CTRL, 0x8, 0x0);\n\n\t\t \n\t\trtl8xxxu_write32_mask(priv, REG_RFE_CTRL_ANT_SRC2, 0xF0, 0x7);\n\t\trtl8xxxu_write32_mask(priv, REG_DPDT_CTRL, 0x20000, 0x0);\n\n\t\trtl8xxxu_write32_mask(priv, REG_RFE_CTRL_ANT_SRC2, 0xF0000, 0x7);\n\t\trtl8xxxu_write32_mask(priv, REG_DPDT_CTRL, 0x100000, 0x0);\n\n\t\trtl8xxxu_write32_mask(priv, REG_RFE_CTRL_ANT_SRC3, 0xF000, 0x7);\n\t\trtl8xxxu_write32_mask(priv, REG_DPDT_CTRL, 0x8000000, 0x0);\n\t}\n\n\tif (priv->rf_paths > 1) {\n\t\t \n\t\trtl8xxxu_write32_mask(priv, REG_FPGA0_IQK, 0xffffff00, 0x000000);\n\t\trtl8xxxu_write_rfreg(priv, RF_B, RF6052_REG_AC, 0x10000);\n\t\trtl8xxxu_write32_mask(priv, REG_FPGA0_IQK, 0xffffff00, 0x808000);\n\t}\n\n\tfor (i = 0; i < retry; i++) {\n\t\tpath_a_ok = rtl8192fu_iqk_path_a(priv);\n\n\t\tif (path_a_ok == 0x01) {\n\t\t\tval32 = rtl8xxxu_read32(priv, REG_TX_POWER_BEFORE_IQK_A);\n\t\t\tresult[t][0] = (val32 >> 16) & 0x3ff;\n\n\t\t\tval32 = rtl8xxxu_read32(priv, REG_TX_POWER_AFTER_IQK_A);\n\t\t\tresult[t][1] = (val32 >> 16) & 0x3ff;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tresult[t][0] = 0x100;\n\t\t\tresult[t][1] = 0x0;\n\t\t}\n\t}\n\n\tfor (i = 0; i < retry; i++) {\n\t\tpath_a_ok = rtl8192fu_rx_iqk_path_a(priv);\n\n\t\tif (path_a_ok == 0x03) {\n\t\t\tval32 = rtl8xxxu_read32(priv, REG_RX_POWER_BEFORE_IQK_A_2);\n\t\t\tresult[t][2] = (val32 >> 16) & 0x3ff;\n\n\t\t\tval32 = rtl8xxxu_read32(priv, REG_RX_POWER_AFTER_IQK_A_2);\n\t\t\tresult[t][3] = (val32 >> 16) & 0x3ff;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tresult[t][2] = 0x100;\n\t\t\tresult[t][3] = 0x0;\n\t\t}\n\t}\n\n\tif (!path_a_ok)\n\t\tdev_warn(dev, \"%s: Path A IQK failed!\\n\", __func__);\n\n\tif (priv->rf_paths > 1) {\n\t\tfor (i = 0; i < retry; i++) {\n\t\t\tpath_b_ok = rtl8192fu_iqk_path_b(priv);\n\n\t\t\tif (path_b_ok == 0x01) {\n\t\t\t\tval32 = rtl8xxxu_read32(priv, REG_TX_POWER_BEFORE_IQK_B);\n\t\t\t\tresult[t][4] = (val32 >> 16) & 0x3ff;\n\n\t\t\t\tval32 = rtl8xxxu_read32(priv, REG_TX_POWER_AFTER_IQK_B);\n\t\t\t\tresult[t][5] = (val32 >> 16) & 0x3ff;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tresult[t][4] = 0x100;\n\t\t\t\tresult[t][5] = 0x0;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < retry; i++) {\n\t\t\tpath_b_ok = rtl8192fu_rx_iqk_path_b(priv);\n\n\t\t\tif (path_b_ok == 0x03) {\n\t\t\t\tval32 = rtl8xxxu_read32(priv, REG_RX_POWER_BEFORE_IQK_B_2);\n\t\t\t\tresult[t][6] = (val32 >> 16) & 0x3ff;\n\n\t\t\t\tval32 = rtl8xxxu_read32(priv, REG_RX_POWER_AFTER_IQK_B_2);\n\t\t\t\tresult[t][7] = (val32 >> 16) & 0x3ff;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tresult[t][6] = 0x100;\n\t\t\t\tresult[t][7] = 0x0;\n\t\t\t}\n\t\t}\n\n\t\tif (!path_b_ok)\n\t\t\tdev_warn(dev, \"%s: Path B IQK failed!\\n\", __func__);\n\t}\n\n\t \n\trtl8xxxu_write32_mask(priv, REG_FPGA0_IQK, 0xffffff00, 0);\n\n\trtl8xxxu_write32(priv, REG_FPGA0_ANALOG4, 0xcc0000c0);\n\n\trtl8xxxu_write32(priv, REG_ANAPWR1, 0x44bbbb44);\n\trtl8xxxu_write32(priv, REG_RX_WAIT_CCA, 0x80408040);\n\trtl8xxxu_write32(priv, REG_OFDM0_TRX_PATH_ENABLE, 0x6f005433);\n\trtl8xxxu_write32(priv, REG_OFDM0_TR_MUX_PAR, 0x000004e4);\n\trtl8xxxu_write32(priv, REG_FPGA0_XCD_RF_SW_CTRL, 0x04003400);\n\trtl8xxxu_write32(priv, REG_FPGA0_XA_HSSI_PARM1, 0x01000100);\n\n\t \n\trtl8xxxu_restore_regs(priv, adda_regs, priv->adda_backup,\n\t\t\t      ARRAY_SIZE(adda_regs));\n\n\t \n\trtl8xxxu_restore_mac_regs(priv, iqk_mac_regs, priv->mac_backup);\n\n\t \n\trtl8xxxu_restore_regs(priv, iqk_bb_regs, priv->bb_backup, RTL8XXXU_BB_REGS);\n\n\trtl8xxxu_write32_clear(priv, REG_FPGA0_XCD_RF_PARM, BIT(31));\n\n\t \n\trtl8xxxu_write32_mask(priv, REG_OFDM0_XA_AGC_CORE1, 0xff, 0x50);\n\trtl8xxxu_write32_mask(priv, REG_OFDM0_XA_AGC_CORE1, 0xff,\n\t\t\t      rx_initial_gain_a & 0xff);\n\tif (priv->rf_paths > 1) {\n\t\trtl8xxxu_write32_mask(priv, REG_OFDM0_XB_AGC_CORE1, 0xff, 0x50);\n\t\trtl8xxxu_write32_mask(priv, REG_OFDM0_XB_AGC_CORE1, 0xff,\n\t\t\t\t      rx_initial_gain_b & 0xff);\n\t}\n}\n\nstatic void rtl8192fu_phy_iq_calibrate(struct rtl8xxxu_priv *priv)\n{\n\ts32 reg_e94, reg_e9c, reg_ea4, reg_eac;\n\ts32 reg_eb4, reg_ebc, reg_ec4, reg_ecc;\n\tstruct device *dev = &priv->udev->dev;\n\tu32 path_a_0xdf, path_a_0x35;\n\tu32 path_b_0xdf, path_b_0x35;\n\tbool path_a_ok, path_b_ok;\n\tu8 rfe = priv->rfe_type;\n\tu32 rfe_path_select;\n\tint result[4][8];  \n\tint i, candidate;\n\ts32 reg_tmp = 0;\n\tbool simu;\n\tu32 val32;\n\n\trfe_path_select = rtl8xxxu_read32(priv, REG_RFE_PATH_SELECT);\n\n\tpath_a_0xdf = rtl8xxxu_read_rfreg(priv, RF_A, RF6052_REG_GAIN_CCA);\n\tpath_a_0x35 = rtl8xxxu_read_rfreg(priv, RF_A, RF6052_REG_GAIN_P1);\n\tpath_b_0xdf = rtl8xxxu_read_rfreg(priv, RF_B, RF6052_REG_GAIN_CCA);\n\tpath_b_0x35 = rtl8xxxu_read_rfreg(priv, RF_B, RF6052_REG_GAIN_P1);\n\n\tmemset(result, 0, sizeof(result));\n\tcandidate = -1;\n\n\tpath_a_ok = false;\n\tpath_b_ok = false;\n\n\tfor (i = 0; i < 3; i++) {\n\t\trtl8192fu_phy_iqcalibrate(priv, result, i);\n\n\t\tif (i == 1) {\n\t\t\tsimu = rtl8xxxu_gen2_simularity_compare(priv, result, 0, 1);\n\t\t\tif (simu) {\n\t\t\t\tcandidate = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (i == 2) {\n\t\t\tsimu = rtl8xxxu_gen2_simularity_compare(priv, result, 0, 2);\n\t\t\tif (simu) {\n\t\t\t\tcandidate = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tsimu = rtl8xxxu_gen2_simularity_compare(priv, result, 1, 2);\n\t\t\tif (simu) {\n\t\t\t\tcandidate = 1;\n\t\t\t} else {\n\t\t\t\tfor (i = 0; i < 8; i++)\n\t\t\t\t\treg_tmp += result[3][i];\n\n\t\t\t\tif (reg_tmp)\n\t\t\t\t\tcandidate = 3;\n\t\t\t\telse\n\t\t\t\t\tcandidate = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (candidate >= 0) {\n\t\treg_e94 = result[candidate][0];\n\t\treg_e9c = result[candidate][1];\n\t\treg_ea4 = result[candidate][2];\n\t\treg_eac = result[candidate][3];\n\t\treg_eb4 = result[candidate][4];\n\t\treg_ebc = result[candidate][5];\n\t\treg_ec4 = result[candidate][6];\n\t\treg_ecc = result[candidate][7];\n\n\t\tdev_dbg(dev, \"%s: candidate is %x\\n\", __func__, candidate);\n\t\tdev_dbg(dev, \"%s: e94=%x e9c=%x ea4=%x eac=%x eb4=%x ebc=%x ec4=%x ecc=%c\\n\",\n\t\t\t__func__, reg_e94, reg_e9c, reg_ea4, reg_eac,\n\t\t\treg_eb4, reg_ebc, reg_ec4, reg_ecc);\n\n\t\tpath_a_ok = true;\n\t\tpath_b_ok = true;\n\t}\n\n\trtl8xxxu_write32_mask(priv, REG_TX_IQK_TONE_A, 0x3ff00000, 0x100);\n\trtl8xxxu_write32_mask(priv, REG_NP_ANTA, 0x3ff, 0);\n\trtl8xxxu_write32_mask(priv, REG_TX_IQK_TONE_B, 0x3ff00000, 0x100);\n\trtl8xxxu_write32_mask(priv, REG_TAP_UPD_97F, 0x3ff, 0);\n\n\tif (candidate >= 0) {\n\t\tif (reg_e94)\n\t\t\trtl8xxxu_fill_iqk_matrix_a(priv, path_a_ok, result,\n\t\t\t\t\t\t   candidate, (reg_ea4 == 0));\n\n\t\tif (reg_eb4)\n\t\t\trtl8xxxu_fill_iqk_matrix_b(priv, path_b_ok, result,\n\t\t\t\t\t\t   candidate, (reg_ec4 == 0));\n\t}\n\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_GAIN_CCA, path_a_0xdf);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_GAIN_P1, path_a_0x35);\n\trtl8xxxu_write_rfreg(priv, RF_B, RF6052_REG_GAIN_CCA, path_b_0xdf);\n\trtl8xxxu_write_rfreg(priv, RF_B, RF6052_REG_GAIN_P1, path_b_0x35);\n\n\tif (rfe == 7 || rfe == 8 || rfe == 9 || rfe == 12) {\n\t\trtl8xxxu_write32_set(priv, REG_SW_GPIO_SHARE_CTRL_1, 0x70000);\n\t\trtl8xxxu_write32_clear(priv, REG_LEDCFG0, 0x6c00000);\n\t\trtl8xxxu_write32_set(priv, REG_PAD_CTRL1, BIT(29) | BIT(28));\n\t\trtl8xxxu_write32_clear(priv, REG_SW_GPIO_SHARE_CTRL_0,\n\t\t\t\t       0x600000 | BIT(4));\n\n\t\t \n\t\tval32 = rtl8xxxu_read32(priv, REG_RFE_BUFFER);\n\t\tval32 &= ~BIT(11);\n\t\tval32 |= 0x1f;\n\t\trtl8xxxu_write32(priv, REG_RFE_BUFFER, val32);\n\n\t\tif (rfe == 7) {\n\t\t\trtl8xxxu_write32_mask(priv, REG_RFE_CTRL_ANTA_SRC,\n\t\t\t\t\t      0xfffff, 0x23200);\n\t\t\trtl8xxxu_write32_mask(priv, REG_RFE_CTRL_ANT_SRC2,\n\t\t\t\t\t      0xfffff, 0x23200);\n\t\t\trtl8xxxu_write32_mask(priv, REG_RFE_CTRL_ANT_SRC1,\n\t\t\t\t\t      0xf000, 0x3);\n\t\t\trtl8xxxu_write32_mask(priv, REG_RFE_CTRL_ANT_SRC3,\n\t\t\t\t\t      0xf000, 0x3);\n\t\t} else {\n\t\t\trtl8xxxu_write32_mask(priv, REG_RFE_CTRL_ANTA_SRC,\n\t\t\t\t\t      0xfffff, 0x22200);\n\t\t\trtl8xxxu_write32_mask(priv, REG_RFE_CTRL_ANT_SRC2,\n\t\t\t\t\t      0xfffff, 0x22200);\n\t\t\trtl8xxxu_write32_mask(priv, REG_RFE_CTRL_ANT_SRC1,\n\t\t\t\t\t      0xf000, 0x2);\n\t\t\trtl8xxxu_write32_mask(priv, REG_RFE_CTRL_ANT_SRC3,\n\t\t\t\t\t      0xf000, 0x2);\n\t\t}\n\n\t\trtl8xxxu_write32_clear(priv, REG_RFE_OPT62, BIT(2));\n\n\t\tif (rfe == 7)\n\t\t\trtl8xxxu_write32(priv, REG_RFE_OPT, 0x03000003);\n\n\t\trtl8xxxu_write32(priv, REG_RFE_PATH_SELECT, rfe_path_select);\n\t}\n}\n\nstatic void rtl8192fu_disabled_to_emu(struct rtl8xxxu_priv *priv)\n{\n\trtl8xxxu_write16_clear(priv, REG_APS_FSMCO,\n\t\t\t       APS_FSMCO_HW_POWERDOWN | APS_FSMCO_HW_SUSPEND);\n\n\trtl8xxxu_write32_clear(priv, REG_GPIO_INTM, BIT(16));\n\n\trtl8xxxu_write16_clear(priv, REG_APS_FSMCO,\n\t\t\t       APS_FSMCO_PCIE | APS_FSMCO_HW_SUSPEND);\n}\n\nstatic int rtl8192fu_emu_to_active(struct rtl8xxxu_priv *priv)\n{\n\tu32 val32;\n\tu16 val16;\n\tint count;\n\n\t \n\trtl8xxxu_write8_set(priv, REG_LDOA15_CTRL, LDOA15_ENABLE);\n\n\t \n\trtl8xxxu_write32_clear(priv, REG_PAD_CTRL1, BIT(28));\n\n\tmdelay(1);\n\n\t \n\trtl8xxxu_write8_clear(priv, REG_SYS_ISO_CTRL, SYS_ISO_ANALOG_IPS);\n\n\tval16 = APS_FSMCO_PCIE | APS_FSMCO_HW_SUSPEND | APS_FSMCO_SW_LPS;\n\trtl8xxxu_write16_clear(priv, REG_APS_FSMCO, val16);\n\n\t \n\tfor (count = RTL8XXXU_MAX_REG_POLL; count; count--) {\n\t\tval32 = rtl8xxxu_read32(priv, REG_APS_FSMCO);\n\t\tif (val32 & BIT(17))\n\t\t\tbreak;\n\n\t\tudelay(10);\n\t}\n\n\tif (!count)\n\t\treturn -EBUSY;\n\n\trtl8xxxu_write32_set(priv, REG_APS_FSMCO, APS_FSMCO_WLON_RESET);\n\n\tfor (count = RTL8XXXU_MAX_REG_POLL; count; count--) {\n\t\tval32 = rtl8xxxu_read32(priv, REG_APS_FSMCO);\n\t\tif ((val32 & (APS_FSMCO_MAC_ENABLE | APS_FSMCO_MAC_OFF)) == 0)\n\t\t\tbreak;\n\n\t\tudelay(10);\n\t}\n\n\tif (!count)\n\t\treturn -EBUSY;\n\n\t \n\trtl8xxxu_write32_set(priv, REG_AFE_MISC, BIT(18));\n\n\trtl8xxxu_write16_clear(priv, REG_APS_FSMCO, APS_FSMCO_HW_POWERDOWN);\n\n\trtl8xxxu_write16_clear(priv, REG_APS_FSMCO,\n\t\t\t       APS_FSMCO_PCIE | APS_FSMCO_HW_SUSPEND);\n\n\t \n\trtl8xxxu_write32_set(priv, REG_LDO_SW_CTRL, BIT(31));\n\n\trtl8xxxu_write16_set(priv, REG_APS_FSMCO, APS_FSMCO_MAC_ENABLE);\n\n\tfor (count = RTL8XXXU_MAX_REG_POLL; count; count--) {\n\t\tval32 = rtl8xxxu_read32(priv, REG_APS_FSMCO);\n\t\tif ((val32 & APS_FSMCO_MAC_ENABLE) == 0)\n\t\t\tbreak;\n\n\t\tudelay(10);\n\t}\n\n\tif (!count)\n\t\treturn -EBUSY;\n\n\t \n\trtl8xxxu_write8_set(priv, REG_AFE_MISC, AFE_MISC_WL_XTAL_CTRL);\n\n\t \n\trtl8xxxu_write16_set(priv, REG_GPIO_INTM, GPIO_INTM_EDGE_TRIG_IRQ);\n\n\t \n\trtl8xxxu_write16_clear(priv, REG_GPIO_IO_SEL_2, GPIO_IO_SEL_2_GPIO09_IRQ);\n\n\t \n\trtl8xxxu_write16_clear(priv, REG_GPIO_IO_SEL_2, GPIO_IO_SEL_2_GPIO09_INPUT);\n\n\t \n\trtl8xxxu_write8_set(priv, REG_HSIMR, BIT(0));\n\n\t \n\trtl8xxxu_write8_clear(priv, REG_MULTI_FUNC_CTRL, MULTI_WIFI_HW_ROF_EN);\n\n\t \n\trtl8xxxu_write8_set(priv, REG_RSV_CTRL, BIT(7));\n\n\t \n\trtl8xxxu_write16_set(priv, REG_MULTI_FUNC_CTRL, BIT(14));\n\n\t \n\trtl8xxxu_write8(priv, REG_RF_CTRL, 0);\n\n\t \n\trtl8xxxu_write8(priv, REG_AFE_CTRL4 + 3, 0);\n\n\t \n\trtl8xxxu_write8(priv, REG_RF_CTRL, RF_SDMRSTB | RF_RSTB | RF_ENABLE);\n\n\t \n\trtl8xxxu_write8(priv, REG_AFE_CTRL4 + 3, RF_SDMRSTB | RF_RSTB | RF_ENABLE);\n\n\t \n\trtl8xxxu_write8_set(priv, REG_RSVD_1, BIT(5));\n\n\t \n\trtl8xxxu_write8(priv, REG_RSVD_4, 0xcc);\n\n\t \n\trtl8xxxu_write8_clear(priv, REG_AFE_XTAL_CTRL, BIT(4) | BIT(3));\n\n\t \n\trtl8xxxu_write32(priv, REG_GPIO_A0, 0xffffffff);\n\n\t \n\trtl8xxxu_write8(priv, REG_GPIO_B0, 0xff);\n\n\t \n\trtl8xxxu_write8_clear(priv, REG_RSV_CTRL, BIT(7));\n\n\treturn 0;\n}\n\nstatic int rtl8192fu_active_to_emu(struct rtl8xxxu_priv *priv)\n{\n\tu32 val32;\n\tint count;\n\n\t \n\trtl8xxxu_write8_clear(priv, REG_SYS_FUNC, SYS_FUNC_BBRSTB);\n\n\t \n\trtl8xxxu_write16_clear(priv, REG_GPIO_INTM, GPIO_INTM_EDGE_TRIG_IRQ);\n\n\t \n\trtl8xxxu_write32_set(priv, REG_APS_FSMCO, APS_FSMCO_WLON_RESET);\n\n\t \n\trtl8xxxu_write16_set(priv, REG_APS_FSMCO, APS_FSMCO_MAC_OFF);\n\n\tfor (count = RTL8XXXU_MAX_REG_POLL; count; count--) {\n\t\tval32 = rtl8xxxu_read32(priv, REG_APS_FSMCO);\n\t\tif ((val32 & APS_FSMCO_MAC_OFF) == 0)\n\t\t\tbreak;\n\n\t\tudelay(10);\n\t}\n\n\tif (!count)\n\t\treturn -EBUSY;\n\n\t \n\trtl8xxxu_write8_set(priv, REG_SYS_ISO_CTRL, SYS_ISO_ANALOG_IPS);\n\n\t \n\trtl8xxxu_write8_clear(priv, REG_LDOA15_CTRL, LDOA15_ENABLE);\n\n\treturn 0;\n}\n\nstatic int rtl8192fu_emu_to_disabled(struct rtl8xxxu_priv *priv)\n{\n\tu16 val16;\n\n\t \n\trtl8xxxu_write8(priv, REG_APS_FSMCO + 3, 0x20);\n\n\t \n\tval16 = rtl8xxxu_read16(priv, REG_APS_FSMCO);\n\tval16 &= ~APS_FSMCO_PCIE;\n\tval16 |= APS_FSMCO_HW_SUSPEND;\n\trtl8xxxu_write16(priv, REG_APS_FSMCO, val16);\n\n\t \n\trtl8xxxu_write32_set(priv, REG_GPIO_INTM, BIT(16));\n\n\treturn 0;\n}\n\nstatic int rtl8192fu_active_to_lps(struct rtl8xxxu_priv *priv)\n{\n\tstruct device *dev = &priv->udev->dev;\n\tu16 val16;\n\tu32 val32;\n\tint retry;\n\n\t \n\trtl8xxxu_write8(priv, REG_TXPAUSE, 0xff);\n\n\tretry = 100;\n\n\t \n\tdo {\n\t\tval32 = rtl8xxxu_read32(priv, REG_SCH_TX_CMD);\n\t\tif (!val32)\n\t\t\tbreak;\n\n\t\tudelay(10);\n\t} while (retry--);\n\n\tif (!retry) {\n\t\tdev_warn(dev, \"%s: Failed to flush TX queue\\n\", __func__);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\trtl8xxxu_write8_clear(priv, REG_SYS_FUNC, SYS_FUNC_BBRSTB);\n\n\tudelay(2);\n\n\t \n\trtl8xxxu_write8_clear(priv, REG_SYS_FUNC, SYS_FUNC_BB_GLB_RSTN);\n\n\t \n\tval16 = rtl8xxxu_read16(priv, REG_CR);\n\tval16 &= 0xff00;\n\tval16 |= CR_HCI_RXDMA_ENABLE | CR_HCI_TXDMA_ENABLE;\n\tval16 &= ~CR_SECURITY_ENABLE;\n\trtl8xxxu_write16(priv, REG_CR, val16);\n\n\t \n\trtl8xxxu_write8_set(priv, REG_DUAL_TSF_RST, DUAL_TSF_TX_OK);\n\n\treturn 0;\n}\n\nstatic int rtl8192fu_power_on(struct rtl8xxxu_priv *priv)\n{\n\tu16 val16;\n\tint ret;\n\n\trtl8xxxu_write8(priv, REG_USB_ACCESS_TIMEOUT, 0x80);\n\n\trtl8192fu_disabled_to_emu(priv);\n\n\tret = rtl8192fu_emu_to_active(priv);\n\tif (ret)\n\t\treturn ret;\n\n\trtl8xxxu_write16(priv, REG_CR, 0);\n\n\tval16 = rtl8xxxu_read16(priv, REG_CR);\n\n\tval16 |= CR_HCI_TXDMA_ENABLE | CR_HCI_RXDMA_ENABLE |\n\t\t CR_TXDMA_ENABLE | CR_RXDMA_ENABLE |\n\t\t CR_PROTOCOL_ENABLE | CR_SCHEDULE_ENABLE |\n\t\t CR_SECURITY_ENABLE | CR_CALTIMER_ENABLE;\n\trtl8xxxu_write16(priv, REG_CR, val16);\n\n\treturn 0;\n}\n\nstatic void rtl8192fu_power_off(struct rtl8xxxu_priv *priv)\n{\n\trtl8xxxu_flush_fifo(priv);\n\n\t \n\trtl8xxxu_write8_clear(priv, REG_TX_REPORT_CTRL,\n\t\t\t      TX_REPORT_CTRL_TIMER_ENABLE);\n\n\t \n\trtl8xxxu_write8(priv, REG_CR, 0x00);\n\n\trtl8192fu_active_to_lps(priv);\n\n\t \n\tif (rtl8xxxu_read8(priv, REG_MCU_FW_DL) & MCU_FW_RAM_SEL)\n\t\trtl8xxxu_firmware_self_reset(priv);\n\n\t \n\trtl8xxxu_write16_clear(priv, REG_SYS_FUNC, SYS_FUNC_CPU_ENABLE);\n\n\t \n\trtl8xxxu_write8(priv, REG_MCU_FW_DL, 0x00);\n\n\trtl8192fu_active_to_emu(priv);\n\trtl8192fu_emu_to_disabled(priv);\n}\n\nstatic void rtl8192f_reset_8051(struct rtl8xxxu_priv *priv)\n{\n\trtl8xxxu_write8_clear(priv, REG_RSV_CTRL, BIT(1));\n\n\trtl8xxxu_write8_clear(priv, REG_RSV_CTRL + 1, BIT(0));\n\n\trtl8xxxu_write16_clear(priv, REG_SYS_FUNC, SYS_FUNC_CPU_ENABLE);\n\n\trtl8xxxu_write8_clear(priv, REG_RSV_CTRL, BIT(1));\n\n\trtl8xxxu_write8_set(priv, REG_RSV_CTRL + 1, BIT(0));\n\n\trtl8xxxu_write16_set(priv, REG_SYS_FUNC, SYS_FUNC_CPU_ENABLE);\n}\n\nstatic void rtl8192f_enable_rf(struct rtl8xxxu_priv *priv)\n{\n\tu32 val32;\n\n\trtl8xxxu_write8(priv, REG_RF_CTRL, RF_ENABLE | RF_RSTB | RF_SDMRSTB);\n\n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_TRX_PATH_ENABLE);\n\tval32 &= ~(OFDM_RF_PATH_RX_MASK | OFDM_RF_PATH_TX_MASK);\n\tval32 |= OFDM_RF_PATH_RX_A | OFDM_RF_PATH_RX_B |\n\t\t OFDM_RF_PATH_TX_A | OFDM_RF_PATH_TX_B;\n\trtl8xxxu_write32(priv, REG_OFDM0_TRX_PATH_ENABLE, val32);\n\n\trtl8xxxu_write8(priv, REG_TXPAUSE, 0x00);\n}\n\nstatic void rtl8192f_disable_rf(struct rtl8xxxu_priv *priv)\n{\n\tu32 val32;\n\n\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_TRX_PATH_ENABLE);\n\tval32 &= ~OFDM_RF_PATH_TX_MASK;\n\trtl8xxxu_write32(priv, REG_OFDM0_TRX_PATH_ENABLE, val32);\n\n\t \n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_AC, 0);\n}\n\nstatic void rtl8192f_usb_quirks(struct rtl8xxxu_priv *priv)\n{\n\tu16 val16;\n\n\trtl8xxxu_gen2_usb_quirks(priv);\n\n\tval16 = rtl8xxxu_read16(priv, REG_CR);\n\tval16 |= (CR_MAC_TX_ENABLE | CR_MAC_RX_ENABLE);\n\trtl8xxxu_write16(priv, REG_CR, val16);\n}\n\n#define XTAL1\tGENMASK(6, 1)\n#define XTAL0\tGENMASK(30, 25)\n\nstatic void rtl8192f_set_crystal_cap(struct rtl8xxxu_priv *priv, u8 crystal_cap)\n{\n\tstruct rtl8xxxu_cfo_tracking *cfo = &priv->cfo_tracking;\n\tu32 xtal1, xtal0;\n\n\tif (crystal_cap == cfo->crystal_cap)\n\t\treturn;\n\n\txtal1 = rtl8xxxu_read32(priv, REG_AFE_PLL_CTRL);\n\txtal0 = rtl8xxxu_read32(priv, REG_AFE_XTAL_CTRL);\n\n\tdev_dbg(&priv->udev->dev,\n\t\t\"%s: Adjusting crystal cap from 0x%x (actually 0x%x 0x%x) to 0x%x\\n\",\n\t\t__func__,\n\t\tcfo->crystal_cap,\n\t\tu32_get_bits(xtal1, XTAL1),\n\t\tu32_get_bits(xtal0, XTAL0),\n\t\tcrystal_cap);\n\n\tu32p_replace_bits(&xtal1, crystal_cap, XTAL1);\n\tu32p_replace_bits(&xtal0, crystal_cap, XTAL0);\n\trtl8xxxu_write32(priv, REG_AFE_PLL_CTRL, xtal1);\n\trtl8xxxu_write32(priv, REG_AFE_XTAL_CTRL, xtal0);\n\n\tcfo->crystal_cap = crystal_cap;\n}\n\nstatic s8 rtl8192f_cck_rssi(struct rtl8xxxu_priv *priv, struct rtl8723au_phy_stats *phy_stats)\n{\n\tstruct jaguar2_phy_stats_type0 *phy_stats0 = (struct jaguar2_phy_stats_type0 *)phy_stats;\n\tu8 lna_idx = (phy_stats0->lna_h << 3) | phy_stats0->lna_l;\n\tu8 vga_idx = phy_stats0->vga;\n\ts8 rx_pwr_all;\n\n\tswitch (lna_idx) {\n\tcase 7:\n\t\trx_pwr_all = -44 - (2 * vga_idx);\n\t\tbreak;\n\tcase 5:\n\t\trx_pwr_all = -28 - (2 * vga_idx);\n\t\tbreak;\n\tcase 3:\n\t\trx_pwr_all = -10 - (2 * vga_idx);\n\t\tbreak;\n\tcase 0:\n\t\trx_pwr_all = 14 - (2 * vga_idx);\n\t\tbreak;\n\tdefault:\n\t\trx_pwr_all = 0;\n\t\tbreak;\n\t}\n\n\treturn rx_pwr_all;\n}\n\nstatic int rtl8192fu_led_brightness_set(struct led_classdev *led_cdev,\n\t\t\t\t\tenum led_brightness brightness)\n{\n\tstruct rtl8xxxu_priv *priv = container_of(led_cdev,\n\t\t\t\t\t\t  struct rtl8xxxu_priv,\n\t\t\t\t\t\t  led_cdev);\n\tu16 ledcfg;\n\n\t \n\trtl8xxxu_write32(priv, REG_SW_GPIO_SHARE_CTRL_0, 0x20080);\n\trtl8xxxu_write32(priv, REG_SW_GPIO_SHARE_CTRL_1, 0x1b0000);\n\n\tledcfg = rtl8xxxu_read16(priv, REG_LEDCFG0);\n\n\tif (brightness == LED_OFF) {\n\t\t \n\t\tledcfg = BIT(1) | BIT(7);\n\t} else if (brightness == LED_ON) {\n\t\t \n\t\tledcfg = BIT(1) | BIT(7) | BIT(11);\n\t} else if (brightness == RTL8XXXU_HW_LED_CONTROL) {\n\t\t \n\t\tledcfg = BIT(8) | BIT(9);\n\t}\n\n\trtl8xxxu_write16(priv, REG_LEDCFG0, ledcfg);\n\n\treturn 0;\n}\n\nstruct rtl8xxxu_fileops rtl8192fu_fops = {\n\t.identify_chip = rtl8192fu_identify_chip,\n\t.parse_efuse = rtl8192fu_parse_efuse,\n\t.load_firmware = rtl8192fu_load_firmware,\n\t.power_on = rtl8192fu_power_on,\n\t.power_off = rtl8192fu_power_off,\n\t.read_efuse = rtl8xxxu_read_efuse,\n\t.reset_8051 = rtl8192f_reset_8051,\n\t.llt_init = rtl8xxxu_auto_llt_table,\n\t.init_phy_bb = rtl8192fu_init_phy_bb,\n\t.init_phy_rf = rtl8192fu_init_phy_rf,\n\t.phy_lc_calibrate = rtl8192f_phy_lc_calibrate,\n\t.phy_iq_calibrate = rtl8192fu_phy_iq_calibrate,\n\t.config_channel = rtl8192fu_config_channel,\n\t.parse_rx_desc = rtl8xxxu_parse_rxdesc24,\n\t.parse_phystats = jaguar2_rx_parse_phystats,\n\t.init_aggregation = rtl8192fu_init_aggregation,\n\t.init_burst = rtl8xxxu_init_burst,\n\t.enable_rf = rtl8192f_enable_rf,\n\t.disable_rf = rtl8192f_disable_rf,\n\t.usb_quirks = rtl8192f_usb_quirks,\n\t.set_tx_power = rtl8192f_set_tx_power,\n\t.update_rate_mask = rtl8xxxu_gen2_update_rate_mask,\n\t.report_connect = rtl8xxxu_gen2_report_connect,\n\t.report_rssi = rtl8xxxu_gen2_report_rssi,\n\t.fill_txdesc = rtl8xxxu_fill_txdesc_v2,\n\t.set_crystal_cap = rtl8192f_set_crystal_cap,\n\t.cck_rssi = rtl8192f_cck_rssi,\n\t.led_classdev_brightness_set = rtl8192fu_led_brightness_set,\n\t.writeN_block_size = 254,\n\t.rx_desc_size = sizeof(struct rtl8xxxu_rxdesc24),\n\t.tx_desc_size = sizeof(struct rtl8xxxu_txdesc40),\n\t.has_tx_report = 1,\n\t.gen2_thermal_meter = 1,\n\t.needs_full_init = 1,\n\t.init_reg_rxfltmap = 1,\n\t.init_reg_pkt_life_time = 1,\n\t.init_reg_hmtfr = 1,\n\t.ampdu_max_time = 0x5e,\n\t.ustime_tsf_edca = 0x50,\n\t.max_aggr_num = 0x1f1f,\n\t.supports_ap = 1,\n\t.max_macid_num = 128,\n\t.trxff_boundary = 0x3f3f,\n\t.pbp_rx = PBP_PAGE_SIZE_256,\n\t.pbp_tx = PBP_PAGE_SIZE_256,\n\t.mactable = rtl8192f_mac_init_table,\n\t.total_page_num = TX_TOTAL_PAGE_NUM_8192F,\n\t.page_num_hi = TX_PAGE_NUM_HI_PQ_8192F,\n\t.page_num_lo = TX_PAGE_NUM_LO_PQ_8192F,\n\t.page_num_norm = TX_PAGE_NUM_NORM_PQ_8192F,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}