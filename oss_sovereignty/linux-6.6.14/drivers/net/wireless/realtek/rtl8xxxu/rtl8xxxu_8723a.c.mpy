{
  "module_name": "rtl8xxxu_8723a.c",
  "hash_id": "db8bd2c60abde55f2949a9b3690bb885832b278ec8d5714ed2e6d0dbbedbbabc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu_8723a.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/usb.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/wireless.h>\n#include <linux/firmware.h>\n#include <linux/moduleparam.h>\n#include <net/mac80211.h>\n#include \"rtl8xxxu.h\"\n#include \"rtl8xxxu_regs.h\"\n\nstatic struct rtl8xxxu_power_base rtl8723a_power_base = {\n\t.reg_0e00 = 0x0a0c0c0c,\n\t.reg_0e04 = 0x02040608,\n\t.reg_0e08 = 0x00000000,\n\t.reg_086c = 0x00000000,\n\n\t.reg_0e10 = 0x0a0c0d0e,\n\t.reg_0e14 = 0x02040608,\n\t.reg_0e18 = 0x0a0c0d0e,\n\t.reg_0e1c = 0x02040608,\n\n\t.reg_0830 = 0x0a0c0c0c,\n\t.reg_0834 = 0x02040608,\n\t.reg_0838 = 0x00000000,\n\t.reg_086c_2 = 0x00000000,\n\n\t.reg_083c = 0x0a0c0d0e,\n\t.reg_0848 = 0x02040608,\n\t.reg_084c = 0x0a0c0d0e,\n\t.reg_0868 = 0x02040608,\n};\n\nstatic const struct rtl8xxxu_rfregval rtl8723au_radioa_1t_init_table[] = {\n\t{0x00, 0x00030159}, {0x01, 0x00031284},\n\t{0x02, 0x00098000}, {0x03, 0x00039c63},\n\t{0x04, 0x000210e7}, {0x09, 0x0002044f},\n\t{0x0a, 0x0001a3f1}, {0x0b, 0x00014787},\n\t{0x0c, 0x000896fe}, {0x0d, 0x0000e02c},\n\t{0x0e, 0x00039ce7}, {0x0f, 0x00000451},\n\t{0x19, 0x00000000}, {0x1a, 0x00030355},\n\t{0x1b, 0x00060a00}, {0x1c, 0x000fc378},\n\t{0x1d, 0x000a1250}, {0x1e, 0x0000024f},\n\t{0x1f, 0x00000000}, {0x20, 0x0000b614},\n\t{0x21, 0x0006c000}, {0x22, 0x00000000},\n\t{0x23, 0x00001558}, {0x24, 0x00000060},\n\t{0x25, 0x00000483}, {0x26, 0x0004f000},\n\t{0x27, 0x000ec7d9}, {0x28, 0x00057730},\n\t{0x29, 0x00004783}, {0x2a, 0x00000001},\n\t{0x2b, 0x00021334}, {0x2a, 0x00000000},\n\t{0x2b, 0x00000054}, {0x2a, 0x00000001},\n\t{0x2b, 0x00000808}, {0x2b, 0x00053333},\n\t{0x2c, 0x0000000c}, {0x2a, 0x00000002},\n\t{0x2b, 0x00000808}, {0x2b, 0x0005b333},\n\t{0x2c, 0x0000000d}, {0x2a, 0x00000003},\n\t{0x2b, 0x00000808}, {0x2b, 0x00063333},\n\t{0x2c, 0x0000000d}, {0x2a, 0x00000004},\n\t{0x2b, 0x00000808}, {0x2b, 0x0006b333},\n\t{0x2c, 0x0000000d}, {0x2a, 0x00000005},\n\t{0x2b, 0x00000808}, {0x2b, 0x00073333},\n\t{0x2c, 0x0000000d}, {0x2a, 0x00000006},\n\t{0x2b, 0x00000709}, {0x2b, 0x0005b333},\n\t{0x2c, 0x0000000d}, {0x2a, 0x00000007},\n\t{0x2b, 0x00000709}, {0x2b, 0x00063333},\n\t{0x2c, 0x0000000d}, {0x2a, 0x00000008},\n\t{0x2b, 0x0000060a}, {0x2b, 0x0004b333},\n\t{0x2c, 0x0000000d}, {0x2a, 0x00000009},\n\t{0x2b, 0x0000060a}, {0x2b, 0x00053333},\n\t{0x2c, 0x0000000d}, {0x2a, 0x0000000a},\n\t{0x2b, 0x0000060a}, {0x2b, 0x0005b333},\n\t{0x2c, 0x0000000d}, {0x2a, 0x0000000b},\n\t{0x2b, 0x0000060a}, {0x2b, 0x00063333},\n\t{0x2c, 0x0000000d}, {0x2a, 0x0000000c},\n\t{0x2b, 0x0000060a}, {0x2b, 0x0006b333},\n\t{0x2c, 0x0000000d}, {0x2a, 0x0000000d},\n\t{0x2b, 0x0000060a}, {0x2b, 0x00073333},\n\t{0x2c, 0x0000000d}, {0x2a, 0x0000000e},\n\t{0x2b, 0x0000050b}, {0x2b, 0x00066666},\n\t{0x2c, 0x0000001a}, {0x2a, 0x000e0000},\n\t{0x10, 0x0004000f}, {0x11, 0x000e31fc},\n\t{0x10, 0x0006000f}, {0x11, 0x000ff9f8},\n\t{0x10, 0x0002000f}, {0x11, 0x000203f9},\n\t{0x10, 0x0003000f}, {0x11, 0x000ff500},\n\t{0x10, 0x00000000}, {0x11, 0x00000000},\n\t{0x10, 0x0008000f}, {0x11, 0x0003f100},\n\t{0x10, 0x0009000f}, {0x11, 0x00023100},\n\t{0x12, 0x00032000}, {0x12, 0x00071000},\n\t{0x12, 0x000b0000}, {0x12, 0x000fc000},\n\t{0x13, 0x000287b3}, {0x13, 0x000244b7},\n\t{0x13, 0x000204ab}, {0x13, 0x0001c49f},\n\t{0x13, 0x00018493}, {0x13, 0x0001429b},\n\t{0x13, 0x00010299}, {0x13, 0x0000c29c},\n\t{0x13, 0x000081a0}, {0x13, 0x000040ac},\n\t{0x13, 0x00000020}, {0x14, 0x0001944c},\n\t{0x14, 0x00059444}, {0x14, 0x0009944c},\n\t{0x14, 0x000d9444}, {0x15, 0x0000f474},\n\t{0x15, 0x0004f477}, {0x15, 0x0008f455},\n\t{0x15, 0x000cf455}, {0x16, 0x00000339},\n\t{0x16, 0x00040339}, {0x16, 0x00080339},\n\t{0x16, 0x000c0366}, {0x00, 0x00010159},\n\t{0x18, 0x0000f401}, {0xfe, 0x00000000},\n\t{0xfe, 0x00000000}, {0x1f, 0x00000003},\n\t{0xfe, 0x00000000}, {0xfe, 0x00000000},\n\t{0x1e, 0x00000247}, {0x1f, 0x00000000},\n\t{0x00, 0x00030159},\n\t{0xff, 0xffffffff}\n};\n\nstatic int rtl8723au_identify_chip(struct rtl8xxxu_priv *priv)\n{\n\tstruct device *dev = &priv->udev->dev;\n\tu32 val32, sys_cfg, vendor;\n\tint ret = 0;\n\n\tsys_cfg = rtl8xxxu_read32(priv, REG_SYS_CFG);\n\tpriv->chip_cut = u32_get_bits(sys_cfg, SYS_CFG_CHIP_VERSION_MASK);\n\tif (sys_cfg & SYS_CFG_TRP_VAUX_EN) {\n\t\tdev_info(dev, \"Unsupported test chip\\n\");\n\t\tret = -ENOTSUPP;\n\t\tgoto out;\n\t}\n\n\tstrscpy(priv->chip_name, \"8723AU\", sizeof(priv->chip_name));\n\tpriv->usb_interrupts = 1;\n\tpriv->rtl_chip = RTL8723A;\n\n\tpriv->rf_paths = 1;\n\tpriv->rx_paths = 1;\n\tpriv->tx_paths = 1;\n\n\tval32 = rtl8xxxu_read32(priv, REG_MULTI_FUNC_CTRL);\n\tif (val32 & MULTI_WIFI_FUNC_EN)\n\t\tpriv->has_wifi = 1;\n\tif (val32 & MULTI_BT_FUNC_EN)\n\t\tpriv->has_bluetooth = 1;\n\tif (val32 & MULTI_GPS_FUNC_EN)\n\t\tpriv->has_gps = 1;\n\tpriv->is_multi_func = 1;\n\n\tvendor = sys_cfg & SYS_CFG_VENDOR_ID;\n\trtl8xxxu_identify_vendor_1bit(priv, vendor);\n\n\tval32 = rtl8xxxu_read32(priv, REG_GPIO_OUTSTS);\n\tpriv->rom_rev = u32_get_bits(val32, GPIO_RF_RL_ID);\n\n\trtl8xxxu_config_endpoints_sie(priv);\n\n\t \n\tif (!priv->ep_tx_count)\n\t\tret = rtl8xxxu_config_endpoints_no_sie(priv);\n\nout:\n\treturn ret;\n}\n\nstatic int rtl8723au_parse_efuse(struct rtl8xxxu_priv *priv)\n{\n\tstruct rtl8723au_efuse *efuse = &priv->efuse_wifi.efuse8723;\n\n\tif (efuse->rtl_id != cpu_to_le16(0x8129))\n\t\treturn -EINVAL;\n\n\tether_addr_copy(priv->mac_addr, efuse->mac_addr);\n\n\tmemcpy(priv->cck_tx_power_index_A,\n\t       efuse->cck_tx_power_index_A,\n\t       sizeof(efuse->cck_tx_power_index_A));\n\tmemcpy(priv->cck_tx_power_index_B,\n\t       efuse->cck_tx_power_index_B,\n\t       sizeof(efuse->cck_tx_power_index_B));\n\n\tmemcpy(priv->ht40_1s_tx_power_index_A,\n\t       efuse->ht40_1s_tx_power_index_A,\n\t       sizeof(efuse->ht40_1s_tx_power_index_A));\n\tmemcpy(priv->ht40_1s_tx_power_index_B,\n\t       efuse->ht40_1s_tx_power_index_B,\n\t       sizeof(efuse->ht40_1s_tx_power_index_B));\n\n\tmemcpy(priv->ht20_tx_power_index_diff,\n\t       efuse->ht20_tx_power_index_diff,\n\t       sizeof(efuse->ht20_tx_power_index_diff));\n\tmemcpy(priv->ofdm_tx_power_index_diff,\n\t       efuse->ofdm_tx_power_index_diff,\n\t       sizeof(efuse->ofdm_tx_power_index_diff));\n\n\tmemcpy(priv->ht40_max_power_offset,\n\t       efuse->ht40_max_power_offset,\n\t       sizeof(efuse->ht40_max_power_offset));\n\tmemcpy(priv->ht20_max_power_offset,\n\t       efuse->ht20_max_power_offset,\n\t       sizeof(efuse->ht20_max_power_offset));\n\n\tif (priv->efuse_wifi.efuse8723.version >= 0x01)\n\t\tpriv->default_crystal_cap = priv->efuse_wifi.efuse8723.xtal_k & 0x3f;\n\telse\n\t\tpriv->fops->set_crystal_cap = NULL;\n\n\tpriv->power_base = &rtl8723a_power_base;\n\n\treturn 0;\n}\n\nstatic int rtl8723au_load_firmware(struct rtl8xxxu_priv *priv)\n{\n\tconst char *fw_name;\n\tint ret;\n\n\tswitch (priv->chip_cut) {\n\tcase 0:\n\t\tfw_name = \"rtlwifi/rtl8723aufw_A.bin\";\n\t\tbreak;\n\tcase 1:\n\t\tif (priv->enable_bluetooth)\n\t\t\tfw_name = \"rtlwifi/rtl8723aufw_B.bin\";\n\t\telse\n\t\t\tfw_name = \"rtlwifi/rtl8723aufw_B_NoBT.bin\";\n\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = rtl8xxxu_load_firmware(priv, fw_name);\n\treturn ret;\n}\n\nstatic int rtl8723au_init_phy_rf(struct rtl8xxxu_priv *priv)\n{\n\tint ret;\n\n\tret = rtl8xxxu_init_phy_rf(priv, rtl8723au_radioa_1t_init_table, RF_A);\n\n\t \n\trtl8xxxu_write32(priv, REG_AFE_XTAL_CTRL, 0x0381808d);\n\trtl8xxxu_write32(priv, REG_AFE_PLL_CTRL, 0xf0ffff83);\n\trtl8xxxu_write32(priv, REG_AFE_PLL_CTRL, 0xf0ffff82);\n\trtl8xxxu_write32(priv, REG_AFE_PLL_CTRL, 0xf0ffff83);\n\n\treturn ret;\n}\n\nstatic int rtl8723a_emu_to_active(struct rtl8xxxu_priv *priv)\n{\n\tu8 val8;\n\tu32 val32;\n\tint count, ret = 0;\n\n\t \n\tval8 = rtl8xxxu_read8(priv, REG_LDOA15_CTRL);\n\tval8 |= LDOA15_ENABLE;\n\trtl8xxxu_write8(priv, REG_LDOA15_CTRL, val8);\n\n\t \n\tval8 = rtl8xxxu_read8(priv, 0x0067);\n\tval8 &= ~BIT(4);\n\trtl8xxxu_write8(priv, 0x0067, val8);\n\n\tmdelay(1);\n\n\t \n\tval8 = rtl8xxxu_read8(priv, REG_SYS_ISO_CTRL);\n\tval8 &= ~SYS_ISO_ANALOG_IPS;\n\trtl8xxxu_write8(priv, REG_SYS_ISO_CTRL, val8);\n\n\t \n\tval8 = rtl8xxxu_read8(priv, REG_APS_FSMCO + 1);\n\tval8 &= ~BIT(2);\n\trtl8xxxu_write8(priv, REG_APS_FSMCO + 1, val8);\n\n\t \n\tfor (count = RTL8XXXU_MAX_REG_POLL; count; count--) {\n\t\tval32 = rtl8xxxu_read32(priv, REG_APS_FSMCO);\n\t\tif (val32 & BIT(17))\n\t\t\tbreak;\n\n\t\tudelay(10);\n\t}\n\n\tif (!count) {\n\t\tret = -EBUSY;\n\t\tgoto exit;\n\t}\n\n\t \n\n\t \n\tval8 = rtl8xxxu_read8(priv, REG_APS_FSMCO + 2);\n\tval8 |= BIT(0);\n\trtl8xxxu_write8(priv, REG_APS_FSMCO + 2, val8);\n\n\t \n\tval8 = rtl8xxxu_read8(priv, REG_APS_FSMCO + 1);\n\tval8 &= ~BIT(7);\n\trtl8xxxu_write8(priv, REG_APS_FSMCO + 1, val8);\n\n\t \n\tval8 = rtl8xxxu_read8(priv, REG_APS_FSMCO + 1);\n\tval8 &= ~(BIT(3) | BIT(4));\n\trtl8xxxu_write8(priv, REG_APS_FSMCO + 1, val8);\n\n\t \n\tval32 = rtl8xxxu_read32(priv, REG_APS_FSMCO);\n\tval32 |= APS_FSMCO_MAC_ENABLE;\n\trtl8xxxu_write32(priv, REG_APS_FSMCO, val32);\n\n\tfor (count = RTL8XXXU_MAX_REG_POLL; count; count--) {\n\t\tval32 = rtl8xxxu_read32(priv, REG_APS_FSMCO);\n\t\tif ((val32 & APS_FSMCO_MAC_ENABLE) == 0) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tudelay(10);\n\t}\n\n\tif (!count) {\n\t\tret = -EBUSY;\n\t\tgoto exit;\n\t}\n\n\t \n\t \n\tval8 = rtl8xxxu_read8(priv, REG_LEDCFG2);\n\tval8 |= LEDCFG2_DPDT_SELECT;\n\tval8 &= ~LEDCFG2_DPDT_SELECT;\n\trtl8xxxu_write8(priv, REG_LEDCFG2, val8);\n\nexit:\n\treturn ret;\n}\n\nstatic int rtl8723au_power_on(struct rtl8xxxu_priv *priv)\n{\n\tu8 val8;\n\tu16 val16;\n\tu32 val32;\n\tint ret;\n\n\t \n\trtl8xxxu_write8(priv, REG_RSV_CTRL, 0x0);\n\n\trtl8xxxu_disabled_to_emu(priv);\n\n\tret = rtl8723a_emu_to_active(priv);\n\tif (ret)\n\t\tgoto exit;\n\n\t \n\tval8 = rtl8xxxu_read8(priv, REG_APS_FSMCO + 2);\n\tval8 |= BIT(3);\n\trtl8xxxu_write8(priv, REG_APS_FSMCO + 2, val8);\n\n\t \n\tval16 = rtl8xxxu_read16(priv, REG_CR);\n\tval16 |= (CR_HCI_TXDMA_ENABLE | CR_HCI_RXDMA_ENABLE |\n\t\t  CR_TXDMA_ENABLE | CR_RXDMA_ENABLE |\n\t\t  CR_PROTOCOL_ENABLE | CR_SCHEDULE_ENABLE |\n\t\t  CR_MAC_TX_ENABLE | CR_MAC_RX_ENABLE |\n\t\t  CR_SECURITY_ENABLE | CR_CALTIMER_ENABLE);\n\trtl8xxxu_write16(priv, REG_CR, val16);\n\n\t \n\tval32 = rtl8xxxu_read32(priv, REG_EFUSE_CTRL);\n\tval32 &= ~(BIT(28) | BIT(29) | BIT(30));\n\tval32 |= (0x06 << 28);\n\trtl8xxxu_write32(priv, REG_EFUSE_CTRL, val32);\nexit:\n\treturn ret;\n}\n\n#define XTAL1\tGENMASK(23, 18)\n#define XTAL0\tGENMASK(17, 12)\n\nvoid rtl8723a_set_crystal_cap(struct rtl8xxxu_priv *priv, u8 crystal_cap)\n{\n\tstruct rtl8xxxu_cfo_tracking *cfo = &priv->cfo_tracking;\n\tu32 val32;\n\n\tif (crystal_cap == cfo->crystal_cap)\n\t\treturn;\n\n\tval32 = rtl8xxxu_read32(priv, REG_MAC_PHY_CTRL);\n\n\tdev_dbg(&priv->udev->dev,\n\t        \"%s: Adjusting crystal cap from 0x%x (actually 0x%lx 0x%lx) to 0x%x\\n\",\n\t        __func__,\n\t        cfo->crystal_cap,\n\t        FIELD_GET(XTAL1, val32),\n\t        FIELD_GET(XTAL0, val32),\n\t        crystal_cap);\n\n\tval32 &= ~(XTAL1 | XTAL0);\n\tval32 |= FIELD_PREP(XTAL1, crystal_cap) |\n\t\t FIELD_PREP(XTAL0, crystal_cap);\n\trtl8xxxu_write32(priv, REG_MAC_PHY_CTRL, val32);\n\n\tcfo->crystal_cap = crystal_cap;\n}\n\ns8 rtl8723a_cck_rssi(struct rtl8xxxu_priv *priv, struct rtl8723au_phy_stats *phy_stats)\n{\n\tu8 cck_agc_rpt = phy_stats->cck_agc_rpt_ofdm_cfosho_a;\n\ts8 rx_pwr_all = 0x00;\n\n\tswitch (cck_agc_rpt & 0xc0) {\n\tcase 0xc0:\n\t\trx_pwr_all = -46 - (cck_agc_rpt & 0x3e);\n\t\tbreak;\n\tcase 0x80:\n\t\trx_pwr_all = -26 - (cck_agc_rpt & 0x3e);\n\t\tbreak;\n\tcase 0x40:\n\t\trx_pwr_all = -12 - (cck_agc_rpt & 0x3e);\n\t\tbreak;\n\tcase 0x00:\n\t\trx_pwr_all = 16 - (cck_agc_rpt & 0x3e);\n\t\tbreak;\n\t}\n\n\treturn rx_pwr_all;\n}\n\nstatic int rtl8723au_led_brightness_set(struct led_classdev *led_cdev,\n\t\t\t\t\tenum led_brightness brightness)\n{\n\tstruct rtl8xxxu_priv *priv = container_of(led_cdev,\n\t\t\t\t\t\t  struct rtl8xxxu_priv,\n\t\t\t\t\t\t  led_cdev);\n\tu8 ledcfg = rtl8xxxu_read8(priv, REG_LEDCFG2);\n\n\tif (brightness == LED_OFF) {\n\t\tledcfg &= ~LEDCFG2_HW_LED_CONTROL;\n\t\tledcfg |= LEDCFG2_SW_LED_CONTROL | LEDCFG2_SW_LED_DISABLE;\n\t} else if (brightness == LED_ON) {\n\t\tledcfg &= ~(LEDCFG2_HW_LED_CONTROL | LEDCFG2_SW_LED_DISABLE);\n\t\tledcfg |= LEDCFG2_SW_LED_CONTROL;\n\t} else if (brightness == RTL8XXXU_HW_LED_CONTROL) {\n\t\tledcfg &= ~LEDCFG2_SW_LED_DISABLE;\n\t\tledcfg |= LEDCFG2_HW_LED_CONTROL | LEDCFG2_HW_LED_ENABLE;\n\t}\n\n\trtl8xxxu_write8(priv, REG_LEDCFG2, ledcfg);\n\n\treturn 0;\n}\n\nstruct rtl8xxxu_fileops rtl8723au_fops = {\n\t.identify_chip = rtl8723au_identify_chip,\n\t.parse_efuse = rtl8723au_parse_efuse,\n\t.load_firmware = rtl8723au_load_firmware,\n\t.power_on = rtl8723au_power_on,\n\t.power_off = rtl8xxxu_power_off,\n\t.read_efuse = rtl8xxxu_read_efuse,\n\t.reset_8051 = rtl8xxxu_reset_8051,\n\t.llt_init = rtl8xxxu_init_llt_table,\n\t.init_phy_bb = rtl8xxxu_gen1_init_phy_bb,\n\t.init_phy_rf = rtl8723au_init_phy_rf,\n\t.phy_lc_calibrate = rtl8723a_phy_lc_calibrate,\n\t.phy_iq_calibrate = rtl8xxxu_gen1_phy_iq_calibrate,\n\t.config_channel = rtl8xxxu_gen1_config_channel,\n\t.parse_rx_desc = rtl8xxxu_parse_rxdesc16,\n\t.parse_phystats = rtl8723au_rx_parse_phystats,\n\t.init_aggregation = rtl8xxxu_gen1_init_aggregation,\n\t.enable_rf = rtl8xxxu_gen1_enable_rf,\n\t.disable_rf = rtl8xxxu_gen1_disable_rf,\n\t.usb_quirks = rtl8xxxu_gen1_usb_quirks,\n\t.set_tx_power = rtl8xxxu_gen1_set_tx_power,\n\t.update_rate_mask = rtl8xxxu_update_rate_mask,\n\t.report_connect = rtl8xxxu_gen1_report_connect,\n\t.report_rssi = rtl8xxxu_gen1_report_rssi,\n\t.fill_txdesc = rtl8xxxu_fill_txdesc_v1,\n\t.set_crystal_cap = rtl8723a_set_crystal_cap,\n\t.cck_rssi = rtl8723a_cck_rssi,\n\t.led_classdev_brightness_set = rtl8723au_led_brightness_set,\n\t.writeN_block_size = 1024,\n\t.rx_agg_buf_size = 16000,\n\t.tx_desc_size = sizeof(struct rtl8xxxu_txdesc32),\n\t.rx_desc_size = sizeof(struct rtl8xxxu_rxdesc16),\n\t.adda_1t_init = 0x0b1b25a0,\n\t.adda_1t_path_on = 0x0bdb25a0,\n\t.adda_2t_path_on_a = 0x04db25a4,\n\t.adda_2t_path_on_b = 0x0b1b25a4,\n\t.trxff_boundary = 0x27ff,\n\t.pbp_rx = PBP_PAGE_SIZE_128,\n\t.pbp_tx = PBP_PAGE_SIZE_128,\n\t.mactable = rtl8xxxu_gen1_mac_init_table,\n\t.total_page_num = TX_TOTAL_PAGE_NUM,\n\t.page_num_hi = TX_PAGE_NUM_HI_PQ,\n\t.page_num_lo = TX_PAGE_NUM_LO_PQ,\n\t.page_num_norm = TX_PAGE_NUM_NORM_PQ,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}