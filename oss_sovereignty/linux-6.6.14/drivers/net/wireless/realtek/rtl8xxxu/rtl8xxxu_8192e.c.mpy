{
  "module_name": "rtl8xxxu_8192e.c",
  "hash_id": "8a0aab4c21355fa9a9ce59539f61593f86a35abb068365cbd79229c265d34ae7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu_8192e.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/usb.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/wireless.h>\n#include <linux/firmware.h>\n#include <linux/moduleparam.h>\n#include <net/mac80211.h>\n#include \"rtl8xxxu.h\"\n#include \"rtl8xxxu_regs.h\"\n\nstatic const struct rtl8xxxu_reg8val rtl8192e_mac_init_table[] = {\n\t{0x011, 0xeb}, {0x012, 0x07}, {0x014, 0x75}, {0x303, 0xa7},\n\t{0x428, 0x0a}, {0x429, 0x10}, {0x430, 0x00}, {0x431, 0x00},\n\t{0x432, 0x00}, {0x433, 0x01}, {0x434, 0x04}, {0x435, 0x05},\n\t{0x436, 0x07}, {0x437, 0x08}, {0x43c, 0x04}, {0x43d, 0x05},\n\t{0x43e, 0x07}, {0x43f, 0x08}, {0x440, 0x5d}, {0x441, 0x01},\n\t{0x442, 0x00}, {0x444, 0x10}, {0x445, 0x00}, {0x446, 0x00},\n\t{0x447, 0x00}, {0x448, 0x00}, {0x449, 0xf0}, {0x44a, 0x0f},\n\t{0x44b, 0x3e}, {0x44c, 0x10}, {0x44d, 0x00}, {0x44e, 0x00},\n\t{0x44f, 0x00}, {0x450, 0x00}, {0x451, 0xf0}, {0x452, 0x0f},\n\t{0x453, 0x00}, {0x456, 0x5e}, {0x460, 0x66}, {0x461, 0x66},\n\t{0x4c8, 0xff}, {0x4c9, 0x08}, {0x4cc, 0xff}, {0x4cd, 0xff},\n\t{0x4ce, 0x01}, {0x500, 0x26}, {0x501, 0xa2}, {0x502, 0x2f},\n\t{0x503, 0x00}, {0x504, 0x28}, {0x505, 0xa3}, {0x506, 0x5e},\n\t{0x507, 0x00}, {0x508, 0x2b}, {0x509, 0xa4}, {0x50a, 0x5e},\n\t{0x50b, 0x00}, {0x50c, 0x4f}, {0x50d, 0xa4}, {0x50e, 0x00},\n\t{0x50f, 0x00}, {0x512, 0x1c}, {0x514, 0x0a}, {0x516, 0x0a},\n\t{0x525, 0x4f}, {0x540, 0x12}, {0x541, 0x64}, {0x550, 0x10},\n\t{0x551, 0x10}, {0x559, 0x02}, {0x55c, 0x50}, {0x55d, 0xff},\n\t{0x605, 0x30}, {0x608, 0x0e}, {0x609, 0x2a}, {0x620, 0xff},\n\t{0x621, 0xff}, {0x622, 0xff}, {0x623, 0xff}, {0x624, 0xff},\n\t{0x625, 0xff}, {0x626, 0xff}, {0x627, 0xff}, {0x638, 0x50},\n\t{0x63c, 0x0a}, {0x63d, 0x0a}, {0x63e, 0x0e}, {0x63f, 0x0e},\n\t{0x640, 0x40}, {0x642, 0x40}, {0x643, 0x00}, {0x652, 0xc8},\n\t{0x66e, 0x05}, {0x700, 0x21}, {0x701, 0x43}, {0x702, 0x65},\n\t{0x703, 0x87}, {0x708, 0x21}, {0x709, 0x43}, {0x70a, 0x65},\n\t{0x70b, 0x87},\n\t{0xffff, 0xff},\n};\n\nstatic const struct rtl8xxxu_reg32val rtl8192eu_phy_init_table[] = {\n\t{0x800, 0x80040000}, {0x804, 0x00000003},\n\t{0x808, 0x0000fc00}, {0x80c, 0x0000000a},\n\t{0x810, 0x10001331}, {0x814, 0x020c3d10},\n\t{0x818, 0x02220385}, {0x81c, 0x00000000},\n\t{0x820, 0x01000100}, {0x824, 0x00390204},\n\t{0x828, 0x01000100}, {0x82c, 0x00390204},\n\t{0x830, 0x32323232}, {0x834, 0x30303030},\n\t{0x838, 0x30303030}, {0x83c, 0x30303030},\n\t{0x840, 0x00010000}, {0x844, 0x00010000},\n\t{0x848, 0x28282828}, {0x84c, 0x28282828},\n\t{0x850, 0x00000000}, {0x854, 0x00000000},\n\t{0x858, 0x009a009a}, {0x85c, 0x01000014},\n\t{0x860, 0x66f60000}, {0x864, 0x061f0000},\n\t{0x868, 0x30303030}, {0x86c, 0x30303030},\n\t{0x870, 0x00000000}, {0x874, 0x55004200},\n\t{0x878, 0x08080808}, {0x87c, 0x00000000},\n\t{0x880, 0xb0000c1c}, {0x884, 0x00000001},\n\t{0x888, 0x00000000}, {0x88c, 0xcc0000c0},\n\t{0x890, 0x00000800}, {0x894, 0xfffffffe},\n\t{0x898, 0x40302010}, {0x900, 0x00000000},\n\t{0x904, 0x00000023}, {0x908, 0x00000000},\n\t{0x90c, 0x81121313}, {0x910, 0x806c0001},\n\t{0x914, 0x00000001}, {0x918, 0x00000000},\n\t{0x91c, 0x00010000}, {0x924, 0x00000001},\n\t{0x928, 0x00000000}, {0x92c, 0x00000000},\n\t{0x930, 0x00000000}, {0x934, 0x00000000},\n\t{0x938, 0x00000000}, {0x93c, 0x00000000},\n\t{0x940, 0x00000000}, {0x944, 0x00000000},\n\t{0x94c, 0x00000008}, {0xa00, 0x00d0c7c8},\n\t{0xa04, 0x81ff000c}, {0xa08, 0x8c838300},\n\t{0xa0c, 0x2e68120f}, {0xa10, 0x95009b78},\n\t{0xa14, 0x1114d028}, {0xa18, 0x00881117},\n\t{0xa1c, 0x89140f00}, {0xa20, 0x1a1b0000},\n\t{0xa24, 0x090e1317}, {0xa28, 0x00000204},\n\t{0xa2c, 0x00d30000}, {0xa70, 0x101fff00},\n\t{0xa74, 0x00000007}, {0xa78, 0x00000900},\n\t{0xa7c, 0x225b0606}, {0xa80, 0x218075b1},\n\t{0xb38, 0x00000000}, {0xc00, 0x48071d40},\n\t{0xc04, 0x03a05633}, {0xc08, 0x000000e4},\n\t{0xc0c, 0x6c6c6c6c}, {0xc10, 0x08800000},\n\t{0xc14, 0x40000100}, {0xc18, 0x08800000},\n\t{0xc1c, 0x40000100}, {0xc20, 0x00000000},\n\t{0xc24, 0x00000000}, {0xc28, 0x00000000},\n\t{0xc2c, 0x00000000}, {0xc30, 0x69e9ac47},\n\t{0xc34, 0x469652af}, {0xc38, 0x49795994},\n\t{0xc3c, 0x0a97971c}, {0xc40, 0x1f7c403f},\n\t{0xc44, 0x000100b7}, {0xc48, 0xec020107},\n\t{0xc4c, 0x007f037f},\n#ifdef EXT_PA_8192EU\n\t \n\t{0xc50, 0x00340220},\n#else\n\t{0xc50, 0x00340020},\n#endif\n\t{0xc54, 0x0080801f},\n#ifdef EXT_PA_8192EU\n\t \n\t{0xc58, 0x00000220},\n#else\n\t{0xc58, 0x00000020},\n#endif\n\t{0xc5c, 0x00248492}, {0xc60, 0x00000000},\n\t{0xc64, 0x7112848b}, {0xc68, 0x47c00bff},\n\t{0xc6c, 0x00000036}, {0xc70, 0x00000600},\n\t{0xc74, 0x02013169}, {0xc78, 0x0000001f},\n\t{0xc7c, 0x00b91612},\n#ifdef EXT_PA_8192EU\n\t \n\t{0xc80, 0x2d4000b5},\n#else\n\t{0xc80, 0x40000100},\n#endif\n\t{0xc84, 0x21f60000},\n#ifdef EXT_PA_8192EU\n\t \n\t{0xc88, 0x2d4000b5},\n#else\n\t{0xc88, 0x40000100},\n#endif\n\t{0xc8c, 0xa0e40000}, {0xc90, 0x00121820},\n\t{0xc94, 0x00000000}, {0xc98, 0x00121820},\n\t{0xc9c, 0x00007f7f}, {0xca0, 0x00000000},\n\t{0xca4, 0x000300a0}, {0xca8, 0x00000000},\n\t{0xcac, 0x00000000}, {0xcb0, 0x00000000},\n\t{0xcb4, 0x00000000}, {0xcb8, 0x00000000},\n\t{0xcbc, 0x28000000}, {0xcc0, 0x00000000},\n\t{0xcc4, 0x00000000}, {0xcc8, 0x00000000},\n\t{0xccc, 0x00000000}, {0xcd0, 0x00000000},\n\t{0xcd4, 0x00000000}, {0xcd8, 0x64b22427},\n\t{0xcdc, 0x00766932}, {0xce0, 0x00222222},\n\t{0xce4, 0x00040000}, {0xce8, 0x77644302},\n\t{0xcec, 0x2f97d40c}, {0xd00, 0x00080740},\n\t{0xd04, 0x00020403}, {0xd08, 0x0000907f},\n\t{0xd0c, 0x20010201}, {0xd10, 0xa0633333},\n\t{0xd14, 0x3333bc43}, {0xd18, 0x7a8f5b6b},\n\t{0xd1c, 0x0000007f}, {0xd2c, 0xcc979975},\n\t{0xd30, 0x00000000}, {0xd34, 0x80608000},\n\t{0xd38, 0x00000000}, {0xd3c, 0x00127353},\n\t{0xd40, 0x00000000}, {0xd44, 0x00000000},\n\t{0xd48, 0x00000000}, {0xd4c, 0x00000000},\n\t{0xd50, 0x6437140a}, {0xd54, 0x00000000},\n\t{0xd58, 0x00000282}, {0xd5c, 0x30032064},\n\t{0xd60, 0x4653de68}, {0xd64, 0x04518a3c},\n\t{0xd68, 0x00002101}, {0xd6c, 0x2a201c16},\n\t{0xd70, 0x1812362e}, {0xd74, 0x322c2220},\n\t{0xd78, 0x000e3c24}, {0xd80, 0x01081008},\n\t{0xd84, 0x00000800}, {0xd88, 0xf0b50000},\n\t{0xe00, 0x30303030}, {0xe04, 0x30303030},\n\t{0xe08, 0x03903030}, {0xe10, 0x30303030},\n\t{0xe14, 0x30303030}, {0xe18, 0x30303030},\n\t{0xe1c, 0x30303030}, {0xe28, 0x00000000},\n\t{0xe30, 0x1000dc1f}, {0xe34, 0x10008c1f},\n\t{0xe38, 0x02140102}, {0xe3c, 0x681604c2},\n\t{0xe40, 0x01007c00}, {0xe44, 0x01004800},\n\t{0xe48, 0xfb000000}, {0xe4c, 0x000028d1},\n\t{0xe50, 0x1000dc1f}, {0xe54, 0x10008c1f},\n\t{0xe58, 0x02140102}, {0xe5c, 0x28160d05},\n\t{0xe60, 0x00000008}, {0xe68, 0x0fc05656},\n\t{0xe6c, 0x03c09696}, {0xe70, 0x03c09696},\n\t{0xe74, 0x0c005656}, {0xe78, 0x0c005656},\n\t{0xe7c, 0x0c005656}, {0xe80, 0x0c005656},\n\t{0xe84, 0x03c09696}, {0xe88, 0x0c005656},\n\t{0xe8c, 0x03c09696}, {0xed0, 0x03c09696},\n\t{0xed4, 0x03c09696}, {0xed8, 0x03c09696},\n\t{0xedc, 0x0000d6d6}, {0xee0, 0x0000d6d6},\n\t{0xeec, 0x0fc01616}, {0xee4, 0xb0000c1c},\n\t{0xee8, 0x00000001}, {0xf14, 0x00000003},\n\t{0xf4c, 0x00000000}, {0xf00, 0x00000300},\n\t{0xffff, 0xffffffff},\n};\n\nstatic const struct rtl8xxxu_reg32val rtl8xxx_agc_8192eu_std_table[] = {\n\t{0xc78, 0xfb000001}, {0xc78, 0xfb010001},\n\t{0xc78, 0xfb020001}, {0xc78, 0xfb030001},\n\t{0xc78, 0xfb040001}, {0xc78, 0xfb050001},\n\t{0xc78, 0xfa060001}, {0xc78, 0xf9070001},\n\t{0xc78, 0xf8080001}, {0xc78, 0xf7090001},\n\t{0xc78, 0xf60a0001}, {0xc78, 0xf50b0001},\n\t{0xc78, 0xf40c0001}, {0xc78, 0xf30d0001},\n\t{0xc78, 0xf20e0001}, {0xc78, 0xf10f0001},\n\t{0xc78, 0xf0100001}, {0xc78, 0xef110001},\n\t{0xc78, 0xee120001}, {0xc78, 0xed130001},\n\t{0xc78, 0xec140001}, {0xc78, 0xeb150001},\n\t{0xc78, 0xea160001}, {0xc78, 0xe9170001},\n\t{0xc78, 0xe8180001}, {0xc78, 0xe7190001},\n\t{0xc78, 0xc81a0001}, {0xc78, 0xc71b0001},\n\t{0xc78, 0xc61c0001}, {0xc78, 0x071d0001},\n\t{0xc78, 0x061e0001}, {0xc78, 0x051f0001},\n\t{0xc78, 0x04200001}, {0xc78, 0x03210001},\n\t{0xc78, 0xaa220001}, {0xc78, 0xa9230001},\n\t{0xc78, 0xa8240001}, {0xc78, 0xa7250001},\n\t{0xc78, 0xa6260001}, {0xc78, 0x85270001},\n\t{0xc78, 0x84280001}, {0xc78, 0x83290001},\n\t{0xc78, 0x252a0001}, {0xc78, 0x242b0001},\n\t{0xc78, 0x232c0001}, {0xc78, 0x222d0001},\n\t{0xc78, 0x672e0001}, {0xc78, 0x662f0001},\n\t{0xc78, 0x65300001}, {0xc78, 0x64310001},\n\t{0xc78, 0x63320001}, {0xc78, 0x62330001},\n\t{0xc78, 0x61340001}, {0xc78, 0x45350001},\n\t{0xc78, 0x44360001}, {0xc78, 0x43370001},\n\t{0xc78, 0x42380001}, {0xc78, 0x41390001},\n\t{0xc78, 0x403a0001}, {0xc78, 0x403b0001},\n\t{0xc78, 0x403c0001}, {0xc78, 0x403d0001},\n\t{0xc78, 0x403e0001}, {0xc78, 0x403f0001},\n\t{0xc78, 0xfb400001}, {0xc78, 0xfb410001},\n\t{0xc78, 0xfb420001}, {0xc78, 0xfb430001},\n\t{0xc78, 0xfb440001}, {0xc78, 0xfb450001},\n\t{0xc78, 0xfa460001}, {0xc78, 0xf9470001},\n\t{0xc78, 0xf8480001}, {0xc78, 0xf7490001},\n\t{0xc78, 0xf64a0001}, {0xc78, 0xf54b0001},\n\t{0xc78, 0xf44c0001}, {0xc78, 0xf34d0001},\n\t{0xc78, 0xf24e0001}, {0xc78, 0xf14f0001},\n\t{0xc78, 0xf0500001}, {0xc78, 0xef510001},\n\t{0xc78, 0xee520001}, {0xc78, 0xed530001},\n\t{0xc78, 0xec540001}, {0xc78, 0xeb550001},\n\t{0xc78, 0xea560001}, {0xc78, 0xe9570001},\n\t{0xc78, 0xe8580001}, {0xc78, 0xe7590001},\n\t{0xc78, 0xe65a0001}, {0xc78, 0xe55b0001},\n\t{0xc78, 0xe45c0001}, {0xc78, 0xe35d0001},\n\t{0xc78, 0xe25e0001}, {0xc78, 0xe15f0001},\n\t{0xc78, 0x8a600001}, {0xc78, 0x89610001},\n\t{0xc78, 0x88620001}, {0xc78, 0x87630001},\n\t{0xc78, 0x86640001}, {0xc78, 0x85650001},\n\t{0xc78, 0x84660001}, {0xc78, 0x83670001},\n\t{0xc78, 0x82680001}, {0xc78, 0x6b690001},\n\t{0xc78, 0x6a6a0001}, {0xc78, 0x696b0001},\n\t{0xc78, 0x686c0001}, {0xc78, 0x676d0001},\n\t{0xc78, 0x666e0001}, {0xc78, 0x656f0001},\n\t{0xc78, 0x64700001}, {0xc78, 0x63710001},\n\t{0xc78, 0x62720001}, {0xc78, 0x61730001},\n\t{0xc78, 0x49740001}, {0xc78, 0x48750001},\n\t{0xc78, 0x47760001}, {0xc78, 0x46770001},\n\t{0xc78, 0x45780001}, {0xc78, 0x44790001},\n\t{0xc78, 0x437a0001}, {0xc78, 0x427b0001},\n\t{0xc78, 0x417c0001}, {0xc78, 0x407d0001},\n\t{0xc78, 0x407e0001}, {0xc78, 0x407f0001},\n\t{0xc50, 0x00040022}, {0xc50, 0x00040020},\n\t{0xffff, 0xffffffff}\n};\n\nstatic const struct rtl8xxxu_reg32val rtl8xxx_agc_8192eu_highpa_table[] = {\n\t{0xc78, 0xfa000001}, {0xc78, 0xf9010001},\n\t{0xc78, 0xf8020001}, {0xc78, 0xf7030001},\n\t{0xc78, 0xf6040001}, {0xc78, 0xf5050001},\n\t{0xc78, 0xf4060001}, {0xc78, 0xf3070001},\n\t{0xc78, 0xf2080001}, {0xc78, 0xf1090001},\n\t{0xc78, 0xf00a0001}, {0xc78, 0xef0b0001},\n\t{0xc78, 0xee0c0001}, {0xc78, 0xed0d0001},\n\t{0xc78, 0xec0e0001}, {0xc78, 0xeb0f0001},\n\t{0xc78, 0xea100001}, {0xc78, 0xe9110001},\n\t{0xc78, 0xe8120001}, {0xc78, 0xe7130001},\n\t{0xc78, 0xe6140001}, {0xc78, 0xe5150001},\n\t{0xc78, 0xe4160001}, {0xc78, 0xe3170001},\n\t{0xc78, 0xe2180001}, {0xc78, 0xe1190001},\n\t{0xc78, 0x8a1a0001}, {0xc78, 0x891b0001},\n\t{0xc78, 0x881c0001}, {0xc78, 0x871d0001},\n\t{0xc78, 0x861e0001}, {0xc78, 0x851f0001},\n\t{0xc78, 0x84200001}, {0xc78, 0x83210001},\n\t{0xc78, 0x82220001}, {0xc78, 0x6a230001},\n\t{0xc78, 0x69240001}, {0xc78, 0x68250001},\n\t{0xc78, 0x67260001}, {0xc78, 0x66270001},\n\t{0xc78, 0x65280001}, {0xc78, 0x64290001},\n\t{0xc78, 0x632a0001}, {0xc78, 0x622b0001},\n\t{0xc78, 0x612c0001}, {0xc78, 0x602d0001},\n\t{0xc78, 0x472e0001}, {0xc78, 0x462f0001},\n\t{0xc78, 0x45300001}, {0xc78, 0x44310001},\n\t{0xc78, 0x43320001}, {0xc78, 0x42330001},\n\t{0xc78, 0x41340001}, {0xc78, 0x40350001},\n\t{0xc78, 0x40360001}, {0xc78, 0x40370001},\n\t{0xc78, 0x40380001}, {0xc78, 0x40390001},\n\t{0xc78, 0x403a0001}, {0xc78, 0x403b0001},\n\t{0xc78, 0x403c0001}, {0xc78, 0x403d0001},\n\t{0xc78, 0x403e0001}, {0xc78, 0x403f0001},\n\t{0xc78, 0xfa400001}, {0xc78, 0xf9410001},\n\t{0xc78, 0xf8420001}, {0xc78, 0xf7430001},\n\t{0xc78, 0xf6440001}, {0xc78, 0xf5450001},\n\t{0xc78, 0xf4460001}, {0xc78, 0xf3470001},\n\t{0xc78, 0xf2480001}, {0xc78, 0xf1490001},\n\t{0xc78, 0xf04a0001}, {0xc78, 0xef4b0001},\n\t{0xc78, 0xee4c0001}, {0xc78, 0xed4d0001},\n\t{0xc78, 0xec4e0001}, {0xc78, 0xeb4f0001},\n\t{0xc78, 0xea500001}, {0xc78, 0xe9510001},\n\t{0xc78, 0xe8520001}, {0xc78, 0xe7530001},\n\t{0xc78, 0xe6540001}, {0xc78, 0xe5550001},\n\t{0xc78, 0xe4560001}, {0xc78, 0xe3570001},\n\t{0xc78, 0xe2580001}, {0xc78, 0xe1590001},\n\t{0xc78, 0x8a5a0001}, {0xc78, 0x895b0001},\n\t{0xc78, 0x885c0001}, {0xc78, 0x875d0001},\n\t{0xc78, 0x865e0001}, {0xc78, 0x855f0001},\n\t{0xc78, 0x84600001}, {0xc78, 0x83610001},\n\t{0xc78, 0x82620001}, {0xc78, 0x6a630001},\n\t{0xc78, 0x69640001}, {0xc78, 0x68650001},\n\t{0xc78, 0x67660001}, {0xc78, 0x66670001},\n\t{0xc78, 0x65680001}, {0xc78, 0x64690001},\n\t{0xc78, 0x636a0001}, {0xc78, 0x626b0001},\n\t{0xc78, 0x616c0001}, {0xc78, 0x606d0001},\n\t{0xc78, 0x476e0001}, {0xc78, 0x466f0001},\n\t{0xc78, 0x45700001}, {0xc78, 0x44710001},\n\t{0xc78, 0x43720001}, {0xc78, 0x42730001},\n\t{0xc78, 0x41740001}, {0xc78, 0x40750001},\n\t{0xc78, 0x40760001}, {0xc78, 0x40770001},\n\t{0xc78, 0x40780001}, {0xc78, 0x40790001},\n\t{0xc78, 0x407a0001}, {0xc78, 0x407b0001},\n\t{0xc78, 0x407c0001}, {0xc78, 0x407d0001},\n\t{0xc78, 0x407e0001}, {0xc78, 0x407f0001},\n\t{0xc50, 0x00040222}, {0xc50, 0x00040220},\n\t{0xffff, 0xffffffff}\n};\n\nstatic const struct rtl8xxxu_rfregval rtl8192eu_radioa_init_table[] = {\n\t{0x7f, 0x00000082}, {0x81, 0x0003fc00},\n\t{0x00, 0x00030000}, {0x08, 0x00008400},\n\t{0x18, 0x00000407}, {0x19, 0x00000012},\n\t{0x1b, 0x00000064}, {0x1e, 0x00080009},\n\t{0x1f, 0x00000880}, {0x2f, 0x0001a060},\n\t{0x3f, 0x00000000}, {0x42, 0x000060c0},\n\t{0x57, 0x000d0000}, {0x58, 0x000be180},\n\t{0x67, 0x00001552}, {0x83, 0x00000000},\n\t{0xb0, 0x000ff9f1}, {0xb1, 0x00055418},\n\t{0xb2, 0x0008cc00}, {0xb4, 0x00043083},\n\t{0xb5, 0x00008166}, {0xb6, 0x0000803e},\n\t{0xb7, 0x0001c69f}, {0xb8, 0x0000407f},\n\t{0xb9, 0x00080001}, {0xba, 0x00040001},\n\t{0xbb, 0x00000400}, {0xbf, 0x000c0000},\n\t{0xc2, 0x00002400}, {0xc3, 0x00000009},\n\t{0xc4, 0x00040c91}, {0xc5, 0x00099999},\n\t{0xc6, 0x000000a3}, {0xc7, 0x00088820},\n\t{0xc8, 0x00076c06}, {0xc9, 0x00000000},\n\t{0xca, 0x00080000}, {0xdf, 0x00000180},\n\t{0xef, 0x000001a0}, {0x51, 0x00069545},\n\t{0x52, 0x0007e45e}, {0x53, 0x00000071},\n\t{0x56, 0x00051ff3}, {0x35, 0x000000a8},\n\t{0x35, 0x000001e2}, {0x35, 0x000002a8},\n\t{0x36, 0x00001c24}, {0x36, 0x00009c24},\n\t{0x36, 0x00011c24}, {0x36, 0x00019c24},\n\t{0x18, 0x00000c07}, {0x5a, 0x00048000},\n\t{0x19, 0x000739d0},\n#ifdef EXT_PA_8192EU\n\t \n\t{0x34, 0x0000a093}, {0x34, 0x0000908f},\n\t{0x34, 0x0000808c}, {0x34, 0x0000704d},\n\t{0x34, 0x0000604a}, {0x34, 0x00005047},\n\t{0x34, 0x0000400a}, {0x34, 0x00003007},\n\t{0x34, 0x00002004}, {0x34, 0x00001001},\n\t{0x34, 0x00000000},\n#else\n\t \n\t{0x34, 0x0000add7}, {0x34, 0x00009dd4},\n\t{0x34, 0x00008dd1}, {0x34, 0x00007dce},\n\t{0x34, 0x00006dcb}, {0x34, 0x00005dc8},\n\t{0x34, 0x00004dc5}, {0x34, 0x000034cc},\n\t{0x34, 0x0000244f}, {0x34, 0x0000144c},\n\t{0x34, 0x00000014},\n#endif\n\t{0x00, 0x00030159},\n\t{0x84, 0x00068180},\n\t{0x86, 0x0000014e},\n\t{0x87, 0x00048e00},\n\t{0x8e, 0x00065540},\n\t{0x8f, 0x00088000},\n\t{0xef, 0x000020a0},\n#ifdef EXT_PA_8192EU\n\t \n\t{0x3b, 0x000f07b0},\n#else\n\t{0x3b, 0x000f02b0},\n#endif\n\t{0x3b, 0x000ef7b0}, {0x3b, 0x000d4fb0},\n\t{0x3b, 0x000cf060}, {0x3b, 0x000b0090},\n\t{0x3b, 0x000a0080}, {0x3b, 0x00090080},\n\t{0x3b, 0x0008f780},\n#ifdef EXT_PA_8192EU\n\t \n\t{0x3b, 0x000787b0},\n#else\n\t{0x3b, 0x00078730},\n#endif\n\t{0x3b, 0x00060fb0}, {0x3b, 0x0005ffa0},\n\t{0x3b, 0x00040620}, {0x3b, 0x00037090},\n\t{0x3b, 0x00020080}, {0x3b, 0x0001f060},\n\t{0x3b, 0x0000ffb0}, {0xef, 0x000000a0},\n\t{0xfe, 0x00000000}, {0x18, 0x0000fc07},\n\t{0xfe, 0x00000000}, {0xfe, 0x00000000},\n\t{0xfe, 0x00000000}, {0xfe, 0x00000000},\n\t{0x1e, 0x00000001}, {0x1f, 0x00080000},\n\t{0x00, 0x00033e70},\n\t{0xff, 0xffffffff}\n};\n\nstatic const struct rtl8xxxu_rfregval rtl8192eu_radiob_init_table[] = {\n\t{0x7f, 0x00000082}, {0x81, 0x0003fc00},\n\t{0x00, 0x00030000}, {0x08, 0x00008400},\n\t{0x18, 0x00000407}, {0x19, 0x00000012},\n\t{0x1b, 0x00000064}, {0x1e, 0x00080009},\n\t{0x1f, 0x00000880}, {0x2f, 0x0001a060},\n\t{0x3f, 0x00000000}, {0x42, 0x000060c0},\n\t{0x57, 0x000d0000}, {0x58, 0x000be180},\n\t{0x67, 0x00001552}, {0x7f, 0x00000082},\n\t{0x81, 0x0003f000}, {0x83, 0x00000000},\n\t{0xdf, 0x00000180}, {0xef, 0x000001a0},\n\t{0x51, 0x00069545}, {0x52, 0x0007e42e},\n\t{0x53, 0x00000071}, {0x56, 0x00051ff3},\n\t{0x35, 0x000000a8}, {0x35, 0x000001e0},\n\t{0x35, 0x000002a8}, {0x36, 0x00001ca8},\n\t{0x36, 0x00009c24}, {0x36, 0x00011c24},\n\t{0x36, 0x00019c24}, {0x18, 0x00000c07},\n\t{0x5a, 0x00048000}, {0x19, 0x000739d0},\n#ifdef EXT_PA_8192EU\n\t \n\t{0x34, 0x0000a093}, {0x34, 0x0000908f},\n\t{0x34, 0x0000808c}, {0x34, 0x0000704d},\n\t{0x34, 0x0000604a}, {0x34, 0x00005047},\n\t{0x34, 0x0000400a}, {0x34, 0x00003007},\n\t{0x34, 0x00002004}, {0x34, 0x00001001},\n\t{0x34, 0x00000000},\n#else\n\t{0x34, 0x0000add7}, {0x34, 0x00009dd4},\n\t{0x34, 0x00008dd1}, {0x34, 0x00007dce},\n\t{0x34, 0x00006dcb}, {0x34, 0x00005dc8},\n\t{0x34, 0x00004dc5}, {0x34, 0x000034cc},\n\t{0x34, 0x0000244f}, {0x34, 0x0000144c},\n\t{0x34, 0x00000014},\n#endif\n\t{0x00, 0x00030159}, {0x84, 0x00068180},\n\t{0x86, 0x000000ce}, {0x87, 0x00048a00},\n\t{0x8e, 0x00065540}, {0x8f, 0x00088000},\n\t{0xef, 0x000020a0},\n#ifdef EXT_PA_8192EU\n\t \n\t{0x3b, 0x000f07b0},\n#else\n\t{0x3b, 0x000f02b0},\n#endif\n\n\t{0x3b, 0x000ef7b0}, {0x3b, 0x000d4fb0},\n\t{0x3b, 0x000cf060}, {0x3b, 0x000b0090},\n\t{0x3b, 0x000a0080}, {0x3b, 0x00090080},\n\t{0x3b, 0x0008f780},\n#ifdef EXT_PA_8192EU\n\t \n\t{0x3b, 0x000787b0},\n#else\n\t{0x3b, 0x00078730},\n#endif\n\t{0x3b, 0x00060fb0}, {0x3b, 0x0005ffa0},\n\t{0x3b, 0x00040620}, {0x3b, 0x00037090},\n\t{0x3b, 0x00020080}, {0x3b, 0x0001f060},\n\t{0x3b, 0x0000ffb0}, {0xef, 0x000000a0},\n\t{0x00, 0x00010159}, {0xfe, 0x00000000},\n\t{0xfe, 0x00000000}, {0xfe, 0x00000000},\n\t{0xfe, 0x00000000}, {0x1e, 0x00000001},\n\t{0x1f, 0x00080000}, {0x00, 0x00033e70},\n\t{0xff, 0xffffffff}\n};\n\nstatic int rtl8192eu_identify_chip(struct rtl8xxxu_priv *priv)\n{\n\tstruct device *dev = &priv->udev->dev;\n\tu32 val32, bonding, sys_cfg, vendor;\n\tint ret = 0;\n\n\tsys_cfg = rtl8xxxu_read32(priv, REG_SYS_CFG);\n\tpriv->chip_cut = u32_get_bits(sys_cfg, SYS_CFG_CHIP_VERSION_MASK);\n\tif (sys_cfg & SYS_CFG_TRP_VAUX_EN) {\n\t\tdev_info(dev, \"Unsupported test chip\\n\");\n\t\tret = -ENOTSUPP;\n\t\tgoto out;\n\t}\n\n\tbonding = rtl8xxxu_read32(priv, REG_HPON_FSM);\n\tbonding &= HPON_FSM_BONDING_MASK;\n\tif (bonding == HPON_FSM_BONDING_1T2R) {\n\t\tstrscpy(priv->chip_name, \"8191EU\", sizeof(priv->chip_name));\n\t\tpriv->tx_paths = 1;\n\t\tpriv->rtl_chip = RTL8191E;\n\t} else {\n\t\tstrscpy(priv->chip_name, \"8192EU\", sizeof(priv->chip_name));\n\t\tpriv->tx_paths = 2;\n\t\tpriv->rtl_chip = RTL8192E;\n\t}\n\tpriv->rf_paths = 2;\n\tpriv->rx_paths = 2;\n\tpriv->has_wifi = 1;\n\n\tvendor = sys_cfg & SYS_CFG_VENDOR_EXT_MASK;\n\trtl8xxxu_identify_vendor_2bits(priv, vendor);\n\n\tval32 = rtl8xxxu_read32(priv, REG_GPIO_OUTSTS);\n\tpriv->rom_rev = u32_get_bits(val32, GPIO_RF_RL_ID);\n\n\trtl8xxxu_config_endpoints_sie(priv);\n\n\t \n\tif (!priv->ep_tx_count)\n\t\tret = rtl8xxxu_config_endpoints_no_sie(priv);\n\nout:\n\treturn ret;\n}\n\nstatic void\nrtl8192e_set_tx_power(struct rtl8xxxu_priv *priv, int channel, bool ht40)\n{\n\tu32 val32, ofdm, mcs;\n\tu8 cck, ofdmbase, mcsbase;\n\tint group, tx_idx;\n\n\ttx_idx = 0;\n\tgroup = rtl8xxxu_gen2_channel_to_group(channel);\n\n\tcck = priv->cck_tx_power_index_A[group];\n\n\tval32 = rtl8xxxu_read32(priv, REG_TX_AGC_A_CCK1_MCS32);\n\tval32 &= 0xffff00ff;\n\tval32 |= (cck << 8);\n\trtl8xxxu_write32(priv, REG_TX_AGC_A_CCK1_MCS32, val32);\n\n\tval32 = rtl8xxxu_read32(priv, REG_TX_AGC_B_CCK11_A_CCK2_11);\n\tval32 &= 0xff;\n\tval32 |= ((cck << 8) | (cck << 16) | (cck << 24));\n\trtl8xxxu_write32(priv, REG_TX_AGC_B_CCK11_A_CCK2_11, val32);\n\n\tofdmbase = priv->ht40_1s_tx_power_index_A[group];\n\tofdmbase += priv->ofdm_tx_power_diff[tx_idx].a;\n\tofdm = ofdmbase | ofdmbase << 8 | ofdmbase << 16 | ofdmbase << 24;\n\n\trtl8xxxu_write32(priv, REG_TX_AGC_A_RATE18_06, ofdm);\n\trtl8xxxu_write32(priv, REG_TX_AGC_A_RATE54_24, ofdm);\n\n\tmcsbase = priv->ht40_1s_tx_power_index_A[group];\n\tif (ht40)\n\t\tmcsbase += priv->ht40_tx_power_diff[tx_idx++].a;\n\telse\n\t\tmcsbase += priv->ht20_tx_power_diff[tx_idx++].a;\n\tmcs = mcsbase | mcsbase << 8 | mcsbase << 16 | mcsbase << 24;\n\n\trtl8xxxu_write32(priv, REG_TX_AGC_A_MCS03_MCS00, mcs);\n\trtl8xxxu_write32(priv, REG_TX_AGC_A_MCS07_MCS04, mcs);\n\trtl8xxxu_write32(priv, REG_TX_AGC_A_MCS11_MCS08, mcs);\n\trtl8xxxu_write32(priv, REG_TX_AGC_A_MCS15_MCS12, mcs);\n\n\tif (priv->tx_paths > 1) {\n\t\tcck = priv->cck_tx_power_index_B[group];\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_TX_AGC_B_CCK1_55_MCS32);\n\t\tval32 &= 0xff;\n\t\tval32 |= ((cck << 8) | (cck << 16) | (cck << 24));\n\t\trtl8xxxu_write32(priv, REG_TX_AGC_B_CCK1_55_MCS32, val32);\n\n\t\tval32 = rtl8xxxu_read32(priv, REG_TX_AGC_B_CCK11_A_CCK2_11);\n\t\tval32 &= 0xffffff00;\n\t\tval32 |= cck;\n\t\trtl8xxxu_write32(priv, REG_TX_AGC_B_CCK11_A_CCK2_11, val32);\n\n\t\tofdmbase = priv->ht40_1s_tx_power_index_B[group];\n\t\tofdmbase += priv->ofdm_tx_power_diff[tx_idx].b;\n\t\tofdm = ofdmbase | ofdmbase << 8 |\n\t\t\tofdmbase << 16 | ofdmbase << 24;\n\n\t\trtl8xxxu_write32(priv, REG_TX_AGC_B_RATE18_06, ofdm);\n\t\trtl8xxxu_write32(priv, REG_TX_AGC_B_RATE54_24, ofdm);\n\n\t\tmcsbase = priv->ht40_1s_tx_power_index_B[group];\n\t\tif (ht40)\n\t\t\tmcsbase += priv->ht40_tx_power_diff[tx_idx++].b;\n\t\telse\n\t\t\tmcsbase += priv->ht20_tx_power_diff[tx_idx++].b;\n\t\tmcs = mcsbase | mcsbase << 8 | mcsbase << 16 | mcsbase << 24;\n\n\t\trtl8xxxu_write32(priv, REG_TX_AGC_B_MCS03_MCS00, mcs);\n\t\trtl8xxxu_write32(priv, REG_TX_AGC_B_MCS07_MCS04, mcs);\n\t\trtl8xxxu_write32(priv, REG_TX_AGC_B_MCS11_MCS08, mcs);\n\t\trtl8xxxu_write32(priv, REG_TX_AGC_B_MCS15_MCS12, mcs);\n\t}\n}\n\nstatic int rtl8192eu_parse_efuse(struct rtl8xxxu_priv *priv)\n{\n\tstruct rtl8192eu_efuse *efuse = &priv->efuse_wifi.efuse8192eu;\n\tint i;\n\n\tif (efuse->rtl_id != cpu_to_le16(0x8129))\n\t\treturn -EINVAL;\n\n\tether_addr_copy(priv->mac_addr, efuse->mac_addr);\n\n\tmemcpy(priv->cck_tx_power_index_A, efuse->tx_power_index_A.cck_base,\n\t       sizeof(efuse->tx_power_index_A.cck_base));\n\tmemcpy(priv->cck_tx_power_index_B, efuse->tx_power_index_B.cck_base,\n\t       sizeof(efuse->tx_power_index_B.cck_base));\n\n\tmemcpy(priv->ht40_1s_tx_power_index_A,\n\t       efuse->tx_power_index_A.ht40_base,\n\t       sizeof(efuse->tx_power_index_A.ht40_base));\n\tmemcpy(priv->ht40_1s_tx_power_index_B,\n\t       efuse->tx_power_index_B.ht40_base,\n\t       sizeof(efuse->tx_power_index_B.ht40_base));\n\n\tpriv->ht20_tx_power_diff[0].a =\n\t\tefuse->tx_power_index_A.ht20_ofdm_1s_diff.b;\n\tpriv->ht20_tx_power_diff[0].b =\n\t\tefuse->tx_power_index_B.ht20_ofdm_1s_diff.b;\n\n\tpriv->ht40_tx_power_diff[0].a = 0;\n\tpriv->ht40_tx_power_diff[0].b = 0;\n\n\tfor (i = 1; i < RTL8723B_TX_COUNT; i++) {\n\t\tpriv->ofdm_tx_power_diff[i].a =\n\t\t\tefuse->tx_power_index_A.pwr_diff[i - 1].ofdm;\n\t\tpriv->ofdm_tx_power_diff[i].b =\n\t\t\tefuse->tx_power_index_B.pwr_diff[i - 1].ofdm;\n\n\t\tpriv->ht20_tx_power_diff[i].a =\n\t\t\tefuse->tx_power_index_A.pwr_diff[i - 1].ht20;\n\t\tpriv->ht20_tx_power_diff[i].b =\n\t\t\tefuse->tx_power_index_B.pwr_diff[i - 1].ht20;\n\n\t\tpriv->ht40_tx_power_diff[i].a =\n\t\t\tefuse->tx_power_index_A.pwr_diff[i - 1].ht40;\n\t\tpriv->ht40_tx_power_diff[i].b =\n\t\t\tefuse->tx_power_index_B.pwr_diff[i - 1].ht40;\n\t}\n\n\tpriv->default_crystal_cap = priv->efuse_wifi.efuse8192eu.xtal_k & 0x3f;\n\n\treturn 0;\n}\n\nstatic int rtl8192eu_load_firmware(struct rtl8xxxu_priv *priv)\n{\n\tconst char *fw_name;\n\tint ret;\n\n\tfw_name = \"rtlwifi/rtl8192eu_nic.bin\";\n\n\tret = rtl8xxxu_load_firmware(priv, fw_name);\n\n\treturn ret;\n}\n\nstatic void rtl8192eu_init_phy_bb(struct rtl8xxxu_priv *priv)\n{\n\tu8 val8;\n\tu16 val16;\n\n\tval16 = rtl8xxxu_read16(priv, REG_SYS_FUNC);\n\tval16 |= SYS_FUNC_BB_GLB_RSTN | SYS_FUNC_BBRSTB | SYS_FUNC_DIO_RF;\n\trtl8xxxu_write16(priv, REG_SYS_FUNC, val16);\n\n\t \n\tval8 = RF_ENABLE | RF_RSTB | RF_SDMRSTB;\n\trtl8xxxu_write8(priv, REG_RF_CTRL, val8);\n\n\tval16 = rtl8xxxu_read16(priv, REG_SYS_FUNC);\n\tval16 |= (SYS_FUNC_USBA | SYS_FUNC_USBD | SYS_FUNC_DIO_RF |\n\t\t  SYS_FUNC_BB_GLB_RSTN | SYS_FUNC_BBRSTB);\n\trtl8xxxu_write16(priv, REG_SYS_FUNC, val16);\n\tval8 = RF_ENABLE | RF_RSTB | RF_SDMRSTB;\n\trtl8xxxu_write8(priv, REG_RF_CTRL, val8);\n\trtl8xxxu_init_phy_regs(priv, rtl8192eu_phy_init_table);\n\n\tif (priv->hi_pa)\n\t\trtl8xxxu_init_phy_regs(priv, rtl8xxx_agc_8192eu_highpa_table);\n\telse\n\t\trtl8xxxu_init_phy_regs(priv, rtl8xxx_agc_8192eu_std_table);\n}\n\nstatic int rtl8192eu_init_phy_rf(struct rtl8xxxu_priv *priv)\n{\n\tint ret;\n\n\tret = rtl8xxxu_init_phy_rf(priv, rtl8192eu_radioa_init_table, RF_A);\n\tif (ret)\n\t\tgoto exit;\n\n\tret = rtl8xxxu_init_phy_rf(priv, rtl8192eu_radiob_init_table, RF_B);\n\nexit:\n\treturn ret;\n}\n\nstatic int rtl8192eu_iqk_path_a(struct rtl8xxxu_priv *priv)\n{\n\tu32 reg_eac, reg_e94, reg_e9c;\n\tint result = 0;\n\n\t \n\trtl8xxxu_write32(priv, REG_FPGA0_IQK, 0x00000000);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_GAIN_CCA, 0x00180);\n\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_WE_LUT, 0x800a0);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_RCK_OS, 0x20000);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_TXPA_G1, 0x0000f);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_TXPA_G2, 0x07f77);\n\n\trtl8xxxu_write32(priv, REG_FPGA0_IQK, 0x80800000);\n\n\t \n\trtl8xxxu_write32(priv, REG_TX_IQK_TONE_A, 0x18008c1c);\n\trtl8xxxu_write32(priv, REG_RX_IQK_TONE_A, 0x38008c1c);\n\trtl8xxxu_write32(priv, REG_TX_IQK_TONE_B, 0x38008c1c);\n\trtl8xxxu_write32(priv, REG_RX_IQK_TONE_B, 0x38008c1c);\n\n\trtl8xxxu_write32(priv, REG_TX_IQK_PI_A, 0x82140303);\n\trtl8xxxu_write32(priv, REG_RX_IQK_PI_A, 0x68160000);\n\n\t \n\trtl8xxxu_write32(priv, REG_IQK_AGC_RSP, 0x00462911);\n\n\t \n\trtl8xxxu_write32(priv, REG_IQK_AGC_PTS, 0xf9000000);\n\trtl8xxxu_write32(priv, REG_IQK_AGC_PTS, 0xf8000000);\n\n\tmdelay(10);\n\n\t \n\treg_eac = rtl8xxxu_read32(priv, REG_RX_POWER_AFTER_IQK_A_2);\n\treg_e94 = rtl8xxxu_read32(priv, REG_TX_POWER_BEFORE_IQK_A);\n\treg_e9c = rtl8xxxu_read32(priv, REG_TX_POWER_AFTER_IQK_A);\n\n\tif (!(reg_eac & BIT(28)) &&\n\t    ((reg_e94 & 0x03ff0000) != 0x01420000) &&\n\t    ((reg_e9c & 0x03ff0000) != 0x00420000))\n\t\tresult |= 0x01;\n\n\treturn result;\n}\n\nstatic int rtl8192eu_rx_iqk_path_a(struct rtl8xxxu_priv *priv)\n{\n\tu32 reg_ea4, reg_eac, reg_e94, reg_e9c, val32;\n\tint result = 0;\n\n\t \n\trtl8xxxu_write32(priv, REG_FPGA0_IQK, 0x00);\n\n\t \n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_WE_LUT, 0x800a0);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_RCK_OS, 0x30000);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_TXPA_G1, 0x0000f);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_TXPA_G2, 0xf1173);\n\n\trtl8xxxu_write_rfreg(priv, RF_B, RF6052_REG_WE_LUT, 0x800a0);\n\trtl8xxxu_write_rfreg(priv, RF_B, RF6052_REG_RCK_OS, 0x30000);\n\trtl8xxxu_write_rfreg(priv, RF_B, RF6052_REG_TXPA_G1, 0x0000f);\n\trtl8xxxu_write_rfreg(priv, RF_B, RF6052_REG_TXPA_G2, 0xf1173);\n\n\t \n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_GAIN_CCA, 0x00980);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_PAD_TXG, 0x511e0);\n\n\t \n\trtl8xxxu_write32(priv, REG_FPGA0_IQK, 0x80800000);\n\n\t \n\trtl8xxxu_write32(priv, REG_TX_IQK, 0x01007c00);\n\trtl8xxxu_write32(priv, REG_RX_IQK, 0x01004800);\n\n\t \n\trtl8xxxu_write32(priv, REG_TX_IQK_TONE_A, 0x18008c1c);\n\trtl8xxxu_write32(priv, REG_RX_IQK_TONE_A, 0x38008c1c);\n\trtl8xxxu_write32(priv, REG_TX_IQK_TONE_B, 0x38008c1c);\n\trtl8xxxu_write32(priv, REG_RX_IQK_TONE_B, 0x38008c1c);\n\n\trtl8xxxu_write32(priv, REG_TX_IQK_PI_A, 0x8216031f);\n\trtl8xxxu_write32(priv, REG_RX_IQK_PI_A, 0x6816031f);\n\n\t \n\trtl8xxxu_write32(priv, REG_IQK_AGC_RSP, 0x0046a911);\n\n\t \n\trtl8xxxu_write32(priv, REG_IQK_AGC_PTS, 0xf9000000);\n\trtl8xxxu_write32(priv, REG_IQK_AGC_PTS, 0xf8000000);\n\n\tmdelay(10);\n\n\t \n\treg_eac = rtl8xxxu_read32(priv, REG_RX_POWER_AFTER_IQK_A_2);\n\treg_e94 = rtl8xxxu_read32(priv, REG_TX_POWER_BEFORE_IQK_A);\n\treg_e9c = rtl8xxxu_read32(priv, REG_TX_POWER_AFTER_IQK_A);\n\n\tif (!(reg_eac & BIT(28)) &&\n\t    ((reg_e94 & 0x03ff0000) != 0x01420000) &&\n\t    ((reg_e9c & 0x03ff0000) != 0x00420000)) {\n\t\tresult |= 0x01;\n\t} else {\n\t\t \n\t\trtl8xxxu_write32(priv, REG_FPGA0_IQK, 0x00000000);\n\t\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_GAIN_CCA, 0x180);\n\t\tgoto out;\n\t}\n\n\tval32 = 0x80007c00 |\n\t\t(reg_e94 & 0x03ff0000) | ((reg_e9c >> 16) & 0x03ff);\n\trtl8xxxu_write32(priv, REG_TX_IQK, val32);\n\n\t \n\trtl8xxxu_write32(priv, REG_FPGA0_IQK, 0x00000000);\n\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_WE_LUT, 0x800a0);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_RCK_OS, 0x30000);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_TXPA_G1, 0x0000f);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_TXPA_G2, 0xf7ff2);\n\n\trtl8xxxu_write_rfreg(priv, RF_B, RF6052_REG_WE_LUT, 0x800a0);\n\trtl8xxxu_write_rfreg(priv, RF_B, RF6052_REG_RCK_OS, 0x30000);\n\trtl8xxxu_write_rfreg(priv, RF_B, RF6052_REG_TXPA_G1, 0x0000f);\n\trtl8xxxu_write_rfreg(priv, RF_B, RF6052_REG_TXPA_G2, 0xf7ff2);\n\n\t \n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_GAIN_CCA, 0x00980);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_PAD_TXG, 0x510e0);\n\n\t \n\trtl8xxxu_write32(priv, REG_FPGA0_IQK, 0x80800000);\n\n\t \n\trtl8xxxu_write32(priv, REG_RX_IQK, 0x01004800);\n\n\t \n\trtl8xxxu_write32(priv, REG_TX_IQK_TONE_A, 0x38008c1c);\n\trtl8xxxu_write32(priv, REG_RX_IQK_TONE_A, 0x18008c1c);\n\trtl8xxxu_write32(priv, REG_TX_IQK_TONE_B, 0x38008c1c);\n\trtl8xxxu_write32(priv, REG_RX_IQK_TONE_B, 0x38008c1c);\n\n\trtl8xxxu_write32(priv, REG_TX_IQK_PI_A, 0x821608ff);\n\trtl8xxxu_write32(priv, REG_RX_IQK_PI_A, 0x281608ff);\n\n\t \n\trtl8xxxu_write32(priv, REG_IQK_AGC_RSP, 0x0046a891);\n\n\t \n\trtl8xxxu_write32(priv, REG_IQK_AGC_PTS, 0xf9000000);\n\trtl8xxxu_write32(priv, REG_IQK_AGC_PTS, 0xf8000000);\n\n\tmdelay(10);\n\n\treg_eac = rtl8xxxu_read32(priv, REG_RX_POWER_AFTER_IQK_A_2);\n\treg_ea4 = rtl8xxxu_read32(priv, REG_RX_POWER_BEFORE_IQK_A_2);\n\n\trtl8xxxu_write32(priv, REG_FPGA0_IQK, 0x00000000);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_GAIN_CCA, 0x180);\n\n\tif (!(reg_eac & BIT(27)) &&\n\t    ((reg_ea4 & 0x03ff0000) != 0x01320000) &&\n\t    ((reg_eac & 0x03ff0000) != 0x00360000))\n\t\tresult |= 0x02;\n\telse\n\t\tdev_warn(&priv->udev->dev, \"%s: Path A RX IQK failed!\\n\",\n\t\t\t __func__);\n\nout:\n\treturn result;\n}\n\nstatic int rtl8192eu_iqk_path_b(struct rtl8xxxu_priv *priv)\n{\n\tu32 reg_eac, reg_eb4, reg_ebc;\n\tint result = 0;\n\n\trtl8xxxu_write32(priv, REG_FPGA0_IQK, 0x00000000);\n\trtl8xxxu_write_rfreg(priv, RF_B, RF6052_REG_GAIN_CCA, 0x00180);\n\n\trtl8xxxu_write_rfreg(priv, RF_B, RF6052_REG_WE_LUT, 0x800a0);\n\trtl8xxxu_write_rfreg(priv, RF_B, RF6052_REG_RCK_OS, 0x20000);\n\trtl8xxxu_write_rfreg(priv, RF_B, RF6052_REG_TXPA_G1, 0x0000f);\n\trtl8xxxu_write_rfreg(priv, RF_B, RF6052_REG_TXPA_G2, 0x07f77);\n\n\trtl8xxxu_write32(priv, REG_FPGA0_IQK, 0x80800000);\n\n\t \n\trtl8xxxu_write32(priv, REG_TX_IQK_TONE_A, 0x38008c1c);\n\trtl8xxxu_write32(priv, REG_RX_IQK_TONE_A, 0x38008c1c);\n\trtl8xxxu_write32(priv, REG_TX_IQK_TONE_B, 0x18008c1c);\n\trtl8xxxu_write32(priv, REG_RX_IQK_TONE_B, 0x38008c1c);\n\n\trtl8xxxu_write32(priv, REG_TX_IQK_PI_B, 0x82140303);\n\trtl8xxxu_write32(priv, REG_RX_IQK_PI_B, 0x68160000);\n\n\t \n\trtl8xxxu_write32(priv, REG_IQK_AGC_RSP, 0x00462911);\n\n\t \n\trtl8xxxu_write32(priv, REG_IQK_AGC_PTS, 0xfa000000);\n\trtl8xxxu_write32(priv, REG_IQK_AGC_PTS, 0xf8000000);\n\n\tmdelay(1);\n\n\t \n\treg_eac = rtl8xxxu_read32(priv, REG_RX_POWER_AFTER_IQK_A_2);\n\treg_eb4 = rtl8xxxu_read32(priv, REG_TX_POWER_BEFORE_IQK_B);\n\treg_ebc = rtl8xxxu_read32(priv, REG_TX_POWER_AFTER_IQK_B);\n\n\tif (!(reg_eac & BIT(31)) &&\n\t    ((reg_eb4 & 0x03ff0000) != 0x01420000) &&\n\t    ((reg_ebc & 0x03ff0000) != 0x00420000))\n\t\tresult |= 0x01;\n\telse\n\t\tdev_warn(&priv->udev->dev, \"%s: Path B IQK failed!\\n\",\n\t\t\t __func__);\n\n\treturn result;\n}\n\nstatic int rtl8192eu_rx_iqk_path_b(struct rtl8xxxu_priv *priv)\n{\n\tu32 reg_eac, reg_eb4, reg_ebc, reg_ec4, reg_ecc, val32;\n\tint result = 0;\n\n\t \n\trtl8xxxu_write32(priv, REG_FPGA0_IQK, 0x00000000);\n\n\t \n\trtl8xxxu_write_rfreg(priv, RF_B, RF6052_REG_WE_LUT, 0x800a0);\n\trtl8xxxu_write_rfreg(priv, RF_B, RF6052_REG_RCK_OS, 0x30000);\n\trtl8xxxu_write_rfreg(priv, RF_B, RF6052_REG_TXPA_G1, 0x0000f);\n\trtl8xxxu_write_rfreg(priv, RF_B, RF6052_REG_TXPA_G2, 0xf1173);\n\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_WE_LUT, 0x800a0);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_RCK_OS, 0x30000);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_TXPA_G1, 0x0000f);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_TXPA_G2, 0xf1173);\n\n\t \n\trtl8xxxu_write_rfreg(priv, RF_B, RF6052_REG_GAIN_CCA, 0x00980);\n\trtl8xxxu_write_rfreg(priv, RF_B, RF6052_REG_PAD_TXG, 0x511e0);\n\n\t \n\trtl8xxxu_write32(priv, REG_FPGA0_IQK, 0x80800000);\n\n\t \n\trtl8xxxu_write32(priv, REG_TX_IQK, 0x01007c00);\n\trtl8xxxu_write32(priv, REG_RX_IQK, 0x01004800);\n\n\t \n\trtl8xxxu_write32(priv, REG_TX_IQK_TONE_A, 0x38008c1c);\n\trtl8xxxu_write32(priv, REG_RX_IQK_TONE_A, 0x38008c1c);\n\trtl8xxxu_write32(priv, REG_TX_IQK_TONE_B, 0x18008c1c);\n\trtl8xxxu_write32(priv, REG_RX_IQK_TONE_B, 0x38008c1c);\n\n\trtl8xxxu_write32(priv, REG_TX_IQK_PI_B, 0x8216031f);\n\trtl8xxxu_write32(priv, REG_RX_IQK_PI_B, 0x6816031f);\n\n\t \n\trtl8xxxu_write32(priv, REG_IQK_AGC_RSP, 0x0046a911);\n\n\t \n\trtl8xxxu_write32(priv, REG_IQK_AGC_PTS, 0xfa000000);\n\trtl8xxxu_write32(priv, REG_IQK_AGC_PTS, 0xf8000000);\n\n\tmdelay(10);\n\n\t \n\treg_eac = rtl8xxxu_read32(priv, REG_RX_POWER_AFTER_IQK_A_2);\n\treg_eb4 = rtl8xxxu_read32(priv, REG_TX_POWER_BEFORE_IQK_B);\n\treg_ebc = rtl8xxxu_read32(priv, REG_TX_POWER_AFTER_IQK_B);\n\n\tif (!(reg_eac & BIT(31)) &&\n\t    ((reg_eb4 & 0x03ff0000) != 0x01420000) &&\n\t    ((reg_ebc & 0x03ff0000) != 0x00420000)) {\n\t\tresult |= 0x01;\n\t} else {\n\t\t \n\t\trtl8xxxu_write32(priv, REG_FPGA0_IQK, 0x00000000);\n\t\trtl8xxxu_write_rfreg(priv, RF_B, RF6052_REG_GAIN_CCA, 0x180);\n\t\tgoto out;\n\t}\n\n\tval32 = 0x80007c00 |\n\t\t(reg_eb4 & 0x03ff0000) | ((reg_ebc >> 16) & 0x03ff);\n\trtl8xxxu_write32(priv, REG_TX_IQK, val32);\n\n\t \n\trtl8xxxu_write32(priv, REG_FPGA0_IQK, 0x00000000);\n\n\trtl8xxxu_write_rfreg(priv, RF_B, RF6052_REG_WE_LUT, 0x800a0);\n\trtl8xxxu_write_rfreg(priv, RF_B, RF6052_REG_RCK_OS, 0x30000);\n\trtl8xxxu_write_rfreg(priv, RF_B, RF6052_REG_TXPA_G1, 0x0000f);\n\trtl8xxxu_write_rfreg(priv, RF_B, RF6052_REG_TXPA_G2, 0xf7ff2);\n\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_WE_LUT, 0x800a0);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_RCK_OS, 0x30000);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_TXPA_G1, 0x0000f);\n\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_TXPA_G2, 0xf7ff2);\n\n\t \n\trtl8xxxu_write_rfreg(priv, RF_B, RF6052_REG_GAIN_CCA, 0x00980);\n\trtl8xxxu_write_rfreg(priv, RF_B, RF6052_REG_PAD_TXG, 0x510e0);\n\n\t \n\trtl8xxxu_write32(priv, REG_FPGA0_IQK, 0x80800000);\n\n\t \n\trtl8xxxu_write32(priv, REG_RX_IQK, 0x01004800);\n\n\t \n\trtl8xxxu_write32(priv, REG_TX_IQK_TONE_A, 0x38008c1c);\n\trtl8xxxu_write32(priv, REG_RX_IQK_TONE_A, 0x38008c1c);\n\trtl8xxxu_write32(priv, REG_TX_IQK_TONE_B, 0x38008c1c);\n\trtl8xxxu_write32(priv, REG_RX_IQK_TONE_B, 0x18008c1c);\n\n\trtl8xxxu_write32(priv, REG_TX_IQK_PI_A, 0x821608ff);\n\trtl8xxxu_write32(priv, REG_RX_IQK_PI_A, 0x281608ff);\n\n\t \n\trtl8xxxu_write32(priv, REG_IQK_AGC_RSP, 0x0046a891);\n\n\t \n\trtl8xxxu_write32(priv, REG_IQK_AGC_PTS, 0xfa000000);\n\trtl8xxxu_write32(priv, REG_IQK_AGC_PTS, 0xf8000000);\n\n\tmdelay(10);\n\n\treg_eac = rtl8xxxu_read32(priv, REG_RX_POWER_AFTER_IQK_A_2);\n\treg_ec4 = rtl8xxxu_read32(priv, REG_RX_POWER_BEFORE_IQK_B_2);\n\treg_ecc = rtl8xxxu_read32(priv, REG_RX_POWER_AFTER_IQK_B_2);\n\n\trtl8xxxu_write32(priv, REG_FPGA0_IQK, 0x00000000);\n\trtl8xxxu_write_rfreg(priv, RF_B, RF6052_REG_GAIN_CCA, 0x180);\n\n\tif (!(reg_eac & BIT(30)) &&\n\t    ((reg_ec4 & 0x03ff0000) != 0x01320000) &&\n\t    ((reg_ecc & 0x03ff0000) != 0x00360000))\n\t\tresult |= 0x02;\n\telse\n\t\tdev_warn(&priv->udev->dev, \"%s: Path B RX IQK failed!\\n\",\n\t\t\t __func__);\n\nout:\n\treturn result;\n}\n\nstatic void rtl8192eu_phy_iqcalibrate(struct rtl8xxxu_priv *priv,\n\t\t\t\t      int result[][8], int t)\n{\n\tstruct device *dev = &priv->udev->dev;\n\tu32 i, val32;\n\tint path_a_ok, path_b_ok;\n\tint retry = 2;\n\tstatic const u32 adda_regs[RTL8XXXU_ADDA_REGS] = {\n\t\tREG_FPGA0_XCD_SWITCH_CTRL, REG_BLUETOOTH,\n\t\tREG_RX_WAIT_CCA, REG_TX_CCK_RFON,\n\t\tREG_TX_CCK_BBON, REG_TX_OFDM_RFON,\n\t\tREG_TX_OFDM_BBON, REG_TX_TO_RX,\n\t\tREG_TX_TO_TX, REG_RX_CCK,\n\t\tREG_RX_OFDM, REG_RX_WAIT_RIFS,\n\t\tREG_RX_TO_RX, REG_STANDBY,\n\t\tREG_SLEEP, REG_PMPD_ANAEN\n\t};\n\tstatic const u32 iqk_mac_regs[RTL8XXXU_MAC_REGS] = {\n\t\tREG_TXPAUSE, REG_BEACON_CTRL,\n\t\tREG_BEACON_CTRL_1, REG_GPIO_MUXCFG\n\t};\n\tstatic const u32 iqk_bb_regs[RTL8XXXU_BB_REGS] = {\n\t\tREG_OFDM0_TRX_PATH_ENABLE, REG_OFDM0_TR_MUX_PAR,\n\t\tREG_FPGA0_XCD_RF_SW_CTRL, REG_CONFIG_ANT_A, REG_CONFIG_ANT_B,\n\t\tREG_FPGA0_XAB_RF_SW_CTRL, REG_FPGA0_XA_RF_INT_OE,\n\t\tREG_FPGA0_XB_RF_INT_OE, REG_CCK0_AFE_SETTING\n\t};\n\tu8 xa_agc = rtl8xxxu_read32(priv, REG_OFDM0_XA_AGC_CORE1) & 0xff;\n\tu8 xb_agc = rtl8xxxu_read32(priv, REG_OFDM0_XB_AGC_CORE1) & 0xff;\n\n\t \n\n\tif (t == 0) {\n\t\t \n\t\trtl8xxxu_save_regs(priv, adda_regs, priv->adda_backup,\n\t\t\t\t   RTL8XXXU_ADDA_REGS);\n\t\trtl8xxxu_save_mac_regs(priv, iqk_mac_regs, priv->mac_backup);\n\t\trtl8xxxu_save_regs(priv, iqk_bb_regs,\n\t\t\t\t   priv->bb_backup, RTL8XXXU_BB_REGS);\n\t}\n\n\trtl8xxxu_path_adda_on(priv, adda_regs, true);\n\n\t \n\trtl8xxxu_mac_calibration(priv, iqk_mac_regs, priv->mac_backup);\n\n\tval32 = rtl8xxxu_read32(priv, REG_CCK0_AFE_SETTING);\n\tval32 |= 0x0f000000;\n\trtl8xxxu_write32(priv, REG_CCK0_AFE_SETTING, val32);\n\n\trtl8xxxu_write32(priv, REG_OFDM0_TRX_PATH_ENABLE, 0x03a05600);\n\trtl8xxxu_write32(priv, REG_OFDM0_TR_MUX_PAR, 0x000800e4);\n\trtl8xxxu_write32(priv, REG_FPGA0_XCD_RF_SW_CTRL, 0x22208200);\n\n\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_XAB_RF_SW_CTRL);\n\tval32 |= (FPGA0_RF_PAPE | (FPGA0_RF_PAPE << FPGA0_RF_BD_CTRL_SHIFT));\n\trtl8xxxu_write32(priv, REG_FPGA0_XAB_RF_SW_CTRL, val32);\n\n\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_XA_RF_INT_OE);\n\tval32 |= BIT(10);\n\trtl8xxxu_write32(priv, REG_FPGA0_XA_RF_INT_OE, val32);\n\tval32 = rtl8xxxu_read32(priv, REG_FPGA0_XB_RF_INT_OE);\n\tval32 |= BIT(10);\n\trtl8xxxu_write32(priv, REG_FPGA0_XB_RF_INT_OE, val32);\n\n\trtl8xxxu_write32(priv, REG_FPGA0_IQK, 0x80800000);\n\trtl8xxxu_write32(priv, REG_TX_IQK, 0x01007c00);\n\trtl8xxxu_write32(priv, REG_RX_IQK, 0x01004800);\n\n\tfor (i = 0; i < retry; i++) {\n\t\tpath_a_ok = rtl8192eu_iqk_path_a(priv);\n\t\tif (path_a_ok == 0x01) {\n\t\t\tval32 = rtl8xxxu_read32(priv,\n\t\t\t\t\t\tREG_TX_POWER_BEFORE_IQK_A);\n\t\t\tresult[t][0] = (val32 >> 16) & 0x3ff;\n\t\t\tval32 = rtl8xxxu_read32(priv,\n\t\t\t\t\t\tREG_TX_POWER_AFTER_IQK_A);\n\t\t\tresult[t][1] = (val32 >> 16) & 0x3ff;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!path_a_ok)\n\t\tdev_dbg(dev, \"%s: Path A TX IQK failed!\\n\", __func__);\n\n\tfor (i = 0; i < retry; i++) {\n\t\tpath_a_ok = rtl8192eu_rx_iqk_path_a(priv);\n\t\tif (path_a_ok == 0x03) {\n\t\t\tval32 = rtl8xxxu_read32(priv,\n\t\t\t\t\t\tREG_RX_POWER_BEFORE_IQK_A_2);\n\t\t\tresult[t][2] = (val32 >> 16) & 0x3ff;\n\t\t\tval32 = rtl8xxxu_read32(priv,\n\t\t\t\t\t\tREG_RX_POWER_AFTER_IQK_A_2);\n\t\t\tresult[t][3] = (val32 >> 16) & 0x3ff;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!path_a_ok)\n\t\tdev_dbg(dev, \"%s: Path A RX IQK failed!\\n\", __func__);\n\n\tif (priv->rf_paths > 1) {\n\t\t \n\t\trtl8xxxu_write32(priv, REG_FPGA0_IQK, 0x00000000);\n\t\trtl8xxxu_write_rfreg(priv, RF_A, RF6052_REG_AC, 0x10000);\n\t\trtl8xxxu_write32(priv, REG_FPGA0_IQK, 0x80800000);\n\n\t\t \n\t\trtl8xxxu_path_adda_on(priv, adda_regs, false);\n\n\t\trtl8xxxu_write32(priv, REG_FPGA0_IQK, 0x80800000);\n\t\trtl8xxxu_write32(priv, REG_TX_IQK, 0x01007c00);\n\t\trtl8xxxu_write32(priv, REG_RX_IQK, 0x01004800);\n\n\t\tfor (i = 0; i < retry; i++) {\n\t\t\tpath_b_ok = rtl8192eu_iqk_path_b(priv);\n\t\t\tif (path_b_ok == 0x01) {\n\t\t\t\tval32 = rtl8xxxu_read32(priv, REG_TX_POWER_BEFORE_IQK_B);\n\t\t\t\tresult[t][4] = (val32 >> 16) & 0x3ff;\n\t\t\t\tval32 = rtl8xxxu_read32(priv, REG_TX_POWER_AFTER_IQK_B);\n\t\t\t\tresult[t][5] = (val32 >> 16) & 0x3ff;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!path_b_ok)\n\t\t\tdev_dbg(dev, \"%s: Path B IQK failed!\\n\", __func__);\n\n\t\tfor (i = 0; i < retry; i++) {\n\t\t\tpath_b_ok = rtl8192eu_rx_iqk_path_b(priv);\n\t\t\tif (path_b_ok == 0x03) {\n\t\t\t\tval32 = rtl8xxxu_read32(priv,\n\t\t\t\t\t\t\tREG_RX_POWER_BEFORE_IQK_B_2);\n\t\t\t\tresult[t][6] = (val32 >> 16) & 0x3ff;\n\t\t\t\tval32 = rtl8xxxu_read32(priv,\n\t\t\t\t\t\t\tREG_RX_POWER_AFTER_IQK_B_2);\n\t\t\t\tresult[t][7] = (val32 >> 16) & 0x3ff;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!path_b_ok)\n\t\t\tdev_dbg(dev, \"%s: Path B RX IQK failed!\\n\", __func__);\n\t}\n\n\t \n\trtl8xxxu_write32(priv, REG_FPGA0_IQK, 0x00000000);\n\n\tif (t) {\n\t\t \n\t\trtl8xxxu_restore_regs(priv, adda_regs, priv->adda_backup,\n\t\t\t\t      RTL8XXXU_ADDA_REGS);\n\n\t\t \n\t\trtl8xxxu_restore_mac_regs(priv, iqk_mac_regs, priv->mac_backup);\n\n\t\t \n\t\trtl8xxxu_restore_regs(priv, iqk_bb_regs,\n\t\t\t\t      priv->bb_backup, RTL8XXXU_BB_REGS);\n\n\t\t \n\t\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_XA_AGC_CORE1);\n\t\tval32 &= 0xffffff00;\n\t\trtl8xxxu_write32(priv, REG_OFDM0_XA_AGC_CORE1, val32 | 0x50);\n\t\trtl8xxxu_write32(priv, REG_OFDM0_XA_AGC_CORE1, val32 | xa_agc);\n\n\t\tif (priv->rf_paths > 1) {\n\t\t\tval32 = rtl8xxxu_read32(priv, REG_OFDM0_XB_AGC_CORE1);\n\t\t\tval32 &= 0xffffff00;\n\t\t\trtl8xxxu_write32(priv, REG_OFDM0_XB_AGC_CORE1,\n\t\t\t\t\t val32 | 0x50);\n\t\t\trtl8xxxu_write32(priv, REG_OFDM0_XB_AGC_CORE1,\n\t\t\t\t\t val32 | xb_agc);\n\t\t}\n\n\t\t \n\t\trtl8xxxu_write32(priv, REG_TX_IQK_TONE_A, 0x01008c00);\n\t\trtl8xxxu_write32(priv, REG_RX_IQK_TONE_A, 0x01008c00);\n\t}\n}\n\nstatic void rtl8192eu_phy_iq_calibrate(struct rtl8xxxu_priv *priv)\n{\n\tstruct device *dev = &priv->udev->dev;\n\tint result[4][8];\t \n\tint i, candidate;\n\tbool path_a_ok, path_b_ok;\n\tu32 reg_e94, reg_e9c, reg_ea4, reg_eac;\n\tu32 reg_eb4, reg_ebc, reg_ec4, reg_ecc;\n\tbool simu;\n\n\tmemset(result, 0, sizeof(result));\n\tcandidate = -1;\n\n\tpath_a_ok = false;\n\tpath_b_ok = false;\n\n\tfor (i = 0; i < 3; i++) {\n\t\trtl8192eu_phy_iqcalibrate(priv, result, i);\n\n\t\tif (i == 1) {\n\t\t\tsimu = rtl8xxxu_gen2_simularity_compare(priv,\n\t\t\t\t\t\t\t\tresult, 0, 1);\n\t\t\tif (simu) {\n\t\t\t\tcandidate = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (i == 2) {\n\t\t\tsimu = rtl8xxxu_gen2_simularity_compare(priv,\n\t\t\t\t\t\t\t\tresult, 0, 2);\n\t\t\tif (simu) {\n\t\t\t\tcandidate = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tsimu = rtl8xxxu_gen2_simularity_compare(priv,\n\t\t\t\t\t\t\t\tresult, 1, 2);\n\t\t\tif (simu)\n\t\t\t\tcandidate = 1;\n\t\t\telse\n\t\t\t\tcandidate = 3;\n\t\t}\n\t}\n\n\tfor (i = 0; i < 4; i++) {\n\t\treg_e94 = result[i][0];\n\t\treg_e9c = result[i][1];\n\t\treg_ea4 = result[i][2];\n\t\treg_eb4 = result[i][4];\n\t\treg_ebc = result[i][5];\n\t\treg_ec4 = result[i][6];\n\t}\n\n\tif (candidate >= 0) {\n\t\treg_e94 = result[candidate][0];\n\t\tpriv->rege94 =  reg_e94;\n\t\treg_e9c = result[candidate][1];\n\t\tpriv->rege9c = reg_e9c;\n\t\treg_ea4 = result[candidate][2];\n\t\treg_eac = result[candidate][3];\n\t\treg_eb4 = result[candidate][4];\n\t\tpriv->regeb4 = reg_eb4;\n\t\treg_ebc = result[candidate][5];\n\t\tpriv->regebc = reg_ebc;\n\t\treg_ec4 = result[candidate][6];\n\t\treg_ecc = result[candidate][7];\n\t\tdev_dbg(dev, \"%s: candidate is %x\\n\", __func__, candidate);\n\t\tdev_dbg(dev,\n\t\t\t\"%s: e94 =%x e9c=%x ea4=%x eac=%x eb4=%x ebc=%x ec4=%x ecc=%x\\n\",\n\t\t\t__func__, reg_e94, reg_e9c,\n\t\t\treg_ea4, reg_eac, reg_eb4, reg_ebc, reg_ec4, reg_ecc);\n\t\tpath_a_ok = true;\n\t\tpath_b_ok = true;\n\t} else {\n\t\treg_e94 = reg_eb4 = priv->rege94 = priv->regeb4 = 0x100;\n\t\treg_e9c = reg_ebc = priv->rege9c = priv->regebc = 0x0;\n\t}\n\n\tif (reg_e94 && candidate >= 0)\n\t\trtl8xxxu_fill_iqk_matrix_a(priv, path_a_ok, result,\n\t\t\t\t\t   candidate, (reg_ea4 == 0));\n\n\tif (priv->rf_paths > 1)\n\t\trtl8xxxu_fill_iqk_matrix_b(priv, path_b_ok, result,\n\t\t\t\t\t   candidate, (reg_ec4 == 0));\n\n\trtl8xxxu_save_regs(priv, rtl8xxxu_iqk_phy_iq_bb_reg,\n\t\t\t   priv->bb_recovery_backup, RTL8XXXU_BB_REGS);\n}\n\n \nstatic void rtl8192e_crystal_afe_adjust(struct rtl8xxxu_priv *priv)\n{\n\tu8 val8;\n\tu32 val32;\n\n\t \n\tval8 = rtl8xxxu_read8(priv, REG_AFE_PLL_CTRL);\n\tval8 &= 0xfb;\n\trtl8xxxu_write8(priv, REG_AFE_PLL_CTRL, val8);\n\n\tval32 = rtl8xxxu_read32(priv, REG_AFE_CTRL4);\n\tval32 &= 0xfffffc7f;\n\trtl8xxxu_write32(priv, REG_AFE_CTRL4, val32);\n\n\t \n\tval8 = rtl8xxxu_read8(priv, REG_AFE_PLL_CTRL);\n\tval8 &= 0xbf;\n\trtl8xxxu_write8(priv, REG_AFE_PLL_CTRL, val8);\n\n\t \n\tval32 = rtl8xxxu_read32(priv, REG_AFE_CTRL4);\n\tval32 &= 0xffdfffff;\n\trtl8xxxu_write32(priv, REG_AFE_CTRL4, val32);\n}\n\nstatic void rtl8192e_disabled_to_emu(struct rtl8xxxu_priv *priv)\n{\n\tu8 val8;\n\n\t \n\tval8 = rtl8xxxu_read8(priv, REG_APS_FSMCO + 1);\n\tval8 &= ~(BIT(3) | BIT(4));\n\trtl8xxxu_write8(priv, REG_APS_FSMCO + 1, val8);\n}\n\nstatic int rtl8192e_emu_to_active(struct rtl8xxxu_priv *priv)\n{\n\tu8 val8;\n\tu32 val32;\n\tint count, ret = 0;\n\n\t \n\tval8 = rtl8xxxu_read8(priv, REG_APS_FSMCO + 1);\n\tval8 &= ~BIT(7);\n\trtl8xxxu_write8(priv, REG_APS_FSMCO + 1, val8);\n\n\t \n\tval8 = rtl8xxxu_read8(priv, REG_APS_FSMCO + 1);\n\tval8 &= ~BIT(2);\n\trtl8xxxu_write8(priv, REG_APS_FSMCO + 1, val8);\n\n\t \n\tval8 = rtl8xxxu_read8(priv, REG_APS_FSMCO + 1);\n\tval8 &= ~(BIT(3) | BIT(4));\n\trtl8xxxu_write8(priv, REG_APS_FSMCO + 1, val8);\n\n\t \n\tfor (count = RTL8XXXU_MAX_REG_POLL; count; count--) {\n\t\tval32 = rtl8xxxu_read32(priv, REG_APS_FSMCO);\n\t\tif (val32 & BIT(17))\n\t\t\tbreak;\n\n\t\tudelay(10);\n\t}\n\n\tif (!count) {\n\t\tret = -EBUSY;\n\t\tgoto exit;\n\t}\n\n\t \n\n\t \n\tval8 = rtl8xxxu_read8(priv, REG_APS_FSMCO + 2);\n\tval8 |= BIT(0);\n\trtl8xxxu_write8(priv, REG_APS_FSMCO + 2, val8);\n\n\t \n\tval32 = rtl8xxxu_read32(priv, REG_APS_FSMCO);\n\tval32 |= APS_FSMCO_MAC_ENABLE;\n\trtl8xxxu_write32(priv, REG_APS_FSMCO, val32);\n\n\tfor (count = RTL8XXXU_MAX_REG_POLL; count; count--) {\n\t\tval32 = rtl8xxxu_read32(priv, REG_APS_FSMCO);\n\t\tif ((val32 & APS_FSMCO_MAC_ENABLE) == 0) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t\tudelay(10);\n\t}\n\n\tif (!count) {\n\t\tret = -EBUSY;\n\t\tgoto exit;\n\t}\n\nexit:\n\treturn ret;\n}\n\nstatic int rtl8192eu_active_to_lps(struct rtl8xxxu_priv *priv)\n{\n\tstruct device *dev = &priv->udev->dev;\n\tu8 val8;\n\tu16 val16;\n\tu32 val32;\n\tint retry, retval;\n\n\trtl8xxxu_write8(priv, REG_TXPAUSE, 0xff);\n\n\tretry = 100;\n\tretval = -EBUSY;\n\t \n\tdo {\n\t\tval32 = rtl8xxxu_read32(priv, REG_SCH_TX_CMD);\n\t\tif (!val32) {\n\t\t\tretval = 0;\n\t\t\tbreak;\n\t\t}\n\t} while (retry--);\n\n\tif (!retry) {\n\t\tdev_warn(dev, \"Failed to flush TX queue\\n\");\n\t\tretval = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t \n\tval8 = rtl8xxxu_read8(priv, REG_SYS_FUNC);\n\tval8 &= ~SYS_FUNC_BBRSTB;\n\trtl8xxxu_write8(priv, REG_SYS_FUNC, val8);\n\n\tudelay(2);\n\n\t \n\tval8 = rtl8xxxu_read8(priv, REG_SYS_FUNC);\n\tval8 &= ~SYS_FUNC_BB_GLB_RSTN;\n\trtl8xxxu_write8(priv, REG_SYS_FUNC, val8);\n\n\t \n\tval16 = rtl8xxxu_read16(priv, REG_CR);\n\tval16 &= 0xff00;\n\tval16 |= (CR_HCI_TXDMA_ENABLE | CR_HCI_RXDMA_ENABLE);\n\trtl8xxxu_write16(priv, REG_CR, val16);\n\n\tval16 = rtl8xxxu_read16(priv, REG_CR);\n\tval16 &= ~CR_SECURITY_ENABLE;\n\trtl8xxxu_write16(priv, REG_CR, val16);\n\n\tval8 = rtl8xxxu_read8(priv, REG_DUAL_TSF_RST);\n\tval8 |= DUAL_TSF_TX_OK;\n\trtl8xxxu_write8(priv, REG_DUAL_TSF_RST, val8);\n\nout:\n\treturn retval;\n}\n\nstatic int rtl8192eu_active_to_emu(struct rtl8xxxu_priv *priv)\n{\n\tu8 val8;\n\tint count, ret = 0;\n\n\t \n\tval8 = rtl8xxxu_read8(priv, REG_RF_CTRL);\n\tval8 &= ~RF_ENABLE;\n\trtl8xxxu_write8(priv, REG_RF_CTRL, val8);\n\n\t \n\tval8 = rtl8xxxu_read8(priv, REG_LEDCFG2);\n\tval8 &= ~LEDCFG2_DPDT_SELECT;\n\trtl8xxxu_write8(priv, REG_LEDCFG2, val8);\n\n\t \n\tval8 = rtl8xxxu_read8(priv, REG_APS_FSMCO + 1);\n\tval8 |= BIT(1);\n\trtl8xxxu_write8(priv, REG_APS_FSMCO + 1, val8);\n\n\tfor (count = RTL8XXXU_MAX_REG_POLL; count; count--) {\n\t\tval8 = rtl8xxxu_read8(priv, REG_APS_FSMCO + 1);\n\t\tif ((val8 & BIT(1)) == 0)\n\t\t\tbreak;\n\t\tudelay(10);\n\t}\n\n\tif (!count) {\n\t\tdev_warn(&priv->udev->dev, \"%s: Disabling MAC timed out\\n\",\n\t\t\t __func__);\n\t\tret = -EBUSY;\n\t\tgoto exit;\n\t}\n\nexit:\n\treturn ret;\n}\n\nstatic int rtl8192eu_emu_to_disabled(struct rtl8xxxu_priv *priv)\n{\n\tu8 val8;\n\n\t \n\tval8 = rtl8xxxu_read8(priv, REG_APS_FSMCO + 1);\n\tval8 &= ~(BIT(3) | BIT(4));\n\tval8 |= BIT(3);\n\trtl8xxxu_write8(priv, REG_APS_FSMCO + 1, val8);\n\n\treturn 0;\n}\n\nstatic int rtl8192eu_power_on(struct rtl8xxxu_priv *priv)\n{\n\tu16 val16;\n\tu32 val32;\n\tint ret;\n\n\tval32 = rtl8xxxu_read32(priv, REG_SYS_CFG);\n\tif (val32 & SYS_CFG_SPS_LDO_SEL) {\n\t\trtl8xxxu_write8(priv, REG_LDO_SW_CTRL, 0xc3);\n\t} else {\n\t\t \n\t\tval32 = rtl8xxxu_read32(priv, REG_8192E_LDOV12_CTRL);\n\t\tval32 &= 0xff0fffff;\n\t\tval32 |= 0x00500000;\n\t\trtl8xxxu_write32(priv, REG_8192E_LDOV12_CTRL, val32);\n\t\trtl8xxxu_write8(priv, REG_LDO_SW_CTRL, 0x83);\n\t}\n\n\t \n\trtl8192e_crystal_afe_adjust(priv);\n\trtl8192e_disabled_to_emu(priv);\n\n\tret = rtl8192e_emu_to_active(priv);\n\tif (ret)\n\t\tgoto exit;\n\n\trtl8xxxu_write16(priv, REG_CR, 0x0000);\n\n\t \n\tval16 = rtl8xxxu_read16(priv, REG_CR);\n\tval16 |= (CR_HCI_TXDMA_ENABLE | CR_HCI_RXDMA_ENABLE |\n\t\t  CR_TXDMA_ENABLE | CR_RXDMA_ENABLE |\n\t\t  CR_PROTOCOL_ENABLE | CR_SCHEDULE_ENABLE |\n\t\t  CR_MAC_TX_ENABLE | CR_MAC_RX_ENABLE |\n\t\t  CR_SECURITY_ENABLE | CR_CALTIMER_ENABLE);\n\trtl8xxxu_write16(priv, REG_CR, val16);\n\nexit:\n\treturn ret;\n}\n\nstatic void rtl8192eu_power_off(struct rtl8xxxu_priv *priv)\n{\n\tu8 val8;\n\tu16 val16;\n\n\trtl8xxxu_flush_fifo(priv);\n\n\tval8 = rtl8xxxu_read8(priv, REG_TX_REPORT_CTRL);\n\tval8 &= ~TX_REPORT_CTRL_TIMER_ENABLE;\n\trtl8xxxu_write8(priv, REG_TX_REPORT_CTRL, val8);\n\n\t \n\trtl8xxxu_write8(priv, REG_RF_CTRL, 0x00);\n\n\trtl8192eu_active_to_lps(priv);\n\n\t \n\tif (rtl8xxxu_read8(priv, REG_MCU_FW_DL) & MCU_FW_RAM_SEL)\n\t\trtl8xxxu_firmware_self_reset(priv);\n\n\t \n\tval16 = rtl8xxxu_read16(priv, REG_SYS_FUNC);\n\tval16 &= ~SYS_FUNC_CPU_ENABLE;\n\trtl8xxxu_write16(priv, REG_SYS_FUNC, val16);\n\n\t \n\trtl8xxxu_write8(priv, REG_MCU_FW_DL, 0x00);\n\n\trtl8xxxu_reset_8051(priv);\n\n\trtl8192eu_active_to_emu(priv);\n\trtl8192eu_emu_to_disabled(priv);\n}\n\nstatic void rtl8192e_enable_rf(struct rtl8xxxu_priv *priv)\n{\n\tu32 val32;\n\tu8 val8;\n\n\tval32 = rtl8xxxu_read32(priv, REG_RX_WAIT_CCA);\n\tval32 |= (BIT(22) | BIT(23));\n\trtl8xxxu_write32(priv, REG_RX_WAIT_CCA, val32);\n\n\tval8 = rtl8xxxu_read8(priv, REG_GPIO_MUXCFG);\n\tval8 |= BIT(5);\n\trtl8xxxu_write8(priv, REG_GPIO_MUXCFG, val8);\n\n\t \n\trtl8xxxu_write8(priv, REG_WLAN_ACT_CONTROL_8723B, 0x04);\n\n\tval32 = rtl8xxxu_read32(priv, REG_PWR_DATA);\n\tval32 |= PWR_DATA_EEPRPAD_RFE_CTRL_EN;\n\trtl8xxxu_write32(priv, REG_PWR_DATA, val32);\n\n\tval32 = rtl8xxxu_read32(priv, REG_RFE_BUFFER);\n\tval32 |= (BIT(0) | BIT(1));\n\trtl8xxxu_write32(priv, REG_RFE_BUFFER, val32);\n\n\trtl8xxxu_write8(priv, REG_RFE_CTRL_ANTA_SRC, 0x77);\n\n\tval32 = rtl8xxxu_read32(priv, REG_LEDCFG0);\n\tval32 &= ~BIT(24);\n\tval32 |= BIT(23);\n\trtl8xxxu_write32(priv, REG_LEDCFG0, val32);\n\n\t \n\tval8 = rtl8xxxu_read8(priv, REG_PAD_CTRL1);\n\tval8 &= ~BIT(0);\n\trtl8xxxu_write8(priv, REG_PAD_CTRL1, val8);\n\n\t \n\trtl8xxxu_write8(priv, REG_TXPAUSE, 0x00);\n}\n\nstatic s8 rtl8192e_cck_rssi(struct rtl8xxxu_priv *priv, struct rtl8723au_phy_stats *phy_stats)\n{\n\tstatic const s8 lna_gain_table_0[8] = {15, 9, -10, -21, -23, -27, -43, -44};\n\tstatic const s8 lna_gain_table_1[8] = {24, 18, 13, -4, -11, -18, -31, -36};\n\n\tu8 cck_agc_rpt = phy_stats->cck_agc_rpt_ofdm_cfosho_a;\n\ts8 rx_pwr_all = 0x00;\n\tu8 vga_idx, lna_idx;\n\ts8 lna_gain = 0;\n\n\tlna_idx = u8_get_bits(cck_agc_rpt, CCK_AGC_RPT_LNA_IDX_MASK);\n\tvga_idx = u8_get_bits(cck_agc_rpt, CCK_AGC_RPT_VGA_IDX_MASK);\n\n\tif (priv->cck_agc_report_type == 0)\n\t\tlna_gain = lna_gain_table_0[lna_idx];\n\telse\n\t\tlna_gain = lna_gain_table_1[lna_idx];\n\n\trx_pwr_all = lna_gain - (2 * vga_idx);\n\n\treturn rx_pwr_all;\n}\n\nstatic int rtl8192eu_led_brightness_set(struct led_classdev *led_cdev,\n\t\t\t\t\tenum led_brightness brightness)\n{\n\tstruct rtl8xxxu_priv *priv = container_of(led_cdev,\n\t\t\t\t\t\t  struct rtl8xxxu_priv,\n\t\t\t\t\t\t  led_cdev);\n\tu8 ledcfg = rtl8xxxu_read8(priv, REG_LEDCFG1);\n\n\tif (brightness == LED_OFF) {\n\t\tledcfg &= ~LEDCFG1_HW_LED_CONTROL;\n\t\tledcfg |= LEDCFG1_LED_DISABLE;\n\t} else if (brightness == LED_ON) {\n\t\tledcfg &= ~(LEDCFG1_HW_LED_CONTROL | LEDCFG1_LED_DISABLE);\n\t} else if (brightness == RTL8XXXU_HW_LED_CONTROL) {\n\t\tledcfg &= ~LEDCFG1_LED_DISABLE;\n\t\tledcfg |= LEDCFG1_HW_LED_CONTROL;\n\t}\n\n\trtl8xxxu_write8(priv, REG_LEDCFG1, ledcfg);\n\n\treturn 0;\n}\n\nstruct rtl8xxxu_fileops rtl8192eu_fops = {\n\t.identify_chip = rtl8192eu_identify_chip,\n\t.parse_efuse = rtl8192eu_parse_efuse,\n\t.load_firmware = rtl8192eu_load_firmware,\n\t.power_on = rtl8192eu_power_on,\n\t.power_off = rtl8192eu_power_off,\n\t.read_efuse = rtl8xxxu_read_efuse,\n\t.reset_8051 = rtl8xxxu_reset_8051,\n\t.llt_init = rtl8xxxu_auto_llt_table,\n\t.init_phy_bb = rtl8192eu_init_phy_bb,\n\t.init_phy_rf = rtl8192eu_init_phy_rf,\n\t.phy_lc_calibrate = rtl8723a_phy_lc_calibrate,\n\t.phy_iq_calibrate = rtl8192eu_phy_iq_calibrate,\n\t.config_channel = rtl8xxxu_gen2_config_channel,\n\t.parse_rx_desc = rtl8xxxu_parse_rxdesc24,\n\t.parse_phystats = rtl8723au_rx_parse_phystats,\n\t.enable_rf = rtl8192e_enable_rf,\n\t.disable_rf = rtl8xxxu_gen2_disable_rf,\n\t.usb_quirks = rtl8xxxu_gen2_usb_quirks,\n\t.set_tx_power = rtl8192e_set_tx_power,\n\t.update_rate_mask = rtl8xxxu_gen2_update_rate_mask,\n\t.report_connect = rtl8xxxu_gen2_report_connect,\n\t.report_rssi = rtl8xxxu_gen2_report_rssi,\n\t.fill_txdesc = rtl8xxxu_fill_txdesc_v2,\n\t.set_crystal_cap = rtl8723a_set_crystal_cap,\n\t.cck_rssi = rtl8192e_cck_rssi,\n\t.led_classdev_brightness_set = rtl8192eu_led_brightness_set,\n\t.writeN_block_size = 128,\n\t.tx_desc_size = sizeof(struct rtl8xxxu_txdesc40),\n\t.rx_desc_size = sizeof(struct rtl8xxxu_rxdesc24),\n\t.has_s0s1 = 0,\n\t.gen2_thermal_meter = 1,\n\t.needs_full_init = 1,\n\t.supports_ap = 1,\n\t.max_macid_num = 128,\n\t.adda_1t_init = 0x0fc01616,\n\t.adda_1t_path_on = 0x0fc01616,\n\t.adda_2t_path_on_a = 0x0fc01616,\n\t.adda_2t_path_on_b = 0x0fc01616,\n\t.trxff_boundary = 0x3cff,\n\t.mactable = rtl8192e_mac_init_table,\n\t.total_page_num = TX_TOTAL_PAGE_NUM_8192E,\n\t.page_num_hi = TX_PAGE_NUM_HI_PQ_8192E,\n\t.page_num_lo = TX_PAGE_NUM_LO_PQ_8192E,\n\t.page_num_norm = TX_PAGE_NUM_NORM_PQ_8192E,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}