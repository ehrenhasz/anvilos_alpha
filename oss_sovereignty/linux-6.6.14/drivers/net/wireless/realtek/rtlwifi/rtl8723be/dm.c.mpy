{
  "module_name": "dm.c",
  "hash_id": "170d4a23cf5e3aa10d5bbb7362aade13f32ec2bb7bfdb2b44276e012cc8d1ccc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtlwifi/rtl8723be/dm.c",
  "human_readable_source": "\n \n\n#include \"../wifi.h\"\n#include \"../base.h\"\n#include \"../pci.h\"\n#include \"../core.h\"\n#include \"reg.h\"\n#include \"def.h\"\n#include \"phy.h\"\n#include \"dm.h\"\n#include \"../rtl8723com/dm_common.h\"\n#include \"fw.h\"\n#include \"trx.h\"\n#include \"../btcoexist/rtl_btc.h\"\n\nstatic const u32 ofdmswing_table[] = {\n\t0x0b40002d,  \n\t0x0c000030,  \n\t0x0cc00033,  \n\t0x0d800036,  \n\t0x0e400039,  \n\t0x0f00003c,  \n\t0x10000040,  \n\t0x11000044,  \n\t0x12000048,  \n\t0x1300004c,  \n\t0x14400051,  \n\t0x15800056,  \n\t0x16c0005b,  \n\t0x18000060,  \n\t0x19800066,  \n\t0x1b00006c,  \n\t0x1c800072,  \n\t0x1e400079,  \n\t0x20000080,  \n\t0x22000088,  \n\t0x24000090,  \n\t0x26000098,  \n\t0x288000a2,  \n\t0x2ac000ab,  \n\t0x2d4000b5,  \n\t0x300000c0,  \n\t0x32c000cb,  \n\t0x35c000d7,  \n\t0x390000e4,  \n\t0x3c8000f2,  \n\t0x40000100,  \n\t0x43c0010f,  \n\t0x47c0011f,  \n\t0x4c000130,  \n\t0x50800142,  \n\t0x55400155,  \n\t0x5a400169,  \n\t0x5fc0017f,  \n\t0x65400195,  \n\t0x6b8001ae,  \n\t0x71c001c7,  \n\t0x788001e2,  \n\t0x7f8001fe   \n};\n\nstatic const u8 cckswing_table_ch1ch13[CCK_TABLE_SIZE][8] = {\n\t{0x09, 0x08, 0x07, 0x06, 0x04, 0x03, 0x01, 0x01},  \n\t{0x09, 0x09, 0x08, 0x06, 0x05, 0x03, 0x01, 0x01},  \n\t{0x0a, 0x09, 0x08, 0x07, 0x05, 0x03, 0x02, 0x01},  \n\t{0x0a, 0x0a, 0x09, 0x07, 0x05, 0x03, 0x02, 0x01},  \n\t{0x0b, 0x0a, 0x09, 0x08, 0x06, 0x04, 0x02, 0x01},  \n\t{0x0b, 0x0b, 0x0a, 0x08, 0x06, 0x04, 0x02, 0x01},  \n\t{0x0c, 0x0c, 0x0a, 0x09, 0x06, 0x04, 0x02, 0x01},  \n\t{0x0d, 0x0c, 0x0b, 0x09, 0x07, 0x04, 0x02, 0x01},  \n\t{0x0d, 0x0d, 0x0c, 0x0a, 0x07, 0x05, 0x02, 0x01},  \n\t{0x0e, 0x0e, 0x0c, 0x0a, 0x08, 0x05, 0x02, 0x01},  \n\t{0x0f, 0x0f, 0x0d, 0x0b, 0x08, 0x05, 0x03, 0x01},  \n\t{0x10, 0x10, 0x0e, 0x0b, 0x08, 0x05, 0x03, 0x01},  \n\t{0x11, 0x11, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},  \n\t{0x12, 0x12, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},  \n\t{0x13, 0x13, 0x10, 0x0d, 0x0a, 0x06, 0x03, 0x01},  \n\t{0x14, 0x14, 0x11, 0x0e, 0x0b, 0x07, 0x03, 0x02},  \n\t{0x16, 0x15, 0x12, 0x0f, 0x0b, 0x07, 0x04, 0x01},  \n\t{0x17, 0x16, 0x13, 0x10, 0x0c, 0x08, 0x04, 0x02},  \n\t{0x18, 0x17, 0x15, 0x11, 0x0c, 0x08, 0x04, 0x02},  \n\t{0x1a, 0x19, 0x16, 0x12, 0x0d, 0x09, 0x04, 0x02},  \n\t{0x1b, 0x1a, 0x17, 0x13, 0x0e, 0x09, 0x04, 0x02},  \n\t{0x1d, 0x1c, 0x18, 0x14, 0x0f, 0x0a, 0x05, 0x02},  \n\t{0x1f, 0x1e, 0x1a, 0x15, 0x10, 0x0a, 0x05, 0x02},  \n\t{0x20, 0x20, 0x1b, 0x16, 0x11, 0x08, 0x05, 0x02},  \n\t{0x22, 0x21, 0x1d, 0x18, 0x11, 0x0b, 0x06, 0x02},  \n\t{0x24, 0x23, 0x1f, 0x19, 0x13, 0x0c, 0x06, 0x03},  \n\t{0x26, 0x25, 0x21, 0x1b, 0x14, 0x0d, 0x06, 0x03},  \n\t{0x28, 0x28, 0x22, 0x1c, 0x15, 0x0d, 0x07, 0x03},  \n\t{0x2b, 0x2a, 0x25, 0x1e, 0x16, 0x0e, 0x07, 0x03},  \n\t{0x2d, 0x2d, 0x27, 0x1f, 0x18, 0x0f, 0x08, 0x03},  \n\t{0x30, 0x2f, 0x29, 0x21, 0x19, 0x10, 0x08, 0x03},  \n\t{0x33, 0x32, 0x2b, 0x23, 0x1a, 0x11, 0x08, 0x04},  \n\t{0x36, 0x35, 0x2e, 0x25, 0x1c, 0x12, 0x09, 0x04}   \n};\n\nstatic const u8 cckswing_table_ch14[CCK_TABLE_SIZE][8] = {\n\t{0x09, 0x08, 0x07, 0x04, 0x00, 0x00, 0x00, 0x00},  \n\t{0x09, 0x09, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00},  \n\t{0x0a, 0x09, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00},  \n\t{0x0a, 0x0a, 0x09, 0x05, 0x00, 0x00, 0x00, 0x00},  \n\t{0x0b, 0x0a, 0x09, 0x05, 0x00, 0x00, 0x00, 0x00},  \n\t{0x0b, 0x0b, 0x0a, 0x06, 0x00, 0x00, 0x00, 0x00},  \n\t{0x0c, 0x0c, 0x0a, 0x06, 0x00, 0x00, 0x00, 0x00},  \n\t{0x0d, 0x0c, 0x0b, 0x06, 0x00, 0x00, 0x00, 0x00},  \n\t{0x0d, 0x0d, 0x0c, 0x07, 0x00, 0x00, 0x00, 0x00},  \n\t{0x0e, 0x0e, 0x0c, 0x07, 0x00, 0x00, 0x00, 0x00},  \n\t{0x0f, 0x0f, 0x0d, 0x08, 0x00, 0x00, 0x00, 0x00},  \n\t{0x10, 0x10, 0x0e, 0x08, 0x00, 0x00, 0x00, 0x00},  \n\t{0x11, 0x11, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},  \n\t{0x12, 0x12, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},  \n\t{0x13, 0x13, 0x10, 0x0a, 0x00, 0x00, 0x00, 0x00},  \n\t{0x14, 0x14, 0x11, 0x0a, 0x00, 0x00, 0x00, 0x00},  \n\t{0x16, 0x15, 0x12, 0x0b, 0x00, 0x00, 0x00, 0x00},  \n\t{0x17, 0x16, 0x13, 0x0b, 0x00, 0x00, 0x00, 0x00},  \n\t{0x18, 0x17, 0x15, 0x0c, 0x00, 0x00, 0x00, 0x00},  \n\t{0x1a, 0x19, 0x16, 0x0d, 0x00, 0x00, 0x00, 0x00},  \n\t{0x1b, 0x1a, 0x17, 0x0e, 0x00, 0x00, 0x00, 0x00},  \n\t{0x1d, 0x1c, 0x18, 0x0e, 0x00, 0x00, 0x00, 0x00},  \n\t{0x1f, 0x1e, 0x1a, 0x0f, 0x00, 0x00, 0x00, 0x00},  \n\t{0x20, 0x20, 0x1b, 0x10, 0x00, 0x00, 0x00, 0x00},  \n\t{0x22, 0x21, 0x1d, 0x11, 0x00, 0x00, 0x00, 0x00},  \n\t{0x24, 0x23, 0x1f, 0x12, 0x00, 0x00, 0x00, 0x00},  \n\t{0x26, 0x25, 0x21, 0x13, 0x00, 0x00, 0x00, 0x00},  \n\t{0x28, 0x28, 0x24, 0x14, 0x00, 0x00, 0x00, 0x00},  \n\t{0x2b, 0x2a, 0x25, 0x15, 0x00, 0x00, 0x00, 0x00},  \n\t{0x2d, 0x2d, 0x17, 0x17, 0x00, 0x00, 0x00, 0x00},  \n\t{0x30, 0x2f, 0x29, 0x18, 0x00, 0x00, 0x00, 0x00},  \n\t{0x33, 0x32, 0x2b, 0x19, 0x00, 0x00, 0x00, 0x00},  \n\t{0x36, 0x35, 0x2e, 0x1b, 0x00, 0x00, 0x00, 0x00}   \n};\n\nstatic const u32 edca_setting_dl[PEER_MAX] = {\n\t0xa44f,\t\t \n\t0x5ea44f,\t \n\t0x5e4322,\t \n\t0x5ea42b,\t \n\t0xa44f,\t\t \n\t0xa630,\t\t \n\t0x5ea630,\t \n\t0x5ea42b,\t \n};\n\nstatic const u32 edca_setting_ul[PEER_MAX] = {\n\t0x5e4322,\t \n\t0xa44f,\t\t \n\t0x5ea44f,\t \n\t0x5ea32b,\t \n\t0x5ea422,\t \n\t0x5ea322,\t \n\t0x3ea430,\t \n\t0x5ea44f,\t \n};\n\nvoid rtl8723be_dm_txpower_track_adjust(struct ieee80211_hw *hw, u8 type,\n\t\t\t\t       u8 *pdirection, u32 *poutwrite_val)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_dm *rtldm = rtl_dm(rtl_priv(hw));\n\tu8 pwr_val = 0;\n\tu8 ofdm_base = rtlpriv->dm.swing_idx_ofdm_base[RF90_PATH_A];\n\tu8 ofdm_val = rtlpriv->dm.swing_idx_ofdm[RF90_PATH_A];\n\tu8 cck_base = rtldm->swing_idx_cck_base;\n\tu8 cck_val = rtldm->swing_idx_cck;\n\n\tif (type == 0) {\n\t\tif (ofdm_val <= ofdm_base) {\n\t\t\t*pdirection = 1;\n\t\t\tpwr_val = ofdm_base - ofdm_val;\n\t\t} else {\n\t\t\t*pdirection = 2;\n\t\t\tpwr_val = ofdm_val - ofdm_base;\n\t\t}\n\t} else if (type == 1) {\n\t\tif (cck_val <= cck_base) {\n\t\t\t*pdirection = 1;\n\t\t\tpwr_val = cck_base - cck_val;\n\t\t} else {\n\t\t\t*pdirection = 2;\n\t\t\tpwr_val = cck_val - cck_base;\n\t\t}\n\t}\n\n\tif (pwr_val >= TXPWRTRACK_MAX_IDX && (*pdirection == 1))\n\t\tpwr_val = TXPWRTRACK_MAX_IDX;\n\n\t*poutwrite_val = pwr_val | (pwr_val << 8) |\n\t\t(pwr_val << 16) | (pwr_val << 24);\n}\n\nvoid rtl8723be_dm_init_rate_adaptive_mask(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rate_adaptive *p_ra = &rtlpriv->ra;\n\n\tp_ra->ratr_state = DM_RATR_STA_INIT;\n\tp_ra->pre_ratr_state = DM_RATR_STA_INIT;\n\n\tif (rtlpriv->dm.dm_type == DM_TYPE_BYDRIVER)\n\t\trtlpriv->dm.useramask = true;\n\telse\n\t\trtlpriv->dm.useramask = false;\n\n\tp_ra->high_rssi_thresh_for_ra = 50;\n\tp_ra->low_rssi_thresh_for_ra40m = 20;\n}\n\nstatic void rtl8723be_dm_init_txpower_tracking(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtlpriv->dm.txpower_tracking = true;\n\trtlpriv->dm.txpower_track_control = true;\n\trtlpriv->dm.thermalvalue = 0;\n\n\trtlpriv->dm.ofdm_index[0] = 30;\n\trtlpriv->dm.cck_index = 20;\n\n\trtlpriv->dm.swing_idx_cck_base = rtlpriv->dm.cck_index;\n\n\trtlpriv->dm.swing_idx_ofdm_base[0] = rtlpriv->dm.ofdm_index[0];\n\trtlpriv->dm.delta_power_index[RF90_PATH_A] = 0;\n\trtlpriv->dm.delta_power_index_last[RF90_PATH_A] = 0;\n\trtlpriv->dm.power_index_offset[RF90_PATH_A] = 0;\n\n\trtl_dbg(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\n\t\t\"rtlpriv->dm.txpower_tracking = %d\\n\",\n\t\trtlpriv->dm.txpower_tracking);\n}\n\nstatic void rtl8723be_dm_init_dynamic_atc_switch(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtlpriv->dm.crystal_cap = rtlpriv->efuse.crystalcap;\n\n\trtlpriv->dm.atc_status = rtl_get_bbreg(hw, ROFDM1_CFOTRACKING, 0x800);\n\trtlpriv->dm.cfo_threshold = CFO_THRESHOLD_XTAL;\n}\n\nvoid rtl8723be_dm_init(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 cur_igvalue = rtl_get_bbreg(hw, ROFDM0_XAAGCCORE1, 0x7f);\n\n\trtlpriv->dm.dm_type = DM_TYPE_BYDRIVER;\n\trtl_dm_diginit(hw, cur_igvalue);\n\trtl8723be_dm_init_rate_adaptive_mask(hw);\n\trtl8723_dm_init_edca_turbo(hw);\n\trtl8723_dm_init_dynamic_bb_powersaving(hw);\n\trtl8723_dm_init_dynamic_txpower(hw);\n\trtl8723be_dm_init_txpower_tracking(hw);\n\trtl8723be_dm_init_dynamic_atc_switch(hw);\n}\n\nstatic void rtl8723be_dm_find_minimum_rssi(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct dig_t *rtl_dm_dig = &rtlpriv->dm_digtable;\n\tstruct rtl_mac *mac = rtl_mac(rtlpriv);\n\n\t \n\tif ((mac->link_state < MAC80211_LINKED) &&\n\t    (rtlpriv->dm.entry_min_undec_sm_pwdb == 0)) {\n\t\trtl_dm_dig->min_undec_pwdb_for_dm = 0;\n\t\trtl_dbg(rtlpriv, COMP_BB_POWERSAVING, DBG_LOUD,\n\t\t\t\"Not connected to any\\n\");\n\t}\n\tif (mac->link_state >= MAC80211_LINKED) {\n\t\tif (mac->opmode == NL80211_IFTYPE_AP ||\n\t\t    mac->opmode == NL80211_IFTYPE_ADHOC) {\n\t\t\trtl_dm_dig->min_undec_pwdb_for_dm =\n\t\t\t    rtlpriv->dm.entry_min_undec_sm_pwdb;\n\t\t\trtl_dbg(rtlpriv, COMP_BB_POWERSAVING, DBG_LOUD,\n\t\t\t\t\"AP Client PWDB = 0x%lx\\n\",\n\t\t\t\trtlpriv->dm.entry_min_undec_sm_pwdb);\n\t\t} else {\n\t\t\trtl_dm_dig->min_undec_pwdb_for_dm =\n\t\t\t    rtlpriv->dm.undec_sm_pwdb;\n\t\t\trtl_dbg(rtlpriv, COMP_BB_POWERSAVING, DBG_LOUD,\n\t\t\t\t\"STA Default Port PWDB = 0x%x\\n\",\n\t\t\t\trtl_dm_dig->min_undec_pwdb_for_dm);\n\t\t}\n\t} else {\n\t\trtl_dm_dig->min_undec_pwdb_for_dm =\n\t\t\t\trtlpriv->dm.entry_min_undec_sm_pwdb;\n\t\trtl_dbg(rtlpriv, COMP_BB_POWERSAVING, DBG_LOUD,\n\t\t\t\"AP Ext Port or disconnect PWDB = 0x%x\\n\",\n\t\t\trtl_dm_dig->min_undec_pwdb_for_dm);\n\t}\n\trtl_dbg(rtlpriv, COMP_DIG, DBG_LOUD, \"MinUndecoratedPWDBForDM =%d\\n\",\n\t\trtl_dm_dig->min_undec_pwdb_for_dm);\n}\n\nstatic void rtl8723be_dm_check_rssi_monitor(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct dig_t *dm_digtable = &rtlpriv->dm_digtable;\n\tstruct rtl_sta_info *drv_priv;\n\tu8 h2c_parameter[3] = { 0 };\n\tlong tmp_entry_max_pwdb = 0, tmp_entry_min_pwdb = 0xff;\n\n\t \n\tspin_lock_bh(&rtlpriv->locks.entry_list_lock);\n\tlist_for_each_entry(drv_priv, &rtlpriv->entry_list, list) {\n\t\tif (drv_priv->rssi_stat.undec_sm_pwdb <\n\t\t\t\t\t\ttmp_entry_min_pwdb)\n\t\t\ttmp_entry_min_pwdb =\n\t\t\t\tdrv_priv->rssi_stat.undec_sm_pwdb;\n\t\tif (drv_priv->rssi_stat.undec_sm_pwdb >\n\t\t\t\t\t\ttmp_entry_max_pwdb)\n\t\t\ttmp_entry_max_pwdb =\n\t\t\t\tdrv_priv->rssi_stat.undec_sm_pwdb;\n\t}\n\tspin_unlock_bh(&rtlpriv->locks.entry_list_lock);\n\n\t \n\tif (tmp_entry_max_pwdb != 0) {\n\t\trtlpriv->dm.entry_max_undec_sm_pwdb =\n\t\t\t\t\t\t\ttmp_entry_max_pwdb;\n\t\tRTPRINT(rtlpriv, FDM, DM_PWDB,\n\t\t\t\"EntryMaxPWDB = 0x%lx(%ld)\\n\",\n\t\t\t tmp_entry_max_pwdb, tmp_entry_max_pwdb);\n\t} else {\n\t\trtlpriv->dm.entry_max_undec_sm_pwdb = 0;\n\t}\n\t \n\tif (tmp_entry_min_pwdb != 0xff) {\n\t\trtlpriv->dm.entry_min_undec_sm_pwdb =\n\t\t\t\t\t\t\ttmp_entry_min_pwdb;\n\t\tRTPRINT(rtlpriv, FDM, DM_PWDB,\n\t\t\t\"EntryMinPWDB = 0x%lx(%ld)\\n\",\n\t\t\t tmp_entry_min_pwdb, tmp_entry_min_pwdb);\n\t} else {\n\t\trtlpriv->dm.entry_min_undec_sm_pwdb = 0;\n\t}\n\t \n\tif (rtlpriv->dm.useramask) {\n\t\th2c_parameter[2] =\n\t\t\t(u8)(rtlpriv->dm.undec_sm_pwdb & 0xFF);\n\t\th2c_parameter[1] = 0x20;\n\t\th2c_parameter[0] = 0;\n\t\trtl8723be_fill_h2c_cmd(hw, H2C_RSSIBE_REPORT, 3, h2c_parameter);\n\t} else {\n\t\trtl_write_byte(rtlpriv, 0x4fe,\n\t\t\t       rtlpriv->dm.undec_sm_pwdb);\n\t}\n\trtl8723be_dm_find_minimum_rssi(hw);\n\tdm_digtable->rssi_val_min =\n\t\t\trtlpriv->dm_digtable.min_undec_pwdb_for_dm;\n}\n\nvoid rtl8723be_dm_write_dig(struct ieee80211_hw *hw, u8 current_igi)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct dig_t *dm_digtable = &rtlpriv->dm_digtable;\n\n\tif (dm_digtable->stop_dig)\n\t\treturn;\n\n\tif (dm_digtable->cur_igvalue != current_igi) {\n\t\trtl_set_bbreg(hw, ROFDM0_XAAGCCORE1, 0x7f, current_igi);\n\t\tif (rtlpriv->phy.rf_type != RF_1T1R)\n\t\t\trtl_set_bbreg(hw, ROFDM0_XBAGCCORE1,\n\t\t\t\t      0x7f, current_igi);\n\t}\n\tdm_digtable->pre_igvalue = dm_digtable->cur_igvalue;\n\tdm_digtable->cur_igvalue = current_igi;\n}\n\nstatic void rtl8723be_dm_dig(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct dig_t *dm_digtable = &rtlpriv->dm_digtable;\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tu8 dig_min_0, dig_maxofmin;\n\tbool bfirstconnect, bfirstdisconnect;\n\tu8 dm_dig_max, dm_dig_min;\n\tu8 current_igi = dm_digtable->cur_igvalue;\n\tu8 offset;\n\n\t \n\tif (mac->act_scanning)\n\t\treturn;\n\n\tdig_min_0 = dm_digtable->dig_min_0;\n\tbfirstconnect = (mac->link_state >= MAC80211_LINKED) &&\n\t\t\t!dm_digtable->media_connect_0;\n\tbfirstdisconnect = (mac->link_state < MAC80211_LINKED) &&\n\t\t\t(dm_digtable->media_connect_0);\n\n\tdm_dig_max = 0x5a;\n\tdm_dig_min = DM_DIG_MIN;\n\tdig_maxofmin = DM_DIG_MAX_AP;\n\n\tif (mac->link_state >= MAC80211_LINKED) {\n\t\tif ((dm_digtable->rssi_val_min + 10) > dm_dig_max)\n\t\t\tdm_digtable->rx_gain_max = dm_dig_max;\n\t\telse if ((dm_digtable->rssi_val_min + 10) < dm_dig_min)\n\t\t\tdm_digtable->rx_gain_max = dm_dig_min;\n\t\telse\n\t\t\tdm_digtable->rx_gain_max =\n\t\t\t\tdm_digtable->rssi_val_min + 10;\n\n\t\tif (rtlpriv->dm.one_entry_only) {\n\t\t\toffset = 12;\n\t\t\tif (dm_digtable->rssi_val_min - offset < dm_dig_min)\n\t\t\t\tdig_min_0 = dm_dig_min;\n\t\t\telse if (dm_digtable->rssi_val_min - offset >\n\t\t\t\t\t\t\tdig_maxofmin)\n\t\t\t\tdig_min_0 = dig_maxofmin;\n\t\t\telse\n\t\t\t\tdig_min_0 =\n\t\t\t\t\tdm_digtable->rssi_val_min - offset;\n\t\t} else {\n\t\t\tdig_min_0 = dm_dig_min;\n\t\t}\n\n\t} else {\n\t\tdm_digtable->rx_gain_max = dm_dig_max;\n\t\tdig_min_0 = dm_dig_min;\n\t\trtl_dbg(rtlpriv, COMP_DIG, DBG_LOUD, \"no link\\n\");\n\t}\n\n\tif (rtlpriv->falsealm_cnt.cnt_all > 10000) {\n\t\tif (dm_digtable->large_fa_hit != 3)\n\t\t\tdm_digtable->large_fa_hit++;\n\t\tif (dm_digtable->forbidden_igi < current_igi) {\n\t\t\tdm_digtable->forbidden_igi = current_igi;\n\t\t\tdm_digtable->large_fa_hit = 1;\n\t\t}\n\n\t\tif (dm_digtable->large_fa_hit >= 3) {\n\t\t\tif ((dm_digtable->forbidden_igi + 1) >\n\t\t\t     dm_digtable->rx_gain_max)\n\t\t\t\tdm_digtable->rx_gain_min =\n\t\t\t\t\t\tdm_digtable->rx_gain_max;\n\t\t\telse\n\t\t\t\tdm_digtable->rx_gain_min =\n\t\t\t\t\t\tdm_digtable->forbidden_igi + 1;\n\t\t\tdm_digtable->recover_cnt = 3600;\n\t\t}\n\t} else {\n\t\tif (dm_digtable->recover_cnt != 0) {\n\t\t\tdm_digtable->recover_cnt--;\n\t\t} else {\n\t\t\tif (dm_digtable->large_fa_hit < 3) {\n\t\t\t\tif ((dm_digtable->forbidden_igi - 1) <\n\t\t\t\t     dig_min_0) {\n\t\t\t\t\tdm_digtable->forbidden_igi =\n\t\t\t\t\t\t\tdig_min_0;\n\t\t\t\t\tdm_digtable->rx_gain_min =\n\t\t\t\t\t\t\tdig_min_0;\n\t\t\t\t} else {\n\t\t\t\t\tdm_digtable->forbidden_igi--;\n\t\t\t\t\tdm_digtable->rx_gain_min =\n\t\t\t\t\t\tdm_digtable->forbidden_igi + 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdm_digtable->large_fa_hit = 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (dm_digtable->rx_gain_min > dm_digtable->rx_gain_max)\n\t\tdm_digtable->rx_gain_min = dm_digtable->rx_gain_max;\n\n\tif (mac->link_state >= MAC80211_LINKED) {\n\t\tif (bfirstconnect) {\n\t\t\tif (dm_digtable->rssi_val_min <= dig_maxofmin)\n\t\t\t\tcurrent_igi = dm_digtable->rssi_val_min;\n\t\t\telse\n\t\t\t\tcurrent_igi = dig_maxofmin;\n\n\t\t\tdm_digtable->large_fa_hit = 0;\n\t\t} else {\n\t\t\tif (rtlpriv->falsealm_cnt.cnt_all > DM_DIG_FA_TH2)\n\t\t\t\tcurrent_igi += 4;\n\t\t\telse if (rtlpriv->falsealm_cnt.cnt_all > DM_DIG_FA_TH1)\n\t\t\t\tcurrent_igi += 2;\n\t\t\telse if (rtlpriv->falsealm_cnt.cnt_all < DM_DIG_FA_TH0)\n\t\t\t\tcurrent_igi -= 2;\n\t\t}\n\t} else {\n\t\tif (bfirstdisconnect) {\n\t\t\tcurrent_igi = dm_digtable->rx_gain_min;\n\t\t} else {\n\t\t\tif (rtlpriv->falsealm_cnt.cnt_all > 10000)\n\t\t\t\tcurrent_igi += 4;\n\t\t\telse if (rtlpriv->falsealm_cnt.cnt_all > 8000)\n\t\t\t\tcurrent_igi += 2;\n\t\t\telse if (rtlpriv->falsealm_cnt.cnt_all < 500)\n\t\t\t\tcurrent_igi -= 2;\n\t\t}\n\t}\n\n\tif (current_igi > dm_digtable->rx_gain_max)\n\t\tcurrent_igi = dm_digtable->rx_gain_max;\n\telse if (current_igi < dm_digtable->rx_gain_min)\n\t\tcurrent_igi = dm_digtable->rx_gain_min;\n\n\trtl8723be_dm_write_dig(hw, current_igi);\n\tdm_digtable->media_connect_0 =\n\t\t((mac->link_state >= MAC80211_LINKED) ? true : false);\n\tdm_digtable->dig_min_0 = dig_min_0;\n}\n\nstatic void rtl8723be_dm_false_alarm_counter_statistics(\n\t\t\t\t\tstruct ieee80211_hw *hw)\n{\n\tu32 ret_value;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct false_alarm_statistics *falsealm_cnt = &rtlpriv->falsealm_cnt;\n\n\trtl_set_bbreg(hw, DM_REG_OFDM_FA_HOLDC_11N, BIT(31), 1);\n\trtl_set_bbreg(hw, DM_REG_OFDM_FA_RSTD_11N, BIT(31), 1);\n\n\tret_value = rtl_get_bbreg(hw, DM_REG_OFDM_FA_TYPE1_11N, MASKDWORD);\n\tfalsealm_cnt->cnt_fast_fsync_fail = ret_value & 0xffff;\n\tfalsealm_cnt->cnt_sb_search_fail = (ret_value & 0xffff0000) >> 16;\n\n\tret_value = rtl_get_bbreg(hw, DM_REG_OFDM_FA_TYPE2_11N, MASKDWORD);\n\tfalsealm_cnt->cnt_ofdm_cca = ret_value & 0xffff;\n\tfalsealm_cnt->cnt_parity_fail = (ret_value & 0xffff0000) >> 16;\n\n\tret_value = rtl_get_bbreg(hw, DM_REG_OFDM_FA_TYPE3_11N, MASKDWORD);\n\tfalsealm_cnt->cnt_rate_illegal = ret_value & 0xffff;\n\tfalsealm_cnt->cnt_crc8_fail = (ret_value & 0xffff0000) >> 16;\n\n\tret_value = rtl_get_bbreg(hw, DM_REG_OFDM_FA_TYPE4_11N, MASKDWORD);\n\tfalsealm_cnt->cnt_mcs_fail = ret_value & 0xffff;\n\n\tfalsealm_cnt->cnt_ofdm_fail = falsealm_cnt->cnt_parity_fail +\n\t\t\t\t      falsealm_cnt->cnt_rate_illegal +\n\t\t\t\t      falsealm_cnt->cnt_crc8_fail +\n\t\t\t\t      falsealm_cnt->cnt_mcs_fail +\n\t\t\t\t      falsealm_cnt->cnt_fast_fsync_fail +\n\t\t\t\t      falsealm_cnt->cnt_sb_search_fail;\n\n\trtl_set_bbreg(hw, DM_REG_CCK_FA_RST_11N, BIT(12), 1);\n\trtl_set_bbreg(hw, DM_REG_CCK_FA_RST_11N, BIT(14), 1);\n\n\tret_value = rtl_get_bbreg(hw, DM_REG_CCK_FA_RST_11N, MASKBYTE0);\n\tfalsealm_cnt->cnt_cck_fail = ret_value;\n\n\tret_value = rtl_get_bbreg(hw, DM_REG_CCK_FA_MSB_11N, MASKBYTE3);\n\tfalsealm_cnt->cnt_cck_fail += (ret_value & 0xff) << 8;\n\n\tret_value = rtl_get_bbreg(hw, DM_REG_CCK_CCA_CNT_11N, MASKDWORD);\n\tfalsealm_cnt->cnt_cck_cca = ((ret_value & 0xff) << 8) |\n\t\t\t\t    ((ret_value & 0xff00) >> 8);\n\n\tfalsealm_cnt->cnt_all = falsealm_cnt->cnt_fast_fsync_fail +\n\t\t\t\tfalsealm_cnt->cnt_sb_search_fail +\n\t\t\t\tfalsealm_cnt->cnt_parity_fail +\n\t\t\t\tfalsealm_cnt->cnt_rate_illegal +\n\t\t\t\tfalsealm_cnt->cnt_crc8_fail +\n\t\t\t\tfalsealm_cnt->cnt_mcs_fail +\n\t\t\t\tfalsealm_cnt->cnt_cck_fail;\n\n\tfalsealm_cnt->cnt_cca_all = falsealm_cnt->cnt_ofdm_cca +\n\t\t\t\t    falsealm_cnt->cnt_cck_cca;\n\n\trtl_set_bbreg(hw, DM_REG_OFDM_FA_RSTC_11N, BIT(31), 1);\n\trtl_set_bbreg(hw, DM_REG_OFDM_FA_RSTC_11N, BIT(31), 0);\n\trtl_set_bbreg(hw, DM_REG_OFDM_FA_RSTD_11N, BIT(27), 1);\n\trtl_set_bbreg(hw, DM_REG_OFDM_FA_RSTD_11N, BIT(27), 0);\n\n\trtl_set_bbreg(hw, DM_REG_OFDM_FA_HOLDC_11N, BIT(31), 0);\n\trtl_set_bbreg(hw, DM_REG_OFDM_FA_RSTD_11N, BIT(31), 0);\n\n\trtl_set_bbreg(hw, DM_REG_CCK_FA_RST_11N, BIT(13) | BIT(12), 0);\n\trtl_set_bbreg(hw, DM_REG_CCK_FA_RST_11N, BIT(13) | BIT(12), 2);\n\n\trtl_set_bbreg(hw, DM_REG_CCK_FA_RST_11N, BIT(15) | BIT(14), 0);\n\trtl_set_bbreg(hw, DM_REG_CCK_FA_RST_11N, BIT(15) | BIT(14), 2);\n\n\trtl_dbg(rtlpriv, COMP_DIG, DBG_TRACE,\n\t\t\"cnt_parity_fail = %d, cnt_rate_illegal = %d, cnt_crc8_fail = %d, cnt_mcs_fail = %d\\n\",\n\t\tfalsealm_cnt->cnt_parity_fail,\n\t\tfalsealm_cnt->cnt_rate_illegal,\n\t\tfalsealm_cnt->cnt_crc8_fail,\n\t\tfalsealm_cnt->cnt_mcs_fail);\n\n\trtl_dbg(rtlpriv, COMP_DIG, DBG_TRACE,\n\t\t\"cnt_ofdm_fail = %x, cnt_cck_fail = %x, cnt_all = %x\\n\",\n\t\tfalsealm_cnt->cnt_ofdm_fail,\n\t\tfalsealm_cnt->cnt_cck_fail,\n\t\tfalsealm_cnt->cnt_all);\n}\n\nstatic void rtl8723be_dm_dynamic_txpower(struct ieee80211_hw *hw)\n{\n\t \n\treturn;\n}\n\nstatic void rtl8723be_set_iqk_matrix(struct ieee80211_hw *hw, u8 ofdm_index,\n\t\t\t\t     u8 rfpath, long iqk_result_x,\n\t\t\t\t     long iqk_result_y)\n{\n\tlong ele_a = 0, ele_d, ele_c = 0, value32;\n\n\tif (ofdm_index >= 43)\n\t\tofdm_index = 43 - 1;\n\n\tele_d = (ofdmswing_table[ofdm_index] & 0xFFC00000) >> 22;\n\n\tif (iqk_result_x != 0) {\n\t\tif ((iqk_result_x & 0x00000200) != 0)\n\t\t\tiqk_result_x = iqk_result_x | 0xFFFFFC00;\n\t\tele_a = ((iqk_result_x * ele_d) >> 8) & 0x000003FF;\n\n\t\tif ((iqk_result_y & 0x00000200) != 0)\n\t\t\tiqk_result_y = iqk_result_y | 0xFFFFFC00;\n\t\tele_c = ((iqk_result_y * ele_d) >> 8) & 0x000003FF;\n\n\t\tswitch (rfpath) {\n\t\tcase RF90_PATH_A:\n\t\t\tvalue32 = (ele_d << 22) |\n\t\t\t\t((ele_c & 0x3F) << 16) | ele_a;\n\t\t\trtl_set_bbreg(hw, ROFDM0_XATXIQIMBALANCE, MASKDWORD,\n\t\t\t\t      value32);\n\t\t\tvalue32 = (ele_c & 0x000003C0) >> 6;\n\t\t\trtl_set_bbreg(hw, ROFDM0_XCTXAFE, MASKH4BITS, value32);\n\t\t\tvalue32 = ((iqk_result_x * ele_d) >> 7) & 0x01;\n\t\t\trtl_set_bbreg(hw, ROFDM0_ECCATHRESHOLD, BIT(24),\n\t\t\t\t      value32);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (rfpath) {\n\t\tcase RF90_PATH_A:\n\t\t\trtl_set_bbreg(hw, ROFDM0_XATXIQIMBALANCE, MASKDWORD,\n\t\t\t\t      ofdmswing_table[ofdm_index]);\n\t\t\trtl_set_bbreg(hw, ROFDM0_XCTXAFE, MASKH4BITS, 0x00);\n\t\t\trtl_set_bbreg(hw, ROFDM0_ECCATHRESHOLD, BIT(24), 0x00);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void rtl8723be_dm_tx_power_track_set_power(struct ieee80211_hw *hw,\n\t\t\t\t\tenum pwr_track_control_method method,\n\t\t\t\t\tu8 rfpath, u8 idx)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\tstruct rtl_dm *rtldm = rtl_dm(rtl_priv(hw));\n\tu8 swing_idx_ofdm_limit = 36;\n\n\tif (method == TXAGC) {\n\t\trtl8723be_phy_set_txpower_level(hw, rtlphy->current_channel);\n\t} else if (method == BBSWING) {\n\t\tif (rtldm->swing_idx_cck >= CCK_TABLE_SIZE)\n\t\t\trtldm->swing_idx_cck = CCK_TABLE_SIZE - 1;\n\n\t\tif (!rtldm->cck_inch14) {\n\t\t\trtl_write_byte(rtlpriv, 0xa22,\n\t\t\t    cckswing_table_ch1ch13[rtldm->swing_idx_cck][0]);\n\t\t\trtl_write_byte(rtlpriv, 0xa23,\n\t\t\t    cckswing_table_ch1ch13[rtldm->swing_idx_cck][1]);\n\t\t\trtl_write_byte(rtlpriv, 0xa24,\n\t\t\t    cckswing_table_ch1ch13[rtldm->swing_idx_cck][2]);\n\t\t\trtl_write_byte(rtlpriv, 0xa25,\n\t\t\t    cckswing_table_ch1ch13[rtldm->swing_idx_cck][3]);\n\t\t\trtl_write_byte(rtlpriv, 0xa26,\n\t\t\t    cckswing_table_ch1ch13[rtldm->swing_idx_cck][4]);\n\t\t\trtl_write_byte(rtlpriv, 0xa27,\n\t\t\t    cckswing_table_ch1ch13[rtldm->swing_idx_cck][5]);\n\t\t\trtl_write_byte(rtlpriv, 0xa28,\n\t\t\t    cckswing_table_ch1ch13[rtldm->swing_idx_cck][6]);\n\t\t\trtl_write_byte(rtlpriv, 0xa29,\n\t\t\t    cckswing_table_ch1ch13[rtldm->swing_idx_cck][7]);\n\t\t} else {\n\t\t\trtl_write_byte(rtlpriv, 0xa22,\n\t\t\t    cckswing_table_ch14[rtldm->swing_idx_cck][0]);\n\t\t\trtl_write_byte(rtlpriv, 0xa23,\n\t\t\t    cckswing_table_ch14[rtldm->swing_idx_cck][1]);\n\t\t\trtl_write_byte(rtlpriv, 0xa24,\n\t\t\t    cckswing_table_ch14[rtldm->swing_idx_cck][2]);\n\t\t\trtl_write_byte(rtlpriv, 0xa25,\n\t\t\t    cckswing_table_ch14[rtldm->swing_idx_cck][3]);\n\t\t\trtl_write_byte(rtlpriv, 0xa26,\n\t\t\t    cckswing_table_ch14[rtldm->swing_idx_cck][4]);\n\t\t\trtl_write_byte(rtlpriv, 0xa27,\n\t\t\t    cckswing_table_ch14[rtldm->swing_idx_cck][5]);\n\t\t\trtl_write_byte(rtlpriv, 0xa28,\n\t\t\t    cckswing_table_ch14[rtldm->swing_idx_cck][6]);\n\t\t\trtl_write_byte(rtlpriv, 0xa29,\n\t\t\t    cckswing_table_ch14[rtldm->swing_idx_cck][7]);\n\t\t}\n\n\t\tif (rfpath == RF90_PATH_A) {\n\t\t\tif (rtldm->swing_idx_ofdm[RF90_PATH_A] <\n\t\t\t    swing_idx_ofdm_limit)\n\t\t\t\tswing_idx_ofdm_limit =\n\t\t\t\t\trtldm->swing_idx_ofdm[RF90_PATH_A];\n\n\t\t\trtl8723be_set_iqk_matrix(hw,\n\t\t\t\trtldm->swing_idx_ofdm[rfpath], rfpath,\n\t\t\t\trtlphy->iqk_matrix[idx].value[0][0],\n\t\t\t\trtlphy->iqk_matrix[idx].value[0][1]);\n\t\t} else if (rfpath == RF90_PATH_B) {\n\t\t\tif (rtldm->swing_idx_ofdm[RF90_PATH_B] <\n\t\t\t    swing_idx_ofdm_limit)\n\t\t\t\tswing_idx_ofdm_limit =\n\t\t\t\t\trtldm->swing_idx_ofdm[RF90_PATH_B];\n\n\t\t\trtl8723be_set_iqk_matrix(hw,\n\t\t\t\trtldm->swing_idx_ofdm[rfpath], rfpath,\n\t\t\t\trtlphy->iqk_matrix[idx].value[0][4],\n\t\t\t\trtlphy->iqk_matrix[idx].value[0][5]);\n\t\t}\n\t} else {\n\t\treturn;\n\t}\n}\n\nstatic void rtl8723be_dm_txpower_tracking_callback_thermalmeter(\n\t\t\t\t\t\t\tstruct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tstruct rtl_dm\t*rtldm = rtl_dm(rtl_priv(hw));\n\tu8 thermalvalue = 0, delta, delta_lck, delta_iqk;\n\tu8 thermalvalue_avg_count = 0;\n\tu32 thermalvalue_avg = 0;\n\tint i = 0;\n\n\tu8 ofdm_min_index = 6;\n\tu8 index_for_channel = 0;\n\n\tstatic const s8 delta_swing_table_idx_tup_a[TXSCALE_TABLE_SIZE] = {\n\t\t0, 0, 1, 2, 2, 2, 3, 3, 3, 4,  5,\n\t\t5, 6, 6, 7, 7, 8, 8, 9, 9, 9, 10,\n\t\t10, 11, 11, 12, 12, 13, 14, 15};\n\tstatic const s8 delta_swing_table_idx_tdown_a[TXSCALE_TABLE_SIZE] = {\n\t\t0, 0, 1, 2, 2, 2, 3, 3, 3, 4,  5,\n\t\t5, 6, 6, 6, 6, 7, 7, 7, 8, 8,  9,\n\t\t9, 10, 10, 11, 12, 13, 14, 15};\n\n\t \n\trtlpriv->dm.txpower_trackinginit = true;\n\trtl_dbg(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\n\t\t\"%s\\n\", __func__);\n\n\tthermalvalue = (u8)rtl_get_rfreg(hw,\n\t\tRF90_PATH_A, RF_T_METER, 0xfc00);\n\tif (!rtlpriv->dm.txpower_track_control || thermalvalue == 0 ||\n\t    rtlefuse->eeprom_thermalmeter == 0xFF)\n\t\treturn;\n\trtl_dbg(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\n\t\t\"Readback Thermal Meter = 0x%x pre thermal meter 0x%x eeprom_thermalmeter 0x%x\\n\",\n\t\tthermalvalue, rtldm->thermalvalue,\n\t\trtlefuse->eeprom_thermalmeter);\n\t \n\tif (!rtldm->thermalvalue) {\n\t\trtlpriv->dm.thermalvalue_lck = thermalvalue;\n\t\trtlpriv->dm.thermalvalue_iqk = thermalvalue;\n\t}\n\n\t \n\trtldm->thermalvalue_avg[rtldm->thermalvalue_avg_index] = thermalvalue;\n\trtldm->thermalvalue_avg_index++;\n\tif (rtldm->thermalvalue_avg_index == AVG_THERMAL_NUM_8723BE)\n\t\trtldm->thermalvalue_avg_index = 0;\n\n\tfor (i = 0; i < AVG_THERMAL_NUM_8723BE; i++) {\n\t\tif (rtldm->thermalvalue_avg[i]) {\n\t\t\tthermalvalue_avg += rtldm->thermalvalue_avg[i];\n\t\t\tthermalvalue_avg_count++;\n\t\t}\n\t}\n\n\tif (thermalvalue_avg_count)\n\t\tthermalvalue = (u8)(thermalvalue_avg / thermalvalue_avg_count);\n\n\t \n\tdelta = (thermalvalue > rtlpriv->dm.thermalvalue) ?\n\t\t(thermalvalue - rtlpriv->dm.thermalvalue) :\n\t\t(rtlpriv->dm.thermalvalue - thermalvalue);\n\tdelta_lck = (thermalvalue > rtlpriv->dm.thermalvalue_lck) ?\n\t\t    (thermalvalue - rtlpriv->dm.thermalvalue_lck) :\n\t\t    (rtlpriv->dm.thermalvalue_lck - thermalvalue);\n\tdelta_iqk = (thermalvalue > rtlpriv->dm.thermalvalue_iqk) ?\n\t\t    (thermalvalue - rtlpriv->dm.thermalvalue_iqk) :\n\t\t    (rtlpriv->dm.thermalvalue_iqk - thermalvalue);\n\n\trtl_dbg(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\n\t\t\"Readback Thermal Meter = 0x%x pre thermal meter 0x%x eeprom_thermalmeter 0x%x delta 0x%x delta_lck 0x%x delta_iqk 0x%x\\n\",\n\t\tthermalvalue, rtlpriv->dm.thermalvalue,\n\t\trtlefuse->eeprom_thermalmeter, delta, delta_lck, delta_iqk);\n\t \n\tif (delta_lck >= IQK_THRESHOLD) {\n\t\trtlpriv->dm.thermalvalue_lck = thermalvalue;\n\t\trtl8723be_phy_lc_calibrate(hw);\n\t}\n\n\t \n\tif (delta > 0 && rtlpriv->dm.txpower_track_control) {\n\t\tdelta = (thermalvalue > rtlefuse->eeprom_thermalmeter) ?\n\t\t\t(thermalvalue - rtlefuse->eeprom_thermalmeter) :\n\t\t\t(rtlefuse->eeprom_thermalmeter - thermalvalue);\n\n\t\tif (delta >= TXSCALE_TABLE_SIZE)\n\t\t\tdelta = TXSCALE_TABLE_SIZE - 1;\n\t\t \n\t\tif (thermalvalue > rtlefuse->eeprom_thermalmeter) {\n\t\t\trtldm->delta_power_index_last[RF90_PATH_A] =\n\t\t\t\t\trtldm->delta_power_index[RF90_PATH_A];\n\t\t\trtldm->delta_power_index[RF90_PATH_A] =\n\t\t\t\t\tdelta_swing_table_idx_tup_a[delta];\n\t\t} else {\n\t\t\trtldm->delta_power_index_last[RF90_PATH_A] =\n\t\t\t\t\trtldm->delta_power_index[RF90_PATH_A];\n\t\t\trtldm->delta_power_index[RF90_PATH_A] =\n\t\t\t\t-1 * delta_swing_table_idx_tdown_a[delta];\n\t\t}\n\n\t\t \n\t\tif (rtldm->delta_power_index[RF90_PATH_A] ==\n\t\t    rtldm->delta_power_index_last[RF90_PATH_A])\n\t\t\trtldm->power_index_offset[RF90_PATH_A] = 0;\n\t\telse\n\t\t\trtldm->power_index_offset[RF90_PATH_A] =\n\t\t\t\trtldm->delta_power_index[RF90_PATH_A] -\n\t\t\t\trtldm->delta_power_index_last[RF90_PATH_A];\n\n\t\trtldm->ofdm_index[0] =\n\t\t\trtldm->swing_idx_ofdm_base[RF90_PATH_A] +\n\t\t\trtldm->power_index_offset[RF90_PATH_A];\n\t\trtldm->cck_index = rtldm->swing_idx_cck_base +\n\t\t\t\t   rtldm->power_index_offset[RF90_PATH_A];\n\n\t\trtldm->swing_idx_cck = rtldm->cck_index;\n\t\trtldm->swing_idx_ofdm[0] = rtldm->ofdm_index[0];\n\n\t\tif (rtldm->ofdm_index[0] > OFDM_TABLE_SIZE - 1)\n\t\t\trtldm->ofdm_index[0] = OFDM_TABLE_SIZE - 1;\n\t\telse if (rtldm->ofdm_index[0] < ofdm_min_index)\n\t\t\trtldm->ofdm_index[0] = ofdm_min_index;\n\n\t\tif (rtldm->cck_index > CCK_TABLE_SIZE - 1)\n\t\t\trtldm->cck_index = CCK_TABLE_SIZE - 1;\n\t\telse if (rtldm->cck_index < 0)\n\t\t\trtldm->cck_index = 0;\n\t} else {\n\t\trtldm->power_index_offset[RF90_PATH_A] = 0;\n\t}\n\n\tif ((rtldm->power_index_offset[RF90_PATH_A] != 0) &&\n\t    (rtldm->txpower_track_control)) {\n\t\trtldm->done_txpower = true;\n\t\trtl8723be_dm_tx_power_track_set_power(hw, BBSWING, 0,\n\t\t\t\t\t\t      index_for_channel);\n\n\t\trtldm->swing_idx_cck_base = rtldm->swing_idx_cck;\n\t\trtldm->swing_idx_ofdm_base[RF90_PATH_A] =\n\t\t\t\t\t\trtldm->swing_idx_ofdm[0];\n\t\trtldm->thermalvalue = thermalvalue;\n\t}\n\n\tif (delta_iqk >= IQK_THRESHOLD) {\n\t\trtldm->thermalvalue_iqk = thermalvalue;\n\t\trtl8723be_phy_iq_calibrate(hw, false);\n\t}\n\n\trtldm->txpowercount = 0;\n\trtl_dbg(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, \"end\\n\");\n\n}\n\nvoid rtl8723be_dm_check_txpower_tracking(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\tif (!rtlpriv->dm.txpower_tracking)\n\t\treturn;\n\n\tif (!rtlpriv->dm.tm_trigger) {\n\t\trtl_set_rfreg(hw, RF90_PATH_A, RF_T_METER, BIT(17) | BIT(16),\n\t\t\t      0x03);\n\t\trtl_dbg(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\n\t\t\t\"Trigger 8723be Thermal Meter!!\\n\");\n\t\trtlpriv->dm.tm_trigger = 1;\n\t\treturn;\n\t} else {\n\t\trtl_dbg(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\n\t\t\t\"Schedule TxPowerTracking !!\\n\");\n\t\trtl8723be_dm_txpower_tracking_callback_thermalmeter(hw);\n\t\trtlpriv->dm.tm_trigger = 0;\n\t}\n}\n\nstatic void rtl8723be_dm_refresh_rate_adaptive_mask(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rate_adaptive *p_ra = &rtlpriv->ra;\n\tu32 low_rssithresh_for_ra = p_ra->low2high_rssi_thresh_for_ra40m;\n\tu32 high_rssithresh_for_ra = p_ra->high_rssi_thresh_for_ra;\n\tu8 go_up_gap = 5;\n\tstruct ieee80211_sta *sta = NULL;\n\n\tif (is_hal_stop(rtlhal)) {\n\t\trtl_dbg(rtlpriv, COMP_RATE, DBG_LOUD,\n\t\t\t\"driver is going to unload\\n\");\n\t\treturn;\n\t}\n\n\tif (!rtlpriv->dm.useramask) {\n\t\trtl_dbg(rtlpriv, COMP_RATE, DBG_LOUD,\n\t\t\t\"driver does not control rate adaptive mask\\n\");\n\t\treturn;\n\t}\n\n\tif (mac->link_state == MAC80211_LINKED &&\n\t\tmac->opmode == NL80211_IFTYPE_STATION) {\n\t\tswitch (p_ra->pre_ratr_state) {\n\t\tcase DM_RATR_STA_MIDDLE:\n\t\t\thigh_rssithresh_for_ra += go_up_gap;\n\t\t\tbreak;\n\t\tcase DM_RATR_STA_LOW:\n\t\t\thigh_rssithresh_for_ra += go_up_gap;\n\t\t\tlow_rssithresh_for_ra += go_up_gap;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rtlpriv->dm.undec_sm_pwdb >\n\t\t    (long)high_rssithresh_for_ra)\n\t\t\tp_ra->ratr_state = DM_RATR_STA_HIGH;\n\t\telse if (rtlpriv->dm.undec_sm_pwdb >\n\t\t\t (long)low_rssithresh_for_ra)\n\t\t\tp_ra->ratr_state = DM_RATR_STA_MIDDLE;\n\t\telse\n\t\t\tp_ra->ratr_state = DM_RATR_STA_LOW;\n\n\t\tif (p_ra->pre_ratr_state != p_ra->ratr_state) {\n\t\t\trtl_dbg(rtlpriv, COMP_RATE, DBG_LOUD,\n\t\t\t\t\"RSSI = %ld\\n\",\n\t\t\t\t rtlpriv->dm.undec_sm_pwdb);\n\t\t\trtl_dbg(rtlpriv, COMP_RATE, DBG_LOUD,\n\t\t\t\t\"RSSI_LEVEL = %d\\n\", p_ra->ratr_state);\n\t\t\trtl_dbg(rtlpriv, COMP_RATE, DBG_LOUD,\n\t\t\t\t\"PreState = %d, CurState = %d\\n\",\n\t\t\t\tp_ra->pre_ratr_state, p_ra->ratr_state);\n\n\t\t\trcu_read_lock();\n\t\t\tsta = rtl_find_sta(hw, mac->bssid);\n\t\t\tif (sta)\n\t\t\t\trtlpriv->cfg->ops->update_rate_tbl(hw, sta,\n\t\t\t\t\t\t\t   p_ra->ratr_state,\n\t\t\t\t\t\t\t   true);\n\t\t\trcu_read_unlock();\n\n\t\t\tp_ra->pre_ratr_state = p_ra->ratr_state;\n\t\t}\n\t}\n}\n\nstatic bool rtl8723be_dm_is_edca_turbo_disable(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\tif (rtlpriv->mac80211.mode == WIRELESS_MODE_B)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic void rtl8723be_dm_check_edca_turbo(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\n\tstatic u64 last_txok_cnt;\n\tstatic u64 last_rxok_cnt;\n\tu64 cur_txok_cnt = 0;\n\tu64 cur_rxok_cnt = 0;\n\tu32 edca_be_ul = 0x6ea42b;\n\tu32 edca_be_dl = 0x6ea42b; \n\tu32 edca_be = 0x5ea42b;\n\tu32 iot_peer = 0;\n\tbool b_is_cur_rdlstate;\n\tbool b_bias_on_rx = false;\n\tbool b_edca_turbo_on = false;\n\n\tcur_txok_cnt = rtlpriv->stats.txbytesunicast - last_txok_cnt;\n\tcur_rxok_cnt = rtlpriv->stats.rxbytesunicast - last_rxok_cnt;\n\n\tiot_peer = rtlpriv->mac80211.vendor;\n\tb_bias_on_rx = (iot_peer == PEER_RAL || iot_peer == PEER_ATH) ?\n\t\t       true : false;\n\tb_edca_turbo_on = ((!rtlpriv->dm.is_any_nonbepkts) &&\n\t\t\t   (!rtlpriv->dm.disable_framebursting)) ?\n\t\t\t   true : false;\n\n\tif ((iot_peer == PEER_CISCO) &&\n\t    (mac->mode == WIRELESS_MODE_N_24G)) {\n\t\tedca_be_dl = edca_setting_dl[iot_peer];\n\t\tedca_be_ul = edca_setting_ul[iot_peer];\n\t}\n\tif (rtl8723be_dm_is_edca_turbo_disable(hw))\n\t\tgoto exit;\n\n\tif (b_edca_turbo_on) {\n\t\tif (b_bias_on_rx)\n\t\t\tb_is_cur_rdlstate = (cur_txok_cnt > cur_rxok_cnt * 4) ?\n\t\t\t\t\t    false : true;\n\t\telse\n\t\t\tb_is_cur_rdlstate = (cur_rxok_cnt > cur_txok_cnt * 4) ?\n\t\t\t\t\t    true : false;\n\n\t\tedca_be = (b_is_cur_rdlstate) ? edca_be_dl : edca_be_ul;\n\t\trtl_write_dword(rtlpriv, REG_EDCA_BE_PARAM, edca_be);\n\t\trtlpriv->dm.is_cur_rdlstate = b_is_cur_rdlstate;\n\t\trtlpriv->dm.current_turbo_edca = true;\n\t} else {\n\t\tif (rtlpriv->dm.current_turbo_edca) {\n\t\t\tu8 tmp = AC0_BE;\n\t\t\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_AC_PARAM,\n\t\t\t\t\t\t      (u8 *)(&tmp));\n\t\t}\n\t\trtlpriv->dm.current_turbo_edca = false;\n\t}\n\nexit:\n\trtlpriv->dm.is_any_nonbepkts = false;\n\tlast_txok_cnt = rtlpriv->stats.txbytesunicast;\n\tlast_rxok_cnt = rtlpriv->stats.rxbytesunicast;\n}\n\nstatic void rtl8723be_dm_cck_packet_detection_thresh(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct dig_t *dm_digtable = &rtlpriv->dm_digtable;\n\tu8 cur_cck_cca_thresh;\n\n\tif (rtlpriv->mac80211.link_state >= MAC80211_LINKED) {\n\t\tif (dm_digtable->rssi_val_min > 25) {\n\t\t\tcur_cck_cca_thresh = 0xcd;\n\t\t} else if ((dm_digtable->rssi_val_min <= 25) &&\n\t\t\t   (dm_digtable->rssi_val_min > 10)) {\n\t\t\tcur_cck_cca_thresh = 0x83;\n\t\t} else {\n\t\t\tif (rtlpriv->falsealm_cnt.cnt_cck_fail > 1000)\n\t\t\t\tcur_cck_cca_thresh = 0x83;\n\t\t\telse\n\t\t\t\tcur_cck_cca_thresh = 0x40;\n\t\t}\n\t} else {\n\t\tif (rtlpriv->falsealm_cnt.cnt_cck_fail > 1000)\n\t\t\tcur_cck_cca_thresh = 0x83;\n\t\telse\n\t\t\tcur_cck_cca_thresh = 0x40;\n\t}\n\n\tif (dm_digtable->cur_cck_cca_thres != cur_cck_cca_thresh)\n\t\trtl_set_bbreg(hw, RCCK0_CCA, MASKBYTE2, cur_cck_cca_thresh);\n\n\tdm_digtable->pre_cck_cca_thres = dm_digtable->cur_cck_cca_thres;\n\tdm_digtable->cur_cck_cca_thres = cur_cck_cca_thresh;\n\trtl_dbg(rtlpriv, COMP_DIG, DBG_TRACE,\n\t\t\"CCK cca thresh hold =%x\\n\", dm_digtable->cur_cck_cca_thres);\n}\n\nstatic void rtl8723be_dm_dynamic_edcca(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 reg_c50, reg_c58;\n\tbool fw_current_in_ps_mode = false;\n\n\trtlpriv->cfg->ops->get_hw_reg(hw, HW_VAR_FW_PSMODE_STATUS,\n\t\t\t\t      (u8 *)(&fw_current_in_ps_mode));\n\tif (fw_current_in_ps_mode)\n\t\treturn;\n\n\treg_c50 = rtl_get_bbreg(hw, ROFDM0_XAAGCCORE1, MASKBYTE0);\n\treg_c58 = rtl_get_bbreg(hw, ROFDM0_XBAGCCORE1, MASKBYTE0);\n\n\tif (reg_c50 > 0x28 && reg_c58 > 0x28) {\n\t\tif (!rtlpriv->rtlhal.pre_edcca_enable) {\n\t\t\trtl_write_byte(rtlpriv, ROFDM0_ECCATHRESHOLD, 0x03);\n\t\t\trtl_write_byte(rtlpriv, ROFDM0_ECCATHRESHOLD + 2, 0x00);\n\t\t}\n\t} else if (reg_c50 < 0x25 && reg_c58 < 0x25) {\n\t\tif (rtlpriv->rtlhal.pre_edcca_enable) {\n\t\t\trtl_write_byte(rtlpriv, ROFDM0_ECCATHRESHOLD, 0x7f);\n\t\t\trtl_write_byte(rtlpriv, ROFDM0_ECCATHRESHOLD + 2, 0x7f);\n\t\t}\n\t}\n}\n\nstatic void rtl8723be_dm_dynamic_atc_switch(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_dm *rtldm = rtl_dm(rtl_priv(hw));\n\tu8 crystal_cap;\n\tu32 packet_count;\n\tint cfo_khz_a, cfo_khz_b, cfo_ave = 0, adjust_xtal = 0;\n\tint cfo_ave_diff;\n\n\tif (rtlpriv->mac80211.link_state < MAC80211_LINKED) {\n\t\tif (rtldm->atc_status == ATC_STATUS_OFF) {\n\t\t\trtl_set_bbreg(hw, ROFDM1_CFOTRACKING, BIT(11),\n\t\t\t\t      ATC_STATUS_ON);\n\t\t\trtldm->atc_status = ATC_STATUS_ON;\n\t\t}\n\t\tif (rtlpriv->cfg->ops->get_btc_status()) {\n\t\t\tif (!rtlpriv->btcoexist.btc_ops->btc_is_bt_disabled(rtlpriv)) {\n\t\t\t\trtl_dbg(rtlpriv, COMP_BT_COEXIST, DBG_LOUD,\n\t\t\t\t\t\"odm_DynamicATCSwitch(): Disable CFO tracking for BT!!\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (rtldm->crystal_cap != rtlpriv->efuse.crystalcap) {\n\t\t\trtldm->crystal_cap = rtlpriv->efuse.crystalcap;\n\t\t\tcrystal_cap = rtldm->crystal_cap & 0x3f;\n\t\t\trtl_set_bbreg(hw, REG_MAC_PHY_CTRL, 0xFFF000,\n\t\t\t\t      (crystal_cap | (crystal_cap << 6)));\n\t\t}\n\t} else {\n\t\tcfo_khz_a = (int)(rtldm->cfo_tail[0] * 3125) / 1280;\n\t\tcfo_khz_b = (int)(rtldm->cfo_tail[1] * 3125) / 1280;\n\t\tpacket_count = rtldm->packet_count;\n\n\t\tif (packet_count == rtldm->packet_count_pre)\n\t\t\treturn;\n\n\t\trtldm->packet_count_pre = packet_count;\n\n\t\tif (rtlpriv->phy.rf_type == RF_1T1R)\n\t\t\tcfo_ave = cfo_khz_a;\n\t\telse\n\t\t\tcfo_ave = (int)(cfo_khz_a + cfo_khz_b) >> 1;\n\n\t\tcfo_ave_diff = (rtldm->cfo_ave_pre >= cfo_ave) ?\n\t\t\t       (rtldm->cfo_ave_pre - cfo_ave) :\n\t\t\t       (cfo_ave - rtldm->cfo_ave_pre);\n\n\t\tif (cfo_ave_diff > 20 && !rtldm->large_cfo_hit) {\n\t\t\trtldm->large_cfo_hit = true;\n\t\t\treturn;\n\t\t} else\n\t\t\trtldm->large_cfo_hit = false;\n\n\t\trtldm->cfo_ave_pre = cfo_ave;\n\n\t\tif (cfo_ave >= -rtldm->cfo_threshold &&\n\t\t    cfo_ave <= rtldm->cfo_threshold && rtldm->is_freeze == 0) {\n\t\t\tif (rtldm->cfo_threshold == CFO_THRESHOLD_XTAL) {\n\t\t\t\trtldm->cfo_threshold = CFO_THRESHOLD_XTAL + 10;\n\t\t\t\trtldm->is_freeze = 1;\n\t\t\t} else {\n\t\t\t\trtldm->cfo_threshold = CFO_THRESHOLD_XTAL;\n\t\t\t}\n\t\t}\n\n\t\tif (cfo_ave > rtldm->cfo_threshold && rtldm->crystal_cap < 0x3f)\n\t\t\tadjust_xtal = ((cfo_ave - CFO_THRESHOLD_XTAL) >> 1) + 1;\n\t\telse if ((cfo_ave < -rtlpriv->dm.cfo_threshold) &&\n\t\t\t\t\trtlpriv->dm.crystal_cap > 0)\n\t\t\tadjust_xtal = ((cfo_ave + CFO_THRESHOLD_XTAL) >> 1) - 1;\n\n\t\tif (adjust_xtal != 0) {\n\t\t\trtldm->is_freeze = 0;\n\t\t\trtldm->crystal_cap += adjust_xtal;\n\n\t\t\tif (rtldm->crystal_cap > 0x3f)\n\t\t\t\trtldm->crystal_cap = 0x3f;\n\t\t\telse if (rtldm->crystal_cap < 0)\n\t\t\t\trtldm->crystal_cap = 0;\n\n\t\t\tcrystal_cap = rtldm->crystal_cap & 0x3f;\n\t\t\trtl_set_bbreg(hw, REG_MAC_PHY_CTRL, 0xFFF000,\n\t\t\t\t      (crystal_cap | (crystal_cap << 6)));\n\t\t}\n\n\t\tif (cfo_ave < CFO_THRESHOLD_ATC &&\n\t\t    cfo_ave > -CFO_THRESHOLD_ATC) {\n\t\t\tif (rtldm->atc_status == ATC_STATUS_ON) {\n\t\t\t\trtl_set_bbreg(hw, ROFDM1_CFOTRACKING, BIT(11),\n\t\t\t\t\t      ATC_STATUS_OFF);\n\t\t\t\trtldm->atc_status = ATC_STATUS_OFF;\n\t\t\t}\n\t\t} else {\n\t\t\tif (rtldm->atc_status == ATC_STATUS_OFF) {\n\t\t\t\trtl_set_bbreg(hw, ROFDM1_CFOTRACKING, BIT(11),\n\t\t\t\t\t      ATC_STATUS_ON);\n\t\t\t\trtldm->atc_status = ATC_STATUS_ON;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void rtl8723be_dm_common_info_self_update(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 cnt = 0;\n\tstruct rtl_sta_info *drv_priv;\n\n\trtlpriv->dm.one_entry_only = false;\n\n\tif (rtlpriv->mac80211.opmode == NL80211_IFTYPE_STATION &&\n\t\trtlpriv->mac80211.link_state >= MAC80211_LINKED) {\n\t\trtlpriv->dm.one_entry_only = true;\n\t\treturn;\n\t}\n\n\tif (rtlpriv->mac80211.opmode == NL80211_IFTYPE_AP ||\n\t\trtlpriv->mac80211.opmode == NL80211_IFTYPE_ADHOC ||\n\t\trtlpriv->mac80211.opmode == NL80211_IFTYPE_MESH_POINT) {\n\t\tspin_lock_bh(&rtlpriv->locks.entry_list_lock);\n\t\tlist_for_each_entry(drv_priv, &rtlpriv->entry_list, list) {\n\t\t\tcnt++;\n\t\t}\n\t\tspin_unlock_bh(&rtlpriv->locks.entry_list_lock);\n\n\t\tif (cnt == 1)\n\t\t\trtlpriv->dm.one_entry_only = true;\n\t}\n}\n\nvoid rtl8723be_dm_watchdog(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tbool fw_current_inpsmode = false;\n\tbool fw_ps_awake = true;\n\n\trtlpriv->cfg->ops->get_hw_reg(hw, HW_VAR_FW_PSMODE_STATUS,\n\t\t\t\t      (u8 *)(&fw_current_inpsmode));\n\n\trtlpriv->cfg->ops->get_hw_reg(hw, HW_VAR_FWLPS_RF_ON,\n\t\t\t\t      (u8 *)(&fw_ps_awake));\n\n\tif (ppsc->p2p_ps_info.p2p_ps_mode)\n\t\tfw_ps_awake = false;\n\n\tspin_lock(&rtlpriv->locks.rf_ps_lock);\n\tif ((ppsc->rfpwr_state == ERFON) &&\n\t\t((!fw_current_inpsmode) && fw_ps_awake) &&\n\t\t(!ppsc->rfchange_inprogress)) {\n\t\trtl8723be_dm_common_info_self_update(hw);\n\t\trtl8723be_dm_false_alarm_counter_statistics(hw);\n\t\trtl8723be_dm_check_rssi_monitor(hw);\n\t\trtl8723be_dm_dig(hw);\n\t\trtl8723be_dm_dynamic_edcca(hw);\n\t\trtl8723be_dm_cck_packet_detection_thresh(hw);\n\t\trtl8723be_dm_refresh_rate_adaptive_mask(hw);\n\t\trtl8723be_dm_check_edca_turbo(hw);\n\t\trtl8723be_dm_dynamic_atc_switch(hw);\n\t\trtl8723be_dm_check_txpower_tracking(hw);\n\t\trtl8723be_dm_dynamic_txpower(hw);\n\t}\n\tspin_unlock(&rtlpriv->locks.rf_ps_lock);\n\trtlpriv->dm.dbginfo.num_qry_beacon_pkt = 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}