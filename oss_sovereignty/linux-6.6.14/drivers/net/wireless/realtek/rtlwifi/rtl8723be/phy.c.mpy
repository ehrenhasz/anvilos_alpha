{
  "module_name": "phy.c",
  "hash_id": "5d765b09a7e8736116e1d88ef152f606194dc11bcf7fa7b638f071e405451a2d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtlwifi/rtl8723be/phy.c",
  "human_readable_source": "\n \n\n#include \"../wifi.h\"\n#include \"../pci.h\"\n#include \"../ps.h\"\n#include \"reg.h\"\n#include \"def.h\"\n#include \"phy.h\"\n#include \"../rtl8723com/phy_common.h\"\n#include \"rf.h\"\n#include \"dm.h\"\n#include \"../rtl8723com/dm_common.h\"\n#include \"table.h\"\n#include \"trx.h\"\n#include <linux/kernel.h>\n\nstatic bool _rtl8723be_phy_bb8723b_config_parafile(struct ieee80211_hw *hw);\nstatic bool _rtl8723be_phy_config_mac_with_headerfile(struct ieee80211_hw *hw);\nstatic bool _rtl8723be_phy_config_bb_with_headerfile(struct ieee80211_hw *hw,\n\t\t\t\t\t\t     u8 configtype);\nstatic bool _rtl8723be_phy_config_bb_with_pgheaderfile(struct ieee80211_hw *hw,\n\t\t\t\t\t\t       u8 configtype);\nstatic bool _rtl8723be_phy_sw_chnl_step_by_step(struct ieee80211_hw *hw,\n\t\t\t\t\t\tu8 channel, u8 *stage,\n\t\t\t\t\t\tu8 *step, u32 *delay);\n\nstatic void rtl8723be_phy_set_rf_on(struct ieee80211_hw *hw);\nstatic void rtl8723be_phy_set_io(struct ieee80211_hw *hw);\n\nu32 rtl8723be_phy_query_rf_reg(struct ieee80211_hw *hw, enum radio_path rfpath,\n\t\t\t       u32 regaddr, u32 bitmask)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 original_value, readback_value, bitshift;\n\n\trtl_dbg(rtlpriv, COMP_RF, DBG_TRACE,\n\t\t\"regaddr(%#x), rfpath(%#x), bitmask(%#x)\\n\",\n\t\tregaddr, rfpath, bitmask);\n\n\tspin_lock(&rtlpriv->locks.rf_lock);\n\n\toriginal_value = rtl8723_phy_rf_serial_read(hw, rfpath, regaddr);\n\tbitshift = rtl8723_phy_calculate_bit_shift(bitmask);\n\treadback_value = (original_value & bitmask) >> bitshift;\n\n\tspin_unlock(&rtlpriv->locks.rf_lock);\n\n\trtl_dbg(rtlpriv, COMP_RF, DBG_TRACE,\n\t\t\"regaddr(%#x), rfpath(%#x), bitmask(%#x), original_value(%#x)\\n\",\n\t\tregaddr, rfpath, bitmask, original_value);\n\n\treturn readback_value;\n}\n\nvoid rtl8723be_phy_set_rf_reg(struct ieee80211_hw *hw, enum radio_path path,\n\t\t\t      u32 regaddr, u32 bitmask, u32 data)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 original_value, bitshift;\n\n\trtl_dbg(rtlpriv, COMP_RF, DBG_TRACE,\n\t\t\"regaddr(%#x), bitmask(%#x), data(%#x), rfpath(%#x)\\n\",\n\t\tregaddr, bitmask, data, path);\n\n\tspin_lock(&rtlpriv->locks.rf_lock);\n\n\tif (bitmask != RFREG_OFFSET_MASK) {\n\t\t\toriginal_value = rtl8723_phy_rf_serial_read(hw, path,\n\t\t\t\t\t\t\t\t    regaddr);\n\t\t\tbitshift = rtl8723_phy_calculate_bit_shift(bitmask);\n\t\t\tdata = ((original_value & (~bitmask)) |\n\t\t\t\t(data << bitshift));\n\t\t}\n\n\trtl8723_phy_rf_serial_write(hw, path, regaddr, data);\n\n\tspin_unlock(&rtlpriv->locks.rf_lock);\n\n\trtl_dbg(rtlpriv, COMP_RF, DBG_TRACE,\n\t\t\"regaddr(%#x), bitmask(%#x), data(%#x), rfpath(%#x)\\n\",\n\t\tregaddr, bitmask, data, path);\n\n}\n\nbool rtl8723be_phy_mac_config(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tbool rtstatus = _rtl8723be_phy_config_mac_with_headerfile(hw);\n\n\trtl_write_byte(rtlpriv, 0x04CA, 0x0B);\n\treturn rtstatus;\n}\n\nbool rtl8723be_phy_bb_config(struct ieee80211_hw *hw)\n{\n\tbool rtstatus = true;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu16 regval;\n\tu8 b_reg_hwparafile = 1;\n\tu32 tmp;\n\tu8 crystalcap = rtlpriv->efuse.crystalcap;\n\trtl8723_phy_init_bb_rf_reg_def(hw);\n\tregval = rtl_read_word(rtlpriv, REG_SYS_FUNC_EN);\n\trtl_write_word(rtlpriv, REG_SYS_FUNC_EN,\n\t\t       regval | BIT(13) | BIT(0) | BIT(1));\n\n\trtl_write_byte(rtlpriv, REG_RF_CTRL, RF_EN | RF_RSTB | RF_SDMRSTB);\n\trtl_write_byte(rtlpriv, REG_SYS_FUNC_EN,\n\t\t       FEN_PPLL | FEN_PCIEA | FEN_DIO_PCIE |\n\t\t       FEN_BB_GLB_RSTN | FEN_BBRSTB);\n\ttmp = rtl_read_dword(rtlpriv, 0x4c);\n\trtl_write_dword(rtlpriv, 0x4c, tmp | BIT(23));\n\n\trtl_write_byte(rtlpriv, REG_AFE_XTAL_CTRL + 1, 0x80);\n\n\tif (b_reg_hwparafile == 1)\n\t\trtstatus = _rtl8723be_phy_bb8723b_config_parafile(hw);\n\n\tcrystalcap = crystalcap & 0x3F;\n\trtl_set_bbreg(hw, REG_MAC_PHY_CTRL, 0xFFF000,\n\t\t      (crystalcap | crystalcap << 6));\n\n\treturn rtstatus;\n}\n\nbool rtl8723be_phy_rf_config(struct ieee80211_hw *hw)\n{\n\treturn rtl8723be_phy_rf6052_config(hw);\n}\n\nstatic bool _rtl8723be_check_positive(struct ieee80211_hw *hw,\n\t\t\t\t      const u32 condition1,\n\t\t\t\t      const u32 condition2)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\n\tu32 cut_ver = ((rtlhal->version & CHIP_VER_RTL_MASK)\n\t\t\t\t\t>> CHIP_VER_RTL_SHIFT);\n\tu32 intf = (rtlhal->interface == INTF_USB ? BIT(1) : BIT(0));\n\n\tu8  board_type = ((rtlhal->board_type & BIT(4)) >> 4) << 0 |  \n\t\t\t ((rtlhal->board_type & BIT(3)) >> 3) << 1 |  \n\t\t\t ((rtlhal->board_type & BIT(7)) >> 7) << 2 |  \n\t\t\t ((rtlhal->board_type & BIT(6)) >> 6) << 3 |  \n\t\t\t ((rtlhal->board_type & BIT(2)) >> 2) << 4;   \n\n\tu32 cond1 = condition1, cond2 = condition2;\n\tu32 driver1 = cut_ver << 24 |\t \n\t\t      0 << 20 |\t\t\t \n\t\t      0x04 << 16 |\t\t \n\t\t      rtlhal->package_type << 12 |\n\t\t      intf << 8 |\t\t\t \n\t\t      board_type;\n\n\tu32 driver2 = rtlhal->type_glna <<  0 |\n\t\t      rtlhal->type_gpa  <<  8 |\n\t\t      rtlhal->type_alna << 16 |\n\t\t      rtlhal->type_apa  << 24;\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\"===> [8812A] CheckPositive (cond1, cond2) = (0x%X 0x%X)\\n\",\n\t\tcond1, cond2);\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\"===> [8812A] CheckPositive (driver1, driver2) = (0x%X 0x%X)\\n\",\n\t\tdriver1, driver2);\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\"(Platform, Interface) = (0x%X, 0x%X)\\n\", 0x04, intf);\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\"(Board, Package) = (0x%X, 0x%X)\\n\",\n\t\trtlhal->board_type, rtlhal->package_type);\n\n\t \n\t \n\n\tif (((cond1 & 0x0000F000) != 0) && ((cond1 & 0x0000F000) !=\n\t\t(driver1 & 0x0000F000)))\n\t\treturn false;\n\tif (((cond1 & 0x0F000000) != 0) && ((cond1 & 0x0F000000) !=\n\t\t(driver1 & 0x0F000000)))\n\t\treturn false;\n\n\t \n\t \n\n\tcond1   &= 0x00FF0FFF;\n\tdriver1 &= 0x00FF0FFF;\n\n\tif ((cond1 & driver1) == cond1) {\n\t\tu32 mask = 0;\n\n\t\tif ((cond1 & 0x0F) == 0)  \n\t\t\treturn true;\n\n\t\tif ((cond1 & BIT(0)) != 0)  \n\t\t\tmask |= 0x000000FF;\n\t\tif ((cond1 & BIT(1)) != 0)  \n\t\t\tmask |= 0x0000FF00;\n\t\tif ((cond1 & BIT(2)) != 0)  \n\t\t\tmask |= 0x00FF0000;\n\t\tif ((cond1 & BIT(3)) != 0)  \n\t\t\tmask |= 0xFF000000;\n\n\t\t \n\t\tif ((cond2 & mask) == (driver2 & mask))\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\treturn false;\n}\n\nstatic void _rtl8723be_config_rf_reg(struct ieee80211_hw *hw, u32 addr,\n\t\t\t\t     u32 data, enum radio_path rfpath,\n\t\t\t\t     u32 regaddr)\n{\n\tif (addr == 0xfe || addr == 0xffe) {\n\t\t \n\t\tmdelay(50);\n\t} else {\n\t\trtl_set_rfreg(hw, rfpath, regaddr, RFREG_OFFSET_MASK, data);\n\t\tudelay(1);\n\t}\n}\nstatic void _rtl8723be_config_rf_radio_a(struct ieee80211_hw *hw,\n\t\t\t\t\t u32 addr, u32 data)\n{\n\tu32 content = 0x1000;  \n\tu32 maskforphyset = (u32)(content & 0xE000);\n\n\t_rtl8723be_config_rf_reg(hw, addr, data, RF90_PATH_A,\n\t\t\t\t addr | maskforphyset);\n\n}\n\nstatic void _rtl8723be_phy_init_tx_power_by_rate(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\n\tu8 band, path, txnum, section;\n\n\tfor (band = BAND_ON_2_4G; band <= BAND_ON_5G; ++band)\n\t\tfor (path = 0; path < TX_PWR_BY_RATE_NUM_RF; ++path)\n\t\t\tfor (txnum = 0; txnum < TX_PWR_BY_RATE_NUM_RF; ++txnum)\n\t\t\t\tfor (section = 0;\n\t\t\t\t     section < TX_PWR_BY_RATE_NUM_SECTION;\n\t\t\t\t     ++section)\n\t\t\t\t\trtlphy->tx_power_by_rate_offset\n\t\t\t\t\t  [band][path][txnum][section] = 0;\n}\n\nstatic void _rtl8723be_config_bb_reg(struct ieee80211_hw *hw,\n\t\t\t\t     u32 addr, u32 data)\n{\n\tif (addr == 0xfe) {\n\t\tmdelay(50);\n\t} else if (addr == 0xfd) {\n\t\tmdelay(5);\n\t} else if (addr == 0xfc) {\n\t\tmdelay(1);\n\t} else if (addr == 0xfb) {\n\t\tudelay(50);\n\t} else if (addr == 0xfa) {\n\t\tudelay(5);\n\t} else if (addr == 0xf9) {\n\t\tudelay(1);\n\t} else {\n\t\trtl_set_bbreg(hw, addr, MASKDWORD, data);\n\t\tudelay(1);\n\t}\n}\n\nstatic void _rtl8723be_phy_set_txpower_by_rate_base(struct ieee80211_hw *hw,\n\t\t\t\t\t\t    u8 band,\n\t\t\t\t\t\t    u8 path, u8 rate_section,\n\t\t\t\t\t\t    u8 txnum, u8 value)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\n\tif (path > RF90_PATH_D) {\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\"Invalid Rf Path %d in phy_SetTxPowerByRatBase()\\n\",\n\t\t\tpath);\n\t\treturn;\n\t}\n\n\tif (band == BAND_ON_2_4G) {\n\t\tswitch (rate_section) {\n\t\tcase CCK:\n\t\t\trtlphy->txpwr_by_rate_base_24g[path][txnum][0] = value;\n\t\t\tbreak;\n\t\tcase OFDM:\n\t\t\trtlphy->txpwr_by_rate_base_24g[path][txnum][1] = value;\n\t\t\tbreak;\n\t\tcase HT_MCS0_MCS7:\n\t\t\trtlphy->txpwr_by_rate_base_24g[path][txnum][2] = value;\n\t\t\tbreak;\n\t\tcase HT_MCS8_MCS15:\n\t\t\trtlphy->txpwr_by_rate_base_24g[path][txnum][3] = value;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\t\"Invalid RateSection %d in Band 2.4G, Rf Path %d, %dTx in PHY_SetTxPowerByRateBase()\\n\",\n\t\t\t\trate_section, path, txnum);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\"Invalid Band %d in PHY_SetTxPowerByRateBase()\\n\",\n\t\t\tband);\n\t}\n\n}\n\nstatic u8 _rtl8723be_phy_get_txpower_by_rate_base(struct ieee80211_hw *hw,\n\t\t\t\t\t\t  u8 band, u8 path, u8 txnum,\n\t\t\t\t\t\t  u8 rate_section)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\tu8 value = 0;\n\tif (path > RF90_PATH_D) {\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\"Invalid Rf Path %d in PHY_GetTxPowerByRateBase()\\n\",\n\t\t\tpath);\n\t\treturn 0;\n\t}\n\n\tif (band == BAND_ON_2_4G) {\n\t\tswitch (rate_section) {\n\t\tcase CCK:\n\t\t\tvalue = rtlphy->txpwr_by_rate_base_24g[path][txnum][0];\n\t\t\tbreak;\n\t\tcase OFDM:\n\t\t\tvalue = rtlphy->txpwr_by_rate_base_24g[path][txnum][1];\n\t\t\tbreak;\n\t\tcase HT_MCS0_MCS7:\n\t\t\tvalue = rtlphy->txpwr_by_rate_base_24g[path][txnum][2];\n\t\t\tbreak;\n\t\tcase HT_MCS8_MCS15:\n\t\t\tvalue = rtlphy->txpwr_by_rate_base_24g[path][txnum][3];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\t\"Invalid RateSection %d in Band 2.4G, Rf Path %d, %dTx in PHY_GetTxPowerByRateBase()\\n\",\n\t\t\t\trate_section, path, txnum);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\"Invalid Band %d in PHY_GetTxPowerByRateBase()\\n\",\n\t\t\tband);\n\t}\n\n\treturn value;\n}\n\nstatic void _rtl8723be_phy_store_txpower_by_rate_base(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\tu16 rawvalue = 0;\n\tu8 base = 0, path = 0;\n\n\tfor (path = RF90_PATH_A; path <= RF90_PATH_B; ++path) {\n\t\tif (path == RF90_PATH_A) {\n\t\t\trawvalue = (u16)(rtlphy->tx_power_by_rate_offset\n\t\t\t\t[BAND_ON_2_4G][path][RF_1TX][3] >> 24) & 0xFF;\n\t\t\tbase = (rawvalue >> 4) * 10 + (rawvalue & 0xF);\n\t\t\t_rtl8723be_phy_set_txpower_by_rate_base(hw,\n\t\t\t\tBAND_ON_2_4G, path, CCK, RF_1TX, base);\n\t\t} else if (path == RF90_PATH_B) {\n\t\t\trawvalue = (u16)(rtlphy->tx_power_by_rate_offset\n\t\t\t\t[BAND_ON_2_4G][path][RF_1TX][3] >> 0) & 0xFF;\n\t\t\tbase = (rawvalue >> 4) * 10 + (rawvalue & 0xF);\n\t\t\t_rtl8723be_phy_set_txpower_by_rate_base(hw,\n\t\t\t\t\t\t\t\tBAND_ON_2_4G,\n\t\t\t\t\t\t\t\tpath, CCK,\n\t\t\t\t\t\t\t\tRF_1TX, base);\n\t\t}\n\t\trawvalue = (u16)(rtlphy->tx_power_by_rate_offset\n\t\t\t\t[BAND_ON_2_4G][path][RF_1TX][1] >> 24) & 0xFF;\n\t\tbase = (rawvalue >> 4) * 10 + (rawvalue & 0xF);\n\t\t_rtl8723be_phy_set_txpower_by_rate_base(hw, BAND_ON_2_4G,\n\t\t\t\t\t\t\tpath, OFDM, RF_1TX,\n\t\t\t\t\t\t\tbase);\n\n\t\trawvalue = (u16)(rtlphy->tx_power_by_rate_offset\n\t\t\t\t[BAND_ON_2_4G][path][RF_1TX][5] >> 24) & 0xFF;\n\t\tbase = (rawvalue >> 4) * 10 + (rawvalue & 0xF);\n\t\t_rtl8723be_phy_set_txpower_by_rate_base(hw, BAND_ON_2_4G,\n\t\t\t\t\t\t\tpath, HT_MCS0_MCS7,\n\t\t\t\t\t\t\tRF_1TX, base);\n\n\t\trawvalue = (u16)(rtlphy->tx_power_by_rate_offset\n\t\t\t\t[BAND_ON_2_4G][path][RF_2TX][7] >> 24) & 0xFF;\n\t\tbase = (rawvalue >> 4) * 10 + (rawvalue & 0xF);\n\t\t_rtl8723be_phy_set_txpower_by_rate_base(hw, BAND_ON_2_4G,\n\t\t\t\t\t\t\tpath, HT_MCS8_MCS15,\n\t\t\t\t\t\t\tRF_2TX, base);\n\t}\n}\n\nstatic void _phy_convert_txpower_dbm_to_relative_value(u32 *data, u8 start,\n\t\t\t\t\t\tu8 end, u8 base_val)\n{\n\ts8 i = 0;\n\tu8 temp_value = 0;\n\tu32 temp_data = 0;\n\n\tfor (i = 3; i >= 0; --i) {\n\t\tif (i >= start && i <= end) {\n\t\t\t \n\t\t\ttemp_value = (u8)(*data >> (i * 8)) & 0xF;\n\t\t\ttemp_value += ((u8)((*data >> (i*8 + 4)) & 0xF)) * 10;\n\n\t\t\t \n\t\t\ttemp_value = (temp_value > base_val) ?\n\t\t\t\t     temp_value - base_val :\n\t\t\t\t     base_val - temp_value;\n\t\t} else {\n\t\t\ttemp_value = (u8)(*data >> (i * 8)) & 0xFF;\n\t\t}\n\t\ttemp_data <<= 8;\n\t\ttemp_data |= temp_value;\n\t}\n\t*data = temp_data;\n}\n\nstatic void _rtl8723be_phy_convert_txpower_dbm_to_relative_value(\n\t\t\t\t\t\t\tstruct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\tu8 base = 0, rfpath = RF90_PATH_A;\n\n\tbase = _rtl8723be_phy_get_txpower_by_rate_base(hw,\n\t\t\tBAND_ON_2_4G, rfpath, RF_1TX, CCK);\n\t_phy_convert_txpower_dbm_to_relative_value(\n\t    &rtlphy->tx_power_by_rate_offset[BAND_ON_2_4G][rfpath][RF_1TX][2],\n\t    1, 1, base);\n\t_phy_convert_txpower_dbm_to_relative_value(\n\t    &rtlphy->tx_power_by_rate_offset[BAND_ON_2_4G][rfpath][RF_1TX][3],\n\t    1, 3, base);\n\n\tbase = _rtl8723be_phy_get_txpower_by_rate_base(hw, BAND_ON_2_4G, rfpath,\n\t\t\t\t\t\t       RF_1TX, OFDM);\n\t_phy_convert_txpower_dbm_to_relative_value(\n\t    &rtlphy->tx_power_by_rate_offset[BAND_ON_2_4G][rfpath][RF_1TX][0],\n\t    0, 3, base);\n\t_phy_convert_txpower_dbm_to_relative_value(\n\t    &rtlphy->tx_power_by_rate_offset[BAND_ON_2_4G][rfpath][RF_1TX][1],\n\t    0, 3, base);\n\n\tbase = _rtl8723be_phy_get_txpower_by_rate_base(hw, BAND_ON_2_4G,\n\t\t\t\t\t\trfpath, RF_1TX, HT_MCS0_MCS7);\n\t_phy_convert_txpower_dbm_to_relative_value(\n\t    &rtlphy->tx_power_by_rate_offset[BAND_ON_2_4G][rfpath][RF_1TX][4],\n\t    0, 3, base);\n\t_phy_convert_txpower_dbm_to_relative_value(\n\t    &rtlphy->tx_power_by_rate_offset[BAND_ON_2_4G][rfpath][RF_1TX][5],\n\t    0, 3, base);\n\n\tbase = _rtl8723be_phy_get_txpower_by_rate_base(hw, BAND_ON_2_4G,\n\t\t\t\t\t\t       rfpath, RF_2TX,\n\t\t\t\t\t\t       HT_MCS8_MCS15);\n\t_phy_convert_txpower_dbm_to_relative_value(\n\t    &rtlphy->tx_power_by_rate_offset[BAND_ON_2_4G][rfpath][RF_2TX][6],\n\t    0, 3, base);\n\n\t_phy_convert_txpower_dbm_to_relative_value(\n\t    &rtlphy->tx_power_by_rate_offset[BAND_ON_2_4G][rfpath][RF_2TX][7],\n\t    0, 3, base);\n\n\trtl_dbg(rtlpriv, COMP_POWER, DBG_TRACE,\n\t\t\"<===%s\\n\", __func__);\n}\n\nstatic void phy_txpower_by_rate_config(struct ieee80211_hw *hw)\n{\n\t_rtl8723be_phy_store_txpower_by_rate_base(hw);\n\t_rtl8723be_phy_convert_txpower_dbm_to_relative_value(hw);\n}\n\nstatic bool _rtl8723be_phy_bb8723b_config_parafile(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tbool rtstatus;\n\n\t \n\tif (rtlpriv->rtlhal.interface == INTF_USB) {\n\t\trtl_write_dword(rtlpriv, 0x948, 0x0);\n\t} else {\n\t\tif (rtlpriv->btcoexist.btc_info.single_ant_path == 0)\n\t\t\trtl_write_dword(rtlpriv, 0x948, 0x280);\n\t\telse\n\t\t\trtl_write_dword(rtlpriv, 0x948, 0x0);\n\t}\n\n\trtstatus = _rtl8723be_phy_config_bb_with_headerfile(hw,\n\t\t\t\t\t\tBASEBAND_CONFIG_PHY_REG);\n\tif (!rtstatus) {\n\t\tpr_err(\"Write BB Reg Fail!!\\n\");\n\t\treturn false;\n\t}\n\t_rtl8723be_phy_init_tx_power_by_rate(hw);\n\tif (!rtlefuse->autoload_failflag) {\n\t\trtlphy->pwrgroup_cnt = 0;\n\t\trtstatus = _rtl8723be_phy_config_bb_with_pgheaderfile(hw,\n\t\t\t\t\t\tBASEBAND_CONFIG_PHY_REG);\n\t}\n\tphy_txpower_by_rate_config(hw);\n\tif (!rtstatus) {\n\t\tpr_err(\"BB_PG Reg Fail!!\\n\");\n\t\treturn false;\n\t}\n\trtstatus = _rtl8723be_phy_config_bb_with_headerfile(hw,\n\t\t\t\t\t\tBASEBAND_CONFIG_AGC_TAB);\n\tif (!rtstatus) {\n\t\tpr_err(\"AGC Table Fail\\n\");\n\t\treturn false;\n\t}\n\trtlphy->cck_high_power = (bool)(rtl_get_bbreg(hw,\n\t\t\t\t\t\t      RFPGA0_XA_HSSIPARAMETER2,\n\t\t\t\t\t\t      0x200));\n\treturn true;\n}\n\nstatic bool rtl8723be_phy_config_with_headerfile(struct ieee80211_hw *hw,\n\t\t\t\t\t\t u32 *array_table,\n\t\t\t\t\t\t u16 arraylen,\n\t\tvoid (*set_reg)(struct ieee80211_hw *hw, u32 regaddr, u32 data))\n{\n\t#define COND_ELSE  2\n\t#define COND_ENDIF 3\n\n\tint i = 0;\n\tu8 cond;\n\tbool matched = true, skipped = false;\n\n\twhile ((i + 1) < arraylen) {\n\t\tu32 v1 = array_table[i];\n\t\tu32 v2 = array_table[i + 1];\n\n\t\tif (v1 & (BIT(31) | BIT(30))) { \n\t\t\tif (v1 & BIT(31)) { \n\t\t\t\tcond  = (u8)((v1 & (BIT(29) | BIT(28))) >> 28);\n\t\t\t\tif (cond == COND_ENDIF) {  \n\t\t\t\t\tmatched = true;\n\t\t\t\t\tskipped = false;\n\t\t\t\t} else if (cond == COND_ELSE) {  \n\t\t\t\t\tmatched = skipped ? false : true;\n\t\t\t\t} else { \n\t\t\t\t\tif (skipped) {\n\t\t\t\t\t\tmatched = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (_rtl8723be_check_positive(\n\t\t\t\t\t\t\t\thw, v1, v2)) {\n\t\t\t\t\t\t\tmatched = true;\n\t\t\t\t\t\t\tskipped = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmatched = false;\n\t\t\t\t\t\t\tskipped = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (v1 & BIT(30)) {  \n\t\t\t \n\t\t\t}\n\t\t} else {\n\t\t\tif (matched)\n\t\t\t\tset_reg(hw, v1, v2);\n\t\t}\n\t\ti = i + 2;\n\t}\n\n\treturn true;\n}\n\nstatic bool _rtl8723be_phy_config_mac_with_headerfile(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE, \"Read rtl8723beMACPHY_Array\\n\");\n\n\treturn rtl8723be_phy_config_with_headerfile(hw,\n\t\t\tRTL8723BEMAC_1T_ARRAY, RTL8723BEMAC_1T_ARRAYLEN,\n\t\t\trtl_write_byte_with_val32);\n}\n\nstatic bool _rtl8723be_phy_config_bb_with_headerfile(struct ieee80211_hw *hw,\n\t\t\t\t\t\t     u8 configtype)\n{\n\n\tif (configtype == BASEBAND_CONFIG_PHY_REG)\n\t\treturn rtl8723be_phy_config_with_headerfile(hw,\n\t\t\t\tRTL8723BEPHY_REG_1TARRAY,\n\t\t\t\tRTL8723BEPHY_REG_1TARRAYLEN,\n\t\t\t\t_rtl8723be_config_bb_reg);\n\telse if (configtype == BASEBAND_CONFIG_AGC_TAB)\n\t\treturn rtl8723be_phy_config_with_headerfile(hw,\n\t\t\t\tRTL8723BEAGCTAB_1TARRAY,\n\t\t\t\tRTL8723BEAGCTAB_1TARRAYLEN,\n\t\t\t\trtl_set_bbreg_with_dwmask);\n\n\treturn false;\n}\n\nstatic u8 _rtl8723be_get_rate_section_index(u32 regaddr)\n{\n\tu8 index = 0;\n\n\tswitch (regaddr) {\n\tcase RTXAGC_A_RATE18_06:\n\t\tindex = 0;\n\tbreak;\n\tcase RTXAGC_A_RATE54_24:\n\t\tindex = 1;\n\tbreak;\n\tcase RTXAGC_A_CCK1_MCS32:\n\t\tindex = 2;\n\tbreak;\n\tcase RTXAGC_B_CCK11_A_CCK2_11:\n\t\tindex = 3;\n\tbreak;\n\tcase RTXAGC_A_MCS03_MCS00:\n\t\tindex = 4;\n\tbreak;\n\tcase RTXAGC_A_MCS07_MCS04:\n\t\tindex = 5;\n\tbreak;\n\tcase RTXAGC_A_MCS11_MCS08:\n\t\tindex = 6;\n\tbreak;\n\tcase RTXAGC_A_MCS15_MCS12:\n\t\tindex = 7;\n\tbreak;\n\tcase RTXAGC_B_RATE18_06:\n\t\tindex = 0;\n\tbreak;\n\tcase RTXAGC_B_RATE54_24:\n\t\tindex = 1;\n\tbreak;\n\tcase RTXAGC_B_CCK1_55_MCS32:\n\t\tindex = 2;\n\tbreak;\n\tcase RTXAGC_B_MCS03_MCS00:\n\t\tindex = 4;\n\tbreak;\n\tcase RTXAGC_B_MCS07_MCS04:\n\t\tindex = 5;\n\tbreak;\n\tcase RTXAGC_B_MCS11_MCS08:\n\t\tindex = 6;\n\tbreak;\n\tcase RTXAGC_B_MCS15_MCS12:\n\t\tindex = 7;\n\tbreak;\n\tdefault:\n\t\tregaddr &= 0xFFF;\n\t\tif (regaddr >= 0xC20 && regaddr <= 0xC4C)\n\t\t\tindex = (u8)((regaddr - 0xC20) / 4);\n\t\telse if (regaddr >= 0xE20 && regaddr <= 0xE4C)\n\t\t\tindex = (u8)((regaddr - 0xE20) / 4);\n\t\tbreak;\n\t}\n\treturn index;\n}\n\nstatic void _rtl8723be_store_tx_power_by_rate(struct ieee80211_hw *hw,\n\t\t\t\t\t      u32 band, u32 rfpath,\n\t\t\t\t\t      u32 txnum, u32 regaddr,\n\t\t\t\t\t      u32 bitmask, u32 data)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\tu8 rate_section = _rtl8723be_get_rate_section_index(regaddr);\n\n\tif (band != BAND_ON_2_4G && band != BAND_ON_5G) {\n\t\trtl_dbg(rtlpriv, FPHY, PHY_TXPWR, \"Invalid Band %d\\n\", band);\n\t\treturn;\n\t}\n\tif (rfpath > MAX_RF_PATH - 1) {\n\t\trtl_dbg(rtlpriv, FPHY, PHY_TXPWR,\n\t\t\t\"Invalid RfPath %d\\n\", rfpath);\n\t\treturn;\n\t}\n\tif (txnum > MAX_RF_PATH - 1) {\n\t\trtl_dbg(rtlpriv, FPHY, PHY_TXPWR, \"Invalid TxNum %d\\n\", txnum);\n\t\treturn;\n\t}\n\n\trtlphy->tx_power_by_rate_offset[band][rfpath][txnum][rate_section] =\n\t\t\t\t\t\t\t\t\tdata;\n\n}\n\nstatic bool _rtl8723be_phy_config_bb_with_pgheaderfile(struct ieee80211_hw *hw,\n\t\t\t\t\t\t       u8 configtype)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tint i;\n\tu32 *phy_regarray_table_pg;\n\tu16 phy_regarray_pg_len;\n\tu32 v1 = 0, v2 = 0, v3 = 0, v4 = 0, v5 = 0, v6 = 0;\n\n\tphy_regarray_pg_len = RTL8723BEPHY_REG_ARRAY_PGLEN;\n\tphy_regarray_table_pg = RTL8723BEPHY_REG_ARRAY_PG;\n\n\tif (configtype == BASEBAND_CONFIG_PHY_REG) {\n\t\tfor (i = 0; i < phy_regarray_pg_len; i = i + 6) {\n\t\t\tv1 = phy_regarray_table_pg[i];\n\t\t\tv2 = phy_regarray_table_pg[i+1];\n\t\t\tv3 = phy_regarray_table_pg[i+2];\n\t\t\tv4 = phy_regarray_table_pg[i+3];\n\t\t\tv5 = phy_regarray_table_pg[i+4];\n\t\t\tv6 = phy_regarray_table_pg[i+5];\n\n\t\t\tif (v1 < 0xcdcdcdcd) {\n\t\t\t\tif (phy_regarray_table_pg[i] == 0xfe ||\n\t\t\t\t    phy_regarray_table_pg[i] == 0xffe)\n\t\t\t\t\tmdelay(50);\n\t\t\t\telse\n\t\t\t\t\t_rtl8723be_store_tx_power_by_rate(hw,\n\t\t\t\t\t\t\tv1, v2, v3, v4, v5, v6);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t} else {\n\t\trtl_dbg(rtlpriv, COMP_SEND, DBG_TRACE,\n\t\t\t\"configtype != BaseBand_Config_PHY_REG\\n\");\n\t}\n\treturn true;\n}\n\nbool rtl8723be_phy_config_rf_with_headerfile(struct ieee80211_hw *hw,\n\t\t\t\t\t     enum radio_path rfpath)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tbool ret = true;\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD, \"Radio No %x\\n\", rfpath);\n\tswitch (rfpath) {\n\tcase RF90_PATH_A:\n\t\tret =  rtl8723be_phy_config_with_headerfile(hw,\n\t\t\t\tRTL8723BE_RADIOA_1TARRAY,\n\t\t\t\tRTL8723BE_RADIOA_1TARRAYLEN,\n\t\t\t\t_rtl8723be_config_rf_radio_a);\n\n\t\tif (rtlhal->oem_id == RT_CID_819X_HP)\n\t\t\t_rtl8723be_config_rf_radio_a(hw, 0x52, 0x7E4BD);\n\t\tbreak;\n\tcase RF90_PATH_B:\n\tcase RF90_PATH_C:\n\t\tbreak;\n\tcase RF90_PATH_D:\n\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_LOUD,\n\t\t\t\"switch case %#x not processed\\n\", rfpath);\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nvoid rtl8723be_phy_get_hw_reg_originalvalue(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\n\trtlphy->default_initialgain[0] =\n\t    (u8)rtl_get_bbreg(hw, ROFDM0_XAAGCCORE1, MASKBYTE0);\n\trtlphy->default_initialgain[1] =\n\t    (u8)rtl_get_bbreg(hw, ROFDM0_XBAGCCORE1, MASKBYTE0);\n\trtlphy->default_initialgain[2] =\n\t    (u8)rtl_get_bbreg(hw, ROFDM0_XCAGCCORE1, MASKBYTE0);\n\trtlphy->default_initialgain[3] =\n\t    (u8)rtl_get_bbreg(hw, ROFDM0_XDAGCCORE1, MASKBYTE0);\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\"Default initial gain (c50=0x%x, c58=0x%x, c60=0x%x, c68=0x%x\\n\",\n\t\trtlphy->default_initialgain[0],\n\t\trtlphy->default_initialgain[1],\n\t\trtlphy->default_initialgain[2],\n\t\trtlphy->default_initialgain[3]);\n\n\trtlphy->framesync = (u8)rtl_get_bbreg(hw, ROFDM0_RXDETECTOR3,\n\t\t\t\t\t       MASKBYTE0);\n\trtlphy->framesync_c34 = rtl_get_bbreg(hw, ROFDM0_RXDETECTOR2,\n\t\t\t\t\t      MASKDWORD);\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\"Default framesync (0x%x) = 0x%x\\n\",\n\t\tROFDM0_RXDETECTOR3, rtlphy->framesync);\n}\n\nstatic u8 _rtl8723be_phy_get_ratesection_intxpower_byrate(enum radio_path path,\n\t\t\t\t\t\t\t  u8 rate)\n{\n\tu8 rate_section = 0;\n\n\tswitch (rate) {\n\tcase DESC92C_RATE1M:\n\t\trate_section = 2;\n\t\tbreak;\n\n\tcase DESC92C_RATE2M:\n\tcase DESC92C_RATE5_5M:\n\t\tif (path == RF90_PATH_A)\n\t\t\trate_section = 3;\n\t\telse if (path == RF90_PATH_B)\n\t\t\trate_section = 2;\n\t\tbreak;\n\n\tcase DESC92C_RATE11M:\n\t\trate_section = 3;\n\t\tbreak;\n\n\tcase DESC92C_RATE6M:\n\tcase DESC92C_RATE9M:\n\tcase DESC92C_RATE12M:\n\tcase DESC92C_RATE18M:\n\t\trate_section = 0;\n\t\tbreak;\n\n\tcase DESC92C_RATE24M:\n\tcase DESC92C_RATE36M:\n\tcase DESC92C_RATE48M:\n\tcase DESC92C_RATE54M:\n\t\trate_section = 1;\n\t\tbreak;\n\n\tcase DESC92C_RATEMCS0:\n\tcase DESC92C_RATEMCS1:\n\tcase DESC92C_RATEMCS2:\n\tcase DESC92C_RATEMCS3:\n\t\trate_section = 4;\n\t\tbreak;\n\n\tcase DESC92C_RATEMCS4:\n\tcase DESC92C_RATEMCS5:\n\tcase DESC92C_RATEMCS6:\n\tcase DESC92C_RATEMCS7:\n\t\trate_section = 5;\n\t\tbreak;\n\n\tcase DESC92C_RATEMCS8:\n\tcase DESC92C_RATEMCS9:\n\tcase DESC92C_RATEMCS10:\n\tcase DESC92C_RATEMCS11:\n\t\trate_section = 6;\n\t\tbreak;\n\n\tcase DESC92C_RATEMCS12:\n\tcase DESC92C_RATEMCS13:\n\tcase DESC92C_RATEMCS14:\n\tcase DESC92C_RATEMCS15:\n\t\trate_section = 7;\n\t\tbreak;\n\n\tdefault:\n\t\tWARN_ONCE(true, \"rtl8723be: Rate_Section is Illegal\\n\");\n\t\tbreak;\n\t}\n\n\treturn rate_section;\n}\n\nstatic u8 _rtl8723be_get_txpower_by_rate(struct ieee80211_hw *hw,\n\t\t\t\t\t enum band_type band,\n\t\t\t\t\t enum radio_path rfpath, u8 rate)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\tu8 shift = 0, rate_section, tx_num;\n\ts8 tx_pwr_diff = 0;\n\n\trate_section = _rtl8723be_phy_get_ratesection_intxpower_byrate(rfpath,\n\t\t\t\t\t\t\t\t       rate);\n\ttx_num = RF_TX_NUM_NONIMPLEMENT;\n\n\tif (tx_num == RF_TX_NUM_NONIMPLEMENT) {\n\t\tif (rate >= DESC92C_RATEMCS8 && rate <= DESC92C_RATEMCS15)\n\t\t\ttx_num = RF_2TX;\n\t\telse\n\t\t\ttx_num = RF_1TX;\n\t}\n\n\tswitch (rate) {\n\tcase DESC92C_RATE6M:\n\tcase DESC92C_RATE24M:\n\tcase DESC92C_RATEMCS0:\n\tcase DESC92C_RATEMCS4:\n\tcase DESC92C_RATEMCS8:\n\tcase DESC92C_RATEMCS12:\n\t\tshift = 0;\n\t\tbreak;\n\tcase DESC92C_RATE1M:\n\tcase DESC92C_RATE2M:\n\tcase DESC92C_RATE9M:\n\tcase DESC92C_RATE36M:\n\tcase DESC92C_RATEMCS1:\n\tcase DESC92C_RATEMCS5:\n\tcase DESC92C_RATEMCS9:\n\tcase DESC92C_RATEMCS13:\n\t\tshift = 8;\n\t\tbreak;\n\tcase DESC92C_RATE5_5M:\n\tcase DESC92C_RATE12M:\n\tcase DESC92C_RATE48M:\n\tcase DESC92C_RATEMCS2:\n\tcase DESC92C_RATEMCS6:\n\tcase DESC92C_RATEMCS10:\n\tcase DESC92C_RATEMCS14:\n\t\tshift = 16;\n\t\tbreak;\n\tcase DESC92C_RATE11M:\n\tcase DESC92C_RATE18M:\n\tcase DESC92C_RATE54M:\n\tcase DESC92C_RATEMCS3:\n\tcase DESC92C_RATEMCS7:\n\tcase DESC92C_RATEMCS11:\n\tcase DESC92C_RATEMCS15:\n\t\tshift = 24;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ONCE(true, \"rtl8723be: Rate_Section is Illegal\\n\");\n\t\tbreak;\n\t}\n\ttx_pwr_diff = (u8)(rtlphy->tx_power_by_rate_offset[band][rfpath][tx_num]\n\t\t\t\t\t  [rate_section] >> shift) & 0xff;\n\n\treturn\ttx_pwr_diff;\n}\n\nstatic u8 _rtl8723be_get_txpower_index(struct ieee80211_hw *hw, u8 path,\n\t\t\t\t       u8 rate, u8 bandwidth, u8 channel)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tu8 index = (channel - 1);\n\tu8 txpower = 0;\n\tu8 power_diff_byrate = 0;\n\n\tif (channel > 14 || channel < 1) {\n\t\tindex = 0;\n\t\trtl_dbg(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\n\t\t\t\"Illegal channel!\\n\");\n\t}\n\tif (RX_HAL_IS_CCK_RATE(rate))\n\t\ttxpower = rtlefuse->txpwrlevel_cck[path][index];\n\telse if (DESC92C_RATE6M <= rate)\n\t\ttxpower = rtlefuse->txpwrlevel_ht40_1s[path][index];\n\telse\n\t\trtl_dbg(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\n\t\t\t\"invalid rate\\n\");\n\n\tif (DESC92C_RATE6M <= rate && rate <= DESC92C_RATE54M &&\n\t    !RX_HAL_IS_CCK_RATE(rate))\n\t\ttxpower += rtlefuse->txpwr_legacyhtdiff[0][TX_1S];\n\n\tif (bandwidth == HT_CHANNEL_WIDTH_20) {\n\t\tif (DESC92C_RATEMCS0 <= rate && rate <= DESC92C_RATEMCS15)\n\t\t\ttxpower += rtlefuse->txpwr_ht20diff[0][TX_1S];\n\t\tif (DESC92C_RATEMCS8 <= rate && rate <= DESC92C_RATEMCS15)\n\t\t\ttxpower += rtlefuse->txpwr_ht20diff[0][TX_2S];\n\t} else if (bandwidth == HT_CHANNEL_WIDTH_20_40) {\n\t\tif (DESC92C_RATEMCS0 <= rate && rate <= DESC92C_RATEMCS15)\n\t\t\ttxpower += rtlefuse->txpwr_ht40diff[0][TX_1S];\n\t\tif (DESC92C_RATEMCS8 <= rate && rate <= DESC92C_RATEMCS15)\n\t\t\ttxpower += rtlefuse->txpwr_ht40diff[0][TX_2S];\n\t}\n\n\tif (rtlefuse->eeprom_regulatory != 2)\n\t\tpower_diff_byrate = _rtl8723be_get_txpower_by_rate(hw,\n\t\t\t\t\t\t\t\t   BAND_ON_2_4G,\n\t\t\t\t\t\t\t\t   path, rate);\n\n\ttxpower += power_diff_byrate;\n\n\tif (txpower > MAX_POWER_INDEX)\n\t\ttxpower = MAX_POWER_INDEX;\n\n\treturn txpower;\n}\n\nstatic void _rtl8723be_phy_set_txpower_index(struct ieee80211_hw *hw,\n\t\t\t\t\t     u8 power_index, u8 path, u8 rate)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tif (path == RF90_PATH_A) {\n\t\tswitch (rate) {\n\t\tcase DESC92C_RATE1M:\n\t\t\trtl8723_phy_set_bb_reg(hw, RTXAGC_A_CCK1_MCS32,\n\t\t\t\t\t       MASKBYTE1, power_index);\n\t\t\tbreak;\n\t\tcase DESC92C_RATE2M:\n\t\t\trtl8723_phy_set_bb_reg(hw, RTXAGC_B_CCK11_A_CCK2_11,\n\t\t\t\t\t       MASKBYTE1, power_index);\n\t\t\tbreak;\n\t\tcase DESC92C_RATE5_5M:\n\t\t\trtl8723_phy_set_bb_reg(hw, RTXAGC_B_CCK11_A_CCK2_11,\n\t\t\t\t\t       MASKBYTE2, power_index);\n\t\t\tbreak;\n\t\tcase DESC92C_RATE11M:\n\t\t\trtl8723_phy_set_bb_reg(hw, RTXAGC_B_CCK11_A_CCK2_11,\n\t\t\t\t\t       MASKBYTE3, power_index);\n\t\t\tbreak;\n\n\t\tcase DESC92C_RATE6M:\n\t\t\trtl8723_phy_set_bb_reg(hw, RTXAGC_A_RATE18_06,\n\t\t\t\t\t       MASKBYTE0, power_index);\n\t\t\tbreak;\n\t\tcase DESC92C_RATE9M:\n\t\t\trtl8723_phy_set_bb_reg(hw, RTXAGC_A_RATE18_06,\n\t\t\t\t\t       MASKBYTE1, power_index);\n\t\t\tbreak;\n\t\tcase DESC92C_RATE12M:\n\t\t\trtl8723_phy_set_bb_reg(hw, RTXAGC_A_RATE18_06,\n\t\t\t\t\t       MASKBYTE2, power_index);\n\t\t\tbreak;\n\t\tcase DESC92C_RATE18M:\n\t\t\trtl8723_phy_set_bb_reg(hw, RTXAGC_A_RATE18_06,\n\t\t\t\t\t       MASKBYTE3, power_index);\n\t\t\tbreak;\n\n\t\tcase DESC92C_RATE24M:\n\t\t\trtl8723_phy_set_bb_reg(hw, RTXAGC_A_RATE54_24,\n\t\t\t\t\t       MASKBYTE0, power_index);\n\t\t\tbreak;\n\t\tcase DESC92C_RATE36M:\n\t\t\trtl8723_phy_set_bb_reg(hw, RTXAGC_A_RATE54_24,\n\t\t\t\t\t       MASKBYTE1, power_index);\n\t\t\tbreak;\n\t\tcase DESC92C_RATE48M:\n\t\t\trtl8723_phy_set_bb_reg(hw, RTXAGC_A_RATE54_24,\n\t\t\t\t\t       MASKBYTE2, power_index);\n\t\t\tbreak;\n\t\tcase DESC92C_RATE54M:\n\t\t\trtl8723_phy_set_bb_reg(hw, RTXAGC_A_RATE54_24,\n\t\t\t\t\t       MASKBYTE3, power_index);\n\t\t\tbreak;\n\n\t\tcase DESC92C_RATEMCS0:\n\t\t\trtl8723_phy_set_bb_reg(hw, RTXAGC_A_MCS03_MCS00,\n\t\t\t\t\t       MASKBYTE0, power_index);\n\t\t\tbreak;\n\t\tcase DESC92C_RATEMCS1:\n\t\t\trtl8723_phy_set_bb_reg(hw, RTXAGC_A_MCS03_MCS00,\n\t\t\t\t\t       MASKBYTE1, power_index);\n\t\t\tbreak;\n\t\tcase DESC92C_RATEMCS2:\n\t\t\trtl8723_phy_set_bb_reg(hw, RTXAGC_A_MCS03_MCS00,\n\t\t\t\t\t       MASKBYTE2, power_index);\n\t\t\tbreak;\n\t\tcase DESC92C_RATEMCS3:\n\t\t\trtl8723_phy_set_bb_reg(hw, RTXAGC_A_MCS03_MCS00,\n\t\t\t\t\t       MASKBYTE3, power_index);\n\t\t\tbreak;\n\n\t\tcase DESC92C_RATEMCS4:\n\t\t\trtl8723_phy_set_bb_reg(hw, RTXAGC_A_MCS07_MCS04,\n\t\t\t\t\t       MASKBYTE0, power_index);\n\t\t\tbreak;\n\t\tcase DESC92C_RATEMCS5:\n\t\t\trtl8723_phy_set_bb_reg(hw, RTXAGC_A_MCS07_MCS04,\n\t\t\t\t\t       MASKBYTE1, power_index);\n\t\t\tbreak;\n\t\tcase DESC92C_RATEMCS6:\n\t\t\trtl8723_phy_set_bb_reg(hw, RTXAGC_A_MCS07_MCS04,\n\t\t\t\t\t       MASKBYTE2, power_index);\n\t\t\tbreak;\n\t\tcase DESC92C_RATEMCS7:\n\t\t\trtl8723_phy_set_bb_reg(hw, RTXAGC_A_MCS07_MCS04,\n\t\t\t\t\t       MASKBYTE3, power_index);\n\t\t\tbreak;\n\n\t\tcase DESC92C_RATEMCS8:\n\t\t\trtl8723_phy_set_bb_reg(hw, RTXAGC_A_MCS11_MCS08,\n\t\t\t\t\t       MASKBYTE0, power_index);\n\t\t\tbreak;\n\t\tcase DESC92C_RATEMCS9:\n\t\t\trtl8723_phy_set_bb_reg(hw, RTXAGC_A_MCS11_MCS08,\n\t\t\t\t\t       MASKBYTE1, power_index);\n\t\t\tbreak;\n\t\tcase DESC92C_RATEMCS10:\n\t\t\trtl8723_phy_set_bb_reg(hw, RTXAGC_A_MCS11_MCS08,\n\t\t\t\t\t       MASKBYTE2, power_index);\n\t\t\tbreak;\n\t\tcase DESC92C_RATEMCS11:\n\t\t\trtl8723_phy_set_bb_reg(hw, RTXAGC_A_MCS11_MCS08,\n\t\t\t\t\t       MASKBYTE3, power_index);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD, \"Invalid Rate!!\\n\");\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD, \"Invalid RFPath!!\\n\");\n\t}\n}\n\nvoid rtl8723be_phy_set_txpower_level(struct ieee80211_hw *hw, u8 channel)\n{\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tu8 cck_rates[]  = {DESC92C_RATE1M, DESC92C_RATE2M,\n\t\t\t   DESC92C_RATE5_5M, DESC92C_RATE11M};\n\tu8 ofdm_rates[]  = {DESC92C_RATE6M, DESC92C_RATE9M,\n\t\t\t    DESC92C_RATE12M, DESC92C_RATE18M,\n\t\t\t    DESC92C_RATE24M, DESC92C_RATE36M,\n\t\t\t    DESC92C_RATE48M, DESC92C_RATE54M};\n\tu8 ht_rates_1t[]  = {DESC92C_RATEMCS0, DESC92C_RATEMCS1,\n\t\t\t     DESC92C_RATEMCS2, DESC92C_RATEMCS3,\n\t\t\t     DESC92C_RATEMCS4, DESC92C_RATEMCS5,\n\t\t\t     DESC92C_RATEMCS6, DESC92C_RATEMCS7};\n\tu8 i;\n\tu8 power_index;\n\n\tif (!rtlefuse->txpwr_fromeprom)\n\t\treturn;\n\n\tfor (i = 0; i < ARRAY_SIZE(cck_rates); i++) {\n\t\tpower_index = _rtl8723be_get_txpower_index(hw, RF90_PATH_A,\n\t\t\t\t\tcck_rates[i],\n\t\t\t\t\trtl_priv(hw)->phy.current_chan_bw,\n\t\t\t\t\tchannel);\n\t\t_rtl8723be_phy_set_txpower_index(hw, power_index, RF90_PATH_A,\n\t\t\t\t\t\t cck_rates[i]);\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(ofdm_rates); i++) {\n\t\tpower_index = _rtl8723be_get_txpower_index(hw, RF90_PATH_A,\n\t\t\t\t\tofdm_rates[i],\n\t\t\t\t\trtl_priv(hw)->phy.current_chan_bw,\n\t\t\t\t\tchannel);\n\t\t_rtl8723be_phy_set_txpower_index(hw, power_index, RF90_PATH_A,\n\t\t\t\t\t\t ofdm_rates[i]);\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(ht_rates_1t); i++) {\n\t\tpower_index = _rtl8723be_get_txpower_index(hw, RF90_PATH_A,\n\t\t\t\t\tht_rates_1t[i],\n\t\t\t\t\trtl_priv(hw)->phy.current_chan_bw,\n\t\t\t\t\tchannel);\n\t\t_rtl8723be_phy_set_txpower_index(hw, power_index, RF90_PATH_A,\n\t\t\t\t\t\t ht_rates_1t[i]);\n\t}\n}\n\nvoid rtl8723be_phy_scan_operation_backup(struct ieee80211_hw *hw, u8 operation)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tenum io_type iotype;\n\n\tif (!is_hal_stop(rtlhal)) {\n\t\tswitch (operation) {\n\t\tcase SCAN_OPT_BACKUP_BAND0:\n\t\t\tiotype = IO_CMD_PAUSE_BAND0_DM_BY_SCAN;\n\t\t\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_IO_CMD,\n\t\t\t\t\t\t      (u8 *)&iotype);\n\n\t\t\tbreak;\n\t\tcase SCAN_OPT_RESTORE:\n\t\t\tiotype = IO_CMD_RESUME_DM_BY_SCAN;\n\t\t\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_IO_CMD,\n\t\t\t\t\t\t      (u8 *)&iotype);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Unknown Scan Backup operation.\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid rtl8723be_phy_set_bw_mode_callback(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tu8 reg_bw_opmode;\n\tu8 reg_prsr_rsc;\n\n\trtl_dbg(rtlpriv, COMP_SCAN, DBG_TRACE,\n\t\t\"Switch to %s bandwidth\\n\",\n\t\trtlphy->current_chan_bw == HT_CHANNEL_WIDTH_20 ?\n\t\t\"20MHz\" : \"40MHz\");\n\n\tif (is_hal_stop(rtlhal)) {\n\t\trtlphy->set_bwmode_inprogress = false;\n\t\treturn;\n\t}\n\n\treg_bw_opmode = rtl_read_byte(rtlpriv, REG_BWOPMODE);\n\treg_prsr_rsc = rtl_read_byte(rtlpriv, REG_RRSR + 2);\n\n\tswitch (rtlphy->current_chan_bw) {\n\tcase HT_CHANNEL_WIDTH_20:\n\t\treg_bw_opmode |= BW_OPMODE_20MHZ;\n\t\trtl_write_byte(rtlpriv, REG_BWOPMODE, reg_bw_opmode);\n\t\tbreak;\n\tcase HT_CHANNEL_WIDTH_20_40:\n\t\treg_bw_opmode &= ~BW_OPMODE_20MHZ;\n\t\trtl_write_byte(rtlpriv, REG_BWOPMODE, reg_bw_opmode);\n\t\treg_prsr_rsc = (reg_prsr_rsc & 0x90) |\n\t\t\t       (mac->cur_40_prime_sc << 5);\n\t\trtl_write_byte(rtlpriv, REG_RRSR + 2, reg_prsr_rsc);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"unknown bandwidth: %#X\\n\",\n\t\t       rtlphy->current_chan_bw);\n\t\tbreak;\n\t}\n\n\tswitch (rtlphy->current_chan_bw) {\n\tcase HT_CHANNEL_WIDTH_20:\n\t\trtl_set_bbreg(hw, RFPGA0_RFMOD, BRFMOD, 0x0);\n\t\trtl_set_bbreg(hw, RFPGA1_RFMOD, BRFMOD, 0x0);\n\t \n\t\tbreak;\n\tcase HT_CHANNEL_WIDTH_20_40:\n\t\trtl_set_bbreg(hw, RFPGA0_RFMOD, BRFMOD, 0x1);\n\t\trtl_set_bbreg(hw, RFPGA1_RFMOD, BRFMOD, 0x1);\n\n\t\trtl_set_bbreg(hw, RCCK0_SYSTEM, BCCK_SIDEBAND,\n\t\t\t      (mac->cur_40_prime_sc >> 1));\n\t\trtl_set_bbreg(hw, ROFDM1_LSTF, 0xC00, mac->cur_40_prime_sc);\n\t\t \n\n\t\trtl_set_bbreg(hw, 0x818, (BIT(26) | BIT(27)),\n\t\t\t      (mac->cur_40_prime_sc ==\n\t\t\t       HAL_PRIME_CHNL_OFFSET_LOWER) ? 2 : 1);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"unknown bandwidth: %#X\\n\",\n\t\t       rtlphy->current_chan_bw);\n\t\tbreak;\n\t}\n\trtl8723be_phy_rf6052_set_bandwidth(hw, rtlphy->current_chan_bw);\n\trtlphy->set_bwmode_inprogress = false;\n\trtl_dbg(rtlpriv, COMP_SCAN, DBG_LOUD, \"\\n\");\n}\n\nvoid rtl8723be_phy_set_bw_mode(struct ieee80211_hw *hw,\n\t\t\t    enum nl80211_channel_type ch_type)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tu8 tmp_bw = rtlphy->current_chan_bw;\n\n\tif (rtlphy->set_bwmode_inprogress)\n\t\treturn;\n\trtlphy->set_bwmode_inprogress = true;\n\tif ((!is_hal_stop(rtlhal)) && !(RT_CANNOT_IO(hw))) {\n\t\trtl8723be_phy_set_bw_mode_callback(hw);\n\t} else {\n\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_WARNING,\n\t\t\t\"false driver sleep or unload\\n\");\n\t\trtlphy->set_bwmode_inprogress = false;\n\t\trtlphy->current_chan_bw = tmp_bw;\n\t}\n}\n\nvoid rtl8723be_phy_sw_chnl_callback(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\tu32 delay = 0;\n\n\trtl_dbg(rtlpriv, COMP_SCAN, DBG_TRACE,\n\t\t\"switch to channel%d\\n\", rtlphy->current_channel);\n\tif (is_hal_stop(rtlhal))\n\t\treturn;\n\tdo {\n\t\tif (!rtlphy->sw_chnl_inprogress)\n\t\t\tbreak;\n\t\tif (!_rtl8723be_phy_sw_chnl_step_by_step(hw,\n\t\t\t\t\t\t\t rtlphy->current_channel,\n\t\t\t\t\t\t\t &rtlphy->sw_chnl_stage,\n\t\t\t\t\t\t\t &rtlphy->sw_chnl_step,\n\t\t\t\t\t\t\t &delay)) {\n\t\t\tif (delay > 0)\n\t\t\t\tmdelay(delay);\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\trtlphy->sw_chnl_inprogress = false;\n\t\t}\n\t\tbreak;\n\t} while (true);\n\trtl_dbg(rtlpriv, COMP_SCAN, DBG_TRACE, \"\\n\");\n}\n\nu8 rtl8723be_phy_sw_chnl(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\n\tif (rtlphy->sw_chnl_inprogress)\n\t\treturn 0;\n\tif (rtlphy->set_bwmode_inprogress)\n\t\treturn 0;\n\tWARN_ONCE((rtlphy->current_channel > 14),\n\t\t  \"rtl8723be: WIRELESS_MODE_G but channel>14\");\n\trtlphy->sw_chnl_inprogress = true;\n\trtlphy->sw_chnl_stage = 0;\n\trtlphy->sw_chnl_step = 0;\n\tif (!(is_hal_stop(rtlhal)) && !(RT_CANNOT_IO(hw))) {\n\t\trtl8723be_phy_sw_chnl_callback(hw);\n\t\trtl_dbg(rtlpriv, COMP_CHAN, DBG_LOUD,\n\t\t\t\"sw_chnl_inprogress false schedule workitem current channel %d\\n\",\n\t\t\trtlphy->current_channel);\n\t\trtlphy->sw_chnl_inprogress = false;\n\t} else {\n\t\trtl_dbg(rtlpriv, COMP_CHAN, DBG_LOUD,\n\t\t\t\"sw_chnl_inprogress false driver sleep or unload\\n\");\n\t\trtlphy->sw_chnl_inprogress = false;\n\t}\n\treturn 1;\n}\n\nstatic bool _rtl8723be_phy_sw_chnl_step_by_step(struct ieee80211_hw *hw,\n\t\t\t\t\t\tu8 channel, u8 *stage,\n\t\t\t\t\t\tu8 *step, u32 *delay)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\tstruct swchnlcmd precommoncmd[MAX_PRECMD_CNT];\n\tu32 precommoncmdcnt;\n\tstruct swchnlcmd postcommoncmd[MAX_POSTCMD_CNT];\n\tu32 postcommoncmdcnt;\n\tstruct swchnlcmd rfdependcmd[MAX_RFDEPENDCMD_CNT];\n\tu32 rfdependcmdcnt;\n\tstruct swchnlcmd *currentcmd = NULL;\n\tu8 rfpath;\n\tu8 num_total_rfpath = rtlphy->num_total_rfpath;\n\n\tprecommoncmdcnt = 0;\n\trtl8723_phy_set_sw_chnl_cmdarray(precommoncmd, precommoncmdcnt++,\n\t\t\t\t\t MAX_PRECMD_CNT,\n\t\t\t\t\t CMDID_SET_TXPOWEROWER_LEVEL,\n\t\t\t\t\t 0, 0, 0);\n\trtl8723_phy_set_sw_chnl_cmdarray(precommoncmd, precommoncmdcnt++,\n\t\t\t\t\t MAX_PRECMD_CNT, CMDID_END, 0, 0, 0);\n\n\tpostcommoncmdcnt = 0;\n\n\trtl8723_phy_set_sw_chnl_cmdarray(postcommoncmd, postcommoncmdcnt++,\n\t\t\t\t\t MAX_POSTCMD_CNT, CMDID_END,\n\t\t\t\t\t    0, 0, 0);\n\n\trfdependcmdcnt = 0;\n\n\tWARN_ONCE((channel < 1 || channel > 14),\n\t\t  \"rtl8723be: illegal channel for Zebra: %d\\n\", channel);\n\n\trtl8723_phy_set_sw_chnl_cmdarray(rfdependcmd, rfdependcmdcnt++,\n\t\t\t\t\t MAX_RFDEPENDCMD_CNT,\n\t\t\t\t\t CMDID_RF_WRITEREG,\n\t\t\t\t\t RF_CHNLBW, channel, 10);\n\n\trtl8723_phy_set_sw_chnl_cmdarray(rfdependcmd, rfdependcmdcnt++,\n\t\t\t\t\t MAX_RFDEPENDCMD_CNT,\n\t\t\t\t\t    CMDID_END, 0, 0, 0);\n\n\tdo {\n\t\tswitch (*stage) {\n\t\tcase 0:\n\t\t\tcurrentcmd = &precommoncmd[*step];\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tcurrentcmd = &rfdependcmd[*step];\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tcurrentcmd = &postcommoncmd[*step];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Invalid 'stage' = %d, Check it!\\n\",\n\t\t\t       *stage);\n\t\t\treturn true;\n\t\t}\n\n\t\tif (currentcmd->cmdid == CMDID_END) {\n\t\t\tif ((*stage) == 2) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\t(*stage)++;\n\t\t\t\t(*step) = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tswitch (currentcmd->cmdid) {\n\t\tcase CMDID_SET_TXPOWEROWER_LEVEL:\n\t\t\trtl8723be_phy_set_txpower_level(hw, channel);\n\t\t\tbreak;\n\t\tcase CMDID_WRITEPORT_ULONG:\n\t\t\trtl_write_dword(rtlpriv, currentcmd->para1,\n\t\t\t\t\tcurrentcmd->para2);\n\t\t\tbreak;\n\t\tcase CMDID_WRITEPORT_USHORT:\n\t\t\trtl_write_word(rtlpriv, currentcmd->para1,\n\t\t\t\t       (u16)currentcmd->para2);\n\t\t\tbreak;\n\t\tcase CMDID_WRITEPORT_UCHAR:\n\t\t\trtl_write_byte(rtlpriv, currentcmd->para1,\n\t\t\t\t       (u8)currentcmd->para2);\n\t\t\tbreak;\n\t\tcase CMDID_RF_WRITEREG:\n\t\t\tfor (rfpath = 0; rfpath < num_total_rfpath; rfpath++) {\n\t\t\t\trtlphy->rfreg_chnlval[rfpath] =\n\t\t\t\t    ((rtlphy->rfreg_chnlval[rfpath] &\n\t\t\t\t      0xfffffc00) | currentcmd->para2);\n\n\t\t\t\trtl_set_rfreg(hw, (enum radio_path)rfpath,\n\t\t\t\t\t      currentcmd->para1,\n\t\t\t\t\t      RFREG_OFFSET_MASK,\n\t\t\t\t\t      rtlphy->rfreg_chnlval[rfpath]);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_LOUD,\n\t\t\t\t\"switch case %#x not processed\\n\",\n\t\t\t\tcurrentcmd->cmdid);\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\t} while (true);\n\n\t(*delay) = currentcmd->msdelay;\n\t(*step)++;\n\treturn false;\n}\n\nstatic u8 _rtl8723be_phy_path_a_iqk(struct ieee80211_hw *hw)\n{\n\tu32 reg_eac, reg_e94, reg_e9c, tmp;\n\tu8 result = 0x00;\n\n\t \n\trtl_set_bbreg(hw, RFPGA0_IQK, MASKDWORD, 0x00000000);\n\t \n\trtl_set_bbreg(hw, 0x948, MASKDWORD, 0x00000000);\n\t \n\trtl_set_rfreg(hw, RF90_PATH_A, RF_WE_LUT, RFREG_OFFSET_MASK, 0x800a0);\n\trtl_set_rfreg(hw, RF90_PATH_A, RF_RCK_OS, RFREG_OFFSET_MASK, 0x20000);\n\trtl_set_rfreg(hw, RF90_PATH_A, RF_TXPA_G1, RFREG_OFFSET_MASK, 0x0003f);\n\trtl_set_rfreg(hw, RF90_PATH_A, RF_TXPA_G2, RFREG_OFFSET_MASK, 0xc7f87);\n\n\t \n\t \n\t \n\trtl_set_bbreg(hw, RTX_IQK, MASKDWORD, 0x01007c00);\n\trtl_set_bbreg(hw, RRX_IQK, MASKDWORD, 0x01004800);\n\t \n\trtl_set_bbreg(hw, RTX_IQK_TONE_A, MASKDWORD, 0x18008c1c);\n\trtl_set_bbreg(hw, RRX_IQK_TONE_A, MASKDWORD, 0x38008c1c);\n\trtl_set_bbreg(hw, RTX_IQK_TONE_B, MASKDWORD, 0x38008c1c);\n\trtl_set_bbreg(hw, RRX_IQK_TONE_B, MASKDWORD, 0x38008c1c);\n\n\trtl_set_bbreg(hw, RTX_IQK_PI_A, MASKDWORD, 0x821403ea);\n\trtl_set_bbreg(hw, RRX_IQK_PI_A, MASKDWORD, 0x28160000);\n\trtl_set_bbreg(hw, RTX_IQK_PI_B, MASKDWORD, 0x82110000);\n\trtl_set_bbreg(hw, RRX_IQK_PI_B, MASKDWORD, 0x28110000);\n\t \n\trtl_set_bbreg(hw, RIQK_AGC_RSP, MASKDWORD, 0x00462911);\n\t \n\trtl_set_bbreg(hw, RFPGA0_IQK, MASKDWORD, 0x80800000);\n\n\t \n\trtl_set_bbreg(hw, RIQK_AGC_PTS, MASKDWORD, 0xf9000000);\n\trtl_set_bbreg(hw, RIQK_AGC_PTS, MASKDWORD, 0xf8000000);\n\n\tmdelay(IQK_DELAY_TIME);\n\n\t \n\trtl_set_bbreg(hw, RFPGA0_IQK, MASKDWORD, 0x00000000);\n\n\t \n\treg_eac = rtl_get_bbreg(hw, 0xeac, MASKDWORD);\n\treg_e94 = rtl_get_bbreg(hw, 0xe94, MASKDWORD);\n\treg_e9c = rtl_get_bbreg(hw, 0xe9c, MASKDWORD);\n\n\tif (!(reg_eac & BIT(28)) &&\n\t    (((reg_e94 & 0x03FF0000) >> 16) != 0x142) &&\n\t    (((reg_e9c & 0x03FF0000) >> 16) != 0x42))\n\t\tresult |= 0x01;\n\telse  \n\t\treturn result;\n\n\t \n\ttmp = (reg_e9c & 0x03FF0000) >> 16;\n\tif ((tmp & 0x200) > 0)\n\t\ttmp = 0x400 - tmp;\n\n\tif (!(reg_eac & BIT(28)) &&\n\t    (((reg_e94 & 0x03FF0000) >> 16) < 0x110) &&\n\t    (((reg_e94 & 0x03FF0000) >> 16) > 0xf0) &&\n\t    (tmp < 0xf))\n\t\tresult |= 0x01;\n\telse  \n\t\treturn result;\n\n\treturn result;\n}\n\n \nstatic u8 _rtl8723be_phy_path_a_rx_iqk(struct ieee80211_hw *hw)\n{\n\tu32 reg_eac, reg_e94, reg_e9c, reg_ea4, u32tmp, tmp;\n\tu8 result = 0x00;\n\n\t \n\trtl_set_bbreg(hw, RFPGA0_IQK, MASKDWORD, 0x00000000);\n\n\t \n\trtl_set_bbreg(hw, 0x948, MASKDWORD, 0x00000000);\n\n\t \n\t \n\trtl_set_rfreg(hw, RF90_PATH_A, RF_WE_LUT, 0x80000, 0x1);\n\trtl_set_rfreg(hw, RF90_PATH_A, RF_RCK_OS, RFREG_OFFSET_MASK, 0x30000);\n\trtl_set_rfreg(hw, RF90_PATH_A, RF_TXPA_G1, RFREG_OFFSET_MASK, 0x0001f);\n\t \n\trtl_set_rfreg(hw, RF90_PATH_A, RF_TXPA_G2, RFREG_OFFSET_MASK, 0xf7fb7);\n\trtl_set_bbreg(hw, RFPGA0_IQK, MASKDWORD, 0x80800000);\n\n\t \n\trtl_set_bbreg(hw, RTX_IQK, MASKDWORD, 0x01007c00);\n\trtl_set_bbreg(hw, RRX_IQK, MASKDWORD, 0x01004800);\n\n\t \n\trtl_set_bbreg(hw, RTX_IQK_TONE_A, MASKDWORD, 0x18008c1c);\n\trtl_set_bbreg(hw, RRX_IQK_TONE_A, MASKDWORD, 0x38008c1c);\n\trtl_set_bbreg(hw, RTX_IQK_TONE_B, MASKDWORD, 0x38008c1c);\n\trtl_set_bbreg(hw, RRX_IQK_TONE_B, MASKDWORD, 0x38008c1c);\n\n\trtl_set_bbreg(hw, RTX_IQK_PI_A, MASKDWORD, 0x82160ff0);\n\trtl_set_bbreg(hw, RRX_IQK_PI_A, MASKDWORD, 0x28110000);\n\trtl_set_bbreg(hw, RTX_IQK_PI_B, MASKDWORD, 0x82110000);\n\trtl_set_bbreg(hw, RRX_IQK_PI_B, MASKDWORD, 0x28110000);\n\n\t \n\trtl_set_bbreg(hw, RIQK_AGC_RSP, MASKDWORD, 0x0046a911);\n\n\t \n\trtl_set_bbreg(hw, RFPGA0_IQK, MASKDWORD, 0x80800000);\n\n\t \n\trtl_set_bbreg(hw, RIQK_AGC_PTS, MASKDWORD, 0xf9000000);\n\trtl_set_bbreg(hw, RIQK_AGC_PTS, MASKDWORD, 0xf8000000);\n\n\tmdelay(IQK_DELAY_TIME);\n\n\t \n\trtl_set_bbreg(hw, RFPGA0_IQK, MASKDWORD, 0x00000000);\n\n\t \n\treg_eac = rtl_get_bbreg(hw, RRX_POWER_AFTER_IQK_A_2, MASKDWORD);\n\treg_e94 = rtl_get_bbreg(hw, RTX_POWER_BEFORE_IQK_A, MASKDWORD);\n\treg_e9c = rtl_get_bbreg(hw, RTX_POWER_AFTER_IQK_A, MASKDWORD);\n\n\tif (!(reg_eac & BIT(28)) &&\n\t    (((reg_e94 & 0x03FF0000) >> 16) != 0x142) &&\n\t    (((reg_e9c & 0x03FF0000) >> 16) != 0x42))\n\t\tresult |= 0x01;\n\telse  \n\t\treturn result;\n\n\t \n\ttmp = (reg_e9c & 0x03FF0000) >> 16;\n\tif ((tmp & 0x200) > 0)\n\t\ttmp = 0x400 - tmp;\n\n\tif (!(reg_eac & BIT(28)) &&\n\t    (((reg_e94 & 0x03FF0000) >> 16) < 0x110) &&\n\t    (((reg_e94 & 0x03FF0000) >> 16) > 0xf0) &&\n\t    (tmp < 0xf))\n\t\tresult |= 0x01;\n\telse  \n\t\treturn result;\n\n\tu32tmp = 0x80007C00 | (reg_e94 & 0x3FF0000) |\n\t\t ((reg_e9c & 0x3FF0000) >> 16);\n\trtl_set_bbreg(hw, RTX_IQK, MASKDWORD, u32tmp);\n\n\t \n\t \n\trtl_set_bbreg(hw, RFPGA0_IQK, MASKDWORD, 0x00000000);\n\trtl_set_rfreg(hw, RF90_PATH_A, RF_WE_LUT, 0x80000, 0x1);\n\trtl_set_rfreg(hw, RF90_PATH_A, RF_RCK_OS, RFREG_OFFSET_MASK, 0x30000);\n\trtl_set_rfreg(hw, RF90_PATH_A, RF_TXPA_G1, RFREG_OFFSET_MASK, 0x0001f);\n\t \n\trtl_set_rfreg(hw, RF90_PATH_A, RF_TXPA_G2, RFREG_OFFSET_MASK, 0xf7d77);\n\n\t \n\trtl_set_rfreg(hw, RF90_PATH_A, 0xdf, RFREG_OFFSET_MASK, 0xf80);\n\trtl_set_rfreg(hw, RF90_PATH_A, 0x55, RFREG_OFFSET_MASK, 0x4021f);\n\n\t \n\trtl_set_bbreg(hw, RRX_IQK, MASKDWORD, 0x01004800);\n\n\t \n\trtl_set_bbreg(hw, RTX_IQK_TONE_A, MASKDWORD, 0x38008c1c);\n\trtl_set_bbreg(hw, RRX_IQK_TONE_A, MASKDWORD, 0x18008c1c);\n\trtl_set_bbreg(hw, RTX_IQK_TONE_B, MASKDWORD, 0x38008c1c);\n\trtl_set_bbreg(hw, RRX_IQK_TONE_B, MASKDWORD, 0x38008c1c);\n\n\trtl_set_bbreg(hw, RTX_IQK_PI_A, MASKDWORD, 0x82110000);\n\trtl_set_bbreg(hw, RRX_IQK_PI_A, MASKDWORD, 0x2816001f);\n\trtl_set_bbreg(hw, RTX_IQK_PI_B, MASKDWORD, 0x82110000);\n\trtl_set_bbreg(hw, RRX_IQK_PI_B, MASKDWORD, 0x28110000);\n\n\t \n\trtl_set_bbreg(hw, RIQK_AGC_RSP, MASKDWORD, 0x0046a8d1);\n\n\t \n\trtl_set_bbreg(hw, RFPGA0_IQK, MASKDWORD, 0x80800000);\n\n\t \n\trtl_set_bbreg(hw, RIQK_AGC_PTS, MASKDWORD, 0xf9000000);\n\trtl_set_bbreg(hw, RIQK_AGC_PTS, MASKDWORD, 0xf8000000);\n\n\tmdelay(IQK_DELAY_TIME);\n\n\t \n\trtl_set_bbreg(hw, RFPGA0_IQK, MASKDWORD, 0x00000000);\n\n\t \n\treg_eac = rtl_get_bbreg(hw, RRX_POWER_AFTER_IQK_A_2, MASKDWORD);\n\treg_ea4 = rtl_get_bbreg(hw, RRX_POWER_BEFORE_IQK_A_2, MASKDWORD);\n\n\t \n\trtl_set_bbreg(hw, RFPGA0_IQK, MASKDWORD, 0x00000000);\n\trtl_set_rfreg(hw, RF90_PATH_A, 0xdf, RFREG_OFFSET_MASK, 0x780);\n\n\t \n\ttmp = (reg_eac & 0x03FF0000) >> 16;\n\tif ((tmp & 0x200) > 0)\n\t\ttmp = 0x400 - tmp;\n\t \n\tif (!(reg_eac & BIT(27)) &&\n\t    (((reg_ea4 & 0x03FF0000) >> 16) != 0x132) &&\n\t    (((reg_eac & 0x03FF0000) >> 16) != 0x36))\n\t\tresult |= 0x02;\n\telse if (!(reg_eac & BIT(27)) &&\n\t\t (((reg_ea4 & 0x03FF0000) >> 16) < 0x110) &&\n\t\t (((reg_ea4 & 0x03FF0000) >> 16) > 0xf0) &&\n\t\t (tmp < 0xf))\n\t\tresult |= 0x02;\n\n\treturn result;\n}\n\nstatic u8 _rtl8723be_phy_path_b_iqk(struct ieee80211_hw *hw)\n{\n\tu32 reg_eac, reg_e94, reg_e9c, tmp;\n\tu8 result = 0x00;\n\n\t \n\trtl_set_bbreg(hw, RFPGA0_IQK, MASKDWORD, 0x00000000);\n\t \n\trtl_set_bbreg(hw, 0x948, MASKDWORD, 0x00000280);\n\n\t \n\trtl_set_rfreg(hw, RF90_PATH_A, 0xed, RFREG_OFFSET_MASK, 0x00020);\n\trtl_set_rfreg(hw, RF90_PATH_A, 0x43, RFREG_OFFSET_MASK, 0x40fc1);\n\n\t \n\t \n\trtl_set_bbreg(hw, RTX_IQK, MASKDWORD, 0x01007c00);\n\trtl_set_bbreg(hw, RRX_IQK, MASKDWORD, 0x01004800);\n\t \n\trtl_set_bbreg(hw, RTX_IQK_TONE_A, MASKDWORD, 0x18008c1c);\n\trtl_set_bbreg(hw, RRX_IQK_TONE_A, MASKDWORD, 0x38008c1c);\n\trtl_set_bbreg(hw, RTX_IQK_TONE_B, MASKDWORD, 0x38008c1c);\n\trtl_set_bbreg(hw, RRX_IQK_TONE_B, MASKDWORD, 0x38008c1c);\n\n\trtl_set_bbreg(hw, RTX_IQK_PI_A, MASKDWORD, 0x821403ea);\n\trtl_set_bbreg(hw, RRX_IQK_PI_A, MASKDWORD, 0x28110000);\n\trtl_set_bbreg(hw, RTX_IQK_PI_B, MASKDWORD, 0x82110000);\n\trtl_set_bbreg(hw, RRX_IQK_PI_B, MASKDWORD, 0x28110000);\n\n\t \n\trtl_set_bbreg(hw, RIQK_AGC_RSP, MASKDWORD, 0x00462911);\n\n\t \n\trtl_set_bbreg(hw, RFPGA0_IQK, MASKDWORD, 0x80800000);\n\n\t \n\trtl_set_bbreg(hw, RIQK_AGC_PTS, MASKDWORD, 0xf9000000);\n\trtl_set_bbreg(hw, RIQK_AGC_PTS, MASKDWORD, 0xf8000000);\n\n\tmdelay(IQK_DELAY_TIME);\n\n\t \n\trtl_set_bbreg(hw, RFPGA0_IQK, MASKDWORD, 0x00000000);\n\n\t \n\treg_eac = rtl_get_bbreg(hw, RRX_POWER_AFTER_IQK_A_2, MASKDWORD);\n\treg_e94 = rtl_get_bbreg(hw, RTX_POWER_BEFORE_IQK_A, MASKDWORD);\n\treg_e9c = rtl_get_bbreg(hw, RTX_POWER_AFTER_IQK_A, MASKDWORD);\n\n\tif (!(reg_eac & BIT(28)) &&\n\t    (((reg_e94 & 0x03FF0000) >> 16) != 0x142) &&\n\t    (((reg_e9c & 0x03FF0000) >> 16) != 0x42))\n\t\tresult |= 0x01;\n\telse\n\t\treturn result;\n\n\t \n\ttmp = (reg_e9c & 0x03FF0000) >> 16;\n\tif ((tmp & 0x200) > 0)\n\t\ttmp = 0x400 - tmp;\n\n\tif (!(reg_eac & BIT(28)) &&\n\t    (((reg_e94 & 0x03FF0000) >> 16) < 0x110) &&\n\t    (((reg_e94 & 0x03FF0000) >> 16) > 0xf0) &&\n\t    (tmp < 0xf))\n\t\tresult |= 0x01;\n\telse\n\t\treturn result;\n\n\treturn result;\n}\n\n \nstatic u8 _rtl8723be_phy_path_b_rx_iqk(struct ieee80211_hw *hw)\n{\n\tu32 reg_e94, reg_e9c, reg_ea4, reg_eac, u32tmp, tmp;\n\tu8 result = 0x00;\n\n\t \n\trtl_set_bbreg(hw, RFPGA0_IQK, MASKDWORD, 0x00000000);\n\t \n\trtl_set_bbreg(hw, 0x948, MASKDWORD, 0x00000280);\n\n\t \n\t \n\trtl_set_rfreg(hw, RF90_PATH_A, RF_WE_LUT, RFREG_OFFSET_MASK, 0x800a0);\n\trtl_set_rfreg(hw, RF90_PATH_A, RF_RCK_OS, RFREG_OFFSET_MASK, 0x30000);\n\trtl_set_rfreg(hw, RF90_PATH_A, RF_TXPA_G1, RFREG_OFFSET_MASK, 0x0001f);\n\trtl_set_rfreg(hw, RF90_PATH_A, RF_TXPA_G2, RFREG_OFFSET_MASK, 0xf7ff7);\n\n\t \n\trtl_set_rfreg(hw, RF90_PATH_A, 0xed, RFREG_OFFSET_MASK, 0x00020);\n\trtl_set_rfreg(hw, RF90_PATH_A, 0x43, RFREG_OFFSET_MASK, 0x60fed);\n\n\t \n\trtl_set_bbreg(hw, RTX_IQK, MASKDWORD, 0x01007c00);\n\trtl_set_bbreg(hw, RRX_IQK, MASKDWORD, 0x01004800);\n\n\t \n\trtl_set_bbreg(hw, RTX_IQK_TONE_A, MASKDWORD, 0x18008c1c);\n\trtl_set_bbreg(hw, RRX_IQK_TONE_A, MASKDWORD, 0x38008c1c);\n\trtl_set_bbreg(hw, RTX_IQK_TONE_B, MASKDWORD, 0x38008c1c);\n\trtl_set_bbreg(hw, RRX_IQK_TONE_B, MASKDWORD, 0x38008c1c);\n\n\trtl_set_bbreg(hw, RTX_IQK_PI_A, MASKDWORD, 0x82160ff0);\n\trtl_set_bbreg(hw, RRX_IQK_PI_A, MASKDWORD, 0x28110000);\n\trtl_set_bbreg(hw, RTX_IQK_PI_B, MASKDWORD, 0x82110000);\n\trtl_set_bbreg(hw, RRX_IQK_PI_B, MASKDWORD, 0x28110000);\n\n\t \n\trtl_set_bbreg(hw, RIQK_AGC_RSP, MASKDWORD, 0x0046a911);\n\t \n\trtl_set_bbreg(hw, RFPGA0_IQK, MASKDWORD, 0x80800000);\n\n\t \n\trtl_set_bbreg(hw, RIQK_AGC_PTS, MASKDWORD, 0xf9000000);\n\trtl_set_bbreg(hw, RIQK_AGC_PTS, MASKDWORD, 0xf8000000);\n\n\tmdelay(IQK_DELAY_TIME);\n\n\t \n\trtl_set_bbreg(hw, RFPGA0_IQK, MASKDWORD, 0x00000000);\n\t \n\treg_eac = rtl_get_bbreg(hw, RRX_POWER_AFTER_IQK_A_2, MASKDWORD);\n\treg_e94 = rtl_get_bbreg(hw, RTX_POWER_BEFORE_IQK_A, MASKDWORD);\n\treg_e9c = rtl_get_bbreg(hw, RTX_POWER_AFTER_IQK_A, MASKDWORD);\n\n\tif (!(reg_eac & BIT(28)) &&\n\t    (((reg_e94 & 0x03FF0000) >> 16) != 0x142) &&\n\t    (((reg_e9c & 0x03FF0000) >> 16) != 0x42))\n\t\tresult |= 0x01;\n\telse\t \n\t\treturn result;\n\n\t \n\ttmp = (reg_e9c & 0x03FF0000) >> 16;\n\tif ((tmp & 0x200) > 0)\n\t\ttmp = 0x400 - tmp;\n\n\tif (!(reg_eac & BIT(28)) &&\n\t    (((reg_e94 & 0x03FF0000) >> 16) < 0x110) &&\n\t    (((reg_e94 & 0x03FF0000) >> 16) > 0xf0) &&\n\t    (tmp < 0xf))\n\t\tresult |= 0x01;\n\telse\n\t\treturn result;\n\n\tu32tmp = 0x80007C00 | (reg_e94 & 0x3FF0000)  |\n\t\t ((reg_e9c & 0x3FF0000) >> 16);\n\trtl_set_bbreg(hw, RTX_IQK, MASKDWORD, u32tmp);\n\n\t \n\n\t \n\trtl_set_bbreg(hw, RFPGA0_IQK, MASKDWORD, 0x00000000);\n\trtl_set_rfreg(hw, RF90_PATH_A, RF_WE_LUT, 0x80000, 0x1);\n\trtl_set_rfreg(hw, RF90_PATH_A, RF_RCK_OS, RFREG_OFFSET_MASK, 0x30000);\n\trtl_set_rfreg(hw, RF90_PATH_A, RF_TXPA_G1, RFREG_OFFSET_MASK, 0x0001f);\n\trtl_set_rfreg(hw, RF90_PATH_A, RF_TXPA_G2, RFREG_OFFSET_MASK, 0xf7d77);\n\trtl_set_rfreg(hw, RF90_PATH_A, RF_WE_LUT, 0x80000, 0x0);\n\n\t \n\trtl_set_rfreg(hw, RF90_PATH_A, 0xed, RFREG_OFFSET_MASK, 0x00020);\n\trtl_set_rfreg(hw, RF90_PATH_A, 0x43, RFREG_OFFSET_MASK, 0x60fbd);\n\n\t \n\trtl_set_bbreg(hw, RRX_IQK, MASKDWORD, 0x01004800);\n\n\t \n\trtl_set_bbreg(hw, RTX_IQK_TONE_A, MASKDWORD, 0x38008c1c);\n\trtl_set_bbreg(hw, RRX_IQK_TONE_A, MASKDWORD, 0x18008c1c);\n\trtl_set_bbreg(hw, RTX_IQK_TONE_B, MASKDWORD, 0x38008c1c);\n\trtl_set_bbreg(hw, RRX_IQK_TONE_B, MASKDWORD, 0x38008c1c);\n\n\trtl_set_bbreg(hw, RTX_IQK_PI_A, MASKDWORD, 0x82110000);\n\trtl_set_bbreg(hw, RRX_IQK_PI_A, MASKDWORD, 0x2816001f);\n\trtl_set_bbreg(hw, RTX_IQK_PI_B, MASKDWORD, 0x82110000);\n\trtl_set_bbreg(hw, RRX_IQK_PI_B, MASKDWORD, 0x28110000);\n\n\t \n\trtl_set_bbreg(hw, RIQK_AGC_RSP, MASKDWORD, 0x0046a8d1);\n\t \n\trtl_set_bbreg(hw, RFPGA0_IQK, MASKDWORD, 0x80800000);\n\n\t \n\trtl_set_bbreg(hw, RIQK_AGC_PTS, MASKDWORD, 0xf9000000);\n\trtl_set_bbreg(hw, RIQK_AGC_PTS, MASKDWORD, 0xf8000000);\n\n\tmdelay(IQK_DELAY_TIME);\n\n\t \n\trtl_set_bbreg(hw, RFPGA0_IQK, MASKDWORD, 0x00000000);\n\t \n\treg_eac = rtl_get_bbreg(hw, RRX_POWER_AFTER_IQK_A_2, MASKDWORD);\n\treg_ea4 = rtl_get_bbreg(hw, RRX_POWER_BEFORE_IQK_A_2, MASKDWORD);\n\n\t \n\ttmp = (reg_eac & 0x03FF0000) >> 16;\n\tif ((tmp & 0x200) > 0)\n\t\ttmp = 0x400 - tmp;\n\n\t \n\tif (!(reg_eac & BIT(27)) &&\n\t    (((reg_ea4 & 0x03FF0000) >> 16) != 0x132) &&\n\t    (((reg_eac & 0x03FF0000) >> 16) != 0x36))\n\t\tresult |= 0x02;\n\telse if (!(reg_eac & BIT(27)) &&\n\t\t (((reg_ea4 & 0x03FF0000) >> 16) < 0x110) &&\n\t\t (((reg_ea4 & 0x03FF0000) >> 16) > 0xf0) &&\n\t\t (tmp < 0xf))\n\t\tresult |= 0x02;\n\telse\n\t\treturn result;\n\n\treturn result;\n}\n\nstatic void _rtl8723be_phy_path_b_fill_iqk_matrix(struct ieee80211_hw *hw,\n\t\t\t\t\t\t  bool b_iqk_ok,\n\t\t\t\t\t\t  long result[][8],\n\t\t\t\t\t\t  u8 final_candidate,\n\t\t\t\t\t\t  bool btxonly)\n{\n\tu32 oldval_1, x, tx1_a, reg;\n\tlong y, tx1_c;\n\n\tif (final_candidate == 0xFF) {\n\t\treturn;\n\t} else if (b_iqk_ok) {\n\t\toldval_1 = (rtl_get_bbreg(hw, ROFDM0_XBTXIQIMBALANCE,\n\t\t\t\t\t  MASKDWORD) >> 22) & 0x3FF;\n\t\tx = result[final_candidate][4];\n\t\tif ((x & 0x00000200) != 0)\n\t\t\tx = x | 0xFFFFFC00;\n\t\ttx1_a = (x * oldval_1) >> 8;\n\t\trtl_set_bbreg(hw, ROFDM0_XBTXIQIMBALANCE, 0x3FF, tx1_a);\n\t\trtl_set_bbreg(hw, ROFDM0_ECCATHRESHOLD, BIT(27),\n\t\t\t      ((x * oldval_1 >> 7) & 0x1));\n\t\ty = result[final_candidate][5];\n\t\tif ((y & 0x00000200) != 0)\n\t\t\ty = y | 0xFFFFFC00;\n\t\ttx1_c = (y * oldval_1) >> 8;\n\t\trtl_set_bbreg(hw, ROFDM0_XDTXAFE, 0xF0000000,\n\t\t\t      ((tx1_c & 0x3C0) >> 6));\n\t\trtl_set_bbreg(hw, ROFDM0_XBTXIQIMBALANCE, 0x003F0000,\n\t\t\t      (tx1_c & 0x3F));\n\t\trtl_set_bbreg(hw, ROFDM0_ECCATHRESHOLD, BIT(25),\n\t\t\t      ((y * oldval_1 >> 7) & 0x1));\n\t\tif (btxonly)\n\t\t\treturn;\n\t\treg = result[final_candidate][6];\n\t\trtl_set_bbreg(hw, ROFDM0_XBRXIQIMBALANCE, 0x3FF, reg);\n\t\treg = result[final_candidate][7] & 0x3F;\n\t\trtl_set_bbreg(hw, ROFDM0_XBRXIQIMBALANCE, 0xFC00, reg);\n\t\treg = (result[final_candidate][7] >> 6) & 0xF;\n\t\t \n\t}\n}\n\nstatic bool _rtl8723be_phy_simularity_compare(struct ieee80211_hw *hw,\n\t\t\t\t\t      long result[][8], u8 c1, u8 c2)\n{\n\tu32 i, j, diff, simularity_bitmap, bound = 0;\n\n\tu8 final_candidate[2] = {0xFF, 0xFF};  \n\tbool bresult = true;  \n\ts32 tmp1 = 0, tmp2 = 0;\n\n\tbound = 8;\n\n\tsimularity_bitmap = 0;\n\n\tfor (i = 0; i < bound; i++) {\n\t\tif ((i == 1) || (i == 3) || (i == 5) || (i == 7)) {\n\t\t\tif ((result[c1][i] & 0x00000200) != 0)\n\t\t\t\ttmp1 = result[c1][i] | 0xFFFFFC00;\n\t\t\telse\n\t\t\t\ttmp1 = result[c1][i];\n\n\t\t\tif ((result[c2][i] & 0x00000200) != 0)\n\t\t\t\ttmp2 = result[c2][i] | 0xFFFFFC00;\n\t\t\telse\n\t\t\t\ttmp2 = result[c2][i];\n\t\t} else {\n\t\t\ttmp1 = result[c1][i];\n\t\t\ttmp2 = result[c2][i];\n\t\t}\n\n\t\tdiff = (tmp1 > tmp2) ? (tmp1 - tmp2) : (tmp2 - tmp1);\n\n\t\tif (diff > MAX_TOLERANCE) {\n\t\t\tif ((i == 2 || i == 6) && !simularity_bitmap) {\n\t\t\t\tif (result[c1][i] + result[c1][i + 1] == 0)\n\t\t\t\t\tfinal_candidate[(i / 4)] = c2;\n\t\t\t\telse if (result[c2][i] + result[c2][i + 1] == 0)\n\t\t\t\t\tfinal_candidate[(i / 4)] = c1;\n\t\t\t\telse\n\t\t\t\t\tsimularity_bitmap |= (1 << i);\n\t\t\t} else\n\t\t\t\tsimularity_bitmap |= (1 << i);\n\t\t}\n\t}\n\n\tif (simularity_bitmap == 0) {\n\t\tfor (i = 0; i < (bound / 4); i++) {\n\t\t\tif (final_candidate[i] != 0xFF) {\n\t\t\t\tfor (j = i * 4; j < (i + 1) * 4 - 2; j++)\n\t\t\t\t\tresult[3][j] =\n\t\t\t\t\t\tresult[final_candidate[i]][j];\n\t\t\t\tbresult = false;\n\t\t\t}\n\t\t}\n\t\treturn bresult;\n\t} else {\n\t\tif (!(simularity_bitmap & 0x03)) {  \n\t\t\tfor (i = 0; i < 2; i++)\n\t\t\t\tresult[3][i] = result[c1][i];\n\t\t}\n\t\tif (!(simularity_bitmap & 0x0c)) {  \n\t\t\tfor (i = 2; i < 4; i++)\n\t\t\t\tresult[3][i] = result[c1][i];\n\t\t}\n\t\tif (!(simularity_bitmap & 0x30)) {  \n\t\t\tfor (i = 4; i < 6; i++)\n\t\t\t\tresult[3][i] = result[c1][i];\n\t\t}\n\t\tif (!(simularity_bitmap & 0xc0)) {  \n\t\t\tfor (i = 6; i < 8; i++)\n\t\t\t\tresult[3][i] = result[c1][i];\n\t\t}\n\t\treturn false;\n\t}\n}\n\nstatic void _rtl8723be_phy_iq_calibrate(struct ieee80211_hw *hw,\n\t\t\t\t\tlong result[][8], u8 t, bool is2t)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\tu32 i;\n\tu8 patha_ok, pathb_ok;\n\tu32 adda_reg[IQK_ADDA_REG_NUM] = {\n\t\t0x85c, 0xe6c, 0xe70, 0xe74,\n\t\t0xe78, 0xe7c, 0xe80, 0xe84,\n\t\t0xe88, 0xe8c, 0xed0, 0xed4,\n\t\t0xed8, 0xedc, 0xee0, 0xeec\n\t};\n\n\tu32 iqk_mac_reg[IQK_MAC_REG_NUM] = {\n\t\t0x522, 0x550, 0x551, 0x040\n\t};\n\tu32 iqk_bb_reg[IQK_BB_REG_NUM] = {\n\t\tROFDM0_TRXPATHENABLE, ROFDM0_TRMUXPAR,\n\t\tRFPGA0_XCD_RFINTERFACESW, 0xb68, 0xb6c,\n\t\t0x870, 0x860,\n\t\t0x864, 0xa04\n\t};\n\tconst u32 retrycount = 2;\n\n\tu32 path_sel_bb; \n\n\tu8 tmp_reg_c50, tmp_reg_c58;\n\n\ttmp_reg_c50 = rtl_get_bbreg(hw, 0xc50, MASKBYTE0);\n\ttmp_reg_c58 = rtl_get_bbreg(hw, 0xc58, MASKBYTE0);\n\n\tif (t == 0) {\n\t\trtl8723_save_adda_registers(hw, adda_reg,\n\t\t\t\t\t    rtlphy->adda_backup, 16);\n\t\trtl8723_phy_save_mac_registers(hw, iqk_mac_reg,\n\t\t\t\t\t       rtlphy->iqk_mac_backup);\n\t\trtl8723_save_adda_registers(hw, iqk_bb_reg,\n\t\t\t\t\t    rtlphy->iqk_bb_backup,\n\t\t\t\t\t    IQK_BB_REG_NUM);\n\t}\n\trtl8723_phy_path_adda_on(hw, adda_reg, true, is2t);\n\tif (t == 0) {\n\t\trtlphy->rfpi_enable = (u8)rtl_get_bbreg(hw,\n\t\t\t\t\t\tRFPGA0_XA_HSSIPARAMETER1,\n\t\t\t\t\t\tBIT(8));\n\t}\n\n\tpath_sel_bb = rtl_get_bbreg(hw, 0x948, MASKDWORD);\n\n\trtl8723_phy_mac_setting_calibration(hw, iqk_mac_reg,\n\t\t\t\t\t    rtlphy->iqk_mac_backup);\n\t \n\trtl_set_bbreg(hw, 0xa04, 0x0f000000, 0xf);\n\trtl_set_bbreg(hw, 0xc04, MASKDWORD, 0x03a05600);\n\trtl_set_bbreg(hw, 0xc08, MASKDWORD, 0x000800e4);\n\trtl_set_bbreg(hw, 0x874, MASKDWORD, 0x22204000);\n\n\t \n\tfor (i = 0; i < retrycount; i++) {\n\t\tpatha_ok = _rtl8723be_phy_path_a_iqk(hw);\n\t\tif (patha_ok == 0x01) {\n\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\t\"Path A Tx IQK Success!!\\n\");\n\t\t\tresult[t][0] = (rtl_get_bbreg(hw, 0xe94, MASKDWORD) &\n\t\t\t\t\t0x3FF0000) >> 16;\n\t\t\tresult[t][1] = (rtl_get_bbreg(hw, 0xe9c, MASKDWORD) &\n\t\t\t\t\t0x3FF0000) >> 16;\n\t\t\tbreak;\n\t\t} else {\n\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\t\"Path A Tx IQK Fail!!\\n\");\n\t\t}\n\t}\n\t \n\tfor (i = 0; i < retrycount; i++) {\n\t\tpatha_ok = _rtl8723be_phy_path_a_rx_iqk(hw);\n\t\tif (patha_ok == 0x03) {\n\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\t\"Path A Rx IQK Success!!\\n\");\n\t\t\tresult[t][2] = (rtl_get_bbreg(hw, 0xea4, MASKDWORD) &\n\t\t\t\t\t0x3FF0000) >> 16;\n\t\t\tresult[t][3] = (rtl_get_bbreg(hw, 0xeac, MASKDWORD) &\n\t\t\t\t\t0x3FF0000) >> 16;\n\t\t\tbreak;\n\t\t}\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\"Path A Rx IQK Fail!!\\n\");\n\t}\n\n\tif (0x00 == patha_ok)\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD, \"Path A IQK Fail!!\\n\");\n\n\tif (is2t) {\n\t\t \n\t\tfor (i = 0; i < retrycount; i++) {\n\t\t\tpathb_ok = _rtl8723be_phy_path_b_iqk(hw);\n\t\t\tif (pathb_ok == 0x01) {\n\t\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\t\t\"Path B Tx IQK Success!!\\n\");\n\t\t\t\tresult[t][4] = (rtl_get_bbreg(hw, 0xe94,\n\t\t\t\t\t\t\t      MASKDWORD) &\n\t\t\t\t\t\t\t      0x3FF0000) >> 16;\n\t\t\t\tresult[t][5] = (rtl_get_bbreg(hw, 0xe9c,\n\t\t\t\t\t\t\t      MASKDWORD) &\n\t\t\t\t\t\t\t      0x3FF0000) >> 16;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\t\"Path B Tx IQK Fail!!\\n\");\n\t\t}\n\t\t \n\t\tfor (i = 0; i < retrycount; i++) {\n\t\t\tpathb_ok = _rtl8723be_phy_path_b_rx_iqk(hw);\n\t\t\tif (pathb_ok == 0x03) {\n\t\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\t\t\"Path B Rx IQK Success!!\\n\");\n\t\t\t\tresult[t][6] = (rtl_get_bbreg(hw, 0xea4,\n\t\t\t\t\t\t\t      MASKDWORD) &\n\t\t\t\t\t\t\t      0x3FF0000) >> 16;\n\t\t\t\tresult[t][7] = (rtl_get_bbreg(hw, 0xeac,\n\t\t\t\t\t\t\t      MASKDWORD) &\n\t\t\t\t\t\t\t      0x3FF0000) >> 16;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\t\"Path B Rx IQK Fail!!\\n\");\n\t\t}\n\t}\n\n\t \n\trtl_set_bbreg(hw, RFPGA0_IQK, MASKDWORD, 0);\n\n\tif (t != 0) {\n\t\trtl8723_phy_reload_adda_registers(hw, adda_reg,\n\t\t\t\t\t\t  rtlphy->adda_backup, 16);\n\t\trtl8723_phy_reload_mac_registers(hw, iqk_mac_reg,\n\t\t\t\t\t\t rtlphy->iqk_mac_backup);\n\t\trtl8723_phy_reload_adda_registers(hw, iqk_bb_reg,\n\t\t\t\t\t\t  rtlphy->iqk_bb_backup,\n\t\t\t\t\t\t  IQK_BB_REG_NUM);\n\n\t\trtl_set_bbreg(hw, 0x948, MASKDWORD, path_sel_bb);\n\t\t \n\n\t\trtl_set_bbreg(hw, 0xc50, MASKBYTE0, 0x50);\n\t\trtl_set_bbreg(hw, 0xc50, MASKBYTE0, tmp_reg_c50);\n\t\tif (is2t) {\n\t\t\trtl_set_bbreg(hw, 0xc58, MASKBYTE0, 0x50);\n\t\t\trtl_set_bbreg(hw, 0xc58, MASKBYTE0, tmp_reg_c58);\n\t\t}\n\t\trtl_set_bbreg(hw, 0xe30, MASKDWORD, 0x01008c00);\n\t\trtl_set_bbreg(hw, 0xe34, MASKDWORD, 0x01008c00);\n\t}\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD, \"8723be IQK Finish!!\\n\");\n}\n\nstatic u8 _get_right_chnl_place_for_iqk(u8 chnl)\n{\n\tu8 channel_all[TARGET_CHNL_NUM_2G_5G] = {\n\t\t\t1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,\n\t\t\t13, 14, 36, 38, 40, 42, 44, 46,\n\t\t\t48, 50, 52, 54, 56, 58, 60, 62, 64,\n\t\t\t100, 102, 104, 106, 108, 110,\n\t\t\t112, 114, 116, 118, 120, 122,\n\t\t\t124, 126, 128, 130, 132, 134, 136,\n\t\t\t138, 140, 149, 151, 153, 155, 157,\n\t\t\t159, 161, 163, 165};\n\tu8 place = chnl;\n\n\tif (chnl > 14) {\n\t\tfor (place = 14; place < sizeof(channel_all); place++) {\n\t\t\tif (channel_all[place] == chnl)\n\t\t\t\treturn place - 13;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void _rtl8723be_phy_lc_calibrate(struct ieee80211_hw *hw, bool is2t)\n{\n\tu8 tmpreg;\n\tu32 rf_a_mode = 0, rf_b_mode = 0;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\ttmpreg = rtl_read_byte(rtlpriv, 0xd03);\n\n\tif ((tmpreg & 0x70) != 0)\n\t\trtl_write_byte(rtlpriv, 0xd03, tmpreg & 0x8F);\n\telse\n\t\trtl_write_byte(rtlpriv, REG_TXPAUSE, 0xFF);\n\n\tif ((tmpreg & 0x70) != 0) {\n\t\trf_a_mode = rtl_get_rfreg(hw, RF90_PATH_A, 0x00, MASK12BITS);\n\n\t\tif (is2t)\n\t\t\trf_b_mode = rtl_get_rfreg(hw, RF90_PATH_B, 0x00,\n\t\t\t\t\t\t  MASK12BITS);\n\n\t\trtl_set_rfreg(hw, RF90_PATH_A, 0x00, MASK12BITS,\n\t\t\t      (rf_a_mode & 0x8FFFF) | 0x10000);\n\n\t\tif (is2t)\n\t\t\trtl_set_rfreg(hw, RF90_PATH_B, 0x00, MASK12BITS,\n\t\t\t\t      (rf_b_mode & 0x8FFFF) | 0x10000);\n\t}\n\trtl_get_rfreg(hw, RF90_PATH_A, 0x18, MASK12BITS);\n\n\trtl_set_rfreg(hw, RF90_PATH_A, 0xb0, RFREG_OFFSET_MASK, 0xdfbe0);\n\trtl_set_rfreg(hw, RF90_PATH_A, 0x18, MASK12BITS, 0x8c0a);\n\n\t \n\t \n\t \n\tmdelay(50);\n\n\trtl_set_rfreg(hw, RF90_PATH_A, 0xb0, RFREG_OFFSET_MASK, 0xdffe0);\n\n\tif ((tmpreg & 0x70) != 0) {\n\t\trtl_write_byte(rtlpriv, 0xd03, tmpreg);\n\t\trtl_set_rfreg(hw, RF90_PATH_A, 0x00, MASK12BITS, rf_a_mode);\n\n\t\tif (is2t)\n\t\t\trtl_set_rfreg(hw, RF90_PATH_B, 0x00,\n\t\t\t\t      MASK12BITS, rf_b_mode);\n\t} else {\n\t\trtl_write_byte(rtlpriv, REG_TXPAUSE, 0x00);\n\t}\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD, \"\\n\");\n}\n\nstatic void _rtl8723be_phy_set_rfpath_switch(struct ieee80211_hw *hw,\n\t\t\t\t\t     bool bmain, bool is2t)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD, \"\\n\");\n\n\tif (bmain)  \n\t\trtl_set_bbreg(hw, 0x92C, MASKDWORD, 0x1);\n\telse\n\t\trtl_set_bbreg(hw, 0x92C, MASKDWORD, 0x2);\n}\n\n#undef IQK_ADDA_REG_NUM\n#undef IQK_DELAY_TIME\n \nvoid rtl8723be_phy_iq_calibrate(struct ieee80211_hw *hw, bool b_recovery)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\tlong result[4][8];\n\tu8 i, final_candidate, idx;\n\tbool b_patha_ok, b_pathb_ok;\n\tlong reg_e94, reg_e9c, reg_ea4, reg_eb4, reg_ebc, reg_ec4;\n\tlong reg_tmp = 0;\n\tbool is12simular, is13simular, is23simular;\n\tu32 iqk_bb_reg[9] = {\n\t\tROFDM0_XARXIQIMBALANCE,\n\t\tROFDM0_XBRXIQIMBALANCE,\n\t\tROFDM0_ECCATHRESHOLD,\n\t\tROFDM0_AGCRSSITABLE,\n\t\tROFDM0_XATXIQIMBALANCE,\n\t\tROFDM0_XBTXIQIMBALANCE,\n\t\tROFDM0_XCTXAFE,\n\t\tROFDM0_XDTXAFE,\n\t\tROFDM0_RXIQEXTANTA\n\t};\n\tu32 path_sel_bb = 0;  \n\n\tif (rtlphy->lck_inprogress)\n\t\treturn;\n\n\tspin_lock(&rtlpriv->locks.iqk_lock);\n\trtlphy->lck_inprogress = true;\n\tspin_unlock(&rtlpriv->locks.iqk_lock);\n\n\tif (b_recovery) {\n\t\trtl8723_phy_reload_adda_registers(hw, iqk_bb_reg,\n\t\t\t\t\t\t  rtlphy->iqk_bb_backup, 9);\n\t\tgoto label_done;\n\t}\n\t \n\tpath_sel_bb = rtl_get_bbreg(hw, 0x948, MASKDWORD);\n\t \n\n\tfor (i = 0; i < 8; i++) {\n\t\tresult[0][i] = 0;\n\t\tresult[1][i] = 0;\n\t\tresult[2][i] = 0;\n\t\tresult[3][i] = 0;\n\t}\n\tfinal_candidate = 0xff;\n\tb_patha_ok = false;\n\tb_pathb_ok = false;\n\tis12simular = false;\n\tis23simular = false;\n\tis13simular = false;\n\tfor (i = 0; i < 3; i++) {\n\t\t_rtl8723be_phy_iq_calibrate(hw, result, i, true);\n\t\tif (i == 1) {\n\t\t\tis12simular = _rtl8723be_phy_simularity_compare(hw,\n\t\t\t\t\t\t\t\t\tresult,\n\t\t\t\t\t\t\t\t\t0, 1);\n\t\t\tif (is12simular) {\n\t\t\t\tfinal_candidate = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == 2) {\n\t\t\tis13simular = _rtl8723be_phy_simularity_compare(hw,\n\t\t\t\t\t\t\t\t\tresult,\n\t\t\t\t\t\t\t\t\t0, 2);\n\t\t\tif (is13simular) {\n\t\t\t\tfinal_candidate = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tis23simular = _rtl8723be_phy_simularity_compare(hw,\n\t\t\t\t\t\t\t\t\tresult,\n\t\t\t\t\t\t\t\t\t1, 2);\n\t\t\tif (is23simular) {\n\t\t\t\tfinal_candidate = 1;\n\t\t\t} else {\n\t\t\t\tfor (i = 0; i < 8; i++)\n\t\t\t\t\treg_tmp += result[3][i];\n\n\t\t\t\tif (reg_tmp != 0)\n\t\t\t\t\tfinal_candidate = 3;\n\t\t\t\telse\n\t\t\t\t\tfinal_candidate = 0xFF;\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0; i < 4; i++) {\n\t\treg_e94 = result[i][0];\n\t\treg_e9c = result[i][1];\n\t\treg_ea4 = result[i][2];\n\t\treg_eb4 = result[i][4];\n\t\treg_ebc = result[i][5];\n\t\treg_ec4 = result[i][6];\n\t}\n\tif (final_candidate != 0xff) {\n\t\treg_e94 = result[final_candidate][0];\n\t\trtlphy->reg_e94 = reg_e94;\n\t\treg_e9c = result[final_candidate][1];\n\t\trtlphy->reg_e9c = reg_e9c;\n\t\treg_ea4 = result[final_candidate][2];\n\t\treg_eb4 = result[final_candidate][4];\n\t\trtlphy->reg_eb4 = reg_eb4;\n\t\treg_ebc = result[final_candidate][5];\n\t\trtlphy->reg_ebc = reg_ebc;\n\t\treg_ec4 = result[final_candidate][6];\n\t\tb_patha_ok = true;\n\t\tb_pathb_ok = true;\n\t} else {\n\t\trtlphy->reg_e94 = 0x100;\n\t\trtlphy->reg_eb4 = 0x100;\n\t\trtlphy->reg_e9c = 0x0;\n\t\trtlphy->reg_ebc = 0x0;\n\t}\n\tif (reg_e94 != 0)\n\t\trtl8723_phy_path_a_fill_iqk_matrix(hw, b_patha_ok, result,\n\t\t\t\t\t\t   final_candidate,\n\t\t\t\t\t\t   (reg_ea4 == 0));\n\tif (reg_eb4 != 0)\n\t\t_rtl8723be_phy_path_b_fill_iqk_matrix(hw, b_pathb_ok, result,\n\t\t\t\t\t\t      final_candidate,\n\t\t\t\t\t\t      (reg_ec4 == 0));\n\n\tidx = _get_right_chnl_place_for_iqk(rtlphy->current_channel);\n\n\tif (final_candidate < 4) {\n\t\tfor (i = 0; i < IQK_MATRIX_REG_NUM; i++)\n\t\t\trtlphy->iqk_matrix[idx].value[0][i] =\n\t\t\t\t\t\tresult[final_candidate][i];\n\t\trtlphy->iqk_matrix[idx].iqk_done = true;\n\n\t}\n\trtl8723_save_adda_registers(hw, iqk_bb_reg,\n\t\t\t\t    rtlphy->iqk_bb_backup, 9);\n\n\trtl_set_bbreg(hw, 0x948, MASKDWORD, path_sel_bb);\n\t \n\nlabel_done:\n\tspin_lock(&rtlpriv->locks.iqk_lock);\n\trtlphy->lck_inprogress = false;\n\tspin_unlock(&rtlpriv->locks.iqk_lock);\n}\n\nvoid rtl8723be_phy_lc_calibrate(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\tstruct rtl_hal *rtlhal = &rtlpriv->rtlhal;\n\tu32 timeout = 2000, timecount = 0;\n\n\twhile (rtlpriv->mac80211.act_scanning && timecount < timeout) {\n\t\tudelay(50);\n\t\ttimecount += 50;\n\t}\n\n\trtlphy->lck_inprogress = true;\n\tRTPRINT(rtlpriv, FINIT, INIT_IQK,\n\t\t\"LCK:Start!!! currentband %x delay %d ms\\n\",\n\t\t rtlhal->current_bandtype, timecount);\n\n\t_rtl8723be_phy_lc_calibrate(hw, false);\n\n\trtlphy->lck_inprogress = false;\n}\n\nvoid rtl8723be_phy_set_rfpath_switch(struct ieee80211_hw *hw, bool bmain)\n{\n\t_rtl8723be_phy_set_rfpath_switch(hw, bmain, true);\n}\n\nbool rtl8723be_phy_set_io_cmd(struct ieee80211_hw *hw, enum io_type iotype)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\tbool b_postprocessing = false;\n\n\trtl_dbg(rtlpriv, COMP_CMD, DBG_TRACE,\n\t\t\"-->IO Cmd(%#x), set_io_inprogress(%d)\\n\",\n\t\tiotype, rtlphy->set_io_inprogress);\n\tdo {\n\t\tswitch (iotype) {\n\t\tcase IO_CMD_RESUME_DM_BY_SCAN:\n\t\t\trtl_dbg(rtlpriv, COMP_CMD, DBG_TRACE,\n\t\t\t\t\"[IO CMD] Resume DM after scan.\\n\");\n\t\t\tb_postprocessing = true;\n\t\t\tbreak;\n\t\tcase IO_CMD_PAUSE_BAND0_DM_BY_SCAN:\n\t\t\trtl_dbg(rtlpriv, COMP_CMD, DBG_TRACE,\n\t\t\t\t\"[IO CMD] Pause DM before scan.\\n\");\n\t\t\tb_postprocessing = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_LOUD,\n\t\t\t\t\"switch case %#x not processed\\n\", iotype);\n\t\t\tbreak;\n\t\t}\n\t} while (false);\n\tif (b_postprocessing && !rtlphy->set_io_inprogress) {\n\t\trtlphy->set_io_inprogress = true;\n\t\trtlphy->current_io_type = iotype;\n\t} else {\n\t\treturn false;\n\t}\n\trtl8723be_phy_set_io(hw);\n\trtl_dbg(rtlpriv, COMP_CMD, DBG_TRACE, \"IO Type(%#x)\\n\", iotype);\n\treturn true;\n}\n\nstatic void rtl8723be_phy_set_io(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct dig_t *dm_digtable = &rtlpriv->dm_digtable;\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\n\trtl_dbg(rtlpriv, COMP_CMD, DBG_TRACE,\n\t\t\"--->Cmd(%#x), set_io_inprogress(%d)\\n\",\n\t\trtlphy->current_io_type, rtlphy->set_io_inprogress);\n\tswitch (rtlphy->current_io_type) {\n\tcase IO_CMD_RESUME_DM_BY_SCAN:\n\t\tdm_digtable->cur_igvalue = rtlphy->initgain_backup.xaagccore1;\n\t\t \n\t\trtl8723be_phy_set_txpower_level(hw, rtlphy->current_channel);\n\t\trtl_set_bbreg(hw, RCCK0_CCA, 0xff0000, 0x83);\n\t\tbreak;\n\tcase IO_CMD_PAUSE_BAND0_DM_BY_SCAN:\n\t\trtlphy->initgain_backup.xaagccore1 = dm_digtable->cur_igvalue;\n\t\tdm_digtable->cur_igvalue = 0x17;\n\t\trtl_set_bbreg(hw, RCCK0_CCA, 0xff0000, 0x40);\n\t\tbreak;\n\tdefault:\n\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_LOUD,\n\t\t\t\"switch case %#x not processed\\n\",\n\t\t\trtlphy->current_io_type);\n\t\tbreak;\n\t}\n\trtlphy->set_io_inprogress = false;\n\trtl_dbg(rtlpriv, COMP_CMD, DBG_TRACE,\n\t\t\"(%#x)\\n\", rtlphy->current_io_type);\n}\n\nstatic void rtl8723be_phy_set_rf_on(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtl_write_byte(rtlpriv, REG_SPS0_CTRL, 0x2b);\n\trtl_write_byte(rtlpriv, REG_SYS_FUNC_EN, 0xE3);\n\trtl_write_byte(rtlpriv, REG_SYS_FUNC_EN, 0xE2);\n\trtl_write_byte(rtlpriv, REG_SYS_FUNC_EN, 0xE3);\n\trtl_write_byte(rtlpriv, REG_TXPAUSE, 0x00);\n}\n\nstatic void _rtl8723be_phy_set_rf_sleep(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtl_write_byte(rtlpriv, REG_TXPAUSE, 0xFF);\n\trtl_set_rfreg(hw, RF90_PATH_A, 0x00, RFREG_OFFSET_MASK, 0x00);\n\trtl_write_byte(rtlpriv, REG_SYS_FUNC_EN, 0xE2);\n\trtl_write_byte(rtlpriv, REG_SPS0_CTRL, 0x22);\n}\n\nstatic bool _rtl8723be_phy_set_rf_power_state(struct ieee80211_hw *hw,\n\t\t\t\t\t      enum rf_pwrstate rfpwr_state)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci_priv *pcipriv = rtl_pcipriv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tbool bresult = true;\n\tu8 i, queue_id;\n\tstruct rtl8192_tx_ring *ring = NULL;\n\n\tswitch (rfpwr_state) {\n\tcase ERFON:\n\t\tif ((ppsc->rfpwr_state == ERFOFF) &&\n\t\t     RT_IN_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_HALT_NIC)) {\n\t\t\tbool rtstatus;\n\t\t\tu32 initializecount = 0;\n\t\t\tdo {\n\t\t\t\tinitializecount++;\n\t\t\t\trtl_dbg(rtlpriv, COMP_RF, DBG_DMESG,\n\t\t\t\t\t\"IPS Set eRf nic enable\\n\");\n\t\t\t\trtstatus = rtl_ps_enable_nic(hw);\n\t\t\t} while (!rtstatus && (initializecount < 10));\n\t\t\tRT_CLEAR_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_HALT_NIC);\n\t\t} else {\n\t\t\trtl_dbg(rtlpriv, COMP_RF, DBG_DMESG,\n\t\t\t\t\"Set ERFON slept:%d ms\\n\",\n\t\t\t\tjiffies_to_msecs(jiffies -\n\t\t\t\t\t\t ppsc->last_sleep_jiffies));\n\t\t\tppsc->last_awake_jiffies = jiffies;\n\t\t\trtl8723be_phy_set_rf_on(hw);\n\t\t}\n\t\tif (mac->link_state == MAC80211_LINKED)\n\t\t\trtlpriv->cfg->ops->led_control(hw, LED_CTL_LINK);\n\t\telse\n\t\t\trtlpriv->cfg->ops->led_control(hw, LED_CTL_NO_LINK);\n\n\t\tbreak;\n\n\tcase ERFOFF:\n\t\tfor (queue_id = 0, i = 0;\n\t\t     queue_id < RTL_PCI_MAX_TX_QUEUE_COUNT;) {\n\t\t\tring = &pcipriv->dev.tx_ring[queue_id];\n\t\t\t \n\t\t\tif (queue_id == BEACON_QUEUE ||\n\t\t\t    skb_queue_len(&ring->queue) == 0) {\n\t\t\t\tqueue_id++;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_WARNING,\n\t\t\t\t\t\"eRf Off/Sleep: %d times TcbBusyQueue[%d] =%d before doze!\\n\",\n\t\t\t\t\t(i + 1), queue_id,\n\t\t\t\t\tskb_queue_len(&ring->queue));\n\n\t\t\t\tudelay(10);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (i >= MAX_DOZE_WAITING_TIMES_9x) {\n\t\t\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_WARNING,\n\t\t\t\t\t\"ERFSLEEP: %d times TcbBusyQueue[%d] = %d !\\n\",\n\t\t\t\t\tMAX_DOZE_WAITING_TIMES_9x,\n\t\t\t\t\tqueue_id,\n\t\t\t\t\tskb_queue_len(&ring->queue));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ppsc->reg_rfps_level & RT_RF_OFF_LEVL_HALT_NIC) {\n\t\t\trtl_dbg(rtlpriv, COMP_RF, DBG_DMESG,\n\t\t\t\t\"IPS Set eRf nic disable\\n\");\n\t\t\trtl_ps_disable_nic(hw);\n\t\t\tRT_SET_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_HALT_NIC);\n\t\t} else {\n\t\t\tif (ppsc->rfoff_reason == RF_CHANGE_BY_IPS) {\n\t\t\t\trtlpriv->cfg->ops->led_control(hw,\n\t\t\t\t\t\t\t       LED_CTL_NO_LINK);\n\t\t\t} else {\n\t\t\t\trtlpriv->cfg->ops->led_control(hw,\n\t\t\t\t\t\t\t     LED_CTL_POWER_OFF);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase ERFSLEEP:\n\t\tif (ppsc->rfpwr_state == ERFOFF)\n\t\t\tbreak;\n\t\tfor (queue_id = 0, i = 0;\n\t\t     queue_id < RTL_PCI_MAX_TX_QUEUE_COUNT;) {\n\t\t\tring = &pcipriv->dev.tx_ring[queue_id];\n\t\t\tif (skb_queue_len(&ring->queue) == 0) {\n\t\t\t\tqueue_id++;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_WARNING,\n\t\t\t\t\t\"eRf Off/Sleep: %d times TcbBusyQueue[%d] =%d before doze!\\n\",\n\t\t\t\t\t(i + 1), queue_id,\n\t\t\t\t\tskb_queue_len(&ring->queue));\n\n\t\t\t\tudelay(10);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (i >= MAX_DOZE_WAITING_TIMES_9x) {\n\t\t\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_WARNING,\n\t\t\t\t\t\"ERFSLEEP: %d times TcbBusyQueue[%d] = %d !\\n\",\n\t\t\t\t\tMAX_DOZE_WAITING_TIMES_9x,\n\t\t\t\t\tqueue_id,\n\t\t\t\t\tskb_queue_len(&ring->queue));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trtl_dbg(rtlpriv, COMP_RF, DBG_DMESG,\n\t\t\t\"Set ERFSLEEP awaked:%d ms\\n\",\n\t\t\tjiffies_to_msecs(jiffies -\n\t\t\t\t\t ppsc->last_awake_jiffies));\n\t\tppsc->last_sleep_jiffies = jiffies;\n\t\t_rtl8723be_phy_set_rf_sleep(hw);\n\t\tbreak;\n\n\tdefault:\n\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_LOUD,\n\t\t\t\"switch case %#x not processed\\n\", rfpwr_state);\n\t\tbresult = false;\n\t\tbreak;\n\t}\n\tif (bresult)\n\t\tppsc->rfpwr_state = rfpwr_state;\n\treturn bresult;\n}\n\nbool rtl8723be_phy_set_rf_power_state(struct ieee80211_hw *hw,\n\t\t\t\t      enum rf_pwrstate rfpwr_state)\n{\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\n\tbool bresult = false;\n\n\tif (rfpwr_state == ppsc->rfpwr_state)\n\t\treturn bresult;\n\tbresult = _rtl8723be_phy_set_rf_power_state(hw, rfpwr_state);\n\treturn bresult;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}