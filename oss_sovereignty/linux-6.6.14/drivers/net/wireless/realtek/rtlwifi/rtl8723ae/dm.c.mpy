{
  "module_name": "dm.c",
  "hash_id": "997bfc3c860ad8b48b713df68c78fba86760c92cd80ef8c4b8b72d89ccade401",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtlwifi/rtl8723ae/dm.c",
  "human_readable_source": "\n \n\n#include \"../wifi.h\"\n#include \"../base.h\"\n#include \"../pci.h\"\n#include \"../core.h\"\n#include \"reg.h\"\n#include \"def.h\"\n#include \"phy.h\"\n#include \"dm.h\"\n#include \"../rtl8723com/dm_common.h\"\n#include \"fw.h\"\n#include \"hal_btc.h\"\n\nstatic u8 rtl8723e_dm_initial_gain_min_pwdb(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct dig_t *dm_digtable = &rtlpriv->dm_digtable;\n\tstruct rtl_mac *mac = rtl_mac(rtlpriv);\n\tlong rssi_val_min = 0;\n\n\tif (mac->link_state == MAC80211_LINKED &&\n\t    mac->opmode == NL80211_IFTYPE_STATION &&\n\t    rtlpriv->link_info.bcn_rx_inperiod == 0)\n\t\treturn 0;\n\n\tif ((dm_digtable->curmultista_cstate == DIG_MULTISTA_CONNECT) &&\n\t    (dm_digtable->cursta_cstate == DIG_STA_CONNECT)) {\n\t\tif (rtlpriv->dm.entry_min_undec_sm_pwdb != 0)\n\t\t\trssi_val_min =\n\t\t\t    (rtlpriv->dm.entry_min_undec_sm_pwdb >\n\t\t\t     rtlpriv->dm.undec_sm_pwdb) ?\n\t\t\t    rtlpriv->dm.undec_sm_pwdb :\n\t\t\t    rtlpriv->dm.entry_min_undec_sm_pwdb;\n\t\telse\n\t\t\trssi_val_min = rtlpriv->dm.undec_sm_pwdb;\n\t} else if (dm_digtable->cursta_cstate == DIG_STA_CONNECT ||\n\t\t   dm_digtable->cursta_cstate == DIG_STA_BEFORE_CONNECT) {\n\t\trssi_val_min = rtlpriv->dm.undec_sm_pwdb;\n\t} else if (dm_digtable->curmultista_cstate ==\n\t\tDIG_MULTISTA_CONNECT) {\n\t\trssi_val_min = rtlpriv->dm.entry_min_undec_sm_pwdb;\n\t}\n\n\treturn (u8) rssi_val_min;\n}\n\nstatic void rtl8723e_dm_false_alarm_counter_statistics(struct ieee80211_hw *hw)\n{\n\tu32 ret_value;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct false_alarm_statistics *falsealm_cnt = &(rtlpriv->falsealm_cnt);\n\n\tret_value = rtl_get_bbreg(hw, ROFDM_PHYCOUNTER1, MASKDWORD);\n\tfalsealm_cnt->cnt_parity_fail = ((ret_value & 0xffff0000) >> 16);\n\n\tret_value = rtl_get_bbreg(hw, ROFDM_PHYCOUNTER2, MASKDWORD);\n\tfalsealm_cnt->cnt_rate_illegal = (ret_value & 0xffff);\n\tfalsealm_cnt->cnt_crc8_fail = ((ret_value & 0xffff0000) >> 16);\n\n\tret_value = rtl_get_bbreg(hw, ROFDM_PHYCOUNTER3, MASKDWORD);\n\tfalsealm_cnt->cnt_mcs_fail = (ret_value & 0xffff);\n\tfalsealm_cnt->cnt_ofdm_fail = falsealm_cnt->cnt_parity_fail +\n\t    falsealm_cnt->cnt_rate_illegal +\n\t    falsealm_cnt->cnt_crc8_fail + falsealm_cnt->cnt_mcs_fail;\n\n\trtl_set_bbreg(hw, RCCK0_FALSEALARMREPORT, BIT(14), 1);\n\tret_value = rtl_get_bbreg(hw, RCCK0_FACOUNTERLOWER, MASKBYTE0);\n\tfalsealm_cnt->cnt_cck_fail = ret_value;\n\n\tret_value = rtl_get_bbreg(hw, RCCK0_FACOUNTERUPPER, MASKBYTE3);\n\tfalsealm_cnt->cnt_cck_fail += (ret_value & 0xff) << 8;\n\tfalsealm_cnt->cnt_all = (falsealm_cnt->cnt_parity_fail +\n\t\t\t\t falsealm_cnt->cnt_rate_illegal +\n\t\t\t\t falsealm_cnt->cnt_crc8_fail +\n\t\t\t\t falsealm_cnt->cnt_mcs_fail +\n\t\t\t\t falsealm_cnt->cnt_cck_fail);\n\n\trtl_set_bbreg(hw, ROFDM1_LSTF, 0x08000000, 1);\n\trtl_set_bbreg(hw, ROFDM1_LSTF, 0x08000000, 0);\n\trtl_set_bbreg(hw, RCCK0_FALSEALARMREPORT, 0x0000c000, 0);\n\trtl_set_bbreg(hw, RCCK0_FALSEALARMREPORT, 0x0000c000, 2);\n\n\trtl_dbg(rtlpriv, COMP_DIG, DBG_TRACE,\n\t\t\"cnt_parity_fail = %d, cnt_rate_illegal = %d, cnt_crc8_fail = %d, cnt_mcs_fail = %d\\n\",\n\t\tfalsealm_cnt->cnt_parity_fail,\n\t\tfalsealm_cnt->cnt_rate_illegal,\n\t\tfalsealm_cnt->cnt_crc8_fail, falsealm_cnt->cnt_mcs_fail);\n\n\trtl_dbg(rtlpriv, COMP_DIG, DBG_TRACE,\n\t\t\"cnt_ofdm_fail = %x, cnt_cck_fail = %x, cnt_all = %x\\n\",\n\t\tfalsealm_cnt->cnt_ofdm_fail,\n\t\tfalsealm_cnt->cnt_cck_fail, falsealm_cnt->cnt_all);\n}\n\nstatic void rtl92c_dm_ctrl_initgain_by_fa(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct dig_t *dm_digtable = &rtlpriv->dm_digtable;\n\tu8 value_igi = dm_digtable->cur_igvalue;\n\n\tif (rtlpriv->falsealm_cnt.cnt_all < DM_DIG_FA_TH0)\n\t\tvalue_igi--;\n\telse if (rtlpriv->falsealm_cnt.cnt_all < DM_DIG_FA_TH1)\n\t\tvalue_igi += 0;\n\telse if (rtlpriv->falsealm_cnt.cnt_all < DM_DIG_FA_TH2)\n\t\tvalue_igi++;\n\telse if (rtlpriv->falsealm_cnt.cnt_all >= DM_DIG_FA_TH2)\n\t\tvalue_igi += 2;\n\tif (value_igi > DM_DIG_FA_UPPER)\n\t\tvalue_igi = DM_DIG_FA_UPPER;\n\telse if (value_igi < DM_DIG_FA_LOWER)\n\t\tvalue_igi = DM_DIG_FA_LOWER;\n\tif (rtlpriv->falsealm_cnt.cnt_all > 10000)\n\t\tvalue_igi = 0x32;\n\n\tdm_digtable->cur_igvalue = value_igi;\n\trtl8723e_dm_write_dig(hw);\n}\n\nstatic void rtl92c_dm_ctrl_initgain_by_rssi(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct dig_t *dm_digtable = &rtlpriv->dm_digtable;\n\n\tif (rtlpriv->falsealm_cnt.cnt_all > dm_digtable->fa_highthresh) {\n\t\tif ((dm_digtable->back_val - 2) <\n\t\t    dm_digtable->back_range_min)\n\t\t\tdm_digtable->back_val =\n\t\t\t    dm_digtable->back_range_min;\n\t\telse\n\t\t\tdm_digtable->back_val -= 2;\n\t} else if (rtlpriv->falsealm_cnt.cnt_all < dm_digtable->fa_lowthresh) {\n\t\tif ((dm_digtable->back_val + 2) >\n\t\t    dm_digtable->back_range_max)\n\t\t\tdm_digtable->back_val =\n\t\t\t    dm_digtable->back_range_max;\n\t\telse\n\t\t\tdm_digtable->back_val += 2;\n\t}\n\n\tif ((dm_digtable->rssi_val_min + 10 - dm_digtable->back_val) >\n\t    dm_digtable->rx_gain_max)\n\t\tdm_digtable->cur_igvalue = dm_digtable->rx_gain_max;\n\telse if ((dm_digtable->rssi_val_min + 10 -\n\t\t  dm_digtable->back_val) < dm_digtable->rx_gain_min)\n\t\tdm_digtable->cur_igvalue = dm_digtable->rx_gain_min;\n\telse\n\t\tdm_digtable->cur_igvalue = dm_digtable->rssi_val_min + 10 -\n\t\t    dm_digtable->back_val;\n\n\trtl_dbg(rtlpriv, COMP_DIG, DBG_TRACE,\n\t\t\"rssi_val_min = %x back_val %x\\n\",\n\t\tdm_digtable->rssi_val_min, dm_digtable->back_val);\n\n\trtl8723e_dm_write_dig(hw);\n}\n\nstatic void rtl8723e_dm_initial_gain_multi_sta(struct ieee80211_hw *hw)\n{\n\tstatic u8 binitialized;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct dig_t *dm_digtable = &rtlpriv->dm_digtable;\n\tlong rssi_strength = rtlpriv->dm.entry_min_undec_sm_pwdb;\n\tbool multi_sta = false;\n\n\tif (mac->opmode == NL80211_IFTYPE_ADHOC)\n\t\tmulti_sta = true;\n\n\tif (!multi_sta || (dm_digtable->cursta_cstate != DIG_STA_DISCONNECT)) {\n\t\tbinitialized = false;\n\t\tdm_digtable->dig_ext_port_stage = DIG_EXT_PORT_STAGE_MAX;\n\t\treturn;\n\t} else if (!binitialized) {\n\t\tbinitialized = true;\n\t\tdm_digtable->dig_ext_port_stage = DIG_EXT_PORT_STAGE_0;\n\t\tdm_digtable->cur_igvalue = 0x20;\n\t\trtl8723e_dm_write_dig(hw);\n\t}\n\n\tif (dm_digtable->curmultista_cstate == DIG_MULTISTA_CONNECT) {\n\t\tif ((rssi_strength < dm_digtable->rssi_lowthresh) &&\n\t\t    (dm_digtable->dig_ext_port_stage != DIG_EXT_PORT_STAGE_1)) {\n\n\t\t\tif (dm_digtable->dig_ext_port_stage ==\n\t\t\t    DIG_EXT_PORT_STAGE_2) {\n\t\t\t\tdm_digtable->cur_igvalue = 0x20;\n\t\t\t\trtl8723e_dm_write_dig(hw);\n\t\t\t}\n\n\t\t\tdm_digtable->dig_ext_port_stage = DIG_EXT_PORT_STAGE_1;\n\t\t} else if (rssi_strength > dm_digtable->rssi_highthresh) {\n\t\t\tdm_digtable->dig_ext_port_stage = DIG_EXT_PORT_STAGE_2;\n\t\t\trtl92c_dm_ctrl_initgain_by_fa(hw);\n\t\t}\n\t} else if (dm_digtable->dig_ext_port_stage != DIG_EXT_PORT_STAGE_0) {\n\t\tdm_digtable->dig_ext_port_stage = DIG_EXT_PORT_STAGE_0;\n\t\tdm_digtable->cur_igvalue = 0x20;\n\t\trtl8723e_dm_write_dig(hw);\n\t}\n\n\trtl_dbg(rtlpriv, COMP_DIG, DBG_TRACE,\n\t\t\"curmultista_cstate = %x dig_ext_port_stage %x\\n\",\n\t\tdm_digtable->curmultista_cstate,\n\t\tdm_digtable->dig_ext_port_stage);\n}\n\nstatic void rtl8723e_dm_initial_gain_sta(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct dig_t *dm_digtable = &rtlpriv->dm_digtable;\n\n\trtl_dbg(rtlpriv, COMP_DIG, DBG_TRACE,\n\t\t\"presta_cstate = %x, cursta_cstate = %x\\n\",\n\t\tdm_digtable->presta_cstate,\n\t\tdm_digtable->cursta_cstate);\n\n\tif (dm_digtable->presta_cstate == dm_digtable->cursta_cstate ||\n\t    dm_digtable->cursta_cstate == DIG_STA_BEFORE_CONNECT ||\n\t    dm_digtable->cursta_cstate == DIG_STA_CONNECT) {\n\t\tif (dm_digtable->cursta_cstate != DIG_STA_DISCONNECT) {\n\t\t\tdm_digtable->rssi_val_min =\n\t\t\t    rtl8723e_dm_initial_gain_min_pwdb(hw);\n\t\t\trtl92c_dm_ctrl_initgain_by_rssi(hw);\n\t\t}\n\t} else {\n\t\tdm_digtable->rssi_val_min = 0;\n\t\tdm_digtable->dig_ext_port_stage = DIG_EXT_PORT_STAGE_MAX;\n\t\tdm_digtable->back_val = DM_DIG_BACKOFF_DEFAULT;\n\t\tdm_digtable->cur_igvalue = 0x20;\n\t\tdm_digtable->pre_igvalue = 0;\n\t\trtl8723e_dm_write_dig(hw);\n\t}\n}\n\nstatic void rtl8723e_dm_cck_packet_detection_thresh(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct dig_t *dm_digtable = &rtlpriv->dm_digtable;\n\n\tif (dm_digtable->cursta_cstate == DIG_STA_CONNECT) {\n\t\tdm_digtable->rssi_val_min = rtl8723e_dm_initial_gain_min_pwdb(hw);\n\n\t\tif (dm_digtable->pre_cck_pd_state == CCK_PD_STAGE_LOWRSSI) {\n\t\t\tif (dm_digtable->rssi_val_min <= 25)\n\t\t\t\tdm_digtable->cur_cck_pd_state =\n\t\t\t\t    CCK_PD_STAGE_LOWRSSI;\n\t\t\telse\n\t\t\t\tdm_digtable->cur_cck_pd_state =\n\t\t\t\t    CCK_PD_STAGE_HIGHRSSI;\n\t\t} else {\n\t\t\tif (dm_digtable->rssi_val_min <= 20)\n\t\t\t\tdm_digtable->cur_cck_pd_state =\n\t\t\t\t    CCK_PD_STAGE_LOWRSSI;\n\t\t\telse\n\t\t\t\tdm_digtable->cur_cck_pd_state =\n\t\t\t\t    CCK_PD_STAGE_HIGHRSSI;\n\t\t}\n\t} else {\n\t\tdm_digtable->cur_cck_pd_state = CCK_PD_STAGE_MAX;\n\t}\n\n\tif (dm_digtable->pre_cck_pd_state != dm_digtable->cur_cck_pd_state) {\n\t\tif (dm_digtable->cur_cck_pd_state == CCK_PD_STAGE_LOWRSSI) {\n\t\t\tif (rtlpriv->falsealm_cnt.cnt_cck_fail > 800)\n\t\t\t\tdm_digtable->cur_cck_fa_state =\n\t\t\t\t    CCK_FA_STAGE_HIGH;\n\t\t\telse\n\t\t\t\tdm_digtable->cur_cck_fa_state =\n\t\t\t\t    CCK_FA_STAGE_LOW;\n\t\t\tif (dm_digtable->pre_cck_fa_state !=\n\t\t\t    dm_digtable->cur_cck_fa_state) {\n\t\t\t\tif (dm_digtable->cur_cck_fa_state ==\n\t\t\t\t    CCK_FA_STAGE_LOW)\n\t\t\t\t\trtl_set_bbreg(hw, RCCK0_CCA, MASKBYTE2,\n\t\t\t\t\t\t      0x83);\n\t\t\t\telse\n\t\t\t\t\trtl_set_bbreg(hw, RCCK0_CCA, MASKBYTE2,\n\t\t\t\t\t\t      0xcd);\n\n\t\t\t\tdm_digtable->pre_cck_fa_state =\n\t\t\t\t    dm_digtable->cur_cck_fa_state;\n\t\t\t}\n\n\t\t\trtl_set_bbreg(hw, RCCK0_SYSTEM, MASKBYTE1, 0x40);\n\n\t\t} else {\n\t\t\trtl_set_bbreg(hw, RCCK0_CCA, MASKBYTE2, 0xcd);\n\t\t\trtl_set_bbreg(hw, RCCK0_SYSTEM, MASKBYTE1, 0x47);\n\t\t\tdm_digtable->pre_cck_fa_state = 0;\n\t\t\tdm_digtable->cur_cck_fa_state = 0;\n\n\t\t}\n\t\tdm_digtable->pre_cck_pd_state = dm_digtable->cur_cck_pd_state;\n\t}\n\n\trtl_dbg(rtlpriv, COMP_DIG, DBG_TRACE,\n\t\t\"CCKPDStage=%x\\n\", dm_digtable->cur_cck_pd_state);\n\n}\n\nstatic void rtl8723e_dm_ctrl_initgain_by_twoport(struct ieee80211_hw *hw)\n{\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct dig_t *dm_digtable = &rtlpriv->dm_digtable;\n\n\tif (mac->act_scanning)\n\t\treturn;\n\n\tif (mac->link_state >= MAC80211_LINKED)\n\t\tdm_digtable->cursta_cstate = DIG_STA_CONNECT;\n\telse\n\t\tdm_digtable->cursta_cstate = DIG_STA_DISCONNECT;\n\n\trtl8723e_dm_initial_gain_sta(hw);\n\trtl8723e_dm_initial_gain_multi_sta(hw);\n\trtl8723e_dm_cck_packet_detection_thresh(hw);\n\n\tdm_digtable->presta_cstate = dm_digtable->cursta_cstate;\n\n}\n\nstatic void rtl8723e_dm_dig(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct dig_t *dm_digtable = &rtlpriv->dm_digtable;\n\n\tif (!rtlpriv->dm.dm_initialgain_enable)\n\t\treturn;\n\tif (!dm_digtable->dig_enable_flag)\n\t\treturn;\n\n\trtl8723e_dm_ctrl_initgain_by_twoport(hw);\n\n}\n\nstatic void rtl8723e_dm_dynamic_txpower(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tlong undec_sm_pwdb;\n\n\tif (!rtlpriv->dm.dynamic_txpower_enable)\n\t\treturn;\n\n\tif (rtlpriv->dm.dm_flag & HAL_DM_HIPWR_DISABLE) {\n\t\trtlpriv->dm.dynamic_txhighpower_lvl = TXHIGHPWRLEVEL_NORMAL;\n\t\treturn;\n\t}\n\n\tif ((mac->link_state < MAC80211_LINKED) &&\n\t    (rtlpriv->dm.entry_min_undec_sm_pwdb == 0)) {\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_TRACE,\n\t\t\t\"Not connected to any\\n\");\n\n\t\trtlpriv->dm.dynamic_txhighpower_lvl = TXHIGHPWRLEVEL_NORMAL;\n\n\t\trtlpriv->dm.last_dtp_lvl = TXHIGHPWRLEVEL_NORMAL;\n\t\treturn;\n\t}\n\n\tif (mac->link_state >= MAC80211_LINKED) {\n\t\tif (mac->opmode == NL80211_IFTYPE_ADHOC) {\n\t\t\tundec_sm_pwdb =\n\t\t\t    rtlpriv->dm.entry_min_undec_sm_pwdb;\n\t\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD,\n\t\t\t\t\"AP Client PWDB = 0x%lx\\n\",\n\t\t\t\tundec_sm_pwdb);\n\t\t} else {\n\t\t\tundec_sm_pwdb =\n\t\t\t    rtlpriv->dm.undec_sm_pwdb;\n\t\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD,\n\t\t\t\t\"STA Default Port PWDB = 0x%lx\\n\",\n\t\t\t\tundec_sm_pwdb);\n\t\t}\n\t} else {\n\t\tundec_sm_pwdb =\n\t\t    rtlpriv->dm.entry_min_undec_sm_pwdb;\n\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD,\n\t\t\t\"AP Ext Port PWDB = 0x%lx\\n\",\n\t\t\tundec_sm_pwdb);\n\t}\n\n\tif (undec_sm_pwdb >= TX_POWER_NEAR_FIELD_THRESH_LVL2) {\n\t\trtlpriv->dm.dynamic_txhighpower_lvl = TXHIGHPWRLEVEL_LEVEL1;\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD,\n\t\t\t\"TXHIGHPWRLEVEL_LEVEL1 (TxPwr=0x0)\\n\");\n\t} else if ((undec_sm_pwdb <\n\t\t    (TX_POWER_NEAR_FIELD_THRESH_LVL2 - 3)) &&\n\t\t   (undec_sm_pwdb >=\n\t\t    TX_POWER_NEAR_FIELD_THRESH_LVL1)) {\n\t\trtlpriv->dm.dynamic_txhighpower_lvl = TXHIGHPWRLEVEL_LEVEL1;\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD,\n\t\t\t\"TXHIGHPWRLEVEL_LEVEL1 (TxPwr=0x10)\\n\");\n\t} else if (undec_sm_pwdb <\n\t\t   (TX_POWER_NEAR_FIELD_THRESH_LVL1 - 5)) {\n\t\trtlpriv->dm.dynamic_txhighpower_lvl = TXHIGHPWRLEVEL_NORMAL;\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD,\n\t\t\t\"TXHIGHPWRLEVEL_NORMAL\\n\");\n\t}\n\n\tif (rtlpriv->dm.dynamic_txhighpower_lvl != rtlpriv->dm.last_dtp_lvl) {\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD,\n\t\t\t\"PHY_SetTxPowerLevel8192S() Channel = %d\\n\",\n\t\t\trtlphy->current_channel);\n\t\trtl8723e_phy_set_txpower_level(hw, rtlphy->current_channel);\n\t}\n\n\trtlpriv->dm.last_dtp_lvl = rtlpriv->dm.dynamic_txhighpower_lvl;\n}\n\nvoid rtl8723e_dm_write_dig(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct dig_t *dm_digtable = &rtlpriv->dm_digtable;\n\n\trtl_dbg(rtlpriv, COMP_DIG, DBG_LOUD,\n\t\t\"cur_igvalue = 0x%x, pre_igvalue = 0x%x, back_val = %d\\n\",\n\t\tdm_digtable->cur_igvalue, dm_digtable->pre_igvalue,\n\t\tdm_digtable->back_val);\n\n\tif (dm_digtable->pre_igvalue != dm_digtable->cur_igvalue) {\n\t\trtl_set_bbreg(hw, ROFDM0_XAAGCCORE1, 0x7f,\n\t\t\t      dm_digtable->cur_igvalue);\n\t\trtl_set_bbreg(hw, ROFDM0_XBAGCCORE1, 0x7f,\n\t\t\t      dm_digtable->cur_igvalue);\n\n\t\tdm_digtable->pre_igvalue = dm_digtable->cur_igvalue;\n\t}\n}\n\nstatic void rtl8723e_dm_pwdb_monitor(struct ieee80211_hw *hw)\n{\n}\n\nstatic void rtl8723e_dm_check_edca_turbo(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\n\tstatic u64 last_txok_cnt;\n\tstatic u64 last_rxok_cnt;\n\tstatic u32 last_bt_edca_ul;\n\tstatic u32 last_bt_edca_dl;\n\tu64 cur_txok_cnt = 0;\n\tu64 cur_rxok_cnt = 0;\n\tu32 edca_be_ul = 0x5ea42b;\n\tu32 edca_be_dl = 0x5ea42b;\n\tbool bt_change_edca = false;\n\n\tif ((last_bt_edca_ul != rtlpriv->btcoexist.bt_edca_ul) ||\n\t    (last_bt_edca_dl != rtlpriv->btcoexist.bt_edca_dl)) {\n\t\trtlpriv->dm.current_turbo_edca = false;\n\t\tlast_bt_edca_ul = rtlpriv->btcoexist.bt_edca_ul;\n\t\tlast_bt_edca_dl = rtlpriv->btcoexist.bt_edca_dl;\n\t}\n\n\tif (rtlpriv->btcoexist.bt_edca_ul != 0) {\n\t\tedca_be_ul = rtlpriv->btcoexist.bt_edca_ul;\n\t\tbt_change_edca = true;\n\t}\n\n\tif (rtlpriv->btcoexist.bt_edca_dl != 0) {\n\t\tedca_be_dl = rtlpriv->btcoexist.bt_edca_dl;\n\t\tbt_change_edca = true;\n\t}\n\n\tif (mac->link_state != MAC80211_LINKED) {\n\t\trtlpriv->dm.current_turbo_edca = false;\n\t\treturn;\n\t}\n\tif ((bt_change_edca) || ((!rtlpriv->dm.is_any_nonbepkts) &&\n\t     (!rtlpriv->dm.disable_framebursting))) {\n\n\t\tcur_txok_cnt = rtlpriv->stats.txbytesunicast - last_txok_cnt;\n\t\tcur_rxok_cnt = rtlpriv->stats.rxbytesunicast - last_rxok_cnt;\n\n\t\tif (cur_rxok_cnt > 4 * cur_txok_cnt) {\n\t\t\tif (!rtlpriv->dm.is_cur_rdlstate ||\n\t\t\t    !rtlpriv->dm.current_turbo_edca) {\n\t\t\t\trtl_write_dword(rtlpriv,\n\t\t\t\t\t\tREG_EDCA_BE_PARAM,\n\t\t\t\t\t\tedca_be_dl);\n\t\t\t\trtlpriv->dm.is_cur_rdlstate = true;\n\t\t\t}\n\t\t} else {\n\t\t\tif (rtlpriv->dm.is_cur_rdlstate ||\n\t\t\t    !rtlpriv->dm.current_turbo_edca) {\n\t\t\t\trtl_write_dword(rtlpriv,\n\t\t\t\t\t\tREG_EDCA_BE_PARAM,\n\t\t\t\t\t\tedca_be_ul);\n\t\t\t\trtlpriv->dm.is_cur_rdlstate = false;\n\t\t\t}\n\t\t}\n\t\trtlpriv->dm.current_turbo_edca = true;\n\t} else {\n\t\tif (rtlpriv->dm.current_turbo_edca) {\n\t\t\tu8 tmp = AC0_BE;\n\t\t\trtlpriv->cfg->ops->set_hw_reg(hw,\n\t\t\t\t\t\t      HW_VAR_AC_PARAM,\n\t\t\t\t\t\t      (u8 *)(&tmp));\n\t\t\trtlpriv->dm.current_turbo_edca = false;\n\t\t}\n\t}\n\n\trtlpriv->dm.is_any_nonbepkts = false;\n\tlast_txok_cnt = rtlpriv->stats.txbytesunicast;\n\tlast_rxok_cnt = rtlpriv->stats.rxbytesunicast;\n}\n\nstatic void rtl8723e_dm_initialize_txpower_tracking_thermalmeter(\n\t\t\t\tstruct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtlpriv->dm.txpower_tracking = true;\n\trtlpriv->dm.txpower_trackinginit = false;\n\n\trtl_dbg(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\n\t\t\"pMgntInfo->txpower_tracking = %d\\n\",\n\t\trtlpriv->dm.txpower_tracking);\n}\n\nstatic void rtl8723e_dm_initialize_txpower_tracking(struct ieee80211_hw *hw)\n{\n\trtl8723e_dm_initialize_txpower_tracking_thermalmeter(hw);\n}\n\nvoid rtl8723e_dm_check_txpower_tracking(struct ieee80211_hw *hw)\n{\n\treturn;\n}\n\nvoid rtl8723e_dm_init_rate_adaptive_mask(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rate_adaptive *p_ra = &rtlpriv->ra;\n\n\tp_ra->ratr_state = DM_RATR_STA_INIT;\n\tp_ra->pre_ratr_state = DM_RATR_STA_INIT;\n\n\tif (rtlpriv->dm.dm_type == DM_TYPE_BYDRIVER)\n\t\trtlpriv->dm.useramask = true;\n\telse\n\t\trtlpriv->dm.useramask = false;\n\n}\n\nstatic void rtl8723e_dm_refresh_rate_adaptive_mask(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rate_adaptive *p_ra = &rtlpriv->ra;\n\tu32 low_rssithresh_for_ra, high_rssithresh_for_ra;\n\tstruct ieee80211_sta *sta = NULL;\n\n\tif (is_hal_stop(rtlhal)) {\n\t\trtl_dbg(rtlpriv, COMP_RATE, DBG_LOUD,\n\t\t\t\" driver is going to unload\\n\");\n\t\treturn;\n\t}\n\n\tif (!rtlpriv->dm.useramask) {\n\t\trtl_dbg(rtlpriv, COMP_RATE, DBG_LOUD,\n\t\t\t\" driver does not control rate adaptive mask\\n\");\n\t\treturn;\n\t}\n\n\tif (mac->link_state == MAC80211_LINKED &&\n\t    mac->opmode == NL80211_IFTYPE_STATION) {\n\t\tswitch (p_ra->pre_ratr_state) {\n\t\tcase DM_RATR_STA_HIGH:\n\t\t\thigh_rssithresh_for_ra = 50;\n\t\t\tlow_rssithresh_for_ra = 20;\n\t\t\tbreak;\n\t\tcase DM_RATR_STA_MIDDLE:\n\t\t\thigh_rssithresh_for_ra = 55;\n\t\t\tlow_rssithresh_for_ra = 20;\n\t\t\tbreak;\n\t\tcase DM_RATR_STA_LOW:\n\t\t\thigh_rssithresh_for_ra = 60;\n\t\t\tlow_rssithresh_for_ra = 25;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\thigh_rssithresh_for_ra = 50;\n\t\t\tlow_rssithresh_for_ra = 20;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rtlpriv->link_info.bcn_rx_inperiod == 0)\n\t\t\tswitch (p_ra->pre_ratr_state) {\n\t\t\tcase DM_RATR_STA_HIGH:\n\t\t\tdefault:\n\t\t\t\tp_ra->ratr_state = DM_RATR_STA_MIDDLE;\n\t\t\t\tbreak;\n\t\t\tcase DM_RATR_STA_MIDDLE:\n\t\t\tcase DM_RATR_STA_LOW:\n\t\t\t\tp_ra->ratr_state = DM_RATR_STA_LOW;\n\t\t\t\tbreak;\n\t\t\t}\n\t\telse if (rtlpriv->dm.undec_sm_pwdb > high_rssithresh_for_ra)\n\t\t\tp_ra->ratr_state = DM_RATR_STA_HIGH;\n\t\telse if (rtlpriv->dm.undec_sm_pwdb > low_rssithresh_for_ra)\n\t\t\tp_ra->ratr_state = DM_RATR_STA_MIDDLE;\n\t\telse\n\t\t\tp_ra->ratr_state = DM_RATR_STA_LOW;\n\n\t\tif (p_ra->pre_ratr_state != p_ra->ratr_state) {\n\t\t\trtl_dbg(rtlpriv, COMP_RATE, DBG_LOUD,\n\t\t\t\t\"RSSI = %ld\\n\",\n\t\t\t\trtlpriv->dm.undec_sm_pwdb);\n\t\t\trtl_dbg(rtlpriv, COMP_RATE, DBG_LOUD,\n\t\t\t\t\"RSSI_LEVEL = %d\\n\", p_ra->ratr_state);\n\t\t\trtl_dbg(rtlpriv, COMP_RATE, DBG_LOUD,\n\t\t\t\t\"PreState = %d, CurState = %d\\n\",\n\t\t\t\tp_ra->pre_ratr_state, p_ra->ratr_state);\n\n\t\t\trcu_read_lock();\n\t\t\tsta = rtl_find_sta(hw, mac->bssid);\n\t\t\tif (sta)\n\t\t\t\trtlpriv->cfg->ops->update_rate_tbl(hw, sta,\n\t\t\t\t\t\t\t   p_ra->ratr_state,\n\t\t\t\t\t\t\t\t      true);\n\t\t\trcu_read_unlock();\n\n\t\t\tp_ra->pre_ratr_state = p_ra->ratr_state;\n\t\t}\n\t}\n}\n\nvoid rtl8723e_dm_rf_saving(struct ieee80211_hw *hw, u8 bforce_in_normal)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct ps_t *dm_pstable = &rtlpriv->dm_pstable;\n\tstatic u8 initialize;\n\tstatic u32 reg_874, reg_c70, reg_85c, reg_a74;\n\n\tif (initialize == 0) {\n\t\treg_874 = (rtl_get_bbreg(hw, RFPGA0_XCD_RFINTERFACESW,\n\t\t\t\t\t MASKDWORD) & 0x1CC000) >> 14;\n\n\t\treg_c70 = (rtl_get_bbreg(hw, ROFDM0_AGCPARAMETER1,\n\t\t\t\t\t MASKDWORD) & BIT(3)) >> 3;\n\n\t\treg_85c = (rtl_get_bbreg(hw, RFPGA0_XCD_SWITCHCONTROL,\n\t\t\t\t\t MASKDWORD) & 0xFF000000) >> 24;\n\n\t\treg_a74 = (rtl_get_bbreg(hw, 0xa74, MASKDWORD) & 0xF000) >> 12;\n\n\t\tinitialize = 1;\n\t}\n\n\tif (!bforce_in_normal) {\n\t\tif (dm_pstable->rssi_val_min != 0) {\n\t\t\tif (dm_pstable->pre_rfstate == RF_NORMAL) {\n\t\t\t\tif (dm_pstable->rssi_val_min >= 30)\n\t\t\t\t\tdm_pstable->cur_rfstate = RF_SAVE;\n\t\t\t\telse\n\t\t\t\t\tdm_pstable->cur_rfstate = RF_NORMAL;\n\t\t\t} else {\n\t\t\t\tif (dm_pstable->rssi_val_min <= 25)\n\t\t\t\t\tdm_pstable->cur_rfstate = RF_NORMAL;\n\t\t\t\telse\n\t\t\t\t\tdm_pstable->cur_rfstate = RF_SAVE;\n\t\t\t}\n\t\t} else {\n\t\t\tdm_pstable->cur_rfstate = RF_MAX;\n\t\t}\n\t} else {\n\t\tdm_pstable->cur_rfstate = RF_NORMAL;\n\t}\n\n\tif (dm_pstable->pre_rfstate != dm_pstable->cur_rfstate) {\n\t\tif (dm_pstable->cur_rfstate == RF_SAVE) {\n\t\t\trtl_set_bbreg(hw, RFPGA0_XCD_RFINTERFACESW,\n\t\t\t\t      BIT(5), 0x1);\n\t\t\trtl_set_bbreg(hw, RFPGA0_XCD_RFINTERFACESW,\n\t\t\t\t      0x1C0000, 0x2);\n\t\t\trtl_set_bbreg(hw, ROFDM0_AGCPARAMETER1, BIT(3), 0);\n\t\t\trtl_set_bbreg(hw, RFPGA0_XCD_SWITCHCONTROL,\n\t\t\t\t      0xFF000000, 0x63);\n\t\t\trtl_set_bbreg(hw, RFPGA0_XCD_RFINTERFACESW,\n\t\t\t\t      0xC000, 0x2);\n\t\t\trtl_set_bbreg(hw, 0xa74, 0xF000, 0x3);\n\t\t\trtl_set_bbreg(hw, 0x818, BIT(28), 0x0);\n\t\t\trtl_set_bbreg(hw, 0x818, BIT(28), 0x1);\n\t\t} else {\n\t\t\trtl_set_bbreg(hw, RFPGA0_XCD_RFINTERFACESW,\n\t\t\t\t      0x1CC000, reg_874);\n\t\t\trtl_set_bbreg(hw, ROFDM0_AGCPARAMETER1, BIT(3),\n\t\t\t\t      reg_c70);\n\t\t\trtl_set_bbreg(hw, RFPGA0_XCD_SWITCHCONTROL, 0xFF000000,\n\t\t\t\t      reg_85c);\n\t\t\trtl_set_bbreg(hw, 0xa74, 0xF000, reg_a74);\n\t\t\trtl_set_bbreg(hw, 0x818, BIT(28), 0x0);\n\t\t\trtl_set_bbreg(hw, RFPGA0_XCD_RFINTERFACESW,\n\t\t\t\t      BIT(5), 0x0);\n\t\t}\n\n\t\tdm_pstable->pre_rfstate = dm_pstable->cur_rfstate;\n\t}\n}\n\nstatic void rtl8723e_dm_dynamic_bb_powersaving(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct ps_t *dm_pstable = &rtlpriv->dm_pstable;\n\n\tif (((mac->link_state == MAC80211_NOLINK)) &&\n\t    (rtlpriv->dm.entry_min_undec_sm_pwdb == 0)) {\n\t\tdm_pstable->rssi_val_min = 0;\n\t\trtl_dbg(rtlpriv, DBG_LOUD, DBG_LOUD,\n\t\t\t\"Not connected to any\\n\");\n\t}\n\n\tif (mac->link_state == MAC80211_LINKED) {\n\t\tif (mac->opmode == NL80211_IFTYPE_ADHOC) {\n\t\t\tdm_pstable->rssi_val_min =\n\t\t\t    rtlpriv->dm.entry_min_undec_sm_pwdb;\n\t\t\trtl_dbg(rtlpriv, DBG_LOUD, DBG_LOUD,\n\t\t\t\t\"AP Client PWDB = 0x%lx\\n\",\n\t\t\t\tdm_pstable->rssi_val_min);\n\t\t} else {\n\t\t\tdm_pstable->rssi_val_min =\n\t\t\t    rtlpriv->dm.undec_sm_pwdb;\n\t\t\trtl_dbg(rtlpriv, DBG_LOUD, DBG_LOUD,\n\t\t\t\t\"STA Default Port PWDB = 0x%lx\\n\",\n\t\t\t\tdm_pstable->rssi_val_min);\n\t\t}\n\t} else {\n\t\tdm_pstable->rssi_val_min =\n\t\t    rtlpriv->dm.entry_min_undec_sm_pwdb;\n\n\t\trtl_dbg(rtlpriv, DBG_LOUD, DBG_LOUD,\n\t\t\t\"AP Ext Port PWDB = 0x%lx\\n\",\n\t\t\tdm_pstable->rssi_val_min);\n\t}\n\n\trtl8723e_dm_rf_saving(hw, false);\n}\n\nvoid rtl8723e_dm_init(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtlpriv->dm.dm_type = DM_TYPE_BYDRIVER;\n\trtl_dm_diginit(hw, 0x20);\n\trtl8723_dm_init_dynamic_txpower(hw);\n\trtl8723_dm_init_edca_turbo(hw);\n\trtl8723e_dm_init_rate_adaptive_mask(hw);\n\trtl8723e_dm_initialize_txpower_tracking(hw);\n\trtl8723_dm_init_dynamic_bb_powersaving(hw);\n}\n\nvoid rtl8723e_dm_watchdog(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tbool fw_current_inpsmode = false;\n\tbool fw_ps_awake = true;\n\trtlpriv->cfg->ops->get_hw_reg(hw, HW_VAR_FW_PSMODE_STATUS,\n\t\t\t\t      (u8 *)(&fw_current_inpsmode));\n\trtlpriv->cfg->ops->get_hw_reg(hw, HW_VAR_FWLPS_RF_ON,\n\t\t\t\t      (u8 *)(&fw_ps_awake));\n\n\tif (ppsc->p2p_ps_info.p2p_ps_mode)\n\t\tfw_ps_awake = false;\n\n\tspin_lock(&rtlpriv->locks.rf_ps_lock);\n\tif ((ppsc->rfpwr_state == ERFON) &&\n\t    ((!fw_current_inpsmode) && fw_ps_awake) &&\n\t    (!ppsc->rfchange_inprogress)) {\n\t\trtl8723e_dm_pwdb_monitor(hw);\n\t\trtl8723e_dm_dig(hw);\n\t\trtl8723e_dm_false_alarm_counter_statistics(hw);\n\t\trtl8723e_dm_dynamic_bb_powersaving(hw);\n\t\trtl8723e_dm_dynamic_txpower(hw);\n\t\trtl8723e_dm_check_txpower_tracking(hw);\n\t\trtl8723e_dm_refresh_rate_adaptive_mask(hw);\n\t\trtl8723e_dm_bt_coexist(hw);\n\t\trtl8723e_dm_check_edca_turbo(hw);\n\t}\n\tspin_unlock(&rtlpriv->locks.rf_ps_lock);\n\tif (rtlpriv->btcoexist.init_set)\n\t\trtl_write_byte(rtlpriv, 0x76e, 0xc);\n}\n\nstatic void rtl8723e_dm_init_bt_coexist(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtlpriv->btcoexist.bt_rfreg_origin_1e\n\t\t= rtl_get_rfreg(hw, (enum radio_path)0, RF_RCK1, 0xfffff);\n\trtlpriv->btcoexist.bt_rfreg_origin_1f\n\t\t= rtl_get_rfreg(hw, (enum radio_path)0, RF_RCK2, 0xf0);\n\n\trtlpriv->btcoexist.cstate = 0;\n\trtlpriv->btcoexist.previous_state = 0;\n\trtlpriv->btcoexist.cstate_h = 0;\n\trtlpriv->btcoexist.previous_state_h = 0;\n\trtlpriv->btcoexist.lps_counter = 0;\n\n\t \n\trtl_write_byte(rtlpriv, 0x76e, 0x4);\n\trtl_write_byte(rtlpriv, 0x778, 0x3);\n\trtl_write_byte(rtlpriv, 0x40, 0x20);\n\n\trtlpriv->btcoexist.init_set = true;\n}\n\nvoid rtl8723e_dm_bt_coexist(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 tmp_byte = 0;\n\tif (!rtlpriv->btcoexist.bt_coexistence) {\n\t\trtl_dbg(rtlpriv, COMP_BT_COEXIST, DBG_LOUD,\n\t\t\t\"[DM]{BT], BT not exist!!\\n\");\n\t\treturn;\n\t}\n\n\tif (!rtlpriv->btcoexist.init_set) {\n\t\trtl_dbg(rtlpriv, COMP_BT_COEXIST, DBG_LOUD,\n\t\t\t\"[DM][BT], %s\\n\", __func__);\n\t\trtl8723e_dm_init_bt_coexist(hw);\n\t}\n\n\ttmp_byte = rtl_read_byte(rtlpriv, 0x40);\n\trtl_dbg(rtlpriv, COMP_BT_COEXIST, DBG_LOUD,\n\t\t\"[DM][BT], 0x40 is 0x%x\\n\", tmp_byte);\n\trtl_dbg(rtlpriv, COMP_BT_COEXIST, DBG_DMESG,\n\t\t\"[DM][BT], bt_dm_coexist start\\n\");\n\trtl8723e_dm_bt_coexist_8723(hw);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}