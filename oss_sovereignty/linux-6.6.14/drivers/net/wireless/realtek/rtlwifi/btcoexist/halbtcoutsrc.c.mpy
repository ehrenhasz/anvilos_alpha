{
  "module_name": "halbtcoutsrc.c",
  "hash_id": "2a9f30e38689078906c9c524f10c02fb8109eb76ae4714f96800697a04cc98a8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtlwifi/btcoexist/halbtcoutsrc.c",
  "human_readable_source": "\n \n\n#include \"halbt_precomp.h\"\n\n \n\nstatic const char *const gl_btc_wifi_bw_string[] = {\n\t\"11bg\",\n\t\"HT20\",\n\t\"HT40\",\n\t\"HT80\",\n\t\"HT160\"\n};\n\nstatic const char *const gl_btc_wifi_freq_string[] = {\n\t\"2.4G\",\n\t\"5G\"\n};\n\nstatic bool halbtc_is_bt_coexist_available(struct btc_coexist *btcoexist)\n{\n\tif (!btcoexist->binded || NULL == btcoexist->adapter)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool halbtc_is_wifi_busy(struct rtl_priv *rtlpriv)\n{\n\tif (rtlpriv->link_info.busytraffic)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic void halbtc_dbg_init(void)\n{\n}\n\n \nstatic bool is_any_client_connect_to_ap(struct btc_coexist *btcoexist)\n{\n\tstruct rtl_priv *rtlpriv = btcoexist->adapter;\n\tstruct rtl_mac *mac = rtl_mac(rtlpriv);\n\tbool ret = false;\n\n\tif (mac->opmode == NL80211_IFTYPE_ADHOC ||\n\t    mac->opmode == NL80211_IFTYPE_MESH_POINT ||\n\t    mac->opmode == NL80211_IFTYPE_AP) {\n\t\tspin_lock_bh(&rtlpriv->locks.entry_list_lock);\n\t\tif (!list_empty(&rtlpriv->entry_list))\n\t\t\tret = true;\n\t\tspin_unlock_bh(&rtlpriv->locks.entry_list_lock);\n\t}\n\treturn ret;\n}\n\nstatic bool halbtc_legacy(struct rtl_priv *adapter)\n{\n\tstruct rtl_priv *rtlpriv = adapter;\n\tstruct rtl_mac *mac = rtl_mac(rtlpriv);\n\n\tbool is_legacy = false;\n\n\tif ((mac->mode == WIRELESS_MODE_B) || (mac->mode == WIRELESS_MODE_G))\n\t\tis_legacy = true;\n\n\treturn is_legacy;\n}\n\nbool halbtc_is_wifi_uplink(struct rtl_priv *adapter)\n{\n\tstruct rtl_priv *rtlpriv = adapter;\n\n\tif (rtlpriv->link_info.tx_busy_traffic)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nstatic u32 halbtc_get_wifi_bw(struct btc_coexist *btcoexist)\n{\n\tstruct rtl_priv *rtlpriv = btcoexist->adapter;\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\tu32 wifi_bw = BTC_WIFI_BW_HT20;\n\n\tif (halbtc_legacy(rtlpriv)) {\n\t\twifi_bw = BTC_WIFI_BW_LEGACY;\n\t} else {\n\t\tswitch (rtlphy->current_chan_bw) {\n\t\tcase HT_CHANNEL_WIDTH_20:\n\t\t\twifi_bw = BTC_WIFI_BW_HT20;\n\t\t\tbreak;\n\t\tcase HT_CHANNEL_WIDTH_20_40:\n\t\t\twifi_bw = BTC_WIFI_BW_HT40;\n\t\t\tbreak;\n\t\tcase HT_CHANNEL_WIDTH_80:\n\t\t\twifi_bw = BTC_WIFI_BW_HT80;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn wifi_bw;\n}\n\nstatic u8 halbtc_get_wifi_central_chnl(struct btc_coexist *btcoexist)\n{\n\tstruct rtl_priv *rtlpriv = btcoexist->adapter;\n\tstruct rtl_phy\t*rtlphy = &(rtlpriv->phy);\n\tu8 chnl = 1;\n\n\tif (rtlphy->current_channel != 0)\n\t\tchnl = rtlphy->current_channel;\n\trtl_dbg(rtlpriv, COMP_BT_COEXIST, DBG_LOUD,\n\t\t\"%s:%d\\n\", __func__, chnl);\n\treturn chnl;\n}\n\nstatic u8 rtl_get_hwpg_single_ant_path(struct rtl_priv *rtlpriv)\n{\n\treturn rtlpriv->btcoexist.btc_info.single_ant_path;\n}\n\nstatic u8 rtl_get_hwpg_bt_type(struct rtl_priv *rtlpriv)\n{\n\treturn rtlpriv->btcoexist.btc_info.bt_type;\n}\n\nstatic u8 rtl_get_hwpg_ant_num(struct rtl_priv *rtlpriv)\n{\n\tu8 num;\n\n\tif (rtlpriv->btcoexist.btc_info.ant_num == ANT_X2)\n\t\tnum = 2;\n\telse\n\t\tnum = 1;\n\n\treturn num;\n}\n\nstatic u8 rtl_get_hwpg_package_type(struct rtl_priv *rtlpriv)\n{\n\tstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\n\n\treturn rtlhal->package_type;\n}\n\nstatic\nu8 rtl_get_hwpg_rfe_type(struct rtl_priv *rtlpriv)\n{\n\tstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\n\n\treturn rtlhal->rfe_type;\n}\n\nstatic\nbool halbtc_is_hw_mailbox_exist(struct btc_coexist *btcoexist)\n{\n\tif (IS_HARDWARE_TYPE_8812(btcoexist->adapter))\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n\nstatic\nbool halbtc_send_bt_mp_operation(struct btc_coexist *btcoexist, u8 op_code,\n\t\t\t\t u8 *cmd, u32 len, unsigned long wait_ms)\n{\n\tstruct rtl_priv *rtlpriv;\n\tconst u8 oper_ver = 0;\n\tu8 req_num;\n\n\tif (!halbtc_is_hw_mailbox_exist(btcoexist))\n\t\treturn false;\n\n\tif (wait_ms)\t \n\t\treinit_completion(&btcoexist->bt_mp_comp);\n\n\trtlpriv = btcoexist->adapter;\n\n\t \n\tswitch (op_code) {\n\tcase BT_OP_GET_BT_VERSION:\n\t\treq_num = BT_SEQ_GET_BT_VERSION;\n\t\tbreak;\n\tcase BT_OP_GET_AFH_MAP_L:\n\t\treq_num = BT_SEQ_GET_AFH_MAP_L;\n\t\tbreak;\n\tcase BT_OP_GET_AFH_MAP_M:\n\t\treq_num = BT_SEQ_GET_AFH_MAP_M;\n\t\tbreak;\n\tcase BT_OP_GET_AFH_MAP_H:\n\t\treq_num = BT_SEQ_GET_AFH_MAP_H;\n\t\tbreak;\n\tcase BT_OP_GET_BT_COEX_SUPPORTED_FEATURE:\n\t\treq_num = BT_SEQ_GET_BT_COEX_SUPPORTED_FEATURE;\n\t\tbreak;\n\tcase BT_OP_GET_BT_COEX_SUPPORTED_VERSION:\n\t\treq_num = BT_SEQ_GET_BT_COEX_SUPPORTED_VERSION;\n\t\tbreak;\n\tcase BT_OP_GET_BT_ANT_DET_VAL:\n\t\treq_num = BT_SEQ_GET_BT_ANT_DET_VAL;\n\t\tbreak;\n\tcase BT_OP_GET_BT_BLE_SCAN_PARA:\n\t\treq_num = BT_SEQ_GET_BT_BLE_SCAN_PARA;\n\t\tbreak;\n\tcase BT_OP_GET_BT_BLE_SCAN_TYPE:\n\t\treq_num = BT_SEQ_GET_BT_BLE_SCAN_TYPE;\n\t\tbreak;\n\tcase BT_OP_GET_BT_DEVICE_INFO:\n\t\treq_num = BT_SEQ_GET_BT_DEVICE_INFO;\n\t\tbreak;\n\tcase BT_OP_GET_BT_FORBIDDEN_SLOT_VAL:\n\t\treq_num = BT_SEQ_GET_BT_FORB_SLOT_VAL;\n\t\tbreak;\n\tcase BT_OP_WRITE_REG_ADDR:\n\tcase BT_OP_WRITE_REG_VALUE:\n\tcase BT_OP_READ_REG:\n\tdefault:\n\t\treq_num = BT_SEQ_DONT_CARE;\n\t\tbreak;\n\t}\n\n\tcmd[0] |= (oper_ver & 0x0f);\t\t \n\tcmd[0] |= ((req_num << 4) & 0xf0);\t \n\tcmd[1] = op_code;\n\trtlpriv->cfg->ops->fill_h2c_cmd(rtlpriv->mac80211.hw, 0x67, len, cmd);\n\n\t \n\tif (!wait_ms)\n\t\treturn true;\n\n\trtl_dbg(rtlpriv, COMP_BT_COEXIST, DBG_LOUD,\n\t\t\"btmpinfo wait req_num=%d wait=%ld\\n\", req_num, wait_ms);\n\n\tif (wait_for_completion_timeout(&btcoexist->bt_mp_comp,\n\t\t\t\t\tmsecs_to_jiffies(wait_ms)) == 0) {\n\t\trtl_dbg(rtlpriv, COMP_BT_COEXIST, DBG_DMESG,\n\t\t\t\"btmpinfo wait (req_num=%d) timeout\\n\", req_num);\n\n\t\treturn false;\t \n\t}\n\n\treturn true;\n}\n\nstatic void halbtc_leave_lps(struct btc_coexist *btcoexist)\n{\n\tstruct rtl_priv *rtlpriv;\n\tbool ap_enable = false;\n\n\trtlpriv = btcoexist->adapter;\n\n\tbtcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,\n\t\t\t   &ap_enable);\n\n\tif (ap_enable) {\n\t\trtl_dbg(rtlpriv, COMP_BT_COEXIST, DBG_DMESG,\n\t\t\t\"%s()<--dont leave lps under AP mode\\n\", __func__);\n\t\treturn;\n\t}\n\n\tbtcoexist->bt_info.bt_ctrl_lps = true;\n\tbtcoexist->bt_info.bt_lps_on = false;\n\t \n\trtl_lps_leave(rtlpriv->mac80211.hw, false);\n}\n\nstatic void halbtc_enter_lps(struct btc_coexist *btcoexist)\n{\n\tstruct rtl_priv *rtlpriv;\n\tbool ap_enable = false;\n\n\trtlpriv = btcoexist->adapter;\n\n\tbtcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_AP_MODE_ENABLE,\n\t\t\t   &ap_enable);\n\n\tif (ap_enable) {\n\t\trtl_dbg(rtlpriv, COMP_BT_COEXIST, DBG_DMESG,\n\t\t\t\"%s()<--dont enter lps under AP mode\\n\", __func__);\n\t\treturn;\n\t}\n\n\tbtcoexist->bt_info.bt_ctrl_lps = true;\n\tbtcoexist->bt_info.bt_lps_on = true;\n\t \n\trtl_lps_enter(rtlpriv->mac80211.hw, false);\n}\n\nstatic void halbtc_normal_lps(struct btc_coexist *btcoexist)\n{\n\tstruct rtl_priv *rtlpriv;\n\n\trtlpriv = btcoexist->adapter;\n\n\tif (btcoexist->bt_info.bt_ctrl_lps) {\n\t\tbtcoexist->bt_info.bt_lps_on = false;\n\t\t \n\t\trtl_lps_leave(rtlpriv->mac80211.hw, false);\n\t\tbtcoexist->bt_info.bt_ctrl_lps = false;\n\t}\n}\n\nstatic void halbtc_pre_normal_lps(struct btc_coexist *btcoexist)\n{\n\tstruct rtl_priv *rtlpriv = btcoexist->adapter;\n\n\tif (btcoexist->bt_info.bt_ctrl_lps) {\n\t\tbtcoexist->bt_info.bt_lps_on = false;\n\t\t \n\t\trtl_lps_leave(rtlpriv->mac80211.hw, false);\n\t}\n}\n\nstatic void halbtc_post_normal_lps(struct btc_coexist *btcoexist)\n{\n\tif (btcoexist->bt_info.bt_ctrl_lps)\n\t\tbtcoexist->bt_info.bt_ctrl_lps = false;\n}\n\nstatic void halbtc_leave_low_power(struct btc_coexist *btcoexist)\n{\n}\n\nstatic void halbtc_normal_low_power(struct btc_coexist *btcoexist)\n{\n}\n\nstatic void halbtc_disable_low_power(struct btc_coexist *btcoexist,\n\t\t\t\t     bool low_pwr_disable)\n{\n\t \n\tbtcoexist->bt_info.bt_disable_low_pwr = low_pwr_disable;\n}\n\nstatic void halbtc_aggregation_check(struct btc_coexist *btcoexist)\n{\n\tbool need_to_act = false;\n\tstatic unsigned long pre_time;\n\tunsigned long cur_time = 0;\n\tstruct rtl_priv *rtlpriv = btcoexist->adapter;\n\n\t \n\n\tcur_time = jiffies;\n\tif (jiffies_to_msecs(cur_time - pre_time) <= 8000) {\n\t\t \n\t\treturn;\n\t}\n\tpre_time = cur_time;\n\n\tif (btcoexist->bt_info.reject_agg_pkt) {\n\t\tneed_to_act = true;\n\t\tbtcoexist->bt_info.pre_reject_agg_pkt =\n\t\t\tbtcoexist->bt_info.reject_agg_pkt;\n\t} else {\n\t\tif (btcoexist->bt_info.pre_reject_agg_pkt) {\n\t\t\tneed_to_act = true;\n\t\t\tbtcoexist->bt_info.pre_reject_agg_pkt =\n\t\t\t\tbtcoexist->bt_info.reject_agg_pkt;\n\t\t}\n\n\t\tif (btcoexist->bt_info.pre_bt_ctrl_agg_buf_size !=\n\t\t    btcoexist->bt_info.bt_ctrl_agg_buf_size) {\n\t\t\tneed_to_act = true;\n\t\t\tbtcoexist->bt_info.pre_bt_ctrl_agg_buf_size =\n\t\t\t\tbtcoexist->bt_info.bt_ctrl_agg_buf_size;\n\t\t}\n\n\t\tif (btcoexist->bt_info.bt_ctrl_agg_buf_size) {\n\t\t\tif (btcoexist->bt_info.pre_agg_buf_size !=\n\t\t\t    btcoexist->bt_info.agg_buf_size) {\n\t\t\t\tneed_to_act = true;\n\t\t\t}\n\t\t\tbtcoexist->bt_info.pre_agg_buf_size =\n\t\t\t\tbtcoexist->bt_info.agg_buf_size;\n\t\t}\n\n\t\tif (need_to_act)\n\t\t\trtl_rx_ampdu_apply(rtlpriv);\n\t}\n}\n\nstatic u32 halbtc_get_bt_patch_version(struct btc_coexist *btcoexist)\n{\n\tu8 cmd_buffer[4] = {0};\n\n\tif (btcoexist->bt_info.bt_real_fw_ver)\n\t\tgoto label_done;\n\n\t \n\thalbtc_send_bt_mp_operation(btcoexist, BT_OP_GET_BT_VERSION,\n\t\t\t\t    cmd_buffer, 4, 200);\n\nlabel_done:\n\treturn btcoexist->bt_info.bt_real_fw_ver;\n}\n\nstatic u32 halbtc_get_bt_coex_supported_feature(void *btc_context)\n{\n\tstruct btc_coexist *btcoexist = (struct btc_coexist *)btc_context;\n\tu8 cmd_buffer[4] = {0};\n\n\tif (btcoexist->bt_info.bt_supported_feature)\n\t\tgoto label_done;\n\n\t \n\thalbtc_send_bt_mp_operation(btcoexist,\n\t\t\t\t    BT_OP_GET_BT_COEX_SUPPORTED_FEATURE,\n\t\t\t\t    cmd_buffer, 4, 200);\n\nlabel_done:\n\treturn btcoexist->bt_info.bt_supported_feature;\n}\n\nstatic u32 halbtc_get_bt_coex_supported_version(void *btc_context)\n{\n\tstruct btc_coexist *btcoexist = (struct btc_coexist *)btc_context;\n\tu8 cmd_buffer[4] = {0};\n\n\tif (btcoexist->bt_info.bt_supported_version)\n\t\tgoto label_done;\n\n\t \n\thalbtc_send_bt_mp_operation(btcoexist,\n\t\t\t\t    BT_OP_GET_BT_COEX_SUPPORTED_VERSION,\n\t\t\t\t    cmd_buffer, 4, 200);\n\nlabel_done:\n\treturn btcoexist->bt_info.bt_supported_version;\n}\n\nstatic u32 halbtc_get_bt_device_info(void *btc_context)\n{\n\tstruct btc_coexist *btcoexist = (struct btc_coexist *)btc_context;\n\tu8 cmd_buffer[4] = {0};\n\n\t \n\thalbtc_send_bt_mp_operation(btcoexist,\n\t\t\t\t    BT_OP_GET_BT_DEVICE_INFO,\n\t\t\t\t    cmd_buffer, 4, 200);\n\n\treturn btcoexist->bt_info.bt_device_info;\n}\n\nstatic u32 halbtc_get_bt_forbidden_slot_val(void *btc_context)\n{\n\tstruct btc_coexist *btcoexist = (struct btc_coexist *)btc_context;\n\tu8 cmd_buffer[4] = {0};\n\n\t \n\thalbtc_send_bt_mp_operation(btcoexist,\n\t\t\t\t    BT_OP_GET_BT_FORBIDDEN_SLOT_VAL,\n\t\t\t\t    cmd_buffer, 4, 200);\n\n\treturn btcoexist->bt_info.bt_forb_slot_val;\n}\n\nstatic u32 halbtc_get_wifi_link_status(struct btc_coexist *btcoexist)\n{\n\t \n\tstruct rtl_priv *rtlpriv = btcoexist->adapter;\n\tstruct rtl_mac *mac = rtl_mac(rtlpriv);\n\tu32 ret_val = 0;\n\tu32 port_connected_status = 0, num_of_connected_port = 0;\n\n\tif (mac->opmode == NL80211_IFTYPE_STATION &&\n\t    mac->link_state >= MAC80211_LINKED) {\n\t\tport_connected_status |= WIFI_STA_CONNECTED;\n\t\tnum_of_connected_port++;\n\t}\n\t \n\tif (is_any_client_connect_to_ap(btcoexist)) {\n\t\tport_connected_status |= WIFI_AP_CONNECTED;\n\t\tnum_of_connected_port++;\n\t}\n\t \n\n\tret_val = (num_of_connected_port << 16) | port_connected_status;\n\n\treturn ret_val;\n}\n\nstatic s32 halbtc_get_wifi_rssi(struct rtl_priv *rtlpriv)\n{\n\treturn rtlpriv->dm.undec_sm_pwdb;\n}\n\nstatic bool halbtc_get(void *void_btcoexist, u8 get_type, void *out_buf)\n{\n\tstruct btc_coexist *btcoexist = (struct btc_coexist *)void_btcoexist;\n\tstruct rtl_priv *rtlpriv = btcoexist->adapter;\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct rtl_mac *mac = rtl_mac(rtlpriv);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\n\tbool *bool_tmp = (bool *)out_buf;\n\tint *s32_tmp = (int *)out_buf;\n\tu32 *u32_tmp = (u32 *)out_buf;\n\tu8 *u8_tmp = (u8 *)out_buf;\n\tbool tmp = false;\n\tbool ret = true;\n\n\tif (!halbtc_is_bt_coexist_available(btcoexist))\n\t\treturn false;\n\n\tswitch (get_type) {\n\tcase BTC_GET_BL_HS_OPERATION:\n\t\t*bool_tmp = false;\n\t\tret = false;\n\t\tbreak;\n\tcase BTC_GET_BL_HS_CONNECTING:\n\t\t*bool_tmp = false;\n\t\tret = false;\n\t\tbreak;\n\tcase BTC_GET_BL_WIFI_CONNECTED:\n\t\tif (rtlpriv->mac80211.opmode == NL80211_IFTYPE_STATION &&\n\t\t    rtlpriv->mac80211.link_state >= MAC80211_LINKED)\n\t\t\ttmp = true;\n\t\tif (is_any_client_connect_to_ap(btcoexist))\n\t\t\ttmp = true;\n\t\t*bool_tmp = tmp;\n\t\tbreak;\n\tcase BTC_GET_BL_WIFI_DUAL_BAND_CONNECTED:\n\t\t*u8_tmp = BTC_MULTIPORT_SCC;\n\t\tbreak;\n\tcase BTC_GET_BL_WIFI_BUSY:\n\t\tif (halbtc_is_wifi_busy(rtlpriv))\n\t\t\t*bool_tmp = true;\n\t\telse\n\t\t\t*bool_tmp = false;\n\t\tbreak;\n\tcase BTC_GET_BL_WIFI_SCAN:\n\t\tif (mac->act_scanning)\n\t\t\t*bool_tmp = true;\n\t\telse\n\t\t\t*bool_tmp = false;\n\t\tbreak;\n\tcase BTC_GET_BL_WIFI_LINK:\n\t\tif (mac->link_state == MAC80211_LINKING)\n\t\t\t*bool_tmp = true;\n\t\telse\n\t\t\t*bool_tmp = false;\n\t\tbreak;\n\tcase BTC_GET_BL_WIFI_ROAM:\n\t\tif (mac->link_state == MAC80211_LINKING)\n\t\t\t*bool_tmp = true;\n\t\telse\n\t\t\t*bool_tmp = false;\n\t\tbreak;\n\tcase BTC_GET_BL_WIFI_4_WAY_PROGRESS:\n\t\t*bool_tmp = rtlpriv->btcoexist.btc_info.in_4way;\n\t\tbreak;\n\tcase BTC_GET_BL_WIFI_UNDER_5G:\n\t\tif (rtlhal->current_bandtype == BAND_ON_5G)\n\t\t\t*bool_tmp = true;\n\t\telse\n\t\t\t*bool_tmp = false;\n\t\tbreak;\n\tcase BTC_GET_BL_WIFI_AP_MODE_ENABLE:\n\t\tif (mac->opmode == NL80211_IFTYPE_AP)\n\t\t\t*bool_tmp = true;\n\t\telse\n\t\t\t*bool_tmp = false;\n\t\tbreak;\n\tcase BTC_GET_BL_WIFI_ENABLE_ENCRYPTION:\n\t\tif (NO_ENCRYPTION == rtlpriv->sec.pairwise_enc_algorithm)\n\t\t\t*bool_tmp = false;\n\t\telse\n\t\t\t*bool_tmp = true;\n\t\tbreak;\n\tcase BTC_GET_BL_WIFI_UNDER_B_MODE:\n\t\tif (rtlpriv->mac80211.mode == WIRELESS_MODE_B)\n\t\t\t*bool_tmp = true;\n\t\telse\n\t\t\t*bool_tmp = false;\n\t\tbreak;\n\tcase BTC_GET_BL_EXT_SWITCH:\n\t\t*bool_tmp = false;\n\t\tbreak;\n\tcase BTC_GET_BL_WIFI_IS_IN_MP_MODE:\n\t\t*bool_tmp = false;\n\t\tbreak;\n\tcase BTC_GET_BL_IS_ASUS_8723B:\n\t\t*bool_tmp = false;\n\t\tbreak;\n\tcase BTC_GET_BL_RF4CE_CONNECTED:\n\t\t*bool_tmp = false;\n\t\tbreak;\n\tcase BTC_GET_S4_WIFI_RSSI:\n\t\t*s32_tmp = halbtc_get_wifi_rssi(rtlpriv);\n\t\tbreak;\n\tcase BTC_GET_S4_HS_RSSI:\n\t\t*s32_tmp = 0;\n\t\tret = false;\n\t\tbreak;\n\tcase BTC_GET_U4_WIFI_BW:\n\t\t*u32_tmp = halbtc_get_wifi_bw(btcoexist);\n\t\tbreak;\n\tcase BTC_GET_U4_WIFI_TRAFFIC_DIRECTION:\n\t\tif (halbtc_is_wifi_uplink(rtlpriv))\n\t\t\t*u32_tmp = BTC_WIFI_TRAFFIC_TX;\n\t\telse\n\t\t\t*u32_tmp = BTC_WIFI_TRAFFIC_RX;\n\t\tbreak;\n\tcase BTC_GET_U4_WIFI_FW_VER:\n\t\t*u32_tmp = (rtlhal->fw_version << 16) | rtlhal->fw_subversion;\n\t\tbreak;\n\tcase BTC_GET_U4_WIFI_LINK_STATUS:\n\t\t*u32_tmp = halbtc_get_wifi_link_status(btcoexist);\n\t\tbreak;\n\tcase BTC_GET_U4_BT_PATCH_VER:\n\t\t*u32_tmp = halbtc_get_bt_patch_version(btcoexist);\n\t\tbreak;\n\tcase BTC_GET_U4_VENDOR:\n\t\t*u32_tmp = BTC_VENDOR_OTHER;\n\t\tbreak;\n\tcase BTC_GET_U4_SUPPORTED_VERSION:\n\t\t*u32_tmp = halbtc_get_bt_coex_supported_version(btcoexist);\n\t\tbreak;\n\tcase BTC_GET_U4_SUPPORTED_FEATURE:\n\t\t*u32_tmp = halbtc_get_bt_coex_supported_feature(btcoexist);\n\t\tbreak;\n\tcase BTC_GET_U4_BT_DEVICE_INFO:\n\t\t*u32_tmp = halbtc_get_bt_device_info(btcoexist);\n\t\tbreak;\n\tcase BTC_GET_U4_BT_FORBIDDEN_SLOT_VAL:\n\t\t*u32_tmp = halbtc_get_bt_forbidden_slot_val(btcoexist);\n\t\tbreak;\n\tcase BTC_GET_U4_WIFI_IQK_TOTAL:\n\t\t*u32_tmp =\n\t\t\tbtcoexist->btc_phydm_query_phy_counter(btcoexist,\n\t\t\t\t\t\t\t       DM_INFO_IQK_ALL);\n\t\tbreak;\n\tcase BTC_GET_U4_WIFI_IQK_OK:\n\t\t*u32_tmp =\n\t\t\tbtcoexist->btc_phydm_query_phy_counter(btcoexist,\n\t\t\t\t\t\t\t       DM_INFO_IQK_OK);\n\t\tbreak;\n\tcase BTC_GET_U4_WIFI_IQK_FAIL:\n\t\t*u32_tmp =\n\t\t\tbtcoexist->btc_phydm_query_phy_counter(btcoexist,\n\t\t\t\t\t\t\t       DM_INFO_IQK_NG);\n\t\tbreak;\n\tcase BTC_GET_U1_WIFI_DOT11_CHNL:\n\t\t*u8_tmp = rtlphy->current_channel;\n\t\tbreak;\n\tcase BTC_GET_U1_WIFI_CENTRAL_CHNL:\n\t\t*u8_tmp = halbtc_get_wifi_central_chnl(btcoexist);\n\t\tbreak;\n\tcase BTC_GET_U1_WIFI_HS_CHNL:\n\t\t*u8_tmp = 0;\n\t\tret = false;\n\t\tbreak;\n\tcase BTC_GET_U1_AP_NUM:\n\t\t*u8_tmp = rtlpriv->btcoexist.btc_info.ap_num;\n\t\tbreak;\n\tcase BTC_GET_U1_ANT_TYPE:\n\t\t*u8_tmp = (u8)BTC_ANT_TYPE_0;\n\t\tbreak;\n\tcase BTC_GET_U1_IOT_PEER:\n\t\t*u8_tmp = 0;\n\t\tbreak;\n\n\t\t \n\tcase BTC_GET_U1_LPS_MODE:\n\t\t*u8_tmp = btcoexist->pwr_mode_val[0];\n\t\tbreak;\n\n\tdefault:\n\t\tret = false;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic bool halbtc_set(void *void_btcoexist, u8 set_type, void *in_buf)\n{\n\tstruct btc_coexist *btcoexist = (struct btc_coexist *)void_btcoexist;\n\tbool *bool_tmp = (bool *)in_buf;\n\tu8 *u8_tmp = (u8 *)in_buf;\n\tu32 *u32_tmp = (u32 *)in_buf;\n\tbool ret = true;\n\n\tif (!halbtc_is_bt_coexist_available(btcoexist))\n\t\treturn false;\n\n\tswitch (set_type) {\n\t \n\tcase BTC_SET_BL_BT_DISABLE:\n\t\tbtcoexist->bt_info.bt_disabled = *bool_tmp;\n\t\tbreak;\n\tcase BTC_SET_BL_BT_TRAFFIC_BUSY:\n\t\tbtcoexist->bt_info.bt_busy = *bool_tmp;\n\t\tbreak;\n\tcase BTC_SET_BL_BT_LIMITED_DIG:\n\t\tbtcoexist->bt_info.limited_dig = *bool_tmp;\n\t\tbreak;\n\tcase BTC_SET_BL_FORCE_TO_ROAM:\n\t\tbtcoexist->bt_info.force_to_roam = *bool_tmp;\n\t\tbreak;\n\tcase BTC_SET_BL_TO_REJ_AP_AGG_PKT:\n\t\tbtcoexist->bt_info.reject_agg_pkt = *bool_tmp;\n\t\tbreak;\n\tcase BTC_SET_BL_BT_CTRL_AGG_SIZE:\n\t\tbtcoexist->bt_info.bt_ctrl_agg_buf_size = *bool_tmp;\n\t\tbreak;\n\tcase BTC_SET_BL_INC_SCAN_DEV_NUM:\n\t\tbtcoexist->bt_info.increase_scan_dev_num = *bool_tmp;\n\t\tbreak;\n\tcase BTC_SET_BL_BT_TX_RX_MASK:\n\t\tbtcoexist->bt_info.bt_tx_rx_mask = *bool_tmp;\n\t\tbreak;\n\tcase BTC_SET_BL_MIRACAST_PLUS_BT:\n\t\tbtcoexist->bt_info.miracast_plus_bt = *bool_tmp;\n\t\tbreak;\n\t\t \n\tcase BTC_SET_U1_RSSI_ADJ_VAL_FOR_AGC_TABLE_ON:\n\t\tbtcoexist->bt_info.rssi_adjust_for_agc_table_on = *u8_tmp;\n\t\tbreak;\n\tcase BTC_SET_U1_AGG_BUF_SIZE:\n\t\tbtcoexist->bt_info.agg_buf_size = *u8_tmp;\n\t\tbreak;\n\n\t \n\tcase BTC_SET_ACT_GET_BT_RSSI:\n\t\tret = false;\n\t\tbreak;\n\tcase BTC_SET_ACT_AGGREGATE_CTRL:\n\t\thalbtc_aggregation_check(btcoexist);\n\t\tbreak;\n\n\t \n\tcase BTC_SET_U1_RSSI_ADJ_VAL_FOR_1ANT_COEX_TYPE:\n\t\tbtcoexist->bt_info.rssi_adjust_for_1ant_coex_type = *u8_tmp;\n\t\tbreak;\n\tcase BTC_SET_UI_SCAN_SIG_COMPENSATION:\n\t\tbreak;\n\tcase BTC_SET_U1_LPS_VAL:\n\t\tbtcoexist->bt_info.lps_val = *u8_tmp;\n\t\tbreak;\n\tcase BTC_SET_U1_RPWM_VAL:\n\t\tbtcoexist->bt_info.rpwm_val = *u8_tmp;\n\t\tbreak;\n\t \n\tcase BTC_SET_ACT_LEAVE_LPS:\n\t\thalbtc_leave_lps(btcoexist);\n\t\tbreak;\n\tcase BTC_SET_ACT_ENTER_LPS:\n\t\thalbtc_enter_lps(btcoexist);\n\t\tbreak;\n\tcase BTC_SET_ACT_NORMAL_LPS:\n\t\thalbtc_normal_lps(btcoexist);\n\t\tbreak;\n\tcase BTC_SET_ACT_PRE_NORMAL_LPS:\n\t\thalbtc_pre_normal_lps(btcoexist);\n\t\tbreak;\n\tcase BTC_SET_ACT_POST_NORMAL_LPS:\n\t\thalbtc_post_normal_lps(btcoexist);\n\t\tbreak;\n\tcase BTC_SET_ACT_DISABLE_LOW_POWER:\n\t\thalbtc_disable_low_power(btcoexist, *bool_tmp);\n\t\tbreak;\n\tcase BTC_SET_ACT_UPDATE_RAMASK:\n\t\tbtcoexist->bt_info.ra_mask = *u32_tmp;\n\t\tbreak;\n\tcase BTC_SET_ACT_SEND_MIMO_PS:\n\t\tbreak;\n\tcase BTC_SET_ACT_CTRL_BT_INFO:  \n\t\tbreak;\n\tcase BTC_SET_ACT_CTRL_BT_COEX:\n\t\tbreak;\n\tcase BTC_SET_ACT_CTRL_8723B_ANT:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic void halbtc_display_coex_statistics(struct btc_coexist *btcoexist,\n\t\t\t\t\t   struct seq_file *m)\n{\n}\n\nstatic void halbtc_display_bt_link_info(struct btc_coexist *btcoexist,\n\t\t\t\t\tstruct seq_file *m)\n{\n}\n\nstatic void halbtc_display_wifi_status(struct btc_coexist *btcoexist,\n\t\t\t\t       struct seq_file *m)\n{\n\tstruct rtl_priv *rtlpriv = btcoexist->adapter;\n\ts32 wifi_rssi = 0, bt_hs_rssi = 0;\n\tbool scan = false, link = false, roam = false, wifi_busy = false;\n\tbool wifi_under_b_mode = false;\n\tbool wifi_under_5g = false;\n\tu32 wifi_bw = BTC_WIFI_BW_HT20;\n\tu32 wifi_traffic_dir = BTC_WIFI_TRAFFIC_TX;\n\tu32 wifi_freq = BTC_FREQ_2_4G;\n\tu32 wifi_link_status = 0x0;\n\tbool bt_hs_on = false, under_ips = false, under_lps = false;\n\tbool low_power = false, dc_mode = false;\n\tu8 wifi_chnl = 0, wifi_hs_chnl = 0;\n\tu8 ap_num = 0;\n\n\twifi_link_status = halbtc_get_wifi_link_status(btcoexist);\n\tseq_printf(m, \"\\n %-35s = %d/ %d/ %d/ %d/ %d\",\n\t\t   \"STA/vWifi/HS/p2pGo/p2pGc\",\n\t\t   ((wifi_link_status & WIFI_STA_CONNECTED) ? 1 : 0),\n\t\t   ((wifi_link_status & WIFI_AP_CONNECTED) ? 1 : 0),\n\t\t   ((wifi_link_status & WIFI_HS_CONNECTED) ? 1 : 0),\n\t\t   ((wifi_link_status & WIFI_P2P_GO_CONNECTED) ? 1 : 0),\n\t\t   ((wifi_link_status & WIFI_P2P_GC_CONNECTED) ? 1 : 0));\n\n\tbtcoexist->btc_get(btcoexist, BTC_GET_BL_HS_OPERATION, &bt_hs_on);\n\tbtcoexist->btc_get(btcoexist, BTC_GET_U1_WIFI_DOT11_CHNL, &wifi_chnl);\n\tbtcoexist->btc_get(btcoexist, BTC_GET_U1_WIFI_HS_CHNL, &wifi_hs_chnl);\n\tseq_printf(m, \"\\n %-35s = %d / %d(%d)\",\n\t\t   \"Dot11 channel / HsChnl(High Speed)\",\n\t\t   wifi_chnl, wifi_hs_chnl, bt_hs_on);\n\n\tbtcoexist->btc_get(btcoexist, BTC_GET_S4_WIFI_RSSI, &wifi_rssi);\n\tbtcoexist->btc_get(btcoexist, BTC_GET_S4_HS_RSSI, &bt_hs_rssi);\n\tseq_printf(m, \"\\n %-35s = %d/ %d\",\n\t\t   \"Wifi rssi/ HS rssi\",\n\t\t   wifi_rssi - 100, bt_hs_rssi - 100);\n\n\tbtcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_SCAN, &scan);\n\tbtcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_LINK, &link);\n\tbtcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_ROAM, &roam);\n\tseq_printf(m, \"\\n %-35s = %d/ %d/ %d \",\n\t\t   \"Wifi link/ roam/ scan\",\n\t\t   link, roam, scan);\n\n\tbtcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);\n\tbtcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_BW, &wifi_bw);\n\tbtcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_BUSY, &wifi_busy);\n\tbtcoexist->btc_get(btcoexist, BTC_GET_U4_WIFI_TRAFFIC_DIRECTION,\n\t\t\t   &wifi_traffic_dir);\n\tbtcoexist->btc_get(btcoexist, BTC_GET_U1_AP_NUM, &ap_num);\n\twifi_freq = (wifi_under_5g ? BTC_FREQ_5G : BTC_FREQ_2_4G);\n\tbtcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_B_MODE,\n\t\t\t   &wifi_under_b_mode);\n\n\tseq_printf(m, \"\\n %-35s = %s / %s/ %s/ AP=%d \",\n\t\t   \"Wifi freq/ bw/ traffic\",\n\t\t   gl_btc_wifi_freq_string[wifi_freq],\n\t\t   ((wifi_under_b_mode) ? \"11b\" :\n\t\t    gl_btc_wifi_bw_string[wifi_bw]),\n\t\t   ((!wifi_busy) ? \"idle\" : ((BTC_WIFI_TRAFFIC_TX ==\n\t\t\t\t\t      wifi_traffic_dir) ? \"uplink\" :\n\t\t\t\t\t     \"downlink\")),\n\t\t   ap_num);\n\n\t \n\tdc_mode = true;\t \n\tunder_ips = rtlpriv->psc.inactive_pwrstate == ERFOFF ? 1 : 0;\n\tunder_lps = rtlpriv->psc.dot11_psmode == EACTIVE ? 0 : 1;\n\tlow_power = 0;  \n\tseq_printf(m, \"\\n %-35s = %s%s%s%s\",\n\t\t   \"Power Status\",\n\t\t   (dc_mode ? \"DC mode\" : \"AC mode\"),\n\t\t   (under_ips ? \", IPS ON\" : \"\"),\n\t\t   (under_lps ? \", LPS ON\" : \"\"),\n\t\t   (low_power ? \", 32k\" : \"\"));\n\n\tseq_printf(m,\n\t\t   \"\\n %-35s = %6ph (0x%x/0x%x)\",\n\t\t   \"Power mode cmd(lps/rpwm)\",\n\t\t   btcoexist->pwr_mode_val,\n\t\t   btcoexist->bt_info.lps_val,\n\t\t   btcoexist->bt_info.rpwm_val);\n}\n\n \nstatic u8 halbtc_read_1byte(void *bt_context, u32 reg_addr)\n{\n\tstruct btc_coexist *btcoexist = (struct btc_coexist *)bt_context;\n\tstruct rtl_priv *rtlpriv = btcoexist->adapter;\n\n\treturn\trtl_read_byte(rtlpriv, reg_addr);\n}\n\nstatic u16 halbtc_read_2byte(void *bt_context, u32 reg_addr)\n{\n\tstruct btc_coexist *btcoexist = (struct btc_coexist *)bt_context;\n\tstruct rtl_priv *rtlpriv = btcoexist->adapter;\n\n\treturn\trtl_read_word(rtlpriv, reg_addr);\n}\n\nstatic u32 halbtc_read_4byte(void *bt_context, u32 reg_addr)\n{\n\tstruct btc_coexist *btcoexist = (struct btc_coexist *)bt_context;\n\tstruct rtl_priv *rtlpriv = btcoexist->adapter;\n\n\treturn\trtl_read_dword(rtlpriv, reg_addr);\n}\n\nstatic void halbtc_write_1byte(void *bt_context, u32 reg_addr, u32 data)\n{\n\tstruct btc_coexist *btcoexist = (struct btc_coexist *)bt_context;\n\tstruct rtl_priv *rtlpriv = btcoexist->adapter;\n\n\trtl_write_byte(rtlpriv, reg_addr, data);\n}\n\nstatic void halbtc_bitmask_write_1byte(void *bt_context, u32 reg_addr,\n\t\t\t\t       u32 bit_mask, u8 data)\n{\n\tstruct btc_coexist *btcoexist = (struct btc_coexist *)bt_context;\n\tstruct rtl_priv *rtlpriv = btcoexist->adapter;\n\tu8 original_value, bit_shift = 0;\n\tu8 i;\n\n\tif (bit_mask != MASKDWORD) { \n\t\toriginal_value = rtl_read_byte(rtlpriv, reg_addr);\n\t\tfor (i = 0; i <= 7; i++) {\n\t\t\tif ((bit_mask>>i) & 0x1)\n\t\t\t\tbreak;\n\t\t}\n\t\tbit_shift = i;\n\t\tdata = (original_value & (~bit_mask)) |\n\t\t\t((data << bit_shift) & bit_mask);\n\t}\n\trtl_write_byte(rtlpriv, reg_addr, data);\n}\n\nstatic void halbtc_write_2byte(void *bt_context, u32 reg_addr, u16 data)\n{\n\tstruct btc_coexist *btcoexist = (struct btc_coexist *)bt_context;\n\tstruct rtl_priv *rtlpriv = btcoexist->adapter;\n\n\trtl_write_word(rtlpriv, reg_addr, data);\n}\n\nstatic void halbtc_write_4byte(void *bt_context, u32 reg_addr, u32 data)\n{\n\tstruct btc_coexist *btcoexist =\n\t\t(struct btc_coexist *)bt_context;\n\tstruct rtl_priv *rtlpriv = btcoexist->adapter;\n\n\trtl_write_dword(rtlpriv, reg_addr, data);\n}\n\nstatic void halbtc_write_local_reg_1byte(void *btc_context, u32 reg_addr,\n\t\t\t\t\t u8 data)\n{\n\tstruct btc_coexist *btcoexist = (struct btc_coexist *)btc_context;\n\tstruct rtl_priv *rtlpriv = btcoexist->adapter;\n\n\tif (btcoexist->chip_interface == BTC_INTF_SDIO)\n\t\t;\n\telse if (btcoexist->chip_interface == BTC_INTF_PCI)\n\t\trtl_write_byte(rtlpriv, reg_addr, data);\n\telse if (btcoexist->chip_interface == BTC_INTF_USB)\n\t\trtl_write_byte(rtlpriv, reg_addr, data);\n}\n\nstatic void halbtc_set_bbreg(void *bt_context, u32 reg_addr, u32 bit_mask,\n\t\t\t     u32 data)\n{\n\tstruct btc_coexist *btcoexist = (struct btc_coexist *)bt_context;\n\tstruct rtl_priv *rtlpriv = btcoexist->adapter;\n\n\trtl_set_bbreg(rtlpriv->mac80211.hw, reg_addr, bit_mask, data);\n}\n\nstatic u32 halbtc_get_bbreg(void *bt_context, u32 reg_addr, u32 bit_mask)\n{\n\tstruct btc_coexist *btcoexist = (struct btc_coexist *)bt_context;\n\tstruct rtl_priv *rtlpriv = btcoexist->adapter;\n\n\treturn rtl_get_bbreg(rtlpriv->mac80211.hw, reg_addr, bit_mask);\n}\n\nstatic void halbtc_set_rfreg(void *bt_context, u8 rf_path, u32 reg_addr,\n\t\t\t     u32 bit_mask, u32 data)\n{\n\tstruct btc_coexist *btcoexist = (struct btc_coexist *)bt_context;\n\tstruct rtl_priv *rtlpriv = btcoexist->adapter;\n\n\trtl_set_rfreg(rtlpriv->mac80211.hw, rf_path, reg_addr, bit_mask, data);\n}\n\nstatic u32 halbtc_get_rfreg(void *bt_context, u8 rf_path, u32 reg_addr,\n\t\t\t    u32 bit_mask)\n{\n\tstruct btc_coexist *btcoexist = (struct btc_coexist *)bt_context;\n\tstruct rtl_priv *rtlpriv = btcoexist->adapter;\n\n\treturn rtl_get_rfreg(rtlpriv->mac80211.hw, rf_path, reg_addr, bit_mask);\n}\n\nstatic void halbtc_fill_h2c_cmd(void *bt_context, u8 element_id,\n\t\t\t\tu32 cmd_len, u8 *cmd_buf)\n{\n\tstruct btc_coexist *btcoexist = (struct btc_coexist *)bt_context;\n\tstruct rtl_priv *rtlpriv = btcoexist->adapter;\n\n\trtlpriv->cfg->ops->fill_h2c_cmd(rtlpriv->mac80211.hw, element_id,\n\t\t\t\t\tcmd_len, cmd_buf);\n}\n\nvoid halbtc_send_wifi_port_id_cmd(void *bt_context)\n{\n\tstruct btc_coexist *btcoexist = (struct btc_coexist *)bt_context;\n\tstruct rtl_priv *rtlpriv = btcoexist->adapter;\n\tu8 cmd_buf[1] = {0};\t \n\n\trtlpriv->cfg->ops->fill_h2c_cmd(rtlpriv->mac80211.hw, H2C_BT_PORT_ID,\n\t\t\t\t\t1, cmd_buf);\n}\n\nvoid halbtc_set_default_port_id_cmd(void *bt_context)\n{\n\tstruct btc_coexist *btcoexist = (struct btc_coexist *)bt_context;\n\tstruct rtl_priv *rtlpriv = btcoexist->adapter;\n\tstruct ieee80211_hw *hw = rtlpriv->mac80211.hw;\n\n\tif (!rtlpriv->cfg->ops->set_default_port_id_cmd)\n\t\treturn;\n\n\trtlpriv->cfg->ops->set_default_port_id_cmd(hw);\n}\n\nstatic\nvoid halbtc_set_bt_reg(void *btc_context, u8 reg_type, u32 offset, u32 set_val)\n{\n\tstruct btc_coexist *btcoexist = (struct btc_coexist *)btc_context;\n\tu8 cmd_buffer1[4] = {0};\n\tu8 cmd_buffer2[4] = {0};\n\n\t \n\t*((__le16 *)&cmd_buffer1[2]) = cpu_to_le16((u16)set_val);\n\tif (!halbtc_send_bt_mp_operation(btcoexist, BT_OP_WRITE_REG_VALUE,\n\t\t\t\t\t cmd_buffer1, 4, 200))\n\t\treturn;\n\n\t \n\tcmd_buffer2[2] = reg_type;\n\t*((u8 *)&cmd_buffer2[3]) = (u8)offset;\n\thalbtc_send_bt_mp_operation(btcoexist, BT_OP_WRITE_REG_ADDR,\n\t\t\t\t    cmd_buffer2, 4, 200);\n}\n\nstatic void halbtc_display_dbg_msg(void *bt_context, u8 disp_type,\n\t\t\t\t   struct seq_file *m)\n{\n\tstruct btc_coexist *btcoexist = (struct btc_coexist *)bt_context;\n\n\tswitch (disp_type) {\n\tcase BTC_DBG_DISP_COEX_STATISTICS:\n\t\thalbtc_display_coex_statistics(btcoexist, m);\n\t\tbreak;\n\tcase BTC_DBG_DISP_BT_LINK_INFO:\n\t\thalbtc_display_bt_link_info(btcoexist, m);\n\t\tbreak;\n\tcase BTC_DBG_DISP_WIFI_STATUS:\n\t\thalbtc_display_wifi_status(btcoexist, m);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic u32 halbtc_get_bt_reg(void *btc_context, u8 reg_type, u32 offset)\n{\n\treturn 0;\n}\n\nstatic bool halbtc_under_ips(struct btc_coexist *btcoexist)\n{\n\tstruct rtl_priv *rtlpriv = btcoexist->adapter;\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtlpriv);\n\tenum rf_pwrstate rtstate;\n\n\tif (ppsc->inactiveps) {\n\t\trtstate = ppsc->rfpwr_state;\n\n\t\tif (rtstate != ERFON &&\n\t\t    ppsc->rfoff_reason == RF_CHANGE_BY_IPS) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic\nu32 halbtc_get_phydm_version(void *btc_context)\n{\n\treturn 0;\n}\n\nstatic\nvoid halbtc_phydm_modify_ra_pcr_threshold(void *btc_context,\n\t\t\t\t\t  u8 ra_offset_direction,\n\t\t\t\t\t  u8 ra_threshold_offset)\n{\n}\n\nstatic\nu32 halbtc_phydm_query_phy_counter(void *btc_context, enum dm_info_query dm_id)\n{\n\treturn 0;\n}\n\nstatic u8 halbtc_get_ant_det_val_from_bt(void *btc_context)\n{\n\tstruct btc_coexist *btcoexist = (struct btc_coexist *)btc_context;\n\tu8 cmd_buffer[4] = {0};\n\n\t \n\thalbtc_send_bt_mp_operation(btcoexist, BT_OP_GET_BT_ANT_DET_VAL,\n\t\t\t\t    cmd_buffer, 4, 200);\n\n\t \n\n\treturn btcoexist->bt_info.bt_ant_det_val;\n}\n\nstatic u8 halbtc_get_ble_scan_type_from_bt(void *btc_context)\n{\n\tstruct btc_coexist *btcoexist = (struct btc_coexist *)btc_context;\n\tu8 cmd_buffer[4] = {0};\n\n\t \n\thalbtc_send_bt_mp_operation(btcoexist, BT_OP_GET_BT_BLE_SCAN_TYPE,\n\t\t\t\t    cmd_buffer, 4, 200);\n\n\t \n\n\treturn btcoexist->bt_info.bt_ble_scan_type;\n}\n\nstatic u32 halbtc_get_ble_scan_para_from_bt(void *btc_context, u8 scan_type)\n{\n\tstruct btc_coexist *btcoexist = (struct btc_coexist *)btc_context;\n\tu8 cmd_buffer[4] = {0};\n\n\t \n\thalbtc_send_bt_mp_operation(btcoexist, BT_OP_GET_BT_BLE_SCAN_PARA,\n\t\t\t\t    cmd_buffer, 4, 200);\n\n\t \n\n\treturn btcoexist->bt_info.bt_ble_scan_para;\n}\n\nstatic bool halbtc_get_bt_afh_map_from_bt(void *btc_context, u8 map_type,\n\t\t\t\t\t  u8 *afh_map)\n{\n\tstruct btc_coexist *btcoexist = (struct btc_coexist *)btc_context;\n\tu8 cmd_buffer[2] = {0};\n\tbool ret;\n\tu32 *afh_map_l = (u32 *)afh_map;\n\tu32 *afh_map_m = (u32 *)(afh_map + 4);\n\tu16 *afh_map_h = (u16 *)(afh_map + 8);\n\n\t \n\tret = halbtc_send_bt_mp_operation(btcoexist, BT_OP_GET_AFH_MAP_L,\n\t\t\t\t\t  cmd_buffer, 2, 200);\n\tif (!ret)\n\t\tgoto exit;\n\n\t*afh_map_l = btcoexist->bt_info.afh_map_l;\n\n\t \n\tret = halbtc_send_bt_mp_operation(btcoexist, BT_OP_GET_AFH_MAP_M,\n\t\t\t\t\t  cmd_buffer, 2, 200);\n\tif (!ret)\n\t\tgoto exit;\n\n\t*afh_map_m = btcoexist->bt_info.afh_map_m;\n\n\t \n\tret = halbtc_send_bt_mp_operation(btcoexist, BT_OP_GET_AFH_MAP_H,\n\t\t\t\t\t  cmd_buffer, 2, 200);\n\tif (!ret)\n\t\tgoto exit;\n\n\t*afh_map_h = btcoexist->bt_info.afh_map_h;\n\nexit:\n\treturn ret;\n}\n\n \nbool exhalbtc_initlize_variables(struct rtl_priv *rtlpriv)\n{\n\tstruct btc_coexist *btcoexist = rtl_btc_coexist(rtlpriv);\n\n\tif (!btcoexist)\n\t\treturn false;\n\n\thalbtc_dbg_init();\n\n\tbtcoexist->btc_read_1byte = halbtc_read_1byte;\n\tbtcoexist->btc_write_1byte = halbtc_write_1byte;\n\tbtcoexist->btc_write_1byte_bitmask = halbtc_bitmask_write_1byte;\n\tbtcoexist->btc_read_2byte = halbtc_read_2byte;\n\tbtcoexist->btc_write_2byte = halbtc_write_2byte;\n\tbtcoexist->btc_read_4byte = halbtc_read_4byte;\n\tbtcoexist->btc_write_4byte = halbtc_write_4byte;\n\tbtcoexist->btc_write_local_reg_1byte = halbtc_write_local_reg_1byte;\n\n\tbtcoexist->btc_set_bb_reg = halbtc_set_bbreg;\n\tbtcoexist->btc_get_bb_reg = halbtc_get_bbreg;\n\n\tbtcoexist->btc_set_rf_reg = halbtc_set_rfreg;\n\tbtcoexist->btc_get_rf_reg = halbtc_get_rfreg;\n\n\tbtcoexist->btc_fill_h2c = halbtc_fill_h2c_cmd;\n\tbtcoexist->btc_disp_dbg_msg = halbtc_display_dbg_msg;\n\n\tbtcoexist->btc_get = halbtc_get;\n\tbtcoexist->btc_set = halbtc_set;\n\tbtcoexist->btc_set_bt_reg = halbtc_set_bt_reg;\n\tbtcoexist->btc_get_bt_reg = halbtc_get_bt_reg;\n\n\tbtcoexist->bt_info.bt_ctrl_buf_size = false;\n\tbtcoexist->bt_info.agg_buf_size = 5;\n\n\tbtcoexist->bt_info.increase_scan_dev_num = false;\n\n\tbtcoexist->btc_get_bt_coex_supported_feature =\n\t\t\t\t\thalbtc_get_bt_coex_supported_feature;\n\tbtcoexist->btc_get_bt_coex_supported_version =\n\t\t\t\t\thalbtc_get_bt_coex_supported_version;\n\tbtcoexist->btc_get_bt_phydm_version = halbtc_get_phydm_version;\n\tbtcoexist->btc_phydm_modify_ra_pcr_threshold =\n\t\t\t\t\thalbtc_phydm_modify_ra_pcr_threshold;\n\tbtcoexist->btc_phydm_query_phy_counter = halbtc_phydm_query_phy_counter;\n\tbtcoexist->btc_get_ant_det_val_from_bt = halbtc_get_ant_det_val_from_bt;\n\tbtcoexist->btc_get_ble_scan_type_from_bt =\n\t\t\t\t\thalbtc_get_ble_scan_type_from_bt;\n\tbtcoexist->btc_get_ble_scan_para_from_bt =\n\t\t\t\t\thalbtc_get_ble_scan_para_from_bt;\n\tbtcoexist->btc_get_bt_afh_map_from_bt =\n\t\t\t\t\thalbtc_get_bt_afh_map_from_bt;\n\n\tinit_completion(&btcoexist->bt_mp_comp);\n\n\treturn true;\n}\n\nbool exhalbtc_initlize_variables_wifi_only(struct rtl_priv *rtlpriv)\n{\n\tstruct wifi_only_cfg *wifionly_cfg = rtl_btc_wifi_only(rtlpriv);\n\tstruct wifi_only_haldata *wifionly_haldata;\n\n\tif (!wifionly_cfg)\n\t\treturn false;\n\n\twifionly_cfg->adapter = rtlpriv;\n\n\tswitch (rtlpriv->rtlhal.interface) {\n\tcase INTF_PCI:\n\t\twifionly_cfg->chip_interface = WIFIONLY_INTF_PCI;\n\t\tbreak;\n\tcase INTF_USB:\n\t\twifionly_cfg->chip_interface = WIFIONLY_INTF_USB;\n\t\tbreak;\n\tdefault:\n\t\twifionly_cfg->chip_interface = WIFIONLY_INTF_UNKNOWN;\n\t\tbreak;\n\t}\n\n\twifionly_haldata = &wifionly_cfg->haldata_info;\n\n\twifionly_haldata->customer_id = CUSTOMER_NORMAL;\n\twifionly_haldata->efuse_pg_antnum = rtl_get_hwpg_ant_num(rtlpriv);\n\twifionly_haldata->efuse_pg_antpath =\n\t\t\t\t\trtl_get_hwpg_single_ant_path(rtlpriv);\n\twifionly_haldata->rfe_type = rtl_get_hwpg_rfe_type(rtlpriv);\n\twifionly_haldata->ant_div_cfg = 0;\n\n\treturn true;\n}\n\nbool exhalbtc_bind_bt_coex_withadapter(void *adapter)\n{\n\tstruct rtl_priv *rtlpriv = adapter;\n\tstruct btc_coexist *btcoexist = rtl_btc_coexist(rtlpriv);\n\tu8 ant_num, chip_type, single_ant_path;\n\n\tif (!btcoexist)\n\t\treturn false;\n\n\tif (btcoexist->binded)\n\t\treturn false;\n\n\tswitch (rtlpriv->rtlhal.interface) {\n\tcase INTF_PCI:\n\t\tbtcoexist->chip_interface = BTC_INTF_PCI;\n\t\tbreak;\n\tcase INTF_USB:\n\t\tbtcoexist->chip_interface = BTC_INTF_USB;\n\t\tbreak;\n\tdefault:\n\t\tbtcoexist->chip_interface = BTC_INTF_UNKNOWN;\n\t\tbreak;\n\t}\n\n\tbtcoexist->binded = true;\n\tbtcoexist->statistics.cnt_bind++;\n\n\tbtcoexist->adapter = adapter;\n\n\tbtcoexist->stack_info.profile_notified = false;\n\n\tbtcoexist->bt_info.bt_ctrl_agg_buf_size = false;\n\tbtcoexist->bt_info.agg_buf_size = 5;\n\n\tbtcoexist->bt_info.increase_scan_dev_num = false;\n\tbtcoexist->bt_info.miracast_plus_bt = false;\n\n\tchip_type = rtl_get_hwpg_bt_type(rtlpriv);\n\texhalbtc_set_chip_type(btcoexist, chip_type);\n\tant_num = rtl_get_hwpg_ant_num(rtlpriv);\n\texhalbtc_set_ant_num(rtlpriv, BT_COEX_ANT_TYPE_PG, ant_num);\n\n\t \n\tbtcoexist->board_info.btdm_ant_pos = BTC_ANTENNA_AT_MAIN_PORT;\n\n\tsingle_ant_path = rtl_get_hwpg_single_ant_path(rtlpriv);\n\texhalbtc_set_single_ant_path(btcoexist, single_ant_path);\n\n\tif (rtl_get_hwpg_package_type(rtlpriv) == 0)\n\t\tbtcoexist->board_info.tfbga_package = false;\n\telse if (rtl_get_hwpg_package_type(rtlpriv) == 1)\n\t\tbtcoexist->board_info.tfbga_package = false;\n\telse\n\t\tbtcoexist->board_info.tfbga_package = true;\n\n\tif (btcoexist->board_info.tfbga_package)\n\t\trtl_dbg(rtlpriv, COMP_BT_COEXIST, DBG_LOUD,\n\t\t\t\"[BTCoex], Package Type = TFBGA\\n\");\n\telse\n\t\trtl_dbg(rtlpriv, COMP_BT_COEXIST, DBG_LOUD,\n\t\t\t\"[BTCoex], Package Type = Non-TFBGA\\n\");\n\n\tbtcoexist->board_info.rfe_type = rtl_get_hwpg_rfe_type(rtlpriv);\n\tbtcoexist->board_info.ant_div_cfg = 0;\n\n\treturn true;\n}\n\nvoid exhalbtc_power_on_setting(struct btc_coexist *btcoexist)\n{\n\tif (!halbtc_is_bt_coexist_available(btcoexist))\n\t\treturn;\n\n\tbtcoexist->statistics.cnt_power_on++;\n\n\tif (IS_HARDWARE_TYPE_8723B(btcoexist->adapter)) {\n\t\tif (btcoexist->board_info.btdm_ant_num == 2)\n\t\t\tex_btc8723b2ant_power_on_setting(btcoexist);\n\t\telse if (btcoexist->board_info.btdm_ant_num == 1)\n\t\t\tex_btc8723b1ant_power_on_setting(btcoexist);\n\t}\n}\n\nvoid exhalbtc_pre_load_firmware(struct btc_coexist *btcoexist)\n{\n\tif (!halbtc_is_bt_coexist_available(btcoexist))\n\t\treturn;\n\n\tbtcoexist->statistics.cnt_pre_load_firmware++;\n\n\tif (IS_HARDWARE_TYPE_8723B(btcoexist->adapter)) {\n\t\tif (btcoexist->board_info.btdm_ant_num == 2)\n\t\t\tex_btc8723b2ant_pre_load_firmware(btcoexist);\n\t}\n}\n\nvoid exhalbtc_init_hw_config(struct btc_coexist *btcoexist, bool wifi_only)\n{\n\tif (!halbtc_is_bt_coexist_available(btcoexist))\n\t\treturn;\n\n\tbtcoexist->statistics.cnt_init_hw_config++;\n\n\tif (IS_HARDWARE_TYPE_8821(btcoexist->adapter)) {\n\t\tif (btcoexist->board_info.btdm_ant_num == 2)\n\t\t\tex_btc8821a2ant_init_hwconfig(btcoexist);\n\t\telse if (btcoexist->board_info.btdm_ant_num == 1)\n\t\t\tex_btc8821a1ant_init_hwconfig(btcoexist, wifi_only);\n\t} else if (IS_HARDWARE_TYPE_8723B(btcoexist->adapter)) {\n\t\tif (btcoexist->board_info.btdm_ant_num == 2)\n\t\t\tex_btc8723b2ant_init_hwconfig(btcoexist);\n\t\telse if (btcoexist->board_info.btdm_ant_num == 1)\n\t\t\tex_btc8723b1ant_init_hwconfig(btcoexist, wifi_only);\n\t} else if (IS_HARDWARE_TYPE_8723A(btcoexist->adapter)) {\n\t\t \n\t} else if (IS_HARDWARE_TYPE_8192E(btcoexist->adapter)) {\n\t\tif (btcoexist->board_info.btdm_ant_num == 2)\n\t\t\tex_btc8192e2ant_init_hwconfig(btcoexist);\n\t}\n}\n\nvoid exhalbtc_init_hw_config_wifi_only(struct wifi_only_cfg *wifionly_cfg)\n{\n}\n\nvoid exhalbtc_init_coex_dm(struct btc_coexist *btcoexist)\n{\n\tif (!halbtc_is_bt_coexist_available(btcoexist))\n\t\treturn;\n\n\tbtcoexist->statistics.cnt_init_coex_dm++;\n\n\tif (IS_HARDWARE_TYPE_8821(btcoexist->adapter)) {\n\t\tif (btcoexist->board_info.btdm_ant_num == 2)\n\t\t\tex_btc8821a2ant_init_coex_dm(btcoexist);\n\t\telse if (btcoexist->board_info.btdm_ant_num == 1)\n\t\t\tex_btc8821a1ant_init_coex_dm(btcoexist);\n\t} else if (IS_HARDWARE_TYPE_8723B(btcoexist->adapter)) {\n\t\tif (btcoexist->board_info.btdm_ant_num == 2)\n\t\t\tex_btc8723b2ant_init_coex_dm(btcoexist);\n\t\telse if (btcoexist->board_info.btdm_ant_num == 1)\n\t\t\tex_btc8723b1ant_init_coex_dm(btcoexist);\n\t} else if (IS_HARDWARE_TYPE_8192E(btcoexist->adapter)) {\n\t\tif (btcoexist->board_info.btdm_ant_num == 2)\n\t\t\tex_btc8192e2ant_init_coex_dm(btcoexist);\n\t}\n\n\tbtcoexist->initialized = true;\n}\n\nvoid exhalbtc_ips_notify(struct btc_coexist *btcoexist, u8 type)\n{\n\tu8 ips_type;\n\n\tif (!halbtc_is_bt_coexist_available(btcoexist))\n\t\treturn;\n\tbtcoexist->statistics.cnt_ips_notify++;\n\tif (btcoexist->manual_control)\n\t\treturn;\n\n\tif (ERFOFF == type)\n\t\tips_type = BTC_IPS_ENTER;\n\telse\n\t\tips_type = BTC_IPS_LEAVE;\n\n\thalbtc_leave_low_power(btcoexist);\n\n\tif (IS_HARDWARE_TYPE_8821(btcoexist->adapter)) {\n\t\tif (btcoexist->board_info.btdm_ant_num == 2)\n\t\t\tex_btc8821a2ant_ips_notify(btcoexist, ips_type);\n\t\telse if (btcoexist->board_info.btdm_ant_num == 1)\n\t\t\tex_btc8821a1ant_ips_notify(btcoexist, ips_type);\n\t} else if (IS_HARDWARE_TYPE_8723B(btcoexist->adapter)) {\n\t\tif (btcoexist->board_info.btdm_ant_num == 2)\n\t\t\tex_btc8723b2ant_ips_notify(btcoexist, ips_type);\n\t\telse if (btcoexist->board_info.btdm_ant_num == 1)\n\t\t\tex_btc8723b1ant_ips_notify(btcoexist, ips_type);\n\t} else if (IS_HARDWARE_TYPE_8192E(btcoexist->adapter)) {\n\t\tif (btcoexist->board_info.btdm_ant_num == 2)\n\t\t\tex_btc8192e2ant_ips_notify(btcoexist, ips_type);\n\t}\n\n\thalbtc_normal_low_power(btcoexist);\n}\n\nvoid exhalbtc_lps_notify(struct btc_coexist *btcoexist, u8 type)\n{\n\tu8 lps_type;\n\n\tif (!halbtc_is_bt_coexist_available(btcoexist))\n\t\treturn;\n\tbtcoexist->statistics.cnt_lps_notify++;\n\tif (btcoexist->manual_control)\n\t\treturn;\n\n\tif (EACTIVE == type)\n\t\tlps_type = BTC_LPS_DISABLE;\n\telse\n\t\tlps_type = BTC_LPS_ENABLE;\n\n\tif (IS_HARDWARE_TYPE_8821(btcoexist->adapter)) {\n\t\tif (btcoexist->board_info.btdm_ant_num == 2)\n\t\t\tex_btc8821a2ant_lps_notify(btcoexist, lps_type);\n\t\telse if (btcoexist->board_info.btdm_ant_num == 1)\n\t\t\tex_btc8821a1ant_lps_notify(btcoexist, lps_type);\n\t} else if (IS_HARDWARE_TYPE_8723B(btcoexist->adapter)) {\n\t\tif (btcoexist->board_info.btdm_ant_num == 2)\n\t\t\tex_btc8723b2ant_lps_notify(btcoexist, lps_type);\n\t\telse if (btcoexist->board_info.btdm_ant_num == 1)\n\t\t\tex_btc8723b1ant_lps_notify(btcoexist, lps_type);\n\t} else if (IS_HARDWARE_TYPE_8192E(btcoexist->adapter)) {\n\t\tif (btcoexist->board_info.btdm_ant_num == 2)\n\t\t\tex_btc8192e2ant_lps_notify(btcoexist, lps_type);\n\t}\n}\n\nvoid exhalbtc_scan_notify(struct btc_coexist *btcoexist, u8 type)\n{\n\tu8 scan_type;\n\n\tif (!halbtc_is_bt_coexist_available(btcoexist))\n\t\treturn;\n\tbtcoexist->statistics.cnt_scan_notify++;\n\tif (btcoexist->manual_control)\n\t\treturn;\n\n\tif (type)\n\t\tscan_type = BTC_SCAN_START;\n\telse\n\t\tscan_type = BTC_SCAN_FINISH;\n\n\thalbtc_leave_low_power(btcoexist);\n\n\tif (IS_HARDWARE_TYPE_8821(btcoexist->adapter)) {\n\t\tif (btcoexist->board_info.btdm_ant_num == 2)\n\t\t\tex_btc8821a2ant_scan_notify(btcoexist, scan_type);\n\t\telse if (btcoexist->board_info.btdm_ant_num == 1)\n\t\t\tex_btc8821a1ant_scan_notify(btcoexist, scan_type);\n\t} else if (IS_HARDWARE_TYPE_8723B(btcoexist->adapter)) {\n\t\tif (btcoexist->board_info.btdm_ant_num == 2)\n\t\t\tex_btc8723b2ant_scan_notify(btcoexist, scan_type);\n\t\telse if (btcoexist->board_info.btdm_ant_num == 1)\n\t\t\tex_btc8723b1ant_scan_notify(btcoexist, scan_type);\n\t} else if (IS_HARDWARE_TYPE_8192E(btcoexist->adapter)) {\n\t\tif (btcoexist->board_info.btdm_ant_num == 2)\n\t\t\tex_btc8192e2ant_scan_notify(btcoexist, scan_type);\n\t}\n\n\thalbtc_normal_low_power(btcoexist);\n}\n\nvoid exhalbtc_scan_notify_wifi_only(struct wifi_only_cfg *wifionly_cfg,\n\t\t\t\t    u8 is_5g)\n{\n}\n\nvoid exhalbtc_connect_notify(struct btc_coexist *btcoexist, u8 action)\n{\n\tu8 asso_type;\n\tbool wifi_under_5g;\n\n\tif (!halbtc_is_bt_coexist_available(btcoexist))\n\t\treturn;\n\tbtcoexist->statistics.cnt_connect_notify++;\n\tif (btcoexist->manual_control)\n\t\treturn;\n\n\tbtcoexist->btc_get(btcoexist, BTC_GET_BL_WIFI_UNDER_5G, &wifi_under_5g);\n\n\tif (action)\n\t\tasso_type = BTC_ASSOCIATE_START;\n\telse\n\t\tasso_type = BTC_ASSOCIATE_FINISH;\n\n\thalbtc_leave_low_power(btcoexist);\n\n\tif (IS_HARDWARE_TYPE_8821(btcoexist->adapter)) {\n\t\tif (btcoexist->board_info.btdm_ant_num == 2)\n\t\t\tex_btc8821a2ant_connect_notify(btcoexist, asso_type);\n\t\telse if (btcoexist->board_info.btdm_ant_num == 1)\n\t\t\tex_btc8821a1ant_connect_notify(btcoexist, asso_type);\n\t} else if (IS_HARDWARE_TYPE_8723B(btcoexist->adapter)) {\n\t\tif (btcoexist->board_info.btdm_ant_num == 2)\n\t\t\tex_btc8723b2ant_connect_notify(btcoexist, asso_type);\n\t\telse if (btcoexist->board_info.btdm_ant_num == 1)\n\t\t\tex_btc8723b1ant_connect_notify(btcoexist, asso_type);\n\t} else if (IS_HARDWARE_TYPE_8192E(btcoexist->adapter)) {\n\t\tif (btcoexist->board_info.btdm_ant_num == 2)\n\t\t\tex_btc8192e2ant_connect_notify(btcoexist, asso_type);\n\t}\n\n\thalbtc_normal_low_power(btcoexist);\n}\n\nvoid exhalbtc_mediastatus_notify(struct btc_coexist *btcoexist,\n\t\t\t\t enum rt_media_status media_status)\n{\n\tu8 status;\n\n\tif (!halbtc_is_bt_coexist_available(btcoexist))\n\t\treturn;\n\tbtcoexist->statistics.cnt_media_status_notify++;\n\tif (btcoexist->manual_control)\n\t\treturn;\n\n\tif (RT_MEDIA_CONNECT == media_status)\n\t\tstatus = BTC_MEDIA_CONNECT;\n\telse\n\t\tstatus = BTC_MEDIA_DISCONNECT;\n\n\thalbtc_leave_low_power(btcoexist);\n\n\tif (IS_HARDWARE_TYPE_8821(btcoexist->adapter)) {\n\t\tif (btcoexist->board_info.btdm_ant_num == 2)\n\t\t\tex_btc8821a2ant_media_status_notify(btcoexist, status);\n\t\telse if (btcoexist->board_info.btdm_ant_num == 1)\n\t\t\tex_btc8821a1ant_media_status_notify(btcoexist, status);\n\t} else if (IS_HARDWARE_TYPE_8723B(btcoexist->adapter)) {\n\t\tif (btcoexist->board_info.btdm_ant_num == 2)\n\t\t\tex_btc8723b2ant_media_status_notify(btcoexist, status);\n\t\telse if (btcoexist->board_info.btdm_ant_num == 1)\n\t\t\tex_btc8723b1ant_media_status_notify(btcoexist, status);\n\t} else if (IS_HARDWARE_TYPE_8192E(btcoexist->adapter)) {\n\t\tif (btcoexist->board_info.btdm_ant_num == 2)\n\t\t\tex_btc8192e2ant_media_status_notify(btcoexist, status);\n\t}\n\n\thalbtc_normal_low_power(btcoexist);\n}\n\nvoid exhalbtc_special_packet_notify(struct btc_coexist *btcoexist, u8 pkt_type)\n{\n\tu8 packet_type;\n\n\tif (!halbtc_is_bt_coexist_available(btcoexist))\n\t\treturn;\n\tbtcoexist->statistics.cnt_special_packet_notify++;\n\tif (btcoexist->manual_control)\n\t\treturn;\n\n\tif (pkt_type == PACKET_DHCP) {\n\t\tpacket_type = BTC_PACKET_DHCP;\n\t} else if (pkt_type == PACKET_EAPOL) {\n\t\tpacket_type = BTC_PACKET_EAPOL;\n\t} else if (pkt_type == PACKET_ARP) {\n\t\tpacket_type = BTC_PACKET_ARP;\n\t} else {\n\t\tpacket_type = BTC_PACKET_UNKNOWN;\n\t\treturn;\n\t}\n\n\thalbtc_leave_low_power(btcoexist);\n\n\tif (IS_HARDWARE_TYPE_8821(btcoexist->adapter)) {\n\t\tif (btcoexist->board_info.btdm_ant_num == 2)\n\t\t\tex_btc8821a2ant_special_packet_notify(btcoexist,\n\t\t\t\t\t\t\t      packet_type);\n\t\telse if (btcoexist->board_info.btdm_ant_num == 1)\n\t\t\tex_btc8821a1ant_special_packet_notify(btcoexist,\n\t\t\t\t\t\t\t      packet_type);\n\t} else if (IS_HARDWARE_TYPE_8723B(btcoexist->adapter)) {\n\t\tif (btcoexist->board_info.btdm_ant_num == 2)\n\t\t\tex_btc8723b2ant_special_packet_notify(btcoexist,\n\t\t\t\t\t\t\t      packet_type);\n\t\telse if (btcoexist->board_info.btdm_ant_num == 1)\n\t\t\tex_btc8723b1ant_special_packet_notify(btcoexist,\n\t\t\t\t\t\t\t      packet_type);\n\t} else if (IS_HARDWARE_TYPE_8192E(btcoexist->adapter)) {\n\t\tif (btcoexist->board_info.btdm_ant_num == 2)\n\t\t\tex_btc8192e2ant_special_packet_notify(btcoexist,\n\t\t\t\t\t\t\t      packet_type);\n\t}\n\n\thalbtc_normal_low_power(btcoexist);\n}\n\nvoid exhalbtc_bt_info_notify(struct btc_coexist *btcoexist,\n\t\t\t     u8 *tmp_buf, u8 length)\n{\n\tif (!halbtc_is_bt_coexist_available(btcoexist))\n\t\treturn;\n\tbtcoexist->statistics.cnt_bt_info_notify++;\n\n\thalbtc_leave_low_power(btcoexist);\n\n\tif (IS_HARDWARE_TYPE_8821(btcoexist->adapter)) {\n\t\tif (btcoexist->board_info.btdm_ant_num == 2)\n\t\t\tex_btc8821a2ant_bt_info_notify(btcoexist, tmp_buf,\n\t\t\t\t\t\t       length);\n\t\telse if (btcoexist->board_info.btdm_ant_num == 1)\n\t\t\tex_btc8821a1ant_bt_info_notify(btcoexist, tmp_buf,\n\t\t\t\t\t\t       length);\n\t} else if (IS_HARDWARE_TYPE_8723B(btcoexist->adapter)) {\n\t\tif (btcoexist->board_info.btdm_ant_num == 2)\n\t\t\tex_btc8723b2ant_bt_info_notify(btcoexist, tmp_buf,\n\t\t\t\t\t\t       length);\n\t\telse if (btcoexist->board_info.btdm_ant_num == 1)\n\t\t\tex_btc8723b1ant_bt_info_notify(btcoexist, tmp_buf,\n\t\t\t\t\t\t       length);\n\t} else if (IS_HARDWARE_TYPE_8192E(btcoexist->adapter)) {\n\t\tif (btcoexist->board_info.btdm_ant_num == 2)\n\t\t\tex_btc8192e2ant_bt_info_notify(btcoexist, tmp_buf,\n\t\t\t\t\t\t       length);\n\t}\n\n\thalbtc_normal_low_power(btcoexist);\n}\n\nvoid exhalbtc_rf_status_notify(struct btc_coexist *btcoexist, u8 type)\n{\n\tif (!halbtc_is_bt_coexist_available(btcoexist))\n\t\treturn;\n\n\tif (IS_HARDWARE_TYPE_8821(btcoexist->adapter)) {\n\t} else if (IS_HARDWARE_TYPE_8723B(btcoexist->adapter)) {\n\t\tif (btcoexist->board_info.btdm_ant_num == 1)\n\t\t\tex_btc8723b1ant_rf_status_notify(btcoexist, type);\n\t} else if (IS_HARDWARE_TYPE_8192E(btcoexist->adapter)) {\n\t}\n}\n\nvoid exhalbtc_halt_notify(struct btc_coexist *btcoexist)\n{\n\tif (!halbtc_is_bt_coexist_available(btcoexist))\n\t\treturn;\n\n\tif (IS_HARDWARE_TYPE_8821(btcoexist->adapter)) {\n\t\tif (btcoexist->board_info.btdm_ant_num == 2)\n\t\t\tex_btc8821a2ant_halt_notify(btcoexist);\n\t\telse if (btcoexist->board_info.btdm_ant_num == 1)\n\t\t\tex_btc8821a1ant_halt_notify(btcoexist);\n\t} else if (IS_HARDWARE_TYPE_8723B(btcoexist->adapter)) {\n\t\tif (btcoexist->board_info.btdm_ant_num == 2)\n\t\t\tex_btc8723b2ant_halt_notify(btcoexist);\n\t\telse if (btcoexist->board_info.btdm_ant_num == 1)\n\t\t\tex_btc8723b1ant_halt_notify(btcoexist);\n\t} else if (IS_HARDWARE_TYPE_8192E(btcoexist->adapter)) {\n\t\tif (btcoexist->board_info.btdm_ant_num == 2)\n\t\t\tex_btc8192e2ant_halt_notify(btcoexist);\n\t}\n\n\tbtcoexist->binded = false;\n}\n\nvoid exhalbtc_pnp_notify(struct btc_coexist *btcoexist, u8 pnp_state)\n{\n\tif (!halbtc_is_bt_coexist_available(btcoexist))\n\t\treturn;\n\n\t \n\n\tif (IS_HARDWARE_TYPE_8723B(btcoexist->adapter)) {\n\t\tif (btcoexist->board_info.btdm_ant_num == 1)\n\t\t\tex_btc8723b1ant_pnp_notify(btcoexist, pnp_state);\n\t\telse if (btcoexist->board_info.btdm_ant_num == 2)\n\t\t\tex_btc8723b2ant_pnp_notify(btcoexist, pnp_state);\n\t} else if (IS_HARDWARE_TYPE_8821(btcoexist->adapter)) {\n\t\tif (btcoexist->board_info.btdm_ant_num == 1)\n\t\t\tex_btc8821a1ant_pnp_notify(btcoexist, pnp_state);\n\t\telse if (btcoexist->board_info.btdm_ant_num == 2)\n\t\t\tex_btc8821a2ant_pnp_notify(btcoexist, pnp_state);\n\t} else if (IS_HARDWARE_TYPE_8192E(btcoexist->adapter)) {\n\t}\n}\n\nvoid exhalbtc_coex_dm_switch(struct btc_coexist *btcoexist)\n{\n\tstruct rtl_priv *rtlpriv = btcoexist->adapter;\n\n\tif (!halbtc_is_bt_coexist_available(btcoexist))\n\t\treturn;\n\tbtcoexist->statistics.cnt_coex_dm_switch++;\n\n\thalbtc_leave_low_power(btcoexist);\n\n\tif (IS_HARDWARE_TYPE_8723B(btcoexist->adapter)) {\n\t\tif (btcoexist->board_info.btdm_ant_num == 1) {\n\t\t\tbtcoexist->stop_coex_dm = true;\n\t\t\tex_btc8723b1ant_coex_dm_reset(btcoexist);\n\t\t\texhalbtc_set_ant_num(rtlpriv,\n\t\t\t\t\t     BT_COEX_ANT_TYPE_DETECTED, 2);\n\t\t\tex_btc8723b2ant_init_hwconfig(btcoexist);\n\t\t\tex_btc8723b2ant_init_coex_dm(btcoexist);\n\t\t\tbtcoexist->stop_coex_dm = false;\n\t\t}\n\t}\n\n\thalbtc_normal_low_power(btcoexist);\n}\n\nvoid exhalbtc_periodical(struct btc_coexist *btcoexist)\n{\n\tif (!halbtc_is_bt_coexist_available(btcoexist))\n\t\treturn;\n\tbtcoexist->statistics.cnt_periodical++;\n\n\thalbtc_leave_low_power(btcoexist);\n\n\tif (IS_HARDWARE_TYPE_8821(btcoexist->adapter)) {\n\t\tif (btcoexist->board_info.btdm_ant_num == 2)\n\t\t\tex_btc8821a2ant_periodical(btcoexist);\n\t\telse if (btcoexist->board_info.btdm_ant_num == 1)\n\t\t\tif (!halbtc_under_ips(btcoexist))\n\t\t\t\tex_btc8821a1ant_periodical(btcoexist);\n\t} else if (IS_HARDWARE_TYPE_8723B(btcoexist->adapter)) {\n\t\tif (btcoexist->board_info.btdm_ant_num == 2)\n\t\t\tex_btc8723b2ant_periodical(btcoexist);\n\t\telse if (btcoexist->board_info.btdm_ant_num == 1)\n\t\t\tex_btc8723b1ant_periodical(btcoexist);\n\t} else if (IS_HARDWARE_TYPE_8192E(btcoexist->adapter)) {\n\t\tif (btcoexist->board_info.btdm_ant_num == 2)\n\t\t\tex_btc8192e2ant_periodical(btcoexist);\n\t}\n\n\thalbtc_normal_low_power(btcoexist);\n}\n\nvoid exhalbtc_dbg_control(struct btc_coexist *btcoexist,\n\t\t\t  u8 code, u8 len, u8 *data)\n{\n\tif (!halbtc_is_bt_coexist_available(btcoexist))\n\t\treturn;\n\tbtcoexist->statistics.cnt_dbg_ctrl++;\n\n\thalbtc_leave_low_power(btcoexist);\n\n\thalbtc_normal_low_power(btcoexist);\n}\n\nvoid exhalbtc_antenna_detection(struct btc_coexist *btcoexist, u32 cent_freq,\n\t\t\t\tu32 offset, u32 span, u32 seconds)\n{\n\tif (!halbtc_is_bt_coexist_available(btcoexist))\n\t\treturn;\n}\n\nvoid exhalbtc_stack_update_profile_info(void)\n{\n}\n\nvoid exhalbtc_update_min_bt_rssi(struct btc_coexist *btcoexist, s8 bt_rssi)\n{\n\tif (!halbtc_is_bt_coexist_available(btcoexist))\n\t\treturn;\n\n\tbtcoexist->stack_info.min_bt_rssi = bt_rssi;\n}\n\nvoid exhalbtc_set_hci_version(struct btc_coexist *btcoexist, u16 hci_version)\n{\n\tif (!halbtc_is_bt_coexist_available(btcoexist))\n\t\treturn;\n\n\tbtcoexist->stack_info.hci_version = hci_version;\n}\n\nvoid exhalbtc_set_bt_patch_version(struct btc_coexist *btcoexist,\n\t\t\t\t   u16 bt_hci_version, u16 bt_patch_version)\n{\n\tif (!halbtc_is_bt_coexist_available(btcoexist))\n\t\treturn;\n\n\tbtcoexist->bt_info.bt_real_fw_ver = bt_patch_version;\n\tbtcoexist->bt_info.bt_hci_ver = bt_hci_version;\n}\n\nvoid exhalbtc_set_chip_type(struct btc_coexist *btcoexist, u8 chip_type)\n{\n\tswitch (chip_type) {\n\tdefault:\n\tcase BT_2WIRE:\n\tcase BT_ISSC_3WIRE:\n\tcase BT_ACCEL:\n\tcase BT_RTL8756:\n\t\tbtcoexist->board_info.bt_chip_type = BTC_CHIP_UNDEF;\n\t\tbreak;\n\tcase BT_CSR_BC4:\n\t\tbtcoexist->board_info.bt_chip_type = BTC_CHIP_CSR_BC4;\n\t\tbreak;\n\tcase BT_CSR_BC8:\n\t\tbtcoexist->board_info.bt_chip_type = BTC_CHIP_CSR_BC8;\n\t\tbreak;\n\tcase BT_RTL8723A:\n\t\tbtcoexist->board_info.bt_chip_type = BTC_CHIP_RTL8723A;\n\t\tbreak;\n\tcase BT_RTL8821A:\n\t\tbtcoexist->board_info.bt_chip_type = BTC_CHIP_RTL8821;\n\t\tbreak;\n\tcase BT_RTL8723B:\n\t\tbtcoexist->board_info.bt_chip_type = BTC_CHIP_RTL8723B;\n\t\tbreak;\n\t}\n}\n\nvoid exhalbtc_set_ant_num(struct rtl_priv *rtlpriv, u8 type, u8 ant_num)\n{\n\tstruct btc_coexist *btcoexist = rtl_btc_coexist(rtlpriv);\n\n\tif (!btcoexist)\n\t\treturn;\n\n\tif (BT_COEX_ANT_TYPE_PG == type) {\n\t\tbtcoexist->board_info.pg_ant_num = ant_num;\n\t\tbtcoexist->board_info.btdm_ant_num = ant_num;\n\t} else if (BT_COEX_ANT_TYPE_ANTDIV == type) {\n\t\tbtcoexist->board_info.btdm_ant_num = ant_num;\n\t} else if (type == BT_COEX_ANT_TYPE_DETECTED) {\n\t\tbtcoexist->board_info.btdm_ant_num = ant_num;\n\t\tif (rtlpriv->cfg->mod_params->ant_sel == 1)\n\t\t\tbtcoexist->board_info.btdm_ant_pos =\n\t\t\t\tBTC_ANTENNA_AT_AUX_PORT;\n\t\telse\n\t\t\tbtcoexist->board_info.btdm_ant_pos =\n\t\t\t\tBTC_ANTENNA_AT_MAIN_PORT;\n\t}\n}\n\n \nvoid exhalbtc_set_single_ant_path(struct btc_coexist *btcoexist,\n\t\t\t\t  u8 single_ant_path)\n{\n\tbtcoexist->board_info.single_ant_path = single_ant_path;\n}\n\nvoid exhalbtc_display_bt_coex_info(struct btc_coexist *btcoexist,\n\t\t\t\t   struct seq_file *m)\n{\n\tif (!halbtc_is_bt_coexist_available(btcoexist))\n\t\treturn;\n\n\thalbtc_leave_low_power(btcoexist);\n\n\tif (IS_HARDWARE_TYPE_8821(btcoexist->adapter)) {\n\t\tif (btcoexist->board_info.btdm_ant_num == 2)\n\t\t\tex_btc8821a2ant_display_coex_info(btcoexist, m);\n\t\telse if (btcoexist->board_info.btdm_ant_num == 1)\n\t\t\tex_btc8821a1ant_display_coex_info(btcoexist, m);\n\t} else if (IS_HARDWARE_TYPE_8723B(btcoexist->adapter)) {\n\t\tif (btcoexist->board_info.btdm_ant_num == 2)\n\t\t\tex_btc8723b2ant_display_coex_info(btcoexist, m);\n\t\telse if (btcoexist->board_info.btdm_ant_num == 1)\n\t\t\tex_btc8723b1ant_display_coex_info(btcoexist, m);\n\t} else if (IS_HARDWARE_TYPE_8192E(btcoexist->adapter)) {\n\t\tif (btcoexist->board_info.btdm_ant_num == 2)\n\t\t\tex_btc8192e2ant_display_coex_info(btcoexist, m);\n\t}\n\n\thalbtc_normal_low_power(btcoexist);\n}\n\nvoid exhalbtc_switch_band_notify(struct btc_coexist *btcoexist, u8 type)\n{\n\tif (!halbtc_is_bt_coexist_available(btcoexist))\n\t\treturn;\n\n\tif (btcoexist->manual_control)\n\t\treturn;\n\n\thalbtc_leave_low_power(btcoexist);\n\n\thalbtc_normal_low_power(btcoexist);\n}\n\nvoid exhalbtc_switch_band_notify_wifi_only(struct wifi_only_cfg *wifionly_cfg,\n\t\t\t\t\t   u8 is_5g)\n{\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}