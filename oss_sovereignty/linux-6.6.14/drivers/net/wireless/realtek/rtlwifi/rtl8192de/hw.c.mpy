{
  "module_name": "hw.c",
  "hash_id": "581906a207baba988a5dd6502d8bdf20e2d7d7e56c60ab8822e7da9ed7d103fe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtlwifi/rtl8192de/hw.c",
  "human_readable_source": "\n \n\n#include \"../wifi.h\"\n#include \"../efuse.h\"\n#include \"../base.h\"\n#include \"../regd.h\"\n#include \"../cam.h\"\n#include \"../ps.h\"\n#include \"../pci.h\"\n#include \"reg.h\"\n#include \"def.h\"\n#include \"phy.h\"\n#include \"dm.h\"\n#include \"fw.h\"\n#include \"led.h\"\n#include \"sw.h\"\n#include \"hw.h\"\n\nu32 rtl92de_read_dword_dbi(struct ieee80211_hw *hw, u16 offset, u8 direct)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 value;\n\n\trtl_write_word(rtlpriv, REG_DBI_CTRL, (offset & 0xFFC));\n\trtl_write_byte(rtlpriv, REG_DBI_FLAG, BIT(1) | direct);\n\tudelay(10);\n\tvalue = rtl_read_dword(rtlpriv, REG_DBI_RDATA);\n\treturn value;\n}\n\nvoid rtl92de_write_dword_dbi(struct ieee80211_hw *hw,\n\t\t\t     u16 offset, u32 value, u8 direct)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtl_write_word(rtlpriv, REG_DBI_CTRL, ((offset & 0xFFC) | 0xF000));\n\trtl_write_dword(rtlpriv, REG_DBI_WDATA, value);\n\trtl_write_byte(rtlpriv, REG_DBI_FLAG, BIT(0) | direct);\n}\n\nstatic void _rtl92de_set_bcn_ctrl_reg(struct ieee80211_hw *hw,\n\t\t\t\t      u8 set_bits, u8 clear_bits)\n{\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtlpci->reg_bcn_ctrl_val |= set_bits;\n\trtlpci->reg_bcn_ctrl_val &= ~clear_bits;\n\trtl_write_byte(rtlpriv, REG_BCN_CTRL, (u8) rtlpci->reg_bcn_ctrl_val);\n}\n\nstatic void _rtl92de_stop_tx_beacon(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 tmp1byte;\n\n\ttmp1byte = rtl_read_byte(rtlpriv, REG_FWHW_TXQ_CTRL + 2);\n\trtl_write_byte(rtlpriv, REG_FWHW_TXQ_CTRL + 2, tmp1byte & (~BIT(6)));\n\trtl_write_byte(rtlpriv, REG_BCN_MAX_ERR, 0xff);\n\trtl_write_byte(rtlpriv, REG_TBTT_PROHIBIT + 1, 0x64);\n\ttmp1byte = rtl_read_byte(rtlpriv, REG_TBTT_PROHIBIT + 2);\n\ttmp1byte &= ~(BIT(0));\n\trtl_write_byte(rtlpriv, REG_TBTT_PROHIBIT + 2, tmp1byte);\n}\n\nstatic void _rtl92de_resume_tx_beacon(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 tmp1byte;\n\n\ttmp1byte = rtl_read_byte(rtlpriv, REG_FWHW_TXQ_CTRL + 2);\n\trtl_write_byte(rtlpriv, REG_FWHW_TXQ_CTRL + 2, tmp1byte | BIT(6));\n\trtl_write_byte(rtlpriv, REG_BCN_MAX_ERR, 0x0a);\n\trtl_write_byte(rtlpriv, REG_TBTT_PROHIBIT + 1, 0xff);\n\ttmp1byte = rtl_read_byte(rtlpriv, REG_TBTT_PROHIBIT + 2);\n\ttmp1byte |= BIT(0);\n\trtl_write_byte(rtlpriv, REG_TBTT_PROHIBIT + 2, tmp1byte);\n}\n\nstatic void _rtl92de_enable_bcn_sub_func(struct ieee80211_hw *hw)\n{\n\t_rtl92de_set_bcn_ctrl_reg(hw, 0, BIT(1));\n}\n\nstatic void _rtl92de_disable_bcn_sub_func(struct ieee80211_hw *hw)\n{\n\t_rtl92de_set_bcn_ctrl_reg(hw, BIT(1), 0);\n}\n\nvoid rtl92de_get_hw_reg(struct ieee80211_hw *hw, u8 variable, u8 *val)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\n\tswitch (variable) {\n\tcase HW_VAR_RCR:\n\t\t*((u32 *) (val)) = rtlpci->receive_config;\n\t\tbreak;\n\tcase HW_VAR_RF_STATE:\n\t\t*((enum rf_pwrstate *)(val)) = ppsc->rfpwr_state;\n\t\tbreak;\n\tcase HW_VAR_FWLPS_RF_ON:{\n\t\tenum rf_pwrstate rfstate;\n\t\tu32 val_rcr;\n\n\t\trtlpriv->cfg->ops->get_hw_reg(hw, HW_VAR_RF_STATE,\n\t\t\t\t\t      (u8 *)(&rfstate));\n\t\tif (rfstate == ERFOFF) {\n\t\t\t*((bool *) (val)) = true;\n\t\t} else {\n\t\t\tval_rcr = rtl_read_dword(rtlpriv, REG_RCR);\n\t\t\tval_rcr &= 0x00070000;\n\t\t\tif (val_rcr)\n\t\t\t\t*((bool *) (val)) = false;\n\t\t\telse\n\t\t\t\t*((bool *) (val)) = true;\n\t\t}\n\t\tbreak;\n\t}\n\tcase HW_VAR_FW_PSMODE_STATUS:\n\t\t*((bool *) (val)) = ppsc->fw_current_inpsmode;\n\t\tbreak;\n\tcase HW_VAR_CORRECT_TSF:{\n\t\tu64 tsf;\n\t\tu32 *ptsf_low = (u32 *)&tsf;\n\t\tu32 *ptsf_high = ((u32 *)&tsf) + 1;\n\n\t\t*ptsf_high = rtl_read_dword(rtlpriv, (REG_TSFTR + 4));\n\t\t*ptsf_low = rtl_read_dword(rtlpriv, REG_TSFTR);\n\t\t*((u64 *) (val)) = tsf;\n\t\tbreak;\n\t}\n\tcase HW_VAR_INT_MIGRATION:\n\t\t*((bool *)(val)) = rtlpriv->dm.interrupt_migration;\n\t\tbreak;\n\tcase HW_VAR_INT_AC:\n\t\t*((bool *)(val)) = rtlpriv->dm.disable_tx_int;\n\t\tbreak;\n\tcase HAL_DEF_WOWLAN:\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"switch case %#x not processed\\n\", variable);\n\t\tbreak;\n\t}\n}\n\nvoid rtl92de_set_hw_reg(struct ieee80211_hw *hw, u8 variable, u8 *val)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tu8 idx;\n\n\tswitch (variable) {\n\tcase HW_VAR_ETHER_ADDR:\n\t\tfor (idx = 0; idx < ETH_ALEN; idx++) {\n\t\t\trtl_write_byte(rtlpriv, (REG_MACID + idx),\n\t\t\t\t       val[idx]);\n\t\t}\n\t\tbreak;\n\tcase HW_VAR_BASIC_RATE: {\n\t\tu16 rate_cfg = ((u16 *) val)[0];\n\t\tu8 rate_index = 0;\n\n\t\trate_cfg = rate_cfg & 0x15f;\n\t\tif (mac->vendor == PEER_CISCO &&\n\t\t    ((rate_cfg & 0x150) == 0))\n\t\t\trate_cfg |= 0x01;\n\t\trtl_write_byte(rtlpriv, REG_RRSR, rate_cfg & 0xff);\n\t\trtl_write_byte(rtlpriv, REG_RRSR + 1,\n\t\t\t       (rate_cfg >> 8) & 0xff);\n\t\twhile (rate_cfg > 0x1) {\n\t\t\trate_cfg = (rate_cfg >> 1);\n\t\t\trate_index++;\n\t\t}\n\t\tif (rtlhal->fw_version > 0xe)\n\t\t\trtl_write_byte(rtlpriv, REG_INIRTS_RATE_SEL,\n\t\t\t\t       rate_index);\n\t\tbreak;\n\t}\n\tcase HW_VAR_BSSID:\n\t\tfor (idx = 0; idx < ETH_ALEN; idx++) {\n\t\t\trtl_write_byte(rtlpriv, (REG_BSSID + idx),\n\t\t\t\t       val[idx]);\n\t\t}\n\t\tbreak;\n\tcase HW_VAR_SIFS:\n\t\trtl_write_byte(rtlpriv, REG_SIFS_CTX + 1, val[0]);\n\t\trtl_write_byte(rtlpriv, REG_SIFS_TRX + 1, val[1]);\n\t\trtl_write_byte(rtlpriv, REG_SPEC_SIFS + 1, val[0]);\n\t\trtl_write_byte(rtlpriv, REG_MAC_SPEC_SIFS + 1, val[0]);\n\t\tif (!mac->ht_enable)\n\t\t\trtl_write_word(rtlpriv, REG_RESP_SIFS_OFDM,\n\t\t\t\t       0x0e0e);\n\t\telse\n\t\t\trtl_write_word(rtlpriv, REG_RESP_SIFS_OFDM,\n\t\t\t\t       *((u16 *) val));\n\t\tbreak;\n\tcase HW_VAR_SLOT_TIME: {\n\t\tu8 e_aci;\n\n\t\trtl_dbg(rtlpriv, COMP_MLME, DBG_LOUD,\n\t\t\t\"HW_VAR_SLOT_TIME %x\\n\", val[0]);\n\t\trtl_write_byte(rtlpriv, REG_SLOT, val[0]);\n\t\tfor (e_aci = 0; e_aci < AC_MAX; e_aci++)\n\t\t\trtlpriv->cfg->ops->set_hw_reg(hw,\n\t\t\t\t\t\t      HW_VAR_AC_PARAM,\n\t\t\t\t\t\t      (&e_aci));\n\t\tbreak;\n\t}\n\tcase HW_VAR_ACK_PREAMBLE: {\n\t\tu8 reg_tmp;\n\t\tu8 short_preamble = (bool) (*val);\n\n\t\treg_tmp = (mac->cur_40_prime_sc) << 5;\n\t\tif (short_preamble)\n\t\t\treg_tmp |= 0x80;\n\t\trtl_write_byte(rtlpriv, REG_RRSR + 2, reg_tmp);\n\t\tbreak;\n\t}\n\tcase HW_VAR_AMPDU_MIN_SPACE: {\n\t\tu8 min_spacing_to_set;\n\t\tu8 sec_min_space;\n\n\t\tmin_spacing_to_set = *val;\n\t\tif (min_spacing_to_set <= 7) {\n\t\t\tsec_min_space = 0;\n\t\t\tif (min_spacing_to_set < sec_min_space)\n\t\t\t\tmin_spacing_to_set = sec_min_space;\n\t\t\tmac->min_space_cfg = ((mac->min_space_cfg & 0xf8) |\n\t\t\t\t\t      min_spacing_to_set);\n\t\t\t*val = min_spacing_to_set;\n\t\t\trtl_dbg(rtlpriv, COMP_MLME, DBG_LOUD,\n\t\t\t\t\"Set HW_VAR_AMPDU_MIN_SPACE: %#x\\n\",\n\t\t\t\tmac->min_space_cfg);\n\t\t\trtl_write_byte(rtlpriv, REG_AMPDU_MIN_SPACE,\n\t\t\t\t       mac->min_space_cfg);\n\t\t}\n\t\tbreak;\n\t}\n\tcase HW_VAR_SHORTGI_DENSITY: {\n\t\tu8 density_to_set;\n\n\t\tdensity_to_set = *val;\n\t\tmac->min_space_cfg = rtlpriv->rtlhal.minspace_cfg;\n\t\tmac->min_space_cfg |= (density_to_set << 3);\n\t\trtl_dbg(rtlpriv, COMP_MLME, DBG_LOUD,\n\t\t\t\"Set HW_VAR_SHORTGI_DENSITY: %#x\\n\",\n\t\t\tmac->min_space_cfg);\n\t\trtl_write_byte(rtlpriv, REG_AMPDU_MIN_SPACE,\n\t\t\t       mac->min_space_cfg);\n\t\tbreak;\n\t}\n\tcase HW_VAR_AMPDU_FACTOR: {\n\t\tu8 factor_toset;\n\t\tu32 regtoset;\n\t\tu8 *ptmp_byte = NULL;\n\t\tu8 index;\n\n\t\tif (rtlhal->macphymode == DUALMAC_DUALPHY)\n\t\t\tregtoset = 0xb9726641;\n\t\telse if (rtlhal->macphymode == DUALMAC_SINGLEPHY)\n\t\t\tregtoset = 0x66626641;\n\t\telse\n\t\t\tregtoset = 0xb972a841;\n\t\tfactor_toset = *val;\n\t\tif (factor_toset <= 3) {\n\t\t\tfactor_toset = (1 << (factor_toset + 2));\n\t\t\tif (factor_toset > 0xf)\n\t\t\t\tfactor_toset = 0xf;\n\t\t\tfor (index = 0; index < 4; index++) {\n\t\t\t\tptmp_byte = (u8 *)(&regtoset) + index;\n\t\t\t\tif ((*ptmp_byte & 0xf0) >\n\t\t\t\t    (factor_toset << 4))\n\t\t\t\t\t*ptmp_byte = (*ptmp_byte & 0x0f)\n\t\t\t\t\t\t | (factor_toset << 4);\n\t\t\t\tif ((*ptmp_byte & 0x0f) > factor_toset)\n\t\t\t\t\t*ptmp_byte = (*ptmp_byte & 0xf0)\n\t\t\t\t\t\t     | (factor_toset);\n\t\t\t}\n\t\t\trtl_write_dword(rtlpriv, REG_AGGLEN_LMT, regtoset);\n\t\t\trtl_dbg(rtlpriv, COMP_MLME, DBG_LOUD,\n\t\t\t\t\"Set HW_VAR_AMPDU_FACTOR: %#x\\n\",\n\t\t\t\tfactor_toset);\n\t\t}\n\t\tbreak;\n\t}\n\tcase HW_VAR_AC_PARAM: {\n\t\tu8 e_aci = *val;\n\t\trtl92d_dm_init_edca_turbo(hw);\n\t\tif (rtlpci->acm_method != EACMWAY2_SW)\n\t\t\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_ACM_CTRL,\n\t\t\t\t\t\t      &e_aci);\n\t\tbreak;\n\t}\n\tcase HW_VAR_ACM_CTRL: {\n\t\tu8 e_aci = *val;\n\t\tunion aci_aifsn *p_aci_aifsn =\n\t\t    (union aci_aifsn *)(&(mac->ac[0].aifs));\n\t\tu8 acm = p_aci_aifsn->f.acm;\n\t\tu8 acm_ctrl = rtl_read_byte(rtlpriv, REG_ACMHWCTRL);\n\n\t\tacm_ctrl = acm_ctrl | ((rtlpci->acm_method == 2) ?  0x0 : 0x1);\n\t\tif (acm) {\n\t\t\tswitch (e_aci) {\n\t\t\tcase AC0_BE:\n\t\t\t\tacm_ctrl |= ACMHW_BEQEN;\n\t\t\t\tbreak;\n\t\t\tcase AC2_VI:\n\t\t\t\tacm_ctrl |= ACMHW_VIQEN;\n\t\t\t\tbreak;\n\t\t\tcase AC3_VO:\n\t\t\t\tacm_ctrl |= ACMHW_VOQEN;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_WARNING,\n\t\t\t\t\t\"HW_VAR_ACM_CTRL acm set failed: eACI is %d\\n\",\n\t\t\t\t\tacm);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (e_aci) {\n\t\t\tcase AC0_BE:\n\t\t\t\tacm_ctrl &= (~ACMHW_BEQEN);\n\t\t\t\tbreak;\n\t\t\tcase AC2_VI:\n\t\t\t\tacm_ctrl &= (~ACMHW_VIQEN);\n\t\t\t\tbreak;\n\t\t\tcase AC3_VO:\n\t\t\t\tacm_ctrl &= (~ACMHW_VOQEN);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpr_err(\"switch case %#x not processed\\n\",\n\t\t\t\t       e_aci);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trtl_dbg(rtlpriv, COMP_QOS, DBG_TRACE,\n\t\t\t\"SetHwReg8190pci(): [HW_VAR_ACM_CTRL] Write 0x%X\\n\",\n\t\t\tacm_ctrl);\n\t\trtl_write_byte(rtlpriv, REG_ACMHWCTRL, acm_ctrl);\n\t\tbreak;\n\t}\n\tcase HW_VAR_RCR:\n\t\trtl_write_dword(rtlpriv, REG_RCR, ((u32 *) (val))[0]);\n\t\trtlpci->receive_config = ((u32 *) (val))[0];\n\t\tbreak;\n\tcase HW_VAR_RETRY_LIMIT: {\n\t\tu8 retry_limit = val[0];\n\n\t\trtl_write_word(rtlpriv, REG_RL,\n\t\t\t       retry_limit << RETRY_LIMIT_SHORT_SHIFT |\n\t\t\t       retry_limit << RETRY_LIMIT_LONG_SHIFT);\n\t\tbreak;\n\t}\n\tcase HW_VAR_DUAL_TSF_RST:\n\t\trtl_write_byte(rtlpriv, REG_DUAL_TSF_RST, (BIT(0) | BIT(1)));\n\t\tbreak;\n\tcase HW_VAR_EFUSE_BYTES:\n\t\trtlefuse->efuse_usedbytes = *((u16 *) val);\n\t\tbreak;\n\tcase HW_VAR_EFUSE_USAGE:\n\t\trtlefuse->efuse_usedpercentage = *val;\n\t\tbreak;\n\tcase HW_VAR_IO_CMD:\n\t\trtl92d_phy_set_io_cmd(hw, (*(enum io_type *)val));\n\t\tbreak;\n\tcase HW_VAR_WPA_CONFIG:\n\t\trtl_write_byte(rtlpriv, REG_SECCFG, *val);\n\t\tbreak;\n\tcase HW_VAR_SET_RPWM:\n\t\trtl92d_fill_h2c_cmd(hw, H2C_PWRM, 1, (val));\n\t\tbreak;\n\tcase HW_VAR_H2C_FW_PWRMODE:\n\t\tbreak;\n\tcase HW_VAR_FW_PSMODE_STATUS:\n\t\tppsc->fw_current_inpsmode = *((bool *) val);\n\t\tbreak;\n\tcase HW_VAR_H2C_FW_JOINBSSRPT: {\n\t\tu8 mstatus = (*val);\n\t\tu8 tmp_regcr, tmp_reg422;\n\t\tbool recover = false;\n\n\t\tif (mstatus == RT_MEDIA_CONNECT) {\n\t\t\trtlpriv->cfg->ops->set_hw_reg(hw,\n\t\t\t\t\t\t      HW_VAR_AID, NULL);\n\t\t\ttmp_regcr = rtl_read_byte(rtlpriv, REG_CR + 1);\n\t\t\trtl_write_byte(rtlpriv, REG_CR + 1,\n\t\t\t\t       (tmp_regcr | BIT(0)));\n\t\t\t_rtl92de_set_bcn_ctrl_reg(hw, 0, BIT(3));\n\t\t\t_rtl92de_set_bcn_ctrl_reg(hw, BIT(4), 0);\n\t\t\ttmp_reg422 = rtl_read_byte(rtlpriv,\n\t\t\t\t\t\t REG_FWHW_TXQ_CTRL + 2);\n\t\t\tif (tmp_reg422 & BIT(6))\n\t\t\t\trecover = true;\n\t\t\trtl_write_byte(rtlpriv, REG_FWHW_TXQ_CTRL + 2,\n\t\t\t\t       tmp_reg422 & (~BIT(6)));\n\t\t\trtl92d_set_fw_rsvdpagepkt(hw, 0);\n\t\t\t_rtl92de_set_bcn_ctrl_reg(hw, BIT(3), 0);\n\t\t\t_rtl92de_set_bcn_ctrl_reg(hw, 0, BIT(4));\n\t\t\tif (recover)\n\t\t\t\trtl_write_byte(rtlpriv,\n\t\t\t\t\t       REG_FWHW_TXQ_CTRL + 2,\n\t\t\t\t\t       tmp_reg422);\n\t\t\trtl_write_byte(rtlpriv, REG_CR + 1,\n\t\t\t\t       (tmp_regcr & ~(BIT(0))));\n\t\t}\n\t\trtl92d_set_fw_joinbss_report_cmd(hw, (*val));\n\t\tbreak;\n\t}\n\tcase HW_VAR_AID: {\n\t\tu16 u2btmp;\n\t\tu2btmp = rtl_read_word(rtlpriv, REG_BCN_PSR_RPT);\n\t\tu2btmp &= 0xC000;\n\t\trtl_write_word(rtlpriv, REG_BCN_PSR_RPT, (u2btmp |\n\t\t\t       mac->assoc_id));\n\t\tbreak;\n\t}\n\tcase HW_VAR_CORRECT_TSF: {\n\t\tu8 btype_ibss = val[0];\n\n\t\tif (btype_ibss)\n\t\t\t_rtl92de_stop_tx_beacon(hw);\n\t\t_rtl92de_set_bcn_ctrl_reg(hw, 0, BIT(3));\n\t\trtl_write_dword(rtlpriv, REG_TSFTR,\n\t\t\t\t(u32) (mac->tsf & 0xffffffff));\n\t\trtl_write_dword(rtlpriv, REG_TSFTR + 4,\n\t\t\t\t(u32) ((mac->tsf >> 32) & 0xffffffff));\n\t\t_rtl92de_set_bcn_ctrl_reg(hw, BIT(3), 0);\n\t\tif (btype_ibss)\n\t\t\t_rtl92de_resume_tx_beacon(hw);\n\n\t\tbreak;\n\t}\n\tcase HW_VAR_INT_MIGRATION: {\n\t\tbool int_migration = *(bool *) (val);\n\n\t\tif (int_migration) {\n\t\t\t \n\t\t\trtl_write_dword(rtlpriv, REG_INT_MIG, 0xfe000fa0);\n\t\t\trtlpriv->dm.interrupt_migration = int_migration;\n\t\t} else {\n\t\t\t \n\t\t\trtl_write_dword(rtlpriv, REG_INT_MIG, 0);\n\t\t\trtlpriv->dm.interrupt_migration = int_migration;\n\t\t}\n\t\tbreak;\n\t}\n\tcase HW_VAR_INT_AC: {\n\t\tbool disable_ac_int = *((bool *) val);\n\n\t\t \n\t\tif (disable_ac_int) {\n\t\t\t \n\t\t\trtlpriv->cfg->ops->update_interrupt_mask(hw, 0,\n\t\t\t\t\t\t RT_AC_INT_MASKS);\n\t\t\trtlpriv->dm.disable_tx_int = disable_ac_int;\n\t\t \n\t\t} else {\n\t\t\trtlpriv->cfg->ops->update_interrupt_mask(hw,\n\t\t\t\t\t\t RT_AC_INT_MASKS, 0);\n\t\t\trtlpriv->dm.disable_tx_int = disable_ac_int;\n\t\t}\n\t\tbreak;\n\t}\n\tdefault:\n\t\tpr_err(\"switch case %#x not processed\\n\", variable);\n\t\tbreak;\n\t}\n}\n\nstatic bool _rtl92de_llt_write(struct ieee80211_hw *hw, u32 address, u32 data)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tbool status = true;\n\tlong count = 0;\n\tu32 value = _LLT_INIT_ADDR(address) |\n\t    _LLT_INIT_DATA(data) | _LLT_OP(_LLT_WRITE_ACCESS);\n\n\trtl_write_dword(rtlpriv, REG_LLT_INIT, value);\n\tdo {\n\t\tvalue = rtl_read_dword(rtlpriv, REG_LLT_INIT);\n\t\tif (_LLT_NO_ACTIVE == _LLT_OP_VALUE(value))\n\t\t\tbreak;\n\t\tif (count > POLLING_LLT_THRESHOLD) {\n\t\t\tpr_err(\"Failed to polling write LLT done at address %d!\\n\",\n\t\t\t       address);\n\t\t\tstatus = false;\n\t\t\tbreak;\n\t\t}\n\t} while (++count);\n\treturn status;\n}\n\nstatic bool _rtl92de_llt_table_init(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tunsigned short i;\n\tu8 txpktbuf_bndy;\n\tu8 maxpage;\n\tbool status;\n\tu32 value32;  \n\tu8 value8;\t  \n\n\tif (rtlpriv->rtlhal.macphymode == SINGLEMAC_SINGLEPHY) {\n\t\tmaxpage = 255;\n\t\ttxpktbuf_bndy = 246;\n\t\tvalue8 = 0;\n\t\tvalue32 = 0x80bf0d29;\n\t} else {\n\t\tmaxpage = 127;\n\t\ttxpktbuf_bndy = 123;\n\t\tvalue8 = 0;\n\t\tvalue32 = 0x80750005;\n\t}\n\n\t \n\t \n\t \n\trtl_write_byte(rtlpriv, REG_RQPN_NPQ, value8);\n\trtl_write_dword(rtlpriv, REG_RQPN, value32);\n\n\t \n\t \n\trtl_write_dword(rtlpriv, REG_TRXFF_BNDY,\n\t\t\t(rtl_read_word(rtlpriv, REG_TRXFF_BNDY + 2) << 16 |\n\t\t\ttxpktbuf_bndy));\n\n\t \n\t \n\trtl_write_byte(rtlpriv, REG_TDECTRL + 1, txpktbuf_bndy);\n\n\t \n\t \n\trtl_write_byte(rtlpriv, REG_TXPKTBUF_BCNQ_BDNY, txpktbuf_bndy);\n\trtl_write_byte(rtlpriv, REG_TXPKTBUF_MGQ_BDNY, txpktbuf_bndy);\n\n\t \n\t \n\trtl_write_byte(rtlpriv, 0x45D, txpktbuf_bndy);\n\n\t \n\t \n\t \n\t \n\trtl_write_byte(rtlpriv, REG_PBP, 0x11);\n\n\t \n\trtl_write_byte(rtlpriv, REG_RX_DRVINFO_SZ, 0x4);\n\n\t \n\tfor (i = 0; i < (txpktbuf_bndy - 1); i++) {\n\t\tstatus = _rtl92de_llt_write(hw, i, i + 1);\n\t\tif (!status)\n\t\t\treturn status;\n\t}\n\n\t \n\tstatus = _rtl92de_llt_write(hw, (txpktbuf_bndy - 1), 0xFF);\n\tif (!status)\n\t\treturn status;\n\n\t \n\t \n\t \n\t \n\tfor (i = txpktbuf_bndy; i < maxpage; i++) {\n\t\tstatus = _rtl92de_llt_write(hw, i, (i + 1));\n\t\tif (!status)\n\t\t\treturn status;\n\t}\n\n\t \n\tstatus = _rtl92de_llt_write(hw, maxpage, txpktbuf_bndy);\n\tif (!status)\n\t\treturn status;\n\n\treturn true;\n}\n\nstatic void _rtl92de_gen_refresh_led_state(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tenum rtl_led_pin pin0 = rtlpriv->ledctl.sw_led0;\n\n\tif (rtlpci->up_first_time)\n\t\treturn;\n\tif (ppsc->rfoff_reason == RF_CHANGE_BY_IPS)\n\t\trtl92de_sw_led_on(hw, pin0);\n\telse if (ppsc->rfoff_reason == RF_CHANGE_BY_INIT)\n\t\trtl92de_sw_led_on(hw, pin0);\n\telse\n\t\trtl92de_sw_led_off(hw, pin0);\n}\n\nstatic bool _rtl92de_init_mac(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tunsigned char bytetmp;\n\tunsigned short wordtmp;\n\tu16 retry;\n\n\trtl92d_phy_set_poweron(hw);\n\t \n\t \n\t \n\trtl_write_byte(rtlpriv, REG_RSV_CTRL, 0x00);\n\trtl_write_byte(rtlpriv, REG_LDOA15_CTRL, 0x05);\n\n\t \n\t \n\t \n\n\t \n\t \n\trtl_write_byte(rtlpriv, REG_SPS0_CTRL, 0x2b);\n\n\t \n\trtl_write_byte(rtlpriv, REG_AFE_XTAL_CTRL, 0x0F);\n\n\t \n\n\t \n\t \n\t \n\tbytetmp = rtl_read_byte(rtlpriv, REG_APS_FSMCO + 1) | BIT(0);\n\tudelay(2);\n\trtl_write_byte(rtlpriv, REG_APS_FSMCO + 1, bytetmp);\n\tudelay(2);\n\n\t \n\tbytetmp = rtl_read_byte(rtlpriv, REG_APS_FSMCO + 1);\n\tudelay(50);\n\tretry = 0;\n\twhile ((bytetmp & BIT(0)) && retry < 1000) {\n\t\tretry++;\n\t\tbytetmp = rtl_read_byte(rtlpriv, REG_APS_FSMCO + 1);\n\t\tudelay(50);\n\t}\n\n\t \n\t \n\trtl_write_word(rtlpriv, REG_APS_FSMCO, 0x1012);\n\n\t \n\t \n\t \n\trtl_write_byte(rtlpriv, REG_SYS_ISO_CTRL + 1, 0x82);\n\tudelay(2);\n\n\t \n\t \n\n\t \n\trtl_write_word(rtlpriv, REG_CR, 0x0);\n\n\t \n\trtl_write_word(rtlpriv, REG_CR, 0x2ff);\n\n\t \n\trtl_write_byte(rtlpriv, REG_PCIE_CTRL_REG + 1, 0x0);\n\n\t \n\n\t \n\t \n\tif (!_rtl92de_llt_table_init(hw))\n\t\treturn false;\n\n\t \n\t \n\t \n\trtl_write_dword(rtlpriv, REG_HISR, 0xffffffff);\n\trtl_write_byte(rtlpriv, REG_HISRE, 0xff);\n\n\t \n\t \n\t \n\n\t \n\t \n\t \n\t \n\n\trtl92d_phy_config_maccoexist_rfpage(hw);\n\n\t \n\t \n\t \n\twordtmp = rtl_read_word(rtlpriv, REG_TRXDMA_CTRL);\n\twordtmp &= 0xf;\n\twordtmp |= 0xF771;\n\trtl_write_word(rtlpriv, REG_TRXDMA_CTRL, wordtmp);\n\n\t \n\t \n\t \n\trtl_write_byte(rtlpriv, REG_FWHW_TXQ_CTRL + 1, 0x1F);\n\n\t \n\t \n\n\t \n\trtl_write_dword(rtlpriv, REG_RCR, rtlpci->receive_config);\n\t \n\n\t \n\trtl_write_dword(rtlpriv, REG_TCR, rtlpci->transmit_config);\n\n\t \n\trtl_write_byte(rtlpriv, 0x4d0, 0x0);\n\n\t \n\trtl_write_dword(rtlpriv, REG_BCNQ_DESA,\n\t\t\trtlpci->tx_ring[BEACON_QUEUE].dma);\n\trtl_write_dword(rtlpriv, REG_MGQ_DESA, rtlpci->tx_ring[MGNT_QUEUE].dma);\n\trtl_write_dword(rtlpriv, REG_VOQ_DESA, rtlpci->tx_ring[VO_QUEUE].dma);\n\trtl_write_dword(rtlpriv, REG_VIQ_DESA, rtlpci->tx_ring[VI_QUEUE].dma);\n\trtl_write_dword(rtlpriv, REG_BEQ_DESA, rtlpci->tx_ring[BE_QUEUE].dma);\n\trtl_write_dword(rtlpriv, REG_BKQ_DESA, rtlpci->tx_ring[BK_QUEUE].dma);\n\trtl_write_dword(rtlpriv, REG_HQ_DESA, rtlpci->tx_ring[HIGH_QUEUE].dma);\n\t \n\trtl_write_dword(rtlpriv, REG_RX_DESA,\n\t\t\trtlpci->rx_ring[RX_MPDU_QUEUE].dma);\n\n\t \n\n\trtl_write_byte(rtlpriv, REG_PCIE_CTRL_REG + 3, 0x33);\n\n\t \n\trtl_write_dword(rtlpriv, REG_INT_MIG, 0);\n\n\t \n\tbytetmp = rtl_read_byte(rtlpriv, REG_APSD_CTRL);\n\trtl_write_byte(rtlpriv, REG_APSD_CTRL, bytetmp & ~BIT(6));\n\tdo {\n\t\tretry++;\n\t\tbytetmp = rtl_read_byte(rtlpriv, REG_APSD_CTRL);\n\t} while ((retry < 200) && !(bytetmp & BIT(7)));\n\n\t \n\t_rtl92de_gen_refresh_led_state(hw);\n\n\t \n\trtl_write_dword(rtlpriv, REG_MCUTST_1, 0x0);\n\n\treturn true;\n}\n\nstatic void _rtl92de_hw_configure(struct ieee80211_hw *hw)\n{\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tu8 reg_bw_opmode = BW_OPMODE_20MHZ;\n\tu32 reg_rrsr;\n\n\treg_rrsr = RATE_ALL_CCK | RATE_ALL_OFDM_AG;\n\trtl_write_byte(rtlpriv, REG_INIRTS_RATE_SEL, 0x8);\n\trtl_write_byte(rtlpriv, REG_BWOPMODE, reg_bw_opmode);\n\trtl_write_dword(rtlpriv, REG_RRSR, reg_rrsr);\n\trtl_write_byte(rtlpriv, REG_SLOT, 0x09);\n\trtl_write_byte(rtlpriv, REG_AMPDU_MIN_SPACE, 0x0);\n\trtl_write_word(rtlpriv, REG_FWHW_TXQ_CTRL, 0x1F80);\n\trtl_write_word(rtlpriv, REG_RL, 0x0707);\n\trtl_write_dword(rtlpriv, REG_BAR_MODE_CTRL, 0x02012802);\n\trtl_write_byte(rtlpriv, REG_HWSEQ_CTRL, 0xFF);\n\trtl_write_dword(rtlpriv, REG_DARFRC, 0x01000000);\n\trtl_write_dword(rtlpriv, REG_DARFRC + 4, 0x07060504);\n\trtl_write_dword(rtlpriv, REG_RARFRC, 0x01000000);\n\trtl_write_dword(rtlpriv, REG_RARFRC + 4, 0x07060504);\n\t \n\tif (rtlhal->macphymode == DUALMAC_DUALPHY)\n\t\trtl_write_dword(rtlpriv, REG_AGGLEN_LMT, 0xb9726641);\n\telse if (rtlhal->macphymode == DUALMAC_SINGLEPHY)\n\t\trtl_write_dword(rtlpriv, REG_AGGLEN_LMT, 0x66626641);\n\telse\n\t\trtl_write_dword(rtlpriv, REG_AGGLEN_LMT, 0xb972a841);\n\trtl_write_byte(rtlpriv, REG_ATIMWND, 0x2);\n\trtl_write_byte(rtlpriv, REG_BCN_MAX_ERR, 0x0a);\n\trtlpci->reg_bcn_ctrl_val = 0x1f;\n\trtl_write_byte(rtlpriv, REG_BCN_CTRL, rtlpci->reg_bcn_ctrl_val);\n\trtl_write_byte(rtlpriv, REG_TBTT_PROHIBIT + 1, 0xff);\n\trtl_write_byte(rtlpriv, REG_PIFS, 0x1C);\n\trtl_write_byte(rtlpriv, REG_AGGR_BREAK_TIME, 0x16);\n\trtl_write_word(rtlpriv, REG_NAV_PROT_LEN, 0x0020);\n\t \n\trtl_write_word(rtlpriv, REG_FAST_EDCA_CTRL, 0x6666);\n\t \n\trtl_write_byte(rtlpriv, REG_ACKTO, 0x40);\n\t \n\trtl_write_word(rtlpriv, REG_SPEC_SIFS, 0x1010);\n\trtl_write_word(rtlpriv, REG_MAC_SPEC_SIFS, 0x1010);\n\t \n\trtl_write_word(rtlpriv, REG_SIFS_CTX, 0x1010);\n\t \n\trtl_write_word(rtlpriv, REG_SIFS_TRX, 0x1010);\n\t \n\trtl_write_dword(rtlpriv, REG_MAR, 0xffffffff);\n\trtl_write_dword(rtlpriv, REG_MAR + 4, 0xffffffff);\n\tswitch (rtlpriv->phy.rf_type) {\n\tcase RF_1T2R:\n\tcase RF_1T1R:\n\t\trtlhal->minspace_cfg = (MAX_MSS_DENSITY_1T << 3);\n\t\tbreak;\n\tcase RF_2T2R:\n\tcase RF_2T2R_GREEN:\n\t\trtlhal->minspace_cfg = (MAX_MSS_DENSITY_2T << 3);\n\t\tbreak;\n\t}\n}\n\nstatic void _rtl92de_enable_aspm_back_door(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\n\trtl_write_byte(rtlpriv, 0x34b, 0x93);\n\trtl_write_word(rtlpriv, 0x350, 0x870c);\n\trtl_write_byte(rtlpriv, 0x352, 0x1);\n\tif (ppsc->support_backdoor)\n\t\trtl_write_byte(rtlpriv, 0x349, 0x1b);\n\telse\n\t\trtl_write_byte(rtlpriv, 0x349, 0x03);\n\trtl_write_word(rtlpriv, 0x350, 0x2718);\n\trtl_write_byte(rtlpriv, 0x352, 0x1);\n}\n\nvoid rtl92de_enable_hw_security_config(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 sec_reg_value;\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\"PairwiseEncAlgorithm = %d GroupEncAlgorithm = %d\\n\",\n\t\trtlpriv->sec.pairwise_enc_algorithm,\n\t\trtlpriv->sec.group_enc_algorithm);\n\tif (rtlpriv->cfg->mod_params->sw_crypto || rtlpriv->sec.use_sw_sec) {\n\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_DMESG,\n\t\t\t\"not open hw encryption\\n\");\n\t\treturn;\n\t}\n\tsec_reg_value = SCR_TXENCENABLE | SCR_RXENCENABLE;\n\tif (rtlpriv->sec.use_defaultkey) {\n\t\tsec_reg_value |= SCR_TXUSEDK;\n\t\tsec_reg_value |= SCR_RXUSEDK;\n\t}\n\tsec_reg_value |= (SCR_RXBCUSEDK | SCR_TXBCUSEDK);\n\trtl_write_byte(rtlpriv, REG_CR + 1, 0x02);\n\trtl_dbg(rtlpriv, COMP_SEC, DBG_LOUD,\n\t\t\"The SECR-value %x\\n\", sec_reg_value);\n\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_WPA_CONFIG, &sec_reg_value);\n}\n\nint rtl92de_hw_init(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tbool rtstatus = true;\n\tu8 tmp_u1b;\n\tint i;\n\tint err;\n\tunsigned long flags;\n\n\trtlpci->being_init_adapter = true;\n\trtlpci->init_ready = false;\n\tspin_lock_irqsave(&globalmutex_for_power_and_efuse, flags);\n\t \n\trtl92d_phy_reset_iqk_result(hw);\n\t \n\trtstatus = _rtl92de_init_mac(hw);\n\tif (!rtstatus) {\n\t\tpr_err(\"Init MAC failed\\n\");\n\t\terr = 1;\n\t\tspin_unlock_irqrestore(&globalmutex_for_power_and_efuse, flags);\n\t\treturn err;\n\t}\n\terr = rtl92d_download_fw(hw);\n\tspin_unlock_irqrestore(&globalmutex_for_power_and_efuse, flags);\n\tif (err) {\n\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_WARNING,\n\t\t\t\"Failed to download FW. Init HW without FW..\\n\");\n\t\treturn 1;\n\t}\n\trtlhal->last_hmeboxnum = 0;\n\trtlpriv->psc.fw_current_inpsmode = false;\n\n\ttmp_u1b = rtl_read_byte(rtlpriv, 0x605);\n\ttmp_u1b = tmp_u1b | 0x30;\n\trtl_write_byte(rtlpriv, 0x605, tmp_u1b);\n\n\tif (rtlhal->earlymode_enable) {\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\"EarlyMode Enabled!!!\\n\");\n\n\t\ttmp_u1b = rtl_read_byte(rtlpriv, 0x4d0);\n\t\ttmp_u1b = tmp_u1b | 0x1f;\n\t\trtl_write_byte(rtlpriv, 0x4d0, tmp_u1b);\n\n\t\trtl_write_byte(rtlpriv, 0x4d3, 0x80);\n\n\t\ttmp_u1b = rtl_read_byte(rtlpriv, 0x605);\n\t\ttmp_u1b = tmp_u1b | 0x40;\n\t\trtl_write_byte(rtlpriv, 0x605, tmp_u1b);\n\t}\n\n\tif (mac->rdg_en) {\n\t\trtl_write_byte(rtlpriv, REG_RD_CTRL, 0xff);\n\t\trtl_write_word(rtlpriv, REG_RD_NAV_NXT, 0x200);\n\t\trtl_write_byte(rtlpriv, REG_RD_RESP_PKT_TH, 0x05);\n\t}\n\n\trtl92d_phy_mac_config(hw);\n\t \n\trtlpci->receive_config = rtl_read_dword(rtlpriv, REG_RCR);\n\trtlpci->receive_config &= ~(RCR_ACRC32 | RCR_AICV);\n\n\trtl92d_phy_bb_config(hw);\n\n\trtlphy->rf_mode = RF_OP_BY_SW_3WIRE;\n\t \n\trtl_set_bbreg(hw, RFPGA0_ANALOGPARAMETER4, 0x00f00000, 0xf);\n\n\t \n\trtl92d_phy_rf_config(hw);\n\n\t \n\t \n\trtl92d_update_bbrf_configuration(hw);\n\t \n\trtl_set_bbreg(hw, RFPGA0_ANALOGPARAMETER4, 0x00f00000, 0);\n\trtlphy->rfreg_chnlval[0] = rtl_get_rfreg(hw, (enum radio_path)0,\n\t\t\tRF_CHNLBW, RFREG_OFFSET_MASK);\n\trtlphy->rfreg_chnlval[1] = rtl_get_rfreg(hw, (enum radio_path)1,\n\t\t\tRF_CHNLBW, RFREG_OFFSET_MASK);\n\n\t \n\tif (rtlhal->current_bandtype == BAND_ON_2_4G)\n\t\trtl_set_bbreg(hw, RFPGA0_RFMOD, BCCKEN, 0x1);\n\trtl_set_bbreg(hw, RFPGA0_RFMOD, BOFDMEN, 0x1);\n\tif (rtlhal->interfaceindex == 0) {\n\t\t \n\t\trtl_set_bbreg(hw, RFPGA0_ANALOGPARAMETER2, BIT(10) |\n\t\t\t      BIT(11), 3);\n\t} else {\n\t\t \n\t\trtl_set_bbreg(hw, RFPGA0_ANALOGPARAMETER2, BIT(11) |\n\t\t\t      BIT(10), 3);\n\t}\n\n\t_rtl92de_hw_configure(hw);\n\n\t \n\trtl_cam_reset_all_entry(hw);\n\trtl92de_enable_hw_security_config(hw);\n\n\t \n\t \n\trtl92d_phy_get_hw_reg_originalvalue(hw);\n\trtl92d_phy_set_txpower_level(hw, rtlphy->current_channel);\n\n\tppsc->rfpwr_state = ERFON;\n\n\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_ETHER_ADDR, mac->mac_addr);\n\n\t_rtl92de_enable_aspm_back_door(hw);\n\t \n\n\trtl92d_dm_init(hw);\n\trtlpci->being_init_adapter = false;\n\n\tif (ppsc->rfpwr_state == ERFON) {\n\t\trtl92d_phy_lc_calibrate(hw);\n\t\t \n\t\tif (rtlhal->macphymode == DUALMAC_DUALPHY) {\n\t\t\tu32 tmp_rega;\n\t\t\tfor (i = 0; i < 10000; i++) {\n\t\t\t\tudelay(MAX_STALL_TIME);\n\n\t\t\t\ttmp_rega = rtl_get_rfreg(hw,\n\t\t\t\t\t\t  (enum radio_path)RF90_PATH_A,\n\t\t\t\t\t\t  0x2a, MASKDWORD);\n\n\t\t\t\tif (((tmp_rega & BIT(11)) == BIT(11)))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tif (i == 10000) {\n\t\t\t\trtlpci->init_ready = false;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\trtlpci->init_ready = true;\n\treturn err;\n}\n\nstatic enum version_8192d _rtl92de_read_chip_version(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tenum version_8192d version = VERSION_NORMAL_CHIP_92D_SINGLEPHY;\n\tu32 value32;\n\n\tvalue32 = rtl_read_dword(rtlpriv, REG_SYS_CFG);\n\tif (!(value32 & 0x000f0000)) {\n\t\tversion = VERSION_TEST_CHIP_92D_SINGLEPHY;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD, \"TEST CHIP!!!\\n\");\n\t} else {\n\t\tversion = VERSION_NORMAL_CHIP_92D_SINGLEPHY;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD, \"Normal CHIP!!!\\n\");\n\t}\n\treturn version;\n}\n\nstatic int _rtl92de_set_media_status(struct ieee80211_hw *hw,\n\t\t\t\t     enum nl80211_iftype type)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 bt_msr = rtl_read_byte(rtlpriv, MSR);\n\tenum led_ctl_mode ledaction = LED_CTL_NO_LINK;\n\n\tbt_msr &= 0xfc;\n\n\tif (type == NL80211_IFTYPE_UNSPECIFIED ||\n\t    type == NL80211_IFTYPE_STATION) {\n\t\t_rtl92de_stop_tx_beacon(hw);\n\t\t_rtl92de_enable_bcn_sub_func(hw);\n\t} else if (type == NL80211_IFTYPE_ADHOC ||\n\t\ttype == NL80211_IFTYPE_AP) {\n\t\t_rtl92de_resume_tx_beacon(hw);\n\t\t_rtl92de_disable_bcn_sub_func(hw);\n\t} else {\n\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_WARNING,\n\t\t\t\"Set HW_VAR_MEDIA_STATUS: No such media status(%x)\\n\",\n\t\t\ttype);\n\t}\n\tswitch (type) {\n\tcase NL80211_IFTYPE_UNSPECIFIED:\n\t\tbt_msr |= MSR_NOLINK;\n\t\tledaction = LED_CTL_LINK;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\t\"Set Network type to NO LINK!\\n\");\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tbt_msr |= MSR_ADHOC;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\t\"Set Network type to Ad Hoc!\\n\");\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tbt_msr |= MSR_INFRA;\n\t\tledaction = LED_CTL_LINK;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\t\"Set Network type to STA!\\n\");\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\t\tbt_msr |= MSR_AP;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\t\"Set Network type to AP!\\n\");\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Network type %d not supported!\\n\", type);\n\t\treturn 1;\n\t}\n\trtl_write_byte(rtlpriv, MSR, bt_msr);\n\trtlpriv->cfg->ops->led_control(hw, ledaction);\n\tif ((bt_msr & MSR_MASK) == MSR_AP)\n\t\trtl_write_byte(rtlpriv, REG_BCNTCFG + 1, 0x00);\n\telse\n\t\trtl_write_byte(rtlpriv, REG_BCNTCFG + 1, 0x66);\n\treturn 0;\n}\n\nvoid rtl92de_set_check_bssid(struct ieee80211_hw *hw, bool check_bssid)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 reg_rcr;\n\n\tif (rtlpriv->psc.rfpwr_state != ERFON)\n\t\treturn;\n\n\trtlpriv->cfg->ops->get_hw_reg(hw, HW_VAR_RCR, (u8 *)(&reg_rcr));\n\n\tif (check_bssid) {\n\t\treg_rcr |= (RCR_CBSSID_DATA | RCR_CBSSID_BCN);\n\t\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_RCR, (u8 *)(&reg_rcr));\n\t\t_rtl92de_set_bcn_ctrl_reg(hw, 0, BIT(4));\n\t} else if (!check_bssid) {\n\t\treg_rcr &= (~(RCR_CBSSID_DATA | RCR_CBSSID_BCN));\n\t\t_rtl92de_set_bcn_ctrl_reg(hw, BIT(4), 0);\n\t\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_RCR, (u8 *)(&reg_rcr));\n\t}\n}\n\nint rtl92de_set_network_type(struct ieee80211_hw *hw, enum nl80211_iftype type)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\tif (_rtl92de_set_media_status(hw, type))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (rtlpriv->mac80211.link_state == MAC80211_LINKED) {\n\t\tif (type != NL80211_IFTYPE_AP)\n\t\t\trtl92de_set_check_bssid(hw, true);\n\t} else {\n\t\trtl92de_set_check_bssid(hw, false);\n\t}\n\treturn 0;\n}\n\n \n \nvoid rtl92d_linked_set_reg(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tu8 indexforchannel;\n\tu8 channel = rtlphy->current_channel;\n\n\tindexforchannel = rtl92d_get_rightchnlplace_for_iqk(channel);\n\tif (!rtlphy->iqk_matrix[indexforchannel].iqk_done) {\n\t\trtl_dbg(rtlpriv, COMP_SCAN | COMP_INIT, DBG_DMESG,\n\t\t\t\"Do IQK for channel:%d\\n\", channel);\n\t\trtl92d_phy_iq_calibrate(hw);\n\t}\n}\n\n \nvoid rtl92de_set_qos(struct ieee80211_hw *hw, int aci)\n{\n\trtl92d_dm_init_edca_turbo(hw);\n}\n\nvoid rtl92de_enable_interrupt(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\n\trtl_write_dword(rtlpriv, REG_HIMR, rtlpci->irq_mask[0] & 0xFFFFFFFF);\n\trtl_write_dword(rtlpriv, REG_HIMRE, rtlpci->irq_mask[1] & 0xFFFFFFFF);\n\trtlpci->irq_enabled = true;\n}\n\nvoid rtl92de_disable_interrupt(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\n\trtl_write_dword(rtlpriv, REG_HIMR, IMR8190_DISABLED);\n\trtl_write_dword(rtlpriv, REG_HIMRE, IMR8190_DISABLED);\n\trtlpci->irq_enabled = false;\n}\n\nstatic void _rtl92de_poweroff_adapter(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 u1b_tmp;\n\tunsigned long flags;\n\n\trtlpriv->intf_ops->enable_aspm(hw);\n\trtl_write_byte(rtlpriv, REG_RF_CTRL, 0x00);\n\trtl_set_bbreg(hw, RFPGA0_XCD_RFPARAMETER, BIT(3), 0);\n\trtl_set_bbreg(hw, RFPGA0_XCD_RFPARAMETER, BIT(15), 0);\n\n\t \n\trtl_write_byte(rtlpriv, REG_LDOA15_CTRL, 0x04);\n\n\t \n\trtl92d_firmware_selfreset(hw);\n\n\t \n\trtl_write_byte(rtlpriv, REG_SYS_FUNC_EN + 1, 0x51);\n\n\t \n\trtl_write_byte(rtlpriv, REG_MCUFWDL, 0x00);\n\n\t \n\n\t \n\trtl_write_dword(rtlpriv, REG_GPIO_PIN_CTRL, 0x00000000);\n\n\t \n\tu1b_tmp = rtl_read_byte(rtlpriv, REG_GPIO_PIN_CTRL);\n\n\t \n\t \n\trtl_write_dword(rtlpriv, REG_GPIO_PIN_CTRL,\n\t\t\t0x00FF0000 | (u1b_tmp << 8));\n\n\t \n\trtl_write_word(rtlpriv, REG_GPIO_IO_SEL, 0x0790);\n\n\t \n\trtl_write_word(rtlpriv, REG_LEDCFG0, 0x8080);\n\n\t \n\n\t \n\trtl_write_byte(rtlpriv, REG_AFE_PLL_CTRL, 0x80);\n\n\t \n\trtl_write_byte(rtlpriv, REG_SPS0_CTRL, 0x23);\n\n\t \n\trtl_write_byte(rtlpriv, REG_AFE_XTAL_CTRL, 0x0e);\n\n\t \n\trtl_write_byte(rtlpriv, REG_RSV_CTRL, 0x0e);\n\n\t \n\n\t \n\t \n\t \n\t \n\t \n\t \n\trtl_write_byte(rtlpriv, REG_APS_FSMCO + 1, 0x10);\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\"In PowerOff,reg0x%x=%X\\n\",\n\t\tREG_SPS0_CTRL, rtl_read_byte(rtlpriv, REG_SPS0_CTRL));\n\t \n\t \n\n\t \n\tif (rtlpriv->rtlhal.macphymode != SINGLEMAC_SINGLEPHY) {\n\t\tspin_lock_irqsave(&globalmutex_power, flags);\n\t\tu1b_tmp = rtl_read_byte(rtlpriv, REG_POWER_OFF_IN_PROCESS);\n\t\tu1b_tmp &= (~BIT(7));\n\t\trtl_write_byte(rtlpriv, REG_POWER_OFF_IN_PROCESS, u1b_tmp);\n\t\tspin_unlock_irqrestore(&globalmutex_power, flags);\n\t}\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD, \"<=======\\n\");\n}\n\nvoid rtl92de_card_disable(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tenum nl80211_iftype opmode;\n\n\tmac->link_state = MAC80211_NOLINK;\n\topmode = NL80211_IFTYPE_UNSPECIFIED;\n\t_rtl92de_set_media_status(hw, opmode);\n\n\tif (rtlpci->driver_is_goingto_unload ||\n\t    ppsc->rfoff_reason > RF_CHANGE_BY_PS)\n\t\trtlpriv->cfg->ops->led_control(hw, LED_CTL_POWER_OFF);\n\tRT_SET_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_HALT_NIC);\n\t \n\t \n\t \n\t \n\t \n\t \n\n\t \n\trtl_write_byte(rtlpriv, REG_PCIE_CTRL_REG + 1, 0xFE);\n\tudelay(50);\n\n\t \n\n\t \n\t \n\trtl_set_bbreg(hw, RFPGA0_ANALOGPARAMETER4, 0x00f00000, 0xf);\n\trtl_set_rfreg(hw, RF90_PATH_A, 0x00, RFREG_OFFSET_MASK, 0x00);\n\n\t \n\trtl_write_byte(rtlpriv, REG_APSD_CTRL, 0x40);\n\n\t \n\trtl_set_bbreg(hw, ROFDM0_TRXPATHENABLE, MASKBYTE0, 0);\n\trtl_set_bbreg(hw, ROFDM1_TRXPATHENABLE, BDWORD, 0);\n\n\t \n\trtl_write_byte(rtlpriv, REG_SYS_FUNC_EN, 0xE2);\n\n\t \n\t \n\tif (rtlpriv->rtlhal.interfaceindex == 1)\n\t\trtl_write_byte(rtlpriv, REG_SYS_FUNC_EN, 0xE0);\n\tudelay(50);\n\n\t \n\t \n\trtl_write_byte(rtlpriv, REG_PCIE_CTRL_REG + 1, 0xff);\n\tudelay(50);\n\trtl_write_byte(rtlpriv, REG_CR, 0x0);\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD, \"==> Do power off.......\\n\");\n\tif (rtl92d_phy_check_poweroff(hw))\n\t\t_rtl92de_poweroff_adapter(hw);\n\treturn;\n}\n\nvoid rtl92de_interrupt_recognized(struct ieee80211_hw *hw,\n\t\t\t\t  struct rtl_int *intvec)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\n\tintvec->inta = rtl_read_dword(rtlpriv, ISR) & rtlpci->irq_mask[0];\n\trtl_write_dword(rtlpriv, ISR, intvec->inta);\n}\n\nvoid rtl92de_set_beacon_related_registers(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tu16 bcn_interval, atim_window;\n\n\tbcn_interval = mac->beacon_interval;\n\tatim_window = 2;\n\trtl92de_disable_interrupt(hw);\n\trtl_write_word(rtlpriv, REG_ATIMWND, atim_window);\n\trtl_write_word(rtlpriv, REG_BCN_INTERVAL, bcn_interval);\n\trtl_write_word(rtlpriv, REG_BCNTCFG, 0x660f);\n\trtl_write_byte(rtlpriv, REG_RXTSF_OFFSET_CCK, 0x20);\n\tif (rtlpriv->rtlhal.current_bandtype == BAND_ON_5G)\n\t\trtl_write_byte(rtlpriv, REG_RXTSF_OFFSET_OFDM, 0x30);\n\telse\n\t\trtl_write_byte(rtlpriv, REG_RXTSF_OFFSET_OFDM, 0x20);\n\trtl_write_byte(rtlpriv, 0x606, 0x30);\n}\n\nvoid rtl92de_set_beacon_interval(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tu16 bcn_interval = mac->beacon_interval;\n\n\trtl_dbg(rtlpriv, COMP_BEACON, DBG_DMESG,\n\t\t\"beacon_interval:%d\\n\", bcn_interval);\n\trtl92de_disable_interrupt(hw);\n\trtl_write_word(rtlpriv, REG_BCN_INTERVAL, bcn_interval);\n\trtl92de_enable_interrupt(hw);\n}\n\nvoid rtl92de_update_interrupt_mask(struct ieee80211_hw *hw,\n\t\t\t\t   u32 add_msr, u32 rm_msr)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\n\trtl_dbg(rtlpriv, COMP_INTR, DBG_LOUD, \"add_msr:%x, rm_msr:%x\\n\",\n\t\tadd_msr, rm_msr);\n\tif (add_msr)\n\t\trtlpci->irq_mask[0] |= add_msr;\n\tif (rm_msr)\n\t\trtlpci->irq_mask[0] &= (~rm_msr);\n\trtl92de_disable_interrupt(hw);\n\trtl92de_enable_interrupt(hw);\n}\n\nstatic void _rtl92de_readpowervalue_fromprom(struct txpower_info *pwrinfo,\n\t\t\t\t u8 *rom_content, bool autoloadfail)\n{\n\tu32 rfpath, eeaddr, group, offset1, offset2;\n\tu8 i;\n\n\tmemset(pwrinfo, 0, sizeof(struct txpower_info));\n\tif (autoloadfail) {\n\t\tfor (group = 0; group < CHANNEL_GROUP_MAX; group++) {\n\t\t\tfor (rfpath = 0; rfpath < RF6052_MAX_PATH; rfpath++) {\n\t\t\t\tif (group < CHANNEL_GROUP_MAX_2G) {\n\t\t\t\t\tpwrinfo->cck_index[rfpath][group] =\n\t\t\t\t\t    EEPROM_DEFAULT_TXPOWERLEVEL_2G;\n\t\t\t\t\tpwrinfo->ht40_1sindex[rfpath][group] =\n\t\t\t\t\t    EEPROM_DEFAULT_TXPOWERLEVEL_2G;\n\t\t\t\t} else {\n\t\t\t\t\tpwrinfo->ht40_1sindex[rfpath][group] =\n\t\t\t\t\t    EEPROM_DEFAULT_TXPOWERLEVEL_5G;\n\t\t\t\t}\n\t\t\t\tpwrinfo->ht40_2sindexdiff[rfpath][group] =\n\t\t\t\t    EEPROM_DEFAULT_HT40_2SDIFF;\n\t\t\t\tpwrinfo->ht20indexdiff[rfpath][group] =\n\t\t\t\t    EEPROM_DEFAULT_HT20_DIFF;\n\t\t\t\tpwrinfo->ofdmindexdiff[rfpath][group] =\n\t\t\t\t    EEPROM_DEFAULT_LEGACYHTTXPOWERDIFF;\n\t\t\t\tpwrinfo->ht40maxoffset[rfpath][group] =\n\t\t\t\t    EEPROM_DEFAULT_HT40_PWRMAXOFFSET;\n\t\t\t\tpwrinfo->ht20maxoffset[rfpath][group] =\n\t\t\t\t    EEPROM_DEFAULT_HT20_PWRMAXOFFSET;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tpwrinfo->tssi_a[i] = EEPROM_DEFAULT_TSSI;\n\t\t\tpwrinfo->tssi_b[i] = EEPROM_DEFAULT_TSSI;\n\t\t}\n\t\treturn;\n\t}\n\n\t \n\tfor (rfpath = 0; rfpath < RF6052_MAX_PATH; rfpath++) {\n\t\tfor (group = 0; group < CHANNEL_GROUP_MAX_2G; group++) {\n\t\t\teeaddr = EEPROM_CCK_TX_PWR_INX_2G + (rfpath * 3)\n\t\t\t\t + group;\n\t\t\tpwrinfo->cck_index[rfpath][group] =\n\t\t\t\t\t(rom_content[eeaddr] == 0xFF) ?\n\t\t\t\t\t     (eeaddr > 0x7B ?\n\t\t\t\t\t     EEPROM_DEFAULT_TXPOWERLEVEL_5G :\n\t\t\t\t\t     EEPROM_DEFAULT_TXPOWERLEVEL_2G) :\n\t\t\t\t\t     rom_content[eeaddr];\n\t\t}\n\t}\n\tfor (rfpath = 0; rfpath < RF6052_MAX_PATH; rfpath++) {\n\t\tfor (group = 0; group < CHANNEL_GROUP_MAX; group++) {\n\t\t\toffset1 = group / 3;\n\t\t\toffset2 = group % 3;\n\t\t\teeaddr = EEPROM_HT40_1S_TX_PWR_INX_2G + (rfpath * 3) +\n\t\t\t    offset2 + offset1 * 21;\n\t\t\tpwrinfo->ht40_1sindex[rfpath][group] =\n\t\t\t    (rom_content[eeaddr] == 0xFF) ? (eeaddr > 0x7B ?\n\t\t\t\t\t     EEPROM_DEFAULT_TXPOWERLEVEL_5G :\n\t\t\t\t\t     EEPROM_DEFAULT_TXPOWERLEVEL_2G) :\n\t\t\t\t\t\t rom_content[eeaddr];\n\t\t}\n\t}\n\t \n\tfor (group = 0; group < CHANNEL_GROUP_MAX; group++) {\n\t\tfor (rfpath = 0; rfpath < RF6052_MAX_PATH; rfpath++) {\n\t\t\tint base1 = EEPROM_HT40_2S_TX_PWR_INX_DIFF_2G;\n\n\t\t\toffset1 = group / 3;\n\t\t\toffset2 = group % 3;\n\n\t\t\tif (rom_content[base1 + offset2 + offset1 * 21] != 0xFF)\n\t\t\t\tpwrinfo->ht40_2sindexdiff[rfpath][group] =\n\t\t\t\t    (rom_content[base1 +\n\t\t\t\t     offset2 + offset1 * 21] >> (rfpath * 4))\n\t\t\t\t     & 0xF;\n\t\t\telse\n\t\t\t\tpwrinfo->ht40_2sindexdiff[rfpath][group] =\n\t\t\t\t    EEPROM_DEFAULT_HT40_2SDIFF;\n\t\t\tif (rom_content[EEPROM_HT20_TX_PWR_INX_DIFF_2G + offset2\n\t\t\t    + offset1 * 21] != 0xFF)\n\t\t\t\tpwrinfo->ht20indexdiff[rfpath][group] =\n\t\t\t\t    (rom_content[EEPROM_HT20_TX_PWR_INX_DIFF_2G\n\t\t\t\t    + offset2 + offset1 * 21] >> (rfpath * 4))\n\t\t\t\t    & 0xF;\n\t\t\telse\n\t\t\t\tpwrinfo->ht20indexdiff[rfpath][group] =\n\t\t\t\t    EEPROM_DEFAULT_HT20_DIFF;\n\t\t\tif (rom_content[EEPROM_OFDM_TX_PWR_INX_DIFF_2G + offset2\n\t\t\t    + offset1 * 21] != 0xFF)\n\t\t\t\tpwrinfo->ofdmindexdiff[rfpath][group] =\n\t\t\t\t    (rom_content[EEPROM_OFDM_TX_PWR_INX_DIFF_2G\n\t\t\t\t     + offset2 + offset1 * 21] >> (rfpath * 4))\n\t\t\t\t     & 0xF;\n\t\t\telse\n\t\t\t\tpwrinfo->ofdmindexdiff[rfpath][group] =\n\t\t\t\t    EEPROM_DEFAULT_LEGACYHTTXPOWERDIFF;\n\t\t\tif (rom_content[EEPROM_HT40_MAX_PWR_OFFSET_2G + offset2\n\t\t\t    + offset1 * 21] != 0xFF)\n\t\t\t\tpwrinfo->ht40maxoffset[rfpath][group] =\n\t\t\t\t    (rom_content[EEPROM_HT40_MAX_PWR_OFFSET_2G\n\t\t\t\t    + offset2 + offset1 * 21] >> (rfpath * 4))\n\t\t\t\t    & 0xF;\n\t\t\telse\n\t\t\t\tpwrinfo->ht40maxoffset[rfpath][group] =\n\t\t\t\t    EEPROM_DEFAULT_HT40_PWRMAXOFFSET;\n\t\t\tif (rom_content[EEPROM_HT20_MAX_PWR_OFFSET_2G + offset2\n\t\t\t    + offset1 * 21] != 0xFF)\n\t\t\t\tpwrinfo->ht20maxoffset[rfpath][group] =\n\t\t\t\t    (rom_content[EEPROM_HT20_MAX_PWR_OFFSET_2G +\n\t\t\t\t     offset2 + offset1 * 21] >> (rfpath * 4)) &\n\t\t\t\t     0xF;\n\t\t\telse\n\t\t\t\tpwrinfo->ht20maxoffset[rfpath][group] =\n\t\t\t\t    EEPROM_DEFAULT_HT20_PWRMAXOFFSET;\n\t\t}\n\t}\n\tif (rom_content[EEPROM_TSSI_A_5G] != 0xFF) {\n\t\t \n\t\tpwrinfo->tssi_a[0] = rom_content[EEPROM_TSSI_A_5G] & 0x3F;\n\t\tpwrinfo->tssi_b[0] = rom_content[EEPROM_TSSI_B_5G] & 0x3F;\n\t\t \n\t\tpwrinfo->tssi_a[1] = rom_content[EEPROM_TSSI_AB_5G] & 0x3F;\n\t\tpwrinfo->tssi_b[1] =\n\t\t    (rom_content[EEPROM_TSSI_AB_5G] & 0xC0) >> 6 |\n\t\t    (rom_content[EEPROM_TSSI_AB_5G + 1] & 0x0F) << 2;\n\t\t \n\t\tpwrinfo->tssi_a[2] = (rom_content[EEPROM_TSSI_AB_5G + 1] &\n\t\t\t\t      0xF0) >> 4 |\n\t\t    (rom_content[EEPROM_TSSI_AB_5G + 2] & 0x03) << 4;\n\t\tpwrinfo->tssi_b[2] = (rom_content[EEPROM_TSSI_AB_5G + 2] &\n\t\t\t\t      0xFC) >> 2;\n\t} else {\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tpwrinfo->tssi_a[i] = EEPROM_DEFAULT_TSSI;\n\t\t\tpwrinfo->tssi_b[i] = EEPROM_DEFAULT_TSSI;\n\t\t}\n\t}\n}\n\nstatic void _rtl92de_read_txpower_info(struct ieee80211_hw *hw,\n\t\t\t\t       bool autoload_fail, u8 *hwinfo)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tstruct txpower_info pwrinfo;\n\tu8 tempval[2], i, pwr, diff;\n\tu32 ch, rfpath, group;\n\n\t_rtl92de_readpowervalue_fromprom(&pwrinfo, hwinfo, autoload_fail);\n\tif (!autoload_fail) {\n\t\t \n\t\trtlefuse->eeprom_regulatory = (hwinfo[EEPROM_RF_OPT1] & 0x7);\n\t\trtlefuse->eeprom_thermalmeter =\n\t\t\t hwinfo[EEPROM_THERMAL_METER] & 0x1f;\n\t\trtlefuse->crystalcap = hwinfo[EEPROM_XTAL_K];\n\t\ttempval[0] = hwinfo[EEPROM_IQK_DELTA] & 0x03;\n\t\ttempval[1] = (hwinfo[EEPROM_LCK_DELTA] & 0x0C) >> 2;\n\t\trtlefuse->txpwr_fromeprom = true;\n\t\tif (IS_92D_D_CUT(rtlpriv->rtlhal.version) ||\n\t\t    IS_92D_E_CUT(rtlpriv->rtlhal.version)) {\n\t\t\trtlefuse->internal_pa_5g[0] =\n\t\t\t\t!((hwinfo[EEPROM_TSSI_A_5G] & BIT(6)) >> 6);\n\t\t\trtlefuse->internal_pa_5g[1] =\n\t\t\t\t!((hwinfo[EEPROM_TSSI_B_5G] & BIT(6)) >> 6);\n\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG,\n\t\t\t\t\"Is D cut,Internal PA0 %d Internal PA1 %d\\n\",\n\t\t\t\trtlefuse->internal_pa_5g[0],\n\t\t\t\trtlefuse->internal_pa_5g[1]);\n\t\t}\n\t\trtlefuse->eeprom_c9 = hwinfo[EEPROM_RF_OPT6];\n\t\trtlefuse->eeprom_cc = hwinfo[EEPROM_RF_OPT7];\n\t} else {\n\t\trtlefuse->eeprom_regulatory = 0;\n\t\trtlefuse->eeprom_thermalmeter = EEPROM_DEFAULT_THERMALMETER;\n\t\trtlefuse->crystalcap = EEPROM_DEFAULT_CRYSTALCAP;\n\t\ttempval[0] = tempval[1] = 3;\n\t}\n\n\t \n\n\t \n\tif (rtlefuse->eeprom_thermalmeter < 0x06 ||\n\t    rtlefuse->eeprom_thermalmeter > 0x1c)\n\t\trtlefuse->eeprom_thermalmeter = 0x12;\n\trtlefuse->thermalmeter[0] = rtlefuse->eeprom_thermalmeter;\n\n\t \n\tif (rtlefuse->crystalcap == 0xFF)\n\t\trtlefuse->crystalcap = 0;\n\tif (rtlefuse->eeprom_regulatory > 3)\n\t\trtlefuse->eeprom_regulatory = 0;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tswitch (tempval[i]) {\n\t\tcase 0:\n\t\t\ttempval[i] = 5;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\ttempval[i] = 4;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\ttempval[i] = 3;\n\t\t\tbreak;\n\t\tcase 3:\n\t\tdefault:\n\t\t\ttempval[i] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trtlefuse->delta_iqk = tempval[0];\n\tif (tempval[1] > 0)\n\t\trtlefuse->delta_lck = tempval[1] - 1;\n\tif (rtlefuse->eeprom_c9 == 0xFF)\n\t\trtlefuse->eeprom_c9 = 0x00;\n\trtl_dbg(rtlpriv, COMP_INTR, DBG_LOUD,\n\t\t\"EEPROMRegulatory = 0x%x\\n\", rtlefuse->eeprom_regulatory);\n\trtl_dbg(rtlpriv, COMP_INTR, DBG_LOUD,\n\t\t\"ThermalMeter = 0x%x\\n\", rtlefuse->eeprom_thermalmeter);\n\trtl_dbg(rtlpriv, COMP_INTR, DBG_LOUD,\n\t\t\"CrystalCap = 0x%x\\n\", rtlefuse->crystalcap);\n\trtl_dbg(rtlpriv, COMP_INTR, DBG_LOUD,\n\t\t\"Delta_IQK = 0x%x Delta_LCK = 0x%x\\n\",\n\t\trtlefuse->delta_iqk, rtlefuse->delta_lck);\n\n\tfor (rfpath = 0; rfpath < RF6052_MAX_PATH; rfpath++) {\n\t\tfor (ch = 0; ch < CHANNEL_MAX_NUMBER; ch++) {\n\t\t\tgroup = rtl92d_get_chnlgroup_fromarray((u8) ch);\n\t\t\tif (ch < CHANNEL_MAX_NUMBER_2G)\n\t\t\t\trtlefuse->txpwrlevel_cck[rfpath][ch] =\n\t\t\t\t    pwrinfo.cck_index[rfpath][group];\n\t\t\trtlefuse->txpwrlevel_ht40_1s[rfpath][ch] =\n\t\t\t\t    pwrinfo.ht40_1sindex[rfpath][group];\n\t\t\trtlefuse->txpwr_ht20diff[rfpath][ch] =\n\t\t\t\t    pwrinfo.ht20indexdiff[rfpath][group];\n\t\t\trtlefuse->txpwr_legacyhtdiff[rfpath][ch] =\n\t\t\t\t    pwrinfo.ofdmindexdiff[rfpath][group];\n\t\t\trtlefuse->pwrgroup_ht20[rfpath][ch] =\n\t\t\t\t    pwrinfo.ht20maxoffset[rfpath][group];\n\t\t\trtlefuse->pwrgroup_ht40[rfpath][ch] =\n\t\t\t\t    pwrinfo.ht40maxoffset[rfpath][group];\n\t\t\tpwr = pwrinfo.ht40_1sindex[rfpath][group];\n\t\t\tdiff = pwrinfo.ht40_2sindexdiff[rfpath][group];\n\t\t\trtlefuse->txpwrlevel_ht40_2s[rfpath][ch] =\n\t\t\t\t    (pwr > diff) ? (pwr - diff) : 0;\n\t\t}\n\t}\n}\n\nstatic void _rtl92de_read_macphymode_from_prom(struct ieee80211_hw *hw,\n\t\t\t\t\t       u8 *content)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tu8 macphy_crvalue = content[EEPROM_MAC_FUNCTION];\n\n\tif (macphy_crvalue & BIT(3)) {\n\t\trtlhal->macphymode = SINGLEMAC_SINGLEPHY;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\"MacPhyMode SINGLEMAC_SINGLEPHY\\n\");\n\t} else {\n\t\trtlhal->macphymode = DUALMAC_DUALPHY;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\"MacPhyMode DUALMAC_DUALPHY\\n\");\n\t}\n}\n\nstatic void _rtl92de_read_macphymode_and_bandtype(struct ieee80211_hw *hw,\n\t\t\t\t\t\t  u8 *content)\n{\n\t_rtl92de_read_macphymode_from_prom(hw, content);\n\trtl92d_phy_config_macphymode(hw);\n\trtl92d_phy_config_macphymode_info(hw);\n}\n\nstatic void _rtl92de_efuse_update_chip_version(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tenum version_8192d chipver = rtlpriv->rtlhal.version;\n\tu8 cutvalue[2];\n\tu16 chipvalue;\n\n\trtlpriv->intf_ops->read_efuse_byte(hw, EEPROME_CHIP_VERSION_H,\n\t\t\t\t\t   &cutvalue[1]);\n\trtlpriv->intf_ops->read_efuse_byte(hw, EEPROME_CHIP_VERSION_L,\n\t\t\t\t\t   &cutvalue[0]);\n\tchipvalue = (cutvalue[1] << 8) | cutvalue[0];\n\tswitch (chipvalue) {\n\tcase 0xAA55:\n\t\tchipver |= CHIP_92D_C_CUT;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD, \"C-CUT!!!\\n\");\n\t\tbreak;\n\tcase 0x9966:\n\t\tchipver |= CHIP_92D_D_CUT;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD, \"D-CUT!!!\\n\");\n\t\tbreak;\n\tcase 0xCC33:\n\t\tchipver |= CHIP_92D_E_CUT;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD, \"E-CUT!!!\\n\");\n\t\tbreak;\n\tdefault:\n\t\tchipver |= CHIP_92D_D_CUT;\n\t\tpr_err(\"Unknown CUT!\\n\");\n\t\tbreak;\n\t}\n\trtlpriv->rtlhal.version = chipver;\n}\n\nstatic void _rtl92de_read_adapter_info(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tint params[] = {RTL8190_EEPROM_ID, EEPROM_VID, EEPROM_DID,\n\t\t\tEEPROM_SVID, EEPROM_SMID, EEPROM_MAC_ADDR_MAC0_92D,\n\t\t\tEEPROM_CHANNEL_PLAN, EEPROM_VERSION, EEPROM_CUSTOMER_ID,\n\t\t\tCOUNTRY_CODE_WORLD_WIDE_13};\n\tint i;\n\tu16 usvalue;\n\tu8 *hwinfo;\n\n\thwinfo = kzalloc(HWSET_MAX_SIZE, GFP_KERNEL);\n\tif (!hwinfo)\n\t\treturn;\n\n\tif (rtl_get_hwinfo(hw, rtlpriv, HWSET_MAX_SIZE, hwinfo, params))\n\t\tgoto exit;\n\n\t_rtl92de_efuse_update_chip_version(hw);\n\t_rtl92de_read_macphymode_and_bandtype(hw, hwinfo);\n\n\t \n\tif (rtlhal->interfaceindex != 0) {\n\t\tfor (i = 0; i < 6; i += 2) {\n\t\t\tusvalue = *(u16 *)&hwinfo[EEPROM_MAC_ADDR_MAC1_92D + i];\n\t\t\t*((u16 *) (&rtlefuse->dev_addr[i])) = usvalue;\n\t\t}\n\t}\n\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_ETHER_ADDR,\n\t\t\t\t      rtlefuse->dev_addr);\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG, \"%pM\\n\", rtlefuse->dev_addr);\n\t_rtl92de_read_txpower_info(hw, rtlefuse->autoload_failflag, hwinfo);\n\n\t \n\tswitch (rtlhal->bandset) {\n\tcase BAND_ON_2_4G:\n\t\trtlefuse->channel_plan = COUNTRY_CODE_TELEC;\n\t\tbreak;\n\tcase BAND_ON_5G:\n\t\trtlefuse->channel_plan = COUNTRY_CODE_FCC;\n\t\tbreak;\n\tcase BAND_ON_BOTH:\n\t\trtlefuse->channel_plan = COUNTRY_CODE_FCC;\n\t\tbreak;\n\tdefault:\n\t\trtlefuse->channel_plan = COUNTRY_CODE_FCC;\n\t\tbreak;\n\t}\n\trtlefuse->txpwr_fromeprom = true;\nexit:\n\tkfree(hwinfo);\n}\n\nvoid rtl92de_read_eeprom_info(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tu8 tmp_u1b;\n\n\trtlhal->version = _rtl92de_read_chip_version(hw);\n\ttmp_u1b = rtl_read_byte(rtlpriv, REG_9346CR);\n\trtlefuse->autoload_status = tmp_u1b;\n\tif (tmp_u1b & BIT(4)) {\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG, \"Boot from EEPROM\\n\");\n\t\trtlefuse->epromtype = EEPROM_93C46;\n\t} else {\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG, \"Boot from EFUSE\\n\");\n\t\trtlefuse->epromtype = EEPROM_BOOT_EFUSE;\n\t}\n\tif (tmp_u1b & BIT(5)) {\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD, \"Autoload OK\\n\");\n\n\t\trtlefuse->autoload_failflag = false;\n\t\t_rtl92de_read_adapter_info(hw);\n\t} else {\n\t\tpr_err(\"Autoload ERR!!\\n\");\n\t}\n\treturn;\n}\n\nstatic void rtl92de_update_hal_rate_table(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct ieee80211_sta *sta)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tu32 ratr_value;\n\tu8 ratr_index = 0;\n\tu8 nmode = mac->ht_enable;\n\tu8 mimo_ps = IEEE80211_SMPS_OFF;\n\tu16 shortgi_rate;\n\tu32 tmp_ratr_value;\n\tu8 curtxbw_40mhz = mac->bw_40;\n\tu8 curshortgi_40mhz = (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_SGI_40) ?\n\t\t\t\t\t\t\t1 : 0;\n\tu8 curshortgi_20mhz = (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_SGI_20) ?\n\t\t\t\t\t\t\t1 : 0;\n\tenum wireless_mode wirelessmode = mac->mode;\n\n\tif (rtlhal->current_bandtype == BAND_ON_5G)\n\t\tratr_value = sta->deflink.supp_rates[1] << 4;\n\telse\n\t\tratr_value = sta->deflink.supp_rates[0];\n\tratr_value |= (sta->deflink.ht_cap.mcs.rx_mask[1] << 20 |\n\t\t       sta->deflink.ht_cap.mcs.rx_mask[0] << 12);\n\tswitch (wirelessmode) {\n\tcase WIRELESS_MODE_A:\n\t\tratr_value &= 0x00000FF0;\n\t\tbreak;\n\tcase WIRELESS_MODE_B:\n\t\tif (ratr_value & 0x0000000c)\n\t\t\tratr_value &= 0x0000000d;\n\t\telse\n\t\t\tratr_value &= 0x0000000f;\n\t\tbreak;\n\tcase WIRELESS_MODE_G:\n\t\tratr_value &= 0x00000FF5;\n\t\tbreak;\n\tcase WIRELESS_MODE_N_24G:\n\tcase WIRELESS_MODE_N_5G:\n\t\tnmode = 1;\n\t\tif (mimo_ps == IEEE80211_SMPS_STATIC) {\n\t\t\tratr_value &= 0x0007F005;\n\t\t} else {\n\t\t\tu32 ratr_mask;\n\n\t\t\tif (get_rf_type(rtlphy) == RF_1T2R ||\n\t\t\t    get_rf_type(rtlphy) == RF_1T1R) {\n\t\t\t\tratr_mask = 0x000ff005;\n\t\t\t} else {\n\t\t\t\tratr_mask = 0x0f0ff005;\n\t\t\t}\n\n\t\t\tratr_value &= ratr_mask;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif (rtlphy->rf_type == RF_1T2R)\n\t\t\tratr_value &= 0x000ff0ff;\n\t\telse\n\t\t\tratr_value &= 0x0f0ff0ff;\n\n\t\tbreak;\n\t}\n\tratr_value &= 0x0FFFFFFF;\n\tif (nmode && ((curtxbw_40mhz && curshortgi_40mhz) ||\n\t    (!curtxbw_40mhz && curshortgi_20mhz))) {\n\t\tratr_value |= 0x10000000;\n\t\ttmp_ratr_value = (ratr_value >> 12);\n\t\tfor (shortgi_rate = 15; shortgi_rate > 0; shortgi_rate--) {\n\t\t\tif ((1 << shortgi_rate) & tmp_ratr_value)\n\t\t\t\tbreak;\n\t\t}\n\t\tshortgi_rate = (shortgi_rate << 12) | (shortgi_rate << 8) |\n\t\t    (shortgi_rate << 4) | (shortgi_rate);\n\t}\n\trtl_write_dword(rtlpriv, REG_ARFR0 + ratr_index * 4, ratr_value);\n\trtl_dbg(rtlpriv, COMP_RATR, DBG_DMESG, \"%x\\n\",\n\t\trtl_read_dword(rtlpriv, REG_ARFR0));\n}\n\nstatic void rtl92de_update_hal_rate_mask(struct ieee80211_hw *hw,\n\t\tstruct ieee80211_sta *sta, u8 rssi_level, bool update_bw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_sta_info *sta_entry = NULL;\n\tu32 ratr_bitmap;\n\tu8 ratr_index;\n\tu8 curtxbw_40mhz = (sta->deflink.bandwidth >= IEEE80211_STA_RX_BW_40) ? 1 : 0;\n\tu8 curshortgi_40mhz = (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_SGI_40) ?\n\t\t\t\t\t\t\t1 : 0;\n\tu8 curshortgi_20mhz = (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_SGI_20) ?\n\t\t\t\t\t\t\t1 : 0;\n\tenum wireless_mode wirelessmode = 0;\n\tbool shortgi = false;\n\tu32 value[2];\n\tu8 macid = 0;\n\tu8 mimo_ps = IEEE80211_SMPS_OFF;\n\n\tsta_entry = (struct rtl_sta_info *) sta->drv_priv;\n\tmimo_ps = sta_entry->mimo_ps;\n\twirelessmode = sta_entry->wireless_mode;\n\tif (mac->opmode == NL80211_IFTYPE_STATION)\n\t\tcurtxbw_40mhz = mac->bw_40;\n\telse if (mac->opmode == NL80211_IFTYPE_AP ||\n\t\tmac->opmode == NL80211_IFTYPE_ADHOC)\n\t\tmacid = sta->aid + 1;\n\n\tif (rtlhal->current_bandtype == BAND_ON_5G)\n\t\tratr_bitmap = sta->deflink.supp_rates[1] << 4;\n\telse\n\t\tratr_bitmap = sta->deflink.supp_rates[0];\n\tratr_bitmap |= (sta->deflink.ht_cap.mcs.rx_mask[1] << 20 |\n\t\t\tsta->deflink.ht_cap.mcs.rx_mask[0] << 12);\n\tswitch (wirelessmode) {\n\tcase WIRELESS_MODE_B:\n\t\tratr_index = RATR_INX_WIRELESS_B;\n\t\tif (ratr_bitmap & 0x0000000c)\n\t\t\tratr_bitmap &= 0x0000000d;\n\t\telse\n\t\t\tratr_bitmap &= 0x0000000f;\n\t\tbreak;\n\tcase WIRELESS_MODE_G:\n\t\tratr_index = RATR_INX_WIRELESS_GB;\n\n\t\tif (rssi_level == 1)\n\t\t\tratr_bitmap &= 0x00000f00;\n\t\telse if (rssi_level == 2)\n\t\t\tratr_bitmap &= 0x00000ff0;\n\t\telse\n\t\t\tratr_bitmap &= 0x00000ff5;\n\t\tbreak;\n\tcase WIRELESS_MODE_A:\n\t\tratr_index = RATR_INX_WIRELESS_G;\n\t\tratr_bitmap &= 0x00000ff0;\n\t\tbreak;\n\tcase WIRELESS_MODE_N_24G:\n\tcase WIRELESS_MODE_N_5G:\n\t\tif (wirelessmode == WIRELESS_MODE_N_24G)\n\t\t\tratr_index = RATR_INX_WIRELESS_NGB;\n\t\telse\n\t\t\tratr_index = RATR_INX_WIRELESS_NG;\n\t\tif (mimo_ps == IEEE80211_SMPS_STATIC) {\n\t\t\tif (rssi_level == 1)\n\t\t\t\tratr_bitmap &= 0x00070000;\n\t\t\telse if (rssi_level == 2)\n\t\t\t\tratr_bitmap &= 0x0007f000;\n\t\t\telse\n\t\t\t\tratr_bitmap &= 0x0007f005;\n\t\t} else {\n\t\t\tif (rtlphy->rf_type == RF_1T2R ||\n\t\t\t    rtlphy->rf_type == RF_1T1R) {\n\t\t\t\tif (curtxbw_40mhz) {\n\t\t\t\t\tif (rssi_level == 1)\n\t\t\t\t\t\tratr_bitmap &= 0x000f0000;\n\t\t\t\t\telse if (rssi_level == 2)\n\t\t\t\t\t\tratr_bitmap &= 0x000ff000;\n\t\t\t\t\telse\n\t\t\t\t\t\tratr_bitmap &= 0x000ff015;\n\t\t\t\t} else {\n\t\t\t\t\tif (rssi_level == 1)\n\t\t\t\t\t\tratr_bitmap &= 0x000f0000;\n\t\t\t\t\telse if (rssi_level == 2)\n\t\t\t\t\t\tratr_bitmap &= 0x000ff000;\n\t\t\t\t\telse\n\t\t\t\t\t\tratr_bitmap &= 0x000ff005;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (curtxbw_40mhz) {\n\t\t\t\t\tif (rssi_level == 1)\n\t\t\t\t\t\tratr_bitmap &= 0x0f0f0000;\n\t\t\t\t\telse if (rssi_level == 2)\n\t\t\t\t\t\tratr_bitmap &= 0x0f0ff000;\n\t\t\t\t\telse\n\t\t\t\t\t\tratr_bitmap &= 0x0f0ff015;\n\t\t\t\t} else {\n\t\t\t\t\tif (rssi_level == 1)\n\t\t\t\t\t\tratr_bitmap &= 0x0f0f0000;\n\t\t\t\t\telse if (rssi_level == 2)\n\t\t\t\t\t\tratr_bitmap &= 0x0f0ff000;\n\t\t\t\t\telse\n\t\t\t\t\t\tratr_bitmap &= 0x0f0ff005;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ((curtxbw_40mhz && curshortgi_40mhz) ||\n\t\t    (!curtxbw_40mhz && curshortgi_20mhz)) {\n\n\t\t\tif (macid == 0)\n\t\t\t\tshortgi = true;\n\t\t\telse if (macid == 1)\n\t\t\t\tshortgi = false;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tratr_index = RATR_INX_WIRELESS_NGB;\n\n\t\tif (rtlphy->rf_type == RF_1T2R)\n\t\t\tratr_bitmap &= 0x000ff0ff;\n\t\telse\n\t\t\tratr_bitmap &= 0x0f0ff0ff;\n\t\tbreak;\n\t}\n\n\tvalue[0] = (ratr_bitmap & 0x0fffffff) | (ratr_index << 28);\n\tvalue[1] = macid | (shortgi ? 0x20 : 0x00) | 0x80;\n\trtl_dbg(rtlpriv, COMP_RATR, DBG_DMESG,\n\t\t\"ratr_bitmap :%x value0:%x value1:%x\\n\",\n\t\tratr_bitmap, value[0], value[1]);\n\trtl92d_fill_h2c_cmd(hw, H2C_RA_MASK, 5, (u8 *) value);\n\tif (macid != 0)\n\t\tsta_entry->ratr_index = ratr_index;\n}\n\nvoid rtl92de_update_hal_rate_tbl(struct ieee80211_hw *hw,\n\t\tstruct ieee80211_sta *sta, u8 rssi_level, bool update_bw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\tif (rtlpriv->dm.useramask)\n\t\trtl92de_update_hal_rate_mask(hw, sta, rssi_level, update_bw);\n\telse\n\t\trtl92de_update_hal_rate_table(hw, sta);\n}\n\nvoid rtl92de_update_channel_access_setting(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tu16 sifs_timer;\n\n\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_SLOT_TIME,\n\t\t\t\t      &mac->slot_time);\n\tif (!mac->ht_enable)\n\t\tsifs_timer = 0x0a0a;\n\telse\n\t\tsifs_timer = 0x1010;\n\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_SIFS, (u8 *)&sifs_timer);\n}\n\nbool rtl92de_gpio_radio_on_off_checking(struct ieee80211_hw *hw, u8 *valid)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tenum rf_pwrstate e_rfpowerstate_toset;\n\tu8 u1tmp;\n\tbool actuallyset = false;\n\tunsigned long flag;\n\n\tif (rtlpci->being_init_adapter)\n\t\treturn false;\n\tif (ppsc->swrf_processing)\n\t\treturn false;\n\tspin_lock_irqsave(&rtlpriv->locks.rf_ps_lock, flag);\n\tif (ppsc->rfchange_inprogress) {\n\t\tspin_unlock_irqrestore(&rtlpriv->locks.rf_ps_lock, flag);\n\t\treturn false;\n\t} else {\n\t\tppsc->rfchange_inprogress = true;\n\t\tspin_unlock_irqrestore(&rtlpriv->locks.rf_ps_lock, flag);\n\t}\n\trtl_write_byte(rtlpriv, REG_MAC_PINMUX_CFG, rtl_read_byte(rtlpriv,\n\t\t\t  REG_MAC_PINMUX_CFG) & ~(BIT(3)));\n\tu1tmp = rtl_read_byte(rtlpriv, REG_GPIO_IO_SEL);\n\te_rfpowerstate_toset = (u1tmp & BIT(3)) ? ERFON : ERFOFF;\n\tif (ppsc->hwradiooff && (e_rfpowerstate_toset == ERFON)) {\n\t\trtl_dbg(rtlpriv, COMP_RF, DBG_DMESG,\n\t\t\t\"GPIOChangeRF  - HW Radio ON, RF ON\\n\");\n\t\te_rfpowerstate_toset = ERFON;\n\t\tppsc->hwradiooff = false;\n\t\tactuallyset = true;\n\t} else if (!ppsc->hwradiooff && (e_rfpowerstate_toset == ERFOFF)) {\n\t\trtl_dbg(rtlpriv, COMP_RF, DBG_DMESG,\n\t\t\t\"GPIOChangeRF  - HW Radio OFF, RF OFF\\n\");\n\t\te_rfpowerstate_toset = ERFOFF;\n\t\tppsc->hwradiooff = true;\n\t\tactuallyset = true;\n\t}\n\tif (actuallyset) {\n\t\tspin_lock_irqsave(&rtlpriv->locks.rf_ps_lock, flag);\n\t\tppsc->rfchange_inprogress = false;\n\t\tspin_unlock_irqrestore(&rtlpriv->locks.rf_ps_lock, flag);\n\t} else {\n\t\tif (ppsc->reg_rfps_level & RT_RF_OFF_LEVL_HALT_NIC)\n\t\t\tRT_SET_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_HALT_NIC);\n\t\tspin_lock_irqsave(&rtlpriv->locks.rf_ps_lock, flag);\n\t\tppsc->rfchange_inprogress = false;\n\t\tspin_unlock_irqrestore(&rtlpriv->locks.rf_ps_lock, flag);\n\t}\n\t*valid = 1;\n\treturn !ppsc->hwradiooff;\n}\n\nvoid rtl92de_set_key(struct ieee80211_hw *hw, u32 key_index,\n\t\t     u8 *p_macaddr, bool is_group, u8 enc_algo,\n\t\t     bool is_wepkey, bool clear_all)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tu8 *macaddr = p_macaddr;\n\tu32 entry_id;\n\tbool is_pairwise = false;\n\tstatic u8 cam_const_addr[4][6] = {\n\t\t{0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n\t\t{0x00, 0x00, 0x00, 0x00, 0x00, 0x01},\n\t\t{0x00, 0x00, 0x00, 0x00, 0x00, 0x02},\n\t\t{0x00, 0x00, 0x00, 0x00, 0x00, 0x03}\n\t};\n\tstatic u8 cam_const_broad[] = {\n\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff\n\t};\n\n\tif (clear_all) {\n\t\tu8 idx;\n\t\tu8 cam_offset = 0;\n\t\tu8 clear_number = 5;\n\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_DMESG, \"clear_all\\n\");\n\t\tfor (idx = 0; idx < clear_number; idx++) {\n\t\t\trtl_cam_mark_invalid(hw, cam_offset + idx);\n\t\t\trtl_cam_empty_entry(hw, cam_offset + idx);\n\n\t\t\tif (idx < 5) {\n\t\t\t\tmemset(rtlpriv->sec.key_buf[idx], 0,\n\t\t\t\t       MAX_KEY_LEN);\n\t\t\t\trtlpriv->sec.key_len[idx] = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tswitch (enc_algo) {\n\t\tcase WEP40_ENCRYPTION:\n\t\t\tenc_algo = CAM_WEP40;\n\t\t\tbreak;\n\t\tcase WEP104_ENCRYPTION:\n\t\t\tenc_algo = CAM_WEP104;\n\t\t\tbreak;\n\t\tcase TKIP_ENCRYPTION:\n\t\t\tenc_algo = CAM_TKIP;\n\t\t\tbreak;\n\t\tcase AESCCMP_ENCRYPTION:\n\t\t\tenc_algo = CAM_AES;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"switch case %#x not processed\\n\",\n\t\t\t       enc_algo);\n\t\t\tenc_algo = CAM_TKIP;\n\t\t\tbreak;\n\t\t}\n\t\tif (is_wepkey || rtlpriv->sec.use_defaultkey) {\n\t\t\tmacaddr = cam_const_addr[key_index];\n\t\t\tentry_id = key_index;\n\t\t} else {\n\t\t\tif (is_group) {\n\t\t\t\tmacaddr = cam_const_broad;\n\t\t\t\tentry_id = key_index;\n\t\t\t} else {\n\t\t\t\tif (mac->opmode == NL80211_IFTYPE_AP) {\n\t\t\t\t\tentry_id = rtl_cam_get_free_entry(hw,\n\t\t\t\t\t\t\t\t p_macaddr);\n\t\t\t\t\tif (entry_id >=  TOTAL_CAM_ENTRY) {\n\t\t\t\t\t\tpr_err(\"Can not find free hw security cam entry\\n\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tentry_id = CAM_PAIRWISE_KEY_POSITION;\n\t\t\t\t}\n\t\t\t\tkey_index = PAIRWISE_KEYIDX;\n\t\t\t\tis_pairwise = true;\n\t\t\t}\n\t\t}\n\t\tif (rtlpriv->sec.key_len[key_index] == 0) {\n\t\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_DMESG,\n\t\t\t\t\"delete one entry, entry_id is %d\\n\",\n\t\t\t\tentry_id);\n\t\t\tif (mac->opmode == NL80211_IFTYPE_AP)\n\t\t\t\trtl_cam_del_entry(hw, p_macaddr);\n\t\t\trtl_cam_delete_one_entry(hw, p_macaddr, entry_id);\n\t\t} else {\n\t\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_LOUD,\n\t\t\t\t\"The insert KEY length is %d\\n\",\n\t\t\t\trtlpriv->sec.key_len[PAIRWISE_KEYIDX]);\n\t\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_LOUD,\n\t\t\t\t\"The insert KEY is %x %x\\n\",\n\t\t\t\trtlpriv->sec.key_buf[0][0],\n\t\t\t\trtlpriv->sec.key_buf[0][1]);\n\t\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_DMESG,\n\t\t\t\t\"add one entry\\n\");\n\t\t\tif (is_pairwise) {\n\t\t\t\tRT_PRINT_DATA(rtlpriv, COMP_SEC, DBG_LOUD,\n\t\t\t\t\t      \"Pairwise Key content\",\n\t\t\t\t\t      rtlpriv->sec.pairwise_key,\n\t\t\t\t\t      rtlpriv->\n\t\t\t\t\t      sec.key_len[PAIRWISE_KEYIDX]);\n\t\t\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_DMESG,\n\t\t\t\t\t\"set Pairwise key\\n\");\n\t\t\t\trtl_cam_add_one_entry(hw, macaddr, key_index,\n\t\t\t\t\t\t      entry_id, enc_algo,\n\t\t\t\t\t\t      CAM_CONFIG_NO_USEDK,\n\t\t\t\t\t\t      rtlpriv->\n\t\t\t\t\t\t      sec.key_buf[key_index]);\n\t\t\t} else {\n\t\t\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_DMESG,\n\t\t\t\t\t\"set group key\\n\");\n\t\t\t\tif (mac->opmode == NL80211_IFTYPE_ADHOC) {\n\t\t\t\t\trtl_cam_add_one_entry(hw,\n\t\t\t\t\t\trtlefuse->dev_addr,\n\t\t\t\t\t\tPAIRWISE_KEYIDX,\n\t\t\t\t\t\tCAM_PAIRWISE_KEY_POSITION,\n\t\t\t\t\t\tenc_algo, CAM_CONFIG_NO_USEDK,\n\t\t\t\t\t\trtlpriv->sec.key_buf[entry_id]);\n\t\t\t\t}\n\t\t\t\trtl_cam_add_one_entry(hw, macaddr, key_index,\n\t\t\t\t\t\tentry_id, enc_algo,\n\t\t\t\t\t\tCAM_CONFIG_NO_USEDK,\n\t\t\t\t\t\trtlpriv->sec.key_buf\n\t\t\t\t\t\t[entry_id]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid rtl92de_suspend(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtlpriv->rtlhal.macphyctl_reg = rtl_read_byte(rtlpriv,\n\t\tREG_MAC_PHY_CTRL_NORMAL);\n}\n\nvoid rtl92de_resume(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtl_write_byte(rtlpriv, REG_MAC_PHY_CTRL_NORMAL,\n\t\t       rtlpriv->rtlhal.macphyctl_reg);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}