{
  "module_name": "phy.c",
  "hash_id": "9bac64afae7dccf5fb88f2e70d6f50208a52d074de3cdad1c1c8eed25ad16219",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtlwifi/rtl8192de/phy.c",
  "human_readable_source": "\n \n\n#include \"../wifi.h\"\n#include \"../pci.h\"\n#include \"../ps.h\"\n#include \"../core.h\"\n#include \"reg.h\"\n#include \"def.h\"\n#include \"phy.h\"\n#include \"rf.h\"\n#include \"dm.h\"\n#include \"table.h\"\n#include \"sw.h\"\n#include \"hw.h\"\n\n#define MAX_RF_IMR_INDEX\t\t\t12\n#define MAX_RF_IMR_INDEX_NORMAL\t\t\t13\n#define RF_REG_NUM_FOR_C_CUT_5G\t\t\t6\n#define RF_REG_NUM_FOR_C_CUT_5G_INTERNALPA\t7\n#define RF_REG_NUM_FOR_C_CUT_2G\t\t\t5\n#define RF_CHNL_NUM_5G\t\t\t\t19\n#define RF_CHNL_NUM_5G_40M\t\t\t17\n#define TARGET_CHNL_NUM_5G\t\t\t221\n#define TARGET_CHNL_NUM_2G\t\t\t14\n#define CV_CURVE_CNT\t\t\t\t64\n\nstatic u32 rf_reg_for_5g_swchnl_normal[MAX_RF_IMR_INDEX_NORMAL] = {\n\t0, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x0\n};\n\nstatic u8 rf_reg_for_c_cut_5g[RF_REG_NUM_FOR_C_CUT_5G] = {\n\tRF_SYN_G1, RF_SYN_G2, RF_SYN_G3, RF_SYN_G4, RF_SYN_G5, RF_SYN_G6\n};\n\nstatic u8 rf_reg_for_c_cut_2g[RF_REG_NUM_FOR_C_CUT_2G] = {\n\tRF_SYN_G1, RF_SYN_G2, RF_SYN_G3, RF_SYN_G7, RF_SYN_G8\n};\n\nstatic u8 rf_for_c_cut_5g_internal_pa[RF_REG_NUM_FOR_C_CUT_5G_INTERNALPA] = {\n\t0x0B, 0x48, 0x49, 0x4B, 0x03, 0x04, 0x0E\n};\n\nstatic u32 rf_reg_mask_for_c_cut_2g[RF_REG_NUM_FOR_C_CUT_2G] = {\n\tBIT(19) | BIT(18) | BIT(17) | BIT(14) | BIT(1),\n\tBIT(10) | BIT(9),\n\tBIT(18) | BIT(17) | BIT(16) | BIT(1),\n\tBIT(2) | BIT(1),\n\tBIT(15) | BIT(14) | BIT(13) | BIT(12) | BIT(11)\n};\n\nstatic u8 rf_chnl_5g[RF_CHNL_NUM_5G] = {\n\t36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108,\n\t112, 116, 120, 124, 128, 132, 136, 140\n};\n\nstatic u8 rf_chnl_5g_40m[RF_CHNL_NUM_5G_40M] = {\n\t38, 42, 46, 50, 54, 58, 62, 102, 106, 110, 114,\n\t118, 122, 126, 130, 134, 138\n};\nstatic u32 rf_reg_pram_c_5g[5][RF_REG_NUM_FOR_C_CUT_5G] = {\n\t{0xE43BE, 0xFC638, 0x77C0A, 0xDE471, 0xd7110, 0x8EB04},\n\t{0xE43BE, 0xFC078, 0xF7C1A, 0xE0C71, 0xD7550, 0xAEB04},\n\t{0xE43BF, 0xFF038, 0xF7C0A, 0xDE471, 0xE5550, 0xAEB04},\n\t{0xE43BF, 0xFF079, 0xF7C1A, 0xDE471, 0xE5550, 0xAEB04},\n\t{0xE43BF, 0xFF038, 0xF7C1A, 0xDE471, 0xd7550, 0xAEB04}\n};\n\nstatic u32 rf_reg_param_for_c_cut_2g[3][RF_REG_NUM_FOR_C_CUT_2G] = {\n\t{0x643BC, 0xFC038, 0x77C1A, 0x41289, 0x01840},\n\t{0x643BC, 0xFC038, 0x07C1A, 0x41289, 0x01840},\n\t{0x243BC, 0xFC438, 0x07C1A, 0x4128B, 0x0FC41}\n};\n\nstatic u32 rf_syn_g4_for_c_cut_2g = 0xD1C31 & 0x7FF;\n\nstatic u32 rf_pram_c_5g_int_pa[3][RF_REG_NUM_FOR_C_CUT_5G_INTERNALPA] = {\n\t{0x01a00, 0x40443, 0x00eb5, 0x89bec, 0x94a12, 0x94a12, 0x94a12},\n\t{0x01800, 0xc0443, 0x00730, 0x896ee, 0x94a52, 0x94a52, 0x94a52},\n\t{0x01800, 0xc0443, 0x00730, 0x896ee, 0x94a12, 0x94a12, 0x94a12}\n};\n\n \nstatic u32 rf_imr_param_normal[1][3][MAX_RF_IMR_INDEX_NORMAL] = {\n\t{\n\t\t \n\t\t{\n\t\t\t0x70000, 0x00ff0, 0x4400f, 0x00ff0, 0x0, 0x0, 0x0,\n\t\t\t0x0, 0x0, 0x64888, 0xe266c, 0x00090, 0x22fff\n\t\t},\n\t\t \n\t\t{\n\t\t\t0x70000, 0x22880, 0x4470f, 0x55880, 0x00070, 0x88000,\n\t\t\t0x0, 0x88080, 0x70000, 0x64a82, 0xe466c, 0x00090,\n\t\t\t0x32c9a\n\t\t},\n\t\t \n\t\t{\n\t\t\t0x70000, 0x44880, 0x4477f, 0x77880, 0x00070, 0x88000,\n\t\t\t0x0, 0x880b0, 0x0, 0x64b82, 0xe466c, 0x00090, 0x32c9a\n\t\t}\n\t}\n};\n\nstatic u32 curveindex_5g[TARGET_CHNL_NUM_5G] = {0};\n\nstatic u32 curveindex_2g[TARGET_CHNL_NUM_2G] = {0};\n\nstatic u32 targetchnl_5g[TARGET_CHNL_NUM_5G] = {\n\t25141, 25116, 25091, 25066, 25041,\n\t25016, 24991, 24966, 24941, 24917,\n\t24892, 24867, 24843, 24818, 24794,\n\t24770, 24765, 24721, 24697, 24672,\n\t24648, 24624, 24600, 24576, 24552,\n\t24528, 24504, 24480, 24457, 24433,\n\t24409, 24385, 24362, 24338, 24315,\n\t24291, 24268, 24245, 24221, 24198,\n\t24175, 24151, 24128, 24105, 24082,\n\t24059, 24036, 24013, 23990, 23967,\n\t23945, 23922, 23899, 23876, 23854,\n\t23831, 23809, 23786, 23764, 23741,\n\t23719, 23697, 23674, 23652, 23630,\n\t23608, 23586, 23564, 23541, 23519,\n\t23498, 23476, 23454, 23432, 23410,\n\t23388, 23367, 23345, 23323, 23302,\n\t23280, 23259, 23237, 23216, 23194,\n\t23173, 23152, 23130, 23109, 23088,\n\t23067, 23046, 23025, 23003, 22982,\n\t22962, 22941, 22920, 22899, 22878,\n\t22857, 22837, 22816, 22795, 22775,\n\t22754, 22733, 22713, 22692, 22672,\n\t22652, 22631, 22611, 22591, 22570,\n\t22550, 22530, 22510, 22490, 22469,\n\t22449, 22429, 22409, 22390, 22370,\n\t22350, 22336, 22310, 22290, 22271,\n\t22251, 22231, 22212, 22192, 22173,\n\t22153, 22134, 22114, 22095, 22075,\n\t22056, 22037, 22017, 21998, 21979,\n\t21960, 21941, 21921, 21902, 21883,\n\t21864, 21845, 21826, 21807, 21789,\n\t21770, 21751, 21732, 21713, 21695,\n\t21676, 21657, 21639, 21620, 21602,\n\t21583, 21565, 21546, 21528, 21509,\n\t21491, 21473, 21454, 21436, 21418,\n\t21400, 21381, 21363, 21345, 21327,\n\t21309, 21291, 21273, 21255, 21237,\n\t21219, 21201, 21183, 21166, 21148,\n\t21130, 21112, 21095, 21077, 21059,\n\t21042, 21024, 21007, 20989, 20972,\n\t25679, 25653, 25627, 25601, 25575,\n\t25549, 25523, 25497, 25471, 25446,\n\t25420, 25394, 25369, 25343, 25318,\n\t25292, 25267, 25242, 25216, 25191,\n\t25166\n};\n\n \nstatic u32 targetchnl_2g[TARGET_CHNL_NUM_2G] = {\n\t26084, 26030, 25976, 25923, 25869, 25816, 25764,\n\t25711, 25658, 25606, 25554, 25502, 25451, 25328\n};\n\nstatic const u8 channel_all[59] = {\n\t1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,\n\t36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58,\n\t60, 62, 64, 100, 102, 104, 106, 108, 110, 112,\n\t114, 116, 118, 120, 122, 124, 126, 128,\t130,\n\t132, 134, 136, 138, 140, 149, 151, 153, 155,\n\t157, 159, 161, 163, 165\n};\n\nu32 rtl92d_phy_query_bb_reg(struct ieee80211_hw *hw, u32 regaddr, u32 bitmask)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\n\tu32 returnvalue, originalvalue, bitshift;\n\n\trtl_dbg(rtlpriv, COMP_RF, DBG_TRACE, \"regaddr(%#x), bitmask(%#x)\\n\",\n\t\tregaddr, bitmask);\n\tif (rtlhal->during_mac1init_radioa || rtlhal->during_mac0init_radiob) {\n\t\tu8 dbi_direct = 0;\n\n\t\t \n\t\t \n\t\tif (rtlhal->during_mac1init_radioa)\n\t\t\tdbi_direct = BIT(3);\n\t\telse if (rtlhal->during_mac0init_radiob)\n\t\t\tdbi_direct = BIT(3) | BIT(2);\n\t\toriginalvalue = rtl92de_read_dword_dbi(hw, (u16)regaddr,\n\t\t\tdbi_direct);\n\t} else {\n\t\toriginalvalue = rtl_read_dword(rtlpriv, regaddr);\n\t}\n\tbitshift = calculate_bit_shift(bitmask);\n\treturnvalue = (originalvalue & bitmask) >> bitshift;\n\trtl_dbg(rtlpriv, COMP_RF, DBG_TRACE,\n\t\t\"BBR MASK=0x%x Addr[0x%x]=0x%x\\n\",\n\t\tbitmask, regaddr, originalvalue);\n\treturn returnvalue;\n}\n\nvoid rtl92d_phy_set_bb_reg(struct ieee80211_hw *hw,\n\t\t\t   u32 regaddr, u32 bitmask, u32 data)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\n\tu8 dbi_direct = 0;\n\tu32 originalvalue, bitshift;\n\n\trtl_dbg(rtlpriv, COMP_RF, DBG_TRACE,\n\t\t\"regaddr(%#x), bitmask(%#x), data(%#x)\\n\",\n\t\tregaddr, bitmask, data);\n\tif (rtlhal->during_mac1init_radioa)\n\t\tdbi_direct = BIT(3);\n\telse if (rtlhal->during_mac0init_radiob)\n\t\t \n\t\tdbi_direct = BIT(3) | BIT(2);\n\tif (bitmask != MASKDWORD) {\n\t\tif (rtlhal->during_mac1init_radioa ||\n\t\t    rtlhal->during_mac0init_radiob)\n\t\t\toriginalvalue = rtl92de_read_dword_dbi(hw,\n\t\t\t\t\t(u16) regaddr,\n\t\t\t\t\tdbi_direct);\n\t\telse\n\t\t\toriginalvalue = rtl_read_dword(rtlpriv, regaddr);\n\t\tbitshift = calculate_bit_shift(bitmask);\n\t\tdata = ((originalvalue & (~bitmask)) | (data << bitshift));\n\t}\n\tif (rtlhal->during_mac1init_radioa || rtlhal->during_mac0init_radiob)\n\t\trtl92de_write_dword_dbi(hw, (u16) regaddr, data, dbi_direct);\n\telse\n\t\trtl_write_dword(rtlpriv, regaddr, data);\n\trtl_dbg(rtlpriv, COMP_RF, DBG_TRACE,\n\t\t\"regaddr(%#x), bitmask(%#x), data(%#x)\\n\",\n\t\tregaddr, bitmask, data);\n}\n\nstatic u32 _rtl92d_phy_rf_serial_read(struct ieee80211_hw *hw,\n\t\t\t\t      enum radio_path rfpath, u32 offset)\n{\n\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct bb_reg_def *pphyreg = &rtlphy->phyreg_def[rfpath];\n\tu32 newoffset;\n\tu32 tmplong, tmplong2;\n\tu8 rfpi_enable = 0;\n\tu32 retvalue;\n\n\tnewoffset = offset;\n\ttmplong = rtl_get_bbreg(hw, RFPGA0_XA_HSSIPARAMETER2, MASKDWORD);\n\tif (rfpath == RF90_PATH_A)\n\t\ttmplong2 = tmplong;\n\telse\n\t\ttmplong2 = rtl_get_bbreg(hw, pphyreg->rfhssi_para2, MASKDWORD);\n\ttmplong2 = (tmplong2 & (~BLSSIREADADDRESS)) |\n\t\t(newoffset << 23) | BLSSIREADEDGE;\n\trtl_set_bbreg(hw, RFPGA0_XA_HSSIPARAMETER2, MASKDWORD,\n\t\ttmplong & (~BLSSIREADEDGE));\n\tudelay(10);\n\trtl_set_bbreg(hw, pphyreg->rfhssi_para2, MASKDWORD, tmplong2);\n\tudelay(50);\n\tudelay(50);\n\trtl_set_bbreg(hw, RFPGA0_XA_HSSIPARAMETER2, MASKDWORD,\n\t\ttmplong | BLSSIREADEDGE);\n\tudelay(10);\n\tif (rfpath == RF90_PATH_A)\n\t\trfpi_enable = (u8) rtl_get_bbreg(hw, RFPGA0_XA_HSSIPARAMETER1,\n\t\t\t      BIT(8));\n\telse if (rfpath == RF90_PATH_B)\n\t\trfpi_enable = (u8) rtl_get_bbreg(hw, RFPGA0_XB_HSSIPARAMETER1,\n\t\t\t      BIT(8));\n\tif (rfpi_enable)\n\t\tretvalue = rtl_get_bbreg(hw, pphyreg->rf_rbpi,\n\t\t\tBLSSIREADBACKDATA);\n\telse\n\t\tretvalue = rtl_get_bbreg(hw, pphyreg->rf_rb,\n\t\t\tBLSSIREADBACKDATA);\n\trtl_dbg(rtlpriv, COMP_RF, DBG_TRACE, \"RFR-%d Addr[0x%x] = 0x%x\\n\",\n\t\trfpath, pphyreg->rf_rb, retvalue);\n\treturn retvalue;\n}\n\nstatic void _rtl92d_phy_rf_serial_write(struct ieee80211_hw *hw,\n\t\t\t\t\tenum radio_path rfpath,\n\t\t\t\t\tu32 offset, u32 data)\n{\n\tu32 data_and_addr;\n\tu32 newoffset;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct bb_reg_def *pphyreg = &rtlphy->phyreg_def[rfpath];\n\n\tnewoffset = offset;\n\t \n\tdata_and_addr = ((newoffset << 20) | (data & 0x000fffff)) & 0x0fffffff;\n\trtl_set_bbreg(hw, pphyreg->rf3wire_offset, MASKDWORD, data_and_addr);\n\trtl_dbg(rtlpriv, COMP_RF, DBG_TRACE, \"RFW-%d Addr[0x%x]=0x%x\\n\",\n\t\trfpath, pphyreg->rf3wire_offset, data_and_addr);\n}\n\nu32 rtl92d_phy_query_rf_reg(struct ieee80211_hw *hw,\n\t\t\t    enum radio_path rfpath, u32 regaddr, u32 bitmask)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 original_value, readback_value, bitshift;\n\n\trtl_dbg(rtlpriv, COMP_RF, DBG_TRACE,\n\t\t\"regaddr(%#x), rfpath(%#x), bitmask(%#x)\\n\",\n\t\tregaddr, rfpath, bitmask);\n\tspin_lock(&rtlpriv->locks.rf_lock);\n\toriginal_value = _rtl92d_phy_rf_serial_read(hw, rfpath, regaddr);\n\tbitshift = calculate_bit_shift(bitmask);\n\treadback_value = (original_value & bitmask) >> bitshift;\n\tspin_unlock(&rtlpriv->locks.rf_lock);\n\trtl_dbg(rtlpriv, COMP_RF, DBG_TRACE,\n\t\t\"regaddr(%#x), rfpath(%#x), bitmask(%#x), original_value(%#x)\\n\",\n\t\tregaddr, rfpath, bitmask, original_value);\n\treturn readback_value;\n}\n\nvoid rtl92d_phy_set_rf_reg(struct ieee80211_hw *hw, enum radio_path rfpath,\n\tu32 regaddr, u32 bitmask, u32 data)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tu32 original_value, bitshift;\n\n\trtl_dbg(rtlpriv, COMP_RF, DBG_TRACE,\n\t\t\"regaddr(%#x), bitmask(%#x), data(%#x), rfpath(%#x)\\n\",\n\t\tregaddr, bitmask, data, rfpath);\n\tif (bitmask == 0)\n\t\treturn;\n\tspin_lock(&rtlpriv->locks.rf_lock);\n\tif (rtlphy->rf_mode != RF_OP_BY_FW) {\n\t\tif (bitmask != RFREG_OFFSET_MASK) {\n\t\t\toriginal_value = _rtl92d_phy_rf_serial_read(hw,\n\t\t\t\trfpath, regaddr);\n\t\t\tbitshift = calculate_bit_shift(bitmask);\n\t\t\tdata = ((original_value & (~bitmask)) |\n\t\t\t\t(data << bitshift));\n\t\t}\n\t\t_rtl92d_phy_rf_serial_write(hw, rfpath, regaddr, data);\n\t}\n\tspin_unlock(&rtlpriv->locks.rf_lock);\n\trtl_dbg(rtlpriv, COMP_RF, DBG_TRACE,\n\t\t\"regaddr(%#x), bitmask(%#x), data(%#x), rfpath(%#x)\\n\",\n\t\tregaddr, bitmask, data, rfpath);\n}\n\nbool rtl92d_phy_mac_config(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 i;\n\tu32 arraylength;\n\tu32 *ptrarray;\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE, \"Read Rtl819XMACPHY_Array\\n\");\n\tarraylength = MAC_2T_ARRAYLENGTH;\n\tptrarray = rtl8192de_mac_2tarray;\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE, \"Img:Rtl819XMAC_Array\\n\");\n\tfor (i = 0; i < arraylength; i = i + 2)\n\t\trtl_write_byte(rtlpriv, ptrarray[i], (u8) ptrarray[i + 1]);\n\tif (rtlpriv->rtlhal.macphymode == SINGLEMAC_SINGLEPHY) {\n\t\t \n\t\t \n\t\t \n\t\t \n\t\trtl_write_byte(rtlpriv, REG_MAX_AGGR_NUM, 0x0B);\n\t} else {\n\t\t \n\t\trtl_write_byte(rtlpriv, REG_MAX_AGGR_NUM, 0x07);\n\t}\n\treturn true;\n}\n\nstatic void _rtl92d_phy_init_bb_rf_register_definition(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\n\t \n\t \n\trtlphy->phyreg_def[RF90_PATH_A].rfintfs = RFPGA0_XAB_RFINTERFACESW;\n\t \n\trtlphy->phyreg_def[RF90_PATH_B].rfintfs = RFPGA0_XAB_RFINTERFACESW;\n\t \n\trtlphy->phyreg_def[RF90_PATH_C].rfintfs = RFPGA0_XCD_RFINTERFACESW;\n\t \n\n\trtlphy->phyreg_def[RF90_PATH_D].rfintfs = RFPGA0_XCD_RFINTERFACESW;\n\t \n\t \n\trtlphy->phyreg_def[RF90_PATH_A].rfintfi = RFPGA0_XAB_RFINTERFACERB;\n\t \n\trtlphy->phyreg_def[RF90_PATH_B].rfintfi = RFPGA0_XAB_RFINTERFACERB;\n\t \n\trtlphy->phyreg_def[RF90_PATH_C].rfintfi = RFPGA0_XCD_RFINTERFACERB;\n\t \n\trtlphy->phyreg_def[RF90_PATH_D].rfintfi = RFPGA0_XCD_RFINTERFACERB;\n\n\t \n\t \n\trtlphy->phyreg_def[RF90_PATH_A].rfintfo = RFPGA0_XA_RFINTERFACEOE;\n\t \n\trtlphy->phyreg_def[RF90_PATH_B].rfintfo = RFPGA0_XB_RFINTERFACEOE;\n\n\t \n\t \n\trtlphy->phyreg_def[RF90_PATH_A].rfintfe = RFPGA0_XA_RFINTERFACEOE;\n\t \n\trtlphy->phyreg_def[RF90_PATH_B].rfintfe = RFPGA0_XB_RFINTERFACEOE;\n\n\t \n\t \n\trtlphy->phyreg_def[RF90_PATH_A].rf3wire_offset =\n\t\t\t\t RFPGA0_XA_LSSIPARAMETER;\n\trtlphy->phyreg_def[RF90_PATH_B].rf3wire_offset =\n\t\t\t\t RFPGA0_XB_LSSIPARAMETER;\n\n\t \n\t \n\trtlphy->phyreg_def[RF90_PATH_A].rflssi_select = RFPGA0_XAB_RFPARAMETER;\n\trtlphy->phyreg_def[RF90_PATH_B].rflssi_select = RFPGA0_XAB_RFPARAMETER;\n\trtlphy->phyreg_def[RF90_PATH_C].rflssi_select = RFPGA0_XCD_RFPARAMETER;\n\trtlphy->phyreg_def[RF90_PATH_D].rflssi_select = RFPGA0_XCD_RFPARAMETER;\n\n\t \n\t \n\trtlphy->phyreg_def[RF90_PATH_A].rftxgain_stage = RFPGA0_TXGAINSTAGE;\n\t \n\trtlphy->phyreg_def[RF90_PATH_B].rftxgain_stage = RFPGA0_TXGAINSTAGE;\n\t \n\trtlphy->phyreg_def[RF90_PATH_C].rftxgain_stage = RFPGA0_TXGAINSTAGE;\n\t \n\trtlphy->phyreg_def[RF90_PATH_D].rftxgain_stage = RFPGA0_TXGAINSTAGE;\n\n\t \n\t \n\trtlphy->phyreg_def[RF90_PATH_A].rfhssi_para1 = RFPGA0_XA_HSSIPARAMETER1;\n\t \n\trtlphy->phyreg_def[RF90_PATH_B].rfhssi_para1 = RFPGA0_XB_HSSIPARAMETER1;\n\n\t \n\t \n\trtlphy->phyreg_def[RF90_PATH_A].rfhssi_para2 = RFPGA0_XA_HSSIPARAMETER2;\n\t \n\trtlphy->phyreg_def[RF90_PATH_B].rfhssi_para2 = RFPGA0_XB_HSSIPARAMETER2;\n\n\t \n\t \n\trtlphy->phyreg_def[RF90_PATH_A].rfsw_ctrl = RFPGA0_XAB_SWITCHCONTROL;\n\trtlphy->phyreg_def[RF90_PATH_B].rfsw_ctrl = RFPGA0_XAB_SWITCHCONTROL;\n\trtlphy->phyreg_def[RF90_PATH_C].rfsw_ctrl = RFPGA0_XCD_SWITCHCONTROL;\n\trtlphy->phyreg_def[RF90_PATH_D].rfsw_ctrl = RFPGA0_XCD_SWITCHCONTROL;\n\n\t \n\trtlphy->phyreg_def[RF90_PATH_A].rfagc_control1 = ROFDM0_XAAGCCORE1;\n\trtlphy->phyreg_def[RF90_PATH_B].rfagc_control1 = ROFDM0_XBAGCCORE1;\n\trtlphy->phyreg_def[RF90_PATH_C].rfagc_control1 = ROFDM0_XCAGCCORE1;\n\trtlphy->phyreg_def[RF90_PATH_D].rfagc_control1 = ROFDM0_XDAGCCORE1;\n\n\t \n\trtlphy->phyreg_def[RF90_PATH_A].rfagc_control2 = ROFDM0_XAAGCCORE2;\n\trtlphy->phyreg_def[RF90_PATH_B].rfagc_control2 = ROFDM0_XBAGCCORE2;\n\trtlphy->phyreg_def[RF90_PATH_C].rfagc_control2 = ROFDM0_XCAGCCORE2;\n\trtlphy->phyreg_def[RF90_PATH_D].rfagc_control2 = ROFDM0_XDAGCCORE2;\n\n\t \n\trtlphy->phyreg_def[RF90_PATH_A].rfrxiq_imbal = ROFDM0_XARXIQIMBALANCE;\n\trtlphy->phyreg_def[RF90_PATH_B].rfrxiq_imbal = ROFDM0_XBRXIQIMBALANCE;\n\trtlphy->phyreg_def[RF90_PATH_C].rfrxiq_imbal = ROFDM0_XCRXIQIMBALANCE;\n\trtlphy->phyreg_def[RF90_PATH_D].rfrxiq_imbal = ROFDM0_XDRXIQIMBALANCE;\n\n\t \n\trtlphy->phyreg_def[RF90_PATH_A].rfrx_afe = ROFDM0_XARXAFE;\n\trtlphy->phyreg_def[RF90_PATH_B].rfrx_afe = ROFDM0_XBRXAFE;\n\trtlphy->phyreg_def[RF90_PATH_C].rfrx_afe = ROFDM0_XCRXAFE;\n\trtlphy->phyreg_def[RF90_PATH_D].rfrx_afe = ROFDM0_XDRXAFE;\n\n\t \n\trtlphy->phyreg_def[RF90_PATH_A].rftxiq_imbal = ROFDM0_XATXIQIMBALANCE;\n\trtlphy->phyreg_def[RF90_PATH_B].rftxiq_imbal = ROFDM0_XBTXIQIMBALANCE;\n\trtlphy->phyreg_def[RF90_PATH_C].rftxiq_imbal = ROFDM0_XCTXIQIMBALANCE;\n\trtlphy->phyreg_def[RF90_PATH_D].rftxiq_imbal = ROFDM0_XDTXIQIMBALANCE;\n\n\t \n\trtlphy->phyreg_def[RF90_PATH_A].rftx_afe = ROFDM0_XATXAFE;\n\trtlphy->phyreg_def[RF90_PATH_B].rftx_afe = ROFDM0_XBTXAFE;\n\trtlphy->phyreg_def[RF90_PATH_C].rftx_afe = ROFDM0_XCTXAFE;\n\trtlphy->phyreg_def[RF90_PATH_D].rftx_afe = ROFDM0_XDTXAFE;\n\n\t \n\trtlphy->phyreg_def[RF90_PATH_A].rf_rb = RFPGA0_XA_LSSIREADBACK;\n\trtlphy->phyreg_def[RF90_PATH_B].rf_rb = RFPGA0_XB_LSSIREADBACK;\n\trtlphy->phyreg_def[RF90_PATH_C].rf_rb = RFPGA0_XC_LSSIREADBACK;\n\trtlphy->phyreg_def[RF90_PATH_D].rf_rb = RFPGA0_XD_LSSIREADBACK;\n\n\t \n\trtlphy->phyreg_def[RF90_PATH_A].rf_rbpi = TRANSCEIVERA_HSPI_READBACK;\n\trtlphy->phyreg_def[RF90_PATH_B].rf_rbpi = TRANSCEIVERB_HSPI_READBACK;\n}\n\nstatic bool _rtl92d_phy_config_bb_with_headerfile(struct ieee80211_hw *hw,\n\tu8 configtype)\n{\n\tint i;\n\tu32 *phy_regarray_table;\n\tu32 *agctab_array_table = NULL;\n\tu32 *agctab_5garray_table;\n\tu16 phy_reg_arraylen, agctab_arraylen = 0, agctab_5garraylen;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\n\t \n\tif (rtlhal->interfaceindex == 0) {\n\t\tagctab_arraylen = AGCTAB_ARRAYLENGTH;\n\t\tagctab_array_table = rtl8192de_agctab_array;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\" ===> phy:MAC0, Rtl819XAGCTAB_Array\\n\");\n\t} else {\n\t\tif (rtlhal->current_bandtype == BAND_ON_2_4G) {\n\t\t\tagctab_arraylen = AGCTAB_2G_ARRAYLENGTH;\n\t\t\tagctab_array_table = rtl8192de_agctab_2garray;\n\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\t\" ===> phy:MAC1, Rtl819XAGCTAB_2GArray\\n\");\n\t\t} else {\n\t\t\tagctab_5garraylen = AGCTAB_5G_ARRAYLENGTH;\n\t\t\tagctab_5garray_table = rtl8192de_agctab_5garray;\n\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\t\" ===> phy:MAC1, Rtl819XAGCTAB_5GArray\\n\");\n\n\t\t}\n\t}\n\tphy_reg_arraylen = PHY_REG_2T_ARRAYLENGTH;\n\tphy_regarray_table = rtl8192de_phy_reg_2tarray;\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\" ===> phy:Rtl819XPHY_REG_Array_PG\\n\");\n\tif (configtype == BASEBAND_CONFIG_PHY_REG) {\n\t\tfor (i = 0; i < phy_reg_arraylen; i = i + 2) {\n\t\t\trtl_addr_delay(phy_regarray_table[i]);\n\t\t\trtl_set_bbreg(hw, phy_regarray_table[i], MASKDWORD,\n\t\t\t\t      phy_regarray_table[i + 1]);\n\t\t\tudelay(1);\n\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\t\t\"The phy_regarray_table[0] is %x Rtl819XPHY_REGArray[1] is %x\\n\",\n\t\t\t\tphy_regarray_table[i],\n\t\t\t\tphy_regarray_table[i + 1]);\n\t\t}\n\t} else if (configtype == BASEBAND_CONFIG_AGC_TAB) {\n\t\tif (rtlhal->interfaceindex == 0) {\n\t\t\tfor (i = 0; i < agctab_arraylen; i = i + 2) {\n\t\t\t\trtl_set_bbreg(hw, agctab_array_table[i],\n\t\t\t\t\tMASKDWORD,\n\t\t\t\t\tagctab_array_table[i + 1]);\n\t\t\t\t \n\t\t\t\tudelay(1);\n\t\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\t\t\t\"The Rtl819XAGCTAB_Array_Table[0] is %u Rtl819XPHY_REGArray[1] is %u\\n\",\n\t\t\t\t\tagctab_array_table[i],\n\t\t\t\t\tagctab_array_table[i + 1]);\n\t\t\t}\n\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\t\"Normal Chip, MAC0, load Rtl819XAGCTAB_Array\\n\");\n\t\t} else {\n\t\t\tif (rtlhal->current_bandtype == BAND_ON_2_4G) {\n\t\t\t\tfor (i = 0; i < agctab_arraylen; i = i + 2) {\n\t\t\t\t\trtl_set_bbreg(hw, agctab_array_table[i],\n\t\t\t\t\t\tMASKDWORD,\n\t\t\t\t\t\tagctab_array_table[i + 1]);\n\t\t\t\t\t \n\t\t\t\t\tudelay(1);\n\t\t\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\t\t\t\t\"The Rtl819XAGCTAB_Array_Table[0] is %u Rtl819XPHY_REGArray[1] is %u\\n\",\n\t\t\t\t\t\tagctab_array_table[i],\n\t\t\t\t\t\tagctab_array_table[i + 1]);\n\t\t\t\t}\n\t\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\t\t\"Load Rtl819XAGCTAB_2GArray\\n\");\n\t\t\t} else {\n\t\t\t\tfor (i = 0; i < agctab_5garraylen; i = i + 2) {\n\t\t\t\t\trtl_set_bbreg(hw,\n\t\t\t\t\t\tagctab_5garray_table[i],\n\t\t\t\t\t\tMASKDWORD,\n\t\t\t\t\t\tagctab_5garray_table[i + 1]);\n\t\t\t\t\t \n\t\t\t\t\tudelay(1);\n\t\t\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\t\t\t\t\"The Rtl819XAGCTAB_5GArray_Table[0] is %u Rtl819XPHY_REGArray[1] is %u\\n\",\n\t\t\t\t\t\tagctab_5garray_table[i],\n\t\t\t\t\t\tagctab_5garray_table[i + 1]);\n\t\t\t\t}\n\t\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\t\t\"Load Rtl819XAGCTAB_5GArray\\n\");\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic void _rtl92d_store_pwrindex_diffrate_offset(struct ieee80211_hw *hw,\n\t\t\t\t\t\t   u32 regaddr, u32 bitmask,\n\t\t\t\t\t\t   u32 data)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tint index;\n\n\tif (regaddr == RTXAGC_A_RATE18_06)\n\t\tindex = 0;\n\telse if (regaddr == RTXAGC_A_RATE54_24)\n\t\tindex = 1;\n\telse if (regaddr == RTXAGC_A_CCK1_MCS32)\n\t\tindex = 6;\n\telse if (regaddr == RTXAGC_B_CCK11_A_CCK2_11 && bitmask == 0xffffff00)\n\t\tindex = 7;\n\telse if (regaddr == RTXAGC_A_MCS03_MCS00)\n\t\tindex = 2;\n\telse if (regaddr == RTXAGC_A_MCS07_MCS04)\n\t\tindex = 3;\n\telse if (regaddr == RTXAGC_A_MCS11_MCS08)\n\t\tindex = 4;\n\telse if (regaddr == RTXAGC_A_MCS15_MCS12)\n\t\tindex = 5;\n\telse if (regaddr == RTXAGC_B_RATE18_06)\n\t\tindex = 8;\n\telse if (regaddr == RTXAGC_B_RATE54_24)\n\t\tindex = 9;\n\telse if (regaddr == RTXAGC_B_CCK1_55_MCS32)\n\t\tindex = 14;\n\telse if (regaddr == RTXAGC_B_CCK11_A_CCK2_11 && bitmask == 0x000000ff)\n\t\tindex = 15;\n\telse if (regaddr == RTXAGC_B_MCS03_MCS00)\n\t\tindex = 10;\n\telse if (regaddr == RTXAGC_B_MCS07_MCS04)\n\t\tindex = 11;\n\telse if (regaddr == RTXAGC_B_MCS11_MCS08)\n\t\tindex = 12;\n\telse if (regaddr == RTXAGC_B_MCS15_MCS12)\n\t\tindex = 13;\n\telse\n\t\treturn;\n\n\trtlphy->mcs_offset[rtlphy->pwrgroup_cnt][index] = data;\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\"MCSTxPowerLevelOriginalOffset[%d][%d] = 0x%x\\n\",\n\t\trtlphy->pwrgroup_cnt, index,\n\t\trtlphy->mcs_offset[rtlphy->pwrgroup_cnt][index]);\n\tif (index == 13)\n\t\trtlphy->pwrgroup_cnt++;\n}\n\nstatic bool _rtl92d_phy_config_bb_with_pgheaderfile(struct ieee80211_hw *hw,\n\tu8 configtype)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tint i;\n\tu32 *phy_regarray_table_pg;\n\tu16 phy_regarray_pg_len;\n\n\tphy_regarray_pg_len = PHY_REG_ARRAY_PG_LENGTH;\n\tphy_regarray_table_pg = rtl8192de_phy_reg_array_pg;\n\tif (configtype == BASEBAND_CONFIG_PHY_REG) {\n\t\tfor (i = 0; i < phy_regarray_pg_len; i = i + 3) {\n\t\t\trtl_addr_delay(phy_regarray_table_pg[i]);\n\t\t\t_rtl92d_store_pwrindex_diffrate_offset(hw,\n\t\t\t\tphy_regarray_table_pg[i],\n\t\t\t\tphy_regarray_table_pg[i + 1],\n\t\t\t\tphy_regarray_table_pg[i + 2]);\n\t\t}\n\t} else {\n\t\trtl_dbg(rtlpriv, COMP_SEND, DBG_TRACE,\n\t\t\t\"configtype != BaseBand_Config_PHY_REG\\n\");\n\t}\n\treturn true;\n}\n\nstatic bool _rtl92d_phy_bb_config(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tbool rtstatus;\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE, \"==>\\n\");\n\trtstatus = _rtl92d_phy_config_bb_with_headerfile(hw,\n\t\tBASEBAND_CONFIG_PHY_REG);\n\tif (!rtstatus) {\n\t\tpr_err(\"Write BB Reg Fail!!\\n\");\n\t\treturn false;\n\t}\n\n\t \n\n\tif (rtlefuse->autoload_failflag == false) {\n\t\trtlphy->pwrgroup_cnt = 0;\n\t\trtstatus = _rtl92d_phy_config_bb_with_pgheaderfile(hw,\n\t\t\tBASEBAND_CONFIG_PHY_REG);\n\t}\n\tif (!rtstatus) {\n\t\tpr_err(\"BB_PG Reg Fail!!\\n\");\n\t\treturn false;\n\t}\n\trtstatus = _rtl92d_phy_config_bb_with_headerfile(hw,\n\t\tBASEBAND_CONFIG_AGC_TAB);\n\tif (!rtstatus) {\n\t\tpr_err(\"AGC Table Fail\\n\");\n\t\treturn false;\n\t}\n\trtlphy->cck_high_power = (bool) (rtl_get_bbreg(hw,\n\t\tRFPGA0_XA_HSSIPARAMETER2, 0x200));\n\n\treturn true;\n}\n\nbool rtl92d_phy_bb_config(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu16 regval;\n\tu32 regvaldw;\n\tu8 value;\n\n\t_rtl92d_phy_init_bb_rf_register_definition(hw);\n\tregval = rtl_read_word(rtlpriv, REG_SYS_FUNC_EN);\n\trtl_write_word(rtlpriv, REG_SYS_FUNC_EN,\n\t\t       regval | BIT(13) | BIT(0) | BIT(1));\n\trtl_write_byte(rtlpriv, REG_AFE_PLL_CTRL, 0x83);\n\trtl_write_byte(rtlpriv, REG_AFE_PLL_CTRL + 1, 0xdb);\n\t \n\tvalue = rtl_read_byte(rtlpriv, REG_RF_CTRL);\n\trtl_write_byte(rtlpriv, REG_RF_CTRL, value | RF_EN | RF_RSTB |\n\t\tRF_SDMRSTB);\n\trtl_write_byte(rtlpriv, REG_SYS_FUNC_EN, FEN_PPLL | FEN_PCIEA |\n\t\tFEN_DIO_PCIE | FEN_BB_GLB_RSTN | FEN_BBRSTB);\n\trtl_write_byte(rtlpriv, REG_AFE_XTAL_CTRL + 1, 0x80);\n\tif (!(IS_92D_SINGLEPHY(rtlpriv->rtlhal.version))) {\n\t\tregvaldw = rtl_read_dword(rtlpriv, REG_LEDCFG0);\n\t\trtl_write_dword(rtlpriv, REG_LEDCFG0, regvaldw | BIT(23));\n\t}\n\n\treturn _rtl92d_phy_bb_config(hw);\n}\n\nbool rtl92d_phy_rf_config(struct ieee80211_hw *hw)\n{\n\treturn rtl92d_phy_rf6052_config(hw);\n}\n\nbool rtl92d_phy_config_rf_with_headerfile(struct ieee80211_hw *hw,\n\t\t\t\t\t  enum rf_content content,\n\t\t\t\t\t  enum radio_path rfpath)\n{\n\tint i;\n\tu32 *radioa_array_table;\n\tu32 *radiob_array_table;\n\tu16 radioa_arraylen, radiob_arraylen;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\tradioa_arraylen = RADIOA_2T_ARRAYLENGTH;\n\tradioa_array_table = rtl8192de_radioa_2tarray;\n\tradiob_arraylen = RADIOB_2T_ARRAYLENGTH;\n\tradiob_array_table = rtl8192de_radiob_2tarray;\n\tif (rtlpriv->efuse.internal_pa_5g[0]) {\n\t\tradioa_arraylen = RADIOA_2T_INT_PA_ARRAYLENGTH;\n\t\tradioa_array_table = rtl8192de_radioa_2t_int_paarray;\n\t}\n\tif (rtlpriv->efuse.internal_pa_5g[1]) {\n\t\tradiob_arraylen = RADIOB_2T_INT_PA_ARRAYLENGTH;\n\t\tradiob_array_table = rtl8192de_radiob_2t_int_paarray;\n\t}\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\"PHY_ConfigRFWithHeaderFile() Radio_A:Rtl819XRadioA_1TArray\\n\");\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\"PHY_ConfigRFWithHeaderFile() Radio_B:Rtl819XRadioB_1TArray\\n\");\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE, \"Radio No %x\\n\", rfpath);\n\n\t \n\tif ((content == radiob_txt) && (rfpath == RF90_PATH_A)) {\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\" ===> althougth Path A, we load radiob.txt\\n\");\n\t\tradioa_arraylen = radiob_arraylen;\n\t\tradioa_array_table = radiob_array_table;\n\t}\n\tswitch (rfpath) {\n\tcase RF90_PATH_A:\n\t\tfor (i = 0; i < radioa_arraylen; i = i + 2) {\n\t\t\trtl_rfreg_delay(hw, rfpath, radioa_array_table[i],\n\t\t\t\t\tRFREG_OFFSET_MASK,\n\t\t\t\t\tradioa_array_table[i + 1]);\n\t\t}\n\t\tbreak;\n\tcase RF90_PATH_B:\n\t\tfor (i = 0; i < radiob_arraylen; i = i + 2) {\n\t\t\trtl_rfreg_delay(hw, rfpath, radiob_array_table[i],\n\t\t\t\t\tRFREG_OFFSET_MASK,\n\t\t\t\t\tradiob_array_table[i + 1]);\n\t\t}\n\t\tbreak;\n\tcase RF90_PATH_C:\n\tcase RF90_PATH_D:\n\t\tpr_err(\"switch case %#x not processed\\n\", rfpath);\n\t\tbreak;\n\t}\n\treturn true;\n}\n\nvoid rtl92d_phy_get_hw_reg_originalvalue(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\n\trtlphy->default_initialgain[0] =\n\t    (u8) rtl_get_bbreg(hw, ROFDM0_XAAGCCORE1, MASKBYTE0);\n\trtlphy->default_initialgain[1] =\n\t    (u8) rtl_get_bbreg(hw, ROFDM0_XBAGCCORE1, MASKBYTE0);\n\trtlphy->default_initialgain[2] =\n\t    (u8) rtl_get_bbreg(hw, ROFDM0_XCAGCCORE1, MASKBYTE0);\n\trtlphy->default_initialgain[3] =\n\t    (u8) rtl_get_bbreg(hw, ROFDM0_XDAGCCORE1, MASKBYTE0);\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\"Default initial gain (c50=0x%x, c58=0x%x, c60=0x%x, c68=0x%x\\n\",\n\t\trtlphy->default_initialgain[0],\n\t\trtlphy->default_initialgain[1],\n\t\trtlphy->default_initialgain[2],\n\t\trtlphy->default_initialgain[3]);\n\trtlphy->framesync = (u8)rtl_get_bbreg(hw, ROFDM0_RXDETECTOR3,\n\t\t\t\t\t      MASKBYTE0);\n\trtlphy->framesync_c34 = rtl_get_bbreg(hw, ROFDM0_RXDETECTOR2,\n\t\t\t\t\t      MASKDWORD);\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\"Default framesync (0x%x) = 0x%x\\n\",\n\t\tROFDM0_RXDETECTOR3, rtlphy->framesync);\n}\n\nstatic void _rtl92d_get_txpower_index(struct ieee80211_hw *hw, u8 channel,\n\tu8 *cckpowerlevel, u8 *ofdmpowerlevel)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct rtl_hal *rtlhal = &(rtlpriv->rtlhal);\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tu8 index = (channel - 1);\n\n\t \n\tif (rtlhal->current_bandtype == BAND_ON_2_4G) {\n\t\t \n\t\tcckpowerlevel[RF90_PATH_A] =\n\t\t\t\t rtlefuse->txpwrlevel_cck[RF90_PATH_A][index];\n\t\t \n\t\tcckpowerlevel[RF90_PATH_B] =\n\t\t\t\t rtlefuse->txpwrlevel_cck[RF90_PATH_B][index];\n\t} else {\n\t\tcckpowerlevel[RF90_PATH_A] = 0;\n\t\tcckpowerlevel[RF90_PATH_B] = 0;\n\t}\n\t \n\tif (rtlphy->rf_type == RF_1T2R || rtlphy->rf_type == RF_1T1R) {\n\t\t \n\t\tofdmpowerlevel[RF90_PATH_A] =\n\t\t    rtlefuse->txpwrlevel_ht40_1s[RF90_PATH_A][index];\n\t\tofdmpowerlevel[RF90_PATH_B] =\n\t\t    rtlefuse->txpwrlevel_ht40_1s[RF90_PATH_B][index];\n\t} else if (rtlphy->rf_type == RF_2T2R) {\n\t\t \n\t\tofdmpowerlevel[RF90_PATH_A] =\n\t\t    rtlefuse->txpwrlevel_ht40_2s[RF90_PATH_A][index];\n\t\tofdmpowerlevel[RF90_PATH_B] =\n\t\t    rtlefuse->txpwrlevel_ht40_2s[RF90_PATH_B][index];\n\t}\n}\n\nstatic void _rtl92d_ccxpower_index_check(struct ieee80211_hw *hw,\n\tu8 channel, u8 *cckpowerlevel, u8 *ofdmpowerlevel)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\n\trtlphy->cur_cck_txpwridx = cckpowerlevel[0];\n\trtlphy->cur_ofdm24g_txpwridx = ofdmpowerlevel[0];\n}\n\nstatic u8 _rtl92c_phy_get_rightchnlplace(u8 chnl)\n{\n\tu8 place = chnl;\n\n\tif (chnl > 14) {\n\t\tfor (place = 14; place < ARRAY_SIZE(channel5g); place++) {\n\t\t\tif (channel5g[place] == chnl) {\n\t\t\t\tplace++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn place;\n}\n\nvoid rtl92d_phy_set_txpower_level(struct ieee80211_hw *hw, u8 channel)\n{\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 cckpowerlevel[2], ofdmpowerlevel[2];\n\n\tif (!rtlefuse->txpwr_fromeprom)\n\t\treturn;\n\tchannel = _rtl92c_phy_get_rightchnlplace(channel);\n\t_rtl92d_get_txpower_index(hw, channel, &cckpowerlevel[0],\n\t\t&ofdmpowerlevel[0]);\n\tif (rtlpriv->rtlhal.current_bandtype == BAND_ON_2_4G)\n\t\t_rtl92d_ccxpower_index_check(hw, channel, &cckpowerlevel[0],\n\t\t\t\t&ofdmpowerlevel[0]);\n\tif (rtlpriv->rtlhal.current_bandtype == BAND_ON_2_4G)\n\t\trtl92d_phy_rf6052_set_cck_txpower(hw, &cckpowerlevel[0]);\n\trtl92d_phy_rf6052_set_ofdm_txpower(hw, &ofdmpowerlevel[0], channel);\n}\n\nvoid rtl92d_phy_set_bw_mode(struct ieee80211_hw *hw,\n\t\t\t    enum nl80211_channel_type ch_type)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tunsigned long flag = 0;\n\tu8 reg_prsr_rsc;\n\tu8 reg_bw_opmode;\n\n\tif (rtlphy->set_bwmode_inprogress)\n\t\treturn;\n\tif ((is_hal_stop(rtlhal)) || (RT_CANNOT_IO(hw))) {\n\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_WARNING,\n\t\t\t\"FALSE driver sleep or unload\\n\");\n\t\treturn;\n\t}\n\trtlphy->set_bwmode_inprogress = true;\n\trtl_dbg(rtlpriv, COMP_SCAN, DBG_TRACE, \"Switch to %s bandwidth\\n\",\n\t\trtlphy->current_chan_bw == HT_CHANNEL_WIDTH_20 ?\n\t\t\"20MHz\" : \"40MHz\");\n\treg_bw_opmode = rtl_read_byte(rtlpriv, REG_BWOPMODE);\n\treg_prsr_rsc = rtl_read_byte(rtlpriv, REG_RRSR + 2);\n\tswitch (rtlphy->current_chan_bw) {\n\tcase HT_CHANNEL_WIDTH_20:\n\t\treg_bw_opmode |= BW_OPMODE_20MHZ;\n\t\trtl_write_byte(rtlpriv, REG_BWOPMODE, reg_bw_opmode);\n\t\tbreak;\n\tcase HT_CHANNEL_WIDTH_20_40:\n\t\treg_bw_opmode &= ~BW_OPMODE_20MHZ;\n\t\trtl_write_byte(rtlpriv, REG_BWOPMODE, reg_bw_opmode);\n\n\t\treg_prsr_rsc = (reg_prsr_rsc & 0x90) |\n\t\t\t(mac->cur_40_prime_sc << 5);\n\t\trtl_write_byte(rtlpriv, REG_RRSR + 2, reg_prsr_rsc);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"unknown bandwidth: %#X\\n\",\n\t\t       rtlphy->current_chan_bw);\n\t\tbreak;\n\t}\n\tswitch (rtlphy->current_chan_bw) {\n\tcase HT_CHANNEL_WIDTH_20:\n\t\trtl_set_bbreg(hw, RFPGA0_RFMOD, BRFMOD, 0x0);\n\t\trtl_set_bbreg(hw, RFPGA1_RFMOD, BRFMOD, 0x0);\n\t\t \n\t\trtl_set_bbreg(hw, RFPGA0_ANALOGPARAMETER2, BIT(10) |\n\t\t\t      BIT(11), 3);\n\t\tbreak;\n\tcase HT_CHANNEL_WIDTH_20_40:\n\t\trtl_set_bbreg(hw, RFPGA0_RFMOD, BRFMOD, 0x1);\n\t\trtl_set_bbreg(hw, RFPGA1_RFMOD, BRFMOD, 0x1);\n\t\t \n\t\tif (rtlhal->current_bandtype == BAND_ON_2_4G) {\n\t\t\trtl92d_acquire_cckandrw_pagea_ctl(hw, &flag);\n\t\t\trtl_set_bbreg(hw, RCCK0_SYSTEM, BCCKSIDEBAND,\n\t\t\t\t(mac->cur_40_prime_sc >> 1));\n\t\t\trtl92d_release_cckandrw_pagea_ctl(hw, &flag);\n\t\t}\n\t\trtl_set_bbreg(hw, ROFDM1_LSTF, 0xC00, mac->cur_40_prime_sc);\n\t\t \n\t\trtl_set_bbreg(hw, RFPGA0_ANALOGPARAMETER2, BIT(10) |\n\t\t\t      BIT(11), 0);\n\t\trtl_set_bbreg(hw, 0x818, (BIT(26) | BIT(27)),\n\t\t\t(mac->cur_40_prime_sc ==\n\t\t\tHAL_PRIME_CHNL_OFFSET_LOWER) ? 2 : 1);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"unknown bandwidth: %#X\\n\",\n\t\t       rtlphy->current_chan_bw);\n\t\tbreak;\n\n\t}\n\trtl92d_phy_rf6052_set_bandwidth(hw, rtlphy->current_chan_bw);\n\trtlphy->set_bwmode_inprogress = false;\n\trtl_dbg(rtlpriv, COMP_SCAN, DBG_TRACE, \"<==\\n\");\n}\n\nstatic void _rtl92d_phy_stop_trx_before_changeband(struct ieee80211_hw *hw)\n{\n\trtl_set_bbreg(hw, RFPGA0_RFMOD, BCCKEN, 0);\n\trtl_set_bbreg(hw, RFPGA0_RFMOD, BOFDMEN, 0);\n\trtl_set_bbreg(hw, ROFDM0_TRXPATHENABLE, MASKBYTE0, 0x00);\n\trtl_set_bbreg(hw, ROFDM1_TRXPATHENABLE, BDWORD, 0x0);\n}\n\nstatic void rtl92d_phy_switch_wirelessband(struct ieee80211_hw *hw, u8 band)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tu8 value8;\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD, \"==>\\n\");\n\trtlhal->bandset = band;\n\trtlhal->current_bandtype = band;\n\tif (IS_92D_SINGLEPHY(rtlhal->version))\n\t\trtlhal->bandset = BAND_ON_BOTH;\n\t \n\t_rtl92d_phy_stop_trx_before_changeband(hw);\n\t \n\tif (rtlhal->current_bandtype == BAND_ON_2_4G) {\n\t\t \n\t\trtl_dbg(rtlpriv, COMP_CMD, DBG_DMESG, \"====>2.4G\\n\");\n\t\tif (rtlhal->interfaceindex == 1)\n\t\t\t_rtl92d_phy_config_bb_with_headerfile(hw,\n\t\t\t\tBASEBAND_CONFIG_AGC_TAB);\n\t} else {\n\t\t \n\t\trtl_dbg(rtlpriv, COMP_CMD, DBG_DMESG, \"====>5G\\n\");\n\t\tif (rtlhal->interfaceindex == 1)\n\t\t\t_rtl92d_phy_config_bb_with_headerfile(hw,\n\t\t\t\tBASEBAND_CONFIG_AGC_TAB);\n\t}\n\trtl92d_update_bbrf_configuration(hw);\n\tif (rtlhal->current_bandtype == BAND_ON_2_4G)\n\t\trtl_set_bbreg(hw, RFPGA0_RFMOD, BCCKEN, 0x1);\n\trtl_set_bbreg(hw, RFPGA0_RFMOD, BOFDMEN, 0x1);\n\n\t \n\t \n\trtlhal->reloadtxpowerindex = true;\n\t \n\tif (rtlhal->current_bandtype == BAND_ON_2_4G) {\n\t\tvalue8 = rtl_read_byte(rtlpriv,\t(rtlhal->interfaceindex ==\n\t\t\t0 ? REG_MAC0 : REG_MAC1));\n\t\tvalue8 |= BIT(1);\n\t\trtl_write_byte(rtlpriv, (rtlhal->interfaceindex ==\n\t\t\t0 ? REG_MAC0 : REG_MAC1), value8);\n\t} else {\n\t\tvalue8 = rtl_read_byte(rtlpriv, (rtlhal->interfaceindex ==\n\t\t\t0 ? REG_MAC0 : REG_MAC1));\n\t\tvalue8 &= (~BIT(1));\n\t\trtl_write_byte(rtlpriv, (rtlhal->interfaceindex ==\n\t\t\t0 ? REG_MAC0 : REG_MAC1), value8);\n\t}\n\tmdelay(1);\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD, \"<==Switch Band OK\\n\");\n}\n\nstatic void _rtl92d_phy_reload_imr_setting(struct ieee80211_hw *hw,\n\tu8 channel, u8 rfpath)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 imr_num = MAX_RF_IMR_INDEX;\n\tu32 rfmask = RFREG_OFFSET_MASK;\n\tu8 group, i;\n\tunsigned long flag = 0;\n\n\trtl_dbg(rtlpriv, COMP_CMD, DBG_LOUD, \"====>path %d\\n\", rfpath);\n\tif (rtlpriv->rtlhal.current_bandtype == BAND_ON_5G) {\n\t\trtl_dbg(rtlpriv, COMP_CMD, DBG_LOUD, \"====>5G\\n\");\n\t\trtl_set_bbreg(hw, RFPGA0_RFMOD, BIT(25) | BIT(24), 0);\n\t\trtl_set_bbreg(hw, RFPGA0_ANALOGPARAMETER4, 0x00f00000, 0xf);\n\t\t \n\t\tif (channel > 99)\n\t\t\trtl_set_bbreg(hw, ROFDM1_CFOTRACKING, BIT(13) |\n\t\t\t\t      BIT(14), 2);\n\t\telse\n\t\t\trtl_set_bbreg(hw, ROFDM1_CFOTRACKING, BIT(13) |\n\t\t\t\t      BIT(14), 1);\n\t\t \n\t\tgroup = channel <= 64 ? 1 : 2;\n\t\timr_num = MAX_RF_IMR_INDEX_NORMAL;\n\t\tfor (i = 0; i < imr_num; i++)\n\t\t\trtl_set_rfreg(hw, (enum radio_path)rfpath,\n\t\t\t\t      rf_reg_for_5g_swchnl_normal[i], rfmask,\n\t\t\t\t      rf_imr_param_normal[0][group][i]);\n\t\trtl_set_bbreg(hw, RFPGA0_ANALOGPARAMETER4, 0x00f00000, 0);\n\t\trtl_set_bbreg(hw, RFPGA0_RFMOD, BOFDMEN, 1);\n\t} else {\n\t\t \n\t\trtl_dbg(rtlpriv, COMP_SCAN, DBG_LOUD,\n\t\t\t\"Load RF IMR parameters for G band. IMR already setting %d\\n\",\n\t\t\trtlpriv->rtlhal.load_imrandiqk_setting_for2g);\n\t\trtl_dbg(rtlpriv, COMP_CMD, DBG_LOUD, \"====>2.4G\\n\");\n\t\tif (!rtlpriv->rtlhal.load_imrandiqk_setting_for2g) {\n\t\t\trtl_dbg(rtlpriv, COMP_SCAN, DBG_LOUD,\n\t\t\t\t\"Load RF IMR parameters for G band. %d\\n\",\n\t\t\t\trfpath);\n\t\t\trtl92d_acquire_cckandrw_pagea_ctl(hw, &flag);\n\t\t\trtl_set_bbreg(hw, RFPGA0_RFMOD, BIT(25) | BIT(24), 0);\n\t\t\trtl_set_bbreg(hw, RFPGA0_ANALOGPARAMETER4,\n\t\t\t\t      0x00f00000, 0xf);\n\t\t\timr_num = MAX_RF_IMR_INDEX_NORMAL;\n\t\t\tfor (i = 0; i < imr_num; i++) {\n\t\t\t\trtl_set_rfreg(hw, (enum radio_path)rfpath,\n\t\t\t\t\t      rf_reg_for_5g_swchnl_normal[i],\n\t\t\t\t\t      RFREG_OFFSET_MASK,\n\t\t\t\t\t      rf_imr_param_normal[0][0][i]);\n\t\t\t}\n\t\t\trtl_set_bbreg(hw, RFPGA0_ANALOGPARAMETER4,\n\t\t\t\t      0x00f00000, 0);\n\t\t\trtl_set_bbreg(hw, RFPGA0_RFMOD, BOFDMEN | BCCKEN, 3);\n\t\t\trtl92d_release_cckandrw_pagea_ctl(hw, &flag);\n\t\t}\n\t}\n\trtl_dbg(rtlpriv, COMP_CMD, DBG_LOUD, \"<====\\n\");\n}\n\nstatic void _rtl92d_phy_enable_rf_env(struct ieee80211_hw *hw,\n\tu8 rfpath, u32 *pu4_regval)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct bb_reg_def *pphyreg = &rtlphy->phyreg_def[rfpath];\n\n\trtl_dbg(rtlpriv, COMP_RF, DBG_LOUD, \"====>\\n\");\n\t \n\tswitch (rfpath) {\n\tcase RF90_PATH_A:\n\tcase RF90_PATH_C:\n\t\t*pu4_regval = rtl_get_bbreg(hw, pphyreg->rfintfs, BRFSI_RFENV);\n\t\tbreak;\n\tcase RF90_PATH_B:\n\tcase RF90_PATH_D:\n\t\t*pu4_regval =\n\t\t    rtl_get_bbreg(hw, pphyreg->rfintfs, BRFSI_RFENV << 16);\n\t\tbreak;\n\t}\n\t \n\trtl_set_bbreg(hw, pphyreg->rfintfe, BRFSI_RFENV << 16, 0x1);\n\tudelay(1);\n\t \n\trtl_set_bbreg(hw, pphyreg->rfintfo, BRFSI_RFENV, 0x1);\n\tudelay(1);\n\t \n\t \n\trtl_set_bbreg(hw, pphyreg->rfhssi_para2, B3WIREADDRESSLENGTH, 0x0);\n\tudelay(1);\n\t \n\trtl_set_bbreg(hw, pphyreg->rfhssi_para2, B3WIREDATALENGTH, 0x0);\n\tudelay(1);\n\trtl_dbg(rtlpriv, COMP_RF, DBG_LOUD, \"<====\\n\");\n}\n\nstatic void _rtl92d_phy_restore_rf_env(struct ieee80211_hw *hw, u8 rfpath,\n\t\t\t\t       u32 *pu4_regval)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct bb_reg_def *pphyreg = &rtlphy->phyreg_def[rfpath];\n\n\trtl_dbg(rtlpriv, COMP_RF, DBG_LOUD, \"=====>\\n\");\n\t \n\tswitch (rfpath) {\n\tcase RF90_PATH_A:\n\tcase RF90_PATH_C:\n\t\trtl_set_bbreg(hw, pphyreg->rfintfs, BRFSI_RFENV, *pu4_regval);\n\t\tbreak;\n\tcase RF90_PATH_B:\n\tcase RF90_PATH_D:\n\t\trtl_set_bbreg(hw, pphyreg->rfintfs, BRFSI_RFENV << 16,\n\t\t\t      *pu4_regval);\n\t\tbreak;\n\t}\n\trtl_dbg(rtlpriv, COMP_RF, DBG_LOUD, \"<=====\\n\");\n}\n\nstatic void _rtl92d_phy_switch_rf_setting(struct ieee80211_hw *hw, u8 channel)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct rtl_hal *rtlhal = &(rtlpriv->rtlhal);\n\tu8 path = rtlhal->current_bandtype ==\n\t    BAND_ON_5G ? RF90_PATH_A : RF90_PATH_B;\n\tu8 index = 0, i = 0, rfpath = RF90_PATH_A;\n\tbool need_pwr_down = false, internal_pa = false;\n\tu32 u4regvalue, mask = 0x1C000, value = 0, u4tmp, u4tmp2;\n\n\trtl_dbg(rtlpriv, COMP_CMD, DBG_LOUD, \"====>\\n\");\n\t \n\tif (rtlhal->current_bandtype == BAND_ON_5G) {\n\t\trtl_dbg(rtlpriv, COMP_CMD, DBG_LOUD, \"====>5G\\n\");\n\t\tu4tmp = curveindex_5g[channel - 1];\n\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK,\n\t\t\t\"ver 1 set RF-A, 5G, 0x28 = 0x%x !!\\n\", u4tmp);\n\t\tfor (i = 0; i < RF_CHNL_NUM_5G; i++) {\n\t\t\tif (channel == rf_chnl_5g[i] && channel <= 140)\n\t\t\t\tindex = 0;\n\t\t}\n\t\tfor (i = 0; i < RF_CHNL_NUM_5G_40M; i++) {\n\t\t\tif (channel == rf_chnl_5g_40m[i] && channel <= 140)\n\t\t\t\tindex = 1;\n\t\t}\n\t\tif (channel == 149 || channel == 155 || channel == 161)\n\t\t\tindex = 2;\n\t\telse if (channel == 151 || channel == 153 || channel == 163\n\t\t\t || channel == 165)\n\t\t\tindex = 3;\n\t\telse if (channel == 157 || channel == 159)\n\t\t\tindex = 4;\n\n\t\tif (rtlhal->macphymode == DUALMAC_DUALPHY\n\t\t    && rtlhal->interfaceindex == 1) {\n\t\t\tneed_pwr_down = rtl92d_phy_enable_anotherphy(hw, false);\n\t\t\trtlhal->during_mac1init_radioa = true;\n\t\t\t \n\t\t\tif (need_pwr_down)\n\t\t\t\t_rtl92d_phy_enable_rf_env(hw, path,\n\t\t\t\t\t\t\t  &u4regvalue);\n\t\t}\n\t\tfor (i = 0; i < RF_REG_NUM_FOR_C_CUT_5G; i++) {\n\t\t\tif (i == 0 && (rtlhal->macphymode == DUALMAC_DUALPHY)) {\n\t\t\t\trtl_set_rfreg(hw, (enum radio_path)path,\n\t\t\t\t\t      rf_reg_for_c_cut_5g[i],\n\t\t\t\t\t      RFREG_OFFSET_MASK, 0xE439D);\n\t\t\t} else if (rf_reg_for_c_cut_5g[i] == RF_SYN_G4) {\n\t\t\t\tu4tmp2 = (rf_reg_pram_c_5g[index][i] &\n\t\t\t\t     0x7FF) | (u4tmp << 11);\n\t\t\t\tif (channel == 36)\n\t\t\t\t\tu4tmp2 &= ~(BIT(7) | BIT(6));\n\t\t\t\trtl_set_rfreg(hw, (enum radio_path)path,\n\t\t\t\t\t      rf_reg_for_c_cut_5g[i],\n\t\t\t\t\t      RFREG_OFFSET_MASK, u4tmp2);\n\t\t\t} else {\n\t\t\t\trtl_set_rfreg(hw, (enum radio_path)path,\n\t\t\t\t\t      rf_reg_for_c_cut_5g[i],\n\t\t\t\t\t      RFREG_OFFSET_MASK,\n\t\t\t\t\t      rf_reg_pram_c_5g[index][i]);\n\t\t\t}\n\t\t\trtl_dbg(rtlpriv, COMP_RF, DBG_TRACE,\n\t\t\t\t\"offset 0x%x value 0x%x path %d index %d readback 0x%x\\n\",\n\t\t\t\trf_reg_for_c_cut_5g[i],\n\t\t\t\trf_reg_pram_c_5g[index][i],\n\t\t\t\tpath, index,\n\t\t\t\trtl_get_rfreg(hw, (enum radio_path)path,\n\t\t\t\t\t      rf_reg_for_c_cut_5g[i],\n\t\t\t\t\t      RFREG_OFFSET_MASK));\n\t\t}\n\t\tif (need_pwr_down)\n\t\t\t_rtl92d_phy_restore_rf_env(hw, path, &u4regvalue);\n\t\tif (rtlhal->during_mac1init_radioa)\n\t\t\trtl92d_phy_powerdown_anotherphy(hw, false);\n\t\tif (channel < 149)\n\t\t\tvalue = 0x07;\n\t\telse if (channel >= 149)\n\t\t\tvalue = 0x02;\n\t\tif (channel >= 36 && channel <= 64)\n\t\t\tindex = 0;\n\t\telse if (channel >= 100 && channel <= 140)\n\t\t\tindex = 1;\n\t\telse\n\t\t\tindex = 2;\n\t\tfor (rfpath = RF90_PATH_A; rfpath < rtlphy->num_total_rfpath;\n\t\t\trfpath++) {\n\t\t\tif (rtlhal->macphymode == DUALMAC_DUALPHY &&\n\t\t\t\trtlhal->interfaceindex == 1)\t \n\t\t\t\tinternal_pa = rtlpriv->efuse.internal_pa_5g[1];\n\t\t\telse\n\t\t\t\tinternal_pa =\n\t\t\t\t\t rtlpriv->efuse.internal_pa_5g[rfpath];\n\t\t\tif (internal_pa) {\n\t\t\t\tfor (i = 0;\n\t\t\t\t     i < RF_REG_NUM_FOR_C_CUT_5G_INTERNALPA;\n\t\t\t\t     i++) {\n\t\t\t\t\trtl_set_rfreg(hw, rfpath,\n\t\t\t\t\t\trf_for_c_cut_5g_internal_pa[i],\n\t\t\t\t\t\tRFREG_OFFSET_MASK,\n\t\t\t\t\t\trf_pram_c_5g_int_pa[index][i]);\n\t\t\t\t\trtl_dbg(rtlpriv, COMP_RF, DBG_LOUD,\n\t\t\t\t\t\t\"offset 0x%x value 0x%x path %d index %d\\n\",\n\t\t\t\t\t\trf_for_c_cut_5g_internal_pa[i],\n\t\t\t\t\t\trf_pram_c_5g_int_pa[index][i],\n\t\t\t\t\t\trfpath, index);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trtl_set_rfreg(hw, (enum radio_path)rfpath, 0x0B,\n\t\t\t\t\t      mask, value);\n\t\t\t}\n\t\t}\n\t} else if (rtlhal->current_bandtype == BAND_ON_2_4G) {\n\t\trtl_dbg(rtlpriv, COMP_CMD, DBG_LOUD, \"====>2.4G\\n\");\n\t\tu4tmp = curveindex_2g[channel - 1];\n\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK,\n\t\t\t\"ver 3 set RF-B, 2G, 0x28 = 0x%x !!\\n\", u4tmp);\n\t\tif (channel == 1 || channel == 2 || channel == 4 || channel == 9\n\t\t    || channel == 10 || channel == 11 || channel == 12)\n\t\t\tindex = 0;\n\t\telse if (channel == 3 || channel == 13 || channel == 14)\n\t\t\tindex = 1;\n\t\telse if (channel >= 5 && channel <= 8)\n\t\t\tindex = 2;\n\t\tif (rtlhal->macphymode == DUALMAC_DUALPHY) {\n\t\t\tpath = RF90_PATH_A;\n\t\t\tif (rtlhal->interfaceindex == 0) {\n\t\t\t\tneed_pwr_down =\n\t\t\t\t\t rtl92d_phy_enable_anotherphy(hw, true);\n\t\t\t\trtlhal->during_mac0init_radiob = true;\n\n\t\t\t\tif (need_pwr_down)\n\t\t\t\t\t_rtl92d_phy_enable_rf_env(hw, path,\n\t\t\t\t\t\t\t\t  &u4regvalue);\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < RF_REG_NUM_FOR_C_CUT_2G; i++) {\n\t\t\tif (rf_reg_for_c_cut_2g[i] == RF_SYN_G7)\n\t\t\t\trtl_set_rfreg(hw, (enum radio_path)path,\n\t\t\t\t\trf_reg_for_c_cut_2g[i],\n\t\t\t\t\tRFREG_OFFSET_MASK,\n\t\t\t\t\t(rf_reg_param_for_c_cut_2g[index][i] |\n\t\t\t\t\tBIT(17)));\n\t\t\telse\n\t\t\t\trtl_set_rfreg(hw, (enum radio_path)path,\n\t\t\t\t\t      rf_reg_for_c_cut_2g[i],\n\t\t\t\t\t      RFREG_OFFSET_MASK,\n\t\t\t\t\t      rf_reg_param_for_c_cut_2g\n\t\t\t\t\t      [index][i]);\n\t\t\trtl_dbg(rtlpriv, COMP_RF, DBG_TRACE,\n\t\t\t\t\"offset 0x%x value 0x%x mak 0x%x path %d index %d readback 0x%x\\n\",\n\t\t\t\trf_reg_for_c_cut_2g[i],\n\t\t\t\trf_reg_param_for_c_cut_2g[index][i],\n\t\t\t\trf_reg_mask_for_c_cut_2g[i], path, index,\n\t\t\t\trtl_get_rfreg(hw, (enum radio_path)path,\n\t\t\t\t\t      rf_reg_for_c_cut_2g[i],\n\t\t\t\t\t      RFREG_OFFSET_MASK));\n\t\t}\n\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK,\n\t\t\t\"cosa ver 3 set RF-B, 2G, 0x28 = 0x%x !!\\n\",\n\t\t\trf_syn_g4_for_c_cut_2g | (u4tmp << 11));\n\n\t\trtl_set_rfreg(hw, (enum radio_path)path, RF_SYN_G4,\n\t\t\t      RFREG_OFFSET_MASK,\n\t\t\t      rf_syn_g4_for_c_cut_2g | (u4tmp << 11));\n\t\tif (need_pwr_down)\n\t\t\t_rtl92d_phy_restore_rf_env(hw, path, &u4regvalue);\n\t\tif (rtlhal->during_mac0init_radiob)\n\t\t\trtl92d_phy_powerdown_anotherphy(hw, true);\n\t}\n\trtl_dbg(rtlpriv, COMP_CMD, DBG_LOUD, \"<====\\n\");\n}\n\nu8 rtl92d_get_rightchnlplace_for_iqk(u8 chnl)\n{\n\tu8 place;\n\n\tif (chnl > 14) {\n\t\tfor (place = 14; place < ARRAY_SIZE(channel_all); place++) {\n\t\t\tif (channel_all[place] == chnl)\n\t\t\t\treturn place - 13;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n#define MAX_TOLERANCE\t\t5\n#define IQK_DELAY_TIME\t\t1\t \n#define MAX_TOLERANCE_92D\t3\n\n \nstatic u8 _rtl92d_phy_patha_iqk(struct ieee80211_hw *hw, bool configpathb)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tu32 regeac, rege94, rege9c, regea4;\n\tu8 result = 0;\n\n\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"Path A IQK!\\n\");\n\t \n\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"Path-A IQK setting!\\n\");\n\tif (rtlhal->interfaceindex == 0) {\n\t\trtl_set_bbreg(hw, 0xe30, MASKDWORD, 0x10008c1f);\n\t\trtl_set_bbreg(hw, 0xe34, MASKDWORD, 0x10008c1f);\n\t} else {\n\t\trtl_set_bbreg(hw, 0xe30, MASKDWORD, 0x10008c22);\n\t\trtl_set_bbreg(hw, 0xe34, MASKDWORD, 0x10008c22);\n\t}\n\trtl_set_bbreg(hw, 0xe38, MASKDWORD, 0x82140102);\n\trtl_set_bbreg(hw, 0xe3c, MASKDWORD, 0x28160206);\n\t \n\tif (configpathb) {\n\t\trtl_set_bbreg(hw, 0xe50, MASKDWORD, 0x10008c22);\n\t\trtl_set_bbreg(hw, 0xe54, MASKDWORD, 0x10008c22);\n\t\trtl_set_bbreg(hw, 0xe58, MASKDWORD, 0x82140102);\n\t\trtl_set_bbreg(hw, 0xe5c, MASKDWORD, 0x28160206);\n\t}\n\t \n\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"LO calibration setting!\\n\");\n\trtl_set_bbreg(hw, 0xe4c, MASKDWORD, 0x00462911);\n\t \n\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"One shot, path A LOK & IQK!\\n\");\n\trtl_set_bbreg(hw, 0xe48, MASKDWORD, 0xf9000000);\n\trtl_set_bbreg(hw, 0xe48, MASKDWORD, 0xf8000000);\n\t \n\tRTPRINT(rtlpriv, FINIT, INIT_IQK,\n\t\t\"Delay %d ms for One shot, path A LOK & IQK\\n\",\n\t\tIQK_DELAY_TIME);\n\tmdelay(IQK_DELAY_TIME);\n\t \n\tregeac = rtl_get_bbreg(hw, 0xeac, MASKDWORD);\n\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"0xeac = 0x%x\\n\", regeac);\n\trege94 = rtl_get_bbreg(hw, 0xe94, MASKDWORD);\n\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"0xe94 = 0x%x\\n\", rege94);\n\trege9c = rtl_get_bbreg(hw, 0xe9c, MASKDWORD);\n\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"0xe9c = 0x%x\\n\", rege9c);\n\tregea4 = rtl_get_bbreg(hw, 0xea4, MASKDWORD);\n\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"0xea4 = 0x%x\\n\", regea4);\n\tif (!(regeac & BIT(28)) && (((rege94 & 0x03FF0000) >> 16) != 0x142) &&\n\t    (((rege9c & 0x03FF0000) >> 16) != 0x42))\n\t\tresult |= 0x01;\n\telse\t\t\t \n\t\treturn result;\n\t \n\tif (!(regeac & BIT(27)) && (((regea4 & 0x03FF0000) >> 16) != 0x132) &&\n\t    (((regeac & 0x03FF0000) >> 16) != 0x36))\n\t\tresult |= 0x02;\n\telse\n\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"Path A Rx IQK fail!!\\n\");\n\treturn result;\n}\n\n \nstatic u8 _rtl92d_phy_patha_iqk_5g_normal(struct ieee80211_hw *hw,\n\t\t\t\t\t  bool configpathb)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tu32 regeac, rege94, rege9c, regea4;\n\tu8 result = 0;\n\tu8 i;\n\tu8 retrycount = 2;\n\tu32 TXOKBIT = BIT(28), RXOKBIT = BIT(27);\n\n\tif (rtlhal->interfaceindex == 1) {\t \n\t\tTXOKBIT = BIT(31);\n\t\tRXOKBIT = BIT(30);\n\t}\n\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"Path A IQK!\\n\");\n\t \n\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"Path-A IQK setting!\\n\");\n\trtl_set_bbreg(hw, 0xe30, MASKDWORD, 0x18008c1f);\n\trtl_set_bbreg(hw, 0xe34, MASKDWORD, 0x18008c1f);\n\trtl_set_bbreg(hw, 0xe38, MASKDWORD, 0x82140307);\n\trtl_set_bbreg(hw, 0xe3c, MASKDWORD, 0x68160960);\n\t \n\tif (configpathb) {\n\t\trtl_set_bbreg(hw, 0xe50, MASKDWORD, 0x18008c2f);\n\t\trtl_set_bbreg(hw, 0xe54, MASKDWORD, 0x18008c2f);\n\t\trtl_set_bbreg(hw, 0xe58, MASKDWORD, 0x82110000);\n\t\trtl_set_bbreg(hw, 0xe5c, MASKDWORD, 0x68110000);\n\t}\n\t \n\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"LO calibration setting!\\n\");\n\trtl_set_bbreg(hw, 0xe4c, MASKDWORD, 0x00462911);\n\t \n\trtl_set_bbreg(hw, RFPGA0_XAB_RFINTERFACESW, MASKDWORD, 0x07000f60);\n\trtl_set_bbreg(hw, RFPGA0_XA_RFINTERFACEOE, MASKDWORD, 0x66e60e30);\n\tfor (i = 0; i < retrycount; i++) {\n\t\t \n\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK,\n\t\t\t\"One shot, path A LOK & IQK!\\n\");\n\t\trtl_set_bbreg(hw, 0xe48, MASKDWORD, 0xf9000000);\n\t\trtl_set_bbreg(hw, 0xe48, MASKDWORD, 0xf8000000);\n\t\t \n\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK,\n\t\t\t\"Delay %d ms for One shot, path A LOK & IQK.\\n\",\n\t\t\tIQK_DELAY_TIME);\n\t\tmdelay(IQK_DELAY_TIME * 10);\n\t\t \n\t\tregeac = rtl_get_bbreg(hw, 0xeac, MASKDWORD);\n\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"0xeac = 0x%x\\n\", regeac);\n\t\trege94 = rtl_get_bbreg(hw, 0xe94, MASKDWORD);\n\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"0xe94 = 0x%x\\n\", rege94);\n\t\trege9c = rtl_get_bbreg(hw, 0xe9c, MASKDWORD);\n\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"0xe9c = 0x%x\\n\", rege9c);\n\t\tregea4 = rtl_get_bbreg(hw, 0xea4, MASKDWORD);\n\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"0xea4 = 0x%x\\n\", regea4);\n\t\tif (!(regeac & TXOKBIT) &&\n\t\t     (((rege94 & 0x03FF0000) >> 16) != 0x142)) {\n\t\t\tresult |= 0x01;\n\t\t} else {  \n\t\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK,\n\t\t\t\t\"Path A Tx IQK fail!!\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (!(regeac & RXOKBIT) &&\n\t\t    (((regea4 & 0x03FF0000) >> 16) != 0x132)) {\n\t\t\tresult |= 0x02;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK,\n\t\t\t\t\"Path A Rx IQK fail!!\\n\");\n\t\t}\n\t}\n\t \n\trtl_set_bbreg(hw, RFPGA0_XAB_RFINTERFACESW, MASKDWORD,\n\t\t      rtlphy->iqk_bb_backup[0]);\n\trtl_set_bbreg(hw, RFPGA0_XA_RFINTERFACEOE, MASKDWORD,\n\t\t      rtlphy->iqk_bb_backup[1]);\n\treturn result;\n}\n\n \nstatic u8 _rtl92d_phy_pathb_iqk(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 regeac, regeb4, regebc, regec4, regecc;\n\tu8 result = 0;\n\n\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"Path B IQK!\\n\");\n\t \n\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"One shot, path A LOK & IQK!\\n\");\n\trtl_set_bbreg(hw, 0xe60, MASKDWORD, 0x00000002);\n\trtl_set_bbreg(hw, 0xe60, MASKDWORD, 0x00000000);\n\t \n\tRTPRINT(rtlpriv, FINIT, INIT_IQK,\n\t\t\"Delay %d ms for One shot, path B LOK & IQK\\n\", IQK_DELAY_TIME);\n\tmdelay(IQK_DELAY_TIME);\n\t \n\tregeac = rtl_get_bbreg(hw, 0xeac, MASKDWORD);\n\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"0xeac = 0x%x\\n\", regeac);\n\tregeb4 = rtl_get_bbreg(hw, 0xeb4, MASKDWORD);\n\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"0xeb4 = 0x%x\\n\", regeb4);\n\tregebc = rtl_get_bbreg(hw, 0xebc, MASKDWORD);\n\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"0xebc = 0x%x\\n\", regebc);\n\tregec4 = rtl_get_bbreg(hw, 0xec4, MASKDWORD);\n\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"0xec4 = 0x%x\\n\", regec4);\n\tregecc = rtl_get_bbreg(hw, 0xecc, MASKDWORD);\n\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"0xecc = 0x%x\\n\", regecc);\n\tif (!(regeac & BIT(31)) && (((regeb4 & 0x03FF0000) >> 16) != 0x142) &&\n\t    (((regebc & 0x03FF0000) >> 16) != 0x42))\n\t\tresult |= 0x01;\n\telse\n\t\treturn result;\n\tif (!(regeac & BIT(30)) && (((regec4 & 0x03FF0000) >> 16) != 0x132) &&\n\t    (((regecc & 0x03FF0000) >> 16) != 0x36))\n\t\tresult |= 0x02;\n\telse\n\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"Path B Rx IQK fail!!\\n\");\n\treturn result;\n}\n\n \nstatic u8 _rtl92d_phy_pathb_iqk_5g_normal(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tu32 regeac, regeb4, regebc, regec4, regecc;\n\tu8 result = 0;\n\tu8 i;\n\tu8 retrycount = 2;\n\n\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"Path B IQK!\\n\");\n\t \n\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"Path-A IQK setting!\\n\");\n\trtl_set_bbreg(hw, 0xe30, MASKDWORD, 0x18008c1f);\n\trtl_set_bbreg(hw, 0xe34, MASKDWORD, 0x18008c1f);\n\trtl_set_bbreg(hw, 0xe38, MASKDWORD, 0x82110000);\n\trtl_set_bbreg(hw, 0xe3c, MASKDWORD, 0x68110000);\n\n\t \n\trtl_set_bbreg(hw, 0xe50, MASKDWORD, 0x18008c2f);\n\trtl_set_bbreg(hw, 0xe54, MASKDWORD, 0x18008c2f);\n\trtl_set_bbreg(hw, 0xe58, MASKDWORD, 0x82140307);\n\trtl_set_bbreg(hw, 0xe5c, MASKDWORD, 0x68160960);\n\n\t \n\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"LO calibration setting!\\n\");\n\trtl_set_bbreg(hw, 0xe4c, MASKDWORD, 0x00462911);\n\n\t \n\trtl_set_bbreg(hw, RFPGA0_XAB_RFINTERFACESW, MASKDWORD, 0x0f600700);\n\trtl_set_bbreg(hw, RFPGA0_XB_RFINTERFACEOE, MASKDWORD, 0x061f0d30);\n\n\tfor (i = 0; i < retrycount; i++) {\n\t\t \n\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK,\n\t\t\t\"One shot, path A LOK & IQK!\\n\");\n\t\trtl_set_bbreg(hw, 0xe48, MASKDWORD, 0xfa000000);\n\t\trtl_set_bbreg(hw, 0xe48, MASKDWORD, 0xf8000000);\n\n\t\t \n\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK,\n\t\t\t\"Delay %d ms for One shot, path B LOK & IQK.\\n\", 10);\n\t\tmdelay(IQK_DELAY_TIME * 10);\n\n\t\t \n\t\tregeac = rtl_get_bbreg(hw, 0xeac, MASKDWORD);\n\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"0xeac = 0x%x\\n\", regeac);\n\t\tregeb4 = rtl_get_bbreg(hw, 0xeb4, MASKDWORD);\n\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"0xeb4 = 0x%x\\n\", regeb4);\n\t\tregebc = rtl_get_bbreg(hw, 0xebc, MASKDWORD);\n\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"0xebc = 0x%x\\n\", regebc);\n\t\tregec4 = rtl_get_bbreg(hw, 0xec4, MASKDWORD);\n\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"0xec4 = 0x%x\\n\", regec4);\n\t\tregecc = rtl_get_bbreg(hw, 0xecc, MASKDWORD);\n\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"0xecc = 0x%x\\n\", regecc);\n\t\tif (!(regeac & BIT(31)) &&\n\t\t    (((regeb4 & 0x03FF0000) >> 16) != 0x142))\n\t\t\tresult |= 0x01;\n\t\telse\n\t\t\tcontinue;\n\t\tif (!(regeac & BIT(30)) &&\n\t\t    (((regec4 & 0x03FF0000) >> 16) != 0x132)) {\n\t\t\tresult |= 0x02;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK,\n\t\t\t\t\"Path B Rx IQK fail!!\\n\");\n\t\t}\n\t}\n\n\t \n\trtl_set_bbreg(hw, RFPGA0_XAB_RFINTERFACESW, MASKDWORD,\n\t\t      rtlphy->iqk_bb_backup[0]);\n\trtl_set_bbreg(hw, RFPGA0_XB_RFINTERFACEOE, MASKDWORD,\n\t\t      rtlphy->iqk_bb_backup[2]);\n\treturn result;\n}\n\nstatic void _rtl92d_phy_save_adda_registers(struct ieee80211_hw *hw,\n\t\t\t\t\t    u32 *adda_reg, u32 *adda_backup,\n\t\t\t\t\t    u32 regnum)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 i;\n\n\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"Save ADDA parameters.\\n\");\n\tfor (i = 0; i < regnum; i++)\n\t\tadda_backup[i] = rtl_get_bbreg(hw, adda_reg[i], MASKDWORD);\n}\n\nstatic void _rtl92d_phy_save_mac_registers(struct ieee80211_hw *hw,\n\tu32 *macreg, u32 *macbackup)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 i;\n\n\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"Save MAC parameters.\\n\");\n\tfor (i = 0; i < (IQK_MAC_REG_NUM - 1); i++)\n\t\tmacbackup[i] = rtl_read_byte(rtlpriv, macreg[i]);\n\tmacbackup[i] = rtl_read_dword(rtlpriv, macreg[i]);\n}\n\nstatic void _rtl92d_phy_reload_adda_registers(struct ieee80211_hw *hw,\n\t\t\t\t\t      u32 *adda_reg, u32 *adda_backup,\n\t\t\t\t\t      u32 regnum)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 i;\n\n\tRTPRINT(rtlpriv, FINIT, INIT_IQK,\n\t\t\"Reload ADDA power saving parameters !\\n\");\n\tfor (i = 0; i < regnum; i++)\n\t\trtl_set_bbreg(hw, adda_reg[i], MASKDWORD, adda_backup[i]);\n}\n\nstatic void _rtl92d_phy_reload_mac_registers(struct ieee80211_hw *hw,\n\t\t\t\t\t     u32 *macreg, u32 *macbackup)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 i;\n\n\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"Reload MAC parameters !\\n\");\n\tfor (i = 0; i < (IQK_MAC_REG_NUM - 1); i++)\n\t\trtl_write_byte(rtlpriv, macreg[i], (u8) macbackup[i]);\n\trtl_write_byte(rtlpriv, macreg[i], macbackup[i]);\n}\n\nstatic void _rtl92d_phy_path_adda_on(struct ieee80211_hw *hw,\n\t\tu32 *adda_reg, bool patha_on, bool is2t)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 pathon;\n\tu32 i;\n\n\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"ADDA ON.\\n\");\n\tpathon = patha_on ? 0x04db25a4 : 0x0b1b25a4;\n\tif (patha_on)\n\t\tpathon = rtlpriv->rtlhal.interfaceindex == 0 ?\n\t\t    0x04db25a4 : 0x0b1b25a4;\n\tfor (i = 0; i < IQK_ADDA_REG_NUM; i++)\n\t\trtl_set_bbreg(hw, adda_reg[i], MASKDWORD, pathon);\n}\n\nstatic void _rtl92d_phy_mac_setting_calibration(struct ieee80211_hw *hw,\n\t\t\t\t\t\tu32 *macreg, u32 *macbackup)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 i;\n\n\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"MAC settings for Calibration.\\n\");\n\trtl_write_byte(rtlpriv, macreg[0], 0x3F);\n\n\tfor (i = 1; i < (IQK_MAC_REG_NUM - 1); i++)\n\t\trtl_write_byte(rtlpriv, macreg[i], (u8)(macbackup[i] &\n\t\t\t       (~BIT(3))));\n\trtl_write_byte(rtlpriv, macreg[i], (u8) (macbackup[i] & (~BIT(5))));\n}\n\nstatic void _rtl92d_phy_patha_standby(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"Path-A standby mode!\\n\");\n\n\trtl_set_bbreg(hw, 0xe28, MASKDWORD, 0x0);\n\trtl_set_bbreg(hw, RFPGA0_XA_LSSIPARAMETER, MASKDWORD, 0x00010000);\n\trtl_set_bbreg(hw, 0xe28, MASKDWORD, 0x80800000);\n}\n\nstatic void _rtl92d_phy_pimode_switch(struct ieee80211_hw *hw, bool pi_mode)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 mode;\n\n\tRTPRINT(rtlpriv, FINIT, INIT_IQK,\n\t\t\"BB Switch to %s mode!\\n\", pi_mode ? \"PI\" : \"SI\");\n\tmode = pi_mode ? 0x01000100 : 0x01000000;\n\trtl_set_bbreg(hw, 0x820, MASKDWORD, mode);\n\trtl_set_bbreg(hw, 0x828, MASKDWORD, mode);\n}\n\nstatic void _rtl92d_phy_iq_calibrate(struct ieee80211_hw *hw, long result[][8],\n\t\t\t\t     u8 t, bool is2t)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tu32 i;\n\tu8 patha_ok, pathb_ok;\n\tstatic u32 adda_reg[IQK_ADDA_REG_NUM] = {\n\t\tRFPGA0_XCD_SWITCHCONTROL, 0xe6c, 0xe70, 0xe74,\n\t\t0xe78, 0xe7c, 0xe80, 0xe84,\n\t\t0xe88, 0xe8c, 0xed0, 0xed4,\n\t\t0xed8, 0xedc, 0xee0, 0xeec\n\t};\n\tstatic u32 iqk_mac_reg[IQK_MAC_REG_NUM] = {\n\t\t0x522, 0x550, 0x551, 0x040\n\t};\n\tstatic u32 iqk_bb_reg[IQK_BB_REG_NUM] = {\n\t\tRFPGA0_XAB_RFINTERFACESW, RFPGA0_XA_RFINTERFACEOE,\n\t\tRFPGA0_XB_RFINTERFACEOE, ROFDM0_TRMUXPAR,\n\t\tRFPGA0_XCD_RFINTERFACESW, ROFDM0_TRXPATHENABLE,\n\t\tRFPGA0_RFMOD, RFPGA0_ANALOGPARAMETER4,\n\t\tROFDM0_XAAGCCORE1, ROFDM0_XBAGCCORE1\n\t};\n\tconst u32 retrycount = 2;\n\tu32 bbvalue;\n\n\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"IQK for 2.4G :Start!!!\\n\");\n\tif (t == 0) {\n\t\tbbvalue = rtl_get_bbreg(hw, RFPGA0_RFMOD, MASKDWORD);\n\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"==>0x%08x\\n\", bbvalue);\n\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK, \"IQ Calibration for %s\\n\",\n\t\t\tis2t ? \"2T2R\" : \"1T1R\");\n\n\t\t \n\t\t_rtl92d_phy_save_adda_registers(hw, adda_reg,\n\t\t\trtlphy->adda_backup, IQK_ADDA_REG_NUM);\n\t\t_rtl92d_phy_save_mac_registers(hw, iqk_mac_reg,\n\t\t\trtlphy->iqk_mac_backup);\n\t\t_rtl92d_phy_save_adda_registers(hw, iqk_bb_reg,\n\t\t\trtlphy->iqk_bb_backup, IQK_BB_REG_NUM);\n\t}\n\t_rtl92d_phy_path_adda_on(hw, adda_reg, true, is2t);\n\tif (t == 0)\n\t\trtlphy->rfpi_enable = (u8) rtl_get_bbreg(hw,\n\t\t\t\tRFPGA0_XA_HSSIPARAMETER1, BIT(8));\n\n\t \n\tif (!rtlphy->rfpi_enable)\n\t\t_rtl92d_phy_pimode_switch(hw, true);\n\n\trtl_set_bbreg(hw, RFPGA0_RFMOD, BIT(24), 0x00);\n\trtl_set_bbreg(hw, ROFDM0_TRXPATHENABLE, MASKDWORD, 0x03a05600);\n\trtl_set_bbreg(hw, ROFDM0_TRMUXPAR, MASKDWORD, 0x000800e4);\n\trtl_set_bbreg(hw, RFPGA0_XCD_RFINTERFACESW, MASKDWORD, 0x22204000);\n\trtl_set_bbreg(hw, RFPGA0_ANALOGPARAMETER4, 0xf00000, 0x0f);\n\tif (is2t) {\n\t\trtl_set_bbreg(hw, RFPGA0_XA_LSSIPARAMETER, MASKDWORD,\n\t\t\t      0x00010000);\n\t\trtl_set_bbreg(hw, RFPGA0_XB_LSSIPARAMETER, MASKDWORD,\n\t\t\t      0x00010000);\n\t}\n\t \n\t_rtl92d_phy_mac_setting_calibration(hw, iqk_mac_reg,\n\t\t\t\t\t    rtlphy->iqk_mac_backup);\n\t \n\trtl_set_bbreg(hw, 0xb68, MASKDWORD, 0x0f600000);\n\tif (is2t)\n\t\trtl_set_bbreg(hw, 0xb6c, MASKDWORD, 0x0f600000);\n\t \n\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"IQK setting!\\n\");\n\trtl_set_bbreg(hw, 0xe28, MASKDWORD, 0x80800000);\n\trtl_set_bbreg(hw, 0xe40, MASKDWORD, 0x01007c00);\n\trtl_set_bbreg(hw, 0xe44, MASKDWORD, 0x01004800);\n\tfor (i = 0; i < retrycount; i++) {\n\t\tpatha_ok = _rtl92d_phy_patha_iqk(hw, is2t);\n\t\tif (patha_ok == 0x03) {\n\t\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK,\n\t\t\t\t\"Path A IQK Success!!\\n\");\n\t\t\tresult[t][0] = (rtl_get_bbreg(hw, 0xe94, MASKDWORD) &\n\t\t\t\t\t0x3FF0000) >> 16;\n\t\t\tresult[t][1] = (rtl_get_bbreg(hw, 0xe9c, MASKDWORD) &\n\t\t\t\t\t0x3FF0000) >> 16;\n\t\t\tresult[t][2] = (rtl_get_bbreg(hw, 0xea4, MASKDWORD) &\n\t\t\t\t\t0x3FF0000) >> 16;\n\t\t\tresult[t][3] = (rtl_get_bbreg(hw, 0xeac, MASKDWORD) &\n\t\t\t\t\t0x3FF0000) >> 16;\n\t\t\tbreak;\n\t\t} else if (i == (retrycount - 1) && patha_ok == 0x01) {\n\t\t\t \n\t\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK,\n\t\t\t\t\"Path A IQK Only  Tx Success!!\\n\");\n\n\t\t\tresult[t][0] = (rtl_get_bbreg(hw, 0xe94, MASKDWORD) &\n\t\t\t\t\t0x3FF0000) >> 16;\n\t\t\tresult[t][1] = (rtl_get_bbreg(hw, 0xe9c, MASKDWORD) &\n\t\t\t\t\t0x3FF0000) >> 16;\n\t\t}\n\t}\n\tif (0x00 == patha_ok)\n\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"Path A IQK failed!!\\n\");\n\tif (is2t) {\n\t\t_rtl92d_phy_patha_standby(hw);\n\t\t \n\t\t_rtl92d_phy_path_adda_on(hw, adda_reg, false, is2t);\n\t\tfor (i = 0; i < retrycount; i++) {\n\t\t\tpathb_ok = _rtl92d_phy_pathb_iqk(hw);\n\t\t\tif (pathb_ok == 0x03) {\n\t\t\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK,\n\t\t\t\t\t\"Path B IQK Success!!\\n\");\n\t\t\t\tresult[t][4] = (rtl_get_bbreg(hw, 0xeb4,\n\t\t\t\t\t       MASKDWORD) & 0x3FF0000) >> 16;\n\t\t\t\tresult[t][5] = (rtl_get_bbreg(hw, 0xebc,\n\t\t\t\t\t       MASKDWORD) & 0x3FF0000) >> 16;\n\t\t\t\tresult[t][6] = (rtl_get_bbreg(hw, 0xec4,\n\t\t\t\t\t       MASKDWORD) & 0x3FF0000) >> 16;\n\t\t\t\tresult[t][7] = (rtl_get_bbreg(hw, 0xecc,\n\t\t\t\t\t       MASKDWORD) & 0x3FF0000) >> 16;\n\t\t\t\tbreak;\n\t\t\t} else if (i == (retrycount - 1) && pathb_ok == 0x01) {\n\t\t\t\t \n\t\t\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK,\n\t\t\t\t\t\"Path B Only Tx IQK Success!!\\n\");\n\t\t\t\tresult[t][4] = (rtl_get_bbreg(hw, 0xeb4,\n\t\t\t\t\t       MASKDWORD) & 0x3FF0000) >> 16;\n\t\t\t\tresult[t][5] = (rtl_get_bbreg(hw, 0xebc,\n\t\t\t\t\t       MASKDWORD) & 0x3FF0000) >> 16;\n\t\t\t}\n\t\t}\n\t\tif (0x00 == pathb_ok)\n\t\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK,\n\t\t\t\t\"Path B IQK failed!!\\n\");\n\t}\n\n\t \n\tRTPRINT(rtlpriv, FINIT, INIT_IQK,\n\t\t\"IQK:Back to BB mode, load original value!\\n\");\n\n\trtl_set_bbreg(hw, 0xe28, MASKDWORD, 0);\n\tif (t != 0) {\n\t\t \n\t\tif (!rtlphy->rfpi_enable)\n\t\t\t_rtl92d_phy_pimode_switch(hw, false);\n\t\t \n\t\t_rtl92d_phy_reload_adda_registers(hw, adda_reg,\n\t\t\t\trtlphy->adda_backup, IQK_ADDA_REG_NUM);\n\t\t \n\t\t_rtl92d_phy_reload_mac_registers(hw, iqk_mac_reg,\n\t\t\t\t\trtlphy->iqk_mac_backup);\n\t\tif (is2t)\n\t\t\t_rtl92d_phy_reload_adda_registers(hw, iqk_bb_reg,\n\t\t\t\t\t\t\t  rtlphy->iqk_bb_backup,\n\t\t\t\t\t\t\t  IQK_BB_REG_NUM);\n\t\telse\n\t\t\t_rtl92d_phy_reload_adda_registers(hw, iqk_bb_reg,\n\t\t\t\t\t\t\t  rtlphy->iqk_bb_backup,\n\t\t\t\t\t\t\t  IQK_BB_REG_NUM - 1);\n\t\t \n\t\trtl_set_bbreg(hw, 0xe30, MASKDWORD, 0x01008c00);\n\t\trtl_set_bbreg(hw, 0xe34, MASKDWORD, 0x01008c00);\n\t}\n\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"<==\\n\");\n}\n\nstatic void _rtl92d_phy_iq_calibrate_5g_normal(struct ieee80211_hw *hw,\n\t\t\t\t\t       long result[][8], u8 t)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct rtl_hal *rtlhal = &(rtlpriv->rtlhal);\n\tu8 patha_ok, pathb_ok;\n\tstatic u32 adda_reg[IQK_ADDA_REG_NUM] = {\n\t\tRFPGA0_XCD_SWITCHCONTROL, 0xe6c, 0xe70, 0xe74,\n\t\t0xe78, 0xe7c, 0xe80, 0xe84,\n\t\t0xe88, 0xe8c, 0xed0, 0xed4,\n\t\t0xed8, 0xedc, 0xee0, 0xeec\n\t};\n\tstatic u32 iqk_mac_reg[IQK_MAC_REG_NUM] = {\n\t\t0x522, 0x550, 0x551, 0x040\n\t};\n\tstatic u32 iqk_bb_reg[IQK_BB_REG_NUM] = {\n\t\tRFPGA0_XAB_RFINTERFACESW, RFPGA0_XA_RFINTERFACEOE,\n\t\tRFPGA0_XB_RFINTERFACEOE, ROFDM0_TRMUXPAR,\n\t\tRFPGA0_XCD_RFINTERFACESW, ROFDM0_TRXPATHENABLE,\n\t\tRFPGA0_RFMOD, RFPGA0_ANALOGPARAMETER4,\n\t\tROFDM0_XAAGCCORE1, ROFDM0_XBAGCCORE1\n\t};\n\tu32 bbvalue;\n\tbool is2t = IS_92D_SINGLEPHY(rtlhal->version);\n\n\t \n\n\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"IQK for 5G NORMAL:Start!!!\\n\");\n\tmdelay(IQK_DELAY_TIME * 20);\n\tif (t == 0) {\n\t\tbbvalue = rtl_get_bbreg(hw, RFPGA0_RFMOD, MASKDWORD);\n\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"==>0x%08x\\n\", bbvalue);\n\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK, \"IQ Calibration for %s\\n\",\n\t\t\tis2t ? \"2T2R\" : \"1T1R\");\n\t\t \n\t\t_rtl92d_phy_save_adda_registers(hw, adda_reg,\n\t\t\t\t\t\trtlphy->adda_backup,\n\t\t\t\t\t\tIQK_ADDA_REG_NUM);\n\t\t_rtl92d_phy_save_mac_registers(hw, iqk_mac_reg,\n\t\t\t\t\t       rtlphy->iqk_mac_backup);\n\t\tif (is2t)\n\t\t\t_rtl92d_phy_save_adda_registers(hw, iqk_bb_reg,\n\t\t\t\t\t\t\trtlphy->iqk_bb_backup,\n\t\t\t\t\t\t\tIQK_BB_REG_NUM);\n\t\telse\n\t\t\t_rtl92d_phy_save_adda_registers(hw, iqk_bb_reg,\n\t\t\t\t\t\t\trtlphy->iqk_bb_backup,\n\t\t\t\t\t\t\tIQK_BB_REG_NUM - 1);\n\t}\n\t_rtl92d_phy_path_adda_on(hw, adda_reg, true, is2t);\n\t \n\t_rtl92d_phy_mac_setting_calibration(hw, iqk_mac_reg,\n\t\t\trtlphy->iqk_mac_backup);\n\tif (t == 0)\n\t\trtlphy->rfpi_enable = (u8) rtl_get_bbreg(hw,\n\t\t\tRFPGA0_XA_HSSIPARAMETER1, BIT(8));\n\t \n\tif (!rtlphy->rfpi_enable)\n\t\t_rtl92d_phy_pimode_switch(hw, true);\n\trtl_set_bbreg(hw, RFPGA0_RFMOD, BIT(24), 0x00);\n\trtl_set_bbreg(hw, ROFDM0_TRXPATHENABLE, MASKDWORD, 0x03a05600);\n\trtl_set_bbreg(hw, ROFDM0_TRMUXPAR, MASKDWORD, 0x000800e4);\n\trtl_set_bbreg(hw, RFPGA0_XCD_RFINTERFACESW, MASKDWORD, 0x22208000);\n\trtl_set_bbreg(hw, RFPGA0_ANALOGPARAMETER4, 0xf00000, 0x0f);\n\n\t \n\trtl_set_bbreg(hw, 0xb68, MASKDWORD, 0x0f600000);\n\tif (is2t)\n\t\trtl_set_bbreg(hw, 0xb6c, MASKDWORD, 0x0f600000);\n\t \n\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"IQK setting!\\n\");\n\trtl_set_bbreg(hw, 0xe28, MASKDWORD, 0x80800000);\n\trtl_set_bbreg(hw, 0xe40, MASKDWORD, 0x10007c00);\n\trtl_set_bbreg(hw, 0xe44, MASKDWORD, 0x01004800);\n\tpatha_ok = _rtl92d_phy_patha_iqk_5g_normal(hw, is2t);\n\tif (patha_ok == 0x03) {\n\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"Path A IQK Success!!\\n\");\n\t\tresult[t][0] = (rtl_get_bbreg(hw, 0xe94, MASKDWORD) &\n\t\t\t\t0x3FF0000) >> 16;\n\t\tresult[t][1] = (rtl_get_bbreg(hw, 0xe9c, MASKDWORD) &\n\t\t\t\t0x3FF0000) >> 16;\n\t\tresult[t][2] = (rtl_get_bbreg(hw, 0xea4, MASKDWORD) &\n\t\t\t\t0x3FF0000) >> 16;\n\t\tresult[t][3] = (rtl_get_bbreg(hw, 0xeac, MASKDWORD) &\n\t\t\t\t0x3FF0000) >> 16;\n\t} else if (patha_ok == 0x01) {\t \n\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK,\n\t\t\t\"Path A IQK Only  Tx Success!!\\n\");\n\n\t\tresult[t][0] = (rtl_get_bbreg(hw, 0xe94, MASKDWORD) &\n\t\t\t\t0x3FF0000) >> 16;\n\t\tresult[t][1] = (rtl_get_bbreg(hw, 0xe9c, MASKDWORD) &\n\t\t\t\t0x3FF0000) >> 16;\n\t} else {\n\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"Path A IQK Fail!!\\n\");\n\t}\n\tif (is2t) {\n\t\t \n\t\t \n\t\t_rtl92d_phy_path_adda_on(hw, adda_reg, false, is2t);\n\t\tpathb_ok = _rtl92d_phy_pathb_iqk_5g_normal(hw);\n\t\tif (pathb_ok == 0x03) {\n\t\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK,\n\t\t\t\t\"Path B IQK Success!!\\n\");\n\t\t\tresult[t][4] = (rtl_get_bbreg(hw, 0xeb4, MASKDWORD) &\n\t\t\t     0x3FF0000) >> 16;\n\t\t\tresult[t][5] = (rtl_get_bbreg(hw, 0xebc, MASKDWORD) &\n\t\t\t     0x3FF0000) >> 16;\n\t\t\tresult[t][6] = (rtl_get_bbreg(hw, 0xec4, MASKDWORD) &\n\t\t\t     0x3FF0000) >> 16;\n\t\t\tresult[t][7] = (rtl_get_bbreg(hw, 0xecc, MASKDWORD) &\n\t\t\t     0x3FF0000) >> 16;\n\t\t} else if (pathb_ok == 0x01) {  \n\t\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK,\n\t\t\t\t\"Path B Only Tx IQK Success!!\\n\");\n\t\t\tresult[t][4] = (rtl_get_bbreg(hw, 0xeb4, MASKDWORD) &\n\t\t\t     0x3FF0000) >> 16;\n\t\t\tresult[t][5] = (rtl_get_bbreg(hw, 0xebc, MASKDWORD) &\n\t\t\t     0x3FF0000) >> 16;\n\t\t} else {\n\t\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK,\n\t\t\t\t\"Path B IQK failed!!\\n\");\n\t\t}\n\t}\n\n\t \n\tRTPRINT(rtlpriv, FINIT, INIT_IQK,\n\t\t\"IQK:Back to BB mode, load original value!\\n\");\n\trtl_set_bbreg(hw, 0xe28, MASKDWORD, 0);\n\tif (t != 0) {\n\t\tif (is2t)\n\t\t\t_rtl92d_phy_reload_adda_registers(hw, iqk_bb_reg,\n\t\t\t\t\t\t\t  rtlphy->iqk_bb_backup,\n\t\t\t\t\t\t\t  IQK_BB_REG_NUM);\n\t\telse\n\t\t\t_rtl92d_phy_reload_adda_registers(hw, iqk_bb_reg,\n\t\t\t\t\t\t\t  rtlphy->iqk_bb_backup,\n\t\t\t\t\t\t\t  IQK_BB_REG_NUM - 1);\n\t\t \n\t\t_rtl92d_phy_reload_mac_registers(hw, iqk_mac_reg,\n\t\t\t\trtlphy->iqk_mac_backup);\n\t\t \n\t\tif (!rtlphy->rfpi_enable)\n\t\t\t_rtl92d_phy_pimode_switch(hw, false);\n\t\t \n\t\t_rtl92d_phy_reload_adda_registers(hw, adda_reg,\n\t\t\t\t\t\t  rtlphy->adda_backup,\n\t\t\t\t\t\t  IQK_ADDA_REG_NUM);\n\t}\n\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"<==\\n\");\n}\n\nstatic bool _rtl92d_phy_simularity_compare(struct ieee80211_hw *hw,\n\tlong result[][8], u8 c1, u8 c2)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = &(rtlpriv->rtlhal);\n\tu32 i, j, diff, sim_bitmap, bound;\n\tu8 final_candidate[2] = {0xFF, 0xFF};\t \n\tbool bresult = true;\n\tbool is2t = IS_92D_SINGLEPHY(rtlhal->version);\n\n\tif (is2t)\n\t\tbound = 8;\n\telse\n\t\tbound = 4;\n\tsim_bitmap = 0;\n\tfor (i = 0; i < bound; i++) {\n\t\tdiff = (result[c1][i] > result[c2][i]) ? (result[c1][i] -\n\t\t       result[c2][i]) : (result[c2][i] - result[c1][i]);\n\t\tif (diff > MAX_TOLERANCE_92D) {\n\t\t\tif ((i == 2 || i == 6) && !sim_bitmap) {\n\t\t\t\tif (result[c1][i] + result[c1][i + 1] == 0)\n\t\t\t\t\tfinal_candidate[(i / 4)] = c2;\n\t\t\t\telse if (result[c2][i] + result[c2][i + 1] == 0)\n\t\t\t\t\tfinal_candidate[(i / 4)] = c1;\n\t\t\t\telse\n\t\t\t\t\tsim_bitmap = sim_bitmap | (1 << i);\n\t\t\t} else {\n\t\t\t\tsim_bitmap = sim_bitmap | (1 << i);\n\t\t\t}\n\t\t}\n\t}\n\tif (sim_bitmap == 0) {\n\t\tfor (i = 0; i < (bound / 4); i++) {\n\t\t\tif (final_candidate[i] != 0xFF) {\n\t\t\t\tfor (j = i * 4; j < (i + 1) * 4 - 2; j++)\n\t\t\t\t\tresult[3][j] =\n\t\t\t\t\t\t result[final_candidate[i]][j];\n\t\t\t\tbresult = false;\n\t\t\t}\n\t\t}\n\t\treturn bresult;\n\t}\n\tif (!(sim_bitmap & 0x0F)) {  \n\t\tfor (i = 0; i < 4; i++)\n\t\t\tresult[3][i] = result[c1][i];\n\t} else if (!(sim_bitmap & 0x03)) {  \n\t\tfor (i = 0; i < 2; i++)\n\t\t\tresult[3][i] = result[c1][i];\n\t}\n\tif (!(sim_bitmap & 0xF0) && is2t) {  \n\t\tfor (i = 4; i < 8; i++)\n\t\t\tresult[3][i] = result[c1][i];\n\t} else if (!(sim_bitmap & 0x30)) {  \n\t\tfor (i = 4; i < 6; i++)\n\t\t\tresult[3][i] = result[c1][i];\n\t}\n\treturn false;\n}\n\nstatic void _rtl92d_phy_patha_fill_iqk_matrix(struct ieee80211_hw *hw,\n\t\t\t\t\t      bool iqk_ok, long result[][8],\n\t\t\t\t\t      u8 final_candidate, bool txonly)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = &(rtlpriv->rtlhal);\n\tu32 oldval_0, val_x, tx0_a, reg;\n\tlong val_y, tx0_c;\n\tbool is2t = IS_92D_SINGLEPHY(rtlhal->version) ||\n\t    rtlhal->macphymode == DUALMAC_DUALPHY;\n\n\tRTPRINT(rtlpriv, FINIT, INIT_IQK,\n\t\t\"Path A IQ Calibration %s !\\n\", iqk_ok ? \"Success\" : \"Failed\");\n\tif (final_candidate == 0xFF) {\n\t\treturn;\n\t} else if (iqk_ok) {\n\t\toldval_0 = (rtl_get_bbreg(hw, ROFDM0_XATXIQIMBALANCE,\n\t\t\tMASKDWORD) >> 22) & 0x3FF;\t \n\t\tval_x = result[final_candidate][0];\n\t\tif ((val_x & 0x00000200) != 0)\n\t\t\tval_x = val_x | 0xFFFFFC00;\n\t\ttx0_a = (val_x * oldval_0) >> 8;\n\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK,\n\t\t\t\"X = 0x%x, tx0_a = 0x%x, oldval_0 0x%x\\n\",\n\t\t\tval_x, tx0_a, oldval_0);\n\t\trtl_set_bbreg(hw, ROFDM0_XATXIQIMBALANCE, 0x3FF, tx0_a);\n\t\trtl_set_bbreg(hw, ROFDM0_ECCATHRESHOLD, BIT(24),\n\t\t\t      ((val_x * oldval_0 >> 7) & 0x1));\n\t\tval_y = result[final_candidate][1];\n\t\tif ((val_y & 0x00000200) != 0)\n\t\t\tval_y = val_y | 0xFFFFFC00;\n\t\t \n\t\tif (rtlhal->interfaceindex == 1 &&\n\t\t\trtlhal->current_bandtype == BAND_ON_5G)\n\t\t\tval_y += 3;\n\t\ttx0_c = (val_y * oldval_0) >> 8;\n\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK,\n\t\t\t\"Y = 0x%lx, tx0_c = 0x%lx\\n\",\n\t\t\tval_y, tx0_c);\n\t\trtl_set_bbreg(hw, ROFDM0_XCTXAFE, 0xF0000000,\n\t\t\t      ((tx0_c & 0x3C0) >> 6));\n\t\trtl_set_bbreg(hw, ROFDM0_XATXIQIMBALANCE, 0x003F0000,\n\t\t\t      (tx0_c & 0x3F));\n\t\tif (is2t)\n\t\t\trtl_set_bbreg(hw, ROFDM0_ECCATHRESHOLD, BIT(26),\n\t\t\t\t      ((val_y * oldval_0 >> 7) & 0x1));\n\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK, \"0xC80 = 0x%x\\n\",\n\t\t\trtl_get_bbreg(hw, ROFDM0_XATXIQIMBALANCE,\n\t\t\t\t      MASKDWORD));\n\t\tif (txonly) {\n\t\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"only Tx OK\\n\");\n\t\t\treturn;\n\t\t}\n\t\treg = result[final_candidate][2];\n\t\trtl_set_bbreg(hw, ROFDM0_XARXIQIMBALANCE, 0x3FF, reg);\n\t\treg = result[final_candidate][3] & 0x3F;\n\t\trtl_set_bbreg(hw, ROFDM0_XARXIQIMBALANCE, 0xFC00, reg);\n\t\treg = (result[final_candidate][3] >> 6) & 0xF;\n\t\trtl_set_bbreg(hw, 0xca0, 0xF0000000, reg);\n\t}\n}\n\nstatic void _rtl92d_phy_pathb_fill_iqk_matrix(struct ieee80211_hw *hw,\n\tbool iqk_ok, long result[][8], u8 final_candidate, bool txonly)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = &(rtlpriv->rtlhal);\n\tu32 oldval_1, val_x, tx1_a, reg;\n\tlong val_y, tx1_c;\n\n\tRTPRINT(rtlpriv, FINIT, INIT_IQK, \"Path B IQ Calibration %s !\\n\",\n\t\tiqk_ok ? \"Success\" : \"Failed\");\n\tif (final_candidate == 0xFF) {\n\t\treturn;\n\t} else if (iqk_ok) {\n\t\toldval_1 = (rtl_get_bbreg(hw, ROFDM0_XBTXIQIMBALANCE,\n\t\t\t\t\t  MASKDWORD) >> 22) & 0x3FF;\n\t\tval_x = result[final_candidate][4];\n\t\tif ((val_x & 0x00000200) != 0)\n\t\t\tval_x = val_x | 0xFFFFFC00;\n\t\ttx1_a = (val_x * oldval_1) >> 8;\n\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK, \"X = 0x%x, tx1_a = 0x%x\\n\",\n\t\t\tval_x, tx1_a);\n\t\trtl_set_bbreg(hw, ROFDM0_XBTXIQIMBALANCE, 0x3FF, tx1_a);\n\t\trtl_set_bbreg(hw, ROFDM0_ECCATHRESHOLD, BIT(28),\n\t\t\t      ((val_x * oldval_1 >> 7) & 0x1));\n\t\tval_y = result[final_candidate][5];\n\t\tif ((val_y & 0x00000200) != 0)\n\t\t\tval_y = val_y | 0xFFFFFC00;\n\t\tif (rtlhal->current_bandtype == BAND_ON_5G)\n\t\t\tval_y += 3;\n\t\ttx1_c = (val_y * oldval_1) >> 8;\n\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK, \"Y = 0x%lx, tx1_c = 0x%lx\\n\",\n\t\t\tval_y, tx1_c);\n\t\trtl_set_bbreg(hw, ROFDM0_XDTXAFE, 0xF0000000,\n\t\t\t      ((tx1_c & 0x3C0) >> 6));\n\t\trtl_set_bbreg(hw, ROFDM0_XBTXIQIMBALANCE, 0x003F0000,\n\t\t\t      (tx1_c & 0x3F));\n\t\trtl_set_bbreg(hw, ROFDM0_ECCATHRESHOLD, BIT(30),\n\t\t\t      ((val_y * oldval_1 >> 7) & 0x1));\n\t\tif (txonly)\n\t\t\treturn;\n\t\treg = result[final_candidate][6];\n\t\trtl_set_bbreg(hw, ROFDM0_XBRXIQIMBALANCE, 0x3FF, reg);\n\t\treg = result[final_candidate][7] & 0x3F;\n\t\trtl_set_bbreg(hw, ROFDM0_XBRXIQIMBALANCE, 0xFC00, reg);\n\t\treg = (result[final_candidate][7] >> 6) & 0xF;\n\t\trtl_set_bbreg(hw, ROFDM0_AGCRSSITABLE, 0x0000F000, reg);\n\t}\n}\n\nvoid rtl92d_phy_iq_calibrate(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct rtl_hal *rtlhal = &(rtlpriv->rtlhal);\n\tlong result[4][8];\n\tu8 i, final_candidate, indexforchannel;\n\tbool patha_ok, pathb_ok;\n\tlong rege94, rege9c, regea4, regeac, regeb4;\n\tlong regebc, regec4, regecc, regtmp = 0;\n\tbool is12simular, is13simular, is23simular;\n\tunsigned long flag = 0;\n\n\tRTPRINT(rtlpriv, FINIT, INIT_IQK,\n\t\t\"IQK:Start!!!channel %d\\n\", rtlphy->current_channel);\n\tfor (i = 0; i < 8; i++) {\n\t\tresult[0][i] = 0;\n\t\tresult[1][i] = 0;\n\t\tresult[2][i] = 0;\n\t\tresult[3][i] = 0;\n\t}\n\tfinal_candidate = 0xff;\n\tpatha_ok = false;\n\tpathb_ok = false;\n\tis12simular = false;\n\tis23simular = false;\n\tis13simular = false;\n\tRTPRINT(rtlpriv, FINIT, INIT_IQK,\n\t\t\"IQK !!!currentband %d\\n\", rtlhal->current_bandtype);\n\trtl92d_acquire_cckandrw_pagea_ctl(hw, &flag);\n\tfor (i = 0; i < 3; i++) {\n\t\tif (rtlhal->current_bandtype == BAND_ON_5G) {\n\t\t\t_rtl92d_phy_iq_calibrate_5g_normal(hw, result, i);\n\t\t} else if (rtlhal->current_bandtype == BAND_ON_2_4G) {\n\t\t\tif (IS_92D_SINGLEPHY(rtlhal->version))\n\t\t\t\t_rtl92d_phy_iq_calibrate(hw, result, i, true);\n\t\t\telse\n\t\t\t\t_rtl92d_phy_iq_calibrate(hw, result, i, false);\n\t\t}\n\t\tif (i == 1) {\n\t\t\tis12simular = _rtl92d_phy_simularity_compare(hw, result,\n\t\t\t\t\t\t\t\t     0, 1);\n\t\t\tif (is12simular) {\n\t\t\t\tfinal_candidate = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == 2) {\n\t\t\tis13simular = _rtl92d_phy_simularity_compare(hw, result,\n\t\t\t\t\t\t\t\t     0, 2);\n\t\t\tif (is13simular) {\n\t\t\t\tfinal_candidate = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tis23simular = _rtl92d_phy_simularity_compare(hw, result,\n\t\t\t\t\t\t\t\t     1, 2);\n\t\t\tif (is23simular) {\n\t\t\t\tfinal_candidate = 1;\n\t\t\t} else {\n\t\t\t\tfor (i = 0; i < 8; i++)\n\t\t\t\t\tregtmp += result[3][i];\n\n\t\t\t\tif (regtmp != 0)\n\t\t\t\t\tfinal_candidate = 3;\n\t\t\t\telse\n\t\t\t\t\tfinal_candidate = 0xFF;\n\t\t\t}\n\t\t}\n\t}\n\trtl92d_release_cckandrw_pagea_ctl(hw, &flag);\n\tfor (i = 0; i < 4; i++) {\n\t\trege94 = result[i][0];\n\t\trege9c = result[i][1];\n\t\tregea4 = result[i][2];\n\t\tregeac = result[i][3];\n\t\tregeb4 = result[i][4];\n\t\tregebc = result[i][5];\n\t\tregec4 = result[i][6];\n\t\tregecc = result[i][7];\n\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK,\n\t\t\t\"IQK: rege94=%lx rege9c=%lx regea4=%lx regeac=%lx regeb4=%lx regebc=%lx regec4=%lx regecc=%lx\\n\",\n\t\t\trege94, rege9c, regea4, regeac, regeb4, regebc, regec4,\n\t\t\tregecc);\n\t}\n\tif (final_candidate != 0xff) {\n\t\trtlphy->reg_e94 = rege94 = result[final_candidate][0];\n\t\trtlphy->reg_e9c = rege9c = result[final_candidate][1];\n\t\tregea4 = result[final_candidate][2];\n\t\tregeac = result[final_candidate][3];\n\t\trtlphy->reg_eb4 = regeb4 = result[final_candidate][4];\n\t\trtlphy->reg_ebc = regebc = result[final_candidate][5];\n\t\tregec4 = result[final_candidate][6];\n\t\tregecc = result[final_candidate][7];\n\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK,\n\t\t\t\"IQK: final_candidate is %x\\n\", final_candidate);\n\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK,\n\t\t\t\"IQK: rege94=%lx rege9c=%lx regea4=%lx regeac=%lx regeb4=%lx regebc=%lx regec4=%lx regecc=%lx\\n\",\n\t\t\trege94, rege9c, regea4, regeac, regeb4, regebc, regec4,\n\t\t\tregecc);\n\t\tpatha_ok = pathb_ok = true;\n\t} else {\n\t\trtlphy->reg_e94 = rtlphy->reg_eb4 = 0x100;  \n\t\trtlphy->reg_e9c = rtlphy->reg_ebc = 0x0;    \n\t}\n\tif ((rege94 != 0)  )\n\t\t_rtl92d_phy_patha_fill_iqk_matrix(hw, patha_ok, result,\n\t\t\t\tfinal_candidate, (regea4 == 0));\n\tif (IS_92D_SINGLEPHY(rtlhal->version)) {\n\t\tif ((regeb4 != 0)  )\n\t\t\t_rtl92d_phy_pathb_fill_iqk_matrix(hw, pathb_ok, result,\n\t\t\t\t\t\tfinal_candidate, (regec4 == 0));\n\t}\n\tif (final_candidate != 0xFF) {\n\t\tindexforchannel = rtl92d_get_rightchnlplace_for_iqk(\n\t\t\t\t  rtlphy->current_channel);\n\n\t\tfor (i = 0; i < IQK_MATRIX_REG_NUM; i++)\n\t\t\trtlphy->iqk_matrix[indexforchannel].\n\t\t\t\tvalue[0][i] = result[final_candidate][i];\n\t\trtlphy->iqk_matrix[indexforchannel].iqk_done =\n\t\t\ttrue;\n\n\t\trtl_dbg(rtlpriv, COMP_SCAN | COMP_MLME, DBG_LOUD,\n\t\t\t\"IQK OK indexforchannel %d\\n\", indexforchannel);\n\t}\n}\n\nvoid rtl92d_phy_reload_iqk_setting(struct ieee80211_hw *hw, u8 channel)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct rtl_hal *rtlhal = &(rtlpriv->rtlhal);\n\tu8 indexforchannel;\n\n\trtl_dbg(rtlpriv, COMP_CMD, DBG_LOUD, \"channel %d\\n\", channel);\n\t \n\tindexforchannel = rtl92d_get_rightchnlplace_for_iqk(channel);\n\trtl_dbg(rtlpriv, COMP_CMD, DBG_LOUD, \"indexforchannel %d done %d\\n\",\n\t\tindexforchannel,\n\t\t rtlphy->iqk_matrix[indexforchannel].iqk_done);\n\tif (0 && !rtlphy->iqk_matrix[indexforchannel].iqk_done &&\n\t\trtlphy->need_iqk) {\n\t\t \n\t\trtl_dbg(rtlpriv, COMP_SCAN | COMP_INIT, DBG_LOUD,\n\t\t\t\"Do IQK Matrix reg for channel:%d....\\n\", channel);\n\t\trtl92d_phy_iq_calibrate(hw);\n\t} else {\n\t\t \n\t\t \n\t\tif (((!rtlhal->load_imrandiqk_setting_for2g) &&\n\t\t    indexforchannel == 0) || indexforchannel > 0) {\n\t\t\trtl_dbg(rtlpriv, COMP_SCAN, DBG_LOUD,\n\t\t\t\t\"Just Read IQK Matrix reg for channel:%d....\\n\",\n\t\t\t\tchannel);\n\t\t\tif (rtlphy->iqk_matrix[indexforchannel].value[0][0] != 0)\n\t\t\t\t_rtl92d_phy_patha_fill_iqk_matrix(hw, true,\n\t\t\t\t\trtlphy->iqk_matrix[indexforchannel].value, 0,\n\t\t\t\t\trtlphy->iqk_matrix[indexforchannel].value[0][2] == 0);\n\t\t\tif (IS_92D_SINGLEPHY(rtlhal->version)) {\n\t\t\t\tif ((rtlphy->iqk_matrix[\n\t\t\t\t\tindexforchannel].value[0][4] != 0)\n\t\t\t\t\t )\n\t\t\t\t\t_rtl92d_phy_pathb_fill_iqk_matrix(hw,\n\t\t\t\t\t\ttrue,\n\t\t\t\t\t\trtlphy->iqk_matrix[\n\t\t\t\t\t\tindexforchannel].value, 0,\n\t\t\t\t\t\t(rtlphy->iqk_matrix[\n\t\t\t\t\t\tindexforchannel].value[0][6]\n\t\t\t\t\t\t== 0));\n\t\t\t}\n\t\t}\n\t}\n\trtlphy->need_iqk = false;\n\trtl_dbg(rtlpriv, COMP_CMD, DBG_LOUD, \"<====\\n\");\n}\n\nstatic u32 _rtl92d_phy_get_abs(u32 val1, u32 val2)\n{\n\tu32 ret;\n\n\tif (val1 >= val2)\n\t\tret = val1 - val2;\n\telse\n\t\tret = val2 - val1;\n\treturn ret;\n}\n\nstatic bool _rtl92d_is_legal_5g_channel(struct ieee80211_hw *hw, u8 channel)\n{\n\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(channel5g); i++)\n\t\tif (channel == channel5g[i])\n\t\t\treturn true;\n\treturn false;\n}\n\nstatic void _rtl92d_phy_calc_curvindex(struct ieee80211_hw *hw,\n\t\t\t\t       u32 *targetchnl, u32 * curvecount_val,\n\t\t\t\t       bool is5g, u32 *curveindex)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 smallest_abs_val = 0xffffffff, u4tmp;\n\tu8 i, j;\n\tu8 chnl_num = is5g ? TARGET_CHNL_NUM_5G : TARGET_CHNL_NUM_2G;\n\n\tfor (i = 0; i < chnl_num; i++) {\n\t\tif (is5g && !_rtl92d_is_legal_5g_channel(hw, i + 1))\n\t\t\tcontinue;\n\t\tcurveindex[i] = 0;\n\t\tfor (j = 0; j < (CV_CURVE_CNT * 2); j++) {\n\t\t\tu4tmp = _rtl92d_phy_get_abs(targetchnl[i],\n\t\t\t\tcurvecount_val[j]);\n\n\t\t\tif (u4tmp < smallest_abs_val) {\n\t\t\t\tcurveindex[i] = j;\n\t\t\t\tsmallest_abs_val = u4tmp;\n\t\t\t}\n\t\t}\n\t\tsmallest_abs_val = 0xffffffff;\n\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK, \"curveindex[%d] = %x\\n\",\n\t\t\ti, curveindex[i]);\n\t}\n}\n\nstatic void _rtl92d_phy_reload_lck_setting(struct ieee80211_hw *hw,\n\t\tu8 channel)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 erfpath = rtlpriv->rtlhal.current_bandtype ==\n\t\tBAND_ON_5G ? RF90_PATH_A :\n\t\tIS_92D_SINGLEPHY(rtlpriv->rtlhal.version) ?\n\t\tRF90_PATH_B : RF90_PATH_A;\n\tu32 u4tmp = 0, u4regvalue = 0;\n\tbool bneed_powerdown_radio = false;\n\n\trtl_dbg(rtlpriv, COMP_CMD, DBG_LOUD, \"path %d\\n\", erfpath);\n\tRTPRINT(rtlpriv, FINIT, INIT_IQK, \"band type = %d\\n\",\n\t\trtlpriv->rtlhal.current_bandtype);\n\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"channel = %d\\n\", channel);\n\tif (rtlpriv->rtlhal.current_bandtype == BAND_ON_5G) { \n\t\tu4tmp = curveindex_5g[channel-1];\n\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK,\n\t\t\t\"ver 1 set RF-A, 5G,\t0x28 = 0x%x !!\\n\", u4tmp);\n\t\tif (rtlpriv->rtlhal.macphymode == DUALMAC_DUALPHY &&\n\t\t\trtlpriv->rtlhal.interfaceindex == 1) {\n\t\t\tbneed_powerdown_radio =\n\t\t\t\trtl92d_phy_enable_anotherphy(hw, false);\n\t\t\trtlpriv->rtlhal.during_mac1init_radioa = true;\n\t\t\t \n\t\t\tif (bneed_powerdown_radio)\n\t\t\t\t_rtl92d_phy_enable_rf_env(hw, erfpath,\n\t\t\t\t\t\t\t  &u4regvalue);\n\t\t}\n\t\trtl_set_rfreg(hw, erfpath, RF_SYN_G4, 0x3f800, u4tmp);\n\t\tif (bneed_powerdown_radio)\n\t\t\t_rtl92d_phy_restore_rf_env(hw, erfpath, &u4regvalue);\n\t\tif (rtlpriv->rtlhal.during_mac1init_radioa)\n\t\t\trtl92d_phy_powerdown_anotherphy(hw, false);\n\t} else if (rtlpriv->rtlhal.current_bandtype == BAND_ON_2_4G) {\n\t\tu4tmp = curveindex_2g[channel-1];\n\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK,\n\t\t\t\"ver 3 set RF-B, 2G, 0x28 = 0x%x !!\\n\", u4tmp);\n\t\tif (rtlpriv->rtlhal.macphymode == DUALMAC_DUALPHY &&\n\t\t\trtlpriv->rtlhal.interfaceindex == 0) {\n\t\t\tbneed_powerdown_radio =\n\t\t\t\trtl92d_phy_enable_anotherphy(hw, true);\n\t\t\trtlpriv->rtlhal.during_mac0init_radiob = true;\n\t\t\tif (bneed_powerdown_radio)\n\t\t\t\t_rtl92d_phy_enable_rf_env(hw, erfpath,\n\t\t\t\t\t\t\t  &u4regvalue);\n\t\t}\n\t\trtl_set_rfreg(hw, erfpath, RF_SYN_G4, 0x3f800, u4tmp);\n\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK,\n\t\t\t\"ver 3 set RF-B, 2G, 0x28 = 0x%x !!\\n\",\n\t\t\trtl_get_rfreg(hw,  erfpath, RF_SYN_G4, 0x3f800));\n\t\tif (bneed_powerdown_radio)\n\t\t\t_rtl92d_phy_restore_rf_env(hw, erfpath, &u4regvalue);\n\t\tif (rtlpriv->rtlhal.during_mac0init_radiob)\n\t\t\trtl92d_phy_powerdown_anotherphy(hw, true);\n\t}\n\trtl_dbg(rtlpriv, COMP_CMD, DBG_LOUD, \"<====\\n\");\n}\n\nstatic void _rtl92d_phy_lc_calibrate_sw(struct ieee80211_hw *hw, bool is2t)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = &(rtlpriv->rtlhal);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tu8 tmpreg, index, rf_mode[2];\n\tu8 path = is2t ? 2 : 1;\n\tu8 i;\n\tu32 u4tmp, offset;\n\tu32 curvecount_val[CV_CURVE_CNT * 2] = {0};\n\tu16 timeout = 800, timecount = 0;\n\n\t \n\ttmpreg = rtl_read_byte(rtlpriv, 0xd03);\n\t \n\t \n\tif ((tmpreg & 0x70) != 0)\n\t\trtl_write_byte(rtlpriv, 0xd03, tmpreg & 0x8F);\n\telse\n\t\trtl_write_byte(rtlpriv, REG_TXPAUSE, 0xFF);\n\trtl_set_bbreg(hw, RFPGA0_ANALOGPARAMETER4, 0xF00000, 0x0F);\n\tfor (index = 0; index < path; index++) {\n\t\t \n\t\toffset = index == 0 ? ROFDM0_XAAGCCORE1 : ROFDM0_XBAGCCORE1;\n\t\trf_mode[index] = rtl_read_byte(rtlpriv, offset);\n\t\t \n\t\trtl_set_rfreg(hw, (enum radio_path)index, RF_AC,\n\t\t\t      RFREG_OFFSET_MASK, 0x010000);\n\t\tif (rtlpci->init_ready) {\n\t\t\t \n\t\t\trtl_set_rfreg(hw, (enum radio_path)index, RF_SYN_G7,\n\t\t\t\t      BIT(17), 0x0);\n\t\t\t \n\t\t\trtl_set_rfreg(hw, (enum radio_path)index, RF_CHNLBW,\n\t\t\t\t      0x08000, 0x01);\n\t\t}\n\t\tu4tmp = rtl_get_rfreg(hw, (enum radio_path)index, RF_SYN_G6,\n\t\t\t\t  RFREG_OFFSET_MASK);\n\t\twhile ((!(u4tmp & BIT(11))) && timecount <= timeout) {\n\t\t\tmdelay(50);\n\t\t\ttimecount += 50;\n\t\t\tu4tmp = rtl_get_rfreg(hw, (enum radio_path)index,\n\t\t\t\t\t      RF_SYN_G6, RFREG_OFFSET_MASK);\n\t\t}\n\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK,\n\t\t\t\"PHY_LCK finish delay for %d ms=2\\n\", timecount);\n\t\trtl_get_rfreg(hw, index, RF_SYN_G4, RFREG_OFFSET_MASK);\n\t\tif (index == 0 && rtlhal->interfaceindex == 0) {\n\t\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK,\n\t\t\t\t\"path-A / 5G LCK\\n\");\n\t\t} else {\n\t\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK,\n\t\t\t\t\"path-B / 2.4G LCK\\n\");\n\t\t}\n\t\tmemset(curvecount_val, 0, sizeof(curvecount_val));\n\t\t \n\t\trtl_set_rfreg(hw, (enum radio_path)index, RF_CHNLBW,\n\t\t\t      0x08000, 0x0);\n\t\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"set RF 0x18[15] = 0\\n\");\n\t\t \n\t\tfor (i = 0; i < CV_CURVE_CNT; i++) {\n\t\t\tu32 readval = 0, readval2 = 0;\n\t\t\trtl_set_rfreg(hw, (enum radio_path)index, 0x3F,\n\t\t\t\t      0x7f, i);\n\n\t\t\trtl_set_rfreg(hw, (enum radio_path)index, 0x4D,\n\t\t\t\tRFREG_OFFSET_MASK, 0x0);\n\t\t\treadval = rtl_get_rfreg(hw, (enum radio_path)index,\n\t\t\t\t\t  0x4F, RFREG_OFFSET_MASK);\n\t\t\tcurvecount_val[2 * i + 1] = (readval & 0xfffe0) >> 5;\n\t\t\t \n\t\t\t \n\t\t\treadval2 = rtl_get_rfreg(hw, (enum radio_path)index,\n\t\t\t\t\t\t 0x50, 0xffc00);\n\t\t\tcurvecount_val[2 * i] = (((readval & 0x1F) << 10) |\n\t\t\t\t\t\t readval2);\n\t\t}\n\t\tif (index == 0 && rtlhal->interfaceindex == 0)\n\t\t\t_rtl92d_phy_calc_curvindex(hw, targetchnl_5g,\n\t\t\t\t\t\t   curvecount_val,\n\t\t\t\t\t\t   true, curveindex_5g);\n\t\telse\n\t\t\t_rtl92d_phy_calc_curvindex(hw, targetchnl_2g,\n\t\t\t\t\t\t   curvecount_val,\n\t\t\t\t\t\t   false, curveindex_2g);\n\t\t \n\t\trtl_set_rfreg(hw, (enum radio_path)index, RF_SYN_G7,\n\t\t\t      BIT(17), 0x1);\n\t}\n\n\t \n\tfor (index = 0; index < path; index++) {\n\t\toffset = index == 0 ? ROFDM0_XAAGCCORE1 : ROFDM0_XBAGCCORE1;\n\t\trtl_write_byte(rtlpriv, offset, 0x50);\n\t\trtl_write_byte(rtlpriv, offset, rf_mode[index]);\n\t}\n\tif ((tmpreg & 0x70) != 0)\n\t\trtl_write_byte(rtlpriv, 0xd03, tmpreg);\n\telse  \n\t\trtl_write_byte(rtlpriv, REG_TXPAUSE, 0x00);\n\trtl_set_bbreg(hw, RFPGA0_ANALOGPARAMETER4, 0xF00000, 0x00);\n\t_rtl92d_phy_reload_lck_setting(hw, rtlpriv->phy.current_channel);\n}\n\nstatic void _rtl92d_phy_lc_calibrate(struct ieee80211_hw *hw, bool is2t)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"cosa PHY_LCK ver=2\\n\");\n\t_rtl92d_phy_lc_calibrate_sw(hw, is2t);\n}\n\nvoid rtl92d_phy_lc_calibrate(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct rtl_hal *rtlhal = &(rtlpriv->rtlhal);\n\tu32 timeout = 2000, timecount = 0;\n\n\twhile (rtlpriv->mac80211.act_scanning && timecount < timeout) {\n\t\tudelay(50);\n\t\ttimecount += 50;\n\t}\n\n\trtlphy->lck_inprogress = true;\n\tRTPRINT(rtlpriv, FINIT, INIT_IQK,\n\t\t\"LCK:Start!!! currentband %x delay %d ms\\n\",\n\t\trtlhal->current_bandtype, timecount);\n\tif (IS_92D_SINGLEPHY(rtlhal->version)) {\n\t\t_rtl92d_phy_lc_calibrate(hw, true);\n\t} else {\n\t\t \n\t\t_rtl92d_phy_lc_calibrate(hw, false);\n\t}\n\trtlphy->lck_inprogress = false;\n\tRTPRINT(rtlpriv, FINIT, INIT_IQK,  \"LCK:Finish!!!\\n\");\n}\n\nvoid rtl92d_phy_ap_calibrate(struct ieee80211_hw *hw, s8 delta)\n{\n\treturn;\n}\n\nstatic bool _rtl92d_phy_set_sw_chnl_cmdarray(struct swchnlcmd *cmdtable,\n\t\tu32 cmdtableidx, u32 cmdtablesz, enum swchnlcmd_id cmdid,\n\t\tu32 para1, u32 para2, u32 msdelay)\n{\n\tstruct swchnlcmd *pcmd;\n\n\tif (cmdtable == NULL) {\n\t\tWARN_ONCE(true, \"rtl8192de: cmdtable cannot be NULL\\n\");\n\t\treturn false;\n\t}\n\tif (cmdtableidx >= cmdtablesz)\n\t\treturn false;\n\n\tpcmd = cmdtable + cmdtableidx;\n\tpcmd->cmdid = cmdid;\n\tpcmd->para1 = para1;\n\tpcmd->para2 = para2;\n\tpcmd->msdelay = msdelay;\n\treturn true;\n}\n\nvoid rtl92d_phy_reset_iqk_result(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tu8 i;\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\"settings regs %zu default regs %d\\n\",\n\t\tARRAY_SIZE(rtlphy->iqk_matrix),\n\t\tIQK_MATRIX_REG_NUM);\n\t \n\tfor (i = 0; i < IQK_MATRIX_SETTINGS_NUM; i++) {\n\t\trtlphy->iqk_matrix[i].value[0][0] = 0x100;\n\t\trtlphy->iqk_matrix[i].value[0][2] = 0x100;\n\t\trtlphy->iqk_matrix[i].value[0][4] = 0x100;\n\t\trtlphy->iqk_matrix[i].value[0][6] = 0x100;\n\t\trtlphy->iqk_matrix[i].value[0][1] = 0x0;\n\t\trtlphy->iqk_matrix[i].value[0][3] = 0x0;\n\t\trtlphy->iqk_matrix[i].value[0][5] = 0x0;\n\t\trtlphy->iqk_matrix[i].value[0][7] = 0x0;\n\t\trtlphy->iqk_matrix[i].iqk_done = false;\n\t}\n}\n\nstatic bool _rtl92d_phy_sw_chnl_step_by_step(struct ieee80211_hw *hw,\n\t\t\t\t\t     u8 channel, u8 *stage, u8 *step,\n\t\t\t\t\t     u32 *delay)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct swchnlcmd precommoncmd[MAX_PRECMD_CNT];\n\tu32 precommoncmdcnt;\n\tstruct swchnlcmd postcommoncmd[MAX_POSTCMD_CNT];\n\tu32 postcommoncmdcnt;\n\tstruct swchnlcmd rfdependcmd[MAX_RFDEPENDCMD_CNT];\n\tu32 rfdependcmdcnt;\n\tstruct swchnlcmd *currentcmd = NULL;\n\tu8 rfpath;\n\tu8 num_total_rfpath = rtlphy->num_total_rfpath;\n\n\tprecommoncmdcnt = 0;\n\t_rtl92d_phy_set_sw_chnl_cmdarray(precommoncmd, precommoncmdcnt++,\n\t\t\t\t\t MAX_PRECMD_CNT,\n\t\t\t\t\t CMDID_SET_TXPOWEROWER_LEVEL, 0, 0, 0);\n\t_rtl92d_phy_set_sw_chnl_cmdarray(precommoncmd, precommoncmdcnt++,\n\t\t\t\t\t MAX_PRECMD_CNT, CMDID_END, 0, 0, 0);\n\tpostcommoncmdcnt = 0;\n\t_rtl92d_phy_set_sw_chnl_cmdarray(postcommoncmd, postcommoncmdcnt++,\n\t\t\t\t\t MAX_POSTCMD_CNT, CMDID_END, 0, 0, 0);\n\trfdependcmdcnt = 0;\n\t_rtl92d_phy_set_sw_chnl_cmdarray(rfdependcmd, rfdependcmdcnt++,\n\t\t\t\t\t MAX_RFDEPENDCMD_CNT, CMDID_RF_WRITEREG,\n\t\t\t\t\t RF_CHNLBW, channel, 0);\n\t_rtl92d_phy_set_sw_chnl_cmdarray(rfdependcmd, rfdependcmdcnt++,\n\t\t\t\t\t MAX_RFDEPENDCMD_CNT, CMDID_END,\n\t\t\t\t\t 0, 0, 0);\n\n\tdo {\n\t\tswitch (*stage) {\n\t\tcase 0:\n\t\t\tcurrentcmd = &precommoncmd[*step];\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tcurrentcmd = &rfdependcmd[*step];\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tcurrentcmd = &postcommoncmd[*step];\n\t\t\tbreak;\n\t\t}\n\t\tif (currentcmd->cmdid == CMDID_END) {\n\t\t\tif ((*stage) == 2) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\t(*stage)++;\n\t\t\t\t(*step) = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tswitch (currentcmd->cmdid) {\n\t\tcase CMDID_SET_TXPOWEROWER_LEVEL:\n\t\t\trtl92d_phy_set_txpower_level(hw, channel);\n\t\t\tbreak;\n\t\tcase CMDID_WRITEPORT_ULONG:\n\t\t\trtl_write_dword(rtlpriv, currentcmd->para1,\n\t\t\t\t\tcurrentcmd->para2);\n\t\t\tbreak;\n\t\tcase CMDID_WRITEPORT_USHORT:\n\t\t\trtl_write_word(rtlpriv, currentcmd->para1,\n\t\t\t\t       (u16)currentcmd->para2);\n\t\t\tbreak;\n\t\tcase CMDID_WRITEPORT_UCHAR:\n\t\t\trtl_write_byte(rtlpriv, currentcmd->para1,\n\t\t\t\t       (u8)currentcmd->para2);\n\t\t\tbreak;\n\t\tcase CMDID_RF_WRITEREG:\n\t\t\tfor (rfpath = 0; rfpath < num_total_rfpath; rfpath++) {\n\t\t\t\trtlphy->rfreg_chnlval[rfpath] =\n\t\t\t\t\t((rtlphy->rfreg_chnlval[rfpath] &\n\t\t\t\t\t0xffffff00) | currentcmd->para2);\n\t\t\t\tif (rtlpriv->rtlhal.current_bandtype ==\n\t\t\t\t    BAND_ON_5G) {\n\t\t\t\t\tif (currentcmd->para2 > 99)\n\t\t\t\t\t\trtlphy->rfreg_chnlval[rfpath] =\n\t\t\t\t\t\t    rtlphy->rfreg_chnlval\n\t\t\t\t\t\t    [rfpath] | (BIT(18));\n\t\t\t\t\telse\n\t\t\t\t\t\trtlphy->rfreg_chnlval[rfpath] =\n\t\t\t\t\t\t    rtlphy->rfreg_chnlval\n\t\t\t\t\t\t    [rfpath] & (~BIT(18));\n\t\t\t\t\trtlphy->rfreg_chnlval[rfpath] |=\n\t\t\t\t\t\t (BIT(16) | BIT(8));\n\t\t\t\t} else {\n\t\t\t\t\trtlphy->rfreg_chnlval[rfpath] &=\n\t\t\t\t\t\t~(BIT(8) | BIT(16) | BIT(18));\n\t\t\t\t}\n\t\t\t\trtl_set_rfreg(hw, (enum radio_path)rfpath,\n\t\t\t\t\t      currentcmd->para1,\n\t\t\t\t\t      RFREG_OFFSET_MASK,\n\t\t\t\t\t      rtlphy->rfreg_chnlval[rfpath]);\n\t\t\t\t_rtl92d_phy_reload_imr_setting(hw, channel,\n\t\t\t\t\t\t\t       rfpath);\n\t\t\t}\n\t\t\t_rtl92d_phy_switch_rf_setting(hw, channel);\n\t\t\t \n\t\t\trtl92d_phy_reload_iqk_setting(hw, channel);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"switch case %#x not processed\\n\",\n\t\t\t       currentcmd->cmdid);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t} while (true);\n\t(*delay) = currentcmd->msdelay;\n\t(*step)++;\n\treturn false;\n}\n\nu8 rtl92d_phy_sw_chnl(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tu32 delay;\n\tu32 timeout = 1000, timecount = 0;\n\tu8 channel = rtlphy->current_channel;\n\tu32 ret_value;\n\n\tif (rtlphy->sw_chnl_inprogress)\n\t\treturn 0;\n\tif (rtlphy->set_bwmode_inprogress)\n\t\treturn 0;\n\n\tif ((is_hal_stop(rtlhal)) || (RT_CANNOT_IO(hw))) {\n\t\trtl_dbg(rtlpriv, COMP_CHAN, DBG_LOUD,\n\t\t\t\"sw_chnl_inprogress false driver sleep or unload\\n\");\n\t\treturn 0;\n\t}\n\twhile (rtlphy->lck_inprogress && timecount < timeout) {\n\t\tmdelay(50);\n\t\ttimecount += 50;\n\t}\n\tif (rtlhal->macphymode == SINGLEMAC_SINGLEPHY &&\n\t    rtlhal->bandset == BAND_ON_BOTH) {\n\t\tret_value = rtl_get_bbreg(hw, RFPGA0_XAB_RFPARAMETER,\n\t\t\t\t\t  MASKDWORD);\n\t\tif (rtlphy->current_channel > 14 && !(ret_value & BIT(0)))\n\t\t\trtl92d_phy_switch_wirelessband(hw, BAND_ON_5G);\n\t\telse if (rtlphy->current_channel <= 14 && (ret_value & BIT(0)))\n\t\t\trtl92d_phy_switch_wirelessband(hw, BAND_ON_2_4G);\n\t}\n\tswitch (rtlhal->current_bandtype) {\n\tcase BAND_ON_5G:\n\t\t \n\t\tif (WARN_ONCE(channel <= 14, \"rtl8192de: 5G but channel<=14\\n\"))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase BAND_ON_2_4G:\n\t\t \n\t\tif (WARN_ONCE(channel > 14, \"rtl8192de: 2G but channel>14\\n\"))\n\t\t\treturn 0;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ONCE(true, \"rtl8192de: Invalid WirelessMode(%#x)!!\\n\",\n\t\t\t  rtlpriv->mac80211.mode);\n\t\tbreak;\n\t}\n\trtlphy->sw_chnl_inprogress = true;\n\tif (channel == 0)\n\t\tchannel = 1;\n\trtlphy->sw_chnl_stage = 0;\n\trtlphy->sw_chnl_step = 0;\n\trtl_dbg(rtlpriv, COMP_SCAN, DBG_TRACE,\n\t\t\"switch to channel%d\\n\", rtlphy->current_channel);\n\n\tdo {\n\t\tif (!rtlphy->sw_chnl_inprogress)\n\t\t\tbreak;\n\t\tif (!_rtl92d_phy_sw_chnl_step_by_step(hw,\n\t\t\t\t\t\t      rtlphy->current_channel,\n\t\t    &rtlphy->sw_chnl_stage, &rtlphy->sw_chnl_step, &delay)) {\n\t\t\tif (delay > 0)\n\t\t\t\tmdelay(delay);\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\trtlphy->sw_chnl_inprogress = false;\n\t\t}\n\t\tbreak;\n\t} while (true);\n\trtl_dbg(rtlpriv, COMP_SCAN, DBG_TRACE, \"<==\\n\");\n\trtlphy->sw_chnl_inprogress = false;\n\treturn 1;\n}\n\nstatic void rtl92d_phy_set_io(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct dig_t *de_digtable = &rtlpriv->dm_digtable;\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\n\trtl_dbg(rtlpriv, COMP_CMD, DBG_TRACE,\n\t\t\"--->Cmd(%#x), set_io_inprogress(%d)\\n\",\n\t\trtlphy->current_io_type, rtlphy->set_io_inprogress);\n\tswitch (rtlphy->current_io_type) {\n\tcase IO_CMD_RESUME_DM_BY_SCAN:\n\t\tde_digtable->cur_igvalue = rtlphy->initgain_backup.xaagccore1;\n\t\trtl92d_dm_write_dig(hw);\n\t\trtl92d_phy_set_txpower_level(hw, rtlphy->current_channel);\n\t\tbreak;\n\tcase IO_CMD_PAUSE_DM_BY_SCAN:\n\t\trtlphy->initgain_backup.xaagccore1 = de_digtable->cur_igvalue;\n\t\tde_digtable->cur_igvalue = 0x37;\n\t\trtl92d_dm_write_dig(hw);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"switch case %#x not processed\\n\",\n\t\t       rtlphy->current_io_type);\n\t\tbreak;\n\t}\n\trtlphy->set_io_inprogress = false;\n\trtl_dbg(rtlpriv, COMP_CMD, DBG_TRACE, \"<---(%#x)\\n\",\n\t\trtlphy->current_io_type);\n}\n\nbool rtl92d_phy_set_io_cmd(struct ieee80211_hw *hw, enum io_type iotype)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tbool postprocessing = false;\n\n\trtl_dbg(rtlpriv, COMP_CMD, DBG_TRACE,\n\t\t\"-->IO Cmd(%#x), set_io_inprogress(%d)\\n\",\n\t\t iotype, rtlphy->set_io_inprogress);\n\tdo {\n\t\tswitch (iotype) {\n\t\tcase IO_CMD_RESUME_DM_BY_SCAN:\n\t\t\trtl_dbg(rtlpriv, COMP_CMD, DBG_TRACE,\n\t\t\t\t\"[IO CMD] Resume DM after scan\\n\");\n\t\t\tpostprocessing = true;\n\t\t\tbreak;\n\t\tcase IO_CMD_PAUSE_DM_BY_SCAN:\n\t\t\trtl_dbg(rtlpriv, COMP_CMD, DBG_TRACE,\n\t\t\t\t\"[IO CMD] Pause DM before scan\\n\");\n\t\t\tpostprocessing = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"switch case %#x not processed\\n\",\n\t\t\t       iotype);\n\t\t\tbreak;\n\t\t}\n\t} while (false);\n\tif (postprocessing && !rtlphy->set_io_inprogress) {\n\t\trtlphy->set_io_inprogress = true;\n\t\trtlphy->current_io_type = iotype;\n\t} else {\n\t\treturn false;\n\t}\n\trtl92d_phy_set_io(hw);\n\trtl_dbg(rtlpriv, COMP_CMD, DBG_TRACE, \"<--IO Type(%#x)\\n\", iotype);\n\treturn true;\n}\n\nstatic void _rtl92d_phy_set_rfon(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\t \n\t \n\tif (rtlpriv->rtlhal.macphymode == SINGLEMAC_SINGLEPHY)\n\t\trtl_write_byte(rtlpriv, REG_SPS0_CTRL, 0x2b);\n\t \n\trtl_write_byte(rtlpriv, REG_SYS_FUNC_EN, 0xE3);\n\t \n\t \n\trtl_write_byte(rtlpriv, REG_APSD_CTRL, 0x00);\n\t \n\t \n\trtl_write_byte(rtlpriv, REG_SYS_FUNC_EN, 0xE2);\n\trtl_write_byte(rtlpriv, REG_SYS_FUNC_EN, 0xE3);\n\t \n\trtl_write_byte(rtlpriv, REG_TXPAUSE, 0x00);\n}\n\nstatic void _rtl92d_phy_set_rfsleep(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 u4btmp;\n\tu8 delay = 5;\n\n\t \n\trtl_write_byte(rtlpriv, REG_TXPAUSE, 0xFF);\n\t \n\trtl_set_rfreg(hw, RF90_PATH_A, 0x00, RFREG_OFFSET_MASK, 0x00);\n\t \n\trtl_write_byte(rtlpriv, REG_APSD_CTRL, 0x40);\n\t \n\tu4btmp = rtl_get_rfreg(hw, RF90_PATH_A, 0, RFREG_OFFSET_MASK);\n\twhile (u4btmp != 0 && delay > 0) {\n\t\trtl_write_byte(rtlpriv, REG_APSD_CTRL, 0x0);\n\t\trtl_set_rfreg(hw, RF90_PATH_A, 0x00, RFREG_OFFSET_MASK, 0x00);\n\t\trtl_write_byte(rtlpriv, REG_APSD_CTRL, 0x40);\n\t\tu4btmp = rtl_get_rfreg(hw, RF90_PATH_A, 0, RFREG_OFFSET_MASK);\n\t\tdelay--;\n\t}\n\tif (delay == 0) {\n\t\t \n\t\trtl_write_byte(rtlpriv, REG_APSD_CTRL, 0x00);\n\n\t\trtl_write_byte(rtlpriv, REG_SYS_FUNC_EN, 0xE2);\n\t\trtl_write_byte(rtlpriv, REG_SYS_FUNC_EN, 0xE3);\n\t\trtl_write_byte(rtlpriv, REG_TXPAUSE, 0x00);\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD,\n\t\t\t\"Fail !!! Switch RF timeout\\n\");\n\t\treturn;\n\t}\n\t \n\trtl_write_byte(rtlpriv, REG_SYS_FUNC_EN, 0xE2);\n\t \n\tif (rtlpriv->rtlhal.macphymode == SINGLEMAC_SINGLEPHY)\n\t\trtl_write_byte(rtlpriv, REG_SPS0_CTRL, 0x22);\n\t \n}\n\nbool rtl92d_phy_set_rf_power_state(struct ieee80211_hw *hw,\n\t\t\t\t   enum rf_pwrstate rfpwr_state)\n{\n\n\tbool bresult = true;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci_priv *pcipriv = rtl_pcipriv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tu8 i, queue_id;\n\tstruct rtl8192_tx_ring *ring = NULL;\n\n\tif (rfpwr_state == ppsc->rfpwr_state)\n\t\treturn false;\n\tswitch (rfpwr_state) {\n\tcase ERFON:\n\t\tif ((ppsc->rfpwr_state == ERFOFF) &&\n\t\t    RT_IN_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_HALT_NIC)) {\n\t\t\tbool rtstatus;\n\t\t\tu32 initializecount = 0;\n\t\t\tdo {\n\t\t\t\tinitializecount++;\n\t\t\t\trtl_dbg(rtlpriv, COMP_RF, DBG_DMESG,\n\t\t\t\t\t\"IPS Set eRf nic enable\\n\");\n\t\t\t\trtstatus = rtl_ps_enable_nic(hw);\n\t\t\t} while (!rtstatus && (initializecount < 10));\n\n\t\t\tRT_CLEAR_PS_LEVEL(ppsc,\n\t\t\t\t\t  RT_RF_OFF_LEVL_HALT_NIC);\n\t\t} else {\n\t\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_DMESG,\n\t\t\t\t\"awake, slept:%d ms state_inap:%x\\n\",\n\t\t\t\tjiffies_to_msecs(jiffies -\n\t\t\t\t\t\t ppsc->last_sleep_jiffies),\n\t\t\t\t rtlpriv->psc.state_inap);\n\t\t\tppsc->last_awake_jiffies = jiffies;\n\t\t\t_rtl92d_phy_set_rfon(hw);\n\t\t}\n\n\t\tif (mac->link_state == MAC80211_LINKED)\n\t\t\trtlpriv->cfg->ops->led_control(hw,\n\t\t\t\t\t LED_CTL_LINK);\n\t\telse\n\t\t\trtlpriv->cfg->ops->led_control(hw,\n\t\t\t\t\t LED_CTL_NO_LINK);\n\t\tbreak;\n\tcase ERFOFF:\n\t\tif (ppsc->reg_rfps_level & RT_RF_OFF_LEVL_HALT_NIC) {\n\t\t\trtl_dbg(rtlpriv, COMP_RF, DBG_DMESG,\n\t\t\t\t\"IPS Set eRf nic disable\\n\");\n\t\t\trtl_ps_disable_nic(hw);\n\t\t\tRT_SET_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_HALT_NIC);\n\t\t} else {\n\t\t\tif (ppsc->rfoff_reason == RF_CHANGE_BY_IPS)\n\t\t\t\trtlpriv->cfg->ops->led_control(hw,\n\t\t\t\t\t\t LED_CTL_NO_LINK);\n\t\t\telse\n\t\t\t\trtlpriv->cfg->ops->led_control(hw,\n\t\t\t\t\t\t LED_CTL_POWER_OFF);\n\t\t}\n\t\tbreak;\n\tcase ERFSLEEP:\n\t\tif (ppsc->rfpwr_state == ERFOFF)\n\t\t\treturn false;\n\n\t\tfor (queue_id = 0, i = 0;\n\t\t     queue_id < RTL_PCI_MAX_TX_QUEUE_COUNT;) {\n\t\t\tring = &pcipriv->dev.tx_ring[queue_id];\n\t\t\tif (skb_queue_len(&ring->queue) == 0 ||\n\t\t\t    queue_id == BEACON_QUEUE) {\n\t\t\t\tqueue_id++;\n\t\t\t\tcontinue;\n\t\t\t} else if (rtlpci->pdev->current_state != PCI_D0) {\n\t\t\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD,\n\t\t\t\t\t\"eRf Off/Sleep: %d times TcbBusyQueue[%d] !=0 but lower power state!\\n\",\n\t\t\t\t\ti + 1, queue_id);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_WARNING,\n\t\t\t\t\t\"eRf Off/Sleep: %d times TcbBusyQueue[%d] =%d before doze!\\n\",\n\t\t\t\t\ti + 1, queue_id,\n\t\t\t\t\tskb_queue_len(&ring->queue));\n\t\t\t\tudelay(10);\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\tif (i >= MAX_DOZE_WAITING_TIMES_9x) {\n\t\t\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_WARNING,\n\t\t\t\t\t\"ERFOFF: %d times TcbBusyQueue[%d] = %d !\\n\",\n\t\t\t\t\tMAX_DOZE_WAITING_TIMES_9x, queue_id,\n\t\t\t\t\tskb_queue_len(&ring->queue));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_DMESG,\n\t\t\t\"Set rfsleep awakened:%d ms\\n\",\n\t\t\t jiffies_to_msecs(jiffies - ppsc->last_awake_jiffies));\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_DMESG,\n\t\t\t\"sleep awakened:%d ms state_inap:%x\\n\",\n\t\t\tjiffies_to_msecs(jiffies -\n\t\t\t\t\t ppsc->last_awake_jiffies),\n\t\t\trtlpriv->psc.state_inap);\n\t\tppsc->last_sleep_jiffies = jiffies;\n\t\t_rtl92d_phy_set_rfsleep(hw);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"switch case %#x not processed\\n\",\n\t\t       rfpwr_state);\n\t\tbresult = false;\n\t\tbreak;\n\t}\n\tif (bresult)\n\t\tppsc->rfpwr_state = rfpwr_state;\n\treturn bresult;\n}\n\nvoid rtl92d_phy_config_macphymode(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tu8 offset = REG_MAC_PHY_CTRL_NORMAL;\n\n\tswitch (rtlhal->macphymode) {\n\tcase DUALMAC_DUALPHY:\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\"MacPhyMode: DUALMAC_DUALPHY\\n\");\n\t\trtl_write_byte(rtlpriv, offset, 0xF3);\n\t\tbreak;\n\tcase SINGLEMAC_SINGLEPHY:\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\"MacPhyMode: SINGLEMAC_SINGLEPHY\\n\");\n\t\trtl_write_byte(rtlpriv, offset, 0xF4);\n\t\tbreak;\n\tcase DUALMAC_SINGLEPHY:\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\"MacPhyMode: DUALMAC_SINGLEPHY\\n\");\n\t\trtl_write_byte(rtlpriv, offset, 0xF1);\n\t\tbreak;\n\t}\n}\n\nvoid rtl92d_phy_config_macphymode_info(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\n\tswitch (rtlhal->macphymode) {\n\tcase DUALMAC_SINGLEPHY:\n\t\trtlphy->rf_type = RF_2T2R;\n\t\trtlhal->version |= RF_TYPE_2T2R;\n\t\trtlhal->bandset = BAND_ON_BOTH;\n\t\trtlhal->current_bandtype = BAND_ON_2_4G;\n\t\tbreak;\n\n\tcase SINGLEMAC_SINGLEPHY:\n\t\trtlphy->rf_type = RF_2T2R;\n\t\trtlhal->version |= RF_TYPE_2T2R;\n\t\trtlhal->bandset = BAND_ON_BOTH;\n\t\trtlhal->current_bandtype = BAND_ON_2_4G;\n\t\tbreak;\n\n\tcase DUALMAC_DUALPHY:\n\t\trtlphy->rf_type = RF_1T1R;\n\t\trtlhal->version &= RF_TYPE_1T1R;\n\t\t \n\t\tif (rtlhal->interfaceindex == 0) {\n\t\t\trtlhal->bandset = BAND_ON_5G;\n\t\t\trtlhal->current_bandtype = BAND_ON_5G;\n\t\t} else {\n\t\t\trtlhal->bandset = BAND_ON_2_4G;\n\t\t\trtlhal->current_bandtype = BAND_ON_2_4G;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nu8 rtl92d_get_chnlgroup_fromarray(u8 chnl)\n{\n\tu8 group;\n\n\tif (channel_all[chnl] <= 3)\n\t\tgroup = 0;\n\telse if (channel_all[chnl] <= 9)\n\t\tgroup = 1;\n\telse if (channel_all[chnl] <= 14)\n\t\tgroup = 2;\n\telse if (channel_all[chnl] <= 44)\n\t\tgroup = 3;\n\telse if (channel_all[chnl] <= 54)\n\t\tgroup = 4;\n\telse if (channel_all[chnl] <= 64)\n\t\tgroup = 5;\n\telse if (channel_all[chnl] <= 112)\n\t\tgroup = 6;\n\telse if (channel_all[chnl] <= 126)\n\t\tgroup = 7;\n\telse if (channel_all[chnl] <= 140)\n\t\tgroup = 8;\n\telse if (channel_all[chnl] <= 153)\n\t\tgroup = 9;\n\telse if (channel_all[chnl] <= 159)\n\t\tgroup = 10;\n\telse\n\t\tgroup = 11;\n\treturn group;\n}\n\nvoid rtl92d_phy_set_poweron(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tunsigned long flags;\n\tu8 value8;\n\tu16 i;\n\tu32 mac_reg = (rtlhal->interfaceindex == 0 ? REG_MAC0 : REG_MAC1);\n\n\t \n\tif (rtlhal->current_bandtype == BAND_ON_2_4G) {\n\t\tvalue8 = rtl_read_byte(rtlpriv, mac_reg);\n\t\tvalue8 |= BIT(1);\n\t\trtl_write_byte(rtlpriv, mac_reg, value8);\n\t} else {\n\t\tvalue8 = rtl_read_byte(rtlpriv, mac_reg);\n\t\tvalue8 &= (~BIT(1));\n\t\trtl_write_byte(rtlpriv, mac_reg, value8);\n\t}\n\n\tif (rtlhal->macphymode == SINGLEMAC_SINGLEPHY) {\n\t\tvalue8 = rtl_read_byte(rtlpriv, REG_MAC0);\n\t\trtl_write_byte(rtlpriv, REG_MAC0, value8 | MAC0_ON);\n\t} else {\n\t\tspin_lock_irqsave(&globalmutex_power, flags);\n\t\tif (rtlhal->interfaceindex == 0) {\n\t\t\tvalue8 = rtl_read_byte(rtlpriv, REG_MAC0);\n\t\t\trtl_write_byte(rtlpriv, REG_MAC0, value8 | MAC0_ON);\n\t\t} else {\n\t\t\tvalue8 = rtl_read_byte(rtlpriv, REG_MAC1);\n\t\t\trtl_write_byte(rtlpriv, REG_MAC1, value8 | MAC1_ON);\n\t\t}\n\t\tvalue8 = rtl_read_byte(rtlpriv, REG_POWER_OFF_IN_PROCESS);\n\t\tspin_unlock_irqrestore(&globalmutex_power, flags);\n\t\tfor (i = 0; i < 200; i++) {\n\t\t\tif ((value8 & BIT(7)) == 0) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tudelay(500);\n\t\t\t\tspin_lock_irqsave(&globalmutex_power, flags);\n\t\t\t\tvalue8 = rtl_read_byte(rtlpriv,\n\t\t\t\t\t\t    REG_POWER_OFF_IN_PROCESS);\n\t\t\t\tspin_unlock_irqrestore(&globalmutex_power,\n\t\t\t\t\t\t       flags);\n\t\t\t}\n\t\t}\n\t\tif (i == 200)\n\t\t\tWARN_ONCE(true, \"rtl8192de: Another mac power off over time\\n\");\n\t}\n}\n\nvoid rtl92d_phy_config_maccoexist_rfpage(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\tswitch (rtlpriv->rtlhal.macphymode) {\n\tcase DUALMAC_DUALPHY:\n\t\trtl_write_byte(rtlpriv, REG_DMC, 0x0);\n\t\trtl_write_byte(rtlpriv, REG_RX_PKT_LIMIT, 0x08);\n\t\trtl_write_word(rtlpriv, REG_TRXFF_BNDY + 2, 0x13ff);\n\t\tbreak;\n\tcase DUALMAC_SINGLEPHY:\n\t\trtl_write_byte(rtlpriv, REG_DMC, 0xf8);\n\t\trtl_write_byte(rtlpriv, REG_RX_PKT_LIMIT, 0x08);\n\t\trtl_write_word(rtlpriv, REG_TRXFF_BNDY + 2, 0x13ff);\n\t\tbreak;\n\tcase SINGLEMAC_SINGLEPHY:\n\t\trtl_write_byte(rtlpriv, REG_DMC, 0x0);\n\t\trtl_write_byte(rtlpriv, REG_RX_PKT_LIMIT, 0x10);\n\t\trtl_write_word(rtlpriv, (REG_TRXFF_BNDY + 2), 0x27FF);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid rtl92d_update_bbrf_configuration(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tu8 rfpath, i;\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD, \"==>\\n\");\n\t \n\tif (rtlhal->current_bandtype == BAND_ON_2_4G) {\n\t\t \n\t\trtl_set_bbreg(hw, RFPGA0_XAB_RFPARAMETER, BIT(0), 0x0);\n\t\trtl_set_bbreg(hw, RFPGA0_XAB_RFPARAMETER, BIT(15), 0x0);\n\t\tif (rtlhal->macphymode != DUALMAC_DUALPHY) {\n\t\t\trtl_set_bbreg(hw, RFPGA0_XAB_RFPARAMETER, BIT(16), 0x0);\n\t\t\trtl_set_bbreg(hw, RFPGA0_XAB_RFPARAMETER, BIT(31), 0x0);\n\t\t}\n\t\t \n\t\trtl_set_bbreg(hw, ROFDM0_AGCRSSITABLE, BIT(6) | BIT(7), 0x0);\n\t\t \n\t\trtl_set_bbreg(hw, ROFDM1_CFOTRACKING, BIT(14) | BIT(13), 0x0);\n\t\t \n\t\trtl_set_bbreg(hw, 0xB30, 0x00F00000, 0xa);\n\t\t \n\t\trtl_set_bbreg(hw, ROFDM0_XATXIQIMBALANCE, MASKDWORD,\n\t\t\t      0x40000100);\n\t\trtl_set_bbreg(hw, ROFDM0_XBTXIQIMBALANCE, MASKDWORD,\n\t\t\t      0x40000100);\n\t\tif (rtlhal->macphymode == DUALMAC_DUALPHY) {\n\t\t\trtl_set_bbreg(hw, RFPGA0_XAB_RFINTERFACESW,\n\t\t\t\t      BIT(10) | BIT(6) | BIT(5),\n\t\t\t\t      ((rtlefuse->eeprom_c9 & BIT(3)) >> 3) |\n\t\t\t\t      (rtlefuse->eeprom_c9 & BIT(1)) |\n\t\t\t\t      ((rtlefuse->eeprom_cc & BIT(1)) << 4));\n\t\t\trtl_set_bbreg(hw, RFPGA0_XA_RFINTERFACEOE,\n\t\t\t\t      BIT(10) | BIT(6) | BIT(5),\n\t\t\t\t      ((rtlefuse->eeprom_c9 & BIT(2)) >> 2) |\n\t\t\t\t      ((rtlefuse->eeprom_c9 & BIT(0)) << 1) |\n\t\t\t\t      ((rtlefuse->eeprom_cc & BIT(0)) << 5));\n\t\t\trtl_set_bbreg(hw, RFPGA0_XAB_RFPARAMETER, BIT(15), 0);\n\t\t} else {\n\t\t\trtl_set_bbreg(hw, RFPGA0_XAB_RFINTERFACESW,\n\t\t\t\t      BIT(26) | BIT(22) | BIT(21) | BIT(10) |\n\t\t\t\t      BIT(6) | BIT(5),\n\t\t\t\t      ((rtlefuse->eeprom_c9 & BIT(3)) >> 3) |\n\t\t\t\t      (rtlefuse->eeprom_c9 & BIT(1)) |\n\t\t\t\t      ((rtlefuse->eeprom_cc & BIT(1)) << 4) |\n\t\t\t\t      ((rtlefuse->eeprom_c9 & BIT(7)) << 9) |\n\t\t\t\t      ((rtlefuse->eeprom_c9 & BIT(5)) << 12) |\n\t\t\t\t      ((rtlefuse->eeprom_cc & BIT(3)) << 18));\n\t\t\trtl_set_bbreg(hw, RFPGA0_XA_RFINTERFACEOE,\n\t\t\t\t      BIT(10) | BIT(6) | BIT(5),\n\t\t\t\t      ((rtlefuse->eeprom_c9 & BIT(2)) >> 2) |\n\t\t\t\t      ((rtlefuse->eeprom_c9 & BIT(0)) << 1) |\n\t\t\t\t      ((rtlefuse->eeprom_cc & BIT(0)) << 5));\n\t\t\trtl_set_bbreg(hw, RFPGA0_XB_RFINTERFACEOE,\n\t\t\t\t      BIT(10) | BIT(6) | BIT(5),\n\t\t\t\t      ((rtlefuse->eeprom_c9 & BIT(6)) >> 6) |\n\t\t\t\t      ((rtlefuse->eeprom_c9 & BIT(4)) >> 3) |\n\t\t\t\t      ((rtlefuse->eeprom_cc & BIT(2)) << 3));\n\t\t\trtl_set_bbreg(hw, RFPGA0_XAB_RFPARAMETER,\n\t\t\t\t      BIT(31) | BIT(15), 0);\n\t\t}\n\t\t \n\t} else {\n\t\t \n\t\trtl_set_bbreg(hw, RFPGA0_XAB_RFPARAMETER, BIT(0), 0x1);\n\t\trtl_set_bbreg(hw, RFPGA0_XAB_RFPARAMETER, BIT(15), 0x1);\n\t\tif (rtlhal->macphymode != DUALMAC_DUALPHY) {\n\t\t\trtl_set_bbreg(hw, RFPGA0_XAB_RFPARAMETER, BIT(16), 0x1);\n\t\t\trtl_set_bbreg(hw, RFPGA0_XAB_RFPARAMETER, BIT(31), 0x1);\n\t\t}\n\t\t \n\t\trtl_set_bbreg(hw, ROFDM0_AGCRSSITABLE, BIT(6) | BIT(7), 0x1);\n\t\t \n\t\trtl_set_bbreg(hw, ROFDM1_CFOTRACKING, BIT(14) | BIT(13), 0x1);\n\t\t \n\t\trtl_set_bbreg(hw, 0xB30, 0x00F00000, 0x0);\n\t\t \n\t\tif (rtlefuse->internal_pa_5g[0])\n\t\t\trtl_set_bbreg(hw, ROFDM0_XATXIQIMBALANCE, MASKDWORD,\n\t\t\t\t      0x2d4000b5);\n\t\telse\n\t\t\trtl_set_bbreg(hw, ROFDM0_XATXIQIMBALANCE, MASKDWORD,\n\t\t\t\t      0x20000080);\n\t\tif (rtlefuse->internal_pa_5g[1])\n\t\t\trtl_set_bbreg(hw, ROFDM0_XBTXIQIMBALANCE, MASKDWORD,\n\t\t\t\t      0x2d4000b5);\n\t\telse\n\t\t\trtl_set_bbreg(hw, ROFDM0_XBTXIQIMBALANCE, MASKDWORD,\n\t\t\t\t      0x20000080);\n\t\tif (rtlhal->macphymode == DUALMAC_DUALPHY) {\n\t\t\trtl_set_bbreg(hw, RFPGA0_XAB_RFINTERFACESW,\n\t\t\t\t      BIT(10) | BIT(6) | BIT(5),\n\t\t\t\t      (rtlefuse->eeprom_cc & BIT(5)));\n\t\t\trtl_set_bbreg(hw, RFPGA0_XA_RFINTERFACEOE, BIT(10),\n\t\t\t\t      ((rtlefuse->eeprom_cc & BIT(4)) >> 4));\n\t\t\trtl_set_bbreg(hw, RFPGA0_XAB_RFPARAMETER, BIT(15),\n\t\t\t\t      (rtlefuse->eeprom_cc & BIT(4)) >> 4);\n\t\t} else {\n\t\t\trtl_set_bbreg(hw, RFPGA0_XAB_RFINTERFACESW,\n\t\t\t\t      BIT(26) | BIT(22) | BIT(21) | BIT(10) |\n\t\t\t\t      BIT(6) | BIT(5),\n\t\t\t\t      (rtlefuse->eeprom_cc & BIT(5)) |\n\t\t\t\t      ((rtlefuse->eeprom_cc & BIT(7)) << 14));\n\t\t\trtl_set_bbreg(hw, RFPGA0_XA_RFINTERFACEOE, BIT(10),\n\t\t\t\t      ((rtlefuse->eeprom_cc & BIT(4)) >> 4));\n\t\t\trtl_set_bbreg(hw, RFPGA0_XB_RFINTERFACEOE, BIT(10),\n\t\t\t\t      ((rtlefuse->eeprom_cc & BIT(6)) >> 6));\n\t\t\trtl_set_bbreg(hw, RFPGA0_XAB_RFPARAMETER,\n\t\t\t\t      BIT(31) | BIT(15),\n\t\t\t\t      ((rtlefuse->eeprom_cc & BIT(4)) >> 4) |\n\t\t\t\t      ((rtlefuse->eeprom_cc & BIT(6)) << 10));\n\t\t}\n\t}\n\t \n\trtl_set_bbreg(hw, ROFDM0_XARXIQIMBALANCE, MASKDWORD, 0x40000100);\n\trtl_set_bbreg(hw, ROFDM0_XBRXIQIMBALANCE, MASKDWORD, 0x40000100);\n\trtl_set_bbreg(hw, ROFDM0_XCTXAFE, 0xF0000000, 0x00);\n\trtl_set_bbreg(hw, ROFDM0_ECCATHRESHOLD, BIT(30) | BIT(28) |\n\t\t      BIT(26) | BIT(24), 0x00);\n\trtl_set_bbreg(hw, ROFDM0_XDTXAFE, 0xF0000000, 0x00);\n\trtl_set_bbreg(hw, 0xca0, 0xF0000000, 0x00);\n\trtl_set_bbreg(hw, ROFDM0_AGCRSSITABLE, 0x0000F000, 0x00);\n\n\t \n\tfor (rfpath = RF90_PATH_A; rfpath < rtlphy->num_total_rfpath;\n\t     rfpath++) {\n\t\tif (rtlhal->current_bandtype == BAND_ON_2_4G) {\n\t\t\t \n\t\t\trtl_set_rfreg(hw, rfpath, RF_CHNLBW, BIT(8) | BIT(16) |\n\t\t\t\t      BIT(18), 0);\n\t\t\t \n\t\t\trtl_set_rfreg(hw, (enum radio_path)rfpath, 0x0B,\n\t\t\t\t      0x1c000, 0x07);\n\t\t} else {\n\t\t\t \n\t\t\trtl_set_rfreg(hw, rfpath, RF_CHNLBW, BIT(8) |\n\t\t\t\t      BIT(16) | BIT(18),\n\t\t\t\t      (BIT(16) | BIT(8)) >> 8);\n\t\t}\n\t}\n\t \n\t \n\tif (rtlphy->rf_type == RF_1T1R) {\n\t\t \n\t\trtl_set_bbreg(hw, ROFDM0_TRXPATHENABLE, MASKBYTE0, 0x11);\n\t\trtl_set_bbreg(hw, ROFDM1_TRXPATHENABLE, BDWORD, 0x1);\n\n\t\t \n\t\tif (rtlhal->interfaceindex == 0) {\n\t\t\trtl_set_bbreg(hw, RFPGA0_ADDALLOCKEN, BIT(12) |\n\t\t\t\t      BIT(13), 0x3);\n\t\t} else {\n\t\t\trtl92d_phy_enable_anotherphy(hw, false);\n\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\t\"MAC1 use DBI to update 0x888\\n\");\n\t\t\t \n\t\t\trtl92de_write_dword_dbi(hw, RFPGA0_ADDALLOCKEN,\n\t\t\t\t\t\trtl92de_read_dword_dbi(hw,\n\t\t\t\t\t\tRFPGA0_ADDALLOCKEN,\n\t\t\t\t\t\tBIT(3)) | BIT(12) | BIT(13),\n\t\t\t\t\t\tBIT(3));\n\t\t\trtl92d_phy_powerdown_anotherphy(hw, false);\n\t\t}\n\t} else {\n\t\t \n\t\t \n\t\trtl_set_bbreg(hw, ROFDM0_TRXPATHENABLE, MASKBYTE0, 0x33);\n\t\trtl_set_bbreg(hw, ROFDM1_TRXPATHENABLE, BDWORD, 0x3);\n\t\t \n\t\trtl_set_bbreg(hw, RFPGA0_ADDALLOCKEN, BIT(12) | BIT(13), 0);\n\t}\n\tfor (rfpath = RF90_PATH_A; rfpath < rtlphy->num_total_rfpath;\n\t     rfpath++) {\n\t\trtlphy->rfreg_chnlval[rfpath] = rtl_get_rfreg(hw, rfpath,\n\t\t\t\t\t\tRF_CHNLBW, RFREG_OFFSET_MASK);\n\t\trtlphy->reg_rf3c[rfpath] = rtl_get_rfreg(hw, rfpath, 0x3C,\n\t\t\tRFREG_OFFSET_MASK);\n\t}\n\tfor (i = 0; i < 2; i++)\n\t\trtl_dbg(rtlpriv, COMP_RF, DBG_LOUD, \"RF 0x18 = 0x%x\\n\",\n\t\t\trtlphy->rfreg_chnlval[i]);\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD, \"<==\\n\");\n\n}\n\nbool rtl92d_phy_check_poweroff(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tu8 u1btmp;\n\tunsigned long flags;\n\n\tif (rtlhal->macphymode == SINGLEMAC_SINGLEPHY) {\n\t\tu1btmp = rtl_read_byte(rtlpriv, REG_MAC0);\n\t\trtl_write_byte(rtlpriv, REG_MAC0, u1btmp & (~MAC0_ON));\n\t\treturn true;\n\t}\n\tspin_lock_irqsave(&globalmutex_power, flags);\n\tif (rtlhal->interfaceindex == 0) {\n\t\tu1btmp = rtl_read_byte(rtlpriv, REG_MAC0);\n\t\trtl_write_byte(rtlpriv, REG_MAC0, u1btmp & (~MAC0_ON));\n\t\tu1btmp = rtl_read_byte(rtlpriv, REG_MAC1);\n\t\tu1btmp &= MAC1_ON;\n\t} else {\n\t\tu1btmp = rtl_read_byte(rtlpriv, REG_MAC1);\n\t\trtl_write_byte(rtlpriv, REG_MAC1, u1btmp & (~MAC1_ON));\n\t\tu1btmp = rtl_read_byte(rtlpriv, REG_MAC0);\n\t\tu1btmp &= MAC0_ON;\n\t}\n\tif (u1btmp) {\n\t\tspin_unlock_irqrestore(&globalmutex_power, flags);\n\t\treturn false;\n\t}\n\tu1btmp = rtl_read_byte(rtlpriv, REG_POWER_OFF_IN_PROCESS);\n\tu1btmp |= BIT(7);\n\trtl_write_byte(rtlpriv, REG_POWER_OFF_IN_PROCESS, u1btmp);\n\tspin_unlock_irqrestore(&globalmutex_power, flags);\n\treturn true;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}