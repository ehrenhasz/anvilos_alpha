{
  "module_name": "fw.c",
  "hash_id": "5e780dbb5650a3a8aea22340c2dd0a28829dff103ff8ddfada75996144d7cfe5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtlwifi/rtl8192de/fw.c",
  "human_readable_source": "\n \n\n#include \"../wifi.h\"\n#include \"../pci.h\"\n#include \"../base.h\"\n#include \"../efuse.h\"\n#include \"reg.h\"\n#include \"def.h\"\n#include \"fw.h\"\n#include \"sw.h\"\n\nstatic bool _rtl92d_is_fw_downloaded(struct rtl_priv *rtlpriv)\n{\n\treturn (rtl_read_dword(rtlpriv, REG_MCUFWDL) & MCUFWDL_RDY) ?\n\t\ttrue : false;\n}\n\nstatic void _rtl92d_enable_fw_download(struct ieee80211_hw *hw, bool enable)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 tmp;\n\n\tif (enable) {\n\t\ttmp = rtl_read_byte(rtlpriv, REG_SYS_FUNC_EN + 1);\n\t\trtl_write_byte(rtlpriv, REG_SYS_FUNC_EN + 1, tmp | 0x04);\n\t\ttmp = rtl_read_byte(rtlpriv, REG_MCUFWDL);\n\t\trtl_write_byte(rtlpriv, REG_MCUFWDL, tmp | 0x01);\n\t\ttmp = rtl_read_byte(rtlpriv, REG_MCUFWDL + 2);\n\t\trtl_write_byte(rtlpriv, REG_MCUFWDL + 2, tmp & 0xf7);\n\t} else {\n\t\ttmp = rtl_read_byte(rtlpriv, REG_MCUFWDL);\n\t\trtl_write_byte(rtlpriv, REG_MCUFWDL, tmp & 0xfe);\n\t\t \n\t}\n}\n\nstatic void _rtl92d_write_fw(struct ieee80211_hw *hw,\n\t\t\t     enum version_8192d version, u8 *buffer, u32 size)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tu8 *bufferptr = buffer;\n\tu32 pagenums, remainsize;\n\tu32 page, offset;\n\n\trtl_dbg(rtlpriv, COMP_FW, DBG_TRACE, \"FW size is %d bytes,\\n\", size);\n\tif (rtlhal->hw_type == HARDWARE_TYPE_RTL8192DE)\n\t\trtl_fill_dummy(bufferptr, &size);\n\tpagenums = size / FW_8192D_PAGE_SIZE;\n\tremainsize = size % FW_8192D_PAGE_SIZE;\n\tif (pagenums > 8)\n\t\tpr_err(\"Page numbers should not greater then 8\\n\");\n\tfor (page = 0; page < pagenums; page++) {\n\t\toffset = page * FW_8192D_PAGE_SIZE;\n\t\trtl_fw_page_write(hw, page, (bufferptr + offset),\n\t\t\t\t  FW_8192D_PAGE_SIZE);\n\t}\n\tif (remainsize) {\n\t\toffset = pagenums * FW_8192D_PAGE_SIZE;\n\t\tpage = pagenums;\n\t\trtl_fw_page_write(hw, page, (bufferptr + offset), remainsize);\n\t}\n}\n\nstatic int _rtl92d_fw_free_to_go(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 counter = 0;\n\tu32 value32;\n\n\tdo {\n\t\tvalue32 = rtl_read_dword(rtlpriv, REG_MCUFWDL);\n\t} while ((counter++ < FW_8192D_POLLING_TIMEOUT_COUNT) &&\n\t\t (!(value32 & FWDL_CHKSUM_RPT)));\n\tif (counter >= FW_8192D_POLLING_TIMEOUT_COUNT) {\n\t\tpr_err(\"chksum report fail! REG_MCUFWDL:0x%08x\\n\",\n\t\t       value32);\n\t\treturn -EIO;\n\t}\n\tvalue32 = rtl_read_dword(rtlpriv, REG_MCUFWDL);\n\tvalue32 |= MCUFWDL_RDY;\n\trtl_write_dword(rtlpriv, REG_MCUFWDL, value32);\n\treturn 0;\n}\n\nvoid rtl92d_firmware_selfreset(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 u1b_tmp;\n\tu8 delay = 100;\n\n\t \n\trtl_write_byte(rtlpriv, REG_HMETFR + 3, 0x20);\n\tu1b_tmp = rtl_read_byte(rtlpriv, REG_SYS_FUNC_EN + 1);\n\twhile (u1b_tmp & BIT(2)) {\n\t\tdelay--;\n\t\tif (delay == 0)\n\t\t\tbreak;\n\t\tudelay(50);\n\t\tu1b_tmp = rtl_read_byte(rtlpriv, REG_SYS_FUNC_EN + 1);\n\t}\n\tWARN_ONCE((delay <= 0), \"rtl8192de: 8051 reset failed!\\n\");\n\trtl_dbg(rtlpriv, COMP_FW, DBG_DMESG,\n\t\t\"=====> 8051 reset success (%d)\\n\", delay);\n}\n\nstatic int _rtl92d_fw_init(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tu32 counter;\n\n\trtl_dbg(rtlpriv, COMP_FW, DBG_DMESG, \"FW already have download\\n\");\n\t \n\tcounter = 0;\n\tdo {\n\t\tif (rtlhal->interfaceindex == 0) {\n\t\t\tif (rtl_read_byte(rtlpriv, FW_MAC0_READY) &\n\t\t\t    MAC0_READY) {\n\t\t\t\trtl_dbg(rtlpriv, COMP_FW, DBG_DMESG,\n\t\t\t\t\t\"Polling FW ready success!! REG_MCUFWDL: 0x%x\\n\",\n\t\t\t\t\trtl_read_byte(rtlpriv,\n\t\t\t\t\t\t      FW_MAC0_READY));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tudelay(5);\n\t\t} else {\n\t\t\tif (rtl_read_byte(rtlpriv, FW_MAC1_READY) &\n\t\t\t    MAC1_READY) {\n\t\t\t\trtl_dbg(rtlpriv, COMP_FW, DBG_DMESG,\n\t\t\t\t\t\"Polling FW ready success!! REG_MCUFWDL: 0x%x\\n\",\n\t\t\t\t\trtl_read_byte(rtlpriv,\n\t\t\t\t\t\t      FW_MAC1_READY));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tudelay(5);\n\t\t}\n\t} while (counter++ < POLLING_READY_TIMEOUT_COUNT);\n\n\tif (rtlhal->interfaceindex == 0) {\n\t\trtl_dbg(rtlpriv, COMP_FW, DBG_DMESG,\n\t\t\t\"Polling FW ready fail!! MAC0 FW init not ready: 0x%x\\n\",\n\t\t\trtl_read_byte(rtlpriv, FW_MAC0_READY));\n\t} else {\n\t\trtl_dbg(rtlpriv, COMP_FW, DBG_DMESG,\n\t\t\t\"Polling FW ready fail!! MAC1 FW init not ready: 0x%x\\n\",\n\t\t\trtl_read_byte(rtlpriv, FW_MAC1_READY));\n\t}\n\trtl_dbg(rtlpriv, COMP_FW, DBG_DMESG,\n\t\t\"Polling FW ready fail!! REG_MCUFWDL:0x%08x\\n\",\n\t\trtl_read_dword(rtlpriv, REG_MCUFWDL));\n\treturn -1;\n}\n\nint rtl92d_download_fw(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tu8 *pfwheader;\n\tu8 *pfwdata;\n\tu32 fwsize;\n\tint err;\n\tenum version_8192d version = rtlhal->version;\n\tu8 value;\n\tu32 count;\n\tbool fw_downloaded = false, fwdl_in_process = false;\n\tunsigned long flags;\n\n\tif (rtlpriv->max_fw_size == 0 || !rtlhal->pfirmware)\n\t\treturn 1;\n\tfwsize = rtlhal->fwsize;\n\tpfwheader = rtlhal->pfirmware;\n\tpfwdata = rtlhal->pfirmware;\n\trtlhal->fw_version = (u16) GET_FIRMWARE_HDR_VERSION(pfwheader);\n\trtlhal->fw_subversion = (u16) GET_FIRMWARE_HDR_SUB_VER(pfwheader);\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\"FirmwareVersion(%d), FirmwareSubVersion(%d), Signature(%#x)\\n\",\n\t\trtlhal->fw_version, rtlhal->fw_subversion,\n\t\tGET_FIRMWARE_HDR_SIGNATURE(pfwheader));\n\tif (IS_FW_HEADER_EXIST(pfwheader)) {\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\"Shift 32 bytes for FW header!!\\n\");\n\t\tpfwdata = pfwdata + 32;\n\t\tfwsize = fwsize - 32;\n\t}\n\n\tspin_lock_irqsave(&globalmutex_for_fwdownload, flags);\n\tfw_downloaded = _rtl92d_is_fw_downloaded(rtlpriv);\n\tif ((rtl_read_byte(rtlpriv, 0x1f) & BIT(5)) == BIT(5))\n\t\tfwdl_in_process = true;\n\telse\n\t\tfwdl_in_process = false;\n\tif (fw_downloaded) {\n\t\tspin_unlock_irqrestore(&globalmutex_for_fwdownload, flags);\n\t\tgoto exit;\n\t} else if (fwdl_in_process) {\n\t\tspin_unlock_irqrestore(&globalmutex_for_fwdownload, flags);\n\t\tfor (count = 0; count < 5000; count++) {\n\t\t\tudelay(500);\n\t\t\tspin_lock_irqsave(&globalmutex_for_fwdownload, flags);\n\t\t\tfw_downloaded = _rtl92d_is_fw_downloaded(rtlpriv);\n\t\t\tif ((rtl_read_byte(rtlpriv, 0x1f) & BIT(5)) == BIT(5))\n\t\t\t\tfwdl_in_process = true;\n\t\t\telse\n\t\t\t\tfwdl_in_process = false;\n\t\t\tspin_unlock_irqrestore(&globalmutex_for_fwdownload,\n\t\t\t\t\t       flags);\n\t\t\tif (fw_downloaded)\n\t\t\t\tgoto exit;\n\t\t\telse if (!fwdl_in_process)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\trtl_dbg(rtlpriv, COMP_FW, DBG_DMESG,\n\t\t\t\t\t\"Wait for another mac download fw\\n\");\n\t\t}\n\t\tspin_lock_irqsave(&globalmutex_for_fwdownload, flags);\n\t\tvalue = rtl_read_byte(rtlpriv, 0x1f);\n\t\tvalue |= BIT(5);\n\t\trtl_write_byte(rtlpriv, 0x1f, value);\n\t\tspin_unlock_irqrestore(&globalmutex_for_fwdownload, flags);\n\t} else {\n\t\tvalue = rtl_read_byte(rtlpriv, 0x1f);\n\t\tvalue |= BIT(5);\n\t\trtl_write_byte(rtlpriv, 0x1f, value);\n\t\tspin_unlock_irqrestore(&globalmutex_for_fwdownload, flags);\n\t}\n\n\t \n\t \n\tif (rtl_read_byte(rtlpriv, REG_MCUFWDL) & BIT(7)) {\n\t\trtl92d_firmware_selfreset(hw);\n\t\trtl_write_byte(rtlpriv, REG_MCUFWDL, 0x00);\n\t}\n\t_rtl92d_enable_fw_download(hw, true);\n\t_rtl92d_write_fw(hw, version, pfwdata, fwsize);\n\t_rtl92d_enable_fw_download(hw, false);\n\tspin_lock_irqsave(&globalmutex_for_fwdownload, flags);\n\terr = _rtl92d_fw_free_to_go(hw);\n\t \n\tvalue = rtl_read_byte(rtlpriv, 0x1f);\n\tvalue &= (~BIT(5));\n\trtl_write_byte(rtlpriv, 0x1f, value);\n\tspin_unlock_irqrestore(&globalmutex_for_fwdownload, flags);\n\tif (err)\n\t\tpr_err(\"fw is not ready to run!\\n\");\nexit:\n\terr = _rtl92d_fw_init(hw);\n\treturn err;\n}\n\nstatic bool _rtl92d_check_fw_read_last_h2c(struct ieee80211_hw *hw, u8 boxnum)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 val_hmetfr;\n\tbool result = false;\n\n\tval_hmetfr = rtl_read_byte(rtlpriv, REG_HMETFR);\n\tif (((val_hmetfr >> boxnum) & BIT(0)) == 0)\n\t\tresult = true;\n\treturn result;\n}\n\nstatic void _rtl92d_fill_h2c_command(struct ieee80211_hw *hw,\n\t\t\t      u8 element_id, u32 cmd_len, u8 *cmdbuffer)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tu8 boxnum;\n\tu16 box_reg = 0, box_extreg = 0;\n\tu8 u1b_tmp;\n\tbool isfw_read = false;\n\tu8 buf_index = 0;\n\tbool bwrite_success = false;\n\tu8 wait_h2c_limmit = 100;\n\tu8 wait_writeh2c_limmit = 100;\n\tu8 boxcontent[4], boxextcontent[2];\n\tu32 h2c_waitcounter = 0;\n\tunsigned long flag;\n\tu8 idx;\n\n\tif (ppsc->rfpwr_state == ERFOFF || ppsc->inactive_pwrstate == ERFOFF) {\n\t\trtl_dbg(rtlpriv, COMP_CMD, DBG_LOUD,\n\t\t\t\"Return as RF is off!!!\\n\");\n\t\treturn;\n\t}\n\trtl_dbg(rtlpriv, COMP_CMD, DBG_LOUD, \"come in\\n\");\n\twhile (true) {\n\t\tspin_lock_irqsave(&rtlpriv->locks.h2c_lock, flag);\n\t\tif (rtlhal->h2c_setinprogress) {\n\t\t\trtl_dbg(rtlpriv, COMP_CMD, DBG_LOUD,\n\t\t\t\t\"H2C set in progress! Wait to set..element_id(%d)\\n\",\n\t\t\t\telement_id);\n\n\t\t\twhile (rtlhal->h2c_setinprogress) {\n\t\t\t\tspin_unlock_irqrestore(&rtlpriv->locks.h2c_lock,\n\t\t\t\t\t\t       flag);\n\t\t\t\th2c_waitcounter++;\n\t\t\t\trtl_dbg(rtlpriv, COMP_CMD, DBG_LOUD,\n\t\t\t\t\t\"Wait 100 us (%d times)...\\n\",\n\t\t\t\t\th2c_waitcounter);\n\t\t\t\tudelay(100);\n\n\t\t\t\tif (h2c_waitcounter > 1000)\n\t\t\t\t\treturn;\n\n\t\t\t\tspin_lock_irqsave(&rtlpriv->locks.h2c_lock,\n\t\t\t\t\t\t  flag);\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&rtlpriv->locks.h2c_lock, flag);\n\t\t} else {\n\t\t\trtlhal->h2c_setinprogress = true;\n\t\t\tspin_unlock_irqrestore(&rtlpriv->locks.h2c_lock, flag);\n\t\t\tbreak;\n\t\t}\n\t}\n\twhile (!bwrite_success) {\n\t\twait_writeh2c_limmit--;\n\t\tif (wait_writeh2c_limmit == 0) {\n\t\t\tpr_err(\"Write H2C fail because no trigger for FW INT!\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tboxnum = rtlhal->last_hmeboxnum;\n\t\tswitch (boxnum) {\n\t\tcase 0:\n\t\t\tbox_reg = REG_HMEBOX_0;\n\t\t\tbox_extreg = REG_HMEBOX_EXT_0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tbox_reg = REG_HMEBOX_1;\n\t\t\tbox_extreg = REG_HMEBOX_EXT_1;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tbox_reg = REG_HMEBOX_2;\n\t\t\tbox_extreg = REG_HMEBOX_EXT_2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tbox_reg = REG_HMEBOX_3;\n\t\t\tbox_extreg = REG_HMEBOX_EXT_3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"switch case %#x not processed\\n\",\n\t\t\t       boxnum);\n\t\t\tbreak;\n\t\t}\n\t\tisfw_read = _rtl92d_check_fw_read_last_h2c(hw, boxnum);\n\t\twhile (!isfw_read) {\n\t\t\twait_h2c_limmit--;\n\t\t\tif (wait_h2c_limmit == 0) {\n\t\t\t\trtl_dbg(rtlpriv, COMP_CMD, DBG_LOUD,\n\t\t\t\t\t\"Waiting too long for FW read clear HMEBox(%d)!\\n\",\n\t\t\t\t\tboxnum);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tudelay(10);\n\t\t\tisfw_read = _rtl92d_check_fw_read_last_h2c(hw, boxnum);\n\t\t\tu1b_tmp = rtl_read_byte(rtlpriv, 0x1BF);\n\t\t\trtl_dbg(rtlpriv, COMP_CMD, DBG_LOUD,\n\t\t\t\t\"Waiting for FW read clear HMEBox(%d)!!! 0x1BF = %2x\\n\",\n\t\t\t\tboxnum, u1b_tmp);\n\t\t}\n\t\tif (!isfw_read) {\n\t\t\trtl_dbg(rtlpriv, COMP_CMD, DBG_LOUD,\n\t\t\t\t\"Write H2C register BOX[%d] fail!!!!! Fw do not read.\\n\",\n\t\t\t\tboxnum);\n\t\t\tbreak;\n\t\t}\n\t\tmemset(boxcontent, 0, sizeof(boxcontent));\n\t\tmemset(boxextcontent, 0, sizeof(boxextcontent));\n\t\tboxcontent[0] = element_id;\n\t\trtl_dbg(rtlpriv, COMP_CMD, DBG_LOUD,\n\t\t\t\"Write element_id box_reg(%4x) = %2x\\n\",\n\t\t\tbox_reg, element_id);\n\t\tswitch (cmd_len) {\n\t\tcase 1:\n\t\t\tboxcontent[0] &= ~(BIT(7));\n\t\t\tmemcpy(boxcontent + 1, cmdbuffer + buf_index, 1);\n\t\t\tfor (idx = 0; idx < 4; idx++)\n\t\t\t\trtl_write_byte(rtlpriv, box_reg + idx,\n\t\t\t\t\t       boxcontent[idx]);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tboxcontent[0] &= ~(BIT(7));\n\t\t\tmemcpy(boxcontent + 1, cmdbuffer + buf_index, 2);\n\t\t\tfor (idx = 0; idx < 4; idx++)\n\t\t\t\trtl_write_byte(rtlpriv, box_reg + idx,\n\t\t\t\t\t       boxcontent[idx]);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tboxcontent[0] &= ~(BIT(7));\n\t\t\tmemcpy(boxcontent + 1, cmdbuffer + buf_index, 3);\n\t\t\tfor (idx = 0; idx < 4; idx++)\n\t\t\t\trtl_write_byte(rtlpriv, box_reg + idx,\n\t\t\t\t\t       boxcontent[idx]);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tboxcontent[0] |= (BIT(7));\n\t\t\tmemcpy(boxextcontent, cmdbuffer + buf_index, 2);\n\t\t\tmemcpy(boxcontent + 1, cmdbuffer + buf_index + 2, 2);\n\t\t\tfor (idx = 0; idx < 2; idx++)\n\t\t\t\trtl_write_byte(rtlpriv, box_extreg + idx,\n\t\t\t\t\t       boxextcontent[idx]);\n\t\t\tfor (idx = 0; idx < 4; idx++)\n\t\t\t\trtl_write_byte(rtlpriv, box_reg + idx,\n\t\t\t\t\t       boxcontent[idx]);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tboxcontent[0] |= (BIT(7));\n\t\t\tmemcpy(boxextcontent, cmdbuffer + buf_index, 2);\n\t\t\tmemcpy(boxcontent + 1, cmdbuffer + buf_index + 2, 3);\n\t\t\tfor (idx = 0; idx < 2; idx++)\n\t\t\t\trtl_write_byte(rtlpriv, box_extreg + idx,\n\t\t\t\t\t       boxextcontent[idx]);\n\t\t\tfor (idx = 0; idx < 4; idx++)\n\t\t\t\trtl_write_byte(rtlpriv, box_reg + idx,\n\t\t\t\t\t       boxcontent[idx]);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"switch case %#x not processed\\n\",\n\t\t\t       cmd_len);\n\t\t\tbreak;\n\t\t}\n\t\tbwrite_success = true;\n\t\trtlhal->last_hmeboxnum = boxnum + 1;\n\t\tif (rtlhal->last_hmeboxnum == 4)\n\t\t\trtlhal->last_hmeboxnum = 0;\n\t\trtl_dbg(rtlpriv, COMP_CMD, DBG_LOUD,\n\t\t\t\"pHalData->last_hmeboxnum  = %d\\n\",\n\t\t\trtlhal->last_hmeboxnum);\n\t}\n\tspin_lock_irqsave(&rtlpriv->locks.h2c_lock, flag);\n\trtlhal->h2c_setinprogress = false;\n\tspin_unlock_irqrestore(&rtlpriv->locks.h2c_lock, flag);\n\trtl_dbg(rtlpriv, COMP_CMD, DBG_LOUD, \"go out\\n\");\n}\n\nvoid rtl92d_fill_h2c_cmd(struct ieee80211_hw *hw,\n\t\t\t u8 element_id, u32 cmd_len, u8 *cmdbuffer)\n{\n\tu32 tmp_cmdbuf[2];\n\n\tmemset(tmp_cmdbuf, 0, 8);\n\tmemcpy(tmp_cmdbuf, cmdbuffer, cmd_len);\n\t_rtl92d_fill_h2c_command(hw, element_id, cmd_len, (u8 *)&tmp_cmdbuf);\n\treturn;\n}\n\nstatic bool _rtl92d_cmd_send_packet(struct ieee80211_hw *hw,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tstruct rtl8192_tx_ring *ring;\n\tstruct rtl_tx_desc *pdesc;\n\tu8 idx = 0;\n\tunsigned long flags;\n\tstruct sk_buff *pskb;\n\n\tring = &rtlpci->tx_ring[BEACON_QUEUE];\n\tpskb = __skb_dequeue(&ring->queue);\n\tkfree_skb(pskb);\n\tspin_lock_irqsave(&rtlpriv->locks.irq_th_lock, flags);\n\tpdesc = &ring->desc[idx];\n\t \n\trtlpriv->cfg->ops->get_desc(hw, (u8 *)pdesc, true, HW_DESC_OWN);\n\trtlpriv->cfg->ops->fill_tx_cmddesc(hw, (u8 *) pdesc, 1, 1, skb);\n\t__skb_queue_tail(&ring->queue, skb);\n\tspin_unlock_irqrestore(&rtlpriv->locks.irq_th_lock, flags);\n\trtlpriv->cfg->ops->tx_polling(hw, BEACON_QUEUE);\n\treturn true;\n}\n\n#define BEACON_PG\t\t0\t \n#define PSPOLL_PG\t\t2\n#define NULL_PG\t\t\t3\n#define PROBERSP_PG\t\t4\t \n#define TOTAL_RESERVED_PKT_LEN\t768\n\nstatic u8 reserved_page_packet[TOTAL_RESERVED_PKT_LEN] = {\n\t \n\t0x80, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,\n\t0xFF, 0xFF, 0x00, 0xE0, 0x4C, 0x76, 0x00, 0x42,\n\t0x00, 0x40, 0x10, 0x10, 0x00, 0x03, 0x50, 0x08,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x64, 0x00, 0x00, 0x04, 0x00, 0x0C, 0x6C, 0x69,\n\t0x6E, 0x6B, 0x73, 0x79, 0x73, 0x5F, 0x77, 0x6C,\n\t0x61, 0x6E, 0x01, 0x04, 0x82, 0x84, 0x8B, 0x96,\n\t0x03, 0x01, 0x01, 0x06, 0x02, 0x00, 0x00, 0x2A,\n\t0x01, 0x00, 0x32, 0x08, 0x24, 0x30, 0x48, 0x6C,\n\t0x0C, 0x12, 0x18, 0x60, 0x2D, 0x1A, 0x6C, 0x18,\n\t0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x3D, 0x00, 0xDD, 0x06, 0x00, 0xE0, 0x4C, 0x02,\n\t0x01, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\n\t \n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x10, 0x00, 0x20, 0x8C, 0x00, 0x12, 0x10, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\n\t \n\t0xA4, 0x10, 0x01, 0xC0, 0x00, 0x40, 0x10, 0x10,\n\t0x00, 0x03, 0x00, 0xE0, 0x4C, 0x76, 0x00, 0x42,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x18, 0x00, 0x20, 0x8C, 0x00, 0x12, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,\n\t0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\n\t \n\t0x48, 0x01, 0x00, 0x00, 0x00, 0x40, 0x10, 0x10,\n\t0x00, 0x03, 0x00, 0xE0, 0x4C, 0x76, 0x00, 0x42,\n\t0x00, 0x40, 0x10, 0x10, 0x00, 0x03, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x72, 0x00, 0x20, 0x8C, 0x00, 0x12, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,\n\t0x80, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\n\t \n\t0x50, 0x00, 0x00, 0x00, 0x00, 0x40, 0x10, 0x10,\n\t0x00, 0x03, 0x00, 0xE0, 0x4C, 0x76, 0x00, 0x42,\n\t0x00, 0x40, 0x10, 0x10, 0x00, 0x03, 0x00, 0x00,\n\t0x9E, 0x46, 0x15, 0x32, 0x27, 0xF2, 0x2D, 0x00,\n\t0x64, 0x00, 0x00, 0x04, 0x00, 0x0C, 0x6C, 0x69,\n\t0x6E, 0x6B, 0x73, 0x79, 0x73, 0x5F, 0x77, 0x6C,\n\t0x61, 0x6E, 0x01, 0x04, 0x82, 0x84, 0x8B, 0x96,\n\t0x03, 0x01, 0x01, 0x06, 0x02, 0x00, 0x00, 0x2A,\n\t0x01, 0x00, 0x32, 0x08, 0x24, 0x30, 0x48, 0x6C,\n\t0x0C, 0x12, 0x18, 0x60, 0x2D, 0x1A, 0x6C, 0x18,\n\t0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x3D, 0x00, 0xDD, 0x06, 0x00, 0xE0, 0x4C, 0x02,\n\t0x01, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\n\t \n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n};\n\nvoid rtl92d_set_fw_rsvdpagepkt(struct ieee80211_hw *hw, bool dl_finished)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct sk_buff *skb = NULL;\n\tu32 totalpacketlen;\n\tbool rtstatus;\n\tu8 u1rsvdpageloc[3] = { 0 };\n\tbool dlok = false;\n\tu8 *beacon;\n\tu8 *p_pspoll;\n\tu8 *nullfunc;\n\tu8 *p_probersp;\n\t \n\tbeacon = &reserved_page_packet[BEACON_PG * 128];\n\tSET_80211_HDR_ADDRESS2(beacon, mac->mac_addr);\n\tSET_80211_HDR_ADDRESS3(beacon, mac->bssid);\n\t \n\tp_pspoll = &reserved_page_packet[PSPOLL_PG * 128];\n\tSET_80211_PS_POLL_AID(p_pspoll, (mac->assoc_id | 0xc000));\n\tSET_80211_PS_POLL_BSSID(p_pspoll, mac->bssid);\n\tSET_80211_PS_POLL_TA(p_pspoll, mac->mac_addr);\n\tSET_H2CCMD_RSVDPAGE_LOC_PSPOLL(u1rsvdpageloc, PSPOLL_PG);\n\t \n\tnullfunc = &reserved_page_packet[NULL_PG * 128];\n\tSET_80211_HDR_ADDRESS1(nullfunc, mac->bssid);\n\tSET_80211_HDR_ADDRESS2(nullfunc, mac->mac_addr);\n\tSET_80211_HDR_ADDRESS3(nullfunc, mac->bssid);\n\tSET_H2CCMD_RSVDPAGE_LOC_NULL_DATA(u1rsvdpageloc, NULL_PG);\n\t \n\tp_probersp = &reserved_page_packet[PROBERSP_PG * 128];\n\tSET_80211_HDR_ADDRESS1(p_probersp, mac->bssid);\n\tSET_80211_HDR_ADDRESS2(p_probersp, mac->mac_addr);\n\tSET_80211_HDR_ADDRESS3(p_probersp, mac->bssid);\n\tSET_H2CCMD_RSVDPAGE_LOC_PROBE_RSP(u1rsvdpageloc, PROBERSP_PG);\n\ttotalpacketlen = TOTAL_RESERVED_PKT_LEN;\n\tRT_PRINT_DATA(rtlpriv, COMP_CMD, DBG_LOUD,\n\t\t      \"rtl92d_set_fw_rsvdpagepkt(): HW_VAR_SET_TX_CMD: ALL\",\n\t\t      &reserved_page_packet[0], totalpacketlen);\n\tRT_PRINT_DATA(rtlpriv, COMP_CMD, DBG_DMESG,\n\t\t      \"rtl92d_set_fw_rsvdpagepkt(): HW_VAR_SET_TX_CMD: ALL\",\n\t\t      u1rsvdpageloc, 3);\n\tskb = dev_alloc_skb(totalpacketlen);\n\tif (!skb) {\n\t\tdlok = false;\n\t} else {\n\t\tskb_put_data(skb, &reserved_page_packet, totalpacketlen);\n\t\trtstatus = _rtl92d_cmd_send_packet(hw, skb);\n\n\t\tif (rtstatus)\n\t\t\tdlok = true;\n\t}\n\tif (dlok) {\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD,\n\t\t\t\"Set RSVD page location to Fw\\n\");\n\t\tRT_PRINT_DATA(rtlpriv, COMP_CMD, DBG_DMESG,\n\t\t\t      \"H2C_RSVDPAGE\", u1rsvdpageloc, 3);\n\t\trtl92d_fill_h2c_cmd(hw, H2C_RSVDPAGE,\n\t\t\tsizeof(u1rsvdpageloc), u1rsvdpageloc);\n\t} else\n\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_WARNING,\n\t\t\t\"Set RSVD page location to Fw FAIL!!!!!!\\n\");\n}\n\nvoid rtl92d_set_fw_joinbss_report_cmd(struct ieee80211_hw *hw, u8 mstatus)\n{\n\tu8 u1_joinbssrpt_parm[1] = {0};\n\n\tSET_H2CCMD_JOINBSSRPT_PARM_OPMODE(u1_joinbssrpt_parm, mstatus);\n\trtl92d_fill_h2c_cmd(hw, H2C_JOINBSSRPT, 1, u1_joinbssrpt_parm);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}