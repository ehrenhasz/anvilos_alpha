{
  "module_name": "phy_common.c",
  "hash_id": "87ab9389c68323447cd6e3c5a0a8f0122adf945954853c6f8ba3e2391e33f0db",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtlwifi/rtl8723com/phy_common.c",
  "human_readable_source": "\n \n\n#include \"../wifi.h\"\n#include \"phy_common.h\"\n#include \"../rtl8723ae/reg.h\"\n#include <linux/module.h>\n\n \n\nu32 rtl8723_phy_query_bb_reg(struct ieee80211_hw *hw,\n\t\t\t     u32 regaddr, u32 bitmask)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 returnvalue, originalvalue, bitshift;\n\n\trtl_dbg(rtlpriv, COMP_RF, DBG_TRACE,\n\t\t\"regaddr(%#x), bitmask(%#x)\\n\", regaddr, bitmask);\n\toriginalvalue = rtl_read_dword(rtlpriv, regaddr);\n\tbitshift = rtl8723_phy_calculate_bit_shift(bitmask);\n\treturnvalue = (originalvalue & bitmask) >> bitshift;\n\n\trtl_dbg(rtlpriv, COMP_RF, DBG_TRACE,\n\t\t\"BBR MASK=0x%x Addr[0x%x]=0x%x\\n\", bitmask,\n\t\tregaddr, originalvalue);\n\treturn returnvalue;\n}\nEXPORT_SYMBOL_GPL(rtl8723_phy_query_bb_reg);\n\nvoid rtl8723_phy_set_bb_reg(struct ieee80211_hw *hw, u32 regaddr,\n\t\t\t      u32 bitmask, u32 data)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 originalvalue, bitshift;\n\n\trtl_dbg(rtlpriv, COMP_RF, DBG_TRACE,\n\t\t\"regaddr(%#x), bitmask(%#x), data(%#x)\\n\", regaddr, bitmask,\n\t\tdata);\n\n\tif (bitmask != MASKDWORD) {\n\t\toriginalvalue = rtl_read_dword(rtlpriv, regaddr);\n\t\tbitshift = rtl8723_phy_calculate_bit_shift(bitmask);\n\t\tdata = ((originalvalue & (~bitmask)) | (data << bitshift));\n\t}\n\n\trtl_write_dword(rtlpriv, regaddr, data);\n\n\trtl_dbg(rtlpriv, COMP_RF, DBG_TRACE,\n\t\t\"regaddr(%#x), bitmask(%#x), data(%#x)\\n\",\n\t\tregaddr, bitmask, data);\n}\nEXPORT_SYMBOL_GPL(rtl8723_phy_set_bb_reg);\n\nu32 rtl8723_phy_calculate_bit_shift(u32 bitmask)\n{\n\tu32 i = ffs(bitmask);\n\n\treturn i ? i - 1 : 32;\n}\nEXPORT_SYMBOL_GPL(rtl8723_phy_calculate_bit_shift);\n\nu32 rtl8723_phy_rf_serial_read(struct ieee80211_hw *hw,\n\t\t\t       enum radio_path rfpath, u32 offset)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct bb_reg_def *pphyreg = &rtlphy->phyreg_def[rfpath];\n\tu32 newoffset;\n\tu32 tmplong, tmplong2;\n\tu8 rfpi_enable = 0;\n\tu32 retvalue;\n\n\toffset &= 0xff;\n\tnewoffset = offset;\n\tif (RT_CANNOT_IO(hw)) {\n\t\tpr_err(\"return all one\\n\");\n\t\treturn 0xFFFFFFFF;\n\t}\n\ttmplong = rtl_get_bbreg(hw, RFPGA0_XA_HSSIPARAMETER2, MASKDWORD);\n\tif (rfpath == RF90_PATH_A)\n\t\ttmplong2 = tmplong;\n\telse\n\t\ttmplong2 = rtl_get_bbreg(hw, pphyreg->rfhssi_para2, MASKDWORD);\n\ttmplong2 = (tmplong2 & (~BLSSIREADADDRESS)) |\n\t    (newoffset << 23) | BLSSIREADEDGE;\n\trtl_set_bbreg(hw, RFPGA0_XA_HSSIPARAMETER2, MASKDWORD,\n\t\t      tmplong & (~BLSSIREADEDGE));\n\trtl_set_bbreg(hw, pphyreg->rfhssi_para2, MASKDWORD, tmplong2);\n\trtl_set_bbreg(hw, RFPGA0_XA_HSSIPARAMETER2, MASKDWORD,\n\t\t      tmplong | BLSSIREADEDGE);\n\tudelay(120);\n\tif (rfpath == RF90_PATH_A)\n\t\trfpi_enable = (u8) rtl_get_bbreg(hw, RFPGA0_XA_HSSIPARAMETER1,\n\t\t\t\t\t\t BIT(8));\n\telse if (rfpath == RF90_PATH_B)\n\t\trfpi_enable = (u8) rtl_get_bbreg(hw, RFPGA0_XB_HSSIPARAMETER1,\n\t\t\t\t\t\t BIT(8));\n\tif (rfpi_enable)\n\t\tretvalue = rtl_get_bbreg(hw, pphyreg->rf_rbpi,\n\t\t\t\t\t BLSSIREADBACKDATA);\n\telse\n\t\tretvalue = rtl_get_bbreg(hw, pphyreg->rf_rb,\n\t\t\t\t\t BLSSIREADBACKDATA);\n\trtl_dbg(rtlpriv, COMP_RF, DBG_TRACE,\n\t\t\"RFR-%d Addr[0x%x]=0x%x\\n\",\n\t\trfpath, pphyreg->rf_rb, retvalue);\n\treturn retvalue;\n}\nEXPORT_SYMBOL_GPL(rtl8723_phy_rf_serial_read);\n\nvoid rtl8723_phy_rf_serial_write(struct ieee80211_hw *hw,\n\t\t\t\t enum radio_path rfpath,\n\t\t\t\t u32 offset, u32 data)\n{\n\tu32 data_and_addr;\n\tu32 newoffset;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct bb_reg_def *pphyreg = &rtlphy->phyreg_def[rfpath];\n\n\tif (RT_CANNOT_IO(hw)) {\n\t\tpr_err(\"stop\\n\");\n\t\treturn;\n\t}\n\toffset &= 0xff;\n\tnewoffset = offset;\n\tdata_and_addr = ((newoffset << 20) | (data & 0x000fffff)) & 0x0fffffff;\n\trtl_set_bbreg(hw, pphyreg->rf3wire_offset, MASKDWORD, data_and_addr);\n\trtl_dbg(rtlpriv, COMP_RF, DBG_TRACE,\n\t\t\"RFW-%d Addr[0x%x]=0x%x\\n\",\n\t\trfpath, pphyreg->rf3wire_offset,\n\t\tdata_and_addr);\n}\nEXPORT_SYMBOL_GPL(rtl8723_phy_rf_serial_write);\n\nlong rtl8723_phy_txpwr_idx_to_dbm(struct ieee80211_hw *hw,\n\t\t\t\t  enum wireless_mode wirelessmode,\n\t\t\t\t  u8 txpwridx)\n{\n\tlong offset;\n\tlong pwrout_dbm;\n\n\tswitch (wirelessmode) {\n\tcase WIRELESS_MODE_B:\n\t\toffset = -7;\n\t\tbreak;\n\tcase WIRELESS_MODE_G:\n\tcase WIRELESS_MODE_N_24G:\n\t\toffset = -8;\n\t\tbreak;\n\tdefault:\n\t\toffset = -8;\n\t\tbreak;\n\t}\n\tpwrout_dbm = txpwridx / 2 + offset;\n\treturn pwrout_dbm;\n}\nEXPORT_SYMBOL_GPL(rtl8723_phy_txpwr_idx_to_dbm);\n\nvoid rtl8723_phy_init_bb_rf_reg_def(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\n\trtlphy->phyreg_def[RF90_PATH_A].rfintfs = RFPGA0_XAB_RFINTERFACESW;\n\trtlphy->phyreg_def[RF90_PATH_B].rfintfs = RFPGA0_XAB_RFINTERFACESW;\n\trtlphy->phyreg_def[RF90_PATH_C].rfintfs = RFPGA0_XCD_RFINTERFACESW;\n\trtlphy->phyreg_def[RF90_PATH_D].rfintfs = RFPGA0_XCD_RFINTERFACESW;\n\n\trtlphy->phyreg_def[RF90_PATH_A].rfintfi = RFPGA0_XAB_RFINTERFACERB;\n\trtlphy->phyreg_def[RF90_PATH_B].rfintfi = RFPGA0_XAB_RFINTERFACERB;\n\trtlphy->phyreg_def[RF90_PATH_C].rfintfi = RFPGA0_XCD_RFINTERFACERB;\n\trtlphy->phyreg_def[RF90_PATH_D].rfintfi = RFPGA0_XCD_RFINTERFACERB;\n\n\trtlphy->phyreg_def[RF90_PATH_A].rfintfo = RFPGA0_XA_RFINTERFACEOE;\n\trtlphy->phyreg_def[RF90_PATH_B].rfintfo = RFPGA0_XB_RFINTERFACEOE;\n\n\trtlphy->phyreg_def[RF90_PATH_A].rfintfe = RFPGA0_XA_RFINTERFACEOE;\n\trtlphy->phyreg_def[RF90_PATH_B].rfintfe = RFPGA0_XB_RFINTERFACEOE;\n\n\trtlphy->phyreg_def[RF90_PATH_A].rf3wire_offset =\n\t    RFPGA0_XA_LSSIPARAMETER;\n\trtlphy->phyreg_def[RF90_PATH_B].rf3wire_offset =\n\t    RFPGA0_XB_LSSIPARAMETER;\n\n\trtlphy->phyreg_def[RF90_PATH_A].rflssi_select = RFPGA0_XAB_RFPARAMETER;\n\trtlphy->phyreg_def[RF90_PATH_B].rflssi_select = RFPGA0_XAB_RFPARAMETER;\n\trtlphy->phyreg_def[RF90_PATH_C].rflssi_select = RFPGA0_XCD_RFPARAMETER;\n\trtlphy->phyreg_def[RF90_PATH_D].rflssi_select = RFPGA0_XCD_RFPARAMETER;\n\n\trtlphy->phyreg_def[RF90_PATH_A].rftxgain_stage = RFPGA0_TXGAINSTAGE;\n\trtlphy->phyreg_def[RF90_PATH_B].rftxgain_stage = RFPGA0_TXGAINSTAGE;\n\trtlphy->phyreg_def[RF90_PATH_C].rftxgain_stage = RFPGA0_TXGAINSTAGE;\n\trtlphy->phyreg_def[RF90_PATH_D].rftxgain_stage = RFPGA0_TXGAINSTAGE;\n\n\trtlphy->phyreg_def[RF90_PATH_A].rfhssi_para1 = RFPGA0_XA_HSSIPARAMETER1;\n\trtlphy->phyreg_def[RF90_PATH_B].rfhssi_para1 = RFPGA0_XB_HSSIPARAMETER1;\n\n\trtlphy->phyreg_def[RF90_PATH_A].rfhssi_para2 = RFPGA0_XA_HSSIPARAMETER2;\n\trtlphy->phyreg_def[RF90_PATH_B].rfhssi_para2 = RFPGA0_XB_HSSIPARAMETER2;\n\n\trtlphy->phyreg_def[RF90_PATH_A].rfsw_ctrl = RFPGA0_XAB_SWITCHCONTROL;\n\trtlphy->phyreg_def[RF90_PATH_B].rfsw_ctrl = RFPGA0_XAB_SWITCHCONTROL;\n\trtlphy->phyreg_def[RF90_PATH_C].rfsw_ctrl = RFPGA0_XCD_SWITCHCONTROL;\n\trtlphy->phyreg_def[RF90_PATH_D].rfsw_ctrl = RFPGA0_XCD_SWITCHCONTROL;\n\n\trtlphy->phyreg_def[RF90_PATH_A].rfagc_control1 = ROFDM0_XAAGCCORE1;\n\trtlphy->phyreg_def[RF90_PATH_B].rfagc_control1 = ROFDM0_XBAGCCORE1;\n\trtlphy->phyreg_def[RF90_PATH_C].rfagc_control1 = ROFDM0_XCAGCCORE1;\n\trtlphy->phyreg_def[RF90_PATH_D].rfagc_control1 = ROFDM0_XDAGCCORE1;\n\n\trtlphy->phyreg_def[RF90_PATH_A].rfagc_control2 = ROFDM0_XAAGCCORE2;\n\trtlphy->phyreg_def[RF90_PATH_B].rfagc_control2 = ROFDM0_XBAGCCORE2;\n\trtlphy->phyreg_def[RF90_PATH_C].rfagc_control2 = ROFDM0_XCAGCCORE2;\n\trtlphy->phyreg_def[RF90_PATH_D].rfagc_control2 = ROFDM0_XDAGCCORE2;\n\n\trtlphy->phyreg_def[RF90_PATH_A].rfrxiq_imbal = ROFDM0_XARXIQIMBALANCE;\n\trtlphy->phyreg_def[RF90_PATH_B].rfrxiq_imbal = ROFDM0_XBRXIQIMBALANCE;\n\trtlphy->phyreg_def[RF90_PATH_C].rfrxiq_imbal = ROFDM0_XCRXIQIMBANLANCE;\n\trtlphy->phyreg_def[RF90_PATH_D].rfrxiq_imbal = ROFDM0_XDRXIQIMBALANCE;\n\n\trtlphy->phyreg_def[RF90_PATH_A].rfrx_afe = ROFDM0_XARXAFE;\n\trtlphy->phyreg_def[RF90_PATH_B].rfrx_afe = ROFDM0_XBRXAFE;\n\trtlphy->phyreg_def[RF90_PATH_C].rfrx_afe = ROFDM0_XCRXAFE;\n\trtlphy->phyreg_def[RF90_PATH_D].rfrx_afe = ROFDM0_XDRXAFE;\n\n\trtlphy->phyreg_def[RF90_PATH_A].rftxiq_imbal = ROFDM0_XATXIQIMBALANCE;\n\trtlphy->phyreg_def[RF90_PATH_B].rftxiq_imbal = ROFDM0_XBTXIQIMBALANCE;\n\trtlphy->phyreg_def[RF90_PATH_C].rftxiq_imbal = ROFDM0_XCTXIQIMBALANCE;\n\trtlphy->phyreg_def[RF90_PATH_D].rftxiq_imbal = ROFDM0_XDTXIQIMBALANCE;\n\n\trtlphy->phyreg_def[RF90_PATH_A].rftx_afe = ROFDM0_XATXAFE;\n\trtlphy->phyreg_def[RF90_PATH_B].rftx_afe = ROFDM0_XBTXAFE;\n\trtlphy->phyreg_def[RF90_PATH_C].rftx_afe = ROFDM0_XCTXAFE;\n\trtlphy->phyreg_def[RF90_PATH_D].rftx_afe = ROFDM0_XDTXAFE;\n\n\trtlphy->phyreg_def[RF90_PATH_A].rf_rb = RFPGA0_XA_LSSIREADBACK;\n\trtlphy->phyreg_def[RF90_PATH_B].rf_rb = RFPGA0_XB_LSSIREADBACK;\n\trtlphy->phyreg_def[RF90_PATH_C].rf_rb = RFPGA0_XC_LSSIREADBACK;\n\trtlphy->phyreg_def[RF90_PATH_D].rf_rb = RFPGA0_XD_LSSIREADBACK;\n\n\trtlphy->phyreg_def[RF90_PATH_A].rf_rbpi = TRANSCEIVEA_HSPI_READBACK;\n\trtlphy->phyreg_def[RF90_PATH_B].rf_rbpi = TRANSCEIVEB_HSPI_READBACK;\n\n}\nEXPORT_SYMBOL_GPL(rtl8723_phy_init_bb_rf_reg_def);\n\nbool rtl8723_phy_set_sw_chnl_cmdarray(struct swchnlcmd *cmdtable,\n\t\t\t\t      u32 cmdtableidx,\n\t\t\t\t      u32 cmdtablesz,\n\t\t\t\t      enum swchnlcmd_id cmdid,\n\t\t\t\t      u32 para1, u32 para2,\n\t\t\t\t      u32 msdelay)\n{\n\tstruct swchnlcmd *pcmd;\n\n\tif (cmdtable == NULL) {\n\t\tWARN_ONCE(true, \"rtl8723-common: cmdtable cannot be NULL.\\n\");\n\t\treturn false;\n\t}\n\n\tif (cmdtableidx >= cmdtablesz)\n\t\treturn false;\n\n\tpcmd = cmdtable + cmdtableidx;\n\tpcmd->cmdid = cmdid;\n\tpcmd->para1 = para1;\n\tpcmd->para2 = para2;\n\tpcmd->msdelay = msdelay;\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(rtl8723_phy_set_sw_chnl_cmdarray);\n\nvoid rtl8723_phy_path_a_fill_iqk_matrix(struct ieee80211_hw *hw,\n\t\t\t\t\tbool iqk_ok,\n\t\t\t\t\tlong result[][8],\n\t\t\t\t\tu8 final_candidate,\n\t\t\t\t\tbool btxonly)\n{\n\tu32 oldval_0, x, tx0_a, reg;\n\tlong y, tx0_c;\n\n\tif (final_candidate == 0xFF) {\n\t\treturn;\n\t} else if (iqk_ok) {\n\t\toldval_0 = (rtl_get_bbreg(hw, ROFDM0_XATXIQIMBALANCE,\n\t\t\t\t\t  MASKDWORD) >> 22) & 0x3FF;\n\t\tx = result[final_candidate][0];\n\t\tif ((x & 0x00000200) != 0)\n\t\t\tx = x | 0xFFFFFC00;\n\t\ttx0_a = (x * oldval_0) >> 8;\n\t\trtl_set_bbreg(hw, ROFDM0_XATXIQIMBALANCE, 0x3FF, tx0_a);\n\t\trtl_set_bbreg(hw, ROFDM0_ECCATHRESHOLD, BIT(31),\n\t\t\t      ((x * oldval_0 >> 7) & 0x1));\n\t\ty = result[final_candidate][1];\n\t\tif ((y & 0x00000200) != 0)\n\t\t\ty = y | 0xFFFFFC00;\n\t\ttx0_c = (y * oldval_0) >> 8;\n\t\trtl_set_bbreg(hw, ROFDM0_XCTXAFE, 0xF0000000,\n\t\t\t      ((tx0_c & 0x3C0) >> 6));\n\t\trtl_set_bbreg(hw, ROFDM0_XATXIQIMBALANCE, 0x003F0000,\n\t\t\t      (tx0_c & 0x3F));\n\t\trtl_set_bbreg(hw, ROFDM0_ECCATHRESHOLD, BIT(29),\n\t\t\t      ((y * oldval_0 >> 7) & 0x1));\n\t\tif (btxonly)\n\t\t\treturn;\n\t\treg = result[final_candidate][2];\n\t\trtl_set_bbreg(hw, ROFDM0_XARXIQIMBALANCE, 0x3FF, reg);\n\t\treg = result[final_candidate][3] & 0x3F;\n\t\trtl_set_bbreg(hw, ROFDM0_XARXIQIMBALANCE, 0xFC00, reg);\n\t\treg = (result[final_candidate][3] >> 6) & 0xF;\n\t\trtl_set_bbreg(hw, 0xca0, 0xF0000000, reg);\n\t}\n}\nEXPORT_SYMBOL_GPL(rtl8723_phy_path_a_fill_iqk_matrix);\n\nvoid rtl8723_save_adda_registers(struct ieee80211_hw *hw, u32 *addareg,\n\t\t\t\t u32 *addabackup, u32 registernum)\n{\n\tu32 i;\n\n\tfor (i = 0; i < registernum; i++)\n\t\taddabackup[i] = rtl_get_bbreg(hw, addareg[i], MASKDWORD);\n}\nEXPORT_SYMBOL_GPL(rtl8723_save_adda_registers);\n\nvoid rtl8723_phy_save_mac_registers(struct ieee80211_hw *hw,\n\t\t\t\t    u32 *macreg, u32 *macbackup)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 i;\n\n\tfor (i = 0; i < (IQK_MAC_REG_NUM - 1); i++)\n\t\tmacbackup[i] = rtl_read_byte(rtlpriv, macreg[i]);\n\tmacbackup[i] = rtl_read_dword(rtlpriv, macreg[i]);\n}\nEXPORT_SYMBOL_GPL(rtl8723_phy_save_mac_registers);\n\nvoid rtl8723_phy_reload_adda_registers(struct ieee80211_hw *hw,\n\t\t\t\t       u32 *addareg, u32 *addabackup,\n\t\t\t\t       u32 regiesternum)\n{\n\tu32 i;\n\n\tfor (i = 0; i < regiesternum; i++)\n\t\trtl_set_bbreg(hw, addareg[i], MASKDWORD, addabackup[i]);\n}\nEXPORT_SYMBOL_GPL(rtl8723_phy_reload_adda_registers);\n\nvoid rtl8723_phy_reload_mac_registers(struct ieee80211_hw *hw,\n\t\t\t\t      u32 *macreg, u32 *macbackup)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 i;\n\n\tfor (i = 0; i < (IQK_MAC_REG_NUM - 1); i++)\n\t\trtl_write_byte(rtlpriv, macreg[i], (u8) macbackup[i]);\n\trtl_write_dword(rtlpriv, macreg[i], macbackup[i]);\n}\nEXPORT_SYMBOL_GPL(rtl8723_phy_reload_mac_registers);\n\nvoid rtl8723_phy_path_adda_on(struct ieee80211_hw *hw, u32 *addareg,\n\t\t\t      bool is_patha_on, bool is2t)\n{\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tu32 pathon;\n\tu32 i;\n\n\tif (rtlhal->hw_type == HARDWARE_TYPE_RTL8723AE) {\n\t\tpathon = is_patha_on ? 0x04db25a4 : 0x0b1b25a4;\n\t\tif (!is2t) {\n\t\t\tpathon = 0x0bdb25a0;\n\t\t\trtl_set_bbreg(hw, addareg[0], MASKDWORD, 0x0b1b25a0);\n\t\t} else {\n\t\t\trtl_set_bbreg(hw, addareg[0], MASKDWORD, pathon);\n\t\t}\n\t} else {\n\t\t \n\t\tpathon = 0x01c00014;\n\t\trtl_set_bbreg(hw, addareg[0], MASKDWORD, pathon);\n\t}\n\n\tfor (i = 1; i < IQK_ADDA_REG_NUM; i++)\n\t\trtl_set_bbreg(hw, addareg[i], MASKDWORD, pathon);\n}\nEXPORT_SYMBOL_GPL(rtl8723_phy_path_adda_on);\n\nvoid rtl8723_phy_mac_setting_calibration(struct ieee80211_hw *hw,\n\t\t\t\t\t u32 *macreg, u32 *macbackup)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 i = 0;\n\n\trtl_write_byte(rtlpriv, macreg[i], 0x3F);\n\n\tfor (i = 1; i < (IQK_MAC_REG_NUM - 1); i++)\n\t\trtl_write_byte(rtlpriv, macreg[i],\n\t\t\t       (u8) (macbackup[i] & (~BIT(3))));\n\trtl_write_byte(rtlpriv, macreg[i], (u8) (macbackup[i] & (~BIT(5))));\n}\nEXPORT_SYMBOL_GPL(rtl8723_phy_mac_setting_calibration);\n\nvoid rtl8723_phy_path_a_standby(struct ieee80211_hw *hw)\n{\n\trtl_set_bbreg(hw, 0xe28, MASKDWORD, 0x0);\n\trtl_set_bbreg(hw, 0x840, MASKDWORD, 0x00010000);\n\trtl_set_bbreg(hw, 0xe28, MASKDWORD, 0x80800000);\n}\nEXPORT_SYMBOL_GPL(rtl8723_phy_path_a_standby);\n\nvoid rtl8723_phy_pi_mode_switch(struct ieee80211_hw *hw, bool pi_mode)\n{\n\tu32 mode;\n\n\tmode = pi_mode ? 0x01000100 : 0x01000000;\n\trtl_set_bbreg(hw, 0x820, MASKDWORD, mode);\n\trtl_set_bbreg(hw, 0x828, MASKDWORD, mode);\n}\nEXPORT_SYMBOL_GPL(rtl8723_phy_pi_mode_switch);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}