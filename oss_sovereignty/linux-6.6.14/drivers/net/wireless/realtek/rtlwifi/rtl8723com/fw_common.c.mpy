{
  "module_name": "fw_common.c",
  "hash_id": "09504a3c92a4c7fefaa2a97aa44ad2a1d752d3ade23936258efda4938de4beae",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtlwifi/rtl8723com/fw_common.c",
  "human_readable_source": "\n \n\n#include \"../wifi.h\"\n#include \"../pci.h\"\n#include \"../base.h\"\n#include \"../efuse.h\"\n#include \"fw_common.h\"\n#include <linux/module.h>\n\nvoid rtl8723_enable_fw_download(struct ieee80211_hw *hw, bool enable)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 tmp;\n\n\tif (enable) {\n\t\ttmp = rtl_read_byte(rtlpriv, REG_SYS_FUNC_EN + 1);\n\t\trtl_write_byte(rtlpriv, REG_SYS_FUNC_EN + 1,\n\t\t\t       tmp | 0x04);\n\n\t\ttmp = rtl_read_byte(rtlpriv, REG_MCUFWDL);\n\t\trtl_write_byte(rtlpriv, REG_MCUFWDL, tmp | 0x01);\n\n\t\ttmp = rtl_read_byte(rtlpriv, REG_MCUFWDL + 2);\n\t\trtl_write_byte(rtlpriv, REG_MCUFWDL + 2, tmp & 0xf7);\n\t} else {\n\t\ttmp = rtl_read_byte(rtlpriv, REG_MCUFWDL);\n\t\trtl_write_byte(rtlpriv, REG_MCUFWDL, tmp & 0xfe);\n\n\t\trtl_write_byte(rtlpriv, REG_MCUFWDL + 1, 0x00);\n\t}\n}\nEXPORT_SYMBOL_GPL(rtl8723_enable_fw_download);\n\nvoid rtl8723_write_fw(struct ieee80211_hw *hw,\n\t\t      enum version_8723e version,\n\t\t      u8 *buffer, u32 size, u8 max_page)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 *bufferptr = buffer;\n\tu32 page_nums, remain_size;\n\tu32 page, offset;\n\n\trtl_dbg(rtlpriv, COMP_FW, DBG_TRACE, \"FW size is %d bytes,\\n\", size);\n\n\trtl_fill_dummy(bufferptr, &size);\n\n\tpage_nums = size / FW_8192C_PAGE_SIZE;\n\tremain_size = size % FW_8192C_PAGE_SIZE;\n\n\tif (page_nums > max_page) {\n\t\tpr_err(\"Page numbers should not greater than %d\\n\",\n\t\t       max_page);\n\t}\n\tfor (page = 0; page < page_nums; page++) {\n\t\toffset = page * FW_8192C_PAGE_SIZE;\n\t\trtl_fw_page_write(hw, page, (bufferptr + offset),\n\t\t\t\t  FW_8192C_PAGE_SIZE);\n\t}\n\n\tif (remain_size) {\n\t\toffset = page_nums * FW_8192C_PAGE_SIZE;\n\t\tpage = page_nums;\n\t\trtl_fw_page_write(hw, page, (bufferptr + offset), remain_size);\n\t}\n\trtl_dbg(rtlpriv, COMP_FW, DBG_TRACE, \"FW write done.\\n\");\n}\nEXPORT_SYMBOL_GPL(rtl8723_write_fw);\n\nvoid rtl8723ae_firmware_selfreset(struct ieee80211_hw *hw)\n{\n\tu8 u1b_tmp;\n\tu8 delay = 100;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtl_write_byte(rtlpriv, REG_HMETFR + 3, 0x20);\n\tu1b_tmp = rtl_read_byte(rtlpriv, REG_SYS_FUNC_EN + 1);\n\n\twhile (u1b_tmp & BIT(2)) {\n\t\tdelay--;\n\t\tif (delay == 0)\n\t\t\tbreak;\n\t\tudelay(50);\n\t\tu1b_tmp = rtl_read_byte(rtlpriv, REG_SYS_FUNC_EN + 1);\n\t}\n\tif (delay == 0) {\n\t\tu1b_tmp = rtl_read_byte(rtlpriv, REG_SYS_FUNC_EN + 1);\n\t\trtl_write_byte(rtlpriv, REG_SYS_FUNC_EN + 1,\n\t\t\t       u1b_tmp&(~BIT(2)));\n\t}\n}\nEXPORT_SYMBOL_GPL(rtl8723ae_firmware_selfreset);\n\nvoid rtl8723be_firmware_selfreset(struct ieee80211_hw *hw)\n{\n\tu8 u1b_tmp;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\tu1b_tmp = rtl_read_byte(rtlpriv, REG_RSV_CTRL + 1);\n\trtl_write_byte(rtlpriv, REG_RSV_CTRL + 1, (u1b_tmp & (~BIT(0))));\n\n\tu1b_tmp = rtl_read_byte(rtlpriv, REG_SYS_FUNC_EN + 1);\n\trtl_write_byte(rtlpriv, REG_SYS_FUNC_EN + 1, (u1b_tmp & (~BIT(2))));\n\tudelay(50);\n\n\tu1b_tmp = rtl_read_byte(rtlpriv, REG_RSV_CTRL + 1);\n\trtl_write_byte(rtlpriv, REG_RSV_CTRL + 1, (u1b_tmp | BIT(0)));\n\n\tu1b_tmp = rtl_read_byte(rtlpriv, REG_SYS_FUNC_EN + 1);\n\trtl_write_byte(rtlpriv, REG_SYS_FUNC_EN + 1, (u1b_tmp | BIT(2)));\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\"_8051Reset8723be(): 8051 reset success .\\n\");\n}\nEXPORT_SYMBOL_GPL(rtl8723be_firmware_selfreset);\n\nint rtl8723_fw_free_to_go(struct ieee80211_hw *hw, bool is_8723be,\n\t\t\t  int max_count)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tint err = -EIO;\n\tu32 counter = 0;\n\tu32 value32;\n\n\tdo {\n\t\tvalue32 = rtl_read_dword(rtlpriv, REG_MCUFWDL);\n\t} while ((counter++ < max_count) &&\n\t\t (!(value32 & FWDL_CHKSUM_RPT)));\n\n\tif (counter >= max_count) {\n\t\tpr_err(\"chksum report fail ! REG_MCUFWDL:0x%08x .\\n\",\n\t\t       value32);\n\t\tgoto exit;\n\t}\n\tvalue32 = rtl_read_dword(rtlpriv, REG_MCUFWDL) | MCUFWDL_RDY;\n\tvalue32 &= ~WINTINI_RDY;\n\trtl_write_dword(rtlpriv, REG_MCUFWDL, value32);\n\n\tif (is_8723be)\n\t\trtl8723be_firmware_selfreset(hw);\n\tcounter = 0;\n\n\tdo {\n\t\tvalue32 = rtl_read_dword(rtlpriv, REG_MCUFWDL);\n\t\tif (value32 & WINTINI_RDY) {\n\t\t\trtl_dbg(rtlpriv, COMP_FW, DBG_TRACE,\n\t\t\t\t\"Polling FW ready success!! REG_MCUFWDL:0x%08x .\\n\",\n\t\t\t\tvalue32);\n\t\t\terr = 0;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tmdelay(FW_8192C_POLLING_DELAY);\n\n\t} while (counter++ < max_count);\n\n\tpr_err(\"Polling FW ready fail!! REG_MCUFWDL:0x%08x .\\n\",\n\t       value32);\n\nexit:\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(rtl8723_fw_free_to_go);\n\nint rtl8723_download_fw(struct ieee80211_hw *hw,\n\t\t\tbool is_8723be, int max_count)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtlwifi_firmware_header *pfwheader;\n\tu8 *pfwdata;\n\tu32 fwsize;\n\tint err;\n\tenum version_8723e version = rtlhal->version;\n\tint max_page;\n\n\tif (rtlpriv->max_fw_size == 0 || !rtlhal->pfirmware)\n\t\treturn 1;\n\n\tpfwheader = (struct rtlwifi_firmware_header *)rtlhal->pfirmware;\n\trtlhal->fw_version = le16_to_cpu(pfwheader->version);\n\trtlhal->fw_subversion = pfwheader->subversion;\n\tpfwdata = rtlhal->pfirmware;\n\tfwsize = rtlhal->fwsize;\n\n\tif (!is_8723be)\n\t\tmax_page = 6;\n\telse\n\t\tmax_page = 8;\n\tif (rtlpriv->cfg->ops->is_fw_header(pfwheader)) {\n\t\trtl_dbg(rtlpriv, COMP_FW, DBG_LOUD,\n\t\t\t\"Firmware Version(%d), Signature(%#x), Size(%d)\\n\",\n\t\t\tpfwheader->version, pfwheader->signature,\n\t\t\t(int)sizeof(struct rtlwifi_firmware_header));\n\n\t\tpfwdata = pfwdata + sizeof(struct rtlwifi_firmware_header);\n\t\tfwsize = fwsize - sizeof(struct rtlwifi_firmware_header);\n\t}\n\n\tif (rtl_read_byte(rtlpriv, REG_MCUFWDL)&BIT(7)) {\n\t\tif (is_8723be)\n\t\t\trtl8723be_firmware_selfreset(hw);\n\t\telse\n\t\t\trtl8723ae_firmware_selfreset(hw);\n\t\trtl_write_byte(rtlpriv, REG_MCUFWDL, 0x00);\n\t}\n\trtl8723_enable_fw_download(hw, true);\n\trtl8723_write_fw(hw, version, pfwdata, fwsize, max_page);\n\trtl8723_enable_fw_download(hw, false);\n\n\terr = rtl8723_fw_free_to_go(hw, is_8723be, max_count);\n\tif (err)\n\t\tpr_err(\"Firmware is not ready to run!\\n\");\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rtl8723_download_fw);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}