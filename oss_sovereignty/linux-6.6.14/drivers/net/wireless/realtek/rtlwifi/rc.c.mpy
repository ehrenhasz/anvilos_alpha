{
  "module_name": "rc.c",
  "hash_id": "e21b803c8c01f6199a7b2e56f6a5973604cf8b8d49a4d911b75155212eafce68",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtlwifi/rc.c",
  "human_readable_source": "\n \n\n#include \"wifi.h\"\n#include \"base.h\"\n#include \"rc.h\"\n\n \nstatic u8 _rtl_rc_get_highest_rix(struct rtl_priv *rtlpriv,\n\t\t\t\t  struct ieee80211_sta *sta,\n\t\t\t\t  struct sk_buff *skb, bool not_data)\n{\n\tstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct rtl_sta_info *sta_entry = NULL;\n\tu16 wireless_mode = 0;\n\tu8 nss;\n\tstruct ieee80211_tx_rate rate;\n\n\tswitch (get_rf_type(rtlphy)) {\n\tcase RF_4T4R:\n\t\tnss = 4;\n\t\tbreak;\n\tcase RF_3T3R:\n\t\tnss = 3;\n\t\tbreak;\n\tcase RF_2T2R:\n\t\tnss = 2;\n\t\tbreak;\n\tdefault:\n\t\tnss = 1;\n\t\tbreak;\n\t}\n\n\t \n\n\tif (sta) {\n\t\tsta_entry = (struct rtl_sta_info *)sta->drv_priv;\n\t\twireless_mode = sta_entry->wireless_mode;\n\t}\n\n\tif (rtl_is_special_data(rtlpriv->mac80211.hw, skb, true, false) ||\n\t    not_data) {\n\t\treturn 0;\n\t} else {\n\t\tif (rtlhal->current_bandtype == BAND_ON_2_4G) {\n\t\t\tif (wireless_mode == WIRELESS_MODE_B) {\n\t\t\t\treturn B_MODE_MAX_RIX;\n\t\t\t} else if (wireless_mode == WIRELESS_MODE_G) {\n\t\t\t\treturn G_MODE_MAX_RIX;\n\t\t\t} else if (wireless_mode == WIRELESS_MODE_N_24G) {\n\t\t\t\tif (nss == 1)\n\t\t\t\t\treturn N_MODE_MCS7_RIX;\n\t\t\t\telse\n\t\t\t\t\treturn N_MODE_MCS15_RIX;\n\t\t\t} else if (wireless_mode == WIRELESS_MODE_AC_24G) {\n\t\t\t\tif (sta->deflink.bandwidth == IEEE80211_STA_RX_BW_20) {\n\t\t\t\t\tieee80211_rate_set_vht(&rate,\n\t\t\t\t\t\t\t       AC_MODE_MCS8_RIX,\n\t\t\t\t\t\t\t       nss);\n\t\t\t\t\tgoto out;\n\t\t\t\t} else {\n\t\t\t\t\tieee80211_rate_set_vht(&rate,\n\t\t\t\t\t\t\t       AC_MODE_MCS9_RIX,\n\t\t\t\t\t\t\t       nss);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (wireless_mode == WIRELESS_MODE_A) {\n\t\t\t\treturn A_MODE_MAX_RIX;\n\t\t\t} else if (wireless_mode == WIRELESS_MODE_N_5G) {\n\t\t\t\tif (nss == 1)\n\t\t\t\t\treturn N_MODE_MCS7_RIX;\n\t\t\t\telse\n\t\t\t\t\treturn N_MODE_MCS15_RIX;\n\t\t\t} else if (wireless_mode == WIRELESS_MODE_AC_5G) {\n\t\t\t\tif (sta->deflink.bandwidth == IEEE80211_STA_RX_BW_20) {\n\t\t\t\t\tieee80211_rate_set_vht(&rate,\n\t\t\t\t\t\t\t       AC_MODE_MCS8_RIX,\n\t\t\t\t\t\t\t       nss);\n\t\t\t\t\tgoto out;\n\t\t\t\t} else {\n\t\t\t\t\tieee80211_rate_set_vht(&rate,\n\t\t\t\t\t\t\t       AC_MODE_MCS9_RIX,\n\t\t\t\t\t\t\t       nss);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\nout:\n\treturn rate.idx;\n}\n\nstatic void _rtl_rc_rate_set_series(struct rtl_priv *rtlpriv,\n\t\t\t\t    struct ieee80211_sta *sta,\n\t\t\t\t    struct ieee80211_tx_rate *rate,\n\t\t\t\t    struct ieee80211_tx_rate_control *txrc,\n\t\t\t\t    u8 tries, s8 rix, int rtsctsenable,\n\t\t\t\t    bool not_data)\n{\n\tstruct rtl_mac *mac = rtl_mac(rtlpriv);\n\tstruct rtl_sta_info *sta_entry = NULL;\n\tu16 wireless_mode = 0;\n\tu8 sgi_20 = 0, sgi_40 = 0, sgi_80 = 0;\n\n\tif (sta) {\n\t\tsgi_20 = sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_SGI_20;\n\t\tsgi_40 = sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_SGI_40;\n\t\tsgi_80 = sta->deflink.vht_cap.cap & IEEE80211_VHT_CAP_SHORT_GI_80;\n\t\tsta_entry = (struct rtl_sta_info *)sta->drv_priv;\n\t\twireless_mode = sta_entry->wireless_mode;\n\t}\n\trate->count = tries;\n\trate->idx = rix >= 0x00 ? rix : 0x00;\n\n\tif (!not_data) {\n\t\tif (txrc->short_preamble)\n\t\t\trate->flags |= IEEE80211_TX_RC_USE_SHORT_PREAMBLE;\n\t\tif (mac->opmode == NL80211_IFTYPE_AP ||\n\t\t\tmac->opmode == NL80211_IFTYPE_ADHOC) {\n\t\t\tif (sta && (sta->deflink.ht_cap.cap &\n\t\t\t\t    IEEE80211_HT_CAP_SUP_WIDTH_20_40))\n\t\t\t\trate->flags |= IEEE80211_TX_RC_40_MHZ_WIDTH;\n\t\t\tif (sta && sta->deflink.vht_cap.vht_supported)\n\t\t\t\trate->flags |= IEEE80211_TX_RC_80_MHZ_WIDTH;\n\t\t} else {\n\t\t\tif (mac->bw_80)\n\t\t\t\trate->flags |= IEEE80211_TX_RC_80_MHZ_WIDTH;\n\t\t\telse if (mac->bw_40)\n\t\t\t\trate->flags |= IEEE80211_TX_RC_40_MHZ_WIDTH;\n\t\t}\n\n\t\tif (sgi_20 || sgi_40 || sgi_80)\n\t\t\trate->flags |= IEEE80211_TX_RC_SHORT_GI;\n\t\tif (sta && sta->deflink.ht_cap.ht_supported &&\n\t\t    (wireless_mode == WIRELESS_MODE_N_5G ||\n\t\t     wireless_mode == WIRELESS_MODE_N_24G))\n\t\t\trate->flags |= IEEE80211_TX_RC_MCS;\n\t\tif (sta && sta->deflink.vht_cap.vht_supported &&\n\t\t    (wireless_mode == WIRELESS_MODE_AC_5G ||\n\t\t     wireless_mode == WIRELESS_MODE_AC_24G ||\n\t\t     wireless_mode == WIRELESS_MODE_AC_ONLY))\n\t\t\trate->flags |= IEEE80211_TX_RC_VHT_MCS;\n\t}\n}\n\nstatic void rtl_get_rate(void *ppriv, struct ieee80211_sta *sta,\n\t\t\t void *priv_sta,\n\t\t\t struct ieee80211_tx_rate_control *txrc)\n{\n\tstruct rtl_priv *rtlpriv = ppriv;\n\tstruct sk_buff *skb = txrc->skb;\n\tstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_tx_rate *rates = tx_info->control.rates;\n\t__le16 fc = rtl_get_fc(skb);\n\tu8 try_per_rate, i, rix;\n\tbool not_data = !ieee80211_is_data(fc);\n\n\trix = _rtl_rc_get_highest_rix(rtlpriv, sta, skb, not_data);\n\ttry_per_rate = 1;\n\t_rtl_rc_rate_set_series(rtlpriv, sta, &rates[0], txrc,\n\t\t\t\ttry_per_rate, rix, 1, not_data);\n\n\tif (!not_data) {\n\t\tfor (i = 1; i < 4; i++)\n\t\t\t_rtl_rc_rate_set_series(rtlpriv, sta, &rates[i],\n\t\t\t\t\t\ttxrc, i, (rix - i), 1,\n\t\t\t\t\t\tnot_data);\n\t}\n}\n\nstatic bool _rtl_tx_aggr_check(struct rtl_priv *rtlpriv,\n\t\t\t       struct rtl_sta_info *sta_entry, u16 tid)\n{\n\tstruct rtl_mac *mac = rtl_mac(rtlpriv);\n\n\tif (mac->act_scanning)\n\t\treturn false;\n\n\tif (mac->opmode == NL80211_IFTYPE_STATION &&\n\t    mac->cnt_after_linked < 3)\n\t\treturn false;\n\n\tif (sta_entry->tids[tid].agg.agg_state == RTL_AGG_STOP)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic void rtl_tx_status(void *ppriv,\n\t\t\t  struct ieee80211_supported_band *sband,\n\t\t\t  struct ieee80211_sta *sta, void *priv_sta,\n\t\t\t  struct sk_buff *skb)\n{\n\tstruct rtl_priv *rtlpriv = ppriv;\n\tstruct rtl_mac *mac = rtl_mac(rtlpriv);\n\tstruct ieee80211_hdr *hdr = rtl_get_hdr(skb);\n\t__le16 fc = rtl_get_fc(skb);\n\tstruct rtl_sta_info *sta_entry;\n\n\tif (!priv_sta || !ieee80211_is_data(fc))\n\t\treturn;\n\n\tif (rtl_is_special_data(mac->hw, skb, true, true))\n\t\treturn;\n\n\tif (is_multicast_ether_addr(ieee80211_get_DA(hdr)) ||\n\t    is_broadcast_ether_addr(ieee80211_get_DA(hdr)))\n\t\treturn;\n\n\tif (sta) {\n\t\t \n\t\tsta_entry = (struct rtl_sta_info *)sta->drv_priv;\n\t\tif (sta->deflink.ht_cap.ht_supported &&\n\t\t    !(skb->protocol == cpu_to_be16(ETH_P_PAE))) {\n\t\t\tif (ieee80211_is_data_qos(fc)) {\n\t\t\t\tu8 tid = rtl_get_tid(skb);\n\n\t\t\t\tif (_rtl_tx_aggr_check(rtlpriv, sta_entry,\n\t\t\t\t\t\t       tid)) {\n\t\t\t\t\tsta_entry->tids[tid].agg.agg_state =\n\t\t\t\t\t\tRTL_AGG_PROGRESS;\n\t\t\t\t\tieee80211_start_tx_ba_session(sta, tid,\n\t\t\t\t\t\t\t\t      5000);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void rtl_rate_init(void *ppriv,\n\t\t\t  struct ieee80211_supported_band *sband,\n\t\t\t  struct cfg80211_chan_def *chandef,\n\t\t\t  struct ieee80211_sta *sta, void *priv_sta)\n{\n}\n\nstatic void rtl_rate_update(void *ppriv,\n\t\t\t    struct ieee80211_supported_band *sband,\n\t\t\t    struct cfg80211_chan_def *chandef,\n\t\t\t    struct ieee80211_sta *sta, void *priv_sta,\n\t\t\t    u32 changed)\n{\n}\n\nstatic void *rtl_rate_alloc(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\treturn rtlpriv;\n}\n\nstatic void rtl_rate_free(void *rtlpriv)\n{\n\treturn;\n}\n\nstatic void *rtl_rate_alloc_sta(void *ppriv,\n\t\t\t\tstruct ieee80211_sta *sta, gfp_t gfp)\n{\n\tstruct rtl_priv *rtlpriv = ppriv;\n\tstruct rtl_rate_priv *rate_priv;\n\n\trate_priv = kzalloc(sizeof(*rate_priv), gfp);\n\tif (!rate_priv)\n\t\treturn NULL;\n\n\trtlpriv->rate_priv = rate_priv;\n\n\treturn rate_priv;\n}\n\nstatic void rtl_rate_free_sta(void *rtlpriv,\n\t\t\t      struct ieee80211_sta *sta, void *priv_sta)\n{\n\tstruct rtl_rate_priv *rate_priv = priv_sta;\n\n\tkfree(rate_priv);\n}\n\nstatic const struct rate_control_ops rtl_rate_ops = {\n\t.name = \"rtl_rc\",\n\t.alloc = rtl_rate_alloc,\n\t.free = rtl_rate_free,\n\t.alloc_sta = rtl_rate_alloc_sta,\n\t.free_sta = rtl_rate_free_sta,\n\t.rate_init = rtl_rate_init,\n\t.rate_update = rtl_rate_update,\n\t.tx_status = rtl_tx_status,\n\t.get_rate = rtl_get_rate,\n};\n\nint rtl_rate_control_register(void)\n{\n\treturn ieee80211_rate_control_register(&rtl_rate_ops);\n}\n\nvoid rtl_rate_control_unregister(void)\n{\n\tieee80211_rate_control_unregister(&rtl_rate_ops);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}