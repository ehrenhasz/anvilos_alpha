{
  "module_name": "pci.c",
  "hash_id": "325d52c821fb2b729a585ba9a6cc8dbc710e272eb204d23eeb4e9eb3b0f384c8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtlwifi/pci.c",
  "human_readable_source": "\n \n\n#include \"wifi.h\"\n#include \"core.h\"\n#include \"pci.h\"\n#include \"base.h\"\n#include \"ps.h\"\n#include \"efuse.h\"\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/module.h>\n\nMODULE_AUTHOR(\"lizhaoming\t<chaoming_li@realsil.com.cn>\");\nMODULE_AUTHOR(\"Realtek WlanFAE\t<wlanfae@realtek.com>\");\nMODULE_AUTHOR(\"Larry Finger\t<Larry.FInger@lwfinger.net>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"PCI basic driver for rtlwifi\");\n\nstatic const u16 pcibridge_vendors[PCI_BRIDGE_VENDOR_MAX] = {\n\tINTEL_VENDOR_ID,\n\tATI_VENDOR_ID,\n\tAMD_VENDOR_ID,\n\tSIS_VENDOR_ID\n};\n\nstatic const u8 ac_to_hwq[] = {\n\tVO_QUEUE,\n\tVI_QUEUE,\n\tBE_QUEUE,\n\tBK_QUEUE\n};\n\nstatic u8 _rtl_mac_to_hwqueue(struct ieee80211_hw *hw, struct sk_buff *skb)\n{\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\t__le16 fc = rtl_get_fc(skb);\n\tu8 queue_index = skb_get_queue_mapping(skb);\n\tstruct ieee80211_hdr *hdr;\n\n\tif (unlikely(ieee80211_is_beacon(fc)))\n\t\treturn BEACON_QUEUE;\n\tif (ieee80211_is_mgmt(fc) || ieee80211_is_ctl(fc))\n\t\treturn MGNT_QUEUE;\n\tif (rtlhal->hw_type == HARDWARE_TYPE_RTL8192SE)\n\t\tif (ieee80211_is_nullfunc(fc))\n\t\t\treturn HIGH_QUEUE;\n\tif (rtlhal->hw_type == HARDWARE_TYPE_RTL8822BE) {\n\t\thdr = rtl_get_hdr(skb);\n\n\t\tif (is_multicast_ether_addr(hdr->addr1) ||\n\t\t    is_broadcast_ether_addr(hdr->addr1))\n\t\t\treturn HIGH_QUEUE;\n\t}\n\n\treturn ac_to_hwq[queue_index];\n}\n\n \nstatic void _rtl_pci_update_default_setting(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci_priv *pcipriv = rtl_pcipriv(hw);\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tu8 pcibridge_vendor = pcipriv->ndis_adapter.pcibridge_vendor;\n\tu8 init_aspm;\n\n\tppsc->reg_rfps_level = 0;\n\tppsc->support_aspm = false;\n\n\t \n\tppsc->const_amdpci_aspm = rtlpci->const_amdpci_aspm;\n\tswitch (rtlpci->const_pci_aspm) {\n\tcase 0:\n\t\t \n\t\tbreak;\n\n\tcase 1:\n\t\t \n\t\tppsc->reg_rfps_level |= RT_RF_LPS_LEVEL_ASPM;\n\t\tbreak;\n\n\tcase 2:\n\t\t \n\t\tppsc->reg_rfps_level |= (RT_RF_LPS_LEVEL_ASPM |\n\t\t\t\t\t RT_RF_OFF_LEVL_CLK_REQ);\n\t\tbreak;\n\n\tcase 3:\n\t\t \n\t\tppsc->reg_rfps_level &= ~(RT_RF_LPS_LEVEL_ASPM);\n\t\tppsc->reg_rfps_level |= (RT_RF_PS_LEVEL_ALWAYS_ASPM |\n\t\t\t\t\t RT_RF_OFF_LEVL_CLK_REQ);\n\t\tbreak;\n\n\tcase 4:\n\t\t \n\t\tppsc->reg_rfps_level &= ~(RT_RF_LPS_LEVEL_ASPM |\n\t\t\t\t\t  RT_RF_OFF_LEVL_CLK_REQ);\n\t\tppsc->reg_rfps_level |= RT_RF_PS_LEVEL_ALWAYS_ASPM;\n\t\tbreak;\n\t}\n\n\tppsc->reg_rfps_level |= RT_RF_OFF_LEVL_HALT_NIC;\n\n\t \n\tswitch (rtlpci->const_hwsw_rfoff_d3) {\n\tcase 1:\n\t\tif (ppsc->reg_rfps_level & RT_RF_LPS_LEVEL_ASPM)\n\t\t\tppsc->reg_rfps_level |= RT_RF_OFF_LEVL_ASPM;\n\t\tbreak;\n\n\tcase 2:\n\t\tif (ppsc->reg_rfps_level & RT_RF_LPS_LEVEL_ASPM)\n\t\t\tppsc->reg_rfps_level |= RT_RF_OFF_LEVL_ASPM;\n\t\tppsc->reg_rfps_level |= RT_RF_OFF_LEVL_HALT_NIC;\n\t\tbreak;\n\n\tcase 3:\n\t\tppsc->reg_rfps_level |= RT_RF_OFF_LEVL_PCI_D3;\n\t\tbreak;\n\t}\n\n\t \n\tswitch (rtlpci->const_support_pciaspm) {\n\tcase 0:\n\t\t \n\t\tppsc->support_aspm = false;\n\t\tbreak;\n\tcase 1:\n\t\t \n\t\tppsc->support_aspm = true;\n\t\tppsc->support_backdoor = true;\n\t\tbreak;\n\tcase 2:\n\t\t \n\t\tif (pcibridge_vendor == PCI_BRIDGE_VENDOR_INTEL)\n\t\t\tppsc->support_aspm = true;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"switch case %#x not processed\\n\",\n\t\t       rtlpci->const_support_pciaspm);\n\t\tbreak;\n\t}\n\n\t \n\tpci_read_config_byte(rtlpci->pdev, 0x80, &init_aspm);\n\tif (rtlpriv->rtlhal.hw_type == HARDWARE_TYPE_RTL8192SE &&\n\t    init_aspm == 0x43)\n\t\tppsc->support_aspm = false;\n}\n\nstatic bool _rtl_pci_platform_switch_device_pci_aspm(\n\t\t\tstruct ieee80211_hw *hw,\n\t\t\tu8 value)\n{\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\n\tvalue &= PCI_EXP_LNKCTL_ASPMC;\n\n\tif (rtlhal->hw_type != HARDWARE_TYPE_RTL8192SE)\n\t\tvalue |= PCI_EXP_LNKCTL_CCC;\n\n\tpcie_capability_clear_and_set_word(rtlpci->pdev, PCI_EXP_LNKCTL,\n\t\t\t\t\t   PCI_EXP_LNKCTL_ASPMC | value,\n\t\t\t\t\t   value);\n\n\treturn false;\n}\n\n \nstatic void _rtl_pci_switch_clk_req(struct ieee80211_hw *hw, u16 value)\n{\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\n\tvalue &= PCI_EXP_LNKCTL_CLKREQ_EN;\n\n\tpcie_capability_clear_and_set_word(rtlpci->pdev, PCI_EXP_LNKCTL,\n\t\t\t\t\t   PCI_EXP_LNKCTL_CLKREQ_EN,\n\t\t\t\t\t   value);\n\n\tif (rtlhal->hw_type == HARDWARE_TYPE_RTL8192SE)\n\t\tudelay(100);\n}\n\n \nstatic void rtl_pci_disable_aspm(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci_priv *pcipriv = rtl_pcipriv(hw);\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tu8 pcibridge_vendor = pcipriv->ndis_adapter.pcibridge_vendor;\n\t \n\tu8 linkctrl_reg = pcipriv->ndis_adapter.linkctrl_reg;\n\tu16 aspmlevel = 0;\n\tu8 tmp_u1b = 0;\n\n\tif (!ppsc->support_aspm)\n\t\treturn;\n\n\tif (pcibridge_vendor == PCI_BRIDGE_VENDOR_UNKNOWN) {\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_TRACE,\n\t\t\t\"PCI(Bridge) UNKNOWN\\n\");\n\n\t\treturn;\n\t}\n\n\tif (ppsc->reg_rfps_level & RT_RF_OFF_LEVL_CLK_REQ) {\n\t\tRT_CLEAR_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_CLK_REQ);\n\t\t_rtl_pci_switch_clk_req(hw, 0x0);\n\t}\n\n\t \n\tpci_read_config_byte(rtlpci->pdev, 0x80, &tmp_u1b);\n\n\t \n\taspmlevel |= BIT(0) | BIT(1);\n\tlinkctrl_reg &= ~aspmlevel;\n\n\t_rtl_pci_platform_switch_device_pci_aspm(hw, linkctrl_reg);\n}\n\n \nstatic void rtl_pci_enable_aspm(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci_priv *pcipriv = rtl_pcipriv(hw);\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tu8 pcibridge_vendor = pcipriv->ndis_adapter.pcibridge_vendor;\n\tu16 aspmlevel;\n\tu8 u_device_aspmsetting;\n\n\tif (!ppsc->support_aspm)\n\t\treturn;\n\n\tif (pcibridge_vendor == PCI_BRIDGE_VENDOR_UNKNOWN) {\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_TRACE,\n\t\t\t\"PCI(Bridge) UNKNOWN\\n\");\n\t\treturn;\n\t}\n\n\t \n\taspmlevel = rtlpci->const_devicepci_aspm_setting;\n\tu_device_aspmsetting = pcipriv->ndis_adapter.linkctrl_reg;\n\n\t \n\t \n\n\tu_device_aspmsetting |= aspmlevel;\n\n\t_rtl_pci_platform_switch_device_pci_aspm(hw, u_device_aspmsetting);\n\n\tif (ppsc->reg_rfps_level & RT_RF_OFF_LEVL_CLK_REQ) {\n\t\t_rtl_pci_switch_clk_req(hw, (ppsc->reg_rfps_level &\n\t\t\t\t\t     RT_RF_OFF_LEVL_CLK_REQ) ?\n\t\t\t\t\t     PCI_EXP_LNKCTL_CLKREQ_EN : 0);\n\t\tRT_SET_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_CLK_REQ);\n\t}\n\tudelay(100);\n}\n\nstatic bool rtl_pci_get_amd_l1_patch(struct ieee80211_hw *hw)\n{\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\n\tbool status = false;\n\tu8 offset_e0;\n\tunsigned int offset_e4;\n\n\tpci_write_config_byte(rtlpci->pdev, 0xe0, 0xa0);\n\n\tpci_read_config_byte(rtlpci->pdev, 0xe0, &offset_e0);\n\n\tif (offset_e0 == 0xA0) {\n\t\tpci_read_config_dword(rtlpci->pdev, 0xe4, &offset_e4);\n\t\tif (offset_e4 & BIT(23))\n\t\t\tstatus = true;\n\t}\n\n\treturn status;\n}\n\nstatic bool rtl_pci_check_buddy_priv(struct ieee80211_hw *hw,\n\t\t\t\t     struct rtl_priv **buddy_priv)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci_priv *pcipriv = rtl_pcipriv(hw);\n\tstruct rtl_priv *tpriv = NULL, *iter;\n\tstruct rtl_pci_priv *tpcipriv = NULL;\n\n\tif (!list_empty(&rtlpriv->glb_var->glb_priv_list)) {\n\t\tlist_for_each_entry(iter, &rtlpriv->glb_var->glb_priv_list,\n\t\t\t\t    list) {\n\t\t\ttpcipriv = (struct rtl_pci_priv *)iter->priv;\n\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\t\"pcipriv->ndis_adapter.funcnumber %x\\n\",\n\t\t\t\tpcipriv->ndis_adapter.funcnumber);\n\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\t\"tpcipriv->ndis_adapter.funcnumber %x\\n\",\n\t\t\t\ttpcipriv->ndis_adapter.funcnumber);\n\n\t\t\tif (pcipriv->ndis_adapter.busnumber ==\n\t\t\t    tpcipriv->ndis_adapter.busnumber &&\n\t\t\t    pcipriv->ndis_adapter.devnumber ==\n\t\t\t    tpcipriv->ndis_adapter.devnumber &&\n\t\t\t    pcipriv->ndis_adapter.funcnumber !=\n\t\t\t    tpcipriv->ndis_adapter.funcnumber) {\n\t\t\t\ttpriv = iter;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\"find_buddy_priv %d\\n\", tpriv != NULL);\n\n\tif (tpriv)\n\t\t*buddy_priv = tpriv;\n\n\treturn tpriv != NULL;\n}\n\nstatic void rtl_pci_parse_configuration(struct pci_dev *pdev,\n\t\t\t\t\tstruct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci_priv *pcipriv = rtl_pcipriv(hw);\n\n\tu8 tmp;\n\tu16 linkctrl_reg;\n\n\t \n\tpcie_capability_read_word(pdev, PCI_EXP_LNKCTL, &linkctrl_reg);\n\tpcipriv->ndis_adapter.linkctrl_reg = (u8)linkctrl_reg;\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE, \"Link Control Register =%x\\n\",\n\t\tpcipriv->ndis_adapter.linkctrl_reg);\n\n\tpci_read_config_byte(pdev, 0x98, &tmp);\n\ttmp |= BIT(4);\n\tpci_write_config_byte(pdev, 0x98, tmp);\n\n\ttmp = 0x17;\n\tpci_write_config_byte(pdev, 0x70f, tmp);\n}\n\nstatic void rtl_pci_init_aspm(struct ieee80211_hw *hw)\n{\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\n\t_rtl_pci_update_default_setting(hw);\n\n\tif (ppsc->reg_rfps_level & RT_RF_PS_LEVEL_ALWAYS_ASPM) {\n\t\t \n\t\trtl_pci_enable_aspm(hw);\n\t\tRT_SET_PS_LEVEL(ppsc, RT_RF_PS_LEVEL_ALWAYS_ASPM);\n\t}\n}\n\nstatic void _rtl_pci_io_handler_init(struct device *dev,\n\t\t\t\t     struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtlpriv->io.dev = dev;\n\n\trtlpriv->io.write8_async = pci_write8_async;\n\trtlpriv->io.write16_async = pci_write16_async;\n\trtlpriv->io.write32_async = pci_write32_async;\n\n\trtlpriv->io.read8_sync = pci_read8_sync;\n\trtlpriv->io.read16_sync = pci_read16_sync;\n\trtlpriv->io.read32_sync = pci_read32_sync;\n}\n\nstatic bool _rtl_update_earlymode_info(struct ieee80211_hw *hw,\n\t\t\t\t       struct sk_buff *skb,\n\t\t\t\t       struct rtl_tcb_desc *tcb_desc, u8 tid)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct sk_buff *next_skb;\n\tu8 additionlen = FCS_LEN;\n\n\t \n\tif (info->control.hw_key)\n\t\tadditionlen += info->control.hw_key->icv_len;\n\n\t \n\ttcb_desc->empkt_num = 0;\n\tspin_lock_bh(&rtlpriv->locks.waitq_lock);\n\tskb_queue_walk(&rtlpriv->mac80211.skb_waitq[tid], next_skb) {\n\t\tstruct ieee80211_tx_info *next_info;\n\n\t\tnext_info = IEEE80211_SKB_CB(next_skb);\n\t\tif (next_info->flags & IEEE80211_TX_CTL_AMPDU) {\n\t\t\ttcb_desc->empkt_len[tcb_desc->empkt_num] =\n\t\t\t\tnext_skb->len + additionlen;\n\t\t\ttcb_desc->empkt_num++;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (skb_queue_is_last(&rtlpriv->mac80211.skb_waitq[tid],\n\t\t\t\t      next_skb))\n\t\t\tbreak;\n\n\t\tif (tcb_desc->empkt_num >= rtlhal->max_earlymode_num)\n\t\t\tbreak;\n\t}\n\tspin_unlock_bh(&rtlpriv->locks.waitq_lock);\n\n\treturn true;\n}\n\n \nstatic void _rtl_pci_tx_chk_waitq(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tstruct sk_buff *skb = NULL;\n\tstruct ieee80211_tx_info *info = NULL;\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tint tid;\n\n\tif (!rtlpriv->rtlhal.earlymode_enable)\n\t\treturn;\n\n\t \n\tfor (tid = 7; tid >= 0; tid--) {\n\t\tu8 hw_queue = ac_to_hwq[rtl_tid_to_ac(tid)];\n\t\tstruct rtl8192_tx_ring *ring = &rtlpci->tx_ring[hw_queue];\n\n\t\twhile (!mac->act_scanning &&\n\t\t       rtlpriv->psc.rfpwr_state == ERFON) {\n\t\t\tstruct rtl_tcb_desc tcb_desc;\n\n\t\t\tmemset(&tcb_desc, 0, sizeof(struct rtl_tcb_desc));\n\n\t\t\tspin_lock(&rtlpriv->locks.waitq_lock);\n\t\t\tif (!skb_queue_empty(&mac->skb_waitq[tid]) &&\n\t\t\t    (ring->entries - skb_queue_len(&ring->queue) >\n\t\t\t     rtlhal->max_earlymode_num)) {\n\t\t\t\tskb = skb_dequeue(&mac->skb_waitq[tid]);\n\t\t\t} else {\n\t\t\t\tspin_unlock(&rtlpriv->locks.waitq_lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tspin_unlock(&rtlpriv->locks.waitq_lock);\n\n\t\t\t \n\t\t\tinfo = IEEE80211_SKB_CB(skb);\n\t\t\tif (info->flags & IEEE80211_TX_CTL_AMPDU)\n\t\t\t\t_rtl_update_earlymode_info(hw, skb,\n\t\t\t\t\t\t\t   &tcb_desc, tid);\n\n\t\t\trtlpriv->intf_ops->adapter_tx(hw, NULL, skb, &tcb_desc);\n\t\t}\n\t}\n}\n\nstatic void _rtl_pci_tx_isr(struct ieee80211_hw *hw, int prio)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\n\tstruct rtl8192_tx_ring *ring = &rtlpci->tx_ring[prio];\n\n\twhile (skb_queue_len(&ring->queue)) {\n\t\tstruct sk_buff *skb;\n\t\tstruct ieee80211_tx_info *info;\n\t\t__le16 fc;\n\t\tu8 tid;\n\t\tu8 *entry;\n\n\t\tif (rtlpriv->use_new_trx_flow)\n\t\t\tentry = (u8 *)(&ring->buffer_desc[ring->idx]);\n\t\telse\n\t\t\tentry = (u8 *)(&ring->desc[ring->idx]);\n\n\t\tif (!rtlpriv->cfg->ops->is_tx_desc_closed(hw, prio, ring->idx))\n\t\t\treturn;\n\t\tring->idx = (ring->idx + 1) % ring->entries;\n\n\t\tskb = __skb_dequeue(&ring->queue);\n\t\tdma_unmap_single(&rtlpci->pdev->dev,\n\t\t\t\t rtlpriv->cfg->ops->get_desc(hw, (u8 *)entry,\n\t\t\t\t\t\ttrue, HW_DESC_TXBUFF_ADDR),\n\t\t\t\t skb->len, DMA_TO_DEVICE);\n\n\t\t \n\t\tif (rtlpriv->rtlhal.earlymode_enable)\n\t\t\tskb_pull(skb, EM_HDR_LEN);\n\n\t\trtl_dbg(rtlpriv, (COMP_INTR | COMP_SEND), DBG_TRACE,\n\t\t\t\"new ring->idx:%d, free: skb_queue_len:%d, free: seq:%x\\n\",\n\t\t\tring->idx,\n\t\t\tskb_queue_len(&ring->queue),\n\t\t\t*(u16 *)(skb->data + 22));\n\n\t\tif (prio == TXCMD_QUEUE) {\n\t\t\tdev_kfree_skb(skb);\n\t\t\tgoto tx_status_ok;\n\t\t}\n\n\t\t \n\t\tfc = rtl_get_fc(skb);\n\t\tif (ieee80211_is_nullfunc(fc)) {\n\t\t\tif (ieee80211_has_pm(fc)) {\n\t\t\t\trtlpriv->mac80211.offchan_delay = true;\n\t\t\t\trtlpriv->psc.state_inap = true;\n\t\t\t} else {\n\t\t\t\trtlpriv->psc.state_inap = false;\n\t\t\t}\n\t\t}\n\t\tif (ieee80211_is_action(fc)) {\n\t\t\tstruct ieee80211_mgmt *action_frame =\n\t\t\t\t(struct ieee80211_mgmt *)skb->data;\n\t\t\tif (action_frame->u.action.u.ht_smps.action ==\n\t\t\t    WLAN_HT_ACTION_SMPS) {\n\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\tgoto tx_status_ok;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\ttid = rtl_get_tid(skb);\n\t\tif (tid <= 7)\n\t\t\trtlpriv->link_info.tidtx_inperiod[tid]++;\n\n\t\tinfo = IEEE80211_SKB_CB(skb);\n\n\t\tif (likely(!ieee80211_is_nullfunc(fc))) {\n\t\t\tieee80211_tx_info_clear_status(info);\n\t\t\tinfo->flags |= IEEE80211_TX_STAT_ACK;\n\t\t\t \n\t\t\tieee80211_tx_status_irqsafe(hw, skb);\n\t\t} else {\n\t\t\trtl_tx_ackqueue(hw, skb);\n\t\t}\n\n\t\tif ((ring->entries - skb_queue_len(&ring->queue)) <= 4) {\n\t\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_DMESG,\n\t\t\t\t\"more desc left, wake skb_queue@%d, ring->idx = %d, skb_queue_len = 0x%x\\n\",\n\t\t\t\tprio, ring->idx,\n\t\t\t\tskb_queue_len(&ring->queue));\n\n\t\t\tieee80211_wake_queue(hw, skb_get_queue_mapping(skb));\n\t\t}\ntx_status_ok:\n\t\tskb = NULL;\n\t}\n\n\tif (((rtlpriv->link_info.num_rx_inperiod +\n\t      rtlpriv->link_info.num_tx_inperiod) > 8) ||\n\t      rtlpriv->link_info.num_rx_inperiod > 2)\n\t\trtl_lps_leave(hw, false);\n}\n\nstatic int _rtl_pci_init_one_rxdesc(struct ieee80211_hw *hw,\n\t\t\t\t    struct sk_buff *new_skb, u8 *entry,\n\t\t\t\t    int rxring_idx, int desc_idx)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tu32 bufferaddress;\n\tu8 tmp_one = 1;\n\tstruct sk_buff *skb;\n\n\tif (likely(new_skb)) {\n\t\tskb = new_skb;\n\t\tgoto remap;\n\t}\n\tskb = dev_alloc_skb(rtlpci->rxbuffersize);\n\tif (!skb)\n\t\treturn 0;\n\nremap:\n\t \n\t*((dma_addr_t *)skb->cb) =\n\t\tdma_map_single(&rtlpci->pdev->dev, skb_tail_pointer(skb),\n\t\t\t       rtlpci->rxbuffersize, DMA_FROM_DEVICE);\n\tbufferaddress = *((dma_addr_t *)skb->cb);\n\tif (dma_mapping_error(&rtlpci->pdev->dev, bufferaddress))\n\t\treturn 0;\n\trtlpci->rx_ring[rxring_idx].rx_buf[desc_idx] = skb;\n\tif (rtlpriv->use_new_trx_flow) {\n\t\t \n\t\trtlpriv->cfg->ops->set_desc(hw, (u8 *)entry, false,\n\t\t\t\t\t    HW_DESC_RX_PREPARE,\n\t\t\t\t\t    (u8 *)(dma_addr_t *)skb->cb);\n\t} else {\n\t\trtlpriv->cfg->ops->set_desc(hw, (u8 *)entry, false,\n\t\t\t\t\t    HW_DESC_RXBUFF_ADDR,\n\t\t\t\t\t    (u8 *)&bufferaddress);\n\t\trtlpriv->cfg->ops->set_desc(hw, (u8 *)entry, false,\n\t\t\t\t\t    HW_DESC_RXPKT_LEN,\n\t\t\t\t\t    (u8 *)&rtlpci->rxbuffersize);\n\t\trtlpriv->cfg->ops->set_desc(hw, (u8 *)entry, false,\n\t\t\t\t\t    HW_DESC_RXOWN,\n\t\t\t\t\t    (u8 *)&tmp_one);\n\t}\n\treturn 1;\n}\n\n \nstatic void _rtl_pci_rx_to_mac80211(struct ieee80211_hw *hw,\n\t\t\t\t    struct sk_buff *skb,\n\t\t\t\t    struct ieee80211_rx_status rx_status)\n{\n\tif (unlikely(!rtl_action_proc(hw, skb, false))) {\n\t\tdev_kfree_skb_any(skb);\n\t} else {\n\t\tstruct sk_buff *uskb = NULL;\n\n\t\tuskb = dev_alloc_skb(skb->len + 128);\n\t\tif (likely(uskb)) {\n\t\t\tmemcpy(IEEE80211_SKB_RXCB(uskb), &rx_status,\n\t\t\t       sizeof(rx_status));\n\t\t\tskb_put_data(uskb, skb->data, skb->len);\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\tieee80211_rx_irqsafe(hw, uskb);\n\t\t} else {\n\t\t\tieee80211_rx_irqsafe(hw, skb);\n\t\t}\n\t}\n}\n\n \nstatic void _rtl_pci_hs_interrupt(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\n\trtl_write_byte(rtlpriv, rtlpriv->cfg->maps[MAC_HSISR],\n\t\t       rtl_read_byte(rtlpriv, rtlpriv->cfg->maps[MAC_HSISR]) |\n\t\t       rtlpci->sys_irq_mask);\n}\n\nstatic void _rtl_pci_rx_interrupt(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tint rxring_idx = RTL_PCI_RX_MPDU_QUEUE;\n\tstruct ieee80211_rx_status rx_status = { 0 };\n\tunsigned int count = rtlpci->rxringcount;\n\tu8 own;\n\tu8 tmp_one;\n\tbool unicast = false;\n\tu8 hw_queue = 0;\n\tunsigned int rx_remained_cnt = 0;\n\tstruct rtl_stats stats = {\n\t\t.signal = 0,\n\t\t.rate = 0,\n\t};\n\n\t \n\twhile (count--) {\n\t\tstruct ieee80211_hdr *hdr;\n\t\t__le16 fc;\n\t\tu16 len;\n\t\t \n\t\tstruct rtl_rx_buffer_desc *buffer_desc = NULL;\n\t\t \n\t\tstruct rtl_rx_desc *pdesc = NULL;\n\t\t \n\t\tstruct sk_buff *skb = rtlpci->rx_ring[rxring_idx].rx_buf[\n\t\t\t\t      rtlpci->rx_ring[rxring_idx].idx];\n\t\tstruct sk_buff *new_skb;\n\n\t\tif (rtlpriv->use_new_trx_flow) {\n\t\t\tif (rx_remained_cnt == 0)\n\t\t\t\trx_remained_cnt =\n\t\t\t\trtlpriv->cfg->ops->rx_desc_buff_remained_cnt(hw,\n\t\t\t\t\t\t\t\t      hw_queue);\n\t\t\tif (rx_remained_cnt == 0)\n\t\t\t\treturn;\n\t\t\tbuffer_desc = &rtlpci->rx_ring[rxring_idx].buffer_desc[\n\t\t\t\trtlpci->rx_ring[rxring_idx].idx];\n\t\t\tpdesc = (struct rtl_rx_desc *)skb->data;\n\t\t} else {\t \n\t\t\tpdesc = &rtlpci->rx_ring[rxring_idx].desc[\n\t\t\t\trtlpci->rx_ring[rxring_idx].idx];\n\n\t\t\town = (u8)rtlpriv->cfg->ops->get_desc(hw, (u8 *)pdesc,\n\t\t\t\t\t\t\t      false,\n\t\t\t\t\t\t\t      HW_DESC_OWN);\n\t\t\tif (own)  \n\t\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tdma_unmap_single(&rtlpci->pdev->dev, *((dma_addr_t *)skb->cb),\n\t\t\t\t rtlpci->rxbuffersize, DMA_FROM_DEVICE);\n\n\t\t \n\t\tnew_skb = dev_alloc_skb(rtlpci->rxbuffersize);\n\t\tif (unlikely(!new_skb))\n\t\t\tgoto no_new;\n\t\tmemset(&rx_status, 0, sizeof(rx_status));\n\t\trtlpriv->cfg->ops->query_rx_desc(hw, &stats,\n\t\t\t\t\t\t &rx_status, (u8 *)pdesc, skb);\n\n\t\tif (rtlpriv->use_new_trx_flow)\n\t\t\trtlpriv->cfg->ops->rx_check_dma_ok(hw,\n\t\t\t\t\t\t\t   (u8 *)buffer_desc,\n\t\t\t\t\t\t\t   hw_queue);\n\n\t\tlen = rtlpriv->cfg->ops->get_desc(hw, (u8 *)pdesc, false,\n\t\t\t\t\t\t  HW_DESC_RXPKT_LEN);\n\n\t\tif (skb->end - skb->tail > len) {\n\t\t\tskb_put(skb, len);\n\t\t\tif (rtlpriv->use_new_trx_flow)\n\t\t\t\tskb_reserve(skb, stats.rx_drvinfo_size +\n\t\t\t\t\t    stats.rx_bufshift + 24);\n\t\t\telse\n\t\t\t\tskb_reserve(skb, stats.rx_drvinfo_size +\n\t\t\t\t\t    stats.rx_bufshift);\n\t\t} else {\n\t\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_WARNING,\n\t\t\t\t\"skb->end - skb->tail = %d, len is %d\\n\",\n\t\t\t\tskb->end - skb->tail, len);\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\tgoto new_trx_end;\n\t\t}\n\t\t \n\t\tif (stats.packet_report_type == C2H_PACKET) {\n\t\t\trtl_c2hcmd_enqueue(hw, skb);\n\t\t\tgoto new_trx_end;\n\t\t}\n\n\t\t \n\n\t\thdr = rtl_get_hdr(skb);\n\t\tfc = rtl_get_fc(skb);\n\n\t\tif (!stats.crc && !stats.hwerror && (skb->len > FCS_LEN)) {\n\t\t\tmemcpy(IEEE80211_SKB_RXCB(skb), &rx_status,\n\t\t\t       sizeof(rx_status));\n\n\t\t\tif (is_broadcast_ether_addr(hdr->addr1)) {\n\t\t\t\t; \n\t\t\t} else if (is_multicast_ether_addr(hdr->addr1)) {\n\t\t\t\t; \n\t\t\t} else {\n\t\t\t\tunicast = true;\n\t\t\t\trtlpriv->stats.rxbytesunicast += skb->len;\n\t\t\t}\n\t\t\trtl_is_special_data(hw, skb, false, true);\n\n\t\t\tif (ieee80211_is_data(fc)) {\n\t\t\t\trtlpriv->cfg->ops->led_control(hw, LED_CTL_RX);\n\t\t\t\tif (unicast)\n\t\t\t\t\trtlpriv->link_info.num_rx_inperiod++;\n\t\t\t}\n\n\t\t\trtl_collect_scan_list(hw, skb);\n\n\t\t\t \n\t\t\trtl_beacon_statistic(hw, skb);\n\t\t\trtl_p2p_info(hw, (void *)skb->data, skb->len);\n\t\t\t \n\t\t\trtl_swlps_beacon(hw, (void *)skb->data, skb->len);\n\t\t\trtl_recognize_peer(hw, (void *)skb->data, skb->len);\n\t\t\tif (rtlpriv->mac80211.opmode == NL80211_IFTYPE_AP &&\n\t\t\t    rtlpriv->rtlhal.current_bandtype == BAND_ON_2_4G &&\n\t\t\t    (ieee80211_is_beacon(fc) ||\n\t\t\t     ieee80211_is_probe_resp(fc))) {\n\t\t\t\tdev_kfree_skb_any(skb);\n\t\t\t} else {\n\t\t\t\t_rtl_pci_rx_to_mac80211(hw, skb, rx_status);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tdev_kfree_skb_any(skb);\n\t\t}\nnew_trx_end:\n\t\tif (rtlpriv->use_new_trx_flow) {\n\t\t\trtlpci->rx_ring[hw_queue].next_rx_rp += 1;\n\t\t\trtlpci->rx_ring[hw_queue].next_rx_rp %=\n\t\t\t\t\tRTL_PCI_MAX_RX_COUNT;\n\n\t\t\trx_remained_cnt--;\n\t\t\trtl_write_word(rtlpriv, 0x3B4,\n\t\t\t\t       rtlpci->rx_ring[hw_queue].next_rx_rp);\n\t\t}\n\t\tif (((rtlpriv->link_info.num_rx_inperiod +\n\t\t      rtlpriv->link_info.num_tx_inperiod) > 8) ||\n\t\t      rtlpriv->link_info.num_rx_inperiod > 2)\n\t\t\trtl_lps_leave(hw, false);\n\t\tskb = new_skb;\nno_new:\n\t\tif (rtlpriv->use_new_trx_flow) {\n\t\t\t_rtl_pci_init_one_rxdesc(hw, skb, (u8 *)buffer_desc,\n\t\t\t\t\t\t rxring_idx,\n\t\t\t\t\t\t rtlpci->rx_ring[rxring_idx].idx);\n\t\t} else {\n\t\t\t_rtl_pci_init_one_rxdesc(hw, skb, (u8 *)pdesc,\n\t\t\t\t\t\t rxring_idx,\n\t\t\t\t\t\t rtlpci->rx_ring[rxring_idx].idx);\n\t\t\tif (rtlpci->rx_ring[rxring_idx].idx ==\n\t\t\t    rtlpci->rxringcount - 1)\n\t\t\t\trtlpriv->cfg->ops->set_desc(hw, (u8 *)pdesc,\n\t\t\t\t\t\t\t    false,\n\t\t\t\t\t\t\t    HW_DESC_RXERO,\n\t\t\t\t\t\t\t    (u8 *)&tmp_one);\n\t\t}\n\t\trtlpci->rx_ring[rxring_idx].idx =\n\t\t\t\t(rtlpci->rx_ring[rxring_idx].idx + 1) %\n\t\t\t\trtlpci->rxringcount;\n\t}\n}\n\nstatic irqreturn_t _rtl_pci_interrupt(int irq, void *dev_id)\n{\n\tstruct ieee80211_hw *hw = dev_id;\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tunsigned long flags;\n\tstruct rtl_int intvec = {0};\n\n\tirqreturn_t ret = IRQ_HANDLED;\n\n\tif (rtlpci->irq_enabled == 0)\n\t\treturn ret;\n\n\tspin_lock_irqsave(&rtlpriv->locks.irq_th_lock, flags);\n\trtlpriv->cfg->ops->disable_interrupt(hw);\n\n\t \n\trtlpriv->cfg->ops->interrupt_recognized(hw, &intvec);\n\n\t \n\tif (!intvec.inta || intvec.inta == 0xffff)\n\t\tgoto done;\n\n\t \n\tif (intvec.inta & rtlpriv->cfg->maps[RTL_IMR_TBDOK])\n\t\trtl_dbg(rtlpriv, COMP_INTR, DBG_TRACE,\n\t\t\t\"beacon ok interrupt!\\n\");\n\n\tif (unlikely(intvec.inta & rtlpriv->cfg->maps[RTL_IMR_TBDER]))\n\t\trtl_dbg(rtlpriv, COMP_INTR, DBG_TRACE,\n\t\t\t\"beacon err interrupt!\\n\");\n\n\tif (intvec.inta & rtlpriv->cfg->maps[RTL_IMR_BDOK])\n\t\trtl_dbg(rtlpriv, COMP_INTR, DBG_TRACE, \"beacon interrupt!\\n\");\n\n\tif (intvec.inta & rtlpriv->cfg->maps[RTL_IMR_BCNINT]) {\n\t\trtl_dbg(rtlpriv, COMP_INTR, DBG_TRACE,\n\t\t\t\"prepare beacon for interrupt!\\n\");\n\t\ttasklet_schedule(&rtlpriv->works.irq_prepare_bcn_tasklet);\n\t}\n\n\t \n\tif (unlikely(intvec.intb & rtlpriv->cfg->maps[RTL_IMR_TXFOVW]))\n\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_WARNING, \"IMR_TXFOVW!\\n\");\n\n\tif (intvec.inta & rtlpriv->cfg->maps[RTL_IMR_MGNTDOK]) {\n\t\trtl_dbg(rtlpriv, COMP_INTR, DBG_TRACE,\n\t\t\t\"Manage ok interrupt!\\n\");\n\t\t_rtl_pci_tx_isr(hw, MGNT_QUEUE);\n\t}\n\n\tif (intvec.inta & rtlpriv->cfg->maps[RTL_IMR_HIGHDOK]) {\n\t\trtl_dbg(rtlpriv, COMP_INTR, DBG_TRACE,\n\t\t\t\"HIGH_QUEUE ok interrupt!\\n\");\n\t\t_rtl_pci_tx_isr(hw, HIGH_QUEUE);\n\t}\n\n\tif (intvec.inta & rtlpriv->cfg->maps[RTL_IMR_BKDOK]) {\n\t\trtlpriv->link_info.num_tx_inperiod++;\n\n\t\trtl_dbg(rtlpriv, COMP_INTR, DBG_TRACE,\n\t\t\t\"BK Tx OK interrupt!\\n\");\n\t\t_rtl_pci_tx_isr(hw, BK_QUEUE);\n\t}\n\n\tif (intvec.inta & rtlpriv->cfg->maps[RTL_IMR_BEDOK]) {\n\t\trtlpriv->link_info.num_tx_inperiod++;\n\n\t\trtl_dbg(rtlpriv, COMP_INTR, DBG_TRACE,\n\t\t\t\"BE TX OK interrupt!\\n\");\n\t\t_rtl_pci_tx_isr(hw, BE_QUEUE);\n\t}\n\n\tif (intvec.inta & rtlpriv->cfg->maps[RTL_IMR_VIDOK]) {\n\t\trtlpriv->link_info.num_tx_inperiod++;\n\n\t\trtl_dbg(rtlpriv, COMP_INTR, DBG_TRACE,\n\t\t\t\"VI TX OK interrupt!\\n\");\n\t\t_rtl_pci_tx_isr(hw, VI_QUEUE);\n\t}\n\n\tif (intvec.inta & rtlpriv->cfg->maps[RTL_IMR_VODOK]) {\n\t\trtlpriv->link_info.num_tx_inperiod++;\n\n\t\trtl_dbg(rtlpriv, COMP_INTR, DBG_TRACE,\n\t\t\t\"Vo TX OK interrupt!\\n\");\n\t\t_rtl_pci_tx_isr(hw, VO_QUEUE);\n\t}\n\n\tif (rtlhal->hw_type == HARDWARE_TYPE_RTL8822BE) {\n\t\tif (intvec.intd & rtlpriv->cfg->maps[RTL_IMR_H2CDOK]) {\n\t\t\trtlpriv->link_info.num_tx_inperiod++;\n\n\t\t\trtl_dbg(rtlpriv, COMP_INTR, DBG_TRACE,\n\t\t\t\t\"H2C TX OK interrupt!\\n\");\n\t\t\t_rtl_pci_tx_isr(hw, H2C_QUEUE);\n\t\t}\n\t}\n\n\tif (rtlhal->hw_type == HARDWARE_TYPE_RTL8192SE) {\n\t\tif (intvec.inta & rtlpriv->cfg->maps[RTL_IMR_COMDOK]) {\n\t\t\trtlpriv->link_info.num_tx_inperiod++;\n\n\t\t\trtl_dbg(rtlpriv, COMP_INTR, DBG_TRACE,\n\t\t\t\t\"CMD TX OK interrupt!\\n\");\n\t\t\t_rtl_pci_tx_isr(hw, TXCMD_QUEUE);\n\t\t}\n\t}\n\n\t \n\tif (intvec.inta & rtlpriv->cfg->maps[RTL_IMR_ROK]) {\n\t\trtl_dbg(rtlpriv, COMP_INTR, DBG_TRACE, \"Rx ok interrupt!\\n\");\n\t\t_rtl_pci_rx_interrupt(hw);\n\t}\n\n\tif (unlikely(intvec.inta & rtlpriv->cfg->maps[RTL_IMR_RDU])) {\n\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_WARNING,\n\t\t\t\"rx descriptor unavailable!\\n\");\n\t\t_rtl_pci_rx_interrupt(hw);\n\t}\n\n\tif (unlikely(intvec.intb & rtlpriv->cfg->maps[RTL_IMR_RXFOVW])) {\n\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_WARNING, \"rx overflow !\\n\");\n\t\t_rtl_pci_rx_interrupt(hw);\n\t}\n\n\t \n\tif (rtlhal->hw_type == HARDWARE_TYPE_RTL8723AE) {\n\t\tif (intvec.inta & rtlpriv->cfg->maps[RTL_IMR_C2HCMD]) {\n\t\t\trtl_dbg(rtlpriv, COMP_INTR, DBG_TRACE,\n\t\t\t\t\"firmware interrupt!\\n\");\n\t\t\tqueue_delayed_work(rtlpriv->works.rtl_wq,\n\t\t\t\t\t   &rtlpriv->works.fwevt_wq, 0);\n\t\t}\n\t}\n\n\t \n\t \n\tif (rtlhal->hw_type == HARDWARE_TYPE_RTL8188EE ||\n\t    rtlhal->hw_type == HARDWARE_TYPE_RTL8723BE) {\n\t\tif (unlikely(intvec.inta &\n\t\t    rtlpriv->cfg->maps[RTL_IMR_HSISR_IND])) {\n\t\t\trtl_dbg(rtlpriv, COMP_INTR, DBG_TRACE,\n\t\t\t\t\"hsisr interrupt!\\n\");\n\t\t\t_rtl_pci_hs_interrupt(hw);\n\t\t}\n\t}\n\n\tif (rtlpriv->rtlhal.earlymode_enable)\n\t\ttasklet_schedule(&rtlpriv->works.irq_tasklet);\n\ndone:\n\trtlpriv->cfg->ops->enable_interrupt(hw);\n\tspin_unlock_irqrestore(&rtlpriv->locks.irq_th_lock, flags);\n\treturn ret;\n}\n\nstatic void _rtl_pci_irq_tasklet(struct tasklet_struct *t)\n{\n\tstruct rtl_priv *rtlpriv = from_tasklet(rtlpriv, t, works.irq_tasklet);\n\tstruct ieee80211_hw *hw = rtlpriv->hw;\n\t_rtl_pci_tx_chk_waitq(hw);\n}\n\nstatic void _rtl_pci_prepare_bcn_tasklet(struct tasklet_struct *t)\n{\n\tstruct rtl_priv *rtlpriv = from_tasklet(rtlpriv, t,\n\t\t\t\t\t\tworks.irq_prepare_bcn_tasklet);\n\tstruct ieee80211_hw *hw = rtlpriv->hw;\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl8192_tx_ring *ring = NULL;\n\tstruct ieee80211_hdr *hdr = NULL;\n\tstruct ieee80211_tx_info *info = NULL;\n\tstruct sk_buff *pskb = NULL;\n\tstruct rtl_tx_desc *pdesc = NULL;\n\tstruct rtl_tcb_desc tcb_desc;\n\t \n\tstruct rtl_tx_buffer_desc *pbuffer_desc = NULL;\n\tu8 temp_one = 1;\n\tu8 *entry;\n\n\tmemset(&tcb_desc, 0, sizeof(struct rtl_tcb_desc));\n\tring = &rtlpci->tx_ring[BEACON_QUEUE];\n\tpskb = __skb_dequeue(&ring->queue);\n\tif (rtlpriv->use_new_trx_flow)\n\t\tentry = (u8 *)(&ring->buffer_desc[ring->idx]);\n\telse\n\t\tentry = (u8 *)(&ring->desc[ring->idx]);\n\tif (pskb) {\n\t\tdma_unmap_single(&rtlpci->pdev->dev,\n\t\t\t\t rtlpriv->cfg->ops->get_desc(hw, (u8 *)entry,\n\t\t\t\t\t\ttrue, HW_DESC_TXBUFF_ADDR),\n\t\t\t\t pskb->len, DMA_TO_DEVICE);\n\t\tkfree_skb(pskb);\n\t}\n\n\t \n\tpskb = ieee80211_beacon_get(hw, mac->vif, 0);\n\tif (!pskb)\n\t\treturn;\n\thdr = rtl_get_hdr(pskb);\n\tinfo = IEEE80211_SKB_CB(pskb);\n\tpdesc = &ring->desc[0];\n\tif (rtlpriv->use_new_trx_flow)\n\t\tpbuffer_desc = &ring->buffer_desc[0];\n\n\trtlpriv->cfg->ops->fill_tx_desc(hw, hdr, (u8 *)pdesc,\n\t\t\t\t\t(u8 *)pbuffer_desc, info, NULL, pskb,\n\t\t\t\t\tBEACON_QUEUE, &tcb_desc);\n\n\t__skb_queue_tail(&ring->queue, pskb);\n\n\tif (rtlpriv->use_new_trx_flow) {\n\t\ttemp_one = 4;\n\t\trtlpriv->cfg->ops->set_desc(hw, (u8 *)pbuffer_desc, true,\n\t\t\t\t\t    HW_DESC_OWN, (u8 *)&temp_one);\n\t} else {\n\t\trtlpriv->cfg->ops->set_desc(hw, (u8 *)pdesc, true, HW_DESC_OWN,\n\t\t\t\t\t    &temp_one);\n\t}\n}\n\nstatic void _rtl_pci_init_trx_var(struct ieee80211_hw *hw)\n{\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\n\tu8 i;\n\tu16 desc_num;\n\n\tif (rtlhal->hw_type == HARDWARE_TYPE_RTL8192EE)\n\t\tdesc_num = TX_DESC_NUM_92E;\n\telse if (rtlhal->hw_type == HARDWARE_TYPE_RTL8822BE)\n\t\tdesc_num = TX_DESC_NUM_8822B;\n\telse\n\t\tdesc_num = RT_TXDESC_NUM;\n\n\tfor (i = 0; i < RTL_PCI_MAX_TX_QUEUE_COUNT; i++)\n\t\trtlpci->txringcount[i] = desc_num;\n\n\t \n\trtlpci->txringcount[BEACON_QUEUE] = 2;\n\n\t \n\tif (!rtl_priv(hw)->use_new_trx_flow)\n\t\trtlpci->txringcount[BE_QUEUE] = RT_TXDESC_NUM_BE_QUEUE;\n\n\trtlpci->rxbuffersize = 9100;\t \n\trtlpci->rxringcount = RTL_PCI_MAX_RX_COUNT;\t \n}\n\nstatic void _rtl_pci_init_struct(struct ieee80211_hw *hw,\n\t\t\t\t struct pci_dev *pdev)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\n\trtlpci->up_first_time = true;\n\trtlpci->being_init_adapter = false;\n\n\trtlhal->hw = hw;\n\trtlpci->pdev = pdev;\n\n\t \n\t_rtl_pci_init_trx_var(hw);\n\n\t \n\tmac->beacon_interval = 100;\n\n\t \n\tmac->min_space_cfg = 0;\n\tmac->max_mss_density = 0;\n\t \n\tmac->current_ampdu_density = 7;\n\tmac->current_ampdu_factor = 3;\n\n\t \n\tmac->retry_short = 7;\n\tmac->retry_long = 7;\n\n\t \n\trtlpci->acm_method = EACMWAY2_SW;\n\n\t \n\ttasklet_setup(&rtlpriv->works.irq_tasklet, _rtl_pci_irq_tasklet);\n\ttasklet_setup(&rtlpriv->works.irq_prepare_bcn_tasklet,\n\t\t     _rtl_pci_prepare_bcn_tasklet);\n\tINIT_WORK(&rtlpriv->works.lps_change_work,\n\t\t  rtl_lps_change_work_callback);\n}\n\nstatic int _rtl_pci_init_tx_ring(struct ieee80211_hw *hw,\n\t\t\t\t unsigned int prio, unsigned int entries)\n{\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_tx_buffer_desc *buffer_desc;\n\tstruct rtl_tx_desc *desc;\n\tdma_addr_t buffer_desc_dma, desc_dma;\n\tu32 nextdescaddress;\n\tint i;\n\n\t \n\tif (rtlpriv->use_new_trx_flow) {\n\t\tbuffer_desc =\n\t\t   dma_alloc_coherent(&rtlpci->pdev->dev,\n\t\t\t\t      sizeof(*buffer_desc) * entries,\n\t\t\t\t      &buffer_desc_dma, GFP_KERNEL);\n\n\t\tif (!buffer_desc || (unsigned long)buffer_desc & 0xFF) {\n\t\t\tpr_err(\"Cannot allocate TX ring (prio = %d)\\n\",\n\t\t\t       prio);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\trtlpci->tx_ring[prio].buffer_desc = buffer_desc;\n\t\trtlpci->tx_ring[prio].buffer_desc_dma = buffer_desc_dma;\n\n\t\trtlpci->tx_ring[prio].cur_tx_rp = 0;\n\t\trtlpci->tx_ring[prio].cur_tx_wp = 0;\n\t}\n\n\t \n\tdesc = dma_alloc_coherent(&rtlpci->pdev->dev, sizeof(*desc) * entries,\n\t\t\t\t  &desc_dma, GFP_KERNEL);\n\n\tif (!desc || (unsigned long)desc & 0xFF) {\n\t\tpr_err(\"Cannot allocate TX ring (prio = %d)\\n\", prio);\n\t\treturn -ENOMEM;\n\t}\n\n\trtlpci->tx_ring[prio].desc = desc;\n\trtlpci->tx_ring[prio].dma = desc_dma;\n\n\trtlpci->tx_ring[prio].idx = 0;\n\trtlpci->tx_ring[prio].entries = entries;\n\tskb_queue_head_init(&rtlpci->tx_ring[prio].queue);\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD, \"queue:%d, ring_addr:%p\\n\",\n\t\tprio, desc);\n\n\t \n\tif (!rtlpriv->use_new_trx_flow) {\n\t\tfor (i = 0; i < entries; i++) {\n\t\t\tnextdescaddress = (u32)desc_dma +\n\t\t\t\t\t  ((i +\t1) % entries) *\n\t\t\t\t\t  sizeof(*desc);\n\n\t\t\trtlpriv->cfg->ops->set_desc(hw, (u8 *)&desc[i],\n\t\t\t\t\t\t    true,\n\t\t\t\t\t\t    HW_DESC_TX_NEXTDESC_ADDR,\n\t\t\t\t\t\t    (u8 *)&nextdescaddress);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int _rtl_pci_init_rx_ring(struct ieee80211_hw *hw, int rxring_idx)\n{\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tint i;\n\n\tif (rtlpriv->use_new_trx_flow) {\n\t\tstruct rtl_rx_buffer_desc *entry = NULL;\n\t\t \n\t\trtlpci->rx_ring[rxring_idx].buffer_desc =\n\t\t    dma_alloc_coherent(&rtlpci->pdev->dev,\n\t\t\t\t       sizeof(*rtlpci->rx_ring[rxring_idx].buffer_desc) *\n\t\t\t\t       rtlpci->rxringcount,\n\t\t\t\t       &rtlpci->rx_ring[rxring_idx].dma, GFP_KERNEL);\n\t\tif (!rtlpci->rx_ring[rxring_idx].buffer_desc ||\n\t\t    (ulong)rtlpci->rx_ring[rxring_idx].buffer_desc & 0xFF) {\n\t\t\tpr_err(\"Cannot allocate RX ring\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\t \n\t\trtlpci->rx_ring[rxring_idx].idx = 0;\n\t\tfor (i = 0; i < rtlpci->rxringcount; i++) {\n\t\t\tentry = &rtlpci->rx_ring[rxring_idx].buffer_desc[i];\n\t\t\tif (!_rtl_pci_init_one_rxdesc(hw, NULL, (u8 *)entry,\n\t\t\t\t\t\t      rxring_idx, i))\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t} else {\n\t\tstruct rtl_rx_desc *entry = NULL;\n\t\tu8 tmp_one = 1;\n\t\t \n\t\trtlpci->rx_ring[rxring_idx].desc =\n\t\t    dma_alloc_coherent(&rtlpci->pdev->dev,\n\t\t\t\t       sizeof(*rtlpci->rx_ring[rxring_idx].desc) *\n\t\t\t\t       rtlpci->rxringcount,\n\t\t\t\t       &rtlpci->rx_ring[rxring_idx].dma, GFP_KERNEL);\n\t\tif (!rtlpci->rx_ring[rxring_idx].desc ||\n\t\t    (unsigned long)rtlpci->rx_ring[rxring_idx].desc & 0xFF) {\n\t\t\tpr_err(\"Cannot allocate RX ring\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\t \n\t\trtlpci->rx_ring[rxring_idx].idx = 0;\n\n\t\tfor (i = 0; i < rtlpci->rxringcount; i++) {\n\t\t\tentry = &rtlpci->rx_ring[rxring_idx].desc[i];\n\t\t\tif (!_rtl_pci_init_one_rxdesc(hw, NULL, (u8 *)entry,\n\t\t\t\t\t\t      rxring_idx, i))\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\trtlpriv->cfg->ops->set_desc(hw, (u8 *)entry, false,\n\t\t\t\t\t    HW_DESC_RXERO, &tmp_one);\n\t}\n\treturn 0;\n}\n\nstatic void _rtl_pci_free_tx_ring(struct ieee80211_hw *hw,\n\t\t\t\t  unsigned int prio)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tstruct rtl8192_tx_ring *ring = &rtlpci->tx_ring[prio];\n\n\t \n\twhile (skb_queue_len(&ring->queue)) {\n\t\tu8 *entry;\n\t\tstruct sk_buff *skb = __skb_dequeue(&ring->queue);\n\n\t\tif (rtlpriv->use_new_trx_flow)\n\t\t\tentry = (u8 *)(&ring->buffer_desc[ring->idx]);\n\t\telse\n\t\t\tentry = (u8 *)(&ring->desc[ring->idx]);\n\n\t\tdma_unmap_single(&rtlpci->pdev->dev,\n\t\t\t\t rtlpriv->cfg->ops->get_desc(hw, (u8 *)entry,\n\t\t\t\t\t\ttrue, HW_DESC_TXBUFF_ADDR),\n\t\t\t\t skb->len, DMA_TO_DEVICE);\n\t\tkfree_skb(skb);\n\t\tring->idx = (ring->idx + 1) % ring->entries;\n\t}\n\n\t \n\tdma_free_coherent(&rtlpci->pdev->dev,\n\t\t\t  sizeof(*ring->desc) * ring->entries, ring->desc,\n\t\t\t  ring->dma);\n\tring->desc = NULL;\n\tif (rtlpriv->use_new_trx_flow) {\n\t\tdma_free_coherent(&rtlpci->pdev->dev,\n\t\t\t\t  sizeof(*ring->buffer_desc) * ring->entries,\n\t\t\t\t  ring->buffer_desc, ring->buffer_desc_dma);\n\t\tring->buffer_desc = NULL;\n\t}\n}\n\nstatic void _rtl_pci_free_rx_ring(struct ieee80211_hw *hw, int rxring_idx)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tint i;\n\n\t \n\tfor (i = 0; i < rtlpci->rxringcount; i++) {\n\t\tstruct sk_buff *skb = rtlpci->rx_ring[rxring_idx].rx_buf[i];\n\n\t\tif (!skb)\n\t\t\tcontinue;\n\t\tdma_unmap_single(&rtlpci->pdev->dev, *((dma_addr_t *)skb->cb),\n\t\t\t\t rtlpci->rxbuffersize, DMA_FROM_DEVICE);\n\t\tkfree_skb(skb);\n\t}\n\n\t \n\tif (rtlpriv->use_new_trx_flow) {\n\t\tdma_free_coherent(&rtlpci->pdev->dev,\n\t\t\t\t  sizeof(*rtlpci->rx_ring[rxring_idx].buffer_desc) *\n\t\t\t\t  rtlpci->rxringcount,\n\t\t\t\t  rtlpci->rx_ring[rxring_idx].buffer_desc,\n\t\t\t\t  rtlpci->rx_ring[rxring_idx].dma);\n\t\trtlpci->rx_ring[rxring_idx].buffer_desc = NULL;\n\t} else {\n\t\tdma_free_coherent(&rtlpci->pdev->dev,\n\t\t\t\t  sizeof(*rtlpci->rx_ring[rxring_idx].desc) *\n\t\t\t\t  rtlpci->rxringcount,\n\t\t\t\t  rtlpci->rx_ring[rxring_idx].desc,\n\t\t\t\t  rtlpci->rx_ring[rxring_idx].dma);\n\t\trtlpci->rx_ring[rxring_idx].desc = NULL;\n\t}\n}\n\nstatic int _rtl_pci_init_trx_ring(struct ieee80211_hw *hw)\n{\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tint ret;\n\tint i, rxring_idx;\n\n\t \n\tfor (rxring_idx = 0; rxring_idx < RTL_PCI_MAX_RX_QUEUE; rxring_idx++) {\n\t\tret = _rtl_pci_init_rx_ring(hw, rxring_idx);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < RTL_PCI_MAX_TX_QUEUE_COUNT; i++) {\n\t\tret = _rtl_pci_init_tx_ring(hw, i, rtlpci->txringcount[i]);\n\t\tif (ret)\n\t\t\tgoto err_free_rings;\n\t}\n\n\treturn 0;\n\nerr_free_rings:\n\tfor (rxring_idx = 0; rxring_idx < RTL_PCI_MAX_RX_QUEUE; rxring_idx++)\n\t\t_rtl_pci_free_rx_ring(hw, rxring_idx);\n\n\tfor (i = 0; i < RTL_PCI_MAX_TX_QUEUE_COUNT; i++)\n\t\tif (rtlpci->tx_ring[i].desc ||\n\t\t    rtlpci->tx_ring[i].buffer_desc)\n\t\t\t_rtl_pci_free_tx_ring(hw, i);\n\n\treturn 1;\n}\n\nstatic int _rtl_pci_deinit_trx_ring(struct ieee80211_hw *hw)\n{\n\tu32 i, rxring_idx;\n\n\t \n\tfor (rxring_idx = 0; rxring_idx < RTL_PCI_MAX_RX_QUEUE; rxring_idx++)\n\t\t_rtl_pci_free_rx_ring(hw, rxring_idx);\n\n\t \n\tfor (i = 0; i < RTL_PCI_MAX_TX_QUEUE_COUNT; i++)\n\t\t_rtl_pci_free_tx_ring(hw, i);\n\n\treturn 0;\n}\n\nint rtl_pci_reset_trx_ring(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tint i, rxring_idx;\n\tunsigned long flags;\n\tu8 tmp_one = 1;\n\tu32 bufferaddress;\n\t \n\t \n\tfor (rxring_idx = 0; rxring_idx < RTL_PCI_MAX_RX_QUEUE; rxring_idx++) {\n\t\t \n\t\tif (!rtlpriv->use_new_trx_flow &&\n\t\t    rtlpci->rx_ring[rxring_idx].desc) {\n\t\t\tstruct rtl_rx_desc *entry = NULL;\n\n\t\t\trtlpci->rx_ring[rxring_idx].idx = 0;\n\t\t\tfor (i = 0; i < rtlpci->rxringcount; i++) {\n\t\t\t\tentry = &rtlpci->rx_ring[rxring_idx].desc[i];\n\t\t\t\tbufferaddress =\n\t\t\t\t  rtlpriv->cfg->ops->get_desc(hw, (u8 *)entry,\n\t\t\t\t  false, HW_DESC_RXBUFF_ADDR);\n\t\t\t\tmemset((u8 *)entry, 0,\n\t\t\t\t       sizeof(*rtlpci->rx_ring\n\t\t\t\t       [rxring_idx].desc)); \n\t\t\t\tif (rtlpriv->use_new_trx_flow) {\n\t\t\t\t\trtlpriv->cfg->ops->set_desc(hw,\n\t\t\t\t\t    (u8 *)entry, false,\n\t\t\t\t\t    HW_DESC_RX_PREPARE,\n\t\t\t\t\t    (u8 *)&bufferaddress);\n\t\t\t\t} else {\n\t\t\t\t\trtlpriv->cfg->ops->set_desc(hw,\n\t\t\t\t\t    (u8 *)entry, false,\n\t\t\t\t\t    HW_DESC_RXBUFF_ADDR,\n\t\t\t\t\t    (u8 *)&bufferaddress);\n\t\t\t\t\trtlpriv->cfg->ops->set_desc(hw,\n\t\t\t\t\t    (u8 *)entry, false,\n\t\t\t\t\t    HW_DESC_RXPKT_LEN,\n\t\t\t\t\t    (u8 *)&rtlpci->rxbuffersize);\n\t\t\t\t\trtlpriv->cfg->ops->set_desc(hw,\n\t\t\t\t\t    (u8 *)entry, false,\n\t\t\t\t\t    HW_DESC_RXOWN,\n\t\t\t\t\t    (u8 *)&tmp_one);\n\t\t\t\t}\n\t\t\t}\n\t\t\trtlpriv->cfg->ops->set_desc(hw, (u8 *)entry, false,\n\t\t\t\t\t    HW_DESC_RXERO, (u8 *)&tmp_one);\n\t\t}\n\t\trtlpci->rx_ring[rxring_idx].idx = 0;\n\t}\n\n\t \n\tspin_lock_irqsave(&rtlpriv->locks.irq_th_lock, flags);\n\tfor (i = 0; i < RTL_PCI_MAX_TX_QUEUE_COUNT; i++) {\n\t\tif (rtlpci->tx_ring[i].desc ||\n\t\t    rtlpci->tx_ring[i].buffer_desc) {\n\t\t\tstruct rtl8192_tx_ring *ring = &rtlpci->tx_ring[i];\n\n\t\t\twhile (skb_queue_len(&ring->queue)) {\n\t\t\t\tu8 *entry;\n\t\t\t\tstruct sk_buff *skb =\n\t\t\t\t\t__skb_dequeue(&ring->queue);\n\t\t\t\tif (rtlpriv->use_new_trx_flow)\n\t\t\t\t\tentry = (u8 *)(&ring->buffer_desc\n\t\t\t\t\t\t\t\t[ring->idx]);\n\t\t\t\telse\n\t\t\t\t\tentry = (u8 *)(&ring->desc[ring->idx]);\n\n\t\t\t\tdma_unmap_single(&rtlpci->pdev->dev,\n\t\t\t\t\t\t rtlpriv->cfg->ops->get_desc(hw, (u8 *)entry,\n\t\t\t\t\t\t\t\ttrue, HW_DESC_TXBUFF_ADDR),\n\t\t\t\t\t\t skb->len, DMA_TO_DEVICE);\n\t\t\t\tdev_kfree_skb_irq(skb);\n\t\t\t\tring->idx = (ring->idx + 1) % ring->entries;\n\t\t\t}\n\n\t\t\tif (rtlpriv->use_new_trx_flow) {\n\t\t\t\trtlpci->tx_ring[i].cur_tx_rp = 0;\n\t\t\t\trtlpci->tx_ring[i].cur_tx_wp = 0;\n\t\t\t}\n\n\t\t\tring->idx = 0;\n\t\t\tring->entries = rtlpci->txringcount[i];\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&rtlpriv->locks.irq_th_lock, flags);\n\n\treturn 0;\n}\n\nstatic bool rtl_pci_tx_chk_waitq_insert(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_sta *sta,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_sta_info *sta_entry = NULL;\n\tu8 tid = rtl_get_tid(skb);\n\t__le16 fc = rtl_get_fc(skb);\n\n\tif (!sta)\n\t\treturn false;\n\tsta_entry = (struct rtl_sta_info *)sta->drv_priv;\n\n\tif (!rtlpriv->rtlhal.earlymode_enable)\n\t\treturn false;\n\tif (ieee80211_is_nullfunc(fc))\n\t\treturn false;\n\tif (ieee80211_is_qos_nullfunc(fc))\n\t\treturn false;\n\tif (ieee80211_is_pspoll(fc))\n\t\treturn false;\n\tif (sta_entry->tids[tid].agg.agg_state != RTL_AGG_OPERATIONAL)\n\t\treturn false;\n\tif (_rtl_mac_to_hwqueue(hw, skb) > VO_QUEUE)\n\t\treturn false;\n\tif (tid > 7)\n\t\treturn false;\n\n\t \n\tif (!rtlpriv->link_info.higher_busytxtraffic[tid])\n\t\treturn false;\n\n\tspin_lock_bh(&rtlpriv->locks.waitq_lock);\n\tskb_queue_tail(&rtlpriv->mac80211.skb_waitq[tid], skb);\n\tspin_unlock_bh(&rtlpriv->locks.waitq_lock);\n\n\treturn true;\n}\n\nstatic int rtl_pci_tx(struct ieee80211_hw *hw,\n\t\t      struct ieee80211_sta *sta,\n\t\t      struct sk_buff *skb,\n\t\t      struct rtl_tcb_desc *ptcb_desc)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct rtl8192_tx_ring *ring;\n\tstruct rtl_tx_desc *pdesc;\n\tstruct rtl_tx_buffer_desc *ptx_bd_desc = NULL;\n\tu16 idx;\n\tu8 hw_queue = _rtl_mac_to_hwqueue(hw, skb);\n\tunsigned long flags;\n\tstruct ieee80211_hdr *hdr = rtl_get_hdr(skb);\n\t__le16 fc = rtl_get_fc(skb);\n\tu8 *pda_addr = hdr->addr1;\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tu8 own;\n\tu8 temp_one = 1;\n\n\tif (ieee80211_is_mgmt(fc))\n\t\trtl_tx_mgmt_proc(hw, skb);\n\n\tif (rtlpriv->psc.sw_ps_enabled) {\n\t\tif (ieee80211_is_data(fc) && !ieee80211_is_nullfunc(fc) &&\n\t\t    !ieee80211_has_pm(fc))\n\t\t\thdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_PM);\n\t}\n\n\trtl_action_proc(hw, skb, true);\n\n\tif (is_multicast_ether_addr(pda_addr))\n\t\trtlpriv->stats.txbytesmulticast += skb->len;\n\telse if (is_broadcast_ether_addr(pda_addr))\n\t\trtlpriv->stats.txbytesbroadcast += skb->len;\n\telse\n\t\trtlpriv->stats.txbytesunicast += skb->len;\n\n\tspin_lock_irqsave(&rtlpriv->locks.irq_th_lock, flags);\n\tring = &rtlpci->tx_ring[hw_queue];\n\tif (hw_queue != BEACON_QUEUE) {\n\t\tif (rtlpriv->use_new_trx_flow)\n\t\t\tidx = ring->cur_tx_wp;\n\t\telse\n\t\t\tidx = (ring->idx + skb_queue_len(&ring->queue)) %\n\t\t\t      ring->entries;\n\t} else {\n\t\tidx = 0;\n\t}\n\n\tpdesc = &ring->desc[idx];\n\tif (rtlpriv->use_new_trx_flow) {\n\t\tptx_bd_desc = &ring->buffer_desc[idx];\n\t} else {\n\t\town = (u8)rtlpriv->cfg->ops->get_desc(hw, (u8 *)pdesc,\n\t\t\t\ttrue, HW_DESC_OWN);\n\n\t\tif (own == 1 && hw_queue != BEACON_QUEUE) {\n\t\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_WARNING,\n\t\t\t\t\"No more TX desc@%d, ring->idx = %d, idx = %d, skb_queue_len = 0x%x\\n\",\n\t\t\t\thw_queue, ring->idx, idx,\n\t\t\t\tskb_queue_len(&ring->queue));\n\n\t\t\tspin_unlock_irqrestore(&rtlpriv->locks.irq_th_lock,\n\t\t\t\t\t       flags);\n\t\t\treturn skb->len;\n\t\t}\n\t}\n\n\tif (rtlpriv->cfg->ops->get_available_desc &&\n\t    rtlpriv->cfg->ops->get_available_desc(hw, hw_queue) == 0) {\n\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_WARNING,\n\t\t\t\"get_available_desc fail\\n\");\n\t\tspin_unlock_irqrestore(&rtlpriv->locks.irq_th_lock, flags);\n\t\treturn skb->len;\n\t}\n\n\tif (ieee80211_is_data(fc))\n\t\trtlpriv->cfg->ops->led_control(hw, LED_CTL_TX);\n\n\trtlpriv->cfg->ops->fill_tx_desc(hw, hdr, (u8 *)pdesc,\n\t\t\t(u8 *)ptx_bd_desc, info, sta, skb, hw_queue, ptcb_desc);\n\n\t__skb_queue_tail(&ring->queue, skb);\n\n\tif (rtlpriv->use_new_trx_flow) {\n\t\trtlpriv->cfg->ops->set_desc(hw, (u8 *)pdesc, true,\n\t\t\t\t\t    HW_DESC_OWN, &hw_queue);\n\t} else {\n\t\trtlpriv->cfg->ops->set_desc(hw, (u8 *)pdesc, true,\n\t\t\t\t\t    HW_DESC_OWN, &temp_one);\n\t}\n\n\tif ((ring->entries - skb_queue_len(&ring->queue)) < 2 &&\n\t    hw_queue != BEACON_QUEUE) {\n\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_LOUD,\n\t\t\t\"less desc left, stop skb_queue@%d, ring->idx = %d, idx = %d, skb_queue_len = 0x%x\\n\",\n\t\t\t hw_queue, ring->idx, idx,\n\t\t\t skb_queue_len(&ring->queue));\n\n\t\tieee80211_stop_queue(hw, skb_get_queue_mapping(skb));\n\t}\n\n\tspin_unlock_irqrestore(&rtlpriv->locks.irq_th_lock, flags);\n\n\trtlpriv->cfg->ops->tx_polling(hw, hw_queue);\n\n\treturn 0;\n}\n\nstatic void rtl_pci_flush(struct ieee80211_hw *hw, u32 queues, bool drop)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci_priv *pcipriv = rtl_pcipriv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tu16 i = 0;\n\tint queue_id;\n\tstruct rtl8192_tx_ring *ring;\n\n\tif (mac->skip_scan)\n\t\treturn;\n\n\tfor (queue_id = RTL_PCI_MAX_TX_QUEUE_COUNT - 1; queue_id >= 0;) {\n\t\tu32 queue_len;\n\n\t\tif (((queues >> queue_id) & 0x1) == 0) {\n\t\t\tqueue_id--;\n\t\t\tcontinue;\n\t\t}\n\t\tring = &pcipriv->dev.tx_ring[queue_id];\n\t\tqueue_len = skb_queue_len(&ring->queue);\n\t\tif (queue_len == 0 || queue_id == BEACON_QUEUE ||\n\t\t    queue_id == TXCMD_QUEUE) {\n\t\t\tqueue_id--;\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tmsleep(20);\n\t\t\ti++;\n\t\t}\n\n\t\t \n\t\tif (rtlpriv->psc.rfpwr_state == ERFOFF ||\n\t\t    is_hal_stop(rtlhal) || i >= 200)\n\t\t\treturn;\n\t}\n}\n\nstatic void rtl_pci_deinit(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\n\t_rtl_pci_deinit_trx_ring(hw);\n\n\tsynchronize_irq(rtlpci->pdev->irq);\n\ttasklet_kill(&rtlpriv->works.irq_tasklet);\n\tcancel_work_sync(&rtlpriv->works.lps_change_work);\n\n\tdestroy_workqueue(rtlpriv->works.rtl_wq);\n}\n\nstatic int rtl_pci_init(struct ieee80211_hw *hw, struct pci_dev *pdev)\n{\n\tint err;\n\n\t_rtl_pci_init_struct(hw, pdev);\n\n\terr = _rtl_pci_init_trx_ring(hw);\n\tif (err) {\n\t\tpr_err(\"tx ring initialization failed\\n\");\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int rtl_pci_start(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tstruct rtl_mac *rtlmac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_btc_ops *btc_ops = rtlpriv->btcoexist.btc_ops;\n\n\tint err;\n\n\trtl_pci_reset_trx_ring(hw);\n\n\trtlpci->driver_is_goingto_unload = false;\n\tif (rtlpriv->cfg->ops->get_btc_status &&\n\t    rtlpriv->cfg->ops->get_btc_status()) {\n\t\trtlpriv->btcoexist.btc_info.ap_num = 36;\n\t\tbtc_ops->btc_init_variables(rtlpriv);\n\t\tbtc_ops->btc_init_hal_vars(rtlpriv);\n\t} else if (btc_ops) {\n\t\tbtc_ops->btc_init_variables_wifi_only(rtlpriv);\n\t}\n\n\terr = rtlpriv->cfg->ops->hw_init(hw);\n\tif (err) {\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG,\n\t\t\t\"Failed to config hardware!\\n\");\n\t\tkfree(rtlpriv->btcoexist.btc_context);\n\t\tkfree(rtlpriv->btcoexist.wifi_only_context);\n\t\treturn err;\n\t}\n\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_RETRY_LIMIT,\n\t\t\t&rtlmac->retry_long);\n\n\trtlpriv->cfg->ops->enable_interrupt(hw);\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD, \"enable_interrupt OK\\n\");\n\n\trtl_init_rx_config(hw);\n\n\t \n\tset_hal_start(rtlhal);\n\n\tRT_CLEAR_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_HALT_NIC);\n\n\trtlpci->up_first_time = false;\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG, \"%s OK\\n\", __func__);\n\treturn 0;\n}\n\nstatic void rtl_pci_stop(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tunsigned long flags;\n\tu8 rf_timeout = 0;\n\n\tif (rtlpriv->cfg->ops->get_btc_status())\n\t\trtlpriv->btcoexist.btc_ops->btc_halt_notify(rtlpriv);\n\n\tif (rtlpriv->btcoexist.btc_ops)\n\t\trtlpriv->btcoexist.btc_ops->btc_deinit_variables(rtlpriv);\n\n\t \n\tset_hal_stop(rtlhal);\n\n\trtlpci->driver_is_goingto_unload = true;\n\trtlpriv->cfg->ops->disable_interrupt(hw);\n\tcancel_work_sync(&rtlpriv->works.lps_change_work);\n\n\tspin_lock_irqsave(&rtlpriv->locks.rf_ps_lock, flags);\n\twhile (ppsc->rfchange_inprogress) {\n\t\tspin_unlock_irqrestore(&rtlpriv->locks.rf_ps_lock, flags);\n\t\tif (rf_timeout > 100) {\n\t\t\tspin_lock_irqsave(&rtlpriv->locks.rf_ps_lock, flags);\n\t\t\tbreak;\n\t\t}\n\t\tmdelay(1);\n\t\trf_timeout++;\n\t\tspin_lock_irqsave(&rtlpriv->locks.rf_ps_lock, flags);\n\t}\n\tppsc->rfchange_inprogress = true;\n\tspin_unlock_irqrestore(&rtlpriv->locks.rf_ps_lock, flags);\n\n\trtlpriv->cfg->ops->hw_disable(hw);\n\t \n\tif (!rtlpriv->max_fw_size)\n\t\treturn;\n\trtlpriv->cfg->ops->led_control(hw, LED_CTL_POWER_OFF);\n\n\tspin_lock_irqsave(&rtlpriv->locks.rf_ps_lock, flags);\n\tppsc->rfchange_inprogress = false;\n\tspin_unlock_irqrestore(&rtlpriv->locks.rf_ps_lock, flags);\n\n\trtl_pci_enable_aspm(hw);\n}\n\nstatic bool _rtl_pci_find_adapter(struct pci_dev *pdev,\n\t\t\t\t  struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci_priv *pcipriv = rtl_pcipriv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct pci_dev *bridge_pdev = pdev->bus->self;\n\tu16 venderid;\n\tu16 deviceid;\n\tu8 revisionid;\n\tu16 irqline;\n\tu8 tmp;\n\n\tpcipriv->ndis_adapter.pcibridge_vendor = PCI_BRIDGE_VENDOR_UNKNOWN;\n\tvenderid = pdev->vendor;\n\tdeviceid = pdev->device;\n\tpci_read_config_byte(pdev, 0x8, &revisionid);\n\tpci_read_config_word(pdev, 0x3C, &irqline);\n\n\t \n\tif (deviceid == RTL_PCI_8192SE_DID &&\n\t    revisionid == RTL_PCI_REVISION_ID_8192PCIE)\n\t\treturn false;\n\n\tif (deviceid == RTL_PCI_8192_DID ||\n\t    deviceid == RTL_PCI_0044_DID ||\n\t    deviceid == RTL_PCI_0047_DID ||\n\t    deviceid == RTL_PCI_8192SE_DID ||\n\t    deviceid == RTL_PCI_8174_DID ||\n\t    deviceid == RTL_PCI_8173_DID ||\n\t    deviceid == RTL_PCI_8172_DID ||\n\t    deviceid == RTL_PCI_8171_DID) {\n\t\tswitch (revisionid) {\n\t\tcase RTL_PCI_REVISION_ID_8192PCIE:\n\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG,\n\t\t\t\t\"8192 PCI-E is found - vid/did=%x/%x\\n\",\n\t\t\t\tvenderid, deviceid);\n\t\t\trtlhal->hw_type = HARDWARE_TYPE_RTL8192E;\n\t\t\treturn false;\n\t\tcase RTL_PCI_REVISION_ID_8192SE:\n\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG,\n\t\t\t\t\"8192SE is found - vid/did=%x/%x\\n\",\n\t\t\t\tvenderid, deviceid);\n\t\t\trtlhal->hw_type = HARDWARE_TYPE_RTL8192SE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_WARNING,\n\t\t\t\t\"Err: Unknown device - vid/did=%x/%x\\n\",\n\t\t\t\tvenderid, deviceid);\n\t\t\trtlhal->hw_type = HARDWARE_TYPE_RTL8192SE;\n\t\t\tbreak;\n\t\t}\n\t} else if (deviceid == RTL_PCI_8723AE_DID) {\n\t\trtlhal->hw_type = HARDWARE_TYPE_RTL8723AE;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG,\n\t\t\t\"8723AE PCI-E is found - vid/did=%x/%x\\n\",\n\t\t\tvenderid, deviceid);\n\t} else if (deviceid == RTL_PCI_8192CET_DID ||\n\t\t   deviceid == RTL_PCI_8192CE_DID ||\n\t\t   deviceid == RTL_PCI_8191CE_DID ||\n\t\t   deviceid == RTL_PCI_8188CE_DID) {\n\t\trtlhal->hw_type = HARDWARE_TYPE_RTL8192CE;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG,\n\t\t\t\"8192C PCI-E is found - vid/did=%x/%x\\n\",\n\t\t\tvenderid, deviceid);\n\t} else if (deviceid == RTL_PCI_8192DE_DID ||\n\t\t   deviceid == RTL_PCI_8192DE_DID2) {\n\t\trtlhal->hw_type = HARDWARE_TYPE_RTL8192DE;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG,\n\t\t\t\"8192D PCI-E is found - vid/did=%x/%x\\n\",\n\t\t\tvenderid, deviceid);\n\t} else if (deviceid == RTL_PCI_8188EE_DID) {\n\t\trtlhal->hw_type = HARDWARE_TYPE_RTL8188EE;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\"Find adapter, Hardware type is 8188EE\\n\");\n\t} else if (deviceid == RTL_PCI_8723BE_DID) {\n\t\trtlhal->hw_type = HARDWARE_TYPE_RTL8723BE;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\"Find adapter, Hardware type is 8723BE\\n\");\n\t} else if (deviceid == RTL_PCI_8192EE_DID) {\n\t\trtlhal->hw_type = HARDWARE_TYPE_RTL8192EE;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\"Find adapter, Hardware type is 8192EE\\n\");\n\t} else if (deviceid == RTL_PCI_8821AE_DID) {\n\t\trtlhal->hw_type = HARDWARE_TYPE_RTL8821AE;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\"Find adapter, Hardware type is 8821AE\\n\");\n\t} else if (deviceid == RTL_PCI_8812AE_DID) {\n\t\trtlhal->hw_type = HARDWARE_TYPE_RTL8812AE;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\"Find adapter, Hardware type is 8812AE\\n\");\n\t} else if (deviceid == RTL_PCI_8822BE_DID) {\n\t\trtlhal->hw_type = HARDWARE_TYPE_RTL8822BE;\n\t\trtlhal->bandset = BAND_ON_BOTH;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\"Find adapter, Hardware type is 8822BE\\n\");\n\t} else {\n\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_WARNING,\n\t\t\t\"Err: Unknown device - vid/did=%x/%x\\n\",\n\t\t\t venderid, deviceid);\n\n\t\trtlhal->hw_type = RTL_DEFAULT_HARDWARE_TYPE;\n\t}\n\n\tif (rtlhal->hw_type == HARDWARE_TYPE_RTL8192DE) {\n\t\tif (revisionid == 0 || revisionid == 1) {\n\t\t\tif (revisionid == 0) {\n\t\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\t\t\"Find 92DE MAC0\\n\");\n\t\t\t\trtlhal->interfaceindex = 0;\n\t\t\t} else if (revisionid == 1) {\n\t\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\t\t\"Find 92DE MAC1\\n\");\n\t\t\t\trtlhal->interfaceindex = 1;\n\t\t\t}\n\t\t} else {\n\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\t\"Unknown device - VendorID/DeviceID=%x/%x, Revision=%x\\n\",\n\t\t\t\t venderid, deviceid, revisionid);\n\t\t\trtlhal->interfaceindex = 0;\n\t\t}\n\t}\n\n\tswitch (rtlhal->hw_type) {\n\tcase HARDWARE_TYPE_RTL8192EE:\n\tcase HARDWARE_TYPE_RTL8822BE:\n\t\t \n\t\trtlpriv->use_new_trx_flow = true;\n\t\tbreak;\n\n\tdefault:\n\t\trtlpriv->use_new_trx_flow = false;\n\t\tbreak;\n\t}\n\n\t \n\tpcipriv->ndis_adapter.busnumber = pdev->bus->number;\n\tpcipriv->ndis_adapter.devnumber = PCI_SLOT(pdev->devfn);\n\tpcipriv->ndis_adapter.funcnumber = PCI_FUNC(pdev->devfn);\n\n\t \n\tpcipriv->ndis_adapter.pcibridge_vendor = PCI_BRIDGE_VENDOR_UNKNOWN;\n\t \n\tif (bridge_pdev) {\n\t\t \n\t\tpcipriv->ndis_adapter.pcibridge_vendorid = bridge_pdev->vendor;\n\t\tfor (tmp = 0; tmp < PCI_BRIDGE_VENDOR_MAX; tmp++) {\n\t\t\tif (bridge_pdev->vendor == pcibridge_vendors[tmp]) {\n\t\t\t\tpcipriv->ndis_adapter.pcibridge_vendor = tmp;\n\t\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG,\n\t\t\t\t\t\"Pci Bridge Vendor is found index: %d\\n\",\n\t\t\t\t\ttmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pcipriv->ndis_adapter.pcibridge_vendor !=\n\t\tPCI_BRIDGE_VENDOR_UNKNOWN) {\n\t\tpcipriv->ndis_adapter.pcibridge_busnum =\n\t\t    bridge_pdev->bus->number;\n\t\tpcipriv->ndis_adapter.pcibridge_devnum =\n\t\t    PCI_SLOT(bridge_pdev->devfn);\n\t\tpcipriv->ndis_adapter.pcibridge_funcnum =\n\t\t    PCI_FUNC(bridge_pdev->devfn);\n\n\t\tif (pcipriv->ndis_adapter.pcibridge_vendor ==\n\t\t    PCI_BRIDGE_VENDOR_AMD) {\n\t\t\tpcipriv->ndis_adapter.amd_l1_patch =\n\t\t\t    rtl_pci_get_amd_l1_patch(hw);\n\t\t}\n\t}\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG,\n\t\t\"pcidev busnumber:devnumber:funcnumber:vendor:link_ctl %d:%d:%d:%x:%x\\n\",\n\t\tpcipriv->ndis_adapter.busnumber,\n\t\tpcipriv->ndis_adapter.devnumber,\n\t\tpcipriv->ndis_adapter.funcnumber,\n\t\tpdev->vendor, pcipriv->ndis_adapter.linkctrl_reg);\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG,\n\t\t\"pci_bridge busnumber:devnumber:funcnumber:vendor:amd %d:%d:%d:%x:%x\\n\",\n\t\tpcipriv->ndis_adapter.pcibridge_busnum,\n\t\tpcipriv->ndis_adapter.pcibridge_devnum,\n\t\tpcipriv->ndis_adapter.pcibridge_funcnum,\n\t\tpcibridge_vendors[pcipriv->ndis_adapter.pcibridge_vendor],\n\t\tpcipriv->ndis_adapter.amd_l1_patch);\n\n\trtl_pci_parse_configuration(pdev, hw);\n\tlist_add_tail(&rtlpriv->list, &rtlpriv->glb_var->glb_priv_list);\n\n\treturn true;\n}\n\nstatic int rtl_pci_intr_mode_msi(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci_priv *pcipriv = rtl_pcipriv(hw);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(pcipriv);\n\tint ret;\n\n\tret = pci_enable_msi(rtlpci->pdev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = request_irq(rtlpci->pdev->irq, &_rtl_pci_interrupt,\n\t\t\t  IRQF_SHARED, KBUILD_MODNAME, hw);\n\tif (ret < 0) {\n\t\tpci_disable_msi(rtlpci->pdev);\n\t\treturn ret;\n\t}\n\n\trtlpci->using_msi = true;\n\n\trtl_dbg(rtlpriv, COMP_INIT | COMP_INTR, DBG_DMESG,\n\t\t\"MSI Interrupt Mode!\\n\");\n\treturn 0;\n}\n\nstatic int rtl_pci_intr_mode_legacy(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci_priv *pcipriv = rtl_pcipriv(hw);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(pcipriv);\n\tint ret;\n\n\tret = request_irq(rtlpci->pdev->irq, &_rtl_pci_interrupt,\n\t\t\t  IRQF_SHARED, KBUILD_MODNAME, hw);\n\tif (ret < 0)\n\t\treturn ret;\n\n\trtlpci->using_msi = false;\n\trtl_dbg(rtlpriv, COMP_INIT | COMP_INTR, DBG_DMESG,\n\t\t\"Pin-based Interrupt Mode!\\n\");\n\treturn 0;\n}\n\nstatic int rtl_pci_intr_mode_decide(struct ieee80211_hw *hw)\n{\n\tstruct rtl_pci_priv *pcipriv = rtl_pcipriv(hw);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(pcipriv);\n\tint ret;\n\n\tif (rtlpci->msi_support) {\n\t\tret = rtl_pci_intr_mode_msi(hw);\n\t\tif (ret < 0)\n\t\t\tret = rtl_pci_intr_mode_legacy(hw);\n\t} else {\n\t\tret = rtl_pci_intr_mode_legacy(hw);\n\t}\n\treturn ret;\n}\n\nstatic void platform_enable_dma64(struct pci_dev *pdev, bool dma64)\n{\n\tu8\tvalue;\n\n\tpci_read_config_byte(pdev, 0x719, &value);\n\n\t \n\tif (dma64)\n\t\tvalue |= BIT(5);\n\telse\n\t\tvalue &= ~BIT(5);\n\n\tpci_write_config_byte(pdev, 0x719, value);\n}\n\nint rtl_pci_probe(struct pci_dev *pdev,\n\t\t  const struct pci_device_id *id)\n{\n\tstruct ieee80211_hw *hw = NULL;\n\n\tstruct rtl_priv *rtlpriv = NULL;\n\tstruct rtl_pci_priv *pcipriv = NULL;\n\tstruct rtl_pci *rtlpci;\n\tunsigned long pmem_start, pmem_len, pmem_flags;\n\tint err;\n\n\terr = pci_enable_device(pdev);\n\tif (err) {\n\t\tWARN_ONCE(true, \"%s : Cannot enable new PCI device\\n\",\n\t\t\t  pci_name(pdev));\n\t\treturn err;\n\t}\n\n\tif (((struct rtl_hal_cfg *)id->driver_data)->mod_params->dma64 &&\n\t    !dma_set_mask(&pdev->dev, DMA_BIT_MASK(64))) {\n\t\tif (dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(64))) {\n\t\t\tWARN_ONCE(true,\n\t\t\t\t  \"Unable to obtain 64bit DMA for consistent allocations\\n\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto fail1;\n\t\t}\n\n\t\tplatform_enable_dma64(pdev, true);\n\t} else if (!dma_set_mask(&pdev->dev, DMA_BIT_MASK(32))) {\n\t\tif (dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32))) {\n\t\t\tWARN_ONCE(true,\n\t\t\t\t  \"rtlwifi: Unable to obtain 32bit DMA for consistent allocations\\n\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto fail1;\n\t\t}\n\n\t\tplatform_enable_dma64(pdev, false);\n\t}\n\n\tpci_set_master(pdev);\n\n\thw = ieee80211_alloc_hw(sizeof(struct rtl_pci_priv) +\n\t\t\t\tsizeof(struct rtl_priv), &rtl_ops);\n\tif (!hw) {\n\t\tWARN_ONCE(true,\n\t\t\t  \"%s : ieee80211 alloc failed\\n\", pci_name(pdev));\n\t\terr = -ENOMEM;\n\t\tgoto fail1;\n\t}\n\n\tSET_IEEE80211_DEV(hw, &pdev->dev);\n\tpci_set_drvdata(pdev, hw);\n\n\trtlpriv = hw->priv;\n\trtlpriv->hw = hw;\n\tpcipriv = (void *)rtlpriv->priv;\n\tpcipriv->dev.pdev = pdev;\n\tinit_completion(&rtlpriv->firmware_loading_complete);\n\t \n\trtlpriv->proximity.proxim_on = false;\n\n\tpcipriv = (void *)rtlpriv->priv;\n\tpcipriv->dev.pdev = pdev;\n\n\t \n\trtlpriv->rtlhal.interface = INTF_PCI;\n\trtlpriv->cfg = (struct rtl_hal_cfg *)(id->driver_data);\n\trtlpriv->intf_ops = &rtl_pci_ops;\n\trtlpriv->glb_var = &rtl_global_var;\n\trtl_efuse_ops_init(hw);\n\n\t \n\terr = pci_request_regions(pdev, KBUILD_MODNAME);\n\tif (err) {\n\t\tWARN_ONCE(true, \"rtlwifi: Can't obtain PCI resources\\n\");\n\t\tgoto fail1;\n\t}\n\n\tpmem_start = pci_resource_start(pdev, rtlpriv->cfg->bar_id);\n\tpmem_len = pci_resource_len(pdev, rtlpriv->cfg->bar_id);\n\tpmem_flags = pci_resource_flags(pdev, rtlpriv->cfg->bar_id);\n\n\t \n\trtlpriv->io.pci_mem_start =\n\t\t\t(unsigned long)pci_iomap(pdev,\n\t\t\trtlpriv->cfg->bar_id, pmem_len);\n\tif (rtlpriv->io.pci_mem_start == 0) {\n\t\tWARN_ONCE(true, \"rtlwifi: Can't map PCI mem\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto fail2;\n\t}\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG,\n\t\t\"mem mapped space: start: 0x%08lx len:%08lx flags:%08lx, after map:0x%08lx\\n\",\n\t\tpmem_start, pmem_len, pmem_flags,\n\t\trtlpriv->io.pci_mem_start);\n\n\t \n\tpci_write_config_byte(pdev, 0x81, 0);\n\t \n\tpci_write_config_byte(pdev, 0x44, 0);\n\tpci_write_config_byte(pdev, 0x04, 0x06);\n\tpci_write_config_byte(pdev, 0x04, 0x07);\n\n\t \n\tif (!_rtl_pci_find_adapter(pdev, hw)) {\n\t\terr = -ENODEV;\n\t\tgoto fail2;\n\t}\n\n\t \n\t_rtl_pci_io_handler_init(&pdev->dev, hw);\n\n\t \n\trtlpriv->cfg->ops->read_eeprom_info(hw);\n\n\tif (rtlpriv->cfg->ops->init_sw_vars(hw)) {\n\t\tpr_err(\"Can't init_sw_vars\\n\");\n\t\terr = -ENODEV;\n\t\tgoto fail3;\n\t}\n\trtl_init_sw_leds(hw);\n\n\t \n\trtl_pci_init_aspm(hw);\n\n\t \n\terr = rtl_init_core(hw);\n\tif (err) {\n\t\tpr_err(\"Can't allocate sw for mac80211\\n\");\n\t\tgoto fail3;\n\t}\n\n\t \n\terr = rtl_pci_init(hw, pdev);\n\tif (err) {\n\t\tpr_err(\"Failed to init PCI\\n\");\n\t\tgoto fail3;\n\t}\n\n\terr = ieee80211_register_hw(hw);\n\tif (err) {\n\t\tpr_err(\"Can't register mac80211 hw.\\n\");\n\t\terr = -ENODEV;\n\t\tgoto fail3;\n\t}\n\trtlpriv->mac80211.mac80211_registered = 1;\n\n\t \n\trtl_debug_add_one(hw);\n\n\t \n\trtl_init_rfkill(hw);\t \n\n\trtlpci = rtl_pcidev(pcipriv);\n\terr = rtl_pci_intr_mode_decide(hw);\n\tif (err) {\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG,\n\t\t\t\"%s: failed to register IRQ handler\\n\",\n\t\t\twiphy_name(hw->wiphy));\n\t\tgoto fail3;\n\t}\n\trtlpci->irq_alloc = 1;\n\n\tset_bit(RTL_STATUS_INTERFACE_START, &rtlpriv->status);\n\treturn 0;\n\nfail3:\n\tpci_set_drvdata(pdev, NULL);\n\trtl_deinit_core(hw);\n\nfail2:\n\tif (rtlpriv->io.pci_mem_start != 0)\n\t\tpci_iounmap(pdev, (void __iomem *)rtlpriv->io.pci_mem_start);\n\n\tpci_release_regions(pdev);\n\tcomplete(&rtlpriv->firmware_loading_complete);\n\nfail1:\n\tif (hw)\n\t\tieee80211_free_hw(hw);\n\tpci_disable_device(pdev);\n\n\treturn err;\n}\nEXPORT_SYMBOL(rtl_pci_probe);\n\nvoid rtl_pci_disconnect(struct pci_dev *pdev)\n{\n\tstruct ieee80211_hw *hw = pci_get_drvdata(pdev);\n\tstruct rtl_pci_priv *pcipriv = rtl_pcipriv(hw);\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(pcipriv);\n\tstruct rtl_mac *rtlmac = rtl_mac(rtlpriv);\n\n\t \n\twait_for_completion(&rtlpriv->firmware_loading_complete);\n\tclear_bit(RTL_STATUS_INTERFACE_START, &rtlpriv->status);\n\n\t \n\trtl_debug_remove_one(hw);\n\n\t \n\tif (rtlmac->mac80211_registered == 1) {\n\t\tieee80211_unregister_hw(hw);\n\t\trtlmac->mac80211_registered = 0;\n\t} else {\n\t\trtl_deinit_deferred_work(hw, false);\n\t\trtlpriv->intf_ops->adapter_stop(hw);\n\t}\n\trtlpriv->cfg->ops->disable_interrupt(hw);\n\n\t \n\trtl_deinit_rfkill(hw);\n\n\trtl_pci_deinit(hw);\n\trtl_deinit_core(hw);\n\trtlpriv->cfg->ops->deinit_sw_vars(hw);\n\n\tif (rtlpci->irq_alloc) {\n\t\tfree_irq(rtlpci->pdev->irq, hw);\n\t\trtlpci->irq_alloc = 0;\n\t}\n\n\tif (rtlpci->using_msi)\n\t\tpci_disable_msi(rtlpci->pdev);\n\n\tlist_del(&rtlpriv->list);\n\tif (rtlpriv->io.pci_mem_start != 0) {\n\t\tpci_iounmap(pdev, (void __iomem *)rtlpriv->io.pci_mem_start);\n\t\tpci_release_regions(pdev);\n\t}\n\n\tpci_disable_device(pdev);\n\n\trtl_pci_disable_aspm(hw);\n\n\tpci_set_drvdata(pdev, NULL);\n\n\tieee80211_free_hw(hw);\n}\nEXPORT_SYMBOL(rtl_pci_disconnect);\n\n#ifdef CONFIG_PM_SLEEP\n \nint rtl_pci_suspend(struct device *dev)\n{\n\tstruct ieee80211_hw *hw = dev_get_drvdata(dev);\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtlpriv->cfg->ops->hw_suspend(hw);\n\trtl_deinit_rfkill(hw);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rtl_pci_suspend);\n\nint rtl_pci_resume(struct device *dev)\n{\n\tstruct ieee80211_hw *hw = dev_get_drvdata(dev);\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtlpriv->cfg->ops->hw_resume(hw);\n\trtl_init_rfkill(hw);\n\treturn 0;\n}\nEXPORT_SYMBOL(rtl_pci_resume);\n#endif  \n\nconst struct rtl_intf_ops rtl_pci_ops = {\n\t.read_efuse_byte = read_efuse_byte,\n\t.adapter_start = rtl_pci_start,\n\t.adapter_stop = rtl_pci_stop,\n\t.check_buddy_priv = rtl_pci_check_buddy_priv,\n\t.adapter_tx = rtl_pci_tx,\n\t.flush = rtl_pci_flush,\n\t.reset_trx_ring = rtl_pci_reset_trx_ring,\n\t.waitq_insert = rtl_pci_tx_chk_waitq_insert,\n\n\t.disable_aspm = rtl_pci_disable_aspm,\n\t.enable_aspm = rtl_pci_enable_aspm,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}