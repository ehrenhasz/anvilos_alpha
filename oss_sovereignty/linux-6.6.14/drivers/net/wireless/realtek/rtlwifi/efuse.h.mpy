{
  "module_name": "efuse.h",
  "hash_id": "f2d02a2b911dcd604937448a1ea93c2ddd8849b0af004facda9a146727249e74",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtlwifi/efuse.h",
  "human_readable_source": " \n \n\n#ifndef __RTL_EFUSE_H_\n#define __RTL_EFUSE_H_\n\n#define EFUSE_IC_ID_OFFSET\t\t506\n\n#define EFUSE_MAX_WORD_UNIT\t\t4\n\n#define EFUSE_INIT_MAP\t\t\t0\n#define EFUSE_MODIFY_MAP\t\t1\n\n#define PG_STATE_HEADER\t\t\t0x01\n#define PG_STATE_WORD_0\t\t\t0x02\n#define PG_STATE_WORD_1\t\t\t0x04\n#define PG_STATE_WORD_2\t\t\t0x08\n#define PG_STATE_WORD_3\t\t\t0x10\n#define PG_STATE_DATA\t\t\t0x20\n\n#define EFUSE_REPEAT_THRESHOLD_\t\t3\n#define EFUSE_ERROE_HANDLE\t\t1\n\nstruct efuse_map {\n\tu8 offset;\n\tu8 word_start;\n\tu8 byte_start;\n\tu8 byte_cnts;\n};\n\nstruct pgpkt_struct {\n\tu8 offset;\n\tu8 word_en;\n\tu8 data[8];\n};\n\nenum efuse_data_item {\n\tEFUSE_CHIP_ID = 0,\n\tEFUSE_LDO_SETTING,\n\tEFUSE_CLK_SETTING,\n\tEFUSE_SDIO_SETTING,\n\tEFUSE_CCCR,\n\tEFUSE_SDIO_MODE,\n\tEFUSE_OCR,\n\tEFUSE_F0CIS,\n\tEFUSE_F1CIS,\n\tEFUSE_MAC_ADDR,\n\tEFUSE_EEPROM_VER,\n\tEFUSE_CHAN_PLAN,\n\tEFUSE_TXPW_TAB\n};\n\nenum {\n\tVOLTAGE_V25 = 0x03,\n\tLDOE25_SHIFT = 28,\n};\n\nstruct efuse_priv {\n\tu8 id[2];\n\tu8 ldo_setting[2];\n\tu8 clk_setting[2];\n\tu8 cccr;\n\tu8 sdio_mode;\n\tu8 ocr[3];\n\tu8 cis0[17];\n\tu8 cis1[48];\n\tu8 mac_addr[6];\n\tu8 eeprom_verno;\n\tu8 channel_plan;\n\tu8 tx_power_b[14];\n\tu8 tx_power_g[14];\n};\n\nvoid read_efuse_byte(struct ieee80211_hw *hw, u16 _offset, u8 *pbuf);\nvoid efuse_initialize(struct ieee80211_hw *hw);\nu8 efuse_read_1byte(struct ieee80211_hw *hw, u16 address);\nint efuse_one_byte_read(struct ieee80211_hw *hw, u16 addr, u8 *data);\nvoid efuse_write_1byte(struct ieee80211_hw *hw, u16 address, u8 value);\nvoid read_efuse(struct ieee80211_hw *hw, u16 _offset,\n\t\tu16 _size_byte, u8 *pbuf);\nvoid efuse_shadow_read(struct ieee80211_hw *hw, u8 type,\n\t\t       u16 offset, u32 *value);\nvoid efuse_shadow_write(struct ieee80211_hw *hw, u8 type,\n\t\t\tu16 offset, u32 value);\nbool efuse_shadow_update(struct ieee80211_hw *hw);\nbool efuse_shadow_update_chk(struct ieee80211_hw *hw);\nvoid rtl_efuse_shadow_map_update(struct ieee80211_hw *hw);\nvoid efuse_force_write_vendor_id(struct ieee80211_hw *hw);\nvoid efuse_re_pg_section(struct ieee80211_hw *hw, u8 section_idx);\nvoid efuse_power_switch(struct ieee80211_hw *hw, u8 write, u8 pwrstate);\nint rtl_get_hwinfo(struct ieee80211_hw *hw, struct rtl_priv *rtlpriv,\n\t\t   int max_size, u8 *hwinfo, int *params);\nvoid rtl_fill_dummy(u8 *pfwbuf, u32 *pfwlen);\nvoid rtl_fw_page_write(struct ieee80211_hw *hw, u32 page, const u8 *buffer,\n\t\t       u32 size);\nvoid rtl_fw_block_write(struct ieee80211_hw *hw, const u8 *buffer, u32 size);\nvoid rtl_efuse_ops_init(struct ieee80211_hw *hw);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}