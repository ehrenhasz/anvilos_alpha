{
  "module_name": "ps.c",
  "hash_id": "0de27430ddb1abc691946891a0296f869d416a132748c2d3dd9d6b48cff654c1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtlwifi/ps.c",
  "human_readable_source": "\n \n\n#include \"wifi.h\"\n#include \"base.h\"\n#include \"ps.h\"\n#include <linux/export.h>\n#include \"btcoexist/rtl_btc.h\"\n\nbool rtl_ps_enable_nic(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_mac *rtlmac = rtl_mac(rtl_priv(hw));\n\n\t \n\tif (rtlhal->interface == INTF_PCI)\n\t\trtlpriv->intf_ops->reset_trx_ring(hw);\n\n\tif (is_hal_stop(rtlhal))\n\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_WARNING,\n\t\t\t\"Driver is already down!\\n\");\n\n\t \n\tif (rtlpriv->cfg->ops->hw_init(hw))\n\t\treturn false;\n\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_RETRY_LIMIT,\n\t\t\t&rtlmac->retry_long);\n\tRT_CLEAR_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_HALT_NIC);\n\n\trtlpriv->cfg->ops->switch_channel(hw);\n\trtlpriv->cfg->ops->set_channel_access(hw);\n\trtlpriv->cfg->ops->set_bw_mode(hw,\n\t\t\tcfg80211_get_chandef_type(&hw->conf.chandef));\n\n\t \n\trtlpriv->cfg->ops->enable_interrupt(hw);\n\n\t \n\trtl_watch_dog_timer_callback(&rtlpriv->works.watchdog_timer);\n\n\treturn true;\n}\nEXPORT_SYMBOL(rtl_ps_enable_nic);\n\nbool rtl_ps_disable_nic(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\t \n\trtl_deinit_deferred_work(hw, true);\n\n\t \n\trtlpriv->cfg->ops->disable_interrupt(hw);\n\ttasklet_kill(&rtlpriv->works.irq_tasklet);\n\n\t \n\trtlpriv->cfg->ops->hw_disable(hw);\n\n\treturn true;\n}\nEXPORT_SYMBOL(rtl_ps_disable_nic);\n\nstatic bool rtl_ps_set_rf_state(struct ieee80211_hw *hw,\n\t\t\t\tenum rf_pwrstate state_toset,\n\t\t\t\tu32 changesource)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tbool actionallowed = false;\n\tu16 rfwait_cnt = 0;\n\n\t \n\twhile (true) {\n\t\tspin_lock(&rtlpriv->locks.rf_ps_lock);\n\t\tif (ppsc->rfchange_inprogress) {\n\t\t\tspin_unlock(&rtlpriv->locks.rf_ps_lock);\n\n\t\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_WARNING,\n\t\t\t\t\"RF Change in progress! Wait to set..state_toset(%d).\\n\",\n\t\t\t\tstate_toset);\n\n\t\t\t \n\t\t\twhile (ppsc->rfchange_inprogress) {\n\t\t\t\trfwait_cnt++;\n\t\t\t\tmdelay(1);\n\t\t\t\t \n\t\t\t\tif (rfwait_cnt > 100)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\tppsc->rfchange_inprogress = true;\n\t\t\tspin_unlock(&rtlpriv->locks.rf_ps_lock);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tswitch (state_toset) {\n\tcase ERFON:\n\t\tppsc->rfoff_reason &= (~changesource);\n\n\t\tif ((changesource == RF_CHANGE_BY_HW) &&\n\t\t    (ppsc->hwradiooff)) {\n\t\t\tppsc->hwradiooff = false;\n\t\t}\n\n\t\tif (!ppsc->rfoff_reason) {\n\t\t\tppsc->rfoff_reason = 0;\n\t\t\tactionallowed = true;\n\t\t}\n\n\t\tbreak;\n\n\tcase ERFOFF:\n\n\t\tif ((changesource == RF_CHANGE_BY_HW) && !ppsc->hwradiooff) {\n\t\t\tppsc->hwradiooff = true;\n\t\t}\n\n\t\tppsc->rfoff_reason |= changesource;\n\t\tactionallowed = true;\n\t\tbreak;\n\n\tcase ERFSLEEP:\n\t\tppsc->rfoff_reason |= changesource;\n\t\tactionallowed = true;\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err(\"switch case %#x not processed\\n\", state_toset);\n\t\tbreak;\n\t}\n\n\tif (actionallowed)\n\t\trtlpriv->cfg->ops->set_rf_power_state(hw, state_toset);\n\n\tspin_lock(&rtlpriv->locks.rf_ps_lock);\n\tppsc->rfchange_inprogress = false;\n\tspin_unlock(&rtlpriv->locks.rf_ps_lock);\n\n\treturn actionallowed;\n}\n\nstatic void _rtl_ps_inactive_ps(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\n\tppsc->swrf_processing = true;\n\n\tif (ppsc->inactive_pwrstate == ERFON &&\n\t    rtlhal->interface == INTF_PCI) {\n\t\tif ((ppsc->reg_rfps_level & RT_RF_OFF_LEVL_ASPM) &&\n\t\t    RT_IN_PS_LEVEL(ppsc, RT_PS_LEVEL_ASPM)) {\n\t\t\trtlpriv->intf_ops->disable_aspm(hw);\n\t\t\tRT_CLEAR_PS_LEVEL(ppsc, RT_PS_LEVEL_ASPM);\n\t\t}\n\t}\n\n\trtl_ps_set_rf_state(hw, ppsc->inactive_pwrstate,\n\t\t\t    RF_CHANGE_BY_IPS);\n\n\tif (ppsc->inactive_pwrstate == ERFOFF &&\n\t    rtlhal->interface == INTF_PCI) {\n\t\tif (ppsc->reg_rfps_level & RT_RF_OFF_LEVL_ASPM &&\n\t\t    !RT_IN_PS_LEVEL(ppsc, RT_PS_LEVEL_ASPM)) {\n\t\t\trtlpriv->intf_ops->enable_aspm(hw);\n\t\t\tRT_SET_PS_LEVEL(ppsc, RT_PS_LEVEL_ASPM);\n\t\t}\n\t}\n\n\tppsc->swrf_processing = false;\n}\n\nvoid rtl_ips_nic_off_wq_callback(struct work_struct *work)\n{\n\tstruct rtl_works *rtlworks = container_of(work, struct rtl_works,\n\t\t\t\t\t\t  ips_nic_off_wq.work);\n\tstruct ieee80211_hw *hw = rtlworks->hw;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tenum rf_pwrstate rtstate;\n\n\tif (mac->opmode != NL80211_IFTYPE_STATION) {\n\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_WARNING,\n\t\t\t\"not station return\\n\");\n\t\treturn;\n\t}\n\n\tif (mac->p2p_in_use)\n\t\treturn;\n\n\tif (mac->link_state > MAC80211_NOLINK)\n\t\treturn;\n\n\tif (is_hal_stop(rtlhal))\n\t\treturn;\n\n\tif (rtlpriv->sec.being_setkey)\n\t\treturn;\n\n\tif (rtlpriv->cfg->ops->bt_coex_off_before_lps)\n\t\trtlpriv->cfg->ops->bt_coex_off_before_lps(hw);\n\n\tif (ppsc->inactiveps) {\n\t\trtstate = ppsc->rfpwr_state;\n\n\t\t \n\n\t\tif (rtstate == ERFON &&\n\t\t    !ppsc->swrf_processing &&\n\t\t    (mac->link_state == MAC80211_NOLINK) &&\n\t\t    !mac->act_scanning) {\n\t\t\trtl_dbg(rtlpriv, COMP_RF, DBG_TRACE,\n\t\t\t\t\"IPSEnter(): Turn off RF\\n\");\n\n\t\t\tppsc->inactive_pwrstate = ERFOFF;\n\t\t\tppsc->in_powersavemode = true;\n\n\t\t\t \n\t\t\tif (rtlpriv->cfg->ops->get_btc_status())\n\t\t\t\trtlpriv->btcoexist.btc_ops->btc_ips_notify(rtlpriv,\n\t\t\t\t\t\t\t\t\tppsc->inactive_pwrstate);\n\n\t\t\t \n\t\t\t_rtl_ps_inactive_ps(hw);\n\t\t}\n\t}\n}\n\nvoid rtl_ips_nic_off(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\t \n\tqueue_delayed_work(rtlpriv->works.rtl_wq,\n\t\t\t   &rtlpriv->works.ips_nic_off_wq, MSECS(100));\n}\n\n \nvoid rtl_ips_nic_on(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tenum rf_pwrstate rtstate;\n\n\tcancel_delayed_work_sync(&rtlpriv->works.ips_nic_off_wq);\n\n\tmutex_lock(&rtlpriv->locks.ips_mutex);\n\tif (ppsc->inactiveps) {\n\t\trtstate = ppsc->rfpwr_state;\n\n\t\tif (rtstate != ERFON &&\n\t\t    !ppsc->swrf_processing &&\n\t\t    ppsc->rfoff_reason <= RF_CHANGE_BY_IPS) {\n\n\t\t\tppsc->inactive_pwrstate = ERFON;\n\t\t\tppsc->in_powersavemode = false;\n\t\t\t_rtl_ps_inactive_ps(hw);\n\t\t\t \n\t\t\tif (rtlpriv->cfg->ops->get_btc_status())\n\t\t\t\trtlpriv->btcoexist.btc_ops->btc_ips_notify(rtlpriv,\n\t\t\t\t\t\t\t\t\tppsc->inactive_pwrstate);\n\t\t}\n\t}\n\tmutex_unlock(&rtlpriv->locks.ips_mutex);\n}\nEXPORT_SYMBOL_GPL(rtl_ips_nic_on);\n\n \n\n \nstatic bool rtl_get_fwlps_doze(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tu32 ps_timediff;\n\n\tps_timediff = jiffies_to_msecs(jiffies -\n\t\t\t\t       ppsc->last_delaylps_stamp_jiffies);\n\n\tif (ps_timediff < 2000) {\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD,\n\t\t\t\"Delay enter Fw LPS for DHCP, ARP, or EAPOL exchanging state\\n\");\n\t\treturn false;\n\t}\n\n\tif (mac->link_state != MAC80211_LINKED)\n\t\treturn false;\n\n\tif (mac->opmode == NL80211_IFTYPE_ADHOC)\n\t\treturn false;\n\n\treturn true;\n}\n\n \nvoid rtl_lps_set_psmode(struct ieee80211_hw *hw, u8 rt_psmode)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tbool enter_fwlps;\n\n\tif (mac->opmode == NL80211_IFTYPE_ADHOC)\n\t\treturn;\n\n\tif (mac->link_state != MAC80211_LINKED)\n\t\treturn;\n\n\tif (ppsc->dot11_psmode == rt_psmode && rt_psmode == EACTIVE)\n\t\treturn;\n\n\t \n\tppsc->dot11_psmode = rt_psmode;\n\n\t \n\n\tif ((ppsc->fwctrl_lps) && ppsc->report_linked) {\n\t\tif (ppsc->dot11_psmode == EACTIVE) {\n\t\t\trtl_dbg(rtlpriv, COMP_RF, DBG_DMESG,\n\t\t\t\t\"FW LPS leave ps_mode:%x\\n\",\n\t\t\t\tFW_PS_ACTIVE_MODE);\n\t\t\tenter_fwlps = false;\n\t\t\tppsc->pwr_mode = FW_PS_ACTIVE_MODE;\n\t\t\tppsc->smart_ps = 0;\n\t\t\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_FW_LPS_ACTION,\n\t\t\t\t\t\t      (u8 *)(&enter_fwlps));\n\t\t\tif (ppsc->p2p_ps_info.opp_ps)\n\t\t\t\trtl_p2p_ps_cmd(hw , P2P_PS_ENABLE);\n\n\t\t\tif (rtlpriv->cfg->ops->get_btc_status())\n\t\t\t\trtlpriv->btcoexist.btc_ops->btc_lps_notify(rtlpriv, rt_psmode);\n\t\t} else {\n\t\t\tif (rtl_get_fwlps_doze(hw)) {\n\t\t\t\trtl_dbg(rtlpriv, COMP_RF, DBG_DMESG,\n\t\t\t\t\t\"FW LPS enter ps_mode:%x\\n\",\n\t\t\t\t\tppsc->fwctrl_psmode);\n\t\t\t\tif (rtlpriv->cfg->ops->get_btc_status())\n\t\t\t\t\trtlpriv->btcoexist.btc_ops->btc_lps_notify(rtlpriv, rt_psmode);\n\t\t\t\tenter_fwlps = true;\n\t\t\t\tppsc->pwr_mode = ppsc->fwctrl_psmode;\n\t\t\t\tppsc->smart_ps = 2;\n\t\t\t\trtlpriv->cfg->ops->set_hw_reg(hw,\n\t\t\t\t\t\t\tHW_VAR_FW_LPS_ACTION,\n\t\t\t\t\t\t\t(u8 *)(&enter_fwlps));\n\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tppsc->dot11_psmode = EACTIVE;\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic void rtl_lps_enter_core(struct ieee80211_hw *hw)\n{\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\tif (!ppsc->fwctrl_lps)\n\t\treturn;\n\n\tif (rtlpriv->sec.being_setkey)\n\t\treturn;\n\n\tif (rtlpriv->link_info.busytraffic)\n\t\treturn;\n\n\t \n\tif (mac->cnt_after_linked < 5)\n\t\treturn;\n\n\tif (mac->opmode == NL80211_IFTYPE_ADHOC)\n\t\treturn;\n\n\tif (mac->link_state != MAC80211_LINKED)\n\t\treturn;\n\n\tmutex_lock(&rtlpriv->locks.lps_mutex);\n\n\t \n\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD,\n\t\t\"Enter 802.11 power save mode...\\n\");\n\trtl_lps_set_psmode(hw, EAUTOPS);\n\n\tmutex_unlock(&rtlpriv->locks.lps_mutex);\n}\n\n \nstatic void rtl_lps_leave_core(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\n\tmutex_lock(&rtlpriv->locks.lps_mutex);\n\n\tif (ppsc->fwctrl_lps) {\n\t\tif (ppsc->dot11_psmode != EACTIVE) {\n\n\t\t\t \n\t\t\t \n\n\t\t\tif (ppsc->reg_rfps_level & RT_RF_LPS_LEVEL_ASPM &&\n\t\t\t    RT_IN_PS_LEVEL(ppsc, RT_PS_LEVEL_ASPM) &&\n\t\t\t    rtlhal->interface == INTF_PCI) {\n\t\t\t\trtlpriv->intf_ops->disable_aspm(hw);\n\t\t\t\tRT_CLEAR_PS_LEVEL(ppsc, RT_PS_LEVEL_ASPM);\n\t\t\t}\n\n\t\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD,\n\t\t\t\t\"Busy Traffic,Leave 802.11 power save..\\n\");\n\n\t\t\trtl_lps_set_psmode(hw, EACTIVE);\n\t\t}\n\t}\n\tmutex_unlock(&rtlpriv->locks.lps_mutex);\n}\n\n \nvoid rtl_swlps_beacon(struct ieee80211_hw *hw, void *data, unsigned int len)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct ieee80211_hdr *hdr = data;\n\tstruct ieee80211_tim_ie *tim_ie;\n\tu8 *tim;\n\tu8 tim_len;\n\tbool u_buffed;\n\tbool m_buffed;\n\n\tif (mac->opmode != NL80211_IFTYPE_STATION)\n\t\treturn;\n\n\tif (!rtlpriv->psc.swctrl_lps)\n\t\treturn;\n\n\tif (rtlpriv->mac80211.link_state != MAC80211_LINKED)\n\t\treturn;\n\n\tif (!rtlpriv->psc.sw_ps_enabled)\n\t\treturn;\n\n\tif (rtlpriv->psc.fwctrl_lps)\n\t\treturn;\n\n\tif (likely(!(hw->conf.flags & IEEE80211_CONF_PS)))\n\t\treturn;\n\n\t \n\tif (!ieee80211_is_beacon(hdr->frame_control))\n\t\treturn;\n\n\t \n\tif (len <= 40 + FCS_LEN)\n\t\treturn;\n\n\t \n\tif (!ether_addr_equal_64bits(hdr->addr3, rtlpriv->mac80211.bssid))\n\t\treturn;\n\n\trtlpriv->psc.last_beacon = jiffies;\n\n\ttim = rtl_find_ie(data, len - FCS_LEN, WLAN_EID_TIM);\n\tif (!tim)\n\t\treturn;\n\n\tif (tim[1] < sizeof(*tim_ie))\n\t\treturn;\n\n\ttim_len = tim[1];\n\ttim_ie = (struct ieee80211_tim_ie *) &tim[2];\n\n\tif (!WARN_ON_ONCE(!hw->conf.ps_dtim_period))\n\t\trtlpriv->psc.dtim_counter = tim_ie->dtim_count;\n\n\t \n\n\t \n\tu_buffed = ieee80211_check_tim(tim_ie, tim_len,\n\t\t\t\t       rtlpriv->mac80211.assoc_id);\n\n\t \n\tm_buffed = tim_ie->bitmap_ctrl & 0x01;\n\trtlpriv->psc.multi_buffered = m_buffed;\n\n\t \n\tif (!m_buffed) {\n\t\t \n\t\tqueue_delayed_work(rtlpriv->works.rtl_wq,\n\t\t\t\t   &rtlpriv->works.ps_work, MSECS(5));\n\t} else {\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_DMESG,\n\t\t\t\"u_bufferd: %x, m_buffered: %x\\n\", u_buffed, m_buffed);\n\t}\n}\nEXPORT_SYMBOL_GPL(rtl_swlps_beacon);\n\nvoid rtl_swlps_rf_awake(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\n\tif (!rtlpriv->psc.swctrl_lps)\n\t\treturn;\n\tif (mac->link_state != MAC80211_LINKED)\n\t\treturn;\n\n\tif (ppsc->reg_rfps_level & RT_RF_LPS_LEVEL_ASPM &&\n\t    RT_IN_PS_LEVEL(ppsc, RT_PS_LEVEL_ASPM)) {\n\t\trtlpriv->intf_ops->disable_aspm(hw);\n\t\tRT_CLEAR_PS_LEVEL(ppsc, RT_PS_LEVEL_ASPM);\n\t}\n\n\tmutex_lock(&rtlpriv->locks.lps_mutex);\n\trtl_ps_set_rf_state(hw, ERFON, RF_CHANGE_BY_PS);\n\tmutex_unlock(&rtlpriv->locks.lps_mutex);\n}\n\nvoid rtl_swlps_rfon_wq_callback(struct work_struct *work)\n{\n\tstruct rtl_works *rtlworks = container_of(work, struct rtl_works,\n\t\t\t\t\t\t  ps_rfon_wq.work);\n\tstruct ieee80211_hw *hw = rtlworks->hw;\n\n\trtl_swlps_rf_awake(hw);\n}\n\nvoid rtl_swlps_rf_sleep(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tu8 sleep_intv;\n\n\tif (!rtlpriv->psc.sw_ps_enabled)\n\t\treturn;\n\n\tif ((rtlpriv->sec.being_setkey) ||\n\t    (mac->opmode == NL80211_IFTYPE_ADHOC))\n\t\treturn;\n\n\t \n\tif ((mac->link_state != MAC80211_LINKED) || (mac->cnt_after_linked < 5))\n\t\treturn;\n\n\tif (rtlpriv->link_info.busytraffic)\n\t\treturn;\n\n\tspin_lock(&rtlpriv->locks.rf_ps_lock);\n\tif (rtlpriv->psc.rfchange_inprogress) {\n\t\tspin_unlock(&rtlpriv->locks.rf_ps_lock);\n\t\treturn;\n\t}\n\tspin_unlock(&rtlpriv->locks.rf_ps_lock);\n\n\tmutex_lock(&rtlpriv->locks.lps_mutex);\n\trtl_ps_set_rf_state(hw, ERFSLEEP, RF_CHANGE_BY_PS);\n\tmutex_unlock(&rtlpriv->locks.lps_mutex);\n\n\tif (ppsc->reg_rfps_level & RT_RF_OFF_LEVL_ASPM &&\n\t    !RT_IN_PS_LEVEL(ppsc, RT_PS_LEVEL_ASPM)) {\n\t\trtlpriv->intf_ops->enable_aspm(hw);\n\t\tRT_SET_PS_LEVEL(ppsc, RT_PS_LEVEL_ASPM);\n\t}\n\n\t \n\n\tif (rtlpriv->psc.dtim_counter == 0) {\n\t\tif (hw->conf.ps_dtim_period == 1)\n\t\t\tsleep_intv = hw->conf.ps_dtim_period * 2;\n\t\telse\n\t\t\tsleep_intv = hw->conf.ps_dtim_period;\n\t} else {\n\t\tsleep_intv = rtlpriv->psc.dtim_counter;\n\t}\n\n\tif (sleep_intv > MAX_SW_LPS_SLEEP_INTV)\n\t\tsleep_intv = MAX_SW_LPS_SLEEP_INTV;\n\n\t \n\trtl_dbg(rtlpriv, COMP_POWER, DBG_DMESG,\n\t\t\"dtim_counter:%x will sleep :%d beacon_intv\\n\",\n\t\trtlpriv->psc.dtim_counter, sleep_intv);\n\n\t \n\tqueue_delayed_work(rtlpriv->works.rtl_wq, &rtlpriv->works.ps_rfon_wq,\n\t\t\tMSECS(sleep_intv * mac->vif->bss_conf.beacon_int - 40));\n}\n\nvoid rtl_lps_change_work_callback(struct work_struct *work)\n{\n\tstruct rtl_works *rtlworks =\n\t    container_of(work, struct rtl_works, lps_change_work);\n\tstruct ieee80211_hw *hw = rtlworks->hw;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\tif (rtlpriv->enter_ps)\n\t\trtl_lps_enter_core(hw);\n\telse\n\t\trtl_lps_leave_core(hw);\n}\nEXPORT_SYMBOL_GPL(rtl_lps_change_work_callback);\n\nvoid rtl_lps_enter(struct ieee80211_hw *hw, bool may_block)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\tif (may_block)\n\t\treturn rtl_lps_enter_core(hw);\n\trtlpriv->enter_ps = true;\n\tschedule_work(&rtlpriv->works.lps_change_work);\n}\nEXPORT_SYMBOL_GPL(rtl_lps_enter);\n\nvoid rtl_lps_leave(struct ieee80211_hw *hw, bool may_block)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\tif (may_block)\n\t\treturn rtl_lps_leave_core(hw);\n\trtlpriv->enter_ps = false;\n\tschedule_work(&rtlpriv->works.lps_change_work);\n}\nEXPORT_SYMBOL_GPL(rtl_lps_leave);\n\nvoid rtl_swlps_wq_callback(struct work_struct *work)\n{\n\tstruct rtl_works *rtlworks = container_of(work, struct rtl_works,\n\t\t\t\t\t\t  ps_work.work);\n\tstruct ieee80211_hw *hw = rtlworks->hw;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tbool ps = false;\n\n\tps = (hw->conf.flags & IEEE80211_CONF_PS);\n\n\t \n\tif (rtlpriv->psc.state_inap) {\n\t\trtl_swlps_rf_sleep(hw);\n\n\t\tif (rtlpriv->psc.state && !ps) {\n\t\t\trtlpriv->psc.sleep_ms = jiffies_to_msecs(jiffies -\n\t\t\t\t\t\t rtlpriv->psc.last_action);\n\t\t}\n\n\t\tif (ps)\n\t\t\trtlpriv->psc.last_slept = jiffies;\n\n\t\trtlpriv->psc.last_action = jiffies;\n\t\trtlpriv->psc.state = ps;\n\t}\n}\n\nstatic void rtl_p2p_noa_ie(struct ieee80211_hw *hw, void *data,\n\t\t\t   unsigned int len)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct ieee80211_mgmt *mgmt = data;\n\tstruct rtl_p2p_ps_info *p2pinfo = &(rtlpriv->psc.p2p_ps_info);\n\tu8 *pos, *end, *ie;\n\tu16 noa_len;\n\tstatic u8 p2p_oui_ie_type[4] = {0x50, 0x6f, 0x9a, 0x09};\n\tu8 noa_num, index , i, noa_index = 0;\n\tbool find_p2p_ie = false , find_p2p_ps_ie = false;\n\n\tpos = (u8 *)mgmt->u.beacon.variable;\n\tend = data + len;\n\tie = NULL;\n\n\twhile (pos + 1 < end) {\n\t\tif (pos + 2 + pos[1] > end)\n\t\t\treturn;\n\n\t\tif (pos[0] == 221 && pos[1] > 4) {\n\t\t\tif (memcmp(&pos[2], p2p_oui_ie_type, 4) == 0) {\n\t\t\t\tie = pos + 2+4;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tpos += 2 + pos[1];\n\t}\n\n\tif (ie == NULL)\n\t\treturn;\n\tfind_p2p_ie = true;\n\t \n\twhile (ie + 1 < end) {\n\t\tnoa_len = le16_to_cpu(*((__le16 *)&ie[1]));\n\t\tif (ie + 3 + ie[1] > end)\n\t\t\treturn;\n\n\t\tif (ie[0] == 12) {\n\t\t\tfind_p2p_ps_ie = true;\n\t\t\tif ((noa_len - 2) % 13 != 0) {\n\t\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\t\t\"P2P notice of absence: invalid length.%d\\n\",\n\t\t\t\t\tnoa_len);\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tnoa_num = (noa_len - 2) / 13;\n\t\t\t\tif (noa_num > P2P_MAX_NOA_NUM)\n\t\t\t\t\tnoa_num = P2P_MAX_NOA_NUM;\n\n\t\t\t}\n\t\t\tnoa_index = ie[3];\n\t\t\tif (rtlpriv->psc.p2p_ps_info.p2p_ps_mode ==\n\t\t\t    P2P_PS_NONE || noa_index != p2pinfo->noa_index) {\n\t\t\t\trtl_dbg(rtlpriv, COMP_FW, DBG_LOUD,\n\t\t\t\t\t\"update NOA ie.\\n\");\n\t\t\t\tp2pinfo->noa_index = noa_index;\n\t\t\t\tp2pinfo->opp_ps = (ie[4] >> 7);\n\t\t\t\tp2pinfo->ctwindow = ie[4] & 0x7F;\n\t\t\t\tp2pinfo->noa_num = noa_num;\n\t\t\t\tindex = 5;\n\t\t\t\tfor (i = 0; i < noa_num; i++) {\n\t\t\t\t\tp2pinfo->noa_count_type[i] =\n\t\t\t\t\t *(u8 *)(ie + index);\n\t\t\t\t\tindex += 1;\n\t\t\t\t\tp2pinfo->noa_duration[i] =\n\t\t\t\t\t le32_to_cpu(*(__le32 *)(ie + index));\n\t\t\t\t\tindex += 4;\n\t\t\t\t\tp2pinfo->noa_interval[i] =\n\t\t\t\t\t le32_to_cpu(*(__le32 *)(ie + index));\n\t\t\t\t\tindex += 4;\n\t\t\t\t\tp2pinfo->noa_start_time[i] =\n\t\t\t\t\t le32_to_cpu(*(__le32 *)(ie + index));\n\t\t\t\t\tindex += 4;\n\t\t\t\t}\n\n\t\t\t\tif (p2pinfo->opp_ps == 1) {\n\t\t\t\t\tp2pinfo->p2p_ps_mode = P2P_PS_CTWINDOW;\n\t\t\t\t\t \n\t\t\t\t\tif (rtlpriv->psc.fw_current_inpsmode)\n\t\t\t\t\t\trtl_p2p_ps_cmd(hw,\n\t\t\t\t\t\t\t       P2P_PS_ENABLE);\n\t\t\t\t} else if (p2pinfo->noa_num > 0) {\n\t\t\t\t\tp2pinfo->p2p_ps_mode = P2P_PS_NOA;\n\t\t\t\t\trtl_p2p_ps_cmd(hw, P2P_PS_ENABLE);\n\t\t\t\t} else if (p2pinfo->p2p_ps_mode > P2P_PS_NONE) {\n\t\t\t\t\trtl_p2p_ps_cmd(hw, P2P_PS_DISABLE);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tie += 3 + noa_len;\n\t}\n\n\tif (find_p2p_ie) {\n\t\tif ((p2pinfo->p2p_ps_mode > P2P_PS_NONE) &&\n\t\t    (!find_p2p_ps_ie))\n\t\t\trtl_p2p_ps_cmd(hw, P2P_PS_DISABLE);\n\t}\n}\n\nstatic void rtl_p2p_action_ie(struct ieee80211_hw *hw, void *data,\n\t\t\t      unsigned int len)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct ieee80211_mgmt *mgmt = data;\n\tstruct rtl_p2p_ps_info *p2pinfo = &(rtlpriv->psc.p2p_ps_info);\n\tu8 noa_num, index , i , noa_index = 0;\n\tu8 *pos, *end, *ie;\n\tu16 noa_len;\n\tstatic u8 p2p_oui_ie_type[4] = {0x50, 0x6f, 0x9a, 0x09};\n\n\tpos = (u8 *)&mgmt->u.action.category;\n\tend = data + len;\n\tie = NULL;\n\n\tif (pos[0] == 0x7f) {\n\t\tif (memcmp(&pos[1], p2p_oui_ie_type, 4) == 0)\n\t\t\tie = pos + 3+4;\n\t}\n\n\tif (ie == NULL)\n\t\treturn;\n\n\trtl_dbg(rtlpriv, COMP_FW, DBG_LOUD, \"action frame find P2P IE.\\n\");\n\t \n\twhile (ie + 1 < end) {\n\t\tnoa_len = le16_to_cpu(*(__le16 *)&ie[1]);\n\t\tif (ie + 3 + ie[1] > end)\n\t\t\treturn;\n\n\t\tif (ie[0] == 12) {\n\t\t\trtl_dbg(rtlpriv, COMP_FW, DBG_LOUD, \"find NOA IE.\\n\");\n\t\t\tRT_PRINT_DATA(rtlpriv, COMP_FW, DBG_LOUD, \"noa ie \",\n\t\t\t\t      ie, noa_len);\n\t\t\tif ((noa_len - 2) % 13 != 0) {\n\t\t\t\trtl_dbg(rtlpriv, COMP_FW, DBG_LOUD,\n\t\t\t\t\t\"P2P notice of absence: invalid length.%d\\n\",\n\t\t\t\t\tnoa_len);\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tnoa_num = (noa_len - 2) / 13;\n\t\t\t\tif (noa_num > P2P_MAX_NOA_NUM)\n\t\t\t\t\tnoa_num = P2P_MAX_NOA_NUM;\n\n\t\t\t}\n\t\t\tnoa_index = ie[3];\n\t\t\tif (rtlpriv->psc.p2p_ps_info.p2p_ps_mode ==\n\t\t\t    P2P_PS_NONE || noa_index != p2pinfo->noa_index) {\n\t\t\t\tp2pinfo->noa_index = noa_index;\n\t\t\t\tp2pinfo->opp_ps = (ie[4] >> 7);\n\t\t\t\tp2pinfo->ctwindow = ie[4] & 0x7F;\n\t\t\t\tp2pinfo->noa_num = noa_num;\n\t\t\t\tindex = 5;\n\t\t\t\tfor (i = 0; i < noa_num; i++) {\n\t\t\t\t\tp2pinfo->noa_count_type[i] =\n\t\t\t\t\t *(u8 *)(ie + index);\n\t\t\t\t\tindex += 1;\n\t\t\t\t\tp2pinfo->noa_duration[i] =\n\t\t\t\t\t le32_to_cpu(*(__le32 *)(ie + index));\n\t\t\t\t\tindex += 4;\n\t\t\t\t\tp2pinfo->noa_interval[i] =\n\t\t\t\t\t le32_to_cpu(*(__le32 *)(ie + index));\n\t\t\t\t\tindex += 4;\n\t\t\t\t\tp2pinfo->noa_start_time[i] =\n\t\t\t\t\t le32_to_cpu(*(__le32 *)(ie + index));\n\t\t\t\t\tindex += 4;\n\t\t\t\t}\n\n\t\t\t\tif (p2pinfo->opp_ps == 1) {\n\t\t\t\t\tp2pinfo->p2p_ps_mode = P2P_PS_CTWINDOW;\n\t\t\t\t\t \n\t\t\t\t\tif (rtlpriv->psc.fw_current_inpsmode)\n\t\t\t\t\t\trtl_p2p_ps_cmd(hw,\n\t\t\t\t\t\t\t       P2P_PS_ENABLE);\n\t\t\t\t} else if (p2pinfo->noa_num > 0) {\n\t\t\t\t\tp2pinfo->p2p_ps_mode = P2P_PS_NOA;\n\t\t\t\t\trtl_p2p_ps_cmd(hw, P2P_PS_ENABLE);\n\t\t\t\t} else if (p2pinfo->p2p_ps_mode > P2P_PS_NONE) {\n\t\t\t\t\trtl_p2p_ps_cmd(hw, P2P_PS_DISABLE);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tie += 3 + noa_len;\n\t}\n}\n\nvoid rtl_p2p_ps_cmd(struct ieee80211_hw *hw , u8 p2p_ps_state)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_ps_ctl *rtlps = rtl_psc(rtl_priv(hw));\n\tstruct rtl_p2p_ps_info  *p2pinfo = &(rtlpriv->psc.p2p_ps_info);\n\n\trtl_dbg(rtlpriv, COMP_FW, DBG_LOUD, \" p2p state %x\\n\", p2p_ps_state);\n\tswitch (p2p_ps_state) {\n\tcase P2P_PS_DISABLE:\n\t\tp2pinfo->p2p_ps_state = p2p_ps_state;\n\t\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_H2C_FW_P2P_PS_OFFLOAD,\n\t\t\t\t\t      &p2p_ps_state);\n\t\tp2pinfo->noa_index = 0;\n\t\tp2pinfo->ctwindow = 0;\n\t\tp2pinfo->opp_ps = 0;\n\t\tp2pinfo->noa_num = 0;\n\t\tp2pinfo->p2p_ps_mode = P2P_PS_NONE;\n\t\tif (rtlps->fw_current_inpsmode) {\n\t\t\tif (rtlps->smart_ps == 0) {\n\t\t\t\trtlps->smart_ps = 2;\n\t\t\t\trtlpriv->cfg->ops->set_hw_reg(hw,\n\t\t\t\t\t HW_VAR_H2C_FW_PWRMODE,\n\t\t\t\t\t &rtlps->pwr_mode);\n\t\t\t}\n\n\t\t}\n\t\tbreak;\n\tcase P2P_PS_ENABLE:\n\t\tif (p2pinfo->p2p_ps_mode > P2P_PS_NONE) {\n\t\t\tp2pinfo->p2p_ps_state = p2p_ps_state;\n\n\t\t\tif (p2pinfo->ctwindow > 0) {\n\t\t\t\tif (rtlps->smart_ps != 0) {\n\t\t\t\t\trtlps->smart_ps = 0;\n\t\t\t\t\trtlpriv->cfg->ops->set_hw_reg(hw,\n\t\t\t\t\t\t HW_VAR_H2C_FW_PWRMODE,\n\t\t\t\t\t\t &rtlps->pwr_mode);\n\t\t\t\t}\n\t\t\t}\n\t\t\trtlpriv->cfg->ops->set_hw_reg(hw,\n\t\t\t\t HW_VAR_H2C_FW_P2P_PS_OFFLOAD,\n\t\t\t\t &p2p_ps_state);\n\n\t\t}\n\t\tbreak;\n\tcase P2P_PS_SCAN:\n\tcase P2P_PS_SCAN_DONE:\n\tcase P2P_PS_ALLSTASLEEP:\n\t\tif (p2pinfo->p2p_ps_mode > P2P_PS_NONE) {\n\t\t\tp2pinfo->p2p_ps_state = p2p_ps_state;\n\t\t\trtlpriv->cfg->ops->set_hw_reg(hw,\n\t\t\t\t HW_VAR_H2C_FW_P2P_PS_OFFLOAD,\n\t\t\t\t &p2p_ps_state);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\trtl_dbg(rtlpriv, COMP_FW, DBG_LOUD,\n\t\t\"ctwindow %x oppps %x\\n\",\n\t\tp2pinfo->ctwindow, p2pinfo->opp_ps);\n\trtl_dbg(rtlpriv, COMP_FW, DBG_LOUD,\n\t\t\"count %x duration %x index %x interval %x start time %x noa num %x\\n\",\n\t\tp2pinfo->noa_count_type[0],\n\t\tp2pinfo->noa_duration[0],\n\t\tp2pinfo->noa_index,\n\t\tp2pinfo->noa_interval[0],\n\t\tp2pinfo->noa_start_time[0],\n\t\tp2pinfo->noa_num);\n\trtl_dbg(rtlpriv, COMP_FW, DBG_LOUD, \"end\\n\");\n}\n\nvoid rtl_p2p_info(struct ieee80211_hw *hw, void *data, unsigned int len)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct ieee80211_hdr *hdr = data;\n\n\tif (!mac->p2p)\n\t\treturn;\n\tif (mac->link_state != MAC80211_LINKED)\n\t\treturn;\n\t \n\tif (len <= 40 + FCS_LEN)\n\t\treturn;\n\n\t \n\tif (!ether_addr_equal_64bits(hdr->addr3, rtlpriv->mac80211.bssid))\n\t\treturn;\n\n\t \n\tif (!(ieee80211_is_beacon(hdr->frame_control) ||\n\t      ieee80211_is_probe_resp(hdr->frame_control) ||\n\t      ieee80211_is_action(hdr->frame_control)))\n\t\treturn;\n\n\tif (ieee80211_is_action(hdr->frame_control))\n\t\trtl_p2p_action_ie(hw , data , len - FCS_LEN);\n\telse\n\t\trtl_p2p_noa_ie(hw , data , len - FCS_LEN);\n}\nEXPORT_SYMBOL_GPL(rtl_p2p_info);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}