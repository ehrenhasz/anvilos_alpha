{
  "module_name": "cam.c",
  "hash_id": "52a9c8bae2f9cc2b92fa7a6bea119e717763daf1f40852f1e5ec4a7a0176a199",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtlwifi/cam.c",
  "human_readable_source": "\n \n\n#include \"wifi.h\"\n#include \"cam.h\"\n#include <linux/export.h>\n\nvoid rtl_cam_reset_sec_info(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtlpriv->sec.use_defaultkey = false;\n\trtlpriv->sec.pairwise_enc_algorithm = NO_ENCRYPTION;\n\trtlpriv->sec.group_enc_algorithm = NO_ENCRYPTION;\n\tmemset(rtlpriv->sec.key_buf, 0, KEY_BUF_SIZE * MAX_KEY_LEN);\n\tmemset(rtlpriv->sec.key_len, 0, KEY_BUF_SIZE);\n\trtlpriv->sec.pairwise_key = NULL;\n}\n\nstatic void rtl_cam_program_entry(struct ieee80211_hw *hw, u32 entry_no,\n\t\t\t   u8 *mac_addr, u8 *key_cont_128, u16 us_config)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\tu32 target_command;\n\tu32 target_content = 0;\n\tint entry_i;\n\n\tRT_PRINT_DATA(rtlpriv, COMP_SEC, DBG_DMESG, \"Key content :\",\n\t\t      key_cont_128, 16);\n\n\t \n\tfor (entry_i = CAM_CONTENT_COUNT - 1; entry_i >= 0; entry_i--) {\n\t\ttarget_command = entry_i + CAM_CONTENT_COUNT * entry_no;\n\t\ttarget_command = target_command | BIT(31) | BIT(16);\n\n\t\tif (entry_i == 0) {\n\t\t\ttarget_content = (u32) (*(mac_addr + 0)) << 16 |\n\t\t\t    (u32) (*(mac_addr + 1)) << 24 | (u32) us_config;\n\n\t\t\trtl_write_dword(rtlpriv, rtlpriv->cfg->maps[WCAMI],\n\t\t\t\t\ttarget_content);\n\t\t\trtl_write_dword(rtlpriv, rtlpriv->cfg->maps[RWCAM],\n\t\t\t\t\ttarget_command);\n\n\t\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_LOUD,\n\t\t\t\t\"WRITE %x: %x\\n\",\n\t\t\t\trtlpriv->cfg->maps[WCAMI], target_content);\n\t\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_LOUD,\n\t\t\t\t\"The Key ID is %d\\n\", entry_no);\n\t\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_LOUD,\n\t\t\t\t\"WRITE %x: %x\\n\",\n\t\t\t\trtlpriv->cfg->maps[RWCAM], target_command);\n\n\t\t} else if (entry_i == 1) {\n\n\t\t\ttarget_content = (u32) (*(mac_addr + 5)) << 24 |\n\t\t\t    (u32) (*(mac_addr + 4)) << 16 |\n\t\t\t    (u32) (*(mac_addr + 3)) << 8 |\n\t\t\t    (u32) (*(mac_addr + 2));\n\n\t\t\trtl_write_dword(rtlpriv, rtlpriv->cfg->maps[WCAMI],\n\t\t\t\t\ttarget_content);\n\t\t\trtl_write_dword(rtlpriv, rtlpriv->cfg->maps[RWCAM],\n\t\t\t\t\ttarget_command);\n\n\t\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_LOUD,\n\t\t\t\t\"WRITE A4: %x\\n\", target_content);\n\t\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_LOUD,\n\t\t\t\t\"WRITE A0: %x\\n\", target_command);\n\n\t\t} else {\n\n\t\t\ttarget_content =\n\t\t\t    (u32) (*(key_cont_128 + (entry_i * 4 - 8) + 3)) <<\n\t\t\t    24 | (u32) (*(key_cont_128 + (entry_i * 4 - 8) + 2))\n\t\t\t    << 16 |\n\t\t\t    (u32) (*(key_cont_128 + (entry_i * 4 - 8) + 1)) << 8\n\t\t\t    | (u32) (*(key_cont_128 + (entry_i * 4 - 8) + 0));\n\n\t\t\trtl_write_dword(rtlpriv, rtlpriv->cfg->maps[WCAMI],\n\t\t\t\t\ttarget_content);\n\t\t\trtl_write_dword(rtlpriv, rtlpriv->cfg->maps[RWCAM],\n\t\t\t\t\ttarget_command);\n\n\t\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_LOUD,\n\t\t\t\t\"WRITE A4: %x\\n\", target_content);\n\t\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_LOUD,\n\t\t\t\t\"WRITE A0: %x\\n\", target_command);\n\t\t}\n\t}\n\n\trtl_dbg(rtlpriv, COMP_SEC, DBG_LOUD,\n\t\t\"after set key, usconfig:%x\\n\", us_config);\n}\n\nu8 rtl_cam_add_one_entry(struct ieee80211_hw *hw, u8 *mac_addr,\n\t\t\t u32 ul_key_id, u32 ul_entry_idx, u32 ul_enc_alg,\n\t\t\t u32 ul_default_key, u8 *key_content)\n{\n\tu32 us_config;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtl_dbg(rtlpriv, COMP_SEC, DBG_DMESG,\n\t\t\"EntryNo:%x, ulKeyId=%x, ulEncAlg=%x, ulUseDK=%x MacAddr %pM\\n\",\n\t\tul_entry_idx, ul_key_id, ul_enc_alg,\n\t\tul_default_key, mac_addr);\n\n\tif (ul_key_id == TOTAL_CAM_ENTRY) {\n\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_WARNING,\n\t\t\t\"ulKeyId exceed!\\n\");\n\t\treturn 0;\n\t}\n\n\tif (ul_default_key == 1)\n\t\tus_config = CFG_VALID | ((u16) (ul_enc_alg) << 2);\n\telse\n\t\tus_config = CFG_VALID | ((ul_enc_alg) << 2) | ul_key_id;\n\n\trtl_cam_program_entry(hw, ul_entry_idx, mac_addr,\n\t\t\t      (u8 *)key_content, us_config);\n\n\trtl_dbg(rtlpriv, COMP_SEC, DBG_DMESG, \"end\\n\");\n\n\treturn 1;\n\n}\nEXPORT_SYMBOL(rtl_cam_add_one_entry);\n\nint rtl_cam_delete_one_entry(struct ieee80211_hw *hw,\n\t\t\t     u8 *mac_addr, u32 ul_key_id)\n{\n\tu32 ul_command;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtl_dbg(rtlpriv, COMP_SEC, DBG_DMESG, \"key_idx:%d\\n\", ul_key_id);\n\n\tul_command = ul_key_id * CAM_CONTENT_COUNT;\n\tul_command = ul_command | BIT(31) | BIT(16);\n\n\trtl_write_dword(rtlpriv, rtlpriv->cfg->maps[WCAMI], 0);\n\trtl_write_dword(rtlpriv, rtlpriv->cfg->maps[RWCAM], ul_command);\n\n\trtl_dbg(rtlpriv, COMP_SEC, DBG_DMESG,\n\t\t\"%s: WRITE A4: %x\\n\", __func__, 0);\n\trtl_dbg(rtlpriv, COMP_SEC, DBG_DMESG,\n\t\t\"%s: WRITE A0: %x\\n\", __func__, ul_command);\n\n\treturn 0;\n\n}\nEXPORT_SYMBOL(rtl_cam_delete_one_entry);\n\nvoid rtl_cam_reset_all_entry(struct ieee80211_hw *hw)\n{\n\tu32 ul_command;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\tul_command = BIT(31) | BIT(30);\n\trtl_write_dword(rtlpriv, rtlpriv->cfg->maps[RWCAM], ul_command);\n}\nEXPORT_SYMBOL(rtl_cam_reset_all_entry);\n\nvoid rtl_cam_mark_invalid(struct ieee80211_hw *hw, u8 uc_index)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\tu32 ul_command;\n\tu32 ul_content;\n\tu32 ul_enc_algo;\n\n\tswitch (rtlpriv->sec.pairwise_enc_algorithm) {\n\tcase WEP40_ENCRYPTION:\n\t\tul_enc_algo = rtlpriv->cfg->maps[SEC_CAM_WEP40];\n\t\tbreak;\n\tcase WEP104_ENCRYPTION:\n\t\tul_enc_algo = rtlpriv->cfg->maps[SEC_CAM_WEP104];\n\t\tbreak;\n\tcase TKIP_ENCRYPTION:\n\t\tul_enc_algo = rtlpriv->cfg->maps[SEC_CAM_TKIP];\n\t\tbreak;\n\tcase AESCCMP_ENCRYPTION:\n\t\tul_enc_algo = rtlpriv->cfg->maps[SEC_CAM_AES];\n\t\tbreak;\n\tdefault:\n\t\tul_enc_algo = rtlpriv->cfg->maps[SEC_CAM_AES];\n\t}\n\n\tul_content = (uc_index & 3) | ((u16) (ul_enc_algo) << 2);\n\n\tul_content |= BIT(15);\n\tul_command = CAM_CONTENT_COUNT * uc_index;\n\tul_command = ul_command | BIT(31) | BIT(16);\n\n\trtl_write_dword(rtlpriv, rtlpriv->cfg->maps[WCAMI], ul_content);\n\trtl_write_dword(rtlpriv, rtlpriv->cfg->maps[RWCAM], ul_command);\n\n\trtl_dbg(rtlpriv, COMP_SEC, DBG_DMESG,\n\t\t\"%s: WRITE A4: %x\\n\", __func__, ul_content);\n\trtl_dbg(rtlpriv, COMP_SEC, DBG_DMESG,\n\t\t\"%s: WRITE A0: %x\\n\", __func__, ul_command);\n}\nEXPORT_SYMBOL(rtl_cam_mark_invalid);\n\nvoid rtl_cam_empty_entry(struct ieee80211_hw *hw, u8 uc_index)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\tu32 ul_command;\n\tu32 ul_content;\n\tu32 ul_encalgo;\n\tu8 entry_i;\n\n\tswitch (rtlpriv->sec.pairwise_enc_algorithm) {\n\tcase WEP40_ENCRYPTION:\n\t\tul_encalgo = rtlpriv->cfg->maps[SEC_CAM_WEP40];\n\t\tbreak;\n\tcase WEP104_ENCRYPTION:\n\t\tul_encalgo = rtlpriv->cfg->maps[SEC_CAM_WEP104];\n\t\tbreak;\n\tcase TKIP_ENCRYPTION:\n\t\tul_encalgo = rtlpriv->cfg->maps[SEC_CAM_TKIP];\n\t\tbreak;\n\tcase AESCCMP_ENCRYPTION:\n\t\tul_encalgo = rtlpriv->cfg->maps[SEC_CAM_AES];\n\t\tbreak;\n\tdefault:\n\t\tul_encalgo = rtlpriv->cfg->maps[SEC_CAM_AES];\n\t}\n\n\tfor (entry_i = 0; entry_i < CAM_CONTENT_COUNT; entry_i++) {\n\n\t\tif (entry_i == 0) {\n\t\t\tul_content =\n\t\t\t    (uc_index & 0x03) | ((u16) (ul_encalgo) << 2);\n\t\t\tul_content |= BIT(15);\n\n\t\t} else {\n\t\t\tul_content = 0;\n\t\t}\n\n\t\tul_command = CAM_CONTENT_COUNT * uc_index + entry_i;\n\t\tul_command = ul_command | BIT(31) | BIT(16);\n\n\t\trtl_write_dword(rtlpriv, rtlpriv->cfg->maps[WCAMI], ul_content);\n\t\trtl_write_dword(rtlpriv, rtlpriv->cfg->maps[RWCAM], ul_command);\n\n\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_LOUD,\n\t\t\t\"%s: WRITE A4: %x\\n\", __func__, ul_content);\n\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_LOUD,\n\t\t\t\"%s: WRITE A0: %x\\n\", __func__, ul_command);\n\t}\n\n}\nEXPORT_SYMBOL(rtl_cam_empty_entry);\n\nu8 rtl_cam_get_free_entry(struct ieee80211_hw *hw, u8 *sta_addr)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 bitmap = (rtlpriv->sec.hwsec_cam_bitmap) >> 4;\n\tu8 entry_idx = 0;\n\tu8 i, *addr;\n\n\tif (NULL == sta_addr) {\n\t\tpr_err(\"sta_addr is NULL.\\n\");\n\t\treturn TOTAL_CAM_ENTRY;\n\t}\n\t \n\tfor (i = 4; i < TOTAL_CAM_ENTRY; i++) {\n\t\taddr = rtlpriv->sec.hwsec_cam_sta_addr[i];\n\t\tif (ether_addr_equal_unaligned(addr, sta_addr))\n\t\t\treturn i;\n\t}\n\t \n\tfor (entry_idx = 4; entry_idx < TOTAL_CAM_ENTRY; entry_idx++) {\n\t\tif ((bitmap & BIT(0)) == 0) {\n\t\t\tpr_err(\"-----hwsec_cam_bitmap: 0x%x entry_idx=%d\\n\",\n\t\t\t       rtlpriv->sec.hwsec_cam_bitmap, entry_idx);\n\t\t\trtlpriv->sec.hwsec_cam_bitmap |= BIT(0) << entry_idx;\n\t\t\tmemcpy(rtlpriv->sec.hwsec_cam_sta_addr[entry_idx],\n\t\t\t       sta_addr, ETH_ALEN);\n\t\t\treturn entry_idx;\n\t\t}\n\t\tbitmap = bitmap >> 1;\n\t}\n\treturn TOTAL_CAM_ENTRY;\n}\nEXPORT_SYMBOL(rtl_cam_get_free_entry);\n\nvoid rtl_cam_del_entry(struct ieee80211_hw *hw, u8 *sta_addr)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 bitmap;\n\tu8 i, *addr;\n\n\tif (NULL == sta_addr) {\n\t\tpr_err(\"sta_addr is NULL.\\n\");\n\t\treturn;\n\t}\n\n\tif (is_zero_ether_addr(sta_addr)) {\n\t\tpr_err(\"sta_addr is %pM\\n\", sta_addr);\n\t\treturn;\n\t}\n\t \n\tfor (i = 4; i < TOTAL_CAM_ENTRY; i++) {\n\t\taddr = rtlpriv->sec.hwsec_cam_sta_addr[i];\n\t\tbitmap = (rtlpriv->sec.hwsec_cam_bitmap) >> i;\n\t\tif (((bitmap & BIT(0)) == BIT(0)) &&\n\t\t    (ether_addr_equal_unaligned(addr, sta_addr))) {\n\t\t\t \n\t\t\teth_zero_addr(rtlpriv->sec.hwsec_cam_sta_addr[i]);\n\t\t\trtlpriv->sec.hwsec_cam_bitmap &= ~(BIT(0) << i);\n\t\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_DMESG,\n\t\t\t\t\"&&&&&&&&&del entry %d\\n\", i);\n\t\t}\n\t}\n\treturn;\n}\nEXPORT_SYMBOL(rtl_cam_del_entry);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}