{
  "module_name": "hw.c",
  "hash_id": "bbab85901d372353adacd09a61c473623866e2c655ef4c4e76dd8023b73cb2cd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtlwifi/rtl8192se/hw.c",
  "human_readable_source": "\n \n\n#include \"../wifi.h\"\n#include \"../efuse.h\"\n#include \"../base.h\"\n#include \"../regd.h\"\n#include \"../cam.h\"\n#include \"../ps.h\"\n#include \"../pci.h\"\n#include \"reg.h\"\n#include \"def.h\"\n#include \"phy.h\"\n#include \"dm.h\"\n#include \"fw.h\"\n#include \"led.h\"\n#include \"hw.h\"\n\nvoid rtl92se_get_hw_reg(struct ieee80211_hw *hw, u8 variable, u8 *val)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\n\tswitch (variable) {\n\tcase HW_VAR_RCR: {\n\t\t\t*((u32 *) (val)) = rtlpci->receive_config;\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_RF_STATE: {\n\t\t\t*((enum rf_pwrstate *)(val)) = ppsc->rfpwr_state;\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_FW_PSMODE_STATUS: {\n\t\t\t*((bool *) (val)) = ppsc->fw_current_inpsmode;\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_CORRECT_TSF: {\n\t\t\tu64 tsf;\n\t\t\tu32 *ptsf_low = (u32 *)&tsf;\n\t\t\tu32 *ptsf_high = ((u32 *)&tsf) + 1;\n\n\t\t\t*ptsf_high = rtl_read_dword(rtlpriv, (TSFR + 4));\n\t\t\t*ptsf_low = rtl_read_dword(rtlpriv, TSFR);\n\n\t\t\t*((u64 *) (val)) = tsf;\n\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_MRC: {\n\t\t\t*((bool *)(val)) = rtlpriv->dm.current_mrc_switch;\n\t\t\tbreak;\n\t\t}\n\tcase HAL_DEF_WOWLAN:\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"switch case %#x not processed\\n\", variable);\n\t\tbreak;\n\t}\n}\n\nvoid rtl92se_set_hw_reg(struct ieee80211_hw *hw, u8 variable, u8 *val)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\n\tswitch (variable) {\n\tcase HW_VAR_ETHER_ADDR:{\n\t\t\trtl_write_dword(rtlpriv, IDR0, ((u32 *)(val))[0]);\n\t\t\trtl_write_word(rtlpriv, IDR4, ((u16 *)(val + 4))[0]);\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_BASIC_RATE:{\n\t\t\tu16 rate_cfg = ((u16 *) val)[0];\n\t\t\tu8 rate_index = 0;\n\n\t\t\tif (rtlhal->version == VERSION_8192S_ACUT)\n\t\t\t\trate_cfg = rate_cfg & 0x150;\n\t\t\telse\n\t\t\t\trate_cfg = rate_cfg & 0x15f;\n\n\t\t\trate_cfg |= 0x01;\n\n\t\t\trtl_write_byte(rtlpriv, RRSR, rate_cfg & 0xff);\n\t\t\trtl_write_byte(rtlpriv, RRSR + 1,\n\t\t\t\t       (rate_cfg >> 8) & 0xff);\n\n\t\t\twhile (rate_cfg > 0x1) {\n\t\t\t\trate_cfg = (rate_cfg >> 1);\n\t\t\t\trate_index++;\n\t\t\t}\n\t\t\trtl_write_byte(rtlpriv, INIRTSMCS_SEL, rate_index);\n\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_BSSID:{\n\t\t\trtl_write_dword(rtlpriv, BSSIDR, ((u32 *)(val))[0]);\n\t\t\trtl_write_word(rtlpriv, BSSIDR + 4,\n\t\t\t\t       ((u16 *)(val + 4))[0]);\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_SIFS:{\n\t\t\trtl_write_byte(rtlpriv, SIFS_OFDM, val[0]);\n\t\t\trtl_write_byte(rtlpriv, SIFS_OFDM + 1, val[1]);\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_SLOT_TIME:{\n\t\t\tu8 e_aci;\n\n\t\t\trtl_dbg(rtlpriv, COMP_MLME, DBG_LOUD,\n\t\t\t\t\"HW_VAR_SLOT_TIME %x\\n\", val[0]);\n\n\t\t\trtl_write_byte(rtlpriv, SLOT_TIME, val[0]);\n\n\t\t\tfor (e_aci = 0; e_aci < AC_MAX; e_aci++) {\n\t\t\t\trtlpriv->cfg->ops->set_hw_reg(hw,\n\t\t\t\t\t\tHW_VAR_AC_PARAM,\n\t\t\t\t\t\t(&e_aci));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_ACK_PREAMBLE:{\n\t\t\tu8 reg_tmp;\n\t\t\tu8 short_preamble = (bool) (*val);\n\t\t\treg_tmp = (mac->cur_40_prime_sc) << 5;\n\t\t\tif (short_preamble)\n\t\t\t\treg_tmp |= 0x80;\n\n\t\t\trtl_write_byte(rtlpriv, RRSR + 2, reg_tmp);\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_AMPDU_MIN_SPACE:{\n\t\t\tu8 min_spacing_to_set;\n\t\t\tu8 sec_min_space;\n\n\t\t\tmin_spacing_to_set = *val;\n\t\t\tif (min_spacing_to_set <= 7) {\n\t\t\t\tif (rtlpriv->sec.pairwise_enc_algorithm ==\n\t\t\t\t    NO_ENCRYPTION)\n\t\t\t\t\tsec_min_space = 0;\n\t\t\t\telse\n\t\t\t\t\tsec_min_space = 1;\n\n\t\t\t\tif (min_spacing_to_set < sec_min_space)\n\t\t\t\t\tmin_spacing_to_set = sec_min_space;\n\t\t\t\tif (min_spacing_to_set > 5)\n\t\t\t\t\tmin_spacing_to_set = 5;\n\n\t\t\t\tmac->min_space_cfg =\n\t\t\t\t\t\t((mac->min_space_cfg & 0xf8) |\n\t\t\t\t\t\tmin_spacing_to_set);\n\n\t\t\t\t*val = min_spacing_to_set;\n\n\t\t\t\trtl_dbg(rtlpriv, COMP_MLME, DBG_LOUD,\n\t\t\t\t\t\"Set HW_VAR_AMPDU_MIN_SPACE: %#x\\n\",\n\t\t\t\t\tmac->min_space_cfg);\n\n\t\t\t\trtl_write_byte(rtlpriv, AMPDU_MIN_SPACE,\n\t\t\t\t\t       mac->min_space_cfg);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_SHORTGI_DENSITY:{\n\t\t\tu8 density_to_set;\n\n\t\t\tdensity_to_set = *val;\n\t\t\tmac->min_space_cfg = rtlpriv->rtlhal.minspace_cfg;\n\t\t\tmac->min_space_cfg |= (density_to_set << 3);\n\n\t\t\trtl_dbg(rtlpriv, COMP_MLME, DBG_LOUD,\n\t\t\t\t\"Set HW_VAR_SHORTGI_DENSITY: %#x\\n\",\n\t\t\t\tmac->min_space_cfg);\n\n\t\t\trtl_write_byte(rtlpriv, AMPDU_MIN_SPACE,\n\t\t\t\t       mac->min_space_cfg);\n\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_AMPDU_FACTOR:{\n\t\t\tu8 factor_toset;\n\t\t\tu8 regtoset;\n\t\t\tu8 factorlevel[18] = {\n\t\t\t\t2, 4, 4, 7, 7, 13, 13,\n\t\t\t\t13, 2, 7, 7, 13, 13,\n\t\t\t\t15, 15, 15, 15, 0};\n\t\t\tu8 index = 0;\n\n\t\t\tfactor_toset = *val;\n\t\t\tif (factor_toset <= 3) {\n\t\t\t\tfactor_toset = (1 << (factor_toset + 2));\n\t\t\t\tif (factor_toset > 0xf)\n\t\t\t\t\tfactor_toset = 0xf;\n\n\t\t\t\tfor (index = 0; index < 17; index++) {\n\t\t\t\t\tif (factorlevel[index] > factor_toset)\n\t\t\t\t\t\tfactorlevel[index] =\n\t\t\t\t\t\t\t\t factor_toset;\n\t\t\t\t}\n\n\t\t\t\tfor (index = 0; index < 8; index++) {\n\t\t\t\t\tregtoset = ((factorlevel[index * 2]) |\n\t\t\t\t\t\t    (factorlevel[index *\n\t\t\t\t\t\t    2 + 1] << 4));\n\t\t\t\t\trtl_write_byte(rtlpriv,\n\t\t\t\t\t\t       AGGLEN_LMT_L + index,\n\t\t\t\t\t\t       regtoset);\n\t\t\t\t}\n\n\t\t\t\tregtoset = ((factorlevel[16]) |\n\t\t\t\t\t    (factorlevel[17] << 4));\n\t\t\t\trtl_write_byte(rtlpriv, AGGLEN_LMT_H, regtoset);\n\n\t\t\t\trtl_dbg(rtlpriv, COMP_MLME, DBG_LOUD,\n\t\t\t\t\t\"Set HW_VAR_AMPDU_FACTOR: %#x\\n\",\n\t\t\t\t\tfactor_toset);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_AC_PARAM:{\n\t\t\tu8 e_aci = *val;\n\t\t\trtl92s_dm_init_edca_turbo(hw);\n\n\t\t\tif (rtlpci->acm_method != EACMWAY2_SW)\n\t\t\t\trtlpriv->cfg->ops->set_hw_reg(hw,\n\t\t\t\t\t\t HW_VAR_ACM_CTRL,\n\t\t\t\t\t\t &e_aci);\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_ACM_CTRL:{\n\t\t\tu8 e_aci = *val;\n\t\t\tunion aci_aifsn *p_aci_aifsn = (union aci_aifsn *)(&(\n\t\t\t\t\t\t\tmac->ac[0].aifs));\n\t\t\tu8 acm = p_aci_aifsn->f.acm;\n\t\t\tu8 acm_ctrl = rtl_read_byte(rtlpriv, ACMHWCTRL);\n\n\t\t\tacm_ctrl = acm_ctrl | ((rtlpci->acm_method == 2) ?\n\t\t\t\t   0x0 : 0x1);\n\n\t\t\tif (acm) {\n\t\t\t\tswitch (e_aci) {\n\t\t\t\tcase AC0_BE:\n\t\t\t\t\tacm_ctrl |= ACMHW_BEQEN;\n\t\t\t\t\tbreak;\n\t\t\t\tcase AC2_VI:\n\t\t\t\t\tacm_ctrl |= ACMHW_VIQEN;\n\t\t\t\t\tbreak;\n\t\t\t\tcase AC3_VO:\n\t\t\t\t\tacm_ctrl |= ACMHW_VOQEN;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_WARNING,\n\t\t\t\t\t\t\"HW_VAR_ACM_CTRL acm set failed: eACI is %d\\n\",\n\t\t\t\t\t\tacm);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswitch (e_aci) {\n\t\t\t\tcase AC0_BE:\n\t\t\t\t\tacm_ctrl &= (~ACMHW_BEQEN);\n\t\t\t\t\tbreak;\n\t\t\t\tcase AC2_VI:\n\t\t\t\t\tacm_ctrl &= (~ACMHW_VIQEN);\n\t\t\t\t\tbreak;\n\t\t\t\tcase AC3_VO:\n\t\t\t\t\tacm_ctrl &= (~ACMHW_VOQEN);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tpr_err(\"switch case %#x not processed\\n\",\n\t\t\t\t\t       e_aci);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trtl_dbg(rtlpriv, COMP_QOS, DBG_TRACE,\n\t\t\t\t\"HW_VAR_ACM_CTRL Write 0x%X\\n\", acm_ctrl);\n\t\t\trtl_write_byte(rtlpriv, ACMHWCTRL, acm_ctrl);\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_RCR:{\n\t\t\trtl_write_dword(rtlpriv, RCR, ((u32 *) (val))[0]);\n\t\t\trtlpci->receive_config = ((u32 *) (val))[0];\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_RETRY_LIMIT:{\n\t\t\tu8 retry_limit = val[0];\n\n\t\t\trtl_write_word(rtlpriv, RETRY_LIMIT,\n\t\t\t\t       retry_limit << RETRY_LIMIT_SHORT_SHIFT |\n\t\t\t\t       retry_limit << RETRY_LIMIT_LONG_SHIFT);\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_DUAL_TSF_RST: {\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_EFUSE_BYTES: {\n\t\t\trtlefuse->efuse_usedbytes = *((u16 *) val);\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_EFUSE_USAGE: {\n\t\t\trtlefuse->efuse_usedpercentage = *val;\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_IO_CMD: {\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_WPA_CONFIG: {\n\t\t\trtl_write_byte(rtlpriv, REG_SECR, *val);\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_SET_RPWM:{\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_H2C_FW_PWRMODE:{\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_FW_PSMODE_STATUS: {\n\t\t\tppsc->fw_current_inpsmode = *((bool *) val);\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_H2C_FW_JOINBSSRPT:{\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_AID:{\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_CORRECT_TSF:{\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_MRC: {\n\t\t\tbool bmrc_toset = *((bool *)val);\n\t\t\tu8 u1bdata = 0;\n\n\t\t\tif (bmrc_toset) {\n\t\t\t\trtl_set_bbreg(hw, ROFDM0_TRXPATHENABLE,\n\t\t\t\t\t      MASKBYTE0, 0x33);\n\t\t\t\tu1bdata = (u8)rtl_get_bbreg(hw,\n\t\t\t\t\t\tROFDM1_TRXPATHENABLE,\n\t\t\t\t\t\tMASKBYTE0);\n\t\t\t\trtl_set_bbreg(hw, ROFDM1_TRXPATHENABLE,\n\t\t\t\t\t      MASKBYTE0,\n\t\t\t\t\t      ((u1bdata & 0xf0) | 0x03));\n\t\t\t\tu1bdata = (u8)rtl_get_bbreg(hw,\n\t\t\t\t\t\tROFDM0_TRXPATHENABLE,\n\t\t\t\t\t\tMASKBYTE1);\n\t\t\t\trtl_set_bbreg(hw, ROFDM0_TRXPATHENABLE,\n\t\t\t\t\t      MASKBYTE1,\n\t\t\t\t\t      (u1bdata | 0x04));\n\n\t\t\t\t \n\t\t\t\trtlpriv->dm.current_mrc_switch = bmrc_toset;\n\t\t\t} else {\n\t\t\t\trtl_set_bbreg(hw, ROFDM0_TRXPATHENABLE,\n\t\t\t\t\t      MASKBYTE0, 0x13);\n\t\t\t\tu1bdata = (u8)rtl_get_bbreg(hw,\n\t\t\t\t\t\t ROFDM1_TRXPATHENABLE,\n\t\t\t\t\t\t MASKBYTE0);\n\t\t\t\trtl_set_bbreg(hw, ROFDM1_TRXPATHENABLE,\n\t\t\t\t\t      MASKBYTE0,\n\t\t\t\t\t      ((u1bdata & 0xf0) | 0x01));\n\t\t\t\tu1bdata = (u8)rtl_get_bbreg(hw,\n\t\t\t\t\t\tROFDM0_TRXPATHENABLE,\n\t\t\t\t\t\tMASKBYTE1);\n\t\t\t\trtl_set_bbreg(hw, ROFDM0_TRXPATHENABLE,\n\t\t\t\t\t      MASKBYTE1, (u1bdata & 0xfb));\n\n\t\t\t\t \n\t\t\t\trtlpriv->dm.current_mrc_switch = bmrc_toset;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_FW_LPS_ACTION: {\n\t\tbool enter_fwlps = *((bool *)val);\n\t\tu8 rpwm_val, fw_pwrmode;\n\t\tbool fw_current_inps;\n\n\t\tif (enter_fwlps) {\n\t\t\trpwm_val = 0x02;\t \n\t\t\tfw_current_inps = true;\n\t\t\trtlpriv->cfg->ops->set_hw_reg(hw,\n\t\t\t\t\tHW_VAR_FW_PSMODE_STATUS,\n\t\t\t\t\t(u8 *)(&fw_current_inps));\n\t\t\trtlpriv->cfg->ops->set_hw_reg(hw,\n\t\t\t\t\tHW_VAR_H2C_FW_PWRMODE,\n\t\t\t\t\t&ppsc->fwctrl_psmode);\n\n\t\t\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_SET_RPWM,\n\t\t\t\t\t\t      &rpwm_val);\n\t\t} else {\n\t\t\trpwm_val = 0x0C;\t \n\t\t\tfw_pwrmode = FW_PS_ACTIVE_MODE;\n\t\t\tfw_current_inps = false;\n\t\t\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_SET_RPWM,\n\t\t\t\t\t\t      &rpwm_val);\n\t\t\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_H2C_FW_PWRMODE,\n\t\t\t\t\t\t      &fw_pwrmode);\n\n\t\t\trtlpriv->cfg->ops->set_hw_reg(hw,\n\t\t\t\t\tHW_VAR_FW_PSMODE_STATUS,\n\t\t\t\t\t(u8 *)(&fw_current_inps));\n\t\t}\n\t\tbreak; }\n\tdefault:\n\t\tpr_err(\"switch case %#x not processed\\n\", variable);\n\t\tbreak;\n\t}\n\n}\n\nvoid rtl92se_enable_hw_security_config(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 sec_reg_value = 0x0;\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\"PairwiseEncAlgorithm = %d GroupEncAlgorithm = %d\\n\",\n\t\trtlpriv->sec.pairwise_enc_algorithm,\n\t\trtlpriv->sec.group_enc_algorithm);\n\n\tif (rtlpriv->cfg->mod_params->sw_crypto || rtlpriv->sec.use_sw_sec) {\n\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_DMESG,\n\t\t\t\"not open hw encryption\\n\");\n\t\treturn;\n\t}\n\n\tsec_reg_value = SCR_TXENCENABLE | SCR_RXENCENABLE;\n\n\tif (rtlpriv->sec.use_defaultkey) {\n\t\tsec_reg_value |= SCR_TXUSEDK;\n\t\tsec_reg_value |= SCR_RXUSEDK;\n\t}\n\n\trtl_dbg(rtlpriv, COMP_SEC, DBG_LOUD, \"The SECR-value %x\\n\",\n\t\tsec_reg_value);\n\n\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_WPA_CONFIG, &sec_reg_value);\n\n}\n\nstatic u8 _rtl92se_halset_sysclk(struct ieee80211_hw *hw, u8 data)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 waitcount = 100;\n\tbool bresult = false;\n\tu8 tmpvalue;\n\n\trtl_write_byte(rtlpriv, SYS_CLKR + 1, data);\n\n\t \n\tudelay(400);\n\n\t \n\ttmpvalue = rtl_read_byte(rtlpriv, SYS_CLKR + 1);\n\tbresult = ((tmpvalue & BIT(7)) == (data & BIT(7)));\n\n\tif (!(data & (BIT(6) | BIT(7)))) {\n\t\twaitcount = 100;\n\t\ttmpvalue = 0;\n\n\t\twhile (1) {\n\t\t\twaitcount--;\n\n\t\t\ttmpvalue = rtl_read_byte(rtlpriv, SYS_CLKR + 1);\n\t\t\tif ((tmpvalue & BIT(6)))\n\t\t\t\tbreak;\n\n\t\t\tpr_err(\"wait for BIT(6) return value %x\\n\", tmpvalue);\n\t\t\tif (waitcount == 0)\n\t\t\t\tbreak;\n\n\t\t\tudelay(10);\n\t\t}\n\n\t\tif (waitcount == 0)\n\t\t\tbresult = false;\n\t\telse\n\t\t\tbresult = true;\n\t}\n\n\treturn bresult;\n}\n\nvoid rtl8192se_gpiobit3_cfg_inputmode(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 u1tmp;\n\n\t \n\trtl_write_byte(rtlpriv, MAC_PINMUX_CFG, (GPIOMUX_EN | GPIOSEL_GPIO));\n\tu1tmp = rtl_read_byte(rtlpriv, GPIO_IO_SEL);\n\n\t \n\tu1tmp &= HAL_8192S_HW_GPIO_OFF_MASK;\n\trtl_write_byte(rtlpriv, GPIO_IO_SEL, u1tmp);\n\n}\n\nstatic u8 _rtl92se_rf_onoff_detect(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 u1tmp;\n\tu8 retval = ERFON;\n\n\t \n\trtl_write_byte(rtlpriv, MAC_PINMUX_CFG, (GPIOMUX_EN | GPIOSEL_GPIO));\n\tu1tmp = rtl_read_byte(rtlpriv, GPIO_IO_SEL);\n\n\t \n\tu1tmp &= HAL_8192S_HW_GPIO_OFF_MASK;\n\trtl_write_byte(rtlpriv, GPIO_IO_SEL, u1tmp);\n\n\t \n\tmdelay(10);\n\n\t \n\tu1tmp = rtl_read_byte(rtlpriv, GPIO_IN_SE);\n\tretval = (u1tmp & HAL_8192S_HW_GPIO_OFF_BIT) ? ERFON : ERFOFF;\n\n\treturn retval;\n}\n\nstatic void _rtl92se_macconfig_before_fwdownload(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\n\tu8 i;\n\tu8 tmpu1b;\n\tu16 tmpu2b;\n\tu8 pollingcnt = 20;\n\n\tif (rtlpci->first_init) {\n\t\t \n\t\ttmpu1b = rtl_read_byte(rtlpriv, REG_SYS_FUNC_EN + 1);\n\t\ttmpu1b &= 0xFE;\n\t\trtl_write_byte(rtlpriv, REG_SYS_FUNC_EN + 1, tmpu1b);\n\t\tudelay(1);\n\t\trtl_write_byte(rtlpriv, REG_SYS_FUNC_EN + 1, tmpu1b | BIT(0));\n\t}\n\n\t \n\ttmpu1b = rtl_read_byte(rtlpriv, (SYS_CLKR + 1));\n\tif (tmpu1b & BIT(7)) {\n\t\ttmpu1b &= ~(BIT(6) | BIT(7));\n\n\t\t \n\t\tif (!_rtl92se_halset_sysclk(hw, tmpu1b))\n\t\t\treturn;\n\t}\n\n\trtl_write_byte(rtlpriv, AFE_PLL_CTRL, 0x0);\n\tudelay(50);\n\trtl_write_byte(rtlpriv, LDOA15_CTRL, 0x34);\n\tudelay(50);\n\n\t \n\trtl_write_byte(rtlpriv, RPWM, 0x0);\n\n\t \n\ttmpu1b = rtl_read_byte(rtlpriv, REG_SYS_FUNC_EN + 1);\n\ttmpu1b &= 0x73;\n\trtl_write_byte(rtlpriv, REG_SYS_FUNC_EN + 1, tmpu1b);\n\t \n\tmdelay(1);\n\n\trtl_write_byte(rtlpriv, CMDR, 0);\n\trtl_write_byte(rtlpriv, TCR, 0);\n\n\t \n\ttmpu1b = rtl_read_byte(rtlpriv, 0x562);\n\ttmpu1b |= 0x08;\n\trtl_write_byte(rtlpriv, 0x562, tmpu1b);\n\ttmpu1b &= ~(BIT(3));\n\trtl_write_byte(rtlpriv, 0x562, tmpu1b);\n\n\t \n\ttmpu1b = rtl_read_byte(rtlpriv, AFE_XTAL_CTRL);\n\trtl_write_byte(rtlpriv, AFE_XTAL_CTRL, (tmpu1b | 0x01));\n\t \n\tmdelay(2);\n\ttmpu1b = rtl_read_byte(rtlpriv, AFE_XTAL_CTRL + 1);\n\trtl_write_byte(rtlpriv, AFE_XTAL_CTRL + 1, (tmpu1b & 0xfb));\n\n\t \n\ttmpu1b = rtl_read_byte(rtlpriv, AFE_MISC);\n\trtl_write_byte(rtlpriv, AFE_MISC, (tmpu1b | BIT(0)));\n\tmdelay(1);\n\n\t \n\ttmpu1b = rtl_read_byte(rtlpriv, AFE_MISC);\n\trtl_write_byte(rtlpriv, AFE_MISC, (tmpu1b | 0x02));\n\tmdelay(1);\n\n\t \n\ttmpu1b = rtl_read_byte(rtlpriv, LDOA15_CTRL);\n\trtl_write_byte(rtlpriv, LDOA15_CTRL, (tmpu1b | BIT(0)));\n\n\t \n\ttmpu2b = rtl_read_word(rtlpriv, REG_SYS_ISO_CTRL);\n\trtl_write_word(rtlpriv, REG_SYS_ISO_CTRL, (tmpu2b | BIT(11)));\n\n\t \n\ttmpu2b = rtl_read_word(rtlpriv, REG_SYS_FUNC_EN);\n\trtl_write_word(rtlpriv, REG_SYS_FUNC_EN, (tmpu2b | BIT(13)));\n\n\trtl_write_byte(rtlpriv, REG_SYS_ISO_CTRL + 1, 0x68);\n\n\t \n\t \n\tudelay(200);\n\ttmpu1b = rtl_read_byte(rtlpriv, AFE_PLL_CTRL);\n\trtl_write_byte(rtlpriv, AFE_PLL_CTRL, (tmpu1b | BIT(0) | BIT(4)));\n\n\t \n\tudelay(100);\n\trtl_write_byte(rtlpriv, AFE_PLL_CTRL, (tmpu1b | BIT(0) |\n\t\t       BIT(4) | BIT(6)));\n\tudelay(10);\n\trtl_write_byte(rtlpriv, AFE_PLL_CTRL, (tmpu1b | BIT(0) | BIT(4)));\n\tudelay(10);\n\n\t \n\ttmpu1b = rtl_read_byte(rtlpriv, AFE_PLL_CTRL + 1);\n\trtl_write_byte(rtlpriv, AFE_PLL_CTRL + 1, (tmpu1b | BIT(0)));\n\tmdelay(1);\n\n\t \n\trtl_write_byte(rtlpriv, REG_SYS_ISO_CTRL, 0xA6);\n\n\t \n\ttmpu2b = rtl_read_word(rtlpriv, SYS_CLKR);\n\trtl_write_word(rtlpriv, SYS_CLKR, (tmpu2b | BIT(12) | BIT(11)));\n\n\t \n\ttmpu2b = rtl_read_word(rtlpriv, REG_SYS_FUNC_EN);\n\trtl_write_word(rtlpriv, REG_SYS_FUNC_EN, (tmpu2b | BIT(11)));\n\n\ttmpu1b = rtl_read_byte(rtlpriv, REG_SYS_FUNC_EN + 1);\n\trtl_write_byte(rtlpriv, REG_SYS_FUNC_EN + 1, tmpu1b & ~(BIT(7)));\n\n\t \n\trtl_write_word(rtlpriv, REG_SYS_FUNC_EN, (tmpu2b | BIT(11) | BIT(15)));\n\n\t \n\ttmpu2b = rtl_read_word(rtlpriv, SYS_CLKR);\n\trtl_write_word(rtlpriv, SYS_CLKR, (tmpu2b & (~BIT(2))));\n\n\ttmpu1b = rtl_read_byte(rtlpriv, (SYS_CLKR + 1));\n\ttmpu1b = ((tmpu1b | BIT(7)) & (~BIT(6)));\n\tif (!_rtl92se_halset_sysclk(hw, tmpu1b))\n\t\treturn;  \n\n\trtl_write_word(rtlpriv, CMDR, 0x07FC);\n\n\t \n\t \n\t \n\trtl_write_byte(rtlpriv, 0x6, 0x30);\n\trtl_write_byte(rtlpriv, 0x49, 0xf0);\n\n\trtl_write_byte(rtlpriv, 0x4b, 0x81);\n\n\trtl_write_byte(rtlpriv, 0xb5, 0x21);\n\n\trtl_write_byte(rtlpriv, 0xdc, 0xff);\n\trtl_write_byte(rtlpriv, 0xdd, 0xff);\n\trtl_write_byte(rtlpriv, 0xde, 0xff);\n\trtl_write_byte(rtlpriv, 0xdf, 0xff);\n\n\trtl_write_byte(rtlpriv, 0x11a, 0x00);\n\trtl_write_byte(rtlpriv, 0x11b, 0x00);\n\n\tfor (i = 0; i < 32; i++)\n\t\trtl_write_byte(rtlpriv, INIMCS_SEL + i, 0x1b);\n\n\trtl_write_byte(rtlpriv, 0x236, 0xff);\n\n\trtl_write_byte(rtlpriv, 0x503, 0x22);\n\n\tif (ppsc->support_aspm && !ppsc->support_backdoor)\n\t\trtl_write_byte(rtlpriv, 0x560, 0x40);\n\telse\n\t\trtl_write_byte(rtlpriv, 0x560, 0x00);\n\n\trtl_write_byte(rtlpriv, DBG_PORT, 0x91);\n\n\t \n\trtl_write_dword(rtlpriv, RDQDA, rtlpci->rx_ring[RX_MPDU_QUEUE].dma);\n\trtl_write_dword(rtlpriv, RCDA, rtlpci->rx_ring[RX_CMD_QUEUE].dma);\n\n\t \n\trtl_write_dword(rtlpriv, TBKDA, rtlpci->tx_ring[BK_QUEUE].dma);\n\trtl_write_dword(rtlpriv, TBEDA, rtlpci->tx_ring[BE_QUEUE].dma);\n\trtl_write_dword(rtlpriv, TVIDA, rtlpci->tx_ring[VI_QUEUE].dma);\n\trtl_write_dword(rtlpriv, TVODA, rtlpci->tx_ring[VO_QUEUE].dma);\n\trtl_write_dword(rtlpriv, TBDA, rtlpci->tx_ring[BEACON_QUEUE].dma);\n\trtl_write_dword(rtlpriv, TCDA, rtlpci->tx_ring[TXCMD_QUEUE].dma);\n\trtl_write_dword(rtlpriv, TMDA, rtlpci->tx_ring[MGNT_QUEUE].dma);\n\trtl_write_dword(rtlpriv, THPDA, rtlpci->tx_ring[HIGH_QUEUE].dma);\n\trtl_write_dword(rtlpriv, HDA, rtlpci->tx_ring[HCCA_QUEUE].dma);\n\n\trtl_write_word(rtlpriv, CMDR, 0x37FC);\n\n\t \n\t \n\tdo {\n\t\ttmpu1b = rtl_read_byte(rtlpriv, TCR);\n\t\tif ((tmpu1b & TXDMA_INIT_VALUE) == TXDMA_INIT_VALUE)\n\t\t\tbreak;\n\n\t\tudelay(5);\n\t} while (pollingcnt--);\n\n\tif (pollingcnt <= 0) {\n\t\tpr_err(\"Polling TXDMA_INIT_VALUE timeout!! Current TCR(%#x)\\n\",\n\t\t       tmpu1b);\n\t\ttmpu1b = rtl_read_byte(rtlpriv, CMDR);\n\t\trtl_write_byte(rtlpriv, CMDR, tmpu1b & (~TXDMA_EN));\n\t\tudelay(2);\n\t\t \n\t\trtl_write_byte(rtlpriv, CMDR, tmpu1b | TXDMA_EN);\n\t}\n\n\t \n\tif ((ppsc->rfoff_reason == RF_CHANGE_BY_IPS) ||\n\t   (ppsc->rfoff_reason == 0)) {\n\t\tenum rtl_led_pin pin0 = rtlpriv->ledctl.sw_led0;\n\t\tenum rf_pwrstate rfpwr_state_toset;\n\t\trfpwr_state_toset = _rtl92se_rf_onoff_detect(hw);\n\n\t\tif (rfpwr_state_toset == ERFON)\n\t\t\trtl92se_sw_led_on(hw, pin0);\n\t}\n}\n\nstatic void _rtl92se_macconfig_after_fwdownload(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tu8 i;\n\tu16 tmpu2b;\n\n\t \n\n\t \n\t \n\trtl_write_word(rtlpriv, CMDR, (BBRSTN | BB_GLB_RSTN |\n\t\t\tSCHEDULE_EN | MACRXEN | MACTXEN | DDMA_EN | FW2HW_EN |\n\t\t\tRXDMA_EN | TXDMA_EN | HCI_RXDMA_EN | HCI_TXDMA_EN));\n\n\t \n\trtl_write_dword(rtlpriv, TCR, rtl_read_dword(rtlpriv, TCR) |\n\t\t\tTXDMAPRE2FULL);\n\n\t \n\trtl_write_dword(rtlpriv, RCR, rtlpci->receive_config);\n\n\t \n\n\t \n\t \n\t \n\trtl_write_word(rtlpriv, SIFS_CCK, 0x0a0a);\n\trtl_write_word(rtlpriv, SIFS_OFDM, 0x1010);\n\n\t \n\trtl_write_byte(rtlpriv, ACK_TIMEOUT, 0x40);\n\n\t \n\trtl_write_word(rtlpriv, BCN_INTERVAL, 100);\n\trtl_write_word(rtlpriv, ATIMWND, 2);\n\n\t \n\t \n\t \n\n\t \n\t \n\t \n\trtl_write_byte(rtlpriv, RXDMA, rtl_read_byte(rtlpriv, RXDMA) | BIT(6));\n\n\t \n\t \n\n\tif (rtlhal->version == VERSION_8192S_ACUT)\n\t\trtl_write_byte(rtlpriv, RRSR, 0xf0);\n\telse if (rtlhal->version == VERSION_8192S_BCUT)\n\t\trtl_write_byte(rtlpriv, RRSR, 0xff);\n\trtl_write_byte(rtlpriv, RRSR + 1, 0x01);\n\trtl_write_byte(rtlpriv, RRSR + 2, 0x00);\n\n\t \n\t \n\tfor (i = 0; i < 8; i++) {\n\t\t \n\t\tif (rtlhal->version == VERSION_8192S_ACUT)\n\t\t\trtl_write_dword(rtlpriv, ARFR0 + i * 4, 0x1f0ff0f0);\n\t}\n\n\t \n\t \n\trtl_write_byte(rtlpriv, AGGLEN_LMT_H, 0x0f);\n\t \n\trtl_write_word(rtlpriv, AGGLEN_LMT_L, 0x7442);\n\t \n\trtl_write_word(rtlpriv, AGGLEN_LMT_L + 2, 0xddd7);\n\t \n\trtl_write_word(rtlpriv, AGGLEN_LMT_L + 4, 0xd772);\n\t \n\trtl_write_word(rtlpriv, AGGLEN_LMT_L + 6, 0xfffd);\n\n\t \n\trtl_write_dword(rtlpriv, DARFRC, 0x04010000);\n\trtl_write_dword(rtlpriv, DARFRC + 4, 0x09070605);\n\trtl_write_dword(rtlpriv, RARFRC, 0x04010000);\n\trtl_write_dword(rtlpriv, RARFRC + 4, 0x09070605);\n\n\t \n\t \n\trtl_write_word(rtlpriv, SG_RATE, 0xFFFF);\n\n\t \n\t \n\trtl_write_word(rtlpriv, NAV_PROT_LEN, 0x0080);\n\t \n\trtl_write_byte(rtlpriv, CFEND_TH, 0xFF);\n\t \n\trtl_write_byte(rtlpriv, AMPDU_MIN_SPACE, 0x07);\n\t \n\trtl_write_byte(rtlpriv, TXOP_STALL_CTRL, 0x00);\n\n\t \n\t \n\t \n\t \n\t \n\n\t \n\trtl_write_byte(rtlpriv, RXDRVINFO_SZ, 4);\n\n\t \n\t \n\ttmpu2b = rtl_read_byte(rtlpriv, REG_SYS_FUNC_EN);\n\trtl_write_byte(rtlpriv, REG_SYS_FUNC_EN, tmpu2b | BIT(13));\n\ttmpu2b = rtl_read_byte(rtlpriv, REG_SYS_ISO_CTRL);\n\trtl_write_byte(rtlpriv, REG_SYS_ISO_CTRL, tmpu2b & (~BIT(8)));\n\n\t \n\t \n\tif (rtlefuse->epromtype == EEPROM_BOOT_EFUSE) {\n\t\tu8\ttempval;\n\n\t\ttempval = rtl_read_byte(rtlpriv, REG_SYS_ISO_CTRL + 1);\n\t\ttempval &= 0xFE;\n\t\trtl_write_byte(rtlpriv, REG_SYS_ISO_CTRL + 1, tempval);\n\n\t\t \n\t\trtl_write_byte(rtlpriv, REG_EFUSE_CTRL + 3, 0x72);\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG, \"EFUSE CONFIG OK\\n\");\n\t}\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG, \"OK\\n\");\n\n}\n\nstatic void _rtl92se_hw_configure(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\n\tu8 reg_bw_opmode = 0;\n\tu32 reg_rrsr = 0;\n\tu8 regtmp = 0;\n\n\treg_bw_opmode = BW_OPMODE_20MHZ;\n\treg_rrsr = RATE_ALL_CCK | RATE_ALL_OFDM_AG;\n\n\tregtmp = rtl_read_byte(rtlpriv, INIRTSMCS_SEL);\n\treg_rrsr = ((reg_rrsr & 0x000fffff) << 8) | regtmp;\n\trtl_write_dword(rtlpriv, INIRTSMCS_SEL, reg_rrsr);\n\trtl_write_byte(rtlpriv, BW_OPMODE, reg_bw_opmode);\n\n\t \n\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_RETRY_LIMIT,\n\t\t\t(u8 *)(&rtlpci->shortretry_limit));\n\n\trtl_write_byte(rtlpriv, MLT, 0x8f);\n\n\t \n\tswitch (rtlphy->rf_type) {\n\tcase RF_1T2R:\n\tcase RF_1T1R:\n\t\trtlhal->minspace_cfg = (MAX_MSS_DENSITY_1T << 3);\n\t\tbreak;\n\tcase RF_2T2R:\n\tcase RF_2T2R_GREEN:\n\t\trtlhal->minspace_cfg = (MAX_MSS_DENSITY_2T << 3);\n\t\tbreak;\n\t}\n\trtl_write_byte(rtlpriv, AMPDU_MIN_SPACE, rtlhal->minspace_cfg);\n}\n\nint rtl92se_hw_init(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tu8 tmp_byte = 0;\n\tunsigned long flags;\n\tbool rtstatus = true;\n\tu8 tmp_u1b;\n\tint err = false;\n\tu8 i;\n\tint wdcapra_add[] = {\n\t\tEDCAPARA_BE, EDCAPARA_BK,\n\t\tEDCAPARA_VI, EDCAPARA_VO};\n\tu8 secr_value = 0x0;\n\n\trtlpci->being_init_adapter = true;\n\n\t \n\tlocal_save_flags(flags);\n\tlocal_irq_enable();\n\n\trtlpriv->intf_ops->disable_aspm(hw);\n\n\t \n\t \n\t_rtl92se_macconfig_before_fwdownload(hw);\n\n\trtlhal->version = (enum version_8192s)((rtl_read_dword(rtlpriv,\n\t\t\tPMC_FSM) >> 16) & 0xF);\n\n\trtl8192se_gpiobit3_cfg_inputmode(hw);\n\n\t \n\trtstatus = rtl92s_download_fw(hw);\n\tif (!rtstatus) {\n\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_WARNING,\n\t\t\t\"Failed to download FW. Init HW without FW now... Please copy FW into /lib/firmware/rtlwifi\\n\");\n\t\terr = 1;\n\t\tgoto exit;\n\t}\n\n\t \n\t_rtl92se_macconfig_after_fwdownload(hw);\n\n\t \n\trtlhal->fwcmd_iomap =\trtl_read_word(rtlpriv, LBUS_MON_ADDR);\n\trtlhal->fwcmd_ioparam = rtl_read_dword(rtlpriv, LBUS_ADDR_MASK);\n\n\t \n\tif (!rtl92s_phy_mac_config(hw)) {\n\t\tpr_err(\"MAC Config failed\\n\");\n\t\terr = rtstatus;\n\t\tgoto exit;\n\t}\n\n\t \n\trtlpci->receive_config = rtl_read_dword(rtlpriv, RCR);\n\trtlpci->receive_config &= ~(RCR_ACRC32 | RCR_AICV);\n\trtl_write_dword(rtlpriv, RCR, rtlpci->receive_config);\n\n\t \n\t \n\trtl_write_dword(rtlpriv, CMDR, 0x37FC);\n\n\t \n\tif (!rtl92s_phy_bb_config(hw)) {\n\t\tpr_err(\"BB Config failed\\n\");\n\t\terr = rtstatus;\n\t\tgoto exit;\n\t}\n\n\t \n\t \n\n\trtlphy->rf_mode = RF_OP_BY_SW_3WIRE;\n\n\t \n\trtl_write_byte(rtlpriv, AFE_XTAL_CTRL + 1, 0xDB);\n\tif (rtlhal->version == VERSION_8192S_ACUT)\n\t\trtl_write_byte(rtlpriv, SPS1_CTRL + 3, 0x07);\n\telse\n\t\trtl_write_byte(rtlpriv, RF_CTRL, 0x07);\n\n\tif (!rtl92s_phy_rf_config(hw)) {\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG, \"RF Config failed\\n\");\n\t\terr = rtstatus;\n\t\tgoto exit;\n\t}\n\n\t \n\n\trtlphy->rfreg_chnlval[0] = rtl92s_phy_query_rf_reg(hw,\n\t\t\t\t\t\t\t   (enum radio_path)0,\n\t\t\t\t\t\t\t   RF_CHNLBW,\n\t\t\t\t\t\t\t   RFREG_OFFSET_MASK);\n\trtlphy->rfreg_chnlval[1] = rtl92s_phy_query_rf_reg(hw,\n\t\t\t\t\t\t\t   (enum radio_path)1,\n\t\t\t\t\t\t\t   RF_CHNLBW,\n\t\t\t\t\t\t\t   RFREG_OFFSET_MASK);\n\n\t \n\trtl_set_bbreg(hw, RFPGA0_RFMOD, BCCKEN, 0x1);\n\trtl_set_bbreg(hw, RFPGA0_RFMOD, BOFDMEN, 0x1);\n\n\t \n\t_rtl92se_hw_configure(hw);\n\n\t \n\t \n\t \n\trtl92s_phy_get_hw_reg_originalvalue(hw);\n\t \n\trtl92s_phy_set_txpower(hw, rtlphy->current_channel);\n\n\t \n\tfor (i = 0; i < 6; i++)\n\t\trtl_write_byte(rtlpriv, MACIDR0 + i, rtlefuse->dev_addr[i]);\n\n\t \n\ttmp_u1b = rtl_read_byte(rtlpriv, MAC_PINMUX_CFG);\n\trtl_write_byte(rtlpriv, MAC_PINMUX_CFG, tmp_u1b & (~BIT(3)));\n\n\trtl_write_byte(rtlpriv, 0x4d, 0x0);\n\n\tif (hal_get_firmwareversion(rtlpriv) >= 0x49) {\n\t\ttmp_byte = rtl_read_byte(rtlpriv, FW_RSVD_PG_CRTL) & (~BIT(4));\n\t\ttmp_byte = tmp_byte | BIT(5);\n\t\trtl_write_byte(rtlpriv, FW_RSVD_PG_CRTL, tmp_byte);\n\t\trtl_write_dword(rtlpriv, TXDESC_MSK, 0xFFFFCFFF);\n\t}\n\n\t \n\tif (hal_get_firmwareversion(rtlpriv) >= 0x35) {\n\t\t \n\t\trtl92s_phy_set_fw_cmd(hw, FW_CMD_RA_INIT);\n\t} else if (hal_get_firmwareversion(rtlpriv) == 0x34) {\n\t\t \n\t\trtl_write_dword(rtlpriv, WFM5, FW_RA_INIT);\n\t\trtl92s_phy_chk_fwcmd_iodone(hw);\n\t} else {\n\t\t \n\t\trtl_write_dword(rtlpriv, WFM5, FW_RA_RESET);\n\t\trtl92s_phy_chk_fwcmd_iodone(hw);\n\t\trtl_write_dword(rtlpriv, WFM5, FW_RA_ACTIVE);\n\t\trtl92s_phy_chk_fwcmd_iodone(hw);\n\t\trtl_write_dword(rtlpriv, WFM5, FW_RA_REFRESH);\n\t\trtl92s_phy_chk_fwcmd_iodone(hw);\n\t}\n\n\t \n\t \n\trtl92s_phy_switch_ephy_parameter(hw);\n\n\t \n\trtl_cam_reset_all_entry(hw);\n\tsecr_value |= SCR_TXENCENABLE;\n\tsecr_value |= SCR_RXENCENABLE;\n\tsecr_value |= SCR_NOSKMC;\n\trtl_write_byte(rtlpriv, REG_SECR, secr_value);\n\n\tfor (i = 0; i < 4; i++)\n\t\trtl_write_dword(rtlpriv, wdcapra_add[i], 0x5e4322);\n\n\tif (rtlphy->rf_type == RF_1T2R) {\n\t\tbool mrc2set = true;\n\t\t \n\t\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_MRC, (u8 *)&mrc2set);\n\t}\n\n\trtlpriv->cfg->ops->led_control(hw, LED_CTL_POWER_ON);\n\trtl92s_dm_init(hw);\nexit:\n\tlocal_irq_restore(flags);\n\trtlpci->being_init_adapter = false;\n\treturn err;\n}\n\nvoid rtl92se_set_mac_addr(struct rtl_io *io, const u8 *addr)\n{\n\t \n}\n\nvoid rtl92se_set_check_bssid(struct ieee80211_hw *hw, bool check_bssid)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 reg_rcr;\n\n\tif (rtlpriv->psc.rfpwr_state != ERFON)\n\t\treturn;\n\n\trtlpriv->cfg->ops->get_hw_reg(hw, HW_VAR_RCR, (u8 *)(&reg_rcr));\n\n\tif (check_bssid) {\n\t\treg_rcr |= (RCR_CBSSID);\n\t\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_RCR, (u8 *)(&reg_rcr));\n\t} else if (!check_bssid) {\n\t\treg_rcr &= (~RCR_CBSSID);\n\t\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_RCR, (u8 *)(&reg_rcr));\n\t}\n\n}\n\nstatic int _rtl92se_set_media_status(struct ieee80211_hw *hw,\n\t\t\t\t     enum nl80211_iftype type)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 bt_msr = rtl_read_byte(rtlpriv, MSR);\n\tu32 temp;\n\tbt_msr &= ~MSR_LINK_MASK;\n\n\tswitch (type) {\n\tcase NL80211_IFTYPE_UNSPECIFIED:\n\t\tbt_msr |= (MSR_LINK_NONE << MSR_LINK_SHIFT);\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\t\"Set Network type to NO LINK!\\n\");\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tbt_msr |= (MSR_LINK_ADHOC << MSR_LINK_SHIFT);\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\t\"Set Network type to Ad Hoc!\\n\");\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tbt_msr |= (MSR_LINK_MANAGED << MSR_LINK_SHIFT);\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\t\"Set Network type to STA!\\n\");\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\t\tbt_msr |= (MSR_LINK_MASTER << MSR_LINK_SHIFT);\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\t\"Set Network type to AP!\\n\");\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Network type %d not supported!\\n\", type);\n\t\treturn 1;\n\n\t}\n\n\tif (type != NL80211_IFTYPE_AP &&\n\t    rtlpriv->mac80211.link_state < MAC80211_LINKED)\n\t\tbt_msr = rtl_read_byte(rtlpriv, MSR) & ~MSR_LINK_MASK;\n\trtl_write_byte(rtlpriv, MSR, bt_msr);\n\n\ttemp = rtl_read_dword(rtlpriv, TCR);\n\trtl_write_dword(rtlpriv, TCR, temp & (~BIT(8)));\n\trtl_write_dword(rtlpriv, TCR, temp | BIT(8));\n\n\n\treturn 0;\n}\n\n \nint rtl92se_set_network_type(struct ieee80211_hw *hw, enum nl80211_iftype type)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\tif (_rtl92se_set_media_status(hw, type))\n\t\treturn -EOPNOTSUPP;\n\n\tif (rtlpriv->mac80211.link_state == MAC80211_LINKED) {\n\t\tif (type != NL80211_IFTYPE_AP)\n\t\t\trtl92se_set_check_bssid(hw, true);\n\t} else {\n\t\trtl92se_set_check_bssid(hw, false);\n\t}\n\n\treturn 0;\n}\n\n \nvoid rtl92se_set_qos(struct ieee80211_hw *hw, int aci)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\trtl92s_dm_init_edca_turbo(hw);\n\n\tswitch (aci) {\n\tcase AC1_BK:\n\t\trtl_write_dword(rtlpriv, EDCAPARA_BK, 0xa44f);\n\t\tbreak;\n\tcase AC0_BE:\n\t\t \n\t\tbreak;\n\tcase AC2_VI:\n\t\trtl_write_dword(rtlpriv, EDCAPARA_VI, 0x5e4322);\n\t\tbreak;\n\tcase AC3_VO:\n\t\trtl_write_dword(rtlpriv, EDCAPARA_VO, 0x2f3222);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ONCE(true, \"rtl8192se: invalid aci: %d !\\n\", aci);\n\t\tbreak;\n\t}\n}\n\nvoid rtl92se_enable_interrupt(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\n\trtl_write_dword(rtlpriv, INTA_MASK, rtlpci->irq_mask[0]);\n\t \n\trtl_write_dword(rtlpriv, INTA_MASK + 4, rtlpci->irq_mask[1] & 0x3F);\n\trtlpci->irq_enabled = true;\n}\n\nvoid rtl92se_disable_interrupt(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv;\n\tstruct rtl_pci *rtlpci;\n\n\trtlpriv = rtl_priv(hw);\n\t \n\tif (!rtlpriv || !rtlpriv->max_fw_size)\n\t\treturn;\n\trtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\trtl_write_dword(rtlpriv, INTA_MASK, 0);\n\trtl_write_dword(rtlpriv, INTA_MASK + 4, 0);\n\trtlpci->irq_enabled = false;\n}\n\nstatic u8 _rtl92s_set_sysclk(struct ieee80211_hw *hw, u8 data)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 waitcnt = 100;\n\tbool result = false;\n\tu8 tmp;\n\n\trtl_write_byte(rtlpriv, SYS_CLKR + 1, data);\n\n\t \n\tudelay(400);\n\n\t \n\ttmp = rtl_read_byte(rtlpriv, SYS_CLKR + 1);\n\tresult = ((tmp & BIT(7)) == (data & BIT(7)));\n\n\tif (!(data & (BIT(6) | BIT(7)))) {\n\t\twaitcnt = 100;\n\t\ttmp = 0;\n\n\t\twhile (1) {\n\t\t\twaitcnt--;\n\t\t\ttmp = rtl_read_byte(rtlpriv, SYS_CLKR + 1);\n\n\t\t\tif ((tmp & BIT(6)))\n\t\t\t\tbreak;\n\n\t\t\tpr_err(\"wait for BIT(6) return value %x\\n\", tmp);\n\n\t\t\tif (waitcnt == 0)\n\t\t\t\tbreak;\n\t\t\tudelay(10);\n\t\t}\n\n\t\tif (waitcnt == 0)\n\t\t\tresult = false;\n\t\telse\n\t\t\tresult = true;\n\t}\n\n\treturn result;\n}\n\nstatic void _rtl92s_phy_set_rfhalt(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tu8 u1btmp;\n\n\tif (rtlhal->driver_is_goingto_unload)\n\t\trtl_write_byte(rtlpriv, 0x560, 0x0);\n\n\t \n\tu1btmp = rtl_read_byte(rtlpriv, LDOV12D_CTRL);\n\tu1btmp |= BIT(0);\n\trtl_write_byte(rtlpriv, LDOV12D_CTRL, u1btmp);\n\trtl_write_byte(rtlpriv, SPS1_CTRL, 0x0);\n\trtl_write_byte(rtlpriv, TXPAUSE, 0xFF);\n\trtl_write_word(rtlpriv, CMDR, 0x57FC);\n\tudelay(100);\n\trtl_write_word(rtlpriv, CMDR, 0x77FC);\n\trtl_write_byte(rtlpriv, PHY_CCA, 0x0);\n\tudelay(10);\n\trtl_write_word(rtlpriv, CMDR, 0x37FC);\n\tudelay(10);\n\trtl_write_word(rtlpriv, CMDR, 0x77FC);\n\tudelay(10);\n\trtl_write_word(rtlpriv, CMDR, 0x57FC);\n\trtl_write_word(rtlpriv, CMDR, 0x0000);\n\n\tif (rtlhal->driver_is_goingto_unload) {\n\t\tu1btmp = rtl_read_byte(rtlpriv, (REG_SYS_FUNC_EN + 1));\n\t\tu1btmp &= ~(BIT(0));\n\t\trtl_write_byte(rtlpriv, REG_SYS_FUNC_EN + 1, u1btmp);\n\t}\n\n\tu1btmp = rtl_read_byte(rtlpriv, (SYS_CLKR + 1));\n\n\t \n\tif (u1btmp & BIT(7)) {\n\t\tu1btmp &= ~(BIT(6) | BIT(7));\n\t\tif (!_rtl92s_set_sysclk(hw, u1btmp)) {\n\t\t\tpr_err(\"Switch ctrl path fail\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tif (ppsc->rfoff_reason == RF_CHANGE_BY_IPS  &&\n\t\t!rtlhal->driver_is_goingto_unload) {\n\t\t \n\t\trtl_write_byte(rtlpriv, 0x03, 0xF9);\n\t \n\t} else {\n\t\t \n\t\t \n\t\t \n\t\trtl_write_byte(rtlpriv, 0x03, 0xF9);\n\t}\n\n\trtl_write_byte(rtlpriv, SYS_CLKR + 1, 0x70);\n\trtl_write_byte(rtlpriv, AFE_PLL_CTRL + 1, 0x68);\n\trtl_write_byte(rtlpriv,  AFE_PLL_CTRL, 0x00);\n\trtl_write_byte(rtlpriv, LDOA15_CTRL, 0x34);\n\trtl_write_byte(rtlpriv, AFE_XTAL_CTRL, 0x0E);\n\tRT_SET_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_HALT_NIC);\n\n}\n\nstatic void _rtl92se_gen_refreshledstate(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tenum rtl_led_pin pin0 = rtlpriv->ledctl.sw_led0;\n\n\tif (rtlpci->up_first_time)\n\t\treturn;\n\n\tif (rtlpriv->psc.rfoff_reason == RF_CHANGE_BY_IPS)\n\t\trtl92se_sw_led_on(hw, pin0);\n\telse\n\t\trtl92se_sw_led_off(hw, pin0);\n}\n\n\nstatic void _rtl92se_power_domain_init(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu16 tmpu2b;\n\tu8 tmpu1b;\n\n\trtlpriv->psc.pwrdomain_protect = true;\n\n\ttmpu1b = rtl_read_byte(rtlpriv, (SYS_CLKR + 1));\n\tif (tmpu1b & BIT(7)) {\n\t\ttmpu1b &= ~(BIT(6) | BIT(7));\n\t\tif (!_rtl92s_set_sysclk(hw, tmpu1b)) {\n\t\t\trtlpriv->psc.pwrdomain_protect = false;\n\t\t\treturn;\n\t\t}\n\t}\n\n\trtl_write_byte(rtlpriv, AFE_PLL_CTRL, 0x0);\n\trtl_write_byte(rtlpriv, LDOA15_CTRL, 0x34);\n\n\t \n\ttmpu1b = rtl_read_byte(rtlpriv, REG_SYS_FUNC_EN + 1);\n\n\t \n\tif (rtlpriv->psc.rfoff_reason & (RF_CHANGE_BY_IPS | RF_CHANGE_BY_HW))\n\t\ttmpu1b &= 0xFB;\n\telse\n\t\ttmpu1b &= 0x73;\n\n\trtl_write_byte(rtlpriv, REG_SYS_FUNC_EN + 1, tmpu1b);\n\t \n\tmdelay(1);\n\n\trtl_write_byte(rtlpriv, CMDR, 0);\n\trtl_write_byte(rtlpriv, TCR, 0);\n\n\t \n\ttmpu1b = rtl_read_byte(rtlpriv, 0x562);\n\ttmpu1b |= 0x08;\n\trtl_write_byte(rtlpriv, 0x562, tmpu1b);\n\ttmpu1b &= ~(BIT(3));\n\trtl_write_byte(rtlpriv, 0x562, tmpu1b);\n\n\t \n\ttmpu1b = rtl_read_byte(rtlpriv, AFE_XTAL_CTRL);\n\trtl_write_byte(rtlpriv, AFE_XTAL_CTRL, (tmpu1b | 0x01));\n\t \n\tudelay(1500);\n\ttmpu1b = rtl_read_byte(rtlpriv, AFE_XTAL_CTRL + 1);\n\trtl_write_byte(rtlpriv, AFE_XTAL_CTRL + 1, (tmpu1b & 0xfb));\n\n\t \n\ttmpu1b = rtl_read_byte(rtlpriv, AFE_MISC);\n\trtl_write_byte(rtlpriv, AFE_MISC, (tmpu1b | BIT(0)));\n\tmdelay(1);\n\n\t \n\ttmpu1b = rtl_read_byte(rtlpriv, AFE_MISC);\n\trtl_write_byte(rtlpriv, AFE_MISC, (tmpu1b | 0x02));\n\tmdelay(1);\n\n\t \n\ttmpu1b = rtl_read_byte(rtlpriv, LDOA15_CTRL);\n\trtl_write_byte(rtlpriv, LDOA15_CTRL, (tmpu1b | BIT(0)));\n\n\t \n\ttmpu2b = rtl_read_word(rtlpriv, REG_SYS_ISO_CTRL);\n\trtl_write_word(rtlpriv, REG_SYS_ISO_CTRL, (tmpu2b | BIT(11)));\n\n\n\t \n\ttmpu2b = rtl_read_word(rtlpriv, REG_SYS_FUNC_EN);\n\trtl_write_word(rtlpriv, REG_SYS_FUNC_EN, (tmpu2b | BIT(13)));\n\n\trtl_write_byte(rtlpriv, REG_SYS_ISO_CTRL + 1, 0x68);\n\n\t \n\ttmpu1b = rtl_read_byte(rtlpriv, AFE_PLL_CTRL);\n\trtl_write_byte(rtlpriv, AFE_PLL_CTRL, (tmpu1b | BIT(0) | BIT(4)));\n\t \n\ttmpu1b = rtl_read_byte(rtlpriv, AFE_PLL_CTRL + 1);\n\trtl_write_byte(rtlpriv, AFE_PLL_CTRL + 1, (tmpu1b | BIT(0)));\n\tmdelay(1);\n\n\t \n\trtl_write_byte(rtlpriv, REG_SYS_ISO_CTRL, 0xA6);\n\n\t \n\ttmpu2b = rtl_read_word(rtlpriv, SYS_CLKR);\n\trtl_write_word(rtlpriv, SYS_CLKR, (tmpu2b | BIT(12) | BIT(11)));\n\n\t \n\ttmpu2b = rtl_read_word(rtlpriv, REG_SYS_FUNC_EN);\n\trtl_write_word(rtlpriv, REG_SYS_FUNC_EN, (tmpu2b | BIT(11)));\n\t \n\trtl_write_word(rtlpriv, REG_SYS_FUNC_EN, (tmpu2b | BIT(11) | BIT(15)));\n\n\t \n\ttmpu2b = rtl_read_word(rtlpriv, SYS_CLKR);\n\trtl_write_word(rtlpriv, SYS_CLKR, (tmpu2b & (~BIT(2))));\n\n\ttmpu1b = rtl_read_byte(rtlpriv, (SYS_CLKR + 1));\n\ttmpu1b = ((tmpu1b | BIT(7)) & (~BIT(6)));\n\tif (!_rtl92s_set_sysclk(hw, tmpu1b)) {\n\t\trtlpriv->psc.pwrdomain_protect = false;\n\t\treturn;\n\t}\n\n\trtl_write_word(rtlpriv, CMDR, 0x37FC);\n\n\t \n\t_rtl92se_gen_refreshledstate(hw);\n\n\trtlpriv->psc.pwrdomain_protect = false;\n}\n\nvoid rtl92se_card_disable(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tenum nl80211_iftype opmode;\n\tu8 wait = 30;\n\n\trtlpriv->intf_ops->enable_aspm(hw);\n\n\tif (rtlpci->driver_is_goingto_unload ||\n\t\tppsc->rfoff_reason > RF_CHANGE_BY_PS)\n\t\trtlpriv->cfg->ops->led_control(hw, LED_CTL_POWER_OFF);\n\n\t \n\trtl8192se_gpiobit3_cfg_inputmode(hw);\n\n\t \n\twhile (wait-- >= 10 && rtlpriv->psc.pwrdomain_protect) {\n\t\tif (rtlpriv->psc.pwrdomain_protect)\n\t\t\tmdelay(20);\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tmac->link_state = MAC80211_NOLINK;\n\topmode = NL80211_IFTYPE_UNSPECIFIED;\n\t_rtl92se_set_media_status(hw, opmode);\n\n\t_rtl92s_phy_set_rfhalt(hw);\n\tudelay(100);\n}\n\nvoid rtl92se_interrupt_recognized(struct ieee80211_hw *hw,\n\t\t\t\t  struct rtl_int *intvec)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\n\tintvec->inta = rtl_read_dword(rtlpriv, ISR) & rtlpci->irq_mask[0];\n\trtl_write_dword(rtlpriv, ISR, intvec->inta);\n\n\tintvec->intb = rtl_read_dword(rtlpriv, ISR + 4) & rtlpci->irq_mask[1];\n\trtl_write_dword(rtlpriv, ISR + 4, intvec->intb);\n}\n\nvoid rtl92se_set_beacon_related_registers(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tu16 atim_window = 2;\n\n\t \n\trtl_write_word(rtlpriv, ATIMWND, atim_window);\n\n\t \n\trtl_write_word(rtlpriv, BCN_INTERVAL, mac->beacon_interval);\n\n\t \n\trtl_write_word(rtlpriv, BCN_DRV_EARLY_INT, 10 << 4);\n\n\t \n\trtl_write_word(rtlpriv, BCN_DMATIME, 256);\n\n\t \n\trtl_write_byte(rtlpriv, BCN_ERR_THRESH, 100);\n\n\t \n\trtl92s_phy_set_beacon_hwreg(hw, mac->beacon_interval);\n}\n\nvoid rtl92se_set_beacon_interval(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tu16 bcn_interval = mac->beacon_interval;\n\n\t \n\trtl_write_word(rtlpriv, BCN_INTERVAL, bcn_interval);\n\t \n\trtl92s_phy_set_beacon_hwreg(hw, bcn_interval);\n}\n\nvoid rtl92se_update_interrupt_mask(struct ieee80211_hw *hw,\n\t\tu32 add_msr, u32 rm_msr)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\n\trtl_dbg(rtlpriv, COMP_INTR, DBG_LOUD, \"add_msr:%x, rm_msr:%x\\n\",\n\t\tadd_msr, rm_msr);\n\n\tif (add_msr)\n\t\trtlpci->irq_mask[0] |= add_msr;\n\n\tif (rm_msr)\n\t\trtlpci->irq_mask[0] &= (~rm_msr);\n\n\trtl92se_disable_interrupt(hw);\n\trtl92se_enable_interrupt(hw);\n}\n\nstatic void _rtl8192se_get_ic_inferiority(struct ieee80211_hw *hw)\n{\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tu8 efuse_id;\n\n\trtlhal->ic_class = IC_INFERIORITY_A;\n\n\t \n\tif ((rtlefuse->epromtype == EEPROM_BOOT_EFUSE) &&\n\t\t!rtlefuse->autoload_failflag) {\n\t\tefuse_id = efuse_read_1byte(hw, EFUSE_IC_ID_OFFSET);\n\n\t\tif (efuse_id == 0xfe)\n\t\t\trtlhal->ic_class = IC_INFERIORITY_B;\n\t}\n}\n\nstatic void _rtl92se_read_adapter_info(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct device *dev = &rtl_pcipriv(hw)->dev.pdev->dev;\n\tu16 i, usvalue;\n\tu16\teeprom_id;\n\tu8 tempval;\n\tu8 hwinfo[HWSET_MAX_SIZE_92S];\n\tu8 rf_path, index;\n\n\tswitch (rtlefuse->epromtype) {\n\tcase EEPROM_BOOT_EFUSE:\n\t\trtl_efuse_shadow_map_update(hw);\n\t\tbreak;\n\n\tcase EEPROM_93C46:\n\t\tpr_err(\"RTL819X Not boot from eeprom, check it !!\\n\");\n\t\treturn;\n\n\tdefault:\n\t\tdev_warn(dev, \"no efuse data\\n\");\n\t\treturn;\n\t}\n\n\tmemcpy(hwinfo, &rtlefuse->efuse_map[EFUSE_INIT_MAP][0],\n\t       HWSET_MAX_SIZE_92S);\n\n\tRT_PRINT_DATA(rtlpriv, COMP_INIT, DBG_DMESG, \"MAP\",\n\t\t      hwinfo, HWSET_MAX_SIZE_92S);\n\n\teeprom_id = *((u16 *)&hwinfo[0]);\n\tif (eeprom_id != RTL8190_EEPROM_ID) {\n\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_WARNING,\n\t\t\t\"EEPROM ID(%#x) is invalid!!\\n\", eeprom_id);\n\t\trtlefuse->autoload_failflag = true;\n\t} else {\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD, \"Autoload OK\\n\");\n\t\trtlefuse->autoload_failflag = false;\n\t}\n\n\tif (rtlefuse->autoload_failflag)\n\t\treturn;\n\n\t_rtl8192se_get_ic_inferiority(hw);\n\n\t \n\t \n\trtlefuse->eeprom_vid = *(u16 *)&hwinfo[EEPROM_VID];\n\trtlefuse->eeprom_did = *(u16 *)&hwinfo[EEPROM_DID];\n\trtlefuse->eeprom_svid = *(u16 *)&hwinfo[EEPROM_SVID];\n\trtlefuse->eeprom_smid = *(u16 *)&hwinfo[EEPROM_SMID];\n\trtlefuse->eeprom_version = *(u16 *)&hwinfo[EEPROM_VERSION];\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\"EEPROMId = 0x%4x\\n\", eeprom_id);\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\"EEPROM VID = 0x%4x\\n\", rtlefuse->eeprom_vid);\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\"EEPROM DID = 0x%4x\\n\", rtlefuse->eeprom_did);\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\"EEPROM SVID = 0x%4x\\n\", rtlefuse->eeprom_svid);\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\"EEPROM SMID = 0x%4x\\n\", rtlefuse->eeprom_smid);\n\n\tfor (i = 0; i < 6; i += 2) {\n\t\tusvalue = *(u16 *)&hwinfo[EEPROM_MAC_ADDR + i];\n\t\t*((u16 *) (&rtlefuse->dev_addr[i])) = usvalue;\n\t}\n\n\tfor (i = 0; i < 6; i++)\n\t\trtl_write_byte(rtlpriv, MACIDR0 + i, rtlefuse->dev_addr[i]);\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG, \"%pM\\n\", rtlefuse->dev_addr);\n\n\t \n\t \n\t \n\tfor (rf_path = 0; rf_path < 2; rf_path++) {\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\t \n\t\t\trtlefuse->eeprom_chnlarea_txpwr_cck[rf_path][i] =\n\t\t\thwinfo[EEPROM_TXPOWERBASE + rf_path * 3 + i];\n\n\t\t\t \n\t\t\trtlefuse->eeprom_chnlarea_txpwr_ht40_1s[rf_path][i] =\n\t\t\thwinfo[EEPROM_TXPOWERBASE + 6 + rf_path * 3 + i];\n\n\t\t\t \n\t\t\trtlefuse->eprom_chnl_txpwr_ht40_2sdf[rf_path][i]\n\t\t\t\t = hwinfo[EEPROM_TXPOWERBASE + 12 +\n\t\t\t\t   rf_path * 3 + i];\n\t\t}\n\t}\n\n\tfor (rf_path = 0; rf_path < 2; rf_path++)\n\t\tfor (i = 0; i < 3; i++)\n\t\t\tRTPRINT(rtlpriv, FINIT, INIT_EEPROM,\n\t\t\t\t\"RF(%d) EEPROM CCK Area(%d) = 0x%x\\n\",\n\t\t\t\trf_path, i,\n\t\t\t\trtlefuse->eeprom_chnlarea_txpwr_cck\n\t\t\t\t[rf_path][i]);\n\tfor (rf_path = 0; rf_path < 2; rf_path++)\n\t\tfor (i = 0; i < 3; i++)\n\t\t\tRTPRINT(rtlpriv, FINIT, INIT_EEPROM,\n\t\t\t\t\"RF(%d) EEPROM HT40 1S Area(%d) = 0x%x\\n\",\n\t\t\t\trf_path, i,\n\t\t\t\trtlefuse->eeprom_chnlarea_txpwr_ht40_1s\n\t\t\t\t[rf_path][i]);\n\tfor (rf_path = 0; rf_path < 2; rf_path++)\n\t\tfor (i = 0; i < 3; i++)\n\t\t\tRTPRINT(rtlpriv, FINIT, INIT_EEPROM,\n\t\t\t\t\"RF(%d) EEPROM HT40 2S Diff Area(%d) = 0x%x\\n\",\n\t\t\t\trf_path, i,\n\t\t\t\trtlefuse->eprom_chnl_txpwr_ht40_2sdf\n\t\t\t\t[rf_path][i]);\n\n\tfor (rf_path = 0; rf_path < 2; rf_path++) {\n\n\t\t \n\t\tfor (i = 0; i < 14; i++)\t{\n\t\t\t \n\t\t\tif (i < 3)\n\t\t\t\tindex = 0;\n\t\t\t \n\t\t\telse if (i < 8)\n\t\t\t\tindex = 1;\n\t\t\t \n\t\t\telse\n\t\t\t\tindex = 2;\n\n\t\t\t \n\t\t\trtlefuse->txpwrlevel_cck[rf_path][i]  =\n\t\t\t\trtlefuse->eeprom_chnlarea_txpwr_cck\n\t\t\t\t\t\t\t[rf_path][index];\n\t\t\trtlefuse->txpwrlevel_ht40_1s[rf_path][i]  =\n\t\t\t\trtlefuse->eeprom_chnlarea_txpwr_ht40_1s\n\t\t\t\t\t\t\t[rf_path][index];\n\t\t\trtlefuse->txpwrlevel_ht40_2s[rf_path][i]  =\n\t\t\t\trtlefuse->eprom_chnl_txpwr_ht40_2sdf\n\t\t\t\t\t\t\t[rf_path][index];\n\t\t}\n\n\t\tfor (i = 0; i < 14; i++) {\n\t\t\tRTPRINT(rtlpriv, FINIT, INIT_TXPOWER,\n\t\t\t\t\"RF(%d)-Ch(%d) [CCK / HT40_1S / HT40_2S] = [0x%x / 0x%x / 0x%x]\\n\",\n\t\t\t\trf_path, i,\n\t\t\t\trtlefuse->txpwrlevel_cck[rf_path][i],\n\t\t\t\trtlefuse->txpwrlevel_ht40_1s[rf_path][i],\n\t\t\t\trtlefuse->txpwrlevel_ht40_2s[rf_path][i]);\n\t\t}\n\t}\n\n\tfor (rf_path = 0; rf_path < 2; rf_path++) {\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\t \n\t\t\trtlefuse->eeprom_pwrgroup[rf_path][i] =\n\t\t\t\thwinfo[EEPROM_TXPWRGROUP + rf_path * 3 + i];\n\t\t}\n\t}\n\n\tfor (rf_path = 0; rf_path < 2; rf_path++) {\n\t\t \n\t\tfor (i = 0; i < 14; i++) {\n\t\t\t \n\t\t\tif (i < 3)\n\t\t\t\tindex = 0;\n\t\t\t \n\t\t\telse if (i < 8)\n\t\t\t\tindex = 1;\n\t\t\t \n\t\t\telse\n\t\t\t\tindex = 2;\n\n\t\t\trtlefuse->pwrgroup_ht20[rf_path][i] =\n\t\t\t\t(rtlefuse->eeprom_pwrgroup[rf_path][index] &\n\t\t\t\t0xf);\n\t\t\trtlefuse->pwrgroup_ht40[rf_path][i] =\n\t\t\t\t((rtlefuse->eeprom_pwrgroup[rf_path][index] &\n\t\t\t\t0xf0) >> 4);\n\n\t\t\tRTPRINT(rtlpriv, FINIT, INIT_TXPOWER,\n\t\t\t\t\"RF-%d pwrgroup_ht20[%d] = 0x%x\\n\",\n\t\t\t\trf_path, i,\n\t\t\t\trtlefuse->pwrgroup_ht20[rf_path][i]);\n\t\t\tRTPRINT(rtlpriv, FINIT, INIT_TXPOWER,\n\t\t\t\t\"RF-%d pwrgroup_ht40[%d] = 0x%x\\n\",\n\t\t\t\trf_path, i,\n\t\t\t\trtlefuse->pwrgroup_ht40[rf_path][i]);\n\t\t\t}\n\t}\n\n\tfor (i = 0; i < 14; i++) {\n\t\t \n\t\t \n\t\tif (i < 3)\n\t\t\tindex = 0;\n\t\t \n\t\telse if (i < 8)\n\t\t\tindex = 1;\n\t\t \n\t\telse\n\t\t\tindex = 2;\n\n\t\ttempval = hwinfo[EEPROM_TX_PWR_HT20_DIFF + index] & 0xff;\n\t\trtlefuse->txpwr_ht20diff[RF90_PATH_A][i] = (tempval & 0xF);\n\t\trtlefuse->txpwr_ht20diff[RF90_PATH_B][i] =\n\t\t\t\t\t\t ((tempval >> 4) & 0xF);\n\n\t\t \n\t\t \n\t\tif (i < 3)\n\t\t\tindex = 0;\n\t\t \n\t\telse if (i < 8)\n\t\t\tindex = 0x11;\n\t\t \n\t\telse\n\t\t\tindex = 1;\n\n\t\ttempval = hwinfo[EEPROM_TX_PWR_OFDM_DIFF + index] & 0xff;\n\t\trtlefuse->txpwr_legacyhtdiff[RF90_PATH_A][i] =\n\t\t\t\t (tempval & 0xF);\n\t\trtlefuse->txpwr_legacyhtdiff[RF90_PATH_B][i] =\n\t\t\t\t ((tempval >> 4) & 0xF);\n\n\t\ttempval = hwinfo[TX_PWR_SAFETY_CHK];\n\t\trtlefuse->txpwr_safetyflag = (tempval & 0x01);\n\t}\n\n\trtlefuse->eeprom_regulatory = 0;\n\tif (rtlefuse->eeprom_version >= 2) {\n\t\t \n\t\tif (rtlefuse->eeprom_version >= 4)\n\t\t\trtlefuse->eeprom_regulatory =\n\t\t\t\t (hwinfo[EEPROM_REGULATORY] & 0x7);\n\t\telse  \n\t\t\trtlefuse->eeprom_regulatory =\n\t\t\t\t (hwinfo[EEPROM_REGULATORY] & 0x1);\n\t}\n\tRTPRINT(rtlpriv, FINIT, INIT_TXPOWER,\n\t\t\"eeprom_regulatory = 0x%x\\n\", rtlefuse->eeprom_regulatory);\n\n\tfor (i = 0; i < 14; i++)\n\t\tRTPRINT(rtlpriv, FINIT, INIT_TXPOWER,\n\t\t\t\"RF-A Ht20 to HT40 Diff[%d] = 0x%x\\n\",\n\t\t\ti, rtlefuse->txpwr_ht20diff[RF90_PATH_A][i]);\n\tfor (i = 0; i < 14; i++)\n\t\tRTPRINT(rtlpriv, FINIT, INIT_TXPOWER,\n\t\t\t\"RF-A Legacy to Ht40 Diff[%d] = 0x%x\\n\",\n\t\t\ti, rtlefuse->txpwr_legacyhtdiff[RF90_PATH_A][i]);\n\tfor (i = 0; i < 14; i++)\n\t\tRTPRINT(rtlpriv, FINIT, INIT_TXPOWER,\n\t\t\t\"RF-B Ht20 to HT40 Diff[%d] = 0x%x\\n\",\n\t\t\ti, rtlefuse->txpwr_ht20diff[RF90_PATH_B][i]);\n\tfor (i = 0; i < 14; i++)\n\t\tRTPRINT(rtlpriv, FINIT, INIT_TXPOWER,\n\t\t\t\"RF-B Legacy to HT40 Diff[%d] = 0x%x\\n\",\n\t\t\ti, rtlefuse->txpwr_legacyhtdiff[RF90_PATH_B][i]);\n\n\tRTPRINT(rtlpriv, FINIT, INIT_TXPOWER,\n\t\t\"TxPwrSafetyFlag = %d\\n\", rtlefuse->txpwr_safetyflag);\n\n\t \n\ttempval = hwinfo[EEPROM_RFIND_POWERDIFF] & 0xff;\n\trtlefuse->eeprom_txpowerdiff = tempval;\n\trtlefuse->legacy_ht_txpowerdiff =\n\t\trtlefuse->txpwr_legacyhtdiff[RF90_PATH_A][0];\n\n\tRTPRINT(rtlpriv, FINIT, INIT_TXPOWER,\n\t\t\"TxPowerDiff = %#x\\n\", rtlefuse->eeprom_txpowerdiff);\n\n\t \n\tusvalue = *(u16 *)&hwinfo[EEPROM_TSSI_A];\n\trtlefuse->eeprom_tssi[RF90_PATH_A] = (u8)((usvalue & 0xff00) >> 8);\n\tusvalue = hwinfo[EEPROM_TSSI_B];\n\trtlefuse->eeprom_tssi[RF90_PATH_B] = (u8)(usvalue & 0xff);\n\n\tRTPRINT(rtlpriv, FINIT, INIT_TXPOWER, \"TSSI_A = 0x%x, TSSI_B = 0x%x\\n\",\n\t\trtlefuse->eeprom_tssi[RF90_PATH_A],\n\t\trtlefuse->eeprom_tssi[RF90_PATH_B]);\n\n\t \n\t \n\ttempval = hwinfo[EEPROM_THERMALMETER];\n\trtlefuse->eeprom_thermalmeter = tempval;\n\tRTPRINT(rtlpriv, FINIT, INIT_TXPOWER,\n\t\t\"thermalmeter = 0x%x\\n\", rtlefuse->eeprom_thermalmeter);\n\n\t \n\trtlefuse->thermalmeter[0] = (rtlefuse->eeprom_thermalmeter & 0x1f);\n\trtlefuse->tssi_13dbm = rtlefuse->eeprom_thermalmeter * 100;\n\n\t \n\ttempval = hwinfo[EEPROM_CRYSTALCAP] >> 4;\n\trtlefuse->eeprom_crystalcap = tempval;\n\t \n\trtlefuse->crystalcap = rtlefuse->eeprom_crystalcap;\n\n\t \n\t \n\trtlefuse->eeprom_channelplan = hwinfo[EEPROM_CHANNELPLAN];\n\trtlefuse->txpwr_fromeprom = true;\n\tRTPRINT(rtlpriv, FINIT, INIT_TXPOWER,\n\t\t\"EEPROM ChannelPlan = 0x%4x\\n\", rtlefuse->eeprom_channelplan);\n\n\t \n\ttempval = hwinfo[EEPROM_BOARDTYPE];\n\t \n\tif (tempval == 0)\n\t\trtlphy->rf_type = RF_2T2R;\n\telse if (tempval == 1)\n\t\trtlphy->rf_type = RF_1T2R;\n\telse if (tempval == 2)\n\t\trtlphy->rf_type = RF_1T2R;\n\telse if (tempval == 3)\n\t\trtlphy->rf_type = RF_1T1R;\n\n\t \n\trtlefuse->b1x1_recvcombine = false;\n\tif (rtlphy->rf_type == RF_1T2R) {\n\t\ttempval = rtl_read_byte(rtlpriv, 0x07);\n\t\tif (!(tempval & BIT(0))) {\n\t\t\trtlefuse->b1x1_recvcombine = true;\n\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\t\"RF_TYPE=1T2R but only 1SS\\n\");\n\t\t}\n\t}\n\trtlefuse->b1ss_support = rtlefuse->b1x1_recvcombine;\n\trtlefuse->eeprom_oemid = *&hwinfo[EEPROM_CUSTOMID];\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD, \"EEPROM Customer ID: 0x%2x\\n\",\n\t\trtlefuse->eeprom_oemid);\n\n\t \n\trtlefuse->channel_plan = COUNTRY_CODE_WORLD_WIDE_13;\n}\n\nvoid rtl92se_read_eeprom_info(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tu8 tmp_u1b = 0;\n\n\ttmp_u1b = rtl_read_byte(rtlpriv, EPROM_CMD);\n\n\tif (tmp_u1b & BIT(4)) {\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG, \"Boot from EEPROM\\n\");\n\t\trtlefuse->epromtype = EEPROM_93C46;\n\t} else {\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG, \"Boot from EFUSE\\n\");\n\t\trtlefuse->epromtype = EEPROM_BOOT_EFUSE;\n\t}\n\n\tif (tmp_u1b & BIT(5)) {\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD, \"Autoload OK\\n\");\n\t\trtlefuse->autoload_failflag = false;\n\t\t_rtl92se_read_adapter_info(hw);\n\t} else {\n\t\tpr_err(\"Autoload ERR!!\\n\");\n\t\trtlefuse->autoload_failflag = true;\n\t}\n}\n\nstatic void rtl92se_update_hal_rate_table(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct ieee80211_sta *sta)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tu32 ratr_value;\n\tu8 ratr_index = 0;\n\tu8 nmode = mac->ht_enable;\n\tu8 mimo_ps = IEEE80211_SMPS_OFF;\n\tu16 shortgi_rate = 0;\n\tu32 tmp_ratr_value = 0;\n\tu8 curtxbw_40mhz = mac->bw_40;\n\tu8 curshortgi_40mhz = (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_SGI_40) ?\n\t\t\t\t1 : 0;\n\tu8 curshortgi_20mhz = (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_SGI_20) ?\n\t\t\t\t1 : 0;\n\tenum wireless_mode wirelessmode = mac->mode;\n\n\tif (rtlhal->current_bandtype == BAND_ON_5G)\n\t\tratr_value = sta->deflink.supp_rates[1] << 4;\n\telse\n\t\tratr_value = sta->deflink.supp_rates[0];\n\tif (mac->opmode == NL80211_IFTYPE_ADHOC)\n\t\tratr_value = 0xfff;\n\tratr_value |= (sta->deflink.ht_cap.mcs.rx_mask[1] << 20 |\n\t\t\tsta->deflink.ht_cap.mcs.rx_mask[0] << 12);\n\tswitch (wirelessmode) {\n\tcase WIRELESS_MODE_B:\n\t\tratr_value &= 0x0000000D;\n\t\tbreak;\n\tcase WIRELESS_MODE_G:\n\t\tratr_value &= 0x00000FF5;\n\t\tbreak;\n\tcase WIRELESS_MODE_N_24G:\n\tcase WIRELESS_MODE_N_5G:\n\t\tnmode = 1;\n\t\tif (mimo_ps == IEEE80211_SMPS_STATIC) {\n\t\t\tratr_value &= 0x0007F005;\n\t\t} else {\n\t\t\tu32 ratr_mask;\n\n\t\t\tif (get_rf_type(rtlphy) == RF_1T2R ||\n\t\t\t    get_rf_type(rtlphy) == RF_1T1R) {\n\t\t\t\tif (curtxbw_40mhz)\n\t\t\t\t\tratr_mask = 0x000ff015;\n\t\t\t\telse\n\t\t\t\t\tratr_mask = 0x000ff005;\n\t\t\t} else {\n\t\t\t\tif (curtxbw_40mhz)\n\t\t\t\t\tratr_mask = 0x0f0ff015;\n\t\t\t\telse\n\t\t\t\t\tratr_mask = 0x0f0ff005;\n\t\t\t}\n\n\t\t\tratr_value &= ratr_mask;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif (rtlphy->rf_type == RF_1T2R)\n\t\t\tratr_value &= 0x000ff0ff;\n\t\telse\n\t\t\tratr_value &= 0x0f0ff0ff;\n\n\t\tbreak;\n\t}\n\n\tif (rtlpriv->rtlhal.version >= VERSION_8192S_BCUT)\n\t\tratr_value &= 0x0FFFFFFF;\n\telse if (rtlpriv->rtlhal.version == VERSION_8192S_ACUT)\n\t\tratr_value &= 0x0FFFFFF0;\n\n\tif (nmode && ((curtxbw_40mhz &&\n\t\t\t curshortgi_40mhz) || (!curtxbw_40mhz &&\n\t\t\t\t\t\t curshortgi_20mhz))) {\n\n\t\tratr_value |= 0x10000000;\n\t\ttmp_ratr_value = (ratr_value >> 12);\n\n\t\tfor (shortgi_rate = 15; shortgi_rate > 0; shortgi_rate--) {\n\t\t\tif ((1 << shortgi_rate) & tmp_ratr_value)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tshortgi_rate = (shortgi_rate << 12) | (shortgi_rate << 8) |\n\t\t    (shortgi_rate << 4) | (shortgi_rate);\n\n\t\trtl_write_byte(rtlpriv, SG_RATE, shortgi_rate);\n\t}\n\n\trtl_write_dword(rtlpriv, ARFR0 + ratr_index * 4, ratr_value);\n\tif (ratr_value & 0xfffff000)\n\t\trtl92s_phy_set_fw_cmd(hw, FW_CMD_RA_REFRESH_N);\n\telse\n\t\trtl92s_phy_set_fw_cmd(hw, FW_CMD_RA_REFRESH_BG);\n\n\trtl_dbg(rtlpriv, COMP_RATR, DBG_DMESG, \"%x\\n\",\n\t\trtl_read_dword(rtlpriv, ARFR0));\n}\n\nstatic void rtl92se_update_hal_rate_mask(struct ieee80211_hw *hw,\n\t\t\t\t\t struct ieee80211_sta *sta,\n\t\t\t\t\t u8 rssi_level, bool update_bw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_sta_info *sta_entry = NULL;\n\tu32 ratr_bitmap;\n\tu8 ratr_index = 0;\n\tu8 curtxbw_40mhz = (sta->deflink.bandwidth >= IEEE80211_STA_RX_BW_40) ? 1 : 0;\n\tu8 curshortgi_40mhz = (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_SGI_40) ?\n\t\t\t\t1 : 0;\n\tu8 curshortgi_20mhz = (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_SGI_20) ?\n\t\t\t\t1 : 0;\n\tenum wireless_mode wirelessmode = 0;\n\tbool shortgi = false;\n\tu32 ratr_value = 0;\n\tu8 shortgi_rate = 0;\n\tu32 mask = 0;\n\tu32 band = 0;\n\tbool bmulticast = false;\n\tu8 macid = 0;\n\tu8 mimo_ps = IEEE80211_SMPS_OFF;\n\n\tsta_entry = (struct rtl_sta_info *) sta->drv_priv;\n\twirelessmode = sta_entry->wireless_mode;\n\tif (mac->opmode == NL80211_IFTYPE_STATION)\n\t\tcurtxbw_40mhz = mac->bw_40;\n\telse if (mac->opmode == NL80211_IFTYPE_AP ||\n\t\tmac->opmode == NL80211_IFTYPE_ADHOC)\n\t\tmacid = sta->aid + 1;\n\n\tif (rtlhal->current_bandtype == BAND_ON_5G)\n\t\tratr_bitmap = sta->deflink.supp_rates[1] << 4;\n\telse\n\t\tratr_bitmap = sta->deflink.supp_rates[0];\n\tif (mac->opmode == NL80211_IFTYPE_ADHOC)\n\t\tratr_bitmap = 0xfff;\n\tratr_bitmap |= (sta->deflink.ht_cap.mcs.rx_mask[1] << 20 |\n\t\t\tsta->deflink.ht_cap.mcs.rx_mask[0] << 12);\n\tswitch (wirelessmode) {\n\tcase WIRELESS_MODE_B:\n\t\tband |= WIRELESS_11B;\n\t\tratr_index = RATR_INX_WIRELESS_B;\n\t\tif (ratr_bitmap & 0x0000000c)\n\t\t\tratr_bitmap &= 0x0000000d;\n\t\telse\n\t\t\tratr_bitmap &= 0x0000000f;\n\t\tbreak;\n\tcase WIRELESS_MODE_G:\n\t\tband |= (WIRELESS_11G | WIRELESS_11B);\n\t\tratr_index = RATR_INX_WIRELESS_GB;\n\n\t\tif (rssi_level == 1)\n\t\t\tratr_bitmap &= 0x00000f00;\n\t\telse if (rssi_level == 2)\n\t\t\tratr_bitmap &= 0x00000ff0;\n\t\telse\n\t\t\tratr_bitmap &= 0x00000ff5;\n\t\tbreak;\n\tcase WIRELESS_MODE_A:\n\t\tband |= WIRELESS_11A;\n\t\tratr_index = RATR_INX_WIRELESS_A;\n\t\tratr_bitmap &= 0x00000ff0;\n\t\tbreak;\n\tcase WIRELESS_MODE_N_24G:\n\tcase WIRELESS_MODE_N_5G:\n\t\tband |= (WIRELESS_11N | WIRELESS_11G | WIRELESS_11B);\n\t\tratr_index = RATR_INX_WIRELESS_NGB;\n\n\t\tif (mimo_ps == IEEE80211_SMPS_STATIC) {\n\t\t\tif (rssi_level == 1)\n\t\t\t\tratr_bitmap &= 0x00070000;\n\t\t\telse if (rssi_level == 2)\n\t\t\t\tratr_bitmap &= 0x0007f000;\n\t\t\telse\n\t\t\t\tratr_bitmap &= 0x0007f005;\n\t\t} else {\n\t\t\tif (rtlphy->rf_type == RF_1T2R ||\n\t\t\t\trtlphy->rf_type == RF_1T1R) {\n\t\t\t\tif (rssi_level == 1) {\n\t\t\t\t\t\tratr_bitmap &= 0x000f0000;\n\t\t\t\t} else if (rssi_level == 3) {\n\t\t\t\t\tratr_bitmap &= 0x000fc000;\n\t\t\t\t} else if (rssi_level == 5) {\n\t\t\t\t\t\tratr_bitmap &= 0x000ff000;\n\t\t\t\t} else {\n\t\t\t\t\tif (curtxbw_40mhz)\n\t\t\t\t\t\tratr_bitmap &= 0x000ff015;\n\t\t\t\t\telse\n\t\t\t\t\t\tratr_bitmap &= 0x000ff005;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (rssi_level == 1) {\n\t\t\t\t\tratr_bitmap &= 0x0f8f0000;\n\t\t\t\t} else if (rssi_level == 3) {\n\t\t\t\t\tratr_bitmap &= 0x0f8fc000;\n\t\t\t\t} else if (rssi_level == 5) {\n\t\t\t\t\tratr_bitmap &= 0x0f8ff000;\n\t\t\t\t} else {\n\t\t\t\t\tif (curtxbw_40mhz)\n\t\t\t\t\t\tratr_bitmap &= 0x0f8ff015;\n\t\t\t\t\telse\n\t\t\t\t\t\tratr_bitmap &= 0x0f8ff005;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ((curtxbw_40mhz && curshortgi_40mhz) ||\n\t\t    (!curtxbw_40mhz && curshortgi_20mhz)) {\n\t\t\tif (macid == 0)\n\t\t\t\tshortgi = true;\n\t\t\telse if (macid == 1)\n\t\t\t\tshortgi = false;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tband |= (WIRELESS_11N | WIRELESS_11G | WIRELESS_11B);\n\t\tratr_index = RATR_INX_WIRELESS_NGB;\n\n\t\tif (rtlphy->rf_type == RF_1T2R)\n\t\t\tratr_bitmap &= 0x000ff0ff;\n\t\telse\n\t\t\tratr_bitmap &= 0x0f8ff0ff;\n\t\tbreak;\n\t}\n\tsta_entry->ratr_index = ratr_index;\n\n\tif (rtlpriv->rtlhal.version >= VERSION_8192S_BCUT)\n\t\tratr_bitmap &= 0x0FFFFFFF;\n\telse if (rtlpriv->rtlhal.version == VERSION_8192S_ACUT)\n\t\tratr_bitmap &= 0x0FFFFFF0;\n\n\tif (shortgi) {\n\t\tratr_bitmap |= 0x10000000;\n\t\t \n\t\tratr_value = (ratr_bitmap >> 12);\n\t\tfor (shortgi_rate = 15; shortgi_rate > 0; shortgi_rate--) {\n\t\t\tif ((1 << shortgi_rate) & ratr_value)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tshortgi_rate = (shortgi_rate << 12) | (shortgi_rate << 8) |\n\t\t\t(shortgi_rate << 4) | (shortgi_rate);\n\t\trtl_write_byte(rtlpriv, SG_RATE, shortgi_rate);\n\t}\n\n\tmask |= (bmulticast ? 1 : 0) << 9 | (macid & 0x1f) << 4 | (band & 0xf);\n\n\trtl_dbg(rtlpriv, COMP_RATR, DBG_TRACE, \"mask = %x, bitmap = %x\\n\",\n\t\tmask, ratr_bitmap);\n\trtl_write_dword(rtlpriv, 0x2c4, ratr_bitmap);\n\trtl_write_dword(rtlpriv, WFM5, (FW_RA_UPDATE_MASK | (mask << 8)));\n\n\tif (macid != 0)\n\t\tsta_entry->ratr_index = ratr_index;\n}\n\nvoid rtl92se_update_hal_rate_tbl(struct ieee80211_hw *hw,\n\t\tstruct ieee80211_sta *sta, u8 rssi_level, bool update_bw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\tif (rtlpriv->dm.useramask)\n\t\trtl92se_update_hal_rate_mask(hw, sta, rssi_level, update_bw);\n\telse\n\t\trtl92se_update_hal_rate_table(hw, sta);\n}\n\nvoid rtl92se_update_channel_access_setting(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tu16 sifs_timer;\n\n\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_SLOT_TIME,\n\t\t\t\t      &mac->slot_time);\n\tsifs_timer = 0x0e0e;\n\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_SIFS, (u8 *)&sifs_timer);\n\n}\n\n \nbool rtl92se_gpio_radio_on_off_checking(struct ieee80211_hw *hw, u8 *valid)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tenum rf_pwrstate rfpwr_toset  ;\n\tunsigned long flag = 0;\n\tbool actuallyset = false;\n\tbool turnonbypowerdomain = false;\n\n\t \n\tif (rtlpci->up_first_time || rtlpci->being_init_adapter)\n\t\treturn false;\n\n\tif (ppsc->swrf_processing)\n\t\treturn false;\n\n\tspin_lock_irqsave(&rtlpriv->locks.rf_ps_lock, flag);\n\tif (ppsc->rfchange_inprogress) {\n\t\tspin_unlock_irqrestore(&rtlpriv->locks.rf_ps_lock, flag);\n\t\treturn false;\n\t} else {\n\t\tppsc->rfchange_inprogress = true;\n\t\tspin_unlock_irqrestore(&rtlpriv->locks.rf_ps_lock, flag);\n\t}\n\n\t \n\n\t \n\tif (RT_IN_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_HALT_NIC)) {\n\t\t_rtl92se_power_domain_init(hw);\n\t\tturnonbypowerdomain = true;\n\t}\n\n\trfpwr_toset = _rtl92se_rf_onoff_detect(hw);\n\n\tif ((ppsc->hwradiooff) && (rfpwr_toset == ERFON)) {\n\t\trtl_dbg(rtlpriv, COMP_RF, DBG_DMESG,\n\t\t\t\"RFKILL-HW Radio ON, RF ON\\n\");\n\n\t\trfpwr_toset = ERFON;\n\t\tppsc->hwradiooff = false;\n\t\tactuallyset = true;\n\t} else if ((!ppsc->hwradiooff) && (rfpwr_toset == ERFOFF)) {\n\t\trtl_dbg(rtlpriv, COMP_RF,\n\t\t\tDBG_DMESG, \"RFKILL-HW Radio OFF, RF OFF\\n\");\n\n\t\trfpwr_toset = ERFOFF;\n\t\tppsc->hwradiooff = true;\n\t\tactuallyset = true;\n\t}\n\n\tif (actuallyset) {\n\t\tspin_lock_irqsave(&rtlpriv->locks.rf_ps_lock, flag);\n\t\tppsc->rfchange_inprogress = false;\n\t\tspin_unlock_irqrestore(&rtlpriv->locks.rf_ps_lock, flag);\n\n\t \n\t \n\t} else {\n\t\t \n\t\tif (ppsc->reg_rfps_level & RT_RF_OFF_LEVL_HALT_NIC &&\n\t\t\tturnonbypowerdomain) {\n\t\t\t_rtl92s_phy_set_rfhalt(hw);\n\t\t\tRT_SET_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_HALT_NIC);\n\t\t}\n\n\t\tspin_lock_irqsave(&rtlpriv->locks.rf_ps_lock, flag);\n\t\tppsc->rfchange_inprogress = false;\n\t\tspin_unlock_irqrestore(&rtlpriv->locks.rf_ps_lock, flag);\n\t}\n\n\t*valid = 1;\n\treturn !ppsc->hwradiooff;\n\n}\n\n \nvoid rtl92se_set_key(struct ieee80211_hw *hw, u32 key_index, u8 *p_macaddr,\n\tbool is_group, u8 enc_algo, bool is_wepkey, bool clear_all)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tu8 *macaddr = p_macaddr;\n\n\tu32 entry_id = 0;\n\tbool is_pairwise = false;\n\n\tstatic u8 cam_const_addr[4][6] = {\n\t\t{0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n\t\t{0x00, 0x00, 0x00, 0x00, 0x00, 0x01},\n\t\t{0x00, 0x00, 0x00, 0x00, 0x00, 0x02},\n\t\t{0x00, 0x00, 0x00, 0x00, 0x00, 0x03}\n\t};\n\tstatic u8 cam_const_broad[] = {\n\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff\n\t};\n\n\tif (clear_all) {\n\t\tu8 idx = 0;\n\t\tu8 cam_offset = 0;\n\t\tu8 clear_number = 5;\n\n\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_DMESG, \"clear_all\\n\");\n\n\t\tfor (idx = 0; idx < clear_number; idx++) {\n\t\t\trtl_cam_mark_invalid(hw, cam_offset + idx);\n\t\t\trtl_cam_empty_entry(hw, cam_offset + idx);\n\n\t\t\tif (idx < 5) {\n\t\t\t\tmemset(rtlpriv->sec.key_buf[idx], 0,\n\t\t\t\t       MAX_KEY_LEN);\n\t\t\t\trtlpriv->sec.key_len[idx] = 0;\n\t\t\t}\n\t\t}\n\n\t} else {\n\t\tswitch (enc_algo) {\n\t\tcase WEP40_ENCRYPTION:\n\t\t\tenc_algo = CAM_WEP40;\n\t\t\tbreak;\n\t\tcase WEP104_ENCRYPTION:\n\t\t\tenc_algo = CAM_WEP104;\n\t\t\tbreak;\n\t\tcase TKIP_ENCRYPTION:\n\t\t\tenc_algo = CAM_TKIP;\n\t\t\tbreak;\n\t\tcase AESCCMP_ENCRYPTION:\n\t\t\tenc_algo = CAM_AES;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"switch case %#x not processed\\n\",\n\t\t\t       enc_algo);\n\t\t\tenc_algo = CAM_TKIP;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_wepkey || rtlpriv->sec.use_defaultkey) {\n\t\t\tmacaddr = cam_const_addr[key_index];\n\t\t\tentry_id = key_index;\n\t\t} else {\n\t\t\tif (is_group) {\n\t\t\t\tmacaddr = cam_const_broad;\n\t\t\t\tentry_id = key_index;\n\t\t\t} else {\n\t\t\t\tif (mac->opmode == NL80211_IFTYPE_AP) {\n\t\t\t\t\tentry_id = rtl_cam_get_free_entry(hw,\n\t\t\t\t\t\t\t\t p_macaddr);\n\t\t\t\t\tif (entry_id >=  TOTAL_CAM_ENTRY) {\n\t\t\t\t\t\tpr_err(\"Can not find free hw security cam entry\\n\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tentry_id = CAM_PAIRWISE_KEY_POSITION;\n\t\t\t\t}\n\n\t\t\t\tkey_index = PAIRWISE_KEYIDX;\n\t\t\t\tis_pairwise = true;\n\t\t\t}\n\t\t}\n\n\t\tif (rtlpriv->sec.key_len[key_index] == 0) {\n\t\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_DMESG,\n\t\t\t\t\"delete one entry, entry_id is %d\\n\",\n\t\t\t\tentry_id);\n\t\t\tif (mac->opmode == NL80211_IFTYPE_AP)\n\t\t\t\trtl_cam_del_entry(hw, p_macaddr);\n\t\t\trtl_cam_delete_one_entry(hw, p_macaddr, entry_id);\n\t\t} else {\n\t\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_DMESG,\n\t\t\t\t\"add one entry\\n\");\n\t\t\tif (is_pairwise) {\n\t\t\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_DMESG,\n\t\t\t\t\t\"set Pairwise key\\n\");\n\n\t\t\t\trtl_cam_add_one_entry(hw, macaddr, key_index,\n\t\t\t\t\tentry_id, enc_algo,\n\t\t\t\t\tCAM_CONFIG_NO_USEDK,\n\t\t\t\t\trtlpriv->sec.key_buf[key_index]);\n\t\t\t} else {\n\t\t\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_DMESG,\n\t\t\t\t\t\"set group key\\n\");\n\n\t\t\t\tif (mac->opmode == NL80211_IFTYPE_ADHOC) {\n\t\t\t\t\trtl_cam_add_one_entry(hw,\n\t\t\t\t\t\trtlefuse->dev_addr,\n\t\t\t\t\t\tPAIRWISE_KEYIDX,\n\t\t\t\t\t\tCAM_PAIRWISE_KEY_POSITION,\n\t\t\t\t\t\tenc_algo, CAM_CONFIG_NO_USEDK,\n\t\t\t\t\t\trtlpriv->sec.key_buf[entry_id]);\n\t\t\t\t}\n\n\t\t\t\trtl_cam_add_one_entry(hw, macaddr, key_index,\n\t\t\t\t\t      entry_id, enc_algo,\n\t\t\t\t\t      CAM_CONFIG_NO_USEDK,\n\t\t\t\t\t      rtlpriv->sec.key_buf[entry_id]);\n\t\t\t}\n\n\t\t}\n\t}\n}\n\nvoid rtl92se_suspend(struct ieee80211_hw *hw)\n{\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\n\trtlpci->up_first_time = true;\n}\n\nvoid rtl92se_resume(struct ieee80211_hw *hw)\n{\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tu32 val;\n\n\tpci_read_config_dword(rtlpci->pdev, 0x40, &val);\n\tif ((val & 0x0000ff00) != 0)\n\t\tpci_write_config_dword(rtlpci->pdev, 0x40,\n\t\t\tval & 0xffff00ff);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}