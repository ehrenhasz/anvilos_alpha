{
  "module_name": "phy.c",
  "hash_id": "2dddfdb0856b59865ab14406379c4185b38cc3af81d35ee6e2df9d4c61a318f4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtlwifi/rtl8192se/phy.c",
  "human_readable_source": "\n \n\n#include \"../wifi.h\"\n#include \"../pci.h\"\n#include \"../ps.h\"\n#include \"../core.h\"\n#include \"reg.h\"\n#include \"def.h\"\n#include \"phy.h\"\n#include \"rf.h\"\n#include \"dm.h\"\n#include \"fw.h\"\n#include \"hw.h\"\n#include \"table.h\"\n\nu32 rtl92s_phy_query_bb_reg(struct ieee80211_hw *hw, u32 regaddr, u32 bitmask)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 returnvalue = 0, originalvalue, bitshift;\n\n\trtl_dbg(rtlpriv, COMP_RF, DBG_TRACE, \"regaddr(%#x), bitmask(%#x)\\n\",\n\t\tregaddr, bitmask);\n\n\toriginalvalue = rtl_read_dword(rtlpriv, regaddr);\n\tbitshift = calculate_bit_shift(bitmask);\n\treturnvalue = (originalvalue & bitmask) >> bitshift;\n\n\trtl_dbg(rtlpriv, COMP_RF, DBG_TRACE, \"BBR MASK=0x%x Addr[0x%x]=0x%x\\n\",\n\t\tbitmask, regaddr, originalvalue);\n\n\treturn returnvalue;\n\n}\n\nvoid rtl92s_phy_set_bb_reg(struct ieee80211_hw *hw, u32 regaddr, u32 bitmask,\n\t\t\t   u32 data)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 originalvalue, bitshift;\n\n\trtl_dbg(rtlpriv, COMP_RF, DBG_TRACE,\n\t\t\"regaddr(%#x), bitmask(%#x), data(%#x)\\n\",\n\t\tregaddr, bitmask, data);\n\n\tif (bitmask != MASKDWORD) {\n\t\toriginalvalue = rtl_read_dword(rtlpriv, regaddr);\n\t\tbitshift = calculate_bit_shift(bitmask);\n\t\tdata = ((originalvalue & (~bitmask)) | (data << bitshift));\n\t}\n\n\trtl_write_dword(rtlpriv, regaddr, data);\n\n\trtl_dbg(rtlpriv, COMP_RF, DBG_TRACE,\n\t\t\"regaddr(%#x), bitmask(%#x), data(%#x)\\n\",\n\t\tregaddr, bitmask, data);\n\n}\n\nstatic u32 _rtl92s_phy_rf_serial_read(struct ieee80211_hw *hw,\n\t\t\t\t      enum radio_path rfpath, u32 offset)\n{\n\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct bb_reg_def *pphyreg = &rtlphy->phyreg_def[rfpath];\n\tu32 newoffset;\n\tu32 tmplong, tmplong2;\n\tu8 rfpi_enable = 0;\n\tu32 retvalue = 0;\n\n\toffset &= 0x3f;\n\tnewoffset = offset;\n\n\ttmplong = rtl_get_bbreg(hw, RFPGA0_XA_HSSIPARAMETER2, MASKDWORD);\n\n\tif (rfpath == RF90_PATH_A)\n\t\ttmplong2 = tmplong;\n\telse\n\t\ttmplong2 = rtl_get_bbreg(hw, pphyreg->rfhssi_para2, MASKDWORD);\n\n\ttmplong2 = (tmplong2 & (~BLSSI_READADDRESS)) | (newoffset << 23) |\n\t\t\tBLSSI_READEDGE;\n\n\trtl_set_bbreg(hw, RFPGA0_XA_HSSIPARAMETER2, MASKDWORD,\n\t\t      tmplong & (~BLSSI_READEDGE));\n\n\tmdelay(1);\n\n\trtl_set_bbreg(hw, pphyreg->rfhssi_para2, MASKDWORD, tmplong2);\n\tmdelay(1);\n\n\trtl_set_bbreg(hw, RFPGA0_XA_HSSIPARAMETER2, MASKDWORD, tmplong |\n\t\t      BLSSI_READEDGE);\n\tmdelay(1);\n\n\tif (rfpath == RF90_PATH_A)\n\t\trfpi_enable = (u8)rtl_get_bbreg(hw, RFPGA0_XA_HSSIPARAMETER1,\n\t\t\t\t\t\tBIT(8));\n\telse if (rfpath == RF90_PATH_B)\n\t\trfpi_enable = (u8)rtl_get_bbreg(hw, RFPGA0_XB_HSSIPARAMETER1,\n\t\t\t\t\t\tBIT(8));\n\n\tif (rfpi_enable)\n\t\tretvalue = rtl_get_bbreg(hw, pphyreg->rf_rbpi,\n\t\t\t\t\t BLSSI_READBACK_DATA);\n\telse\n\t\tretvalue = rtl_get_bbreg(hw, pphyreg->rf_rb,\n\t\t\t\t\t BLSSI_READBACK_DATA);\n\n\trtl_dbg(rtlpriv, COMP_RF, DBG_TRACE, \"RFR-%d Addr[0x%x]=0x%x\\n\",\n\t\trfpath, pphyreg->rf_rb, retvalue);\n\n\treturn retvalue;\n\n}\n\nstatic void _rtl92s_phy_rf_serial_write(struct ieee80211_hw *hw,\n\t\t\t\t\tenum radio_path rfpath, u32 offset,\n\t\t\t\t\tu32 data)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct bb_reg_def *pphyreg = &rtlphy->phyreg_def[rfpath];\n\tu32 data_and_addr = 0;\n\tu32 newoffset;\n\n\toffset &= 0x3f;\n\tnewoffset = offset;\n\n\tdata_and_addr = ((newoffset << 20) | (data & 0x000fffff)) & 0x0fffffff;\n\trtl_set_bbreg(hw, pphyreg->rf3wire_offset, MASKDWORD, data_and_addr);\n\n\trtl_dbg(rtlpriv, COMP_RF, DBG_TRACE, \"RFW-%d Addr[0x%x]=0x%x\\n\",\n\t\trfpath, pphyreg->rf3wire_offset, data_and_addr);\n}\n\n\nu32 rtl92s_phy_query_rf_reg(struct ieee80211_hw *hw, enum radio_path rfpath,\n\t\t\t    u32 regaddr, u32 bitmask)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 original_value, readback_value, bitshift;\n\n\trtl_dbg(rtlpriv, COMP_RF, DBG_TRACE,\n\t\t\"regaddr(%#x), rfpath(%#x), bitmask(%#x)\\n\",\n\t\t regaddr, rfpath, bitmask);\n\n\tspin_lock(&rtlpriv->locks.rf_lock);\n\n\toriginal_value = _rtl92s_phy_rf_serial_read(hw, rfpath, regaddr);\n\n\tbitshift = calculate_bit_shift(bitmask);\n\treadback_value = (original_value & bitmask) >> bitshift;\n\n\tspin_unlock(&rtlpriv->locks.rf_lock);\n\n\trtl_dbg(rtlpriv, COMP_RF, DBG_TRACE,\n\t\t\"regaddr(%#x), rfpath(%#x), bitmask(%#x), original_value(%#x)\\n\",\n\t\tregaddr, rfpath, bitmask, original_value);\n\n\treturn readback_value;\n}\n\nvoid rtl92s_phy_set_rf_reg(struct ieee80211_hw *hw, enum radio_path rfpath,\n\t\t\t   u32 regaddr, u32 bitmask, u32 data)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tu32 original_value, bitshift;\n\n\tif (!((rtlphy->rf_pathmap >> rfpath) & 0x1))\n\t\treturn;\n\n\trtl_dbg(rtlpriv, COMP_RF, DBG_TRACE,\n\t\t\"regaddr(%#x), bitmask(%#x), data(%#x), rfpath(%#x)\\n\",\n\t\tregaddr, bitmask, data, rfpath);\n\n\tspin_lock(&rtlpriv->locks.rf_lock);\n\n\tif (bitmask != RFREG_OFFSET_MASK) {\n\t\toriginal_value = _rtl92s_phy_rf_serial_read(hw, rfpath,\n\t\t\t\t\t\t\t    regaddr);\n\t\tbitshift = calculate_bit_shift(bitmask);\n\t\tdata = ((original_value & (~bitmask)) | (data << bitshift));\n\t}\n\n\t_rtl92s_phy_rf_serial_write(hw, rfpath, regaddr, data);\n\n\tspin_unlock(&rtlpriv->locks.rf_lock);\n\n\trtl_dbg(rtlpriv, COMP_RF, DBG_TRACE,\n\t\t\"regaddr(%#x), bitmask(%#x), data(%#x), rfpath(%#x)\\n\",\n\t\tregaddr, bitmask, data, rfpath);\n\n}\n\nvoid rtl92s_phy_scan_operation_backup(struct ieee80211_hw *hw,\n\t\t\t\t      u8 operation)\n{\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\n\tif (!is_hal_stop(rtlhal)) {\n\t\tswitch (operation) {\n\t\tcase SCAN_OPT_BACKUP:\n\t\t\trtl92s_phy_set_fw_cmd(hw, FW_CMD_PAUSE_DM_BY_SCAN);\n\t\t\tbreak;\n\t\tcase SCAN_OPT_RESTORE:\n\t\t\trtl92s_phy_set_fw_cmd(hw, FW_CMD_RESUME_DM_BY_SCAN);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Unknown operation\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid rtl92s_phy_set_bw_mode(struct ieee80211_hw *hw,\n\t\t\t    enum nl80211_channel_type ch_type)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tu8 reg_bw_opmode;\n\n\trtl_dbg(rtlpriv, COMP_SCAN, DBG_TRACE, \"Switch to %s bandwidth\\n\",\n\t\trtlphy->current_chan_bw == HT_CHANNEL_WIDTH_20 ?\n\t\t\"20MHz\" : \"40MHz\");\n\n\tif (rtlphy->set_bwmode_inprogress)\n\t\treturn;\n\tif (is_hal_stop(rtlhal))\n\t\treturn;\n\n\trtlphy->set_bwmode_inprogress = true;\n\n\treg_bw_opmode = rtl_read_byte(rtlpriv, BW_OPMODE);\n\t \n\trtl_read_byte(rtlpriv, RRSR + 2);\n\n\tswitch (rtlphy->current_chan_bw) {\n\tcase HT_CHANNEL_WIDTH_20:\n\t\treg_bw_opmode |= BW_OPMODE_20MHZ;\n\t\trtl_write_byte(rtlpriv, BW_OPMODE, reg_bw_opmode);\n\t\tbreak;\n\tcase HT_CHANNEL_WIDTH_20_40:\n\t\treg_bw_opmode &= ~BW_OPMODE_20MHZ;\n\t\trtl_write_byte(rtlpriv, BW_OPMODE, reg_bw_opmode);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"unknown bandwidth: %#X\\n\",\n\t\t       rtlphy->current_chan_bw);\n\t\tbreak;\n\t}\n\n\tswitch (rtlphy->current_chan_bw) {\n\tcase HT_CHANNEL_WIDTH_20:\n\t\trtl_set_bbreg(hw, RFPGA0_RFMOD, BRFMOD, 0x0);\n\t\trtl_set_bbreg(hw, RFPGA1_RFMOD, BRFMOD, 0x0);\n\n\t\tif (rtlhal->version >= VERSION_8192S_BCUT)\n\t\t\trtl_write_byte(rtlpriv, RFPGA0_ANALOGPARAMETER2, 0x58);\n\t\tbreak;\n\tcase HT_CHANNEL_WIDTH_20_40:\n\t\trtl_set_bbreg(hw, RFPGA0_RFMOD, BRFMOD, 0x1);\n\t\trtl_set_bbreg(hw, RFPGA1_RFMOD, BRFMOD, 0x1);\n\n\t\trtl_set_bbreg(hw, RCCK0_SYSTEM, BCCK_SIDEBAND,\n\t\t\t\t(mac->cur_40_prime_sc >> 1));\n\t\trtl_set_bbreg(hw, ROFDM1_LSTF, 0xC00, mac->cur_40_prime_sc);\n\n\t\tif (rtlhal->version >= VERSION_8192S_BCUT)\n\t\t\trtl_write_byte(rtlpriv, RFPGA0_ANALOGPARAMETER2, 0x18);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"unknown bandwidth: %#X\\n\",\n\t\t       rtlphy->current_chan_bw);\n\t\tbreak;\n\t}\n\n\trtl92s_phy_rf6052_set_bandwidth(hw, rtlphy->current_chan_bw);\n\trtlphy->set_bwmode_inprogress = false;\n\trtl_dbg(rtlpriv, COMP_SCAN, DBG_TRACE, \"<==\\n\");\n}\n\nstatic bool _rtl92s_phy_set_sw_chnl_cmdarray(struct swchnlcmd *cmdtable,\n\t\tu32 cmdtableidx, u32 cmdtablesz, enum swchnlcmd_id cmdid,\n\t\tu32 para1, u32 para2, u32 msdelay)\n{\n\tstruct swchnlcmd *pcmd;\n\n\tif (cmdtable == NULL) {\n\t\tWARN_ONCE(true, \"rtl8192se: cmdtable cannot be NULL\\n\");\n\t\treturn false;\n\t}\n\n\tif (cmdtableidx >= cmdtablesz)\n\t\treturn false;\n\n\tpcmd = cmdtable + cmdtableidx;\n\tpcmd->cmdid = cmdid;\n\tpcmd->para1 = para1;\n\tpcmd->para2 = para2;\n\tpcmd->msdelay = msdelay;\n\n\treturn true;\n}\n\nstatic bool _rtl92s_phy_sw_chnl_step_by_step(struct ieee80211_hw *hw,\n\t     u8 channel, u8 *stage, u8 *step, u32 *delay)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct swchnlcmd precommoncmd[MAX_PRECMD_CNT];\n\tu32 precommoncmdcnt;\n\tstruct swchnlcmd postcommoncmd[MAX_POSTCMD_CNT];\n\tu32 postcommoncmdcnt;\n\tstruct swchnlcmd rfdependcmd[MAX_RFDEPENDCMD_CNT];\n\tu32 rfdependcmdcnt;\n\tstruct swchnlcmd *currentcmd = NULL;\n\tu8 rfpath;\n\tu8 num_total_rfpath = rtlphy->num_total_rfpath;\n\n\tprecommoncmdcnt = 0;\n\t_rtl92s_phy_set_sw_chnl_cmdarray(precommoncmd, precommoncmdcnt++,\n\t\t\tMAX_PRECMD_CNT, CMDID_SET_TXPOWEROWER_LEVEL, 0, 0, 0);\n\t_rtl92s_phy_set_sw_chnl_cmdarray(precommoncmd, precommoncmdcnt++,\n\t\t\tMAX_PRECMD_CNT, CMDID_END, 0, 0, 0);\n\n\tpostcommoncmdcnt = 0;\n\n\t_rtl92s_phy_set_sw_chnl_cmdarray(postcommoncmd, postcommoncmdcnt++,\n\t\t\tMAX_POSTCMD_CNT, CMDID_END, 0, 0, 0);\n\n\trfdependcmdcnt = 0;\n\n\tWARN_ONCE((channel < 1 || channel > 14),\n\t\t  \"rtl8192se: invalid channel for Zebra: %d\\n\", channel);\n\n\t_rtl92s_phy_set_sw_chnl_cmdarray(rfdependcmd, rfdependcmdcnt++,\n\t\t\t\t\t MAX_RFDEPENDCMD_CNT, CMDID_RF_WRITEREG,\n\t\t\t\t\t RF_CHNLBW, channel, 10);\n\n\t_rtl92s_phy_set_sw_chnl_cmdarray(rfdependcmd, rfdependcmdcnt++,\n\t\t\tMAX_RFDEPENDCMD_CNT, CMDID_END, 0, 0, 0);\n\n\tdo {\n\t\tswitch (*stage) {\n\t\tcase 0:\n\t\t\tcurrentcmd = &precommoncmd[*step];\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tcurrentcmd = &rfdependcmd[*step];\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tcurrentcmd = &postcommoncmd[*step];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn true;\n\t\t}\n\n\t\tif (currentcmd->cmdid == CMDID_END) {\n\t\t\tif ((*stage) == 2) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\t(*stage)++;\n\t\t\t\t(*step) = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tswitch (currentcmd->cmdid) {\n\t\tcase CMDID_SET_TXPOWEROWER_LEVEL:\n\t\t\trtl92s_phy_set_txpower(hw, channel);\n\t\t\tbreak;\n\t\tcase CMDID_WRITEPORT_ULONG:\n\t\t\trtl_write_dword(rtlpriv, currentcmd->para1,\n\t\t\t\t\tcurrentcmd->para2);\n\t\t\tbreak;\n\t\tcase CMDID_WRITEPORT_USHORT:\n\t\t\trtl_write_word(rtlpriv, currentcmd->para1,\n\t\t\t\t       (u16)currentcmd->para2);\n\t\t\tbreak;\n\t\tcase CMDID_WRITEPORT_UCHAR:\n\t\t\trtl_write_byte(rtlpriv, currentcmd->para1,\n\t\t\t\t       (u8)currentcmd->para2);\n\t\t\tbreak;\n\t\tcase CMDID_RF_WRITEREG:\n\t\t\tfor (rfpath = 0; rfpath < num_total_rfpath; rfpath++) {\n\t\t\t\trtlphy->rfreg_chnlval[rfpath] =\n\t\t\t\t\t ((rtlphy->rfreg_chnlval[rfpath] &\n\t\t\t\t\t 0xfffffc00) | currentcmd->para2);\n\t\t\t\trtl_set_rfreg(hw, (enum radio_path)rfpath,\n\t\t\t\t\t      currentcmd->para1,\n\t\t\t\t\t      RFREG_OFFSET_MASK,\n\t\t\t\t\t      rtlphy->rfreg_chnlval[rfpath]);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"switch case %#x not processed\\n\",\n\t\t\t       currentcmd->cmdid);\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\t} while (true);\n\n\t(*delay) = currentcmd->msdelay;\n\t(*step)++;\n\treturn false;\n}\n\nu8 rtl92s_phy_sw_chnl(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tu32 delay;\n\tbool ret;\n\n\trtl_dbg(rtlpriv, COMP_SCAN, DBG_TRACE, \"switch to channel%d\\n\",\n\t\trtlphy->current_channel);\n\n\tif (rtlphy->sw_chnl_inprogress)\n\t\treturn 0;\n\n\tif (rtlphy->set_bwmode_inprogress)\n\t\treturn 0;\n\n\tif (is_hal_stop(rtlhal))\n\t\treturn 0;\n\n\trtlphy->sw_chnl_inprogress = true;\n\trtlphy->sw_chnl_stage = 0;\n\trtlphy->sw_chnl_step = 0;\n\n\tdo {\n\t\tif (!rtlphy->sw_chnl_inprogress)\n\t\t\tbreak;\n\n\t\tret = _rtl92s_phy_sw_chnl_step_by_step(hw,\n\t\t\t\t rtlphy->current_channel,\n\t\t\t\t &rtlphy->sw_chnl_stage,\n\t\t\t\t &rtlphy->sw_chnl_step, &delay);\n\t\tif (!ret) {\n\t\t\tif (delay > 0)\n\t\t\t\tmdelay(delay);\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\trtlphy->sw_chnl_inprogress = false;\n\t\t}\n\t\tbreak;\n\t} while (true);\n\n\trtlphy->sw_chnl_inprogress = false;\n\n\trtl_dbg(rtlpriv, COMP_SCAN, DBG_TRACE, \"<==\\n\");\n\n\treturn 1;\n}\n\nstatic void _rtl92se_phy_set_rf_sleep(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 u1btmp;\n\n\tu1btmp = rtl_read_byte(rtlpriv, LDOV12D_CTRL);\n\tu1btmp |= BIT(0);\n\n\trtl_write_byte(rtlpriv, LDOV12D_CTRL, u1btmp);\n\trtl_write_byte(rtlpriv, SPS1_CTRL, 0x0);\n\trtl_write_byte(rtlpriv, TXPAUSE, 0xFF);\n\trtl_write_word(rtlpriv, CMDR, 0x57FC);\n\tudelay(100);\n\n\trtl_write_word(rtlpriv, CMDR, 0x77FC);\n\trtl_write_byte(rtlpriv, PHY_CCA, 0x0);\n\tudelay(10);\n\n\trtl_write_word(rtlpriv, CMDR, 0x37FC);\n\tudelay(10);\n\n\trtl_write_word(rtlpriv, CMDR, 0x77FC);\n\tudelay(10);\n\n\trtl_write_word(rtlpriv, CMDR, 0x57FC);\n\n\t \n\trtl8192se_gpiobit3_cfg_inputmode(hw);\n}\n\nbool rtl92s_phy_set_rf_power_state(struct ieee80211_hw *hw,\n\t\t\t\t   enum rf_pwrstate rfpwr_state)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci_priv *pcipriv = rtl_pcipriv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tbool bresult = true;\n\tu8 i, queue_id;\n\tstruct rtl8192_tx_ring *ring = NULL;\n\n\tif (rfpwr_state == ppsc->rfpwr_state)\n\t\treturn false;\n\n\tswitch (rfpwr_state) {\n\tcase ERFON:{\n\t\t\tif ((ppsc->rfpwr_state == ERFOFF) &&\n\t\t\t    RT_IN_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_HALT_NIC)) {\n\n\t\t\t\tbool rtstatus;\n\t\t\t\tu32 initializecount = 0;\n\t\t\t\tdo {\n\t\t\t\t\tinitializecount++;\n\t\t\t\t\trtl_dbg(rtlpriv, COMP_RF, DBG_DMESG,\n\t\t\t\t\t\t\"IPS Set eRf nic enable\\n\");\n\t\t\t\t\trtstatus = rtl_ps_enable_nic(hw);\n\t\t\t\t} while (!rtstatus && (initializecount < 10));\n\n\t\t\t\tRT_CLEAR_PS_LEVEL(ppsc,\n\t\t\t\t\t\t  RT_RF_OFF_LEVL_HALT_NIC);\n\t\t\t} else {\n\t\t\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_DMESG,\n\t\t\t\t\t\"awake, slept:%d ms state_inap:%x\\n\",\n\t\t\t\t\tjiffies_to_msecs(jiffies -\n\t\t\t\t\tppsc->last_sleep_jiffies),\n\t\t\t\t\trtlpriv->psc.state_inap);\n\t\t\t\tppsc->last_awake_jiffies = jiffies;\n\t\t\t\trtl_write_word(rtlpriv, CMDR, 0x37FC);\n\t\t\t\trtl_write_byte(rtlpriv, TXPAUSE, 0x00);\n\t\t\t\trtl_write_byte(rtlpriv, PHY_CCA, 0x3);\n\t\t\t}\n\n\t\t\tif (mac->link_state == MAC80211_LINKED)\n\t\t\t\trtlpriv->cfg->ops->led_control(hw,\n\t\t\t\t\t\t\t LED_CTL_LINK);\n\t\t\telse\n\t\t\t\trtlpriv->cfg->ops->led_control(hw,\n\t\t\t\t\t\t\t LED_CTL_NO_LINK);\n\t\t\tbreak;\n\t\t}\n\tcase ERFOFF:{\n\t\t\tif (ppsc->reg_rfps_level & RT_RF_OFF_LEVL_HALT_NIC) {\n\t\t\t\trtl_dbg(rtlpriv, COMP_RF, DBG_DMESG,\n\t\t\t\t\t\"IPS Set eRf nic disable\\n\");\n\t\t\t\trtl_ps_disable_nic(hw);\n\t\t\t\tRT_SET_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_HALT_NIC);\n\t\t\t} else {\n\t\t\t\tif (ppsc->rfoff_reason == RF_CHANGE_BY_IPS)\n\t\t\t\t\trtlpriv->cfg->ops->led_control(hw,\n\t\t\t\t\t\t\t LED_CTL_NO_LINK);\n\t\t\t\telse\n\t\t\t\t\trtlpriv->cfg->ops->led_control(hw,\n\t\t\t\t\t\t\t LED_CTL_POWER_OFF);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\tcase ERFSLEEP:\n\t\t\tif (ppsc->rfpwr_state == ERFOFF)\n\t\t\t\treturn false;\n\n\t\t\tfor (queue_id = 0, i = 0;\n\t\t\t     queue_id < RTL_PCI_MAX_TX_QUEUE_COUNT;) {\n\t\t\t\tring = &pcipriv->dev.tx_ring[queue_id];\n\t\t\t\tif (skb_queue_len(&ring->queue) == 0 ||\n\t\t\t\t\tqueue_id == BEACON_QUEUE) {\n\t\t\t\t\tqueue_id++;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_WARNING,\n\t\t\t\t\t\t\"eRf Off/Sleep: %d times TcbBusyQueue[%d] = %d before doze!\\n\",\n\t\t\t\t\t\ti + 1, queue_id,\n\t\t\t\t\t\tskb_queue_len(&ring->queue));\n\n\t\t\t\t\tudelay(10);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\n\t\t\t\tif (i >= MAX_DOZE_WAITING_TIMES_9x) {\n\t\t\t\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_WARNING,\n\t\t\t\t\t\t\"ERFOFF: %d times TcbBusyQueue[%d] = %d !\\n\",\n\t\t\t\t\t\tMAX_DOZE_WAITING_TIMES_9x,\n\t\t\t\t\t\tqueue_id,\n\t\t\t\t\t\tskb_queue_len(&ring->queue));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_DMESG,\n\t\t\t\t\"Set ERFSLEEP awaked:%d ms\\n\",\n\t\t\t\tjiffies_to_msecs(jiffies -\n\t\t\t\t\t\t ppsc->last_awake_jiffies));\n\n\t\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_DMESG,\n\t\t\t\t\"sleep awaked:%d ms state_inap:%x\\n\",\n\t\t\t\tjiffies_to_msecs(jiffies -\n\t\t\t\t\t\t ppsc->last_awake_jiffies),\n\t\t\t\t rtlpriv->psc.state_inap);\n\t\t\tppsc->last_sleep_jiffies = jiffies;\n\t\t\t_rtl92se_phy_set_rf_sleep(hw);\n\t\t\tbreak;\n\tdefault:\n\t\tpr_err(\"switch case %#x not processed\\n\",\n\t\t       rfpwr_state);\n\t\tbresult = false;\n\t\tbreak;\n\t}\n\n\tif (bresult)\n\t\tppsc->rfpwr_state = rfpwr_state;\n\n\treturn bresult;\n}\n\nstatic bool _rtl92s_phy_config_rfpa_bias_current(struct ieee80211_hw *hw,\n\t\t\t\t\t\t enum radio_path rfpath)\n{\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tbool rtstatus = true;\n\tu32 tmpval = 0;\n\n\t \n\tif (rtlhal->ic_class != IC_INFERIORITY_A) {\n\t\ttmpval = rtl92s_phy_query_rf_reg(hw, rfpath, RF_IPA, 0xf);\n\t\trtl92s_phy_set_rf_reg(hw, rfpath, RF_IPA, 0xf, tmpval + 1);\n\t}\n\n\treturn rtstatus;\n}\n\nstatic void _rtl92s_store_pwrindex_diffrate_offset(struct ieee80211_hw *hw,\n\t\tu32 reg_addr, u32 bitmask, u32 data)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tint index;\n\n\tif (reg_addr == RTXAGC_RATE18_06)\n\t\tindex = 0;\n\telse if (reg_addr == RTXAGC_RATE54_24)\n\t\tindex = 1;\n\telse if (reg_addr == RTXAGC_CCK_MCS32)\n\t\tindex = 6;\n\telse if (reg_addr == RTXAGC_MCS03_MCS00)\n\t\tindex = 2;\n\telse if (reg_addr == RTXAGC_MCS07_MCS04)\n\t\tindex = 3;\n\telse if (reg_addr == RTXAGC_MCS11_MCS08)\n\t\tindex = 4;\n\telse if (reg_addr == RTXAGC_MCS15_MCS12)\n\t\tindex = 5;\n\telse\n\t\treturn;\n\n\trtlphy->mcs_offset[rtlphy->pwrgroup_cnt][index] = data;\n\tif (index == 5)\n\t\trtlphy->pwrgroup_cnt++;\n}\n\nstatic void _rtl92s_phy_init_register_definition(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\n\t \n\trtlphy->phyreg_def[RF90_PATH_A].rfintfs = RFPGA0_XAB_RFINTERFACESW;\n\trtlphy->phyreg_def[RF90_PATH_B].rfintfs = RFPGA0_XAB_RFINTERFACESW;\n\trtlphy->phyreg_def[RF90_PATH_C].rfintfs = RFPGA0_XCD_RFINTERFACESW;\n\trtlphy->phyreg_def[RF90_PATH_D].rfintfs = RFPGA0_XCD_RFINTERFACESW;\n\n\t \n\trtlphy->phyreg_def[RF90_PATH_A].rfintfi = RFPGA0_XAB_RFINTERFACERB;\n\trtlphy->phyreg_def[RF90_PATH_B].rfintfi = RFPGA0_XAB_RFINTERFACERB;\n\trtlphy->phyreg_def[RF90_PATH_C].rfintfi = RFPGA0_XCD_RFINTERFACERB;\n\trtlphy->phyreg_def[RF90_PATH_D].rfintfi = RFPGA0_XCD_RFINTERFACERB;\n\n\t \n\trtlphy->phyreg_def[RF90_PATH_A].rfintfo = RFPGA0_XA_RFINTERFACEOE;\n\trtlphy->phyreg_def[RF90_PATH_B].rfintfo = RFPGA0_XB_RFINTERFACEOE;\n\trtlphy->phyreg_def[RF90_PATH_C].rfintfo = RFPGA0_XC_RFINTERFACEOE;\n\trtlphy->phyreg_def[RF90_PATH_D].rfintfo = RFPGA0_XD_RFINTERFACEOE;\n\n\t \n\trtlphy->phyreg_def[RF90_PATH_A].rfintfe = RFPGA0_XA_RFINTERFACEOE;\n\trtlphy->phyreg_def[RF90_PATH_B].rfintfe = RFPGA0_XB_RFINTERFACEOE;\n\trtlphy->phyreg_def[RF90_PATH_C].rfintfe = RFPGA0_XC_RFINTERFACEOE;\n\trtlphy->phyreg_def[RF90_PATH_D].rfintfe = RFPGA0_XD_RFINTERFACEOE;\n\n\t \n\trtlphy->phyreg_def[RF90_PATH_A].rf3wire_offset =\n\t\t\t\t\t\t RFPGA0_XA_LSSIPARAMETER;\n\trtlphy->phyreg_def[RF90_PATH_B].rf3wire_offset =\n\t\t\t\t\t\t RFPGA0_XB_LSSIPARAMETER;\n\trtlphy->phyreg_def[RF90_PATH_C].rf3wire_offset =\n\t\t\t\t\t\t RFPGA0_XC_LSSIPARAMETER;\n\trtlphy->phyreg_def[RF90_PATH_D].rf3wire_offset =\n\t\t\t\t\t\t RFPGA0_XD_LSSIPARAMETER;\n\n\t \n\trtlphy->phyreg_def[RF90_PATH_A].rflssi_select = RFPGA0_XAB_RFPARAMETER;\n\trtlphy->phyreg_def[RF90_PATH_B].rflssi_select = RFPGA0_XAB_RFPARAMETER;\n\trtlphy->phyreg_def[RF90_PATH_C].rflssi_select = RFPGA0_XCD_RFPARAMETER;\n\trtlphy->phyreg_def[RF90_PATH_D].rflssi_select = RFPGA0_XCD_RFPARAMETER;\n\n\t \n\trtlphy->phyreg_def[RF90_PATH_A].rftxgain_stage = RFPGA0_TXGAINSTAGE;\n\trtlphy->phyreg_def[RF90_PATH_B].rftxgain_stage = RFPGA0_TXGAINSTAGE;\n\trtlphy->phyreg_def[RF90_PATH_C].rftxgain_stage = RFPGA0_TXGAINSTAGE;\n\trtlphy->phyreg_def[RF90_PATH_D].rftxgain_stage = RFPGA0_TXGAINSTAGE;\n\n\t \n\trtlphy->phyreg_def[RF90_PATH_A].rfhssi_para1 = RFPGA0_XA_HSSIPARAMETER1;\n\trtlphy->phyreg_def[RF90_PATH_B].rfhssi_para1 = RFPGA0_XB_HSSIPARAMETER1;\n\trtlphy->phyreg_def[RF90_PATH_C].rfhssi_para1 = RFPGA0_XC_HSSIPARAMETER1;\n\trtlphy->phyreg_def[RF90_PATH_D].rfhssi_para1 = RFPGA0_XD_HSSIPARAMETER1;\n\n\t \n\trtlphy->phyreg_def[RF90_PATH_A].rfhssi_para2 = RFPGA0_XA_HSSIPARAMETER2;\n\trtlphy->phyreg_def[RF90_PATH_B].rfhssi_para2 = RFPGA0_XB_HSSIPARAMETER2;\n\trtlphy->phyreg_def[RF90_PATH_C].rfhssi_para2 = RFPGA0_XC_HSSIPARAMETER2;\n\trtlphy->phyreg_def[RF90_PATH_D].rfhssi_para2 = RFPGA0_XD_HSSIPARAMETER2;\n\n\t \n\trtlphy->phyreg_def[RF90_PATH_A].rfsw_ctrl = RFPGA0_XAB_SWITCHCONTROL;\n\trtlphy->phyreg_def[RF90_PATH_B].rfsw_ctrl = RFPGA0_XAB_SWITCHCONTROL;\n\trtlphy->phyreg_def[RF90_PATH_C].rfsw_ctrl = RFPGA0_XCD_SWITCHCONTROL;\n\trtlphy->phyreg_def[RF90_PATH_D].rfsw_ctrl = RFPGA0_XCD_SWITCHCONTROL;\n\n\t \n\trtlphy->phyreg_def[RF90_PATH_A].rfagc_control1 = ROFDM0_XAAGCCORE1;\n\trtlphy->phyreg_def[RF90_PATH_B].rfagc_control1 = ROFDM0_XBAGCCORE1;\n\trtlphy->phyreg_def[RF90_PATH_C].rfagc_control1 = ROFDM0_XCAGCCORE1;\n\trtlphy->phyreg_def[RF90_PATH_D].rfagc_control1 = ROFDM0_XDAGCCORE1;\n\n\t \n\trtlphy->phyreg_def[RF90_PATH_A].rfagc_control2 = ROFDM0_XAAGCCORE2;\n\trtlphy->phyreg_def[RF90_PATH_B].rfagc_control2 = ROFDM0_XBAGCCORE2;\n\trtlphy->phyreg_def[RF90_PATH_C].rfagc_control2 = ROFDM0_XCAGCCORE2;\n\trtlphy->phyreg_def[RF90_PATH_D].rfagc_control2 = ROFDM0_XDAGCCORE2;\n\n\t \n\trtlphy->phyreg_def[RF90_PATH_A].rfrxiq_imbal = ROFDM0_XARXIQIMBALANCE;\n\trtlphy->phyreg_def[RF90_PATH_B].rfrxiq_imbal = ROFDM0_XBRXIQIMBALANCE;\n\trtlphy->phyreg_def[RF90_PATH_C].rfrxiq_imbal = ROFDM0_XCRXIQIMBALANCE;\n\trtlphy->phyreg_def[RF90_PATH_D].rfrxiq_imbal = ROFDM0_XDRXIQIMBALANCE;\n\n\t \n\trtlphy->phyreg_def[RF90_PATH_A].rfrx_afe = ROFDM0_XARXAFE;\n\trtlphy->phyreg_def[RF90_PATH_B].rfrx_afe = ROFDM0_XBRXAFE;\n\trtlphy->phyreg_def[RF90_PATH_C].rfrx_afe = ROFDM0_XCRXAFE;\n\trtlphy->phyreg_def[RF90_PATH_D].rfrx_afe = ROFDM0_XDRXAFE;\n\n\t \n\trtlphy->phyreg_def[RF90_PATH_A].rftxiq_imbal = ROFDM0_XATXIQIMBALANCE;\n\trtlphy->phyreg_def[RF90_PATH_B].rftxiq_imbal = ROFDM0_XBTXIQIMBALANCE;\n\trtlphy->phyreg_def[RF90_PATH_C].rftxiq_imbal = ROFDM0_XCTXIQIMBALANCE;\n\trtlphy->phyreg_def[RF90_PATH_D].rftxiq_imbal = ROFDM0_XDTXIQIMBALANCE;\n\n\t \n\trtlphy->phyreg_def[RF90_PATH_A].rftx_afe = ROFDM0_XATXAFE;\n\trtlphy->phyreg_def[RF90_PATH_B].rftx_afe = ROFDM0_XBTXAFE;\n\trtlphy->phyreg_def[RF90_PATH_C].rftx_afe = ROFDM0_XCTXAFE;\n\trtlphy->phyreg_def[RF90_PATH_D].rftx_afe = ROFDM0_XDTXAFE;\n\n\t \n\trtlphy->phyreg_def[RF90_PATH_A].rf_rb = RFPGA0_XA_LSSIREADBACK;\n\trtlphy->phyreg_def[RF90_PATH_B].rf_rb = RFPGA0_XB_LSSIREADBACK;\n\trtlphy->phyreg_def[RF90_PATH_C].rf_rb = RFPGA0_XC_LSSIREADBACK;\n\trtlphy->phyreg_def[RF90_PATH_D].rf_rb = RFPGA0_XD_LSSIREADBACK;\n\n\t \n\trtlphy->phyreg_def[RF90_PATH_A].rf_rbpi = TRANSCEIVERA_HSPI_READBACK;\n\trtlphy->phyreg_def[RF90_PATH_B].rf_rbpi = TRANSCEIVERB_HSPI_READBACK;\n}\n\n\nstatic bool _rtl92s_phy_config_bb(struct ieee80211_hw *hw, u8 configtype)\n{\n\tint i;\n\tu32 *phy_reg_table;\n\tu32 *agc_table;\n\tu16 phy_reg_len, agc_len;\n\n\tagc_len = AGCTAB_ARRAYLENGTH;\n\tagc_table = rtl8192seagctab_array;\n\t \n\tphy_reg_len = PHY_REG_2T2RARRAYLENGTH;\n\tphy_reg_table = rtl8192sephy_reg_2t2rarray;\n\n\tif (configtype == BASEBAND_CONFIG_PHY_REG) {\n\t\tfor (i = 0; i < phy_reg_len; i = i + 2) {\n\t\t\trtl_addr_delay(phy_reg_table[i]);\n\n\t\t\t \n\t\t\tudelay(1);\n\n\t\t\trtl92s_phy_set_bb_reg(hw, phy_reg_table[i], MASKDWORD,\n\t\t\t\t\tphy_reg_table[i + 1]);\n\t\t}\n\t} else if (configtype == BASEBAND_CONFIG_AGC_TAB) {\n\t\tfor (i = 0; i < agc_len; i = i + 2) {\n\t\t\trtl92s_phy_set_bb_reg(hw, agc_table[i], MASKDWORD,\n\t\t\t\t\tagc_table[i + 1]);\n\n\t\t\t \n\t\t\tudelay(1);\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic bool _rtl92s_phy_set_bb_to_diff_rf(struct ieee80211_hw *hw,\n\t\t\t\t\t  u8 configtype)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tu32 *phy_regarray2xtxr_table;\n\tu16 phy_regarray2xtxr_len;\n\tint i;\n\n\tif (rtlphy->rf_type == RF_1T1R) {\n\t\tphy_regarray2xtxr_table = rtl8192sephy_changeto_1t1rarray;\n\t\tphy_regarray2xtxr_len = PHY_CHANGETO_1T1RARRAYLENGTH;\n\t} else if (rtlphy->rf_type == RF_1T2R) {\n\t\tphy_regarray2xtxr_table = rtl8192sephy_changeto_1t2rarray;\n\t\tphy_regarray2xtxr_len = PHY_CHANGETO_1T2RARRAYLENGTH;\n\t} else {\n\t\treturn false;\n\t}\n\n\tif (configtype == BASEBAND_CONFIG_PHY_REG) {\n\t\tfor (i = 0; i < phy_regarray2xtxr_len; i = i + 3) {\n\t\t\trtl_addr_delay(phy_regarray2xtxr_table[i]);\n\n\t\t\trtl92s_phy_set_bb_reg(hw, phy_regarray2xtxr_table[i],\n\t\t\t\tphy_regarray2xtxr_table[i + 1],\n\t\t\t\tphy_regarray2xtxr_table[i + 2]);\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic bool _rtl92s_phy_config_bb_with_pg(struct ieee80211_hw *hw,\n\t\t\t\t\t  u8 configtype)\n{\n\tint i;\n\tu32 *phy_table_pg;\n\tu16 phy_pg_len;\n\n\tphy_pg_len = PHY_REG_ARRAY_PGLENGTH;\n\tphy_table_pg = rtl8192sephy_reg_array_pg;\n\n\tif (configtype == BASEBAND_CONFIG_PHY_REG) {\n\t\tfor (i = 0; i < phy_pg_len; i = i + 3) {\n\t\t\trtl_addr_delay(phy_table_pg[i]);\n\n\t\t\t_rtl92s_store_pwrindex_diffrate_offset(hw,\n\t\t\t\t\tphy_table_pg[i],\n\t\t\t\t\tphy_table_pg[i + 1],\n\t\t\t\t\tphy_table_pg[i + 2]);\n\t\t\trtl92s_phy_set_bb_reg(hw, phy_table_pg[i],\n\t\t\t\t\tphy_table_pg[i + 1],\n\t\t\t\t\tphy_table_pg[i + 2]);\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic bool _rtl92s_phy_bb_config_parafile(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tbool rtstatus = true;\n\n\t \n\t \n\tif (rtlphy->rf_type == RF_1T2R || rtlphy->rf_type == RF_2T2R ||\n\t    rtlphy->rf_type == RF_1T1R || rtlphy->rf_type == RF_2T2R_GREEN) {\n\t\trtstatus = _rtl92s_phy_config_bb(hw, BASEBAND_CONFIG_PHY_REG);\n\n\t\tif (rtlphy->rf_type != RF_2T2R &&\n\t\t    rtlphy->rf_type != RF_2T2R_GREEN)\n\t\t\t \n\t\t\trtstatus = _rtl92s_phy_set_bb_to_diff_rf(hw,\n\t\t\t\t\t\tBASEBAND_CONFIG_PHY_REG);\n\t} else {\n\t\trtstatus = false;\n\t}\n\n\tif (!rtstatus) {\n\t\tpr_err(\"Write BB Reg Fail!!\\n\");\n\t\tgoto phy_bb8190_config_parafile_fail;\n\t}\n\n\t \n\tif (rtlefuse->autoload_failflag == false) {\n\t\trtlphy->pwrgroup_cnt = 0;\n\n\t\trtstatus = _rtl92s_phy_config_bb_with_pg(hw,\n\t\t\t\t\t\t BASEBAND_CONFIG_PHY_REG);\n\t}\n\tif (!rtstatus) {\n\t\tpr_err(\"_rtl92s_phy_bb_config_parafile(): BB_PG Reg Fail!!\\n\");\n\t\tgoto phy_bb8190_config_parafile_fail;\n\t}\n\n\t \n\trtstatus = _rtl92s_phy_config_bb(hw, BASEBAND_CONFIG_AGC_TAB);\n\n\tif (!rtstatus) {\n\t\tpr_err(\"%s(): AGC Table Fail\\n\", __func__);\n\t\tgoto phy_bb8190_config_parafile_fail;\n\t}\n\n\t \n\t \n\trtlphy->cck_high_power = (bool)(rtl92s_phy_query_bb_reg(hw,\n\t\t\tRFPGA0_XA_HSSIPARAMETER2, 0x200));\n\nphy_bb8190_config_parafile_fail:\n\treturn rtstatus;\n}\n\nu8 rtl92s_phy_config_rf(struct ieee80211_hw *hw, enum radio_path rfpath)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tint i;\n\tbool rtstatus = true;\n\tu32 *radio_a_table;\n\tu32 *radio_b_table;\n\tu16 radio_a_tblen, radio_b_tblen;\n\n\tradio_a_tblen = RADIOA_1T_ARRAYLENGTH;\n\tradio_a_table = rtl8192seradioa_1t_array;\n\n\t \n\tif (rtlphy->rf_type == RF_2T2R_GREEN) {\n\t\tradio_b_table = rtl8192seradiob_gm_array;\n\t\tradio_b_tblen = RADIOB_GM_ARRAYLENGTH;\n\t} else {\n\t\tradio_b_table = rtl8192seradiob_array;\n\t\tradio_b_tblen = RADIOB_ARRAYLENGTH;\n\t}\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD, \"Radio No %x\\n\", rfpath);\n\trtstatus = true;\n\n\tswitch (rfpath) {\n\tcase RF90_PATH_A:\n\t\tfor (i = 0; i < radio_a_tblen; i = i + 2) {\n\t\t\trtl_rfreg_delay(hw, rfpath, radio_a_table[i],\n\t\t\t\t\tMASK20BITS, radio_a_table[i + 1]);\n\n\t\t}\n\n\t\t \n\t\t_rtl92s_phy_config_rfpa_bias_current(hw, rfpath);\n\t\tbreak;\n\tcase RF90_PATH_B:\n\t\tfor (i = 0; i < radio_b_tblen; i = i + 2) {\n\t\t\trtl_rfreg_delay(hw, rfpath, radio_b_table[i],\n\t\t\t\t\tMASK20BITS, radio_b_table[i + 1]);\n\t\t}\n\t\tbreak;\n\tcase RF90_PATH_C:\n\t\t;\n\t\tbreak;\n\tcase RF90_PATH_D:\n\t\t;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn rtstatus;\n}\n\n\nbool rtl92s_phy_mac_config(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 i;\n\tu32 arraylength;\n\tu32 *ptrarray;\n\n\tarraylength = MAC_2T_ARRAYLENGTH;\n\tptrarray = rtl8192semac_2t_array;\n\n\tfor (i = 0; i < arraylength; i = i + 2)\n\t\trtl_write_byte(rtlpriv, ptrarray[i], (u8)ptrarray[i + 1]);\n\n\treturn true;\n}\n\n\nbool rtl92s_phy_bb_config(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tbool rtstatus;\n\tu8 pathmap, index, rf_num = 0;\n\tu8 path1, path2;\n\n\t_rtl92s_phy_init_register_definition(hw);\n\n\t \n\trtstatus = _rtl92s_phy_bb_config_parafile(hw);\n\n\n\t \n\t \n\tpath1 = (u8)(rtl92s_phy_query_bb_reg(hw, RFPGA0_TXINFO, 0xf));\n\tmdelay(10);\n\tpath2 = (u8)(rtl92s_phy_query_bb_reg(hw, ROFDM0_TRXPATHENABLE, 0xf));\n\tpathmap = path1 | path2;\n\n\trtlphy->rf_pathmap = pathmap;\n\tfor (index = 0; index < 4; index++) {\n\t\tif ((pathmap >> index) & 0x1)\n\t\t\trf_num++;\n\t}\n\n\tif ((rtlphy->rf_type == RF_1T1R && rf_num != 1) ||\n\t    (rtlphy->rf_type == RF_1T2R && rf_num != 2) ||\n\t    (rtlphy->rf_type == RF_2T2R && rf_num != 2) ||\n\t    (rtlphy->rf_type == RF_2T2R_GREEN && rf_num != 2)) {\n\t\tpr_err(\"RF_Type(%x) does not match RF_Num(%x)!!\\n\",\n\t\t       rtlphy->rf_type, rf_num);\n\t\tpr_err(\"path1 0x%x, path2 0x%x, pathmap 0x%x\\n\",\n\t\t       path1, path2, pathmap);\n\t}\n\n\treturn rtstatus;\n}\n\nbool rtl92s_phy_rf_config(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\n\t \n\tif (rtlphy->rf_type == RF_1T1R)\n\t\trtlphy->num_total_rfpath = 1;\n\telse\n\t\trtlphy->num_total_rfpath = 2;\n\n\t \n\treturn rtl92s_phy_rf6052_config(hw);\n}\n\nvoid rtl92s_phy_get_hw_reg_originalvalue(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\n\t \n\trtlphy->default_initialgain[0] = rtl_get_bbreg(hw,\n\t\t\tROFDM0_XAAGCCORE1, MASKBYTE0);\n\trtlphy->default_initialgain[1] = rtl_get_bbreg(hw,\n\t\t\tROFDM0_XBAGCCORE1, MASKBYTE0);\n\trtlphy->default_initialgain[2] = rtl_get_bbreg(hw,\n\t\t\tROFDM0_XCAGCCORE1, MASKBYTE0);\n\trtlphy->default_initialgain[3] = rtl_get_bbreg(hw,\n\t\t\tROFDM0_XDAGCCORE1, MASKBYTE0);\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\"Default initial gain (c50=0x%x, c58=0x%x, c60=0x%x, c68=0x%x)\\n\",\n\t\trtlphy->default_initialgain[0],\n\t\trtlphy->default_initialgain[1],\n\t\trtlphy->default_initialgain[2],\n\t\trtlphy->default_initialgain[3]);\n\n\t \n\trtlphy->framesync = rtl_get_bbreg(hw, ROFDM0_RXDETECTOR3, MASKBYTE0);\n\trtlphy->framesync_c34 = rtl_get_bbreg(hw, ROFDM0_RXDETECTOR2,\n\t\t\t\t\t      MASKDWORD);\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\"Default framesync (0x%x) = 0x%x\\n\",\n\t\tROFDM0_RXDETECTOR3, rtlphy->framesync);\n\n}\n\nstatic void _rtl92s_phy_get_txpower_index(struct ieee80211_hw *hw, u8 channel,\n\t\t\t\t\t  u8 *cckpowerlevel, u8 *ofdmpowerlevel)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tu8 index = (channel - 1);\n\n\t \n\t \n\tcckpowerlevel[0] = rtlefuse->txpwrlevel_cck[0][index];\n\t \n\tcckpowerlevel[1] = rtlefuse->txpwrlevel_cck[1][index];\n\n\t \n\tif (rtlphy->rf_type == RF_1T2R || rtlphy->rf_type == RF_1T1R) {\n\t\t \n\t\tofdmpowerlevel[0] = rtlefuse->txpwrlevel_ht40_1s[0][index];\n\t\tofdmpowerlevel[1] = rtlefuse->txpwrlevel_ht40_1s[1][index];\n\t} else if (rtlphy->rf_type == RF_2T2R) {\n\t\t \n\t\tofdmpowerlevel[0] = rtlefuse->txpwrlevel_ht40_2s[0][index];\n\t\tofdmpowerlevel[1] = rtlefuse->txpwrlevel_ht40_2s[1][index];\n\t} else {\n\t\tofdmpowerlevel[0] = 0;\n\t\tofdmpowerlevel[1] = 0;\n\t}\n}\n\nstatic void _rtl92s_phy_ccxpower_indexcheck(struct ieee80211_hw *hw,\n\t\tu8 channel, u8 *cckpowerlevel, u8 *ofdmpowerlevel)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\n\trtlphy->cur_cck_txpwridx = cckpowerlevel[0];\n\trtlphy->cur_ofdm24g_txpwridx = ofdmpowerlevel[0];\n}\n\nvoid rtl92s_phy_set_txpower(struct ieee80211_hw *hw, u8\tchannel)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\t \n\tu8 cckpowerlevel[2], ofdmpowerlevel[2];\n\n\tif (!rtlefuse->txpwr_fromeprom)\n\t\treturn;\n\n\t \n\t_rtl92s_phy_get_txpower_index(hw, channel, &cckpowerlevel[0],\n\t\t\t&ofdmpowerlevel[0]);\n\n\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD,\n\t\t\"Channel-%d, cckPowerLevel (A / B) = 0x%x / 0x%x, ofdmPowerLevel (A / B) = 0x%x / 0x%x\\n\",\n\t\tchannel, cckpowerlevel[0], cckpowerlevel[1],\n\t\tofdmpowerlevel[0], ofdmpowerlevel[1]);\n\n\t_rtl92s_phy_ccxpower_indexcheck(hw, channel, &cckpowerlevel[0],\n\t\t\t&ofdmpowerlevel[0]);\n\n\trtl92s_phy_rf6052_set_ccktxpower(hw, cckpowerlevel[0]);\n\trtl92s_phy_rf6052_set_ofdmtxpower(hw, &ofdmpowerlevel[0], channel);\n\n}\n\nvoid rtl92s_phy_chk_fwcmd_iodone(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu16 pollingcnt = 10000;\n\tu32 tmpvalue;\n\n\t \n\tdo {\n\t\tudelay(10);\n\n\t\ttmpvalue = rtl_read_dword(rtlpriv, WFM5);\n\t\tif (tmpvalue == 0)\n\t\t\tbreak;\n\t} while (--pollingcnt);\n\n\tif (pollingcnt == 0)\n\t\tpr_err(\"Set FW Cmd fail!!\\n\");\n}\n\n\nstatic void _rtl92s_phy_set_fwcmd_io(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tu32 input, current_aid = 0;\n\n\tif (is_hal_stop(rtlhal))\n\t\treturn;\n\n\tif (hal_get_firmwareversion(rtlpriv) < 0x34)\n\t\tgoto skip;\n\t \n\t \n\tswitch (rtlhal->current_fwcmd_io) {\n\tcase FW_CMD_RA_REFRESH_N:\n\t\trtlhal->current_fwcmd_io = FW_CMD_RA_REFRESH_N_COMB;\n\t\tbreak;\n\tcase FW_CMD_RA_REFRESH_BG:\n\t\trtlhal->current_fwcmd_io = FW_CMD_RA_REFRESH_BG_COMB;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\nskip:\n\tswitch (rtlhal->current_fwcmd_io) {\n\tcase FW_CMD_RA_RESET:\n\t\trtl_dbg(rtlpriv, COMP_CMD, DBG_DMESG, \"FW_CMD_RA_RESET\\n\");\n\t\trtl_write_dword(rtlpriv, WFM5, FW_RA_RESET);\n\t\trtl92s_phy_chk_fwcmd_iodone(hw);\n\t\tbreak;\n\tcase FW_CMD_RA_ACTIVE:\n\t\trtl_dbg(rtlpriv, COMP_CMD, DBG_DMESG, \"FW_CMD_RA_ACTIVE\\n\");\n\t\trtl_write_dword(rtlpriv, WFM5, FW_RA_ACTIVE);\n\t\trtl92s_phy_chk_fwcmd_iodone(hw);\n\t\tbreak;\n\tcase FW_CMD_RA_REFRESH_N:\n\t\trtl_dbg(rtlpriv, COMP_CMD, DBG_DMESG, \"FW_CMD_RA_REFRESH_N\\n\");\n\t\tinput = FW_RA_REFRESH;\n\t\trtl_write_dword(rtlpriv, WFM5, input);\n\t\trtl92s_phy_chk_fwcmd_iodone(hw);\n\t\trtl_write_dword(rtlpriv, WFM5, FW_RA_ENABLE_RSSI_MASK);\n\t\trtl92s_phy_chk_fwcmd_iodone(hw);\n\t\tbreak;\n\tcase FW_CMD_RA_REFRESH_BG:\n\t\trtl_dbg(rtlpriv, COMP_CMD, DBG_DMESG,\n\t\t\t\"FW_CMD_RA_REFRESH_BG\\n\");\n\t\trtl_write_dword(rtlpriv, WFM5, FW_RA_REFRESH);\n\t\trtl92s_phy_chk_fwcmd_iodone(hw);\n\t\trtl_write_dword(rtlpriv, WFM5, FW_RA_DISABLE_RSSI_MASK);\n\t\trtl92s_phy_chk_fwcmd_iodone(hw);\n\t\tbreak;\n\tcase FW_CMD_RA_REFRESH_N_COMB:\n\t\trtl_dbg(rtlpriv, COMP_CMD, DBG_DMESG,\n\t\t\t\"FW_CMD_RA_REFRESH_N_COMB\\n\");\n\t\tinput = FW_RA_IOT_N_COMB;\n\t\trtl_write_dword(rtlpriv, WFM5, input);\n\t\trtl92s_phy_chk_fwcmd_iodone(hw);\n\t\tbreak;\n\tcase FW_CMD_RA_REFRESH_BG_COMB:\n\t\trtl_dbg(rtlpriv, COMP_CMD, DBG_DMESG,\n\t\t\t\"FW_CMD_RA_REFRESH_BG_COMB\\n\");\n\t\tinput = FW_RA_IOT_BG_COMB;\n\t\trtl_write_dword(rtlpriv, WFM5, input);\n\t\trtl92s_phy_chk_fwcmd_iodone(hw);\n\t\tbreak;\n\tcase FW_CMD_IQK_ENABLE:\n\t\trtl_dbg(rtlpriv, COMP_CMD, DBG_DMESG, \"FW_CMD_IQK_ENABLE\\n\");\n\t\trtl_write_dword(rtlpriv, WFM5, FW_IQK_ENABLE);\n\t\trtl92s_phy_chk_fwcmd_iodone(hw);\n\t\tbreak;\n\tcase FW_CMD_PAUSE_DM_BY_SCAN:\n\t\t \n\t\trtl_set_bbreg(hw, ROFDM0_XAAGCCORE1, MASKBYTE0, 0x17);\n\t\trtl_set_bbreg(hw, ROFDM0_XBAGCCORE1, MASKBYTE0, 0x17);\n\t\t \n\t\trtl_set_bbreg(hw, RCCK0_CCA, MASKBYTE2, 0x40);\n\t\tbreak;\n\tcase FW_CMD_RESUME_DM_BY_SCAN:\n\t\t \n\t\trtl_set_bbreg(hw, RCCK0_CCA, MASKBYTE2, 0xcd);\n\t\trtl92s_phy_set_txpower(hw, rtlphy->current_channel);\n\t\tbreak;\n\tcase FW_CMD_HIGH_PWR_DISABLE:\n\t\tif (rtlpriv->dm.dm_flag & HAL_DM_HIPWR_DISABLE)\n\t\t\tbreak;\n\n\t\t \n\t\trtl_set_bbreg(hw, ROFDM0_XAAGCCORE1, MASKBYTE0, 0x17);\n\t\trtl_set_bbreg(hw, ROFDM0_XBAGCCORE1, MASKBYTE0, 0x17);\n\t\t \n\t\trtl_set_bbreg(hw, RCCK0_CCA, MASKBYTE2, 0x40);\n\t\tbreak;\n\tcase FW_CMD_HIGH_PWR_ENABLE:\n\t\tif ((rtlpriv->dm.dm_flag & HAL_DM_HIPWR_DISABLE) ||\n\t\t\trtlpriv->dm.dynamic_txpower_enable)\n\t\t\tbreak;\n\n\t\t \n\t\trtl_set_bbreg(hw, RCCK0_CCA, MASKBYTE2, 0xcd);\n\t\tbreak;\n\tcase FW_CMD_LPS_ENTER:\n\t\trtl_dbg(rtlpriv, COMP_CMD, DBG_DMESG, \"FW_CMD_LPS_ENTER\\n\");\n\t\tcurrent_aid = rtlpriv->mac80211.assoc_id;\n\t\trtl_write_dword(rtlpriv, WFM5, (FW_LPS_ENTER |\n\t\t\t\t((current_aid | 0xc000) << 8)));\n\t\trtl92s_phy_chk_fwcmd_iodone(hw);\n\t\t \n\t\tbreak;\n\tcase FW_CMD_LPS_LEAVE:\n\t\trtl_dbg(rtlpriv, COMP_CMD, DBG_DMESG, \"FW_CMD_LPS_LEAVE\\n\");\n\t\trtl_write_dword(rtlpriv, WFM5, FW_LPS_LEAVE);\n\t\trtl92s_phy_chk_fwcmd_iodone(hw);\n\t\tbreak;\n\tcase FW_CMD_ADD_A2_ENTRY:\n\t\trtl_dbg(rtlpriv, COMP_CMD, DBG_DMESG, \"FW_CMD_ADD_A2_ENTRY\\n\");\n\t\trtl_write_dword(rtlpriv, WFM5, FW_ADD_A2_ENTRY);\n\t\trtl92s_phy_chk_fwcmd_iodone(hw);\n\t\tbreak;\n\tcase FW_CMD_CTRL_DM_BY_DRIVER:\n\t\trtl_dbg(rtlpriv, COMP_CMD, DBG_LOUD,\n\t\t\t\"FW_CMD_CTRL_DM_BY_DRIVER\\n\");\n\t\trtl_write_dword(rtlpriv, WFM5, FW_CTRL_DM_BY_DRIVER);\n\t\trtl92s_phy_chk_fwcmd_iodone(hw);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\trtl92s_phy_chk_fwcmd_iodone(hw);\n\n\t \n\trtlhal->set_fwcmd_inprogress = false;\n}\n\nbool rtl92s_phy_set_fw_cmd(struct ieee80211_hw *hw, enum fwcmd_iotype fw_cmdio)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct dig_t *digtable = &rtlpriv->dm_digtable;\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tu32\tfw_param = FW_CMD_IO_PARA_QUERY(rtlpriv);\n\tu16\tfw_cmdmap = FW_CMD_IO_QUERY(rtlpriv);\n\tbool postprocessing = false;\n\n\trtl_dbg(rtlpriv, COMP_CMD, DBG_LOUD,\n\t\t\"Set FW Cmd(%#x), set_fwcmd_inprogress(%d)\\n\",\n\t\tfw_cmdio, rtlhal->set_fwcmd_inprogress);\n\n\tdo {\n\t\t \n\t\t \n\t\tif (hal_get_firmwareversion(rtlpriv) >= 0x35) {\n\t\t\tswitch (fw_cmdio) {\n\t\t\tcase FW_CMD_RA_REFRESH_N:\n\t\t\t\tfw_cmdio = FW_CMD_RA_REFRESH_N_COMB;\n\t\t\t\tbreak;\n\t\t\tcase FW_CMD_RA_REFRESH_BG:\n\t\t\t\tfw_cmdio = FW_CMD_RA_REFRESH_BG_COMB;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif ((fw_cmdio == FW_CMD_IQK_ENABLE) ||\n\t\t\t    (fw_cmdio == FW_CMD_RA_REFRESH_N) ||\n\t\t\t    (fw_cmdio == FW_CMD_RA_REFRESH_BG)) {\n\t\t\t\tpostprocessing = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (hal_get_firmwareversion(rtlpriv) >= 0x3E) {\n\t\t\tif (fw_cmdio == FW_CMD_CTRL_DM_BY_DRIVER)\n\t\t\t\tfw_cmdio = FW_CMD_CTRL_DM_BY_DRIVER_NEW;\n\t\t}\n\n\n\t\t \n\t\tswitch (fw_cmdio) {\n\t\tcase FW_CMD_RA_INIT:\n\t\t\trtl_dbg(rtlpriv, COMP_CMD, DBG_LOUD, \"RA init!!\\n\");\n\t\t\tfw_cmdmap |= FW_RA_INIT_CTL;\n\t\t\tFW_CMD_IO_SET(rtlpriv, fw_cmdmap);\n\t\t\t \n\t\t\tFW_CMD_IO_CLR(rtlpriv, FW_RA_INIT_CTL);\n\t\t\tbreak;\n\t\tcase FW_CMD_DIG_DISABLE:\n\t\t\trtl_dbg(rtlpriv, COMP_CMD, DBG_LOUD,\n\t\t\t\t\"Set DIG disable!!\\n\");\n\t\t\tfw_cmdmap &= ~FW_DIG_ENABLE_CTL;\n\t\t\tFW_CMD_IO_SET(rtlpriv, fw_cmdmap);\n\t\t\tbreak;\n\t\tcase FW_CMD_DIG_ENABLE:\n\t\tcase FW_CMD_DIG_RESUME:\n\t\t\tif (!(rtlpriv->dm.dm_flag & HAL_DM_DIG_DISABLE)) {\n\t\t\t\trtl_dbg(rtlpriv, COMP_CMD, DBG_LOUD,\n\t\t\t\t\t\"Set DIG enable or resume!!\\n\");\n\t\t\t\tfw_cmdmap |= (FW_DIG_ENABLE_CTL | FW_SS_CTL);\n\t\t\t\tFW_CMD_IO_SET(rtlpriv, fw_cmdmap);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FW_CMD_DIG_HALT:\n\t\t\trtl_dbg(rtlpriv, COMP_CMD, DBG_LOUD,\n\t\t\t\t\"Set DIG halt!!\\n\");\n\t\t\tfw_cmdmap &= ~(FW_DIG_ENABLE_CTL | FW_SS_CTL);\n\t\t\tFW_CMD_IO_SET(rtlpriv, fw_cmdmap);\n\t\t\tbreak;\n\t\tcase FW_CMD_TXPWR_TRACK_THERMAL: {\n\t\t\tu8\tthermalval = 0;\n\t\t\tfw_cmdmap |= FW_PWR_TRK_CTL;\n\n\t\t\t \n\t\t\tfw_param &= FW_PWR_TRK_PARAM_CLR;\n\n\t\t\tthermalval = rtlpriv->dm.thermalvalue;\n\t\t\tfw_param |= ((thermalval << 24) |\n\t\t\t\t     (rtlefuse->thermalmeter[0] << 16));\n\n\t\t\trtl_dbg(rtlpriv, COMP_CMD, DBG_LOUD,\n\t\t\t\t\"Set TxPwr tracking!! FwCmdMap(%#x), FwParam(%#x)\\n\",\n\t\t\t\tfw_cmdmap, fw_param);\n\n\t\t\tFW_CMD_PARA_SET(rtlpriv, fw_param);\n\t\t\tFW_CMD_IO_SET(rtlpriv, fw_cmdmap);\n\n\t\t\t \n\t\t\tFW_CMD_IO_CLR(rtlpriv, FW_PWR_TRK_CTL);\n\t\t\t}\n\t\t\tbreak;\n\t\t \n\t\tcase FW_CMD_RA_REFRESH_N_COMB:\n\t\t\tfw_cmdmap |= FW_RA_N_CTL;\n\n\t\t\t \n\t\t\tfw_cmdmap &= ~(FW_RA_BG_CTL | FW_RA_INIT_CTL);\n\n\t\t\t \n\t\t\tfw_param &= FW_RA_PARAM_CLR;\n\n\t\t\trtl_dbg(rtlpriv, COMP_CMD, DBG_LOUD,\n\t\t\t\t\"[FW CMD] [New Version] Set RA/IOT Comb in n mode!! FwCmdMap(%#x), FwParam(%#x)\\n\",\n\t\t\t\tfw_cmdmap, fw_param);\n\n\t\t\tFW_CMD_PARA_SET(rtlpriv, fw_param);\n\t\t\tFW_CMD_IO_SET(rtlpriv, fw_cmdmap);\n\n\t\t\t \n\t\t\tFW_CMD_IO_CLR(rtlpriv, FW_RA_N_CTL);\n\t\t\tbreak;\n\t\tcase FW_CMD_RA_REFRESH_BG_COMB:\n\t\t\tfw_cmdmap |= FW_RA_BG_CTL;\n\n\t\t\t \n\t\t\tfw_cmdmap &= ~(FW_RA_N_CTL | FW_RA_INIT_CTL);\n\t\t\t \n\t\t\tfw_param &= FW_RA_PARAM_CLR;\n\n\t\t\tFW_CMD_PARA_SET(rtlpriv, fw_param);\n\t\t\tFW_CMD_IO_SET(rtlpriv, fw_cmdmap);\n\n\t\t\t \n\t\t\tFW_CMD_IO_CLR(rtlpriv, FW_RA_BG_CTL);\n\t\t\tbreak;\n\t\tcase FW_CMD_IQK_ENABLE:\n\t\t\tfw_cmdmap |= FW_IQK_CTL;\n\t\t\tFW_CMD_IO_SET(rtlpriv, fw_cmdmap);\n\t\t\t \n\t\t\tFW_CMD_IO_CLR(rtlpriv, FW_IQK_CTL);\n\t\t\tbreak;\n\t\t \n\t\tcase FW_CMD_CTRL_DM_BY_DRIVER_NEW:\n\t\t\tfw_cmdmap |= FW_DRIVER_CTRL_DM_CTL;\n\t\t\tFW_CMD_IO_SET(rtlpriv, fw_cmdmap);\n\t\t\tbreak;\n\t\t \n\t\tcase FW_CMD_RESUME_DM_BY_SCAN:\n\t\t\tfw_cmdmap |= (FW_DIG_ENABLE_CTL |\n\t\t\t\t      FW_HIGH_PWR_ENABLE_CTL |\n\t\t\t\t      FW_SS_CTL);\n\n\t\t\tif (rtlpriv->dm.dm_flag & HAL_DM_DIG_DISABLE ||\n\t\t\t\t!digtable->dig_enable_flag)\n\t\t\t\tfw_cmdmap &= ~FW_DIG_ENABLE_CTL;\n\n\t\t\tif ((rtlpriv->dm.dm_flag & HAL_DM_HIPWR_DISABLE) ||\n\t\t\t    rtlpriv->dm.dynamic_txpower_enable)\n\t\t\t\tfw_cmdmap &= ~FW_HIGH_PWR_ENABLE_CTL;\n\n\t\t\tif ((digtable->dig_ext_port_stage ==\n\t\t\t    DIG_EXT_PORT_STAGE_0) ||\n\t\t\t    (digtable->dig_ext_port_stage ==\n\t\t\t    DIG_EXT_PORT_STAGE_1))\n\t\t\t\tfw_cmdmap &= ~FW_DIG_ENABLE_CTL;\n\n\t\t\tFW_CMD_IO_SET(rtlpriv, fw_cmdmap);\n\t\t\tpostprocessing = true;\n\t\t\tbreak;\n\t\tcase FW_CMD_PAUSE_DM_BY_SCAN:\n\t\t\tfw_cmdmap &= ~(FW_DIG_ENABLE_CTL |\n\t\t\t\t       FW_HIGH_PWR_ENABLE_CTL |\n\t\t\t\t       FW_SS_CTL);\n\t\t\tFW_CMD_IO_SET(rtlpriv, fw_cmdmap);\n\t\t\tpostprocessing = true;\n\t\t\tbreak;\n\t\tcase FW_CMD_HIGH_PWR_DISABLE:\n\t\t\tfw_cmdmap &= ~FW_HIGH_PWR_ENABLE_CTL;\n\t\t\tFW_CMD_IO_SET(rtlpriv, fw_cmdmap);\n\t\t\tpostprocessing = true;\n\t\t\tbreak;\n\t\tcase FW_CMD_HIGH_PWR_ENABLE:\n\t\t\tif (!(rtlpriv->dm.dm_flag & HAL_DM_HIPWR_DISABLE) &&\n\t\t\t    !rtlpriv->dm.dynamic_txpower_enable) {\n\t\t\t\tfw_cmdmap |= (FW_HIGH_PWR_ENABLE_CTL |\n\t\t\t\t\t      FW_SS_CTL);\n\t\t\t\tFW_CMD_IO_SET(rtlpriv, fw_cmdmap);\n\t\t\t\tpostprocessing = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase FW_CMD_DIG_MODE_FA:\n\t\t\tfw_cmdmap |= FW_FA_CTL;\n\t\t\tFW_CMD_IO_SET(rtlpriv, fw_cmdmap);\n\t\t\tbreak;\n\t\tcase FW_CMD_DIG_MODE_SS:\n\t\t\tfw_cmdmap &= ~FW_FA_CTL;\n\t\t\tFW_CMD_IO_SET(rtlpriv, fw_cmdmap);\n\t\t\tbreak;\n\t\tcase FW_CMD_PAPE_CONTROL:\n\t\t\trtl_dbg(rtlpriv, COMP_CMD, DBG_LOUD,\n\t\t\t\t\"[FW CMD] Set PAPE Control\\n\");\n\t\t\tfw_cmdmap &= ~FW_PAPE_CTL_BY_SW_HW;\n\n\t\t\tFW_CMD_IO_SET(rtlpriv, fw_cmdmap);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tpostprocessing = true;\n\t\t\tbreak;\n\t\t}\n\t} while (false);\n\n\t \n\tif (postprocessing && !rtlhal->set_fwcmd_inprogress) {\n\t\trtlhal->set_fwcmd_inprogress = true;\n\t\t \n\t\trtlhal->current_fwcmd_io = fw_cmdio;\n\t} else {\n\t\treturn false;\n\t}\n\n\t_rtl92s_phy_set_fwcmd_io(hw);\n\treturn true;\n}\n\nstatic\tvoid _rtl92s_phy_check_ephy_switchready(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32\tdelay = 100;\n\tu8\tregu1;\n\n\tregu1 = rtl_read_byte(rtlpriv, 0x554);\n\twhile ((regu1 & BIT(5)) && (delay > 0)) {\n\t\tregu1 = rtl_read_byte(rtlpriv, 0x554);\n\t\tdelay--;\n\t\t \n\t\tudelay(50);\n\t}\n}\n\nvoid rtl92s_phy_switch_ephy_parameter(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\n\t \n\trtl_write_dword(rtlpriv, 0x540, 0x73c11);\n\trtl_write_dword(rtlpriv, 0x548, 0x2407c);\n\n\t \n\trtl_write_word(rtlpriv, 0x550, 0x1000);\n\trtl_write_byte(rtlpriv, 0x554, 0x20);\n\t_rtl92s_phy_check_ephy_switchready(hw);\n\n\trtl_write_word(rtlpriv, 0x550, 0xa0eb);\n\trtl_write_byte(rtlpriv, 0x554, 0x3e);\n\t_rtl92s_phy_check_ephy_switchready(hw);\n\n\trtl_write_word(rtlpriv, 0x550, 0xff80);\n\trtl_write_byte(rtlpriv, 0x554, 0x39);\n\t_rtl92s_phy_check_ephy_switchready(hw);\n\n\t \n\tif (ppsc->support_aspm && !ppsc->support_backdoor)\n\t\trtl_write_byte(rtlpriv, 0x560, 0x40);\n\telse\n\t\trtl_write_byte(rtlpriv, 0x560, 0x00);\n\n}\n\nvoid rtl92s_phy_set_beacon_hwreg(struct ieee80211_hw *hw, u16 beaconinterval)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 new_bcn_num = 0;\n\n\tif (hal_get_firmwareversion(rtlpriv) >= 0x33) {\n\t\t \n\t\trtl_write_dword(rtlpriv, WFM5, 0xF1000000 |\n\t\t\t\t(beaconinterval << 8));\n\t} else {\n\t\tnew_bcn_num = beaconinterval * 32 - 64;\n\t\trtl_write_dword(rtlpriv, WFM3 + 4, new_bcn_num);\n\t\trtl_write_dword(rtlpriv, WFM3, 0xB026007C);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}