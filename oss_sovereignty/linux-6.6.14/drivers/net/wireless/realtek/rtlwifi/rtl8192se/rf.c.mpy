{
  "module_name": "rf.c",
  "hash_id": "d9513c727fed45517415e12580f7f54baff7183ac3189fb4b78bf4a58625445b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtlwifi/rtl8192se/rf.c",
  "human_readable_source": "\n \n\n#include \"../wifi.h\"\n#include \"reg.h\"\n#include \"def.h\"\n#include \"phy.h\"\n#include \"rf.h\"\n#include \"dm.h\"\n\n\nstatic void _rtl92s_get_powerbase(struct ieee80211_hw *hw, u8 *p_pwrlevel,\n\t\t\t\t  u8 chnl, u32 *ofdmbase, u32 *mcsbase,\n\t\t\t\t  u8 *p_final_pwridx)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tu32 pwrbase0, pwrbase1;\n\tu8 legacy_pwrdiff = 0, ht20_pwrdiff = 0;\n\tu8 i, pwrlevel[4];\n\n\tfor (i = 0; i < 2; i++)\n\t\tpwrlevel[i] = p_pwrlevel[i];\n\n\t \n\tif (rtlefuse->eeprom_version < 2) {\n\t\tpwrbase0 = pwrlevel[0] + (rtlefuse->legacy_ht_txpowerdiff & 0xf);\n\t} else {\n\t\tlegacy_pwrdiff = rtlefuse->txpwr_legacyhtdiff\n\t\t\t\t\t\t[RF90_PATH_A][chnl - 1];\n\n\t\t \n\t\tpwrbase0 = pwrlevel[0] + legacy_pwrdiff;\n\t}\n\n\tpwrbase0 = (pwrbase0 << 24) | (pwrbase0 << 16) | (pwrbase0 << 8) |\n\t\t    pwrbase0;\n\t*ofdmbase = pwrbase0;\n\n\t \n\tif (rtlefuse->eeprom_version >= 2) {\n\t\t \n\t\tif (rtlphy->current_chan_bw == HT_CHANNEL_WIDTH_20) {\n\t\t\tfor (i = 0; i < 2; i++) {\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tht20_pwrdiff = rtlefuse->txpwr_ht20diff\n\t\t\t\t\t\t\t[i][chnl - 1];\n\n\t\t\t\tif (ht20_pwrdiff < 8)  \n\t\t\t\t\tpwrlevel[i] += ht20_pwrdiff;\n\t\t\t\telse  \n\t\t\t\t\tpwrlevel[i] -= (16 - ht20_pwrdiff);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tpwrbase1 = pwrlevel[0];\n\tpwrbase1 = (pwrbase1 << 24) | (pwrbase1 << 16) | (pwrbase1 << 8) |\n\t\t\t\tpwrbase1;\n\t*mcsbase = pwrbase1;\n\n\t \n\tp_final_pwridx[0] = pwrlevel[0];\n\tp_final_pwridx[1] = pwrlevel[1];\n\n\tswitch (rtlefuse->eeprom_regulatory) {\n\tcase 3:\n\t\t \n\t\tif (rtlphy->current_chan_bw == HT_CHANNEL_WIDTH_20_40) {\n\t\t\tp_final_pwridx[0] += rtlefuse->pwrgroup_ht40\n\t\t\t\t\t\t[RF90_PATH_A][\n\t\t\t\t\t\tchnl - 1];\n\t\t\tp_final_pwridx[1] += rtlefuse->pwrgroup_ht40\n\t\t\t\t\t\t[RF90_PATH_B][\n\t\t\t\t\t\tchnl - 1];\n\t\t} else {\n\t\t\tp_final_pwridx[0] += rtlefuse->pwrgroup_ht20\n\t\t\t\t\t\t[RF90_PATH_A][\n\t\t\t\t\t\tchnl - 1];\n\t\t\tp_final_pwridx[1] += rtlefuse->pwrgroup_ht20\n\t\t\t\t\t\t[RF90_PATH_B][\n\t\t\t\t\t\tchnl - 1];\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (rtlphy->current_chan_bw == HT_CHANNEL_WIDTH_20_40) {\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD,\n\t\t\t\"40MHz finalpwr_idx (A / B) = 0x%x / 0x%x\\n\",\n\t\t\tp_final_pwridx[0], p_final_pwridx[1]);\n\t} else {\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD,\n\t\t\t\"20MHz finalpwr_idx (A / B) = 0x%x / 0x%x\\n\",\n\t\t\tp_final_pwridx[0], p_final_pwridx[1]);\n\t}\n}\n\nstatic void _rtl92s_set_antennadiff(struct ieee80211_hw *hw,\n\t\t\t\t    u8 *p_final_pwridx)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\ts8 ant_pwr_diff = 0;\n\tu32\tu4reg_val = 0;\n\n\tif (rtlphy->rf_type == RF_2T2R) {\n\t\tant_pwr_diff = p_final_pwridx[1] - p_final_pwridx[0];\n\n\t\t \n\t\tif (ant_pwr_diff > 7)\n\t\t\tant_pwr_diff = 7;\n\t\tif (ant_pwr_diff < -8)\n\t\t\tant_pwr_diff = -8;\n\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD,\n\t\t\t\"Antenna Diff from RF-B to RF-A = %d (0x%x)\\n\",\n\t\t\tant_pwr_diff, ant_pwr_diff & 0xf);\n\n\t\tant_pwr_diff &= 0xf;\n\t}\n\n\t \n\trtlefuse->antenna_txpwdiff[2] = 0; \n\trtlefuse->antenna_txpwdiff[1] = 0; \n\trtlefuse->antenna_txpwdiff[0] = (u8)(ant_pwr_diff);\t \n\n\tu4reg_val = rtlefuse->antenna_txpwdiff[2] << 8 |\n\t\t\t\trtlefuse->antenna_txpwdiff[1] << 4 |\n\t\t\t\trtlefuse->antenna_txpwdiff[0];\n\n\trtl_set_bbreg(hw, RFPGA0_TXGAINSTAGE, (BXBTXAGC | BXCTXAGC | BXDTXAGC),\n\t\t      u4reg_val);\n\n\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD, \"Write BCD-Diff(0x%x) = 0x%x\\n\",\n\t\tRFPGA0_TXGAINSTAGE, u4reg_val);\n}\n\nstatic void _rtl92s_get_txpower_writeval_byregulatory(struct ieee80211_hw *hw,\n\t\t\t\t\t\t      u8 chnl, u8 index,\n\t\t\t\t\t\t      u32 pwrbase0,\n\t\t\t\t\t\t      u32 pwrbase1,\n\t\t\t\t\t\t      u32 *p_outwrite_val)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tu8 i, chnlgroup, pwrdiff_limit[4];\n\tu32 writeval, customer_limit;\n\n\t \n\tswitch (rtlefuse->eeprom_regulatory) {\n\tcase 0:\n\t\t \n\t\tchnlgroup = 0;\n\n\t\twriteval = rtlphy->mcs_offset[chnlgroup][index] +\n\t\t\t\t((index < 2) ? pwrbase0 : pwrbase1);\n\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD,\n\t\t\t\"RTK better performance, writeval = 0x%x\\n\", writeval);\n\t\tbreak;\n\tcase 1:\n\t\t \n\t\tif (rtlphy->current_chan_bw == HT_CHANNEL_WIDTH_20_40) {\n\t\t\twriteval = ((index < 2) ? pwrbase0 : pwrbase1);\n\n\t\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD,\n\t\t\t\t\"Realtek regulatory, 40MHz, writeval = 0x%x\\n\",\n\t\t\t\twriteval);\n\t\t} else {\n\t\t\tchnlgroup = 0;\n\n\t\t\tif (rtlphy->pwrgroup_cnt >= 3) {\n\t\t\t\tif (chnl <= 3)\n\t\t\t\t\tchnlgroup = 0;\n\t\t\t\telse if (chnl >= 4 && chnl <= 8)\n\t\t\t\t\tchnlgroup = 1;\n\t\t\t\telse if (chnl > 8)\n\t\t\t\t\tchnlgroup = 2;\n\t\t\t\tif (rtlphy->pwrgroup_cnt == 4)\n\t\t\t\t\tchnlgroup++;\n\t\t\t}\n\n\t\t\twriteval = rtlphy->mcs_offset[chnlgroup][index]\n\t\t\t\t\t+ ((index < 2) ?\n\t\t\t\t\tpwrbase0 : pwrbase1);\n\n\t\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD,\n\t\t\t\t\"Realtek regulatory, 20MHz, writeval = 0x%x\\n\",\n\t\t\t\twriteval);\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\t \n\t\twriteval = ((index < 2) ? pwrbase0 : pwrbase1);\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD,\n\t\t\t\"Better regulatory, writeval = 0x%x\\n\", writeval);\n\t\tbreak;\n\tcase 3:\n\t\t \n\t\tchnlgroup = 0;\n\n\t\tif (rtlphy->current_chan_bw == HT_CHANNEL_WIDTH_20_40) {\n\t\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD,\n\t\t\t\t\"customer's limit, 40MHz = 0x%x\\n\",\n\t\t\t\trtlefuse->pwrgroup_ht40\n\t\t\t\t[RF90_PATH_A][chnl - 1]);\n\t\t} else {\n\t\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD,\n\t\t\t\t\"customer's limit, 20MHz = 0x%x\\n\",\n\t\t\t\trtlefuse->pwrgroup_ht20\n\t\t\t\t[RF90_PATH_A][chnl - 1]);\n\t\t}\n\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tpwrdiff_limit[i] = (u8)((rtlphy->mcs_offset\n\t\t\t\t[chnlgroup][index] & (0x7f << (i * 8)))\n\t\t\t\t>> (i * 8));\n\n\t\t\tif (rtlphy->current_chan_bw ==\n\t\t\t    HT_CHANNEL_WIDTH_20_40) {\n\t\t\t\tif (pwrdiff_limit[i] >\n\t\t\t\t    rtlefuse->pwrgroup_ht40\n\t\t\t\t    [RF90_PATH_A][chnl - 1]) {\n\t\t\t\t\tpwrdiff_limit[i] =\n\t\t\t\t\t  rtlefuse->pwrgroup_ht40\n\t\t\t\t\t  [RF90_PATH_A][chnl - 1];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (pwrdiff_limit[i] >\n\t\t\t\t    rtlefuse->pwrgroup_ht20\n\t\t\t\t    [RF90_PATH_A][chnl - 1]) {\n\t\t\t\t\tpwrdiff_limit[i] =\n\t\t\t\t\t    rtlefuse->pwrgroup_ht20\n\t\t\t\t\t    [RF90_PATH_A][chnl - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcustomer_limit = (pwrdiff_limit[3] << 24) |\n\t\t\t\t(pwrdiff_limit[2] << 16) |\n\t\t\t\t(pwrdiff_limit[1] << 8) |\n\t\t\t\t(pwrdiff_limit[0]);\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD,\n\t\t\t\"Customer's limit = 0x%x\\n\", customer_limit);\n\n\t\twriteval = customer_limit + ((index < 2) ?\n\t\t\t\t\t     pwrbase0 : pwrbase1);\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD,\n\t\t\t\"Customer, writeval = 0x%x\\n\", writeval);\n\t\tbreak;\n\tdefault:\n\t\tchnlgroup = 0;\n\t\twriteval = rtlphy->mcs_offset[chnlgroup][index] +\n\t\t\t\t((index < 2) ? pwrbase0 : pwrbase1);\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD,\n\t\t\t\"RTK better performance, writeval = 0x%x\\n\", writeval);\n\t\tbreak;\n\t}\n\n\tif (rtlpriv->dm.dynamic_txhighpower_lvl == TX_HIGH_PWR_LEVEL_LEVEL1)\n\t\twriteval = 0x10101010;\n\telse if (rtlpriv->dm.dynamic_txhighpower_lvl ==\n\t\t TX_HIGH_PWR_LEVEL_LEVEL2)\n\t\twriteval = 0x0;\n\n\t*p_outwrite_val = writeval;\n\n}\n\nstatic void _rtl92s_write_ofdm_powerreg(struct ieee80211_hw *hw,\n\t\t\t\t\tu8 index, u32 val)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tu16 regoffset[6] = {0xe00, 0xe04, 0xe10, 0xe14, 0xe18, 0xe1c};\n\tu8 i, rfa_pwr[4];\n\tu8 rfa_lower_bound = 0, rfa_upper_bound = 0, rf_pwr_diff = 0;\n\tu32 writeval = val;\n\n\t \n\tif (rtlphy->rf_type == RF_2T2R) {\n\t\trf_pwr_diff = rtlefuse->antenna_txpwdiff[0];\n\n\t\t \n\t\tif (rf_pwr_diff >= 8) {\n\t\t\t \n\t\t\trfa_lower_bound = 0x10 - rf_pwr_diff;\n\t\t \n\t\t} else {\n\t\t\trfa_upper_bound = RF6052_MAX_TX_PWR - rf_pwr_diff;\n\t\t}\n\t}\n\n\tfor (i = 0; i < 4; i++) {\n\t\trfa_pwr[i] = (u8)((writeval & (0x7f << (i * 8))) >> (i * 8));\n\t\tif (rfa_pwr[i]  > RF6052_MAX_TX_PWR)\n\t\t\trfa_pwr[i]  = RF6052_MAX_TX_PWR;\n\n\t\t \n\t\tif (rtlphy->rf_type == RF_2T2R) {\n\t\t\t \n\t\t\tif (rf_pwr_diff >= 8) {\n\t\t\t\t \n\t\t\t\tif (rfa_pwr[i] < rfa_lower_bound)\n\t\t\t\t\trfa_pwr[i] = rfa_lower_bound;\n\t\t\t \n\t\t\t} else if (rf_pwr_diff >= 1) {\n\t\t\t\t \n\t\t\t\tif (rfa_pwr[i] > rfa_upper_bound)\n\t\t\t\t\trfa_pwr[i] = rfa_upper_bound;\n\t\t\t}\n\t\t}\n\n\t}\n\n\twriteval = (rfa_pwr[3] << 24) | (rfa_pwr[2] << 16) | (rfa_pwr[1] << 8) |\n\t\t\t\trfa_pwr[0];\n\n\trtl_set_bbreg(hw, regoffset[index], 0x7f7f7f7f, writeval);\n}\n\nvoid rtl92s_phy_rf6052_set_ofdmtxpower(struct ieee80211_hw *hw,\n\t\t\t\t       u8 *p_pwrlevel, u8 chnl)\n{\n\tu32 writeval, pwrbase0, pwrbase1;\n\tu8 index = 0;\n\tu8 finalpwr_idx[4];\n\n\t_rtl92s_get_powerbase(hw, p_pwrlevel, chnl, &pwrbase0, &pwrbase1,\n\t\t\t&finalpwr_idx[0]);\n\t_rtl92s_set_antennadiff(hw, &finalpwr_idx[0]);\n\n\tfor (index = 0; index < 6; index++) {\n\t\t_rtl92s_get_txpower_writeval_byregulatory(hw, chnl, index,\n\t\t\t\tpwrbase0, pwrbase1, &writeval);\n\n\t\t_rtl92s_write_ofdm_powerreg(hw, index, writeval);\n\t}\n}\n\nvoid rtl92s_phy_rf6052_set_ccktxpower(struct ieee80211_hw *hw, u8 pwrlevel)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tu32 txagc = 0;\n\tbool dont_inc_cck_or_turboscanoff = false;\n\n\tif (((rtlefuse->eeprom_version >= 2) &&\n\t      (rtlefuse->txpwr_safetyflag == 1)) ||\n\t      ((rtlefuse->eeprom_version >= 2) &&\n\t      (rtlefuse->eeprom_regulatory != 0)))\n\t\tdont_inc_cck_or_turboscanoff = true;\n\n\tif (mac->act_scanning) {\n\t\ttxagc = 0x3f;\n\t\tif (dont_inc_cck_or_turboscanoff)\n\t\t\ttxagc = pwrlevel;\n\t} else {\n\t\ttxagc = pwrlevel;\n\n\t\tif (rtlpriv->dm.dynamic_txhighpower_lvl ==\n\t\t    TX_HIGH_PWR_LEVEL_LEVEL1)\n\t\t\ttxagc = 0x10;\n\t\telse if (rtlpriv->dm.dynamic_txhighpower_lvl ==\n\t\t\tTX_HIGH_PWR_LEVEL_LEVEL2)\n\t\t\ttxagc = 0x0;\n\t}\n\n\tif (txagc > RF6052_MAX_TX_PWR)\n\t\ttxagc = RF6052_MAX_TX_PWR;\n\n\trtl_set_bbreg(hw, RTXAGC_CCK_MCS32, BTX_AGCRATECCK, txagc);\n\n}\n\nbool rtl92s_phy_rf6052_config(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tu32 u4reg_val = 0;\n\tu8 rfpath;\n\tbool rtstatus = true;\n\tstruct bb_reg_def *pphyreg;\n\n\t \n\tfor (rfpath = 0; rfpath < rtlphy->num_total_rfpath; rfpath++) {\n\n\t\tpphyreg = &rtlphy->phyreg_def[rfpath];\n\n\t\t \n\t\tswitch (rfpath) {\n\t\tcase RF90_PATH_A:\n\t\tcase RF90_PATH_C:\n\t\t\tu4reg_val = rtl92s_phy_query_bb_reg(hw,\n\t\t\t\t\t\t\t    pphyreg->rfintfs,\n\t\t\t\t\t\t\t    BRFSI_RFENV);\n\t\t\tbreak;\n\t\tcase RF90_PATH_B:\n\t\tcase RF90_PATH_D:\n\t\t\tu4reg_val = rtl92s_phy_query_bb_reg(hw,\n\t\t\t\t\t\t\t    pphyreg->rfintfs,\n\t\t\t\t\t\t\t    BRFSI_RFENV << 16);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\trtl92s_phy_set_bb_reg(hw, pphyreg->rfintfe,\n\t\t\t\t      BRFSI_RFENV << 16, 0x1);\n\n\t\t \n\t\trtl92s_phy_set_bb_reg(hw, pphyreg->rfintfo, BRFSI_RFENV, 0x1);\n\n\t\t \n\t\trtl92s_phy_set_bb_reg(hw, pphyreg->rfhssi_para2,\n\t\t\t\tB3WIRE_ADDRESSLENGTH, 0x0);\n\t\trtl92s_phy_set_bb_reg(hw, pphyreg->rfhssi_para2,\n\t\t\t\tB3WIRE_DATALENGTH, 0x0);\n\n\t\t \n\t\tswitch (rfpath) {\n\t\tcase RF90_PATH_A:\n\t\t\trtstatus = rtl92s_phy_config_rf(hw,\n\t\t\t\t\t\t(enum radio_path)rfpath);\n\t\t\tbreak;\n\t\tcase RF90_PATH_B:\n\t\t\trtstatus = rtl92s_phy_config_rf(hw,\n\t\t\t\t\t\t(enum radio_path)rfpath);\n\t\t\tbreak;\n\t\tcase RF90_PATH_C:\n\t\t\tbreak;\n\t\tcase RF90_PATH_D:\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tswitch (rfpath) {\n\t\tcase RF90_PATH_A:\n\t\tcase RF90_PATH_C:\n\t\t\trtl92s_phy_set_bb_reg(hw, pphyreg->rfintfs, BRFSI_RFENV,\n\t\t\t\t\t      u4reg_val);\n\t\t\tbreak;\n\t\tcase RF90_PATH_B:\n\t\tcase RF90_PATH_D:\n\t\t\trtl92s_phy_set_bb_reg(hw, pphyreg->rfintfs,\n\t\t\t\t\t      BRFSI_RFENV << 16,\n\t\t\t\t\t      u4reg_val);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!rtstatus) {\n\t\t\tpr_err(\"Radio[%d] Fail!!\\n\", rfpath);\n\t\t\tgoto fail;\n\t\t}\n\n\t}\n\n\treturn rtstatus;\n\nfail:\n\treturn rtstatus;\n}\n\nvoid rtl92s_phy_rf6052_set_bandwidth(struct ieee80211_hw *hw, u8 bandwidth)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\n\tswitch (bandwidth) {\n\tcase HT_CHANNEL_WIDTH_20:\n\t\trtlphy->rfreg_chnlval[0] = ((rtlphy->rfreg_chnlval[0] &\n\t\t\t\t\t   0xfffff3ff) | 0x0400);\n\t\trtl_set_rfreg(hw, RF90_PATH_A, RF_CHNLBW, RFREG_OFFSET_MASK,\n\t\t\t\t\trtlphy->rfreg_chnlval[0]);\n\t\tbreak;\n\tcase HT_CHANNEL_WIDTH_20_40:\n\t\trtlphy->rfreg_chnlval[0] = ((rtlphy->rfreg_chnlval[0] &\n\t\t\t\t\t    0xfffff3ff));\n\t\trtl_set_rfreg(hw, RF90_PATH_A, RF_CHNLBW, RFREG_OFFSET_MASK,\n\t\t\t\t\trtlphy->rfreg_chnlval[0]);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"unknown bandwidth: %#X\\n\", bandwidth);\n\t\tbreak;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}