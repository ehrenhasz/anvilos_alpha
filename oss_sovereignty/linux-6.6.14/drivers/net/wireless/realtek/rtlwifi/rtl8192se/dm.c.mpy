{
  "module_name": "dm.c",
  "hash_id": "96a5effe015f21a8f5a405cc708384796b567999d4204fe3bb2e776201003a44",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtlwifi/rtl8192se/dm.c",
  "human_readable_source": "\n \n\n#include \"../wifi.h\"\n#include \"../base.h\"\n#include \"../core.h\"\n#include \"reg.h\"\n#include \"def.h\"\n#include \"phy.h\"\n#include \"dm.h\"\n#include \"fw.h\"\n\nstatic const u32 edca_setting_dl[PEER_MAX] = {\n\t0xa44f,\t\t \n\t0x5ea44f,\t \n\t0x5ea44f,\t \n\t0xa630,\t\t \n\t0xa44f,\t\t \n\t0xa630,\t\t \n\t0xa630,\t\t \n\t0xa42b,\t\t \n};\n\nstatic const u32 edca_setting_dl_gmode[PEER_MAX] = {\n\t0x4322,\t\t \n\t0xa44f,\t\t \n\t0x5ea44f,\t \n\t0xa42b,\t\t \n\t0x5e4322,\t \n\t0x4322,\t\t \n\t0xa430,\t\t \n\t0x5ea44f,\t \n};\n\nstatic const u32 edca_setting_ul[PEER_MAX] = {\n\t0x5e4322,\t \n\t0xa44f,\t\t \n\t0x5ea44f,\t \n\t0x5ea322,\t \n\t0x5ea422,\t \n\t0x5ea322,\t \n\t0x3ea44f,\t \n\t0x5ea44f,\t \n};\n\nstatic void _rtl92s_dm_check_edca_turbo(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\n\tstatic u64 last_txok_cnt;\n\tstatic u64 last_rxok_cnt;\n\tu64 cur_txok_cnt = 0;\n\tu64 cur_rxok_cnt = 0;\n\n\tu32 edca_be_ul = edca_setting_ul[mac->vendor];\n\tu32 edca_be_dl = edca_setting_dl[mac->vendor];\n\tu32 edca_gmode = edca_setting_dl_gmode[mac->vendor];\n\n\tif (mac->link_state != MAC80211_LINKED) {\n\t\trtlpriv->dm.current_turbo_edca = false;\n\t\tgoto dm_checkedcaturbo_exit;\n\t}\n\n\tif ((!rtlpriv->dm.is_any_nonbepkts) &&\n\t    (!rtlpriv->dm.disable_framebursting)) {\n\t\tcur_txok_cnt = rtlpriv->stats.txbytesunicast - last_txok_cnt;\n\t\tcur_rxok_cnt = rtlpriv->stats.rxbytesunicast - last_rxok_cnt;\n\n\t\tif (rtlpriv->phy.rf_type == RF_1T2R) {\n\t\t\tif (cur_txok_cnt > 4 * cur_rxok_cnt) {\n\t\t\t\t \n\t\t\t\tif (rtlpriv->dm.is_cur_rdlstate ||\n\t\t\t\t\t!rtlpriv->dm.current_turbo_edca) {\n\t\t\t\t\trtl_write_dword(rtlpriv, EDCAPARA_BE,\n\t\t\t\t\t\t\tedca_be_ul);\n\t\t\t\t\trtlpriv->dm.is_cur_rdlstate = false;\n\t\t\t\t}\n\t\t\t} else { \n\t\t\t\tif (!rtlpriv->dm.is_cur_rdlstate ||\n\t\t\t\t\t!rtlpriv->dm.current_turbo_edca) {\n\t\t\t\t\tif (mac->mode == WIRELESS_MODE_G ||\n\t\t\t\t\t    mac->mode == WIRELESS_MODE_B)\n\t\t\t\t\t\trtl_write_dword(rtlpriv,\n\t\t\t\t\t\t\t\tEDCAPARA_BE,\n\t\t\t\t\t\t\t\tedca_gmode);\n\t\t\t\t\telse\n\t\t\t\t\t\trtl_write_dword(rtlpriv,\n\t\t\t\t\t\t\t\tEDCAPARA_BE,\n\t\t\t\t\t\t\t\tedca_be_dl);\n\t\t\t\t\trtlpriv->dm.is_cur_rdlstate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\trtlpriv->dm.current_turbo_edca = true;\n\t\t} else {\n\t\t\tif (cur_rxok_cnt > 4 * cur_txok_cnt) {\n\t\t\t\tif (!rtlpriv->dm.is_cur_rdlstate ||\n\t\t\t\t\t!rtlpriv->dm.current_turbo_edca) {\n\t\t\t\t\tif (mac->mode == WIRELESS_MODE_G ||\n\t\t\t\t\t    mac->mode == WIRELESS_MODE_B)\n\t\t\t\t\t\trtl_write_dword(rtlpriv,\n\t\t\t\t\t\t\t\tEDCAPARA_BE,\n\t\t\t\t\t\t\t\tedca_gmode);\n\t\t\t\t\telse\n\t\t\t\t\t\trtl_write_dword(rtlpriv,\n\t\t\t\t\t\t\t\tEDCAPARA_BE,\n\t\t\t\t\t\t\t\tedca_be_dl);\n\t\t\t\t\trtlpriv->dm.is_cur_rdlstate = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (rtlpriv->dm.is_cur_rdlstate ||\n\t\t\t\t\t!rtlpriv->dm.current_turbo_edca) {\n\t\t\t\t\trtl_write_dword(rtlpriv, EDCAPARA_BE,\n\t\t\t\t\t\t\tedca_be_ul);\n\t\t\t\t\trtlpriv->dm.is_cur_rdlstate = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\trtlpriv->dm.current_turbo_edca = true;\n\t\t}\n\t} else {\n\t\tif (rtlpriv->dm.current_turbo_edca) {\n\t\t\tu8 tmp = AC0_BE;\n\t\t\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_AC_PARAM,\n\t\t\t\t\t\t      &tmp);\n\t\t\trtlpriv->dm.current_turbo_edca = false;\n\t\t}\n\t}\n\ndm_checkedcaturbo_exit:\n\trtlpriv->dm.is_any_nonbepkts = false;\n\tlast_txok_cnt = rtlpriv->stats.txbytesunicast;\n\tlast_rxok_cnt = rtlpriv->stats.rxbytesunicast;\n}\n\nstatic void _rtl92s_dm_txpowertracking_callback_thermalmeter(\n\t\t\t\t\tstruct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tu8 thermalvalue = 0;\n\tu32 fw_cmd = 0;\n\n\trtlpriv->dm.txpower_trackinginit = true;\n\n\tthermalvalue = (u8)rtl_get_rfreg(hw, RF90_PATH_A, RF_T_METER, 0x1f);\n\n\trtl_dbg(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\n\t\t\"Readback Thermal Meter = 0x%x pre thermal meter 0x%x eeprom_thermal meter 0x%x\\n\",\n\t\tthermalvalue,\n\t\trtlpriv->dm.thermalvalue, rtlefuse->eeprom_thermalmeter);\n\n\tif (thermalvalue) {\n\t\trtlpriv->dm.thermalvalue = thermalvalue;\n\t\tif (hal_get_firmwareversion(rtlpriv) >= 0x35) {\n\t\t\trtl92s_phy_set_fw_cmd(hw, FW_CMD_TXPWR_TRACK_THERMAL);\n\t\t} else {\n\t\t\tfw_cmd = (FW_TXPWR_TRACK_THERMAL |\n\t\t\t\t (rtlpriv->efuse.thermalmeter[0] << 8) |\n\t\t\t\t (thermalvalue << 16));\n\n\t\t\trtl_dbg(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\n\t\t\t\t\"Write to FW Thermal Val = 0x%x\\n\", fw_cmd);\n\n\t\t\trtl_write_dword(rtlpriv, WFM5, fw_cmd);\n\t\t\trtl92s_phy_chk_fwcmd_iodone(hw);\n\t\t}\n\t}\n\n\trtlpriv->dm.txpowercount = 0;\n}\n\nstatic void _rtl92s_dm_check_txpowertracking_thermalmeter(\n\t\t\t\t\tstruct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tu8 tx_power_checkcnt = 5;\n\n\t \n\tif (rtlphy->rf_type == RF_2T2R)\n\t\treturn;\n\n\tif (!rtlpriv->dm.txpower_tracking)\n\t\treturn;\n\n\tif (rtlpriv->dm.txpowercount <= tx_power_checkcnt) {\n\t\trtlpriv->dm.txpowercount++;\n\t\treturn;\n\t}\n\n\tif (!rtlpriv->dm.tm_trigger) {\n\t\trtl_set_rfreg(hw, RF90_PATH_A, RF_T_METER,\n\t\t\t      RFREG_OFFSET_MASK, 0x60);\n\t\trtlpriv->dm.tm_trigger = 1;\n\t} else {\n\t\t_rtl92s_dm_txpowertracking_callback_thermalmeter(hw);\n\t\trtlpriv->dm.tm_trigger = 0;\n\t}\n}\n\nstatic void _rtl92s_dm_refresh_rateadaptive_mask(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rate_adaptive *ra = &(rtlpriv->ra);\n\tstruct ieee80211_sta *sta = NULL;\n\tu32 low_rssi_thresh = 0;\n\tu32 middle_rssi_thresh = 0;\n\tu32 high_rssi_thresh = 0;\n\n\tif (is_hal_stop(rtlhal))\n\t\treturn;\n\n\tif (!rtlpriv->dm.useramask)\n\t\treturn;\n\n\tif (hal_get_firmwareversion(rtlpriv) >= 61 &&\n\t    !rtlpriv->dm.inform_fw_driverctrldm) {\n\t\trtl92s_phy_set_fw_cmd(hw, FW_CMD_CTRL_DM_BY_DRIVER);\n\t\trtlpriv->dm.inform_fw_driverctrldm = true;\n\t}\n\n\tif ((mac->link_state == MAC80211_LINKED) &&\n\t    (mac->opmode == NL80211_IFTYPE_STATION)) {\n\t\tswitch (ra->pre_ratr_state) {\n\t\tcase DM_RATR_STA_HIGH:\n\t\t\thigh_rssi_thresh = 40;\n\t\t\tmiddle_rssi_thresh = 30;\n\t\t\tlow_rssi_thresh = 20;\n\t\t\tbreak;\n\t\tcase DM_RATR_STA_MIDDLE:\n\t\t\thigh_rssi_thresh = 44;\n\t\t\tmiddle_rssi_thresh = 30;\n\t\t\tlow_rssi_thresh = 20;\n\t\t\tbreak;\n\t\tcase DM_RATR_STA_LOW:\n\t\t\thigh_rssi_thresh = 44;\n\t\t\tmiddle_rssi_thresh = 34;\n\t\t\tlow_rssi_thresh = 20;\n\t\t\tbreak;\n\t\tcase DM_RATR_STA_ULTRALOW:\n\t\t\thigh_rssi_thresh = 44;\n\t\t\tmiddle_rssi_thresh = 34;\n\t\t\tlow_rssi_thresh = 24;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\thigh_rssi_thresh = 44;\n\t\t\tmiddle_rssi_thresh = 34;\n\t\t\tlow_rssi_thresh = 24;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rtlpriv->dm.undec_sm_pwdb > (long)high_rssi_thresh) {\n\t\t\tra->ratr_state = DM_RATR_STA_HIGH;\n\t\t} else if (rtlpriv->dm.undec_sm_pwdb >\n\t\t\t   (long)middle_rssi_thresh) {\n\t\t\tra->ratr_state = DM_RATR_STA_LOW;\n\t\t} else if (rtlpriv->dm.undec_sm_pwdb >\n\t\t\t   (long)low_rssi_thresh) {\n\t\t\tra->ratr_state = DM_RATR_STA_LOW;\n\t\t} else {\n\t\t\tra->ratr_state = DM_RATR_STA_ULTRALOW;\n\t\t}\n\n\t\tif (ra->pre_ratr_state != ra->ratr_state) {\n\t\t\trtl_dbg(rtlpriv, COMP_RATE, DBG_LOUD,\n\t\t\t\t\"RSSI = %ld RSSI_LEVEL = %d PreState = %d, CurState = %d\\n\",\n\t\t\t\trtlpriv->dm.undec_sm_pwdb, ra->ratr_state,\n\t\t\t\tra->pre_ratr_state, ra->ratr_state);\n\n\t\t\trcu_read_lock();\n\t\t\tsta = rtl_find_sta(hw, mac->bssid);\n\t\t\tif (sta)\n\t\t\t\trtlpriv->cfg->ops->update_rate_tbl(hw, sta,\n\t\t\t\t\t\t\t   ra->ratr_state,\n\t\t\t\t\t\t\t   true);\n\t\t\trcu_read_unlock();\n\n\t\t\tra->pre_ratr_state = ra->ratr_state;\n\t\t}\n\t}\n}\n\nstatic void _rtl92s_dm_switch_baseband_mrc(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tbool current_mrc;\n\tbool enable_mrc = true;\n\tlong tmpentry_maxpwdb = 0;\n\tu8 rssi_a = 0;\n\tu8 rssi_b = 0;\n\n\tif (is_hal_stop(rtlhal))\n\t\treturn;\n\n\tif ((rtlphy->rf_type == RF_1T1R) || (rtlphy->rf_type == RF_2T2R))\n\t\treturn;\n\n\trtlpriv->cfg->ops->get_hw_reg(hw, HW_VAR_MRC, (u8 *)(&current_mrc));\n\n\tif (mac->link_state >= MAC80211_LINKED) {\n\t\tif (rtlpriv->dm.undec_sm_pwdb > tmpentry_maxpwdb) {\n\t\t\trssi_a = rtlpriv->stats.rx_rssi_percentage[RF90_PATH_A];\n\t\t\trssi_b = rtlpriv->stats.rx_rssi_percentage[RF90_PATH_B];\n\t\t}\n\t}\n\n\t \n\tif (mac->mode != WIRELESS_MODE_B) {\n\t\tif ((rssi_a == 0) && (rssi_b == 0)) {\n\t\t\tenable_mrc = true;\n\t\t} else if (rssi_b > 30) {\n\t\t\t \n\t\t\tenable_mrc = true;\n\t\t} else if (rssi_b < 5) {\n\t\t\t \n\t\t\tenable_mrc = false;\n\t\t \n\t\t} else if (rssi_a > 15 && (rssi_a >= rssi_b)) {\n\t\t\tif ((rssi_a - rssi_b) > 15)\n\t\t\t\t \n\t\t\t\tenable_mrc = false;\n\t\t\telse if ((rssi_a - rssi_b) < 10)\n\t\t\t\t \n\t\t\t\tenable_mrc = true;\n\t\t\telse\n\t\t\t\tenable_mrc = current_mrc;\n\t\t} else {\n\t\t\t \n\t\t\tenable_mrc = true;\n\t\t}\n\t}\n\n\t \n\tif (enable_mrc != current_mrc)\n\t\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_MRC,\n\t\t\t\t\t      (u8 *)&enable_mrc);\n\n}\n\nvoid rtl92s_dm_init_edca_turbo(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtlpriv->dm.current_turbo_edca = false;\n\trtlpriv->dm.is_any_nonbepkts = false;\n\trtlpriv->dm.is_cur_rdlstate = false;\n}\n\nstatic void _rtl92s_dm_init_rate_adaptive_mask(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rate_adaptive *ra = &(rtlpriv->ra);\n\n\tra->ratr_state = DM_RATR_STA_MAX;\n\tra->pre_ratr_state = DM_RATR_STA_MAX;\n\n\tif (rtlpriv->dm.dm_type == DM_TYPE_BYDRIVER &&\n\t    hal_get_firmwareversion(rtlpriv) >= 60)\n\t\trtlpriv->dm.useramask = true;\n\telse\n\t\trtlpriv->dm.useramask = false;\n\n\trtlpriv->dm.useramask = false;\n\trtlpriv->dm.inform_fw_driverctrldm = false;\n}\n\nstatic void _rtl92s_dm_init_txpowertracking_thermalmeter(\n\t\t\t\tstruct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtlpriv->dm.txpower_tracking = true;\n\trtlpriv->dm.txpowercount = 0;\n\trtlpriv->dm.txpower_trackinginit = false;\n}\n\nstatic void _rtl92s_dm_false_alarm_counter_statistics(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct false_alarm_statistics *falsealm_cnt = &(rtlpriv->falsealm_cnt);\n\tu32 ret_value;\n\n\tret_value = rtl_get_bbreg(hw, ROFDM_PHYCOUNTER1, MASKDWORD);\n\tfalsealm_cnt->cnt_parity_fail = ((ret_value & 0xffff0000) >> 16);\n\n\tret_value = rtl_get_bbreg(hw, ROFDM_PHYCOUNTER2, MASKDWORD);\n\tfalsealm_cnt->cnt_rate_illegal = (ret_value & 0xffff);\n\tfalsealm_cnt->cnt_crc8_fail = ((ret_value & 0xffff0000) >> 16);\n\tret_value = rtl_get_bbreg(hw, ROFDM_PHYCOUNTER3, MASKDWORD);\n\tfalsealm_cnt->cnt_mcs_fail = (ret_value & 0xffff);\n\n\tfalsealm_cnt->cnt_ofdm_fail = falsealm_cnt->cnt_parity_fail +\n\t\tfalsealm_cnt->cnt_rate_illegal + falsealm_cnt->cnt_crc8_fail +\n\t\tfalsealm_cnt->cnt_mcs_fail;\n\n\t \n\tret_value = rtl_get_bbreg(hw, 0xc64, MASKDWORD);\n\tfalsealm_cnt->cnt_cck_fail = (ret_value & 0xffff);\n\tfalsealm_cnt->cnt_all =\tfalsealm_cnt->cnt_ofdm_fail +\n\t\tfalsealm_cnt->cnt_cck_fail;\n}\n\nstatic void rtl92s_backoff_enable_flag(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct dig_t *digtable = &rtlpriv->dm_digtable;\n\tstruct false_alarm_statistics *falsealm_cnt = &(rtlpriv->falsealm_cnt);\n\n\tif (falsealm_cnt->cnt_all > digtable->fa_highthresh) {\n\t\tif ((digtable->back_val - 6) <\n\t\t\tdigtable->backoffval_range_min)\n\t\t\tdigtable->back_val = digtable->backoffval_range_min;\n\t\telse\n\t\t\tdigtable->back_val -= 6;\n\t} else if (falsealm_cnt->cnt_all < digtable->fa_lowthresh) {\n\t\tif ((digtable->back_val + 6) >\n\t\t\tdigtable->backoffval_range_max)\n\t\t\tdigtable->back_val =\n\t\t\t\t digtable->backoffval_range_max;\n\t\telse\n\t\t\tdigtable->back_val += 6;\n\t}\n}\n\nstatic void _rtl92s_dm_initial_gain_sta_beforeconnect(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct dig_t *digtable = &rtlpriv->dm_digtable;\n\tstruct false_alarm_statistics *falsealm_cnt = &(rtlpriv->falsealm_cnt);\n\tstatic u8 initialized, force_write;\n\tu8 initial_gain = 0;\n\n\tif ((digtable->pre_sta_cstate == digtable->cur_sta_cstate) ||\n\t    (digtable->cur_sta_cstate == DIG_STA_BEFORE_CONNECT)) {\n\t\tif (digtable->cur_sta_cstate == DIG_STA_BEFORE_CONNECT) {\n\t\t\tif (rtlpriv->psc.rfpwr_state != ERFON)\n\t\t\t\treturn;\n\n\t\t\tif (digtable->backoff_enable_flag)\n\t\t\t\trtl92s_backoff_enable_flag(hw);\n\t\t\telse\n\t\t\t\tdigtable->back_val = DM_DIG_BACKOFF_MAX;\n\n\t\t\tif ((digtable->rssi_val + 10 - digtable->back_val) >\n\t\t\t\tdigtable->rx_gain_max)\n\t\t\t\tdigtable->cur_igvalue =\n\t\t\t\t\t\tdigtable->rx_gain_max;\n\t\t\telse if ((digtable->rssi_val + 10 - digtable->back_val)\n\t\t\t\t < digtable->rx_gain_min)\n\t\t\t\tdigtable->cur_igvalue =\n\t\t\t\t\t\tdigtable->rx_gain_min;\n\t\t\telse\n\t\t\t\tdigtable->cur_igvalue = digtable->rssi_val + 10\n\t\t\t\t\t- digtable->back_val;\n\n\t\t\tif (falsealm_cnt->cnt_all > 10000)\n\t\t\t\tdigtable->cur_igvalue =\n\t\t\t\t\t (digtable->cur_igvalue > 0x33) ?\n\t\t\t\t\t digtable->cur_igvalue : 0x33;\n\n\t\t\tif (falsealm_cnt->cnt_all > 16000)\n\t\t\t\tdigtable->cur_igvalue =\n\t\t\t\t\t\t digtable->rx_gain_max;\n\t\t \n\t\t} else {\n\t\t\t \n\t\t\treturn;\n\t\t}\n\t\t \n\t} else {\n\t\t \n\t\tdigtable->dig_ext_port_stage = DIG_EXT_PORT_STAGE_MAX;\n\t\trtl92s_phy_set_fw_cmd(hw, FW_CMD_DIG_ENABLE);\n\n\t\tdigtable->back_val = DM_DIG_BACKOFF_MAX;\n\t\tdigtable->cur_igvalue = rtlpriv->phy.default_initialgain[0];\n\t\tdigtable->pre_igvalue = 0;\n\t\treturn;\n\t}\n\n\t \n\tif (digtable->pre_igvalue != rtl_get_bbreg(hw, ROFDM0_XAAGCCORE1,\n\t\t\t\t\t\t  MASKBYTE0))\n\t\tforce_write = 1;\n\n\tif ((digtable->pre_igvalue != digtable->cur_igvalue) ||\n\t    !initialized || force_write) {\n\t\t \n\t\trtl92s_phy_set_fw_cmd(hw, FW_CMD_DIG_DISABLE);\n\n\t\tinitial_gain = (u8)digtable->cur_igvalue;\n\n\t\t \n\t\trtl_set_bbreg(hw, ROFDM0_XAAGCCORE1, MASKBYTE0, initial_gain);\n\t\trtl_set_bbreg(hw, ROFDM0_XBAGCCORE1, MASKBYTE0, initial_gain);\n\t\tdigtable->pre_igvalue = digtable->cur_igvalue;\n\t\tinitialized = 1;\n\t\tforce_write = 0;\n\t}\n}\n\nstatic void _rtl92s_dm_ctrl_initgain_bytwoport(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct dig_t *dig = &rtlpriv->dm_digtable;\n\n\tif (rtlpriv->mac80211.act_scanning)\n\t\treturn;\n\n\t \n\tif (rtlpriv->mac80211.link_state >= MAC80211_LINKED ||\n\t    rtlpriv->mac80211.opmode == NL80211_IFTYPE_ADHOC)\n\t\tdig->cur_sta_cstate = DIG_STA_CONNECT;\n\telse\n\t\tdig->cur_sta_cstate = DIG_STA_DISCONNECT;\n\n\tdig->rssi_val = rtlpriv->dm.undec_sm_pwdb;\n\n\t \n\tif (dig->cur_sta_cstate != DIG_STA_DISCONNECT) {\n\t\tif (dig->dig_twoport_algorithm ==\n\t\t    DIG_TWO_PORT_ALGO_FALSE_ALARM) {\n\t\t\tdig->dig_twoport_algorithm = DIG_TWO_PORT_ALGO_RSSI;\n\t\t\trtl92s_phy_set_fw_cmd(hw, FW_CMD_DIG_MODE_SS);\n\t\t}\n\t}\n\n\t_rtl92s_dm_false_alarm_counter_statistics(hw);\n\t_rtl92s_dm_initial_gain_sta_beforeconnect(hw);\n\n\tdig->pre_sta_cstate = dig->cur_sta_cstate;\n}\n\nstatic void _rtl92s_dm_ctrl_initgain_byrssi(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct dig_t *digtable = &rtlpriv->dm_digtable;\n\n\t \n\tif (rtlphy->rf_type == RF_2T2R)\n\t\treturn;\n\n\tif (!rtlpriv->dm.dm_initialgain_enable)\n\t\treturn;\n\n\tif (digtable->dig_enable_flag == false)\n\t\treturn;\n\n\t_rtl92s_dm_ctrl_initgain_bytwoport(hw);\n}\n\nstatic void _rtl92s_dm_dynamic_txpower(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tlong undec_sm_pwdb;\n\tlong txpwr_threshold_lv1, txpwr_threshold_lv2;\n\n\t \n\tif (rtlphy->rf_type == RF_2T2R)\n\t\treturn;\n\n\tif (!rtlpriv->dm.dynamic_txpower_enable ||\n\t    rtlpriv->dm.dm_flag & HAL_DM_HIPWR_DISABLE) {\n\t\trtlpriv->dm.dynamic_txhighpower_lvl = TX_HIGHPWR_LEVEL_NORMAL;\n\t\treturn;\n\t}\n\n\tif ((mac->link_state < MAC80211_LINKED) &&\n\t    (rtlpriv->dm.entry_min_undec_sm_pwdb == 0)) {\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_TRACE,\n\t\t\t\"Not connected to any\\n\");\n\n\t\trtlpriv->dm.dynamic_txhighpower_lvl = TX_HIGHPWR_LEVEL_NORMAL;\n\n\t\trtlpriv->dm.last_dtp_lvl = TX_HIGHPWR_LEVEL_NORMAL;\n\t\treturn;\n\t}\n\n\tif (mac->link_state >= MAC80211_LINKED) {\n\t\tif (mac->opmode == NL80211_IFTYPE_ADHOC) {\n\t\t\tundec_sm_pwdb = rtlpriv->dm.entry_min_undec_sm_pwdb;\n\t\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD,\n\t\t\t\t\"AP Client PWDB = 0x%lx\\n\",\n\t\t\t\tundec_sm_pwdb);\n\t\t} else {\n\t\t\tundec_sm_pwdb = rtlpriv->dm.undec_sm_pwdb;\n\t\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD,\n\t\t\t\t\"STA Default Port PWDB = 0x%lx\\n\",\n\t\t\t\tundec_sm_pwdb);\n\t\t}\n\t} else {\n\t\tundec_sm_pwdb = rtlpriv->dm.entry_min_undec_sm_pwdb;\n\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD,\n\t\t\t\"AP Ext Port PWDB = 0x%lx\\n\",\n\t\t\tundec_sm_pwdb);\n\t}\n\n\ttxpwr_threshold_lv2 = TX_POWER_NEAR_FIELD_THRESH_LVL2;\n\ttxpwr_threshold_lv1 = TX_POWER_NEAR_FIELD_THRESH_LVL1;\n\n\tif (rtl_get_bbreg(hw, 0xc90, MASKBYTE0) == 1)\n\t\trtlpriv->dm.dynamic_txhighpower_lvl = TX_HIGHPWR_LEVEL_NORMAL;\n\telse if (undec_sm_pwdb >= txpwr_threshold_lv2)\n\t\trtlpriv->dm.dynamic_txhighpower_lvl = TX_HIGHPWR_LEVEL_NORMAL2;\n\telse if ((undec_sm_pwdb < (txpwr_threshold_lv2 - 3)) &&\n\t\t(undec_sm_pwdb >= txpwr_threshold_lv1))\n\t\trtlpriv->dm.dynamic_txhighpower_lvl = TX_HIGHPWR_LEVEL_NORMAL1;\n\telse if (undec_sm_pwdb < (txpwr_threshold_lv1 - 3))\n\t\trtlpriv->dm.dynamic_txhighpower_lvl = TX_HIGHPWR_LEVEL_NORMAL;\n\n\tif ((rtlpriv->dm.dynamic_txhighpower_lvl != rtlpriv->dm.last_dtp_lvl))\n\t\trtl92s_phy_set_txpower(hw, rtlphy->current_channel);\n\n\trtlpriv->dm.last_dtp_lvl = rtlpriv->dm.dynamic_txhighpower_lvl;\n}\n\nstatic void _rtl92s_dm_init_dig(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct dig_t *digtable = &rtlpriv->dm_digtable;\n\n\t \n\tdigtable->dig_enable_flag = true;\n\tdigtable->backoff_enable_flag = true;\n\n\tif ((rtlpriv->dm.dm_type == DM_TYPE_BYDRIVER) &&\n\t    (hal_get_firmwareversion(rtlpriv) >= 0x3c))\n\t\tdigtable->dig_algorithm = DIG_ALGO_BY_TOW_PORT;\n\telse\n\t\tdigtable->dig_algorithm =\n\t\t\t DIG_ALGO_BEFORE_CONNECT_BY_RSSI_AND_ALARM;\n\n\tdigtable->dig_twoport_algorithm = DIG_TWO_PORT_ALGO_RSSI;\n\tdigtable->dig_ext_port_stage = DIG_EXT_PORT_STAGE_MAX;\n\t \n\tdigtable->dig_dbgmode = DM_DBG_OFF;\n\tdigtable->dig_slgorithm_switch = 0;\n\n\t \n\tdigtable->dig_state = DM_STA_DIG_MAX;\n\tdigtable->dig_highpwrstate = DM_STA_DIG_MAX;\n\n\tdigtable->cur_sta_cstate = DIG_STA_DISCONNECT;\n\tdigtable->pre_sta_cstate = DIG_STA_DISCONNECT;\n\tdigtable->cur_ap_cstate = DIG_AP_DISCONNECT;\n\tdigtable->pre_ap_cstate = DIG_AP_DISCONNECT;\n\n\tdigtable->rssi_lowthresh = DM_DIG_THRESH_LOW;\n\tdigtable->rssi_highthresh = DM_DIG_THRESH_HIGH;\n\n\tdigtable->fa_lowthresh = DM_FALSEALARM_THRESH_LOW;\n\tdigtable->fa_highthresh = DM_FALSEALARM_THRESH_HIGH;\n\n\tdigtable->rssi_highpower_lowthresh = DM_DIG_HIGH_PWR_THRESH_LOW;\n\tdigtable->rssi_highpower_highthresh = DM_DIG_HIGH_PWR_THRESH_HIGH;\n\n\t \n\tdigtable->rssi_val = 50;\n\tdigtable->back_val = DM_DIG_BACKOFF_MAX;\n\tdigtable->rx_gain_max = DM_DIG_MAX;\n\n\tdigtable->rx_gain_min = DM_DIG_MIN;\n\n\tdigtable->backoffval_range_max = DM_DIG_BACKOFF_MAX;\n\tdigtable->backoffval_range_min = DM_DIG_BACKOFF_MIN;\n}\n\nstatic void _rtl92s_dm_init_dynamic_txpower(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\tif ((hal_get_firmwareversion(rtlpriv) >= 60) &&\n\t    (rtlpriv->dm.dm_type == DM_TYPE_BYDRIVER))\n\t\trtlpriv->dm.dynamic_txpower_enable = true;\n\telse\n\t\trtlpriv->dm.dynamic_txpower_enable = false;\n\n\trtlpriv->dm.last_dtp_lvl = TX_HIGHPWR_LEVEL_NORMAL;\n\trtlpriv->dm.dynamic_txhighpower_lvl = TX_HIGHPWR_LEVEL_NORMAL;\n}\n\nvoid rtl92s_dm_init(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtlpriv->dm.dm_type = DM_TYPE_BYDRIVER;\n\trtlpriv->dm.undec_sm_pwdb = -1;\n\n\t_rtl92s_dm_init_dynamic_txpower(hw);\n\trtl92s_dm_init_edca_turbo(hw);\n\t_rtl92s_dm_init_rate_adaptive_mask(hw);\n\t_rtl92s_dm_init_txpowertracking_thermalmeter(hw);\n\t_rtl92s_dm_init_dig(hw);\n\n\trtl_write_dword(rtlpriv, WFM5, FW_CCA_CHK_ENABLE);\n}\n\nvoid rtl92s_dm_watchdog(struct ieee80211_hw *hw)\n{\n\t_rtl92s_dm_check_edca_turbo(hw);\n\t_rtl92s_dm_check_txpowertracking_thermalmeter(hw);\n\t_rtl92s_dm_ctrl_initgain_byrssi(hw);\n\t_rtl92s_dm_dynamic_txpower(hw);\n\t_rtl92s_dm_refresh_rateadaptive_mask(hw);\n\t_rtl92s_dm_switch_baseband_mrc(hw);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}