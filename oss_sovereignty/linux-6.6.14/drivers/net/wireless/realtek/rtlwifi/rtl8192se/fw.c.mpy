{
  "module_name": "fw.c",
  "hash_id": "2093303884d61d4329f8d57ebff4addba6107a6b3ee412867dfbac51a7a8a0c2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtlwifi/rtl8192se/fw.c",
  "human_readable_source": "\n \n\n#include \"../wifi.h\"\n#include \"../pci.h\"\n#include \"../base.h\"\n#include \"reg.h\"\n#include \"def.h\"\n#include \"fw.h\"\n\nstatic void _rtl92s_fw_set_rqpn(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtl_write_dword(rtlpriv, RQPN, 0xffffffff);\n\trtl_write_dword(rtlpriv, RQPN + 4, 0xffffffff);\n\trtl_write_byte(rtlpriv, RQPN + 8, 0xff);\n\trtl_write_byte(rtlpriv, RQPN + 0xB, 0x80);\n}\n\nstatic bool _rtl92s_firmware_enable_cpu(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 ichecktime = 200;\n\tu16 tmpu2b;\n\tu8 tmpu1b, cpustatus = 0;\n\n\t_rtl92s_fw_set_rqpn(hw);\n\n\t \n\ttmpu1b = rtl_read_byte(rtlpriv, SYS_CLKR);\n\t \n\trtl_write_byte(rtlpriv, SYS_CLKR, (tmpu1b | SYS_CPU_CLKSEL));\n\n\ttmpu2b = rtl_read_word(rtlpriv, REG_SYS_FUNC_EN);\n\trtl_write_word(rtlpriv, REG_SYS_FUNC_EN, (tmpu2b | FEN_CPUEN));\n\n\t \n\tdo {\n\t\tcpustatus = rtl_read_byte(rtlpriv, TCR);\n\t\tif (cpustatus & IMEM_RDY) {\n\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\t\"IMEM Ready after CPU has refilled\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tudelay(100);\n\t} while (ichecktime--);\n\n\tif (!(cpustatus & IMEM_RDY))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic enum fw_status _rtl92s_firmware_get_nextstatus(\n\t\tenum fw_status fw_currentstatus)\n{\n\tenum fw_status\tnext_fwstatus = 0;\n\n\tswitch (fw_currentstatus) {\n\tcase FW_STATUS_INIT:\n\t\tnext_fwstatus = FW_STATUS_LOAD_IMEM;\n\t\tbreak;\n\tcase FW_STATUS_LOAD_IMEM:\n\t\tnext_fwstatus = FW_STATUS_LOAD_EMEM;\n\t\tbreak;\n\tcase FW_STATUS_LOAD_EMEM:\n\t\tnext_fwstatus = FW_STATUS_LOAD_DMEM;\n\t\tbreak;\n\tcase FW_STATUS_LOAD_DMEM:\n\t\tnext_fwstatus = FW_STATUS_READY;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn next_fwstatus;\n}\n\nstatic u8 _rtl92s_firmware_header_map_rftype(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\n\tswitch (rtlphy->rf_type) {\n\tcase RF_1T1R:\n\t\treturn 0x11;\n\tcase RF_1T2R:\n\t\treturn 0x12;\n\tcase RF_2T2R:\n\t\treturn 0x22;\n\tdefault:\n\t\tpr_err(\"Unknown RF type(%x)\\n\", rtlphy->rf_type);\n\t\tbreak;\n\t}\n\treturn 0x22;\n}\n\nstatic void _rtl92s_firmwareheader_priveupdate(struct ieee80211_hw *hw,\n\t\tstruct fw_priv *pfw_priv)\n{\n\t \n\tpfw_priv->rf_config = _rtl92s_firmware_header_map_rftype(hw);\n}\n\n\n\nstatic bool _rtl92s_cmd_send_packet(struct ieee80211_hw *hw,\n\t\tstruct sk_buff *skb, u8 last)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tstruct rtl8192_tx_ring *ring;\n\tstruct rtl_tx_desc *pdesc;\n\tunsigned long flags;\n\tu8 idx = 0;\n\n\tring = &rtlpci->tx_ring[TXCMD_QUEUE];\n\n\tspin_lock_irqsave(&rtlpriv->locks.irq_th_lock, flags);\n\n\tidx = (ring->idx + skb_queue_len(&ring->queue)) % ring->entries;\n\tpdesc = &ring->desc[idx];\n\trtlpriv->cfg->ops->fill_tx_cmddesc(hw, (u8 *)pdesc, 1, 1, skb);\n\t__skb_queue_tail(&ring->queue, skb);\n\n\tspin_unlock_irqrestore(&rtlpriv->locks.irq_th_lock, flags);\n\n\treturn true;\n}\n\nstatic bool _rtl92s_firmware_downloadcode(struct ieee80211_hw *hw,\n\t\tu8 *code_virtual_address, u32 buffer_len)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct sk_buff *skb;\n\tstruct rtl_tcb_desc *tcb_desc;\n\tu16 frag_threshold = MAX_FIRMWARE_CODE_SIZE;\n\tu16 frag_length, frag_offset = 0;\n\tu16 extra_descoffset = 0;\n\tu8 last_inipkt = 0;\n\n\t_rtl92s_fw_set_rqpn(hw);\n\n\tif (buffer_len >= MAX_FIRMWARE_CODE_SIZE) {\n\t\tpr_err(\"Size over FIRMWARE_CODE_SIZE!\\n\");\n\t\treturn false;\n\t}\n\n\textra_descoffset = 0;\n\n\tdo {\n\t\tif ((buffer_len - frag_offset) > frag_threshold) {\n\t\t\tfrag_length = frag_threshold + extra_descoffset;\n\t\t} else {\n\t\t\tfrag_length = (u16)(buffer_len - frag_offset +\n\t\t\t\t\t    extra_descoffset);\n\t\t\tlast_inipkt = 1;\n\t\t}\n\n\t\t \n\t\t \n\t\tskb = dev_alloc_skb(frag_length);\n\t\tif (!skb)\n\t\t\treturn false;\n\t\tskb_reserve(skb, extra_descoffset);\n\t\tskb_put_data(skb, code_virtual_address + frag_offset,\n\t\t\t     (u32)(frag_length - extra_descoffset));\n\n\t\ttcb_desc = (struct rtl_tcb_desc *)(skb->cb);\n\t\ttcb_desc->queue_index = TXCMD_QUEUE;\n\t\ttcb_desc->cmd_or_init = DESC_PACKET_TYPE_INIT;\n\t\ttcb_desc->last_inipkt = last_inipkt;\n\n\t\t_rtl92s_cmd_send_packet(hw, skb, last_inipkt);\n\n\t\tfrag_offset += (frag_length - extra_descoffset);\n\n\t} while (frag_offset < buffer_len);\n\n\trtl_write_byte(rtlpriv, TP_POLL, TPPOLL_CQ);\n\n\treturn true ;\n}\n\nstatic bool _rtl92s_firmware_checkready(struct ieee80211_hw *hw,\n\t\tu8 loadfw_status)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rt_firmware *firmware = (struct rt_firmware *)rtlhal->pfirmware;\n\tu32 tmpu4b;\n\tu8 cpustatus = 0;\n\tshort pollingcnt = 1000;\n\tbool rtstatus = true;\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\"LoadStaus(%d)\\n\", loadfw_status);\n\n\tfirmware->fwstatus = (enum fw_status)loadfw_status;\n\n\tswitch (loadfw_status) {\n\tcase FW_STATUS_LOAD_IMEM:\n\t\t \n\t\tdo {\n\t\t\tcpustatus = rtl_read_byte(rtlpriv, TCR);\n\t\t\tif (cpustatus & IMEM_CODE_DONE)\n\t\t\t\tbreak;\n\t\t\tudelay(5);\n\t\t} while (pollingcnt--);\n\n\t\tif (!(cpustatus & IMEM_CHK_RPT) || (pollingcnt <= 0)) {\n\t\t\tpr_err(\"FW_STATUS_LOAD_IMEM FAIL CPU, Status=%x\\n\",\n\t\t\t       cpustatus);\n\t\t\tgoto status_check_fail;\n\t\t}\n\t\tbreak;\n\n\tcase FW_STATUS_LOAD_EMEM:\n\t\t \n\t\t \n\t\tdo {\n\t\t\tcpustatus = rtl_read_byte(rtlpriv, TCR);\n\t\t\tif (cpustatus & EMEM_CODE_DONE)\n\t\t\t\tbreak;\n\t\t\tudelay(5);\n\t\t} while (pollingcnt--);\n\n\t\tif (!(cpustatus & EMEM_CHK_RPT) || (pollingcnt <= 0)) {\n\t\t\tpr_err(\"FW_STATUS_LOAD_EMEM FAIL CPU, Status=%x\\n\",\n\t\t\t       cpustatus);\n\t\t\tgoto status_check_fail;\n\t\t}\n\n\t\t \n\t\trtstatus = _rtl92s_firmware_enable_cpu(hw);\n\t\tif (!rtstatus) {\n\t\t\tpr_err(\"Enable CPU fail!\\n\");\n\t\t\tgoto status_check_fail;\n\t\t}\n\t\tbreak;\n\n\tcase FW_STATUS_LOAD_DMEM:\n\t\t \n\t\tdo {\n\t\t\tcpustatus = rtl_read_byte(rtlpriv, TCR);\n\t\t\tif (cpustatus & DMEM_CODE_DONE)\n\t\t\t\tbreak;\n\t\t\tudelay(5);\n\t\t} while (pollingcnt--);\n\n\t\tif (!(cpustatus & DMEM_CODE_DONE) || (pollingcnt <= 0)) {\n\t\t\tpr_err(\"Polling DMEM code done fail ! cpustatus(%#x)\\n\",\n\t\t\t       cpustatus);\n\t\t\tgoto status_check_fail;\n\t\t}\n\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\"DMEM code download success, cpustatus(%#x)\\n\",\n\t\t\tcpustatus);\n\n\t\t \n\t\t \n\t\tpollingcnt = 2000;\n\t\tdo {\n\t\t\tcpustatus = rtl_read_byte(rtlpriv, TCR);\n\t\t\tif (cpustatus & FWRDY)\n\t\t\t\tbreak;\n\t\t\tudelay(40);\n\t\t} while (pollingcnt--);\n\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\"Polling Load Firmware ready, cpustatus(%x)\\n\",\n\t\t\tcpustatus);\n\n\t\tif (((cpustatus & LOAD_FW_READY) != LOAD_FW_READY) ||\n\t\t    (pollingcnt <= 0)) {\n\t\t\tpr_err(\"Polling Load Firmware ready fail ! cpustatus(%x)\\n\",\n\t\t\t       cpustatus);\n\t\t\tgoto status_check_fail;\n\t\t}\n\n\t\t \n\t\t \n\t\ttmpu4b = rtl_read_dword(rtlpriv, TCR);\n\t\trtl_write_dword(rtlpriv, TCR, (tmpu4b & (~TCR_ICV)));\n\n\t\ttmpu4b = rtl_read_dword(rtlpriv, RCR);\n\t\trtl_write_dword(rtlpriv, RCR, (tmpu4b | RCR_APPFCS |\n\t\t\t\tRCR_APP_ICV | RCR_APP_MIC));\n\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\"Current RCR settings(%#x)\\n\", tmpu4b);\n\n\t\t \n\t\trtl_write_byte(rtlpriv, LBKMD_SEL, LBK_NORMAL);\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err(\"Unknown status check!\\n\");\n\t\trtstatus = false;\n\t\tbreak;\n\t}\n\nstatus_check_fail:\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\"loadfw_status(%d), rtstatus(%x)\\n\",\n\t\tloadfw_status, rtstatus);\n\treturn rtstatus;\n}\n\nint rtl92s_download_fw(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rt_firmware *firmware = NULL;\n\tstruct fw_hdr *pfwheader;\n\tstruct fw_priv *pfw_priv = NULL;\n\tu8 *puc_mappedfile = NULL;\n\tu32 ul_filelength = 0;\n\tu8 fwhdr_size = RT_8192S_FIRMWARE_HDR_SIZE;\n\tu8 fwstatus = FW_STATUS_INIT;\n\tbool rtstatus = true;\n\n\tif (rtlpriv->max_fw_size == 0 || !rtlhal->pfirmware)\n\t\treturn 1;\n\n\tfirmware = (struct rt_firmware *)rtlhal->pfirmware;\n\tfirmware->fwstatus = FW_STATUS_INIT;\n\n\tpuc_mappedfile = firmware->sz_fw_tmpbuffer;\n\n\t \n\tfirmware->pfwheader = (struct fw_hdr *) puc_mappedfile;\n\tpfwheader = firmware->pfwheader;\n\tfirmware->firmwareversion =  byte(pfwheader->version, 0);\n\tfirmware->pfwheader->fwpriv.hci_sel = 1; \n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\"signature:%x, version:%x, size:%x, imemsize:%x, sram size:%x\\n\",\n\t\tpfwheader->signature,\n\t\tpfwheader->version, pfwheader->dmem_size,\n\t\tpfwheader->img_imem_size, pfwheader->img_sram_size);\n\n\t \n\tif ((pfwheader->img_imem_size == 0) || (pfwheader->img_imem_size >\n\t    sizeof(firmware->fw_imem))) {\n\t\tpr_err(\"memory for data image is less than IMEM required\\n\");\n\t\tgoto fail;\n\t} else {\n\t\tpuc_mappedfile += fwhdr_size;\n\n\t\tmemcpy(firmware->fw_imem, puc_mappedfile,\n\t\t       pfwheader->img_imem_size);\n\t\tfirmware->fw_imem_len = pfwheader->img_imem_size;\n\t}\n\n\t \n\tif (pfwheader->img_sram_size > sizeof(firmware->fw_emem)) {\n\t\tpr_err(\"memory for data image is less than EMEM required\\n\");\n\t\tgoto fail;\n\t} else {\n\t\tpuc_mappedfile += firmware->fw_imem_len;\n\n\t\tmemcpy(firmware->fw_emem, puc_mappedfile,\n\t\t       pfwheader->img_sram_size);\n\t\tfirmware->fw_emem_len = pfwheader->img_sram_size;\n\t}\n\n\t \n\tfwstatus = _rtl92s_firmware_get_nextstatus(firmware->fwstatus);\n\twhile (fwstatus != FW_STATUS_READY) {\n\t\t \n\t\tswitch (fwstatus) {\n\t\tcase FW_STATUS_LOAD_IMEM:\n\t\t\tpuc_mappedfile = firmware->fw_imem;\n\t\t\tul_filelength = firmware->fw_imem_len;\n\t\t\tbreak;\n\t\tcase FW_STATUS_LOAD_EMEM:\n\t\t\tpuc_mappedfile = firmware->fw_emem;\n\t\t\tul_filelength = firmware->fw_emem_len;\n\t\t\tbreak;\n\t\tcase FW_STATUS_LOAD_DMEM:\n\t\t\t \n\t\t\tpfwheader = firmware->pfwheader;\n\t\t\tpfw_priv = &pfwheader->fwpriv;\n\t\t\t_rtl92s_firmwareheader_priveupdate(hw, pfw_priv);\n\t\t\tpuc_mappedfile = (u8 *)(firmware->pfwheader) +\n\t\t\t\t\tRT_8192S_FIRMWARE_HDR_EXCLUDE_PRI_SIZE;\n\t\t\tul_filelength = fwhdr_size -\n\t\t\t\t\tRT_8192S_FIRMWARE_HDR_EXCLUDE_PRI_SIZE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Unexpected Download step!!\\n\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\t \n\t\trtstatus = _rtl92s_firmware_downloadcode(hw, puc_mappedfile,\n\t\t\t\tul_filelength);\n\n\t\tif (!rtstatus) {\n\t\t\tpr_err(\"fail!\\n\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\t \n\t\trtstatus = _rtl92s_firmware_checkready(hw, fwstatus);\n\t\tif (!rtstatus) {\n\t\t\tpr_err(\"rtl8192se: firmware fail!\\n\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tfwstatus = _rtl92s_firmware_get_nextstatus(firmware->fwstatus);\n\t}\n\n\treturn rtstatus;\nfail:\n\treturn 0;\n}\n\nstatic u32 _rtl92s_fill_h2c_cmd(struct sk_buff *skb, u32 h2cbufferlen,\n\t\t\t\tu32 cmd_num, u32 *pelement_id, u32 *pcmd_len,\n\t\t\t\tu8 **pcmb_buffer, u8 *cmd_start_seq)\n{\n\tu32 totallen = 0, len = 0, tx_desclen = 0;\n\tu32 pre_continueoffset = 0;\n\tu8 *ph2c_buffer;\n\tu8 i = 0;\n\n\tdo {\n\t\t \n\t\tlen = H2C_TX_CMD_HDR_LEN + N_BYTE_ALIGMENT(pcmd_len[i], 8);\n\n\t\t \n\t\tif (h2cbufferlen < totallen + len + tx_desclen)\n\t\t\tbreak;\n\n\t\t \n\t\tph2c_buffer = skb_put(skb, (u32)len);\n\t\tmemset((ph2c_buffer + totallen + tx_desclen), 0, len);\n\n\t\t \n\t\tle32p_replace_bits((__le32 *)(ph2c_buffer + totallen +\n\t\t\t\t\t      tx_desclen), pcmd_len[i],\n\t\t\t\t   GENMASK(15, 0));\n\n\t\t \n\t\tle32p_replace_bits((__le32 *)(ph2c_buffer + totallen +\n\t\t\t\t\t      tx_desclen), pelement_id[i],\n\t\t\t\t   GENMASK(23, 16));\n\n\t\t \n\t\t*cmd_start_seq = *cmd_start_seq % 0x80;\n\t\tle32p_replace_bits((__le32 *)(ph2c_buffer + totallen +\n\t\t\t\t\t      tx_desclen), *cmd_start_seq,\n\t\t\t\t   GENMASK(30, 24));\n\t\t++*cmd_start_seq;\n\n\t\t \n\t\tmemcpy((ph2c_buffer + totallen + tx_desclen +\n\t\t\tH2C_TX_CMD_HDR_LEN), pcmb_buffer[i], pcmd_len[i]);\n\n\t\t \n\t\t \n\t\tif (i < cmd_num - 1)\n\t\t\tle32p_replace_bits((__le32 *)(ph2c_buffer +\n\t\t\t\t\t\t      pre_continueoffset),\n\t\t\t\t\t   1, BIT(31));\n\n\t\tpre_continueoffset = totallen;\n\n\t\ttotallen += len;\n\t} while (++i < cmd_num);\n\n\treturn totallen;\n}\n\nstatic u32 _rtl92s_get_h2c_cmdlen(u32 h2cbufferlen, u32 cmd_num, u32 *pcmd_len)\n{\n\tu32 totallen = 0, len = 0, tx_desclen = 0;\n\tu8 i = 0;\n\n\tdo {\n\t\t \n\t\tlen = H2C_TX_CMD_HDR_LEN + N_BYTE_ALIGMENT(pcmd_len[i], 8);\n\n\t\t \n\t\tif (h2cbufferlen < totallen + len + tx_desclen)\n\t\t\tbreak;\n\n\t\ttotallen += len;\n\t} while (++i < cmd_num);\n\n\treturn totallen + tx_desclen;\n}\n\nstatic bool _rtl92s_firmware_set_h2c_cmd(struct ieee80211_hw *hw, u8 h2c_cmd,\n\t\t\t\t\t u8 *pcmd_buffer)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_tcb_desc *cb_desc;\n\tstruct sk_buff *skb;\n\tu32\telement_id = 0;\n\tu32\tcmd_len = 0;\n\tu32\tlen;\n\n\tswitch (h2c_cmd) {\n\tcase FW_H2C_SETPWRMODE:\n\t\telement_id = H2C_SETPWRMODE_CMD ;\n\t\tcmd_len = sizeof(struct h2c_set_pwrmode_parm);\n\t\tbreak;\n\tcase FW_H2C_JOINBSSRPT:\n\t\telement_id = H2C_JOINBSSRPT_CMD;\n\t\tcmd_len = sizeof(struct h2c_joinbss_rpt_parm);\n\t\tbreak;\n\tcase FW_H2C_WOWLAN_UPDATE_GTK:\n\t\telement_id = H2C_WOWLAN_UPDATE_GTK_CMD;\n\t\tcmd_len = sizeof(struct h2c_wpa_two_way_parm);\n\t\tbreak;\n\tcase FW_H2C_WOWLAN_UPDATE_IV:\n\t\telement_id = H2C_WOWLAN_UPDATE_IV_CMD;\n\t\tcmd_len = sizeof(unsigned long long);\n\t\tbreak;\n\tcase FW_H2C_WOWLAN_OFFLOAD:\n\t\telement_id = H2C_WOWLAN_FW_OFFLOAD;\n\t\tcmd_len = sizeof(u8);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tlen = _rtl92s_get_h2c_cmdlen(MAX_TRANSMIT_BUFFER_SIZE, 1, &cmd_len);\n\tskb = dev_alloc_skb(len);\n\tif (!skb)\n\t\treturn false;\n\tcb_desc = (struct rtl_tcb_desc *)(skb->cb);\n\tcb_desc->queue_index = TXCMD_QUEUE;\n\tcb_desc->cmd_or_init = DESC_PACKET_TYPE_NORMAL;\n\tcb_desc->last_inipkt = false;\n\n\t_rtl92s_fill_h2c_cmd(skb, MAX_TRANSMIT_BUFFER_SIZE, 1, &element_id,\n\t\t\t&cmd_len, &pcmd_buffer,\t&rtlhal->h2c_txcmd_seq);\n\t_rtl92s_cmd_send_packet(hw, skb, false);\n\trtlpriv->cfg->ops->tx_polling(hw, TXCMD_QUEUE);\n\n\treturn true;\n}\n\nvoid rtl92s_set_fw_pwrmode_cmd(struct ieee80211_hw *hw, u8 mode)\n{\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tstruct h2c_set_pwrmode_parm\tpwrmode;\n\tu16 max_wakeup_period = 0;\n\n\tpwrmode.mode = mode;\n\tpwrmode.flag_low_traffic_en = 0;\n\tpwrmode.flag_lpnav_en = 0;\n\tpwrmode.flag_rf_low_snr_en = 0;\n\tpwrmode.flag_dps_en = 0;\n\tpwrmode.bcn_rx_en = 0;\n\tpwrmode.bcn_to = 0;\n\tle16p_replace_bits((__le16 *)(((u8 *)(&pwrmode) + 8)),\n\t\t\t   mac->vif->bss_conf.beacon_int, GENMASK(15, 0));\n\tpwrmode.app_itv = 0;\n\tpwrmode.awake_bcn_itvl = ppsc->reg_max_lps_awakeintvl;\n\tpwrmode.smart_ps = 1;\n\tpwrmode.bcn_pass_period = 10;\n\n\t \n\tif (pwrmode.mode == FW_PS_MIN_MODE)\n\t\tmax_wakeup_period = mac->vif->bss_conf.beacon_int;\n\telse if (pwrmode.mode == FW_PS_MAX_MODE)\n\t\tmax_wakeup_period = mac->vif->bss_conf.beacon_int *\n\t\t\tmac->vif->bss_conf.dtim_period;\n\n\tif (max_wakeup_period >= 500)\n\t\tpwrmode.bcn_pass_cnt = 1;\n\telse if ((max_wakeup_period >= 300) && (max_wakeup_period < 500))\n\t\tpwrmode.bcn_pass_cnt = 2;\n\telse if ((max_wakeup_period >= 200) && (max_wakeup_period < 300))\n\t\tpwrmode.bcn_pass_cnt = 3;\n\telse if ((max_wakeup_period >= 20) && (max_wakeup_period < 200))\n\t\tpwrmode.bcn_pass_cnt = 5;\n\telse\n\t\tpwrmode.bcn_pass_cnt = 1;\n\n\t_rtl92s_firmware_set_h2c_cmd(hw, FW_H2C_SETPWRMODE, (u8 *)&pwrmode);\n\n}\n\nvoid rtl92s_set_fw_joinbss_report_cmd(struct ieee80211_hw *hw,\n\t\tu8 mstatus, u8 ps_qosinfo)\n{\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct h2c_joinbss_rpt_parm joinbss_rpt;\n\n\tjoinbss_rpt.opmode = mstatus;\n\tjoinbss_rpt.ps_qos_info = ps_qosinfo;\n\tjoinbss_rpt.bssid[0] = mac->bssid[0];\n\tjoinbss_rpt.bssid[1] = mac->bssid[1];\n\tjoinbss_rpt.bssid[2] = mac->bssid[2];\n\tjoinbss_rpt.bssid[3] = mac->bssid[3];\n\tjoinbss_rpt.bssid[4] = mac->bssid[4];\n\tjoinbss_rpt.bssid[5] = mac->bssid[5];\n\tle16p_replace_bits((__le16 *)(((u8 *)(&joinbss_rpt) + 8)),\n\t\t\t   mac->vif->bss_conf.beacon_int, GENMASK(15, 0));\n\tle16p_replace_bits((__le16 *)(((u8 *)(&joinbss_rpt) + 10)),\n\t\t\t   mac->assoc_id, GENMASK(15, 0));\n\n\t_rtl92s_firmware_set_h2c_cmd(hw, FW_H2C_JOINBSSRPT, (u8 *)&joinbss_rpt);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}