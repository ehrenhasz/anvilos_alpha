{
  "module_name": "hw.c",
  "hash_id": "590a1fedef079f81929d7063b944ec6090f5f0144e0096336ec425b258d27881",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtlwifi/rtl8821ae/hw.c",
  "human_readable_source": "\n \n\n#include \"../wifi.h\"\n#include \"../efuse.h\"\n#include \"../base.h\"\n#include \"../regd.h\"\n#include \"../cam.h\"\n#include \"../ps.h\"\n#include \"../pci.h\"\n#include \"reg.h\"\n#include \"def.h\"\n#include \"phy.h\"\n#include \"dm.h\"\n#include \"fw.h\"\n#include \"led.h\"\n#include \"hw.h\"\n#include \"../pwrseqcmd.h\"\n#include \"pwrseq.h\"\n#include \"../btcoexist/rtl_btc.h\"\n\n#define LLT_CONFIG\t5\n\nstatic void _rtl8821ae_return_beacon_queue_skb(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tstruct rtl8192_tx_ring *ring = &rtlpci->tx_ring[BEACON_QUEUE];\n\tstruct sk_buff_head free_list;\n\tunsigned long flags;\n\n\tskb_queue_head_init(&free_list);\n\tspin_lock_irqsave(&rtlpriv->locks.irq_th_lock, flags);\n\twhile (skb_queue_len(&ring->queue)) {\n\t\tstruct rtl_tx_desc *entry = &ring->desc[ring->idx];\n\t\tstruct sk_buff *skb = __skb_dequeue(&ring->queue);\n\n\t\tdma_unmap_single(&rtlpci->pdev->dev,\n\t\t\t\t rtlpriv->cfg->ops->get_desc(hw, (u8 *)entry,\n\t\t\t\t\t\ttrue, HW_DESC_TXBUFF_ADDR),\n\t\t\t\t skb->len, DMA_TO_DEVICE);\n\t\t__skb_queue_tail(&free_list, skb);\n\t\tring->idx = (ring->idx + 1) % ring->entries;\n\t}\n\tspin_unlock_irqrestore(&rtlpriv->locks.irq_th_lock, flags);\n\n\t__skb_queue_purge(&free_list);\n}\n\nstatic void _rtl8821ae_set_bcn_ctrl_reg(struct ieee80211_hw *hw,\n\t\t\t\t\tu8 set_bits, u8 clear_bits)\n{\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtlpci->reg_bcn_ctrl_val |= set_bits;\n\trtlpci->reg_bcn_ctrl_val &= ~clear_bits;\n\n\trtl_write_byte(rtlpriv, REG_BCN_CTRL, (u8)rtlpci->reg_bcn_ctrl_val);\n}\n\nvoid _rtl8821ae_stop_tx_beacon(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 tmp1byte;\n\n\ttmp1byte = rtl_read_byte(rtlpriv, REG_FWHW_TXQ_CTRL + 2);\n\trtl_write_byte(rtlpriv, REG_FWHW_TXQ_CTRL + 2, tmp1byte & (~BIT(6)));\n\trtl_write_byte(rtlpriv, REG_TBTT_PROHIBIT + 1, 0x64);\n\ttmp1byte = rtl_read_byte(rtlpriv, REG_TBTT_PROHIBIT + 2);\n\ttmp1byte &= ~(BIT(0));\n\trtl_write_byte(rtlpriv, REG_TBTT_PROHIBIT + 2, tmp1byte);\n}\n\nvoid _rtl8821ae_resume_tx_beacon(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 tmp1byte;\n\n\ttmp1byte = rtl_read_byte(rtlpriv, REG_FWHW_TXQ_CTRL + 2);\n\trtl_write_byte(rtlpriv, REG_FWHW_TXQ_CTRL + 2, tmp1byte | BIT(6));\n\trtl_write_byte(rtlpriv, REG_TBTT_PROHIBIT + 1, 0xff);\n\ttmp1byte = rtl_read_byte(rtlpriv, REG_TBTT_PROHIBIT + 2);\n\ttmp1byte |= BIT(0);\n\trtl_write_byte(rtlpriv, REG_TBTT_PROHIBIT + 2, tmp1byte);\n}\n\nstatic void _rtl8821ae_enable_bcn_sub_func(struct ieee80211_hw *hw)\n{\n\t_rtl8821ae_set_bcn_ctrl_reg(hw, 0, BIT(1));\n}\n\nstatic void _rtl8821ae_disable_bcn_sub_func(struct ieee80211_hw *hw)\n{\n\t_rtl8821ae_set_bcn_ctrl_reg(hw, BIT(1), 0);\n}\n\nstatic void _rtl8821ae_set_fw_clock_on(struct ieee80211_hw *hw,\n\t\t\t\t       u8 rpwm_val, bool b_need_turn_off_ckk)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tbool b_support_remote_wake_up;\n\tu32 count = 0, isr_regaddr, content;\n\tbool b_schedule_timer = b_need_turn_off_ckk;\n\n\trtlpriv->cfg->ops->get_hw_reg(hw, HAL_DEF_WOWLAN,\n\t\t\t\t\t(u8 *)(&b_support_remote_wake_up));\n\n\tif (!rtlhal->fw_ready)\n\t\treturn;\n\tif (!rtlpriv->psc.fw_current_inpsmode)\n\t\treturn;\n\n\twhile (1) {\n\t\tspin_lock_bh(&rtlpriv->locks.fw_ps_lock);\n\t\tif (rtlhal->fw_clk_change_in_progress) {\n\t\t\twhile (rtlhal->fw_clk_change_in_progress) {\n\t\t\t\tspin_unlock_bh(&rtlpriv->locks.fw_ps_lock);\n\t\t\t\tcount++;\n\t\t\t\tudelay(100);\n\t\t\t\tif (count > 1000)\n\t\t\t\t\tgoto change_done;\n\t\t\t\tspin_lock_bh(&rtlpriv->locks.fw_ps_lock);\n\t\t\t}\n\t\t\tspin_unlock_bh(&rtlpriv->locks.fw_ps_lock);\n\t\t} else {\n\t\t\trtlhal->fw_clk_change_in_progress = false;\n\t\t\tspin_unlock_bh(&rtlpriv->locks.fw_ps_lock);\n\t\t\tgoto change_done;\n\t\t}\n\t}\nchange_done:\n\tif (IS_IN_LOW_POWER_STATE_8821AE(rtlhal->fw_ps_state)) {\n\t\trtlpriv->cfg->ops->get_hw_reg(hw, HW_VAR_SET_RPWM,\n\t\t\t\t\t(u8 *)(&rpwm_val));\n\t\tif (FW_PS_IS_ACK(rpwm_val)) {\n\t\t\tisr_regaddr = REG_HISR;\n\t\t\tcontent = rtl_read_dword(rtlpriv, isr_regaddr);\n\t\t\twhile (!(content & IMR_CPWM) && (count < 500)) {\n\t\t\t\tudelay(50);\n\t\t\t\tcount++;\n\t\t\t\tcontent = rtl_read_dword(rtlpriv, isr_regaddr);\n\t\t\t}\n\n\t\t\tif (content & IMR_CPWM) {\n\t\t\t\trtl_write_word(rtlpriv, isr_regaddr, 0x0100);\n\t\t\t\trtlhal->fw_ps_state = FW_PS_STATE_RF_ON_8821AE;\n\t\t\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD,\n\t\t\t\t\t\"Receive CPWM INT!!! Set rtlhal->FwPSState = %X\\n\",\n\t\t\t\t\trtlhal->fw_ps_state);\n\t\t\t}\n\t\t}\n\n\t\tspin_lock_bh(&rtlpriv->locks.fw_ps_lock);\n\t\trtlhal->fw_clk_change_in_progress = false;\n\t\tspin_unlock_bh(&rtlpriv->locks.fw_ps_lock);\n\t\tif (b_schedule_timer)\n\t\t\tmod_timer(&rtlpriv->works.fw_clockoff_timer,\n\t\t\t\t  jiffies + MSECS(10));\n\t} else  {\n\t\tspin_lock_bh(&rtlpriv->locks.fw_ps_lock);\n\t\trtlhal->fw_clk_change_in_progress = false;\n\t\tspin_unlock_bh(&rtlpriv->locks.fw_ps_lock);\n\t}\n}\n\nstatic void _rtl8821ae_set_fw_clock_off(struct ieee80211_hw *hw,\n\t\t\t\t\tu8 rpwm_val)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tstruct rtl8192_tx_ring *ring;\n\tenum rf_pwrstate rtstate;\n\tbool b_schedule_timer = false;\n\tu8 queue;\n\n\tif (!rtlhal->fw_ready)\n\t\treturn;\n\tif (!rtlpriv->psc.fw_current_inpsmode)\n\t\treturn;\n\tif (!rtlhal->allow_sw_to_change_hwclc)\n\t\treturn;\n\trtlpriv->cfg->ops->get_hw_reg(hw, HW_VAR_RF_STATE, (u8 *)(&rtstate));\n\tif (rtstate == ERFOFF || rtlpriv->psc.inactive_pwrstate == ERFOFF)\n\t\treturn;\n\n\tfor (queue = 0; queue < RTL_PCI_MAX_TX_QUEUE_COUNT; queue++) {\n\t\tring = &rtlpci->tx_ring[queue];\n\t\tif (skb_queue_len(&ring->queue)) {\n\t\t\tb_schedule_timer = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (b_schedule_timer) {\n\t\tmod_timer(&rtlpriv->works.fw_clockoff_timer,\n\t\t\t  jiffies + MSECS(10));\n\t\treturn;\n\t}\n\n\tif (FW_PS_STATE(rtlhal->fw_ps_state) !=\n\t\tFW_PS_STATE_RF_OFF_LOW_PWR_8821AE) {\n\t\tspin_lock_bh(&rtlpriv->locks.fw_ps_lock);\n\t\tif (!rtlhal->fw_clk_change_in_progress) {\n\t\t\trtlhal->fw_clk_change_in_progress = true;\n\t\t\tspin_unlock_bh(&rtlpriv->locks.fw_ps_lock);\n\t\t\trtlhal->fw_ps_state = FW_PS_STATE(rpwm_val);\n\t\t\trtl_write_word(rtlpriv, REG_HISR, 0x0100);\n\t\t\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_SET_RPWM,\n\t\t\t\t\t\t      (u8 *)(&rpwm_val));\n\t\t\tspin_lock_bh(&rtlpriv->locks.fw_ps_lock);\n\t\t\trtlhal->fw_clk_change_in_progress = false;\n\t\t\tspin_unlock_bh(&rtlpriv->locks.fw_ps_lock);\n\t\t} else {\n\t\t\tspin_unlock_bh(&rtlpriv->locks.fw_ps_lock);\n\t\t\tmod_timer(&rtlpriv->works.fw_clockoff_timer,\n\t\t\t\t  jiffies + MSECS(10));\n\t\t}\n\t}\n}\n\nstatic void _rtl8821ae_set_fw_ps_rf_on(struct ieee80211_hw *hw)\n{\n\tu8 rpwm_val = 0;\n\n\trpwm_val |= (FW_PS_STATE_RF_OFF_8821AE | FW_PS_ACK);\n\t_rtl8821ae_set_fw_clock_on(hw, rpwm_val, true);\n}\n\nstatic void _rtl8821ae_fwlps_leave(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tbool fw_current_inps = false;\n\tu8 rpwm_val = 0, fw_pwrmode = FW_PS_ACTIVE_MODE;\n\n\tif (ppsc->low_power_enable) {\n\t\trpwm_val = (FW_PS_STATE_ALL_ON_8821AE|FW_PS_ACK); \n\t\t_rtl8821ae_set_fw_clock_on(hw, rpwm_val, false);\n\t\trtlhal->allow_sw_to_change_hwclc = false;\n\t\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_H2C_FW_PWRMODE,\n\t\t\t\t(u8 *)(&fw_pwrmode));\n\t\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_FW_PSMODE_STATUS,\n\t\t\t\t(u8 *)(&fw_current_inps));\n\t} else {\n\t\trpwm_val = FW_PS_STATE_ALL_ON_8821AE;\t \n\t\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_SET_RPWM,\n\t\t\t\t(u8 *)(&rpwm_val));\n\t\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_H2C_FW_PWRMODE,\n\t\t\t\t(u8 *)(&fw_pwrmode));\n\t\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_FW_PSMODE_STATUS,\n\t\t\t\t(u8 *)(&fw_current_inps));\n\t}\n}\n\nstatic void _rtl8821ae_fwlps_enter(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tbool fw_current_inps = true;\n\tu8 rpwm_val;\n\n\tif (ppsc->low_power_enable) {\n\t\trpwm_val = FW_PS_STATE_RF_OFF_LOW_PWR_8821AE;\t \n\t\trtlpriv->cfg->ops->set_hw_reg(hw,\n\t\t\t\tHW_VAR_FW_PSMODE_STATUS,\n\t\t\t\t(u8 *)(&fw_current_inps));\n\t\trtlpriv->cfg->ops->set_hw_reg(hw,\n\t\t\t\tHW_VAR_H2C_FW_PWRMODE,\n\t\t\t\t(u8 *)(&ppsc->fwctrl_psmode));\n\t\trtlhal->allow_sw_to_change_hwclc = true;\n\t\t_rtl8821ae_set_fw_clock_off(hw, rpwm_val);\n\t} else {\n\t\trpwm_val = FW_PS_STATE_RF_OFF_8821AE;\t \n\t\trtlpriv->cfg->ops->set_hw_reg(hw,\n\t\t\t\tHW_VAR_FW_PSMODE_STATUS,\n\t\t\t\t(u8 *)(&fw_current_inps));\n\t\trtlpriv->cfg->ops->set_hw_reg(hw,\n\t\t\t\tHW_VAR_H2C_FW_PWRMODE,\n\t\t\t\t(u8 *)(&ppsc->fwctrl_psmode));\n\t\trtlpriv->cfg->ops->set_hw_reg(hw,\n\t\t\t\tHW_VAR_SET_RPWM,\n\t\t\t\t(u8 *)(&rpwm_val));\n\t}\n}\n\nstatic void _rtl8821ae_download_rsvd_page(struct ieee80211_hw *hw,\n\t\t\t\t\t  bool dl_whole_packets)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\n\tu8 tmp_regcr, tmp_reg422, bcnvalid_reg;\n\tu8 count = 0, dlbcn_count = 0;\n\tbool send_beacon = false;\n\n\ttmp_regcr = rtl_read_byte(rtlpriv, REG_CR + 1);\n\trtl_write_byte(rtlpriv, REG_CR + 1, (tmp_regcr | BIT(0)));\n\n\t_rtl8821ae_set_bcn_ctrl_reg(hw, 0, BIT(3));\n\t_rtl8821ae_set_bcn_ctrl_reg(hw, BIT(4), 0);\n\n\ttmp_reg422 = rtl_read_byte(rtlpriv, REG_FWHW_TXQ_CTRL + 2);\n\trtl_write_byte(rtlpriv, REG_FWHW_TXQ_CTRL + 2,\n\t\t       tmp_reg422 & (~BIT(6)));\n\tif (tmp_reg422 & BIT(6))\n\t\tsend_beacon = true;\n\n\tdo {\n\t\tbcnvalid_reg = rtl_read_byte(rtlpriv, REG_TDECTRL + 2);\n\t\trtl_write_byte(rtlpriv, REG_TDECTRL + 2,\n\t\t\t       (bcnvalid_reg | BIT(0)));\n\t\t_rtl8821ae_return_beacon_queue_skb(hw);\n\n\t\tif (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE)\n\t\t\trtl8812ae_set_fw_rsvdpagepkt(hw, false,\n\t\t\t\t\t\t     dl_whole_packets);\n\t\telse\n\t\t\trtl8821ae_set_fw_rsvdpagepkt(hw, false,\n\t\t\t\t\t\t     dl_whole_packets);\n\n\t\tbcnvalid_reg = rtl_read_byte(rtlpriv, REG_TDECTRL + 2);\n\t\tcount = 0;\n\t\twhile (!(bcnvalid_reg & BIT(0)) && count < 20) {\n\t\t\tcount++;\n\t\t\tudelay(10);\n\t\t\tbcnvalid_reg = rtl_read_byte(rtlpriv, REG_TDECTRL + 2);\n\t\t}\n\t\tdlbcn_count++;\n\t} while (!(bcnvalid_reg & BIT(0)) && dlbcn_count < 5);\n\n\tif (!(bcnvalid_reg & BIT(0)))\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\"Download RSVD page failed!\\n\");\n\tif (bcnvalid_reg & BIT(0) && rtlhal->enter_pnp_sleep) {\n\t\trtl_write_byte(rtlpriv, REG_TDECTRL + 2, bcnvalid_reg | BIT(0));\n\t\t_rtl8821ae_return_beacon_queue_skb(hw);\n\t\tif (send_beacon) {\n\t\t\tdlbcn_count = 0;\n\t\t\tdo {\n\t\t\t\trtl_write_byte(rtlpriv, REG_TDECTRL + 2,\n\t\t\t\t\t       bcnvalid_reg | BIT(0));\n\n\t\t\t\t_rtl8821ae_return_beacon_queue_skb(hw);\n\n\t\t\t\tif (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE)\n\t\t\t\t\trtl8812ae_set_fw_rsvdpagepkt(hw, true,\n\t\t\t\t\t\t\t\t     false);\n\t\t\t\telse\n\t\t\t\t\trtl8821ae_set_fw_rsvdpagepkt(hw, true,\n\t\t\t\t\t\t\t\t     false);\n\n\t\t\t\t \n\t\t\t\tbcnvalid_reg = rtl_read_byte(rtlpriv,\n\t\t\t\t\t\t\t     REG_TDECTRL + 2);\n\t\t\t\tcount = 0;\n\t\t\t\twhile (!(bcnvalid_reg & BIT(0)) && count < 20) {\n\t\t\t\t\tcount++;\n\t\t\t\t\tudelay(10);\n\t\t\t\t\tbcnvalid_reg =\n\t\t\t\t\t  rtl_read_byte(rtlpriv,\n\t\t\t\t\t\t\tREG_TDECTRL + 2);\n\t\t\t\t}\n\t\t\t\tdlbcn_count++;\n\t\t\t} while (!(bcnvalid_reg & BIT(0)) && dlbcn_count < 5);\n\n\t\t\tif (!(bcnvalid_reg & BIT(0)))\n\t\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\t\t\"2 Download RSVD page failed!\\n\");\n\t\t}\n\t}\n\n\tif (bcnvalid_reg & BIT(0))\n\t\trtl_write_byte(rtlpriv, REG_TDECTRL + 2, BIT(0));\n\n\t_rtl8821ae_set_bcn_ctrl_reg(hw, BIT(3), 0);\n\t_rtl8821ae_set_bcn_ctrl_reg(hw, 0, BIT(4));\n\n\tif (send_beacon)\n\t\trtl_write_byte(rtlpriv, REG_FWHW_TXQ_CTRL + 2, tmp_reg422);\n\n\tif (!rtlhal->enter_pnp_sleep) {\n\t\ttmp_regcr = rtl_read_byte(rtlpriv, REG_CR + 1);\n\t\trtl_write_byte(rtlpriv, REG_CR + 1, (tmp_regcr & ~(BIT(0))));\n\t}\n}\n\nvoid rtl8821ae_get_hw_reg(struct ieee80211_hw *hw, u8 variable, u8 *val)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\n\tswitch (variable) {\n\tcase HW_VAR_ETHER_ADDR:\n\t\t*((u32 *)(val)) = rtl_read_dword(rtlpriv, REG_MACID);\n\t\t*((u16 *)(val+4)) = rtl_read_word(rtlpriv, REG_MACID + 4);\n\t\tbreak;\n\tcase HW_VAR_BSSID:\n\t\t*((u32 *)(val)) = rtl_read_dword(rtlpriv, REG_BSSID);\n\t\t*((u16 *)(val+4)) = rtl_read_word(rtlpriv, REG_BSSID+4);\n\t\tbreak;\n\tcase HW_VAR_MEDIA_STATUS:\n\t\tval[0] = rtl_read_byte(rtlpriv, MSR) & 0x3;\n\t\tbreak;\n\tcase HW_VAR_SLOT_TIME:\n\t\t*((u8 *)(val)) = mac->slot_time;\n\t\tbreak;\n\tcase HW_VAR_BEACON_INTERVAL:\n\t\t*((u16 *)(val)) = rtl_read_word(rtlpriv, REG_BCN_INTERVAL);\n\t\tbreak;\n\tcase HW_VAR_ATIM_WINDOW:\n\t\t*((u16 *)(val)) =  rtl_read_word(rtlpriv, REG_ATIMWND);\n\t\tbreak;\n\tcase HW_VAR_RCR:\n\t\t*((u32 *)(val)) = rtlpci->receive_config;\n\t\tbreak;\n\tcase HW_VAR_RF_STATE:\n\t\t*((enum rf_pwrstate *)(val)) = ppsc->rfpwr_state;\n\t\tbreak;\n\tcase HW_VAR_FWLPS_RF_ON:{\n\t\tenum rf_pwrstate rfstate;\n\t\tu32 val_rcr;\n\n\t\trtlpriv->cfg->ops->get_hw_reg(hw,\n\t\t\t\t\t      HW_VAR_RF_STATE,\n\t\t\t\t\t      (u8 *)(&rfstate));\n\t\tif (rfstate == ERFOFF) {\n\t\t\t*((bool *)(val)) = true;\n\t\t} else {\n\t\t\tval_rcr = rtl_read_dword(rtlpriv, REG_RCR);\n\t\t\tval_rcr &= 0x00070000;\n\t\t\tif (val_rcr)\n\t\t\t\t*((bool *)(val)) = false;\n\t\t\telse\n\t\t\t\t*((bool *)(val)) = true;\n\t\t}\n\t\tbreak; }\n\tcase HW_VAR_FW_PSMODE_STATUS:\n\t\t*((bool *)(val)) = ppsc->fw_current_inpsmode;\n\t\tbreak;\n\tcase HW_VAR_CORRECT_TSF:{\n\t\tu64 tsf;\n\t\tu32 *ptsf_low = (u32 *)&tsf;\n\t\tu32 *ptsf_high = ((u32 *)&tsf) + 1;\n\n\t\t*ptsf_high = rtl_read_dword(rtlpriv, (REG_TSFTR + 4));\n\t\t*ptsf_low = rtl_read_dword(rtlpriv, REG_TSFTR);\n\n\t\t*((u64 *)(val)) = tsf;\n\n\t\tbreak; }\n\tcase HAL_DEF_WOWLAN:\n\t\tif (ppsc->wo_wlan_mode)\n\t\t\t*((bool *)(val)) = true;\n\t\telse\n\t\t\t*((bool *)(val)) = false;\n\t\tbreak;\n\tdefault:\n\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_LOUD,\n\t\t\t\"switch case %#x not processed\\n\", variable);\n\t\tbreak;\n\t}\n}\n\nvoid rtl8821ae_set_hw_reg(struct ieee80211_hw *hw, u8 variable, u8 *val)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tu8 idx;\n\n\tswitch (variable) {\n\tcase HW_VAR_ETHER_ADDR:{\n\t\t\tfor (idx = 0; idx < ETH_ALEN; idx++) {\n\t\t\t\trtl_write_byte(rtlpriv, (REG_MACID + idx),\n\t\t\t\t\t       val[idx]);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_BASIC_RATE:{\n\t\t\tu16 b_rate_cfg = ((u16 *)val)[0];\n\t\t\tb_rate_cfg = b_rate_cfg & 0x15f;\n\t\t\trtl_write_word(rtlpriv, REG_RRSR, b_rate_cfg);\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_BSSID:{\n\t\t\tfor (idx = 0; idx < ETH_ALEN; idx++) {\n\t\t\t\trtl_write_byte(rtlpriv, (REG_BSSID + idx),\n\t\t\t\t\t       val[idx]);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_SIFS:\n\t\trtl_write_byte(rtlpriv, REG_SIFS_CTX + 1, val[0]);\n\t\trtl_write_byte(rtlpriv, REG_SIFS_TRX + 1, val[0]);\n\n\t\trtl_write_byte(rtlpriv, REG_SPEC_SIFS + 1, val[0]);\n\t\trtl_write_byte(rtlpriv, REG_MAC_SPEC_SIFS + 1, val[0]);\n\n\t\trtl_write_byte(rtlpriv, REG_RESP_SIFS_OFDM + 1, val[0]);\n\t\trtl_write_byte(rtlpriv, REG_RESP_SIFS_OFDM, val[0]);\n\t\tbreak;\n\tcase HW_VAR_R2T_SIFS:\n\t\trtl_write_byte(rtlpriv, REG_RESP_SIFS_OFDM + 1, val[0]);\n\t\tbreak;\n\tcase HW_VAR_SLOT_TIME:{\n\t\tu8 e_aci;\n\n\t\trtl_dbg(rtlpriv, COMP_MLME, DBG_LOUD,\n\t\t\t\"HW_VAR_SLOT_TIME %x\\n\", val[0]);\n\n\t\trtl_write_byte(rtlpriv, REG_SLOT, val[0]);\n\n\t\tfor (e_aci = 0; e_aci < AC_MAX; e_aci++) {\n\t\t\trtlpriv->cfg->ops->set_hw_reg(hw,\n\t\t\t\t\t\t      HW_VAR_AC_PARAM,\n\t\t\t\t\t\t      (u8 *)(&e_aci));\n\t\t}\n\t\tbreak; }\n\tcase HW_VAR_ACK_PREAMBLE:{\n\t\tu8 reg_tmp;\n\t\tu8 short_preamble = (bool)(*(u8 *)val);\n\n\t\treg_tmp = rtl_read_byte(rtlpriv, REG_TRXPTCL_CTL+2);\n\t\tif (short_preamble) {\n\t\t\treg_tmp |= BIT(1);\n\t\t\trtl_write_byte(rtlpriv, REG_TRXPTCL_CTL + 2,\n\t\t\t\t       reg_tmp);\n\t\t} else {\n\t\t\treg_tmp &= (~BIT(1));\n\t\t\trtl_write_byte(rtlpriv,\n\t\t\t\tREG_TRXPTCL_CTL + 2,\n\t\t\t\treg_tmp);\n\t\t}\n\t\tbreak; }\n\tcase HW_VAR_WPA_CONFIG:\n\t\trtl_write_byte(rtlpriv, REG_SECCFG, *((u8 *)val));\n\t\tbreak;\n\tcase HW_VAR_AMPDU_MIN_SPACE:{\n\t\tu8 min_spacing_to_set;\n\t\tu8 sec_min_space;\n\n\t\tmin_spacing_to_set = *((u8 *)val);\n\t\tif (min_spacing_to_set <= 7) {\n\t\t\tsec_min_space = 0;\n\n\t\t\tif (min_spacing_to_set < sec_min_space)\n\t\t\t\tmin_spacing_to_set = sec_min_space;\n\n\t\t\tmac->min_space_cfg = ((mac->min_space_cfg &\n\t\t\t\t\t       0xf8) |\n\t\t\t\t\t      min_spacing_to_set);\n\n\t\t\t*val = min_spacing_to_set;\n\n\t\t\trtl_dbg(rtlpriv, COMP_MLME, DBG_LOUD,\n\t\t\t\t\"Set HW_VAR_AMPDU_MIN_SPACE: %#x\\n\",\n\t\t\t\tmac->min_space_cfg);\n\n\t\t\trtl_write_byte(rtlpriv, REG_AMPDU_MIN_SPACE,\n\t\t\t\t       mac->min_space_cfg);\n\t\t}\n\t\tbreak; }\n\tcase HW_VAR_SHORTGI_DENSITY:{\n\t\tu8 density_to_set;\n\n\t\tdensity_to_set = *((u8 *)val);\n\t\tmac->min_space_cfg |= (density_to_set << 3);\n\n\t\trtl_dbg(rtlpriv, COMP_MLME, DBG_LOUD,\n\t\t\t\"Set HW_VAR_SHORTGI_DENSITY: %#x\\n\",\n\t\t\tmac->min_space_cfg);\n\n\t\trtl_write_byte(rtlpriv, REG_AMPDU_MIN_SPACE,\n\t\t\t       mac->min_space_cfg);\n\n\t\tbreak; }\n\tcase HW_VAR_AMPDU_FACTOR:{\n\t\tu32\tampdu_len =  (*((u8 *)val));\n\n\t\tif (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE) {\n\t\t\tif (ampdu_len < VHT_AGG_SIZE_128K)\n\t\t\t\tampdu_len =\n\t\t\t\t\t(0x2000 << (*((u8 *)val))) - 1;\n\t\t\telse\n\t\t\t\tampdu_len = 0x1ffff;\n\t\t} else if (rtlhal->hw_type == HARDWARE_TYPE_RTL8821AE) {\n\t\t\tif (ampdu_len < HT_AGG_SIZE_64K)\n\t\t\t\tampdu_len =\n\t\t\t\t\t(0x2000 << (*((u8 *)val))) - 1;\n\t\t\telse\n\t\t\t\tampdu_len = 0xffff;\n\t\t}\n\t\tampdu_len |= BIT(31);\n\n\t\trtl_write_dword(rtlpriv,\n\t\t\tREG_AMPDU_MAX_LENGTH_8812, ampdu_len);\n\t\tbreak; }\n\tcase HW_VAR_AC_PARAM:{\n\t\tu8 e_aci = *((u8 *)val);\n\n\t\trtl8821ae_dm_init_edca_turbo(hw);\n\t\tif (rtlpci->acm_method != EACMWAY2_SW)\n\t\t\trtlpriv->cfg->ops->set_hw_reg(hw,\n\t\t\t\t\t\t      HW_VAR_ACM_CTRL,\n\t\t\t\t\t\t      (u8 *)(&e_aci));\n\t\tbreak; }\n\tcase HW_VAR_ACM_CTRL:{\n\t\tu8 e_aci = *((u8 *)val);\n\t\tunion aci_aifsn *p_aci_aifsn =\n\t\t    (union aci_aifsn *)(&mac->ac[0].aifs);\n\t\tu8 acm = p_aci_aifsn->f.acm;\n\t\tu8 acm_ctrl = rtl_read_byte(rtlpriv, REG_ACMHWCTRL);\n\n\t\tacm_ctrl =\n\t\t    acm_ctrl | ((rtlpci->acm_method == 2) ? 0x0 : 0x1);\n\n\t\tif (acm) {\n\t\t\tswitch (e_aci) {\n\t\t\tcase AC0_BE:\n\t\t\t\tacm_ctrl |= ACMHW_BEQEN;\n\t\t\t\tbreak;\n\t\t\tcase AC2_VI:\n\t\t\t\tacm_ctrl |= ACMHW_VIQEN;\n\t\t\t\tbreak;\n\t\t\tcase AC3_VO:\n\t\t\t\tacm_ctrl |= ACMHW_VOQEN;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_WARNING,\n\t\t\t\t\t\"HW_VAR_ACM_CTRL acm set failed: eACI is %d\\n\",\n\t\t\t\t\tacm);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (e_aci) {\n\t\t\tcase AC0_BE:\n\t\t\t\tacm_ctrl &= (~ACMHW_BEQEN);\n\t\t\t\tbreak;\n\t\t\tcase AC2_VI:\n\t\t\t\tacm_ctrl &= (~ACMHW_VIQEN);\n\t\t\t\tbreak;\n\t\t\tcase AC3_VO:\n\t\t\t\tacm_ctrl &= (~ACMHW_VOQEN);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_LOUD,\n\t\t\t\t\t\"switch case %#x not processed\\n\",\n\t\t\t\t\te_aci);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\trtl_dbg(rtlpriv, COMP_QOS, DBG_TRACE,\n\t\t\t\"SetHwReg8190pci(): [HW_VAR_ACM_CTRL] Write 0x%X\\n\",\n\t\t\tacm_ctrl);\n\t\trtl_write_byte(rtlpriv, REG_ACMHWCTRL, acm_ctrl);\n\t\tbreak; }\n\tcase HW_VAR_RCR:\n\t\trtl_write_dword(rtlpriv, REG_RCR, ((u32 *)(val))[0]);\n\t\trtlpci->receive_config = ((u32 *)(val))[0];\n\t\tbreak;\n\tcase HW_VAR_RETRY_LIMIT:{\n\t\tu8 retry_limit = ((u8 *)(val))[0];\n\n\t\trtl_write_word(rtlpriv, REG_RL,\n\t\t\t       retry_limit << RETRY_LIMIT_SHORT_SHIFT |\n\t\t\t       retry_limit << RETRY_LIMIT_LONG_SHIFT);\n\t\tbreak; }\n\tcase HW_VAR_DUAL_TSF_RST:\n\t\trtl_write_byte(rtlpriv, REG_DUAL_TSF_RST, (BIT(0) | BIT(1)));\n\t\tbreak;\n\tcase HW_VAR_EFUSE_BYTES:\n\t\trtlefuse->efuse_usedbytes = *((u16 *)val);\n\t\tbreak;\n\tcase HW_VAR_EFUSE_USAGE:\n\t\trtlefuse->efuse_usedpercentage = *((u8 *)val);\n\t\tbreak;\n\tcase HW_VAR_IO_CMD:\n\t\trtl8821ae_phy_set_io_cmd(hw, (*(enum io_type *)val));\n\t\tbreak;\n\tcase HW_VAR_SET_RPWM:{\n\t\tu8 rpwm_val;\n\n\t\trpwm_val = rtl_read_byte(rtlpriv, REG_PCIE_HRPWM);\n\t\tudelay(1);\n\n\t\tif (rpwm_val & BIT(7)) {\n\t\t\trtl_write_byte(rtlpriv, REG_PCIE_HRPWM,\n\t\t\t\t       (*(u8 *)val));\n\t\t} else {\n\t\t\trtl_write_byte(rtlpriv, REG_PCIE_HRPWM,\n\t\t\t\t       ((*(u8 *)val) | BIT(7)));\n\t\t}\n\n\t\tbreak; }\n\tcase HW_VAR_H2C_FW_PWRMODE:\n\t\trtl8821ae_set_fw_pwrmode_cmd(hw, (*(u8 *)val));\n\t\tbreak;\n\tcase HW_VAR_FW_PSMODE_STATUS:\n\t\tppsc->fw_current_inpsmode = *((bool *)val);\n\t\tbreak;\n\tcase HW_VAR_INIT_RTS_RATE:\n\t\tbreak;\n\tcase HW_VAR_RESUME_CLK_ON:\n\t\t_rtl8821ae_set_fw_ps_rf_on(hw);\n\t\tbreak;\n\tcase HW_VAR_FW_LPS_ACTION:{\n\t\tbool b_enter_fwlps = *((bool *)val);\n\n\t\tif (b_enter_fwlps)\n\t\t\t_rtl8821ae_fwlps_enter(hw);\n\t\t else\n\t\t\t_rtl8821ae_fwlps_leave(hw);\n\t\t break; }\n\tcase HW_VAR_H2C_FW_JOINBSSRPT:{\n\t\tu8 mstatus = (*(u8 *)val);\n\n\t\tif (mstatus == RT_MEDIA_CONNECT) {\n\t\t\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_AID,\n\t\t\t\t\t\t      NULL);\n\t\t\t_rtl8821ae_download_rsvd_page(hw, false);\n\t\t}\n\t\trtl8821ae_set_fw_media_status_rpt_cmd(hw, mstatus);\n\n\t\tbreak; }\n\tcase HW_VAR_H2C_FW_P2P_PS_OFFLOAD:\n\t\trtl8821ae_set_p2p_ps_offload_cmd(hw, (*(u8 *)val));\n\t\tbreak;\n\tcase HW_VAR_AID:{\n\t\tu16 u2btmp;\n\t\tu2btmp = rtl_read_word(rtlpriv, REG_BCN_PSR_RPT);\n\t\tu2btmp &= 0xC000;\n\t\trtl_write_word(rtlpriv, REG_BCN_PSR_RPT, (u2btmp |\n\t\t\t       mac->assoc_id));\n\t\tbreak; }\n\tcase HW_VAR_CORRECT_TSF:{\n\t\tu8 btype_ibss = ((u8 *)(val))[0];\n\n\t\tif (btype_ibss)\n\t\t\t_rtl8821ae_stop_tx_beacon(hw);\n\n\t\t_rtl8821ae_set_bcn_ctrl_reg(hw, 0, BIT(3));\n\n\t\trtl_write_dword(rtlpriv, REG_TSFTR,\n\t\t\t\t(u32)(mac->tsf & 0xffffffff));\n\t\trtl_write_dword(rtlpriv, REG_TSFTR + 4,\n\t\t\t\t(u32)((mac->tsf >> 32) & 0xffffffff));\n\n\t\t_rtl8821ae_set_bcn_ctrl_reg(hw, BIT(3), 0);\n\n\t\tif (btype_ibss)\n\t\t\t_rtl8821ae_resume_tx_beacon(hw);\n\t\tbreak; }\n\tcase HW_VAR_NAV_UPPER: {\n\t\tu32\tus_nav_upper = *(u32 *)val;\n\n\t\tif (us_nav_upper > HAL_92C_NAV_UPPER_UNIT * 0xFF) {\n\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_WARNING,\n\t\t\t\t\"The setting value (0x%08X us) of NAV_UPPER is larger than (%d * 0xFF)!!!\\n\",\n\t\t\t\tus_nav_upper, HAL_92C_NAV_UPPER_UNIT);\n\t\t\tbreak;\n\t\t}\n\t\trtl_write_byte(rtlpriv, REG_NAV_UPPER,\n\t\t\t       ((u8)((us_nav_upper +\n\t\t\t\tHAL_92C_NAV_UPPER_UNIT - 1) /\n\t\t\t\tHAL_92C_NAV_UPPER_UNIT)));\n\t\tbreak; }\n\tcase HW_VAR_KEEP_ALIVE: {\n\t\tu8 array[2];\n\t\tarray[0] = 0xff;\n\t\tarray[1] = *((u8 *)val);\n\t\trtl8821ae_fill_h2c_cmd(hw, H2C_8821AE_KEEP_ALIVE_CTRL, 2,\n\t\t\t\t       array);\n\t\tbreak; }\n\tdefault:\n\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_LOUD,\n\t\t\t\"switch case %#x not processed\\n\", variable);\n\t\tbreak;\n\t}\n}\n\nstatic bool _rtl8821ae_llt_write(struct ieee80211_hw *hw, u32 address, u32 data)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tbool status = true;\n\tlong count = 0;\n\tu32 value = _LLT_INIT_ADDR(address) | _LLT_INIT_DATA(data) |\n\t\t    _LLT_OP(_LLT_WRITE_ACCESS);\n\n\trtl_write_dword(rtlpriv, REG_LLT_INIT, value);\n\n\tdo {\n\t\tvalue = rtl_read_dword(rtlpriv, REG_LLT_INIT);\n\t\tif (_LLT_NO_ACTIVE == _LLT_OP_VALUE(value))\n\t\t\tbreak;\n\n\t\tif (count > POLLING_LLT_THRESHOLD) {\n\t\t\tpr_err(\"Failed to polling write LLT done at address %d!\\n\",\n\t\t\t       address);\n\t\t\tstatus = false;\n\t\t\tbreak;\n\t\t}\n\t} while (++count);\n\n\treturn status;\n}\n\nstatic bool _rtl8821ae_llt_table_init(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tunsigned short i;\n\tu8 txpktbuf_bndy;\n\tu32 rqpn;\n\tu8 maxpage;\n\tbool status;\n\n\tmaxpage = 255;\n\ttxpktbuf_bndy = 0xF7;\n\trqpn = 0x80e60808;\n\n\trtl_write_byte(rtlpriv, REG_TRXFF_BNDY, txpktbuf_bndy);\n\trtl_write_word(rtlpriv, REG_TRXFF_BNDY + 2, MAX_RX_DMA_BUFFER_SIZE - 1);\n\n\trtl_write_byte(rtlpriv, REG_TDECTRL + 1, txpktbuf_bndy);\n\n\trtl_write_byte(rtlpriv, REG_TXPKTBUF_BCNQ_BDNY, txpktbuf_bndy);\n\trtl_write_byte(rtlpriv, REG_TXPKTBUF_MGQ_BDNY, txpktbuf_bndy);\n\n\trtl_write_byte(rtlpriv, REG_PBP, 0x31);\n\trtl_write_byte(rtlpriv, REG_RX_DRVINFO_SZ, 0x4);\n\n\tfor (i = 0; i < (txpktbuf_bndy - 1); i++) {\n\t\tstatus = _rtl8821ae_llt_write(hw, i, i + 1);\n\t\tif (!status)\n\t\t\treturn status;\n\t}\n\n\tstatus = _rtl8821ae_llt_write(hw, (txpktbuf_bndy - 1), 0xFF);\n\tif (!status)\n\t\treturn status;\n\n\tfor (i = txpktbuf_bndy; i < maxpage; i++) {\n\t\tstatus = _rtl8821ae_llt_write(hw, i, (i + 1));\n\t\tif (!status)\n\t\t\treturn status;\n\t}\n\n\tstatus = _rtl8821ae_llt_write(hw, maxpage, txpktbuf_bndy);\n\tif (!status)\n\t\treturn status;\n\n\trtl_write_dword(rtlpriv, REG_RQPN, rqpn);\n\n\trtl_write_byte(rtlpriv, REG_RQPN_NPQ, 0x00);\n\n\treturn true;\n}\n\nstatic void _rtl8821ae_gen_refresh_led_state(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tenum rtl_led_pin pin0 = rtlpriv->ledctl.sw_led0;\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\n\tif (rtlpriv->rtlhal.up_first_time)\n\t\treturn;\n\n\tif (ppsc->rfoff_reason == RF_CHANGE_BY_IPS)\n\t\tif (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE)\n\t\t\trtl8812ae_sw_led_on(hw, pin0);\n\t\telse\n\t\t\trtl8821ae_sw_led_on(hw, pin0);\n\telse if (ppsc->rfoff_reason == RF_CHANGE_BY_INIT)\n\t\tif (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE)\n\t\t\trtl8812ae_sw_led_on(hw, pin0);\n\t\telse\n\t\t\trtl8821ae_sw_led_on(hw, pin0);\n\telse\n\t\tif (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE)\n\t\t\trtl8812ae_sw_led_off(hw, pin0);\n\t\telse\n\t\t\trtl8821ae_sw_led_off(hw, pin0);\n}\n\nstatic bool _rtl8821ae_init_mac(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\n\tu8 bytetmp = 0;\n\tu16 wordtmp = 0;\n\tbool mac_func_enable = rtlhal->mac_func_enable;\n\n\trtl_write_byte(rtlpriv, REG_RSV_CTRL, 0x00);\n\n\t \n\tbytetmp = rtl_read_byte(rtlpriv, REG_APS_FSMCO + 1) & (~BIT(7));\n\trtl_write_byte(rtlpriv, REG_APS_FSMCO + 1, bytetmp);\n\n\tif (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE) {\n\t\t \n\t\tif (!rtl_hal_pwrseqcmdparsing(rtlpriv, PWR_CUT_ALL_MSK,\n\t\t\t\t\t      PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,\n\t\t\t\t\t      RTL8812_NIC_ENABLE_FLOW)) {\n\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\t\"init 8812 MAC Fail as power on failure\\n\");\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\t \n\t\tif (!rtl_hal_pwrseqcmdparsing(rtlpriv, PWR_CUT_A_MSK,\n\t\t\t\t\t      PWR_FAB_ALL_MSK, PWR_INTF_PCI_MSK,\n\t\t\t\t\t      RTL8821A_NIC_ENABLE_FLOW)){\n\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\t\"init 8821 MAC Fail as power on failure\\n\");\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tbytetmp = rtl_read_byte(rtlpriv, REG_APS_FSMCO) | BIT(4);\n\trtl_write_byte(rtlpriv, REG_APS_FSMCO, bytetmp);\n\n\tbytetmp = rtl_read_byte(rtlpriv, REG_CR);\n\tbytetmp = 0xff;\n\trtl_write_byte(rtlpriv, REG_CR, bytetmp);\n\tmdelay(2);\n\n\tbytetmp = 0xff;\n\trtl_write_byte(rtlpriv, REG_HWSEQ_CTRL, bytetmp);\n\tmdelay(2);\n\n\tif (rtlhal->hw_type == HARDWARE_TYPE_RTL8821AE) {\n\t\tbytetmp = rtl_read_byte(rtlpriv, REG_SYS_CFG + 3);\n\t\tif (bytetmp & BIT(0)) {\n\t\t\tbytetmp = rtl_read_byte(rtlpriv, 0x7c);\n\t\t\tbytetmp |= BIT(6);\n\t\t\trtl_write_byte(rtlpriv, 0x7c, bytetmp);\n\t\t}\n\t}\n\n\tbytetmp = rtl_read_byte(rtlpriv, REG_GPIO_MUXCFG + 1);\n\tbytetmp &= ~BIT(4);\n\trtl_write_byte(rtlpriv, REG_GPIO_MUXCFG + 1, bytetmp);\n\n\trtl_write_word(rtlpriv, REG_CR, 0x2ff);\n\n\tif (!mac_func_enable) {\n\t\tif (!_rtl8821ae_llt_table_init(hw))\n\t\t\treturn false;\n\t}\n\n\trtl_write_dword(rtlpriv, REG_HISR, 0xffffffff);\n\trtl_write_dword(rtlpriv, REG_HISRE, 0xffffffff);\n\n\t \n\tbytetmp = rtl_read_byte(rtlpriv, REG_FWIMR + 3);\n\trtl_write_byte(rtlpriv, REG_FWIMR + 3, bytetmp | BIT(6));\n\n\twordtmp = rtl_read_word(rtlpriv, REG_TRXDMA_CTRL);\n\twordtmp &= 0xf;\n\twordtmp |= 0xF5B1;\n\trtl_write_word(rtlpriv, REG_TRXDMA_CTRL, wordtmp);\n\n\trtl_write_byte(rtlpriv, REG_FWHW_TXQ_CTRL + 1, 0x1F);\n\trtl_write_dword(rtlpriv, REG_RCR, rtlpci->receive_config);\n\trtl_write_word(rtlpriv, REG_RXFLTMAP2, 0xFFFF);\n\t \n\trtl_write_dword(rtlpriv, REG_BCNQ_DESA,\n\t\t\trtlpci->tx_ring[BEACON_QUEUE].dma & DMA_BIT_MASK(32));\n\trtl_write_dword(rtlpriv, REG_MGQ_DESA,\n\t\t\trtlpci->tx_ring[MGNT_QUEUE].dma & DMA_BIT_MASK(32));\n\trtl_write_dword(rtlpriv, REG_VOQ_DESA,\n\t\t\trtlpci->tx_ring[VO_QUEUE].dma & DMA_BIT_MASK(32));\n\trtl_write_dword(rtlpriv, REG_VIQ_DESA,\n\t\t\trtlpci->tx_ring[VI_QUEUE].dma & DMA_BIT_MASK(32));\n\trtl_write_dword(rtlpriv, REG_BEQ_DESA,\n\t\t\trtlpci->tx_ring[BE_QUEUE].dma & DMA_BIT_MASK(32));\n\trtl_write_dword(rtlpriv, REG_BKQ_DESA,\n\t\t\trtlpci->tx_ring[BK_QUEUE].dma & DMA_BIT_MASK(32));\n\trtl_write_dword(rtlpriv, REG_HQ_DESA,\n\t\t\trtlpci->tx_ring[HIGH_QUEUE].dma & DMA_BIT_MASK(32));\n\trtl_write_dword(rtlpriv, REG_RX_DESA,\n\t\t\trtlpci->rx_ring[RX_MPDU_QUEUE].dma & DMA_BIT_MASK(32));\n\n\trtl_write_byte(rtlpriv, REG_PCIE_CTRL_REG + 3, 0x77);\n\n\trtl_write_dword(rtlpriv, REG_INT_MIG, 0);\n\n\trtl_write_dword(rtlpriv, REG_MCUTST_1, 0);\n\n\trtl_write_byte(rtlpriv, REG_SECONDARY_CCA_CTRL, 0x3);\n\t_rtl8821ae_gen_refresh_led_state(hw);\n\n\treturn true;\n}\n\nstatic void _rtl8821ae_hw_configure(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tu32 reg_rrsr;\n\n\treg_rrsr = RATE_ALL_CCK | RATE_ALL_OFDM_AG;\n\n\trtl_write_dword(rtlpriv, REG_RRSR, reg_rrsr);\n\t \n\trtl_write_dword(rtlpriv, REG_ARFR0 + 4, 0xfffff000);\n\t \n\trtl_write_dword(rtlpriv, REG_ARFR1 + 4, 0x003ff000);\n\t \n\trtl_write_dword(rtlpriv, REG_ARFR2, 0x00000015);\n\trtl_write_dword(rtlpriv, REG_ARFR2 + 4, 0x003ff000);\n\t \n\trtl_write_dword(rtlpriv, REG_ARFR3, 0x00000015);\n\trtl_write_dword(rtlpriv, REG_ARFR3 + 4, 0xffcff000);\n\t \n\trtl_write_word(rtlpriv, REG_FWHW_TXQ_CTRL, 0x1F00);\n\trtl_write_byte(rtlpriv, REG_AMPDU_MAX_TIME, 0x70);\n\n\t \n\trtl_write_word(rtlpriv, REG_RL, 0x0707);\n\n\t \n\trtl_write_dword(rtlpriv, REG_DARFRC, 0x01000000);\n\trtl_write_dword(rtlpriv, REG_DARFRC + 4, 0x07060504);\n\trtl_write_dword(rtlpriv, REG_RARFRC, 0x01000000);\n\trtl_write_dword(rtlpriv, REG_RARFRC + 4, 0x07060504);\n\n\trtlpci->reg_bcn_ctrl_val = 0x1d;\n\trtl_write_byte(rtlpriv, REG_BCN_CTRL, rtlpci->reg_bcn_ctrl_val);\n\n\t \n\trtl_write_byte(rtlpriv, REG_TBTT_PROHIBIT + 1, 0xff);\n\n\t \n\trtl_write_word(rtlpriv, REG_NAV_PROT_LEN, 0x0040);\n\n\t \n\trtl_write_dword(rtlpriv, REG_FAST_EDCA_CTRL, 0x03086666);\n\n\trtl_write_byte(rtlpriv, REG_HT_SINGLE_AMPDU, 0x80);\n\trtl_write_byte(rtlpriv, REG_RX_PKT_LIMIT, 0x20);\n\trtl_write_word(rtlpriv, REG_MAX_AGGR_NUM, 0x1F1F);\n}\n\nstatic u16 _rtl8821ae_mdio_read(struct rtl_priv *rtlpriv, u8 addr)\n{\n\tu16 ret = 0;\n\tu8 tmp = 0, count = 0;\n\n\trtl_write_byte(rtlpriv, REG_MDIO_CTL, addr | BIT(6));\n\ttmp = rtl_read_byte(rtlpriv, REG_MDIO_CTL) & BIT(6);\n\tcount = 0;\n\twhile (tmp && count < 20) {\n\t\tudelay(10);\n\t\ttmp = rtl_read_byte(rtlpriv, REG_MDIO_CTL) & BIT(6);\n\t\tcount++;\n\t}\n\tif (0 == tmp)\n\t\tret = rtl_read_word(rtlpriv, REG_MDIO_RDATA);\n\n\treturn ret;\n}\n\nstatic void _rtl8821ae_mdio_write(struct rtl_priv *rtlpriv, u8 addr, u16 data)\n{\n\tu8 tmp = 0, count = 0;\n\n\trtl_write_word(rtlpriv, REG_MDIO_WDATA, data);\n\trtl_write_byte(rtlpriv, REG_MDIO_CTL, addr | BIT(5));\n\ttmp = rtl_read_byte(rtlpriv, REG_MDIO_CTL) & BIT(5);\n\tcount = 0;\n\twhile (tmp && count < 20) {\n\t\tudelay(10);\n\t\ttmp = rtl_read_byte(rtlpriv, REG_MDIO_CTL) & BIT(5);\n\t\tcount++;\n\t}\n}\n\nstatic u8 _rtl8821ae_dbi_read(struct rtl_priv *rtlpriv, u16 addr)\n{\n\tu16 read_addr = addr & 0xfffc;\n\tu8 tmp = 0, count = 0, ret = 0;\n\n\trtl_write_word(rtlpriv, REG_DBI_ADDR, read_addr);\n\trtl_write_byte(rtlpriv, REG_DBI_FLAG, 0x2);\n\ttmp = rtl_read_byte(rtlpriv, REG_DBI_FLAG);\n\tcount = 0;\n\twhile (tmp && count < 20) {\n\t\tudelay(10);\n\t\ttmp = rtl_read_byte(rtlpriv, REG_DBI_FLAG);\n\t\tcount++;\n\t}\n\tif (0 == tmp) {\n\t\tread_addr = REG_DBI_RDATA + addr % 4;\n\t\tret = rtl_read_byte(rtlpriv, read_addr);\n\t}\n\treturn ret;\n}\n\nstatic void _rtl8821ae_dbi_write(struct rtl_priv *rtlpriv, u16 addr, u8 data)\n{\n\tu8 tmp = 0, count = 0;\n\tu16 write_addr, remainder = addr % 4;\n\n\twrite_addr = REG_DBI_WDATA + remainder;\n\trtl_write_byte(rtlpriv, write_addr, data);\n\n\twrite_addr = (addr & 0xfffc) | (BIT(0) << (remainder + 12));\n\trtl_write_word(rtlpriv, REG_DBI_ADDR, write_addr);\n\n\trtl_write_byte(rtlpriv, REG_DBI_FLAG, 0x1);\n\n\ttmp = rtl_read_byte(rtlpriv, REG_DBI_FLAG);\n\tcount = 0;\n\twhile (tmp && count < 20) {\n\t\tudelay(10);\n\t\ttmp = rtl_read_byte(rtlpriv, REG_DBI_FLAG);\n\t\tcount++;\n\t}\n}\n\nstatic void _rtl8821ae_enable_aspm_back_door(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tu8 tmp;\n\n\tif (rtlhal->hw_type == HARDWARE_TYPE_RTL8821AE) {\n\t\tif (_rtl8821ae_mdio_read(rtlpriv, 0x04) != 0x8544)\n\t\t\t_rtl8821ae_mdio_write(rtlpriv, 0x04, 0x8544);\n\n\t\tif (_rtl8821ae_mdio_read(rtlpriv, 0x0b) != 0x0070)\n\t\t\t_rtl8821ae_mdio_write(rtlpriv, 0x0b, 0x0070);\n\t}\n\n\ttmp = _rtl8821ae_dbi_read(rtlpriv, 0x70f);\n\t_rtl8821ae_dbi_write(rtlpriv, 0x70f, tmp | BIT(7) |\n\t\t\t     ASPM_L1_LATENCY << 3);\n\n\ttmp = _rtl8821ae_dbi_read(rtlpriv, 0x719);\n\t_rtl8821ae_dbi_write(rtlpriv, 0x719, tmp | BIT(3) | BIT(4));\n\n\tif (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE) {\n\t\ttmp  = _rtl8821ae_dbi_read(rtlpriv, 0x718);\n\t\t_rtl8821ae_dbi_write(rtlpriv, 0x718, tmp|BIT(4));\n\t}\n}\n\nvoid rtl8821ae_enable_hw_security_config(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 sec_reg_value;\n\tu8 tmp;\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG,\n\t\t\"PairwiseEncAlgorithm = %d GroupEncAlgorithm = %d\\n\",\n\t\trtlpriv->sec.pairwise_enc_algorithm,\n\t\trtlpriv->sec.group_enc_algorithm);\n\n\tif (rtlpriv->cfg->mod_params->sw_crypto || rtlpriv->sec.use_sw_sec) {\n\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_DMESG,\n\t\t\t\"not open hw encryption\\n\");\n\t\treturn;\n\t}\n\n\tsec_reg_value = SCR_TXENCENABLE | SCR_RXDECENABLE;\n\n\tif (rtlpriv->sec.use_defaultkey) {\n\t\tsec_reg_value |= SCR_TXUSEDK;\n\t\tsec_reg_value |= SCR_RXUSEDK;\n\t}\n\n\tsec_reg_value |= (SCR_RXBCUSEDK | SCR_TXBCUSEDK);\n\n\ttmp = rtl_read_byte(rtlpriv, REG_CR + 1);\n\trtl_write_byte(rtlpriv, REG_CR + 1, tmp | BIT(1));\n\n\trtl_dbg(rtlpriv, COMP_SEC, DBG_DMESG,\n\t\t\"The SECR-value %x\\n\", sec_reg_value);\n\n\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_WPA_CONFIG, &sec_reg_value);\n}\n\n \n#define MAC_ID_STATIC_FOR_DEFAULT_PORT\t\t\t\t0\n#define MAC_ID_STATIC_FOR_BROADCAST_MULTICAST\t\t1\n#define MAC_ID_STATIC_FOR_BT_CLIENT_START\t\t\t\t2\n#define MAC_ID_STATIC_FOR_BT_CLIENT_END\t\t\t\t3\n \n\nstatic void rtl8821ae_macid_initialize_mediastatus(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8\tmedia_rpt[4] = {RT_MEDIA_CONNECT, 1,\n\t\tMAC_ID_STATIC_FOR_BROADCAST_MULTICAST,\n\t\tMAC_ID_STATIC_FOR_BT_CLIENT_END};\n\n\trtlpriv->cfg->ops->set_hw_reg(hw,\n\t\tHW_VAR_H2C_FW_MEDIASTATUSRPT, media_rpt);\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\"Initialize MacId media status: from %d to %d\\n\",\n\t\tMAC_ID_STATIC_FOR_BROADCAST_MULTICAST,\n\t\tMAC_ID_STATIC_FOR_BT_CLIENT_END);\n}\n\nstatic bool _rtl8821ae_check_pcie_dma_hang(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 tmp;\n\n\t \n\ttmp = rtl_read_byte(rtlpriv, REG_DBI_CTRL + 3);\n\tif (!(tmp & BIT(2))) {\n\t\trtl_write_byte(rtlpriv, REG_DBI_CTRL + 3, (tmp | BIT(2)));\n\t\tmdelay(100);\n\t}\n\n\t \n\t \n\ttmp = rtl_read_byte(rtlpriv, REG_DBI_CTRL + 3);\n\tif ((tmp & BIT(0)) || (tmp & BIT(1))) {\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\"CheckPcieDMAHang8821AE(): true! Reset PCIE DMA!\\n\");\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n\nstatic bool _rtl8821ae_reset_pcie_interface_dma(struct ieee80211_hw *hw,\n\t\t\t\t\t bool mac_power_on,\n\t\t\t\t\t bool in_watchdog)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tu8 tmp;\n\tbool release_mac_rx_pause;\n\tu8 backup_pcie_dma_pause;\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD, \"\\n\");\n\n\t \n\ttmp = rtl_read_byte(rtlpriv, REG_RSV_CTRL);\n\ttmp &= ~(BIT(1));\n\trtl_write_byte(rtlpriv, REG_RSV_CTRL, tmp);\n\tif (rtlhal->hw_type == HARDWARE_TYPE_RTL8821AE) {\n\t\t \n\t\ttmp = rtl_read_byte(rtlpriv, REG_PMC_DBG_CTRL2);\n\t\ttmp |= BIT(2);\n\t\trtl_write_byte(rtlpriv, REG_PMC_DBG_CTRL2, tmp);\n\t}\n\n\t \n\t \n\t \n\ttmp = rtl_read_byte(rtlpriv, REG_RXDMA_CONTROL);\n\tif (tmp & BIT(2)) {\n\t\t \n\t\trelease_mac_rx_pause = false;\n\t} else {\n\t\trtl_write_byte(rtlpriv, REG_RXDMA_CONTROL, (tmp | BIT(2)));\n\t\trelease_mac_rx_pause = true;\n\t}\n\tbackup_pcie_dma_pause = rtl_read_byte(rtlpriv, REG_PCIE_CTRL_REG + 1);\n\tif (backup_pcie_dma_pause != 0xFF)\n\t\trtl_write_byte(rtlpriv, REG_PCIE_CTRL_REG + 1, 0xFF);\n\n\tif (mac_power_on) {\n\t\t \n\t\t \n\t\trtl_write_byte(rtlpriv, REG_CR, 0);\n\t}\n\n\t \n\ttmp = rtl_read_byte(rtlpriv, REG_SYS_FUNC_EN + 1);\n\ttmp &= ~(BIT(0));\n\trtl_write_byte(rtlpriv, REG_SYS_FUNC_EN + 1, tmp);\n\n\t \n\ttmp = rtl_read_byte(rtlpriv, REG_SYS_FUNC_EN + 1);\n\ttmp |= BIT(0);\n\trtl_write_byte(rtlpriv, REG_SYS_FUNC_EN + 1, tmp);\n\n\tif (mac_power_on) {\n\t\t \n\t\t \n\t\trtl_write_byte(rtlpriv, REG_CR, 0xFF);\n\n\t\t \n\t}\n\n\t \n\t \n\tif (rtlhal->hw_type == HARDWARE_TYPE_RTL8821AE) {\n\t\t \n\t\ttmp = rtl_read_byte(rtlpriv, REG_MAC_PHY_CTRL_NORMAL + 2);\n\t\ttmp |= BIT(1);\n\t\trtl_write_byte(rtlpriv, REG_MAC_PHY_CTRL_NORMAL + 2, tmp);\n\t}\n\n\t \n\tif (!mac_power_on ) {\n\t\t \n\t\t \n\t\t \n\t\tif (release_mac_rx_pause) {\n\t\t\ttmp = rtl_read_byte(rtlpriv, REG_RXDMA_CONTROL);\n\t\t\trtl_write_byte(rtlpriv, REG_RXDMA_CONTROL,\n\t\t\t\t       tmp & (~BIT(2)));\n\t\t}\n\t\trtl_write_byte(rtlpriv, REG_PCIE_CTRL_REG + 1,\n\t\t\t       backup_pcie_dma_pause);\n\t}\n\n\tif (rtlhal->hw_type == HARDWARE_TYPE_RTL8821AE) {\n\t\t \n\t\t \n\t\ttmp = rtl_read_byte(rtlpriv, REG_PMC_DBG_CTRL2);\n\t\ttmp &= ~(BIT(2));\n\t\trtl_write_byte(rtlpriv, REG_PMC_DBG_CTRL2, tmp);\n\t}\n\treturn true;\n}\n\nstatic void _rtl8821ae_get_wakeup_reason(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtlpriv);\n\tu8 fw_reason = 0;\n\n\tfw_reason = rtl_read_byte(rtlpriv, REG_MCUTST_WOWLAN);\n\n\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD, \"WOL Read 0x1c7 = %02X\\n\",\n\t\tfw_reason);\n\n\tppsc->wakeup_reason = 0;\n\n\trtlhal->last_suspend_sec = ktime_get_real_seconds();\n\n\tswitch (fw_reason) {\n\tcase FW_WOW_V2_PTK_UPDATE_EVENT:\n\t\tppsc->wakeup_reason = WOL_REASON_PTK_UPDATE;\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_DMESG,\n\t\t\t\"It's a WOL PTK Key update event!\\n\");\n\t\tbreak;\n\tcase FW_WOW_V2_GTK_UPDATE_EVENT:\n\t\tppsc->wakeup_reason = WOL_REASON_GTK_UPDATE;\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_DMESG,\n\t\t\t\"It's a WOL GTK Key update event!\\n\");\n\t\tbreak;\n\tcase FW_WOW_V2_DISASSOC_EVENT:\n\t\tppsc->wakeup_reason = WOL_REASON_DISASSOC;\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_DMESG,\n\t\t\t\"It's a disassociation event!\\n\");\n\t\tbreak;\n\tcase FW_WOW_V2_DEAUTH_EVENT:\n\t\tppsc->wakeup_reason = WOL_REASON_DEAUTH;\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_DMESG,\n\t\t\t\"It's a deauth event!\\n\");\n\t\tbreak;\n\tcase FW_WOW_V2_FW_DISCONNECT_EVENT:\n\t\tppsc->wakeup_reason = WOL_REASON_AP_LOST;\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_DMESG,\n\t\t\t\"It's a Fw disconnect decision (AP lost) event!\\n\");\n\tbreak;\n\tcase FW_WOW_V2_MAGIC_PKT_EVENT:\n\t\tppsc->wakeup_reason = WOL_REASON_MAGIC_PKT;\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_DMESG,\n\t\t\t\"It's a magic packet event!\\n\");\n\t\tbreak;\n\tcase FW_WOW_V2_UNICAST_PKT_EVENT:\n\t\tppsc->wakeup_reason = WOL_REASON_UNICAST_PKT;\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_DMESG,\n\t\t\t\"It's an unicast packet event!\\n\");\n\t\tbreak;\n\tcase FW_WOW_V2_PATTERN_PKT_EVENT:\n\t\tppsc->wakeup_reason = WOL_REASON_PATTERN_PKT;\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_DMESG,\n\t\t\t\"It's a pattern match event!\\n\");\n\t\tbreak;\n\tcase FW_WOW_V2_RTD3_SSID_MATCH_EVENT:\n\t\tppsc->wakeup_reason = WOL_REASON_RTD3_SSID_MATCH;\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_DMESG,\n\t\t\t\"It's an RTD3 Ssid match event!\\n\");\n\t\tbreak;\n\tcase FW_WOW_V2_REALWOW_V2_WAKEUPPKT:\n\t\tppsc->wakeup_reason = WOL_REASON_REALWOW_V2_WAKEUPPKT;\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_DMESG,\n\t\t\t\"It's an RealWoW wake packet event!\\n\");\n\t\tbreak;\n\tcase FW_WOW_V2_REALWOW_V2_ACKLOST:\n\t\tppsc->wakeup_reason = WOL_REASON_REALWOW_V2_ACKLOST;\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_DMESG,\n\t\t\t\"It's an RealWoW ack lost event!\\n\");\n\t\tbreak;\n\tdefault:\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_DMESG,\n\t\t\t\"WOL Read 0x1c7 = %02X, Unknown reason!\\n\",\n\t\t\tfw_reason);\n\t\tbreak;\n\t}\n}\n\nstatic void _rtl8821ae_init_trx_desc_hw_address(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\n\t \n\trtl_write_dword(rtlpriv, REG_BCNQ_DESA,\n\t\t\trtlpci->tx_ring[BEACON_QUEUE].dma & DMA_BIT_MASK(32));\n\trtl_write_dword(rtlpriv, REG_MGQ_DESA,\n\t\t\trtlpci->tx_ring[MGNT_QUEUE].dma & DMA_BIT_MASK(32));\n\trtl_write_dword(rtlpriv, REG_VOQ_DESA,\n\t\t\trtlpci->tx_ring[VO_QUEUE].dma & DMA_BIT_MASK(32));\n\trtl_write_dword(rtlpriv, REG_VIQ_DESA,\n\t\t\trtlpci->tx_ring[VI_QUEUE].dma & DMA_BIT_MASK(32));\n\trtl_write_dword(rtlpriv, REG_BEQ_DESA,\n\t\t\trtlpci->tx_ring[BE_QUEUE].dma & DMA_BIT_MASK(32));\n\trtl_write_dword(rtlpriv, REG_BKQ_DESA,\n\t\t\trtlpci->tx_ring[BK_QUEUE].dma & DMA_BIT_MASK(32));\n\trtl_write_dword(rtlpriv, REG_HQ_DESA,\n\t\t\trtlpci->tx_ring[HIGH_QUEUE].dma & DMA_BIT_MASK(32));\n\trtl_write_dword(rtlpriv, REG_RX_DESA,\n\t\t\trtlpci->rx_ring[RX_MPDU_QUEUE].dma & DMA_BIT_MASK(32));\n}\n\nstatic bool _rtl8821ae_init_llt_table(struct ieee80211_hw *hw, u32 boundary)\n{\n\tbool status = true;\n\tu32 i;\n\tu32 txpktbuf_bndy = boundary;\n\tu32 last_entry_of_txpktbuf = LAST_ENTRY_OF_TX_PKT_BUFFER;\n\n\tfor (i = 0 ; i < (txpktbuf_bndy - 1) ; i++) {\n\t\tstatus = _rtl8821ae_llt_write(hw, i , i + 1);\n\t\tif (!status)\n\t\t\treturn status;\n\t}\n\n\tstatus = _rtl8821ae_llt_write(hw, (txpktbuf_bndy - 1), 0xFF);\n\tif (!status)\n\t\treturn status;\n\n\tfor (i = txpktbuf_bndy ; i < last_entry_of_txpktbuf ; i++) {\n\t\tstatus = _rtl8821ae_llt_write(hw, i, (i + 1));\n\t\tif (!status)\n\t\t\treturn status;\n\t}\n\n\tstatus = _rtl8821ae_llt_write(hw, last_entry_of_txpktbuf,\n\t\t\t\t      txpktbuf_bndy);\n\tif (!status)\n\t\treturn status;\n\n\treturn status;\n}\n\nstatic bool _rtl8821ae_dynamic_rqpn(struct ieee80211_hw *hw, u32 boundary,\n\t\t\t     u16 npq_rqpn_value, u32 rqpn_val)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 tmp;\n\tbool ret = true;\n\tu16 count = 0, tmp16;\n\tbool support_remote_wakeup;\n\n\trtlpriv->cfg->ops->get_hw_reg(hw, HAL_DEF_WOWLAN,\n\t\t\t\t      (u8 *)(&support_remote_wakeup));\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\"boundary=%#X, NPQ_RQPNValue=%#X, RQPNValue=%#X\\n\",\n\t\tboundary, npq_rqpn_value, rqpn_val);\n\n\t \n\trtl_write_byte(rtlpriv, REG_PCIE_CTRL_REG + 1, 0xFE);\n\n\t \n\ttmp16 = rtl_read_word(rtlpriv, REG_TXPKT_EMPTY);\n\twhile ((tmp16 & 0x07FF) != 0x07FF) {\n\t\tudelay(100);\n\t\ttmp16 = rtl_read_word(rtlpriv, REG_TXPKT_EMPTY);\n\t\tcount++;\n\t\tif ((count % 200) == 0) {\n\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\t\"Tx queue is not empty for 20ms!\\n\");\n\t\t}\n\t\tif (count >= 1000) {\n\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\t\"Wait for Tx FIFO empty timeout!\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\trtl_write_byte(rtlpriv, REG_TXPAUSE, 0xFF);\n\n\t \n\tcount = 0;\n\twhile (rtl_read_byte(rtlpriv, REG_SCH_TXCMD) != 0) {\n\t\tudelay(100);\n\t\tcount++;\n\t\tif (count >= 500) {\n\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\t\"Wait for TX State Machine ready timeout !!\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tcount = 0;\n\ttmp = rtl_read_byte(rtlpriv, REG_RXDMA_CONTROL);\n\trtl_write_byte(rtlpriv, REG_RXDMA_CONTROL, (tmp | BIT(2)));\n\tdo {\n\t\ttmp = rtl_read_byte(rtlpriv, REG_RXDMA_CONTROL);\n\t\tudelay(10);\n\t\tcount++;\n\t} while (!(tmp & BIT(1)) && count < 100);\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\"Wait until Rx DMA Idle. count=%d REG[0x286]=0x%x\\n\",\n\t\tcount, tmp);\n\n\t \n\ttmp = rtl_read_byte(rtlpriv, REG_SYS_FUNC_EN);\n\ttmp &= ~(BIT(0));\n\trtl_write_byte(rtlpriv, REG_SYS_FUNC_EN, tmp);\n\n\t \n\trtl_write_byte(rtlpriv, REG_CR, 0x00);\n\tudelay(1000);\n\n\t \n\ttmp = rtl_read_byte(rtlpriv, REG_CR + 1);\n\ttmp &= ~(BIT(1));\n\trtl_write_byte(rtlpriv, REG_CR + 1, tmp);\n\n\t \n\ttmp = rtl_read_byte(rtlpriv, REG_DUAL_TSF_RST);\n\trtl_write_byte(rtlpriv, REG_DUAL_TSF_RST, (tmp | BIT(5)));\n\n\t \n\ttmp = rtl_read_byte(rtlpriv, REG_CR + 1);\n\trtl_write_byte(rtlpriv, REG_CR + 1, (tmp | BIT(1)));\n\n\t \n\trtl_write_byte(rtlpriv, REG_CR, 0xFF);\n\tudelay(1000);\n\n\t \n\ttmp = rtl_read_byte(rtlpriv, REG_SYS_FUNC_EN);\n\trtl_write_byte(rtlpriv, REG_SYS_FUNC_EN, (tmp | BIT(0)));\n\n\t \n\trtl_write_byte(rtlpriv, REG_TDECTRL + 1, (u8)boundary);\n\trtl_write_byte(rtlpriv, REG_TXPKTBUF_BCNQ_BDNY, (u8)boundary);\n\trtl_write_byte(rtlpriv, REG_TXPKTBUF_MGQ_BDNY, (u8)boundary);\n\n\t \n\trtl_write_byte(rtlpriv, REG_TXPKTBUF_WMAC_LBK_BF_HD,\n\t\t       (u8)boundary);\n\n\trtl_write_word(rtlpriv, REG_TRXFF_BNDY, boundary);\n\n\t \n\tif (!_rtl8821ae_init_llt_table(hw, boundary)) {\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_WARNING,\n\t\t\t\"Failed to init LLT table!\\n\");\n\t\treturn false;\n\t}\n\n\t \n\trtl_write_word(rtlpriv, REG_RQPN_NPQ, npq_rqpn_value);\n\trtl_write_dword(rtlpriv, REG_RQPN, rqpn_val);\n\n\t \n\trtl_write_byte(rtlpriv, REG_TXPAUSE, 0x00);\n\n\t \n\trtl_write_byte(rtlpriv, REG_PCIE_CTRL_REG + 1, 0x00);\n\ttmp = rtl_read_byte(rtlpriv, REG_RXDMA_CONTROL);\n\trtl_write_byte(rtlpriv, REG_RXDMA_CONTROL, (tmp&~BIT(2)));\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD, \"End.\\n\");\n\treturn ret;\n}\n\nstatic void _rtl8821ae_simple_initialize_adapter(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtlpriv);\n\n#if (USE_SPECIFIC_FW_TO_SUPPORT_WOWLAN == 1)\n\t \n\trtl8821ae_set_fw_related_for_wowlan(hw, false);\n#endif\n\n\t \n\tif (rtlhal->re_init_llt_table) {\n\t\tu32 rqpn = 0x80e70808;\n\t\tu8 rqpn_npq = 0, boundary = 0xF8;\n\t\tif (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE) {\n\t\t\trqpn = 0x80e90808;\n\t\t\tboundary = 0xFA;\n\t\t}\n\t\tif (_rtl8821ae_dynamic_rqpn(hw, boundary, rqpn_npq, rqpn))\n\t\t\trtlhal->re_init_llt_table = false;\n\t}\n\n\tppsc->rfpwr_state = ERFON;\n}\n\nstatic void _rtl8821ae_enable_l1off(struct ieee80211_hw *hw)\n{\n\tu8 tmp  = 0;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD, \"--->\\n\");\n\n\ttmp = _rtl8821ae_dbi_read(rtlpriv, 0x160);\n\tif (!(tmp & (BIT(2) | BIT(3)))) {\n\t\trtl_dbg(rtlpriv, COMP_POWER | COMP_INIT, DBG_LOUD,\n\t\t\t\"0x160(%#x)return!!\\n\", tmp);\n\t\treturn;\n\t}\n\n\ttmp = _rtl8821ae_mdio_read(rtlpriv, 0x1b);\n\t_rtl8821ae_mdio_write(rtlpriv, 0x1b, (tmp | BIT(4)));\n\n\ttmp = _rtl8821ae_dbi_read(rtlpriv, 0x718);\n\t_rtl8821ae_dbi_write(rtlpriv, 0x718, tmp | BIT(5));\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD, \"<---\\n\");\n}\n\nstatic void _rtl8821ae_enable_ltr(struct ieee80211_hw *hw)\n{\n\tu8 tmp  = 0;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD, \"--->\\n\");\n\n\t \n\ttmp = _rtl8821ae_dbi_read(rtlpriv, 0x99);\n\tif (!(tmp & BIT(2))) {\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\"<---0x99(%#x) return!!\\n\", tmp);\n\t\treturn;\n\t}\n\n\t \n\trtl_write_dword(rtlpriv, 0x798, 0x88908890);\n\n\t \n\trtl_write_dword(rtlpriv, 0x79c, 0x883c883c);\n\n\ttmp = rtl_read_byte(rtlpriv, 0x7a4);\n\trtl_write_byte(rtlpriv, 0x7a4, (tmp | BIT(4)));\n\n\ttmp = rtl_read_byte(rtlpriv, 0x7a4);\n\trtl_write_byte(rtlpriv, 0x7a4, (tmp & (~BIT(0))));\n\trtl_write_byte(rtlpriv, 0x7a4, (tmp | BIT(0)));\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD, \"<---\\n\");\n}\n\nstatic bool _rtl8821ae_wowlan_initialize_adapter(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\n\tbool init_finished = true;\n\tu8 tmp = 0;\n\n\t \n\t_rtl8821ae_get_wakeup_reason(hw);\n\n\t \n\tif (_rtl8821ae_check_pcie_dma_hang(hw))\n\t\t_rtl8821ae_reset_pcie_interface_dma(hw, true, false);\n\n\t \n\t_rtl8821ae_init_trx_desc_hw_address(hw);\n\n\t \n\trtl_write_byte(rtlpriv, REG_PCIE_CTRL_REG + 1, 0xFE);\n\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD, \"Enable PCIE Rx DMA.\\n\");\n\n\t \n\ttmp = rtl_read_byte(rtlpriv, REG_FTISR + 3);\n\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD,\n\t\t\"Read REG_FTISR 0x13f = %#X\\n\", tmp);\n\n\t \n\trtl8821ae_set_fw_wowlan_mode(hw, false);\n\trtl8821ae_set_fw_remote_wake_ctrl_cmd(hw, 0);\n\n\tif (rtlhal->hw_rof_enable) {\n\t\ttmp = rtl_read_byte(rtlpriv, REG_HSISR + 3);\n\t\tif (tmp & BIT(1)) {\n\t\t\t \n\t\t\trtl_write_byte(rtlpriv, REG_HSISR + 3, tmp | BIT(1));\n\t\t\tinit_finished = false;\n\t\t} else {\n\t\t\tinit_finished = true;\n\t\t}\n\t}\n\n\tif (init_finished) {\n\t\t_rtl8821ae_simple_initialize_adapter(hw);\n\n\t\t \n\t\trtl_write_byte(rtlpriv, REG_PCIE_CTRL_REG + 1, 0x00);\n\t\t \n\t\trtl_write_byte(rtlpriv, REG_RXDMA_CONTROL, 0x02);\n\n\t\ttmp = rtl_read_byte(rtlpriv, REG_CR + 1);\n\t\trtl_write_byte(rtlpriv, REG_CR + 1, (tmp & (~BIT(0))));\n\n\t\t_rtl8821ae_enable_l1off(hw);\n\t\t_rtl8821ae_enable_ltr(hw);\n\t}\n\n\treturn init_finished;\n}\n\nstatic void _rtl8812ae_bb8812_config_1t(struct ieee80211_hw *hw)\n{\n\t \n\trtl_set_bbreg(hw, 0x808, 0xff, 0x11);\n\t \n\trtl_set_bbreg(hw, 0x80c, MASKLWORD, 0x1111);\n\t \n\trtl_set_bbreg(hw, 0xa04, 0x0c000000, 0x0);\n\t \n\trtl_set_bbreg(hw, 0x8bc, 0xc0000060, 0x4);\n\t \n\trtl_set_bbreg(hw, 0xe00, 0xf, 0x4);\n\t \n\trtl_set_bbreg(hw, 0xe90, MASKDWORD, 0);\n\t \n\trtl_set_bbreg(hw, 0xe60, MASKDWORD, 0);\n\trtl_set_bbreg(hw, 0xe64, MASKDWORD, 0);\n}\n\nstatic void _rtl8821ae_poweroff_adapter(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tu8 u1b_tmp;\n\n\trtlhal->mac_func_enable = false;\n\n\tif (rtlhal->hw_type == HARDWARE_TYPE_RTL8821AE) {\n\t\t \n\t\t \n\t\t \n\t\trtl_hal_pwrseqcmdparsing(rtlpriv,\n\t\t\tPWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK,\n\t\t\tPWR_INTF_PCI_MSK, RTL8821A_NIC_LPS_ENTER_FLOW);\n\t}\n\t \n\t \n\t \n\tif ((rtl_read_byte(rtlpriv, REG_MCUFWDL) & BIT(7)) &&\n\t\trtlhal->fw_ready) {\n\t\trtl8821ae_firmware_selfreset(hw);\n\t}\n\n\t \n\tu1b_tmp = rtl_read_byte(rtlpriv, REG_SYS_FUNC_EN+1);\n\trtl_write_byte(rtlpriv, REG_SYS_FUNC_EN+1, (u1b_tmp & (~BIT(2))));\n\n\t \n\t \n\trtl_write_byte(rtlpriv, REG_MCUFWDL, 0x00);\n\n\tif (rtlhal->hw_type == HARDWARE_TYPE_RTL8821AE) {\n\t\t \n\t\trtl_hal_pwrseqcmdparsing(rtlpriv, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK,\n\t\t\tPWR_INTF_PCI_MSK, RTL8821A_NIC_DISABLE_FLOW);\n\t} else {\n\t\t \n\t\trtl_hal_pwrseqcmdparsing(rtlpriv, PWR_CUT_ALL_MSK, PWR_FAB_ALL_MSK,\n\t\t\tPWR_INTF_PCI_MSK, RTL8812_NIC_DISABLE_FLOW);\n\t}\n\n\t \n\tu1b_tmp = rtl_read_byte(rtlpriv, REG_RSV_CTRL + 1);\n\trtl_write_byte(rtlpriv, REG_RSV_CTRL + 1, (u1b_tmp & (~BIT(0))));\n\tu1b_tmp = rtl_read_byte(rtlpriv, REG_RSV_CTRL + 1);\n\trtl_write_byte(rtlpriv, REG_RSV_CTRL + 1, u1b_tmp | BIT(0));\n\n\t \n\t \n\trtl_write_byte(rtlpriv, REG_RSV_CTRL, 0x0e);\n}\n\nint rtl8821ae_hw_init(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tbool rtstatus = true;\n\tint err;\n\tu8 tmp_u1b;\n\tbool support_remote_wakeup;\n\tu32 nav_upper = WIFI_NAV_UPPER_US;\n\n\trtlhal->being_init_adapter = true;\n\trtlpriv->cfg->ops->get_hw_reg(hw, HAL_DEF_WOWLAN,\n\t\t\t\t      (u8 *)(&support_remote_wakeup));\n\trtlpriv->intf_ops->disable_aspm(hw);\n\n\t \n\n\ttmp_u1b = rtl_read_byte(rtlpriv, REG_CR);\n\tif (tmp_u1b != 0 && tmp_u1b != 0xEA) {\n\t\trtlhal->mac_func_enable = true;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\"MAC has already power on.\\n\");\n\t} else {\n\t\trtlhal->mac_func_enable = false;\n\t\trtlhal->fw_ps_state = FW_PS_STATE_ALL_ON_8821AE;\n\t}\n\n\tif (support_remote_wakeup &&\n\t\trtlhal->wake_from_pnp_sleep &&\n\t\trtlhal->mac_func_enable) {\n\t\tif (_rtl8821ae_wowlan_initialize_adapter(hw)) {\n\t\t\trtlhal->being_init_adapter = false;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (_rtl8821ae_check_pcie_dma_hang(hw)) {\n\t\t_rtl8821ae_reset_pcie_interface_dma(hw,\n\t\t\t\t\t\t    rtlhal->mac_func_enable,\n\t\t\t\t\t\t    false);\n\t\trtlhal->mac_func_enable = false;\n\t}\n\n\t \n\tif (rtlhal->mac_func_enable) {\n\t\t_rtl8821ae_poweroff_adapter(hw);\n\t\trtlhal->mac_func_enable = false;\n\t}\n\n\trtstatus = _rtl8821ae_init_mac(hw);\n\tif (!rtstatus) {\n\t\tpr_err(\"Init MAC failed\\n\");\n\t\terr = 1;\n\t\treturn err;\n\t}\n\n\ttmp_u1b = rtl_read_byte(rtlpriv, REG_SYS_CFG);\n\ttmp_u1b &= 0x7F;\n\trtl_write_byte(rtlpriv, REG_SYS_CFG, tmp_u1b);\n\n\terr = rtl8821ae_download_fw(hw, false);\n\tif (err) {\n\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_WARNING,\n\t\t\t\"Failed to download FW. Init HW without FW now\\n\");\n\t\terr = 1;\n\t\trtlhal->fw_ready = false;\n\t\treturn err;\n\t} else {\n\t\trtlhal->fw_ready = true;\n\t}\n\tppsc->fw_current_inpsmode = false;\n\trtlhal->fw_ps_state = FW_PS_STATE_ALL_ON_8821AE;\n\trtlhal->fw_clk_change_in_progress = false;\n\trtlhal->allow_sw_to_change_hwclc = false;\n\trtlhal->last_hmeboxnum = 0;\n\n\t \n\n\trtl8821ae_phy_mac_config(hw);\n\t \n\trtl8821ae_phy_bb_config(hw);\n\n\trtl8821ae_phy_rf_config(hw);\n\n\tif (rtlpriv->phy.rf_type == RF_1T1R &&\n\t\trtlhal->hw_type == HARDWARE_TYPE_RTL8812AE)\n\t\t_rtl8812ae_bb8812_config_1t(hw);\n\n\t_rtl8821ae_hw_configure(hw);\n\n\trtl8821ae_phy_switch_wirelessband(hw, BAND_ON_2_4G);\n\n\t \n\n\trtlhal->mac_func_enable = true;\n\n\trtl_cam_reset_all_entry(hw);\n\n\trtl8821ae_enable_hw_security_config(hw);\n\n\tppsc->rfpwr_state = ERFON;\n\n\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_ETHER_ADDR, mac->mac_addr);\n\t_rtl8821ae_enable_aspm_back_door(hw);\n\trtlpriv->intf_ops->enable_aspm(hw);\n\n\tif (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE &&\n\t    (rtlhal->rfe_type == 1 || rtlhal->rfe_type == 5))\n\t\trtl_set_bbreg(hw, 0x900, 0x00000303, 0x0302);\n\n\trtl8821ae_bt_hw_init(hw);\n\trtlpriv->rtlhal.being_init_adapter = false;\n\n\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_NAV_UPPER, (u8 *)&nav_upper);\n\n\t \n\t \n\tif (support_remote_wakeup)\n\t\trtl_write_byte(rtlpriv, REG_WOW_CTRL, 0);\n\n\t \n\ttmp_u1b = rtl_read_byte(rtlpriv, REG_RXDMA_CONTROL);\n\tif (tmp_u1b & BIT(2)) {\n\t\t \n\t\ttmp_u1b &= ~BIT(2);\n\t\trtl_write_byte(rtlpriv, REG_RXDMA_CONTROL, tmp_u1b);\n\t}\n\n\t \n\trtl_write_byte(rtlpriv, REG_PCIE_CTRL_REG + 1, 0);\n\n\trtl8821ae_dm_init(hw);\n\trtl8821ae_macid_initialize_mediastatus(hw);\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD, \"%s() <====\\n\", __func__);\n\treturn err;\n}\n\nstatic enum version_8821ae _rtl8821ae_read_chip_version(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tenum version_8821ae version = VERSION_UNKNOWN;\n\tu32 value32;\n\n\tvalue32 = rtl_read_dword(rtlpriv, REG_SYS_CFG);\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\"ReadChipVersion8812A 0xF0 = 0x%x\\n\", value32);\n\n\tif (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE)\n\t\trtlphy->rf_type = RF_2T2R;\n\telse if (rtlhal->hw_type == HARDWARE_TYPE_RTL8821AE)\n\t\trtlphy->rf_type = RF_1T1R;\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\"RF_Type is %x!!\\n\", rtlphy->rf_type);\n\n\tif (value32 & TRP_VAUX_EN) {\n\t\tif (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE) {\n\t\t\tif (rtlphy->rf_type == RF_2T2R)\n\t\t\t\tversion = VERSION_TEST_CHIP_2T2R_8812;\n\t\t\telse\n\t\t\t\tversion = VERSION_TEST_CHIP_1T1R_8812;\n\t\t} else\n\t\t\tversion = VERSION_TEST_CHIP_8821;\n\t} else {\n\t\tif (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE) {\n\t\t\tu32 rtl_id = ((value32 & CHIP_VER_RTL_MASK) >> 12) + 1;\n\n\t\t\tif (rtlphy->rf_type == RF_2T2R)\n\t\t\t\tversion =\n\t\t\t\t\t(enum version_8821ae)(CHIP_8812\n\t\t\t\t\t| NORMAL_CHIP |\n\t\t\t\t\tRF_TYPE_2T2R);\n\t\t\telse\n\t\t\t\tversion = (enum version_8821ae)(CHIP_8812\n\t\t\t\t\t| NORMAL_CHIP);\n\n\t\t\tversion = (enum version_8821ae)(version | (rtl_id << 12));\n\t\t} else if (rtlhal->hw_type == HARDWARE_TYPE_RTL8821AE) {\n\t\t\tu32 rtl_id = value32 & CHIP_VER_RTL_MASK;\n\n\t\t\tversion = (enum version_8821ae)(CHIP_8821\n\t\t\t\t| NORMAL_CHIP | rtl_id);\n\t\t}\n\t}\n\n\tif (rtlhal->hw_type == HARDWARE_TYPE_RTL8821AE) {\n\t\t \n\t\tvalue32 = rtl_read_dword(rtlpriv, REG_MULTI_FUNC_CTRL);\n\t\trtlhal->hw_rof_enable = ((value32 & WL_HWROF_EN) ? 1 : 0);\n\t}\n\n\tswitch (version) {\n\tcase VERSION_TEST_CHIP_1T1R_8812:\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\"Chip Version ID: VERSION_TEST_CHIP_1T1R_8812\\n\");\n\t\tbreak;\n\tcase VERSION_TEST_CHIP_2T2R_8812:\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\"Chip Version ID: VERSION_TEST_CHIP_2T2R_8812\\n\");\n\t\tbreak;\n\tcase VERSION_NORMAL_TSMC_CHIP_1T1R_8812:\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\"Chip Version ID:VERSION_NORMAL_TSMC_CHIP_1T1R_8812\\n\");\n\t\tbreak;\n\tcase VERSION_NORMAL_TSMC_CHIP_2T2R_8812:\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\"Chip Version ID: VERSION_NORMAL_TSMC_CHIP_2T2R_8812\\n\");\n\t\tbreak;\n\tcase VERSION_NORMAL_TSMC_CHIP_1T1R_8812_C_CUT:\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\"Chip Version ID: VERSION_NORMAL_TSMC_CHIP_1T1R_8812 C CUT\\n\");\n\t\tbreak;\n\tcase VERSION_NORMAL_TSMC_CHIP_2T2R_8812_C_CUT:\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\"Chip Version ID: VERSION_NORMAL_TSMC_CHIP_2T2R_8812 C CUT\\n\");\n\t\tbreak;\n\tcase VERSION_TEST_CHIP_8821:\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\"Chip Version ID: VERSION_TEST_CHIP_8821\\n\");\n\t\tbreak;\n\tcase VERSION_NORMAL_TSMC_CHIP_8821:\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\"Chip Version ID: VERSION_NORMAL_TSMC_CHIP_8821 A CUT\\n\");\n\t\tbreak;\n\tcase VERSION_NORMAL_TSMC_CHIP_8821_B_CUT:\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\"Chip Version ID: VERSION_NORMAL_TSMC_CHIP_8821 B CUT\\n\");\n\t\tbreak;\n\tdefault:\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\"Chip Version ID: Unknown (0x%X)\\n\", version);\n\t\tbreak;\n\t}\n\n\treturn version;\n}\n\nstatic int _rtl8821ae_set_media_status(struct ieee80211_hw *hw,\n\t\t\t\t     enum nl80211_iftype type)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 bt_msr = rtl_read_byte(rtlpriv, MSR);\n\tenum led_ctl_mode ledaction = LED_CTL_NO_LINK;\n\tbt_msr &= 0xfc;\n\n\trtl_write_dword(rtlpriv, REG_BCN_CTRL, 0);\n\trtl_dbg(rtlpriv, COMP_BEACON, DBG_LOUD,\n\t\t\"clear 0x550 when set HW_VAR_MEDIA_STATUS\\n\");\n\n\tif (type == NL80211_IFTYPE_UNSPECIFIED ||\n\t    type == NL80211_IFTYPE_STATION) {\n\t\t_rtl8821ae_stop_tx_beacon(hw);\n\t\t_rtl8821ae_enable_bcn_sub_func(hw);\n\t} else if (type == NL80211_IFTYPE_ADHOC ||\n\t\ttype == NL80211_IFTYPE_AP) {\n\t\t_rtl8821ae_resume_tx_beacon(hw);\n\t\t_rtl8821ae_disable_bcn_sub_func(hw);\n\t} else {\n\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_WARNING,\n\t\t\t\"Set HW_VAR_MEDIA_STATUS: No such media status(%x).\\n\",\n\t\t\ttype);\n\t}\n\n\tswitch (type) {\n\tcase NL80211_IFTYPE_UNSPECIFIED:\n\t\tbt_msr |= MSR_NOLINK;\n\t\tledaction = LED_CTL_LINK;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\t\"Set Network type to NO LINK!\\n\");\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tbt_msr |= MSR_ADHOC;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\t\"Set Network type to Ad Hoc!\\n\");\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tbt_msr |= MSR_INFRA;\n\t\tledaction = LED_CTL_LINK;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\t\"Set Network type to STA!\\n\");\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\t\tbt_msr |= MSR_AP;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\t\"Set Network type to AP!\\n\");\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Network type %d not support!\\n\", type);\n\t\treturn 1;\n\t}\n\n\trtl_write_byte(rtlpriv, MSR, bt_msr);\n\trtlpriv->cfg->ops->led_control(hw, ledaction);\n\tif ((bt_msr & MSR_MASK) == MSR_AP)\n\t\trtl_write_byte(rtlpriv, REG_BCNTCFG + 1, 0x00);\n\telse\n\t\trtl_write_byte(rtlpriv, REG_BCNTCFG + 1, 0x66);\n\n\treturn 0;\n}\n\nvoid rtl8821ae_set_check_bssid(struct ieee80211_hw *hw, bool check_bssid)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tu32 reg_rcr = rtlpci->receive_config;\n\n\tif (rtlpriv->psc.rfpwr_state != ERFON)\n\t\treturn;\n\n\tif (check_bssid) {\n\t\treg_rcr |= (RCR_CBSSID_DATA | RCR_CBSSID_BCN);\n\t\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_RCR,\n\t\t\t\t\t      (u8 *)(&reg_rcr));\n\t\t_rtl8821ae_set_bcn_ctrl_reg(hw, 0, BIT(4));\n\t} else if (!check_bssid) {\n\t\treg_rcr &= (~(RCR_CBSSID_DATA | RCR_CBSSID_BCN));\n\t\t_rtl8821ae_set_bcn_ctrl_reg(hw, BIT(4), 0);\n\t\trtlpriv->cfg->ops->set_hw_reg(hw,\n\t\t\tHW_VAR_RCR, (u8 *)(&reg_rcr));\n\t}\n}\n\nint rtl8821ae_set_network_type(struct ieee80211_hw *hw, enum nl80211_iftype type)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD, \"%s!\\n\", __func__);\n\n\tif (_rtl8821ae_set_media_status(hw, type))\n\t\treturn -EOPNOTSUPP;\n\n\tif (rtlpriv->mac80211.link_state == MAC80211_LINKED) {\n\t\tif (type != NL80211_IFTYPE_AP)\n\t\t\trtl8821ae_set_check_bssid(hw, true);\n\t} else {\n\t\trtl8821ae_set_check_bssid(hw, false);\n\t}\n\n\treturn 0;\n}\n\n \nvoid rtl8821ae_set_qos(struct ieee80211_hw *hw, int aci)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\trtl8821ae_dm_init_edca_turbo(hw);\n\tswitch (aci) {\n\tcase AC1_BK:\n\t\trtl_write_dword(rtlpriv, REG_EDCA_BK_PARAM, 0xa44f);\n\t\tbreak;\n\tcase AC0_BE:\n\t\t \n\t\tbreak;\n\tcase AC2_VI:\n\t\trtl_write_dword(rtlpriv, REG_EDCA_VI_PARAM, 0x5e4322);\n\t\tbreak;\n\tcase AC3_VO:\n\t\trtl_write_dword(rtlpriv, REG_EDCA_VO_PARAM, 0x2f3222);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ONCE(true, \"rtl8821ae: invalid aci: %d !\\n\", aci);\n\t\tbreak;\n\t}\n}\n\nstatic void rtl8821ae_clear_interrupt(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 tmp = rtl_read_dword(rtlpriv, REG_HISR);\n\n\trtl_write_dword(rtlpriv, REG_HISR, tmp);\n\n\ttmp = rtl_read_dword(rtlpriv, REG_HISRE);\n\trtl_write_dword(rtlpriv, REG_HISRE, tmp);\n\n\ttmp = rtl_read_dword(rtlpriv, REG_HSISR);\n\trtl_write_dword(rtlpriv, REG_HSISR, tmp);\n}\n\nvoid rtl8821ae_enable_interrupt(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\n\tif (rtlpci->int_clear)\n\t\trtl8821ae_clear_interrupt(hw); \n\n\trtl_write_dword(rtlpriv, REG_HIMR, rtlpci->irq_mask[0] & 0xFFFFFFFF);\n\trtl_write_dword(rtlpriv, REG_HIMRE, rtlpci->irq_mask[1] & 0xFFFFFFFF);\n\trtlpci->irq_enabled = true;\n\t \n\t \n\t \n\trtl_write_dword(rtlpriv, REG_HSIMR, rtlpci->sys_irq_mask & 0xFFFFFFFF);\n}\n\nvoid rtl8821ae_disable_interrupt(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\n\trtl_write_dword(rtlpriv, REG_HIMR, IMR_DISABLED);\n\trtl_write_dword(rtlpriv, REG_HIMRE, IMR_DISABLED);\n\trtlpci->irq_enabled = false;\n\t \n}\n\nstatic void _rtl8821ae_clear_pci_pme_status(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tu16 cap_hdr;\n\tu8 cap_pointer;\n\tu8 cap_id = 0xff;\n\tu8 pmcs_reg;\n\tu8 cnt = 0;\n\n\t \n\n\tpci_read_config_byte(rtlpci->pdev, 0x34, &cap_pointer);\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\"PCI configuration 0x34 = 0x%2x\\n\", cap_pointer);\n\n\tdo {\n\t\tpci_read_config_word(rtlpci->pdev, cap_pointer, &cap_hdr);\n\t\tcap_id = cap_hdr & 0xFF;\n\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\"in pci configuration, cap_pointer%x = %x\\n\",\n\t\t\tcap_pointer, cap_id);\n\n\t\tif (cap_id == 0x01) {\n\t\t\tbreak;\n\t\t} else {\n\t\t\t \n\t\t\tcap_pointer = (cap_hdr >> 8) & 0xFF;\n\t\t\t \n\t\t\tif (cap_pointer == 0x00 || cap_pointer == 0xff) {\n\t\t\t\tcap_id = 0xff;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} while (cnt++ < 200);\n\n\tif (cap_id == 0x01) {\n\t\t \n\t\tpci_read_config_byte(rtlpci->pdev, cap_pointer + 5, &pmcs_reg);\n\n\t\tif (pmcs_reg & BIT(7)) {\n\t\t\t \n\t\t\tpmcs_reg = pmcs_reg | BIT(7);\n\n\t\t\tpci_write_config_byte(rtlpci->pdev, cap_pointer + 5,\n\t\t\t\t\t      pmcs_reg);\n\t\t\t \n\t\t\tpci_read_config_byte(rtlpci->pdev, cap_pointer + 5,\n\t\t\t\t\t     &pmcs_reg);\n\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG,\n\t\t\t\t\"Clear PME status 0x%2x to 0x%2x\\n\",\n\t\t\t\tcap_pointer + 5, pmcs_reg);\n\t\t} else {\n\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG,\n\t\t\t\t\"PME status(0x%2x) = 0x%2x\\n\",\n\t\t\t\tcap_pointer + 5, pmcs_reg);\n\t\t}\n\t} else {\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_WARNING,\n\t\t\t\"Cannot find PME Capability\\n\");\n\t}\n}\n\nvoid rtl8821ae_card_disable(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtlpriv);\n\tstruct rtl_mac *mac = rtl_mac(rtlpriv);\n\tenum nl80211_iftype opmode;\n\tbool support_remote_wakeup;\n\tu8 tmp;\n\tu32 count = 0;\n\n\trtlpriv->cfg->ops->get_hw_reg(hw, HAL_DEF_WOWLAN,\n\t\t\t\t      (u8 *)(&support_remote_wakeup));\n\n\tRT_SET_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_HALT_NIC);\n\n\tif (!(support_remote_wakeup && mac->opmode == NL80211_IFTYPE_STATION)\n\t    || !rtlhal->enter_pnp_sleep) {\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG, \"Normal Power off\\n\");\n\t\tmac->link_state = MAC80211_NOLINK;\n\t\topmode = NL80211_IFTYPE_UNSPECIFIED;\n\t\t_rtl8821ae_set_media_status(hw, opmode);\n\t\t_rtl8821ae_poweroff_adapter(hw);\n\t} else {\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG, \"Wowlan Supported.\\n\");\n\t\t \n\t\t \n\t\trtl_write_byte(rtlpriv, REG_MCUTST_WOWLAN, 0x0);\n\n#if (USE_SPECIFIC_FW_TO_SUPPORT_WOWLAN == 1)\n\t\trtl8821ae_set_fw_related_for_wowlan(hw, true);\n#endif\n\t\t \n\t\tif (_rtl8821ae_dynamic_rqpn(hw, 0xE0, 0x3, 0x80c20d0d))\n\t\t\trtlhal->re_init_llt_table = true;\n\n\t\t \n\n\t\t \n\t\trtl8821ae_set_fw_global_info_cmd(hw);\n\n\t\t_rtl8821ae_download_rsvd_page(hw, true);\n\n\t\t \n\t\tprintk(\"mac->link_state = %d\\n\", mac->link_state);\n\t\tif (mac->link_state >= MAC80211_LINKED &&\n\t\t    mac->opmode == NL80211_IFTYPE_STATION) {\n\t\t\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_AID, NULL);\n\t\t\trtl8821ae_set_fw_media_status_rpt_cmd(hw,\n\t\t\t\t\t\t\t      RT_MEDIA_CONNECT);\n\n\t\t\trtl8821ae_set_fw_wowlan_mode(hw, true);\n\t\t\t \n\t\t\trtl8821ae_set_fw_keep_alive_cmd(hw, true);\n\n\t\t\t \n\t\t\trtl8821ae_set_fw_disconnect_decision_ctrl_cmd(hw, true);\n\t\t}\n\n\t\t \n\n\t\t \n\t\trtl_write_byte(rtlpriv, REG_RXDMA_CONTROL, BIT(2));\n\n\t\ttmp = rtl_read_byte(rtlpriv, REG_RXDMA_CONTROL);\n\t\tcount = 0;\n\t\twhile (!(tmp & BIT(1)) && (count++ < 100)) {\n\t\t\tudelay(10);\n\t\t\ttmp = rtl_read_byte(rtlpriv, REG_RXDMA_CONTROL);\n\t\t}\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\"Wait Rx DMA Finished before host sleep. count=%d\\n\",\n\t\t\tcount);\n\n\t\t \n\t\trtlpriv->intf_ops->reset_trx_ring(hw);\n\n\t\trtl_write_byte(rtlpriv, REG_APS_FSMCO + 1, 0x0);\n\n\t\t_rtl8821ae_clear_pci_pme_status(hw);\n\t\ttmp = rtl_read_byte(rtlpriv, REG_SYS_CLKR);\n\t\trtl_write_byte(rtlpriv, REG_SYS_CLKR, tmp | BIT(3));\n\t\t \n\t\trtl_write_byte(rtlpriv, REG_RSV_CTRL, 0x20);\n\t\trtl_write_byte(rtlpriv, REG_RSV_CTRL, 0x60);\n\t}\n\n\tif (rtlpriv->rtlhal.driver_is_goingto_unload ||\n\t    ppsc->rfoff_reason > RF_CHANGE_BY_PS)\n\t\trtlpriv->cfg->ops->led_control(hw, LED_CTL_POWER_OFF);\n\t \n\tif (support_remote_wakeup && rtlhal->enter_pnp_sleep) {\n\t\t \n\t\trtl8821ae_set_fw_remote_wake_ctrl_cmd(hw, 1);\n\n\t\t \n\t\trtl_write_byte(rtlpriv, REG_PCIE_CTRL_REG + 1, 0xff);\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD, \"Stop PCIE Tx DMA.\\n\");\n\n\t\t \n\t\tcount = 0;\n\t\tdo {\n\t\t\ttmp = rtl_read_byte(rtlpriv, REG_PCIE_CTRL_REG);\n\t\t\tudelay(10);\n\t\t\tcount++;\n\t\t} while ((tmp != 0) && (count < 100));\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\"Wait Tx DMA Finished before host sleep. count=%d\\n\",\n\t\t\tcount);\n\n\t\tif (rtlhal->hw_rof_enable) {\n\t\t\tprintk(\"hw_rof_enable\\n\");\n\t\t\ttmp = rtl_read_byte(rtlpriv, REG_HSISR + 3);\n\t\t\trtl_write_byte(rtlpriv, REG_HSISR + 3, tmp | BIT(1));\n\t\t}\n\t}\n\t \n\trtlpriv->phy.iqk_initialized = false;\n}\n\nvoid rtl8821ae_interrupt_recognized(struct ieee80211_hw *hw,\n\t\t\t\t    struct rtl_int *intvec)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\n\tintvec->inta = rtl_read_dword(rtlpriv, ISR) & rtlpci->irq_mask[0];\n\trtl_write_dword(rtlpriv, ISR, intvec->inta);\n\n\tintvec->intb = rtl_read_dword(rtlpriv, REG_HISRE) & rtlpci->irq_mask[1];\n\trtl_write_dword(rtlpriv, REG_HISRE, intvec->intb);\n}\n\nvoid rtl8821ae_set_beacon_related_registers(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tu16 bcn_interval, atim_window;\n\n\tbcn_interval = mac->beacon_interval;\n\tatim_window = 2;\t \n\trtl8821ae_disable_interrupt(hw);\n\trtl_write_word(rtlpriv, REG_ATIMWND, atim_window);\n\trtl_write_word(rtlpriv, REG_BCN_INTERVAL, bcn_interval);\n\trtl_write_word(rtlpriv, REG_BCNTCFG, 0x660f);\n\trtl_write_byte(rtlpriv, REG_RXTSF_OFFSET_CCK, 0x18);\n\trtl_write_byte(rtlpriv, REG_RXTSF_OFFSET_OFDM, 0x18);\n\trtl_write_byte(rtlpriv, 0x606, 0x30);\n\trtlpci->reg_bcn_ctrl_val |= BIT(3);\n\trtl_write_byte(rtlpriv, REG_BCN_CTRL, (u8)rtlpci->reg_bcn_ctrl_val);\n\trtl8821ae_enable_interrupt(hw);\n}\n\nvoid rtl8821ae_set_beacon_interval(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tu16 bcn_interval = mac->beacon_interval;\n\n\trtl_dbg(rtlpriv, COMP_BEACON, DBG_DMESG,\n\t\t\"beacon_interval:%d\\n\", bcn_interval);\n\trtl8821ae_disable_interrupt(hw);\n\trtl_write_word(rtlpriv, REG_BCN_INTERVAL, bcn_interval);\n\trtl8821ae_enable_interrupt(hw);\n}\n\nvoid rtl8821ae_update_interrupt_mask(struct ieee80211_hw *hw,\n\t\t\t\t   u32 add_msr, u32 rm_msr)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\n\trtl_dbg(rtlpriv, COMP_INTR, DBG_LOUD,\n\t\t\"add_msr:%x, rm_msr:%x\\n\", add_msr, rm_msr);\n\n\tif (add_msr)\n\t\trtlpci->irq_mask[0] |= add_msr;\n\tif (rm_msr)\n\t\trtlpci->irq_mask[0] &= (~rm_msr);\n\trtl8821ae_disable_interrupt(hw);\n\trtl8821ae_enable_interrupt(hw);\n}\n\nstatic u8 _rtl8821ae_get_chnl_group(u8 chnl)\n{\n\tu8 group = 0;\n\n\tif (chnl <= 14) {\n\t\tif (1 <= chnl && chnl <= 2)\n\t\t\tgroup = 0;\n\telse if (3 <= chnl && chnl <= 5)\n\t\t\tgroup = 1;\n\telse if (6 <= chnl && chnl <= 8)\n\t\t\tgroup = 2;\n\telse if (9 <= chnl && chnl <= 11)\n\t\t\tgroup = 3;\n\telse  \n\t\t\tgroup = 4;\n\t} else {\n\t\tif (36 <= chnl && chnl <= 42)\n\t\t\tgroup = 0;\n\telse if (44 <= chnl && chnl <= 48)\n\t\t\tgroup = 1;\n\telse if (50 <= chnl && chnl <= 58)\n\t\t\tgroup = 2;\n\telse if (60 <= chnl && chnl <= 64)\n\t\t\tgroup = 3;\n\telse if (100 <= chnl && chnl <= 106)\n\t\t\tgroup = 4;\n\telse if (108 <= chnl && chnl <= 114)\n\t\t\tgroup = 5;\n\telse if (116 <= chnl && chnl <= 122)\n\t\t\tgroup = 6;\n\telse if (124 <= chnl && chnl <= 130)\n\t\t\tgroup = 7;\n\telse if (132 <= chnl && chnl <= 138)\n\t\t\tgroup = 8;\n\telse if (140 <= chnl && chnl <= 144)\n\t\t\tgroup = 9;\n\telse if (149 <= chnl && chnl <= 155)\n\t\t\tgroup = 10;\n\telse if (157 <= chnl && chnl <= 161)\n\t\t\tgroup = 11;\n\telse if (165 <= chnl && chnl <= 171)\n\t\t\tgroup = 12;\n\telse if (173 <= chnl && chnl <= 177)\n\t\t\tgroup = 13;\n\telse\n\t\tWARN_ONCE(true,\n\t\t\t  \"rtl8821ae: 5G, Channel %d in Group not found\\n\",\n\t\t\t  chnl);\n\t}\n\treturn group;\n}\n\nstatic void _rtl8821ae_read_power_value_fromprom(struct ieee80211_hw *hw,\n\tstruct txpower_info_2g *pwrinfo24g,\n\tstruct txpower_info_5g *pwrinfo5g,\n\tbool autoload_fail,\n\tu8 *hwinfo)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 rfpath, eeaddr = EEPROM_TX_PWR_INX, group, txcount = 0;\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\"hal_ReadPowerValueFromPROM8821ae(): hwinfo[0x%x]=0x%x\\n\",\n\t\t(eeaddr + 1), hwinfo[eeaddr + 1]);\n\tif (hwinfo[eeaddr + 1] == 0xFF)   \n\t\tautoload_fail = true;\n\n\tif (autoload_fail) {\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\"auto load fail : Use Default value!\\n\");\n\t\tfor (rfpath = 0 ; rfpath < MAX_RF_PATH ; rfpath++) {\n\t\t\t \n\t\t\tfor (group = 0 ; group < MAX_CHNL_GROUP_24G; group++) {\n\t\t\t\tpwrinfo24g->index_cck_base[rfpath][group] = 0x2D;\n\t\t\t\tpwrinfo24g->index_bw40_base[rfpath][group] = 0x2D;\n\t\t\t}\n\t\t\tfor (txcount = 0; txcount < MAX_TX_COUNT; txcount++) {\n\t\t\t\tif (txcount == 0) {\n\t\t\t\t\tpwrinfo24g->bw20_diff[rfpath][0] = 0x02;\n\t\t\t\t\tpwrinfo24g->ofdm_diff[rfpath][0] = 0x04;\n\t\t\t\t} else {\n\t\t\t\t\tpwrinfo24g->bw20_diff[rfpath][txcount] = 0xFE;\n\t\t\t\t\tpwrinfo24g->bw40_diff[rfpath][txcount] = 0xFE;\n\t\t\t\t\tpwrinfo24g->cck_diff[rfpath][txcount] =\t0xFE;\n\t\t\t\t\tpwrinfo24g->ofdm_diff[rfpath][txcount] = 0xFE;\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\tfor (group = 0 ; group < MAX_CHNL_GROUP_5G; group++)\n\t\t\t\tpwrinfo5g->index_bw40_base[rfpath][group] = 0x2A;\n\n\t\t\tfor (txcount = 0; txcount < MAX_TX_COUNT; txcount++) {\n\t\t\t\tif (txcount == 0) {\n\t\t\t\t\tpwrinfo5g->ofdm_diff[rfpath][0] = 0x04;\n\t\t\t\t\tpwrinfo5g->bw20_diff[rfpath][0] = 0x00;\n\t\t\t\t\tpwrinfo5g->bw80_diff[rfpath][0] = 0xFE;\n\t\t\t\t\tpwrinfo5g->bw160_diff[rfpath][0] = 0xFE;\n\t\t\t\t} else {\n\t\t\t\t\tpwrinfo5g->ofdm_diff[rfpath][0] = 0xFE;\n\t\t\t\t\tpwrinfo5g->bw20_diff[rfpath][0] = 0xFE;\n\t\t\t\t\tpwrinfo5g->bw40_diff[rfpath][0] = 0xFE;\n\t\t\t\t\tpwrinfo5g->bw80_diff[rfpath][0] = 0xFE;\n\t\t\t\t\tpwrinfo5g->bw160_diff[rfpath][0] = 0xFE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\trtl_priv(hw)->efuse.txpwr_fromeprom = true;\n\n\tfor (rfpath = 0 ; rfpath < MAX_RF_PATH ; rfpath++) {\n\t\t \n\t\tfor (group = 0 ; group < MAX_CHNL_GROUP_24G; group++) {\n\t\t\tpwrinfo24g->index_cck_base[rfpath][group] = hwinfo[eeaddr++];\n\t\t\tif (pwrinfo24g->index_cck_base[rfpath][group] == 0xFF)\n\t\t\t\tpwrinfo24g->index_cck_base[rfpath][group] = 0x2D;\n\t\t}\n\t\tfor (group = 0 ; group < MAX_CHNL_GROUP_24G - 1; group++) {\n\t\t\tpwrinfo24g->index_bw40_base[rfpath][group] = hwinfo[eeaddr++];\n\t\t\tif (pwrinfo24g->index_bw40_base[rfpath][group] == 0xFF)\n\t\t\t\tpwrinfo24g->index_bw40_base[rfpath][group] = 0x2D;\n\t\t}\n\t\tfor (txcount = 0; txcount < MAX_TX_COUNT; txcount++) {\n\t\t\tif (txcount == 0) {\n\t\t\t\tpwrinfo24g->bw40_diff[rfpath][txcount] = 0;\n\t\t\t\t \n\t\t\t\tpwrinfo24g->bw20_diff[rfpath][txcount] = (hwinfo[eeaddr] & 0xf0) >> 4;\n\t\t\t\tif (pwrinfo24g->bw20_diff[rfpath][txcount] & BIT(3))\n\t\t\t\t\tpwrinfo24g->bw20_diff[rfpath][txcount] |= 0xF0;\n\t\t\t\t \n\t\t\t\tpwrinfo24g->ofdm_diff[rfpath][txcount] = (hwinfo[eeaddr] & 0x0f);\n\t\t\t\tif (pwrinfo24g->ofdm_diff[rfpath][txcount] & BIT(3))\n\t\t\t\t\tpwrinfo24g->ofdm_diff[rfpath][txcount] |= 0xF0;\n\n\t\t\t\tpwrinfo24g->cck_diff[rfpath][txcount] = 0;\n\t\t\t\teeaddr++;\n\t\t\t} else {\n\t\t\t\tpwrinfo24g->bw40_diff[rfpath][txcount] = (hwinfo[eeaddr] & 0xf0) >> 4;\n\t\t\t\tif (pwrinfo24g->bw40_diff[rfpath][txcount] & BIT(3))\n\t\t\t\t\tpwrinfo24g->bw40_diff[rfpath][txcount] |= 0xF0;\n\n\t\t\t\tpwrinfo24g->bw20_diff[rfpath][txcount] = (hwinfo[eeaddr] & 0x0f);\n\t\t\t\tif (pwrinfo24g->bw20_diff[rfpath][txcount] & BIT(3))\n\t\t\t\t\tpwrinfo24g->bw20_diff[rfpath][txcount] |= 0xF0;\n\n\t\t\t\teeaddr++;\n\n\t\t\t\tpwrinfo24g->ofdm_diff[rfpath][txcount] = (hwinfo[eeaddr] & 0xf0) >> 4;\n\t\t\t\tif (pwrinfo24g->ofdm_diff[rfpath][txcount] & BIT(3))\n\t\t\t\t\tpwrinfo24g->ofdm_diff[rfpath][txcount] |= 0xF0;\n\n\t\t\t\tpwrinfo24g->cck_diff[rfpath][txcount] =\t(hwinfo[eeaddr] & 0x0f);\n\t\t\t\tif (pwrinfo24g->cck_diff[rfpath][txcount] & BIT(3))\n\t\t\t\t\tpwrinfo24g->cck_diff[rfpath][txcount] |= 0xF0;\n\n\t\t\t\teeaddr++;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tfor (group = 0 ; group < MAX_CHNL_GROUP_5G; group++) {\n\t\t\tpwrinfo5g->index_bw40_base[rfpath][group] = hwinfo[eeaddr++];\n\t\t\tif (pwrinfo5g->index_bw40_base[rfpath][group] == 0xFF)\n\t\t\t\tpwrinfo5g->index_bw40_base[rfpath][group] = 0xFE;\n\t\t}\n\n\t\tfor (txcount = 0; txcount < MAX_TX_COUNT; txcount++) {\n\t\t\tif (txcount == 0) {\n\t\t\t\tpwrinfo5g->bw40_diff[rfpath][txcount] = 0;\n\n\t\t\t\tpwrinfo5g->bw20_diff[rfpath][0] = (hwinfo[eeaddr] & 0xf0) >> 4;\n\t\t\t\tif (pwrinfo5g->bw20_diff[rfpath][txcount] & BIT(3))\n\t\t\t\t\tpwrinfo5g->bw20_diff[rfpath][txcount] |= 0xF0;\n\n\t\t\t\tpwrinfo5g->ofdm_diff[rfpath][0] = (hwinfo[eeaddr] & 0x0f);\n\t\t\t\tif (pwrinfo5g->ofdm_diff[rfpath][txcount] & BIT(3))\n\t\t\t\t\tpwrinfo5g->ofdm_diff[rfpath][txcount] |= 0xF0;\n\n\t\t\t\teeaddr++;\n\t\t\t} else {\n\t\t\t\tpwrinfo5g->bw40_diff[rfpath][txcount] = (hwinfo[eeaddr] & 0xf0) >> 4;\n\t\t\t\tif (pwrinfo5g->bw40_diff[rfpath][txcount] & BIT(3))\n\t\t\t\t\tpwrinfo5g->bw40_diff[rfpath][txcount] |= 0xF0;\n\n\t\t\t\tpwrinfo5g->bw20_diff[rfpath][txcount] = (hwinfo[eeaddr] & 0x0f);\n\t\t\t\tif (pwrinfo5g->bw20_diff[rfpath][txcount] & BIT(3))\n\t\t\t\t\tpwrinfo5g->bw20_diff[rfpath][txcount] |= 0xF0;\n\n\t\t\t\teeaddr++;\n\t\t\t}\n\t\t}\n\n\t\tpwrinfo5g->ofdm_diff[rfpath][1] =\t(hwinfo[eeaddr] & 0xf0) >> 4;\n\t\tpwrinfo5g->ofdm_diff[rfpath][2] =\t(hwinfo[eeaddr] & 0x0f);\n\n\t\teeaddr++;\n\n\t\tpwrinfo5g->ofdm_diff[rfpath][3] = (hwinfo[eeaddr] & 0x0f);\n\n\t\teeaddr++;\n\n\t\tfor (txcount = 1; txcount < MAX_TX_COUNT; txcount++) {\n\t\t\tif (pwrinfo5g->ofdm_diff[rfpath][txcount] & BIT(3))\n\t\t\t\tpwrinfo5g->ofdm_diff[rfpath][txcount] |= 0xF0;\n\t\t}\n\t\tfor (txcount = 0; txcount < MAX_TX_COUNT; txcount++) {\n\t\t\tpwrinfo5g->bw80_diff[rfpath][txcount] =\t(hwinfo[eeaddr] & 0xf0) >> 4;\n\t\t\t \n\t\t\tif (pwrinfo5g->bw80_diff[rfpath][txcount] & BIT(3))\n\t\t\t\tpwrinfo5g->bw80_diff[rfpath][txcount] |= 0xF0;\n\t\t\t \n\t\t\tpwrinfo5g->bw160_diff[rfpath][txcount] = (hwinfo[eeaddr] & 0x0f);\n\t\t\tif (pwrinfo5g->bw160_diff[rfpath][txcount] & BIT(3))\n\t\t\t\tpwrinfo5g->bw160_diff[rfpath][txcount] |= 0xF0;\n\n\t\t\teeaddr++;\n\t\t}\n\t}\n}\n#if 0\nstatic void _rtl8812ae_read_txpower_info_from_hwpg(struct ieee80211_hw *hw,\n\t\t\t\t\t\t bool autoload_fail,\n\t\t\t\t\t\t u8 *hwinfo)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tstruct txpower_info_2g pwrinfo24g;\n\tstruct txpower_info_5g pwrinfo5g;\n\tu8 rf_path, index;\n\tu8 i;\n\n\t_rtl8821ae_read_power_value_fromprom(hw, &pwrinfo24g,\n\t\t\t\t\t&pwrinfo5g, autoload_fail, hwinfo);\n\n\tfor (rf_path = 0; rf_path < 2; rf_path++) {\n\t\tfor (i = 0; i < CHANNEL_MAX_NUMBER_2G; i++) {\n\t\t\tindex = _rtl8821ae_get_chnl_group(i + 1);\n\n\t\t\tif (i == CHANNEL_MAX_NUMBER_2G - 1) {\n\t\t\t\trtlefuse->txpwrlevel_cck[rf_path][i] =\n\t\t\t\t\tpwrinfo24g.index_cck_base[rf_path][5];\n\t\t\t\trtlefuse->txpwrlevel_ht40_1s[rf_path][i] =\n\t\t\t\t\tpwrinfo24g.index_bw40_base[rf_path][index];\n\t\t\t} else {\n\t\t\t\trtlefuse->txpwrlevel_cck[rf_path][i] =\n\t\t\t\t\tpwrinfo24g.index_cck_base[rf_path][index];\n\t\t\t\trtlefuse->txpwrlevel_ht40_1s[rf_path][i] =\n\t\t\t\t\tpwrinfo24g.index_bw40_base[rf_path][index];\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < CHANNEL_MAX_NUMBER_5G; i++) {\n\t\t\tindex = _rtl8821ae_get_chnl_group(channel5g[i]);\n\t\t\trtlefuse->txpwr_5g_bw40base[rf_path][i] =\n\t\t\t\t\tpwrinfo5g.index_bw40_base[rf_path][index];\n\t\t}\n\t\tfor (i = 0; i < CHANNEL_MAX_NUMBER_5G_80M; i++) {\n\t\t\tu8 upper, lower;\n\t\t\tindex = _rtl8821ae_get_chnl_group(channel5g_80m[i]);\n\t\t\tupper = pwrinfo5g.index_bw40_base[rf_path][index];\n\t\t\tlower = pwrinfo5g.index_bw40_base[rf_path][index + 1];\n\n\t\t\trtlefuse->txpwr_5g_bw80base[rf_path][i] = (upper + lower) / 2;\n\t\t}\n\t\tfor (i = 0; i < MAX_TX_COUNT; i++) {\n\t\t\trtlefuse->txpwr_cckdiff[rf_path][i] =\n\t\t\t\tpwrinfo24g.cck_diff[rf_path][i];\n\t\t\trtlefuse->txpwr_legacyhtdiff[rf_path][i] =\n\t\t\t\tpwrinfo24g.ofdm_diff[rf_path][i];\n\t\t\trtlefuse->txpwr_ht20diff[rf_path][i] =\n\t\t\t\tpwrinfo24g.bw20_diff[rf_path][i];\n\t\t\trtlefuse->txpwr_ht40diff[rf_path][i] =\n\t\t\t\tpwrinfo24g.bw40_diff[rf_path][i];\n\n\t\t\trtlefuse->txpwr_5g_ofdmdiff[rf_path][i] =\n\t\t\t\tpwrinfo5g.ofdm_diff[rf_path][i];\n\t\t\trtlefuse->txpwr_5g_bw20diff[rf_path][i] =\n\t\t\t\tpwrinfo5g.bw20_diff[rf_path][i];\n\t\t\trtlefuse->txpwr_5g_bw40diff[rf_path][i] =\n\t\t\t\tpwrinfo5g.bw40_diff[rf_path][i];\n\t\t\trtlefuse->txpwr_5g_bw80diff[rf_path][i] =\n\t\t\t\tpwrinfo5g.bw80_diff[rf_path][i];\n\t\t}\n\t}\n\n\tif (!autoload_fail) {\n\t\trtlefuse->eeprom_regulatory =\n\t\t\thwinfo[EEPROM_RF_BOARD_OPTION] & 0x07; \n\t\tif (hwinfo[EEPROM_RF_BOARD_OPTION] == 0xFF)\n\t\t\trtlefuse->eeprom_regulatory = 0;\n\t} else {\n\t\trtlefuse->eeprom_regulatory = 0;\n\t}\n\n\tRTPRINT(rtlpriv, FINIT, INIT_TXPOWER,\n\t\"eeprom_regulatory = 0x%x\\n\", rtlefuse->eeprom_regulatory);\n}\n#endif\nstatic void _rtl8821ae_read_txpower_info_from_hwpg(struct ieee80211_hw *hw,\n\t\t\t\t\t\t bool autoload_fail,\n\t\t\t\t\t\t u8 *hwinfo)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tstruct txpower_info_2g pwrinfo24g;\n\tstruct txpower_info_5g pwrinfo5g;\n\tu8 rf_path, index;\n\tu8 i;\n\n\t_rtl8821ae_read_power_value_fromprom(hw, &pwrinfo24g,\n\t\t&pwrinfo5g, autoload_fail, hwinfo);\n\n\tfor (rf_path = 0; rf_path < 2; rf_path++) {\n\t\tfor (i = 0; i < CHANNEL_MAX_NUMBER_2G; i++) {\n\t\t\tindex = _rtl8821ae_get_chnl_group(i + 1);\n\n\t\t\tif (i == CHANNEL_MAX_NUMBER_2G - 1) {\n\t\t\t\trtlefuse->txpwrlevel_cck[rf_path][i] =\n\t\t\t\t\tpwrinfo24g.index_cck_base[rf_path][5];\n\t\t\t\trtlefuse->txpwrlevel_ht40_1s[rf_path][i] =\n\t\t\t\t\tpwrinfo24g.index_bw40_base[rf_path][index];\n\t\t\t} else {\n\t\t\t\trtlefuse->txpwrlevel_cck[rf_path][i] =\n\t\t\t\t\tpwrinfo24g.index_cck_base[rf_path][index];\n\t\t\t\trtlefuse->txpwrlevel_ht40_1s[rf_path][i] =\n\t\t\t\t\tpwrinfo24g.index_bw40_base[rf_path][index];\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0; i < CHANNEL_MAX_NUMBER_5G; i++) {\n\t\t\tindex = _rtl8821ae_get_chnl_group(channel5g[i]);\n\t\t\trtlefuse->txpwr_5g_bw40base[rf_path][i] =\n\t\t\t\tpwrinfo5g.index_bw40_base[rf_path][index];\n\t\t}\n\t\tfor (i = 0; i < CHANNEL_MAX_NUMBER_5G_80M; i++) {\n\t\t\tu8 upper, lower;\n\t\t\tindex = _rtl8821ae_get_chnl_group(channel5g_80m[i]);\n\t\t\tupper = pwrinfo5g.index_bw40_base[rf_path][index];\n\t\t\tlower = pwrinfo5g.index_bw40_base[rf_path][index + 1];\n\n\t\t\trtlefuse->txpwr_5g_bw80base[rf_path][i] = (upper + lower) / 2;\n\t\t}\n\t\tfor (i = 0; i < MAX_TX_COUNT; i++) {\n\t\t\trtlefuse->txpwr_cckdiff[rf_path][i] =\n\t\t\t\tpwrinfo24g.cck_diff[rf_path][i];\n\t\t\trtlefuse->txpwr_legacyhtdiff[rf_path][i] =\n\t\t\t\tpwrinfo24g.ofdm_diff[rf_path][i];\n\t\t\trtlefuse->txpwr_ht20diff[rf_path][i] =\n\t\t\t\tpwrinfo24g.bw20_diff[rf_path][i];\n\t\t\trtlefuse->txpwr_ht40diff[rf_path][i] =\n\t\t\t\tpwrinfo24g.bw40_diff[rf_path][i];\n\n\t\t\trtlefuse->txpwr_5g_ofdmdiff[rf_path][i] =\n\t\t\t\tpwrinfo5g.ofdm_diff[rf_path][i];\n\t\t\trtlefuse->txpwr_5g_bw20diff[rf_path][i] =\n\t\t\t\tpwrinfo5g.bw20_diff[rf_path][i];\n\t\t\trtlefuse->txpwr_5g_bw40diff[rf_path][i] =\n\t\t\t\tpwrinfo5g.bw40_diff[rf_path][i];\n\t\t\trtlefuse->txpwr_5g_bw80diff[rf_path][i] =\n\t\t\t\tpwrinfo5g.bw80_diff[rf_path][i];\n\t\t}\n\t}\n\t \n\tif (!autoload_fail) {\n\t\trtlefuse->eeprom_regulatory = hwinfo[EEPROM_RF_BOARD_OPTION] & 0x07;\n\t\tif (hwinfo[EEPROM_RF_BOARD_OPTION] == 0xFF)\n\t\t\trtlefuse->eeprom_regulatory = 0;\n\t} else {\n\t\trtlefuse->eeprom_regulatory = 0;\n\t}\n\n\tRTPRINT(rtlpriv, FINIT, INIT_TXPOWER,\n\t\"eeprom_regulatory = 0x%x\\n\", rtlefuse->eeprom_regulatory);\n}\n\nstatic void _rtl8812ae_read_pa_type(struct ieee80211_hw *hw, u8 *hwinfo,\n\t\t\t\t    bool autoload_fail)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\n\n\tif (!autoload_fail) {\n\t\trtlhal->pa_type_2g = hwinfo[0XBC];\n\t\trtlhal->lna_type_2g = hwinfo[0XBD];\n\t\tif (rtlhal->pa_type_2g == 0xFF && rtlhal->lna_type_2g == 0xFF) {\n\t\t\trtlhal->pa_type_2g = 0;\n\t\t\trtlhal->lna_type_2g = 0;\n\t\t}\n\t\trtlhal->external_pa_2g = ((rtlhal->pa_type_2g & BIT(5)) &&\n\t\t\t\t\t  (rtlhal->pa_type_2g & BIT(4))) ?\n\t\t\t\t\t 1 : 0;\n\t\trtlhal->external_lna_2g = ((rtlhal->lna_type_2g & BIT(7)) &&\n\t\t\t\t\t   (rtlhal->lna_type_2g & BIT(3))) ?\n\t\t\t\t\t  1 : 0;\n\n\t\trtlhal->pa_type_5g = hwinfo[0XBC];\n\t\trtlhal->lna_type_5g = hwinfo[0XBF];\n\t\tif (rtlhal->pa_type_5g == 0xFF && rtlhal->lna_type_5g == 0xFF) {\n\t\t\trtlhal->pa_type_5g = 0;\n\t\t\trtlhal->lna_type_5g = 0;\n\t\t}\n\t\trtlhal->external_pa_5g = ((rtlhal->pa_type_5g & BIT(1)) &&\n\t\t\t\t\t  (rtlhal->pa_type_5g & BIT(0))) ?\n\t\t\t\t\t 1 : 0;\n\t\trtlhal->external_lna_5g = ((rtlhal->lna_type_5g & BIT(7)) &&\n\t\t\t\t\t   (rtlhal->lna_type_5g & BIT(3))) ?\n\t\t\t\t\t  1 : 0;\n\t} else {\n\t\trtlhal->external_pa_2g  = 0;\n\t\trtlhal->external_lna_2g = 0;\n\t\trtlhal->external_pa_5g  = 0;\n\t\trtlhal->external_lna_5g = 0;\n\t}\n}\n\nstatic void _rtl8812ae_read_amplifier_type(struct ieee80211_hw *hw, u8 *hwinfo,\n\t\t\t\t\t   bool autoload_fail)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\n\n\tu8 ext_type_pa_2g_a  = (hwinfo[0XBD] & BIT(2))      >> 2;  \n\tu8 ext_type_pa_2g_b  = (hwinfo[0XBD] & BIT(6))      >> 6;  \n\tu8 ext_type_pa_5g_a  = (hwinfo[0XBF] & BIT(2))      >> 2;  \n\tu8 ext_type_pa_5g_b  = (hwinfo[0XBF] & BIT(6))      >> 6;  \n\t \n\tu8 ext_type_lna_2g_a = (hwinfo[0XBD] & (BIT(1) | BIT(0))) >> 0;\n\t \n\tu8 ext_type_lna_2g_b = (hwinfo[0XBD] & (BIT(5) | BIT(4))) >> 4;\n\t \n\tu8 ext_type_lna_5g_a = (hwinfo[0XBF] & (BIT(1) | BIT(0))) >> 0;\n\t \n\tu8 ext_type_lna_5g_b = (hwinfo[0XBF] & (BIT(5) | BIT(4))) >> 4;\n\n\t_rtl8812ae_read_pa_type(hw, hwinfo, autoload_fail);\n\n\t \n\tif ((rtlhal->pa_type_2g & (BIT(5) | BIT(4))) == (BIT(5) | BIT(4)))\n\t\trtlhal->type_gpa  = ext_type_pa_2g_b  << 2 | ext_type_pa_2g_a;\n\n\t \n\tif ((rtlhal->pa_type_5g & (BIT(1) | BIT(0))) == (BIT(1) | BIT(0)))\n\t\trtlhal->type_apa  = ext_type_pa_5g_b  << 2 | ext_type_pa_5g_a;\n\n\t \n\tif ((rtlhal->lna_type_2g & (BIT(7) | BIT(3))) == (BIT(7) | BIT(3)))\n\t\trtlhal->type_glna = ext_type_lna_2g_b << 2 | ext_type_lna_2g_a;\n\n\t \n\tif ((rtlhal->lna_type_5g & (BIT(7) | BIT(3))) == (BIT(7) | BIT(3)))\n\t\trtlhal->type_alna = ext_type_lna_5g_b << 2 | ext_type_lna_5g_a;\n}\n\nstatic void _rtl8821ae_read_pa_type(struct ieee80211_hw *hw, u8 *hwinfo,\n\t\t\t\t    bool autoload_fail)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\n\n\tif (!autoload_fail) {\n\t\trtlhal->pa_type_2g = hwinfo[0XBC];\n\t\trtlhal->lna_type_2g = hwinfo[0XBD];\n\t\tif (rtlhal->pa_type_2g == 0xFF && rtlhal->lna_type_2g == 0xFF) {\n\t\t\trtlhal->pa_type_2g = 0;\n\t\t\trtlhal->lna_type_2g = 0;\n\t\t}\n\t\trtlhal->external_pa_2g = (rtlhal->pa_type_2g & BIT(5)) ? 1 : 0;\n\t\trtlhal->external_lna_2g = (rtlhal->lna_type_2g & BIT(7)) ? 1 : 0;\n\n\t\trtlhal->pa_type_5g = hwinfo[0XBC];\n\t\trtlhal->lna_type_5g = hwinfo[0XBF];\n\t\tif (rtlhal->pa_type_5g == 0xFF && rtlhal->lna_type_5g == 0xFF) {\n\t\t\trtlhal->pa_type_5g = 0;\n\t\t\trtlhal->lna_type_5g = 0;\n\t\t}\n\t\trtlhal->external_pa_5g = (rtlhal->pa_type_5g & BIT(1)) ? 1 : 0;\n\t\trtlhal->external_lna_5g = (rtlhal->lna_type_5g & BIT(7)) ? 1 : 0;\n\t} else {\n\t\trtlhal->external_pa_2g  = 0;\n\t\trtlhal->external_lna_2g = 0;\n\t\trtlhal->external_pa_5g  = 0;\n\t\trtlhal->external_lna_5g = 0;\n\t}\n}\n\nstatic void _rtl8821ae_read_rfe_type(struct ieee80211_hw *hw, u8 *hwinfo,\n\t\t\t      bool autoload_fail)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\n\n\tif (!autoload_fail) {\n\t\tif (hwinfo[EEPROM_RFE_OPTION] & BIT(7)) {\n\t\t\tif (rtlhal->external_lna_5g) {\n\t\t\t\tif (rtlhal->external_pa_5g) {\n\t\t\t\t\tif (rtlhal->external_lna_2g &&\n\t\t\t\t\t    rtlhal->external_pa_2g)\n\t\t\t\t\t\trtlhal->rfe_type = 3;\n\t\t\t\t\telse\n\t\t\t\t\t\trtlhal->rfe_type = 0;\n\t\t\t\t} else {\n\t\t\t\t\trtlhal->rfe_type = 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trtlhal->rfe_type = 4;\n\t\t\t}\n\t\t} else {\n\t\t\trtlhal->rfe_type = hwinfo[EEPROM_RFE_OPTION] & 0x3F;\n\n\t\t\tif (rtlhal->rfe_type == 4 &&\n\t\t\t    (rtlhal->external_pa_5g ||\n\t\t\t     rtlhal->external_pa_2g ||\n\t\t\t     rtlhal->external_lna_5g ||\n\t\t\t     rtlhal->external_lna_2g)) {\n\t\t\t\tif (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE)\n\t\t\t\t\trtlhal->rfe_type = 2;\n\t\t\t}\n\t\t}\n\t} else {\n\t\trtlhal->rfe_type = 0x04;\n\t}\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\"RFE Type: 0x%2x\\n\", rtlhal->rfe_type);\n}\n\nstatic void _rtl8812ae_read_bt_coexist_info_from_hwpg(struct ieee80211_hw *hw,\n\t\t\t\t\t      bool auto_load_fail, u8 *hwinfo)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 value;\n\n\tif (!auto_load_fail) {\n\t\tvalue = *(u8 *)&hwinfo[EEPROM_RF_BOARD_OPTION];\n\t\tif (((value & 0xe0) >> 5) == 0x1)\n\t\t\trtlpriv->btcoexist.btc_info.btcoexist = 1;\n\t\telse\n\t\t\trtlpriv->btcoexist.btc_info.btcoexist = 0;\n\t\trtlpriv->btcoexist.btc_info.bt_type = BT_RTL8812A;\n\n\t\tvalue = hwinfo[EEPROM_RF_BT_SETTING];\n\t\trtlpriv->btcoexist.btc_info.ant_num = (value & 0x1);\n\t} else {\n\t\trtlpriv->btcoexist.btc_info.btcoexist = 0;\n\t\trtlpriv->btcoexist.btc_info.bt_type = BT_RTL8812A;\n\t\trtlpriv->btcoexist.btc_info.ant_num = ANT_X2;\n\t}\n\t \n}\n\nstatic void _rtl8821ae_read_bt_coexist_info_from_hwpg(struct ieee80211_hw *hw,\n\t\t\t\t\t      bool auto_load_fail, u8 *hwinfo)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 value;\n\tu32 tmpu_32;\n\n\tif (!auto_load_fail) {\n\t\ttmpu_32 = rtl_read_dword(rtlpriv, REG_MULTI_FUNC_CTRL);\n\t\tif (tmpu_32 & BIT(18))\n\t\t\trtlpriv->btcoexist.btc_info.btcoexist = 1;\n\t\telse\n\t\t\trtlpriv->btcoexist.btc_info.btcoexist = 0;\n\t\trtlpriv->btcoexist.btc_info.bt_type = BT_RTL8821A;\n\n\t\tvalue = hwinfo[EEPROM_RF_BT_SETTING];\n\t\trtlpriv->btcoexist.btc_info.ant_num = (value & 0x1);\n\t} else {\n\t\trtlpriv->btcoexist.btc_info.btcoexist = 0;\n\t\trtlpriv->btcoexist.btc_info.bt_type = BT_RTL8821A;\n\t\trtlpriv->btcoexist.btc_info.ant_num = ANT_X2;\n\t}\n\t \n}\n\nstatic void _rtl8821ae_read_adapter_info(struct ieee80211_hw *hw, bool b_pseudo_test)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tint params[] = {RTL_EEPROM_ID, EEPROM_VID, EEPROM_DID,\n\t\t\tEEPROM_SVID, EEPROM_SMID, EEPROM_MAC_ADDR,\n\t\t\tEEPROM_CHANNELPLAN, EEPROM_VERSION, EEPROM_CUSTOMER_ID,\n\t\t\tCOUNTRY_CODE_WORLD_WIDE_13};\n\tu8 *hwinfo;\n\n\tif (b_pseudo_test) {\n\t\t; \n\t}\n\n\thwinfo = kzalloc(HWSET_MAX_SIZE, GFP_KERNEL);\n\tif (!hwinfo)\n\t\treturn;\n\n\tif (rtl_get_hwinfo(hw, rtlpriv, HWSET_MAX_SIZE, hwinfo, params))\n\t\tgoto exit;\n\n\t_rtl8821ae_read_txpower_info_from_hwpg(hw, rtlefuse->autoload_failflag,\n\t\t\t\t\t       hwinfo);\n\n\tif (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE) {\n\t\t_rtl8812ae_read_amplifier_type(hw, hwinfo,\n\t\t\t\t\t       rtlefuse->autoload_failflag);\n\t\t_rtl8812ae_read_bt_coexist_info_from_hwpg(hw,\n\t\t\t\trtlefuse->autoload_failflag, hwinfo);\n\t} else {\n\t\t_rtl8821ae_read_pa_type(hw, hwinfo, rtlefuse->autoload_failflag);\n\t\t_rtl8821ae_read_bt_coexist_info_from_hwpg(hw,\n\t\t\t\trtlefuse->autoload_failflag, hwinfo);\n\t}\n\n\t_rtl8821ae_read_rfe_type(hw, hwinfo, rtlefuse->autoload_failflag);\n\t \n\trtlefuse->board_type = ODM_BOARD_DEFAULT;\n\tif (rtlhal->external_lna_2g != 0)\n\t\trtlefuse->board_type |= ODM_BOARD_EXT_LNA;\n\tif (rtlhal->external_lna_5g != 0)\n\t\trtlefuse->board_type |= ODM_BOARD_EXT_LNA_5G;\n\tif (rtlhal->external_pa_2g != 0)\n\t\trtlefuse->board_type |= ODM_BOARD_EXT_PA;\n\tif (rtlhal->external_pa_5g != 0)\n\t\trtlefuse->board_type |= ODM_BOARD_EXT_PA_5G;\n\n\tif (rtlpriv->btcoexist.btc_info.btcoexist == 1)\n\t\trtlefuse->board_type |= ODM_BOARD_BT;\n\n\trtlhal->board_type = rtlefuse->board_type;\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\"board_type = 0x%x\\n\", rtlefuse->board_type);\n\n\trtlefuse->eeprom_channelplan = *(u8 *)&hwinfo[EEPROM_CHANNELPLAN];\n\tif (rtlefuse->eeprom_channelplan == 0xff)\n\t\trtlefuse->eeprom_channelplan = 0x7F;\n\n\t \n\trtlefuse->channel_plan = rtlefuse->eeprom_channelplan;\n\n\t \n\trtlefuse->crystalcap = hwinfo[EEPROM_XTAL_8821AE];\n\tif (rtlefuse->crystalcap == 0xFF)\n\t\trtlefuse->crystalcap = 0x20;\n\n\trtlefuse->eeprom_thermalmeter = *(u8 *)&hwinfo[EEPROM_THERMAL_METER];\n\tif ((rtlefuse->eeprom_thermalmeter == 0xff) ||\n\t    rtlefuse->autoload_failflag) {\n\t\trtlefuse->apk_thermalmeterignore = true;\n\t\trtlefuse->eeprom_thermalmeter = 0xff;\n\t}\n\n\trtlefuse->thermalmeter[0] = rtlefuse->eeprom_thermalmeter;\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\"thermalmeter = 0x%x\\n\", rtlefuse->eeprom_thermalmeter);\n\n\tif (!rtlefuse->autoload_failflag) {\n\t\trtlefuse->antenna_div_cfg =\n\t\t  (hwinfo[EEPROM_RF_BOARD_OPTION] & 0x18) >> 3;\n\t\tif (hwinfo[EEPROM_RF_BOARD_OPTION] == 0xff)\n\t\t\trtlefuse->antenna_div_cfg = 0;\n\n\t\tif (rtlpriv->btcoexist.btc_info.btcoexist == 1 &&\n\t\t    rtlpriv->btcoexist.btc_info.ant_num == ANT_X1)\n\t\t\trtlefuse->antenna_div_cfg = 0;\n\n\t\trtlefuse->antenna_div_type = hwinfo[EEPROM_RF_ANTENNA_OPT_88E];\n\t\tif (rtlefuse->antenna_div_type == 0xff)\n\t\t\trtlefuse->antenna_div_type = FIXED_HW_ANTDIV;\n\t} else {\n\t\trtlefuse->antenna_div_cfg = 0;\n\t\trtlefuse->antenna_div_type = 0;\n\t}\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\"SWAS: bHwAntDiv = %x, TRxAntDivType = %x\\n\",\n\t\trtlefuse->antenna_div_cfg, rtlefuse->antenna_div_type);\n\n\trtlpriv->ledctl.led_opendrain = true;\n\n\tif (rtlhal->oem_id == RT_CID_DEFAULT) {\n\t\tswitch (rtlefuse->eeprom_oemid) {\n\t\tcase RT_CID_DEFAULT:\n\t\t\tbreak;\n\t\tcase EEPROM_CID_TOSHIBA:\n\t\t\trtlhal->oem_id = RT_CID_TOSHIBA;\n\t\t\tbreak;\n\t\tcase EEPROM_CID_CCX:\n\t\t\trtlhal->oem_id = RT_CID_CCX;\n\t\t\tbreak;\n\t\tcase EEPROM_CID_QMI:\n\t\t\trtlhal->oem_id = RT_CID_819X_QMI;\n\t\t\tbreak;\n\t\tcase EEPROM_CID_WHQL:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\nexit:\n\tkfree(hwinfo);\n}\n\n \n\nvoid rtl8821ae_read_eeprom_info(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tu8 tmp_u1b;\n\n\trtlhal->version = _rtl8821ae_read_chip_version(hw);\n\tif (get_rf_type(rtlphy) == RF_1T1R)\n\t\trtlpriv->dm.rfpath_rxenable[0] = true;\n\telse\n\t\trtlpriv->dm.rfpath_rxenable[0] =\n\t\t    rtlpriv->dm.rfpath_rxenable[1] = true;\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD, \"VersionID = 0x%4x\\n\",\n\t\trtlhal->version);\n\n\ttmp_u1b = rtl_read_byte(rtlpriv, REG_9346CR);\n\tif (tmp_u1b & BIT(4)) {\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG, \"Boot from EEPROM\\n\");\n\t\trtlefuse->epromtype = EEPROM_93C46;\n\t} else {\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG, \"Boot from EFUSE\\n\");\n\t\trtlefuse->epromtype = EEPROM_BOOT_EFUSE;\n\t}\n\n\tif (tmp_u1b & BIT(5)) {\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD, \"Autoload OK\\n\");\n\t\trtlefuse->autoload_failflag = false;\n\t\t_rtl8821ae_read_adapter_info(hw, false);\n\t} else {\n\t\tpr_err(\"Autoload ERR!!\\n\");\n\t}\n\t \n\t \n}\n\nstatic void rtl8821ae_update_hal_rate_table(struct ieee80211_hw *hw,\n\t\tstruct ieee80211_sta *sta)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tu32 ratr_value;\n\tu8 ratr_index = 0;\n\tu8 b_nmode = mac->ht_enable;\n\tu8 mimo_ps = IEEE80211_SMPS_OFF;\n\tu16 shortgi_rate;\n\tu32 tmp_ratr_value;\n\tu8 curtxbw_40mhz = mac->bw_40;\n\tu8 b_curshortgi_40mhz = (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_SGI_40) ?\n\t\t\t\t1 : 0;\n\tu8 b_curshortgi_20mhz = (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_SGI_20) ?\n\t\t\t\t1 : 0;\n\tenum wireless_mode wirelessmode = mac->mode;\n\n\tif (rtlhal->current_bandtype == BAND_ON_5G)\n\t\tratr_value = sta->deflink.supp_rates[1] << 4;\n\telse\n\t\tratr_value = sta->deflink.supp_rates[0];\n\tif (mac->opmode == NL80211_IFTYPE_ADHOC)\n\t\tratr_value = 0xfff;\n\tratr_value |= (sta->deflink.ht_cap.mcs.rx_mask[1] << 20 |\n\t\t\tsta->deflink.ht_cap.mcs.rx_mask[0] << 12);\n\tswitch (wirelessmode) {\n\tcase WIRELESS_MODE_B:\n\t\tif (ratr_value & 0x0000000c)\n\t\t\tratr_value &= 0x0000000d;\n\t\telse\n\t\t\tratr_value &= 0x0000000f;\n\t\tbreak;\n\tcase WIRELESS_MODE_G:\n\t\tratr_value &= 0x00000FF5;\n\t\tbreak;\n\tcase WIRELESS_MODE_N_24G:\n\tcase WIRELESS_MODE_N_5G:\n\t\tb_nmode = 1;\n\t\tif (mimo_ps == IEEE80211_SMPS_STATIC) {\n\t\t\tratr_value &= 0x0007F005;\n\t\t} else {\n\t\t\tu32 ratr_mask;\n\n\t\t\tif (get_rf_type(rtlphy) == RF_1T2R ||\n\t\t\t    get_rf_type(rtlphy) == RF_1T1R)\n\t\t\t\tratr_mask = 0x000ff005;\n\t\t\telse\n\t\t\t\tratr_mask = 0x0f0ff005;\n\n\t\t\tratr_value &= ratr_mask;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif (rtlphy->rf_type == RF_1T2R)\n\t\t\tratr_value &= 0x000ff0ff;\n\t\telse\n\t\t\tratr_value &= 0x0f0ff0ff;\n\n\t\tbreak;\n\t}\n\n\tif ((rtlpriv->btcoexist.bt_coexistence) &&\n\t     (rtlpriv->btcoexist.bt_coexist_type == BT_CSR_BC4) &&\n\t     (rtlpriv->btcoexist.bt_cur_state) &&\n\t     (rtlpriv->btcoexist.bt_ant_isolation) &&\n\t     ((rtlpriv->btcoexist.bt_service == BT_SCO) ||\n\t     (rtlpriv->btcoexist.bt_service == BT_BUSY)))\n\t\tratr_value &= 0x0fffcfc0;\n\telse\n\t\tratr_value &= 0x0FFFFFFF;\n\n\tif (b_nmode && ((curtxbw_40mhz &&\n\t\t\t b_curshortgi_40mhz) || (!curtxbw_40mhz &&\n\t\t\t\t\t\t b_curshortgi_20mhz))) {\n\t\tratr_value |= 0x10000000;\n\t\ttmp_ratr_value = (ratr_value >> 12);\n\n\t\tfor (shortgi_rate = 15; shortgi_rate > 0; shortgi_rate--) {\n\t\t\tif ((1 << shortgi_rate) & tmp_ratr_value)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tshortgi_rate = (shortgi_rate << 12) | (shortgi_rate << 8) |\n\t\t    (shortgi_rate << 4) | (shortgi_rate);\n\t}\n\n\trtl_write_dword(rtlpriv, REG_ARFR0 + ratr_index * 4, ratr_value);\n\n\trtl_dbg(rtlpriv, COMP_RATR, DBG_DMESG,\n\t\t\"%x\\n\", rtl_read_dword(rtlpriv, REG_ARFR0));\n}\n\nstatic u32 _rtl8821ae_rate_to_bitmap_2ssvht(__le16 vht_rate)\n{\n\tu8 i, j, tmp_rate;\n\tu32 rate_bitmap = 0;\n\n\tfor (i = j = 0; i < 4; i += 2, j += 10) {\n\t\ttmp_rate = (le16_to_cpu(vht_rate) >> i) & 3;\n\n\t\tswitch (tmp_rate) {\n\t\tcase 2:\n\t\t\trate_bitmap = rate_bitmap | (0x03ff << j);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\trate_bitmap = rate_bitmap | (0x01ff << j);\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\trate_bitmap = rate_bitmap | (0x00ff << j);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rate_bitmap;\n}\n\nstatic u32 _rtl8821ae_set_ra_vht_ratr_bitmap(struct ieee80211_hw *hw,\n\t\t\t\t\t     enum wireless_mode wirelessmode,\n\t\t\t\t\t     u32 ratr_bitmap)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\tu32 ret_bitmap = ratr_bitmap;\n\n\tif (rtlphy->current_chan_bw == HT_CHANNEL_WIDTH_20_40\n\t\t|| rtlphy->current_chan_bw == HT_CHANNEL_WIDTH_80)\n\t\tret_bitmap = ratr_bitmap;\n\telse if (wirelessmode == WIRELESS_MODE_AC_5G\n\t\t|| wirelessmode == WIRELESS_MODE_AC_24G) {\n\t\tif (rtlphy->rf_type == RF_1T1R)\n\t\t\tret_bitmap = ratr_bitmap & (~BIT21);\n\t\telse\n\t\t\tret_bitmap = ratr_bitmap & (~(BIT31|BIT21));\n\t}\n\n\treturn ret_bitmap;\n}\n\nstatic u8 _rtl8821ae_get_vht_eni(enum wireless_mode wirelessmode,\n\t\t\tu32 ratr_bitmap)\n{\n\tu8 ret = 0;\n\tif (wirelessmode < WIRELESS_MODE_N_24G)\n\t\tret =  0;\n\telse if (wirelessmode == WIRELESS_MODE_AC_24G) {\n\t\tif (ratr_bitmap & 0xfff00000)\t \n\t\t\tret = 3;\n\t\telse\t\t\t\t\t \n\t\t\tret = 2;\n\t} else if (wirelessmode == WIRELESS_MODE_AC_5G) {\n\t\t\tret = 1;\n\t}  \n\n\treturn ret << 4;\n}\n\nstatic u8 _rtl8821ae_get_ra_ldpc(struct ieee80211_hw *hw,\n\t\t\t     u8 mac_id, struct rtl_sta_info *sta_entry,\n\t\t\t     enum wireless_mode wirelessmode)\n{\n\tu8 b_ldpc = 0;\n\t \n\treturn b_ldpc << 2;\n}\n\nstatic u8 _rtl8821ae_get_ra_rftype(struct ieee80211_hw *hw,\n\t\t\t  enum wireless_mode wirelessmode,\n\t\t\t  u32 ratr_bitmap)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\tu8 rf_type = RF_1T1R;\n\n\tif (rtlphy->rf_type == RF_1T1R)\n\t\trf_type = RF_1T1R;\n\telse if (wirelessmode == WIRELESS_MODE_AC_5G\n\t\t|| wirelessmode == WIRELESS_MODE_AC_24G\n\t\t|| wirelessmode == WIRELESS_MODE_AC_ONLY) {\n\t\tif (ratr_bitmap & 0xffc00000)\n\t\t\trf_type = RF_2T2R;\n\t} else if (wirelessmode == WIRELESS_MODE_N_5G\n\t\t|| wirelessmode == WIRELESS_MODE_N_24G) {\n\t\tif (ratr_bitmap & 0xfff00000)\n\t\t\trf_type = RF_2T2R;\n\t}\n\n\treturn rf_type;\n}\n\nstatic bool _rtl8821ae_get_ra_shortgi(struct ieee80211_hw *hw, struct ieee80211_sta *sta,\n\t\t\t      u8 mac_id)\n{\n\tbool b_short_gi = false;\n\tu8 b_curshortgi_40mhz = (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_SGI_40) ?\n\t\t\t\t1 : 0;\n\tu8 b_curshortgi_20mhz = (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_SGI_20) ?\n\t\t\t\t1 : 0;\n\tu8 b_curshortgi_80mhz = 0;\n\tb_curshortgi_80mhz = (sta->deflink.vht_cap.cap &\n\t\t\t      IEEE80211_VHT_CAP_SHORT_GI_80) ? 1 : 0;\n\n\tif (mac_id == MAC_ID_STATIC_FOR_BROADCAST_MULTICAST)\n\t\t\tb_short_gi = false;\n\n\tif (b_curshortgi_40mhz || b_curshortgi_80mhz\n\t\t|| b_curshortgi_20mhz)\n\t\tb_short_gi = true;\n\n\treturn b_short_gi;\n}\n\nstatic void rtl8821ae_update_hal_rate_mask(struct ieee80211_hw *hw,\n\t\tstruct ieee80211_sta *sta, u8 rssi_level, bool update_bw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_sta_info *sta_entry = NULL;\n\tu32 ratr_bitmap;\n\tu8 ratr_index;\n\tenum wireless_mode wirelessmode = 0;\n\tu8 curtxbw_40mhz = (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40)\n\t\t\t\t? 1 : 0;\n\tbool b_shortgi = false;\n\tu8 rate_mask[7];\n\tu8 macid = 0;\n\tu8 mimo_ps = IEEE80211_SMPS_OFF;\n\tu8 rf_type;\n\n\tsta_entry = (struct rtl_sta_info *)sta->drv_priv;\n\twirelessmode = sta_entry->wireless_mode;\n\n\trtl_dbg(rtlpriv, COMP_RATR, DBG_LOUD,\n\t\t\"wireless mode = 0x%x\\n\", wirelessmode);\n\tif (mac->opmode == NL80211_IFTYPE_STATION ||\n\t\tmac->opmode == NL80211_IFTYPE_MESH_POINT) {\n\t\tcurtxbw_40mhz = mac->bw_40;\n\t} else if (mac->opmode == NL80211_IFTYPE_AP ||\n\t\tmac->opmode == NL80211_IFTYPE_ADHOC)\n\t\tmacid = sta->aid + 1;\n\tif (wirelessmode == WIRELESS_MODE_N_5G ||\n\t    wirelessmode == WIRELESS_MODE_AC_5G ||\n\t    wirelessmode == WIRELESS_MODE_A)\n\t\tratr_bitmap = sta->deflink.supp_rates[NL80211_BAND_5GHZ] << 4;\n\telse\n\t\tratr_bitmap = sta->deflink.supp_rates[NL80211_BAND_2GHZ];\n\n\tif (mac->opmode == NL80211_IFTYPE_ADHOC)\n\t\tratr_bitmap = 0xfff;\n\n\tif (wirelessmode == WIRELESS_MODE_N_24G\n\t\t|| wirelessmode == WIRELESS_MODE_N_5G)\n\t\tratr_bitmap |= (sta->deflink.ht_cap.mcs.rx_mask[1] << 20 |\n\t\t\t\tsta->deflink.ht_cap.mcs.rx_mask[0] << 12);\n\telse if (wirelessmode == WIRELESS_MODE_AC_24G\n\t\t|| wirelessmode == WIRELESS_MODE_AC_5G\n\t\t|| wirelessmode == WIRELESS_MODE_AC_ONLY)\n\t\tratr_bitmap |= _rtl8821ae_rate_to_bitmap_2ssvht(\n\t\t\t\tsta->deflink.vht_cap.vht_mcs.rx_mcs_map) << 12;\n\n\tb_shortgi = _rtl8821ae_get_ra_shortgi(hw, sta, macid);\n\trf_type = _rtl8821ae_get_ra_rftype(hw, wirelessmode, ratr_bitmap);\n\n \n\tswitch (wirelessmode) {\n\tcase WIRELESS_MODE_B:\n\t\tratr_index = RATR_INX_WIRELESS_B;\n\t\tif (ratr_bitmap & 0x0000000c)\n\t\t\tratr_bitmap &= 0x0000000d;\n\t\telse\n\t\t\tratr_bitmap &= 0x0000000f;\n\t\tbreak;\n\tcase WIRELESS_MODE_G:\n\t\tratr_index = RATR_INX_WIRELESS_GB;\n\n\t\tif (rssi_level == 1)\n\t\t\tratr_bitmap &= 0x00000f00;\n\t\telse if (rssi_level == 2)\n\t\t\tratr_bitmap &= 0x00000ff0;\n\t\telse\n\t\t\tratr_bitmap &= 0x00000ff5;\n\t\tbreak;\n\tcase WIRELESS_MODE_A:\n\t\tratr_index = RATR_INX_WIRELESS_G;\n\t\tratr_bitmap &= 0x00000ff0;\n\t\tbreak;\n\tcase WIRELESS_MODE_N_24G:\n\tcase WIRELESS_MODE_N_5G:\n\t\tif (wirelessmode == WIRELESS_MODE_N_24G)\n\t\t\tratr_index = RATR_INX_WIRELESS_NGB;\n\t\telse\n\t\t\tratr_index = RATR_INX_WIRELESS_NG;\n\n\t\tif (mimo_ps == IEEE80211_SMPS_STATIC\n\t\t\t|| mimo_ps == IEEE80211_SMPS_DYNAMIC) {\n\t\t\tif (rssi_level == 1)\n\t\t\t\tratr_bitmap &= 0x000f0000;\n\t\t\telse if (rssi_level == 2)\n\t\t\t\tratr_bitmap &= 0x000ff000;\n\t\t\telse\n\t\t\t\tratr_bitmap &= 0x000ff005;\n\t\t} else {\n\t\t\tif (rf_type == RF_1T1R) {\n\t\t\t\tif (curtxbw_40mhz) {\n\t\t\t\t\tif (rssi_level == 1)\n\t\t\t\t\t\tratr_bitmap &= 0x000f0000;\n\t\t\t\t\telse if (rssi_level == 2)\n\t\t\t\t\t\tratr_bitmap &= 0x000ff000;\n\t\t\t\t\telse\n\t\t\t\t\t\tratr_bitmap &= 0x000ff015;\n\t\t\t\t} else {\n\t\t\t\t\tif (rssi_level == 1)\n\t\t\t\t\t\tratr_bitmap &= 0x000f0000;\n\t\t\t\t\telse if (rssi_level == 2)\n\t\t\t\t\t\tratr_bitmap &= 0x000ff000;\n\t\t\t\t\telse\n\t\t\t\t\t\tratr_bitmap &= 0x000ff005;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (curtxbw_40mhz) {\n\t\t\t\t\tif (rssi_level == 1)\n\t\t\t\t\t\tratr_bitmap &= 0x0fff0000;\n\t\t\t\t\telse if (rssi_level == 2)\n\t\t\t\t\t\tratr_bitmap &= 0x0ffff000;\n\t\t\t\t\telse\n\t\t\t\t\t\tratr_bitmap &= 0x0ffff015;\n\t\t\t\t} else {\n\t\t\t\t\tif (rssi_level == 1)\n\t\t\t\t\t\tratr_bitmap &= 0x0fff0000;\n\t\t\t\t\telse if (rssi_level == 2)\n\t\t\t\t\t\tratr_bitmap &= 0x0ffff000;\n\t\t\t\t\telse\n\t\t\t\t\t\tratr_bitmap &= 0x0ffff005;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase WIRELESS_MODE_AC_24G:\n\t\tratr_index = RATR_INX_WIRELESS_AC_24N;\n\t\tif (rssi_level == 1)\n\t\t\tratr_bitmap &= 0xfc3f0000;\n\t\telse if (rssi_level == 2)\n\t\t\tratr_bitmap &= 0xfffff000;\n\t\telse\n\t\t\tratr_bitmap &= 0xffffffff;\n\t\tbreak;\n\n\tcase WIRELESS_MODE_AC_5G:\n\t\tratr_index = RATR_INX_WIRELESS_AC_5N;\n\n\t\tif (rf_type == RF_1T1R) {\n\t\t\tif (rssi_level == 1)\t \n\t\t\t\tratr_bitmap &= 0x003f8000;\n\t\t\telse if (rssi_level == 2)\n\t\t\t\tratr_bitmap &= 0x003ff000;\n\t\t\telse\n\t\t\t\tratr_bitmap &= 0x003ff010;\n\t\t} else {\n\t\t\tif (rssi_level == 1)\n\t\t\t\tratr_bitmap &= 0xfe3f8000;\n\t\t\telse if (rssi_level == 2)\n\t\t\t\tratr_bitmap &= 0xfffff000;\n\t\t\telse\n\t\t\t\tratr_bitmap &= 0xfffff010;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tratr_index = RATR_INX_WIRELESS_NGB;\n\n\t\tif (rf_type == RF_1T2R)\n\t\t\tratr_bitmap &= 0x000ff0ff;\n\t\telse\n\t\t\tratr_bitmap &= 0x0f8ff0ff;\n\t\tbreak;\n\t}\n\n\tratr_index = rtl_mrate_idx_to_arfr_id(hw, ratr_index, wirelessmode);\n\tsta_entry->ratr_index = ratr_index;\n\tratr_bitmap = _rtl8821ae_set_ra_vht_ratr_bitmap(hw, wirelessmode,\n\t\t\t\t\t\t\tratr_bitmap);\n\n\trtl_dbg(rtlpriv, COMP_RATR, DBG_LOUD,\n\t\t\"ratr_bitmap :%x\\n\", ratr_bitmap);\n\n\t \n\n\trate_mask[0] = macid;\n\trate_mask[1] = ratr_index | (b_shortgi ? 0x80 : 0x00);\n\trate_mask[2] = rtlphy->current_chan_bw | ((!update_bw) << 3)\n\t\t\t   | _rtl8821ae_get_vht_eni(wirelessmode, ratr_bitmap)\n\t\t\t   | _rtl8821ae_get_ra_ldpc(hw, macid, sta_entry, wirelessmode);\n\n\trate_mask[3] = (u8)(ratr_bitmap & 0x000000ff);\n\trate_mask[4] = (u8)((ratr_bitmap & 0x0000ff00) >> 8);\n\trate_mask[5] = (u8)((ratr_bitmap & 0x00ff0000) >> 16);\n\trate_mask[6] = (u8)((ratr_bitmap & 0xff000000) >> 24);\n\n\trtl_dbg(rtlpriv, COMP_RATR, DBG_DMESG,\n\t\t\"Rate_index:%x, ratr_val:%x, %x:%x:%x:%x:%x:%x:%x\\n\",\n\t\tratr_index, ratr_bitmap,\n\t\trate_mask[0], rate_mask[1],\n\t\t rate_mask[2], rate_mask[3],\n\t\t rate_mask[4], rate_mask[5],\n\t\t rate_mask[6]);\n\trtl8821ae_fill_h2c_cmd(hw, H2C_8821AE_RA_MASK, 7, rate_mask);\n\t_rtl8821ae_set_bcn_ctrl_reg(hw, BIT(3), 0);\n}\n\nvoid rtl8821ae_update_hal_rate_tbl(struct ieee80211_hw *hw,\n\t\tstruct ieee80211_sta *sta, u8 rssi_level, bool update_bw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tif (rtlpriv->dm.useramask)\n\t\trtl8821ae_update_hal_rate_mask(hw, sta, rssi_level, update_bw);\n\telse\n\t\t \n\t\trtl8821ae_update_hal_rate_table(hw, sta);\n}\n\nvoid rtl8821ae_update_channel_access_setting(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tu16 wireless_mode = mac->mode;\n\tu8 sifs_timer, r2t_sifs;\n\n\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_SLOT_TIME,\n\t\t\t\t      (u8 *)&mac->slot_time);\n\tif (wireless_mode == WIRELESS_MODE_G)\n\t\tsifs_timer = 0x0a;\n\telse\n\t\tsifs_timer = 0x0e;\n\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_SIFS, (u8 *)&sifs_timer);\n\n\tr2t_sifs = 0xa;\n\n\tif (wireless_mode == WIRELESS_MODE_AC_5G &&\n\t    (mac->vht_ldpc_cap & LDPC_VHT_ENABLE_RX) &&\n\t    (mac->vht_stbc_cap & STBC_VHT_ENABLE_RX)) {\n\t\tif (mac->vendor == PEER_ATH)\n\t\t\tr2t_sifs = 0x8;\n\t\telse\n\t\t\tr2t_sifs = 0xa;\n\t} else if (wireless_mode == WIRELESS_MODE_AC_5G) {\n\t\tr2t_sifs = 0xa;\n\t}\n\n\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_R2T_SIFS, (u8 *)&r2t_sifs);\n}\n\nbool rtl8821ae_gpio_radio_on_off_checking(struct ieee80211_hw *hw, u8 *valid)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\tenum rf_pwrstate e_rfpowerstate_toset;\n\tu8 u1tmp = 0;\n\tbool b_actuallyset = false;\n\n\tif (rtlpriv->rtlhal.being_init_adapter)\n\t\treturn false;\n\n\tif (ppsc->swrf_processing)\n\t\treturn false;\n\n\tspin_lock(&rtlpriv->locks.rf_ps_lock);\n\tif (ppsc->rfchange_inprogress) {\n\t\tspin_unlock(&rtlpriv->locks.rf_ps_lock);\n\t\treturn false;\n\t} else {\n\t\tppsc->rfchange_inprogress = true;\n\t\tspin_unlock(&rtlpriv->locks.rf_ps_lock);\n\t}\n\n\trtl_write_byte(rtlpriv, REG_GPIO_IO_SEL_2,\n\t\t\trtl_read_byte(rtlpriv,\n\t\t\t\t\tREG_GPIO_IO_SEL_2) & ~(BIT(1)));\n\n\tu1tmp = rtl_read_byte(rtlpriv, REG_GPIO_PIN_CTRL_2);\n\n\tif (rtlphy->polarity_ctl)\n\t\te_rfpowerstate_toset = (u1tmp & BIT(1)) ? ERFOFF : ERFON;\n\telse\n\t\te_rfpowerstate_toset = (u1tmp & BIT(1)) ? ERFON : ERFOFF;\n\n\tif ((ppsc->hwradiooff) && (e_rfpowerstate_toset == ERFON)) {\n\t\trtl_dbg(rtlpriv, COMP_RF, DBG_DMESG,\n\t\t\t\"GPIOChangeRF  - HW Radio ON, RF ON\\n\");\n\n\t\te_rfpowerstate_toset = ERFON;\n\t\tppsc->hwradiooff = false;\n\t\tb_actuallyset = true;\n\t} else if ((!ppsc->hwradiooff)\n\t\t   && (e_rfpowerstate_toset == ERFOFF)) {\n\t\trtl_dbg(rtlpriv, COMP_RF, DBG_DMESG,\n\t\t\t\"GPIOChangeRF  - HW Radio OFF, RF OFF\\n\");\n\n\t\te_rfpowerstate_toset = ERFOFF;\n\t\tppsc->hwradiooff = true;\n\t\tb_actuallyset = true;\n\t}\n\n\tif (b_actuallyset) {\n\t\tspin_lock(&rtlpriv->locks.rf_ps_lock);\n\t\tppsc->rfchange_inprogress = false;\n\t\tspin_unlock(&rtlpriv->locks.rf_ps_lock);\n\t} else {\n\t\tif (ppsc->reg_rfps_level & RT_RF_OFF_LEVL_HALT_NIC)\n\t\t\tRT_SET_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_HALT_NIC);\n\n\t\tspin_lock(&rtlpriv->locks.rf_ps_lock);\n\t\tppsc->rfchange_inprogress = false;\n\t\tspin_unlock(&rtlpriv->locks.rf_ps_lock);\n\t}\n\n\t*valid = 1;\n\treturn !ppsc->hwradiooff;\n}\n\nvoid rtl8821ae_set_key(struct ieee80211_hw *hw, u32 key_index,\n\t\t     u8 *p_macaddr, bool is_group, u8 enc_algo,\n\t\t     bool is_wepkey, bool clear_all)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tu8 *macaddr = p_macaddr;\n\tu32 entry_id = 0;\n\tbool is_pairwise = false;\n\n\tstatic u8 cam_const_addr[4][6] = {\n\t\t{0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n\t\t{0x00, 0x00, 0x00, 0x00, 0x00, 0x01},\n\t\t{0x00, 0x00, 0x00, 0x00, 0x00, 0x02},\n\t\t{0x00, 0x00, 0x00, 0x00, 0x00, 0x03}\n\t};\n\tstatic u8 cam_const_broad[] = {\n\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff\n\t};\n\n\tif (clear_all) {\n\t\tu8 idx = 0;\n\t\tu8 cam_offset = 0;\n\t\tu8 clear_number = 5;\n\n\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_DMESG, \"clear_all\\n\");\n\n\t\tfor (idx = 0; idx < clear_number; idx++) {\n\t\t\trtl_cam_mark_invalid(hw, cam_offset + idx);\n\t\t\trtl_cam_empty_entry(hw, cam_offset + idx);\n\n\t\t\tif (idx < 5) {\n\t\t\t\tmemset(rtlpriv->sec.key_buf[idx], 0,\n\t\t\t\t       MAX_KEY_LEN);\n\t\t\t\trtlpriv->sec.key_len[idx] = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tswitch (enc_algo) {\n\t\tcase WEP40_ENCRYPTION:\n\t\t\tenc_algo = CAM_WEP40;\n\t\t\tbreak;\n\t\tcase WEP104_ENCRYPTION:\n\t\t\tenc_algo = CAM_WEP104;\n\t\t\tbreak;\n\t\tcase TKIP_ENCRYPTION:\n\t\t\tenc_algo = CAM_TKIP;\n\t\t\tbreak;\n\t\tcase AESCCMP_ENCRYPTION:\n\t\t\tenc_algo = CAM_AES;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_LOUD,\n\t\t\t\t\"switch case %#x not processed\\n\", enc_algo);\n\t\t\tenc_algo = CAM_TKIP;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_wepkey || rtlpriv->sec.use_defaultkey) {\n\t\t\tmacaddr = cam_const_addr[key_index];\n\t\t\tentry_id = key_index;\n\t\t} else {\n\t\t\tif (is_group) {\n\t\t\t\tmacaddr = cam_const_broad;\n\t\t\t\tentry_id = key_index;\n\t\t\t} else {\n\t\t\t\tif (mac->opmode == NL80211_IFTYPE_AP) {\n\t\t\t\t\tentry_id = rtl_cam_get_free_entry(hw, p_macaddr);\n\t\t\t\t\tif (entry_id >=  TOTAL_CAM_ENTRY) {\n\t\t\t\t\t\tpr_err(\"an not find free hwsecurity cam entry\\n\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tentry_id = CAM_PAIRWISE_KEY_POSITION;\n\t\t\t\t}\n\n\t\t\t\tkey_index = PAIRWISE_KEYIDX;\n\t\t\t\tis_pairwise = true;\n\t\t\t}\n\t\t}\n\n\t\tif (rtlpriv->sec.key_len[key_index] == 0) {\n\t\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_DMESG,\n\t\t\t\t\"delete one entry, entry_id is %d\\n\",\n\t\t\t\tentry_id);\n\t\t\tif (mac->opmode == NL80211_IFTYPE_AP)\n\t\t\t\trtl_cam_del_entry(hw, p_macaddr);\n\t\t\trtl_cam_delete_one_entry(hw, p_macaddr, entry_id);\n\t\t} else {\n\t\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_DMESG,\n\t\t\t\t\"add one entry\\n\");\n\t\t\tif (is_pairwise) {\n\t\t\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_DMESG,\n\t\t\t\t\t\"set Pairwise key\\n\");\n\n\t\t\t\trtl_cam_add_one_entry(hw, macaddr, key_index,\n\t\t\t\t\t\t      entry_id, enc_algo,\n\t\t\t\t\t\t      CAM_CONFIG_NO_USEDK,\n\t\t\t\t\t\t      rtlpriv->sec.key_buf[key_index]);\n\t\t\t} else {\n\t\t\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_DMESG,\n\t\t\t\t\t\"set group key\\n\");\n\n\t\t\t\tif (mac->opmode == NL80211_IFTYPE_ADHOC) {\n\t\t\t\t\trtl_cam_add_one_entry(hw,\n\t\t\t\t\t\t\trtlefuse->dev_addr,\n\t\t\t\t\t\t\tPAIRWISE_KEYIDX,\n\t\t\t\t\t\t\tCAM_PAIRWISE_KEY_POSITION,\n\t\t\t\t\t\t\tenc_algo,\n\t\t\t\t\t\t\tCAM_CONFIG_NO_USEDK,\n\t\t\t\t\t\t\trtlpriv->sec.key_buf\n\t\t\t\t\t\t\t[entry_id]);\n\t\t\t\t}\n\n\t\t\t\trtl_cam_add_one_entry(hw, macaddr, key_index,\n\t\t\t\t\t\tentry_id, enc_algo,\n\t\t\t\t\t\tCAM_CONFIG_NO_USEDK,\n\t\t\t\t\t\trtlpriv->sec.key_buf[entry_id]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid rtl8821ae_bt_reg_init(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\t \n\trtlpriv->btcoexist.reg_bt_iso = 2;\n\t \n\trtlpriv->btcoexist.reg_bt_sco = 3;\n\t \n\trtlpriv->btcoexist.reg_bt_sco = 0;\n}\n\nvoid rtl8821ae_bt_hw_init(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\tif (rtlpriv->cfg->ops->get_btc_status())\n\t\trtlpriv->btcoexist.btc_ops->btc_init_hw_config(rtlpriv);\n}\n\nvoid rtl8821ae_suspend(struct ieee80211_hw *hw)\n{\n}\n\nvoid rtl8821ae_resume(struct ieee80211_hw *hw)\n{\n}\n\n \nvoid rtl8821ae_allow_all_destaddr(struct ieee80211_hw *hw,\n\tbool allow_all_da, bool write_into_reg)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\n\tif (allow_all_da)  \n\t\trtlpci->receive_config |= RCR_AAP;\n\telse  \n\t\trtlpci->receive_config &= ~RCR_AAP;\n\n\tif (write_into_reg)\n\t\trtl_write_dword(rtlpriv, REG_RCR, rtlpci->receive_config);\n\n\trtl_dbg(rtlpriv, COMP_TURBO | COMP_INIT, DBG_LOUD,\n\t\t\"receive_config=0x%08X, write_into_reg=%d\\n\",\n\t\trtlpci->receive_config, write_into_reg);\n}\n\n \nvoid rtl8821ae_add_wowlan_pattern(struct ieee80211_hw *hw,\n\t\t\t\t  struct rtl_wow_pattern *rtl_pattern,\n\t\t\t\t  u8 index)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 cam = 0;\n\tu8 addr = 0;\n\tu16 rxbuf_addr;\n\tu8 tmp, count = 0;\n\tu16 cam_start;\n\tu16 offset;\n\n\t \n\n\t \n\toffset = MAX_RX_DMA_BUFFER_SIZE_8812 / 128;\n\t \n\tcam_start = offset * 128;\n\n\t \n\trtl_write_byte(rtlpriv, REG_PKT_BUFF_ACCESS_CTRL, RXPKT_BUF_SELECT);\n\tfor (addr = 0; addr < WKFMCAM_ADDR_NUM; addr++) {\n\t\t \n\t\trxbuf_addr = (cam_start + index * WKFMCAM_SIZE + addr * 4) >> 3;\n\t\t \n\t\trtl_write_word(rtlpriv, REG_PKTBUF_DBG_CTRL, rxbuf_addr);\n\n\t\tif (addr == 0) {\n\t\t\tcam = BIT(31) | rtl_pattern->crc;\n\n\t\t\tif (rtl_pattern->type == UNICAST_PATTERN)\n\t\t\t\tcam |= BIT(24);\n\t\t\telse if (rtl_pattern->type == MULTICAST_PATTERN)\n\t\t\t\tcam |= BIT(25);\n\t\t\telse if (rtl_pattern->type == BROADCAST_PATTERN)\n\t\t\t\tcam |= BIT(26);\n\n\t\t\trtl_write_dword(rtlpriv, REG_PKTBUF_DBG_DATA_L, cam);\n\t\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_TRACE,\n\t\t\t\t\"WRITE entry[%d] 0x%x: %x\\n\", addr,\n\t\t\t\tREG_PKTBUF_DBG_DATA_L, cam);\n\n\t\t\t \n\t\t\trtl_write_word(rtlpriv, REG_RXPKTBUF_CTRL, 0x0f01);\n\t\t} else if (addr == 2 || addr == 4) { \n\t\t\tcam = rtl_pattern->mask[addr - 2];\n\n\t\t\trtl_write_dword(rtlpriv, REG_PKTBUF_DBG_DATA_L, cam);\n\t\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_TRACE,\n\t\t\t\t\"WRITE entry[%d] 0x%x: %x\\n\", addr,\n\t\t\t\tREG_PKTBUF_DBG_DATA_L, cam);\n\n\t\t\trtl_write_word(rtlpriv, REG_RXPKTBUF_CTRL, 0x0f01);\n\t\t} else if (addr == 3 || addr == 5) { \n\t\t\tcam = rtl_pattern->mask[addr - 2];\n\n\t\t\trtl_write_dword(rtlpriv, REG_PKTBUF_DBG_DATA_H, cam);\n\t\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_TRACE,\n\t\t\t\t\"WRITE entry[%d] 0x%x: %x\\n\", addr,\n\t\t\t\tREG_PKTBUF_DBG_DATA_H, cam);\n\n\t\t\trtl_write_word(rtlpriv, REG_RXPKTBUF_CTRL, 0xf001);\n\t\t}\n\n\t\tcount = 0;\n\t\tdo {\n\t\t\ttmp = rtl_read_byte(rtlpriv, REG_RXPKTBUF_CTRL);\n\t\t\tudelay(2);\n\t\t\tcount++;\n\t\t} while (tmp && count < 100);\n\n\t\tWARN_ONCE((count >= 100),\n\t\t\t  \"rtl8821ae: Write wake up frame mask FAIL %d value!\\n\",\n\t\t\t  tmp);\n\t}\n\t \n\trtl_write_byte(rtlpriv, REG_PKT_BUFF_ACCESS_CTRL,\n\t\t       DISABLE_TRXPKT_BUF_ACCESS);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}