{
  "module_name": "led.c",
  "hash_id": "6ccba8600ed1cadbf571d3df3527791dad3af122cc3834a6ede3d0058d8f57e9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtlwifi/rtl8821ae/led.c",
  "human_readable_source": "\n \n\n#include \"../wifi.h\"\n#include \"../pci.h\"\n#include \"reg.h\"\n#include \"led.h\"\n\nvoid rtl8821ae_sw_led_on(struct ieee80211_hw *hw, enum rtl_led_pin pin)\n{\n\tu8 ledcfg;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtl_dbg(rtlpriv, COMP_LED, DBG_LOUD,\n\t\t\"LedAddr:%X ledpin=%d\\n\", REG_LEDCFG2, pin);\n\n\tswitch (pin) {\n\tcase LED_PIN_GPIO0:\n\t\tbreak;\n\tcase LED_PIN_LED0:\n\t\tledcfg = rtl_read_byte(rtlpriv, REG_LEDCFG2);\n\t\tledcfg &= ~BIT(6);\n\t\trtl_write_byte(rtlpriv,\n\t\t\t       REG_LEDCFG2, (ledcfg & 0xf0) | BIT(5));\n\t\tbreak;\n\tcase LED_PIN_LED1:\n\t\tledcfg = rtl_read_byte(rtlpriv, REG_LEDCFG1);\n\t\trtl_write_byte(rtlpriv, REG_LEDCFG1, ledcfg & 0x10);\n\t\tbreak;\n\tdefault:\n\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_LOUD,\n\t\t\t\"switch case %#x not processed\\n\", pin);\n\t\tbreak;\n\t}\n}\n\nvoid rtl8812ae_sw_led_on(struct ieee80211_hw *hw, enum rtl_led_pin pin)\n{\n\tu16\tledreg = REG_LEDCFG1;\n\tu8\tledcfg = 0;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\tswitch (pin) {\n\tcase LED_PIN_LED0:\n\t\tledreg = REG_LEDCFG1;\n\t\tbreak;\n\n\tcase LED_PIN_LED1:\n\t\tledreg = REG_LEDCFG2;\n\t\tbreak;\n\n\tcase LED_PIN_GPIO0:\n\tdefault:\n\t\tbreak;\n\t}\n\n\trtl_dbg(rtlpriv, COMP_LED, DBG_LOUD,\n\t\t\"In SwLedOn, LedAddr:%X LEDPIN=%d\\n\",\n\t\tledreg, pin);\n\n\tledcfg =  rtl_read_byte(rtlpriv, ledreg);\n\tledcfg |= BIT(5);  \n\tledcfg &= ~(BIT(7) | BIT(6) | BIT(3) | BIT(2) | BIT(1) | BIT(0));\n\t\t \n\trtl_write_byte(rtlpriv, ledreg, ledcfg);  \n}\n\nvoid rtl8821ae_sw_led_off(struct ieee80211_hw *hw, enum rtl_led_pin pin)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 ledcfg;\n\n\trtl_dbg(rtlpriv, COMP_LED, DBG_LOUD,\n\t\t\"LedAddr:%X ledpin=%d\\n\", REG_LEDCFG2, pin);\n\n\tledcfg = rtl_read_byte(rtlpriv, REG_LEDCFG2);\n\n\tswitch (pin) {\n\tcase LED_PIN_GPIO0:\n\t\tbreak;\n\tcase LED_PIN_LED0:\n\t\tledcfg &= 0xf0;\n\t\tif (rtlpriv->ledctl.led_opendrain) {\n\t\t\tledcfg &= 0x90;  \n\t\t\trtl_write_byte(rtlpriv, REG_LEDCFG2, (ledcfg|BIT(3)));\n\t\t\tledcfg = rtl_read_byte(rtlpriv, REG_MAC_PINMUX_CFG);\n\t\t\tledcfg &= 0xFE;\n\t\t\trtl_write_byte(rtlpriv, REG_MAC_PINMUX_CFG, ledcfg);\n\t\t} else {\n\t\t\tledcfg &= ~BIT(6);\n\t\t\trtl_write_byte(rtlpriv, REG_LEDCFG2,\n\t\t\t\t       (ledcfg | BIT(3) | BIT(5)));\n\t\t}\n\t\tbreak;\n\tcase LED_PIN_LED1:\n\t\tledcfg = rtl_read_byte(rtlpriv, REG_LEDCFG1);\n\t\tledcfg &= 0x10;  \n\t\trtl_write_byte(rtlpriv, REG_LEDCFG1, ledcfg|BIT(3));\n\t\tbreak;\n\tdefault:\n\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_LOUD,\n\t\t\t\"switch case %#x not processed\\n\", pin);\n\t\tbreak;\n\t}\n}\n\nvoid rtl8812ae_sw_led_off(struct ieee80211_hw *hw, enum rtl_led_pin pin)\n{\n\tu16 ledreg = REG_LEDCFG1;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\tswitch (pin) {\n\tcase LED_PIN_LED0:\n\t\tledreg = REG_LEDCFG1;\n\t\tbreak;\n\n\tcase LED_PIN_LED1:\n\t\tledreg = REG_LEDCFG2;\n\t\tbreak;\n\n\tcase LED_PIN_GPIO0:\n\tdefault:\n\t\tbreak;\n\t}\n\n\trtl_dbg(rtlpriv, COMP_LED, DBG_LOUD,\n\t\t\"In SwLedOff,LedAddr:%X LEDPIN=%d\\n\",\n\t\tledreg, pin);\n\t \n\tif (rtlpriv->ledctl.led_opendrain) {\n\t\tu8 ledcfg = rtl_read_byte(rtlpriv, ledreg);\n\n\t\tledreg &= 0xd0;  \n\t\trtl_write_byte(rtlpriv, ledreg, (ledcfg | BIT(3)));\n\n\t\t \n\t\tledcfg = rtl_read_byte(rtlpriv, REG_MAC_PINMUX_CFG);\n\t\tledcfg &= 0xFE; \n\t\trtl_write_byte(rtlpriv, REG_MAC_PINMUX_CFG, ledcfg);\n\t} else {\n\t\trtl_write_byte(rtlpriv, ledreg, 0x28);\n\t}\n}\n\nstatic void _rtl8821ae_sw_led_control(struct ieee80211_hw *hw,\n\t\t\t\t      enum led_ctl_mode ledaction)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tenum rtl_led_pin pin0 = rtlpriv->ledctl.sw_led0;\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\n\tswitch (ledaction) {\n\tcase LED_CTL_POWER_ON:\n\tcase LED_CTL_LINK:\n\tcase LED_CTL_NO_LINK:\n\t\tif (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE)\n\t\t\trtl8812ae_sw_led_on(hw, pin0);\n\t\telse\n\t\t\trtl8821ae_sw_led_on(hw, pin0);\n\t\tbreak;\n\tcase LED_CTL_POWER_OFF:\n\t\tif (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE)\n\t\t\trtl8812ae_sw_led_off(hw, pin0);\n\t\telse\n\t\t\trtl8821ae_sw_led_off(hw, pin0);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid rtl8821ae_led_control(struct ieee80211_hw *hw,\n\t\t\t   enum led_ctl_mode ledaction)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\n\tif ((ppsc->rfoff_reason > RF_CHANGE_BY_PS) &&\n\t    (ledaction == LED_CTL_TX ||\n\t     ledaction == LED_CTL_RX ||\n\t     ledaction == LED_CTL_SITE_SURVEY ||\n\t     ledaction == LED_CTL_LINK ||\n\t     ledaction == LED_CTL_NO_LINK ||\n\t     ledaction == LED_CTL_START_TO_LINK ||\n\t     ledaction == LED_CTL_POWER_ON)) {\n\t\treturn;\n\t}\n\trtl_dbg(rtlpriv, COMP_LED, DBG_LOUD, \"ledaction %d,\\n\",\n\t\tledaction);\n\t_rtl8821ae_sw_led_control(hw, ledaction);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}