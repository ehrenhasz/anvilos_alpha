{
  "module_name": "rf.c",
  "hash_id": "2ddbf855c47b06aeb53684c21ca8d8b9d077ae7c6adc679080b2a249b237e515",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtlwifi/rtl8821ae/rf.c",
  "human_readable_source": "\n \n\n#include \"../wifi.h\"\n#include \"reg.h\"\n#include \"def.h\"\n#include \"phy.h\"\n#include \"rf.h\"\n#include \"dm.h\"\n\nstatic bool _rtl8821ae_phy_rf6052_config_parafile(struct ieee80211_hw *hw);\n\nvoid rtl8821ae_phy_rf6052_set_bandwidth(struct ieee80211_hw *hw, u8 bandwidth)\n{\n\tswitch (bandwidth) {\n\tcase HT_CHANNEL_WIDTH_20:\n\t\trtl_set_rfreg(hw, RF90_PATH_A, RF_CHNLBW, BIT(11)|BIT(10), 3);\n\t\trtl_set_rfreg(hw, RF90_PATH_B, RF_CHNLBW, BIT(11)|BIT(10), 3);\n\t\tbreak;\n\tcase HT_CHANNEL_WIDTH_20_40:\n\t\trtl_set_rfreg(hw, RF90_PATH_A, RF_CHNLBW, BIT(11)|BIT(10), 1);\n\t\trtl_set_rfreg(hw, RF90_PATH_B, RF_CHNLBW, BIT(11)|BIT(10), 1);\n\t\tbreak;\n\tcase HT_CHANNEL_WIDTH_80:\n\t\trtl_set_rfreg(hw, RF90_PATH_A, RF_CHNLBW, BIT(11)|BIT(10), 0);\n\t\trtl_set_rfreg(hw, RF90_PATH_B, RF_CHNLBW, BIT(11)|BIT(10), 0);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"unknown bandwidth: %#X\\n\", bandwidth);\n\t\tbreak;\n\t}\n}\n\nvoid rtl8821ae_phy_rf6052_set_cck_txpower(struct ieee80211_hw *hw,\n\t\t\t\t\t  u8 *ppowerlevel)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tu32 tx_agc[2] = {0, 0}, tmpval;\n\tbool turbo_scanoff = false;\n\tu8 idx1, idx2;\n\tu8 *ptr;\n\tu8 direction;\n\tu32 pwrtrac_value;\n\n\tif (rtlefuse->eeprom_regulatory != 0)\n\t\tturbo_scanoff = true;\n\n\tif (mac->act_scanning) {\n\t\ttx_agc[RF90_PATH_A] = 0x3f3f3f3f;\n\t\ttx_agc[RF90_PATH_B] = 0x3f3f3f3f;\n\n\t\tif (turbo_scanoff) {\n\t\t\tfor (idx1 = RF90_PATH_A;\n\t\t\t\tidx1 <= RF90_PATH_B;\n\t\t\t\tidx1++) {\n\t\t\t\ttx_agc[idx1] = ppowerlevel[idx1] |\n\t\t\t\t    (ppowerlevel[idx1] << 8) |\n\t\t\t\t    (ppowerlevel[idx1] << 16) |\n\t\t\t\t    (ppowerlevel[idx1] << 24);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (idx1 = RF90_PATH_A; idx1 <= RF90_PATH_B; idx1++) {\n\t\t\ttx_agc[idx1] = ppowerlevel[idx1] |\n\t\t\t    (ppowerlevel[idx1] << 8) |\n\t\t\t    (ppowerlevel[idx1] << 16) |\n\t\t\t    (ppowerlevel[idx1] << 24);\n\t\t}\n\n\t\tif (rtlefuse->eeprom_regulatory == 0) {\n\t\t\ttmpval =\n\t\t\t    (rtlphy->mcs_txpwrlevel_origoffset[0][6]) +\n\t\t\t    (rtlphy->mcs_txpwrlevel_origoffset[0][7] <<\n\t\t\t     8);\n\t\t\ttx_agc[RF90_PATH_A] += tmpval;\n\n\t\t\ttmpval = (rtlphy->mcs_txpwrlevel_origoffset[0][14]) +\n\t\t\t    (rtlphy->mcs_txpwrlevel_origoffset[0][15] <<\n\t\t\t     24);\n\t\t\ttx_agc[RF90_PATH_B] += tmpval;\n\t\t}\n\t}\n\n\tfor (idx1 = RF90_PATH_A; idx1 <= RF90_PATH_B; idx1++) {\n\t\tptr = (u8 *)(&tx_agc[idx1]);\n\t\tfor (idx2 = 0; idx2 < 4; idx2++) {\n\t\t\tif (*ptr > RF6052_MAX_TX_PWR)\n\t\t\t\t*ptr = RF6052_MAX_TX_PWR;\n\t\t\tptr++;\n\t\t}\n\t}\n\trtl8821ae_dm_txpower_track_adjust(hw, 1, &direction, &pwrtrac_value);\n\tif (direction == 1) {\n\t\ttx_agc[0] += pwrtrac_value;\n\t\ttx_agc[1] += pwrtrac_value;\n\t} else if (direction == 2) {\n\t\ttx_agc[0] -= pwrtrac_value;\n\t\ttx_agc[1] -= pwrtrac_value;\n\t}\n\ttmpval = tx_agc[RF90_PATH_A];\n\trtl_set_bbreg(hw, RTXAGC_A_CCK11_CCK1, MASKDWORD, tmpval);\n\n\tRTPRINT(rtlpriv, FPHY, PHY_TXPWR,\n\t\t\"CCK PWR 1~11M (rf-A) = 0x%x (reg 0x%x)\\n\", tmpval,\n\t\t RTXAGC_A_CCK11_CCK1);\n\n\ttmpval = tx_agc[RF90_PATH_B];\n\trtl_set_bbreg(hw, RTXAGC_B_CCK11_CCK1, MASKDWORD, tmpval);\n\n\tRTPRINT(rtlpriv, FPHY, PHY_TXPWR,\n\t\t\"CCK PWR 11M (rf-B) = 0x%x (reg 0x%x)\\n\", tmpval,\n\t\t RTXAGC_B_CCK11_CCK1);\n}\n\nstatic void rtl8821ae_phy_get_power_base(struct ieee80211_hw *hw,\n\t\t\t\t\t u8 *ppowerlevel_ofdm,\n\t\t\t\t\t u8 *ppowerlevel_bw20,\n\t\t\t\t\t u8 *ppowerlevel_bw40, u8 channel,\n\t\t\t\t\t u32 *ofdmbase, u32 *mcsbase)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\tu32 powerbase0, powerbase1;\n\tu8 i, powerlevel[2];\n\n\tfor (i = 0; i < 2; i++) {\n\t\tpowerbase0 = ppowerlevel_ofdm[i];\n\n\t\tpowerbase0 = (powerbase0 << 24) | (powerbase0 << 16) |\n\t\t    (powerbase0 << 8) | powerbase0;\n\t\t*(ofdmbase + i) = powerbase0;\n\t\tRTPRINT(rtlpriv, FPHY, PHY_TXPWR,\n\t\t\t\" [OFDM power base index rf(%c) = 0x%x]\\n\",\n\t\t\t ((i == 0) ? 'A' : 'B'), *(ofdmbase + i));\n\t}\n\n\tfor (i = 0; i < 2; i++) {\n\t\tif (rtlphy->current_chan_bw == HT_CHANNEL_WIDTH_20)\n\t\t\tpowerlevel[i] = ppowerlevel_bw20[i];\n\t\telse\n\t\t\tpowerlevel[i] = ppowerlevel_bw40[i];\n\n\t\tpowerbase1 = powerlevel[i];\n\t\tpowerbase1 = (powerbase1 << 24) |\n\t\t    (powerbase1 << 16) | (powerbase1 << 8) | powerbase1;\n\n\t\t*(mcsbase + i) = powerbase1;\n\n\t\tRTPRINT(rtlpriv, FPHY, PHY_TXPWR,\n\t\t\t\" [MCS power base index rf(%c) = 0x%x]\\n\",\n\t\t\t ((i == 0) ? 'A' : 'B'), *(mcsbase + i));\n\t}\n}\n\nstatic void get_txpower_writeval_by_regulatory(struct ieee80211_hw *hw,\n\t\t\t\t\t       u8 channel, u8 index,\n\t\t\t\t\t       u32 *powerbase0,\n\t\t\t\t\t       u32 *powerbase1,\n\t\t\t\t\t       u32 *p_outwriteval)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tu8 i, chnlgroup = 0, pwr_diff_limit[4], pwr_diff = 0, customer_pwr_diff;\n\tu32 writeval, customer_limit, rf;\n\n\tfor (rf = 0; rf < 2; rf++) {\n\t\tswitch (rtlefuse->eeprom_regulatory) {\n\t\tcase 0:\n\t\t\tchnlgroup = 0;\n\n\t\t\twriteval =\n\t\t\t    rtlphy->mcs_txpwrlevel_origoffset[chnlgroup][index +\n\t\t\t\t\t\t\t(rf ? 8 : 0)]\n\t\t\t    + ((index < 2) ? powerbase0[rf] : powerbase1[rf]);\n\n\t\t\tRTPRINT(rtlpriv, FPHY, PHY_TXPWR,\n\t\t\t\t\"RTK better performance, writeval(%c) = 0x%x\\n\",\n\t\t\t\t ((rf == 0) ? 'A' : 'B'), writeval);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (rtlphy->pwrgroup_cnt == 1) {\n\t\t\t\tchnlgroup = 0;\n\t\t\t} else {\n\t\t\t\tif (channel < 3)\n\t\t\t\t\tchnlgroup = 0;\n\t\t\t\telse if (channel < 6)\n\t\t\t\t\tchnlgroup = 1;\n\t\t\t\telse if (channel < 9)\n\t\t\t\t\tchnlgroup = 2;\n\t\t\t\telse if (channel < 12)\n\t\t\t\t\tchnlgroup = 3;\n\t\t\t\telse if (channel < 14)\n\t\t\t\t\tchnlgroup = 4;\n\t\t\t\telse if (channel == 14)\n\t\t\t\t\tchnlgroup = 5;\n\t\t\t}\n\n\t\t\twriteval =\n\t\t\t    rtlphy->mcs_txpwrlevel_origoffset[chnlgroup]\n\t\t\t    [index + (rf ? 8 : 0)] + ((index < 2) ?\n\t\t\t\t\t\t      powerbase0[rf] :\n\t\t\t\t\t\t      powerbase1[rf]);\n\n\t\t\tRTPRINT(rtlpriv, FPHY, PHY_TXPWR,\n\t\t\t\t\"Realtek regulatory, 20MHz, writeval(%c) = 0x%x\\n\",\n\t\t\t\t ((rf == 0) ? 'A' : 'B'), writeval);\n\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\twriteval =\n\t\t\t    ((index < 2) ? powerbase0[rf] : powerbase1[rf]);\n\n\t\t\tRTPRINT(rtlpriv, FPHY, PHY_TXPWR,\n\t\t\t\t\"Better regulatory, writeval(%c) = 0x%x\\n\",\n\t\t\t\t ((rf == 0) ? 'A' : 'B'), writeval);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tchnlgroup = 0;\n\n\t\t\tif (rtlphy->current_chan_bw == HT_CHANNEL_WIDTH_20_40) {\n\t\t\t\tRTPRINT(rtlpriv, FPHY, PHY_TXPWR,\n\t\t\t\t\t\"customer's limit, 40MHz rf(%c) = 0x%x\\n\",\n\t\t\t\t\t ((rf == 0) ? 'A' : 'B'),\n\t\t\t\t\t rtlefuse->pwrgroup_ht40[rf][channel -\n\t\t\t\t\t\t\t\t     1]);\n\t\t\t} else {\n\t\t\t\tRTPRINT(rtlpriv, FPHY, PHY_TXPWR,\n\t\t\t\t\t\"customer's limit, 20MHz rf(%c) = 0x%x\\n\",\n\t\t\t\t\t ((rf == 0) ? 'A' : 'B'),\n\t\t\t\t\t rtlefuse->pwrgroup_ht20[rf][channel -\n\t\t\t\t\t\t\t\t     1]);\n\t\t\t}\n\n\t\t\tif (index < 2)\n\t\t\t\tpwr_diff = rtlefuse->txpwr_legacyhtdiff[rf][channel-1];\n\t\t\telse if (rtlphy->current_chan_bw ==  HT_CHANNEL_WIDTH_20)\n\t\t\t\tpwr_diff =\n\t\t\t\t  rtlefuse->txpwr_ht20diff[rf][channel-1];\n\n\t\t\tif (rtlphy->current_chan_bw == HT_CHANNEL_WIDTH_20_40)\n\t\t\t\tcustomer_pwr_diff =\n\t\t\t\t  rtlefuse->pwrgroup_ht40[rf][channel-1];\n\t\t\telse\n\t\t\t\tcustomer_pwr_diff =\n\t\t\t\t  rtlefuse->pwrgroup_ht20[rf][channel-1];\n\n\t\t\tif (pwr_diff > customer_pwr_diff)\n\t\t\t\tpwr_diff = 0;\n\t\t\telse\n\t\t\t\tpwr_diff = customer_pwr_diff - pwr_diff;\n\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tpwr_diff_limit[i] =\n\t\t\t\t    (u8)((rtlphy->mcs_txpwrlevel_origoffset\n\t\t\t\t    [chnlgroup][index + (rf ? 8 : 0)] &\n\t\t\t\t    (0x7f << (i * 8))) >> (i * 8));\n\n\t\t\t\tif (pwr_diff_limit[i] > pwr_diff)\n\t\t\t\t\tpwr_diff_limit[i] = pwr_diff;\n\t\t\t}\n\n\t\t\tcustomer_limit = (pwr_diff_limit[3] << 24) |\n\t\t\t    (pwr_diff_limit[2] << 16) |\n\t\t\t    (pwr_diff_limit[1] << 8) | (pwr_diff_limit[0]);\n\n\t\t\tRTPRINT(rtlpriv, FPHY, PHY_TXPWR,\n\t\t\t\t\"Customer's limit rf(%c) = 0x%x\\n\",\n\t\t\t\t ((rf == 0) ? 'A' : 'B'), customer_limit);\n\n\t\t\twriteval = customer_limit +\n\t\t\t    ((index < 2) ? powerbase0[rf] : powerbase1[rf]);\n\n\t\t\tRTPRINT(rtlpriv, FPHY, PHY_TXPWR,\n\t\t\t\t\"Customer, writeval rf(%c)= 0x%x\\n\",\n\t\t\t\t ((rf == 0) ? 'A' : 'B'), writeval);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tchnlgroup = 0;\n\t\t\twriteval =\n\t\t\t    rtlphy->mcs_txpwrlevel_origoffset[chnlgroup]\n\t\t\t    [index + (rf ? 8 : 0)]\n\t\t\t    + ((index < 2) ? powerbase0[rf] : powerbase1[rf]);\n\n\t\t\tRTPRINT(rtlpriv, FPHY, PHY_TXPWR,\n\t\t\t\t\"RTK better performance, writeval rf(%c) = 0x%x\\n\",\n\t\t\t\t ((rf == 0) ? 'A' : 'B'), writeval);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rtlpriv->dm.dynamic_txhighpower_lvl == TXHIGHPWRLEVEL_BT1)\n\t\t\twriteval = writeval - 0x06060606;\n\t\telse if (rtlpriv->dm.dynamic_txhighpower_lvl ==\n\t\t\t TXHIGHPWRLEVEL_BT2)\n\t\t\twriteval = writeval - 0x0c0c0c0c;\n\t\t*(p_outwriteval + rf) = writeval;\n\t}\n}\n\nstatic void _rtl8821ae_write_ofdm_power_reg(struct ieee80211_hw *hw,\n\t\t\t\t\t    u8 index, u32 *pvalue)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu16 regoffset_a[6] = {\n\t\tRTXAGC_A_OFDM18_OFDM6, RTXAGC_A_OFDM54_OFDM24,\n\t\tRTXAGC_A_MCS03_MCS00, RTXAGC_A_MCS07_MCS04,\n\t\tRTXAGC_A_MCS11_MCS08, RTXAGC_A_MCS15_MCS12\n\t};\n\tu16 regoffset_b[6] = {\n\t\tRTXAGC_B_OFDM18_OFDM6, RTXAGC_B_OFDM54_OFDM24,\n\t\tRTXAGC_B_MCS03_MCS00, RTXAGC_B_MCS07_MCS04,\n\t\tRTXAGC_B_MCS11_MCS08, RTXAGC_B_MCS15_MCS12\n\t};\n\tu8 i, rf, pwr_val[4];\n\tu32 writeval;\n\tu16 regoffset;\n\n\tfor (rf = 0; rf < 2; rf++) {\n\t\twriteval = pvalue[rf];\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tpwr_val[i] = (u8)((writeval & (0x7f <<\n\t\t\t\t\t\t\t(i * 8))) >> (i * 8));\n\n\t\t\tif (pwr_val[i] > RF6052_MAX_TX_PWR)\n\t\t\t\tpwr_val[i] = RF6052_MAX_TX_PWR;\n\t\t}\n\t\twriteval = (pwr_val[3] << 24) | (pwr_val[2] << 16) |\n\t\t    (pwr_val[1] << 8) | pwr_val[0];\n\n\t\tif (rf == 0)\n\t\t\tregoffset = regoffset_a[index];\n\t\telse\n\t\t\tregoffset = regoffset_b[index];\n\t\trtl_set_bbreg(hw, regoffset, MASKDWORD, writeval);\n\n\t\tRTPRINT(rtlpriv, FPHY, PHY_TXPWR,\n\t\t\t\"Set 0x%x = %08x\\n\", regoffset, writeval);\n\t}\n}\n\nvoid rtl8821ae_phy_rf6052_set_ofdm_txpower(struct ieee80211_hw *hw,\n\t\t\t\t\t   u8 *ppowerlevel_ofdm,\n\t\t\t\t\t   u8 *ppowerlevel_bw20,\n\t\t\t\t\t   u8 *ppowerlevel_bw40,\n\t\t\t\t\t   u8 channel)\n{\n\tu32 writeval[2], powerbase0[2], powerbase1[2];\n\tu8 index;\n\tu8 direction;\n\tu32 pwrtrac_value;\n\n\trtl8821ae_phy_get_power_base(hw, ppowerlevel_ofdm,\n\t\t\t\t     ppowerlevel_bw20,\n\t\t\t\t     ppowerlevel_bw40,\n\t\t\t\t     channel,\n\t\t\t\t     &powerbase0[0],\n\t\t\t\t     &powerbase1[0]);\n\n\trtl8821ae_dm_txpower_track_adjust(hw, 1, &direction, &pwrtrac_value);\n\n\tfor (index = 0; index < 6; index++) {\n\t\tget_txpower_writeval_by_regulatory(hw, channel, index,\n\t\t\t\t\t\t   &powerbase0[0],\n\t\t\t\t\t\t   &powerbase1[0],\n\t\t\t\t\t\t   &writeval[0]);\n\t\tif (direction == 1) {\n\t\t\twriteval[0] += pwrtrac_value;\n\t\t\twriteval[1] += pwrtrac_value;\n\t\t} else if (direction == 2) {\n\t\t\twriteval[0] -= pwrtrac_value;\n\t\t\twriteval[1] -= pwrtrac_value;\n\t\t}\n\t\t_rtl8821ae_write_ofdm_power_reg(hw, index, &writeval[0]);\n\t}\n}\n\nbool rtl8821ae_phy_rf6052_config(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\n\tif (rtlphy->rf_type == RF_1T1R)\n\t\trtlphy->num_total_rfpath = 1;\n\telse\n\t\trtlphy->num_total_rfpath = 2;\n\n\treturn _rtl8821ae_phy_rf6052_config_parafile(hw);\n}\n\nstatic bool _rtl8821ae_phy_rf6052_config_parafile(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tu8 rfpath;\n\tbool rtstatus = true;\n\n\tfor (rfpath = 0; rfpath < rtlphy->num_total_rfpath; rfpath++) {\n\t\tswitch (rfpath) {\n\t\tcase RF90_PATH_A: {\n\t\t\tif (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE)\n\t\t\t\trtstatus =\n\t\t\t\t  rtl8812ae_phy_config_rf_with_headerfile(hw,\n\t\t\t\t\t\t\t(enum radio_path)rfpath);\n\t\t\telse\n\t\t\t\trtstatus =\n\t\t\t\t  rtl8821ae_phy_config_rf_with_headerfile(hw,\n\t\t\t\t\t\t\t(enum radio_path)rfpath);\n\t\t\tbreak;\n\t\t\t}\n\t\tcase RF90_PATH_B:\n\t\t\tif (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE)\n\t\t\t\trtstatus =\n\t\t\t\t  rtl8812ae_phy_config_rf_with_headerfile(hw,\n\t\t\t\t\t\t\t(enum radio_path)rfpath);\n\t\t\telse\n\t\t\t\trtstatus =\n\t\t\t\t  rtl8821ae_phy_config_rf_with_headerfile(hw,\n\t\t\t\t\t\t\t(enum radio_path)rfpath);\n\t\t\tbreak;\n\t\tcase RF90_PATH_C:\n\t\t\tbreak;\n\t\tcase RF90_PATH_D:\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!rtstatus) {\n\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\t\t\"Radio[%d] Fail!!\\n\", rfpath);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t \n\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE, \"\\n\");\n\treturn rtstatus;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}