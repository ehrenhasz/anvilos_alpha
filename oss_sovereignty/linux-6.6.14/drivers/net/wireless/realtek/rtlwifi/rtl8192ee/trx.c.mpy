{
  "module_name": "trx.c",
  "hash_id": "1548e60b88f96114374a34f1659928d163813a6f0de29afd9594b6f7ca81b7e2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtlwifi/rtl8192ee/trx.c",
  "human_readable_source": "\n \n\n#include \"../wifi.h\"\n#include \"../pci.h\"\n#include \"../base.h\"\n#include \"../stats.h\"\n#include \"reg.h\"\n#include \"def.h\"\n#include \"phy.h\"\n#include \"trx.h\"\n#include \"led.h\"\n#include \"dm.h\"\n#include \"fw.h\"\n\nstatic u8 _rtl92ee_map_hwqueue_to_fwqueue(struct sk_buff *skb, u8 hw_queue)\n{\n\t__le16 fc = rtl_get_fc(skb);\n\n\tif (unlikely(ieee80211_is_beacon(fc)))\n\t\treturn QSLT_BEACON;\n\tif (ieee80211_is_mgmt(fc) || ieee80211_is_ctl(fc))\n\t\treturn QSLT_MGNT;\n\n\treturn skb->priority;\n}\n\nstatic void _rtl92ee_query_rxphystatus(struct ieee80211_hw *hw,\n\t\t\t\t       struct rtl_stats *pstatus, u8 *pdesc,\n\t\t\t\t       struct rx_fwinfo *p_drvinfo,\n\t\t\t\t       bool bpacket_match_bssid,\n\t\t\t\t       bool bpacket_toself,\n\t\t\t\t       bool packet_beacon)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct phy_status_rpt *p_phystrpt = (struct phy_status_rpt *)p_drvinfo;\n\ts8 rx_pwr_all, rx_pwr[4];\n\tu8 rf_rx_num = 0, evm, pwdb_all;\n\tu8 i, max_spatial_stream;\n\tu32 rssi, total_rssi = 0;\n\tbool is_cck = pstatus->is_cck;\n\tu8 lan_idx, vga_idx;\n\n\t \n\tpstatus->packet_matchbssid = bpacket_match_bssid;\n\tpstatus->packet_toself = bpacket_toself;\n\tpstatus->packet_beacon = packet_beacon;\n\tpstatus->rx_mimo_signalquality[0] = -1;\n\tpstatus->rx_mimo_signalquality[1] = -1;\n\n\tif (is_cck) {\n\t\tu8 cck_highpwr;\n\t\tu8 cck_agc_rpt;\n\t\t \n\t\tcck_agc_rpt = p_phystrpt->cck_agc_rpt_ofdm_cfosho_a;\n\n\t\t \n\t\tcck_highpwr = (u8)rtl_get_bbreg(hw, RFPGA0_XA_HSSIPARAMETER2,\n\t\t\t\t\t\t BIT(9));\n\n\t\tlan_idx = ((cck_agc_rpt & 0xE0) >> 5);\n\t\tvga_idx = (cck_agc_rpt & 0x1f);\n\t\tswitch (lan_idx) {\n\t\tcase 7:  \n\t\t\t\tif (vga_idx <= 27)\n\t\t\t\t\trx_pwr_all = -100 + 2 * (27 - vga_idx);\n\t\t\t\telse\n\t\t\t\t\trx_pwr_all = -100;\n\t\t\t\tbreak;\n\t\tcase 6:  \n\t\t\t\trx_pwr_all = -48 + 2 * (2 - vga_idx);\n\t\t\t\tbreak;\n\t\tcase 5:  \n\t\t\t\trx_pwr_all = -42 + 2 * (7 - vga_idx);\n\t\t\t\tbreak;\n\t\tcase 4:  \n\t\t\t\trx_pwr_all = -36 + 2 * (7 - vga_idx);\n\t\t\t\tbreak;\n\t\tcase 3:  \n\t\t\t\trx_pwr_all = -24 + 2 * (7 - vga_idx);\n\t\t\t\tbreak;\n\t\tcase 2:  \n\t\t\t\tif (cck_highpwr)\n\t\t\t\t\trx_pwr_all = -12 + 2 * (5 - vga_idx);\n\t\t\t\telse\n\t\t\t\t\trx_pwr_all = -6 + 2 * (5 - vga_idx);\n\t\t\t\tbreak;\n\t\tcase 1:\n\t\t\t\trx_pwr_all = 8 - 2 * vga_idx;\n\t\t\t\tbreak;\n\t\tcase 0:\n\t\t\t\trx_pwr_all = 14 - 2 * vga_idx;\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\t\trx_pwr_all = 0;\n\t\t\t\tbreak;\n\t\t}\n\t\trx_pwr_all += 16;\n\t\tpwdb_all = rtl_query_rxpwrpercentage(rx_pwr_all);\n\n\t\tif (!cck_highpwr) {\n\t\t\tif (pwdb_all >= 80)\n\t\t\t\tpwdb_all = ((pwdb_all - 80) << 1) +\n\t\t\t\t\t   ((pwdb_all - 80) >> 1) + 80;\n\t\t\telse if ((pwdb_all <= 78) && (pwdb_all >= 20))\n\t\t\t\tpwdb_all += 3;\n\t\t\tif (pwdb_all > 100)\n\t\t\t\tpwdb_all = 100;\n\t\t}\n\n\t\tpstatus->rx_pwdb_all = pwdb_all;\n\t\tpstatus->bt_rx_rssi_percentage = pwdb_all;\n\t\tpstatus->recvsignalpower = rx_pwr_all;\n\n\t\t \n\t\tif (bpacket_match_bssid) {\n\t\t\tu8 sq, sq_rpt;\n\n\t\t\tif (pstatus->rx_pwdb_all > 40) {\n\t\t\t\tsq = 100;\n\t\t\t} else {\n\t\t\t\tsq_rpt = p_phystrpt->cck_sig_qual_ofdm_pwdb_all;\n\t\t\t\tif (sq_rpt > 64)\n\t\t\t\t\tsq = 0;\n\t\t\t\telse if (sq_rpt < 20)\n\t\t\t\t\tsq = 100;\n\t\t\t\telse\n\t\t\t\t\tsq = ((64 - sq_rpt) * 100) / 44;\n\t\t\t}\n\n\t\t\tpstatus->signalquality = sq;\n\t\t\tpstatus->rx_mimo_signalquality[0] = sq;\n\t\t\tpstatus->rx_mimo_signalquality[1] = -1;\n\t\t}\n\t} else {\n\t\t \n\t\tfor (i = RF90_PATH_A; i < RF6052_MAX_PATH; i++) {\n\t\t\t \n\t\t\tif (rtlpriv->dm.rfpath_rxenable[i])\n\t\t\t\trf_rx_num++;\n\n\t\t\trx_pwr[i] = ((p_phystrpt->path_agc[i].gain & 0x3f) * 2)\n\t\t\t\t    - 110;\n\n\t\t\tpstatus->rx_pwr[i] = rx_pwr[i];\n\t\t\t \n\t\t\trssi = rtl_query_rxpwrpercentage(rx_pwr[i]);\n\t\t\ttotal_rssi += rssi;\n\n\t\t\tpstatus->rx_mimo_signalstrength[i] = (u8)rssi;\n\t\t}\n\n\t\t \n\t\trx_pwr_all = ((p_phystrpt->cck_sig_qual_ofdm_pwdb_all >> 1)\n\t\t\t      & 0x7f) - 110;\n\n\t\tpwdb_all = rtl_query_rxpwrpercentage(rx_pwr_all);\n\t\tpstatus->rx_pwdb_all = pwdb_all;\n\t\tpstatus->bt_rx_rssi_percentage = pwdb_all;\n\t\tpstatus->rxpower = rx_pwr_all;\n\t\tpstatus->recvsignalpower = rx_pwr_all;\n\n\t\t \n\t\tif (pstatus->rate >= DESC_RATEMCS8 &&\n\t\t    pstatus->rate <= DESC_RATEMCS15)\n\t\t\tmax_spatial_stream = 2;\n\t\telse\n\t\t\tmax_spatial_stream = 1;\n\n\t\tfor (i = 0; i < max_spatial_stream; i++) {\n\t\t\tevm = rtl_evm_db_to_percentage(\n\t\t\t\t\t\tp_phystrpt->stream_rxevm[i]);\n\n\t\t\tif (bpacket_match_bssid) {\n\t\t\t\t \n\t\t\t\tif (i == 0)\n\t\t\t\t\tpstatus->signalquality = (u8)(evm &\n\t\t\t\t\t\t\t\t       0xff);\n\t\t\t\tpstatus->rx_mimo_signalquality[i] = (u8)(evm &\n\t\t\t\t\t\t\t\t\t  0xff);\n\t\t\t}\n\t\t}\n\n\t\tif (bpacket_match_bssid) {\n\t\t\tfor (i = RF90_PATH_A; i <= RF90_PATH_B; i++)\n\t\t\t\trtl_priv(hw)->dm.cfo_tail[i] =\n\t\t\t\t\t(int)p_phystrpt->path_cfotail[i];\n\n\t\t\tif (rtl_priv(hw)->dm.packet_count == 0xffffffff)\n\t\t\t\trtl_priv(hw)->dm.packet_count = 0;\n\t\t\telse\n\t\t\t\trtl_priv(hw)->dm.packet_count++;\n\t\t}\n\t}\n\n\t \n\tif (is_cck)\n\t\tpstatus->signalstrength = (u8)(rtl_signal_scale_mapping(hw,\n\t\t\t\t\t\t\t\t     pwdb_all));\n\telse if (rf_rx_num != 0)\n\t\tpstatus->signalstrength = (u8)(rtl_signal_scale_mapping(hw,\n\t\t\t\t\t\t      total_rssi /= rf_rx_num));\n}\n\nstatic void _rtl92ee_translate_rx_signal_stuff(struct ieee80211_hw *hw,\n\t\t\t\t\t       struct sk_buff *skb,\n\t\t\t\t\t       struct rtl_stats *pstatus,\n\t\t\t\t\t       u8 *pdesc,\n\t\t\t\t\t       struct rx_fwinfo *p_drvinfo)\n{\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tstruct ieee80211_hdr *hdr;\n\tu8 *tmp_buf;\n\tu8 *praddr;\n\tu8 *psaddr;\n\t__le16 fc;\n\tbool packet_matchbssid, packet_toself, packet_beacon;\n\n\ttmp_buf = skb->data + pstatus->rx_drvinfo_size +\n\t\t  pstatus->rx_bufshift + 24;\n\n\thdr = (struct ieee80211_hdr *)tmp_buf;\n\tfc = hdr->frame_control;\n\tpraddr = hdr->addr1;\n\tpsaddr = ieee80211_get_SA(hdr);\n\tether_addr_copy(pstatus->psaddr, psaddr);\n\n\tpacket_matchbssid = (!ieee80211_is_ctl(fc) &&\n\t\t\t       (ether_addr_equal(mac->bssid,\n\t\t\t\t\t\tieee80211_has_tods(fc) ?\n\t\t\t\t\t\thdr->addr1 :\n\t\t\t\t\t\tieee80211_has_fromds(fc) ?\n\t\t\t\t\t\thdr->addr2 : hdr->addr3)) &&\n\t\t\t\t(!pstatus->hwerror) && (!pstatus->crc) &&\n\t\t\t\t(!pstatus->icv));\n\n\tpacket_toself = packet_matchbssid &&\n\t\t\t (ether_addr_equal(praddr, rtlefuse->dev_addr));\n\n\tif (ieee80211_is_beacon(fc))\n\t\tpacket_beacon = true;\n\telse\n\t\tpacket_beacon = false;\n\n\tif (packet_beacon && packet_matchbssid)\n\t\trtl_priv(hw)->dm.dbginfo.num_qry_beacon_pkt++;\n\n\tif (packet_matchbssid && ieee80211_is_data_qos(hdr->frame_control) &&\n\t    !is_multicast_ether_addr(ieee80211_get_DA(hdr))) {\n\t\tstruct ieee80211_qos_hdr *hdr_qos =\n\t\t\t\t\t    (struct ieee80211_qos_hdr *)tmp_buf;\n\t\tu16 tid = le16_to_cpu(hdr_qos->qos_ctrl) & 0xf;\n\n\t\tif (tid != 0 && tid != 3)\n\t\t\trtl_priv(hw)->dm.dbginfo.num_non_be_pkt++;\n\t}\n\n\t_rtl92ee_query_rxphystatus(hw, pstatus, pdesc, p_drvinfo,\n\t\t\t\t   packet_matchbssid, packet_toself,\n\t\t\t\t   packet_beacon);\n\trtl_process_phyinfo(hw, tmp_buf, pstatus);\n}\n\nstatic void _rtl92ee_insert_emcontent(struct rtl_tcb_desc *ptcb_desc,\n\t\t\t\t      u8 *virtualaddress8)\n{\n\tu32 dwtmp;\n\t__le32 *virtualaddress = (__le32 *)virtualaddress8;\n\n\tmemset(virtualaddress, 0, 8);\n\n\tset_earlymode_pktnum(virtualaddress, ptcb_desc->empkt_num);\n\tif (ptcb_desc->empkt_num == 1) {\n\t\tdwtmp = ptcb_desc->empkt_len[0];\n\t} else {\n\t\tdwtmp = ptcb_desc->empkt_len[0];\n\t\tdwtmp += ((dwtmp % 4) ? (4 - dwtmp % 4) : 0) + 4;\n\t\tdwtmp += ptcb_desc->empkt_len[1];\n\t}\n\tset_earlymode_len0(virtualaddress, dwtmp);\n\n\tif (ptcb_desc->empkt_num <= 3) {\n\t\tdwtmp = ptcb_desc->empkt_len[2];\n\t} else {\n\t\tdwtmp = ptcb_desc->empkt_len[2];\n\t\tdwtmp += ((dwtmp % 4) ? (4 - dwtmp % 4) : 0) + 4;\n\t\tdwtmp += ptcb_desc->empkt_len[3];\n\t}\n\tset_earlymode_len1(virtualaddress, dwtmp);\n\tif (ptcb_desc->empkt_num <= 5) {\n\t\tdwtmp = ptcb_desc->empkt_len[4];\n\t} else {\n\t\tdwtmp = ptcb_desc->empkt_len[4];\n\t\tdwtmp += ((dwtmp % 4) ? (4 - dwtmp % 4) : 0) + 4;\n\t\tdwtmp += ptcb_desc->empkt_len[5];\n\t}\n\tset_earlymode_len2_1(virtualaddress, dwtmp & 0xF);\n\tset_earlymode_len2_2(virtualaddress, dwtmp >> 4);\n\tif (ptcb_desc->empkt_num <= 7) {\n\t\tdwtmp = ptcb_desc->empkt_len[6];\n\t} else {\n\t\tdwtmp = ptcb_desc->empkt_len[6];\n\t\tdwtmp += ((dwtmp % 4) ? (4 - dwtmp % 4) : 0) + 4;\n\t\tdwtmp += ptcb_desc->empkt_len[7];\n\t}\n\tset_earlymode_len3(virtualaddress, dwtmp);\n\tif (ptcb_desc->empkt_num <= 9) {\n\t\tdwtmp = ptcb_desc->empkt_len[8];\n\t} else {\n\t\tdwtmp = ptcb_desc->empkt_len[8];\n\t\tdwtmp += ((dwtmp % 4) ? (4 - dwtmp % 4) : 0) + 4;\n\t\tdwtmp += ptcb_desc->empkt_len[9];\n\t}\n\tset_earlymode_len4(virtualaddress, dwtmp);\n}\n\nbool rtl92ee_rx_query_desc(struct ieee80211_hw *hw,\n\t\t\t   struct rtl_stats *status,\n\t\t\t   struct ieee80211_rx_status *rx_status,\n\t\t\t   u8 *pdesc8, struct sk_buff *skb)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rx_fwinfo *p_drvinfo;\n\tstruct ieee80211_hdr *hdr;\n\t__le32 *pdesc = (__le32 *)pdesc8;\n\tu32 phystatus = get_rx_desc_physt(pdesc);\n\tu8 wake_match;\n\n\tif (get_rx_status_desc_rpt_sel(pdesc) == 0)\n\t\tstatus->packet_report_type = NORMAL_RX;\n\telse\n\t\tstatus->packet_report_type = C2H_PACKET;\n\tstatus->length = (u16)get_rx_desc_pkt_len(pdesc);\n\tstatus->rx_drvinfo_size = (u8)get_rx_desc_drv_info_size(pdesc) *\n\t\t\t\t  RX_DRV_INFO_SIZE_UNIT;\n\tstatus->rx_bufshift = (u8)(get_rx_desc_shift(pdesc) & 0x03);\n\tstatus->icv = (u16)get_rx_desc_icv(pdesc);\n\tstatus->crc = (u16)get_rx_desc_crc32(pdesc);\n\tstatus->hwerror = (status->crc | status->icv);\n\tstatus->decrypted = !get_rx_desc_swdec(pdesc);\n\tstatus->rate = (u8)get_rx_desc_rxmcs(pdesc);\n\tstatus->isampdu = (bool)(get_rx_desc_paggr(pdesc) == 1);\n\tstatus->timestamp_low = get_rx_desc_tsfl(pdesc);\n\tstatus->is_cck = RTL92EE_RX_HAL_IS_CCK_RATE(status->rate);\n\n\tstatus->macid = get_rx_desc_macid(pdesc);\n\tif (get_rx_status_desc_pattern_match(pdesc))\n\t\twake_match = BIT(2);\n\telse if (get_rx_status_desc_magic_match(pdesc))\n\t\twake_match = BIT(1);\n\telse if (get_rx_status_desc_unicast_match(pdesc))\n\t\twake_match = BIT(0);\n\telse\n\t\twake_match = 0;\n\tif (wake_match)\n\t\trtl_dbg(rtlpriv, COMP_RXDESC, DBG_LOUD,\n\t\t\t\"GGGGGGGGGGGGGet Wakeup Packet!! WakeMatch=%d\\n\",\n\t\t\twake_match);\n\trx_status->freq = hw->conf.chandef.chan->center_freq;\n\trx_status->band = hw->conf.chandef.chan->band;\n\n\thdr = (struct ieee80211_hdr *)(skb->data + status->rx_drvinfo_size +\n\t\t\t\t       status->rx_bufshift + 24);\n\n\tif (status->crc)\n\t\trx_status->flag |= RX_FLAG_FAILED_FCS_CRC;\n\n\tif (status->rx_is40mhzpacket)\n\t\trx_status->bw = RATE_INFO_BW_40;\n\n\tif (status->is_ht)\n\t\trx_status->encoding = RX_ENC_HT;\n\n\trx_status->flag |= RX_FLAG_MACTIME_START;\n\n\t \n\tif (status->decrypted) {\n\t\tif ((!_ieee80211_is_robust_mgmt_frame(hdr)) &&\n\t\t    (ieee80211_has_protected(hdr->frame_control)))\n\t\t\trx_status->flag |= RX_FLAG_DECRYPTED;\n\t\telse\n\t\t\trx_status->flag &= ~RX_FLAG_DECRYPTED;\n\t}\n\n\t \n\trx_status->rate_idx = rtlwifi_rate_mapping(hw, status->is_ht,\n\t\t\t\t\t\t   false, status->rate);\n\n\trx_status->mactime = status->timestamp_low;\n\tif (phystatus) {\n\t\tp_drvinfo = (struct rx_fwinfo *)(skb->data +\n\t\t\t\t\t\t status->rx_bufshift + 24);\n\n\t\t_rtl92ee_translate_rx_signal_stuff(hw, skb, status, pdesc8,\n\t\t\t\t\t\t   p_drvinfo);\n\t}\n\trx_status->signal = status->recvsignalpower + 10;\n\tif (status->packet_report_type == TX_REPORT2) {\n\t\tstatus->macid_valid_entry[0] =\n\t\t\tget_rx_rpt2_desc_macid_valid_1(pdesc);\n\t\tstatus->macid_valid_entry[1] =\n\t\t\tget_rx_rpt2_desc_macid_valid_2(pdesc);\n\t}\n\treturn true;\n}\n\n \nvoid rtl92ee_rx_check_dma_ok(struct ieee80211_hw *hw, u8 *header_desc8,\n\t\t\t     u8 queue_index)\n{\n\tu8 first_seg = 0;\n\tu8 last_seg = 0;\n\tu16 total_len = 0;\n\tu16 read_cnt = 0;\n\t__le32 *header_desc = (__le32 *)header_desc8;\n\n\tif (header_desc == NULL)\n\t\treturn;\n\n\ttotal_len = (u16)get_rx_buffer_desc_total_length(header_desc);\n\n\tfirst_seg = (u8)get_rx_buffer_desc_fs(header_desc);\n\n\tlast_seg = (u8)get_rx_buffer_desc_ls(header_desc);\n\n\twhile (total_len == 0 && first_seg == 0 && last_seg == 0) {\n\t\tread_cnt++;\n\t\ttotal_len = (u16)get_rx_buffer_desc_total_length(header_desc);\n\t\tfirst_seg = (u8)get_rx_buffer_desc_fs(header_desc);\n\t\tlast_seg = (u8)get_rx_buffer_desc_ls(header_desc);\n\n\t\tif (read_cnt > 20)\n\t\t\tbreak;\n\t}\n}\n\nu16 rtl92ee_rx_desc_buff_remained_cnt(struct ieee80211_hw *hw, u8 queue_index)\n{\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu16 read_point, write_point, remind_cnt;\n\tu32 tmp_4byte;\n\tstatic bool start_rx;\n\n\ttmp_4byte = rtl_read_dword(rtlpriv, REG_RXQ_TXBD_IDX);\n\tread_point = (u16)((tmp_4byte>>16) & 0x7ff);\n\twrite_point = (u16)(tmp_4byte & 0x7ff);\n\n\tif (write_point != rtlpci->rx_ring[queue_index].next_rx_rp) {\n\t\trtl_dbg(rtlpriv, COMP_RXDESC, DBG_DMESG,\n\t\t\t\"!!!write point is 0x%x, reg 0x3B4 value is 0x%x\\n\",\n\t\t\twrite_point, tmp_4byte);\n\t\ttmp_4byte = rtl_read_dword(rtlpriv, REG_RXQ_TXBD_IDX);\n\t\tread_point = (u16)((tmp_4byte>>16) & 0x7ff);\n\t\twrite_point = (u16)(tmp_4byte & 0x7ff);\n\t}\n\n\tif (read_point > 0)\n\t\tstart_rx = true;\n\tif (!start_rx)\n\t\treturn 0;\n\n\tremind_cnt = calc_fifo_space(read_point, write_point,\n\t\t\t\t     RTL_PCI_MAX_RX_COUNT);\n\n\tif (remind_cnt == 0)\n\t\treturn 0;\n\n\trtlpci->rx_ring[queue_index].next_rx_rp = write_point;\n\n\treturn remind_cnt;\n}\n\nstatic u16 get_desc_addr_fr_q_idx(u16 queue_index)\n{\n\tu16 desc_address;\n\n\tswitch (queue_index) {\n\tcase BK_QUEUE:\n\t\tdesc_address = REG_BKQ_TXBD_IDX;\n\t\tbreak;\n\tcase BE_QUEUE:\n\t\tdesc_address = REG_BEQ_TXBD_IDX;\n\t\tbreak;\n\tcase VI_QUEUE:\n\t\tdesc_address = REG_VIQ_TXBD_IDX;\n\t\tbreak;\n\tcase VO_QUEUE:\n\t\tdesc_address = REG_VOQ_TXBD_IDX;\n\t\tbreak;\n\tcase BEACON_QUEUE:\n\t\tdesc_address = REG_BEQ_TXBD_IDX;\n\t\tbreak;\n\tcase TXCMD_QUEUE:\n\t\tdesc_address = REG_BEQ_TXBD_IDX;\n\t\tbreak;\n\tcase MGNT_QUEUE:\n\t\tdesc_address = REG_MGQ_TXBD_IDX;\n\t\tbreak;\n\tcase HIGH_QUEUE:\n\t\tdesc_address = REG_HI0Q_TXBD_IDX;\n\t\tbreak;\n\tcase HCCA_QUEUE:\n\t\tdesc_address = REG_BEQ_TXBD_IDX;\n\t\tbreak;\n\tdefault:\n\t\tdesc_address = REG_BEQ_TXBD_IDX;\n\t\tbreak;\n\t}\n\treturn desc_address;\n}\n\nu16 rtl92ee_get_available_desc(struct ieee80211_hw *hw, u8 q_idx)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu16 point_diff = 0;\n\tu16 current_tx_read_point, current_tx_write_point;\n\tu32 tmp_4byte;\n\n\ttmp_4byte = rtl_read_dword(rtlpriv,\n\t\t\t\t   get_desc_addr_fr_q_idx(q_idx));\n\tcurrent_tx_read_point = (u16)((tmp_4byte >> 16) & 0x0fff);\n\tcurrent_tx_write_point = (u16)((tmp_4byte) & 0x0fff);\n\n\tpoint_diff = calc_fifo_space(current_tx_read_point,\n\t\t\t\t     current_tx_write_point,\n\t\t\t\t     TX_DESC_NUM_92E);\n\n\treturn point_diff;\n}\n\nvoid rtl92ee_pre_fill_tx_bd_desc(struct ieee80211_hw *hw,\n\t\t\t\t u8 *tx_bd_desc8, u8 *desc8, u8 queue_index,\n\t\t\t\t struct sk_buff *skb, dma_addr_t addr)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tu32 pkt_len = skb->len;\n\tu16 desc_size = 40;  \n\tu32 psblen = 0;\n\tu16 tx_page_size;\n\tu32 total_packet_size;\n\tu16 current_bd_desc;\n\tu8 i;\n\tu16 real_desc_size = 0x28;\n\tu16\tappend_early_mode_size = 0;\n\tu8 segmentnum = 1 << (RTL8192EE_SEG_NUM + 1);\n\tdma_addr_t desc_dma_addr;\n\tbool dma64 = rtlpriv->cfg->mod_params->dma64;\n\t__le32 *desc = (__le32 *)desc8;\n\t__le32 *tx_bd_desc = (__le32 *)tx_bd_desc8;\n\n\ttx_page_size = 2;\n\tcurrent_bd_desc = rtlpci->tx_ring[queue_index].cur_tx_wp;\n\n\ttotal_packet_size = desc_size+pkt_len;\n\n\tif (rtlpriv->rtlhal.earlymode_enable)\t{\n\t\tif (queue_index < BEACON_QUEUE) {\n\t\t\tappend_early_mode_size = 8;\n\t\t\ttotal_packet_size += append_early_mode_size;\n\t\t}\n\t}\n\n\tif (tx_page_size > 0) {\n\t\tpsblen = (pkt_len + real_desc_size + append_early_mode_size) /\n\t\t\t (tx_page_size * 128);\n\n\t\tif (psblen * (tx_page_size * 128) < total_packet_size)\n\t\t\tpsblen += 1;\n\t}\n\n\t \n\tdesc_dma_addr = rtlpci->tx_ring[queue_index].dma +\n\t\t\t(current_bd_desc * TX_DESC_SIZE);\n\n\t \n\tset_tx_buff_desc_len_0(tx_bd_desc, 0);\n\tset_tx_buff_desc_psb(tx_bd_desc, 0);\n\tset_tx_buff_desc_own(tx_bd_desc, 0);\n\n\tfor (i = 1; i < segmentnum; i++) {\n\t\tset_txbuffer_desc_len_with_offset(tx_bd_desc, i, 0);\n\t\tset_txbuffer_desc_amsdu_with_offset(tx_bd_desc, i, 0);\n\t\tset_txbuffer_desc_add_low_with_offset(tx_bd_desc, i, 0);\n\t\tset_txbuffer_desc_add_high_with_offset(tx_bd_desc, i, 0, dma64);\n\t}\n\n\t \n\tclear_pci_tx_desc_content(desc, TX_DESC_SIZE);\n\n\tif (rtlpriv->rtlhal.earlymode_enable) {\n\t\tif (queue_index < BEACON_QUEUE) {\n\t\t\t \n\t\t\tset_tx_buff_desc_len_0(tx_bd_desc, desc_size + 8);\n\t\t} else {\n\t\t\tset_tx_buff_desc_len_0(tx_bd_desc, desc_size);\n\t\t}\n\t} else {\n\t\tset_tx_buff_desc_len_0(tx_bd_desc, desc_size);\n\t}\n\tset_tx_buff_desc_psb(tx_bd_desc, psblen);\n\tset_tx_buff_desc_addr_low_0(tx_bd_desc, desc_dma_addr);\n\tset_tx_buff_desc_addr_high_0(tx_bd_desc, ((u64)desc_dma_addr >> 32),\n\t\t\t\t     dma64);\n\n\tset_txbuffer_desc_len_with_offset(tx_bd_desc, 1, pkt_len);\n\t \n\tset_txbuffer_desc_amsdu_with_offset(tx_bd_desc, 1, 0);\n\tset_txbuffer_desc_add_low_with_offset(tx_bd_desc, 1, addr);\n\tset_txbuffer_desc_add_high_with_offset(tx_bd_desc, 1,\n\t\t\t\t\t       ((u64)addr >> 32), dma64);\n\n\tset_tx_desc_pkt_size(desc, (u16)(pkt_len));\n\tset_tx_desc_tx_buffer_size(desc, (u16)(pkt_len));\n}\n\nvoid rtl92ee_tx_fill_desc(struct ieee80211_hw *hw,\n\t\t\t  struct ieee80211_hdr *hdr, u8 *pdesc8,\n\t\t\t  u8 *pbd_desc_tx,\n\t\t\t  struct ieee80211_tx_info *info,\n\t\t\t  struct ieee80211_sta *sta,\n\t\t\t  struct sk_buff *skb,\n\t\t\t  u8 hw_queue, struct rtl_tcb_desc *ptcb_desc)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\n\tstruct rtlwifi_tx_info *tx_info = rtl_tx_skb_cb_info(skb);\n\tu16 seq_number;\n\t__le16 fc = hdr->frame_control;\n\tu8 fw_qsel = _rtl92ee_map_hwqueue_to_fwqueue(skb, hw_queue);\n\tbool firstseg = ((hdr->seq_ctrl &\n\t\t\t    cpu_to_le16(IEEE80211_SCTL_FRAG)) == 0);\n\tbool lastseg = ((hdr->frame_control &\n\t\t\t   cpu_to_le16(IEEE80211_FCTL_MOREFRAGS)) == 0);\n\tdma_addr_t mapping;\n\tu8 bw_40 = 0;\n\t__le32 *pdesc = (__le32 *)pdesc8;\n\n\tif (mac->opmode == NL80211_IFTYPE_STATION) {\n\t\tbw_40 = mac->bw_40;\n\t} else if (mac->opmode == NL80211_IFTYPE_AP ||\n\t\t   mac->opmode == NL80211_IFTYPE_ADHOC) {\n\t\tif (sta)\n\t\t\tbw_40 = sta->deflink.ht_cap.cap &\n\t\t\t\tIEEE80211_HT_CAP_SUP_WIDTH_20_40;\n\t}\n\tseq_number = (le16_to_cpu(hdr->seq_ctrl) & IEEE80211_SCTL_SEQ) >> 4;\n\trtl_get_tcb_desc(hw, info, sta, skb, ptcb_desc);\n\t \n\tif (rtlhal->earlymode_enable) {\n\t\tskb_push(skb, EM_HDR_LEN);\n\t\tmemset(skb->data, 0, EM_HDR_LEN);\n\t}\n\tmapping = dma_map_single(&rtlpci->pdev->dev, skb->data, skb->len,\n\t\t\t\t DMA_TO_DEVICE);\n\tif (dma_mapping_error(&rtlpci->pdev->dev, mapping)) {\n\t\trtl_dbg(rtlpriv, COMP_SEND, DBG_TRACE,\n\t\t\t\"DMA mapping error\\n\");\n\t\treturn;\n\t}\n\n\tif (pbd_desc_tx != NULL)\n\t\trtl92ee_pre_fill_tx_bd_desc(hw, pbd_desc_tx, pdesc8, hw_queue,\n\t\t\t\t\t    skb, mapping);\n\n\tif (ieee80211_is_nullfunc(fc) || ieee80211_is_ctl(fc)) {\n\t\tfirstseg = true;\n\t\tlastseg = true;\n\t}\n\tif (firstseg) {\n\t\tif (rtlhal->earlymode_enable) {\n\t\t\tset_tx_desc_pkt_offset(pdesc, 1);\n\t\t\tset_tx_desc_offset(pdesc,\n\t\t\t\t\t   USB_HWDESC_HEADER_LEN + EM_HDR_LEN);\n\t\t\tif (ptcb_desc->empkt_num) {\n\t\t\t\trtl_dbg(rtlpriv, COMP_SEND, DBG_TRACE,\n\t\t\t\t\t\"Insert 8 byte.pTcb->EMPktNum:%d\\n\",\n\t\t\t\t\tptcb_desc->empkt_num);\n\t\t\t\t_rtl92ee_insert_emcontent(ptcb_desc,\n\t\t\t\t\t\t\t  (u8 *)(skb->data));\n\t\t\t}\n\t\t} else {\n\t\t\tset_tx_desc_offset(pdesc, USB_HWDESC_HEADER_LEN);\n\t\t}\n\n\n\t\tset_tx_desc_tx_rate(pdesc, ptcb_desc->hw_rate);\n\n\t\tif (ieee80211_is_mgmt(fc)) {\n\t\t\tptcb_desc->use_driver_rate = true;\n\t\t} else {\n\t\t\tif (rtlpriv->ra.is_special_data) {\n\t\t\t\tptcb_desc->use_driver_rate = true;\n\t\t\t\tset_tx_desc_tx_rate(pdesc, DESC_RATE11M);\n\t\t\t} else {\n\t\t\t\tptcb_desc->use_driver_rate = false;\n\t\t\t}\n\t\t}\n\n\t\tif (info->flags & IEEE80211_TX_CTL_AMPDU) {\n\t\t\tset_tx_desc_agg_enable(pdesc, 1);\n\t\t\tset_tx_desc_max_agg_num(pdesc, 0x14);\n\t\t}\n\t\tset_tx_desc_seq(pdesc, seq_number);\n\t\tset_tx_desc_rts_enable(pdesc,\n\t\t\t\t       ((ptcb_desc->rts_enable &&\n\t\t\t\t\t !ptcb_desc->cts_enable) ? 1 : 0));\n\t\tset_tx_desc_hw_rts_enable(pdesc, 0);\n\t\tset_tx_desc_cts2self(pdesc,\n\t\t\t\t     ((ptcb_desc->cts_enable) ? 1 : 0));\n\n\t\tset_tx_desc_rts_rate(pdesc, ptcb_desc->rts_rate);\n\t\tset_tx_desc_rts_sc(pdesc, ptcb_desc->rts_sc);\n\t\tset_tx_desc_rts_short(pdesc,\n\t\t\t\t((ptcb_desc->rts_rate <= DESC_RATE54M) ?\n\t\t\t\t (ptcb_desc->rts_use_shortpreamble ? 1 : 0) :\n\t\t\t\t (ptcb_desc->rts_use_shortgi ? 1 : 0)));\n\n\t\tif (ptcb_desc->tx_enable_sw_calc_duration)\n\t\t\tset_tx_desc_nav_use_hdr(pdesc, 1);\n\n\t\tif (bw_40) {\n\t\t\tif (ptcb_desc->packet_bw == HT_CHANNEL_WIDTH_20_40) {\n\t\t\t\tset_tx_desc_data_bw(pdesc, 1);\n\t\t\t\tset_tx_desc_tx_sub_carrier(pdesc, 3);\n\t\t\t} else {\n\t\t\t\tset_tx_desc_data_bw(pdesc, 0);\n\t\t\t\tset_tx_desc_tx_sub_carrier(pdesc,\n\t\t\t\t\t\t\t   mac->cur_40_prime_sc);\n\t\t\t}\n\t\t} else {\n\t\t\tset_tx_desc_data_bw(pdesc, 0);\n\t\t\tset_tx_desc_tx_sub_carrier(pdesc, 0);\n\t\t}\n\n\t\tset_tx_desc_linip(pdesc, 0);\n\t\tif (sta) {\n\t\t\tu8 ampdu_density = sta->deflink.ht_cap.ampdu_density;\n\n\t\t\tset_tx_desc_ampdu_density(pdesc, ampdu_density);\n\t\t}\n\t\tif (info->control.hw_key) {\n\t\t\tstruct ieee80211_key_conf *key = info->control.hw_key;\n\n\t\t\tswitch (key->cipher) {\n\t\t\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\t\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\t\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\t\t\tset_tx_desc_sec_type(pdesc, 0x1);\n\t\t\t\tbreak;\n\t\t\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\t\t\tset_tx_desc_sec_type(pdesc, 0x3);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tset_tx_desc_sec_type(pdesc, 0x0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tset_tx_desc_queue_sel(pdesc, fw_qsel);\n\t\tset_tx_desc_data_rate_fb_limit(pdesc, 0x1F);\n\t\tset_tx_desc_rts_rate_fb_limit(pdesc, 0xF);\n\t\tset_tx_desc_disable_fb(pdesc,\n\t\t\t\t       ptcb_desc->disable_ratefallback ? 1 : 0);\n\t\tset_tx_desc_use_rate(pdesc, ptcb_desc->use_driver_rate ? 1 : 0);\n\n\t\t \n\t\t \n\t\t \n\t\t \n\t\tif (!ptcb_desc->use_driver_rate) {\n\t\t\t \n\t\t\t \n\t\t}\n\t\tif (ieee80211_is_data_qos(fc)) {\n\t\t\tif (mac->rdg_en) {\n\t\t\t\trtl_dbg(rtlpriv, COMP_SEND, DBG_TRACE,\n\t\t\t\t\t\"Enable RDG function.\\n\");\n\t\t\t\tset_tx_desc_rdg_enable(pdesc, 1);\n\t\t\t\tset_tx_desc_htc(pdesc, 1);\n\t\t\t}\n\t\t}\n\t\t \n\t\trtl_set_tx_report(ptcb_desc, pdesc8, hw, tx_info);\n\t}\n\n\tset_tx_desc_first_seg(pdesc, (firstseg ? 1 : 0));\n\tset_tx_desc_last_seg(pdesc, (lastseg ? 1 : 0));\n\tset_tx_desc_tx_buffer_address(pdesc, mapping);\n\tif (rtlpriv->dm.useramask) {\n\t\tset_tx_desc_rate_id(pdesc, ptcb_desc->ratr_index);\n\t\tset_tx_desc_macid(pdesc, ptcb_desc->mac_id);\n\t} else {\n\t\tset_tx_desc_rate_id(pdesc, 0xC + ptcb_desc->ratr_index);\n\t\tset_tx_desc_macid(pdesc, ptcb_desc->ratr_index);\n\t}\n\n\tset_tx_desc_more_frag(pdesc, (lastseg ? 0 : 1));\n\tif (is_multicast_ether_addr(ieee80211_get_DA(hdr)) ||\n\t    is_broadcast_ether_addr(ieee80211_get_DA(hdr))) {\n\t\tset_tx_desc_bmc(pdesc, 1);\n\t}\n\trtl_dbg(rtlpriv, COMP_SEND, DBG_TRACE, \"\\n\");\n}\n\nvoid rtl92ee_tx_fill_cmddesc(struct ieee80211_hw *hw,\n\t\t\t     u8 *pdesc8, bool firstseg,\n\t\t\t     bool lastseg, struct sk_buff *skb)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tu8 fw_queue = QSLT_BEACON;\n\tdma_addr_t mapping = dma_map_single(&rtlpci->pdev->dev, skb->data,\n\t\t\t\t\t    skb->len, DMA_TO_DEVICE);\n\tu8 txdesc_len = 40;\n\t__le32 *pdesc = (__le32 *)pdesc8;\n\n\tif (dma_mapping_error(&rtlpci->pdev->dev, mapping)) {\n\t\trtl_dbg(rtlpriv, COMP_SEND, DBG_TRACE,\n\t\t\t\"DMA mapping error\\n\");\n\t\treturn;\n\t}\n\tclear_pci_tx_desc_content(pdesc, txdesc_len);\n\n\tif (firstseg)\n\t\tset_tx_desc_offset(pdesc, txdesc_len);\n\n\tset_tx_desc_tx_rate(pdesc, DESC_RATE1M);\n\n\tset_tx_desc_seq(pdesc, 0);\n\n\tset_tx_desc_linip(pdesc, 0);\n\n\tset_tx_desc_queue_sel(pdesc, fw_queue);\n\n\tset_tx_desc_first_seg(pdesc, 1);\n\tset_tx_desc_last_seg(pdesc, 1);\n\n\tset_tx_desc_tx_buffer_size(pdesc, (u16)(skb->len));\n\n\tset_tx_desc_tx_buffer_address(pdesc, mapping);\n\n\tset_tx_desc_rate_id(pdesc, 7);\n\tset_tx_desc_macid(pdesc, 0);\n\n\tset_tx_desc_own(pdesc, 1);\n\n\tset_tx_desc_pkt_size(pdesc, (u16)(skb->len));\n\n\tset_tx_desc_first_seg(pdesc, 1);\n\tset_tx_desc_last_seg(pdesc, 1);\n\n\tset_tx_desc_offset(pdesc, 40);\n\n\tset_tx_desc_use_rate(pdesc, 1);\n\n\tRT_PRINT_DATA(rtlpriv, COMP_CMD, DBG_LOUD,\n\t\t      \"H2C Tx Cmd Content\\n\", pdesc, txdesc_len);\n}\n\nvoid rtl92ee_set_desc(struct ieee80211_hw *hw, u8 *pdesc8, bool istx,\n\t\t      u8 desc_name, u8 *val)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 q_idx = *val;\n\tbool dma64 = rtlpriv->cfg->mod_params->dma64;\n\t__le32 *pdesc = (__le32 *)pdesc8;\n\n\tif (istx) {\n\t\tswitch (desc_name) {\n\t\tcase HW_DESC_TX_NEXTDESC_ADDR:\n\t\t\tset_tx_desc_next_desc_address(pdesc, *(u32 *)val);\n\t\t\tbreak;\n\t\tcase HW_DESC_OWN:{\n\t\t\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\t\t\tstruct rtl8192_tx_ring *ring = &rtlpci->tx_ring[q_idx];\n\t\t\tu16 max_tx_desc = ring->entries;\n\n\t\t\tif (q_idx == BEACON_QUEUE) {\n\t\t\t\tring->cur_tx_wp = 0;\n\t\t\t\tring->cur_tx_rp = 0;\n\t\t\t\tset_tx_buff_desc_own(pdesc, 1);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t \n\t\t\tring->cur_tx_wp = ((ring->cur_tx_wp + 1) % max_tx_desc);\n\n\t\t\trtl_write_word(rtlpriv,\n\t\t\t\t       get_desc_addr_fr_q_idx(q_idx),\n\t\t\t\t       ring->cur_tx_wp);\n\t\t}\n\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (desc_name) {\n\t\tcase HW_DESC_RX_PREPARE:\n\t\t\tset_rx_buffer_desc_ls(pdesc, 0);\n\t\t\tset_rx_buffer_desc_fs(pdesc, 0);\n\t\t\tset_rx_buffer_desc_total_length(pdesc, 0);\n\n\t\t\tset_rx_buffer_desc_data_length(pdesc,\n\t\t\t\t\t\t       MAX_RECEIVE_BUFFER_SIZE +\n\t\t\t\t\t\t       RX_DESC_SIZE);\n\n\t\t\tset_rx_buffer_physical_low(pdesc, (*(dma_addr_t *)val) &\n\t\t\t\t\t\t   DMA_BIT_MASK(32));\n\t\t\tset_rx_buffer_physical_high(pdesc,\n\t\t\t\t\t\t    ((u64)(*(dma_addr_t *)val)\n\t\t\t\t\t\t    >> 32),\n\t\t\t\t\t\t    dma64);\n\t\t\tbreak;\n\t\tcase HW_DESC_RXERO:\n\t\t\tset_rx_desc_eor(pdesc, 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ONCE(true,\n\t\t\t\t  \"rtl8192ee: ERR rxdesc :%d not processed\\n\",\n\t\t\t\t  desc_name);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nu64 rtl92ee_get_desc(struct ieee80211_hw *hw,\n\t\t     u8 *pdesc8, bool istx, u8 desc_name)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu64 ret = 0;\n\tbool dma64 = rtlpriv->cfg->mod_params->dma64;\n\t__le32 *pdesc = (__le32 *)pdesc8;\n\n\tif (istx) {\n\t\tswitch (desc_name) {\n\t\tcase HW_DESC_OWN:\n\t\t\tret = get_tx_desc_own(pdesc);\n\t\t\tbreak;\n\t\tcase HW_DESC_TXBUFF_ADDR:\n\t\t\tret = get_txbuffer_desc_addr_low(pdesc, 1);\n\t\t\tret |= (u64)get_txbuffer_desc_addr_high(pdesc, 1,\n\t\t\t\t\t\t\t\tdma64) << 32;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ONCE(true,\n\t\t\t\t  \"rtl8192ee: ERR txdesc :%d not processed\\n\",\n\t\t\t\t  desc_name);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (desc_name) {\n\t\tcase HW_DESC_OWN:\n\t\t\tret = get_rx_desc_own(pdesc);\n\t\t\tbreak;\n\t\tcase HW_DESC_RXPKT_LEN:\n\t\t\tret = get_rx_desc_pkt_len(pdesc);\n\t\t\tbreak;\n\t\tcase HW_DESC_RXBUFF_ADDR:\n\t\t\tret = get_rx_desc_buff_addr(pdesc);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ONCE(true,\n\t\t\t\t  \"rtl8192ee: ERR rxdesc :%d not processed\\n\",\n\t\t\t\t  desc_name);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nbool rtl92ee_is_tx_desc_closed(struct ieee80211_hw *hw, u8 hw_queue, u16 index)\n{\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu16 read_point, write_point;\n\tbool ret = false;\n\tstruct rtl8192_tx_ring *ring = &rtlpci->tx_ring[hw_queue];\n\n\t{\n\t\tu16 cur_tx_rp;\n\t\tu32 tmpu32;\n\n\t\ttmpu32 =\n\t\t  rtl_read_dword(rtlpriv,\n\t\t\t\t get_desc_addr_fr_q_idx(hw_queue));\n\t\tcur_tx_rp = (u16)((tmpu32 >> 16) & 0x0fff);\n\n\t\t \n\t\tring->cur_tx_rp = cur_tx_rp;\n\t}\n\n\tread_point = ring->cur_tx_rp;\n\twrite_point = ring->cur_tx_wp;\n\n\tif (write_point > read_point) {\n\t\tif (index < write_point && index >= read_point)\n\t\t\tret = false;\n\t\telse\n\t\t\tret = true;\n\t} else if (write_point < read_point) {\n\t\tif (index > write_point && index < read_point)\n\t\t\tret = true;\n\t\telse\n\t\t\tret = false;\n\t} else {\n\t\tif (index != read_point)\n\t\t\tret = true;\n\t}\n\n\tif (hw_queue == BEACON_QUEUE)\n\t\tret = true;\n\n\tif (rtlpriv->rtlhal.driver_is_goingto_unload ||\n\t    rtlpriv->psc.rfoff_reason > RF_CHANGE_BY_PS)\n\t\tret = true;\n\n\treturn ret;\n}\n\nvoid rtl92ee_tx_polling(struct ieee80211_hw *hw, u8 hw_queue)\n{\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}