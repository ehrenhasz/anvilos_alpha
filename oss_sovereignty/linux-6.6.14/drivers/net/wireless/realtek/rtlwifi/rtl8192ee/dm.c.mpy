{
  "module_name": "dm.c",
  "hash_id": "a2ac4ef2bf959e0a310f64359f01fbaf7b1f3eba23c66e1557107a7966d14786",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtlwifi/rtl8192ee/dm.c",
  "human_readable_source": "\n \n\n#include \"../wifi.h\"\n#include \"../base.h\"\n#include \"../pci.h\"\n#include \"../core.h\"\n#include \"reg.h\"\n#include \"def.h\"\n#include \"phy.h\"\n#include \"dm.h\"\n#include \"fw.h\"\n#include \"trx.h\"\n\nstatic void rtl92ee_dm_false_alarm_counter_statistics(struct ieee80211_hw *hw)\n{\n\tu32 ret_value;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct false_alarm_statistics *falsealm_cnt = &rtlpriv->falsealm_cnt;\n\n\trtl_set_bbreg(hw, DM_REG_OFDM_FA_HOLDC_11N, BIT(31), 1);\n\trtl_set_bbreg(hw, DM_REG_OFDM_FA_RSTD_11N, BIT(31), 1);\n\n\tret_value = rtl_get_bbreg(hw, DM_REG_OFDM_FA_TYPE1_11N, MASKDWORD);\n\tfalsealm_cnt->cnt_fast_fsync_fail = (ret_value & 0xffff);\n\tfalsealm_cnt->cnt_sb_search_fail = ((ret_value & 0xffff0000) >> 16);\n\n\tret_value = rtl_get_bbreg(hw, DM_REG_OFDM_FA_TYPE2_11N, MASKDWORD);\n\tfalsealm_cnt->cnt_ofdm_cca = (ret_value & 0xffff);\n\tfalsealm_cnt->cnt_parity_fail = ((ret_value & 0xffff0000) >> 16);\n\n\tret_value = rtl_get_bbreg(hw, DM_REG_OFDM_FA_TYPE3_11N, MASKDWORD);\n\tfalsealm_cnt->cnt_rate_illegal = (ret_value & 0xffff);\n\tfalsealm_cnt->cnt_crc8_fail = ((ret_value & 0xffff0000) >> 16);\n\n\tret_value = rtl_get_bbreg(hw, DM_REG_OFDM_FA_TYPE4_11N, MASKDWORD);\n\tfalsealm_cnt->cnt_mcs_fail = (ret_value & 0xffff);\n\n\tfalsealm_cnt->cnt_ofdm_fail = falsealm_cnt->cnt_parity_fail +\n\t\t\t\t      falsealm_cnt->cnt_rate_illegal +\n\t\t\t\t      falsealm_cnt->cnt_crc8_fail +\n\t\t\t\t      falsealm_cnt->cnt_mcs_fail +\n\t\t\t\t      falsealm_cnt->cnt_fast_fsync_fail +\n\t\t\t\t      falsealm_cnt->cnt_sb_search_fail;\n\n\tret_value = rtl_get_bbreg(hw, DM_REG_SC_CNT_11N, MASKDWORD);\n\tfalsealm_cnt->cnt_bw_lsc = (ret_value & 0xffff);\n\tfalsealm_cnt->cnt_bw_usc = ((ret_value & 0xffff0000) >> 16);\n\n\trtl_set_bbreg(hw, DM_REG_CCK_FA_RST_11N, BIT(12), 1);\n\trtl_set_bbreg(hw, DM_REG_CCK_FA_RST_11N, BIT(14), 1);\n\n\tret_value = rtl_get_bbreg(hw, DM_REG_CCK_FA_LSB_11N, MASKBYTE0);\n\tfalsealm_cnt->cnt_cck_fail = ret_value;\n\n\tret_value = rtl_get_bbreg(hw, DM_REG_CCK_FA_MSB_11N, MASKBYTE3);\n\tfalsealm_cnt->cnt_cck_fail += (ret_value & 0xff) << 8;\n\n\tret_value = rtl_get_bbreg(hw, DM_REG_CCK_CCA_CNT_11N, MASKDWORD);\n\tfalsealm_cnt->cnt_cck_cca = ((ret_value & 0xff) << 8) |\n\t\t\t\t    ((ret_value & 0xFF00) >> 8);\n\n\tfalsealm_cnt->cnt_all = falsealm_cnt->cnt_fast_fsync_fail +\n\t\t\t\tfalsealm_cnt->cnt_sb_search_fail +\n\t\t\t\tfalsealm_cnt->cnt_parity_fail +\n\t\t\t\tfalsealm_cnt->cnt_rate_illegal +\n\t\t\t\tfalsealm_cnt->cnt_crc8_fail +\n\t\t\t\tfalsealm_cnt->cnt_mcs_fail +\n\t\t\t\tfalsealm_cnt->cnt_cck_fail;\n\n\tfalsealm_cnt->cnt_cca_all = falsealm_cnt->cnt_ofdm_cca +\n\t\t\t\t    falsealm_cnt->cnt_cck_cca;\n\n\t \n\trtl_set_bbreg(hw, DM_REG_OFDM_FA_RSTC_11N, BIT(31), 1);\n\trtl_set_bbreg(hw, DM_REG_OFDM_FA_RSTC_11N, BIT(31), 0);\n\trtl_set_bbreg(hw, DM_REG_OFDM_FA_RSTD_11N, BIT(27), 1);\n\trtl_set_bbreg(hw, DM_REG_OFDM_FA_RSTD_11N, BIT(27), 0);\n\t \n\trtl_set_bbreg(hw, DM_REG_OFDM_FA_HOLDC_11N, BIT(31), 0);\n\trtl_set_bbreg(hw, DM_REG_OFDM_FA_RSTD_11N, BIT(31), 0);\n\t \n\trtl_set_bbreg(hw, DM_REG_CCK_FA_RST_11N, BIT(13) | BIT(12), 0);\n\trtl_set_bbreg(hw, DM_REG_CCK_FA_RST_11N, BIT(13) | BIT(12), 2);\n\t \n\trtl_set_bbreg(hw, DM_REG_CCK_FA_RST_11N, BIT(15) | BIT(14), 0);\n\trtl_set_bbreg(hw, DM_REG_CCK_FA_RST_11N, BIT(15) | BIT(14), 2);\n\n\trtl_dbg(rtlpriv, COMP_DIG, DBG_TRACE,\n\t\t\"cnt_parity_fail = %d, cnt_rate_illegal = %d, cnt_crc8_fail = %d, cnt_mcs_fail = %d\\n\",\n\t\tfalsealm_cnt->cnt_parity_fail,\n\t\tfalsealm_cnt->cnt_rate_illegal,\n\t\tfalsealm_cnt->cnt_crc8_fail, falsealm_cnt->cnt_mcs_fail);\n\n\trtl_dbg(rtlpriv, COMP_DIG, DBG_TRACE,\n\t\t\"cnt_ofdm_fail = %x, cnt_cck_fail = %x, cnt_all = %x\\n\",\n\t\tfalsealm_cnt->cnt_ofdm_fail,\n\t\tfalsealm_cnt->cnt_cck_fail, falsealm_cnt->cnt_all);\n}\n\nstatic void rtl92ee_dm_cck_packet_detection_thresh(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct dig_t *dm_dig = &rtlpriv->dm_digtable;\n\tu8 cur_cck_cca_thresh;\n\n\tif (rtlpriv->mac80211.link_state >= MAC80211_LINKED) {\n\t\tif (dm_dig->rssi_val_min > 25) {\n\t\t\tcur_cck_cca_thresh = 0xcd;\n\t\t} else if ((dm_dig->rssi_val_min <= 25) &&\n\t\t\t   (dm_dig->rssi_val_min > 10)) {\n\t\t\tcur_cck_cca_thresh = 0x83;\n\t\t} else {\n\t\t\tif (rtlpriv->falsealm_cnt.cnt_cck_fail > 1000)\n\t\t\t\tcur_cck_cca_thresh = 0x83;\n\t\t\telse\n\t\t\t\tcur_cck_cca_thresh = 0x40;\n\t\t}\n\t} else {\n\t\tif (rtlpriv->falsealm_cnt.cnt_cck_fail > 1000)\n\t\t\tcur_cck_cca_thresh = 0x83;\n\t\telse\n\t\t\tcur_cck_cca_thresh = 0x40;\n\t}\n\trtl92ee_dm_write_cck_cca_thres(hw, cur_cck_cca_thresh);\n}\n\nstatic void rtl92ee_dm_dig(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct dig_t *dm_dig = &rtlpriv->dm_digtable;\n\tu8 dig_min_0, dig_maxofmin;\n\tbool bfirstconnect , bfirstdisconnect;\n\tu8 dm_dig_max, dm_dig_min;\n\tu8 current_igi = dm_dig->cur_igvalue;\n\tu8 offset;\n\n\t \n\tif (mac->act_scanning)\n\t\treturn;\n\n\tdig_min_0 = dm_dig->dig_min_0;\n\tbfirstconnect = (mac->link_state >= MAC80211_LINKED) &&\n\t\t\t!dm_dig->media_connect_0;\n\tbfirstdisconnect = (mac->link_state < MAC80211_LINKED) &&\n\t\t\t   dm_dig->media_connect_0;\n\n\tdm_dig_max = 0x5a;\n\tdm_dig_min = DM_DIG_MIN;\n\tdig_maxofmin = DM_DIG_MAX_AP;\n\n\tif (mac->link_state >= MAC80211_LINKED) {\n\t\tif ((dm_dig->rssi_val_min + 10) > dm_dig_max)\n\t\t\tdm_dig->rx_gain_max = dm_dig_max;\n\t\telse if ((dm_dig->rssi_val_min + 10) < dm_dig_min)\n\t\t\tdm_dig->rx_gain_max = dm_dig_min;\n\t\telse\n\t\t\tdm_dig->rx_gain_max = dm_dig->rssi_val_min + 10;\n\n\t\tif (rtlpriv->dm.one_entry_only) {\n\t\t\toffset = 0;\n\t\t\tif (dm_dig->rssi_val_min - offset < dm_dig_min)\n\t\t\t\tdig_min_0 = dm_dig_min;\n\t\t\telse if (dm_dig->rssi_val_min - offset >\n\t\t\t\t dig_maxofmin)\n\t\t\t\tdig_min_0 = dig_maxofmin;\n\t\t\telse\n\t\t\t\tdig_min_0 = dm_dig->rssi_val_min - offset;\n\t\t} else {\n\t\t\tdig_min_0 = dm_dig_min;\n\t\t}\n\n\t} else {\n\t\tdm_dig->rx_gain_max = dm_dig_max;\n\t\tdig_min_0 = dm_dig_min;\n\t\trtl_dbg(rtlpriv, COMP_DIG, DBG_LOUD, \"no link\\n\");\n\t}\n\n\tif (rtlpriv->falsealm_cnt.cnt_all > 10000) {\n\t\tif (dm_dig->large_fa_hit != 3)\n\t\t\tdm_dig->large_fa_hit++;\n\t\tif (dm_dig->forbidden_igi < current_igi) {\n\t\t\tdm_dig->forbidden_igi = current_igi;\n\t\t\tdm_dig->large_fa_hit = 1;\n\t\t}\n\n\t\tif (dm_dig->large_fa_hit >= 3) {\n\t\t\tif (dm_dig->forbidden_igi + 1 > dm_dig->rx_gain_max)\n\t\t\t\tdm_dig->rx_gain_min =\n\t\t\t\t\t\tdm_dig->rx_gain_max;\n\t\t\telse\n\t\t\t\tdm_dig->rx_gain_min =\n\t\t\t\t\t\tdm_dig->forbidden_igi + 1;\n\t\t\tdm_dig->recover_cnt = 3600;\n\t\t}\n\t} else {\n\t\tif (dm_dig->recover_cnt != 0) {\n\t\t\tdm_dig->recover_cnt--;\n\t\t} else {\n\t\t\tif (dm_dig->large_fa_hit < 3) {\n\t\t\t\tif ((dm_dig->forbidden_igi - 1) <\n\t\t\t\t    dig_min_0) {\n\t\t\t\t\tdm_dig->forbidden_igi = dig_min_0;\n\t\t\t\t\tdm_dig->rx_gain_min =\n\t\t\t\t\t\t\t\tdig_min_0;\n\t\t\t\t} else {\n\t\t\t\t\tdm_dig->forbidden_igi--;\n\t\t\t\t\tdm_dig->rx_gain_min =\n\t\t\t\t\t\tdm_dig->forbidden_igi + 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdm_dig->large_fa_hit = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (rtlpriv->dm.dbginfo.num_qry_beacon_pkt < 5)\n\t\tdm_dig->rx_gain_min = dm_dig_min;\n\n\tif (dm_dig->rx_gain_min > dm_dig->rx_gain_max)\n\t\tdm_dig->rx_gain_min = dm_dig->rx_gain_max;\n\n\tif (mac->link_state >= MAC80211_LINKED) {\n\t\tif (bfirstconnect) {\n\t\t\tif (dm_dig->rssi_val_min <= dig_maxofmin)\n\t\t\t\tcurrent_igi = dm_dig->rssi_val_min;\n\t\t\telse\n\t\t\t\tcurrent_igi = dig_maxofmin;\n\n\t\t\tdm_dig->large_fa_hit = 0;\n\t\t} else {\n\t\t\tif (rtlpriv->falsealm_cnt.cnt_all > DM_DIG_FA_TH2)\n\t\t\t\tcurrent_igi += 4;\n\t\t\telse if (rtlpriv->falsealm_cnt.cnt_all > DM_DIG_FA_TH1)\n\t\t\t\tcurrent_igi += 2;\n\t\t\telse if (rtlpriv->falsealm_cnt.cnt_all < DM_DIG_FA_TH0)\n\t\t\t\tcurrent_igi -= 2;\n\n\t\t\tif (rtlpriv->dm.dbginfo.num_qry_beacon_pkt < 5 &&\n\t\t\t    rtlpriv->falsealm_cnt.cnt_all < DM_DIG_FA_TH1)\n\t\t\t\tcurrent_igi = dm_dig->rx_gain_min;\n\t\t}\n\t} else {\n\t\tif (bfirstdisconnect) {\n\t\t\tcurrent_igi = dm_dig->rx_gain_min;\n\t\t} else {\n\t\t\tif (rtlpriv->falsealm_cnt.cnt_all > 10000)\n\t\t\t\tcurrent_igi += 4;\n\t\t\telse if (rtlpriv->falsealm_cnt.cnt_all > 8000)\n\t\t\t\tcurrent_igi += 2;\n\t\t\telse if (rtlpriv->falsealm_cnt.cnt_all < 500)\n\t\t\t\tcurrent_igi -= 2;\n\t\t}\n\t}\n\n\tif (current_igi > dm_dig->rx_gain_max)\n\t\tcurrent_igi = dm_dig->rx_gain_max;\n\tif (current_igi < dm_dig->rx_gain_min)\n\t\tcurrent_igi = dm_dig->rx_gain_min;\n\n\trtl92ee_dm_write_dig(hw , current_igi);\n\tdm_dig->media_connect_0 = ((mac->link_state >= MAC80211_LINKED) ?\n\t\t\t\t   true : false);\n\tdm_dig->dig_min_0 = dig_min_0;\n}\n\nvoid rtl92ee_dm_write_cck_cca_thres(struct ieee80211_hw *hw, u8 cur_thres)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct dig_t *dm_dig = &rtlpriv->dm_digtable;\n\n\tif (dm_dig->cur_cck_cca_thres != cur_thres)\n\t\trtl_write_byte(rtlpriv, DM_REG_CCK_CCA_11N, cur_thres);\n\n\tdm_dig->pre_cck_cca_thres = dm_dig->cur_cck_cca_thres;\n\tdm_dig->cur_cck_cca_thres = cur_thres;\n}\n\nvoid rtl92ee_dm_write_dig(struct ieee80211_hw *hw, u8 current_igi)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct dig_t *dm_dig = &rtlpriv->dm_digtable;\n\n\tif (dm_dig->stop_dig)\n\t\treturn;\n\n\tif (dm_dig->cur_igvalue != current_igi) {\n\t\trtl_set_bbreg(hw, ROFDM0_XAAGCCORE1, 0x7f, current_igi);\n\t\tif (rtlpriv->phy.rf_type != RF_1T1R)\n\t\t\trtl_set_bbreg(hw, ROFDM0_XBAGCCORE1, 0x7f, current_igi);\n\t}\n\tdm_dig->pre_igvalue = dm_dig->cur_igvalue;\n\tdm_dig->cur_igvalue = current_igi;\n}\n\nstatic void rtl92ee_rssi_dump_to_register(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtl_write_byte(rtlpriv, RA_RSSIDUMP,\n\t\t       rtlpriv->stats.rx_rssi_percentage[0]);\n\trtl_write_byte(rtlpriv, RB_RSSIDUMP,\n\t\t       rtlpriv->stats.rx_rssi_percentage[1]);\n\t \n\t \n\trtl_write_byte(rtlpriv, RS1_RXEVMDUMP, rtlpriv->stats.rx_evm_dbm[0]);\n\trtl_write_byte(rtlpriv, RS2_RXEVMDUMP, rtlpriv->stats.rx_evm_dbm[1]);\n\t \n\trtl_write_byte(rtlpriv, RA_RXSNRDUMP,\n\t\t       (u8)(rtlpriv->stats.rx_snr_db[0]));\n\trtl_write_byte(rtlpriv, RB_RXSNRDUMP,\n\t\t       (u8)(rtlpriv->stats.rx_snr_db[1]));\n\t \n\trtl_write_word(rtlpriv, RA_CFOSHORTDUMP,\n\t\t       rtlpriv->stats.rx_cfo_short[0]);\n\trtl_write_word(rtlpriv, RB_CFOSHORTDUMP,\n\t\t       rtlpriv->stats.rx_cfo_short[1]);\n\t \n\trtl_write_word(rtlpriv, RA_CFOLONGDUMP, rtlpriv->stats.rx_cfo_tail[0]);\n\trtl_write_word(rtlpriv, RB_CFOLONGDUMP, rtlpriv->stats.rx_cfo_tail[1]);\n}\n\nstatic void rtl92ee_dm_find_minimum_rssi(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct dig_t *rtl_dm_dig = &rtlpriv->dm_digtable;\n\tstruct rtl_mac *mac = rtl_mac(rtlpriv);\n\n\t \n\tif ((mac->link_state < MAC80211_LINKED) &&\n\t    (rtlpriv->dm.entry_min_undec_sm_pwdb == 0)) {\n\t\trtl_dm_dig->min_undec_pwdb_for_dm = 0;\n\t\trtl_dbg(rtlpriv, COMP_BB_POWERSAVING, DBG_LOUD,\n\t\t\t\"Not connected to any\\n\");\n\t}\n\tif (mac->link_state >= MAC80211_LINKED) {\n\t\tif (mac->opmode == NL80211_IFTYPE_AP ||\n\t\t    mac->opmode == NL80211_IFTYPE_ADHOC) {\n\t\t\trtl_dm_dig->min_undec_pwdb_for_dm =\n\t\t\t\trtlpriv->dm.entry_min_undec_sm_pwdb;\n\t\t\trtl_dbg(rtlpriv, COMP_BB_POWERSAVING, DBG_LOUD,\n\t\t\t\t\"AP Client PWDB = 0x%lx\\n\",\n\t\t\t\trtlpriv->dm.entry_min_undec_sm_pwdb);\n\t\t} else {\n\t\t\trtl_dm_dig->min_undec_pwdb_for_dm =\n\t\t\t    rtlpriv->dm.undec_sm_pwdb;\n\t\t\trtl_dbg(rtlpriv, COMP_BB_POWERSAVING, DBG_LOUD,\n\t\t\t\t\"STA Default Port PWDB = 0x%x\\n\",\n\t\t\t\trtl_dm_dig->min_undec_pwdb_for_dm);\n\t\t}\n\t} else {\n\t\trtl_dm_dig->min_undec_pwdb_for_dm =\n\t\t\trtlpriv->dm.entry_min_undec_sm_pwdb;\n\t\trtl_dbg(rtlpriv, COMP_BB_POWERSAVING, DBG_LOUD,\n\t\t\t\"AP Ext Port or disconnect PWDB = 0x%x\\n\",\n\t\t\trtl_dm_dig->min_undec_pwdb_for_dm);\n\t}\n\trtl_dbg(rtlpriv, COMP_DIG, DBG_LOUD,\n\t\t\"MinUndecoratedPWDBForDM =%d\\n\",\n\t\trtl_dm_dig->min_undec_pwdb_for_dm);\n}\n\nstatic void rtl92ee_dm_check_rssi_monitor(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct dig_t *dm_dig = &rtlpriv->dm_digtable;\n\tstruct rtl_mac *mac = rtl_mac(rtlpriv);\n\tstruct rtl_dm *dm = rtl_dm(rtlpriv);\n\tstruct rtl_sta_info *drv_priv;\n\tu8 h2c[4] = { 0 };\n\tlong max = 0, min = 0xff;\n\tu8 i = 0;\n\n\tif (mac->opmode == NL80211_IFTYPE_AP ||\n\t    mac->opmode == NL80211_IFTYPE_ADHOC ||\n\t    mac->opmode == NL80211_IFTYPE_MESH_POINT) {\n\t\t \n\t\tspin_lock_bh(&rtlpriv->locks.entry_list_lock);\n\t\tlist_for_each_entry(drv_priv, &rtlpriv->entry_list, list) {\n\t\t\tstruct rssi_sta *stat = &drv_priv->rssi_stat;\n\n\t\t\tif (stat->undec_sm_pwdb < min)\n\t\t\t\tmin = stat->undec_sm_pwdb;\n\t\t\tif (stat->undec_sm_pwdb > max)\n\t\t\t\tmax = stat->undec_sm_pwdb;\n\n\t\t\th2c[3] = 0;\n\t\t\th2c[2] = (u8)(dm->undec_sm_pwdb & 0xFF);\n\t\t\th2c[1] = 0x20;\n\t\t\th2c[0] = ++i;\n\t\t\trtl92ee_fill_h2c_cmd(hw, H2C_92E_RSSI_REPORT, 4, h2c);\n\t\t}\n\t\tspin_unlock_bh(&rtlpriv->locks.entry_list_lock);\n\n\t\t \n\t\tif (max != 0) {\n\t\t\tdm->entry_max_undec_sm_pwdb = max;\n\t\t\tRTPRINT(rtlpriv, FDM, DM_PWDB,\n\t\t\t\t\"EntryMaxPWDB = 0x%lx(%ld)\\n\", max, max);\n\t\t} else {\n\t\t\tdm->entry_max_undec_sm_pwdb = 0;\n\t\t}\n\t\t \n\t\tif (min != 0xff) {\n\t\t\tdm->entry_min_undec_sm_pwdb = min;\n\t\t\tRTPRINT(rtlpriv, FDM, DM_PWDB,\n\t\t\t\t\"EntryMinPWDB = 0x%lx(%ld)\\n\", min, min);\n\t\t} else {\n\t\t\tdm->entry_min_undec_sm_pwdb = 0;\n\t\t}\n\t}\n\n\t \n\tif (dm->useramask) {\n\t\th2c[3] = 0;\n\t\th2c[2] = (u8)(dm->undec_sm_pwdb & 0xFF);\n\t\th2c[1] = 0x20;\n\t\th2c[0] = 0;\n\t\trtl92ee_fill_h2c_cmd(hw, H2C_92E_RSSI_REPORT, 4, h2c);\n\t} else {\n\t\trtl_write_byte(rtlpriv, 0x4fe, dm->undec_sm_pwdb);\n\t}\n\trtl92ee_rssi_dump_to_register(hw);\n\trtl92ee_dm_find_minimum_rssi(hw);\n\tdm_dig->rssi_val_min = rtlpriv->dm_digtable.min_undec_pwdb_for_dm;\n}\n\nstatic void rtl92ee_dm_init_primary_cca_check(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\n\tstruct dynamic_primary_cca *primarycca = &rtlpriv->primarycca;\n\n\trtlhal->rts_en = 0;\n\tprimarycca->dup_rts_flag = 0;\n\tprimarycca->intf_flag = 0;\n\tprimarycca->intf_type = 0;\n\tprimarycca->monitor_flag = 0;\n\tprimarycca->ch_offset = 0;\n\tprimarycca->mf_state = 0;\n}\n\nstatic bool rtl92ee_dm_is_edca_turbo_disable(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\tif (rtlpriv->mac80211.mode == WIRELESS_MODE_B)\n\t\treturn true;\n\n\treturn false;\n}\n\nvoid rtl92ee_dm_init_edca_turbo(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtlpriv->dm.current_turbo_edca = false;\n\trtlpriv->dm.is_cur_rdlstate = false;\n\trtlpriv->dm.is_any_nonbepkts = false;\n}\n\nstatic void rtl92ee_dm_check_edca_turbo(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\tstatic u64 last_txok_cnt;\n\tstatic u64 last_rxok_cnt;\n\tu64 cur_txok_cnt = 0;\n\tu64 cur_rxok_cnt = 0;\n\tu32 edca_be_ul = 0x5ea42b;\n\tu32 edca_be_dl = 0x5ea42b;  \n\tu32 edca_be = 0x5ea42b;\n\tbool is_cur_rdlstate;\n\tbool b_edca_turbo_on = false;\n\n\tif (rtlpriv->dm.dbginfo.num_non_be_pkt > 0x100)\n\t\trtlpriv->dm.is_any_nonbepkts = true;\n\trtlpriv->dm.dbginfo.num_non_be_pkt = 0;\n\n\tcur_txok_cnt = rtlpriv->stats.txbytesunicast - last_txok_cnt;\n\tcur_rxok_cnt = rtlpriv->stats.rxbytesunicast - last_rxok_cnt;\n\n\t \n\tb_edca_turbo_on = ((!rtlpriv->dm.is_any_nonbepkts) &&\n\t\t\t   (!rtlpriv->dm.disable_framebursting)) ?\n\t\t\t  true : false;\n\n\tif (rtl92ee_dm_is_edca_turbo_disable(hw))\n\t\tgoto check_exit;\n\n\tif (b_edca_turbo_on) {\n\t\tis_cur_rdlstate = (cur_rxok_cnt > cur_txok_cnt * 4) ?\n\t\t\t\t    true : false;\n\n\t\tedca_be = is_cur_rdlstate ? edca_be_dl : edca_be_ul;\n\t\trtl_write_dword(rtlpriv , REG_EDCA_BE_PARAM , edca_be);\n\t\trtlpriv->dm.is_cur_rdlstate = is_cur_rdlstate;\n\t\trtlpriv->dm.current_turbo_edca = true;\n\t} else {\n\t\tif (rtlpriv->dm.current_turbo_edca) {\n\t\t\tu8 tmp = AC0_BE;\n\n\t\t\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_AC_PARAM,\n\t\t\t\t\t\t      (u8 *)(&tmp));\n\t\t}\n\t\trtlpriv->dm.current_turbo_edca = false;\n\t}\n\ncheck_exit:\n\trtlpriv->dm.is_any_nonbepkts = false;\n\tlast_txok_cnt = rtlpriv->stats.txbytesunicast;\n\tlast_rxok_cnt = rtlpriv->stats.rxbytesunicast;\n}\n\nstatic void rtl92ee_dm_dynamic_edcca(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 reg_c50 , reg_c58;\n\tbool fw_current_in_ps_mode = false;\n\n\trtlpriv->cfg->ops->get_hw_reg(hw, HW_VAR_FW_PSMODE_STATUS,\n\t\t\t\t      (u8 *)(&fw_current_in_ps_mode));\n\tif (fw_current_in_ps_mode)\n\t\treturn;\n\n\treg_c50 = rtl_get_bbreg(hw, ROFDM0_XAAGCCORE1, MASKBYTE0);\n\treg_c58 = rtl_get_bbreg(hw, ROFDM0_XBAGCCORE1, MASKBYTE0);\n\n\tif (reg_c50 > 0x28 && reg_c58 > 0x28) {\n\t\tif (!rtlpriv->rtlhal.pre_edcca_enable) {\n\t\t\trtl_write_byte(rtlpriv, ROFDM0_ECCATHRESHOLD, 0x03);\n\t\t\trtl_write_byte(rtlpriv, ROFDM0_ECCATHRESHOLD + 2, 0x00);\n\t\t\trtlpriv->rtlhal.pre_edcca_enable = true;\n\t\t}\n\t} else if (reg_c50 < 0x25 && reg_c58 < 0x25) {\n\t\tif (rtlpriv->rtlhal.pre_edcca_enable) {\n\t\t\trtl_write_byte(rtlpriv, ROFDM0_ECCATHRESHOLD, 0x7f);\n\t\t\trtl_write_byte(rtlpriv, ROFDM0_ECCATHRESHOLD + 2, 0x7f);\n\t\t\trtlpriv->rtlhal.pre_edcca_enable = false;\n\t\t}\n\t}\n}\n\nstatic void rtl92ee_dm_adaptivity(struct ieee80211_hw *hw)\n{\n\trtl92ee_dm_dynamic_edcca(hw);\n}\n\nstatic void rtl92ee_dm_write_dynamic_cca(struct ieee80211_hw *hw,\n\t\t\t\t\t u8 cur_mf_state)\n{\n\tstruct dynamic_primary_cca *primarycca = &rtl_priv(hw)->primarycca;\n\n\tif (primarycca->mf_state != cur_mf_state)\n\t\trtl_set_bbreg(hw, DM_REG_L1SBD_PD_CH_11N, BIT(8) | BIT(7),\n\t\t\t      cur_mf_state);\n\n\tprimarycca->mf_state = cur_mf_state;\n}\n\nstatic void rtl92ee_dm_dynamic_primary_cca_ckeck(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct false_alarm_statistics *falsealm_cnt = &rtlpriv->falsealm_cnt;\n\tstruct dynamic_primary_cca *primarycca = &rtlpriv->primarycca;\n\tbool is40mhz = false;\n\tu64 ofdm_cca, ofdm_fa, bw_usc_cnt, bw_lsc_cnt;\n\tu8 sec_ch_offset;\n\tu8 cur_mf_state;\n\tstatic u8 count_down = MONITOR_TIME;\n\n\tofdm_cca = falsealm_cnt->cnt_ofdm_cca;\n\tofdm_fa = falsealm_cnt->cnt_ofdm_fail;\n\tbw_usc_cnt = falsealm_cnt->cnt_bw_usc;\n\tbw_lsc_cnt = falsealm_cnt->cnt_bw_lsc;\n\tis40mhz = rtlpriv->mac80211.bw_40;\n\tsec_ch_offset = rtlpriv->mac80211.cur_40_prime_sc;\n\t \n\n\tif (rtlpriv->mac80211.opmode == NL80211_IFTYPE_AP) {\n\t\tcur_mf_state = MF_USC_LSC;\n\t\trtl92ee_dm_write_dynamic_cca(hw, cur_mf_state);\n\t\treturn;\n\t}\n\n\tif (rtlpriv->mac80211.link_state < MAC80211_LINKED)\n\t\treturn;\n\n\tif (is40mhz)\n\t\treturn;\n\n\tif (primarycca->pricca_flag == 0) {\n\t\t \n\t\tif (sec_ch_offset == 2) {\n\t\t\tif ((ofdm_cca > OFDMCCA_TH) &&\n\t\t\t    (bw_lsc_cnt > (bw_usc_cnt + BW_IND_BIAS)) &&\n\t\t\t    (ofdm_fa > (ofdm_cca >> 1))) {\n\t\t\t\tprimarycca->intf_type = 1;\n\t\t\t\tprimarycca->intf_flag = 1;\n\t\t\t\tcur_mf_state = MF_USC;\n\t\t\t\trtl92ee_dm_write_dynamic_cca(hw, cur_mf_state);\n\t\t\t\tprimarycca->pricca_flag = 1;\n\t\t\t} else if ((ofdm_cca > OFDMCCA_TH) &&\n\t\t\t\t   (bw_lsc_cnt > (bw_usc_cnt + BW_IND_BIAS)) &&\n\t\t\t\t   (ofdm_fa < (ofdm_cca >> 1))) {\n\t\t\t\tprimarycca->intf_type = 2;\n\t\t\t\tprimarycca->intf_flag = 1;\n\t\t\t\tcur_mf_state = MF_USC;\n\t\t\t\trtl92ee_dm_write_dynamic_cca(hw, cur_mf_state);\n\t\t\t\tprimarycca->pricca_flag = 1;\n\t\t\t\tprimarycca->dup_rts_flag = 1;\n\t\t\t\trtlpriv->rtlhal.rts_en = 1;\n\t\t\t} else {\n\t\t\t\tprimarycca->intf_type = 0;\n\t\t\t\tprimarycca->intf_flag = 0;\n\t\t\t\tcur_mf_state = MF_USC_LSC;\n\t\t\t\trtl92ee_dm_write_dynamic_cca(hw, cur_mf_state);\n\t\t\t\trtlpriv->rtlhal.rts_en = 0;\n\t\t\t\tprimarycca->dup_rts_flag = 0;\n\t\t\t}\n\t\t} else if (sec_ch_offset == 1) {\n\t\t\tif ((ofdm_cca > OFDMCCA_TH) &&\n\t\t\t    (bw_usc_cnt > (bw_lsc_cnt + BW_IND_BIAS)) &&\n\t\t\t    (ofdm_fa > (ofdm_cca >> 1))) {\n\t\t\t\tprimarycca->intf_type = 1;\n\t\t\t\tprimarycca->intf_flag = 1;\n\t\t\t\tcur_mf_state = MF_LSC;\n\t\t\t\trtl92ee_dm_write_dynamic_cca(hw, cur_mf_state);\n\t\t\t\tprimarycca->pricca_flag = 1;\n\t\t\t} else if ((ofdm_cca > OFDMCCA_TH) &&\n\t\t\t\t   (bw_usc_cnt > (bw_lsc_cnt + BW_IND_BIAS)) &&\n\t\t\t\t   (ofdm_fa < (ofdm_cca >> 1))) {\n\t\t\t\tprimarycca->intf_type = 2;\n\t\t\t\tprimarycca->intf_flag = 1;\n\t\t\t\tcur_mf_state = MF_LSC;\n\t\t\t\trtl92ee_dm_write_dynamic_cca(hw, cur_mf_state);\n\t\t\t\tprimarycca->pricca_flag = 1;\n\t\t\t\tprimarycca->dup_rts_flag = 1;\n\t\t\t\trtlpriv->rtlhal.rts_en = 1;\n\t\t\t} else {\n\t\t\t\tprimarycca->intf_type = 0;\n\t\t\t\tprimarycca->intf_flag = 0;\n\t\t\t\tcur_mf_state = MF_USC_LSC;\n\t\t\t\trtl92ee_dm_write_dynamic_cca(hw, cur_mf_state);\n\t\t\t\trtlpriv->rtlhal.rts_en = 0;\n\t\t\t\tprimarycca->dup_rts_flag = 0;\n\t\t\t}\n\t\t}\n\t} else { \n\t\tcount_down--;\n\t\tif (count_down == 0) {\n\t\t\tcount_down = MONITOR_TIME;\n\t\t\tprimarycca->pricca_flag = 0;\n\t\t\tcur_mf_state = MF_USC_LSC;\n\t\t\t \n\t\t\trtl92ee_dm_write_dynamic_cca(hw, cur_mf_state);\n\t\t\trtlpriv->rtlhal.rts_en = 0;\n\t\t\tprimarycca->dup_rts_flag = 0;\n\t\t\tprimarycca->intf_type = 0;\n\t\t\tprimarycca->intf_flag = 0;\n\t\t}\n\t}\n}\n\nstatic void rtl92ee_dm_dynamic_atc_switch(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_dm *rtldm = rtl_dm(rtl_priv(hw));\n\tu8 crystal_cap;\n\tu32 packet_count;\n\tint cfo_khz_a , cfo_khz_b , cfo_ave = 0, adjust_xtal = 0;\n\tint cfo_ave_diff;\n\n\tif (rtlpriv->mac80211.link_state < MAC80211_LINKED) {\n\t\tif (rtldm->atc_status == ATC_STATUS_OFF) {\n\t\t\trtl_set_bbreg(hw, ROFDM1_CFOTRACKING, BIT(11),\n\t\t\t\t      ATC_STATUS_ON);\n\t\t\trtldm->atc_status = ATC_STATUS_ON;\n\t\t}\n\t\t \n\t\tif (rtlpriv->cfg->ops->get_btc_status()) {\n\t\t\tif (!rtlpriv->btcoexist.btc_ops->\n\t\t\t    btc_is_bt_disabled(rtlpriv)) {\n\t\t\t\trtl_dbg(rtlpriv, COMP_BT_COEXIST, DBG_LOUD,\n\t\t\t\t\t\"odm_DynamicATCSwitch(): Disable CFO tracking for BT!!\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (rtldm->crystal_cap != rtlpriv->efuse.crystalcap) {\n\t\t\trtldm->crystal_cap = rtlpriv->efuse.crystalcap;\n\t\t\tcrystal_cap = rtldm->crystal_cap & 0x3f;\n\t\t\trtl_set_bbreg(hw, REG_MAC_PHY_CTRL, 0xFFF000,\n\t\t\t\t      (crystal_cap | (crystal_cap << 6)));\n\t\t}\n\t} else {\n\t\tcfo_khz_a = (int)(rtldm->cfo_tail[0] * 3125) / 1280;\n\t\tcfo_khz_b = (int)(rtldm->cfo_tail[1] * 3125) / 1280;\n\t\tpacket_count = rtldm->packet_count;\n\n\t\tif (packet_count == rtldm->packet_count_pre)\n\t\t\treturn;\n\n\t\trtldm->packet_count_pre = packet_count;\n\n\t\tif (rtlpriv->phy.rf_type == RF_1T1R)\n\t\t\tcfo_ave = cfo_khz_a;\n\t\telse\n\t\t\tcfo_ave = (int)(cfo_khz_a + cfo_khz_b) >> 1;\n\n\t\tcfo_ave_diff = (rtldm->cfo_ave_pre >= cfo_ave) ?\n\t\t\t       (rtldm->cfo_ave_pre - cfo_ave) :\n\t\t\t       (cfo_ave - rtldm->cfo_ave_pre);\n\n\t\tif (cfo_ave_diff > 20 && !rtldm->large_cfo_hit) {\n\t\t\trtldm->large_cfo_hit = true;\n\t\t\treturn;\n\t\t}\n\t\trtldm->large_cfo_hit = false;\n\n\t\trtldm->cfo_ave_pre = cfo_ave;\n\n\t\tif (cfo_ave >= -rtldm->cfo_threshold &&\n\t\t    cfo_ave <= rtldm->cfo_threshold && rtldm->is_freeze == 0) {\n\t\t\tif (rtldm->cfo_threshold == CFO_THRESHOLD_XTAL) {\n\t\t\t\trtldm->cfo_threshold = CFO_THRESHOLD_XTAL + 10;\n\t\t\t\trtldm->is_freeze = 1;\n\t\t\t} else {\n\t\t\t\trtldm->cfo_threshold = CFO_THRESHOLD_XTAL;\n\t\t\t}\n\t\t}\n\n\t\tif (cfo_ave > rtldm->cfo_threshold && rtldm->crystal_cap < 0x3f)\n\t\t\tadjust_xtal = ((cfo_ave - CFO_THRESHOLD_XTAL) >> 2) + 1;\n\t\telse if ((cfo_ave < -rtlpriv->dm.cfo_threshold) &&\n\t\t\t rtlpriv->dm.crystal_cap > 0)\n\t\t\tadjust_xtal = ((cfo_ave + CFO_THRESHOLD_XTAL) >> 2) - 1;\n\n\t\tif (adjust_xtal != 0) {\n\t\t\trtldm->is_freeze = 0;\n\t\t\trtldm->crystal_cap += adjust_xtal;\n\n\t\t\tif (rtldm->crystal_cap > 0x3f)\n\t\t\t\trtldm->crystal_cap = 0x3f;\n\t\t\telse if (rtldm->crystal_cap < 0)\n\t\t\t\trtldm->crystal_cap = 0;\n\n\t\t\tcrystal_cap = rtldm->crystal_cap & 0x3f;\n\t\t\trtl_set_bbreg(hw, REG_MAC_PHY_CTRL, 0xFFF000,\n\t\t\t\t      (crystal_cap | (crystal_cap << 6)));\n\t\t}\n\n\t\tif (cfo_ave < CFO_THRESHOLD_ATC &&\n\t\t    cfo_ave > -CFO_THRESHOLD_ATC) {\n\t\t\tif (rtldm->atc_status == ATC_STATUS_ON) {\n\t\t\t\trtl_set_bbreg(hw, ROFDM1_CFOTRACKING, BIT(11),\n\t\t\t\t\t      ATC_STATUS_OFF);\n\t\t\t\trtldm->atc_status = ATC_STATUS_OFF;\n\t\t\t}\n\t\t} else {\n\t\t\tif (rtldm->atc_status == ATC_STATUS_OFF) {\n\t\t\t\trtl_set_bbreg(hw, ROFDM1_CFOTRACKING, BIT(11),\n\t\t\t\t\t      ATC_STATUS_ON);\n\t\t\t\trtldm->atc_status = ATC_STATUS_ON;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void rtl92ee_dm_init_txpower_tracking(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_dm *dm = rtl_dm(rtlpriv);\n\tu8 path;\n\n\tdm->txpower_tracking = true;\n\tdm->default_ofdm_index = 30;\n\tdm->default_cck_index = 20;\n\n\tdm->swing_idx_cck_base = dm->default_cck_index;\n\tdm->cck_index = dm->default_cck_index;\n\n\tfor (path = RF90_PATH_A; path < MAX_RF_PATH; path++) {\n\t\tdm->swing_idx_ofdm_base[path] = dm->default_ofdm_index;\n\t\tdm->ofdm_index[path] = dm->default_ofdm_index;\n\t\tdm->delta_power_index[path] = 0;\n\t\tdm->delta_power_index_last[path] = 0;\n\t\tdm->power_index_offset[path] = 0;\n\t}\n}\n\nvoid rtl92ee_dm_init_rate_adaptive_mask(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rate_adaptive *p_ra = &rtlpriv->ra;\n\n\tp_ra->ratr_state = DM_RATR_STA_INIT;\n\tp_ra->pre_ratr_state = DM_RATR_STA_INIT;\n\n\tif (rtlpriv->dm.dm_type == DM_TYPE_BYDRIVER)\n\t\trtlpriv->dm.useramask = true;\n\telse\n\t\trtlpriv->dm.useramask = false;\n\n\tp_ra->ldpc_thres = 35;\n\tp_ra->use_ldpc = false;\n\tp_ra->high_rssi_thresh_for_ra = 50;\n\tp_ra->low_rssi_thresh_for_ra40m = 20;\n}\n\nstatic bool _rtl92ee_dm_ra_state_check(struct ieee80211_hw *hw,\n\t\t\t\t       s32 rssi, u8 *ratr_state)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rate_adaptive *p_ra = &rtlpriv->ra;\n\tconst u8 go_up_gap = 5;\n\tu32 high_rssithresh_for_ra = p_ra->high_rssi_thresh_for_ra;\n\tu32 low_rssithresh_for_ra = p_ra->low_rssi_thresh_for_ra40m;\n\tu8 state;\n\n\t \n\tswitch (*ratr_state) {\n\tcase DM_RATR_STA_INIT:\n\tcase DM_RATR_STA_HIGH:\n\t\tbreak;\n\tcase DM_RATR_STA_MIDDLE:\n\t\thigh_rssithresh_for_ra += go_up_gap;\n\t\tbreak;\n\tcase DM_RATR_STA_LOW:\n\t\thigh_rssithresh_for_ra += go_up_gap;\n\t\tlow_rssithresh_for_ra += go_up_gap;\n\t\tbreak;\n\tdefault:\n\t\trtl_dbg(rtlpriv, COMP_RATR, DBG_DMESG,\n\t\t\t\"wrong rssi level setting %d !\\n\", *ratr_state);\n\t\tbreak;\n\t}\n\n\t \n\tif (rssi > high_rssithresh_for_ra)\n\t\tstate = DM_RATR_STA_HIGH;\n\telse if (rssi > low_rssithresh_for_ra)\n\t\tstate = DM_RATR_STA_MIDDLE;\n\telse\n\t\tstate = DM_RATR_STA_LOW;\n\n\tif (*ratr_state != state) {\n\t\t*ratr_state = state;\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void rtl92ee_dm_refresh_rate_adaptive_mask(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rate_adaptive *p_ra = &rtlpriv->ra;\n\tstruct ieee80211_sta *sta = NULL;\n\n\tif (is_hal_stop(rtlhal)) {\n\t\trtl_dbg(rtlpriv, COMP_RATE, DBG_LOUD,\n\t\t\t\"driver is going to unload\\n\");\n\t\treturn;\n\t}\n\n\tif (!rtlpriv->dm.useramask) {\n\t\trtl_dbg(rtlpriv, COMP_RATE, DBG_LOUD,\n\t\t\t\"driver does not control rate adaptive mask\\n\");\n\t\treturn;\n\t}\n\n\tif (mac->link_state == MAC80211_LINKED &&\n\t    mac->opmode == NL80211_IFTYPE_STATION) {\n\t\tif (rtlpriv->dm.undec_sm_pwdb < p_ra->ldpc_thres) {\n\t\t\tp_ra->use_ldpc = true;\n\t\t\tp_ra->lower_rts_rate = true;\n\t\t} else if (rtlpriv->dm.undec_sm_pwdb >\n\t\t\t   (p_ra->ldpc_thres - 5)) {\n\t\t\tp_ra->use_ldpc = false;\n\t\t\tp_ra->lower_rts_rate = false;\n\t\t}\n\t\tif (_rtl92ee_dm_ra_state_check(hw, rtlpriv->dm.undec_sm_pwdb,\n\t\t\t\t\t       &p_ra->ratr_state)) {\n\t\t\trcu_read_lock();\n\t\t\tsta = rtl_find_sta(hw, mac->bssid);\n\t\t\tif (sta)\n\t\t\t\trtlpriv->cfg->ops->update_rate_tbl(hw, sta,\n\t\t\t\t\t\t\t      p_ra->ratr_state,\n\t\t\t\t\t\t\t      true);\n\t\t\trcu_read_unlock();\n\n\t\t\tp_ra->pre_ratr_state = p_ra->ratr_state;\n\t\t}\n\t}\n}\n\nstatic void rtl92ee_dm_init_dynamic_atc_switch(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtlpriv->dm.crystal_cap = rtlpriv->efuse.crystalcap;\n\n\trtlpriv->dm.atc_status = rtl_get_bbreg(hw, ROFDM1_CFOTRACKING, BIT(11));\n\trtlpriv->dm.cfo_threshold = CFO_THRESHOLD_XTAL;\n}\n\nvoid rtl92ee_dm_init(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 cur_igvalue = rtl_get_bbreg(hw, DM_REG_IGI_A_11N, DM_BIT_IGI_11N);\n\n\trtlpriv->dm.dm_type = DM_TYPE_BYDRIVER;\n\n\trtl_dm_diginit(hw, cur_igvalue);\n\trtl92ee_dm_init_rate_adaptive_mask(hw);\n\trtl92ee_dm_init_primary_cca_check(hw);\n\trtl92ee_dm_init_edca_turbo(hw);\n\trtl92ee_dm_init_txpower_tracking(hw);\n\trtl92ee_dm_init_dynamic_atc_switch(hw);\n}\n\nstatic void rtl92ee_dm_common_info_self_update(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_sta_info *drv_priv;\n\tu8 cnt = 0;\n\n\trtlpriv->dm.one_entry_only = false;\n\n\tif (rtlpriv->mac80211.opmode == NL80211_IFTYPE_STATION &&\n\t    rtlpriv->mac80211.link_state >= MAC80211_LINKED) {\n\t\trtlpriv->dm.one_entry_only = true;\n\t\treturn;\n\t}\n\n\tif (rtlpriv->mac80211.opmode == NL80211_IFTYPE_AP ||\n\t    rtlpriv->mac80211.opmode == NL80211_IFTYPE_ADHOC ||\n\t    rtlpriv->mac80211.opmode == NL80211_IFTYPE_MESH_POINT) {\n\t\tspin_lock_bh(&rtlpriv->locks.entry_list_lock);\n\t\tlist_for_each_entry(drv_priv, &rtlpriv->entry_list, list) {\n\t\t\tcnt++;\n\t\t}\n\t\tspin_unlock_bh(&rtlpriv->locks.entry_list_lock);\n\n\t\tif (cnt == 1)\n\t\t\trtlpriv->dm.one_entry_only = true;\n\t}\n}\n\nvoid rtl92ee_dm_dynamic_arfb_select(struct ieee80211_hw *hw,\n\t\t\t\t    u8 rate, bool collision_state)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\tif (rate >= DESC92C_RATEMCS8  && rate <= DESC92C_RATEMCS12) {\n\t\tif (collision_state == 1) {\n\t\t\tif (rate == DESC92C_RATEMCS12) {\n\t\t\t\trtl_write_dword(rtlpriv, REG_DARFRC, 0x0);\n\t\t\t\trtl_write_dword(rtlpriv, REG_DARFRC + 4,\n\t\t\t\t\t\t0x07060501);\n\t\t\t} else if (rate == DESC92C_RATEMCS11) {\n\t\t\t\trtl_write_dword(rtlpriv, REG_DARFRC, 0x0);\n\t\t\t\trtl_write_dword(rtlpriv, REG_DARFRC + 4,\n\t\t\t\t\t\t0x07070605);\n\t\t\t} else if (rate == DESC92C_RATEMCS10) {\n\t\t\t\trtl_write_dword(rtlpriv, REG_DARFRC, 0x0);\n\t\t\t\trtl_write_dword(rtlpriv, REG_DARFRC + 4,\n\t\t\t\t\t\t0x08080706);\n\t\t\t} else if (rate == DESC92C_RATEMCS9) {\n\t\t\t\trtl_write_dword(rtlpriv, REG_DARFRC, 0x0);\n\t\t\t\trtl_write_dword(rtlpriv, REG_DARFRC + 4,\n\t\t\t\t\t\t0x08080707);\n\t\t\t} else {\n\t\t\t\trtl_write_dword(rtlpriv, REG_DARFRC, 0x0);\n\t\t\t\trtl_write_dword(rtlpriv, REG_DARFRC + 4,\n\t\t\t\t\t\t0x09090808);\n\t\t\t}\n\t\t} else {    \n\t\t\tif (rate == DESC92C_RATEMCS12) {\n\t\t\t\trtl_write_dword(rtlpriv, REG_DARFRC,\n\t\t\t\t\t\t0x05010000);\n\t\t\t\trtl_write_dword(rtlpriv, REG_DARFRC + 4,\n\t\t\t\t\t\t0x09080706);\n\t\t\t} else if (rate == DESC92C_RATEMCS11) {\n\t\t\t\trtl_write_dword(rtlpriv, REG_DARFRC,\n\t\t\t\t\t\t0x06050000);\n\t\t\t\trtl_write_dword(rtlpriv, REG_DARFRC + 4,\n\t\t\t\t\t\t0x09080807);\n\t\t\t} else if (rate == DESC92C_RATEMCS10) {\n\t\t\t\trtl_write_dword(rtlpriv, REG_DARFRC,\n\t\t\t\t\t\t0x07060000);\n\t\t\t\trtl_write_dword(rtlpriv, REG_DARFRC + 4,\n\t\t\t\t\t\t0x0a090908);\n\t\t\t} else if (rate == DESC92C_RATEMCS9) {\n\t\t\t\trtl_write_dword(rtlpriv, REG_DARFRC,\n\t\t\t\t\t\t0x07070000);\n\t\t\t\trtl_write_dword(rtlpriv, REG_DARFRC + 4,\n\t\t\t\t\t\t0x0a090808);\n\t\t\t} else {\n\t\t\t\trtl_write_dword(rtlpriv, REG_DARFRC,\n\t\t\t\t\t\t0x08080000);\n\t\t\t\trtl_write_dword(rtlpriv, REG_DARFRC + 4,\n\t\t\t\t\t\t0x0b0a0909);\n\t\t\t}\n\t\t}\n\t} else {   \n\t\tif (collision_state == 1) {\n\t\t\tif (rate == DESC92C_RATEMCS15) {\n\t\t\t\trtl_write_dword(rtlpriv, REG_DARFRC,\n\t\t\t\t\t\t0x00000000);\n\t\t\t\trtl_write_dword(rtlpriv, REG_DARFRC + 4,\n\t\t\t\t\t\t0x05040302);\n\t\t\t} else if (rate == DESC92C_RATEMCS14) {\n\t\t\t\trtl_write_dword(rtlpriv, REG_DARFRC,\n\t\t\t\t\t\t0x00000000);\n\t\t\t\trtl_write_dword(rtlpriv, REG_DARFRC + 4,\n\t\t\t\t\t\t0x06050302);\n\t\t\t} else if (rate == DESC92C_RATEMCS13) {\n\t\t\t\trtl_write_dword(rtlpriv, REG_DARFRC,\n\t\t\t\t\t\t0x00000000);\n\t\t\t\trtl_write_dword(rtlpriv, REG_DARFRC + 4,\n\t\t\t\t\t\t0x07060502);\n\t\t\t} else {\n\t\t\t\trtl_write_dword(rtlpriv, REG_DARFRC,\n\t\t\t\t\t\t0x00000000);\n\t\t\t\trtl_write_dword(rtlpriv, REG_DARFRC + 4,\n\t\t\t\t\t\t0x06050402);\n\t\t\t}\n\t\t} else{    \n\t\t\tif (rate == DESC92C_RATEMCS15) {\n\t\t\t\trtl_write_dword(rtlpriv, REG_DARFRC,\n\t\t\t\t\t\t0x03020000);\n\t\t\t\trtl_write_dword(rtlpriv, REG_DARFRC + 4,\n\t\t\t\t\t\t0x07060504);\n\t\t\t} else if (rate == DESC92C_RATEMCS14) {\n\t\t\t\trtl_write_dword(rtlpriv, REG_DARFRC,\n\t\t\t\t\t\t0x03020000);\n\t\t\t\trtl_write_dword(rtlpriv, REG_DARFRC + 4,\n\t\t\t\t\t\t0x08070605);\n\t\t\t} else if (rate == DESC92C_RATEMCS13) {\n\t\t\t\trtl_write_dword(rtlpriv, REG_DARFRC,\n\t\t\t\t\t\t0x05020000);\n\t\t\t\trtl_write_dword(rtlpriv, REG_DARFRC + 4,\n\t\t\t\t\t\t0x09080706);\n\t\t\t} else {\n\t\t\t\trtl_write_dword(rtlpriv, REG_DARFRC,\n\t\t\t\t\t\t0x04020000);\n\t\t\t\trtl_write_dword(rtlpriv, REG_DARFRC + 4,\n\t\t\t\t\t\t0x08070605);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid rtl92ee_dm_watchdog(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tbool fw_current_inpsmode = false;\n\tbool fw_ps_awake = true;\n\n\trtlpriv->cfg->ops->get_hw_reg(hw, HW_VAR_FW_PSMODE_STATUS,\n\t\t\t\t      (u8 *)(&fw_current_inpsmode));\n\trtlpriv->cfg->ops->get_hw_reg(hw, HW_VAR_FWLPS_RF_ON,\n\t\t\t\t      (u8 *)(&fw_ps_awake));\n\tif (ppsc->p2p_ps_info.p2p_ps_mode)\n\t\tfw_ps_awake = false;\n\n\tspin_lock(&rtlpriv->locks.rf_ps_lock);\n\tif ((ppsc->rfpwr_state == ERFON) &&\n\t    ((!fw_current_inpsmode) && fw_ps_awake) &&\n\t    (!ppsc->rfchange_inprogress)) {\n\t\trtl92ee_dm_common_info_self_update(hw);\n\t\trtl92ee_dm_false_alarm_counter_statistics(hw);\n\t\trtl92ee_dm_check_rssi_monitor(hw);\n\t\trtl92ee_dm_dig(hw);\n\t\trtl92ee_dm_adaptivity(hw);\n\t\trtl92ee_dm_cck_packet_detection_thresh(hw);\n\t\trtl92ee_dm_refresh_rate_adaptive_mask(hw);\n\t\trtl92ee_dm_check_edca_turbo(hw);\n\t\trtl92ee_dm_dynamic_atc_switch(hw);\n\t\trtl92ee_dm_dynamic_primary_cca_ckeck(hw);\n\t}\n\tspin_unlock(&rtlpriv->locks.rf_ps_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}