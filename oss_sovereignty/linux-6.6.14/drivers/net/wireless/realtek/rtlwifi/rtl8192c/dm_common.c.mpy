{
  "module_name": "dm_common.c",
  "hash_id": "e6fa123fd2358d62646ec759ce18945343784a12d6f02422e62dfceced7d5cc1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtlwifi/rtl8192c/dm_common.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include \"dm_common.h\"\n#include \"phy_common.h\"\n#include \"../pci.h\"\n#include \"../base.h\"\n#include \"../core.h\"\n\n#define BT_RSSI_STATE_NORMAL_POWER\tBIT(0)\n#define BT_RSSI_STATE_AMDPU_OFF\t\tBIT(1)\n#define BT_RSSI_STATE_SPECIAL_LOW\tBIT(2)\n#define BT_RSSI_STATE_BG_EDCA_LOW\tBIT(3)\n#define BT_RSSI_STATE_TXPOWER_LOW\tBIT(4)\n#define BT_MASK\t\t\t\t0x00ffffff\n\n#define RTLPRIV\t\t\t(struct rtl_priv *)\n#define GET_UNDECORATED_AVERAGE_RSSI(_priv)\t\\\n\t((RTLPRIV(_priv))->mac80211.opmode == \\\n\t\t\t     NL80211_IFTYPE_ADHOC) ?\t\\\n\t((RTLPRIV(_priv))->dm.entry_min_undec_sm_pwdb) : \\\n\t((RTLPRIV(_priv))->dm.undec_sm_pwdb)\n\nstatic const u32 ofdmswing_table[OFDM_TABLE_SIZE] = {\n\t0x7f8001fe,\n\t0x788001e2,\n\t0x71c001c7,\n\t0x6b8001ae,\n\t0x65400195,\n\t0x5fc0017f,\n\t0x5a400169,\n\t0x55400155,\n\t0x50800142,\n\t0x4c000130,\n\t0x47c0011f,\n\t0x43c0010f,\n\t0x40000100,\n\t0x3c8000f2,\n\t0x390000e4,\n\t0x35c000d7,\n\t0x32c000cb,\n\t0x300000c0,\n\t0x2d4000b5,\n\t0x2ac000ab,\n\t0x288000a2,\n\t0x26000098,\n\t0x24000090,\n\t0x22000088,\n\t0x20000080,\n\t0x1e400079,\n\t0x1c800072,\n\t0x1b00006c,\n\t0x19800066,\n\t0x18000060,\n\t0x16c0005b,\n\t0x15800056,\n\t0x14400051,\n\t0x1300004c,\n\t0x12000048,\n\t0x11000044,\n\t0x10000040,\n};\n\nstatic const u8 cckswing_table_ch1ch13[CCK_TABLE_SIZE][8] = {\n\t{0x36, 0x35, 0x2e, 0x25, 0x1c, 0x12, 0x09, 0x04},\n\t{0x33, 0x32, 0x2b, 0x23, 0x1a, 0x11, 0x08, 0x04},\n\t{0x30, 0x2f, 0x29, 0x21, 0x19, 0x10, 0x08, 0x03},\n\t{0x2d, 0x2d, 0x27, 0x1f, 0x18, 0x0f, 0x08, 0x03},\n\t{0x2b, 0x2a, 0x25, 0x1e, 0x16, 0x0e, 0x07, 0x03},\n\t{0x28, 0x28, 0x22, 0x1c, 0x15, 0x0d, 0x07, 0x03},\n\t{0x26, 0x25, 0x21, 0x1b, 0x14, 0x0d, 0x06, 0x03},\n\t{0x24, 0x23, 0x1f, 0x19, 0x13, 0x0c, 0x06, 0x03},\n\t{0x22, 0x21, 0x1d, 0x18, 0x11, 0x0b, 0x06, 0x02},\n\t{0x20, 0x20, 0x1b, 0x16, 0x11, 0x08, 0x05, 0x02},\n\t{0x1f, 0x1e, 0x1a, 0x15, 0x10, 0x0a, 0x05, 0x02},\n\t{0x1d, 0x1c, 0x18, 0x14, 0x0f, 0x0a, 0x05, 0x02},\n\t{0x1b, 0x1a, 0x17, 0x13, 0x0e, 0x09, 0x04, 0x02},\n\t{0x1a, 0x19, 0x16, 0x12, 0x0d, 0x09, 0x04, 0x02},\n\t{0x18, 0x17, 0x15, 0x11, 0x0c, 0x08, 0x04, 0x02},\n\t{0x17, 0x16, 0x13, 0x10, 0x0c, 0x08, 0x04, 0x02},\n\t{0x16, 0x15, 0x12, 0x0f, 0x0b, 0x07, 0x04, 0x01},\n\t{0x14, 0x14, 0x11, 0x0e, 0x0b, 0x07, 0x03, 0x02},\n\t{0x13, 0x13, 0x10, 0x0d, 0x0a, 0x06, 0x03, 0x01},\n\t{0x12, 0x12, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},\n\t{0x11, 0x11, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},\n\t{0x10, 0x10, 0x0e, 0x0b, 0x08, 0x05, 0x03, 0x01},\n\t{0x0f, 0x0f, 0x0d, 0x0b, 0x08, 0x05, 0x03, 0x01},\n\t{0x0e, 0x0e, 0x0c, 0x0a, 0x08, 0x05, 0x02, 0x01},\n\t{0x0d, 0x0d, 0x0c, 0x0a, 0x07, 0x05, 0x02, 0x01},\n\t{0x0d, 0x0c, 0x0b, 0x09, 0x07, 0x04, 0x02, 0x01},\n\t{0x0c, 0x0c, 0x0a, 0x09, 0x06, 0x04, 0x02, 0x01},\n\t{0x0b, 0x0b, 0x0a, 0x08, 0x06, 0x04, 0x02, 0x01},\n\t{0x0b, 0x0a, 0x09, 0x08, 0x06, 0x04, 0x02, 0x01},\n\t{0x0a, 0x0a, 0x09, 0x07, 0x05, 0x03, 0x02, 0x01},\n\t{0x0a, 0x09, 0x08, 0x07, 0x05, 0x03, 0x02, 0x01},\n\t{0x09, 0x09, 0x08, 0x06, 0x05, 0x03, 0x01, 0x01},\n\t{0x09, 0x08, 0x07, 0x06, 0x04, 0x03, 0x01, 0x01}\n};\n\nstatic const u8 cckswing_table_ch14[CCK_TABLE_SIZE][8] = {\n\t{0x36, 0x35, 0x2e, 0x1b, 0x00, 0x00, 0x00, 0x00},\n\t{0x33, 0x32, 0x2b, 0x19, 0x00, 0x00, 0x00, 0x00},\n\t{0x30, 0x2f, 0x29, 0x18, 0x00, 0x00, 0x00, 0x00},\n\t{0x2d, 0x2d, 0x17, 0x17, 0x00, 0x00, 0x00, 0x00},\n\t{0x2b, 0x2a, 0x25, 0x15, 0x00, 0x00, 0x00, 0x00},\n\t{0x28, 0x28, 0x24, 0x14, 0x00, 0x00, 0x00, 0x00},\n\t{0x26, 0x25, 0x21, 0x13, 0x00, 0x00, 0x00, 0x00},\n\t{0x24, 0x23, 0x1f, 0x12, 0x00, 0x00, 0x00, 0x00},\n\t{0x22, 0x21, 0x1d, 0x11, 0x00, 0x00, 0x00, 0x00},\n\t{0x20, 0x20, 0x1b, 0x10, 0x00, 0x00, 0x00, 0x00},\n\t{0x1f, 0x1e, 0x1a, 0x0f, 0x00, 0x00, 0x00, 0x00},\n\t{0x1d, 0x1c, 0x18, 0x0e, 0x00, 0x00, 0x00, 0x00},\n\t{0x1b, 0x1a, 0x17, 0x0e, 0x00, 0x00, 0x00, 0x00},\n\t{0x1a, 0x19, 0x16, 0x0d, 0x00, 0x00, 0x00, 0x00},\n\t{0x18, 0x17, 0x15, 0x0c, 0x00, 0x00, 0x00, 0x00},\n\t{0x17, 0x16, 0x13, 0x0b, 0x00, 0x00, 0x00, 0x00},\n\t{0x16, 0x15, 0x12, 0x0b, 0x00, 0x00, 0x00, 0x00},\n\t{0x14, 0x14, 0x11, 0x0a, 0x00, 0x00, 0x00, 0x00},\n\t{0x13, 0x13, 0x10, 0x0a, 0x00, 0x00, 0x00, 0x00},\n\t{0x12, 0x12, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},\n\t{0x11, 0x11, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},\n\t{0x10, 0x10, 0x0e, 0x08, 0x00, 0x00, 0x00, 0x00},\n\t{0x0f, 0x0f, 0x0d, 0x08, 0x00, 0x00, 0x00, 0x00},\n\t{0x0e, 0x0e, 0x0c, 0x07, 0x00, 0x00, 0x00, 0x00},\n\t{0x0d, 0x0d, 0x0c, 0x07, 0x00, 0x00, 0x00, 0x00},\n\t{0x0d, 0x0c, 0x0b, 0x06, 0x00, 0x00, 0x00, 0x00},\n\t{0x0c, 0x0c, 0x0a, 0x06, 0x00, 0x00, 0x00, 0x00},\n\t{0x0b, 0x0b, 0x0a, 0x06, 0x00, 0x00, 0x00, 0x00},\n\t{0x0b, 0x0a, 0x09, 0x05, 0x00, 0x00, 0x00, 0x00},\n\t{0x0a, 0x0a, 0x09, 0x05, 0x00, 0x00, 0x00, 0x00},\n\t{0x0a, 0x09, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00},\n\t{0x09, 0x09, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00},\n\t{0x09, 0x08, 0x07, 0x04, 0x00, 0x00, 0x00, 0x00}\n};\n\nstatic u32 power_index_reg[6] = {0xc90, 0xc91, 0xc92, 0xc98, 0xc99, 0xc9a};\n\nvoid dm_restorepowerindex(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8\tindex;\n\n\tfor (index = 0; index < 6; index++)\n\t\trtl_write_byte(rtlpriv, power_index_reg[index],\n\t\t\t       rtlpriv->dm.powerindex_backup[index]);\n}\nEXPORT_SYMBOL_GPL(dm_restorepowerindex);\n\nvoid dm_writepowerindex(struct ieee80211_hw *hw, u8 value)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 index;\n\n\tfor (index = 0; index < 6; index++)\n\t\trtl_write_byte(rtlpriv, power_index_reg[index], value);\n}\nEXPORT_SYMBOL_GPL(dm_writepowerindex);\n\nvoid dm_savepowerindex(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 index;\n\tu8 tmp;\n\n\tfor (index = 0; index < 6; index++) {\n\t\ttmp = rtl_read_byte(rtlpriv, power_index_reg[index]);\n\t\trtlpriv->dm.powerindex_backup[index] = tmp;\n\t}\n}\nEXPORT_SYMBOL_GPL(dm_savepowerindex);\n\nstatic u8 rtl92c_dm_initial_gain_min_pwdb(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct dig_t *dm_digtable = &rtlpriv->dm_digtable;\n\tlong rssi_val_min = 0;\n\n\tif ((dm_digtable->curmultista_cstate == DIG_MULTISTA_CONNECT) &&\n\t    (dm_digtable->cursta_cstate == DIG_STA_CONNECT)) {\n\t\tif (rtlpriv->dm.entry_min_undec_sm_pwdb != 0)\n\t\t\trssi_val_min =\n\t\t\t    (rtlpriv->dm.entry_min_undec_sm_pwdb >\n\t\t\t     rtlpriv->dm.undec_sm_pwdb) ?\n\t\t\t    rtlpriv->dm.undec_sm_pwdb :\n\t\t\t    rtlpriv->dm.entry_min_undec_sm_pwdb;\n\t\telse\n\t\t\trssi_val_min = rtlpriv->dm.undec_sm_pwdb;\n\t} else if (dm_digtable->cursta_cstate == DIG_STA_CONNECT ||\n\t\t   dm_digtable->cursta_cstate == DIG_STA_BEFORE_CONNECT) {\n\t\trssi_val_min = rtlpriv->dm.undec_sm_pwdb;\n\t} else if (dm_digtable->curmultista_cstate == DIG_MULTISTA_CONNECT) {\n\t\trssi_val_min = rtlpriv->dm.entry_min_undec_sm_pwdb;\n\t}\n\n\tif (rssi_val_min > 100)\n\t\trssi_val_min = 100;\n\treturn (u8)rssi_val_min;\n}\n\nstatic void rtl92c_dm_false_alarm_counter_statistics(struct ieee80211_hw *hw)\n{\n\tu32 ret_value;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct false_alarm_statistics *falsealm_cnt = &(rtlpriv->falsealm_cnt);\n\n\tret_value = rtl_get_bbreg(hw, ROFDM_PHYCOUNTER1, MASKDWORD);\n\tfalsealm_cnt->cnt_parity_fail = ((ret_value & 0xffff0000) >> 16);\n\n\tret_value = rtl_get_bbreg(hw, ROFDM_PHYCOUNTER2, MASKDWORD);\n\tfalsealm_cnt->cnt_rate_illegal = (ret_value & 0xffff);\n\tfalsealm_cnt->cnt_crc8_fail = ((ret_value & 0xffff0000) >> 16);\n\n\tret_value = rtl_get_bbreg(hw, ROFDM_PHYCOUNTER3, MASKDWORD);\n\tfalsealm_cnt->cnt_mcs_fail = (ret_value & 0xffff);\n\n\tret_value = rtl_get_bbreg(hw, ROFDM0_FRAMESYNC, MASKDWORD);\n\tfalsealm_cnt->cnt_fast_fsync_fail = (ret_value & 0xffff);\n\tfalsealm_cnt->cnt_sb_search_fail = ((ret_value & 0xffff0000) >> 16);\n\n\tfalsealm_cnt->cnt_ofdm_fail = falsealm_cnt->cnt_parity_fail +\n\t\t\t\t      falsealm_cnt->cnt_rate_illegal +\n\t\t\t\t      falsealm_cnt->cnt_crc8_fail +\n\t\t\t\t      falsealm_cnt->cnt_mcs_fail +\n\t\t\t\t      falsealm_cnt->cnt_fast_fsync_fail +\n\t\t\t\t      falsealm_cnt->cnt_sb_search_fail;\n\n\trtl_set_bbreg(hw, RCCK0_FALSEALARMREPORT, BIT(14), 1);\n\tret_value = rtl_get_bbreg(hw, RCCK0_FACOUNTERLOWER, MASKBYTE0);\n\tfalsealm_cnt->cnt_cck_fail = ret_value;\n\n\tret_value = rtl_get_bbreg(hw, RCCK0_FACOUNTERUPPER, MASKBYTE3);\n\tfalsealm_cnt->cnt_cck_fail += (ret_value & 0xff) << 8;\n\tfalsealm_cnt->cnt_all = (falsealm_cnt->cnt_parity_fail +\n\t\t\t\t falsealm_cnt->cnt_rate_illegal +\n\t\t\t\t falsealm_cnt->cnt_crc8_fail +\n\t\t\t\t falsealm_cnt->cnt_mcs_fail +\n\t\t\t\t falsealm_cnt->cnt_cck_fail);\n\n\trtl_set_bbreg(hw, ROFDM1_LSTF, 0x08000000, 1);\n\trtl_set_bbreg(hw, ROFDM1_LSTF, 0x08000000, 0);\n\trtl_set_bbreg(hw, RCCK0_FALSEALARMREPORT, 0x0000c000, 0);\n\trtl_set_bbreg(hw, RCCK0_FALSEALARMREPORT, 0x0000c000, 2);\n\n\trtl_dbg(rtlpriv, COMP_DIG, DBG_TRACE,\n\t\t\"cnt_parity_fail = %d, cnt_rate_illegal = %d, cnt_crc8_fail = %d, cnt_mcs_fail = %d\\n\",\n\t\tfalsealm_cnt->cnt_parity_fail,\n\t\tfalsealm_cnt->cnt_rate_illegal,\n\t\tfalsealm_cnt->cnt_crc8_fail, falsealm_cnt->cnt_mcs_fail);\n\n\trtl_dbg(rtlpriv, COMP_DIG, DBG_TRACE,\n\t\t\"cnt_ofdm_fail = %x, cnt_cck_fail = %x, cnt_all = %x\\n\",\n\t\tfalsealm_cnt->cnt_ofdm_fail,\n\t\tfalsealm_cnt->cnt_cck_fail, falsealm_cnt->cnt_all);\n}\n\nstatic void rtl92c_dm_ctrl_initgain_by_fa(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct dig_t *dm_digtable = &rtlpriv->dm_digtable;\n\tu8 value_igi = dm_digtable->cur_igvalue;\n\n\tif (rtlpriv->falsealm_cnt.cnt_all < DM_DIG_FA_TH0)\n\t\tvalue_igi--;\n\telse if (rtlpriv->falsealm_cnt.cnt_all < DM_DIG_FA_TH1)\n\t\tvalue_igi += 0;\n\telse if (rtlpriv->falsealm_cnt.cnt_all < DM_DIG_FA_TH2)\n\t\tvalue_igi++;\n\telse if (rtlpriv->falsealm_cnt.cnt_all >= DM_DIG_FA_TH2)\n\t\tvalue_igi += 2;\n\n\tif (value_igi > DM_DIG_FA_UPPER)\n\t\tvalue_igi = DM_DIG_FA_UPPER;\n\telse if (value_igi < DM_DIG_FA_LOWER)\n\t\tvalue_igi = DM_DIG_FA_LOWER;\n\n\tif (rtlpriv->falsealm_cnt.cnt_all > 10000)\n\t\tvalue_igi = DM_DIG_FA_UPPER;\n\n\tdm_digtable->cur_igvalue = value_igi;\n\trtl92c_dm_write_dig(hw);\n}\n\nstatic void rtl92c_dm_ctrl_initgain_by_rssi(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct dig_t *digtable = &rtlpriv->dm_digtable;\n\tu32 isbt;\n\n\t \n\tif (rtlpriv->falsealm_cnt.cnt_all > 10000) {\n\t\tdigtable->large_fa_hit++;\n\t\tif (digtable->forbidden_igi < digtable->cur_igvalue) {\n\t\t\tdigtable->forbidden_igi = digtable->cur_igvalue;\n\t\t\tdigtable->large_fa_hit = 1;\n\t\t}\n\n\t\tif (digtable->large_fa_hit >= 3) {\n\t\t\tif ((digtable->forbidden_igi + 1) >\n\t\t\t    digtable->rx_gain_max)\n\t\t\t\tdigtable->rx_gain_min = digtable->rx_gain_max;\n\t\t\telse\n\t\t\t\tdigtable->rx_gain_min = (digtable->forbidden_igi + 1);\n\t\t\tdigtable->recover_cnt = 3600;  \n\t\t}\n\t} else {\n\t\t \n\t\tif (digtable->recover_cnt != 0) {\n\t\t\tdigtable->recover_cnt--;\n\t\t} else {\n\t\t\tif (digtable->large_fa_hit == 0) {\n\t\t\t\tif ((digtable->forbidden_igi-1) < DM_DIG_MIN) {\n\t\t\t\t\tdigtable->forbidden_igi = DM_DIG_MIN;\n\t\t\t\t\tdigtable->rx_gain_min = DM_DIG_MIN;\n\t\t\t\t} else {\n\t\t\t\t\tdigtable->forbidden_igi--;\n\t\t\t\t\tdigtable->rx_gain_min = digtable->forbidden_igi + 1;\n\t\t\t\t}\n\t\t\t} else if (digtable->large_fa_hit == 3) {\n\t\t\t\tdigtable->large_fa_hit = 0;\n\t\t\t}\n\t\t}\n\t}\n\tif (rtlpriv->falsealm_cnt.cnt_all < 250) {\n\t\tisbt = rtl_read_byte(rtlpriv, 0x4fd) & 0x01;\n\n\t\tif (!isbt) {\n\t\t\tif (rtlpriv->falsealm_cnt.cnt_all >\n\t\t\t    digtable->fa_lowthresh) {\n\t\t\t\tif ((digtable->back_val - 2) <\n\t\t\t\t   digtable->back_range_min)\n\t\t\t\t\tdigtable->back_val = digtable->back_range_min;\n\t\t\t\telse\n\t\t\t\t\tdigtable->back_val -= 2;\n\t\t\t} else if (rtlpriv->falsealm_cnt.cnt_all <\n\t\t\t\t   digtable->fa_lowthresh) {\n\t\t\t\tif ((digtable->back_val + 2) >\n\t\t\t\t    digtable->back_range_max)\n\t\t\t\t\tdigtable->back_val = digtable->back_range_max;\n\t\t\t\telse\n\t\t\t\t\tdigtable->back_val += 2;\n\t\t\t}\n\t\t} else {\n\t\t\tdigtable->back_val = DM_DIG_BACKOFF_DEFAULT;\n\t\t}\n\t} else {\n\t\t \n\t\tif (rtlpriv->falsealm_cnt.cnt_all > 1000)\n\t\t\tdigtable->cur_igvalue = digtable->pre_igvalue + 2;\n\t\telse if (rtlpriv->falsealm_cnt.cnt_all > 750)\n\t\t\tdigtable->cur_igvalue = digtable->pre_igvalue + 1;\n\t\telse if (rtlpriv->falsealm_cnt.cnt_all < 500)\n\t\t\tdigtable->cur_igvalue = digtable->pre_igvalue - 1;\n\t}\n\n\t \n\tif (digtable->cur_igvalue > digtable->rx_gain_max)\n\t\tdigtable->cur_igvalue = digtable->rx_gain_max;\n\n\tif (digtable->cur_igvalue < digtable->rx_gain_min)\n\t\tdigtable->cur_igvalue = digtable->rx_gain_min;\n\n\trtl92c_dm_write_dig(hw);\n}\n\nstatic void rtl92c_dm_initial_gain_multi_sta(struct ieee80211_hw *hw)\n{\n\tstatic u8 initialized;  \n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct dig_t *dm_digtable = &rtlpriv->dm_digtable;\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tlong rssi_strength = rtlpriv->dm.entry_min_undec_sm_pwdb;\n\tbool multi_sta = false;\n\n\tif (mac->opmode == NL80211_IFTYPE_ADHOC)\n\t\tmulti_sta = true;\n\n\tif (!multi_sta ||\n\t    dm_digtable->cursta_cstate == DIG_STA_DISCONNECT) {\n\t\tinitialized = false;\n\t\tdm_digtable->dig_ext_port_stage = DIG_EXT_PORT_STAGE_MAX;\n\t\treturn;\n\t} else if (!initialized) {\n\t\tinitialized = true;\n\t\tdm_digtable->dig_ext_port_stage = DIG_EXT_PORT_STAGE_0;\n\t\tdm_digtable->cur_igvalue = 0x20;\n\t\trtl92c_dm_write_dig(hw);\n\t}\n\n\tif (dm_digtable->curmultista_cstate == DIG_MULTISTA_CONNECT) {\n\t\tif ((rssi_strength < dm_digtable->rssi_lowthresh) &&\n\t\t    (dm_digtable->dig_ext_port_stage != DIG_EXT_PORT_STAGE_1)) {\n\n\t\t\tif (dm_digtable->dig_ext_port_stage ==\n\t\t\t    DIG_EXT_PORT_STAGE_2) {\n\t\t\t\tdm_digtable->cur_igvalue = 0x20;\n\t\t\t\trtl92c_dm_write_dig(hw);\n\t\t\t}\n\n\t\t\tdm_digtable->dig_ext_port_stage = DIG_EXT_PORT_STAGE_1;\n\t\t} else if (rssi_strength > dm_digtable->rssi_highthresh) {\n\t\t\tdm_digtable->dig_ext_port_stage = DIG_EXT_PORT_STAGE_2;\n\t\t\trtl92c_dm_ctrl_initgain_by_fa(hw);\n\t\t}\n\t} else if (dm_digtable->dig_ext_port_stage != DIG_EXT_PORT_STAGE_0) {\n\t\tdm_digtable->dig_ext_port_stage = DIG_EXT_PORT_STAGE_0;\n\t\tdm_digtable->cur_igvalue = 0x20;\n\t\trtl92c_dm_write_dig(hw);\n\t}\n\n\trtl_dbg(rtlpriv, COMP_DIG, DBG_TRACE,\n\t\t\"curmultista_cstate = %x dig_ext_port_stage %x\\n\",\n\t\tdm_digtable->curmultista_cstate,\n\t\tdm_digtable->dig_ext_port_stage);\n}\n\nstatic void rtl92c_dm_initial_gain_sta(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct dig_t *dm_digtable = &rtlpriv->dm_digtable;\n\n\trtl_dbg(rtlpriv, COMP_DIG, DBG_TRACE,\n\t\t\"presta_cstate = %x, cursta_cstate = %x\\n\",\n\t\tdm_digtable->presta_cstate, dm_digtable->cursta_cstate);\n\tif (dm_digtable->presta_cstate == dm_digtable->cursta_cstate ||\n\t    dm_digtable->cursta_cstate == DIG_STA_BEFORE_CONNECT ||\n\t    dm_digtable->cursta_cstate == DIG_STA_CONNECT) {\n\t\tif (dm_digtable->cursta_cstate != DIG_STA_DISCONNECT) {\n\t\t\tdm_digtable->rssi_val_min =\n\t\t\t    rtl92c_dm_initial_gain_min_pwdb(hw);\n\t\t\tif (dm_digtable->rssi_val_min > 100)\n\t\t\t\tdm_digtable->rssi_val_min = 100;\n\t\t\trtl92c_dm_ctrl_initgain_by_rssi(hw);\n\t\t}\n\t} else {\n\t\tdm_digtable->rssi_val_min = 0;\n\t\tdm_digtable->dig_ext_port_stage = DIG_EXT_PORT_STAGE_MAX;\n\t\tdm_digtable->back_val = DM_DIG_BACKOFF_DEFAULT;\n\t\tdm_digtable->cur_igvalue = 0x20;\n\t\tdm_digtable->pre_igvalue = 0;\n\t\trtl92c_dm_write_dig(hw);\n\t}\n}\n\nstatic void rtl92c_dm_cck_packet_detection_thresh(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct dig_t *dm_digtable = &rtlpriv->dm_digtable;\n\n\tif (dm_digtable->cursta_cstate == DIG_STA_CONNECT) {\n\t\tdm_digtable->rssi_val_min = rtl92c_dm_initial_gain_min_pwdb(hw);\n\t\tif (dm_digtable->rssi_val_min > 100)\n\t\t\tdm_digtable->rssi_val_min = 100;\n\n\t\tif (dm_digtable->pre_cck_pd_state == CCK_PD_STAGE_LOWRSSI) {\n\t\t\tif (dm_digtable->rssi_val_min <= 25)\n\t\t\t\tdm_digtable->cur_cck_pd_state =\n\t\t\t\t    CCK_PD_STAGE_LOWRSSI;\n\t\t\telse\n\t\t\t\tdm_digtable->cur_cck_pd_state =\n\t\t\t\t    CCK_PD_STAGE_HIGHRSSI;\n\t\t} else {\n\t\t\tif (dm_digtable->rssi_val_min <= 20)\n\t\t\t\tdm_digtable->cur_cck_pd_state =\n\t\t\t\t    CCK_PD_STAGE_LOWRSSI;\n\t\t\telse\n\t\t\t\tdm_digtable->cur_cck_pd_state =\n\t\t\t\t    CCK_PD_STAGE_HIGHRSSI;\n\t\t}\n\t} else {\n\t\tdm_digtable->cur_cck_pd_state = CCK_PD_STAGE_MAX;\n\t}\n\n\tif (dm_digtable->pre_cck_pd_state != dm_digtable->cur_cck_pd_state) {\n\t\tif ((dm_digtable->cur_cck_pd_state == CCK_PD_STAGE_LOWRSSI) ||\n\t\t    (dm_digtable->cur_cck_pd_state == CCK_PD_STAGE_MAX))\n\t\t\trtl_set_bbreg(hw, RCCK0_CCA, MASKBYTE2, 0x83);\n\t\telse\n\t\t\trtl_set_bbreg(hw, RCCK0_CCA, MASKBYTE2, 0xcd);\n\n\t\tdm_digtable->pre_cck_pd_state = dm_digtable->cur_cck_pd_state;\n\t}\n}\n\nstatic void rtl92c_dm_ctrl_initgain_by_twoport(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct dig_t *dm_digtable = &rtlpriv->dm_digtable;\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\n\tif (mac->act_scanning)\n\t\treturn;\n\n\tif (mac->link_state >= MAC80211_LINKED)\n\t\tdm_digtable->cursta_cstate = DIG_STA_CONNECT;\n\telse\n\t\tdm_digtable->cursta_cstate = DIG_STA_DISCONNECT;\n\n\tdm_digtable->curmultista_cstate = DIG_MULTISTA_DISCONNECT;\n\n\trtl92c_dm_initial_gain_sta(hw);\n\trtl92c_dm_initial_gain_multi_sta(hw);\n\trtl92c_dm_cck_packet_detection_thresh(hw);\n\n\tdm_digtable->presta_cstate = dm_digtable->cursta_cstate;\n}\n\nstatic void rtl92c_dm_dig(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\tif (!rtlpriv->dm.dm_initialgain_enable)\n\t\treturn;\n\tif (!(rtlpriv->dm.dm_flag & DYNAMIC_FUNC_DIG))\n\t\treturn;\n\n\trtl92c_dm_ctrl_initgain_by_twoport(hw);\n}\n\nstatic void rtl92c_dm_init_dynamic_txpower(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\tif (rtlpriv->rtlhal.interface == INTF_USB &&\n\t    rtlpriv->rtlhal.board_type & 0x1) {\n\t\tdm_savepowerindex(hw);\n\t\trtlpriv->dm.dynamic_txpower_enable = true;\n\t} else {\n\t\trtlpriv->dm.dynamic_txpower_enable = false;\n\t}\n\trtlpriv->dm.last_dtp_lvl = TXHIGHPWRLEVEL_NORMAL;\n\trtlpriv->dm.dynamic_txhighpower_lvl = TXHIGHPWRLEVEL_NORMAL;\n}\n\nvoid rtl92c_dm_write_dig(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct dig_t *dm_digtable = &rtlpriv->dm_digtable;\n\n\trtl_dbg(rtlpriv, COMP_DIG, DBG_LOUD,\n\t\t\"cur_igvalue = 0x%x, pre_igvalue = 0x%x, back_val = %d\\n\",\n\t\tdm_digtable->cur_igvalue, dm_digtable->pre_igvalue,\n\t\tdm_digtable->back_val);\n\n\tif (rtlpriv->rtlhal.interface == INTF_USB &&\n\t    !dm_digtable->dig_enable_flag) {\n\t\tdm_digtable->pre_igvalue = 0x17;\n\t\treturn;\n\t}\n\tdm_digtable->cur_igvalue -= 1;\n\tif (dm_digtable->cur_igvalue < DM_DIG_MIN)\n\t\tdm_digtable->cur_igvalue = DM_DIG_MIN;\n\n\tif (dm_digtable->pre_igvalue != dm_digtable->cur_igvalue) {\n\t\trtl_set_bbreg(hw, ROFDM0_XAAGCCORE1, 0x7f,\n\t\t\t      dm_digtable->cur_igvalue);\n\t\trtl_set_bbreg(hw, ROFDM0_XBAGCCORE1, 0x7f,\n\t\t\t      dm_digtable->cur_igvalue);\n\n\t\tdm_digtable->pre_igvalue = dm_digtable->cur_igvalue;\n\t}\n\trtl_dbg(rtlpriv, COMP_DIG, DBG_WARNING,\n\t\t\"dig values 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\\n\",\n\t\tdm_digtable->cur_igvalue, dm_digtable->pre_igvalue,\n\t\tdm_digtable->rssi_val_min, dm_digtable->back_val,\n\t\tdm_digtable->rx_gain_max, dm_digtable->rx_gain_min,\n\t\tdm_digtable->large_fa_hit, dm_digtable->forbidden_igi);\n}\nEXPORT_SYMBOL(rtl92c_dm_write_dig);\n\nstatic void rtl92c_dm_pwdb_monitor(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tlong tmpentry_max_pwdb = 0, tmpentry_min_pwdb = 0xff;\n\n\tif (mac->link_state != MAC80211_LINKED)\n\t\treturn;\n\n\tif (mac->opmode == NL80211_IFTYPE_ADHOC ||\n\t    mac->opmode == NL80211_IFTYPE_AP) {\n\t\t \n\t}\n\n\tif (tmpentry_max_pwdb != 0)\n\t\trtlpriv->dm.entry_max_undec_sm_pwdb = tmpentry_max_pwdb;\n\telse\n\t\trtlpriv->dm.entry_max_undec_sm_pwdb = 0;\n\n\tif (tmpentry_min_pwdb != 0xff)\n\t\trtlpriv->dm.entry_min_undec_sm_pwdb = tmpentry_min_pwdb;\n\telse\n\t\trtlpriv->dm.entry_min_undec_sm_pwdb = 0;\n\n \n}\n\nvoid rtl92c_dm_init_edca_turbo(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtlpriv->dm.current_turbo_edca = false;\n\trtlpriv->dm.is_any_nonbepkts = false;\n\trtlpriv->dm.is_cur_rdlstate = false;\n}\nEXPORT_SYMBOL(rtl92c_dm_init_edca_turbo);\n\nstatic void rtl92c_dm_check_edca_turbo(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\n\tstatic u64 last_txok_cnt;\n\tstatic u64 last_rxok_cnt;\n\tstatic u32 last_bt_edca_ul;\n\tstatic u32 last_bt_edca_dl;\n\tu64 cur_txok_cnt = 0;\n\tu64 cur_rxok_cnt = 0;\n\tu32 edca_be_ul = 0x5ea42b;\n\tu32 edca_be_dl = 0x5ea42b;\n\tbool bt_change_edca = false;\n\n\tif ((last_bt_edca_ul != rtlpriv->btcoexist.bt_edca_ul) ||\n\t    (last_bt_edca_dl != rtlpriv->btcoexist.bt_edca_dl)) {\n\t\trtlpriv->dm.current_turbo_edca = false;\n\t\tlast_bt_edca_ul = rtlpriv->btcoexist.bt_edca_ul;\n\t\tlast_bt_edca_dl = rtlpriv->btcoexist.bt_edca_dl;\n\t}\n\n\tif (rtlpriv->btcoexist.bt_edca_ul != 0) {\n\t\tedca_be_ul = rtlpriv->btcoexist.bt_edca_ul;\n\t\tbt_change_edca = true;\n\t}\n\n\tif (rtlpriv->btcoexist.bt_edca_dl != 0) {\n\t\tedca_be_dl = rtlpriv->btcoexist.bt_edca_dl;\n\t\tbt_change_edca = true;\n\t}\n\n\tif (mac->link_state != MAC80211_LINKED) {\n\t\trtlpriv->dm.current_turbo_edca = false;\n\t\treturn;\n\t}\n\n\tif ((!mac->ht_enable) && (!rtlpriv->btcoexist.bt_coexistence)) {\n\t\tif (!(edca_be_ul & 0xffff0000))\n\t\t\tedca_be_ul |= 0x005e0000;\n\n\t\tif (!(edca_be_dl & 0xffff0000))\n\t\t\tedca_be_dl |= 0x005e0000;\n\t}\n\n\tif ((bt_change_edca) || ((!rtlpriv->dm.is_any_nonbepkts) &&\n\t     (!rtlpriv->dm.disable_framebursting))) {\n\t\tcur_txok_cnt = rtlpriv->stats.txbytesunicast - last_txok_cnt;\n\t\tcur_rxok_cnt = rtlpriv->stats.rxbytesunicast - last_rxok_cnt;\n\n\t\tif (cur_rxok_cnt > 4 * cur_txok_cnt) {\n\t\t\tif (!rtlpriv->dm.is_cur_rdlstate ||\n\t\t\t    !rtlpriv->dm.current_turbo_edca) {\n\t\t\t\trtl_write_dword(rtlpriv,\n\t\t\t\t\t\tREG_EDCA_BE_PARAM,\n\t\t\t\t\t\tedca_be_dl);\n\t\t\t\trtlpriv->dm.is_cur_rdlstate = true;\n\t\t\t}\n\t\t} else {\n\t\t\tif (rtlpriv->dm.is_cur_rdlstate ||\n\t\t\t    !rtlpriv->dm.current_turbo_edca) {\n\t\t\t\trtl_write_dword(rtlpriv,\n\t\t\t\t\t\tREG_EDCA_BE_PARAM,\n\t\t\t\t\t\tedca_be_ul);\n\t\t\t\trtlpriv->dm.is_cur_rdlstate = false;\n\t\t\t}\n\t\t}\n\t\trtlpriv->dm.current_turbo_edca = true;\n\t} else {\n\t\tif (rtlpriv->dm.current_turbo_edca) {\n\t\t\tu8 tmp = AC0_BE;\n\n\t\t\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_AC_PARAM,\n\t\t\t\t\t\t      &tmp);\n\t\t\trtlpriv->dm.current_turbo_edca = false;\n\t\t}\n\t}\n\n\trtlpriv->dm.is_any_nonbepkts = false;\n\tlast_txok_cnt = rtlpriv->stats.txbytesunicast;\n\tlast_rxok_cnt = rtlpriv->stats.rxbytesunicast;\n}\n\nstatic void rtl92c_dm_txpower_tracking_callback_thermalmeter(struct ieee80211_hw\n\t\t\t\t\t\t\t     *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tu8 thermalvalue, delta, delta_lck, delta_iqk;\n\tlong ele_a, ele_d, temp_cck, val_x, value32;\n\tlong val_y, ele_c = 0;\n\tu8 ofdm_index[2], ofdm_index_old[2] = {0, 0}, cck_index_old = 0;\n\ts8 cck_index = 0;\n\tint i;\n\tbool is2t = IS_92C_SERIAL(rtlhal->version);\n\ts8 txpwr_level[3] = {0, 0, 0};\n\tu8 ofdm_min_index = 6, rf;\n\n\trtlpriv->dm.txpower_trackinginit = true;\n\trtl_dbg(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\n\t\t\"%s\\n\", __func__);\n\n\tthermalvalue = (u8) rtl_get_rfreg(hw, RF90_PATH_A, RF_T_METER, 0x1f);\n\n\trtl_dbg(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\n\t\t\"Readback Thermal Meter = 0x%x pre thermal meter 0x%x eeprom_thermalmeter 0x%x\\n\",\n\t\tthermalvalue, rtlpriv->dm.thermalvalue,\n\t\trtlefuse->eeprom_thermalmeter);\n\n\trtl92c_phy_ap_calibrate(hw, (thermalvalue -\n\t\t\t\t     rtlefuse->eeprom_thermalmeter));\n\tif (is2t)\n\t\trf = 2;\n\telse\n\t\trf = 1;\n\n\tif (thermalvalue) {\n\t\tele_d = rtl_get_bbreg(hw, ROFDM0_XATXIQIMBALANCE,\n\t\t\t\t      MASKDWORD) & MASKOFDM_D;\n\n\t\tfor (i = 0; i < OFDM_TABLE_LENGTH; i++) {\n\t\t\tif (ele_d == (ofdmswing_table[i] & MASKOFDM_D)) {\n\t\t\t\tofdm_index_old[0] = (u8) i;\n\n\t\t\t\trtl_dbg(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\n\t\t\t\t\t\"Initial pathA ele_d reg0x%x = 0x%lx, ofdm_index=0x%x\\n\",\n\t\t\t\t\tROFDM0_XATXIQIMBALANCE,\n\t\t\t\t\tele_d, ofdm_index_old[0]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (is2t) {\n\t\t\tele_d = rtl_get_bbreg(hw, ROFDM0_XBTXIQIMBALANCE,\n\t\t\t\t\t      MASKDWORD) & MASKOFDM_D;\n\n\t\t\tfor (i = 0; i < OFDM_TABLE_LENGTH; i++) {\n\t\t\t\tif (ele_d == (ofdmswing_table[i] &\n\t\t\t\t    MASKOFDM_D)) {\n\t\t\t\t\tofdm_index_old[1] = (u8) i;\n\t\t\t\t\trtl_dbg(rtlpriv, COMP_POWER_TRACKING,\n\t\t\t\t\t\tDBG_LOUD,\n\t\t\t\t\t\t\"Initial pathB ele_d reg0x%x = 0x%lx, ofdm_index=0x%x\\n\",\n\t\t\t\t\t\tROFDM0_XBTXIQIMBALANCE, ele_d,\n\t\t\t\t\t\tofdm_index_old[1]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttemp_cck =\n\t\t    rtl_get_bbreg(hw, RCCK0_TXFILTER2, MASKDWORD) & MASKCCK;\n\n\t\tfor (i = 0; i < CCK_TABLE_LENGTH; i++) {\n\t\t\tif (rtlpriv->dm.cck_inch14) {\n\t\t\t\tif (memcmp((void *)&temp_cck,\n\t\t\t\t\t   (void *)&cckswing_table_ch14[i][2],\n\t\t\t\t\t   4) == 0) {\n\t\t\t\t\tcck_index_old = (u8) i;\n\n\t\t\t\t\trtl_dbg(rtlpriv, COMP_POWER_TRACKING,\n\t\t\t\t\t\tDBG_LOUD,\n\t\t\t\t\t\t\"Initial reg0x%x = 0x%lx, cck_index=0x%x, ch 14 %d\\n\",\n\t\t\t\t\t\tRCCK0_TXFILTER2, temp_cck,\n\t\t\t\t\t\tcck_index_old,\n\t\t\t\t\t\trtlpriv->dm.cck_inch14);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (memcmp((void *)&temp_cck,\n\t\t\t\t\t   (void *)\n\t\t\t\t\t   &cckswing_table_ch1ch13[i][2],\n\t\t\t\t\t   4) == 0) {\n\t\t\t\t\tcck_index_old = (u8) i;\n\n\t\t\t\t\trtl_dbg(rtlpriv, COMP_POWER_TRACKING,\n\t\t\t\t\t\tDBG_LOUD,\n\t\t\t\t\t\t\"Initial reg0x%x = 0x%lx, cck_index=0x%x, ch14 %d\\n\",\n\t\t\t\t\t\tRCCK0_TXFILTER2, temp_cck,\n\t\t\t\t\t\tcck_index_old,\n\t\t\t\t\t\trtlpriv->dm.cck_inch14);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!rtlpriv->dm.thermalvalue) {\n\t\t\trtlpriv->dm.thermalvalue =\n\t\t\t    rtlefuse->eeprom_thermalmeter;\n\t\t\trtlpriv->dm.thermalvalue_lck = thermalvalue;\n\t\t\trtlpriv->dm.thermalvalue_iqk = thermalvalue;\n\t\t\tfor (i = 0; i < rf; i++)\n\t\t\t\trtlpriv->dm.ofdm_index[i] = ofdm_index_old[i];\n\t\t\trtlpriv->dm.cck_index = cck_index_old;\n\t\t}\n\t\t \n\n\t\tdelta = (thermalvalue > rtlpriv->dm.thermalvalue) ?\n\t\t    (thermalvalue - rtlpriv->dm.thermalvalue) :\n\t\t    (rtlpriv->dm.thermalvalue - thermalvalue);\n\n\t\tdelta_lck = (thermalvalue > rtlpriv->dm.thermalvalue_lck) ?\n\t\t    (thermalvalue - rtlpriv->dm.thermalvalue_lck) :\n\t\t    (rtlpriv->dm.thermalvalue_lck - thermalvalue);\n\n\t\tdelta_iqk = (thermalvalue > rtlpriv->dm.thermalvalue_iqk) ?\n\t\t    (thermalvalue - rtlpriv->dm.thermalvalue_iqk) :\n\t\t    (rtlpriv->dm.thermalvalue_iqk - thermalvalue);\n\n\t\trtl_dbg(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\n\t\t\t\"Readback Thermal Meter = 0x%x pre thermal meter 0x%x eeprom_thermalmeter 0x%x delta 0x%x delta_lck 0x%x delta_iqk 0x%x\\n\",\n\t\t\tthermalvalue, rtlpriv->dm.thermalvalue,\n\t\t\trtlefuse->eeprom_thermalmeter, delta, delta_lck,\n\t\t\tdelta_iqk);\n\n\t\tif (delta_lck > 1) {\n\t\t\trtlpriv->dm.thermalvalue_lck = thermalvalue;\n\t\t\trtl92c_phy_lc_calibrate(hw);\n\t\t}\n\n\t\tif (delta > 0 && rtlpriv->dm.txpower_track_control) {\n\t\t\tif (thermalvalue > rtlpriv->dm.thermalvalue) {\n\t\t\t\tfor (i = 0; i < rf; i++)\n\t\t\t\t\trtlpriv->dm.ofdm_index[i] -= delta;\n\t\t\t\trtlpriv->dm.cck_index -= delta;\n\t\t\t} else {\n\t\t\t\tfor (i = 0; i < rf; i++)\n\t\t\t\t\trtlpriv->dm.ofdm_index[i] += delta;\n\t\t\t\trtlpriv->dm.cck_index += delta;\n\t\t\t}\n\n\t\t\tif (is2t) {\n\t\t\t\trtl_dbg(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\n\t\t\t\t\t\"temp OFDM_A_index=0x%x, OFDM_B_index=0x%x, cck_index=0x%x\\n\",\n\t\t\t\t\trtlpriv->dm.ofdm_index[0],\n\t\t\t\t\trtlpriv->dm.ofdm_index[1],\n\t\t\t\t\trtlpriv->dm.cck_index);\n\t\t\t} else {\n\t\t\t\trtl_dbg(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\n\t\t\t\t\t\"temp OFDM_A_index=0x%x, cck_index=0x%x\\n\",\n\t\t\t\t\trtlpriv->dm.ofdm_index[0],\n\t\t\t\t\trtlpriv->dm.cck_index);\n\t\t\t}\n\n\t\t\tif (thermalvalue > rtlefuse->eeprom_thermalmeter) {\n\t\t\t\tfor (i = 0; i < rf; i++)\n\t\t\t\t\tofdm_index[i] =\n\t\t\t\t\t    rtlpriv->dm.ofdm_index[i]\n\t\t\t\t\t    + 1;\n\t\t\t\tcck_index = rtlpriv->dm.cck_index + 1;\n\t\t\t} else {\n\t\t\t\tfor (i = 0; i < rf; i++)\n\t\t\t\t\tofdm_index[i] =\n\t\t\t\t\t    rtlpriv->dm.ofdm_index[i];\n\t\t\t\tcck_index = rtlpriv->dm.cck_index;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < rf; i++) {\n\t\t\t\tif (txpwr_level[i] >= 0 &&\n\t\t\t\t    txpwr_level[i] <= 26) {\n\t\t\t\t\tif (thermalvalue >\n\t\t\t\t\t    rtlefuse->eeprom_thermalmeter) {\n\t\t\t\t\t\tif (delta < 5)\n\t\t\t\t\t\t\tofdm_index[i] -= 1;\n\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tofdm_index[i] -= 2;\n\t\t\t\t\t} else if (delta > 5 && thermalvalue <\n\t\t\t\t\t\t   rtlefuse->\n\t\t\t\t\t\t   eeprom_thermalmeter) {\n\t\t\t\t\t\tofdm_index[i] += 1;\n\t\t\t\t\t}\n\t\t\t\t} else if (txpwr_level[i] >= 27 &&\n\t\t\t\t\t   txpwr_level[i] <= 32\n\t\t\t\t\t   && thermalvalue >\n\t\t\t\t\t   rtlefuse->eeprom_thermalmeter) {\n\t\t\t\t\tif (delta < 5)\n\t\t\t\t\t\tofdm_index[i] -= 1;\n\n\t\t\t\t\telse\n\t\t\t\t\t\tofdm_index[i] -= 2;\n\t\t\t\t} else if (txpwr_level[i] >= 32 &&\n\t\t\t\t\t   txpwr_level[i] <= 38 &&\n\t\t\t\t\t   thermalvalue >\n\t\t\t\t\t   rtlefuse->eeprom_thermalmeter\n\t\t\t\t\t   && delta > 5) {\n\t\t\t\t\tofdm_index[i] -= 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (txpwr_level[i] >= 0 && txpwr_level[i] <= 26) {\n\t\t\t\tif (thermalvalue >\n\t\t\t\t    rtlefuse->eeprom_thermalmeter) {\n\t\t\t\t\tif (delta < 5)\n\t\t\t\t\t\tcck_index -= 1;\n\n\t\t\t\t\telse\n\t\t\t\t\t\tcck_index -= 2;\n\t\t\t\t} else if (delta > 5 && thermalvalue <\n\t\t\t\t\t   rtlefuse->eeprom_thermalmeter) {\n\t\t\t\t\tcck_index += 1;\n\t\t\t\t}\n\t\t\t} else if (txpwr_level[i] >= 27 &&\n\t\t\t\t   txpwr_level[i] <= 32 &&\n\t\t\t\t   thermalvalue >\n\t\t\t\t   rtlefuse->eeprom_thermalmeter) {\n\t\t\t\tif (delta < 5)\n\t\t\t\t\tcck_index -= 1;\n\n\t\t\t\telse\n\t\t\t\t\tcck_index -= 2;\n\t\t\t} else if (txpwr_level[i] >= 32 &&\n\t\t\t\t   txpwr_level[i] <= 38 &&\n\t\t\t\t   thermalvalue > rtlefuse->eeprom_thermalmeter\n\t\t\t\t   && delta > 5) {\n\t\t\t\tcck_index -= 1;\n\t\t\t}\n\n\t\t\tfor (i = 0; i < rf; i++) {\n\t\t\t\tif (ofdm_index[i] > OFDM_TABLE_SIZE - 1)\n\t\t\t\t\tofdm_index[i] = OFDM_TABLE_SIZE - 1;\n\n\t\t\t\telse if (ofdm_index[i] < ofdm_min_index)\n\t\t\t\t\tofdm_index[i] = ofdm_min_index;\n\t\t\t}\n\n\t\t\tif (cck_index > CCK_TABLE_SIZE - 1)\n\t\t\t\tcck_index = CCK_TABLE_SIZE - 1;\n\t\t\telse if (cck_index < 0)\n\t\t\t\tcck_index = 0;\n\n\t\t\tif (is2t) {\n\t\t\t\trtl_dbg(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\n\t\t\t\t\t\"new OFDM_A_index=0x%x, OFDM_B_index=0x%x, cck_index=0x%x\\n\",\n\t\t\t\t\tofdm_index[0], ofdm_index[1],\n\t\t\t\t\tcck_index);\n\t\t\t} else {\n\t\t\t\trtl_dbg(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\n\t\t\t\t\t\"new OFDM_A_index=0x%x, cck_index=0x%x\\n\",\n\t\t\t\t\tofdm_index[0], cck_index);\n\t\t\t}\n\t\t}\n\n\t\tif (rtlpriv->dm.txpower_track_control && delta != 0) {\n\t\t\tele_d =\n\t\t\t    (ofdmswing_table[ofdm_index[0]] & 0xFFC00000) >> 22;\n\t\t\tval_x = rtlphy->reg_e94;\n\t\t\tval_y = rtlphy->reg_e9c;\n\n\t\t\tif (val_x != 0) {\n\t\t\t\tif ((val_x & 0x00000200) != 0)\n\t\t\t\t\tval_x = val_x | 0xFFFFFC00;\n\t\t\t\tele_a = ((val_x * ele_d) >> 8) & 0x000003FF;\n\n\t\t\t\tif ((val_y & 0x00000200) != 0)\n\t\t\t\t\tval_y = val_y | 0xFFFFFC00;\n\t\t\t\tele_c = ((val_y * ele_d) >> 8) & 0x000003FF;\n\n\t\t\t\tvalue32 = (ele_d << 22) |\n\t\t\t\t    ((ele_c & 0x3F) << 16) | ele_a;\n\n\t\t\t\trtl_set_bbreg(hw, ROFDM0_XATXIQIMBALANCE,\n\t\t\t\t\t      MASKDWORD, value32);\n\n\t\t\t\tvalue32 = (ele_c & 0x000003C0) >> 6;\n\t\t\t\trtl_set_bbreg(hw, ROFDM0_XCTXAFE, MASKH4BITS,\n\t\t\t\t\t      value32);\n\n\t\t\t\tvalue32 = ((val_x * ele_d) >> 7) & 0x01;\n\t\t\t\trtl_set_bbreg(hw, ROFDM0_ECCATHRESHOLD,\n\t\t\t\t\t      BIT(31), value32);\n\n\t\t\t\tvalue32 = ((val_y * ele_d) >> 7) & 0x01;\n\t\t\t\trtl_set_bbreg(hw, ROFDM0_ECCATHRESHOLD,\n\t\t\t\t\t      BIT(29), value32);\n\t\t\t} else {\n\t\t\t\trtl_set_bbreg(hw, ROFDM0_XATXIQIMBALANCE,\n\t\t\t\t\t      MASKDWORD,\n\t\t\t\t\t      ofdmswing_table[ofdm_index[0]]);\n\n\t\t\t\trtl_set_bbreg(hw, ROFDM0_XCTXAFE, MASKH4BITS,\n\t\t\t\t\t      0x00);\n\t\t\t\trtl_set_bbreg(hw, ROFDM0_ECCATHRESHOLD,\n\t\t\t\t\t      BIT(31) | BIT(29), 0x00);\n\t\t\t}\n\n\t\t\tif (!rtlpriv->dm.cck_inch14) {\n\t\t\t\trtl_write_byte(rtlpriv, 0xa22,\n\t\t\t\t\t       cckswing_table_ch1ch13[cck_index]\n\t\t\t\t\t       [0]);\n\t\t\t\trtl_write_byte(rtlpriv, 0xa23,\n\t\t\t\t\t       cckswing_table_ch1ch13[cck_index]\n\t\t\t\t\t       [1]);\n\t\t\t\trtl_write_byte(rtlpriv, 0xa24,\n\t\t\t\t\t       cckswing_table_ch1ch13[cck_index]\n\t\t\t\t\t       [2]);\n\t\t\t\trtl_write_byte(rtlpriv, 0xa25,\n\t\t\t\t\t       cckswing_table_ch1ch13[cck_index]\n\t\t\t\t\t       [3]);\n\t\t\t\trtl_write_byte(rtlpriv, 0xa26,\n\t\t\t\t\t       cckswing_table_ch1ch13[cck_index]\n\t\t\t\t\t       [4]);\n\t\t\t\trtl_write_byte(rtlpriv, 0xa27,\n\t\t\t\t\t       cckswing_table_ch1ch13[cck_index]\n\t\t\t\t\t       [5]);\n\t\t\t\trtl_write_byte(rtlpriv, 0xa28,\n\t\t\t\t\t       cckswing_table_ch1ch13[cck_index]\n\t\t\t\t\t       [6]);\n\t\t\t\trtl_write_byte(rtlpriv, 0xa29,\n\t\t\t\t\t       cckswing_table_ch1ch13[cck_index]\n\t\t\t\t\t       [7]);\n\t\t\t} else {\n\t\t\t\trtl_write_byte(rtlpriv, 0xa22,\n\t\t\t\t\t       cckswing_table_ch14[cck_index]\n\t\t\t\t\t       [0]);\n\t\t\t\trtl_write_byte(rtlpriv, 0xa23,\n\t\t\t\t\t       cckswing_table_ch14[cck_index]\n\t\t\t\t\t       [1]);\n\t\t\t\trtl_write_byte(rtlpriv, 0xa24,\n\t\t\t\t\t       cckswing_table_ch14[cck_index]\n\t\t\t\t\t       [2]);\n\t\t\t\trtl_write_byte(rtlpriv, 0xa25,\n\t\t\t\t\t       cckswing_table_ch14[cck_index]\n\t\t\t\t\t       [3]);\n\t\t\t\trtl_write_byte(rtlpriv, 0xa26,\n\t\t\t\t\t       cckswing_table_ch14[cck_index]\n\t\t\t\t\t       [4]);\n\t\t\t\trtl_write_byte(rtlpriv, 0xa27,\n\t\t\t\t\t       cckswing_table_ch14[cck_index]\n\t\t\t\t\t       [5]);\n\t\t\t\trtl_write_byte(rtlpriv, 0xa28,\n\t\t\t\t\t       cckswing_table_ch14[cck_index]\n\t\t\t\t\t       [6]);\n\t\t\t\trtl_write_byte(rtlpriv, 0xa29,\n\t\t\t\t\t       cckswing_table_ch14[cck_index]\n\t\t\t\t\t       [7]);\n\t\t\t}\n\n\t\t\tif (is2t) {\n\t\t\t\tele_d = (ofdmswing_table[ofdm_index[1]] &\n\t\t\t\t\t 0xFFC00000) >> 22;\n\n\t\t\t\tval_x = rtlphy->reg_eb4;\n\t\t\t\tval_y = rtlphy->reg_ebc;\n\n\t\t\t\tif (val_x != 0) {\n\t\t\t\t\tif ((val_x & 0x00000200) != 0)\n\t\t\t\t\t\tval_x = val_x | 0xFFFFFC00;\n\t\t\t\t\tele_a = ((val_x * ele_d) >> 8) &\n\t\t\t\t\t    0x000003FF;\n\n\t\t\t\t\tif ((val_y & 0x00000200) != 0)\n\t\t\t\t\t\tval_y = val_y | 0xFFFFFC00;\n\t\t\t\t\tele_c = ((val_y * ele_d) >> 8) &\n\t\t\t\t\t    0x00003FF;\n\n\t\t\t\t\tvalue32 = (ele_d << 22) |\n\t\t\t\t\t    ((ele_c & 0x3F) << 16) | ele_a;\n\t\t\t\t\trtl_set_bbreg(hw,\n\t\t\t\t\t\t      ROFDM0_XBTXIQIMBALANCE,\n\t\t\t\t\t\t      MASKDWORD, value32);\n\n\t\t\t\t\tvalue32 = (ele_c & 0x000003C0) >> 6;\n\t\t\t\t\trtl_set_bbreg(hw, ROFDM0_XDTXAFE,\n\t\t\t\t\t\t      MASKH4BITS, value32);\n\n\t\t\t\t\tvalue32 = ((val_x * ele_d) >> 7) & 0x01;\n\t\t\t\t\trtl_set_bbreg(hw, ROFDM0_ECCATHRESHOLD,\n\t\t\t\t\t\t      BIT(27), value32);\n\n\t\t\t\t\tvalue32 = ((val_y * ele_d) >> 7) & 0x01;\n\t\t\t\t\trtl_set_bbreg(hw, ROFDM0_ECCATHRESHOLD,\n\t\t\t\t\t\t      BIT(25), value32);\n\t\t\t\t} else {\n\t\t\t\t\trtl_set_bbreg(hw,\n\t\t\t\t\t\t      ROFDM0_XBTXIQIMBALANCE,\n\t\t\t\t\t\t      MASKDWORD,\n\t\t\t\t\t\t      ofdmswing_table[ofdm_index\n\t\t\t\t\t\t\t\t      [1]]);\n\t\t\t\t\trtl_set_bbreg(hw, ROFDM0_XDTXAFE,\n\t\t\t\t\t\t      MASKH4BITS, 0x00);\n\t\t\t\t\trtl_set_bbreg(hw, ROFDM0_ECCATHRESHOLD,\n\t\t\t\t\t\t      BIT(27) | BIT(25), 0x00);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tif (delta_iqk > 3) {\n\t\t\trtlpriv->dm.thermalvalue_iqk = thermalvalue;\n\t\t\trtl92c_phy_iq_calibrate(hw, false);\n\t\t}\n\n\t\tif (rtlpriv->dm.txpower_track_control)\n\t\t\trtlpriv->dm.thermalvalue = thermalvalue;\n\t}\n\n\trtl_dbg(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, \"<===\\n\");\n\n}\n\nstatic void rtl92c_dm_initialize_txpower_tracking_thermalmeter(\n\t\t\t\t\t\tstruct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtlpriv->dm.txpower_tracking = true;\n\trtlpriv->dm.txpower_trackinginit = false;\n\n\trtl_dbg(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\n\t\t\"pMgntInfo->txpower_tracking = %d\\n\",\n\t\trtlpriv->dm.txpower_tracking);\n}\n\nstatic void rtl92c_dm_initialize_txpower_tracking(struct ieee80211_hw *hw)\n{\n\trtl92c_dm_initialize_txpower_tracking_thermalmeter(hw);\n}\n\nstatic void rtl92c_dm_txpower_tracking_directcall(struct ieee80211_hw *hw)\n{\n\trtl92c_dm_txpower_tracking_callback_thermalmeter(hw);\n}\n\nstatic void rtl92c_dm_check_txpower_tracking_thermal_meter(\n\t\t\t\t\t\tstruct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\tif (!rtlpriv->dm.txpower_tracking)\n\t\treturn;\n\n\tif (!rtlpriv->dm.tm_trigger) {\n\t\trtl_set_rfreg(hw, RF90_PATH_A, RF_T_METER, RFREG_OFFSET_MASK,\n\t\t\t      0x60);\n\t\trtl_dbg(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\n\t\t\t\"Trigger 92S Thermal Meter!!\\n\");\n\t\trtlpriv->dm.tm_trigger = 1;\n\t\treturn;\n\t} else {\n\t\trtl_dbg(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\n\t\t\t\"Schedule TxPowerTracking direct call!!\\n\");\n\t\trtl92c_dm_txpower_tracking_directcall(hw);\n\t\trtlpriv->dm.tm_trigger = 0;\n\t}\n}\n\nvoid rtl92c_dm_check_txpower_tracking(struct ieee80211_hw *hw)\n{\n\trtl92c_dm_check_txpower_tracking_thermal_meter(hw);\n}\nEXPORT_SYMBOL(rtl92c_dm_check_txpower_tracking);\n\nvoid rtl92c_dm_init_rate_adaptive_mask(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rate_adaptive *p_ra = &(rtlpriv->ra);\n\n\tp_ra->ratr_state = DM_RATR_STA_INIT;\n\tp_ra->pre_ratr_state = DM_RATR_STA_INIT;\n\n\tif (rtlpriv->dm.dm_type == DM_TYPE_BYDRIVER)\n\t\trtlpriv->dm.useramask = true;\n\telse\n\t\trtlpriv->dm.useramask = false;\n\n}\nEXPORT_SYMBOL(rtl92c_dm_init_rate_adaptive_mask);\n\nstatic void rtl92c_dm_init_dynamic_bb_powersaving(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct ps_t *dm_pstable = &rtlpriv->dm_pstable;\n\n\tdm_pstable->pre_ccastate = CCA_MAX;\n\tdm_pstable->cur_ccasate = CCA_MAX;\n\tdm_pstable->pre_rfstate = RF_MAX;\n\tdm_pstable->cur_rfstate = RF_MAX;\n\tdm_pstable->rssi_val_min = 0;\n}\n\nvoid rtl92c_dm_rf_saving(struct ieee80211_hw *hw, u8 bforce_in_normal)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct ps_t *dm_pstable = &rtlpriv->dm_pstable;\n\n\tif (!rtlpriv->reg_init) {\n\t\trtlpriv->reg_874 = (rtl_get_bbreg(hw,\n\t\t\t\t\t\t  RFPGA0_XCD_RFINTERFACESW,\n\t\t\t\t\t\t  MASKDWORD) & 0x1CC000) >> 14;\n\n\t\trtlpriv->reg_c70 = (rtl_get_bbreg(hw, ROFDM0_AGCPARAMETER1,\n\t\t\t\t    MASKDWORD) & BIT(3)) >> 3;\n\n\t\trtlpriv->reg_85c = (rtl_get_bbreg(hw, RFPGA0_XCD_SWITCHCONTROL,\n\t\t\t\t    MASKDWORD) & 0xFF000000) >> 24;\n\n\t\trtlpriv->reg_a74 = (rtl_get_bbreg(hw, 0xa74, MASKDWORD) &\n\t\t\t\t    0xF000) >> 12;\n\n\t\trtlpriv->reg_init = true;\n\t}\n\n\tif (!bforce_in_normal) {\n\t\tif (dm_pstable->rssi_val_min != 0) {\n\t\t\tif (dm_pstable->pre_rfstate == RF_NORMAL) {\n\t\t\t\tif (dm_pstable->rssi_val_min >= 30)\n\t\t\t\t\tdm_pstable->cur_rfstate = RF_SAVE;\n\t\t\t\telse\n\t\t\t\t\tdm_pstable->cur_rfstate = RF_NORMAL;\n\t\t\t} else {\n\t\t\t\tif (dm_pstable->rssi_val_min <= 25)\n\t\t\t\t\tdm_pstable->cur_rfstate = RF_NORMAL;\n\t\t\t\telse\n\t\t\t\t\tdm_pstable->cur_rfstate = RF_SAVE;\n\t\t\t}\n\t\t} else {\n\t\t\tdm_pstable->cur_rfstate = RF_MAX;\n\t\t}\n\t} else {\n\t\tdm_pstable->cur_rfstate = RF_NORMAL;\n\t}\n\n\tif (dm_pstable->pre_rfstate != dm_pstable->cur_rfstate) {\n\t\tif (dm_pstable->cur_rfstate == RF_SAVE) {\n\t\t\trtl_set_bbreg(hw, RFPGA0_XCD_RFINTERFACESW,\n\t\t\t\t      0x1C0000, 0x2);\n\t\t\trtl_set_bbreg(hw, ROFDM0_AGCPARAMETER1, BIT(3), 0);\n\t\t\trtl_set_bbreg(hw, RFPGA0_XCD_SWITCHCONTROL,\n\t\t\t\t      0xFF000000, 0x63);\n\t\t\trtl_set_bbreg(hw, RFPGA0_XCD_RFINTERFACESW,\n\t\t\t\t      0xC000, 0x2);\n\t\t\trtl_set_bbreg(hw, 0xa74, 0xF000, 0x3);\n\t\t\trtl_set_bbreg(hw, 0x818, BIT(28), 0x0);\n\t\t\trtl_set_bbreg(hw, 0x818, BIT(28), 0x1);\n\t\t} else {\n\t\t\trtl_set_bbreg(hw, RFPGA0_XCD_RFINTERFACESW,\n\t\t\t\t      0x1CC000, rtlpriv->reg_874);\n\t\t\trtl_set_bbreg(hw, ROFDM0_AGCPARAMETER1, BIT(3),\n\t\t\t\t      rtlpriv->reg_c70);\n\t\t\trtl_set_bbreg(hw, RFPGA0_XCD_SWITCHCONTROL, 0xFF000000,\n\t\t\t\t      rtlpriv->reg_85c);\n\t\t\trtl_set_bbreg(hw, 0xa74, 0xF000, rtlpriv->reg_a74);\n\t\t\trtl_set_bbreg(hw, 0x818, BIT(28), 0x0);\n\t\t}\n\n\t\tdm_pstable->pre_rfstate = dm_pstable->cur_rfstate;\n\t}\n}\nEXPORT_SYMBOL(rtl92c_dm_rf_saving);\n\nstatic void rtl92c_dm_dynamic_bb_powersaving(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct ps_t *dm_pstable = &rtlpriv->dm_pstable;\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\n\t \n\tif (((mac->link_state == MAC80211_NOLINK)) &&\n\t    (rtlpriv->dm.entry_min_undec_sm_pwdb == 0)) {\n\t\tdm_pstable->rssi_val_min = 0;\n\t\trtl_dbg(rtlpriv, DBG_LOUD, DBG_LOUD, \"Not connected to any\\n\");\n\t}\n\n\tif (mac->link_state == MAC80211_LINKED) {\n\t\tif (mac->opmode == NL80211_IFTYPE_ADHOC) {\n\t\t\tdm_pstable->rssi_val_min =\n\t\t\t    rtlpriv->dm.entry_min_undec_sm_pwdb;\n\t\t\trtl_dbg(rtlpriv, DBG_LOUD, DBG_LOUD,\n\t\t\t\t\"AP Client PWDB = 0x%lx\\n\",\n\t\t\t\tdm_pstable->rssi_val_min);\n\t\t} else {\n\t\t\tdm_pstable->rssi_val_min = rtlpriv->dm.undec_sm_pwdb;\n\t\t\trtl_dbg(rtlpriv, DBG_LOUD, DBG_LOUD,\n\t\t\t\t\"STA Default Port PWDB = 0x%lx\\n\",\n\t\t\t\tdm_pstable->rssi_val_min);\n\t\t}\n\t} else {\n\t\tdm_pstable->rssi_val_min =\n\t\t    rtlpriv->dm.entry_min_undec_sm_pwdb;\n\n\t\trtl_dbg(rtlpriv, DBG_LOUD, DBG_LOUD,\n\t\t\t\"AP Ext Port PWDB = 0x%lx\\n\",\n\t\t\tdm_pstable->rssi_val_min);\n\t}\n\n\t \n\tif (IS_92C_SERIAL(rtlhal->version))\n\t\t; \n\telse\n\t\trtl92c_dm_rf_saving(hw, false);\n}\n\nvoid rtl92c_dm_init(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtlpriv->dm.dm_type = DM_TYPE_BYDRIVER;\n\trtlpriv->dm.dm_flag = DYNAMIC_FUNC_DISABLE | DYNAMIC_FUNC_DIG;\n\trtlpriv->dm.undec_sm_pwdb = -1;\n\trtlpriv->dm.undec_sm_cck = -1;\n\trtlpriv->dm.dm_initialgain_enable = true;\n\trtl_dm_diginit(hw, 0x20);\n\n\trtlpriv->dm.dm_flag |= HAL_DM_HIPWR_DISABLE;\n\trtl92c_dm_init_dynamic_txpower(hw);\n\n\trtl92c_dm_init_edca_turbo(hw);\n\trtl92c_dm_init_rate_adaptive_mask(hw);\n\trtlpriv->dm.dm_flag |= DYNAMIC_FUNC_SS;\n\trtl92c_dm_initialize_txpower_tracking(hw);\n\trtl92c_dm_init_dynamic_bb_powersaving(hw);\n\n\trtlpriv->dm.ofdm_pkt_cnt = 0;\n\trtlpriv->dm.dm_rssi_sel = RSSI_DEFAULT;\n}\nEXPORT_SYMBOL(rtl92c_dm_init);\n\nvoid rtl92c_dm_dynamic_txpower(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tlong undec_sm_pwdb;\n\n\tif (!rtlpriv->dm.dynamic_txpower_enable)\n\t\treturn;\n\n\tif (rtlpriv->dm.dm_flag & HAL_DM_HIPWR_DISABLE) {\n\t\trtlpriv->dm.dynamic_txhighpower_lvl = TXHIGHPWRLEVEL_NORMAL;\n\t\treturn;\n\t}\n\n\tif ((mac->link_state < MAC80211_LINKED) &&\n\t    (rtlpriv->dm.entry_min_undec_sm_pwdb == 0)) {\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_TRACE,\n\t\t\t\"Not connected to any\\n\");\n\n\t\trtlpriv->dm.dynamic_txhighpower_lvl = TXHIGHPWRLEVEL_NORMAL;\n\n\t\trtlpriv->dm.last_dtp_lvl = TXHIGHPWRLEVEL_NORMAL;\n\t\treturn;\n\t}\n\n\tif (mac->link_state >= MAC80211_LINKED) {\n\t\tif (mac->opmode == NL80211_IFTYPE_ADHOC) {\n\t\t\tundec_sm_pwdb = rtlpriv->dm.entry_min_undec_sm_pwdb;\n\t\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD,\n\t\t\t\t\"AP Client PWDB = 0x%lx\\n\",\n\t\t\t\tundec_sm_pwdb);\n\t\t} else {\n\t\t\tundec_sm_pwdb = rtlpriv->dm.undec_sm_pwdb;\n\t\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD,\n\t\t\t\t\"STA Default Port PWDB = 0x%lx\\n\",\n\t\t\t\tundec_sm_pwdb);\n\t\t}\n\t} else {\n\t\tundec_sm_pwdb = rtlpriv->dm.entry_min_undec_sm_pwdb;\n\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD,\n\t\t\t\"AP Ext Port PWDB = 0x%lx\\n\",\n\t\t\tundec_sm_pwdb);\n\t}\n\n\tif (undec_sm_pwdb >= TX_POWER_NEAR_FIELD_THRESH_LVL2) {\n\t\trtlpriv->dm.dynamic_txhighpower_lvl = TXHIGHPWRLEVEL_LEVEL2;\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD,\n\t\t\t\"TXHIGHPWRLEVEL_LEVEL1 (TxPwr=0x0)\\n\");\n\t} else if ((undec_sm_pwdb < (TX_POWER_NEAR_FIELD_THRESH_LVL2 - 3)) &&\n\t\t   (undec_sm_pwdb >= TX_POWER_NEAR_FIELD_THRESH_LVL1)) {\n\n\t\trtlpriv->dm.dynamic_txhighpower_lvl = TXHIGHPWRLEVEL_LEVEL1;\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD,\n\t\t\t\"TXHIGHPWRLEVEL_LEVEL1 (TxPwr=0x10)\\n\");\n\t} else if (undec_sm_pwdb < (TX_POWER_NEAR_FIELD_THRESH_LVL1 - 5)) {\n\t\trtlpriv->dm.dynamic_txhighpower_lvl = TXHIGHPWRLEVEL_NORMAL;\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD,\n\t\t\t\"TXHIGHPWRLEVEL_NORMAL\\n\");\n\t}\n\n\tif ((rtlpriv->dm.dynamic_txhighpower_lvl != rtlpriv->dm.last_dtp_lvl)) {\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD,\n\t\t\t\"PHY_SetTxPowerLevel8192S() Channel = %d\\n\",\n\t\t\t rtlphy->current_channel);\n\t\trtl92c_phy_set_txpower_level(hw, rtlphy->current_channel);\n\t\tif (rtlpriv->dm.dynamic_txhighpower_lvl ==\n\t\t    TXHIGHPWRLEVEL_NORMAL)\n\t\t\tdm_restorepowerindex(hw);\n\t\telse if (rtlpriv->dm.dynamic_txhighpower_lvl ==\n\t\t\t TXHIGHPWRLEVEL_LEVEL1)\n\t\t\tdm_writepowerindex(hw, 0x14);\n\t\telse if (rtlpriv->dm.dynamic_txhighpower_lvl ==\n\t\t\t TXHIGHPWRLEVEL_LEVEL2)\n\t\t\tdm_writepowerindex(hw, 0x10);\n\t}\n\trtlpriv->dm.last_dtp_lvl = rtlpriv->dm.dynamic_txhighpower_lvl;\n}\n\nvoid rtl92c_dm_watchdog(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tbool fw_current_inpsmode = false;\n\tbool fw_ps_awake = true;\n\n\trtlpriv->cfg->ops->get_hw_reg(hw, HW_VAR_FW_PSMODE_STATUS,\n\t\t\t\t      (u8 *) (&fw_current_inpsmode));\n\trtlpriv->cfg->ops->get_hw_reg(hw, HW_VAR_FWLPS_RF_ON,\n\t\t\t\t      (u8 *) (&fw_ps_awake));\n\n\tif (ppsc->p2p_ps_info.p2p_ps_mode)\n\t\tfw_ps_awake = false;\n\n\tif ((ppsc->rfpwr_state == ERFON) && ((!fw_current_inpsmode) &&\n\t\t\t\t\t     fw_ps_awake)\n\t    && (!ppsc->rfchange_inprogress)) {\n\t\trtl92c_dm_pwdb_monitor(hw);\n\t\trtl92c_dm_dig(hw);\n\t\trtl92c_dm_false_alarm_counter_statistics(hw);\n\t\trtl92c_dm_dynamic_bb_powersaving(hw);\n\t\trtl92c_dm_dynamic_txpower(hw);\n\t\trtl92c_dm_check_txpower_tracking(hw);\n\t\t \n\t\trtl92c_dm_bt_coexist(hw);\n\t\trtl92c_dm_check_edca_turbo(hw);\n\t}\n}\nEXPORT_SYMBOL(rtl92c_dm_watchdog);\n\nu8 rtl92c_bt_rssi_state_change(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tlong undec_sm_pwdb;\n\tu8 curr_bt_rssi_state = 0x00;\n\n\tif (rtlpriv->mac80211.link_state == MAC80211_LINKED) {\n\t\tundec_sm_pwdb = GET_UNDECORATED_AVERAGE_RSSI(rtlpriv);\n\t} else {\n\t\tif (rtlpriv->dm.entry_min_undec_sm_pwdb == 0)\n\t\t\tundec_sm_pwdb = 100;\n\t\telse\n\t\t\tundec_sm_pwdb = rtlpriv->dm.entry_min_undec_sm_pwdb;\n\t}\n\n\t \n\tif (undec_sm_pwdb >= 67)\n\t\tcurr_bt_rssi_state &= (~BT_RSSI_STATE_NORMAL_POWER);\n\telse if (undec_sm_pwdb < 62)\n\t\tcurr_bt_rssi_state |= BT_RSSI_STATE_NORMAL_POWER;\n\n\t \n\tif (undec_sm_pwdb >= 40)\n\t\tcurr_bt_rssi_state &= (~BT_RSSI_STATE_AMDPU_OFF);\n\telse if (undec_sm_pwdb <= 32)\n\t\tcurr_bt_rssi_state |= BT_RSSI_STATE_AMDPU_OFF;\n\n\t \n\tif (undec_sm_pwdb < 35)\n\t\tcurr_bt_rssi_state |=  BT_RSSI_STATE_SPECIAL_LOW;\n\telse\n\t\tcurr_bt_rssi_state &= (~BT_RSSI_STATE_SPECIAL_LOW);\n\n\t \n\tif (undec_sm_pwdb < 15)\n\t\tcurr_bt_rssi_state |=  BT_RSSI_STATE_BG_EDCA_LOW;\n\telse\n\t\tcurr_bt_rssi_state &= (~BT_RSSI_STATE_BG_EDCA_LOW);\n\n\tif (curr_bt_rssi_state != rtlpriv->btcoexist.bt_rssi_state) {\n\t\trtlpriv->btcoexist.bt_rssi_state = curr_bt_rssi_state;\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\nEXPORT_SYMBOL(rtl92c_bt_rssi_state_change);\n\nstatic bool rtl92c_bt_state_change(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\tu32 polling, ratio_tx, ratio_pri;\n\tu32 bt_tx, bt_pri;\n\tu8 bt_state;\n\tu8 cur_service_type;\n\n\tif (rtlpriv->mac80211.link_state < MAC80211_LINKED)\n\t\treturn false;\n\n\tbt_state = rtl_read_byte(rtlpriv, 0x4fd);\n\tbt_tx = rtl_read_dword(rtlpriv, 0x488) & BT_MASK;\n\tbt_pri = rtl_read_dword(rtlpriv, 0x48c) & BT_MASK;\n\tpolling = rtl_read_dword(rtlpriv, 0x490);\n\n\tif (bt_tx == BT_MASK && bt_pri == BT_MASK &&\n\t    polling == 0xffffffff && bt_state == 0xff)\n\t\treturn false;\n\n\tbt_state &= BIT(0);\n\tif (bt_state != rtlpriv->btcoexist.bt_cur_state) {\n\t\trtlpriv->btcoexist.bt_cur_state = bt_state;\n\n\t\tif (rtlpriv->btcoexist.reg_bt_sco == 3) {\n\t\t\trtlpriv->btcoexist.bt_service = BT_IDLE;\n\n\t\t\tbt_state = bt_state |\n\t\t\t  ((rtlpriv->btcoexist.bt_ant_isolation == 1) ?\n\t\t\t  0 : BIT(1)) | BIT(2);\n\t\t\trtl_write_byte(rtlpriv, 0x4fd, bt_state);\n\t\t}\n\t\treturn true;\n\t}\n\n\tratio_tx = bt_tx * 1000 / polling;\n\tratio_pri = bt_pri * 1000 / polling;\n\trtlpriv->btcoexist.ratio_tx = ratio_tx;\n\trtlpriv->btcoexist.ratio_pri = ratio_pri;\n\n\tif (bt_state && rtlpriv->btcoexist.reg_bt_sco == 3) {\n\n\t\tif ((ratio_tx < 30)  && (ratio_pri < 30))\n\t\t\tcur_service_type = BT_IDLE;\n\t\telse if ((ratio_pri > 110) && (ratio_pri < 250))\n\t\t\tcur_service_type = BT_SCO;\n\t\telse if ((ratio_tx >= 200) && (ratio_pri >= 200))\n\t\t\tcur_service_type = BT_BUSY;\n\t\telse if ((ratio_tx >= 350) && (ratio_tx < 500))\n\t\t\tcur_service_type = BT_OTHERBUSY;\n\t\telse if (ratio_tx >= 500)\n\t\t\tcur_service_type = BT_PAN;\n\t\telse\n\t\t\tcur_service_type = BT_OTHER_ACTION;\n\n\t\tif (cur_service_type != rtlpriv->btcoexist.bt_service) {\n\t\t\trtlpriv->btcoexist.bt_service = cur_service_type;\n\t\t\tbt_state = bt_state |\n\t\t\t   ((rtlpriv->btcoexist.bt_ant_isolation == 1) ?\n\t\t\t   0 : BIT(1)) |\n\t\t\t   ((rtlpriv->btcoexist.bt_service != BT_IDLE) ?\n\t\t\t   0 : BIT(2));\n\n\t\t\t \n\t\t\tif (rtlpriv->btcoexist.bt_service != BT_IDLE) {\n\t\t\t\trtl_write_word(rtlpriv, 0x504, 0x0ccc);\n\t\t\t\trtl_write_byte(rtlpriv, 0x506, 0x54);\n\t\t\t\trtl_write_byte(rtlpriv, 0x507, 0x54);\n\t\t\t} else {\n\t\t\t\trtl_write_byte(rtlpriv, 0x506, 0x00);\n\t\t\t\trtl_write_byte(rtlpriv, 0x507, 0x00);\n\t\t\t}\n\n\t\t\trtl_write_byte(rtlpriv, 0x4fd, bt_state);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n\n}\n\nstatic bool rtl92c_bt_wifi_connect_change(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstatic bool media_connect;\n\n\tif (rtlpriv->mac80211.link_state < MAC80211_LINKED) {\n\t\tmedia_connect = false;\n\t} else {\n\t\tif (!media_connect) {\n\t\t\tmedia_connect = true;\n\t\t\treturn true;\n\t\t}\n\t\tmedia_connect = true;\n\t}\n\n\treturn false;\n}\n\nstatic void rtl92c_bt_set_normal(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\tif (rtlpriv->btcoexist.bt_service == BT_OTHERBUSY) {\n\t\trtlpriv->btcoexist.bt_edca_ul = 0x5ea72b;\n\t\trtlpriv->btcoexist.bt_edca_dl = 0x5ea72b;\n\t} else if (rtlpriv->btcoexist.bt_service == BT_BUSY) {\n\t\trtlpriv->btcoexist.bt_edca_ul = 0x5eb82f;\n\t\trtlpriv->btcoexist.bt_edca_dl = 0x5eb82f;\n\t} else if (rtlpriv->btcoexist.bt_service == BT_SCO) {\n\t\tif (rtlpriv->btcoexist.ratio_tx > 160) {\n\t\t\trtlpriv->btcoexist.bt_edca_ul = 0x5ea72f;\n\t\t\trtlpriv->btcoexist.bt_edca_dl = 0x5ea72f;\n\t\t} else {\n\t\t\trtlpriv->btcoexist.bt_edca_ul = 0x5ea32b;\n\t\t\trtlpriv->btcoexist.bt_edca_dl = 0x5ea42b;\n\t\t}\n\t} else {\n\t\trtlpriv->btcoexist.bt_edca_ul = 0;\n\t\trtlpriv->btcoexist.bt_edca_dl = 0;\n\t}\n\n\tif ((rtlpriv->btcoexist.bt_service != BT_IDLE) &&\n\t    (rtlpriv->mac80211.mode == WIRELESS_MODE_G ||\n\t     (rtlpriv->mac80211.mode == (WIRELESS_MODE_G | WIRELESS_MODE_B))) &&\n\t    (rtlpriv->btcoexist.bt_rssi_state &\n\t     BT_RSSI_STATE_BG_EDCA_LOW)) {\n\t\trtlpriv->btcoexist.bt_edca_ul = 0x5eb82b;\n\t\trtlpriv->btcoexist.bt_edca_dl = 0x5eb82b;\n\t}\n}\n\nstatic void rtl92c_bt_ant_isolation(struct ieee80211_hw *hw, u8 tmp1byte)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\t \n\tif (rtlpriv->mac80211.vendor == PEER_CISCO &&\n\t    rtlpriv->btcoexist.bt_service == BT_OTHER_ACTION) {\n\t\trtl_write_byte(rtlpriv, REG_GPIO_MUXCFG, 0xa0);\n\t} else {\n\t\tif ((rtlpriv->btcoexist.bt_service == BT_BUSY) &&\n\t\t    (rtlpriv->btcoexist.bt_rssi_state &\n\t\t     BT_RSSI_STATE_NORMAL_POWER)) {\n\t\t\trtl_write_byte(rtlpriv, REG_GPIO_MUXCFG, 0xa0);\n\t\t} else if ((rtlpriv->btcoexist.bt_service ==\n\t\t\t    BT_OTHER_ACTION) && (rtlpriv->mac80211.mode <\n\t\t\t    WIRELESS_MODE_N_24G) &&\n\t\t\t    (rtlpriv->btcoexist.bt_rssi_state &\n\t\t\t    BT_RSSI_STATE_SPECIAL_LOW)) {\n\t\t\trtl_write_byte(rtlpriv, REG_GPIO_MUXCFG, 0xa0);\n\t\t} else {\n\t\t\trtl_write_byte(rtlpriv, REG_GPIO_MUXCFG, tmp1byte);\n\t\t}\n\t}\n\n\tif (rtlpriv->btcoexist.bt_service == BT_PAN)\n\t\trtl_write_dword(rtlpriv, REG_GPIO_PIN_CTRL, 0x10100);\n\telse\n\t\trtl_write_dword(rtlpriv, REG_GPIO_PIN_CTRL, 0x0);\n\n\tif (rtlpriv->btcoexist.bt_rssi_state &\n\t    BT_RSSI_STATE_NORMAL_POWER) {\n\t\trtl92c_bt_set_normal(hw);\n\t} else {\n\t\trtlpriv->btcoexist.bt_edca_ul = 0;\n\t\trtlpriv->btcoexist.bt_edca_dl = 0;\n\t}\n\n\tif (rtlpriv->btcoexist.bt_service != BT_IDLE) {\n\t\trtlpriv->cfg->ops->set_rfreg(hw,\n\t\t\t\t RF90_PATH_A,\n\t\t\t\t 0x1e,\n\t\t\t\t 0xf0, 0xf);\n\t} else {\n\t\trtlpriv->cfg->ops->set_rfreg(hw,\n\t\t     RF90_PATH_A, 0x1e, 0xf0,\n\t\t     rtlpriv->btcoexist.bt_rfreg_origin_1e);\n\t}\n\n\tif (!rtlpriv->dm.dynamic_txpower_enable) {\n\t\tif (rtlpriv->btcoexist.bt_service != BT_IDLE) {\n\t\t\tif (rtlpriv->btcoexist.bt_rssi_state &\n\t\t\t\tBT_RSSI_STATE_TXPOWER_LOW) {\n\t\t\t\trtlpriv->dm.dynamic_txhighpower_lvl =\n\t\t\t\t\t\t\tTXHIGHPWRLEVEL_BT2;\n\t\t\t} else {\n\t\t\t\trtlpriv->dm.dynamic_txhighpower_lvl =\n\t\t\t\t\tTXHIGHPWRLEVEL_BT1;\n\t\t\t}\n\t\t} else {\n\t\t\trtlpriv->dm.dynamic_txhighpower_lvl =\n\t\t\t\tTXHIGHPWRLEVEL_NORMAL;\n\t\t}\n\t\trtl92c_phy_set_txpower_level(hw,\n\t\t\trtlpriv->phy.current_channel);\n\t}\n}\n\nstatic void rtl92c_check_bt_change(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tu8 tmp1byte = 0;\n\n\tif (IS_81XXC_VENDOR_UMC_B_CUT(rtlhal->version) &&\n\t    rtlpriv->btcoexist.bt_coexistence)\n\t\ttmp1byte |= BIT(5);\n\tif (rtlpriv->btcoexist.bt_cur_state) {\n\t\tif (rtlpriv->btcoexist.bt_ant_isolation)\n\t\t\trtl92c_bt_ant_isolation(hw, tmp1byte);\n\t} else {\n\t\trtl_write_byte(rtlpriv, REG_GPIO_MUXCFG, tmp1byte);\n\t\trtlpriv->cfg->ops->set_rfreg(hw, RF90_PATH_A, 0x1e, 0xf0,\n\t\t\t\trtlpriv->btcoexist.bt_rfreg_origin_1e);\n\n\t\trtlpriv->btcoexist.bt_edca_ul = 0;\n\t\trtlpriv->btcoexist.bt_edca_dl = 0;\n\t}\n}\n\nvoid rtl92c_dm_bt_coexist(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tbool wifi_connect_change;\n\tbool bt_state_change;\n\tbool rssi_state_change;\n\n\tif ((rtlpriv->btcoexist.bt_coexistence) &&\n\t    (rtlpriv->btcoexist.bt_coexist_type == BT_CSR_BC4)) {\n\t\twifi_connect_change = rtl92c_bt_wifi_connect_change(hw);\n\t\tbt_state_change = rtl92c_bt_state_change(hw);\n\t\trssi_state_change = rtl92c_bt_rssi_state_change(hw);\n\n\t\tif (wifi_connect_change || bt_state_change || rssi_state_change)\n\t\t\trtl92c_check_bt_change(hw);\n\t}\n}\nEXPORT_SYMBOL(rtl92c_dm_bt_coexist);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}