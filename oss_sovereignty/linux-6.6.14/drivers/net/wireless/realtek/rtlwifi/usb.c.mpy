{
  "module_name": "usb.c",
  "hash_id": "00221724c572250f9746b044110b4272a2fbecca0679744fdc7a9418be3f5d1b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtlwifi/usb.c",
  "human_readable_source": "\n \n\n#include \"wifi.h\"\n#include \"core.h\"\n#include \"usb.h\"\n#include \"base.h\"\n#include \"ps.h\"\n#include \"rtl8192c/fw_common.h\"\n#include <linux/export.h>\n#include <linux/module.h>\n\nMODULE_AUTHOR(\"lizhaoming\t<chaoming_li@realsil.com.cn>\");\nMODULE_AUTHOR(\"Realtek WlanFAE\t<wlanfae@realtek.com>\");\nMODULE_AUTHOR(\"Larry Finger\t<Larry.FInger@lwfinger.net>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"USB basic driver for rtlwifi\");\n\n#define\tREALTEK_USB_VENQT_READ\t\t\t0xC0\n#define\tREALTEK_USB_VENQT_WRITE\t\t\t0x40\n#define REALTEK_USB_VENQT_CMD_REQ\t\t0x05\n#define\tREALTEK_USB_VENQT_CMD_IDX\t\t0x00\n\n#define MAX_USBCTRL_VENDORREQ_TIMES\t\t10\n\nstatic void usbctrl_async_callback(struct urb *urb)\n{\n\tif (urb) {\n\t\t \n\t\tkfree(urb->setup_packet);\n\t\t \n\t\tkfree(urb->transfer_buffer);\n\t}\n}\n\nstatic int _usbctrl_vendorreq_async_write(struct usb_device *udev, u8 request,\n\t\t\t\t\t  u16 value, u16 index, void *pdata,\n\t\t\t\t\t  u16 len)\n{\n\tint rc;\n\tunsigned int pipe;\n\tu8 reqtype;\n\tstruct usb_ctrlrequest *dr;\n\tstruct urb *urb;\n\tconst u16 databuf_maxlen = REALTEK_USB_VENQT_MAX_BUF_SIZE;\n\tu8 *databuf;\n\n\tif (WARN_ON_ONCE(len > databuf_maxlen))\n\t\tlen = databuf_maxlen;\n\n\tpipe = usb_sndctrlpipe(udev, 0);  \n\treqtype =  REALTEK_USB_VENQT_WRITE;\n\n\tdr = kzalloc(sizeof(*dr), GFP_ATOMIC);\n\tif (!dr)\n\t\treturn -ENOMEM;\n\n\tdatabuf = kzalloc(databuf_maxlen, GFP_ATOMIC);\n\tif (!databuf) {\n\t\tkfree(dr);\n\t\treturn -ENOMEM;\n\t}\n\n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb) {\n\t\tkfree(databuf);\n\t\tkfree(dr);\n\t\treturn -ENOMEM;\n\t}\n\n\tdr->bRequestType = reqtype;\n\tdr->bRequest = request;\n\tdr->wValue = cpu_to_le16(value);\n\tdr->wIndex = cpu_to_le16(index);\n\tdr->wLength = cpu_to_le16(len);\n\t \n\tmemcpy(databuf, pdata, len);\n\tusb_fill_control_urb(urb, udev, pipe,\n\t\t\t     (unsigned char *)dr, databuf, len,\n\t\t\t     usbctrl_async_callback, NULL);\n\trc = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (rc < 0) {\n\t\tkfree(databuf);\n\t\tkfree(dr);\n\t}\n\tusb_free_urb(urb);\n\treturn rc;\n}\n\nstatic int _usbctrl_vendorreq_sync_read(struct usb_device *udev, u8 request,\n\t\t\t\t\tu16 value, u16 index, void *pdata,\n\t\t\t\t\tu16 len)\n{\n\tunsigned int pipe;\n\tint status;\n\tu8 reqtype;\n\tint vendorreq_times = 0;\n\tstatic int count;\n\n\tpipe = usb_rcvctrlpipe(udev, 0);  \n\treqtype =  REALTEK_USB_VENQT_READ;\n\n\tdo {\n\t\tstatus = usb_control_msg(udev, pipe, request, reqtype, value,\n\t\t\t\t\t index, pdata, len, 1000);\n\t\tif (status < 0) {\n\t\t\t \n\t\t\tif ((value >= FW_8192C_START_ADDRESS &&\n\t\t\t    value <= FW_8192C_END_ADDRESS))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t} while (++vendorreq_times < MAX_USBCTRL_VENDORREQ_TIMES);\n\n\tif (status < 0 && count++ < 4)\n\t\tpr_err(\"reg 0x%x, usbctrl_vendorreq TimeOut! status:0x%x value=0x%x\\n\",\n\t\t       value, status, *(u32 *)pdata);\n\treturn status;\n}\n\nstatic u32 _usb_read_sync(struct rtl_priv *rtlpriv, u32 addr, u16 len)\n{\n\tstruct device *dev = rtlpriv->io.dev;\n\tstruct usb_device *udev = to_usb_device(dev);\n\tu8 request;\n\tu16 wvalue;\n\tu16 index;\n\t__le32 *data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rtlpriv->locks.usb_lock, flags);\n\tif (++rtlpriv->usb_data_index >= RTL_USB_MAX_RX_COUNT)\n\t\trtlpriv->usb_data_index = 0;\n\tdata = &rtlpriv->usb_data[rtlpriv->usb_data_index];\n\tspin_unlock_irqrestore(&rtlpriv->locks.usb_lock, flags);\n\trequest = REALTEK_USB_VENQT_CMD_REQ;\n\tindex = REALTEK_USB_VENQT_CMD_IDX;  \n\n\twvalue = (u16)addr;\n\t_usbctrl_vendorreq_sync_read(udev, request, wvalue, index, data, len);\n\treturn le32_to_cpu(*data);\n}\n\nstatic u8 _usb_read8_sync(struct rtl_priv *rtlpriv, u32 addr)\n{\n\treturn (u8)_usb_read_sync(rtlpriv, addr, 1);\n}\n\nstatic u16 _usb_read16_sync(struct rtl_priv *rtlpriv, u32 addr)\n{\n\treturn (u16)_usb_read_sync(rtlpriv, addr, 2);\n}\n\nstatic u32 _usb_read32_sync(struct rtl_priv *rtlpriv, u32 addr)\n{\n\treturn _usb_read_sync(rtlpriv, addr, 4);\n}\n\nstatic void _usb_write_async(struct usb_device *udev, u32 addr, u32 val,\n\t\t\t     u16 len)\n{\n\tu8 request;\n\tu16 wvalue;\n\tu16 index;\n\t__le32 data;\n\tint ret;\n\n\trequest = REALTEK_USB_VENQT_CMD_REQ;\n\tindex = REALTEK_USB_VENQT_CMD_IDX;  \n\twvalue = (u16)(addr&0x0000ffff);\n\tdata = cpu_to_le32(val);\n\n\tret = _usbctrl_vendorreq_async_write(udev, request, wvalue,\n\t\t\t\t\t     index, &data, len);\n\tif (ret < 0)\n\t\tdev_err(&udev->dev, \"error %d writing at 0x%x\\n\", ret, addr);\n}\n\nstatic void _usb_write8_async(struct rtl_priv *rtlpriv, u32 addr, u8 val)\n{\n\tstruct device *dev = rtlpriv->io.dev;\n\n\t_usb_write_async(to_usb_device(dev), addr, val, 1);\n}\n\nstatic void _usb_write16_async(struct rtl_priv *rtlpriv, u32 addr, u16 val)\n{\n\tstruct device *dev = rtlpriv->io.dev;\n\n\t_usb_write_async(to_usb_device(dev), addr, val, 2);\n}\n\nstatic void _usb_write32_async(struct rtl_priv *rtlpriv, u32 addr, u32 val)\n{\n\tstruct device *dev = rtlpriv->io.dev;\n\n\t_usb_write_async(to_usb_device(dev), addr, val, 4);\n}\n\nstatic void _rtl_usb_io_handler_init(struct device *dev,\n\t\t\t\t     struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtlpriv->io.dev = dev;\n\tmutex_init(&rtlpriv->io.bb_mutex);\n\trtlpriv->io.write8_async\t= _usb_write8_async;\n\trtlpriv->io.write16_async\t= _usb_write16_async;\n\trtlpriv->io.write32_async\t= _usb_write32_async;\n\trtlpriv->io.read8_sync\t\t= _usb_read8_sync;\n\trtlpriv->io.read16_sync\t\t= _usb_read16_sync;\n\trtlpriv->io.read32_sync\t\t= _usb_read32_sync;\n}\n\nstatic void _rtl_usb_io_handler_release(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv __maybe_unused *rtlpriv = rtl_priv(hw);\n\n\tmutex_destroy(&rtlpriv->io.bb_mutex);\n}\n\n \nstatic struct sk_buff *_none_usb_tx_aggregate_hdl(struct ieee80211_hw *hw,\n\t\t\t\t\t\t  struct sk_buff_head *list)\n{\n\treturn skb_dequeue(list);\n}\n\n#define IS_HIGH_SPEED_USB(udev) \\\n\t\t((USB_SPEED_HIGH == (udev)->speed) ? true : false)\n\nstatic int _rtl_usb_init_tx(struct ieee80211_hw *hw)\n{\n\tu32 i;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));\n\n\trtlusb->max_bulk_out_size = IS_HIGH_SPEED_USB(rtlusb->udev)\n\t\t\t\t\t\t    ? USB_HIGH_SPEED_BULK_SIZE\n\t\t\t\t\t\t    : USB_FULL_SPEED_BULK_SIZE;\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG, \"USB Max Bulk-out Size=%d\\n\",\n\t\trtlusb->max_bulk_out_size);\n\n\tfor (i = 0; i < __RTL_TXQ_NUM; i++) {\n\t\tu32 ep_num = rtlusb->ep_map.ep_mapping[i];\n\n\t\tif (!ep_num) {\n\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG,\n\t\t\t\t\"Invalid endpoint map setting!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\trtlusb->usb_tx_post_hdl =\n\t\t rtlpriv->cfg->usb_interface_cfg->usb_tx_post_hdl;\n\trtlusb->usb_tx_cleanup\t=\n\t\t rtlpriv->cfg->usb_interface_cfg->usb_tx_cleanup;\n\trtlusb->usb_tx_aggregate_hdl =\n\t\t (rtlpriv->cfg->usb_interface_cfg->usb_tx_aggregate_hdl)\n\t\t ? rtlpriv->cfg->usb_interface_cfg->usb_tx_aggregate_hdl\n\t\t : &_none_usb_tx_aggregate_hdl;\n\n\tinit_usb_anchor(&rtlusb->tx_submitted);\n\tfor (i = 0; i < RTL_USB_MAX_EP_NUM; i++) {\n\t\tskb_queue_head_init(&rtlusb->tx_skb_queue[i]);\n\t\tinit_usb_anchor(&rtlusb->tx_pending[i]);\n\t}\n\treturn 0;\n}\n\nstatic void _rtl_rx_work(struct tasklet_struct *t);\n\nstatic int _rtl_usb_init_rx(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_usb_priv *usb_priv = rtl_usbpriv(hw);\n\tstruct rtl_usb *rtlusb = rtl_usbdev(usb_priv);\n\n\trtlusb->rx_max_size = rtlpriv->cfg->usb_interface_cfg->rx_max_size;\n\trtlusb->rx_urb_num = rtlpriv->cfg->usb_interface_cfg->rx_urb_num;\n\trtlusb->in_ep = rtlpriv->cfg->usb_interface_cfg->in_ep_num;\n\trtlusb->usb_rx_hdl = rtlpriv->cfg->usb_interface_cfg->usb_rx_hdl;\n\trtlusb->usb_rx_segregate_hdl =\n\t\trtlpriv->cfg->usb_interface_cfg->usb_rx_segregate_hdl;\n\n\tpr_info(\"rx_max_size %d, rx_urb_num %d, in_ep %d\\n\",\n\t\trtlusb->rx_max_size, rtlusb->rx_urb_num, rtlusb->in_ep);\n\tinit_usb_anchor(&rtlusb->rx_submitted);\n\tinit_usb_anchor(&rtlusb->rx_cleanup_urbs);\n\n\tskb_queue_head_init(&rtlusb->rx_queue);\n\ttasklet_setup(&rtlusb->rx_work_tasklet, _rtl_rx_work);\n\n\treturn 0;\n}\n\nstatic int _rtl_usb_init(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_usb_priv *usb_priv = rtl_usbpriv(hw);\n\tstruct rtl_usb *rtlusb = rtl_usbdev(usb_priv);\n\tint err;\n\tu8 epidx;\n\tstruct usb_interface\t*usb_intf = rtlusb->intf;\n\tu8 epnums = usb_intf->cur_altsetting->desc.bNumEndpoints;\n\n\trtlusb->out_ep_nums = rtlusb->in_ep_nums = 0;\n\tfor (epidx = 0; epidx < epnums; epidx++) {\n\t\tstruct usb_endpoint_descriptor *pep_desc;\n\n\t\tpep_desc = &usb_intf->cur_altsetting->endpoint[epidx].desc;\n\n\t\tif (usb_endpoint_dir_in(pep_desc))\n\t\t\trtlusb->in_ep_nums++;\n\t\telse if (usb_endpoint_dir_out(pep_desc))\n\t\t\trtlusb->out_ep_nums++;\n\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG,\n\t\t\t\"USB EP(0x%02x), MaxPacketSize=%d, Interval=%d\\n\",\n\t\t\tpep_desc->bEndpointAddress, pep_desc->wMaxPacketSize,\n\t\t\tpep_desc->bInterval);\n\t}\n\tif (rtlusb->in_ep_nums <  rtlpriv->cfg->usb_interface_cfg->in_ep_num) {\n\t\tpr_err(\"Too few input end points found\\n\");\n\t\treturn -EINVAL;\n\t}\n\tif (rtlusb->out_ep_nums == 0) {\n\t\tpr_err(\"No output end points found\\n\");\n\t\treturn -EINVAL;\n\t}\n\t \n\terr = rtlpriv->cfg->usb_interface_cfg->usb_endpoint_mapping(hw);\n\trtlusb->usb_mq_to_hwq =  rtlpriv->cfg->usb_interface_cfg->usb_mq_to_hwq;\n\t_rtl_usb_init_tx(hw);\n\t_rtl_usb_init_rx(hw);\n\treturn err;\n}\n\nstatic void rtl_usb_init_sw(struct ieee80211_hw *hw)\n{\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tstruct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));\n\n\trtlhal->hw = hw;\n\tppsc->inactiveps = false;\n\tppsc->leisure_ps = false;\n\tppsc->fwctrl_lps = false;\n\tppsc->reg_fwctrl_lps = 3;\n\tppsc->reg_max_lps_awakeintvl = 5;\n\tppsc->fwctrl_psmode = FW_PS_DTIM_MODE;\n\n\t  \n\tmac->beacon_interval = 100;\n\n\t  \n\tmac->min_space_cfg = 0;\n\tmac->max_mss_density = 0;\n\n\t \n\tmac->current_ampdu_density = 7;\n\tmac->current_ampdu_factor = 3;\n\n\t \n\trtlusb->acm_method = EACMWAY2_SW;\n\n\t \n\t \n\trtlusb->irq_mask[0] = 0xFFFFFFFF;\n\t \n\trtlusb->irq_mask[1] = 0xFFFFFFFF;\n\trtlusb->disablehwsm =  true;\n}\n\nstatic void _rtl_rx_completed(struct urb *urb);\n\nstatic int _rtl_prep_rx_urb(struct ieee80211_hw *hw, struct rtl_usb *rtlusb,\n\t\t\t      struct urb *urb, gfp_t gfp_mask)\n{\n\tvoid *buf;\n\n\tbuf = usb_alloc_coherent(rtlusb->udev, rtlusb->rx_max_size, gfp_mask,\n\t\t\t\t &urb->transfer_dma);\n\tif (!buf) {\n\t\tpr_err(\"Failed to usb_alloc_coherent!!\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tusb_fill_bulk_urb(urb, rtlusb->udev,\n\t\t\t  usb_rcvbulkpipe(rtlusb->udev, rtlusb->in_ep),\n\t\t\t  buf, rtlusb->rx_max_size, _rtl_rx_completed, rtlusb);\n\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\treturn 0;\n}\n\nstatic void _rtl_usb_rx_process_agg(struct ieee80211_hw *hw,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 *rxdesc = skb->data;\n\tstruct ieee80211_hdr *hdr;\n\tbool unicast = false;\n\t__le16 fc;\n\tstruct ieee80211_rx_status rx_status = {0};\n\tstruct rtl_stats stats = {\n\t\t.signal = 0,\n\t\t.rate = 0,\n\t};\n\n\tskb_pull(skb, RTL_RX_DESC_SIZE);\n\trtlpriv->cfg->ops->query_rx_desc(hw, &stats, &rx_status, rxdesc, skb);\n\tskb_pull(skb, (stats.rx_drvinfo_size + stats.rx_bufshift));\n\thdr = rtl_get_hdr(skb);\n\tfc = hdr->frame_control;\n\tif (!stats.crc) {\n\t\tmemcpy(IEEE80211_SKB_RXCB(skb), &rx_status, sizeof(rx_status));\n\n\t\tif (is_broadcast_ether_addr(hdr->addr1)) {\n\t\t\t ;\n\t\t} else if (is_multicast_ether_addr(hdr->addr1)) {\n\t\t\t \n\t\t} else {\n\t\t\tunicast = true;\n\t\t\trtlpriv->stats.rxbytesunicast +=  skb->len;\n\t\t}\n\n\t\tif (ieee80211_is_data(fc)) {\n\t\t\trtlpriv->cfg->ops->led_control(hw, LED_CTL_RX);\n\n\t\t\tif (unicast)\n\t\t\t\trtlpriv->link_info.num_rx_inperiod++;\n\t\t}\n\t\t \n\t\trtl_beacon_statistic(hw, skb);\n\t}\n}\n\nstatic void _rtl_usb_rx_process_noagg(struct ieee80211_hw *hw,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 *rxdesc = skb->data;\n\tstruct ieee80211_hdr *hdr;\n\tbool unicast = false;\n\t__le16 fc;\n\tstruct ieee80211_rx_status rx_status = {0};\n\tstruct rtl_stats stats = {\n\t\t.signal = 0,\n\t\t.rate = 0,\n\t};\n\n\tskb_pull(skb, RTL_RX_DESC_SIZE);\n\trtlpriv->cfg->ops->query_rx_desc(hw, &stats, &rx_status, rxdesc, skb);\n\tskb_pull(skb, (stats.rx_drvinfo_size + stats.rx_bufshift));\n\thdr = rtl_get_hdr(skb);\n\tfc = hdr->frame_control;\n\tif (!stats.crc) {\n\t\tmemcpy(IEEE80211_SKB_RXCB(skb), &rx_status, sizeof(rx_status));\n\n\t\tif (is_broadcast_ether_addr(hdr->addr1)) {\n\t\t\t ;\n\t\t} else if (is_multicast_ether_addr(hdr->addr1)) {\n\t\t\t \n\t\t} else {\n\t\t\tunicast = true;\n\t\t\trtlpriv->stats.rxbytesunicast +=  skb->len;\n\t\t}\n\n\t\tif (ieee80211_is_data(fc)) {\n\t\t\trtlpriv->cfg->ops->led_control(hw, LED_CTL_RX);\n\n\t\t\tif (unicast)\n\t\t\t\trtlpriv->link_info.num_rx_inperiod++;\n\t\t}\n\n\t\t \n\t\trtl_beacon_statistic(hw, skb);\n\n\t\tif (likely(rtl_action_proc(hw, skb, false)))\n\t\t\tieee80211_rx(hw, skb);\n\t\telse\n\t\t\tdev_kfree_skb_any(skb);\n\t} else {\n\t\tdev_kfree_skb_any(skb);\n\t}\n}\n\nstatic void _rtl_rx_pre_process(struct ieee80211_hw *hw, struct sk_buff *skb)\n{\n\tstruct sk_buff *_skb;\n\tstruct sk_buff_head rx_queue;\n\tstruct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));\n\n\tskb_queue_head_init(&rx_queue);\n\tif (rtlusb->usb_rx_segregate_hdl)\n\t\trtlusb->usb_rx_segregate_hdl(hw, skb, &rx_queue);\n\tWARN_ON(skb_queue_empty(&rx_queue));\n\twhile (!skb_queue_empty(&rx_queue)) {\n\t\t_skb = skb_dequeue(&rx_queue);\n\t\t_rtl_usb_rx_process_agg(hw, _skb);\n\t\tieee80211_rx(hw, _skb);\n\t}\n}\n\n#define __RX_SKB_MAX_QUEUED\t64\n\nstatic void _rtl_rx_work(struct tasklet_struct *t)\n{\n\tstruct rtl_usb *rtlusb = from_tasklet(rtlusb, t, rx_work_tasklet);\n\tstruct ieee80211_hw *hw = usb_get_intfdata(rtlusb->intf);\n\tstruct sk_buff *skb;\n\n\twhile ((skb = skb_dequeue(&rtlusb->rx_queue))) {\n\t\tif (unlikely(IS_USB_STOP(rtlusb))) {\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (likely(!rtlusb->usb_rx_segregate_hdl)) {\n\t\t\t_rtl_usb_rx_process_noagg(hw, skb);\n\t\t} else {\n\t\t\t \n\t\t\t_rtl_rx_pre_process(hw, skb);\n\t\t\tpr_err(\"rx agg not supported\\n\");\n\t\t}\n\t}\n}\n\nstatic unsigned int _rtl_rx_get_padding(struct ieee80211_hdr *hdr,\n\t\t\t\t\tunsigned int len)\n{\n#if NET_IP_ALIGN != 0\n\tunsigned int padding = 0;\n#endif\n\n\t \n\tif (NET_IP_ALIGN == 0 || len < sizeof(*hdr))\n\t\treturn 0;\n\n#if NET_IP_ALIGN != 0\n\t \n\t \n\n\tif (ieee80211_is_data_qos(hdr->frame_control)) {\n\t\tu8 *qc = ieee80211_get_qos_ctl(hdr);\n\n\t\tpadding ^= NET_IP_ALIGN;\n\n\t\t \n\t\tif ((unsigned long)qc - (unsigned long)hdr < len &&\n\t\t    *qc & IEEE80211_QOS_CTL_A_MSDU_PRESENT)\n\t\t\tpadding ^= NET_IP_ALIGN;\n\t}\n\n\tif (ieee80211_has_a4(hdr->frame_control))\n\t\tpadding ^= NET_IP_ALIGN;\n\n\treturn padding;\n#endif\n}\n\n#define __RADIO_TAP_SIZE_RSV\t32\n\nstatic void _rtl_rx_completed(struct urb *_urb)\n{\n\tstruct rtl_usb *rtlusb = (struct rtl_usb *)_urb->context;\n\tint err = 0;\n\n\tif (unlikely(IS_USB_STOP(rtlusb)))\n\t\tgoto free;\n\n\tif (likely(0 == _urb->status)) {\n\t\tunsigned int padding;\n\t\tstruct sk_buff *skb;\n\t\tunsigned int qlen;\n\t\tunsigned int size = _urb->actual_length;\n\t\tstruct ieee80211_hdr *hdr;\n\n\t\tif (size < RTL_RX_DESC_SIZE + sizeof(struct ieee80211_hdr)) {\n\t\t\tpr_err(\"Too short packet from bulk IN! (len: %d)\\n\",\n\t\t\t       size);\n\t\t\tgoto resubmit;\n\t\t}\n\n\t\tqlen = skb_queue_len(&rtlusb->rx_queue);\n\t\tif (qlen >= __RX_SKB_MAX_QUEUED) {\n\t\t\tpr_err(\"Pending RX skbuff queue full! (qlen: %d)\\n\",\n\t\t\t       qlen);\n\t\t\tgoto resubmit;\n\t\t}\n\n\t\thdr = (void *)(_urb->transfer_buffer + RTL_RX_DESC_SIZE);\n\t\tpadding = _rtl_rx_get_padding(hdr, size - RTL_RX_DESC_SIZE);\n\n\t\tskb = dev_alloc_skb(size + __RADIO_TAP_SIZE_RSV + padding);\n\t\tif (!skb) {\n\t\t\tpr_err(\"Can't allocate skb for bulk IN!\\n\");\n\t\t\tgoto resubmit;\n\t\t}\n\n\t\t_rtl_install_trx_info(rtlusb, skb, rtlusb->in_ep);\n\n\t\t \n\t\tskb_reserve(skb, padding);\n\n\t\t \n\t\tskb_reserve(skb, __RADIO_TAP_SIZE_RSV);\n\n\t\tskb_put_data(skb, _urb->transfer_buffer, size);\n\n\t\tskb_queue_tail(&rtlusb->rx_queue, skb);\n\t\ttasklet_schedule(&rtlusb->rx_work_tasklet);\n\n\t\tgoto resubmit;\n\t}\n\n\tswitch (_urb->status) {\n\t \n\tcase -ENOENT:\n\tcase -ECONNRESET:\n\tcase -ENODEV:\n\tcase -ESHUTDOWN:\n\t\tgoto free;\n\tdefault:\n\t\tbreak;\n\t}\n\nresubmit:\n\tusb_anchor_urb(_urb, &rtlusb->rx_submitted);\n\terr = usb_submit_urb(_urb, GFP_ATOMIC);\n\tif (unlikely(err)) {\n\t\tusb_unanchor_urb(_urb);\n\t\tgoto free;\n\t}\n\treturn;\n\nfree:\n\t \n\tusb_anchor_urb(_urb, &rtlusb->rx_cleanup_urbs);\n}\n\n#undef __RADIO_TAP_SIZE_RSV\n\nstatic void _rtl_usb_cleanup_rx(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));\n\tstruct urb *urb;\n\n\tusb_kill_anchored_urbs(&rtlusb->rx_submitted);\n\n\ttasklet_kill(&rtlusb->rx_work_tasklet);\n\tcancel_work_sync(&rtlpriv->works.lps_change_work);\n\n\tif (rtlpriv->works.rtl_wq) {\n\t\tdestroy_workqueue(rtlpriv->works.rtl_wq);\n\t\trtlpriv->works.rtl_wq = NULL;\n\t}\n\n\tskb_queue_purge(&rtlusb->rx_queue);\n\n\twhile ((urb = usb_get_from_anchor(&rtlusb->rx_cleanup_urbs))) {\n\t\tusb_free_coherent(urb->dev, urb->transfer_buffer_length,\n\t\t\t\turb->transfer_buffer, urb->transfer_dma);\n\t\tusb_free_urb(urb);\n\t}\n}\n\nstatic int _rtl_usb_receive(struct ieee80211_hw *hw)\n{\n\tstruct urb *urb;\n\tint err;\n\tint i;\n\tstruct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));\n\n\tWARN_ON(0 == rtlusb->rx_urb_num);\n\t \n\tWARN_ON(rtlusb->rx_max_size < 1600);\n\n\tfor (i = 0; i < rtlusb->rx_urb_num; i++) {\n\t\terr = -ENOMEM;\n\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!urb)\n\t\t\tgoto err_out;\n\n\t\terr = _rtl_prep_rx_urb(hw, rtlusb, urb, GFP_KERNEL);\n\t\tif (err < 0) {\n\t\t\tpr_err(\"Failed to prep_rx_urb!!\\n\");\n\t\t\tusb_free_urb(urb);\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tusb_anchor_urb(urb, &rtlusb->rx_submitted);\n\t\terr = usb_submit_urb(urb, GFP_KERNEL);\n\t\tif (err) {\n\t\t\tusb_unanchor_urb(urb);\n\t\t\tusb_free_urb(urb);\n\t\t\tgoto err_out;\n\t\t}\n\t\tusb_free_urb(urb);\n\t}\n\treturn 0;\n\nerr_out:\n\tusb_kill_anchored_urbs(&rtlusb->rx_submitted);\n\treturn err;\n}\n\nstatic int rtl_usb_start(struct ieee80211_hw *hw)\n{\n\tint err;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));\n\n\terr = rtlpriv->cfg->ops->hw_init(hw);\n\tif (!err) {\n\t\trtl_init_rx_config(hw);\n\n\t\t \n\t\tSET_USB_START(rtlusb);\n\t\t \n\t\tset_hal_start(rtlhal);\n\n\t\t \n\t\terr = _rtl_usb_receive(hw);\n\t}\n\n\treturn err;\n}\n\n \nstatic void rtl_usb_cleanup(struct ieee80211_hw *hw)\n{\n\tu32 i;\n\tstruct sk_buff *_skb;\n\tstruct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));\n\tstruct ieee80211_tx_info *txinfo;\n\n\t \n\t_rtl_usb_cleanup_rx(hw);\n\n\t \n\tfor (i = 0; i < RTL_USB_MAX_EP_NUM; i++) {\n\t\twhile ((_skb = skb_dequeue(&rtlusb->tx_skb_queue[i]))) {\n\t\t\trtlusb->usb_tx_cleanup(hw, _skb);\n\t\t\ttxinfo = IEEE80211_SKB_CB(_skb);\n\t\t\tieee80211_tx_info_clear_status(txinfo);\n\t\t\ttxinfo->flags |= IEEE80211_TX_STAT_ACK;\n\t\t\tieee80211_tx_status_irqsafe(hw, _skb);\n\t\t}\n\t\tusb_kill_anchored_urbs(&rtlusb->tx_pending[i]);\n\t}\n\tusb_kill_anchored_urbs(&rtlusb->tx_submitted);\n}\n\n \nstatic void rtl_usb_deinit(struct ieee80211_hw *hw)\n{\n\trtl_usb_cleanup(hw);\n}\n\nstatic void rtl_usb_stop(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));\n\tstruct urb *urb;\n\n\t \n\tset_hal_stop(rtlhal);\n\tcancel_work_sync(&rtlpriv->works.fill_h2c_cmd);\n\t \n\tSET_USB_STOP(rtlusb);\n\n\t \n\tusb_kill_anchored_urbs(&rtlusb->rx_submitted);\n\n\ttasklet_kill(&rtlusb->rx_work_tasklet);\n\tcancel_work_sync(&rtlpriv->works.lps_change_work);\n\tcancel_work_sync(&rtlpriv->works.update_beacon_work);\n\n\tflush_workqueue(rtlpriv->works.rtl_wq);\n\n\tskb_queue_purge(&rtlusb->rx_queue);\n\n\twhile ((urb = usb_get_from_anchor(&rtlusb->rx_cleanup_urbs))) {\n\t\tusb_free_coherent(urb->dev, urb->transfer_buffer_length,\n\t\t\t\turb->transfer_buffer, urb->transfer_dma);\n\t\tusb_free_urb(urb);\n\t}\n\n\trtlpriv->cfg->ops->hw_disable(hw);\n}\n\nstatic void _rtl_submit_tx_urb(struct ieee80211_hw *hw, struct urb *_urb)\n{\n\tint err;\n\tstruct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));\n\n\tusb_anchor_urb(_urb, &rtlusb->tx_submitted);\n\terr = usb_submit_urb(_urb, GFP_ATOMIC);\n\tif (err < 0) {\n\t\tstruct sk_buff *skb;\n\n\t\tpr_err(\"Failed to submit urb\\n\");\n\t\tusb_unanchor_urb(_urb);\n\t\tskb = (struct sk_buff *)_urb->context;\n\t\tkfree_skb(skb);\n\t}\n\tusb_free_urb(_urb);\n}\n\nstatic int _usb_tx_post(struct ieee80211_hw *hw, struct urb *urb,\n\t\t\tstruct sk_buff *skb)\n{\n\tstruct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));\n\tstruct ieee80211_tx_info *txinfo;\n\n\trtlusb->usb_tx_post_hdl(hw, urb, skb);\n\tskb_pull(skb, RTL_TX_HEADER_SIZE);\n\ttxinfo = IEEE80211_SKB_CB(skb);\n\tieee80211_tx_info_clear_status(txinfo);\n\ttxinfo->flags |= IEEE80211_TX_STAT_ACK;\n\n\tif (urb->status) {\n\t\tpr_err(\"Urb has error status 0x%X\\n\", urb->status);\n\t\tgoto out;\n\t}\n\t \nout:\n\tieee80211_tx_status_irqsafe(hw, skb);\n\treturn urb->status;\n}\n\nstatic void _rtl_tx_complete(struct urb *urb)\n{\n\tstruct sk_buff *skb = (struct sk_buff *)urb->context;\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct rtl_usb *rtlusb = (struct rtl_usb *)info->rate_driver_data[0];\n\tstruct ieee80211_hw *hw = usb_get_intfdata(rtlusb->intf);\n\tint err;\n\n\tif (unlikely(IS_USB_STOP(rtlusb)))\n\t\treturn;\n\terr = _usb_tx_post(hw, urb, skb);\n\tif (err) {\n\t\t \n\t\treturn;\n\t}\n}\n\nstatic struct urb *_rtl_usb_tx_urb_setup(struct ieee80211_hw *hw,\n\t\t\t\tstruct sk_buff *skb, u32 ep_num)\n{\n\tstruct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));\n\tstruct urb *_urb;\n\n\tWARN_ON(NULL == skb);\n\t_urb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!_urb)\n\t\treturn NULL;\n\t_rtl_install_trx_info(rtlusb, skb, ep_num);\n\tusb_fill_bulk_urb(_urb, rtlusb->udev, usb_sndbulkpipe(rtlusb->udev,\n\t\t\t  ep_num), skb->data, skb->len, _rtl_tx_complete, skb);\n\t_urb->transfer_flags |= URB_ZERO_PACKET;\n\treturn _urb;\n}\n\nstatic void _rtl_usb_transmit(struct ieee80211_hw *hw, struct sk_buff *skb,\n\t\t       enum rtl_txq qnum)\n{\n\tstruct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));\n\tu32 ep_num;\n\tstruct urb *_urb = NULL;\n\n\tWARN_ON(NULL == rtlusb->usb_tx_aggregate_hdl);\n\tif (unlikely(IS_USB_STOP(rtlusb))) {\n\t\tpr_err(\"USB device is stopping...\\n\");\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\tep_num = rtlusb->ep_map.ep_mapping[qnum];\n\t_urb = _rtl_usb_tx_urb_setup(hw, skb, ep_num);\n\tif (unlikely(!_urb)) {\n\t\tpr_err(\"Can't allocate urb. Drop skb!\\n\");\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\t_rtl_submit_tx_urb(hw, _urb);\n}\n\nstatic void _rtl_usb_tx_preprocess(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_sta *sta,\n\t\t\t\t   struct sk_buff *skb,\n\t\t\t\t   u16 hw_queue)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\tstruct rtl_tx_desc *pdesc = NULL;\n\tstruct rtl_tcb_desc tcb_desc;\n\tstruct ieee80211_hdr *hdr = rtl_get_hdr(skb);\n\t__le16 fc = hdr->frame_control;\n\tu8 *pda_addr = hdr->addr1;\n\n\tmemset(&tcb_desc, 0, sizeof(struct rtl_tcb_desc));\n\tif (ieee80211_is_auth(fc)) {\n\t\trtl_dbg(rtlpriv, COMP_SEND, DBG_DMESG, \"MAC80211_LINKING\\n\");\n\t}\n\n\tif (rtlpriv->psc.sw_ps_enabled) {\n\t\tif (ieee80211_is_data(fc) && !ieee80211_is_nullfunc(fc) &&\n\t\t    !ieee80211_has_pm(fc))\n\t\t\thdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_PM);\n\t}\n\n\trtl_action_proc(hw, skb, true);\n\tif (is_multicast_ether_addr(pda_addr))\n\t\trtlpriv->stats.txbytesmulticast += skb->len;\n\telse if (is_broadcast_ether_addr(pda_addr))\n\t\trtlpriv->stats.txbytesbroadcast += skb->len;\n\telse\n\t\trtlpriv->stats.txbytesunicast += skb->len;\n\trtlpriv->cfg->ops->fill_tx_desc(hw, hdr, (u8 *)pdesc, NULL, info, sta, skb,\n\t\t\t\t\thw_queue, &tcb_desc);\n\tif (ieee80211_is_data(fc))\n\t\trtlpriv->cfg->ops->led_control(hw, LED_CTL_TX);\n}\n\nstatic int rtl_usb_tx(struct ieee80211_hw *hw,\n\t\t      struct ieee80211_sta *sta,\n\t\t      struct sk_buff *skb,\n\t\t      struct rtl_tcb_desc *dummy)\n{\n\tstruct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct ieee80211_hdr *hdr = rtl_get_hdr(skb);\n\t__le16 fc = hdr->frame_control;\n\tu16 hw_queue;\n\n\tif (unlikely(is_hal_stop(rtlhal)))\n\t\tgoto err_free;\n\thw_queue = rtlusb->usb_mq_to_hwq(fc, skb_get_queue_mapping(skb));\n\t_rtl_usb_tx_preprocess(hw, sta, skb, hw_queue);\n\t_rtl_usb_transmit(hw, skb, hw_queue);\n\treturn NETDEV_TX_OK;\n\nerr_free:\n\tdev_kfree_skb_any(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic bool rtl_usb_tx_chk_waitq_insert(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct ieee80211_sta *sta,\n\t\t\t\t\tstruct sk_buff *skb)\n{\n\treturn false;\n}\n\nstatic void rtl_fill_h2c_cmd_work_callback(struct work_struct *work)\n{\n\tstruct rtl_works *rtlworks =\n\t    container_of(work, struct rtl_works, fill_h2c_cmd);\n\tstruct ieee80211_hw *hw = rtlworks->hw;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtlpriv->cfg->ops->fill_h2c_cmd(hw, H2C_RA_MASK, 5, rtlpriv->rate_mask);\n}\n\nstatic const struct rtl_intf_ops rtl_usb_ops = {\n\t.adapter_start = rtl_usb_start,\n\t.adapter_stop = rtl_usb_stop,\n\t.adapter_tx = rtl_usb_tx,\n\t.waitq_insert = rtl_usb_tx_chk_waitq_insert,\n};\n\nint rtl_usb_probe(struct usb_interface *intf,\n\t\t  const struct usb_device_id *id,\n\t\t  struct rtl_hal_cfg *rtl_hal_cfg)\n{\n\tint err;\n\tstruct ieee80211_hw *hw = NULL;\n\tstruct rtl_priv *rtlpriv = NULL;\n\tstruct usb_device\t*udev;\n\tstruct rtl_usb_priv *usb_priv;\n\n\thw = ieee80211_alloc_hw(sizeof(struct rtl_priv) +\n\t\t\t\tsizeof(struct rtl_usb_priv), &rtl_ops);\n\tif (!hw) {\n\t\tpr_warn(\"rtl_usb: ieee80211 alloc failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\trtlpriv = hw->priv;\n\trtlpriv->hw = hw;\n\trtlpriv->usb_data = kcalloc(RTL_USB_MAX_RX_COUNT, sizeof(u32),\n\t\t\t\t    GFP_KERNEL);\n\tif (!rtlpriv->usb_data) {\n\t\tieee80211_free_hw(hw);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tspin_lock_init(&rtlpriv->locks.usb_lock);\n\tINIT_WORK(&rtlpriv->works.fill_h2c_cmd,\n\t\t  rtl_fill_h2c_cmd_work_callback);\n\tINIT_WORK(&rtlpriv->works.lps_change_work,\n\t\t  rtl_lps_change_work_callback);\n\tINIT_WORK(&rtlpriv->works.update_beacon_work,\n\t\t  rtl_update_beacon_work_callback);\n\n\trtlpriv->usb_data_index = 0;\n\tinit_completion(&rtlpriv->firmware_loading_complete);\n\tSET_IEEE80211_DEV(hw, &intf->dev);\n\tudev = interface_to_usbdev(intf);\n\tusb_get_dev(udev);\n\tusb_priv = rtl_usbpriv(hw);\n\tmemset(usb_priv, 0, sizeof(*usb_priv));\n\tusb_priv->dev.intf = intf;\n\tusb_priv->dev.udev = udev;\n\tusb_set_intfdata(intf, hw);\n\t \n\trtlpriv->rtlhal.interface = INTF_USB;\n\trtlpriv->cfg = rtl_hal_cfg;\n\trtlpriv->intf_ops = &rtl_usb_ops;\n\t \n\t_rtl_usb_io_handler_init(&udev->dev, hw);\n\trtlpriv->cfg->ops->read_chip_version(hw);\n\t \n\trtlpriv->cfg->ops->read_eeprom_info(hw);\n\terr = _rtl_usb_init(hw);\n\tif (err)\n\t\tgoto error_out2;\n\trtl_usb_init_sw(hw);\n\t \n\terr = rtl_init_core(hw);\n\tif (err) {\n\t\tpr_err(\"Can't allocate sw for mac80211\\n\");\n\t\tgoto error_out2;\n\t}\n\tif (rtlpriv->cfg->ops->init_sw_vars(hw)) {\n\t\tpr_err(\"Can't init_sw_vars\\n\");\n\t\tgoto error_out;\n\t}\n\trtl_init_sw_leds(hw);\n\n\terr = ieee80211_register_hw(hw);\n\tif (err) {\n\t\tpr_err(\"Can't register mac80211 hw.\\n\");\n\t\tgoto error_out;\n\t}\n\trtlpriv->mac80211.mac80211_registered = 1;\n\n\tset_bit(RTL_STATUS_INTERFACE_START, &rtlpriv->status);\n\treturn 0;\n\nerror_out:\n\trtl_deinit_core(hw);\nerror_out2:\n\t_rtl_usb_io_handler_release(hw);\n\tusb_put_dev(udev);\n\tcomplete(&rtlpriv->firmware_loading_complete);\n\tkfree(rtlpriv->usb_data);\n\tieee80211_free_hw(hw);\n\treturn -ENODEV;\n}\nEXPORT_SYMBOL(rtl_usb_probe);\n\nvoid rtl_usb_disconnect(struct usb_interface *intf)\n{\n\tstruct ieee80211_hw *hw = usb_get_intfdata(intf);\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *rtlmac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));\n\n\tif (unlikely(!rtlpriv))\n\t\treturn;\n\t \n\twait_for_completion(&rtlpriv->firmware_loading_complete);\n\tclear_bit(RTL_STATUS_INTERFACE_START, &rtlpriv->status);\n\t \n\tif (rtlmac->mac80211_registered == 1) {\n\t\tieee80211_unregister_hw(hw);\n\t\trtlmac->mac80211_registered = 0;\n\t} else {\n\t\trtl_deinit_deferred_work(hw, false);\n\t\trtlpriv->intf_ops->adapter_stop(hw);\n\t}\n\t \n\t \n\trtl_usb_deinit(hw);\n\trtl_deinit_core(hw);\n\tkfree(rtlpriv->usb_data);\n\trtlpriv->cfg->ops->deinit_sw_vars(hw);\n\t_rtl_usb_io_handler_release(hw);\n\tusb_put_dev(rtlusb->udev);\n\tusb_set_intfdata(intf, NULL);\n\tieee80211_free_hw(hw);\n}\nEXPORT_SYMBOL(rtl_usb_disconnect);\n\nint rtl_usb_suspend(struct usb_interface *pusb_intf, pm_message_t message)\n{\n\treturn 0;\n}\nEXPORT_SYMBOL(rtl_usb_suspend);\n\nint rtl_usb_resume(struct usb_interface *pusb_intf)\n{\n\treturn 0;\n}\nEXPORT_SYMBOL(rtl_usb_resume);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}