{
  "module_name": "efuse.c",
  "hash_id": "ca2654ece3db73f64fa878cb613a0dd4db8766475884e22a8eb421342fe1013d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtlwifi/efuse.c",
  "human_readable_source": "\n \n\n#include \"wifi.h\"\n#include \"efuse.h\"\n#include \"pci.h\"\n#include <linux/export.h>\n\nstatic const u8 PGPKT_DATA_SIZE = 8;\nstatic const int EFUSE_MAX_SIZE = 512;\n\n#define START_ADDRESS\t\t0x1000\n#define REG_MCUFWDL\t\t0x0080\n\nstatic const struct rtl_efuse_ops efuse_ops = {\n\t.efuse_onebyte_read = efuse_one_byte_read,\n\t.efuse_logical_map_read = efuse_shadow_read,\n};\n\nstatic void efuse_shadow_read_1byte(struct ieee80211_hw *hw, u16 offset,\n\t\t\t\t    u8 *value);\nstatic void efuse_shadow_read_2byte(struct ieee80211_hw *hw, u16 offset,\n\t\t\t\t    u16 *value);\nstatic void efuse_shadow_read_4byte(struct ieee80211_hw *hw, u16 offset,\n\t\t\t\t    u32 *value);\nstatic void efuse_shadow_write_1byte(struct ieee80211_hw *hw, u16 offset,\n\t\t\t\t     u8 value);\nstatic void efuse_shadow_write_2byte(struct ieee80211_hw *hw, u16 offset,\n\t\t\t\t     u16 value);\nstatic void efuse_shadow_write_4byte(struct ieee80211_hw *hw, u16 offset,\n\t\t\t\t     u32 value);\nstatic int efuse_one_byte_write(struct ieee80211_hw *hw, u16 addr,\n\t\t\t\tu8 data);\nstatic void efuse_read_all_map(struct ieee80211_hw *hw, u8 *efuse);\nstatic int efuse_pg_packet_read(struct ieee80211_hw *hw, u8 offset,\n\t\t\t\tu8 *data);\nstatic int efuse_pg_packet_write(struct ieee80211_hw *hw, u8 offset,\n\t\t\t\t u8 word_en, u8 *data);\nstatic void efuse_word_enable_data_read(u8 word_en, u8 *sourdata,\n\t\t\t\t\tu8 *targetdata);\nstatic u8 enable_efuse_data_write(struct ieee80211_hw *hw,\n\t\t\t\t  u16 efuse_addr, u8 word_en, u8 *data);\nstatic u16 efuse_get_current_size(struct ieee80211_hw *hw);\nstatic u8 efuse_calculate_word_cnts(u8 word_en);\n\nvoid efuse_initialize(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 bytetemp;\n\tu8 temp;\n\n\tbytetemp = rtl_read_byte(rtlpriv, rtlpriv->cfg->maps[SYS_FUNC_EN] + 1);\n\ttemp = bytetemp | 0x20;\n\trtl_write_byte(rtlpriv, rtlpriv->cfg->maps[SYS_FUNC_EN] + 1, temp);\n\n\tbytetemp = rtl_read_byte(rtlpriv, rtlpriv->cfg->maps[SYS_ISO_CTRL] + 1);\n\ttemp = bytetemp & 0xFE;\n\trtl_write_byte(rtlpriv, rtlpriv->cfg->maps[SYS_ISO_CTRL] + 1, temp);\n\n\tbytetemp = rtl_read_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_TEST] + 3);\n\ttemp = bytetemp | 0x80;\n\trtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_TEST] + 3, temp);\n\n\trtl_write_byte(rtlpriv, 0x2F8, 0x3);\n\n\trtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL] + 3, 0x72);\n\n}\n\nu8 efuse_read_1byte(struct ieee80211_hw *hw, u16 address)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 data;\n\tu8 bytetemp;\n\tu8 temp;\n\tu32 k = 0;\n\tconst u32 efuse_len =\n\t\trtlpriv->cfg->maps[EFUSE_REAL_CONTENT_SIZE];\n\n\tif (address < efuse_len) {\n\t\ttemp = address & 0xFF;\n\t\trtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL] + 1,\n\t\t\t       temp);\n\t\tbytetemp = rtl_read_byte(rtlpriv,\n\t\t\t\t\t rtlpriv->cfg->maps[EFUSE_CTRL] + 2);\n\t\ttemp = ((address >> 8) & 0x03) | (bytetemp & 0xFC);\n\t\trtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL] + 2,\n\t\t\t       temp);\n\n\t\tbytetemp = rtl_read_byte(rtlpriv,\n\t\t\t\t\t rtlpriv->cfg->maps[EFUSE_CTRL] + 3);\n\t\ttemp = bytetemp & 0x7F;\n\t\trtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL] + 3,\n\t\t\t       temp);\n\n\t\tbytetemp = rtl_read_byte(rtlpriv,\n\t\t\t\t\t rtlpriv->cfg->maps[EFUSE_CTRL] + 3);\n\t\twhile (!(bytetemp & 0x80)) {\n\t\t\tbytetemp = rtl_read_byte(rtlpriv,\n\t\t\t\t\t\t rtlpriv->cfg->\n\t\t\t\t\t\t maps[EFUSE_CTRL] + 3);\n\t\t\tk++;\n\t\t\tif (k == 1000)\n\t\t\t\tbreak;\n\t\t}\n\t\tdata = rtl_read_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL]);\n\t\treturn data;\n\t} else\n\t\treturn 0xFF;\n\n}\nEXPORT_SYMBOL(efuse_read_1byte);\n\nvoid efuse_write_1byte(struct ieee80211_hw *hw, u16 address, u8 value)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 bytetemp;\n\tu8 temp;\n\tu32 k = 0;\n\tconst u32 efuse_len =\n\t\trtlpriv->cfg->maps[EFUSE_REAL_CONTENT_SIZE];\n\n\trtl_dbg(rtlpriv, COMP_EFUSE, DBG_LOUD, \"Addr=%x Data =%x\\n\",\n\t\taddress, value);\n\n\tif (address < efuse_len) {\n\t\trtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL], value);\n\n\t\ttemp = address & 0xFF;\n\t\trtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL] + 1,\n\t\t\t       temp);\n\t\tbytetemp = rtl_read_byte(rtlpriv,\n\t\t\t\t\t rtlpriv->cfg->maps[EFUSE_CTRL] + 2);\n\n\t\ttemp = ((address >> 8) & 0x03) | (bytetemp & 0xFC);\n\t\trtl_write_byte(rtlpriv,\n\t\t\t       rtlpriv->cfg->maps[EFUSE_CTRL] + 2, temp);\n\n\t\tbytetemp = rtl_read_byte(rtlpriv,\n\t\t\t\t\t rtlpriv->cfg->maps[EFUSE_CTRL] + 3);\n\t\ttemp = bytetemp | 0x80;\n\t\trtl_write_byte(rtlpriv,\n\t\t\t       rtlpriv->cfg->maps[EFUSE_CTRL] + 3, temp);\n\n\t\tbytetemp = rtl_read_byte(rtlpriv,\n\t\t\t\t\t rtlpriv->cfg->maps[EFUSE_CTRL] + 3);\n\n\t\twhile (bytetemp & 0x80) {\n\t\t\tbytetemp = rtl_read_byte(rtlpriv,\n\t\t\t\t\t\t rtlpriv->cfg->\n\t\t\t\t\t\t maps[EFUSE_CTRL] + 3);\n\t\t\tk++;\n\t\t\tif (k == 100) {\n\t\t\t\tk = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nvoid read_efuse_byte(struct ieee80211_hw *hw, u16 _offset, u8 *pbuf)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 value32;\n\tu8 readbyte;\n\tu16 retry;\n\n\trtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL] + 1,\n\t\t       (_offset & 0xff));\n\treadbyte = rtl_read_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL] + 2);\n\trtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL] + 2,\n\t\t       ((_offset >> 8) & 0x03) | (readbyte & 0xfc));\n\n\treadbyte = rtl_read_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL] + 3);\n\trtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL] + 3,\n\t\t       (readbyte & 0x7f));\n\n\tretry = 0;\n\tvalue32 = rtl_read_dword(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL]);\n\twhile (!(((value32 >> 24) & 0xff) & 0x80) && (retry < 10000)) {\n\t\tvalue32 = rtl_read_dword(rtlpriv,\n\t\t\t\t\t rtlpriv->cfg->maps[EFUSE_CTRL]);\n\t\tretry++;\n\t}\n\n\tudelay(50);\n\tvalue32 = rtl_read_dword(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL]);\n\n\t*pbuf = (u8) (value32 & 0xff);\n}\nEXPORT_SYMBOL_GPL(read_efuse_byte);\n\nvoid read_efuse(struct ieee80211_hw *hw, u16 _offset, u16 _size_byte, u8 *pbuf)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tu8 *efuse_tbl;\n\tu8 rtemp8[1];\n\tu16 efuse_addr = 0;\n\tu8 offset, wren;\n\tu8 u1temp = 0;\n\tu16 i;\n\tu16 j;\n\tconst u16 efuse_max_section =\n\t\trtlpriv->cfg->maps[EFUSE_MAX_SECTION_MAP];\n\tconst u32 efuse_len =\n\t\trtlpriv->cfg->maps[EFUSE_REAL_CONTENT_SIZE];\n\tu16 **efuse_word;\n\tu16 efuse_utilized = 0;\n\tu8 efuse_usage;\n\n\tif ((_offset + _size_byte) > rtlpriv->cfg->maps[EFUSE_HWSET_MAX_SIZE]) {\n\t\trtl_dbg(rtlpriv, COMP_EFUSE, DBG_LOUD,\n\t\t\t\"%s: Invalid offset(%#x) with read bytes(%#x)!!\\n\",\n\t\t\t__func__, _offset, _size_byte);\n\t\treturn;\n\t}\n\n\t \n\tefuse_tbl = kzalloc(rtlpriv->cfg->maps[EFUSE_HWSET_MAX_SIZE],\n\t\t\t    GFP_ATOMIC);\n\tif (!efuse_tbl)\n\t\treturn;\n\tefuse_word = kcalloc(EFUSE_MAX_WORD_UNIT, sizeof(u16 *), GFP_ATOMIC);\n\tif (!efuse_word)\n\t\tgoto out;\n\tfor (i = 0; i < EFUSE_MAX_WORD_UNIT; i++) {\n\t\tefuse_word[i] = kcalloc(efuse_max_section, sizeof(u16),\n\t\t\t\t\tGFP_ATOMIC);\n\t\tif (!efuse_word[i])\n\t\t\tgoto done;\n\t}\n\n\tfor (i = 0; i < efuse_max_section; i++)\n\t\tfor (j = 0; j < EFUSE_MAX_WORD_UNIT; j++)\n\t\t\tefuse_word[j][i] = 0xFFFF;\n\n\tread_efuse_byte(hw, efuse_addr, rtemp8);\n\tif (*rtemp8 != 0xFF) {\n\t\tefuse_utilized++;\n\t\tRTPRINT(rtlpriv, FEEPROM, EFUSE_READ_ALL,\n\t\t\t\"Addr=%d\\n\", efuse_addr);\n\t\tefuse_addr++;\n\t}\n\n\twhile ((*rtemp8 != 0xFF) && (efuse_addr < efuse_len)) {\n\t\t \n\t\tif ((*rtemp8 & 0x1F) == 0x0F) { \n\t\t\tu1temp = ((*rtemp8 & 0xE0) >> 5);\n\t\t\tread_efuse_byte(hw, efuse_addr, rtemp8);\n\n\t\t\tif ((*rtemp8 & 0x0F) == 0x0F) {\n\t\t\t\tefuse_addr++;\n\t\t\t\tread_efuse_byte(hw, efuse_addr, rtemp8);\n\n\t\t\t\tif (*rtemp8 != 0xFF &&\n\t\t\t\t    (efuse_addr < efuse_len)) {\n\t\t\t\t\tefuse_addr++;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\toffset = ((*rtemp8 & 0xF0) >> 1) | u1temp;\n\t\t\t\twren = (*rtemp8 & 0x0F);\n\t\t\t\tefuse_addr++;\n\t\t\t}\n\t\t} else {\n\t\t\toffset = ((*rtemp8 >> 4) & 0x0f);\n\t\t\twren = (*rtemp8 & 0x0f);\n\t\t}\n\n\t\tif (offset < efuse_max_section) {\n\t\t\tRTPRINT(rtlpriv, FEEPROM, EFUSE_READ_ALL,\n\t\t\t\t\"offset-%d Worden=%x\\n\", offset, wren);\n\n\t\t\tfor (i = 0; i < EFUSE_MAX_WORD_UNIT; i++) {\n\t\t\t\tif (!(wren & 0x01)) {\n\t\t\t\t\tRTPRINT(rtlpriv, FEEPROM,\n\t\t\t\t\t\tEFUSE_READ_ALL,\n\t\t\t\t\t\t\"Addr=%d\\n\", efuse_addr);\n\n\t\t\t\t\tread_efuse_byte(hw, efuse_addr, rtemp8);\n\t\t\t\t\tefuse_addr++;\n\t\t\t\t\tefuse_utilized++;\n\t\t\t\t\tefuse_word[i][offset] =\n\t\t\t\t\t\t\t (*rtemp8 & 0xff);\n\n\t\t\t\t\tif (efuse_addr >= efuse_len)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tRTPRINT(rtlpriv, FEEPROM,\n\t\t\t\t\t\tEFUSE_READ_ALL,\n\t\t\t\t\t\t\"Addr=%d\\n\", efuse_addr);\n\n\t\t\t\t\tread_efuse_byte(hw, efuse_addr, rtemp8);\n\t\t\t\t\tefuse_addr++;\n\t\t\t\t\tefuse_utilized++;\n\t\t\t\t\tefuse_word[i][offset] |=\n\t\t\t\t\t    (((u16)*rtemp8 << 8) & 0xff00);\n\n\t\t\t\t\tif (efuse_addr >= efuse_len)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\twren >>= 1;\n\t\t\t}\n\t\t}\n\n\t\tRTPRINT(rtlpriv, FEEPROM, EFUSE_READ_ALL,\n\t\t\t\"Addr=%d\\n\", efuse_addr);\n\t\tread_efuse_byte(hw, efuse_addr, rtemp8);\n\t\tif (*rtemp8 != 0xFF && (efuse_addr < efuse_len)) {\n\t\t\tefuse_utilized++;\n\t\t\tefuse_addr++;\n\t\t}\n\t}\n\n\tfor (i = 0; i < efuse_max_section; i++) {\n\t\tfor (j = 0; j < EFUSE_MAX_WORD_UNIT; j++) {\n\t\t\tefuse_tbl[(i * 8) + (j * 2)] =\n\t\t\t    (efuse_word[j][i] & 0xff);\n\t\t\tefuse_tbl[(i * 8) + ((j * 2) + 1)] =\n\t\t\t    ((efuse_word[j][i] >> 8) & 0xff);\n\t\t}\n\t}\n\n\tfor (i = 0; i < _size_byte; i++)\n\t\tpbuf[i] = efuse_tbl[_offset + i];\n\n\trtlefuse->efuse_usedbytes = efuse_utilized;\n\tefuse_usage = (u8) ((efuse_utilized * 100) / efuse_len);\n\trtlefuse->efuse_usedpercentage = efuse_usage;\n\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_EFUSE_BYTES,\n\t\t\t\t      (u8 *)&efuse_utilized);\n\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_EFUSE_USAGE,\n\t\t\t\t      &efuse_usage);\ndone:\n\tfor (i = 0; i < EFUSE_MAX_WORD_UNIT; i++)\n\t\tkfree(efuse_word[i]);\n\tkfree(efuse_word);\nout:\n\tkfree(efuse_tbl);\n}\n\nbool efuse_shadow_update_chk(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tu8 section_idx, i, base;\n\tu16 words_need = 0, hdr_num = 0, totalbytes, efuse_used;\n\tbool wordchanged, result = true;\n\n\tfor (section_idx = 0; section_idx < 16; section_idx++) {\n\t\tbase = section_idx * 8;\n\t\twordchanged = false;\n\n\t\tfor (i = 0; i < 8; i = i + 2) {\n\t\t\tif (rtlefuse->efuse_map[EFUSE_INIT_MAP][base + i] !=\n\t\t\t    rtlefuse->efuse_map[EFUSE_MODIFY_MAP][base + i] ||\n\t\t\t    rtlefuse->efuse_map[EFUSE_INIT_MAP][base + i + 1] !=\n\t\t\t    rtlefuse->efuse_map[EFUSE_MODIFY_MAP][base + i +\n\t\t\t\t\t\t\t\t   1]) {\n\t\t\t\twords_need++;\n\t\t\t\twordchanged = true;\n\t\t\t}\n\t\t}\n\n\t\tif (wordchanged)\n\t\t\thdr_num++;\n\t}\n\n\ttotalbytes = hdr_num + words_need * 2;\n\tefuse_used = rtlefuse->efuse_usedbytes;\n\n\tif ((totalbytes + efuse_used) >=\n\t    (EFUSE_MAX_SIZE - rtlpriv->cfg->maps[EFUSE_OOB_PROTECT_BYTES_LEN]))\n\t\tresult = false;\n\n\trtl_dbg(rtlpriv, COMP_EFUSE, DBG_LOUD,\n\t\t\"%s: totalbytes(%#x), hdr_num(%#x), words_need(%#x), efuse_used(%d)\\n\",\n\t\t__func__, totalbytes, hdr_num, words_need, efuse_used);\n\n\treturn result;\n}\n\nvoid efuse_shadow_read(struct ieee80211_hw *hw, u8 type,\n\t\t       u16 offset, u32 *value)\n{\n\tif (type == 1)\n\t\tefuse_shadow_read_1byte(hw, offset, (u8 *)value);\n\telse if (type == 2)\n\t\tefuse_shadow_read_2byte(hw, offset, (u16 *)value);\n\telse if (type == 4)\n\t\tefuse_shadow_read_4byte(hw, offset, value);\n\n}\nEXPORT_SYMBOL(efuse_shadow_read);\n\nvoid efuse_shadow_write(struct ieee80211_hw *hw, u8 type, u16 offset,\n\t\t\t\tu32 value)\n{\n\tif (type == 1)\n\t\tefuse_shadow_write_1byte(hw, offset, (u8) value);\n\telse if (type == 2)\n\t\tefuse_shadow_write_2byte(hw, offset, (u16) value);\n\telse if (type == 4)\n\t\tefuse_shadow_write_4byte(hw, offset, value);\n\n}\n\nbool efuse_shadow_update(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tu16 i, offset, base;\n\tu8 word_en = 0x0F;\n\tu8 first_pg = false;\n\n\trtl_dbg(rtlpriv, COMP_EFUSE, DBG_LOUD, \"\\n\");\n\n\tif (!efuse_shadow_update_chk(hw)) {\n\t\tefuse_read_all_map(hw, &rtlefuse->efuse_map[EFUSE_INIT_MAP][0]);\n\t\tmemcpy(&rtlefuse->efuse_map[EFUSE_MODIFY_MAP][0],\n\t\t       &rtlefuse->efuse_map[EFUSE_INIT_MAP][0],\n\t\t       rtlpriv->cfg->maps[EFUSE_HWSET_MAX_SIZE]);\n\n\t\trtl_dbg(rtlpriv, COMP_EFUSE, DBG_LOUD,\n\t\t\t\"efuse out of capacity!!\\n\");\n\t\treturn false;\n\t}\n\tefuse_power_switch(hw, true, true);\n\n\tfor (offset = 0; offset < 16; offset++) {\n\n\t\tword_en = 0x0F;\n\t\tbase = offset * 8;\n\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tif (first_pg) {\n\t\t\t\tword_en &= ~(BIT(i / 2));\n\n\t\t\t\trtlefuse->efuse_map[EFUSE_INIT_MAP][base + i] =\n\t\t\t\t    rtlefuse->efuse_map[EFUSE_MODIFY_MAP][base + i];\n\t\t\t} else {\n\n\t\t\t\tif (rtlefuse->efuse_map[EFUSE_INIT_MAP][base + i] !=\n\t\t\t\t    rtlefuse->efuse_map[EFUSE_MODIFY_MAP][base + i]) {\n\t\t\t\t\tword_en &= ~(BIT(i / 2));\n\n\t\t\t\t\trtlefuse->efuse_map[EFUSE_INIT_MAP][base + i] =\n\t\t\t\t\t    rtlefuse->efuse_map[EFUSE_MODIFY_MAP][base + i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (word_en != 0x0F) {\n\t\t\tu8 tmpdata[8];\n\n\t\t\tmemcpy(tmpdata,\n\t\t\t       &rtlefuse->efuse_map[EFUSE_MODIFY_MAP][base],\n\t\t\t       8);\n\t\t\tRT_PRINT_DATA(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\t      \"U-efuse\\n\", tmpdata, 8);\n\n\t\t\tif (!efuse_pg_packet_write(hw, (u8) offset, word_en,\n\t\t\t\t\t\t   tmpdata)) {\n\t\t\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_WARNING,\n\t\t\t\t\t\"PG section(%#x) fail!!\\n\", offset);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tefuse_power_switch(hw, true, false);\n\tefuse_read_all_map(hw, &rtlefuse->efuse_map[EFUSE_INIT_MAP][0]);\n\n\tmemcpy(&rtlefuse->efuse_map[EFUSE_MODIFY_MAP][0],\n\t       &rtlefuse->efuse_map[EFUSE_INIT_MAP][0],\n\t       rtlpriv->cfg->maps[EFUSE_HWSET_MAX_SIZE]);\n\n\trtl_dbg(rtlpriv, COMP_EFUSE, DBG_LOUD, \"\\n\");\n\treturn true;\n}\n\nvoid rtl_efuse_shadow_map_update(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\n\tif (rtlefuse->autoload_failflag)\n\t\tmemset((&rtlefuse->efuse_map[EFUSE_INIT_MAP][0]),\n\t\t       0xFF, rtlpriv->cfg->maps[EFUSE_HWSET_MAX_SIZE]);\n\telse\n\t\tefuse_read_all_map(hw, &rtlefuse->efuse_map[EFUSE_INIT_MAP][0]);\n\n\tmemcpy(&rtlefuse->efuse_map[EFUSE_MODIFY_MAP][0],\n\t\t\t&rtlefuse->efuse_map[EFUSE_INIT_MAP][0],\n\t\t\trtlpriv->cfg->maps[EFUSE_HWSET_MAX_SIZE]);\n\n}\nEXPORT_SYMBOL(rtl_efuse_shadow_map_update);\n\nvoid efuse_force_write_vendor_id(struct ieee80211_hw *hw)\n{\n\tu8 tmpdata[8] = { 0xFF, 0xFF, 0xEC, 0x10, 0xFF, 0xFF, 0xFF, 0xFF };\n\n\tefuse_power_switch(hw, true, true);\n\n\tefuse_pg_packet_write(hw, 1, 0xD, tmpdata);\n\n\tefuse_power_switch(hw, true, false);\n\n}\n\nvoid efuse_re_pg_section(struct ieee80211_hw *hw, u8 section_idx)\n{\n}\n\nstatic void efuse_shadow_read_1byte(struct ieee80211_hw *hw,\n\t\t\t\t    u16 offset, u8 *value)\n{\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\t*value = rtlefuse->efuse_map[EFUSE_MODIFY_MAP][offset];\n}\n\nstatic void efuse_shadow_read_2byte(struct ieee80211_hw *hw,\n\t\t\t\t    u16 offset, u16 *value)\n{\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\n\t*value = rtlefuse->efuse_map[EFUSE_MODIFY_MAP][offset];\n\t*value |= rtlefuse->efuse_map[EFUSE_MODIFY_MAP][offset + 1] << 8;\n\n}\n\nstatic void efuse_shadow_read_4byte(struct ieee80211_hw *hw,\n\t\t\t\t    u16 offset, u32 *value)\n{\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\n\t*value = rtlefuse->efuse_map[EFUSE_MODIFY_MAP][offset];\n\t*value |= rtlefuse->efuse_map[EFUSE_MODIFY_MAP][offset + 1] << 8;\n\t*value |= rtlefuse->efuse_map[EFUSE_MODIFY_MAP][offset + 2] << 16;\n\t*value |= rtlefuse->efuse_map[EFUSE_MODIFY_MAP][offset + 3] << 24;\n}\n\nstatic void efuse_shadow_write_1byte(struct ieee80211_hw *hw,\n\t\t\t\t     u16 offset, u8 value)\n{\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\n\trtlefuse->efuse_map[EFUSE_MODIFY_MAP][offset] = value;\n}\n\nstatic void efuse_shadow_write_2byte(struct ieee80211_hw *hw,\n\t\t\t\t     u16 offset, u16 value)\n{\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\n\trtlefuse->efuse_map[EFUSE_MODIFY_MAP][offset] = value & 0x00FF;\n\trtlefuse->efuse_map[EFUSE_MODIFY_MAP][offset + 1] = value >> 8;\n\n}\n\nstatic void efuse_shadow_write_4byte(struct ieee80211_hw *hw,\n\t\t\t\t     u16 offset, u32 value)\n{\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\n\trtlefuse->efuse_map[EFUSE_MODIFY_MAP][offset] =\n\t    (u8) (value & 0x000000FF);\n\trtlefuse->efuse_map[EFUSE_MODIFY_MAP][offset + 1] =\n\t    (u8) ((value >> 8) & 0x0000FF);\n\trtlefuse->efuse_map[EFUSE_MODIFY_MAP][offset + 2] =\n\t    (u8) ((value >> 16) & 0x00FF);\n\trtlefuse->efuse_map[EFUSE_MODIFY_MAP][offset + 3] =\n\t    (u8) ((value >> 24) & 0xFF);\n\n}\n\nint efuse_one_byte_read(struct ieee80211_hw *hw, u16 addr, u8 *data)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 tmpidx = 0;\n\tint result;\n\n\trtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL] + 1,\n\t\t       (u8) (addr & 0xff));\n\trtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL] + 2,\n\t\t       ((u8) ((addr >> 8) & 0x03)) |\n\t\t       (rtl_read_byte(rtlpriv,\n\t\t\t\t      rtlpriv->cfg->maps[EFUSE_CTRL] + 2) &\n\t\t\t0xFC));\n\n\trtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL] + 3, 0x72);\n\n\twhile (!(0x80 & rtl_read_byte(rtlpriv,\n\t\t\t\t      rtlpriv->cfg->maps[EFUSE_CTRL] + 3))\n\t       && (tmpidx < 100)) {\n\t\ttmpidx++;\n\t}\n\n\tif (tmpidx < 100) {\n\t\t*data = rtl_read_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL]);\n\t\tresult = true;\n\t} else {\n\t\t*data = 0xff;\n\t\tresult = false;\n\t}\n\treturn result;\n}\nEXPORT_SYMBOL(efuse_one_byte_read);\n\nstatic int efuse_one_byte_write(struct ieee80211_hw *hw, u16 addr, u8 data)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 tmpidx = 0;\n\n\trtl_dbg(rtlpriv, COMP_EFUSE, DBG_LOUD,\n\t\t\"Addr = %x Data=%x\\n\", addr, data);\n\n\trtl_write_byte(rtlpriv,\n\t\t       rtlpriv->cfg->maps[EFUSE_CTRL] + 1, (u8) (addr & 0xff));\n\trtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL] + 2,\n\t\t       (rtl_read_byte(rtlpriv,\n\t\t\t rtlpriv->cfg->maps[EFUSE_CTRL] +\n\t\t\t 2) & 0xFC) | (u8) ((addr >> 8) & 0x03));\n\n\trtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL], data);\n\trtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CTRL] + 3, 0xF2);\n\n\twhile ((0x80 & rtl_read_byte(rtlpriv,\n\t\t\t\t     rtlpriv->cfg->maps[EFUSE_CTRL] + 3))\n\t       && (tmpidx < 100)) {\n\t\ttmpidx++;\n\t}\n\n\tif (tmpidx < 100)\n\t\treturn true;\n\treturn false;\n}\n\nstatic void efuse_read_all_map(struct ieee80211_hw *hw, u8 *efuse)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\tefuse_power_switch(hw, false, true);\n\tread_efuse(hw, 0, rtlpriv->cfg->maps[EFUSE_HWSET_MAX_SIZE], efuse);\n\tefuse_power_switch(hw, false, false);\n}\n\nstatic void efuse_read_data_case1(struct ieee80211_hw *hw, u16 *efuse_addr,\n\t\t\t\tu8 efuse_data, u8 offset, u8 *tmpdata,\n\t\t\t\tu8 *readstate)\n{\n\tbool dataempty = true;\n\tu8 hoffset;\n\tu8 tmpidx;\n\tu8 hworden;\n\tu8 word_cnts;\n\n\thoffset = (efuse_data >> 4) & 0x0F;\n\thworden = efuse_data & 0x0F;\n\tword_cnts = efuse_calculate_word_cnts(hworden);\n\n\tif (hoffset == offset) {\n\t\tfor (tmpidx = 0; tmpidx < word_cnts * 2; tmpidx++) {\n\t\t\tif (efuse_one_byte_read(hw, *efuse_addr + 1 + tmpidx,\n\t\t\t\t\t\t&efuse_data)) {\n\t\t\t\ttmpdata[tmpidx] = efuse_data;\n\t\t\t\tif (efuse_data != 0xff)\n\t\t\t\t\tdataempty = false;\n\t\t\t}\n\t\t}\n\n\t\tif (!dataempty) {\n\t\t\t*readstate = PG_STATE_DATA;\n\t\t} else {\n\t\t\t*efuse_addr = *efuse_addr + (word_cnts * 2) + 1;\n\t\t\t*readstate = PG_STATE_HEADER;\n\t\t}\n\n\t} else {\n\t\t*efuse_addr = *efuse_addr + (word_cnts * 2) + 1;\n\t\t*readstate = PG_STATE_HEADER;\n\t}\n}\n\nstatic int efuse_pg_packet_read(struct ieee80211_hw *hw, u8 offset, u8 *data)\n{\n\tu8 readstate = PG_STATE_HEADER;\n\n\tbool continual = true;\n\n\tu8 efuse_data, word_cnts = 0;\n\tu16 efuse_addr = 0;\n\tu8 tmpdata[8];\n\n\tif (data == NULL)\n\t\treturn false;\n\tif (offset > 15)\n\t\treturn false;\n\n\tmemset(data, 0xff, PGPKT_DATA_SIZE * sizeof(u8));\n\tmemset(tmpdata, 0xff, PGPKT_DATA_SIZE * sizeof(u8));\n\n\twhile (continual && (efuse_addr < EFUSE_MAX_SIZE)) {\n\t\tif (readstate & PG_STATE_HEADER) {\n\t\t\tif (efuse_one_byte_read(hw, efuse_addr, &efuse_data)\n\t\t\t    && (efuse_data != 0xFF))\n\t\t\t\tefuse_read_data_case1(hw, &efuse_addr,\n\t\t\t\t\t\t      efuse_data, offset,\n\t\t\t\t\t\t      tmpdata, &readstate);\n\t\t\telse\n\t\t\t\tcontinual = false;\n\t\t} else if (readstate & PG_STATE_DATA) {\n\t\t\tefuse_word_enable_data_read(0, tmpdata, data);\n\t\t\tefuse_addr = efuse_addr + (word_cnts * 2) + 1;\n\t\t\treadstate = PG_STATE_HEADER;\n\t\t}\n\n\t}\n\n\tif ((data[0] == 0xff) && (data[1] == 0xff) &&\n\t    (data[2] == 0xff) && (data[3] == 0xff) &&\n\t    (data[4] == 0xff) && (data[5] == 0xff) &&\n\t    (data[6] == 0xff) && (data[7] == 0xff))\n\t\treturn false;\n\telse\n\t\treturn true;\n\n}\n\nstatic void efuse_write_data_case1(struct ieee80211_hw *hw, u16 *efuse_addr,\n\t\t\t\t   u8 efuse_data, u8 offset,\n\t\t\t\t   int *continual, u8 *write_state,\n\t\t\t\t   struct pgpkt_struct *target_pkt,\n\t\t\t\t   int *repeat_times, int *result, u8 word_en)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct pgpkt_struct tmp_pkt;\n\tint dataempty = true;\n\tu8 originaldata[8 * sizeof(u8)];\n\tu8 badworden = 0x0F;\n\tu8 match_word_en, tmp_word_en;\n\tu8 tmpindex;\n\tu8 tmp_header = efuse_data;\n\tu8 tmp_word_cnts;\n\n\ttmp_pkt.offset = (tmp_header >> 4) & 0x0F;\n\ttmp_pkt.word_en = tmp_header & 0x0F;\n\ttmp_word_cnts = efuse_calculate_word_cnts(tmp_pkt.word_en);\n\n\tif (tmp_pkt.offset != target_pkt->offset) {\n\t\t*efuse_addr = *efuse_addr + (tmp_word_cnts * 2) + 1;\n\t\t*write_state = PG_STATE_HEADER;\n\t} else {\n\t\tfor (tmpindex = 0; tmpindex < (tmp_word_cnts * 2); tmpindex++) {\n\t\t\tif (efuse_one_byte_read(hw,\n\t\t\t\t\t\t(*efuse_addr + 1 + tmpindex),\n\t\t\t\t\t\t&efuse_data) &&\n\t\t\t    (efuse_data != 0xFF))\n\t\t\t\tdataempty = false;\n\t\t}\n\n\t\tif (!dataempty) {\n\t\t\t*efuse_addr = *efuse_addr + (tmp_word_cnts * 2) + 1;\n\t\t\t*write_state = PG_STATE_HEADER;\n\t\t} else {\n\t\t\tmatch_word_en = 0x0F;\n\t\t\tif (!((target_pkt->word_en & BIT(0)) |\n\t\t\t    (tmp_pkt.word_en & BIT(0))))\n\t\t\t\tmatch_word_en &= (~BIT(0));\n\n\t\t\tif (!((target_pkt->word_en & BIT(1)) |\n\t\t\t    (tmp_pkt.word_en & BIT(1))))\n\t\t\t\tmatch_word_en &= (~BIT(1));\n\n\t\t\tif (!((target_pkt->word_en & BIT(2)) |\n\t\t\t    (tmp_pkt.word_en & BIT(2))))\n\t\t\t\tmatch_word_en &= (~BIT(2));\n\n\t\t\tif (!((target_pkt->word_en & BIT(3)) |\n\t\t\t    (tmp_pkt.word_en & BIT(3))))\n\t\t\t\tmatch_word_en &= (~BIT(3));\n\n\t\t\tif ((match_word_en & 0x0F) != 0x0F) {\n\t\t\t\tbadworden =\n\t\t\t\t  enable_efuse_data_write(hw,\n\t\t\t\t\t\t\t  *efuse_addr + 1,\n\t\t\t\t\t\t\t  tmp_pkt.word_en,\n\t\t\t\t\t\t\t  target_pkt->data);\n\n\t\t\t\tif (0x0F != (badworden & 0x0F))\t{\n\t\t\t\t\tu8 reorg_offset = offset;\n\t\t\t\t\tu8 reorg_worden = badworden;\n\n\t\t\t\t\tefuse_pg_packet_write(hw, reorg_offset,\n\t\t\t\t\t\t\t      reorg_worden,\n\t\t\t\t\t\t\t      originaldata);\n\t\t\t\t}\n\n\t\t\t\ttmp_word_en = 0x0F;\n\t\t\t\tif ((target_pkt->word_en & BIT(0)) ^\n\t\t\t\t    (match_word_en & BIT(0)))\n\t\t\t\t\ttmp_word_en &= (~BIT(0));\n\n\t\t\t\tif ((target_pkt->word_en & BIT(1)) ^\n\t\t\t\t    (match_word_en & BIT(1)))\n\t\t\t\t\ttmp_word_en &= (~BIT(1));\n\n\t\t\t\tif ((target_pkt->word_en & BIT(2)) ^\n\t\t\t\t    (match_word_en & BIT(2)))\n\t\t\t\t\ttmp_word_en &= (~BIT(2));\n\n\t\t\t\tif ((target_pkt->word_en & BIT(3)) ^\n\t\t\t\t    (match_word_en & BIT(3)))\n\t\t\t\t\ttmp_word_en &= (~BIT(3));\n\n\t\t\t\tif ((tmp_word_en & 0x0F) != 0x0F) {\n\t\t\t\t\t*efuse_addr = efuse_get_current_size(hw);\n\t\t\t\t\ttarget_pkt->offset = offset;\n\t\t\t\t\ttarget_pkt->word_en = tmp_word_en;\n\t\t\t\t} else {\n\t\t\t\t\t*continual = false;\n\t\t\t\t}\n\t\t\t\t*write_state = PG_STATE_HEADER;\n\t\t\t\t*repeat_times += 1;\n\t\t\t\tif (*repeat_times > EFUSE_REPEAT_THRESHOLD_) {\n\t\t\t\t\t*continual = false;\n\t\t\t\t\t*result = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t*efuse_addr += (2 * tmp_word_cnts) + 1;\n\t\t\t\ttarget_pkt->offset = offset;\n\t\t\t\ttarget_pkt->word_en = word_en;\n\t\t\t\t*write_state = PG_STATE_HEADER;\n\t\t\t}\n\t\t}\n\t}\n\tRTPRINT(rtlpriv, FEEPROM, EFUSE_PG, \"efuse PG_STATE_HEADER-1\\n\");\n}\n\nstatic void efuse_write_data_case2(struct ieee80211_hw *hw, u16 *efuse_addr,\n\t\t\t\t   int *continual, u8 *write_state,\n\t\t\t\t   struct pgpkt_struct target_pkt,\n\t\t\t\t   int *repeat_times, int *result)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct pgpkt_struct tmp_pkt;\n\tu8 pg_header;\n\tu8 tmp_header;\n\tu8 originaldata[8 * sizeof(u8)];\n\tu8 tmp_word_cnts;\n\tu8 badworden = 0x0F;\n\n\tpg_header = ((target_pkt.offset << 4) & 0xf0) | target_pkt.word_en;\n\tefuse_one_byte_write(hw, *efuse_addr, pg_header);\n\tefuse_one_byte_read(hw, *efuse_addr, &tmp_header);\n\n\tif (tmp_header == pg_header) {\n\t\t*write_state = PG_STATE_DATA;\n\t} else if (tmp_header == 0xFF) {\n\t\t*write_state = PG_STATE_HEADER;\n\t\t*repeat_times += 1;\n\t\tif (*repeat_times > EFUSE_REPEAT_THRESHOLD_) {\n\t\t\t*continual = false;\n\t\t\t*result = false;\n\t\t}\n\t} else {\n\t\ttmp_pkt.offset = (tmp_header >> 4) & 0x0F;\n\t\ttmp_pkt.word_en = tmp_header & 0x0F;\n\n\t\ttmp_word_cnts = efuse_calculate_word_cnts(tmp_pkt.word_en);\n\n\t\tmemset(originaldata, 0xff,  8 * sizeof(u8));\n\n\t\tif (efuse_pg_packet_read(hw, tmp_pkt.offset, originaldata)) {\n\t\t\tbadworden = enable_efuse_data_write(hw,\n\t\t\t\t\t\t\t    *efuse_addr + 1,\n\t\t\t\t\t\t\t    tmp_pkt.word_en,\n\t\t\t\t\t\t\t    originaldata);\n\n\t\t\tif (0x0F != (badworden & 0x0F)) {\n\t\t\t\tu8 reorg_offset = tmp_pkt.offset;\n\t\t\t\tu8 reorg_worden = badworden;\n\n\t\t\t\tefuse_pg_packet_write(hw, reorg_offset,\n\t\t\t\t\t\t      reorg_worden,\n\t\t\t\t\t\t      originaldata);\n\t\t\t\t*efuse_addr = efuse_get_current_size(hw);\n\t\t\t} else {\n\t\t\t\t*efuse_addr = *efuse_addr +\n\t\t\t\t\t      (tmp_word_cnts * 2) + 1;\n\t\t\t}\n\t\t} else {\n\t\t\t*efuse_addr = *efuse_addr + (tmp_word_cnts * 2) + 1;\n\t\t}\n\n\t\t*write_state = PG_STATE_HEADER;\n\t\t*repeat_times += 1;\n\t\tif (*repeat_times > EFUSE_REPEAT_THRESHOLD_) {\n\t\t\t*continual = false;\n\t\t\t*result = false;\n\t\t}\n\n\t\tRTPRINT(rtlpriv, FEEPROM, EFUSE_PG,\n\t\t\t\"efuse PG_STATE_HEADER-2\\n\");\n\t}\n}\n\nstatic int efuse_pg_packet_write(struct ieee80211_hw *hw,\n\t\t\t\t u8 offset, u8 word_en, u8 *data)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct pgpkt_struct target_pkt;\n\tu8 write_state = PG_STATE_HEADER;\n\tint continual = true, result = true;\n\tu16 efuse_addr = 0;\n\tu8 efuse_data;\n\tu8 target_word_cnts = 0;\n\tu8 badworden = 0x0F;\n\tstatic int repeat_times;\n\n\tif (efuse_get_current_size(hw) >= (EFUSE_MAX_SIZE -\n\t\trtlpriv->cfg->maps[EFUSE_OOB_PROTECT_BYTES_LEN])) {\n\t\tRTPRINT(rtlpriv, FEEPROM, EFUSE_PG,\n\t\t\t\"efuse_pg_packet_write error\\n\");\n\t\treturn false;\n\t}\n\n\ttarget_pkt.offset = offset;\n\ttarget_pkt.word_en = word_en;\n\n\tmemset(target_pkt.data, 0xFF,  8 * sizeof(u8));\n\n\tefuse_word_enable_data_read(word_en, data, target_pkt.data);\n\ttarget_word_cnts = efuse_calculate_word_cnts(target_pkt.word_en);\n\n\tRTPRINT(rtlpriv, FEEPROM, EFUSE_PG, \"efuse Power ON\\n\");\n\n\twhile (continual && (efuse_addr < (EFUSE_MAX_SIZE -\n\t\trtlpriv->cfg->maps[EFUSE_OOB_PROTECT_BYTES_LEN]))) {\n\t\tif (write_state == PG_STATE_HEADER) {\n\t\t\tbadworden = 0x0F;\n\t\t\tRTPRINT(rtlpriv, FEEPROM, EFUSE_PG,\n\t\t\t\t\"efuse PG_STATE_HEADER\\n\");\n\n\t\t\tif (efuse_one_byte_read(hw, efuse_addr, &efuse_data) &&\n\t\t\t    (efuse_data != 0xFF))\n\t\t\t\tefuse_write_data_case1(hw, &efuse_addr,\n\t\t\t\t\t\t       efuse_data, offset,\n\t\t\t\t\t\t       &continual,\n\t\t\t\t\t\t       &write_state,\n\t\t\t\t\t\t       &target_pkt,\n\t\t\t\t\t\t       &repeat_times, &result,\n\t\t\t\t\t\t       word_en);\n\t\t\telse\n\t\t\t\tefuse_write_data_case2(hw, &efuse_addr,\n\t\t\t\t\t\t       &continual,\n\t\t\t\t\t\t       &write_state,\n\t\t\t\t\t\t       target_pkt,\n\t\t\t\t\t\t       &repeat_times,\n\t\t\t\t\t\t       &result);\n\n\t\t} else if (write_state == PG_STATE_DATA) {\n\t\t\tRTPRINT(rtlpriv, FEEPROM, EFUSE_PG,\n\t\t\t\t\"efuse PG_STATE_DATA\\n\");\n\t\t\tbadworden =\n\t\t\t    enable_efuse_data_write(hw, efuse_addr + 1,\n\t\t\t\t\t\t    target_pkt.word_en,\n\t\t\t\t\t\t    target_pkt.data);\n\n\t\t\tif ((badworden & 0x0F) == 0x0F) {\n\t\t\t\tcontinual = false;\n\t\t\t} else {\n\t\t\t\tefuse_addr =\n\t\t\t\t    efuse_addr + (2 * target_word_cnts) + 1;\n\n\t\t\t\ttarget_pkt.offset = offset;\n\t\t\t\ttarget_pkt.word_en = badworden;\n\t\t\t\ttarget_word_cnts =\n\t\t\t\t    efuse_calculate_word_cnts(target_pkt.\n\t\t\t\t\t\t\t      word_en);\n\t\t\t\twrite_state = PG_STATE_HEADER;\n\t\t\t\trepeat_times++;\n\t\t\t\tif (repeat_times > EFUSE_REPEAT_THRESHOLD_) {\n\t\t\t\t\tcontinual = false;\n\t\t\t\t\tresult = false;\n\t\t\t\t}\n\t\t\t\tRTPRINT(rtlpriv, FEEPROM, EFUSE_PG,\n\t\t\t\t\t\"efuse PG_STATE_HEADER-3\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\tif (efuse_addr >= (EFUSE_MAX_SIZE -\n\t\trtlpriv->cfg->maps[EFUSE_OOB_PROTECT_BYTES_LEN])) {\n\t\trtl_dbg(rtlpriv, COMP_EFUSE, DBG_LOUD,\n\t\t\t\"efuse_addr(%#x) Out of size!!\\n\", efuse_addr);\n\t}\n\n\treturn true;\n}\n\nstatic void efuse_word_enable_data_read(u8 word_en, u8 *sourdata,\n\t\t\t\t\tu8 *targetdata)\n{\n\tif (!(word_en & BIT(0))) {\n\t\ttargetdata[0] = sourdata[0];\n\t\ttargetdata[1] = sourdata[1];\n\t}\n\n\tif (!(word_en & BIT(1))) {\n\t\ttargetdata[2] = sourdata[2];\n\t\ttargetdata[3] = sourdata[3];\n\t}\n\n\tif (!(word_en & BIT(2))) {\n\t\ttargetdata[4] = sourdata[4];\n\t\ttargetdata[5] = sourdata[5];\n\t}\n\n\tif (!(word_en & BIT(3))) {\n\t\ttargetdata[6] = sourdata[6];\n\t\ttargetdata[7] = sourdata[7];\n\t}\n}\n\nstatic u8 enable_efuse_data_write(struct ieee80211_hw *hw,\n\t\t\t\t  u16 efuse_addr, u8 word_en, u8 *data)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu16 tmpaddr;\n\tu16 start_addr = efuse_addr;\n\tu8 badworden = 0x0F;\n\tu8 tmpdata[8];\n\n\tmemset(tmpdata, 0xff, PGPKT_DATA_SIZE);\n\trtl_dbg(rtlpriv, COMP_EFUSE, DBG_LOUD,\n\t\t\"word_en = %x efuse_addr=%x\\n\", word_en, efuse_addr);\n\n\tif (!(word_en & BIT(0))) {\n\t\ttmpaddr = start_addr;\n\t\tefuse_one_byte_write(hw, start_addr++, data[0]);\n\t\tefuse_one_byte_write(hw, start_addr++, data[1]);\n\n\t\tefuse_one_byte_read(hw, tmpaddr, &tmpdata[0]);\n\t\tefuse_one_byte_read(hw, tmpaddr + 1, &tmpdata[1]);\n\t\tif ((data[0] != tmpdata[0]) || (data[1] != tmpdata[1]))\n\t\t\tbadworden &= (~BIT(0));\n\t}\n\n\tif (!(word_en & BIT(1))) {\n\t\ttmpaddr = start_addr;\n\t\tefuse_one_byte_write(hw, start_addr++, data[2]);\n\t\tefuse_one_byte_write(hw, start_addr++, data[3]);\n\n\t\tefuse_one_byte_read(hw, tmpaddr, &tmpdata[2]);\n\t\tefuse_one_byte_read(hw, tmpaddr + 1, &tmpdata[3]);\n\t\tif ((data[2] != tmpdata[2]) || (data[3] != tmpdata[3]))\n\t\t\tbadworden &= (~BIT(1));\n\t}\n\n\tif (!(word_en & BIT(2))) {\n\t\ttmpaddr = start_addr;\n\t\tefuse_one_byte_write(hw, start_addr++, data[4]);\n\t\tefuse_one_byte_write(hw, start_addr++, data[5]);\n\n\t\tefuse_one_byte_read(hw, tmpaddr, &tmpdata[4]);\n\t\tefuse_one_byte_read(hw, tmpaddr + 1, &tmpdata[5]);\n\t\tif ((data[4] != tmpdata[4]) || (data[5] != tmpdata[5]))\n\t\t\tbadworden &= (~BIT(2));\n\t}\n\n\tif (!(word_en & BIT(3))) {\n\t\ttmpaddr = start_addr;\n\t\tefuse_one_byte_write(hw, start_addr++, data[6]);\n\t\tefuse_one_byte_write(hw, start_addr++, data[7]);\n\n\t\tefuse_one_byte_read(hw, tmpaddr, &tmpdata[6]);\n\t\tefuse_one_byte_read(hw, tmpaddr + 1, &tmpdata[7]);\n\t\tif ((data[6] != tmpdata[6]) || (data[7] != tmpdata[7]))\n\t\t\tbadworden &= (~BIT(3));\n\t}\n\n\treturn badworden;\n}\n\nvoid efuse_power_switch(struct ieee80211_hw *hw, u8 write, u8 pwrstate)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tu8 tempval;\n\tu16 tmpv16;\n\n\tif (pwrstate && (rtlhal->hw_type != HARDWARE_TYPE_RTL8192SE)) {\n\t\tif (rtlhal->hw_type != HARDWARE_TYPE_RTL8192CE &&\n\t\t    rtlhal->hw_type != HARDWARE_TYPE_RTL8192DE) {\n\t\t\trtl_write_byte(rtlpriv,\n\t\t\t\t       rtlpriv->cfg->maps[EFUSE_ACCESS], 0x69);\n\t\t} else {\n\t\t\ttmpv16 =\n\t\t\t  rtl_read_word(rtlpriv,\n\t\t\t\t\trtlpriv->cfg->maps[SYS_ISO_CTRL]);\n\t\t\tif (!(tmpv16 & rtlpriv->cfg->maps[EFUSE_PWC_EV12V])) {\n\t\t\t\ttmpv16 |= rtlpriv->cfg->maps[EFUSE_PWC_EV12V];\n\t\t\t\trtl_write_word(rtlpriv,\n\t\t\t\t\t       rtlpriv->cfg->maps[SYS_ISO_CTRL],\n\t\t\t\t\t       tmpv16);\n\t\t\t}\n\t\t}\n\t\ttmpv16 = rtl_read_word(rtlpriv,\n\t\t\t\t       rtlpriv->cfg->maps[SYS_FUNC_EN]);\n\t\tif (!(tmpv16 & rtlpriv->cfg->maps[EFUSE_FEN_ELDR])) {\n\t\t\ttmpv16 |= rtlpriv->cfg->maps[EFUSE_FEN_ELDR];\n\t\t\trtl_write_word(rtlpriv,\n\t\t\t\t       rtlpriv->cfg->maps[SYS_FUNC_EN], tmpv16);\n\t\t}\n\n\t\ttmpv16 = rtl_read_word(rtlpriv, rtlpriv->cfg->maps[SYS_CLK]);\n\t\tif ((!(tmpv16 & rtlpriv->cfg->maps[EFUSE_LOADER_CLK_EN])) ||\n\t\t    (!(tmpv16 & rtlpriv->cfg->maps[EFUSE_ANA8M]))) {\n\t\t\ttmpv16 |= (rtlpriv->cfg->maps[EFUSE_LOADER_CLK_EN] |\n\t\t\t\t   rtlpriv->cfg->maps[EFUSE_ANA8M]);\n\t\t\trtl_write_word(rtlpriv,\n\t\t\t\t       rtlpriv->cfg->maps[SYS_CLK], tmpv16);\n\t\t}\n\t}\n\n\tif (pwrstate) {\n\t\tif (write) {\n\t\t\ttempval = rtl_read_byte(rtlpriv,\n\t\t\t\t\t\trtlpriv->cfg->maps[EFUSE_TEST] +\n\t\t\t\t\t\t3);\n\n\t\t\tif (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE) {\n\t\t\t\ttempval &= ~(BIT(3) | BIT(4) | BIT(5) | BIT(6));\n\t\t\t\ttempval |= (VOLTAGE_V25 << 3);\n\t\t\t} else if (rtlhal->hw_type != HARDWARE_TYPE_RTL8192SE) {\n\t\t\t\ttempval &= 0x0F;\n\t\t\t\ttempval |= (VOLTAGE_V25 << 4);\n\t\t\t}\n\n\t\t\trtl_write_byte(rtlpriv,\n\t\t\t\t       rtlpriv->cfg->maps[EFUSE_TEST] + 3,\n\t\t\t\t       (tempval | 0x80));\n\t\t}\n\n\t\tif (rtlhal->hw_type == HARDWARE_TYPE_RTL8192SE) {\n\t\t\trtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CLK],\n\t\t\t\t       0x03);\n\t\t}\n\t} else {\n\t\tif (rtlhal->hw_type != HARDWARE_TYPE_RTL8192CE &&\n\t\t    rtlhal->hw_type != HARDWARE_TYPE_RTL8192DE)\n\t\t\trtl_write_byte(rtlpriv,\n\t\t\t\t       rtlpriv->cfg->maps[EFUSE_ACCESS], 0);\n\n\t\tif (write) {\n\t\t\ttempval = rtl_read_byte(rtlpriv,\n\t\t\t\t\t\trtlpriv->cfg->maps[EFUSE_TEST] +\n\t\t\t\t\t\t3);\n\t\t\trtl_write_byte(rtlpriv,\n\t\t\t\t       rtlpriv->cfg->maps[EFUSE_TEST] + 3,\n\t\t\t\t       (tempval & 0x7F));\n\t\t}\n\n\t\tif (rtlhal->hw_type == HARDWARE_TYPE_RTL8192SE) {\n\t\t\trtl_write_byte(rtlpriv, rtlpriv->cfg->maps[EFUSE_CLK],\n\t\t\t\t       0x02);\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(efuse_power_switch);\n\nstatic u16 efuse_get_current_size(struct ieee80211_hw *hw)\n{\n\tint continual = true;\n\tu16 efuse_addr = 0;\n\tu8 hworden;\n\tu8 efuse_data, word_cnts;\n\n\twhile (continual && efuse_one_byte_read(hw, efuse_addr, &efuse_data) &&\n\t       (efuse_addr < EFUSE_MAX_SIZE)) {\n\t\tif (efuse_data != 0xFF) {\n\t\t\thworden = efuse_data & 0x0F;\n\t\t\tword_cnts = efuse_calculate_word_cnts(hworden);\n\t\t\tefuse_addr = efuse_addr + (word_cnts * 2) + 1;\n\t\t} else {\n\t\t\tcontinual = false;\n\t\t}\n\t}\n\n\treturn efuse_addr;\n}\n\nstatic u8 efuse_calculate_word_cnts(u8 word_en)\n{\n\tu8 word_cnts = 0;\n\n\tif (!(word_en & BIT(0)))\n\t\tword_cnts++;\n\tif (!(word_en & BIT(1)))\n\t\tword_cnts++;\n\tif (!(word_en & BIT(2)))\n\t\tword_cnts++;\n\tif (!(word_en & BIT(3)))\n\t\tword_cnts++;\n\treturn word_cnts;\n}\n\nint rtl_get_hwinfo(struct ieee80211_hw *hw, struct rtl_priv *rtlpriv,\n\t\t   int max_size, u8 *hwinfo, int *params)\n{\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tstruct rtl_pci_priv *rtlpcipriv = rtl_pcipriv(hw);\n\tstruct device *dev = &rtlpcipriv->dev.pdev->dev;\n\tu16 eeprom_id;\n\tu16 i, usvalue;\n\n\tswitch (rtlefuse->epromtype) {\n\tcase EEPROM_BOOT_EFUSE:\n\t\trtl_efuse_shadow_map_update(hw);\n\t\tbreak;\n\n\tcase EEPROM_93C46:\n\t\tpr_err(\"RTL8XXX did not boot from eeprom, check it !!\\n\");\n\t\treturn 1;\n\n\tdefault:\n\t\tdev_warn(dev, \"no efuse data\\n\");\n\t\treturn 1;\n\t}\n\n\tmemcpy(hwinfo, &rtlefuse->efuse_map[EFUSE_INIT_MAP][0], max_size);\n\n\tRT_PRINT_DATA(rtlpriv, COMP_INIT, DBG_DMESG, \"MAP\",\n\t\t      hwinfo, max_size);\n\n\teeprom_id = *((u16 *)&hwinfo[0]);\n\tif (eeprom_id != params[0]) {\n\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_WARNING,\n\t\t\t\"EEPROM ID(%#x) is invalid!!\\n\", eeprom_id);\n\t\trtlefuse->autoload_failflag = true;\n\t} else {\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD, \"Autoload OK\\n\");\n\t\trtlefuse->autoload_failflag = false;\n\t}\n\n\tif (rtlefuse->autoload_failflag)\n\t\treturn 1;\n\n\trtlefuse->eeprom_vid = *(u16 *)&hwinfo[params[1]];\n\trtlefuse->eeprom_did = *(u16 *)&hwinfo[params[2]];\n\trtlefuse->eeprom_svid = *(u16 *)&hwinfo[params[3]];\n\trtlefuse->eeprom_smid = *(u16 *)&hwinfo[params[4]];\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\"EEPROMId = 0x%4x\\n\", eeprom_id);\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\"EEPROM VID = 0x%4x\\n\", rtlefuse->eeprom_vid);\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\"EEPROM DID = 0x%4x\\n\", rtlefuse->eeprom_did);\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\"EEPROM SVID = 0x%4x\\n\", rtlefuse->eeprom_svid);\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\"EEPROM SMID = 0x%4x\\n\", rtlefuse->eeprom_smid);\n\n\tfor (i = 0; i < 6; i += 2) {\n\t\tusvalue = *(u16 *)&hwinfo[params[5] + i];\n\t\t*((u16 *)(&rtlefuse->dev_addr[i])) = usvalue;\n\t}\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG, \"%pM\\n\", rtlefuse->dev_addr);\n\n\trtlefuse->eeprom_channelplan = *&hwinfo[params[6]];\n\trtlefuse->eeprom_version = *(u16 *)&hwinfo[params[7]];\n\trtlefuse->txpwr_fromeprom = true;\n\trtlefuse->eeprom_oemid = *&hwinfo[params[8]];\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\"EEPROM Customer ID: 0x%2x\\n\", rtlefuse->eeprom_oemid);\n\n\t \n\trtlefuse->channel_plan = params[9];\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(rtl_get_hwinfo);\n\nvoid rtl_fw_block_write(struct ieee80211_hw *hw, const u8 *buffer, u32 size)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 *pu4byteptr = (u8 *)buffer;\n\tu32 i;\n\n\tfor (i = 0; i < size; i++)\n\t\trtl_write_byte(rtlpriv, (START_ADDRESS + i), *(pu4byteptr + i));\n}\nEXPORT_SYMBOL_GPL(rtl_fw_block_write);\n\nvoid rtl_fw_page_write(struct ieee80211_hw *hw, u32 page, const u8 *buffer,\n\t\t       u32 size)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 value8;\n\tu8 u8page = (u8)(page & 0x07);\n\n\tvalue8 = (rtl_read_byte(rtlpriv, REG_MCUFWDL + 2) & 0xF8) | u8page;\n\n\trtl_write_byte(rtlpriv, (REG_MCUFWDL + 2), value8);\n\trtl_fw_block_write(hw, buffer, size);\n}\nEXPORT_SYMBOL_GPL(rtl_fw_page_write);\n\nvoid rtl_fill_dummy(u8 *pfwbuf, u32 *pfwlen)\n{\n\tu32 fwlen = *pfwlen;\n\tu8 remain = (u8)(fwlen % 4);\n\n\tremain = (remain == 0) ? 0 : (4 - remain);\n\n\twhile (remain > 0) {\n\t\tpfwbuf[fwlen] = 0;\n\t\tfwlen++;\n\t\tremain--;\n\t}\n\n\t*pfwlen = fwlen;\n}\nEXPORT_SYMBOL_GPL(rtl_fill_dummy);\n\nvoid rtl_efuse_ops_init(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtlpriv->efuse.efuse_ops = &efuse_ops;\n}\nEXPORT_SYMBOL_GPL(rtl_efuse_ops_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}