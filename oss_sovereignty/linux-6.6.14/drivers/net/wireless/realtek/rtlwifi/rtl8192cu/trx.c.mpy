{
  "module_name": "trx.c",
  "hash_id": "f5cb751769a0e5199e9af816463b98f985ec98dae2d901f2c634fdf6d8b96b95",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtlwifi/rtl8192cu/trx.c",
  "human_readable_source": "\n \n\n#include \"../wifi.h\"\n#include \"../usb.h\"\n#include \"../ps.h\"\n#include \"../base.h\"\n#include \"reg.h\"\n#include \"def.h\"\n#include \"phy.h\"\n#include \"rf.h\"\n#include \"dm.h\"\n#include \"mac.h\"\n#include \"trx.h\"\n#include \"../rtl8192c/fw_common.h\"\n\nstatic int configvertoutep(struct ieee80211_hw *hw)\n{\n\tu8 ep_cfg, txqsele;\n\tu8 ep_nums = 0;\n\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_usb_priv *usb_priv = rtl_usbpriv(hw);\n\tstruct rtl_usb *rtlusb = rtl_usbdev(usb_priv);\n\n\trtlusb->out_queue_sel = 0;\n\tep_cfg = rtl_read_byte(rtlpriv, REG_TEST_SIE_OPTIONAL);\n\tep_cfg = (ep_cfg & USB_TEST_EP_MASK) >> USB_TEST_EP_SHIFT;\n\tswitch (ep_cfg)\t{\n\tcase 0:\t\t \n\tcase 3:\n\t\trtlusb->out_queue_sel  = TX_SELE_HQ | TX_SELE_LQ;\n\t\tep_nums = 2;\n\t\tbreak;\n\tcase 1:\t \n\tcase 2:\t \n\t\ttxqsele = rtl_read_byte(rtlpriv, REG_TEST_USB_TXQS);\n\t\tif (txqsele & 0x0F)  \n\t\t\trtlusb->out_queue_sel =  TX_SELE_HQ;\n\t\telse if (txqsele&0xF0)  \n\t\t\trtlusb->out_queue_sel =  TX_SELE_LQ;\n\t\tep_nums = 1;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn (rtlusb->out_ep_nums == ep_nums) ? 0 : -EINVAL;\n}\n\nstatic int configvernoutep(struct ieee80211_hw *hw)\n{\n\tu8 ep_cfg;\n\tu8 ep_nums = 0;\n\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_usb_priv *usb_priv = rtl_usbpriv(hw);\n\tstruct rtl_usb *rtlusb = rtl_usbdev(usb_priv);\n\n\trtlusb->out_queue_sel = 0;\n\t \n\tep_cfg =  rtl_read_byte(rtlpriv, (REG_NORMAL_SIE_EP + 1));\n\tif (ep_cfg & USB_NORMAL_SIE_EP_MASK) {\n\t\trtlusb->out_queue_sel |= TX_SELE_HQ;\n\t\tep_nums++;\n\t}\n\tif ((ep_cfg >> USB_NORMAL_SIE_EP_SHIFT) & USB_NORMAL_SIE_EP_MASK) {\n\t\trtlusb->out_queue_sel |= TX_SELE_NQ;\n\t\tep_nums++;\n\t}\n\t \n\tep_cfg =  rtl_read_byte(rtlpriv, (REG_NORMAL_SIE_EP + 2));\n\tif (ep_cfg & USB_NORMAL_SIE_EP_MASK) {\n\t\trtlusb->out_queue_sel |= TX_SELE_LQ;\n\t\tep_nums++;\n\t}\n\treturn (rtlusb->out_ep_nums == ep_nums) ? 0 : -EINVAL;\n}\n\nstatic void twooutepmapping(struct ieee80211_hw *hw, bool is_chip8,\n\t\t\t     bool  bwificfg, struct rtl_ep_map *ep_map)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\tif (bwificfg) {  \n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG,\n\t\t\t\"USB Chip-B & WMM Setting.....\\n\");\n\t\tep_map->ep_mapping[RTL_TXQ_BE]\t= 2;\n\t\tep_map->ep_mapping[RTL_TXQ_BK]\t= 3;\n\t\tep_map->ep_mapping[RTL_TXQ_VI]\t= 3;\n\t\tep_map->ep_mapping[RTL_TXQ_VO] = 2;\n\t\tep_map->ep_mapping[RTL_TXQ_MGT] = 2;\n\t\tep_map->ep_mapping[RTL_TXQ_BCN] = 2;\n\t\tep_map->ep_mapping[RTL_TXQ_HI]\t= 2;\n\t} else {  \n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG,\n\t\t\t\"USB typical Setting.....\\n\");\n\t\tep_map->ep_mapping[RTL_TXQ_BE]\t= 3;\n\t\tep_map->ep_mapping[RTL_TXQ_BK]\t= 3;\n\t\tep_map->ep_mapping[RTL_TXQ_VI]\t= 2;\n\t\tep_map->ep_mapping[RTL_TXQ_VO]\t= 2;\n\t\tep_map->ep_mapping[RTL_TXQ_MGT] = 2;\n\t\tep_map->ep_mapping[RTL_TXQ_BCN] = 2;\n\t\tep_map->ep_mapping[RTL_TXQ_HI]\t= 2;\n\t}\n}\n\nstatic void threeoutepmapping(struct ieee80211_hw *hw, bool  bwificfg,\n\t\t\t       struct rtl_ep_map *ep_map)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\tif (bwificfg) {  \n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG,\n\t\t\t\"USB 3EP Setting for WMM.....\\n\");\n\t\tep_map->ep_mapping[RTL_TXQ_BE]\t= 5;\n\t\tep_map->ep_mapping[RTL_TXQ_BK]\t= 3;\n\t\tep_map->ep_mapping[RTL_TXQ_VI]\t= 3;\n\t\tep_map->ep_mapping[RTL_TXQ_VO]\t= 2;\n\t\tep_map->ep_mapping[RTL_TXQ_MGT] = 2;\n\t\tep_map->ep_mapping[RTL_TXQ_BCN] = 2;\n\t\tep_map->ep_mapping[RTL_TXQ_HI]\t= 2;\n\t} else {  \n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG,\n\t\t\t\"USB 3EP Setting for typical.....\\n\");\n\t\tep_map->ep_mapping[RTL_TXQ_BE]\t= 5;\n\t\tep_map->ep_mapping[RTL_TXQ_BK]\t= 5;\n\t\tep_map->ep_mapping[RTL_TXQ_VI]\t= 3;\n\t\tep_map->ep_mapping[RTL_TXQ_VO]\t= 2;\n\t\tep_map->ep_mapping[RTL_TXQ_MGT] = 2;\n\t\tep_map->ep_mapping[RTL_TXQ_BCN] = 2;\n\t\tep_map->ep_mapping[RTL_TXQ_HI]\t= 2;\n\t}\n}\n\nstatic void oneoutepmapping(struct ieee80211_hw *hw, struct rtl_ep_map *ep_map)\n{\n\tep_map->ep_mapping[RTL_TXQ_BE]\t= 2;\n\tep_map->ep_mapping[RTL_TXQ_BK]\t= 2;\n\tep_map->ep_mapping[RTL_TXQ_VI]\t= 2;\n\tep_map->ep_mapping[RTL_TXQ_VO] = 2;\n\tep_map->ep_mapping[RTL_TXQ_MGT] = 2;\n\tep_map->ep_mapping[RTL_TXQ_BCN] = 2;\n\tep_map->ep_mapping[RTL_TXQ_HI]\t= 2;\n}\n\nstatic int _out_ep_mapping(struct ieee80211_hw *hw)\n{\n\tint err = 0;\n\tbool ischipn, bwificfg = false;\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_usb_priv *usb_priv = rtl_usbpriv(hw);\n\tstruct rtl_usb *rtlusb = rtl_usbdev(usb_priv);\n\tstruct rtl_ep_map *ep_map = &(rtlusb->ep_map);\n\n\tischipn = IS_NORMAL_CHIP(rtlhal->version);\n\tswitch (rtlusb->out_ep_nums) {\n\tcase 2:\n\t\ttwooutepmapping(hw, ischipn, bwificfg, ep_map);\n\t\tbreak;\n\tcase 3:\n\t\t \n\t\tif (!ischipn) {\n\t\t\terr  =  -EINVAL;\n\t\t\tgoto err_out;\n\t\t}\n\t\tthreeoutepmapping(hw, ischipn, ep_map);\n\t\tbreak;\n\tcase 1:\n\t\toneoutepmapping(hw, ep_map);\n\t\tbreak;\n\tdefault:\n\t\terr  =  -EINVAL;\n\t\tbreak;\n\t}\nerr_out:\n\treturn err;\n\n}\n\n \nint  rtl8192cu_endpoint_mapping(struct ieee80211_hw *hw)\n{\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tint error = 0;\n\n\tif (likely(IS_NORMAL_CHIP(rtlhal->version)))\n\t\terror = configvernoutep(hw);\n\telse\n\t\terror = configvertoutep(hw);\n\tif (error)\n\t\tgoto err_out;\n\terror = _out_ep_mapping(hw);\n\tif (error)\n\t\tgoto err_out;\nerr_out:\n\treturn error;\n}\n\nu16 rtl8192cu_mq_to_hwq(__le16 fc, u16 mac80211_queue_index)\n{\n\tu16 hw_queue_index;\n\n\tif (unlikely(ieee80211_is_beacon(fc))) {\n\t\thw_queue_index = RTL_TXQ_BCN;\n\t\tgoto out;\n\t}\n\tif (ieee80211_is_mgmt(fc)) {\n\t\thw_queue_index = RTL_TXQ_MGT;\n\t\tgoto out;\n\t}\n\tswitch (mac80211_queue_index) {\n\tcase 0:\n\t\thw_queue_index = RTL_TXQ_VO;\n\t\tbreak;\n\tcase 1:\n\t\thw_queue_index = RTL_TXQ_VI;\n\t\tbreak;\n\tcase 2:\n\t\thw_queue_index = RTL_TXQ_BE;\n\t\tbreak;\n\tcase 3:\n\t\thw_queue_index = RTL_TXQ_BK;\n\t\tbreak;\n\tdefault:\n\t\thw_queue_index = RTL_TXQ_BE;\n\t\tWARN_ONCE(true, \"rtl8192cu: QSLT_BE queue, skb_queue:%d\\n\",\n\t\t\t  mac80211_queue_index);\n\t\tbreak;\n\t}\nout:\n\treturn hw_queue_index;\n}\n\nstatic enum rtl_desc_qsel _rtl8192cu_mq_to_descq(struct ieee80211_hw *hw,\n\t\t\t\t\t __le16 fc, u16 mac80211_queue_index)\n{\n\tenum rtl_desc_qsel qsel;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\tif (unlikely(ieee80211_is_beacon(fc))) {\n\t\tqsel = QSLT_BEACON;\n\t\tgoto out;\n\t}\n\tif (ieee80211_is_mgmt(fc)) {\n\t\tqsel = QSLT_MGNT;\n\t\tgoto out;\n\t}\n\tswitch (mac80211_queue_index) {\n\tcase 0:\t \n\t\tqsel = QSLT_VO;\n\t\trtl_dbg(rtlpriv, COMP_USB, DBG_DMESG,\n\t\t\t\"VO queue, set qsel = 0x%x\\n\", QSLT_VO);\n\t\tbreak;\n\tcase 1:\t \n\t\tqsel = QSLT_VI;\n\t\trtl_dbg(rtlpriv, COMP_USB, DBG_DMESG,\n\t\t\t\"VI queue, set qsel = 0x%x\\n\", QSLT_VI);\n\t\tbreak;\n\tcase 3:\t \n\t\tqsel = QSLT_BK;\n\t\trtl_dbg(rtlpriv, COMP_USB, DBG_DMESG,\n\t\t\t\"BK queue, set qsel = 0x%x\\n\", QSLT_BK);\n\t\tbreak;\n\tcase 2:\t \n\tdefault:\n\t\tqsel = QSLT_BE;\n\t\trtl_dbg(rtlpriv, COMP_USB, DBG_DMESG,\n\t\t\t\"BE queue, set qsel = 0x%x\\n\", QSLT_BE);\n\t\tbreak;\n\t}\nout:\n\treturn qsel;\n}\n\n \n\n \nbool rtl92cu_rx_query_desc(struct ieee80211_hw *hw,\n\t\t\t   struct rtl_stats *stats,\n\t\t\t   struct ieee80211_rx_status *rx_status,\n\t\t\t   u8 *pdesc8, struct sk_buff *skb)\n{\n\tstruct rx_fwinfo_92c *p_drvinfo;\n\tstruct rx_desc_92c *p_desc = (struct rx_desc_92c *)pdesc8;\n\t__le32 *pdesc = (__le32 *)pdesc8;\n\tu32 phystatus = get_rx_desc_phy_status(pdesc);\n\n\tstats->length = (u16)get_rx_desc_pkt_len(pdesc);\n\tstats->rx_drvinfo_size = (u8)get_rx_desc_drvinfo_size(pdesc) *\n\t\t\t\t RX_DRV_INFO_SIZE_UNIT;\n\tstats->rx_bufshift = (u8)(get_rx_desc_shift(pdesc) & 0x03);\n\tstats->icv = (u16)get_rx_desc_icv(pdesc);\n\tstats->crc = (u16)get_rx_desc_crc32(pdesc);\n\tstats->hwerror = (stats->crc | stats->icv);\n\tstats->decrypted = !get_rx_desc_swdec(pdesc);\n\tstats->rate = (u8)get_rx_desc_rx_mcs(pdesc);\n\tstats->shortpreamble = (u16)get_rx_desc_splcp(pdesc);\n\tstats->isampdu = (bool)(get_rx_desc_paggr(pdesc) == 1);\n\tstats->isfirst_ampdu = (bool)((get_rx_desc_paggr(pdesc) == 1) &&\n\t\t\t\t      (get_rx_desc_faggr(pdesc) == 1));\n\tstats->timestamp_low = get_rx_desc_tsfl(pdesc);\n\tstats->rx_is40mhzpacket = (bool)get_rx_desc_bw(pdesc);\n\tstats->is_ht = (bool)get_rx_desc_rx_ht(pdesc);\n\trx_status->freq = hw->conf.chandef.chan->center_freq;\n\trx_status->band = hw->conf.chandef.chan->band;\n\tif (get_rx_desc_crc32(pdesc))\n\t\trx_status->flag |= RX_FLAG_FAILED_FCS_CRC;\n\tif (!get_rx_desc_swdec(pdesc))\n\t\trx_status->flag |= RX_FLAG_DECRYPTED;\n\tif (get_rx_desc_bw(pdesc))\n\t\trx_status->bw = RATE_INFO_BW_40;\n\tif (get_rx_desc_rx_ht(pdesc))\n\t\trx_status->encoding = RX_ENC_HT;\n\trx_status->flag |= RX_FLAG_MACTIME_START;\n\tif (stats->decrypted)\n\t\trx_status->flag |= RX_FLAG_DECRYPTED;\n\trx_status->rate_idx = rtlwifi_rate_mapping(hw, stats->is_ht,\n\t\t\t\t\t\t   false, stats->rate);\n\trx_status->mactime = get_rx_desc_tsfl(pdesc);\n\tif (phystatus) {\n\t\tp_drvinfo = (struct rx_fwinfo_92c *)(skb->data +\n\t\t\t\t\t\t     stats->rx_bufshift);\n\t\trtl92c_translate_rx_signal_stuff(hw, skb, stats, p_desc,\n\t\t\t\t\t\t p_drvinfo);\n\t}\n\t \n\trx_status->signal = stats->recvsignalpower + 10;\n\treturn true;\n}\n\n#define RTL_RX_DRV_INFO_UNIT\t\t8\n\nstatic void _rtl_rx_process(struct ieee80211_hw *hw, struct sk_buff *skb)\n{\n\tstruct ieee80211_rx_status *rx_status =\n\t\t (struct ieee80211_rx_status *)IEEE80211_SKB_RXCB(skb);\n\tu32 skb_len, pkt_len, drvinfo_len;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\t__le32 *rxdesc;\n\tstruct rtl_stats stats = {\n\t\t.signal = 0,\n\t\t.rate = 0,\n\t};\n\tstruct rx_fwinfo_92c *p_drvinfo;\n\tbool bv;\n\t__le16 fc;\n\tstruct ieee80211_hdr *hdr;\n\n\tmemset(rx_status, 0, sizeof(*rx_status));\n\trxdesc\t= (__le32 *)skb->data;\n\tskb_len\t= skb->len;\n\tdrvinfo_len = (get_rx_desc_drvinfo_size(rxdesc) * RTL_RX_DRV_INFO_UNIT);\n\tpkt_len\t\t= get_rx_desc_pkt_len(rxdesc);\n\t \n\tWARN_ON(skb_len < (pkt_len + RTL_RX_DESC_SIZE + drvinfo_len));\n\tstats.length = (u16)get_rx_desc_pkt_len(rxdesc);\n\tstats.rx_drvinfo_size = (u8)get_rx_desc_drvinfo_size(rxdesc) *\n\t\t\t\tRX_DRV_INFO_SIZE_UNIT;\n\tstats.rx_bufshift = (u8)(get_rx_desc_shift(rxdesc) & 0x03);\n\tstats.icv = (u16)get_rx_desc_icv(rxdesc);\n\tstats.crc = (u16)get_rx_desc_crc32(rxdesc);\n\tstats.hwerror = (stats.crc | stats.icv);\n\tstats.decrypted = !get_rx_desc_swdec(rxdesc);\n\tstats.rate = (u8)get_rx_desc_rx_mcs(rxdesc);\n\tstats.shortpreamble = (u16)get_rx_desc_splcp(rxdesc);\n\tstats.isampdu = (bool)((get_rx_desc_paggr(rxdesc) == 1) &&\n\t\t\t       (get_rx_desc_faggr(rxdesc) == 1));\n\tstats.timestamp_low = get_rx_desc_tsfl(rxdesc);\n\tstats.rx_is40mhzpacket = (bool)get_rx_desc_bw(rxdesc);\n\tstats.is_ht = (bool)get_rx_desc_rx_ht(rxdesc);\n\t \n\t \n\trx_status->freq = hw->conf.chandef.chan->center_freq;\n\trx_status->band = hw->conf.chandef.chan->band;\n\tif (get_rx_desc_crc32(rxdesc))\n\t\trx_status->flag |= RX_FLAG_FAILED_FCS_CRC;\n\tif (!get_rx_desc_swdec(rxdesc))\n\t\trx_status->flag |= RX_FLAG_DECRYPTED;\n\tif (get_rx_desc_bw(rxdesc))\n\t\trx_status->bw = RATE_INFO_BW_40;\n\tif (get_rx_desc_rx_ht(rxdesc))\n\t\trx_status->encoding = RX_ENC_HT;\n\t \n\trx_status->rate_idx = rtlwifi_rate_mapping(hw, stats.is_ht,\n\t\t\t\t\t\t   false, stats.rate);\n\t \n\tif (get_rx_desc_phy_status(rxdesc)) {\n\t\tp_drvinfo = (struct rx_fwinfo_92c *)(rxdesc + RTL_RX_DESC_SIZE);\n\t\trtl92c_translate_rx_signal_stuff(hw, skb, &stats,\n\t\t\t\t (struct rx_desc_92c *)rxdesc, p_drvinfo);\n\t}\n\tskb_pull(skb, (drvinfo_len + RTL_RX_DESC_SIZE));\n\thdr = rtl_get_hdr(skb);\n\tfc = hdr->frame_control;\n\tbv = ieee80211_is_probe_resp(fc);\n\tif (bv)\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG,\n\t\t\t\"Got probe response frame\\n\");\n\tif (ieee80211_is_beacon(fc))\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG, \"Got beacon frame\\n\");\n\tif (ieee80211_is_data(fc))\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG, \"Got data frame\\n\");\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG,\n\t\t\"Fram: fc = 0x%X addr1 = 0x%02X:0x%02X:0x%02X:0x%02X:0x%02X:0x%02X\\n\",\n\t\tfc,\n\t\t(u32)hdr->addr1[0], (u32)hdr->addr1[1],\n\t\t(u32)hdr->addr1[2], (u32)hdr->addr1[3],\n\t\t(u32)hdr->addr1[4], (u32)hdr->addr1[5]);\n\tieee80211_rx(hw, skb);\n}\n\nvoid  rtl8192cu_rx_hdl(struct ieee80211_hw *hw, struct sk_buff * skb)\n{\n\t_rtl_rx_process(hw, skb);\n}\n\n \nvoid rtl8192c_tx_cleanup(struct ieee80211_hw *hw, struct sk_buff  *skb)\n{\n}\n\nint rtl8192c_tx_post_hdl(struct ieee80211_hw *hw, struct urb *urb,\n\t\t\t struct sk_buff *skb)\n{\n\treturn 0;\n}\n\nstruct sk_buff *rtl8192c_tx_aggregate_hdl(struct ieee80211_hw *hw,\n\t\t\t\t\t   struct sk_buff_head *list)\n{\n\treturn skb_dequeue(list);\n}\n\n \n\nstatic void _rtl_fill_usb_tx_desc(__le32 *txdesc)\n{\n\tset_tx_desc_own(txdesc, 1);\n\tset_tx_desc_last_seg(txdesc, 1);\n\tset_tx_desc_first_seg(txdesc, 1);\n}\n\n \nstatic void _rtl_tx_desc_checksum(__le32 *txdesc)\n{\n\t__le16 *ptr = (__le16 *)txdesc;\n\tu16\tchecksum = 0;\n\tu32 index;\n\n\t \n\tset_tx_desc_tx_desc_checksum(txdesc, 0);\n\tfor (index = 0; index < 16; index++)\n\t\tchecksum = checksum ^ le16_to_cpu(*(ptr + index));\n\tset_tx_desc_tx_desc_checksum(txdesc, checksum);\n}\n\nvoid rtl92cu_tx_fill_desc(struct ieee80211_hw *hw,\n\t\t\t  struct ieee80211_hdr *hdr, u8 *pdesc_tx,\n\t\t\t  u8 *pbd_desc_tx, struct ieee80211_tx_info *info,\n\t\t\t  struct ieee80211_sta *sta,\n\t\t\t  struct sk_buff *skb,\n\t\t\t  u8 queue_index,\n\t\t\t  struct rtl_tcb_desc *tcb_desc)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tbool defaultadapter = true;\n\tu8 *qc = ieee80211_get_qos_ctl(hdr);\n\tu8 tid = qc[0] & IEEE80211_QOS_CTL_TID_MASK;\n\tu16 seq_number;\n\t__le16 fc = hdr->frame_control;\n\tu8 rate_flag = info->control.rates[0].flags;\n\tu16 pktlen = skb->len;\n\tenum rtl_desc_qsel fw_qsel = _rtl8192cu_mq_to_descq(hw, fc,\n\t\t\t\t\t\tskb_get_queue_mapping(skb));\n\tu8 *txdesc8;\n\t__le32 *txdesc;\n\n\tseq_number = (le16_to_cpu(hdr->seq_ctrl) & IEEE80211_SCTL_SEQ) >> 4;\n\trtl_get_tcb_desc(hw, info, sta, skb, tcb_desc);\n\ttxdesc8 = skb_push(skb, RTL_TX_HEADER_SIZE);\n\ttxdesc = (__le32 *)txdesc8;\n\tmemset(txdesc, 0, RTL_TX_HEADER_SIZE);\n\tset_tx_desc_pkt_size(txdesc, pktlen);\n\tset_tx_desc_linip(txdesc, 0);\n\tset_tx_desc_pkt_offset(txdesc, RTL_DUMMY_OFFSET);\n\tset_tx_desc_offset(txdesc, RTL_TX_HEADER_SIZE);\n\tset_tx_desc_tx_rate(txdesc, tcb_desc->hw_rate);\n\tif (tcb_desc->use_shortgi || tcb_desc->use_shortpreamble)\n\t\tset_tx_desc_data_shortgi(txdesc, 1);\n\tif (mac->tids[tid].agg.agg_state == RTL_AGG_ON &&\n\t\t    info->flags & IEEE80211_TX_CTL_AMPDU) {\n\t\tset_tx_desc_agg_enable(txdesc, 1);\n\t\tset_tx_desc_max_agg_num(txdesc, 0x14);\n\t} else {\n\t\tset_tx_desc_agg_break(txdesc, 1);\n\t}\n\tset_tx_desc_seq(txdesc, seq_number);\n\tset_tx_desc_rts_enable(txdesc,\n\t\t\t       ((tcb_desc->rts_enable &&\n\t\t\t\t!tcb_desc->cts_enable) ? 1 : 0));\n\tset_tx_desc_hw_rts_enable(txdesc,\n\t\t\t\t  ((tcb_desc->rts_enable ||\n\t\t\t\t   tcb_desc->cts_enable) ? 1 : 0));\n\tset_tx_desc_cts2self(txdesc, ((tcb_desc->cts_enable) ? 1 : 0));\n\tset_tx_desc_rts_stbc(txdesc, ((tcb_desc->rts_stbc) ? 1 : 0));\n\tset_tx_desc_rts_rate(txdesc, tcb_desc->rts_rate);\n\tset_tx_desc_rts_bw(txdesc, 0);\n\tset_tx_desc_rts_sc(txdesc, tcb_desc->rts_sc);\n\tset_tx_desc_rts_short(txdesc,\n\t\t\t      ((tcb_desc->rts_rate <= DESC_RATE54M) ?\n\t\t\t       (tcb_desc->rts_use_shortpreamble ? 1 : 0)\n\t\t\t       : (tcb_desc->rts_use_shortgi ? 1 : 0)));\n\tif (mac->bw_40) {\n\t\tif (rate_flag & IEEE80211_TX_RC_DUP_DATA) {\n\t\t\tset_tx_desc_data_bw(txdesc, 1);\n\t\t\tset_tx_desc_data_sc(txdesc, 3);\n\t\t} else if(rate_flag & IEEE80211_TX_RC_40_MHZ_WIDTH){\n\t\t\tset_tx_desc_data_bw(txdesc, 1);\n\t\t\tset_tx_desc_data_sc(txdesc, mac->cur_40_prime_sc);\n\t\t} else {\n\t\t\tset_tx_desc_data_bw(txdesc, 0);\n\t\t\tset_tx_desc_data_sc(txdesc, 0);\n\t\t}\n\t} else {\n\t\tset_tx_desc_data_bw(txdesc, 0);\n\t\tset_tx_desc_data_sc(txdesc, 0);\n\t}\n\trcu_read_lock();\n\tsta = ieee80211_find_sta(mac->vif, mac->bssid);\n\tif (sta) {\n\t\tu8 ampdu_density = sta->deflink.ht_cap.ampdu_density;\n\n\t\tset_tx_desc_ampdu_density(txdesc, ampdu_density);\n\t}\n\trcu_read_unlock();\n\tif (info->control.hw_key) {\n\t\tstruct ieee80211_key_conf *keyconf = info->control.hw_key;\n\n\t\tswitch (keyconf->cipher) {\n\t\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\t\tset_tx_desc_sec_type(txdesc, 0x1);\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\t\tset_tx_desc_sec_type(txdesc, 0x3);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tset_tx_desc_sec_type(txdesc, 0x0);\n\t\t\tbreak;\n\t\t}\n\t}\n\tset_tx_desc_pkt_id(txdesc, 0);\n\tset_tx_desc_queue_sel(txdesc, fw_qsel);\n\tset_tx_desc_data_rate_fb_limit(txdesc, 0x1F);\n\tset_tx_desc_rts_rate_fb_limit(txdesc, 0xF);\n\tset_tx_desc_disable_fb(txdesc, 0);\n\tset_tx_desc_use_rate(txdesc, tcb_desc->use_driver_rate ? 1 : 0);\n\tif (ieee80211_is_data_qos(fc)) {\n\t\tif (mac->rdg_en) {\n\t\t\trtl_dbg(rtlpriv, COMP_SEND, DBG_TRACE,\n\t\t\t\t\"Enable RDG function\\n\");\n\t\t\tset_tx_desc_rdg_enable(txdesc, 1);\n\t\t\tset_tx_desc_htc(txdesc, 1);\n\t\t}\n\t}\n\tif (rtlpriv->dm.useramask) {\n\t\tset_tx_desc_rate_id(txdesc, tcb_desc->ratr_index);\n\t\tset_tx_desc_macid(txdesc, tcb_desc->mac_id);\n\t} else {\n\t\tset_tx_desc_rate_id(txdesc, 0xC + tcb_desc->ratr_index);\n\t\tset_tx_desc_macid(txdesc, tcb_desc->ratr_index);\n\t}\n\tif ((!ieee80211_is_data_qos(fc)) && ppsc->leisure_ps &&\n\t      ppsc->fwctrl_lps) {\n\t\tset_tx_desc_hwseq_en(txdesc, 1);\n\t\tset_tx_desc_pkt_id(txdesc, 8);\n\t\tif (!defaultadapter)\n\t\t\tset_tx_desc_qos(txdesc, 1);\n\t}\n\tif (ieee80211_has_morefrags(fc))\n\t\tset_tx_desc_more_frag(txdesc, 1);\n\tif (is_multicast_ether_addr(ieee80211_get_DA(hdr)) ||\n\t    is_broadcast_ether_addr(ieee80211_get_DA(hdr)))\n\t\tset_tx_desc_bmc(txdesc, 1);\n\t_rtl_fill_usb_tx_desc(txdesc);\n\t_rtl_tx_desc_checksum(txdesc);\n\trtl_dbg(rtlpriv, COMP_SEND, DBG_TRACE, \"==>\\n\");\n}\n\nvoid rtl92cu_fill_fake_txdesc(struct ieee80211_hw *hw, u8 *pdesc8,\n\t\t\t      u32 buffer_len, bool is_pspoll)\n{\n\t__le32 *pdesc = (__le32 *)pdesc8;\n\n\t \n\tmemset(pdesc, 0, RTL_TX_HEADER_SIZE);\n\tset_tx_desc_first_seg(pdesc, 1);  \n\tset_tx_desc_last_seg(pdesc, 1);  \n\tset_tx_desc_offset(pdesc, RTL_TX_HEADER_SIZE);  \n\tset_tx_desc_pkt_size(pdesc, buffer_len);  \n\tset_tx_desc_queue_sel(pdesc, QSLT_MGNT);  \n\t \n\tif (is_pspoll) {\n\t\tset_tx_desc_nav_use_hdr(pdesc, 1);\n\t} else {\n\t\tset_tx_desc_hwseq_en(pdesc, 1);  \n\t\tset_tx_desc_pkt_id(pdesc, BIT(3));  \n\t}\n\tset_tx_desc_use_rate(pdesc, 1);  \n\tset_tx_desc_own(pdesc, 1);\n\tset_tx_desc_tx_rate(pdesc, DESC_RATE1M);\n\t_rtl_tx_desc_checksum(pdesc);\n}\n\nvoid rtl92cu_tx_fill_cmddesc(struct ieee80211_hw *hw,\n\t\t\t     u8 *pdesc8, bool firstseg,\n\t\t\t     bool lastseg, struct sk_buff *skb)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 fw_queue = QSLT_BEACON;\n\tstruct ieee80211_hdr *hdr = rtl_get_hdr(skb);\n\t__le16 fc = hdr->frame_control;\n\t__le32 *pdesc = (__le32 *)pdesc8;\n\n\tmemset((void *)pdesc, 0, RTL_TX_HEADER_SIZE);\n\tif (firstseg)\n\t\tset_tx_desc_offset(pdesc, RTL_TX_HEADER_SIZE);\n\tset_tx_desc_tx_rate(pdesc, DESC_RATE1M);\n\tset_tx_desc_seq(pdesc, 0);\n\tset_tx_desc_linip(pdesc, 0);\n\tset_tx_desc_queue_sel(pdesc, fw_queue);\n\tset_tx_desc_first_seg(pdesc, 1);\n\tset_tx_desc_last_seg(pdesc, 1);\n\tset_tx_desc_rate_id(pdesc, 7);\n\tset_tx_desc_macid(pdesc, 0);\n\tset_tx_desc_own(pdesc, 1);\n\tset_tx_desc_pkt_size(pdesc, (u16)skb->len);\n\tset_tx_desc_first_seg(pdesc, 1);\n\tset_tx_desc_last_seg(pdesc, 1);\n\tset_tx_desc_offset(pdesc, 0x20);\n\tset_tx_desc_use_rate(pdesc, 1);\n\tif (!ieee80211_is_data_qos(fc)) {\n\t\tset_tx_desc_hwseq_en(pdesc, 1);\n\t\tset_tx_desc_pkt_id(pdesc, 8);\n\t}\n\tRT_PRINT_DATA(rtlpriv, COMP_CMD, DBG_LOUD, \"H2C Tx Cmd Content\",\n\t\t      pdesc, RTL_TX_DESC_SIZE);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}