{
  "module_name": "mac.c",
  "hash_id": "cfd56ddcac39880d64d65e110e1a06b6c8f319e50141927393bd6847fbd3900b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtlwifi/rtl8192cu/mac.c",
  "human_readable_source": "\n \n\n#include \"../wifi.h\"\n#include \"../pci.h\"\n#include \"../usb.h\"\n#include \"../ps.h\"\n#include \"../cam.h\"\n#include \"../stats.h\"\n#include \"reg.h\"\n#include \"def.h\"\n#include \"phy.h\"\n#include \"rf.h\"\n#include \"dm.h\"\n#include \"mac.h\"\n#include \"trx.h\"\n#include \"../rtl8192c/fw_common.h\"\n\n#include <linux/module.h>\n\n \n\n#define LINK_Q\tui_link_quality\n#define RX_EVM\trx_evm_percentage\n#define RX_SIGQ\trx_mimo_sig_qual\n\nvoid rtl92c_read_chip_version(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\n\tenum version_8192c chip_version = VERSION_UNKNOWN;\n\tconst char *versionid;\n\tu32 value32;\n\n\tvalue32 = rtl_read_dword(rtlpriv, REG_SYS_CFG);\n\tif (value32 & TRP_VAUX_EN) {\n\t\tchip_version = (value32 & TYPE_ID) ? VERSION_TEST_CHIP_92C :\n\t\t\t       VERSION_TEST_CHIP_88C;\n\t} else {\n\t\t \n\t\tchip_version = NORMAL_CHIP;\n\t\tchip_version |= ((value32 & TYPE_ID) ? CHIP_92C : 0);\n\t\tchip_version |= ((value32 & VENDOR_ID) ? CHIP_VENDOR_UMC : 0);\n\t\tif (IS_VENDOR_UMC(chip_version))\n\t\t\tchip_version |= ((value32 & CHIP_VER_RTL_MASK) ?\n\t\t\t\t\t CHIP_VENDOR_UMC_B_CUT : 0);\n\t\tif (IS_92C_SERIAL(chip_version)) {\n\t\t\tvalue32 = rtl_read_dword(rtlpriv, REG_HPON_FSM);\n\t\t\tchip_version |= ((CHIP_BONDING_IDENTIFIER(value32) ==\n\t\t\t\t CHIP_BONDING_92C_1T2R) ? CHIP_92C_1T2R : 0);\n\t\t}\n\t}\n\trtlhal->version  = (enum version_8192c)chip_version;\n\tpr_info(\"Chip version 0x%x\\n\", chip_version);\n\tswitch (rtlhal->version) {\n\tcase VERSION_NORMAL_TSMC_CHIP_92C_1T2R:\n\t\tversionid = \"NORMAL_B_CHIP_92C\";\n\t\tbreak;\n\tcase VERSION_NORMAL_TSMC_CHIP_92C:\n\t\tversionid = \"NORMAL_TSMC_CHIP_92C\";\n\t\tbreak;\n\tcase VERSION_NORMAL_TSMC_CHIP_88C:\n\t\tversionid = \"NORMAL_TSMC_CHIP_88C\";\n\t\tbreak;\n\tcase VERSION_NORMAL_UMC_CHIP_92C_1T2R_A_CUT:\n\t\tversionid = \"NORMAL_UMC_CHIP_i92C_1T2R_A_CUT\";\n\t\tbreak;\n\tcase VERSION_NORMAL_UMC_CHIP_92C_A_CUT:\n\t\tversionid = \"NORMAL_UMC_CHIP_92C_A_CUT\";\n\t\tbreak;\n\tcase VERSION_NORMAL_UMC_CHIP_88C_A_CUT:\n\t\tversionid = \"NORMAL_UMC_CHIP_88C_A_CUT\";\n\t\tbreak;\n\tcase VERSION_NORMAL_UMC_CHIP_92C_1T2R_B_CUT:\n\t\tversionid = \"NORMAL_UMC_CHIP_92C_1T2R_B_CUT\";\n\t\tbreak;\n\tcase VERSION_NORMAL_UMC_CHIP_92C_B_CUT:\n\t\tversionid = \"NORMAL_UMC_CHIP_92C_B_CUT\";\n\t\tbreak;\n\tcase VERSION_NORMAL_UMC_CHIP_88C_B_CUT:\n\t\tversionid = \"NORMAL_UMC_CHIP_88C_B_CUT\";\n\t\tbreak;\n\tcase VERSION_TEST_CHIP_92C:\n\t\tversionid = \"TEST_CHIP_92C\";\n\t\tbreak;\n\tcase VERSION_TEST_CHIP_88C:\n\t\tversionid = \"TEST_CHIP_88C\";\n\t\tbreak;\n\tdefault:\n\t\tversionid = \"UNKNOWN\";\n\t\tbreak;\n\t}\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\"Chip Version ID: %s\\n\", versionid);\n\n\tif (IS_92C_SERIAL(rtlhal->version))\n\t\trtlphy->rf_type =\n\t\t\t (IS_92C_1T2R(rtlhal->version)) ? RF_1T2R : RF_2T2R;\n\telse\n\t\trtlphy->rf_type = RF_1T1R;\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\"Chip RF Type: %s\\n\",\n\t\trtlphy->rf_type == RF_2T2R ? \"RF_2T2R\" : \"RF_1T1R\");\n\tif (get_rf_type(rtlphy) == RF_1T1R)\n\t\trtlpriv->dm.rfpath_rxenable[0] = true;\n\telse\n\t\trtlpriv->dm.rfpath_rxenable[0] =\n\t\t    rtlpriv->dm.rfpath_rxenable[1] = true;\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD, \"VersionID = 0x%4x\\n\",\n\t\trtlhal->version);\n}\n\n \nbool rtl92c_llt_write(struct ieee80211_hw *hw, u32 address, u32 data)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tbool status = true;\n\tlong count = 0;\n\tu32 value = _LLT_INIT_ADDR(address) |\n\t    _LLT_INIT_DATA(data) | _LLT_OP(_LLT_WRITE_ACCESS);\n\n\trtl_write_dword(rtlpriv, REG_LLT_INIT, value);\n\tdo {\n\t\tvalue = rtl_read_dword(rtlpriv, REG_LLT_INIT);\n\t\tif (_LLT_NO_ACTIVE == _LLT_OP_VALUE(value))\n\t\t\tbreak;\n\t\tif (count > POLLING_LLT_THRESHOLD) {\n\t\t\tpr_err(\"Failed to polling write LLT done at address %d! _LLT_OP_VALUE(%x)\\n\",\n\t\t\t       address, _LLT_OP_VALUE(value));\n\t\t\tstatus = false;\n\t\t\tbreak;\n\t\t}\n\t} while (++count);\n\treturn status;\n}\n\n \nbool rtl92c_init_llt_table(struct ieee80211_hw *hw, u32 boundary)\n{\n\tbool rst = true;\n\tu32\ti;\n\n\tfor (i = 0; i < (boundary - 1); i++) {\n\t\trst = rtl92c_llt_write(hw, i , i + 1);\n\t\tif (!rst) {\n\t\t\tpr_err(\"===> %s #1 fail\\n\", __func__);\n\t\t\treturn rst;\n\t\t}\n\t}\n\t \n\trst = rtl92c_llt_write(hw, (boundary - 1), 0xFF);\n\tif (!rst) {\n\t\tpr_err(\"===> %s #2 fail\\n\", __func__);\n\t\treturn rst;\n\t}\n\t \n\tfor (i = boundary; i < LLT_LAST_ENTRY_OF_TX_PKT_BUFFER; i++) {\n\t\trst = rtl92c_llt_write(hw, i, (i + 1));\n\t\tif (!rst) {\n\t\t\tpr_err(\"===> %s #3 fail\\n\", __func__);\n\t\t\treturn rst;\n\t\t}\n\t}\n\t \n\trst = rtl92c_llt_write(hw, LLT_LAST_ENTRY_OF_TX_PKT_BUFFER, boundary);\n\tif (!rst) {\n\t\tpr_err(\"===> %s #4 fail\\n\", __func__);\n\t\treturn rst;\n\t}\n\treturn rst;\n}\n\nvoid rtl92c_set_key(struct ieee80211_hw *hw, u32 key_index,\n\t\t     u8 *p_macaddr, bool is_group, u8 enc_algo,\n\t\t     bool is_wepkey, bool clear_all)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tu8 *macaddr = p_macaddr;\n\tu32 entry_id = 0;\n\tbool is_pairwise = false;\n\tstatic u8 cam_const_addr[4][6] = {\n\t\t{0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n\t\t{0x00, 0x00, 0x00, 0x00, 0x00, 0x01},\n\t\t{0x00, 0x00, 0x00, 0x00, 0x00, 0x02},\n\t\t{0x00, 0x00, 0x00, 0x00, 0x00, 0x03}\n\t};\n\tstatic u8 cam_const_broad[] = {\n\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff\n\t};\n\n\tif (clear_all) {\n\t\tu8 idx = 0;\n\t\tu8 cam_offset = 0;\n\t\tu8 clear_number = 5;\n\n\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_DMESG, \"clear_all\\n\");\n\t\tfor (idx = 0; idx < clear_number; idx++) {\n\t\t\trtl_cam_mark_invalid(hw, cam_offset + idx);\n\t\t\trtl_cam_empty_entry(hw, cam_offset + idx);\n\t\t\tif (idx < 5) {\n\t\t\t\tmemset(rtlpriv->sec.key_buf[idx], 0,\n\t\t\t\t       MAX_KEY_LEN);\n\t\t\t\trtlpriv->sec.key_len[idx] = 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tswitch (enc_algo) {\n\t\tcase WEP40_ENCRYPTION:\n\t\t\tenc_algo = CAM_WEP40;\n\t\t\tbreak;\n\t\tcase WEP104_ENCRYPTION:\n\t\t\tenc_algo = CAM_WEP104;\n\t\t\tbreak;\n\t\tcase TKIP_ENCRYPTION:\n\t\t\tenc_algo = CAM_TKIP;\n\t\t\tbreak;\n\t\tcase AESCCMP_ENCRYPTION:\n\t\t\tenc_algo = CAM_AES;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"illegal switch case\\n\");\n\t\t\tenc_algo = CAM_TKIP;\n\t\t\tbreak;\n\t\t}\n\t\tif (is_wepkey || rtlpriv->sec.use_defaultkey) {\n\t\t\tmacaddr = cam_const_addr[key_index];\n\t\t\tentry_id = key_index;\n\t\t} else {\n\t\t\tif (is_group) {\n\t\t\t\tmacaddr = cam_const_broad;\n\t\t\t\tentry_id = key_index;\n\t\t\t} else {\n\t\t\t\tif (mac->opmode == NL80211_IFTYPE_AP ||\n\t\t\t\t    mac->opmode == NL80211_IFTYPE_MESH_POINT) {\n\t\t\t\t\tentry_id = rtl_cam_get_free_entry(hw,\n\t\t\t\t\t\t\t\t p_macaddr);\n\t\t\t\t\tif (entry_id >=  TOTAL_CAM_ENTRY) {\n\t\t\t\t\t\tpr_err(\"Can not find free hw security cam entry\\n\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tentry_id = CAM_PAIRWISE_KEY_POSITION;\n\t\t\t\t}\n\n\t\t\t\tkey_index = PAIRWISE_KEYIDX;\n\t\t\t\tis_pairwise = true;\n\t\t\t}\n\t\t}\n\t\tif (rtlpriv->sec.key_len[key_index] == 0) {\n\t\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_DMESG,\n\t\t\t\t\"delete one entry\\n\");\n\t\t\tif (mac->opmode == NL80211_IFTYPE_AP ||\n\t\t\t    mac->opmode == NL80211_IFTYPE_MESH_POINT)\n\t\t\t\trtl_cam_del_entry(hw, p_macaddr);\n\t\t\trtl_cam_delete_one_entry(hw, p_macaddr, entry_id);\n\t\t} else {\n\t\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_LOUD,\n\t\t\t\t\"The insert KEY length is %d\\n\",\n\t\t\t\t rtlpriv->sec.key_len[PAIRWISE_KEYIDX]);\n\t\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_LOUD,\n\t\t\t\t\"The insert KEY is %x %x\\n\",\n\t\t\t\trtlpriv->sec.key_buf[0][0],\n\t\t\t\trtlpriv->sec.key_buf[0][1]);\n\t\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_DMESG,\n\t\t\t\t\"add one entry\\n\");\n\t\t\tif (is_pairwise) {\n\t\t\t\tRT_PRINT_DATA(rtlpriv, COMP_SEC, DBG_LOUD,\n\t\t\t\t\t      \"Pairwise Key content\",\n\t\t\t\t\t      rtlpriv->sec.pairwise_key,\n\t\t\t\t\t      rtlpriv->sec.\n\t\t\t\t\t      key_len[PAIRWISE_KEYIDX]);\n\t\t\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_DMESG,\n\t\t\t\t\t\"set Pairwise key\\n\");\n\n\t\t\t\trtl_cam_add_one_entry(hw, macaddr, key_index,\n\t\t\t\t\t\tentry_id, enc_algo,\n\t\t\t\t\t\tCAM_CONFIG_NO_USEDK,\n\t\t\t\t\t\trtlpriv->sec.\n\t\t\t\t\t\tkey_buf[key_index]);\n\t\t\t} else {\n\t\t\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_DMESG,\n\t\t\t\t\t\"set group key\\n\");\n\t\t\t\tif (mac->opmode == NL80211_IFTYPE_ADHOC) {\n\t\t\t\t\trtl_cam_add_one_entry(hw,\n\t\t\t\t\t\trtlefuse->dev_addr,\n\t\t\t\t\t\tPAIRWISE_KEYIDX,\n\t\t\t\t\t\tCAM_PAIRWISE_KEY_POSITION,\n\t\t\t\t\t\tenc_algo,\n\t\t\t\t\t\tCAM_CONFIG_NO_USEDK,\n\t\t\t\t\t\trtlpriv->sec.key_buf\n\t\t\t\t\t\t[entry_id]);\n\t\t\t\t}\n\t\t\t\trtl_cam_add_one_entry(hw, macaddr, key_index,\n\t\t\t\t\t\tentry_id, enc_algo,\n\t\t\t\t\t\tCAM_CONFIG_NO_USEDK,\n\t\t\t\t\t\trtlpriv->sec.key_buf[entry_id]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nu32 rtl92c_get_txdma_status(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\treturn rtl_read_dword(rtlpriv, REG_TXDMA_STATUS);\n}\n\nvoid rtl92c_enable_interrupt(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tstruct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));\n\n\tif (IS_HARDWARE_TYPE_8192CE(rtlpriv)) {\n\t\trtl_write_dword(rtlpriv, REG_HIMR, rtlpci->irq_mask[0] &\n\t\t\t\t0xFFFFFFFF);\n\t\trtl_write_dword(rtlpriv, REG_HIMRE, rtlpci->irq_mask[1] &\n\t\t\t\t0xFFFFFFFF);\n\t} else {\n\t\trtl_write_dword(rtlpriv, REG_HIMR, rtlusb->irq_mask[0] &\n\t\t\t\t0xFFFFFFFF);\n\t\trtl_write_dword(rtlpriv, REG_HIMRE, rtlusb->irq_mask[1] &\n\t\t\t\t0xFFFFFFFF);\n\t}\n}\n\nvoid rtl92c_init_interrupt(struct ieee80211_hw *hw)\n{\n\t rtl92c_enable_interrupt(hw);\n}\n\nvoid rtl92c_disable_interrupt(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtl_write_dword(rtlpriv, REG_HIMR, IMR8190_DISABLED);\n\trtl_write_dword(rtlpriv, REG_HIMRE, IMR8190_DISABLED);\n}\n\nvoid rtl92c_set_qos(struct ieee80211_hw *hw, int aci)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtl92c_dm_init_edca_turbo(hw);\n\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_AC_PARAM, (u8 *)&aci);\n}\n\nvoid rtl92c_init_driver_info_size(struct ieee80211_hw *hw, u8 size)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtl_write_byte(rtlpriv, REG_RX_DRVINFO_SZ, size);\n}\n\nint rtl92c_set_network_type(struct ieee80211_hw *hw, enum nl80211_iftype type)\n{\n\tu8 value;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\tswitch (type) {\n\tcase NL80211_IFTYPE_UNSPECIFIED:\n\t\tvalue = NT_NO_LINK;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG,\n\t\t\t\"Set Network type to NO LINK!\\n\");\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tvalue = NT_LINK_AD_HOC;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG,\n\t\t\t\"Set Network type to Ad Hoc!\\n\");\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tvalue = NT_LINK_AP;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG,\n\t\t\t\"Set Network type to STA!\\n\");\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\t\tvalue = NT_AS_AP;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG,\n\t\t\t\"Set Network type to AP!\\n\");\n\t\tbreak;\n\tdefault:\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG,\n\t\t\t\"Network type %d not supported!\\n\", type);\n\t\treturn -EOPNOTSUPP;\n\t}\n\trtl_write_byte(rtlpriv, MSR, value);\n\treturn 0;\n}\n\nvoid rtl92c_init_network_type(struct ieee80211_hw *hw)\n{\n\trtl92c_set_network_type(hw, NL80211_IFTYPE_UNSPECIFIED);\n}\n\nvoid rtl92c_init_adaptive_ctrl(struct ieee80211_hw *hw)\n{\n\tu16\tvalue16;\n\tu32\tvalue32;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\t \n\tvalue32 = rtl_read_dword(rtlpriv, REG_RRSR);\n\tvalue32 &= ~RATE_BITMAP_ALL;\n\tvalue32 |= RATE_RRSR_CCK_ONLY_1M;\n\trtl_write_dword(rtlpriv, REG_RRSR, value32);\n\t \n\tvalue16 = _SPEC_SIFS_CCK(0x10) | _SPEC_SIFS_OFDM(0x10);\n\trtl_write_word(rtlpriv,  REG_SPEC_SIFS, value16);\n\t \n\tvalue16 = _LRL(0x30) | _SRL(0x30);\n\trtl_write_dword(rtlpriv,  REG_RL, value16);\n}\n\nvoid rtl92c_init_rate_fallback(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\t \n\trtl_write_dword(rtlpriv,  REG_DARFRC, 0x00000000);\n\trtl_write_dword(rtlpriv,  REG_DARFRC+4, 0x10080404);\n\trtl_write_dword(rtlpriv,  REG_RARFRC, 0x04030201);\n\trtl_write_dword(rtlpriv,  REG_RARFRC+4, 0x08070605);\n}\n\nstatic void rtl92c_set_cck_sifs(struct ieee80211_hw *hw, u8 trx_sifs,\n\t\t\t\tu8 ctx_sifs)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtl_write_byte(rtlpriv, REG_SIFS_CCK, trx_sifs);\n\trtl_write_byte(rtlpriv, (REG_SIFS_CCK + 1), ctx_sifs);\n}\n\nstatic void rtl92c_set_ofdm_sifs(struct ieee80211_hw *hw, u8 trx_sifs,\n\t\t\t\t u8 ctx_sifs)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtl_write_byte(rtlpriv, REG_SIFS_OFDM, trx_sifs);\n\trtl_write_byte(rtlpriv, (REG_SIFS_OFDM + 1), ctx_sifs);\n}\n\nvoid rtl92c_init_edca_param(struct ieee80211_hw *hw,\n\t\t\t    u16 queue, u16 txop, u8 cw_min, u8 cw_max, u8 aifs)\n{\n\t \n\tu32 value;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\tvalue = (u32)aifs;\n\tvalue |= ((u32)cw_min & 0xF) << 8;\n\tvalue |= ((u32)cw_max & 0xF) << 12;\n\tvalue |= (u32)txop << 16;\n\t \n\trtl_write_dword(rtlpriv, (REG_EDCA_VO_PARAM + (queue * 4)), value);\n}\n\nvoid rtl92c_init_edca(struct ieee80211_hw *hw)\n{\n\tu16 value16;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\t \n\tvalue16 = rtl_read_word(rtlpriv, REG_RD_CTRL);\n\tvalue16 |= DIS_EDCA_CNT_DWN;\n\trtl_write_word(rtlpriv, REG_RD_CTRL, value16);\n\t \n\trtl92c_set_cck_sifs(hw, 0xa, 0xa);\n\trtl92c_set_ofdm_sifs(hw, 0xe, 0xe);\n\t \n\trtl_write_word(rtlpriv, REG_SIFS_CCK, 0x0a0a);\n\trtl_write_word(rtlpriv, REG_SIFS_OFDM, 0x1010);\n\trtl_write_word(rtlpriv, REG_PROT_MODE_CTRL, 0x0204);\n\trtl_write_dword(rtlpriv, REG_BAR_MODE_CTRL, 0x014004);\n\t \n\trtl_write_dword(rtlpriv, REG_EDCA_BE_PARAM, 0x005EA42B);\n\trtl_write_dword(rtlpriv, REG_EDCA_BK_PARAM, 0x0000A44F);\n\trtl_write_dword(rtlpriv, REG_EDCA_VI_PARAM, 0x005EA324);\n\trtl_write_dword(rtlpriv, REG_EDCA_VO_PARAM, 0x002FA226);\n\t \n\trtl_write_byte(rtlpriv, REG_PIFS, 0x1C);\n\t \n\trtl_write_byte(rtlpriv, REG_AGGR_BREAK_TIME, 0x16);\n\trtl_write_word(rtlpriv, REG_NAV_PROT_LEN, 0x0040);\n\trtl_write_byte(rtlpriv, REG_BCNDMATIM, 0x02);\n\trtl_write_byte(rtlpriv, REG_ATIMWND, 0x02);\n}\n\nvoid rtl92c_init_ampdu_aggregation(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtl_write_dword(rtlpriv, REG_AGGLEN_LMT, 0x99997631);\n\trtl_write_byte(rtlpriv, REG_AGGR_BREAK_TIME, 0x16);\n\t \n\trtl_write_word(rtlpriv, 0x4CA, 0x0708);\n}\n\nvoid rtl92c_init_beacon_max_error(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtl_write_byte(rtlpriv, REG_BCN_MAX_ERR, 0xFF);\n}\n\nvoid rtl92c_init_rdg_setting(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtl_write_byte(rtlpriv, REG_RD_CTRL, 0xFF);\n\trtl_write_word(rtlpriv, REG_RD_NAV_NXT, 0x200);\n\trtl_write_byte(rtlpriv, REG_RD_RESP_PKT_TH, 0x05);\n}\n\nvoid rtl92c_init_retry_function(struct ieee80211_hw *hw)\n{\n\tu8\tvalue8;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\tvalue8 = rtl_read_byte(rtlpriv, REG_FWHW_TXQ_CTRL);\n\tvalue8 |= EN_AMPDU_RTY_NEW;\n\trtl_write_byte(rtlpriv, REG_FWHW_TXQ_CTRL, value8);\n\t \n\trtl_write_byte(rtlpriv, REG_ACKTO, 0x40);\n}\n\nvoid rtl92c_disable_fast_edca(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtl_write_word(rtlpriv, REG_FAST_EDCA_CTRL, 0);\n}\n\nvoid rtl92c_set_min_space(struct ieee80211_hw *hw, bool is2T)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 value = is2T ? MAX_MSS_DENSITY_2T : MAX_MSS_DENSITY_1T;\n\n\trtl_write_byte(rtlpriv, REG_AMPDU_MIN_SPACE, value);\n}\n\n \n\nstatic void _rtl92c_query_rxphystatus(struct ieee80211_hw *hw,\n\t\t\t\t      struct rtl_stats *pstats,\n\t\t\t\t      struct rx_desc_92c *p_desc,\n\t\t\t\t      struct rx_fwinfo_92c *p_drvinfo,\n\t\t\t\t      bool packet_match_bssid,\n\t\t\t\t      bool packet_toself,\n\t\t\t\t      bool packet_beacon)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct phy_sts_cck_8192s_t *cck_buf;\n\ts8 rx_pwr_all = 0, rx_pwr[4];\n\tu8 rf_rx_num = 0, evm, pwdb_all;\n\tu8 i, max_spatial_stream;\n\tu32 rssi, total_rssi = 0;\n\tbool in_powersavemode = false;\n\tbool is_cck_rate;\n\t__le32 *pdesc = (__le32 *)p_desc;\n\n\tis_cck_rate = RX_HAL_IS_CCK_RATE(p_desc->rxmcs);\n\tpstats->packet_matchbssid = packet_match_bssid;\n\tpstats->packet_toself = packet_toself;\n\tpstats->packet_beacon = packet_beacon;\n\tpstats->is_cck = is_cck_rate;\n\tpstats->RX_SIGQ[0] = -1;\n\tpstats->RX_SIGQ[1] = -1;\n\tif (is_cck_rate) {\n\t\tu8 report, cck_highpwr;\n\n\t\tcck_buf = (struct phy_sts_cck_8192s_t *)p_drvinfo;\n\t\tif (!in_powersavemode)\n\t\t\tcck_highpwr = rtlphy->cck_high_power;\n\t\telse\n\t\t\tcck_highpwr = false;\n\t\tif (!cck_highpwr) {\n\t\t\tu8 cck_agc_rpt = cck_buf->cck_agc_rpt;\n\n\t\t\treport = cck_buf->cck_agc_rpt & 0xc0;\n\t\t\treport = report >> 6;\n\t\t\tswitch (report) {\n\t\t\tcase 0x3:\n\t\t\t\trx_pwr_all = -46 - (cck_agc_rpt & 0x3e);\n\t\t\t\tbreak;\n\t\t\tcase 0x2:\n\t\t\t\trx_pwr_all = -26 - (cck_agc_rpt & 0x3e);\n\t\t\t\tbreak;\n\t\t\tcase 0x1:\n\t\t\t\trx_pwr_all = -12 - (cck_agc_rpt & 0x3e);\n\t\t\t\tbreak;\n\t\t\tcase 0x0:\n\t\t\t\trx_pwr_all = 16 - (cck_agc_rpt & 0x3e);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tu8 cck_agc_rpt = cck_buf->cck_agc_rpt;\n\n\t\t\treport = p_drvinfo->cfosho[0] & 0x60;\n\t\t\treport = report >> 5;\n\t\t\tswitch (report) {\n\t\t\tcase 0x3:\n\t\t\t\trx_pwr_all = -46 - ((cck_agc_rpt & 0x1f) << 1);\n\t\t\t\tbreak;\n\t\t\tcase 0x2:\n\t\t\t\trx_pwr_all = -26 - ((cck_agc_rpt & 0x1f) << 1);\n\t\t\t\tbreak;\n\t\t\tcase 0x1:\n\t\t\t\trx_pwr_all = -12 - ((cck_agc_rpt & 0x1f) << 1);\n\t\t\t\tbreak;\n\t\t\tcase 0x0:\n\t\t\t\trx_pwr_all = 16 - ((cck_agc_rpt & 0x1f) << 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tpwdb_all = rtl_query_rxpwrpercentage(rx_pwr_all);\n\t\tpstats->rx_pwdb_all = pwdb_all;\n\t\tpstats->recvsignalpower = rx_pwr_all;\n\t\tif (packet_match_bssid) {\n\t\t\tu8 sq;\n\n\t\t\tif (pstats->rx_pwdb_all > 40)\n\t\t\t\tsq = 100;\n\t\t\telse {\n\t\t\t\tsq = cck_buf->sq_rpt;\n\t\t\t\tif (sq > 64)\n\t\t\t\t\tsq = 0;\n\t\t\t\telse if (sq < 20)\n\t\t\t\t\tsq = 100;\n\t\t\t\telse\n\t\t\t\t\tsq = ((64 - sq) * 100) / 44;\n\t\t\t}\n\t\t\tpstats->signalquality = sq;\n\t\t\tpstats->RX_SIGQ[0] = sq;\n\t\t\tpstats->RX_SIGQ[1] = -1;\n\t\t}\n\t} else {\n\t\trtlpriv->dm.rfpath_rxenable[0] =\n\t\t    rtlpriv->dm.rfpath_rxenable[1] = true;\n\t\tfor (i = RF90_PATH_A; i < RF90_PATH_MAX; i++) {\n\t\t\tif (rtlpriv->dm.rfpath_rxenable[i])\n\t\t\t\trf_rx_num++;\n\t\t\trx_pwr[i] =\n\t\t\t    ((p_drvinfo->gain_trsw[i] & 0x3f) * 2) - 110;\n\t\t\trssi = rtl_query_rxpwrpercentage(rx_pwr[i]);\n\t\t\ttotal_rssi += rssi;\n\t\t\trtlpriv->stats.rx_snr_db[i] =\n\t\t\t    (long)(p_drvinfo->rxsnr[i] / 2);\n\n\t\t\tif (packet_match_bssid)\n\t\t\t\tpstats->rx_mimo_signalstrength[i] = (u8) rssi;\n\t\t}\n\t\trx_pwr_all = ((p_drvinfo->pwdb_all >> 1) & 0x7f) - 110;\n\t\tpwdb_all = rtl_query_rxpwrpercentage(rx_pwr_all);\n\t\tpstats->rx_pwdb_all = pwdb_all;\n\t\tpstats->rxpower = rx_pwr_all;\n\t\tpstats->recvsignalpower = rx_pwr_all;\n\t\tif (get_rx_desc_rx_mcs(pdesc) &&\n\t\t    get_rx_desc_rx_mcs(pdesc) >= DESC_RATEMCS8 &&\n\t\t    get_rx_desc_rx_mcs(pdesc) <= DESC_RATEMCS15)\n\t\t\tmax_spatial_stream = 2;\n\t\telse\n\t\t\tmax_spatial_stream = 1;\n\t\tfor (i = 0; i < max_spatial_stream; i++) {\n\t\t\tevm = rtl_evm_db_to_percentage(p_drvinfo->rxevm[i]);\n\t\t\tif (packet_match_bssid) {\n\t\t\t\tif (i == 0)\n\t\t\t\t\tpstats->signalquality =\n\t\t\t\t\t    (u8) (evm & 0xff);\n\t\t\t\tpstats->RX_SIGQ[i] =\n\t\t\t\t    (u8) (evm & 0xff);\n\t\t\t}\n\t\t}\n\t}\n\tif (is_cck_rate)\n\t\tpstats->signalstrength =\n\t\t    (u8)(rtl_signal_scale_mapping(hw, pwdb_all));\n\telse if (rf_rx_num != 0)\n\t\tpstats->signalstrength =\n\t\t    (u8)(rtl_signal_scale_mapping(hw, total_rssi /= rf_rx_num));\n}\n\nvoid rtl92c_translate_rx_signal_stuff(struct ieee80211_hw *hw,\n\t\t\t\t\t       struct sk_buff *skb,\n\t\t\t\t\t       struct rtl_stats *pstats,\n\t\t\t\t\t       struct rx_desc_92c *pdesc,\n\t\t\t\t\t       struct rx_fwinfo_92c *p_drvinfo)\n{\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tstruct ieee80211_hdr *hdr;\n\tu8 *tmp_buf;\n\tu8 *praddr;\n\t__le16 fc;\n\tu16 type, cpu_fc;\n\tbool packet_matchbssid, packet_toself, packet_beacon = false;\n\n\ttmp_buf = skb->data + pstats->rx_drvinfo_size + pstats->rx_bufshift;\n\thdr = (struct ieee80211_hdr *)tmp_buf;\n\tfc = hdr->frame_control;\n\tcpu_fc = le16_to_cpu(fc);\n\ttype = WLAN_FC_GET_TYPE(fc);\n\tpraddr = hdr->addr1;\n\tpacket_matchbssid =\n\t    ((IEEE80211_FTYPE_CTL != type) &&\n\t     ether_addr_equal(mac->bssid,\n\t\t\t      (cpu_fc & IEEE80211_FCTL_TODS) ? hdr->addr1 :\n\t\t\t      (cpu_fc & IEEE80211_FCTL_FROMDS) ? hdr->addr2 :\n\t\t\t      hdr->addr3) &&\n\t     (!pstats->hwerror) && (!pstats->crc) && (!pstats->icv));\n\n\tpacket_toself = packet_matchbssid &&\n\t    ether_addr_equal(praddr, rtlefuse->dev_addr);\n\tif (ieee80211_is_beacon(fc))\n\t\tpacket_beacon = true;\n\t_rtl92c_query_rxphystatus(hw, pstats, pdesc, p_drvinfo,\n\t\t\t\t   packet_matchbssid, packet_toself,\n\t\t\t\t   packet_beacon);\n\trtl_process_phyinfo(hw, tmp_buf, pstats);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}