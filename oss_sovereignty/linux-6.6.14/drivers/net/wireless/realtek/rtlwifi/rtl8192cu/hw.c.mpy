{
  "module_name": "hw.c",
  "hash_id": "da9915fe7ca2fe54dbe641883b6151d0bac2e5890dbe2b7c6d37afb3794921bc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtlwifi/rtl8192cu/hw.c",
  "human_readable_source": "\n \n\n#include \"../wifi.h\"\n#include \"../efuse.h\"\n#include \"../base.h\"\n#include \"../cam.h\"\n#include \"../ps.h\"\n#include \"../usb.h\"\n#include \"reg.h\"\n#include \"def.h\"\n#include \"phy.h\"\n#include \"../rtl8192c/phy_common.h\"\n#include \"mac.h\"\n#include \"dm.h\"\n#include \"../rtl8192c/dm_common.h\"\n#include \"../rtl8192c/fw_common.h\"\n#include \"hw.h\"\n#include \"../rtl8192ce/hw.h\"\n#include \"trx.h\"\n#include \"led.h\"\n#include \"table.h\"\n\nstatic void _rtl92cu_phy_param_tab_init(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtlpriv);\n\n\trtlphy->hwparam_tables[MAC_REG].length = RTL8192CUMAC_2T_ARRAYLENGTH;\n\trtlphy->hwparam_tables[MAC_REG].pdata = RTL8192CUMAC_2T_ARRAY;\n\tif (IS_HIGHT_PA(rtlefuse->board_type)) {\n\t\trtlphy->hwparam_tables[PHY_REG_PG].length =\n\t\t\tRTL8192CUPHY_REG_ARRAY_PG_HPLENGTH;\n\t\trtlphy->hwparam_tables[PHY_REG_PG].pdata =\n\t\t\tRTL8192CUPHY_REG_ARRAY_PG_HP;\n\t} else {\n\t\trtlphy->hwparam_tables[PHY_REG_PG].length =\n\t\t\tRTL8192CUPHY_REG_ARRAY_PGLENGTH;\n\t\trtlphy->hwparam_tables[PHY_REG_PG].pdata =\n\t\t\tRTL8192CUPHY_REG_ARRAY_PG;\n\t}\n\t \n\trtlphy->hwparam_tables[PHY_REG_2T].length =\n\t\t\tRTL8192CUPHY_REG_2TARRAY_LENGTH;\n\trtlphy->hwparam_tables[PHY_REG_2T].pdata =\n\t\t\tRTL8192CUPHY_REG_2TARRAY;\n\trtlphy->hwparam_tables[RADIOA_2T].length =\n\t\t\tRTL8192CURADIOA_2TARRAYLENGTH;\n\trtlphy->hwparam_tables[RADIOA_2T].pdata =\n\t\t\tRTL8192CURADIOA_2TARRAY;\n\trtlphy->hwparam_tables[RADIOB_2T].length =\n\t\t\tRTL8192CURADIOB_2TARRAYLENGTH;\n\trtlphy->hwparam_tables[RADIOB_2T].pdata =\n\t\t\tRTL8192CU_RADIOB_2TARRAY;\n\trtlphy->hwparam_tables[AGCTAB_2T].length =\n\t\t\tRTL8192CUAGCTAB_2TARRAYLENGTH;\n\trtlphy->hwparam_tables[AGCTAB_2T].pdata =\n\t\t\tRTL8192CUAGCTAB_2TARRAY;\n\t \n\tif (IS_HIGHT_PA(rtlefuse->board_type)) {\n\t\trtlphy->hwparam_tables[PHY_REG_1T].length =\n\t\t\tRTL8192CUPHY_REG_1T_HPARRAYLENGTH;\n\t\trtlphy->hwparam_tables[PHY_REG_1T].pdata =\n\t\t\tRTL8192CUPHY_REG_1T_HPARRAY;\n\t\trtlphy->hwparam_tables[RADIOA_1T].length =\n\t\t\tRTL8192CURADIOA_1T_HPARRAYLENGTH;\n\t\trtlphy->hwparam_tables[RADIOA_1T].pdata =\n\t\t\tRTL8192CURADIOA_1T_HPARRAY;\n\t\trtlphy->hwparam_tables[RADIOB_1T].length =\n\t\t\tRTL8192CURADIOB_1TARRAYLENGTH;\n\t\trtlphy->hwparam_tables[RADIOB_1T].pdata =\n\t\t\tRTL8192CU_RADIOB_1TARRAY;\n\t\trtlphy->hwparam_tables[AGCTAB_1T].length =\n\t\t\tRTL8192CUAGCTAB_1T_HPARRAYLENGTH;\n\t\trtlphy->hwparam_tables[AGCTAB_1T].pdata =\n\t\t\tRTL8192CUAGCTAB_1T_HPARRAY;\n\t} else {\n\t\trtlphy->hwparam_tables[PHY_REG_1T].length =\n\t\t\t RTL8192CUPHY_REG_1TARRAY_LENGTH;\n\t\trtlphy->hwparam_tables[PHY_REG_1T].pdata =\n\t\t\tRTL8192CUPHY_REG_1TARRAY;\n\t\trtlphy->hwparam_tables[RADIOA_1T].length =\n\t\t\tRTL8192CURADIOA_1TARRAYLENGTH;\n\t\trtlphy->hwparam_tables[RADIOA_1T].pdata =\n\t\t\tRTL8192CU_RADIOA_1TARRAY;\n\t\trtlphy->hwparam_tables[RADIOB_1T].length =\n\t\t\tRTL8192CURADIOB_1TARRAYLENGTH;\n\t\trtlphy->hwparam_tables[RADIOB_1T].pdata =\n\t\t\tRTL8192CU_RADIOB_1TARRAY;\n\t\trtlphy->hwparam_tables[AGCTAB_1T].length =\n\t\t\tRTL8192CUAGCTAB_1TARRAYLENGTH;\n\t\trtlphy->hwparam_tables[AGCTAB_1T].pdata =\n\t\t\tRTL8192CUAGCTAB_1TARRAY;\n\t}\n}\n\nstatic void _rtl92cu_read_txpower_info_from_hwpg(struct ieee80211_hw *hw,\n\t\t\t\t\t\t bool autoload_fail,\n\t\t\t\t\t\t u8 *hwinfo)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tu8 rf_path, index, tempval;\n\tu16 i;\n\n\tfor (rf_path = 0; rf_path < 2; rf_path++) {\n\t\tfor (i = 0; i < 3; i++) {\n\t\t\tif (!autoload_fail) {\n\t\t\t\trtlefuse->\n\t\t\t\t    eeprom_chnlarea_txpwr_cck[rf_path][i] =\n\t\t\t\t    hwinfo[EEPROM_TXPOWERCCK + rf_path * 3 + i];\n\t\t\t\trtlefuse->\n\t\t\t\t    eeprom_chnlarea_txpwr_ht40_1s[rf_path][i] =\n\t\t\t\t    hwinfo[EEPROM_TXPOWERHT40_1S + rf_path * 3 +\n\t\t\t\t\t   i];\n\t\t\t} else {\n\t\t\t\trtlefuse->\n\t\t\t\t    eeprom_chnlarea_txpwr_cck[rf_path][i] =\n\t\t\t\t    EEPROM_DEFAULT_TXPOWERLEVEL;\n\t\t\t\trtlefuse->\n\t\t\t\t    eeprom_chnlarea_txpwr_ht40_1s[rf_path][i] =\n\t\t\t\t    EEPROM_DEFAULT_TXPOWERLEVEL;\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0; i < 3; i++) {\n\t\tif (!autoload_fail)\n\t\t\ttempval = hwinfo[EEPROM_TXPOWERHT40_2SDIFF + i];\n\t\telse\n\t\t\ttempval = EEPROM_DEFAULT_HT40_2SDIFF;\n\t\trtlefuse->eprom_chnl_txpwr_ht40_2sdf[RF90_PATH_A][i] =\n\t\t    (tempval & 0xf);\n\t\trtlefuse->eprom_chnl_txpwr_ht40_2sdf[RF90_PATH_B][i] =\n\t\t    ((tempval & 0xf0) >> 4);\n\t}\n\tfor (rf_path = 0; rf_path < 2; rf_path++)\n\t\tfor (i = 0; i < 3; i++)\n\t\t\tRTPRINT(rtlpriv, FINIT, INIT_EEPROM,\n\t\t\t\t\"RF(%d) EEPROM CCK Area(%d) = 0x%x\\n\",\n\t\t\t\trf_path, i,\n\t\t\t\trtlefuse->\n\t\t\t\teeprom_chnlarea_txpwr_cck[rf_path][i]);\n\tfor (rf_path = 0; rf_path < 2; rf_path++)\n\t\tfor (i = 0; i < 3; i++)\n\t\t\tRTPRINT(rtlpriv, FINIT, INIT_EEPROM,\n\t\t\t\t\"RF(%d) EEPROM HT40 1S Area(%d) = 0x%x\\n\",\n\t\t\t\trf_path, i,\n\t\t\t\trtlefuse->\n\t\t\t\teeprom_chnlarea_txpwr_ht40_1s[rf_path][i]);\n\tfor (rf_path = 0; rf_path < 2; rf_path++)\n\t\tfor (i = 0; i < 3; i++)\n\t\t\tRTPRINT(rtlpriv, FINIT, INIT_EEPROM,\n\t\t\t\t\"RF(%d) EEPROM HT40 2S Diff Area(%d) = 0x%x\\n\",\n\t\t\t\trf_path, i,\n\t\t\t\trtlefuse->\n\t\t\t\teprom_chnl_txpwr_ht40_2sdf[rf_path][i]);\n\tfor (rf_path = 0; rf_path < 2; rf_path++) {\n\t\tfor (i = 0; i < 14; i++) {\n\t\t\tindex = rtl92c_get_chnl_group((u8)i);\n\t\t\trtlefuse->txpwrlevel_cck[rf_path][i] =\n\t\t\t    rtlefuse->eeprom_chnlarea_txpwr_cck[rf_path][index];\n\t\t\trtlefuse->txpwrlevel_ht40_1s[rf_path][i] =\n\t\t\t    rtlefuse->\n\t\t\t    eeprom_chnlarea_txpwr_ht40_1s[rf_path][index];\n\t\t\tif ((rtlefuse->\n\t\t\t     eeprom_chnlarea_txpwr_ht40_1s[rf_path][index] -\n\t\t\t     rtlefuse->\n\t\t\t     eprom_chnl_txpwr_ht40_2sdf[rf_path][index])\n\t\t\t    > 0) {\n\t\t\t\trtlefuse->txpwrlevel_ht40_2s[rf_path][i] =\n\t\t\t\t    rtlefuse->\n\t\t\t\t    eeprom_chnlarea_txpwr_ht40_1s[rf_path]\n\t\t\t\t    [index] - rtlefuse->\n\t\t\t\t    eprom_chnl_txpwr_ht40_2sdf[rf_path]\n\t\t\t\t    [index];\n\t\t\t} else {\n\t\t\t\trtlefuse->txpwrlevel_ht40_2s[rf_path][i] = 0;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < 14; i++) {\n\t\t\tRTPRINT(rtlpriv, FINIT, INIT_TXPOWER,\n\t\t\t\t\"RF(%d)-Ch(%d) [CCK / HT40_1S / HT40_2S] = [0x%x / 0x%x / 0x%x]\\n\", rf_path, i,\n\t\t\t\trtlefuse->txpwrlevel_cck[rf_path][i],\n\t\t\t\trtlefuse->txpwrlevel_ht40_1s[rf_path][i],\n\t\t\t\trtlefuse->txpwrlevel_ht40_2s[rf_path][i]);\n\t\t}\n\t}\n\tfor (i = 0; i < 3; i++) {\n\t\tif (!autoload_fail) {\n\t\t\trtlefuse->eeprom_pwrlimit_ht40[i] =\n\t\t\t    hwinfo[EEPROM_TXPWR_GROUP + i];\n\t\t\trtlefuse->eeprom_pwrlimit_ht20[i] =\n\t\t\t    hwinfo[EEPROM_TXPWR_GROUP + 3 + i];\n\t\t} else {\n\t\t\trtlefuse->eeprom_pwrlimit_ht40[i] = 0;\n\t\t\trtlefuse->eeprom_pwrlimit_ht20[i] = 0;\n\t\t}\n\t}\n\tfor (rf_path = 0; rf_path < 2; rf_path++) {\n\t\tfor (i = 0; i < 14; i++) {\n\t\t\tindex = rtl92c_get_chnl_group((u8)i);\n\t\t\tif (rf_path == RF90_PATH_A) {\n\t\t\t\trtlefuse->pwrgroup_ht20[rf_path][i] =\n\t\t\t\t    (rtlefuse->eeprom_pwrlimit_ht20[index]\n\t\t\t\t     & 0xf);\n\t\t\t\trtlefuse->pwrgroup_ht40[rf_path][i] =\n\t\t\t\t    (rtlefuse->eeprom_pwrlimit_ht40[index]\n\t\t\t\t     & 0xf);\n\t\t\t} else if (rf_path == RF90_PATH_B) {\n\t\t\t\trtlefuse->pwrgroup_ht20[rf_path][i] =\n\t\t\t\t    ((rtlefuse->eeprom_pwrlimit_ht20[index]\n\t\t\t\t      & 0xf0) >> 4);\n\t\t\t\trtlefuse->pwrgroup_ht40[rf_path][i] =\n\t\t\t\t    ((rtlefuse->eeprom_pwrlimit_ht40[index]\n\t\t\t\t      & 0xf0) >> 4);\n\t\t\t}\n\t\t\tRTPRINT(rtlpriv, FINIT, INIT_TXPOWER,\n\t\t\t\t\"RF-%d pwrgroup_ht20[%d] = 0x%x\\n\",\n\t\t\t\trf_path, i,\n\t\t\t\trtlefuse->pwrgroup_ht20[rf_path][i]);\n\t\t\tRTPRINT(rtlpriv, FINIT, INIT_TXPOWER,\n\t\t\t\t\"RF-%d pwrgroup_ht40[%d] = 0x%x\\n\",\n\t\t\t\trf_path, i,\n\t\t\t\trtlefuse->pwrgroup_ht40[rf_path][i]);\n\t\t}\n\t}\n\tfor (i = 0; i < 14; i++) {\n\t\tindex = rtl92c_get_chnl_group((u8)i);\n\t\tif (!autoload_fail)\n\t\t\ttempval = hwinfo[EEPROM_TXPOWERHT20DIFF + index];\n\t\telse\n\t\t\ttempval = EEPROM_DEFAULT_HT20_DIFF;\n\t\trtlefuse->txpwr_ht20diff[RF90_PATH_A][i] = (tempval & 0xF);\n\t\trtlefuse->txpwr_ht20diff[RF90_PATH_B][i] =\n\t\t    ((tempval >> 4) & 0xF);\n\t\tif (rtlefuse->txpwr_ht20diff[RF90_PATH_A][i] & BIT(3))\n\t\t\trtlefuse->txpwr_ht20diff[RF90_PATH_A][i] |= 0xF0;\n\t\tif (rtlefuse->txpwr_ht20diff[RF90_PATH_B][i] & BIT(3))\n\t\t\trtlefuse->txpwr_ht20diff[RF90_PATH_B][i] |= 0xF0;\n\t\tindex = rtl92c_get_chnl_group((u8)i);\n\t\tif (!autoload_fail)\n\t\t\ttempval = hwinfo[EEPROM_TXPOWER_OFDMDIFF + index];\n\t\telse\n\t\t\ttempval = EEPROM_DEFAULT_LEGACYHTTXPOWERDIFF;\n\t\trtlefuse->txpwr_legacyhtdiff[RF90_PATH_A][i] = (tempval & 0xF);\n\t\trtlefuse->txpwr_legacyhtdiff[RF90_PATH_B][i] =\n\t\t    ((tempval >> 4) & 0xF);\n\t}\n\trtlefuse->legacy_ht_txpowerdiff =\n\t    rtlefuse->txpwr_legacyhtdiff[RF90_PATH_A][7];\n\tfor (i = 0; i < 14; i++)\n\t\tRTPRINT(rtlpriv, FINIT, INIT_TXPOWER,\n\t\t\t\"RF-A Ht20 to HT40 Diff[%d] = 0x%x\\n\",\n\t\t\ti, rtlefuse->txpwr_ht20diff[RF90_PATH_A][i]);\n\tfor (i = 0; i < 14; i++)\n\t\tRTPRINT(rtlpriv, FINIT, INIT_TXPOWER,\n\t\t\t\"RF-A Legacy to Ht40 Diff[%d] = 0x%x\\n\",\n\t\t\ti, rtlefuse->txpwr_legacyhtdiff[RF90_PATH_A][i]);\n\tfor (i = 0; i < 14; i++)\n\t\tRTPRINT(rtlpriv, FINIT, INIT_TXPOWER,\n\t\t\t\"RF-B Ht20 to HT40 Diff[%d] = 0x%x\\n\",\n\t\t\ti, rtlefuse->txpwr_ht20diff[RF90_PATH_B][i]);\n\tfor (i = 0; i < 14; i++)\n\t\tRTPRINT(rtlpriv, FINIT, INIT_TXPOWER,\n\t\t\t\"RF-B Legacy to HT40 Diff[%d] = 0x%x\\n\",\n\t\t\ti, rtlefuse->txpwr_legacyhtdiff[RF90_PATH_B][i]);\n\tif (!autoload_fail)\n\t\trtlefuse->eeprom_regulatory = (hwinfo[RF_OPTION1] & 0x7);\n\telse\n\t\trtlefuse->eeprom_regulatory = 0;\n\tRTPRINT(rtlpriv, FINIT, INIT_TXPOWER,\n\t\t\"eeprom_regulatory = 0x%x\\n\", rtlefuse->eeprom_regulatory);\n\tif (!autoload_fail) {\n\t\trtlefuse->eeprom_tssi[RF90_PATH_A] = hwinfo[EEPROM_TSSI_A];\n\t\trtlefuse->eeprom_tssi[RF90_PATH_B] = hwinfo[EEPROM_TSSI_B];\n\t} else {\n\t\trtlefuse->eeprom_tssi[RF90_PATH_A] = EEPROM_DEFAULT_TSSI;\n\t\trtlefuse->eeprom_tssi[RF90_PATH_B] = EEPROM_DEFAULT_TSSI;\n\t}\n\tRTPRINT(rtlpriv, FINIT, INIT_TXPOWER,\n\t\t\"TSSI_A = 0x%x, TSSI_B = 0x%x\\n\",\n\t\trtlefuse->eeprom_tssi[RF90_PATH_A],\n\t\trtlefuse->eeprom_tssi[RF90_PATH_B]);\n\tif (!autoload_fail)\n\t\ttempval = hwinfo[EEPROM_THERMAL_METER];\n\telse\n\t\ttempval = EEPROM_DEFAULT_THERMALMETER;\n\trtlefuse->eeprom_thermalmeter = (tempval & 0x1f);\n\tif (rtlefuse->eeprom_thermalmeter < 0x06 ||\n\t    rtlefuse->eeprom_thermalmeter > 0x1c)\n\t\trtlefuse->eeprom_thermalmeter = 0x12;\n\tif (rtlefuse->eeprom_thermalmeter == 0x1f || autoload_fail)\n\t\trtlefuse->apk_thermalmeterignore = true;\n\trtlefuse->thermalmeter[0] = rtlefuse->eeprom_thermalmeter;\n\tRTPRINT(rtlpriv, FINIT, INIT_TXPOWER,\n\t\t\"thermalmeter = 0x%x\\n\", rtlefuse->eeprom_thermalmeter);\n}\n\nstatic void _rtl92cu_read_board_type(struct ieee80211_hw *hw, u8 *contents)\n{\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tu8 boardtype;\n\n\tif (IS_NORMAL_CHIP(rtlhal->version)) {\n\t\tboardtype = ((contents[EEPROM_RF_OPT1]) &\n\t\t\t    BOARD_TYPE_NORMAL_MASK) >> 5;  \n\t} else {\n\t\tboardtype = contents[EEPROM_RF_OPT4];\n\t\tboardtype &= BOARD_TYPE_TEST_MASK;\n\t}\n\trtlefuse->board_type = boardtype;\n\tif (IS_HIGHT_PA(rtlefuse->board_type))\n\t\trtlefuse->external_pa = 1;\n\tpr_info(\"Board Type %x\\n\", rtlefuse->board_type);\n}\n\nstatic void _rtl92cu_read_adapter_info(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tint params[] = {RTL8190_EEPROM_ID, EEPROM_VID, EEPROM_DID,\n\t\t\tEEPROM_SVID, EEPROM_SMID, EEPROM_MAC_ADDR,\n\t\t\tEEPROM_CHANNELPLAN, EEPROM_VERSION, EEPROM_CUSTOMER_ID,\n\t\t\t0};\n\tu8 *hwinfo;\n\n\thwinfo = kzalloc(HWSET_MAX_SIZE, GFP_KERNEL);\n\tif (!hwinfo)\n\t\treturn;\n\n\tif (rtl_get_hwinfo(hw, rtlpriv, HWSET_MAX_SIZE, hwinfo, params))\n\t\tgoto exit;\n\n\t_rtl92cu_read_txpower_info_from_hwpg(hw,\n\t\t\t\t\t   rtlefuse->autoload_failflag, hwinfo);\n\t_rtl92cu_read_board_type(hw, hwinfo);\n\n\trtlefuse->txpwr_fromeprom = true;\n\tif (rtlhal->oem_id == RT_CID_DEFAULT) {\n\t\tswitch (rtlefuse->eeprom_oemid) {\n\t\tcase EEPROM_CID_DEFAULT:\n\t\t\tif (rtlefuse->eeprom_did == 0x8176) {\n\t\t\t\tif ((rtlefuse->eeprom_svid == 0x103C &&\n\t\t\t\t     rtlefuse->eeprom_smid == 0x1629))\n\t\t\t\t\trtlhal->oem_id = RT_CID_819X_HP;\n\t\t\t\telse\n\t\t\t\t\trtlhal->oem_id = RT_CID_DEFAULT;\n\t\t\t} else {\n\t\t\t\trtlhal->oem_id = RT_CID_DEFAULT;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase EEPROM_CID_TOSHIBA:\n\t\t\trtlhal->oem_id = RT_CID_TOSHIBA;\n\t\t\tbreak;\n\t\tcase EEPROM_CID_QMI:\n\t\t\trtlhal->oem_id = RT_CID_819X_QMI;\n\t\t\tbreak;\n\t\tcase EEPROM_CID_WHQL:\n\t\tdefault:\n\t\t\trtlhal->oem_id = RT_CID_DEFAULT;\n\t\t\tbreak;\n\t\t}\n\t}\nexit:\n\tkfree(hwinfo);\n}\n\nstatic void _rtl92cu_hal_customized_behavior(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\n\tswitch (rtlhal->oem_id) {\n\tcase RT_CID_819X_HP:\n\t\trtlpriv->ledctl.led_opendrain = true;\n\t\tbreak;\n\tcase RT_CID_819X_LENOVO:\n\tcase RT_CID_DEFAULT:\n\tcase RT_CID_TOSHIBA:\n\tcase RT_CID_CCX:\n\tcase RT_CID_819X_ACER:\n\tcase RT_CID_WHQL:\n\tdefault:\n\t\tbreak;\n\t}\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG, \"RT Customized ID: 0x%02X\\n\",\n\t\trtlhal->oem_id);\n}\n\nvoid rtl92cu_read_eeprom_info(struct ieee80211_hw *hw)\n{\n\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tu8 tmp_u1b;\n\n\tif (!IS_NORMAL_CHIP(rtlhal->version))\n\t\treturn;\n\ttmp_u1b = rtl_read_byte(rtlpriv, REG_9346CR);\n\trtlefuse->epromtype = (tmp_u1b & BOOT_FROM_EEPROM) ?\n\t\t\t       EEPROM_93C46 : EEPROM_BOOT_EFUSE;\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG, \"Boot from %s\\n\",\n\t\ttmp_u1b & BOOT_FROM_EEPROM ? \"EERROM\" : \"EFUSE\");\n\trtlefuse->autoload_failflag = (tmp_u1b & EEPROM_EN) ? false : true;\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD, \"Autoload %s\\n\",\n\t\ttmp_u1b & EEPROM_EN ? \"OK!!\" : \"ERR!!\");\n\t_rtl92cu_read_adapter_info(hw);\n\t_rtl92cu_hal_customized_behavior(hw);\n\treturn;\n}\n\nstatic int _rtl92cu_init_power_on(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tint\t\tstatus = 0;\n\tu16\t\tvalue16;\n\tu8\t\tvalue8;\n\t \n\tu32\tpollingcount = 0;\n\n\tdo {\n\t\tif (rtl_read_byte(rtlpriv, REG_APS_FSMCO) & PFM_ALDN) {\n\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG,\n\t\t\t\t\"Autoload Done!\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (pollingcount++ > 100) {\n\t\t\tpr_err(\"Failed to polling REG_APS_FSMCO[PFM_ALDN] done!\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t} while (true);\n\t \n\trtl_write_byte(rtlpriv, REG_RSV_CTRL, 0x0);\n\t \n\t \n\trtl_write_byte(rtlpriv, REG_SPS0_CTRL, 0x2b);\n\tudelay(100);\n\tvalue8 = rtl_read_byte(rtlpriv, REG_LDOV12D_CTRL);\n\tif (0 == (value8 & LDV12_EN)) {\n\t\tvalue8 |= LDV12_EN;\n\t\trtl_write_byte(rtlpriv, REG_LDOV12D_CTRL, value8);\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG,\n\t\t\t\" power-on :REG_LDOV12D_CTRL Reg0x21:0x%02x\\n\",\n\t\t\tvalue8);\n\t\tudelay(100);\n\t\tvalue8 = rtl_read_byte(rtlpriv, REG_SYS_ISO_CTRL);\n\t\tvalue8 &= ~ISO_MD2PP;\n\t\trtl_write_byte(rtlpriv, REG_SYS_ISO_CTRL, value8);\n\t}\n\t \n\tpollingcount = 0;\n\tvalue16 = rtl_read_word(rtlpriv, REG_APS_FSMCO);\n\tvalue16 |= APFM_ONMAC;\n\trtl_write_word(rtlpriv, REG_APS_FSMCO, value16);\n\tdo {\n\t\tif (!(rtl_read_word(rtlpriv, REG_APS_FSMCO) & APFM_ONMAC)) {\n\t\t\tpr_info(\"MAC auto ON okay!\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (pollingcount++ > 1000) {\n\t\t\tpr_err(\"Failed to polling REG_APS_FSMCO[APFM_ONMAC] done!\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t} while (true);\n\t \n\trtl_write_word(rtlpriv, REG_APS_FSMCO, 0x0812);\n\t \n\tvalue16 = rtl_read_word(rtlpriv, REG_SYS_ISO_CTRL);\n\tvalue16 &= ~ISO_DIOR;\n\trtl_write_word(rtlpriv, REG_SYS_ISO_CTRL, value16);\n\t \n\tpollingcount = 0;\n\trtl_write_byte(rtlpriv, REG_APSD_CTRL, (rtl_read_byte(rtlpriv,\n\t\t\t\t\t\tREG_APSD_CTRL) & ~BIT(6)));\n\tdo {\n\t\tpollingcount++;\n\t} while ((pollingcount < 200) &&\n\t\t (rtl_read_byte(rtlpriv, REG_APSD_CTRL) & BIT(7)));\n\t \n\tvalue16 = rtl_read_word(rtlpriv,  REG_CR);\n\tvalue16 |= (HCI_TXDMA_EN | HCI_RXDMA_EN | TXDMA_EN | RXDMA_EN |\n\t\t    PROTOCOL_EN | SCHEDULE_EN | MACTXEN | MACRXEN | ENSEC);\n\trtl_write_word(rtlpriv, REG_CR, value16);\n\treturn status;\n}\n\nstatic void _rtl92cu_init_queue_reserved_page(struct ieee80211_hw *hw,\n\t\t\t\t\t      bool wmm_enable,\n\t\t\t\t\t      u8 out_ep_num,\n\t\t\t\t\t      u8 queue_sel)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tbool ischipn = IS_NORMAL_CHIP(rtlhal->version);\n\tu32 outepnum = (u32)out_ep_num;\n\tu32 numhq = 0;\n\tu32 numlq = 0;\n\tu32 numnq = 0;\n\tu32 numpubq;\n\tu32 value32;\n\tu8 value8;\n\tu32 txqpagenum, txqpageunit, txqremaininpage;\n\n\tif (!wmm_enable) {\n\t\tnumpubq = (ischipn) ? CHIP_B_PAGE_NUM_PUBQ :\n\t\t\t  CHIP_A_PAGE_NUM_PUBQ;\n\t\ttxqpagenum = TX_TOTAL_PAGE_NUMBER - numpubq;\n\n\t\ttxqpageunit = txqpagenum / outepnum;\n\t\ttxqremaininpage = txqpagenum % outepnum;\n\t\tif (queue_sel & TX_SELE_HQ)\n\t\t\tnumhq = txqpageunit;\n\t\tif (queue_sel & TX_SELE_LQ)\n\t\t\tnumlq = txqpageunit;\n\t\t \n\t\tif (outepnum > 1 && txqremaininpage)\n\t\t\tnumhq += txqremaininpage;\n\t\t \n\t\tif (ischipn) {\n\t\t\tif (queue_sel & TX_SELE_NQ)\n\t\t\t\tnumnq = txqpageunit;\n\t\t\tvalue8 = (u8)_NPQ(numnq);\n\t\t\trtl_write_byte(rtlpriv,  REG_RQPN_NPQ, value8);\n\t\t}\n\t} else {\n\t\t \n\t\tnumpubq = ischipn ? WMM_CHIP_B_PAGE_NUM_PUBQ :\n\t\t\t  WMM_CHIP_A_PAGE_NUM_PUBQ;\n\t\tif (queue_sel & TX_SELE_HQ) {\n\t\t\tnumhq = ischipn ? WMM_CHIP_B_PAGE_NUM_HPQ :\n\t\t\t\tWMM_CHIP_A_PAGE_NUM_HPQ;\n\t\t}\n\t\tif (queue_sel & TX_SELE_LQ) {\n\t\t\tnumlq = ischipn ? WMM_CHIP_B_PAGE_NUM_LPQ :\n\t\t\t\tWMM_CHIP_A_PAGE_NUM_LPQ;\n\t\t}\n\t\t \n\t\tif (ischipn) {\n\t\t\tif (queue_sel & TX_SELE_NQ)\n\t\t\t\tnumnq = WMM_CHIP_B_PAGE_NUM_NPQ;\n\t\t\tvalue8 = (u8)_NPQ(numnq);\n\t\t\trtl_write_byte(rtlpriv, REG_RQPN_NPQ, value8);\n\t\t}\n\t}\n\t \n\tvalue32 = _HPQ(numhq) | _LPQ(numlq) | _PUBQ(numpubq) | LD_RQPN;\n\trtl_write_dword(rtlpriv, REG_RQPN, value32);\n}\n\nstatic void _rtl92c_init_trx_buffer(struct ieee80211_hw *hw, bool wmm_enable)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tu8\ttxpktbuf_bndy;\n\tu8\tvalue8;\n\n\tif (!wmm_enable)\n\t\ttxpktbuf_bndy = TX_PAGE_BOUNDARY;\n\telse  \n\t\ttxpktbuf_bndy = (IS_NORMAL_CHIP(rtlhal->version))\n\t\t\t\t\t\t? WMM_CHIP_B_TX_PAGE_BOUNDARY\n\t\t\t\t\t\t: WMM_CHIP_A_TX_PAGE_BOUNDARY;\n\trtl_write_byte(rtlpriv, REG_TXPKTBUF_BCNQ_BDNY, txpktbuf_bndy);\n\trtl_write_byte(rtlpriv, REG_TXPKTBUF_MGQ_BDNY, txpktbuf_bndy);\n\trtl_write_byte(rtlpriv, REG_TXPKTBUF_WMAC_LBK_BF_HD, txpktbuf_bndy);\n\trtl_write_byte(rtlpriv, REG_TRXFF_BNDY, txpktbuf_bndy);\n\trtl_write_byte(rtlpriv, REG_TDECTRL+1, txpktbuf_bndy);\n\trtl_write_word(rtlpriv,  (REG_TRXFF_BNDY + 2), 0x27FF);\n\tvalue8 = _PSRX(RX_PAGE_SIZE_REG_VALUE) | _PSTX(PBP_128);\n\trtl_write_byte(rtlpriv, REG_PBP, value8);\n}\n\nstatic void _rtl92c_init_chipn_reg_priority(struct ieee80211_hw *hw, u16 beq,\n\t\t\t\t\t    u16 bkq, u16 viq, u16 voq,\n\t\t\t\t\t    u16 mgtq, u16 hiq)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu16 value16 = (rtl_read_word(rtlpriv, REG_TRXDMA_CTRL) & 0x7);\n\n\tvalue16 |= _TXDMA_BEQ_MAP(beq) | _TXDMA_BKQ_MAP(bkq) |\n\t\t   _TXDMA_VIQ_MAP(viq) | _TXDMA_VOQ_MAP(voq) |\n\t\t   _TXDMA_MGQ_MAP(mgtq) | _TXDMA_HIQ_MAP(hiq);\n\trtl_write_word(rtlpriv,  REG_TRXDMA_CTRL, value16);\n}\n\nstatic void _rtl92cu_init_chipn_one_out_ep_priority(struct ieee80211_hw *hw,\n\t\t\t\t\t\t    bool wmm_enable,\n\t\t\t\t\t\t    u8 queue_sel)\n{\n\tu16 value;\n\n\tswitch (queue_sel) {\n\tcase TX_SELE_HQ:\n\t\tvalue = QUEUE_HIGH;\n\t\tbreak;\n\tcase TX_SELE_LQ:\n\t\tvalue = QUEUE_LOW;\n\t\tbreak;\n\tcase TX_SELE_NQ:\n\t\tvalue = QUEUE_NORMAL;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);  \n\t\treturn;\n\t}\n\t_rtl92c_init_chipn_reg_priority(hw, value, value, value, value,\n\t\t\t\t\tvalue, value);\n\tpr_info(\"Tx queue select: 0x%02x\\n\", queue_sel);\n}\n\nstatic void _rtl92cu_init_chipn_two_out_ep_priority(struct ieee80211_hw *hw,\n\t\t\t\t\t\t     bool wmm_enable,\n\t\t\t\t\t\t     u8 queue_sel)\n{\n\tu16 beq, bkq, viq, voq, mgtq, hiq;\n\tu16 valuehi;\n\tu16 valuelow;\n\n\tswitch (queue_sel) {\n\tcase (TX_SELE_HQ | TX_SELE_LQ):\n\t\tvaluehi = QUEUE_HIGH;\n\t\tvaluelow = QUEUE_LOW;\n\t\tbreak;\n\tcase (TX_SELE_NQ | TX_SELE_LQ):\n\t\tvaluehi = QUEUE_NORMAL;\n\t\tvaluelow = QUEUE_LOW;\n\t\tbreak;\n\tcase (TX_SELE_HQ | TX_SELE_NQ):\n\t\tvaluehi = QUEUE_HIGH;\n\t\tvaluelow = QUEUE_NORMAL;\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\tif (!wmm_enable) {\n\t\tbeq = valuelow;\n\t\tbkq = valuelow;\n\t\tviq = valuehi;\n\t\tvoq = valuehi;\n\t\tmgtq = valuehi;\n\t\thiq = valuehi;\n\t} else { \n\t\tbeq = valuehi;\n\t\tbkq = valuelow;\n\t\tviq = valuelow;\n\t\tvoq = valuehi;\n\t\tmgtq = valuehi;\n\t\thiq = valuehi;\n\t}\n\t_rtl92c_init_chipn_reg_priority(hw, beq, bkq, viq, voq, mgtq, hiq);\n\tpr_info(\"Tx queue select: 0x%02x\\n\", queue_sel);\n}\n\nstatic void _rtl92cu_init_chipn_three_out_ep_priority(struct ieee80211_hw *hw,\n\t\t\t\t\t\t      bool wmm_enable,\n\t\t\t\t\t\t      u8 queue_sel)\n{\n\tu16 beq, bkq, viq, voq, mgtq, hiq;\n\n\tif (!wmm_enable) {  \n\t\tbeq\t= QUEUE_LOW;\n\t\tbkq\t= QUEUE_LOW;\n\t\tviq\t= QUEUE_NORMAL;\n\t\tvoq\t= QUEUE_HIGH;\n\t\tmgtq\t= QUEUE_HIGH;\n\t\thiq\t= QUEUE_HIGH;\n\t} else {  \n\t\tbeq\t= QUEUE_LOW;\n\t\tbkq\t= QUEUE_NORMAL;\n\t\tviq\t= QUEUE_NORMAL;\n\t\tvoq\t= QUEUE_HIGH;\n\t\tmgtq\t= QUEUE_HIGH;\n\t\thiq\t= QUEUE_HIGH;\n\t}\n\t_rtl92c_init_chipn_reg_priority(hw, beq, bkq, viq, voq, mgtq, hiq);\n\tpr_info(\"Tx queue select :0x%02x..\\n\", queue_sel);\n}\n\nstatic void _rtl92cu_init_chipn_queue_priority(struct ieee80211_hw *hw,\n\t\t\t\t\t       bool wmm_enable,\n\t\t\t\t\t       u8 out_ep_num,\n\t\t\t\t\t       u8 queue_sel)\n{\n\tswitch (out_ep_num) {\n\tcase 1:\n\t\t_rtl92cu_init_chipn_one_out_ep_priority(hw, wmm_enable,\n\t\t\t\t\t\t\tqueue_sel);\n\t\tbreak;\n\tcase 2:\n\t\t_rtl92cu_init_chipn_two_out_ep_priority(hw, wmm_enable,\n\t\t\t\t\t\t\tqueue_sel);\n\t\tbreak;\n\tcase 3:\n\t\t_rtl92cu_init_chipn_three_out_ep_priority(hw, wmm_enable,\n\t\t\t\t\t\t\t  queue_sel);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);  \n\t\tbreak;\n\t}\n}\n\nstatic void _rtl92cu_init_chipt_queue_priority(struct ieee80211_hw *hw,\n\t\t\t\t\t       bool wmm_enable,\n\t\t\t\t\t       u8 out_ep_num,\n\t\t\t\t\t       u8 queue_sel)\n{\n\tu8 hq_sele = 0;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\tswitch (out_ep_num) {\n\tcase 2:\t \n\t\tif (!wmm_enable)  \n\t\t\thq_sele =  HQSEL_VOQ | HQSEL_VIQ | HQSEL_MGTQ |\n\t\t\t\t   HQSEL_HIQ;\n\t\telse\t \n\t\t\thq_sele = HQSEL_VOQ | HQSEL_BEQ | HQSEL_MGTQ |\n\t\t\t\t  HQSEL_HIQ;\n\t\tbreak;\n\tcase 1:\n\t\tif (TX_SELE_LQ == queue_sel) {\n\t\t\t \n\t\t\thq_sele = 0;\n\t\t} else if (TX_SELE_HQ == queue_sel) {\n\t\t\t \n\t\t\thq_sele =  HQSEL_VOQ | HQSEL_VIQ | HQSEL_BEQ |\n\t\t\t\t   HQSEL_BKQ | HQSEL_MGTQ | HQSEL_HIQ;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);  \n\t\tbreak;\n\t}\n\trtl_write_byte(rtlpriv, (REG_TRXDMA_CTRL+1), hq_sele);\n\tpr_info(\"Tx queue select :0x%02x..\\n\", hq_sele);\n}\n\nstatic void _rtl92cu_init_queue_priority(struct ieee80211_hw *hw,\n\t\t\t\t\t\tbool wmm_enable,\n\t\t\t\t\t\tu8 out_ep_num,\n\t\t\t\t\t\tu8 queue_sel)\n{\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\n\tif (IS_NORMAL_CHIP(rtlhal->version))\n\t\t_rtl92cu_init_chipn_queue_priority(hw, wmm_enable, out_ep_num,\n\t\t\t\t\t\t   queue_sel);\n\telse\n\t\t_rtl92cu_init_chipt_queue_priority(hw, wmm_enable, out_ep_num,\n\t\t\t\t\t\t   queue_sel);\n}\n\nstatic void _rtl92cu_init_wmac_setting(struct ieee80211_hw *hw)\n{\n\tu16 value16;\n\tu32 value32;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\tvalue32 = (RCR_APM | RCR_AM | RCR_ADF | RCR_AB | RCR_APPFCS |\n\t\t   RCR_APP_ICV | RCR_AMF | RCR_HTC_LOC_CTRL |\n\t\t   RCR_APP_MIC | RCR_APP_PHYSTS | RCR_ACRC32);\n\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_RCR, (u8 *)(&value32));\n\t \n\trtl_write_dword(rtlpriv,  REG_MAR, 0xFFFFFFFF);\n\trtl_write_dword(rtlpriv,  REG_MAR + 4, 0xFFFFFFFF);\n\t \n\tvalue16 = 0xFFFF;\n\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_MGT_FILTER,\n\t\t\t\t      (u8 *)(&value16));\n\t \n\tvalue16 = 0x0;\n\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_CTRL_FILTER,\n\t\t\t\t      (u8 *)(&value16));\n\t \n\tvalue16 = 0xFFFF;\n\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_DATA_FILTER,\n\t\t\t\t      (u8 *)(&value16));\n}\n\nstatic void _rtl92cu_init_beacon_parameters(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\n\n\trtl_write_word(rtlpriv, REG_BCN_CTRL, 0x1010);\n\n\t \n\trtl_write_word(rtlpriv, REG_TBTT_PROHIBIT, 0x6404);\n\trtl_write_byte(rtlpriv, REG_DRVERLYINT, DRIVER_EARLY_INT_TIME);\n\trtl_write_byte(rtlpriv, REG_BCNDMATIM, BCN_DMA_ATIME_INT_TIME);\n\t \n\tif (IS_NORMAL_CHIP(rtlhal->version))\n\t\trtl_write_word(rtlpriv, REG_BCNTCFG, 0x660F);\n\telse\n\t\trtl_write_word(rtlpriv, REG_BCNTCFG, 0x66FF);\n}\n\nstatic int _rtl92cu_init_mac(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_usb_priv *usb_priv = rtl_usbpriv(hw);\n\tstruct rtl_usb *rtlusb = rtl_usbdev(usb_priv);\n\tint err = 0;\n\tu32\tboundary = 0;\n\tu8 wmm_enable = false;  \n\tu8 out_ep_nums = rtlusb->out_ep_nums;\n\tu8 queue_sel = rtlusb->out_queue_sel;\n\n\terr = _rtl92cu_init_power_on(hw);\n\n\tif (err) {\n\t\tpr_err(\"Failed to init power on!\\n\");\n\t\treturn err;\n\t}\n\tif (!wmm_enable) {\n\t\tboundary = TX_PAGE_BOUNDARY;\n\t} else {  \n\t\tboundary = (IS_NORMAL_CHIP(rtlhal->version))\n\t\t\t\t\t? WMM_CHIP_B_TX_PAGE_BOUNDARY\n\t\t\t\t\t: WMM_CHIP_A_TX_PAGE_BOUNDARY;\n\t}\n\tif (!rtl92c_init_llt_table(hw, boundary)) {\n\t\tpr_err(\"Failed to init LLT Table!\\n\");\n\t\treturn -EINVAL;\n\t}\n\t_rtl92cu_init_queue_reserved_page(hw, wmm_enable, out_ep_nums,\n\t\t\t\t\t  queue_sel);\n\t_rtl92c_init_trx_buffer(hw, wmm_enable);\n\t_rtl92cu_init_queue_priority(hw, wmm_enable, out_ep_nums,\n\t\t\t\t     queue_sel);\n\t \n\trtl92c_init_driver_info_size(hw, RTL92C_DRIVER_INFO_SIZE);\n\trtl92c_init_interrupt(hw);\n\trtl92c_init_network_type(hw);\n\t_rtl92cu_init_wmac_setting(hw);\n\trtl92c_init_adaptive_ctrl(hw);\n\trtl92c_init_edca(hw);\n\trtl92c_init_rate_fallback(hw);\n\trtl92c_init_retry_function(hw);\n\trtlpriv->cfg->ops->set_bw_mode(hw, NL80211_CHAN_HT20);\n\trtl92c_set_min_space(hw, IS_92C_SERIAL(rtlhal->version));\n\t_rtl92cu_init_beacon_parameters(hw);\n\trtl92c_init_ampdu_aggregation(hw);\n\trtl92c_init_beacon_max_error(hw);\n\treturn err;\n}\n\nvoid rtl92cu_enable_hw_security_config(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 sec_reg_value = 0x0;\n\tstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\"PairwiseEncAlgorithm = %d GroupEncAlgorithm = %d\\n\",\n\t\trtlpriv->sec.pairwise_enc_algorithm,\n\t\trtlpriv->sec.group_enc_algorithm);\n\tif (rtlpriv->cfg->mod_params->sw_crypto || rtlpriv->sec.use_sw_sec) {\n\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_DMESG,\n\t\t\t\"not open sw encryption\\n\");\n\t\treturn;\n\t}\n\tsec_reg_value = SCR_TXENCENABLE | SCR_RXDECENABLE;\n\tif (rtlpriv->sec.use_defaultkey) {\n\t\tsec_reg_value |= SCR_TXUSEDK;\n\t\tsec_reg_value |= SCR_RXUSEDK;\n\t}\n\tif (IS_NORMAL_CHIP(rtlhal->version))\n\t\tsec_reg_value |= (SCR_RXBCUSEDK | SCR_TXBCUSEDK);\n\trtl_write_byte(rtlpriv, REG_CR + 1, 0x02);\n\trtl_dbg(rtlpriv, COMP_SEC, DBG_LOUD, \"The SECR-value %x\\n\",\n\t\tsec_reg_value);\n\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_WPA_CONFIG, &sec_reg_value);\n}\n\nstatic void _rtl92cu_hw_configure(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));\n\n\t \n\trtl_write_byte(rtlpriv, REG_LDOHCI12_CTRL, 0x0f);\n\trtl_write_byte(rtlpriv, 0x15, 0xe9);\n\t \n\t \n\trtl_write_byte(rtlpriv, REG_HWSEQ_CTRL, 0xFF);\n\t \n\trtl_write_byte(rtlpriv, 0xfe40, 0xe0);\n\trtl_write_byte(rtlpriv, 0xfe41, 0x8d);\n\trtl_write_byte(rtlpriv, 0xfe42, 0x80);\n\trtlusb->reg_bcn_ctrl_val = 0x18;\n\trtl_write_byte(rtlpriv, REG_BCN_CTRL, (u8)rtlusb->reg_bcn_ctrl_val);\n}\n\nstatic void _initpabias(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tu8 pa_setting;\n\n\t \n\tpa_setting = efuse_read_1byte(hw, 0x1FA);\n\tif (!(pa_setting & BIT(0))) {\n\t\trtl_set_rfreg(hw, RF90_PATH_A, 0x15, 0x0FFFFF, 0x0F406);\n\t\trtl_set_rfreg(hw, RF90_PATH_A, 0x15, 0x0FFFFF, 0x4F406);\n\t\trtl_set_rfreg(hw, RF90_PATH_A, 0x15, 0x0FFFFF, 0x8F406);\n\t\trtl_set_rfreg(hw, RF90_PATH_A, 0x15, 0x0FFFFF, 0xCF406);\n\t}\n\tif (!(pa_setting & BIT(1)) && IS_NORMAL_CHIP(rtlhal->version) &&\n\t    IS_92C_SERIAL(rtlhal->version)) {\n\t\trtl_set_rfreg(hw, RF90_PATH_B, 0x15, 0x0FFFFF, 0x0F406);\n\t\trtl_set_rfreg(hw, RF90_PATH_B, 0x15, 0x0FFFFF, 0x4F406);\n\t\trtl_set_rfreg(hw, RF90_PATH_B, 0x15, 0x0FFFFF, 0x8F406);\n\t\trtl_set_rfreg(hw, RF90_PATH_B, 0x15, 0x0FFFFF, 0xCF406);\n\t}\n\tif (!(pa_setting & BIT(4))) {\n\t\tpa_setting = rtl_read_byte(rtlpriv, 0x16);\n\t\tpa_setting &= 0x0F;\n\t\trtl_write_byte(rtlpriv, 0x16, pa_setting | 0x90);\n\t}\n}\n\nint rtl92cu_hw_init(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tint err = 0;\n\tunsigned long flags;\n\n\t \n\tlocal_save_flags(flags);\n\tlocal_irq_enable();\n\n\trtlhal->fw_ready = false;\n\trtlhal->hw_type = HARDWARE_TYPE_RTL8192CU;\n\terr = _rtl92cu_init_mac(hw);\n\tif (err) {\n\t\tpr_err(\"init mac failed!\\n\");\n\t\tgoto exit;\n\t}\n\terr = rtl92c_download_fw(hw);\n\tif (err) {\n\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_WARNING,\n\t\t\t\"Failed to download FW. Init HW without FW now..\\n\");\n\t\terr = 1;\n\t\tgoto exit;\n\t}\n\n\trtlhal->fw_ready = true;\n\trtlhal->last_hmeboxnum = 0;  \n\t_rtl92cu_phy_param_tab_init(hw);\n\trtl92cu_phy_mac_config(hw);\n\trtl92cu_phy_bb_config(hw);\n\trtlphy->rf_mode = RF_OP_BY_SW_3WIRE;\n\trtl92c_phy_rf_config(hw);\n\tif (IS_VENDOR_UMC_A_CUT(rtlhal->version) &&\n\t    !IS_92C_SERIAL(rtlhal->version)) {\n\t\trtl_set_rfreg(hw, RF90_PATH_A, RF_RX_G1, MASKDWORD, 0x30255);\n\t\trtl_set_rfreg(hw, RF90_PATH_A, RF_RX_G2, MASKDWORD, 0x50a00);\n\t}\n\trtlphy->rfreg_chnlval[0] = rtl_get_rfreg(hw, (enum radio_path)0,\n\t\t\t\t\t\t RF_CHNLBW, RFREG_OFFSET_MASK);\n\trtlphy->rfreg_chnlval[1] = rtl_get_rfreg(hw, (enum radio_path)1,\n\t\t\t\t\t\t RF_CHNLBW, RFREG_OFFSET_MASK);\n\trtl92cu_bb_block_on(hw);\n\trtl_cam_reset_all_entry(hw);\n\trtl92cu_enable_hw_security_config(hw);\n\tppsc->rfpwr_state = ERFON;\n\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_ETHER_ADDR, mac->mac_addr);\n\tif (ppsc->rfpwr_state == ERFON) {\n\t\trtl92c_phy_set_rfpath_switch(hw, 1);\n\t\tif (rtlphy->iqk_initialized) {\n\t\t\trtl92c_phy_iq_calibrate(hw, true);\n\t\t} else {\n\t\t\trtl92c_phy_iq_calibrate(hw, false);\n\t\t\trtlphy->iqk_initialized = true;\n\t\t}\n\t\trtl92c_dm_check_txpower_tracking(hw);\n\t\trtl92c_phy_lc_calibrate(hw);\n\t}\n\t_rtl92cu_hw_configure(hw);\n\t_initpabias(hw);\n\trtl92c_dm_init(hw);\nexit:\n\tlocal_irq_disable();\n\tlocal_irq_restore(flags);\n\treturn err;\n}\n\nstatic void disable_rfafeandresetbb(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n \n\tu8 erfpath = 0, value8 = 0;\n\n\trtl_write_byte(rtlpriv, REG_TXPAUSE, 0xFF);\n\trtl_set_rfreg(hw, (enum radio_path)erfpath, 0x0, MASKBYTE0, 0x0);\n\n\tvalue8 |= APSDOFF;\n\trtl_write_byte(rtlpriv, REG_APSD_CTRL, value8);  \n\tvalue8 = 0;\n\tvalue8 |= (FEN_USBD | FEN_USBA | FEN_BB_GLB_RSTN);\n\trtl_write_byte(rtlpriv, REG_SYS_FUNC_EN, value8); \n\tvalue8 &= (~FEN_BB_GLB_RSTN);\n\trtl_write_byte(rtlpriv, REG_SYS_FUNC_EN, value8);  \n}\n\nstatic void  _resetdigitalprocedure1(struct ieee80211_hw *hw, bool withouthwsm)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\n\tif (rtlhal->fw_version <=  0x20) {\n\t\t \n\t\tu16 valu16 = 0;\n\n\t\trtl_write_byte(rtlpriv, REG_MCUFWDL, 0);\n\t\tvalu16 = rtl_read_word(rtlpriv, REG_SYS_FUNC_EN);\n\t\trtl_write_word(rtlpriv, REG_SYS_FUNC_EN, (valu16 &\n\t\t\t       (~FEN_CPUEN)));  \n\t\tvalu16 = rtl_read_word(rtlpriv, REG_SYS_FUNC_EN)&0x0FFF;\n\t\trtl_write_word(rtlpriv, REG_SYS_FUNC_EN, (valu16 |\n\t\t\t      (FEN_HWPDN|FEN_ELDR)));  \n\t\tvalu16 = rtl_read_word(rtlpriv, REG_SYS_FUNC_EN);\n\t\trtl_write_word(rtlpriv, REG_SYS_FUNC_EN, (valu16 |\n\t\t\t       FEN_CPUEN));  \n\t} else {\n\t\tu8 retry_cnts = 0;\n\n\t\t \n\t\tif (rtl_read_byte(rtlpriv, REG_MCUFWDL) & BIT(1)) {\n\t\t\t \n\t\t\trtl_write_byte(rtlpriv, REG_MCUFWDL, 0);\n\t\t\t \n\t\t\trtl_write_byte(rtlpriv, REG_HMETFR+3, 0x20);\n\t\t\twhile ((retry_cnts++ < 100) &&\n\t\t\t       (FEN_CPUEN & rtl_read_word(rtlpriv,\n\t\t\t       REG_SYS_FUNC_EN))) {\n\t\t\t\tudelay(50);\n\t\t\t}\n\t\t\tif (retry_cnts >= 100) {\n\t\t\t\tpr_err(\"8051 reset failed!.........................\\n\");\n\t\t\t\t \n\t\t\t\trtl_write_byte(rtlpriv,\n\t\t\t\t\t       REG_SYS_FUNC_EN + 1,\n\t\t\t\t\t       0x50);\n\t\t\t\tudelay(100);\n\t\t\t}\n\t\t}\n\t\t \n\t\trtl_write_byte(rtlpriv, REG_SYS_FUNC_EN + 1, 0x54);\n\t\trtl_write_byte(rtlpriv, REG_MCUFWDL, 0);\n\t}\n\tif (withouthwsm) {\n\t\t \n\t\trtl_write_word(rtlpriv, REG_SYS_CLKR, 0x70A3);\n\t\trtl_write_byte(rtlpriv, REG_AFE_PLL_CTRL, 0x80);\n\t\trtl_write_word(rtlpriv, REG_AFE_XTAL_CTRL, 0x880F);\n\t\trtl_write_byte(rtlpriv, REG_SYS_ISO_CTRL, 0xF9);\n\t}\n}\n\nstatic void _resetdigitalprocedure2(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n \n\trtl_write_word(rtlpriv, REG_SYS_CLKR, 0x70A3);\n\trtl_write_byte(rtlpriv, REG_SYS_ISO_CTRL+1, 0x82);\n}\n\nstatic void _disablegpio(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n \n\tu8\tvalue8;\n\tu16\tvalue16;\n\tu32\tvalue32;\n\n\t \n\trtl_write_word(rtlpriv, REG_GPIO_PIN_CTRL+2, 0x0000);\n\tvalue32 = rtl_read_dword(rtlpriv, REG_GPIO_PIN_CTRL) & 0xFFFF00FF;\n\tvalue8 = (u8)(value32&0x000000FF);\n\tvalue32 |= ((value8<<8) | 0x00FF0000);\n\trtl_write_dword(rtlpriv, REG_GPIO_PIN_CTRL, value32);\n\t \n\trtl_write_byte(rtlpriv, REG_GPIO_MUXCFG+3, 0x00);\n\tvalue16 = rtl_read_word(rtlpriv, REG_GPIO_MUXCFG+2) & 0xFF0F;\n\tvalue8 = (u8)(value16&0x000F);\n\tvalue16 |= ((value8<<4) | 0x0780);\n\trtl_write_word(rtlpriv, REG_GPIO_PIN_CTRL+2, value16);\n\t \n\trtl_write_word(rtlpriv, REG_LEDCFG0, 0x8080);\n}\n\nstatic void disable_analog(struct ieee80211_hw *hw, bool withouthwsm)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu16 value16 = 0;\n\tu8 value8 = 0;\n\n\tif (withouthwsm) {\n\t\t \n\t\trtl_write_byte(rtlpriv, REG_LDOA15_CTRL, 0x04);\n\t\tvalue8 = rtl_read_byte(rtlpriv, REG_LDOV12D_CTRL);\n\t\tvalue8 &= (~LDV12_EN);\n\t\trtl_write_byte(rtlpriv, REG_LDOV12D_CTRL, value8);\n\t}\n\n \n\trtl_write_byte(rtlpriv, REG_SPS0_CTRL, 0x23);\n\tvalue16 |= (APDM_HOST | AFSM_HSUS | PFM_ALDN);\n\trtl_write_word(rtlpriv, REG_APS_FSMCO, (u16)value16);\n\trtl_write_byte(rtlpriv, REG_RSV_CTRL, 0x0E);\n}\n\nstatic void carddisable_hwsm(struct ieee80211_hw *hw)\n{\n\t \n\tdisable_rfafeandresetbb(hw);\n\t \n\t_resetdigitalprocedure1(hw, false);\n\t \n\t_disablegpio(hw);\n\t \n\tdisable_analog(hw, false);\n}\n\nstatic void carddisablewithout_hwsm(struct ieee80211_hw *hw)\n{\n\t \n\tdisable_rfafeandresetbb(hw);\n\t \n\t_resetdigitalprocedure1(hw, true);\n\t \n\t_disablegpio(hw);\n\t \n\t_resetdigitalprocedure2(hw);\n\t \n\tdisable_analog(hw, true);\n}\n\nstatic void _rtl92cu_set_bcn_ctrl_reg(struct ieee80211_hw *hw,\n\t\t\t\t      u8 set_bits, u8 clear_bits)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));\n\n\trtlusb->reg_bcn_ctrl_val |= set_bits;\n\trtlusb->reg_bcn_ctrl_val &= ~clear_bits;\n\trtl_write_byte(rtlpriv, REG_BCN_CTRL, (u8)rtlusb->reg_bcn_ctrl_val);\n}\n\nstatic void _rtl92cu_stop_tx_beacon(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\n\tu8 tmp1byte = 0;\n\n\tif (IS_NORMAL_CHIP(rtlhal->version)) {\n\t\ttmp1byte = rtl_read_byte(rtlpriv, REG_FWHW_TXQ_CTRL + 2);\n\t\trtl_write_byte(rtlpriv, REG_FWHW_TXQ_CTRL + 2,\n\t\t\t       tmp1byte & (~BIT(6)));\n\t\trtl_write_byte(rtlpriv, REG_TBTT_PROHIBIT + 1, 0x64);\n\t\ttmp1byte = rtl_read_byte(rtlpriv, REG_TBTT_PROHIBIT + 2);\n\t\ttmp1byte &= ~(BIT(0));\n\t\trtl_write_byte(rtlpriv, REG_TBTT_PROHIBIT + 2, tmp1byte);\n\t} else {\n\t\trtl_write_byte(rtlpriv, REG_TXPAUSE,\n\t\t\t       rtl_read_byte(rtlpriv, REG_TXPAUSE) | BIT(6));\n\t}\n}\n\nstatic void _rtl92cu_resume_tx_beacon(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\n\tu8 tmp1byte = 0;\n\n\tif (IS_NORMAL_CHIP(rtlhal->version)) {\n\t\ttmp1byte = rtl_read_byte(rtlpriv, REG_FWHW_TXQ_CTRL + 2);\n\t\trtl_write_byte(rtlpriv, REG_FWHW_TXQ_CTRL + 2,\n\t\t\t       tmp1byte | BIT(6));\n\t\trtl_write_byte(rtlpriv, REG_TBTT_PROHIBIT + 1, 0xff);\n\t\ttmp1byte = rtl_read_byte(rtlpriv, REG_TBTT_PROHIBIT + 2);\n\t\ttmp1byte |= BIT(0);\n\t\trtl_write_byte(rtlpriv, REG_TBTT_PROHIBIT + 2, tmp1byte);\n\t} else {\n\t\trtl_write_byte(rtlpriv, REG_TXPAUSE,\n\t\t\t       rtl_read_byte(rtlpriv, REG_TXPAUSE) & (~BIT(6)));\n\t}\n}\n\nstatic void _rtl92cu_enable_bcn_sub_func(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\n\n\tif (IS_NORMAL_CHIP(rtlhal->version))\n\t\t_rtl92cu_set_bcn_ctrl_reg(hw, 0, BIT(1));\n\telse\n\t\t_rtl92cu_set_bcn_ctrl_reg(hw, 0, BIT(4));\n}\n\nstatic void _rtl92cu_disable_bcn_sub_func(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\n\n\tif (IS_NORMAL_CHIP(rtlhal->version))\n\t\t_rtl92cu_set_bcn_ctrl_reg(hw, BIT(1), 0);\n\telse\n\t\t_rtl92cu_set_bcn_ctrl_reg(hw, BIT(4), 0);\n}\n\nstatic int _rtl92cu_set_media_status(struct ieee80211_hw *hw,\n\t\t\t\t     enum nl80211_iftype type)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 bt_msr = rtl_read_byte(rtlpriv, MSR);\n\tenum led_ctl_mode ledaction = LED_CTL_NO_LINK;\n\n\tbt_msr &= 0xfc;\n\tif (type == NL80211_IFTYPE_UNSPECIFIED || type ==\n\t    NL80211_IFTYPE_STATION) {\n\t\t_rtl92cu_stop_tx_beacon(hw);\n\t\t_rtl92cu_enable_bcn_sub_func(hw);\n\t} else if (type == NL80211_IFTYPE_ADHOC || type == NL80211_IFTYPE_AP) {\n\t\t_rtl92cu_resume_tx_beacon(hw);\n\t\t_rtl92cu_disable_bcn_sub_func(hw);\n\t} else {\n\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_WARNING,\n\t\t\t\"Set HW_VAR_MEDIA_STATUS:No such media status(%x)\\n\",\n\t\t\ttype);\n\t}\n\tswitch (type) {\n\tcase NL80211_IFTYPE_UNSPECIFIED:\n\t\tbt_msr |= MSR_NOLINK;\n\t\tledaction = LED_CTL_LINK;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\t\"Set Network type to NO LINK!\\n\");\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tbt_msr |= MSR_ADHOC;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\t\"Set Network type to Ad Hoc!\\n\");\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tbt_msr |= MSR_INFRA;\n\t\tledaction = LED_CTL_LINK;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\t\"Set Network type to STA!\\n\");\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\t\tbt_msr |= MSR_AP;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\t\"Set Network type to AP!\\n\");\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Network type %d not supported!\\n\", type);\n\t\tgoto error_out;\n\t}\n\trtl_write_byte(rtlpriv, MSR, bt_msr);\n\trtlpriv->cfg->ops->led_control(hw, ledaction);\n\tif ((bt_msr & MSR_MASK) == MSR_AP)\n\t\trtl_write_byte(rtlpriv, REG_BCNTCFG + 1, 0x00);\n\telse\n\t\trtl_write_byte(rtlpriv, REG_BCNTCFG + 1, 0x66);\n\treturn 0;\nerror_out:\n\treturn 1;\n}\n\nvoid rtl92cu_card_disable(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tstruct rtl_usb *rtlusb = rtl_usbdev(rtl_usbpriv(hw));\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tenum nl80211_iftype opmode;\n\n\tmac->link_state = MAC80211_NOLINK;\n\topmode = NL80211_IFTYPE_UNSPECIFIED;\n\t_rtl92cu_set_media_status(hw, opmode);\n\trtlpriv->cfg->ops->led_control(hw, LED_CTL_POWER_OFF);\n\tRT_SET_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_HALT_NIC);\n\tif (rtlusb->disablehwsm)\n\t\tcarddisable_hwsm(hw);\n\telse\n\t\tcarddisablewithout_hwsm(hw);\n\n\t \n\trtlpriv->phy.iqk_initialized = false;\n}\n\nvoid rtl92cu_set_check_bssid(struct ieee80211_hw *hw, bool check_bssid)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\n\tu32 reg_rcr;\n\n\tif (rtlpriv->psc.rfpwr_state != ERFON)\n\t\treturn;\n\n\trtlpriv->cfg->ops->get_hw_reg(hw, HW_VAR_RCR, (u8 *)(&reg_rcr));\n\n\tif (check_bssid) {\n\t\tu8 tmp;\n\n\t\tif (IS_NORMAL_CHIP(rtlhal->version)) {\n\t\t\treg_rcr |= (RCR_CBSSID_DATA | RCR_CBSSID_BCN);\n\t\t\ttmp = BIT(4);\n\t\t} else {\n\t\t\treg_rcr |= RCR_CBSSID;\n\t\t\ttmp = BIT(4) | BIT(5);\n\t\t}\n\t\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_RCR,\n\t\t\t\t\t      (u8 *) (&reg_rcr));\n\t\t_rtl92cu_set_bcn_ctrl_reg(hw, 0, tmp);\n\t} else {\n\t\tu8 tmp;\n\n\t\tif (IS_NORMAL_CHIP(rtlhal->version)) {\n\t\t\treg_rcr &= ~(RCR_CBSSID_DATA | RCR_CBSSID_BCN);\n\t\t\ttmp = BIT(4);\n\t\t} else {\n\t\t\treg_rcr &= ~RCR_CBSSID;\n\t\t\ttmp = BIT(4) | BIT(5);\n\t\t}\n\t\treg_rcr &= (~(RCR_CBSSID_DATA | RCR_CBSSID_BCN));\n\t\trtlpriv->cfg->ops->set_hw_reg(hw,\n\t\t\t\t\t      HW_VAR_RCR, (u8 *) (&reg_rcr));\n\t\t_rtl92cu_set_bcn_ctrl_reg(hw, tmp, 0);\n\t}\n}\n\n \n\nint rtl92cu_set_network_type(struct ieee80211_hw *hw, enum nl80211_iftype type)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\tif (_rtl92cu_set_media_status(hw, type))\n\t\treturn -EOPNOTSUPP;\n\n\tif (rtlpriv->mac80211.link_state == MAC80211_LINKED) {\n\t\tif (type != NL80211_IFTYPE_AP)\n\t\t\trtl92cu_set_check_bssid(hw, true);\n\t} else {\n\t\trtl92cu_set_check_bssid(hw, false);\n\t}\n\n\treturn 0;\n}\n\nstatic void _beacon_function_enable(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\t_rtl92cu_set_bcn_ctrl_reg(hw, (BIT(4) | BIT(3) | BIT(1)), 0x00);\n\trtl_write_byte(rtlpriv, REG_RD_CTRL+1, 0x6F);\n}\n\nvoid rtl92cu_set_beacon_related_registers(struct ieee80211_hw *hw)\n{\n\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tu16 bcn_interval, atim_window;\n\tu32 value32;\n\n\tbcn_interval = mac->beacon_interval;\n\tatim_window = 2;\t \n\trtl_write_word(rtlpriv, REG_ATIMWND, atim_window);\n\trtl_write_word(rtlpriv, REG_BCN_INTERVAL, bcn_interval);\n\t_rtl92cu_init_beacon_parameters(hw);\n\trtl_write_byte(rtlpriv, REG_SLOT, 0x09);\n\t \n\tvalue32 = rtl_read_dword(rtlpriv, REG_TCR);\n\tvalue32 &= ~TSFRST;\n\trtl_write_dword(rtlpriv, REG_TCR, value32);\n\tvalue32 |= TSFRST;\n\trtl_write_dword(rtlpriv, REG_TCR, value32);\n\trtl_dbg(rtlpriv, COMP_INIT | COMP_BEACON, DBG_LOUD,\n\t\t\"SetBeaconRelatedRegisters8192CUsb(): Set TCR(%x)\\n\",\n\t\tvalue32);\n\t \n\tif ((mac->opmode == NL80211_IFTYPE_ADHOC) ||\n\t    (mac->opmode == NL80211_IFTYPE_MESH_POINT) ||\n\t    (mac->opmode == NL80211_IFTYPE_AP)) {\n\t\trtl_write_byte(rtlpriv, REG_RXTSF_OFFSET_CCK, 0x50);\n\t\trtl_write_byte(rtlpriv, REG_RXTSF_OFFSET_OFDM, 0x50);\n\t}\n\t_beacon_function_enable(hw);\n}\n\nvoid rtl92cu_set_beacon_interval(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tu16 bcn_interval = mac->beacon_interval;\n\n\trtl_dbg(rtlpriv, COMP_BEACON, DBG_DMESG, \"beacon_interval:%d\\n\",\n\t\tbcn_interval);\n\trtl_write_word(rtlpriv, REG_BCN_INTERVAL, bcn_interval);\n}\n\nvoid rtl92cu_update_interrupt_mask(struct ieee80211_hw *hw,\n\t\t\t\t   u32 add_msr, u32 rm_msr)\n{\n}\n\nvoid rtl92cu_get_hw_reg(struct ieee80211_hw *hw, u8 variable, u8 *val)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\n\tswitch (variable) {\n\tcase HW_VAR_RCR:\n\t\t*((u32 *)(val)) = mac->rx_conf;\n\t\tbreak;\n\tcase HW_VAR_RF_STATE:\n\t\t*((enum rf_pwrstate *)(val)) = ppsc->rfpwr_state;\n\t\tbreak;\n\tcase HW_VAR_FWLPS_RF_ON:{\n\t\t\tenum rf_pwrstate rfstate;\n\t\t\tu32 val_rcr;\n\n\t\t\trtlpriv->cfg->ops->get_hw_reg(hw, HW_VAR_RF_STATE,\n\t\t\t\t\t\t      (u8 *)(&rfstate));\n\t\t\tif (rfstate == ERFOFF) {\n\t\t\t\t*((bool *) (val)) = true;\n\t\t\t} else {\n\t\t\t\tval_rcr = rtl_read_dword(rtlpriv, REG_RCR);\n\t\t\t\tval_rcr &= 0x00070000;\n\t\t\t\tif (val_rcr)\n\t\t\t\t\t*((bool *) (val)) = false;\n\t\t\t\telse\n\t\t\t\t\t*((bool *) (val)) = true;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_FW_PSMODE_STATUS:\n\t\t*((bool *) (val)) = ppsc->fw_current_inpsmode;\n\t\tbreak;\n\tcase HW_VAR_CORRECT_TSF:{\n\t\t\tu64 tsf;\n\t\t\tu32 *ptsf_low = (u32 *)&tsf;\n\t\t\tu32 *ptsf_high = ((u32 *)&tsf) + 1;\n\n\t\t\t*ptsf_high = rtl_read_dword(rtlpriv, (REG_TSFTR + 4));\n\t\t\t*ptsf_low = rtl_read_dword(rtlpriv, REG_TSFTR);\n\t\t\t*((u64 *)(val)) = tsf;\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_MGT_FILTER:\n\t\t*((u16 *) (val)) = rtl_read_word(rtlpriv, REG_RXFLTMAP0);\n\t\tbreak;\n\tcase HW_VAR_CTRL_FILTER:\n\t\t*((u16 *) (val)) = rtl_read_word(rtlpriv, REG_RXFLTMAP1);\n\t\tbreak;\n\tcase HW_VAR_DATA_FILTER:\n\t\t*((u16 *) (val)) = rtl_read_word(rtlpriv, REG_RXFLTMAP2);\n\t\tbreak;\n\tcase HAL_DEF_WOWLAN:\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"switch case %#x not processed\\n\", variable);\n\t\tbreak;\n\t}\n}\n\nstatic bool usb_cmd_send_packet(struct ieee80211_hw *hw, struct sk_buff *skb)\n{\n   \n\tdev_kfree_skb(skb);\n\n\treturn true;\n}\n\nvoid rtl92cu_set_hw_reg(struct ieee80211_hw *hw, u8 variable, u8 *val)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tenum wireless_mode wirelessmode = mac->mode;\n\tu8 idx = 0;\n\n\tswitch (variable) {\n\tcase HW_VAR_ETHER_ADDR:{\n\t\t\tfor (idx = 0; idx < ETH_ALEN; idx++) {\n\t\t\t\trtl_write_byte(rtlpriv, (REG_MACID + idx),\n\t\t\t\t\t       val[idx]);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_BASIC_RATE:{\n\t\t\tu16 rate_cfg = ((u16 *) val)[0];\n\t\t\tu8 rate_index = 0;\n\n\t\t\trate_cfg &= 0x15f;\n\t\t\t \n\t\t\t \n\t\t\trate_cfg |= 0x01;\n\t\t\trtl_write_byte(rtlpriv, REG_RRSR, rate_cfg & 0xff);\n\t\t\trtl_write_byte(rtlpriv, REG_RRSR + 1,\n\t\t\t\t       (rate_cfg >> 8) & 0xff);\n\t\t\twhile (rate_cfg > 0x1) {\n\t\t\t\trate_cfg >>= 1;\n\t\t\t\trate_index++;\n\t\t\t}\n\t\t\trtl_write_byte(rtlpriv, REG_INIRTS_RATE_SEL,\n\t\t\t\t       rate_index);\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_BSSID:{\n\t\t\tfor (idx = 0; idx < ETH_ALEN; idx++) {\n\t\t\t\trtl_write_byte(rtlpriv, (REG_BSSID + idx),\n\t\t\t\t\t       val[idx]);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_SIFS:{\n\t\t\trtl_write_byte(rtlpriv, REG_SIFS_CCK + 1, val[0]);\n\t\t\trtl_write_byte(rtlpriv, REG_SIFS_OFDM + 1, val[1]);\n\t\t\trtl_write_byte(rtlpriv, REG_SPEC_SIFS + 1, val[0]);\n\t\t\trtl_write_byte(rtlpriv, REG_MAC_SPEC_SIFS + 1, val[0]);\n\t\t\trtl_write_byte(rtlpriv, REG_R2T_SIFS+1, val[0]);\n\t\t\trtl_write_byte(rtlpriv, REG_T2T_SIFS+1, val[0]);\n\t\t\trtl_dbg(rtlpriv, COMP_MLME, DBG_LOUD, \"HW_VAR_SIFS\\n\");\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_SLOT_TIME:{\n\t\t\tu8 e_aci;\n\t\t\tu8 QOS_MODE = 1;\n\n\t\t\trtl_write_byte(rtlpriv, REG_SLOT, val[0]);\n\t\t\trtl_dbg(rtlpriv, COMP_MLME, DBG_LOUD,\n\t\t\t\t\"HW_VAR_SLOT_TIME %x\\n\", val[0]);\n\t\t\tif (QOS_MODE) {\n\t\t\t\tfor (e_aci = 0; e_aci < AC_MAX; e_aci++)\n\t\t\t\t\trtlpriv->cfg->ops->set_hw_reg(hw,\n\t\t\t\t\t\t\t\tHW_VAR_AC_PARAM,\n\t\t\t\t\t\t\t\t&e_aci);\n\t\t\t} else {\n\t\t\t\tu8 sifstime = 0;\n\t\t\t\tu8\tu1baifs;\n\n\t\t\t\tif (IS_WIRELESS_MODE_A(wirelessmode) ||\n\t\t\t\t    IS_WIRELESS_MODE_N_24G(wirelessmode) ||\n\t\t\t\t    IS_WIRELESS_MODE_N_5G(wirelessmode))\n\t\t\t\t\tsifstime = 16;\n\t\t\t\telse\n\t\t\t\t\tsifstime = 10;\n\t\t\t\tu1baifs = sifstime + (2 *  val[0]);\n\t\t\t\trtl_write_byte(rtlpriv, REG_EDCA_VO_PARAM,\n\t\t\t\t\t       u1baifs);\n\t\t\t\trtl_write_byte(rtlpriv, REG_EDCA_VI_PARAM,\n\t\t\t\t\t       u1baifs);\n\t\t\t\trtl_write_byte(rtlpriv, REG_EDCA_BE_PARAM,\n\t\t\t\t\t       u1baifs);\n\t\t\t\trtl_write_byte(rtlpriv, REG_EDCA_BK_PARAM,\n\t\t\t\t\t       u1baifs);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_ACK_PREAMBLE:{\n\t\t\tu8 reg_tmp;\n\t\t\tu8 short_preamble = (bool)*val;\n\n\t\t\treg_tmp = 0;\n\t\t\tif (short_preamble)\n\t\t\t\treg_tmp |= 0x80;\n\t\t\trtl_write_byte(rtlpriv, REG_RRSR + 2, reg_tmp);\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_AMPDU_MIN_SPACE:{\n\t\t\tu8 min_spacing_to_set;\n\t\t\tu8 sec_min_space;\n\n\t\t\tmin_spacing_to_set = *val;\n\t\t\tif (min_spacing_to_set <= 7) {\n\t\t\t\tswitch (rtlpriv->sec.pairwise_enc_algorithm) {\n\t\t\t\tcase NO_ENCRYPTION:\n\t\t\t\tcase AESCCMP_ENCRYPTION:\n\t\t\t\t\tsec_min_space = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase WEP40_ENCRYPTION:\n\t\t\t\tcase WEP104_ENCRYPTION:\n\t\t\t\tcase TKIP_ENCRYPTION:\n\t\t\t\t\tsec_min_space = 6;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tsec_min_space = 7;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (min_spacing_to_set < sec_min_space)\n\t\t\t\t\tmin_spacing_to_set = sec_min_space;\n\t\t\t\tmac->min_space_cfg = ((mac->min_space_cfg &\n\t\t\t\t\t\t     0xf8) |\n\t\t\t\t\t\t     min_spacing_to_set);\n\t\t\t\t*val = min_spacing_to_set;\n\t\t\t\trtl_dbg(rtlpriv, COMP_MLME, DBG_LOUD,\n\t\t\t\t\t\"Set HW_VAR_AMPDU_MIN_SPACE: %#x\\n\",\n\t\t\t\t\tmac->min_space_cfg);\n\t\t\t\trtl_write_byte(rtlpriv, REG_AMPDU_MIN_SPACE,\n\t\t\t\t\t       mac->min_space_cfg);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_SHORTGI_DENSITY:{\n\t\t\tu8 density_to_set;\n\n\t\t\tdensity_to_set = *val;\n\t\t\tdensity_to_set &= 0x1f;\n\t\t\tmac->min_space_cfg &= 0x07;\n\t\t\tmac->min_space_cfg |= (density_to_set << 3);\n\t\t\trtl_dbg(rtlpriv, COMP_MLME, DBG_LOUD,\n\t\t\t\t\"Set HW_VAR_SHORTGI_DENSITY: %#x\\n\",\n\t\t\t\tmac->min_space_cfg);\n\t\t\trtl_write_byte(rtlpriv, REG_AMPDU_MIN_SPACE,\n\t\t\t\t       mac->min_space_cfg);\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_AMPDU_FACTOR:{\n\t\t\tu8 regtoset_normal[4] = {0x41, 0xa8, 0x72, 0xb9};\n\t\t\tu8 factor_toset;\n\t\t\tu8 *p_regtoset = NULL;\n\t\t\tu8 index = 0;\n\n\t\t\tp_regtoset = regtoset_normal;\n\t\t\tfactor_toset = *val;\n\t\t\tif (factor_toset <= 3) {\n\t\t\t\tfactor_toset = (1 << (factor_toset + 2));\n\t\t\t\tif (factor_toset > 0xf)\n\t\t\t\t\tfactor_toset = 0xf;\n\t\t\t\tfor (index = 0; index < 4; index++) {\n\t\t\t\t\tif ((p_regtoset[index] & 0xf0) >\n\t\t\t\t\t    (factor_toset << 4))\n\t\t\t\t\t\tp_regtoset[index] =\n\t\t\t\t\t\t     (p_regtoset[index] & 0x0f)\n\t\t\t\t\t\t     | (factor_toset << 4);\n\t\t\t\t\tif ((p_regtoset[index] & 0x0f) >\n\t\t\t\t\t     factor_toset)\n\t\t\t\t\t\tp_regtoset[index] =\n\t\t\t\t\t\t     (p_regtoset[index] & 0xf0)\n\t\t\t\t\t\t     | (factor_toset);\n\t\t\t\t\trtl_write_byte(rtlpriv,\n\t\t\t\t\t\t       (REG_AGGLEN_LMT + index),\n\t\t\t\t\t\t       p_regtoset[index]);\n\t\t\t\t}\n\t\t\t\trtl_dbg(rtlpriv, COMP_MLME, DBG_LOUD,\n\t\t\t\t\t\"Set HW_VAR_AMPDU_FACTOR: %#x\\n\",\n\t\t\t\t\tfactor_toset);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_AC_PARAM:{\n\t\t\tu8 e_aci = *val;\n\t\t\tu32 u4b_ac_param;\n\t\t\tu16 cw_min = le16_to_cpu(mac->ac[e_aci].cw_min);\n\t\t\tu16 cw_max = le16_to_cpu(mac->ac[e_aci].cw_max);\n\t\t\tu16 tx_op = le16_to_cpu(mac->ac[e_aci].tx_op);\n\n\t\t\tu4b_ac_param = (u32) mac->ac[e_aci].aifs;\n\t\t\tu4b_ac_param |= (u32) ((cw_min & 0xF) <<\n\t\t\t\t\t AC_PARAM_ECW_MIN_OFFSET);\n\t\t\tu4b_ac_param |= (u32) ((cw_max & 0xF) <<\n\t\t\t\t\t AC_PARAM_ECW_MAX_OFFSET);\n\t\t\tu4b_ac_param |= (u32) tx_op << AC_PARAM_TXOP_OFFSET;\n\t\t\trtl_dbg(rtlpriv, COMP_MLME, DBG_LOUD,\n\t\t\t\t\"queue:%x, ac_param:%x\\n\",\n\t\t\t\te_aci, u4b_ac_param);\n\t\t\tswitch (e_aci) {\n\t\t\tcase AC1_BK:\n\t\t\t\trtl_write_dword(rtlpriv, REG_EDCA_BK_PARAM,\n\t\t\t\t\t\tu4b_ac_param);\n\t\t\t\tbreak;\n\t\t\tcase AC0_BE:\n\t\t\t\trtl_write_dword(rtlpriv, REG_EDCA_BE_PARAM,\n\t\t\t\t\t\tu4b_ac_param);\n\t\t\t\tbreak;\n\t\t\tcase AC2_VI:\n\t\t\t\trtl_write_dword(rtlpriv, REG_EDCA_VI_PARAM,\n\t\t\t\t\t\tu4b_ac_param);\n\t\t\t\tbreak;\n\t\t\tcase AC3_VO:\n\t\t\t\trtl_write_dword(rtlpriv, REG_EDCA_VO_PARAM,\n\t\t\t\t\t\tu4b_ac_param);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tWARN_ONCE(true, \"rtl8192cu: invalid aci: %d !\\n\",\n\t\t\t\t\t  e_aci);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_RCR:{\n\t\t\trtl_write_dword(rtlpriv, REG_RCR, ((u32 *) (val))[0]);\n\t\t\tmac->rx_conf = ((u32 *) (val))[0];\n\t\t\trtl_dbg(rtlpriv, COMP_RECV, DBG_DMESG,\n\t\t\t\t\"### Set RCR(0x%08x) ###\\n\", mac->rx_conf);\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_RETRY_LIMIT:{\n\t\t\tu8 retry_limit = val[0];\n\n\t\t\trtl_write_word(rtlpriv, REG_RL,\n\t\t\t\t       retry_limit << RETRY_LIMIT_SHORT_SHIFT |\n\t\t\t\t       retry_limit << RETRY_LIMIT_LONG_SHIFT);\n\t\t\trtl_dbg(rtlpriv, COMP_MLME, DBG_DMESG,\n\t\t\t\t\"Set HW_VAR_RETRY_LIMIT(0x%08x)\\n\",\n\t\t\t\tretry_limit);\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_DUAL_TSF_RST:\n\t\trtl_write_byte(rtlpriv, REG_DUAL_TSF_RST, (BIT(0) | BIT(1)));\n\t\tbreak;\n\tcase HW_VAR_EFUSE_BYTES:\n\t\trtlefuse->efuse_usedbytes = *((u16 *) val);\n\t\tbreak;\n\tcase HW_VAR_EFUSE_USAGE:\n\t\trtlefuse->efuse_usedpercentage = *val;\n\t\tbreak;\n\tcase HW_VAR_IO_CMD:\n\t\trtl92c_phy_set_io_cmd(hw, (*(enum io_type *)val));\n\t\tbreak;\n\tcase HW_VAR_WPA_CONFIG:\n\t\trtl_write_byte(rtlpriv, REG_SECCFG, *val);\n\t\tbreak;\n\tcase HW_VAR_SET_RPWM:{\n\t\t\tu8 rpwm_val = rtl_read_byte(rtlpriv, REG_USB_HRPWM);\n\n\t\t\tif (rpwm_val & BIT(7))\n\t\t\t\trtl_write_byte(rtlpriv, REG_USB_HRPWM, *val);\n\t\t\telse\n\t\t\t\trtl_write_byte(rtlpriv, REG_USB_HRPWM,\n\t\t\t\t\t       *val | BIT(7));\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_H2C_FW_PWRMODE:{\n\t\t\tu8 psmode = *val;\n\n\t\t\tif ((psmode != FW_PS_ACTIVE_MODE) &&\n\t\t\t   (!IS_92C_SERIAL(rtlhal->version)))\n\t\t\t\trtl92c_dm_rf_saving(hw, true);\n\t\t\trtl92c_set_fw_pwrmode_cmd(hw, (*val));\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_FW_PSMODE_STATUS:\n\t\tppsc->fw_current_inpsmode = *((bool *) val);\n\t\tbreak;\n\tcase HW_VAR_H2C_FW_JOINBSSRPT:{\n\t\t\tu8 mstatus = *val;\n\t\t\tu8 tmp_reg422;\n\t\t\tbool recover = false;\n\n\t\t\tif (mstatus == RT_MEDIA_CONNECT) {\n\t\t\t\trtlpriv->cfg->ops->set_hw_reg(hw,\n\t\t\t\t\t\t\t HW_VAR_AID, NULL);\n\t\t\t\trtl_write_byte(rtlpriv, REG_CR + 1, 0x03);\n\t\t\t\t_rtl92cu_set_bcn_ctrl_reg(hw, 0, BIT(3));\n\t\t\t\t_rtl92cu_set_bcn_ctrl_reg(hw, BIT(4), 0);\n\t\t\t\ttmp_reg422 = rtl_read_byte(rtlpriv,\n\t\t\t\t\t\t\tREG_FWHW_TXQ_CTRL + 2);\n\t\t\t\tif (tmp_reg422 & BIT(6))\n\t\t\t\t\trecover = true;\n\t\t\t\trtl_write_byte(rtlpriv, REG_FWHW_TXQ_CTRL + 2,\n\t\t\t\t\t       tmp_reg422 & (~BIT(6)));\n\t\t\t\trtl92c_set_fw_rsvdpagepkt(hw,\n\t\t\t\t\t\t\t  &usb_cmd_send_packet);\n\t\t\t\t_rtl92cu_set_bcn_ctrl_reg(hw, BIT(3), 0);\n\t\t\t\t_rtl92cu_set_bcn_ctrl_reg(hw, 0, BIT(4));\n\t\t\t\tif (recover)\n\t\t\t\t\trtl_write_byte(rtlpriv,\n\t\t\t\t\t\t REG_FWHW_TXQ_CTRL + 2,\n\t\t\t\t\t\ttmp_reg422 | BIT(6));\n\t\t\t\trtl_write_byte(rtlpriv, REG_CR + 1, 0x02);\n\t\t\t}\n\t\t\trtl92c_set_fw_joinbss_report_cmd(hw, (*val));\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_AID:{\n\t\t\tu16 u2btmp;\n\n\t\t\tu2btmp = rtl_read_word(rtlpriv, REG_BCN_PSR_RPT);\n\t\t\tu2btmp &= 0xC000;\n\t\t\trtl_write_word(rtlpriv, REG_BCN_PSR_RPT,\n\t\t\t\t       (u2btmp | mac->assoc_id));\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_CORRECT_TSF:{\n\t\t\tu8 btype_ibss = val[0];\n\n\t\t\tif (btype_ibss)\n\t\t\t\t_rtl92cu_stop_tx_beacon(hw);\n\t\t\t_rtl92cu_set_bcn_ctrl_reg(hw, 0, BIT(3));\n\t\t\trtl_write_dword(rtlpriv, REG_TSFTR, (u32)(mac->tsf &\n\t\t\t\t\t0xffffffff));\n\t\t\trtl_write_dword(rtlpriv, REG_TSFTR + 4,\n\t\t\t\t\t(u32)((mac->tsf >> 32) & 0xffffffff));\n\t\t\t_rtl92cu_set_bcn_ctrl_reg(hw, BIT(3), 0);\n\t\t\tif (btype_ibss)\n\t\t\t\t_rtl92cu_resume_tx_beacon(hw);\n\t\t\tbreak;\n\t\t}\n\tcase HW_VAR_MGT_FILTER:\n\t\trtl_write_word(rtlpriv, REG_RXFLTMAP0, *(u16 *)val);\n\t\tmac->rx_mgt_filter = *(u16 *)val;\n\t\tbreak;\n\tcase HW_VAR_CTRL_FILTER:\n\t\trtl_write_word(rtlpriv, REG_RXFLTMAP1, *(u16 *)val);\n\t\tmac->rx_ctrl_filter = *(u16 *)val;\n\t\tbreak;\n\tcase HW_VAR_DATA_FILTER:\n\t\trtl_write_word(rtlpriv, REG_RXFLTMAP2, *(u16 *)val);\n\t\tmac->rx_data_filter = *(u16 *)val;\n\t\tbreak;\n\tcase HW_VAR_KEEP_ALIVE:{\n\t\t\tu8 array[2];\n\n\t\t\tarray[0] = 0xff;\n\t\t\tarray[1] = *((u8 *)val);\n\t\t\trtl92c_fill_h2c_cmd(hw, H2C_92C_KEEP_ALIVE_CTRL, 2,\n\t\t\t\t\t    array);\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\tpr_err(\"switch case %#x not processed\\n\", variable);\n\t\tbreak;\n\t}\n}\n\nstatic void rtl92cu_update_hal_rate_table(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct ieee80211_sta *sta)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tu32 ratr_value;\n\tu8 ratr_index = 0;\n\tu8 nmode = mac->ht_enable;\n\tu8 mimo_ps = IEEE80211_SMPS_OFF;\n\tu16 shortgi_rate;\n\tu32 tmp_ratr_value;\n\tu8 curtxbw_40mhz = mac->bw_40;\n\tu8 curshortgi_40mhz = (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_SGI_40) ?\n\t\t\t       1 : 0;\n\tu8 curshortgi_20mhz = (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_SGI_20) ?\n\t\t\t       1 : 0;\n\tenum wireless_mode wirelessmode = mac->mode;\n\n\tif (rtlhal->current_bandtype == BAND_ON_5G)\n\t\tratr_value = sta->deflink.supp_rates[1] << 4;\n\telse\n\t\tratr_value = sta->deflink.supp_rates[0];\n\tif (mac->opmode == NL80211_IFTYPE_ADHOC)\n\t\tratr_value = 0xfff;\n\n\tratr_value |= (sta->deflink.ht_cap.mcs.rx_mask[1] << 20 |\n\t\t\tsta->deflink.ht_cap.mcs.rx_mask[0] << 12);\n\tswitch (wirelessmode) {\n\tcase WIRELESS_MODE_B:\n\t\tif (ratr_value & 0x0000000c)\n\t\t\tratr_value &= 0x0000000d;\n\t\telse\n\t\t\tratr_value &= 0x0000000f;\n\t\tbreak;\n\tcase WIRELESS_MODE_G:\n\t\tratr_value &= 0x00000FF5;\n\t\tbreak;\n\tcase WIRELESS_MODE_N_24G:\n\tcase WIRELESS_MODE_N_5G:\n\t\tnmode = 1;\n\t\tif (mimo_ps == IEEE80211_SMPS_STATIC) {\n\t\t\tratr_value &= 0x0007F005;\n\t\t} else {\n\t\t\tu32 ratr_mask;\n\n\t\t\tif (get_rf_type(rtlphy) == RF_1T2R ||\n\t\t\t    get_rf_type(rtlphy) == RF_1T1R)\n\t\t\t\tratr_mask = 0x000ff005;\n\t\t\telse\n\t\t\t\tratr_mask = 0x0f0ff005;\n\n\t\t\tratr_value &= ratr_mask;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif (rtlphy->rf_type == RF_1T2R)\n\t\t\tratr_value &= 0x000ff0ff;\n\t\telse\n\t\t\tratr_value &= 0x0f0ff0ff;\n\n\t\tbreak;\n\t}\n\n\tratr_value &= 0x0FFFFFFF;\n\n\tif (nmode && ((curtxbw_40mhz &&\n\t\t\t curshortgi_40mhz) || (!curtxbw_40mhz &&\n\t\t\t\t\t       curshortgi_20mhz))) {\n\t\tratr_value |= 0x10000000;\n\t\ttmp_ratr_value = (ratr_value >> 12);\n\n\t\tfor (shortgi_rate = 15; shortgi_rate > 0; shortgi_rate--) {\n\t\t\tif ((1 << shortgi_rate) & tmp_ratr_value)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tshortgi_rate = (shortgi_rate << 12) | (shortgi_rate << 8) |\n\t\t    (shortgi_rate << 4) | (shortgi_rate);\n\t}\n\n\trtl_write_dword(rtlpriv, REG_ARFR0 + ratr_index * 4, ratr_value);\n\n\trtl_dbg(rtlpriv, COMP_RATR, DBG_DMESG, \"%x\\n\",\n\t\trtl_read_dword(rtlpriv, REG_ARFR0));\n}\n\nstatic void rtl92cu_update_hal_rate_mask(struct ieee80211_hw *hw,\n\t\t\t\t\t struct ieee80211_sta *sta,\n\t\t\t\t\t u8 rssi_level, bool update_bw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_sta_info *sta_entry = NULL;\n\tu32 ratr_bitmap;\n\tu8 ratr_index;\n\tu8 curtxbw_40mhz = (sta->deflink.bandwidth >= IEEE80211_STA_RX_BW_40) ? 1 : 0;\n\tu8 curshortgi_40mhz = curtxbw_40mhz &&\n\t\t\t      (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_SGI_40) ?\n\t\t\t\t1 : 0;\n\tu8 curshortgi_20mhz = (sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_SGI_20) ?\n\t\t\t\t1 : 0;\n\tenum wireless_mode wirelessmode = 0;\n\tbool shortgi = false;\n\tu8 rate_mask[5];\n\tu8 macid = 0;\n\tu8 mimo_ps = IEEE80211_SMPS_OFF;\n\n\tsta_entry = (struct rtl_sta_info *) sta->drv_priv;\n\twirelessmode = sta_entry->wireless_mode;\n\tif (mac->opmode == NL80211_IFTYPE_STATION ||\n\t    mac->opmode == NL80211_IFTYPE_MESH_POINT)\n\t\tcurtxbw_40mhz = mac->bw_40;\n\telse if (mac->opmode == NL80211_IFTYPE_AP ||\n\t\tmac->opmode == NL80211_IFTYPE_ADHOC)\n\t\tmacid = sta->aid + 1;\n\n\tif (rtlhal->current_bandtype == BAND_ON_5G)\n\t\tratr_bitmap = sta->deflink.supp_rates[1] << 4;\n\telse\n\t\tratr_bitmap = sta->deflink.supp_rates[0];\n\tif (mac->opmode == NL80211_IFTYPE_ADHOC)\n\t\tratr_bitmap = 0xfff;\n\tratr_bitmap |= (sta->deflink.ht_cap.mcs.rx_mask[1] << 20 |\n\t\t\tsta->deflink.ht_cap.mcs.rx_mask[0] << 12);\n\tswitch (wirelessmode) {\n\tcase WIRELESS_MODE_B:\n\t\tratr_index = RATR_INX_WIRELESS_B;\n\t\tif (ratr_bitmap & 0x0000000c)\n\t\t\tratr_bitmap &= 0x0000000d;\n\t\telse\n\t\t\tratr_bitmap &= 0x0000000f;\n\t\tbreak;\n\tcase WIRELESS_MODE_G:\n\t\tratr_index = RATR_INX_WIRELESS_GB;\n\n\t\tif (rssi_level == 1)\n\t\t\tratr_bitmap &= 0x00000f00;\n\t\telse if (rssi_level == 2)\n\t\t\tratr_bitmap &= 0x00000ff0;\n\t\telse\n\t\t\tratr_bitmap &= 0x00000ff5;\n\t\tbreak;\n\tcase WIRELESS_MODE_A:\n\t\tratr_index = RATR_INX_WIRELESS_A;\n\t\tratr_bitmap &= 0x00000ff0;\n\t\tbreak;\n\tcase WIRELESS_MODE_N_24G:\n\tcase WIRELESS_MODE_N_5G:\n\t\tratr_index = RATR_INX_WIRELESS_NGB;\n\n\t\tif (mimo_ps == IEEE80211_SMPS_STATIC) {\n\t\t\tif (rssi_level == 1)\n\t\t\t\tratr_bitmap &= 0x00070000;\n\t\t\telse if (rssi_level == 2)\n\t\t\t\tratr_bitmap &= 0x0007f000;\n\t\t\telse\n\t\t\t\tratr_bitmap &= 0x0007f005;\n\t\t} else {\n\t\t\tif (rtlphy->rf_type == RF_1T2R ||\n\t\t\t    rtlphy->rf_type == RF_1T1R) {\n\t\t\t\tif (curtxbw_40mhz) {\n\t\t\t\t\tif (rssi_level == 1)\n\t\t\t\t\t\tratr_bitmap &= 0x000f0000;\n\t\t\t\t\telse if (rssi_level == 2)\n\t\t\t\t\t\tratr_bitmap &= 0x000ff000;\n\t\t\t\t\telse\n\t\t\t\t\t\tratr_bitmap &= 0x000ff015;\n\t\t\t\t} else {\n\t\t\t\t\tif (rssi_level == 1)\n\t\t\t\t\t\tratr_bitmap &= 0x000f0000;\n\t\t\t\t\telse if (rssi_level == 2)\n\t\t\t\t\t\tratr_bitmap &= 0x000ff000;\n\t\t\t\t\telse\n\t\t\t\t\t\tratr_bitmap &= 0x000ff005;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (curtxbw_40mhz) {\n\t\t\t\t\tif (rssi_level == 1)\n\t\t\t\t\t\tratr_bitmap &= 0x0f0f0000;\n\t\t\t\t\telse if (rssi_level == 2)\n\t\t\t\t\t\tratr_bitmap &= 0x0f0ff000;\n\t\t\t\t\telse\n\t\t\t\t\t\tratr_bitmap &= 0x0f0ff015;\n\t\t\t\t} else {\n\t\t\t\t\tif (rssi_level == 1)\n\t\t\t\t\t\tratr_bitmap &= 0x0f0f0000;\n\t\t\t\t\telse if (rssi_level == 2)\n\t\t\t\t\t\tratr_bitmap &= 0x0f0ff000;\n\t\t\t\t\telse\n\t\t\t\t\t\tratr_bitmap &= 0x0f0ff005;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ((curtxbw_40mhz && curshortgi_40mhz) ||\n\t\t    (!curtxbw_40mhz && curshortgi_20mhz)) {\n\n\t\t\tif (macid == 0)\n\t\t\t\tshortgi = true;\n\t\t\telse if (macid == 1)\n\t\t\t\tshortgi = false;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tratr_index = RATR_INX_WIRELESS_NGB;\n\n\t\tif (rtlphy->rf_type == RF_1T2R)\n\t\t\tratr_bitmap &= 0x000ff0ff;\n\t\telse\n\t\t\tratr_bitmap &= 0x0f0ff0ff;\n\t\tbreak;\n\t}\n\tsta_entry->ratr_index = ratr_index;\n\n\trtl_dbg(rtlpriv, COMP_RATR, DBG_DMESG,\n\t\t\"ratr_bitmap :%x\\n\", ratr_bitmap);\n\t*(u32 *)&rate_mask = (ratr_bitmap & 0x0fffffff) |\n\t\t\t\t     (ratr_index << 28);\n\trate_mask[4] = macid | (shortgi ? 0x20 : 0x00) | 0x80;\n\trtl_dbg(rtlpriv, COMP_RATR, DBG_DMESG,\n\t\t\"Rate_index:%x, ratr_val:%x, %5phC\\n\",\n\t\tratr_index, ratr_bitmap, rate_mask);\n\tmemcpy(rtlpriv->rate_mask, rate_mask, 5);\n\t \n\tschedule_work(&rtlpriv->works.fill_h2c_cmd);\n\n\tif (macid != 0)\n\t\tsta_entry->ratr_index = ratr_index;\n}\n\nvoid rtl92cu_update_hal_rate_tbl(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_sta *sta,\n\t\t\t\t u8 rssi_level, bool update_bw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\tif (rtlpriv->dm.useramask)\n\t\trtl92cu_update_hal_rate_mask(hw, sta, rssi_level, update_bw);\n\telse\n\t\trtl92cu_update_hal_rate_table(hw, sta);\n}\n\nvoid rtl92cu_update_channel_access_setting(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tu16 sifs_timer;\n\n\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_SLOT_TIME,\n\t\t\t\t      &mac->slot_time);\n\tif (!mac->ht_enable)\n\t\tsifs_timer = 0x0a0a;\n\telse\n\t\tsifs_timer = 0x0e0e;\n\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_SIFS, (u8 *)&sifs_timer);\n}\n\nbool rtl92cu_gpio_radio_on_off_checking(struct ieee80211_hw *hw, u8 * valid)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tenum rf_pwrstate e_rfpowerstate_toset, cur_rfstate;\n\tu8 u1tmp = 0;\n\tbool actuallyset = false;\n\tunsigned long flag = 0;\n\t \n\tu8 usb_autosuspend = 0;\n\n\tif (ppsc->swrf_processing)\n\t\treturn false;\n\tspin_lock_irqsave(&rtlpriv->locks.rf_ps_lock, flag);\n\tif (ppsc->rfchange_inprogress) {\n\t\tspin_unlock_irqrestore(&rtlpriv->locks.rf_ps_lock, flag);\n\t\treturn false;\n\t} else {\n\t\tppsc->rfchange_inprogress = true;\n\t\tspin_unlock_irqrestore(&rtlpriv->locks.rf_ps_lock, flag);\n\t}\n\tcur_rfstate = ppsc->rfpwr_state;\n\tif (usb_autosuspend) {\n\t\t \n\t} else {\n\t\tif (ppsc->pwrdown_mode) {\n\t\t\tu1tmp = rtl_read_byte(rtlpriv, REG_HSISR);\n\t\t\te_rfpowerstate_toset = (u1tmp & BIT(7)) ?\n\t\t\t\t\t       ERFOFF : ERFON;\n\t\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_DMESG,\n\t\t\t\t\"pwrdown, 0x5c(BIT7)=%02x\\n\", u1tmp);\n\t\t} else {\n\t\t\trtl_write_byte(rtlpriv, REG_MAC_PINMUX_CFG,\n\t\t\t\t       rtl_read_byte(rtlpriv,\n\t\t\t\t       REG_MAC_PINMUX_CFG) & ~(BIT(3)));\n\t\t\tu1tmp = rtl_read_byte(rtlpriv, REG_GPIO_IO_SEL);\n\t\t\te_rfpowerstate_toset  = (u1tmp & BIT(3)) ?\n\t\t\t\t\t\t ERFON : ERFOFF;\n\t\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_DMESG,\n\t\t\t\t\"GPIO_IN=%02x\\n\", u1tmp);\n\t\t}\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD, \"N-SS RF =%x\\n\",\n\t\t\te_rfpowerstate_toset);\n\t}\n\tif ((ppsc->hwradiooff) && (e_rfpowerstate_toset == ERFON)) {\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD,\n\t\t\t\"GPIOChangeRF  - HW Radio ON, RF ON\\n\");\n\t\tppsc->hwradiooff = false;\n\t\tactuallyset = true;\n\t} else if ((!ppsc->hwradiooff) && (e_rfpowerstate_toset  ==\n\t\t    ERFOFF)) {\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD,\n\t\t\t\"GPIOChangeRF  - HW Radio OFF\\n\");\n\t\tppsc->hwradiooff = true;\n\t\tactuallyset = true;\n\t} else {\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD,\n\t\t\t\"pHalData->bHwRadioOff and eRfPowerStateToSet do not match: pHalData->bHwRadioOff %x, eRfPowerStateToSet %x\\n\",\n\t\t\t ppsc->hwradiooff, e_rfpowerstate_toset);\n\t}\n\tif (actuallyset) {\n\t\tppsc->hwradiooff = true;\n\t\tif (e_rfpowerstate_toset == ERFON) {\n\t\t\tif ((ppsc->reg_rfps_level  & RT_RF_OFF_LEVL_ASPM) &&\n\t\t\t     RT_IN_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_ASPM))\n\t\t\t\tRT_CLEAR_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_ASPM);\n\t\t\telse if ((ppsc->reg_rfps_level  & RT_RF_OFF_LEVL_PCI_D3)\n\t\t\t\t && RT_IN_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_PCI_D3))\n\t\t\t\tRT_CLEAR_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_PCI_D3);\n\t\t}\n\t\tspin_lock_irqsave(&rtlpriv->locks.rf_ps_lock, flag);\n\t\tppsc->rfchange_inprogress = false;\n\t\tspin_unlock_irqrestore(&rtlpriv->locks.rf_ps_lock, flag);\n\t\t \n\t\tif (ppsc->pwrdown_mode && e_rfpowerstate_toset == ERFOFF) {\n\t\t\t \n\t\t\trtl_write_byte(rtlpriv, REG_RSV_CTRL, 0x0);\n\t\t\trtl_write_word(rtlpriv, REG_APS_FSMCO, 0x8812);\n\t\t}\n\t\tif (e_rfpowerstate_toset == ERFOFF) {\n\t\t\tif (ppsc->reg_rfps_level  & RT_RF_OFF_LEVL_ASPM)\n\t\t\t\tRT_SET_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_ASPM);\n\t\t\telse if (ppsc->reg_rfps_level & RT_RF_OFF_LEVL_PCI_D3)\n\t\t\t\tRT_SET_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_PCI_D3);\n\t\t}\n\t} else if (e_rfpowerstate_toset == ERFOFF || cur_rfstate == ERFOFF) {\n\t\t \n\t\tif (ppsc->reg_rfps_level  & RT_RF_OFF_LEVL_ASPM)\n\t\t\tRT_SET_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_ASPM);\n\t\telse if (ppsc->reg_rfps_level  & RT_RF_OFF_LEVL_PCI_D3)\n\t\t\tRT_SET_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_PCI_D3);\n\t\tspin_lock_irqsave(&rtlpriv->locks.rf_ps_lock, flag);\n\t\tppsc->rfchange_inprogress = false;\n\t\tspin_unlock_irqrestore(&rtlpriv->locks.rf_ps_lock, flag);\n\t} else {\n\t\tspin_lock_irqsave(&rtlpriv->locks.rf_ps_lock, flag);\n\t\tppsc->rfchange_inprogress = false;\n\t\tspin_unlock_irqrestore(&rtlpriv->locks.rf_ps_lock, flag);\n\t}\n\t*valid = 1;\n\treturn !ppsc->hwradiooff;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}