{
  "module_name": "phy.c",
  "hash_id": "fc48fa1db123874baea8192e47ce99b5ddae3950444c44538938a938a9d9ef56",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtlwifi/rtl8188ee/phy.c",
  "human_readable_source": "\n \n\n#include \"../wifi.h\"\n#include \"../pci.h\"\n#include \"../ps.h\"\n#include \"reg.h\"\n#include \"def.h\"\n#include \"phy.h\"\n#include \"rf.h\"\n#include \"dm.h\"\n#include \"table.h\"\n\nstatic u32 _rtl88e_phy_rf_serial_read(struct ieee80211_hw *hw,\n\t\t\t\t      enum radio_path rfpath, u32 offset);\nstatic void _rtl88e_phy_rf_serial_write(struct ieee80211_hw *hw,\n\t\t\t\t\tenum radio_path rfpath, u32 offset,\n\t\t\t\t\tu32 data);\nstatic bool _rtl88e_phy_bb8188e_config_parafile(struct ieee80211_hw *hw);\nstatic bool _rtl88e_phy_config_mac_with_headerfile(struct ieee80211_hw *hw);\nstatic bool phy_config_bb_with_headerfile(struct ieee80211_hw *hw,\n\t\t\t\t\t  u8 configtype);\nstatic bool phy_config_bb_with_pghdr(struct ieee80211_hw *hw,\n\t\t\t\t     u8 configtype);\nstatic void _rtl88e_phy_init_bb_rf_register_definition(struct ieee80211_hw *hw);\nstatic bool _rtl88e_phy_set_sw_chnl_cmdarray(struct swchnlcmd *cmdtable,\n\t\t\t\t\t     u32 cmdtableidx, u32 cmdtablesz,\n\t\t\t\t\t     enum swchnlcmd_id cmdid, u32 para1,\n\t\t\t\t\t     u32 para2, u32 msdelay);\nstatic bool _rtl88e_phy_sw_chnl_step_by_step(struct ieee80211_hw *hw,\n\t\t\t\t\t     u8 channel, u8 *stage, u8 *step,\n\t\t\t\t\t     u32 *delay);\n\nstatic long _rtl88e_phy_txpwr_idx_to_dbm(struct ieee80211_hw *hw,\n\t\t\t\t\t enum wireless_mode wirelessmode,\n\t\t\t\t\t u8 txpwridx);\nstatic void rtl88ee_phy_set_rf_on(struct ieee80211_hw *hw);\nstatic void rtl88e_phy_set_io(struct ieee80211_hw *hw);\n\nu32 rtl88e_phy_query_bb_reg(struct ieee80211_hw *hw, u32 regaddr, u32 bitmask)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 returnvalue, originalvalue, bitshift;\n\n\trtl_dbg(rtlpriv, COMP_RF, DBG_TRACE,\n\t\t\"regaddr(%#x), bitmask(%#x)\\n\", regaddr, bitmask);\n\toriginalvalue = rtl_read_dword(rtlpriv, regaddr);\n\tbitshift = calculate_bit_shift(bitmask);\n\treturnvalue = (originalvalue & bitmask) >> bitshift;\n\n\trtl_dbg(rtlpriv, COMP_RF, DBG_TRACE,\n\t\t\"BBR MASK=0x%x Addr[0x%x]=0x%x\\n\", bitmask,\n\t\tregaddr, originalvalue);\n\n\treturn returnvalue;\n\n}\n\nvoid rtl88e_phy_set_bb_reg(struct ieee80211_hw *hw,\n\t\t\t   u32 regaddr, u32 bitmask, u32 data)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 originalvalue, bitshift;\n\n\trtl_dbg(rtlpriv, COMP_RF, DBG_TRACE,\n\t\t\"regaddr(%#x), bitmask(%#x), data(%#x)\\n\",\n\t\tregaddr, bitmask, data);\n\n\tif (bitmask != MASKDWORD) {\n\t\toriginalvalue = rtl_read_dword(rtlpriv, regaddr);\n\t\tbitshift = calculate_bit_shift(bitmask);\n\t\tdata = ((originalvalue & (~bitmask)) | (data << bitshift));\n\t}\n\n\trtl_write_dword(rtlpriv, regaddr, data);\n\n\trtl_dbg(rtlpriv, COMP_RF, DBG_TRACE,\n\t\t\"regaddr(%#x), bitmask(%#x), data(%#x)\\n\",\n\t\tregaddr, bitmask, data);\n}\n\nu32 rtl88e_phy_query_rf_reg(struct ieee80211_hw *hw,\n\t\t\t    enum radio_path rfpath, u32 regaddr, u32 bitmask)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 original_value, readback_value, bitshift;\n\n\trtl_dbg(rtlpriv, COMP_RF, DBG_TRACE,\n\t\t\"regaddr(%#x), rfpath(%#x), bitmask(%#x)\\n\",\n\t\tregaddr, rfpath, bitmask);\n\n\tspin_lock(&rtlpriv->locks.rf_lock);\n\n\n\toriginal_value = _rtl88e_phy_rf_serial_read(hw, rfpath, regaddr);\n\tbitshift = calculate_bit_shift(bitmask);\n\treadback_value = (original_value & bitmask) >> bitshift;\n\n\tspin_unlock(&rtlpriv->locks.rf_lock);\n\n\trtl_dbg(rtlpriv, COMP_RF, DBG_TRACE,\n\t\t\"regaddr(%#x), rfpath(%#x), bitmask(%#x), original_value(%#x)\\n\",\n\t\tregaddr, rfpath, bitmask, original_value);\n\treturn readback_value;\n}\n\nvoid rtl88e_phy_set_rf_reg(struct ieee80211_hw *hw,\n\t\t\t   enum radio_path rfpath,\n\t\t\t   u32 regaddr, u32 bitmask, u32 data)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 original_value, bitshift;\n\n\trtl_dbg(rtlpriv, COMP_RF, DBG_TRACE,\n\t\t\"regaddr(%#x), bitmask(%#x), data(%#x), rfpath(%#x)\\n\",\n\t\tregaddr, bitmask, data, rfpath);\n\n\tspin_lock(&rtlpriv->locks.rf_lock);\n\n\tif (bitmask != RFREG_OFFSET_MASK) {\n\t\t\toriginal_value = _rtl88e_phy_rf_serial_read(hw,\n\t\t\t\t\t\t\t\t    rfpath,\n\t\t\t\t\t\t\t\t    regaddr);\n\t\t\tbitshift = calculate_bit_shift(bitmask);\n\t\t\tdata =\n\t\t\t    ((original_value & (~bitmask)) |\n\t\t\t     (data << bitshift));\n\t\t}\n\n\t_rtl88e_phy_rf_serial_write(hw, rfpath, regaddr, data);\n\n\n\tspin_unlock(&rtlpriv->locks.rf_lock);\n\n\trtl_dbg(rtlpriv, COMP_RF, DBG_TRACE,\n\t\t\"regaddr(%#x), bitmask(%#x), data(%#x), rfpath(%#x)\\n\",\n\t\tregaddr, bitmask, data, rfpath);\n}\n\nstatic u32 _rtl88e_phy_rf_serial_read(struct ieee80211_hw *hw,\n\t\t\t\t      enum radio_path rfpath, u32 offset)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\tstruct bb_reg_def *pphyreg = &rtlphy->phyreg_def[rfpath];\n\tu32 newoffset;\n\tu32 tmplong, tmplong2;\n\tu8 rfpi_enable = 0;\n\tu32 retvalue;\n\n\toffset &= 0xff;\n\tnewoffset = offset;\n\tif (RT_CANNOT_IO(hw)) {\n\t\tpr_err(\"return all one\\n\");\n\t\treturn 0xFFFFFFFF;\n\t}\n\ttmplong = rtl_get_bbreg(hw, RFPGA0_XA_HSSIPARAMETER2, MASKDWORD);\n\tif (rfpath == RF90_PATH_A)\n\t\ttmplong2 = tmplong;\n\telse\n\t\ttmplong2 = rtl_get_bbreg(hw, pphyreg->rfhssi_para2, MASKDWORD);\n\ttmplong2 = (tmplong2 & (~BLSSIREADADDRESS)) |\n\t    (newoffset << 23) | BLSSIREADEDGE;\n\trtl_set_bbreg(hw, RFPGA0_XA_HSSIPARAMETER2, MASKDWORD,\n\t\t      tmplong & (~BLSSIREADEDGE));\n\tudelay(10);\n\trtl_set_bbreg(hw, pphyreg->rfhssi_para2, MASKDWORD, tmplong2);\n\tudelay(120);\n\tif (rfpath == RF90_PATH_A)\n\t\trfpi_enable = (u8)rtl_get_bbreg(hw, RFPGA0_XA_HSSIPARAMETER1,\n\t\t\t\t\t\tBIT(8));\n\telse if (rfpath == RF90_PATH_B)\n\t\trfpi_enable = (u8)rtl_get_bbreg(hw, RFPGA0_XB_HSSIPARAMETER1,\n\t\t\t\t\t\tBIT(8));\n\tif (rfpi_enable)\n\t\tretvalue = rtl_get_bbreg(hw, pphyreg->rf_rbpi,\n\t\t\t\t\t BLSSIREADBACKDATA);\n\telse\n\t\tretvalue = rtl_get_bbreg(hw, pphyreg->rf_rb,\n\t\t\t\t\t BLSSIREADBACKDATA);\n\trtl_dbg(rtlpriv, COMP_RF, DBG_TRACE,\n\t\t\"RFR-%d Addr[0x%x]=0x%x\\n\",\n\t\trfpath, pphyreg->rf_rb, retvalue);\n\treturn retvalue;\n}\n\nstatic void _rtl88e_phy_rf_serial_write(struct ieee80211_hw *hw,\n\t\t\t\t\tenum radio_path rfpath, u32 offset,\n\t\t\t\t\tu32 data)\n{\n\tu32 data_and_addr;\n\tu32 newoffset;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\tstruct bb_reg_def *pphyreg = &rtlphy->phyreg_def[rfpath];\n\n\tif (RT_CANNOT_IO(hw)) {\n\t\tpr_err(\"stop\\n\");\n\t\treturn;\n\t}\n\toffset &= 0xff;\n\tnewoffset = offset;\n\tdata_and_addr = ((newoffset << 20) | (data & 0x000fffff)) & 0x0fffffff;\n\trtl_set_bbreg(hw, pphyreg->rf3wire_offset, MASKDWORD, data_and_addr);\n\trtl_dbg(rtlpriv, COMP_RF, DBG_TRACE,\n\t\t\"RFW-%d Addr[0x%x]=0x%x\\n\",\n\t\trfpath, pphyreg->rf3wire_offset, data_and_addr);\n}\n\nbool rtl88e_phy_mac_config(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tbool rtstatus = _rtl88e_phy_config_mac_with_headerfile(hw);\n\n\trtl_write_byte(rtlpriv, 0x04CA, 0x0B);\n\treturn rtstatus;\n}\n\nbool rtl88e_phy_bb_config(struct ieee80211_hw *hw)\n{\n\tbool rtstatus = true;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu16 regval;\n\tu8 b_reg_hwparafile = 1;\n\tu32 tmp;\n\t_rtl88e_phy_init_bb_rf_register_definition(hw);\n\tregval = rtl_read_word(rtlpriv, REG_SYS_FUNC_EN);\n\trtl_write_word(rtlpriv, REG_SYS_FUNC_EN,\n\t\t       regval | BIT(13) | BIT(0) | BIT(1));\n\n\trtl_write_byte(rtlpriv, REG_RF_CTRL, RF_EN | RF_RSTB | RF_SDMRSTB);\n\trtl_write_byte(rtlpriv, REG_SYS_FUNC_EN,\n\t\t       FEN_PPLL | FEN_PCIEA | FEN_DIO_PCIE |\n\t\t       FEN_BB_GLB_RSTN | FEN_BBRSTB);\n\ttmp = rtl_read_dword(rtlpriv, 0x4c);\n\trtl_write_dword(rtlpriv, 0x4c, tmp | BIT(23));\n\tif (b_reg_hwparafile == 1)\n\t\trtstatus = _rtl88e_phy_bb8188e_config_parafile(hw);\n\treturn rtstatus;\n}\n\nbool rtl88e_phy_rf_config(struct ieee80211_hw *hw)\n{\n\treturn rtl88e_phy_rf6052_config(hw);\n}\n\nstatic bool _rtl88e_check_condition(struct ieee80211_hw *hw,\n\t\t\t\t    const u32  condition)\n{\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tu32 _board = rtlefuse->board_type;  \n\tu32 _interface = rtlhal->interface;\n\tu32 _platform = 0x08; \n\tu32 cond;\n\n\tif (condition == 0xCDCDCDCD)\n\t\treturn true;\n\n\tcond = condition & 0xFF;\n\tif ((_board & cond) == 0 && cond != 0x1F)\n\t\treturn false;\n\n\tcond = condition & 0xFF00;\n\tcond = cond >> 8;\n\tif ((_interface & cond) == 0 && cond != 0x07)\n\t\treturn false;\n\n\tcond = condition & 0xFF0000;\n\tcond = cond >> 16;\n\tif ((_platform & cond) == 0 && cond != 0x0F)\n\t\treturn false;\n\treturn true;\n}\n\nstatic void _rtl8188e_config_rf_reg(struct ieee80211_hw *hw, u32 addr,\n\t\t\t\t    u32 data, enum radio_path rfpath,\n\t\t\t\t    u32 regaddr)\n{\n\tif (addr == 0xffe) {\n\t\tmdelay(50);\n\t} else if (addr == 0xfd) {\n\t\tmdelay(5);\n\t} else if (addr == 0xfc) {\n\t\tmdelay(1);\n\t} else if (addr == 0xfb) {\n\t\tudelay(50);\n\t} else if (addr == 0xfa) {\n\t\tudelay(5);\n\t} else if (addr == 0xf9) {\n\t\tudelay(1);\n\t} else {\n\t\trtl_set_rfreg(hw, rfpath, regaddr,\n\t\t\t      RFREG_OFFSET_MASK,\n\t\t\t      data);\n\t\tudelay(1);\n\t}\n}\n\nstatic void _rtl8188e_config_rf_radio_a(struct ieee80211_hw *hw,\n\t\t\t\t\tu32 addr, u32 data)\n{\n\tu32 content = 0x1000;  \n\tu32 maskforphyset = (u32)(content & 0xE000);\n\n\t_rtl8188e_config_rf_reg(hw, addr, data, RF90_PATH_A,\n\t\taddr | maskforphyset);\n}\n\nstatic void _rtl8188e_config_bb_reg(struct ieee80211_hw *hw,\n\t\t\t\t    u32 addr, u32 data)\n{\n\tif (addr == 0xfe) {\n\t\tmdelay(50);\n\t} else if (addr == 0xfd) {\n\t\tmdelay(5);\n\t} else if (addr == 0xfc) {\n\t\tmdelay(1);\n\t} else if (addr == 0xfb) {\n\t\tudelay(50);\n\t} else if (addr == 0xfa) {\n\t\tudelay(5);\n\t} else if (addr == 0xf9) {\n\t\tudelay(1);\n\t} else {\n\t\trtl_set_bbreg(hw, addr, MASKDWORD, data);\n\t\tudelay(1);\n\t}\n}\n\nstatic bool _rtl88e_phy_bb8188e_config_parafile(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tbool rtstatus;\n\n\trtstatus = phy_config_bb_with_headerfile(hw, BASEBAND_CONFIG_PHY_REG);\n\tif (!rtstatus) {\n\t\tpr_err(\"Write BB Reg Fail!!\\n\");\n\t\treturn false;\n\t}\n\n\tif (!rtlefuse->autoload_failflag) {\n\t\trtlphy->pwrgroup_cnt = 0;\n\t\trtstatus =\n\t\t  phy_config_bb_with_pghdr(hw, BASEBAND_CONFIG_PHY_REG);\n\t}\n\tif (!rtstatus) {\n\t\tpr_err(\"BB_PG Reg Fail!!\\n\");\n\t\treturn false;\n\t}\n\trtstatus =\n\t  phy_config_bb_with_headerfile(hw, BASEBAND_CONFIG_AGC_TAB);\n\tif (!rtstatus) {\n\t\tpr_err(\"AGC Table Fail\\n\");\n\t\treturn false;\n\t}\n\trtlphy->cck_high_power =\n\t  (bool)(rtl_get_bbreg(hw, RFPGA0_XA_HSSIPARAMETER2, 0x200));\n\n\treturn true;\n}\n\nstatic bool _rtl88e_phy_config_mac_with_headerfile(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 i;\n\tu32 arraylength;\n\tu32 *ptrarray;\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE, \"Read Rtl8188EMACPHY_Array\\n\");\n\tarraylength = RTL8188EEMAC_1T_ARRAYLEN;\n\tptrarray = RTL8188EEMAC_1T_ARRAY;\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\"Img:RTL8188EEMAC_1T_ARRAY LEN %d\\n\", arraylength);\n\tfor (i = 0; i < arraylength; i = i + 2)\n\t\trtl_write_byte(rtlpriv, ptrarray[i], (u8)ptrarray[i + 1]);\n\treturn true;\n}\n\n#define READ_NEXT_PAIR(v1, v2, i)\t\t\t\\\n\tdo {\t\t\t\t\t\t\\\n\t\ti += 2; v1 = array_table[i];\t\t\\\n\t\tv2 = array_table[i+1];\t\t\t\\\n\t} while (0)\n\nstatic void handle_branch1(struct ieee80211_hw *hw, u16 arraylen,\n\t\t\t   u32 *array_table)\n{\n\tu32 v1;\n\tu32 v2;\n\tint i;\n\n\tfor (i = 0; i < arraylen; i = i + 2) {\n\t\tv1 = array_table[i];\n\t\tv2 = array_table[i+1];\n\t\tif (v1 < 0xcdcdcdcd) {\n\t\t\t_rtl8188e_config_bb_reg(hw, v1, v2);\n\t\t} else {  \n\t\t\t \n\t\t\tif (i >= arraylen - 2)\n\t\t\t\tbreak;\n\n\t\t\tif (!_rtl88e_check_condition(hw, array_table[i])) {\n\t\t\t\t \n\t\t\t\tREAD_NEXT_PAIR(v1, v2, i);\n\t\t\t\twhile (v2 != 0xDEAD &&\n\t\t\t\t       v2 != 0xCDEF &&\n\t\t\t\t       v2 != 0xCDCD && i < arraylen - 2)\n\t\t\t\t\tREAD_NEXT_PAIR(v1, v2, i);\n\t\t\t\ti -= 2;  \n\t\t\t} else {  \n\t\t\t\tREAD_NEXT_PAIR(v1, v2, i);\n\t\t\t\twhile (v2 != 0xDEAD &&\n\t\t\t\t       v2 != 0xCDEF &&\n\t\t\t\t       v2 != 0xCDCD && i < arraylen - 2) {\n\t\t\t\t\t_rtl8188e_config_bb_reg(hw, v1, v2);\n\t\t\t\t\tREAD_NEXT_PAIR(v1, v2, i);\n\t\t\t\t}\n\n\t\t\t\twhile (v2 != 0xDEAD && i < arraylen - 2)\n\t\t\t\t\tREAD_NEXT_PAIR(v1, v2, i);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void handle_branch2(struct ieee80211_hw *hw, u16 arraylen,\n\t\t\t   u32 *array_table)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 v1;\n\tu32 v2;\n\tint i;\n\n\tfor (i = 0; i < arraylen; i = i + 2) {\n\t\tv1 = array_table[i];\n\t\tv2 = array_table[i+1];\n\t\tif (v1 < 0xCDCDCDCD) {\n\t\t\trtl_set_bbreg(hw, array_table[i], MASKDWORD,\n\t\t\t\t      array_table[i + 1]);\n\t\t\tudelay(1);\n\t\t\tcontinue;\n\t\t} else {  \n\t\t\t \n\t\t\tif (i >= arraylen - 2)\n\t\t\t\tbreak;\n\n\t\t\tif (!_rtl88e_check_condition(hw, array_table[i])) {\n\t\t\t\t \n\t\t\t\tREAD_NEXT_PAIR(v1, v2, i);\n\t\t\t\twhile (v2 != 0xDEAD &&\n\t\t\t\t       v2 != 0xCDEF &&\n\t\t\t\t       v2 != 0xCDCD && i < arraylen - 2)\n\t\t\t\t\tREAD_NEXT_PAIR(v1, v2, i);\n\t\t\t\ti -= 2;  \n\t\t\t} else {  \n\t\t\t\tREAD_NEXT_PAIR(v1, v2, i);\n\t\t\t\twhile (v2 != 0xDEAD &&\n\t\t\t\t       v2 != 0xCDEF &&\n\t\t\t\t       v2 != 0xCDCD && i < arraylen - 2) {\n\t\t\t\t\trtl_set_bbreg(hw, array_table[i],\n\t\t\t\t\t\t      MASKDWORD,\n\t\t\t\t\t\t      array_table[i + 1]);\n\t\t\t\t\tudelay(1);\n\t\t\t\t\tREAD_NEXT_PAIR(v1, v2, i);\n\t\t\t\t}\n\n\t\t\t\twhile (v2 != 0xDEAD && i < arraylen - 2)\n\t\t\t\t\tREAD_NEXT_PAIR(v1, v2, i);\n\t\t\t}\n\t\t}\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\t\"The agctab_array_table[0] is %x Rtl818EEPHY_REGArray[1] is %x\\n\",\n\t\t\tarray_table[i], array_table[i + 1]);\n\t}\n}\n\nstatic bool phy_config_bb_with_headerfile(struct ieee80211_hw *hw,\n\t\t\t\t\t  u8 configtype)\n{\n\tu32 *array_table;\n\tu16 arraylen;\n\n\tif (configtype == BASEBAND_CONFIG_PHY_REG) {\n\t\tarraylen = RTL8188EEPHY_REG_1TARRAYLEN;\n\t\tarray_table = RTL8188EEPHY_REG_1TARRAY;\n\t\thandle_branch1(hw, arraylen, array_table);\n\t} else if (configtype == BASEBAND_CONFIG_AGC_TAB) {\n\t\tarraylen = RTL8188EEAGCTAB_1TARRAYLEN;\n\t\tarray_table = RTL8188EEAGCTAB_1TARRAY;\n\t\thandle_branch2(hw, arraylen, array_table);\n\t}\n\treturn true;\n}\n\nstatic void store_pwrindex_rate_offset(struct ieee80211_hw *hw,\n\t\t\t\t       u32 regaddr, u32 bitmask,\n\t\t\t\t       u32 data)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\tint count = rtlphy->pwrgroup_cnt;\n\n\tif (regaddr == RTXAGC_A_RATE18_06) {\n\t\trtlphy->mcs_txpwrlevel_origoffset[count][0] = data;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\t\"MCSTxPowerLevelOriginalOffset[%d][0] = 0x%x\\n\",\n\t\t\tcount,\n\t\t\trtlphy->mcs_txpwrlevel_origoffset[count][0]);\n\t}\n\tif (regaddr == RTXAGC_A_RATE54_24) {\n\t\trtlphy->mcs_txpwrlevel_origoffset[count][1] = data;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\t\"MCSTxPowerLevelOriginalOffset[%d][1] = 0x%x\\n\",\n\t\t\tcount,\n\t\t\trtlphy->mcs_txpwrlevel_origoffset[count][1]);\n\t}\n\tif (regaddr == RTXAGC_A_CCK1_MCS32) {\n\t\trtlphy->mcs_txpwrlevel_origoffset[count][6] = data;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\t\"MCSTxPowerLevelOriginalOffset[%d][6] = 0x%x\\n\",\n\t\t\tcount,\n\t\t\trtlphy->mcs_txpwrlevel_origoffset[count][6]);\n\t}\n\tif (regaddr == RTXAGC_B_CCK11_A_CCK2_11 && bitmask == 0xffffff00) {\n\t\trtlphy->mcs_txpwrlevel_origoffset[count][7] = data;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\t\"MCSTxPowerLevelOriginalOffset[%d][7] = 0x%x\\n\",\n\t\t\tcount,\n\t\t\trtlphy->mcs_txpwrlevel_origoffset[count][7]);\n\t}\n\tif (regaddr == RTXAGC_A_MCS03_MCS00) {\n\t\trtlphy->mcs_txpwrlevel_origoffset[count][2] = data;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\t\"MCSTxPowerLevelOriginalOffset[%d][2] = 0x%x\\n\",\n\t\t\tcount,\n\t\t\trtlphy->mcs_txpwrlevel_origoffset[count][2]);\n\t}\n\tif (regaddr == RTXAGC_A_MCS07_MCS04) {\n\t\trtlphy->mcs_txpwrlevel_origoffset[count][3] = data;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\t\"MCSTxPowerLevelOriginalOffset[%d][3] = 0x%x\\n\",\n\t\t\tcount,\n\t\t\trtlphy->mcs_txpwrlevel_origoffset[count][3]);\n\t}\n\tif (regaddr == RTXAGC_A_MCS11_MCS08) {\n\t\trtlphy->mcs_txpwrlevel_origoffset[count][4] = data;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\t\"MCSTxPowerLevelOriginalOffset[%d][4] = 0x%x\\n\",\n\t\t\tcount,\n\t\t\trtlphy->mcs_txpwrlevel_origoffset[count][4]);\n\t}\n\tif (regaddr == RTXAGC_A_MCS15_MCS12) {\n\t\trtlphy->mcs_txpwrlevel_origoffset[count][5] = data;\n\t\tif (get_rf_type(rtlphy) == RF_1T1R) {\n\t\t\tcount++;\n\t\t\trtlphy->pwrgroup_cnt = count;\n\t\t}\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\t\"MCSTxPowerLevelOriginalOffset[%d][5] = 0x%x\\n\",\n\t\t\tcount,\n\t\t\trtlphy->mcs_txpwrlevel_origoffset[count][5]);\n\t}\n\tif (regaddr == RTXAGC_B_RATE18_06) {\n\t\trtlphy->mcs_txpwrlevel_origoffset[count][8] = data;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\t\"MCSTxPowerLevelOriginalOffset[%d][8] = 0x%x\\n\",\n\t\t\tcount,\n\t\t\trtlphy->mcs_txpwrlevel_origoffset[count][8]);\n\t}\n\tif (regaddr == RTXAGC_B_RATE54_24) {\n\t\trtlphy->mcs_txpwrlevel_origoffset[count][9] = data;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\t\"MCSTxPowerLevelOriginalOffset[%d][9] = 0x%x\\n\",\n\t\t\tcount,\n\t\t\trtlphy->mcs_txpwrlevel_origoffset[count][9]);\n\t}\n\tif (regaddr == RTXAGC_B_CCK1_55_MCS32) {\n\t\trtlphy->mcs_txpwrlevel_origoffset[count][14] = data;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\t\"MCSTxPowerLevelOriginalOffset[%d][14] = 0x%x\\n\",\n\t\t\tcount,\n\t\t\trtlphy->mcs_txpwrlevel_origoffset[count][14]);\n\t}\n\tif (regaddr == RTXAGC_B_CCK11_A_CCK2_11 && bitmask == 0x000000ff) {\n\t\trtlphy->mcs_txpwrlevel_origoffset[count][15] = data;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\t\"MCSTxPowerLevelOriginalOffset[%d][15] = 0x%x\\n\",\n\t\t\tcount,\n\t\t\trtlphy->mcs_txpwrlevel_origoffset[count][15]);\n\t}\n\tif (regaddr == RTXAGC_B_MCS03_MCS00) {\n\t\trtlphy->mcs_txpwrlevel_origoffset[count][10] = data;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\t\"MCSTxPowerLevelOriginalOffset[%d][10] = 0x%x\\n\",\n\t\t\tcount,\n\t\t\trtlphy->mcs_txpwrlevel_origoffset[count][10]);\n\t}\n\tif (regaddr == RTXAGC_B_MCS07_MCS04) {\n\t\trtlphy->mcs_txpwrlevel_origoffset[count][11] = data;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\t\"MCSTxPowerLevelOriginalOffset[%d][11] = 0x%x\\n\",\n\t\t\tcount,\n\t\t\trtlphy->mcs_txpwrlevel_origoffset[count][11]);\n\t}\n\tif (regaddr == RTXAGC_B_MCS11_MCS08) {\n\t\trtlphy->mcs_txpwrlevel_origoffset[count][12] = data;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\t\"MCSTxPowerLevelOriginalOffset[%d][12] = 0x%x\\n\",\n\t\t\tcount,\n\t\t\trtlphy->mcs_txpwrlevel_origoffset[count][12]);\n\t}\n\tif (regaddr == RTXAGC_B_MCS15_MCS12) {\n\t\trtlphy->mcs_txpwrlevel_origoffset[count][13] = data;\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\t\"MCSTxPowerLevelOriginalOffset[%d][13] = 0x%x\\n\",\n\t\t\tcount,\n\t\t\trtlphy->mcs_txpwrlevel_origoffset[count][13]);\n\t\tif (get_rf_type(rtlphy) != RF_1T1R) {\n\t\t\tcount++;\n\t\t\trtlphy->pwrgroup_cnt = count;\n\t\t}\n\t}\n}\n\nstatic bool phy_config_bb_with_pghdr(struct ieee80211_hw *hw, u8 configtype)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tint i;\n\tu32 *phy_reg_page;\n\tu16 phy_reg_page_len;\n\tu32 v1 = 0, v2 = 0;\n\n\tphy_reg_page_len = RTL8188EEPHY_REG_ARRAY_PGLEN;\n\tphy_reg_page = RTL8188EEPHY_REG_ARRAY_PG;\n\n\tif (configtype == BASEBAND_CONFIG_PHY_REG) {\n\t\tfor (i = 0; i < phy_reg_page_len; i = i + 3) {\n\t\t\tv1 = phy_reg_page[i];\n\t\t\tv2 = phy_reg_page[i+1];\n\n\t\t\tif (v1 < 0xcdcdcdcd) {\n\t\t\t\tif (phy_reg_page[i] == 0xfe)\n\t\t\t\t\tmdelay(50);\n\t\t\t\telse if (phy_reg_page[i] == 0xfd)\n\t\t\t\t\tmdelay(5);\n\t\t\t\telse if (phy_reg_page[i] == 0xfc)\n\t\t\t\t\tmdelay(1);\n\t\t\t\telse if (phy_reg_page[i] == 0xfb)\n\t\t\t\t\tudelay(50);\n\t\t\t\telse if (phy_reg_page[i] == 0xfa)\n\t\t\t\t\tudelay(5);\n\t\t\t\telse if (phy_reg_page[i] == 0xf9)\n\t\t\t\t\tudelay(1);\n\n\t\t\t\tstore_pwrindex_rate_offset(hw, phy_reg_page[i],\n\t\t\t\t\t\t\t   phy_reg_page[i + 1],\n\t\t\t\t\t\t\t   phy_reg_page[i + 2]);\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif (!_rtl88e_check_condition(hw,\n\t\t\t\t\t\t\t     phy_reg_page[i])) {\n\t\t\t\t\t \n\t\t\t\t    i += 2;  \n\t\t\t\t     \n\t\t\t\t    if (i >= phy_reg_page_len - 2)\n\t\t\t\t\tbreak;\n\n\t\t\t\t    v1 = phy_reg_page[i];\n\t\t\t\t    v2 = phy_reg_page[i+1];\n\t\t\t\t    while (v2 != 0xDEAD &&\n\t\t\t\t\t   i < phy_reg_page_len - 5) {\n\t\t\t\t\ti += 3;\n\t\t\t\t\tv1 = phy_reg_page[i];\n\t\t\t\t\tv2 = phy_reg_page[i+1];\n\t\t\t\t    }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\trtl_dbg(rtlpriv, COMP_SEND, DBG_TRACE,\n\t\t\t\"configtype != BaseBand_Config_PHY_REG\\n\");\n\t}\n\treturn true;\n}\n\n#define READ_NEXT_RF_PAIR(v1, v2, i) \\\ndo { \\\n\ti += 2; \\\n\tv1 = radioa_array_table[i]; \\\n\tv2 = radioa_array_table[i+1]; \\\n} while (0)\n\nstatic void process_path_a(struct ieee80211_hw *hw,\n\t\t\t   u16  radioa_arraylen,\n\t\t\t   u32 *radioa_array_table)\n{\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tu32 v1, v2;\n\tint i;\n\n\tfor (i = 0; i < radioa_arraylen; i = i + 2) {\n\t\tv1 = radioa_array_table[i];\n\t\tv2 = radioa_array_table[i+1];\n\t\tif (v1 < 0xcdcdcdcd) {\n\t\t\t_rtl8188e_config_rf_radio_a(hw, v1, v2);\n\t\t} else {  \n\t\t\t \n\t\t\tif (i >= radioa_arraylen - 2)\n\t\t\t\tbreak;\n\n\t\t\tif (!_rtl88e_check_condition(hw, radioa_array_table[i])) {\n\t\t\t\t \n\t\t\t\tREAD_NEXT_RF_PAIR(v1, v2, i);\n\t\t\t\twhile (v2 != 0xDEAD &&\n\t\t\t\t       v2 != 0xCDEF &&\n\t\t\t\t       v2 != 0xCDCD &&\n\t\t\t\t       i < radioa_arraylen - 2) {\n\t\t\t\t\tREAD_NEXT_RF_PAIR(v1, v2, i);\n\t\t\t\t}\n\t\t\t\ti -= 2;  \n\t\t\t} else {  \n\t\t\t\tREAD_NEXT_RF_PAIR(v1, v2, i);\n\t\t\t\twhile (v2 != 0xDEAD &&\n\t\t\t\t       v2 != 0xCDEF &&\n\t\t\t\t       v2 != 0xCDCD &&\n\t\t\t\t       i < radioa_arraylen - 2) {\n\t\t\t\t\t_rtl8188e_config_rf_radio_a(hw, v1, v2);\n\t\t\t\t\tREAD_NEXT_RF_PAIR(v1, v2, i);\n\t\t\t\t}\n\n\t\t\t\twhile (v2 != 0xDEAD &&\n\t\t\t\t       i < radioa_arraylen - 2)\n\t\t\t\t\tREAD_NEXT_RF_PAIR(v1, v2, i);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (rtlhal->oem_id == RT_CID_819X_HP)\n\t\t_rtl8188e_config_rf_radio_a(hw, 0x52, 0x7E4BD);\n}\n\nbool rtl88e_phy_config_rf_with_headerfile(struct ieee80211_hw *hw,\n\t\t\t\t\t  enum radio_path rfpath)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 *radioa_array_table;\n\tu16 radioa_arraylen;\n\n\tradioa_arraylen = RTL8188EE_RADIOA_1TARRAYLEN;\n\tradioa_array_table = RTL8188EE_RADIOA_1TARRAY;\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\"Radio_A:RTL8188EE_RADIOA_1TARRAY %d\\n\", radioa_arraylen);\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD, \"Radio No %x\\n\", rfpath);\n\tswitch (rfpath) {\n\tcase RF90_PATH_A:\n\t\tprocess_path_a(hw, radioa_arraylen, radioa_array_table);\n\t\tbreak;\n\tcase RF90_PATH_B:\n\tcase RF90_PATH_C:\n\tcase RF90_PATH_D:\n\t\tbreak;\n\t}\n\treturn true;\n}\n\nvoid rtl88e_phy_get_hw_reg_originalvalue(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\n\trtlphy->default_initialgain[0] =\n\t    (u8)rtl_get_bbreg(hw, ROFDM0_XAAGCCORE1, MASKBYTE0);\n\trtlphy->default_initialgain[1] =\n\t    (u8)rtl_get_bbreg(hw, ROFDM0_XBAGCCORE1, MASKBYTE0);\n\trtlphy->default_initialgain[2] =\n\t    (u8)rtl_get_bbreg(hw, ROFDM0_XCAGCCORE1, MASKBYTE0);\n\trtlphy->default_initialgain[3] =\n\t    (u8)rtl_get_bbreg(hw, ROFDM0_XDAGCCORE1, MASKBYTE0);\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\"Default initial gain (c50=0x%x, c58=0x%x, c60=0x%x, c68=0x%x\\n\",\n\t\trtlphy->default_initialgain[0],\n\t\trtlphy->default_initialgain[1],\n\t\trtlphy->default_initialgain[2],\n\t\trtlphy->default_initialgain[3]);\n\n\trtlphy->framesync = (u8)rtl_get_bbreg(hw, ROFDM0_RXDETECTOR3,\n\t\t\t\t\t      MASKBYTE0);\n\trtlphy->framesync_c34 = rtl_get_bbreg(hw, ROFDM0_RXDETECTOR2,\n\t\t\t\t\t      MASKDWORD);\n\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\"Default framesync (0x%x) = 0x%x\\n\",\n\t\tROFDM0_RXDETECTOR3, rtlphy->framesync);\n}\n\nstatic void _rtl88e_phy_init_bb_rf_register_definition(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\n\trtlphy->phyreg_def[RF90_PATH_A].rfintfs = RFPGA0_XAB_RFINTERFACESW;\n\trtlphy->phyreg_def[RF90_PATH_B].rfintfs = RFPGA0_XAB_RFINTERFACESW;\n\trtlphy->phyreg_def[RF90_PATH_C].rfintfs = RFPGA0_XCD_RFINTERFACESW;\n\trtlphy->phyreg_def[RF90_PATH_D].rfintfs = RFPGA0_XCD_RFINTERFACESW;\n\n\trtlphy->phyreg_def[RF90_PATH_A].rfintfi = RFPGA0_XAB_RFINTERFACERB;\n\trtlphy->phyreg_def[RF90_PATH_B].rfintfi = RFPGA0_XAB_RFINTERFACERB;\n\trtlphy->phyreg_def[RF90_PATH_C].rfintfi = RFPGA0_XCD_RFINTERFACERB;\n\trtlphy->phyreg_def[RF90_PATH_D].rfintfi = RFPGA0_XCD_RFINTERFACERB;\n\n\trtlphy->phyreg_def[RF90_PATH_A].rfintfo = RFPGA0_XA_RFINTERFACEOE;\n\trtlphy->phyreg_def[RF90_PATH_B].rfintfo = RFPGA0_XB_RFINTERFACEOE;\n\n\trtlphy->phyreg_def[RF90_PATH_A].rfintfe = RFPGA0_XA_RFINTERFACEOE;\n\trtlphy->phyreg_def[RF90_PATH_B].rfintfe = RFPGA0_XB_RFINTERFACEOE;\n\n\trtlphy->phyreg_def[RF90_PATH_A].rf3wire_offset =\n\t    RFPGA0_XA_LSSIPARAMETER;\n\trtlphy->phyreg_def[RF90_PATH_B].rf3wire_offset =\n\t    RFPGA0_XB_LSSIPARAMETER;\n\n\trtlphy->phyreg_def[RF90_PATH_A].rflssi_select = RFPGA0_XAB_RFPARAMETER;\n\trtlphy->phyreg_def[RF90_PATH_B].rflssi_select = RFPGA0_XAB_RFPARAMETER;\n\trtlphy->phyreg_def[RF90_PATH_C].rflssi_select = RFPGA0_XCD_RFPARAMETER;\n\trtlphy->phyreg_def[RF90_PATH_D].rflssi_select = RFPGA0_XCD_RFPARAMETER;\n\n\trtlphy->phyreg_def[RF90_PATH_A].rftxgain_stage = RFPGA0_TXGAINSTAGE;\n\trtlphy->phyreg_def[RF90_PATH_B].rftxgain_stage = RFPGA0_TXGAINSTAGE;\n\trtlphy->phyreg_def[RF90_PATH_C].rftxgain_stage = RFPGA0_TXGAINSTAGE;\n\trtlphy->phyreg_def[RF90_PATH_D].rftxgain_stage = RFPGA0_TXGAINSTAGE;\n\n\trtlphy->phyreg_def[RF90_PATH_A].rfhssi_para1 = RFPGA0_XA_HSSIPARAMETER1;\n\trtlphy->phyreg_def[RF90_PATH_B].rfhssi_para1 = RFPGA0_XB_HSSIPARAMETER1;\n\n\trtlphy->phyreg_def[RF90_PATH_A].rfhssi_para2 = RFPGA0_XA_HSSIPARAMETER2;\n\trtlphy->phyreg_def[RF90_PATH_B].rfhssi_para2 = RFPGA0_XB_HSSIPARAMETER2;\n\n\trtlphy->phyreg_def[RF90_PATH_A].rfsw_ctrl =\n\t    RFPGA0_XAB_SWITCHCONTROL;\n\trtlphy->phyreg_def[RF90_PATH_B].rfsw_ctrl =\n\t    RFPGA0_XAB_SWITCHCONTROL;\n\trtlphy->phyreg_def[RF90_PATH_C].rfsw_ctrl =\n\t    RFPGA0_XCD_SWITCHCONTROL;\n\trtlphy->phyreg_def[RF90_PATH_D].rfsw_ctrl =\n\t    RFPGA0_XCD_SWITCHCONTROL;\n\n\trtlphy->phyreg_def[RF90_PATH_A].rfagc_control1 = ROFDM0_XAAGCCORE1;\n\trtlphy->phyreg_def[RF90_PATH_B].rfagc_control1 = ROFDM0_XBAGCCORE1;\n\trtlphy->phyreg_def[RF90_PATH_C].rfagc_control1 = ROFDM0_XCAGCCORE1;\n\trtlphy->phyreg_def[RF90_PATH_D].rfagc_control1 = ROFDM0_XDAGCCORE1;\n\n\trtlphy->phyreg_def[RF90_PATH_A].rfagc_control2 = ROFDM0_XAAGCCORE2;\n\trtlphy->phyreg_def[RF90_PATH_B].rfagc_control2 = ROFDM0_XBAGCCORE2;\n\trtlphy->phyreg_def[RF90_PATH_C].rfagc_control2 = ROFDM0_XCAGCCORE2;\n\trtlphy->phyreg_def[RF90_PATH_D].rfagc_control2 = ROFDM0_XDAGCCORE2;\n\n\trtlphy->phyreg_def[RF90_PATH_A].rfrxiq_imbal = ROFDM0_XARXIQIMBALANCE;\n\trtlphy->phyreg_def[RF90_PATH_B].rfrxiq_imbal = ROFDM0_XBRXIQIMBALANCE;\n\trtlphy->phyreg_def[RF90_PATH_C].rfrxiq_imbal = ROFDM0_XCRXIQIMBANLANCE;\n\trtlphy->phyreg_def[RF90_PATH_D].rfrxiq_imbal = ROFDM0_XDRXIQIMBALANCE;\n\n\trtlphy->phyreg_def[RF90_PATH_A].rfrx_afe = ROFDM0_XARXAFE;\n\trtlphy->phyreg_def[RF90_PATH_B].rfrx_afe = ROFDM0_XBRXAFE;\n\trtlphy->phyreg_def[RF90_PATH_C].rfrx_afe = ROFDM0_XCRXAFE;\n\trtlphy->phyreg_def[RF90_PATH_D].rfrx_afe = ROFDM0_XDRXAFE;\n\n\trtlphy->phyreg_def[RF90_PATH_A].rftxiq_imbal = ROFDM0_XATXIQIMBALANCE;\n\trtlphy->phyreg_def[RF90_PATH_B].rftxiq_imbal = ROFDM0_XBTXIQIMBALANCE;\n\trtlphy->phyreg_def[RF90_PATH_C].rftxiq_imbal = ROFDM0_XCTXIQIMBALANCE;\n\trtlphy->phyreg_def[RF90_PATH_D].rftxiq_imbal = ROFDM0_XDTXIQIMBALANCE;\n\n\trtlphy->phyreg_def[RF90_PATH_A].rftx_afe = ROFDM0_XATXAFE;\n\trtlphy->phyreg_def[RF90_PATH_B].rftx_afe = ROFDM0_XBTXAFE;\n\n\trtlphy->phyreg_def[RF90_PATH_A].rf_rb = RFPGA0_XA_LSSIREADBACK;\n\trtlphy->phyreg_def[RF90_PATH_B].rf_rb = RFPGA0_XB_LSSIREADBACK;\n\n\trtlphy->phyreg_def[RF90_PATH_A].rf_rbpi = TRANSCEIVEA_HSPI_READBACK;\n\trtlphy->phyreg_def[RF90_PATH_B].rf_rbpi = TRANSCEIVEB_HSPI_READBACK;\n}\n\nvoid rtl88e_phy_get_txpower_level(struct ieee80211_hw *hw, long *powerlevel)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\tu8 txpwr_level;\n\tlong txpwr_dbm;\n\n\ttxpwr_level = rtlphy->cur_cck_txpwridx;\n\ttxpwr_dbm = _rtl88e_phy_txpwr_idx_to_dbm(hw,\n\t\t\t\t\t\t WIRELESS_MODE_B, txpwr_level);\n\ttxpwr_level = rtlphy->cur_ofdm24g_txpwridx;\n\tif (_rtl88e_phy_txpwr_idx_to_dbm(hw,\n\t\t\t\t\t WIRELESS_MODE_G,\n\t\t\t\t\t txpwr_level) > txpwr_dbm)\n\t\ttxpwr_dbm =\n\t\t    _rtl88e_phy_txpwr_idx_to_dbm(hw, WIRELESS_MODE_G,\n\t\t\t\t\t\t txpwr_level);\n\ttxpwr_level = rtlphy->cur_ofdm24g_txpwridx;\n\tif (_rtl88e_phy_txpwr_idx_to_dbm(hw,\n\t\t\t\t\t WIRELESS_MODE_N_24G,\n\t\t\t\t\t txpwr_level) > txpwr_dbm)\n\t\ttxpwr_dbm =\n\t\t    _rtl88e_phy_txpwr_idx_to_dbm(hw, WIRELESS_MODE_N_24G,\n\t\t\t\t\t\t txpwr_level);\n\t*powerlevel = txpwr_dbm;\n}\n\nstatic void handle_path_a(struct rtl_efuse *rtlefuse, u8 index,\n\t\t\t  u8 *cckpowerlevel, u8 *ofdmpowerlevel,\n\t\t\t  u8 *bw20powerlevel, u8 *bw40powerlevel)\n{\n\tcckpowerlevel[RF90_PATH_A] =\n\t    rtlefuse->txpwrlevel_cck[RF90_PATH_A][index];\n\t\t \n\tif (rtlefuse->txpwr_ht20diff[RF90_PATH_A][index] > 0x0f)\n\t\tbw20powerlevel[RF90_PATH_A] =\n\t\t  rtlefuse->txpwrlevel_ht40_1s[RF90_PATH_A][index] -\n\t\t  (~(rtlefuse->txpwr_ht20diff[RF90_PATH_A][index]) + 1);\n\telse\n\t\tbw20powerlevel[RF90_PATH_A] =\n\t\t  rtlefuse->txpwrlevel_ht40_1s[RF90_PATH_A][index] +\n\t\t  rtlefuse->txpwr_ht20diff[RF90_PATH_A][index];\n\tif (rtlefuse->txpwr_legacyhtdiff[RF90_PATH_A][index] > 0xf)\n\t\tofdmpowerlevel[RF90_PATH_A] =\n\t\t  rtlefuse->txpwrlevel_ht40_1s[RF90_PATH_A][index] -\n\t\t  (~(rtlefuse->txpwr_legacyhtdiff[RF90_PATH_A][index])+1);\n\telse\n\t\tofdmpowerlevel[RF90_PATH_A] =\n\t\trtlefuse->txpwrlevel_ht40_1s[RF90_PATH_A][index] +\n\t\t  rtlefuse->txpwr_legacyhtdiff[RF90_PATH_A][index];\n\tbw40powerlevel[RF90_PATH_A] =\n\t  rtlefuse->txpwrlevel_ht40_1s[RF90_PATH_A][index];\n}\n\nstatic void _rtl88e_get_txpower_index(struct ieee80211_hw *hw, u8 channel,\n\t\t\t\t      u8 *cckpowerlevel, u8 *ofdmpowerlevel,\n\t\t\t\t      u8 *bw20powerlevel, u8 *bw40powerlevel)\n{\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tu8 index = (channel - 1);\n\tu8 rf_path = 0;\n\n\tfor (rf_path = 0; rf_path < 2; rf_path++) {\n\t\tif (rf_path == RF90_PATH_A) {\n\t\t\thandle_path_a(rtlefuse, index, cckpowerlevel,\n\t\t\t\t      ofdmpowerlevel, bw20powerlevel,\n\t\t\t\t      bw40powerlevel);\n\t\t} else if (rf_path == RF90_PATH_B) {\n\t\t\tcckpowerlevel[RF90_PATH_B] =\n\t\t\t  rtlefuse->txpwrlevel_cck[RF90_PATH_B][index];\n\t\t\tbw20powerlevel[RF90_PATH_B] =\n\t\t\t  rtlefuse->txpwrlevel_ht40_1s[RF90_PATH_B][index] +\n\t\t\t  rtlefuse->txpwr_ht20diff[RF90_PATH_B][index];\n\t\t\tofdmpowerlevel[RF90_PATH_B] =\n\t\t\t  rtlefuse->txpwrlevel_ht40_1s[RF90_PATH_B][index] +\n\t\t\t  rtlefuse->txpwr_legacyhtdiff[RF90_PATH_B][index];\n\t\t\tbw40powerlevel[RF90_PATH_B] =\n\t\t\t  rtlefuse->txpwrlevel_ht40_1s[RF90_PATH_B][index];\n\t\t}\n\t}\n\n}\n\nstatic void _rtl88e_ccxpower_index_check(struct ieee80211_hw *hw,\n\t\t\t\t\t u8 channel, u8 *cckpowerlevel,\n\t\t\t\t\t u8 *ofdmpowerlevel, u8 *bw20powerlevel,\n\t\t\t\t\t u8 *bw40powerlevel)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\n\trtlphy->cur_cck_txpwridx = cckpowerlevel[0];\n\trtlphy->cur_ofdm24g_txpwridx = ofdmpowerlevel[0];\n\trtlphy->cur_bw20_txpwridx = bw20powerlevel[0];\n\trtlphy->cur_bw40_txpwridx = bw40powerlevel[0];\n\n}\n\nvoid rtl88e_phy_set_txpower_level(struct ieee80211_hw *hw, u8 channel)\n{\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tu8 cckpowerlevel[MAX_TX_COUNT]  = {0};\n\tu8 ofdmpowerlevel[MAX_TX_COUNT] = {0};\n\tu8 bw20powerlevel[MAX_TX_COUNT] = {0};\n\tu8 bw40powerlevel[MAX_TX_COUNT] = {0};\n\n\tif (!rtlefuse->txpwr_fromeprom)\n\t\treturn;\n\t_rtl88e_get_txpower_index(hw, channel,\n\t\t\t\t  &cckpowerlevel[0], &ofdmpowerlevel[0],\n\t\t\t\t  &bw20powerlevel[0], &bw40powerlevel[0]);\n\t_rtl88e_ccxpower_index_check(hw, channel,\n\t\t\t\t     &cckpowerlevel[0], &ofdmpowerlevel[0],\n\t\t\t\t     &bw20powerlevel[0], &bw40powerlevel[0]);\n\trtl88e_phy_rf6052_set_cck_txpower(hw, &cckpowerlevel[0]);\n\trtl88e_phy_rf6052_set_ofdm_txpower(hw, &ofdmpowerlevel[0],\n\t\t\t\t\t   &bw20powerlevel[0],\n\t\t\t\t\t   &bw40powerlevel[0], channel);\n}\n\nstatic long _rtl88e_phy_txpwr_idx_to_dbm(struct ieee80211_hw *hw,\n\t\t\t\t\t enum wireless_mode wirelessmode,\n\t\t\t\t\t u8 txpwridx)\n{\n\tlong offset;\n\tlong pwrout_dbm;\n\n\tswitch (wirelessmode) {\n\tcase WIRELESS_MODE_B:\n\t\toffset = -7;\n\t\tbreak;\n\tcase WIRELESS_MODE_G:\n\tcase WIRELESS_MODE_N_24G:\n\t\toffset = -8;\n\t\tbreak;\n\tdefault:\n\t\toffset = -8;\n\t\tbreak;\n\t}\n\tpwrout_dbm = txpwridx / 2 + offset;\n\treturn pwrout_dbm;\n}\n\nvoid rtl88e_phy_scan_operation_backup(struct ieee80211_hw *hw, u8 operation)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tenum io_type iotype;\n\n\tif (!is_hal_stop(rtlhal)) {\n\t\tswitch (operation) {\n\t\tcase SCAN_OPT_BACKUP_BAND0:\n\t\t\tiotype = IO_CMD_PAUSE_BAND0_DM_BY_SCAN;\n\t\t\trtlpriv->cfg->ops->set_hw_reg(hw,\n\t\t\t\t\t\t      HW_VAR_IO_CMD,\n\t\t\t\t\t\t      (u8 *)&iotype);\n\n\t\t\tbreak;\n\t\tcase SCAN_OPT_RESTORE:\n\t\t\tiotype = IO_CMD_RESUME_DM_BY_SCAN;\n\t\t\trtlpriv->cfg->ops->set_hw_reg(hw,\n\t\t\t\t\t\t      HW_VAR_IO_CMD,\n\t\t\t\t\t\t      (u8 *)&iotype);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Unknown Scan Backup operation.\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid rtl88e_phy_set_bw_mode_callback(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tu8 reg_bw_opmode;\n\tu8 reg_prsr_rsc;\n\n\trtl_dbg(rtlpriv, COMP_SCAN, DBG_TRACE,\n\t\t\"Switch to %s bandwidth\\n\",\n\t\trtlphy->current_chan_bw == HT_CHANNEL_WIDTH_20 ?\n\t\t\"20MHz\" : \"40MHz\");\n\n\tif (is_hal_stop(rtlhal)) {\n\t\trtlphy->set_bwmode_inprogress = false;\n\t\treturn;\n\t}\n\n\treg_bw_opmode = rtl_read_byte(rtlpriv, REG_BWOPMODE);\n\treg_prsr_rsc = rtl_read_byte(rtlpriv, REG_RRSR + 2);\n\n\tswitch (rtlphy->current_chan_bw) {\n\tcase HT_CHANNEL_WIDTH_20:\n\t\treg_bw_opmode |= BW_OPMODE_20MHZ;\n\t\trtl_write_byte(rtlpriv, REG_BWOPMODE, reg_bw_opmode);\n\t\tbreak;\n\tcase HT_CHANNEL_WIDTH_20_40:\n\t\treg_bw_opmode &= ~BW_OPMODE_20MHZ;\n\t\trtl_write_byte(rtlpriv, REG_BWOPMODE, reg_bw_opmode);\n\t\treg_prsr_rsc =\n\t\t    (reg_prsr_rsc & 0x90) | (mac->cur_40_prime_sc << 5);\n\t\trtl_write_byte(rtlpriv, REG_RRSR + 2, reg_prsr_rsc);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"unknown bandwidth: %#X\\n\",\n\t\t       rtlphy->current_chan_bw);\n\t\tbreak;\n\t}\n\n\tswitch (rtlphy->current_chan_bw) {\n\tcase HT_CHANNEL_WIDTH_20:\n\t\trtl_set_bbreg(hw, RFPGA0_RFMOD, BRFMOD, 0x0);\n\t\trtl_set_bbreg(hw, RFPGA1_RFMOD, BRFMOD, 0x0);\n\t \n\t\tbreak;\n\tcase HT_CHANNEL_WIDTH_20_40:\n\t\trtl_set_bbreg(hw, RFPGA0_RFMOD, BRFMOD, 0x1);\n\t\trtl_set_bbreg(hw, RFPGA1_RFMOD, BRFMOD, 0x1);\n\n\t\trtl_set_bbreg(hw, RCCK0_SYSTEM, BCCK_SIDEBAND,\n\t\t\t      (mac->cur_40_prime_sc >> 1));\n\t\trtl_set_bbreg(hw, ROFDM1_LSTF, 0xC00, mac->cur_40_prime_sc);\n\t\t \n\n\t\trtl_set_bbreg(hw, 0x818, (BIT(26) | BIT(27)),\n\t\t\t      (mac->cur_40_prime_sc ==\n\t\t\t       HAL_PRIME_CHNL_OFFSET_LOWER) ? 2 : 1);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"unknown bandwidth: %#X\\n\",\n\t\t       rtlphy->current_chan_bw);\n\t\tbreak;\n\t}\n\trtl88e_phy_rf6052_set_bandwidth(hw, rtlphy->current_chan_bw);\n\trtlphy->set_bwmode_inprogress = false;\n\trtl_dbg(rtlpriv, COMP_SCAN, DBG_LOUD, \"\\n\");\n}\n\nvoid rtl88e_phy_set_bw_mode(struct ieee80211_hw *hw,\n\t\t\t    enum nl80211_channel_type ch_type)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tu8 tmp_bw = rtlphy->current_chan_bw;\n\n\tif (rtlphy->set_bwmode_inprogress)\n\t\treturn;\n\trtlphy->set_bwmode_inprogress = true;\n\tif ((!is_hal_stop(rtlhal)) && !(RT_CANNOT_IO(hw))) {\n\t\trtl88e_phy_set_bw_mode_callback(hw);\n\t} else {\n\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_WARNING,\n\t\t\t\"false driver sleep or unload\\n\");\n\t\trtlphy->set_bwmode_inprogress = false;\n\t\trtlphy->current_chan_bw = tmp_bw;\n\t}\n}\n\nvoid rtl88e_phy_sw_chnl_callback(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\tu32 delay;\n\n\trtl_dbg(rtlpriv, COMP_SCAN, DBG_TRACE,\n\t\t\"switch to channel%d\\n\", rtlphy->current_channel);\n\tif (is_hal_stop(rtlhal))\n\t\treturn;\n\tdo {\n\t\tif (!rtlphy->sw_chnl_inprogress)\n\t\t\tbreak;\n\t\tif (!_rtl88e_phy_sw_chnl_step_by_step\n\t\t    (hw, rtlphy->current_channel, &rtlphy->sw_chnl_stage,\n\t\t     &rtlphy->sw_chnl_step, &delay)) {\n\t\t\tif (delay > 0)\n\t\t\t\tmdelay(delay);\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t} else {\n\t\t\trtlphy->sw_chnl_inprogress = false;\n\t\t}\n\t\tbreak;\n\t} while (true);\n\trtl_dbg(rtlpriv, COMP_SCAN, DBG_TRACE, \"\\n\");\n}\n\nu8 rtl88e_phy_sw_chnl(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\n\tif (rtlphy->sw_chnl_inprogress)\n\t\treturn 0;\n\tif (rtlphy->set_bwmode_inprogress)\n\t\treturn 0;\n\tWARN_ONCE((rtlphy->current_channel > 14),\n\t\t  \"rtl8188ee: WIRELESS_MODE_G but channel>14\");\n\trtlphy->sw_chnl_inprogress = true;\n\trtlphy->sw_chnl_stage = 0;\n\trtlphy->sw_chnl_step = 0;\n\tif (!(is_hal_stop(rtlhal)) && !(RT_CANNOT_IO(hw))) {\n\t\trtl88e_phy_sw_chnl_callback(hw);\n\t\trtl_dbg(rtlpriv, COMP_CHAN, DBG_LOUD,\n\t\t\t\"sw_chnl_inprogress false schedule workitem current channel %d\\n\",\n\t\t\trtlphy->current_channel);\n\t\trtlphy->sw_chnl_inprogress = false;\n\t} else {\n\t\trtl_dbg(rtlpriv, COMP_CHAN, DBG_LOUD,\n\t\t\t\"sw_chnl_inprogress false driver sleep or unload\\n\");\n\t\trtlphy->sw_chnl_inprogress = false;\n\t}\n\treturn 1;\n}\n\nstatic bool _rtl88e_phy_sw_chnl_step_by_step(struct ieee80211_hw *hw,\n\t\t\t\t\t     u8 channel, u8 *stage, u8 *step,\n\t\t\t\t\t     u32 *delay)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\tstruct swchnlcmd precommoncmd[MAX_PRECMD_CNT];\n\tu32 precommoncmdcnt;\n\tstruct swchnlcmd postcommoncmd[MAX_POSTCMD_CNT];\n\tu32 postcommoncmdcnt;\n\tstruct swchnlcmd rfdependcmd[MAX_RFDEPENDCMD_CNT];\n\tu32 rfdependcmdcnt;\n\tstruct swchnlcmd *currentcmd = NULL;\n\tu8 rfpath;\n\tu8 num_total_rfpath = rtlphy->num_total_rfpath;\n\n\tprecommoncmdcnt = 0;\n\t_rtl88e_phy_set_sw_chnl_cmdarray(precommoncmd, precommoncmdcnt++,\n\t\t\t\t\t MAX_PRECMD_CNT,\n\t\t\t\t\t CMDID_SET_TXPOWEROWER_LEVEL, 0, 0, 0);\n\t_rtl88e_phy_set_sw_chnl_cmdarray(precommoncmd, precommoncmdcnt++,\n\t\t\t\t\t MAX_PRECMD_CNT, CMDID_END, 0, 0, 0);\n\n\tpostcommoncmdcnt = 0;\n\n\t_rtl88e_phy_set_sw_chnl_cmdarray(postcommoncmd, postcommoncmdcnt++,\n\t\t\t\t\t MAX_POSTCMD_CNT, CMDID_END, 0, 0, 0);\n\n\trfdependcmdcnt = 0;\n\n\tWARN_ONCE((channel < 1 || channel > 14),\n\t\t  \"rtl8188ee: illegal channel for Zebra: %d\\n\", channel);\n\n\t_rtl88e_phy_set_sw_chnl_cmdarray(rfdependcmd, rfdependcmdcnt++,\n\t\t\t\t\t MAX_RFDEPENDCMD_CNT, CMDID_RF_WRITEREG,\n\t\t\t\t\t RF_CHNLBW, channel, 10);\n\n\t_rtl88e_phy_set_sw_chnl_cmdarray(rfdependcmd, rfdependcmdcnt++,\n\t\t\t\t\t MAX_RFDEPENDCMD_CNT, CMDID_END, 0, 0,\n\t\t\t\t\t 0);\n\n\tdo {\n\t\tswitch (*stage) {\n\t\tcase 0:\n\t\t\tcurrentcmd = &precommoncmd[*step];\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tcurrentcmd = &rfdependcmd[*step];\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tcurrentcmd = &postcommoncmd[*step];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Invalid 'stage' = %d, Check it!\\n\",\n\t\t\t       *stage);\n\t\t\treturn true;\n\t\t}\n\n\t\tif (currentcmd->cmdid == CMDID_END) {\n\t\t\tif ((*stage) == 2)\n\t\t\t\treturn true;\n\t\t\t(*stage)++;\n\t\t\t(*step) = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (currentcmd->cmdid) {\n\t\tcase CMDID_SET_TXPOWEROWER_LEVEL:\n\t\t\trtl88e_phy_set_txpower_level(hw, channel);\n\t\t\tbreak;\n\t\tcase CMDID_WRITEPORT_ULONG:\n\t\t\trtl_write_dword(rtlpriv, currentcmd->para1,\n\t\t\t\t\tcurrentcmd->para2);\n\t\t\tbreak;\n\t\tcase CMDID_WRITEPORT_USHORT:\n\t\t\trtl_write_word(rtlpriv, currentcmd->para1,\n\t\t\t\t       (u16)currentcmd->para2);\n\t\t\tbreak;\n\t\tcase CMDID_WRITEPORT_UCHAR:\n\t\t\trtl_write_byte(rtlpriv, currentcmd->para1,\n\t\t\t\t       (u8)currentcmd->para2);\n\t\t\tbreak;\n\t\tcase CMDID_RF_WRITEREG:\n\t\t\tfor (rfpath = 0; rfpath < num_total_rfpath; rfpath++) {\n\t\t\t\trtlphy->rfreg_chnlval[rfpath] =\n\t\t\t\t    ((rtlphy->rfreg_chnlval[rfpath] &\n\t\t\t\t      0xfffffc00) | currentcmd->para2);\n\n\t\t\t\trtl_set_rfreg(hw, (enum radio_path)rfpath,\n\t\t\t\t\t      currentcmd->para1,\n\t\t\t\t\t      RFREG_OFFSET_MASK,\n\t\t\t\t\t      rtlphy->rfreg_chnlval[rfpath]);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_LOUD,\n\t\t\t\t\"switch case %#x not processed\\n\",\n\t\t\t\tcurrentcmd->cmdid);\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\t} while (true);\n\n\t(*delay) = currentcmd->msdelay;\n\t(*step)++;\n\treturn false;\n}\n\nstatic bool _rtl88e_phy_set_sw_chnl_cmdarray(struct swchnlcmd *cmdtable,\n\t\t\t\t\t     u32 cmdtableidx, u32 cmdtablesz,\n\t\t\t\t\t     enum swchnlcmd_id cmdid,\n\t\t\t\t\t     u32 para1, u32 para2, u32 msdelay)\n{\n\tstruct swchnlcmd *pcmd;\n\n\tif (cmdtable == NULL) {\n\t\tWARN_ONCE(true, \"rtl8188ee: cmdtable cannot be NULL.\\n\");\n\t\treturn false;\n\t}\n\n\tif (cmdtableidx >= cmdtablesz)\n\t\treturn false;\n\n\tpcmd = cmdtable + cmdtableidx;\n\tpcmd->cmdid = cmdid;\n\tpcmd->para1 = para1;\n\tpcmd->para2 = para2;\n\tpcmd->msdelay = msdelay;\n\treturn true;\n}\n\nstatic u8 _rtl88e_phy_path_a_iqk(struct ieee80211_hw *hw, bool config_pathb)\n{\n\tu32 reg_eac, reg_e94, reg_e9c;\n\tu8 result = 0x00;\n\n\trtl_set_bbreg(hw, 0xe30, MASKDWORD, 0x10008c1c);\n\trtl_set_bbreg(hw, 0xe34, MASKDWORD, 0x30008c1c);\n\trtl_set_bbreg(hw, 0xe38, MASKDWORD, 0x8214032a);\n\trtl_set_bbreg(hw, 0xe3c, MASKDWORD, 0x28160000);\n\n\trtl_set_bbreg(hw, 0xe4c, MASKDWORD, 0x00462911);\n\trtl_set_bbreg(hw, 0xe48, MASKDWORD, 0xf9000000);\n\trtl_set_bbreg(hw, 0xe48, MASKDWORD, 0xf8000000);\n\n\tmdelay(IQK_DELAY_TIME);\n\n\treg_eac = rtl_get_bbreg(hw, 0xeac, MASKDWORD);\n\treg_e94 = rtl_get_bbreg(hw, 0xe94, MASKDWORD);\n\treg_e9c = rtl_get_bbreg(hw, 0xe9c, MASKDWORD);\n\trtl_get_bbreg(hw, 0xea4, MASKDWORD);\n\n\tif (!(reg_eac & BIT(28)) &&\n\t    (((reg_e94 & 0x03FF0000) >> 16) != 0x142) &&\n\t    (((reg_e9c & 0x03FF0000) >> 16) != 0x42))\n\t\tresult |= 0x01;\n\treturn result;\n}\n\nstatic u8 _rtl88e_phy_path_b_iqk(struct ieee80211_hw *hw)\n{\n\tu32 reg_eac, reg_eb4, reg_ebc, reg_ec4, reg_ecc;\n\tu8 result = 0x00;\n\n\trtl_set_bbreg(hw, 0xe60, MASKDWORD, 0x00000002);\n\trtl_set_bbreg(hw, 0xe60, MASKDWORD, 0x00000000);\n\tmdelay(IQK_DELAY_TIME);\n\treg_eac = rtl_get_bbreg(hw, 0xeac, MASKDWORD);\n\treg_eb4 = rtl_get_bbreg(hw, 0xeb4, MASKDWORD);\n\treg_ebc = rtl_get_bbreg(hw, 0xebc, MASKDWORD);\n\treg_ec4 = rtl_get_bbreg(hw, 0xec4, MASKDWORD);\n\treg_ecc = rtl_get_bbreg(hw, 0xecc, MASKDWORD);\n\n\tif (!(reg_eac & BIT(31)) &&\n\t    (((reg_eb4 & 0x03FF0000) >> 16) != 0x142) &&\n\t    (((reg_ebc & 0x03FF0000) >> 16) != 0x42))\n\t\tresult |= 0x01;\n\telse\n\t\treturn result;\n\tif (!(reg_eac & BIT(30)) &&\n\t    (((reg_ec4 & 0x03FF0000) >> 16) != 0x132) &&\n\t    (((reg_ecc & 0x03FF0000) >> 16) != 0x36))\n\t\tresult |= 0x02;\n\treturn result;\n}\n\nstatic u8 _rtl88e_phy_path_a_rx_iqk(struct ieee80211_hw *hw, bool config_pathb)\n{\n\tu32 reg_eac, reg_e94, reg_e9c, reg_ea4, u32temp;\n\tu8 result = 0x00;\n\n\t \n\t \n\trtl_set_bbreg(hw, RFPGA0_IQK, MASKDWORD, 0x00000000);\n\trtl_set_rfreg(hw, RF90_PATH_A, RF_WE_LUT, RFREG_OFFSET_MASK, 0x800a0);\n\trtl_set_rfreg(hw, RF90_PATH_A, RF_RCK_OS, RFREG_OFFSET_MASK, 0x30000);\n\trtl_set_rfreg(hw, RF90_PATH_A, RF_TXPA_G1, RFREG_OFFSET_MASK, 0x0000f);\n\trtl_set_rfreg(hw, RF90_PATH_A, RF_TXPA_G2, RFREG_OFFSET_MASK, 0xf117b);\n\trtl_set_bbreg(hw, RFPGA0_IQK, MASKDWORD, 0x80800000);\n\n\t \n\trtl_set_bbreg(hw, RTX_IQK, MASKDWORD, 0x01007c00);\n\trtl_set_bbreg(hw, RRX_IQK, MASKDWORD, 0x81004800);\n\n\t \n\trtl_set_bbreg(hw, RTX_IQK_TONE_A, MASKDWORD, 0x10008c1c);\n\trtl_set_bbreg(hw, RRX_IQK_TONE_A, MASKDWORD, 0x30008c1c);\n\trtl_set_bbreg(hw, RTX_IQK_PI_A, MASKDWORD, 0x82160804);\n\trtl_set_bbreg(hw, RRX_IQK_PI_A, MASKDWORD, 0x28160000);\n\n\t \n\trtl_set_bbreg(hw, RIQK_AGC_RSP, MASKDWORD, 0x0046a911);\n\t \n\trtl_set_bbreg(hw, RIQK_AGC_PTS, MASKDWORD, 0xf9000000);\n\trtl_set_bbreg(hw, RIQK_AGC_PTS, MASKDWORD, 0xf8000000);\n\n\tmdelay(IQK_DELAY_TIME);\n\n\treg_eac = rtl_get_bbreg(hw, RRX_POWER_AFTER_IQK_A_2, MASKDWORD);\n\treg_e94 = rtl_get_bbreg(hw, RTX_POWER_BEFORE_IQK_A, MASKDWORD);\n\treg_e9c = rtl_get_bbreg(hw, RTX_POWER_AFTER_IQK_A, MASKDWORD);\n\n\n\tif (!(reg_eac & BIT(28)) &&\n\t    (((reg_e94 & 0x03FF0000) >> 16) != 0x142) &&\n\t    (((reg_e9c & 0x03FF0000) >> 16) != 0x42))\n\t\tresult |= 0x01;\n\telse\n\t\treturn result;\n\n\tu32temp = 0x80007C00 | (reg_e94&0x3FF0000) |\n\t\t  ((reg_e9c&0x3FF0000) >> 16);\n\trtl_set_bbreg(hw, RTX_IQK, MASKDWORD, u32temp);\n\t \n\t \n\trtl_set_bbreg(hw, RFPGA0_IQK, MASKDWORD, 0x00000000);\n\trtl_set_rfreg(hw, RF90_PATH_A, RF_WE_LUT, RFREG_OFFSET_MASK, 0x800a0);\n\trtl_set_rfreg(hw, RF90_PATH_A, RF_RCK_OS, RFREG_OFFSET_MASK, 0x30000);\n\trtl_set_rfreg(hw, RF90_PATH_A, RF_TXPA_G1, RFREG_OFFSET_MASK, 0x0000f);\n\trtl_set_rfreg(hw, RF90_PATH_A, RF_TXPA_G2, RFREG_OFFSET_MASK, 0xf7ffa);\n\trtl_set_bbreg(hw, RFPGA0_IQK, MASKDWORD, 0x80800000);\n\n\t \n\trtl_set_bbreg(hw, RRX_IQK, MASKDWORD, 0x01004800);\n\n\t \n\trtl_set_bbreg(hw, RTX_IQK_TONE_A, MASKDWORD, 0x30008c1c);\n\trtl_set_bbreg(hw, RRX_IQK_TONE_A, MASKDWORD, 0x10008c1c);\n\trtl_set_bbreg(hw, RTX_IQK_PI_A, MASKDWORD, 0x82160c05);\n\trtl_set_bbreg(hw, RRX_IQK_PI_A, MASKDWORD, 0x28160c05);\n\n\t \n\trtl_set_bbreg(hw, RIQK_AGC_RSP, MASKDWORD, 0x0046a911);\n\t \n\trtl_set_bbreg(hw, RIQK_AGC_PTS, MASKDWORD, 0xf9000000);\n\trtl_set_bbreg(hw, RIQK_AGC_PTS, MASKDWORD, 0xf8000000);\n\n\tmdelay(IQK_DELAY_TIME);\n\n\treg_eac = rtl_get_bbreg(hw, RRX_POWER_AFTER_IQK_A_2, MASKDWORD);\n\treg_e94 = rtl_get_bbreg(hw, RTX_POWER_BEFORE_IQK_A, MASKDWORD);\n\treg_e9c = rtl_get_bbreg(hw, RTX_POWER_AFTER_IQK_A, MASKDWORD);\n\treg_ea4 = rtl_get_bbreg(hw, RRX_POWER_BEFORE_IQK_A_2, MASKDWORD);\n\n\tif (!(reg_eac & BIT(27)) &&\n\t    (((reg_ea4 & 0x03FF0000) >> 16) != 0x132) &&\n\t    (((reg_eac & 0x03FF0000) >> 16) != 0x36))\n\t\tresult |= 0x02;\n\treturn result;\n}\n\nstatic void _rtl88e_phy_path_a_fill_iqk_matrix(struct ieee80211_hw *hw,\n\t\t\t\t\t       bool iqk_ok, long result[][8],\n\t\t\t\t\t       u8 final_candidate, bool btxonly)\n{\n\tu32 oldval_0, x, tx0_a, reg;\n\tlong y, tx0_c;\n\n\tif (final_candidate == 0xFF) {\n\t\treturn;\n\t} else if (iqk_ok) {\n\t\toldval_0 = (rtl_get_bbreg(hw, ROFDM0_XATXIQIMBALANCE,\n\t\t\t\t\t  MASKDWORD) >> 22) & 0x3FF;\n\t\tx = result[final_candidate][0];\n\t\tif ((x & 0x00000200) != 0)\n\t\t\tx = x | 0xFFFFFC00;\n\t\ttx0_a = (x * oldval_0) >> 8;\n\t\trtl_set_bbreg(hw, ROFDM0_XATXIQIMBALANCE, 0x3FF, tx0_a);\n\t\trtl_set_bbreg(hw, ROFDM0_ECCATHRESHOLD, BIT(31),\n\t\t\t      ((x * oldval_0 >> 7) & 0x1));\n\t\ty = result[final_candidate][1];\n\t\tif ((y & 0x00000200) != 0)\n\t\t\ty = y | 0xFFFFFC00;\n\t\ttx0_c = (y * oldval_0) >> 8;\n\t\trtl_set_bbreg(hw, ROFDM0_XCTXAFE, 0xF0000000,\n\t\t\t      ((tx0_c & 0x3C0) >> 6));\n\t\trtl_set_bbreg(hw, ROFDM0_XATXIQIMBALANCE, 0x003F0000,\n\t\t\t      (tx0_c & 0x3F));\n\t\trtl_set_bbreg(hw, ROFDM0_ECCATHRESHOLD, BIT(29),\n\t\t\t      ((y * oldval_0 >> 7) & 0x1));\n\t\tif (btxonly)\n\t\t\treturn;\n\t\treg = result[final_candidate][2];\n\t\trtl_set_bbreg(hw, ROFDM0_XARXIQIMBALANCE, 0x3FF, reg);\n\t\treg = result[final_candidate][3] & 0x3F;\n\t\trtl_set_bbreg(hw, ROFDM0_XARXIQIMBALANCE, 0xFC00, reg);\n\t\treg = (result[final_candidate][3] >> 6) & 0xF;\n\t\trtl_set_bbreg(hw, 0xca0, 0xF0000000, reg);\n\t}\n}\n\nstatic void _rtl88e_phy_save_adda_registers(struct ieee80211_hw *hw,\n\t\t\t\t\t    u32 *addareg, u32 *addabackup,\n\t\t\t\t\t    u32 registernum)\n{\n\tu32 i;\n\n\tfor (i = 0; i < registernum; i++)\n\t\taddabackup[i] = rtl_get_bbreg(hw, addareg[i], MASKDWORD);\n}\n\nstatic void _rtl88e_phy_save_mac_registers(struct ieee80211_hw *hw,\n\t\t\t\t\t   u32 *macreg, u32 *macbackup)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 i;\n\n\tfor (i = 0; i < (IQK_MAC_REG_NUM - 1); i++)\n\t\tmacbackup[i] = rtl_read_byte(rtlpriv, macreg[i]);\n\tmacbackup[i] = rtl_read_dword(rtlpriv, macreg[i]);\n}\n\nstatic void _rtl88e_phy_reload_adda_registers(struct ieee80211_hw *hw,\n\t\t\t\t\t      u32 *addareg, u32 *addabackup,\n\t\t\t\t\t      u32 regiesternum)\n{\n\tu32 i;\n\n\tfor (i = 0; i < regiesternum; i++)\n\t\trtl_set_bbreg(hw, addareg[i], MASKDWORD, addabackup[i]);\n}\n\nstatic void _rtl88e_phy_reload_mac_registers(struct ieee80211_hw *hw,\n\t\t\t\t\t     u32 *macreg, u32 *macbackup)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 i;\n\n\tfor (i = 0; i < (IQK_MAC_REG_NUM - 1); i++)\n\t\trtl_write_byte(rtlpriv, macreg[i], (u8) macbackup[i]);\n\trtl_write_dword(rtlpriv, macreg[i], macbackup[i]);\n}\n\nstatic void _rtl88e_phy_path_adda_on(struct ieee80211_hw *hw,\n\t\t\t\t     u32 *addareg, bool is_patha_on, bool is2t)\n{\n\tu32 pathon;\n\tu32 i;\n\n\tpathon = is_patha_on ? 0x04db25a4 : 0x0b1b25a4;\n\tif (!is2t) {\n\t\tpathon = 0x0bdb25a0;\n\t\trtl_set_bbreg(hw, addareg[0], MASKDWORD, 0x0b1b25a0);\n\t} else {\n\t\trtl_set_bbreg(hw, addareg[0], MASKDWORD, pathon);\n\t}\n\n\tfor (i = 1; i < IQK_ADDA_REG_NUM; i++)\n\t\trtl_set_bbreg(hw, addareg[i], MASKDWORD, pathon);\n}\n\nstatic void _rtl88e_phy_mac_setting_calibration(struct ieee80211_hw *hw,\n\t\t\t\t\t\tu32 *macreg, u32 *macbackup)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 i = 0;\n\n\trtl_write_byte(rtlpriv, macreg[i], 0x3F);\n\n\tfor (i = 1; i < (IQK_MAC_REG_NUM - 1); i++)\n\t\trtl_write_byte(rtlpriv, macreg[i],\n\t\t\t       (u8) (macbackup[i] & (~BIT(3))));\n\trtl_write_byte(rtlpriv, macreg[i], (u8) (macbackup[i] & (~BIT(5))));\n}\n\nstatic void _rtl88e_phy_path_a_standby(struct ieee80211_hw *hw)\n{\n\trtl_set_bbreg(hw, 0xe28, MASKDWORD, 0x0);\n\trtl_set_bbreg(hw, 0x840, MASKDWORD, 0x00010000);\n\trtl_set_bbreg(hw, 0xe28, MASKDWORD, 0x80800000);\n}\n\nstatic void _rtl88e_phy_pi_mode_switch(struct ieee80211_hw *hw, bool pi_mode)\n{\n\tu32 mode;\n\n\tmode = pi_mode ? 0x01000100 : 0x01000000;\n\trtl_set_bbreg(hw, 0x820, MASKDWORD, mode);\n\trtl_set_bbreg(hw, 0x828, MASKDWORD, mode);\n}\n\nstatic bool _rtl88e_phy_simularity_compare(struct ieee80211_hw *hw,\n\t\t\t\t\t   long result[][8], u8 c1, u8 c2)\n{\n\tu32 i, j, diff, simularity_bitmap, bound;\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\n\tu8 final_candidate[2] = { 0xFF, 0xFF };\n\tbool bresult = true, is2t = IS_92C_SERIAL(rtlhal->version);\n\n\tif (is2t)\n\t\tbound = 8;\n\telse\n\t\tbound = 4;\n\n\tsimularity_bitmap = 0;\n\n\tfor (i = 0; i < bound; i++) {\n\t\tdiff = (result[c1][i] > result[c2][i]) ?\n\t\t    (result[c1][i] - result[c2][i]) :\n\t\t    (result[c2][i] - result[c1][i]);\n\n\t\tif (diff > MAX_TOLERANCE) {\n\t\t\tif ((i == 2 || i == 6) && !simularity_bitmap) {\n\t\t\t\tif (result[c1][i] + result[c1][i + 1] == 0)\n\t\t\t\t\tfinal_candidate[(i / 4)] = c2;\n\t\t\t\telse if (result[c2][i] + result[c2][i + 1] == 0)\n\t\t\t\t\tfinal_candidate[(i / 4)] = c1;\n\t\t\t\telse\n\t\t\t\t\tsimularity_bitmap = simularity_bitmap |\n\t\t\t\t\t    (1 << i);\n\t\t\t} else\n\t\t\t\tsimularity_bitmap =\n\t\t\t\t    simularity_bitmap | (1 << i);\n\t\t}\n\t}\n\n\tif (simularity_bitmap == 0) {\n\t\tfor (i = 0; i < (bound / 4); i++) {\n\t\t\tif (final_candidate[i] != 0xFF) {\n\t\t\t\tfor (j = i * 4; j < (i + 1) * 4 - 2; j++)\n\t\t\t\t\tresult[3][j] =\n\t\t\t\t\t    result[final_candidate[i]][j];\n\t\t\t\tbresult = false;\n\t\t\t}\n\t\t}\n\t\treturn bresult;\n\t} else if (!(simularity_bitmap & 0x0F)) {\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tresult[3][i] = result[c1][i];\n\t\treturn false;\n\t} else if (!(simularity_bitmap & 0xF0) && is2t) {\n\t\tfor (i = 4; i < 8; i++)\n\t\t\tresult[3][i] = result[c1][i];\n\t\treturn false;\n\t} else {\n\t\treturn false;\n\t}\n\n}\n\nstatic void _rtl88e_phy_iq_calibrate(struct ieee80211_hw *hw,\n\t\t\t\t     long result[][8], u8 t, bool is2t)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\tu32 i;\n\tu8 patha_ok, pathb_ok;\n\tu32 adda_reg[IQK_ADDA_REG_NUM] = {\n\t\t0x85c, 0xe6c, 0xe70, 0xe74,\n\t\t0xe78, 0xe7c, 0xe80, 0xe84,\n\t\t0xe88, 0xe8c, 0xed0, 0xed4,\n\t\t0xed8, 0xedc, 0xee0, 0xeec\n\t};\n\tu32 iqk_mac_reg[IQK_MAC_REG_NUM] = {\n\t\t0x522, 0x550, 0x551, 0x040\n\t};\n\tu32 iqk_bb_reg[IQK_BB_REG_NUM] = {\n\t\tROFDM0_TRXPATHENABLE, ROFDM0_TRMUXPAR,\n\t\tRFPGA0_XCD_RFINTERFACESW, 0xb68, 0xb6c,\n\t\t0x870, 0x860, 0x864, 0x800\n\t};\n\tconst u32 retrycount = 2;\n\n\tif (t == 0) {\n\t\t_rtl88e_phy_save_adda_registers(hw, adda_reg,\n\t\t\t\t\t\trtlphy->adda_backup, 16);\n\t\t_rtl88e_phy_save_mac_registers(hw, iqk_mac_reg,\n\t\t\t\t\t       rtlphy->iqk_mac_backup);\n\t\t_rtl88e_phy_save_adda_registers(hw, iqk_bb_reg,\n\t\t\t\t\t\trtlphy->iqk_bb_backup,\n\t\t\t\t\t\tIQK_BB_REG_NUM);\n\t}\n\t_rtl88e_phy_path_adda_on(hw, adda_reg, true, is2t);\n\tif (t == 0) {\n\t\trtlphy->rfpi_enable =\n\t\t  (u8)rtl_get_bbreg(hw, RFPGA0_XA_HSSIPARAMETER1, BIT(8));\n\t}\n\n\tif (!rtlphy->rfpi_enable)\n\t\t_rtl88e_phy_pi_mode_switch(hw, true);\n\t \n\trtl_set_bbreg(hw, 0x800, BIT(24), 0x00);\n\trtl_set_bbreg(hw, 0xc04, MASKDWORD, 0x03a05600);\n\trtl_set_bbreg(hw, 0xc08, MASKDWORD, 0x000800e4);\n\trtl_set_bbreg(hw, 0x874, MASKDWORD, 0x22204000);\n\n\trtl_set_bbreg(hw, 0x870, BIT(10), 0x01);\n\trtl_set_bbreg(hw, 0x870, BIT(26), 0x01);\n\trtl_set_bbreg(hw, 0x860, BIT(10), 0x00);\n\trtl_set_bbreg(hw, 0x864, BIT(10), 0x00);\n\n\tif (is2t) {\n\t\trtl_set_bbreg(hw, 0x840, MASKDWORD, 0x00010000);\n\t\trtl_set_bbreg(hw, 0x844, MASKDWORD, 0x00010000);\n\t}\n\t_rtl88e_phy_mac_setting_calibration(hw, iqk_mac_reg,\n\t\t\t\t\t    rtlphy->iqk_mac_backup);\n\trtl_set_bbreg(hw, 0xb68, MASKDWORD, 0x0f600000);\n\tif (is2t)\n\t\trtl_set_bbreg(hw, 0xb6c, MASKDWORD, 0x0f600000);\n\n\trtl_set_bbreg(hw, 0xe28, MASKDWORD, 0x80800000);\n\trtl_set_bbreg(hw, 0xe40, MASKDWORD, 0x01007c00);\n\trtl_set_bbreg(hw, 0xe44, MASKDWORD, 0x81004800);\n\tfor (i = 0; i < retrycount; i++) {\n\t\tpatha_ok = _rtl88e_phy_path_a_iqk(hw, is2t);\n\t\tif (patha_ok == 0x01) {\n\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\t\"Path A Tx IQK Success!!\\n\");\n\t\t\tresult[t][0] = (rtl_get_bbreg(hw, 0xe94, MASKDWORD) &\n\t\t\t\t\t0x3FF0000) >> 16;\n\t\t\tresult[t][1] = (rtl_get_bbreg(hw, 0xe9c, MASKDWORD) &\n\t\t\t\t\t0x3FF0000) >> 16;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (i = 0; i < retrycount; i++) {\n\t\tpatha_ok = _rtl88e_phy_path_a_rx_iqk(hw, is2t);\n\t\tif (patha_ok == 0x03) {\n\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\t\"Path A Rx IQK Success!!\\n\");\n\t\t\tresult[t][2] = (rtl_get_bbreg(hw, 0xea4, MASKDWORD) &\n\t\t\t\t\t0x3FF0000) >> 16;\n\t\t\tresult[t][3] = (rtl_get_bbreg(hw, 0xeac, MASKDWORD) &\n\t\t\t\t\t0x3FF0000) >> 16;\n\t\t\tbreak;\n\t\t} else {\n\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\t\"Path a RX iqk fail!!!\\n\");\n\t\t}\n\t}\n\n\tif (0 == patha_ok)\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\"Path A IQK Success!!\\n\");\n\tif (is2t) {\n\t\t_rtl88e_phy_path_a_standby(hw);\n\t\t_rtl88e_phy_path_adda_on(hw, adda_reg, false, is2t);\n\t\tfor (i = 0; i < retrycount; i++) {\n\t\t\tpathb_ok = _rtl88e_phy_path_b_iqk(hw);\n\t\t\tif (pathb_ok == 0x03) {\n\t\t\t\tresult[t][4] = (rtl_get_bbreg(hw,\n\t\t\t\t\t\t\t      0xeb4,\n\t\t\t\t\t\t\t      MASKDWORD) &\n\t\t\t\t\t\t0x3FF0000) >> 16;\n\t\t\t\tresult[t][5] =\n\t\t\t\t    (rtl_get_bbreg(hw, 0xebc, MASKDWORD) &\n\t\t\t\t     0x3FF0000) >> 16;\n\t\t\t\tresult[t][6] =\n\t\t\t\t    (rtl_get_bbreg(hw, 0xec4, MASKDWORD) &\n\t\t\t\t     0x3FF0000) >> 16;\n\t\t\t\tresult[t][7] =\n\t\t\t\t    (rtl_get_bbreg(hw, 0xecc, MASKDWORD) &\n\t\t\t\t     0x3FF0000) >> 16;\n\t\t\t\tbreak;\n\t\t\t} else if (i == (retrycount - 1) && pathb_ok == 0x01) {\n\t\t\t\tresult[t][4] = (rtl_get_bbreg(hw,\n\t\t\t\t\t\t\t      0xeb4,\n\t\t\t\t\t\t\t      MASKDWORD) &\n\t\t\t\t\t\t0x3FF0000) >> 16;\n\t\t\t}\n\t\t\tresult[t][5] = (rtl_get_bbreg(hw, 0xebc, MASKDWORD) &\n\t\t\t\t\t0x3FF0000) >> 16;\n\t\t}\n\t}\n\n\trtl_set_bbreg(hw, 0xe28, MASKDWORD, 0);\n\n\tif (t != 0) {\n\t\tif (!rtlphy->rfpi_enable)\n\t\t\t_rtl88e_phy_pi_mode_switch(hw, false);\n\t\t_rtl88e_phy_reload_adda_registers(hw, adda_reg,\n\t\t\t\t\t\t  rtlphy->adda_backup, 16);\n\t\t_rtl88e_phy_reload_mac_registers(hw, iqk_mac_reg,\n\t\t\t\t\t\t rtlphy->iqk_mac_backup);\n\t\t_rtl88e_phy_reload_adda_registers(hw, iqk_bb_reg,\n\t\t\t\t\t\t  rtlphy->iqk_bb_backup,\n\t\t\t\t\t\t  IQK_BB_REG_NUM);\n\n\t\trtl_set_bbreg(hw, 0x840, MASKDWORD, 0x00032ed3);\n\t\tif (is2t)\n\t\t\trtl_set_bbreg(hw, 0x844, MASKDWORD, 0x00032ed3);\n\t\trtl_set_bbreg(hw, 0xe30, MASKDWORD, 0x01008c00);\n\t\trtl_set_bbreg(hw, 0xe34, MASKDWORD, 0x01008c00);\n\t}\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD, \"88ee IQK Finish!!\\n\");\n}\n\nstatic void _rtl88e_phy_lc_calibrate(struct ieee80211_hw *hw, bool is2t)\n{\n\tu8 tmpreg;\n\tu32 rf_a_mode = 0, rf_b_mode = 0, lc_cal;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\ttmpreg = rtl_read_byte(rtlpriv, 0xd03);\n\n\tif ((tmpreg & 0x70) != 0)\n\t\trtl_write_byte(rtlpriv, 0xd03, tmpreg & 0x8F);\n\telse\n\t\trtl_write_byte(rtlpriv, REG_TXPAUSE, 0xFF);\n\n\tif ((tmpreg & 0x70) != 0) {\n\t\trf_a_mode = rtl_get_rfreg(hw, RF90_PATH_A, 0x00, MASK12BITS);\n\n\t\tif (is2t)\n\t\t\trf_b_mode = rtl_get_rfreg(hw, RF90_PATH_B, 0x00,\n\t\t\t\t\t\t  MASK12BITS);\n\n\t\trtl_set_rfreg(hw, RF90_PATH_A, 0x00, MASK12BITS,\n\t\t\t      (rf_a_mode & 0x8FFFF) | 0x10000);\n\n\t\tif (is2t)\n\t\t\trtl_set_rfreg(hw, RF90_PATH_B, 0x00, MASK12BITS,\n\t\t\t\t      (rf_b_mode & 0x8FFFF) | 0x10000);\n\t}\n\tlc_cal = rtl_get_rfreg(hw, RF90_PATH_A, 0x18, MASK12BITS);\n\n\trtl_set_rfreg(hw, RF90_PATH_A, 0x18, MASK12BITS, lc_cal | 0x08000);\n\n\tmdelay(100);\n\n\tif ((tmpreg & 0x70) != 0) {\n\t\trtl_write_byte(rtlpriv, 0xd03, tmpreg);\n\t\trtl_set_rfreg(hw, RF90_PATH_A, 0x00, MASK12BITS, rf_a_mode);\n\n\t\tif (is2t)\n\t\t\trtl_set_rfreg(hw, RF90_PATH_B, 0x00, MASK12BITS,\n\t\t\t\t      rf_b_mode);\n\t} else {\n\t\trtl_write_byte(rtlpriv, REG_TXPAUSE, 0x00);\n\t}\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD, \"\\n\");\n}\n\nstatic void _rtl88e_phy_set_rfpath_switch(struct ieee80211_hw *hw,\n\t\t\t\t\t  bool bmain, bool is2t)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD, \"\\n\");\n\n\tif (is_hal_stop(rtlhal)) {\n\t\tu8 u1btmp;\n\t\tu1btmp = rtl_read_byte(rtlpriv, REG_LEDCFG0);\n\t\trtl_write_byte(rtlpriv, REG_LEDCFG0, u1btmp | BIT(7));\n\t\trtl_set_bbreg(hw, RFPGA0_XAB_RFPARAMETER, BIT(13), 0x01);\n\t}\n\tif (is2t) {\n\t\tif (bmain)\n\t\t\trtl_set_bbreg(hw, RFPGA0_XB_RFINTERFACEOE,\n\t\t\t\t      BIT(5) | BIT(6), 0x1);\n\t\telse\n\t\t\trtl_set_bbreg(hw, RFPGA0_XB_RFINTERFACEOE,\n\t\t\t\t      BIT(5) | BIT(6), 0x2);\n\t} else {\n\t\trtl_set_bbreg(hw, RFPGA0_XAB_RFINTERFACESW, BIT(8) | BIT(9), 0);\n\t\trtl_set_bbreg(hw, 0x914, MASKLWORD, 0x0201);\n\n\t\t \n\t\tif (bmain) {\n\t\t\trtl_set_bbreg(hw, RFPGA0_XA_RFINTERFACEOE,\n\t\t\t\t      BIT(14) | BIT(13) | BIT(12), 0);\n\t\t\trtl_set_bbreg(hw, RFPGA0_XB_RFINTERFACEOE,\n\t\t\t\t      BIT(5) | BIT(4) | BIT(3), 0);\n\t\t\tif (rtlefuse->antenna_div_type == CGCS_RX_HW_ANTDIV)\n\t\t\t\trtl_set_bbreg(hw, RCONFIG_RAM64x16, BIT(31), 0);\n\t\t} else {\n\t\t\trtl_set_bbreg(hw, RFPGA0_XA_RFINTERFACEOE,\n\t\t\t\t      BIT(14) | BIT(13) | BIT(12), 1);\n\t\t\trtl_set_bbreg(hw, RFPGA0_XB_RFINTERFACEOE,\n\t\t\t\t      BIT(5) | BIT(4) | BIT(3), 1);\n\t\t\tif (rtlefuse->antenna_div_type == CGCS_RX_HW_ANTDIV)\n\t\t\t\trtl_set_bbreg(hw, RCONFIG_RAM64x16, BIT(31), 1);\n\t\t}\n\t}\n}\n\n#undef IQK_ADDA_REG_NUM\n#undef IQK_DELAY_TIME\n\nvoid rtl88e_phy_iq_calibrate(struct ieee80211_hw *hw, bool b_recovery)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\tlong result[4][8];\n\tu8 i, final_candidate;\n\tbool b_patha_ok;\n\tlong reg_e94, reg_e9c, reg_ea4, reg_eb4, reg_ebc,\n\t    reg_tmp = 0;\n\tbool is12simular, is13simular, is23simular;\n\tu32 iqk_bb_reg[9] = {\n\t\tROFDM0_XARXIQIMBALANCE,\n\t\tROFDM0_XBRXIQIMBALANCE,\n\t\tROFDM0_ECCATHRESHOLD,\n\t\tROFDM0_AGCRSSITABLE,\n\t\tROFDM0_XATXIQIMBALANCE,\n\t\tROFDM0_XBTXIQIMBALANCE,\n\t\tROFDM0_XCTXAFE,\n\t\tROFDM0_XDTXAFE,\n\t\tROFDM0_RXIQEXTANTA\n\t};\n\n\tif (b_recovery) {\n\t\t_rtl88e_phy_reload_adda_registers(hw,\n\t\t\t\t\t\t  iqk_bb_reg,\n\t\t\t\t\t\t  rtlphy->iqk_bb_backup, 9);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 8; i++) {\n\t\tresult[0][i] = 0;\n\t\tresult[1][i] = 0;\n\t\tresult[2][i] = 0;\n\t\tresult[3][i] = 0;\n\t}\n\tfinal_candidate = 0xff;\n\tb_patha_ok = false;\n\tis12simular = false;\n\tis23simular = false;\n\tis13simular = false;\n\tfor (i = 0; i < 3; i++) {\n\t\tif (get_rf_type(rtlphy) == RF_2T2R)\n\t\t\t_rtl88e_phy_iq_calibrate(hw, result, i, true);\n\t\telse\n\t\t\t_rtl88e_phy_iq_calibrate(hw, result, i, false);\n\t\tif (i == 1) {\n\t\t\tis12simular =\n\t\t\t  _rtl88e_phy_simularity_compare(hw, result, 0, 1);\n\t\t\tif (is12simular) {\n\t\t\t\tfinal_candidate = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == 2) {\n\t\t\tis13simular =\n\t\t\t  _rtl88e_phy_simularity_compare(hw, result, 0, 2);\n\t\t\tif (is13simular) {\n\t\t\t\tfinal_candidate = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tis23simular =\n\t\t\t   _rtl88e_phy_simularity_compare(hw, result, 1, 2);\n\t\t\tif (is23simular) {\n\t\t\t\tfinal_candidate = 1;\n\t\t\t} else {\n\t\t\t\tfor (i = 0; i < 8; i++)\n\t\t\t\t\treg_tmp += result[3][i];\n\n\t\t\t\tif (reg_tmp != 0)\n\t\t\t\t\tfinal_candidate = 3;\n\t\t\t\telse\n\t\t\t\t\tfinal_candidate = 0xFF;\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0; i < 4; i++) {\n\t\treg_e94 = result[i][0];\n\t\treg_e9c = result[i][1];\n\t\treg_ea4 = result[i][2];\n\t\treg_eb4 = result[i][4];\n\t\treg_ebc = result[i][5];\n\t}\n\tif (final_candidate != 0xff) {\n\t\treg_e94 = result[final_candidate][0];\n\t\treg_e9c = result[final_candidate][1];\n\t\treg_ea4 = result[final_candidate][2];\n\t\treg_eb4 = result[final_candidate][4];\n\t\treg_ebc = result[final_candidate][5];\n\t\trtlphy->reg_eb4 = reg_eb4;\n\t\trtlphy->reg_ebc = reg_ebc;\n\t\trtlphy->reg_e94 = reg_e94;\n\t\trtlphy->reg_e9c = reg_e9c;\n\t\tb_patha_ok = true;\n\t} else {\n\t\trtlphy->reg_e94 = 0x100;\n\t\trtlphy->reg_eb4 = 0x100;\n\t\trtlphy->reg_e9c = 0x0;\n\t\trtlphy->reg_ebc = 0x0;\n\t}\n\tif (reg_e94 != 0)  \n\t\t_rtl88e_phy_path_a_fill_iqk_matrix(hw, b_patha_ok, result,\n\t\t\t\t\t\t   final_candidate,\n\t\t\t\t\t\t   (reg_ea4 == 0));\n\tif (final_candidate != 0xFF) {\n\t\tfor (i = 0; i < IQK_MATRIX_REG_NUM; i++)\n\t\t\trtlphy->iqk_matrix[0].value[0][i] =\n\t\t\t\tresult[final_candidate][i];\n\t\trtlphy->iqk_matrix[0].iqk_done = true;\n\n\t}\n\t_rtl88e_phy_save_adda_registers(hw, iqk_bb_reg,\n\t\t\t\t\trtlphy->iqk_bb_backup, 9);\n}\n\nvoid rtl88e_phy_lc_calibrate(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\tstruct rtl_hal *rtlhal = &rtlpriv->rtlhal;\n\tu32 timeout = 2000, timecount = 0;\n\n\twhile (rtlpriv->mac80211.act_scanning && timecount < timeout) {\n\t\tudelay(50);\n\t\ttimecount += 50;\n\t}\n\n\trtlphy->lck_inprogress = true;\n\tRTPRINT(rtlpriv, FINIT, INIT_IQK,\n\t\t\"LCK:Start!!! currentband %x delay %d ms\\n\",\n\t\t rtlhal->current_bandtype, timecount);\n\n\t_rtl88e_phy_lc_calibrate(hw, false);\n\n\trtlphy->lck_inprogress = false;\n}\n\nvoid rtl88e_phy_set_rfpath_switch(struct ieee80211_hw *hw, bool bmain)\n{\n\t_rtl88e_phy_set_rfpath_switch(hw, bmain, false);\n}\n\nbool rtl88e_phy_set_io_cmd(struct ieee80211_hw *hw, enum io_type iotype)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\tbool postprocessing = false;\n\n\trtl_dbg(rtlpriv, COMP_CMD, DBG_TRACE,\n\t\t\"-->IO Cmd(%#x), set_io_inprogress(%d)\\n\",\n\t\tiotype, rtlphy->set_io_inprogress);\n\tdo {\n\t\tswitch (iotype) {\n\t\tcase IO_CMD_RESUME_DM_BY_SCAN:\n\t\t\trtl_dbg(rtlpriv, COMP_CMD, DBG_TRACE,\n\t\t\t\t\"[IO CMD] Resume DM after scan.\\n\");\n\t\t\tpostprocessing = true;\n\t\t\tbreak;\n\t\tcase IO_CMD_PAUSE_BAND0_DM_BY_SCAN:\n\t\t\trtl_dbg(rtlpriv, COMP_CMD, DBG_TRACE,\n\t\t\t\t\"[IO CMD] Pause DM before scan.\\n\");\n\t\t\tpostprocessing = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_LOUD,\n\t\t\t\t\"switch case %#x not processed\\n\", iotype);\n\t\t\tbreak;\n\t\t}\n\t} while (false);\n\tif (postprocessing && !rtlphy->set_io_inprogress) {\n\t\trtlphy->set_io_inprogress = true;\n\t\trtlphy->current_io_type = iotype;\n\t} else {\n\t\treturn false;\n\t}\n\trtl88e_phy_set_io(hw);\n\trtl_dbg(rtlpriv, COMP_CMD, DBG_TRACE, \"IO Type(%#x)\\n\", iotype);\n\treturn true;\n}\n\nstatic void rtl88e_phy_set_io(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\tstruct dig_t *dm_digtable = &rtlpriv->dm_digtable;\n\n\trtl_dbg(rtlpriv, COMP_CMD, DBG_TRACE,\n\t\t\"--->Cmd(%#x), set_io_inprogress(%d)\\n\",\n\t\trtlphy->current_io_type, rtlphy->set_io_inprogress);\n\tswitch (rtlphy->current_io_type) {\n\tcase IO_CMD_RESUME_DM_BY_SCAN:\n\t\tdm_digtable->cur_igvalue = rtlphy->initgain_backup.xaagccore1;\n\t\t \n\t\trtl88e_phy_set_txpower_level(hw, rtlphy->current_channel);\n\t\trtl_set_bbreg(hw, RCCK0_CCA, 0xff0000, 0x83);\n\t\tbreak;\n\tcase IO_CMD_PAUSE_BAND0_DM_BY_SCAN:\n\t\trtlphy->initgain_backup.xaagccore1 = dm_digtable->cur_igvalue;\n\t\tdm_digtable->cur_igvalue = 0x17;\n\t\trtl_set_bbreg(hw, RCCK0_CCA, 0xff0000, 0x40);\n\t\tbreak;\n\tdefault:\n\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_LOUD,\n\t\t\t\"switch case %#x not processed\\n\",\n\t\t\trtlphy->current_io_type);\n\t\tbreak;\n\t}\n\trtlphy->set_io_inprogress = false;\n\trtl_dbg(rtlpriv, COMP_CMD, DBG_TRACE,\n\t\t\"(%#x)\\n\", rtlphy->current_io_type);\n}\n\nstatic void rtl88ee_phy_set_rf_on(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtl_write_byte(rtlpriv, REG_SPS0_CTRL, 0x2b);\n\trtl_write_byte(rtlpriv, REG_SYS_FUNC_EN, 0xE3);\n\t \n\trtl_write_byte(rtlpriv, REG_SYS_FUNC_EN, 0xE2);\n\trtl_write_byte(rtlpriv, REG_SYS_FUNC_EN, 0xE3);\n\trtl_write_byte(rtlpriv, REG_TXPAUSE, 0x00);\n}\n\nstatic void _rtl88ee_phy_set_rf_sleep(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtl_write_byte(rtlpriv, REG_TXPAUSE, 0xFF);\n\trtl_set_rfreg(hw, RF90_PATH_A, 0x00, RFREG_OFFSET_MASK, 0x00);\n\trtl_write_byte(rtlpriv, REG_SYS_FUNC_EN, 0xE2);\n\trtl_write_byte(rtlpriv, REG_SPS0_CTRL, 0x22);\n}\n\nstatic bool _rtl88ee_phy_set_rf_power_state(struct ieee80211_hw *hw,\n\t\t\t\t\t    enum rf_pwrstate rfpwr_state)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci_priv *pcipriv = rtl_pcipriv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tbool bresult = true;\n\tu8 i, queue_id;\n\tstruct rtl8192_tx_ring *ring = NULL;\n\n\tswitch (rfpwr_state) {\n\tcase ERFON:\n\t\tif ((ppsc->rfpwr_state == ERFOFF) &&\n\t\t    RT_IN_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_HALT_NIC)) {\n\t\t\tbool rtstatus;\n\t\t\tu32 initializecount = 0;\n\n\t\t\tdo {\n\t\t\t\tinitializecount++;\n\t\t\t\trtl_dbg(rtlpriv, COMP_RF, DBG_DMESG,\n\t\t\t\t\t\"IPS Set eRf nic enable\\n\");\n\t\t\t\trtstatus = rtl_ps_enable_nic(hw);\n\t\t\t} while (!rtstatus &&\n\t\t\t\t (initializecount < 10));\n\t\t\tRT_CLEAR_PS_LEVEL(ppsc,\n\t\t\t\t\t  RT_RF_OFF_LEVL_HALT_NIC);\n\t\t} else {\n\t\t\trtl_dbg(rtlpriv, COMP_RF, DBG_DMESG,\n\t\t\t\t\"Set ERFON slept:%d ms\\n\",\n\t\t\t\tjiffies_to_msecs(jiffies -\n\t\t\t\t\t\t ppsc->last_sleep_jiffies));\n\t\t\tppsc->last_awake_jiffies = jiffies;\n\t\t\trtl88ee_phy_set_rf_on(hw);\n\t\t}\n\t\tif (mac->link_state == MAC80211_LINKED) {\n\t\t\trtlpriv->cfg->ops->led_control(hw,\n\t\t\t\t\t\t       LED_CTL_LINK);\n\t\t} else {\n\t\t\trtlpriv->cfg->ops->led_control(hw,\n\t\t\t\t\t\t       LED_CTL_NO_LINK);\n\t\t}\n\t\tbreak;\n\tcase ERFOFF:\n\t\tfor (queue_id = 0, i = 0;\n\t\t     queue_id < RTL_PCI_MAX_TX_QUEUE_COUNT;) {\n\t\t\tring = &pcipriv->dev.tx_ring[queue_id];\n\t\t\tif (queue_id == BEACON_QUEUE ||\n\t\t\t    skb_queue_len(&ring->queue) == 0) {\n\t\t\t\tqueue_id++;\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_WARNING,\n\t\t\t\t\t\"eRf Off/Sleep: %d times TcbBusyQueue[%d] =%d before doze!\\n\",\n\t\t\t\t\t(i + 1), queue_id,\n\t\t\t\t\tskb_queue_len(&ring->queue));\n\n\t\t\t\tudelay(10);\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tif (i >= MAX_DOZE_WAITING_TIMES_9x) {\n\t\t\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_WARNING,\n\t\t\t\t\t\"\\n ERFSLEEP: %d times TcbBusyQueue[%d] = %d !\\n\",\n\t\t\t\t\tMAX_DOZE_WAITING_TIMES_9x,\n\t\t\t\t\tqueue_id,\n\t\t\t\t\tskb_queue_len(&ring->queue));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ppsc->reg_rfps_level & RT_RF_OFF_LEVL_HALT_NIC) {\n\t\t\trtl_dbg(rtlpriv, COMP_RF, DBG_DMESG,\n\t\t\t\t\"IPS Set eRf nic disable\\n\");\n\t\t\trtl_ps_disable_nic(hw);\n\t\t\tRT_SET_PS_LEVEL(ppsc, RT_RF_OFF_LEVL_HALT_NIC);\n\t\t} else {\n\t\t\tif (ppsc->rfoff_reason == RF_CHANGE_BY_IPS) {\n\t\t\t\trtlpriv->cfg->ops->led_control(hw,\n\t\t\t\t\t\t\t       LED_CTL_NO_LINK);\n\t\t\t} else {\n\t\t\t\trtlpriv->cfg->ops->led_control(hw,\n\t\t\t\t\t\t\t       LED_CTL_POWER_OFF);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ERFSLEEP:{\n\t\t\tif (ppsc->rfpwr_state == ERFOFF)\n\t\t\t\tbreak;\n\t\t\tfor (queue_id = 0, i = 0;\n\t\t\t     queue_id < RTL_PCI_MAX_TX_QUEUE_COUNT;) {\n\t\t\t\tring = &pcipriv->dev.tx_ring[queue_id];\n\t\t\t\tif (skb_queue_len(&ring->queue) == 0) {\n\t\t\t\t\tqueue_id++;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_WARNING,\n\t\t\t\t\t\t\"eRf Off/Sleep: %d times TcbBusyQueue[%d] =%d before doze!\\n\",\n\t\t\t\t\t\t(i + 1), queue_id,\n\t\t\t\t\t\tskb_queue_len(&ring->queue));\n\n\t\t\t\t\tudelay(10);\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tif (i >= MAX_DOZE_WAITING_TIMES_9x) {\n\t\t\t\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_WARNING,\n\t\t\t\t\t\t\"\\n ERFSLEEP: %d times TcbBusyQueue[%d] = %d !\\n\",\n\t\t\t\t\t\tMAX_DOZE_WAITING_TIMES_9x,\n\t\t\t\t\t\tqueue_id,\n\t\t\t\t\t\tskb_queue_len(&ring->queue));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\trtl_dbg(rtlpriv, COMP_RF, DBG_DMESG,\n\t\t\t\t\"Set ERFSLEEP awaked:%d ms\\n\",\n\t\t\t\tjiffies_to_msecs(jiffies -\n\t\t\t\tppsc->last_awake_jiffies));\n\t\t\tppsc->last_sleep_jiffies = jiffies;\n\t\t\t_rtl88ee_phy_set_rf_sleep(hw);\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_LOUD,\n\t\t\t\"switch case %#x not processed\\n\", rfpwr_state);\n\t\tbresult = false;\n\t\tbreak;\n\t}\n\tif (bresult)\n\t\tppsc->rfpwr_state = rfpwr_state;\n\treturn bresult;\n}\n\nbool rtl88e_phy_set_rf_power_state(struct ieee80211_hw *hw,\n\t\t\t\t   enum rf_pwrstate rfpwr_state)\n{\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\n\tbool bresult = false;\n\n\tif (rfpwr_state == ppsc->rfpwr_state)\n\t\treturn bresult;\n\tbresult = _rtl88ee_phy_set_rf_power_state(hw, rfpwr_state);\n\treturn bresult;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}