{
  "module_name": "dm.c",
  "hash_id": "afee5812aaa3145b85464362399400b750e1116299fff81524ba7bf7c0b3b74a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtlwifi/rtl8188ee/dm.c",
  "human_readable_source": "\n \n\n#include \"../wifi.h\"\n#include \"../base.h\"\n#include \"../pci.h\"\n#include \"../core.h\"\n#include \"reg.h\"\n#include \"def.h\"\n#include \"phy.h\"\n#include \"dm.h\"\n#include \"fw.h\"\n#include \"trx.h\"\n\nstatic const u32 ofdmswing_table[OFDM_TABLE_SIZE] = {\n\t0x7f8001fe,\t\t \n\t0x788001e2,\t\t \n\t0x71c001c7,\t\t \n\t0x6b8001ae,\t\t \n\t0x65400195,\t\t \n\t0x5fc0017f,\t\t \n\t0x5a400169,\t\t \n\t0x55400155,\t\t \n\t0x50800142,\t\t \n\t0x4c000130,\t\t \n\t0x47c0011f,\t\t \n\t0x43c0010f,\t\t \n\t0x40000100,\t\t \n\t0x3c8000f2,\t\t \n\t0x390000e4,\t\t \n\t0x35c000d7,\t\t \n\t0x32c000cb,\t\t \n\t0x300000c0,\t\t \n\t0x2d4000b5,\t\t \n\t0x2ac000ab,\t\t \n\t0x288000a2,\t\t \n\t0x26000098,\t\t \n\t0x24000090,\t\t \n\t0x22000088,\t\t \n\t0x20000080,\t\t \n\t0x1e400079,\t\t \n\t0x1c800072,\t\t \n\t0x1b00006c,\t\t \n\t0x19800066,\t\t \n\t0x18000060,\t\t \n\t0x16c0005b,\t\t \n\t0x15800056,\t\t \n\t0x14400051,\t\t \n\t0x1300004c,\t\t \n\t0x12000048,\t\t \n\t0x11000044,\t\t \n\t0x10000040,\t\t \n\t0x0f00003c,\t\t \n\t0x0e400039,\t\t \n\t0x0d800036,\t\t \n\t0x0cc00033,\t\t \n\t0x0c000030,\t\t \n\t0x0b40002d,\t\t \n};\n\nstatic const u8 cck_tbl_ch1_13[CCK_TABLE_SIZE][8] = {\n\t{0x36, 0x35, 0x2e, 0x25, 0x1c, 0x12, 0x09, 0x04},\t \n\t{0x33, 0x32, 0x2b, 0x23, 0x1a, 0x11, 0x08, 0x04},\t \n\t{0x30, 0x2f, 0x29, 0x21, 0x19, 0x10, 0x08, 0x03},\t \n\t{0x2d, 0x2d, 0x27, 0x1f, 0x18, 0x0f, 0x08, 0x03},\t \n\t{0x2b, 0x2a, 0x25, 0x1e, 0x16, 0x0e, 0x07, 0x03},\t \n\t{0x28, 0x28, 0x22, 0x1c, 0x15, 0x0d, 0x07, 0x03},\t \n\t{0x26, 0x25, 0x21, 0x1b, 0x14, 0x0d, 0x06, 0x03},\t \n\t{0x24, 0x23, 0x1f, 0x19, 0x13, 0x0c, 0x06, 0x03},\t \n\t{0x22, 0x21, 0x1d, 0x18, 0x11, 0x0b, 0x06, 0x02},\t \n\t{0x20, 0x20, 0x1b, 0x16, 0x11, 0x08, 0x05, 0x02},\t \n\t{0x1f, 0x1e, 0x1a, 0x15, 0x10, 0x0a, 0x05, 0x02},\t \n\t{0x1d, 0x1c, 0x18, 0x14, 0x0f, 0x0a, 0x05, 0x02},\t \n\t{0x1b, 0x1a, 0x17, 0x13, 0x0e, 0x09, 0x04, 0x02},\t \n\t{0x1a, 0x19, 0x16, 0x12, 0x0d, 0x09, 0x04, 0x02},\t \n\t{0x18, 0x17, 0x15, 0x11, 0x0c, 0x08, 0x04, 0x02},\t \n\t{0x17, 0x16, 0x13, 0x10, 0x0c, 0x08, 0x04, 0x02},\t \n\t{0x16, 0x15, 0x12, 0x0f, 0x0b, 0x07, 0x04, 0x01},\t \n\t{0x14, 0x14, 0x11, 0x0e, 0x0b, 0x07, 0x03, 0x02},\t \n\t{0x13, 0x13, 0x10, 0x0d, 0x0a, 0x06, 0x03, 0x01},\t \n\t{0x12, 0x12, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},\t \n\t{0x11, 0x11, 0x0f, 0x0c, 0x09, 0x06, 0x03, 0x01},\t \n\t{0x10, 0x10, 0x0e, 0x0b, 0x08, 0x05, 0x03, 0x01},\t \n\t{0x0f, 0x0f, 0x0d, 0x0b, 0x08, 0x05, 0x03, 0x01},\t \n\t{0x0e, 0x0e, 0x0c, 0x0a, 0x08, 0x05, 0x02, 0x01},\t \n\t{0x0d, 0x0d, 0x0c, 0x0a, 0x07, 0x05, 0x02, 0x01},\t \n\t{0x0d, 0x0c, 0x0b, 0x09, 0x07, 0x04, 0x02, 0x01},\t \n\t{0x0c, 0x0c, 0x0a, 0x09, 0x06, 0x04, 0x02, 0x01},\t \n\t{0x0b, 0x0b, 0x0a, 0x08, 0x06, 0x04, 0x02, 0x01},\t \n\t{0x0b, 0x0a, 0x09, 0x08, 0x06, 0x04, 0x02, 0x01},\t \n\t{0x0a, 0x0a, 0x09, 0x07, 0x05, 0x03, 0x02, 0x01},\t \n\t{0x0a, 0x09, 0x08, 0x07, 0x05, 0x03, 0x02, 0x01},\t \n\t{0x09, 0x09, 0x08, 0x06, 0x05, 0x03, 0x01, 0x01},\t \n\t{0x09, 0x08, 0x07, 0x06, 0x04, 0x03, 0x01, 0x01}\t \n};\n\nstatic const u8 cck_tbl_ch14[CCK_TABLE_SIZE][8] = {\n\t{0x36, 0x35, 0x2e, 0x1b, 0x00, 0x00, 0x00, 0x00},\t \n\t{0x33, 0x32, 0x2b, 0x19, 0x00, 0x00, 0x00, 0x00},\t \n\t{0x30, 0x2f, 0x29, 0x18, 0x00, 0x00, 0x00, 0x00},\t \n\t{0x2d, 0x2d, 0x17, 0x17, 0x00, 0x00, 0x00, 0x00},\t \n\t{0x2b, 0x2a, 0x25, 0x15, 0x00, 0x00, 0x00, 0x00},\t \n\t{0x28, 0x28, 0x24, 0x14, 0x00, 0x00, 0x00, 0x00},\t \n\t{0x26, 0x25, 0x21, 0x13, 0x00, 0x00, 0x00, 0x00},\t \n\t{0x24, 0x23, 0x1f, 0x12, 0x00, 0x00, 0x00, 0x00},\t \n\t{0x22, 0x21, 0x1d, 0x11, 0x00, 0x00, 0x00, 0x00},\t \n\t{0x20, 0x20, 0x1b, 0x10, 0x00, 0x00, 0x00, 0x00},\t \n\t{0x1f, 0x1e, 0x1a, 0x0f, 0x00, 0x00, 0x00, 0x00},\t \n\t{0x1d, 0x1c, 0x18, 0x0e, 0x00, 0x00, 0x00, 0x00},\t \n\t{0x1b, 0x1a, 0x17, 0x0e, 0x00, 0x00, 0x00, 0x00},\t \n\t{0x1a, 0x19, 0x16, 0x0d, 0x00, 0x00, 0x00, 0x00},\t \n\t{0x18, 0x17, 0x15, 0x0c, 0x00, 0x00, 0x00, 0x00},\t \n\t{0x17, 0x16, 0x13, 0x0b, 0x00, 0x00, 0x00, 0x00},\t \n\t{0x16, 0x15, 0x12, 0x0b, 0x00, 0x00, 0x00, 0x00},\t \n\t{0x14, 0x14, 0x11, 0x0a, 0x00, 0x00, 0x00, 0x00},\t \n\t{0x13, 0x13, 0x10, 0x0a, 0x00, 0x00, 0x00, 0x00},\t \n\t{0x12, 0x12, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},\t \n\t{0x11, 0x11, 0x0f, 0x09, 0x00, 0x00, 0x00, 0x00},\t \n\t{0x10, 0x10, 0x0e, 0x08, 0x00, 0x00, 0x00, 0x00},\t \n\t{0x0f, 0x0f, 0x0d, 0x08, 0x00, 0x00, 0x00, 0x00},\t \n\t{0x0e, 0x0e, 0x0c, 0x07, 0x00, 0x00, 0x00, 0x00},\t \n\t{0x0d, 0x0d, 0x0c, 0x07, 0x00, 0x00, 0x00, 0x00},\t \n\t{0x0d, 0x0c, 0x0b, 0x06, 0x00, 0x00, 0x00, 0x00},\t \n\t{0x0c, 0x0c, 0x0a, 0x06, 0x00, 0x00, 0x00, 0x00},\t \n\t{0x0b, 0x0b, 0x0a, 0x06, 0x00, 0x00, 0x00, 0x00},\t \n\t{0x0b, 0x0a, 0x09, 0x05, 0x00, 0x00, 0x00, 0x00},\t \n\t{0x0a, 0x0a, 0x09, 0x05, 0x00, 0x00, 0x00, 0x00},\t \n\t{0x0a, 0x09, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00},\t \n\t{0x09, 0x09, 0x08, 0x05, 0x00, 0x00, 0x00, 0x00},\t \n\t{0x09, 0x08, 0x07, 0x04, 0x00, 0x00, 0x00, 0x00}\t \n};\n\n#define\tCAL_SWING_OFF(_off, _dir, _size, _del)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tfor (_off = 0; _off < _size; _off++) {\t\t\t\\\n\t\t\tif (_del < thermal_threshold[_dir][_off]) {\t\\\n\t\t\t\tif (_off != 0)\t\t\t\t\\\n\t\t\t\t\t_off--;\t\t\t\t\\\n\t\t\t\tbreak;\t\t\t\t\t\\\n\t\t\t}\t\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\tif (_off >= _size)\t\t\t\t\t\\\n\t\t\t_off = _size - 1;\t\t\t\t\\\n\t} while (0)\n\nstatic void rtl88e_set_iqk_matrix(struct ieee80211_hw *hw,\n\t\t\t\t  u8 ofdm_index, u8 rfpath,\n\t\t\t\t  long iqk_result_x, long iqk_result_y)\n{\n\tlong ele_a = 0, ele_d, ele_c = 0, value32;\n\n\tele_d = (ofdmswing_table[ofdm_index] & 0xFFC00000)>>22;\n\n\tif (iqk_result_x != 0) {\n\t\tif ((iqk_result_x & 0x00000200) != 0)\n\t\t\tiqk_result_x = iqk_result_x | 0xFFFFFC00;\n\t\tele_a = ((iqk_result_x * ele_d)>>8)&0x000003FF;\n\n\t\tif ((iqk_result_y & 0x00000200) != 0)\n\t\t\tiqk_result_y = iqk_result_y | 0xFFFFFC00;\n\t\tele_c = ((iqk_result_y * ele_d)>>8)&0x000003FF;\n\n\t\tswitch (rfpath) {\n\t\tcase RF90_PATH_A:\n\t\t\tvalue32 = (ele_d << 22)|((ele_c & 0x3F)<<16) | ele_a;\n\t\t\trtl_set_bbreg(hw, ROFDM0_XATXIQIMBALANCE,\n\t\t\t\t      MASKDWORD, value32);\n\t\t\tvalue32 = (ele_c & 0x000003C0) >> 6;\n\t\t\trtl_set_bbreg(hw, ROFDM0_XCTXAFE, MASKH4BITS,\n\t\t\t\t      value32);\n\t\t\tvalue32 = ((iqk_result_x * ele_d) >> 7) & 0x01;\n\t\t\trtl_set_bbreg(hw, ROFDM0_ECCATHRESHOLD, BIT(24),\n\t\t\t\t      value32);\n\t\t\tbreak;\n\t\tcase RF90_PATH_B:\n\t\t\tvalue32 = (ele_d << 22)|((ele_c & 0x3F)<<16) | ele_a;\n\t\t\trtl_set_bbreg(hw, ROFDM0_XBTXIQIMBALANCE, MASKDWORD,\n\t\t\t\t      value32);\n\t\t\tvalue32 = (ele_c & 0x000003C0) >> 6;\n\t\t\trtl_set_bbreg(hw, ROFDM0_XDTXAFE, MASKH4BITS, value32);\n\t\t\tvalue32 = ((iqk_result_x * ele_d) >> 7) & 0x01;\n\t\t\trtl_set_bbreg(hw, ROFDM0_ECCATHRESHOLD, BIT(28),\n\t\t\t\t      value32);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (rfpath) {\n\t\tcase RF90_PATH_A:\n\t\t\trtl_set_bbreg(hw, ROFDM0_XATXIQIMBALANCE,\n\t\t\t\t      MASKDWORD, ofdmswing_table[ofdm_index]);\n\t\t\trtl_set_bbreg(hw, ROFDM0_XCTXAFE,\n\t\t\t\t      MASKH4BITS, 0x00);\n\t\t\trtl_set_bbreg(hw, ROFDM0_ECCATHRESHOLD,\n\t\t\t\t      BIT(24), 0x00);\n\t\t\tbreak;\n\t\tcase RF90_PATH_B:\n\t\t\trtl_set_bbreg(hw, ROFDM0_XBTXIQIMBALANCE,\n\t\t\t\t      MASKDWORD, ofdmswing_table[ofdm_index]);\n\t\t\trtl_set_bbreg(hw, ROFDM0_XDTXAFE,\n\t\t\t\t      MASKH4BITS, 0x00);\n\t\t\trtl_set_bbreg(hw, ROFDM0_ECCATHRESHOLD,\n\t\t\t\t      BIT(28), 0x00);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid rtl88e_dm_txpower_track_adjust(struct ieee80211_hw *hw,\n\tu8 type, u8 *pdirection, u32 *poutwrite_val)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_dm *rtldm = rtl_dm(rtl_priv(hw));\n\tu8 pwr_val = 0;\n\tu8 cck_base = rtldm->swing_idx_cck_base;\n\tu8 cck_val = rtldm->swing_idx_cck;\n\tu8 ofdm_base = rtldm->swing_idx_ofdm_base[0];\n\tu8 ofdm_val = rtlpriv->dm.swing_idx_ofdm[RF90_PATH_A];\n\n\tif (type == 0) {\n\t\tif (ofdm_val <= ofdm_base) {\n\t\t\t*pdirection = 1;\n\t\t\tpwr_val = ofdm_base - ofdm_val;\n\t\t} else {\n\t\t\t*pdirection = 2;\n\t\t\tpwr_val = ofdm_base - ofdm_val;\n\t\t}\n\t} else if (type == 1) {\n\t\tif (cck_val <= cck_base) {\n\t\t\t*pdirection = 1;\n\t\t\tpwr_val = cck_base - cck_val;\n\t\t} else {\n\t\t\t*pdirection = 2;\n\t\t\tpwr_val = cck_val - cck_base;\n\t\t}\n\t}\n\n\tif (pwr_val >= TXPWRTRACK_MAX_IDX && (*pdirection == 1))\n\t\tpwr_val = TXPWRTRACK_MAX_IDX;\n\n\t*poutwrite_val = pwr_val | (pwr_val << 8) | (pwr_val << 16) |\n\t\t\t (pwr_val << 24);\n}\n\nstatic void dm_tx_pwr_track_set_pwr(struct ieee80211_hw *hw,\n\t\t\t\t    enum pwr_track_control_method method,\n\t\t\t\t    u8 rfpath, u8 channel_mapped_index)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\tstruct rtl_dm *rtldm = rtl_dm(rtl_priv(hw));\n\n\tif (method == TXAGC) {\n\t\tif (rtldm->swing_flag_ofdm ||\n\t\t    rtldm->swing_flag_cck) {\n\t\t\trtl88e_phy_set_txpower_level(hw,\n\t\t\t\t\t\t     rtlphy->current_channel);\n\t\t\trtldm->swing_flag_ofdm = false;\n\t\t\trtldm->swing_flag_cck = false;\n\t\t}\n\t} else if (method == BBSWING) {\n\t\tif (!rtldm->cck_inch14) {\n\t\t\trtl_write_byte(rtlpriv, 0xa22,\n\t\t\t\t       cck_tbl_ch1_13[rtldm->swing_idx_cck][0]);\n\t\t\trtl_write_byte(rtlpriv, 0xa23,\n\t\t\t\t       cck_tbl_ch1_13[rtldm->swing_idx_cck][1]);\n\t\t\trtl_write_byte(rtlpriv, 0xa24,\n\t\t\t\t       cck_tbl_ch1_13[rtldm->swing_idx_cck][2]);\n\t\t\trtl_write_byte(rtlpriv, 0xa25,\n\t\t\t\t       cck_tbl_ch1_13[rtldm->swing_idx_cck][3]);\n\t\t\trtl_write_byte(rtlpriv, 0xa26,\n\t\t\t\t       cck_tbl_ch1_13[rtldm->swing_idx_cck][4]);\n\t\t\trtl_write_byte(rtlpriv, 0xa27,\n\t\t\t\t       cck_tbl_ch1_13[rtldm->swing_idx_cck][5]);\n\t\t\trtl_write_byte(rtlpriv, 0xa28,\n\t\t\t\t       cck_tbl_ch1_13[rtldm->swing_idx_cck][6]);\n\t\t\trtl_write_byte(rtlpriv, 0xa29,\n\t\t\t\t       cck_tbl_ch1_13[rtldm->swing_idx_cck][7]);\n\t\t} else {\n\t\t\trtl_write_byte(rtlpriv, 0xa22,\n\t\t\t\t       cck_tbl_ch14[rtldm->swing_idx_cck][0]);\n\t\t\trtl_write_byte(rtlpriv, 0xa23,\n\t\t\t\t       cck_tbl_ch14[rtldm->swing_idx_cck][1]);\n\t\t\trtl_write_byte(rtlpriv, 0xa24,\n\t\t\t\t       cck_tbl_ch14[rtldm->swing_idx_cck][2]);\n\t\t\trtl_write_byte(rtlpriv, 0xa25,\n\t\t\t\t       cck_tbl_ch14[rtldm->swing_idx_cck][3]);\n\t\t\trtl_write_byte(rtlpriv, 0xa26,\n\t\t\t\t       cck_tbl_ch14[rtldm->swing_idx_cck][4]);\n\t\t\trtl_write_byte(rtlpriv, 0xa27,\n\t\t\t\t       cck_tbl_ch14[rtldm->swing_idx_cck][5]);\n\t\t\trtl_write_byte(rtlpriv, 0xa28,\n\t\t\t\t       cck_tbl_ch14[rtldm->swing_idx_cck][6]);\n\t\t\trtl_write_byte(rtlpriv, 0xa29,\n\t\t\t\t       cck_tbl_ch14[rtldm->swing_idx_cck][7]);\n\t\t}\n\n\t\tif (rfpath == RF90_PATH_A) {\n\t\t\trtl88e_set_iqk_matrix(hw, rtldm->swing_idx_ofdm[rfpath],\n\t\t\t\t\t      rfpath, rtlphy->iqk_matrix\n\t\t\t\t\t      [channel_mapped_index].\n\t\t\t\t\t      value[0][0],\n\t\t\t\t\t      rtlphy->iqk_matrix\n\t\t\t\t\t      [channel_mapped_index].\n\t\t\t\t\t      value[0][1]);\n\t\t} else if (rfpath == RF90_PATH_B) {\n\t\t\trtl88e_set_iqk_matrix(hw, rtldm->swing_idx_ofdm[rfpath],\n\t\t\t\t\t      rfpath, rtlphy->iqk_matrix\n\t\t\t\t\t      [channel_mapped_index].\n\t\t\t\t\t      value[0][4],\n\t\t\t\t\t      rtlphy->iqk_matrix\n\t\t\t\t\t      [channel_mapped_index].\n\t\t\t\t\t      value[0][5]);\n\t\t}\n\t} else {\n\t\treturn;\n\t}\n}\n\nstatic u8 rtl88e_dm_initial_gain_min_pwdb(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct dig_t *dm_dig = &rtlpriv->dm_digtable;\n\tlong rssi_val_min = 0;\n\n\tif ((dm_dig->curmultista_cstate == DIG_MULTISTA_CONNECT) &&\n\t    (dm_dig->cur_sta_cstate == DIG_STA_CONNECT)) {\n\t\tif (rtlpriv->dm.entry_min_undec_sm_pwdb != 0)\n\t\t\trssi_val_min =\n\t\t\t    (rtlpriv->dm.entry_min_undec_sm_pwdb >\n\t\t\t     rtlpriv->dm.undec_sm_pwdb) ?\n\t\t\t    rtlpriv->dm.undec_sm_pwdb :\n\t\t\t    rtlpriv->dm.entry_min_undec_sm_pwdb;\n\t\telse\n\t\t\trssi_val_min = rtlpriv->dm.undec_sm_pwdb;\n\t} else if (dm_dig->cur_sta_cstate == DIG_STA_CONNECT ||\n\t\t   dm_dig->cur_sta_cstate == DIG_STA_BEFORE_CONNECT) {\n\t\trssi_val_min = rtlpriv->dm.undec_sm_pwdb;\n\t} else if (dm_dig->curmultista_cstate ==\n\t\tDIG_MULTISTA_CONNECT) {\n\t\trssi_val_min = rtlpriv->dm.entry_min_undec_sm_pwdb;\n\t}\n\n\treturn (u8)rssi_val_min;\n}\n\nstatic void rtl88e_dm_false_alarm_counter_statistics(struct ieee80211_hw *hw)\n{\n\tu32 ret_value;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct false_alarm_statistics *falsealm_cnt = &rtlpriv->falsealm_cnt;\n\n\trtl_set_bbreg(hw, ROFDM0_LSTF, BIT(31), 1);\n\trtl_set_bbreg(hw, ROFDM1_LSTF, BIT(31), 1);\n\n\tret_value = rtl_get_bbreg(hw, ROFDM0_FRAMESYNC, MASKDWORD);\n\tfalsealm_cnt->cnt_fast_fsync_fail = (ret_value&0xffff);\n\tfalsealm_cnt->cnt_sb_search_fail = ((ret_value&0xffff0000)>>16);\n\n\tret_value = rtl_get_bbreg(hw, ROFDM_PHYCOUNTER1, MASKDWORD);\n\tfalsealm_cnt->cnt_ofdm_cca = (ret_value&0xffff);\n\tfalsealm_cnt->cnt_parity_fail = ((ret_value & 0xffff0000) >> 16);\n\n\tret_value = rtl_get_bbreg(hw, ROFDM_PHYCOUNTER2, MASKDWORD);\n\tfalsealm_cnt->cnt_rate_illegal = (ret_value & 0xffff);\n\tfalsealm_cnt->cnt_crc8_fail = ((ret_value & 0xffff0000) >> 16);\n\n\tret_value = rtl_get_bbreg(hw, ROFDM_PHYCOUNTER3, MASKDWORD);\n\tfalsealm_cnt->cnt_mcs_fail = (ret_value & 0xffff);\n\tfalsealm_cnt->cnt_ofdm_fail = falsealm_cnt->cnt_parity_fail +\n\t\tfalsealm_cnt->cnt_rate_illegal +\n\t\tfalsealm_cnt->cnt_crc8_fail +\n\t\tfalsealm_cnt->cnt_mcs_fail +\n\t\tfalsealm_cnt->cnt_fast_fsync_fail +\n\t\tfalsealm_cnt->cnt_sb_search_fail;\n\n\tret_value = rtl_get_bbreg(hw, REG_SC_CNT, MASKDWORD);\n\tfalsealm_cnt->cnt_bw_lsc = (ret_value & 0xffff);\n\tfalsealm_cnt->cnt_bw_usc = ((ret_value & 0xffff0000) >> 16);\n\n\trtl_set_bbreg(hw, RCCK0_FALSEALARMREPORT, BIT(12), 1);\n\trtl_set_bbreg(hw, RCCK0_FALSEALARMREPORT, BIT(14), 1);\n\n\tret_value = rtl_get_bbreg(hw, RCCK0_FACOUNTERLOWER, MASKBYTE0);\n\tfalsealm_cnt->cnt_cck_fail = ret_value;\n\n\tret_value = rtl_get_bbreg(hw, RCCK0_FACOUNTERUPPER, MASKBYTE3);\n\tfalsealm_cnt->cnt_cck_fail += (ret_value & 0xff) << 8;\n\n\tret_value = rtl_get_bbreg(hw, RCCK0_CCA_CNT, MASKDWORD);\n\tfalsealm_cnt->cnt_cck_cca = ((ret_value & 0xff) << 8) |\n\t\t((ret_value&0xFF00)>>8);\n\n\tfalsealm_cnt->cnt_all = (falsealm_cnt->cnt_fast_fsync_fail +\n\t\t\t\tfalsealm_cnt->cnt_sb_search_fail +\n\t\t\t\tfalsealm_cnt->cnt_parity_fail +\n\t\t\t\tfalsealm_cnt->cnt_rate_illegal +\n\t\t\t\tfalsealm_cnt->cnt_crc8_fail +\n\t\t\t\tfalsealm_cnt->cnt_mcs_fail +\n\t\t\t\tfalsealm_cnt->cnt_cck_fail);\n\tfalsealm_cnt->cnt_cca_all = falsealm_cnt->cnt_ofdm_cca +\n\t\tfalsealm_cnt->cnt_cck_cca;\n\n\trtl_set_bbreg(hw, ROFDM0_TRSWISOLATION, BIT(31), 1);\n\trtl_set_bbreg(hw, ROFDM0_TRSWISOLATION, BIT(31), 0);\n\trtl_set_bbreg(hw, ROFDM1_LSTF, BIT(27), 1);\n\trtl_set_bbreg(hw, ROFDM1_LSTF, BIT(27), 0);\n\trtl_set_bbreg(hw, ROFDM0_LSTF, BIT(31), 0);\n\trtl_set_bbreg(hw, ROFDM1_LSTF, BIT(31), 0);\n\trtl_set_bbreg(hw, RCCK0_FALSEALARMREPORT, BIT(13)|BIT(12), 0);\n\trtl_set_bbreg(hw, RCCK0_FALSEALARMREPORT, BIT(13)|BIT(12), 2);\n\trtl_set_bbreg(hw, RCCK0_FALSEALARMREPORT, BIT(15)|BIT(14), 0);\n\trtl_set_bbreg(hw, RCCK0_FALSEALARMREPORT, BIT(15)|BIT(14), 2);\n\n\trtl_dbg(rtlpriv, COMP_DIG, DBG_TRACE,\n\t\t\"cnt_parity_fail = %d, cnt_rate_illegal = %d, cnt_crc8_fail = %d, cnt_mcs_fail = %d\\n\",\n\t\tfalsealm_cnt->cnt_parity_fail,\n\t\tfalsealm_cnt->cnt_rate_illegal,\n\t\tfalsealm_cnt->cnt_crc8_fail, falsealm_cnt->cnt_mcs_fail);\n\n\trtl_dbg(rtlpriv, COMP_DIG, DBG_TRACE,\n\t\t\"cnt_ofdm_fail = %x, cnt_cck_fail = %x, cnt_all = %x\\n\",\n\t\tfalsealm_cnt->cnt_ofdm_fail,\n\t\tfalsealm_cnt->cnt_cck_fail, falsealm_cnt->cnt_all);\n}\n\nstatic void rtl88e_dm_cck_packet_detection_thresh(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct dig_t *dm_dig = &rtlpriv->dm_digtable;\n\tu8 cur_cck_cca_thresh;\n\n\tif (dm_dig->cur_sta_cstate == DIG_STA_CONNECT) {\n\t\tdm_dig->rssi_val_min = rtl88e_dm_initial_gain_min_pwdb(hw);\n\t\tif (dm_dig->rssi_val_min > 25) {\n\t\t\tcur_cck_cca_thresh = 0xcd;\n\t\t} else if ((dm_dig->rssi_val_min <= 25) &&\n\t\t\t   (dm_dig->rssi_val_min > 10)) {\n\t\t\tcur_cck_cca_thresh = 0x83;\n\t\t} else {\n\t\t\tif (rtlpriv->falsealm_cnt.cnt_cck_fail > 1000)\n\t\t\t\tcur_cck_cca_thresh = 0x83;\n\t\t\telse\n\t\t\t\tcur_cck_cca_thresh = 0x40;\n\t\t}\n\n\t} else {\n\t\tif (rtlpriv->falsealm_cnt.cnt_cck_fail > 1000)\n\t\t\tcur_cck_cca_thresh = 0x83;\n\t\telse\n\t\t\tcur_cck_cca_thresh = 0x40;\n\t}\n\n\tif (dm_dig->cur_cck_cca_thres != cur_cck_cca_thresh)\n\t\trtl_set_bbreg(hw, RCCK0_CCA, MASKBYTE2, cur_cck_cca_thresh);\n\n\tdm_dig->cur_cck_cca_thres = cur_cck_cca_thresh;\n\tdm_dig->pre_cck_cca_thres = dm_dig->cur_cck_cca_thres;\n\trtl_dbg(rtlpriv, COMP_DIG, DBG_TRACE,\n\t\t\"CCK cca thresh hold =%x\\n\", dm_dig->cur_cck_cca_thres);\n}\n\nstatic void rtl88e_dm_dig(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tstruct dig_t *dm_dig = &rtlpriv->dm_digtable;\n\tu8 dig_dynamic_min, dig_maxofmin;\n\tbool bfirstconnect;\n\tu8 dm_dig_max, dm_dig_min;\n\tu8 current_igi = dm_dig->cur_igvalue;\n\n\tif (!rtlpriv->dm.dm_initialgain_enable)\n\t\treturn;\n\tif (!dm_dig->dig_enable_flag)\n\t\treturn;\n\tif (mac->act_scanning)\n\t\treturn;\n\n\tif (mac->link_state >= MAC80211_LINKED)\n\t\tdm_dig->cur_sta_cstate = DIG_STA_CONNECT;\n\telse\n\t\tdm_dig->cur_sta_cstate = DIG_STA_DISCONNECT;\n\tif (rtlpriv->mac80211.opmode == NL80211_IFTYPE_AP ||\n\t    rtlpriv->mac80211.opmode == NL80211_IFTYPE_ADHOC)\n\t\tdm_dig->cur_sta_cstate = DIG_STA_DISCONNECT;\n\n\tdm_dig_max = DM_DIG_MAX;\n\tdm_dig_min = DM_DIG_MIN;\n\tdig_maxofmin = DM_DIG_MAX_AP;\n\tdig_dynamic_min = dm_dig->dig_min_0;\n\tbfirstconnect = ((mac->link_state >= MAC80211_LINKED) ? true : false) &&\n\t\t\t !dm_dig->media_connect_0;\n\n\tdm_dig->rssi_val_min =\n\t\trtl88e_dm_initial_gain_min_pwdb(hw);\n\n\tif (mac->link_state >= MAC80211_LINKED) {\n\t\tif ((dm_dig->rssi_val_min + 20) > dm_dig_max)\n\t\t\tdm_dig->rx_gain_max = dm_dig_max;\n\t\telse if ((dm_dig->rssi_val_min + 20) < dm_dig_min)\n\t\t\tdm_dig->rx_gain_max = dm_dig_min;\n\t\telse\n\t\t\tdm_dig->rx_gain_max = dm_dig->rssi_val_min + 20;\n\n\t\tif (rtlefuse->antenna_div_type == CG_TRX_HW_ANTDIV) {\n\t\t\tdig_dynamic_min  = dm_dig->antdiv_rssi_max;\n\t\t} else {\n\t\t\tif (dm_dig->rssi_val_min < dm_dig_min)\n\t\t\t\tdig_dynamic_min = dm_dig_min;\n\t\t\telse if (dm_dig->rssi_val_min < dig_maxofmin)\n\t\t\t\tdig_dynamic_min = dig_maxofmin;\n\t\t\telse\n\t\t\t\tdig_dynamic_min = dm_dig->rssi_val_min;\n\t\t}\n\t} else {\n\t\tdm_dig->rx_gain_max = dm_dig_max;\n\t\tdig_dynamic_min = dm_dig_min;\n\t\trtl_dbg(rtlpriv, COMP_DIG, DBG_LOUD, \"no link\\n\");\n\t}\n\n\tif (rtlpriv->falsealm_cnt.cnt_all > 10000) {\n\t\tdm_dig->large_fa_hit++;\n\t\tif (dm_dig->forbidden_igi < current_igi) {\n\t\t\tdm_dig->forbidden_igi = current_igi;\n\t\t\tdm_dig->large_fa_hit = 1;\n\t\t}\n\n\t\tif (dm_dig->large_fa_hit >= 3) {\n\t\t\tif ((dm_dig->forbidden_igi + 1) >\n\t\t\t\tdm_dig->rx_gain_max)\n\t\t\t\tdm_dig->rx_gain_min =\n\t\t\t\t\tdm_dig->rx_gain_max;\n\t\t\telse\n\t\t\t\tdm_dig->rx_gain_min =\n\t\t\t\t\tdm_dig->forbidden_igi + 1;\n\t\t\tdm_dig->recover_cnt = 3600;\n\t\t}\n\t} else {\n\t\tif (dm_dig->recover_cnt != 0) {\n\t\t\tdm_dig->recover_cnt--;\n\t\t} else {\n\t\t\tif (dm_dig->large_fa_hit == 0) {\n\t\t\t\tif ((dm_dig->forbidden_igi - 1) <\n\t\t\t\t    dig_dynamic_min) {\n\t\t\t\t\tdm_dig->forbidden_igi = dig_dynamic_min;\n\t\t\t\t\tdm_dig->rx_gain_min = dig_dynamic_min;\n\t\t\t\t} else {\n\t\t\t\t\tdm_dig->forbidden_igi--;\n\t\t\t\t\tdm_dig->rx_gain_min =\n\t\t\t\t\t\tdm_dig->forbidden_igi + 1;\n\t\t\t\t}\n\t\t\t} else if (dm_dig->large_fa_hit == 3) {\n\t\t\t\tdm_dig->large_fa_hit = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dm_dig->cur_sta_cstate == DIG_STA_CONNECT) {\n\t\tif (bfirstconnect) {\n\t\t\tcurrent_igi = dm_dig->rssi_val_min;\n\t\t} else {\n\t\t\tif (rtlpriv->falsealm_cnt.cnt_all > DM_DIG_FA_TH2)\n\t\t\t\tcurrent_igi += 2;\n\t\t\telse if (rtlpriv->falsealm_cnt.cnt_all > DM_DIG_FA_TH1)\n\t\t\t\tcurrent_igi++;\n\t\t\telse if (rtlpriv->falsealm_cnt.cnt_all < DM_DIG_FA_TH0)\n\t\t\t\tcurrent_igi--;\n\t\t}\n\t} else {\n\t\tif (rtlpriv->falsealm_cnt.cnt_all > 10000)\n\t\t\tcurrent_igi += 2;\n\t\telse if (rtlpriv->falsealm_cnt.cnt_all > 8000)\n\t\t\tcurrent_igi++;\n\t\telse if (rtlpriv->falsealm_cnt.cnt_all < 500)\n\t\t\tcurrent_igi--;\n\t}\n\n\tif (current_igi > DM_DIG_FA_UPPER)\n\t\tcurrent_igi = DM_DIG_FA_UPPER;\n\telse if (current_igi < DM_DIG_FA_LOWER)\n\t\tcurrent_igi = DM_DIG_FA_LOWER;\n\n\tif (rtlpriv->falsealm_cnt.cnt_all > 10000)\n\t\tcurrent_igi = DM_DIG_FA_UPPER;\n\n\tdm_dig->cur_igvalue = current_igi;\n\trtl88e_dm_write_dig(hw);\n\tdm_dig->media_connect_0 =\n\t\t((mac->link_state >= MAC80211_LINKED) ? true : false);\n\tdm_dig->dig_min_0 = dig_dynamic_min;\n\n\trtl88e_dm_cck_packet_detection_thresh(hw);\n}\n\nstatic void rtl88e_dm_init_dynamic_txpower(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtlpriv->dm.dynamic_txpower_enable = false;\n\n\trtlpriv->dm.last_dtp_lvl = TXHIGHPWRLEVEL_NORMAL;\n\trtlpriv->dm.dynamic_txhighpower_lvl = TXHIGHPWRLEVEL_NORMAL;\n}\n\nstatic void rtl92c_dm_dynamic_txpower(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tlong undec_sm_pwdb;\n\n\tif (!rtlpriv->dm.dynamic_txpower_enable)\n\t\treturn;\n\n\tif (rtlpriv->dm.dm_flag & HAL_DM_HIPWR_DISABLE) {\n\t\trtlpriv->dm.dynamic_txhighpower_lvl = TXHIGHPWRLEVEL_NORMAL;\n\t\treturn;\n\t}\n\n\tif ((mac->link_state < MAC80211_LINKED) &&\n\t    (rtlpriv->dm.entry_min_undec_sm_pwdb == 0)) {\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_TRACE,\n\t\t\t\"Not connected to any\\n\");\n\n\t\trtlpriv->dm.dynamic_txhighpower_lvl = TXHIGHPWRLEVEL_NORMAL;\n\n\t\trtlpriv->dm.last_dtp_lvl = TXHIGHPWRLEVEL_NORMAL;\n\t\treturn;\n\t}\n\n\tif (mac->link_state >= MAC80211_LINKED) {\n\t\tif (mac->opmode == NL80211_IFTYPE_ADHOC) {\n\t\t\tundec_sm_pwdb =\n\t\t\t    rtlpriv->dm.entry_min_undec_sm_pwdb;\n\t\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD,\n\t\t\t\t\"AP Client PWDB = 0x%lx\\n\",\n\t\t\t\tundec_sm_pwdb);\n\t\t} else {\n\t\t\tundec_sm_pwdb =\n\t\t\t    rtlpriv->dm.undec_sm_pwdb;\n\t\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD,\n\t\t\t\t\"STA Default Port PWDB = 0x%lx\\n\",\n\t\t\t\tundec_sm_pwdb);\n\t\t}\n\t} else {\n\t\tundec_sm_pwdb =\n\t\t    rtlpriv->dm.entry_min_undec_sm_pwdb;\n\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD,\n\t\t\t\"AP Ext Port PWDB = 0x%lx\\n\",\n\t\t\tundec_sm_pwdb);\n\t}\n\n\tif (undec_sm_pwdb >= TX_POWER_NEAR_FIELD_THRESH_LVL2) {\n\t\trtlpriv->dm.dynamic_txhighpower_lvl = TXHIGHPWRLEVEL_LEVEL1;\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD,\n\t\t\t\"TXHIGHPWRLEVEL_LEVEL1 (TxPwr = 0x0)\\n\");\n\t} else if ((undec_sm_pwdb <\n\t\t    (TX_POWER_NEAR_FIELD_THRESH_LVL2 - 3)) &&\n\t\t   (undec_sm_pwdb >=\n\t\t    TX_POWER_NEAR_FIELD_THRESH_LVL1)) {\n\t\trtlpriv->dm.dynamic_txhighpower_lvl = TXHIGHPWRLEVEL_LEVEL1;\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD,\n\t\t\t\"TXHIGHPWRLEVEL_LEVEL1 (TxPwr = 0x10)\\n\");\n\t} else if (undec_sm_pwdb <\n\t\t   (TX_POWER_NEAR_FIELD_THRESH_LVL1 - 5)) {\n\t\trtlpriv->dm.dynamic_txhighpower_lvl = TXHIGHPWRLEVEL_NORMAL;\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD,\n\t\t\t\"TXHIGHPWRLEVEL_NORMAL\\n\");\n\t}\n\n\tif ((rtlpriv->dm.dynamic_txhighpower_lvl !=\n\t\trtlpriv->dm.last_dtp_lvl)) {\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_LOUD,\n\t\t\t\"PHY_SetTxPowerLevel8192S() Channel = %d\\n\",\n\t\t\t  rtlphy->current_channel);\n\t\trtl88e_phy_set_txpower_level(hw, rtlphy->current_channel);\n\t}\n\n\trtlpriv->dm.last_dtp_lvl = rtlpriv->dm.dynamic_txhighpower_lvl;\n}\n\nvoid rtl88e_dm_write_dig(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct dig_t *dm_dig = &rtlpriv->dm_digtable;\n\n\trtl_dbg(rtlpriv, COMP_DIG, DBG_LOUD,\n\t\t\"cur_igvalue = 0x%x, pre_igvalue = 0x%x, backoff_val = %d\\n\",\n\t\t dm_dig->cur_igvalue, dm_dig->pre_igvalue,\n\t\t dm_dig->back_val);\n\n\tif (dm_dig->cur_igvalue > 0x3f)\n\t\tdm_dig->cur_igvalue = 0x3f;\n\tif (dm_dig->pre_igvalue != dm_dig->cur_igvalue) {\n\t\trtl_set_bbreg(hw, ROFDM0_XAAGCCORE1, 0x7f,\n\t\t\t      dm_dig->cur_igvalue);\n\n\t\tdm_dig->pre_igvalue = dm_dig->cur_igvalue;\n\t}\n}\n\nstatic void rtl88e_dm_pwdb_monitor(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_sta_info *drv_priv;\n\tstatic u64 last_record_txok_cnt;\n\tstatic u64 last_record_rxok_cnt;\n\tlong tmp_entry_max_pwdb = 0, tmp_entry_min_pwdb = 0xff;\n\n\tif (rtlhal->oem_id == RT_CID_819X_HP) {\n\t\tu64 cur_txok_cnt = 0;\n\t\tu64 cur_rxok_cnt = 0;\n\t\tcur_txok_cnt = rtlpriv->stats.txbytesunicast -\n\t\t\tlast_record_txok_cnt;\n\t\tcur_rxok_cnt = rtlpriv->stats.rxbytesunicast -\n\t\t\tlast_record_rxok_cnt;\n\t\tlast_record_txok_cnt = cur_txok_cnt;\n\t\tlast_record_rxok_cnt = cur_rxok_cnt;\n\n\t\tif (cur_rxok_cnt > (cur_txok_cnt * 6))\n\t\t\trtl_write_dword(rtlpriv, REG_ARFR0, 0x8f015);\n\t\telse\n\t\t\trtl_write_dword(rtlpriv, REG_ARFR0, 0xff015);\n\t}\n\n\t \n\tspin_lock_bh(&rtlpriv->locks.entry_list_lock);\n\tlist_for_each_entry(drv_priv, &rtlpriv->entry_list, list) {\n\t\tif (drv_priv->rssi_stat.undec_sm_pwdb <\n\t\t\ttmp_entry_min_pwdb)\n\t\t\ttmp_entry_min_pwdb = drv_priv->rssi_stat.undec_sm_pwdb;\n\t\tif (drv_priv->rssi_stat.undec_sm_pwdb >\n\t\t\ttmp_entry_max_pwdb)\n\t\t\ttmp_entry_max_pwdb = drv_priv->rssi_stat.undec_sm_pwdb;\n\t}\n\tspin_unlock_bh(&rtlpriv->locks.entry_list_lock);\n\n\t \n\tif (tmp_entry_max_pwdb != 0) {\n\t\trtlpriv->dm.entry_max_undec_sm_pwdb = tmp_entry_max_pwdb;\n\t\tRTPRINT(rtlpriv, FDM, DM_PWDB, \"EntryMaxPWDB = 0x%lx(%ld)\\n\",\n\t\t\ttmp_entry_max_pwdb, tmp_entry_max_pwdb);\n\t} else {\n\t\trtlpriv->dm.entry_max_undec_sm_pwdb = 0;\n\t}\n\t \n\tif (tmp_entry_min_pwdb != 0xff) {\n\t\trtlpriv->dm.entry_min_undec_sm_pwdb = tmp_entry_min_pwdb;\n\t\tRTPRINT(rtlpriv, FDM, DM_PWDB, \"EntryMinPWDB = 0x%lx(%ld)\\n\",\n\t\t\t\t\ttmp_entry_min_pwdb, tmp_entry_min_pwdb);\n\t} else {\n\t\trtlpriv->dm.entry_min_undec_sm_pwdb = 0;\n\t}\n\t \n\tif (!rtlpriv->dm.useramask)\n\t\trtl_write_byte(rtlpriv, 0x4fe, rtlpriv->dm.undec_sm_pwdb);\n}\n\nvoid rtl88e_dm_init_edca_turbo(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtlpriv->dm.current_turbo_edca = false;\n\trtlpriv->dm.is_any_nonbepkts = false;\n\trtlpriv->dm.is_cur_rdlstate = false;\n}\n\nstatic void rtl88e_dm_check_edca_turbo(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstatic u64 last_txok_cnt;\n\tstatic u64 last_rxok_cnt;\n\tstatic u32 last_bt_edca_ul;\n\tstatic u32 last_bt_edca_dl;\n\tu64 cur_txok_cnt = 0;\n\tu64 cur_rxok_cnt = 0;\n\tu32 edca_be_ul = 0x5ea42b;\n\tu32 edca_be_dl = 0x5ea42b;\n\tbool bt_change_edca = false;\n\n\tif ((last_bt_edca_ul != rtlpriv->btcoexist.bt_edca_ul) ||\n\t    (last_bt_edca_dl != rtlpriv->btcoexist.bt_edca_dl)) {\n\t\trtlpriv->dm.current_turbo_edca = false;\n\t\tlast_bt_edca_ul = rtlpriv->btcoexist.bt_edca_ul;\n\t\tlast_bt_edca_dl = rtlpriv->btcoexist.bt_edca_dl;\n\t}\n\n\tif (rtlpriv->btcoexist.bt_edca_ul != 0) {\n\t\tedca_be_ul = rtlpriv->btcoexist.bt_edca_ul;\n\t\tbt_change_edca = true;\n\t}\n\n\tif (rtlpriv->btcoexist.bt_edca_dl != 0) {\n\t\tedca_be_dl = rtlpriv->btcoexist.bt_edca_dl;\n\t\tbt_change_edca = true;\n\t}\n\n\tif (mac->link_state != MAC80211_LINKED) {\n\t\trtlpriv->dm.current_turbo_edca = false;\n\t\treturn;\n\t}\n\tif ((bt_change_edca) ||\n\t    ((!rtlpriv->dm.is_any_nonbepkts) &&\n\t     (!rtlpriv->dm.disable_framebursting))) {\n\n\t\tcur_txok_cnt = rtlpriv->stats.txbytesunicast - last_txok_cnt;\n\t\tcur_rxok_cnt = rtlpriv->stats.rxbytesunicast - last_rxok_cnt;\n\n\t\tif (cur_rxok_cnt > 4 * cur_txok_cnt) {\n\t\t\tif (!rtlpriv->dm.is_cur_rdlstate ||\n\t\t\t    !rtlpriv->dm.current_turbo_edca) {\n\t\t\t\trtl_write_dword(rtlpriv,\n\t\t\t\t\t\tREG_EDCA_BE_PARAM,\n\t\t\t\t\t\tedca_be_dl);\n\t\t\t\trtlpriv->dm.is_cur_rdlstate = true;\n\t\t\t}\n\t\t} else {\n\t\t\tif (rtlpriv->dm.is_cur_rdlstate ||\n\t\t\t    !rtlpriv->dm.current_turbo_edca) {\n\t\t\t\trtl_write_dword(rtlpriv,\n\t\t\t\t\t\tREG_EDCA_BE_PARAM,\n\t\t\t\t\t\tedca_be_ul);\n\t\t\t\trtlpriv->dm.is_cur_rdlstate = false;\n\t\t\t}\n\t\t}\n\t\trtlpriv->dm.current_turbo_edca = true;\n\t} else {\n\t\tif (rtlpriv->dm.current_turbo_edca) {\n\t\t\tu8 tmp = AC0_BE;\n\n\t\t\trtlpriv->cfg->ops->set_hw_reg(hw,\n\t\t\t\t\t\t      HW_VAR_AC_PARAM,\n\t\t\t\t\t\t      &tmp);\n\t\t\trtlpriv->dm.current_turbo_edca = false;\n\t\t}\n\t}\n\n\trtlpriv->dm.is_any_nonbepkts = false;\n\tlast_txok_cnt = rtlpriv->stats.txbytesunicast;\n\tlast_rxok_cnt = rtlpriv->stats.rxbytesunicast;\n}\n\nstatic void dm_txpower_track_cb_therm(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tstruct rtl_dm\t*rtldm = rtl_dm(rtl_priv(hw));\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tu8 thermalvalue = 0, delta, delta_lck, delta_iqk, offset;\n\tu8 thermalvalue_avg_count = 0;\n\tu32 thermalvalue_avg = 0;\n\tlong  ele_d, temp_cck;\n\ts8 ofdm_index[2], cck_index = 0,\n\t\tofdm_index_old[2] = {0, 0}, cck_index_old = 0;\n\tint i = 0;\n\t \n\n\tu8 ofdm_min_index = 6, rf = 1;\n\t \n\tenum _power_dec_inc {power_dec, power_inc};\n\n\t \n\tstatic const s8 delta_swing_table_idx[2][15]  = {\n\t\t{0, 0, 2, 3, 4, 4, 5, 6, 7, 7, 8, 9, 10, 10, 11},\n\t\t{0, 0, -1, -2, -3, -4, -4, -4, -4, -5, -7, -8, -9, -9, -10}\n\t};\n\tstatic const u8 thermal_threshold[2][15] = {\n\t\t{0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 27},\n\t\t{0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 25, 25, 25}\n\t};\n\n\t \n\trtlpriv->dm.txpower_trackinginit = true;\n\trtl_dbg(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\n\t\t\"%s\\n\", __func__);\n\n\tthermalvalue = (u8)rtl_get_rfreg(hw, RF90_PATH_A, RF_T_METER,\n\t\t\t\t\t 0xfc00);\n\tif (!thermalvalue)\n\t\treturn;\n\trtl_dbg(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\n\t\t\"Readback Thermal Meter = 0x%x pre thermal meter 0x%x eeprom_thermalmeter 0x%x\\n\",\n\t\tthermalvalue, rtlpriv->dm.thermalvalue,\n\t\trtlefuse->eeprom_thermalmeter);\n\n\t \n\tele_d = rtl_get_bbreg(hw, ROFDM0_XATXIQIMBALANCE, MASKDWORD) &\n\t\t\t      MASKOFDM_D;\n\tfor (i = 0; i < OFDM_TABLE_LENGTH; i++) {\n\t\tif (ele_d == (ofdmswing_table[i] & MASKOFDM_D)) {\n\t\t\tofdm_index_old[0] = (u8)i;\n\t\t\trtldm->swing_idx_ofdm_base[RF90_PATH_A] = (u8)i;\n\t\t\trtl_dbg(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\n\t\t\t\t\"Initial pathA ele_d reg0x%x = 0x%lx, ofdm_index = 0x%x\\n\",\n\t\t\t\t ROFDM0_XATXIQIMBALANCE,\n\t\t\t\t ele_d, ofdm_index_old[0]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\ttemp_cck = rtl_get_bbreg(hw, RCCK0_TXFILTER2, MASKDWORD) & MASKCCK;\n\tfor (i = 0; i < CCK_TABLE_LENGTH; i++) {\n\t\tif (rtlpriv->dm.cck_inch14) {\n\t\t\tif (memcmp(&temp_cck, &cck_tbl_ch14[i][2], 4) == 0) {\n\t\t\t\tcck_index_old = (u8)i;\n\t\t\t\trtldm->swing_idx_cck_base = (u8)i;\n\t\t\t\trtl_dbg(rtlpriv, COMP_POWER_TRACKING,\n\t\t\t\t\tDBG_LOUD,\n\t\t\t\t\t\"Initial reg0x%x = 0x%lx, cck_index = 0x%x, ch 14 %d\\n\",\n\t\t\t\t\tRCCK0_TXFILTER2, temp_cck,\n\t\t\t\t\tcck_index_old,\n\t\t\t\t\trtlpriv->dm.cck_inch14);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (memcmp(&temp_cck, &cck_tbl_ch1_13[i][2], 4) == 0) {\n\t\t\t\tcck_index_old = (u8)i;\n\t\t\t\trtldm->swing_idx_cck_base = (u8)i;\n\t\t\t\trtl_dbg(rtlpriv, COMP_POWER_TRACKING,\n\t\t\t\t\tDBG_LOUD,\n\t\t\t\t\t\"Initial reg0x%x = 0x%lx, cck_index = 0x%x, ch14 %d\\n\",\n\t\t\t\t\tRCCK0_TXFILTER2, temp_cck,\n\t\t\t\t\tcck_index_old,\n\t\t\t\t\trtlpriv->dm.cck_inch14);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (!rtldm->thermalvalue) {\n\t\trtlpriv->dm.thermalvalue = rtlefuse->eeprom_thermalmeter;\n\t\trtlpriv->dm.thermalvalue_lck = thermalvalue;\n\t\trtlpriv->dm.thermalvalue_iqk = thermalvalue;\n\t\tfor (i = 0; i < rf; i++)\n\t\t\trtlpriv->dm.ofdm_index[i] = ofdm_index_old[i];\n\t\trtlpriv->dm.cck_index = cck_index_old;\n\t}\n\n\t \n\trtldm->thermalvalue_avg[rtldm->thermalvalue_avg_index] = thermalvalue;\n\trtldm->thermalvalue_avg_index++;\n\tif (rtldm->thermalvalue_avg_index == AVG_THERMAL_NUM_88E)\n\t\trtldm->thermalvalue_avg_index = 0;\n\n\tfor (i = 0; i < AVG_THERMAL_NUM_88E; i++) {\n\t\tif (rtldm->thermalvalue_avg[i]) {\n\t\t\tthermalvalue_avg += rtldm->thermalvalue_avg[i];\n\t\t\tthermalvalue_avg_count++;\n\t\t}\n\t}\n\n\tif (thermalvalue_avg_count)\n\t\tthermalvalue = (u8)(thermalvalue_avg / thermalvalue_avg_count);\n\n\t \n\tif (rtlhal->reloadtxpowerindex) {\n\t\tdelta = (thermalvalue > rtlefuse->eeprom_thermalmeter) ?\n\t\t    (thermalvalue - rtlefuse->eeprom_thermalmeter) :\n\t\t    (rtlefuse->eeprom_thermalmeter - thermalvalue);\n\t\trtlhal->reloadtxpowerindex = false;\n\t\trtlpriv->dm.done_txpower = false;\n\t} else if (rtlpriv->dm.done_txpower) {\n\t\tdelta = (thermalvalue > rtlpriv->dm.thermalvalue) ?\n\t\t    (thermalvalue - rtlpriv->dm.thermalvalue) :\n\t\t    (rtlpriv->dm.thermalvalue - thermalvalue);\n\t} else {\n\t\tdelta = (thermalvalue > rtlefuse->eeprom_thermalmeter) ?\n\t\t    (thermalvalue - rtlefuse->eeprom_thermalmeter) :\n\t\t    (rtlefuse->eeprom_thermalmeter - thermalvalue);\n\t}\n\tdelta_lck = (thermalvalue > rtlpriv->dm.thermalvalue_lck) ?\n\t    (thermalvalue - rtlpriv->dm.thermalvalue_lck) :\n\t    (rtlpriv->dm.thermalvalue_lck - thermalvalue);\n\tdelta_iqk = (thermalvalue > rtlpriv->dm.thermalvalue_iqk) ?\n\t    (thermalvalue - rtlpriv->dm.thermalvalue_iqk) :\n\t    (rtlpriv->dm.thermalvalue_iqk - thermalvalue);\n\n\trtl_dbg(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\n\t\t\"Readback Thermal Meter = 0x%x pre thermal meter 0x%x eeprom_thermalmeter 0x%x delta 0x%x delta_lck 0x%x delta_iqk 0x%x\\n\",\n\t\tthermalvalue, rtlpriv->dm.thermalvalue,\n\t\trtlefuse->eeprom_thermalmeter, delta, delta_lck,\n\t\tdelta_iqk);\n\t \n\tif (delta_lck >= 8) {\n\t\trtlpriv->dm.thermalvalue_lck = thermalvalue;\n\t\trtl88e_phy_lc_calibrate(hw);\n\t}\n\n\t \n\tif (delta > 0 && rtlpriv->dm.txpower_track_control) {\n\t\tdelta = (thermalvalue > rtlefuse->eeprom_thermalmeter) ?\n\t\t    (thermalvalue - rtlefuse->eeprom_thermalmeter) :\n\t\t    (rtlefuse->eeprom_thermalmeter - thermalvalue);\n\n\t\t \n\t\tif (thermalvalue > rtlefuse->eeprom_thermalmeter) {\n\t\t\tCAL_SWING_OFF(offset, power_inc, INDEX_MAPPING_NUM,\n\t\t\t\t      delta);\n\t\t\tfor (i = 0; i < rf; i++)\n\t\t\t\tofdm_index[i] =\n\t\t\t\t  rtldm->ofdm_index[i] +\n\t\t\t\t  delta_swing_table_idx[power_inc][offset];\n\t\t\tcck_index = rtldm->cck_index +\n\t\t\t\tdelta_swing_table_idx[power_inc][offset];\n\t\t} else {\n\t\t\tCAL_SWING_OFF(offset, power_dec, INDEX_MAPPING_NUM,\n\t\t\t\t      delta);\n\t\t\tfor (i = 0; i < rf; i++)\n\t\t\t\tofdm_index[i] =\n\t\t\t\t  rtldm->ofdm_index[i] +\n\t\t\t\t  delta_swing_table_idx[power_dec][offset];\n\t\t\tcck_index = rtldm->cck_index +\n\t\t\t\tdelta_swing_table_idx[power_dec][offset];\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < rf; i++) {\n\t\t\tif (ofdm_index[i] > OFDM_TABLE_SIZE-1)\n\t\t\t\tofdm_index[i] = OFDM_TABLE_SIZE-1;\n\t\t\telse if (rtldm->ofdm_index[i] < ofdm_min_index)\n\t\t\t\tofdm_index[i] = ofdm_min_index;\n\t\t}\n\n\t\tif (cck_index > CCK_TABLE_SIZE-1)\n\t\t\tcck_index = CCK_TABLE_SIZE-1;\n\t\telse if (cck_index < 0)\n\t\t\tcck_index = 0;\n\n\t\t \n\t\tif (rtlpriv->dm.txpower_track_control) {\n\t\t\trtldm->done_txpower = true;\n\t\t\trtldm->swing_idx_ofdm[RF90_PATH_A] =\n\t\t\t\t(u8)ofdm_index[RF90_PATH_A];\n\t\t\trtldm->swing_idx_cck = cck_index;\n\t\t\tif (rtldm->swing_idx_ofdm_cur !=\n\t\t\t    rtldm->swing_idx_ofdm[0]) {\n\t\t\t\trtldm->swing_idx_ofdm_cur =\n\t\t\t\t\t rtldm->swing_idx_ofdm[0];\n\t\t\t\trtldm->swing_flag_ofdm = true;\n\t\t\t}\n\n\t\t\tif (rtldm->swing_idx_cck_cur != rtldm->swing_idx_cck) {\n\t\t\t\trtldm->swing_idx_cck_cur = rtldm->swing_idx_cck;\n\t\t\t\trtldm->swing_flag_cck = true;\n\t\t\t}\n\n\t\t\tdm_tx_pwr_track_set_pwr(hw, TXAGC, 0, 0);\n\t\t}\n\t}\n\n\tif (delta_iqk >= 8) {\n\t\trtlpriv->dm.thermalvalue_iqk = thermalvalue;\n\t\trtl88e_phy_iq_calibrate(hw, false);\n\t}\n\n\tif (rtldm->txpower_track_control)\n\t\trtldm->thermalvalue = thermalvalue;\n\trtldm->txpowercount = 0;\n\trtl_dbg(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD, \"end\\n\");\n}\n\nstatic void rtl88e_dm_init_txpower_tracking(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtlpriv->dm.txpower_tracking = true;\n\trtlpriv->dm.txpower_trackinginit = false;\n\trtlpriv->dm.txpowercount = 0;\n\trtlpriv->dm.txpower_track_control = true;\n\n\trtlpriv->dm.swing_idx_ofdm[RF90_PATH_A] = 12;\n\trtlpriv->dm.swing_idx_ofdm_cur = 12;\n\trtlpriv->dm.swing_flag_ofdm = false;\n\trtl_dbg(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\n\t\t\"rtlpriv->dm.txpower_tracking = %d\\n\",\n\t\trtlpriv->dm.txpower_tracking);\n}\n\nvoid rtl88e_dm_check_txpower_tracking(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\tif (!rtlpriv->dm.txpower_tracking)\n\t\treturn;\n\n\tif (!rtlpriv->dm.tm_trigger) {\n\t\trtl_set_rfreg(hw, RF90_PATH_A, RF_T_METER, BIT(17)|BIT(16),\n\t\t\t      0x03);\n\t\trtl_dbg(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\n\t\t\t\"Trigger 88E Thermal Meter!!\\n\");\n\t\trtlpriv->dm.tm_trigger = 1;\n\t\treturn;\n\t} else {\n\t\trtl_dbg(rtlpriv, COMP_POWER_TRACKING, DBG_LOUD,\n\t\t\t\"Schedule TxPowerTracking !!\\n\");\n\t\tdm_txpower_track_cb_therm(hw);\n\t\trtlpriv->dm.tm_trigger = 0;\n\t}\n}\n\nvoid rtl88e_dm_init_rate_adaptive_mask(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rate_adaptive *p_ra = &rtlpriv->ra;\n\n\tp_ra->ratr_state = DM_RATR_STA_INIT;\n\tp_ra->pre_ratr_state = DM_RATR_STA_INIT;\n\n\tif (rtlpriv->dm.dm_type == DM_TYPE_BYDRIVER)\n\t\trtlpriv->dm.useramask = true;\n\telse\n\t\trtlpriv->dm.useramask = false;\n}\n\nstatic void rtl88e_dm_refresh_rate_adaptive_mask(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rate_adaptive *p_ra = &rtlpriv->ra;\n\tu32 low_rssithresh_for_ra, high_rssithresh_for_ra;\n\tstruct ieee80211_sta *sta = NULL;\n\n\tif (is_hal_stop(rtlhal)) {\n\t\trtl_dbg(rtlpriv, COMP_RATE, DBG_LOUD,\n\t\t\t\"driver is going to unload\\n\");\n\t\treturn;\n\t}\n\n\tif (!rtlpriv->dm.useramask) {\n\t\trtl_dbg(rtlpriv, COMP_RATE, DBG_LOUD,\n\t\t\t\"driver does not control rate adaptive mask\\n\");\n\t\treturn;\n\t}\n\n\tif (mac->link_state == MAC80211_LINKED &&\n\t    mac->opmode == NL80211_IFTYPE_STATION) {\n\t\tswitch (p_ra->pre_ratr_state) {\n\t\tcase DM_RATR_STA_HIGH:\n\t\t\thigh_rssithresh_for_ra = 50;\n\t\t\tlow_rssithresh_for_ra = 20;\n\t\t\tbreak;\n\t\tcase DM_RATR_STA_MIDDLE:\n\t\t\thigh_rssithresh_for_ra = 55;\n\t\t\tlow_rssithresh_for_ra = 20;\n\t\t\tbreak;\n\t\tcase DM_RATR_STA_LOW:\n\t\t\thigh_rssithresh_for_ra = 50;\n\t\t\tlow_rssithresh_for_ra = 25;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\thigh_rssithresh_for_ra = 50;\n\t\t\tlow_rssithresh_for_ra = 20;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rtlpriv->dm.undec_sm_pwdb >\n\t\t    (long)high_rssithresh_for_ra)\n\t\t\tp_ra->ratr_state = DM_RATR_STA_HIGH;\n\t\telse if (rtlpriv->dm.undec_sm_pwdb >\n\t\t\t (long)low_rssithresh_for_ra)\n\t\t\tp_ra->ratr_state = DM_RATR_STA_MIDDLE;\n\t\telse\n\t\t\tp_ra->ratr_state = DM_RATR_STA_LOW;\n\n\t\tif (p_ra->pre_ratr_state != p_ra->ratr_state) {\n\t\t\trtl_dbg(rtlpriv, COMP_RATE, DBG_LOUD,\n\t\t\t\t\"RSSI = %ld\\n\",\n\t\t\t\trtlpriv->dm.undec_sm_pwdb);\n\t\t\trtl_dbg(rtlpriv, COMP_RATE, DBG_LOUD,\n\t\t\t\t\"RSSI_LEVEL = %d\\n\", p_ra->ratr_state);\n\t\t\trtl_dbg(rtlpriv, COMP_RATE, DBG_LOUD,\n\t\t\t\t\"PreState = %d, CurState = %d\\n\",\n\t\t\t\tp_ra->pre_ratr_state, p_ra->ratr_state);\n\n\t\t\trcu_read_lock();\n\t\t\tsta = rtl_find_sta(hw, mac->bssid);\n\t\t\tif (sta)\n\t\t\t\trtlpriv->cfg->ops->update_rate_tbl(hw, sta,\n\t\t\t\t\t\t\tp_ra->ratr_state,\n\t\t\t\t\t\t\t\t   true);\n\t\t\trcu_read_unlock();\n\n\t\t\tp_ra->pre_ratr_state = p_ra->ratr_state;\n\t\t}\n\t}\n}\n\nstatic void rtl92c_dm_init_dynamic_bb_powersaving(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct ps_t *dm_pstable = &rtlpriv->dm_pstable;\n\n\tdm_pstable->pre_ccastate = CCA_MAX;\n\tdm_pstable->cur_ccasate = CCA_MAX;\n\tdm_pstable->pre_rfstate = RF_MAX;\n\tdm_pstable->cur_rfstate = RF_MAX;\n\tdm_pstable->rssi_val_min = 0;\n}\n\nstatic void rtl88e_dm_update_rx_idle_ant(struct ieee80211_hw *hw,\n\t\t\t\t\t u8 ant)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tstruct rtl_dm *rtldm = rtl_dm(rtl_priv(hw));\n\tstruct fast_ant_training *pfat_table = &rtldm->fat_table;\n\tu32 default_ant, optional_ant;\n\n\tif (pfat_table->rx_idle_ant != ant) {\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\t\"need to update rx idle ant\\n\");\n\t\tif (ant == MAIN_ANT) {\n\t\t\tdefault_ant =\n\t\t\t  (pfat_table->rx_idle_ant == CG_TRX_HW_ANTDIV) ?\n\t\t\t  MAIN_ANT_CG_TRX : MAIN_ANT_CGCS_RX;\n\t\t\toptional_ant =\n\t\t\t  (pfat_table->rx_idle_ant == CG_TRX_HW_ANTDIV) ?\n\t\t\t  AUX_ANT_CG_TRX : AUX_ANT_CGCS_RX;\n\t\t} else {\n\t\t\tdefault_ant =\n\t\t\t   (pfat_table->rx_idle_ant == CG_TRX_HW_ANTDIV) ?\n\t\t\t   AUX_ANT_CG_TRX : AUX_ANT_CGCS_RX;\n\t\t\toptional_ant =\n\t\t\t   (pfat_table->rx_idle_ant == CG_TRX_HW_ANTDIV) ?\n\t\t\t   MAIN_ANT_CG_TRX : MAIN_ANT_CGCS_RX;\n\t\t}\n\n\t\tif (rtlefuse->antenna_div_type == CG_TRX_HW_ANTDIV) {\n\t\t\trtl_set_bbreg(hw, DM_REG_RX_ANT_CTRL_11N,\n\t\t\t\t      BIT(5) | BIT(4) | BIT(3), default_ant);\n\t\t\trtl_set_bbreg(hw, DM_REG_RX_ANT_CTRL_11N,\n\t\t\t\t      BIT(8) | BIT(7) | BIT(6), optional_ant);\n\t\t\trtl_set_bbreg(hw, DM_REG_ANTSEL_CTRL_11N,\n\t\t\t\t      BIT(14) | BIT(13) | BIT(12),\n\t\t\t\t      default_ant);\n\t\t\trtl_set_bbreg(hw, DM_REG_RESP_TX_11N,\n\t\t\t\t      BIT(6) | BIT(7), default_ant);\n\t\t} else if (rtlefuse->antenna_div_type == CGCS_RX_HW_ANTDIV) {\n\t\t\trtl_set_bbreg(hw, DM_REG_RX_ANT_CTRL_11N,\n\t\t\t\t      BIT(5) | BIT(4) | BIT(3), default_ant);\n\t\t\trtl_set_bbreg(hw, DM_REG_RX_ANT_CTRL_11N,\n\t\t\t\t      BIT(8) | BIT(7) | BIT(6), optional_ant);\n\t\t}\n\t}\n\tpfat_table->rx_idle_ant = ant;\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD, \"RxIdleAnt %s\\n\",\n\t\t(ant == MAIN_ANT) ? (\"MAIN_ANT\") : (\"AUX_ANT\"));\n}\n\nstatic void rtl88e_dm_update_tx_ant(struct ieee80211_hw *hw,\n\t\t\t\t    u8 ant, u32 mac_id)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_dm *rtldm = rtl_dm(rtl_priv(hw));\n\tstruct fast_ant_training *pfat_table = &rtldm->fat_table;\n\tu8 target_ant;\n\n\tif (ant == MAIN_ANT)\n\t\ttarget_ant = MAIN_ANT_CG_TRX;\n\telse\n\t\ttarget_ant = AUX_ANT_CG_TRX;\n\n\tpfat_table->antsel_a[mac_id] = target_ant & BIT(0);\n\tpfat_table->antsel_b[mac_id] = (target_ant & BIT(1)) >> 1;\n\tpfat_table->antsel_c[mac_id] = (target_ant & BIT(2)) >> 2;\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD, \"txfrominfo target ant %s\\n\",\n\t\t(ant == MAIN_ANT) ? (\"MAIN_ANT\") : (\"AUX_ANT\"));\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD, \"antsel_tr_mux = 3'b%d%d%d\\n\",\n\t\tpfat_table->antsel_c[mac_id],\n\t\tpfat_table->antsel_b[mac_id],\n\t\tpfat_table->antsel_a[mac_id]);\n}\n\nstatic void rtl88e_dm_rx_hw_antena_div_init(struct ieee80211_hw *hw)\n{\n\tu32  value32;\n\n\t \n\tvalue32 = rtl_get_bbreg(hw, DM_REG_ANTSEL_PIN_11N, MASKDWORD);\n\trtl_set_bbreg(hw, DM_REG_ANTSEL_PIN_11N,\n\t\t      MASKDWORD, value32 | (BIT(23) | BIT(25)));\n\t \n\trtl_set_bbreg(hw, DM_REG_PIN_CTRL_11N, BIT(9) | BIT(8), 0);\n\trtl_set_bbreg(hw, DM_REG_RX_ANT_CTRL_11N, BIT(10), 0);\n\trtl_set_bbreg(hw, DM_REG_LNA_SWITCH_11N, BIT(22), 1);\n\trtl_set_bbreg(hw, DM_REG_LNA_SWITCH_11N, BIT(31), 1);\n\t \n\trtl_set_bbreg(hw, DM_REG_ANTDIV_PARA1_11N, MASKDWORD, 0x000000a0);\n\t \n\trtl_set_bbreg(hw, DM_REG_BB_PWR_SAV4_11N, BIT(7), 1);\n\trtl_set_bbreg(hw, DM_REG_CCK_ANTDIV_PARA2_11N, BIT(4), 1);\n\trtl88e_dm_update_rx_idle_ant(hw, MAIN_ANT);\n\trtl_set_bbreg(hw, DM_REG_ANT_MAPPING1_11N, MASKLWORD, 0x0201);\n}\n\nstatic void rtl88e_dm_trx_hw_antenna_div_init(struct ieee80211_hw *hw)\n{\n\tu32  value32;\n\n\t \n\tvalue32 = rtl_get_bbreg(hw, DM_REG_ANTSEL_PIN_11N, MASKDWORD);\n\trtl_set_bbreg(hw, DM_REG_ANTSEL_PIN_11N, MASKDWORD,\n\t\t      value32 | (BIT(23) | BIT(25)));\n\t \n\trtl_set_bbreg(hw, DM_REG_PIN_CTRL_11N, BIT(9) | BIT(8), 0);\n\trtl_set_bbreg(hw, DM_REG_RX_ANT_CTRL_11N, BIT(10), 0);\n\trtl_set_bbreg(hw, DM_REG_LNA_SWITCH_11N, BIT(22), 0);\n\trtl_set_bbreg(hw, DM_REG_LNA_SWITCH_11N, BIT(31), 1);\n\t \n\trtl_set_bbreg(hw, DM_REG_ANTDIV_PARA1_11N, MASKDWORD, 0x000000a0);\n\t \n\trtl_set_bbreg(hw, DM_REG_BB_PWR_SAV4_11N, BIT(7), 1);\n\trtl_set_bbreg(hw, DM_REG_CCK_ANTDIV_PARA2_11N, BIT(4), 1);\n\t \n\trtl_set_bbreg(hw, DM_REG_TX_ANT_CTRL_11N, BIT(21), 0);\n\trtl88e_dm_update_rx_idle_ant(hw, MAIN_ANT);\n\trtl_set_bbreg(hw, DM_REG_ANT_MAPPING1_11N, MASKLWORD, 0x0201);\n}\n\nstatic void rtl88e_dm_fast_training_init(struct ieee80211_hw *hw)\n{\n\tstruct rtl_dm *rtldm = rtl_dm(rtl_priv(hw));\n\tstruct fast_ant_training *pfat_table = &rtldm->fat_table;\n\tu32 ant_combination = 2;\n\tu32 value32, i;\n\n\tfor (i = 0; i < 6; i++) {\n\t\tpfat_table->bssid[i] = 0;\n\t\tpfat_table->ant_sum[i] = 0;\n\t\tpfat_table->ant_cnt[i] = 0;\n\t\tpfat_table->ant_ave[i] = 0;\n\t}\n\tpfat_table->train_idx = 0;\n\tpfat_table->fat_state = FAT_NORMAL_STATE;\n\n\t \n\tvalue32 = rtl_get_bbreg(hw, DM_REG_ANTSEL_PIN_11N, MASKDWORD);\n\trtl_set_bbreg(hw, DM_REG_ANTSEL_PIN_11N,\n\t\t      MASKDWORD, value32 | (BIT(23) | BIT(25)));\n\tvalue32 = rtl_get_bbreg(hw, DM_REG_ANT_TRAIN_PARA2_11N, MASKDWORD);\n\trtl_set_bbreg(hw, DM_REG_ANT_TRAIN_PARA2_11N,\n\t\t      MASKDWORD, value32 | (BIT(16) | BIT(17)));\n\trtl_set_bbreg(hw, DM_REG_ANT_TRAIN_PARA2_11N,\n\t\t      MASKLWORD, 0);\n\trtl_set_bbreg(hw, DM_REG_ANT_TRAIN_PARA1_11N,\n\t\t      MASKDWORD, 0);\n\n\t \n\trtl_set_bbreg(hw, DM_REG_PIN_CTRL_11N, BIT(9) | BIT(8), 0);\n\trtl_set_bbreg(hw, DM_REG_RX_ANT_CTRL_11N, BIT(10), 0);\n\trtl_set_bbreg(hw, DM_REG_LNA_SWITCH_11N, BIT(22), 0);\n\trtl_set_bbreg(hw, DM_REG_LNA_SWITCH_11N, BIT(31), 1);\n\n\t \n\trtl_set_bbreg(hw, DM_REG_ANTDIV_PARA1_11N, MASKDWORD, 0x000000a0);\n\t \n\trtl_set_bbreg(hw, DM_REG_ANT_MAPPING1_11N, MASKBYTE0, 1);\n\trtl_set_bbreg(hw, DM_REG_ANT_MAPPING1_11N, MASKBYTE1, 2);\n\n\t \n\trtl_set_bbreg(hw, DM_REG_TX_ANT_CTRL_11N, BIT(21), 1);\n\trtl_set_bbreg(hw, DM_REG_RX_ANT_CTRL_11N,\n\t\t      BIT(5) | BIT(4) | BIT(3), 0);\n\trtl_set_bbreg(hw, DM_REG_RX_ANT_CTRL_11N,\n\t\t      BIT(8) | BIT(7) | BIT(6), 1);\n\trtl_set_bbreg(hw, DM_REG_RX_ANT_CTRL_11N,\n\t\t      BIT(2) | BIT(1) | BIT(0), (ant_combination - 1));\n\n\trtl_set_bbreg(hw, DM_REG_IGI_A_11N, BIT(7), 1);\n}\n\nstatic void rtl88e_dm_antenna_div_init(struct ieee80211_hw *hw)\n{\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\n\tif (rtlefuse->antenna_div_type == CGCS_RX_HW_ANTDIV)\n\t\trtl88e_dm_rx_hw_antena_div_init(hw);\n\telse if (rtlefuse->antenna_div_type == CG_TRX_HW_ANTDIV)\n\t\trtl88e_dm_trx_hw_antenna_div_init(hw);\n\telse if (rtlefuse->antenna_div_type == CG_TRX_SMART_ANTDIV)\n\t\trtl88e_dm_fast_training_init(hw);\n\n}\n\nvoid rtl88e_dm_set_tx_ant_by_tx_info(struct ieee80211_hw *hw,\n\t\t\t\t     u8 *pdesc, u32 mac_id)\n{\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tstruct rtl_dm *rtldm = rtl_dm(rtl_priv(hw));\n\tstruct fast_ant_training *pfat_table = &rtldm->fat_table;\n\t__le32 *pdesc32 = (__le32 *)pdesc;\n\n\tif ((rtlefuse->antenna_div_type == CG_TRX_HW_ANTDIV) ||\n\t    (rtlefuse->antenna_div_type == CG_TRX_SMART_ANTDIV)) {\n\t\tset_tx_desc_antsel_a(pdesc32, pfat_table->antsel_a[mac_id]);\n\t\tset_tx_desc_antsel_b(pdesc32, pfat_table->antsel_b[mac_id]);\n\t\tset_tx_desc_antsel_c(pdesc32, pfat_table->antsel_c[mac_id]);\n\t}\n}\n\nvoid rtl88e_dm_ant_sel_statistics(struct ieee80211_hw *hw,\n\t\t\t\t  u8 antsel_tr_mux, u32 mac_id,\n\t\t\t\t  u32 rx_pwdb_all)\n{\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tstruct rtl_dm *rtldm = rtl_dm(rtl_priv(hw));\n\tstruct fast_ant_training *pfat_table = &rtldm->fat_table;\n\n\tif (rtlefuse->antenna_div_type == CG_TRX_HW_ANTDIV) {\n\t\tif (antsel_tr_mux == MAIN_ANT_CG_TRX) {\n\t\t\tpfat_table->main_ant_sum[mac_id] += rx_pwdb_all;\n\t\t\tpfat_table->main_ant_cnt[mac_id]++;\n\t\t} else {\n\t\t\tpfat_table->aux_ant_sum[mac_id] += rx_pwdb_all;\n\t\t\tpfat_table->aux_ant_cnt[mac_id]++;\n\t\t}\n\t} else if (rtlefuse->antenna_div_type == CGCS_RX_HW_ANTDIV) {\n\t\tif (antsel_tr_mux == MAIN_ANT_CGCS_RX) {\n\t\t\tpfat_table->main_ant_sum[mac_id] += rx_pwdb_all;\n\t\t\tpfat_table->main_ant_cnt[mac_id]++;\n\t\t} else {\n\t\t\tpfat_table->aux_ant_sum[mac_id] += rx_pwdb_all;\n\t\t\tpfat_table->aux_ant_cnt[mac_id]++;\n\t\t}\n\t}\n}\n\nstatic void rtl88e_dm_hw_ant_div(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tstruct rtl_dm *rtldm = rtl_dm(rtl_priv(hw));\n\tstruct rtl_sta_info *drv_priv;\n\tstruct fast_ant_training *pfat_table = &rtldm->fat_table;\n\tstruct dig_t *dm_dig = &rtlpriv->dm_digtable;\n\tu32 i, min_rssi = 0xff, ant_div_max_rssi = 0;\n\tu32 max_rssi = 0, local_min_rssi, local_max_rssi;\n\tu32 main_rssi, aux_rssi;\n\tu8 rx_idle_ant = 0, target_ant = 7;\n\n\t \n\ti = 0;\n\tmain_rssi = (pfat_table->main_ant_cnt[i] != 0) ?\n\t\t(pfat_table->main_ant_sum[i] / pfat_table->main_ant_cnt[i]) : 0;\n\taux_rssi = (pfat_table->aux_ant_cnt[i] != 0) ?\n\t\t(pfat_table->aux_ant_sum[i] / pfat_table->aux_ant_cnt[i]) : 0;\n\ttarget_ant = (main_rssi == aux_rssi) ?\n\t\tpfat_table->rx_idle_ant : ((main_rssi >= aux_rssi) ?\n\t\tMAIN_ANT : AUX_ANT);\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\"main_ant_sum %d main_ant_cnt %d\\n\",\n\t\tpfat_table->main_ant_sum[i],\n\t\tpfat_table->main_ant_cnt[i]);\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD,\n\t\t\"aux_ant_sum %d aux_ant_cnt %d\\n\",\n\t\tpfat_table->aux_ant_sum[i], pfat_table->aux_ant_cnt[i]);\n\trtl_dbg(rtlpriv, COMP_INIT, DBG_LOUD, \"main_rssi %d aux_rssi%d\\n\",\n\t\tmain_rssi, aux_rssi);\n\tlocal_max_rssi = (main_rssi > aux_rssi) ? main_rssi : aux_rssi;\n\tif ((local_max_rssi > ant_div_max_rssi) && (local_max_rssi < 40))\n\t\tant_div_max_rssi = local_max_rssi;\n\tif (local_max_rssi > max_rssi)\n\t\tmax_rssi = local_max_rssi;\n\n\tif ((pfat_table->rx_idle_ant == MAIN_ANT) && (main_rssi == 0))\n\t\tmain_rssi = aux_rssi;\n\telse if ((pfat_table->rx_idle_ant == AUX_ANT) && (aux_rssi == 0))\n\t\taux_rssi = main_rssi;\n\n\tlocal_min_rssi = (main_rssi > aux_rssi) ? aux_rssi : main_rssi;\n\tif (local_min_rssi < min_rssi) {\n\t\tmin_rssi = local_min_rssi;\n\t\trx_idle_ant = target_ant;\n\t}\n\tif (rtlefuse->antenna_div_type == CG_TRX_HW_ANTDIV)\n\t\trtl88e_dm_update_tx_ant(hw, target_ant, i);\n\n\tif (rtlpriv->mac80211.opmode == NL80211_IFTYPE_AP ||\n\t    rtlpriv->mac80211.opmode == NL80211_IFTYPE_ADHOC) {\n\t\tspin_lock_bh(&rtlpriv->locks.entry_list_lock);\n\t\tlist_for_each_entry(drv_priv, &rtlpriv->entry_list, list) {\n\t\t\ti++;\n\t\t\tmain_rssi = (pfat_table->main_ant_cnt[i] != 0) ?\n\t\t\t\t(pfat_table->main_ant_sum[i] /\n\t\t\t\tpfat_table->main_ant_cnt[i]) : 0;\n\t\t\taux_rssi = (pfat_table->aux_ant_cnt[i] != 0) ?\n\t\t\t\t(pfat_table->aux_ant_sum[i] /\n\t\t\t\tpfat_table->aux_ant_cnt[i]) : 0;\n\t\t\ttarget_ant = (main_rssi == aux_rssi) ?\n\t\t\t\tpfat_table->rx_idle_ant : ((main_rssi >=\n\t\t\t\taux_rssi) ? MAIN_ANT : AUX_ANT);\n\n\t\t\tlocal_max_rssi = (main_rssi > aux_rssi) ?\n\t\t\t\t\t main_rssi : aux_rssi;\n\t\t\tif ((local_max_rssi > ant_div_max_rssi) &&\n\t\t\t    (local_max_rssi < 40))\n\t\t\t\tant_div_max_rssi = local_max_rssi;\n\t\t\tif (local_max_rssi > max_rssi)\n\t\t\t\tmax_rssi = local_max_rssi;\n\n\t\t\tif ((pfat_table->rx_idle_ant == MAIN_ANT) &&\n\t\t\t    (main_rssi == 0))\n\t\t\t\tmain_rssi = aux_rssi;\n\t\t\telse if ((pfat_table->rx_idle_ant == AUX_ANT) &&\n\t\t\t\t (aux_rssi == 0))\n\t\t\t\taux_rssi = main_rssi;\n\n\t\t\tlocal_min_rssi = (main_rssi > aux_rssi) ?\n\t\t\t\taux_rssi : main_rssi;\n\t\t\tif (local_min_rssi < min_rssi) {\n\t\t\t\tmin_rssi = local_min_rssi;\n\t\t\t\trx_idle_ant = target_ant;\n\t\t\t}\n\t\t\tif (rtlefuse->antenna_div_type == CG_TRX_HW_ANTDIV)\n\t\t\t\trtl88e_dm_update_tx_ant(hw, target_ant, i);\n\t\t}\n\t\tspin_unlock_bh(&rtlpriv->locks.entry_list_lock);\n\t}\n\n\tfor (i = 0; i < ASSOCIATE_ENTRY_NUM; i++) {\n\t\tpfat_table->main_ant_sum[i] = 0;\n\t\tpfat_table->aux_ant_sum[i] = 0;\n\t\tpfat_table->main_ant_cnt[i] = 0;\n\t\tpfat_table->aux_ant_cnt[i] = 0;\n\t}\n\n\trtl88e_dm_update_rx_idle_ant(hw, rx_idle_ant);\n\n\tdm_dig->antdiv_rssi_max = ant_div_max_rssi;\n\tdm_dig->rssi_max = max_rssi;\n}\n\nstatic void rtl88e_set_next_mac_address_target(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_dm *rtldm = rtl_dm(rtl_priv(hw));\n\tstruct rtl_sta_info *drv_priv;\n\tstruct fast_ant_training *pfat_table = &rtldm->fat_table;\n\tu32 value32, i, j = 0;\n\n\tif (mac->link_state >= MAC80211_LINKED) {\n\t\tfor (i = 0; i < ASSOCIATE_ENTRY_NUM; i++) {\n\t\t\tif ((pfat_table->train_idx + 1) == ASSOCIATE_ENTRY_NUM)\n\t\t\t\tpfat_table->train_idx = 0;\n\t\t\telse\n\t\t\t\tpfat_table->train_idx++;\n\n\t\t\tif (pfat_table->train_idx == 0) {\n\t\t\t\tvalue32 = (mac->mac_addr[5] << 8) |\n\t\t\t\t\t  mac->mac_addr[4];\n\t\t\t\trtl_set_bbreg(hw, DM_REG_ANT_TRAIN_PARA2_11N,\n\t\t\t\t\t      MASKLWORD, value32);\n\n\t\t\t\tvalue32 = (mac->mac_addr[3] << 24) |\n\t\t\t\t\t  (mac->mac_addr[2] << 16) |\n\t\t\t\t\t  (mac->mac_addr[1] << 8) |\n\t\t\t\t\t  mac->mac_addr[0];\n\t\t\t\trtl_set_bbreg(hw, DM_REG_ANT_TRAIN_PARA1_11N,\n\t\t\t\t\t      MASKDWORD, value32);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (rtlpriv->mac80211.opmode !=\n\t\t\t    NL80211_IFTYPE_STATION) {\n\t\t\t\tspin_lock_bh(&rtlpriv->locks.entry_list_lock);\n\t\t\t\tlist_for_each_entry(drv_priv,\n\t\t\t\t\t\t    &rtlpriv->entry_list, list) {\n\t\t\t\t\tj++;\n\t\t\t\t\tif (j != pfat_table->train_idx)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tvalue32 = (drv_priv->mac_addr[5] << 8) |\n\t\t\t\t\t\t  drv_priv->mac_addr[4];\n\t\t\t\t\trtl_set_bbreg(hw,\n\t\t\t\t\t\t      DM_REG_ANT_TRAIN_PARA2_11N,\n\t\t\t\t\t\t      MASKLWORD, value32);\n\n\t\t\t\t\tvalue32 = (drv_priv->mac_addr[3] << 24) |\n\t\t\t\t\t\t  (drv_priv->mac_addr[2] << 16) |\n\t\t\t\t\t\t  (drv_priv->mac_addr[1] << 8) |\n\t\t\t\t\t\t  drv_priv->mac_addr[0];\n\t\t\t\t\trtl_set_bbreg(hw,\n\t\t\t\t\t\t      DM_REG_ANT_TRAIN_PARA1_11N,\n\t\t\t\t\t\t      MASKDWORD, value32);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tspin_unlock_bh(&rtlpriv->locks.entry_list_lock);\n\t\t\t\t \n\t\t\t\tif (j == pfat_table->train_idx)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void rtl88e_dm_fast_ant_training(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_dm *rtldm = rtl_dm(rtl_priv(hw));\n\tstruct fast_ant_training *pfat_table = &rtldm->fat_table;\n\tu32 i, max_rssi = 0;\n\tu8 target_ant = 2;\n\tbool bpkt_filter_match = false;\n\n\tif (pfat_table->fat_state == FAT_TRAINING_STATE) {\n\t\tfor (i = 0; i < 7; i++) {\n\t\t\tif (pfat_table->ant_cnt[i] == 0) {\n\t\t\t\tpfat_table->ant_ave[i] = 0;\n\t\t\t} else {\n\t\t\t\tpfat_table->ant_ave[i] =\n\t\t\t\t\tpfat_table->ant_sum[i] /\n\t\t\t\t\tpfat_table->ant_cnt[i];\n\t\t\t\tbpkt_filter_match = true;\n\t\t\t}\n\n\t\t\tif (pfat_table->ant_ave[i] > max_rssi) {\n\t\t\t\tmax_rssi = pfat_table->ant_ave[i];\n\t\t\t\ttarget_ant = (u8) i;\n\t\t\t}\n\t\t}\n\n\t\tif (!bpkt_filter_match) {\n\t\t\trtl_set_bbreg(hw, DM_REG_TXAGC_A_1_MCS32_11N,\n\t\t\t\t      BIT(16), 0);\n\t\t\trtl_set_bbreg(hw, DM_REG_IGI_A_11N, BIT(7), 0);\n\t\t} else {\n\t\t\trtl_set_bbreg(hw, DM_REG_TXAGC_A_1_MCS32_11N,\n\t\t\t\t      BIT(16), 0);\n\t\t\trtl_set_bbreg(hw, DM_REG_RX_ANT_CTRL_11N, BIT(8) |\n\t\t\t\t      BIT(7) | BIT(6), target_ant);\n\t\t\trtl_set_bbreg(hw, DM_REG_TX_ANT_CTRL_11N,\n\t\t\t\t      BIT(21), 1);\n\n\t\t\tpfat_table->antsel_a[pfat_table->train_idx] =\n\t\t\t\ttarget_ant & BIT(0);\n\t\t\tpfat_table->antsel_b[pfat_table->train_idx] =\n\t\t\t\t(target_ant & BIT(1)) >> 1;\n\t\t\tpfat_table->antsel_c[pfat_table->train_idx] =\n\t\t\t\t(target_ant & BIT(2)) >> 2;\n\n\t\t\tif (target_ant == 0)\n\t\t\t\trtl_set_bbreg(hw, DM_REG_IGI_A_11N, BIT(7), 0);\n\t\t}\n\n\t\tfor (i = 0; i < 7; i++) {\n\t\t\tpfat_table->ant_sum[i] = 0;\n\t\t\tpfat_table->ant_cnt[i] = 0;\n\t\t}\n\n\t\tpfat_table->fat_state = FAT_NORMAL_STATE;\n\t\treturn;\n\t}\n\n\tif (pfat_table->fat_state == FAT_NORMAL_STATE) {\n\t\trtl88e_set_next_mac_address_target(hw);\n\n\t\tpfat_table->fat_state = FAT_TRAINING_STATE;\n\t\trtl_set_bbreg(hw, DM_REG_TXAGC_A_1_MCS32_11N, BIT(16), 1);\n\t\trtl_set_bbreg(hw, DM_REG_IGI_A_11N, BIT(7), 1);\n\n\t\tmod_timer(&rtlpriv->works.fast_antenna_training_timer,\n\t\t\t  jiffies + MSECS(RTL_WATCH_DOG_TIME));\n\t}\n}\n\nvoid rtl88e_dm_fast_antenna_training_callback(struct timer_list *t)\n{\n\tstruct rtl_priv *rtlpriv =\n\t\tfrom_timer(rtlpriv, t, works.fast_antenna_training_timer);\n\tstruct ieee80211_hw *hw = rtlpriv->hw;\n\n\trtl88e_dm_fast_ant_training(hw);\n}\n\nstatic void rtl88e_dm_antenna_diversity(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tstruct rtl_dm *rtldm = rtl_dm(rtl_priv(hw));\n\tstruct fast_ant_training *pfat_table = &rtldm->fat_table;\n\n\tif (mac->link_state < MAC80211_LINKED) {\n\t\trtl_dbg(rtlpriv, COMP_DIG, DBG_LOUD, \"No Link\\n\");\n\t\tif (pfat_table->becomelinked) {\n\t\t\trtl_dbg(rtlpriv, COMP_DIG, DBG_LOUD,\n\t\t\t\t\"need to turn off HW AntDiv\\n\");\n\t\t\trtl_set_bbreg(hw, DM_REG_IGI_A_11N, BIT(7), 0);\n\t\t\trtl_set_bbreg(hw, DM_REG_CCK_ANTDIV_PARA1_11N,\n\t\t\t\t      BIT(15), 0);\n\t\t\tif (rtlefuse->antenna_div_type == CG_TRX_HW_ANTDIV)\n\t\t\t\trtl_set_bbreg(hw, DM_REG_TX_ANT_CTRL_11N,\n\t\t\t\t\t      BIT(21), 0);\n\t\t\tpfat_table->becomelinked =\n\t\t\t\t(mac->link_state == MAC80211_LINKED) ?\n\t\t\t\ttrue : false;\n\t\t}\n\t\treturn;\n\t} else {\n\t\tif (!pfat_table->becomelinked) {\n\t\t\trtl_dbg(rtlpriv, COMP_DIG, DBG_LOUD,\n\t\t\t\t\"Need to turn on HW AntDiv\\n\");\n\t\t\trtl_set_bbreg(hw, DM_REG_IGI_A_11N, BIT(7), 1);\n\t\t\trtl_set_bbreg(hw, DM_REG_CCK_ANTDIV_PARA1_11N,\n\t\t\t\t      BIT(15), 1);\n\t\t\tif (rtlefuse->antenna_div_type == CG_TRX_HW_ANTDIV)\n\t\t\t\trtl_set_bbreg(hw, DM_REG_TX_ANT_CTRL_11N,\n\t\t\t\t\t      BIT(21), 1);\n\t\t\tpfat_table->becomelinked =\n\t\t\t\t(mac->link_state >= MAC80211_LINKED) ?\n\t\t\t\ttrue : false;\n\t\t}\n\t}\n\n\tif ((rtlefuse->antenna_div_type == CG_TRX_HW_ANTDIV) ||\n\t    (rtlefuse->antenna_div_type == CGCS_RX_HW_ANTDIV))\n\t\trtl88e_dm_hw_ant_div(hw);\n\telse if (rtlefuse->antenna_div_type == CG_TRX_SMART_ANTDIV)\n\t\trtl88e_dm_fast_ant_training(hw);\n}\n\nvoid rtl88e_dm_init(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu32 cur_igvalue = rtl_get_bbreg(hw, ROFDM0_XAAGCCORE1, 0x7f);\n\n\trtlpriv->dm.dm_type = DM_TYPE_BYDRIVER;\n\trtl_dm_diginit(hw, cur_igvalue);\n\trtl88e_dm_init_dynamic_txpower(hw);\n\trtl88e_dm_init_edca_turbo(hw);\n\trtl88e_dm_init_rate_adaptive_mask(hw);\n\trtl88e_dm_init_txpower_tracking(hw);\n\trtl92c_dm_init_dynamic_bb_powersaving(hw);\n\trtl88e_dm_antenna_div_init(hw);\n}\n\nvoid rtl88e_dm_watchdog(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tbool fw_current_inpsmode = false;\n\tbool fw_ps_awake = true;\n\n\trtlpriv->cfg->ops->get_hw_reg(hw, HW_VAR_FW_PSMODE_STATUS,\n\t\t\t\t      (u8 *)(&fw_current_inpsmode));\n\trtlpriv->cfg->ops->get_hw_reg(hw, HW_VAR_FWLPS_RF_ON,\n\t\t\t\t      (u8 *)(&fw_ps_awake));\n\tif (ppsc->p2p_ps_info.p2p_ps_mode)\n\t\tfw_ps_awake = false;\n\n\tspin_lock(&rtlpriv->locks.rf_ps_lock);\n\tif ((ppsc->rfpwr_state == ERFON) &&\n\t    ((!fw_current_inpsmode) && fw_ps_awake) &&\n\t    (!ppsc->rfchange_inprogress)) {\n\t\trtl88e_dm_pwdb_monitor(hw);\n\t\trtl88e_dm_dig(hw);\n\t\trtl88e_dm_false_alarm_counter_statistics(hw);\n\t\trtl92c_dm_dynamic_txpower(hw);\n\t\trtl88e_dm_check_txpower_tracking(hw);\n\t\trtl88e_dm_refresh_rate_adaptive_mask(hw);\n\t\trtl88e_dm_check_edca_turbo(hw);\n\t\trtl88e_dm_antenna_diversity(hw);\n\t}\n\tspin_unlock(&rtlpriv->locks.rf_ps_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}