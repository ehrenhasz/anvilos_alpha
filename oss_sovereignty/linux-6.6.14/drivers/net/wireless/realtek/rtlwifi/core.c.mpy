{
  "module_name": "core.c",
  "hash_id": "a236b6dbf6f75f4d17451e180f7446a5fc01172f3e6a41f28dc7b18a21f19be5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtlwifi/core.c",
  "human_readable_source": "\n \n\n#include \"wifi.h\"\n#include \"core.h\"\n#include \"cam.h\"\n#include \"base.h\"\n#include \"ps.h\"\n#include \"pwrseqcmd.h\"\n\n#include \"btcoexist/rtl_btc.h\"\n#include <linux/firmware.h>\n#include <linux/export.h>\n#include <net/cfg80211.h>\n\nu8 channel5g[CHANNEL_MAX_NUMBER_5G] = {\n\t36, 38, 40, 42, 44, 46, 48,\t\t \n\t52, 54, 56, 58, 60, 62, 64,\t\t \n\t100, 102, 104, 106, 108, 110, 112,\t \n\t116, 118, 120, 122, 124, 126, 128,\t \n\t132, 134, 136, 138, 140, 142, 144,\t \n\t149, 151, 153, 155, 157, 159, 161,\t \n\t165, 167, 169, 171, 173, 175, 177\t \n};\nEXPORT_SYMBOL(channel5g);\n\nu8 channel5g_80m[CHANNEL_MAX_NUMBER_5G_80M] = {\n\t42, 58, 106, 122, 138, 155, 171\n};\nEXPORT_SYMBOL(channel5g_80m);\n\nvoid rtl_addr_delay(u32 addr)\n{\n\tif (addr == 0xfe)\n\t\tmdelay(50);\n\telse if (addr == 0xfd)\n\t\tmsleep(5);\n\telse if (addr == 0xfc)\n\t\tmsleep(1);\n\telse if (addr == 0xfb)\n\t\tusleep_range(50, 100);\n\telse if (addr == 0xfa)\n\t\tusleep_range(5, 10);\n\telse if (addr == 0xf9)\n\t\tusleep_range(1, 2);\n}\nEXPORT_SYMBOL(rtl_addr_delay);\n\nvoid rtl_rfreg_delay(struct ieee80211_hw *hw, enum radio_path rfpath, u32 addr,\n\t\t     u32 mask, u32 data)\n{\n\tif (addr >= 0xf9 && addr <= 0xfe) {\n\t\trtl_addr_delay(addr);\n\t} else {\n\t\trtl_set_rfreg(hw, rfpath, addr, mask, data);\n\t\tudelay(1);\n\t}\n}\nEXPORT_SYMBOL(rtl_rfreg_delay);\n\nvoid rtl_bb_delay(struct ieee80211_hw *hw, u32 addr, u32 data)\n{\n\tif (addr >= 0xf9 && addr <= 0xfe) {\n\t\trtl_addr_delay(addr);\n\t} else {\n\t\trtl_set_bbreg(hw, addr, MASKDWORD, data);\n\t\tudelay(1);\n\t}\n}\nEXPORT_SYMBOL(rtl_bb_delay);\n\nstatic void rtl_fw_do_work(const struct firmware *firmware, void *context,\n\t\t\t   bool is_wow)\n{\n\tstruct ieee80211_hw *hw = context;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tint err;\n\n\trtl_dbg(rtlpriv, COMP_ERR, DBG_LOUD,\n\t\t\"Firmware callback routine entered!\\n\");\n\tif (!firmware) {\n\t\tif (rtlpriv->cfg->alt_fw_name) {\n\t\t\terr = request_firmware(&firmware,\n\t\t\t\t\t       rtlpriv->cfg->alt_fw_name,\n\t\t\t\t\t       rtlpriv->io.dev);\n\t\t\tpr_info(\"Loading alternative firmware %s\\n\",\n\t\t\t\trtlpriv->cfg->alt_fw_name);\n\t\t\tif (!err)\n\t\t\t\tgoto found_alt;\n\t\t}\n\t\tpr_err(\"Selected firmware is not available\\n\");\n\t\trtlpriv->max_fw_size = 0;\n\t\tgoto exit;\n\t}\nfound_alt:\n\tif (firmware->size > rtlpriv->max_fw_size) {\n\t\tpr_err(\"Firmware is too big!\\n\");\n\t\trelease_firmware(firmware);\n\t\tgoto exit;\n\t}\n\tif (!is_wow) {\n\t\tmemcpy(rtlpriv->rtlhal.pfirmware, firmware->data,\n\t\t       firmware->size);\n\t\trtlpriv->rtlhal.fwsize = firmware->size;\n\t} else {\n\t\tmemcpy(rtlpriv->rtlhal.wowlan_firmware, firmware->data,\n\t\t       firmware->size);\n\t\trtlpriv->rtlhal.wowlan_fwsize = firmware->size;\n\t}\n\trelease_firmware(firmware);\n\nexit:\n\tcomplete(&rtlpriv->firmware_loading_complete);\n}\n\nvoid rtl_fw_cb(const struct firmware *firmware, void *context)\n{\n\trtl_fw_do_work(firmware, context, false);\n}\nEXPORT_SYMBOL(rtl_fw_cb);\n\nvoid rtl_wowlan_fw_cb(const struct firmware *firmware, void *context)\n{\n\trtl_fw_do_work(firmware, context, true);\n}\nEXPORT_SYMBOL(rtl_wowlan_fw_cb);\n\n \nstatic int rtl_op_start(struct ieee80211_hw *hw)\n{\n\tint err = 0;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\n\tif (!is_hal_stop(rtlhal))\n\t\treturn 0;\n\tif (!test_bit(RTL_STATUS_INTERFACE_START, &rtlpriv->status))\n\t\treturn 0;\n\tmutex_lock(&rtlpriv->locks.conf_mutex);\n\terr = rtlpriv->intf_ops->adapter_start(hw);\n\tif (!err)\n\t\trtl_watch_dog_timer_callback(&rtlpriv->works.watchdog_timer);\n\tmutex_unlock(&rtlpriv->locks.conf_mutex);\n\treturn err;\n}\n\nstatic void rtl_op_stop(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tbool support_remote_wakeup = false;\n\n\tif (is_hal_stop(rtlhal))\n\t\treturn;\n\n\trtlpriv->cfg->ops->get_hw_reg(hw, HAL_DEF_WOWLAN,\n\t\t\t\t      (u8 *)(&support_remote_wakeup));\n\t \n\tif (unlikely(ppsc->rfpwr_state == ERFOFF))\n\t\trtl_ips_nic_on(hw);\n\n\tmutex_lock(&rtlpriv->locks.conf_mutex);\n\t \n\tif (!(support_remote_wakeup &&\n\t      rtlhal->enter_pnp_sleep)) {\n\t\tmac->link_state = MAC80211_NOLINK;\n\t\teth_zero_addr(mac->bssid);\n\t\tmac->vendor = PEER_UNKNOWN;\n\n\t\t \n\t\trtl_cam_reset_sec_info(hw);\n\n\t\trtl_deinit_deferred_work(hw, false);\n\t}\n\trtlpriv->intf_ops->adapter_stop(hw);\n\n\tmutex_unlock(&rtlpriv->locks.conf_mutex);\n}\n\nstatic void rtl_op_tx(struct ieee80211_hw *hw,\n\t\t      struct ieee80211_tx_control *control,\n\t\t      struct sk_buff *skb)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tstruct rtl_tcb_desc tcb_desc;\n\n\tmemset(&tcb_desc, 0, sizeof(struct rtl_tcb_desc));\n\n\tif (unlikely(is_hal_stop(rtlhal) || ppsc->rfpwr_state != ERFON))\n\t\tgoto err_free;\n\n\tif (!test_bit(RTL_STATUS_INTERFACE_START, &rtlpriv->status))\n\t\tgoto err_free;\n\n\tif (!rtlpriv->intf_ops->waitq_insert(hw, control->sta, skb))\n\t\trtlpriv->intf_ops->adapter_tx(hw, control->sta, skb, &tcb_desc);\n\treturn;\n\nerr_free:\n\tdev_kfree_skb_any(skb);\n}\n\nstatic int rtl_op_add_interface(struct ieee80211_hw *hw,\n\t\tstruct ieee80211_vif *vif)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tint err = 0;\n\tu8 retry_limit = 0x30;\n\n\tif (mac->vif) {\n\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_WARNING,\n\t\t\t\"vif has been set!! mac->vif = 0x%p\\n\", mac->vif);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tvif->driver_flags |= IEEE80211_VIF_BEACON_FILTER;\n\n\trtl_ips_nic_on(hw);\n\n\tmutex_lock(&rtlpriv->locks.conf_mutex);\n\tswitch (ieee80211_vif_type_p2p(vif)) {\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tmac->p2p = P2P_ROLE_CLIENT;\n\t\tfallthrough;\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (mac->beacon_enabled == 1) {\n\t\t\trtl_dbg(rtlpriv, COMP_MAC80211, DBG_LOUD,\n\t\t\t\t\"NL80211_IFTYPE_STATION\\n\");\n\t\t\tmac->beacon_enabled = 0;\n\t\t\trtlpriv->cfg->ops->update_interrupt_mask(hw, 0,\n\t\t\t\t\trtlpriv->cfg->maps[RTL_IBSS_INT_MASKS]);\n\t\t}\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\trtl_dbg(rtlpriv, COMP_MAC80211, DBG_LOUD,\n\t\t\t\"NL80211_IFTYPE_ADHOC\\n\");\n\n\t\tmac->link_state = MAC80211_LINKED;\n\t\trtlpriv->cfg->ops->set_bcn_reg(hw);\n\t\tif (rtlpriv->rtlhal.current_bandtype == BAND_ON_2_4G)\n\t\t\tmac->basic_rates = 0xfff;\n\t\telse\n\t\t\tmac->basic_rates = 0xff0;\n\t\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_BASIC_RATE,\n\t\t\t\t(u8 *)(&mac->basic_rates));\n\n\t\tretry_limit = 0x07;\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tmac->p2p = P2P_ROLE_GO;\n\t\tfallthrough;\n\tcase NL80211_IFTYPE_AP:\n\t\trtl_dbg(rtlpriv, COMP_MAC80211, DBG_LOUD,\n\t\t\t\"NL80211_IFTYPE_AP\\n\");\n\n\t\tmac->link_state = MAC80211_LINKED;\n\t\trtlpriv->cfg->ops->set_bcn_reg(hw);\n\t\tif (rtlpriv->rtlhal.current_bandtype == BAND_ON_2_4G)\n\t\t\tmac->basic_rates = 0xfff;\n\t\telse\n\t\t\tmac->basic_rates = 0xff0;\n\t\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_BASIC_RATE,\n\t\t\t\t\t      (u8 *)(&mac->basic_rates));\n\n\t\tretry_limit = 0x07;\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\trtl_dbg(rtlpriv, COMP_MAC80211, DBG_LOUD,\n\t\t\t\"NL80211_IFTYPE_MESH_POINT\\n\");\n\n\t\tmac->link_state = MAC80211_LINKED;\n\t\trtlpriv->cfg->ops->set_bcn_reg(hw);\n\t\tif (rtlpriv->rtlhal.current_bandtype == BAND_ON_2_4G)\n\t\t\tmac->basic_rates = 0xfff;\n\t\telse\n\t\t\tmac->basic_rates = 0xff0;\n\t\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_BASIC_RATE,\n\t\t\t\t(u8 *)(&mac->basic_rates));\n\n\t\tretry_limit = 0x07;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"operation mode %d is not supported!\\n\",\n\t\t       vif->type);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (mac->p2p) {\n\t\trtl_dbg(rtlpriv, COMP_MAC80211, DBG_LOUD,\n\t\t\t\"p2p role %x\\n\", vif->type);\n\t\tmac->basic_rates = 0xff0; \n\t\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_BASIC_RATE,\n\t\t\t\t(u8 *)(&mac->basic_rates));\n\t}\n\tmac->vif = vif;\n\tmac->opmode = vif->type;\n\trtlpriv->cfg->ops->set_network_type(hw, vif->type);\n\tmemcpy(mac->mac_addr, vif->addr, ETH_ALEN);\n\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_ETHER_ADDR, mac->mac_addr);\n\n\tmac->retry_long = retry_limit;\n\tmac->retry_short = retry_limit;\n\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_RETRY_LIMIT,\n\t\t\t(u8 *)(&retry_limit));\nout:\n\tmutex_unlock(&rtlpriv->locks.conf_mutex);\n\treturn err;\n}\n\nstatic void rtl_op_remove_interface(struct ieee80211_hw *hw,\n\t\tstruct ieee80211_vif *vif)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\n\tmutex_lock(&rtlpriv->locks.conf_mutex);\n\n\t \n\tif (vif->type == NL80211_IFTYPE_AP ||\n\t    vif->type == NL80211_IFTYPE_ADHOC ||\n\t    vif->type == NL80211_IFTYPE_MESH_POINT) {\n\t\tif (mac->beacon_enabled == 1) {\n\t\t\tmac->beacon_enabled = 0;\n\t\t\trtlpriv->cfg->ops->update_interrupt_mask(hw, 0,\n\t\t\t\t\trtlpriv->cfg->maps[RTL_IBSS_INT_MASKS]);\n\t\t}\n\t}\n\n\t \n\tmac->p2p = 0;\n\tmac->vif = NULL;\n\tmac->link_state = MAC80211_NOLINK;\n\teth_zero_addr(mac->bssid);\n\tmac->vendor = PEER_UNKNOWN;\n\tmac->opmode = NL80211_IFTYPE_UNSPECIFIED;\n\trtlpriv->cfg->ops->set_network_type(hw, mac->opmode);\n\n\tmutex_unlock(&rtlpriv->locks.conf_mutex);\n}\n\nstatic int rtl_op_change_interface(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif,\n\t\t\t\t   enum nl80211_iftype new_type, bool p2p)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tint ret;\n\n\trtl_op_remove_interface(hw, vif);\n\n\tvif->type = new_type;\n\tvif->p2p = p2p;\n\tret = rtl_op_add_interface(hw, vif);\n\trtl_dbg(rtlpriv, COMP_MAC80211, DBG_LOUD,\n\t\t\"p2p  %x\\n\", p2p);\n\treturn ret;\n}\n\n#ifdef CONFIG_PM\nstatic u16 crc16_ccitt(u8 data, u16 crc)\n{\n\tu8 shift_in, data_bit, crc_bit11, crc_bit4, crc_bit15;\n\tu8 i;\n\tu16 result;\n\n\tfor (i = 0; i < 8; i++) {\n\t\tcrc_bit15 = ((crc & BIT(15)) ? 1 : 0);\n\t\tdata_bit  = (data & (BIT(0) << i) ? 1 : 0);\n\t\tshift_in = crc_bit15 ^ data_bit;\n\n\t\tresult = crc << 1;\n\t\tif (shift_in == 0)\n\t\t\tresult &= (~BIT(0));\n\t\telse\n\t\t\tresult |= BIT(0);\n\n\t\tcrc_bit11 = ((crc & BIT(11)) ? 1 : 0) ^ shift_in;\n\t\tif (crc_bit11 == 0)\n\t\t\tresult &= (~BIT(12));\n\t\telse\n\t\t\tresult |= BIT(12);\n\n\t\tcrc_bit4 = ((crc & BIT(4)) ? 1 : 0) ^ shift_in;\n\t\tif (crc_bit4 == 0)\n\t\t\tresult &= (~BIT(5));\n\t\telse\n\t\t\tresult |= BIT(5);\n\n\t\tcrc = result;\n\t}\n\n\treturn crc;\n}\n\nstatic u16 _calculate_wol_pattern_crc(u8 *pattern, u16 len)\n{\n\tu16 crc = 0xffff;\n\tu32 i;\n\n\tfor (i = 0; i < len; i++)\n\t\tcrc = crc16_ccitt(pattern[i], crc);\n\n\tcrc = ~crc;\n\n\treturn crc;\n}\n\nstatic void _rtl_add_wowlan_patterns(struct ieee80211_hw *hw,\n\t\t\t\t     struct cfg80211_wowlan *wow)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = &rtlpriv->mac80211;\n\tstruct cfg80211_pkt_pattern *patterns = wow->patterns;\n\tstruct rtl_wow_pattern rtl_pattern;\n\tconst u8 *pattern_os, *mask_os;\n\tu8 mask[MAX_WOL_BIT_MASK_SIZE] = {0};\n\tu8 content[MAX_WOL_PATTERN_SIZE] = {0};\n\tu8 broadcast_addr[6] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\n\tu8 multicast_addr1[2] = {0x33, 0x33};\n\tu8 multicast_addr2[3] = {0x01, 0x00, 0x5e};\n\tu8 i, mask_len;\n\tu16 j, len;\n\n\tfor (i = 0; i < wow->n_patterns; i++) {\n\t\tmemset(&rtl_pattern, 0, sizeof(struct rtl_wow_pattern));\n\t\tmemset(mask, 0, MAX_WOL_BIT_MASK_SIZE);\n\t\tif (patterns[i].pattern_len < 0 ||\n\t\t    patterns[i].pattern_len > MAX_WOL_PATTERN_SIZE) {\n\t\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_WARNING,\n\t\t\t\t\"Pattern[%d] is too long\\n\", i);\n\t\t\tcontinue;\n\t\t}\n\t\tpattern_os = patterns[i].pattern;\n\t\tmask_len = DIV_ROUND_UP(patterns[i].pattern_len, 8);\n\t\tmask_os = patterns[i].mask;\n\t\tRT_PRINT_DATA(rtlpriv, COMP_POWER, DBG_TRACE,\n\t\t\t      \"pattern content\\n\", pattern_os,\n\t\t\t       patterns[i].pattern_len);\n\t\tRT_PRINT_DATA(rtlpriv, COMP_POWER, DBG_TRACE,\n\t\t\t      \"mask content\\n\", mask_os, mask_len);\n\t\t \n\t\tif (memcmp(pattern_os, broadcast_addr, 6) == 0)\n\t\t\trtl_pattern.type = BROADCAST_PATTERN;\n\t\telse if (memcmp(pattern_os, multicast_addr1, 2) == 0 ||\n\t\t\t memcmp(pattern_os, multicast_addr2, 3) == 0)\n\t\t\trtl_pattern.type = MULTICAST_PATTERN;\n\t\telse if  (memcmp(pattern_os, mac->mac_addr, 6) == 0)\n\t\t\trtl_pattern.type = UNICAST_PATTERN;\n\t\telse\n\t\t\trtl_pattern.type = UNKNOWN_TYPE;\n\n\t\t \n\n \n\n\t\t \n\t\tfor (j = 0; j < mask_len - 1; j++) {\n\t\t\tmask[j] = mask_os[j] >> 6;\n\t\t\tmask[j] |= (mask_os[j + 1] & 0x3F) << 2;\n\t\t}\n\t\tmask[j] = (mask_os[j] >> 6) & 0x3F;\n\t\t \n\t\tmask[0] &= 0xC0;\n\n\t\tRT_PRINT_DATA(rtlpriv, COMP_POWER, DBG_TRACE,\n\t\t\t      \"mask to hw\\n\", mask, mask_len);\n\t\tfor (j = 0; j < (MAX_WOL_BIT_MASK_SIZE + 1) / 4; j++) {\n\t\t\trtl_pattern.mask[j] = mask[j * 4];\n\t\t\trtl_pattern.mask[j] |= (mask[j * 4 + 1] << 8);\n\t\t\trtl_pattern.mask[j] |= (mask[j * 4 + 2] << 16);\n\t\t\trtl_pattern.mask[j] |= (mask[j * 4 + 3] << 24);\n\t\t}\n\n\t\t \n\t\tlen = 0;\n\t\tfor (j = 12; j < patterns[i].pattern_len; j++) {\n\t\t\tif ((mask_os[j / 8] >> (j % 8)) & 0x01) {\n\t\t\t\tcontent[len] = pattern_os[j];\n\t\t\t\tlen++;\n\t\t\t}\n\t\t}\n\n\t\tRT_PRINT_DATA(rtlpriv, COMP_POWER, DBG_TRACE,\n\t\t\t      \"pattern to hw\\n\", content, len);\n\t\t \n\t\trtl_pattern.crc = _calculate_wol_pattern_crc(content, len);\n\t\trtl_dbg(rtlpriv, COMP_POWER, DBG_TRACE,\n\t\t\t\"CRC_Remainder = 0x%x\\n\", rtl_pattern.crc);\n\n\t\t \n\t\trtlpriv->cfg->ops->add_wowlan_pattern(hw, &rtl_pattern, i);\n\t}\n\trtl_write_byte(rtlpriv, 0x698, wow->n_patterns);\n}\n\nstatic int rtl_op_suspend(struct ieee80211_hw *hw,\n\t\t\t  struct cfg80211_wowlan *wow)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\n\trtl_dbg(rtlpriv, COMP_POWER, DBG_DMESG, \"\\n\");\n\tif (WARN_ON(!wow))\n\t\treturn -EINVAL;\n\n\t \n\trtlhal->last_suspend_sec = ktime_get_real_seconds();\n\n\tif ((ppsc->wo_wlan_mode & WAKE_ON_PATTERN_MATCH) && wow->n_patterns)\n\t\t_rtl_add_wowlan_patterns(hw, wow);\n\n\trtlhal->driver_is_goingto_unload = true;\n\trtlhal->enter_pnp_sleep = true;\n\n\trtl_lps_leave(hw, true);\n\trtl_op_stop(hw);\n\tdevice_set_wakeup_enable(wiphy_dev(hw->wiphy), true);\n\treturn 0;\n}\n\nstatic int rtl_op_resume(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\ttime64_t now;\n\n\trtl_dbg(rtlpriv, COMP_POWER, DBG_DMESG, \"\\n\");\n\trtlhal->driver_is_goingto_unload = false;\n\trtlhal->enter_pnp_sleep = false;\n\trtlhal->wake_from_pnp_sleep = true;\n\n\t \n\tnow = ktime_get_real_seconds();\n\tif (now - rtlhal->last_suspend_sec < 5)\n\t\treturn -1;\n\n\trtl_op_start(hw);\n\tdevice_set_wakeup_enable(wiphy_dev(hw->wiphy), false);\n\tieee80211_resume_disconnect(mac->vif);\n\trtlhal->wake_from_pnp_sleep = false;\n\treturn 0;\n}\n#endif\n\nstatic int rtl_op_config(struct ieee80211_hw *hw, u32 changed)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tstruct ieee80211_conf *conf = &hw->conf;\n\n\tif (mac->skip_scan)\n\t\treturn 1;\n\n\tmutex_lock(&rtlpriv->locks.conf_mutex);\n\tif (changed & IEEE80211_CONF_CHANGE_LISTEN_INTERVAL) {\t \n\t\trtl_dbg(rtlpriv, COMP_MAC80211, DBG_LOUD,\n\t\t\t\"IEEE80211_CONF_CHANGE_LISTEN_INTERVAL\\n\");\n\t}\n\n\t \n\tif (changed & IEEE80211_CONF_CHANGE_IDLE) {\n\t\tif (hw->conf.flags & IEEE80211_CONF_IDLE)\n\t\t\trtl_ips_nic_off(hw);\n\t\telse\n\t\t\trtl_ips_nic_on(hw);\n\t} else {\n\t\t \n\t\tif (unlikely(ppsc->rfpwr_state == ERFOFF))\n\t\t\trtl_ips_nic_on(hw);\n\t}\n\n\t \n\tif ((changed & IEEE80211_CONF_CHANGE_PS) &&\n\t    rtlpriv->psc.swctrl_lps && !rtlpriv->psc.fwctrl_lps) {\n\t\tcancel_delayed_work(&rtlpriv->works.ps_work);\n\t\tcancel_delayed_work(&rtlpriv->works.ps_rfon_wq);\n\t\tif (conf->flags & IEEE80211_CONF_PS) {\n\t\t\trtlpriv->psc.sw_ps_enabled = true;\n\t\t\t \n\t\t\tif (!rtlpriv->psc.multi_buffered)\n\t\t\t\tqueue_delayed_work(rtlpriv->works.rtl_wq,\n\t\t\t\t\t\t   &rtlpriv->works.ps_work,\n\t\t\t\t\t\t   MSECS(5));\n\t\t} else {\n\t\t\trtl_swlps_rf_awake(hw);\n\t\t\trtlpriv->psc.sw_ps_enabled = false;\n\t\t}\n\t}\n\n\tif (changed & IEEE80211_CONF_CHANGE_RETRY_LIMITS) {\n\t\trtl_dbg(rtlpriv, COMP_MAC80211, DBG_LOUD,\n\t\t\t\"IEEE80211_CONF_CHANGE_RETRY_LIMITS %x\\n\",\n\t\t\thw->conf.long_frame_max_tx_count);\n\t\t \n\t\tif (changed != ~0) {\n\t\t\tmac->retry_long = hw->conf.long_frame_max_tx_count;\n\t\t\tmac->retry_short = hw->conf.long_frame_max_tx_count;\n\t\t\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_RETRY_LIMIT,\n\t\t\t\t(u8 *)(&hw->conf.long_frame_max_tx_count));\n\t\t}\n\t}\n\n\tif (changed & IEEE80211_CONF_CHANGE_CHANNEL &&\n\t    !rtlpriv->proximity.proxim_on) {\n\t\tstruct ieee80211_channel *channel = hw->conf.chandef.chan;\n\t\tenum nl80211_chan_width width = hw->conf.chandef.width;\n\t\tenum nl80211_channel_type channel_type = NL80211_CHAN_NO_HT;\n\t\tu8 wide_chan = (u8) channel->hw_value;\n\n\t\t \n\t\tif (width < NL80211_CHAN_WIDTH_80)\n\t\t\tchannel_type =\n\t\t\t\tcfg80211_get_chandef_type(&hw->conf.chandef);\n\t\tif (mac->act_scanning)\n\t\t\tmac->n_channels++;\n\n\t\tif (rtlpriv->dm.supp_phymode_switch &&\n\t\t\tmac->link_state < MAC80211_LINKED &&\n\t\t\t!mac->act_scanning) {\n\t\t\tif (rtlpriv->cfg->ops->chk_switch_dmdp)\n\t\t\t\trtlpriv->cfg->ops->chk_switch_dmdp(hw);\n\t\t}\n\n\t\t \n\n\t\tif (width >= NL80211_CHAN_WIDTH_80) {\n\t\t\tif (width == NL80211_CHAN_WIDTH_80) {\n\t\t\t\tu32 center = hw->conf.chandef.center_freq1;\n\t\t\t\tu32 primary =\n\t\t\t\t(u32)hw->conf.chandef.chan->center_freq;\n\n\t\t\t\trtlphy->current_chan_bw =\n\t\t\t\t\tHT_CHANNEL_WIDTH_80;\n\t\t\t\tmac->bw_80 = true;\n\t\t\t\tmac->bw_40 = true;\n\t\t\t\tif (center > primary) {\n\t\t\t\t\tmac->cur_80_prime_sc =\n\t\t\t\t\tPRIME_CHNL_OFFSET_LOWER;\n\t\t\t\t\tif (center - primary == 10) {\n\t\t\t\t\t\tmac->cur_40_prime_sc =\n\t\t\t\t\t\tPRIME_CHNL_OFFSET_UPPER;\n\n\t\t\t\t\t\twide_chan += 2;\n\t\t\t\t\t} else if (center - primary == 30) {\n\t\t\t\t\t\tmac->cur_40_prime_sc =\n\t\t\t\t\t\tPRIME_CHNL_OFFSET_LOWER;\n\n\t\t\t\t\t\twide_chan += 6;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmac->cur_80_prime_sc =\n\t\t\t\t\tPRIME_CHNL_OFFSET_UPPER;\n\t\t\t\t\tif (primary - center == 10) {\n\t\t\t\t\t\tmac->cur_40_prime_sc =\n\t\t\t\t\t\tPRIME_CHNL_OFFSET_LOWER;\n\n\t\t\t\t\t\twide_chan -= 2;\n\t\t\t\t\t} else if (primary - center == 30) {\n\t\t\t\t\t\tmac->cur_40_prime_sc =\n\t\t\t\t\t\tPRIME_CHNL_OFFSET_UPPER;\n\n\t\t\t\t\t\twide_chan -= 6;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (channel_type) {\n\t\t\tcase NL80211_CHAN_HT20:\n\t\t\tcase NL80211_CHAN_NO_HT:\n\t\t\t\t\t \n\t\t\t\t\tmac->cur_40_prime_sc =\n\t\t\t\t\t\tPRIME_CHNL_OFFSET_DONT_CARE;\n\t\t\t\t\trtlphy->current_chan_bw =\n\t\t\t\t\t\tHT_CHANNEL_WIDTH_20;\n\t\t\t\t\tmac->bw_40 = false;\n\t\t\t\t\tmac->bw_80 = false;\n\t\t\t\t\tbreak;\n\t\t\tcase NL80211_CHAN_HT40MINUS:\n\t\t\t\t\t \n\t\t\t\t\tmac->cur_40_prime_sc =\n\t\t\t\t\t\tPRIME_CHNL_OFFSET_UPPER;\n\t\t\t\t\trtlphy->current_chan_bw =\n\t\t\t\t\t\tHT_CHANNEL_WIDTH_20_40;\n\t\t\t\t\tmac->bw_40 = true;\n\t\t\t\t\tmac->bw_80 = false;\n\n\t\t\t\t\t \n\t\t\t\t\twide_chan -= 2;\n\n\t\t\t\t\tbreak;\n\t\t\tcase NL80211_CHAN_HT40PLUS:\n\t\t\t\t\t \n\t\t\t\t\tmac->cur_40_prime_sc =\n\t\t\t\t\t\tPRIME_CHNL_OFFSET_LOWER;\n\t\t\t\t\trtlphy->current_chan_bw =\n\t\t\t\t\t\tHT_CHANNEL_WIDTH_20_40;\n\t\t\t\t\tmac->bw_40 = true;\n\t\t\t\t\tmac->bw_80 = false;\n\n\t\t\t\t\t \n\t\t\t\t\twide_chan += 2;\n\n\t\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t\tmac->bw_40 = false;\n\t\t\t\t\tmac->bw_80 = false;\n\t\t\t\t\tpr_err(\"switch case %#x not processed\\n\",\n\t\t\t\t\t       channel_type);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (wide_chan <= 0)\n\t\t\twide_chan = 1;\n\n\t\t \n\t\tif (rtlpriv->mac80211.offchan_delay) {\n\t\t\trtlpriv->mac80211.offchan_delay = false;\n\t\t\tmdelay(50);\n\t\t}\n\n\t\trtlphy->current_channel = wide_chan;\n\n\t\trtlpriv->cfg->ops->switch_channel(hw);\n\t\trtlpriv->cfg->ops->set_channel_access(hw);\n\t\trtlpriv->cfg->ops->set_bw_mode(hw, channel_type);\n\t}\n\n\tmutex_unlock(&rtlpriv->locks.conf_mutex);\n\n\treturn 0;\n}\n\nstatic void rtl_op_configure_filter(struct ieee80211_hw *hw,\n\t\t\t\t    unsigned int changed_flags,\n\t\t\t\t    unsigned int *new_flags, u64 multicast)\n{\n\tbool update_rcr = false;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\n\t*new_flags &= RTL_SUPPORTED_FILTERS;\n\tif (0 == changed_flags)\n\t\treturn;\n\n\t \n\tif (changed_flags & FIF_ALLMULTI) {\n\t\tif (*new_flags & FIF_ALLMULTI) {\n\t\t\tmac->rx_conf |= rtlpriv->cfg->maps[MAC_RCR_AM] |\n\t\t\t    rtlpriv->cfg->maps[MAC_RCR_AB];\n\t\t\trtl_dbg(rtlpriv, COMP_MAC80211, DBG_LOUD,\n\t\t\t\t\"Enable receive multicast frame\\n\");\n\t\t} else {\n\t\t\tmac->rx_conf &= ~(rtlpriv->cfg->maps[MAC_RCR_AM] |\n\t\t\t\t\t  rtlpriv->cfg->maps[MAC_RCR_AB]);\n\t\t\trtl_dbg(rtlpriv, COMP_MAC80211, DBG_LOUD,\n\t\t\t\t\"Disable receive multicast frame\\n\");\n\t\t}\n\t\tupdate_rcr = true;\n\t}\n\n\tif (changed_flags & FIF_FCSFAIL) {\n\t\tif (*new_flags & FIF_FCSFAIL) {\n\t\t\tmac->rx_conf |= rtlpriv->cfg->maps[MAC_RCR_ACRC32];\n\t\t\trtl_dbg(rtlpriv, COMP_MAC80211, DBG_LOUD,\n\t\t\t\t\"Enable receive FCS error frame\\n\");\n\t\t} else {\n\t\t\tmac->rx_conf &= ~rtlpriv->cfg->maps[MAC_RCR_ACRC32];\n\t\t\trtl_dbg(rtlpriv, COMP_MAC80211, DBG_LOUD,\n\t\t\t\t\"Disable receive FCS error frame\\n\");\n\t\t}\n\t\tif (!update_rcr)\n\t\t\tupdate_rcr = true;\n\t}\n\n\t \n\tif (changed_flags & FIF_BCN_PRBRESP_PROMISC &&\n\t    mac->link_state >= MAC80211_LINKED) {\n\t\tif (mac->opmode != NL80211_IFTYPE_AP &&\n\t\t    mac->opmode != NL80211_IFTYPE_MESH_POINT) {\n\t\t\tif (*new_flags & FIF_BCN_PRBRESP_PROMISC)\n\t\t\t\trtlpriv->cfg->ops->set_chk_bssid(hw, false);\n\t\t\telse\n\t\t\t\trtlpriv->cfg->ops->set_chk_bssid(hw, true);\n\t\t\tif (update_rcr)\n\t\t\t\tupdate_rcr = false;\n\t\t}\n\t}\n\n\tif (changed_flags & FIF_CONTROL) {\n\t\tif (*new_flags & FIF_CONTROL) {\n\t\t\tmac->rx_conf |= rtlpriv->cfg->maps[MAC_RCR_ACF];\n\n\t\t\trtl_dbg(rtlpriv, COMP_MAC80211, DBG_LOUD,\n\t\t\t\t\"Enable receive control frame.\\n\");\n\t\t} else {\n\t\t\tmac->rx_conf &= ~rtlpriv->cfg->maps[MAC_RCR_ACF];\n\t\t\trtl_dbg(rtlpriv, COMP_MAC80211, DBG_LOUD,\n\t\t\t\t\"Disable receive control frame.\\n\");\n\t\t}\n\t\tif (!update_rcr)\n\t\t\tupdate_rcr = true;\n\t}\n\n\tif (changed_flags & FIF_OTHER_BSS) {\n\t\tif (*new_flags & FIF_OTHER_BSS) {\n\t\t\tmac->rx_conf |= rtlpriv->cfg->maps[MAC_RCR_AAP];\n\t\t\trtl_dbg(rtlpriv, COMP_MAC80211, DBG_LOUD,\n\t\t\t\t\"Enable receive other BSS's frame.\\n\");\n\t\t} else {\n\t\t\tmac->rx_conf &= ~rtlpriv->cfg->maps[MAC_RCR_AAP];\n\t\t\trtl_dbg(rtlpriv, COMP_MAC80211, DBG_LOUD,\n\t\t\t\t\"Disable receive other BSS's frame.\\n\");\n\t\t}\n\t\tif (!update_rcr)\n\t\t\tupdate_rcr = true;\n\t}\n\n\tif (update_rcr)\n\t\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_RCR,\n\t\t\t\t\t      (u8 *)(&mac->rx_conf));\n}\n\nstatic int rtl_op_sta_add(struct ieee80211_hw *hw,\n\t\t\t struct ieee80211_vif *vif,\n\t\t\t struct ieee80211_sta *sta)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_sta_info *sta_entry;\n\n\tif (sta) {\n\t\tsta_entry = (struct rtl_sta_info *)sta->drv_priv;\n\t\tspin_lock_bh(&rtlpriv->locks.entry_list_lock);\n\t\tlist_add_tail(&sta_entry->list, &rtlpriv->entry_list);\n\t\tspin_unlock_bh(&rtlpriv->locks.entry_list_lock);\n\t\tif (rtlhal->current_bandtype == BAND_ON_2_4G) {\n\t\t\tsta_entry->wireless_mode = WIRELESS_MODE_G;\n\t\t\tif (sta->deflink.supp_rates[0] <= 0xf)\n\t\t\t\tsta_entry->wireless_mode = WIRELESS_MODE_B;\n\t\t\tif (sta->deflink.ht_cap.ht_supported)\n\t\t\t\tsta_entry->wireless_mode = WIRELESS_MODE_N_24G;\n\n\t\t\tif (vif->type == NL80211_IFTYPE_ADHOC)\n\t\t\t\tsta_entry->wireless_mode = WIRELESS_MODE_G;\n\t\t} else if (rtlhal->current_bandtype == BAND_ON_5G) {\n\t\t\tsta_entry->wireless_mode = WIRELESS_MODE_A;\n\t\t\tif (sta->deflink.ht_cap.ht_supported)\n\t\t\t\tsta_entry->wireless_mode = WIRELESS_MODE_N_5G;\n\t\t\tif (sta->deflink.vht_cap.vht_supported)\n\t\t\t\tsta_entry->wireless_mode = WIRELESS_MODE_AC_5G;\n\n\t\t\tif (vif->type == NL80211_IFTYPE_ADHOC)\n\t\t\t\tsta_entry->wireless_mode = WIRELESS_MODE_A;\n\t\t}\n\t\t \n\t\tif (mac->p2p)\n\t\t\tsta->deflink.supp_rates[0] &= 0xfffffff0;\n\n\t\tmemcpy(sta_entry->mac_addr, sta->addr, ETH_ALEN);\n\t\trtl_dbg(rtlpriv, COMP_MAC80211, DBG_DMESG,\n\t\t\t\"Add sta addr is %pM\\n\", sta->addr);\n\t\trtlpriv->cfg->ops->update_rate_tbl(hw, sta, 0, true);\n\t}\n\n\treturn 0;\n}\n\nstatic int rtl_op_sta_remove(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tstruct ieee80211_sta *sta)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_sta_info *sta_entry;\n\n\tif (sta) {\n\t\trtl_dbg(rtlpriv, COMP_MAC80211, DBG_DMESG,\n\t\t\t\"Remove sta addr is %pM\\n\", sta->addr);\n\t\tsta_entry = (struct rtl_sta_info *)sta->drv_priv;\n\t\tsta_entry->wireless_mode = 0;\n\t\tsta_entry->ratr_index = 0;\n\t\tspin_lock_bh(&rtlpriv->locks.entry_list_lock);\n\t\tlist_del(&sta_entry->list);\n\t\tspin_unlock_bh(&rtlpriv->locks.entry_list_lock);\n\t}\n\treturn 0;\n}\n\nstatic int _rtl_get_hal_qnum(u16 queue)\n{\n\tint qnum;\n\n\tswitch (queue) {\n\tcase 0:\n\t\tqnum = AC3_VO;\n\t\tbreak;\n\tcase 1:\n\t\tqnum = AC2_VI;\n\t\tbreak;\n\tcase 2:\n\t\tqnum = AC0_BE;\n\t\tbreak;\n\tcase 3:\n\t\tqnum = AC1_BK;\n\t\tbreak;\n\tdefault:\n\t\tqnum = AC0_BE;\n\t\tbreak;\n\t}\n\treturn qnum;\n}\n\n \nstatic int rtl_op_conf_tx(struct ieee80211_hw *hw,\n\t\t\t  struct ieee80211_vif *vif,\n\t\t\t  unsigned int link_id, u16 queue,\n\t\t\t  const struct ieee80211_tx_queue_params *param)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tint aci;\n\n\tif (queue >= AC_MAX) {\n\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_WARNING,\n\t\t\t\"queue number %d is incorrect!\\n\", queue);\n\t\treturn -EINVAL;\n\t}\n\n\taci = _rtl_get_hal_qnum(queue);\n\tmac->ac[aci].aifs = param->aifs;\n\tmac->ac[aci].cw_min = cpu_to_le16(param->cw_min);\n\tmac->ac[aci].cw_max = cpu_to_le16(param->cw_max);\n\tmac->ac[aci].tx_op = cpu_to_le16(param->txop);\n\tmemcpy(&mac->edca_param[aci], param, sizeof(*param));\n\trtlpriv->cfg->ops->set_qos(hw, aci);\n\treturn 0;\n}\n\nstatic void send_beacon_frame(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct sk_buff *skb = ieee80211_beacon_get(hw, vif, 0);\n\tstruct rtl_tcb_desc tcb_desc;\n\n\tif (skb) {\n\t\tmemset(&tcb_desc, 0, sizeof(struct rtl_tcb_desc));\n\t\trtlpriv->intf_ops->adapter_tx(hw, NULL, skb, &tcb_desc);\n\t}\n}\n\nvoid rtl_update_beacon_work_callback(struct work_struct *work)\n{\n\tstruct rtl_works *rtlworks =\n\t    container_of(work, struct rtl_works, update_beacon_work);\n\tstruct ieee80211_hw *hw = rtlworks->hw;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct ieee80211_vif *vif = rtlpriv->mac80211.vif;\n\n\tif (!vif) {\n\t\tWARN_ONCE(true, \"no vif to update beacon\\n\");\n\t\treturn;\n\t}\n\n\tmutex_lock(&rtlpriv->locks.conf_mutex);\n\tsend_beacon_frame(hw, vif);\n\tmutex_unlock(&rtlpriv->locks.conf_mutex);\n}\nEXPORT_SYMBOL_GPL(rtl_update_beacon_work_callback);\n\nstatic void rtl_op_bss_info_changed(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif,\n\t\t\t\t    struct ieee80211_bss_conf *bss_conf,\n\t\t\t\t    u64 changed)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\n\tmutex_lock(&rtlpriv->locks.conf_mutex);\n\tif (vif->type == NL80211_IFTYPE_ADHOC ||\n\t    vif->type == NL80211_IFTYPE_AP ||\n\t    vif->type == NL80211_IFTYPE_MESH_POINT) {\n\t\tif (changed & BSS_CHANGED_BEACON ||\n\t\t    (changed & BSS_CHANGED_BEACON_ENABLED &&\n\t\t     bss_conf->enable_beacon)) {\n\t\t\tif (mac->beacon_enabled == 0) {\n\t\t\t\trtl_dbg(rtlpriv, COMP_MAC80211, DBG_DMESG,\n\t\t\t\t\t\"BSS_CHANGED_BEACON_ENABLED\\n\");\n\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tmac->beacon_enabled = 1;\n\t\t\t\trtlpriv->cfg->ops->update_interrupt_mask(hw,\n\t\t\t\t\t\trtlpriv->cfg->maps\n\t\t\t\t\t\t[RTL_IBSS_INT_MASKS], 0);\n\n\t\t\t\tif (rtlpriv->cfg->ops->linked_set_reg)\n\t\t\t\t\trtlpriv->cfg->ops->linked_set_reg(hw);\n\t\t\t\tsend_beacon_frame(hw, vif);\n\t\t\t}\n\t\t}\n\t\tif ((changed & BSS_CHANGED_BEACON_ENABLED &&\n\t\t    !bss_conf->enable_beacon)) {\n\t\t\tif (mac->beacon_enabled == 1) {\n\t\t\t\trtl_dbg(rtlpriv, COMP_MAC80211, DBG_DMESG,\n\t\t\t\t\t\"ADHOC DISABLE BEACON\\n\");\n\n\t\t\t\tmac->beacon_enabled = 0;\n\t\t\t\trtlpriv->cfg->ops->update_interrupt_mask(hw, 0,\n\t\t\t\t\t\trtlpriv->cfg->maps\n\t\t\t\t\t\t[RTL_IBSS_INT_MASKS]);\n\t\t\t}\n\t\t}\n\t\tif (changed & BSS_CHANGED_BEACON_INT) {\n\t\t\trtl_dbg(rtlpriv, COMP_BEACON, DBG_TRACE,\n\t\t\t\t\"BSS_CHANGED_BEACON_INT\\n\");\n\t\t\tmac->beacon_interval = bss_conf->beacon_int;\n\t\t\trtlpriv->cfg->ops->set_bcn_intv(hw);\n\t\t}\n\t}\n\n\t \n\tif (changed & BSS_CHANGED_ASSOC) {\n\t\tu8 mstatus;\n\n\t\tif (vif->cfg.assoc) {\n\t\t\tstruct ieee80211_sta *sta = NULL;\n\t\t\tu8 keep_alive = 10;\n\n\t\t\tmstatus = RT_MEDIA_CONNECT;\n\t\t\t \n\t\t\t \n\t\t\trtl_cam_reset_sec_info(hw);\n\t\t\t \n\t\t\trtl_cam_reset_all_entry(hw);\n\n\t\t\tmac->link_state = MAC80211_LINKED;\n\t\t\tmac->cnt_after_linked = 0;\n\t\t\tmac->assoc_id = vif->cfg.aid;\n\t\t\tmemcpy(mac->bssid, bss_conf->bssid, ETH_ALEN);\n\n\t\t\tif (rtlpriv->cfg->ops->linked_set_reg)\n\t\t\t\trtlpriv->cfg->ops->linked_set_reg(hw);\n\n\t\t\trcu_read_lock();\n\t\t\tsta = ieee80211_find_sta(vif, (u8 *)bss_conf->bssid);\n\t\t\tif (!sta) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\trtl_dbg(rtlpriv, COMP_EASY_CONCURRENT, DBG_LOUD,\n\t\t\t\t\"send PS STATIC frame\\n\");\n\t\t\tif (rtlpriv->dm.supp_phymode_switch) {\n\t\t\t\tif (sta->deflink.ht_cap.ht_supported)\n\t\t\t\t\trtl_send_smps_action(hw, sta,\n\t\t\t\t\t\t\tIEEE80211_SMPS_STATIC);\n\t\t\t}\n\n\t\t\tif (rtlhal->current_bandtype == BAND_ON_5G) {\n\t\t\t\tmac->mode = WIRELESS_MODE_A;\n\t\t\t} else {\n\t\t\t\tif (sta->deflink.supp_rates[0] <= 0xf)\n\t\t\t\t\tmac->mode = WIRELESS_MODE_B;\n\t\t\t\telse\n\t\t\t\t\tmac->mode = WIRELESS_MODE_G;\n\t\t\t}\n\n\t\t\tif (sta->deflink.ht_cap.ht_supported) {\n\t\t\t\tif (rtlhal->current_bandtype == BAND_ON_2_4G)\n\t\t\t\t\tmac->mode = WIRELESS_MODE_N_24G;\n\t\t\t\telse\n\t\t\t\t\tmac->mode = WIRELESS_MODE_N_5G;\n\t\t\t}\n\n\t\t\tif (sta->deflink.vht_cap.vht_supported) {\n\t\t\t\tif (rtlhal->current_bandtype == BAND_ON_5G)\n\t\t\t\t\tmac->mode = WIRELESS_MODE_AC_5G;\n\t\t\t\telse\n\t\t\t\t\tmac->mode = WIRELESS_MODE_AC_24G;\n\t\t\t}\n\n\t\t\tif (vif->type == NL80211_IFTYPE_STATION)\n\t\t\t\trtlpriv->cfg->ops->update_rate_tbl(hw, sta, 0,\n\t\t\t\t\t\t\t\t   true);\n\t\t\trcu_read_unlock();\n\n\t\t\t \n\t\t\trtlpriv->cfg->ops->set_hw_reg(hw,\n\t\t\t\t\t\t      HW_VAR_KEEP_ALIVE,\n\t\t\t\t\t\t      (u8 *)(&keep_alive));\n\n\t\t\trtl_dbg(rtlpriv, COMP_MAC80211, DBG_DMESG,\n\t\t\t\t\"BSS_CHANGED_ASSOC\\n\");\n\t\t} else {\n\t\t\tstruct cfg80211_bss *bss = NULL;\n\n\t\t\tmstatus = RT_MEDIA_DISCONNECT;\n\n\t\t\tif (mac->link_state == MAC80211_LINKED)\n\t\t\t\trtl_lps_leave(hw, true);\n\t\t\tif (ppsc->p2p_ps_info.p2p_ps_mode > P2P_PS_NONE)\n\t\t\t\trtl_p2p_ps_cmd(hw, P2P_PS_DISABLE);\n\t\t\tmac->link_state = MAC80211_NOLINK;\n\n\t\t\tbss = cfg80211_get_bss(hw->wiphy, NULL,\n\t\t\t\t\t       (u8 *)mac->bssid, NULL, 0,\n\t\t\t\t\t       IEEE80211_BSS_TYPE_ESS,\n\t\t\t\t\t       IEEE80211_PRIVACY_OFF);\n\n\t\t\trtl_dbg(rtlpriv, COMP_MAC80211, DBG_DMESG,\n\t\t\t\t\"bssid = %pMF\\n\", mac->bssid);\n\n\t\t\tif (bss) {\n\t\t\t\tcfg80211_unlink_bss(hw->wiphy, bss);\n\t\t\t\tcfg80211_put_bss(hw->wiphy, bss);\n\t\t\t\trtl_dbg(rtlpriv, COMP_MAC80211, DBG_DMESG,\n\t\t\t\t\t\"cfg80211_unlink !!\\n\");\n\t\t\t}\n\n\t\t\teth_zero_addr(mac->bssid);\n\t\t\tmac->vendor = PEER_UNKNOWN;\n\t\t\tmac->mode = 0;\n\n\t\t\tif (rtlpriv->dm.supp_phymode_switch) {\n\t\t\t\tif (rtlpriv->cfg->ops->chk_switch_dmdp)\n\t\t\t\t\trtlpriv->cfg->ops->chk_switch_dmdp(hw);\n\t\t\t}\n\t\t\trtl_dbg(rtlpriv, COMP_MAC80211, DBG_DMESG,\n\t\t\t\t\"BSS_CHANGED_UN_ASSOC\\n\");\n\t\t}\n\t\trtlpriv->cfg->ops->set_network_type(hw, vif->type);\n\t\t \n\t\trtlpriv->cfg->ops->set_hw_reg(hw,\n\t\t\t\t\t      HW_VAR_H2C_FW_JOINBSSRPT,\n\t\t\t\t\t      (u8 *)(&mstatus));\n\t\tppsc->report_linked = (mstatus == RT_MEDIA_CONNECT) ?\n\t\t\t\t      true : false;\n\n\t\tif (rtlpriv->cfg->ops->get_btc_status())\n\t\t\trtlpriv->btcoexist.btc_ops->btc_mediastatus_notify(\n\t\t\t\t\t\t\trtlpriv, mstatus);\n\t}\n\n\tif (changed & BSS_CHANGED_ERP_CTS_PROT) {\n\t\trtl_dbg(rtlpriv, COMP_MAC80211, DBG_TRACE,\n\t\t\t\"BSS_CHANGED_ERP_CTS_PROT\\n\");\n\t\tmac->use_cts_protect = bss_conf->use_cts_prot;\n\t}\n\n\tif (changed & BSS_CHANGED_ERP_PREAMBLE) {\n\t\trtl_dbg(rtlpriv, COMP_MAC80211, DBG_LOUD,\n\t\t\t\"BSS_CHANGED_ERP_PREAMBLE use short preamble:%x\\n\",\n\t\t\t  bss_conf->use_short_preamble);\n\n\t\tmac->short_preamble = bss_conf->use_short_preamble;\n\t\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_ACK_PREAMBLE,\n\t\t\t\t\t      (u8 *)(&mac->short_preamble));\n\t}\n\n\tif (changed & BSS_CHANGED_ERP_SLOT) {\n\t\trtl_dbg(rtlpriv, COMP_MAC80211, DBG_TRACE,\n\t\t\t\"BSS_CHANGED_ERP_SLOT\\n\");\n\n\t\tif (bss_conf->use_short_slot)\n\t\t\tmac->slot_time = RTL_SLOT_TIME_9;\n\t\telse\n\t\t\tmac->slot_time = RTL_SLOT_TIME_20;\n\n\t\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_SLOT_TIME,\n\t\t\t\t\t      (u8 *)(&mac->slot_time));\n\t}\n\n\tif (changed & BSS_CHANGED_HT) {\n\t\tstruct ieee80211_sta *sta = NULL;\n\n\t\trtl_dbg(rtlpriv, COMP_MAC80211, DBG_TRACE,\n\t\t\t\"BSS_CHANGED_HT\\n\");\n\n\t\trcu_read_lock();\n\t\tsta = ieee80211_find_sta(vif, (u8 *)bss_conf->bssid);\n\t\tif (sta) {\n\t\t\tif (sta->deflink.ht_cap.ampdu_density >\n\t\t\t    mac->current_ampdu_density)\n\t\t\t\tmac->current_ampdu_density =\n\t\t\t\t    sta->deflink.ht_cap.ampdu_density;\n\t\t\tif (sta->deflink.ht_cap.ampdu_factor <\n\t\t\t    mac->current_ampdu_factor)\n\t\t\t\tmac->current_ampdu_factor =\n\t\t\t\t    sta->deflink.ht_cap.ampdu_factor;\n\t\t}\n\t\trcu_read_unlock();\n\n\t\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_SHORTGI_DENSITY,\n\t\t\t\t\t      (u8 *)(&mac->max_mss_density));\n\t\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_AMPDU_FACTOR,\n\t\t\t\t\t      &mac->current_ampdu_factor);\n\t\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_AMPDU_MIN_SPACE,\n\t\t\t\t\t      &mac->current_ampdu_density);\n\t}\n\n\tif (changed & BSS_CHANGED_BSSID) {\n\t\tu32 basic_rates;\n\t\tstruct ieee80211_sta *sta = NULL;\n\n\t\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_BSSID,\n\t\t\t\t\t      (u8 *)bss_conf->bssid);\n\n\t\trtl_dbg(rtlpriv, COMP_MAC80211, DBG_DMESG,\n\t\t\t\"bssid: %pM\\n\", bss_conf->bssid);\n\n\t\tmac->vendor = PEER_UNKNOWN;\n\t\tmemcpy(mac->bssid, bss_conf->bssid, ETH_ALEN);\n\n\t\trcu_read_lock();\n\t\tsta = ieee80211_find_sta(vif, (u8 *)bss_conf->bssid);\n\t\tif (!sta) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (rtlhal->current_bandtype == BAND_ON_5G) {\n\t\t\tmac->mode = WIRELESS_MODE_A;\n\t\t} else {\n\t\t\tif (sta->deflink.supp_rates[0] <= 0xf)\n\t\t\t\tmac->mode = WIRELESS_MODE_B;\n\t\t\telse\n\t\t\t\tmac->mode = WIRELESS_MODE_G;\n\t\t}\n\n\t\tif (sta->deflink.ht_cap.ht_supported) {\n\t\t\tif (rtlhal->current_bandtype == BAND_ON_2_4G)\n\t\t\t\tmac->mode = WIRELESS_MODE_N_24G;\n\t\t\telse\n\t\t\t\tmac->mode = WIRELESS_MODE_N_5G;\n\t\t}\n\n\t\tif (sta->deflink.vht_cap.vht_supported) {\n\t\t\tif (rtlhal->current_bandtype == BAND_ON_5G)\n\t\t\t\tmac->mode = WIRELESS_MODE_AC_5G;\n\t\t\telse\n\t\t\t\tmac->mode = WIRELESS_MODE_AC_24G;\n\t\t}\n\n\t\t \n\t\tif (vif->type == NL80211_IFTYPE_STATION) {\n\t\t\tstruct rtl_sta_info *sta_entry;\n\n\t\t\tsta_entry = (struct rtl_sta_info *)sta->drv_priv;\n\t\t\tsta_entry->wireless_mode = mac->mode;\n\t\t}\n\n\t\tif (sta->deflink.ht_cap.ht_supported) {\n\t\t\tmac->ht_enable = true;\n\n\t\t\t \n\t\t}\n\n\t\tif (sta->deflink.vht_cap.vht_supported)\n\t\t\tmac->vht_enable = true;\n\n\t\tif (changed & BSS_CHANGED_BASIC_RATES) {\n\t\t\t \n\t\t\tif (rtlhal->current_bandtype == BAND_ON_5G)\n\t\t\t\tbasic_rates = sta->deflink.supp_rates[1] << 4;\n\t\t\telse\n\t\t\t\tbasic_rates = sta->deflink.supp_rates[0];\n\n\t\t\tmac->basic_rates = basic_rates;\n\t\t\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_BASIC_RATE,\n\t\t\t\t\t(u8 *)(&basic_rates));\n\t\t}\n\t\trcu_read_unlock();\n\t}\nout:\n\tmutex_unlock(&rtlpriv->locks.conf_mutex);\n}\n\nstatic u64 rtl_op_get_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu64 tsf;\n\n\trtlpriv->cfg->ops->get_hw_reg(hw, HW_VAR_CORRECT_TSF, (u8 *)(&tsf));\n\treturn tsf;\n}\n\nstatic void rtl_op_set_tsf(struct ieee80211_hw *hw,\n\t\t\t   struct ieee80211_vif *vif, u64 tsf)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tu8 bibss = (mac->opmode == NL80211_IFTYPE_ADHOC) ? 1 : 0;\n\n\tmac->tsf = tsf;\n\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_CORRECT_TSF, (u8 *)(&bibss));\n}\n\nstatic void rtl_op_reset_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 tmp = 0;\n\n\trtlpriv->cfg->ops->set_hw_reg(hw, HW_VAR_DUAL_TSF_RST, (u8 *)(&tmp));\n}\n\nstatic void rtl_op_sta_notify(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_vif *vif,\n\t\t\t      enum sta_notify_cmd cmd,\n\t\t\t      struct ieee80211_sta *sta)\n{\n\tswitch (cmd) {\n\tcase STA_NOTIFY_SLEEP:\n\t\tbreak;\n\tcase STA_NOTIFY_AWAKE:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int rtl_op_ampdu_action(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif,\n\t\t\t       struct ieee80211_ampdu_params *params)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct ieee80211_sta *sta = params->sta;\n\tenum ieee80211_ampdu_mlme_action action = params->action;\n\tu16 tid = params->tid;\n\tu16 *ssn = &params->ssn;\n\n\tswitch (action) {\n\tcase IEEE80211_AMPDU_TX_START:\n\t\trtl_dbg(rtlpriv, COMP_MAC80211, DBG_TRACE,\n\t\t\t\"IEEE80211_AMPDU_TX_START: TID:%d\\n\", tid);\n\t\treturn rtl_tx_agg_start(hw, vif, sta, tid, ssn);\n\tcase IEEE80211_AMPDU_TX_STOP_CONT:\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH:\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH_CONT:\n\t\trtl_dbg(rtlpriv, COMP_MAC80211, DBG_TRACE,\n\t\t\t\"IEEE80211_AMPDU_TX_STOP: TID:%d\\n\", tid);\n\t\treturn rtl_tx_agg_stop(hw, vif, sta, tid);\n\tcase IEEE80211_AMPDU_TX_OPERATIONAL:\n\t\trtl_dbg(rtlpriv, COMP_MAC80211, DBG_TRACE,\n\t\t\t\"IEEE80211_AMPDU_TX_OPERATIONAL:TID:%d\\n\", tid);\n\t\trtl_tx_agg_oper(hw, sta, tid);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_RX_START:\n\t\trtl_dbg(rtlpriv, COMP_MAC80211, DBG_TRACE,\n\t\t\t\"IEEE80211_AMPDU_RX_START:TID:%d\\n\", tid);\n\t\treturn rtl_rx_agg_start(hw, sta, tid);\n\tcase IEEE80211_AMPDU_RX_STOP:\n\t\trtl_dbg(rtlpriv, COMP_MAC80211, DBG_TRACE,\n\t\t\t\"IEEE80211_AMPDU_RX_STOP:TID:%d\\n\", tid);\n\t\treturn rtl_rx_agg_stop(hw, sta, tid);\n\tdefault:\n\t\tpr_err(\"IEEE80211_AMPDU_ERR!!!!:\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\nstatic void rtl_op_sw_scan_start(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t const u8 *mac_addr)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\n\trtl_dbg(rtlpriv, COMP_MAC80211, DBG_LOUD, \"\\n\");\n\tmac->act_scanning = true;\n\tif (rtlpriv->link_info.higher_busytraffic) {\n\t\tmac->skip_scan = true;\n\t\treturn;\n\t}\n\n\tif (rtlpriv->cfg->ops->get_btc_status())\n\t\trtlpriv->btcoexist.btc_ops->btc_scan_notify(rtlpriv, 1);\n\telse if (rtlpriv->btcoexist.btc_ops)\n\t\trtlpriv->btcoexist.btc_ops->btc_scan_notify_wifi_only(rtlpriv,\n\t\t\t\t\t\t\t\t      1);\n\n\tif (rtlpriv->dm.supp_phymode_switch) {\n\t\tif (rtlpriv->cfg->ops->chk_switch_dmdp)\n\t\t\trtlpriv->cfg->ops->chk_switch_dmdp(hw);\n\t}\n\n\tif (mac->link_state == MAC80211_LINKED) {\n\t\trtl_lps_leave(hw, true);\n\t\tmac->link_state = MAC80211_LINKED_SCANNING;\n\t} else {\n\t\trtl_ips_nic_on(hw);\n\t}\n\n\t \n\trtlpriv->rtlhal.load_imrandiqk_setting_for2g = false;\n\n\trtlpriv->cfg->ops->led_control(hw, LED_CTL_SITE_SURVEY);\n\trtlpriv->cfg->ops->scan_operation_backup(hw, SCAN_OPT_BACKUP_BAND0);\n}\n\nstatic void rtl_op_sw_scan_complete(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_vif *vif)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\n\trtl_dbg(rtlpriv, COMP_MAC80211, DBG_LOUD, \"\\n\");\n\tmac->act_scanning = false;\n\tmac->skip_scan = false;\n\n\trtlpriv->btcoexist.btc_info.ap_num = rtlpriv->scan_list.num;\n\n\tif (rtlpriv->link_info.higher_busytraffic)\n\t\treturn;\n\n\t \n\tif (mac->n_channels == 3)\n\t\tmac->p2p_in_use = true;\n\telse\n\t\tmac->p2p_in_use = false;\n\tmac->n_channels = 0;\n\t \n\trtlpriv->rtlhal.load_imrandiqk_setting_for2g = false;\n\n\tif (mac->link_state == MAC80211_LINKED_SCANNING) {\n\t\tmac->link_state = MAC80211_LINKED;\n\t\tif (mac->opmode == NL80211_IFTYPE_STATION) {\n\t\t\t \n\t\t\trtlpriv->cfg->ops->set_network_type(hw, mac->opmode);\n\t\t}\n\t}\n\n\trtlpriv->cfg->ops->scan_operation_backup(hw, SCAN_OPT_RESTORE);\n\tif (rtlpriv->cfg->ops->get_btc_status())\n\t\trtlpriv->btcoexist.btc_ops->btc_scan_notify(rtlpriv, 0);\n\telse if (rtlpriv->btcoexist.btc_ops)\n\t\trtlpriv->btcoexist.btc_ops->btc_scan_notify_wifi_only(rtlpriv,\n\t\t\t\t\t\t\t\t      0);\n}\n\nstatic int rtl_op_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,\n\t\t\t  struct ieee80211_vif *vif, struct ieee80211_sta *sta,\n\t\t\t  struct ieee80211_key_conf *key)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 key_type = NO_ENCRYPTION;\n\tu8 key_idx;\n\tbool group_key = false;\n\tbool wep_only = false;\n\tint err = 0;\n\tu8 mac_addr[ETH_ALEN];\n\tu8 bcast_addr[ETH_ALEN] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\n\n\trtlpriv->btcoexist.btc_info.in_4way = false;\n\n\tif (rtlpriv->cfg->mod_params->sw_crypto || rtlpriv->sec.use_sw_sec) {\n\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_WARNING,\n\t\t\t\"not open hw encryption\\n\");\n\t\treturn -ENOSPC;\t \n\t}\n\t \n\tif ((vif->type == NL80211_IFTYPE_ADHOC ||\n\t     vif->type == NL80211_IFTYPE_MESH_POINT) &&\n\t    !(key->flags & IEEE80211_KEY_FLAG_PAIRWISE))\n\t\treturn -ENOSPC;\n\trtl_dbg(rtlpriv, COMP_SEC, DBG_DMESG,\n\t\t\"%s hardware based encryption for keyidx: %d, mac: %pM\\n\",\n\t\tcmd == SET_KEY ? \"Using\" : \"Disabling\", key->keyidx,\n\t\tsta ? sta->addr : bcast_addr);\n\trtlpriv->sec.being_setkey = true;\n\trtl_ips_nic_on(hw);\n\tmutex_lock(&rtlpriv->locks.conf_mutex);\n\t \n\n\tswitch (key->cipher) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\tkey_type = WEP40_ENCRYPTION;\n\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_DMESG, \"alg:WEP40\\n\");\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_DMESG, \"alg:WEP104\\n\");\n\t\tkey_type = WEP104_ENCRYPTION;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\tkey_type = TKIP_ENCRYPTION;\n\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_DMESG, \"alg:TKIP\\n\");\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tkey_type = AESCCMP_ENCRYPTION;\n\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_DMESG, \"alg:CCMP\\n\");\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_AES_CMAC:\n\t\t \n\t\tkey_type = AESCMAC_ENCRYPTION;\n\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_DMESG, \"alg:CMAC\\n\");\n\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_DMESG,\n\t\t\t\"HW don't support CMAC encryption, use software CMAC encryption\\n\");\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_unlock;\n\tdefault:\n\t\tpr_err(\"alg_err:%x!!!!:\\n\", key->cipher);\n\t\tgoto out_unlock;\n\t}\n\tif (key_type == WEP40_ENCRYPTION ||\n\t   key_type == WEP104_ENCRYPTION ||\n\t   vif->type == NL80211_IFTYPE_ADHOC)\n\t\trtlpriv->sec.use_defaultkey = true;\n\n\t \n\tkey_idx = (u8) (key->keyidx);\n\tif (key_idx > 3)\n\t\tgoto out_unlock;\n\t \n\tgroup_key = !(key->flags & IEEE80211_KEY_FLAG_PAIRWISE);\n\n\t \n\t \n\tif (vif->type == NL80211_IFTYPE_AP ||\n\t\tvif->type == NL80211_IFTYPE_MESH_POINT) {\n\t\tif (!group_key || key_type == WEP40_ENCRYPTION ||\n\t\t\tkey_type == WEP104_ENCRYPTION) {\n\t\t\tif (group_key)\n\t\t\t\twep_only = true;\n\t\t\trtlpriv->cfg->ops->enable_hw_sec(hw);\n\t\t}\n\t} else {\n\t\tif (!group_key || vif->type == NL80211_IFTYPE_ADHOC ||\n\t\t    rtlpriv->sec.pairwise_enc_algorithm == NO_ENCRYPTION) {\n\t\t\tif (rtlpriv->sec.pairwise_enc_algorithm ==\n\t\t\t    NO_ENCRYPTION &&\n\t\t\t   (key_type == WEP40_ENCRYPTION ||\n\t\t\t    key_type == WEP104_ENCRYPTION))\n\t\t\t\twep_only = true;\n\t\t\trtlpriv->sec.pairwise_enc_algorithm = key_type;\n\t\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_DMESG,\n\t\t\t\t\"set enable_hw_sec, key_type:%x(OPEN:0 WEP40:1 TKIP:2 AES:4 WEP104:5)\\n\",\n\t\t\t\tkey_type);\n\t\t\trtlpriv->cfg->ops->enable_hw_sec(hw);\n\t\t}\n\t}\n\t \n\tswitch (cmd) {\n\tcase SET_KEY:\n\t\tif (wep_only) {\n\t\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_DMESG,\n\t\t\t\t\"set WEP(group/pairwise) key\\n\");\n\t\t\t \n\t\t\trtlpriv->sec.pairwise_enc_algorithm = key_type;\n\t\t\trtlpriv->sec.group_enc_algorithm = key_type;\n\t\t\t \n\t\t\tmemcpy(rtlpriv->sec.key_buf[key_idx],\n\t\t\t       key->key, key->keylen);\n\t\t\trtlpriv->sec.key_len[key_idx] = key->keylen;\n\t\t\teth_zero_addr(mac_addr);\n\t\t} else if (group_key) {\t \n\t\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_DMESG,\n\t\t\t\t\"set group key\\n\");\n\t\t\t \n\t\t\trtlpriv->sec.group_enc_algorithm = key_type;\n\t\t\t \n\t\t\tmemcpy(rtlpriv->sec.key_buf[key_idx],\n\t\t\t       key->key, key->keylen);\n\t\t\trtlpriv->sec.key_len[key_idx] = key->keylen;\n\t\t\teth_broadcast_addr(mac_addr);\n\t\t} else {\t \n\t\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_DMESG,\n\t\t\t\t\"set pairwise key\\n\");\n\t\t\tif (!sta) {\n\t\t\t\tWARN_ONCE(true,\n\t\t\t\t\t  \"rtlwifi: pairwise key without mac_addr\\n\");\n\n\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\t \n\t\t\trtlpriv->sec.pairwise_enc_algorithm = key_type;\n\t\t\t \n\t\t\tmemcpy(rtlpriv->sec.key_buf[PAIRWISE_KEYIDX],\n\t\t\t       key->key, key->keylen);\n\t\t\trtlpriv->sec.key_len[PAIRWISE_KEYIDX] = key->keylen;\n\t\t\trtlpriv->sec.pairwise_key =\n\t\t\t    rtlpriv->sec.key_buf[PAIRWISE_KEYIDX];\n\t\t\tmemcpy(mac_addr, sta->addr, ETH_ALEN);\n\t\t}\n\t\trtlpriv->cfg->ops->set_key(hw, key_idx, mac_addr,\n\t\t\t\t\t   group_key, key_type, wep_only,\n\t\t\t\t\t   false);\n\t\t \n\t\t \n\t\tkey->flags |= IEEE80211_KEY_FLAG_GENERATE_IV;\n\t\tkey->hw_key_idx = key_idx;\n\t\tif (key_type == TKIP_ENCRYPTION)\n\t\t\tkey->flags |= IEEE80211_KEY_FLAG_GENERATE_MMIC;\n\t\t \n\t\tif (key_type == AESCCMP_ENCRYPTION)\n\t\t\tkey->flags |= IEEE80211_KEY_FLAG_SW_MGMT_TX;\n\t\tbreak;\n\tcase DISABLE_KEY:\n\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_DMESG,\n\t\t\t\"disable key delete one entry\\n\");\n\t\t \n\t\tif (vif->type == NL80211_IFTYPE_AP ||\n\t\t\tvif->type == NL80211_IFTYPE_MESH_POINT) {\n\t\t\tif (sta)\n\t\t\t\trtl_cam_del_entry(hw, sta->addr);\n\t\t}\n\t\tmemset(rtlpriv->sec.key_buf[key_idx], 0, key->keylen);\n\t\trtlpriv->sec.key_len[key_idx] = 0;\n\t\teth_zero_addr(mac_addr);\n\t\t \n\t\trtl_wait_tx_report_acked(hw, 500);  \n\n\t\trtl_cam_delete_one_entry(hw, mac_addr, key_idx);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"cmd_err:%x!!!!:\\n\", cmd);\n\t}\nout_unlock:\n\tmutex_unlock(&rtlpriv->locks.conf_mutex);\n\trtlpriv->sec.being_setkey = false;\n\treturn err;\n}\n\nstatic void rtl_op_rfkill_poll(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\tbool radio_state;\n\tbool blocked;\n\tu8 valid = 0;\n\n\tif (!test_bit(RTL_STATUS_INTERFACE_START, &rtlpriv->status))\n\t\treturn;\n\n\tmutex_lock(&rtlpriv->locks.conf_mutex);\n\n\t \n\tradio_state = rtlpriv->cfg->ops->radio_onoff_checking(hw, &valid);\n\n\tif (valid) {\n\t\tif (unlikely(radio_state != rtlpriv->rfkill.rfkill_state)) {\n\t\t\trtlpriv->rfkill.rfkill_state = radio_state;\n\n\t\t\trtl_dbg(rtlpriv, COMP_RF, DBG_DMESG,\n\t\t\t\t\"wireless radio switch turned %s\\n\",\n\t\t\t\tradio_state ? \"on\" : \"off\");\n\n\t\t\tblocked = !rtlpriv->rfkill.rfkill_state;\n\t\t\twiphy_rfkill_set_hw_state(hw->wiphy, blocked);\n\t\t}\n\t}\n\n\tmutex_unlock(&rtlpriv->locks.conf_mutex);\n}\n\n \nstatic void rtl_op_flush(struct ieee80211_hw *hw,\n\t\t\t struct ieee80211_vif *vif,\n\t\t\t u32 queues,\n\t\t\t bool drop)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\tif (rtlpriv->intf_ops->flush)\n\t\trtlpriv->intf_ops->flush(hw, queues, drop);\n}\n\nstatic int rtl_op_set_tim(struct ieee80211_hw *hw, struct ieee80211_sta *sta,\n\t\t\t  bool set)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\n\tif (rtlhal->hw_type == HARDWARE_TYPE_RTL8192CU)\n\t\tschedule_work(&rtlpriv->works.update_beacon_work);\n\n\treturn 0;\n}\n\n \nbool rtl_hal_pwrseqcmdparsing(struct rtl_priv *rtlpriv, u8 cut_version,\n\t\t\t      u8 faversion, u8 interface_type,\n\t\t\t      struct wlan_pwr_cfg pwrcfgcmd[])\n{\n\tstruct wlan_pwr_cfg cfg_cmd;\n\tbool polling_bit = false;\n\tu32 ary_idx = 0;\n\tu8 value = 0;\n\tu32 offset = 0;\n\tu32 polling_count = 0;\n\tu32 max_polling_cnt = 5000;\n\n\tdo {\n\t\tcfg_cmd = pwrcfgcmd[ary_idx];\n\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\t\"%s: offset(%#x),cut_msk(%#x), famsk(%#x), interface_msk(%#x), base(%#x), cmd(%#x), msk(%#x), value(%#x)\\n\",\n\t\t\t__func__,\n\t\t\tGET_PWR_CFG_OFFSET(cfg_cmd),\n\t\t\t\t\t   GET_PWR_CFG_CUT_MASK(cfg_cmd),\n\t\t\tGET_PWR_CFG_FAB_MASK(cfg_cmd),\n\t\t\t\t\t     GET_PWR_CFG_INTF_MASK(cfg_cmd),\n\t\t\tGET_PWR_CFG_BASE(cfg_cmd), GET_PWR_CFG_CMD(cfg_cmd),\n\t\t\tGET_PWR_CFG_MASK(cfg_cmd), GET_PWR_CFG_VALUE(cfg_cmd));\n\n\t\tif ((GET_PWR_CFG_FAB_MASK(cfg_cmd)&faversion) &&\n\t\t    (GET_PWR_CFG_CUT_MASK(cfg_cmd)&cut_version) &&\n\t\t    (GET_PWR_CFG_INTF_MASK(cfg_cmd)&interface_type)) {\n\t\t\tswitch (GET_PWR_CFG_CMD(cfg_cmd)) {\n\t\t\tcase PWR_CMD_READ:\n\t\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\t\t\t\"rtl_hal_pwrseqcmdparsing(): PWR_CMD_READ\\n\");\n\t\t\t\tbreak;\n\t\t\tcase PWR_CMD_WRITE:\n\t\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\t\t\t\"%s(): PWR_CMD_WRITE\\n\", __func__);\n\t\t\t\toffset = GET_PWR_CFG_OFFSET(cfg_cmd);\n\n\t\t\t\t \n\t\t\t\tvalue = rtl_read_byte(rtlpriv, offset);\n\t\t\t\tvalue &= (~(GET_PWR_CFG_MASK(cfg_cmd)));\n\t\t\t\tvalue |= (GET_PWR_CFG_VALUE(cfg_cmd) &\n\t\t\t\t\t  GET_PWR_CFG_MASK(cfg_cmd));\n\n\t\t\t\t \n\t\t\t\trtl_write_byte(rtlpriv, offset, value);\n\t\t\t\tbreak;\n\t\t\tcase PWR_CMD_POLLING:\n\t\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\t\t\t\"rtl_hal_pwrseqcmdparsing(): PWR_CMD_POLLING\\n\");\n\t\t\t\tpolling_bit = false;\n\t\t\t\toffset = GET_PWR_CFG_OFFSET(cfg_cmd);\n\n\t\t\t\tdo {\n\t\t\t\t\tvalue = rtl_read_byte(rtlpriv, offset);\n\n\t\t\t\t\tvalue &= GET_PWR_CFG_MASK(cfg_cmd);\n\t\t\t\t\tif (value ==\n\t\t\t\t\t    (GET_PWR_CFG_VALUE(cfg_cmd) &\n\t\t\t\t\t     GET_PWR_CFG_MASK(cfg_cmd)))\n\t\t\t\t\t\tpolling_bit = true;\n\t\t\t\t\telse\n\t\t\t\t\t\tudelay(10);\n\n\t\t\t\t\tif (polling_count++ > max_polling_cnt)\n\t\t\t\t\t\treturn false;\n\t\t\t\t} while (!polling_bit);\n\t\t\t\tbreak;\n\t\t\tcase PWR_CMD_DELAY:\n\t\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\t\t\t\"%s: PWR_CMD_DELAY\\n\", __func__);\n\t\t\t\tif (GET_PWR_CFG_VALUE(cfg_cmd) ==\n\t\t\t\t    PWRSEQ_DELAY_US)\n\t\t\t\t\tudelay(GET_PWR_CFG_OFFSET(cfg_cmd));\n\t\t\t\telse\n\t\t\t\t\tmdelay(GET_PWR_CFG_OFFSET(cfg_cmd));\n\t\t\t\tbreak;\n\t\t\tcase PWR_CMD_END:\n\t\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_TRACE,\n\t\t\t\t\t\"%s: PWR_CMD_END\\n\", __func__);\n\t\t\t\treturn true;\n\t\t\tdefault:\n\t\t\t\tWARN_ONCE(true,\n\t\t\t\t\t  \"rtlwifi: rtl_hal_pwrseqcmdparsing(): Unknown CMD!!\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tary_idx++;\n\t} while (1);\n\n\treturn true;\n}\nEXPORT_SYMBOL(rtl_hal_pwrseqcmdparsing);\n\nbool rtl_cmd_send_packet(struct ieee80211_hw *hw, struct sk_buff *skb)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));\n\tstruct rtl8192_tx_ring *ring;\n\tstruct rtl_tx_desc *pdesc;\n\tunsigned long flags;\n\tstruct sk_buff *pskb = NULL;\n\n\tring = &rtlpci->tx_ring[BEACON_QUEUE];\n\n\tspin_lock_irqsave(&rtlpriv->locks.irq_th_lock, flags);\n\tpskb = __skb_dequeue(&ring->queue);\n\tif (pskb)\n\t\tdev_kfree_skb_irq(pskb);\n\n\t \n\tpdesc = &ring->desc[0];\n\n\trtlpriv->cfg->ops->fill_tx_cmddesc(hw, (u8 *)pdesc, 1, 1, skb);\n\n\t__skb_queue_tail(&ring->queue, skb);\n\n\tspin_unlock_irqrestore(&rtlpriv->locks.irq_th_lock, flags);\n\n\trtlpriv->cfg->ops->tx_polling(hw, BEACON_QUEUE);\n\n\treturn true;\n}\nEXPORT_SYMBOL(rtl_cmd_send_packet);\n\nvoid rtl_init_sw_leds(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtlpriv->ledctl.sw_led0 = LED_PIN_LED0;\n\trtlpriv->ledctl.sw_led1 = LED_PIN_LED1;\n}\nEXPORT_SYMBOL(rtl_init_sw_leds);\n\nconst struct ieee80211_ops rtl_ops = {\n\t.start = rtl_op_start,\n\t.stop = rtl_op_stop,\n\t.tx = rtl_op_tx,\n\t.wake_tx_queue = ieee80211_handle_wake_tx_queue,\n\t.add_interface = rtl_op_add_interface,\n\t.remove_interface = rtl_op_remove_interface,\n\t.change_interface = rtl_op_change_interface,\n#ifdef CONFIG_PM\n\t.suspend = rtl_op_suspend,\n\t.resume = rtl_op_resume,\n#endif\n\t.config = rtl_op_config,\n\t.configure_filter = rtl_op_configure_filter,\n\t.set_key = rtl_op_set_key,\n\t.conf_tx = rtl_op_conf_tx,\n\t.bss_info_changed = rtl_op_bss_info_changed,\n\t.get_tsf = rtl_op_get_tsf,\n\t.set_tsf = rtl_op_set_tsf,\n\t.reset_tsf = rtl_op_reset_tsf,\n\t.sta_notify = rtl_op_sta_notify,\n\t.ampdu_action = rtl_op_ampdu_action,\n\t.sw_scan_start = rtl_op_sw_scan_start,\n\t.sw_scan_complete = rtl_op_sw_scan_complete,\n\t.rfkill_poll = rtl_op_rfkill_poll,\n\t.sta_add = rtl_op_sta_add,\n\t.sta_remove = rtl_op_sta_remove,\n\t.flush = rtl_op_flush,\n\t.set_tim = rtl_op_set_tim,\n};\nEXPORT_SYMBOL_GPL(rtl_ops);\n\nbool rtl_btc_status_false(void)\n{\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(rtl_btc_status_false);\n\nvoid rtl_dm_diginit(struct ieee80211_hw *hw, u32 cur_igvalue)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct dig_t *dm_digtable = &rtlpriv->dm_digtable;\n\n\tdm_digtable->dig_enable_flag = true;\n\tdm_digtable->dig_ext_port_stage = DIG_EXT_PORT_STAGE_MAX;\n\tdm_digtable->cur_igvalue = cur_igvalue;\n\tdm_digtable->pre_igvalue = 0;\n\tdm_digtable->cur_sta_cstate = DIG_STA_DISCONNECT;\n\tdm_digtable->presta_cstate = DIG_STA_DISCONNECT;\n\tdm_digtable->curmultista_cstate = DIG_MULTISTA_DISCONNECT;\n\tdm_digtable->rssi_lowthresh = DM_DIG_THRESH_LOW;\n\tdm_digtable->rssi_highthresh = DM_DIG_THRESH_HIGH;\n\tdm_digtable->fa_lowthresh = DM_FALSEALARM_THRESH_LOW;\n\tdm_digtable->fa_highthresh = DM_FALSEALARM_THRESH_HIGH;\n\tdm_digtable->rx_gain_max = DM_DIG_MAX;\n\tdm_digtable->rx_gain_min = DM_DIG_MIN;\n\tdm_digtable->back_val = DM_DIG_BACKOFF_DEFAULT;\n\tdm_digtable->back_range_max = DM_DIG_BACKOFF_MAX;\n\tdm_digtable->back_range_min = DM_DIG_BACKOFF_MIN;\n\tdm_digtable->pre_cck_cca_thres = 0xff;\n\tdm_digtable->cur_cck_cca_thres = 0x83;\n\tdm_digtable->forbidden_igi = DM_DIG_MIN;\n\tdm_digtable->large_fa_hit = 0;\n\tdm_digtable->recover_cnt = 0;\n\tdm_digtable->dig_min_0 = 0x25;\n\tdm_digtable->dig_min_1 = 0x25;\n\tdm_digtable->media_connect_0 = false;\n\tdm_digtable->media_connect_1 = false;\n\trtlpriv->dm.dm_initialgain_enable = true;\n\tdm_digtable->bt30_cur_igi = 0x32;\n\tdm_digtable->pre_cck_pd_state = CCK_PD_STAGE_MAX;\n\tdm_digtable->cur_cck_pd_state = CCK_PD_STAGE_LOWRSSI;\n\tdm_digtable->pre_cck_fa_state = 0;\n\tdm_digtable->cur_cck_fa_state = 0;\n}\nEXPORT_SYMBOL(rtl_dm_diginit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}