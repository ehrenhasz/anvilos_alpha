{
  "module_name": "base.c",
  "hash_id": "a3f73c84022c479cc0cb93c7c90fa005b05dea67b25adcbd6949483d21c169e0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/realtek/rtlwifi/base.c",
  "human_readable_source": "\n \n\n#include \"wifi.h\"\n#include \"rc.h\"\n#include \"base.h\"\n#include \"efuse.h\"\n#include \"cam.h\"\n#include \"ps.h\"\n#include \"regd.h\"\n#include \"pci.h\"\n#include <linux/ip.h>\n#include <linux/module.h>\n#include <linux/udp.h>\n\n \n\n \nstatic struct ieee80211_channel rtl_channeltable_2g[] = {\n\t{.center_freq = 2412, .hw_value = 1,},\n\t{.center_freq = 2417, .hw_value = 2,},\n\t{.center_freq = 2422, .hw_value = 3,},\n\t{.center_freq = 2427, .hw_value = 4,},\n\t{.center_freq = 2432, .hw_value = 5,},\n\t{.center_freq = 2437, .hw_value = 6,},\n\t{.center_freq = 2442, .hw_value = 7,},\n\t{.center_freq = 2447, .hw_value = 8,},\n\t{.center_freq = 2452, .hw_value = 9,},\n\t{.center_freq = 2457, .hw_value = 10,},\n\t{.center_freq = 2462, .hw_value = 11,},\n\t{.center_freq = 2467, .hw_value = 12,},\n\t{.center_freq = 2472, .hw_value = 13,},\n\t{.center_freq = 2484, .hw_value = 14,},\n};\n\nstatic struct ieee80211_channel rtl_channeltable_5g[] = {\n\t{.center_freq = 5180, .hw_value = 36,},\n\t{.center_freq = 5200, .hw_value = 40,},\n\t{.center_freq = 5220, .hw_value = 44,},\n\t{.center_freq = 5240, .hw_value = 48,},\n\t{.center_freq = 5260, .hw_value = 52,},\n\t{.center_freq = 5280, .hw_value = 56,},\n\t{.center_freq = 5300, .hw_value = 60,},\n\t{.center_freq = 5320, .hw_value = 64,},\n\t{.center_freq = 5500, .hw_value = 100,},\n\t{.center_freq = 5520, .hw_value = 104,},\n\t{.center_freq = 5540, .hw_value = 108,},\n\t{.center_freq = 5560, .hw_value = 112,},\n\t{.center_freq = 5580, .hw_value = 116,},\n\t{.center_freq = 5600, .hw_value = 120,},\n\t{.center_freq = 5620, .hw_value = 124,},\n\t{.center_freq = 5640, .hw_value = 128,},\n\t{.center_freq = 5660, .hw_value = 132,},\n\t{.center_freq = 5680, .hw_value = 136,},\n\t{.center_freq = 5700, .hw_value = 140,},\n\t{.center_freq = 5745, .hw_value = 149,},\n\t{.center_freq = 5765, .hw_value = 153,},\n\t{.center_freq = 5785, .hw_value = 157,},\n\t{.center_freq = 5805, .hw_value = 161,},\n\t{.center_freq = 5825, .hw_value = 165,},\n};\n\nstatic struct ieee80211_rate rtl_ratetable_2g[] = {\n\t{.bitrate = 10, .hw_value = 0x00,},\n\t{.bitrate = 20, .hw_value = 0x01,},\n\t{.bitrate = 55, .hw_value = 0x02,},\n\t{.bitrate = 110, .hw_value = 0x03,},\n\t{.bitrate = 60, .hw_value = 0x04,},\n\t{.bitrate = 90, .hw_value = 0x05,},\n\t{.bitrate = 120, .hw_value = 0x06,},\n\t{.bitrate = 180, .hw_value = 0x07,},\n\t{.bitrate = 240, .hw_value = 0x08,},\n\t{.bitrate = 360, .hw_value = 0x09,},\n\t{.bitrate = 480, .hw_value = 0x0a,},\n\t{.bitrate = 540, .hw_value = 0x0b,},\n};\n\nstatic struct ieee80211_rate rtl_ratetable_5g[] = {\n\t{.bitrate = 60, .hw_value = 0x04,},\n\t{.bitrate = 90, .hw_value = 0x05,},\n\t{.bitrate = 120, .hw_value = 0x06,},\n\t{.bitrate = 180, .hw_value = 0x07,},\n\t{.bitrate = 240, .hw_value = 0x08,},\n\t{.bitrate = 360, .hw_value = 0x09,},\n\t{.bitrate = 480, .hw_value = 0x0a,},\n\t{.bitrate = 540, .hw_value = 0x0b,},\n};\n\nstatic const struct ieee80211_supported_band rtl_band_2ghz = {\n\t.band = NL80211_BAND_2GHZ,\n\n\t.channels = rtl_channeltable_2g,\n\t.n_channels = ARRAY_SIZE(rtl_channeltable_2g),\n\n\t.bitrates = rtl_ratetable_2g,\n\t.n_bitrates = ARRAY_SIZE(rtl_ratetable_2g),\n\n\t.ht_cap = {0},\n};\n\nstatic struct ieee80211_supported_band rtl_band_5ghz = {\n\t.band = NL80211_BAND_5GHZ,\n\n\t.channels = rtl_channeltable_5g,\n\t.n_channels = ARRAY_SIZE(rtl_channeltable_5g),\n\n\t.bitrates = rtl_ratetable_5g,\n\t.n_bitrates = ARRAY_SIZE(rtl_ratetable_5g),\n\n\t.ht_cap = {0},\n};\n\nstatic const u8 tid_to_ac[] = {\n\t2,  \n\t3,  \n\t3,  \n\t2,  \n\t1,  \n\t1,  \n\t0,  \n\t0,  \n};\n\nu8 rtl_tid_to_ac(u8 tid)\n{\n\treturn tid_to_ac[tid];\n}\nEXPORT_SYMBOL_GPL(rtl_tid_to_ac);\n\nstatic void _rtl_init_hw_ht_capab(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_sta_ht_cap *ht_cap)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\n\tht_cap->ht_supported = true;\n\tht_cap->cap = IEEE80211_HT_CAP_SUP_WIDTH_20_40 |\n\t    IEEE80211_HT_CAP_SGI_40 |\n\t    IEEE80211_HT_CAP_SGI_20 |\n\t    IEEE80211_HT_CAP_DSSSCCK40 | IEEE80211_HT_CAP_MAX_AMSDU;\n\n\tif (rtlpriv->rtlhal.disable_amsdu_8k)\n\t\tht_cap->cap &= ~IEEE80211_HT_CAP_MAX_AMSDU;\n\n\t \n\tht_cap->ampdu_factor = IEEE80211_HT_MAX_AMPDU_64K;\n\n\t \n\tht_cap->ampdu_density = IEEE80211_HT_MPDU_DENSITY_16;\n\n\tht_cap->mcs.tx_params = IEEE80211_HT_MCS_TX_DEFINED;\n\n\t \n\tif (rtlpriv->dm.supp_phymode_switch) {\n\t\tpr_info(\"Support phy mode switch\\n\");\n\n\t\tht_cap->mcs.rx_mask[0] = 0xFF;\n\t\tht_cap->mcs.rx_mask[1] = 0xFF;\n\t\tht_cap->mcs.rx_mask[4] = 0x01;\n\n\t\tht_cap->mcs.rx_highest = cpu_to_le16(MAX_BIT_RATE_40MHZ_MCS15);\n\t} else {\n\t\tif (get_rf_type(rtlphy) == RF_1T2R ||\n\t\t    get_rf_type(rtlphy) == RF_2T2R) {\n\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG,\n\t\t\t\t\"1T2R or 2T2R\\n\");\n\t\t\tht_cap->mcs.rx_mask[0] = 0xFF;\n\t\t\tht_cap->mcs.rx_mask[1] = 0xFF;\n\t\t\tht_cap->mcs.rx_mask[4] = 0x01;\n\n\t\t\tht_cap->mcs.rx_highest =\n\t\t\t\t cpu_to_le16(MAX_BIT_RATE_40MHZ_MCS15);\n\t\t} else if (get_rf_type(rtlphy) == RF_1T1R) {\n\t\t\trtl_dbg(rtlpriv, COMP_INIT, DBG_DMESG, \"1T1R\\n\");\n\n\t\t\tht_cap->mcs.rx_mask[0] = 0xFF;\n\t\t\tht_cap->mcs.rx_mask[1] = 0x00;\n\t\t\tht_cap->mcs.rx_mask[4] = 0x01;\n\n\t\t\tht_cap->mcs.rx_highest =\n\t\t\t\t cpu_to_le16(MAX_BIT_RATE_40MHZ_MCS7);\n\t\t}\n\t}\n}\n\nstatic void _rtl_init_hw_vht_capab(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_sta_vht_cap *vht_cap)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\n\n\tif (!(rtlpriv->cfg->spec_ver & RTL_SPEC_SUPPORT_VHT))\n\t\treturn;\n\n\tif (rtlhal->hw_type == HARDWARE_TYPE_RTL8812AE ||\n\t    rtlhal->hw_type == HARDWARE_TYPE_RTL8822BE) {\n\t\tu16 mcs_map;\n\n\t\tvht_cap->vht_supported = true;\n\t\tvht_cap->cap =\n\t\t\tIEEE80211_VHT_CAP_MAX_MPDU_LENGTH_11454 |\n\t\t\tIEEE80211_VHT_CAP_SHORT_GI_80 |\n\t\t\tIEEE80211_VHT_CAP_TXSTBC |\n\t\t\tIEEE80211_VHT_CAP_RXSTBC_1 |\n\t\t\tIEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE |\n\t\t\tIEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE |\n\t\t\tIEEE80211_VHT_CAP_HTC_VHT |\n\t\t\tIEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK |\n\t\t\tIEEE80211_VHT_CAP_RX_ANTENNA_PATTERN |\n\t\t\tIEEE80211_VHT_CAP_TX_ANTENNA_PATTERN |\n\t\t\t0;\n\n\t\tmcs_map = IEEE80211_VHT_MCS_SUPPORT_0_9 << 0 |\n\t\t\tIEEE80211_VHT_MCS_SUPPORT_0_9 << 2 |\n\t\t\tIEEE80211_VHT_MCS_NOT_SUPPORTED << 4 |\n\t\t\tIEEE80211_VHT_MCS_NOT_SUPPORTED << 6 |\n\t\t\tIEEE80211_VHT_MCS_NOT_SUPPORTED << 8 |\n\t\t\tIEEE80211_VHT_MCS_NOT_SUPPORTED << 10 |\n\t\t\tIEEE80211_VHT_MCS_NOT_SUPPORTED << 12 |\n\t\t\tIEEE80211_VHT_MCS_NOT_SUPPORTED << 14;\n\n\t\tvht_cap->vht_mcs.rx_mcs_map = cpu_to_le16(mcs_map);\n\t\tvht_cap->vht_mcs.rx_highest =\n\t\t\tcpu_to_le16(MAX_BIT_RATE_SHORT_GI_2NSS_80MHZ_MCS9);\n\t\tvht_cap->vht_mcs.tx_mcs_map = cpu_to_le16(mcs_map);\n\t\tvht_cap->vht_mcs.tx_highest =\n\t\t\tcpu_to_le16(MAX_BIT_RATE_SHORT_GI_2NSS_80MHZ_MCS9);\n\t} else if (rtlhal->hw_type == HARDWARE_TYPE_RTL8821AE) {\n\t\tu16 mcs_map;\n\n\t\tvht_cap->vht_supported = true;\n\t\tvht_cap->cap =\n\t\t\tIEEE80211_VHT_CAP_MAX_MPDU_LENGTH_11454 |\n\t\t\tIEEE80211_VHT_CAP_SHORT_GI_80 |\n\t\t\tIEEE80211_VHT_CAP_TXSTBC |\n\t\t\tIEEE80211_VHT_CAP_RXSTBC_1 |\n\t\t\tIEEE80211_VHT_CAP_SU_BEAMFORMER_CAPABLE |\n\t\t\tIEEE80211_VHT_CAP_SU_BEAMFORMEE_CAPABLE |\n\t\t\tIEEE80211_VHT_CAP_HTC_VHT |\n\t\t\tIEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK |\n\t\t\tIEEE80211_VHT_CAP_RX_ANTENNA_PATTERN |\n\t\t\tIEEE80211_VHT_CAP_TX_ANTENNA_PATTERN |\n\t\t\t0;\n\n\t\tmcs_map = IEEE80211_VHT_MCS_SUPPORT_0_9 << 0 |\n\t\t\tIEEE80211_VHT_MCS_NOT_SUPPORTED << 2 |\n\t\t\tIEEE80211_VHT_MCS_NOT_SUPPORTED << 4 |\n\t\t\tIEEE80211_VHT_MCS_NOT_SUPPORTED << 6 |\n\t\t\tIEEE80211_VHT_MCS_NOT_SUPPORTED << 8 |\n\t\t\tIEEE80211_VHT_MCS_NOT_SUPPORTED << 10 |\n\t\t\tIEEE80211_VHT_MCS_NOT_SUPPORTED << 12 |\n\t\t\tIEEE80211_VHT_MCS_NOT_SUPPORTED << 14;\n\n\t\tvht_cap->vht_mcs.rx_mcs_map = cpu_to_le16(mcs_map);\n\t\tvht_cap->vht_mcs.rx_highest =\n\t\t\tcpu_to_le16(MAX_BIT_RATE_SHORT_GI_1NSS_80MHZ_MCS9);\n\t\tvht_cap->vht_mcs.tx_mcs_map = cpu_to_le16(mcs_map);\n\t\tvht_cap->vht_mcs.tx_highest =\n\t\t\tcpu_to_le16(MAX_BIT_RATE_SHORT_GI_1NSS_80MHZ_MCS9);\n\t}\n}\n\nstatic void _rtl_init_mac80211(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtlpriv);\n\tstruct rtl_mac *rtlmac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tstruct ieee80211_supported_band *sband;\n\n\tif (rtlhal->macphymode == SINGLEMAC_SINGLEPHY &&\n\t    rtlhal->bandset == BAND_ON_BOTH) {\n\t\t \n\t\t \n\t\tsband = &(rtlmac->bands[NL80211_BAND_2GHZ]);\n\n\t\t \n\t\tmemcpy(&(rtlmac->bands[NL80211_BAND_2GHZ]), &rtl_band_2ghz,\n\t\t\t\tsizeof(struct ieee80211_supported_band));\n\n\t\t \n\t\t_rtl_init_hw_ht_capab(hw, &sband->ht_cap);\n\n\t\t \n\t\thw->wiphy->bands[NL80211_BAND_2GHZ] = sband;\n\n\t\t \n\t\t \n\t\tsband = &(rtlmac->bands[NL80211_BAND_5GHZ]);\n\n\t\t \n\t\tmemcpy(&(rtlmac->bands[NL80211_BAND_5GHZ]), &rtl_band_5ghz,\n\t\t\t\tsizeof(struct ieee80211_supported_band));\n\n\t\t \n\t\t_rtl_init_hw_ht_capab(hw, &sband->ht_cap);\n\n\t\t_rtl_init_hw_vht_capab(hw, &sband->vht_cap);\n\t\t \n\t\thw->wiphy->bands[NL80211_BAND_5GHZ] = sband;\n\t} else {\n\t\tif (rtlhal->current_bandtype == BAND_ON_2_4G) {\n\t\t\t \n\t\t\tsband = &(rtlmac->bands[NL80211_BAND_2GHZ]);\n\n\t\t\t \n\t\t\tmemcpy(&(rtlmac->bands[NL80211_BAND_2GHZ]),\n\t\t\t       &rtl_band_2ghz,\n\t\t\t       sizeof(struct ieee80211_supported_band));\n\n\t\t\t \n\t\t\t_rtl_init_hw_ht_capab(hw, &sband->ht_cap);\n\n\t\t\t \n\t\t\thw->wiphy->bands[NL80211_BAND_2GHZ] = sband;\n\t\t} else if (rtlhal->current_bandtype == BAND_ON_5G) {\n\t\t\t \n\t\t\tsband = &(rtlmac->bands[NL80211_BAND_5GHZ]);\n\n\t\t\t \n\t\t\tmemcpy(&(rtlmac->bands[NL80211_BAND_5GHZ]),\n\t\t\t       &rtl_band_5ghz,\n\t\t\t       sizeof(struct ieee80211_supported_band));\n\n\t\t\t \n\t\t\t_rtl_init_hw_ht_capab(hw, &sband->ht_cap);\n\n\t\t\t_rtl_init_hw_vht_capab(hw, &sband->vht_cap);\n\t\t\t \n\t\t\thw->wiphy->bands[NL80211_BAND_5GHZ] = sband;\n\t\t} else {\n\t\t\tpr_err(\"Err BAND %d\\n\",\n\t\t\t       rtlhal->current_bandtype);\n\t\t}\n\t}\n\t \n\tieee80211_hw_set(hw, SIGNAL_DBM);\n\tieee80211_hw_set(hw, RX_INCLUDES_FCS);\n\tieee80211_hw_set(hw, AMPDU_AGGREGATION);\n\tieee80211_hw_set(hw, MFP_CAPABLE);\n\tieee80211_hw_set(hw, REPORTS_TX_ACK_STATUS);\n\tieee80211_hw_set(hw, SUPPORTS_AMSDU_IN_AMPDU);\n\tieee80211_hw_set(hw, SUPPORT_FAST_XMIT);\n\n\t \n\tif (rtlpriv->psc.swctrl_lps) {\n\t\tieee80211_hw_set(hw, SUPPORTS_PS);\n\t\tieee80211_hw_set(hw, PS_NULLFUNC_STACK);\n\t}\n\tif (rtlpriv->psc.fwctrl_lps) {\n\t\tieee80211_hw_set(hw, SUPPORTS_PS);\n\t\tieee80211_hw_set(hw, SUPPORTS_DYNAMIC_PS);\n\t}\n\thw->wiphy->interface_modes =\n\t    BIT(NL80211_IFTYPE_AP) |\n\t    BIT(NL80211_IFTYPE_STATION) |\n\t    BIT(NL80211_IFTYPE_ADHOC) |\n\t    BIT(NL80211_IFTYPE_MESH_POINT) |\n\t    BIT(NL80211_IFTYPE_P2P_CLIENT) |\n\t    BIT(NL80211_IFTYPE_P2P_GO);\n\thw->wiphy->flags |= WIPHY_FLAG_IBSS_RSN;\n\n\thw->wiphy->flags |= WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;\n\n\thw->wiphy->rts_threshold = 2347;\n\n\thw->queues = AC_MAX;\n\thw->extra_tx_headroom = RTL_TX_HEADER_SIZE;\n\n\t \n\thw->max_listen_interval = MAX_LISTEN_INTERVAL;\n\thw->max_rate_tries = MAX_RATE_TRIES;\n\t \n\thw->sta_data_size = sizeof(struct rtl_sta_info);\n\n \n#ifdef CONFIG_PM\n\tif (rtlpriv->psc.wo_wlan_mode) {\n\t\tif (rtlpriv->psc.wo_wlan_mode & WAKE_ON_MAGIC_PACKET)\n\t\t\trtlpriv->wowlan.flags = WIPHY_WOWLAN_MAGIC_PKT;\n\t\tif (rtlpriv->psc.wo_wlan_mode & WAKE_ON_PATTERN_MATCH) {\n\t\t\trtlpriv->wowlan.n_patterns =\n\t\t\t\tMAX_SUPPORT_WOL_PATTERN_NUM;\n\t\t\trtlpriv->wowlan.pattern_min_len = MIN_WOL_PATTERN_SIZE;\n\t\t\trtlpriv->wowlan.pattern_max_len = MAX_WOL_PATTERN_SIZE;\n\t\t}\n\t\thw->wiphy->wowlan = &rtlpriv->wowlan;\n\t}\n#endif\n\n\t \n\tif (is_valid_ether_addr(rtlefuse->dev_addr)) {\n\t\tSET_IEEE80211_PERM_ADDR(hw, rtlefuse->dev_addr);\n\t} else {\n\t\tu8 rtlmac1[] = { 0x00, 0xe0, 0x4c, 0x81, 0x92, 0x00 };\n\n\t\tget_random_bytes((rtlmac1 + (ETH_ALEN - 1)), 1);\n\t\tSET_IEEE80211_PERM_ADDR(hw, rtlmac1);\n\t}\n}\n\nstatic void rtl_watchdog_wq_callback(struct work_struct *work);\nstatic void rtl_fwevt_wq_callback(struct work_struct *work);\nstatic void rtl_c2hcmd_wq_callback(struct work_struct *work);\n\nstatic int _rtl_init_deferred_work(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct workqueue_struct *wq;\n\n\twq = alloc_workqueue(\"%s\", 0, 0, rtlpriv->cfg->name);\n\tif (!wq)\n\t\treturn -ENOMEM;\n\n\t \n\ttimer_setup(&rtlpriv->works.watchdog_timer,\n\t\t    rtl_watch_dog_timer_callback, 0);\n\n\t \n\trtlpriv->works.hw = hw;\n\trtlpriv->works.rtl_wq = wq;\n\n\tINIT_DELAYED_WORK(&rtlpriv->works.watchdog_wq,\n\t\t\t  rtl_watchdog_wq_callback);\n\tINIT_DELAYED_WORK(&rtlpriv->works.ips_nic_off_wq,\n\t\t\t  rtl_ips_nic_off_wq_callback);\n\tINIT_DELAYED_WORK(&rtlpriv->works.ps_work, rtl_swlps_wq_callback);\n\tINIT_DELAYED_WORK(&rtlpriv->works.ps_rfon_wq,\n\t\t\t  rtl_swlps_rfon_wq_callback);\n\tINIT_DELAYED_WORK(&rtlpriv->works.fwevt_wq, rtl_fwevt_wq_callback);\n\tINIT_DELAYED_WORK(&rtlpriv->works.c2hcmd_wq, rtl_c2hcmd_wq_callback);\n\treturn 0;\n}\n\nvoid rtl_deinit_deferred_work(struct ieee80211_hw *hw, bool ips_wq)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\tdel_timer_sync(&rtlpriv->works.watchdog_timer);\n\n\tcancel_delayed_work_sync(&rtlpriv->works.watchdog_wq);\n\tif (ips_wq)\n\t\tcancel_delayed_work(&rtlpriv->works.ips_nic_off_wq);\n\telse\n\t\tcancel_delayed_work_sync(&rtlpriv->works.ips_nic_off_wq);\n\tcancel_delayed_work_sync(&rtlpriv->works.ps_work);\n\tcancel_delayed_work_sync(&rtlpriv->works.ps_rfon_wq);\n\tcancel_delayed_work_sync(&rtlpriv->works.fwevt_wq);\n\tcancel_delayed_work_sync(&rtlpriv->works.c2hcmd_wq);\n}\nEXPORT_SYMBOL_GPL(rtl_deinit_deferred_work);\n\nvoid rtl_init_rfkill(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\tbool radio_state;\n\tbool blocked;\n\tu8 valid = 0;\n\n\t \n\trtlpriv->rfkill.rfkill_state = true;\n\twiphy_rfkill_set_hw_state(hw->wiphy, 0);\n\n\tradio_state = rtlpriv->cfg->ops->radio_onoff_checking(hw, &valid);\n\n\tif (valid) {\n\t\tpr_info(\"rtlwifi: wireless switch is %s\\n\",\n\t\t\trtlpriv->rfkill.rfkill_state ? \"on\" : \"off\");\n\n\t\trtlpriv->rfkill.rfkill_state = radio_state;\n\n\t\tblocked = rtlpriv->rfkill.rfkill_state != 1;\n\t\twiphy_rfkill_set_hw_state(hw->wiphy, blocked);\n\t}\n\n\twiphy_rfkill_start_polling(hw->wiphy);\n}\nEXPORT_SYMBOL(rtl_init_rfkill);\n\nvoid rtl_deinit_rfkill(struct ieee80211_hw *hw)\n{\n\twiphy_rfkill_stop_polling(hw->wiphy);\n}\nEXPORT_SYMBOL_GPL(rtl_deinit_rfkill);\n\nint rtl_init_core(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *rtlmac = rtl_mac(rtl_priv(hw));\n\n\t \n\t_rtl_init_mac80211(hw);\n\trtlmac->hw = hw;\n\n\t \n\thw->rate_control_algorithm = \"rtl_rc\";\n\n\t \n\tif (rtl_regd_init(hw, rtl_reg_notifier)) {\n\t\tpr_err(\"REGD init failed\\n\");\n\t\treturn 1;\n\t}\n\n\t \n\tmutex_init(&rtlpriv->locks.conf_mutex);\n\tmutex_init(&rtlpriv->locks.ips_mutex);\n\tmutex_init(&rtlpriv->locks.lps_mutex);\n\tspin_lock_init(&rtlpriv->locks.irq_th_lock);\n\tspin_lock_init(&rtlpriv->locks.h2c_lock);\n\tspin_lock_init(&rtlpriv->locks.rf_ps_lock);\n\tspin_lock_init(&rtlpriv->locks.rf_lock);\n\tspin_lock_init(&rtlpriv->locks.waitq_lock);\n\tspin_lock_init(&rtlpriv->locks.entry_list_lock);\n\tspin_lock_init(&rtlpriv->locks.scan_list_lock);\n\tspin_lock_init(&rtlpriv->locks.cck_and_rw_pagea_lock);\n\tspin_lock_init(&rtlpriv->locks.fw_ps_lock);\n\tspin_lock_init(&rtlpriv->locks.iqk_lock);\n\t \n\tINIT_LIST_HEAD(&rtlpriv->entry_list);\n\tINIT_LIST_HEAD(&rtlpriv->scan_list.list);\n\tskb_queue_head_init(&rtlpriv->tx_report.queue);\n\tskb_queue_head_init(&rtlpriv->c2hcmd_queue);\n\n\trtlmac->link_state = MAC80211_NOLINK;\n\n\t \n\treturn _rtl_init_deferred_work(hw);\n}\nEXPORT_SYMBOL_GPL(rtl_init_core);\n\nstatic void rtl_free_entries_from_scan_list(struct ieee80211_hw *hw);\nstatic void rtl_free_entries_from_ack_queue(struct ieee80211_hw *hw,\n\t\t\t\t\t    bool timeout);\n\nvoid rtl_deinit_core(struct ieee80211_hw *hw)\n{\n\trtl_c2hcmd_launcher(hw, 0);\n\trtl_free_entries_from_scan_list(hw);\n\trtl_free_entries_from_ack_queue(hw, false);\n}\nEXPORT_SYMBOL_GPL(rtl_deinit_core);\n\nvoid rtl_init_rx_config(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\n\trtlpriv->cfg->ops->get_hw_reg(hw, HW_VAR_RCR, (u8 *) (&mac->rx_conf));\n}\nEXPORT_SYMBOL_GPL(rtl_init_rx_config);\n\n \nstatic void _rtl_qurey_shortpreamble_mode(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct rtl_tcb_desc *tcb_desc,\n\t\t\t\t\t  struct ieee80211_tx_info *info)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 rate_flag = info->control.rates[0].flags;\n\n\ttcb_desc->use_shortpreamble = false;\n\n\t \n\tif (tcb_desc->hw_rate == rtlpriv->cfg->maps[RTL_RC_CCK_RATE1M])\n\t\treturn;\n\telse if (rate_flag & IEEE80211_TX_RC_USE_SHORT_PREAMBLE)\n\t\ttcb_desc->use_shortpreamble = true;\n\n\treturn;\n}\n\nstatic void _rtl_query_shortgi(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_sta *sta,\n\t\t\t       struct rtl_tcb_desc *tcb_desc,\n\t\t\t       struct ieee80211_tx_info *info)\n{\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tu8 rate_flag = info->control.rates[0].flags;\n\tu8 sgi_40 = 0, sgi_20 = 0, bw_40 = 0;\n\tu8 sgi_80 = 0, bw_80 = 0;\n\n\ttcb_desc->use_shortgi = false;\n\n\tif (sta == NULL)\n\t\treturn;\n\n\tsgi_40 = sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_SGI_40;\n\tsgi_20 = sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_SGI_20;\n\tsgi_80 = sta->deflink.vht_cap.cap & IEEE80211_VHT_CAP_SHORT_GI_80;\n\n\tif (!sta->deflink.ht_cap.ht_supported &&\n\t    !sta->deflink.vht_cap.vht_supported)\n\t\treturn;\n\n\tif (!sgi_40 && !sgi_20)\n\t\treturn;\n\n\tif (mac->opmode == NL80211_IFTYPE_STATION) {\n\t\tbw_40 = mac->bw_40;\n\t\tbw_80 = mac->bw_80;\n\t} else if (mac->opmode == NL80211_IFTYPE_AP ||\n\t\t mac->opmode == NL80211_IFTYPE_ADHOC ||\n\t\t mac->opmode == NL80211_IFTYPE_MESH_POINT) {\n\t\tbw_40 = sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40;\n\t\tbw_80 = sta->deflink.vht_cap.vht_supported;\n\t}\n\n\tif (bw_80) {\n\t\tif (sgi_80)\n\t\t\ttcb_desc->use_shortgi = true;\n\t\telse\n\t\t\ttcb_desc->use_shortgi = false;\n\t} else {\n\t\tif (bw_40 && sgi_40)\n\t\t\ttcb_desc->use_shortgi = true;\n\t\telse if (!bw_40 && sgi_20)\n\t\t\ttcb_desc->use_shortgi = true;\n\t}\n\n\tif (!(rate_flag & IEEE80211_TX_RC_SHORT_GI))\n\t\ttcb_desc->use_shortgi = false;\n}\n\nstatic void _rtl_query_protection_mode(struct ieee80211_hw *hw,\n\t\t\t\t       struct rtl_tcb_desc *tcb_desc,\n\t\t\t\t       struct ieee80211_tx_info *info)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 rate_flag = info->control.rates[0].flags;\n\n\t \n\ttcb_desc->rts_stbc = false;\n\ttcb_desc->cts_enable = false;\n\ttcb_desc->rts_sc = 0;\n\ttcb_desc->rts_bw = false;\n\ttcb_desc->rts_use_shortpreamble = false;\n\ttcb_desc->rts_use_shortgi = false;\n\n\tif (rate_flag & IEEE80211_TX_RC_USE_CTS_PROTECT) {\n\t\t \n\t\ttcb_desc->rts_enable = true;\n\t\ttcb_desc->cts_enable = true;\n\t\ttcb_desc->rts_rate = rtlpriv->cfg->maps[RTL_RC_OFDM_RATE24M];\n\t} else if (rate_flag & IEEE80211_TX_RC_USE_RTS_CTS) {\n\t\t \n\t\ttcb_desc->rts_enable = true;\n\t\ttcb_desc->rts_rate = rtlpriv->cfg->maps[RTL_RC_OFDM_RATE24M];\n\t}\n}\n\nu8 rtl_mrate_idx_to_arfr_id(struct ieee80211_hw *hw, u8 rate_index,\n\t\t\t    enum wireless_mode wirelessmode)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\tu8 ret = 0;\n\n\tswitch (rate_index) {\n\tcase RATR_INX_WIRELESS_NGB:\n\t\tif (rtlphy->rf_type == RF_1T1R)\n\t\t\tret = RATEID_IDX_BGN_40M_1SS;\n\t\telse\n\t\t\tret = RATEID_IDX_BGN_40M_2SS;\n\t\t; break;\n\tcase RATR_INX_WIRELESS_N:\n\tcase RATR_INX_WIRELESS_NG:\n\t\tif (rtlphy->rf_type == RF_1T1R)\n\t\t\tret = RATEID_IDX_GN_N1SS;\n\t\telse\n\t\t\tret = RATEID_IDX_GN_N2SS;\n\t\t; break;\n\tcase RATR_INX_WIRELESS_NB:\n\t\tif (rtlphy->rf_type == RF_1T1R)\n\t\t\tret = RATEID_IDX_BGN_20M_1SS_BN;\n\t\telse\n\t\t\tret = RATEID_IDX_BGN_20M_2SS_BN;\n\t\t; break;\n\tcase RATR_INX_WIRELESS_GB:\n\t\tret = RATEID_IDX_BG;\n\t\tbreak;\n\tcase RATR_INX_WIRELESS_G:\n\t\tret = RATEID_IDX_G;\n\t\tbreak;\n\tcase RATR_INX_WIRELESS_B:\n\t\tret = RATEID_IDX_B;\n\t\tbreak;\n\tcase RATR_INX_WIRELESS_MC:\n\t\tif (wirelessmode == WIRELESS_MODE_B ||\n\t\t    wirelessmode == WIRELESS_MODE_G ||\n\t\t    wirelessmode == WIRELESS_MODE_N_24G ||\n\t\t    wirelessmode == WIRELESS_MODE_AC_24G)\n\t\t\tret = RATEID_IDX_BG;\n\t\telse\n\t\t\tret = RATEID_IDX_G;\n\t\tbreak;\n\tcase RATR_INX_WIRELESS_AC_5N:\n\t\tif (rtlphy->rf_type == RF_1T1R)\n\t\t\tret = RATEID_IDX_VHT_1SS;\n\t\telse\n\t\t\tret = RATEID_IDX_VHT_2SS;\n\t\tbreak;\n\tcase RATR_INX_WIRELESS_AC_24N:\n\t\tif (rtlphy->current_chan_bw == HT_CHANNEL_WIDTH_80) {\n\t\t\tif (rtlphy->rf_type == RF_1T1R)\n\t\t\t\tret = RATEID_IDX_VHT_1SS;\n\t\t\telse\n\t\t\t\tret = RATEID_IDX_VHT_2SS;\n\t\t} else {\n\t\t\tif (rtlphy->rf_type == RF_1T1R)\n\t\t\t\tret = RATEID_IDX_MIX1;\n\t\t\telse\n\t\t\t\tret = RATEID_IDX_MIX2;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tret = RATEID_IDX_BGN_40M_2SS;\n\t\tbreak;\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL(rtl_mrate_idx_to_arfr_id);\n\nstatic void _rtl_txrate_selectmode(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_sta *sta,\n\t\t\t\t   struct rtl_tcb_desc *tcb_desc)\n{\n#define SET_RATE_ID(rate_id)\t\t\t\t\t\\\n\t({typeof(rate_id) _id = rate_id;\t\t\t\\\n\t  ((rtlpriv->cfg->spec_ver & RTL_SPEC_NEW_RATEID) ?\t\\\n\t\trtl_mrate_idx_to_arfr_id(hw, _id,\t\t\\\n\t\t\t(sta_entry ? sta_entry->wireless_mode :\t\\\n\t\t\t WIRELESS_MODE_G)) :\t\t\t\\\n\t\t_id); })\n\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_sta_info *sta_entry = NULL;\n\tu8 ratr_index = SET_RATE_ID(RATR_INX_WIRELESS_MC);\n\n\tif (sta) {\n\t\tsta_entry = (struct rtl_sta_info *) sta->drv_priv;\n\t\tratr_index = sta_entry->ratr_index;\n\t}\n\tif (!tcb_desc->disable_ratefallback || !tcb_desc->use_driver_rate) {\n\t\tif (mac->opmode == NL80211_IFTYPE_STATION) {\n\t\t\ttcb_desc->ratr_index = 0;\n\t\t} else if (mac->opmode == NL80211_IFTYPE_ADHOC ||\n\t\t\t\tmac->opmode == NL80211_IFTYPE_MESH_POINT) {\n\t\t\tif (tcb_desc->multicast || tcb_desc->broadcast) {\n\t\t\t\ttcb_desc->hw_rate =\n\t\t\t\t    rtlpriv->cfg->maps[RTL_RC_CCK_RATE2M];\n\t\t\t\ttcb_desc->use_driver_rate = 1;\n\t\t\t\ttcb_desc->ratr_index =\n\t\t\t\t\tSET_RATE_ID(RATR_INX_WIRELESS_MC);\n\t\t\t} else {\n\t\t\t\ttcb_desc->ratr_index = ratr_index;\n\t\t\t}\n\t\t} else if (mac->opmode == NL80211_IFTYPE_AP) {\n\t\t\ttcb_desc->ratr_index = ratr_index;\n\t\t}\n\t}\n\n\tif (rtlpriv->dm.useramask) {\n\t\ttcb_desc->ratr_index = ratr_index;\n\t\t \n\t\tif (mac->opmode == NL80211_IFTYPE_STATION ||\n\t\t    mac->opmode == NL80211_IFTYPE_MESH_POINT) {\n\t\t\ttcb_desc->mac_id = 0;\n\n\t\t\tif (sta &&\n\t\t\t    (rtlpriv->cfg->spec_ver & RTL_SPEC_NEW_RATEID))\n\t\t\t\t;\t \n\t\t\telse if (mac->mode == WIRELESS_MODE_AC_5G)\n\t\t\t\ttcb_desc->ratr_index =\n\t\t\t\t\tSET_RATE_ID(RATR_INX_WIRELESS_AC_5N);\n\t\t\telse if (mac->mode == WIRELESS_MODE_AC_24G)\n\t\t\t\ttcb_desc->ratr_index =\n\t\t\t\t\tSET_RATE_ID(RATR_INX_WIRELESS_AC_24N);\n\t\t\telse if (mac->mode == WIRELESS_MODE_N_24G)\n\t\t\t\ttcb_desc->ratr_index =\n\t\t\t\t\tSET_RATE_ID(RATR_INX_WIRELESS_NGB);\n\t\t\telse if (mac->mode == WIRELESS_MODE_N_5G)\n\t\t\t\ttcb_desc->ratr_index =\n\t\t\t\t\tSET_RATE_ID(RATR_INX_WIRELESS_NG);\n\t\t\telse if (mac->mode & WIRELESS_MODE_G)\n\t\t\t\ttcb_desc->ratr_index =\n\t\t\t\t\tSET_RATE_ID(RATR_INX_WIRELESS_GB);\n\t\t\telse if (mac->mode & WIRELESS_MODE_B)\n\t\t\t\ttcb_desc->ratr_index =\n\t\t\t\t\tSET_RATE_ID(RATR_INX_WIRELESS_B);\n\t\t\telse if (mac->mode & WIRELESS_MODE_A)\n\t\t\t\ttcb_desc->ratr_index =\n\t\t\t\t\tSET_RATE_ID(RATR_INX_WIRELESS_G);\n\n\t\t} else if (mac->opmode == NL80211_IFTYPE_AP ||\n\t\t\tmac->opmode == NL80211_IFTYPE_ADHOC) {\n\t\t\tif (NULL != sta) {\n\t\t\t\tif (sta->aid > 0)\n\t\t\t\t\ttcb_desc->mac_id = sta->aid + 1;\n\t\t\t\telse\n\t\t\t\t\ttcb_desc->mac_id = 1;\n\t\t\t} else {\n\t\t\t\ttcb_desc->mac_id = 0;\n\t\t\t}\n\t\t}\n\t}\n#undef SET_RATE_ID\n}\n\nstatic void _rtl_query_bandwidth_mode(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_sta *sta,\n\t\t\t\t      struct rtl_tcb_desc *tcb_desc)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\n\ttcb_desc->packet_bw = false;\n\tif (!sta)\n\t\treturn;\n\tif (mac->opmode == NL80211_IFTYPE_AP ||\n\t    mac->opmode == NL80211_IFTYPE_ADHOC ||\n\t    mac->opmode == NL80211_IFTYPE_MESH_POINT) {\n\t\tif (!(sta->deflink.ht_cap.ht_supported) ||\n\t\t    !(sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40))\n\t\t\treturn;\n\t} else if (mac->opmode == NL80211_IFTYPE_STATION) {\n\t\tif (!mac->bw_40 || !(sta->deflink.ht_cap.ht_supported))\n\t\t\treturn;\n\t}\n\tif (tcb_desc->multicast || tcb_desc->broadcast)\n\t\treturn;\n\n\t \n\tif (tcb_desc->hw_rate <= rtlpriv->cfg->maps[RTL_RC_OFDM_RATE54M])\n\t\treturn;\n\n\ttcb_desc->packet_bw = HT_CHANNEL_WIDTH_20_40;\n\n\tif (rtlpriv->cfg->spec_ver & RTL_SPEC_SUPPORT_VHT) {\n\t\tif (mac->opmode == NL80211_IFTYPE_AP ||\n\t\t    mac->opmode == NL80211_IFTYPE_ADHOC ||\n\t\t    mac->opmode == NL80211_IFTYPE_MESH_POINT) {\n\t\t\tif (!(sta->deflink.vht_cap.vht_supported))\n\t\t\t\treturn;\n\t\t} else if (mac->opmode == NL80211_IFTYPE_STATION) {\n\t\t\tif (!mac->bw_80 ||\n\t\t\t    !(sta->deflink.vht_cap.vht_supported))\n\t\t\t\treturn;\n\t\t}\n\t\tif (tcb_desc->hw_rate <=\n\t\t\trtlpriv->cfg->maps[RTL_RC_HT_RATEMCS15])\n\t\t\treturn;\n\t\ttcb_desc->packet_bw = HT_CHANNEL_WIDTH_80;\n\t}\n}\n\nstatic u8 _rtl_get_vht_highest_n_rate(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_sta *sta)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &(rtlpriv->phy);\n\tu8 hw_rate;\n\tu16 tx_mcs_map = le16_to_cpu(sta->deflink.vht_cap.vht_mcs.tx_mcs_map);\n\n\tif ((get_rf_type(rtlphy) == RF_2T2R) &&\n\t    (tx_mcs_map & 0x000c) != 0x000c) {\n\t\tif ((tx_mcs_map & 0x000c) >> 2 ==\n\t\t\tIEEE80211_VHT_MCS_SUPPORT_0_7)\n\t\t\thw_rate =\n\t\t\trtlpriv->cfg->maps[RTL_RC_VHT_RATE_2SS_MCS7];\n\t\telse if ((tx_mcs_map  & 0x000c) >> 2 ==\n\t\t\tIEEE80211_VHT_MCS_SUPPORT_0_8)\n\t\t\thw_rate =\n\t\t\trtlpriv->cfg->maps[RTL_RC_VHT_RATE_2SS_MCS8];\n\t\telse\n\t\t\thw_rate =\n\t\t\trtlpriv->cfg->maps[RTL_RC_VHT_RATE_2SS_MCS9];\n\t} else {\n\t\tif ((tx_mcs_map  & 0x0003) ==\n\t\t\tIEEE80211_VHT_MCS_SUPPORT_0_7)\n\t\t\thw_rate =\n\t\t\trtlpriv->cfg->maps[RTL_RC_VHT_RATE_1SS_MCS7];\n\t\telse if ((tx_mcs_map  & 0x0003) ==\n\t\t\tIEEE80211_VHT_MCS_SUPPORT_0_8)\n\t\t\thw_rate =\n\t\t\trtlpriv->cfg->maps[RTL_RC_VHT_RATE_1SS_MCS8];\n\t\telse\n\t\t\thw_rate =\n\t\t\trtlpriv->cfg->maps[RTL_RC_VHT_RATE_1SS_MCS9];\n\t}\n\n\treturn hw_rate;\n}\n\nstatic u8 _rtl_get_highest_n_rate(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_sta *sta)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_phy *rtlphy = &rtlpriv->phy;\n\tu8 hw_rate;\n\n\tif (get_rf_type(rtlphy) == RF_2T2R &&\n\t    sta->deflink.ht_cap.mcs.rx_mask[1] != 0)\n\t\thw_rate = rtlpriv->cfg->maps[RTL_RC_HT_RATEMCS15];\n\telse\n\t\thw_rate = rtlpriv->cfg->maps[RTL_RC_HT_RATEMCS7];\n\n\treturn hw_rate;\n}\n\n \nint rtlwifi_rate_mapping(struct ieee80211_hw *hw, bool isht, bool isvht,\n\t\t\t u8 desc_rate)\n{\n\tint rate_idx;\n\n\tif (isvht) {\n\t\tswitch (desc_rate) {\n\t\tcase DESC_RATEVHT1SS_MCS0:\n\t\t\trate_idx = 0;\n\t\t\tbreak;\n\t\tcase DESC_RATEVHT1SS_MCS1:\n\t\t\trate_idx = 1;\n\t\t\tbreak;\n\t\tcase DESC_RATEVHT1SS_MCS2:\n\t\t\trate_idx = 2;\n\t\t\tbreak;\n\t\tcase DESC_RATEVHT1SS_MCS3:\n\t\t\trate_idx = 3;\n\t\t\tbreak;\n\t\tcase DESC_RATEVHT1SS_MCS4:\n\t\t\trate_idx = 4;\n\t\t\tbreak;\n\t\tcase DESC_RATEVHT1SS_MCS5:\n\t\t\trate_idx = 5;\n\t\t\tbreak;\n\t\tcase DESC_RATEVHT1SS_MCS6:\n\t\t\trate_idx = 6;\n\t\t\tbreak;\n\t\tcase DESC_RATEVHT1SS_MCS7:\n\t\t\trate_idx = 7;\n\t\t\tbreak;\n\t\tcase DESC_RATEVHT1SS_MCS8:\n\t\t\trate_idx = 8;\n\t\t\tbreak;\n\t\tcase DESC_RATEVHT1SS_MCS9:\n\t\t\trate_idx = 9;\n\t\t\tbreak;\n\t\tcase DESC_RATEVHT2SS_MCS0:\n\t\t\trate_idx = 0;\n\t\t\tbreak;\n\t\tcase DESC_RATEVHT2SS_MCS1:\n\t\t\trate_idx = 1;\n\t\t\tbreak;\n\t\tcase DESC_RATEVHT2SS_MCS2:\n\t\t\trate_idx = 2;\n\t\t\tbreak;\n\t\tcase DESC_RATEVHT2SS_MCS3:\n\t\t\trate_idx = 3;\n\t\t\tbreak;\n\t\tcase DESC_RATEVHT2SS_MCS4:\n\t\t\trate_idx = 4;\n\t\t\tbreak;\n\t\tcase DESC_RATEVHT2SS_MCS5:\n\t\t\trate_idx = 5;\n\t\t\tbreak;\n\t\tcase DESC_RATEVHT2SS_MCS6:\n\t\t\trate_idx = 6;\n\t\t\tbreak;\n\t\tcase DESC_RATEVHT2SS_MCS7:\n\t\t\trate_idx = 7;\n\t\t\tbreak;\n\t\tcase DESC_RATEVHT2SS_MCS8:\n\t\t\trate_idx = 8;\n\t\t\tbreak;\n\t\tcase DESC_RATEVHT2SS_MCS9:\n\t\t\trate_idx = 9;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trate_idx = 0;\n\t\t\tbreak;\n\t\t}\n\t\treturn rate_idx;\n\t}\n\tif (false == isht) {\n\t\tif (NL80211_BAND_2GHZ == hw->conf.chandef.chan->band) {\n\t\t\tswitch (desc_rate) {\n\t\t\tcase DESC_RATE1M:\n\t\t\t\trate_idx = 0;\n\t\t\t\tbreak;\n\t\t\tcase DESC_RATE2M:\n\t\t\t\trate_idx = 1;\n\t\t\t\tbreak;\n\t\t\tcase DESC_RATE5_5M:\n\t\t\t\trate_idx = 2;\n\t\t\t\tbreak;\n\t\t\tcase DESC_RATE11M:\n\t\t\t\trate_idx = 3;\n\t\t\t\tbreak;\n\t\t\tcase DESC_RATE6M:\n\t\t\t\trate_idx = 4;\n\t\t\t\tbreak;\n\t\t\tcase DESC_RATE9M:\n\t\t\t\trate_idx = 5;\n\t\t\t\tbreak;\n\t\t\tcase DESC_RATE12M:\n\t\t\t\trate_idx = 6;\n\t\t\t\tbreak;\n\t\t\tcase DESC_RATE18M:\n\t\t\t\trate_idx = 7;\n\t\t\t\tbreak;\n\t\t\tcase DESC_RATE24M:\n\t\t\t\trate_idx = 8;\n\t\t\t\tbreak;\n\t\t\tcase DESC_RATE36M:\n\t\t\t\trate_idx = 9;\n\t\t\t\tbreak;\n\t\t\tcase DESC_RATE48M:\n\t\t\t\trate_idx = 10;\n\t\t\t\tbreak;\n\t\t\tcase DESC_RATE54M:\n\t\t\t\trate_idx = 11;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\trate_idx = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tswitch (desc_rate) {\n\t\t\tcase DESC_RATE6M:\n\t\t\t\trate_idx = 0;\n\t\t\t\tbreak;\n\t\t\tcase DESC_RATE9M:\n\t\t\t\trate_idx = 1;\n\t\t\t\tbreak;\n\t\t\tcase DESC_RATE12M:\n\t\t\t\trate_idx = 2;\n\t\t\t\tbreak;\n\t\t\tcase DESC_RATE18M:\n\t\t\t\trate_idx = 3;\n\t\t\t\tbreak;\n\t\t\tcase DESC_RATE24M:\n\t\t\t\trate_idx = 4;\n\t\t\t\tbreak;\n\t\t\tcase DESC_RATE36M:\n\t\t\t\trate_idx = 5;\n\t\t\t\tbreak;\n\t\t\tcase DESC_RATE48M:\n\t\t\t\trate_idx = 6;\n\t\t\t\tbreak;\n\t\t\tcase DESC_RATE54M:\n\t\t\t\trate_idx = 7;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\trate_idx = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tswitch (desc_rate) {\n\t\tcase DESC_RATEMCS0:\n\t\t\trate_idx = 0;\n\t\t\tbreak;\n\t\tcase DESC_RATEMCS1:\n\t\t\trate_idx = 1;\n\t\t\tbreak;\n\t\tcase DESC_RATEMCS2:\n\t\t\trate_idx = 2;\n\t\t\tbreak;\n\t\tcase DESC_RATEMCS3:\n\t\t\trate_idx = 3;\n\t\t\tbreak;\n\t\tcase DESC_RATEMCS4:\n\t\t\trate_idx = 4;\n\t\t\tbreak;\n\t\tcase DESC_RATEMCS5:\n\t\t\trate_idx = 5;\n\t\t\tbreak;\n\t\tcase DESC_RATEMCS6:\n\t\t\trate_idx = 6;\n\t\t\tbreak;\n\t\tcase DESC_RATEMCS7:\n\t\t\trate_idx = 7;\n\t\t\tbreak;\n\t\tcase DESC_RATEMCS8:\n\t\t\trate_idx = 8;\n\t\t\tbreak;\n\t\tcase DESC_RATEMCS9:\n\t\t\trate_idx = 9;\n\t\t\tbreak;\n\t\tcase DESC_RATEMCS10:\n\t\t\trate_idx = 10;\n\t\t\tbreak;\n\t\tcase DESC_RATEMCS11:\n\t\t\trate_idx = 11;\n\t\t\tbreak;\n\t\tcase DESC_RATEMCS12:\n\t\t\trate_idx = 12;\n\t\t\tbreak;\n\t\tcase DESC_RATEMCS13:\n\t\t\trate_idx = 13;\n\t\t\tbreak;\n\t\tcase DESC_RATEMCS14:\n\t\t\trate_idx = 14;\n\t\t\tbreak;\n\t\tcase DESC_RATEMCS15:\n\t\t\trate_idx = 15;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trate_idx = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn rate_idx;\n}\nEXPORT_SYMBOL(rtlwifi_rate_mapping);\n\nstatic u8 _rtl_get_tx_hw_rate(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_tx_info *info)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct ieee80211_tx_rate *r = &info->status.rates[0];\n\tstruct ieee80211_rate *txrate;\n\tu8 hw_value = 0x0;\n\n\tif (r->flags & IEEE80211_TX_RC_MCS) {\n\t\t \n\t\thw_value = rtlpriv->cfg->maps[RTL_RC_HT_RATEMCS15] - 15 +\n\t\t\t   r->idx;\n\t} else if (r->flags & IEEE80211_TX_RC_VHT_MCS) {\n\t\t \n\t\tif (ieee80211_rate_get_vht_nss(r) == 2)\n\t\t\thw_value = rtlpriv->cfg->maps[RTL_RC_VHT_RATE_2SS_MCS9];\n\t\telse\n\t\t\thw_value = rtlpriv->cfg->maps[RTL_RC_VHT_RATE_1SS_MCS9];\n\n\t\thw_value = hw_value - 9 + ieee80211_rate_get_vht_mcs(r);\n\t} else {\n\t\t \n\t\ttxrate = ieee80211_get_tx_rate(hw, info);\n\n\t\tif (txrate)\n\t\t\thw_value = txrate->hw_value;\n\t}\n\n\t \n\tif (rtlpriv->rtlhal.current_bandtype == BAND_ON_5G &&\n\t    hw_value < rtlpriv->cfg->maps[RTL_RC_OFDM_RATE6M])\n\t\thw_value = rtlpriv->cfg->maps[RTL_RC_OFDM_RATE6M];\n\n\treturn hw_value;\n}\n\nvoid rtl_get_tcb_desc(struct ieee80211_hw *hw,\n\t\t      struct ieee80211_tx_info *info,\n\t\t      struct ieee80211_sta *sta,\n\t\t      struct sk_buff *skb, struct rtl_tcb_desc *tcb_desc)\n{\n#define SET_RATE_ID(rate_id)\t\t\t\t\t\\\n\t({typeof(rate_id) _id = rate_id;\t\t\t\\\n\t  ((rtlpriv->cfg->spec_ver & RTL_SPEC_NEW_RATEID) ?\t\\\n\t\trtl_mrate_idx_to_arfr_id(hw, _id,\t\t\\\n\t\t\t(sta_entry ? sta_entry->wireless_mode :\t\\\n\t\t\t WIRELESS_MODE_G)) :\t\t\t\\\n\t\t_id); })\n\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *rtlmac = rtl_mac(rtl_priv(hw));\n\tstruct ieee80211_hdr *hdr = rtl_get_hdr(skb);\n\tstruct rtl_sta_info *sta_entry =\n\t\t(sta ? (struct rtl_sta_info *)sta->drv_priv : NULL);\n\n\t__le16 fc = rtl_get_fc(skb);\n\n\ttcb_desc->hw_rate = _rtl_get_tx_hw_rate(hw, info);\n\n\tif (rtl_is_tx_report_skb(hw, skb))\n\t\ttcb_desc->use_spe_rpt = 1;\n\n\tif (ieee80211_is_data(fc)) {\n\t\t \n\n\t\t \n\t\tif (info->control.rates[0].idx == 0 ||\n\t\t\t\tieee80211_is_nullfunc(fc)) {\n\t\t\ttcb_desc->use_driver_rate = true;\n\t\t\ttcb_desc->ratr_index =\n\t\t\t\t\tSET_RATE_ID(RATR_INX_WIRELESS_MC);\n\n\t\t\ttcb_desc->disable_ratefallback = 1;\n\t\t} else {\n\t\t\t \n\t\t\tif (sta && sta->deflink.vht_cap.vht_supported) {\n\t\t\t\ttcb_desc->hw_rate =\n\t\t\t\t_rtl_get_vht_highest_n_rate(hw, sta);\n\t\t\t} else {\n\t\t\t\tif (sta && sta->deflink.ht_cap.ht_supported) {\n\t\t\t\t\ttcb_desc->hw_rate =\n\t\t\t\t\t\t_rtl_get_highest_n_rate(hw, sta);\n\t\t\t\t} else {\n\t\t\t\t\tif (rtlmac->mode == WIRELESS_MODE_B) {\n\t\t\t\t\t\ttcb_desc->hw_rate =\n\t\t\t\t\t\t    rtlpriv->cfg->maps[RTL_RC_CCK_RATE11M];\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttcb_desc->hw_rate =\n\t\t\t\t\t\t    rtlpriv->cfg->maps[RTL_RC_OFDM_RATE54M];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (is_multicast_ether_addr(hdr->addr1))\n\t\t\ttcb_desc->multicast = 1;\n\t\telse if (is_broadcast_ether_addr(hdr->addr1))\n\t\t\ttcb_desc->broadcast = 1;\n\n\t\t_rtl_txrate_selectmode(hw, sta, tcb_desc);\n\t\t_rtl_query_bandwidth_mode(hw, sta, tcb_desc);\n\t\t_rtl_qurey_shortpreamble_mode(hw, tcb_desc, info);\n\t\t_rtl_query_shortgi(hw, sta, tcb_desc, info);\n\t\t_rtl_query_protection_mode(hw, tcb_desc, info);\n\t} else {\n\t\ttcb_desc->use_driver_rate = true;\n\t\ttcb_desc->ratr_index = SET_RATE_ID(RATR_INX_WIRELESS_MC);\n\t\ttcb_desc->disable_ratefallback = 1;\n\t\ttcb_desc->mac_id = 0;\n\t\ttcb_desc->packet_bw = false;\n\t}\n#undef SET_RATE_ID\n}\nEXPORT_SYMBOL(rtl_get_tcb_desc);\n\nbool rtl_tx_mgmt_proc(struct ieee80211_hw *hw, struct sk_buff *skb)\n{\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\t__le16 fc = rtl_get_fc(skb);\n\n\tif (rtlpriv->dm.supp_phymode_switch &&\n\t    mac->link_state < MAC80211_LINKED &&\n\t    (ieee80211_is_auth(fc) || ieee80211_is_probe_req(fc))) {\n\t\tif (rtlpriv->cfg->ops->chk_switch_dmdp)\n\t\t\trtlpriv->cfg->ops->chk_switch_dmdp(hw);\n\t}\n\tif (ieee80211_is_auth(fc)) {\n\t\trtl_dbg(rtlpriv, COMP_SEND, DBG_DMESG, \"MAC80211_LINKING\\n\");\n\n\t\tmac->link_state = MAC80211_LINKING;\n\t\t \n\t\trtlpriv->phy.need_iqk = true;\n\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(rtl_tx_mgmt_proc);\n\nstruct sk_buff *rtl_make_del_ba(struct ieee80211_hw *hw, u8 *sa,\n\t\t\t\tu8 *bssid, u16 tid);\n\nstatic void process_agg_start(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_hdr *hdr, u16 tid)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct ieee80211_rx_status rx_status = { 0 };\n\tstruct sk_buff *skb_delba = NULL;\n\n\tskb_delba = rtl_make_del_ba(hw, hdr->addr2, hdr->addr3, tid);\n\tif (skb_delba) {\n\t\trx_status.freq = hw->conf.chandef.chan->center_freq;\n\t\trx_status.band = hw->conf.chandef.chan->band;\n\t\trx_status.flag |= RX_FLAG_DECRYPTED;\n\t\trx_status.flag |= RX_FLAG_MACTIME_START;\n\t\trx_status.rate_idx = 0;\n\t\trx_status.signal = 50 + 10;\n\t\tmemcpy(IEEE80211_SKB_RXCB(skb_delba),\n\t\t       &rx_status, sizeof(rx_status));\n\t\tRT_PRINT_DATA(rtlpriv, COMP_INIT, DBG_DMESG,\n\t\t\t      \"fake del\\n\",\n\t\t\t      skb_delba->data,\n\t\t\t      skb_delba->len);\n\t\tieee80211_rx_irqsafe(hw, skb_delba);\n\t}\n}\n\nbool rtl_action_proc(struct ieee80211_hw *hw, struct sk_buff *skb, u8 is_tx)\n{\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct ieee80211_hdr *hdr = rtl_get_hdr(skb);\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\t__le16 fc = rtl_get_fc(skb);\n\tu8 *act = (u8 *)(((u8 *)skb->data + MAC80211_3ADDR_LEN));\n\tu8 category;\n\n\tif (!ieee80211_is_action(fc))\n\t\treturn true;\n\n\tcategory = *act;\n\tact++;\n\tswitch (category) {\n\tcase ACT_CAT_BA:\n\t\tswitch (*act) {\n\t\tcase ACT_ADDBAREQ:\n\t\t\tif (mac->act_scanning)\n\t\t\t\treturn false;\n\n\t\t\trtl_dbg(rtlpriv, (COMP_SEND | COMP_RECV), DBG_DMESG,\n\t\t\t\t\"%s ACT_ADDBAREQ From :%pM\\n\",\n\t\t\t\tis_tx ? \"Tx\" : \"Rx\", hdr->addr2);\n\t\t\tRT_PRINT_DATA(rtlpriv, COMP_INIT, DBG_DMESG, \"req\\n\",\n\t\t\t\tskb->data, skb->len);\n\t\t\tif (!is_tx) {\n\t\t\t\tstruct ieee80211_sta *sta = NULL;\n\t\t\t\tstruct rtl_sta_info *sta_entry = NULL;\n\t\t\t\tstruct rtl_tid_data *tid_data;\n\t\t\t\tstruct ieee80211_mgmt *mgmt = (void *)skb->data;\n\t\t\t\tu16 capab = 0, tid = 0;\n\n\t\t\t\trcu_read_lock();\n\t\t\t\tsta = rtl_find_sta(hw, hdr->addr3);\n\t\t\t\tif (sta == NULL) {\n\t\t\t\t\trtl_dbg(rtlpriv, COMP_SEND | COMP_RECV,\n\t\t\t\t\t\tDBG_DMESG, \"sta is NULL\\n\");\n\t\t\t\t\trcu_read_unlock();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tsta_entry =\n\t\t\t\t\t(struct rtl_sta_info *)sta->drv_priv;\n\t\t\t\tif (!sta_entry) {\n\t\t\t\t\trcu_read_unlock();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tcapab =\n\t\t\t\t  le16_to_cpu(mgmt->u.action.u.addba_req.capab);\n\t\t\t\ttid = (capab &\n\t\t\t\t       IEEE80211_ADDBA_PARAM_TID_MASK) >> 2;\n\t\t\t\tif (tid >= MAX_TID_COUNT) {\n\t\t\t\t\trcu_read_unlock();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\ttid_data = &sta_entry->tids[tid];\n\t\t\t\tif (tid_data->agg.rx_agg_state ==\n\t\t\t\t    RTL_RX_AGG_START)\n\t\t\t\t\tprocess_agg_start(hw, hdr, tid);\n\t\t\t\trcu_read_unlock();\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ACT_ADDBARSP:\n\t\t\trtl_dbg(rtlpriv, (COMP_SEND | COMP_RECV), DBG_DMESG,\n\t\t\t\t\"%s ACT_ADDBARSP From :%pM\\n\",\n\t\t\t\tis_tx ? \"Tx\" : \"Rx\", hdr->addr2);\n\t\t\tbreak;\n\t\tcase ACT_DELBA:\n\t\t\trtl_dbg(rtlpriv, (COMP_SEND | COMP_RECV), DBG_DMESG,\n\t\t\t\t\"ACT_ADDBADEL From :%pM\\n\", hdr->addr2);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(rtl_action_proc);\n\nstatic void setup_special_tx(struct rtl_priv *rtlpriv, struct rtl_ps_ctl *ppsc,\n\t\t\t     int type)\n{\n\tstruct ieee80211_hw *hw = rtlpriv->hw;\n\n\trtlpriv->ra.is_special_data = true;\n\tif (rtlpriv->cfg->ops->get_btc_status())\n\t\trtlpriv->btcoexist.btc_ops->btc_special_packet_notify(\n\t\t\t\t\trtlpriv, type);\n\trtl_lps_leave(hw, false);\n\tppsc->last_delaylps_stamp_jiffies = jiffies;\n}\n\nstatic const u8 *rtl_skb_ether_type_ptr(struct ieee80211_hw *hw,\n\t\t\t\t\tstruct sk_buff *skb, bool is_enc)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tu8 mac_hdr_len = ieee80211_get_hdrlen_from_skb(skb);\n\tu8 encrypt_header_len = 0;\n\tu8 offset;\n\n\tswitch (rtlpriv->sec.pairwise_enc_algorithm) {\n\tcase WEP40_ENCRYPTION:\n\tcase WEP104_ENCRYPTION:\n\t\tencrypt_header_len = 4; \n\t\tbreak;\n\tcase TKIP_ENCRYPTION:\n\t\tencrypt_header_len = 8; \n\t\tbreak;\n\tcase AESCCMP_ENCRYPTION:\n\t\tencrypt_header_len = 8; \n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\toffset = mac_hdr_len + SNAP_SIZE;\n\tif (is_enc)\n\t\toffset += encrypt_header_len;\n\n\treturn skb->data + offset;\n}\n\n \nu8 rtl_is_special_data(struct ieee80211_hw *hw, struct sk_buff *skb, u8 is_tx,\n\t\t       bool is_enc)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\t__le16 fc = rtl_get_fc(skb);\n\tu16 ether_type;\n\tconst u8 *ether_type_ptr;\n\tconst struct iphdr *ip;\n\n\tif (!ieee80211_is_data(fc))\n\t\tgoto end;\n\n\tether_type_ptr = rtl_skb_ether_type_ptr(hw, skb, is_enc);\n\tether_type = be16_to_cpup((__be16 *)ether_type_ptr);\n\n\tif (ETH_P_IP == ether_type) {\n\t\tip = (struct iphdr *)((u8 *)ether_type_ptr +\n\t\t     PROTOC_TYPE_SIZE);\n\t\tif (IPPROTO_UDP == ip->protocol) {\n\t\t\tstruct udphdr *udp = (struct udphdr *)((u8 *)ip +\n\t\t\t\t\t\t\t       (ip->ihl << 2));\n\t\t\tif (((((u8 *)udp)[1] == 68) &&\n\t\t\t     (((u8 *)udp)[3] == 67)) ||\n\t\t\t    ((((u8 *)udp)[1] == 67) &&\n\t\t\t     (((u8 *)udp)[3] == 68))) {\n\t\t\t\t \n\t\t\t\trtl_dbg(rtlpriv, (COMP_SEND | COMP_RECV),\n\t\t\t\t\tDBG_DMESG, \"dhcp %s !!\\n\",\n\t\t\t\t\t(is_tx) ? \"Tx\" : \"Rx\");\n\n\t\t\t\tif (is_tx)\n\t\t\t\t\tsetup_special_tx(rtlpriv, ppsc,\n\t\t\t\t\t\t\t PACKET_DHCP);\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t} else if (ETH_P_ARP == ether_type) {\n\t\tif (is_tx)\n\t\t\tsetup_special_tx(rtlpriv, ppsc, PACKET_ARP);\n\n\t\treturn true;\n\t} else if (ETH_P_PAE == ether_type) {\n\t\t \n\t\trtlpriv->btcoexist.btc_info.in_4way = true;\n\t\trtlpriv->btcoexist.btc_info.in_4way_ts = jiffies;\n\n\t\trtl_dbg(rtlpriv, (COMP_SEND | COMP_RECV), DBG_DMESG,\n\t\t\t\"802.1X %s EAPOL pkt!!\\n\", (is_tx) ? \"Tx\" : \"Rx\");\n\n\t\tif (is_tx) {\n\t\t\trtlpriv->ra.is_special_data = true;\n\t\t\trtl_lps_leave(hw, false);\n\t\t\tppsc->last_delaylps_stamp_jiffies = jiffies;\n\n\t\t\tsetup_special_tx(rtlpriv, ppsc, PACKET_EAPOL);\n\t\t}\n\n\t\treturn true;\n\t} else if (ETH_P_IPV6 == ether_type) {\n\t\t \n\t\tgoto end;\n\t}\n\nend:\n\trtlpriv->ra.is_special_data = false;\n\treturn false;\n}\nEXPORT_SYMBOL_GPL(rtl_is_special_data);\n\nvoid rtl_tx_ackqueue(struct ieee80211_hw *hw, struct sk_buff *skb)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_tx_report *tx_report = &rtlpriv->tx_report;\n\n\t__skb_queue_tail(&tx_report->queue, skb);\n}\nEXPORT_SYMBOL_GPL(rtl_tx_ackqueue);\n\nstatic void rtl_tx_status(struct ieee80211_hw *hw, struct sk_buff *skb,\n\t\t\t  bool ack)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct ieee80211_tx_info *info;\n\n\tinfo = IEEE80211_SKB_CB(skb);\n\tieee80211_tx_info_clear_status(info);\n\tif (ack) {\n\t\trtl_dbg(rtlpriv, COMP_TX_REPORT, DBG_LOUD,\n\t\t\t\"tx report: ack\\n\");\n\t\tinfo->flags |= IEEE80211_TX_STAT_ACK;\n\t} else {\n\t\trtl_dbg(rtlpriv, COMP_TX_REPORT, DBG_LOUD,\n\t\t\t\"tx report: not ack\\n\");\n\t\tinfo->flags &= ~IEEE80211_TX_STAT_ACK;\n\t}\n\tieee80211_tx_status_irqsafe(hw, skb);\n}\n\nbool rtl_is_tx_report_skb(struct ieee80211_hw *hw, struct sk_buff *skb)\n{\n\tu16 ether_type;\n\tconst u8 *ether_type_ptr;\n\t__le16 fc = rtl_get_fc(skb);\n\n\tether_type_ptr = rtl_skb_ether_type_ptr(hw, skb, true);\n\tether_type = be16_to_cpup((__be16 *)ether_type_ptr);\n\n\tif (ether_type == ETH_P_PAE || ieee80211_is_nullfunc(fc))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic u16 rtl_get_tx_report_sn(struct ieee80211_hw *hw,\n\t\t\t\tstruct rtlwifi_tx_info *tx_info)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_tx_report *tx_report = &rtlpriv->tx_report;\n\tu16 sn;\n\n\t \n\tsn = (atomic_inc_return(&tx_report->sn) & 0x003F) << 2;\n\n\ttx_report->last_sent_sn = sn;\n\ttx_report->last_sent_time = jiffies;\n\ttx_info->sn = sn;\n\ttx_info->send_time = tx_report->last_sent_time;\n\trtl_dbg(rtlpriv, COMP_TX_REPORT, DBG_DMESG,\n\t\t\"Send TX-Report sn=0x%X\\n\", sn);\n\n\treturn sn;\n}\n\nvoid rtl_set_tx_report(struct rtl_tcb_desc *ptcb_desc, u8 *pdesc,\n\t\t       struct ieee80211_hw *hw, struct rtlwifi_tx_info *tx_info)\n{\n\tif (ptcb_desc->use_spe_rpt) {\n\t\tu16 sn = rtl_get_tx_report_sn(hw, tx_info);\n\n\t\tSET_TX_DESC_SPE_RPT(pdesc, 1);\n\t\tSET_TX_DESC_SW_DEFINE(pdesc, sn);\n\t}\n}\nEXPORT_SYMBOL_GPL(rtl_set_tx_report);\n\nvoid rtl_tx_report_handler(struct ieee80211_hw *hw, u8 *tmp_buf, u8 c2h_cmd_len)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_tx_report *tx_report = &rtlpriv->tx_report;\n\tstruct rtlwifi_tx_info *tx_info;\n\tstruct sk_buff_head *queue = &tx_report->queue;\n\tstruct sk_buff *skb;\n\tu16 sn;\n\tu8 st, retry;\n\n\tif (rtlpriv->cfg->spec_ver & RTL_SPEC_EXT_C2H) {\n\t\tsn = GET_TX_REPORT_SN_V2(tmp_buf);\n\t\tst = GET_TX_REPORT_ST_V2(tmp_buf);\n\t\tretry = GET_TX_REPORT_RETRY_V2(tmp_buf);\n\t} else {\n\t\tsn = GET_TX_REPORT_SN_V1(tmp_buf);\n\t\tst = GET_TX_REPORT_ST_V1(tmp_buf);\n\t\tretry = GET_TX_REPORT_RETRY_V1(tmp_buf);\n\t}\n\n\ttx_report->last_recv_sn = sn;\n\n\tskb_queue_walk(queue, skb) {\n\t\ttx_info = rtl_tx_skb_cb_info(skb);\n\t\tif (tx_info->sn == sn) {\n\t\t\tskb_unlink(skb, queue);\n\t\t\trtl_tx_status(hw, skb, st == 0);\n\t\t\tbreak;\n\t\t}\n\t}\n\trtl_dbg(rtlpriv, COMP_TX_REPORT, DBG_DMESG,\n\t\t\"Recv TX-Report st=0x%02X sn=0x%X retry=0x%X\\n\",\n\t\tst, sn, retry);\n}\nEXPORT_SYMBOL_GPL(rtl_tx_report_handler);\n\nbool rtl_check_tx_report_acked(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_tx_report *tx_report = &rtlpriv->tx_report;\n\n\tif (tx_report->last_sent_sn == tx_report->last_recv_sn)\n\t\treturn true;\n\n\tif (time_before(tx_report->last_sent_time + 3 * HZ, jiffies)) {\n\t\trtl_dbg(rtlpriv, COMP_TX_REPORT, DBG_WARNING,\n\t\t\t\"Check TX-Report timeout!! s_sn=0x%X r_sn=0x%X\\n\",\n\t\t\ttx_report->last_sent_sn, tx_report->last_recv_sn);\n\t\treturn true;\t \n\t}\n\n\treturn false;\n}\n\nvoid rtl_wait_tx_report_acked(struct ieee80211_hw *hw, u32 wait_ms)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tint i;\n\n\tfor (i = 0; i < wait_ms; i++) {\n\t\tif (rtl_check_tx_report_acked(hw))\n\t\t\tbreak;\n\t\tusleep_range(1000, 2000);\n\t\trtl_dbg(rtlpriv, COMP_SEC, DBG_DMESG,\n\t\t\t\"Wait 1ms (%d/%d) to disable key.\\n\", i, wait_ms);\n\t}\n}\n\nu32 rtl_get_hal_edca_param(struct ieee80211_hw *hw,\n\t\t\t   struct ieee80211_vif *vif,\n\t\t\t   enum wireless_mode wirelessmode,\n\t\t\t   struct ieee80211_tx_queue_params *param)\n{\n\tu32 reg = 0;\n\tu8 sifstime = 10;\n\tu8 slottime = 20;\n\n\t \n\tswitch (wirelessmode) {\n\tcase WIRELESS_MODE_A:\n\tcase WIRELESS_MODE_N_24G:\n\tcase WIRELESS_MODE_N_5G:\n\tcase WIRELESS_MODE_AC_5G:\n\tcase WIRELESS_MODE_AC_24G:\n\t\tsifstime = 16;\n\t\tslottime = 9;\n\t\tbreak;\n\tcase WIRELESS_MODE_G:\n\t\tslottime = (vif->bss_conf.use_short_slot ? 9 : 20);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treg |= (param->txop & 0x7FF) << 16;\n\treg |= (fls(param->cw_max) & 0xF) << 12;\n\treg |= (fls(param->cw_min) & 0xF) << 8;\n\treg |= (param->aifs & 0x0F) * slottime + sifstime;\n\n\treturn reg;\n}\nEXPORT_SYMBOL_GPL(rtl_get_hal_edca_param);\n\n \nint rtl_tx_agg_start(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t     struct ieee80211_sta *sta, u16 tid, u16 *ssn)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_tid_data *tid_data;\n\tstruct rtl_sta_info *sta_entry = NULL;\n\n\tif (sta == NULL)\n\t\treturn -EINVAL;\n\n\tif (unlikely(tid >= MAX_TID_COUNT))\n\t\treturn -EINVAL;\n\n\tsta_entry = (struct rtl_sta_info *)sta->drv_priv;\n\tif (!sta_entry)\n\t\treturn -ENXIO;\n\ttid_data = &sta_entry->tids[tid];\n\n\trtl_dbg(rtlpriv, COMP_SEND, DBG_DMESG,\n\t\t\"on ra = %pM tid = %d seq:%d\\n\", sta->addr, tid,\n\t\t*ssn);\n\n\ttid_data->agg.agg_state = RTL_AGG_START;\n\n\treturn IEEE80211_AMPDU_TX_START_IMMEDIATE;\n}\n\nint rtl_tx_agg_stop(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t    struct ieee80211_sta *sta, u16 tid)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_sta_info *sta_entry = NULL;\n\n\tif (sta == NULL)\n\t\treturn -EINVAL;\n\n\trtl_dbg(rtlpriv, COMP_SEND, DBG_DMESG,\n\t\t\"on ra = %pM tid = %d\\n\", sta->addr, tid);\n\n\tif (unlikely(tid >= MAX_TID_COUNT))\n\t\treturn -EINVAL;\n\n\tsta_entry = (struct rtl_sta_info *)sta->drv_priv;\n\tsta_entry->tids[tid].agg.agg_state = RTL_AGG_STOP;\n\n\tieee80211_stop_tx_ba_cb_irqsafe(vif, sta->addr, tid);\n\treturn 0;\n}\n\nint rtl_rx_agg_start(struct ieee80211_hw *hw,\n\t\t     struct ieee80211_sta *sta, u16 tid)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_tid_data *tid_data;\n\tstruct rtl_sta_info *sta_entry = NULL;\n\tu8 reject_agg;\n\n\tif (sta == NULL)\n\t\treturn -EINVAL;\n\n\tif (unlikely(tid >= MAX_TID_COUNT))\n\t\treturn -EINVAL;\n\n\tif (rtlpriv->cfg->ops->get_btc_status()) {\n\t\trtlpriv->btcoexist.btc_ops->btc_get_ampdu_cfg(rtlpriv,\n\t\t\t\t\t\t\t      &reject_agg,\n\t\t\t\t\t\t\t      NULL, NULL);\n\t\tif (reject_agg)\n\t\t\treturn -EINVAL;\n\t}\n\n\tsta_entry = (struct rtl_sta_info *)sta->drv_priv;\n\tif (!sta_entry)\n\t\treturn -ENXIO;\n\ttid_data = &sta_entry->tids[tid];\n\n\trtl_dbg(rtlpriv, COMP_RECV, DBG_DMESG,\n\t\t\"on ra = %pM tid = %d\\n\", sta->addr, tid);\n\n\ttid_data->agg.rx_agg_state = RTL_RX_AGG_START;\n\treturn 0;\n}\n\nint rtl_rx_agg_stop(struct ieee80211_hw *hw,\n\t\t    struct ieee80211_sta *sta, u16 tid)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_sta_info *sta_entry = NULL;\n\n\tif (sta == NULL)\n\t\treturn -EINVAL;\n\n\trtl_dbg(rtlpriv, COMP_SEND, DBG_DMESG,\n\t\t\"on ra = %pM tid = %d\\n\", sta->addr, tid);\n\n\tif (unlikely(tid >= MAX_TID_COUNT))\n\t\treturn -EINVAL;\n\n\tsta_entry = (struct rtl_sta_info *)sta->drv_priv;\n\tsta_entry->tids[tid].agg.rx_agg_state = RTL_RX_AGG_STOP;\n\n\treturn 0;\n}\n\nint rtl_tx_agg_oper(struct ieee80211_hw *hw,\n\t\tstruct ieee80211_sta *sta, u16 tid)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_sta_info *sta_entry = NULL;\n\n\tif (sta == NULL)\n\t\treturn -EINVAL;\n\n\trtl_dbg(rtlpriv, COMP_SEND, DBG_DMESG,\n\t\t\"on ra = %pM tid = %d\\n\", sta->addr, tid);\n\n\tif (unlikely(tid >= MAX_TID_COUNT))\n\t\treturn -EINVAL;\n\n\tsta_entry = (struct rtl_sta_info *)sta->drv_priv;\n\tsta_entry->tids[tid].agg.agg_state = RTL_AGG_OPERATIONAL;\n\n\treturn 0;\n}\n\nvoid rtl_rx_ampdu_apply(struct rtl_priv *rtlpriv)\n{\n\tstruct rtl_btc_ops *btc_ops = rtlpriv->btcoexist.btc_ops;\n\tu8 reject_agg = 0, ctrl_agg_size = 0, agg_size = 0;\n\n\tif (rtlpriv->cfg->ops->get_btc_status())\n\t\tbtc_ops->btc_get_ampdu_cfg(rtlpriv, &reject_agg,\n\t\t\t\t\t   &ctrl_agg_size, &agg_size);\n\n\trtl_dbg(rtlpriv, COMP_BT_COEXIST, DBG_DMESG,\n\t\t\"Set RX AMPDU: coex - reject=%d, ctrl_agg_size=%d, size=%d\",\n\t\treject_agg, ctrl_agg_size, agg_size);\n\n\trtlpriv->hw->max_rx_aggregation_subframes =\n\t\t(ctrl_agg_size ? agg_size : IEEE80211_MAX_AMPDU_BUF_HT);\n}\nEXPORT_SYMBOL(rtl_rx_ampdu_apply);\n\n \n \nvoid rtl_beacon_statistic(struct ieee80211_hw *hw, struct sk_buff *skb)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct ieee80211_hdr *hdr = rtl_get_hdr(skb);\n\n\tif (rtlpriv->mac80211.opmode != NL80211_IFTYPE_STATION)\n\t\treturn;\n\n\tif (rtlpriv->mac80211.link_state < MAC80211_LINKED)\n\t\treturn;\n\n\t \n\tif (!ieee80211_is_beacon(hdr->frame_control) &&\n\t    !ieee80211_is_probe_resp(hdr->frame_control))\n\t\treturn;\n\n\t \n\tif (skb->len <= 40 + FCS_LEN)\n\t\treturn;\n\n\t \n\tif (!ether_addr_equal(hdr->addr3, rtlpriv->mac80211.bssid))\n\t\treturn;\n\n\trtlpriv->link_info.bcn_rx_inperiod++;\n}\nEXPORT_SYMBOL_GPL(rtl_beacon_statistic);\n\nstatic void rtl_free_entries_from_scan_list(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_bssid_entry *entry, *next;\n\n\tlist_for_each_entry_safe(entry, next, &rtlpriv->scan_list.list, list) {\n\t\tlist_del(&entry->list);\n\t\tkfree(entry);\n\t\trtlpriv->scan_list.num--;\n\t}\n}\n\nstatic void rtl_free_entries_from_ack_queue(struct ieee80211_hw *hw,\n\t\t\t\t\t    bool chk_timeout)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_tx_report *tx_report = &rtlpriv->tx_report;\n\tstruct sk_buff_head *queue = &tx_report->queue;\n\tstruct sk_buff *skb, *tmp;\n\tstruct rtlwifi_tx_info *tx_info;\n\n\tskb_queue_walk_safe(queue, skb, tmp) {\n\t\ttx_info = rtl_tx_skb_cb_info(skb);\n\t\tif (chk_timeout &&\n\t\t    time_after(tx_info->send_time + HZ, jiffies))\n\t\t\tcontinue;\n\t\tskb_unlink(skb, queue);\n\t\trtl_tx_status(hw, skb, false);\n\t}\n}\n\nvoid rtl_scan_list_expire(struct ieee80211_hw *hw)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_bssid_entry *entry, *next;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&rtlpriv->locks.scan_list_lock, flags);\n\n\tlist_for_each_entry_safe(entry, next, &rtlpriv->scan_list.list, list) {\n\t\t \n\t\tif (jiffies_to_msecs(jiffies - entry->age) < 180000)\n\t\t\tcontinue;\n\n\t\tlist_del(&entry->list);\n\t\trtlpriv->scan_list.num--;\n\n\t\trtl_dbg(rtlpriv, COMP_SCAN, DBG_LOUD,\n\t\t\t\"BSSID=%pM is expire in scan list (total=%d)\\n\",\n\t\t\tentry->bssid, rtlpriv->scan_list.num);\n\t\tkfree(entry);\n\t}\n\n\tspin_unlock_irqrestore(&rtlpriv->locks.scan_list_lock, flags);\n\n\trtlpriv->btcoexist.btc_info.ap_num = rtlpriv->scan_list.num;\n}\n\nvoid rtl_collect_scan_list(struct ieee80211_hw *hw, struct sk_buff *skb)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct ieee80211_hdr *hdr = rtl_get_hdr(skb);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tunsigned long flags;\n\n\tstruct rtl_bssid_entry *entry = NULL, *iter;\n\n\t \n\tif (!mac->act_scanning)\n\t\treturn;\n\n\t \n\tif (!ieee80211_is_beacon(hdr->frame_control) &&\n\t    !ieee80211_is_probe_resp(hdr->frame_control))\n\t\treturn;\n\n\tspin_lock_irqsave(&rtlpriv->locks.scan_list_lock, flags);\n\n\tlist_for_each_entry(iter, &rtlpriv->scan_list.list, list) {\n\t\tif (memcmp(iter->bssid, hdr->addr3, ETH_ALEN) == 0) {\n\t\t\tlist_del_init(&iter->list);\n\t\t\tentry = iter;\n\t\t\trtl_dbg(rtlpriv, COMP_SCAN, DBG_LOUD,\n\t\t\t\t\"Update BSSID=%pM to scan list (total=%d)\\n\",\n\t\t\t\thdr->addr3, rtlpriv->scan_list.num);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!entry) {\n\t\tentry = kmalloc(sizeof(*entry), GFP_ATOMIC);\n\n\t\tif (!entry)\n\t\t\tgoto label_err;\n\n\t\tmemcpy(entry->bssid, hdr->addr3, ETH_ALEN);\n\t\trtlpriv->scan_list.num++;\n\n\t\trtl_dbg(rtlpriv, COMP_SCAN, DBG_LOUD,\n\t\t\t\"Add BSSID=%pM to scan list (total=%d)\\n\",\n\t\t\thdr->addr3, rtlpriv->scan_list.num);\n\t}\n\n\tentry->age = jiffies;\n\n\tlist_add_tail(&entry->list, &rtlpriv->scan_list.list);\n\nlabel_err:\n\tspin_unlock_irqrestore(&rtlpriv->locks.scan_list_lock, flags);\n}\nEXPORT_SYMBOL(rtl_collect_scan_list);\n\nstatic void rtl_watchdog_wq_callback(struct work_struct *work)\n{\n\tstruct rtl_works *rtlworks = container_of(work, struct rtl_works,\n\t\t\t\t\t\t  watchdog_wq.work);\n\tstruct ieee80211_hw *hw = rtlworks->hw;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tbool busytraffic = false;\n\tbool tx_busy_traffic = false;\n\tbool rx_busy_traffic = false;\n\tbool higher_busytraffic = false;\n\tbool higher_busyrxtraffic = false;\n\tu8 idx, tid;\n\tu32 rx_cnt_inp4eriod = 0;\n\tu32 tx_cnt_inp4eriod = 0;\n\tu32 aver_rx_cnt_inperiod = 0;\n\tu32 aver_tx_cnt_inperiod = 0;\n\tu32 aver_tidtx_inperiod[MAX_TID_COUNT] = {0};\n\tu32 tidtx_inp4eriod[MAX_TID_COUNT] = {0};\n\n\tif (is_hal_stop(rtlhal))\n\t\treturn;\n\n\t \n\tif (mac->link_state > MAC80211_NOLINK) {\n\t\tif (mac->cnt_after_linked < 20)\n\t\t\tmac->cnt_after_linked++;\n\t} else {\n\t\tmac->cnt_after_linked = 0;\n\t}\n\n\t \n\tif (mac->link_state >= MAC80211_LINKED) {\n\t\t \n\t\tfor (idx = 0; idx <= 2; idx++) {\n\t\t\trtlpriv->link_info.num_rx_in4period[idx] =\n\t\t\t    rtlpriv->link_info.num_rx_in4period[idx + 1];\n\t\t\trtlpriv->link_info.num_tx_in4period[idx] =\n\t\t\t    rtlpriv->link_info.num_tx_in4period[idx + 1];\n\t\t}\n\t\trtlpriv->link_info.num_rx_in4period[3] =\n\t\t    rtlpriv->link_info.num_rx_inperiod;\n\t\trtlpriv->link_info.num_tx_in4period[3] =\n\t\t    rtlpriv->link_info.num_tx_inperiod;\n\t\tfor (idx = 0; idx <= 3; idx++) {\n\t\t\trx_cnt_inp4eriod +=\n\t\t\t    rtlpriv->link_info.num_rx_in4period[idx];\n\t\t\ttx_cnt_inp4eriod +=\n\t\t\t    rtlpriv->link_info.num_tx_in4period[idx];\n\t\t}\n\t\taver_rx_cnt_inperiod = rx_cnt_inp4eriod / 4;\n\t\taver_tx_cnt_inperiod = tx_cnt_inp4eriod / 4;\n\n\t\t \n\t\tif (aver_rx_cnt_inperiod > 100 || aver_tx_cnt_inperiod > 100) {\n\t\t\tbusytraffic = true;\n\t\t\tif (aver_rx_cnt_inperiod > aver_tx_cnt_inperiod)\n\t\t\t\trx_busy_traffic = true;\n\t\t\telse\n\t\t\t\ttx_busy_traffic = false;\n\t\t}\n\n\t\t \n\t\tif (aver_rx_cnt_inperiod > 4000 ||\n\t\t    aver_tx_cnt_inperiod > 4000) {\n\t\t\thigher_busytraffic = true;\n\n\t\t\t \n\t\t\tif (aver_rx_cnt_inperiod > 5000)\n\t\t\t\thigher_busyrxtraffic = true;\n\t\t}\n\n\t\t \n\t\tfor (tid = 0; tid <= 7; tid++) {\n\t\t\tfor (idx = 0; idx <= 2; idx++)\n\t\t\t\trtlpriv->link_info.tidtx_in4period[tid][idx] =\n\t\t\t\t\trtlpriv->link_info.tidtx_in4period[tid]\n\t\t\t\t\t[idx + 1];\n\t\t\trtlpriv->link_info.tidtx_in4period[tid][3] =\n\t\t\t\trtlpriv->link_info.tidtx_inperiod[tid];\n\n\t\t\tfor (idx = 0; idx <= 3; idx++)\n\t\t\t\ttidtx_inp4eriod[tid] +=\n\t\t\t\t   rtlpriv->link_info.tidtx_in4period[tid][idx];\n\t\t\taver_tidtx_inperiod[tid] = tidtx_inp4eriod[tid] / 4;\n\t\t\tif (aver_tidtx_inperiod[tid] > 5000)\n\t\t\t\trtlpriv->link_info.higher_busytxtraffic[tid] =\n\t\t\t\t\t\t\t\t\ttrue;\n\t\t\telse\n\t\t\t\trtlpriv->link_info.higher_busytxtraffic[tid] =\n\t\t\t\t\t\t\t\t\tfalse;\n\t\t}\n\n\t\t \n\t\tif (rtlpriv->cfg->ops->get_btc_status() &&\n\t\t    rtlpriv->btcoexist.btc_ops->btc_is_bt_ctrl_lps(rtlpriv))\n\t\t\tgoto label_lps_done;\n\n\t\tif (rtlpriv->link_info.num_rx_inperiod +\n\t\t      rtlpriv->link_info.num_tx_inperiod > 8 ||\n\t\t    rtlpriv->link_info.num_rx_inperiod > 2)\n\t\t\trtl_lps_leave(hw, true);\n\t\telse\n\t\t\trtl_lps_enter(hw, true);\n\nlabel_lps_done:\n\t\t;\n\t}\n\n\tfor (tid = 0; tid <= 7; tid++)\n\t\trtlpriv->link_info.tidtx_inperiod[tid] = 0;\n\n\trtlpriv->link_info.busytraffic = busytraffic;\n\trtlpriv->link_info.higher_busytraffic = higher_busytraffic;\n\trtlpriv->link_info.rx_busy_traffic = rx_busy_traffic;\n\trtlpriv->link_info.tx_busy_traffic = tx_busy_traffic;\n\trtlpriv->link_info.higher_busyrxtraffic = higher_busyrxtraffic;\n\n\trtlpriv->stats.txbytesunicast_inperiod =\n\t\trtlpriv->stats.txbytesunicast -\n\t\trtlpriv->stats.txbytesunicast_last;\n\trtlpriv->stats.rxbytesunicast_inperiod =\n\t\trtlpriv->stats.rxbytesunicast -\n\t\trtlpriv->stats.rxbytesunicast_last;\n\trtlpriv->stats.txbytesunicast_last = rtlpriv->stats.txbytesunicast;\n\trtlpriv->stats.rxbytesunicast_last = rtlpriv->stats.rxbytesunicast;\n\n\trtlpriv->stats.txbytesunicast_inperiod_tp =\n\t\t(u32)(rtlpriv->stats.txbytesunicast_inperiod * 8 / 2 /\n\t\t1024 / 1024);\n\trtlpriv->stats.rxbytesunicast_inperiod_tp =\n\t\t(u32)(rtlpriv->stats.rxbytesunicast_inperiod * 8 / 2 /\n\t\t1024 / 1024);\n\n\t \n\tif (!rtlpriv->cfg->mod_params->disable_watchdog)\n\t\trtlpriv->cfg->ops->dm_watchdog(hw);\n\n\t \n\tif (mac->link_state == MAC80211_LINKED &&\n\t    mac->opmode == NL80211_IFTYPE_STATION) {\n\t\tif ((rtlpriv->link_info.bcn_rx_inperiod +\n\t\t    rtlpriv->link_info.num_rx_inperiod) == 0) {\n\t\t\trtlpriv->link_info.roam_times++;\n\t\t\trtl_dbg(rtlpriv, COMP_ERR, DBG_DMESG,\n\t\t\t\t\"AP off for %d s\\n\",\n\t\t\t\t(rtlpriv->link_info.roam_times * 2));\n\n\t\t\t \n\t\t\tif (rtlpriv->link_info.roam_times >= 5) {\n\t\t\t\tpr_err(\"AP off, try to reconnect now\\n\");\n\t\t\t\trtlpriv->link_info.roam_times = 0;\n\t\t\t\tieee80211_connection_loss(\n\t\t\t\t\trtlpriv->mac80211.vif);\n\t\t\t}\n\t\t} else {\n\t\t\trtlpriv->link_info.roam_times = 0;\n\t\t}\n\t}\n\n\tif (rtlpriv->cfg->ops->get_btc_status())\n\t\trtlpriv->btcoexist.btc_ops->btc_periodical(rtlpriv);\n\n\tif (rtlpriv->btcoexist.btc_info.in_4way) {\n\t\tif (time_after(jiffies, rtlpriv->btcoexist.btc_info.in_4way_ts +\n\t\t\t       msecs_to_jiffies(IN_4WAY_TIMEOUT_TIME)))\n\t\t\trtlpriv->btcoexist.btc_info.in_4way = false;\n\t}\n\n\trtlpriv->link_info.num_rx_inperiod = 0;\n\trtlpriv->link_info.num_tx_inperiod = 0;\n\trtlpriv->link_info.bcn_rx_inperiod = 0;\n\n\t \n\trtl_scan_list_expire(hw);\n\n\t \n\trtl_free_entries_from_ack_queue(hw, true);\n}\n\nvoid rtl_watch_dog_timer_callback(struct timer_list *t)\n{\n\tstruct rtl_priv *rtlpriv = from_timer(rtlpriv, t, works.watchdog_timer);\n\n\tqueue_delayed_work(rtlpriv->works.rtl_wq,\n\t\t\t   &rtlpriv->works.watchdog_wq, 0);\n\n\tmod_timer(&rtlpriv->works.watchdog_timer,\n\t\t  jiffies + MSECS(RTL_WATCH_DOG_TIME));\n}\n\nstatic void rtl_fwevt_wq_callback(struct work_struct *work)\n{\n\tstruct rtl_works *rtlworks = container_of(work, struct rtl_works,\n\t\t\t\t\t\t  fwevt_wq.work);\n\tstruct ieee80211_hw *hw = rtlworks->hw;\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\trtlpriv->cfg->ops->c2h_command_handle(hw);\n}\n\nstatic void rtl_c2h_content_parsing(struct ieee80211_hw *hw,\n\t\t\t\t    struct sk_buff *skb);\n\nstatic bool rtl_c2h_fast_cmd(struct ieee80211_hw *hw, struct sk_buff *skb)\n{\n\tu8 cmd_id = GET_C2H_CMD_ID(skb->data);\n\n\tswitch (cmd_id) {\n\tcase C2H_BT_MP:\n\t\treturn true;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn false;\n}\n\nvoid rtl_c2hcmd_enqueue(struct ieee80211_hw *hw, struct sk_buff *skb)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\n\tif (rtl_c2h_fast_cmd(hw, skb)) {\n\t\trtl_c2h_content_parsing(hw, skb);\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\t \n\tskb_queue_tail(&rtlpriv->c2hcmd_queue, skb);\n\n\t \n\tqueue_delayed_work(rtlpriv->works.rtl_wq, &rtlpriv->works.c2hcmd_wq, 0);\n}\nEXPORT_SYMBOL(rtl_c2hcmd_enqueue);\n\nstatic void rtl_c2h_content_parsing(struct ieee80211_hw *hw,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal_ops *hal_ops = rtlpriv->cfg->ops;\n\tconst struct rtl_btc_ops *btc_ops = rtlpriv->btcoexist.btc_ops;\n\tu8 cmd_id, cmd_len;\n\tu8 *cmd_buf = NULL;\n\n\tcmd_id = GET_C2H_CMD_ID(skb->data);\n\tcmd_len = skb->len - C2H_DATA_OFFSET;\n\tcmd_buf = GET_C2H_DATA_PTR(skb->data);\n\n\tswitch (cmd_id) {\n\tcase C2H_DBG:\n\t\trtl_dbg(rtlpriv, COMP_FW, DBG_LOUD, \"[C2H], C2H_DBG!!\\n\");\n\t\tbreak;\n\tcase C2H_TXBF:\n\t\trtl_dbg(rtlpriv, COMP_FW, DBG_TRACE,\n\t\t\t\"[C2H], C2H_TXBF!!\\n\");\n\t\tbreak;\n\tcase C2H_TX_REPORT:\n\t\trtl_tx_report_handler(hw, cmd_buf, cmd_len);\n\t\tbreak;\n\tcase C2H_RA_RPT:\n\t\tif (hal_ops->c2h_ra_report_handler)\n\t\t\thal_ops->c2h_ra_report_handler(hw, cmd_buf, cmd_len);\n\t\tbreak;\n\tcase C2H_BT_INFO:\n\t\trtl_dbg(rtlpriv, COMP_FW, DBG_TRACE,\n\t\t\t\"[C2H], C2H_BT_INFO!!\\n\");\n\t\tif (rtlpriv->cfg->ops->get_btc_status())\n\t\t\tbtc_ops->btc_btinfo_notify(rtlpriv, cmd_buf, cmd_len);\n\t\tbreak;\n\tcase C2H_BT_MP:\n\t\trtl_dbg(rtlpriv, COMP_FW, DBG_TRACE,\n\t\t\t\"[C2H], C2H_BT_MP!!\\n\");\n\t\tif (rtlpriv->cfg->ops->get_btc_status())\n\t\t\tbtc_ops->btc_btmpinfo_notify(rtlpriv, cmd_buf, cmd_len);\n\t\tbreak;\n\tdefault:\n\t\trtl_dbg(rtlpriv, COMP_FW, DBG_TRACE,\n\t\t\t\"[C2H], Unknown packet!! cmd_id(%#X)!\\n\", cmd_id);\n\t\tbreak;\n\t}\n}\n\nvoid rtl_c2hcmd_launcher(struct ieee80211_hw *hw, int exec)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct sk_buff *skb;\n\tint i;\n\n\tfor (i = 0; i < 200; i++) {\n\t\t \n\t\tskb = skb_dequeue(&rtlpriv->c2hcmd_queue);\n\n\t\t \n\t\tif (!skb)\n\t\t\tbreak;\n\n\t\trtl_dbg(rtlpriv, COMP_FW, DBG_DMESG, \"C2H rx_desc_shift=%d\\n\",\n\t\t\t*((u8 *)skb->cb));\n\t\tRT_PRINT_DATA(rtlpriv, COMP_FW, DBG_DMESG,\n\t\t\t      \"C2H data: \", skb->data, skb->len);\n\n\t\tif (exec)\n\t\t\trtl_c2h_content_parsing(hw, skb);\n\n\t\t \n\t\tdev_kfree_skb_any(skb);\n\t}\n}\n\nstatic void rtl_c2hcmd_wq_callback(struct work_struct *work)\n{\n\tstruct rtl_works *rtlworks = container_of(work, struct rtl_works,\n\t\t\t\t\t\t  c2hcmd_wq.work);\n\tstruct ieee80211_hw *hw = rtlworks->hw;\n\n\trtl_c2hcmd_launcher(hw, 1);\n}\n\n \nu8 *rtl_find_ie(u8 *data, unsigned int len, u8 ie)\n{\n\tstruct ieee80211_mgmt *mgmt = (void *)data;\n\tu8 *pos, *end;\n\n\tpos = (u8 *)mgmt->u.beacon.variable;\n\tend = data + len;\n\twhile (pos < end) {\n\t\tif (pos + 2 + pos[1] > end)\n\t\t\treturn NULL;\n\n\t\tif (pos[0] == ie)\n\t\t\treturn pos;\n\n\t\tpos += 2 + pos[1];\n\t}\n\treturn NULL;\n}\n\n \n \nstatic struct sk_buff *rtl_make_smps_action(struct ieee80211_hw *hw,\n\t\t\t\t     enum ieee80211_smps_mode smps,\n\t\t\t\t     u8 *da, u8 *bssid)\n{\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tstruct sk_buff *skb;\n\tstruct ieee80211_mgmt *action_frame;\n\n\t \n\tskb = dev_alloc_skb(27 + hw->extra_tx_headroom);\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, hw->extra_tx_headroom);\n\taction_frame = skb_put_zero(skb, 27);\n\tmemcpy(action_frame->da, da, ETH_ALEN);\n\tmemcpy(action_frame->sa, rtlefuse->dev_addr, ETH_ALEN);\n\tmemcpy(action_frame->bssid, bssid, ETH_ALEN);\n\taction_frame->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\n\t\t\t\t\t\t  IEEE80211_STYPE_ACTION);\n\taction_frame->u.action.category = WLAN_CATEGORY_HT;\n\taction_frame->u.action.u.ht_smps.action = WLAN_HT_ACTION_SMPS;\n\tswitch (smps) {\n\tcase IEEE80211_SMPS_AUTOMATIC: \n\tcase IEEE80211_SMPS_NUM_MODES: \n\t\tWARN_ON(1);\n\t\tfallthrough;\n\tcase IEEE80211_SMPS_OFF:   \n\t\taction_frame->u.action.u.ht_smps.smps_control =\n\t\t\t\tWLAN_HT_SMPS_CONTROL_DISABLED; \n\t\tbreak;\n\tcase IEEE80211_SMPS_STATIC:   \n\t\taction_frame->u.action.u.ht_smps.smps_control =\n\t\t\t\tWLAN_HT_SMPS_CONTROL_STATIC; \n\t\tbreak;\n\tcase IEEE80211_SMPS_DYNAMIC:   \n\t\taction_frame->u.action.u.ht_smps.smps_control =\n\t\t\t\tWLAN_HT_SMPS_CONTROL_DYNAMIC; \n\t\tbreak;\n\t}\n\n\treturn skb;\n}\n\nint rtl_send_smps_action(struct ieee80211_hw *hw,\n\t\t\t struct ieee80211_sta *sta,\n\t\t\t enum ieee80211_smps_mode smps)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tstruct rtl_ps_ctl *ppsc = rtl_psc(rtl_priv(hw));\n\tstruct sk_buff *skb = NULL;\n\tstruct rtl_tcb_desc tcb_desc;\n\tu8 bssid[ETH_ALEN] = {0};\n\n\tmemset(&tcb_desc, 0, sizeof(struct rtl_tcb_desc));\n\n\tif (rtlpriv->mac80211.act_scanning)\n\t\tgoto err_free;\n\n\tif (!sta)\n\t\tgoto err_free;\n\n\tif (unlikely(is_hal_stop(rtlhal) || ppsc->rfpwr_state != ERFON))\n\t\tgoto err_free;\n\n\tif (!test_bit(RTL_STATUS_INTERFACE_START, &rtlpriv->status))\n\t\tgoto err_free;\n\n\tif (rtlpriv->mac80211.opmode == NL80211_IFTYPE_AP)\n\t\tmemcpy(bssid, rtlpriv->efuse.dev_addr, ETH_ALEN);\n\telse\n\t\tmemcpy(bssid, rtlpriv->mac80211.bssid, ETH_ALEN);\n\n\tskb = rtl_make_smps_action(hw, smps, sta->addr, bssid);\n\t \n\tif (skb) {\n\t\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\t\tstruct rtl_sta_info *sta_entry =\n\t\t\t(struct rtl_sta_info *) sta->drv_priv;\n\t\tsta_entry->mimo_ps = smps;\n\t\t \n\n\t\tinfo->control.rates[0].idx = 0;\n\t\tinfo->band = hw->conf.chandef.chan->band;\n\t\trtlpriv->intf_ops->adapter_tx(hw, sta, skb, &tcb_desc);\n\t}\n\treturn 1;\n\nerr_free:\n\treturn 0;\n}\nEXPORT_SYMBOL(rtl_send_smps_action);\n\nvoid rtl_phy_scan_operation_backup(struct ieee80211_hw *hw, u8 operation)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));\n\tenum io_type iotype;\n\n\tif (!is_hal_stop(rtlhal)) {\n\t\tswitch (operation) {\n\t\tcase SCAN_OPT_BACKUP:\n\t\t\tiotype = IO_CMD_PAUSE_DM_BY_SCAN;\n\t\t\trtlpriv->cfg->ops->set_hw_reg(hw,\n\t\t\t\t\t\t      HW_VAR_IO_CMD,\n\t\t\t\t\t\t      (u8 *)&iotype);\n\t\t\tbreak;\n\t\tcase SCAN_OPT_RESTORE:\n\t\t\tiotype = IO_CMD_RESUME_DM_BY_SCAN;\n\t\t\trtlpriv->cfg->ops->set_hw_reg(hw,\n\t\t\t\t\t\t      HW_VAR_IO_CMD,\n\t\t\t\t\t\t      (u8 *)&iotype);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"Unknown Scan Backup operation.\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(rtl_phy_scan_operation_backup);\n\n \nstruct sk_buff *rtl_make_del_ba(struct ieee80211_hw *hw,\n\t\t\t\tu8 *sa, u8 *bssid, u16 tid)\n{\n\tstruct rtl_efuse *rtlefuse = rtl_efuse(rtl_priv(hw));\n\tstruct sk_buff *skb;\n\tstruct ieee80211_mgmt *action_frame;\n\tu16 params;\n\n\t \n\tskb = dev_alloc_skb(34 + hw->extra_tx_headroom);\n\tif (!skb)\n\t\treturn NULL;\n\n\tskb_reserve(skb, hw->extra_tx_headroom);\n\taction_frame = skb_put_zero(skb, 34);\n\tmemcpy(action_frame->sa, sa, ETH_ALEN);\n\tmemcpy(action_frame->da, rtlefuse->dev_addr, ETH_ALEN);\n\tmemcpy(action_frame->bssid, bssid, ETH_ALEN);\n\taction_frame->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |\n\t\t\t\t\t\t  IEEE80211_STYPE_ACTION);\n\taction_frame->u.action.category = WLAN_CATEGORY_BACK;\n\taction_frame->u.action.u.delba.action_code = WLAN_ACTION_DELBA;\n\tparams = (u16)(1 << 11);\t \n\tparams |= (u16)(tid << 12);\t \n\n\taction_frame->u.action.u.delba.params = cpu_to_le16(params);\n\taction_frame->u.action.u.delba.reason_code =\n\t\tcpu_to_le16(WLAN_REASON_QSTA_TIMEOUT);\n\n\treturn skb;\n}\n\n \nstatic bool rtl_chk_vendor_ouisub(struct ieee80211_hw *hw,\n\t\t\t\t  struct octet_string vendor_ie)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tbool matched = false;\n\tstatic u8 athcap_1[] = { 0x00, 0x03, 0x7F };\n\tstatic u8 athcap_2[] = { 0x00, 0x13, 0x74 };\n\tstatic u8 broadcap_1[] = { 0x00, 0x10, 0x18 };\n\tstatic u8 broadcap_2[] = { 0x00, 0x0a, 0xf7 };\n\tstatic u8 broadcap_3[] = { 0x00, 0x05, 0xb5 };\n\tstatic u8 racap[] = { 0x00, 0x0c, 0x43 };\n\tstatic u8 ciscocap[] = { 0x00, 0x40, 0x96 };\n\tstatic u8 marvcap[] = { 0x00, 0x50, 0x43 };\n\n\tif (memcmp(vendor_ie.octet, athcap_1, 3) == 0 ||\n\t\tmemcmp(vendor_ie.octet, athcap_2, 3) == 0) {\n\t\trtlpriv->mac80211.vendor = PEER_ATH;\n\t\tmatched = true;\n\t} else if (memcmp(vendor_ie.octet, broadcap_1, 3) == 0 ||\n\t\tmemcmp(vendor_ie.octet, broadcap_2, 3) == 0 ||\n\t\tmemcmp(vendor_ie.octet, broadcap_3, 3) == 0) {\n\t\trtlpriv->mac80211.vendor = PEER_BROAD;\n\t\tmatched = true;\n\t} else if (memcmp(vendor_ie.octet, racap, 3) == 0) {\n\t\trtlpriv->mac80211.vendor = PEER_RAL;\n\t\tmatched = true;\n\t} else if (memcmp(vendor_ie.octet, ciscocap, 3) == 0) {\n\t\trtlpriv->mac80211.vendor = PEER_CISCO;\n\t\tmatched = true;\n\t} else if (memcmp(vendor_ie.octet, marvcap, 3) == 0) {\n\t\trtlpriv->mac80211.vendor = PEER_MARV;\n\t\tmatched = true;\n\t}\n\n\treturn matched;\n}\n\nstatic bool rtl_find_221_ie(struct ieee80211_hw *hw, u8 *data,\n\t\tunsigned int len)\n{\n\tstruct ieee80211_mgmt *mgmt = (void *)data;\n\tstruct octet_string vendor_ie;\n\tu8 *pos, *end;\n\n\tpos = (u8 *)mgmt->u.beacon.variable;\n\tend = data + len;\n\twhile (pos < end) {\n\t\tif (pos[0] == 221) {\n\t\t\tvendor_ie.length = pos[1];\n\t\t\tvendor_ie.octet = &pos[2];\n\t\t\tif (rtl_chk_vendor_ouisub(hw, vendor_ie))\n\t\t\t\treturn true;\n\t\t}\n\n\t\tif (pos + 2 + pos[1] > end)\n\t\t\treturn false;\n\n\t\tpos += 2 + pos[1];\n\t}\n\treturn false;\n}\n\nvoid rtl_recognize_peer(struct ieee80211_hw *hw, u8 *data, unsigned int len)\n{\n\tstruct rtl_priv *rtlpriv = rtl_priv(hw);\n\tstruct rtl_mac *mac = rtl_mac(rtl_priv(hw));\n\tstruct ieee80211_hdr *hdr = (void *)data;\n\tu32 vendor = PEER_UNKNOWN;\n\n\tstatic u8 ap3_1[3] = { 0x00, 0x14, 0xbf };\n\tstatic u8 ap3_2[3] = { 0x00, 0x1a, 0x70 };\n\tstatic u8 ap3_3[3] = { 0x00, 0x1d, 0x7e };\n\tstatic u8 ap4_1[3] = { 0x00, 0x90, 0xcc };\n\tstatic u8 ap4_2[3] = { 0x00, 0x0e, 0x2e };\n\tstatic u8 ap4_3[3] = { 0x00, 0x18, 0x02 };\n\tstatic u8 ap4_4[3] = { 0x00, 0x17, 0x3f };\n\tstatic u8 ap4_5[3] = { 0x00, 0x1c, 0xdf };\n\tstatic u8 ap5_1[3] = { 0x00, 0x1c, 0xf0 };\n\tstatic u8 ap5_2[3] = { 0x00, 0x21, 0x91 };\n\tstatic u8 ap5_3[3] = { 0x00, 0x24, 0x01 };\n\tstatic u8 ap5_4[3] = { 0x00, 0x15, 0xe9 };\n\tstatic u8 ap5_5[3] = { 0x00, 0x17, 0x9A };\n\tstatic u8 ap5_6[3] = { 0x00, 0x18, 0xE7 };\n\tstatic u8 ap6_1[3] = { 0x00, 0x17, 0x94 };\n\tstatic u8 ap7_1[3] = { 0x00, 0x14, 0xa4 };\n\n\tif (mac->opmode != NL80211_IFTYPE_STATION)\n\t\treturn;\n\n\tif (mac->link_state == MAC80211_NOLINK) {\n\t\tmac->vendor = PEER_UNKNOWN;\n\t\treturn;\n\t}\n\n\tif (mac->cnt_after_linked > 2)\n\t\treturn;\n\n\t \n\tif (!ieee80211_is_beacon(hdr->frame_control))\n\t\treturn;\n\n\t \n\tif (len <= 40 + FCS_LEN)\n\t\treturn;\n\n\t \n\tif (!ether_addr_equal_64bits(hdr->addr3, rtlpriv->mac80211.bssid))\n\t\treturn;\n\n\tif (rtl_find_221_ie(hw, data, len))\n\t\tvendor = mac->vendor;\n\n\tif ((memcmp(mac->bssid, ap5_1, 3) == 0) ||\n\t\t(memcmp(mac->bssid, ap5_2, 3) == 0) ||\n\t\t(memcmp(mac->bssid, ap5_3, 3) == 0) ||\n\t\t(memcmp(mac->bssid, ap5_4, 3) == 0) ||\n\t\t(memcmp(mac->bssid, ap5_5, 3) == 0) ||\n\t\t(memcmp(mac->bssid, ap5_6, 3) == 0) ||\n\t\tvendor == PEER_ATH) {\n\t\tvendor = PEER_ATH;\n\t\trtl_dbg(rtlpriv, COMP_MAC80211, DBG_LOUD, \"=>ath find\\n\");\n\t} else if ((memcmp(mac->bssid, ap4_4, 3) == 0) ||\n\t\t(memcmp(mac->bssid, ap4_5, 3) == 0) ||\n\t\t(memcmp(mac->bssid, ap4_1, 3) == 0) ||\n\t\t(memcmp(mac->bssid, ap4_2, 3) == 0) ||\n\t\t(memcmp(mac->bssid, ap4_3, 3) == 0) ||\n\t\tvendor == PEER_RAL) {\n\t\trtl_dbg(rtlpriv, COMP_MAC80211, DBG_LOUD, \"=>ral find\\n\");\n\t\tvendor = PEER_RAL;\n\t} else if (memcmp(mac->bssid, ap6_1, 3) == 0 ||\n\t\tvendor == PEER_CISCO) {\n\t\tvendor = PEER_CISCO;\n\t\trtl_dbg(rtlpriv, COMP_MAC80211, DBG_LOUD, \"=>cisco find\\n\");\n\t} else if ((memcmp(mac->bssid, ap3_1, 3) == 0) ||\n\t\t(memcmp(mac->bssid, ap3_2, 3) == 0) ||\n\t\t(memcmp(mac->bssid, ap3_3, 3) == 0) ||\n\t\tvendor == PEER_BROAD) {\n\t\trtl_dbg(rtlpriv, COMP_MAC80211, DBG_LOUD, \"=>broad find\\n\");\n\t\tvendor = PEER_BROAD;\n\t} else if (memcmp(mac->bssid, ap7_1, 3) == 0 ||\n\t\tvendor == PEER_MARV) {\n\t\tvendor = PEER_MARV;\n\t\trtl_dbg(rtlpriv, COMP_MAC80211, DBG_LOUD, \"=>marv find\\n\");\n\t}\n\n\tmac->vendor = vendor;\n}\nEXPORT_SYMBOL_GPL(rtl_recognize_peer);\n\nMODULE_AUTHOR(\"lizhaoming\t<chaoming_li@realsil.com.cn>\");\nMODULE_AUTHOR(\"Realtek WlanFAE\t<wlanfae@realtek.com>\");\nMODULE_AUTHOR(\"Larry Finger\t<Larry.FInger@lwfinger.net>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Realtek 802.11n PCI wireless core\");\n\nstruct rtl_global_var rtl_global_var = {};\nEXPORT_SYMBOL_GPL(rtl_global_var);\n\nstatic int __init rtl_core_module_init(void)\n{\n\tBUILD_BUG_ON(TX_PWR_BY_RATE_NUM_RATE < TX_PWR_BY_RATE_NUM_SECTION);\n\tBUILD_BUG_ON(MAX_RATE_SECTION_NUM != MAX_RATE_SECTION);\n\tBUILD_BUG_ON(MAX_BASE_NUM_IN_PHY_REG_PG_24G != MAX_RATE_SECTION);\n\tBUILD_BUG_ON(MAX_BASE_NUM_IN_PHY_REG_PG_5G != (MAX_RATE_SECTION - 1));\n\n\tif (rtl_rate_control_register())\n\t\tpr_err(\"rtl: Unable to register rtl_rc, use default RC !!\\n\");\n\n\t \n\trtl_debugfs_add_topdir();\n\n\t \n\tINIT_LIST_HEAD(&rtl_global_var.glb_priv_list);\n\tspin_lock_init(&rtl_global_var.glb_list_lock);\n\n\treturn 0;\n}\n\nstatic void __exit rtl_core_module_exit(void)\n{\n\t \n\trtl_rate_control_unregister();\n\n\t \n\trtl_debugfs_remove_topdir();\n}\n\nmodule_init(rtl_core_module_init);\nmodule_exit(rtl_core_module_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}