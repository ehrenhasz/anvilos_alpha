{
  "module_name": "scan.c",
  "hash_id": "29d61d946659b402415ec2f4a23a78ebf433836090fb7f0768f83ac82988910f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/silabs/wfx/scan.c",
  "human_readable_source": "\n \n#include <net/mac80211.h>\n\n#include \"scan.h\"\n#include \"wfx.h\"\n#include \"sta.h\"\n#include \"hif_tx_mib.h\"\n\nstatic void wfx_ieee80211_scan_completed_compat(struct ieee80211_hw *hw, bool aborted)\n{\n\tstruct cfg80211_scan_info info = {\n\t\t.aborted = aborted,\n\t};\n\n\tieee80211_scan_completed(hw, &info);\n}\n\nstatic int update_probe_tmpl(struct wfx_vif *wvif, struct cfg80211_scan_request *req)\n{\n\tstruct ieee80211_vif *vif = wvif_to_vif(wvif);\n\tstruct sk_buff *skb;\n\n\tskb = ieee80211_probereq_get(wvif->wdev->hw, vif->addr, NULL, 0,\n\t\t\t\t     req->ie_len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put_data(skb, req->ie, req->ie_len);\n\twfx_hif_set_template_frame(wvif, skb, HIF_TMPLT_PRBREQ, 0);\n\tdev_kfree_skb(skb);\n\treturn 0;\n}\n\nstatic int send_scan_req(struct wfx_vif *wvif, struct cfg80211_scan_request *req, int start_idx)\n{\n\tstruct ieee80211_vif *vif = wvif_to_vif(wvif);\n\tstruct ieee80211_channel *ch_start, *ch_cur;\n\tint i, ret;\n\n\tfor (i = start_idx; i < req->n_channels; i++) {\n\t\tch_start = req->channels[start_idx];\n\t\tch_cur = req->channels[i];\n\t\tWARN(ch_cur->band != NL80211_BAND_2GHZ, \"band not supported\");\n\t\tif (ch_cur->max_power != ch_start->max_power)\n\t\t\tbreak;\n\t\tif ((ch_cur->flags ^ ch_start->flags) & IEEE80211_CHAN_NO_IR)\n\t\t\tbreak;\n\t}\n\twfx_tx_lock_flush(wvif->wdev);\n\twvif->scan_abort = false;\n\treinit_completion(&wvif->scan_complete);\n\tret = wfx_hif_scan(wvif, req, start_idx, i - start_idx);\n\tif (ret) {\n\t\twfx_tx_unlock(wvif->wdev);\n\t\treturn -EIO;\n\t}\n\tret = wait_for_completion_timeout(&wvif->scan_complete, 1 * HZ);\n\tif (!ret) {\n\t\twfx_hif_stop_scan(wvif);\n\t\tret = wait_for_completion_timeout(&wvif->scan_complete, 1 * HZ);\n\t\tdev_dbg(wvif->wdev->dev, \"scan timeout (%d channels done)\\n\",\n\t\t\twvif->scan_nb_chan_done);\n\t}\n\tif (!ret) {\n\t\tdev_err(wvif->wdev->dev, \"scan didn't stop\\n\");\n\t\tret = -ETIMEDOUT;\n\t} else if (wvif->scan_abort) {\n\t\tdev_notice(wvif->wdev->dev, \"scan abort\\n\");\n\t\tret = -ECONNABORTED;\n\t} else if (wvif->scan_nb_chan_done > i - start_idx) {\n\t\tret = -EIO;\n\t} else {\n\t\tret = wvif->scan_nb_chan_done;\n\t}\n\tif (req->channels[start_idx]->max_power != vif->bss_conf.txpower)\n\t\twfx_hif_set_output_power(wvif, vif->bss_conf.txpower);\n\twfx_tx_unlock(wvif->wdev);\n\treturn ret;\n}\n\n \nvoid wfx_hw_scan_work(struct work_struct *work)\n{\n\tstruct wfx_vif *wvif = container_of(work, struct wfx_vif, scan_work);\n\tstruct ieee80211_scan_request *hw_req = wvif->scan_req;\n\tint chan_cur, ret, err;\n\n\tmutex_lock(&wvif->wdev->conf_mutex);\n\tmutex_lock(&wvif->scan_lock);\n\tif (wvif->join_in_progress) {\n\t\tdev_info(wvif->wdev->dev, \"abort in-progress REQ_JOIN\");\n\t\twfx_reset(wvif);\n\t}\n\tupdate_probe_tmpl(wvif, &hw_req->req);\n\tchan_cur = 0;\n\terr = 0;\n\tdo {\n\t\tret = send_scan_req(wvif, &hw_req->req, chan_cur);\n\t\tif (ret > 0) {\n\t\t\tchan_cur += ret;\n\t\t\terr = 0;\n\t\t}\n\t\tif (!ret)\n\t\t\terr++;\n\t\tif (err > 2) {\n\t\t\tdev_err(wvif->wdev->dev, \"scan has not been able to start\\n\");\n\t\t\tret = -ETIMEDOUT;\n\t\t}\n\t} while (ret >= 0 && chan_cur < hw_req->req.n_channels);\n\tmutex_unlock(&wvif->scan_lock);\n\tmutex_unlock(&wvif->wdev->conf_mutex);\n\twfx_ieee80211_scan_completed_compat(wvif->wdev->hw, ret < 0);\n}\n\nint wfx_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\tstruct ieee80211_scan_request *hw_req)\n{\n\tstruct wfx_vif *wvif = (struct wfx_vif *)vif->drv_priv;\n\n\tWARN_ON(hw_req->req.n_channels > HIF_API_MAX_NB_CHANNELS);\n\twvif->scan_req = hw_req;\n\tschedule_work(&wvif->scan_work);\n\treturn 0;\n}\n\nvoid wfx_cancel_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\n{\n\tstruct wfx_vif *wvif = (struct wfx_vif *)vif->drv_priv;\n\n\twvif->scan_abort = true;\n\twfx_hif_stop_scan(wvif);\n}\n\nvoid wfx_scan_complete(struct wfx_vif *wvif, int nb_chan_done)\n{\n\twvif->scan_nb_chan_done = nb_chan_done;\n\tcomplete(&wvif->scan_complete);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}