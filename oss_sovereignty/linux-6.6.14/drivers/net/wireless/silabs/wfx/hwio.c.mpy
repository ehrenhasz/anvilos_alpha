{
  "module_name": "hwio.c",
  "hash_id": "cfec24ecfa3eca9dc6e482e993483bb50c7bc4d4dd6c099da27f25c90d3b1655",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/silabs/wfx/hwio.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/align.h>\n\n#include \"hwio.h\"\n#include \"wfx.h\"\n#include \"bus.h\"\n#include \"traces.h\"\n\n#define WFX_HIF_BUFFER_SIZE 0x2000\n\nstatic int wfx_read32(struct wfx_dev *wdev, int reg, u32 *val)\n{\n\tint ret;\n\t__le32 *tmp = kmalloc(sizeof(u32), GFP_KERNEL);\n\n\t*val = ~0;  \n\tif (!tmp)\n\t\treturn -ENOMEM;\n\tret = wdev->hwbus_ops->copy_from_io(wdev->hwbus_priv, reg, tmp, sizeof(u32));\n\tif (ret >= 0)\n\t\t*val = le32_to_cpu(*tmp);\n\tkfree(tmp);\n\tif (ret)\n\t\tdev_err(wdev->dev, \"%s: bus communication error: %d\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic int wfx_write32(struct wfx_dev *wdev, int reg, u32 val)\n{\n\tint ret;\n\t__le32 *tmp = kmalloc(sizeof(u32), GFP_KERNEL);\n\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\t*tmp = cpu_to_le32(val);\n\tret = wdev->hwbus_ops->copy_to_io(wdev->hwbus_priv, reg, tmp, sizeof(u32));\n\tkfree(tmp);\n\tif (ret)\n\t\tdev_err(wdev->dev, \"%s: bus communication error: %d\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic int wfx_read32_locked(struct wfx_dev *wdev, int reg, u32 *val)\n{\n\tint ret;\n\n\twdev->hwbus_ops->lock(wdev->hwbus_priv);\n\tret = wfx_read32(wdev, reg, val);\n\t_trace_io_read32(reg, *val);\n\twdev->hwbus_ops->unlock(wdev->hwbus_priv);\n\treturn ret;\n}\n\nstatic int wfx_write32_locked(struct wfx_dev *wdev, int reg, u32 val)\n{\n\tint ret;\n\n\twdev->hwbus_ops->lock(wdev->hwbus_priv);\n\tret = wfx_write32(wdev, reg, val);\n\t_trace_io_write32(reg, val);\n\twdev->hwbus_ops->unlock(wdev->hwbus_priv);\n\treturn ret;\n}\n\nstatic int wfx_write32_bits_locked(struct wfx_dev *wdev, int reg, u32 mask, u32 val)\n{\n\tint ret;\n\tu32 val_r, val_w;\n\n\tWARN_ON(~mask & val);\n\tval &= mask;\n\twdev->hwbus_ops->lock(wdev->hwbus_priv);\n\tret = wfx_read32(wdev, reg, &val_r);\n\t_trace_io_read32(reg, val_r);\n\tif (ret < 0)\n\t\tgoto err;\n\tval_w = (val_r & ~mask) | val;\n\tif (val_w != val_r) {\n\t\tret = wfx_write32(wdev, reg, val_w);\n\t\t_trace_io_write32(reg, val_w);\n\t}\nerr:\n\twdev->hwbus_ops->unlock(wdev->hwbus_priv);\n\treturn ret;\n}\n\nstatic int wfx_indirect_read(struct wfx_dev *wdev, int reg, u32 addr, void *buf, size_t len)\n{\n\tint ret;\n\tint i;\n\tu32 cfg;\n\tu32 prefetch;\n\n\tWARN_ON(len >= WFX_HIF_BUFFER_SIZE);\n\tWARN_ON(reg != WFX_REG_AHB_DPORT && reg != WFX_REG_SRAM_DPORT);\n\n\tif (reg == WFX_REG_AHB_DPORT)\n\t\tprefetch = CFG_PREFETCH_AHB;\n\telse if (reg == WFX_REG_SRAM_DPORT)\n\t\tprefetch = CFG_PREFETCH_SRAM;\n\telse\n\t\treturn -ENODEV;\n\n\tret = wfx_write32(wdev, WFX_REG_BASE_ADDR, addr);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = wfx_read32(wdev, WFX_REG_CONFIG, &cfg);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = wfx_write32(wdev, WFX_REG_CONFIG, cfg | prefetch);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tfor (i = 0; i < 20; i++) {\n\t\tret = wfx_read32(wdev, WFX_REG_CONFIG, &cfg);\n\t\tif (ret < 0)\n\t\t\tgoto err;\n\t\tif (!(cfg & prefetch))\n\t\t\tbreak;\n\t\tusleep_range(200, 250);\n\t}\n\tif (i == 20) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto err;\n\t}\n\n\tret = wdev->hwbus_ops->copy_from_io(wdev->hwbus_priv, reg, buf, len);\n\nerr:\n\tif (ret < 0)\n\t\tmemset(buf, 0xFF, len);  \n\treturn ret;\n}\n\nstatic int wfx_indirect_write(struct wfx_dev *wdev, int reg, u32 addr,\n\t\t\t      const void *buf, size_t len)\n{\n\tint ret;\n\n\tWARN_ON(len >= WFX_HIF_BUFFER_SIZE);\n\tWARN_ON(reg != WFX_REG_AHB_DPORT && reg != WFX_REG_SRAM_DPORT);\n\tret = wfx_write32(wdev, WFX_REG_BASE_ADDR, addr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn wdev->hwbus_ops->copy_to_io(wdev->hwbus_priv, reg, buf, len);\n}\n\nstatic int wfx_indirect_read_locked(struct wfx_dev *wdev, int reg, u32 addr,\n\t\t\t\t    void *buf, size_t len)\n{\n\tint ret;\n\n\twdev->hwbus_ops->lock(wdev->hwbus_priv);\n\tret = wfx_indirect_read(wdev, reg, addr, buf, len);\n\t_trace_io_ind_read(reg, addr, buf, len);\n\twdev->hwbus_ops->unlock(wdev->hwbus_priv);\n\treturn ret;\n}\n\nstatic int wfx_indirect_write_locked(struct wfx_dev *wdev, int reg, u32 addr,\n\t\t\t\t     const void *buf, size_t len)\n{\n\tint ret;\n\n\twdev->hwbus_ops->lock(wdev->hwbus_priv);\n\tret = wfx_indirect_write(wdev, reg, addr, buf, len);\n\t_trace_io_ind_write(reg, addr, buf, len);\n\twdev->hwbus_ops->unlock(wdev->hwbus_priv);\n\treturn ret;\n}\n\nstatic int wfx_indirect_read32_locked(struct wfx_dev *wdev, int reg, u32 addr, u32 *val)\n{\n\tint ret;\n\t__le32 *tmp = kmalloc(sizeof(u32), GFP_KERNEL);\n\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\twdev->hwbus_ops->lock(wdev->hwbus_priv);\n\tret = wfx_indirect_read(wdev, reg, addr, tmp, sizeof(u32));\n\t*val = le32_to_cpu(*tmp);\n\t_trace_io_ind_read32(reg, addr, *val);\n\twdev->hwbus_ops->unlock(wdev->hwbus_priv);\n\tkfree(tmp);\n\treturn ret;\n}\n\nstatic int wfx_indirect_write32_locked(struct wfx_dev *wdev, int reg, u32 addr, u32 val)\n{\n\tint ret;\n\t__le32 *tmp = kmalloc(sizeof(u32), GFP_KERNEL);\n\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\t*tmp = cpu_to_le32(val);\n\twdev->hwbus_ops->lock(wdev->hwbus_priv);\n\tret = wfx_indirect_write(wdev, reg, addr, tmp, sizeof(u32));\n\t_trace_io_ind_write32(reg, addr, val);\n\twdev->hwbus_ops->unlock(wdev->hwbus_priv);\n\tkfree(tmp);\n\treturn ret;\n}\n\nint wfx_data_read(struct wfx_dev *wdev, void *buf, size_t len)\n{\n\tint ret;\n\n\tWARN(!IS_ALIGNED((uintptr_t)buf, 4), \"unaligned buffer\");\n\twdev->hwbus_ops->lock(wdev->hwbus_priv);\n\tret = wdev->hwbus_ops->copy_from_io(wdev->hwbus_priv, WFX_REG_IN_OUT_QUEUE, buf, len);\n\t_trace_io_read(WFX_REG_IN_OUT_QUEUE, buf, len);\n\twdev->hwbus_ops->unlock(wdev->hwbus_priv);\n\tif (ret)\n\t\tdev_err(wdev->dev, \"%s: bus communication error: %d\\n\", __func__, ret);\n\treturn ret;\n}\n\nint wfx_data_write(struct wfx_dev *wdev, const void *buf, size_t len)\n{\n\tint ret;\n\n\tWARN(!IS_ALIGNED((uintptr_t)buf, 4), \"unaligned buffer\");\n\twdev->hwbus_ops->lock(wdev->hwbus_priv);\n\tret = wdev->hwbus_ops->copy_to_io(wdev->hwbus_priv, WFX_REG_IN_OUT_QUEUE, buf, len);\n\t_trace_io_write(WFX_REG_IN_OUT_QUEUE, buf, len);\n\twdev->hwbus_ops->unlock(wdev->hwbus_priv);\n\tif (ret)\n\t\tdev_err(wdev->dev, \"%s: bus communication error: %d\\n\", __func__, ret);\n\treturn ret;\n}\n\nint wfx_sram_buf_read(struct wfx_dev *wdev, u32 addr, void *buf, size_t len)\n{\n\treturn wfx_indirect_read_locked(wdev, WFX_REG_SRAM_DPORT, addr, buf, len);\n}\n\nint wfx_ahb_buf_read(struct wfx_dev *wdev, u32 addr, void *buf, size_t len)\n{\n\treturn wfx_indirect_read_locked(wdev, WFX_REG_AHB_DPORT, addr, buf, len);\n}\n\nint wfx_sram_buf_write(struct wfx_dev *wdev, u32 addr, const void *buf, size_t len)\n{\n\treturn wfx_indirect_write_locked(wdev, WFX_REG_SRAM_DPORT, addr, buf, len);\n}\n\nint wfx_ahb_buf_write(struct wfx_dev *wdev, u32 addr, const void *buf, size_t len)\n{\n\treturn wfx_indirect_write_locked(wdev, WFX_REG_AHB_DPORT, addr, buf, len);\n}\n\nint wfx_sram_reg_read(struct wfx_dev *wdev, u32 addr, u32 *val)\n{\n\treturn wfx_indirect_read32_locked(wdev, WFX_REG_SRAM_DPORT, addr, val);\n}\n\nint wfx_ahb_reg_read(struct wfx_dev *wdev, u32 addr, u32 *val)\n{\n\treturn wfx_indirect_read32_locked(wdev, WFX_REG_AHB_DPORT, addr, val);\n}\n\nint wfx_sram_reg_write(struct wfx_dev *wdev, u32 addr, u32 val)\n{\n\treturn wfx_indirect_write32_locked(wdev, WFX_REG_SRAM_DPORT, addr, val);\n}\n\nint wfx_ahb_reg_write(struct wfx_dev *wdev, u32 addr, u32 val)\n{\n\treturn wfx_indirect_write32_locked(wdev, WFX_REG_AHB_DPORT, addr, val);\n}\n\nint wfx_config_reg_read(struct wfx_dev *wdev, u32 *val)\n{\n\treturn wfx_read32_locked(wdev, WFX_REG_CONFIG, val);\n}\n\nint wfx_config_reg_write(struct wfx_dev *wdev, u32 val)\n{\n\treturn wfx_write32_locked(wdev, WFX_REG_CONFIG, val);\n}\n\nint wfx_config_reg_write_bits(struct wfx_dev *wdev, u32 mask, u32 val)\n{\n\treturn wfx_write32_bits_locked(wdev, WFX_REG_CONFIG, mask, val);\n}\n\nint wfx_control_reg_read(struct wfx_dev *wdev, u32 *val)\n{\n\treturn wfx_read32_locked(wdev, WFX_REG_CONTROL, val);\n}\n\nint wfx_control_reg_write(struct wfx_dev *wdev, u32 val)\n{\n\treturn wfx_write32_locked(wdev, WFX_REG_CONTROL, val);\n}\n\nint wfx_control_reg_write_bits(struct wfx_dev *wdev, u32 mask, u32 val)\n{\n\treturn wfx_write32_bits_locked(wdev, WFX_REG_CONTROL, mask, val);\n}\n\nint wfx_igpr_reg_read(struct wfx_dev *wdev, int index, u32 *val)\n{\n\tint ret;\n\n\t*val = ~0;  \n\tret = wfx_write32_locked(wdev, WFX_REG_SET_GEN_R_W, IGPR_RW | index << 24);\n\tif (ret)\n\t\treturn ret;\n\tret = wfx_read32_locked(wdev, WFX_REG_SET_GEN_R_W, val);\n\tif (ret)\n\t\treturn ret;\n\t*val &= IGPR_VALUE;\n\treturn ret;\n}\n\nint wfx_igpr_reg_write(struct wfx_dev *wdev, int index, u32 val)\n{\n\treturn wfx_write32_locked(wdev, WFX_REG_SET_GEN_R_W, index << 24 | val);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}