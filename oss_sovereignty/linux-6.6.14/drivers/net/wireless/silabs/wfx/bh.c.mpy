{
  "module_name": "bh.c",
  "hash_id": "afdf135db32ad535e2fdc56ebef2f4af7e9123e6a3358076d0367b0d7cb50e0b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/silabs/wfx/bh.c",
  "human_readable_source": "\n \n#include <linux/gpio/consumer.h>\n#include <net/mac80211.h>\n\n#include \"bh.h\"\n#include \"wfx.h\"\n#include \"hwio.h\"\n#include \"traces.h\"\n#include \"hif_rx.h\"\n#include \"hif_api_cmd.h\"\n\nstatic void device_wakeup(struct wfx_dev *wdev)\n{\n\tint max_retry = 3;\n\n\tif (!wdev->pdata.gpio_wakeup)\n\t\treturn;\n\tif (gpiod_get_value_cansleep(wdev->pdata.gpio_wakeup) > 0)\n\t\treturn;\n\n\tif (wfx_api_older_than(wdev, 1, 4)) {\n\t\tgpiod_set_value_cansleep(wdev->pdata.gpio_wakeup, 1);\n\t\tif (!completion_done(&wdev->hif.ctrl_ready))\n\t\t\tusleep_range(2000, 2500);\n\t\treturn;\n\t}\n\tfor (;;) {\n\t\tgpiod_set_value_cansleep(wdev->pdata.gpio_wakeup, 1);\n\t\t \n\t\tif (wait_for_completion_timeout(&wdev->hif.ctrl_ready, msecs_to_jiffies(2))) {\n\t\t\tcomplete(&wdev->hif.ctrl_ready);\n\t\t\treturn;\n\t\t} else if (max_retry-- > 0) {\n\t\t\t \n\t\t\tdev_err(wdev->dev, \"timeout while wake up chip\\n\");\n\t\t\tgpiod_set_value_cansleep(wdev->pdata.gpio_wakeup, 0);\n\t\t\tusleep_range(2000, 2500);\n\t\t} else {\n\t\t\tdev_err(wdev->dev, \"max wake-up retries reached\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void device_release(struct wfx_dev *wdev)\n{\n\tif (!wdev->pdata.gpio_wakeup)\n\t\treturn;\n\n\tgpiod_set_value_cansleep(wdev->pdata.gpio_wakeup, 0);\n}\n\nstatic int rx_helper(struct wfx_dev *wdev, size_t read_len, int *is_cnf)\n{\n\tstruct sk_buff *skb;\n\tstruct wfx_hif_msg *hif;\n\tsize_t alloc_len;\n\tsize_t computed_len;\n\tint release_count;\n\tint piggyback = 0;\n\n\tWARN(read_len > round_down(0xFFF, 2) * sizeof(u16), \"request exceed the chip capability\");\n\n\t \n\talloc_len = wdev->hwbus_ops->align_size(wdev->hwbus_priv, read_len + 2);\n\tskb = dev_alloc_skb(alloc_len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tif (wfx_data_read(wdev, skb->data, alloc_len))\n\t\tgoto err;\n\n\tpiggyback = le16_to_cpup((__le16 *)(skb->data + alloc_len - 2));\n\t_trace_piggyback(piggyback, false);\n\n\thif = (struct wfx_hif_msg *)skb->data;\n\tWARN(hif->encrypted & 0x3, \"encryption is unsupported\");\n\tif (WARN(read_len < sizeof(struct wfx_hif_msg), \"corrupted read\"))\n\t\tgoto err;\n\tcomputed_len = le16_to_cpu(hif->len);\n\tcomputed_len = round_up(computed_len, 2);\n\tif (computed_len != read_len) {\n\t\tdev_err(wdev->dev, \"inconsistent message length: %zu != %zu\\n\",\n\t\t\tcomputed_len, read_len);\n\t\tprint_hex_dump(KERN_INFO, \"hif: \", DUMP_PREFIX_OFFSET, 16, 1,\n\t\t\t       hif, read_len, true);\n\t\tgoto err;\n\t}\n\n\tif (!(hif->id & HIF_ID_IS_INDICATION)) {\n\t\t(*is_cnf)++;\n\t\tif (hif->id == HIF_CNF_ID_MULTI_TRANSMIT)\n\t\t\trelease_count =\n\t\t\t\t((struct wfx_hif_cnf_multi_transmit *)hif->body)->num_tx_confs;\n\t\telse\n\t\t\trelease_count = 1;\n\t\tWARN(wdev->hif.tx_buffers_used < release_count, \"corrupted buffer counter\");\n\t\twdev->hif.tx_buffers_used -= release_count;\n\t}\n\t_trace_hif_recv(hif, wdev->hif.tx_buffers_used);\n\n\tif (hif->id != HIF_IND_ID_EXCEPTION && hif->id != HIF_IND_ID_ERROR) {\n\t\tif (hif->seqnum != wdev->hif.rx_seqnum)\n\t\t\tdev_warn(wdev->dev, \"wrong message sequence: %d != %d\\n\",\n\t\t\t\t hif->seqnum, wdev->hif.rx_seqnum);\n\t\twdev->hif.rx_seqnum = (hif->seqnum + 1) % (HIF_COUNTER_MAX + 1);\n\t}\n\n\tskb_put(skb, le16_to_cpu(hif->len));\n\t \n\twfx_handle_rx(wdev, skb);\n\tif (!wdev->hif.tx_buffers_used)\n\t\twake_up(&wdev->hif.tx_buffers_empty);\n\n\treturn piggyback;\n\nerr:\n\tif (skb)\n\t\tdev_kfree_skb(skb);\n\treturn -EIO;\n}\n\nstatic int bh_work_rx(struct wfx_dev *wdev, int max_msg, int *num_cnf)\n{\n\tsize_t len;\n\tint i;\n\tint ctrl_reg, piggyback;\n\n\tpiggyback = 0;\n\tfor (i = 0; i < max_msg; i++) {\n\t\tif (piggyback & CTRL_NEXT_LEN_MASK)\n\t\t\tctrl_reg = piggyback;\n\t\telse if (try_wait_for_completion(&wdev->hif.ctrl_ready))\n\t\t\tctrl_reg = atomic_xchg(&wdev->hif.ctrl_reg, 0);\n\t\telse\n\t\t\tctrl_reg = 0;\n\t\tif (!(ctrl_reg & CTRL_NEXT_LEN_MASK))\n\t\t\treturn i;\n\t\t \n\t\tlen = (ctrl_reg & CTRL_NEXT_LEN_MASK) * 2;\n\t\tpiggyback = rx_helper(wdev, len, num_cnf);\n\t\tif (piggyback < 0)\n\t\t\treturn i;\n\t\tif (!(piggyback & CTRL_WLAN_READY))\n\t\t\tdev_err(wdev->dev, \"unexpected piggyback value: ready bit not set: %04x\\n\",\n\t\t\t\tpiggyback);\n\t}\n\tif (piggyback & CTRL_NEXT_LEN_MASK) {\n\t\tctrl_reg = atomic_xchg(&wdev->hif.ctrl_reg, piggyback);\n\t\tcomplete(&wdev->hif.ctrl_ready);\n\t\tif (ctrl_reg)\n\t\t\tdev_err(wdev->dev, \"unexpected IRQ happened: %04x/%04x\\n\",\n\t\t\t\tctrl_reg, piggyback);\n\t}\n\treturn i;\n}\n\nstatic void tx_helper(struct wfx_dev *wdev, struct wfx_hif_msg *hif)\n{\n\tint ret;\n\tvoid *data;\n\tbool is_encrypted = false;\n\tsize_t len = le16_to_cpu(hif->len);\n\n\tWARN(len < sizeof(*hif), \"try to send corrupted data\");\n\n\thif->seqnum = wdev->hif.tx_seqnum;\n\twdev->hif.tx_seqnum = (wdev->hif.tx_seqnum + 1) % (HIF_COUNTER_MAX + 1);\n\n\tdata = hif;\n\tWARN(len > le16_to_cpu(wdev->hw_caps.size_inp_ch_buf),\n\t     \"request exceed the chip capability: %zu > %d\\n\",\n\t     len, le16_to_cpu(wdev->hw_caps.size_inp_ch_buf));\n\tlen = wdev->hwbus_ops->align_size(wdev->hwbus_priv, len);\n\tret = wfx_data_write(wdev, data, len);\n\tif (ret)\n\t\tgoto end;\n\n\twdev->hif.tx_buffers_used++;\n\t_trace_hif_send(hif, wdev->hif.tx_buffers_used);\nend:\n\tif (is_encrypted)\n\t\tkfree(data);\n}\n\nstatic int bh_work_tx(struct wfx_dev *wdev, int max_msg)\n{\n\tstruct wfx_hif_msg *hif;\n\tint i;\n\n\tfor (i = 0; i < max_msg; i++) {\n\t\thif = NULL;\n\t\tif (wdev->hif.tx_buffers_used < le16_to_cpu(wdev->hw_caps.num_inp_ch_bufs)) {\n\t\t\tif (try_wait_for_completion(&wdev->hif_cmd.ready)) {\n\t\t\t\tWARN(!mutex_is_locked(&wdev->hif_cmd.lock), \"data locking error\");\n\t\t\t\thif = wdev->hif_cmd.buf_send;\n\t\t\t} else {\n\t\t\t\thif = wfx_tx_queues_get(wdev);\n\t\t\t}\n\t\t}\n\t\tif (!hif)\n\t\t\treturn i;\n\t\ttx_helper(wdev, hif);\n\t}\n\treturn i;\n}\n\n \nstatic void ack_sdio_data(struct wfx_dev *wdev)\n{\n\tu32 cfg_reg;\n\n\twfx_config_reg_read(wdev, &cfg_reg);\n\tif (cfg_reg & 0xFF) {\n\t\tdev_warn(wdev->dev, \"chip reports errors: %02x\\n\", cfg_reg & 0xFF);\n\t\twfx_config_reg_write_bits(wdev, 0xFF, 0x00);\n\t}\n}\n\nstatic void bh_work(struct work_struct *work)\n{\n\tstruct wfx_dev *wdev = container_of(work, struct wfx_dev, hif.bh);\n\tint stats_req = 0, stats_cnf = 0, stats_ind = 0;\n\tbool release_chip = false, last_op_is_rx = false;\n\tint num_tx, num_rx;\n\n\tdevice_wakeup(wdev);\n\tdo {\n\t\tnum_tx = bh_work_tx(wdev, 32);\n\t\tstats_req += num_tx;\n\t\tif (num_tx)\n\t\t\tlast_op_is_rx = false;\n\t\tnum_rx = bh_work_rx(wdev, 32, &stats_cnf);\n\t\tstats_ind += num_rx;\n\t\tif (num_rx)\n\t\t\tlast_op_is_rx = true;\n\t} while (num_rx || num_tx);\n\tstats_ind -= stats_cnf;\n\n\tif (last_op_is_rx)\n\t\tack_sdio_data(wdev);\n\tif (!wdev->hif.tx_buffers_used && !work_pending(work)) {\n\t\tdevice_release(wdev);\n\t\trelease_chip = true;\n\t}\n\t_trace_bh_stats(stats_ind, stats_req, stats_cnf, wdev->hif.tx_buffers_used, release_chip);\n}\n\n \nvoid wfx_bh_request_rx(struct wfx_dev *wdev)\n{\n\tu32 cur, prev;\n\n\twfx_control_reg_read(wdev, &cur);\n\tprev = atomic_xchg(&wdev->hif.ctrl_reg, cur);\n\tcomplete(&wdev->hif.ctrl_ready);\n\tqueue_work(wdev->bh_wq, &wdev->hif.bh);\n\n\tif (!(cur & CTRL_NEXT_LEN_MASK))\n\t\tdev_err(wdev->dev, \"unexpected control register value: length field is 0: %04x\\n\",\n\t\t\tcur);\n\tif (prev != 0)\n\t\tdev_err(wdev->dev, \"received IRQ but previous data was not (yet) read: %04x/%04x\\n\",\n\t\t\tprev, cur);\n}\n\n \nvoid wfx_bh_request_tx(struct wfx_dev *wdev)\n{\n\tqueue_work(wdev->bh_wq, &wdev->hif.bh);\n}\n\n \nvoid wfx_bh_poll_irq(struct wfx_dev *wdev)\n{\n\tktime_t now, start;\n\tu32 reg;\n\n\tWARN(!wdev->poll_irq, \"unexpected IRQ polling can mask IRQ\");\n\tflush_workqueue(wdev->bh_wq);\n\tstart = ktime_get();\n\tfor (;;) {\n\t\twfx_control_reg_read(wdev, &reg);\n\t\tnow = ktime_get();\n\t\tif (reg & 0xFFF)\n\t\t\tbreak;\n\t\tif (ktime_after(now, ktime_add_ms(start, 1000))) {\n\t\t\tdev_err(wdev->dev, \"time out while polling control register\\n\");\n\t\t\treturn;\n\t\t}\n\t\tudelay(200);\n\t}\n\twfx_bh_request_rx(wdev);\n}\n\nvoid wfx_bh_register(struct wfx_dev *wdev)\n{\n\tINIT_WORK(&wdev->hif.bh, bh_work);\n\tinit_completion(&wdev->hif.ctrl_ready);\n\tinit_waitqueue_head(&wdev->hif.tx_buffers_empty);\n}\n\nvoid wfx_bh_unregister(struct wfx_dev *wdev)\n{\n\tflush_work(&wdev->hif.bh);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}