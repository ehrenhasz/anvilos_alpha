{
  "module_name": "bus_spi.c",
  "hash_id": "c15e1c7417374d08717223fd39044b9a50a5ea0b16f49f4312620c77246264bb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/silabs/wfx/bus_spi.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/spi/spi.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/of.h>\n\n#include \"bus.h\"\n#include \"wfx.h\"\n#include \"hwio.h\"\n#include \"main.h\"\n#include \"bh.h\"\n\n#define SET_WRITE 0x7FFF         \n#define SET_READ 0x8000          \n\nstatic const struct wfx_platform_data pdata_wf200 = {\n\t.file_fw = \"wfx/wfm_wf200\",\n\t.file_pds = \"wfx/wf200.pds\",\n\t.use_rising_clk = true,\n};\n\nstatic const struct wfx_platform_data pdata_brd4001a = {\n\t.file_fw = \"wfx/wfm_wf200\",\n\t.file_pds = \"wfx/brd4001a.pds\",\n\t.use_rising_clk = true,\n};\n\nstatic const struct wfx_platform_data pdata_brd8022a = {\n\t.file_fw = \"wfx/wfm_wf200\",\n\t.file_pds = \"wfx/brd8022a.pds\",\n\t.use_rising_clk = true,\n};\n\nstatic const struct wfx_platform_data pdata_brd8023a = {\n\t.file_fw = \"wfx/wfm_wf200\",\n\t.file_pds = \"wfx/brd8023a.pds\",\n\t.use_rising_clk = true,\n};\n\nstruct wfx_spi_priv {\n\tstruct spi_device *func;\n\tstruct wfx_dev *core;\n\tstruct gpio_desc *gpio_reset;\n\tbool need_swab;\n};\n\n \nstatic int wfx_spi_copy_from_io(void *priv, unsigned int addr, void *dst, size_t count)\n{\n\tstruct wfx_spi_priv *bus = priv;\n\tu16 regaddr = (addr << 12) | (count / 2) | SET_READ;\n\tstruct spi_message m;\n\tstruct spi_transfer t_addr = {\n\t\t.tx_buf = &regaddr,\n\t\t.len = sizeof(regaddr),\n\t};\n\tstruct spi_transfer t_msg = {\n\t\t.rx_buf = dst,\n\t\t.len = count,\n\t};\n\tu16 *dst16 = dst;\n\tint ret, i;\n\n\tWARN(count % 2, \"buffer size must be a multiple of 2\");\n\n\tcpu_to_le16s(&regaddr);\n\tif (bus->need_swab)\n\t\tswab16s(&regaddr);\n\n\tspi_message_init(&m);\n\tspi_message_add_tail(&t_addr, &m);\n\tspi_message_add_tail(&t_msg, &m);\n\tret = spi_sync(bus->func, &m);\n\n\tif (bus->need_swab && addr == WFX_REG_CONFIG)\n\t\tfor (i = 0; i < count / 2; i++)\n\t\t\tswab16s(&dst16[i]);\n\treturn ret;\n}\n\nstatic int wfx_spi_copy_to_io(void *priv, unsigned int addr, const void *src, size_t count)\n{\n\tstruct wfx_spi_priv *bus = priv;\n\tu16 regaddr = (addr << 12) | (count / 2);\n\t \n\tu16 *src16 = (void *)src;\n\tint ret, i;\n\tstruct spi_message m;\n\tstruct spi_transfer t_addr = {\n\t\t.tx_buf = &regaddr,\n\t\t.len = sizeof(regaddr),\n\t};\n\tstruct spi_transfer t_msg = {\n\t\t.tx_buf = src,\n\t\t.len = count,\n\t};\n\n\tWARN(count % 2, \"buffer size must be a multiple of 2\");\n\tWARN(regaddr & SET_READ, \"bad addr or size overflow\");\n\n\tcpu_to_le16s(&regaddr);\n\n\t \n\tif (bus->need_swab)\n\t\tswab16s(&regaddr);\n\tif (bus->need_swab && addr == WFX_REG_CONFIG)\n\t\tfor (i = 0; i < count / 2; i++)\n\t\t\tswab16s(&src16[i]);\n\n\tspi_message_init(&m);\n\tspi_message_add_tail(&t_addr, &m);\n\tspi_message_add_tail(&t_msg, &m);\n\tret = spi_sync(bus->func, &m);\n\n\tif (bus->need_swab && addr == WFX_REG_CONFIG)\n\t\tfor (i = 0; i < count / 2; i++)\n\t\t\tswab16s(&src16[i]);\n\treturn ret;\n}\n\nstatic void wfx_spi_lock(void *priv)\n{\n}\n\nstatic void wfx_spi_unlock(void *priv)\n{\n}\n\nstatic irqreturn_t wfx_spi_irq_handler(int irq, void *priv)\n{\n\tstruct wfx_spi_priv *bus = priv;\n\n\twfx_bh_request_rx(bus->core);\n\treturn IRQ_HANDLED;\n}\n\nstatic int wfx_spi_irq_subscribe(void *priv)\n{\n\tstruct wfx_spi_priv *bus = priv;\n\tu32 flags;\n\n\tflags = irq_get_trigger_type(bus->func->irq);\n\tif (!flags)\n\t\tflags = IRQF_TRIGGER_HIGH;\n\tflags |= IRQF_ONESHOT;\n\treturn devm_request_threaded_irq(&bus->func->dev, bus->func->irq, NULL,\n\t\t\t\t\t wfx_spi_irq_handler, flags, \"wfx\", bus);\n}\n\nstatic int wfx_spi_irq_unsubscribe(void *priv)\n{\n\tstruct wfx_spi_priv *bus = priv;\n\n\tdevm_free_irq(&bus->func->dev, bus->func->irq, bus);\n\treturn 0;\n}\n\nstatic size_t wfx_spi_align_size(void *priv, size_t size)\n{\n\t \n\treturn ALIGN(size, 4);\n}\n\nstatic const struct wfx_hwbus_ops wfx_spi_hwbus_ops = {\n\t.copy_from_io    = wfx_spi_copy_from_io,\n\t.copy_to_io      = wfx_spi_copy_to_io,\n\t.irq_subscribe   = wfx_spi_irq_subscribe,\n\t.irq_unsubscribe = wfx_spi_irq_unsubscribe,\n\t.lock            = wfx_spi_lock,\n\t.unlock          = wfx_spi_unlock,\n\t.align_size      = wfx_spi_align_size,\n};\n\nstatic int wfx_spi_probe(struct spi_device *func)\n{\n\tstruct wfx_platform_data *pdata;\n\tstruct wfx_spi_priv *bus;\n\tint ret;\n\n\tif (!func->bits_per_word)\n\t\tfunc->bits_per_word = 16;\n\tret = spi_setup(func);\n\tif (ret)\n\t\treturn ret;\n\tpdata = (struct wfx_platform_data *)spi_get_device_id(func)->driver_data;\n\tif (!pdata) {\n\t\tdev_err(&func->dev, \"unable to retrieve driver data (please report)\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tdev_dbg(&func->dev, \"SPI params: CS=%d, mode=%d bits/word=%d speed=%d\\n\",\n\t\tspi_get_chipselect(func, 0), func->mode, func->bits_per_word, func->max_speed_hz);\n\tif (func->bits_per_word != 16 && func->bits_per_word != 8)\n\t\tdev_warn(&func->dev, \"unusual bits/word value: %d\\n\", func->bits_per_word);\n\tif (func->max_speed_hz > 50000000)\n\t\tdev_warn(&func->dev, \"%dHz is a very high speed\\n\", func->max_speed_hz);\n\n\tbus = devm_kzalloc(&func->dev, sizeof(*bus), GFP_KERNEL);\n\tif (!bus)\n\t\treturn -ENOMEM;\n\tbus->func = func;\n\tif (func->bits_per_word == 8 || IS_ENABLED(CONFIG_CPU_BIG_ENDIAN))\n\t\tbus->need_swab = true;\n\tspi_set_drvdata(func, bus);\n\n\tbus->gpio_reset = devm_gpiod_get_optional(&func->dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(bus->gpio_reset))\n\t\treturn PTR_ERR(bus->gpio_reset);\n\tif (!bus->gpio_reset) {\n\t\tdev_warn(&func->dev, \"gpio reset is not defined, trying to load firmware anyway\\n\");\n\t} else {\n\t\tgpiod_set_consumer_name(bus->gpio_reset, \"wfx reset\");\n\t\tgpiod_set_value_cansleep(bus->gpio_reset, 1);\n\t\tusleep_range(100, 150);\n\t\tgpiod_set_value_cansleep(bus->gpio_reset, 0);\n\t\tusleep_range(2000, 2500);\n\t}\n\n\tbus->core = wfx_init_common(&func->dev, pdata, &wfx_spi_hwbus_ops, bus);\n\tif (!bus->core)\n\t\treturn -EIO;\n\n\treturn wfx_probe(bus->core);\n}\n\nstatic void wfx_spi_remove(struct spi_device *func)\n{\n\tstruct wfx_spi_priv *bus = spi_get_drvdata(func);\n\n\twfx_release(bus->core);\n}\n\n \nstatic const struct spi_device_id wfx_spi_id[] = {\n\t{ \"wf200\",    (kernel_ulong_t)&pdata_wf200 },\n\t{ \"brd4001a\", (kernel_ulong_t)&pdata_brd4001a },\n\t{ \"brd8022a\", (kernel_ulong_t)&pdata_brd8022a },\n\t{ \"brd8023a\", (kernel_ulong_t)&pdata_brd8023a },\n\t{ },\n};\nMODULE_DEVICE_TABLE(spi, wfx_spi_id);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id wfx_spi_of_match[] = {\n\t{ .compatible = \"silabs,wf200\" },\n\t{ .compatible = \"silabs,brd4001a\" },\n\t{ .compatible = \"silabs,brd8022a\" },\n\t{ .compatible = \"silabs,brd8023a\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, wfx_spi_of_match);\n#endif\n\nstruct spi_driver wfx_spi_driver = {\n\t.driver = {\n\t\t.name = \"wfx-spi\",\n\t\t.of_match_table = of_match_ptr(wfx_spi_of_match),\n\t},\n\t.id_table = wfx_spi_id,\n\t.probe = wfx_spi_probe,\n\t.remove = wfx_spi_remove,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}