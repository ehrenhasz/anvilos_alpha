{
  "module_name": "sta.c",
  "hash_id": "957b4bebc4a50679daa373d75d5cd4b12205c4aef14af3b06a1367806da77509",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/silabs/wfx/sta.c",
  "human_readable_source": "\n \n#include <linux/etherdevice.h>\n#include <net/mac80211.h>\n\n#include \"sta.h\"\n#include \"wfx.h\"\n#include \"fwio.h\"\n#include \"bh.h\"\n#include \"key.h\"\n#include \"scan.h\"\n#include \"debug.h\"\n#include \"hif_tx.h\"\n#include \"hif_tx_mib.h\"\n\n#define HIF_MAX_ARP_IP_ADDRTABLE_ENTRIES 2\n\nu32 wfx_rate_mask_to_hw(struct wfx_dev *wdev, u32 rates)\n{\n\tint i;\n\tu32 ret = 0;\n\t \n\tstruct ieee80211_supported_band *sband = wdev->hw->wiphy->bands[NL80211_BAND_2GHZ];\n\n\tfor (i = 0; i < sband->n_bitrates; i++) {\n\t\tif (rates & BIT(i)) {\n\t\t\tif (i >= sband->n_bitrates)\n\t\t\t\tdev_warn(wdev->dev, \"unsupported basic rate\\n\");\n\t\t\telse\n\t\t\t\tret |= BIT(sband->bitrates[i].hw_value);\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid wfx_cooling_timeout_work(struct work_struct *work)\n{\n\tstruct wfx_dev *wdev = container_of(to_delayed_work(work), struct wfx_dev,\n\t\t\t\t\t    cooling_timeout_work);\n\n\twdev->chip_frozen = true;\n\twfx_tx_unlock(wdev);\n}\n\nvoid wfx_suspend_hot_dev(struct wfx_dev *wdev, enum sta_notify_cmd cmd)\n{\n\tif (cmd == STA_NOTIFY_AWAKE) {\n\t\t \n\t\tif (cancel_delayed_work(&wdev->cooling_timeout_work))\n\t\t\twfx_tx_unlock(wdev);\n\t} else {\n\t\t \n\t\tschedule_delayed_work(&wdev->cooling_timeout_work, 10 * HZ);\n\t\twfx_tx_lock(wdev);\n\t}\n}\n\nstatic void wfx_filter_beacon(struct wfx_vif *wvif, bool filter_beacon)\n{\n\tstatic const struct wfx_hif_ie_table_entry filter_ies[] = {\n\t\t{\n\t\t\t.ie_id        = WLAN_EID_VENDOR_SPECIFIC,\n\t\t\t.has_changed  = 1,\n\t\t\t.no_longer    = 1,\n\t\t\t.has_appeared = 1,\n\t\t\t.oui          = { 0x50, 0x6F, 0x9A },\n\t\t}, {\n\t\t\t.ie_id        = WLAN_EID_HT_OPERATION,\n\t\t\t.has_changed  = 1,\n\t\t\t.no_longer    = 1,\n\t\t\t.has_appeared = 1,\n\t\t}, {\n\t\t\t.ie_id        = WLAN_EID_ERP_INFO,\n\t\t\t.has_changed  = 1,\n\t\t\t.no_longer    = 1,\n\t\t\t.has_appeared = 1,\n\t\t}, {\n\t\t\t.ie_id        = WLAN_EID_CHANNEL_SWITCH,\n\t\t\t.has_changed  = 1,\n\t\t\t.no_longer    = 1,\n\t\t\t.has_appeared = 1,\n\t\t}\n\t};\n\n\tif (!filter_beacon) {\n\t\twfx_hif_beacon_filter_control(wvif, 0, 1);\n\t} else {\n\t\twfx_hif_set_beacon_filter_table(wvif, ARRAY_SIZE(filter_ies), filter_ies);\n\t\twfx_hif_beacon_filter_control(wvif, HIF_BEACON_FILTER_ENABLE, 0);\n\t}\n}\n\nvoid wfx_configure_filter(struct ieee80211_hw *hw, unsigned int changed_flags,\n\t\t\t  unsigned int *total_flags, u64 unused)\n{\n\tbool filter_bssid, filter_prbreq, filter_beacon;\n\tstruct ieee80211_vif *vif = NULL;\n\tstruct wfx_dev *wdev = hw->priv;\n\tstruct wfx_vif *wvif = NULL;\n\n\t \n\t*total_flags &= FIF_BCN_PRBRESP_PROMISC | FIF_ALLMULTI | FIF_OTHER_BSS |\n\t\t\tFIF_PROBE_REQ | FIF_PSPOLL;\n\n\tmutex_lock(&wdev->conf_mutex);\n\twhile ((wvif = wvif_iterate(wdev, wvif)) != NULL) {\n\t\tmutex_lock(&wvif->scan_lock);\n\n\t\t \n\t\tif (*total_flags & FIF_BCN_PRBRESP_PROMISC)\n\t\t\tfilter_beacon = false;\n\t\telse\n\t\t\tfilter_beacon = true;\n\t\twfx_filter_beacon(wvif, filter_beacon);\n\n\t\tif (*total_flags & FIF_OTHER_BSS)\n\t\t\tfilter_bssid = false;\n\t\telse\n\t\t\tfilter_bssid = true;\n\n\t\tvif = wvif_to_vif(wvif);\n\t\t \n\t\tif (*total_flags & FIF_PROBE_REQ && vif->type == NL80211_IFTYPE_AP) {\n\t\t\tdev_dbg(wdev->dev, \"do not forward probe request in AP mode\\n\");\n\t\t\t*total_flags &= ~FIF_PROBE_REQ;\n\t\t}\n\n\t\tif (*total_flags & FIF_PROBE_REQ)\n\t\t\tfilter_prbreq = false;\n\t\telse\n\t\t\tfilter_prbreq = true;\n\t\twfx_hif_set_rx_filter(wvif, filter_bssid, filter_prbreq);\n\n\t\tmutex_unlock(&wvif->scan_lock);\n\t}\n\tmutex_unlock(&wdev->conf_mutex);\n}\n\nstatic int wfx_get_ps_timeout(struct wfx_vif *wvif, bool *enable_ps)\n{\n\tstruct ieee80211_channel *chan0 = NULL, *chan1 = NULL;\n\tstruct ieee80211_conf *conf = &wvif->wdev->hw->conf;\n\tstruct ieee80211_vif *vif = wvif_to_vif(wvif);\n\n\tWARN(!vif->cfg.assoc && enable_ps,\n\t     \"enable_ps is reliable only if associated\");\n\tif (wdev_to_wvif(wvif->wdev, 0)) {\n\t\tstruct wfx_vif *wvif_ch0 = wdev_to_wvif(wvif->wdev, 0);\n\t\tstruct ieee80211_vif *vif_ch0 = wvif_to_vif(wvif_ch0);\n\n\t\tchan0 = vif_ch0->bss_conf.chandef.chan;\n\t}\n\tif (wdev_to_wvif(wvif->wdev, 1)) {\n\t\tstruct wfx_vif *wvif_ch1 = wdev_to_wvif(wvif->wdev, 1);\n\t\tstruct ieee80211_vif *vif_ch1 = wvif_to_vif(wvif_ch1);\n\n\t\tchan1 = vif_ch1->bss_conf.chandef.chan;\n\t}\n\tif (chan0 && chan1 && vif->type != NL80211_IFTYPE_AP) {\n\t\tif (chan0->hw_value == chan1->hw_value) {\n\t\t\t \n\t\t\tif (enable_ps)\n\t\t\t\t*enable_ps = false;\n\t\t\tif (vif->cfg.assoc && vif->cfg.ps)\n\t\t\t\tdev_info(wvif->wdev->dev, \"ignoring requested PS mode\");\n\t\t\treturn -1;\n\t\t}\n\t\t \n\t\tif (enable_ps)\n\t\t\t*enable_ps = true;\n\t\tif (wfx_api_older_than(wvif->wdev, 3, 2))\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn 30;\n\t}\n\tif (enable_ps)\n\t\t*enable_ps = vif->cfg.ps;\n\tif (vif->cfg.assoc && vif->cfg.ps)\n\t\treturn conf->dynamic_ps_timeout;\n\telse\n\t\treturn -1;\n}\n\nint wfx_update_pm(struct wfx_vif *wvif)\n{\n\tstruct ieee80211_vif *vif = wvif_to_vif(wvif);\n\tint ps_timeout;\n\tbool ps;\n\n\tif (!vif->cfg.assoc)\n\t\treturn 0;\n\tps_timeout = wfx_get_ps_timeout(wvif, &ps);\n\tif (!ps)\n\t\tps_timeout = 0;\n\tWARN_ON(ps_timeout < 0);\n\tif (wvif->uapsd_mask)\n\t\tps_timeout = 0;\n\n\tif (!wait_for_completion_timeout(&wvif->set_pm_mode_complete, TU_TO_JIFFIES(512)))\n\t\tdev_warn(wvif->wdev->dev, \"timeout while waiting of set_pm_mode_complete\\n\");\n\treturn wfx_hif_set_pm(wvif, ps, ps_timeout);\n}\n\nint wfx_conf_tx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\tunsigned int link_id, u16 queue,\n\t\tconst struct ieee80211_tx_queue_params *params)\n{\n\tstruct wfx_dev *wdev = hw->priv;\n\tstruct wfx_vif *wvif = (struct wfx_vif *)vif->drv_priv;\n\tint old_uapsd = wvif->uapsd_mask;\n\n\tWARN_ON(queue >= hw->queues);\n\n\tmutex_lock(&wdev->conf_mutex);\n\tassign_bit(queue, &wvif->uapsd_mask, params->uapsd);\n\twfx_hif_set_edca_queue_params(wvif, queue, params);\n\tif (vif->type == NL80211_IFTYPE_STATION &&\n\t    old_uapsd != wvif->uapsd_mask) {\n\t\twfx_hif_set_uapsd_info(wvif, wvif->uapsd_mask);\n\t\twfx_update_pm(wvif);\n\t}\n\tmutex_unlock(&wdev->conf_mutex);\n\treturn 0;\n}\n\nint wfx_set_rts_threshold(struct ieee80211_hw *hw, u32 value)\n{\n\tstruct wfx_dev *wdev = hw->priv;\n\tstruct wfx_vif *wvif = NULL;\n\n\twhile ((wvif = wvif_iterate(wdev, wvif)) != NULL)\n\t\twfx_hif_rts_threshold(wvif, value);\n\treturn 0;\n}\n\nvoid wfx_event_report_rssi(struct wfx_vif *wvif, u8 raw_rcpi_rssi)\n{\n\t \n\tstruct ieee80211_vif *vif = wvif_to_vif(wvif);\n\tint rcpi_rssi;\n\tint cqm_evt;\n\n\trcpi_rssi = raw_rcpi_rssi / 2 - 110;\n\tif (rcpi_rssi <= vif->bss_conf.cqm_rssi_thold)\n\t\tcqm_evt = NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW;\n\telse\n\t\tcqm_evt = NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH;\n\tieee80211_cqm_rssi_notify(vif, cqm_evt, rcpi_rssi, GFP_KERNEL);\n}\n\nstatic void wfx_beacon_loss_work(struct work_struct *work)\n{\n\tstruct wfx_vif *wvif = container_of(to_delayed_work(work), struct wfx_vif,\n\t\t\t\t\t    beacon_loss_work);\n\tstruct ieee80211_vif *vif = wvif_to_vif(wvif);\n\tstruct ieee80211_bss_conf *bss_conf = &vif->bss_conf;\n\n\tieee80211_beacon_loss(vif);\n\tschedule_delayed_work(to_delayed_work(work), msecs_to_jiffies(bss_conf->beacon_int));\n}\n\nvoid wfx_set_default_unicast_key(struct ieee80211_hw *hw, struct ieee80211_vif *vif, int idx)\n{\n\tstruct wfx_vif *wvif = (struct wfx_vif *)vif->drv_priv;\n\n\twfx_hif_wep_default_key_id(wvif, idx);\n}\n\nvoid wfx_reset(struct wfx_vif *wvif)\n{\n\tstruct wfx_dev *wdev = wvif->wdev;\n\n\twfx_tx_lock_flush(wdev);\n\twfx_hif_reset(wvif, false);\n\twfx_tx_policy_init(wvif);\n\tif (wvif_count(wdev) <= 1)\n\t\twfx_hif_set_block_ack_policy(wvif, 0xFF, 0xFF);\n\twfx_tx_unlock(wdev);\n\twvif->join_in_progress = false;\n\tcancel_delayed_work_sync(&wvif->beacon_loss_work);\n\twvif =  NULL;\n\twhile ((wvif = wvif_iterate(wdev, wvif)) != NULL)\n\t\twfx_update_pm(wvif);\n}\n\nint wfx_sta_add(struct ieee80211_hw *hw, struct ieee80211_vif *vif, struct ieee80211_sta *sta)\n{\n\tstruct wfx_vif *wvif = (struct wfx_vif *)vif->drv_priv;\n\tstruct wfx_sta_priv *sta_priv = (struct wfx_sta_priv *)&sta->drv_priv;\n\n\tsta_priv->vif_id = wvif->id;\n\n\tif (vif->type == NL80211_IFTYPE_STATION)\n\t\twfx_hif_set_mfp(wvif, sta->mfp, sta->mfp);\n\n\t \n\tif (vif->type == NL80211_IFTYPE_STATION && !sta->tdls)\n\t\treturn 0;\n\tsta_priv->link_id = ffz(wvif->link_id_map);\n\twvif->link_id_map |= BIT(sta_priv->link_id);\n\tWARN_ON(!sta_priv->link_id);\n\tWARN_ON(sta_priv->link_id >= HIF_LINK_ID_MAX);\n\twfx_hif_map_link(wvif, false, sta->addr, sta_priv->link_id, sta->mfp);\n\n\treturn 0;\n}\n\nint wfx_sta_remove(struct ieee80211_hw *hw, struct ieee80211_vif *vif, struct ieee80211_sta *sta)\n{\n\tstruct wfx_vif *wvif = (struct wfx_vif *)vif->drv_priv;\n\tstruct wfx_sta_priv *sta_priv = (struct wfx_sta_priv *)&sta->drv_priv;\n\n\t \n\tif (!sta_priv->link_id)\n\t\treturn 0;\n\t \n\twfx_hif_map_link(wvif, true, sta->addr, sta_priv->link_id, false);\n\twvif->link_id_map &= ~BIT(sta_priv->link_id);\n\treturn 0;\n}\n\nstatic int wfx_upload_ap_templates(struct wfx_vif *wvif)\n{\n\tstruct ieee80211_vif *vif = wvif_to_vif(wvif);\n\tstruct sk_buff *skb;\n\n\tskb = ieee80211_beacon_get(wvif->wdev->hw, vif, 0);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\twfx_hif_set_template_frame(wvif, skb, HIF_TMPLT_BCN, API_RATE_INDEX_B_1MBPS);\n\tdev_kfree_skb(skb);\n\n\tskb = ieee80211_proberesp_get(wvif->wdev->hw, vif);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\twfx_hif_set_template_frame(wvif, skb, HIF_TMPLT_PRBRES, API_RATE_INDEX_B_1MBPS);\n\tdev_kfree_skb(skb);\n\treturn 0;\n}\n\nstatic void wfx_set_mfp_ap(struct wfx_vif *wvif)\n{\n\tstruct ieee80211_vif *vif = wvif_to_vif(wvif);\n\tstruct sk_buff *skb = ieee80211_beacon_get(wvif->wdev->hw, vif, 0);\n\tconst int ieoffset = offsetof(struct ieee80211_mgmt, u.beacon.variable);\n\tconst u16 *ptr = (u16 *)cfg80211_find_ie(WLAN_EID_RSN, skb->data + ieoffset,\n\t\t\t\t\t\t skb->len - ieoffset);\n\tconst int pairwise_cipher_suite_count_offset = 8 / sizeof(u16);\n\tconst int pairwise_cipher_suite_size = 4 / sizeof(u16);\n\tconst int akm_suite_size = 4 / sizeof(u16);\n\n\tif (ptr) {\n\t\tptr += pairwise_cipher_suite_count_offset;\n\t\tif (WARN_ON(ptr > (u16 *)skb_tail_pointer(skb)))\n\t\t\treturn;\n\t\tptr += 1 + pairwise_cipher_suite_size * *ptr;\n\t\tif (WARN_ON(ptr > (u16 *)skb_tail_pointer(skb)))\n\t\t\treturn;\n\t\tptr += 1 + akm_suite_size * *ptr;\n\t\tif (WARN_ON(ptr > (u16 *)skb_tail_pointer(skb)))\n\t\t\treturn;\n\t\twfx_hif_set_mfp(wvif, *ptr & BIT(7), *ptr & BIT(6));\n\t}\n}\n\nint wfx_start_ap(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t struct ieee80211_bss_conf *link_conf)\n{\n\tstruct wfx_vif *wvif = (struct wfx_vif *)vif->drv_priv;\n\tstruct wfx_dev *wdev = wvif->wdev;\n\tint ret;\n\n\twvif =  NULL;\n\twhile ((wvif = wvif_iterate(wdev, wvif)) != NULL)\n\t\twfx_update_pm(wvif);\n\twvif = (struct wfx_vif *)vif->drv_priv;\n\twfx_upload_ap_templates(wvif);\n\tret = wfx_hif_start(wvif, &vif->bss_conf, wvif->channel);\n\tif (ret > 0)\n\t\treturn -EIO;\n\twfx_set_mfp_ap(wvif);\n\treturn ret;\n}\n\nvoid wfx_stop_ap(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t struct ieee80211_bss_conf *link_conf)\n{\n\tstruct wfx_vif *wvif = (struct wfx_vif *)vif->drv_priv;\n\n\twfx_reset(wvif);\n}\n\nstatic void wfx_join(struct wfx_vif *wvif)\n{\n\tstruct ieee80211_vif *vif = wvif_to_vif(wvif);\n\tstruct ieee80211_bss_conf *conf = &vif->bss_conf;\n\tstruct cfg80211_bss *bss = NULL;\n\tu8 ssid[IEEE80211_MAX_SSID_LEN];\n\tconst u8 *ssid_ie = NULL;\n\tint ssid_len = 0;\n\tint ret;\n\n\twfx_tx_lock_flush(wvif->wdev);\n\n\tbss = cfg80211_get_bss(wvif->wdev->hw->wiphy, wvif->channel, conf->bssid, NULL, 0,\n\t\t\t       IEEE80211_BSS_TYPE_ANY, IEEE80211_PRIVACY_ANY);\n\tif (!bss && !vif->cfg.ibss_joined) {\n\t\twfx_tx_unlock(wvif->wdev);\n\t\treturn;\n\t}\n\n\trcu_read_lock();  \n\tif (bss)\n\t\tssid_ie = ieee80211_bss_get_ie(bss, WLAN_EID_SSID);\n\tif (ssid_ie) {\n\t\tssid_len = ssid_ie[1];\n\t\tif (ssid_len > IEEE80211_MAX_SSID_LEN)\n\t\t\tssid_len = IEEE80211_MAX_SSID_LEN;\n\t\tmemcpy(ssid, &ssid_ie[2], ssid_len);\n\t}\n\trcu_read_unlock();\n\n\tcfg80211_put_bss(wvif->wdev->hw->wiphy, bss);\n\n\twvif->join_in_progress = true;\n\tret = wfx_hif_join(wvif, conf, wvif->channel, ssid, ssid_len);\n\tif (ret) {\n\t\tieee80211_connection_loss(vif);\n\t\twfx_reset(wvif);\n\t} else {\n\t\t \n\t\twfx_filter_beacon(wvif, false);\n\t}\n\twfx_tx_unlock(wvif->wdev);\n}\n\nstatic void wfx_join_finalize(struct wfx_vif *wvif, struct ieee80211_bss_conf *info)\n{\n\tstruct ieee80211_vif *vif = wvif_to_vif(wvif);\n\tstruct ieee80211_sta *sta = NULL;\n\tint ampdu_density = 0;\n\tbool greenfield = false;\n\n\trcu_read_lock();  \n\tif (info->bssid && !vif->cfg.ibss_joined)\n\t\tsta = ieee80211_find_sta(vif, info->bssid);\n\tif (sta && sta->deflink.ht_cap.ht_supported)\n\t\tampdu_density = sta->deflink.ht_cap.ampdu_density;\n\tif (sta && sta->deflink.ht_cap.ht_supported &&\n\t    !(info->ht_operation_mode & IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT))\n\t\tgreenfield = !!(sta->deflink.ht_cap.cap & IEEE80211_HT_CAP_GRN_FLD);\n\trcu_read_unlock();\n\n\twvif->join_in_progress = false;\n\twfx_hif_set_association_mode(wvif, ampdu_density, greenfield, info->use_short_preamble);\n\twfx_hif_keep_alive_period(wvif, 0);\n\t \n\twfx_hif_set_bss_params(wvif, vif->cfg.aid, 7);\n\twfx_hif_set_beacon_wakeup_period(wvif, 1, 1);\n\twfx_update_pm(wvif);\n}\n\nint wfx_join_ibss(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\n{\n\tstruct wfx_vif *wvif = (struct wfx_vif *)vif->drv_priv;\n\n\twfx_upload_ap_templates(wvif);\n\twfx_join(wvif);\n\treturn 0;\n}\n\nvoid wfx_leave_ibss(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\n{\n\tstruct wfx_vif *wvif = (struct wfx_vif *)vif->drv_priv;\n\n\twfx_reset(wvif);\n}\n\nstatic void wfx_enable_beacon(struct wfx_vif *wvif, bool enable)\n{\n\t \n\tif (!enable && wfx_tx_queues_has_cab(wvif)) {\n\t\twvif->after_dtim_tx_allowed = true;\n\t\twfx_bh_request_tx(wvif->wdev);\n\t}\n\twfx_hif_beacon_transmit(wvif, enable);\n}\n\nvoid wfx_bss_info_changed(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t  struct ieee80211_bss_conf *info, u64 changed)\n{\n\tstruct wfx_dev *wdev = hw->priv;\n\tstruct wfx_vif *wvif = (struct wfx_vif *)vif->drv_priv;\n\tint i;\n\n\tmutex_lock(&wdev->conf_mutex);\n\n\tif (changed & BSS_CHANGED_BASIC_RATES ||\n\t    changed & BSS_CHANGED_BEACON_INT ||\n\t    changed & BSS_CHANGED_BSSID) {\n\t\tif (vif->type == NL80211_IFTYPE_STATION)\n\t\t\twfx_join(wvif);\n\t}\n\n\tif (changed & BSS_CHANGED_ASSOC) {\n\t\tif (vif->cfg.assoc || vif->cfg.ibss_joined)\n\t\t\twfx_join_finalize(wvif, info);\n\t\telse if (!vif->cfg.assoc && vif->type == NL80211_IFTYPE_STATION)\n\t\t\twfx_reset(wvif);\n\t\telse\n\t\t\tdev_warn(wdev->dev, \"misunderstood change: ASSOC\\n\");\n\t}\n\n\tif (changed & BSS_CHANGED_BEACON_INFO) {\n\t\tif (vif->type != NL80211_IFTYPE_STATION)\n\t\t\tdev_warn(wdev->dev, \"misunderstood change: BEACON_INFO\\n\");\n\t\twfx_hif_set_beacon_wakeup_period(wvif, info->dtim_period, info->dtim_period);\n\t\t \n\t\twfx_filter_beacon(wvif, true);\n\t}\n\n\tif (changed & BSS_CHANGED_ARP_FILTER) {\n\t\tfor (i = 0; i < HIF_MAX_ARP_IP_ADDRTABLE_ENTRIES; i++) {\n\t\t\t__be32 *arp_addr = &vif->cfg.arp_addr_list[i];\n\n\t\t\tif (vif->cfg.arp_addr_cnt > HIF_MAX_ARP_IP_ADDRTABLE_ENTRIES)\n\t\t\t\tarp_addr = NULL;\n\t\t\tif (i >= vif->cfg.arp_addr_cnt)\n\t\t\t\tarp_addr = NULL;\n\t\t\twfx_hif_set_arp_ipv4_filter(wvif, i, arp_addr);\n\t\t}\n\t}\n\n\tif (changed & BSS_CHANGED_AP_PROBE_RESP || changed & BSS_CHANGED_BEACON)\n\t\twfx_upload_ap_templates(wvif);\n\n\tif (changed & BSS_CHANGED_BEACON_ENABLED)\n\t\twfx_enable_beacon(wvif, info->enable_beacon);\n\n\tif (changed & BSS_CHANGED_KEEP_ALIVE)\n\t\twfx_hif_keep_alive_period(wvif,\n\t\t\t\t\t  info->max_idle_period * USEC_PER_TU / USEC_PER_MSEC);\n\n\tif (changed & BSS_CHANGED_ERP_CTS_PROT)\n\t\twfx_hif_erp_use_protection(wvif, info->use_cts_prot);\n\n\tif (changed & BSS_CHANGED_ERP_SLOT)\n\t\twfx_hif_slot_time(wvif, info->use_short_slot ? 9 : 20);\n\n\tif (changed & BSS_CHANGED_CQM)\n\t\twfx_hif_set_rcpi_rssi_threshold(wvif, info->cqm_rssi_thold, info->cqm_rssi_hyst);\n\n\tif (changed & BSS_CHANGED_TXPOWER)\n\t\twfx_hif_set_output_power(wvif, info->txpower);\n\n\tif (changed & BSS_CHANGED_PS)\n\t\twfx_update_pm(wvif);\n\n\tmutex_unlock(&wdev->conf_mutex);\n}\n\nstatic int wfx_update_tim(struct wfx_vif *wvif)\n{\n\tstruct ieee80211_vif *vif = wvif_to_vif(wvif);\n\tstruct sk_buff *skb;\n\tu16 tim_offset, tim_length;\n\tu8 *tim_ptr;\n\n\tskb = ieee80211_beacon_get_tim(wvif->wdev->hw, vif, &tim_offset,\n\t\t\t\t       &tim_length, 0);\n\tif (!skb)\n\t\treturn -ENOENT;\n\ttim_ptr = skb->data + tim_offset;\n\n\tif (tim_offset && tim_length >= 6) {\n\t\t \n\t\ttim_ptr[2] = 0;\n\n\t\t \n\t\tif (wfx_tx_queues_has_cab(wvif))\n\t\t\ttim_ptr[4] |= 1;\n\t\telse\n\t\t\ttim_ptr[4] &= ~1;\n\t}\n\n\twfx_hif_update_ie_beacon(wvif, tim_ptr, tim_length);\n\tdev_kfree_skb(skb);\n\n\treturn 0;\n}\n\nstatic void wfx_update_tim_work(struct work_struct *work)\n{\n\tstruct wfx_vif *wvif = container_of(work, struct wfx_vif, update_tim_work);\n\n\twfx_update_tim(wvif);\n}\n\nint wfx_set_tim(struct ieee80211_hw *hw, struct ieee80211_sta *sta, bool set)\n{\n\tstruct wfx_dev *wdev = hw->priv;\n\tstruct wfx_sta_priv *sta_dev = (struct wfx_sta_priv *)&sta->drv_priv;\n\tstruct wfx_vif *wvif = wdev_to_wvif(wdev, sta_dev->vif_id);\n\n\tif (!wvif) {\n\t\tdev_warn(wdev->dev, \"%s: received event for non-existent vif\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\tschedule_work(&wvif->update_tim_work);\n\treturn 0;\n}\n\nvoid wfx_suspend_resume_mc(struct wfx_vif *wvif, enum sta_notify_cmd notify_cmd)\n{\n\tstruct wfx_vif *wvif_it;\n\n\tif (notify_cmd != STA_NOTIFY_AWAKE)\n\t\treturn;\n\n\t \n\twvif_it = NULL;\n\twhile ((wvif_it = wvif_iterate(wvif->wdev, wvif_it)) != NULL)\n\t\tif (mutex_is_locked(&wvif_it->scan_lock))\n\t\t\treturn;\n\n\tif (!wfx_tx_queues_has_cab(wvif) || wvif->after_dtim_tx_allowed)\n\t\tdev_warn(wvif->wdev->dev, \"incorrect sequence (%d CAB in queue)\",\n\t\t\t wfx_tx_queues_has_cab(wvif));\n\twvif->after_dtim_tx_allowed = true;\n\twfx_bh_request_tx(wvif->wdev);\n}\n\nint wfx_ampdu_action(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t     struct ieee80211_ampdu_params *params)\n{\n\t \n\tswitch (params->action) {\n\tcase IEEE80211_AMPDU_RX_START:\n\tcase IEEE80211_AMPDU_RX_STOP:\n\t\t \n\t\treturn 0;\n\tdefault:\n\t\t \n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nint wfx_add_chanctx(struct ieee80211_hw *hw, struct ieee80211_chanctx_conf *conf)\n{\n\treturn 0;\n}\n\nvoid wfx_remove_chanctx(struct ieee80211_hw *hw, struct ieee80211_chanctx_conf *conf)\n{\n}\n\nvoid wfx_change_chanctx(struct ieee80211_hw *hw, struct ieee80211_chanctx_conf *conf, u32 changed)\n{\n}\n\nint wfx_assign_vif_chanctx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t   struct ieee80211_bss_conf *link_conf,\n\t\t\t   struct ieee80211_chanctx_conf *conf)\n{\n\tstruct wfx_vif *wvif = (struct wfx_vif *)vif->drv_priv;\n\tstruct ieee80211_channel *ch = conf->def.chan;\n\n\tWARN(wvif->channel, \"channel overwrite\");\n\twvif->channel = ch;\n\n\treturn 0;\n}\n\nvoid wfx_unassign_vif_chanctx(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t      struct ieee80211_bss_conf *link_conf,\n\t\t\t      struct ieee80211_chanctx_conf *conf)\n{\n\tstruct wfx_vif *wvif = (struct wfx_vif *)vif->drv_priv;\n\tstruct ieee80211_channel *ch = conf->def.chan;\n\n\tWARN(wvif->channel != ch, \"channel mismatch\");\n\twvif->channel = NULL;\n}\n\nint wfx_config(struct ieee80211_hw *hw, u32 changed)\n{\n\treturn 0;\n}\n\nint wfx_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\n{\n\tint i;\n\tstruct wfx_dev *wdev = hw->priv;\n\tstruct wfx_vif *wvif = (struct wfx_vif *)vif->drv_priv;\n\n\tvif->driver_flags |= IEEE80211_VIF_BEACON_FILTER |\n\t\t\t     IEEE80211_VIF_SUPPORTS_UAPSD |\n\t\t\t     IEEE80211_VIF_SUPPORTS_CQM_RSSI;\n\n\tmutex_lock(&wdev->conf_mutex);\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_AP:\n\t\tbreak;\n\tdefault:\n\t\tmutex_unlock(&wdev->conf_mutex);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\twvif->wdev = wdev;\n\n\twvif->link_id_map = 1;  \n\tINIT_WORK(&wvif->update_tim_work, wfx_update_tim_work);\n\tINIT_DELAYED_WORK(&wvif->beacon_loss_work, wfx_beacon_loss_work);\n\n\tinit_completion(&wvif->set_pm_mode_complete);\n\tcomplete(&wvif->set_pm_mode_complete);\n\tINIT_WORK(&wvif->tx_policy_upload_work, wfx_tx_policy_upload_work);\n\n\tmutex_init(&wvif->scan_lock);\n\tinit_completion(&wvif->scan_complete);\n\tINIT_WORK(&wvif->scan_work, wfx_hw_scan_work);\n\n\twfx_tx_queues_init(wvif);\n\twfx_tx_policy_init(wvif);\n\n\tfor (i = 0; i < ARRAY_SIZE(wdev->vif); i++) {\n\t\tif (!wdev->vif[i]) {\n\t\t\twdev->vif[i] = vif;\n\t\t\twvif->id = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tWARN(i == ARRAY_SIZE(wdev->vif), \"try to instantiate more vif than supported\");\n\n\twfx_hif_set_macaddr(wvif, vif->addr);\n\n\tmutex_unlock(&wdev->conf_mutex);\n\n\twvif = NULL;\n\twhile ((wvif = wvif_iterate(wdev, wvif)) != NULL) {\n\t\t \n\t\tif (wvif_count(wdev) == 1)\n\t\t\twfx_hif_set_block_ack_policy(wvif, 0xFF, 0xFF);\n\t\telse\n\t\t\twfx_hif_set_block_ack_policy(wvif, 0x00, 0x00);\n\t}\n\treturn 0;\n}\n\nvoid wfx_remove_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)\n{\n\tstruct wfx_dev *wdev = hw->priv;\n\tstruct wfx_vif *wvif = (struct wfx_vif *)vif->drv_priv;\n\n\twait_for_completion_timeout(&wvif->set_pm_mode_complete, msecs_to_jiffies(300));\n\twfx_tx_queues_check_empty(wvif);\n\n\tmutex_lock(&wdev->conf_mutex);\n\tWARN(wvif->link_id_map != 1, \"corrupted state\");\n\n\twfx_hif_reset(wvif, false);\n\twfx_hif_set_macaddr(wvif, NULL);\n\twfx_tx_policy_init(wvif);\n\n\tcancel_delayed_work_sync(&wvif->beacon_loss_work);\n\twdev->vif[wvif->id] = NULL;\n\n\tmutex_unlock(&wdev->conf_mutex);\n\n\twvif = NULL;\n\twhile ((wvif = wvif_iterate(wdev, wvif)) != NULL) {\n\t\t \n\t\tif (wvif_count(wdev) == 1)\n\t\t\twfx_hif_set_block_ack_policy(wvif, 0xFF, 0xFF);\n\t\telse\n\t\t\twfx_hif_set_block_ack_policy(wvif, 0x00, 0x00);\n\t}\n}\n\nint wfx_start(struct ieee80211_hw *hw)\n{\n\treturn 0;\n}\n\nvoid wfx_stop(struct ieee80211_hw *hw)\n{\n\tstruct wfx_dev *wdev = hw->priv;\n\n\tWARN_ON(!skb_queue_empty_lockless(&wdev->tx_pending));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}