{
  "module_name": "hif_tx_mib.c",
  "hash_id": "83e43cf0d10f93fe7a54c8db709659766b54f7857a0c22758e160f52cbfd4b34",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/silabs/wfx/hif_tx_mib.c",
  "human_readable_source": "\n \n\n#include <linux/etherdevice.h>\n\n#include \"wfx.h\"\n#include \"hif_tx.h\"\n#include \"hif_tx_mib.h\"\n#include \"hif_api_mib.h\"\n\nint wfx_hif_set_output_power(struct wfx_vif *wvif, int val)\n{\n\tstruct wfx_hif_mib_current_tx_power_level arg = {\n\t\t.power_level = cpu_to_le32(val * 10),\n\t};\n\n\treturn wfx_hif_write_mib(wvif->wdev, wvif->id, HIF_MIB_ID_CURRENT_TX_POWER_LEVEL,\n\t\t\t\t &arg, sizeof(arg));\n}\n\nint wfx_hif_set_beacon_wakeup_period(struct wfx_vif *wvif,\n\t\t\t\t     unsigned int dtim_interval, unsigned int listen_interval)\n{\n\tstruct wfx_hif_mib_beacon_wake_up_period arg = {\n\t\t.wakeup_period_min = dtim_interval,\n\t\t.receive_dtim = 0,\n\t\t.wakeup_period_max = listen_interval,\n\t};\n\n\tif (dtim_interval > 0xFF || listen_interval > 0xFFFF)\n\t\treturn -EINVAL;\n\treturn wfx_hif_write_mib(wvif->wdev, wvif->id, HIF_MIB_ID_BEACON_WAKEUP_PERIOD,\n\t\t\t\t &arg, sizeof(arg));\n}\n\nint wfx_hif_set_rcpi_rssi_threshold(struct wfx_vif *wvif, int rssi_thold, int rssi_hyst)\n{\n\tstruct wfx_hif_mib_rcpi_rssi_threshold arg = {\n\t\t.rolling_average_count = 8,\n\t\t.detection = 1,\n\t};\n\n\tif (!rssi_thold && !rssi_hyst) {\n\t\targ.upperthresh = 1;\n\t\targ.lowerthresh = 1;\n\t} else {\n\t\targ.upper_threshold = rssi_thold + rssi_hyst;\n\t\targ.upper_threshold = (arg.upper_threshold + 110) * 2;\n\t\targ.lower_threshold = rssi_thold;\n\t\targ.lower_threshold = (arg.lower_threshold + 110) * 2;\n\t}\n\n\treturn wfx_hif_write_mib(wvif->wdev, wvif->id, HIF_MIB_ID_RCPI_RSSI_THRESHOLD,\n\t\t\t\t &arg, sizeof(arg));\n}\n\nint wfx_hif_get_counters_table(struct wfx_dev *wdev, int vif_id,\n\t\t\t       struct wfx_hif_mib_extended_count_table *arg)\n{\n\tif (wfx_api_older_than(wdev, 1, 3)) {\n\t\t \n\t\tmemset(arg, 0xFF, sizeof(*arg));\n\t\treturn wfx_hif_read_mib(wdev, vif_id, HIF_MIB_ID_COUNTERS_TABLE,\n\t\t\t\t    arg, sizeof(struct wfx_hif_mib_count_table));\n\t} else {\n\t\treturn wfx_hif_read_mib(wdev, vif_id, HIF_MIB_ID_EXTENDED_COUNTERS_TABLE,\n\t\t\t\t\targ, sizeof(struct wfx_hif_mib_extended_count_table));\n\t}\n}\n\nint wfx_hif_set_macaddr(struct wfx_vif *wvif, u8 *mac)\n{\n\tstruct wfx_hif_mib_mac_address arg = { };\n\n\tif (mac)\n\t\tether_addr_copy(arg.mac_addr, mac);\n\treturn wfx_hif_write_mib(wvif->wdev, wvif->id, HIF_MIB_ID_DOT11_MAC_ADDRESS,\n\t\t\t\t &arg, sizeof(arg));\n}\n\nint wfx_hif_set_rx_filter(struct wfx_vif *wvif, bool filter_bssid, bool filter_prbreq)\n{\n\tstruct wfx_hif_mib_rx_filter arg = { };\n\n\tif (filter_bssid)\n\t\targ.bssid_filter = 1;\n\tif (!filter_prbreq)\n\t\targ.fwd_probe_req = 1;\n\treturn wfx_hif_write_mib(wvif->wdev, wvif->id, HIF_MIB_ID_RX_FILTER, &arg, sizeof(arg));\n}\n\nint wfx_hif_set_beacon_filter_table(struct wfx_vif *wvif, int tbl_len,\n\t\t\t\t    const struct wfx_hif_ie_table_entry *tbl)\n{\n\tint ret;\n\tstruct wfx_hif_mib_bcn_filter_table *arg;\n\tint buf_len = struct_size(arg, ie_table, tbl_len);\n\n\targ = kzalloc(buf_len, GFP_KERNEL);\n\tif (!arg)\n\t\treturn -ENOMEM;\n\targ->num_of_info_elmts = cpu_to_le32(tbl_len);\n\tmemcpy(arg->ie_table, tbl, flex_array_size(arg, ie_table, tbl_len));\n\tret = wfx_hif_write_mib(wvif->wdev, wvif->id, HIF_MIB_ID_BEACON_FILTER_TABLE,\n\t\t\t\targ, buf_len);\n\tkfree(arg);\n\treturn ret;\n}\n\nint wfx_hif_beacon_filter_control(struct wfx_vif *wvif, int enable, int beacon_count)\n{\n\tstruct wfx_hif_mib_bcn_filter_enable arg = {\n\t\t.enable = cpu_to_le32(enable),\n\t\t.bcn_count = cpu_to_le32(beacon_count),\n\t};\n\treturn wfx_hif_write_mib(wvif->wdev, wvif->id, HIF_MIB_ID_BEACON_FILTER_ENABLE,\n\t\t\t\t &arg, sizeof(arg));\n}\n\nint wfx_hif_set_operational_mode(struct wfx_dev *wdev, enum wfx_hif_op_power_mode mode)\n{\n\tstruct wfx_hif_mib_gl_operational_power_mode arg = {\n\t\t.power_mode = mode,\n\t\t.wup_ind_activation = 1,\n\t};\n\n\treturn wfx_hif_write_mib(wdev, -1, HIF_MIB_ID_GL_OPERATIONAL_POWER_MODE,\n\t\t\t\t &arg, sizeof(arg));\n}\n\nint wfx_hif_set_template_frame(struct wfx_vif *wvif, struct sk_buff *skb,\n\t\t\t       u8 frame_type, int init_rate)\n{\n\tstruct wfx_hif_mib_template_frame *arg;\n\n\tWARN(skb->len > HIF_API_MAX_TEMPLATE_FRAME_SIZE, \"frame is too big\");\n\tskb_push(skb, 4);\n\targ = (struct wfx_hif_mib_template_frame *)skb->data;\n\tskb_pull(skb, 4);\n\targ->init_rate = init_rate;\n\targ->frame_type = frame_type;\n\targ->frame_length = cpu_to_le16(skb->len);\n\treturn wfx_hif_write_mib(wvif->wdev, wvif->id, HIF_MIB_ID_TEMPLATE_FRAME,\n\t\t\t\t arg, sizeof(*arg) + skb->len);\n}\n\nint wfx_hif_set_mfp(struct wfx_vif *wvif, bool capable, bool required)\n{\n\tstruct wfx_hif_mib_protected_mgmt_policy arg = { };\n\n\tWARN(required && !capable, \"incoherent arguments\");\n\tif (capable) {\n\t\targ.pmf_enable = 1;\n\t\targ.host_enc_auth_frames = 1;\n\t}\n\tif (!required)\n\t\targ.unpmf_allowed = 1;\n\treturn wfx_hif_write_mib(wvif->wdev, wvif->id, HIF_MIB_ID_PROTECTED_MGMT_POLICY,\n\t\t\t\t &arg, sizeof(arg));\n}\n\nint wfx_hif_set_block_ack_policy(struct wfx_vif *wvif, u8 tx_tid_policy, u8 rx_tid_policy)\n{\n\tstruct wfx_hif_mib_block_ack_policy arg = {\n\t\t.block_ack_tx_tid_policy = tx_tid_policy,\n\t\t.block_ack_rx_tid_policy = rx_tid_policy,\n\t};\n\n\treturn wfx_hif_write_mib(wvif->wdev, wvif->id, HIF_MIB_ID_BLOCK_ACK_POLICY,\n\t\t\t\t &arg, sizeof(arg));\n}\n\nint wfx_hif_set_association_mode(struct wfx_vif *wvif, int ampdu_density,\n\t\t\t\t bool greenfield, bool short_preamble)\n{\n\tstruct wfx_hif_mib_set_association_mode arg = {\n\t\t.preambtype_use = 1,\n\t\t.mode = 1,\n\t\t.spacing = 1,\n\t\t.short_preamble = short_preamble,\n\t\t.greenfield = greenfield,\n\t\t.mpdu_start_spacing = ampdu_density,\n\t};\n\n\treturn wfx_hif_write_mib(wvif->wdev, wvif->id, HIF_MIB_ID_SET_ASSOCIATION_MODE,\n\t\t\t\t &arg, sizeof(arg));\n}\n\nint wfx_hif_set_tx_rate_retry_policy(struct wfx_vif *wvif, int policy_index, u8 *rates)\n{\n\tstruct wfx_hif_mib_set_tx_rate_retry_policy *arg;\n\tsize_t size = struct_size(arg, tx_rate_retry_policy, 1);\n\tint ret;\n\n\targ = kzalloc(size, GFP_KERNEL);\n\tif (!arg)\n\t\treturn -ENOMEM;\n\targ->num_tx_rate_policies = 1;\n\targ->tx_rate_retry_policy[0].policy_index = policy_index;\n\targ->tx_rate_retry_policy[0].short_retry_count = 255;\n\targ->tx_rate_retry_policy[0].long_retry_count = 255;\n\targ->tx_rate_retry_policy[0].first_rate_sel = 1;\n\targ->tx_rate_retry_policy[0].terminate = 1;\n\targ->tx_rate_retry_policy[0].count_init = 1;\n\tmemcpy(&arg->tx_rate_retry_policy[0].rates, rates,\n\t       sizeof(arg->tx_rate_retry_policy[0].rates));\n\tret = wfx_hif_write_mib(wvif->wdev, wvif->id, HIF_MIB_ID_SET_TX_RATE_RETRY_POLICY,\n\t\t\t\targ, size);\n\tkfree(arg);\n\treturn ret;\n}\n\nint wfx_hif_keep_alive_period(struct wfx_vif *wvif, int period)\n{\n\tstruct wfx_hif_mib_keep_alive_period arg = {\n\t\t.keep_alive_period = cpu_to_le16(period),\n\t};\n\n\treturn wfx_hif_write_mib(wvif->wdev, wvif->id, HIF_MIB_ID_KEEP_ALIVE_PERIOD,\n\t\t\t\t &arg, sizeof(arg));\n};\n\nint wfx_hif_set_arp_ipv4_filter(struct wfx_vif *wvif, int idx, __be32 *addr)\n{\n\tstruct wfx_hif_mib_arp_ip_addr_table arg = {\n\t\t.condition_idx = idx,\n\t\t.arp_enable = HIF_ARP_NS_FILTERING_DISABLE,\n\t};\n\n\tif (addr) {\n\t\t \n\t\tmemcpy(arg.ipv4_address, addr, sizeof(arg.ipv4_address));\n\t\targ.arp_enable = HIF_ARP_NS_FILTERING_ENABLE;\n\t}\n\treturn wfx_hif_write_mib(wvif->wdev, wvif->id, HIF_MIB_ID_ARP_IP_ADDRESSES_TABLE,\n\t\t\t\t &arg, sizeof(arg));\n}\n\nint wfx_hif_use_multi_tx_conf(struct wfx_dev *wdev, bool enable)\n{\n\tstruct wfx_hif_mib_gl_set_multi_msg arg = {\n\t\t.enable_multi_tx_conf = enable,\n\t};\n\n\treturn wfx_hif_write_mib(wdev, -1, HIF_MIB_ID_GL_SET_MULTI_MSG, &arg, sizeof(arg));\n}\n\nint wfx_hif_set_uapsd_info(struct wfx_vif *wvif, unsigned long val)\n{\n\tstruct wfx_hif_mib_set_uapsd_information arg = { };\n\n\tif (val & BIT(IEEE80211_AC_VO))\n\t\targ.trig_voice = 1;\n\tif (val & BIT(IEEE80211_AC_VI))\n\t\targ.trig_video = 1;\n\tif (val & BIT(IEEE80211_AC_BE))\n\t\targ.trig_be = 1;\n\tif (val & BIT(IEEE80211_AC_BK))\n\t\targ.trig_bckgrnd = 1;\n\treturn wfx_hif_write_mib(wvif->wdev, wvif->id, HIF_MIB_ID_SET_UAPSD_INFORMATION,\n\t\t\t\t &arg, sizeof(arg));\n}\n\nint wfx_hif_erp_use_protection(struct wfx_vif *wvif, bool enable)\n{\n\tstruct wfx_hif_mib_non_erp_protection arg = {\n\t\t.use_cts_to_self = enable,\n\t};\n\n\treturn wfx_hif_write_mib(wvif->wdev, wvif->id, HIF_MIB_ID_NON_ERP_PROTECTION,\n\t\t\t\t &arg, sizeof(arg));\n}\n\nint wfx_hif_slot_time(struct wfx_vif *wvif, int val)\n{\n\tstruct wfx_hif_mib_slot_time arg = {\n\t\t.slot_time = cpu_to_le32(val),\n\t};\n\n\treturn wfx_hif_write_mib(wvif->wdev, wvif->id, HIF_MIB_ID_SLOT_TIME, &arg, sizeof(arg));\n}\n\nint wfx_hif_wep_default_key_id(struct wfx_vif *wvif, int val)\n{\n\tstruct wfx_hif_mib_wep_default_key_id arg = {\n\t\t.wep_default_key_id = val,\n\t};\n\n\treturn wfx_hif_write_mib(wvif->wdev, wvif->id, HIF_MIB_ID_DOT11_WEP_DEFAULT_KEY_ID,\n\t\t\t\t &arg, sizeof(arg));\n}\n\nint wfx_hif_rts_threshold(struct wfx_vif *wvif, int val)\n{\n\tstruct wfx_hif_mib_dot11_rts_threshold arg = {\n\t\t.threshold = cpu_to_le32(val >= 0 ? val : 0xFFFF),\n\t};\n\n\treturn wfx_hif_write_mib(wvif->wdev, wvif->id, HIF_MIB_ID_DOT11_RTS_THRESHOLD,\n\t\t\t\t &arg, sizeof(arg));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}