{
  "module_name": "hif_tx.c",
  "hash_id": "ede57eb4c4d26a2bc756ef6e94d60e7b68f9bbde88b45e97d02a92f5c52fd3f5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/silabs/wfx/hif_tx.c",
  "human_readable_source": "\n \n#include <linux/etherdevice.h>\n\n#include \"hif_tx.h\"\n#include \"wfx.h\"\n#include \"bh.h\"\n#include \"hwio.h\"\n#include \"debug.h\"\n#include \"sta.h\"\n\nvoid wfx_init_hif_cmd(struct wfx_hif_cmd *hif_cmd)\n{\n\tinit_completion(&hif_cmd->ready);\n\tinit_completion(&hif_cmd->done);\n\tmutex_init(&hif_cmd->lock);\n}\n\nstatic void wfx_fill_header(struct wfx_hif_msg *hif, int if_id, unsigned int cmd, size_t size)\n{\n\tif (if_id == -1)\n\t\tif_id = 2;\n\n\tWARN(cmd > 0x3f, \"invalid hardware command %#.2x\", cmd);\n\tWARN(size > 0xFFF, \"requested buffer is too large: %zu bytes\", size);\n\tWARN(if_id > 0x3, \"invalid interface ID %d\", if_id);\n\n\thif->len = cpu_to_le16(size + 4);\n\thif->id = cmd;\n\thif->interface = if_id;\n}\n\nstatic void *wfx_alloc_hif(size_t body_len, struct wfx_hif_msg **hif)\n{\n\t*hif = kzalloc(sizeof(struct wfx_hif_msg) + body_len, GFP_KERNEL);\n\tif (*hif)\n\t\treturn (*hif)->body;\n\telse\n\t\treturn NULL;\n}\n\nint wfx_cmd_send(struct wfx_dev *wdev, struct wfx_hif_msg *request,\n\t\t void *reply, size_t reply_len, bool no_reply)\n{\n\tconst char *mib_name = \"\";\n\tconst char *mib_sep = \"\";\n\tint cmd = request->id;\n\tint vif = request->interface;\n\tint ret;\n\n\t \n\tif (wdev->chip_frozen)\n\t\treturn -ETIMEDOUT;\n\n\tmutex_lock(&wdev->hif_cmd.lock);\n\tWARN(wdev->hif_cmd.buf_send, \"data locking error\");\n\n\t \n\twdev->hif_cmd.buf_send = request;\n\twdev->hif_cmd.buf_recv = reply;\n\twdev->hif_cmd.len_recv = reply_len;\n\tcomplete(&wdev->hif_cmd.ready);\n\n\twfx_bh_request_tx(wdev);\n\n\tif (no_reply) {\n\t\t \n\t\tflush_workqueue(wdev->bh_wq);\n\t\tret = 0;\n\t\tgoto end;\n\t}\n\n\tif (wdev->poll_irq)\n\t\twfx_bh_poll_irq(wdev);\n\n\tret = wait_for_completion_timeout(&wdev->hif_cmd.done, 1 * HZ);\n\tif (!ret) {\n\t\tdev_err(wdev->dev, \"chip is abnormally long to answer\\n\");\n\t\treinit_completion(&wdev->hif_cmd.ready);\n\t\tret = wait_for_completion_timeout(&wdev->hif_cmd.done, 3 * HZ);\n\t}\n\tif (!ret) {\n\t\tdev_err(wdev->dev, \"chip did not answer\\n\");\n\t\twfx_pending_dump_old_frames(wdev, 3000);\n\t\twdev->chip_frozen = true;\n\t\treinit_completion(&wdev->hif_cmd.done);\n\t\tret = -ETIMEDOUT;\n\t} else {\n\t\tret = wdev->hif_cmd.ret;\n\t}\n\nend:\n\twdev->hif_cmd.buf_send = NULL;\n\tmutex_unlock(&wdev->hif_cmd.lock);\n\n\tif (ret &&\n\t    (cmd == HIF_REQ_ID_READ_MIB || cmd == HIF_REQ_ID_WRITE_MIB)) {\n\t\tmib_name = wfx_get_mib_name(((u16 *)request)[2]);\n\t\tmib_sep = \"/\";\n\t}\n\tif (ret < 0)\n\t\tdev_err(wdev->dev, \"hardware request %s%s%s (%#.2x) on vif %d returned error %d\\n\",\n\t\t\twfx_get_hif_name(cmd), mib_sep, mib_name, cmd, vif, ret);\n\tif (ret > 0)\n\t\tdev_warn(wdev->dev, \"hardware request %s%s%s (%#.2x) on vif %d returned status %d\\n\",\n\t\t\t wfx_get_hif_name(cmd), mib_sep, mib_name, cmd, vif, ret);\n\n\treturn ret;\n}\n\n \nint wfx_hif_shutdown(struct wfx_dev *wdev)\n{\n\tint ret;\n\tstruct wfx_hif_msg *hif;\n\n\twfx_alloc_hif(0, &hif);\n\tif (!hif)\n\t\treturn -ENOMEM;\n\twfx_fill_header(hif, -1, HIF_REQ_ID_SHUT_DOWN, 0);\n\tret = wfx_cmd_send(wdev, hif, NULL, 0, true);\n\tif (wdev->pdata.gpio_wakeup)\n\t\tgpiod_set_value(wdev->pdata.gpio_wakeup, 0);\n\telse\n\t\twfx_control_reg_write(wdev, 0);\n\tkfree(hif);\n\treturn ret;\n}\n\nint wfx_hif_configuration(struct wfx_dev *wdev, const u8 *conf, size_t len)\n{\n\tint ret;\n\tsize_t buf_len = sizeof(struct wfx_hif_req_configuration) + len;\n\tstruct wfx_hif_msg *hif;\n\tstruct wfx_hif_req_configuration *body = wfx_alloc_hif(buf_len, &hif);\n\n\tif (!hif)\n\t\treturn -ENOMEM;\n\tbody->length = cpu_to_le16(len);\n\tmemcpy(body->pds_data, conf, len);\n\twfx_fill_header(hif, -1, HIF_REQ_ID_CONFIGURATION, buf_len);\n\tret = wfx_cmd_send(wdev, hif, NULL, 0, false);\n\tkfree(hif);\n\treturn ret;\n}\n\nint wfx_hif_reset(struct wfx_vif *wvif, bool reset_stat)\n{\n\tint ret;\n\tstruct wfx_hif_msg *hif;\n\tstruct wfx_hif_req_reset *body = wfx_alloc_hif(sizeof(*body), &hif);\n\n\tif (!hif)\n\t\treturn -ENOMEM;\n\tbody->reset_stat = reset_stat;\n\twfx_fill_header(hif, wvif->id, HIF_REQ_ID_RESET, sizeof(*body));\n\tret = wfx_cmd_send(wvif->wdev, hif, NULL, 0, false);\n\tkfree(hif);\n\treturn ret;\n}\n\nint wfx_hif_read_mib(struct wfx_dev *wdev, int vif_id, u16 mib_id, void *val, size_t val_len)\n{\n\tint ret;\n\tstruct wfx_hif_msg *hif;\n\tint buf_len = sizeof(struct wfx_hif_cnf_read_mib) + val_len;\n\tstruct wfx_hif_req_read_mib *body = wfx_alloc_hif(sizeof(*body), &hif);\n\tstruct wfx_hif_cnf_read_mib *reply = kmalloc(buf_len, GFP_KERNEL);\n\n\tif (!body || !reply) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tbody->mib_id = cpu_to_le16(mib_id);\n\twfx_fill_header(hif, vif_id, HIF_REQ_ID_READ_MIB, sizeof(*body));\n\tret = wfx_cmd_send(wdev, hif, reply, buf_len, false);\n\n\tif (!ret && mib_id != le16_to_cpu(reply->mib_id)) {\n\t\tdev_warn(wdev->dev, \"%s: confirmation mismatch request\\n\", __func__);\n\t\tret = -EIO;\n\t}\n\tif (ret == -ENOMEM)\n\t\tdev_err(wdev->dev, \"buffer is too small to receive %s (%zu < %d)\\n\",\n\t\t\twfx_get_mib_name(mib_id), val_len, le16_to_cpu(reply->length));\n\tif (!ret)\n\t\tmemcpy(val, &reply->mib_data, le16_to_cpu(reply->length));\n\telse\n\t\tmemset(val, 0xFF, val_len);\nout:\n\tkfree(hif);\n\tkfree(reply);\n\treturn ret;\n}\n\nint wfx_hif_write_mib(struct wfx_dev *wdev, int vif_id, u16 mib_id, void *val, size_t val_len)\n{\n\tint ret;\n\tstruct wfx_hif_msg *hif;\n\tint buf_len = sizeof(struct wfx_hif_req_write_mib) + val_len;\n\tstruct wfx_hif_req_write_mib *body = wfx_alloc_hif(buf_len, &hif);\n\n\tif (!hif)\n\t\treturn -ENOMEM;\n\tbody->mib_id = cpu_to_le16(mib_id);\n\tbody->length = cpu_to_le16(val_len);\n\tmemcpy(&body->mib_data, val, val_len);\n\twfx_fill_header(hif, vif_id, HIF_REQ_ID_WRITE_MIB, buf_len);\n\tret = wfx_cmd_send(wdev, hif, NULL, 0, false);\n\tkfree(hif);\n\treturn ret;\n}\n\nint wfx_hif_scan(struct wfx_vif *wvif, struct cfg80211_scan_request *req,\n\t\t int chan_start_idx, int chan_num)\n{\n\tint ret, i;\n\tstruct wfx_hif_msg *hif;\n\tsize_t buf_len = sizeof(struct wfx_hif_req_start_scan_alt) + chan_num * sizeof(u8);\n\tstruct wfx_hif_req_start_scan_alt *body = wfx_alloc_hif(buf_len, &hif);\n\n\tWARN(chan_num > HIF_API_MAX_NB_CHANNELS, \"invalid params\");\n\tWARN(req->n_ssids > HIF_API_MAX_NB_SSIDS, \"invalid params\");\n\n\tif (!hif)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < req->n_ssids; i++) {\n\t\tmemcpy(body->ssid_def[i].ssid, req->ssids[i].ssid, IEEE80211_MAX_SSID_LEN);\n\t\tbody->ssid_def[i].ssid_length = cpu_to_le32(req->ssids[i].ssid_len);\n\t}\n\tbody->num_of_ssids = HIF_API_MAX_NB_SSIDS;\n\tbody->maintain_current_bss = 1;\n\tbody->disallow_ps = 1;\n\tbody->tx_power_level = cpu_to_le32(req->channels[chan_start_idx]->max_power);\n\tbody->num_of_channels = chan_num;\n\tfor (i = 0; i < chan_num; i++)\n\t\tbody->channel_list[i] = req->channels[i + chan_start_idx]->hw_value;\n\tif (req->no_cck)\n\t\tbody->max_transmit_rate = API_RATE_INDEX_G_6MBPS;\n\telse\n\t\tbody->max_transmit_rate = API_RATE_INDEX_B_1MBPS;\n\tif (req->channels[chan_start_idx]->flags & IEEE80211_CHAN_NO_IR) {\n\t\tbody->min_channel_time = cpu_to_le32(50);\n\t\tbody->max_channel_time = cpu_to_le32(150);\n\t} else {\n\t\tbody->min_channel_time = cpu_to_le32(10);\n\t\tbody->max_channel_time = cpu_to_le32(50);\n\t\tbody->num_of_probe_requests = 2;\n\t\tbody->probe_delay = 100;\n\t}\n\n\twfx_fill_header(hif, wvif->id, HIF_REQ_ID_START_SCAN, buf_len);\n\tret = wfx_cmd_send(wvif->wdev, hif, NULL, 0, false);\n\tkfree(hif);\n\treturn ret;\n}\n\nint wfx_hif_stop_scan(struct wfx_vif *wvif)\n{\n\tint ret;\n\tstruct wfx_hif_msg *hif;\n\t \n\twfx_alloc_hif(0, &hif);\n\n\tif (!hif)\n\t\treturn -ENOMEM;\n\twfx_fill_header(hif, wvif->id, HIF_REQ_ID_STOP_SCAN, 0);\n\tret = wfx_cmd_send(wvif->wdev, hif, NULL, 0, false);\n\tkfree(hif);\n\treturn ret;\n}\n\nint wfx_hif_join(struct wfx_vif *wvif, const struct ieee80211_bss_conf *conf,\n\t\t struct ieee80211_channel *channel, const u8 *ssid, int ssid_len)\n{\n\tstruct ieee80211_vif *vif = container_of(conf, struct ieee80211_vif,\n\t\t\t\t\t\t bss_conf);\n\tint ret;\n\tstruct wfx_hif_msg *hif;\n\tstruct wfx_hif_req_join *body = wfx_alloc_hif(sizeof(*body), &hif);\n\n\tWARN_ON(!conf->beacon_int);\n\tWARN_ON(!conf->basic_rates);\n\tWARN_ON(sizeof(body->ssid) < ssid_len);\n\tWARN(!vif->cfg.ibss_joined && !ssid_len, \"joining an unknown BSS\");\n\tif (!hif)\n\t\treturn -ENOMEM;\n\tbody->infrastructure_bss_mode = !vif->cfg.ibss_joined;\n\tbody->short_preamble = conf->use_short_preamble;\n\tbody->probe_for_join = !(channel->flags & IEEE80211_CHAN_NO_IR);\n\tbody->channel_number = channel->hw_value;\n\tbody->beacon_interval = cpu_to_le32(conf->beacon_int);\n\tbody->basic_rate_set = cpu_to_le32(wfx_rate_mask_to_hw(wvif->wdev, conf->basic_rates));\n\tmemcpy(body->bssid, conf->bssid, sizeof(body->bssid));\n\tif (ssid) {\n\t\tbody->ssid_length = cpu_to_le32(ssid_len);\n\t\tmemcpy(body->ssid, ssid, ssid_len);\n\t}\n\twfx_fill_header(hif, wvif->id, HIF_REQ_ID_JOIN, sizeof(*body));\n\tret = wfx_cmd_send(wvif->wdev, hif, NULL, 0, false);\n\tkfree(hif);\n\treturn ret;\n}\n\nint wfx_hif_set_bss_params(struct wfx_vif *wvif, int aid, int beacon_lost_count)\n{\n\tint ret;\n\tstruct wfx_hif_msg *hif;\n\tstruct wfx_hif_req_set_bss_params *body = wfx_alloc_hif(sizeof(*body), &hif);\n\n\tif (!hif)\n\t\treturn -ENOMEM;\n\tbody->aid = cpu_to_le16(aid);\n\tbody->beacon_lost_count = beacon_lost_count;\n\twfx_fill_header(hif, wvif->id, HIF_REQ_ID_SET_BSS_PARAMS, sizeof(*body));\n\tret = wfx_cmd_send(wvif->wdev, hif, NULL, 0, false);\n\tkfree(hif);\n\treturn ret;\n}\n\nint wfx_hif_add_key(struct wfx_dev *wdev, const struct wfx_hif_req_add_key *arg)\n{\n\tint ret;\n\tstruct wfx_hif_msg *hif;\n\t \n\tstruct wfx_hif_req_add_key *body = wfx_alloc_hif(sizeof(*body), &hif);\n\n\tif (!hif)\n\t\treturn -ENOMEM;\n\t \n\tmemcpy(body, arg, sizeof(*body));\n\tif (wfx_api_older_than(wdev, 1, 5))\n\t\t \n\t\twfx_fill_header(hif, arg->int_id, HIF_REQ_ID_ADD_KEY, sizeof(*body));\n\telse\n\t\twfx_fill_header(hif, -1, HIF_REQ_ID_ADD_KEY, sizeof(*body));\n\tret = wfx_cmd_send(wdev, hif, NULL, 0, false);\n\tkfree(hif);\n\treturn ret;\n}\n\nint wfx_hif_remove_key(struct wfx_dev *wdev, int idx)\n{\n\tint ret;\n\tstruct wfx_hif_msg *hif;\n\tstruct wfx_hif_req_remove_key *body = wfx_alloc_hif(sizeof(*body), &hif);\n\n\tif (!hif)\n\t\treturn -ENOMEM;\n\tbody->entry_index = idx;\n\twfx_fill_header(hif, -1, HIF_REQ_ID_REMOVE_KEY, sizeof(*body));\n\tret = wfx_cmd_send(wdev, hif, NULL, 0, false);\n\tkfree(hif);\n\treturn ret;\n}\n\nint wfx_hif_set_edca_queue_params(struct wfx_vif *wvif, u16 queue,\n\t\t\t\t  const struct ieee80211_tx_queue_params *arg)\n{\n\tint ret;\n\tstruct wfx_hif_msg *hif;\n\tstruct wfx_hif_req_edca_queue_params *body = wfx_alloc_hif(sizeof(*body), &hif);\n\n\tif (!body)\n\t\treturn -ENOMEM;\n\n\tWARN_ON(arg->aifs > 255);\n\tif (!hif)\n\t\treturn -ENOMEM;\n\tbody->aifsn = arg->aifs;\n\tbody->cw_min = cpu_to_le16(arg->cw_min);\n\tbody->cw_max = cpu_to_le16(arg->cw_max);\n\tbody->tx_op_limit = cpu_to_le16(arg->txop * USEC_PER_TXOP);\n\tbody->queue_id = 3 - queue;\n\t \n\tif (wfx_api_older_than(wvif->wdev, 2, 0) && queue == IEEE80211_AC_BE)\n\t\tbody->queue_id = HIF_QUEUE_ID_BACKGROUND;\n\tif (wfx_api_older_than(wvif->wdev, 2, 0) && queue == IEEE80211_AC_BK)\n\t\tbody->queue_id = HIF_QUEUE_ID_BESTEFFORT;\n\twfx_fill_header(hif, wvif->id, HIF_REQ_ID_EDCA_QUEUE_PARAMS, sizeof(*body));\n\tret = wfx_cmd_send(wvif->wdev, hif, NULL, 0, false);\n\tkfree(hif);\n\treturn ret;\n}\n\nint wfx_hif_set_pm(struct wfx_vif *wvif, bool ps, int dynamic_ps_timeout)\n{\n\tint ret;\n\tstruct wfx_hif_msg *hif;\n\tstruct wfx_hif_req_set_pm_mode *body = wfx_alloc_hif(sizeof(*body), &hif);\n\n\tif (!body)\n\t\treturn -ENOMEM;\n\n\tif (!hif)\n\t\treturn -ENOMEM;\n\tif (ps) {\n\t\tbody->enter_psm = 1;\n\t\t \n\t\tbody->fast_psm_idle_period = min(dynamic_ps_timeout * 2, 255);\n\t\tif (body->fast_psm_idle_period)\n\t\t\tbody->fast_psm = 1;\n\t}\n\twfx_fill_header(hif, wvif->id, HIF_REQ_ID_SET_PM_MODE, sizeof(*body));\n\tret = wfx_cmd_send(wvif->wdev, hif, NULL, 0, false);\n\tkfree(hif);\n\treturn ret;\n}\n\nint wfx_hif_start(struct wfx_vif *wvif, const struct ieee80211_bss_conf *conf,\n\t\t  const struct ieee80211_channel *channel)\n{\n        struct ieee80211_vif *vif = container_of(conf, struct ieee80211_vif,\n\t\t\t\t\t\t bss_conf);\n\tint ret;\n\tstruct wfx_hif_msg *hif;\n\tstruct wfx_hif_req_start *body = wfx_alloc_hif(sizeof(*body), &hif);\n\n\tWARN_ON(!conf->beacon_int);\n\tif (!hif)\n\t\treturn -ENOMEM;\n\tbody->dtim_period = conf->dtim_period;\n\tbody->short_preamble = conf->use_short_preamble;\n\tbody->channel_number = channel->hw_value;\n\tbody->beacon_interval = cpu_to_le32(conf->beacon_int);\n\tbody->basic_rate_set = cpu_to_le32(wfx_rate_mask_to_hw(wvif->wdev, conf->basic_rates));\n\tbody->ssid_length = vif->cfg.ssid_len;\n\tmemcpy(body->ssid, vif->cfg.ssid, vif->cfg.ssid_len);\n\twfx_fill_header(hif, wvif->id, HIF_REQ_ID_START, sizeof(*body));\n\tret = wfx_cmd_send(wvif->wdev, hif, NULL, 0, false);\n\tkfree(hif);\n\treturn ret;\n}\n\nint wfx_hif_beacon_transmit(struct wfx_vif *wvif, bool enable)\n{\n\tint ret;\n\tstruct wfx_hif_msg *hif;\n\tstruct wfx_hif_req_beacon_transmit *body = wfx_alloc_hif(sizeof(*body), &hif);\n\n\tif (!hif)\n\t\treturn -ENOMEM;\n\tbody->enable_beaconing = enable ? 1 : 0;\n\twfx_fill_header(hif, wvif->id, HIF_REQ_ID_BEACON_TRANSMIT, sizeof(*body));\n\tret = wfx_cmd_send(wvif->wdev, hif, NULL, 0, false);\n\tkfree(hif);\n\treturn ret;\n}\n\nint wfx_hif_map_link(struct wfx_vif *wvif, bool unmap, u8 *mac_addr, int sta_id, bool mfp)\n{\n\tint ret;\n\tstruct wfx_hif_msg *hif;\n\tstruct wfx_hif_req_map_link *body = wfx_alloc_hif(sizeof(*body), &hif);\n\n\tif (!hif)\n\t\treturn -ENOMEM;\n\tif (mac_addr)\n\t\tether_addr_copy(body->mac_addr, mac_addr);\n\tbody->mfpc = mfp ? 1 : 0;\n\tbody->unmap = unmap ? 1 : 0;\n\tbody->peer_sta_id = sta_id;\n\twfx_fill_header(hif, wvif->id, HIF_REQ_ID_MAP_LINK, sizeof(*body));\n\tret = wfx_cmd_send(wvif->wdev, hif, NULL, 0, false);\n\tkfree(hif);\n\treturn ret;\n}\n\nint wfx_hif_update_ie_beacon(struct wfx_vif *wvif, const u8 *ies, size_t ies_len)\n{\n\tint ret;\n\tstruct wfx_hif_msg *hif;\n\tint buf_len = sizeof(struct wfx_hif_req_update_ie) + ies_len;\n\tstruct wfx_hif_req_update_ie *body = wfx_alloc_hif(buf_len, &hif);\n\n\tif (!hif)\n\t\treturn -ENOMEM;\n\tbody->beacon = 1;\n\tbody->num_ies = cpu_to_le16(1);\n\tmemcpy(body->ie, ies, ies_len);\n\twfx_fill_header(hif, wvif->id, HIF_REQ_ID_UPDATE_IE, buf_len);\n\tret = wfx_cmd_send(wvif->wdev, hif, NULL, 0, false);\n\tkfree(hif);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}