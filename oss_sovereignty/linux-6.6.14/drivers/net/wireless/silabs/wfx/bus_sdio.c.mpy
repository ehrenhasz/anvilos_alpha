{
  "module_name": "bus_sdio.c",
  "hash_id": "6f2e8e1ac4f1619c235a1a8d8f6428899addd2eff5ece636c6f1cfc95311b1bc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/silabs/wfx/bus_sdio.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/mmc/sdio.h>\n#include <linux/mmc/sdio_func.h>\n#include <linux/mmc/card.h>\n#include <linux/interrupt.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/irq.h>\n#include <linux/align.h>\n\n#include \"bus.h\"\n#include \"wfx.h\"\n#include \"hwio.h\"\n#include \"main.h\"\n#include \"bh.h\"\n\nstatic const struct wfx_platform_data pdata_wf200 = {\n\t.file_fw = \"wfx/wfm_wf200\",\n\t.file_pds = \"wfx/wf200.pds\",\n};\n\nstatic const struct wfx_platform_data pdata_brd4001a = {\n\t.file_fw = \"wfx/wfm_wf200\",\n\t.file_pds = \"wfx/brd4001a.pds\",\n};\n\nstatic const struct wfx_platform_data pdata_brd8022a = {\n\t.file_fw = \"wfx/wfm_wf200\",\n\t.file_pds = \"wfx/brd8022a.pds\",\n};\n\nstatic const struct wfx_platform_data pdata_brd8023a = {\n\t.file_fw = \"wfx/wfm_wf200\",\n\t.file_pds = \"wfx/brd8023a.pds\",\n};\n\nstruct wfx_sdio_priv {\n\tstruct sdio_func *func;\n\tstruct wfx_dev *core;\n\tu8 buf_id_tx;\n\tu8 buf_id_rx;\n\tint of_irq;\n};\n\nstatic int wfx_sdio_copy_from_io(void *priv, unsigned int reg_id, void *dst, size_t count)\n{\n\tstruct wfx_sdio_priv *bus = priv;\n\tunsigned int sdio_addr = reg_id << 2;\n\tint ret;\n\n\tWARN(reg_id > 7, \"chip only has 7 registers\");\n\tWARN(!IS_ALIGNED((uintptr_t)dst, 4), \"unaligned buffer address\");\n\tWARN(!IS_ALIGNED(count, 4), \"unaligned buffer size\");\n\n\t \n\tif (reg_id == WFX_REG_IN_OUT_QUEUE)\n\t\tsdio_addr |= (bus->buf_id_rx + 1) << 7;\n\tret = sdio_memcpy_fromio(bus->func, dst, sdio_addr, count);\n\tif (!ret && reg_id == WFX_REG_IN_OUT_QUEUE)\n\t\tbus->buf_id_rx = (bus->buf_id_rx + 1) % 4;\n\n\treturn ret;\n}\n\nstatic int wfx_sdio_copy_to_io(void *priv, unsigned int reg_id, const void *src, size_t count)\n{\n\tstruct wfx_sdio_priv *bus = priv;\n\tunsigned int sdio_addr = reg_id << 2;\n\tint ret;\n\n\tWARN(reg_id > 7, \"chip only has 7 registers\");\n\tWARN(!IS_ALIGNED((uintptr_t)src, 4), \"unaligned buffer address\");\n\tWARN(!IS_ALIGNED(count, 4), \"unaligned buffer size\");\n\n\t \n\tif (reg_id == WFX_REG_IN_OUT_QUEUE)\n\t\tsdio_addr |= bus->buf_id_tx << 7;\n\t \n\tret = sdio_memcpy_toio(bus->func, sdio_addr, (void *)src, count);\n\tif (!ret && reg_id == WFX_REG_IN_OUT_QUEUE)\n\t\tbus->buf_id_tx = (bus->buf_id_tx + 1) % 32;\n\n\treturn ret;\n}\n\nstatic void wfx_sdio_lock(void *priv)\n{\n\tstruct wfx_sdio_priv *bus = priv;\n\n\tsdio_claim_host(bus->func);\n}\n\nstatic void wfx_sdio_unlock(void *priv)\n{\n\tstruct wfx_sdio_priv *bus = priv;\n\n\tsdio_release_host(bus->func);\n}\n\nstatic void wfx_sdio_irq_handler(struct sdio_func *func)\n{\n\tstruct wfx_sdio_priv *bus = sdio_get_drvdata(func);\n\n\twfx_bh_request_rx(bus->core);\n}\n\nstatic irqreturn_t wfx_sdio_irq_handler_ext(int irq, void *priv)\n{\n\tstruct wfx_sdio_priv *bus = priv;\n\n\tsdio_claim_host(bus->func);\n\twfx_bh_request_rx(bus->core);\n\tsdio_release_host(bus->func);\n\treturn IRQ_HANDLED;\n}\n\nstatic int wfx_sdio_irq_subscribe(void *priv)\n{\n\tstruct wfx_sdio_priv *bus = priv;\n\tu32 flags;\n\tint ret;\n\tu8 cccr;\n\n\tif (!bus->of_irq) {\n\t\tsdio_claim_host(bus->func);\n\t\tret = sdio_claim_irq(bus->func, wfx_sdio_irq_handler);\n\t\tsdio_release_host(bus->func);\n\t\treturn ret;\n\t}\n\n\tflags = irq_get_trigger_type(bus->of_irq);\n\tif (!flags)\n\t\tflags = IRQF_TRIGGER_HIGH;\n\tflags |= IRQF_ONESHOT;\n\tret = devm_request_threaded_irq(&bus->func->dev, bus->of_irq, NULL,\n\t\t\t\t\twfx_sdio_irq_handler_ext, flags, \"wfx\", bus);\n\tif (ret)\n\t\treturn ret;\n\tsdio_claim_host(bus->func);\n\tcccr = sdio_f0_readb(bus->func, SDIO_CCCR_IENx, NULL);\n\tcccr |= BIT(0);\n\tcccr |= BIT(bus->func->num);\n\tsdio_f0_writeb(bus->func, cccr, SDIO_CCCR_IENx, NULL);\n\tsdio_release_host(bus->func);\n\treturn 0;\n}\n\nstatic int wfx_sdio_irq_unsubscribe(void *priv)\n{\n\tstruct wfx_sdio_priv *bus = priv;\n\tint ret;\n\n\tif (bus->of_irq)\n\t\tdevm_free_irq(&bus->func->dev, bus->of_irq, bus);\n\tsdio_claim_host(bus->func);\n\tret = sdio_release_irq(bus->func);\n\tsdio_release_host(bus->func);\n\treturn ret;\n}\n\nstatic size_t wfx_sdio_align_size(void *priv, size_t size)\n{\n\tstruct wfx_sdio_priv *bus = priv;\n\n\treturn sdio_align_size(bus->func, size);\n}\n\nstatic const struct wfx_hwbus_ops wfx_sdio_hwbus_ops = {\n\t.copy_from_io    = wfx_sdio_copy_from_io,\n\t.copy_to_io      = wfx_sdio_copy_to_io,\n\t.irq_subscribe   = wfx_sdio_irq_subscribe,\n\t.irq_unsubscribe = wfx_sdio_irq_unsubscribe,\n\t.lock            = wfx_sdio_lock,\n\t.unlock          = wfx_sdio_unlock,\n\t.align_size      = wfx_sdio_align_size,\n};\n\nstatic const struct of_device_id wfx_sdio_of_match[] = {\n\t{ .compatible = \"silabs,wf200\",    .data = &pdata_wf200 },\n\t{ .compatible = \"silabs,brd4001a\", .data = &pdata_brd4001a },\n\t{ .compatible = \"silabs,brd8022a\", .data = &pdata_brd8022a },\n\t{ .compatible = \"silabs,brd8023a\", .data = &pdata_brd8023a },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, wfx_sdio_of_match);\n\nstatic int wfx_sdio_probe(struct sdio_func *func, const struct sdio_device_id *id)\n{\n\tconst struct wfx_platform_data *pdata = of_device_get_match_data(&func->dev);\n\tstruct device_node *np = func->dev.of_node;\n\tstruct wfx_sdio_priv *bus;\n\tint ret;\n\n\tif (func->num != 1) {\n\t\tdev_err(&func->dev, \"SDIO function number is %d while it should always be 1 (unsupported chip?)\\n\",\n\t\t\tfunc->num);\n\t\treturn -ENODEV;\n\t}\n\n\tif (!pdata) {\n\t\tdev_warn(&func->dev, \"no compatible device found in DT\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tbus = devm_kzalloc(&func->dev, sizeof(*bus), GFP_KERNEL);\n\tif (!bus)\n\t\treturn -ENOMEM;\n\n\tbus->func = func;\n\tbus->of_irq = irq_of_parse_and_map(np, 0);\n\tsdio_set_drvdata(func, bus);\n\n\tsdio_claim_host(func);\n\tret = sdio_enable_func(func);\n\t \n\tsdio_set_block_size(func, 64);\n\tsdio_release_host(func);\n\tif (ret)\n\t\treturn ret;\n\n\tbus->core = wfx_init_common(&func->dev, pdata, &wfx_sdio_hwbus_ops, bus);\n\tif (!bus->core) {\n\t\tret = -EIO;\n\t\tgoto sdio_release;\n\t}\n\n\tret = wfx_probe(bus->core);\n\tif (ret)\n\t\tgoto sdio_release;\n\n\treturn 0;\n\nsdio_release:\n\tsdio_claim_host(func);\n\tsdio_disable_func(func);\n\tsdio_release_host(func);\n\treturn ret;\n}\n\nstatic void wfx_sdio_remove(struct sdio_func *func)\n{\n\tstruct wfx_sdio_priv *bus = sdio_get_drvdata(func);\n\n\twfx_release(bus->core);\n\tsdio_claim_host(func);\n\tsdio_disable_func(func);\n\tsdio_release_host(func);\n}\n\nstatic const struct sdio_device_id wfx_sdio_ids[] = {\n\t \n\t{ SDIO_DEVICE(0x0000, 0x1000) },\n\t{ },\n};\nMODULE_DEVICE_TABLE(sdio, wfx_sdio_ids);\n\nstruct sdio_driver wfx_sdio_driver = {\n\t.name = \"wfx-sdio\",\n\t.id_table = wfx_sdio_ids,\n\t.probe = wfx_sdio_probe,\n\t.remove = wfx_sdio_remove,\n\t.drv = {\n\t\t.owner = THIS_MODULE,\n\t\t.of_match_table = wfx_sdio_of_match,\n\t}\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}