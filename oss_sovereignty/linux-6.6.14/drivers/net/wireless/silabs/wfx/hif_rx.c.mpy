{
  "module_name": "hif_rx.c",
  "hash_id": "a22564af84dc8d8c1b7845e8cbbeb555920264e6845d570472127209a856a97f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/silabs/wfx/hif_rx.c",
  "human_readable_source": "\n \n#include <linux/skbuff.h>\n#include <linux/etherdevice.h>\n\n#include \"hif_rx.h\"\n#include \"wfx.h\"\n#include \"scan.h\"\n#include \"bh.h\"\n#include \"sta.h\"\n#include \"data_rx.h\"\n#include \"hif_api_cmd.h\"\n\nstatic int wfx_hif_generic_confirm(struct wfx_dev *wdev,\n\t\t\t\t   const struct wfx_hif_msg *hif, const void *buf)\n{\n\t \n\tint status = le32_to_cpup((__le32 *)buf);\n\tint cmd = hif->id;\n\tint len = le16_to_cpu(hif->len) - 4;  \n\n\tWARN(!mutex_is_locked(&wdev->hif_cmd.lock), \"data locking error\");\n\n\tif (!wdev->hif_cmd.buf_send) {\n\t\tdev_warn(wdev->dev, \"unexpected confirmation: 0x%.2x\\n\", cmd);\n\t\treturn -EINVAL;\n\t}\n\n\tif (cmd != wdev->hif_cmd.buf_send->id) {\n\t\tdev_warn(wdev->dev, \"chip response mismatch request: 0x%.2x vs 0x%.2x\\n\",\n\t\t\t cmd, wdev->hif_cmd.buf_send->id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (wdev->hif_cmd.buf_recv) {\n\t\tif (wdev->hif_cmd.len_recv >= len && len > 0)\n\t\t\tmemcpy(wdev->hif_cmd.buf_recv, buf, len);\n\t\telse\n\t\t\tstatus = -EIO;\n\t}\n\twdev->hif_cmd.ret = status;\n\n\tcomplete(&wdev->hif_cmd.done);\n\treturn status;\n}\n\nstatic int wfx_hif_tx_confirm(struct wfx_dev *wdev,\n\t\t\t      const struct wfx_hif_msg *hif, const void *buf)\n{\n\tconst struct wfx_hif_cnf_tx *body = buf;\n\n\twfx_tx_confirm_cb(wdev, body);\n\treturn 0;\n}\n\nstatic int wfx_hif_multi_tx_confirm(struct wfx_dev *wdev,\n\t\t\t\t    const struct wfx_hif_msg *hif, const void *buf)\n{\n\tconst struct wfx_hif_cnf_multi_transmit *body = buf;\n\tint i;\n\n\tWARN(body->num_tx_confs <= 0, \"corrupted message\");\n\tfor (i = 0; i < body->num_tx_confs; i++)\n\t\twfx_tx_confirm_cb(wdev, &body->tx_conf_payload[i]);\n\treturn 0;\n}\n\nstatic int wfx_hif_startup_indication(struct wfx_dev *wdev,\n\t\t\t\t      const struct wfx_hif_msg *hif, const void *buf)\n{\n\tconst struct wfx_hif_ind_startup *body = buf;\n\n\tif (body->status || body->firmware_type > 4) {\n\t\tdev_err(wdev->dev, \"received invalid startup indication\");\n\t\treturn -EINVAL;\n\t}\n\tmemcpy(&wdev->hw_caps, body, sizeof(struct wfx_hif_ind_startup));\n\tcomplete(&wdev->firmware_ready);\n\treturn 0;\n}\n\nstatic int wfx_hif_wakeup_indication(struct wfx_dev *wdev,\n\t\t\t\t     const struct wfx_hif_msg *hif, const void *buf)\n{\n\tif (!wdev->pdata.gpio_wakeup || gpiod_get_value(wdev->pdata.gpio_wakeup) == 0) {\n\t\tdev_warn(wdev->dev, \"unexpected wake-up indication\\n\");\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic int wfx_hif_receive_indication(struct wfx_dev *wdev, const struct wfx_hif_msg *hif,\n\t\t\t\t      const void *buf, struct sk_buff *skb)\n{\n\tstruct wfx_vif *wvif = wdev_to_wvif(wdev, hif->interface);\n\tconst struct wfx_hif_ind_rx *body = buf;\n\n\tif (!wvif) {\n\t\tdev_warn(wdev->dev, \"%s: received event for non-existent vif\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\tskb_pull(skb, sizeof(struct wfx_hif_msg) + sizeof(struct wfx_hif_ind_rx));\n\twfx_rx_cb(wvif, body, skb);\n\n\treturn 0;\n}\n\nstatic int wfx_hif_event_indication(struct wfx_dev *wdev,\n\t\t\t\t    const struct wfx_hif_msg *hif, const void *buf)\n{\n\tstruct wfx_vif *wvif = wdev_to_wvif(wdev, hif->interface);\n\tconst struct wfx_hif_ind_event *body = buf;\n\tint type = le32_to_cpu(body->event_id);\n\n\tif (!wvif) {\n\t\tdev_warn(wdev->dev, \"%s: received event for non-existent vif\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\tswitch (type) {\n\tcase HIF_EVENT_IND_RCPI_RSSI:\n\t\twfx_event_report_rssi(wvif, body->event_data.rcpi_rssi);\n\t\tbreak;\n\tcase HIF_EVENT_IND_BSSLOST:\n\t\tschedule_delayed_work(&wvif->beacon_loss_work, 0);\n\t\tbreak;\n\tcase HIF_EVENT_IND_BSSREGAINED:\n\t\tcancel_delayed_work(&wvif->beacon_loss_work);\n\t\tdev_dbg(wdev->dev, \"ignore BSSREGAINED indication\\n\");\n\t\tbreak;\n\tcase HIF_EVENT_IND_PS_MODE_ERROR:\n\t\tdev_warn(wdev->dev, \"error while processing power save request: %d\\n\",\n\t\t\t le32_to_cpu(body->event_data.ps_mode_error));\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(wdev->dev, \"unhandled event indication: %.2x\\n\", type);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int wfx_hif_pm_mode_complete_indication(struct wfx_dev *wdev,\n\t\t\t\t\t       const struct wfx_hif_msg *hif, const void *buf)\n{\n\tstruct wfx_vif *wvif = wdev_to_wvif(wdev, hif->interface);\n\n\tif (!wvif) {\n\t\tdev_warn(wdev->dev, \"%s: received event for non-existent vif\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\tcomplete(&wvif->set_pm_mode_complete);\n\n\treturn 0;\n}\n\nstatic int wfx_hif_scan_complete_indication(struct wfx_dev *wdev,\n\t\t\t\t\t    const struct wfx_hif_msg *hif, const void *buf)\n{\n\tstruct wfx_vif *wvif = wdev_to_wvif(wdev, hif->interface);\n\tconst struct wfx_hif_ind_scan_cmpl *body = buf;\n\n\tif (!wvif) {\n\t\tdev_warn(wdev->dev, \"%s: received event for non-existent vif\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\twfx_scan_complete(wvif, body->num_channels_completed);\n\n\treturn 0;\n}\n\nstatic int wfx_hif_join_complete_indication(struct wfx_dev *wdev,\n\t\t\t\t\t    const struct wfx_hif_msg *hif, const void *buf)\n{\n\tstruct wfx_vif *wvif = wdev_to_wvif(wdev, hif->interface);\n\n\tif (!wvif) {\n\t\tdev_warn(wdev->dev, \"%s: received event for non-existent vif\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\tdev_warn(wdev->dev, \"unattended JoinCompleteInd\\n\");\n\n\treturn 0;\n}\n\nstatic int wfx_hif_suspend_resume_indication(struct wfx_dev *wdev,\n\t\t\t\t\t     const struct wfx_hif_msg *hif, const void *buf)\n{\n\tconst struct wfx_hif_ind_suspend_resume_tx *body = buf;\n\tstruct wfx_vif *wvif;\n\n\tif (body->bc_mc_only) {\n\t\twvif = wdev_to_wvif(wdev, hif->interface);\n\t\tif (!wvif) {\n\t\t\tdev_warn(wdev->dev, \"%s: received event for non-existent vif\\n\", __func__);\n\t\t\treturn -EIO;\n\t\t}\n\t\tif (body->resume)\n\t\t\twfx_suspend_resume_mc(wvif, STA_NOTIFY_AWAKE);\n\t\telse\n\t\t\twfx_suspend_resume_mc(wvif, STA_NOTIFY_SLEEP);\n\t} else {\n\t\tWARN(body->peer_sta_set, \"misunderstood indication\");\n\t\tWARN(hif->interface != 2, \"misunderstood indication\");\n\t\tif (body->resume)\n\t\t\twfx_suspend_hot_dev(wdev, STA_NOTIFY_AWAKE);\n\t\telse\n\t\t\twfx_suspend_hot_dev(wdev, STA_NOTIFY_SLEEP);\n\t}\n\n\treturn 0;\n}\n\nstatic int wfx_hif_generic_indication(struct wfx_dev *wdev,\n\t\t\t\t      const struct wfx_hif_msg *hif, const void *buf)\n{\n\tconst struct wfx_hif_ind_generic *body = buf;\n\tint type = le32_to_cpu(body->type);\n\n\tswitch (type) {\n\tcase HIF_GENERIC_INDICATION_TYPE_RAW:\n\t\treturn 0;\n\tcase HIF_GENERIC_INDICATION_TYPE_STRING:\n\t\tdev_info(wdev->dev, \"firmware says: %s\\n\", (char *)&body->data);\n\t\treturn 0;\n\tcase HIF_GENERIC_INDICATION_TYPE_RX_STATS:\n\t\tmutex_lock(&wdev->rx_stats_lock);\n\t\t \n\t\tif (!wfx_api_older_than(wdev, 1, 4))\n\t\t\tdev_info(wdev->dev, \"Rx test ongoing. Temperature: %d degrees C\\n\",\n\t\t\t\t body->data.rx_stats.current_temp);\n\t\tmemcpy(&wdev->rx_stats, &body->data.rx_stats, sizeof(wdev->rx_stats));\n\t\tmutex_unlock(&wdev->rx_stats_lock);\n\t\treturn 0;\n\tcase HIF_GENERIC_INDICATION_TYPE_TX_POWER_LOOP_INFO:\n\t\tmutex_lock(&wdev->tx_power_loop_info_lock);\n\t\tmemcpy(&wdev->tx_power_loop_info, &body->data.tx_power_loop_info,\n\t\t       sizeof(wdev->tx_power_loop_info));\n\t\tmutex_unlock(&wdev->tx_power_loop_info_lock);\n\t\treturn 0;\n\tdefault:\n\t\tdev_err(wdev->dev, \"generic_indication: unknown indication type: %#.8x\\n\", type);\n\t\treturn -EIO;\n\t}\n}\n\nstatic const struct {\n\tint val;\n\tconst char *str;\n\tbool has_param;\n} hif_errors[] = {\n\t{ HIF_ERROR_FIRMWARE_ROLLBACK,\n\t\t\"rollback status\" },\n\t{ HIF_ERROR_FIRMWARE_DEBUG_ENABLED,\n\t\t\"debug feature enabled\" },\n\t{ HIF_ERROR_PDS_PAYLOAD,\n\t\t\"PDS version is not supported\" },\n\t{ HIF_ERROR_PDS_TESTFEATURE,\n\t\t\"PDS ask for an unknown test mode\" },\n\t{ HIF_ERROR_OOR_VOLTAGE,\n\t\t\"out-of-range power supply voltage\", true },\n\t{ HIF_ERROR_OOR_TEMPERATURE,\n\t\t\"out-of-range temperature\", true },\n\t{ HIF_ERROR_SLK_REQ_DURING_KEY_EXCHANGE,\n\t\t\"secure link does not expect request during key exchange\" },\n\t{ HIF_ERROR_SLK_SESSION_KEY,\n\t\t\"secure link session key is invalid\" },\n\t{ HIF_ERROR_SLK_OVERFLOW,\n\t\t\"secure link overflow\" },\n\t{ HIF_ERROR_SLK_WRONG_ENCRYPTION_STATE,\n\t\t\"secure link messages list does not match message encryption\" },\n\t{ HIF_ERROR_SLK_UNCONFIGURED,\n\t\t\"secure link not yet configured\" },\n\t{ HIF_ERROR_HIF_BUS_FREQUENCY_TOO_LOW,\n\t\t\"bus clock is too slow (<1kHz)\" },\n\t{ HIF_ERROR_HIF_RX_DATA_TOO_LARGE,\n\t\t\"HIF message too large\" },\n\t \n\t{ HIF_ERROR_HIF_TX_QUEUE_FULL,\n\t\t\"HIF messages queue is full\" },\n\t{ HIF_ERROR_HIF_BUS,\n\t\t\"HIF bus\" },\n\t{ HIF_ERROR_SLK_MULTI_TX_UNSUPPORTED,\n\t\t\"secure link does not support multi-tx confirmations\" },\n\t{ HIF_ERROR_SLK_OUTDATED_SESSION_KEY,\n\t\t\"secure link session key is outdated\" },\n\t{ HIF_ERROR_SLK_DECRYPTION,\n\t\t\"secure link params (nonce or tag) mismatch\" },\n};\n\nstatic int wfx_hif_error_indication(struct wfx_dev *wdev,\n\t\t\t\t    const struct wfx_hif_msg *hif, const void *buf)\n{\n\tconst struct wfx_hif_ind_error *body = buf;\n\tint type = le32_to_cpu(body->type);\n\tint param = (s8)body->data[0];\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(hif_errors); i++)\n\t\tif (type == hif_errors[i].val)\n\t\t\tbreak;\n\tif (i < ARRAY_SIZE(hif_errors))\n\t\tif (hif_errors[i].has_param)\n\t\t\tdev_err(wdev->dev, \"asynchronous error: %s: %d\\n\",\n\t\t\t\thif_errors[i].str, param);\n\t\telse\n\t\t\tdev_err(wdev->dev, \"asynchronous error: %s\\n\", hif_errors[i].str);\n\telse\n\t\tdev_err(wdev->dev, \"asynchronous error: unknown: %08x\\n\", type);\n\tprint_hex_dump(KERN_INFO, \"hif: \", DUMP_PREFIX_OFFSET,\n\t\t       16, 1, hif, le16_to_cpu(hif->len), false);\n\twdev->chip_frozen = true;\n\n\treturn 0;\n};\n\nstatic int wfx_hif_exception_indication(struct wfx_dev *wdev,\n\t\t\t\t\tconst struct wfx_hif_msg *hif, const void *buf)\n{\n\tconst struct wfx_hif_ind_exception *body = buf;\n\tint type = le32_to_cpu(body->type);\n\n\tif (type == 4)\n\t\tdev_err(wdev->dev, \"firmware assert %d\\n\", le32_to_cpup((__le32 *)body->data));\n\telse\n\t\tdev_err(wdev->dev, \"firmware exception\\n\");\n\tprint_hex_dump(KERN_INFO, \"hif: \", DUMP_PREFIX_OFFSET,\n\t\t       16, 1, hif, le16_to_cpu(hif->len), false);\n\twdev->chip_frozen = true;\n\n\treturn -1;\n}\n\nstatic const struct {\n\tint msg_id;\n\tint (*handler)(struct wfx_dev *wdev, const struct wfx_hif_msg *hif, const void *buf);\n} hif_handlers[] = {\n\t \n\t{ HIF_CNF_ID_TX,                wfx_hif_tx_confirm },\n\t{ HIF_CNF_ID_MULTI_TRANSMIT,    wfx_hif_multi_tx_confirm },\n\t \n\t{ HIF_IND_ID_STARTUP,           wfx_hif_startup_indication },\n\t{ HIF_IND_ID_WAKEUP,            wfx_hif_wakeup_indication },\n\t{ HIF_IND_ID_JOIN_COMPLETE,     wfx_hif_join_complete_indication },\n\t{ HIF_IND_ID_SET_PM_MODE_CMPL,  wfx_hif_pm_mode_complete_indication },\n\t{ HIF_IND_ID_SCAN_CMPL,         wfx_hif_scan_complete_indication },\n\t{ HIF_IND_ID_SUSPEND_RESUME_TX, wfx_hif_suspend_resume_indication },\n\t{ HIF_IND_ID_EVENT,             wfx_hif_event_indication },\n\t{ HIF_IND_ID_GENERIC,           wfx_hif_generic_indication },\n\t{ HIF_IND_ID_ERROR,             wfx_hif_error_indication },\n\t{ HIF_IND_ID_EXCEPTION,         wfx_hif_exception_indication },\n\t \n\t\n};\n\nvoid wfx_handle_rx(struct wfx_dev *wdev, struct sk_buff *skb)\n{\n\tint i;\n\tconst struct wfx_hif_msg *hif = (const struct wfx_hif_msg *)skb->data;\n\tint hif_id = hif->id;\n\n\tif (hif_id == HIF_IND_ID_RX) {\n\t\t \n\t\twfx_hif_receive_indication(wdev, hif, hif->body, skb);\n\t\treturn;\n\t}\n\t \n\tif (mutex_is_locked(&wdev->hif_cmd.lock) &&\n\t    wdev->hif_cmd.buf_send && wdev->hif_cmd.buf_send->id == hif_id) {\n\t\twfx_hif_generic_confirm(wdev, hif, hif->body);\n\t\tgoto free;\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(hif_handlers); i++) {\n\t\tif (hif_handlers[i].msg_id == hif_id) {\n\t\t\tif (hif_handlers[i].handler)\n\t\t\t\thif_handlers[i].handler(wdev, hif, hif->body);\n\t\t\tgoto free;\n\t\t}\n\t}\n\tif (hif_id & HIF_ID_IS_INDICATION)\n\t\tdev_err(wdev->dev, \"unsupported HIF indication: ID %02x\\n\", hif_id);\n\telse\n\t\tdev_err(wdev->dev, \"unexpected HIF confirmation: ID %02x\\n\", hif_id);\nfree:\n\tdev_kfree_skb(skb);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}