{
  "module_name": "key.c",
  "hash_id": "d7a6422c1293a338acb9932caca94874273ae643a082416258b616fa242228eb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/silabs/wfx/key.c",
  "human_readable_source": "\n \n#include <linux/etherdevice.h>\n#include <net/mac80211.h>\n\n#include \"key.h\"\n#include \"wfx.h\"\n#include \"hif_tx_mib.h\"\n\nstatic int wfx_alloc_key(struct wfx_dev *wdev)\n{\n\tint idx;\n\n\tidx = ffs(~wdev->key_map) - 1;\n\tif (idx < 0 || idx >= MAX_KEY_ENTRIES)\n\t\treturn -1;\n\n\twdev->key_map |= BIT(idx);\n\treturn idx;\n}\n\nstatic void wfx_free_key(struct wfx_dev *wdev, int idx)\n{\n\tWARN(!(wdev->key_map & BIT(idx)), \"inconsistent key allocation\");\n\twdev->key_map &= ~BIT(idx);\n}\n\nstatic u8 fill_wep_pair(struct wfx_hif_wep_pairwise_key *msg,\n\t\t\tstruct ieee80211_key_conf *key, u8 *peer_addr)\n{\n\tWARN(key->keylen > sizeof(msg->key_data), \"inconsistent data\");\n\tmsg->key_length = key->keylen;\n\tmemcpy(msg->key_data, key->key, key->keylen);\n\tether_addr_copy(msg->peer_address, peer_addr);\n\treturn HIF_KEY_TYPE_WEP_PAIRWISE;\n}\n\nstatic u8 fill_wep_group(struct wfx_hif_wep_group_key *msg,\n\t\t\t struct ieee80211_key_conf *key)\n{\n\tWARN(key->keylen > sizeof(msg->key_data), \"inconsistent data\");\n\tmsg->key_id = key->keyidx;\n\tmsg->key_length = key->keylen;\n\tmemcpy(msg->key_data, key->key, key->keylen);\n\treturn HIF_KEY_TYPE_WEP_DEFAULT;\n}\n\nstatic u8 fill_tkip_pair(struct wfx_hif_tkip_pairwise_key *msg,\n\t\t\t struct ieee80211_key_conf *key, u8 *peer_addr)\n{\n\tu8 *keybuf = key->key;\n\n\tWARN(key->keylen != sizeof(msg->tkip_key_data) + sizeof(msg->tx_mic_key) +\n\t\t\t    sizeof(msg->rx_mic_key), \"inconsistent data\");\n\tmemcpy(msg->tkip_key_data, keybuf, sizeof(msg->tkip_key_data));\n\tkeybuf += sizeof(msg->tkip_key_data);\n\tmemcpy(msg->tx_mic_key, keybuf, sizeof(msg->tx_mic_key));\n\tkeybuf += sizeof(msg->tx_mic_key);\n\tmemcpy(msg->rx_mic_key, keybuf, sizeof(msg->rx_mic_key));\n\tether_addr_copy(msg->peer_address, peer_addr);\n\treturn HIF_KEY_TYPE_TKIP_PAIRWISE;\n}\n\nstatic u8 fill_tkip_group(struct wfx_hif_tkip_group_key *msg, struct ieee80211_key_conf *key,\n\t\t\t  struct ieee80211_key_seq *seq, enum nl80211_iftype iftype)\n{\n\tu8 *keybuf = key->key;\n\n\tWARN(key->keylen != sizeof(msg->tkip_key_data) + 2 * sizeof(msg->rx_mic_key),\n\t     \"inconsistent data\");\n\tmsg->key_id = key->keyidx;\n\tmemcpy(msg->rx_sequence_counter, &seq->tkip.iv16, sizeof(seq->tkip.iv16));\n\tmemcpy(msg->rx_sequence_counter + sizeof(u16), &seq->tkip.iv32, sizeof(seq->tkip.iv32));\n\tmemcpy(msg->tkip_key_data, keybuf, sizeof(msg->tkip_key_data));\n\tkeybuf += sizeof(msg->tkip_key_data);\n\tif (iftype == NL80211_IFTYPE_AP)\n\t\t \n\t\tmemcpy(msg->rx_mic_key, keybuf + 0, sizeof(msg->rx_mic_key));\n\telse\n\t\t \n\t\tmemcpy(msg->rx_mic_key, keybuf + 8, sizeof(msg->rx_mic_key));\n\treturn HIF_KEY_TYPE_TKIP_GROUP;\n}\n\nstatic u8 fill_ccmp_pair(struct wfx_hif_aes_pairwise_key *msg,\n\t\t\t struct ieee80211_key_conf *key, u8 *peer_addr)\n{\n\tWARN(key->keylen != sizeof(msg->aes_key_data), \"inconsistent data\");\n\tether_addr_copy(msg->peer_address, peer_addr);\n\tmemcpy(msg->aes_key_data, key->key, key->keylen);\n\treturn HIF_KEY_TYPE_AES_PAIRWISE;\n}\n\nstatic u8 fill_ccmp_group(struct wfx_hif_aes_group_key *msg,\n\t\t\t  struct ieee80211_key_conf *key, struct ieee80211_key_seq *seq)\n{\n\tWARN(key->keylen != sizeof(msg->aes_key_data), \"inconsistent data\");\n\tmemcpy(msg->aes_key_data, key->key, key->keylen);\n\tmemcpy(msg->rx_sequence_counter, seq->ccmp.pn, sizeof(seq->ccmp.pn));\n\tmemreverse(msg->rx_sequence_counter, sizeof(seq->ccmp.pn));\n\tmsg->key_id = key->keyidx;\n\treturn HIF_KEY_TYPE_AES_GROUP;\n}\n\nstatic u8 fill_sms4_pair(struct wfx_hif_wapi_pairwise_key *msg,\n\t\t\t struct ieee80211_key_conf *key, u8 *peer_addr)\n{\n\tu8 *keybuf = key->key;\n\n\tWARN(key->keylen != sizeof(msg->wapi_key_data) + sizeof(msg->mic_key_data),\n\t     \"inconsistent data\");\n\tether_addr_copy(msg->peer_address, peer_addr);\n\tmemcpy(msg->wapi_key_data, keybuf, sizeof(msg->wapi_key_data));\n\tkeybuf += sizeof(msg->wapi_key_data);\n\tmemcpy(msg->mic_key_data, keybuf, sizeof(msg->mic_key_data));\n\tmsg->key_id = key->keyidx;\n\treturn HIF_KEY_TYPE_WAPI_PAIRWISE;\n}\n\nstatic u8 fill_sms4_group(struct wfx_hif_wapi_group_key *msg,\n\t\t\t  struct ieee80211_key_conf *key)\n{\n\tu8 *keybuf = key->key;\n\n\tWARN(key->keylen != sizeof(msg->wapi_key_data) + sizeof(msg->mic_key_data),\n\t     \"inconsistent data\");\n\tmemcpy(msg->wapi_key_data, keybuf, sizeof(msg->wapi_key_data));\n\tkeybuf += sizeof(msg->wapi_key_data);\n\tmemcpy(msg->mic_key_data, keybuf, sizeof(msg->mic_key_data));\n\tmsg->key_id = key->keyidx;\n\treturn HIF_KEY_TYPE_WAPI_GROUP;\n}\n\nstatic u8 fill_aes_cmac_group(struct wfx_hif_igtk_group_key *msg,\n\t\t\t      struct ieee80211_key_conf *key, struct ieee80211_key_seq *seq)\n{\n\tWARN(key->keylen != sizeof(msg->igtk_key_data), \"inconsistent data\");\n\tmemcpy(msg->igtk_key_data, key->key, key->keylen);\n\tmemcpy(msg->ipn, seq->aes_cmac.pn, sizeof(seq->aes_cmac.pn));\n\tmemreverse(msg->ipn, sizeof(seq->aes_cmac.pn));\n\tmsg->key_id = key->keyidx;\n\treturn HIF_KEY_TYPE_IGTK_GROUP;\n}\n\nstatic int wfx_add_key(struct wfx_vif *wvif, struct ieee80211_sta *sta,\n\t\t       struct ieee80211_key_conf *key)\n{\n\tint ret;\n\tstruct wfx_hif_req_add_key k = { };\n\tstruct ieee80211_key_seq seq;\n\tstruct wfx_dev *wdev = wvif->wdev;\n\tint idx = wfx_alloc_key(wvif->wdev);\n\tbool pairwise = key->flags & IEEE80211_KEY_FLAG_PAIRWISE;\n\tstruct ieee80211_vif *vif = wvif_to_vif(wvif);\n\n\tWARN(key->flags & IEEE80211_KEY_FLAG_PAIRWISE && !sta, \"inconsistent data\");\n\tieee80211_get_key_rx_seq(key, 0, &seq);\n\tif (idx < 0)\n\t\treturn -EINVAL;\n\tk.int_id = wvif->id;\n\tk.entry_index = idx;\n\tif (key->cipher == WLAN_CIPHER_SUITE_WEP40 ||\n\t    key->cipher == WLAN_CIPHER_SUITE_WEP104) {\n\t\tif (pairwise)\n\t\t\tk.type = fill_wep_pair(&k.key.wep_pairwise_key, key, sta->addr);\n\t\telse\n\t\t\tk.type = fill_wep_group(&k.key.wep_group_key, key);\n\t} else if (key->cipher == WLAN_CIPHER_SUITE_TKIP) {\n\t\tif (pairwise)\n\t\t\tk.type = fill_tkip_pair(&k.key.tkip_pairwise_key, key, sta->addr);\n\t\telse\n\t\t\tk.type = fill_tkip_group(&k.key.tkip_group_key, key, &seq,\n\t\t\t\t\t\t vif->type);\n\t} else if (key->cipher == WLAN_CIPHER_SUITE_CCMP) {\n\t\tif (pairwise)\n\t\t\tk.type = fill_ccmp_pair(&k.key.aes_pairwise_key, key, sta->addr);\n\t\telse\n\t\t\tk.type = fill_ccmp_group(&k.key.aes_group_key, key, &seq);\n\t} else if (key->cipher == WLAN_CIPHER_SUITE_SMS4) {\n\t\tif (pairwise)\n\t\t\tk.type = fill_sms4_pair(&k.key.wapi_pairwise_key, key, sta->addr);\n\t\telse\n\t\t\tk.type = fill_sms4_group(&k.key.wapi_group_key, key);\n\t} else if (key->cipher == WLAN_CIPHER_SUITE_AES_CMAC) {\n\t\tk.type = fill_aes_cmac_group(&k.key.igtk_group_key, key, &seq);\n\t\tkey->flags |= IEEE80211_KEY_FLAG_GENERATE_MMIE;\n\t} else {\n\t\tdev_warn(wdev->dev, \"unsupported key type %d\\n\", key->cipher);\n\t\twfx_free_key(wdev, idx);\n\t\treturn -EOPNOTSUPP;\n\t}\n\tret = wfx_hif_add_key(wdev, &k);\n\tif (ret) {\n\t\twfx_free_key(wdev, idx);\n\t\treturn -EOPNOTSUPP;\n\t}\n\tkey->flags |= IEEE80211_KEY_FLAG_PUT_IV_SPACE | IEEE80211_KEY_FLAG_RESERVE_TAILROOM;\n\tkey->hw_key_idx = idx;\n\treturn 0;\n}\n\nstatic int wfx_remove_key(struct wfx_vif *wvif, struct ieee80211_key_conf *key)\n{\n\tWARN(key->hw_key_idx >= MAX_KEY_ENTRIES, \"corrupted hw_key_idx\");\n\twfx_free_key(wvif->wdev, key->hw_key_idx);\n\treturn wfx_hif_remove_key(wvif->wdev, key->hw_key_idx);\n}\n\nint wfx_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd, struct ieee80211_vif *vif,\n\t\tstruct ieee80211_sta *sta, struct ieee80211_key_conf *key)\n{\n\tint ret = -EOPNOTSUPP;\n\tstruct wfx_vif *wvif = (struct wfx_vif *)vif->drv_priv;\n\n\tmutex_lock(&wvif->wdev->conf_mutex);\n\tif (cmd == SET_KEY)\n\t\tret = wfx_add_key(wvif, sta, key);\n\tif (cmd == DISABLE_KEY)\n\t\tret = wfx_remove_key(wvif, key);\n\tmutex_unlock(&wvif->wdev->conf_mutex);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}