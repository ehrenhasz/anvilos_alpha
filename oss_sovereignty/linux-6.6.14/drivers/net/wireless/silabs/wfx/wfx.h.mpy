{
  "module_name": "wfx.h",
  "hash_id": "dc5a5eb449228a8c89b6eeebda7a6cdc7508736029d22c36b09ce6dca3551ecb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/silabs/wfx/wfx.h",
  "human_readable_source": " \n \n#ifndef WFX_H\n#define WFX_H\n\n#include <linux/completion.h>\n#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/nospec.h>\n#include <net/mac80211.h>\n\n#include \"bh.h\"\n#include \"data_tx.h\"\n#include \"main.h\"\n#include \"queue.h\"\n#include \"hif_tx.h\"\n\n#define USEC_PER_TXOP 32  \n#define USEC_PER_TU 1024\n\nstruct wfx_hwbus_ops;\n\nstruct wfx_dev {\n\tstruct wfx_platform_data   pdata;\n\tstruct device              *dev;\n\tstruct ieee80211_hw        *hw;\n\tstruct ieee80211_vif       *vif[2];\n\tstruct mac_address         addresses[2];\n\tconst struct wfx_hwbus_ops *hwbus_ops;\n\tvoid                       *hwbus_priv;\n\n\tu8                         keyset;\n\tstruct completion          firmware_ready;\n\tstruct wfx_hif_ind_startup hw_caps;\n\tstruct wfx_hif             hif;\n\tstruct delayed_work        cooling_timeout_work;\n\tbool                       poll_irq;\n\tbool                       chip_frozen;\n\tstruct mutex               conf_mutex;\n\n\tstruct wfx_hif_cmd         hif_cmd;\n\tstruct sk_buff_head        tx_pending;\n\twait_queue_head_t          tx_dequeue;\n\tatomic_t                   tx_lock;\n\n\tatomic_t                   packet_id;\n\tu32                        key_map;\n\n\tstruct wfx_hif_rx_stats    rx_stats;\n\tstruct mutex               rx_stats_lock;\n\tstruct wfx_hif_tx_power_loop_info tx_power_loop_info;\n\tstruct mutex               tx_power_loop_info_lock;\n\tstruct workqueue_struct    *bh_wq;\n};\n\nstruct wfx_vif {\n\tstruct wfx_dev             *wdev;\n\tstruct ieee80211_channel   *channel;\n\tint                        id;\n\n\tu32                        link_id_map;\n\n\tbool                       after_dtim_tx_allowed;\n\tbool                       join_in_progress;\n\n\tstruct delayed_work        beacon_loss_work;\n\n\tstruct wfx_queue           tx_queue[4];\n\tstruct wfx_tx_policy_cache tx_policy_cache;\n\tstruct work_struct         tx_policy_upload_work;\n\n\tstruct work_struct         update_tim_work;\n\n\tunsigned long              uapsd_mask;\n\n\t \n\tstruct mutex               scan_lock;\n\tstruct work_struct         scan_work;\n\tstruct completion          scan_complete;\n\tint                        scan_nb_chan_done;\n\tbool                       scan_abort;\n\tstruct ieee80211_scan_request *scan_req;\n\n\tstruct completion          set_pm_mode_complete;\n};\n\nstatic inline struct ieee80211_vif *wvif_to_vif(struct wfx_vif *wvif)\n{\n\treturn container_of((void *)wvif, struct ieee80211_vif, drv_priv);\n}\n\nstatic inline struct wfx_vif *wdev_to_wvif(struct wfx_dev *wdev, int vif_id)\n{\n\tif (vif_id >= ARRAY_SIZE(wdev->vif)) {\n\t\tdev_dbg(wdev->dev, \"requesting non-existent vif: %d\\n\", vif_id);\n\t\treturn NULL;\n\t}\n\tvif_id = array_index_nospec(vif_id, ARRAY_SIZE(wdev->vif));\n\tif (!wdev->vif[vif_id])\n\t\treturn NULL;\n\treturn (struct wfx_vif *)wdev->vif[vif_id]->drv_priv;\n}\n\nstatic inline struct wfx_vif *wvif_iterate(struct wfx_dev *wdev, struct wfx_vif *cur)\n{\n\tint i;\n\tint mark = 0;\n\tstruct wfx_vif *tmp;\n\n\tif (!cur)\n\t\tmark = 1;\n\tfor (i = 0; i < ARRAY_SIZE(wdev->vif); i++) {\n\t\ttmp = wdev_to_wvif(wdev, i);\n\t\tif (mark && tmp)\n\t\t\treturn tmp;\n\t\tif (tmp == cur)\n\t\t\tmark = 1;\n\t}\n\treturn NULL;\n}\n\nstatic inline int wvif_count(struct wfx_dev *wdev)\n{\n\tint i;\n\tint ret = 0;\n\tstruct wfx_vif *wvif;\n\n\tfor (i = 0; i < ARRAY_SIZE(wdev->vif); i++) {\n\t\twvif = wdev_to_wvif(wdev, i);\n\t\tif (wvif)\n\t\t\tret++;\n\t}\n\treturn ret;\n}\n\nstatic inline void memreverse(u8 *src, u8 length)\n{\n\tu8 *lo = src;\n\tu8 *hi = src + length - 1;\n\tu8 swap;\n\n\twhile (lo < hi) {\n\t\tswap = *lo;\n\t\t*lo++ = *hi;\n\t\t*hi-- = swap;\n\t}\n}\n\nstatic inline int memzcmp(void *src, unsigned int size)\n{\n\tu8 *buf = src;\n\n\tif (!size)\n\t\treturn 0;\n\tif (*buf)\n\t\treturn 1;\n\treturn memcmp(buf, buf + 1, size - 1);\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}