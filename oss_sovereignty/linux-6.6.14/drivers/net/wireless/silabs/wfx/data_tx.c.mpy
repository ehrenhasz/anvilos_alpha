{
  "module_name": "data_tx.c",
  "hash_id": "d6c8ff5e48abae46c88222b80fff0dfec8410d411a54ac31a0c4526fbe47340f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/silabs/wfx/data_tx.c",
  "human_readable_source": "\n \n#include <net/mac80211.h>\n#include <linux/etherdevice.h>\n\n#include \"data_tx.h\"\n#include \"wfx.h\"\n#include \"bh.h\"\n#include \"sta.h\"\n#include \"queue.h\"\n#include \"debug.h\"\n#include \"traces.h\"\n#include \"hif_tx_mib.h\"\n\nstatic int wfx_get_hw_rate(struct wfx_dev *wdev, const struct ieee80211_tx_rate *rate)\n{\n\tstruct ieee80211_supported_band *band;\n\n\tif (rate->idx < 0)\n\t\treturn -1;\n\tif (rate->flags & IEEE80211_TX_RC_MCS) {\n\t\tif (rate->idx > 7) {\n\t\t\tWARN(1, \"wrong rate->idx value: %d\", rate->idx);\n\t\t\treturn -1;\n\t\t}\n\t\treturn rate->idx + 14;\n\t}\n\t \n\tband = wdev->hw->wiphy->bands[NL80211_BAND_2GHZ];\n\tif (rate->idx >= band->n_bitrates) {\n\t\tWARN(1, \"wrong rate->idx value: %d\", rate->idx);\n\t\treturn -1;\n\t}\n\treturn band->bitrates[rate->idx].hw_value;\n}\n\n \n\nstatic void wfx_tx_policy_build(struct wfx_vif *wvif, struct wfx_tx_policy *policy,\n\t\t\t\tstruct ieee80211_tx_rate *rates)\n{\n\tstruct wfx_dev *wdev = wvif->wdev;\n\tint i, rateid;\n\tu8 count;\n\n\tWARN(rates[0].idx < 0, \"invalid rate policy\");\n\tmemset(policy, 0, sizeof(*policy));\n\tfor (i = 0; i < IEEE80211_TX_MAX_RATES; ++i) {\n\t\tif (rates[i].idx < 0)\n\t\t\tbreak;\n\t\tWARN_ON(rates[i].count > 15);\n\t\trateid = wfx_get_hw_rate(wdev, &rates[i]);\n\t\t \n\t\tcount = rates[i].count;\n\t\tif (rateid % 2)\n\t\t\tcount <<= 4;\n\t\tpolicy->rates[rateid / 2] |= count;\n\t}\n}\n\nstatic bool wfx_tx_policy_is_equal(const struct wfx_tx_policy *a, const struct wfx_tx_policy *b)\n{\n\treturn !memcmp(a->rates, b->rates, sizeof(a->rates));\n}\n\nstatic int wfx_tx_policy_find(struct wfx_tx_policy_cache *cache, struct wfx_tx_policy *wanted)\n{\n\tstruct wfx_tx_policy *it;\n\n\tlist_for_each_entry(it, &cache->used, link)\n\t\tif (wfx_tx_policy_is_equal(wanted, it))\n\t\t\treturn it - cache->cache;\n\tlist_for_each_entry(it, &cache->free, link)\n\t\tif (wfx_tx_policy_is_equal(wanted, it))\n\t\t\treturn it - cache->cache;\n\treturn -1;\n}\n\nstatic void wfx_tx_policy_use(struct wfx_tx_policy_cache *cache, struct wfx_tx_policy *entry)\n{\n\t++entry->usage_count;\n\tlist_move(&entry->link, &cache->used);\n}\n\nstatic int wfx_tx_policy_release(struct wfx_tx_policy_cache *cache, struct wfx_tx_policy *entry)\n{\n\tint ret = --entry->usage_count;\n\n\tif (!ret)\n\t\tlist_move(&entry->link, &cache->free);\n\treturn ret;\n}\n\nstatic int wfx_tx_policy_get(struct wfx_vif *wvif, struct ieee80211_tx_rate *rates, bool *renew)\n{\n\tint idx;\n\tstruct wfx_tx_policy_cache *cache = &wvif->tx_policy_cache;\n\tstruct wfx_tx_policy wanted;\n\tstruct wfx_tx_policy *entry;\n\n\twfx_tx_policy_build(wvif, &wanted, rates);\n\n\tspin_lock_bh(&cache->lock);\n\tif (list_empty(&cache->free)) {\n\t\tWARN(1, \"unable to get a valid Tx policy\");\n\t\tspin_unlock_bh(&cache->lock);\n\t\treturn HIF_TX_RETRY_POLICY_INVALID;\n\t}\n\tidx = wfx_tx_policy_find(cache, &wanted);\n\tif (idx >= 0) {\n\t\t*renew = false;\n\t} else {\n\t\t \n\t\t*renew = true;\n\t\tentry = list_entry(cache->free.prev, struct wfx_tx_policy, link);\n\t\tmemcpy(entry->rates, wanted.rates, sizeof(entry->rates));\n\t\tentry->uploaded = false;\n\t\tentry->usage_count = 0;\n\t\tidx = entry - cache->cache;\n\t}\n\twfx_tx_policy_use(cache, &cache->cache[idx]);\n\tif (list_empty(&cache->free))\n\t\tieee80211_stop_queues(wvif->wdev->hw);\n\tspin_unlock_bh(&cache->lock);\n\treturn idx;\n}\n\nstatic void wfx_tx_policy_put(struct wfx_vif *wvif, int idx)\n{\n\tint usage, locked;\n\tstruct wfx_tx_policy_cache *cache = &wvif->tx_policy_cache;\n\n\tif (idx == HIF_TX_RETRY_POLICY_INVALID)\n\t\treturn;\n\tspin_lock_bh(&cache->lock);\n\tlocked = list_empty(&cache->free);\n\tusage = wfx_tx_policy_release(cache, &cache->cache[idx]);\n\tif (locked && !usage)\n\t\tieee80211_wake_queues(wvif->wdev->hw);\n\tspin_unlock_bh(&cache->lock);\n}\n\nstatic int wfx_tx_policy_upload(struct wfx_vif *wvif)\n{\n\tstruct wfx_tx_policy *policies = wvif->tx_policy_cache.cache;\n\tu8 tmp_rates[12];\n\tint i, is_used;\n\n\tdo {\n\t\tspin_lock_bh(&wvif->tx_policy_cache.lock);\n\t\tfor (i = 0; i < ARRAY_SIZE(wvif->tx_policy_cache.cache); ++i) {\n\t\t\tis_used = memzcmp(policies[i].rates, sizeof(policies[i].rates));\n\t\t\tif (!policies[i].uploaded && is_used)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i < ARRAY_SIZE(wvif->tx_policy_cache.cache)) {\n\t\t\tpolicies[i].uploaded = true;\n\t\t\tmemcpy(tmp_rates, policies[i].rates, sizeof(tmp_rates));\n\t\t\tspin_unlock_bh(&wvif->tx_policy_cache.lock);\n\t\t\twfx_hif_set_tx_rate_retry_policy(wvif, i, tmp_rates);\n\t\t} else {\n\t\t\tspin_unlock_bh(&wvif->tx_policy_cache.lock);\n\t\t}\n\t} while (i < ARRAY_SIZE(wvif->tx_policy_cache.cache));\n\treturn 0;\n}\n\nvoid wfx_tx_policy_upload_work(struct work_struct *work)\n{\n\tstruct wfx_vif *wvif = container_of(work, struct wfx_vif, tx_policy_upload_work);\n\n\twfx_tx_policy_upload(wvif);\n\twfx_tx_unlock(wvif->wdev);\n}\n\nvoid wfx_tx_policy_init(struct wfx_vif *wvif)\n{\n\tstruct wfx_tx_policy_cache *cache = &wvif->tx_policy_cache;\n\tint i;\n\n\tmemset(cache, 0, sizeof(*cache));\n\n\tspin_lock_init(&cache->lock);\n\tINIT_LIST_HEAD(&cache->used);\n\tINIT_LIST_HEAD(&cache->free);\n\n\tfor (i = 0; i < ARRAY_SIZE(cache->cache); ++i)\n\t\tlist_add(&cache->cache[i].link, &cache->free);\n}\n\n \n\nstatic bool wfx_is_action_back(struct ieee80211_hdr *hdr)\n{\n\tstruct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)hdr;\n\n\tif (!ieee80211_is_action(mgmt->frame_control))\n\t\treturn false;\n\tif (mgmt->u.action.category != WLAN_CATEGORY_BACK)\n\t\treturn false;\n\treturn true;\n}\n\nstatic u8 wfx_tx_get_link_id(struct wfx_vif *wvif, struct ieee80211_sta *sta,\n\t\t\t     struct ieee80211_hdr *hdr)\n{\n\tstruct wfx_sta_priv *sta_priv = sta ? (struct wfx_sta_priv *)&sta->drv_priv : NULL;\n\tstruct ieee80211_vif *vif = wvif_to_vif(wvif);\n\tconst u8 *da = ieee80211_get_DA(hdr);\n\n\tif (sta_priv && sta_priv->link_id)\n\t\treturn sta_priv->link_id;\n\tif (vif->type != NL80211_IFTYPE_AP)\n\t\treturn 0;\n\tif (is_multicast_ether_addr(da))\n\t\treturn 0;\n\treturn HIF_LINK_ID_NOT_ASSOCIATED;\n}\n\nstatic void wfx_tx_fixup_rates(struct ieee80211_tx_rate *rates)\n{\n\tbool has_rate0 = false;\n\tint i, j;\n\n\tfor (i = 1, j = 1; j < IEEE80211_TX_MAX_RATES; j++) {\n\t\tif (rates[j].idx == -1)\n\t\t\tbreak;\n\t\t \n\t\tif (rates[j].idx >= rates[i - 1].idx) {\n\t\t\trates[i - 1].count += rates[j].count;\n\t\t\trates[i - 1].count = min_t(u16, 15, rates[i - 1].count);\n\t\t} else {\n\t\t\tmemcpy(rates + i, rates + j, sizeof(rates[i]));\n\t\t\tif (rates[i].idx == 0)\n\t\t\t\thas_rate0 = true;\n\t\t\t \n\t\t\trates[i].flags &= ~IEEE80211_TX_RC_SHORT_GI;\n\t\t\ti++;\n\t\t}\n\t}\n\t \n\tif (!has_rate0 && i < IEEE80211_TX_MAX_RATES) {\n\t\trates[i].idx = 0;\n\t\trates[i].count = 8;  \n\t\trates[i].flags = rates[0].flags & IEEE80211_TX_RC_MCS;\n\t\ti++;\n\t}\n\tfor (; i < IEEE80211_TX_MAX_RATES; i++) {\n\t\tmemset(rates + i, 0, sizeof(rates[i]));\n\t\trates[i].idx = -1;\n\t}\n}\n\nstatic u8 wfx_tx_get_retry_policy_id(struct wfx_vif *wvif, struct ieee80211_tx_info *tx_info)\n{\n\tbool tx_policy_renew = false;\n\tu8 ret;\n\n\tret = wfx_tx_policy_get(wvif, tx_info->driver_rates, &tx_policy_renew);\n\tif (ret == HIF_TX_RETRY_POLICY_INVALID)\n\t\tdev_warn(wvif->wdev->dev, \"unable to get a valid Tx policy\");\n\n\tif (tx_policy_renew) {\n\t\twfx_tx_lock(wvif->wdev);\n\t\tif (!schedule_work(&wvif->tx_policy_upload_work))\n\t\t\twfx_tx_unlock(wvif->wdev);\n\t}\n\treturn ret;\n}\n\nstatic int wfx_tx_get_frame_format(struct ieee80211_tx_info *tx_info)\n{\n\tif (!(tx_info->driver_rates[0].flags & IEEE80211_TX_RC_MCS))\n\t\treturn HIF_FRAME_FORMAT_NON_HT;\n\telse if (!(tx_info->driver_rates[0].flags & IEEE80211_TX_RC_GREEN_FIELD))\n\t\treturn HIF_FRAME_FORMAT_MIXED_FORMAT_HT;\n\telse\n\t\treturn HIF_FRAME_FORMAT_GF_HT_11N;\n}\n\nstatic int wfx_tx_get_icv_len(struct ieee80211_key_conf *hw_key)\n{\n\tint mic_space;\n\n\tif (!hw_key)\n\t\treturn 0;\n\tif (hw_key->cipher == WLAN_CIPHER_SUITE_AES_CMAC)\n\t\treturn 0;\n\tmic_space = (hw_key->cipher == WLAN_CIPHER_SUITE_TKIP) ? 8 : 0;\n\treturn hw_key->icv_len + mic_space;\n}\n\nstatic int wfx_tx_inner(struct wfx_vif *wvif, struct ieee80211_sta *sta, struct sk_buff *skb)\n{\n\tstruct wfx_hif_msg *hif_msg;\n\tstruct wfx_hif_req_tx *req;\n\tstruct wfx_tx_priv *tx_priv;\n\tstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_key_conf *hw_key = tx_info->control.hw_key;\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tint queue_id = skb_get_queue_mapping(skb);\n\tsize_t offset = (size_t)skb->data & 3;\n\tint wmsg_len = sizeof(struct wfx_hif_msg) + sizeof(struct wfx_hif_req_tx) + offset;\n\n\tWARN(queue_id >= IEEE80211_NUM_ACS, \"unsupported queue_id\");\n\twfx_tx_fixup_rates(tx_info->driver_rates);\n\n\t \n\tmemset(tx_info->rate_driver_data, 0, sizeof(struct wfx_tx_priv));\n\t \n\ttx_priv = (struct wfx_tx_priv *)tx_info->rate_driver_data;\n\ttx_priv->icv_size = wfx_tx_get_icv_len(hw_key);\n\n\t \n\tWARN(skb_headroom(skb) < wmsg_len, \"not enough space in skb\");\n\tWARN(offset & 1, \"attempt to transmit an unaligned frame\");\n\tskb_put(skb, tx_priv->icv_size);\n\tskb_push(skb, wmsg_len);\n\tmemset(skb->data, 0, wmsg_len);\n\thif_msg = (struct wfx_hif_msg *)skb->data;\n\thif_msg->len = cpu_to_le16(skb->len);\n\thif_msg->id = HIF_REQ_ID_TX;\n\thif_msg->interface = wvif->id;\n\tif (skb->len > le16_to_cpu(wvif->wdev->hw_caps.size_inp_ch_buf)) {\n\t\tdev_warn(wvif->wdev->dev,\n\t\t\t \"requested frame size (%d) is larger than maximum supported (%d)\\n\",\n\t\t\t skb->len, le16_to_cpu(wvif->wdev->hw_caps.size_inp_ch_buf));\n\t\tskb_pull(skb, wmsg_len);\n\t\treturn -EIO;\n\t}\n\n\t \n\treq = (struct wfx_hif_req_tx *)hif_msg->body;\n\t \n\treq->packet_id = atomic_add_return(1, &wvif->wdev->packet_id) & 0xFFFF;\n\treq->packet_id |= IEEE80211_SEQ_TO_SN(le16_to_cpu(hdr->seq_ctrl)) << 16;\n\treq->packet_id |= queue_id << 28;\n\n\treq->fc_offset = offset;\n\t \n\treq->queue_id = 3 - queue_id;\n\treq->peer_sta_id = wfx_tx_get_link_id(wvif, sta, hdr);\n\treq->retry_policy_index = wfx_tx_get_retry_policy_id(wvif, tx_info);\n\treq->frame_format = wfx_tx_get_frame_format(tx_info);\n\tif (tx_info->driver_rates[0].flags & IEEE80211_TX_RC_SHORT_GI)\n\t\treq->short_gi = 1;\n\tif (tx_info->flags & IEEE80211_TX_CTL_SEND_AFTER_DTIM)\n\t\treq->after_dtim = 1;\n\n\t \n\twfx_tx_queues_put(wvif, skb);\n\tif (tx_info->flags & IEEE80211_TX_CTL_SEND_AFTER_DTIM)\n\t\tschedule_work(&wvif->update_tim_work);\n\twfx_bh_request_tx(wvif->wdev);\n\treturn 0;\n}\n\nvoid wfx_tx(struct ieee80211_hw *hw, struct ieee80211_tx_control *control, struct sk_buff *skb)\n{\n\tstruct wfx_dev *wdev = hw->priv;\n\tstruct wfx_vif *wvif;\n\tstruct ieee80211_sta *sta = control ? control->sta : NULL;\n\tstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);\n\tstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\n\tsize_t driver_data_room = sizeof_field(struct ieee80211_tx_info, rate_driver_data);\n\n\tBUILD_BUG_ON_MSG(sizeof(struct wfx_tx_priv) > driver_data_room,\n\t\t\t \"struct tx_priv is too large\");\n\tWARN(skb->next || skb->prev, \"skb is already member of a list\");\n\t \n\tif (tx_info->control.vif)\n\t\twvif = (struct wfx_vif *)tx_info->control.vif->drv_priv;\n\telse\n\t\twvif = wvif_iterate(wdev, NULL);\n\tif (WARN_ON(!wvif))\n\t\tgoto drop;\n\t \n\tif (wfx_is_action_back(hdr)) {\n\t\tdev_info(wdev->dev, \"drop BA action\\n\");\n\t\tgoto drop;\n\t}\n\tif (wfx_tx_inner(wvif, sta, skb))\n\t\tgoto drop;\n\n\treturn;\n\ndrop:\n\tieee80211_tx_status_irqsafe(wdev->hw, skb);\n}\n\nstatic void wfx_skb_dtor(struct wfx_vif *wvif, struct sk_buff *skb)\n{\n\tstruct wfx_hif_msg *hif = (struct wfx_hif_msg *)skb->data;\n\tstruct wfx_hif_req_tx *req = (struct wfx_hif_req_tx *)hif->body;\n\tunsigned int offset = sizeof(struct wfx_hif_msg) + sizeof(struct wfx_hif_req_tx) +\n\t\t\t      req->fc_offset;\n\n\tif (!wvif) {\n\t\tpr_warn(\"vif associated with the skb does not exist anymore\\n\");\n\t\treturn;\n\t}\n\twfx_tx_policy_put(wvif, req->retry_policy_index);\n\tskb_pull(skb, offset);\n\tieee80211_tx_status_irqsafe(wvif->wdev->hw, skb);\n}\n\nstatic void wfx_tx_fill_rates(struct wfx_dev *wdev, struct ieee80211_tx_info *tx_info,\n\t\t\t      const struct wfx_hif_cnf_tx *arg)\n{\n\tstruct ieee80211_tx_rate *rate;\n\tint tx_count;\n\tint i;\n\n\ttx_count = arg->ack_failures;\n\tif (!arg->status || arg->ack_failures)\n\t\ttx_count += 1;  \n\tfor (i = 0; i < IEEE80211_TX_MAX_RATES; i++) {\n\t\trate = &tx_info->status.rates[i];\n\t\tif (rate->idx < 0)\n\t\t\tbreak;\n\t\tif (tx_count < rate->count && arg->status == HIF_STATUS_TX_FAIL_RETRIES &&\n\t\t    arg->ack_failures)\n\t\t\tdev_dbg(wdev->dev, \"all retries were not consumed: %d != %d\\n\",\n\t\t\t\trate->count, tx_count);\n\t\tif (tx_count <= rate->count && tx_count &&\n\t\t    arg->txed_rate != wfx_get_hw_rate(wdev, rate))\n\t\t\tdev_dbg(wdev->dev, \"inconsistent tx_info rates: %d != %d\\n\",\n\t\t\t\targ->txed_rate, wfx_get_hw_rate(wdev, rate));\n\t\tif (tx_count > rate->count) {\n\t\t\ttx_count -= rate->count;\n\t\t} else if (!tx_count) {\n\t\t\trate->count = 0;\n\t\t\trate->idx = -1;\n\t\t} else {\n\t\t\trate->count = tx_count;\n\t\t\ttx_count = 0;\n\t\t}\n\t}\n\tif (tx_count)\n\t\tdev_dbg(wdev->dev, \"%d more retries than expected\\n\", tx_count);\n}\n\nvoid wfx_tx_confirm_cb(struct wfx_dev *wdev, const struct wfx_hif_cnf_tx *arg)\n{\n\tconst struct wfx_tx_priv *tx_priv;\n\tstruct ieee80211_tx_info *tx_info;\n\tstruct wfx_vif *wvif;\n\tstruct sk_buff *skb;\n\n\tskb = wfx_pending_get(wdev, arg->packet_id);\n\tif (!skb) {\n\t\tdev_warn(wdev->dev, \"received unknown packet_id (%#.8x) from chip\\n\",\n\t\t\t arg->packet_id);\n\t\treturn;\n\t}\n\ttx_info = IEEE80211_SKB_CB(skb);\n\ttx_priv = wfx_skb_tx_priv(skb);\n\twvif = wdev_to_wvif(wdev, ((struct wfx_hif_msg *)skb->data)->interface);\n\tWARN_ON(!wvif);\n\tif (!wvif)\n\t\treturn;\n\n\t \n\t_trace_tx_stats(arg, skb, wfx_pending_get_pkt_us_delay(wdev, skb));\n\twfx_tx_fill_rates(wdev, tx_info, arg);\n\tskb_trim(skb, skb->len - tx_priv->icv_size);\n\n\t \n\t \n\tmemset(tx_info->rate_driver_data, 0, sizeof(tx_info->rate_driver_data));\n\tmemset(tx_info->pad, 0, sizeof(tx_info->pad));\n\n\tif (!arg->status) {\n\t\ttx_info->status.tx_time = le32_to_cpu(arg->media_delay) -\n\t\t\t\t\t  le32_to_cpu(arg->tx_queue_delay);\n\t\tif (tx_info->flags & IEEE80211_TX_CTL_NO_ACK)\n\t\t\ttx_info->flags |= IEEE80211_TX_STAT_NOACK_TRANSMITTED;\n\t\telse\n\t\t\ttx_info->flags |= IEEE80211_TX_STAT_ACK;\n\t} else if (arg->status == HIF_STATUS_TX_FAIL_REQUEUE) {\n\t\tWARN(!arg->requeue, \"incoherent status and result_flags\");\n\t\tif (tx_info->flags & IEEE80211_TX_CTL_SEND_AFTER_DTIM) {\n\t\t\twvif->after_dtim_tx_allowed = false;  \n\t\t\tschedule_work(&wvif->update_tim_work);\n\t\t}\n\t\ttx_info->flags |= IEEE80211_TX_STAT_TX_FILTERED;\n\t}\n\twfx_skb_dtor(wvif, skb);\n}\n\nstatic void wfx_flush_vif(struct wfx_vif *wvif, u32 queues, struct sk_buff_head *dropped)\n{\n\tstruct wfx_queue *queue;\n\tint i;\n\n\tfor (i = 0; i < IEEE80211_NUM_ACS; i++) {\n\t\tif (!(BIT(i) & queues))\n\t\t\tcontinue;\n\t\tqueue = &wvif->tx_queue[i];\n\t\tif (dropped)\n\t\t\twfx_tx_queue_drop(wvif, queue, dropped);\n\t}\n\tif (wvif->wdev->chip_frozen)\n\t\treturn;\n\tfor (i = 0; i < IEEE80211_NUM_ACS; i++) {\n\t\tif (!(BIT(i) & queues))\n\t\t\tcontinue;\n\t\tqueue = &wvif->tx_queue[i];\n\t\tif (wait_event_timeout(wvif->wdev->tx_dequeue, wfx_tx_queue_empty(wvif, queue),\n\t\t\t\t       msecs_to_jiffies(1000)) <= 0)\n\t\t\tdev_warn(wvif->wdev->dev, \"frames queued while flushing tx queues?\");\n\t}\n}\n\nvoid wfx_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif, u32 queues, bool drop)\n{\n\tstruct wfx_dev *wdev = hw->priv;\n\tstruct sk_buff_head dropped;\n\tstruct wfx_vif *wvif;\n\tstruct wfx_hif_msg *hif;\n\tstruct sk_buff *skb;\n\n\tskb_queue_head_init(&dropped);\n\tif (vif) {\n\t\twvif = (struct wfx_vif *)vif->drv_priv;\n\t\twfx_flush_vif(wvif, queues, drop ? &dropped : NULL);\n\t} else {\n\t\twvif = NULL;\n\t\twhile ((wvif = wvif_iterate(wdev, wvif)) != NULL)\n\t\t\twfx_flush_vif(wvif, queues, drop ? &dropped : NULL);\n\t}\n\twfx_tx_flush(wdev);\n\tif (wdev->chip_frozen)\n\t\twfx_pending_drop(wdev, &dropped);\n\twhile ((skb = skb_dequeue(&dropped)) != NULL) {\n\t\thif = (struct wfx_hif_msg *)skb->data;\n\t\twvif = wdev_to_wvif(wdev, hif->interface);\n\t\tieee80211_tx_info_clear_status(IEEE80211_SKB_CB(skb));\n\t\twfx_skb_dtor(wvif, skb);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}