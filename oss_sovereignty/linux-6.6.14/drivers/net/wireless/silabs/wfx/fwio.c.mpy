{
  "module_name": "fwio.c",
  "hash_id": "b5bf890cb36e719ddc7db89a4aefe7a1821b562b7568a581aaabf3e59af166fc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/silabs/wfx/fwio.c",
  "human_readable_source": "\n \n#include <linux/firmware.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/bitfield.h>\n\n#include \"fwio.h\"\n#include \"wfx.h\"\n#include \"hwio.h\"\n\n \n#define WFX_DNLD_FIFO             0x09004000\n#define     DNLD_BLOCK_SIZE           0x0400\n#define     DNLD_FIFO_SIZE            0x8000  \n \n#define WFX_DCA_IMAGE_SIZE        0x0900C000\n#define WFX_DCA_PUT               0x0900C004\n#define WFX_DCA_GET               0x0900C008\n#define WFX_DCA_HOST_STATUS       0x0900C00C\n#define     HOST_READY                0x87654321\n#define     HOST_INFO_READ            0xA753BD99\n#define     HOST_UPLOAD_PENDING       0xABCDDCBA\n#define     HOST_UPLOAD_COMPLETE      0xD4C64A99\n#define     HOST_OK_TO_JUMP           0x174FC882\n#define WFX_DCA_NCP_STATUS        0x0900C010\n#define     NCP_NOT_READY             0x12345678\n#define     NCP_READY                 0x87654321\n#define     NCP_INFO_READY            0xBD53EF99\n#define     NCP_DOWNLOAD_PENDING      0xABCDDCBA\n#define     NCP_DOWNLOAD_COMPLETE     0xCAFEFECA\n#define     NCP_AUTH_OK               0xD4C64A99\n#define     NCP_AUTH_FAIL             0x174FC882\n#define     NCP_PUB_KEY_RDY           0x7AB41D19\n#define WFX_DCA_FW_SIGNATURE      0x0900C014\n#define     FW_SIGNATURE_SIZE         0x40\n#define WFX_DCA_FW_HASH           0x0900C054\n#define     FW_HASH_SIZE              0x08\n#define WFX_DCA_FW_VERSION        0x0900C05C\n#define     FW_VERSION_SIZE           0x04\n#define WFX_DCA_RESERVED          0x0900C060\n#define     DCA_RESERVED_SIZE         0x20\n#define WFX_STATUS_INFO           0x0900C080\n#define WFX_BOOTLOADER_LABEL      0x0900C084\n#define     BOOTLOADER_LABEL_SIZE     0x3C\n#define WFX_PTE_INFO              0x0900C0C0\n#define     PTE_INFO_KEYSET_IDX       0x0D\n#define     PTE_INFO_SIZE             0x10\n#define WFX_ERR_INFO              0x0900C0D0\n#define     ERR_INVALID_SEC_TYPE      0x05\n#define     ERR_SIG_VERIF_FAILED      0x0F\n#define     ERR_AES_CTRL_KEY          0x10\n#define     ERR_ECC_PUB_KEY           0x11\n#define     ERR_MAC_KEY               0x18\n\n#define DCA_TIMEOUT  50  \n#define WAKEUP_TIMEOUT 200  \n\nstatic const char * const fwio_errors[] = {\n\t[ERR_INVALID_SEC_TYPE] = \"Invalid section type or wrong encryption\",\n\t[ERR_SIG_VERIF_FAILED] = \"Signature verification failed\",\n\t[ERR_AES_CTRL_KEY]     = \"AES control key not initialized\",\n\t[ERR_ECC_PUB_KEY]      = \"ECC public key not initialized\",\n\t[ERR_MAC_KEY]          = \"MAC key not initialized\",\n};\n\n \nstatic int wfx_sram_write_dma_safe(struct wfx_dev *wdev, u32 addr, const u8 *buf, size_t len)\n{\n\tint ret;\n\tconst u8 *tmp;\n\n\tif (!virt_addr_valid(buf)) {\n\t\ttmp = kmemdup(buf, len, GFP_KERNEL);\n\t\tif (!tmp)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\ttmp = buf;\n\t}\n\tret = wfx_sram_buf_write(wdev, addr, tmp, len);\n\tif (tmp != buf)\n\t\tkfree(tmp);\n\treturn ret;\n}\n\nstatic int get_firmware(struct wfx_dev *wdev, u32 keyset_chip,\n\t\t\tconst struct firmware **fw, int *file_offset)\n{\n\tint keyset_file;\n\tchar filename[256];\n\tconst char *data;\n\tint ret;\n\n\tsnprintf(filename, sizeof(filename), \"%s_%02X.sec\",\n\t\t wdev->pdata.file_fw, keyset_chip);\n\tret = firmware_request_nowarn(fw, filename, wdev->dev);\n\tif (ret) {\n\t\tdev_info(wdev->dev, \"can't load %s, falling back to %s.sec\\n\",\n\t\t\t filename, wdev->pdata.file_fw);\n\t\tsnprintf(filename, sizeof(filename), \"%s.sec\", wdev->pdata.file_fw);\n\t\tret = request_firmware(fw, filename, wdev->dev);\n\t\tif (ret) {\n\t\t\tdev_err(wdev->dev, \"can't load %s\\n\", filename);\n\t\t\t*fw = NULL;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tdata = (*fw)->data;\n\tif (memcmp(data, \"KEYSET\", 6) != 0) {\n\t\t \n\t\t*file_offset = 0;\n\t\tkeyset_file = 0x90;\n\t} else {\n\t\t*file_offset = 8;\n\t\tkeyset_file = (hex_to_bin(data[6]) * 16) | hex_to_bin(data[7]);\n\t\tif (keyset_file < 0) {\n\t\t\tdev_err(wdev->dev, \"%s corrupted\\n\", filename);\n\t\t\trelease_firmware(*fw);\n\t\t\t*fw = NULL;\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (keyset_file != keyset_chip) {\n\t\tdev_err(wdev->dev, \"firmware keyset is incompatible with chip (file: 0x%02X, chip: 0x%02X)\\n\",\n\t\t\tkeyset_file, keyset_chip);\n\t\trelease_firmware(*fw);\n\t\t*fw = NULL;\n\t\treturn -ENODEV;\n\t}\n\twdev->keyset = keyset_file;\n\treturn 0;\n}\n\nstatic int wait_ncp_status(struct wfx_dev *wdev, u32 status)\n{\n\tktime_t now, start;\n\tu32 reg;\n\tint ret;\n\n\tstart = ktime_get();\n\tfor (;;) {\n\t\tret = wfx_sram_reg_read(wdev, WFX_DCA_NCP_STATUS, &reg);\n\t\tif (ret < 0)\n\t\t\treturn -EIO;\n\t\tnow = ktime_get();\n\t\tif (reg == status)\n\t\t\tbreak;\n\t\tif (ktime_after(now, ktime_add_ms(start, DCA_TIMEOUT)))\n\t\t\treturn -ETIMEDOUT;\n\t}\n\tif (ktime_compare(now, start))\n\t\tdev_dbg(wdev->dev, \"chip answer after %lldus\\n\", ktime_us_delta(now, start));\n\telse\n\t\tdev_dbg(wdev->dev, \"chip answer immediately\\n\");\n\treturn 0;\n}\n\nstatic int upload_firmware(struct wfx_dev *wdev, const u8 *data, size_t len)\n{\n\tint ret;\n\tu32 offs, bytes_done = 0;\n\tktime_t now, start;\n\n\tif (len % DNLD_BLOCK_SIZE) {\n\t\tdev_err(wdev->dev, \"firmware size is not aligned. Buffer overrun will occur\\n\");\n\t\treturn -EIO;\n\t}\n\toffs = 0;\n\twhile (offs < len) {\n\t\tstart = ktime_get();\n\t\tfor (;;) {\n\t\t\tnow = ktime_get();\n\t\t\tif (offs + DNLD_BLOCK_SIZE - bytes_done < DNLD_FIFO_SIZE)\n\t\t\t\tbreak;\n\t\t\tif (ktime_after(now, ktime_add_ms(start, DCA_TIMEOUT)))\n\t\t\t\treturn -ETIMEDOUT;\n\t\t\tret = wfx_sram_reg_read(wdev, WFX_DCA_GET, &bytes_done);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t\tif (ktime_compare(now, start))\n\t\t\tdev_dbg(wdev->dev, \"answer after %lldus\\n\", ktime_us_delta(now, start));\n\n\t\tret = wfx_sram_write_dma_safe(wdev, WFX_DNLD_FIFO + (offs % DNLD_FIFO_SIZE),\n\t\t\t\t\t      data + offs, DNLD_BLOCK_SIZE);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\toffs += DNLD_BLOCK_SIZE;\n\t\tret = wfx_sram_reg_write(wdev, WFX_DCA_PUT, offs);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic void print_boot_status(struct wfx_dev *wdev)\n{\n\tu32 reg;\n\n\twfx_sram_reg_read(wdev, WFX_STATUS_INFO, &reg);\n\tif (reg == 0x12345678)\n\t\treturn;\n\twfx_sram_reg_read(wdev, WFX_ERR_INFO, &reg);\n\tif (reg < ARRAY_SIZE(fwio_errors) && fwio_errors[reg])\n\t\tdev_info(wdev->dev, \"secure boot: %s\\n\", fwio_errors[reg]);\n\telse\n\t\tdev_info(wdev->dev, \"secure boot: Error %#02x\\n\", reg);\n}\n\nstatic int load_firmware_secure(struct wfx_dev *wdev)\n{\n\tconst struct firmware *fw = NULL;\n\tint header_size;\n\tint fw_offset;\n\tktime_t start;\n\tu8 *buf;\n\tint ret;\n\n\tBUILD_BUG_ON(PTE_INFO_SIZE > BOOTLOADER_LABEL_SIZE);\n\tbuf = kmalloc(BOOTLOADER_LABEL_SIZE + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\twfx_sram_reg_write(wdev, WFX_DCA_HOST_STATUS, HOST_READY);\n\tret = wait_ncp_status(wdev, NCP_INFO_READY);\n\tif (ret)\n\t\tgoto error;\n\n\twfx_sram_buf_read(wdev, WFX_BOOTLOADER_LABEL, buf, BOOTLOADER_LABEL_SIZE);\n\tbuf[BOOTLOADER_LABEL_SIZE] = 0;\n\tdev_dbg(wdev->dev, \"bootloader: \\\"%s\\\"\\n\", buf);\n\n\twfx_sram_buf_read(wdev, WFX_PTE_INFO, buf, PTE_INFO_SIZE);\n\tret = get_firmware(wdev, buf[PTE_INFO_KEYSET_IDX], &fw, &fw_offset);\n\tif (ret)\n\t\tgoto error;\n\theader_size = fw_offset + FW_SIGNATURE_SIZE + FW_HASH_SIZE;\n\n\twfx_sram_reg_write(wdev, WFX_DCA_HOST_STATUS, HOST_INFO_READ);\n\tret = wait_ncp_status(wdev, NCP_READY);\n\tif (ret)\n\t\tgoto error;\n\n\twfx_sram_reg_write(wdev, WFX_DNLD_FIFO, 0xFFFFFFFF);  \n\twfx_sram_write_dma_safe(wdev, WFX_DCA_FW_VERSION, \"\\x01\\x00\\x00\\x00\", FW_VERSION_SIZE);\n\twfx_sram_write_dma_safe(wdev, WFX_DCA_FW_SIGNATURE, fw->data + fw_offset,\n\t\t\t\tFW_SIGNATURE_SIZE);\n\twfx_sram_write_dma_safe(wdev, WFX_DCA_FW_HASH, fw->data + fw_offset + FW_SIGNATURE_SIZE,\n\t\t\t\tFW_HASH_SIZE);\n\twfx_sram_reg_write(wdev, WFX_DCA_IMAGE_SIZE, fw->size - header_size);\n\twfx_sram_reg_write(wdev, WFX_DCA_HOST_STATUS, HOST_UPLOAD_PENDING);\n\tret = wait_ncp_status(wdev, NCP_DOWNLOAD_PENDING);\n\tif (ret)\n\t\tgoto error;\n\n\tstart = ktime_get();\n\tret = upload_firmware(wdev, fw->data + header_size, fw->size - header_size);\n\tif (ret)\n\t\tgoto error;\n\tdev_dbg(wdev->dev, \"firmware load after %lldus\\n\",\n\t\tktime_us_delta(ktime_get(), start));\n\n\twfx_sram_reg_write(wdev, WFX_DCA_HOST_STATUS, HOST_UPLOAD_COMPLETE);\n\tret = wait_ncp_status(wdev, NCP_AUTH_OK);\n\t \n\tif (ret < 0)\n\t\tret = wait_ncp_status(wdev, NCP_PUB_KEY_RDY);\n\tif (ret < 0)\n\t\tgoto error;\n\twfx_sram_reg_write(wdev, WFX_DCA_HOST_STATUS, HOST_OK_TO_JUMP);\n\nerror:\n\tkfree(buf);\n\trelease_firmware(fw);\n\tif (ret)\n\t\tprint_boot_status(wdev);\n\treturn ret;\n}\n\nstatic int init_gpr(struct wfx_dev *wdev)\n{\n\tint ret, i;\n\tstatic const struct {\n\t\tint index;\n\t\tu32 value;\n\t} gpr_init[] = {\n\t\t{ 0x07, 0x208775 },\n\t\t{ 0x08, 0x2EC020 },\n\t\t{ 0x09, 0x3C3C3C },\n\t\t{ 0x0B, 0x322C44 },\n\t\t{ 0x0C, 0xA06497 },\n\t};\n\n\tfor (i = 0; i < ARRAY_SIZE(gpr_init); i++) {\n\t\tret = wfx_igpr_reg_write(wdev, gpr_init[i].index, gpr_init[i].value);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tdev_dbg(wdev->dev, \"  index %02x: %08x\\n\", gpr_init[i].index, gpr_init[i].value);\n\t}\n\treturn 0;\n}\n\nint wfx_init_device(struct wfx_dev *wdev)\n{\n\tint ret;\n\tint hw_revision, hw_type;\n\tint wakeup_timeout = 50;  \n\tktime_t now, start;\n\tu32 reg;\n\n\treg = CFG_DIRECT_ACCESS_MODE | CFG_CPU_RESET | CFG_BYTE_ORDER_ABCD;\n\tif (wdev->pdata.use_rising_clk)\n\t\treg |= CFG_CLK_RISE_EDGE;\n\tret = wfx_config_reg_write(wdev, reg);\n\tif (ret < 0) {\n\t\tdev_err(wdev->dev, \"bus returned an error during first write access. Host configuration error?\\n\");\n\t\treturn -EIO;\n\t}\n\n\tret = wfx_config_reg_read(wdev, &reg);\n\tif (ret < 0) {\n\t\tdev_err(wdev->dev, \"bus returned an error during first read access. Bus configuration error?\\n\");\n\t\treturn -EIO;\n\t}\n\tif (reg == 0 || reg == ~0) {\n\t\tdev_err(wdev->dev, \"chip mute. Bus configuration error or chip wasn't reset?\\n\");\n\t\treturn -EIO;\n\t}\n\tdev_dbg(wdev->dev, \"initial config register value: %08x\\n\", reg);\n\n\thw_revision = FIELD_GET(CFG_DEVICE_ID_MAJOR, reg);\n\tif (hw_revision == 0) {\n\t\tdev_err(wdev->dev, \"bad hardware revision number: %d\\n\", hw_revision);\n\t\treturn -ENODEV;\n\t}\n\thw_type = FIELD_GET(CFG_DEVICE_ID_TYPE, reg);\n\tif (hw_type == 1) {\n\t\tdev_notice(wdev->dev, \"development hardware detected\\n\");\n\t\twakeup_timeout = 2000;\n\t}\n\n\tret = init_gpr(wdev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = wfx_control_reg_write(wdev, CTRL_WLAN_WAKEUP);\n\tif (ret < 0)\n\t\treturn -EIO;\n\tstart = ktime_get();\n\tfor (;;) {\n\t\tret = wfx_control_reg_read(wdev, &reg);\n\t\tnow = ktime_get();\n\t\tif (reg & CTRL_WLAN_READY)\n\t\t\tbreak;\n\t\tif (ktime_after(now, ktime_add_ms(start, wakeup_timeout))) {\n\t\t\tdev_err(wdev->dev, \"chip didn't wake up. Chip wasn't reset?\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t}\n\tdev_dbg(wdev->dev, \"chip wake up after %lldus\\n\", ktime_us_delta(now, start));\n\n\tret = wfx_config_reg_write_bits(wdev, CFG_CPU_RESET, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = load_firmware_secure(wdev);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn wfx_config_reg_write_bits(wdev,\n\t\t\t\t\t CFG_DIRECT_ACCESS_MODE |\n\t\t\t\t\t CFG_IRQ_ENABLE_DATA |\n\t\t\t\t\t CFG_IRQ_ENABLE_WRDY,\n\t\t\t\t\t CFG_IRQ_ENABLE_DATA);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}