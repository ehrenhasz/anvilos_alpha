{
  "module_name": "main.c",
  "hash_id": "9536c9a5036ac2de65a83bead7f9fe374bb0e64ac57bf574d77ec2c8dfc2c4c3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/silabs/wfx/main.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_net.h>\n#include <linux/gpio/consumer.h>\n#include <linux/mmc/sdio_func.h>\n#include <linux/spi/spi.h>\n#include <linux/etherdevice.h>\n#include <linux/firmware.h>\n\n#include \"main.h\"\n#include \"wfx.h\"\n#include \"fwio.h\"\n#include \"hwio.h\"\n#include \"bus.h\"\n#include \"bh.h\"\n#include \"sta.h\"\n#include \"key.h\"\n#include \"scan.h\"\n#include \"debug.h\"\n#include \"data_tx.h\"\n#include \"hif_tx_mib.h\"\n#include \"hif_api_cmd.h\"\n\n#define WFX_PDS_TLV_TYPE 0x4450 \n#define WFX_PDS_MAX_CHUNK_SIZE 1500\n\nMODULE_DESCRIPTION(\"Silicon Labs 802.11 Wireless LAN driver for WF200\");\nMODULE_AUTHOR(\"J\u00e9r\u00f4me Pouiller <jerome.pouiller@silabs.com>\");\nMODULE_LICENSE(\"GPL\");\n\n#define RATETAB_ENT(_rate, _rateid, _flags) { \\\n\t.bitrate  = (_rate),   \\\n\t.hw_value = (_rateid), \\\n\t.flags    = (_flags),  \\\n}\n\nstatic struct ieee80211_rate wfx_rates[] = {\n\tRATETAB_ENT(10,  0,  0),\n\tRATETAB_ENT(20,  1,  IEEE80211_RATE_SHORT_PREAMBLE),\n\tRATETAB_ENT(55,  2,  IEEE80211_RATE_SHORT_PREAMBLE),\n\tRATETAB_ENT(110, 3,  IEEE80211_RATE_SHORT_PREAMBLE),\n\tRATETAB_ENT(60,  6,  0),\n\tRATETAB_ENT(90,  7,  0),\n\tRATETAB_ENT(120, 8,  0),\n\tRATETAB_ENT(180, 9,  0),\n\tRATETAB_ENT(240, 10, 0),\n\tRATETAB_ENT(360, 11, 0),\n\tRATETAB_ENT(480, 12, 0),\n\tRATETAB_ENT(540, 13, 0),\n};\n\n#define CHAN2G(_channel, _freq, _flags) { \\\n\t.band = NL80211_BAND_2GHZ, \\\n\t.center_freq = (_freq),    \\\n\t.hw_value = (_channel),    \\\n\t.flags = (_flags),         \\\n\t.max_antenna_gain = 0,     \\\n\t.max_power = 30,           \\\n}\n\nstatic struct ieee80211_channel wfx_2ghz_chantable[] = {\n\tCHAN2G(1,  2412, 0),\n\tCHAN2G(2,  2417, 0),\n\tCHAN2G(3,  2422, 0),\n\tCHAN2G(4,  2427, 0),\n\tCHAN2G(5,  2432, 0),\n\tCHAN2G(6,  2437, 0),\n\tCHAN2G(7,  2442, 0),\n\tCHAN2G(8,  2447, 0),\n\tCHAN2G(9,  2452, 0),\n\tCHAN2G(10, 2457, 0),\n\tCHAN2G(11, 2462, 0),\n\tCHAN2G(12, 2467, 0),\n\tCHAN2G(13, 2472, 0),\n\tCHAN2G(14, 2484, 0),\n};\n\nstatic const struct ieee80211_supported_band wfx_band_2ghz = {\n\t.channels = wfx_2ghz_chantable,\n\t.n_channels = ARRAY_SIZE(wfx_2ghz_chantable),\n\t.bitrates = wfx_rates,\n\t.n_bitrates = ARRAY_SIZE(wfx_rates),\n\t.ht_cap = {\n\t\t \n\t\t.cap = IEEE80211_HT_CAP_GRN_FLD | IEEE80211_HT_CAP_SGI_20 |\n\t\t       IEEE80211_HT_CAP_MAX_AMSDU | (1 << IEEE80211_HT_CAP_RX_STBC_SHIFT),\n\t\t.ht_supported = 1,\n\t\t.ampdu_factor = IEEE80211_HT_MAX_AMPDU_16K,\n\t\t.ampdu_density = IEEE80211_HT_MPDU_DENSITY_NONE,\n\t\t.mcs = {\n\t\t\t.rx_mask = { 0xFF },  \n\t\t\t.rx_highest = cpu_to_le16(72),\n\t\t\t.tx_params = IEEE80211_HT_MCS_TX_DEFINED,\n\t\t},\n\t},\n};\n\nstatic const struct ieee80211_iface_limit wdev_iface_limits[] = {\n\t{ .max = 1, .types = BIT(NL80211_IFTYPE_STATION) },\n\t{ .max = 1, .types = BIT(NL80211_IFTYPE_AP) },\n};\n\nstatic const struct ieee80211_iface_combination wfx_iface_combinations[] = {\n\t{\n\t\t.num_different_channels = 2,\n\t\t.max_interfaces = 2,\n\t\t.limits = wdev_iface_limits,\n\t\t.n_limits = ARRAY_SIZE(wdev_iface_limits),\n\t}\n};\n\nstatic const struct ieee80211_ops wfx_ops = {\n\t.start                   = wfx_start,\n\t.stop                    = wfx_stop,\n\t.add_interface           = wfx_add_interface,\n\t.remove_interface        = wfx_remove_interface,\n\t.config                  = wfx_config,\n\t.tx                      = wfx_tx,\n\t.wake_tx_queue           = ieee80211_handle_wake_tx_queue,\n\t.join_ibss               = wfx_join_ibss,\n\t.leave_ibss              = wfx_leave_ibss,\n\t.conf_tx                 = wfx_conf_tx,\n\t.hw_scan                 = wfx_hw_scan,\n\t.cancel_hw_scan          = wfx_cancel_hw_scan,\n\t.start_ap                = wfx_start_ap,\n\t.stop_ap                 = wfx_stop_ap,\n\t.sta_add                 = wfx_sta_add,\n\t.sta_remove              = wfx_sta_remove,\n\t.set_tim                 = wfx_set_tim,\n\t.set_key                 = wfx_set_key,\n\t.set_rts_threshold       = wfx_set_rts_threshold,\n\t.set_default_unicast_key = wfx_set_default_unicast_key,\n\t.bss_info_changed        = wfx_bss_info_changed,\n\t.configure_filter        = wfx_configure_filter,\n\t.ampdu_action            = wfx_ampdu_action,\n\t.flush                   = wfx_flush,\n\t.add_chanctx             = wfx_add_chanctx,\n\t.remove_chanctx          = wfx_remove_chanctx,\n\t.change_chanctx          = wfx_change_chanctx,\n\t.assign_vif_chanctx      = wfx_assign_vif_chanctx,\n\t.unassign_vif_chanctx    = wfx_unassign_vif_chanctx,\n};\n\nbool wfx_api_older_than(struct wfx_dev *wdev, int major, int minor)\n{\n\tif (wdev->hw_caps.api_version_major < major)\n\t\treturn true;\n\tif (wdev->hw_caps.api_version_major > major)\n\t\treturn false;\n\tif (wdev->hw_caps.api_version_minor < minor)\n\t\treturn true;\n\treturn false;\n}\n\n \nint wfx_send_pds(struct wfx_dev *wdev, u8 *buf, size_t len)\n{\n\tint ret, chunk_type, chunk_len, chunk_num = 0;\n\n\tif (*buf == '{') {\n\t\tdev_err(wdev->dev, \"PDS: malformed file (legacy format?)\\n\");\n\t\treturn -EINVAL;\n\t}\n\twhile (len > 0) {\n\t\tchunk_type = get_unaligned_le16(buf + 0);\n\t\tchunk_len = get_unaligned_le16(buf + 2);\n\t\tif (chunk_len < 4 || chunk_len > len) {\n\t\t\tdev_err(wdev->dev, \"PDS:%d: corrupted file\\n\", chunk_num);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (chunk_type != WFX_PDS_TLV_TYPE) {\n\t\t\tdev_info(wdev->dev, \"PDS:%d: skip unknown data\\n\", chunk_num);\n\t\t\tgoto next;\n\t\t}\n\t\tif (chunk_len > WFX_PDS_MAX_CHUNK_SIZE)\n\t\t\tdev_warn(wdev->dev, \"PDS:%d: unexpectedly large chunk\\n\", chunk_num);\n\t\tif (buf[4] != '{' || buf[chunk_len - 1] != '}')\n\t\t\tdev_warn(wdev->dev, \"PDS:%d: unexpected content\\n\", chunk_num);\n\n\t\tret = wfx_hif_configuration(wdev, buf + 4, chunk_len - 4);\n\t\tif (ret > 0) {\n\t\t\tdev_err(wdev->dev, \"PDS:%d: invalid data (unsupported options?)\\n\", chunk_num);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (ret == -ETIMEDOUT) {\n\t\t\tdev_err(wdev->dev, \"PDS:%d: chip didn't reply (corrupted file?)\\n\", chunk_num);\n\t\t\treturn ret;\n\t\t}\n\t\tif (ret) {\n\t\t\tdev_err(wdev->dev, \"PDS:%d: chip returned an unknown error\\n\", chunk_num);\n\t\t\treturn -EIO;\n\t\t}\nnext:\n\t\tchunk_num++;\n\t\tlen -= chunk_len;\n\t\tbuf += chunk_len;\n\t}\n\treturn 0;\n}\n\nstatic int wfx_send_pdata_pds(struct wfx_dev *wdev)\n{\n\tint ret = 0;\n\tconst struct firmware *pds;\n\tu8 *tmp_buf;\n\n\tret = request_firmware(&pds, wdev->pdata.file_pds, wdev->dev);\n\tif (ret) {\n\t\tdev_err(wdev->dev, \"can't load antenna parameters (PDS file %s). The device may be unstable.\\n\",\n\t\t\twdev->pdata.file_pds);\n\t\treturn ret;\n\t}\n\ttmp_buf = kmemdup(pds->data, pds->size, GFP_KERNEL);\n\tif (!tmp_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto release_fw;\n\t}\n\tret = wfx_send_pds(wdev, tmp_buf, pds->size);\n\tkfree(tmp_buf);\nrelease_fw:\n\trelease_firmware(pds);\n\treturn ret;\n}\n\nstatic void wfx_free_common(void *data)\n{\n\tstruct wfx_dev *wdev = data;\n\n\tmutex_destroy(&wdev->tx_power_loop_info_lock);\n\tmutex_destroy(&wdev->rx_stats_lock);\n\tmutex_destroy(&wdev->conf_mutex);\n\tieee80211_free_hw(wdev->hw);\n}\n\nstruct wfx_dev *wfx_init_common(struct device *dev, const struct wfx_platform_data *pdata,\n\t\t\t\tconst struct wfx_hwbus_ops *hwbus_ops, void *hwbus_priv)\n{\n\tstruct ieee80211_hw *hw;\n\tstruct wfx_dev *wdev;\n\n\thw = ieee80211_alloc_hw(sizeof(struct wfx_dev), &wfx_ops);\n\tif (!hw)\n\t\treturn NULL;\n\n\tSET_IEEE80211_DEV(hw, dev);\n\n\tieee80211_hw_set(hw, TX_AMPDU_SETUP_IN_HW);\n\tieee80211_hw_set(hw, AMPDU_AGGREGATION);\n\tieee80211_hw_set(hw, CONNECTION_MONITOR);\n\tieee80211_hw_set(hw, REPORTS_TX_ACK_STATUS);\n\tieee80211_hw_set(hw, SUPPORTS_DYNAMIC_PS);\n\tieee80211_hw_set(hw, SIGNAL_DBM);\n\tieee80211_hw_set(hw, SUPPORTS_PS);\n\tieee80211_hw_set(hw, MFP_CAPABLE);\n\n\thw->vif_data_size = sizeof(struct wfx_vif);\n\thw->sta_data_size = sizeof(struct wfx_sta_priv);\n\thw->queues = 4;\n\thw->max_rates = 8;\n\thw->max_rate_tries = 8;\n\thw->extra_tx_headroom = sizeof(struct wfx_hif_msg) + sizeof(struct wfx_hif_req_tx) +\n\t\t\t\t4   + 8  ;\n\thw->wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |\n\t\t\t\t     BIT(NL80211_IFTYPE_ADHOC) |\n\t\t\t\t     BIT(NL80211_IFTYPE_AP);\n\thw->wiphy->probe_resp_offload = NL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS |\n\t\t\t\t\tNL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS2 |\n\t\t\t\t\tNL80211_PROBE_RESP_OFFLOAD_SUPPORT_P2P |\n\t\t\t\t\tNL80211_PROBE_RESP_OFFLOAD_SUPPORT_80211U;\n\thw->wiphy->features |= NL80211_FEATURE_AP_SCAN;\n\thw->wiphy->flags |= WIPHY_FLAG_AP_PROBE_RESP_OFFLOAD;\n\thw->wiphy->flags |= WIPHY_FLAG_AP_UAPSD;\n\thw->wiphy->max_ap_assoc_sta = HIF_LINK_ID_MAX;\n\thw->wiphy->max_scan_ssids = 2;\n\thw->wiphy->max_scan_ie_len = IEEE80211_MAX_DATA_LEN;\n\thw->wiphy->n_iface_combinations = ARRAY_SIZE(wfx_iface_combinations);\n\thw->wiphy->iface_combinations = wfx_iface_combinations;\n\t \n\thw->wiphy->bands[NL80211_BAND_2GHZ] = devm_kmemdup(dev, &wfx_band_2ghz,\n\t\t\t\t\t\t\t   sizeof(wfx_band_2ghz), GFP_KERNEL);\n\tif (!hw->wiphy->bands[NL80211_BAND_2GHZ])\n\t\tgoto err;\n\n\twdev = hw->priv;\n\twdev->hw = hw;\n\twdev->dev = dev;\n\twdev->hwbus_ops = hwbus_ops;\n\twdev->hwbus_priv = hwbus_priv;\n\tmemcpy(&wdev->pdata, pdata, sizeof(*pdata));\n\tof_property_read_string(dev->of_node, \"silabs,antenna-config-file\", &wdev->pdata.file_pds);\n\twdev->pdata.gpio_wakeup = devm_gpiod_get_optional(dev, \"wakeup\", GPIOD_OUT_LOW);\n\tif (IS_ERR(wdev->pdata.gpio_wakeup))\n\t\tgoto err;\n\n\tif (wdev->pdata.gpio_wakeup)\n\t\tgpiod_set_consumer_name(wdev->pdata.gpio_wakeup, \"wfx wakeup\");\n\n\tmutex_init(&wdev->conf_mutex);\n\tmutex_init(&wdev->rx_stats_lock);\n\tmutex_init(&wdev->tx_power_loop_info_lock);\n\tinit_completion(&wdev->firmware_ready);\n\tINIT_DELAYED_WORK(&wdev->cooling_timeout_work, wfx_cooling_timeout_work);\n\tskb_queue_head_init(&wdev->tx_pending);\n\tinit_waitqueue_head(&wdev->tx_dequeue);\n\twfx_init_hif_cmd(&wdev->hif_cmd);\n\n\tif (devm_add_action_or_reset(dev, wfx_free_common, wdev))\n\t\treturn NULL;\n\n\treturn wdev;\n\nerr:\n\tieee80211_free_hw(hw);\n\treturn NULL;\n}\n\nint wfx_probe(struct wfx_dev *wdev)\n{\n\tint i;\n\tint err;\n\tstruct gpio_desc *gpio_saved;\n\n\t \n\tgpio_saved = wdev->pdata.gpio_wakeup;\n\twdev->pdata.gpio_wakeup = NULL;\n\twdev->poll_irq = true;\n\n\twdev->bh_wq = alloc_workqueue(\"wfx_bh_wq\", WQ_HIGHPRI, 0);\n\tif (!wdev->bh_wq)\n\t\treturn -ENOMEM;\n\n\twfx_bh_register(wdev);\n\n\terr = wfx_init_device(wdev);\n\tif (err)\n\t\tgoto bh_unregister;\n\n\twfx_bh_poll_irq(wdev);\n\terr = wait_for_completion_timeout(&wdev->firmware_ready, 1 * HZ);\n\tif (err == 0) {\n\t\tdev_err(wdev->dev, \"timeout while waiting for startup indication\\n\");\n\t\terr = -ETIMEDOUT;\n\t\tgoto bh_unregister;\n\t}\n\n\t \n\tdev_info(wdev->dev, \"started firmware %d.%d.%d \\\"%s\\\" (API: %d.%d, keyset: %02X, caps: 0x%.8X)\\n\",\n\t\t wdev->hw_caps.firmware_major, wdev->hw_caps.firmware_minor,\n\t\t wdev->hw_caps.firmware_build, wdev->hw_caps.firmware_label,\n\t\t wdev->hw_caps.api_version_major, wdev->hw_caps.api_version_minor,\n\t\t wdev->keyset, wdev->hw_caps.link_mode);\n\tsnprintf(wdev->hw->wiphy->fw_version,\n\t\t sizeof(wdev->hw->wiphy->fw_version),\n\t\t \"%d.%d.%d\",\n\t\t wdev->hw_caps.firmware_major,\n\t\t wdev->hw_caps.firmware_minor,\n\t\t wdev->hw_caps.firmware_build);\n\n\tif (wfx_api_older_than(wdev, 1, 0)) {\n\t\tdev_err(wdev->dev, \"unsupported firmware API version (expect 1 while firmware returns %d)\\n\",\n\t\t\twdev->hw_caps.api_version_major);\n\t\terr = -EOPNOTSUPP;\n\t\tgoto bh_unregister;\n\t}\n\n\tif (wdev->hw_caps.link_mode == SEC_LINK_ENFORCED) {\n\t\tdev_err(wdev->dev, \"chip require secure_link, but can't negotiate it\\n\");\n\t\tgoto bh_unregister;\n\t}\n\n\tif (wdev->hw_caps.region_sel_mode) {\n\t\twdev->hw->wiphy->regulatory_flags |= REGULATORY_DISABLE_BEACON_HINTS;\n\t\twdev->hw->wiphy->bands[NL80211_BAND_2GHZ]->channels[11].flags |=\n\t\t\tIEEE80211_CHAN_NO_IR;\n\t\twdev->hw->wiphy->bands[NL80211_BAND_2GHZ]->channels[12].flags |=\n\t\t\tIEEE80211_CHAN_NO_IR;\n\t\twdev->hw->wiphy->bands[NL80211_BAND_2GHZ]->channels[13].flags |=\n\t\t\tIEEE80211_CHAN_DISABLED;\n\t}\n\n\tdev_dbg(wdev->dev, \"sending configuration file %s\\n\", wdev->pdata.file_pds);\n\terr = wfx_send_pdata_pds(wdev);\n\tif (err < 0 && err != -ENOENT)\n\t\tgoto bh_unregister;\n\n\twdev->poll_irq = false;\n\terr = wdev->hwbus_ops->irq_subscribe(wdev->hwbus_priv);\n\tif (err)\n\t\tgoto bh_unregister;\n\n\terr = wfx_hif_use_multi_tx_conf(wdev, true);\n\tif (err)\n\t\tdev_err(wdev->dev, \"misconfigured IRQ?\\n\");\n\n\twdev->pdata.gpio_wakeup = gpio_saved;\n\tif (wdev->pdata.gpio_wakeup) {\n\t\tdev_dbg(wdev->dev, \"enable 'quiescent' power mode with wakeup GPIO and PDS file %s\\n\",\n\t\t\twdev->pdata.file_pds);\n\t\tgpiod_set_value_cansleep(wdev->pdata.gpio_wakeup, 1);\n\t\twfx_control_reg_write(wdev, 0);\n\t\twfx_hif_set_operational_mode(wdev, HIF_OP_POWER_MODE_QUIESCENT);\n\t} else {\n\t\twfx_hif_set_operational_mode(wdev, HIF_OP_POWER_MODE_DOZE);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(wdev->addresses); i++) {\n\t\teth_zero_addr(wdev->addresses[i].addr);\n\t\terr = of_get_mac_address(wdev->dev->of_node, wdev->addresses[i].addr);\n\t\tif (!err)\n\t\t\twdev->addresses[i].addr[ETH_ALEN - 1] += i;\n\t\telse\n\t\t\tether_addr_copy(wdev->addresses[i].addr, wdev->hw_caps.mac_addr[i]);\n\t\tif (!is_valid_ether_addr(wdev->addresses[i].addr)) {\n\t\t\tdev_warn(wdev->dev, \"using random MAC address\\n\");\n\t\t\teth_random_addr(wdev->addresses[i].addr);\n\t\t}\n\t\tdev_info(wdev->dev, \"MAC address %d: %pM\\n\", i, wdev->addresses[i].addr);\n\t}\n\twdev->hw->wiphy->n_addresses = ARRAY_SIZE(wdev->addresses);\n\twdev->hw->wiphy->addresses = wdev->addresses;\n\n\tif (!wfx_api_older_than(wdev, 3, 8))\n\t\twdev->hw->wiphy->flags |= WIPHY_FLAG_SUPPORTS_TDLS;\n\n\terr = ieee80211_register_hw(wdev->hw);\n\tif (err)\n\t\tgoto irq_unsubscribe;\n\n\terr = wfx_debug_init(wdev);\n\tif (err)\n\t\tgoto ieee80211_unregister;\n\n\treturn 0;\n\nieee80211_unregister:\n\tieee80211_unregister_hw(wdev->hw);\nirq_unsubscribe:\n\twdev->hwbus_ops->irq_unsubscribe(wdev->hwbus_priv);\nbh_unregister:\n\twfx_bh_unregister(wdev);\n\tdestroy_workqueue(wdev->bh_wq);\n\treturn err;\n}\n\nvoid wfx_release(struct wfx_dev *wdev)\n{\n\tieee80211_unregister_hw(wdev->hw);\n\twfx_hif_shutdown(wdev);\n\twdev->hwbus_ops->irq_unsubscribe(wdev->hwbus_priv);\n\twfx_bh_unregister(wdev);\n\tdestroy_workqueue(wdev->bh_wq);\n}\n\nstatic int __init wfx_core_init(void)\n{\n\tint ret = 0;\n\n\tif (IS_ENABLED(CONFIG_SPI))\n\t\tret = spi_register_driver(&wfx_spi_driver);\n\tif (IS_ENABLED(CONFIG_MMC) && !ret)\n\t\tret = sdio_register_driver(&wfx_sdio_driver);\n\treturn ret;\n}\nmodule_init(wfx_core_init);\n\nstatic void __exit wfx_core_exit(void)\n{\n\tif (IS_ENABLED(CONFIG_MMC))\n\t\tsdio_unregister_driver(&wfx_sdio_driver);\n\tif (IS_ENABLED(CONFIG_SPI))\n\t\tspi_unregister_driver(&wfx_spi_driver);\n}\nmodule_exit(wfx_core_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}