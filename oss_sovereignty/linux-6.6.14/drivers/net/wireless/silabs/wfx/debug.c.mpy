{
  "module_name": "debug.c",
  "hash_id": "fdffca18e78f2efc5b2f0f52a908bf1f89a999da74e5624ea7d8278ee6b15fe9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/silabs/wfx/debug.c",
  "human_readable_source": "\n \n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/crc32.h>\n\n#include \"debug.h\"\n#include \"wfx.h\"\n#include \"sta.h\"\n#include \"main.h\"\n#include \"hif_tx.h\"\n#include \"hif_tx_mib.h\"\n\n#define CREATE_TRACE_POINTS\n#include \"traces.h\"\n\nstatic const struct trace_print_flags hif_msg_print_map[] = {\n\thif_msg_list,\n};\n\nstatic const struct trace_print_flags hif_mib_print_map[] = {\n\thif_mib_list,\n};\n\nstatic const struct trace_print_flags wfx_reg_print_map[] = {\n\twfx_reg_list,\n};\n\nstatic const char *get_symbol(unsigned long val, const struct trace_print_flags *symbol_array)\n{\n\tint i;\n\n\tfor (i = 0; symbol_array[i].mask != -1; i++) {\n\t\tif (val == symbol_array[i].mask)\n\t\t\treturn symbol_array[i].name;\n\t}\n\n\treturn \"unknown\";\n}\n\nconst char *wfx_get_hif_name(unsigned long id)\n{\n\treturn get_symbol(id, hif_msg_print_map);\n}\n\nconst char *wfx_get_mib_name(unsigned long id)\n{\n\treturn get_symbol(id, hif_mib_print_map);\n}\n\nconst char *wfx_get_reg_name(unsigned long id)\n{\n\treturn get_symbol(id, wfx_reg_print_map);\n}\n\nstatic int wfx_counters_show(struct seq_file *seq, void *v)\n{\n\tint ret, i;\n\tstruct wfx_dev *wdev = seq->private;\n\tstruct wfx_hif_mib_extended_count_table counters[3];\n\n\tfor (i = 0; i < ARRAY_SIZE(counters); i++) {\n\t\tret = wfx_hif_get_counters_table(wdev, i, counters + i);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret > 0)\n\t\t\treturn -EIO;\n\t}\n\n\tseq_printf(seq, \"%-24s %12s %12s %12s\\n\", \"\", \"global\", \"iface 0\", \"iface 1\");\n\n#define PUT_COUNTER(name) \\\n\tseq_printf(seq, \"%-24s %12d %12d %12d\\n\", #name,  \\\n\t\t   le32_to_cpu(counters[2].count_##name), \\\n\t\t   le32_to_cpu(counters[0].count_##name), \\\n\t\t   le32_to_cpu(counters[1].count_##name))\n\n\tPUT_COUNTER(tx_frames);\n\tPUT_COUNTER(tx_frames_multicast);\n\tPUT_COUNTER(tx_frames_success);\n\tPUT_COUNTER(tx_frames_retried);\n\tPUT_COUNTER(tx_frames_multi_retried);\n\tPUT_COUNTER(tx_frames_failed);\n\n\tPUT_COUNTER(ack_failed);\n\tPUT_COUNTER(rts_success);\n\tPUT_COUNTER(rts_failed);\n\n\tPUT_COUNTER(rx_frames);\n\tPUT_COUNTER(rx_frames_multicast);\n\tPUT_COUNTER(rx_frames_success);\n\tPUT_COUNTER(rx_frames_failed);\n\tPUT_COUNTER(drop_plcp);\n\tPUT_COUNTER(drop_fcs);\n\tPUT_COUNTER(drop_no_key);\n\tPUT_COUNTER(drop_decryption);\n\tPUT_COUNTER(drop_tkip_mic);\n\tPUT_COUNTER(drop_bip_mic);\n\tPUT_COUNTER(drop_cmac_icv);\n\tPUT_COUNTER(drop_cmac_replay);\n\tPUT_COUNTER(drop_ccmp_replay);\n\tPUT_COUNTER(drop_duplicate);\n\n\tPUT_COUNTER(rx_bcn_miss);\n\tPUT_COUNTER(rx_bcn_success);\n\tPUT_COUNTER(rx_bcn_dtim);\n\tPUT_COUNTER(rx_bcn_dtim_aid0_clr);\n\tPUT_COUNTER(rx_bcn_dtim_aid0_set);\n\n#undef PUT_COUNTER\n\n\tfor (i = 0; i < ARRAY_SIZE(counters[0].reserved); i++)\n\t\tseq_printf(seq, \"reserved[%02d]%12s %12d %12d %12d\\n\", i, \"\",\n\t\t\t   le32_to_cpu(counters[2].reserved[i]),\n\t\t\t   le32_to_cpu(counters[0].reserved[i]),\n\t\t\t   le32_to_cpu(counters[1].reserved[i]));\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(wfx_counters);\n\nstatic const char * const channel_names[] = {\n\t[0] = \"1M\",\n\t[1] = \"2M\",\n\t[2] = \"5.5M\",\n\t[3] = \"11M\",\n\t \n\t[6] = \"6M\",\n\t[7] = \"9M\",\n\t[8] = \"12M\",\n\t[9] = \"18M\",\n\t[10] = \"24M\",\n\t[11] = \"36M\",\n\t[12] = \"48M\",\n\t[13] = \"54M\",\n\t[14] = \"MCS0\",\n\t[15] = \"MCS1\",\n\t[16] = \"MCS2\",\n\t[17] = \"MCS3\",\n\t[18] = \"MCS4\",\n\t[19] = \"MCS5\",\n\t[20] = \"MCS6\",\n\t[21] = \"MCS7\",\n};\n\nstatic int wfx_rx_stats_show(struct seq_file *seq, void *v)\n{\n\tstruct wfx_dev *wdev = seq->private;\n\tstruct wfx_hif_rx_stats *st = &wdev->rx_stats;\n\tint i;\n\n\tmutex_lock(&wdev->rx_stats_lock);\n\tseq_printf(seq, \"Timestamp: %dus\\n\", st->date);\n\tseq_printf(seq, \"Low power clock: frequency %uHz, external %s\\n\",\n\t\t   le32_to_cpu(st->pwr_clk_freq), st->is_ext_pwr_clk ? \"yes\" : \"no\");\n\tseq_printf(seq, \"Num. of frames: %d, PER (x10e4): %d, Throughput: %dKbps/s\\n\",\n\t\t   st->nb_rx_frame, st->per_total, st->throughput);\n\tseq_puts(seq, \"       Num. of      PER     RSSI      SNR      CFO\\n\");\n\tseq_puts(seq, \"        frames  (x10e4)    (dBm)     (dB)    (kHz)\\n\");\n\tfor (i = 0; i < ARRAY_SIZE(channel_names); i++) {\n\t\tif (channel_names[i])\n\t\t\tseq_printf(seq, \"%5s %8d %8d %8d %8d %8d\\n\",\n\t\t\t\t   channel_names[i],\n\t\t\t\t   le32_to_cpu(st->nb_rx_by_rate[i]),\n\t\t\t\t   le16_to_cpu(st->per[i]),\n\t\t\t\t   (s16)le16_to_cpu(st->rssi[i]) / 100,\n\t\t\t\t   (s16)le16_to_cpu(st->snr[i]) / 100,\n\t\t\t\t   (s16)le16_to_cpu(st->cfo[i]));\n\t}\n\tmutex_unlock(&wdev->rx_stats_lock);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(wfx_rx_stats);\n\nstatic int wfx_tx_power_loop_show(struct seq_file *seq, void *v)\n{\n\tstruct wfx_dev *wdev = seq->private;\n\tstruct wfx_hif_tx_power_loop_info *st = &wdev->tx_power_loop_info;\n\tint tmp;\n\n\tmutex_lock(&wdev->tx_power_loop_info_lock);\n\ttmp = le16_to_cpu(st->tx_gain_dig);\n\tseq_printf(seq, \"Tx gain digital: %d\\n\", tmp);\n\ttmp = le16_to_cpu(st->tx_gain_pa);\n\tseq_printf(seq, \"Tx gain PA: %d\\n\", tmp);\n\ttmp = (s16)le16_to_cpu(st->target_pout);\n\tseq_printf(seq, \"Target Pout: %d.%02d dBm\\n\", tmp / 4, (tmp % 4) * 25);\n\ttmp = (s16)le16_to_cpu(st->p_estimation);\n\tseq_printf(seq, \"FEM Pout: %d.%02d dBm\\n\", tmp / 4, (tmp % 4) * 25);\n\ttmp = le16_to_cpu(st->vpdet);\n\tseq_printf(seq, \"Vpdet: %d mV\\n\", tmp);\n\tseq_printf(seq, \"Measure index: %d\\n\", st->measurement_index);\n\tmutex_unlock(&wdev->tx_power_loop_info_lock);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(wfx_tx_power_loop);\n\nstatic ssize_t wfx_send_pds_write(struct file *file, const char __user *user_buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct wfx_dev *wdev = file->private_data;\n\tchar *buf;\n\tint ret;\n\n\tif (*ppos != 0) {\n\t\tdev_dbg(wdev->dev, \"PDS data must be written in one transaction\");\n\t\treturn -EBUSY;\n\t}\n\tbuf = memdup_user(user_buf, count);\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\t*ppos = *ppos + count;\n\tret = wfx_send_pds(wdev, buf, count);\n\tkfree(buf);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn count;\n}\n\nstatic const struct file_operations wfx_send_pds_fops = {\n\t.open = simple_open,\n\t.write = wfx_send_pds_write,\n};\n\nstruct dbgfs_hif_msg {\n\tstruct wfx_dev *wdev;\n\tstruct completion complete;\n\tu8 reply[1024];\n\tint ret;\n};\n\nstatic ssize_t wfx_send_hif_msg_write(struct file *file, const char __user *user_buf,\n\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct dbgfs_hif_msg *context = file->private_data;\n\tstruct wfx_dev *wdev = context->wdev;\n\tstruct wfx_hif_msg *request;\n\n\tif (completion_done(&context->complete)) {\n\t\tdev_dbg(wdev->dev, \"read previous result before start a new one\\n\");\n\t\treturn -EBUSY;\n\t}\n\tif (count < sizeof(struct wfx_hif_msg))\n\t\treturn -EINVAL;\n\n\t \n\tmemset(context->reply, 0xFF, sizeof(context->reply));\n\trequest = memdup_user(user_buf, count);\n\tif (IS_ERR(request))\n\t\treturn PTR_ERR(request);\n\tif (le16_to_cpu(request->len) != count) {\n\t\tkfree(request);\n\t\treturn -EINVAL;\n\t}\n\tcontext->ret = wfx_cmd_send(wdev, request, context->reply, sizeof(context->reply), false);\n\n\tkfree(request);\n\tcomplete(&context->complete);\n\treturn count;\n}\n\nstatic ssize_t wfx_send_hif_msg_read(struct file *file, char __user *user_buf,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct dbgfs_hif_msg *context = file->private_data;\n\tint ret;\n\n\tif (count > sizeof(context->reply))\n\t\treturn -EINVAL;\n\tret = wait_for_completion_interruptible(&context->complete);\n\tif (ret)\n\t\treturn ret;\n\tif (context->ret < 0)\n\t\treturn context->ret;\n\t \n\tif (copy_to_user(user_buf, context->reply, count))\n\t\treturn -EFAULT;\n\n\treturn count;\n}\n\nstatic int wfx_send_hif_msg_open(struct inode *inode, struct file *file)\n{\n\tstruct dbgfs_hif_msg *context = kzalloc(sizeof(*context), GFP_KERNEL);\n\n\tif (!context)\n\t\treturn -ENOMEM;\n\tcontext->wdev = inode->i_private;\n\tinit_completion(&context->complete);\n\tfile->private_data = context;\n\treturn 0;\n}\n\nstatic int wfx_send_hif_msg_release(struct inode *inode, struct file *file)\n{\n\tstruct dbgfs_hif_msg *context = file->private_data;\n\n\tkfree(context);\n\treturn 0;\n}\n\nstatic const struct file_operations wfx_send_hif_msg_fops = {\n\t.open = wfx_send_hif_msg_open,\n\t.release = wfx_send_hif_msg_release,\n\t.write = wfx_send_hif_msg_write,\n\t.read = wfx_send_hif_msg_read,\n};\n\nint wfx_debug_init(struct wfx_dev *wdev)\n{\n\tstruct dentry *d;\n\n\td = debugfs_create_dir(\"wfx\", wdev->hw->wiphy->debugfsdir);\n\tdebugfs_create_file(\"counters\", 0444, d, wdev, &wfx_counters_fops);\n\tdebugfs_create_file(\"rx_stats\", 0444, d, wdev, &wfx_rx_stats_fops);\n\tdebugfs_create_file(\"tx_power_loop\", 0444, d, wdev, &wfx_tx_power_loop_fops);\n\tdebugfs_create_file(\"send_pds\", 0200, d, wdev, &wfx_send_pds_fops);\n\tdebugfs_create_file(\"send_hif_msg\", 0600, d, wdev, &wfx_send_hif_msg_fops);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}