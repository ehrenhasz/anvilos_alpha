{
  "module_name": "queue.c",
  "hash_id": "c3f6409a477be6ac03fbb22987107561c44c124ab775023c2e941a4a15935b2c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/silabs/wfx/queue.c",
  "human_readable_source": "\n \n#include <linux/sched.h>\n#include <net/mac80211.h>\n\n#include \"queue.h\"\n#include \"wfx.h\"\n#include \"sta.h\"\n#include \"data_tx.h\"\n#include \"traces.h\"\n\nvoid wfx_tx_lock(struct wfx_dev *wdev)\n{\n\tatomic_inc(&wdev->tx_lock);\n}\n\nvoid wfx_tx_unlock(struct wfx_dev *wdev)\n{\n\tint tx_lock = atomic_dec_return(&wdev->tx_lock);\n\n\tWARN(tx_lock < 0, \"inconsistent tx_lock value\");\n\tif (!tx_lock)\n\t\twfx_bh_request_tx(wdev);\n}\n\nvoid wfx_tx_flush(struct wfx_dev *wdev)\n{\n\tint ret;\n\n\t \n\tif (wdev->chip_frozen)\n\t\treturn;\n\n\twfx_tx_lock(wdev);\n\tmutex_lock(&wdev->hif_cmd.lock);\n\tret = wait_event_timeout(wdev->hif.tx_buffers_empty, !wdev->hif.tx_buffers_used,\n\t\t\t\t msecs_to_jiffies(3000));\n\tif (!ret) {\n\t\tdev_warn(wdev->dev, \"cannot flush tx buffers (%d still busy)\\n\",\n\t\t\t wdev->hif.tx_buffers_used);\n\t\twfx_pending_dump_old_frames(wdev, 3000);\n\t\t \n\t\twdev->chip_frozen = true;\n\t}\n\tmutex_unlock(&wdev->hif_cmd.lock);\n\twfx_tx_unlock(wdev);\n}\n\nvoid wfx_tx_lock_flush(struct wfx_dev *wdev)\n{\n\twfx_tx_lock(wdev);\n\twfx_tx_flush(wdev);\n}\n\nvoid wfx_tx_queues_init(struct wfx_vif *wvif)\n{\n\t \n\tconst int priorities[IEEE80211_NUM_ACS] = { 1, 2, 64, 128 };\n\tint i;\n\n\tfor (i = 0; i < IEEE80211_NUM_ACS; ++i) {\n\t\tskb_queue_head_init(&wvif->tx_queue[i].normal);\n\t\tskb_queue_head_init(&wvif->tx_queue[i].cab);\n\t\twvif->tx_queue[i].priority = priorities[i];\n\t}\n}\n\nbool wfx_tx_queue_empty(struct wfx_vif *wvif, struct wfx_queue *queue)\n{\n\treturn skb_queue_empty_lockless(&queue->normal) && skb_queue_empty_lockless(&queue->cab);\n}\n\nvoid wfx_tx_queues_check_empty(struct wfx_vif *wvif)\n{\n\tint i;\n\n\tfor (i = 0; i < IEEE80211_NUM_ACS; ++i) {\n\t\tWARN_ON(atomic_read(&wvif->tx_queue[i].pending_frames));\n\t\tWARN_ON(!wfx_tx_queue_empty(wvif, &wvif->tx_queue[i]));\n\t}\n}\n\nstatic void __wfx_tx_queue_drop(struct wfx_vif *wvif,\n\t\t\t\tstruct sk_buff_head *skb_queue, struct sk_buff_head *dropped)\n{\n\tstruct sk_buff *skb, *tmp;\n\n\tspin_lock_bh(&skb_queue->lock);\n\tskb_queue_walk_safe(skb_queue, skb, tmp) {\n\t\t__skb_unlink(skb, skb_queue);\n\t\tskb_queue_head(dropped, skb);\n\t}\n\tspin_unlock_bh(&skb_queue->lock);\n}\n\nvoid wfx_tx_queue_drop(struct wfx_vif *wvif, struct wfx_queue *queue,\n\t\t       struct sk_buff_head *dropped)\n{\n\t__wfx_tx_queue_drop(wvif, &queue->cab, dropped);\n\t__wfx_tx_queue_drop(wvif, &queue->normal, dropped);\n\twake_up(&wvif->wdev->tx_dequeue);\n}\n\nvoid wfx_tx_queues_put(struct wfx_vif *wvif, struct sk_buff *skb)\n{\n\tstruct wfx_queue *queue = &wvif->tx_queue[skb_get_queue_mapping(skb)];\n\tstruct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);\n\n\tif (tx_info->flags & IEEE80211_TX_CTL_SEND_AFTER_DTIM)\n\t\tskb_queue_tail(&queue->cab, skb);\n\telse\n\t\tskb_queue_tail(&queue->normal, skb);\n}\n\nvoid wfx_pending_drop(struct wfx_dev *wdev, struct sk_buff_head *dropped)\n{\n\tstruct wfx_queue *queue;\n\tstruct wfx_vif *wvif;\n\tstruct wfx_hif_msg *hif;\n\tstruct sk_buff *skb;\n\n\tWARN(!wdev->chip_frozen, \"%s should only be used to recover a frozen device\", __func__);\n\twhile ((skb = skb_dequeue(&wdev->tx_pending)) != NULL) {\n\t\thif = (struct wfx_hif_msg *)skb->data;\n\t\twvif = wdev_to_wvif(wdev, hif->interface);\n\t\tif (wvif) {\n\t\t\tqueue = &wvif->tx_queue[skb_get_queue_mapping(skb)];\n\t\t\tWARN_ON(skb_get_queue_mapping(skb) > 3);\n\t\t\tWARN_ON(!atomic_read(&queue->pending_frames));\n\t\t\tatomic_dec(&queue->pending_frames);\n\t\t}\n\t\tskb_queue_head(dropped, skb);\n\t}\n}\n\nstruct sk_buff *wfx_pending_get(struct wfx_dev *wdev, u32 packet_id)\n{\n\tstruct wfx_queue *queue;\n\tstruct wfx_hif_req_tx *req;\n\tstruct wfx_vif *wvif;\n\tstruct wfx_hif_msg *hif;\n\tstruct sk_buff *skb;\n\n\tspin_lock_bh(&wdev->tx_pending.lock);\n\tskb_queue_walk(&wdev->tx_pending, skb) {\n\t\thif = (struct wfx_hif_msg *)skb->data;\n\t\treq = (struct wfx_hif_req_tx *)hif->body;\n\t\tif (req->packet_id != packet_id)\n\t\t\tcontinue;\n\t\tspin_unlock_bh(&wdev->tx_pending.lock);\n\t\twvif = wdev_to_wvif(wdev, hif->interface);\n\t\tif (wvif) {\n\t\t\tqueue = &wvif->tx_queue[skb_get_queue_mapping(skb)];\n\t\t\tWARN_ON(skb_get_queue_mapping(skb) > 3);\n\t\t\tWARN_ON(!atomic_read(&queue->pending_frames));\n\t\t\tatomic_dec(&queue->pending_frames);\n\t\t}\n\t\tskb_unlink(skb, &wdev->tx_pending);\n\t\treturn skb;\n\t}\n\tspin_unlock_bh(&wdev->tx_pending.lock);\n\tWARN(1, \"cannot find packet in pending queue\");\n\treturn NULL;\n}\n\nvoid wfx_pending_dump_old_frames(struct wfx_dev *wdev, unsigned int limit_ms)\n{\n\tktime_t now = ktime_get();\n\tstruct wfx_tx_priv *tx_priv;\n\tstruct wfx_hif_req_tx *req;\n\tstruct sk_buff *skb;\n\tbool first = true;\n\n\tspin_lock_bh(&wdev->tx_pending.lock);\n\tskb_queue_walk(&wdev->tx_pending, skb) {\n\t\ttx_priv = wfx_skb_tx_priv(skb);\n\t\treq = wfx_skb_txreq(skb);\n\t\tif (ktime_after(now, ktime_add_ms(tx_priv->xmit_timestamp, limit_ms))) {\n\t\t\tif (first) {\n\t\t\t\tdev_info(wdev->dev, \"frames stuck in firmware since %dms or more:\\n\",\n\t\t\t\t\t limit_ms);\n\t\t\t\tfirst = false;\n\t\t\t}\n\t\t\tdev_info(wdev->dev, \"   id %08x sent %lldms ago\\n\",\n\t\t\t\t req->packet_id, ktime_ms_delta(now, tx_priv->xmit_timestamp));\n\t\t}\n\t}\n\tspin_unlock_bh(&wdev->tx_pending.lock);\n}\n\nunsigned int wfx_pending_get_pkt_us_delay(struct wfx_dev *wdev, struct sk_buff *skb)\n{\n\tktime_t now = ktime_get();\n\tstruct wfx_tx_priv *tx_priv = wfx_skb_tx_priv(skb);\n\n\treturn ktime_us_delta(now, tx_priv->xmit_timestamp);\n}\n\nbool wfx_tx_queues_has_cab(struct wfx_vif *wvif)\n{\n\tstruct ieee80211_vif *vif = wvif_to_vif(wvif);\n\tint i;\n\n\tif (vif->type != NL80211_IFTYPE_AP)\n\t\treturn false;\n\tfor (i = 0; i < IEEE80211_NUM_ACS; ++i)\n\t\t \n\t\tif (!skb_queue_empty_lockless(&wvif->tx_queue[i].cab))\n\t\t\treturn true;\n\treturn false;\n}\n\nstatic int wfx_tx_queue_get_weight(struct wfx_queue *queue)\n{\n\treturn atomic_read(&queue->pending_frames) * queue->priority;\n}\n\nstatic struct sk_buff *wfx_tx_queues_get_skb(struct wfx_dev *wdev)\n{\n\tstruct wfx_queue *queues[IEEE80211_NUM_ACS * ARRAY_SIZE(wdev->vif)];\n\tint i, j, num_queues = 0;\n\tstruct wfx_vif *wvif;\n\tstruct wfx_hif_msg *hif;\n\tstruct sk_buff *skb;\n\n\t \n\twvif = NULL;\n\twhile ((wvif = wvif_iterate(wdev, wvif)) != NULL) {\n\t\tfor (i = 0; i < IEEE80211_NUM_ACS; i++) {\n\t\t\tWARN_ON(num_queues >= ARRAY_SIZE(queues));\n\t\t\tqueues[num_queues] = &wvif->tx_queue[i];\n\t\t\tfor (j = num_queues; j > 0; j--)\n\t\t\t\tif (wfx_tx_queue_get_weight(queues[j]) <\n\t\t\t\t    wfx_tx_queue_get_weight(queues[j - 1]))\n\t\t\t\t\tswap(queues[j - 1], queues[j]);\n\t\t\tnum_queues++;\n\t\t}\n\t}\n\n\twvif = NULL;\n\twhile ((wvif = wvif_iterate(wdev, wvif)) != NULL) {\n\t\tif (!wvif->after_dtim_tx_allowed)\n\t\t\tcontinue;\n\t\tfor (i = 0; i < num_queues; i++) {\n\t\t\tskb = skb_dequeue(&queues[i]->cab);\n\t\t\tif (!skb)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\thif = (struct wfx_hif_msg *)skb->data;\n\t\t\tWARN_ON(hif->interface != wvif->id);\n\t\t\tWARN_ON(queues[i] != &wvif->tx_queue[skb_get_queue_mapping(skb)]);\n\t\t\tatomic_inc(&queues[i]->pending_frames);\n\t\t\ttrace_queues_stats(wdev, queues[i]);\n\t\t\treturn skb;\n\t\t}\n\t\t \n\t\twvif->after_dtim_tx_allowed = false;\n\t\tschedule_work(&wvif->update_tim_work);\n\t}\n\n\tfor (i = 0; i < num_queues; i++) {\n\t\tskb = skb_dequeue(&queues[i]->normal);\n\t\tif (skb) {\n\t\t\tatomic_inc(&queues[i]->pending_frames);\n\t\t\ttrace_queues_stats(wdev, queues[i]);\n\t\t\treturn skb;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstruct wfx_hif_msg *wfx_tx_queues_get(struct wfx_dev *wdev)\n{\n\tstruct wfx_tx_priv *tx_priv;\n\tstruct sk_buff *skb;\n\n\tif (atomic_read(&wdev->tx_lock))\n\t\treturn NULL;\n\tskb = wfx_tx_queues_get_skb(wdev);\n\tif (!skb)\n\t\treturn NULL;\n\tskb_queue_tail(&wdev->tx_pending, skb);\n\twake_up(&wdev->tx_dequeue);\n\ttx_priv = wfx_skb_tx_priv(skb);\n\ttx_priv->xmit_timestamp = ktime_get();\n\treturn (struct wfx_hif_msg *)skb->data;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}