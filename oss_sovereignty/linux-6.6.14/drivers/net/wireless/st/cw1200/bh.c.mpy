{
  "module_name": "bh.c",
  "hash_id": "34e79f5894749c33432e16fa7a42ee851342033d32463d1f4038932f7db4e9b0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/st/cw1200/bh.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <net/mac80211.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n\n#include \"cw1200.h\"\n#include \"bh.h\"\n#include \"hwio.h\"\n#include \"wsm.h\"\n#include \"hwbus.h\"\n#include \"debug.h\"\n#include \"fwio.h\"\n\nstatic int cw1200_bh(void *arg);\n\n#define DOWNLOAD_BLOCK_SIZE_WR\t(0x1000 - 4)\n \n#define MAX_SZ_RD_WR_BUFFERS\t(DOWNLOAD_BLOCK_SIZE_WR*2)\n#define PIGGYBACK_CTRL_REG\t(2)\n#define EFFECTIVE_BUF_SIZE\t(MAX_SZ_RD_WR_BUFFERS - PIGGYBACK_CTRL_REG)\n\n \nenum cw1200_bh_pm_state {\n\tCW1200_BH_RESUMED = 0,\n\tCW1200_BH_SUSPEND,\n\tCW1200_BH_SUSPENDED,\n\tCW1200_BH_RESUME,\n};\n\nstatic void cw1200_bh_work(struct work_struct *work)\n{\n\tstruct cw1200_common *priv =\n\tcontainer_of(work, struct cw1200_common, bh_work);\n\tcw1200_bh(priv);\n}\n\nint cw1200_register_bh(struct cw1200_common *priv)\n{\n\tint err = 0;\n\t \n\tpriv->bh_workqueue = alloc_workqueue(\"cw1200_bh\",\n\t\t\t\tWQ_MEM_RECLAIM | WQ_HIGHPRI\n\t\t\t\t| WQ_CPU_INTENSIVE, 1);\n\n\tif (!priv->bh_workqueue)\n\t\treturn -ENOMEM;\n\n\tINIT_WORK(&priv->bh_work, cw1200_bh_work);\n\n\tpr_debug(\"[BH] register.\\n\");\n\n\tatomic_set(&priv->bh_rx, 0);\n\tatomic_set(&priv->bh_tx, 0);\n\tatomic_set(&priv->bh_term, 0);\n\tatomic_set(&priv->bh_suspend, CW1200_BH_RESUMED);\n\tpriv->bh_error = 0;\n\tpriv->hw_bufs_used = 0;\n\tpriv->buf_id_tx = 0;\n\tpriv->buf_id_rx = 0;\n\tinit_waitqueue_head(&priv->bh_wq);\n\tinit_waitqueue_head(&priv->bh_evt_wq);\n\n\terr = !queue_work(priv->bh_workqueue, &priv->bh_work);\n\tWARN_ON(err);\n\treturn err;\n}\n\nvoid cw1200_unregister_bh(struct cw1200_common *priv)\n{\n\tatomic_inc(&priv->bh_term);\n\twake_up(&priv->bh_wq);\n\n\tdestroy_workqueue(priv->bh_workqueue);\n\tpriv->bh_workqueue = NULL;\n\n\tpr_debug(\"[BH] unregistered.\\n\");\n}\n\nvoid cw1200_irq_handler(struct cw1200_common *priv)\n{\n\tpr_debug(\"[BH] irq.\\n\");\n\n\t \n\t \n\t__cw1200_irq_enable(priv, 0);\n\n\tif ( (priv->bh_error))\n\t\treturn;\n\n\tif (atomic_inc_return(&priv->bh_rx) == 1)\n\t\twake_up(&priv->bh_wq);\n}\nEXPORT_SYMBOL_GPL(cw1200_irq_handler);\n\nvoid cw1200_bh_wakeup(struct cw1200_common *priv)\n{\n\tpr_debug(\"[BH] wakeup.\\n\");\n\tif (priv->bh_error) {\n\t\tpr_err(\"[BH] wakeup failed (BH error)\\n\");\n\t\treturn;\n\t}\n\n\tif (atomic_inc_return(&priv->bh_tx) == 1)\n\t\twake_up(&priv->bh_wq);\n}\n\nint cw1200_bh_suspend(struct cw1200_common *priv)\n{\n\tpr_debug(\"[BH] suspend.\\n\");\n\tif (priv->bh_error) {\n\t\twiphy_warn(priv->hw->wiphy, \"BH error -- can't suspend\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tatomic_set(&priv->bh_suspend, CW1200_BH_SUSPEND);\n\twake_up(&priv->bh_wq);\n\treturn wait_event_timeout(priv->bh_evt_wq, priv->bh_error ||\n\t\t(CW1200_BH_SUSPENDED == atomic_read(&priv->bh_suspend)),\n\t\t 1 * HZ) ? 0 : -ETIMEDOUT;\n}\n\nint cw1200_bh_resume(struct cw1200_common *priv)\n{\n\tpr_debug(\"[BH] resume.\\n\");\n\tif (priv->bh_error) {\n\t\twiphy_warn(priv->hw->wiphy, \"BH error -- can't resume\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tatomic_set(&priv->bh_suspend, CW1200_BH_RESUME);\n\twake_up(&priv->bh_wq);\n\treturn wait_event_timeout(priv->bh_evt_wq, priv->bh_error ||\n\t\t(CW1200_BH_RESUMED == atomic_read(&priv->bh_suspend)),\n\t\t1 * HZ) ? 0 : -ETIMEDOUT;\n}\n\nstatic inline void wsm_alloc_tx_buffer(struct cw1200_common *priv)\n{\n\t++priv->hw_bufs_used;\n}\n\nint wsm_release_tx_buffer(struct cw1200_common *priv, int count)\n{\n\tint ret = 0;\n\tint hw_bufs_used = priv->hw_bufs_used;\n\n\tpriv->hw_bufs_used -= count;\n\tif (WARN_ON(priv->hw_bufs_used < 0))\n\t\tret = -1;\n\telse if (hw_bufs_used >= priv->wsm_caps.input_buffers)\n\t\tret = 1;\n\tif (!priv->hw_bufs_used)\n\t\twake_up(&priv->bh_evt_wq);\n\treturn ret;\n}\n\nstatic int cw1200_bh_read_ctrl_reg(struct cw1200_common *priv,\n\t\t\t\t\t  u16 *ctrl_reg)\n{\n\tint ret;\n\n\tret = cw1200_reg_read_16(priv,\n\t\t\tST90TDS_CONTROL_REG_ID, ctrl_reg);\n\tif (ret) {\n\t\tret = cw1200_reg_read_16(priv,\n\t\t\t\tST90TDS_CONTROL_REG_ID, ctrl_reg);\n\t\tif (ret)\n\t\t\tpr_err(\"[BH] Failed to read control register.\\n\");\n\t}\n\n\treturn ret;\n}\n\nstatic int cw1200_device_wakeup(struct cw1200_common *priv)\n{\n\tu16 ctrl_reg;\n\tint ret;\n\n\tpr_debug(\"[BH] Device wakeup.\\n\");\n\n\t \n\tret = cw1200_reg_write_32(priv, ST90TDS_TSET_GEN_R_W_REG_ID,\n\t\t\t\t  cw1200_dpll_from_clk(priv->hw_refclk));\n\tif (WARN_ON(ret))\n\t\treturn ret;\n\n\t \n\tret = cw1200_reg_write_16(priv, ST90TDS_CONTROL_REG_ID,\n\t\t\tST90TDS_CONT_WUP_BIT);\n\tif (WARN_ON(ret))\n\t\treturn ret;\n\n\tret = cw1200_bh_read_ctrl_reg(priv, &ctrl_reg);\n\tif (WARN_ON(ret))\n\t\treturn ret;\n\n\t \n\tif (ctrl_reg & ST90TDS_CONT_RDY_BIT) {\n\t\tpr_debug(\"[BH] Device awake.\\n\");\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \nvoid cw1200_enable_powersave(struct cw1200_common *priv,\n\t\t\t     bool enable)\n{\n\tpr_debug(\"[BH] Powerave is %s.\\n\",\n\t\t enable ? \"enabled\" : \"disabled\");\n\tpriv->powersave_enabled = enable;\n}\n\nstatic int cw1200_bh_rx_helper(struct cw1200_common *priv,\n\t\t\t       uint16_t *ctrl_reg,\n\t\t\t       int *tx)\n{\n\tsize_t read_len = 0;\n\tstruct sk_buff *skb_rx = NULL;\n\tstruct wsm_hdr *wsm;\n\tsize_t wsm_len;\n\tu16 wsm_id;\n\tu8 wsm_seq;\n\tint rx_resync = 1;\n\n\tsize_t alloc_len;\n\tu8 *data;\n\n\tread_len = (*ctrl_reg & ST90TDS_CONT_NEXT_LEN_MASK) * 2;\n\tif (!read_len)\n\t\treturn 0;  \n\n\tif (WARN_ON((read_len < sizeof(struct wsm_hdr)) ||\n\t\t    (read_len > EFFECTIVE_BUF_SIZE))) {\n\t\tpr_debug(\"Invalid read len: %zu (%04x)\",\n\t\t\t read_len, *ctrl_reg);\n\t\tgoto err;\n\t}\n\n\t \n\tread_len = read_len + 2;\n\n\talloc_len = priv->hwbus_ops->align_size(\n\t\tpriv->hwbus_priv, read_len);\n\n\t \n\tif (WARN_ON_ONCE(alloc_len > EFFECTIVE_BUF_SIZE)) {\n\t\tpr_debug(\"Read aligned len: %zu\\n\",\n\t\t\t alloc_len);\n\t}\n\n\tskb_rx = dev_alloc_skb(alloc_len);\n\tif (WARN_ON(!skb_rx))\n\t\tgoto err;\n\n\tskb_trim(skb_rx, 0);\n\tskb_put(skb_rx, read_len);\n\tdata = skb_rx->data;\n\tif (WARN_ON(!data))\n\t\tgoto err;\n\n\tif (WARN_ON(cw1200_data_read(priv, data, alloc_len))) {\n\t\tpr_err(\"rx blew up, len %zu\\n\", alloc_len);\n\t\tgoto err;\n\t}\n\n\t \n\t*ctrl_reg = __le16_to_cpu(\n\t\t((__le16 *)data)[alloc_len / 2 - 1]);\n\n\twsm = (struct wsm_hdr *)data;\n\twsm_len = __le16_to_cpu(wsm->len);\n\tif (WARN_ON(wsm_len > read_len))\n\t\tgoto err;\n\n\tif (priv->wsm_enable_wsm_dumps)\n\t\tprint_hex_dump_bytes(\"<-- \",\n\t\t\t\t     DUMP_PREFIX_NONE,\n\t\t\t\t     data, wsm_len);\n\n\twsm_id  = __le16_to_cpu(wsm->id) & 0xFFF;\n\twsm_seq = (__le16_to_cpu(wsm->id) >> 13) & 7;\n\n\tskb_trim(skb_rx, wsm_len);\n\n\tif (wsm_id == 0x0800) {\n\t\twsm_handle_exception(priv,\n\t\t\t\t     &data[sizeof(*wsm)],\n\t\t\t\t     wsm_len - sizeof(*wsm));\n\t\tgoto err;\n\t} else if (!rx_resync) {\n\t\tif (WARN_ON(wsm_seq != priv->wsm_rx_seq))\n\t\t\tgoto err;\n\t}\n\tpriv->wsm_rx_seq = (wsm_seq + 1) & 7;\n\trx_resync = 0;\n\n\tif (wsm_id & 0x0400) {\n\t\tint rc = wsm_release_tx_buffer(priv, 1);\n\t\tif (WARN_ON(rc < 0))\n\t\t\treturn rc;\n\t\telse if (rc > 0)\n\t\t\t*tx = 1;\n\t}\n\n\t \n\tif (WARN_ON(wsm_handle_rx(priv, wsm_id, wsm, &skb_rx)))\n\t\tgoto err;\n\n\tdev_kfree_skb(skb_rx);\n\n\treturn 0;\n\nerr:\n\tdev_kfree_skb(skb_rx);\n\treturn -1;\n}\n\nstatic int cw1200_bh_tx_helper(struct cw1200_common *priv,\n\t\t\t       int *pending_tx,\n\t\t\t       int *tx_burst)\n{\n\tsize_t tx_len;\n\tu8 *data;\n\tint ret;\n\tstruct wsm_hdr *wsm;\n\n\tif (priv->device_can_sleep) {\n\t\tret = cw1200_device_wakeup(priv);\n\t\tif (WARN_ON(ret < 0)) {  \n\t\t\t*pending_tx = 1;\n\t\t\treturn 0;\n\t\t} else if (ret) {  \n\t\t\tpriv->device_can_sleep = false;\n\t\t} else {  \n\t\t\t*pending_tx = 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\twsm_alloc_tx_buffer(priv);\n\tret = wsm_get_tx(priv, &data, &tx_len, tx_burst);\n\tif (ret <= 0) {\n\t\twsm_release_tx_buffer(priv, 1);\n\t\tif (WARN_ON(ret < 0))\n\t\t\treturn ret;  \n\t\treturn 0;  \n\t}\n\n\twsm = (struct wsm_hdr *)data;\n\tBUG_ON(tx_len < sizeof(*wsm));\n\tBUG_ON(__le16_to_cpu(wsm->len) != tx_len);\n\n\tatomic_inc(&priv->bh_tx);\n\n\ttx_len = priv->hwbus_ops->align_size(\n\t\tpriv->hwbus_priv, tx_len);\n\n\t \n\tif (WARN_ON_ONCE(tx_len > EFFECTIVE_BUF_SIZE))\n\t\tpr_debug(\"Write aligned len: %zu\\n\", tx_len);\n\n\twsm->id &= __cpu_to_le16(0xffff ^ WSM_TX_SEQ(WSM_TX_SEQ_MAX));\n\twsm->id |= __cpu_to_le16(WSM_TX_SEQ(priv->wsm_tx_seq));\n\n\tif (WARN_ON(cw1200_data_write(priv, data, tx_len))) {\n\t\tpr_err(\"tx blew up, len %zu\\n\", tx_len);\n\t\twsm_release_tx_buffer(priv, 1);\n\t\treturn -1;  \n\t}\n\n\tif (priv->wsm_enable_wsm_dumps)\n\t\tprint_hex_dump_bytes(\"--> \",\n\t\t\t\t     DUMP_PREFIX_NONE,\n\t\t\t\t     data,\n\t\t\t\t     __le16_to_cpu(wsm->len));\n\n\twsm_txed(priv, data);\n\tpriv->wsm_tx_seq = (priv->wsm_tx_seq + 1) & WSM_TX_SEQ_MAX;\n\n\tif (*tx_burst > 1) {\n\t\tcw1200_debug_tx_burst(priv);\n\t\treturn 1;  \n\t}\n\n\treturn 0;\n}\n\nstatic int cw1200_bh(void *arg)\n{\n\tstruct cw1200_common *priv = arg;\n\tint rx, tx, term, suspend;\n\tu16 ctrl_reg = 0;\n\tint tx_allowed;\n\tint pending_tx = 0;\n\tint tx_burst;\n\tlong status;\n\tu32 dummy;\n\tint ret;\n\n\tfor (;;) {\n\t\tif (!priv->hw_bufs_used &&\n\t\t    priv->powersave_enabled &&\n\t\t    !priv->device_can_sleep &&\n\t\t    !atomic_read(&priv->recent_scan)) {\n\t\t\tstatus = 1 * HZ;\n\t\t\tpr_debug(\"[BH] Device wakedown. No data.\\n\");\n\t\t\tcw1200_reg_write_16(priv, ST90TDS_CONTROL_REG_ID, 0);\n\t\t\tpriv->device_can_sleep = true;\n\t\t} else if (priv->hw_bufs_used) {\n\t\t\t \n\t\t\tstatus = 1 * HZ;\n\t\t} else {\n\t\t\tstatus = MAX_SCHEDULE_TIMEOUT;\n\t\t}\n\n\t\t \n\t\tif ((priv->hw_type != -1) &&\n\t\t    (atomic_read(&priv->bh_rx) == 0) &&\n\t\t    (atomic_read(&priv->bh_tx) == 0))\n\t\t\tcw1200_reg_read(priv, ST90TDS_CONFIG_REG_ID,\n\t\t\t\t\t&dummy, sizeof(dummy));\n\n\t\tpr_debug(\"[BH] waiting ...\\n\");\n\t\tstatus = wait_event_interruptible_timeout(priv->bh_wq, ({\n\t\t\t\trx = atomic_xchg(&priv->bh_rx, 0);\n\t\t\t\ttx = atomic_xchg(&priv->bh_tx, 0);\n\t\t\t\tterm = atomic_xchg(&priv->bh_term, 0);\n\t\t\t\tsuspend = pending_tx ?\n\t\t\t\t\t0 : atomic_read(&priv->bh_suspend);\n\t\t\t\t(rx || tx || term || suspend || priv->bh_error);\n\t\t\t}), status);\n\n\t\tpr_debug(\"[BH] - rx: %d, tx: %d, term: %d, bh_err: %d, suspend: %d, status: %ld\\n\",\n\t\t\t rx, tx, term, suspend, priv->bh_error, status);\n\n\t\t \n\t\tif ((status < 0 && status != -ERESTARTSYS) ||\n\t\t    term || priv->bh_error) {\n\t\t\tbreak;\n\t\t}\n\t\tif (!status) {   \n\t\t\tunsigned long timestamp = jiffies;\n\t\t\tlong timeout;\n\t\t\tint pending = 0;\n\t\t\tint i;\n\n\t\t\t \n\t\t\tif (priv->hw_bufs_used && (!rx || !tx)) {\n\t\t\t\twiphy_warn(priv->hw->wiphy,\n\t\t\t\t\t   \"Missed interrupt? (%d frames outstanding)\\n\",\n\t\t\t\t\t   priv->hw_bufs_used);\n\t\t\t\trx = 1;\n\n\t\t\t\t \n\t\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\t\tpending += cw1200_queue_get_xmit_timestamp(\n\t\t\t\t\t\t&priv->tx_queue[i],\n\t\t\t\t\t\t&timestamp,\n\t\t\t\t\t\tpriv->pending_frame_id);\n\n\t\t\t\t \n\t\t\t\ttimeout = timestamp +\n\t\t\t\t\tWSM_CMD_LAST_CHANCE_TIMEOUT +\n\t\t\t\t\t1 * HZ  -\n\t\t\t\t\tjiffies;\n\n\t\t\t\t \n\t\t\t\tif (pending && timeout < 0) {\n\t\t\t\t\twiphy_warn(priv->hw->wiphy,\n\t\t\t\t\t\t   \"Timeout waiting for TX confirm (%d/%d pending, %ld vs %lu).\\n\",\n\t\t\t\t\t\t   priv->hw_bufs_used, pending,\n\t\t\t\t\t\t   timestamp, jiffies);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if (!priv->device_can_sleep &&\n\t\t\t\t   !atomic_read(&priv->recent_scan)) {\n\t\t\t\tpr_debug(\"[BH] Device wakedown. Timeout.\\n\");\n\t\t\t\tcw1200_reg_write_16(priv,\n\t\t\t\t\t\t    ST90TDS_CONTROL_REG_ID, 0);\n\t\t\t\tpriv->device_can_sleep = true;\n\t\t\t}\n\t\t\tgoto done;\n\t\t} else if (suspend) {\n\t\t\tpr_debug(\"[BH] Device suspend.\\n\");\n\t\t\tif (priv->powersave_enabled) {\n\t\t\t\tpr_debug(\"[BH] Device wakedown. Suspend.\\n\");\n\t\t\t\tcw1200_reg_write_16(priv,\n\t\t\t\t\t\t    ST90TDS_CONTROL_REG_ID, 0);\n\t\t\t\tpriv->device_can_sleep = true;\n\t\t\t}\n\n\t\t\tatomic_set(&priv->bh_suspend, CW1200_BH_SUSPENDED);\n\t\t\twake_up(&priv->bh_evt_wq);\n\t\t\tstatus = wait_event_interruptible(priv->bh_wq,\n\t\t\t\t\t\t\t  CW1200_BH_RESUME == atomic_read(&priv->bh_suspend));\n\t\t\tif (status < 0) {\n\t\t\t\twiphy_err(priv->hw->wiphy,\n\t\t\t\t\t  \"Failed to wait for resume: %ld.\\n\",\n\t\t\t\t\t  status);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpr_debug(\"[BH] Device resume.\\n\");\n\t\t\tatomic_set(&priv->bh_suspend, CW1200_BH_RESUMED);\n\t\t\twake_up(&priv->bh_evt_wq);\n\t\t\tatomic_inc(&priv->bh_rx);\n\t\t\tgoto done;\n\t\t}\n\n\trx:\n\t\ttx += pending_tx;\n\t\tpending_tx = 0;\n\n\t\tif (cw1200_bh_read_ctrl_reg(priv, &ctrl_reg))\n\t\t\tbreak;\n\n\t\t \n\t\tif (ctrl_reg & ST90TDS_CONT_NEXT_LEN_MASK) {\n\t\t\tret = cw1200_bh_rx_helper(priv, &ctrl_reg, &tx);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tif (ctrl_reg & ST90TDS_CONT_NEXT_LEN_MASK) {\n\t\t\t\tret = cw1200_bh_rx_helper(priv, &ctrl_reg, &tx);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\ttx:\n\t\tif (tx) {\n\t\t\ttx = 0;\n\n\t\t\tBUG_ON(priv->hw_bufs_used > priv->wsm_caps.input_buffers);\n\t\t\ttx_burst = priv->wsm_caps.input_buffers - priv->hw_bufs_used;\n\t\t\ttx_allowed = tx_burst > 0;\n\n\t\t\tif (!tx_allowed) {\n\t\t\t\t \n\t\t\t\tpending_tx = tx;\n\t\t\t\tgoto done_rx;\n\t\t\t}\n\t\t\tret = cw1200_bh_tx_helper(priv, &pending_tx, &tx_burst);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tif (ret > 0)  \n\t\t\t\ttx = ret;\n\n\t\t\t \n\t\t\tif (cw1200_bh_read_ctrl_reg(priv, &ctrl_reg))\n\t\t\t\tbreak;\n\t\t}\n\n\tdone_rx:\n\t\tif (priv->bh_error)\n\t\t\tbreak;\n\t\tif (ctrl_reg & ST90TDS_CONT_NEXT_LEN_MASK)\n\t\t\tgoto rx;\n\t\tif (tx)\n\t\t\tgoto tx;\n\n\tdone:\n\t\t \n\t\tpriv->hwbus_ops->lock(priv->hwbus_priv);\n\t\t__cw1200_irq_enable(priv, 1);\n\t\tpriv->hwbus_ops->unlock(priv->hwbus_priv);\n\t}\n\n\t \n\tpriv->hwbus_ops->lock(priv->hwbus_priv);\n\t__cw1200_irq_enable(priv, 0);\n\tpriv->hwbus_ops->unlock(priv->hwbus_priv);\n\n\tif (!term) {\n\t\tpr_err(\"[BH] Fatal error, exiting.\\n\");\n\t\tpriv->bh_error = 1;\n\t\t \n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}