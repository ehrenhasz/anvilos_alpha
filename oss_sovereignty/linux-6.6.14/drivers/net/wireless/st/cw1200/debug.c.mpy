{
  "module_name": "debug.c",
  "hash_id": "a95406732c30099c67231d1e41e767af07a8fbca8622454b273225e452cf5984",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/st/cw1200/debug.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include \"cw1200.h\"\n#include \"debug.h\"\n#include \"fwio.h\"\n\n \nstatic const char * const cw1200_debug_join_status[] = {\n\t\"passive\",\n\t\"monitor\",\n\t\"station (joining)\",\n\t\"station (not authenticated yet)\",\n\t\"station\",\n\t\"adhoc\",\n\t\"access point\",\n};\n\n \nstatic const char * const cw1200_debug_preamble[] = {\n\t\"long\",\n\t\"short\",\n\t\"long on 1 and 2 Mbps\",\n};\n\n\nstatic const char * const cw1200_debug_link_id[] = {\n\t\"OFF\",\n\t\"REQ\",\n\t\"SOFT\",\n\t\"HARD\",\n\t\"RESET\",\n\t\"RESET_REMAP\",\n};\n\nstatic const char *cw1200_debug_mode(int mode)\n{\n\tswitch (mode) {\n\tcase NL80211_IFTYPE_UNSPECIFIED:\n\t\treturn \"unspecified\";\n\tcase NL80211_IFTYPE_MONITOR:\n\t\treturn \"monitor\";\n\tcase NL80211_IFTYPE_STATION:\n\t\treturn \"station\";\n\tcase NL80211_IFTYPE_ADHOC:\n\t\treturn \"adhoc\";\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\treturn \"mesh point\";\n\tcase NL80211_IFTYPE_AP:\n\t\treturn \"access point\";\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\treturn \"p2p client\";\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\treturn \"p2p go\";\n\tdefault:\n\t\treturn \"unsupported\";\n\t}\n}\n\nstatic void cw1200_queue_status_show(struct seq_file *seq,\n\t\t\t\t     struct cw1200_queue *q)\n{\n\tint i;\n\tseq_printf(seq, \"Queue       %d:\\n\", q->queue_id);\n\tseq_printf(seq, \"  capacity: %zu\\n\", q->capacity);\n\tseq_printf(seq, \"  queued:   %zu\\n\", q->num_queued);\n\tseq_printf(seq, \"  pending:  %zu\\n\", q->num_pending);\n\tseq_printf(seq, \"  sent:     %zu\\n\", q->num_sent);\n\tseq_printf(seq, \"  locked:   %s\\n\", q->tx_locked_cnt ? \"yes\" : \"no\");\n\tseq_printf(seq, \"  overfull: %s\\n\", q->overfull ? \"yes\" : \"no\");\n\tseq_puts(seq,   \"  link map: 0-> \");\n\tfor (i = 0; i < q->stats->map_capacity; ++i)\n\t\tseq_printf(seq, \"%.2d \", q->link_map_cache[i]);\n\tseq_printf(seq, \"<-%zu\\n\", q->stats->map_capacity);\n}\n\nstatic void cw1200_debug_print_map(struct seq_file *seq,\n\t\t\t\t   struct cw1200_common *priv,\n\t\t\t\t   const char *label,\n\t\t\t\t   u32 map)\n{\n\tint i;\n\tseq_printf(seq, \"%s0-> \", label);\n\tfor (i = 0; i < priv->tx_queue_stats.map_capacity; ++i)\n\t\tseq_printf(seq, \"%s \", (map & BIT(i)) ? \"**\" : \"..\");\n\tseq_printf(seq, \"<-%zu\\n\", priv->tx_queue_stats.map_capacity - 1);\n}\n\nstatic int cw1200_status_show(struct seq_file *seq, void *v)\n{\n\tint i;\n\tstruct list_head *item;\n\tstruct cw1200_common *priv = seq->private;\n\tstruct cw1200_debug_priv *d = priv->debug;\n\n\tseq_puts(seq,   \"CW1200 Wireless LAN driver status\\n\");\n\tseq_printf(seq, \"Hardware:   %d.%d\\n\",\n\t\t   priv->wsm_caps.hw_id,\n\t\t   priv->wsm_caps.hw_subid);\n\tseq_printf(seq, \"Firmware:   %s %d.%d\\n\",\n\t\t   cw1200_fw_types[priv->wsm_caps.fw_type],\n\t\t   priv->wsm_caps.fw_ver,\n\t\t   priv->wsm_caps.fw_build);\n\tseq_printf(seq, \"FW API:     %d\\n\",\n\t\t   priv->wsm_caps.fw_api);\n\tseq_printf(seq, \"FW caps:    0x%.4X\\n\",\n\t\t   priv->wsm_caps.fw_cap);\n\tseq_printf(seq, \"FW label:  '%s'\\n\",\n\t\t   priv->wsm_caps.fw_label);\n\tseq_printf(seq, \"Mode:       %s%s\\n\",\n\t\t   cw1200_debug_mode(priv->mode),\n\t\t   priv->listening ? \" (listening)\" : \"\");\n\tseq_printf(seq, \"Join state: %s\\n\",\n\t\t   cw1200_debug_join_status[priv->join_status]);\n\tif (priv->channel)\n\t\tseq_printf(seq, \"Channel:    %d%s\\n\",\n\t\t\t   priv->channel->hw_value,\n\t\t\t   priv->channel_switch_in_progress ?\n\t\t\t   \" (switching)\" : \"\");\n\tif (priv->rx_filter.promiscuous)\n\t\tseq_puts(seq,   \"Filter:     promisc\\n\");\n\telse if (priv->rx_filter.fcs)\n\t\tseq_puts(seq,   \"Filter:     fcs\\n\");\n\tif (priv->rx_filter.bssid)\n\t\tseq_puts(seq,   \"Filter:     bssid\\n\");\n\tif (!priv->disable_beacon_filter)\n\t\tseq_puts(seq,   \"Filter:     beacons\\n\");\n\n\tif (priv->enable_beacon ||\n\t    priv->mode == NL80211_IFTYPE_AP ||\n\t    priv->mode == NL80211_IFTYPE_ADHOC ||\n\t    priv->mode == NL80211_IFTYPE_MESH_POINT ||\n\t    priv->mode == NL80211_IFTYPE_P2P_GO)\n\t\tseq_printf(seq, \"Beaconing:  %s\\n\",\n\t\t\t   priv->enable_beacon ?\n\t\t\t   \"enabled\" : \"disabled\");\n\n\tfor (i = 0; i < 4; ++i)\n\t\tseq_printf(seq, \"EDCA(%d):    %d, %d, %d, %d, %d\\n\", i,\n\t\t\t   priv->edca.params[i].cwmin,\n\t\t\t   priv->edca.params[i].cwmax,\n\t\t\t   priv->edca.params[i].aifns,\n\t\t\t   priv->edca.params[i].txop_limit,\n\t\t\t   priv->edca.params[i].max_rx_lifetime);\n\n\tif (priv->join_status == CW1200_JOIN_STATUS_STA) {\n\t\tstatic const char *pm_mode = \"unknown\";\n\t\tswitch (priv->powersave_mode.mode) {\n\t\tcase WSM_PSM_ACTIVE:\n\t\t\tpm_mode = \"off\";\n\t\t\tbreak;\n\t\tcase WSM_PSM_PS:\n\t\t\tpm_mode = \"on\";\n\t\t\tbreak;\n\t\tcase WSM_PSM_FAST_PS:\n\t\t\tpm_mode = \"dynamic\";\n\t\t\tbreak;\n\t\t}\n\t\tseq_printf(seq, \"Preamble:   %s\\n\",\n\t\t\t   cw1200_debug_preamble[priv->association_mode.preamble]);\n\t\tseq_printf(seq, \"AMPDU spcn: %d\\n\",\n\t\t\t   priv->association_mode.mpdu_start_spacing);\n\t\tseq_printf(seq, \"Basic rate: 0x%.8X\\n\",\n\t\t\t   le32_to_cpu(priv->association_mode.basic_rate_set));\n\t\tseq_printf(seq, \"Bss lost:   %d beacons\\n\",\n\t\t\t   priv->bss_params.beacon_lost_count);\n\t\tseq_printf(seq, \"AID:        %d\\n\",\n\t\t\t   priv->bss_params.aid);\n\t\tseq_printf(seq, \"Rates:      0x%.8X\\n\",\n\t\t\t   priv->bss_params.operational_rate_set);\n\t\tseq_printf(seq, \"Powersave:  %s\\n\", pm_mode);\n\t}\n\tseq_printf(seq, \"HT:         %s\\n\",\n\t\t   cw1200_is_ht(&priv->ht_info) ? \"on\" : \"off\");\n\tif (cw1200_is_ht(&priv->ht_info)) {\n\t\tseq_printf(seq, \"Greenfield: %s\\n\",\n\t\t\t   cw1200_ht_greenfield(&priv->ht_info) ? \"yes\" : \"no\");\n\t\tseq_printf(seq, \"AMPDU dens: %d\\n\",\n\t\t\t   cw1200_ht_ampdu_density(&priv->ht_info));\n\t}\n\tseq_printf(seq, \"RSSI thold: %d\\n\",\n\t\t   priv->cqm_rssi_thold);\n\tseq_printf(seq, \"RSSI hyst:  %d\\n\",\n\t\t   priv->cqm_rssi_hyst);\n\tseq_printf(seq, \"Long retr:  %d\\n\",\n\t\t   priv->long_frame_max_tx_count);\n\tseq_printf(seq, \"Short retr: %d\\n\",\n\t\t   priv->short_frame_max_tx_count);\n\tspin_lock_bh(&priv->tx_policy_cache.lock);\n\ti = 0;\n\tlist_for_each(item, &priv->tx_policy_cache.used)\n\t\t++i;\n\tspin_unlock_bh(&priv->tx_policy_cache.lock);\n\tseq_printf(seq, \"RC in use:  %d\\n\", i);\n\n\tseq_puts(seq, \"\\n\");\n\tfor (i = 0; i < 4; ++i) {\n\t\tcw1200_queue_status_show(seq, &priv->tx_queue[i]);\n\t\tseq_puts(seq, \"\\n\");\n\t}\n\n\tcw1200_debug_print_map(seq, priv, \"Link map:   \",\n\t\t\t       priv->link_id_map);\n\tcw1200_debug_print_map(seq, priv, \"Asleep map: \",\n\t\t\t       priv->sta_asleep_mask);\n\tcw1200_debug_print_map(seq, priv, \"PSPOLL map: \",\n\t\t\t       priv->pspoll_mask);\n\n\tseq_puts(seq, \"\\n\");\n\n\tfor (i = 0; i < CW1200_MAX_STA_IN_AP_MODE; ++i) {\n\t\tif (priv->link_id_db[i].status) {\n\t\t\tseq_printf(seq, \"Link %d:     %s, %pM\\n\",\n\t\t\t\t   i + 1,\n\t\t\t\t   cw1200_debug_link_id[priv->link_id_db[i].status],\n\t\t\t\t   priv->link_id_db[i].mac);\n\t\t}\n\t}\n\n\tseq_puts(seq, \"\\n\");\n\n\tseq_printf(seq, \"BH status:  %s\\n\",\n\t\t   atomic_read(&priv->bh_term) ? \"terminated\" : \"alive\");\n\tseq_printf(seq, \"Pending RX: %d\\n\",\n\t\t   atomic_read(&priv->bh_rx));\n\tseq_printf(seq, \"Pending TX: %d\\n\",\n\t\t   atomic_read(&priv->bh_tx));\n\tif (priv->bh_error)\n\t\tseq_printf(seq, \"BH errcode: %d\\n\",\n\t\t\t   priv->bh_error);\n\tseq_printf(seq, \"TX bufs:    %d x %d bytes\\n\",\n\t\t   priv->wsm_caps.input_buffers,\n\t\t   priv->wsm_caps.input_buffer_size);\n\tseq_printf(seq, \"Used bufs:  %d\\n\",\n\t\t   priv->hw_bufs_used);\n\tseq_printf(seq, \"Powermgmt:  %s\\n\",\n\t\t   priv->powersave_enabled ? \"on\" : \"off\");\n\tseq_printf(seq, \"Device:     %s\\n\",\n\t\t   priv->device_can_sleep ? \"asleep\" : \"awake\");\n\n\tspin_lock(&priv->wsm_cmd.lock);\n\tseq_printf(seq, \"WSM status: %s\\n\",\n\t\t   priv->wsm_cmd.done ? \"idle\" : \"active\");\n\tseq_printf(seq, \"WSM cmd:    0x%.4X (%td bytes)\\n\",\n\t\t   priv->wsm_cmd.cmd, priv->wsm_cmd.len);\n\tseq_printf(seq, \"WSM retval: %d\\n\",\n\t\t   priv->wsm_cmd.ret);\n\tspin_unlock(&priv->wsm_cmd.lock);\n\n\tseq_printf(seq, \"Datapath:   %s\\n\",\n\t\t   atomic_read(&priv->tx_lock) ? \"locked\" : \"unlocked\");\n\tif (atomic_read(&priv->tx_lock))\n\t\tseq_printf(seq, \"TXlock cnt: %d\\n\",\n\t\t\t   atomic_read(&priv->tx_lock));\n\n\tseq_printf(seq, \"TXed:       %d\\n\",\n\t\t   d->tx);\n\tseq_printf(seq, \"AGG TXed:   %d\\n\",\n\t\t   d->tx_agg);\n\tseq_printf(seq, \"MULTI TXed: %d (%d)\\n\",\n\t\t   d->tx_multi, d->tx_multi_frames);\n\tseq_printf(seq, \"RXed:       %d\\n\",\n\t\t   d->rx);\n\tseq_printf(seq, \"AGG RXed:   %d\\n\",\n\t\t   d->rx_agg);\n\tseq_printf(seq, \"TX miss:    %d\\n\",\n\t\t   d->tx_cache_miss);\n\tseq_printf(seq, \"TX align:   %d\\n\",\n\t\t   d->tx_align);\n\tseq_printf(seq, \"TX burst:   %d\\n\",\n\t\t   d->tx_burst);\n\tseq_printf(seq, \"TX TTL:     %d\\n\",\n\t\t   d->tx_ttl);\n\tseq_printf(seq, \"Scan:       %s\\n\",\n\t\t   atomic_read(&priv->scan.in_progress) ? \"active\" : \"idle\");\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(cw1200_status);\n\nstatic int cw1200_counters_show(struct seq_file *seq, void *v)\n{\n\tint ret;\n\tstruct cw1200_common *priv = seq->private;\n\tstruct wsm_mib_counters_table counters;\n\n\tret = wsm_get_counters_table(priv, &counters);\n\tif (ret)\n\t\treturn ret;\n\n#define PUT_COUNTER(tab, name) \\\n\tseq_printf(seq, \"%s:\" tab \"%d\\n\", #name, \\\n\t\t__le32_to_cpu(counters.name))\n\n\tPUT_COUNTER(\"\\t\\t\", plcp_errors);\n\tPUT_COUNTER(\"\\t\\t\", fcs_errors);\n\tPUT_COUNTER(\"\\t\\t\", tx_packets);\n\tPUT_COUNTER(\"\\t\\t\", rx_packets);\n\tPUT_COUNTER(\"\\t\\t\", rx_packet_errors);\n\tPUT_COUNTER(\"\\t\",   rx_decryption_failures);\n\tPUT_COUNTER(\"\\t\\t\", rx_mic_failures);\n\tPUT_COUNTER(\"\\t\",   rx_no_key_failures);\n\tPUT_COUNTER(\"\\t\",   tx_multicast_frames);\n\tPUT_COUNTER(\"\\t\",   tx_frames_success);\n\tPUT_COUNTER(\"\\t\",   tx_frame_failures);\n\tPUT_COUNTER(\"\\t\",   tx_frames_retried);\n\tPUT_COUNTER(\"\\t\",   tx_frames_multi_retried);\n\tPUT_COUNTER(\"\\t\",   rx_frame_duplicates);\n\tPUT_COUNTER(\"\\t\\t\", rts_success);\n\tPUT_COUNTER(\"\\t\\t\", rts_failures);\n\tPUT_COUNTER(\"\\t\\t\", ack_failures);\n\tPUT_COUNTER(\"\\t\",   rx_multicast_frames);\n\tPUT_COUNTER(\"\\t\",   rx_frames_success);\n\tPUT_COUNTER(\"\\t\",   rx_cmac_icv_errors);\n\tPUT_COUNTER(\"\\t\\t\", rx_cmac_replays);\n\tPUT_COUNTER(\"\\t\",   rx_mgmt_ccmp_replays);\n\n#undef PUT_COUNTER\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(cw1200_counters);\n\nstatic ssize_t cw1200_wsm_dumps(struct file *file,\n\tconst char __user *user_buf, size_t count, loff_t *ppos)\n{\n\tstruct cw1200_common *priv = file->private_data;\n\tchar buf[1];\n\n\tif (!count)\n\t\treturn -EINVAL;\n\tif (copy_from_user(buf, user_buf, 1))\n\t\treturn -EFAULT;\n\n\tif (buf[0] == '1')\n\t\tpriv->wsm_enable_wsm_dumps = 1;\n\telse\n\t\tpriv->wsm_enable_wsm_dumps = 0;\n\n\treturn count;\n}\n\nstatic const struct file_operations fops_wsm_dumps = {\n\t.open = simple_open,\n\t.write = cw1200_wsm_dumps,\n\t.llseek = default_llseek,\n};\n\nint cw1200_debug_init(struct cw1200_common *priv)\n{\n\tint ret = -ENOMEM;\n\tstruct cw1200_debug_priv *d = kzalloc(sizeof(struct cw1200_debug_priv),\n\t\t\tGFP_KERNEL);\n\tpriv->debug = d;\n\tif (!d)\n\t\treturn ret;\n\n\td->debugfs_phy = debugfs_create_dir(\"cw1200\",\n\t\t\t\t\t    priv->hw->wiphy->debugfsdir);\n\tdebugfs_create_file(\"status\", 0400, d->debugfs_phy, priv,\n\t\t\t    &cw1200_status_fops);\n\tdebugfs_create_file(\"counters\", 0400, d->debugfs_phy, priv,\n\t\t\t    &cw1200_counters_fops);\n\tdebugfs_create_file(\"wsm_dumps\", 0200, d->debugfs_phy, priv,\n\t\t\t    &fops_wsm_dumps);\n\n\treturn 0;\n}\n\nvoid cw1200_debug_release(struct cw1200_common *priv)\n{\n\tstruct cw1200_debug_priv *d = priv->debug;\n\tif (d) {\n\t\tdebugfs_remove_recursive(d->debugfs_phy);\n\t\tpriv->debug = NULL;\n\t\tkfree(d);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}