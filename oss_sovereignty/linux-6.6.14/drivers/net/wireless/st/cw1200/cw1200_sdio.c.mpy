{
  "module_name": "cw1200_sdio.c",
  "hash_id": "3e8078caf9a455f1acf537de0b4c77f6e583918aee6d2b33b8a987897a3dd550",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/st/cw1200/cw1200_sdio.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/gpio.h>\n#include <linux/delay.h>\n#include <linux/mmc/host.h>\n#include <linux/mmc/sdio_func.h>\n#include <linux/mmc/card.h>\n#include <linux/mmc/sdio.h>\n#include <linux/mmc/sdio_ids.h>\n#include <net/mac80211.h>\n\n#include \"cw1200.h\"\n#include \"hwbus.h\"\n#include <linux/platform_data/net-cw1200.h>\n#include \"hwio.h\"\n\nMODULE_AUTHOR(\"Dmitry Tarnyagin <dmitry.tarnyagin@lockless.no>\");\nMODULE_DESCRIPTION(\"mac80211 ST-Ericsson CW1200 SDIO driver\");\nMODULE_LICENSE(\"GPL\");\n\n#define SDIO_BLOCK_SIZE (512)\n\n \nstatic struct cw1200_platform_data_sdio sagrad_109x_evk_platform_data = {\n\t.ref_clk = 38400,\n\t.have_5ghz = false,\n\t.sdd_file = \"sdd_sagrad_1091_1098.bin\",\n};\n\n \nstatic struct cw1200_platform_data_sdio *global_plat_data = &sagrad_109x_evk_platform_data;\n\nvoid __init cw1200_sdio_set_platform_data(struct cw1200_platform_data_sdio *pdata)\n{\n\tglobal_plat_data = pdata;\n}\n\nstruct hwbus_priv {\n\tstruct sdio_func\t*func;\n\tstruct cw1200_common\t*core;\n\tconst struct cw1200_platform_data_sdio *pdata;\n};\n\nstatic const struct sdio_device_id cw1200_sdio_ids[] = {\n\t{ SDIO_DEVICE(SDIO_VENDOR_ID_STE, SDIO_DEVICE_ID_STE_CW1200) },\n\t{  \t\t\t},\n};\nMODULE_DEVICE_TABLE(sdio, cw1200_sdio_ids);\n\n \n\nstatic int cw1200_sdio_memcpy_fromio(struct hwbus_priv *self,\n\t\t\t\t     unsigned int addr,\n\t\t\t\t     void *dst, int count)\n{\n\treturn sdio_memcpy_fromio(self->func, dst, addr, count);\n}\n\nstatic int cw1200_sdio_memcpy_toio(struct hwbus_priv *self,\n\t\t\t\t   unsigned int addr,\n\t\t\t\t   const void *src, int count)\n{\n\treturn sdio_memcpy_toio(self->func, addr, (void *)src, count);\n}\n\nstatic void cw1200_sdio_lock(struct hwbus_priv *self)\n{\n\tsdio_claim_host(self->func);\n}\n\nstatic void cw1200_sdio_unlock(struct hwbus_priv *self)\n{\n\tsdio_release_host(self->func);\n}\n\nstatic void cw1200_sdio_irq_handler(struct sdio_func *func)\n{\n\tstruct hwbus_priv *self = sdio_get_drvdata(func);\n\n\t \n\tif (self->core)\n\t\tcw1200_irq_handler(self->core);\n}\n\nstatic irqreturn_t cw1200_gpio_hardirq(int irq, void *dev_id)\n{\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic irqreturn_t cw1200_gpio_irq(int irq, void *dev_id)\n{\n\tstruct hwbus_priv *self = dev_id;\n\n\tif (self->core) {\n\t\tcw1200_sdio_lock(self);\n\t\tcw1200_irq_handler(self->core);\n\t\tcw1200_sdio_unlock(self);\n\t\treturn IRQ_HANDLED;\n\t} else {\n\t\treturn IRQ_NONE;\n\t}\n}\n\nstatic int cw1200_request_irq(struct hwbus_priv *self)\n{\n\tint ret;\n\tu8 cccr;\n\n\tcccr = sdio_f0_readb(self->func, SDIO_CCCR_IENx, &ret);\n\tif (WARN_ON(ret))\n\t\tgoto err;\n\n\t \n\tcccr |= BIT(0);\n\n\t \n\tcccr |= BIT(self->func->num);\n\n\tsdio_f0_writeb(self->func, cccr, SDIO_CCCR_IENx, &ret);\n\tif (WARN_ON(ret))\n\t\tgoto err;\n\n\tret = enable_irq_wake(self->pdata->irq);\n\tif (WARN_ON(ret))\n\t\tgoto err;\n\n\t \n\tret =  request_threaded_irq(self->pdata->irq, cw1200_gpio_hardirq,\n\t\t\t\t    cw1200_gpio_irq,\n\t\t\t\t    IRQF_TRIGGER_HIGH | IRQF_ONESHOT,\n\t\t\t\t    \"cw1200_wlan_irq\", self);\n\tif (WARN_ON(ret))\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\treturn ret;\n}\n\nstatic int cw1200_sdio_irq_subscribe(struct hwbus_priv *self)\n{\n\tint ret = 0;\n\n\tpr_debug(\"SW IRQ subscribe\\n\");\n\tsdio_claim_host(self->func);\n\tif (self->pdata->irq)\n\t\tret = cw1200_request_irq(self);\n\telse\n\t\tret = sdio_claim_irq(self->func, cw1200_sdio_irq_handler);\n\n\tsdio_release_host(self->func);\n\treturn ret;\n}\n\nstatic int cw1200_sdio_irq_unsubscribe(struct hwbus_priv *self)\n{\n\tint ret = 0;\n\n\tpr_debug(\"SW IRQ unsubscribe\\n\");\n\n\tif (self->pdata->irq) {\n\t\tdisable_irq_wake(self->pdata->irq);\n\t\tfree_irq(self->pdata->irq, self);\n\t} else {\n\t\tsdio_claim_host(self->func);\n\t\tret = sdio_release_irq(self->func);\n\t\tsdio_release_host(self->func);\n\t}\n\treturn ret;\n}\n\nstatic int cw1200_sdio_off(const struct cw1200_platform_data_sdio *pdata)\n{\n\tif (pdata->reset) {\n\t\tgpio_set_value(pdata->reset, 0);\n\t\tmsleep(30);  \n\t\tgpio_free(pdata->reset);\n\t}\n\n\tif (pdata->power_ctrl)\n\t\tpdata->power_ctrl(pdata, false);\n\tif (pdata->clk_ctrl)\n\t\tpdata->clk_ctrl(pdata, false);\n\n\treturn 0;\n}\n\nstatic int cw1200_sdio_on(const struct cw1200_platform_data_sdio *pdata)\n{\n\t \n\tif (pdata->reset) {\n\t\tgpio_request(pdata->reset, \"cw1200_wlan_reset\");\n\t\tgpio_direction_output(pdata->reset, 0);\n\t}\n\tif (pdata->powerup) {\n\t\tgpio_request(pdata->powerup, \"cw1200_wlan_powerup\");\n\t\tgpio_direction_output(pdata->powerup, 0);\n\t}\n\tif (pdata->reset || pdata->powerup)\n\t\tmsleep(10);  \n\n\t \n\tif (pdata->power_ctrl) {\n\t\tif (pdata->power_ctrl(pdata, true)) {\n\t\t\tpr_err(\"power_ctrl() failed!\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t \n\tif (pdata->clk_ctrl) {\n\t\tif (pdata->clk_ctrl(pdata, true)) {\n\t\t\tpr_err(\"clk_ctrl() failed!\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tmsleep(10);  \n\t}\n\n\t \n\tif (pdata->powerup) {\n\t\tgpio_set_value(pdata->powerup, 1);\n\t\tmsleep(250);  \n\t}\n\t \n\tif (pdata->reset) {\n\t\tgpio_set_value(pdata->reset, 1);\n\t\tmsleep(50);  \n\t}\n\treturn 0;\n}\n\nstatic size_t cw1200_sdio_align_size(struct hwbus_priv *self, size_t size)\n{\n\tif (self->pdata->no_nptb)\n\t\tsize = round_up(size, SDIO_BLOCK_SIZE);\n\telse\n\t\tsize = sdio_align_size(self->func, size);\n\n\treturn size;\n}\n\nstatic int cw1200_sdio_pm(struct hwbus_priv *self, bool suspend)\n{\n\tint ret = 0;\n\n\tif (self->pdata->irq)\n\t\tret = irq_set_irq_wake(self->pdata->irq, suspend);\n\treturn ret;\n}\n\nstatic const struct hwbus_ops cw1200_sdio_hwbus_ops = {\n\t.hwbus_memcpy_fromio\t= cw1200_sdio_memcpy_fromio,\n\t.hwbus_memcpy_toio\t= cw1200_sdio_memcpy_toio,\n\t.lock\t\t\t= cw1200_sdio_lock,\n\t.unlock\t\t\t= cw1200_sdio_unlock,\n\t.align_size\t\t= cw1200_sdio_align_size,\n\t.power_mgmt\t\t= cw1200_sdio_pm,\n};\n\n \nstatic int cw1200_sdio_probe(struct sdio_func *func,\n\t\t\t     const struct sdio_device_id *id)\n{\n\tstruct hwbus_priv *self;\n\tint status;\n\n\tpr_info(\"cw1200_wlan_sdio: Probe called\\n\");\n\n\t \n\tif (func->num != 0x01)\n\t\treturn -ENODEV;\n\n\tself = kzalloc(sizeof(*self), GFP_KERNEL);\n\tif (!self) {\n\t\tpr_err(\"Can't allocate SDIO hwbus_priv.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfunc->card->quirks |= MMC_QUIRK_LENIENT_FN0;\n\n\tself->pdata = global_plat_data;  \n\tself->func = func;\n\tsdio_set_drvdata(func, self);\n\tsdio_claim_host(func);\n\tsdio_enable_func(func);\n\tsdio_release_host(func);\n\n\tstatus = cw1200_sdio_irq_subscribe(self);\n\n\tstatus = cw1200_core_probe(&cw1200_sdio_hwbus_ops,\n\t\t\t\t   self, &func->dev, &self->core,\n\t\t\t\t   self->pdata->ref_clk,\n\t\t\t\t   self->pdata->macaddr,\n\t\t\t\t   self->pdata->sdd_file,\n\t\t\t\t   self->pdata->have_5ghz);\n\tif (status) {\n\t\tcw1200_sdio_irq_unsubscribe(self);\n\t\tsdio_claim_host(func);\n\t\tsdio_disable_func(func);\n\t\tsdio_release_host(func);\n\t\tsdio_set_drvdata(func, NULL);\n\t\tkfree(self);\n\t}\n\n\treturn status;\n}\n\n \nstatic void cw1200_sdio_disconnect(struct sdio_func *func)\n{\n\tstruct hwbus_priv *self = sdio_get_drvdata(func);\n\n\tif (self) {\n\t\tcw1200_sdio_irq_unsubscribe(self);\n\t\tif (self->core) {\n\t\t\tcw1200_core_release(self->core);\n\t\t\tself->core = NULL;\n\t\t}\n\t\tsdio_claim_host(func);\n\t\tsdio_disable_func(func);\n\t\tsdio_release_host(func);\n\t\tsdio_set_drvdata(func, NULL);\n\t\tkfree(self);\n\t}\n}\n\n#ifdef CONFIG_PM\nstatic int cw1200_sdio_suspend(struct device *dev)\n{\n\tint ret;\n\tstruct sdio_func *func = dev_to_sdio_func(dev);\n\tstruct hwbus_priv *self = sdio_get_drvdata(func);\n\n\tif (!cw1200_can_suspend(self->core))\n\t\treturn -EAGAIN;\n\n\t \n\tret = sdio_set_host_pm_flags(func, MMC_PM_KEEP_POWER);\n\tif (ret)\n\t\tpr_err(\"Error setting SDIO pm flags: %i\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int cw1200_sdio_resume(struct device *dev)\n{\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops cw1200_pm_ops = {\n\t.suspend = cw1200_sdio_suspend,\n\t.resume = cw1200_sdio_resume,\n};\n#endif\n\nstatic struct sdio_driver sdio_driver = {\n\t.name\t\t= \"cw1200_wlan_sdio\",\n\t.id_table\t= cw1200_sdio_ids,\n\t.probe\t\t= cw1200_sdio_probe,\n\t.remove\t\t= cw1200_sdio_disconnect,\n#ifdef CONFIG_PM\n\t.drv = {\n\t\t.pm = &cw1200_pm_ops,\n\t}\n#endif\n};\n\n \nstatic int __init cw1200_sdio_init(void)\n{\n\tconst struct cw1200_platform_data_sdio *pdata;\n\tint ret;\n\n\t \n\tpdata = global_plat_data;\n\n\tif (cw1200_sdio_on(pdata)) {\n\t\tret = -1;\n\t\tgoto err;\n\t}\n\n\tret = sdio_register_driver(&sdio_driver);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tcw1200_sdio_off(pdata);\n\treturn ret;\n}\n\n \nstatic void __exit cw1200_sdio_exit(void)\n{\n\tconst struct cw1200_platform_data_sdio *pdata;\n\n\t \n\tpdata = global_plat_data;\n\tsdio_unregister_driver(&sdio_driver);\n\tcw1200_sdio_off(pdata);\n}\n\n\nmodule_init(cw1200_sdio_init);\nmodule_exit(cw1200_sdio_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}