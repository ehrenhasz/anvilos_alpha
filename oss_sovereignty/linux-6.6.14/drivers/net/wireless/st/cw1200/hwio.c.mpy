{
  "module_name": "hwio.c",
  "hash_id": "96bf6475ccc4fed13080c558587acb16e7d6f883e0b44d3b16c63f13a68eee37",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/st/cw1200/hwio.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n\n#include \"cw1200.h\"\n#include \"hwio.h\"\n#include \"hwbus.h\"\n\n  \n#define SPI_REG_ADDR_TO_SDIO(spi_reg_addr) ((spi_reg_addr) << 2)\n#define SDIO_ADDR17BIT(buf_id, mpf, rfu, reg_id_ofs) \\\n\t\t\t\t((((buf_id)    & 0x1F) << 7) \\\n\t\t\t\t| (((mpf)        & 1) << 6) \\\n\t\t\t\t| (((rfu)        & 1) << 5) \\\n\t\t\t\t| (((reg_id_ofs) & 0x1F) << 0))\n#define MAX_RETRY\t\t3\n\n\nstatic int __cw1200_reg_read(struct cw1200_common *priv, u16 addr,\n\t\t\t     void *buf, size_t buf_len, int buf_id)\n{\n\tu16 addr_sdio;\n\tu32 sdio_reg_addr_17bit;\n\n\t \n\tif (WARN_ON(((unsigned long)buf & 3) && (buf_len > 4))) {\n\t\tpr_err(\"buffer is not aligned.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\taddr_sdio = SPI_REG_ADDR_TO_SDIO(addr);\n\tsdio_reg_addr_17bit = SDIO_ADDR17BIT(buf_id, 0, 0, addr_sdio);\n\n\treturn priv->hwbus_ops->hwbus_memcpy_fromio(priv->hwbus_priv,\n\t\t\t\t\t\t  sdio_reg_addr_17bit,\n\t\t\t\t\t\t  buf, buf_len);\n}\n\nstatic int __cw1200_reg_write(struct cw1200_common *priv, u16 addr,\n\t\t\t\tconst void *buf, size_t buf_len, int buf_id)\n{\n\tu16 addr_sdio;\n\tu32 sdio_reg_addr_17bit;\n\n\t \n\taddr_sdio = SPI_REG_ADDR_TO_SDIO(addr);\n\tsdio_reg_addr_17bit = SDIO_ADDR17BIT(buf_id, 0, 0, addr_sdio);\n\n\treturn priv->hwbus_ops->hwbus_memcpy_toio(priv->hwbus_priv,\n\t\t\t\t\t\tsdio_reg_addr_17bit,\n\t\t\t\t\t\tbuf, buf_len);\n}\n\nstatic inline int __cw1200_reg_read_32(struct cw1200_common *priv,\n\t\t\t\t\tu16 addr, u32 *val)\n{\n\t__le32 tmp;\n\tint i = __cw1200_reg_read(priv, addr, &tmp, sizeof(tmp), 0);\n\t*val = le32_to_cpu(tmp);\n\treturn i;\n}\n\nstatic inline int __cw1200_reg_write_32(struct cw1200_common *priv,\n\t\t\t\t\tu16 addr, u32 val)\n{\n\t__le32 tmp = cpu_to_le32(val);\n\treturn __cw1200_reg_write(priv, addr, &tmp, sizeof(tmp), 0);\n}\n\nstatic inline int __cw1200_reg_read_16(struct cw1200_common *priv,\n\t\t\t\t\tu16 addr, u16 *val)\n{\n\t__le16 tmp;\n\tint i = __cw1200_reg_read(priv, addr, &tmp, sizeof(tmp), 0);\n\t*val = le16_to_cpu(tmp);\n\treturn i;\n}\n\nstatic inline int __cw1200_reg_write_16(struct cw1200_common *priv,\n\t\t\t\t\tu16 addr, u16 val)\n{\n\t__le16 tmp = cpu_to_le16(val);\n\treturn __cw1200_reg_write(priv, addr, &tmp, sizeof(tmp), 0);\n}\n\nint cw1200_reg_read(struct cw1200_common *priv, u16 addr, void *buf,\n\t\t\tsize_t buf_len)\n{\n\tint ret;\n\tpriv->hwbus_ops->lock(priv->hwbus_priv);\n\tret = __cw1200_reg_read(priv, addr, buf, buf_len, 0);\n\tpriv->hwbus_ops->unlock(priv->hwbus_priv);\n\treturn ret;\n}\n\nint cw1200_reg_write(struct cw1200_common *priv, u16 addr, const void *buf,\n\t\t\tsize_t buf_len)\n{\n\tint ret;\n\tpriv->hwbus_ops->lock(priv->hwbus_priv);\n\tret = __cw1200_reg_write(priv, addr, buf, buf_len, 0);\n\tpriv->hwbus_ops->unlock(priv->hwbus_priv);\n\treturn ret;\n}\n\nint cw1200_data_read(struct cw1200_common *priv, void *buf, size_t buf_len)\n{\n\tint ret, retry = 1;\n\tint buf_id_rx = priv->buf_id_rx;\n\n\tpriv->hwbus_ops->lock(priv->hwbus_priv);\n\n\twhile (retry <= MAX_RETRY) {\n\t\tret = __cw1200_reg_read(priv,\n\t\t\t\t\tST90TDS_IN_OUT_QUEUE_REG_ID, buf,\n\t\t\t\t\tbuf_len, buf_id_rx + 1);\n\t\tif (!ret) {\n\t\t\tbuf_id_rx = (buf_id_rx + 1) & 3;\n\t\t\tpriv->buf_id_rx = buf_id_rx;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tretry++;\n\t\t\tmdelay(1);\n\t\t\tpr_err(\"error :[%d]\\n\", ret);\n\t\t}\n\t}\n\n\tpriv->hwbus_ops->unlock(priv->hwbus_priv);\n\treturn ret;\n}\n\nint cw1200_data_write(struct cw1200_common *priv, const void *buf,\n\t\t\tsize_t buf_len)\n{\n\tint ret, retry = 1;\n\tint buf_id_tx = priv->buf_id_tx;\n\n\tpriv->hwbus_ops->lock(priv->hwbus_priv);\n\n\twhile (retry <= MAX_RETRY) {\n\t\tret = __cw1200_reg_write(priv,\n\t\t\t\t\t ST90TDS_IN_OUT_QUEUE_REG_ID, buf,\n\t\t\t\t\t buf_len, buf_id_tx);\n\t\tif (!ret) {\n\t\t\tbuf_id_tx = (buf_id_tx + 1) & 31;\n\t\t\tpriv->buf_id_tx = buf_id_tx;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tretry++;\n\t\t\tmdelay(1);\n\t\t\tpr_err(\"error :[%d]\\n\", ret);\n\t\t}\n\t}\n\n\tpriv->hwbus_ops->unlock(priv->hwbus_priv);\n\treturn ret;\n}\n\nint cw1200_indirect_read(struct cw1200_common *priv, u32 addr, void *buf,\n\t\t\t size_t buf_len, u32 prefetch, u16 port_addr)\n{\n\tu32 val32 = 0;\n\tint i, ret;\n\n\tif ((buf_len / 2) >= 0x1000) {\n\t\tpr_err(\"Can't read more than 0xfff words.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv->hwbus_ops->lock(priv->hwbus_priv);\n\t \n\tret = __cw1200_reg_write_32(priv, ST90TDS_SRAM_BASE_ADDR_REG_ID, addr);\n\tif (ret < 0) {\n\t\tpr_err(\"Can't write address register.\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tret = __cw1200_reg_read_32(priv, ST90TDS_CONFIG_REG_ID, &val32);\n\tif (ret < 0) {\n\t\tpr_err(\"Can't read config register.\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tret = __cw1200_reg_write_32(priv, ST90TDS_CONFIG_REG_ID,\n\t\t\t\t\tval32 | prefetch);\n\tif (ret < 0) {\n\t\tpr_err(\"Can't write prefetch bit.\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tfor (i = 0; i < 20; i++) {\n\t\tret = __cw1200_reg_read_32(priv, ST90TDS_CONFIG_REG_ID, &val32);\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"Can't check prefetch bit.\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (!(val32 & prefetch))\n\t\t\tbreak;\n\n\t\tmdelay(i);\n\t}\n\n\tif (val32 & prefetch) {\n\t\tpr_err(\"Prefetch bit is not cleared.\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tret = __cw1200_reg_read(priv, port_addr, buf, buf_len, 0);\n\tif (ret < 0) {\n\t\tpr_err(\"Can't read data port.\\n\");\n\t\tgoto out;\n\t}\n\nout:\n\tpriv->hwbus_ops->unlock(priv->hwbus_priv);\n\treturn ret;\n}\n\nint cw1200_apb_write(struct cw1200_common *priv, u32 addr, const void *buf,\n\t\t\tsize_t buf_len)\n{\n\tint ret;\n\n\tif ((buf_len / 2) >= 0x1000) {\n\t\tpr_err(\"Can't write more than 0xfff words.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv->hwbus_ops->lock(priv->hwbus_priv);\n\n\t \n\tret = __cw1200_reg_write_32(priv, ST90TDS_SRAM_BASE_ADDR_REG_ID, addr);\n\tif (ret < 0) {\n\t\tpr_err(\"Can't write address register.\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tret = __cw1200_reg_write(priv, ST90TDS_SRAM_DPORT_REG_ID,\n\t\t\t\t\tbuf, buf_len, 0);\n\tif (ret < 0) {\n\t\tpr_err(\"Can't write data port.\\n\");\n\t\tgoto out;\n\t}\n\nout:\n\tpriv->hwbus_ops->unlock(priv->hwbus_priv);\n\treturn ret;\n}\n\nint __cw1200_irq_enable(struct cw1200_common *priv, int enable)\n{\n\tu32 val32;\n\tu16 val16;\n\tint ret;\n\n\tif (HIF_8601_SILICON == priv->hw_type) {\n\t\tret = __cw1200_reg_read_32(priv, ST90TDS_CONFIG_REG_ID, &val32);\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"Can't read config register.\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (enable)\n\t\t\tval32 |= ST90TDS_CONF_IRQ_RDY_ENABLE;\n\t\telse\n\t\t\tval32 &= ~ST90TDS_CONF_IRQ_RDY_ENABLE;\n\n\t\tret = __cw1200_reg_write_32(priv, ST90TDS_CONFIG_REG_ID, val32);\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"Can't write config register.\\n\");\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tret = __cw1200_reg_read_16(priv, ST90TDS_CONFIG_REG_ID, &val16);\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"Can't read control register.\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (enable)\n\t\t\tval16 |= ST90TDS_CONT_IRQ_RDY_ENABLE;\n\t\telse\n\t\t\tval16 &= ~ST90TDS_CONT_IRQ_RDY_ENABLE;\n\n\t\tret = __cw1200_reg_write_16(priv, ST90TDS_CONFIG_REG_ID, val16);\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"Can't write control register.\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}