{
  "module_name": "fwio.c",
  "hash_id": "da8a59cca42489dfff17f6c42f7a4702b8d4e6d0689ffc10f9e2e8946ef01131",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/st/cw1200/fwio.c",
  "human_readable_source": "\n \n\n#include <linux/vmalloc.h>\n#include <linux/sched.h>\n#include <linux/firmware.h>\n\n#include \"cw1200.h\"\n#include \"fwio.h\"\n#include \"hwio.h\"\n#include \"hwbus.h\"\n#include \"bh.h\"\n\nstatic int cw1200_get_hw_type(u32 config_reg_val, int *major_revision)\n{\n\tint hw_type = -1;\n\tu32 silicon_type = (config_reg_val >> 24) & 0x7;\n\tu32 silicon_vers = (config_reg_val >> 31) & 0x1;\n\n\tswitch (silicon_type) {\n\tcase 0x00:\n\t\t*major_revision = 1;\n\t\thw_type = HIF_9000_SILICON_VERSATILE;\n\t\tbreak;\n\tcase 0x01:\n\tcase 0x02:  \n\tcase 0x04:  \n\t\t*major_revision = silicon_type;\n\t\tif (silicon_vers)\n\t\t\thw_type = HIF_8601_VERSATILE;\n\t\telse\n\t\t\thw_type = HIF_8601_SILICON;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn hw_type;\n}\n\nstatic int cw1200_load_firmware_cw1200(struct cw1200_common *priv)\n{\n\tint ret, block, num_blocks;\n\tunsigned i;\n\tu32 val32;\n\tu32 put = 0, get = 0;\n\tu8 *buf = NULL;\n\tconst char *fw_path;\n\tconst struct firmware *firmware = NULL;\n\n\t \n#define APB_WRITE(reg, val) \\\n\tdo { \\\n\t\tret = cw1200_apb_write_32(priv, CW1200_APB(reg), (val)); \\\n\t\tif (ret < 0) \\\n\t\t\tgoto exit; \\\n\t} while (0)\n#define APB_WRITE2(reg, val) \\\n\tdo { \\\n\t\tret = cw1200_apb_write_32(priv, CW1200_APB(reg), (val)); \\\n\t\tif (ret < 0) \\\n\t\t\tgoto free_buffer; \\\n\t} while (0)\n#define APB_READ(reg, val) \\\n\tdo { \\\n\t\tret = cw1200_apb_read_32(priv, CW1200_APB(reg), &(val)); \\\n\t\tif (ret < 0) \\\n\t\t\tgoto free_buffer; \\\n\t} while (0)\n#define REG_WRITE(reg, val) \\\n\tdo { \\\n\t\tret = cw1200_reg_write_32(priv, (reg), (val)); \\\n\t\tif (ret < 0) \\\n\t\t\tgoto exit; \\\n\t} while (0)\n#define REG_READ(reg, val) \\\n\tdo { \\\n\t\tret = cw1200_reg_read_32(priv, (reg), &(val)); \\\n\t\tif (ret < 0) \\\n\t\t\tgoto exit; \\\n\t} while (0)\n\n\tswitch (priv->hw_revision) {\n\tcase CW1200_HW_REV_CUT10:\n\t\tfw_path = FIRMWARE_CUT10;\n\t\tif (!priv->sdd_path)\n\t\t\tpriv->sdd_path = SDD_FILE_10;\n\t\tbreak;\n\tcase CW1200_HW_REV_CUT11:\n\t\tfw_path = FIRMWARE_CUT11;\n\t\tif (!priv->sdd_path)\n\t\t\tpriv->sdd_path = SDD_FILE_11;\n\t\tbreak;\n\tcase CW1200_HW_REV_CUT20:\n\t\tfw_path = FIRMWARE_CUT20;\n\t\tif (!priv->sdd_path)\n\t\t\tpriv->sdd_path = SDD_FILE_20;\n\t\tbreak;\n\tcase CW1200_HW_REV_CUT22:\n\t\tfw_path = FIRMWARE_CUT22;\n\t\tif (!priv->sdd_path)\n\t\t\tpriv->sdd_path = SDD_FILE_22;\n\t\tbreak;\n\tcase CW1X60_HW_REV:\n\t\tfw_path = FIRMWARE_CW1X60;\n\t\tif (!priv->sdd_path)\n\t\t\tpriv->sdd_path = SDD_FILE_CW1X60;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Invalid silicon revision %d.\\n\", priv->hw_revision);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tAPB_WRITE(DOWNLOAD_IMAGE_SIZE_REG, DOWNLOAD_ARE_YOU_HERE);\n\tAPB_WRITE(DOWNLOAD_PUT_REG, 0);\n\tAPB_WRITE(DOWNLOAD_GET_REG, 0);\n\tAPB_WRITE(DOWNLOAD_STATUS_REG, DOWNLOAD_PENDING);\n\tAPB_WRITE(DOWNLOAD_FLAGS_REG, 0);\n\n\t \n\tREG_WRITE(ST90TDS_SRAM_BASE_ADDR_REG_ID, 0xFFF20000);\n\tREG_WRITE(ST90TDS_AHB_DPORT_REG_ID, 0xEAFFFFFE);\n\n\t \n\tREG_READ(ST90TDS_CONFIG_REG_ID, val32);\n\tval32 &= ~ST90TDS_CONFIG_CPU_RESET_BIT;\n\tREG_WRITE(ST90TDS_CONFIG_REG_ID, val32);\n\n\t \n\tval32 &= ~ST90TDS_CONFIG_CPU_CLK_DIS_BIT;\n\tREG_WRITE(ST90TDS_CONFIG_REG_ID, val32);\n\n\t \n\tret = request_firmware(&firmware, fw_path, priv->pdev);\n\tif (ret) {\n\t\tpr_err(\"Can't load firmware file %s.\\n\", fw_path);\n\t\tgoto exit;\n\t}\n\n\tbuf = kmalloc(DOWNLOAD_BLOCK_SIZE, GFP_KERNEL | GFP_DMA);\n\tif (!buf) {\n\t\tpr_err(\"Can't allocate firmware load buffer.\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto firmware_release;\n\t}\n\n\t \n\tfor (i = 0; i < 100; i += 1 + i / 2) {\n\t\tAPB_READ(DOWNLOAD_IMAGE_SIZE_REG, val32);\n\t\tif (val32 == DOWNLOAD_I_AM_HERE)\n\t\t\tbreak;\n\t\tmdelay(i);\n\t}  \n\n\tif (val32 != DOWNLOAD_I_AM_HERE) {\n\t\tpr_err(\"Bootloader is not ready.\\n\");\n\t\tret = -ETIMEDOUT;\n\t\tgoto free_buffer;\n\t}\n\n\t \n\tnum_blocks = (firmware->size - 1) / DOWNLOAD_BLOCK_SIZE + 1;\n\n\t \n\tval32 = firmware->size;  \n\tAPB_WRITE2(DOWNLOAD_IMAGE_SIZE_REG, val32);\n\n\t \n\tfor (block = 0; block < num_blocks; block++) {\n\t\tsize_t tx_size;\n\t\tsize_t block_size;\n\n\t\t \n\t\tAPB_READ(DOWNLOAD_STATUS_REG, val32);\n\t\tif (val32 != DOWNLOAD_PENDING) {\n\t\t\tpr_err(\"Bootloader reported error %d.\\n\", val32);\n\t\t\tret = -EIO;\n\t\t\tgoto free_buffer;\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < 100; i++) {\n\t\t\tAPB_READ(DOWNLOAD_GET_REG, get);\n\t\t\tif ((put - get) <=\n\t\t\t    (DOWNLOAD_FIFO_SIZE - DOWNLOAD_BLOCK_SIZE))\n\t\t\t\tbreak;\n\t\t\tmdelay(i);\n\t\t}\n\n\t\tif ((put - get) > (DOWNLOAD_FIFO_SIZE - DOWNLOAD_BLOCK_SIZE)) {\n\t\t\tpr_err(\"Timeout waiting for FIFO.\\n\");\n\t\t\tret = -ETIMEDOUT;\n\t\t\tgoto free_buffer;\n\t\t}\n\n\t\t \n\t\ttx_size = block_size = min_t(size_t, firmware->size - put,\n\t\t\t\t\tDOWNLOAD_BLOCK_SIZE);\n\n\t\tmemcpy(buf, &firmware->data[put], block_size);\n\t\tif (block_size < DOWNLOAD_BLOCK_SIZE) {\n\t\t\tmemset(&buf[block_size], 0,\n\t\t\t       DOWNLOAD_BLOCK_SIZE - block_size);\n\t\t\ttx_size = DOWNLOAD_BLOCK_SIZE;\n\t\t}\n\n\t\t \n\t\tret = cw1200_apb_write(priv,\n\t\t\tCW1200_APB(DOWNLOAD_FIFO_OFFSET +\n\t\t\t\t   (put & (DOWNLOAD_FIFO_SIZE - 1))),\n\t\t\tbuf, tx_size);\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"Can't write firmware block @ %d!\\n\",\n\t\t\t       put & (DOWNLOAD_FIFO_SIZE - 1));\n\t\t\tgoto free_buffer;\n\t\t}\n\n\t\t \n\t\tput += block_size;\n\t\tAPB_WRITE2(DOWNLOAD_PUT_REG, put);\n\t}  \n\n\t \n\tfor (i = 0; i < 300; i += 1 + i / 2) {\n\t\tAPB_READ(DOWNLOAD_STATUS_REG, val32);\n\t\tif (val32 != DOWNLOAD_PENDING)\n\t\t\tbreak;\n\t\tmdelay(i);\n\t}\n\tif (val32 != DOWNLOAD_SUCCESS) {\n\t\tpr_err(\"Wait for download completion failed: 0x%.8X\\n\", val32);\n\t\tret = -ETIMEDOUT;\n\t\tgoto free_buffer;\n\t} else {\n\t\tpr_info(\"Firmware download completed.\\n\");\n\t\tret = 0;\n\t}\n\nfree_buffer:\n\tkfree(buf);\nfirmware_release:\n\trelease_firmware(firmware);\nexit:\n\treturn ret;\n\n#undef APB_WRITE\n#undef APB_WRITE2\n#undef APB_READ\n#undef REG_WRITE\n#undef REG_READ\n}\n\n\nstatic int config_reg_read(struct cw1200_common *priv, u32 *val)\n{\n\tswitch (priv->hw_type) {\n\tcase HIF_9000_SILICON_VERSATILE: {\n\t\tu16 val16;\n\t\tint ret = cw1200_reg_read_16(priv,\n\t\t\t\t\t     ST90TDS_CONFIG_REG_ID,\n\t\t\t\t\t     &val16);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t*val = val16;\n\t\treturn 0;\n\t}\n\tcase HIF_8601_VERSATILE:\n\tcase HIF_8601_SILICON:\n\tdefault:\n\t\tcw1200_reg_read_32(priv, ST90TDS_CONFIG_REG_ID, val);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int config_reg_write(struct cw1200_common *priv, u32 val)\n{\n\tswitch (priv->hw_type) {\n\tcase HIF_9000_SILICON_VERSATILE:\n\t\treturn cw1200_reg_write_16(priv,\n\t\t\t\t\t   ST90TDS_CONFIG_REG_ID,\n\t\t\t\t\t   (u16)val);\n\tcase HIF_8601_VERSATILE:\n\tcase HIF_8601_SILICON:\n\tdefault:\n\t\treturn cw1200_reg_write_32(priv, ST90TDS_CONFIG_REG_ID, val);\n\t}\n\treturn 0;\n}\n\nint cw1200_load_firmware(struct cw1200_common *priv)\n{\n\tint ret;\n\tint i;\n\tu32 val32;\n\tu16 val16;\n\tint major_revision = -1;\n\n\t \n\tret = cw1200_reg_read_32(priv, ST90TDS_CONFIG_REG_ID, &val32);\n\tif (ret < 0) {\n\t\tpr_err(\"Can't read config register.\\n\");\n\t\tgoto out;\n\t}\n\n\tif (val32 == 0 || val32 == 0xffffffff) {\n\t\tpr_err(\"Bad config register value (0x%08x)\\n\", val32);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tret = cw1200_get_hw_type(val32, &major_revision);\n\tif (ret < 0) {\n\t\tpr_err(\"Can't deduce hardware type.\\n\");\n\t\tgoto out;\n\t}\n\tpriv->hw_type = ret;\n\n\t \n\tret = cw1200_reg_write_32(priv, ST90TDS_TSET_GEN_R_W_REG_ID,\n\t\t\t\t  cw1200_dpll_from_clk(priv->hw_refclk));\n\tif (ret < 0) {\n\t\tpr_err(\"Can't write DPLL register.\\n\");\n\t\tgoto out;\n\t}\n\n\tmsleep(20);\n\n\tret = cw1200_reg_read_32(priv,\n\t\tST90TDS_TSET_GEN_R_W_REG_ID, &val32);\n\tif (ret < 0) {\n\t\tpr_err(\"Can't read DPLL register.\\n\");\n\t\tgoto out;\n\t}\n\n\tif (val32 != cw1200_dpll_from_clk(priv->hw_refclk)) {\n\t\tpr_err(\"Unable to initialise DPLL register. Wrote 0x%.8X, Read 0x%.8X.\\n\",\n\t\t       cw1200_dpll_from_clk(priv->hw_refclk), val32);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\tret = cw1200_reg_read_16(priv, ST90TDS_CONTROL_REG_ID, &val16);\n\tif (ret < 0) {\n\t\tpr_err(\"set_wakeup: can't read control register.\\n\");\n\t\tgoto out;\n\t}\n\n\tret = cw1200_reg_write_16(priv, ST90TDS_CONTROL_REG_ID,\n\t\tval16 | ST90TDS_CONT_WUP_BIT);\n\tif (ret < 0) {\n\t\tpr_err(\"set_wakeup: can't write control register.\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tfor (i = 0; i < 300; i += (1 + i / 2)) {\n\t\tret = cw1200_reg_read_16(priv,\n\t\t\tST90TDS_CONTROL_REG_ID, &val16);\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"wait_for_wakeup: can't read control register.\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (val16 & ST90TDS_CONT_RDY_BIT)\n\t\t\tbreak;\n\n\t\tmsleep(i);\n\t}\n\n\tif ((val16 & ST90TDS_CONT_RDY_BIT) == 0) {\n\t\tpr_err(\"wait_for_wakeup: device is not responding.\\n\");\n\t\tret = -ETIMEDOUT;\n\t\tgoto out;\n\t}\n\n\tswitch (major_revision) {\n\tcase 1:\n\t\t \n\t\tret = cw1200_ahb_read_32(priv, CW1200_CUT_ID_ADDR, &val32);\n\t\tif (ret) {\n\t\t\tpr_err(\"HW detection: can't read CUT ID.\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tswitch (val32) {\n\t\tcase CW1200_CUT_11_ID_STR:\n\t\t\tpr_info(\"CW1x00 Cut 1.1 silicon detected.\\n\");\n\t\t\tpriv->hw_revision = CW1200_HW_REV_CUT11;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_info(\"CW1x00 Cut 1.0 silicon detected.\\n\");\n\t\t\tpriv->hw_revision = CW1200_HW_REV_CUT10;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tpriv->ba_rx_tid_mask = 0;\n\t\tpriv->ba_tx_tid_mask = 0;\n\t\tbreak;\n\tcase 2: {\n\t\tu32 ar1, ar2, ar3;\n\t\tret = cw1200_ahb_read_32(priv, CW1200_CUT2_ID_ADDR, &ar1);\n\t\tif (ret) {\n\t\t\tpr_err(\"(1) HW detection: can't read CUT ID\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tret = cw1200_ahb_read_32(priv, CW1200_CUT2_ID_ADDR + 4, &ar2);\n\t\tif (ret) {\n\t\t\tpr_err(\"(2) HW detection: can't read CUT ID.\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = cw1200_ahb_read_32(priv, CW1200_CUT2_ID_ADDR + 8, &ar3);\n\t\tif (ret) {\n\t\t\tpr_err(\"(3) HW detection: can't read CUT ID.\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (ar1 == CW1200_CUT_22_ID_STR1 &&\n\t\t    ar2 == CW1200_CUT_22_ID_STR2 &&\n\t\t    ar3 == CW1200_CUT_22_ID_STR3) {\n\t\t\tpr_info(\"CW1x00 Cut 2.2 silicon detected.\\n\");\n\t\t\tpriv->hw_revision = CW1200_HW_REV_CUT22;\n\t\t} else {\n\t\t\tpr_info(\"CW1x00 Cut 2.0 silicon detected.\\n\");\n\t\t\tpriv->hw_revision = CW1200_HW_REV_CUT20;\n\t\t}\n\t\tbreak;\n\t}\n\tcase 4:\n\t\tpr_info(\"CW1x60 silicon detected.\\n\");\n\t\tpriv->hw_revision = CW1X60_HW_REV;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unsupported silicon major revision %d.\\n\",\n\t\t       major_revision);\n\t\tret = -ENOTSUPP;\n\t\tgoto out;\n\t}\n\n\t \n\tret = config_reg_read(priv, &val32);\n\tif (ret < 0) {\n\t\tpr_err(\"Can't read config register.\\n\");\n\t\tgoto out;\n\t}\n\n\tif (!(val32 & ST90TDS_CONFIG_ACCESS_MODE_BIT)) {\n\t\tpr_err(\"Device is already in QUEUE mode!\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tswitch (priv->hw_type)  {\n\tcase HIF_8601_SILICON:\n\t\tif (priv->hw_revision == CW1X60_HW_REV) {\n\t\t\tpr_err(\"Can't handle CW1160/1260 firmware load yet.\\n\");\n\t\t\tret = -ENOTSUPP;\n\t\t\tgoto out;\n\t\t}\n\t\tret = cw1200_load_firmware_cw1200(priv);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Can't perform firmware load for hw type %d.\\n\",\n\t\t       priv->hw_type);\n\t\tret = -ENOTSUPP;\n\t\tgoto out;\n\t}\n\tif (ret < 0) {\n\t\tpr_err(\"Firmware load error.\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tpriv->hwbus_ops->lock(priv->hwbus_priv);\n\tret = __cw1200_irq_enable(priv, 1);\n\tpriv->hwbus_ops->unlock(priv->hwbus_priv);\n\tif (ret < 0)\n\t\tgoto unsubscribe;\n\n\t \n\tret = config_reg_read(priv, &val32);\n\tif (ret < 0) {\n\t\tpr_err(\"Can't read config register.\\n\");\n\t\tgoto unsubscribe;\n\t}\n\tret = config_reg_write(priv, val32 & ~ST90TDS_CONFIG_ACCESS_MODE_BIT);\n\tif (ret < 0) {\n\t\tpr_err(\"Can't write config register.\\n\");\n\t\tgoto unsubscribe;\n\t}\n\n\t \n\tmdelay(10);\n\tconfig_reg_read(priv, &val32);\n\nout:\n\treturn ret;\n\nunsubscribe:\n\t \n\tpriv->hwbus_ops->lock(priv->hwbus_priv);\n\tret = __cw1200_irq_enable(priv, 0);\n\tpriv->hwbus_ops->unlock(priv->hwbus_priv);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}