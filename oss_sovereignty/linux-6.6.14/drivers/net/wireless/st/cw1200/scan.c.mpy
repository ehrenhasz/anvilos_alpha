{
  "module_name": "scan.c",
  "hash_id": "3d770377f0e61caf331f562272415bfb2333407b45bc7a3bd056a9ad62e7d23f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/st/cw1200/scan.c",
  "human_readable_source": "\n \n\n#include <linux/sched.h>\n#include \"cw1200.h\"\n#include \"scan.h\"\n#include \"sta.h\"\n#include \"pm.h\"\n\nstatic void cw1200_scan_restart_delayed(struct cw1200_common *priv);\n\nstatic int cw1200_scan_start(struct cw1200_common *priv, struct wsm_scan *scan)\n{\n\tint ret, i;\n\tint tmo = 2000;\n\n\tswitch (priv->join_status) {\n\tcase CW1200_JOIN_STATUS_PRE_STA:\n\tcase CW1200_JOIN_STATUS_JOINING:\n\t\treturn -EBUSY;\n\tdefault:\n\t\tbreak;\n\t}\n\n\twiphy_dbg(priv->hw->wiphy, \"[SCAN] hw req, type %d, %d channels, flags: 0x%x.\\n\",\n\t\t  scan->type, scan->num_channels, scan->flags);\n\n\tfor (i = 0; i < scan->num_channels; ++i)\n\t\ttmo += scan->ch[i].max_chan_time + 10;\n\n\tcancel_delayed_work_sync(&priv->clear_recent_scan_work);\n\tatomic_set(&priv->scan.in_progress, 1);\n\tatomic_set(&priv->recent_scan, 1);\n\tcw1200_pm_stay_awake(&priv->pm_state, msecs_to_jiffies(tmo));\n\tqueue_delayed_work(priv->workqueue, &priv->scan.timeout,\n\t\t\t   msecs_to_jiffies(tmo));\n\tret = wsm_scan(priv, scan);\n\tif (ret) {\n\t\tatomic_set(&priv->scan.in_progress, 0);\n\t\tcancel_delayed_work_sync(&priv->scan.timeout);\n\t\tcw1200_scan_restart_delayed(priv);\n\t}\n\treturn ret;\n}\n\nint cw1200_hw_scan(struct ieee80211_hw *hw,\n\t\t   struct ieee80211_vif *vif,\n\t\t   struct ieee80211_scan_request *hw_req)\n{\n\tstruct cw1200_common *priv = hw->priv;\n\tstruct cfg80211_scan_request *req = &hw_req->req;\n\tstruct wsm_template_frame frame = {\n\t\t.frame_type = WSM_FRAME_TYPE_PROBE_REQUEST,\n\t};\n\tint i, ret;\n\n\tif (!priv->vif)\n\t\treturn -EINVAL;\n\n\t \n\tif (priv->join_status == CW1200_JOIN_STATUS_AP)\n\t\treturn -EOPNOTSUPP;\n\n\tif (req->n_ssids == 1 && !req->ssids[0].ssid_len)\n\t\treq->n_ssids = 0;\n\n\twiphy_dbg(hw->wiphy, \"[SCAN] Scan request for %d SSIDs.\\n\",\n\t\t  req->n_ssids);\n\n\tif (req->n_ssids > WSM_SCAN_MAX_NUM_OF_SSIDS)\n\t\treturn -EINVAL;\n\n\tframe.skb = ieee80211_probereq_get(hw, priv->vif->addr, NULL, 0,\n\t\treq->ie_len);\n\tif (!frame.skb)\n\t\treturn -ENOMEM;\n\n\tif (req->ie_len)\n\t\tskb_put_data(frame.skb, req->ie, req->ie_len);\n\n\t \n\tdown(&priv->scan.lock);\n\tmutex_lock(&priv->conf_mutex);\n\n\tret = wsm_set_template_frame(priv, &frame);\n\tif (!ret) {\n\t\t \n\t\tret = wsm_set_probe_responder(priv, true);\n\t}\n\tif (ret) {\n\t\tmutex_unlock(&priv->conf_mutex);\n\t\tup(&priv->scan.lock);\n\t\tdev_kfree_skb(frame.skb);\n\t\treturn ret;\n\t}\n\n\twsm_lock_tx(priv);\n\n\tBUG_ON(priv->scan.req);\n\tpriv->scan.req = req;\n\tpriv->scan.n_ssids = 0;\n\tpriv->scan.status = 0;\n\tpriv->scan.begin = &req->channels[0];\n\tpriv->scan.curr = priv->scan.begin;\n\tpriv->scan.end = &req->channels[req->n_channels];\n\tpriv->scan.output_power = priv->output_power;\n\n\tfor (i = 0; i < req->n_ssids; ++i) {\n\t\tstruct wsm_ssid *dst = &priv->scan.ssids[priv->scan.n_ssids];\n\t\tmemcpy(&dst->ssid[0], req->ssids[i].ssid, sizeof(dst->ssid));\n\t\tdst->length = req->ssids[i].ssid_len;\n\t\t++priv->scan.n_ssids;\n\t}\n\n\tmutex_unlock(&priv->conf_mutex);\n\tdev_kfree_skb(frame.skb);\n\tqueue_work(priv->workqueue, &priv->scan.work);\n\treturn 0;\n}\n\nvoid cw1200_scan_work(struct work_struct *work)\n{\n\tstruct cw1200_common *priv = container_of(work, struct cw1200_common,\n\t\t\t\t\t\t\tscan.work);\n\tstruct ieee80211_channel **it;\n\tstruct wsm_scan scan = {\n\t\t.type = WSM_SCAN_TYPE_FOREGROUND,\n\t\t.flags = WSM_SCAN_FLAG_SPLIT_METHOD,\n\t};\n\tbool first_run = (priv->scan.begin == priv->scan.curr &&\n\t\t\t  priv->scan.begin != priv->scan.end);\n\tint i;\n\n\tif (first_run) {\n\t\t \n\t\tif (cancel_delayed_work_sync(&priv->join_timeout) > 0)\n\t\t\tcw1200_join_timeout(&priv->join_timeout.work);\n\t}\n\n\tmutex_lock(&priv->conf_mutex);\n\n\tif (first_run) {\n\t\tif (priv->join_status == CW1200_JOIN_STATUS_STA &&\n\t\t    !(priv->powersave_mode.mode & WSM_PSM_PS)) {\n\t\t\tstruct wsm_set_pm pm = priv->powersave_mode;\n\t\t\tpm.mode = WSM_PSM_PS;\n\t\t\tcw1200_set_pm(priv, &pm);\n\t\t} else if (priv->join_status == CW1200_JOIN_STATUS_MONITOR) {\n\t\t\t \n\t\t\tcw1200_disable_listening(priv);\n\t\t}\n\t}\n\n\tif (!priv->scan.req || (priv->scan.curr == priv->scan.end)) {\n\t\tstruct cfg80211_scan_info info = {\n\t\t\t.aborted = priv->scan.status ? 1 : 0,\n\t\t};\n\n\t\tif (priv->scan.output_power != priv->output_power)\n\t\t\twsm_set_output_power(priv, priv->output_power * 10);\n\t\tif (priv->join_status == CW1200_JOIN_STATUS_STA &&\n\t\t    !(priv->powersave_mode.mode & WSM_PSM_PS))\n\t\t\tcw1200_set_pm(priv, &priv->powersave_mode);\n\n\t\tif (priv->scan.status < 0)\n\t\t\twiphy_warn(priv->hw->wiphy,\n\t\t\t\t   \"[SCAN] Scan failed (%d).\\n\",\n\t\t\t\t   priv->scan.status);\n\t\telse if (priv->scan.req)\n\t\t\twiphy_dbg(priv->hw->wiphy,\n\t\t\t\t  \"[SCAN] Scan completed.\\n\");\n\t\telse\n\t\t\twiphy_dbg(priv->hw->wiphy,\n\t\t\t\t  \"[SCAN] Scan canceled.\\n\");\n\n\t\tpriv->scan.req = NULL;\n\t\tcw1200_scan_restart_delayed(priv);\n\t\twsm_unlock_tx(priv);\n\t\tmutex_unlock(&priv->conf_mutex);\n\t\tieee80211_scan_completed(priv->hw, &info);\n\t\tup(&priv->scan.lock);\n\t\treturn;\n\t} else {\n\t\tstruct ieee80211_channel *first = *priv->scan.curr;\n\t\tfor (it = priv->scan.curr + 1, i = 1;\n\t\t     it != priv->scan.end && i < WSM_SCAN_MAX_NUM_OF_CHANNELS;\n\t\t     ++it, ++i) {\n\t\t\tif ((*it)->band != first->band)\n\t\t\t\tbreak;\n\t\t\tif (((*it)->flags ^ first->flags) &\n\t\t\t\t\tIEEE80211_CHAN_NO_IR)\n\t\t\t\tbreak;\n\t\t\tif (!(first->flags & IEEE80211_CHAN_NO_IR) &&\n\t\t\t    (*it)->max_power != first->max_power)\n\t\t\t\tbreak;\n\t\t}\n\t\tscan.band = first->band;\n\n\t\tif (priv->scan.req->no_cck)\n\t\t\tscan.max_tx_rate = WSM_TRANSMIT_RATE_6;\n\t\telse\n\t\t\tscan.max_tx_rate = WSM_TRANSMIT_RATE_1;\n\t\tscan.num_probes =\n\t\t\t(first->flags & IEEE80211_CHAN_NO_IR) ? 0 : 2;\n\t\tscan.num_ssids = priv->scan.n_ssids;\n\t\tscan.ssids = &priv->scan.ssids[0];\n\t\tscan.num_channels = it - priv->scan.curr;\n\t\t \n\t\tscan.probe_delay = 100;\n\t\t \n\t\tif (priv->join_status == CW1200_JOIN_STATUS_STA) {\n\t\t\tscan.type = WSM_SCAN_TYPE_BACKGROUND;\n\t\t\tscan.flags = WSM_SCAN_FLAG_FORCE_BACKGROUND;\n\t\t}\n\t\tscan.ch = kcalloc(it - priv->scan.curr,\n\t\t\t\t  sizeof(struct wsm_scan_ch),\n\t\t\t\t  GFP_KERNEL);\n\t\tif (!scan.ch) {\n\t\t\tpriv->scan.status = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t\tfor (i = 0; i < scan.num_channels; ++i) {\n\t\t\tscan.ch[i].number = priv->scan.curr[i]->hw_value;\n\t\t\tif (priv->scan.curr[i]->flags & IEEE80211_CHAN_NO_IR) {\n\t\t\t\tscan.ch[i].min_chan_time = 50;\n\t\t\t\tscan.ch[i].max_chan_time = 100;\n\t\t\t} else {\n\t\t\t\tscan.ch[i].min_chan_time = 10;\n\t\t\t\tscan.ch[i].max_chan_time = 25;\n\t\t\t}\n\t\t}\n\t\tif (!(first->flags & IEEE80211_CHAN_NO_IR) &&\n\t\t    priv->scan.output_power != first->max_power) {\n\t\t\tpriv->scan.output_power = first->max_power;\n\t\t\twsm_set_output_power(priv,\n\t\t\t\t\t     priv->scan.output_power * 10);\n\t\t}\n\t\tpriv->scan.status = cw1200_scan_start(priv, &scan);\n\t\tkfree(scan.ch);\n\t\tif (priv->scan.status)\n\t\t\tgoto fail;\n\t\tpriv->scan.curr = it;\n\t}\n\tmutex_unlock(&priv->conf_mutex);\n\treturn;\n\nfail:\n\tpriv->scan.curr = priv->scan.end;\n\tmutex_unlock(&priv->conf_mutex);\n\tqueue_work(priv->workqueue, &priv->scan.work);\n\treturn;\n}\n\nstatic void cw1200_scan_restart_delayed(struct cw1200_common *priv)\n{\n\t \n\tif (priv->join_status == CW1200_JOIN_STATUS_MONITOR) {\n\t\tcw1200_enable_listening(priv);\n\t\tcw1200_update_filtering(priv);\n\t}\n\n\tif (priv->delayed_unjoin) {\n\t\tpriv->delayed_unjoin = false;\n\t\tif (queue_work(priv->workqueue, &priv->unjoin_work) <= 0)\n\t\t\twsm_unlock_tx(priv);\n\t} else if (priv->delayed_link_loss) {\n\t\t\twiphy_dbg(priv->hw->wiphy, \"[CQM] Requeue BSS loss.\\n\");\n\t\t\tpriv->delayed_link_loss = 0;\n\t\t\tcw1200_cqm_bssloss_sm(priv, 1, 0, 0);\n\t}\n}\n\nstatic void cw1200_scan_complete(struct cw1200_common *priv)\n{\n\tqueue_delayed_work(priv->workqueue, &priv->clear_recent_scan_work, HZ);\n\tif (priv->scan.direct_probe) {\n\t\twiphy_dbg(priv->hw->wiphy, \"[SCAN] Direct probe complete.\\n\");\n\t\tcw1200_scan_restart_delayed(priv);\n\t\tpriv->scan.direct_probe = 0;\n\t\tup(&priv->scan.lock);\n\t\twsm_unlock_tx(priv);\n\t} else {\n\t\tcw1200_scan_work(&priv->scan.work);\n\t}\n}\n\nvoid cw1200_scan_failed_cb(struct cw1200_common *priv)\n{\n\tif (priv->mode == NL80211_IFTYPE_UNSPECIFIED)\n\t\t \n\t\treturn;\n\n\tif (cancel_delayed_work_sync(&priv->scan.timeout) > 0) {\n\t\tpriv->scan.status = -EIO;\n\t\tqueue_delayed_work(priv->workqueue, &priv->scan.timeout, 0);\n\t}\n}\n\n\nvoid cw1200_scan_complete_cb(struct cw1200_common *priv,\n\t\t\t\tstruct wsm_scan_complete *arg)\n{\n\tif (priv->mode == NL80211_IFTYPE_UNSPECIFIED)\n\t\t \n\t\treturn;\n\n\tif (cancel_delayed_work_sync(&priv->scan.timeout) > 0) {\n\t\tpriv->scan.status = 1;\n\t\tqueue_delayed_work(priv->workqueue, &priv->scan.timeout, 0);\n\t}\n}\n\nvoid cw1200_clear_recent_scan_work(struct work_struct *work)\n{\n\tstruct cw1200_common *priv =\n\t\tcontainer_of(work, struct cw1200_common,\n\t\t\t     clear_recent_scan_work.work);\n\tatomic_xchg(&priv->recent_scan, 0);\n}\n\nvoid cw1200_scan_timeout(struct work_struct *work)\n{\n\tstruct cw1200_common *priv =\n\t\tcontainer_of(work, struct cw1200_common, scan.timeout.work);\n\tif (atomic_xchg(&priv->scan.in_progress, 0)) {\n\t\tif (priv->scan.status > 0) {\n\t\t\tpriv->scan.status = 0;\n\t\t} else if (!priv->scan.status) {\n\t\t\twiphy_warn(priv->hw->wiphy,\n\t\t\t\t   \"Timeout waiting for scan complete notification.\\n\");\n\t\t\tpriv->scan.status = -ETIMEDOUT;\n\t\t\tpriv->scan.curr = priv->scan.end;\n\t\t\twsm_stop_scan(priv);\n\t\t}\n\t\tcw1200_scan_complete(priv);\n\t}\n}\n\nvoid cw1200_probe_work(struct work_struct *work)\n{\n\tstruct cw1200_common *priv =\n\t\tcontainer_of(work, struct cw1200_common, scan.probe_work.work);\n\tu8 queue_id = cw1200_queue_get_queue_id(priv->pending_frame_id);\n\tstruct cw1200_queue *queue = &priv->tx_queue[queue_id];\n\tconst struct cw1200_txpriv *txpriv;\n\tstruct wsm_tx *wsm;\n\tstruct wsm_template_frame frame = {\n\t\t.frame_type = WSM_FRAME_TYPE_PROBE_REQUEST,\n\t};\n\tstruct wsm_ssid ssids[1] = {{\n\t\t.length = 0,\n\t} };\n\tstruct wsm_scan_ch ch[1] = {{\n\t\t.min_chan_time = 0,\n\t\t.max_chan_time = 10,\n\t} };\n\tstruct wsm_scan scan = {\n\t\t.type = WSM_SCAN_TYPE_FOREGROUND,\n\t\t.num_probes = 1,\n\t\t.probe_delay = 0,\n\t\t.num_channels = 1,\n\t\t.ssids = ssids,\n\t\t.ch = ch,\n\t};\n\tu8 *ies;\n\tsize_t ies_len;\n\tint ret;\n\n\twiphy_dbg(priv->hw->wiphy, \"[SCAN] Direct probe work.\\n\");\n\n\tmutex_lock(&priv->conf_mutex);\n\tif (down_trylock(&priv->scan.lock)) {\n\t\t \n\t\tschedule();\n\t\tqueue_delayed_work(priv->workqueue, &priv->scan.probe_work,\n\t\t\t\t   msecs_to_jiffies(100));\n\t\tmutex_unlock(&priv->conf_mutex);\n\t\treturn;\n\t}\n\n\t \n\tif (cw1200_queue_get_skb(queue,\tpriv->pending_frame_id,\n\t\t\t\t &frame.skb, &txpriv)) {\n\t\tup(&priv->scan.lock);\n\t\tmutex_unlock(&priv->conf_mutex);\n\t\twsm_unlock_tx(priv);\n\t\treturn;\n\t}\n\twsm = (struct wsm_tx *)frame.skb->data;\n\tscan.max_tx_rate = wsm->max_tx_rate;\n\tscan.band = (priv->channel->band == NL80211_BAND_5GHZ) ?\n\t\tWSM_PHY_BAND_5G : WSM_PHY_BAND_2_4G;\n\tif (priv->join_status == CW1200_JOIN_STATUS_STA ||\n\t    priv->join_status == CW1200_JOIN_STATUS_IBSS) {\n\t\tscan.type = WSM_SCAN_TYPE_BACKGROUND;\n\t\tscan.flags = WSM_SCAN_FLAG_FORCE_BACKGROUND;\n\t}\n\tch[0].number = priv->channel->hw_value;\n\n\tskb_pull(frame.skb, txpriv->offset);\n\n\ties = &frame.skb->data[sizeof(struct ieee80211_hdr_3addr)];\n\ties_len = frame.skb->len - sizeof(struct ieee80211_hdr_3addr);\n\n\tif (ies_len) {\n\t\tu8 *ssidie =\n\t\t\t(u8 *)cfg80211_find_ie(WLAN_EID_SSID, ies, ies_len);\n\t\tif (ssidie && ssidie[1] && ssidie[1] <= sizeof(ssids[0].ssid)) {\n\t\t\tu8 *nextie = &ssidie[2 + ssidie[1]];\n\t\t\t \n\n\t\t\t \n\t\t\tssids[0].length = ssidie[1];\n\t\t\tmemcpy(ssids[0].ssid, &ssidie[2], ssids[0].length);\n\t\t\tscan.num_ssids = 1;\n\n\t\t\t \n\t\t\tssidie[1] = 0;\n\t\t\tmemmove(&ssidie[2], nextie, &ies[ies_len] - nextie);\n\t\t\tskb_trim(frame.skb, frame.skb->len - ssids[0].length);\n\t\t}\n\t}\n\n\t \n\tif (priv->join_status == CW1200_JOIN_STATUS_MONITOR)\n\t\tcw1200_disable_listening(priv);\n\tret = wsm_set_template_frame(priv, &frame);\n\tpriv->scan.direct_probe = 1;\n\tif (!ret) {\n\t\twsm_flush_tx(priv);\n\t\tret = cw1200_scan_start(priv, &scan);\n\t}\n\tmutex_unlock(&priv->conf_mutex);\n\n\tskb_push(frame.skb, txpriv->offset);\n\tif (!ret)\n\t\tIEEE80211_SKB_CB(frame.skb)->flags |= IEEE80211_TX_STAT_ACK;\n\tBUG_ON(cw1200_queue_remove(queue, priv->pending_frame_id));\n\n\tif (ret) {\n\t\tpriv->scan.direct_probe = 0;\n\t\tup(&priv->scan.lock);\n\t\twsm_unlock_tx(priv);\n\t}\n\n\treturn;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}