{
  "module_name": "txrx.c",
  "hash_id": "a5dde9d37e8fd80cb670ef22c7e75b85be254178e3599def4f0945031ddd317f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/st/cw1200/txrx.c",
  "human_readable_source": "\n \n\n#include <net/mac80211.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n\n#include \"cw1200.h\"\n#include \"wsm.h\"\n#include \"bh.h\"\n#include \"sta.h\"\n#include \"debug.h\"\n\n#define CW1200_INVALID_RATE_ID (0xFF)\n\nstatic int cw1200_handle_action_rx(struct cw1200_common *priv,\n\t\t\t\t   struct sk_buff *skb);\nstatic const struct ieee80211_rate *\ncw1200_get_tx_rate(const struct cw1200_common *priv,\n\t\t   const struct ieee80211_tx_rate *rate);\n\n \n \n\nstatic inline void cw1200_tx_queues_lock(struct cw1200_common *priv)\n{\n\tint i;\n\tfor (i = 0; i < 4; ++i)\n\t\tcw1200_queue_lock(&priv->tx_queue[i]);\n}\n\nstatic inline void cw1200_tx_queues_unlock(struct cw1200_common *priv)\n{\n\tint i;\n\tfor (i = 0; i < 4; ++i)\n\t\tcw1200_queue_unlock(&priv->tx_queue[i]);\n}\n\n \n \n\nstatic void tx_policy_dump(struct tx_policy *policy)\n{\n\tpr_debug(\"[TX policy] %.1X%.1X%.1X%.1X%.1X%.1X%.1X%.1X %.1X%.1X%.1X%.1X%.1X%.1X%.1X%.1X %.1X%.1X%.1X%.1X%.1X%.1X%.1X%.1X: %d\\n\",\n\t\t policy->raw[0] & 0x0F,  policy->raw[0] >> 4,\n\t\t policy->raw[1] & 0x0F,  policy->raw[1] >> 4,\n\t\t policy->raw[2] & 0x0F,  policy->raw[2] >> 4,\n\t\t policy->raw[3] & 0x0F,  policy->raw[3] >> 4,\n\t\t policy->raw[4] & 0x0F,  policy->raw[4] >> 4,\n\t\t policy->raw[5] & 0x0F,  policy->raw[5] >> 4,\n\t\t policy->raw[6] & 0x0F,  policy->raw[6] >> 4,\n\t\t policy->raw[7] & 0x0F,  policy->raw[7] >> 4,\n\t\t policy->raw[8] & 0x0F,  policy->raw[8] >> 4,\n\t\t policy->raw[9] & 0x0F,  policy->raw[9] >> 4,\n\t\t policy->raw[10] & 0x0F,  policy->raw[10] >> 4,\n\t\t policy->raw[11] & 0x0F,  policy->raw[11] >> 4,\n\t\t policy->defined);\n}\n\nstatic void tx_policy_build(const struct cw1200_common *priv,\n\t  struct tx_policy *policy,\n\tstruct ieee80211_tx_rate *rates, size_t count)\n{\n\tint i, j;\n\tunsigned limit = priv->short_frame_max_tx_count;\n\tunsigned total = 0;\n\tBUG_ON(rates[0].idx < 0);\n\tmemset(policy, 0, sizeof(*policy));\n\n\t \n\tfor (i = 1; i < count; ++i) {\n\t\tif (rates[i].idx < 0) {\n\t\t\tcount = i;\n\t\t\tbreak;\n\t\t}\n\t\tif (rates[i].idx > rates[i - 1].idx) {\n\t\t\tstruct ieee80211_tx_rate tmp = rates[i - 1];\n\t\t\trates[i - 1] = rates[i];\n\t\t\trates[i] = tmp;\n\t\t}\n\t}\n\n\t \n\ttotal = rates[0].count;\n\tfor (i = 0, j = 1; j < count; ++j) {\n\t\tif (rates[j].idx == rates[i].idx) {\n\t\t\trates[i].count += rates[j].count;\n\t\t} else if (rates[j].idx > rates[i].idx) {\n\t\t\tbreak;\n\t\t} else {\n\t\t\t++i;\n\t\t\tif (i != j)\n\t\t\t\trates[i] = rates[j];\n\t\t}\n\t\ttotal += rates[j].count;\n\t}\n\tcount = i + 1;\n\n\t \n\tif (limit < count)\n\t\tlimit = count;\n\tif (total > limit) {\n\t\tfor (i = 0; i < count; ++i) {\n\t\t\tint left = count - i - 1;\n\t\t\tif (rates[i].count > limit - left)\n\t\t\t\trates[i].count = limit - left;\n\t\t\tlimit -= rates[i].count;\n\t\t}\n\t}\n\n\t \n\tif (count == 2 && !(rates[0].flags & IEEE80211_TX_RC_MCS) &&\n\t    rates[0].idx > 4 && rates[0].count > 2 &&\n\t    rates[1].idx < 2) {\n\t\tint mid_rate = (rates[0].idx + 4) >> 1;\n\n\t\t \n\t\trates[0].count -= 2;\n\n\t\tif (mid_rate != 4) {\n\t\t\t \n\t\t\trates[3] = rates[1];\n\n\t\t\t \n\t\t\trates[2].idx = 4;\n\t\t\trates[2].count = 1;\n\t\t\trates[2].flags = rates[1].flags;\n\n\t\t\t \n\t\t\trates[1].idx = mid_rate;\n\t\t\trates[1].count = 1;\n\n\t\t\t \n\t\t\tif (rates[0].count >= 3) {\n\t\t\t\t--rates[0].count;\n\t\t\t\t++rates[2].count;\n\t\t\t}\n\n\t\t\t \n\t\t\tcount += 2;\n\t\t} else {\n\t\t\t \n\t\t\trates[2] = rates[1];\n\n\t\t\t \n\t\t\trates[1].idx = 4;\n\t\t\trates[1].count = 2;\n\n\t\t\t \n\t\t\tcount += 1;\n\t\t}\n\t}\n\n\tpolicy->defined = cw1200_get_tx_rate(priv, &rates[0])->hw_value + 1;\n\n\tfor (i = 0; i < count; ++i) {\n\t\tregister unsigned rateid, off, shift, retries;\n\n\t\trateid = cw1200_get_tx_rate(priv, &rates[i])->hw_value;\n\t\toff = rateid >> 3;\t\t \n\t\tshift = (rateid & 0x07) << 2;\t \n\n\t\tretries = rates[i].count;\n\t\tif (retries > 0x0F) {\n\t\t\trates[i].count = 0x0f;\n\t\t\tretries = 0x0F;\n\t\t}\n\t\tpolicy->tbl[off] |= __cpu_to_le32(retries << shift);\n\t\tpolicy->retry_count += retries;\n\t}\n\n\tpr_debug(\"[TX policy] Policy (%zu): %d:%d, %d:%d, %d:%d, %d:%d\\n\",\n\t\t count,\n\t\t rates[0].idx, rates[0].count,\n\t\t rates[1].idx, rates[1].count,\n\t\t rates[2].idx, rates[2].count,\n\t\t rates[3].idx, rates[3].count);\n}\n\nstatic inline bool tx_policy_is_equal(const struct tx_policy *wanted,\n\t\t\t\t\tconst struct tx_policy *cached)\n{\n\tsize_t count = wanted->defined >> 1;\n\tif (wanted->defined > cached->defined)\n\t\treturn false;\n\tif (count) {\n\t\tif (memcmp(wanted->raw, cached->raw, count))\n\t\t\treturn false;\n\t}\n\tif (wanted->defined & 1) {\n\t\tif ((wanted->raw[count] & 0x0F) != (cached->raw[count] & 0x0F))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic int tx_policy_find(struct tx_policy_cache *cache,\n\t\t\t\tconst struct tx_policy *wanted)\n{\n\t \n\tstruct tx_policy_cache_entry *it;\n\t \n\tlist_for_each_entry(it, &cache->used, link) {\n\t\tif (tx_policy_is_equal(wanted, &it->policy))\n\t\t\treturn it - cache->cache;\n\t}\n\t \n\tlist_for_each_entry(it, &cache->free, link) {\n\t\tif (tx_policy_is_equal(wanted, &it->policy))\n\t\t\treturn it - cache->cache;\n\t}\n\treturn -1;\n}\n\nstatic inline void tx_policy_use(struct tx_policy_cache *cache,\n\t\t\t\t struct tx_policy_cache_entry *entry)\n{\n\t++entry->policy.usage_count;\n\tlist_move(&entry->link, &cache->used);\n}\n\nstatic inline int tx_policy_release(struct tx_policy_cache *cache,\n\t\t\t\t    struct tx_policy_cache_entry *entry)\n{\n\tint ret = --entry->policy.usage_count;\n\tif (!ret)\n\t\tlist_move(&entry->link, &cache->free);\n\treturn ret;\n}\n\nvoid tx_policy_clean(struct cw1200_common *priv)\n{\n\tint idx, locked;\n\tstruct tx_policy_cache *cache = &priv->tx_policy_cache;\n\tstruct tx_policy_cache_entry *entry;\n\n\tcw1200_tx_queues_lock(priv);\n\tspin_lock_bh(&cache->lock);\n\tlocked = list_empty(&cache->free);\n\n\tfor (idx = 0; idx < TX_POLICY_CACHE_SIZE; idx++) {\n\t\tentry = &cache->cache[idx];\n\t\t \n\t\tif (WARN_ON(entry->policy.usage_count)) {\n\t\t\tentry->policy.usage_count = 0;\n\t\t\tlist_move(&entry->link, &cache->free);\n\t\t}\n\t\tmemset(&entry->policy, 0, sizeof(entry->policy));\n\t}\n\tif (locked)\n\t\tcw1200_tx_queues_unlock(priv);\n\n\tcw1200_tx_queues_unlock(priv);\n\tspin_unlock_bh(&cache->lock);\n}\n\n \n \n\nvoid tx_policy_init(struct cw1200_common *priv)\n{\n\tstruct tx_policy_cache *cache = &priv->tx_policy_cache;\n\tint i;\n\n\tmemset(cache, 0, sizeof(*cache));\n\n\tspin_lock_init(&cache->lock);\n\tINIT_LIST_HEAD(&cache->used);\n\tINIT_LIST_HEAD(&cache->free);\n\n\tfor (i = 0; i < TX_POLICY_CACHE_SIZE; ++i)\n\t\tlist_add(&cache->cache[i].link, &cache->free);\n}\n\nstatic int tx_policy_get(struct cw1200_common *priv,\n\t\t  struct ieee80211_tx_rate *rates,\n\t\t  size_t count, bool *renew)\n{\n\tint idx;\n\tstruct tx_policy_cache *cache = &priv->tx_policy_cache;\n\tstruct tx_policy wanted;\n\n\ttx_policy_build(priv, &wanted, rates, count);\n\n\tspin_lock_bh(&cache->lock);\n\tif (WARN_ON_ONCE(list_empty(&cache->free))) {\n\t\tspin_unlock_bh(&cache->lock);\n\t\treturn CW1200_INVALID_RATE_ID;\n\t}\n\tidx = tx_policy_find(cache, &wanted);\n\tif (idx >= 0) {\n\t\tpr_debug(\"[TX policy] Used TX policy: %d\\n\", idx);\n\t\t*renew = false;\n\t} else {\n\t\tstruct tx_policy_cache_entry *entry;\n\t\t*renew = true;\n\t\t \n\t\tentry = list_entry(cache->free.prev,\n\t\t\tstruct tx_policy_cache_entry, link);\n\t\tentry->policy = wanted;\n\t\tidx = entry - cache->cache;\n\t\tpr_debug(\"[TX policy] New TX policy: %d\\n\", idx);\n\t\ttx_policy_dump(&entry->policy);\n\t}\n\ttx_policy_use(cache, &cache->cache[idx]);\n\tif (list_empty(&cache->free)) {\n\t\t \n\t\tcw1200_tx_queues_lock(priv);\n\t}\n\tspin_unlock_bh(&cache->lock);\n\treturn idx;\n}\n\nstatic void tx_policy_put(struct cw1200_common *priv, int idx)\n{\n\tint usage, locked;\n\tstruct tx_policy_cache *cache = &priv->tx_policy_cache;\n\n\tspin_lock_bh(&cache->lock);\n\tlocked = list_empty(&cache->free);\n\tusage = tx_policy_release(cache, &cache->cache[idx]);\n\tif (locked && !usage) {\n\t\t \n\t\tcw1200_tx_queues_unlock(priv);\n\t}\n\tspin_unlock_bh(&cache->lock);\n}\n\nstatic int tx_policy_upload(struct cw1200_common *priv)\n{\n\tstruct tx_policy_cache *cache = &priv->tx_policy_cache;\n\tint i;\n\tstruct wsm_set_tx_rate_retry_policy arg = {\n\t\t.num = 0,\n\t};\n\tspin_lock_bh(&cache->lock);\n\n\t \n\tfor (i = 0; i < TX_POLICY_CACHE_SIZE; ++i) {\n\t\tstruct tx_policy *src = &cache->cache[i].policy;\n\t\tif (src->retry_count && !src->uploaded) {\n\t\t\tstruct wsm_tx_rate_retry_policy *dst =\n\t\t\t\t&arg.tbl[arg.num];\n\t\t\tdst->index = i;\n\t\t\tdst->short_retries = priv->short_frame_max_tx_count;\n\t\t\tdst->long_retries = priv->long_frame_max_tx_count;\n\n\t\t\tdst->flags = WSM_TX_RATE_POLICY_FLAG_TERMINATE_WHEN_FINISHED |\n\t\t\t\tWSM_TX_RATE_POLICY_FLAG_COUNT_INITIAL_TRANSMIT;\n\t\t\tmemcpy(dst->rate_count_indices, src->tbl,\n\t\t\t       sizeof(dst->rate_count_indices));\n\t\t\tsrc->uploaded = 1;\n\t\t\t++arg.num;\n\t\t}\n\t}\n\tspin_unlock_bh(&cache->lock);\n\tcw1200_debug_tx_cache_miss(priv);\n\tpr_debug(\"[TX policy] Upload %d policies\\n\", arg.num);\n\treturn wsm_set_tx_rate_retry_policy(priv, &arg);\n}\n\nvoid tx_policy_upload_work(struct work_struct *work)\n{\n\tstruct cw1200_common *priv =\n\t\tcontainer_of(work, struct cw1200_common, tx_policy_upload_work);\n\n\tpr_debug(\"[TX] TX policy upload.\\n\");\n\ttx_policy_upload(priv);\n\n\twsm_unlock_tx(priv);\n\tcw1200_tx_queues_unlock(priv);\n}\n\n \n \n\nstruct cw1200_txinfo {\n\tstruct sk_buff *skb;\n\tunsigned queue;\n\tstruct ieee80211_tx_info *tx_info;\n\tconst struct ieee80211_rate *rate;\n\tstruct ieee80211_hdr *hdr;\n\tsize_t hdrlen;\n\tconst u8 *da;\n\tstruct cw1200_sta_priv *sta_priv;\n\tstruct ieee80211_sta *sta;\n\tstruct cw1200_txpriv txpriv;\n};\n\nu32 cw1200_rate_mask_to_wsm(struct cw1200_common *priv, u32 rates)\n{\n\tu32 ret = 0;\n\tint i;\n\tfor (i = 0; i < 32; ++i) {\n\t\tif (rates & BIT(i))\n\t\t\tret |= BIT(priv->rates[i].hw_value);\n\t}\n\treturn ret;\n}\n\nstatic const struct ieee80211_rate *\ncw1200_get_tx_rate(const struct cw1200_common *priv,\n\t\t   const struct ieee80211_tx_rate *rate)\n{\n\tif (rate->idx < 0)\n\t\treturn NULL;\n\tif (rate->flags & IEEE80211_TX_RC_MCS)\n\t\treturn &priv->mcs_rates[rate->idx];\n\treturn &priv->hw->wiphy->bands[priv->channel->band]->\n\t\tbitrates[rate->idx];\n}\n\nstatic int\ncw1200_tx_h_calc_link_ids(struct cw1200_common *priv,\n\t\t\t  struct cw1200_txinfo *t)\n{\n\tif (t->sta && t->sta_priv->link_id)\n\t\tt->txpriv.raw_link_id =\n\t\t\t\tt->txpriv.link_id =\n\t\t\t\tt->sta_priv->link_id;\n\telse if (priv->mode != NL80211_IFTYPE_AP)\n\t\tt->txpriv.raw_link_id =\n\t\t\t\tt->txpriv.link_id = 0;\n\telse if (is_multicast_ether_addr(t->da)) {\n\t\tif (priv->enable_beacon) {\n\t\t\tt->txpriv.raw_link_id = 0;\n\t\t\tt->txpriv.link_id = CW1200_LINK_ID_AFTER_DTIM;\n\t\t} else {\n\t\t\tt->txpriv.raw_link_id = 0;\n\t\t\tt->txpriv.link_id = 0;\n\t\t}\n\t} else {\n\t\tt->txpriv.link_id = cw1200_find_link_id(priv, t->da);\n\t\tif (!t->txpriv.link_id)\n\t\t\tt->txpriv.link_id = cw1200_alloc_link_id(priv, t->da);\n\t\tif (!t->txpriv.link_id) {\n\t\t\twiphy_err(priv->hw->wiphy,\n\t\t\t\t  \"No more link IDs available.\\n\");\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tt->txpriv.raw_link_id = t->txpriv.link_id;\n\t}\n\tif (t->txpriv.raw_link_id)\n\t\tpriv->link_id_db[t->txpriv.raw_link_id - 1].timestamp =\n\t\t\t\tjiffies;\n\tif (t->sta && (t->sta->uapsd_queues & BIT(t->queue)))\n\t\tt->txpriv.link_id = CW1200_LINK_ID_UAPSD;\n\treturn 0;\n}\n\nstatic void\ncw1200_tx_h_pm(struct cw1200_common *priv,\n\t       struct cw1200_txinfo *t)\n{\n\tif (ieee80211_is_auth(t->hdr->frame_control)) {\n\t\tu32 mask = ~BIT(t->txpriv.raw_link_id);\n\t\tspin_lock_bh(&priv->ps_state_lock);\n\t\tpriv->sta_asleep_mask &= mask;\n\t\tpriv->pspoll_mask &= mask;\n\t\tspin_unlock_bh(&priv->ps_state_lock);\n\t}\n}\n\nstatic void\ncw1200_tx_h_calc_tid(struct cw1200_common *priv,\n\t\t     struct cw1200_txinfo *t)\n{\n\tif (ieee80211_is_data_qos(t->hdr->frame_control)) {\n\t\tu8 *qos = ieee80211_get_qos_ctl(t->hdr);\n\t\tt->txpriv.tid = qos[0] & IEEE80211_QOS_CTL_TID_MASK;\n\t} else if (ieee80211_is_data(t->hdr->frame_control)) {\n\t\tt->txpriv.tid = 0;\n\t}\n}\n\nstatic int\ncw1200_tx_h_crypt(struct cw1200_common *priv,\n\t\t  struct cw1200_txinfo *t)\n{\n\tif (!t->tx_info->control.hw_key ||\n\t    !ieee80211_has_protected(t->hdr->frame_control))\n\t\treturn 0;\n\n\tt->hdrlen += t->tx_info->control.hw_key->iv_len;\n\tskb_put(t->skb, t->tx_info->control.hw_key->icv_len);\n\n\tif (t->tx_info->control.hw_key->cipher == WLAN_CIPHER_SUITE_TKIP)\n\t\tskb_put(t->skb, 8);  \n\n\treturn 0;\n}\n\nstatic int\ncw1200_tx_h_align(struct cw1200_common *priv,\n\t\t  struct cw1200_txinfo *t,\n\t\t  u8 *flags)\n{\n\tsize_t offset = (size_t)t->skb->data & 3;\n\n\tif (!offset)\n\t\treturn 0;\n\n\tif (offset & 1) {\n\t\twiphy_err(priv->hw->wiphy,\n\t\t\t  \"Bug: attempt to transmit a frame with wrong alignment: %zu\\n\",\n\t\t\t  offset);\n\t\treturn -EINVAL;\n\t}\n\n\tif (skb_headroom(t->skb) < offset) {\n\t\twiphy_err(priv->hw->wiphy,\n\t\t\t  \"Bug: no space allocated for DMA alignment. headroom: %d\\n\",\n\t\t\t  skb_headroom(t->skb));\n\t\treturn -ENOMEM;\n\t}\n\tskb_push(t->skb, offset);\n\tt->hdrlen += offset;\n\tt->txpriv.offset += offset;\n\t*flags |= WSM_TX_2BYTES_SHIFT;\n\tcw1200_debug_tx_align(priv);\n\treturn 0;\n}\n\nstatic int\ncw1200_tx_h_action(struct cw1200_common *priv,\n\t\t   struct cw1200_txinfo *t)\n{\n\tstruct ieee80211_mgmt *mgmt =\n\t\t(struct ieee80211_mgmt *)t->hdr;\n\tif (ieee80211_is_action(t->hdr->frame_control) &&\n\t    mgmt->u.action.category == WLAN_CATEGORY_BACK)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n \nstatic struct wsm_tx *\ncw1200_tx_h_wsm(struct cw1200_common *priv,\n\t\tstruct cw1200_txinfo *t)\n{\n\tstruct wsm_tx *wsm;\n\n\tif (skb_headroom(t->skb) < sizeof(struct wsm_tx)) {\n\t\twiphy_err(priv->hw->wiphy,\n\t\t\t  \"Bug: no space allocated for WSM header. headroom: %d\\n\",\n\t\t\t  skb_headroom(t->skb));\n\t\treturn NULL;\n\t}\n\n\twsm = skb_push(t->skb, sizeof(struct wsm_tx));\n\tt->txpriv.offset += sizeof(struct wsm_tx);\n\tmemset(wsm, 0, sizeof(*wsm));\n\twsm->hdr.len = __cpu_to_le16(t->skb->len);\n\twsm->hdr.id = __cpu_to_le16(0x0004);\n\twsm->queue_id = wsm_queue_id_to_wsm(t->queue);\n\treturn wsm;\n}\n\n \nstatic void\ncw1200_tx_h_bt(struct cw1200_common *priv,\n\t       struct cw1200_txinfo *t,\n\t       struct wsm_tx *wsm)\n{\n\tu8 priority = 0;\n\n\tif (!priv->bt_present)\n\t\treturn;\n\n\tif (ieee80211_is_nullfunc(t->hdr->frame_control)) {\n\t\tpriority = WSM_EPTA_PRIORITY_MGT;\n\t} else if (ieee80211_is_data(t->hdr->frame_control)) {\n\t\t \n\t\tu8 *payload = &t->skb->data[t->hdrlen];\n\t\t__be16 *ethertype = (__be16 *)&payload[6];\n\t\tif (be16_to_cpu(*ethertype) == ETH_P_PAE)\n\t\t\tpriority = WSM_EPTA_PRIORITY_EAPOL;\n\t} else if (ieee80211_is_assoc_req(t->hdr->frame_control) ||\n\t\tieee80211_is_reassoc_req(t->hdr->frame_control)) {\n\t\tstruct ieee80211_mgmt *mgt_frame =\n\t\t\t\t(struct ieee80211_mgmt *)t->hdr;\n\n\t\tif (le16_to_cpu(mgt_frame->u.assoc_req.listen_interval) <\n\t\t\t\t\t\tpriv->listen_interval) {\n\t\t\tpr_debug(\"Modified Listen Interval to %d from %d\\n\",\n\t\t\t\t priv->listen_interval,\n\t\t\t\t mgt_frame->u.assoc_req.listen_interval);\n\t\t\t \n\t\t\tmgt_frame->u.assoc_req.listen_interval = cpu_to_le16(priv->listen_interval);\n\t\t}\n\t}\n\n\tif (!priority) {\n\t\tif (ieee80211_is_action(t->hdr->frame_control))\n\t\t\tpriority = WSM_EPTA_PRIORITY_ACTION;\n\t\telse if (ieee80211_is_mgmt(t->hdr->frame_control))\n\t\t\tpriority = WSM_EPTA_PRIORITY_MGT;\n\t\telse if (wsm->queue_id == WSM_QUEUE_VOICE)\n\t\t\tpriority = WSM_EPTA_PRIORITY_VOICE;\n\t\telse if (wsm->queue_id == WSM_QUEUE_VIDEO)\n\t\t\tpriority = WSM_EPTA_PRIORITY_VIDEO;\n\t\telse\n\t\t\tpriority = WSM_EPTA_PRIORITY_DATA;\n\t}\n\n\tpr_debug(\"[TX] EPTA priority %d.\\n\", priority);\n\n\twsm->flags |= priority << 1;\n}\n\nstatic int\ncw1200_tx_h_rate_policy(struct cw1200_common *priv,\n\t\t\tstruct cw1200_txinfo *t,\n\t\t\tstruct wsm_tx *wsm)\n{\n\tbool tx_policy_renew = false;\n\n\tt->txpriv.rate_id = tx_policy_get(priv,\n\t\tt->tx_info->control.rates, IEEE80211_TX_MAX_RATES,\n\t\t&tx_policy_renew);\n\tif (t->txpriv.rate_id == CW1200_INVALID_RATE_ID)\n\t\treturn -EFAULT;\n\n\twsm->flags |= t->txpriv.rate_id << 4;\n\n\tt->rate = cw1200_get_tx_rate(priv,\n\t\t&t->tx_info->control.rates[0]);\n\twsm->max_tx_rate = t->rate->hw_value;\n\tif (t->rate->flags & IEEE80211_TX_RC_MCS) {\n\t\tif (cw1200_ht_greenfield(&priv->ht_info))\n\t\t\twsm->ht_tx_parameters |=\n\t\t\t\t__cpu_to_le32(WSM_HT_TX_GREENFIELD);\n\t\telse\n\t\t\twsm->ht_tx_parameters |=\n\t\t\t\t__cpu_to_le32(WSM_HT_TX_MIXED);\n\t}\n\n\tif (tx_policy_renew) {\n\t\tpr_debug(\"[TX] TX policy renew.\\n\");\n\t\t \n\t\twsm_lock_tx_async(priv);\n\t\tcw1200_tx_queues_lock(priv);\n\t\tif (queue_work(priv->workqueue,\n\t\t\t       &priv->tx_policy_upload_work) <= 0) {\n\t\t\tcw1200_tx_queues_unlock(priv);\n\t\t\twsm_unlock_tx(priv);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic bool\ncw1200_tx_h_pm_state(struct cw1200_common *priv,\n\t\t     struct cw1200_txinfo *t)\n{\n\tint was_buffered = 1;\n\n\tif (t->txpriv.link_id == CW1200_LINK_ID_AFTER_DTIM &&\n\t    !priv->buffered_multicasts) {\n\t\tpriv->buffered_multicasts = true;\n\t\tif (priv->sta_asleep_mask)\n\t\t\tqueue_work(priv->workqueue,\n\t\t\t\t   &priv->multicast_start_work);\n\t}\n\n\tif (t->txpriv.raw_link_id && t->txpriv.tid < CW1200_MAX_TID)\n\t\twas_buffered = priv->link_id_db[t->txpriv.raw_link_id - 1].buffered[t->txpriv.tid]++;\n\n\treturn !was_buffered;\n}\n\n \n\nvoid cw1200_tx(struct ieee80211_hw *dev,\n\t       struct ieee80211_tx_control *control,\n\t       struct sk_buff *skb)\n{\n\tstruct cw1200_common *priv = dev->priv;\n\tstruct cw1200_txinfo t = {\n\t\t.skb = skb,\n\t\t.queue = skb_get_queue_mapping(skb),\n\t\t.tx_info = IEEE80211_SKB_CB(skb),\n\t\t.hdr = (struct ieee80211_hdr *)skb->data,\n\t\t.txpriv.tid = CW1200_MAX_TID,\n\t\t.txpriv.rate_id = CW1200_INVALID_RATE_ID,\n\t};\n\tstruct ieee80211_sta *sta;\n\tstruct wsm_tx *wsm;\n\tbool tid_update = false;\n\tu8 flags = 0;\n\tint ret;\n\n\tif (priv->bh_error)\n\t\tgoto drop;\n\n\tt.hdrlen = ieee80211_hdrlen(t.hdr->frame_control);\n\tt.da = ieee80211_get_DA(t.hdr);\n\tif (control) {\n\t\tt.sta = control->sta;\n\t\tt.sta_priv = (struct cw1200_sta_priv *)&t.sta->drv_priv;\n\t}\n\n\tif (WARN_ON(t.queue >= 4))\n\t\tgoto drop;\n\n\tret = cw1200_tx_h_calc_link_ids(priv, &t);\n\tif (ret)\n\t\tgoto drop;\n\n\tpr_debug(\"[TX] TX %d bytes (queue: %d, link_id: %d (%d)).\\n\",\n\t\t skb->len, t.queue, t.txpriv.link_id,\n\t\t t.txpriv.raw_link_id);\n\n\tcw1200_tx_h_pm(priv, &t);\n\tcw1200_tx_h_calc_tid(priv, &t);\n\tret = cw1200_tx_h_crypt(priv, &t);\n\tif (ret)\n\t\tgoto drop;\n\tret = cw1200_tx_h_align(priv, &t, &flags);\n\tif (ret)\n\t\tgoto drop;\n\tret = cw1200_tx_h_action(priv, &t);\n\tif (ret)\n\t\tgoto drop;\n\twsm = cw1200_tx_h_wsm(priv, &t);\n\tif (!wsm) {\n\t\tret = -ENOMEM;\n\t\tgoto drop;\n\t}\n\twsm->flags |= flags;\n\tcw1200_tx_h_bt(priv, &t, wsm);\n\tret = cw1200_tx_h_rate_policy(priv, &t, wsm);\n\tif (ret)\n\t\tgoto drop;\n\n\tsta = t.sta;\n\n\tspin_lock_bh(&priv->ps_state_lock);\n\t{\n\t\ttid_update = cw1200_tx_h_pm_state(priv, &t);\n\t\tBUG_ON(cw1200_queue_put(&priv->tx_queue[t.queue],\n\t\t\t\t\tt.skb, &t.txpriv));\n\t}\n\tspin_unlock_bh(&priv->ps_state_lock);\n\n\tif (tid_update && sta)\n\t\tieee80211_sta_set_buffered(sta, t.txpriv.tid, true);\n\n\tcw1200_bh_wakeup(priv);\n\n\treturn;\n\ndrop:\n\tcw1200_skb_dtor(priv, skb, &t.txpriv);\n\treturn;\n}\n\n \n\nstatic int cw1200_handle_action_rx(struct cw1200_common *priv,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tstruct ieee80211_mgmt *mgmt = (void *)skb->data;\n\n\t \n\tif (mgmt->u.action.category == WLAN_CATEGORY_BACK)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int cw1200_handle_pspoll(struct cw1200_common *priv,\n\t\t\t\tstruct sk_buff *skb)\n{\n\tstruct ieee80211_sta *sta;\n\tstruct ieee80211_pspoll *pspoll = (struct ieee80211_pspoll *)skb->data;\n\tint link_id = 0;\n\tu32 pspoll_mask = 0;\n\tint drop = 1;\n\tint i;\n\n\tif (priv->join_status != CW1200_JOIN_STATUS_AP)\n\t\tgoto done;\n\tif (memcmp(priv->vif->addr, pspoll->bssid, ETH_ALEN))\n\t\tgoto done;\n\n\trcu_read_lock();\n\tsta = ieee80211_find_sta(priv->vif, pspoll->ta);\n\tif (sta) {\n\t\tstruct cw1200_sta_priv *sta_priv;\n\t\tsta_priv = (struct cw1200_sta_priv *)&sta->drv_priv;\n\t\tlink_id = sta_priv->link_id;\n\t\tpspoll_mask = BIT(sta_priv->link_id);\n\t}\n\trcu_read_unlock();\n\tif (!link_id)\n\t\tgoto done;\n\n\tpriv->pspoll_mask |= pspoll_mask;\n\tdrop = 0;\n\n\t \n\tfor (i = 0; i < 4; ++i) {\n\t\tif (cw1200_queue_get_num_queued(&priv->tx_queue[i],\n\t\t\t\t\t\tpspoll_mask)) {\n\t\t\tcw1200_bh_wakeup(priv);\n\t\t\tdrop = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tpr_debug(\"[RX] PSPOLL: %s\\n\", drop ? \"local\" : \"fwd\");\ndone:\n\treturn drop;\n}\n\n \n\nvoid cw1200_tx_confirm_cb(struct cw1200_common *priv,\n\t\t\t  int link_id,\n\t\t\t  struct wsm_tx_confirm *arg)\n{\n\tu8 queue_id = cw1200_queue_get_queue_id(arg->packet_id);\n\tstruct cw1200_queue *queue = &priv->tx_queue[queue_id];\n\tstruct sk_buff *skb;\n\tconst struct cw1200_txpriv *txpriv;\n\n\tpr_debug(\"[TX] TX confirm: %d, %d.\\n\",\n\t\t arg->status, arg->ack_failures);\n\n\tif (priv->mode == NL80211_IFTYPE_UNSPECIFIED) {\n\t\t \n\t\treturn;\n\t}\n\n\tif (WARN_ON(queue_id >= 4))\n\t\treturn;\n\n\tif (arg->status)\n\t\tpr_debug(\"TX failed: %d.\\n\", arg->status);\n\n\tif ((arg->status == WSM_REQUEUE) &&\n\t    (arg->flags & WSM_TX_STATUS_REQUEUE)) {\n\t\t \n\t\tstruct wsm_suspend_resume suspend = {\n\t\t\t.link_id = link_id,\n\t\t\t.stop = 1,\n\t\t\t.multicast = !link_id,\n\t\t};\n\t\tcw1200_suspend_resume(priv, &suspend);\n\t\twiphy_warn(priv->hw->wiphy, \"Requeue for link_id %d (try %d). STAs asleep: 0x%.8X\\n\",\n\t\t\t   link_id,\n\t\t\t   cw1200_queue_get_generation(arg->packet_id) + 1,\n\t\t\t   priv->sta_asleep_mask);\n\t\tcw1200_queue_requeue(queue, arg->packet_id);\n\t\tspin_lock_bh(&priv->ps_state_lock);\n\t\tif (!link_id) {\n\t\t\tpriv->buffered_multicasts = true;\n\t\t\tif (priv->sta_asleep_mask) {\n\t\t\t\tqueue_work(priv->workqueue,\n\t\t\t\t\t   &priv->multicast_start_work);\n\t\t\t}\n\t\t}\n\t\tspin_unlock_bh(&priv->ps_state_lock);\n\t} else if (!cw1200_queue_get_skb(queue, arg->packet_id,\n\t\t\t\t\t &skb, &txpriv)) {\n\t\tstruct ieee80211_tx_info *tx = IEEE80211_SKB_CB(skb);\n\t\tint tx_count = arg->ack_failures;\n\t\tu8 ht_flags = 0;\n\t\tint i;\n\n\t\tif (cw1200_ht_greenfield(&priv->ht_info))\n\t\t\tht_flags |= IEEE80211_TX_RC_GREEN_FIELD;\n\n\t\tspin_lock(&priv->bss_loss_lock);\n\t\tif (priv->bss_loss_state &&\n\t\t    arg->packet_id == priv->bss_loss_confirm_id) {\n\t\t\tif (arg->status) {\n\t\t\t\t \n\t\t\t\t__cw1200_cqm_bssloss_sm(priv, 0, 0, 1);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\t__cw1200_cqm_bssloss_sm(priv, 0, 1, 0);\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&priv->bss_loss_lock);\n\n\t\tif (!arg->status) {\n\t\t\ttx->flags |= IEEE80211_TX_STAT_ACK;\n\t\t\t++tx_count;\n\t\t\tcw1200_debug_txed(priv);\n\t\t\tif (arg->flags & WSM_TX_STATUS_AGGREGATION) {\n\t\t\t\t \n\t\t\t\t \n\t\t\t\tcw1200_debug_txed_agg(priv);\n\t\t\t}\n\t\t} else {\n\t\t\tif (tx_count)\n\t\t\t\t++tx_count;\n\t\t}\n\n\t\tfor (i = 0; i < IEEE80211_TX_MAX_RATES; ++i) {\n\t\t\tif (tx->status.rates[i].count >= tx_count) {\n\t\t\t\ttx->status.rates[i].count = tx_count;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttx_count -= tx->status.rates[i].count;\n\t\t\tif (tx->status.rates[i].flags & IEEE80211_TX_RC_MCS)\n\t\t\t\ttx->status.rates[i].flags |= ht_flags;\n\t\t}\n\n\t\tfor (++i; i < IEEE80211_TX_MAX_RATES; ++i) {\n\t\t\ttx->status.rates[i].count = 0;\n\t\t\ttx->status.rates[i].idx = -1;\n\t\t}\n\n\t\t \n\t\tif (tx->control.hw_key) {\n\t\t\tskb_trim(skb, skb->len - tx->control.hw_key->icv_len);\n\t\t\tif (tx->control.hw_key->cipher == WLAN_CIPHER_SUITE_TKIP)\n\t\t\t\tskb_trim(skb, skb->len - 8);  \n\t\t}\n\t\tcw1200_queue_remove(queue, arg->packet_id);\n\t}\n\t \n\tcw1200_bh_wakeup(priv);\n}\n\nstatic void cw1200_notify_buffered_tx(struct cw1200_common *priv,\n\t\t\t       struct sk_buff *skb, int link_id, int tid)\n{\n\tstruct ieee80211_sta *sta;\n\tstruct ieee80211_hdr *hdr;\n\tu8 *buffered;\n\tu8 still_buffered = 0;\n\n\tif (link_id && tid < CW1200_MAX_TID) {\n\t\tbuffered = priv->link_id_db\n\t\t\t\t[link_id - 1].buffered;\n\n\t\tspin_lock_bh(&priv->ps_state_lock);\n\t\tif (!WARN_ON(!buffered[tid]))\n\t\t\tstill_buffered = --buffered[tid];\n\t\tspin_unlock_bh(&priv->ps_state_lock);\n\n\t\tif (!still_buffered && tid < CW1200_MAX_TID) {\n\t\t\thdr = (struct ieee80211_hdr *)skb->data;\n\t\t\trcu_read_lock();\n\t\t\tsta = ieee80211_find_sta(priv->vif, hdr->addr1);\n\t\t\tif (sta)\n\t\t\t\tieee80211_sta_set_buffered(sta, tid, false);\n\t\t\trcu_read_unlock();\n\t\t}\n\t}\n}\n\nvoid cw1200_skb_dtor(struct cw1200_common *priv,\n\t\t     struct sk_buff *skb,\n\t\t     const struct cw1200_txpriv *txpriv)\n{\n\tskb_pull(skb, txpriv->offset);\n\tif (txpriv->rate_id != CW1200_INVALID_RATE_ID) {\n\t\tcw1200_notify_buffered_tx(priv, skb,\n\t\t\t\t\t  txpriv->raw_link_id, txpriv->tid);\n\t\ttx_policy_put(priv, txpriv->rate_id);\n\t}\n\tieee80211_tx_status(priv->hw, skb);\n}\n\nvoid cw1200_rx_cb(struct cw1200_common *priv,\n\t\t  struct wsm_rx *arg,\n\t\t  int link_id,\n\t\t  struct sk_buff **skb_p)\n{\n\tstruct sk_buff *skb = *skb_p;\n\tstruct ieee80211_rx_status *hdr = IEEE80211_SKB_RXCB(skb);\n\tstruct ieee80211_hdr *frame = (struct ieee80211_hdr *)skb->data;\n\tstruct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)skb->data;\n\tstruct cw1200_link_entry *entry = NULL;\n\tunsigned long grace_period;\n\n\tbool early_data = false;\n\tbool p2p = priv->vif && priv->vif->p2p;\n\tsize_t hdrlen;\n\thdr->flag = 0;\n\n\tif (priv->mode == NL80211_IFTYPE_UNSPECIFIED) {\n\t\t \n\t\tgoto drop;\n\t}\n\n\tif (link_id && link_id <= CW1200_MAX_STA_IN_AP_MODE) {\n\t\tentry =\t&priv->link_id_db[link_id - 1];\n\t\tif (entry->status == CW1200_LINK_SOFT &&\n\t\t    ieee80211_is_data(frame->frame_control))\n\t\t\tearly_data = true;\n\t\tentry->timestamp = jiffies;\n\t} else if (p2p &&\n\t\t   ieee80211_is_action(frame->frame_control) &&\n\t\t   (mgmt->u.action.category == WLAN_CATEGORY_PUBLIC)) {\n\t\tpr_debug(\"[RX] Going to MAP&RESET link ID\\n\");\n\t\tWARN_ON(work_pending(&priv->linkid_reset_work));\n\t\tmemcpy(&priv->action_frame_sa[0],\n\t\t       ieee80211_get_SA(frame), ETH_ALEN);\n\t\tpriv->action_linkid = 0;\n\t\tschedule_work(&priv->linkid_reset_work);\n\t}\n\n\tif (link_id && p2p &&\n\t    ieee80211_is_action(frame->frame_control) &&\n\t    (mgmt->u.action.category == WLAN_CATEGORY_PUBLIC)) {\n\t\t \n\t\tWARN_ON(work_pending(&priv->linkid_reset_work));\n\t\tmemcpy(&priv->action_frame_sa[0],\n\t\t       ieee80211_get_SA(frame), ETH_ALEN);\n\t\tpriv->action_linkid = link_id;\n\t\tschedule_work(&priv->linkid_reset_work);\n\t}\n\tif (arg->status) {\n\t\tif (arg->status == WSM_STATUS_MICFAILURE) {\n\t\t\tpr_debug(\"[RX] MIC failure.\\n\");\n\t\t\thdr->flag |= RX_FLAG_MMIC_ERROR;\n\t\t} else if (arg->status == WSM_STATUS_NO_KEY_FOUND) {\n\t\t\tpr_debug(\"[RX] No key found.\\n\");\n\t\t\tgoto drop;\n\t\t} else {\n\t\t\tpr_debug(\"[RX] Receive failure: %d.\\n\",\n\t\t\t\t arg->status);\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\tif (skb->len < sizeof(struct ieee80211_pspoll)) {\n\t\twiphy_warn(priv->hw->wiphy, \"Malformed SDU rx'ed. Size is lesser than IEEE header.\\n\");\n\t\tgoto drop;\n\t}\n\n\tif (ieee80211_is_pspoll(frame->frame_control))\n\t\tif (cw1200_handle_pspoll(priv, skb))\n\t\t\tgoto drop;\n\n\thdr->band = ((arg->channel_number & 0xff00) ||\n\t\t     (arg->channel_number > 14)) ?\n\t\t\tNL80211_BAND_5GHZ : NL80211_BAND_2GHZ;\n\thdr->freq = ieee80211_channel_to_frequency(\n\t\t\targ->channel_number,\n\t\t\thdr->band);\n\n\tif (arg->rx_rate >= 14) {\n\t\thdr->encoding = RX_ENC_HT;\n\t\thdr->rate_idx = arg->rx_rate - 14;\n\t} else if (arg->rx_rate >= 4) {\n\t\thdr->rate_idx = arg->rx_rate - 2;\n\t} else {\n\t\thdr->rate_idx = arg->rx_rate;\n\t}\n\n\thdr->signal = (s8)arg->rcpi_rssi;\n\thdr->antenna = 0;\n\n\thdrlen = ieee80211_hdrlen(frame->frame_control);\n\n\tif (WSM_RX_STATUS_ENCRYPTION(arg->flags)) {\n\t\tsize_t iv_len = 0, icv_len = 0;\n\n\t\thdr->flag |= RX_FLAG_DECRYPTED | RX_FLAG_IV_STRIPPED;\n\n\t\t \n\t\tswitch (WSM_RX_STATUS_ENCRYPTION(arg->flags)) {\n\t\tcase WSM_RX_STATUS_WEP:\n\t\t\tiv_len = 4  ;\n\t\t\ticv_len = 4  ;\n\t\t\tbreak;\n\t\tcase WSM_RX_STATUS_TKIP:\n\t\t\tiv_len = 8  ;\n\t\t\ticv_len = 4  \n\t\t\t\t+ 8  ;\n\t\t\thdr->flag |= RX_FLAG_MMIC_STRIPPED;\n\t\t\tbreak;\n\t\tcase WSM_RX_STATUS_AES:\n\t\t\tiv_len = 8  ;\n\t\t\ticv_len = 8  ;\n\t\t\tbreak;\n\t\tcase WSM_RX_STATUS_WAPI:\n\t\t\tiv_len = 18  ;\n\t\t\ticv_len = 16  ;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"Unknown encryption type %d\\n\",\n\t\t\t\tWSM_RX_STATUS_ENCRYPTION(arg->flags));\n\t\t\tgoto drop;\n\t\t}\n\n\t\t \n\t\tif (arg->status == WSM_STATUS_MICFAILURE)\n\t\t\ticv_len = 0;\n\n\t\tif (skb->len < hdrlen + iv_len + icv_len) {\n\t\t\twiphy_warn(priv->hw->wiphy, \"Malformed SDU rx'ed. Size is lesser than crypto headers.\\n\");\n\t\t\tgoto drop;\n\t\t}\n\n\t\t \n\t\tskb_trim(skb, skb->len - icv_len);\n\t\tmemmove(skb->data + iv_len, skb->data, hdrlen);\n\t\tskb_pull(skb, iv_len);\n\t}\n\n\t \n\tif (arg->flags & WSM_RX_STATUS_TSF_INCLUDED) {\n\t\thdr->mactime = get_unaligned_le64(skb->data + skb->len - 8);\n\t\tif (skb->len >= 8)\n\t\t\tskb_trim(skb, skb->len - 8);\n\t} else {\n\t\thdr->mactime = 0;\n\t}\n\n\tcw1200_debug_rxed(priv);\n\tif (arg->flags & WSM_RX_STATUS_AGGREGATE)\n\t\tcw1200_debug_rxed_agg(priv);\n\n\tif (ieee80211_is_action(frame->frame_control) &&\n\t    (arg->flags & WSM_RX_STATUS_ADDRESS1)) {\n\t\tif (cw1200_handle_action_rx(priv, skb))\n\t\t\treturn;\n\t} else if (ieee80211_is_beacon(frame->frame_control) &&\n\t\t   !arg->status && priv->vif &&\n\t\t   ether_addr_equal(ieee80211_get_SA(frame), priv->vif->bss_conf.bssid)) {\n\t\tconst u8 *tim_ie;\n\t\tu8 *ies = ((struct ieee80211_mgmt *)\n\t\t\t  (skb->data))->u.beacon.variable;\n\t\tsize_t ies_len = skb->len - (ies - (u8 *)(skb->data));\n\n\t\ttim_ie = cfg80211_find_ie(WLAN_EID_TIM, ies, ies_len);\n\t\tif (tim_ie) {\n\t\t\tstruct ieee80211_tim_ie *tim =\n\t\t\t\t(struct ieee80211_tim_ie *)&tim_ie[2];\n\n\t\t\tif (priv->join_dtim_period != tim->dtim_period) {\n\t\t\t\tpriv->join_dtim_period = tim->dtim_period;\n\t\t\t\tqueue_work(priv->workqueue,\n\t\t\t\t\t   &priv->set_beacon_wakeup_period_work);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (priv->disable_beacon_filter &&\n\t\t    (priv->vif->cfg.assoc ||\n\t\t     priv->vif->cfg.ibss_joined)) {\n\t\t\tpriv->disable_beacon_filter = false;\n\t\t\tqueue_work(priv->workqueue,\n\t\t\t\t   &priv->update_filtering_work);\n\t\t}\n\t}\n\n\t \n\tif (ieee80211_is_auth(frame->frame_control))\n\t\tgrace_period = 5 * HZ;\n\telse if (ieee80211_is_deauth(frame->frame_control))\n\t\tgrace_period = 5 * HZ;\n\telse\n\t\tgrace_period = 1 * HZ;\n\tcw1200_pm_stay_awake(&priv->pm_state, grace_period);\n\n\tif (early_data) {\n\t\tspin_lock_bh(&priv->ps_state_lock);\n\t\t \n\t\tif (entry->status == CW1200_LINK_SOFT)\n\t\t\tskb_queue_tail(&entry->rx_queue, skb);\n\t\telse\n\t\t\tieee80211_rx_irqsafe(priv->hw, skb);\n\t\tspin_unlock_bh(&priv->ps_state_lock);\n\t} else {\n\t\tieee80211_rx_irqsafe(priv->hw, skb);\n\t}\n\t*skb_p = NULL;\n\n\treturn;\n\ndrop:\n\t \n\treturn;\n}\n\n \n \n\nint cw1200_alloc_key(struct cw1200_common *priv)\n{\n\tint idx;\n\n\tidx = ffs(~priv->key_map) - 1;\n\tif (idx < 0 || idx > WSM_KEY_MAX_INDEX)\n\t\treturn -1;\n\n\tpriv->key_map |= BIT(idx);\n\tpriv->keys[idx].index = idx;\n\treturn idx;\n}\n\nvoid cw1200_free_key(struct cw1200_common *priv, int idx)\n{\n\tBUG_ON(!(priv->key_map & BIT(idx)));\n\tmemset(&priv->keys[idx], 0, sizeof(priv->keys[idx]));\n\tpriv->key_map &= ~BIT(idx);\n}\n\nvoid cw1200_free_keys(struct cw1200_common *priv)\n{\n\tmemset(&priv->keys, 0, sizeof(priv->keys));\n\tpriv->key_map = 0;\n}\n\nint cw1200_upload_keys(struct cw1200_common *priv)\n{\n\tint idx, ret = 0;\n\tfor (idx = 0; idx <= WSM_KEY_MAX_INDEX; ++idx)\n\t\tif (priv->key_map & BIT(idx)) {\n\t\t\tret = wsm_add_key(priv, &priv->keys[idx]);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\treturn ret;\n}\n\n \nvoid cw1200_link_id_reset(struct work_struct *work)\n{\n\tstruct cw1200_common *priv =\n\t\tcontainer_of(work, struct cw1200_common, linkid_reset_work);\n\tint temp_linkid;\n\n\tif (!priv->action_linkid) {\n\t\t \n\t\ttemp_linkid = cw1200_alloc_link_id(priv,\n\t\t\t\t&priv->action_frame_sa[0]);\n\t\tWARN_ON(!temp_linkid);\n\t\tif (temp_linkid) {\n\t\t\t \n\t\t\tflush_workqueue(priv->workqueue);\n\t\t\t \n\t\t\tspin_lock_bh(&priv->ps_state_lock);\n\t\t\tpriv->link_id_db[temp_linkid - 1].prev_status =\n\t\t\t\tpriv->link_id_db[temp_linkid - 1].status;\n\t\t\tpriv->link_id_db[temp_linkid - 1].status =\n\t\t\t\tCW1200_LINK_RESET;\n\t\t\tspin_unlock_bh(&priv->ps_state_lock);\n\t\t\twsm_lock_tx_async(priv);\n\t\t\tif (queue_work(priv->workqueue,\n\t\t\t\t       &priv->link_id_work) <= 0)\n\t\t\t\twsm_unlock_tx(priv);\n\t\t}\n\t} else {\n\t\tspin_lock_bh(&priv->ps_state_lock);\n\t\tpriv->link_id_db[priv->action_linkid - 1].prev_status =\n\t\t\tpriv->link_id_db[priv->action_linkid - 1].status;\n\t\tpriv->link_id_db[priv->action_linkid - 1].status =\n\t\t\tCW1200_LINK_RESET_REMAP;\n\t\tspin_unlock_bh(&priv->ps_state_lock);\n\t\twsm_lock_tx_async(priv);\n\t\tif (queue_work(priv->workqueue, &priv->link_id_work) <= 0)\n\t\t\twsm_unlock_tx(priv);\n\t\tflush_workqueue(priv->workqueue);\n\t}\n}\n\nint cw1200_find_link_id(struct cw1200_common *priv, const u8 *mac)\n{\n\tint i, ret = 0;\n\tspin_lock_bh(&priv->ps_state_lock);\n\tfor (i = 0; i < CW1200_MAX_STA_IN_AP_MODE; ++i) {\n\t\tif (!memcmp(mac, priv->link_id_db[i].mac, ETH_ALEN) &&\n\t\t    priv->link_id_db[i].status) {\n\t\t\tpriv->link_id_db[i].timestamp = jiffies;\n\t\t\tret = i + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_bh(&priv->ps_state_lock);\n\treturn ret;\n}\n\nint cw1200_alloc_link_id(struct cw1200_common *priv, const u8 *mac)\n{\n\tint i, ret = 0;\n\tunsigned long max_inactivity = 0;\n\tunsigned long now = jiffies;\n\n\tspin_lock_bh(&priv->ps_state_lock);\n\tfor (i = 0; i < CW1200_MAX_STA_IN_AP_MODE; ++i) {\n\t\tif (!priv->link_id_db[i].status) {\n\t\t\tret = i + 1;\n\t\t\tbreak;\n\t\t} else if (priv->link_id_db[i].status != CW1200_LINK_HARD &&\n\t\t\t   !priv->tx_queue_stats.link_map_cache[i + 1]) {\n\t\t\tunsigned long inactivity =\n\t\t\t\tnow - priv->link_id_db[i].timestamp;\n\t\t\tif (inactivity < max_inactivity)\n\t\t\t\tcontinue;\n\t\t\tmax_inactivity = inactivity;\n\t\t\tret = i + 1;\n\t\t}\n\t}\n\tif (ret) {\n\t\tstruct cw1200_link_entry *entry = &priv->link_id_db[ret - 1];\n\t\tpr_debug(\"[AP] STA added, link_id: %d\\n\", ret);\n\t\tentry->status = CW1200_LINK_RESERVE;\n\t\tmemcpy(&entry->mac, mac, ETH_ALEN);\n\t\tmemset(&entry->buffered, 0, CW1200_MAX_TID);\n\t\tskb_queue_head_init(&entry->rx_queue);\n\t\twsm_lock_tx_async(priv);\n\t\tif (queue_work(priv->workqueue, &priv->link_id_work) <= 0)\n\t\t\twsm_unlock_tx(priv);\n\t} else {\n\t\twiphy_info(priv->hw->wiphy,\n\t\t\t   \"[AP] Early: no more link IDs available.\\n\");\n\t}\n\n\tspin_unlock_bh(&priv->ps_state_lock);\n\treturn ret;\n}\n\nvoid cw1200_link_id_work(struct work_struct *work)\n{\n\tstruct cw1200_common *priv =\n\t\tcontainer_of(work, struct cw1200_common, link_id_work);\n\twsm_flush_tx(priv);\n\tcw1200_link_id_gc_work(&priv->link_id_gc_work.work);\n\twsm_unlock_tx(priv);\n}\n\nvoid cw1200_link_id_gc_work(struct work_struct *work)\n{\n\tstruct cw1200_common *priv =\n\t\tcontainer_of(work, struct cw1200_common, link_id_gc_work.work);\n\tstruct wsm_reset reset = {\n\t\t.reset_statistics = false,\n\t};\n\tstruct wsm_map_link map_link = {\n\t\t.link_id = 0,\n\t};\n\tunsigned long now = jiffies;\n\tunsigned long next_gc = -1;\n\tlong ttl;\n\tbool need_reset;\n\tu32 mask;\n\tint i;\n\n\tif (priv->join_status != CW1200_JOIN_STATUS_AP)\n\t\treturn;\n\n\twsm_lock_tx(priv);\n\tspin_lock_bh(&priv->ps_state_lock);\n\tfor (i = 0; i < CW1200_MAX_STA_IN_AP_MODE; ++i) {\n\t\tneed_reset = false;\n\t\tmask = BIT(i + 1);\n\t\tif (priv->link_id_db[i].status == CW1200_LINK_RESERVE ||\n\t\t    (priv->link_id_db[i].status == CW1200_LINK_HARD &&\n\t\t     !(priv->link_id_map & mask))) {\n\t\t\tif (priv->link_id_map & mask) {\n\t\t\t\tpriv->sta_asleep_mask &= ~mask;\n\t\t\t\tpriv->pspoll_mask &= ~mask;\n\t\t\t\tneed_reset = true;\n\t\t\t}\n\t\t\tpriv->link_id_map |= mask;\n\t\t\tif (priv->link_id_db[i].status != CW1200_LINK_HARD)\n\t\t\t\tpriv->link_id_db[i].status = CW1200_LINK_SOFT;\n\t\t\tmemcpy(map_link.mac_addr, priv->link_id_db[i].mac,\n\t\t\t       ETH_ALEN);\n\t\t\tspin_unlock_bh(&priv->ps_state_lock);\n\t\t\tif (need_reset) {\n\t\t\t\treset.link_id = i + 1;\n\t\t\t\twsm_reset(priv, &reset);\n\t\t\t}\n\t\t\tmap_link.link_id = i + 1;\n\t\t\twsm_map_link(priv, &map_link);\n\t\t\tnext_gc = min(next_gc, CW1200_LINK_ID_GC_TIMEOUT);\n\t\t\tspin_lock_bh(&priv->ps_state_lock);\n\t\t} else if (priv->link_id_db[i].status == CW1200_LINK_SOFT) {\n\t\t\tttl = priv->link_id_db[i].timestamp - now +\n\t\t\t\t\tCW1200_LINK_ID_GC_TIMEOUT;\n\t\t\tif (ttl <= 0) {\n\t\t\t\tneed_reset = true;\n\t\t\t\tpriv->link_id_db[i].status = CW1200_LINK_OFF;\n\t\t\t\tpriv->link_id_map &= ~mask;\n\t\t\t\tpriv->sta_asleep_mask &= ~mask;\n\t\t\t\tpriv->pspoll_mask &= ~mask;\n\t\t\t\teth_zero_addr(map_link.mac_addr);\n\t\t\t\tspin_unlock_bh(&priv->ps_state_lock);\n\t\t\t\treset.link_id = i + 1;\n\t\t\t\twsm_reset(priv, &reset);\n\t\t\t\tspin_lock_bh(&priv->ps_state_lock);\n\t\t\t} else {\n\t\t\t\tnext_gc = min_t(unsigned long, next_gc, ttl);\n\t\t\t}\n\t\t} else if (priv->link_id_db[i].status == CW1200_LINK_RESET ||\n\t\t\t\tpriv->link_id_db[i].status ==\n\t\t\t\tCW1200_LINK_RESET_REMAP) {\n\t\t\tint status = priv->link_id_db[i].status;\n\t\t\tpriv->link_id_db[i].status =\n\t\t\t\t\tpriv->link_id_db[i].prev_status;\n\t\t\tpriv->link_id_db[i].timestamp = now;\n\t\t\treset.link_id = i + 1;\n\t\t\tspin_unlock_bh(&priv->ps_state_lock);\n\t\t\twsm_reset(priv, &reset);\n\t\t\tif (status == CW1200_LINK_RESET_REMAP) {\n\t\t\t\tmemcpy(map_link.mac_addr,\n\t\t\t\t       priv->link_id_db[i].mac,\n\t\t\t\t       ETH_ALEN);\n\t\t\t\tmap_link.link_id = i + 1;\n\t\t\t\twsm_map_link(priv, &map_link);\n\t\t\t\tnext_gc = min(next_gc,\n\t\t\t\t\t\tCW1200_LINK_ID_GC_TIMEOUT);\n\t\t\t}\n\t\t\tspin_lock_bh(&priv->ps_state_lock);\n\t\t}\n\t\tif (need_reset) {\n\t\t\tskb_queue_purge(&priv->link_id_db[i].rx_queue);\n\t\t\tpr_debug(\"[AP] STA removed, link_id: %d\\n\",\n\t\t\t\t reset.link_id);\n\t\t}\n\t}\n\tspin_unlock_bh(&priv->ps_state_lock);\n\tif (next_gc != -1)\n\t\tqueue_delayed_work(priv->workqueue,\n\t\t\t\t   &priv->link_id_gc_work, next_gc);\n\twsm_unlock_tx(priv);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}