{
  "module_name": "queue.c",
  "hash_id": "c429817c790ea86dca70eddf540e68eb5381f893a4e51159a4c403b18b910395",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/st/cw1200/queue.c",
  "human_readable_source": "\n \n\n#include <net/mac80211.h>\n#include <linux/sched.h>\n#include <linux/jiffies.h>\n#include \"queue.h\"\n#include \"cw1200.h\"\n#include \"debug.h\"\n\n  struct cw1200_queue_item\n{\n\tstruct list_head\thead;\n\tstruct sk_buff\t\t*skb;\n\tu32\t\t\tpacket_id;\n\tunsigned long\t\tqueue_timestamp;\n\tunsigned long\t\txmit_timestamp;\n\tstruct cw1200_txpriv\ttxpriv;\n\tu8\t\t\tgeneration;\n};\n\nstatic inline void __cw1200_queue_lock(struct cw1200_queue *queue)\n{\n\tstruct cw1200_queue_stats *stats = queue->stats;\n\tif (queue->tx_locked_cnt++ == 0) {\n\t\tpr_debug(\"[TX] Queue %d is locked.\\n\",\n\t\t\t queue->queue_id);\n\t\tieee80211_stop_queue(stats->priv->hw, queue->queue_id);\n\t}\n}\n\nstatic inline void __cw1200_queue_unlock(struct cw1200_queue *queue)\n{\n\tstruct cw1200_queue_stats *stats = queue->stats;\n\tBUG_ON(!queue->tx_locked_cnt);\n\tif (--queue->tx_locked_cnt == 0) {\n\t\tpr_debug(\"[TX] Queue %d is unlocked.\\n\",\n\t\t\t queue->queue_id);\n\t\tieee80211_wake_queue(stats->priv->hw, queue->queue_id);\n\t}\n}\n\nstatic inline void cw1200_queue_parse_id(u32 packet_id, u8 *queue_generation,\n\t\t\t\t\t u8 *queue_id, u8 *item_generation,\n\t\t\t\t\t u8 *item_id)\n{\n\t*item_id\t\t= (packet_id >>  0) & 0xFF;\n\t*item_generation\t= (packet_id >>  8) & 0xFF;\n\t*queue_id\t\t= (packet_id >> 16) & 0xFF;\n\t*queue_generation\t= (packet_id >> 24) & 0xFF;\n}\n\nstatic inline u32 cw1200_queue_mk_packet_id(u8 queue_generation, u8 queue_id,\n\t\t\t\t\t    u8 item_generation, u8 item_id)\n{\n\treturn ((u32)item_id << 0) |\n\t\t((u32)item_generation << 8) |\n\t\t((u32)queue_id << 16) |\n\t\t((u32)queue_generation << 24);\n}\n\nstatic void cw1200_queue_post_gc(struct cw1200_queue_stats *stats,\n\t\t\t\t struct list_head *gc_list)\n{\n\tstruct cw1200_queue_item *item, *tmp;\n\n\tlist_for_each_entry_safe(item, tmp, gc_list, head) {\n\t\tlist_del(&item->head);\n\t\tstats->skb_dtor(stats->priv, item->skb, &item->txpriv);\n\t\tkfree(item);\n\t}\n}\n\nstatic void cw1200_queue_register_post_gc(struct list_head *gc_list,\n\t\t\t\t\t  struct cw1200_queue_item *item)\n{\n\tstruct cw1200_queue_item *gc_item;\n\tgc_item = kmemdup(item, sizeof(struct cw1200_queue_item),\n\t\t\tGFP_ATOMIC);\n\tBUG_ON(!gc_item);\n\tlist_add_tail(&gc_item->head, gc_list);\n}\n\nstatic void __cw1200_queue_gc(struct cw1200_queue *queue,\n\t\t\t      struct list_head *head,\n\t\t\t      bool unlock)\n{\n\tstruct cw1200_queue_stats *stats = queue->stats;\n\tstruct cw1200_queue_item *item = NULL, *iter, *tmp;\n\tbool wakeup_stats = false;\n\n\tlist_for_each_entry_safe(iter, tmp, &queue->queue, head) {\n\t\tif (time_is_after_jiffies(iter->queue_timestamp + queue->ttl)) {\n\t\t\titem = iter;\n\t\t\tbreak;\n\t\t}\n\t\t--queue->num_queued;\n\t\t--queue->link_map_cache[iter->txpriv.link_id];\n\t\tspin_lock_bh(&stats->lock);\n\t\t--stats->num_queued;\n\t\tif (!--stats->link_map_cache[iter->txpriv.link_id])\n\t\t\twakeup_stats = true;\n\t\tspin_unlock_bh(&stats->lock);\n\t\tcw1200_debug_tx_ttl(stats->priv);\n\t\tcw1200_queue_register_post_gc(head, iter);\n\t\titer->skb = NULL;\n\t\tlist_move_tail(&iter->head, &queue->free_pool);\n\t}\n\n\tif (wakeup_stats)\n\t\twake_up(&stats->wait_link_id_empty);\n\n\tif (queue->overfull) {\n\t\tif (queue->num_queued <= (queue->capacity >> 1)) {\n\t\t\tqueue->overfull = false;\n\t\t\tif (unlock)\n\t\t\t\t__cw1200_queue_unlock(queue);\n\t\t} else if (item) {\n\t\t\tunsigned long tmo = item->queue_timestamp + queue->ttl;\n\t\t\tmod_timer(&queue->gc, tmo);\n\t\t\tcw1200_pm_stay_awake(&stats->priv->pm_state,\n\t\t\t\t\t     tmo - jiffies);\n\t\t}\n\t}\n}\n\nstatic void cw1200_queue_gc(struct timer_list *t)\n{\n\tLIST_HEAD(list);\n\tstruct cw1200_queue *queue =\n\t\tfrom_timer(queue, t, gc);\n\n\tspin_lock_bh(&queue->lock);\n\t__cw1200_queue_gc(queue, &list, true);\n\tspin_unlock_bh(&queue->lock);\n\tcw1200_queue_post_gc(queue->stats, &list);\n}\n\nint cw1200_queue_stats_init(struct cw1200_queue_stats *stats,\n\t\t\t    size_t map_capacity,\n\t\t\t    cw1200_queue_skb_dtor_t skb_dtor,\n\t\t\t    struct cw1200_common *priv)\n{\n\tmemset(stats, 0, sizeof(*stats));\n\tstats->map_capacity = map_capacity;\n\tstats->skb_dtor = skb_dtor;\n\tstats->priv = priv;\n\tspin_lock_init(&stats->lock);\n\tinit_waitqueue_head(&stats->wait_link_id_empty);\n\n\tstats->link_map_cache = kcalloc(map_capacity, sizeof(int),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!stats->link_map_cache)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nint cw1200_queue_init(struct cw1200_queue *queue,\n\t\t      struct cw1200_queue_stats *stats,\n\t\t      u8 queue_id,\n\t\t      size_t capacity,\n\t\t      unsigned long ttl)\n{\n\tsize_t i;\n\n\tmemset(queue, 0, sizeof(*queue));\n\tqueue->stats = stats;\n\tqueue->capacity = capacity;\n\tqueue->queue_id = queue_id;\n\tqueue->ttl = ttl;\n\tINIT_LIST_HEAD(&queue->queue);\n\tINIT_LIST_HEAD(&queue->pending);\n\tINIT_LIST_HEAD(&queue->free_pool);\n\tspin_lock_init(&queue->lock);\n\ttimer_setup(&queue->gc, cw1200_queue_gc, 0);\n\n\tqueue->pool = kcalloc(capacity, sizeof(struct cw1200_queue_item),\n\t\t\t      GFP_KERNEL);\n\tif (!queue->pool)\n\t\treturn -ENOMEM;\n\n\tqueue->link_map_cache = kcalloc(stats->map_capacity, sizeof(int),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!queue->link_map_cache) {\n\t\tkfree(queue->pool);\n\t\tqueue->pool = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < capacity; ++i)\n\t\tlist_add_tail(&queue->pool[i].head, &queue->free_pool);\n\n\treturn 0;\n}\n\nint cw1200_queue_clear(struct cw1200_queue *queue)\n{\n\tint i;\n\tLIST_HEAD(gc_list);\n\tstruct cw1200_queue_stats *stats = queue->stats;\n\tstruct cw1200_queue_item *item, *tmp;\n\n\tspin_lock_bh(&queue->lock);\n\tqueue->generation++;\n\tlist_splice_tail_init(&queue->queue, &queue->pending);\n\tlist_for_each_entry_safe(item, tmp, &queue->pending, head) {\n\t\tWARN_ON(!item->skb);\n\t\tcw1200_queue_register_post_gc(&gc_list, item);\n\t\titem->skb = NULL;\n\t\tlist_move_tail(&item->head, &queue->free_pool);\n\t}\n\tqueue->num_queued = 0;\n\tqueue->num_pending = 0;\n\n\tspin_lock_bh(&stats->lock);\n\tfor (i = 0; i < stats->map_capacity; ++i) {\n\t\tstats->num_queued -= queue->link_map_cache[i];\n\t\tstats->link_map_cache[i] -= queue->link_map_cache[i];\n\t\tqueue->link_map_cache[i] = 0;\n\t}\n\tspin_unlock_bh(&stats->lock);\n\tif (queue->overfull) {\n\t\tqueue->overfull = false;\n\t\t__cw1200_queue_unlock(queue);\n\t}\n\tspin_unlock_bh(&queue->lock);\n\twake_up(&stats->wait_link_id_empty);\n\tcw1200_queue_post_gc(stats, &gc_list);\n\treturn 0;\n}\n\nvoid cw1200_queue_stats_deinit(struct cw1200_queue_stats *stats)\n{\n\tkfree(stats->link_map_cache);\n\tstats->link_map_cache = NULL;\n}\n\nvoid cw1200_queue_deinit(struct cw1200_queue *queue)\n{\n\tcw1200_queue_clear(queue);\n\tdel_timer_sync(&queue->gc);\n\tINIT_LIST_HEAD(&queue->free_pool);\n\tkfree(queue->pool);\n\tkfree(queue->link_map_cache);\n\tqueue->pool = NULL;\n\tqueue->link_map_cache = NULL;\n\tqueue->capacity = 0;\n}\n\nsize_t cw1200_queue_get_num_queued(struct cw1200_queue *queue,\n\t\t\t\t   u32 link_id_map)\n{\n\tsize_t ret;\n\tint i, bit;\n\tsize_t map_capacity = queue->stats->map_capacity;\n\n\tif (!link_id_map)\n\t\treturn 0;\n\n\tspin_lock_bh(&queue->lock);\n\tif (link_id_map == (u32)-1) {\n\t\tret = queue->num_queued - queue->num_pending;\n\t} else {\n\t\tret = 0;\n\t\tfor (i = 0, bit = 1; i < map_capacity; ++i, bit <<= 1) {\n\t\t\tif (link_id_map & bit)\n\t\t\t\tret += queue->link_map_cache[i];\n\t\t}\n\t}\n\tspin_unlock_bh(&queue->lock);\n\treturn ret;\n}\n\nint cw1200_queue_put(struct cw1200_queue *queue,\n\t\t     struct sk_buff *skb,\n\t\t     struct cw1200_txpriv *txpriv)\n{\n\tint ret = 0;\n\tstruct cw1200_queue_stats *stats = queue->stats;\n\n\tif (txpriv->link_id >= queue->stats->map_capacity)\n\t\treturn -EINVAL;\n\n\tspin_lock_bh(&queue->lock);\n\tif (!WARN_ON(list_empty(&queue->free_pool))) {\n\t\tstruct cw1200_queue_item *item = list_first_entry(\n\t\t\t&queue->free_pool, struct cw1200_queue_item, head);\n\t\tBUG_ON(item->skb);\n\n\t\tlist_move_tail(&item->head, &queue->queue);\n\t\titem->skb = skb;\n\t\titem->txpriv = *txpriv;\n\t\titem->generation = 0;\n\t\titem->packet_id = cw1200_queue_mk_packet_id(queue->generation,\n\t\t\t\t\t\t\t    queue->queue_id,\n\t\t\t\t\t\t\t    item->generation,\n\t\t\t\t\t\t\t    item - queue->pool);\n\t\titem->queue_timestamp = jiffies;\n\n\t\t++queue->num_queued;\n\t\t++queue->link_map_cache[txpriv->link_id];\n\n\t\tspin_lock_bh(&stats->lock);\n\t\t++stats->num_queued;\n\t\t++stats->link_map_cache[txpriv->link_id];\n\t\tspin_unlock_bh(&stats->lock);\n\n\t\t \n\t\tif (queue->overfull == false &&\n\t\t    queue->num_queued >=\n\t\t    (queue->capacity - (num_present_cpus() - 1))) {\n\t\t\tqueue->overfull = true;\n\t\t\t__cw1200_queue_lock(queue);\n\t\t\tmod_timer(&queue->gc, jiffies);\n\t\t}\n\t} else {\n\t\tret = -ENOENT;\n\t}\n\tspin_unlock_bh(&queue->lock);\n\treturn ret;\n}\n\nint cw1200_queue_get(struct cw1200_queue *queue,\n\t\t     u32 link_id_map,\n\t\t     struct wsm_tx **tx,\n\t\t     struct ieee80211_tx_info **tx_info,\n\t\t     const struct cw1200_txpriv **txpriv)\n{\n\tint ret = -ENOENT;\n\tstruct cw1200_queue_item *item;\n\tstruct cw1200_queue_stats *stats = queue->stats;\n\tbool wakeup_stats = false;\n\n\tspin_lock_bh(&queue->lock);\n\tlist_for_each_entry(item, &queue->queue, head) {\n\t\tif (link_id_map & BIT(item->txpriv.link_id)) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!WARN_ON(ret)) {\n\t\t*tx = (struct wsm_tx *)item->skb->data;\n\t\t*tx_info = IEEE80211_SKB_CB(item->skb);\n\t\t*txpriv = &item->txpriv;\n\t\t(*tx)->packet_id = item->packet_id;\n\t\tlist_move_tail(&item->head, &queue->pending);\n\t\t++queue->num_pending;\n\t\t--queue->link_map_cache[item->txpriv.link_id];\n\t\titem->xmit_timestamp = jiffies;\n\n\t\tspin_lock_bh(&stats->lock);\n\t\t--stats->num_queued;\n\t\tif (!--stats->link_map_cache[item->txpriv.link_id])\n\t\t\twakeup_stats = true;\n\t\tspin_unlock_bh(&stats->lock);\n\t}\n\tspin_unlock_bh(&queue->lock);\n\tif (wakeup_stats)\n\t\twake_up(&stats->wait_link_id_empty);\n\treturn ret;\n}\n\nint cw1200_queue_requeue(struct cw1200_queue *queue, u32 packet_id)\n{\n\tint ret = 0;\n\tu8 queue_generation, queue_id, item_generation, item_id;\n\tstruct cw1200_queue_item *item;\n\tstruct cw1200_queue_stats *stats = queue->stats;\n\n\tcw1200_queue_parse_id(packet_id, &queue_generation, &queue_id,\n\t\t\t      &item_generation, &item_id);\n\n\titem = &queue->pool[item_id];\n\n\tspin_lock_bh(&queue->lock);\n\tBUG_ON(queue_id != queue->queue_id);\n\tif (queue_generation != queue->generation) {\n\t\tret = -ENOENT;\n\t} else if (item_id >= (unsigned) queue->capacity) {\n\t\tWARN_ON(1);\n\t\tret = -EINVAL;\n\t} else if (item->generation != item_generation) {\n\t\tWARN_ON(1);\n\t\tret = -ENOENT;\n\t} else {\n\t\t--queue->num_pending;\n\t\t++queue->link_map_cache[item->txpriv.link_id];\n\n\t\tspin_lock_bh(&stats->lock);\n\t\t++stats->num_queued;\n\t\t++stats->link_map_cache[item->txpriv.link_id];\n\t\tspin_unlock_bh(&stats->lock);\n\n\t\titem->generation = ++item_generation;\n\t\titem->packet_id = cw1200_queue_mk_packet_id(queue_generation,\n\t\t\t\t\t\t\t    queue_id,\n\t\t\t\t\t\t\t    item_generation,\n\t\t\t\t\t\t\t    item_id);\n\t\tlist_move(&item->head, &queue->queue);\n\t}\n\tspin_unlock_bh(&queue->lock);\n\treturn ret;\n}\n\nint cw1200_queue_requeue_all(struct cw1200_queue *queue)\n{\n\tstruct cw1200_queue_item *item, *tmp;\n\tstruct cw1200_queue_stats *stats = queue->stats;\n\tspin_lock_bh(&queue->lock);\n\n\tlist_for_each_entry_safe_reverse(item, tmp, &queue->pending, head) {\n\t\t--queue->num_pending;\n\t\t++queue->link_map_cache[item->txpriv.link_id];\n\n\t\tspin_lock_bh(&stats->lock);\n\t\t++stats->num_queued;\n\t\t++stats->link_map_cache[item->txpriv.link_id];\n\t\tspin_unlock_bh(&stats->lock);\n\n\t\t++item->generation;\n\t\titem->packet_id = cw1200_queue_mk_packet_id(queue->generation,\n\t\t\t\t\t\t\t    queue->queue_id,\n\t\t\t\t\t\t\t    item->generation,\n\t\t\t\t\t\t\t    item - queue->pool);\n\t\tlist_move(&item->head, &queue->queue);\n\t}\n\tspin_unlock_bh(&queue->lock);\n\n\treturn 0;\n}\n\nint cw1200_queue_remove(struct cw1200_queue *queue, u32 packet_id)\n{\n\tint ret = 0;\n\tu8 queue_generation, queue_id, item_generation, item_id;\n\tstruct cw1200_queue_item *item;\n\tstruct cw1200_queue_stats *stats = queue->stats;\n\tstruct sk_buff *gc_skb = NULL;\n\tstruct cw1200_txpriv gc_txpriv;\n\n\tcw1200_queue_parse_id(packet_id, &queue_generation, &queue_id,\n\t\t\t      &item_generation, &item_id);\n\n\titem = &queue->pool[item_id];\n\n\tspin_lock_bh(&queue->lock);\n\tBUG_ON(queue_id != queue->queue_id);\n\tif (queue_generation != queue->generation) {\n\t\tret = -ENOENT;\n\t} else if (item_id >= (unsigned) queue->capacity) {\n\t\tWARN_ON(1);\n\t\tret = -EINVAL;\n\t} else if (item->generation != item_generation) {\n\t\tWARN_ON(1);\n\t\tret = -ENOENT;\n\t} else {\n\t\tgc_txpriv = item->txpriv;\n\t\tgc_skb = item->skb;\n\t\titem->skb = NULL;\n\t\t--queue->num_pending;\n\t\t--queue->num_queued;\n\t\t++queue->num_sent;\n\t\t++item->generation;\n\t\t \n\t\tlist_move(&item->head, &queue->free_pool);\n\n\t\tif (queue->overfull &&\n\t\t    (queue->num_queued <= (queue->capacity >> 1))) {\n\t\t\tqueue->overfull = false;\n\t\t\t__cw1200_queue_unlock(queue);\n\t\t}\n\t}\n\tspin_unlock_bh(&queue->lock);\n\n\tif (gc_skb)\n\t\tstats->skb_dtor(stats->priv, gc_skb, &gc_txpriv);\n\n\treturn ret;\n}\n\nint cw1200_queue_get_skb(struct cw1200_queue *queue, u32 packet_id,\n\t\t\t struct sk_buff **skb,\n\t\t\t const struct cw1200_txpriv **txpriv)\n{\n\tint ret = 0;\n\tu8 queue_generation, queue_id, item_generation, item_id;\n\tstruct cw1200_queue_item *item;\n\tcw1200_queue_parse_id(packet_id, &queue_generation, &queue_id,\n\t\t\t      &item_generation, &item_id);\n\n\titem = &queue->pool[item_id];\n\n\tspin_lock_bh(&queue->lock);\n\tBUG_ON(queue_id != queue->queue_id);\n\tif (queue_generation != queue->generation) {\n\t\tret = -ENOENT;\n\t} else if (item_id >= (unsigned) queue->capacity) {\n\t\tWARN_ON(1);\n\t\tret = -EINVAL;\n\t} else if (item->generation != item_generation) {\n\t\tWARN_ON(1);\n\t\tret = -ENOENT;\n\t} else {\n\t\t*skb = item->skb;\n\t\t*txpriv = &item->txpriv;\n\t}\n\tspin_unlock_bh(&queue->lock);\n\treturn ret;\n}\n\nvoid cw1200_queue_lock(struct cw1200_queue *queue)\n{\n\tspin_lock_bh(&queue->lock);\n\t__cw1200_queue_lock(queue);\n\tspin_unlock_bh(&queue->lock);\n}\n\nvoid cw1200_queue_unlock(struct cw1200_queue *queue)\n{\n\tspin_lock_bh(&queue->lock);\n\t__cw1200_queue_unlock(queue);\n\tspin_unlock_bh(&queue->lock);\n}\n\nbool cw1200_queue_get_xmit_timestamp(struct cw1200_queue *queue,\n\t\t\t\t     unsigned long *timestamp,\n\t\t\t\t     u32 pending_frame_id)\n{\n\tstruct cw1200_queue_item *item;\n\tbool ret;\n\n\tspin_lock_bh(&queue->lock);\n\tret = !list_empty(&queue->pending);\n\tif (ret) {\n\t\tlist_for_each_entry(item, &queue->pending, head) {\n\t\t\tif (item->packet_id != pending_frame_id)\n\t\t\t\tif (time_before(item->xmit_timestamp,\n\t\t\t\t\t\t*timestamp))\n\t\t\t\t\t*timestamp = item->xmit_timestamp;\n\t\t}\n\t}\n\tspin_unlock_bh(&queue->lock);\n\treturn ret;\n}\n\nbool cw1200_queue_stats_is_empty(struct cw1200_queue_stats *stats,\n\t\t\t\t u32 link_id_map)\n{\n\tbool empty = true;\n\n\tspin_lock_bh(&stats->lock);\n\tif (link_id_map == (u32)-1) {\n\t\tempty = stats->num_queued == 0;\n\t} else {\n\t\tint i;\n\t\tfor (i = 0; i < stats->map_capacity; ++i) {\n\t\t\tif (link_id_map & BIT(i)) {\n\t\t\t\tif (stats->link_map_cache[i]) {\n\t\t\t\t\tempty = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_bh(&stats->lock);\n\n\treturn empty;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}