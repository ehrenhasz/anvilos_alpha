{
  "module_name": "cw1200_spi.c",
  "hash_id": "2ff3e9b5f4f990361f3696068328424d68249283206949f153b03d1dc3dd53ee",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/st/cw1200/cw1200_spi.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/gpio.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <net/mac80211.h>\n\n#include <linux/spi/spi.h>\n#include <linux/device.h>\n\n#include \"cw1200.h\"\n#include \"hwbus.h\"\n#include <linux/platform_data/net-cw1200.h>\n#include \"hwio.h\"\n\nMODULE_AUTHOR(\"Solomon Peachy <speachy@sagrad.com>\");\nMODULE_DESCRIPTION(\"mac80211 ST-Ericsson CW1200 SPI driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"spi:cw1200_wlan_spi\");\n\n \n\nstruct hwbus_priv {\n\tstruct spi_device\t*func;\n\tstruct cw1200_common\t*core;\n\tconst struct cw1200_platform_data_spi *pdata;\n\tspinlock_t\t\tlock;  \n\twait_queue_head_t       wq;\n\tint claimed;\n};\n\n#define SDIO_TO_SPI_ADDR(addr) ((addr & 0x1f)>>2)\n#define SET_WRITE 0x7FFF  \n#define SET_READ 0x8000   \n\n \n\nstatic int cw1200_spi_memcpy_fromio(struct hwbus_priv *self,\n\t\t\t\t     unsigned int addr,\n\t\t\t\t     void *dst, int count)\n{\n\tint ret, i;\n\tu16 regaddr;\n\tstruct spi_message      m;\n\n\tstruct spi_transfer     t_addr = {\n\t\t.tx_buf         = &regaddr,\n\t\t.len            = sizeof(regaddr),\n\t};\n\tstruct spi_transfer     t_msg = {\n\t\t.rx_buf         = dst,\n\t\t.len            = count,\n\t};\n\n\tregaddr = (SDIO_TO_SPI_ADDR(addr))<<12;\n\tregaddr |= SET_READ;\n\tregaddr |= (count>>1);\n\n#ifdef SPI_DEBUG\n\tpr_info(\"READ : %04d from 0x%02x (%04x)\\n\", count, addr, regaddr);\n#endif\n\n\t \n\tregaddr = cpu_to_le16(regaddr);\n\n\t \n#if defined(__LITTLE_ENDIAN)\n\tif (self->func->bits_per_word == 8)\n#endif\n\t\tregaddr = swab16(regaddr);\n\n\tspi_message_init(&m);\n\tspi_message_add_tail(&t_addr, &m);\n\tspi_message_add_tail(&t_msg, &m);\n\tret = spi_sync(self->func, &m);\n\n#ifdef SPI_DEBUG\n\tpr_info(\"READ : \");\n\tfor (i = 0; i < t_addr.len; i++)\n\t\tprintk(\"%02x \", ((u8 *)t_addr.tx_buf)[i]);\n\tprintk(\" : \");\n\tfor (i = 0; i < t_msg.len; i++)\n\t\tprintk(\"%02x \", ((u8 *)t_msg.rx_buf)[i]);\n\tprintk(\"\\n\");\n#endif\n\n\t \n#if defined(__LITTLE_ENDIAN)\n\tif (self->func->bits_per_word == 8)\n#endif\n\t{\n\t\tuint16_t *buf = (uint16_t *)dst;\n\t\tfor (i = 0; i < ((count + 1) >> 1); i++)\n\t\t\tbuf[i] = swab16(buf[i]);\n\t}\n\n\treturn ret;\n}\n\nstatic int cw1200_spi_memcpy_toio(struct hwbus_priv *self,\n\t\t\t\t   unsigned int addr,\n\t\t\t\t   const void *src, int count)\n{\n\tint rval, i;\n\tu16 regaddr;\n\tstruct spi_transfer     t_addr = {\n\t\t.tx_buf         = &regaddr,\n\t\t.len            = sizeof(regaddr),\n\t};\n\tstruct spi_transfer     t_msg = {\n\t\t.tx_buf         = src,\n\t\t.len            = count,\n\t};\n\tstruct spi_message      m;\n\n\tregaddr = (SDIO_TO_SPI_ADDR(addr))<<12;\n\tregaddr &= SET_WRITE;\n\tregaddr |= (count>>1);\n\n#ifdef SPI_DEBUG\n\tpr_info(\"WRITE: %04d  to  0x%02x (%04x)\\n\", count, addr, regaddr);\n#endif\n\n\t \n\tregaddr = cpu_to_le16(regaddr);\n\n\t \n#if defined(__LITTLE_ENDIAN)\n\tif (self->func->bits_per_word == 8)\n#endif\n\t{\n\t\tuint16_t *buf = (uint16_t *)src;\n\t        regaddr = swab16(regaddr);\n\t\tfor (i = 0; i < ((count + 1) >> 1); i++)\n\t\t\tbuf[i] = swab16(buf[i]);\n\t}\n\n#ifdef SPI_DEBUG\n\tpr_info(\"WRITE: \");\n\tfor (i = 0; i < t_addr.len; i++)\n\t\tprintk(\"%02x \", ((u8 *)t_addr.tx_buf)[i]);\n\tprintk(\" : \");\n\tfor (i = 0; i < t_msg.len; i++)\n\t\tprintk(\"%02x \", ((u8 *)t_msg.tx_buf)[i]);\n\tprintk(\"\\n\");\n#endif\n\n\tspi_message_init(&m);\n\tspi_message_add_tail(&t_addr, &m);\n\tspi_message_add_tail(&t_msg, &m);\n\trval = spi_sync(self->func, &m);\n\n#ifdef SPI_DEBUG\n\tpr_info(\"WROTE: %d\\n\", m.actual_length);\n#endif\n\n#if defined(__LITTLE_ENDIAN)\n\t \n\tif (self->func->bits_per_word == 8)\n#endif\n\t{\n\t\tuint16_t *buf = (uint16_t *)src;\n\t\tfor (i = 0; i < ((count + 1) >> 1); i++)\n\t\t\tbuf[i] = swab16(buf[i]);\n\t}\n\treturn rval;\n}\n\nstatic void cw1200_spi_lock(struct hwbus_priv *self)\n{\n\tunsigned long flags;\n\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tmight_sleep();\n\n\tadd_wait_queue(&self->wq, &wait);\n\tspin_lock_irqsave(&self->lock, flags);\n\twhile (1) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tif (!self->claimed)\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&self->lock, flags);\n\t\tschedule();\n\t\tspin_lock_irqsave(&self->lock, flags);\n\t}\n\tset_current_state(TASK_RUNNING);\n\tself->claimed = 1;\n\tspin_unlock_irqrestore(&self->lock, flags);\n\tremove_wait_queue(&self->wq, &wait);\n\n\treturn;\n}\n\nstatic void cw1200_spi_unlock(struct hwbus_priv *self)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&self->lock, flags);\n\tself->claimed = 0;\n\tspin_unlock_irqrestore(&self->lock, flags);\n\twake_up(&self->wq);\n\n\treturn;\n}\n\nstatic irqreturn_t cw1200_spi_irq_handler(int irq, void *dev_id)\n{\n\tstruct hwbus_priv *self = dev_id;\n\n\tif (self->core) {\n\t\tcw1200_spi_lock(self);\n\t\tcw1200_irq_handler(self->core);\n\t\tcw1200_spi_unlock(self);\n\t\treturn IRQ_HANDLED;\n\t} else {\n\t\treturn IRQ_NONE;\n\t}\n}\n\nstatic int cw1200_spi_irq_subscribe(struct hwbus_priv *self)\n{\n\tint ret;\n\n\tpr_debug(\"SW IRQ subscribe\\n\");\n\n\tret = request_threaded_irq(self->func->irq, NULL,\n\t\t\t\t   cw1200_spi_irq_handler,\n\t\t\t\t   IRQF_TRIGGER_HIGH | IRQF_ONESHOT,\n\t\t\t\t   \"cw1200_wlan_irq\", self);\n\tif (WARN_ON(ret < 0))\n\t\tgoto exit;\n\n\tret = enable_irq_wake(self->func->irq);\n\tif (WARN_ON(ret))\n\t\tgoto free_irq;\n\n\treturn 0;\n\nfree_irq:\n\tfree_irq(self->func->irq, self);\nexit:\n\treturn ret;\n}\n\nstatic void cw1200_spi_irq_unsubscribe(struct hwbus_priv *self)\n{\n\tpr_debug(\"SW IRQ unsubscribe\\n\");\n\tdisable_irq_wake(self->func->irq);\n\tfree_irq(self->func->irq, self);\n}\n\nstatic int cw1200_spi_off(const struct cw1200_platform_data_spi *pdata)\n{\n\tif (pdata->reset) {\n\t\tgpio_set_value(pdata->reset, 0);\n\t\tmsleep(30);  \n\t\tgpio_free(pdata->reset);\n\t}\n\n\tif (pdata->power_ctrl)\n\t\tpdata->power_ctrl(pdata, false);\n\tif (pdata->clk_ctrl)\n\t\tpdata->clk_ctrl(pdata, false);\n\n\treturn 0;\n}\n\nstatic int cw1200_spi_on(const struct cw1200_platform_data_spi *pdata)\n{\n\t \n\tif (pdata->reset) {\n\t\tgpio_request(pdata->reset, \"cw1200_wlan_reset\");\n\t\tgpio_direction_output(pdata->reset, 0);\n\t}\n\tif (pdata->powerup) {\n\t\tgpio_request(pdata->powerup, \"cw1200_wlan_powerup\");\n\t\tgpio_direction_output(pdata->powerup, 0);\n\t}\n\tif (pdata->reset || pdata->powerup)\n\t\tmsleep(10);  \n\n\t \n\tif (pdata->power_ctrl) {\n\t\tif (pdata->power_ctrl(pdata, true)) {\n\t\t\tpr_err(\"power_ctrl() failed!\\n\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\t \n\tif (pdata->clk_ctrl) {\n\t\tif (pdata->clk_ctrl(pdata, true)) {\n\t\t\tpr_err(\"clk_ctrl() failed!\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tmsleep(10);  \n\t}\n\n\t \n\tif (pdata->powerup) {\n\t\tgpio_set_value(pdata->powerup, 1);\n\t\tmsleep(250);  \n\t}\n\t \n\tif (pdata->reset) {\n\t\tgpio_set_value(pdata->reset, 1);\n\t\tmsleep(50);  \n\t}\n\treturn 0;\n}\n\nstatic size_t cw1200_spi_align_size(struct hwbus_priv *self, size_t size)\n{\n\treturn size & 1 ? size + 1 : size;\n}\n\nstatic int cw1200_spi_pm(struct hwbus_priv *self, bool suspend)\n{\n\treturn irq_set_irq_wake(self->func->irq, suspend);\n}\n\nstatic const struct hwbus_ops cw1200_spi_hwbus_ops = {\n\t.hwbus_memcpy_fromio\t= cw1200_spi_memcpy_fromio,\n\t.hwbus_memcpy_toio\t= cw1200_spi_memcpy_toio,\n\t.lock\t\t\t= cw1200_spi_lock,\n\t.unlock\t\t\t= cw1200_spi_unlock,\n\t.align_size\t\t= cw1200_spi_align_size,\n\t.power_mgmt\t\t= cw1200_spi_pm,\n};\n\n \nstatic int cw1200_spi_probe(struct spi_device *func)\n{\n\tconst struct cw1200_platform_data_spi *plat_data =\n\t\tdev_get_platdata(&func->dev);\n\tstruct hwbus_priv *self;\n\tint status;\n\n\t \n\tif (func->max_speed_hz > 52000000)\n\t\tfunc->max_speed_hz = 52000000;\n\tif (func->max_speed_hz < 1000000)\n\t\tfunc->max_speed_hz = 1000000;\n\n\t \n\tif (plat_data->spi_bits_per_word)\n\t\tfunc->bits_per_word = plat_data->spi_bits_per_word;\n\tif (!func->bits_per_word)\n\t\tfunc->bits_per_word = 16;\n\n\t \n\tfunc->mode = SPI_MODE_0;\n\n\tpr_info(\"cw1200_wlan_spi: Probe called (CS %d M %d BPW %d CLK %d)\\n\",\n\t\tspi_get_chipselect(func, 0), func->mode, func->bits_per_word,\n\t\tfunc->max_speed_hz);\n\n\tif (cw1200_spi_on(plat_data)) {\n\t\tpr_err(\"spi_on() failed!\\n\");\n\t\treturn -1;\n\t}\n\n\tif (spi_setup(func)) {\n\t\tpr_err(\"spi_setup() failed!\\n\");\n\t\treturn -1;\n\t}\n\n\tself = devm_kzalloc(&func->dev, sizeof(*self), GFP_KERNEL);\n\tif (!self) {\n\t\tpr_err(\"Can't allocate SPI hwbus_priv.\");\n\t\treturn -ENOMEM;\n\t}\n\n\tself->pdata = plat_data;\n\tself->func = func;\n\tspin_lock_init(&self->lock);\n\n\tspi_set_drvdata(func, self);\n\n\tinit_waitqueue_head(&self->wq);\n\n\tstatus = cw1200_spi_irq_subscribe(self);\n\n\tstatus = cw1200_core_probe(&cw1200_spi_hwbus_ops,\n\t\t\t\t   self, &func->dev, &self->core,\n\t\t\t\t   self->pdata->ref_clk,\n\t\t\t\t   self->pdata->macaddr,\n\t\t\t\t   self->pdata->sdd_file,\n\t\t\t\t   self->pdata->have_5ghz);\n\n\tif (status) {\n\t\tcw1200_spi_irq_unsubscribe(self);\n\t\tcw1200_spi_off(plat_data);\n\t}\n\n\treturn status;\n}\n\n \nstatic void cw1200_spi_disconnect(struct spi_device *func)\n{\n\tstruct hwbus_priv *self = spi_get_drvdata(func);\n\n\tif (self) {\n\t\tcw1200_spi_irq_unsubscribe(self);\n\t\tif (self->core) {\n\t\t\tcw1200_core_release(self->core);\n\t\t\tself->core = NULL;\n\t\t}\n\t}\n\tcw1200_spi_off(dev_get_platdata(&func->dev));\n}\n\nstatic int __maybe_unused cw1200_spi_suspend(struct device *dev)\n{\n\tstruct hwbus_priv *self = spi_get_drvdata(to_spi_device(dev));\n\n\tif (!cw1200_can_suspend(self->core))\n\t\treturn -EAGAIN;\n\n\t \n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(cw1200_pm_ops, cw1200_spi_suspend, NULL);\n\nstatic struct spi_driver spi_driver = {\n\t.probe\t\t= cw1200_spi_probe,\n\t.remove\t\t= cw1200_spi_disconnect,\n\t.driver = {\n\t\t.name\t\t= \"cw1200_wlan_spi\",\n\t\t.pm\t\t= IS_ENABLED(CONFIG_PM) ? &cw1200_pm_ops : NULL,\n\t},\n};\n\nmodule_spi_driver(spi_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}