{
  "module_name": "wsm.c",
  "hash_id": "6ff76b103ac8da83e35bb053735a9731ad0682637389543eb10c5da1d63ec19c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/st/cw1200/wsm.c",
  "human_readable_source": "\n \n\n#include <linux/skbuff.h>\n#include <linux/wait.h>\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n\n#include \"cw1200.h\"\n#include \"wsm.h\"\n#include \"bh.h\"\n#include \"sta.h\"\n#include \"debug.h\"\n\n#define WSM_CMD_TIMEOUT\t\t(2 * HZ)  \n#define WSM_CMD_START_TIMEOUT\t(7 * HZ)\n#define WSM_CMD_RESET_TIMEOUT\t(3 * HZ)  \n#define WSM_CMD_MAX_TIMEOUT\t(3 * HZ)\n\n#define WSM_SKIP(buf, size)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif ((buf)->data + size > (buf)->end)\t\t\t\\\n\t\t\tgoto underflow;\t\t\t\t\t\\\n\t\t(buf)->data += size;\t\t\t\t\t\\\n\t} while (0)\n\n#define WSM_GET(buf, ptr, size)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif ((buf)->data + size > (buf)->end)\t\t\t\\\n\t\t\tgoto underflow;\t\t\t\t\t\\\n\t\tmemcpy(ptr, (buf)->data, size);\t\t\t\t\\\n\t\t(buf)->data += size;\t\t\t\t\t\\\n\t} while (0)\n\n#define __WSM_GET(buf, type, type2, cvt)\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\\\n\t\ttype val;\t\t\t\t\t\t\\\n\t\tif ((buf)->data + sizeof(type) > (buf)->end)\t\t\\\n\t\t\tgoto underflow;\t\t\t\t\t\\\n\t\tval = cvt(*(type2 *)(buf)->data);\t\t\t\\\n\t\t(buf)->data += sizeof(type);\t\t\t\t\\\n\t\tval;\t\t\t\t\t\t\t\\\n\t})\n\n#define WSM_GET8(buf)  __WSM_GET(buf, u8, u8, (u8))\n#define WSM_GET16(buf) __WSM_GET(buf, u16, __le16, __le16_to_cpu)\n#define WSM_GET32(buf) __WSM_GET(buf, u32, __le32, __le32_to_cpu)\n\n#define WSM_PUT(buf, ptr, size)\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif ((buf)->data + size > (buf)->end)\t\t\\\n\t\t\tif (wsm_buf_reserve((buf), size))\t\\\n\t\t\t\tgoto nomem;\t\t\t\t\\\n\t\tmemcpy((buf)->data, ptr, size);\t\t\t\t\\\n\t\t(buf)->data += size;\t\t\t\t\t\\\n\t} while (0)\n\n#define __WSM_PUT(buf, val, type, type2, cvt)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif ((buf)->data + sizeof(type) > (buf)->end)\t\t\\\n\t\t\tif (wsm_buf_reserve((buf), sizeof(type))) \\\n\t\t\t\tgoto nomem;\t\t\t\t\\\n\t\t*(type2 *)(buf)->data = cvt(val);\t\t\t\\\n\t\t(buf)->data += sizeof(type);\t\t\t\t\\\n\t} while (0)\n\n#define WSM_PUT8(buf, val)  __WSM_PUT(buf, val, u8, u8, (u8))\n#define WSM_PUT16(buf, val) __WSM_PUT(buf, val, u16, __le16, __cpu_to_le16)\n#define WSM_PUT32(buf, val) __WSM_PUT(buf, val, u32, __le32, __cpu_to_le32)\n\nstatic void wsm_buf_reset(struct wsm_buf *buf);\nstatic int wsm_buf_reserve(struct wsm_buf *buf, size_t extra_size);\n\nstatic int wsm_cmd_send(struct cw1200_common *priv,\n\t\t\tstruct wsm_buf *buf,\n\t\t\tvoid *arg, u16 cmd, long tmo);\n\n#define wsm_cmd_lock(__priv) mutex_lock(&((__priv)->wsm_cmd_mux))\n#define wsm_cmd_unlock(__priv) mutex_unlock(&((__priv)->wsm_cmd_mux))\n\n \n \n\nstatic int wsm_generic_confirm(struct cw1200_common *priv,\n\t\t\t     void *arg,\n\t\t\t     struct wsm_buf *buf)\n{\n\tu32 status = WSM_GET32(buf);\n\tif (status != WSM_STATUS_SUCCESS)\n\t\treturn -EINVAL;\n\treturn 0;\n\nunderflow:\n\tWARN_ON(1);\n\treturn -EINVAL;\n}\n\nint wsm_configuration(struct cw1200_common *priv, struct wsm_configuration *arg)\n{\n\tint ret;\n\tstruct wsm_buf *buf = &priv->wsm_cmd_buf;\n\n\twsm_cmd_lock(priv);\n\n\tWSM_PUT32(buf, arg->dot11MaxTransmitMsduLifeTime);\n\tWSM_PUT32(buf, arg->dot11MaxReceiveLifeTime);\n\tWSM_PUT32(buf, arg->dot11RtsThreshold);\n\n\t \n\tWSM_PUT16(buf, arg->dpdData_size + 12);\n\tWSM_PUT16(buf, 1);  \n\tWSM_PUT(buf, arg->dot11StationId, ETH_ALEN);\n\tWSM_PUT16(buf, 5);  \n\tWSM_PUT(buf, arg->dpdData, arg->dpdData_size);\n\n\tret = wsm_cmd_send(priv, buf, arg,\n\t\t\t   WSM_CONFIGURATION_REQ_ID, WSM_CMD_TIMEOUT);\n\n\twsm_cmd_unlock(priv);\n\treturn ret;\n\nnomem:\n\twsm_cmd_unlock(priv);\n\treturn -ENOMEM;\n}\n\nstatic int wsm_configuration_confirm(struct cw1200_common *priv,\n\t\t\t\t     struct wsm_configuration *arg,\n\t\t\t\t     struct wsm_buf *buf)\n{\n\tint i;\n\tint status;\n\n\tstatus = WSM_GET32(buf);\n\tif (WARN_ON(status != WSM_STATUS_SUCCESS))\n\t\treturn -EINVAL;\n\n\tWSM_GET(buf, arg->dot11StationId, ETH_ALEN);\n\targ->dot11FrequencyBandsSupported = WSM_GET8(buf);\n\tWSM_SKIP(buf, 1);\n\targ->supportedRateMask = WSM_GET32(buf);\n\tfor (i = 0; i < 2; ++i) {\n\t\targ->txPowerRange[i].min_power_level = WSM_GET32(buf);\n\t\targ->txPowerRange[i].max_power_level = WSM_GET32(buf);\n\t\targ->txPowerRange[i].stepping = WSM_GET32(buf);\n\t}\n\treturn 0;\n\nunderflow:\n\tWARN_ON(1);\n\treturn -EINVAL;\n}\n\n \n\nint wsm_reset(struct cw1200_common *priv, const struct wsm_reset *arg)\n{\n\tint ret;\n\tstruct wsm_buf *buf = &priv->wsm_cmd_buf;\n\tu16 cmd = WSM_RESET_REQ_ID | WSM_TX_LINK_ID(arg->link_id);\n\n\twsm_cmd_lock(priv);\n\n\tWSM_PUT32(buf, arg->reset_statistics ? 0 : 1);\n\tret = wsm_cmd_send(priv, buf, NULL, cmd, WSM_CMD_RESET_TIMEOUT);\n\twsm_cmd_unlock(priv);\n\treturn ret;\n\nnomem:\n\twsm_cmd_unlock(priv);\n\treturn -ENOMEM;\n}\n\n \n\nstruct wsm_mib {\n\tu16 mib_id;\n\tvoid *buf;\n\tsize_t buf_size;\n};\n\nint wsm_read_mib(struct cw1200_common *priv, u16 mib_id, void *_buf,\n\t\t\tsize_t buf_size)\n{\n\tint ret;\n\tstruct wsm_buf *buf = &priv->wsm_cmd_buf;\n\tstruct wsm_mib mib_buf = {\n\t\t.mib_id = mib_id,\n\t\t.buf = _buf,\n\t\t.buf_size = buf_size,\n\t};\n\twsm_cmd_lock(priv);\n\n\tWSM_PUT16(buf, mib_id);\n\tWSM_PUT16(buf, 0);\n\n\tret = wsm_cmd_send(priv, buf, &mib_buf,\n\t\t\t   WSM_READ_MIB_REQ_ID, WSM_CMD_TIMEOUT);\n\twsm_cmd_unlock(priv);\n\treturn ret;\n\nnomem:\n\twsm_cmd_unlock(priv);\n\treturn -ENOMEM;\n}\n\nstatic int wsm_read_mib_confirm(struct cw1200_common *priv,\n\t\t\t\tstruct wsm_mib *arg,\n\t\t\t\tstruct wsm_buf *buf)\n{\n\tu16 size;\n\tif (WARN_ON(WSM_GET32(buf) != WSM_STATUS_SUCCESS))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(WSM_GET16(buf) != arg->mib_id))\n\t\treturn -EINVAL;\n\n\tsize = WSM_GET16(buf);\n\tif (size > arg->buf_size)\n\t\tsize = arg->buf_size;\n\n\tWSM_GET(buf, arg->buf, size);\n\targ->buf_size = size;\n\treturn 0;\n\nunderflow:\n\tWARN_ON(1);\n\treturn -EINVAL;\n}\n\n \n\nint wsm_write_mib(struct cw1200_common *priv, u16 mib_id, void *_buf,\n\t\t\tsize_t buf_size)\n{\n\tint ret;\n\tstruct wsm_buf *buf = &priv->wsm_cmd_buf;\n\tstruct wsm_mib mib_buf = {\n\t\t.mib_id = mib_id,\n\t\t.buf = _buf,\n\t\t.buf_size = buf_size,\n\t};\n\n\twsm_cmd_lock(priv);\n\n\tWSM_PUT16(buf, mib_id);\n\tWSM_PUT16(buf, buf_size);\n\tWSM_PUT(buf, _buf, buf_size);\n\n\tret = wsm_cmd_send(priv, buf, &mib_buf,\n\t\t\t   WSM_WRITE_MIB_REQ_ID, WSM_CMD_TIMEOUT);\n\twsm_cmd_unlock(priv);\n\treturn ret;\n\nnomem:\n\twsm_cmd_unlock(priv);\n\treturn -ENOMEM;\n}\n\nstatic int wsm_write_mib_confirm(struct cw1200_common *priv,\n\t\t\t\tstruct wsm_mib *arg,\n\t\t\t\tstruct wsm_buf *buf)\n{\n\tint ret;\n\n\tret = wsm_generic_confirm(priv, arg, buf);\n\tif (ret)\n\t\treturn ret;\n\n\tif (arg->mib_id == WSM_MIB_ID_OPERATIONAL_POWER_MODE) {\n\t\t \n\t\tconst char *p = arg->buf;\n\t\tcw1200_enable_powersave(priv, (p[0] & 0x0F) ? true : false);\n\t}\n\treturn 0;\n}\n\n \n\nint wsm_scan(struct cw1200_common *priv, const struct wsm_scan *arg)\n{\n\tint i;\n\tint ret;\n\tstruct wsm_buf *buf = &priv->wsm_cmd_buf;\n\n\tif (arg->num_channels > 48)\n\t\treturn -EINVAL;\n\n\tif (arg->num_ssids > 2)\n\t\treturn -EINVAL;\n\n\tif (arg->band > 1)\n\t\treturn -EINVAL;\n\n\twsm_cmd_lock(priv);\n\n\tWSM_PUT8(buf, arg->band);\n\tWSM_PUT8(buf, arg->type);\n\tWSM_PUT8(buf, arg->flags);\n\tWSM_PUT8(buf, arg->max_tx_rate);\n\tWSM_PUT32(buf, arg->auto_scan_interval);\n\tWSM_PUT8(buf, arg->num_probes);\n\tWSM_PUT8(buf, arg->num_channels);\n\tWSM_PUT8(buf, arg->num_ssids);\n\tWSM_PUT8(buf, arg->probe_delay);\n\n\tfor (i = 0; i < arg->num_channels; ++i) {\n\t\tWSM_PUT16(buf, arg->ch[i].number);\n\t\tWSM_PUT16(buf, 0);\n\t\tWSM_PUT32(buf, arg->ch[i].min_chan_time);\n\t\tWSM_PUT32(buf, arg->ch[i].max_chan_time);\n\t\tWSM_PUT32(buf, 0);\n\t}\n\n\tfor (i = 0; i < arg->num_ssids; ++i) {\n\t\tWSM_PUT32(buf, arg->ssids[i].length);\n\t\tWSM_PUT(buf, &arg->ssids[i].ssid[0],\n\t\t\tsizeof(arg->ssids[i].ssid));\n\t}\n\n\tret = wsm_cmd_send(priv, buf, NULL,\n\t\t\t   WSM_START_SCAN_REQ_ID, WSM_CMD_TIMEOUT);\n\twsm_cmd_unlock(priv);\n\treturn ret;\n\nnomem:\n\twsm_cmd_unlock(priv);\n\treturn -ENOMEM;\n}\n\n \n\nint wsm_stop_scan(struct cw1200_common *priv)\n{\n\tint ret;\n\tstruct wsm_buf *buf = &priv->wsm_cmd_buf;\n\twsm_cmd_lock(priv);\n\tret = wsm_cmd_send(priv, buf, NULL,\n\t\t\t   WSM_STOP_SCAN_REQ_ID, WSM_CMD_TIMEOUT);\n\twsm_cmd_unlock(priv);\n\treturn ret;\n}\n\n\nstatic int wsm_tx_confirm(struct cw1200_common *priv,\n\t\t\t  struct wsm_buf *buf,\n\t\t\t  int link_id)\n{\n\tstruct wsm_tx_confirm tx_confirm;\n\n\ttx_confirm.packet_id = WSM_GET32(buf);\n\ttx_confirm.status = WSM_GET32(buf);\n\ttx_confirm.tx_rate = WSM_GET8(buf);\n\ttx_confirm.ack_failures = WSM_GET8(buf);\n\ttx_confirm.flags = WSM_GET16(buf);\n\ttx_confirm.media_delay = WSM_GET32(buf);\n\ttx_confirm.tx_queue_delay = WSM_GET32(buf);\n\n\tcw1200_tx_confirm_cb(priv, link_id, &tx_confirm);\n\treturn 0;\n\nunderflow:\n\tWARN_ON(1);\n\treturn -EINVAL;\n}\n\nstatic int wsm_multi_tx_confirm(struct cw1200_common *priv,\n\t\t\t\tstruct wsm_buf *buf, int link_id)\n{\n\tint ret;\n\tint count;\n\n\tcount = WSM_GET32(buf);\n\tif (WARN_ON(count <= 0))\n\t\treturn -EINVAL;\n\n\tif (count > 1) {\n\t\t \n\t\tret = wsm_release_tx_buffer(priv, count - 1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\telse if (ret > 0)\n\t\t\tcw1200_bh_wakeup(priv);\n\t}\n\n\tcw1200_debug_txed_multi(priv, count);\n\tdo {\n\t\tret = wsm_tx_confirm(priv, buf, link_id);\n\t} while (!ret && --count);\n\n\treturn ret;\n\nunderflow:\n\tWARN_ON(1);\n\treturn -EINVAL;\n}\n\n \n\nstatic int wsm_join_confirm(struct cw1200_common *priv,\n\t\t\t    struct wsm_join_cnf *arg,\n\t\t\t    struct wsm_buf *buf)\n{\n\targ->status = WSM_GET32(buf);\n\tif (WARN_ON(arg->status) != WSM_STATUS_SUCCESS)\n\t\treturn -EINVAL;\n\n\targ->min_power_level = WSM_GET32(buf);\n\targ->max_power_level = WSM_GET32(buf);\n\n\treturn 0;\n\nunderflow:\n\tWARN_ON(1);\n\treturn -EINVAL;\n}\n\nint wsm_join(struct cw1200_common *priv, struct wsm_join *arg)\n{\n\tint ret;\n\tstruct wsm_buf *buf = &priv->wsm_cmd_buf;\n\tstruct wsm_join_cnf resp;\n\twsm_cmd_lock(priv);\n\n\tWSM_PUT8(buf, arg->mode);\n\tWSM_PUT8(buf, arg->band);\n\tWSM_PUT16(buf, arg->channel_number);\n\tWSM_PUT(buf, &arg->bssid[0], sizeof(arg->bssid));\n\tWSM_PUT16(buf, arg->atim_window);\n\tWSM_PUT8(buf, arg->preamble_type);\n\tWSM_PUT8(buf, arg->probe_for_join);\n\tWSM_PUT8(buf, arg->dtim_period);\n\tWSM_PUT8(buf, arg->flags);\n\tWSM_PUT32(buf, arg->ssid_len);\n\tWSM_PUT(buf, &arg->ssid[0], sizeof(arg->ssid));\n\tWSM_PUT32(buf, arg->beacon_interval);\n\tWSM_PUT32(buf, arg->basic_rate_set);\n\n\tpriv->tx_burst_idx = -1;\n\tret = wsm_cmd_send(priv, buf, &resp,\n\t\t\t   WSM_JOIN_REQ_ID, WSM_CMD_TIMEOUT);\n\t \n\n\tpriv->join_complete_status = resp.status;\n\n\twsm_cmd_unlock(priv);\n\treturn ret;\n\nnomem:\n\twsm_cmd_unlock(priv);\n\treturn -ENOMEM;\n}\n\n \n\nint wsm_set_bss_params(struct cw1200_common *priv,\n\t\t       const struct wsm_set_bss_params *arg)\n{\n\tint ret;\n\tstruct wsm_buf *buf = &priv->wsm_cmd_buf;\n\n\twsm_cmd_lock(priv);\n\n\tWSM_PUT8(buf, (arg->reset_beacon_loss ?  0x1 : 0));\n\tWSM_PUT8(buf, arg->beacon_lost_count);\n\tWSM_PUT16(buf, arg->aid);\n\tWSM_PUT32(buf, arg->operational_rate_set);\n\n\tret = wsm_cmd_send(priv, buf, NULL,\n\t\t\t   WSM_SET_BSS_PARAMS_REQ_ID, WSM_CMD_TIMEOUT);\n\n\twsm_cmd_unlock(priv);\n\treturn ret;\n\nnomem:\n\twsm_cmd_unlock(priv);\n\treturn -ENOMEM;\n}\n\n \n\nint wsm_add_key(struct cw1200_common *priv, const struct wsm_add_key *arg)\n{\n\tint ret;\n\tstruct wsm_buf *buf = &priv->wsm_cmd_buf;\n\n\twsm_cmd_lock(priv);\n\n\tWSM_PUT(buf, arg, sizeof(*arg));\n\n\tret = wsm_cmd_send(priv, buf, NULL,\n\t\t\t   WSM_ADD_KEY_REQ_ID, WSM_CMD_TIMEOUT);\n\n\twsm_cmd_unlock(priv);\n\treturn ret;\n\nnomem:\n\twsm_cmd_unlock(priv);\n\treturn -ENOMEM;\n}\n\n \n\nint wsm_remove_key(struct cw1200_common *priv, const struct wsm_remove_key *arg)\n{\n\tint ret;\n\tstruct wsm_buf *buf = &priv->wsm_cmd_buf;\n\n\twsm_cmd_lock(priv);\n\n\tWSM_PUT8(buf, arg->index);\n\tWSM_PUT8(buf, 0);\n\tWSM_PUT16(buf, 0);\n\n\tret = wsm_cmd_send(priv, buf, NULL,\n\t\t\t   WSM_REMOVE_KEY_REQ_ID, WSM_CMD_TIMEOUT);\n\n\twsm_cmd_unlock(priv);\n\treturn ret;\n\nnomem:\n\twsm_cmd_unlock(priv);\n\treturn -ENOMEM;\n}\n\n \n\nint wsm_set_tx_queue_params(struct cw1200_common *priv,\n\t\tconst struct wsm_set_tx_queue_params *arg, u8 id)\n{\n\tint ret;\n\tstruct wsm_buf *buf = &priv->wsm_cmd_buf;\n\tstatic const u8 queue_id_to_wmm_aci[] = { 3, 2, 0, 1 };\n\n\twsm_cmd_lock(priv);\n\n\tWSM_PUT8(buf, queue_id_to_wmm_aci[id]);\n\tWSM_PUT8(buf, 0);\n\tWSM_PUT8(buf, arg->ackPolicy);\n\tWSM_PUT8(buf, 0);\n\tWSM_PUT32(buf, arg->maxTransmitLifetime);\n\tWSM_PUT16(buf, arg->allowedMediumTime);\n\tWSM_PUT16(buf, 0);\n\n\tret = wsm_cmd_send(priv, buf, NULL, 0x0012, WSM_CMD_TIMEOUT);\n\n\twsm_cmd_unlock(priv);\n\treturn ret;\n\nnomem:\n\twsm_cmd_unlock(priv);\n\treturn -ENOMEM;\n}\n\n \n\nint wsm_set_edca_params(struct cw1200_common *priv,\n\t\t\t\tconst struct wsm_edca_params *arg)\n{\n\tint ret;\n\tstruct wsm_buf *buf = &priv->wsm_cmd_buf;\n\n\twsm_cmd_lock(priv);\n\n\t \n\n\tWSM_PUT16(buf, arg->params[3].cwmin);\n\tWSM_PUT16(buf, arg->params[2].cwmin);\n\tWSM_PUT16(buf, arg->params[1].cwmin);\n\tWSM_PUT16(buf, arg->params[0].cwmin);\n\n\tWSM_PUT16(buf, arg->params[3].cwmax);\n\tWSM_PUT16(buf, arg->params[2].cwmax);\n\tWSM_PUT16(buf, arg->params[1].cwmax);\n\tWSM_PUT16(buf, arg->params[0].cwmax);\n\n\tWSM_PUT8(buf, arg->params[3].aifns);\n\tWSM_PUT8(buf, arg->params[2].aifns);\n\tWSM_PUT8(buf, arg->params[1].aifns);\n\tWSM_PUT8(buf, arg->params[0].aifns);\n\n\tWSM_PUT16(buf, arg->params[3].txop_limit);\n\tWSM_PUT16(buf, arg->params[2].txop_limit);\n\tWSM_PUT16(buf, arg->params[1].txop_limit);\n\tWSM_PUT16(buf, arg->params[0].txop_limit);\n\n\tWSM_PUT32(buf, arg->params[3].max_rx_lifetime);\n\tWSM_PUT32(buf, arg->params[2].max_rx_lifetime);\n\tWSM_PUT32(buf, arg->params[1].max_rx_lifetime);\n\tWSM_PUT32(buf, arg->params[0].max_rx_lifetime);\n\n\tret = wsm_cmd_send(priv, buf, NULL,\n\t\t\t   WSM_EDCA_PARAMS_REQ_ID, WSM_CMD_TIMEOUT);\n\twsm_cmd_unlock(priv);\n\treturn ret;\n\nnomem:\n\twsm_cmd_unlock(priv);\n\treturn -ENOMEM;\n}\n\n \n\nint wsm_switch_channel(struct cw1200_common *priv,\n\t\t\tconst struct wsm_switch_channel *arg)\n{\n\tint ret;\n\tstruct wsm_buf *buf = &priv->wsm_cmd_buf;\n\n\twsm_cmd_lock(priv);\n\n\tWSM_PUT8(buf, arg->mode);\n\tWSM_PUT8(buf, arg->switch_count);\n\tWSM_PUT16(buf, arg->channel_number);\n\n\tpriv->channel_switch_in_progress = 1;\n\n\tret = wsm_cmd_send(priv, buf, NULL,\n\t\t\t   WSM_SWITCH_CHANNEL_REQ_ID, WSM_CMD_TIMEOUT);\n\tif (ret)\n\t\tpriv->channel_switch_in_progress = 0;\n\n\twsm_cmd_unlock(priv);\n\treturn ret;\n\nnomem:\n\twsm_cmd_unlock(priv);\n\treturn -ENOMEM;\n}\n\n \n\nint wsm_set_pm(struct cw1200_common *priv, const struct wsm_set_pm *arg)\n{\n\tint ret;\n\tstruct wsm_buf *buf = &priv->wsm_cmd_buf;\n\tpriv->ps_mode_switch_in_progress = 1;\n\n\twsm_cmd_lock(priv);\n\n\tWSM_PUT8(buf, arg->mode);\n\tWSM_PUT8(buf, arg->fast_psm_idle_period);\n\tWSM_PUT8(buf, arg->ap_psm_change_period);\n\tWSM_PUT8(buf, arg->min_auto_pspoll_period);\n\n\tret = wsm_cmd_send(priv, buf, NULL,\n\t\t\t   WSM_SET_PM_REQ_ID, WSM_CMD_TIMEOUT);\n\n\twsm_cmd_unlock(priv);\n\treturn ret;\n\nnomem:\n\twsm_cmd_unlock(priv);\n\treturn -ENOMEM;\n}\n\n \n\nint wsm_start(struct cw1200_common *priv, const struct wsm_start *arg)\n{\n\tint ret;\n\tstruct wsm_buf *buf = &priv->wsm_cmd_buf;\n\n\twsm_cmd_lock(priv);\n\n\tWSM_PUT8(buf, arg->mode);\n\tWSM_PUT8(buf, arg->band);\n\tWSM_PUT16(buf, arg->channel_number);\n\tWSM_PUT32(buf, arg->ct_window);\n\tWSM_PUT32(buf, arg->beacon_interval);\n\tWSM_PUT8(buf, arg->dtim_period);\n\tWSM_PUT8(buf, arg->preamble);\n\tWSM_PUT8(buf, arg->probe_delay);\n\tWSM_PUT8(buf, arg->ssid_len);\n\tWSM_PUT(buf, arg->ssid, sizeof(arg->ssid));\n\tWSM_PUT32(buf, arg->basic_rate_set);\n\n\tpriv->tx_burst_idx = -1;\n\tret = wsm_cmd_send(priv, buf, NULL,\n\t\t\t   WSM_START_REQ_ID, WSM_CMD_START_TIMEOUT);\n\n\twsm_cmd_unlock(priv);\n\treturn ret;\n\nnomem:\n\twsm_cmd_unlock(priv);\n\treturn -ENOMEM;\n}\n\n \n\nint wsm_beacon_transmit(struct cw1200_common *priv,\n\t\t\tconst struct wsm_beacon_transmit *arg)\n{\n\tint ret;\n\tstruct wsm_buf *buf = &priv->wsm_cmd_buf;\n\n\twsm_cmd_lock(priv);\n\n\tWSM_PUT32(buf, arg->enable_beaconing ? 1 : 0);\n\n\tret = wsm_cmd_send(priv, buf, NULL,\n\t\t\t   WSM_BEACON_TRANSMIT_REQ_ID, WSM_CMD_TIMEOUT);\n\n\twsm_cmd_unlock(priv);\n\treturn ret;\n\nnomem:\n\twsm_cmd_unlock(priv);\n\treturn -ENOMEM;\n}\n\n \n\nint wsm_start_find(struct cw1200_common *priv)\n{\n\tint ret;\n\tstruct wsm_buf *buf = &priv->wsm_cmd_buf;\n\n\twsm_cmd_lock(priv);\n\tret = wsm_cmd_send(priv, buf, NULL, 0x0019, WSM_CMD_TIMEOUT);\n\twsm_cmd_unlock(priv);\n\treturn ret;\n}\n\n \n\nint wsm_stop_find(struct cw1200_common *priv)\n{\n\tint ret;\n\tstruct wsm_buf *buf = &priv->wsm_cmd_buf;\n\n\twsm_cmd_lock(priv);\n\tret = wsm_cmd_send(priv, buf, NULL, 0x001A, WSM_CMD_TIMEOUT);\n\twsm_cmd_unlock(priv);\n\treturn ret;\n}\n\n \n\nint wsm_map_link(struct cw1200_common *priv, const struct wsm_map_link *arg)\n{\n\tint ret;\n\tstruct wsm_buf *buf = &priv->wsm_cmd_buf;\n\tu16 cmd = 0x001C | WSM_TX_LINK_ID(arg->link_id);\n\n\twsm_cmd_lock(priv);\n\n\tWSM_PUT(buf, &arg->mac_addr[0], sizeof(arg->mac_addr));\n\tWSM_PUT16(buf, 0);\n\n\tret = wsm_cmd_send(priv, buf, NULL, cmd, WSM_CMD_TIMEOUT);\n\n\twsm_cmd_unlock(priv);\n\treturn ret;\n\nnomem:\n\twsm_cmd_unlock(priv);\n\treturn -ENOMEM;\n}\n\n \n\nint wsm_update_ie(struct cw1200_common *priv,\n\t\t  const struct wsm_update_ie *arg)\n{\n\tint ret;\n\tstruct wsm_buf *buf = &priv->wsm_cmd_buf;\n\n\twsm_cmd_lock(priv);\n\n\tWSM_PUT16(buf, arg->what);\n\tWSM_PUT16(buf, arg->count);\n\tWSM_PUT(buf, arg->ies, arg->length);\n\n\tret = wsm_cmd_send(priv, buf, NULL, 0x001B, WSM_CMD_TIMEOUT);\n\n\twsm_cmd_unlock(priv);\n\treturn ret;\n\nnomem:\n\twsm_cmd_unlock(priv);\n\treturn -ENOMEM;\n}\n\n \nint wsm_set_probe_responder(struct cw1200_common *priv, bool enable)\n{\n\tpriv->rx_filter.probeResponder = enable;\n\treturn wsm_set_rx_filter(priv, &priv->rx_filter);\n}\n\n \n \nconst char * const cw1200_fw_types[] = {\n\t\"ETF\",\n\t\"WFM\",\n\t\"WSM\",\n\t\"HI test\",\n\t\"Platform test\"\n};\n\nstatic int wsm_startup_indication(struct cw1200_common *priv,\n\t\t\t\t\tstruct wsm_buf *buf)\n{\n\tpriv->wsm_caps.input_buffers     = WSM_GET16(buf);\n\tpriv->wsm_caps.input_buffer_size = WSM_GET16(buf);\n\tpriv->wsm_caps.hw_id\t  = WSM_GET16(buf);\n\tpriv->wsm_caps.hw_subid\t  = WSM_GET16(buf);\n\tpriv->wsm_caps.status\t  = WSM_GET16(buf);\n\tpriv->wsm_caps.fw_cap\t  = WSM_GET16(buf);\n\tpriv->wsm_caps.fw_type\t  = WSM_GET16(buf);\n\tpriv->wsm_caps.fw_api\t  = WSM_GET16(buf);\n\tpriv->wsm_caps.fw_build   = WSM_GET16(buf);\n\tpriv->wsm_caps.fw_ver     = WSM_GET16(buf);\n\tWSM_GET(buf, priv->wsm_caps.fw_label, sizeof(priv->wsm_caps.fw_label));\n\tpriv->wsm_caps.fw_label[sizeof(priv->wsm_caps.fw_label) - 1] = 0;  \n\n\tif (WARN_ON(priv->wsm_caps.status))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(priv->wsm_caps.fw_type > 4))\n\t\treturn -EINVAL;\n\n\tpr_info(\"CW1200 WSM init done.\\n\"\n\t\t\"   Input buffers: %d x %d bytes\\n\"\n\t\t\"   Hardware: %d.%d\\n\"\n\t\t\"   %s firmware [%s], ver: %d, build: %d,\"\n\t\t\"   api: %d, cap: 0x%.4X\\n\",\n\t\tpriv->wsm_caps.input_buffers,\n\t\tpriv->wsm_caps.input_buffer_size,\n\t\tpriv->wsm_caps.hw_id, priv->wsm_caps.hw_subid,\n\t\tcw1200_fw_types[priv->wsm_caps.fw_type],\n\t\tpriv->wsm_caps.fw_label, priv->wsm_caps.fw_ver,\n\t\tpriv->wsm_caps.fw_build,\n\t\tpriv->wsm_caps.fw_api, priv->wsm_caps.fw_cap);\n\n\t \n\tif (!(priv->wsm_caps.fw_cap & 0x1))\n\t\tpriv->hw->wiphy->bands[NL80211_BAND_2GHZ] = NULL;\n\tif (!(priv->wsm_caps.fw_cap & 0x2))\n\t\tpriv->hw->wiphy->bands[NL80211_BAND_5GHZ] = NULL;\n\n\tpriv->firmware_ready = 1;\n\twake_up(&priv->wsm_startup_done);\n\treturn 0;\n\nunderflow:\n\tWARN_ON(1);\n\treturn -EINVAL;\n}\n\nstatic int wsm_receive_indication(struct cw1200_common *priv,\n\t\t\t\t  int link_id,\n\t\t\t\t  struct wsm_buf *buf,\n\t\t\t\t  struct sk_buff **skb_p)\n{\n\tstruct wsm_rx rx;\n\tstruct ieee80211_hdr *hdr;\n\tsize_t hdr_len;\n\t__le16 fctl;\n\n\trx.status = WSM_GET32(buf);\n\trx.channel_number = WSM_GET16(buf);\n\trx.rx_rate = WSM_GET8(buf);\n\trx.rcpi_rssi = WSM_GET8(buf);\n\trx.flags = WSM_GET32(buf);\n\n\t \n\thdr = (struct ieee80211_hdr *)(*skb_p)->data;\n\n\tif (!rx.rcpi_rssi &&\n\t    (ieee80211_is_probe_resp(hdr->frame_control) ||\n\t     ieee80211_is_beacon(hdr->frame_control)))\n\t\treturn 0;\n\n\t \n\tif (!priv->cqm_use_rssi)\n\t\trx.rcpi_rssi = rx.rcpi_rssi / 2 - 110;\n\n\tfctl = *(__le16 *)buf->data;\n\thdr_len = buf->data - buf->begin;\n\tskb_pull(*skb_p, hdr_len);\n\tif (!rx.status && ieee80211_is_deauth(fctl)) {\n\t\tif (priv->join_status == CW1200_JOIN_STATUS_STA) {\n\t\t\t \n\t\t\tpr_debug(\"[WSM] Issue unjoin command (RX).\\n\");\n\t\t\twsm_lock_tx_async(priv);\n\t\t\tif (queue_work(priv->workqueue,\n\t\t\t\t       &priv->unjoin_work) <= 0)\n\t\t\t\twsm_unlock_tx(priv);\n\t\t}\n\t}\n\tcw1200_rx_cb(priv, &rx, link_id, skb_p);\n\tif (*skb_p)\n\t\tskb_push(*skb_p, hdr_len);\n\n\treturn 0;\n\nunderflow:\n\treturn -EINVAL;\n}\n\nstatic int wsm_event_indication(struct cw1200_common *priv, struct wsm_buf *buf)\n{\n\tint first;\n\tstruct cw1200_wsm_event *event;\n\n\tif (priv->mode == NL80211_IFTYPE_UNSPECIFIED) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tevent = kzalloc(sizeof(struct cw1200_wsm_event), GFP_KERNEL);\n\tif (!event)\n\t\treturn -ENOMEM;\n\n\tevent->evt.id = WSM_GET32(buf);\n\tevent->evt.data = WSM_GET32(buf);\n\n\tpr_debug(\"[WSM] Event: %d(%d)\\n\",\n\t\t event->evt.id, event->evt.data);\n\n\tspin_lock(&priv->event_queue_lock);\n\tfirst = list_empty(&priv->event_queue);\n\tlist_add_tail(&event->link, &priv->event_queue);\n\tspin_unlock(&priv->event_queue_lock);\n\n\tif (first)\n\t\tqueue_work(priv->workqueue, &priv->event_handler);\n\n\treturn 0;\n\nunderflow:\n\tkfree(event);\n\treturn -EINVAL;\n}\n\nstatic int wsm_channel_switch_indication(struct cw1200_common *priv,\n\t\t\t\t\t struct wsm_buf *buf)\n{\n\tWARN_ON(WSM_GET32(buf));\n\n\tpriv->channel_switch_in_progress = 0;\n\twake_up(&priv->channel_switch_done);\n\n\twsm_unlock_tx(priv);\n\n\treturn 0;\n\nunderflow:\n\treturn -EINVAL;\n}\n\nstatic int wsm_set_pm_indication(struct cw1200_common *priv,\n\t\t\t\t struct wsm_buf *buf)\n{\n\t \n\tif (priv->ps_mode_switch_in_progress) {\n\t\tpriv->ps_mode_switch_in_progress = 0;\n\t\twake_up(&priv->ps_mode_switch_done);\n\t}\n\treturn 0;\n}\n\nstatic int wsm_scan_started(struct cw1200_common *priv, void *arg,\n\t\t\t    struct wsm_buf *buf)\n{\n\tu32 status = WSM_GET32(buf);\n\tif (status != WSM_STATUS_SUCCESS) {\n\t\tcw1200_scan_failed_cb(priv);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n\nunderflow:\n\tWARN_ON(1);\n\treturn -EINVAL;\n}\n\nstatic int wsm_scan_complete_indication(struct cw1200_common *priv,\n\t\t\t\t\tstruct wsm_buf *buf)\n{\n\tstruct wsm_scan_complete arg;\n\targ.status = WSM_GET32(buf);\n\targ.psm = WSM_GET8(buf);\n\targ.num_channels = WSM_GET8(buf);\n\tcw1200_scan_complete_cb(priv, &arg);\n\n\treturn 0;\n\nunderflow:\n\treturn -EINVAL;\n}\n\nstatic int wsm_join_complete_indication(struct cw1200_common *priv,\n\t\t\t\t\tstruct wsm_buf *buf)\n{\n\tstruct wsm_join_complete arg;\n\targ.status = WSM_GET32(buf);\n\tpr_debug(\"[WSM] Join complete indication, status: %d\\n\", arg.status);\n\tcw1200_join_complete_cb(priv, &arg);\n\n\treturn 0;\n\nunderflow:\n\treturn -EINVAL;\n}\n\nstatic int wsm_find_complete_indication(struct cw1200_common *priv,\n\t\t\t\t\tstruct wsm_buf *buf)\n{\n\tpr_warn(\"Implement find_complete_indication\\n\");\n\treturn 0;\n}\n\nstatic int wsm_ba_timeout_indication(struct cw1200_common *priv,\n\t\t\t\t     struct wsm_buf *buf)\n{\n\tu8 tid;\n\tu8 addr[ETH_ALEN];\n\n\tWSM_GET32(buf);\n\ttid = WSM_GET8(buf);\n\tWSM_GET8(buf);\n\tWSM_GET(buf, addr, ETH_ALEN);\n\n\tpr_info(\"BlockACK timeout, tid %d, addr %pM\\n\",\n\t\ttid, addr);\n\n\treturn 0;\n\nunderflow:\n\treturn -EINVAL;\n}\n\nstatic int wsm_suspend_resume_indication(struct cw1200_common *priv,\n\t\t\t\t\t int link_id, struct wsm_buf *buf)\n{\n\tu32 flags;\n\tstruct wsm_suspend_resume arg;\n\n\tflags = WSM_GET32(buf);\n\targ.link_id = link_id;\n\targ.stop = !(flags & 1);\n\targ.multicast = !!(flags & 8);\n\targ.queue = (flags >> 1) & 3;\n\n\tcw1200_suspend_resume(priv, &arg);\n\n\treturn 0;\n\nunderflow:\n\treturn -EINVAL;\n}\n\n\n \n \n\nstatic int wsm_cmd_send(struct cw1200_common *priv,\n\t\t\tstruct wsm_buf *buf,\n\t\t\tvoid *arg, u16 cmd, long tmo)\n{\n\tsize_t buf_len = buf->data - buf->begin;\n\tint ret;\n\n\t \n\tif (priv->bh_error) {\n\t\tret = 0;\n\t\tgoto done;\n\t}\n\n\t \n\tspin_lock(&priv->wsm_cmd.lock);\n\twhile (!priv->wsm_cmd.done) {\n\t\tspin_unlock(&priv->wsm_cmd.lock);\n\t\tspin_lock(&priv->wsm_cmd.lock);\n\t}\n\tpriv->wsm_cmd.done = 0;\n\tspin_unlock(&priv->wsm_cmd.lock);\n\n\tif (cmd == WSM_WRITE_MIB_REQ_ID ||\n\t    cmd == WSM_READ_MIB_REQ_ID)\n\t\tpr_debug(\"[WSM] >>> 0x%.4X [MIB: 0x%.4X] (%zu)\\n\",\n\t\t\t cmd, __le16_to_cpu(((__le16 *)buf->begin)[2]),\n\t\t\t buf_len);\n\telse\n\t\tpr_debug(\"[WSM] >>> 0x%.4X (%zu)\\n\", cmd, buf_len);\n\n\t \n\tbuf_len += 4;\n\n\t \n\t \n\t((__le16 *)buf->begin)[0] = __cpu_to_le16(buf_len);\n\t((__le16 *)buf->begin)[1] = __cpu_to_le16(cmd);\n\n\tspin_lock(&priv->wsm_cmd.lock);\n\tBUG_ON(priv->wsm_cmd.ptr);\n\tpriv->wsm_cmd.ptr = buf->begin;\n\tpriv->wsm_cmd.len = buf_len;\n\tpriv->wsm_cmd.arg = arg;\n\tpriv->wsm_cmd.cmd = cmd;\n\tspin_unlock(&priv->wsm_cmd.lock);\n\n\tcw1200_bh_wakeup(priv);\n\n\t \n\tret = wait_event_timeout(priv->wsm_cmd_wq,\n\t\t\t\t priv->wsm_cmd.done, tmo);\n\n\tif (!ret && !priv->wsm_cmd.done) {\n\t\tspin_lock(&priv->wsm_cmd.lock);\n\t\tpriv->wsm_cmd.done = 1;\n\t\tpriv->wsm_cmd.ptr = NULL;\n\t\tspin_unlock(&priv->wsm_cmd.lock);\n\t\tif (priv->bh_error) {\n\t\t\t \n\t\t\tret = 0;\n\t\t} else {\n\t\t\tpr_err(\"CMD req (0x%04x) stuck in firmware, killing BH\\n\", priv->wsm_cmd.cmd);\n\t\t\tprint_hex_dump_bytes(\"REQDUMP: \", DUMP_PREFIX_NONE,\n\t\t\t\t\t     buf->begin, buf_len);\n\t\t\tpr_err(\"Outstanding outgoing frames:  %d\\n\", priv->hw_bufs_used);\n\n\t\t\t \n\t\t\tatomic_inc(&priv->bh_term);\n\t\t\twake_up(&priv->bh_wq);\n\t\t\tret = -ETIMEDOUT;\n\t\t}\n\t} else {\n\t\tspin_lock(&priv->wsm_cmd.lock);\n\t\tBUG_ON(!priv->wsm_cmd.done);\n\t\tret = priv->wsm_cmd.ret;\n\t\tspin_unlock(&priv->wsm_cmd.lock);\n\t}\ndone:\n\twsm_buf_reset(buf);\n\treturn ret;\n}\n\n \n \n\nvoid wsm_lock_tx(struct cw1200_common *priv)\n{\n\twsm_cmd_lock(priv);\n\tif (atomic_inc_return(&priv->tx_lock) == 1) {\n\t\tif (wsm_flush_tx(priv))\n\t\t\tpr_debug(\"[WSM] TX is locked.\\n\");\n\t}\n\twsm_cmd_unlock(priv);\n}\n\nvoid wsm_lock_tx_async(struct cw1200_common *priv)\n{\n\tif (atomic_inc_return(&priv->tx_lock) == 1)\n\t\tpr_debug(\"[WSM] TX is locked (async).\\n\");\n}\n\nbool wsm_flush_tx(struct cw1200_common *priv)\n{\n\tunsigned long timestamp = jiffies;\n\tbool pending = false;\n\tlong timeout;\n\tint i;\n\n\t \n\tBUG_ON(!atomic_read(&priv->tx_lock));\n\n\t \n\tif (!priv->hw_bufs_used)\n\t\treturn true;\n\n\tif (priv->bh_error) {\n\t\t \n\t\tpr_err(\"[WSM] Fatal error occurred, will not flush TX.\\n\");\n\t\treturn false;\n\t} else {\n\t\t \n\t\tfor (i = 0; i < 4; ++i)\n\t\t\tpending |= cw1200_queue_get_xmit_timestamp(\n\t\t\t\t\t&priv->tx_queue[i],\n\t\t\t\t\t&timestamp, 0xffffffff);\n\t\t \n\t\tif (!pending)\n\t\t\treturn true;\n\n\t\ttimeout = timestamp + WSM_CMD_LAST_CHANCE_TIMEOUT - jiffies;\n\t\tif (timeout < 0 || wait_event_timeout(priv->bh_evt_wq,\n\t\t\t\t\t\t      !priv->hw_bufs_used,\n\t\t\t\t\t\t      timeout) <= 0) {\n\t\t\t \n\t\t\tpriv->bh_error = 1;\n\t\t\twiphy_err(priv->hw->wiphy, \"[WSM] TX Frames (%d) stuck in firmware, killing BH\\n\", priv->hw_bufs_used);\n\t\t\twake_up(&priv->bh_wq);\n\t\t\treturn false;\n\t\t}\n\n\t\t \n\t\treturn true;\n\t}\n}\n\nvoid wsm_unlock_tx(struct cw1200_common *priv)\n{\n\tint tx_lock;\n\ttx_lock = atomic_dec_return(&priv->tx_lock);\n\tBUG_ON(tx_lock < 0);\n\n\tif (tx_lock == 0) {\n\t\tif (!priv->bh_error)\n\t\t\tcw1200_bh_wakeup(priv);\n\t\tpr_debug(\"[WSM] TX is unlocked.\\n\");\n\t}\n}\n\n \n \n\nint wsm_handle_exception(struct cw1200_common *priv, u8 *data, size_t len)\n{\n\tstruct wsm_buf buf;\n\tu32 reason;\n\tu32 reg[18];\n\tchar fname[48];\n\tunsigned int i;\n\n\tstatic const char * const reason_str[] = {\n\t\t\"undefined instruction\",\n\t\t\"prefetch abort\",\n\t\t\"data abort\",\n\t\t\"unknown error\",\n\t};\n\n\tbuf.begin = buf.data = data;\n\tbuf.end = &buf.begin[len];\n\n\treason = WSM_GET32(&buf);\n\tfor (i = 0; i < ARRAY_SIZE(reg); ++i)\n\t\treg[i] = WSM_GET32(&buf);\n\tWSM_GET(&buf, fname, sizeof(fname));\n\n\tif (reason < 4)\n\t\twiphy_err(priv->hw->wiphy,\n\t\t\t  \"Firmware exception: %s.\\n\",\n\t\t\t  reason_str[reason]);\n\telse\n\t\twiphy_err(priv->hw->wiphy,\n\t\t\t  \"Firmware assert at %.*s, line %d\\n\",\n\t\t\t  (int) sizeof(fname), fname, reg[1]);\n\n\tfor (i = 0; i < 12; i += 4)\n\t\twiphy_err(priv->hw->wiphy,\n\t\t\t  \"R%d: 0x%.8X, R%d: 0x%.8X, R%d: 0x%.8X, R%d: 0x%.8X,\\n\",\n\t\t\t  i + 0, reg[i + 0], i + 1, reg[i + 1],\n\t\t\t  i + 2, reg[i + 2], i + 3, reg[i + 3]);\n\twiphy_err(priv->hw->wiphy,\n\t\t  \"R12: 0x%.8X, SP: 0x%.8X, LR: 0x%.8X, PC: 0x%.8X,\\n\",\n\t\t  reg[i + 0], reg[i + 1], reg[i + 2], reg[i + 3]);\n\ti += 4;\n\twiphy_err(priv->hw->wiphy,\n\t\t  \"CPSR: 0x%.8X, SPSR: 0x%.8X\\n\",\n\t\t  reg[i + 0], reg[i + 1]);\n\n\tprint_hex_dump_bytes(\"R1: \", DUMP_PREFIX_NONE,\n\t\t\t     fname, sizeof(fname));\n\treturn 0;\n\nunderflow:\n\twiphy_err(priv->hw->wiphy, \"Firmware exception.\\n\");\n\tprint_hex_dump_bytes(\"Exception: \", DUMP_PREFIX_NONE,\n\t\t\t     data, len);\n\treturn -EINVAL;\n}\n\nint wsm_handle_rx(struct cw1200_common *priv, u16 id,\n\t\t  struct wsm_hdr *wsm, struct sk_buff **skb_p)\n{\n\tint ret = 0;\n\tstruct wsm_buf wsm_buf;\n\tint link_id = (id >> 6) & 0x0F;\n\n\t \n\tid &= ~WSM_TX_LINK_ID(WSM_TX_LINK_ID_MAX);\n\n\twsm_buf.begin = (u8 *)&wsm[0];\n\twsm_buf.data = (u8 *)&wsm[1];\n\twsm_buf.end = &wsm_buf.begin[__le16_to_cpu(wsm->len)];\n\n\tpr_debug(\"[WSM] <<< 0x%.4X (%td)\\n\", id,\n\t\t wsm_buf.end - wsm_buf.begin);\n\n\tif (id == WSM_TX_CONFIRM_IND_ID) {\n\t\tret = wsm_tx_confirm(priv, &wsm_buf, link_id);\n\t} else if (id == WSM_MULTI_TX_CONFIRM_ID) {\n\t\tret = wsm_multi_tx_confirm(priv, &wsm_buf, link_id);\n\t} else if (id & 0x0400) {\n\t\tvoid *wsm_arg;\n\t\tu16 wsm_cmd;\n\n\t\t \n\t\tspin_lock(&priv->wsm_cmd.lock);\n\t\twsm_arg = priv->wsm_cmd.arg;\n\t\twsm_cmd = priv->wsm_cmd.cmd &\n\t\t\t\t~WSM_TX_LINK_ID(WSM_TX_LINK_ID_MAX);\n\t\tpriv->wsm_cmd.cmd = 0xFFFF;\n\t\tspin_unlock(&priv->wsm_cmd.lock);\n\n\t\tif (WARN_ON((id & ~0x0400) != wsm_cmd)) {\n\t\t\t \n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\n\t\tswitch (id) {\n\t\tcase WSM_READ_MIB_RESP_ID:\n\t\t\tif (wsm_arg)\n\t\t\t\tret = wsm_read_mib_confirm(priv, wsm_arg,\n\t\t\t\t\t\t\t\t&wsm_buf);\n\t\t\tbreak;\n\t\tcase WSM_WRITE_MIB_RESP_ID:\n\t\t\tif (wsm_arg)\n\t\t\t\tret = wsm_write_mib_confirm(priv, wsm_arg,\n\t\t\t\t\t\t\t    &wsm_buf);\n\t\t\tbreak;\n\t\tcase WSM_START_SCAN_RESP_ID:\n\t\t\tif (wsm_arg)\n\t\t\t\tret = wsm_scan_started(priv, wsm_arg, &wsm_buf);\n\t\t\tbreak;\n\t\tcase WSM_CONFIGURATION_RESP_ID:\n\t\t\tif (wsm_arg)\n\t\t\t\tret = wsm_configuration_confirm(priv, wsm_arg,\n\t\t\t\t\t\t\t\t&wsm_buf);\n\t\t\tbreak;\n\t\tcase WSM_JOIN_RESP_ID:\n\t\t\tif (wsm_arg)\n\t\t\t\tret = wsm_join_confirm(priv, wsm_arg, &wsm_buf);\n\t\t\tbreak;\n\t\tcase WSM_STOP_SCAN_RESP_ID:\n\t\tcase WSM_RESET_RESP_ID:\n\t\tcase WSM_ADD_KEY_RESP_ID:\n\t\tcase WSM_REMOVE_KEY_RESP_ID:\n\t\tcase WSM_SET_PM_RESP_ID:\n\t\tcase WSM_SET_BSS_PARAMS_RESP_ID:\n\t\tcase 0x0412:  \n\t\tcase WSM_EDCA_PARAMS_RESP_ID:\n\t\tcase WSM_SWITCH_CHANNEL_RESP_ID:\n\t\tcase WSM_START_RESP_ID:\n\t\tcase WSM_BEACON_TRANSMIT_RESP_ID:\n\t\tcase 0x0419:  \n\t\tcase 0x041A:  \n\t\tcase 0x041B:  \n\t\tcase 0x041C:  \n\t\t\tWARN_ON(wsm_arg != NULL);\n\t\t\tret = wsm_generic_confirm(priv, wsm_arg, &wsm_buf);\n\t\t\tif (ret) {\n\t\t\t\twiphy_warn(priv->hw->wiphy,\n\t\t\t\t\t   \"wsm_generic_confirm failed for request 0x%04x.\\n\",\n\t\t\t\t\t   id & ~0x0400);\n\n\t\t\t\t \n\t\t\t\tif (priv->join_status >= CW1200_JOIN_STATUS_JOINING) {\n\t\t\t\t\twsm_lock_tx(priv);\n\t\t\t\t\tif (queue_work(priv->workqueue, &priv->unjoin_work) <= 0)\n\t\t\t\t\t\twsm_unlock_tx(priv);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\twiphy_warn(priv->hw->wiphy,\n\t\t\t\t   \"Unrecognized confirmation 0x%04x\\n\",\n\t\t\t\t   id & ~0x0400);\n\t\t}\n\n\t\tspin_lock(&priv->wsm_cmd.lock);\n\t\tpriv->wsm_cmd.ret = ret;\n\t\tpriv->wsm_cmd.done = 1;\n\t\tspin_unlock(&priv->wsm_cmd.lock);\n\n\t\tret = 0;  \n\n\t\twake_up(&priv->wsm_cmd_wq);\n\t} else if (id & 0x0800) {\n\t\tswitch (id) {\n\t\tcase WSM_STARTUP_IND_ID:\n\t\t\tret = wsm_startup_indication(priv, &wsm_buf);\n\t\t\tbreak;\n\t\tcase WSM_RECEIVE_IND_ID:\n\t\t\tret = wsm_receive_indication(priv, link_id,\n\t\t\t\t\t\t     &wsm_buf, skb_p);\n\t\t\tbreak;\n\t\tcase 0x0805:\n\t\t\tret = wsm_event_indication(priv, &wsm_buf);\n\t\t\tbreak;\n\t\tcase WSM_SCAN_COMPLETE_IND_ID:\n\t\t\tret = wsm_scan_complete_indication(priv, &wsm_buf);\n\t\t\tbreak;\n\t\tcase 0x0808:\n\t\t\tret = wsm_ba_timeout_indication(priv, &wsm_buf);\n\t\t\tbreak;\n\t\tcase 0x0809:\n\t\t\tret = wsm_set_pm_indication(priv, &wsm_buf);\n\t\t\tbreak;\n\t\tcase 0x080A:\n\t\t\tret = wsm_channel_switch_indication(priv, &wsm_buf);\n\t\t\tbreak;\n\t\tcase 0x080B:\n\t\t\tret = wsm_find_complete_indication(priv, &wsm_buf);\n\t\t\tbreak;\n\t\tcase 0x080C:\n\t\t\tret = wsm_suspend_resume_indication(priv,\n\t\t\t\t\tlink_id, &wsm_buf);\n\t\t\tbreak;\n\t\tcase 0x080F:\n\t\t\tret = wsm_join_complete_indication(priv, &wsm_buf);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"Unrecognised WSM ID %04x\\n\", id);\n\t\t}\n\t} else {\n\t\tWARN_ON(1);\n\t\tret = -EINVAL;\n\t}\nout:\n\treturn ret;\n}\n\nstatic bool wsm_handle_tx_data(struct cw1200_common *priv,\n\t\t\t       struct wsm_tx *wsm,\n\t\t\t       const struct ieee80211_tx_info *tx_info,\n\t\t\t       const struct cw1200_txpriv *txpriv,\n\t\t\t       struct cw1200_queue *queue)\n{\n\tbool handled = false;\n\tconst struct ieee80211_hdr *frame =\n\t\t(struct ieee80211_hdr *)&((u8 *)wsm)[txpriv->offset];\n\t__le16 fctl = frame->frame_control;\n\tenum {\n\t\tdo_probe,\n\t\tdo_drop,\n\t\tdo_wep,\n\t\tdo_tx,\n\t} action = do_tx;\n\n\tswitch (priv->mode) {\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (priv->join_status == CW1200_JOIN_STATUS_MONITOR)\n\t\t\taction = do_tx;\n\t\telse if (priv->join_status < CW1200_JOIN_STATUS_PRE_STA)\n\t\t\taction = do_drop;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\t\tif (!priv->join_status) {\n\t\t\taction = do_drop;\n\t\t} else if (!(BIT(txpriv->raw_link_id) &\n\t\t\t     (BIT(0) | priv->link_id_map))) {\n\t\t\twiphy_warn(priv->hw->wiphy,\n\t\t\t\t   \"A frame with expired link id is dropped.\\n\");\n\t\t\taction = do_drop;\n\t\t}\n\t\tif (cw1200_queue_get_generation(wsm->packet_id) >\n\t\t\t\tCW1200_MAX_REQUEUE_ATTEMPTS) {\n\t\t\t \n\t\t\twiphy_warn(priv->hw->wiphy,\n\t\t\t\t   \"Too many attempts to requeue a frame; dropped.\\n\");\n\t\t\taction = do_drop;\n\t\t}\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tif (priv->join_status != CW1200_JOIN_STATUS_IBSS)\n\t\t\taction = do_drop;\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\taction = do_tx;  \n\t\tbreak;\n\tcase NL80211_IFTYPE_MONITOR:\n\tdefault:\n\t\taction = do_drop;\n\t\tbreak;\n\t}\n\n\tif (action == do_tx) {\n\t\tif (ieee80211_is_nullfunc(fctl)) {\n\t\t\tspin_lock(&priv->bss_loss_lock);\n\t\t\tif (priv->bss_loss_state) {\n\t\t\t\tpriv->bss_loss_confirm_id = wsm->packet_id;\n\t\t\t\twsm->queue_id = WSM_QUEUE_VOICE;\n\t\t\t}\n\t\t\tspin_unlock(&priv->bss_loss_lock);\n\t\t} else if (ieee80211_is_probe_req(fctl)) {\n\t\t\taction = do_probe;\n\t\t} else if (ieee80211_is_deauth(fctl) &&\n\t\t\t   priv->mode != NL80211_IFTYPE_AP) {\n\t\t\tpr_debug(\"[WSM] Issue unjoin command due to tx deauth.\\n\");\n\t\t\twsm_lock_tx_async(priv);\n\t\t\tif (queue_work(priv->workqueue,\n\t\t\t\t       &priv->unjoin_work) <= 0)\n\t\t\t\twsm_unlock_tx(priv);\n\t\t} else if (ieee80211_has_protected(fctl) &&\n\t\t\t   tx_info->control.hw_key &&\n\t\t\t   tx_info->control.hw_key->keyidx != priv->wep_default_key_id &&\n\t\t\t   (tx_info->control.hw_key->cipher == WLAN_CIPHER_SUITE_WEP40 ||\n\t\t\t    tx_info->control.hw_key->cipher == WLAN_CIPHER_SUITE_WEP104)) {\n\t\t\taction = do_wep;\n\t\t}\n\t}\n\n\tswitch (action) {\n\tcase do_probe:\n\t\t \n\t\tpr_debug(\"[WSM] Convert probe request to scan.\\n\");\n\t\twsm_lock_tx_async(priv);\n\t\tpriv->pending_frame_id = wsm->packet_id;\n\t\tif (queue_delayed_work(priv->workqueue,\n\t\t\t\t       &priv->scan.probe_work, 0) <= 0)\n\t\t\twsm_unlock_tx(priv);\n\t\thandled = true;\n\t\tbreak;\n\tcase do_drop:\n\t\tpr_debug(\"[WSM] Drop frame (0x%.4X).\\n\", fctl);\n\t\tBUG_ON(cw1200_queue_remove(queue, wsm->packet_id));\n\t\thandled = true;\n\t\tbreak;\n\tcase do_wep:\n\t\tpr_debug(\"[WSM] Issue set_default_wep_key.\\n\");\n\t\twsm_lock_tx_async(priv);\n\t\tpriv->wep_default_key_id = tx_info->control.hw_key->keyidx;\n\t\tpriv->pending_frame_id = wsm->packet_id;\n\t\tif (queue_work(priv->workqueue, &priv->wep_key_work) <= 0)\n\t\t\twsm_unlock_tx(priv);\n\t\thandled = true;\n\t\tbreak;\n\tcase do_tx:\n\t\tpr_debug(\"[WSM] Transmit frame.\\n\");\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\treturn handled;\n}\n\nstatic int cw1200_get_prio_queue(struct cw1200_common *priv,\n\t\t\t\t u32 link_id_map, int *total)\n{\n\tstatic const int urgent = BIT(CW1200_LINK_ID_AFTER_DTIM) |\n\t\tBIT(CW1200_LINK_ID_UAPSD);\n\tstruct wsm_edca_queue_params *edca;\n\tunsigned score, best = -1;\n\tint winner = -1;\n\tint queued;\n\tint i;\n\n\t \n\tfor (i = 0; i < 4; ++i) {\n\t\tqueued = cw1200_queue_get_num_queued(&priv->tx_queue[i],\n\t\t\t\tlink_id_map);\n\t\tif (!queued)\n\t\t\tcontinue;\n\t\t*total += queued;\n\t\tedca = &priv->edca.params[i];\n\t\tscore = ((edca->aifns + edca->cwmin) << 16) +\n\t\t\t((edca->cwmax - edca->cwmin) *\n\t\t\t get_random_u16());\n\t\tif (score < best && (winner < 0 || i != 3)) {\n\t\t\tbest = score;\n\t\t\twinner = i;\n\t\t}\n\t}\n\n\t \n\tif (winner >= 0 && priv->tx_burst_idx >= 0 &&\n\t    winner != priv->tx_burst_idx &&\n\t    !cw1200_queue_get_num_queued(\n\t\t    &priv->tx_queue[winner],\n\t\t    link_id_map & urgent) &&\n\t    cw1200_queue_get_num_queued(\n\t\t    &priv->tx_queue[priv->tx_burst_idx],\n\t\t    link_id_map))\n\t\twinner = priv->tx_burst_idx;\n\n\treturn winner;\n}\n\nstatic int wsm_get_tx_queue_and_mask(struct cw1200_common *priv,\n\t\t\t\t     struct cw1200_queue **queue_p,\n\t\t\t\t     u32 *tx_allowed_mask_p,\n\t\t\t\t     bool *more)\n{\n\tint idx;\n\tu32 tx_allowed_mask;\n\tint total = 0;\n\n\t \n\tif (priv->tx_multicast) {\n\t\ttx_allowed_mask = BIT(CW1200_LINK_ID_AFTER_DTIM);\n\t\tidx = cw1200_get_prio_queue(priv,\n\t\t\t\ttx_allowed_mask, &total);\n\t\tif (idx >= 0) {\n\t\t\t*more = total > 1;\n\t\t\tgoto found;\n\t\t}\n\t}\n\n\t \n\ttx_allowed_mask = ~priv->sta_asleep_mask;\n\ttx_allowed_mask |= BIT(CW1200_LINK_ID_UAPSD);\n\tif (priv->sta_asleep_mask) {\n\t\ttx_allowed_mask |= priv->pspoll_mask;\n\t\ttx_allowed_mask &= ~BIT(CW1200_LINK_ID_AFTER_DTIM);\n\t} else {\n\t\ttx_allowed_mask |= BIT(CW1200_LINK_ID_AFTER_DTIM);\n\t}\n\tidx = cw1200_get_prio_queue(priv,\n\t\t\ttx_allowed_mask, &total);\n\tif (idx < 0)\n\t\treturn -ENOENT;\n\nfound:\n\t*queue_p = &priv->tx_queue[idx];\n\t*tx_allowed_mask_p = tx_allowed_mask;\n\treturn 0;\n}\n\nint wsm_get_tx(struct cw1200_common *priv, u8 **data,\n\t       size_t *tx_len, int *burst)\n{\n\tstruct wsm_tx *wsm = NULL;\n\tstruct ieee80211_tx_info *tx_info;\n\tstruct cw1200_queue *queue = NULL;\n\tint queue_num;\n\tu32 tx_allowed_mask = 0;\n\tconst struct cw1200_txpriv *txpriv = NULL;\n\tint count = 0;\n\n\t \n\tbool more = false;\n\n\tif (priv->wsm_cmd.ptr) {  \n\t\t++count;\n\t\tspin_lock(&priv->wsm_cmd.lock);\n\t\tBUG_ON(!priv->wsm_cmd.ptr);\n\t\t*data = priv->wsm_cmd.ptr;\n\t\t*tx_len = priv->wsm_cmd.len;\n\t\t*burst = 1;\n\t\tspin_unlock(&priv->wsm_cmd.lock);\n\t} else {\n\t\tfor (;;) {\n\t\t\tint ret;\n\n\t\t\tif (atomic_add_return(0, &priv->tx_lock))\n\t\t\t\tbreak;\n\n\t\t\tspin_lock_bh(&priv->ps_state_lock);\n\n\t\t\tret = wsm_get_tx_queue_and_mask(priv, &queue,\n\t\t\t\t\t\t\t&tx_allowed_mask, &more);\n\t\t\tqueue_num = queue - priv->tx_queue;\n\n\t\t\tif (priv->buffered_multicasts &&\n\t\t\t    (ret || !more) &&\n\t\t\t    (priv->tx_multicast || !priv->sta_asleep_mask)) {\n\t\t\t\tpriv->buffered_multicasts = false;\n\t\t\t\tif (priv->tx_multicast) {\n\t\t\t\t\tpriv->tx_multicast = false;\n\t\t\t\t\tqueue_work(priv->workqueue,\n\t\t\t\t\t\t   &priv->multicast_stop_work);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tspin_unlock_bh(&priv->ps_state_lock);\n\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\tif (cw1200_queue_get(queue,\n\t\t\t\t\t     tx_allowed_mask,\n\t\t\t\t\t     &wsm, &tx_info, &txpriv))\n\t\t\t\tcontinue;\n\n\t\t\tif (wsm_handle_tx_data(priv, wsm,\n\t\t\t\t\t       tx_info, txpriv, queue))\n\t\t\t\tcontinue;   \n\n\t\t\twsm->hdr.id &= __cpu_to_le16(\n\t\t\t\t~WSM_TX_LINK_ID(WSM_TX_LINK_ID_MAX));\n\t\t\twsm->hdr.id |= cpu_to_le16(\n\t\t\t\tWSM_TX_LINK_ID(txpriv->raw_link_id));\n\t\t\tpriv->pspoll_mask &= ~BIT(txpriv->raw_link_id);\n\n\t\t\t*data = (u8 *)wsm;\n\t\t\t*tx_len = __le16_to_cpu(wsm->hdr.len);\n\n\t\t\t \n\t\t\tif (priv->edca.params[queue_num].txop_limit)\n\t\t\t\t*burst = min(*burst,\n\t\t\t\t\t     (int)cw1200_queue_get_num_queued(queue, tx_allowed_mask) + 1);\n\t\t\telse\n\t\t\t\t*burst = 1;\n\n\t\t\t \n\t\t\tif (*burst > 1)\n\t\t\t\tpriv->tx_burst_idx = queue_num;\n\t\t\telse\n\t\t\t\tpriv->tx_burst_idx = -1;\n\n\t\t\tif (more) {\n\t\t\t\tstruct ieee80211_hdr *hdr =\n\t\t\t\t\t(struct ieee80211_hdr *)\n\t\t\t\t\t&((u8 *)wsm)[txpriv->offset];\n\t\t\t\t \n\t\t\t\thdr->frame_control |=\n\t\t\t\t\tcpu_to_le16(IEEE80211_FCTL_MOREDATA);\n\t\t\t}\n\n\t\t\tpr_debug(\"[WSM] >>> 0x%.4X (%zu) %p %c\\n\",\n\t\t\t\t 0x0004, *tx_len, *data,\n\t\t\t\t wsm->more ? 'M' : ' ');\n\t\t\t++count;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn count;\n}\n\nvoid wsm_txed(struct cw1200_common *priv, u8 *data)\n{\n\tif (data == priv->wsm_cmd.ptr) {\n\t\tspin_lock(&priv->wsm_cmd.lock);\n\t\tpriv->wsm_cmd.ptr = NULL;\n\t\tspin_unlock(&priv->wsm_cmd.lock);\n\t}\n}\n\n \n \n\nvoid wsm_buf_init(struct wsm_buf *buf)\n{\n\tBUG_ON(buf->begin);\n\tbuf->begin = kmalloc(FWLOAD_BLOCK_SIZE, GFP_KERNEL | GFP_DMA);\n\tbuf->end = buf->begin ? &buf->begin[FWLOAD_BLOCK_SIZE] : buf->begin;\n\twsm_buf_reset(buf);\n}\n\nvoid wsm_buf_deinit(struct wsm_buf *buf)\n{\n\tkfree(buf->begin);\n\tbuf->begin = buf->data = buf->end = NULL;\n}\n\nstatic void wsm_buf_reset(struct wsm_buf *buf)\n{\n\tif (buf->begin) {\n\t\tbuf->data = &buf->begin[4];\n\t\t*(u32 *)buf->begin = 0;\n\t} else {\n\t\tbuf->data = buf->begin;\n\t}\n}\n\nstatic int wsm_buf_reserve(struct wsm_buf *buf, size_t extra_size)\n{\n\tsize_t pos = buf->data - buf->begin;\n\tsize_t size = pos + extra_size;\n\tu8 *tmp;\n\n\tsize = round_up(size, FWLOAD_BLOCK_SIZE);\n\n\ttmp = krealloc(buf->begin, size, GFP_KERNEL | GFP_DMA);\n\tif (!tmp) {\n\t\twsm_buf_deinit(buf);\n\t\treturn -ENOMEM;\n\t}\n\n\tbuf->begin = tmp;\n\tbuf->data = &buf->begin[pos];\n\tbuf->end = &buf->begin[size];\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}