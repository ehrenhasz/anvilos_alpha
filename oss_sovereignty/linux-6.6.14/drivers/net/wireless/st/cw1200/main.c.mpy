{
  "module_name": "main.c",
  "hash_id": "e23c4bfb8e053e570f73860357a65bffdf704f77add596e0f85fc70ad9e7e658",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/st/cw1200/main.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/firmware.h>\n#include <linux/etherdevice.h>\n#include <linux/vmalloc.h>\n#include <linux/random.h>\n#include <linux/sched.h>\n#include <net/mac80211.h>\n\n#include \"cw1200.h\"\n#include \"txrx.h\"\n#include \"hwbus.h\"\n#include \"fwio.h\"\n#include \"hwio.h\"\n#include \"bh.h\"\n#include \"sta.h\"\n#include \"scan.h\"\n#include \"debug.h\"\n#include \"pm.h\"\n\nMODULE_AUTHOR(\"Dmitry Tarnyagin <dmitry.tarnyagin@lockless.no>\");\nMODULE_DESCRIPTION(\"Softmac ST-Ericsson CW1200 common code\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"cw1200_core\");\n\n \nstatic u8 cw1200_mac_template[ETH_ALEN] = {0x02, 0x80, 0xe1, 0x00, 0x00, 0x00};\nmodule_param_array_named(macaddr, cw1200_mac_template, byte, NULL, 0444);\nMODULE_PARM_DESC(macaddr, \"Override platform_data MAC address\");\n\nstatic char *cw1200_sdd_path;\nmodule_param(cw1200_sdd_path, charp, 0644);\nMODULE_PARM_DESC(cw1200_sdd_path, \"Override platform_data SDD file\");\nstatic int cw1200_refclk;\nmodule_param(cw1200_refclk, int, 0644);\nMODULE_PARM_DESC(cw1200_refclk, \"Override platform_data reference clock\");\n\nint cw1200_power_mode = wsm_power_mode_quiescent;\nmodule_param(cw1200_power_mode, int, 0644);\nMODULE_PARM_DESC(cw1200_power_mode, \"WSM power mode.  0 == active, 1 == doze, 2 == quiescent (default)\");\n\n#define RATETAB_ENT(_rate, _rateid, _flags)\t\t\\\n\t{\t\t\t\t\t\t\\\n\t\t.bitrate\t= (_rate),\t\t\\\n\t\t.hw_value\t= (_rateid),\t\t\\\n\t\t.flags\t\t= (_flags),\t\t\\\n\t}\n\nstatic struct ieee80211_rate cw1200_rates[] = {\n\tRATETAB_ENT(10,  0,   0),\n\tRATETAB_ENT(20,  1,   0),\n\tRATETAB_ENT(55,  2,   0),\n\tRATETAB_ENT(110, 3,   0),\n\tRATETAB_ENT(60,  6,  0),\n\tRATETAB_ENT(90,  7,  0),\n\tRATETAB_ENT(120, 8,  0),\n\tRATETAB_ENT(180, 9,  0),\n\tRATETAB_ENT(240, 10, 0),\n\tRATETAB_ENT(360, 11, 0),\n\tRATETAB_ENT(480, 12, 0),\n\tRATETAB_ENT(540, 13, 0),\n};\n\nstatic struct ieee80211_rate cw1200_mcs_rates[] = {\n\tRATETAB_ENT(65,  14, IEEE80211_TX_RC_MCS),\n\tRATETAB_ENT(130, 15, IEEE80211_TX_RC_MCS),\n\tRATETAB_ENT(195, 16, IEEE80211_TX_RC_MCS),\n\tRATETAB_ENT(260, 17, IEEE80211_TX_RC_MCS),\n\tRATETAB_ENT(390, 18, IEEE80211_TX_RC_MCS),\n\tRATETAB_ENT(520, 19, IEEE80211_TX_RC_MCS),\n\tRATETAB_ENT(585, 20, IEEE80211_TX_RC_MCS),\n\tRATETAB_ENT(650, 21, IEEE80211_TX_RC_MCS),\n};\n\n#define cw1200_a_rates\t\t(cw1200_rates + 4)\n#define cw1200_a_rates_size\t(ARRAY_SIZE(cw1200_rates) - 4)\n#define cw1200_g_rates\t\t(cw1200_rates + 0)\n#define cw1200_g_rates_size\t(ARRAY_SIZE(cw1200_rates))\n#define cw1200_n_rates\t\t(cw1200_mcs_rates)\n#define cw1200_n_rates_size\t(ARRAY_SIZE(cw1200_mcs_rates))\n\n\n#define CHAN2G(_channel, _freq, _flags) {\t\t\t\\\n\t.band\t\t\t= NL80211_BAND_2GHZ,\t\t\\\n\t.center_freq\t\t= (_freq),\t\t\t\\\n\t.hw_value\t\t= (_channel),\t\t\t\\\n\t.flags\t\t\t= (_flags),\t\t\t\\\n\t.max_antenna_gain\t= 0,\t\t\t\t\\\n\t.max_power\t\t= 30,\t\t\t\t\\\n}\n\n#define CHAN5G(_channel, _flags) {\t\t\t\t\\\n\t.band\t\t\t= NL80211_BAND_5GHZ,\t\t\\\n\t.center_freq\t= 5000 + (5 * (_channel)),\t\t\\\n\t.hw_value\t\t= (_channel),\t\t\t\\\n\t.flags\t\t\t= (_flags),\t\t\t\\\n\t.max_antenna_gain\t= 0,\t\t\t\t\\\n\t.max_power\t\t= 30,\t\t\t\t\\\n}\n\nstatic struct ieee80211_channel cw1200_2ghz_chantable[] = {\n\tCHAN2G(1, 2412, 0),\n\tCHAN2G(2, 2417, 0),\n\tCHAN2G(3, 2422, 0),\n\tCHAN2G(4, 2427, 0),\n\tCHAN2G(5, 2432, 0),\n\tCHAN2G(6, 2437, 0),\n\tCHAN2G(7, 2442, 0),\n\tCHAN2G(8, 2447, 0),\n\tCHAN2G(9, 2452, 0),\n\tCHAN2G(10, 2457, 0),\n\tCHAN2G(11, 2462, 0),\n\tCHAN2G(12, 2467, 0),\n\tCHAN2G(13, 2472, 0),\n\tCHAN2G(14, 2484, 0),\n};\n\nstatic struct ieee80211_channel cw1200_5ghz_chantable[] = {\n\tCHAN5G(34, 0),\t\tCHAN5G(36, 0),\n\tCHAN5G(38, 0),\t\tCHAN5G(40, 0),\n\tCHAN5G(42, 0),\t\tCHAN5G(44, 0),\n\tCHAN5G(46, 0),\t\tCHAN5G(48, 0),\n\tCHAN5G(52, 0),\t\tCHAN5G(56, 0),\n\tCHAN5G(60, 0),\t\tCHAN5G(64, 0),\n\tCHAN5G(100, 0),\t\tCHAN5G(104, 0),\n\tCHAN5G(108, 0),\t\tCHAN5G(112, 0),\n\tCHAN5G(116, 0),\t\tCHAN5G(120, 0),\n\tCHAN5G(124, 0),\t\tCHAN5G(128, 0),\n\tCHAN5G(132, 0),\t\tCHAN5G(136, 0),\n\tCHAN5G(140, 0),\t\tCHAN5G(149, 0),\n\tCHAN5G(153, 0),\t\tCHAN5G(157, 0),\n\tCHAN5G(161, 0),\t\tCHAN5G(165, 0),\n\tCHAN5G(184, 0),\t\tCHAN5G(188, 0),\n\tCHAN5G(192, 0),\t\tCHAN5G(196, 0),\n\tCHAN5G(200, 0),\t\tCHAN5G(204, 0),\n\tCHAN5G(208, 0),\t\tCHAN5G(212, 0),\n\tCHAN5G(216, 0),\n};\n\nstatic struct ieee80211_supported_band cw1200_band_2ghz = {\n\t.channels = cw1200_2ghz_chantable,\n\t.n_channels = ARRAY_SIZE(cw1200_2ghz_chantable),\n\t.bitrates = cw1200_g_rates,\n\t.n_bitrates = cw1200_g_rates_size,\n\t.ht_cap = {\n\t\t.cap = IEEE80211_HT_CAP_GRN_FLD |\n\t\t\t(1 << IEEE80211_HT_CAP_RX_STBC_SHIFT) |\n\t\t\tIEEE80211_HT_CAP_MAX_AMSDU,\n\t\t.ht_supported = 1,\n\t\t.ampdu_factor = IEEE80211_HT_MAX_AMPDU_8K,\n\t\t.ampdu_density = IEEE80211_HT_MPDU_DENSITY_NONE,\n\t\t.mcs = {\n\t\t\t.rx_mask[0] = 0xFF,\n\t\t\t.rx_highest = __cpu_to_le16(0x41),\n\t\t\t.tx_params = IEEE80211_HT_MCS_TX_DEFINED,\n\t\t},\n\t},\n};\n\nstatic struct ieee80211_supported_band cw1200_band_5ghz = {\n\t.channels = cw1200_5ghz_chantable,\n\t.n_channels = ARRAY_SIZE(cw1200_5ghz_chantable),\n\t.bitrates = cw1200_a_rates,\n\t.n_bitrates = cw1200_a_rates_size,\n\t.ht_cap = {\n\t\t.cap = IEEE80211_HT_CAP_GRN_FLD |\n\t\t\t(1 << IEEE80211_HT_CAP_RX_STBC_SHIFT) |\n\t\t\tIEEE80211_HT_CAP_MAX_AMSDU,\n\t\t.ht_supported = 1,\n\t\t.ampdu_factor = IEEE80211_HT_MAX_AMPDU_8K,\n\t\t.ampdu_density = IEEE80211_HT_MPDU_DENSITY_NONE,\n\t\t.mcs = {\n\t\t\t.rx_mask[0] = 0xFF,\n\t\t\t.rx_highest = __cpu_to_le16(0x41),\n\t\t\t.tx_params = IEEE80211_HT_MCS_TX_DEFINED,\n\t\t},\n\t},\n};\n\nstatic const unsigned long cw1200_ttl[] = {\n\t1 * HZ,\t \n\t2 * HZ,\t \n\t5 * HZ,  \n\t10 * HZ\t \n};\n\nstatic const struct ieee80211_ops cw1200_ops = {\n\t.start\t\t\t= cw1200_start,\n\t.stop\t\t\t= cw1200_stop,\n\t.add_interface\t\t= cw1200_add_interface,\n\t.remove_interface\t= cw1200_remove_interface,\n\t.change_interface\t= cw1200_change_interface,\n\t.tx\t\t\t= cw1200_tx,\n\t.wake_tx_queue\t\t= ieee80211_handle_wake_tx_queue,\n\t.hw_scan\t\t= cw1200_hw_scan,\n\t.set_tim\t\t= cw1200_set_tim,\n\t.sta_notify\t\t= cw1200_sta_notify,\n\t.sta_add\t\t= cw1200_sta_add,\n\t.sta_remove\t\t= cw1200_sta_remove,\n\t.set_key\t\t= cw1200_set_key,\n\t.set_rts_threshold\t= cw1200_set_rts_threshold,\n\t.config\t\t\t= cw1200_config,\n\t.bss_info_changed\t= cw1200_bss_info_changed,\n\t.prepare_multicast\t= cw1200_prepare_multicast,\n\t.configure_filter\t= cw1200_configure_filter,\n\t.conf_tx\t\t= cw1200_conf_tx,\n\t.get_stats\t\t= cw1200_get_stats,\n\t.ampdu_action\t\t= cw1200_ampdu_action,\n\t.flush\t\t\t= cw1200_flush,\n#ifdef CONFIG_PM\n\t.suspend\t\t= cw1200_wow_suspend,\n\t.resume\t\t\t= cw1200_wow_resume,\n#endif\n\t \n\t \n\t \n\t \n};\n\nstatic int cw1200_ba_rx_tids = -1;\nstatic int cw1200_ba_tx_tids = -1;\nmodule_param(cw1200_ba_rx_tids, int, 0644);\nmodule_param(cw1200_ba_tx_tids, int, 0644);\nMODULE_PARM_DESC(cw1200_ba_rx_tids, \"Block ACK RX TIDs\");\nMODULE_PARM_DESC(cw1200_ba_tx_tids, \"Block ACK TX TIDs\");\n\n#ifdef CONFIG_PM\nstatic const struct wiphy_wowlan_support cw1200_wowlan_support = {\n\t \n\t.flags = WIPHY_WOWLAN_ANY | WIPHY_WOWLAN_DISCONNECT,\n};\n#endif\n\n\nstatic struct ieee80211_hw *cw1200_init_common(const u8 *macaddr,\n\t\t\t\t\t\tconst bool have_5ghz)\n{\n\tint i, band;\n\tstruct ieee80211_hw *hw;\n\tstruct cw1200_common *priv;\n\n\thw = ieee80211_alloc_hw(sizeof(struct cw1200_common), &cw1200_ops);\n\tif (!hw)\n\t\treturn NULL;\n\n\tpriv = hw->priv;\n\tpriv->hw = hw;\n\tpriv->hw_type = -1;\n\tpriv->mode = NL80211_IFTYPE_UNSPECIFIED;\n\tpriv->rates = cw1200_rates;  \n\tpriv->mcs_rates = cw1200_n_rates;\n\tif (cw1200_ba_rx_tids != -1)\n\t\tpriv->ba_rx_tid_mask = cw1200_ba_rx_tids;\n\telse\n\t\tpriv->ba_rx_tid_mask = 0xFF;  \n\tif (cw1200_ba_tx_tids != -1)\n\t\tpriv->ba_tx_tid_mask = cw1200_ba_tx_tids;\n\telse\n\t\tpriv->ba_tx_tid_mask = 0xff;  \n\n\tieee80211_hw_set(hw, NEED_DTIM_BEFORE_ASSOC);\n\tieee80211_hw_set(hw, TX_AMPDU_SETUP_IN_HW);\n\tieee80211_hw_set(hw, AMPDU_AGGREGATION);\n\tieee80211_hw_set(hw, CONNECTION_MONITOR);\n\tieee80211_hw_set(hw, REPORTS_TX_ACK_STATUS);\n\tieee80211_hw_set(hw, SUPPORTS_DYNAMIC_PS);\n\tieee80211_hw_set(hw, SIGNAL_DBM);\n\tieee80211_hw_set(hw, SUPPORTS_PS);\n\n\thw->wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |\n\t\t\t\t\t  BIT(NL80211_IFTYPE_ADHOC) |\n\t\t\t\t\t  BIT(NL80211_IFTYPE_AP) |\n\t\t\t\t\t  BIT(NL80211_IFTYPE_MESH_POINT) |\n\t\t\t\t\t  BIT(NL80211_IFTYPE_P2P_CLIENT) |\n\t\t\t\t\t  BIT(NL80211_IFTYPE_P2P_GO);\n\n#ifdef CONFIG_PM\n\thw->wiphy->wowlan = &cw1200_wowlan_support;\n#endif\n\n\thw->wiphy->flags |= WIPHY_FLAG_AP_UAPSD;\n\n\thw->queues = 4;\n\n\tpriv->rts_threshold = -1;\n\n\thw->max_rates = 8;\n\thw->max_rate_tries = 15;\n\thw->extra_tx_headroom = WSM_TX_EXTRA_HEADROOM +\n\t\t8;   \n\n\thw->sta_data_size = sizeof(struct cw1200_sta_priv);\n\n\thw->wiphy->bands[NL80211_BAND_2GHZ] = &cw1200_band_2ghz;\n\tif (have_5ghz)\n\t\thw->wiphy->bands[NL80211_BAND_5GHZ] = &cw1200_band_5ghz;\n\n\t \n\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\tstruct ieee80211_supported_band *sband = hw->wiphy->bands[band];\n\t\tif (!sband)\n\t\t\tcontinue;\n\t\tfor (i = 0; i < sband->n_channels; i++) {\n\t\t\tsband->channels[i].flags = 0;\n\t\t\tsband->channels[i].max_antenna_gain = 0;\n\t\t\tsband->channels[i].max_power = 30;\n\t\t}\n\t}\n\n\thw->wiphy->max_scan_ssids = 2;\n\thw->wiphy->max_scan_ie_len = IEEE80211_MAX_DATA_LEN;\n\n\tif (macaddr)\n\t\tSET_IEEE80211_PERM_ADDR(hw, (u8 *)macaddr);\n\telse\n\t\tSET_IEEE80211_PERM_ADDR(hw, cw1200_mac_template);\n\n\t \n\tif (hw->wiphy->perm_addr[3] == 0 &&\n\t    hw->wiphy->perm_addr[4] == 0 &&\n\t    hw->wiphy->perm_addr[5] == 0) {\n\t\tget_random_bytes(&hw->wiphy->perm_addr[3], 3);\n\t}\n\n\tmutex_init(&priv->wsm_cmd_mux);\n\tmutex_init(&priv->conf_mutex);\n\tpriv->workqueue = create_singlethread_workqueue(\"cw1200_wq\");\n\tif (!priv->workqueue) {\n\t\tieee80211_free_hw(hw);\n\t\treturn NULL;\n\t}\n\n\tsema_init(&priv->scan.lock, 1);\n\tINIT_WORK(&priv->scan.work, cw1200_scan_work);\n\tINIT_DELAYED_WORK(&priv->scan.probe_work, cw1200_probe_work);\n\tINIT_DELAYED_WORK(&priv->scan.timeout, cw1200_scan_timeout);\n\tINIT_DELAYED_WORK(&priv->clear_recent_scan_work,\n\t\t\t  cw1200_clear_recent_scan_work);\n\tINIT_DELAYED_WORK(&priv->join_timeout, cw1200_join_timeout);\n\tINIT_WORK(&priv->unjoin_work, cw1200_unjoin_work);\n\tINIT_WORK(&priv->join_complete_work, cw1200_join_complete_work);\n\tINIT_WORK(&priv->wep_key_work, cw1200_wep_key_work);\n\tINIT_WORK(&priv->tx_policy_upload_work, tx_policy_upload_work);\n\tspin_lock_init(&priv->event_queue_lock);\n\tINIT_LIST_HEAD(&priv->event_queue);\n\tINIT_WORK(&priv->event_handler, cw1200_event_handler);\n\tINIT_DELAYED_WORK(&priv->bss_loss_work, cw1200_bss_loss_work);\n\tINIT_WORK(&priv->bss_params_work, cw1200_bss_params_work);\n\tspin_lock_init(&priv->bss_loss_lock);\n\tspin_lock_init(&priv->ps_state_lock);\n\tINIT_WORK(&priv->set_cts_work, cw1200_set_cts_work);\n\tINIT_WORK(&priv->set_tim_work, cw1200_set_tim_work);\n\tINIT_WORK(&priv->multicast_start_work, cw1200_multicast_start_work);\n\tINIT_WORK(&priv->multicast_stop_work, cw1200_multicast_stop_work);\n\tINIT_WORK(&priv->link_id_work, cw1200_link_id_work);\n\tINIT_DELAYED_WORK(&priv->link_id_gc_work, cw1200_link_id_gc_work);\n\tINIT_WORK(&priv->linkid_reset_work, cw1200_link_id_reset);\n\tINIT_WORK(&priv->update_filtering_work, cw1200_update_filtering_work);\n\tINIT_WORK(&priv->set_beacon_wakeup_period_work,\n\t\t  cw1200_set_beacon_wakeup_period_work);\n\ttimer_setup(&priv->mcast_timeout, cw1200_mcast_timeout, 0);\n\n\tif (cw1200_queue_stats_init(&priv->tx_queue_stats,\n\t\t\t\t    CW1200_LINK_ID_MAX,\n\t\t\t\t    cw1200_skb_dtor,\n\t\t\t\t    priv)) {\n\t\tdestroy_workqueue(priv->workqueue);\n\t\tieee80211_free_hw(hw);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < 4; ++i) {\n\t\tif (cw1200_queue_init(&priv->tx_queue[i],\n\t\t\t\t      &priv->tx_queue_stats, i, 16,\n\t\t\t\t      cw1200_ttl[i])) {\n\t\t\tfor (; i > 0; i--)\n\t\t\t\tcw1200_queue_deinit(&priv->tx_queue[i - 1]);\n\t\t\tcw1200_queue_stats_deinit(&priv->tx_queue_stats);\n\t\t\tdestroy_workqueue(priv->workqueue);\n\t\t\tieee80211_free_hw(hw);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tinit_waitqueue_head(&priv->channel_switch_done);\n\tinit_waitqueue_head(&priv->wsm_cmd_wq);\n\tinit_waitqueue_head(&priv->wsm_startup_done);\n\tinit_waitqueue_head(&priv->ps_mode_switch_done);\n\twsm_buf_init(&priv->wsm_cmd_buf);\n\tspin_lock_init(&priv->wsm_cmd.lock);\n\tpriv->wsm_cmd.done = 1;\n\ttx_policy_init(priv);\n\n\treturn hw;\n}\n\nstatic int cw1200_register_common(struct ieee80211_hw *dev)\n{\n\tstruct cw1200_common *priv = dev->priv;\n\tint err;\n\n#ifdef CONFIG_PM\n\terr = cw1200_pm_init(&priv->pm_state, priv);\n\tif (err) {\n\t\tpr_err(\"Cannot init PM. (%d).\\n\",\n\t\t       err);\n\t\treturn err;\n\t}\n#endif\n\n\terr = ieee80211_register_hw(dev);\n\tif (err) {\n\t\tpr_err(\"Cannot register device (%d).\\n\",\n\t\t       err);\n#ifdef CONFIG_PM\n\t\tcw1200_pm_deinit(&priv->pm_state);\n#endif\n\t\treturn err;\n\t}\n\n\tcw1200_debug_init(priv);\n\n\tpr_info(\"Registered as '%s'\\n\", wiphy_name(dev->wiphy));\n\treturn 0;\n}\n\nstatic void cw1200_free_common(struct ieee80211_hw *dev)\n{\n\tieee80211_free_hw(dev);\n}\n\nstatic void cw1200_unregister_common(struct ieee80211_hw *dev)\n{\n\tstruct cw1200_common *priv = dev->priv;\n\tint i;\n\n\tieee80211_unregister_hw(dev);\n\n\tdel_timer_sync(&priv->mcast_timeout);\n\tcw1200_unregister_bh(priv);\n\n\tcw1200_debug_release(priv);\n\n\tmutex_destroy(&priv->conf_mutex);\n\n\twsm_buf_deinit(&priv->wsm_cmd_buf);\n\n\tdestroy_workqueue(priv->workqueue);\n\tpriv->workqueue = NULL;\n\n\tif (priv->sdd) {\n\t\trelease_firmware(priv->sdd);\n\t\tpriv->sdd = NULL;\n\t}\n\n\tfor (i = 0; i < 4; ++i)\n\t\tcw1200_queue_deinit(&priv->tx_queue[i]);\n\n\tcw1200_queue_stats_deinit(&priv->tx_queue_stats);\n#ifdef CONFIG_PM\n\tcw1200_pm_deinit(&priv->pm_state);\n#endif\n}\n\n \nu32 cw1200_dpll_from_clk(u16 clk_khz)\n{\n\tswitch (clk_khz) {\n\tcase 0x32C8:  \n\t\treturn 0x1D89D241;\n\tcase 0x3E80:  \n\t\treturn 0x000001E1;\n\tcase 0x41A0:  \n\t\treturn 0x124931C1;\n\tcase 0x4B00:  \n\t\treturn 0x00000191;\n\tcase 0x5DC0:  \n\t\treturn 0x00000141;\n\tcase 0x6590:  \n\t\treturn 0x0EC4F121;\n\tcase 0x8340:  \n\t\treturn 0x092490E1;\n\tcase 0x9600:  \n\t\treturn 0x100010C1;\n\tcase 0x9C40:  \n\t\treturn 0x000000C1;\n\tcase 0xBB80:  \n\t\treturn 0x000000A1;\n\tcase 0xCB20:  \n\t\treturn 0x07627091;\n\tdefault:\n\t\tpr_err(\"Unknown Refclk freq (0x%04x), using 26000KHz\\n\",\n\t\t       clk_khz);\n\t\treturn 0x0EC4F121;\n\t}\n}\n\nint cw1200_core_probe(const struct hwbus_ops *hwbus_ops,\n\t\t      struct hwbus_priv *hwbus,\n\t\t      struct device *pdev,\n\t\t      struct cw1200_common **core,\n\t\t      int ref_clk, const u8 *macaddr,\n\t\t      const char *sdd_path, bool have_5ghz)\n{\n\tint err = -EINVAL;\n\tstruct ieee80211_hw *dev;\n\tstruct cw1200_common *priv;\n\tstruct wsm_operational_mode mode = {\n\t\t.power_mode = cw1200_power_mode,\n\t\t.disable_more_flag_usage = true,\n\t};\n\n\tdev = cw1200_init_common(macaddr, have_5ghz);\n\tif (!dev)\n\t\tgoto err;\n\n\tpriv = dev->priv;\n\tpriv->hw_refclk = ref_clk;\n\tif (cw1200_refclk)\n\t\tpriv->hw_refclk = cw1200_refclk;\n\n\tpriv->sdd_path = (char *)sdd_path;\n\tif (cw1200_sdd_path)\n\t\tpriv->sdd_path = cw1200_sdd_path;\n\n\tpriv->hwbus_ops = hwbus_ops;\n\tpriv->hwbus_priv = hwbus;\n\tpriv->pdev = pdev;\n\tSET_IEEE80211_DEV(priv->hw, pdev);\n\n\t \n\t*core = priv;\n\n\terr = cw1200_register_bh(priv);\n\tif (err)\n\t\tgoto err1;\n\n\terr = cw1200_load_firmware(priv);\n\tif (err)\n\t\tgoto err2;\n\n\tif (wait_event_interruptible_timeout(priv->wsm_startup_done,\n\t\t\t\t\t     priv->firmware_ready,\n\t\t\t\t\t     3*HZ) <= 0) {\n\t\t \n\t\tpr_err(\"Timeout waiting on device startup\\n\");\n\t\terr = -ETIMEDOUT;\n\t\tgoto err2;\n\t}\n\n\t \n\twsm_set_operational_mode(priv, &mode);\n\n\t \n\twsm_use_multi_tx_conf(priv, true);\n\n\terr = cw1200_register_common(dev);\n\tif (err)\n\t\tgoto err2;\n\n\treturn err;\n\nerr2:\n\tcw1200_unregister_bh(priv);\nerr1:\n\tcw1200_free_common(dev);\nerr:\n\t*core = NULL;\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(cw1200_core_probe);\n\nvoid cw1200_core_release(struct cw1200_common *self)\n{\n\t \n\tself->hwbus_ops->lock(self->hwbus_priv);\n\t__cw1200_irq_enable(self, 0);\n\tself->hwbus_ops->unlock(self->hwbus_priv);\n\n\t \n\tcw1200_unregister_common(self->hw);\n\tcw1200_free_common(self->hw);\n\treturn;\n}\nEXPORT_SYMBOL_GPL(cw1200_core_release);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}