{
  "module_name": "sta.c",
  "hash_id": "7c4c0065eeaf137131e02e584fb3262fcea2daf68c04966bac5f795efe2b01a7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/st/cw1200/sta.c",
  "human_readable_source": "\n \n\n#include <linux/vmalloc.h>\n#include <linux/sched.h>\n#include <linux/firmware.h>\n#include <linux/module.h>\n#include <linux/etherdevice.h>\n\n#include \"cw1200.h\"\n#include \"sta.h\"\n#include \"fwio.h\"\n#include \"bh.h\"\n#include \"debug.h\"\n\n#ifndef ERP_INFO_BYTE_OFFSET\n#define ERP_INFO_BYTE_OFFSET 2\n#endif\n\nstatic void cw1200_do_join(struct cw1200_common *priv);\nstatic void cw1200_do_unjoin(struct cw1200_common *priv);\n\nstatic int cw1200_upload_beacon(struct cw1200_common *priv);\nstatic int cw1200_upload_pspoll(struct cw1200_common *priv);\nstatic int cw1200_upload_null(struct cw1200_common *priv);\nstatic int cw1200_upload_qosnull(struct cw1200_common *priv);\nstatic int cw1200_start_ap(struct cw1200_common *priv);\nstatic int cw1200_update_beaconing(struct cw1200_common *priv);\nstatic int cw1200_enable_beaconing(struct cw1200_common *priv,\n\t\t\t\t   bool enable);\nstatic void __cw1200_sta_notify(struct ieee80211_hw *dev,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tenum sta_notify_cmd notify_cmd,\n\t\t\t\tint link_id);\nstatic int __cw1200_flush(struct cw1200_common *priv, bool drop);\n\nstatic inline void __cw1200_free_event_queue(struct list_head *list)\n{\n\tstruct cw1200_wsm_event *event, *tmp;\n\tlist_for_each_entry_safe(event, tmp, list, link) {\n\t\tlist_del(&event->link);\n\t\tkfree(event);\n\t}\n}\n\n \n \n\nint cw1200_start(struct ieee80211_hw *dev)\n{\n\tstruct cw1200_common *priv = dev->priv;\n\tint ret = 0;\n\n\tcw1200_pm_stay_awake(&priv->pm_state, HZ);\n\n\tmutex_lock(&priv->conf_mutex);\n\n\t \n\tWSM_EDCA_SET(&priv->edca, 0, 0x0002, 0x0003, 0x0007, 47, 0xc8, false);\n\tWSM_EDCA_SET(&priv->edca, 1, 0x0002, 0x0007, 0x000f, 94, 0xc8, false);\n\tWSM_EDCA_SET(&priv->edca, 2, 0x0003, 0x000f, 0x03ff, 0, 0xc8, false);\n\tWSM_EDCA_SET(&priv->edca, 3, 0x0007, 0x000f, 0x03ff, 0, 0xc8, false);\n\tret = wsm_set_edca_params(priv, &priv->edca);\n\tif (ret)\n\t\tgoto out;\n\n\tret = cw1200_set_uapsd_param(priv, &priv->edca);\n\tif (ret)\n\t\tgoto out;\n\n\tpriv->setbssparams_done = false;\n\n\tmemcpy(priv->mac_addr, dev->wiphy->perm_addr, ETH_ALEN);\n\tpriv->mode = NL80211_IFTYPE_MONITOR;\n\tpriv->wep_default_key_id = -1;\n\n\tpriv->cqm_beacon_loss_count = 10;\n\n\tret = cw1200_setup_mac(priv);\n\tif (ret)\n\t\tgoto out;\n\nout:\n\tmutex_unlock(&priv->conf_mutex);\n\treturn ret;\n}\n\nvoid cw1200_stop(struct ieee80211_hw *dev)\n{\n\tstruct cw1200_common *priv = dev->priv;\n\tLIST_HEAD(list);\n\tint i;\n\n\twsm_lock_tx(priv);\n\n\twhile (down_trylock(&priv->scan.lock)) {\n\t\t \n\t\tpriv->scan.req = NULL;\n\t\tschedule();\n\t}\n\tup(&priv->scan.lock);\n\n\tcancel_delayed_work_sync(&priv->scan.probe_work);\n\tcancel_delayed_work_sync(&priv->scan.timeout);\n\tcancel_delayed_work_sync(&priv->clear_recent_scan_work);\n\tcancel_delayed_work_sync(&priv->join_timeout);\n\tcw1200_cqm_bssloss_sm(priv, 0, 0, 0);\n\tcancel_work_sync(&priv->unjoin_work);\n\tcancel_delayed_work_sync(&priv->link_id_gc_work);\n\tflush_workqueue(priv->workqueue);\n\tdel_timer_sync(&priv->mcast_timeout);\n\tmutex_lock(&priv->conf_mutex);\n\tpriv->mode = NL80211_IFTYPE_UNSPECIFIED;\n\tpriv->listening = false;\n\n\tspin_lock(&priv->event_queue_lock);\n\tlist_splice_init(&priv->event_queue, &list);\n\tspin_unlock(&priv->event_queue_lock);\n\t__cw1200_free_event_queue(&list);\n\n\n\tpriv->join_status = CW1200_JOIN_STATUS_PASSIVE;\n\tpriv->join_pending = false;\n\n\tfor (i = 0; i < 4; i++)\n\t\tcw1200_queue_clear(&priv->tx_queue[i]);\n\tmutex_unlock(&priv->conf_mutex);\n\ttx_policy_clean(priv);\n\n\t \n\tif (atomic_xchg(&priv->tx_lock, 1) != 1)\n\t\tpr_debug(\"[STA] TX is force-unlocked due to stop request.\\n\");\n\n\twsm_unlock_tx(priv);\n\tatomic_xchg(&priv->tx_lock, 0);  \n}\n\nstatic int cw1200_bssloss_mitigation = 1;\nmodule_param(cw1200_bssloss_mitigation, int, 0644);\nMODULE_PARM_DESC(cw1200_bssloss_mitigation, \"BSS Loss mitigation. 0 == disabled, 1 == enabled (default)\");\n\n\nvoid __cw1200_cqm_bssloss_sm(struct cw1200_common *priv,\n\t\t\t     int init, int good, int bad)\n{\n\tint tx = 0;\n\n\tpriv->delayed_link_loss = 0;\n\tcancel_work_sync(&priv->bss_params_work);\n\n\tpr_debug(\"[STA] CQM BSSLOSS_SM: state: %d init %d good %d bad: %d txlock: %d uj: %d\\n\",\n\t\t priv->bss_loss_state,\n\t\t init, good, bad,\n\t\t atomic_read(&priv->tx_lock),\n\t\t priv->delayed_unjoin);\n\n\t \n\tif (priv->delayed_unjoin)\n\t\treturn;\n\n\tif (init) {\n\t\tqueue_delayed_work(priv->workqueue,\n\t\t\t\t   &priv->bss_loss_work,\n\t\t\t\t   HZ);\n\t\tpriv->bss_loss_state = 0;\n\n\t\t \n\t\tif (!priv->vif->p2p && !atomic_read(&priv->tx_lock))\n\t\t\ttx = 1;\n\t} else if (good) {\n\t\tcancel_delayed_work_sync(&priv->bss_loss_work);\n\t\tpriv->bss_loss_state = 0;\n\t\tqueue_work(priv->workqueue, &priv->bss_params_work);\n\t} else if (bad) {\n\t\t \n\t\tif (priv->bss_loss_state < 3)\n\t\t\ttx = 1;\n\t} else {\n\t\tcancel_delayed_work_sync(&priv->bss_loss_work);\n\t\tpriv->bss_loss_state = 0;\n\t}\n\n\t \n\tif (!cw1200_bssloss_mitigation)\n\t\ttx = 0;\n\n\t \n\tif (tx) {\n\t\tstruct sk_buff *skb;\n\n\t\tpriv->bss_loss_state++;\n\n\t\tskb = ieee80211_nullfunc_get(priv->hw, priv->vif, -1, false);\n\t\tWARN_ON(!skb);\n\t\tif (skb)\n\t\t\tcw1200_tx(priv->hw, NULL, skb);\n\t}\n}\n\nint cw1200_add_interface(struct ieee80211_hw *dev,\n\t\t\t struct ieee80211_vif *vif)\n{\n\tint ret;\n\tstruct cw1200_common *priv = dev->priv;\n\t \n\n\tvif->driver_flags |= IEEE80211_VIF_BEACON_FILTER |\n\t\t\t     IEEE80211_VIF_SUPPORTS_UAPSD |\n\t\t\t     IEEE80211_VIF_SUPPORTS_CQM_RSSI;\n\n\tmutex_lock(&priv->conf_mutex);\n\n\tif (priv->mode != NL80211_IFTYPE_MONITOR) {\n\t\tmutex_unlock(&priv->conf_mutex);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_ADHOC:\n\tcase NL80211_IFTYPE_MESH_POINT:\n\tcase NL80211_IFTYPE_AP:\n\t\tpriv->mode = vif->type;\n\t\tbreak;\n\tdefault:\n\t\tmutex_unlock(&priv->conf_mutex);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tpriv->vif = vif;\n\tmemcpy(priv->mac_addr, vif->addr, ETH_ALEN);\n\tret = cw1200_setup_mac(priv);\n\t \n\t \n\n\tmutex_unlock(&priv->conf_mutex);\n\treturn ret;\n}\n\nvoid cw1200_remove_interface(struct ieee80211_hw *dev,\n\t\t\t     struct ieee80211_vif *vif)\n{\n\tstruct cw1200_common *priv = dev->priv;\n\tstruct wsm_reset reset = {\n\t\t.reset_statistics = true,\n\t};\n\tint i;\n\n\tmutex_lock(&priv->conf_mutex);\n\tswitch (priv->join_status) {\n\tcase CW1200_JOIN_STATUS_JOINING:\n\tcase CW1200_JOIN_STATUS_PRE_STA:\n\tcase CW1200_JOIN_STATUS_STA:\n\tcase CW1200_JOIN_STATUS_IBSS:\n\t\twsm_lock_tx(priv);\n\t\tif (queue_work(priv->workqueue, &priv->unjoin_work) <= 0)\n\t\t\twsm_unlock_tx(priv);\n\t\tbreak;\n\tcase CW1200_JOIN_STATUS_AP:\n\t\tfor (i = 0; priv->link_id_map; ++i) {\n\t\t\tif (priv->link_id_map & BIT(i)) {\n\t\t\t\treset.link_id = i;\n\t\t\t\twsm_reset(priv, &reset);\n\t\t\t\tpriv->link_id_map &= ~BIT(i);\n\t\t\t}\n\t\t}\n\t\tmemset(priv->link_id_db, 0, sizeof(priv->link_id_db));\n\t\tpriv->sta_asleep_mask = 0;\n\t\tpriv->enable_beacon = false;\n\t\tpriv->tx_multicast = false;\n\t\tpriv->aid0_bit_set = false;\n\t\tpriv->buffered_multicasts = false;\n\t\tpriv->pspoll_mask = 0;\n\t\treset.link_id = 0;\n\t\twsm_reset(priv, &reset);\n\t\tbreak;\n\tcase CW1200_JOIN_STATUS_MONITOR:\n\t\tcw1200_update_listening(priv, false);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tpriv->vif = NULL;\n\tpriv->mode = NL80211_IFTYPE_MONITOR;\n\teth_zero_addr(priv->mac_addr);\n\tmemset(&priv->p2p_ps_modeinfo, 0, sizeof(priv->p2p_ps_modeinfo));\n\tcw1200_free_keys(priv);\n\tcw1200_setup_mac(priv);\n\tpriv->listening = false;\n\tpriv->join_status = CW1200_JOIN_STATUS_PASSIVE;\n\tif (!__cw1200_flush(priv, true))\n\t\twsm_unlock_tx(priv);\n\n\tmutex_unlock(&priv->conf_mutex);\n}\n\nint cw1200_change_interface(struct ieee80211_hw *dev,\n\t\t\t    struct ieee80211_vif *vif,\n\t\t\t    enum nl80211_iftype new_type,\n\t\t\t    bool p2p)\n{\n\tint ret = 0;\n\tpr_debug(\"change_interface new: %d (%d), old: %d (%d)\\n\", new_type,\n\t\t p2p, vif->type, vif->p2p);\n\n\tif (new_type != vif->type || vif->p2p != p2p) {\n\t\tcw1200_remove_interface(dev, vif);\n\t\tvif->type = new_type;\n\t\tvif->p2p = p2p;\n\t\tret = cw1200_add_interface(dev, vif);\n\t}\n\n\treturn ret;\n}\n\nint cw1200_config(struct ieee80211_hw *dev, u32 changed)\n{\n\tint ret = 0;\n\tstruct cw1200_common *priv = dev->priv;\n\tstruct ieee80211_conf *conf = &dev->conf;\n\n\tpr_debug(\"CONFIG CHANGED:  %08x\\n\", changed);\n\n\tdown(&priv->scan.lock);\n\tmutex_lock(&priv->conf_mutex);\n\t \n\t \n\n\tif (changed & IEEE80211_CONF_CHANGE_POWER) {\n\t\tpriv->output_power = conf->power_level;\n\t\tpr_debug(\"[STA] TX power: %d\\n\", priv->output_power);\n\t\twsm_set_output_power(priv, priv->output_power * 10);\n\t}\n\n\tif ((changed & IEEE80211_CONF_CHANGE_CHANNEL) &&\n\t    (priv->channel != conf->chandef.chan)) {\n\t\tstruct ieee80211_channel *ch = conf->chandef.chan;\n\t\tstruct wsm_switch_channel channel = {\n\t\t\t.channel_number = ch->hw_value,\n\t\t};\n\t\tpr_debug(\"[STA] Freq %d (wsm ch: %d).\\n\",\n\t\t\t ch->center_freq, ch->hw_value);\n\n\t\t \n\t\tif (!__cw1200_flush(priv, false)) {\n\t\t\tif (!wsm_switch_channel(priv, &channel)) {\n\t\t\t\tret = wait_event_timeout(priv->channel_switch_done,\n\t\t\t\t\t\t\t !priv->channel_switch_in_progress,\n\t\t\t\t\t\t\t 3 * HZ);\n\t\t\t\tif (ret) {\n\t\t\t\t\t \n\t\t\t\t\tpriv->channel = ch;\n\t\t\t\t\tret = 0;\n\t\t\t\t} else {\n\t\t\t\t\tret = -ETIMEDOUT;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\twsm_unlock_tx(priv);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (changed & IEEE80211_CONF_CHANGE_PS) {\n\t\tif (!(conf->flags & IEEE80211_CONF_PS))\n\t\t\tpriv->powersave_mode.mode = WSM_PSM_ACTIVE;\n\t\telse if (conf->dynamic_ps_timeout <= 0)\n\t\t\tpriv->powersave_mode.mode = WSM_PSM_PS;\n\t\telse\n\t\t\tpriv->powersave_mode.mode = WSM_PSM_FAST_PS;\n\n\t\t \n\t\tif (conf->dynamic_ps_timeout >= 0x80)\n\t\t\tpriv->powersave_mode.fast_psm_idle_period = 0xFF;\n\t\telse\n\t\t\tpriv->powersave_mode.fast_psm_idle_period =\n\t\t\t\t\tconf->dynamic_ps_timeout << 1;\n\n\t\tif (priv->join_status == CW1200_JOIN_STATUS_STA &&\n\t\t    priv->bss_params.aid)\n\t\t\tcw1200_set_pm(priv, &priv->powersave_mode);\n\t}\n\n\tif (changed & IEEE80211_CONF_CHANGE_MONITOR) {\n\t\t \n\t}\n\n\tif (changed & IEEE80211_CONF_CHANGE_IDLE) {\n\t\tstruct wsm_operational_mode mode = {\n\t\t\t.power_mode = cw1200_power_mode,\n\t\t\t.disable_more_flag_usage = true,\n\t\t};\n\n\t\twsm_lock_tx(priv);\n\t\t \n\t\tif ((priv->join_status == CW1200_JOIN_STATUS_MONITOR) &&\n\t\t    (conf->flags & IEEE80211_CONF_IDLE) &&\n\t\t    !priv->listening) {\n\t\t\tcw1200_disable_listening(priv);\n\t\t\tpriv->join_status = CW1200_JOIN_STATUS_PASSIVE;\n\t\t}\n\t\twsm_set_operational_mode(priv, &mode);\n\t\twsm_unlock_tx(priv);\n\t}\n\n\tif (changed & IEEE80211_CONF_CHANGE_RETRY_LIMITS) {\n\t\tpr_debug(\"[STA] Retry limits: %d (long), %d (short).\\n\",\n\t\t\t conf->long_frame_max_tx_count,\n\t\t\t conf->short_frame_max_tx_count);\n\t\tspin_lock_bh(&priv->tx_policy_cache.lock);\n\t\tpriv->long_frame_max_tx_count = conf->long_frame_max_tx_count;\n\t\tpriv->short_frame_max_tx_count =\n\t\t\t(conf->short_frame_max_tx_count < 0x0F) ?\n\t\t\tconf->short_frame_max_tx_count : 0x0F;\n\t\tpriv->hw->max_rate_tries = priv->short_frame_max_tx_count;\n\t\tspin_unlock_bh(&priv->tx_policy_cache.lock);\n\t}\n\tmutex_unlock(&priv->conf_mutex);\n\tup(&priv->scan.lock);\n\treturn ret;\n}\n\nvoid cw1200_update_filtering(struct cw1200_common *priv)\n{\n\tint ret;\n\tbool bssid_filtering = !priv->rx_filter.bssid;\n\tbool is_p2p = priv->vif && priv->vif->p2p;\n\tbool is_sta = priv->vif && NL80211_IFTYPE_STATION == priv->vif->type;\n\n\tstatic struct wsm_beacon_filter_control bf_ctrl;\n\tstatic struct wsm_mib_beacon_filter_table bf_tbl = {\n\t\t.entry[0].ie_id = WLAN_EID_VENDOR_SPECIFIC,\n\t\t.entry[0].flags = WSM_BEACON_FILTER_IE_HAS_CHANGED |\n\t\t\t\t\tWSM_BEACON_FILTER_IE_NO_LONGER_PRESENT |\n\t\t\t\t\tWSM_BEACON_FILTER_IE_HAS_APPEARED,\n\t\t.entry[0].oui[0] = 0x50,\n\t\t.entry[0].oui[1] = 0x6F,\n\t\t.entry[0].oui[2] = 0x9A,\n\t\t.entry[1].ie_id = WLAN_EID_HT_OPERATION,\n\t\t.entry[1].flags = WSM_BEACON_FILTER_IE_HAS_CHANGED |\n\t\t\t\t\tWSM_BEACON_FILTER_IE_NO_LONGER_PRESENT |\n\t\t\t\t\tWSM_BEACON_FILTER_IE_HAS_APPEARED,\n\t\t.entry[2].ie_id = WLAN_EID_ERP_INFO,\n\t\t.entry[2].flags = WSM_BEACON_FILTER_IE_HAS_CHANGED |\n\t\t\t\t\tWSM_BEACON_FILTER_IE_NO_LONGER_PRESENT |\n\t\t\t\t\tWSM_BEACON_FILTER_IE_HAS_APPEARED,\n\t};\n\n\tif (priv->join_status == CW1200_JOIN_STATUS_PASSIVE)\n\t\treturn;\n\telse if (priv->join_status == CW1200_JOIN_STATUS_MONITOR)\n\t\tbssid_filtering = false;\n\n\tif (priv->disable_beacon_filter) {\n\t\tbf_ctrl.enabled = 0;\n\t\tbf_ctrl.bcn_count = 1;\n\t\tbf_tbl.num = __cpu_to_le32(0);\n\t} else if (is_p2p || !is_sta) {\n\t\tbf_ctrl.enabled = WSM_BEACON_FILTER_ENABLE |\n\t\t\tWSM_BEACON_FILTER_AUTO_ERP;\n\t\tbf_ctrl.bcn_count = 0;\n\t\tbf_tbl.num = __cpu_to_le32(2);\n\t} else {\n\t\tbf_ctrl.enabled = WSM_BEACON_FILTER_ENABLE;\n\t\tbf_ctrl.bcn_count = 0;\n\t\tbf_tbl.num = __cpu_to_le32(3);\n\t}\n\n\t \n\tif (is_p2p)\n\t\tbssid_filtering = false;\n\n\tret = wsm_set_rx_filter(priv, &priv->rx_filter);\n\tif (!ret)\n\t\tret = wsm_set_beacon_filter_table(priv, &bf_tbl);\n\tif (!ret)\n\t\tret = wsm_beacon_filter_control(priv, &bf_ctrl);\n\tif (!ret)\n\t\tret = wsm_set_bssid_filtering(priv, bssid_filtering);\n\tif (!ret)\n\t\tret = wsm_set_multicast_filter(priv, &priv->multicast_filter);\n\tif (ret)\n\t\twiphy_err(priv->hw->wiphy,\n\t\t\t  \"Update filtering failed: %d.\\n\", ret);\n\treturn;\n}\n\nvoid cw1200_update_filtering_work(struct work_struct *work)\n{\n\tstruct cw1200_common *priv =\n\t\tcontainer_of(work, struct cw1200_common,\n\t\t\t     update_filtering_work);\n\n\tcw1200_update_filtering(priv);\n}\n\nvoid cw1200_set_beacon_wakeup_period_work(struct work_struct *work)\n{\n\tstruct cw1200_common *priv =\n\t\tcontainer_of(work, struct cw1200_common,\n\t\t\t     set_beacon_wakeup_period_work);\n\n\twsm_set_beacon_wakeup_period(priv,\n\t\t\t\t     priv->beacon_int * priv->join_dtim_period >\n\t\t\t\t     MAX_BEACON_SKIP_TIME_MS ? 1 :\n\t\t\t\t     priv->join_dtim_period, 0);\n}\n\nu64 cw1200_prepare_multicast(struct ieee80211_hw *hw,\n\t\t\t     struct netdev_hw_addr_list *mc_list)\n{\n\tstatic u8 broadcast_ipv6[ETH_ALEN] = {\n\t\t0x33, 0x33, 0x00, 0x00, 0x00, 0x01\n\t};\n\tstatic u8 broadcast_ipv4[ETH_ALEN] = {\n\t\t0x01, 0x00, 0x5e, 0x00, 0x00, 0x01\n\t};\n\tstruct cw1200_common *priv = hw->priv;\n\tstruct netdev_hw_addr *ha;\n\tint count = 0;\n\n\t \n\tpriv->has_multicast_subscription = false;\n\tmemset(&priv->multicast_filter, 0x00, sizeof(priv->multicast_filter));\n\n\tif (netdev_hw_addr_list_count(mc_list) > WSM_MAX_GRP_ADDRTABLE_ENTRIES)\n\t\treturn 0;\n\n\t \n\tnetdev_hw_addr_list_for_each(ha, mc_list) {\n\t\tpr_debug(\"[STA] multicast: %pM\\n\", ha->addr);\n\t\tmemcpy(&priv->multicast_filter.macaddrs[count],\n\t\t       ha->addr, ETH_ALEN);\n\t\tif (!ether_addr_equal(ha->addr, broadcast_ipv4) &&\n\t\t    !ether_addr_equal(ha->addr, broadcast_ipv6))\n\t\t\tpriv->has_multicast_subscription = true;\n\t\tcount++;\n\t}\n\n\tif (count) {\n\t\tpriv->multicast_filter.enable = __cpu_to_le32(1);\n\t\tpriv->multicast_filter.num_addrs = __cpu_to_le32(count);\n\t}\n\n\treturn netdev_hw_addr_list_count(mc_list);\n}\n\nvoid cw1200_configure_filter(struct ieee80211_hw *dev,\n\t\t\t     unsigned int changed_flags,\n\t\t\t     unsigned int *total_flags,\n\t\t\t     u64 multicast)\n{\n\tstruct cw1200_common *priv = dev->priv;\n\tbool listening = !!(*total_flags &\n\t\t\t    (FIF_OTHER_BSS |\n\t\t\t     FIF_BCN_PRBRESP_PROMISC |\n\t\t\t     FIF_PROBE_REQ));\n\n\t*total_flags &= FIF_OTHER_BSS |\n\t\t\tFIF_FCSFAIL |\n\t\t\tFIF_BCN_PRBRESP_PROMISC |\n\t\t\tFIF_PROBE_REQ;\n\n\tdown(&priv->scan.lock);\n\tmutex_lock(&priv->conf_mutex);\n\n\tpriv->rx_filter.promiscuous = 0;\n\tpriv->rx_filter.bssid = (*total_flags & (FIF_OTHER_BSS |\n\t\t\tFIF_PROBE_REQ)) ? 1 : 0;\n\tpriv->rx_filter.fcs = (*total_flags & FIF_FCSFAIL) ? 1 : 0;\n\tpriv->disable_beacon_filter = !(*total_flags &\n\t\t\t\t\t(FIF_BCN_PRBRESP_PROMISC |\n\t\t\t\t\t FIF_PROBE_REQ));\n\tif (priv->listening != listening) {\n\t\tpriv->listening = listening;\n\t\twsm_lock_tx(priv);\n\t\tcw1200_update_listening(priv, listening);\n\t\twsm_unlock_tx(priv);\n\t}\n\tcw1200_update_filtering(priv);\n\tmutex_unlock(&priv->conf_mutex);\n\tup(&priv->scan.lock);\n}\n\nint cw1200_conf_tx(struct ieee80211_hw *dev, struct ieee80211_vif *vif,\n\t\t   unsigned int link_id, u16 queue,\n\t\t   const struct ieee80211_tx_queue_params *params)\n{\n\tstruct cw1200_common *priv = dev->priv;\n\tint ret = 0;\n\t \n\tbool old_uapsd_flags;\n\n\tmutex_lock(&priv->conf_mutex);\n\n\tif (queue < dev->queues) {\n\t\told_uapsd_flags = le16_to_cpu(priv->uapsd_info.uapsd_flags);\n\n\t\tWSM_TX_QUEUE_SET(&priv->tx_queue_params, queue, 0, 0, 0);\n\t\tret = wsm_set_tx_queue_params(priv,\n\t\t\t\t\t      &priv->tx_queue_params.params[queue], queue);\n\t\tif (ret) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tWSM_EDCA_SET(&priv->edca, queue, params->aifs,\n\t\t\t     params->cw_min, params->cw_max,\n\t\t\t     params->txop, 0xc8,\n\t\t\t     params->uapsd);\n\t\tret = wsm_set_edca_params(priv, &priv->edca);\n\t\tif (ret) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (priv->mode == NL80211_IFTYPE_STATION) {\n\t\t\tret = cw1200_set_uapsd_param(priv, &priv->edca);\n\t\t\tif (!ret && priv->setbssparams_done &&\n\t\t\t    (priv->join_status == CW1200_JOIN_STATUS_STA) &&\n\t\t\t    (old_uapsd_flags != le16_to_cpu(priv->uapsd_info.uapsd_flags)))\n\t\t\t\tret = cw1200_set_pm(priv, &priv->powersave_mode);\n\t\t}\n\t} else {\n\t\tret = -EINVAL;\n\t}\n\nout:\n\tmutex_unlock(&priv->conf_mutex);\n\treturn ret;\n}\n\nint cw1200_get_stats(struct ieee80211_hw *dev,\n\t\t     struct ieee80211_low_level_stats *stats)\n{\n\tstruct cw1200_common *priv = dev->priv;\n\n\tmemcpy(stats, &priv->stats, sizeof(*stats));\n\treturn 0;\n}\n\nint cw1200_set_pm(struct cw1200_common *priv, const struct wsm_set_pm *arg)\n{\n\tstruct wsm_set_pm pm = *arg;\n\n\tif (priv->uapsd_info.uapsd_flags != 0)\n\t\tpm.mode &= ~WSM_PSM_FAST_PS_FLAG;\n\n\tif (memcmp(&pm, &priv->firmware_ps_mode,\n\t\t   sizeof(struct wsm_set_pm))) {\n\t\tpriv->firmware_ps_mode = pm;\n\t\treturn wsm_set_pm(priv, &pm);\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nint cw1200_set_key(struct ieee80211_hw *dev, enum set_key_cmd cmd,\n\t\t   struct ieee80211_vif *vif, struct ieee80211_sta *sta,\n\t\t   struct ieee80211_key_conf *key)\n{\n\tint ret = -EOPNOTSUPP;\n\tstruct cw1200_common *priv = dev->priv;\n\tstruct ieee80211_key_seq seq;\n\n\tmutex_lock(&priv->conf_mutex);\n\n\tif (cmd == SET_KEY) {\n\t\tu8 *peer_addr = NULL;\n\t\tint pairwise = (key->flags & IEEE80211_KEY_FLAG_PAIRWISE) ?\n\t\t\t1 : 0;\n\t\tint idx = cw1200_alloc_key(priv);\n\t\tstruct wsm_add_key *wsm_key = &priv->keys[idx];\n\n\t\tif (idx < 0) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto finally;\n\t\t}\n\n\t\tif (sta)\n\t\t\tpeer_addr = sta->addr;\n\n\t\tkey->flags |= IEEE80211_KEY_FLAG_PUT_IV_SPACE |\n\t\t\t      IEEE80211_KEY_FLAG_RESERVE_TAILROOM;\n\n\t\tswitch (key->cipher) {\n\t\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\t\tif (key->keylen > 16) {\n\t\t\t\tcw1200_free_key(priv, idx);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto finally;\n\t\t\t}\n\n\t\t\tif (pairwise) {\n\t\t\t\twsm_key->type = WSM_KEY_TYPE_WEP_PAIRWISE;\n\t\t\t\tmemcpy(wsm_key->wep_pairwise.peer,\n\t\t\t\t       peer_addr, ETH_ALEN);\n\t\t\t\tmemcpy(wsm_key->wep_pairwise.keydata,\n\t\t\t\t       &key->key[0], key->keylen);\n\t\t\t\twsm_key->wep_pairwise.keylen = key->keylen;\n\t\t\t} else {\n\t\t\t\twsm_key->type = WSM_KEY_TYPE_WEP_DEFAULT;\n\t\t\t\tmemcpy(wsm_key->wep_group.keydata,\n\t\t\t\t       &key->key[0], key->keylen);\n\t\t\t\twsm_key->wep_group.keylen = key->keylen;\n\t\t\t\twsm_key->wep_group.keyid = key->keyidx;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\t\tieee80211_get_key_rx_seq(key, 0, &seq);\n\t\t\tif (pairwise) {\n\t\t\t\twsm_key->type = WSM_KEY_TYPE_TKIP_PAIRWISE;\n\t\t\t\tmemcpy(wsm_key->tkip_pairwise.peer,\n\t\t\t\t       peer_addr, ETH_ALEN);\n\t\t\t\tmemcpy(wsm_key->tkip_pairwise.keydata,\n\t\t\t\t       &key->key[0], 16);\n\t\t\t\tmemcpy(wsm_key->tkip_pairwise.tx_mic_key,\n\t\t\t\t       &key->key[16], 8);\n\t\t\t\tmemcpy(wsm_key->tkip_pairwise.rx_mic_key,\n\t\t\t\t       &key->key[24], 8);\n\t\t\t} else {\n\t\t\t\tsize_t mic_offset =\n\t\t\t\t\t(priv->mode == NL80211_IFTYPE_AP) ?\n\t\t\t\t\t16 : 24;\n\t\t\t\twsm_key->type = WSM_KEY_TYPE_TKIP_GROUP;\n\t\t\t\tmemcpy(wsm_key->tkip_group.keydata,\n\t\t\t\t       &key->key[0], 16);\n\t\t\t\tmemcpy(wsm_key->tkip_group.rx_mic_key,\n\t\t\t\t       &key->key[mic_offset], 8);\n\n\t\t\t\twsm_key->tkip_group.rx_seqnum[0] = seq.tkip.iv16 & 0xff;\n\t\t\t\twsm_key->tkip_group.rx_seqnum[1] = (seq.tkip.iv16 >> 8) & 0xff;\n\t\t\t\twsm_key->tkip_group.rx_seqnum[2] = seq.tkip.iv32 & 0xff;\n\t\t\t\twsm_key->tkip_group.rx_seqnum[3] = (seq.tkip.iv32 >> 8) & 0xff;\n\t\t\t\twsm_key->tkip_group.rx_seqnum[4] = (seq.tkip.iv32 >> 16) & 0xff;\n\t\t\t\twsm_key->tkip_group.rx_seqnum[5] = (seq.tkip.iv32 >> 24) & 0xff;\n\t\t\t\twsm_key->tkip_group.rx_seqnum[6] = 0;\n\t\t\t\twsm_key->tkip_group.rx_seqnum[7] = 0;\n\n\t\t\t\twsm_key->tkip_group.keyid = key->keyidx;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\t\tieee80211_get_key_rx_seq(key, 0, &seq);\n\t\t\tif (pairwise) {\n\t\t\t\twsm_key->type = WSM_KEY_TYPE_AES_PAIRWISE;\n\t\t\t\tmemcpy(wsm_key->aes_pairwise.peer,\n\t\t\t\t       peer_addr, ETH_ALEN);\n\t\t\t\tmemcpy(wsm_key->aes_pairwise.keydata,\n\t\t\t\t       &key->key[0], 16);\n\t\t\t} else {\n\t\t\t\twsm_key->type = WSM_KEY_TYPE_AES_GROUP;\n\t\t\t\tmemcpy(wsm_key->aes_group.keydata,\n\t\t\t\t       &key->key[0], 16);\n\n\t\t\t\twsm_key->aes_group.rx_seqnum[0] = seq.ccmp.pn[5];\n\t\t\t\twsm_key->aes_group.rx_seqnum[1] = seq.ccmp.pn[4];\n\t\t\t\twsm_key->aes_group.rx_seqnum[2] = seq.ccmp.pn[3];\n\t\t\t\twsm_key->aes_group.rx_seqnum[3] = seq.ccmp.pn[2];\n\t\t\t\twsm_key->aes_group.rx_seqnum[4] = seq.ccmp.pn[1];\n\t\t\t\twsm_key->aes_group.rx_seqnum[5] = seq.ccmp.pn[0];\n\t\t\t\twsm_key->aes_group.rx_seqnum[6] = 0;\n\t\t\t\twsm_key->aes_group.rx_seqnum[7] = 0;\n\t\t\t\twsm_key->aes_group.keyid = key->keyidx;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_SMS4:\n\t\t\tif (pairwise) {\n\t\t\t\twsm_key->type = WSM_KEY_TYPE_WAPI_PAIRWISE;\n\t\t\t\tmemcpy(wsm_key->wapi_pairwise.peer,\n\t\t\t\t       peer_addr, ETH_ALEN);\n\t\t\t\tmemcpy(wsm_key->wapi_pairwise.keydata,\n\t\t\t\t       &key->key[0], 16);\n\t\t\t\tmemcpy(wsm_key->wapi_pairwise.mic_key,\n\t\t\t\t       &key->key[16], 16);\n\t\t\t\twsm_key->wapi_pairwise.keyid = key->keyidx;\n\t\t\t} else {\n\t\t\t\twsm_key->type = WSM_KEY_TYPE_WAPI_GROUP;\n\t\t\t\tmemcpy(wsm_key->wapi_group.keydata,\n\t\t\t\t       &key->key[0],  16);\n\t\t\t\tmemcpy(wsm_key->wapi_group.mic_key,\n\t\t\t\t       &key->key[16], 16);\n\t\t\t\twsm_key->wapi_group.keyid = key->keyidx;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"Unhandled key type %d\\n\", key->cipher);\n\t\t\tcw1200_free_key(priv, idx);\n\t\t\tret = -EOPNOTSUPP;\n\t\t\tgoto finally;\n\t\t}\n\t\tret = wsm_add_key(priv, wsm_key);\n\t\tif (!ret)\n\t\t\tkey->hw_key_idx = idx;\n\t\telse\n\t\t\tcw1200_free_key(priv, idx);\n\t} else if (cmd == DISABLE_KEY) {\n\t\tstruct wsm_remove_key wsm_key = {\n\t\t\t.index = key->hw_key_idx,\n\t\t};\n\n\t\tif (wsm_key.index > WSM_KEY_MAX_INDEX) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto finally;\n\t\t}\n\n\t\tcw1200_free_key(priv, wsm_key.index);\n\t\tret = wsm_remove_key(priv, &wsm_key);\n\t} else {\n\t\tpr_warn(\"Unhandled key command %d\\n\", cmd);\n\t}\n\nfinally:\n\tmutex_unlock(&priv->conf_mutex);\n\treturn ret;\n}\n\nvoid cw1200_wep_key_work(struct work_struct *work)\n{\n\tstruct cw1200_common *priv =\n\t\tcontainer_of(work, struct cw1200_common, wep_key_work);\n\tu8 queue_id = cw1200_queue_get_queue_id(priv->pending_frame_id);\n\tstruct cw1200_queue *queue = &priv->tx_queue[queue_id];\n\t__le32 wep_default_key_id = __cpu_to_le32(\n\t\tpriv->wep_default_key_id);\n\n\tpr_debug(\"[STA] Setting default WEP key: %d\\n\",\n\t\t priv->wep_default_key_id);\n\twsm_flush_tx(priv);\n\twsm_write_mib(priv, WSM_MIB_ID_DOT11_WEP_DEFAULT_KEY_ID,\n\t\t      &wep_default_key_id, sizeof(wep_default_key_id));\n\tcw1200_queue_requeue(queue, priv->pending_frame_id);\n\twsm_unlock_tx(priv);\n}\n\nint cw1200_set_rts_threshold(struct ieee80211_hw *hw, u32 value)\n{\n\tint ret = 0;\n\t__le32 val32;\n\tstruct cw1200_common *priv = hw->priv;\n\n\tif (priv->mode == NL80211_IFTYPE_UNSPECIFIED)\n\t\treturn 0;\n\n\tif (value != (u32) -1)\n\t\tval32 = __cpu_to_le32(value);\n\telse\n\t\tval32 = 0;  \n\n\tif (priv->rts_threshold == value)\n\t\tgoto out;\n\n\tpr_debug(\"[STA] Setting RTS threshold: %d\\n\",\n\t\t priv->rts_threshold);\n\n\t \n\tret = wsm_write_mib(priv, WSM_MIB_ID_DOT11_RTS_THRESHOLD,\n\t\t\t    &val32, sizeof(val32));\n\tif (!ret)\n\t\tpriv->rts_threshold = value;\n\t \n\nout:\n\treturn ret;\n}\n\n \nstatic int __cw1200_flush(struct cw1200_common *priv, bool drop)\n{\n\tint i, ret;\n\n\tfor (;;) {\n\t\t \n\t\tif (drop) {\n\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\tcw1200_queue_clear(&priv->tx_queue[i]);\n\t\t} else {\n\t\t\tret = wait_event_timeout(\n\t\t\t\tpriv->tx_queue_stats.wait_link_id_empty,\n\t\t\t\tcw1200_queue_stats_is_empty(\n\t\t\t\t\t&priv->tx_queue_stats, -1),\n\t\t\t\t2 * HZ);\n\t\t}\n\n\t\tif (!drop && ret <= 0) {\n\t\t\tret = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tret = 0;\n\t\t}\n\n\t\twsm_lock_tx(priv);\n\t\tif (!cw1200_queue_stats_is_empty(&priv->tx_queue_stats, -1)) {\n\t\t\t \n\t\t\twsm_unlock_tx(priv);\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nvoid cw1200_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t  u32 queues, bool drop)\n{\n\tstruct cw1200_common *priv = hw->priv;\n\n\tswitch (priv->mode) {\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tdrop = true;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\t\tif (!priv->enable_beacon)\n\t\t\tdrop = true;\n\t\tbreak;\n\t}\n\n\tif (!__cw1200_flush(priv, drop))\n\t\twsm_unlock_tx(priv);\n\n\treturn;\n}\n\n \n \n\nvoid cw1200_free_event_queue(struct cw1200_common *priv)\n{\n\tLIST_HEAD(list);\n\n\tspin_lock(&priv->event_queue_lock);\n\tlist_splice_init(&priv->event_queue, &list);\n\tspin_unlock(&priv->event_queue_lock);\n\n\t__cw1200_free_event_queue(&list);\n}\n\nvoid cw1200_event_handler(struct work_struct *work)\n{\n\tstruct cw1200_common *priv =\n\t\tcontainer_of(work, struct cw1200_common, event_handler);\n\tstruct cw1200_wsm_event *event;\n\tLIST_HEAD(list);\n\n\tspin_lock(&priv->event_queue_lock);\n\tlist_splice_init(&priv->event_queue, &list);\n\tspin_unlock(&priv->event_queue_lock);\n\n\tlist_for_each_entry(event, &list, link) {\n\t\tswitch (event->evt.id) {\n\t\tcase WSM_EVENT_ERROR:\n\t\t\tpr_err(\"Unhandled WSM Error from LMAC\\n\");\n\t\t\tbreak;\n\t\tcase WSM_EVENT_BSS_LOST:\n\t\t\tpr_debug(\"[CQM] BSS lost.\\n\");\n\t\t\tcancel_work_sync(&priv->unjoin_work);\n\t\t\tif (!down_trylock(&priv->scan.lock)) {\n\t\t\t\tcw1200_cqm_bssloss_sm(priv, 1, 0, 0);\n\t\t\t\tup(&priv->scan.lock);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tpriv->delayed_link_loss = 1;\n\t\t\t\t \n\t\t\t\tqueue_delayed_work(priv->workqueue,\n\t\t\t\t\t\t   &priv->bss_loss_work, 5*HZ);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase WSM_EVENT_BSS_REGAINED:\n\t\t\tpr_debug(\"[CQM] BSS regained.\\n\");\n\t\t\tcw1200_cqm_bssloss_sm(priv, 0, 0, 0);\n\t\t\tcancel_work_sync(&priv->unjoin_work);\n\t\t\tbreak;\n\t\tcase WSM_EVENT_RADAR_DETECTED:\n\t\t\twiphy_info(priv->hw->wiphy, \"radar pulse detected\\n\");\n\t\t\tbreak;\n\t\tcase WSM_EVENT_RCPI_RSSI:\n\t\t{\n\t\t\t \n\t\t\tint rcpi_rssi = (int)(event->evt.data & 0xFF);\n\t\t\tint cqm_evt;\n\t\t\tif (priv->cqm_use_rssi)\n\t\t\t\trcpi_rssi = (s8)rcpi_rssi;\n\t\t\telse\n\t\t\t\trcpi_rssi =  rcpi_rssi / 2 - 110;\n\n\t\t\tcqm_evt = (rcpi_rssi <= priv->cqm_rssi_thold) ?\n\t\t\t\tNL80211_CQM_RSSI_THRESHOLD_EVENT_LOW :\n\t\t\t\tNL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH;\n\t\t\tpr_debug(\"[CQM] RSSI event: %d.\\n\", rcpi_rssi);\n\t\t\tieee80211_cqm_rssi_notify(priv->vif, cqm_evt, rcpi_rssi,\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\t\tbreak;\n\t\t}\n\t\tcase WSM_EVENT_BT_INACTIVE:\n\t\t\tpr_warn(\"Unhandled BT INACTIVE from LMAC\\n\");\n\t\t\tbreak;\n\t\tcase WSM_EVENT_BT_ACTIVE:\n\t\t\tpr_warn(\"Unhandled BT ACTIVE from LMAC\\n\");\n\t\t\tbreak;\n\t\t}\n\t}\n\t__cw1200_free_event_queue(&list);\n}\n\nvoid cw1200_bss_loss_work(struct work_struct *work)\n{\n\tstruct cw1200_common *priv =\n\t\tcontainer_of(work, struct cw1200_common, bss_loss_work.work);\n\n\tpr_debug(\"[CQM] Reporting connection loss.\\n\");\n\twsm_lock_tx(priv);\n\tif (queue_work(priv->workqueue, &priv->unjoin_work) <= 0)\n\t\twsm_unlock_tx(priv);\n}\n\nvoid cw1200_bss_params_work(struct work_struct *work)\n{\n\tstruct cw1200_common *priv =\n\t\tcontainer_of(work, struct cw1200_common, bss_params_work);\n\tmutex_lock(&priv->conf_mutex);\n\n\tpriv->bss_params.reset_beacon_loss = 1;\n\twsm_set_bss_params(priv, &priv->bss_params);\n\tpriv->bss_params.reset_beacon_loss = 0;\n\n\tmutex_unlock(&priv->conf_mutex);\n}\n\n \n \n\n \nstatic int cw1200_parse_sdd_file(struct cw1200_common *priv)\n{\n\tconst u8 *p = priv->sdd->data;\n\tint ret = 0;\n\n\twhile (p + 2 <= priv->sdd->data + priv->sdd->size) {\n\t\tif (p + p[1] + 2 > priv->sdd->data + priv->sdd->size) {\n\t\t\tpr_warn(\"Malformed sdd structure\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tswitch (p[0]) {\n\t\tcase SDD_PTA_CFG_ELT_ID: {\n\t\t\tu16 v;\n\t\t\tif (p[1] < 4) {\n\t\t\t\tpr_warn(\"SDD_PTA_CFG_ELT_ID malformed\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tv = le16_to_cpu(*((__le16 *)(p + 2)));\n\t\t\tif (!v)   \n\t\t\t\tbreak;\n\n\t\t\tv = le16_to_cpu(*((__le16 *)(p + 4)));\n\t\t\tpriv->conf_listen_interval = (v >> 7) & 0x1F;\n\t\t\tpr_debug(\"PTA found; Listen Interval %d\\n\",\n\t\t\t\t priv->conf_listen_interval);\n\t\t\tbreak;\n\t\t}\n\t\tcase SDD_REFERENCE_FREQUENCY_ELT_ID: {\n\t\t\tu16 clk = le16_to_cpu(*((__le16 *)(p + 2)));\n\t\t\tif (clk != priv->hw_refclk)\n\t\t\t\tpr_warn(\"SDD file doesn't match configured refclk (%d vs %d)\\n\",\n\t\t\t\t\tclk, priv->hw_refclk);\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tp += p[1] + 2;\n\t}\n\n\tif (!priv->bt_present) {\n\t\tpr_debug(\"PTA element NOT found.\\n\");\n\t\tpriv->conf_listen_interval = 0;\n\t}\n\treturn ret;\n}\n\nint cw1200_setup_mac(struct cw1200_common *priv)\n{\n\tint ret = 0;\n\n\t \n\tstruct wsm_rcpi_rssi_threshold threshold = {\n\t\t.rssiRcpiMode = WSM_RCPI_RSSI_THRESHOLD_ENABLE |\n\t\tWSM_RCPI_RSSI_DONT_USE_UPPER |\n\t\tWSM_RCPI_RSSI_DONT_USE_LOWER,\n\t\t.rollingAverageCount = 16,\n\t};\n\n\tstruct wsm_configuration cfg = {\n\t\t.dot11StationId = &priv->mac_addr[0],\n\t};\n\n\t \n\tif (threshold.rssiRcpiMode & WSM_RCPI_RSSI_USE_RSSI)\n\t\tpriv->cqm_use_rssi = true;\n\n\tif (!priv->sdd) {\n\t\tret = request_firmware(&priv->sdd, priv->sdd_path, priv->pdev);\n\t\tif (ret) {\n\t\t\tpr_err(\"Can't load sdd file %s.\\n\", priv->sdd_path);\n\t\t\treturn ret;\n\t\t}\n\t\tcw1200_parse_sdd_file(priv);\n\t}\n\n\tcfg.dpdData = priv->sdd->data;\n\tcfg.dpdData_size = priv->sdd->size;\n\tret = wsm_configuration(priv, &cfg);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\twsm_set_rcpi_rssi_threshold(priv, &threshold);\n\n\treturn 0;\n}\n\nstatic void cw1200_join_complete(struct cw1200_common *priv)\n{\n\tpr_debug(\"[STA] Join complete (%d)\\n\", priv->join_complete_status);\n\n\tpriv->join_pending = false;\n\tif (priv->join_complete_status) {\n\t\tpriv->join_status = CW1200_JOIN_STATUS_PASSIVE;\n\t\tcw1200_update_listening(priv, priv->listening);\n\t\tcw1200_do_unjoin(priv);\n\t\tieee80211_connection_loss(priv->vif);\n\t} else {\n\t\tif (priv->mode == NL80211_IFTYPE_ADHOC)\n\t\t\tpriv->join_status = CW1200_JOIN_STATUS_IBSS;\n\t\telse\n\t\t\tpriv->join_status = CW1200_JOIN_STATUS_PRE_STA;\n\t}\n\twsm_unlock_tx(priv);  \n}\n\nvoid cw1200_join_complete_work(struct work_struct *work)\n{\n\tstruct cw1200_common *priv =\n\t\tcontainer_of(work, struct cw1200_common, join_complete_work);\n\tmutex_lock(&priv->conf_mutex);\n\tcw1200_join_complete(priv);\n\tmutex_unlock(&priv->conf_mutex);\n}\n\nvoid cw1200_join_complete_cb(struct cw1200_common *priv,\n\t\t\t     struct wsm_join_complete *arg)\n{\n\tpr_debug(\"[STA] cw1200_join_complete_cb called, status=%d.\\n\",\n\t\t arg->status);\n\n\tif (cancel_delayed_work(&priv->join_timeout)) {\n\t\tpriv->join_complete_status = arg->status;\n\t\tqueue_work(priv->workqueue, &priv->join_complete_work);\n\t}\n}\n\n \nstatic void cw1200_do_join(struct cw1200_common *priv)\n{\n\tconst u8 *bssid;\n\tstruct ieee80211_bss_conf *conf = &priv->vif->bss_conf;\n\tstruct cfg80211_bss *bss = NULL;\n\tstruct wsm_protected_mgmt_policy mgmt_policy;\n\tstruct wsm_join join = {\n\t\t.mode = priv->vif->cfg.ibss_joined ?\n\t\tWSM_JOIN_MODE_IBSS : WSM_JOIN_MODE_BSS,\n\t\t.preamble_type = WSM_JOIN_PREAMBLE_LONG,\n\t\t.probe_for_join = 1,\n\t\t.atim_window = 0,\n\t\t.basic_rate_set = cw1200_rate_mask_to_wsm(priv,\n\t\t\t\t\t\t\t  conf->basic_rates),\n\t};\n\tif (delayed_work_pending(&priv->join_timeout)) {\n\t\tpr_warn(\"[STA] - Join request already pending, skipping..\\n\");\n\t\twsm_unlock_tx(priv);\n\t\treturn;\n\t}\n\n\tif (priv->join_status)\n\t\tcw1200_do_unjoin(priv);\n\n\tbssid = priv->vif->bss_conf.bssid;\n\n\tbss = cfg80211_get_bss(priv->hw->wiphy, priv->channel, bssid, NULL, 0,\n\t\t\t       IEEE80211_BSS_TYPE_ANY, IEEE80211_PRIVACY_ANY);\n\n\tif (!bss && !priv->vif->cfg.ibss_joined) {\n\t\twsm_unlock_tx(priv);\n\t\treturn;\n\t}\n\n\tmutex_lock(&priv->conf_mutex);\n\n\t \n\tif (atomic_read(&priv->scan.in_progress)) {\n\t\twsm_unlock_tx(priv);\n\t\tgoto done_put;\n\t}\n\n\tpriv->join_pending = true;\n\n\t \n\tif (!join.basic_rate_set)\n\t\tjoin.basic_rate_set = 7;\n\n\t \n\tif (!priv->beacon_int)\n\t\tpriv->beacon_int = 1;\n\n\tjoin.beacon_interval = priv->beacon_int;\n\n\t \n\tif (priv->bt_present) {\n\t\tif (((priv->conf_listen_interval * 100) %\n\t\t     priv->beacon_int) == 0)\n\t\t\tpriv->listen_interval =\n\t\t\t\t((priv->conf_listen_interval * 100) /\n\t\t\t\t priv->beacon_int);\n\t\telse\n\t\t\tpriv->listen_interval =\n\t\t\t\t((priv->conf_listen_interval * 100) /\n\t\t\t\t priv->beacon_int + 1);\n\t}\n\n\tif (priv->hw->conf.ps_dtim_period)\n\t\tpriv->join_dtim_period = priv->hw->conf.ps_dtim_period;\n\tjoin.dtim_period = priv->join_dtim_period;\n\n\tjoin.channel_number = priv->channel->hw_value;\n\tjoin.band = (priv->channel->band == NL80211_BAND_5GHZ) ?\n\t\tWSM_PHY_BAND_5G : WSM_PHY_BAND_2_4G;\n\n\tmemcpy(join.bssid, bssid, sizeof(join.bssid));\n\n\tpr_debug(\"[STA] Join BSSID: %pM DTIM: %d, interval: %d\\n\",\n\t\t join.bssid,\n\t\t join.dtim_period, priv->beacon_int);\n\n\tif (!priv->vif->cfg.ibss_joined) {\n\t\tconst u8 *ssidie;\n\t\trcu_read_lock();\n\t\tssidie = ieee80211_bss_get_ie(bss, WLAN_EID_SSID);\n\t\tif (ssidie) {\n\t\t\tjoin.ssid_len = ssidie[1];\n\t\t\tmemcpy(join.ssid, &ssidie[2], join.ssid_len);\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tif (priv->vif->p2p) {\n\t\tjoin.flags |= WSM_JOIN_FLAGS_P2P_GO;\n\t\tjoin.basic_rate_set =\n\t\t\tcw1200_rate_mask_to_wsm(priv, 0xFF0);\n\t}\n\n\t \n\tif (!priv->vif->cfg.ibss_joined) {\n\t\tjoin.flags |= WSM_JOIN_FLAGS_FORCE;\n\t\tjoin.flags |= WSM_JOIN_FLAGS_FORCE_WITH_COMPLETE_IND;\n\t}\n\n\twsm_flush_tx(priv);\n\n\t \n\tcw1200_pm_stay_awake(&priv->pm_state,\n\t\t\t     CW1200_JOIN_TIMEOUT + CW1200_AUTH_TIMEOUT);\n\n\tcw1200_update_listening(priv, false);\n\n\t \n\twsm_set_block_ack_policy(priv, priv->ba_tx_tid_mask,\n\t\t\t\t priv->ba_rx_tid_mask);\n\n\t \n\tif (join.flags & WSM_JOIN_FLAGS_FORCE_WITH_COMPLETE_IND) {\n\t\tpriv->join_status = CW1200_JOIN_STATUS_JOINING;\n\t\tqueue_delayed_work(priv->workqueue,\n\t\t\t\t   &priv->join_timeout,\n\t\t\t\t   CW1200_JOIN_TIMEOUT);\n\t}\n\n\t \n\tmgmt_policy.protectedMgmtEnable = 0;\n\tmgmt_policy.unprotectedMgmtFramesAllowed = 1;\n\tmgmt_policy.encryptionForAuthFrame = 1;\n\twsm_set_protected_mgmt_policy(priv, &mgmt_policy);\n\n\t \n\tif (wsm_join(priv, &join)) {\n\t\tpr_err(\"[STA] cw1200_join_work: wsm_join failed!\\n\");\n\t\tcancel_delayed_work_sync(&priv->join_timeout);\n\t\tcw1200_update_listening(priv, priv->listening);\n\t\t \n\t\tif (queue_work(priv->workqueue, &priv->unjoin_work) <= 0)\n\t\t\twsm_unlock_tx(priv);\n\t} else {\n\t\tif (!(join.flags & WSM_JOIN_FLAGS_FORCE_WITH_COMPLETE_IND))\n\t\t\tcw1200_join_complete(priv);  \n\n\t\t \n\t\tcw1200_upload_keys(priv);\n\n\t\t \n\t\tpriv->disable_beacon_filter = true;\n\t}\n\tcw1200_update_filtering(priv);\n\ndone_put:\n\tmutex_unlock(&priv->conf_mutex);\n\tif (bss)\n\t\tcfg80211_put_bss(priv->hw->wiphy, bss);\n}\n\nvoid cw1200_join_timeout(struct work_struct *work)\n{\n\tstruct cw1200_common *priv =\n\t\tcontainer_of(work, struct cw1200_common, join_timeout.work);\n\tpr_debug(\"[WSM] Join timed out.\\n\");\n\twsm_lock_tx(priv);\n\tif (queue_work(priv->workqueue, &priv->unjoin_work) <= 0)\n\t\twsm_unlock_tx(priv);\n}\n\nstatic void cw1200_do_unjoin(struct cw1200_common *priv)\n{\n\tstruct wsm_reset reset = {\n\t\t.reset_statistics = true,\n\t};\n\n\tcancel_delayed_work_sync(&priv->join_timeout);\n\n\tmutex_lock(&priv->conf_mutex);\n\tpriv->join_pending = false;\n\n\tif (atomic_read(&priv->scan.in_progress)) {\n\t\tif (priv->delayed_unjoin)\n\t\t\twiphy_dbg(priv->hw->wiphy, \"Delayed unjoin is already scheduled.\\n\");\n\t\telse\n\t\t\tpriv->delayed_unjoin = true;\n\t\tgoto done;\n\t}\n\n\tpriv->delayed_link_loss = false;\n\n\tif (!priv->join_status)\n\t\tgoto done;\n\n\tif (priv->join_status == CW1200_JOIN_STATUS_AP)\n\t\tgoto done;\n\n\tcancel_work_sync(&priv->update_filtering_work);\n\tcancel_work_sync(&priv->set_beacon_wakeup_period_work);\n\tpriv->join_status = CW1200_JOIN_STATUS_PASSIVE;\n\n\t \n\twsm_flush_tx(priv);\n\twsm_keep_alive_period(priv, 0);\n\twsm_reset(priv, &reset);\n\twsm_set_output_power(priv, priv->output_power * 10);\n\tpriv->join_dtim_period = 0;\n\tcw1200_setup_mac(priv);\n\tcw1200_free_event_queue(priv);\n\tcancel_work_sync(&priv->event_handler);\n\tcw1200_update_listening(priv, priv->listening);\n\tcw1200_cqm_bssloss_sm(priv, 0, 0, 0);\n\n\t \n\twsm_set_block_ack_policy(priv, 0, 0);\n\n\tpriv->disable_beacon_filter = false;\n\tcw1200_update_filtering(priv);\n\tmemset(&priv->association_mode, 0,\n\t       sizeof(priv->association_mode));\n\tmemset(&priv->bss_params, 0, sizeof(priv->bss_params));\n\tpriv->setbssparams_done = false;\n\tmemset(&priv->firmware_ps_mode, 0,\n\t       sizeof(priv->firmware_ps_mode));\n\n\tpr_debug(\"[STA] Unjoin completed.\\n\");\n\ndone:\n\tmutex_unlock(&priv->conf_mutex);\n}\n\nvoid cw1200_unjoin_work(struct work_struct *work)\n{\n\tstruct cw1200_common *priv =\n\t\tcontainer_of(work, struct cw1200_common, unjoin_work);\n\n\tcw1200_do_unjoin(priv);\n\n\t \n\tieee80211_connection_loss(priv->vif);\n\n\twsm_unlock_tx(priv);\n}\n\nint cw1200_enable_listening(struct cw1200_common *priv)\n{\n\tstruct wsm_start start = {\n\t\t.mode = WSM_START_MODE_P2P_DEV,\n\t\t.band = WSM_PHY_BAND_2_4G,\n\t\t.beacon_interval = 100,\n\t\t.dtim_period = 1,\n\t\t.probe_delay = 0,\n\t\t.basic_rate_set = 0x0F,\n\t};\n\n\tif (priv->channel) {\n\t\tstart.band = priv->channel->band == NL80211_BAND_5GHZ ?\n\t\t\t     WSM_PHY_BAND_5G : WSM_PHY_BAND_2_4G;\n\t\tstart.channel_number = priv->channel->hw_value;\n\t} else {\n\t\tstart.band = WSM_PHY_BAND_2_4G;\n\t\tstart.channel_number = 1;\n\t}\n\n\treturn wsm_start(priv, &start);\n}\n\nint cw1200_disable_listening(struct cw1200_common *priv)\n{\n\tint ret;\n\tstruct wsm_reset reset = {\n\t\t.reset_statistics = true,\n\t};\n\tret = wsm_reset(priv, &reset);\n\treturn ret;\n}\n\nvoid cw1200_update_listening(struct cw1200_common *priv, bool enabled)\n{\n\tif (enabled) {\n\t\tif (priv->join_status == CW1200_JOIN_STATUS_PASSIVE) {\n\t\t\tif (!cw1200_enable_listening(priv))\n\t\t\t\tpriv->join_status = CW1200_JOIN_STATUS_MONITOR;\n\t\t\twsm_set_probe_responder(priv, true);\n\t\t}\n\t} else {\n\t\tif (priv->join_status == CW1200_JOIN_STATUS_MONITOR) {\n\t\t\tif (!cw1200_disable_listening(priv))\n\t\t\t\tpriv->join_status = CW1200_JOIN_STATUS_PASSIVE;\n\t\t\twsm_set_probe_responder(priv, false);\n\t\t}\n\t}\n}\n\nint cw1200_set_uapsd_param(struct cw1200_common *priv,\n\t\t\t   const struct wsm_edca_params *arg)\n{\n\tint ret;\n\tu16 uapsd_flags = 0;\n\n\t \n\n\tif (arg->uapsd_enable[0])\n\t\tuapsd_flags |= 1 << 3;\n\n\tif (arg->uapsd_enable[1])\n\t\tuapsd_flags |= 1 << 2;\n\n\tif (arg->uapsd_enable[2])\n\t\tuapsd_flags |= 1 << 1;\n\n\tif (arg->uapsd_enable[3])\n\t\tuapsd_flags |= 1;\n\n\t \n\n\tpriv->uapsd_info.uapsd_flags = cpu_to_le16(uapsd_flags);\n\tpriv->uapsd_info.min_auto_trigger_interval = 0;\n\tpriv->uapsd_info.max_auto_trigger_interval = 0;\n\tpriv->uapsd_info.auto_trigger_step = 0;\n\n\tret = wsm_set_uapsd_info(priv, &priv->uapsd_info);\n\treturn ret;\n}\n\n \n \n\nint cw1200_sta_add(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t   struct ieee80211_sta *sta)\n{\n\tstruct cw1200_common *priv = hw->priv;\n\tstruct cw1200_sta_priv *sta_priv =\n\t\t\t(struct cw1200_sta_priv *)&sta->drv_priv;\n\tstruct cw1200_link_entry *entry;\n\tstruct sk_buff *skb;\n\n\tif (priv->mode != NL80211_IFTYPE_AP)\n\t\treturn 0;\n\n\tsta_priv->link_id = cw1200_find_link_id(priv, sta->addr);\n\tif (WARN_ON(!sta_priv->link_id)) {\n\t\twiphy_info(priv->hw->wiphy,\n\t\t\t   \"[AP] No more link IDs available.\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tentry = &priv->link_id_db[sta_priv->link_id - 1];\n\tspin_lock_bh(&priv->ps_state_lock);\n\tif ((sta->uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_MASK) ==\n\t\t\t\t\tIEEE80211_WMM_IE_STA_QOSINFO_AC_MASK)\n\t\tpriv->sta_asleep_mask |= BIT(sta_priv->link_id);\n\tentry->status = CW1200_LINK_HARD;\n\twhile ((skb = skb_dequeue(&entry->rx_queue)))\n\t\tieee80211_rx_irqsafe(priv->hw, skb);\n\tspin_unlock_bh(&priv->ps_state_lock);\n\treturn 0;\n}\n\nint cw1200_sta_remove(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t      struct ieee80211_sta *sta)\n{\n\tstruct cw1200_common *priv = hw->priv;\n\tstruct cw1200_sta_priv *sta_priv =\n\t\t\t(struct cw1200_sta_priv *)&sta->drv_priv;\n\tstruct cw1200_link_entry *entry;\n\n\tif (priv->mode != NL80211_IFTYPE_AP || !sta_priv->link_id)\n\t\treturn 0;\n\n\tentry = &priv->link_id_db[sta_priv->link_id - 1];\n\tspin_lock_bh(&priv->ps_state_lock);\n\tentry->status = CW1200_LINK_RESERVE;\n\tentry->timestamp = jiffies;\n\twsm_lock_tx_async(priv);\n\tif (queue_work(priv->workqueue, &priv->link_id_work) <= 0)\n\t\twsm_unlock_tx(priv);\n\tspin_unlock_bh(&priv->ps_state_lock);\n\tflush_workqueue(priv->workqueue);\n\treturn 0;\n}\n\nstatic void __cw1200_sta_notify(struct ieee80211_hw *dev,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tenum sta_notify_cmd notify_cmd,\n\t\t\t\tint link_id)\n{\n\tstruct cw1200_common *priv = dev->priv;\n\tu32 bit, prev;\n\n\t \n\tif (link_id)\n\t\tbit = BIT(link_id);\n\telse if (WARN_ON_ONCE(notify_cmd != STA_NOTIFY_AWAKE))\n\t\tbit = 0;\n\telse\n\t\tbit = priv->link_id_map;\n\tprev = priv->sta_asleep_mask & bit;\n\n\tswitch (notify_cmd) {\n\tcase STA_NOTIFY_SLEEP:\n\t\tif (!prev) {\n\t\t\tif (priv->buffered_multicasts &&\n\t\t\t    !priv->sta_asleep_mask)\n\t\t\t\tqueue_work(priv->workqueue,\n\t\t\t\t\t   &priv->multicast_start_work);\n\t\t\tpriv->sta_asleep_mask |= bit;\n\t\t}\n\t\tbreak;\n\tcase STA_NOTIFY_AWAKE:\n\t\tif (prev) {\n\t\t\tpriv->sta_asleep_mask &= ~bit;\n\t\t\tpriv->pspoll_mask &= ~bit;\n\t\t\tif (priv->tx_multicast && link_id &&\n\t\t\t    !priv->sta_asleep_mask)\n\t\t\t\tqueue_work(priv->workqueue,\n\t\t\t\t\t   &priv->multicast_stop_work);\n\t\t\tcw1200_bh_wakeup(priv);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nvoid cw1200_sta_notify(struct ieee80211_hw *dev,\n\t\t       struct ieee80211_vif *vif,\n\t\t       enum sta_notify_cmd notify_cmd,\n\t\t       struct ieee80211_sta *sta)\n{\n\tstruct cw1200_common *priv = dev->priv;\n\tstruct cw1200_sta_priv *sta_priv =\n\t\t(struct cw1200_sta_priv *)&sta->drv_priv;\n\n\tspin_lock_bh(&priv->ps_state_lock);\n\t__cw1200_sta_notify(dev, vif, notify_cmd, sta_priv->link_id);\n\tspin_unlock_bh(&priv->ps_state_lock);\n}\n\nstatic void cw1200_ps_notify(struct cw1200_common *priv,\n\t\t      int link_id, bool ps)\n{\n\tif (link_id > CW1200_MAX_STA_IN_AP_MODE)\n\t\treturn;\n\n\tpr_debug(\"%s for LinkId: %d. STAs asleep: %.8X\\n\",\n\t\t ps ? \"Stop\" : \"Start\",\n\t\t link_id, priv->sta_asleep_mask);\n\n\t__cw1200_sta_notify(priv->hw, priv->vif,\n\t\t\t    ps ? STA_NOTIFY_SLEEP : STA_NOTIFY_AWAKE, link_id);\n}\n\nstatic int cw1200_set_tim_impl(struct cw1200_common *priv, bool aid0_bit_set)\n{\n\tstruct sk_buff *skb;\n\tstruct wsm_update_ie update_ie = {\n\t\t.what = WSM_UPDATE_IE_BEACON,\n\t\t.count = 1,\n\t};\n\tu16 tim_offset, tim_length;\n\n\tpr_debug(\"[AP] mcast: %s.\\n\", aid0_bit_set ? \"ena\" : \"dis\");\n\n\tskb = ieee80211_beacon_get_tim(priv->hw, priv->vif,\n\t\t\t\t       &tim_offset, &tim_length, 0);\n\tif (!skb) {\n\t\tif (!__cw1200_flush(priv, true))\n\t\t\twsm_unlock_tx(priv);\n\t\treturn -ENOENT;\n\t}\n\n\tif (tim_offset && tim_length >= 6) {\n\t\t \n\t\tskb->data[tim_offset + 2] = 0;\n\n\t\t \n\t\tif (aid0_bit_set)\n\t\t\tskb->data[tim_offset + 4] |= 1;\n\t\telse\n\t\t\tskb->data[tim_offset + 4] &= ~1;\n\t}\n\n\tupdate_ie.ies = &skb->data[tim_offset];\n\tupdate_ie.length = tim_length;\n\twsm_update_ie(priv, &update_ie);\n\n\tdev_kfree_skb(skb);\n\n\treturn 0;\n}\n\nvoid cw1200_set_tim_work(struct work_struct *work)\n{\n\tstruct cw1200_common *priv =\n\t\tcontainer_of(work, struct cw1200_common, set_tim_work);\n\t(void)cw1200_set_tim_impl(priv, priv->aid0_bit_set);\n}\n\nint cw1200_set_tim(struct ieee80211_hw *dev, struct ieee80211_sta *sta,\n\t\t   bool set)\n{\n\tstruct cw1200_common *priv = dev->priv;\n\tqueue_work(priv->workqueue, &priv->set_tim_work);\n\treturn 0;\n}\n\nvoid cw1200_set_cts_work(struct work_struct *work)\n{\n\tstruct cw1200_common *priv =\n\t\tcontainer_of(work, struct cw1200_common, set_cts_work);\n\n\tu8 erp_ie[3] = {WLAN_EID_ERP_INFO, 0x1, 0};\n\tstruct wsm_update_ie update_ie = {\n\t\t.what = WSM_UPDATE_IE_BEACON,\n\t\t.count = 1,\n\t\t.ies = erp_ie,\n\t\t.length = 3,\n\t};\n\tu32 erp_info;\n\t__le32 use_cts_prot;\n\tmutex_lock(&priv->conf_mutex);\n\terp_info = priv->erp_info;\n\tmutex_unlock(&priv->conf_mutex);\n\tuse_cts_prot =\n\t\terp_info & WLAN_ERP_USE_PROTECTION ?\n\t\t__cpu_to_le32(1) : 0;\n\n\terp_ie[ERP_INFO_BYTE_OFFSET] = erp_info;\n\n\tpr_debug(\"[STA] ERP information 0x%x\\n\", erp_info);\n\n\twsm_write_mib(priv, WSM_MIB_ID_NON_ERP_PROTECTION,\n\t\t      &use_cts_prot, sizeof(use_cts_prot));\n\twsm_update_ie(priv, &update_ie);\n\n\treturn;\n}\n\nstatic int cw1200_set_btcoexinfo(struct cw1200_common *priv)\n{\n\tstruct wsm_override_internal_txrate arg;\n\tint ret = 0;\n\n\tif (priv->mode == NL80211_IFTYPE_STATION) {\n\t\t \n\t\tcw1200_upload_pspoll(priv);\n\t\tcw1200_upload_null(priv);\n\t\tcw1200_upload_qosnull(priv);\n\t} else {\n\t\treturn 0;\n\t}\n\n\tmemset(&arg, 0, sizeof(struct wsm_override_internal_txrate));\n\n\tif (!priv->vif->p2p) {\n\t\t \n\t\tif (priv->bss_params.operational_rate_set & ~0xF) {\n\t\t\tpr_debug(\"[STA] STA has ERP rates\\n\");\n\t\t\t \n\t\t\targ.internalTxRate = (__ffs(\n\t\t\tpriv->bss_params.operational_rate_set & ~0xF));\n\t\t} else {\n\t\t\tpr_debug(\"[STA] STA has non ERP rates\\n\");\n\t\t\t \n\t\t\targ.internalTxRate = (__ffs(le32_to_cpu(priv->association_mode.basic_rate_set)));\n\t\t}\n\t\targ.nonErpInternalTxRate = (__ffs(le32_to_cpu(priv->association_mode.basic_rate_set)));\n\t} else {\n\t\t \n\t\targ.internalTxRate = (__ffs(priv->bss_params.operational_rate_set & ~0xF));\n\t\targ.nonErpInternalTxRate = (__ffs(priv->bss_params.operational_rate_set & ~0xF));\n\t}\n\n\tpr_debug(\"[STA] BTCOEX_INFO MODE %d, internalTxRate : %x, nonErpInternalTxRate: %x\\n\",\n\t\t priv->mode,\n\t\t arg.internalTxRate,\n\t\t arg.nonErpInternalTxRate);\n\n\tret = wsm_write_mib(priv, WSM_MIB_ID_OVERRIDE_INTERNAL_TX_RATE,\n\t\t\t    &arg, sizeof(arg));\n\n\treturn ret;\n}\n\nvoid cw1200_bss_info_changed(struct ieee80211_hw *dev,\n\t\t\t     struct ieee80211_vif *vif,\n\t\t\t     struct ieee80211_bss_conf *info,\n\t\t\t     u64 changed)\n{\n\tstruct cw1200_common *priv = dev->priv;\n\tbool do_join = false;\n\n\tmutex_lock(&priv->conf_mutex);\n\n\tpr_debug(\"BSS CHANGED:  %llx\\n\", changed);\n\n\t \n\t \n\n\tif (changed & BSS_CHANGED_ARP_FILTER) {\n\t\tstruct wsm_mib_arp_ipv4_filter filter = {0};\n\t\tint i;\n\n\t\tpr_debug(\"[STA] BSS_CHANGED_ARP_FILTER cnt: %d\\n\",\n\t\t\t vif->cfg.arp_addr_cnt);\n\n\t\t \n\t\tif (vif->cfg.arp_addr_cnt > 0 &&\n\t\t    vif->cfg.arp_addr_cnt <= WSM_MAX_ARP_IP_ADDRTABLE_ENTRIES) {\n\t\t\tfor (i = 0; i < vif->cfg.arp_addr_cnt; i++) {\n\t\t\t\tfilter.ipv4addrs[i] = vif->cfg.arp_addr_list[i];\n\t\t\t\tpr_debug(\"[STA] addr[%d]: 0x%X\\n\",\n\t\t\t\t\t i, filter.ipv4addrs[i]);\n\t\t\t}\n\t\t\tfilter.enable = __cpu_to_le32(1);\n\t\t}\n\n\t\tpr_debug(\"[STA] arp ip filter enable: %d\\n\",\n\t\t\t __le32_to_cpu(filter.enable));\n\n\t\twsm_set_arp_ipv4_filter(priv, &filter);\n\t}\n\n\tif (changed &\n\t    (BSS_CHANGED_BEACON |\n\t     BSS_CHANGED_AP_PROBE_RESP |\n\t     BSS_CHANGED_BSSID |\n\t     BSS_CHANGED_SSID |\n\t     BSS_CHANGED_IBSS)) {\n\t\tpr_debug(\"BSS_CHANGED_BEACON\\n\");\n\t\tpriv->beacon_int = info->beacon_int;\n\t\tcw1200_update_beaconing(priv);\n\t\tcw1200_upload_beacon(priv);\n\t}\n\n\tif (changed & BSS_CHANGED_BEACON_ENABLED) {\n\t\tpr_debug(\"BSS_CHANGED_BEACON_ENABLED (%d)\\n\", info->enable_beacon);\n\n\t\tif (priv->enable_beacon != info->enable_beacon) {\n\t\t\tcw1200_enable_beaconing(priv, info->enable_beacon);\n\t\t\tpriv->enable_beacon = info->enable_beacon;\n\t\t}\n\t}\n\n\tif (changed & BSS_CHANGED_BEACON_INT) {\n\t\tpr_debug(\"CHANGED_BEACON_INT\\n\");\n\t\tif (vif->cfg.ibss_joined)\n\t\t\tdo_join = true;\n\t\telse if (priv->join_status == CW1200_JOIN_STATUS_AP)\n\t\t\tcw1200_update_beaconing(priv);\n\t}\n\n\t \n\tif (changed & BSS_CHANGED_ASSOC) {\n\t\twsm_lock_tx(priv);\n\t\tpriv->wep_default_key_id = -1;\n\t\twsm_unlock_tx(priv);\n\t}\n\n\tif (changed & BSS_CHANGED_BSSID) {\n\t\tpr_debug(\"BSS_CHANGED_BSSID\\n\");\n\t\tdo_join = true;\n\t}\n\n\tif (changed &\n\t    (BSS_CHANGED_ASSOC |\n\t     BSS_CHANGED_BSSID |\n\t     BSS_CHANGED_IBSS |\n\t     BSS_CHANGED_BASIC_RATES |\n\t     BSS_CHANGED_HT)) {\n\t\tpr_debug(\"BSS_CHANGED_ASSOC\\n\");\n\t\tif (vif->cfg.assoc) {\n\t\t\tif (priv->join_status < CW1200_JOIN_STATUS_PRE_STA) {\n\t\t\t\tieee80211_connection_loss(vif);\n\t\t\t\tmutex_unlock(&priv->conf_mutex);\n\t\t\t\treturn;\n\t\t\t} else if (priv->join_status == CW1200_JOIN_STATUS_PRE_STA) {\n\t\t\t\tpriv->join_status = CW1200_JOIN_STATUS_STA;\n\t\t\t}\n\t\t} else {\n\t\t\tdo_join = true;\n\t\t}\n\n\t\tif (vif->cfg.assoc || vif->cfg.ibss_joined) {\n\t\t\tstruct ieee80211_sta *sta = NULL;\n\t\t\t__le32 htprot = 0;\n\n\t\t\tif (info->dtim_period)\n\t\t\t\tpriv->join_dtim_period = info->dtim_period;\n\t\t\tpriv->beacon_int = info->beacon_int;\n\n\t\t\trcu_read_lock();\n\n\t\t\tif (info->bssid && !vif->cfg.ibss_joined)\n\t\t\t\tsta = ieee80211_find_sta(vif, info->bssid);\n\t\t\tif (sta) {\n\t\t\t\tpriv->ht_info.ht_cap = sta->deflink.ht_cap;\n\t\t\t\tpriv->bss_params.operational_rate_set =\n\t\t\t\t\tcw1200_rate_mask_to_wsm(priv,\n\t\t\t\t\t\tsta->deflink.supp_rates[priv->channel->band]);\n\t\t\t\tpriv->ht_info.channel_type = cfg80211_get_chandef_type(&dev->conf.chandef);\n\t\t\t\tpriv->ht_info.operation_mode = info->ht_operation_mode;\n\t\t\t} else {\n\t\t\t\tmemset(&priv->ht_info, 0,\n\t\t\t\t       sizeof(priv->ht_info));\n\t\t\t\tpriv->bss_params.operational_rate_set = -1;\n\t\t\t}\n\t\t\trcu_read_unlock();\n\n\t\t\t \n\t\t\tif (priv->ht_info.operation_mode &\n\t\t\t    IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT)\n\t\t\t\thtprot |= cpu_to_le32(WSM_NON_GREENFIELD_STA_PRESENT);\n\n\t\t\t \n\t\t\thtprot |= cpu_to_le32((priv->ht_info.operation_mode & IEEE80211_HT_OP_MODE_PROTECTION) << 2);\n\n\t\t\t \n\n\t\t\twsm_write_mib(priv, WSM_MIB_ID_SET_HT_PROTECTION,\n\t\t\t\t      &htprot, sizeof(htprot));\n\n\t\t\tpriv->association_mode.greenfield =\n\t\t\t\tcw1200_ht_greenfield(&priv->ht_info);\n\t\t\tpriv->association_mode.flags =\n\t\t\t\tWSM_ASSOCIATION_MODE_SNOOP_ASSOC_FRAMES |\n\t\t\t\tWSM_ASSOCIATION_MODE_USE_PREAMBLE_TYPE |\n\t\t\t\tWSM_ASSOCIATION_MODE_USE_HT_MODE |\n\t\t\t\tWSM_ASSOCIATION_MODE_USE_BASIC_RATE_SET |\n\t\t\t\tWSM_ASSOCIATION_MODE_USE_MPDU_START_SPACING;\n\t\t\tpriv->association_mode.preamble =\n\t\t\t\tinfo->use_short_preamble ?\n\t\t\t\tWSM_JOIN_PREAMBLE_SHORT :\n\t\t\t\tWSM_JOIN_PREAMBLE_LONG;\n\t\t\tpriv->association_mode.basic_rate_set = __cpu_to_le32(\n\t\t\t\tcw1200_rate_mask_to_wsm(priv,\n\t\t\t\t\t\t\tinfo->basic_rates));\n\t\t\tpriv->association_mode.mpdu_start_spacing =\n\t\t\t\tcw1200_ht_ampdu_density(&priv->ht_info);\n\n\t\t\tcw1200_cqm_bssloss_sm(priv, 0, 0, 0);\n\t\t\tcancel_work_sync(&priv->unjoin_work);\n\n\t\t\tpriv->bss_params.beacon_lost_count = priv->cqm_beacon_loss_count;\n\t\t\tpriv->bss_params.aid = vif->cfg.aid;\n\n\t\t\tif (priv->join_dtim_period < 1)\n\t\t\t\tpriv->join_dtim_period = 1;\n\n\t\t\tpr_debug(\"[STA] DTIM %d, interval: %d\\n\",\n\t\t\t\t priv->join_dtim_period, priv->beacon_int);\n\t\t\tpr_debug(\"[STA] Preamble: %d, Greenfield: %d, Aid: %d, Rates: 0x%.8X, Basic: 0x%.8X\\n\",\n\t\t\t\t priv->association_mode.preamble,\n\t\t\t\t priv->association_mode.greenfield,\n\t\t\t\t priv->bss_params.aid,\n\t\t\t\t priv->bss_params.operational_rate_set,\n\t\t\t\t priv->association_mode.basic_rate_set);\n\t\t\twsm_set_association_mode(priv, &priv->association_mode);\n\n\t\t\tif (!vif->cfg.ibss_joined) {\n\t\t\t\twsm_keep_alive_period(priv, 30  );\n\t\t\t\twsm_set_bss_params(priv, &priv->bss_params);\n\t\t\t\tpriv->setbssparams_done = true;\n\t\t\t\tcw1200_set_beacon_wakeup_period_work(&priv->set_beacon_wakeup_period_work);\n\t\t\t\tcw1200_set_pm(priv, &priv->powersave_mode);\n\t\t\t}\n\t\t\tif (priv->vif->p2p) {\n\t\t\t\tpr_debug(\"[STA] Setting p2p powersave configuration.\\n\");\n\t\t\t\twsm_set_p2p_ps_modeinfo(priv,\n\t\t\t\t\t\t\t&priv->p2p_ps_modeinfo);\n\t\t\t}\n\t\t\tif (priv->bt_present)\n\t\t\t\tcw1200_set_btcoexinfo(priv);\n\t\t} else {\n\t\t\tmemset(&priv->association_mode, 0,\n\t\t\t       sizeof(priv->association_mode));\n\t\t\tmemset(&priv->bss_params, 0, sizeof(priv->bss_params));\n\t\t}\n\t}\n\n\t \n\tif (changed & (BSS_CHANGED_ASSOC |\n\t\t       BSS_CHANGED_ERP_CTS_PROT |\n\t\t       BSS_CHANGED_ERP_PREAMBLE)) {\n\t\tu32 prev_erp_info = priv->erp_info;\n\t\tif (info->use_cts_prot)\n\t\t\tpriv->erp_info |= WLAN_ERP_USE_PROTECTION;\n\t\telse if (!(prev_erp_info & WLAN_ERP_NON_ERP_PRESENT))\n\t\t\tpriv->erp_info &= ~WLAN_ERP_USE_PROTECTION;\n\n\t\tif (info->use_short_preamble)\n\t\t\tpriv->erp_info |= WLAN_ERP_BARKER_PREAMBLE;\n\t\telse\n\t\t\tpriv->erp_info &= ~WLAN_ERP_BARKER_PREAMBLE;\n\n\t\tpr_debug(\"[STA] ERP Protection: %x\\n\", priv->erp_info);\n\n\t\tif (prev_erp_info != priv->erp_info)\n\t\t\tqueue_work(priv->workqueue, &priv->set_cts_work);\n\t}\n\n\t \n\tif (changed & (BSS_CHANGED_ASSOC | BSS_CHANGED_ERP_SLOT)) {\n\t\t__le32 slot_time = info->use_short_slot ?\n\t\t\t__cpu_to_le32(9) : __cpu_to_le32(20);\n\t\tpr_debug(\"[STA] Slot time: %d us.\\n\",\n\t\t\t __le32_to_cpu(slot_time));\n\t\twsm_write_mib(priv, WSM_MIB_ID_DOT11_SLOT_TIME,\n\t\t\t      &slot_time, sizeof(slot_time));\n\t}\n\n\tif (changed & (BSS_CHANGED_ASSOC | BSS_CHANGED_CQM)) {\n\t\tstruct wsm_rcpi_rssi_threshold threshold = {\n\t\t\t.rollingAverageCount = 8,\n\t\t};\n\t\tpr_debug(\"[CQM] RSSI threshold subscribe: %d +- %d\\n\",\n\t\t\t info->cqm_rssi_thold, info->cqm_rssi_hyst);\n\t\tpriv->cqm_rssi_thold = info->cqm_rssi_thold;\n\t\tpriv->cqm_rssi_hyst = info->cqm_rssi_hyst;\n\n\t\tif (info->cqm_rssi_thold || info->cqm_rssi_hyst) {\n\t\t\t \n\t\t\t \n\n\t\t\t \n\t\t\tif (priv->cqm_use_rssi) {\n\t\t\t\tthreshold.upperThreshold =\n\t\t\t\t\tinfo->cqm_rssi_thold + info->cqm_rssi_hyst;\n\t\t\t\tthreshold.lowerThreshold =\n\t\t\t\t\tinfo->cqm_rssi_thold;\n\t\t\t\tthreshold.rssiRcpiMode |= WSM_RCPI_RSSI_USE_RSSI;\n\t\t\t} else {\n\t\t\t\tthreshold.upperThreshold = (info->cqm_rssi_thold + info->cqm_rssi_hyst + 110) * 2;\n\t\t\t\tthreshold.lowerThreshold = (info->cqm_rssi_thold + 110) * 2;\n\t\t\t}\n\t\t\tthreshold.rssiRcpiMode |= WSM_RCPI_RSSI_THRESHOLD_ENABLE;\n\t\t} else {\n\t\t\t \n\t\t\tthreshold.rssiRcpiMode |=\n\t\t\t\tWSM_RCPI_RSSI_THRESHOLD_ENABLE |\n\t\t\t\tWSM_RCPI_RSSI_DONT_USE_UPPER |\n\t\t\t\tWSM_RCPI_RSSI_DONT_USE_LOWER;\n\t\t\tif (priv->cqm_use_rssi)\n\t\t\t\tthreshold.rssiRcpiMode |= WSM_RCPI_RSSI_USE_RSSI;\n\t\t}\n\t\twsm_set_rcpi_rssi_threshold(priv, &threshold);\n\t}\n\tmutex_unlock(&priv->conf_mutex);\n\n\tif (do_join) {\n\t\twsm_lock_tx(priv);\n\t\tcw1200_do_join(priv);  \n\t}\n}\n\nvoid cw1200_multicast_start_work(struct work_struct *work)\n{\n\tstruct cw1200_common *priv =\n\t\tcontainer_of(work, struct cw1200_common, multicast_start_work);\n\tlong tmo = priv->join_dtim_period *\n\t\t\t(priv->beacon_int + 20) * HZ / 1024;\n\n\tcancel_work_sync(&priv->multicast_stop_work);\n\n\tif (!priv->aid0_bit_set) {\n\t\twsm_lock_tx(priv);\n\t\tcw1200_set_tim_impl(priv, true);\n\t\tpriv->aid0_bit_set = true;\n\t\tmod_timer(&priv->mcast_timeout, jiffies + tmo);\n\t\twsm_unlock_tx(priv);\n\t}\n}\n\nvoid cw1200_multicast_stop_work(struct work_struct *work)\n{\n\tstruct cw1200_common *priv =\n\t\tcontainer_of(work, struct cw1200_common, multicast_stop_work);\n\n\tif (priv->aid0_bit_set) {\n\t\tdel_timer_sync(&priv->mcast_timeout);\n\t\twsm_lock_tx(priv);\n\t\tpriv->aid0_bit_set = false;\n\t\tcw1200_set_tim_impl(priv, false);\n\t\twsm_unlock_tx(priv);\n\t}\n}\n\nvoid cw1200_mcast_timeout(struct timer_list *t)\n{\n\tstruct cw1200_common *priv = from_timer(priv, t, mcast_timeout);\n\n\twiphy_warn(priv->hw->wiphy,\n\t\t   \"Multicast delivery timeout.\\n\");\n\tspin_lock_bh(&priv->ps_state_lock);\n\tpriv->tx_multicast = priv->aid0_bit_set &&\n\t\t\tpriv->buffered_multicasts;\n\tif (priv->tx_multicast)\n\t\tcw1200_bh_wakeup(priv);\n\tspin_unlock_bh(&priv->ps_state_lock);\n}\n\nint cw1200_ampdu_action(struct ieee80211_hw *hw,\n\t\t\tstruct ieee80211_vif *vif,\n\t\t\tstruct ieee80211_ampdu_params *params)\n{\n\t \n\n\t \n\treturn -ENOTSUPP;\n}\n\n \n \nvoid cw1200_suspend_resume(struct cw1200_common *priv,\n\t\t\t  struct wsm_suspend_resume *arg)\n{\n\tpr_debug(\"[AP] %s: %s\\n\",\n\t\t arg->stop ? \"stop\" : \"start\",\n\t\t arg->multicast ? \"broadcast\" : \"unicast\");\n\n\tif (arg->multicast) {\n\t\tbool cancel_tmo = false;\n\t\tspin_lock_bh(&priv->ps_state_lock);\n\t\tif (arg->stop) {\n\t\t\tpriv->tx_multicast = false;\n\t\t} else {\n\t\t\t \n\t\t\tcw1200_pm_stay_awake(&priv->pm_state,\n\t\t\t\t\t     priv->join_dtim_period *\n\t\t\t\t\t     (priv->beacon_int + 20) * HZ / 1024);\n\t\t\tpriv->tx_multicast = (priv->aid0_bit_set &&\n\t\t\t\t\t      priv->buffered_multicasts);\n\t\t\tif (priv->tx_multicast) {\n\t\t\t\tcancel_tmo = true;\n\t\t\t\tcw1200_bh_wakeup(priv);\n\t\t\t}\n\t\t}\n\t\tspin_unlock_bh(&priv->ps_state_lock);\n\t\tif (cancel_tmo)\n\t\t\tdel_timer_sync(&priv->mcast_timeout);\n\t} else {\n\t\tspin_lock_bh(&priv->ps_state_lock);\n\t\tcw1200_ps_notify(priv, arg->link_id, arg->stop);\n\t\tspin_unlock_bh(&priv->ps_state_lock);\n\t\tif (!arg->stop)\n\t\t\tcw1200_bh_wakeup(priv);\n\t}\n\treturn;\n}\n\n \n \n\nstatic int cw1200_upload_beacon(struct cw1200_common *priv)\n{\n\tint ret = 0;\n\tstruct ieee80211_mgmt *mgmt;\n\tstruct wsm_template_frame frame = {\n\t\t.frame_type = WSM_FRAME_TYPE_BEACON,\n\t};\n\n\tu16 tim_offset;\n\tu16 tim_len;\n\n\tif (priv->mode == NL80211_IFTYPE_STATION ||\n\t    priv->mode == NL80211_IFTYPE_MONITOR ||\n\t    priv->mode == NL80211_IFTYPE_UNSPECIFIED)\n\t\tgoto done;\n\n\tif (priv->vif->p2p)\n\t\tframe.rate = WSM_TRANSMIT_RATE_6;\n\n\tframe.skb = ieee80211_beacon_get_tim(priv->hw, priv->vif,\n\t\t\t\t\t     &tim_offset, &tim_len, 0);\n\tif (!frame.skb)\n\t\treturn -ENOMEM;\n\n\tret = wsm_set_template_frame(priv, &frame);\n\n\tif (ret)\n\t\tgoto done;\n\n\t \n\tmgmt = (void *)frame.skb->data;\n\tmgmt->frame_control =\n\t\t__cpu_to_le16(IEEE80211_FTYPE_MGMT |\n\t\t\t      IEEE80211_STYPE_PROBE_RESP);\n\n\tframe.frame_type = WSM_FRAME_TYPE_PROBE_RESPONSE;\n\tif (priv->vif->p2p) {\n\t\tret = wsm_set_probe_responder(priv, true);\n\t} else {\n\t\tret = wsm_set_template_frame(priv, &frame);\n\t\twsm_set_probe_responder(priv, false);\n\t}\n\ndone:\n\tdev_kfree_skb(frame.skb);\n\n\treturn ret;\n}\n\nstatic int cw1200_upload_pspoll(struct cw1200_common *priv)\n{\n\tint ret = 0;\n\tstruct wsm_template_frame frame = {\n\t\t.frame_type = WSM_FRAME_TYPE_PS_POLL,\n\t\t.rate = 0xFF,\n\t};\n\n\n\tframe.skb = ieee80211_pspoll_get(priv->hw, priv->vif);\n\tif (!frame.skb)\n\t\treturn -ENOMEM;\n\n\tret = wsm_set_template_frame(priv, &frame);\n\n\tdev_kfree_skb(frame.skb);\n\n\treturn ret;\n}\n\nstatic int cw1200_upload_null(struct cw1200_common *priv)\n{\n\tint ret = 0;\n\tstruct wsm_template_frame frame = {\n\t\t.frame_type = WSM_FRAME_TYPE_NULL,\n\t\t.rate = 0xFF,\n\t};\n\n\tframe.skb = ieee80211_nullfunc_get(priv->hw, priv->vif,-1, false);\n\tif (!frame.skb)\n\t\treturn -ENOMEM;\n\n\tret = wsm_set_template_frame(priv, &frame);\n\n\tdev_kfree_skb(frame.skb);\n\n\treturn ret;\n}\n\nstatic int cw1200_upload_qosnull(struct cw1200_common *priv)\n{\n\t \n\treturn 0;\n}\n\nstatic int cw1200_enable_beaconing(struct cw1200_common *priv,\n\t\t\t\t   bool enable)\n{\n\tstruct wsm_beacon_transmit transmit = {\n\t\t.enable_beaconing = enable,\n\t};\n\n\treturn wsm_beacon_transmit(priv, &transmit);\n}\n\nstatic int cw1200_start_ap(struct cw1200_common *priv)\n{\n\tint ret;\n\tstruct ieee80211_bss_conf *conf = &priv->vif->bss_conf;\n\tstruct wsm_start start = {\n\t\t.mode = priv->vif->p2p ?\n\t\t\t\tWSM_START_MODE_P2P_GO : WSM_START_MODE_AP,\n\t\t.band = (priv->channel->band == NL80211_BAND_5GHZ) ?\n\t\t\t\tWSM_PHY_BAND_5G : WSM_PHY_BAND_2_4G,\n\t\t.channel_number = priv->channel->hw_value,\n\t\t.beacon_interval = conf->beacon_int,\n\t\t.dtim_period = conf->dtim_period,\n\t\t.preamble = conf->use_short_preamble ?\n\t\t\t\tWSM_JOIN_PREAMBLE_SHORT :\n\t\t\t\tWSM_JOIN_PREAMBLE_LONG,\n\t\t.probe_delay = 100,\n\t\t.basic_rate_set = cw1200_rate_mask_to_wsm(priv,\n\t\t\t\tconf->basic_rates),\n\t};\n\tstruct wsm_operational_mode mode = {\n\t\t.power_mode = cw1200_power_mode,\n\t\t.disable_more_flag_usage = true,\n\t};\n\n\tmemset(start.ssid, 0, sizeof(start.ssid));\n\tif (!conf->hidden_ssid) {\n\t\tstart.ssid_len = priv->vif->cfg.ssid_len;\n\t\tmemcpy(start.ssid, priv->vif->cfg.ssid, start.ssid_len);\n\t}\n\n\tpriv->beacon_int = conf->beacon_int;\n\tpriv->join_dtim_period = conf->dtim_period;\n\n\tmemset(&priv->link_id_db, 0, sizeof(priv->link_id_db));\n\n\tpr_debug(\"[AP] ch: %d(%d), bcn: %d(%d), brt: 0x%.8X, ssid: %.*s.\\n\",\n\t\t start.channel_number, start.band,\n\t\t start.beacon_interval, start.dtim_period,\n\t\t start.basic_rate_set,\n\t\t start.ssid_len, start.ssid);\n\tret = wsm_start(priv, &start);\n\tif (!ret)\n\t\tret = cw1200_upload_keys(priv);\n\tif (!ret && priv->vif->p2p) {\n\t\tpr_debug(\"[AP] Setting p2p powersave configuration.\\n\");\n\t\twsm_set_p2p_ps_modeinfo(priv, &priv->p2p_ps_modeinfo);\n\t}\n\tif (!ret) {\n\t\twsm_set_block_ack_policy(priv, 0, 0);\n\t\tpriv->join_status = CW1200_JOIN_STATUS_AP;\n\t\tcw1200_update_filtering(priv);\n\t}\n\twsm_set_operational_mode(priv, &mode);\n\treturn ret;\n}\n\nstatic int cw1200_update_beaconing(struct cw1200_common *priv)\n{\n\tstruct ieee80211_bss_conf *conf = &priv->vif->bss_conf;\n\tstruct wsm_reset reset = {\n\t\t.link_id = 0,\n\t\t.reset_statistics = true,\n\t};\n\n\tif (priv->mode == NL80211_IFTYPE_AP) {\n\t\t \n\t\tif (priv->join_status != CW1200_JOIN_STATUS_AP ||\n\t\t    priv->beacon_int != conf->beacon_int) {\n\t\t\tpr_debug(\"ap restarting\\n\");\n\t\t\twsm_lock_tx(priv);\n\t\t\tif (priv->join_status != CW1200_JOIN_STATUS_PASSIVE)\n\t\t\t\twsm_reset(priv, &reset);\n\t\t\tpriv->join_status = CW1200_JOIN_STATUS_PASSIVE;\n\t\t\tcw1200_start_ap(priv);\n\t\t\twsm_unlock_tx(priv);\n\t\t} else\n\t\t\tpr_debug(\"ap started join_status: %d\\n\",\n\t\t\t\t priv->join_status);\n\t}\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}