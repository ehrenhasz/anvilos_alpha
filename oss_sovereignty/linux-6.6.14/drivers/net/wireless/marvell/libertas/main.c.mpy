{
  "module_name": "main.c",
  "hash_id": "a1d377ab41b37a7e579f446c71f5c25ba5effd354b06ac242f4a8eb9cf36597c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/marvell/libertas/main.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/etherdevice.h>\n#include <linux/hardirq.h>\n#include <linux/netdevice.h>\n#include <linux/if_arp.h>\n#include <linux/kthread.h>\n#include <linux/kfifo.h>\n#include <linux/slab.h>\n#include <net/cfg80211.h>\n\n#include \"host.h\"\n#include \"decl.h\"\n#include \"dev.h\"\n#include \"cfg.h\"\n#include \"debugfs.h\"\n#include \"cmd.h\"\n#include \"mesh.h\"\n\n#define DRIVER_RELEASE_VERSION \"323.p0\"\nconst char lbs_driver_version[] = \"COMM-USB8388-\" DRIVER_RELEASE_VERSION\n#ifdef  DEBUG\n    \"-dbg\"\n#endif\n    \"\";\n\n\n \nunsigned int lbs_debug;\nEXPORT_SYMBOL_GPL(lbs_debug);\nmodule_param_named(libertas_debug, lbs_debug, int, 0644);\n\nstatic unsigned int lbs_disablemesh;\nmodule_param_named(libertas_disablemesh, lbs_disablemesh, int, 0644);\n\n\n \nstruct cmd_confirm_sleep confirm_sleep;\n\n\n \nu16 lbs_region_code_to_index[MRVDRV_MAX_REGION_CODE] =\n    { 0x10, 0x20, 0x30, 0x31, 0x32, 0x40 };\n\n \nstatic u8 fw_data_rates[MAX_RATES] =\n    { 0x02, 0x04, 0x0B, 0x16, 0x00, 0x0C, 0x12,\n      0x18, 0x24, 0x30, 0x48, 0x60, 0x6C, 0x00\n};\n\n \nu32 lbs_fw_index_to_data_rate(u8 idx)\n{\n\tif (idx >= sizeof(fw_data_rates))\n\t\tidx = 0;\n\treturn fw_data_rates[idx];\n}\n\n \nu8 lbs_data_rate_to_fw_index(u32 rate)\n{\n\tu8 i;\n\n\tif (!rate)\n\t\treturn 0;\n\n\tfor (i = 0; i < sizeof(fw_data_rates); i++) {\n\t\tif (rate == fw_data_rates[i])\n\t\t\treturn i;\n\t}\n\treturn 0;\n}\n\nint lbs_set_iface_type(struct lbs_private *priv, enum nl80211_iftype type)\n{\n\tint ret = 0;\n\n\tswitch (type) {\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tret = lbs_set_monitor_mode(priv, 1);\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (priv->wdev->iftype == NL80211_IFTYPE_MONITOR)\n\t\t\tret = lbs_set_monitor_mode(priv, 0);\n\t\tif (!ret)\n\t\t\tret = lbs_set_snmp_mib(priv, SNMP_MIB_OID_BSS_TYPE, 1);\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tif (priv->wdev->iftype == NL80211_IFTYPE_MONITOR)\n\t\t\tret = lbs_set_monitor_mode(priv, 0);\n\t\tif (!ret)\n\t\t\tret = lbs_set_snmp_mib(priv, SNMP_MIB_OID_BSS_TYPE, 2);\n\t\tbreak;\n\tdefault:\n\t\tret = -ENOTSUPP;\n\t}\n\treturn ret;\n}\n\nint lbs_start_iface(struct lbs_private *priv)\n{\n\tstruct cmd_ds_802_11_mac_address cmd;\n\tint ret;\n\n\tif (priv->power_restore) {\n\t\tret = priv->power_restore(priv);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tcmd.hdr.size = cpu_to_le16(sizeof(cmd));\n\tcmd.action = cpu_to_le16(CMD_ACT_SET);\n\tmemcpy(cmd.macadd, priv->current_addr, ETH_ALEN);\n\n\tret = lbs_cmd_with_response(priv, CMD_802_11_MAC_ADDRESS, &cmd);\n\tif (ret) {\n\t\tlbs_deb_net(\"set MAC address failed\\n\");\n\t\tgoto err;\n\t}\n\n\tret = lbs_set_iface_type(priv, priv->wdev->iftype);\n\tif (ret) {\n\t\tlbs_deb_net(\"set iface type failed\\n\");\n\t\tgoto err;\n\t}\n\n\tret = lbs_set_11d_domain_info(priv);\n\tif (ret) {\n\t\tlbs_deb_net(\"set 11d domain info failed\\n\");\n\t\tgoto err;\n\t}\n\n\tlbs_update_channel(priv);\n\n\tpriv->iface_running = true;\n\treturn 0;\n\nerr:\n\tif (priv->power_save)\n\t\tpriv->power_save(priv);\n\treturn ret;\n}\n\n \nstatic int lbs_dev_open(struct net_device *dev)\n{\n\tstruct lbs_private *priv = dev->ml_priv;\n\tint ret = 0;\n\n\tif (!priv->iface_running) {\n\t\tret = lbs_start_iface(priv);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tspin_lock_irq(&priv->driver_lock);\n\n\tnetif_carrier_off(dev);\n\n\tif (!priv->tx_pending_len)\n\t\tnetif_wake_queue(dev);\n\n\tspin_unlock_irq(&priv->driver_lock);\n\nout:\n\treturn ret;\n}\n\nstatic bool lbs_command_queue_empty(struct lbs_private *priv)\n{\n\tunsigned long flags;\n\tbool ret;\n\tspin_lock_irqsave(&priv->driver_lock, flags);\n\tret = priv->cur_cmd == NULL && list_empty(&priv->cmdpendingq);\n\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\treturn ret;\n}\n\nint lbs_stop_iface(struct lbs_private *priv)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&priv->driver_lock, flags);\n\tpriv->iface_running = false;\n\tdev_kfree_skb_irq(priv->currenttxskb);\n\tpriv->currenttxskb = NULL;\n\tpriv->tx_pending_len = 0;\n\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\n\tcancel_work_sync(&priv->mcast_work);\n\tdel_timer_sync(&priv->tx_lockup_timer);\n\n\t \n\tlbs_deb_main(\"waiting for commands to complete\\n\");\n\twait_event(priv->waitq, lbs_command_queue_empty(priv));\n\tlbs_deb_main(\"all commands completed\\n\");\n\n\tif (priv->power_save)\n\t\tret = priv->power_save(priv);\n\n\treturn ret;\n}\n\n \nstatic int lbs_eth_stop(struct net_device *dev)\n{\n\tstruct lbs_private *priv = dev->ml_priv;\n\n\tif (priv->connect_status == LBS_CONNECTED)\n\t\tlbs_disconnect(priv, WLAN_REASON_DEAUTH_LEAVING);\n\n\tspin_lock_irq(&priv->driver_lock);\n\tnetif_stop_queue(dev);\n\tspin_unlock_irq(&priv->driver_lock);\n\n\tlbs_update_mcast(priv);\n\tcancel_delayed_work_sync(&priv->scan_work);\n\tif (priv->scan_req)\n\t\tlbs_scan_done(priv);\n\n\tnetif_carrier_off(priv->dev);\n\n\tif (!lbs_iface_active(priv))\n\t\tlbs_stop_iface(priv);\n\n\treturn 0;\n}\n\nvoid lbs_host_to_card_done(struct lbs_private *priv)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->driver_lock, flags);\n\tdel_timer(&priv->tx_lockup_timer);\n\n\tpriv->dnld_sent = DNLD_RES_RECEIVED;\n\n\t \n\tif (!priv->cur_cmd || priv->tx_pending_len > 0) {\n\t\tif (!priv->wakeup_dev_required)\n\t\t\twake_up(&priv->waitq);\n\t}\n\n\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n}\nEXPORT_SYMBOL_GPL(lbs_host_to_card_done);\n\nint lbs_set_mac_address(struct net_device *dev, void *addr)\n{\n\tint ret = 0;\n\tstruct lbs_private *priv = dev->ml_priv;\n\tstruct sockaddr *phwaddr = addr;\n\n\t \n\tif (lbs_iface_active(priv))\n\t\treturn -EBUSY;\n\n\t \n\tdev = priv->dev;\n\n\tmemcpy(priv->current_addr, phwaddr->sa_data, ETH_ALEN);\n\teth_hw_addr_set(dev, phwaddr->sa_data);\n\tif (priv->mesh_dev)\n\t\teth_hw_addr_set(priv->mesh_dev, phwaddr->sa_data);\n\n\treturn ret;\n}\n\n\nstatic inline int mac_in_list(unsigned char *list, int list_len,\n\t\t\t      unsigned char *mac)\n{\n\twhile (list_len) {\n\t\tif (!memcmp(list, mac, ETH_ALEN))\n\t\t\treturn 1;\n\t\tlist += ETH_ALEN;\n\t\tlist_len--;\n\t}\n\treturn 0;\n}\n\n\nstatic int lbs_add_mcast_addrs(struct cmd_ds_mac_multicast_adr *cmd,\n\t\t\t       struct net_device *dev, int nr_addrs)\n{\n\tint i = nr_addrs;\n\tstruct netdev_hw_addr *ha;\n\tint cnt;\n\n\tif ((dev->flags & (IFF_UP|IFF_MULTICAST)) != (IFF_UP|IFF_MULTICAST))\n\t\treturn nr_addrs;\n\n\tnetif_addr_lock_bh(dev);\n\tcnt = netdev_mc_count(dev);\n\tnetdev_for_each_mc_addr(ha, dev) {\n\t\tif (mac_in_list(cmd->maclist, nr_addrs, ha->addr)) {\n\t\t\tlbs_deb_net(\"mcast address %s:%pM skipped\\n\", dev->name,\n\t\t\t\t    ha->addr);\n\t\t\tcnt--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (i == MRVDRV_MAX_MULTICAST_LIST_SIZE)\n\t\t\tbreak;\n\t\tmemcpy(&cmd->maclist[6*i], ha->addr, ETH_ALEN);\n\t\tlbs_deb_net(\"mcast address %s:%pM added to filter\\n\", dev->name,\n\t\t\t    ha->addr);\n\t\ti++;\n\t\tcnt--;\n\t}\n\tnetif_addr_unlock_bh(dev);\n\tif (cnt)\n\t\treturn -EOVERFLOW;\n\n\treturn i;\n}\n\nvoid lbs_update_mcast(struct lbs_private *priv)\n{\n\tstruct cmd_ds_mac_multicast_adr mcast_cmd;\n\tint dev_flags = 0;\n\tint nr_addrs;\n\tint old_mac_control = priv->mac_control;\n\n\tif (netif_running(priv->dev))\n\t\tdev_flags |= priv->dev->flags;\n\tif (priv->mesh_dev && netif_running(priv->mesh_dev))\n\t\tdev_flags |= priv->mesh_dev->flags;\n\n\tif (dev_flags & IFF_PROMISC) {\n\t\tpriv->mac_control |= CMD_ACT_MAC_PROMISCUOUS_ENABLE;\n\t\tpriv->mac_control &= ~(CMD_ACT_MAC_ALL_MULTICAST_ENABLE |\n\t\t\t\t       CMD_ACT_MAC_MULTICAST_ENABLE);\n\t\tgoto out_set_mac_control;\n\t} else if (dev_flags & IFF_ALLMULTI) {\n\tdo_allmulti:\n\t\tpriv->mac_control |= CMD_ACT_MAC_ALL_MULTICAST_ENABLE;\n\t\tpriv->mac_control &= ~(CMD_ACT_MAC_PROMISCUOUS_ENABLE |\n\t\t\t\t       CMD_ACT_MAC_MULTICAST_ENABLE);\n\t\tgoto out_set_mac_control;\n\t}\n\n\t \n\tnr_addrs = lbs_add_mcast_addrs(&mcast_cmd, priv->dev, 0);\n\tif (nr_addrs >= 0 && priv->mesh_dev)\n\t\tnr_addrs = lbs_add_mcast_addrs(&mcast_cmd, priv->mesh_dev, nr_addrs);\n\tif (nr_addrs < 0)\n\t\tgoto do_allmulti;\n\n\tif (nr_addrs) {\n\t\tint size = offsetof(struct cmd_ds_mac_multicast_adr,\n\t\t\t\t    maclist[6*nr_addrs]);\n\n\t\tmcast_cmd.action = cpu_to_le16(CMD_ACT_SET);\n\t\tmcast_cmd.hdr.size = cpu_to_le16(size);\n\t\tmcast_cmd.nr_of_adrs = cpu_to_le16(nr_addrs);\n\n\t\tlbs_cmd_async(priv, CMD_MAC_MULTICAST_ADR, &mcast_cmd.hdr, size);\n\n\t\tpriv->mac_control |= CMD_ACT_MAC_MULTICAST_ENABLE;\n\t} else\n\t\tpriv->mac_control &= ~CMD_ACT_MAC_MULTICAST_ENABLE;\n\n\tpriv->mac_control &= ~(CMD_ACT_MAC_PROMISCUOUS_ENABLE |\n\t\t\t       CMD_ACT_MAC_ALL_MULTICAST_ENABLE);\n out_set_mac_control:\n\tif (priv->mac_control != old_mac_control)\n\t\tlbs_set_mac_control(priv);\n}\n\nstatic void lbs_set_mcast_worker(struct work_struct *work)\n{\n\tstruct lbs_private *priv = container_of(work, struct lbs_private, mcast_work);\n\tlbs_update_mcast(priv);\n}\n\nvoid lbs_set_multicast_list(struct net_device *dev)\n{\n\tstruct lbs_private *priv = dev->ml_priv;\n\n\tschedule_work(&priv->mcast_work);\n}\n\n \nstatic int lbs_thread(void *data)\n{\n\tstruct net_device *dev = data;\n\tstruct lbs_private *priv = dev->ml_priv;\n\twait_queue_entry_t wait;\n\n\tinit_waitqueue_entry(&wait, current);\n\n\tfor (;;) {\n\t\tint shouldsleep;\n\t\tu8 resp_idx;\n\n\t\tlbs_deb_thread(\"1: currenttxskb %p, dnld_sent %d\\n\",\n\t\t\t\tpriv->currenttxskb, priv->dnld_sent);\n\n\t\tadd_wait_queue(&priv->waitq, &wait);\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tspin_lock_irq(&priv->driver_lock);\n\n\t\tif (kthread_should_stop())\n\t\t\tshouldsleep = 0;\t \n\t\telse if (priv->surpriseremoved)\n\t\t\tshouldsleep = 1;\t \n\t\telse if (priv->psstate == PS_STATE_SLEEP)\n\t\t\tshouldsleep = 1;\t \n\t\telse if (priv->cmd_timed_out)\n\t\t\tshouldsleep = 0;\t \n\t\telse if (!priv->fw_ready)\n\t\t\tshouldsleep = 1;\t \n\t\telse if (priv->dnld_sent)\n\t\t\tshouldsleep = 1;\t \n\t\telse if (priv->tx_pending_len > 0)\n\t\t\tshouldsleep = 0;\t \n\t\telse if (priv->resp_len[priv->resp_idx])\n\t\t\tshouldsleep = 0;\t \n\t\telse if (priv->cur_cmd)\n\t\t\tshouldsleep = 1;\t \n\t\telse if (!list_empty(&priv->cmdpendingq) &&\n\t\t\t\t\t!(priv->wakeup_dev_required))\n\t\t\tshouldsleep = 0;\t \n\t\telse if (kfifo_len(&priv->event_fifo))\n\t\t\tshouldsleep = 0;\t \n\t\telse\n\t\t\tshouldsleep = 1;\t \n\n\t\tif (shouldsleep) {\n\t\t\tlbs_deb_thread(\"sleeping, connect_status %d, \"\n\t\t\t\t\"psmode %d, psstate %d\\n\",\n\t\t\t\tpriv->connect_status,\n\t\t\t\tpriv->psmode, priv->psstate);\n\t\t\tspin_unlock_irq(&priv->driver_lock);\n\t\t\tschedule();\n\t\t} else\n\t\t\tspin_unlock_irq(&priv->driver_lock);\n\n\t\tlbs_deb_thread(\"2: currenttxskb %p, dnld_send %d\\n\",\n\t\t\t       priv->currenttxskb, priv->dnld_sent);\n\n\t\tset_current_state(TASK_RUNNING);\n\t\tremove_wait_queue(&priv->waitq, &wait);\n\n\t\tlbs_deb_thread(\"3: currenttxskb %p, dnld_sent %d\\n\",\n\t\t\t       priv->currenttxskb, priv->dnld_sent);\n\n\t\tif (kthread_should_stop()) {\n\t\t\tlbs_deb_thread(\"break from main thread\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (priv->surpriseremoved) {\n\t\t\tlbs_deb_thread(\"adapter removed; waiting to die...\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tlbs_deb_thread(\"4: currenttxskb %p, dnld_sent %d\\n\",\n\t\t       priv->currenttxskb, priv->dnld_sent);\n\n\t\t \n\t\tspin_lock_irq(&priv->driver_lock);\n\t\tresp_idx = priv->resp_idx;\n\t\tif (priv->resp_len[resp_idx]) {\n\t\t\tspin_unlock_irq(&priv->driver_lock);\n\t\t\tlbs_process_command_response(priv,\n\t\t\t\tpriv->resp_buf[resp_idx],\n\t\t\t\tpriv->resp_len[resp_idx]);\n\t\t\tspin_lock_irq(&priv->driver_lock);\n\t\t\tpriv->resp_len[resp_idx] = 0;\n\t\t}\n\t\tspin_unlock_irq(&priv->driver_lock);\n\n\t\t \n\t\tspin_lock_irq(&priv->driver_lock);\n\t\twhile (kfifo_len(&priv->event_fifo)) {\n\t\t\tu32 event;\n\n\t\t\tif (kfifo_out(&priv->event_fifo,\n\t\t\t\t(unsigned char *) &event, sizeof(event)) !=\n\t\t\t\tsizeof(event))\n\t\t\t\t\tbreak;\n\t\t\tspin_unlock_irq(&priv->driver_lock);\n\t\t\tlbs_process_event(priv, event);\n\t\t\tspin_lock_irq(&priv->driver_lock);\n\t\t}\n\t\tspin_unlock_irq(&priv->driver_lock);\n\n\t\tif (priv->wakeup_dev_required) {\n\t\t\tlbs_deb_thread(\"Waking up device...\\n\");\n\t\t\t \n\t\t\tif (priv->exit_deep_sleep(priv))\n\t\t\t\tlbs_deb_thread(\"Wakeup device failed\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (priv->cmd_timed_out && priv->cur_cmd) {\n\t\t\tstruct cmd_ctrl_node *cmdnode = priv->cur_cmd;\n\n\t\t\tnetdev_info(dev, \"Timeout submitting command 0x%04x\\n\",\n\t\t\t\t    le16_to_cpu(cmdnode->cmdbuf->command));\n\t\t\tlbs_complete_command(priv, cmdnode, -ETIMEDOUT);\n\n\t\t\t \n\t\t\tif (!dev->dismantle && priv->reset_card)\n\t\t\t\tpriv->reset_card(priv);\n\t\t}\n\t\tpriv->cmd_timed_out = 0;\n\n\t\tif (!priv->fw_ready)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (priv->psstate == PS_STATE_PRE_SLEEP &&\n\t\t    !priv->dnld_sent && !priv->cur_cmd) {\n\t\t\tif (priv->connect_status == LBS_CONNECTED) {\n\t\t\t\tlbs_deb_thread(\"pre-sleep, currenttxskb %p, \"\n\t\t\t\t\t\"dnld_sent %d, cur_cmd %p\\n\",\n\t\t\t\t\tpriv->currenttxskb, priv->dnld_sent,\n\t\t\t\t\tpriv->cur_cmd);\n\n\t\t\t\tlbs_ps_confirm_sleep(priv);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tpriv->psstate = PS_STATE_AWAKE;\n\t\t\t\tnetdev_alert(dev,\n\t\t\t\t\t     \"ignore PS_SleepConfirm in non-connected state\\n\");\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif ((priv->psstate == PS_STATE_SLEEP) ||\n\t\t    (priv->psstate == PS_STATE_PRE_SLEEP))\n\t\t\tcontinue;\n\n\t\tif (priv->is_deep_sleep)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (!priv->dnld_sent && !priv->cur_cmd)\n\t\t\tlbs_execute_next_command(priv);\n\n\t\tspin_lock_irq(&priv->driver_lock);\n\t\tif (!priv->dnld_sent && priv->tx_pending_len > 0) {\n\t\t\tint ret = priv->hw_host_to_card(priv, MVMS_DAT,\n\t\t\t\t\t\t\tpriv->tx_pending_buf,\n\t\t\t\t\t\t\tpriv->tx_pending_len);\n\t\t\tif (ret) {\n\t\t\t\tlbs_deb_tx(\"host_to_card failed %d\\n\", ret);\n\t\t\t\tpriv->dnld_sent = DNLD_RES_RECEIVED;\n\t\t\t} else {\n\t\t\t\tmod_timer(&priv->tx_lockup_timer,\n\t\t\t\t\t  jiffies + (HZ * 5));\n\t\t\t}\n\t\t\tpriv->tx_pending_len = 0;\n\t\t\tif (!priv->currenttxskb) {\n\t\t\t\t \n\t\t\t\tif (priv->connect_status == LBS_CONNECTED)\n\t\t\t\t\tnetif_wake_queue(priv->dev);\n\t\t\t\tif (priv->mesh_dev &&\n\t\t\t\t    netif_running(priv->mesh_dev))\n\t\t\t\t\tnetif_wake_queue(priv->mesh_dev);\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irq(&priv->driver_lock);\n\t}\n\n\tdel_timer(&priv->command_timer);\n\tdel_timer(&priv->tx_lockup_timer);\n\tdel_timer(&priv->auto_deepsleep_timer);\n\n\treturn 0;\n}\n\n \nstatic int lbs_setup_firmware(struct lbs_private *priv)\n{\n\tint ret = -1;\n\ts16 curlevel = 0, minlevel = 0, maxlevel = 0;\n\n\t \n\teth_broadcast_addr(priv->current_addr);\n\tret = lbs_update_hw_spec(priv);\n\tif (ret)\n\t\tgoto done;\n\n\t \n\tret = lbs_get_tx_power(priv, &curlevel, &minlevel, &maxlevel);\n\tif (ret == 0) {\n\t\tpriv->txpower_cur = curlevel;\n\t\tpriv->txpower_min = minlevel;\n\t\tpriv->txpower_max = maxlevel;\n\t}\n\n\t \n\tret = lbs_set_snmp_mib(priv, SNMP_MIB_OID_11D_ENABLE, 1);\n\tif (ret)\n\t\tgoto done;\n\n\tret = lbs_set_mac_control_sync(priv);\ndone:\n\treturn ret;\n}\n\nint lbs_suspend(struct lbs_private *priv)\n{\n\tint ret;\n\n\tif (priv->is_deep_sleep) {\n\t\tret = lbs_set_deep_sleep(priv, 0);\n\t\tif (ret) {\n\t\t\tnetdev_err(priv->dev,\n\t\t\t\t   \"deep sleep cancellation failed: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tpriv->deep_sleep_required = 1;\n\t}\n\n\tret = lbs_set_host_sleep(priv, 1);\n\n\tnetif_device_detach(priv->dev);\n\tif (priv->mesh_dev)\n\t\tnetif_device_detach(priv->mesh_dev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(lbs_suspend);\n\nint lbs_resume(struct lbs_private *priv)\n{\n\tint ret;\n\n\tret = lbs_set_host_sleep(priv, 0);\n\n\tnetif_device_attach(priv->dev);\n\tif (priv->mesh_dev)\n\t\tnetif_device_attach(priv->mesh_dev);\n\n\tif (priv->deep_sleep_required) {\n\t\tpriv->deep_sleep_required = 0;\n\t\tret = lbs_set_deep_sleep(priv, 1);\n\t\tif (ret)\n\t\t\tnetdev_err(priv->dev,\n\t\t\t\t   \"deep sleep activation failed: %d\\n\", ret);\n\t}\n\n\tif (priv->setup_fw_on_resume)\n\t\tret = lbs_setup_firmware(priv);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(lbs_resume);\n\n \nstatic void lbs_cmd_timeout_handler(struct timer_list *t)\n{\n\tstruct lbs_private *priv = from_timer(priv, t, command_timer);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->driver_lock, flags);\n\n\tif (!priv->cur_cmd)\n\t\tgoto out;\n\n\tnetdev_info(priv->dev, \"command 0x%04x timed out\\n\",\n\t\t    le16_to_cpu(priv->cur_cmd->cmdbuf->command));\n\n\tpriv->cmd_timed_out = 1;\n\n\t \n\tif (priv->dnld_sent == DNLD_CMD_SENT)\n\t\tpriv->dnld_sent = DNLD_RES_RECEIVED;\n\n\twake_up(&priv->waitq);\nout:\n\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n}\n\n \nstatic void lbs_tx_lockup_handler(struct timer_list *t)\n{\n\tstruct lbs_private *priv = from_timer(priv, t, tx_lockup_timer);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->driver_lock, flags);\n\n\tnetdev_info(priv->dev, \"TX lockup detected\\n\");\n\tif (priv->reset_card)\n\t\tpriv->reset_card(priv);\n\n\tpriv->dnld_sent = DNLD_RES_RECEIVED;\n\twake_up_interruptible(&priv->waitq);\n\n\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n}\n\n \nstatic void auto_deepsleep_timer_fn(struct timer_list *t)\n{\n\tstruct lbs_private *priv = from_timer(priv, t, auto_deepsleep_timer);\n\n\tif (priv->is_activity_detected) {\n\t\tpriv->is_activity_detected = 0;\n\t} else {\n\t\tif (priv->is_auto_deep_sleep_enabled &&\n\t\t    (!priv->wakeup_dev_required) &&\n\t\t    (priv->connect_status != LBS_CONNECTED)) {\n\t\t\tstruct cmd_header cmd;\n\n\t\t\tlbs_deb_main(\"Entering auto deep sleep mode...\\n\");\n\t\t\tmemset(&cmd, 0, sizeof(cmd));\n\t\t\tcmd.size = cpu_to_le16(sizeof(cmd));\n\t\t\tlbs_cmd_async(priv, CMD_802_11_DEEP_SLEEP, &cmd,\n\t\t\t\t\tsizeof(cmd));\n\t\t}\n\t}\n\tmod_timer(&priv->auto_deepsleep_timer , jiffies +\n\t\t\t\t(priv->auto_deep_sleep_timeout * HZ)/1000);\n}\n\nint lbs_enter_auto_deep_sleep(struct lbs_private *priv)\n{\n\tpriv->is_auto_deep_sleep_enabled = 1;\n\tif (priv->is_deep_sleep)\n\t\tpriv->wakeup_dev_required = 1;\n\tmod_timer(&priv->auto_deepsleep_timer ,\n\t\t\tjiffies + (priv->auto_deep_sleep_timeout * HZ)/1000);\n\n\treturn 0;\n}\n\nint lbs_exit_auto_deep_sleep(struct lbs_private *priv)\n{\n\tpriv->is_auto_deep_sleep_enabled = 0;\n\tpriv->auto_deep_sleep_timeout = 0;\n\tdel_timer(&priv->auto_deepsleep_timer);\n\n\treturn 0;\n}\n\nstatic int lbs_init_adapter(struct lbs_private *priv)\n{\n\tint ret;\n\n\teth_broadcast_addr(priv->current_addr);\n\n\tpriv->connect_status = LBS_DISCONNECTED;\n\tpriv->channel = DEFAULT_AD_HOC_CHANNEL;\n\tpriv->mac_control = CMD_ACT_MAC_RX_ON | CMD_ACT_MAC_TX_ON;\n\tpriv->radio_on = 1;\n\tpriv->psmode = LBS802_11POWERMODECAM;\n\tpriv->psstate = PS_STATE_FULL_POWER;\n\tpriv->is_deep_sleep = 0;\n\tpriv->is_auto_deep_sleep_enabled = 0;\n\tpriv->deep_sleep_required = 0;\n\tpriv->wakeup_dev_required = 0;\n\tinit_waitqueue_head(&priv->ds_awake_q);\n\tinit_waitqueue_head(&priv->scan_q);\n\tpriv->authtype_auto = 1;\n\tpriv->is_host_sleep_configured = 0;\n\tpriv->is_host_sleep_activated = 0;\n\tinit_waitqueue_head(&priv->host_sleep_q);\n\tinit_waitqueue_head(&priv->fw_waitq);\n\tmutex_init(&priv->lock);\n\n\ttimer_setup(&priv->command_timer, lbs_cmd_timeout_handler, 0);\n\ttimer_setup(&priv->tx_lockup_timer, lbs_tx_lockup_handler, 0);\n\ttimer_setup(&priv->auto_deepsleep_timer, auto_deepsleep_timer_fn, 0);\n\n\tINIT_LIST_HEAD(&priv->cmdfreeq);\n\tINIT_LIST_HEAD(&priv->cmdpendingq);\n\n\tspin_lock_init(&priv->driver_lock);\n\n\t \n\tif (lbs_allocate_cmd_buffer(priv)) {\n\t\tpr_err(\"Out of memory allocating command buffers\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tpriv->resp_idx = 0;\n\tpriv->resp_len[0] = priv->resp_len[1] = 0;\n\n\t \n\tret = kfifo_alloc(&priv->event_fifo, sizeof(u32) * 16, GFP_KERNEL);\n\tif (ret) {\n\t\tpr_err(\"Out of memory allocating event FIFO buffer\\n\");\n\t\tlbs_free_cmd_buffer(priv);\n\t\tgoto out;\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic void lbs_free_adapter(struct lbs_private *priv)\n{\n\tlbs_free_cmd_buffer(priv);\n\tkfifo_free(&priv->event_fifo);\n\tdel_timer(&priv->command_timer);\n\tdel_timer(&priv->tx_lockup_timer);\n\tdel_timer(&priv->auto_deepsleep_timer);\n}\n\nstatic const struct net_device_ops lbs_netdev_ops = {\n\t.ndo_open \t\t= lbs_dev_open,\n\t.ndo_stop\t\t= lbs_eth_stop,\n\t.ndo_start_xmit\t\t= lbs_hard_start_xmit,\n\t.ndo_set_mac_address\t= lbs_set_mac_address,\n\t.ndo_set_rx_mode\t= lbs_set_multicast_list,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\n \nstruct lbs_private *lbs_add_card(void *card, struct device *dmdev)\n{\n\tstruct net_device *dev;\n\tstruct wireless_dev *wdev;\n\tstruct lbs_private *priv = NULL;\n\tint err;\n\n\t \n\twdev = lbs_cfg_alloc(dmdev);\n\tif (IS_ERR(wdev)) {\n\t\terr = PTR_ERR(wdev);\n\t\tpr_err(\"cfg80211 init failed\\n\");\n\t\tgoto err_cfg;\n\t}\n\n\twdev->iftype = NL80211_IFTYPE_STATION;\n\tpriv = wdev_priv(wdev);\n\tpriv->wdev = wdev;\n\n\terr = lbs_init_adapter(priv);\n\tif (err) {\n\t\tpr_err(\"failed to initialize adapter structure\\n\");\n\t\tgoto err_wdev;\n\t}\n\n\tdev = alloc_netdev(0, \"wlan%d\", NET_NAME_UNKNOWN, ether_setup);\n\tif (!dev) {\n\t\terr = -ENOMEM;\n\t\tdev_err(dmdev, \"no memory for network device instance\\n\");\n\t\tgoto err_adapter;\n\t}\n\n\tdev->ieee80211_ptr = wdev;\n\tdev->ml_priv = priv;\n\tSET_NETDEV_DEV(dev, dmdev);\n\twdev->netdev = dev;\n\tpriv->dev = dev;\n\n\tdev->netdev_ops = &lbs_netdev_ops;\n\tdev->watchdog_timeo = 5 * HZ;\n\tdev->ethtool_ops = &lbs_ethtool_ops;\n\tdev->flags |= IFF_BROADCAST | IFF_MULTICAST;\n\n\tpriv->card = card;\n\n\tstrcpy(dev->name, \"wlan%d\");\n\n\tlbs_deb_thread(\"Starting main thread...\\n\");\n\tinit_waitqueue_head(&priv->waitq);\n\tpriv->main_thread = kthread_run(lbs_thread, dev, \"lbs_main\");\n\tif (IS_ERR(priv->main_thread)) {\n\t\terr = PTR_ERR(priv->main_thread);\n\t\tlbs_deb_thread(\"Error creating main thread.\\n\");\n\t\tgoto err_ndev;\n\t}\n\n\tpriv->work_thread = create_singlethread_workqueue(\"lbs_worker\");\n\tINIT_WORK(&priv->mcast_work, lbs_set_mcast_worker);\n\n\tpriv->wol_criteria = EHS_REMOVE_WAKEUP;\n\tpriv->wol_gpio = 0xff;\n\tpriv->wol_gap = 20;\n\tpriv->ehs_remove_supported = true;\n\n\treturn priv;\n\n err_ndev:\n\tfree_netdev(dev);\n\n err_adapter:\n\tlbs_free_adapter(priv);\n\n err_wdev:\n\tlbs_cfg_free(priv);\n\n err_cfg:\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL_GPL(lbs_add_card);\n\n\nvoid lbs_remove_card(struct lbs_private *priv)\n{\n\tstruct net_device *dev = priv->dev;\n\n\tlbs_remove_mesh(priv);\n\n\tif (priv->wiphy_registered)\n\t\tlbs_scan_deinit(priv);\n\n\tlbs_wait_for_firmware_load(priv);\n\n\t \n\tlbs_deb_main(\"destroying worker thread\\n\");\n\tdestroy_workqueue(priv->work_thread);\n\tlbs_deb_main(\"done destroying worker thread\\n\");\n\n\tif (priv->psmode == LBS802_11POWERMODEMAX_PSP) {\n\t\tpriv->psmode = LBS802_11POWERMODECAM;\n\t\t \n\t\tif (priv->psstate != PS_STATE_FULL_POWER)\n\t\t\tlbs_set_ps_mode(priv, PS_MODE_ACTION_EXIT_PS, true);\n\t}\n\n\tif (priv->is_deep_sleep) {\n\t\tpriv->is_deep_sleep = 0;\n\t\twake_up_interruptible(&priv->ds_awake_q);\n\t}\n\n\tpriv->is_host_sleep_configured = 0;\n\tpriv->is_host_sleep_activated = 0;\n\twake_up_interruptible(&priv->host_sleep_q);\n\n\t \n\tpriv->surpriseremoved = 1;\n\tkthread_stop(priv->main_thread);\n\n\tlbs_free_adapter(priv);\n\tlbs_cfg_free(priv);\n\tfree_netdev(dev);\n}\nEXPORT_SYMBOL_GPL(lbs_remove_card);\n\n\nint lbs_rtap_supported(struct lbs_private *priv)\n{\n\tif (MRVL_FW_MAJOR_REV(priv->fwrelease) == MRVL_FW_V5)\n\t\treturn 1;\n\n\t \n\treturn ((MRVL_FW_MAJOR_REV(priv->fwrelease) >= MRVL_FW_V10) &&\n\t\t(priv->fwcapinfo & MESH_CAPINFO_ENABLE_MASK));\n}\n\n\nint lbs_start_card(struct lbs_private *priv)\n{\n\tstruct net_device *dev = priv->dev;\n\tint ret;\n\n\t \n\tret = lbs_setup_firmware(priv);\n\tif (ret)\n\t\tgoto done;\n\n\tif (!lbs_disablemesh)\n\t\tlbs_init_mesh(priv);\n\telse\n\t\tpr_info(\"%s: mesh disabled\\n\", dev->name);\n\n\tret = lbs_cfg_register(priv);\n\tif (ret) {\n\t\tpr_err(\"cannot register device\\n\");\n\t\tgoto done;\n\t}\n\n\tif (lbs_mesh_activated(priv))\n\t\tlbs_start_mesh(priv);\n\n\tlbs_debugfs_init_one(priv, dev);\n\n\tnetdev_info(dev, \"Marvell WLAN 802.11 adapter\\n\");\n\n\tret = 0;\n\ndone:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(lbs_start_card);\n\n\nvoid lbs_stop_card(struct lbs_private *priv)\n{\n\tstruct net_device *dev;\n\n\tif (!priv)\n\t\treturn;\n\tdev = priv->dev;\n\n\t \n\tif (dev->reg_state != NETREG_REGISTERED)\n\t\treturn;\n\n\tnetif_stop_queue(dev);\n\tnetif_carrier_off(dev);\n\n\tlbs_debugfs_remove_one(priv);\n\tlbs_deinit_mesh(priv);\n\tunregister_netdev(dev);\n}\nEXPORT_SYMBOL_GPL(lbs_stop_card);\n\n\nvoid lbs_queue_event(struct lbs_private *priv, u32 event)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->driver_lock, flags);\n\n\tif (priv->psstate == PS_STATE_SLEEP)\n\t\tpriv->psstate = PS_STATE_AWAKE;\n\n\tkfifo_in(&priv->event_fifo, (unsigned char *) &event, sizeof(u32));\n\n\twake_up(&priv->waitq);\n\n\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n}\nEXPORT_SYMBOL_GPL(lbs_queue_event);\n\nvoid lbs_notify_command_response(struct lbs_private *priv, u8 resp_idx)\n{\n\tif (priv->psstate == PS_STATE_SLEEP)\n\t\tpriv->psstate = PS_STATE_AWAKE;\n\n\t \n\tBUG_ON(resp_idx > 1);\n\tpriv->resp_idx = resp_idx;\n\n\twake_up(&priv->waitq);\n}\nEXPORT_SYMBOL_GPL(lbs_notify_command_response);\n\nstatic int __init lbs_init_module(void)\n{\n\tmemset(&confirm_sleep, 0, sizeof(confirm_sleep));\n\tconfirm_sleep.hdr.command = cpu_to_le16(CMD_802_11_PS_MODE);\n\tconfirm_sleep.hdr.size = cpu_to_le16(sizeof(confirm_sleep));\n\tconfirm_sleep.action = cpu_to_le16(PS_MODE_ACTION_SLEEP_CONFIRMED);\n\tlbs_debugfs_init();\n\n\treturn 0;\n}\n\nstatic void __exit lbs_exit_module(void)\n{\n\tlbs_debugfs_remove();\n}\n\nmodule_init(lbs_init_module);\nmodule_exit(lbs_exit_module);\n\nMODULE_DESCRIPTION(\"Libertas WLAN Driver Library\");\nMODULE_AUTHOR(\"Marvell International Ltd.\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}