{
  "module_name": "if_sdio.c",
  "hash_id": "7014d12f87c65f7fb2ca2fb6524a4fe178f1ba64ef34a57f771da3ec507c96ed",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/marvell/libertas/if_sdio.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/firmware.h>\n#include <linux/netdevice.h>\n#include <linux/delay.h>\n#include <linux/mmc/card.h>\n#include <linux/mmc/sdio_func.h>\n#include <linux/mmc/sdio_ids.h>\n#include <linux/mmc/sdio.h>\n#include <linux/mmc/host.h>\n#include <linux/pm_runtime.h>\n\n#include \"host.h\"\n#include \"decl.h\"\n#include \"defs.h\"\n#include \"dev.h\"\n#include \"cmd.h\"\n#include \"if_sdio.h\"\n\nstatic void if_sdio_interrupt(struct sdio_func *func);\n\n \nstatic u8 user_rmmod;\n\nstatic const struct sdio_device_id if_sdio_ids[] = {\n\t{ SDIO_DEVICE(SDIO_VENDOR_ID_MARVELL,\n\t\t\tSDIO_DEVICE_ID_MARVELL_LIBERTAS) },\n\t{ SDIO_DEVICE(SDIO_VENDOR_ID_MARVELL,\n\t\t\tSDIO_DEVICE_ID_MARVELL_8688_WLAN) },\n\t{  \t\t\t\t},\n};\n\nMODULE_DEVICE_TABLE(sdio, if_sdio_ids);\n\n#define MODEL_8385\t0x04\n#define MODEL_8686\t0x0b\n#define MODEL_8688\t0x10\n\nstatic const struct lbs_fw_table fw_table[] = {\n\t{ MODEL_8385, \"libertas/sd8385_helper.bin\", \"libertas/sd8385.bin\" },\n\t{ MODEL_8385, \"sd8385_helper.bin\", \"sd8385.bin\" },\n\t{ MODEL_8686, \"libertas/sd8686_v9_helper.bin\", \"libertas/sd8686_v9.bin\" },\n\t{ MODEL_8686, \"libertas/sd8686_v8_helper.bin\", \"libertas/sd8686_v8.bin\" },\n\t{ MODEL_8686, \"sd8686_helper.bin\", \"sd8686.bin\" },\n\t{ MODEL_8688, \"libertas/sd8688_helper.bin\", \"libertas/sd8688.bin\" },\n\t{ MODEL_8688, \"sd8688_helper.bin\", \"sd8688.bin\" },\n\t{ 0, NULL, NULL }\n};\nMODULE_FIRMWARE(\"libertas/sd8385_helper.bin\");\nMODULE_FIRMWARE(\"libertas/sd8385.bin\");\nMODULE_FIRMWARE(\"sd8385_helper.bin\");\nMODULE_FIRMWARE(\"sd8385.bin\");\nMODULE_FIRMWARE(\"libertas/sd8686_v9_helper.bin\");\nMODULE_FIRMWARE(\"libertas/sd8686_v9.bin\");\nMODULE_FIRMWARE(\"libertas/sd8686_v8_helper.bin\");\nMODULE_FIRMWARE(\"libertas/sd8686_v8.bin\");\nMODULE_FIRMWARE(\"sd8686_helper.bin\");\nMODULE_FIRMWARE(\"sd8686.bin\");\nMODULE_FIRMWARE(\"libertas/sd8688_helper.bin\");\nMODULE_FIRMWARE(\"libertas/sd8688.bin\");\nMODULE_FIRMWARE(\"sd8688_helper.bin\");\nMODULE_FIRMWARE(\"sd8688.bin\");\n\nstruct if_sdio_packet {\n\tstruct list_head\tlist;\n\tu16\t\t\tnb;\n\tu8\t\t\tbuffer[] __aligned(4);\n};\n\nstruct if_sdio_card {\n\tstruct sdio_func\t*func;\n\tstruct lbs_private\t*priv;\n\n\tint\t\t\tmodel;\n\tunsigned long\t\tioport;\n\tunsigned int\t\tscratch_reg;\n\tbool\t\t\tstarted;\n\twait_queue_head_t\tpwron_waitq;\n\n\tu8\t\t\tbuffer[65536] __attribute__((aligned(4)));\n\n\tspinlock_t\t\tlock;\n\tstruct list_head\tpackets;\n\n\tstruct workqueue_struct\t*workqueue;\n\tstruct work_struct\tpacket_worker;\n\tstruct work_struct\treset_worker;\n\n\tu8\t\t\trx_unit;\n};\n\nstatic void if_sdio_finish_power_on(struct if_sdio_card *card);\nstatic int if_sdio_power_off(struct if_sdio_card *card);\n\n \n \n \n\n \nstatic u16 if_sdio_read_scratch(struct if_sdio_card *card, int *err)\n{\n\tint ret;\n\tu16 scratch;\n\n\tscratch = sdio_readb(card->func, card->scratch_reg, &ret);\n\tif (!ret)\n\t\tscratch |= sdio_readb(card->func, card->scratch_reg + 1,\n\t\t\t\t\t&ret) << 8;\n\n\tif (err)\n\t\t*err = ret;\n\n\tif (ret)\n\t\treturn 0xffff;\n\n\treturn scratch;\n}\n\nstatic u8 if_sdio_read_rx_unit(struct if_sdio_card *card)\n{\n\tint ret;\n\tu8 rx_unit;\n\n\trx_unit = sdio_readb(card->func, IF_SDIO_RX_UNIT, &ret);\n\n\tif (ret)\n\t\trx_unit = 0;\n\n\treturn rx_unit;\n}\n\nstatic u16 if_sdio_read_rx_len(struct if_sdio_card *card, int *err)\n{\n\tint ret;\n\tu16 rx_len;\n\n\tswitch (card->model) {\n\tcase MODEL_8385:\n\tcase MODEL_8686:\n\t\trx_len = if_sdio_read_scratch(card, &ret);\n\t\tbreak;\n\tcase MODEL_8688:\n\tdefault:  \n\t\trx_len = sdio_readb(card->func, IF_SDIO_RX_LEN, &ret);\n\t\tif (!ret)\n\t\t\trx_len <<= card->rx_unit;\n\t\telse\n\t\t\trx_len = 0xffff;\t \n\n\t\tbreak;\n\t}\n\n\tif (err)\n\t\t*err = ret;\n\n\treturn rx_len;\n}\n\nstatic int if_sdio_handle_cmd(struct if_sdio_card *card,\n\t\tu8 *buffer, unsigned size)\n{\n\tstruct lbs_private *priv = card->priv;\n\tint ret;\n\tunsigned long flags;\n\tu8 i;\n\n\tif (size > LBS_CMD_BUFFER_SIZE) {\n\t\tlbs_deb_sdio(\"response packet too large (%d bytes)\\n\",\n\t\t\t(int)size);\n\t\tret = -E2BIG;\n\t\tgoto out;\n\t}\n\n\tspin_lock_irqsave(&priv->driver_lock, flags);\n\n\ti = (priv->resp_idx == 0) ? 1 : 0;\n\tBUG_ON(priv->resp_len[i]);\n\tpriv->resp_len[i] = size;\n\tmemcpy(priv->resp_buf[i], buffer, size);\n\tlbs_notify_command_response(priv, i);\n\n\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\n\tret = 0;\n\nout:\n\treturn ret;\n}\n\nstatic int if_sdio_handle_data(struct if_sdio_card *card,\n\t\tu8 *buffer, unsigned size)\n{\n\tint ret;\n\tstruct sk_buff *skb;\n\n\tif (size > MRVDRV_ETH_RX_PACKET_BUFFER_SIZE) {\n\t\tlbs_deb_sdio(\"response packet too large (%d bytes)\\n\",\n\t\t\t(int)size);\n\t\tret = -E2BIG;\n\t\tgoto out;\n\t}\n\n\tskb = dev_alloc_skb(MRVDRV_ETH_RX_PACKET_BUFFER_SIZE + NET_IP_ALIGN);\n\tif (!skb) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tskb_reserve(skb, NET_IP_ALIGN);\n\n\tskb_put_data(skb, buffer, size);\n\n\tlbs_process_rxed_packet(card->priv, skb);\n\n\tret = 0;\n\nout:\n\treturn ret;\n}\n\nstatic int if_sdio_handle_event(struct if_sdio_card *card,\n\t\tu8 *buffer, unsigned size)\n{\n\tint ret;\n\tu32 event;\n\n\tif (card->model == MODEL_8385) {\n\t\tevent = sdio_readb(card->func, IF_SDIO_EVENT, &ret);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t \n\t\tevent >>= 3;\n\t} else {\n\t\tif (size < 4) {\n\t\t\tlbs_deb_sdio(\"event packet too small (%d bytes)\\n\",\n\t\t\t\t(int)size);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tevent = buffer[3] << 24;\n\t\tevent |= buffer[2] << 16;\n\t\tevent |= buffer[1] << 8;\n\t\tevent |= buffer[0] << 0;\n\t}\n\n\tlbs_queue_event(card->priv, event & 0xFF);\n\tret = 0;\n\nout:\n\treturn ret;\n}\n\nstatic int if_sdio_wait_status(struct if_sdio_card *card, const u8 condition)\n{\n\tu8 status;\n\tunsigned long timeout;\n\tint ret = 0;\n\n\ttimeout = jiffies + HZ;\n\twhile (1) {\n\t\tstatus = sdio_readb(card->func, IF_SDIO_STATUS, &ret);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif ((status & condition) == condition)\n\t\t\tbreak;\n\t\tif (time_after(jiffies, timeout))\n\t\t\treturn -ETIMEDOUT;\n\t\tmdelay(1);\n\t}\n\treturn ret;\n}\n\nstatic int if_sdio_card_to_host(struct if_sdio_card *card)\n{\n\tint ret;\n\tu16 size, type, chunk;\n\n\tsize = if_sdio_read_rx_len(card, &ret);\n\tif (ret)\n\t\tgoto out;\n\n\tif (size < 4) {\n\t\tlbs_deb_sdio(\"invalid packet size (%d bytes) from firmware\\n\",\n\t\t\t(int)size);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = if_sdio_wait_status(card, IF_SDIO_IO_RDY);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tchunk = sdio_align_size(card->func, size);\n\n\tret = sdio_readsb(card->func, card->buffer, card->ioport, chunk);\n\tif (ret)\n\t\tgoto out;\n\n\tchunk = card->buffer[0] | (card->buffer[1] << 8);\n\ttype = card->buffer[2] | (card->buffer[3] << 8);\n\n\tlbs_deb_sdio(\"packet of type %d and size %d bytes\\n\",\n\t\t(int)type, (int)chunk);\n\n\tif (chunk > size) {\n\t\tlbs_deb_sdio(\"packet fragment (%d > %d)\\n\",\n\t\t\t(int)chunk, (int)size);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (chunk < size) {\n\t\tlbs_deb_sdio(\"packet fragment (%d < %d)\\n\",\n\t\t\t(int)chunk, (int)size);\n\t}\n\n\tswitch (type) {\n\tcase MVMS_CMD:\n\t\tret = if_sdio_handle_cmd(card, card->buffer + 4, chunk - 4);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase MVMS_DAT:\n\t\tret = if_sdio_handle_data(card, card->buffer + 4, chunk - 4);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase MVMS_EVENT:\n\t\tret = if_sdio_handle_event(card, card->buffer + 4, chunk - 4);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tbreak;\n\tdefault:\n\t\tlbs_deb_sdio(\"invalid type (%d) from firmware\\n\",\n\t\t\t\t(int)type);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\nout:\n\tif (ret)\n\t\tpr_err(\"problem fetching packet from firmware\\n\");\n\n\treturn ret;\n}\n\nstatic void if_sdio_host_to_card_worker(struct work_struct *work)\n{\n\tstruct if_sdio_card *card;\n\tstruct if_sdio_packet *packet;\n\tint ret;\n\tunsigned long flags;\n\n\tcard = container_of(work, struct if_sdio_card, packet_worker);\n\n\twhile (1) {\n\t\tspin_lock_irqsave(&card->lock, flags);\n\t\tpacket = list_first_entry_or_null(&card->packets,\n\t\t\t\t\t\t  struct if_sdio_packet, list);\n\t\tif (packet)\n\t\t\tlist_del(&packet->list);\n\t\tspin_unlock_irqrestore(&card->lock, flags);\n\n\t\tif (!packet)\n\t\t\tbreak;\n\n\t\tsdio_claim_host(card->func);\n\n\t\tret = if_sdio_wait_status(card, IF_SDIO_IO_RDY);\n\t\tif (ret == 0) {\n\t\t\tret = sdio_writesb(card->func, card->ioport,\n\t\t\t\t\t   packet->buffer, packet->nb);\n\t\t}\n\n\t\tif (ret)\n\t\t\tpr_err(\"error %d sending packet to firmware\\n\", ret);\n\n\t\tsdio_release_host(card->func);\n\n\t\tkfree(packet);\n\t}\n}\n\n \n \n \n\n#define FW_DL_READY_STATUS (IF_SDIO_IO_RDY | IF_SDIO_DL_RDY)\n\nstatic int if_sdio_prog_helper(struct if_sdio_card *card,\n\t\t\t\tconst struct firmware *fw)\n{\n\tint ret;\n\tunsigned long timeout;\n\tu8 *chunk_buffer;\n\tu32 chunk_size;\n\tconst u8 *firmware;\n\tsize_t size;\n\n\tchunk_buffer = kzalloc(64, GFP_KERNEL);\n\tif (!chunk_buffer) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsdio_claim_host(card->func);\n\n\tret = sdio_set_block_size(card->func, 32);\n\tif (ret)\n\t\tgoto release;\n\n\tfirmware = fw->data;\n\tsize = fw->size;\n\n\twhile (size) {\n\t\tret = if_sdio_wait_status(card, FW_DL_READY_STATUS);\n\t\tif (ret)\n\t\t\tgoto release;\n\n\t\t \n\t\tmdelay(2);\n\n\t\tchunk_size = min_t(size_t, size, 60);\n\n\t\t*((__le32*)chunk_buffer) = cpu_to_le32(chunk_size);\n\t\tmemcpy(chunk_buffer + 4, firmware, chunk_size);\n \n\t\tret = sdio_writesb(card->func, card->ioport,\n\t\t\t\tchunk_buffer, 64);\n\t\tif (ret)\n\t\t\tgoto release;\n\n\t\tfirmware += chunk_size;\n\t\tsize -= chunk_size;\n\t}\n\n\t \n\tmemset(chunk_buffer, 0, 4);\n\tret = sdio_writesb(card->func, card->ioport, chunk_buffer, 64);\n\tif (ret)\n\t\tgoto release;\n\n\tlbs_deb_sdio(\"waiting for helper to boot...\\n\");\n\n\t \n\ttimeout = jiffies + HZ;\n\twhile (1) {\n\t\tu16 req_size;\n\n\t\treq_size = sdio_readb(card->func, IF_SDIO_RD_BASE, &ret);\n\t\tif (ret)\n\t\t\tgoto release;\n\n\t\treq_size |= sdio_readb(card->func, IF_SDIO_RD_BASE + 1, &ret) << 8;\n\t\tif (ret)\n\t\t\tgoto release;\n\n\t\tif (req_size != 0)\n\t\t\tbreak;\n\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tret = -ETIMEDOUT;\n\t\t\tgoto release;\n\t\t}\n\n\t\tmsleep(10);\n\t}\n\n\tret = 0;\n\nrelease:\n\tsdio_release_host(card->func);\n\tkfree(chunk_buffer);\n\nout:\n\tif (ret)\n\t\tpr_err(\"failed to load helper firmware\\n\");\n\n\treturn ret;\n}\n\nstatic int if_sdio_prog_real(struct if_sdio_card *card,\n\t\t\t\tconst struct firmware *fw)\n{\n\tint ret;\n\tunsigned long timeout;\n\tu8 *chunk_buffer;\n\tu32 chunk_size;\n\tconst u8 *firmware;\n\tsize_t size, req_size;\n\n\tchunk_buffer = kzalloc(512, GFP_KERNEL);\n\tif (!chunk_buffer) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsdio_claim_host(card->func);\n\n\tret = sdio_set_block_size(card->func, 32);\n\tif (ret)\n\t\tgoto release;\n\n\tfirmware = fw->data;\n\tsize = fw->size;\n\n\twhile (size) {\n\t\ttimeout = jiffies + HZ;\n\t\twhile (1) {\n\t\t\tret = if_sdio_wait_status(card, FW_DL_READY_STATUS);\n\t\t\tif (ret)\n\t\t\t\tgoto release;\n\n\t\t\treq_size = sdio_readb(card->func, IF_SDIO_RD_BASE,\n\t\t\t\t\t&ret);\n\t\t\tif (ret)\n\t\t\t\tgoto release;\n\n\t\t\treq_size |= sdio_readb(card->func, IF_SDIO_RD_BASE + 1,\n\t\t\t\t\t&ret) << 8;\n\t\t\tif (ret)\n\t\t\t\tgoto release;\n\n\t\t\t \n\t\t\tif ((size != fw->size) || (req_size > 2))\n\t\t\t\tbreak;\n\t\t\tif (time_after(jiffies, timeout)) {\n\t\t\t\tret = -ETIMEDOUT;\n\t\t\t\tgoto release;\n\t\t\t}\n\t\t\tmdelay(1);\n\t\t}\n\n \n\t\tif (req_size == 0) {\n\t\t\tlbs_deb_sdio(\"firmware helper gave up early\\n\");\n\t\t\tret = -EIO;\n\t\t\tgoto release;\n\t\t}\n\n\t\tif (req_size & 0x01) {\n\t\t\tlbs_deb_sdio(\"firmware helper signalled error\\n\");\n\t\t\tret = -EIO;\n\t\t\tgoto release;\n\t\t}\n\n\t\tif (req_size > size)\n\t\t\treq_size = size;\n\n\t\twhile (req_size) {\n\t\t\tchunk_size = min_t(size_t, req_size, 512);\n\n\t\t\tmemcpy(chunk_buffer, firmware, chunk_size);\n \n\t\t\tret = sdio_writesb(card->func, card->ioport,\n\t\t\t\tchunk_buffer, roundup(chunk_size, 32));\n\t\t\tif (ret)\n\t\t\t\tgoto release;\n\n\t\t\tfirmware += chunk_size;\n\t\t\tsize -= chunk_size;\n\t\t\treq_size -= chunk_size;\n\t\t}\n\t}\n\n\tret = 0;\n\n\tlbs_deb_sdio(\"waiting for firmware to boot...\\n\");\n\n\t \n\ttimeout = jiffies + HZ;\n\twhile (1) {\n\t\tu16 scratch;\n\n\t\tscratch = if_sdio_read_scratch(card, &ret);\n\t\tif (ret)\n\t\t\tgoto release;\n\n\t\tif (scratch == IF_SDIO_FIRMWARE_OK)\n\t\t\tbreak;\n\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tret = -ETIMEDOUT;\n\t\t\tgoto release;\n\t\t}\n\n\t\tmsleep(10);\n\t}\n\n\tret = 0;\n\nrelease:\n\tsdio_release_host(card->func);\n\tkfree(chunk_buffer);\n\nout:\n\tif (ret)\n\t\tpr_err(\"failed to load firmware\\n\");\n\n\treturn ret;\n}\n\nstatic void if_sdio_do_prog_firmware(struct lbs_private *priv, int ret,\n\t\t\t\t     const struct firmware *helper,\n\t\t\t\t     const struct firmware *mainfw)\n{\n\tstruct if_sdio_card *card = priv->card;\n\n\tif (ret) {\n\t\tpr_err(\"failed to find firmware (%d)\\n\", ret);\n\t\treturn;\n\t}\n\n\tret = if_sdio_prog_helper(card, helper);\n\tif (ret)\n\t\treturn;\n\n\tlbs_deb_sdio(\"Helper firmware loaded\\n\");\n\n\tret = if_sdio_prog_real(card, mainfw);\n\tif (ret)\n\t\treturn;\n\n\tlbs_deb_sdio(\"Firmware loaded\\n\");\n\tif_sdio_finish_power_on(card);\n}\n\nstatic int if_sdio_prog_firmware(struct if_sdio_card *card)\n{\n\tint ret;\n\tu16 scratch;\n\n\t \n\tsdio_claim_host(card->func);\n\tsdio_writeb(card->func, 0x00, IF_SDIO_H_INT_MASK, &ret);\n\tsdio_release_host(card->func);\n\n\tsdio_claim_host(card->func);\n\tscratch = if_sdio_read_scratch(card, &ret);\n\tsdio_release_host(card->func);\n\n\tlbs_deb_sdio(\"firmware status = %#x\\n\", scratch);\n\tlbs_deb_sdio(\"scratch ret = %d\\n\", ret);\n\n\tif (ret)\n\t\tgoto out;\n\n\n\t \n\tif (scratch == IF_SDIO_FIRMWARE_OK) {\n\t\tlbs_deb_sdio(\"firmware already loaded\\n\");\n\t\tif_sdio_finish_power_on(card);\n\t\treturn 0;\n\t} else if ((card->model == MODEL_8686) && (scratch & 0x7fff)) {\n\t\tlbs_deb_sdio(\"firmware may be running\\n\");\n\t\tif_sdio_finish_power_on(card);\n\t\treturn 0;\n\t}\n\n\tret = lbs_get_firmware_async(card->priv, &card->func->dev, card->model,\n\t\t\t\t     fw_table, if_sdio_do_prog_firmware);\n\nout:\n\treturn ret;\n}\n\n \n \n \n\n \nstatic void if_sdio_finish_power_on(struct if_sdio_card *card)\n{\n\tstruct sdio_func *func = card->func;\n\tstruct lbs_private *priv = card->priv;\n\tint ret;\n\n\tsdio_claim_host(func);\n\tsdio_set_block_size(card->func, IF_SDIO_BLOCK_SIZE);\n\n\t \n\tif ((card->model != MODEL_8385)\n\t\t\t&& (card->model != MODEL_8686))\n\t\tcard->rx_unit = if_sdio_read_rx_unit(card);\n\telse\n\t\tcard->rx_unit = 0;\n\n\t \n\tret = sdio_claim_irq(func, if_sdio_interrupt);\n\tif (ret)\n\t\tgoto release;\n\n\t \n\tsdio_writeb(func, 0x0f, IF_SDIO_H_INT_MASK, &ret);\n\tif (ret)\n\t\tgoto release_irq;\n\n\tsdio_release_host(func);\n\n\t \n\tpriv->fw_ready = 1;\n\n\t \n\tif (card->model == MODEL_8688) {\n\t\tstruct cmd_header cmd;\n\n\t\tmemset(&cmd, 0, sizeof(cmd));\n\n\t\tlbs_deb_sdio(\"send function INIT command\\n\");\n\t\tif (__lbs_cmd(priv, CMD_FUNC_INIT, &cmd, sizeof(cmd),\n\t\t\t\tlbs_cmd_copyback, (unsigned long) &cmd))\n\t\t\tnetdev_alert(priv->dev, \"CMD_FUNC_INIT cmd failed\\n\");\n\t}\n\n\twake_up(&card->pwron_waitq);\n\n\tif (!card->started) {\n\t\tret = lbs_start_card(priv);\n\t\tif_sdio_power_off(card);\n\t\tif (ret == 0) {\n\t\t\tcard->started = true;\n\t\t\t \n\t\t\tpm_runtime_put(&func->dev);\n\t\t}\n\t}\n\n\treturn;\n\nrelease_irq:\n\tsdio_release_irq(func);\nrelease:\n\tsdio_release_host(func);\n}\n\nstatic int if_sdio_power_on(struct if_sdio_card *card)\n{\n\tstruct sdio_func *func = card->func;\n\tstruct mmc_host *host = func->card->host;\n\tint ret;\n\n\tsdio_claim_host(func);\n\n\tret = sdio_enable_func(func);\n\tif (ret)\n\t\tgoto release;\n\n\t \n\tif ((card->model == MODEL_8686) &&\n\t    (host->caps & MMC_CAP_SDIO_IRQ) &&\n\t    (host->ios.bus_width == MMC_BUS_WIDTH_1)) {\n\t\tu8 reg;\n\n\t\tfunc->card->quirks |= MMC_QUIRK_LENIENT_FN0;\n\t\treg = sdio_f0_readb(func, SDIO_CCCR_IF, &ret);\n\t\tif (ret)\n\t\t\tgoto disable;\n\n\t\treg |= SDIO_BUS_ECSI;\n\t\tsdio_f0_writeb(func, reg, SDIO_CCCR_IF, &ret);\n\t\tif (ret)\n\t\t\tgoto disable;\n\t}\n\n\tcard->ioport = sdio_readb(func, IF_SDIO_IOPORT, &ret);\n\tif (ret)\n\t\tgoto disable;\n\n\tcard->ioport |= sdio_readb(func, IF_SDIO_IOPORT + 1, &ret) << 8;\n\tif (ret)\n\t\tgoto disable;\n\n\tcard->ioport |= sdio_readb(func, IF_SDIO_IOPORT + 2, &ret) << 16;\n\tif (ret)\n\t\tgoto disable;\n\n\tsdio_release_host(func);\n\tret = if_sdio_prog_firmware(card);\n\tif (ret) {\n\t\tsdio_claim_host(func);\n\t\tgoto disable;\n\t}\n\n\treturn 0;\n\ndisable:\n\tsdio_disable_func(func);\nrelease:\n\tsdio_release_host(func);\n\treturn ret;\n}\n\nstatic int if_sdio_power_off(struct if_sdio_card *card)\n{\n\tstruct sdio_func *func = card->func;\n\tstruct lbs_private *priv = card->priv;\n\n\tpriv->fw_ready = 0;\n\n\tsdio_claim_host(func);\n\tsdio_release_irq(func);\n\tsdio_disable_func(func);\n\tsdio_release_host(func);\n\treturn 0;\n}\n\n\n \n \n \n\nstatic int if_sdio_host_to_card(struct lbs_private *priv,\n\t\tu8 type, u8 *buf, u16 nb)\n{\n\tint ret;\n\tstruct if_sdio_card *card;\n\tstruct if_sdio_packet *packet;\n\tu16 size;\n\tunsigned long flags;\n\n\tcard = priv->card;\n\n\tif (nb > (65536 - sizeof(struct if_sdio_packet) - 4)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tsize = sdio_align_size(card->func, nb + 4);\n\n\tpacket = kzalloc(sizeof(struct if_sdio_packet) + size,\n\t\t\tGFP_ATOMIC);\n\tif (!packet) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tpacket->nb = size;\n\n\t \n\tpacket->buffer[0] = (nb + 4) & 0xff;\n\tpacket->buffer[1] = ((nb + 4) >> 8) & 0xff;\n\tpacket->buffer[2] = type;\n\tpacket->buffer[3] = 0;\n\n\tmemcpy(packet->buffer + 4, buf, nb);\n\n\tspin_lock_irqsave(&card->lock, flags);\n\n\tlist_add_tail(&packet->list, &card->packets);\n\n\tswitch (type) {\n\tcase MVMS_CMD:\n\t\tpriv->dnld_sent = DNLD_CMD_SENT;\n\t\tbreak;\n\tcase MVMS_DAT:\n\t\tpriv->dnld_sent = DNLD_DATA_SENT;\n\t\tbreak;\n\tdefault:\n\t\tlbs_deb_sdio(\"unknown packet type %d\\n\", (int)type);\n\t}\n\n\tspin_unlock_irqrestore(&card->lock, flags);\n\n\tqueue_work(card->workqueue, &card->packet_worker);\n\n\tret = 0;\n\nout:\n\treturn ret;\n}\n\nstatic int if_sdio_enter_deep_sleep(struct lbs_private *priv)\n{\n\tint ret;\n\tstruct cmd_header cmd;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\n\tlbs_deb_sdio(\"send DEEP_SLEEP command\\n\");\n\tret = __lbs_cmd(priv, CMD_802_11_DEEP_SLEEP, &cmd, sizeof(cmd),\n\t\t\tlbs_cmd_copyback, (unsigned long) &cmd);\n\tif (ret)\n\t\tnetdev_err(priv->dev, \"DEEP_SLEEP cmd failed\\n\");\n\n\tmdelay(200);\n\treturn ret;\n}\n\nstatic int if_sdio_exit_deep_sleep(struct lbs_private *priv)\n{\n\tstruct if_sdio_card *card = priv->card;\n\tint ret = -1;\n\n\tsdio_claim_host(card->func);\n\n\tsdio_writeb(card->func, HOST_POWER_UP, CONFIGURATION_REG, &ret);\n\tif (ret)\n\t\tnetdev_err(priv->dev, \"sdio_writeb failed!\\n\");\n\n\tsdio_release_host(card->func);\n\n\treturn ret;\n}\n\nstatic int if_sdio_reset_deep_sleep_wakeup(struct lbs_private *priv)\n{\n\tstruct if_sdio_card *card = priv->card;\n\tint ret = -1;\n\n\tsdio_claim_host(card->func);\n\n\tsdio_writeb(card->func, 0, CONFIGURATION_REG, &ret);\n\tif (ret)\n\t\tnetdev_err(priv->dev, \"sdio_writeb failed!\\n\");\n\n\tsdio_release_host(card->func);\n\n\treturn ret;\n\n}\n\nstatic void if_sdio_reset_card_worker(struct work_struct *work)\n{\n\tint ret;\n\tconst char *name;\n\tstruct device *dev;\n\tstruct if_sdio_card *card;\n\tstruct mmc_host *reset_host;\n\n\tcard = container_of(work, struct if_sdio_card, reset_worker);\n\treset_host = card->func->card->host;\n\tname = card->priv->dev->name;\n\tdev = &card->func->dev;\n\n\t \n\n\tdev_info(dev, \"resetting card %s...\", name);\n\tmmc_remove_host(reset_host);\n\tret = mmc_add_host(reset_host);\n\tif (ret)\n\t\tdev_err(dev, \"%s: can't add mmc host, error %d\\n\", name, ret);\n}\n\nstatic void if_sdio_reset_card(struct lbs_private *priv)\n{\n\tstruct if_sdio_card *card = priv->card;\n\n\tif (!work_pending(&card->reset_worker))\n\t\tschedule_work(&card->reset_worker);\n}\n\nstatic int if_sdio_power_save(struct lbs_private *priv)\n{\n\tstruct if_sdio_card *card = priv->card;\n\tint ret;\n\n\tflush_workqueue(card->workqueue);\n\n\tret = if_sdio_power_off(card);\n\n\t \n\tpm_runtime_put_sync(&card->func->dev);\n\n\treturn ret;\n}\n\nstatic int if_sdio_power_restore(struct lbs_private *priv)\n{\n\tstruct if_sdio_card *card = priv->card;\n\tint r;\n\n\t \n\tpm_runtime_get_sync(&card->func->dev);\n\n\tr = if_sdio_power_on(card);\n\tif (r)\n\t\treturn r;\n\n\twait_event(card->pwron_waitq, priv->fw_ready);\n\treturn 0;\n}\n\n\n \n \n \n\nstatic void if_sdio_interrupt(struct sdio_func *func)\n{\n\tint ret;\n\tstruct if_sdio_card *card;\n\tu8 cause;\n\n\tcard = sdio_get_drvdata(func);\n\n\tcause = sdio_readb(card->func, IF_SDIO_H_INT_STATUS, &ret);\n\tif (ret || !cause)\n\t\treturn;\n\n\tlbs_deb_sdio(\"interrupt: 0x%X\\n\", (unsigned)cause);\n\n\tsdio_writeb(card->func, ~cause, IF_SDIO_H_INT_STATUS, &ret);\n\tif (ret)\n\t\treturn;\n\n\t \n\tcard->priv->is_activity_detected = 1;\n\tif (cause & IF_SDIO_H_INT_DNLD)\n\t\tlbs_host_to_card_done(card->priv);\n\n\n\tif (cause & IF_SDIO_H_INT_UPLD) {\n\t\tret = if_sdio_card_to_host(card);\n\t\tif (ret)\n\t\t\treturn;\n\t}\n}\n\nstatic int if_sdio_probe(struct sdio_func *func,\n\t\tconst struct sdio_device_id *id)\n{\n\tstruct if_sdio_card *card;\n\tstruct lbs_private *priv;\n\tint ret, i;\n\tunsigned int model;\n\tstruct if_sdio_packet *packet, *tmp;\n\n\tfor (i = 0;i < func->card->num_info;i++) {\n\t\tif (sscanf(func->card->info[i],\n\t\t\t\t\"802.11 SDIO ID: %x\", &model) == 1)\n\t\t\tbreak;\n\t\tif (sscanf(func->card->info[i],\n\t\t\t\t\"ID: %x\", &model) == 1)\n\t\t\tbreak;\n\t\tif (!strcmp(func->card->info[i], \"IBIS Wireless SDIO Card\")) {\n\t\t\tmodel = MODEL_8385;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == func->card->num_info) {\n\t\tpr_err(\"unable to identify card model\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tcard = kzalloc(sizeof(struct if_sdio_card), GFP_KERNEL);\n\tif (!card)\n\t\treturn -ENOMEM;\n\n\tcard->func = func;\n\tcard->model = model;\n\n\tswitch (card->model) {\n\tcase MODEL_8385:\n\t\tcard->scratch_reg = IF_SDIO_SCRATCH_OLD;\n\t\tbreak;\n\tcase MODEL_8686:\n\t\tcard->scratch_reg = IF_SDIO_SCRATCH;\n\t\tbreak;\n\tcase MODEL_8688:\n\tdefault:  \n\t\tcard->scratch_reg = IF_SDIO_FW_STATUS;\n\t\tbreak;\n\t}\n\n\tspin_lock_init(&card->lock);\n\tINIT_LIST_HEAD(&card->packets);\n\n\tcard->workqueue = alloc_workqueue(\"libertas_sdio\", WQ_MEM_RECLAIM, 0);\n\tif (unlikely(!card->workqueue)) {\n\t\tret = -ENOMEM;\n\t\tgoto err_queue;\n\t}\n\n\tINIT_WORK(&card->reset_worker, if_sdio_reset_card_worker);\n\tINIT_WORK(&card->packet_worker, if_sdio_host_to_card_worker);\n\tinit_waitqueue_head(&card->pwron_waitq);\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(fw_table); i++) {\n\t\tif (card->model == fw_table[i].model)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(fw_table)) {\n\t\tpr_err(\"unknown card model 0x%x\\n\", card->model);\n\t\tret = -ENODEV;\n\t\tgoto free;\n\t}\n\n\tsdio_set_drvdata(func, card);\n\n\tlbs_deb_sdio(\"class = 0x%X, vendor = 0x%X, \"\n\t\t\t\"device = 0x%X, model = 0x%X, ioport = 0x%X\\n\",\n\t\t\tfunc->class, func->vendor, func->device,\n\t\t\tmodel, (unsigned)card->ioport);\n\n\n\tpriv = lbs_add_card(card, &func->dev);\n\tif (IS_ERR(priv)) {\n\t\tret = PTR_ERR(priv);\n\t\tgoto free;\n\t}\n\n\tcard->priv = priv;\n\n\tpriv->card = card;\n\tpriv->hw_host_to_card = if_sdio_host_to_card;\n\tpriv->enter_deep_sleep = if_sdio_enter_deep_sleep;\n\tpriv->exit_deep_sleep = if_sdio_exit_deep_sleep;\n\tpriv->reset_deep_sleep_wakeup = if_sdio_reset_deep_sleep_wakeup;\n\tpriv->reset_card = if_sdio_reset_card;\n\tpriv->power_save = if_sdio_power_save;\n\tpriv->power_restore = if_sdio_power_restore;\n\tpriv->is_polling = !(func->card->host->caps & MMC_CAP_SDIO_IRQ);\n\tret = if_sdio_power_on(card);\n\tif (ret)\n\t\tgoto err_activate_card;\n\nout:\n\treturn ret;\n\nerr_activate_card:\n\tflush_workqueue(card->workqueue);\n\tlbs_remove_card(priv);\nfree:\n\tcancel_work_sync(&card->packet_worker);\n\tcancel_work_sync(&card->reset_worker);\n\tdestroy_workqueue(card->workqueue);\nerr_queue:\n\tlist_for_each_entry_safe(packet, tmp, &card->packets, list)\n\t\tkfree(packet);\n\n\tkfree(card);\n\n\tgoto out;\n}\n\nstatic void if_sdio_remove(struct sdio_func *func)\n{\n\tstruct if_sdio_card *card;\n\tstruct if_sdio_packet *packet, *tmp;\n\n\tcard = sdio_get_drvdata(func);\n\n\t \n\tpm_runtime_get_noresume(&func->dev);\n\n\tif (user_rmmod && (card->model == MODEL_8688)) {\n\t\t \n\t\tstruct cmd_header cmd;\n\n\t\tmemset(&cmd, 0, sizeof(cmd));\n\n\t\tlbs_deb_sdio(\"send function SHUTDOWN command\\n\");\n\t\tif (__lbs_cmd(card->priv, CMD_FUNC_SHUTDOWN,\n\t\t\t\t&cmd, sizeof(cmd), lbs_cmd_copyback,\n\t\t\t\t(unsigned long) &cmd))\n\t\t\tpr_alert(\"CMD_FUNC_SHUTDOWN cmd failed\\n\");\n\t}\n\n\n\tlbs_deb_sdio(\"call remove card\\n\");\n\tlbs_stop_card(card->priv);\n\tlbs_remove_card(card->priv);\n\n\tcancel_work_sync(&card->packet_worker);\n\tcancel_work_sync(&card->reset_worker);\n\tdestroy_workqueue(card->workqueue);\n\n\tlist_for_each_entry_safe(packet, tmp, &card->packets, list)\n\t\tkfree(packet);\n\n\tkfree(card);\n}\n\nstatic int if_sdio_suspend(struct device *dev)\n{\n\tstruct sdio_func *func = dev_to_sdio_func(dev);\n\tstruct if_sdio_card *card = sdio_get_drvdata(func);\n\tstruct lbs_private *priv = card->priv;\n\tint ret;\n\n\tmmc_pm_flag_t flags = sdio_get_host_pm_caps(func);\n\tpriv->power_up_on_resume = false;\n\n\t \n\tif (!lbs_iface_active(priv)) {\n\t\tif (priv->fw_ready) {\n\t\t\tpriv->power_up_on_resume = true;\n\t\t\tif_sdio_power_off(card);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tdev_info(dev, \"%s: suspend: PM flags = 0x%x\\n\",\n\t\t sdio_func_id(func), flags);\n\n\t \n\tif (priv->wol_criteria == EHS_REMOVE_WAKEUP) {\n\t\tdev_info(dev, \"Suspend without wake params -- powering down card\\n\");\n\t\tif (priv->fw_ready) {\n\t\t\tret = lbs_suspend(priv);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tpriv->power_up_on_resume = true;\n\t\t\tif_sdio_power_off(card);\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif (!(flags & MMC_PM_KEEP_POWER)) {\n\t\tdev_err(dev, \"%s: cannot remain alive while host is suspended\\n\",\n\t\t\tsdio_func_id(func));\n\t\treturn -ENOSYS;\n\t}\n\n\tret = sdio_set_host_pm_flags(func, MMC_PM_KEEP_POWER);\n\tif (ret)\n\t\treturn ret;\n\n\tret = lbs_suspend(priv);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sdio_set_host_pm_flags(func, MMC_PM_WAKE_SDIO_IRQ);\n}\n\nstatic int if_sdio_resume(struct device *dev)\n{\n\tstruct sdio_func *func = dev_to_sdio_func(dev);\n\tstruct if_sdio_card *card = sdio_get_drvdata(func);\n\tint ret;\n\n\tdev_info(dev, \"%s: resume: we're back\\n\", sdio_func_id(func));\n\n\tif (card->priv->power_up_on_resume) {\n\t\tif_sdio_power_on(card);\n\t\twait_event(card->pwron_waitq, card->priv->fw_ready);\n\t}\n\n\tret = lbs_resume(card->priv);\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops if_sdio_pm_ops = {\n\t.suspend\t= if_sdio_suspend,\n\t.resume\t\t= if_sdio_resume,\n};\n\nstatic struct sdio_driver if_sdio_driver = {\n\t.name\t\t= \"libertas_sdio\",\n\t.id_table\t= if_sdio_ids,\n\t.probe\t\t= if_sdio_probe,\n\t.remove\t\t= if_sdio_remove,\n\t.drv = {\n\t\t.pm = &if_sdio_pm_ops,\n\t},\n};\n\n \n \n \n\nstatic int __init if_sdio_init_module(void)\n{\n\tint ret = 0;\n\n\tprintk(KERN_INFO \"libertas_sdio: Libertas SDIO driver\\n\");\n\tprintk(KERN_INFO \"libertas_sdio: Copyright Pierre Ossman\\n\");\n\n\tret = sdio_register_driver(&if_sdio_driver);\n\n\t \n\tuser_rmmod = 0;\n\n\treturn ret;\n}\n\nstatic void __exit if_sdio_exit_module(void)\n{\n\t \n\tuser_rmmod = 1;\n\n\tsdio_unregister_driver(&if_sdio_driver);\n}\n\nmodule_init(if_sdio_init_module);\nmodule_exit(if_sdio_exit_module);\n\nMODULE_DESCRIPTION(\"Libertas SDIO WLAN Driver\");\nMODULE_AUTHOR(\"Pierre Ossman\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}