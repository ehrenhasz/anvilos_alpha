{
  "module_name": "if_usb.c",
  "hash_id": "a75f46f96a44b8ed7bbb46dbc2cd2a4bdf5821802bc1a4ab93cbe07cfb3ed089",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/marvell/libertas/if_usb.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/firmware.h>\n#include <linux/netdevice.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n#include <linux/olpc-ec.h>\n\n#ifdef CONFIG_OLPC\n#include <asm/olpc.h>\n#endif\n\n#define DRV_NAME \"usb8xxx\"\n\n#include \"host.h\"\n#include \"decl.h\"\n#include \"defs.h\"\n#include \"dev.h\"\n#include \"cmd.h\"\n#include \"if_usb.h\"\n\n#define INSANEDEBUG\t0\n#define lbs_deb_usb2(...) do { if (INSANEDEBUG) lbs_deb_usbd(__VA_ARGS__); } while (0)\n\n#define MESSAGE_HEADER_LEN\t4\n\nMODULE_FIRMWARE(\"libertas/usb8388_v9.bin\");\nMODULE_FIRMWARE(\"libertas/usb8388_v5.bin\");\nMODULE_FIRMWARE(\"libertas/usb8388.bin\");\nMODULE_FIRMWARE(\"libertas/usb8682.bin\");\nMODULE_FIRMWARE(\"usb8388.bin\");\n\nenum {\n\tMODEL_UNKNOWN = 0x0,\n\tMODEL_8388 = 0x1,\n\tMODEL_8682 = 0x2\n};\n\n \nstatic const struct lbs_fw_table fw_table[] = {\n\t{ MODEL_8388, \"libertas/usb8388_olpc.bin\", NULL },\n\t{ MODEL_8388, \"libertas/usb8388_v9.bin\", NULL },\n\t{ MODEL_8388, \"libertas/usb8388_v5.bin\", NULL },\n\t{ MODEL_8388, \"libertas/usb8388.bin\", NULL },\n\t{ MODEL_8388, \"usb8388.bin\", NULL },\n\t{ MODEL_8682, \"libertas/usb8682.bin\", NULL },\n\t{ 0, NULL, NULL }\n};\n\nstatic const struct usb_device_id if_usb_table[] = {\n\t \n\t{ USB_DEVICE(0x1286, 0x2001), .driver_info = MODEL_8388 },\n\t{ USB_DEVICE(0x05a3, 0x8388), .driver_info = MODEL_8388 },\n\t{}\t \n};\n\nMODULE_DEVICE_TABLE(usb, if_usb_table);\n\nstatic void if_usb_receive(struct urb *urb);\nstatic void if_usb_receive_fwload(struct urb *urb);\nstatic void if_usb_prog_firmware(struct lbs_private *priv, int ret,\n\t\t\t\t const struct firmware *fw,\n\t\t\t\t const struct firmware *unused);\nstatic int if_usb_host_to_card(struct lbs_private *priv, uint8_t type,\n\t\t\t       uint8_t *payload, uint16_t nb);\nstatic int usb_tx_block(struct if_usb_card *cardp, uint8_t *payload,\n\t\t\tuint16_t nb);\nstatic void if_usb_free(struct if_usb_card *cardp);\nstatic int if_usb_submit_rx_urb(struct if_usb_card *cardp);\nstatic int if_usb_reset_device(struct if_usb_card *cardp);\n\n \nstatic void if_usb_write_bulk_callback(struct urb *urb)\n{\n\tstruct if_usb_card *cardp = (struct if_usb_card *) urb->context;\n\n\t \n\n\tif (urb->status == 0) {\n\t\tstruct lbs_private *priv = cardp->priv;\n\n\t\tlbs_deb_usb2(&urb->dev->dev, \"URB status is successful\\n\");\n\t\tlbs_deb_usb2(&urb->dev->dev, \"Actual length transmitted %d\\n\",\n\t\t\t     urb->actual_length);\n\n\t\t \n\t\tif (priv && priv->dnld_sent != DNLD_BOOTCMD_SENT)\n\t\t\tlbs_host_to_card_done(priv);\n\t} else {\n\t\t \n\t\tpr_info(\"URB in failure status: %d\\n\", urb->status);\n\t}\n}\n\n \nstatic void if_usb_free(struct if_usb_card *cardp)\n{\n\t \n\tusb_kill_urb(cardp->tx_urb);\n\tusb_kill_urb(cardp->rx_urb);\n\n\tusb_free_urb(cardp->tx_urb);\n\tcardp->tx_urb = NULL;\n\n\tusb_free_urb(cardp->rx_urb);\n\tcardp->rx_urb = NULL;\n\n\tkfree(cardp->ep_out_buf);\n\tcardp->ep_out_buf = NULL;\n}\n\nstatic void if_usb_setup_firmware(struct lbs_private *priv)\n{\n\tstruct if_usb_card *cardp = priv->card;\n\tstruct cmd_ds_set_boot2_ver b2_cmd;\n\tstruct cmd_ds_802_11_fw_wake_method wake_method;\n\n\tb2_cmd.hdr.size = cpu_to_le16(sizeof(b2_cmd));\n\tb2_cmd.action = 0;\n\tb2_cmd.version = cardp->boot2_version;\n\n\tif (lbs_cmd_with_response(priv, CMD_SET_BOOT2_VER, &b2_cmd))\n\t\tlbs_deb_usb(\"Setting boot2 version failed\\n\");\n\n\tpriv->wol_gpio = 2;  \n\tpriv->wol_gap = 20;  \n\tlbs_host_sleep_cfg(priv, EHS_WAKE_ON_UNICAST_DATA,\n\t\t\t(struct wol_config *) NULL);\n\n\twake_method.hdr.size = cpu_to_le16(sizeof(wake_method));\n\twake_method.action = cpu_to_le16(CMD_ACT_GET);\n\tif (lbs_cmd_with_response(priv, CMD_802_11_FW_WAKE_METHOD, &wake_method)) {\n\t\tnetdev_info(priv->dev, \"Firmware does not seem to support PS mode\\n\");\n\t\tpriv->fwcapinfo &= ~FW_CAPINFO_PS;\n\t} else {\n\t\tif (le16_to_cpu(wake_method.method) == CMD_WAKE_METHOD_COMMAND_INT) {\n\t\t\tlbs_deb_usb(\"Firmware seems to support PS with wake-via-command\\n\");\n\t\t} else {\n\t\t\t \n\t\t\tpriv->fwcapinfo &= ~FW_CAPINFO_PS;\n\t\t\tnetdev_info(priv->dev,\n\t\t\t\t    \"Firmware doesn't wake via command interrupt; disabling PS mode\\n\");\n\t\t}\n\t}\n}\n\nstatic void if_usb_fw_timeo(struct timer_list *t)\n{\n\tstruct if_usb_card *cardp = from_timer(cardp, t, fw_timeout);\n\n\tif (cardp->fwdnldover) {\n\t\tlbs_deb_usb(\"Download complete, no event. Assuming success\\n\");\n\t} else {\n\t\tpr_err(\"Download timed out\\n\");\n\t\tcardp->surprise_removed = 1;\n\t}\n\twake_up(&cardp->fw_wq);\n}\n\n#ifdef CONFIG_OLPC\nstatic void if_usb_reset_olpc_card(struct lbs_private *priv)\n{\n\tprintk(KERN_CRIT \"Resetting OLPC wireless via EC...\\n\");\n\tolpc_ec_cmd(0x25, NULL, 0, NULL, 0);\n}\n#endif\n\n \nstatic int if_usb_probe(struct usb_interface *intf,\n\t\t\tconst struct usb_device_id *id)\n{\n\tstruct usb_device *udev;\n\tstruct usb_host_interface *iface_desc;\n\tstruct usb_endpoint_descriptor *endpoint;\n\tstruct lbs_private *priv;\n\tstruct if_usb_card *cardp;\n\tint r = -ENOMEM;\n\tint i;\n\n\tudev = interface_to_usbdev(intf);\n\n\tcardp = kzalloc(sizeof(struct if_usb_card), GFP_KERNEL);\n\tif (!cardp)\n\t\tgoto error;\n\n\ttimer_setup(&cardp->fw_timeout, if_usb_fw_timeo, 0);\n\tinit_waitqueue_head(&cardp->fw_wq);\n\n\tcardp->udev = udev;\n\tcardp->model = (uint32_t) id->driver_info;\n\tiface_desc = intf->cur_altsetting;\n\n\tlbs_deb_usbd(&udev->dev, \"bcdUSB = 0x%X bDeviceClass = 0x%X\"\n\t\t     \" bDeviceSubClass = 0x%X, bDeviceProtocol = 0x%X\\n\",\n\t\t     le16_to_cpu(udev->descriptor.bcdUSB),\n\t\t     udev->descriptor.bDeviceClass,\n\t\t     udev->descriptor.bDeviceSubClass,\n\t\t     udev->descriptor.bDeviceProtocol);\n\n\tfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\n\t\tendpoint = &iface_desc->endpoint[i].desc;\n\t\tif (usb_endpoint_is_bulk_in(endpoint)) {\n\t\t\tcardp->ep_in_size = le16_to_cpu(endpoint->wMaxPacketSize);\n\t\t\tcardp->ep_in = usb_endpoint_num(endpoint);\n\n\t\t\tlbs_deb_usbd(&udev->dev, \"in_endpoint = %d\\n\", cardp->ep_in);\n\t\t\tlbs_deb_usbd(&udev->dev, \"Bulk in size is %d\\n\", cardp->ep_in_size);\n\n\t\t} else if (usb_endpoint_is_bulk_out(endpoint)) {\n\t\t\tcardp->ep_out_size = le16_to_cpu(endpoint->wMaxPacketSize);\n\t\t\tcardp->ep_out = usb_endpoint_num(endpoint);\n\n\t\t\tlbs_deb_usbd(&udev->dev, \"out_endpoint = %d\\n\", cardp->ep_out);\n\t\t\tlbs_deb_usbd(&udev->dev, \"Bulk out size is %d\\n\", cardp->ep_out_size);\n\t\t}\n\t}\n\tif (!cardp->ep_out_size || !cardp->ep_in_size) {\n\t\tlbs_deb_usbd(&udev->dev, \"Endpoints not found\\n\");\n\t\tgoto dealloc;\n\t}\n\tif (!(cardp->rx_urb = usb_alloc_urb(0, GFP_KERNEL))) {\n\t\tlbs_deb_usbd(&udev->dev, \"Rx URB allocation failed\\n\");\n\t\tgoto dealloc;\n\t}\n\tif (!(cardp->tx_urb = usb_alloc_urb(0, GFP_KERNEL))) {\n\t\tlbs_deb_usbd(&udev->dev, \"Tx URB allocation failed\\n\");\n\t\tgoto dealloc;\n\t}\n\tcardp->ep_out_buf = kmalloc(MRVDRV_ETH_TX_PACKET_BUFFER_SIZE, GFP_KERNEL);\n\tif (!cardp->ep_out_buf) {\n\t\tlbs_deb_usbd(&udev->dev, \"Could not allocate buffer\\n\");\n\t\tgoto dealloc;\n\t}\n\n\tpriv = lbs_add_card(cardp, &intf->dev);\n\tif (IS_ERR(priv)) {\n\t\tr = PTR_ERR(priv);\n\t\tgoto err_add_card;\n\t}\n\n\tcardp->priv = priv;\n\n\tpriv->hw_host_to_card = if_usb_host_to_card;\n\tpriv->enter_deep_sleep = NULL;\n\tpriv->exit_deep_sleep = NULL;\n\tpriv->reset_deep_sleep_wakeup = NULL;\n\tpriv->is_polling = false;\n#ifdef CONFIG_OLPC\n\tif (machine_is_olpc())\n\t\tpriv->reset_card = if_usb_reset_olpc_card;\n#endif\n\n\tcardp->boot2_version = udev->descriptor.bcdDevice;\n\n\tusb_get_dev(udev);\n\tusb_set_intfdata(intf, cardp);\n\n\tr = lbs_get_firmware_async(priv, &udev->dev, cardp->model,\n\t\t\t\t   fw_table, if_usb_prog_firmware);\n\tif (r)\n\t\tgoto err_get_fw;\n\n\treturn 0;\n\nerr_get_fw:\n\tusb_put_dev(udev);\n\tlbs_remove_card(priv);\nerr_add_card:\n\tif_usb_reset_device(cardp);\ndealloc:\n\tif_usb_free(cardp);\n\tkfree(cardp);\n\nerror:\n\treturn r;\n}\n\n \nstatic void if_usb_disconnect(struct usb_interface *intf)\n{\n\tstruct if_usb_card *cardp = usb_get_intfdata(intf);\n\tstruct lbs_private *priv = cardp->priv;\n\n\tcardp->surprise_removed = 1;\n\n\tif (priv) {\n\t\tlbs_stop_card(priv);\n\t\tlbs_remove_card(priv);\n\t}\n\n\t \n\tif_usb_free(cardp);\n\tkfree(cardp);\n\n\tusb_set_intfdata(intf, NULL);\n\tusb_put_dev(interface_to_usbdev(intf));\n}\n\n \nstatic int if_usb_send_fw_pkt(struct if_usb_card *cardp)\n{\n\tstruct fwdata *fwdata = cardp->ep_out_buf;\n\tconst uint8_t *firmware = cardp->fw->data;\n\n\t \n\tif (!cardp->CRC_OK) {\n\t\tcardp->totalbytes = cardp->fwlastblksent;\n\t\tcardp->fwseqnum--;\n\t}\n\n\tlbs_deb_usb2(&cardp->udev->dev, \"totalbytes = %d\\n\",\n\t\t     cardp->totalbytes);\n\n\t \n\tmemcpy(&fwdata->hdr, &firmware[cardp->totalbytes],\n\t       sizeof(struct fwheader));\n\n\tcardp->fwlastblksent = cardp->totalbytes;\n\tcardp->totalbytes += sizeof(struct fwheader);\n\n\tmemcpy(fwdata->data, &firmware[cardp->totalbytes],\n\t       le32_to_cpu(fwdata->hdr.datalength));\n\n\tlbs_deb_usb2(&cardp->udev->dev, \"Data length = %d\\n\",\n\t\t     le32_to_cpu(fwdata->hdr.datalength));\n\n\tfwdata->seqnum = cpu_to_le32(++cardp->fwseqnum);\n\tcardp->totalbytes += le32_to_cpu(fwdata->hdr.datalength);\n\n\tusb_tx_block(cardp, cardp->ep_out_buf, sizeof(struct fwdata) +\n\t\t     le32_to_cpu(fwdata->hdr.datalength));\n\n\tif (fwdata->hdr.dnldcmd == cpu_to_le32(FW_HAS_DATA_TO_RECV)) {\n\t\tlbs_deb_usb2(&cardp->udev->dev, \"There are data to follow\\n\");\n\t\tlbs_deb_usb2(&cardp->udev->dev, \"seqnum = %d totalbytes = %d\\n\",\n\t\t\t     cardp->fwseqnum, cardp->totalbytes);\n\t} else if (fwdata->hdr.dnldcmd == cpu_to_le32(FW_HAS_LAST_BLOCK)) {\n\t\tlbs_deb_usb2(&cardp->udev->dev, \"Host has finished FW downloading\\n\");\n\t\tlbs_deb_usb2(&cardp->udev->dev, \"Downloading FW JUMP BLOCK\\n\");\n\n\t\tcardp->fwfinalblk = 1;\n\t}\n\n\tlbs_deb_usb2(&cardp->udev->dev, \"Firmware download done; size %d\\n\",\n\t\t     cardp->totalbytes);\n\n\treturn 0;\n}\n\nstatic int if_usb_reset_device(struct if_usb_card *cardp)\n{\n\tstruct cmd_header *cmd = cardp->ep_out_buf + 4;\n\tint ret;\n\n\t*(__le32 *)cardp->ep_out_buf = cpu_to_le32(CMD_TYPE_REQUEST);\n\n\tcmd->command = cpu_to_le16(CMD_802_11_RESET);\n\tcmd->size = cpu_to_le16(sizeof(cmd));\n\tcmd->result = cpu_to_le16(0);\n\tcmd->seqnum = cpu_to_le16(0x5a5a);\n\tusb_tx_block(cardp, cardp->ep_out_buf, 4 + sizeof(struct cmd_header));\n\n\tmsleep(100);\n\tret = usb_reset_device(cardp->udev);\n\tmsleep(100);\n\n#ifdef CONFIG_OLPC\n\tif (ret && machine_is_olpc())\n\t\tif_usb_reset_olpc_card(NULL);\n#endif\n\n\treturn ret;\n}\n\n \nstatic int usb_tx_block(struct if_usb_card *cardp, uint8_t *payload, uint16_t nb)\n{\n\tint ret;\n\n\t \n\tif (cardp->surprise_removed) {\n\t\tlbs_deb_usbd(&cardp->udev->dev, \"Device removed\\n\");\n\t\tret = -ENODEV;\n\t\tgoto tx_ret;\n\t}\n\n\tusb_fill_bulk_urb(cardp->tx_urb, cardp->udev,\n\t\t\t  usb_sndbulkpipe(cardp->udev,\n\t\t\t\t\t  cardp->ep_out),\n\t\t\t  payload, nb, if_usb_write_bulk_callback, cardp);\n\n\tcardp->tx_urb->transfer_flags |= URB_ZERO_PACKET;\n\n\tif ((ret = usb_submit_urb(cardp->tx_urb, GFP_ATOMIC))) {\n\t\tlbs_deb_usbd(&cardp->udev->dev, \"usb_submit_urb failed: %d\\n\", ret);\n\t} else {\n\t\tlbs_deb_usb2(&cardp->udev->dev, \"usb_submit_urb success\\n\");\n\t\tret = 0;\n\t}\n\ntx_ret:\n\treturn ret;\n}\n\nstatic int __if_usb_submit_rx_urb(struct if_usb_card *cardp,\n\t\t\t\t  void (*callbackfn)(struct urb *urb))\n{\n\tstruct sk_buff *skb;\n\tint ret = -1;\n\n\tif (!(skb = dev_alloc_skb(MRVDRV_ETH_RX_PACKET_BUFFER_SIZE))) {\n\t\tpr_err(\"No free skb\\n\");\n\t\tgoto rx_ret;\n\t}\n\n\tcardp->rx_skb = skb;\n\n\t \n\tusb_fill_bulk_urb(cardp->rx_urb, cardp->udev,\n\t\t\t  usb_rcvbulkpipe(cardp->udev, cardp->ep_in),\n\t\t\t  skb->data + IPFIELD_ALIGN_OFFSET,\n\t\t\t  MRVDRV_ETH_RX_PACKET_BUFFER_SIZE, callbackfn,\n\t\t\t  cardp);\n\n\tlbs_deb_usb2(&cardp->udev->dev, \"Pointer for rx_urb %p\\n\", cardp->rx_urb);\n\tif ((ret = usb_submit_urb(cardp->rx_urb, GFP_ATOMIC))) {\n\t\tlbs_deb_usbd(&cardp->udev->dev, \"Submit Rx URB failed: %d\\n\", ret);\n\t\tkfree_skb(skb);\n\t\tcardp->rx_skb = NULL;\n\t\tret = -1;\n\t} else {\n\t\tlbs_deb_usb2(&cardp->udev->dev, \"Submit Rx URB success\\n\");\n\t\tret = 0;\n\t}\n\nrx_ret:\n\treturn ret;\n}\n\nstatic int if_usb_submit_rx_urb_fwload(struct if_usb_card *cardp)\n{\n\treturn __if_usb_submit_rx_urb(cardp, &if_usb_receive_fwload);\n}\n\nstatic int if_usb_submit_rx_urb(struct if_usb_card *cardp)\n{\n\treturn __if_usb_submit_rx_urb(cardp, &if_usb_receive);\n}\n\nstatic void if_usb_receive_fwload(struct urb *urb)\n{\n\tstruct if_usb_card *cardp = urb->context;\n\tstruct sk_buff *skb = cardp->rx_skb;\n\tstruct fwsyncheader *syncfwheader;\n\tstruct bootcmdresp bootcmdresp;\n\n\tif (urb->status) {\n\t\tlbs_deb_usbd(&cardp->udev->dev,\n\t\t\t     \"URB status is failed during fw load\\n\");\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tif (cardp->fwdnldover) {\n\t\t__le32 *tmp = (__le32 *)(skb->data + IPFIELD_ALIGN_OFFSET);\n\n\t\tif (tmp[0] == cpu_to_le32(CMD_TYPE_INDICATION) &&\n\t\t    tmp[1] == cpu_to_le32(MACREG_INT_CODE_FIRMWARE_READY)) {\n\t\t\tpr_info(\"Firmware ready event received\\n\");\n\t\t\twake_up(&cardp->fw_wq);\n\t\t} else {\n\t\t\tlbs_deb_usb(\"Waiting for confirmation; got %x %x\\n\",\n\t\t\t\t    le32_to_cpu(tmp[0]), le32_to_cpu(tmp[1]));\n\t\t\tif_usb_submit_rx_urb_fwload(cardp);\n\t\t}\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\tif (cardp->bootcmdresp <= 0) {\n\t\tmemcpy (&bootcmdresp, skb->data + IPFIELD_ALIGN_OFFSET,\n\t\t\tsizeof(bootcmdresp));\n\n\t\tif (le16_to_cpu(cardp->udev->descriptor.bcdDevice) < 0x3106) {\n\t\t\tkfree_skb(skb);\n\t\t\tif_usb_submit_rx_urb_fwload(cardp);\n\t\t\tcardp->bootcmdresp = BOOT_CMD_RESP_OK;\n\t\t\tlbs_deb_usbd(&cardp->udev->dev,\n\t\t\t\t     \"Received valid boot command response\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif (bootcmdresp.magic != cpu_to_le32(BOOT_CMD_MAGIC_NUMBER)) {\n\t\t\tif (bootcmdresp.magic == cpu_to_le32(CMD_TYPE_REQUEST) ||\n\t\t\t    bootcmdresp.magic == cpu_to_le32(CMD_TYPE_DATA) ||\n\t\t\t    bootcmdresp.magic == cpu_to_le32(CMD_TYPE_INDICATION)) {\n\t\t\t\tif (!cardp->bootcmdresp)\n\t\t\t\t\tpr_info(\"Firmware already seems alive; resetting\\n\");\n\t\t\t\tcardp->bootcmdresp = -1;\n\t\t\t} else {\n\t\t\t\tpr_info(\"boot cmd response wrong magic number (0x%x)\\n\",\n\t\t\t\t\t    le32_to_cpu(bootcmdresp.magic));\n\t\t\t}\n\t\t} else if ((bootcmdresp.cmd != BOOT_CMD_FW_BY_USB) &&\n\t\t\t   (bootcmdresp.cmd != BOOT_CMD_UPDATE_FW) &&\n\t\t\t   (bootcmdresp.cmd != BOOT_CMD_UPDATE_BOOT2)) {\n\t\t\tpr_info(\"boot cmd response cmd_tag error (%d)\\n\",\n\t\t\t\tbootcmdresp.cmd);\n\t\t} else if (bootcmdresp.result != BOOT_CMD_RESP_OK) {\n\t\t\tpr_info(\"boot cmd response result error (%d)\\n\",\n\t\t\t\tbootcmdresp.result);\n\t\t} else {\n\t\t\tcardp->bootcmdresp = 1;\n\t\t\tlbs_deb_usbd(&cardp->udev->dev,\n\t\t\t\t     \"Received valid boot command response\\n\");\n\t\t}\n\t\tkfree_skb(skb);\n\t\tif_usb_submit_rx_urb_fwload(cardp);\n\t\treturn;\n\t}\n\n\tsyncfwheader = kmemdup(skb->data + IPFIELD_ALIGN_OFFSET,\n\t\t\t       sizeof(struct fwsyncheader), GFP_ATOMIC);\n\tif (!syncfwheader) {\n\t\tlbs_deb_usbd(&cardp->udev->dev, \"Failure to allocate syncfwheader\\n\");\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tif (!syncfwheader->cmd) {\n\t\tlbs_deb_usb2(&cardp->udev->dev, \"FW received Blk with correct CRC\\n\");\n\t\tlbs_deb_usb2(&cardp->udev->dev, \"FW received Blk seqnum = %d\\n\",\n\t\t\t     le32_to_cpu(syncfwheader->seqnum));\n\t\tcardp->CRC_OK = 1;\n\t} else {\n\t\tlbs_deb_usbd(&cardp->udev->dev, \"FW received Blk with CRC error\\n\");\n\t\tcardp->CRC_OK = 0;\n\t}\n\n\tkfree_skb(skb);\n\n\t \n\tmod_timer(&cardp->fw_timeout, jiffies + (HZ*5));\n\n\tif (cardp->fwfinalblk) {\n\t\tcardp->fwdnldover = 1;\n\t\tgoto exit;\n\t}\n\n\tif_usb_send_fw_pkt(cardp);\n\n exit:\n\tif_usb_submit_rx_urb_fwload(cardp);\n\n\tkfree(syncfwheader);\n}\n\n#define MRVDRV_MIN_PKT_LEN\t30\n\nstatic inline void process_cmdtypedata(int recvlength, struct sk_buff *skb,\n\t\t\t\t       struct if_usb_card *cardp,\n\t\t\t\t       struct lbs_private *priv)\n{\n\tif (recvlength > MRVDRV_ETH_RX_PACKET_BUFFER_SIZE + MESSAGE_HEADER_LEN\n\t    || recvlength < MRVDRV_MIN_PKT_LEN) {\n\t\tlbs_deb_usbd(&cardp->udev->dev, \"Packet length is Invalid\\n\");\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tskb_reserve(skb, IPFIELD_ALIGN_OFFSET);\n\tskb_put(skb, recvlength);\n\tskb_pull(skb, MESSAGE_HEADER_LEN);\n\n\tlbs_process_rxed_packet(priv, skb);\n}\n\nstatic inline void process_cmdrequest(int recvlength, uint8_t *recvbuff,\n\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t      struct if_usb_card *cardp,\n\t\t\t\t      struct lbs_private *priv)\n{\n\tunsigned long flags;\n\tu8 i;\n\n\tif (recvlength > LBS_CMD_BUFFER_SIZE) {\n\t\tlbs_deb_usbd(&cardp->udev->dev,\n\t\t\t     \"The receive buffer is too large\\n\");\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&priv->driver_lock, flags);\n\n\ti = (priv->resp_idx == 0) ? 1 : 0;\n\tBUG_ON(priv->resp_len[i]);\n\tpriv->resp_len[i] = (recvlength - MESSAGE_HEADER_LEN);\n\tmemcpy(priv->resp_buf[i], recvbuff + MESSAGE_HEADER_LEN,\n\t\tpriv->resp_len[i]);\n\tdev_kfree_skb_irq(skb);\n\tlbs_notify_command_response(priv, i);\n\n\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\n\tlbs_deb_usbd(&cardp->udev->dev,\n\t\t    \"Wake up main thread to handle cmd response\\n\");\n}\n\n \nstatic void if_usb_receive(struct urb *urb)\n{\n\tstruct if_usb_card *cardp = urb->context;\n\tstruct sk_buff *skb = cardp->rx_skb;\n\tstruct lbs_private *priv = cardp->priv;\n\tint recvlength = urb->actual_length;\n\tuint8_t *recvbuff = NULL;\n\tuint32_t recvtype = 0;\n\t__le32 *pkt = (__le32 *)(skb->data + IPFIELD_ALIGN_OFFSET);\n\tuint32_t event;\n\n\tif (recvlength) {\n\t\tif (urb->status) {\n\t\t\tlbs_deb_usbd(&cardp->udev->dev, \"RX URB failed: %d\\n\",\n\t\t\t\t     urb->status);\n\t\t\tkfree_skb(skb);\n\t\t\tgoto setup_for_next;\n\t\t}\n\n\t\trecvbuff = skb->data + IPFIELD_ALIGN_OFFSET;\n\t\trecvtype = le32_to_cpu(pkt[0]);\n\t\tlbs_deb_usbd(&cardp->udev->dev,\n\t\t\t    \"Recv length = 0x%x, Recv type = 0x%X\\n\",\n\t\t\t    recvlength, recvtype);\n\t} else if (urb->status) {\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tswitch (recvtype) {\n\tcase CMD_TYPE_DATA:\n\t\tprocess_cmdtypedata(recvlength, skb, cardp, priv);\n\t\tbreak;\n\n\tcase CMD_TYPE_REQUEST:\n\t\tprocess_cmdrequest(recvlength, recvbuff, skb, cardp, priv);\n\t\tbreak;\n\n\tcase CMD_TYPE_INDICATION:\n\t\t \n\t\tevent = le32_to_cpu(pkt[1]);\n\t\tlbs_deb_usbd(&cardp->udev->dev, \"**EVENT** 0x%X\\n\", event);\n\t\tkfree_skb(skb);\n\n\t\t \n\t\tif (event & 0xffff0000) {\n\t\t\tu32 trycount = (event & 0xffff0000) >> 16;\n\n\t\t\tlbs_send_tx_feedback(priv, trycount);\n\t\t} else\n\t\t\tlbs_queue_event(priv, event & 0xFF);\n\t\tbreak;\n\n\tdefault:\n\t\tlbs_deb_usbd(&cardp->udev->dev, \"Unknown command type 0x%X\\n\",\n\t\t\t     recvtype);\n\t\tkfree_skb(skb);\n\t\tbreak;\n\t}\n\nsetup_for_next:\n\tif_usb_submit_rx_urb(cardp);\n}\n\n \nstatic int if_usb_host_to_card(struct lbs_private *priv, uint8_t type,\n\t\t\t       uint8_t *payload, uint16_t nb)\n{\n\tstruct if_usb_card *cardp = priv->card;\n\n\tlbs_deb_usbd(&cardp->udev->dev,\"*** type = %u\\n\", type);\n\tlbs_deb_usbd(&cardp->udev->dev,\"size after = %d\\n\", nb);\n\n\tif (type == MVMS_CMD) {\n\t\t*(__le32 *)cardp->ep_out_buf = cpu_to_le32(CMD_TYPE_REQUEST);\n\t\tpriv->dnld_sent = DNLD_CMD_SENT;\n\t} else {\n\t\t*(__le32 *)cardp->ep_out_buf = cpu_to_le32(CMD_TYPE_DATA);\n\t\tpriv->dnld_sent = DNLD_DATA_SENT;\n\t}\n\n\tmemcpy((cardp->ep_out_buf + MESSAGE_HEADER_LEN), payload, nb);\n\n\treturn usb_tx_block(cardp, cardp->ep_out_buf, nb + MESSAGE_HEADER_LEN);\n}\n\n \nstatic int if_usb_issue_boot_command(struct if_usb_card *cardp, int ivalue)\n{\n\tstruct bootcmd *bootcmd = cardp->ep_out_buf;\n\n\t \n\tbootcmd->magic = cpu_to_le32(BOOT_CMD_MAGIC_NUMBER);\n\tbootcmd->cmd = ivalue;\n\tmemset(bootcmd->pad, 0, sizeof(bootcmd->pad));\n\n\t \n\tusb_tx_block(cardp, cardp->ep_out_buf, sizeof(*bootcmd));\n\n\treturn 0;\n}\n\n\n \nstatic int check_fwfile_format(const uint8_t *data, uint32_t totlen)\n{\n\tuint32_t bincmd, exit;\n\tuint32_t blksize, offset, len;\n\tint ret;\n\n\tret = 1;\n\texit = len = 0;\n\n\tdo {\n\t\tstruct fwheader *fwh = (void *)data;\n\n\t\tbincmd = le32_to_cpu(fwh->dnldcmd);\n\t\tblksize = le32_to_cpu(fwh->datalength);\n\t\tswitch (bincmd) {\n\t\tcase FW_HAS_DATA_TO_RECV:\n\t\t\toffset = sizeof(struct fwheader) + blksize;\n\t\t\tdata += offset;\n\t\t\tlen += offset;\n\t\t\tif (len >= totlen)\n\t\t\t\texit = 1;\n\t\t\tbreak;\n\t\tcase FW_HAS_LAST_BLOCK:\n\t\t\texit = 1;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\texit = 1;\n\t\t\tbreak;\n\t\t}\n\t} while (!exit);\n\n\tif (ret)\n\t\tpr_err(\"firmware file format check FAIL\\n\");\n\telse\n\t\tlbs_deb_fw(\"firmware file format check PASS\\n\");\n\n\treturn ret;\n}\n\nstatic void if_usb_prog_firmware(struct lbs_private *priv, int ret,\n\t\t\t\t const struct firmware *fw,\n\t\t\t\t const struct firmware *unused)\n{\n\tstruct if_usb_card *cardp = priv->card;\n\tint i = 0;\n\tstatic int reset_count = 10;\n\n\tif (ret) {\n\t\tpr_err(\"failed to find firmware (%d)\\n\", ret);\n\t\tgoto done;\n\t}\n\n\tcardp->fw = fw;\n\tif (check_fwfile_format(cardp->fw->data, cardp->fw->size)) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\t \n\tusb_kill_urb(cardp->rx_urb);\n\tusb_kill_urb(cardp->tx_urb);\n\n\tcardp->fwlastblksent = 0;\n\tcardp->fwdnldover = 0;\n\tcardp->totalbytes = 0;\n\tcardp->fwfinalblk = 0;\n\tcardp->bootcmdresp = 0;\n\nrestart:\n\tif (if_usb_submit_rx_urb_fwload(cardp) < 0) {\n\t\tlbs_deb_usbd(&cardp->udev->dev, \"URB submission is failed\\n\");\n\t\tret = -EIO;\n\t\tgoto done;\n\t}\n\n\tcardp->bootcmdresp = 0;\n\tdo {\n\t\tint j = 0;\n\t\ti++;\n\t\tif_usb_issue_boot_command(cardp, BOOT_CMD_FW_BY_USB);\n\t\t \n\t\tdo {\n\t\t\tj++;\n\t\t\tmsleep_interruptible(100);\n\t\t} while (cardp->bootcmdresp == 0 && j < 10);\n\t} while (cardp->bootcmdresp == 0 && i < 5);\n\n\tif (cardp->bootcmdresp == BOOT_CMD_RESP_NOT_SUPPORTED) {\n\t\t \n\t\tret = -EOPNOTSUPP;\n\t\tusb_kill_urb(cardp->rx_urb);\n\t\tusb_kill_urb(cardp->tx_urb);\n\t\tif (if_usb_submit_rx_urb(cardp) < 0)\n\t\t\tret = -EIO;\n\t\tgoto done;\n\t} else if (cardp->bootcmdresp <= 0) {\n\t\tif (--reset_count >= 0) {\n\t\t\tif_usb_reset_device(cardp);\n\t\t\tgoto restart;\n\t\t}\n\t\tret = -EIO;\n\t\tgoto done;\n\t}\n\n\ti = 0;\n\n\tcardp->totalbytes = 0;\n\tcardp->fwlastblksent = 0;\n\tcardp->CRC_OK = 1;\n\tcardp->fwdnldover = 0;\n\tcardp->fwseqnum = -1;\n\tcardp->totalbytes = 0;\n\tcardp->fwfinalblk = 0;\n\n\t \n\tif_usb_send_fw_pkt(cardp);\n\n\t \n\twait_event_interruptible(cardp->fw_wq, cardp->surprise_removed || cardp->fwdnldover);\n\n\tdel_timer_sync(&cardp->fw_timeout);\n\tusb_kill_urb(cardp->rx_urb);\n\n\tif (!cardp->fwdnldover) {\n\t\tpr_info(\"failed to load fw, resetting device!\\n\");\n\t\tif (--reset_count >= 0) {\n\t\t\tif_usb_reset_device(cardp);\n\t\t\tgoto restart;\n\t\t}\n\n\t\tpr_info(\"FW download failure, time = %d ms\\n\", i * 100);\n\t\tret = -EIO;\n\t\tgoto done;\n\t}\n\n\tcardp->priv->fw_ready = 1;\n\tif_usb_submit_rx_urb(cardp);\n\n\tif (lbs_start_card(priv))\n\t\tgoto done;\n\n\tif_usb_setup_firmware(priv);\n\n\t \n\tpriv->wol_criteria = EHS_REMOVE_WAKEUP;\n\tif (lbs_host_sleep_cfg(priv, priv->wol_criteria, NULL))\n\t\tpriv->ehs_remove_supported = false;\n\n done:\n\tcardp->fw = NULL;\n}\n\n\n#ifdef CONFIG_PM\nstatic int if_usb_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct if_usb_card *cardp = usb_get_intfdata(intf);\n\tstruct lbs_private *priv = cardp->priv;\n\tint ret;\n\n\tif (priv->psstate != PS_STATE_FULL_POWER) {\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\n#ifdef CONFIG_OLPC\n\tif (machine_is_olpc()) {\n\t\tif (priv->wol_criteria == EHS_REMOVE_WAKEUP)\n\t\t\tolpc_ec_wakeup_clear(EC_SCI_SRC_WLAN);\n\t\telse\n\t\t\tolpc_ec_wakeup_set(EC_SCI_SRC_WLAN);\n\t}\n#endif\n\n\tret = lbs_suspend(priv);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tusb_kill_urb(cardp->tx_urb);\n\tusb_kill_urb(cardp->rx_urb);\n\n out:\n\treturn ret;\n}\n\nstatic int if_usb_resume(struct usb_interface *intf)\n{\n\tstruct if_usb_card *cardp = usb_get_intfdata(intf);\n\tstruct lbs_private *priv = cardp->priv;\n\n\tif_usb_submit_rx_urb(cardp);\n\n\tlbs_resume(priv);\n\n\treturn 0;\n}\n#else\n#define if_usb_suspend NULL\n#define if_usb_resume NULL\n#endif\n\nstatic struct usb_driver if_usb_driver = {\n\t.name = DRV_NAME,\n\t.probe = if_usb_probe,\n\t.disconnect = if_usb_disconnect,\n\t.id_table = if_usb_table,\n\t.suspend = if_usb_suspend,\n\t.resume = if_usb_resume,\n\t.reset_resume = if_usb_resume,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(if_usb_driver);\n\nMODULE_DESCRIPTION(\"8388 USB WLAN Driver\");\nMODULE_AUTHOR(\"Marvell International Ltd. and Red Hat, Inc.\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}