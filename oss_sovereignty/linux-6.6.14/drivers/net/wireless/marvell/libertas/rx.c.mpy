{
  "module_name": "rx.c",
  "hash_id": "245b0a3d2dc2b49089f0c9432a4ff37568fd240ca9df64eb54a6903f1231e599",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/marvell/libertas/rx.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/etherdevice.h>\n#include <linux/hardirq.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <net/cfg80211.h>\n\n#include \"defs.h\"\n#include \"host.h\"\n#include \"radiotap.h\"\n#include \"decl.h\"\n#include \"dev.h\"\n#include \"mesh.h\"\n\nstruct eth803hdr {\n\tu8 dest_addr[6];\n\tu8 src_addr[6];\n\tu16 h803_len;\n} __packed;\n\nstruct rfc1042hdr {\n\tu8 llc_dsap;\n\tu8 llc_ssap;\n\tu8 llc_ctrl;\n\tu8 snap_oui[3];\n\tu16 snap_type;\n} __packed;\n\nstruct rxpackethdr {\n\tstruct eth803hdr eth803_hdr;\n\tstruct rfc1042hdr rfc1042_hdr;\n} __packed;\n\nstruct rx80211packethdr {\n\tstruct rxpd rx_pd;\n\tvoid *eth80211_hdr;\n} __packed;\n\nstatic int process_rxed_802_11_packet(struct lbs_private *priv,\n\tstruct sk_buff *skb);\n\n \nint lbs_process_rxed_packet(struct lbs_private *priv, struct sk_buff *skb)\n{\n\tint ret = 0;\n\tstruct net_device *dev = priv->dev;\n\tstruct rxpackethdr *p_rx_pkt;\n\tstruct rxpd *p_rx_pd;\n\tint hdrchop;\n\tstruct ethhdr *p_ethhdr;\n\n\tBUG_ON(!skb);\n\n\tskb->ip_summed = CHECKSUM_NONE;\n\n\tif (priv->wdev->iftype == NL80211_IFTYPE_MONITOR) {\n\t\tret = process_rxed_802_11_packet(priv, skb);\n\t\tgoto done;\n\t}\n\n\tp_rx_pd = (struct rxpd *) skb->data;\n\tp_rx_pkt = (struct rxpackethdr *) ((u8 *)p_rx_pd +\n\t\tle32_to_cpu(p_rx_pd->pkt_ptr));\n\n\tdev = lbs_mesh_set_dev(priv, dev, p_rx_pd);\n\n\tlbs_deb_hex(LBS_DEB_RX, \"RX Data: Before chop rxpd\", skb->data,\n\t\t min_t(unsigned int, skb->len, 100));\n\n\tif (skb->len < (ETH_HLEN + 8 + sizeof(struct rxpd))) {\n\t\tlbs_deb_rx(\"rx err: frame received with bad length\\n\");\n\t\tdev->stats.rx_length_errors++;\n\t\tret = -EINVAL;\n\t\tdev_kfree_skb(skb);\n\t\tgoto done;\n\t}\n\n\tlbs_deb_rx(\"rx data: skb->len - pkt_ptr = %d-%zd = %zd\\n\",\n\t\tskb->len, (size_t)le32_to_cpu(p_rx_pd->pkt_ptr),\n\t\tskb->len - (size_t)le32_to_cpu(p_rx_pd->pkt_ptr));\n\n\tlbs_deb_hex(LBS_DEB_RX, \"RX Data: Dest\", p_rx_pkt->eth803_hdr.dest_addr,\n\t\tsizeof(p_rx_pkt->eth803_hdr.dest_addr));\n\tlbs_deb_hex(LBS_DEB_RX, \"RX Data: Src\", p_rx_pkt->eth803_hdr.src_addr,\n\t\tsizeof(p_rx_pkt->eth803_hdr.src_addr));\n\n\tif (memcmp(&p_rx_pkt->rfc1042_hdr,\n\t\t   rfc1042_header, sizeof(rfc1042_header)) == 0) {\n\t\t \n\t\tp_ethhdr = (struct ethhdr *)\n\t\t    ((u8 *) &p_rx_pkt->eth803_hdr\n\t\t     + sizeof(p_rx_pkt->eth803_hdr) + sizeof(p_rx_pkt->rfc1042_hdr)\n\t\t     - sizeof(p_rx_pkt->eth803_hdr.dest_addr)\n\t\t     - sizeof(p_rx_pkt->eth803_hdr.src_addr)\n\t\t     - sizeof(p_rx_pkt->rfc1042_hdr.snap_type));\n\n\t\tmemcpy(p_ethhdr->h_source, p_rx_pkt->eth803_hdr.src_addr,\n\t\t       sizeof(p_ethhdr->h_source));\n\t\tmemcpy(p_ethhdr->h_dest, p_rx_pkt->eth803_hdr.dest_addr,\n\t\t       sizeof(p_ethhdr->h_dest));\n\n\t\t \n\t\thdrchop = (u8 *)p_ethhdr - (u8 *)p_rx_pd;\n\t} else {\n\t\tlbs_deb_hex(LBS_DEB_RX, \"RX Data: LLC/SNAP\",\n\t\t\t(u8 *) &p_rx_pkt->rfc1042_hdr,\n\t\t\tsizeof(p_rx_pkt->rfc1042_hdr));\n\n\t\t \n\t\thdrchop = (u8 *)&p_rx_pkt->eth803_hdr - (u8 *)p_rx_pd;\n\t}\n\n\t \n\tskb_pull(skb, hdrchop);\n\n\tpriv->cur_rate = lbs_fw_index_to_data_rate(p_rx_pd->rx_rate);\n\n\tlbs_deb_rx(\"rx data: size of actual packet %d\\n\", skb->len);\n\tdev->stats.rx_bytes += skb->len;\n\tdev->stats.rx_packets++;\n\n\tskb->protocol = eth_type_trans(skb, dev);\n\tnetif_rx(skb);\n\n\tret = 0;\ndone:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(lbs_process_rxed_packet);\n\n \nstatic u8 convert_mv_rate_to_radiotap(u8 rate)\n{\n\tswitch (rate) {\n\tcase 0:\t\t \n\t\treturn 2;\n\tcase 1:\t\t \n\t\treturn 4;\n\tcase 2:\t\t \n\t\treturn 11;\n\tcase 3:\t\t \n\t\treturn 22;\n\t \n\tcase 5:\t\t \n\t\treturn 12;\n\tcase 6:\t\t \n\t\treturn 18;\n\tcase 7:\t\t \n\t\treturn 24;\n\tcase 8:\t\t \n\t\treturn 36;\n\tcase 9:\t\t \n\t\treturn 48;\n\tcase 10:\t\t \n\t\treturn 72;\n\tcase 11:\t\t \n\t\treturn 96;\n\tcase 12:\t\t \n\t\treturn 108;\n\t}\n\tpr_alert(\"Invalid Marvell WLAN rate %i\\n\", rate);\n\treturn 0;\n}\n\n \nstatic int process_rxed_802_11_packet(struct lbs_private *priv,\n\tstruct sk_buff *skb)\n{\n\tint ret = 0;\n\tstruct net_device *dev = priv->dev;\n\tstruct rx80211packethdr *p_rx_pkt;\n\tstruct rxpd *prxpd;\n\tstruct rx_radiotap_hdr radiotap_hdr;\n\tstruct rx_radiotap_hdr *pradiotap_hdr;\n\n\tp_rx_pkt = (struct rx80211packethdr *) skb->data;\n\tprxpd = &p_rx_pkt->rx_pd;\n\n\t \n\n\tif (skb->len < (ETH_HLEN + 8 + sizeof(struct rxpd))) {\n\t\tlbs_deb_rx(\"rx err: frame received with bad length\\n\");\n\t\tdev->stats.rx_length_errors++;\n\t\tret = -EINVAL;\n\t\tkfree_skb(skb);\n\t\tgoto done;\n\t}\n\n\tlbs_deb_rx(\"rx data: skb->len-sizeof(RxPd) = %d-%zd = %zd\\n\",\n\t       skb->len, sizeof(struct rxpd), skb->len - sizeof(struct rxpd));\n\n\t \n\n\t \n\tmemset(&radiotap_hdr, 0, sizeof(radiotap_hdr));\n\t \n\tradiotap_hdr.hdr.it_len = cpu_to_le16 (sizeof(struct rx_radiotap_hdr));\n\tradiotap_hdr.hdr.it_present = cpu_to_le32 (RX_RADIOTAP_PRESENT);\n\tradiotap_hdr.rate = convert_mv_rate_to_radiotap(prxpd->rx_rate);\n\t \n\tradiotap_hdr.antsignal = prxpd->snr + prxpd->nf;\n\n\t \n\tskb_pull(skb, sizeof(struct rxpd));\n\n\t \n\tif ((skb_headroom(skb) < sizeof(struct rx_radiotap_hdr)) &&\n\t    pskb_expand_head(skb, sizeof(struct rx_radiotap_hdr), 0, GFP_ATOMIC)) {\n\t\tnetdev_alert(dev, \"%s: couldn't pskb_expand_head\\n\", __func__);\n\t\tret = -ENOMEM;\n\t\tkfree_skb(skb);\n\t\tgoto done;\n\t}\n\n\tpradiotap_hdr = skb_push(skb, sizeof(struct rx_radiotap_hdr));\n\tmemcpy(pradiotap_hdr, &radiotap_hdr, sizeof(struct rx_radiotap_hdr));\n\n\tpriv->cur_rate = lbs_fw_index_to_data_rate(prxpd->rx_rate);\n\n\tlbs_deb_rx(\"rx data: size of actual packet %d\\n\", skb->len);\n\tdev->stats.rx_bytes += skb->len;\n\tdev->stats.rx_packets++;\n\n\tskb->protocol = eth_type_trans(skb, priv->dev);\n\tnetif_rx(skb);\n\n\tret = 0;\n\ndone:\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}