{
  "module_name": "if_spi.c",
  "hash_id": "b29ef9d1f54f13c301d5c9f0d2336ee96b7910046ed32de374ef1e4e4672c661",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/marvell/libertas/if_spi.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/hardirq.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/firmware.h>\n#include <linux/jiffies.h>\n#include <linux/list.h>\n#include <linux/netdevice.h>\n#include <linux/slab.h>\n#include <linux/spi/libertas_spi.h>\n#include <linux/spi/spi.h>\n\n#include \"host.h\"\n#include \"decl.h\"\n#include \"defs.h\"\n#include \"dev.h\"\n#include \"if_spi.h\"\n\nstruct if_spi_packet {\n\tstruct list_head\t\tlist;\n\tu16\t\t\t\tblen;\n\tu8\t\t\t\tbuffer[] __aligned(4);\n};\n\nstruct if_spi_card {\n\tstruct spi_device\t\t*spi;\n\tstruct lbs_private\t\t*priv;\n\tstruct libertas_spi_platform_data *pdata;\n\n\t \n\tu16\t\t\t\tcard_id;\n\tu8\t\t\t\tcard_rev;\n\n\t \n\tunsigned long\t\t\tprev_xfer_time;\n\n\tint\t\t\t\tuse_dummy_writes;\n\tunsigned long\t\t\tspu_port_delay;\n\tunsigned long\t\t\tspu_reg_delay;\n\n\t \n\tstruct workqueue_struct\t\t*workqueue;\n\tstruct work_struct\t\tpacket_work;\n\tstruct work_struct\t\tresume_work;\n\n\tu8\t\t\t\tcmd_buffer[IF_SPI_CMD_BUF_SIZE];\n\n\t \n\tstruct list_head\t\tcmd_packet_list;\n\tstruct list_head\t\tdata_packet_list;\n\n\t \n\tspinlock_t\t\t\tbuffer_lock;\n\n\t \n\tu8\t\t\t\tsuspended;\n};\n\nstatic void free_if_spi_card(struct if_spi_card *card)\n{\n\tstruct if_spi_packet *packet, *tmp;\n\n\tlist_for_each_entry_safe(packet, tmp, &card->cmd_packet_list, list) {\n\t\tlist_del(&packet->list);\n\t\tkfree(packet);\n\t}\n\tlist_for_each_entry_safe(packet, tmp, &card->data_packet_list, list) {\n\t\tlist_del(&packet->list);\n\t\tkfree(packet);\n\t}\n\tkfree(card);\n}\n\n#define MODEL_8385\t0x04\n#define MODEL_8686\t0x0b\n#define MODEL_8688\t0x10\n\nstatic const struct lbs_fw_table fw_table[] = {\n\t{ MODEL_8385, \"libertas/gspi8385_helper.bin\", \"libertas/gspi8385.bin\" },\n\t{ MODEL_8385, \"libertas/gspi8385_hlp.bin\", \"libertas/gspi8385.bin\" },\n\t{ MODEL_8686, \"libertas/gspi8686_v9_helper.bin\", \"libertas/gspi8686_v9.bin\" },\n\t{ MODEL_8686, \"libertas/gspi8686_hlp.bin\", \"libertas/gspi8686.bin\" },\n\t{ MODEL_8688, \"libertas/gspi8688_helper.bin\", \"libertas/gspi8688.bin\" },\n\t{ 0, NULL, NULL }\n};\nMODULE_FIRMWARE(\"libertas/gspi8385_helper.bin\");\nMODULE_FIRMWARE(\"libertas/gspi8385_hlp.bin\");\nMODULE_FIRMWARE(\"libertas/gspi8385.bin\");\nMODULE_FIRMWARE(\"libertas/gspi8686_v9_helper.bin\");\nMODULE_FIRMWARE(\"libertas/gspi8686_v9.bin\");\nMODULE_FIRMWARE(\"libertas/gspi8686_hlp.bin\");\nMODULE_FIRMWARE(\"libertas/gspi8686.bin\");\nMODULE_FIRMWARE(\"libertas/gspi8688_helper.bin\");\nMODULE_FIRMWARE(\"libertas/gspi8688.bin\");\n\n\n \n\nstatic void spu_transaction_init(struct if_spi_card *card)\n{\n\tif (!time_after(jiffies, card->prev_xfer_time + 1)) {\n\t\t \n\t\tndelay(400);\n\t}\n}\n\nstatic void spu_transaction_finish(struct if_spi_card *card)\n{\n\tcard->prev_xfer_time = jiffies;\n}\n\n \nstatic int spu_write(struct if_spi_card *card, u16 reg, const u8 *buf, int len)\n{\n\tint err = 0;\n\t__le16 reg_out = cpu_to_le16(reg | IF_SPI_WRITE_OPERATION_MASK);\n\tstruct spi_message m;\n\tstruct spi_transfer reg_trans;\n\tstruct spi_transfer data_trans;\n\n\tspi_message_init(&m);\n\tmemset(&reg_trans, 0, sizeof(reg_trans));\n\tmemset(&data_trans, 0, sizeof(data_trans));\n\n\t \n\tBUG_ON(len & 0x1);\n\n\tspu_transaction_init(card);\n\n\t \n\treg_trans.tx_buf = &reg_out;\n\treg_trans.len = sizeof(reg_out);\n\n\tdata_trans.tx_buf = buf;\n\tdata_trans.len = len;\n\n\tspi_message_add_tail(&reg_trans, &m);\n\tspi_message_add_tail(&data_trans, &m);\n\n\terr = spi_sync(card->spi, &m);\n\tspu_transaction_finish(card);\n\treturn err;\n}\n\nstatic inline int spu_write_u16(struct if_spi_card *card, u16 reg, u16 val)\n{\n\t__le16 buff;\n\n\tbuff = cpu_to_le16(val);\n\treturn spu_write(card, reg, (u8 *)&buff, sizeof(u16));\n}\n\nstatic inline int spu_reg_is_port_reg(u16 reg)\n{\n\tswitch (reg) {\n\tcase IF_SPI_IO_RDWRPORT_REG:\n\tcase IF_SPI_CMD_RDWRPORT_REG:\n\tcase IF_SPI_DATA_RDWRPORT_REG:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int spu_read(struct if_spi_card *card, u16 reg, u8 *buf, int len)\n{\n\tunsigned int delay;\n\tint err = 0;\n\t__le16 reg_out = cpu_to_le16(reg | IF_SPI_READ_OPERATION_MASK);\n\tstruct spi_message m;\n\tstruct spi_transfer reg_trans;\n\tstruct spi_transfer dummy_trans;\n\tstruct spi_transfer data_trans;\n\n\t \n\tBUG_ON(len & 0x1);\n\n\tspu_transaction_init(card);\n\n\tspi_message_init(&m);\n\tmemset(&reg_trans, 0, sizeof(reg_trans));\n\tmemset(&dummy_trans, 0, sizeof(dummy_trans));\n\tmemset(&data_trans, 0, sizeof(data_trans));\n\n\t \n\treg_trans.tx_buf = &reg_out;\n\treg_trans.len = sizeof(reg_out);\n\tspi_message_add_tail(&reg_trans, &m);\n\n\tdelay = spu_reg_is_port_reg(reg) ? card->spu_port_delay :\n\t\t\t\t\t\tcard->spu_reg_delay;\n\tif (card->use_dummy_writes) {\n\t\t \n\t\tdummy_trans.len = delay / 8;\n\t\tspi_message_add_tail(&dummy_trans, &m);\n\t} else {\n\t\t \n\t\treg_trans.delay.value =\n\t\t\tDIV_ROUND_UP((100 + (delay * 10)), 1000);\n\t\treg_trans.delay.unit = SPI_DELAY_UNIT_USECS;\n\t}\n\n\t \n\tdata_trans.rx_buf = buf;\n\tdata_trans.len = len;\n\tspi_message_add_tail(&data_trans, &m);\n\n\terr = spi_sync(card->spi, &m);\n\tspu_transaction_finish(card);\n\treturn err;\n}\n\n \nstatic inline int spu_read_u16(struct if_spi_card *card, u16 reg, u16 *val)\n{\n\t__le16 buf;\n\tint ret;\n\n\tret = spu_read(card, reg, (u8 *)&buf, sizeof(buf));\n\tif (ret == 0)\n\t\t*val = le16_to_cpup(&buf);\n\treturn ret;\n}\n\n \nstatic int spu_read_u32(struct if_spi_card *card, u16 reg, u32 *val)\n{\n\t__le32 buf;\n\tint err;\n\n\terr = spu_read(card, reg, (u8 *)&buf, sizeof(buf));\n\tif (!err)\n\t\t*val = le32_to_cpup(&buf);\n\treturn err;\n}\n\n \nstatic int spu_wait_for_u16(struct if_spi_card *card, u16 reg,\n\t\t\tu16 target_mask, u16 target)\n{\n\tint err;\n\tunsigned long timeout = jiffies + 5*HZ;\n\twhile (1) {\n\t\tu16 val;\n\t\terr = spu_read_u16(card, reg, &val);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (target_mask) {\n\t\t\tif ((val & target_mask) == target)\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (val)\n\t\t\t\treturn 0;\n\t\t}\n\t\tudelay(100);\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tpr_err(\"%s: timeout with val=%02x, target_mask=%02x, target=%02x\\n\",\n\t\t\t       __func__, val, target_mask, target);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t}\n}\n\n \nstatic int spu_wait_for_u32(struct if_spi_card *card, u32 reg, u32 target)\n{\n\tint err, try;\n\tfor (try = 0; try < 4; ++try) {\n\t\tu32 val = 0;\n\t\terr = spu_read_u32(card, reg, &val);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (val == target)\n\t\t\treturn 0;\n\t\tmdelay(100);\n\t}\n\treturn -ETIMEDOUT;\n}\n\nstatic int spu_set_interrupt_mode(struct if_spi_card *card,\n\t\t\t   int suppress_host_int,\n\t\t\t   int auto_int)\n{\n\tint err = 0;\n\n\t \n\tif (suppress_host_int) {\n\t\terr = spu_write_u16(card, IF_SPI_HOST_INT_STATUS_MASK_REG, 0);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\terr = spu_write_u16(card, IF_SPI_HOST_INT_STATUS_MASK_REG,\n\t\t\t      IF_SPI_HISM_TX_DOWNLOAD_RDY |\n\t\t\t      IF_SPI_HISM_RX_UPLOAD_RDY |\n\t\t\t      IF_SPI_HISM_CMD_DOWNLOAD_RDY |\n\t\t\t      IF_SPI_HISM_CARDEVENT |\n\t\t\t      IF_SPI_HISM_CMD_UPLOAD_RDY);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (auto_int) {\n\t\terr = spu_write_u16(card, IF_SPI_HOST_INT_CTRL_REG,\n\t\t\t\tIF_SPI_HICT_TX_DOWNLOAD_OVER_AUTO |\n\t\t\t\tIF_SPI_HICT_RX_UPLOAD_OVER_AUTO |\n\t\t\t\tIF_SPI_HICT_CMD_DOWNLOAD_OVER_AUTO |\n\t\t\t\tIF_SPI_HICT_CMD_UPLOAD_OVER_AUTO);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\terr = spu_write_u16(card, IF_SPI_HOST_INT_STATUS_MASK_REG, 0);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\treturn err;\n}\n\nstatic int spu_get_chip_revision(struct if_spi_card *card,\n\t\t\t\t  u16 *card_id, u8 *card_rev)\n{\n\tint err = 0;\n\tu32 dev_ctrl;\n\terr = spu_read_u32(card, IF_SPI_DEVICEID_CTRL_REG, &dev_ctrl);\n\tif (err)\n\t\treturn err;\n\t*card_id = IF_SPI_DEVICEID_CTRL_REG_TO_CARD_ID(dev_ctrl);\n\t*card_rev = IF_SPI_DEVICEID_CTRL_REG_TO_CARD_REV(dev_ctrl);\n\treturn err;\n}\n\nstatic int spu_set_bus_mode(struct if_spi_card *card, u16 mode)\n{\n\tint err = 0;\n\tu16 rval;\n\t \n\terr = spu_write_u16(card, IF_SPI_SPU_BUS_MODE_REG, mode);\n\tif (err)\n\t\treturn err;\n\t \n\terr = spu_read_u16(card, IF_SPI_SPU_BUS_MODE_REG, &rval);\n\tif (err)\n\t\treturn err;\n\tif ((rval & 0xF) != mode) {\n\t\tpr_err(\"Can't read bus mode register\\n\");\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\nstatic int spu_init(struct if_spi_card *card, int use_dummy_writes)\n{\n\tint err = 0;\n\tu32 delay;\n\n\t \n\tcard->use_dummy_writes = 0;\n\terr = spu_set_bus_mode(card,\n\t\t\t\tIF_SPI_BUS_MODE_SPI_CLOCK_PHASE_RISING |\n\t\t\t\tIF_SPI_BUS_MODE_DELAY_METHOD_TIMED |\n\t\t\t\tIF_SPI_BUS_MODE_16_BIT_ADDRESS_16_BIT_DATA);\n\tif (err)\n\t\treturn err;\n\tcard->spu_port_delay = 1000;\n\tcard->spu_reg_delay = 1000;\n\terr = spu_read_u32(card, IF_SPI_DELAY_READ_REG, &delay);\n\tif (err)\n\t\treturn err;\n\tcard->spu_port_delay = delay & 0x0000ffff;\n\tcard->spu_reg_delay = (delay & 0xffff0000) >> 16;\n\n\t \n\tif (use_dummy_writes) {\n\t\tcard->use_dummy_writes = 1;\n\t\terr = spu_set_bus_mode(card,\n\t\t\t\tIF_SPI_BUS_MODE_SPI_CLOCK_PHASE_RISING |\n\t\t\t\tIF_SPI_BUS_MODE_DELAY_METHOD_DUMMY_CLOCK |\n\t\t\t\tIF_SPI_BUS_MODE_16_BIT_ADDRESS_16_BIT_DATA);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tlbs_deb_spi(\"Initialized SPU unit. \"\n\t\t    \"spu_port_delay=0x%04lx, spu_reg_delay=0x%04lx\\n\",\n\t\t    card->spu_port_delay, card->spu_reg_delay);\n\treturn err;\n}\n\n \n\nstatic int if_spi_prog_helper_firmware(struct if_spi_card *card,\n\t\t\t\t\tconst struct firmware *firmware)\n{\n\tint err = 0;\n\tint bytes_remaining;\n\tconst u8 *fw;\n\tu8 temp[HELPER_FW_LOAD_CHUNK_SZ];\n\n\terr = spu_set_interrupt_mode(card, 1, 0);\n\tif (err)\n\t\tgoto out;\n\n\tbytes_remaining = firmware->size;\n\tfw = firmware->data;\n\n\t \n\twhile (bytes_remaining > 0) {\n\t\t \n\t\terr = spu_write_u16(card, IF_SPI_SCRATCH_1_REG,\n\t\t\t\t\tHELPER_FW_LOAD_CHUNK_SZ);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\terr = spu_wait_for_u16(card, IF_SPI_HOST_INT_STATUS_REG,\n\t\t\t\t\tIF_SPI_HIST_CMD_DOWNLOAD_RDY,\n\t\t\t\t\tIF_SPI_HIST_CMD_DOWNLOAD_RDY);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t \n\t\tmemset(temp, 0, sizeof(temp));\n\t\tmemcpy(temp, fw,\n\t\t       min(bytes_remaining, HELPER_FW_LOAD_CHUNK_SZ));\n\t\tmdelay(10);\n\t\terr = spu_write(card, IF_SPI_CMD_RDWRPORT_REG,\n\t\t\t\t\ttemp, HELPER_FW_LOAD_CHUNK_SZ);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t \n\t\terr = spu_write_u16(card, IF_SPI_HOST_INT_STATUS_REG, 0);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = spu_write_u16(card, IF_SPI_CARD_INT_CAUSE_REG,\n\t\t\t\t       IF_SPI_CIC_CMD_DOWNLOAD_OVER);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tbytes_remaining -= HELPER_FW_LOAD_CHUNK_SZ;\n\t\tfw += HELPER_FW_LOAD_CHUNK_SZ;\n\t}\n\n\t \n\terr = spu_write_u16(card, IF_SPI_SCRATCH_1_REG, FIRMWARE_DNLD_OK);\n\tif (err)\n\t\tgoto out;\n\terr = spu_write_u16(card, IF_SPI_HOST_INT_STATUS_REG, 0);\n\tif (err)\n\t\tgoto out;\n\terr = spu_write_u16(card, IF_SPI_CARD_INT_CAUSE_REG,\n\t\t\t\tIF_SPI_CIC_CMD_DOWNLOAD_OVER);\nout:\n\tif (err)\n\t\tpr_err(\"failed to load helper firmware (err=%d)\\n\", err);\n\n\treturn err;\n}\n\n \nstatic int if_spi_prog_main_firmware_check_len(struct if_spi_card *card,\n\t\t\t\t\t\tint *crc_err)\n{\n\tu16 len;\n\tint err = 0;\n\n\t \n\terr = spu_wait_for_u16(card, IF_SPI_HOST_INT_STATUS_REG,\n\t\t\t\tIF_SPI_HIST_CMD_DOWNLOAD_RDY,\n\t\t\t\tIF_SPI_HIST_CMD_DOWNLOAD_RDY);\n\tif (err) {\n\t\tpr_err(\"timed out waiting for host_int_status\\n\");\n\t\treturn err;\n\t}\n\n\t \n\terr = spu_read_u16(card, IF_SPI_SCRATCH_1_REG, &len);\n\tif (err)\n\t\treturn err;\n\n\tif (len > IF_SPI_CMD_BUF_SIZE) {\n\t\tpr_err(\"firmware load device requested a larger transfer than we are prepared to handle (len = %d)\\n\",\n\t\t       len);\n\t\treturn -EIO;\n\t}\n\tif (len & 0x1) {\n\t\tlbs_deb_spi(\"%s: crc error\\n\", __func__);\n\t\tlen &= ~0x1;\n\t\t*crc_err = 1;\n\t} else\n\t\t*crc_err = 0;\n\n\treturn len;\n}\n\nstatic int if_spi_prog_main_firmware(struct if_spi_card *card,\n\t\t\t\t\tconst struct firmware *firmware)\n{\n\tstruct lbs_private *priv = card->priv;\n\tint len, prev_len;\n\tint bytes, crc_err = 0, err = 0;\n\tconst u8 *fw;\n\tu16 num_crc_errs;\n\n\terr = spu_set_interrupt_mode(card, 1, 0);\n\tif (err)\n\t\tgoto out;\n\n\terr = spu_wait_for_u16(card, IF_SPI_SCRATCH_1_REG, 0, 0);\n\tif (err) {\n\t\tnetdev_err(priv->dev,\n\t\t\t   \"%s: timed out waiting for initial scratch reg = 0\\n\",\n\t\t\t   __func__);\n\t\tgoto out;\n\t}\n\n\tnum_crc_errs = 0;\n\tprev_len = 0;\n\tbytes = firmware->size;\n\tfw = firmware->data;\n\twhile ((len = if_spi_prog_main_firmware_check_len(card, &crc_err))) {\n\t\tif (len < 0) {\n\t\t\terr = len;\n\t\t\tgoto out;\n\t\t}\n\t\tif (bytes < 0) {\n\t\t\t \n\t\t\tnetdev_err(priv->dev,\n\t\t\t\t   \"Firmware load wants more bytes than we have to offer.\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (crc_err) {\n\t\t\t \n\t\t\tif (++num_crc_errs > MAX_MAIN_FW_LOAD_CRC_ERR) {\n\t\t\t\tpr_err(\"Too many CRC errors encountered in firmware load.\\n\");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tbytes -= prev_len;\n\t\t\tfw += prev_len;\n\t\t}\n\t\tif (bytes < len) {\n\t\t\tmemset(card->cmd_buffer, 0, len);\n\t\t\tmemcpy(card->cmd_buffer, fw, bytes);\n\t\t} else\n\t\t\tmemcpy(card->cmd_buffer, fw, len);\n\n\t\terr = spu_write_u16(card, IF_SPI_HOST_INT_STATUS_REG, 0);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = spu_write(card, IF_SPI_CMD_RDWRPORT_REG,\n\t\t\t\tcard->cmd_buffer, len);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = spu_write_u16(card, IF_SPI_CARD_INT_CAUSE_REG ,\n\t\t\t\t\tIF_SPI_CIC_CMD_DOWNLOAD_OVER);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tprev_len = len;\n\t}\n\tif (bytes > prev_len) {\n\t\tpr_err(\"firmware load wants fewer bytes than we have to offer\\n\");\n\t}\n\n\t \n\terr = spu_wait_for_u32(card, IF_SPI_SCRATCH_4_REG,\n\t\t\t\t\tSUCCESSFUL_FW_DOWNLOAD_MAGIC);\n\tif (err) {\n\t\tpr_err(\"failed to confirm the firmware download\\n\");\n\t\tgoto out;\n\t}\n\nout:\n\tif (err)\n\t\tpr_err(\"failed to load firmware (err=%d)\\n\", err);\n\n\treturn err;\n}\n\n \n\n \nstatic int if_spi_c2h_cmd(struct if_spi_card *card)\n{\n\tstruct lbs_private *priv = card->priv;\n\tunsigned long flags;\n\tint err = 0;\n\tu16 len;\n\tu8 i;\n\n\t \n\tBUILD_BUG_ON(IF_SPI_CMD_BUF_SIZE < LBS_CMD_BUFFER_SIZE);\n\tBUILD_BUG_ON(IF_SPI_CMD_BUF_SIZE < LBS_UPLD_SIZE);\n\n\t \n\tBUILD_BUG_ON(IF_SPI_CMD_BUF_SIZE % 4 != 0);\n\n\t \n\terr = spu_read_u16(card, IF_SPI_SCRATCH_2_REG, &len);\n\tif (err)\n\t\tgoto out;\n\tif (!len) {\n\t\tnetdev_err(priv->dev, \"%s: error: card has no data for host\\n\",\n\t\t\t   __func__);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t} else if (len > IF_SPI_CMD_BUF_SIZE) {\n\t\tnetdev_err(priv->dev,\n\t\t\t   \"%s: error: response packet too large: %d bytes, but maximum is %d\\n\",\n\t\t\t   __func__, len, IF_SPI_CMD_BUF_SIZE);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\terr = spu_read(card, IF_SPI_CMD_RDWRPORT_REG,\n\t\t\t\tcard->cmd_buffer, ALIGN(len, 4));\n\tif (err)\n\t\tgoto out;\n\n\tspin_lock_irqsave(&priv->driver_lock, flags);\n\ti = (priv->resp_idx == 0) ? 1 : 0;\n\tBUG_ON(priv->resp_len[i]);\n\tpriv->resp_len[i] = len;\n\tmemcpy(priv->resp_buf[i], card->cmd_buffer, len);\n\tlbs_notify_command_response(priv, i);\n\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\nout:\n\tif (err)\n\t\tnetdev_err(priv->dev, \"%s: err=%d\\n\", __func__, err);\n\n\treturn err;\n}\n\n \nstatic int if_spi_c2h_data(struct if_spi_card *card)\n{\n\tstruct lbs_private *priv = card->priv;\n\tstruct sk_buff *skb;\n\tchar *data;\n\tu16 len;\n\tint err = 0;\n\n\t \n\terr = spu_read_u16(card, IF_SPI_SCRATCH_1_REG, &len);\n\tif (err)\n\t\tgoto out;\n\tif (!len) {\n\t\tnetdev_err(priv->dev, \"%s: error: card has no data for host\\n\",\n\t\t\t   __func__);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t} else if (len > MRVDRV_ETH_RX_PACKET_BUFFER_SIZE) {\n\t\tnetdev_err(priv->dev,\n\t\t\t   \"%s: error: card has %d bytes of data, but our maximum skb size is %zu\\n\",\n\t\t\t   __func__, len, MRVDRV_ETH_RX_PACKET_BUFFER_SIZE);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tskb = dev_alloc_skb(MRVDRV_ETH_RX_PACKET_BUFFER_SIZE);\n\tif (!skb) {\n\t\terr = -ENOBUFS;\n\t\tgoto out;\n\t}\n\tskb_reserve(skb, IPFIELD_ALIGN_OFFSET);\n\tdata = skb_put(skb, len);\n\n\t \n\terr = spu_read(card, IF_SPI_DATA_RDWRPORT_REG, data, ALIGN(len, 4));\n\tif (err) {\n\t\tdev_kfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\t \n\terr = lbs_process_rxed_packet(card->priv, skb);\n\t \n\nout:\n\tif (err)\n\t\tnetdev_err(priv->dev, \"%s: err=%d\\n\", __func__, err);\n\n\treturn err;\n}\n\n \nstatic void if_spi_h2c(struct if_spi_card *card,\n\t\t\tstruct if_spi_packet *packet, int type)\n{\n\tstruct lbs_private *priv = card->priv;\n\tint err = 0;\n\tu16 port_reg;\n\n\tswitch (type) {\n\tcase MVMS_DAT:\n\t\tport_reg = IF_SPI_DATA_RDWRPORT_REG;\n\t\tbreak;\n\tcase MVMS_CMD:\n\t\tport_reg = IF_SPI_CMD_RDWRPORT_REG;\n\t\tbreak;\n\tdefault:\n\t\tnetdev_err(priv->dev, \"can't transfer buffer of type %d\\n\",\n\t\t\t   type);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\terr = spu_write(card, port_reg, packet->buffer, packet->blen);\n\tif (err)\n\t\tgoto out;\n\nout:\n\tkfree(packet);\n\n\tif (err)\n\t\tnetdev_err(priv->dev, \"%s: error %d\\n\", __func__, err);\n}\n\n \nstatic void if_spi_e2h(struct if_spi_card *card)\n{\n\tint err = 0;\n\tu32 cause;\n\tstruct lbs_private *priv = card->priv;\n\n\terr = spu_read_u32(card, IF_SPI_SCRATCH_3_REG, &cause);\n\tif (err)\n\t\tgoto out;\n\n\t \n\terr = spu_write_u16(card, IF_SPI_HOST_INT_STATUS_REG,\n\t\t\t    ~IF_SPI_HICU_CARD_EVENT);\n\tif (err)\n\t\tgoto out;\n\n\t \n\terr = spu_write_u16(card, IF_SPI_CARD_INT_CAUSE_REG,\n\t\t\t    IF_SPI_CIC_HOST_EVENT);\n\tif (err)\n\t\tgoto out;\n\n\tlbs_queue_event(priv, cause & 0xff);\nout:\n\tif (err)\n\t\tnetdev_err(priv->dev, \"%s: error %d\\n\", __func__, err);\n}\n\nstatic void if_spi_host_to_card_worker(struct work_struct *work)\n{\n\tint err;\n\tstruct if_spi_card *card;\n\tu16 hiStatus;\n\tunsigned long flags;\n\tstruct if_spi_packet *packet;\n\tstruct lbs_private *priv;\n\n\tcard = container_of(work, struct if_spi_card, packet_work);\n\tpriv = card->priv;\n\n\t \n\terr = spu_read_u16(card, IF_SPI_HOST_INT_STATUS_REG,\n\t\t\t\t&hiStatus);\n\tif (err) {\n\t\tnetdev_err(priv->dev, \"I/O error\\n\");\n\t\tgoto err;\n\t}\n\n\tif (hiStatus & IF_SPI_HIST_CMD_UPLOAD_RDY) {\n\t\terr = if_spi_c2h_cmd(card);\n\t\tif (err)\n\t\t\tgoto err;\n\t}\n\tif (hiStatus & IF_SPI_HIST_RX_UPLOAD_RDY) {\n\t\terr = if_spi_c2h_data(card);\n\t\tif (err)\n\t\t\tgoto err;\n\t}\n\n\t \n\tif (hiStatus & IF_SPI_HIST_CMD_DOWNLOAD_RDY ||\n\t   (card->priv->psstate != PS_STATE_FULL_POWER &&\n\t    (hiStatus & IF_SPI_HIST_TX_DOWNLOAD_RDY))) {\n\t\t \n\t\tlbs_host_to_card_done(card->priv);\n\n\t\t \n\t\tpacket = NULL;\n\t\tspin_lock_irqsave(&card->buffer_lock, flags);\n\t\tif (!list_empty(&card->cmd_packet_list)) {\n\t\t\tpacket = (struct if_spi_packet *)(card->\n\t\t\t\t\tcmd_packet_list.next);\n\t\t\tlist_del(&packet->list);\n\t\t}\n\t\tspin_unlock_irqrestore(&card->buffer_lock, flags);\n\n\t\tif (packet)\n\t\t\tif_spi_h2c(card, packet, MVMS_CMD);\n\t}\n\tif (hiStatus & IF_SPI_HIST_TX_DOWNLOAD_RDY) {\n\t\t \n\t\tpacket = NULL;\n\t\tspin_lock_irqsave(&card->buffer_lock, flags);\n\t\tif (!list_empty(&card->data_packet_list)) {\n\t\t\tpacket = (struct if_spi_packet *)(card->\n\t\t\t\t\tdata_packet_list.next);\n\t\t\tlist_del(&packet->list);\n\t\t}\n\t\tspin_unlock_irqrestore(&card->buffer_lock, flags);\n\n\t\tif (packet)\n\t\t\tif_spi_h2c(card, packet, MVMS_DAT);\n\t}\n\tif (hiStatus & IF_SPI_HIST_CARD_EVENT)\n\t\tif_spi_e2h(card);\n\nerr:\n\tif (err)\n\t\tnetdev_err(priv->dev, \"%s: got error %d\\n\", __func__, err);\n}\n\n \nstatic int if_spi_host_to_card(struct lbs_private *priv,\n\t\t\t\tu8 type, u8 *buf, u16 nb)\n{\n\tint err = 0;\n\tunsigned long flags;\n\tstruct if_spi_card *card = priv->card;\n\tstruct if_spi_packet *packet;\n\tu16 blen;\n\n\tif (nb == 0) {\n\t\tnetdev_err(priv->dev, \"%s: invalid size requested: %d\\n\",\n\t\t\t   __func__, nb);\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\tblen = ALIGN(nb, 4);\n\tpacket = kzalloc(sizeof(struct if_spi_packet) + blen, GFP_ATOMIC);\n\tif (!packet) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\tpacket->blen = blen;\n\tmemcpy(packet->buffer, buf, nb);\n\tmemset(packet->buffer + nb, 0, blen - nb);\n\n\tswitch (type) {\n\tcase MVMS_CMD:\n\t\tpriv->dnld_sent = DNLD_CMD_SENT;\n\t\tspin_lock_irqsave(&card->buffer_lock, flags);\n\t\tlist_add_tail(&packet->list, &card->cmd_packet_list);\n\t\tspin_unlock_irqrestore(&card->buffer_lock, flags);\n\t\tbreak;\n\tcase MVMS_DAT:\n\t\tpriv->dnld_sent = DNLD_DATA_SENT;\n\t\tspin_lock_irqsave(&card->buffer_lock, flags);\n\t\tlist_add_tail(&packet->list, &card->data_packet_list);\n\t\tspin_unlock_irqrestore(&card->buffer_lock, flags);\n\t\tbreak;\n\tdefault:\n\t\tkfree(packet);\n\t\tnetdev_err(priv->dev, \"can't transfer buffer of type %d\\n\",\n\t\t\t   type);\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n\t \n\tqueue_work(card->workqueue, &card->packet_work);\nout:\n\treturn err;\n}\n\n \nstatic irqreturn_t if_spi_host_interrupt(int irq, void *dev_id)\n{\n\tstruct if_spi_card *card = dev_id;\n\n\tqueue_work(card->workqueue, &card->packet_work);\n\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic int if_spi_init_card(struct if_spi_card *card)\n{\n\tstruct lbs_private *priv = card->priv;\n\tint err, i;\n\tu32 scratch;\n\tconst struct firmware *helper = NULL;\n\tconst struct firmware *mainfw = NULL;\n\n\terr = spu_init(card, card->pdata->use_dummy_writes);\n\tif (err)\n\t\tgoto out;\n\terr = spu_get_chip_revision(card, &card->card_id, &card->card_rev);\n\tif (err)\n\t\tgoto out;\n\n\terr = spu_read_u32(card, IF_SPI_SCRATCH_4_REG, &scratch);\n\tif (err)\n\t\tgoto out;\n\tif (scratch == SUCCESSFUL_FW_DOWNLOAD_MAGIC)\n\t\tlbs_deb_spi(\"Firmware is already loaded for \"\n\t\t\t    \"Marvell WLAN 802.11 adapter\\n\");\n\telse {\n\t\t \n\t\tfor (i = 0; i < ARRAY_SIZE(fw_table); i++) {\n\t\t\tif (card->card_id == fw_table[i].model)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == ARRAY_SIZE(fw_table)) {\n\t\t\tnetdev_err(priv->dev, \"Unsupported chip_id: 0x%02x\\n\",\n\t\t\t\t   card->card_id);\n\t\t\terr = -ENODEV;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = lbs_get_firmware(&card->spi->dev, card->card_id,\n\t\t\t\t\t&fw_table[0], &helper, &mainfw);\n\t\tif (err) {\n\t\t\tnetdev_err(priv->dev, \"failed to find firmware (%d)\\n\",\n\t\t\t\t   err);\n\t\t\tgoto out;\n\t\t}\n\n\t\tlbs_deb_spi(\"Initializing FW for Marvell WLAN 802.11 adapter \"\n\t\t\t\t\"(chip_id = 0x%04x, chip_rev = 0x%02x) \"\n\t\t\t\t\"attached to SPI bus_num %d, chip_select %d. \"\n\t\t\t\t\"spi->max_speed_hz=%d\\n\",\n\t\t\t\tcard->card_id, card->card_rev,\n\t\t\t\tcard->spi->master->bus_num,\n\t\t\t\tspi_get_chipselect(card->spi, 0),\n\t\t\t\tcard->spi->max_speed_hz);\n\t\terr = if_spi_prog_helper_firmware(card, helper);\n\t\tif (err)\n\t\t\tgoto out;\n\t\terr = if_spi_prog_main_firmware(card, mainfw);\n\t\tif (err)\n\t\t\tgoto out;\n\t\tlbs_deb_spi(\"loaded FW for Marvell WLAN 802.11 adapter\\n\");\n\t}\n\n\terr = spu_set_interrupt_mode(card, 0, 1);\n\tif (err)\n\t\tgoto out;\n\nout:\n\treturn err;\n}\n\nstatic void if_spi_resume_worker(struct work_struct *work)\n{\n\tstruct if_spi_card *card;\n\n\tcard = container_of(work, struct if_spi_card, resume_work);\n\n\tif (card->suspended) {\n\t\tif (card->pdata->setup)\n\t\t\tcard->pdata->setup(card->spi);\n\n\t\t \n\t\tif_spi_init_card(card);\n\n\t\tenable_irq(card->spi->irq);\n\n\t\t \n\t\tlbs_resume(card->priv);\n\n\t\tcard->suspended = 0;\n\t}\n}\n\nstatic int if_spi_probe(struct spi_device *spi)\n{\n\tstruct if_spi_card *card;\n\tstruct lbs_private *priv = NULL;\n\tstruct libertas_spi_platform_data *pdata = dev_get_platdata(&spi->dev);\n\tint err = 0;\n\n\tif (!pdata) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (pdata->setup) {\n\t\terr = pdata->setup(spi);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\t \n\tcard = kzalloc(sizeof(struct if_spi_card), GFP_KERNEL);\n\tif (!card) {\n\t\terr = -ENOMEM;\n\t\tgoto teardown;\n\t}\n\tspi_set_drvdata(spi, card);\n\tcard->pdata = pdata;\n\tcard->spi = spi;\n\tcard->prev_xfer_time = jiffies;\n\n\tINIT_LIST_HEAD(&card->cmd_packet_list);\n\tINIT_LIST_HEAD(&card->data_packet_list);\n\tspin_lock_init(&card->buffer_lock);\n\n\t \n\n\t \n\terr = if_spi_init_card(card);\n\tif (err)\n\t\tgoto free_card;\n\n\t \n\tpriv = lbs_add_card(card, &spi->dev);\n\tif (IS_ERR(priv)) {\n\t\terr = PTR_ERR(priv);\n\t\tgoto free_card;\n\t}\n\tcard->priv = priv;\n\tpriv->setup_fw_on_resume = 1;\n\tpriv->card = card;\n\tpriv->hw_host_to_card = if_spi_host_to_card;\n\tpriv->enter_deep_sleep = NULL;\n\tpriv->exit_deep_sleep = NULL;\n\tpriv->reset_deep_sleep_wakeup = NULL;\n\tpriv->fw_ready = 1;\n\n\t \n\tcard->workqueue = alloc_workqueue(\"libertas_spi\", WQ_MEM_RECLAIM, 0);\n\tif (!card->workqueue) {\n\t\terr = -ENOMEM;\n\t\tgoto remove_card;\n\t}\n\tINIT_WORK(&card->packet_work, if_spi_host_to_card_worker);\n\tINIT_WORK(&card->resume_work, if_spi_resume_worker);\n\n\terr = request_irq(spi->irq, if_spi_host_interrupt,\n\t\t\tIRQF_TRIGGER_FALLING, \"libertas_spi\", card);\n\tif (err) {\n\t\tpr_err(\"can't get host irq line-- request_irq failed\\n\");\n\t\tgoto terminate_workqueue;\n\t}\n\n\t \n\terr = lbs_start_card(priv);\n\tif (err)\n\t\tgoto release_irq;\n\n\tlbs_deb_spi(\"Finished initializing WLAN module.\\n\");\n\n\t \n\tgoto out;\n\nrelease_irq:\n\tfree_irq(spi->irq, card);\nterminate_workqueue:\n\tdestroy_workqueue(card->workqueue);\nremove_card:\n\tlbs_remove_card(priv);  \nfree_card:\n\tfree_if_spi_card(card);\nteardown:\n\tif (pdata->teardown)\n\t\tpdata->teardown(spi);\nout:\n\treturn err;\n}\n\nstatic void libertas_spi_remove(struct spi_device *spi)\n{\n\tstruct if_spi_card *card = spi_get_drvdata(spi);\n\tstruct lbs_private *priv = card->priv;\n\n\tlbs_deb_spi(\"libertas_spi_remove\\n\");\n\n\tcancel_work_sync(&card->resume_work);\n\n\tlbs_stop_card(priv);\n\tlbs_remove_card(priv);  \n\n\tfree_irq(spi->irq, card);\n\tdestroy_workqueue(card->workqueue);\n\tif (card->pdata->teardown)\n\t\tcard->pdata->teardown(spi);\n\tfree_if_spi_card(card);\n}\n\nstatic int if_spi_suspend(struct device *dev)\n{\n\tstruct spi_device *spi = to_spi_device(dev);\n\tstruct if_spi_card *card = spi_get_drvdata(spi);\n\n\tif (!card->suspended) {\n\t\tlbs_suspend(card->priv);\n\t\tflush_workqueue(card->workqueue);\n\t\tdisable_irq(spi->irq);\n\n\t\tif (card->pdata->teardown)\n\t\t\tcard->pdata->teardown(spi);\n\t\tcard->suspended = 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int if_spi_resume(struct device *dev)\n{\n\tstruct spi_device *spi = to_spi_device(dev);\n\tstruct if_spi_card *card = spi_get_drvdata(spi);\n\n\t \n\tschedule_work(&card->resume_work);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops if_spi_pm_ops = {\n\t.suspend\t= if_spi_suspend,\n\t.resume\t\t= if_spi_resume,\n};\n\nstatic struct spi_driver libertas_spi_driver = {\n\t.probe\t= if_spi_probe,\n\t.remove = libertas_spi_remove,\n\t.driver = {\n\t\t.name\t= \"libertas_spi\",\n\t\t.pm\t= &if_spi_pm_ops,\n\t},\n};\n\n \n\nstatic int __init if_spi_init_module(void)\n{\n\tint ret = 0;\n\n\tprintk(KERN_INFO \"libertas_spi: Libertas SPI driver\\n\");\n\tret = spi_register_driver(&libertas_spi_driver);\n\n\treturn ret;\n}\n\nstatic void __exit if_spi_exit_module(void)\n{\n\tspi_unregister_driver(&libertas_spi_driver);\n}\n\nmodule_init(if_spi_init_module);\nmodule_exit(if_spi_exit_module);\n\nMODULE_DESCRIPTION(\"Libertas SPI WLAN Driver\");\nMODULE_AUTHOR(\"Andrey Yurovsky <andrey@cozybit.com>, \"\n\t      \"Colin McCabe <colin@cozybit.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"spi:libertas_spi\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}