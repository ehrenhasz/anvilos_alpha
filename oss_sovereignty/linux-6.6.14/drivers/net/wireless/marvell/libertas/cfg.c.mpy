{
  "module_name": "cfg.c",
  "hash_id": "6ec31ed6a934469abfa8975591443b1f04e5afc189b7ee7d12644e684b0d291f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/marvell/libertas/cfg.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/hardirq.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/slab.h>\n#include <linux/ieee80211.h>\n#include <net/cfg80211.h>\n#include <asm/unaligned.h>\n\n#include \"decl.h\"\n#include \"cfg.h\"\n#include \"cmd.h\"\n#include \"mesh.h\"\n\n\n#define CHAN2G(_channel, _freq, _flags) {        \\\n\t.band             = NL80211_BAND_2GHZ, \\\n\t.center_freq      = (_freq),             \\\n\t.hw_value         = (_channel),          \\\n\t.flags            = (_flags),            \\\n\t.max_antenna_gain = 0,                   \\\n\t.max_power        = 30,                  \\\n}\n\nstatic struct ieee80211_channel lbs_2ghz_channels[] = {\n\tCHAN2G(1,  2412, 0),\n\tCHAN2G(2,  2417, 0),\n\tCHAN2G(3,  2422, 0),\n\tCHAN2G(4,  2427, 0),\n\tCHAN2G(5,  2432, 0),\n\tCHAN2G(6,  2437, 0),\n\tCHAN2G(7,  2442, 0),\n\tCHAN2G(8,  2447, 0),\n\tCHAN2G(9,  2452, 0),\n\tCHAN2G(10, 2457, 0),\n\tCHAN2G(11, 2462, 0),\n\tCHAN2G(12, 2467, 0),\n\tCHAN2G(13, 2472, 0),\n\tCHAN2G(14, 2484, 0),\n};\n\n#define RATETAB_ENT(_rate, _hw_value, _flags) { \\\n\t.bitrate  = (_rate),                    \\\n\t.hw_value = (_hw_value),                \\\n\t.flags    = (_flags),                   \\\n}\n\n\n \nstatic struct ieee80211_rate lbs_rates[] = {\n\tRATETAB_ENT(10,  0,  0),\n\tRATETAB_ENT(20,  1,  0),\n\tRATETAB_ENT(55,  2,  0),\n\tRATETAB_ENT(110, 3,  0),\n\tRATETAB_ENT(60,  9,  0),\n\tRATETAB_ENT(90,  6,  0),\n\tRATETAB_ENT(120, 7,  0),\n\tRATETAB_ENT(180, 8,  0),\n\tRATETAB_ENT(240, 9,  0),\n\tRATETAB_ENT(360, 10, 0),\n\tRATETAB_ENT(480, 11, 0),\n\tRATETAB_ENT(540, 12, 0),\n};\n\nstatic struct ieee80211_supported_band lbs_band_2ghz = {\n\t.channels = lbs_2ghz_channels,\n\t.n_channels = ARRAY_SIZE(lbs_2ghz_channels),\n\t.bitrates = lbs_rates,\n\t.n_bitrates = ARRAY_SIZE(lbs_rates),\n};\n\n\nstatic const u32 cipher_suites[] = {\n\tWLAN_CIPHER_SUITE_WEP40,\n\tWLAN_CIPHER_SUITE_WEP104,\n\tWLAN_CIPHER_SUITE_TKIP,\n\tWLAN_CIPHER_SUITE_CCMP,\n};\n\n \n#define LBS_DWELL_PASSIVE 100\n#define LBS_DWELL_ACTIVE  40\n\n\n \n\n \nstatic int lbs_auth_to_authtype(enum nl80211_auth_type auth_type)\n{\n\tint ret = -ENOTSUPP;\n\n\tswitch (auth_type) {\n\tcase NL80211_AUTHTYPE_OPEN_SYSTEM:\n\tcase NL80211_AUTHTYPE_SHARED_KEY:\n\t\tret = auth_type;\n\t\tbreak;\n\tcase NL80211_AUTHTYPE_AUTOMATIC:\n\t\tret = NL80211_AUTHTYPE_OPEN_SYSTEM;\n\t\tbreak;\n\tcase NL80211_AUTHTYPE_NETWORK_EAP:\n\t\tret = 0x80;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\treturn ret;\n}\n\n\n \nstatic int lbs_add_rates(u8 *rates)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < ARRAY_SIZE(lbs_rates); i++) {\n\t\tu8 rate = lbs_rates[i].bitrate / 5;\n\t\tif (rate == 0x02 || rate == 0x04 ||\n\t\t    rate == 0x0b || rate == 0x16)\n\t\t\trate |= 0x80;\n\t\trates[i] = rate;\n\t}\n\treturn ARRAY_SIZE(lbs_rates);\n}\n\n\n \n\n\n \n#define LBS_MAX_SSID_TLV_SIZE\t\t\t\\\n\t(sizeof(struct mrvl_ie_header)\t\t\\\n\t + IEEE80211_MAX_SSID_LEN)\n\nstatic int lbs_add_ssid_tlv(u8 *tlv, const u8 *ssid, int ssid_len)\n{\n\tstruct mrvl_ie_ssid_param_set *ssid_tlv = (void *)tlv;\n\n\t \n\tssid_tlv->header.type = cpu_to_le16(TLV_TYPE_SSID);\n\tssid_tlv->header.len = cpu_to_le16(ssid_len);\n\tmemcpy(ssid_tlv->ssid, ssid, ssid_len);\n\treturn sizeof(ssid_tlv->header) + ssid_len;\n}\n\n\n \n#define LBS_MAX_CHANNEL_LIST_TLV_SIZE\t\t\t\t\t\\\n\t(sizeof(struct mrvl_ie_header)\t\t\t\t\t\\\n\t + (LBS_SCAN_BEFORE_NAP * sizeof(struct chanscanparamset)))\n\nstatic int lbs_add_channel_list_tlv(struct lbs_private *priv, u8 *tlv,\n\t\t\t\t    int last_channel, int active_scan)\n{\n\tint chanscanparamsize = sizeof(struct chanscanparamset) *\n\t\t(last_channel - priv->scan_channel);\n\n\tstruct mrvl_ie_header *header = (void *) tlv;\n\n\t \n\n\theader->type = cpu_to_le16(TLV_TYPE_CHANLIST);\n\theader->len  = cpu_to_le16(chanscanparamsize);\n\ttlv += sizeof(struct mrvl_ie_header);\n\n\t \n\tmemset(tlv, 0, chanscanparamsize);\n\n\twhile (priv->scan_channel < last_channel) {\n\t\tstruct chanscanparamset *param = (void *) tlv;\n\n\t\tparam->radiotype = CMD_SCAN_RADIO_TYPE_BG;\n\t\tparam->channumber =\n\t\t\tpriv->scan_req->channels[priv->scan_channel]->hw_value;\n\t\tif (active_scan) {\n\t\t\tparam->maxscantime = cpu_to_le16(LBS_DWELL_ACTIVE);\n\t\t} else {\n\t\t\tparam->chanscanmode.passivescan = 1;\n\t\t\tparam->maxscantime = cpu_to_le16(LBS_DWELL_PASSIVE);\n\t\t}\n\t\ttlv += sizeof(struct chanscanparamset);\n\t\tpriv->scan_channel++;\n\t}\n\treturn sizeof(struct mrvl_ie_header) + chanscanparamsize;\n}\n\n\n \n#define LBS_MAX_RATES_TLV_SIZE\t\t\t\\\n\t(sizeof(struct mrvl_ie_header)\t\t\\\n\t + (ARRAY_SIZE(lbs_rates)))\n\n \nstatic int lbs_add_supported_rates_tlv(u8 *tlv)\n{\n\tsize_t i;\n\tstruct mrvl_ie_rates_param_set *rate_tlv = (void *)tlv;\n\n\t \n\trate_tlv->header.type = cpu_to_le16(TLV_TYPE_RATES);\n\ttlv += sizeof(rate_tlv->header);\n\ti = lbs_add_rates(tlv);\n\ttlv += i;\n\trate_tlv->header.len = cpu_to_le16(i);\n\treturn sizeof(rate_tlv->header) + i;\n}\n\n \nstatic u8 *\nadd_ie_rates(u8 *tlv, const u8 *ie, int *nrates)\n{\n\tint hw, ap, ap_max = ie[1];\n\tu8 hw_rate;\n\n\tif (ap_max > MAX_RATES) {\n\t\tlbs_deb_assoc(\"invalid rates\\n\");\n\t\treturn tlv;\n\t}\n\t \n\tie += 2;\n\n\tlbs_deb_hex(LBS_DEB_ASSOC, \"AP IE Rates\", (u8 *) ie, ap_max);\n\n\tfor (hw = 0; hw < ARRAY_SIZE(lbs_rates); hw++) {\n\t\thw_rate = lbs_rates[hw].bitrate / 5;\n\t\tfor (ap = 0; ap < ap_max; ap++) {\n\t\t\tif (hw_rate == (ie[ap] & 0x7f)) {\n\t\t\t\t*tlv++ = ie[ap];\n\t\t\t\t*nrates = *nrates + 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn tlv;\n}\n\n \nstatic int lbs_add_common_rates_tlv(u8 *tlv, struct cfg80211_bss *bss)\n{\n\tstruct mrvl_ie_rates_param_set *rate_tlv = (void *)tlv;\n\tconst u8 *rates_eid, *ext_rates_eid;\n\tint n = 0;\n\n\trcu_read_lock();\n\trates_eid = ieee80211_bss_get_ie(bss, WLAN_EID_SUPP_RATES);\n\text_rates_eid = ieee80211_bss_get_ie(bss, WLAN_EID_EXT_SUPP_RATES);\n\n\t \n\trate_tlv->header.type = cpu_to_le16(TLV_TYPE_RATES);\n\ttlv += sizeof(rate_tlv->header);\n\n\t \n\tif (rates_eid) {\n\t\ttlv = add_ie_rates(tlv, rates_eid, &n);\n\n\t\t \n\t\tif (ext_rates_eid)\n\t\t\ttlv = add_ie_rates(tlv, ext_rates_eid, &n);\n\t} else {\n\t\tlbs_deb_assoc(\"assoc: bss had no basic rate IE\\n\");\n\t\t \n\t\t*tlv++ = 0x82;\n\t\t*tlv++ = 0x84;\n\t\t*tlv++ = 0x8b;\n\t\t*tlv++ = 0x96;\n\t\tn = 4;\n\t}\n\trcu_read_unlock();\n\n\trate_tlv->header.len = cpu_to_le16(n);\n\treturn sizeof(rate_tlv->header) + n;\n}\n\n\n \n#define LBS_MAX_AUTH_TYPE_TLV_SIZE \\\n\tsizeof(struct mrvl_ie_auth_type)\n\nstatic int lbs_add_auth_type_tlv(u8 *tlv, enum nl80211_auth_type auth_type)\n{\n\tstruct mrvl_ie_auth_type *auth = (void *) tlv;\n\n\t \n\tauth->header.type = cpu_to_le16(TLV_TYPE_AUTH_TYPE);\n\tauth->header.len = cpu_to_le16(sizeof(*auth)-sizeof(auth->header));\n\tauth->auth = cpu_to_le16(lbs_auth_to_authtype(auth_type));\n\treturn sizeof(*auth);\n}\n\n\n \n#define LBS_MAX_CHANNEL_TLV_SIZE \\\n\tsizeof(struct mrvl_ie_header)\n\nstatic int lbs_add_channel_tlv(u8 *tlv, u8 channel)\n{\n\tstruct mrvl_ie_ds_param_set *ds = (void *) tlv;\n\n\t \n\tds->header.type = cpu_to_le16(TLV_TYPE_PHY_DS);\n\tds->header.len = cpu_to_le16(sizeof(*ds)-sizeof(ds->header));\n\tds->channel = channel;\n\treturn sizeof(*ds);\n}\n\n\n \n#define LBS_MAX_CF_PARAM_TLV_SIZE\t\t\\\n\tsizeof(struct mrvl_ie_header)\n\nstatic int lbs_add_cf_param_tlv(u8 *tlv)\n{\n\tstruct mrvl_ie_cf_param_set *cf = (void *)tlv;\n\n\t \n\tcf->header.type = cpu_to_le16(TLV_TYPE_CF);\n\tcf->header.len = cpu_to_le16(sizeof(*cf)-sizeof(cf->header));\n\treturn sizeof(*cf);\n}\n\n \n#define LBS_MAX_WPA_TLV_SIZE\t\t\t\\\n\t(sizeof(struct mrvl_ie_header)\t\t\\\n\t + 128  )\n\nstatic int lbs_add_wpa_tlv(u8 *tlv, const u8 *ie, u8 ie_len)\n{\n\tstruct mrvl_ie_data *wpatlv = (struct mrvl_ie_data *)tlv;\n\tconst struct element *wpaie;\n\n\t \n\twpaie = cfg80211_find_elem(WLAN_EID_RSN, ie, ie_len);\n\tif (!wpaie)\n\t\twpaie = cfg80211_find_vendor_elem(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t\t  WLAN_OUI_TYPE_MICROSOFT_WPA,\n\t\t\t\t\t\t  ie, ie_len);\n\tif (!wpaie || wpaie->datalen > 128)\n\t\treturn 0;\n\n\t \n\twpatlv->header.type = cpu_to_le16(wpaie->id);\n\twpatlv->header.len = cpu_to_le16(wpaie->datalen);\n\tmemcpy(wpatlv->data, wpaie->data, wpaie->datalen);\n\n\t \n\treturn sizeof(struct mrvl_ie_header) + wpaie->datalen;\n}\n\n \n#define LBS_MAX_WPS_ENROLLEE_TLV_SIZE\t\t\\\n\t(sizeof(struct mrvl_ie_header)\t\t\\\n\t + 256)\n\nstatic int lbs_add_wps_enrollee_tlv(u8 *tlv, const u8 *ie, size_t ie_len)\n{\n\tstruct mrvl_ie_data *wpstlv = (struct mrvl_ie_data *)tlv;\n\tconst struct element *wpsie;\n\n\t \n\twpsie = cfg80211_find_vendor_elem(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t  WLAN_OUI_TYPE_MICROSOFT_WPS,\n\t\t\t\t\t  ie, ie_len);\n\tif (!wpsie)\n\t\treturn 0;\n\n\t \n\twpstlv->header.type = cpu_to_le16(TLV_TYPE_WPS_ENROLLEE);\n\twpstlv->header.len = cpu_to_le16(wpsie->datalen);\n\tmemcpy(wpstlv->data, wpsie->data, wpsie->datalen);\n\n\t \n\treturn sizeof(struct mrvl_ie_header) + wpsie->datalen;\n}\n\n \n\nstatic int lbs_cfg_set_monitor_channel(struct wiphy *wiphy,\n\t\t\t\t       struct cfg80211_chan_def *chandef)\n{\n\tstruct lbs_private *priv = wiphy_priv(wiphy);\n\tint ret = -ENOTSUPP;\n\n\tif (cfg80211_get_chandef_type(chandef) != NL80211_CHAN_NO_HT)\n\t\tgoto out;\n\n\tret = lbs_set_channel(priv, chandef->chan->hw_value);\n\n out:\n\treturn ret;\n}\n\nstatic int lbs_cfg_set_mesh_channel(struct wiphy *wiphy,\n\t\t\t\t    struct net_device *netdev,\n\t\t\t\t    struct ieee80211_channel *channel)\n{\n\tstruct lbs_private *priv = wiphy_priv(wiphy);\n\tint ret = -ENOTSUPP;\n\n\tif (netdev != priv->mesh_dev)\n\t\tgoto out;\n\n\tret = lbs_mesh_set_channel(priv, channel->hw_value);\n\n out:\n\treturn ret;\n}\n\n\n\n \n\n \n#define LBS_SCAN_BEFORE_NAP 4\n\n\n \n#define LBS_SCAN_RSSI_TO_MBM(rssi) \\\n\t((-(int)rssi + 3)*100)\n\nstatic int lbs_ret_scan(struct lbs_private *priv, unsigned long dummy,\n\tstruct cmd_header *resp)\n{\n\tstruct cfg80211_bss *bss;\n\tstruct cmd_ds_802_11_scan_rsp *scanresp = (void *)resp;\n\tint bsssize;\n\tconst u8 *pos;\n\tconst u8 *tsfdesc;\n\tint tsfsize;\n\tint i;\n\tint ret = -EILSEQ;\n\n\tbsssize = get_unaligned_le16(&scanresp->bssdescriptsize);\n\n\tlbs_deb_scan(\"scan response: %d BSSs (%d bytes); resp size %d bytes\\n\",\n\t\t\tscanresp->nr_sets, bsssize, le16_to_cpu(resp->size));\n\n\tif (scanresp->nr_sets == 0) {\n\t\tret = 0;\n\t\tgoto done;\n\t}\n\n\t \n\n\tpos = scanresp->bssdesc_and_tlvbuffer;\n\n\tlbs_deb_hex(LBS_DEB_SCAN, \"SCAN_RSP\", scanresp->bssdesc_and_tlvbuffer,\n\t\t    bsssize);\n\n\ttsfdesc = pos + bsssize;\n\ttsfsize = 4 + 8 * scanresp->nr_sets;\n\tlbs_deb_hex(LBS_DEB_SCAN, \"SCAN_TSF\", (u8 *) tsfdesc, tsfsize);\n\n\t \n\ti = get_unaligned_le16(tsfdesc);\n\ttsfdesc += 2;\n\tif (i != TLV_TYPE_TSFTIMESTAMP) {\n\t\tlbs_deb_scan(\"scan response: invalid TSF Timestamp %d\\n\", i);\n\t\tgoto done;\n\t}\n\n\t \n\ti = get_unaligned_le16(tsfdesc);\n\ttsfdesc += 2;\n\tif (i / 8 != scanresp->nr_sets) {\n\t\tlbs_deb_scan(\"scan response: invalid number of TSF timestamp \"\n\t\t\t     \"sets (expected %d got %d)\\n\", scanresp->nr_sets,\n\t\t\t     i / 8);\n\t\tgoto done;\n\t}\n\n\tfor (i = 0; i < scanresp->nr_sets; i++) {\n\t\tconst u8 *bssid;\n\t\tconst u8 *ie;\n\t\tint left;\n\t\tint ielen;\n\t\tint rssi;\n\t\tu16 intvl;\n\t\tu16 capa;\n\t\tint chan_no = -1;\n\t\tconst u8 *ssid = NULL;\n\t\tu8 ssid_len = 0;\n\n\t\tint len = get_unaligned_le16(pos);\n\t\tpos += 2;\n\n\t\t \n\t\tbssid = pos;\n\t\tpos += ETH_ALEN;\n\t\t \n\t\trssi = *pos++;\n\t\t \n\t\tpos += 8;\n\t\t \n\t\tintvl = get_unaligned_le16(pos);\n\t\tpos += 2;\n\t\t \n\t\tcapa = get_unaligned_le16(pos);\n\t\tpos += 2;\n\n\t\t \n\t\tie = pos;\n\t\t \n\t\tielen = left = len - (6 + 1 + 8 + 2 + 2);\n\t\twhile (left >= 2) {\n\t\t\tu8 id, elen;\n\t\t\tid = *pos++;\n\t\t\telen = *pos++;\n\t\t\tleft -= 2;\n\t\t\tif (elen > left) {\n\t\t\t\tlbs_deb_scan(\"scan response: invalid IE fmt\\n\");\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tif (id == WLAN_EID_DS_PARAMS)\n\t\t\t\tchan_no = *pos;\n\t\t\tif (id == WLAN_EID_SSID) {\n\t\t\t\tssid = pos;\n\t\t\t\tssid_len = elen;\n\t\t\t}\n\t\t\tleft -= elen;\n\t\t\tpos += elen;\n\t\t}\n\n\t\t \n\t\tif (chan_no != -1) {\n\t\t\tstruct wiphy *wiphy = priv->wdev->wiphy;\n\t\t\tint freq = ieee80211_channel_to_frequency(chan_no,\n\t\t\t\t\t\t\tNL80211_BAND_2GHZ);\n\t\t\tstruct ieee80211_channel *channel =\n\t\t\t\tieee80211_get_channel(wiphy, freq);\n\n\t\t\tlbs_deb_scan(\"scan: %pM, capa %04x, chan %2d, %*pE, %d dBm\\n\",\n\t\t\t\t     bssid, capa, chan_no, ssid_len, ssid,\n\t\t\t\t     LBS_SCAN_RSSI_TO_MBM(rssi)/100);\n\n\t\t\tif (channel &&\n\t\t\t    !(channel->flags & IEEE80211_CHAN_DISABLED)) {\n\t\t\t\tbss = cfg80211_inform_bss(wiphy, channel,\n\t\t\t\t\tCFG80211_BSS_FTYPE_UNKNOWN,\n\t\t\t\t\tbssid, get_unaligned_le64(tsfdesc),\n\t\t\t\t\tcapa, intvl, ie, ielen,\n\t\t\t\t\tLBS_SCAN_RSSI_TO_MBM(rssi),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\t\tcfg80211_put_bss(wiphy, bss);\n\t\t\t}\n\t\t} else\n\t\t\tlbs_deb_scan(\"scan response: missing BSS channel IE\\n\");\n\n\t\ttsfdesc += 8;\n\t}\n\tret = 0;\n\n done:\n\treturn ret;\n}\n\n\n \n#define LBS_SCAN_MAX_CMD_SIZE\t\t\t\\\n\t(sizeof(struct cmd_ds_802_11_scan)\t\\\n\t + LBS_MAX_SSID_TLV_SIZE\t\t\\\n\t + LBS_MAX_CHANNEL_LIST_TLV_SIZE\t\\\n\t + LBS_MAX_RATES_TLV_SIZE\t\t\\\n\t + LBS_MAX_WPS_ENROLLEE_TLV_SIZE)\n\n \nstatic void lbs_scan_worker(struct work_struct *work)\n{\n\tstruct lbs_private *priv =\n\t\tcontainer_of(work, struct lbs_private, scan_work.work);\n\tstruct cmd_ds_802_11_scan *scan_cmd;\n\tu8 *tlv;  \n\tint last_channel;\n\tint running, carrier;\n\n\tscan_cmd = kzalloc(LBS_SCAN_MAX_CMD_SIZE, GFP_KERNEL);\n\tif (scan_cmd == NULL)\n\t\treturn;\n\n\t \n\tscan_cmd->bsstype = CMD_BSS_TYPE_ANY;\n\n\t \n\trunning = !netif_queue_stopped(priv->dev);\n\tcarrier = netif_carrier_ok(priv->dev);\n\tif (running)\n\t\tnetif_stop_queue(priv->dev);\n\tif (carrier)\n\t\tnetif_carrier_off(priv->dev);\n\n\t \n\ttlv = scan_cmd->tlvbuffer;\n\n\t \n\tif (priv->scan_req->n_ssids && priv->scan_req->ssids[0].ssid_len > 0)\n\t\ttlv += lbs_add_ssid_tlv(tlv,\n\t\t\t\t\tpriv->scan_req->ssids[0].ssid,\n\t\t\t\t\tpriv->scan_req->ssids[0].ssid_len);\n\n\t \n\tlast_channel = priv->scan_channel + LBS_SCAN_BEFORE_NAP;\n\tif (last_channel > priv->scan_req->n_channels)\n\t\tlast_channel = priv->scan_req->n_channels;\n\ttlv += lbs_add_channel_list_tlv(priv, tlv, last_channel,\n\t\tpriv->scan_req->n_ssids);\n\n\t \n\ttlv += lbs_add_supported_rates_tlv(tlv);\n\n\t \n\tif (priv->scan_req->ie && priv->scan_req->ie_len)\n\t\ttlv += lbs_add_wps_enrollee_tlv(tlv, priv->scan_req->ie,\n\t\t\t\t\t\tpriv->scan_req->ie_len);\n\n\tif (priv->scan_channel < priv->scan_req->n_channels) {\n\t\tcancel_delayed_work(&priv->scan_work);\n\t\tif (netif_running(priv->dev))\n\t\t\tqueue_delayed_work(priv->work_thread, &priv->scan_work,\n\t\t\t\tmsecs_to_jiffies(300));\n\t}\n\n\t \n\tscan_cmd->hdr.size = cpu_to_le16(tlv - (u8 *)scan_cmd);\n\tlbs_deb_hex(LBS_DEB_SCAN, \"SCAN_CMD\", (void *)scan_cmd,\n\t\t    sizeof(*scan_cmd));\n\tlbs_deb_hex(LBS_DEB_SCAN, \"SCAN_TLV\", scan_cmd->tlvbuffer,\n\t\t    tlv - scan_cmd->tlvbuffer);\n\n\t__lbs_cmd(priv, CMD_802_11_SCAN, &scan_cmd->hdr,\n\t\tle16_to_cpu(scan_cmd->hdr.size),\n\t\tlbs_ret_scan, 0);\n\n\tif (priv->scan_channel >= priv->scan_req->n_channels) {\n\t\t \n\t\tcancel_delayed_work(&priv->scan_work);\n\t\tlbs_scan_done(priv);\n\t}\n\n\t \n\tif (carrier)\n\t\tnetif_carrier_on(priv->dev);\n\tif (running && !priv->tx_pending_len)\n\t\tnetif_wake_queue(priv->dev);\n\n\tkfree(scan_cmd);\n\n\t \n\tif (priv->scan_req == NULL) {\n\t\tlbs_deb_scan(\"scan: waking up waiters\\n\");\n\t\twake_up_all(&priv->scan_q);\n\t}\n}\n\nstatic void _internal_start_scan(struct lbs_private *priv, bool internal,\n\tstruct cfg80211_scan_request *request)\n{\n\tlbs_deb_scan(\"scan: ssids %d, channels %d, ie_len %zd\\n\",\n\t\trequest->n_ssids, request->n_channels, request->ie_len);\n\n\tpriv->scan_channel = 0;\n\tpriv->scan_req = request;\n\tpriv->internal_scan = internal;\n\n\tqueue_delayed_work(priv->work_thread, &priv->scan_work,\n\t\tmsecs_to_jiffies(50));\n}\n\n \nvoid lbs_scan_done(struct lbs_private *priv)\n{\n\tWARN_ON(!priv->scan_req);\n\n\tif (priv->internal_scan) {\n\t\tkfree(priv->scan_req);\n\t} else {\n\t\tstruct cfg80211_scan_info info = {\n\t\t\t.aborted = false,\n\t\t};\n\n\t\tcfg80211_scan_done(priv->scan_req, &info);\n\t}\n\n\tpriv->scan_req = NULL;\n}\n\nstatic int lbs_cfg_scan(struct wiphy *wiphy,\n\tstruct cfg80211_scan_request *request)\n{\n\tstruct lbs_private *priv = wiphy_priv(wiphy);\n\tint ret = 0;\n\n\tif (priv->scan_req || delayed_work_pending(&priv->scan_work)) {\n\t\t \n\t\tret = -EAGAIN;\n\t\tgoto out;\n\t}\n\n\t_internal_start_scan(priv, false, request);\n\n\tif (priv->surpriseremoved)\n\t\tret = -EIO;\n\n out:\n\treturn ret;\n}\n\n\n\n\n \n\nvoid lbs_send_disconnect_notification(struct lbs_private *priv,\n\t\t\t\t      bool locally_generated)\n{\n\tcfg80211_disconnected(priv->dev, 0, NULL, 0, locally_generated,\n\t\t\t      GFP_KERNEL);\n}\n\nvoid lbs_send_mic_failureevent(struct lbs_private *priv, u32 event)\n{\n\tcfg80211_michael_mic_failure(priv->dev,\n\t\tpriv->assoc_bss,\n\t\tevent == MACREG_INT_CODE_MIC_ERR_MULTICAST ?\n\t\t\tNL80211_KEYTYPE_GROUP :\n\t\t\tNL80211_KEYTYPE_PAIRWISE,\n\t\t-1,\n\t\tNULL,\n\t\tGFP_KERNEL);\n}\n\n\n\n\n \n\n\n \nstatic int lbs_remove_wep_keys(struct lbs_private *priv)\n{\n\tstruct cmd_ds_802_11_set_wep cmd;\n\tint ret;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.hdr.size = cpu_to_le16(sizeof(cmd));\n\tcmd.keyindex = cpu_to_le16(priv->wep_tx_key);\n\tcmd.action = cpu_to_le16(CMD_ACT_REMOVE);\n\n\tret = lbs_cmd_with_response(priv, CMD_802_11_SET_WEP, &cmd);\n\n\treturn ret;\n}\n\n \nstatic int lbs_set_wep_keys(struct lbs_private *priv)\n{\n\tstruct cmd_ds_802_11_set_wep cmd;\n\tint i;\n\tint ret;\n\n\t \n\tif (priv->wep_key_len[0] || priv->wep_key_len[1] ||\n\t    priv->wep_key_len[2] || priv->wep_key_len[3]) {\n\t\t \n\t\tmemset(&cmd, 0, sizeof(cmd));\n\t\tcmd.hdr.size = cpu_to_le16(sizeof(cmd));\n\t\tcmd.keyindex = cpu_to_le16(priv->wep_tx_key);\n\t\tcmd.action = cpu_to_le16(CMD_ACT_ADD);\n\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tswitch (priv->wep_key_len[i]) {\n\t\t\tcase WLAN_KEY_LEN_WEP40:\n\t\t\t\tcmd.keytype[i] = CMD_TYPE_WEP_40_BIT;\n\t\t\t\tbreak;\n\t\t\tcase WLAN_KEY_LEN_WEP104:\n\t\t\t\tcmd.keytype[i] = CMD_TYPE_WEP_104_BIT;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcmd.keytype[i] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemcpy(cmd.keymaterial[i], priv->wep_key[i],\n\t\t\t       priv->wep_key_len[i]);\n\t\t}\n\n\t\tret = lbs_cmd_with_response(priv, CMD_802_11_SET_WEP, &cmd);\n\t} else {\n\t\t \n\t\tret = lbs_remove_wep_keys(priv);\n\t}\n\n\treturn ret;\n}\n\n\n \nstatic int lbs_enable_rsn(struct lbs_private *priv, int enable)\n{\n\tstruct cmd_ds_802_11_enable_rsn cmd;\n\tint ret;\n\n\t \n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.hdr.size = cpu_to_le16(sizeof(cmd));\n\tcmd.action = cpu_to_le16(CMD_ACT_SET);\n\tcmd.enable = cpu_to_le16(enable);\n\n\tret = lbs_cmd_with_response(priv, CMD_802_11_ENABLE_RSN, &cmd);\n\n\treturn ret;\n}\n\n\n \n\n \n\nstruct cmd_key_material {\n\tstruct cmd_header hdr;\n\n\t__le16 action;\n\tstruct MrvlIEtype_keyParamSet param;\n} __packed;\n\nstatic int lbs_set_key_material(struct lbs_private *priv,\n\t\t\t\tint key_type, int key_info,\n\t\t\t\tconst u8 *key, u16 key_len)\n{\n\tstruct cmd_key_material cmd;\n\tint ret;\n\n\t \n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.hdr.size = cpu_to_le16(sizeof(cmd));\n\tcmd.action = cpu_to_le16(CMD_ACT_SET);\n\tcmd.param.type = cpu_to_le16(TLV_TYPE_KEY_MATERIAL);\n\tcmd.param.length = cpu_to_le16(sizeof(cmd.param) - 4);\n\tcmd.param.keytypeid = cpu_to_le16(key_type);\n\tcmd.param.keyinfo = cpu_to_le16(key_info);\n\tcmd.param.keylen = cpu_to_le16(key_len);\n\tif (key && key_len)\n\t\tmemcpy(cmd.param.key, key, key_len);\n\n\tret = lbs_cmd_with_response(priv, CMD_802_11_KEY_MATERIAL, &cmd);\n\n\treturn ret;\n}\n\n\n \nstatic int lbs_set_authtype(struct lbs_private *priv,\n\t\t\t    struct cfg80211_connect_params *sme)\n{\n\tstruct cmd_ds_802_11_authenticate cmd;\n\tint ret;\n\n\t \n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.hdr.size = cpu_to_le16(sizeof(cmd));\n\tif (sme->bssid)\n\t\tmemcpy(cmd.bssid, sme->bssid, ETH_ALEN);\n\t \n\tret = lbs_auth_to_authtype(sme->auth_type);\n\tif (ret < 0)\n\t\tgoto done;\n\n\tcmd.authtype = ret;\n\tret = lbs_cmd_with_response(priv, CMD_802_11_AUTHENTICATE, &cmd);\n\n done:\n\treturn ret;\n}\n\n\n \n#define LBS_ASSOC_MAX_CMD_SIZE                     \\\n\t(sizeof(struct cmd_ds_802_11_associate)    \\\n\t + LBS_MAX_SSID_TLV_SIZE                   \\\n\t + LBS_MAX_CHANNEL_TLV_SIZE                \\\n\t + LBS_MAX_CF_PARAM_TLV_SIZE               \\\n\t + LBS_MAX_AUTH_TYPE_TLV_SIZE              \\\n\t + LBS_MAX_WPA_TLV_SIZE)\n\nstatic int lbs_associate(struct lbs_private *priv,\n\t\tstruct cfg80211_bss *bss,\n\t\tstruct cfg80211_connect_params *sme)\n{\n\tstruct cmd_ds_802_11_associate_response *resp;\n\tstruct cmd_ds_802_11_associate *cmd = kzalloc(LBS_ASSOC_MAX_CMD_SIZE,\n\t\t\t\t\t\t      GFP_KERNEL);\n\tconst u8 *ssid_eid;\n\tsize_t len, resp_ie_len;\n\tint status;\n\tint ret;\n\tu8 *pos;\n\tu8 *tmp;\n\n\tif (!cmd) {\n\t\tret = -ENOMEM;\n\t\tgoto done;\n\t}\n\tpos = &cmd->iebuf[0];\n\n\t \n\tcmd->hdr.command = cpu_to_le16(CMD_802_11_ASSOCIATE);\n\n\t \n\tmemcpy(cmd->bssid, bss->bssid, ETH_ALEN);\n\tcmd->listeninterval = cpu_to_le16(MRVDRV_DEFAULT_LISTEN_INTERVAL);\n\tcmd->capability = cpu_to_le16(bss->capability);\n\n\t \n\trcu_read_lock();\n\tssid_eid = ieee80211_bss_get_ie(bss, WLAN_EID_SSID);\n\tif (ssid_eid)\n\t\tpos += lbs_add_ssid_tlv(pos, ssid_eid + 2, ssid_eid[1]);\n\telse\n\t\tlbs_deb_assoc(\"no SSID\\n\");\n\trcu_read_unlock();\n\n\t \n\tif (bss->channel)\n\t\tpos += lbs_add_channel_tlv(pos, bss->channel->hw_value);\n\telse\n\t\tlbs_deb_assoc(\"no channel\\n\");\n\n\t \n\tpos += lbs_add_cf_param_tlv(pos);\n\n\t \n\ttmp = pos + 4;  \n\tpos += lbs_add_common_rates_tlv(pos, bss);\n\tlbs_deb_hex(LBS_DEB_ASSOC, \"Common Rates\", tmp, pos - tmp);\n\n\t \n\tif (MRVL_FW_MAJOR_REV(priv->fwrelease) >= 9)\n\t\tpos += lbs_add_auth_type_tlv(pos, sme->auth_type);\n\n\t \n\tif (sme->ie && sme->ie_len)\n\t\tpos += lbs_add_wpa_tlv(pos, sme->ie, sme->ie_len);\n\n\tlen = sizeof(*cmd) + (u16)(pos - (u8 *) &cmd->iebuf);\n\tcmd->hdr.size = cpu_to_le16(len);\n\n\tlbs_deb_hex(LBS_DEB_ASSOC, \"ASSOC_CMD\", (u8 *) cmd,\n\t\t\tle16_to_cpu(cmd->hdr.size));\n\n\t \n\tmemcpy(priv->assoc_bss, bss->bssid, ETH_ALEN);\n\n\tret = lbs_cmd_with_response(priv, CMD_802_11_ASSOCIATE, cmd);\n\tif (ret)\n\t\tgoto done;\n\n\t \n\n\tresp = (void *) cmd;  \n\tstatus = le16_to_cpu(resp->statuscode);\n\n\t \n\tif (MRVL_FW_MAJOR_REV(priv->fwrelease) <= 8) {\n\t\tswitch (status) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tlbs_deb_assoc(\"invalid association parameters\\n\");\n\t\t\tstatus = WLAN_STATUS_CAPS_UNSUPPORTED;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tlbs_deb_assoc(\"timer expired while waiting for AP\\n\");\n\t\t\tstatus = WLAN_STATUS_AUTH_TIMEOUT;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tlbs_deb_assoc(\"association refused by AP\\n\");\n\t\t\tstatus = WLAN_STATUS_ASSOC_DENIED_UNSPEC;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tlbs_deb_assoc(\"authentication refused by AP\\n\");\n\t\t\tstatus = WLAN_STATUS_UNKNOWN_AUTH_TRANSACTION;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlbs_deb_assoc(\"association failure %d\\n\", status);\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlbs_deb_assoc(\"status %d, statuscode 0x%04x, capability 0x%04x, \"\n\t\t      \"aid 0x%04x\\n\", status, le16_to_cpu(resp->statuscode),\n\t\t      le16_to_cpu(resp->capability), le16_to_cpu(resp->aid));\n\n\tresp_ie_len = le16_to_cpu(resp->hdr.size)\n\t\t- sizeof(resp->hdr)\n\t\t- 6;\n\tcfg80211_connect_result(priv->dev,\n\t\t\t\tpriv->assoc_bss,\n\t\t\t\tsme->ie, sme->ie_len,\n\t\t\t\tresp->iebuf, resp_ie_len,\n\t\t\t\tstatus,\n\t\t\t\tGFP_KERNEL);\n\n\tif (status == 0) {\n\t\t \n\t\tpriv->connect_status = LBS_CONNECTED;\n\t\tnetif_carrier_on(priv->dev);\n\t\tif (!priv->tx_pending_len)\n\t\t\tnetif_tx_wake_all_queues(priv->dev);\n\t}\n\n\tkfree(cmd);\ndone:\n\treturn ret;\n}\n\nstatic struct cfg80211_scan_request *\n_new_connect_scan_req(struct wiphy *wiphy, struct cfg80211_connect_params *sme)\n{\n\tstruct cfg80211_scan_request *creq = NULL;\n\tint i, n_channels = ieee80211_get_num_supported_channels(wiphy);\n\tenum nl80211_band band;\n\n\tcreq = kzalloc(sizeof(*creq) + sizeof(struct cfg80211_ssid) +\n\t\t       n_channels * sizeof(void *),\n\t\t       GFP_ATOMIC);\n\tif (!creq)\n\t\treturn NULL;\n\n\t \n\tcreq->ssids = (void *)&creq->channels[n_channels];\n\tcreq->n_channels = n_channels;\n\tcreq->n_ssids = 1;\n\n\t \n\ti = 0;\n\tfor (band = 0; band < NUM_NL80211_BANDS; band++) {\n\t\tint j;\n\n\t\tif (!wiphy->bands[band])\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < wiphy->bands[band]->n_channels; j++) {\n\t\t\t \n\t\t\tif (wiphy->bands[band]->channels[j].flags &\n\t\t\t\t\t\tIEEE80211_CHAN_DISABLED)\n\t\t\t\tcontinue;\n\n\t\t\tcreq->channels[i] = &wiphy->bands[band]->channels[j];\n\t\t\ti++;\n\t\t}\n\t}\n\tif (i) {\n\t\t \n\t\tcreq->n_channels = i;\n\n\t\t \n\t\tmemcpy(creq->ssids[0].ssid, sme->ssid, sme->ssid_len);\n\t\tcreq->ssids[0].ssid_len = sme->ssid_len;\n\t} else {\n\t\t \n\t\tkfree(creq);\n\t\tcreq = NULL;\n\t}\n\n\treturn creq;\n}\n\nstatic int lbs_cfg_connect(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t   struct cfg80211_connect_params *sme)\n{\n\tstruct lbs_private *priv = wiphy_priv(wiphy);\n\tstruct cfg80211_bss *bss = NULL;\n\tint ret = 0;\n\tu8 preamble = RADIO_PREAMBLE_SHORT;\n\n\tif (dev == priv->mesh_dev)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!sme->bssid) {\n\t\tstruct cfg80211_scan_request *creq;\n\n\t\t \n\t\tlbs_deb_assoc(\"assoc: waiting for existing scans\\n\");\n\t\twait_event_interruptible_timeout(priv->scan_q,\n\t\t\t\t\t\t (priv->scan_req == NULL),\n\t\t\t\t\t\t (15 * HZ));\n\n\t\tcreq = _new_connect_scan_req(wiphy, sme);\n\t\tif (!creq) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\n\t\tlbs_deb_assoc(\"assoc: scanning for compatible AP\\n\");\n\t\t_internal_start_scan(priv, true, creq);\n\n\t\tlbs_deb_assoc(\"assoc: waiting for scan to complete\\n\");\n\t\twait_event_interruptible_timeout(priv->scan_q,\n\t\t\t\t\t\t (priv->scan_req == NULL),\n\t\t\t\t\t\t (15 * HZ));\n\t\tlbs_deb_assoc(\"assoc: scanning completed\\n\");\n\t}\n\n\t \n\tbss = cfg80211_get_bss(wiphy, sme->channel, sme->bssid,\n\t\tsme->ssid, sme->ssid_len, IEEE80211_BSS_TYPE_ESS,\n\t\tIEEE80211_PRIVACY_ANY);\n\tif (!bss) {\n\t\twiphy_err(wiphy, \"assoc: bss %pM not in scan results\\n\",\n\t\t\t  sme->bssid);\n\t\tret = -ENOENT;\n\t\tgoto done;\n\t}\n\tlbs_deb_assoc(\"trying %pM\\n\", bss->bssid);\n\tlbs_deb_assoc(\"cipher 0x%x, key index %d, key len %d\\n\",\n\t\t      sme->crypto.cipher_group,\n\t\t      sme->key_idx, sme->key_len);\n\n\t \n\tpriv->wep_tx_key = 0;\n\tmemset(priv->wep_key, 0, sizeof(priv->wep_key));\n\tmemset(priv->wep_key_len, 0, sizeof(priv->wep_key_len));\n\n\t \n\tswitch (sme->crypto.cipher_group) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\t \n\t\tpriv->wep_tx_key = sme->key_idx;\n\t\tpriv->wep_key_len[sme->key_idx] = sme->key_len;\n\t\tmemcpy(priv->wep_key[sme->key_idx], sme->key, sme->key_len);\n\t\t \n\t\tlbs_set_wep_keys(priv);\n\t\tpriv->mac_control |= CMD_ACT_MAC_WEP_ENABLE;\n\t\tlbs_set_mac_control(priv);\n\t\t \n\t\tlbs_enable_rsn(priv, 0);\n\t\tbreak;\n\tcase 0:  \n\t\t \n\tcase WLAN_CIPHER_SUITE_TKIP:\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\t \n\t\tlbs_remove_wep_keys(priv);\n\t\tpriv->mac_control &= ~CMD_ACT_MAC_WEP_ENABLE;\n\t\tlbs_set_mac_control(priv);\n\n\t\t \n\t\tlbs_set_key_material(priv,\n\t\t\tKEY_TYPE_ID_WEP,  \n\t\t\tKEY_INFO_WPA_UNICAST,\n\t\t\tNULL, 0);\n\t\tlbs_set_key_material(priv,\n\t\t\tKEY_TYPE_ID_WEP,  \n\t\t\tKEY_INFO_WPA_MCAST,\n\t\t\tNULL, 0);\n\t\t \n\t\tlbs_enable_rsn(priv, sme->crypto.cipher_group != 0);\n\t\tbreak;\n\tdefault:\n\t\twiphy_err(wiphy, \"unsupported cipher group 0x%x\\n\",\n\t\t\t  sme->crypto.cipher_group);\n\t\tret = -ENOTSUPP;\n\t\tgoto done;\n\t}\n\n\tret = lbs_set_authtype(priv, sme);\n\tif (ret == -ENOTSUPP) {\n\t\twiphy_err(wiphy, \"unsupported authtype 0x%x\\n\", sme->auth_type);\n\t\tgoto done;\n\t}\n\n\tlbs_set_radio(priv, preamble, 1);\n\n\t \n\tret = lbs_associate(priv, bss, sme);\n\n done:\n\tif (bss)\n\t\tcfg80211_put_bss(wiphy, bss);\n\treturn ret;\n}\n\nint lbs_disconnect(struct lbs_private *priv, u16 reason)\n{\n\tstruct cmd_ds_802_11_deauthenticate cmd;\n\tint ret;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.hdr.size = cpu_to_le16(sizeof(cmd));\n\t \n\tmemcpy(cmd.macaddr, &priv->assoc_bss, ETH_ALEN);\n\tcmd.reasoncode = cpu_to_le16(reason);\n\n\tret = lbs_cmd_with_response(priv, CMD_802_11_DEAUTHENTICATE, &cmd);\n\tif (ret)\n\t\treturn ret;\n\n\tcfg80211_disconnected(priv->dev,\n\t\t\treason,\n\t\t\tNULL, 0, true,\n\t\t\tGFP_KERNEL);\n\tpriv->connect_status = LBS_DISCONNECTED;\n\n\treturn 0;\n}\n\nstatic int lbs_cfg_disconnect(struct wiphy *wiphy, struct net_device *dev,\n\tu16 reason_code)\n{\n\tstruct lbs_private *priv = wiphy_priv(wiphy);\n\n\tif (dev == priv->mesh_dev)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tpriv->disassoc_reason = reason_code;\n\n\treturn lbs_disconnect(priv, reason_code);\n}\n\nstatic int lbs_cfg_set_default_key(struct wiphy *wiphy,\n\t\t\t\t   struct net_device *netdev, int link_id,\n\t\t\t\t   u8 key_index, bool unicast,\n\t\t\t\t   bool multicast)\n{\n\tstruct lbs_private *priv = wiphy_priv(wiphy);\n\n\tif (netdev == priv->mesh_dev)\n\t\treturn -EOPNOTSUPP;\n\n\tif (key_index != priv->wep_tx_key) {\n\t\tlbs_deb_assoc(\"set_default_key: to %d\\n\", key_index);\n\t\tpriv->wep_tx_key = key_index;\n\t\tlbs_set_wep_keys(priv);\n\t}\n\n\treturn 0;\n}\n\n\nstatic int lbs_cfg_add_key(struct wiphy *wiphy, struct net_device *netdev,\n\t\t\t   int link_id, u8 idx, bool pairwise,\n\t\t\t   const u8 *mac_addr, struct key_params *params)\n{\n\tstruct lbs_private *priv = wiphy_priv(wiphy);\n\tu16 key_info;\n\tu16 key_type;\n\tint ret = 0;\n\n\tif (netdev == priv->mesh_dev)\n\t\treturn -EOPNOTSUPP;\n\n\tlbs_deb_assoc(\"add_key: cipher 0x%x, mac_addr %pM\\n\",\n\t\t      params->cipher, mac_addr);\n\tlbs_deb_assoc(\"add_key: key index %d, key len %d\\n\",\n\t\t      idx, params->key_len);\n\tif (params->key_len)\n\t\tlbs_deb_hex(LBS_DEB_CFG80211, \"KEY\",\n\t\t\t    params->key, params->key_len);\n\n\tlbs_deb_assoc(\"add_key: seq len %d\\n\", params->seq_len);\n\tif (params->seq_len)\n\t\tlbs_deb_hex(LBS_DEB_CFG80211, \"SEQ\",\n\t\t\t    params->seq, params->seq_len);\n\n\tswitch (params->cipher) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\t \n\t\tif ((priv->wep_key_len[idx] != params->key_len) ||\n\t\t\tmemcmp(priv->wep_key[idx],\n\t\t\t       params->key, params->key_len) != 0) {\n\t\t\tpriv->wep_key_len[idx] = params->key_len;\n\t\t\tmemcpy(priv->wep_key[idx],\n\t\t\t       params->key, params->key_len);\n\t\t\tlbs_set_wep_keys(priv);\n\t\t}\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tkey_info = KEY_INFO_WPA_ENABLED | ((idx == 0)\n\t\t\t\t\t\t   ? KEY_INFO_WPA_UNICAST\n\t\t\t\t\t\t   : KEY_INFO_WPA_MCAST);\n\t\tkey_type = (params->cipher == WLAN_CIPHER_SUITE_TKIP)\n\t\t\t? KEY_TYPE_ID_TKIP\n\t\t\t: KEY_TYPE_ID_AES;\n\t\tlbs_set_key_material(priv,\n\t\t\t\t     key_type,\n\t\t\t\t     key_info,\n\t\t\t\t     params->key, params->key_len);\n\t\tbreak;\n\tdefault:\n\t\twiphy_err(wiphy, \"unhandled cipher 0x%x\\n\", params->cipher);\n\t\tret = -ENOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n\nstatic int lbs_cfg_del_key(struct wiphy *wiphy, struct net_device *netdev,\n\t\t\t   int link_id, u8 key_index, bool pairwise,\n\t\t\t   const u8 *mac_addr)\n{\n\n\tlbs_deb_assoc(\"del_key: key_idx %d, mac_addr %pM\\n\",\n\t\t      key_index, mac_addr);\n\n#ifdef TODO\n\tstruct lbs_private *priv = wiphy_priv(wiphy);\n\t \n\tif (key_index < 3 && priv->wep_key_len[key_index]) {\n\t\tpriv->wep_key_len[key_index] = 0;\n\t\tlbs_set_wep_keys(priv);\n\t}\n#endif\n\n\treturn 0;\n}\n\n\n \n\nstatic int lbs_cfg_get_station(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t       const u8 *mac, struct station_info *sinfo)\n{\n\tstruct lbs_private *priv = wiphy_priv(wiphy);\n\ts8 signal, noise;\n\tint ret;\n\tsize_t i;\n\n\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_BYTES) |\n\t\t\t BIT_ULL(NL80211_STA_INFO_TX_PACKETS) |\n\t\t\t BIT_ULL(NL80211_STA_INFO_RX_BYTES) |\n\t\t\t BIT_ULL(NL80211_STA_INFO_RX_PACKETS);\n\tsinfo->tx_bytes = priv->dev->stats.tx_bytes;\n\tsinfo->tx_packets = priv->dev->stats.tx_packets;\n\tsinfo->rx_bytes = priv->dev->stats.rx_bytes;\n\tsinfo->rx_packets = priv->dev->stats.rx_packets;\n\n\t \n\tret = lbs_get_rssi(priv, &signal, &noise);\n\tif (ret == 0) {\n\t\tsinfo->signal = signal;\n\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_SIGNAL);\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(lbs_rates); i++) {\n\t\tif (priv->cur_rate == lbs_rates[i].hw_value) {\n\t\t\tsinfo->txrate.legacy = lbs_rates[i].bitrate;\n\t\t\tsinfo->filled |= BIT_ULL(NL80211_STA_INFO_TX_BITRATE);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n\n\n \n\nstatic int lbs_change_intf(struct wiphy *wiphy, struct net_device *dev,\n\tenum nl80211_iftype type,\n\t       struct vif_params *params)\n{\n\tstruct lbs_private *priv = wiphy_priv(wiphy);\n\tint ret = 0;\n\n\tif (dev == priv->mesh_dev)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (type) {\n\tcase NL80211_IFTYPE_MONITOR:\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (priv->iface_running)\n\t\tret = lbs_set_iface_type(priv, type);\n\n\tif (!ret)\n\t\tpriv->wdev->iftype = type;\n\n\treturn ret;\n}\n\n\n\n \n\n \n#define CAPINFO_MASK (~(0xda00))\n\n\nstatic void lbs_join_post(struct lbs_private *priv,\n\t\t\t  struct cfg80211_ibss_params *params,\n\t\t\t  u8 *bssid, u16 capability)\n{\n\tu8 fake_ie[2 + IEEE80211_MAX_SSID_LEN +  \n\t\t   2 + 4 +                       \n\t\t   2 + 1 +                       \n\t\t   2 + 2 +                       \n\t\t   2 + 8];                       \n\tu8 *fake = fake_ie;\n\tstruct cfg80211_bss *bss;\n\n\t \n\t \n\t*fake++ = WLAN_EID_SSID;\n\t*fake++ = params->ssid_len;\n\tmemcpy(fake, params->ssid, params->ssid_len);\n\tfake += params->ssid_len;\n\t \n\t*fake++ = WLAN_EID_SUPP_RATES;\n\t*fake++ = 4;\n\t*fake++ = 0x82;\n\t*fake++ = 0x84;\n\t*fake++ = 0x8b;\n\t*fake++ = 0x96;\n\t \n\t*fake++ = WLAN_EID_DS_PARAMS;\n\t*fake++ = 1;\n\t*fake++ = params->chandef.chan->hw_value;\n\t \n\t*fake++ = WLAN_EID_IBSS_PARAMS;\n\t*fake++ = 2;\n\t*fake++ = 0;  \n\t*fake++ = 0;\n\t \n\t*fake++ = WLAN_EID_EXT_SUPP_RATES;\n\t*fake++ = 8;\n\t*fake++ = 0x0c;\n\t*fake++ = 0x12;\n\t*fake++ = 0x18;\n\t*fake++ = 0x24;\n\t*fake++ = 0x30;\n\t*fake++ = 0x48;\n\t*fake++ = 0x60;\n\t*fake++ = 0x6c;\n\tlbs_deb_hex(LBS_DEB_CFG80211, \"IE\", fake_ie, fake - fake_ie);\n\n\tbss = cfg80211_inform_bss(priv->wdev->wiphy,\n\t\t\t\t  params->chandef.chan,\n\t\t\t\t  CFG80211_BSS_FTYPE_UNKNOWN,\n\t\t\t\t  bssid,\n\t\t\t\t  0,\n\t\t\t\t  capability,\n\t\t\t\t  params->beacon_interval,\n\t\t\t\t  fake_ie, fake - fake_ie,\n\t\t\t\t  0, GFP_KERNEL);\n\tcfg80211_put_bss(priv->wdev->wiphy, bss);\n\n\tcfg80211_ibss_joined(priv->dev, bssid, params->chandef.chan,\n\t\t\t     GFP_KERNEL);\n\n\t \n\tpriv->connect_status = LBS_CONNECTED;\n\tnetif_carrier_on(priv->dev);\n\tif (!priv->tx_pending_len)\n\t\tnetif_wake_queue(priv->dev);\n}\n\nstatic int lbs_ibss_join_existing(struct lbs_private *priv,\n\tstruct cfg80211_ibss_params *params,\n\tstruct cfg80211_bss *bss)\n{\n\tconst u8 *rates_eid;\n\tstruct cmd_ds_802_11_ad_hoc_join cmd;\n\tu8 preamble = RADIO_PREAMBLE_SHORT;\n\tint ret = 0;\n\tint hw, i;\n\tu8 rates_max;\n\tu8 *rates;\n\n\t \n\tret = lbs_set_radio(priv, preamble, 1);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.hdr.size = cpu_to_le16(sizeof(cmd));\n\n\tmemcpy(cmd.bss.bssid, bss->bssid, ETH_ALEN);\n\tmemcpy(cmd.bss.ssid, params->ssid, params->ssid_len);\n\tcmd.bss.type = CMD_BSS_TYPE_IBSS;\n\tcmd.bss.beaconperiod = cpu_to_le16(params->beacon_interval);\n\tcmd.bss.ds.header.id = WLAN_EID_DS_PARAMS;\n\tcmd.bss.ds.header.len = 1;\n\tcmd.bss.ds.channel = params->chandef.chan->hw_value;\n\tcmd.bss.ibss.header.id = WLAN_EID_IBSS_PARAMS;\n\tcmd.bss.ibss.header.len = 2;\n\tcmd.bss.ibss.atimwindow = 0;\n\tcmd.bss.capability = cpu_to_le16(bss->capability & CAPINFO_MASK);\n\n\t \n\trcu_read_lock();\n\trates_eid = ieee80211_bss_get_ie(bss, WLAN_EID_SUPP_RATES);\n\tif (!rates_eid) {\n\t\tlbs_add_rates(cmd.bss.rates);\n\t} else {\n\t\trates_max = rates_eid[1];\n\t\tif (rates_max > MAX_RATES) {\n\t\t\tlbs_deb_join(\"invalid rates\");\n\t\t\trcu_read_unlock();\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\trates = cmd.bss.rates;\n\t\tfor (hw = 0; hw < ARRAY_SIZE(lbs_rates); hw++) {\n\t\t\tu8 hw_rate = lbs_rates[hw].bitrate / 5;\n\t\t\tfor (i = 0; i < rates_max; i++) {\n\t\t\t\tif (hw_rate == (rates_eid[i+2] & 0x7f)) {\n\t\t\t\t\tu8 rate = rates_eid[i+2];\n\t\t\t\t\tif (rate == 0x02 || rate == 0x04 ||\n\t\t\t\t\t    rate == 0x0b || rate == 0x16)\n\t\t\t\t\t\trate |= 0x80;\n\t\t\t\t\t*rates++ = rate;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\t \n\tif (MRVL_FW_MAJOR_REV(priv->fwrelease) <= 8) {\n\t\tcmd.failtimeout = cpu_to_le16(MRVDRV_ASSOCIATION_TIME_OUT);\n\t\tcmd.probedelay = cpu_to_le16(CMD_SCAN_PROBE_DELAY_TIME);\n\t}\n\tret = lbs_cmd_with_response(priv, CMD_802_11_AD_HOC_JOIN, &cmd);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tlbs_join_post(priv, params, bss->bssid, bss->capability);\n\n out:\n\treturn ret;\n}\n\n\n\nstatic int lbs_ibss_start_new(struct lbs_private *priv,\n\tstruct cfg80211_ibss_params *params)\n{\n\tstruct cmd_ds_802_11_ad_hoc_start cmd;\n\tstruct cmd_ds_802_11_ad_hoc_result *resp =\n\t\t(struct cmd_ds_802_11_ad_hoc_result *) &cmd;\n\tu8 preamble = RADIO_PREAMBLE_SHORT;\n\tint ret = 0;\n\tu16 capability;\n\n\tret = lbs_set_radio(priv, preamble, 1);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.hdr.size = cpu_to_le16(sizeof(cmd));\n\tmemcpy(cmd.ssid, params->ssid, params->ssid_len);\n\tcmd.bsstype = CMD_BSS_TYPE_IBSS;\n\tcmd.beaconperiod = cpu_to_le16(params->beacon_interval);\n\tcmd.ibss.header.id = WLAN_EID_IBSS_PARAMS;\n\tcmd.ibss.header.len = 2;\n\tcmd.ibss.atimwindow = 0;\n\tcmd.ds.header.id = WLAN_EID_DS_PARAMS;\n\tcmd.ds.header.len = 1;\n\tcmd.ds.channel = params->chandef.chan->hw_value;\n\t \n\tif (MRVL_FW_MAJOR_REV(priv->fwrelease) <= 8)\n\t\tcmd.probedelay = cpu_to_le16(CMD_SCAN_PROBE_DELAY_TIME);\n\t \n\tcapability = WLAN_CAPABILITY_IBSS;\n\tcmd.capability = cpu_to_le16(capability);\n\tlbs_add_rates(cmd.rates);\n\n\n\tret = lbs_cmd_with_response(priv, CMD_802_11_AD_HOC_START, &cmd);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tlbs_join_post(priv, params, resp->bssid, capability);\n\n out:\n\treturn ret;\n}\n\n\nstatic int lbs_join_ibss(struct wiphy *wiphy, struct net_device *dev,\n\t\tstruct cfg80211_ibss_params *params)\n{\n\tstruct lbs_private *priv = wiphy_priv(wiphy);\n\tint ret = 0;\n\tstruct cfg80211_bss *bss;\n\n\tif (dev == priv->mesh_dev)\n\t\treturn -EOPNOTSUPP;\n\n\tif (!params->chandef.chan) {\n\t\tret = -ENOTSUPP;\n\t\tgoto out;\n\t}\n\n\tret = lbs_set_channel(priv, params->chandef.chan->hw_value);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tbss = cfg80211_get_bss(wiphy, params->chandef.chan, params->bssid,\n\t\tparams->ssid, params->ssid_len,\n\t\tIEEE80211_BSS_TYPE_IBSS, IEEE80211_PRIVACY_ANY);\n\n\tif (bss) {\n\t\tret = lbs_ibss_join_existing(priv, params, bss);\n\t\tcfg80211_put_bss(wiphy, bss);\n\t} else\n\t\tret = lbs_ibss_start_new(priv, params);\n\n\n out:\n\treturn ret;\n}\n\n\nstatic int lbs_leave_ibss(struct wiphy *wiphy, struct net_device *dev)\n{\n\tstruct lbs_private *priv = wiphy_priv(wiphy);\n\tstruct cmd_ds_802_11_ad_hoc_stop cmd;\n\tint ret = 0;\n\n\tif (dev == priv->mesh_dev)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.hdr.size = cpu_to_le16(sizeof(cmd));\n\tret = lbs_cmd_with_response(priv, CMD_802_11_AD_HOC_STOP, &cmd);\n\n\t \n\tlbs_mac_event_disconnected(priv, true);\n\n\treturn ret;\n}\n\n\n\nstatic int lbs_set_power_mgmt(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t      bool enabled, int timeout)\n{\n\tstruct lbs_private *priv = wiphy_priv(wiphy);\n\n\tif  (!(priv->fwcapinfo & FW_CAPINFO_PS)) {\n\t\tif (!enabled)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\t \n\tif  (priv->is_polling) {\n\t\tif (!enabled)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\tif (!enabled) {\n\t\tpriv->psmode = LBS802_11POWERMODECAM;\n\t\tif (priv->psstate != PS_STATE_FULL_POWER)\n\t\t\tlbs_set_ps_mode(priv,\n\t\t\t\t\tPS_MODE_ACTION_EXIT_PS,\n\t\t\t\t\ttrue);\n\t\treturn 0;\n\t}\n\tif (priv->psmode != LBS802_11POWERMODECAM)\n\t\treturn 0;\n\tpriv->psmode = LBS802_11POWERMODEMAX_PSP;\n\tif (priv->connect_status == LBS_CONNECTED)\n\t\tlbs_set_ps_mode(priv, PS_MODE_ACTION_ENTER_PS, true);\n\treturn 0;\n}\n\n \n\nstatic const struct cfg80211_ops lbs_cfg80211_ops = {\n\t.set_monitor_channel = lbs_cfg_set_monitor_channel,\n\t.libertas_set_mesh_channel = lbs_cfg_set_mesh_channel,\n\t.scan = lbs_cfg_scan,\n\t.connect = lbs_cfg_connect,\n\t.disconnect = lbs_cfg_disconnect,\n\t.add_key = lbs_cfg_add_key,\n\t.del_key = lbs_cfg_del_key,\n\t.set_default_key = lbs_cfg_set_default_key,\n\t.get_station = lbs_cfg_get_station,\n\t.change_virtual_intf = lbs_change_intf,\n\t.join_ibss = lbs_join_ibss,\n\t.leave_ibss = lbs_leave_ibss,\n\t.set_power_mgmt = lbs_set_power_mgmt,\n};\n\n\n \nstruct wireless_dev *lbs_cfg_alloc(struct device *dev)\n{\n\tint ret = 0;\n\tstruct wireless_dev *wdev;\n\n\twdev = kzalloc(sizeof(struct wireless_dev), GFP_KERNEL);\n\tif (!wdev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\twdev->wiphy = wiphy_new(&lbs_cfg80211_ops, sizeof(struct lbs_private));\n\tif (!wdev->wiphy) {\n\t\tdev_err(dev, \"cannot allocate wiphy\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_wiphy_new;\n\t}\n\n\treturn wdev;\n\n err_wiphy_new:\n\tkfree(wdev);\n\treturn ERR_PTR(ret);\n}\n\n\nstatic void lbs_cfg_set_regulatory_hint(struct lbs_private *priv)\n{\n\tstruct region_code_mapping {\n\t\tconst char *cn;\n\t\tint code;\n\t};\n\n\t \n\tstatic const struct region_code_mapping regmap[] = {\n\t\t{\"US \", 0x10},  \n\t\t{\"CA \", 0x20},  \n\t\t{\"EU \", 0x30},  \n\t\t{\"ES \", 0x31},  \n\t\t{\"FR \", 0x32},  \n\t\t{\"JP \", 0x40},  \n\t};\n\tsize_t i;\n\n\tfor (i = 0; i < ARRAY_SIZE(regmap); i++)\n\t\tif (regmap[i].code == priv->regioncode) {\n\t\t\tregulatory_hint(priv->wdev->wiphy, regmap[i].cn);\n\t\t\tbreak;\n\t\t}\n}\n\nstatic void lbs_reg_notifier(struct wiphy *wiphy,\n\t\t\t     struct regulatory_request *request)\n{\n\tstruct lbs_private *priv = wiphy_priv(wiphy);\n\n\tmemcpy(priv->country_code, request->alpha2, sizeof(request->alpha2));\n\tif (lbs_iface_active(priv))\n\t\tlbs_set_11d_domain_info(priv);\n}\n\n \nint lbs_cfg_register(struct lbs_private *priv)\n{\n\tstruct wireless_dev *wdev = priv->wdev;\n\tint ret;\n\n\twdev->wiphy->max_scan_ssids = 1;\n\twdev->wiphy->max_scan_ie_len = 256;\n\twdev->wiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;\n\n\twdev->wiphy->interface_modes =\n\t\t\tBIT(NL80211_IFTYPE_STATION) |\n\t\t\tBIT(NL80211_IFTYPE_ADHOC);\n\tif (lbs_rtap_supported(priv))\n\t\twdev->wiphy->interface_modes |= BIT(NL80211_IFTYPE_MONITOR);\n\tif (lbs_mesh_activated(priv))\n\t\twdev->wiphy->interface_modes |= BIT(NL80211_IFTYPE_MESH_POINT);\n\n\twdev->wiphy->bands[NL80211_BAND_2GHZ] = &lbs_band_2ghz;\n\n\t \n\twdev->wiphy->cipher_suites = cipher_suites;\n\twdev->wiphy->n_cipher_suites = ARRAY_SIZE(cipher_suites);\n\twdev->wiphy->reg_notifier = lbs_reg_notifier;\n\n\tret = wiphy_register(wdev->wiphy);\n\tif (ret < 0)\n\t\tpr_err(\"cannot register wiphy device\\n\");\n\n\tpriv->wiphy_registered = true;\n\n\tret = register_netdev(priv->dev);\n\tif (ret)\n\t\tpr_err(\"cannot register network device\\n\");\n\n\tINIT_DELAYED_WORK(&priv->scan_work, lbs_scan_worker);\n\n\tlbs_cfg_set_regulatory_hint(priv);\n\n\treturn ret;\n}\n\nvoid lbs_scan_deinit(struct lbs_private *priv)\n{\n\tcancel_delayed_work_sync(&priv->scan_work);\n}\n\n\nvoid lbs_cfg_free(struct lbs_private *priv)\n{\n\tstruct wireless_dev *wdev = priv->wdev;\n\n\tif (!wdev)\n\t\treturn;\n\n\tif (priv->wiphy_registered)\n\t\twiphy_unregister(wdev->wiphy);\n\n\tif (wdev->wiphy)\n\t\twiphy_free(wdev->wiphy);\n\n\tkfree(wdev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}