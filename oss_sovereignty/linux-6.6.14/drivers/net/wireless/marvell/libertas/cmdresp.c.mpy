{
  "module_name": "cmdresp.c",
  "hash_id": "21035d2ef097a592d72e10514955fb26d07d0b4a02a2aa285de47a171e4c869c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/marvell/libertas/cmdresp.c",
  "human_readable_source": "\n \n\n#include <linux/hardirq.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/sched.h>\n#include <asm/unaligned.h>\n#include <net/cfg80211.h>\n\n#include \"cfg.h\"\n#include \"cmd.h\"\n\n \nvoid lbs_mac_event_disconnected(struct lbs_private *priv,\n\t\t\t\tbool locally_generated)\n{\n\tunsigned long flags;\n\n\tif (priv->connect_status != LBS_CONNECTED)\n\t\treturn;\n\n\t \n\tmsleep_interruptible(1000);\n\n\tif (priv->wdev->iftype == NL80211_IFTYPE_STATION)\n\t\tlbs_send_disconnect_notification(priv, locally_generated);\n\n\t \n\tnetif_stop_queue(priv->dev);\n\tnetif_carrier_off(priv->dev);\n\n\t \n\tspin_lock_irqsave(&priv->driver_lock, flags);\n\tdev_kfree_skb_irq(priv->currenttxskb);\n\tpriv->currenttxskb = NULL;\n\tpriv->tx_pending_len = 0;\n\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\n\tpriv->connect_status = LBS_DISCONNECTED;\n\n\tif (priv->psstate != PS_STATE_FULL_POWER) {\n\t\t \n\t\tlbs_deb_cmd(\"disconnected, so exit PS mode\\n\");\n\t\tlbs_set_ps_mode(priv, PS_MODE_ACTION_EXIT_PS, false);\n\t}\n}\n\nint lbs_process_command_response(struct lbs_private *priv, u8 *data, u32 len)\n{\n\tuint16_t respcmd, curcmd;\n\tstruct cmd_header *resp;\n\tint ret = 0;\n\tunsigned long flags;\n\tuint16_t result;\n\n\tmutex_lock(&priv->lock);\n\tspin_lock_irqsave(&priv->driver_lock, flags);\n\n\tif (!priv->cur_cmd) {\n\t\tlbs_deb_host(\"CMD_RESP: cur_cmd is NULL\\n\");\n\t\tret = -1;\n\t\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\t\tgoto done;\n\t}\n\n\tresp = (void *)data;\n\tcurcmd = le16_to_cpu(priv->cur_cmd->cmdbuf->command);\n\trespcmd = le16_to_cpu(resp->command);\n\tresult = le16_to_cpu(resp->result);\n\n\tlbs_deb_cmd(\"CMD_RESP: response 0x%04x, seq %d, size %d\\n\",\n\t\t     respcmd, le16_to_cpu(resp->seqnum), len);\n\tlbs_deb_hex(LBS_DEB_CMD, \"CMD_RESP\", (void *) resp, len);\n\n\tif (resp->seqnum != priv->cur_cmd->cmdbuf->seqnum) {\n\t\tnetdev_info(priv->dev,\n\t\t\t    \"Received CMD_RESP with invalid sequence %d (expected %d)\\n\",\n\t\t\t    le16_to_cpu(resp->seqnum),\n\t\t\t    le16_to_cpu(priv->cur_cmd->cmdbuf->seqnum));\n\t\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\t\tret = -1;\n\t\tgoto done;\n\t}\n\tif (respcmd != CMD_RET(curcmd) &&\n\t    respcmd != CMD_RET_802_11_ASSOCIATE && curcmd != CMD_802_11_ASSOCIATE) {\n\t\tnetdev_info(priv->dev, \"Invalid CMD_RESP %x to command %x!\\n\",\n\t\t\t    respcmd, curcmd);\n\t\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\t\tret = -1;\n\t\tgoto done;\n\t}\n\n\tif (resp->result == cpu_to_le16(0x0004)) {\n\t\t \n\t\tnetdev_info(priv->dev,\n\t\t\t    \"Firmware returns DEFER to command %x. Will let it time out...\\n\",\n\t\t\t    le16_to_cpu(resp->command));\n\t\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\t\tret = -1;\n\t\tgoto done;\n\t}\n\n\t \n\tdel_timer(&priv->command_timer);\n\tpriv->cmd_timed_out = 0;\n\n\tif (respcmd == CMD_RET(CMD_802_11_PS_MODE)) {\n\t\t \n\t\tstruct cmd_ds_802_11_ps_mode *psmode = (void *)resp;\n\t\tu16 action = le16_to_cpu(psmode->action);\n\n\t\tlbs_deb_host(\n\t\t       \"CMD_RESP: PS_MODE cmd reply result 0x%x, action 0x%x\\n\",\n\t\t       result, action);\n\n\t\tif (result) {\n\t\t\tlbs_deb_host(\"CMD_RESP: PS command failed with 0x%x\\n\",\n\t\t\t\t    result);\n\t\t\t \n\t\t\tif (priv->wdev->iftype == NL80211_IFTYPE_MONITOR &&\n\t\t\t    action == PS_MODE_ACTION_ENTER_PS)\n\t\t\t\tpriv->psmode = LBS802_11POWERMODECAM;\n\t\t} else if (action == PS_MODE_ACTION_ENTER_PS) {\n\t\t\tpriv->needtowakeup = 0;\n\t\t\tpriv->psstate = PS_STATE_AWAKE;\n\n\t\t\tlbs_deb_host(\"CMD_RESP: ENTER_PS command response\\n\");\n\t\t\tif (priv->connect_status != LBS_CONNECTED) {\n\t\t\t\t \n\t\t\t\tlbs_deb_host(\n\t\t\t\t       \"disconnected, invoking lbs_ps_wakeup\\n\");\n\n\t\t\t\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\t\t\t\tmutex_unlock(&priv->lock);\n\t\t\t\tlbs_set_ps_mode(priv, PS_MODE_ACTION_EXIT_PS,\n\t\t\t\t\t\tfalse);\n\t\t\t\tmutex_lock(&priv->lock);\n\t\t\t\tspin_lock_irqsave(&priv->driver_lock, flags);\n\t\t\t}\n\t\t} else if (action == PS_MODE_ACTION_EXIT_PS) {\n\t\t\tpriv->needtowakeup = 0;\n\t\t\tpriv->psstate = PS_STATE_FULL_POWER;\n\t\t\tlbs_deb_host(\"CMD_RESP: EXIT_PS command response\\n\");\n\t\t} else {\n\t\t\tlbs_deb_host(\"CMD_RESP: PS action 0x%X\\n\", action);\n\t\t}\n\n\t\t__lbs_complete_command(priv, priv->cur_cmd, result);\n\t\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\n\t\tret = 0;\n\t\tgoto done;\n\t}\n\n\t \n\tif ((result != 0 || !(respcmd & 0x8000))) {\n\t\tlbs_deb_host(\"CMD_RESP: error 0x%04x in command reply 0x%04x\\n\",\n\t\t       result, respcmd);\n\t\t \n\t\tswitch (respcmd) {\n\t\tcase CMD_RET(CMD_GET_HW_SPEC):\n\t\tcase CMD_RET(CMD_802_11_RESET):\n\t\t\tlbs_deb_host(\"CMD_RESP: reset failed\\n\");\n\t\t\tbreak;\n\n\t\t}\n\t\t__lbs_complete_command(priv, priv->cur_cmd, result);\n\t\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\n\t\tret = -1;\n\t\tgoto done;\n\t}\n\n\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\n\tif (priv->cur_cmd && priv->cur_cmd->callback) {\n\t\tret = priv->cur_cmd->callback(priv, priv->cur_cmd->callback_arg,\n\t\t\t\tresp);\n\t}\n\n\tspin_lock_irqsave(&priv->driver_lock, flags);\n\n\tif (priv->cur_cmd) {\n\t\t \n\t\t__lbs_complete_command(priv, priv->cur_cmd, result);\n\t}\n\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\ndone:\n\tmutex_unlock(&priv->lock);\n\treturn ret;\n}\n\nvoid lbs_process_event(struct lbs_private *priv, u32 event)\n{\n\tstruct cmd_header cmd;\n\n\tswitch (event) {\n\tcase MACREG_INT_CODE_LINK_SENSED:\n\t\tlbs_deb_cmd(\"EVENT: link sensed\\n\");\n\t\tbreak;\n\n\tcase MACREG_INT_CODE_DEAUTHENTICATED:\n\t\tlbs_deb_cmd(\"EVENT: deauthenticated\\n\");\n\t\tlbs_mac_event_disconnected(priv, false);\n\t\tbreak;\n\n\tcase MACREG_INT_CODE_DISASSOCIATED:\n\t\tlbs_deb_cmd(\"EVENT: disassociated\\n\");\n\t\tlbs_mac_event_disconnected(priv, false);\n\t\tbreak;\n\n\tcase MACREG_INT_CODE_LINK_LOST_NO_SCAN:\n\t\tlbs_deb_cmd(\"EVENT: link lost\\n\");\n\t\tlbs_mac_event_disconnected(priv, true);\n\t\tbreak;\n\n\tcase MACREG_INT_CODE_PS_SLEEP:\n\t\tlbs_deb_cmd(\"EVENT: ps sleep\\n\");\n\n\t\t \n\t\tif (priv->psstate == PS_STATE_FULL_POWER) {\n\t\t\tlbs_deb_cmd(\n\t\t\t       \"EVENT: in FULL POWER mode, ignoring PS_SLEEP\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (!list_empty(&priv->cmdpendingq)) {\n\t\t\tlbs_deb_cmd(\"EVENT: commands in queue, do not sleep\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tpriv->psstate = PS_STATE_PRE_SLEEP;\n\n\t\tlbs_ps_confirm_sleep(priv);\n\n\t\tbreak;\n\n\tcase MACREG_INT_CODE_HOST_AWAKE:\n\t\tlbs_deb_cmd(\"EVENT: host awake\\n\");\n\t\tif (priv->reset_deep_sleep_wakeup)\n\t\t\tpriv->reset_deep_sleep_wakeup(priv);\n\t\tpriv->is_deep_sleep = 0;\n\t\tlbs_cmd_async(priv, CMD_802_11_WAKEUP_CONFIRM, &cmd,\n\t\t\t\tsizeof(cmd));\n\t\tpriv->is_host_sleep_activated = 0;\n\t\twake_up_interruptible(&priv->host_sleep_q);\n\t\tbreak;\n\n\tcase MACREG_INT_CODE_DEEP_SLEEP_AWAKE:\n\t\tif (priv->reset_deep_sleep_wakeup)\n\t\t\tpriv->reset_deep_sleep_wakeup(priv);\n\t\tlbs_deb_cmd(\"EVENT: ds awake\\n\");\n\t\tpriv->is_deep_sleep = 0;\n\t\tpriv->wakeup_dev_required = 0;\n\t\twake_up_interruptible(&priv->ds_awake_q);\n\t\tbreak;\n\n\tcase MACREG_INT_CODE_PS_AWAKE:\n\t\tlbs_deb_cmd(\"EVENT: ps awake\\n\");\n\t\t \n\t\tif (priv->psstate == PS_STATE_FULL_POWER) {\n\t\t\tlbs_deb_cmd(\n\t\t\t       \"EVENT: In FULL POWER mode - ignore PS AWAKE\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tpriv->psstate = PS_STATE_AWAKE;\n\n\t\tif (priv->needtowakeup) {\n\t\t\t \n\t\t\tlbs_deb_cmd(\"waking up ...\\n\");\n\t\t\tlbs_set_ps_mode(priv, PS_MODE_ACTION_EXIT_PS, false);\n\t\t}\n\t\tbreak;\n\n\tcase MACREG_INT_CODE_MIC_ERR_UNICAST:\n\t\tlbs_deb_cmd(\"EVENT: UNICAST MIC ERROR\\n\");\n\t\tlbs_send_mic_failureevent(priv, event);\n\t\tbreak;\n\n\tcase MACREG_INT_CODE_MIC_ERR_MULTICAST:\n\t\tlbs_deb_cmd(\"EVENT: MULTICAST MIC ERROR\\n\");\n\t\tlbs_send_mic_failureevent(priv, event);\n\t\tbreak;\n\n\tcase MACREG_INT_CODE_MIB_CHANGED:\n\t\tlbs_deb_cmd(\"EVENT: MIB CHANGED\\n\");\n\t\tbreak;\n\tcase MACREG_INT_CODE_INIT_DONE:\n\t\tlbs_deb_cmd(\"EVENT: INIT DONE\\n\");\n\t\tbreak;\n\tcase MACREG_INT_CODE_ADHOC_BCN_LOST:\n\t\tlbs_deb_cmd(\"EVENT: ADHOC beacon lost\\n\");\n\t\tbreak;\n\tcase MACREG_INT_CODE_RSSI_LOW:\n\t\tnetdev_alert(priv->dev, \"EVENT: rssi low\\n\");\n\t\tbreak;\n\tcase MACREG_INT_CODE_SNR_LOW:\n\t\tnetdev_alert(priv->dev, \"EVENT: snr low\\n\");\n\t\tbreak;\n\tcase MACREG_INT_CODE_MAX_FAIL:\n\t\tnetdev_alert(priv->dev, \"EVENT: max fail\\n\");\n\t\tbreak;\n\tcase MACREG_INT_CODE_RSSI_HIGH:\n\t\tnetdev_alert(priv->dev, \"EVENT: rssi high\\n\");\n\t\tbreak;\n\tcase MACREG_INT_CODE_SNR_HIGH:\n\t\tnetdev_alert(priv->dev, \"EVENT: snr high\\n\");\n\t\tbreak;\n\n\tcase MACREG_INT_CODE_MESH_AUTO_STARTED:\n\t\t \n\t\tnetdev_info(priv->dev, \"EVENT: MESH_AUTO_STARTED (ignoring)\\n\");\n\t\tbreak;\n\n\tdefault:\n\t\tnetdev_alert(priv->dev, \"EVENT: unknown event id %d\\n\", event);\n\t\tbreak;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}