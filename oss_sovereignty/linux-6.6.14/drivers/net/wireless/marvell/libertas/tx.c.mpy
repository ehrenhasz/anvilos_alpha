{
  "module_name": "tx.c",
  "hash_id": "1edc475def01bcbffeeef68fc27e2b25b51ba6fd0a05073d33073cb7839dbf80",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/marvell/libertas/tx.c",
  "human_readable_source": "\n \n#include <linux/hardirq.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n#include <net/cfg80211.h>\n\n#include \"host.h\"\n#include \"radiotap.h\"\n#include \"decl.h\"\n#include \"defs.h\"\n#include \"dev.h\"\n#include \"mesh.h\"\n\n \nstatic u32 convert_radiotap_rate_to_mv(u8 rate)\n{\n\tswitch (rate) {\n\tcase 2:\t\t \n\t\treturn 0 | (1 << 4);\n\tcase 4:\t\t \n\t\treturn 1 | (1 << 4);\n\tcase 11:\t\t \n\t\treturn 2 | (1 << 4);\n\tcase 22:\t\t \n\t\treturn 3 | (1 << 4);\n\tcase 12:\t\t \n\t\treturn 4 | (1 << 4);\n\tcase 18:\t\t \n\t\treturn 5 | (1 << 4);\n\tcase 24:\t\t \n\t\treturn 6 | (1 << 4);\n\tcase 36:\t\t \n\t\treturn 7 | (1 << 4);\n\tcase 48:\t\t \n\t\treturn 8 | (1 << 4);\n\tcase 72:\t\t \n\t\treturn 9 | (1 << 4);\n\tcase 96:\t\t \n\t\treturn 10 | (1 << 4);\n\tcase 108:\t\t \n\t\treturn 11 | (1 << 4);\n\t}\n\treturn 0;\n}\n\n \nnetdev_tx_t lbs_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tunsigned long flags;\n\tstruct lbs_private *priv = dev->ml_priv;\n\tstruct txpd *txpd;\n\tchar *p802x_hdr;\n\tuint16_t pkt_len;\n\tnetdev_tx_t ret = NETDEV_TX_OK;\n\n\t \n\tspin_lock_irqsave(&priv->driver_lock, flags);\n\n\tif (priv->surpriseremoved)\n\t\tgoto free;\n\n\tif (!skb->len || (skb->len > MRVDRV_ETH_TX_PACKET_BUFFER_SIZE)) {\n\t\tlbs_deb_tx(\"tx err: skb length %d 0 or > %zd\\n\",\n\t\t       skb->len, MRVDRV_ETH_TX_PACKET_BUFFER_SIZE);\n\t\t \n\n\t\tdev->stats.tx_dropped++;\n\t\tdev->stats.tx_errors++;\n\t\tgoto free;\n\t}\n\n\n\tnetif_stop_queue(priv->dev);\n\tif (priv->mesh_dev)\n\t\tnetif_stop_queue(priv->mesh_dev);\n\n\tif (priv->tx_pending_len) {\n\t\t \n\t\tlbs_deb_tx(\"Packet on %s while busy\\n\", dev->name);\n\t\tret = NETDEV_TX_BUSY;\n\t\tgoto unlock;\n\t}\n\n\tpriv->tx_pending_len = -1;\n\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\n\tlbs_deb_hex(LBS_DEB_TX, \"TX Data\", skb->data, min_t(unsigned int, skb->len, 100));\n\n\ttxpd = (void *)priv->tx_pending_buf;\n\tmemset(txpd, 0, sizeof(struct txpd));\n\n\tp802x_hdr = skb->data;\n\tpkt_len = skb->len;\n\n\tBUILD_BUG_ON(sizeof(txpd->tx_dest_addr) != ETH_ALEN);\n\tif (priv->wdev->iftype == NL80211_IFTYPE_MONITOR) {\n\t\tstruct tx_radiotap_hdr *rtap_hdr = (void *)skb->data;\n\n\t\t \n\t\ttxpd->tx_control = cpu_to_le32(convert_radiotap_rate_to_mv(rtap_hdr->rate));\n\n\t\t \n\t\tp802x_hdr += sizeof(*rtap_hdr);\n\t\tpkt_len -= sizeof(*rtap_hdr);\n\n\t\t \n\t\tmemcpy(&txpd->tx_dest_addr, p802x_hdr + 4, ETH_ALEN);\n\t} else {\n\t\t \n\t\tmemcpy(&txpd->tx_dest_addr, p802x_hdr, ETH_ALEN);\n\t}\n\n\ttxpd->tx_packet_length = cpu_to_le16(pkt_len);\n\ttxpd->tx_packet_location = cpu_to_le32(sizeof(struct txpd));\n\n\tlbs_mesh_set_txpd(priv, dev, txpd);\n\n\tlbs_deb_hex(LBS_DEB_TX, \"txpd\", (u8 *) &txpd, sizeof(struct txpd));\n\n\tlbs_deb_hex(LBS_DEB_TX, \"Tx Data\", (u8 *) p802x_hdr, le16_to_cpu(txpd->tx_packet_length));\n\n\tmemcpy(&txpd[1], p802x_hdr, le16_to_cpu(txpd->tx_packet_length));\n\n\tspin_lock_irqsave(&priv->driver_lock, flags);\n\tpriv->tx_pending_len = pkt_len + sizeof(struct txpd);\n\n\tlbs_deb_tx(\"%s lined up packet\\n\", __func__);\n\n\tdev->stats.tx_packets++;\n\tdev->stats.tx_bytes += skb->len;\n\n\tif (priv->wdev->iftype == NL80211_IFTYPE_MONITOR) {\n\t\t \n\t\tskb_orphan(skb);\n\n\t\t \n\t\tpriv->currenttxskb = skb;\n\t} else {\n free:\n\t\tdev_kfree_skb_any(skb);\n\t}\n\n unlock:\n\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\twake_up(&priv->waitq);\n\n\treturn ret;\n}\n\n \nvoid lbs_send_tx_feedback(struct lbs_private *priv, u32 try_count)\n{\n\tstruct tx_radiotap_hdr *radiotap_hdr;\n\n\tif (priv->wdev->iftype != NL80211_IFTYPE_MONITOR ||\n\t    priv->currenttxskb == NULL)\n\t\treturn;\n\n\tradiotap_hdr = (struct tx_radiotap_hdr *)priv->currenttxskb->data;\n\n\tradiotap_hdr->data_retries = try_count ?\n\t\t(1 + priv->txretrycount - try_count) : 0;\n\n\tpriv->currenttxskb->protocol = eth_type_trans(priv->currenttxskb,\n\t\t\t\t\t\t      priv->dev);\n\tnetif_rx(priv->currenttxskb);\n\n\tpriv->currenttxskb = NULL;\n\n\tif (priv->connect_status == LBS_CONNECTED)\n\t\tnetif_wake_queue(priv->dev);\n\n\tif (priv->mesh_dev && netif_running(priv->mesh_dev))\n\t\tnetif_wake_queue(priv->mesh_dev);\n}\nEXPORT_SYMBOL_GPL(lbs_send_tx_feedback);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}