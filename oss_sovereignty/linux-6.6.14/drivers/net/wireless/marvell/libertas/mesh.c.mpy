{
  "module_name": "mesh.c",
  "hash_id": "630baae4442f167284450189860bc5ba75805b3146c1af64b926e814eefb4ce6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/marvell/libertas/mesh.c",
  "human_readable_source": "\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/delay.h>\n#include <linux/etherdevice.h>\n#include <linux/hardirq.h>\n#include <linux/netdevice.h>\n#include <linux/if_ether.h>\n#include <linux/if_arp.h>\n#include <linux/kthread.h>\n#include <linux/kfifo.h>\n#include <net/cfg80211.h>\n\n#include \"mesh.h\"\n#include \"decl.h\"\n#include \"cmd.h\"\n\n\nstatic int lbs_add_mesh(struct lbs_private *priv);\n\n \n\nstatic int lbs_mesh_access(struct lbs_private *priv, uint16_t cmd_action,\n\t\t    struct cmd_ds_mesh_access *cmd)\n{\n\tint ret;\n\n\tcmd->hdr.command = cpu_to_le16(CMD_MESH_ACCESS);\n\tcmd->hdr.size = cpu_to_le16(sizeof(*cmd));\n\tcmd->hdr.result = 0;\n\n\tcmd->action = cpu_to_le16(cmd_action);\n\n\tret = lbs_cmd_with_response(priv, CMD_MESH_ACCESS, cmd);\n\n\treturn ret;\n}\n\nstatic int __lbs_mesh_config_send(struct lbs_private *priv,\n\t\t\t\t  struct cmd_ds_mesh_config *cmd,\n\t\t\t\t  uint16_t action, uint16_t type)\n{\n\tint ret;\n\tu16 command = CMD_MESH_CONFIG_OLD;\n\n\t \n\tif (priv->mesh_tlv == TLV_TYPE_MESH_ID)\n\t\tcommand = CMD_MESH_CONFIG |\n\t\t\t  (MESH_IFACE_ID << MESH_IFACE_BIT_OFFSET);\n\n\tcmd->hdr.command = cpu_to_le16(command);\n\tcmd->hdr.size = cpu_to_le16(sizeof(struct cmd_ds_mesh_config));\n\tcmd->hdr.result = 0;\n\n\tcmd->type = cpu_to_le16(type);\n\tcmd->action = cpu_to_le16(action);\n\n\tret = lbs_cmd_with_response(priv, command, cmd);\n\n\treturn ret;\n}\n\nstatic int lbs_mesh_config_send(struct lbs_private *priv,\n\t\t\t struct cmd_ds_mesh_config *cmd,\n\t\t\t uint16_t action, uint16_t type)\n{\n\tint ret;\n\n\tif (!(priv->fwcapinfo & FW_CAPINFO_PERSISTENT_CONFIG))\n\t\treturn -EOPNOTSUPP;\n\n\tret = __lbs_mesh_config_send(priv, cmd, action, type);\n\treturn ret;\n}\n\n \nstatic int lbs_mesh_config(struct lbs_private *priv, uint16_t action,\n\t\tuint16_t chan)\n{\n\tstruct wireless_dev *mesh_wdev;\n\tstruct cmd_ds_mesh_config cmd;\n\tstruct mrvl_meshie *ie;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.channel = cpu_to_le16(chan);\n\tie = (struct mrvl_meshie *)cmd.data;\n\n\tswitch (action) {\n\tcase CMD_ACT_MESH_CONFIG_START:\n\t\tie->id = WLAN_EID_VENDOR_SPECIFIC;\n\t\tie->val.oui[0] = 0x00;\n\t\tie->val.oui[1] = 0x50;\n\t\tie->val.oui[2] = 0x43;\n\t\tie->val.type = MARVELL_MESH_IE_TYPE;\n\t\tie->val.subtype = MARVELL_MESH_IE_SUBTYPE;\n\t\tie->val.version = MARVELL_MESH_IE_VERSION;\n\t\tie->val.active_protocol_id = MARVELL_MESH_PROTO_ID_HWMP;\n\t\tie->val.active_metric_id = MARVELL_MESH_METRIC_ID;\n\t\tie->val.mesh_capability = MARVELL_MESH_CAPABILITY;\n\n\t\tif (priv->mesh_dev) {\n\t\t\tmesh_wdev = priv->mesh_dev->ieee80211_ptr;\n\t\t\tie->val.mesh_id_len = mesh_wdev->u.mesh.id_up_len;\n\t\t\tmemcpy(ie->val.mesh_id, mesh_wdev->u.mesh.id,\n\t\t\t\t\t\tmesh_wdev->u.mesh.id_up_len);\n\t\t}\n\n\t\tie->len = sizeof(struct mrvl_meshie_val) -\n\t\t\tIEEE80211_MAX_SSID_LEN + ie->val.mesh_id_len;\n\n\t\tcmd.length = cpu_to_le16(sizeof(struct mrvl_meshie_val));\n\t\tbreak;\n\tcase CMD_ACT_MESH_CONFIG_STOP:\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\tlbs_deb_cmd(\"mesh config action %d type %x channel %d SSID %*pE\\n\",\n\t\t    action, priv->mesh_tlv, chan, ie->val.mesh_id_len,\n\t\t    ie->val.mesh_id);\n\n\treturn __lbs_mesh_config_send(priv, &cmd, action, priv->mesh_tlv);\n}\n\nint lbs_mesh_set_channel(struct lbs_private *priv, u8 channel)\n{\n\tpriv->mesh_channel = channel;\n\treturn lbs_mesh_config(priv, CMD_ACT_MESH_CONFIG_START, channel);\n}\n\nstatic uint16_t lbs_mesh_get_channel(struct lbs_private *priv)\n{\n\treturn priv->mesh_channel ?: 1;\n}\n\n \n\n \n\n \nstatic ssize_t anycast_mask_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct lbs_private *priv = to_net_dev(dev)->ml_priv;\n\tstruct cmd_ds_mesh_access mesh_access;\n\tint ret;\n\n\tmemset(&mesh_access, 0, sizeof(mesh_access));\n\n\tret = lbs_mesh_access(priv, CMD_ACT_MESH_GET_ANYCAST, &mesh_access);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"0x%X\\n\", le32_to_cpu(mesh_access.data[0]));\n}\n\n \nstatic ssize_t anycast_mask_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t count)\n{\n\tstruct lbs_private *priv = to_net_dev(dev)->ml_priv;\n\tstruct cmd_ds_mesh_access mesh_access;\n\tuint32_t datum;\n\tint ret;\n\n\tret = kstrtouint(buf, 16, &datum);\n\tif (ret)\n\t\treturn ret;\n\n\tmemset(&mesh_access, 0, sizeof(mesh_access));\n\tmesh_access.data[0] = cpu_to_le32(datum);\n\n\tret = lbs_mesh_access(priv, CMD_ACT_MESH_SET_ANYCAST, &mesh_access);\n\tif (ret)\n\t\treturn ret;\n\n\treturn strlen(buf);\n}\n\n \nstatic ssize_t prb_rsp_limit_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct lbs_private *priv = to_net_dev(dev)->ml_priv;\n\tstruct cmd_ds_mesh_access mesh_access;\n\tint ret;\n\tu32 retry_limit;\n\n\tmemset(&mesh_access, 0, sizeof(mesh_access));\n\tmesh_access.data[0] = cpu_to_le32(CMD_ACT_GET);\n\n\tret = lbs_mesh_access(priv, CMD_ACT_MESH_SET_GET_PRB_RSP_LIMIT,\n\t\t\t&mesh_access);\n\tif (ret)\n\t\treturn ret;\n\n\tretry_limit = le32_to_cpu(mesh_access.data[1]);\n\treturn sysfs_emit(buf, \"%d\\n\", retry_limit);\n}\n\n \nstatic ssize_t prb_rsp_limit_store(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tstruct lbs_private *priv = to_net_dev(dev)->ml_priv;\n\tstruct cmd_ds_mesh_access mesh_access;\n\tint ret;\n\tunsigned long retry_limit;\n\n\tret = kstrtoul(buf, 10, &retry_limit);\n\tif (ret)\n\t\treturn ret;\n\tif (retry_limit > 15)\n\t\treturn -ENOTSUPP;\n\n\tmemset(&mesh_access, 0, sizeof(mesh_access));\n\tmesh_access.data[0] = cpu_to_le32(CMD_ACT_SET);\n\tmesh_access.data[1] = cpu_to_le32(retry_limit);\n\n\tret = lbs_mesh_access(priv, CMD_ACT_MESH_SET_GET_PRB_RSP_LIMIT,\n\t\t\t&mesh_access);\n\tif (ret)\n\t\treturn ret;\n\n\treturn strlen(buf);\n}\n\n \nstatic ssize_t lbs_mesh_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct lbs_private *priv = to_net_dev(dev)->ml_priv;\n\treturn sysfs_emit(buf, \"0x%X\\n\", !!priv->mesh_dev);\n}\n\n \nstatic ssize_t lbs_mesh_store(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct lbs_private *priv = to_net_dev(dev)->ml_priv;\n\tint ret, enable;\n\n\tret = kstrtoint(buf, 16, &enable);\n\tif (ret)\n\t\treturn ret;\n\n\tenable = !!enable;\n\tif (enable == !!priv->mesh_dev)\n\t\treturn count;\n\n\tif (enable)\n\t\tlbs_add_mesh(priv);\n\telse\n\t\tlbs_remove_mesh(priv);\n\n\treturn count;\n}\n\n \nstatic DEVICE_ATTR_RW(lbs_mesh);\n\n \nstatic DEVICE_ATTR_RW(anycast_mask);\n\n \nstatic DEVICE_ATTR_RW(prb_rsp_limit);\n\nstatic struct attribute *lbs_mesh_sysfs_entries[] = {\n\t&dev_attr_anycast_mask.attr,\n\t&dev_attr_prb_rsp_limit.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group lbs_mesh_attr_group = {\n\t.attrs = lbs_mesh_sysfs_entries,\n};\n\n\n \n\nstatic int mesh_get_default_parameters(struct device *dev,\n\t\t\t\t       struct mrvl_mesh_defaults *defs)\n{\n\tstruct lbs_private *priv = to_net_dev(dev)->ml_priv;\n\tstruct cmd_ds_mesh_config cmd;\n\tint ret;\n\n\tmemset(&cmd, 0, sizeof(struct cmd_ds_mesh_config));\n\tret = lbs_mesh_config_send(priv, &cmd, CMD_ACT_MESH_CONFIG_GET,\n\t\t\t\t   CMD_TYPE_MESH_GET_DEFAULTS);\n\n\tif (ret)\n\t\treturn -EOPNOTSUPP;\n\n\tmemcpy(defs, &cmd.data[0], sizeof(struct mrvl_mesh_defaults));\n\n\treturn 0;\n}\n\n \nstatic ssize_t bootflag_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct mrvl_mesh_defaults defs;\n\tint ret;\n\n\tret = mesh_get_default_parameters(dev, &defs);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%d\\n\", le32_to_cpu(defs.bootflag));\n}\n\n \nstatic ssize_t bootflag_store(struct device *dev, struct device_attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct lbs_private *priv = to_net_dev(dev)->ml_priv;\n\tstruct cmd_ds_mesh_config cmd;\n\tuint32_t datum;\n\tint ret;\n\n\tret = kstrtouint(buf, 10, &datum);\n\tif (ret)\n\t\treturn ret;\n\tif (datum > 1)\n\t\treturn -EINVAL;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\t*((__le32 *)&cmd.data[0]) = cpu_to_le32(!!datum);\n\tcmd.length = cpu_to_le16(sizeof(uint32_t));\n\tret = lbs_mesh_config_send(priv, &cmd, CMD_ACT_MESH_CONFIG_SET,\n\t\t\t\t   CMD_TYPE_MESH_SET_BOOTFLAG);\n\tif (ret)\n\t\treturn ret;\n\n\treturn strlen(buf);\n}\n\n \nstatic ssize_t boottime_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct mrvl_mesh_defaults defs;\n\tint ret;\n\n\tret = mesh_get_default_parameters(dev, &defs);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%d\\n\", defs.boottime);\n}\n\n \nstatic ssize_t boottime_store(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      const char *buf, size_t count)\n{\n\tstruct lbs_private *priv = to_net_dev(dev)->ml_priv;\n\tstruct cmd_ds_mesh_config cmd;\n\tuint32_t datum;\n\tint ret;\n\n\tret = kstrtouint(buf, 10, &datum);\n\tif (ret)\n\t\treturn ret;\n\tif (datum > 255)\n\t\treturn -EINVAL;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\n\t \n\tdatum = (datum < 20) ? 20 : datum;\n\tcmd.data[0] = datum;\n\tcmd.length = cpu_to_le16(sizeof(uint8_t));\n\tret = lbs_mesh_config_send(priv, &cmd, CMD_ACT_MESH_CONFIG_SET,\n\t\t\t\t   CMD_TYPE_MESH_SET_BOOTTIME);\n\tif (ret)\n\t\treturn ret;\n\n\treturn strlen(buf);\n}\n\n \nstatic ssize_t channel_show(struct device *dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct mrvl_mesh_defaults defs;\n\tint ret;\n\n\tret = mesh_get_default_parameters(dev, &defs);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%d\\n\", le16_to_cpu(defs.channel));\n}\n\n \nstatic ssize_t channel_store(struct device *dev, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct lbs_private *priv = to_net_dev(dev)->ml_priv;\n\tstruct cmd_ds_mesh_config cmd;\n\tuint32_t datum;\n\tint ret;\n\n\tret = kstrtouint(buf, 10, &datum);\n\tif (ret)\n\t\treturn ret;\n\tif (datum < 1 || datum > 11)\n\t\treturn -EINVAL;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\t*((__le16 *)&cmd.data[0]) = cpu_to_le16(datum);\n\tcmd.length = cpu_to_le16(sizeof(uint16_t));\n\tret = lbs_mesh_config_send(priv, &cmd, CMD_ACT_MESH_CONFIG_SET,\n\t\t\t\t   CMD_TYPE_MESH_SET_DEF_CHANNEL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn strlen(buf);\n}\n\n \nstatic ssize_t mesh_id_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct mrvl_mesh_defaults defs;\n\tint ret;\n\n\tret = mesh_get_default_parameters(dev, &defs);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (defs.meshie.val.mesh_id_len > IEEE80211_MAX_SSID_LEN) {\n\t\tdev_err(dev, \"inconsistent mesh ID length\\n\");\n\t\tdefs.meshie.val.mesh_id_len = IEEE80211_MAX_SSID_LEN;\n\t}\n\n\tmemcpy(buf, defs.meshie.val.mesh_id, defs.meshie.val.mesh_id_len);\n\tbuf[defs.meshie.val.mesh_id_len] = '\\n';\n\tbuf[defs.meshie.val.mesh_id_len + 1] = '\\0';\n\n\treturn defs.meshie.val.mesh_id_len + 1;\n}\n\n \nstatic ssize_t mesh_id_store(struct device *dev, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct cmd_ds_mesh_config cmd;\n\tstruct mrvl_mesh_defaults defs;\n\tstruct mrvl_meshie *ie;\n\tstruct lbs_private *priv = to_net_dev(dev)->ml_priv;\n\tint len;\n\tint ret;\n\n\tif (count < 2 || count > IEEE80211_MAX_SSID_LEN + 1)\n\t\treturn -EINVAL;\n\n\tmemset(&cmd, 0, sizeof(struct cmd_ds_mesh_config));\n\tie = (struct mrvl_meshie *) &cmd.data[0];\n\n\t \n\tret = mesh_get_default_parameters(dev, &defs);\n\n\tcmd.length = cpu_to_le16(sizeof(struct mrvl_meshie));\n\n\t \n\tmemcpy(ie, &defs.meshie, sizeof(struct mrvl_meshie));\n\n\tlen = count - 1;\n\tmemcpy(ie->val.mesh_id, buf, len);\n\t \n\tie->val.mesh_id_len = len;\n\t \n\tie->len = sizeof(struct mrvl_meshie_val) - IEEE80211_MAX_SSID_LEN + len;\n\n\tret = lbs_mesh_config_send(priv, &cmd, CMD_ACT_MESH_CONFIG_SET,\n\t\t\t\t   CMD_TYPE_MESH_SET_MESH_IE);\n\tif (ret)\n\t\treturn ret;\n\n\treturn strlen(buf);\n}\n\n \nstatic ssize_t protocol_id_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tstruct mrvl_mesh_defaults defs;\n\tint ret;\n\n\tret = mesh_get_default_parameters(dev, &defs);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%d\\n\", defs.meshie.val.active_protocol_id);\n}\n\n \nstatic ssize_t protocol_id_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tstruct cmd_ds_mesh_config cmd;\n\tstruct mrvl_mesh_defaults defs;\n\tstruct mrvl_meshie *ie;\n\tstruct lbs_private *priv = to_net_dev(dev)->ml_priv;\n\tuint32_t datum;\n\tint ret;\n\n\tret = kstrtouint(buf, 10, &datum);\n\tif (ret)\n\t\treturn ret;\n\tif (datum > 255)\n\t\treturn -EINVAL;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\n\t \n\tret = mesh_get_default_parameters(dev, &defs);\n\n\tcmd.length = cpu_to_le16(sizeof(struct mrvl_meshie));\n\n\t \n\tie = (struct mrvl_meshie *) &cmd.data[0];\n\tmemcpy(ie, &defs.meshie, sizeof(struct mrvl_meshie));\n\t \n\tie->val.active_protocol_id = datum;\n\n\tret = lbs_mesh_config_send(priv, &cmd, CMD_ACT_MESH_CONFIG_SET,\n\t\t\t\t   CMD_TYPE_MESH_SET_MESH_IE);\n\tif (ret)\n\t\treturn ret;\n\n\treturn strlen(buf);\n}\n\n \nstatic ssize_t metric_id_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct mrvl_mesh_defaults defs;\n\tint ret;\n\n\tret = mesh_get_default_parameters(dev, &defs);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%d\\n\", defs.meshie.val.active_metric_id);\n}\n\n \nstatic ssize_t metric_id_store(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       const char *buf, size_t count)\n{\n\tstruct cmd_ds_mesh_config cmd;\n\tstruct mrvl_mesh_defaults defs;\n\tstruct mrvl_meshie *ie;\n\tstruct lbs_private *priv = to_net_dev(dev)->ml_priv;\n\tuint32_t datum;\n\tint ret;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tret = sscanf(buf, \"%d\", &datum);\n\tif ((ret != 1) || (datum > 255))\n\t\treturn -EINVAL;\n\n\t \n\tret = mesh_get_default_parameters(dev, &defs);\n\n\tcmd.length = cpu_to_le16(sizeof(struct mrvl_meshie));\n\n\t \n\tie = (struct mrvl_meshie *) &cmd.data[0];\n\tmemcpy(ie, &defs.meshie, sizeof(struct mrvl_meshie));\n\t \n\tie->val.active_metric_id = datum;\n\n\tret = lbs_mesh_config_send(priv, &cmd, CMD_ACT_MESH_CONFIG_SET,\n\t\t\t\t   CMD_TYPE_MESH_SET_MESH_IE);\n\tif (ret)\n\t\treturn ret;\n\n\treturn strlen(buf);\n}\n\n \nstatic ssize_t capability_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct mrvl_mesh_defaults defs;\n\tint ret;\n\n\tret = mesh_get_default_parameters(dev, &defs);\n\n\tif (ret)\n\t\treturn ret;\n\n\treturn sysfs_emit(buf, \"%d\\n\", defs.meshie.val.mesh_capability);\n}\n\n \nstatic ssize_t capability_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct cmd_ds_mesh_config cmd;\n\tstruct mrvl_mesh_defaults defs;\n\tstruct mrvl_meshie *ie;\n\tstruct lbs_private *priv = to_net_dev(dev)->ml_priv;\n\tuint32_t datum;\n\tint ret;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tret = sscanf(buf, \"%d\", &datum);\n\tif ((ret != 1) || (datum > 255))\n\t\treturn -EINVAL;\n\n\t \n\tret = mesh_get_default_parameters(dev, &defs);\n\n\tcmd.length = cpu_to_le16(sizeof(struct mrvl_meshie));\n\n\t \n\tie = (struct mrvl_meshie *) &cmd.data[0];\n\tmemcpy(ie, &defs.meshie, sizeof(struct mrvl_meshie));\n\t \n\tie->val.mesh_capability = datum;\n\n\tret = lbs_mesh_config_send(priv, &cmd, CMD_ACT_MESH_CONFIG_SET,\n\t\t\t\t   CMD_TYPE_MESH_SET_MESH_IE);\n\tif (ret)\n\t\treturn ret;\n\n\treturn strlen(buf);\n}\n\n\nstatic DEVICE_ATTR_RW(bootflag);\nstatic DEVICE_ATTR_RW(boottime);\nstatic DEVICE_ATTR_RW(channel);\nstatic DEVICE_ATTR_RW(mesh_id);\nstatic DEVICE_ATTR_RW(protocol_id);\nstatic DEVICE_ATTR_RW(metric_id);\nstatic DEVICE_ATTR_RW(capability);\n\nstatic struct attribute *boot_opts_attrs[] = {\n\t&dev_attr_bootflag.attr,\n\t&dev_attr_boottime.attr,\n\t&dev_attr_channel.attr,\n\tNULL\n};\n\nstatic const struct attribute_group boot_opts_group = {\n\t.name = \"boot_options\",\n\t.attrs = boot_opts_attrs,\n};\n\nstatic struct attribute *mesh_ie_attrs[] = {\n\t&dev_attr_mesh_id.attr,\n\t&dev_attr_protocol_id.attr,\n\t&dev_attr_metric_id.attr,\n\t&dev_attr_capability.attr,\n\tNULL\n};\n\nstatic const struct attribute_group mesh_ie_group = {\n\t.name = \"mesh_ie\",\n\t.attrs = mesh_ie_attrs,\n};\n\n\n \n\n \nvoid lbs_init_mesh(struct lbs_private *priv)\n{\n\t \n\t \n\t \n\t \n\t \n\tif (MRVL_FW_MAJOR_REV(priv->fwrelease) == MRVL_FW_V5) {\n\t\t \n\n\t\t \n\n\t\tpriv->mesh_tlv = TLV_TYPE_OLD_MESH_ID;\n\t\tif (lbs_mesh_config(priv, CMD_ACT_MESH_CONFIG_START, 1)) {\n\t\t\tpriv->mesh_tlv = TLV_TYPE_MESH_ID;\n\t\t\tif (lbs_mesh_config(priv, CMD_ACT_MESH_CONFIG_START, 1))\n\t\t\t\tpriv->mesh_tlv = 0;\n\t\t}\n\t} else\n\tif ((MRVL_FW_MAJOR_REV(priv->fwrelease) >= MRVL_FW_V10) &&\n\t\t(priv->fwcapinfo & MESH_CAPINFO_ENABLE_MASK)) {\n\t\t \n\t\tpriv->mesh_tlv = TLV_TYPE_MESH_ID;\n\t\tif (lbs_mesh_config(priv, CMD_ACT_MESH_CONFIG_START, 1))\n\t\t\tpriv->mesh_tlv = 0;\n\t}\n\n\t \n\tlbs_mesh_config(priv, CMD_ACT_MESH_CONFIG_STOP, 1);\n}\n\nvoid lbs_start_mesh(struct lbs_private *priv)\n{\n\tlbs_add_mesh(priv);\n\n\tif (device_create_file(&priv->dev->dev, &dev_attr_lbs_mesh))\n\t\tnetdev_err(priv->dev, \"cannot register lbs_mesh attribute\\n\");\n}\n\nint lbs_deinit_mesh(struct lbs_private *priv)\n{\n\tstruct net_device *dev = priv->dev;\n\tint ret = 0;\n\n\tif (priv->mesh_tlv) {\n\t\tdevice_remove_file(&dev->dev, &dev_attr_lbs_mesh);\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}\n\n\n \nstatic int lbs_mesh_stop(struct net_device *dev)\n{\n\tstruct lbs_private *priv = dev->ml_priv;\n\n\tlbs_mesh_config(priv, CMD_ACT_MESH_CONFIG_STOP,\n\t\tlbs_mesh_get_channel(priv));\n\n\tspin_lock_irq(&priv->driver_lock);\n\n\tnetif_stop_queue(dev);\n\tnetif_carrier_off(dev);\n\n\tspin_unlock_irq(&priv->driver_lock);\n\n\tlbs_update_mcast(priv);\n\tif (!lbs_iface_active(priv))\n\t\tlbs_stop_iface(priv);\n\n\treturn 0;\n}\n\n \nstatic int lbs_mesh_dev_open(struct net_device *dev)\n{\n\tstruct lbs_private *priv = dev->ml_priv;\n\tint ret = 0;\n\n\tif (!priv->iface_running) {\n\t\tret = lbs_start_iface(priv);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tspin_lock_irq(&priv->driver_lock);\n\n\tif (priv->wdev->iftype == NL80211_IFTYPE_MONITOR) {\n\t\tret = -EBUSY;\n\t\tspin_unlock_irq(&priv->driver_lock);\n\t\tgoto out;\n\t}\n\n\tnetif_carrier_on(dev);\n\n\tif (!priv->tx_pending_len)\n\t\tnetif_wake_queue(dev);\n\n\tspin_unlock_irq(&priv->driver_lock);\n\n\tret = lbs_mesh_config(priv, CMD_ACT_MESH_CONFIG_START,\n\t\tlbs_mesh_get_channel(priv));\n\nout:\n\treturn ret;\n}\n\nstatic const struct net_device_ops mesh_netdev_ops = {\n\t.ndo_open\t\t= lbs_mesh_dev_open,\n\t.ndo_stop \t\t= lbs_mesh_stop,\n\t.ndo_start_xmit\t\t= lbs_hard_start_xmit,\n\t.ndo_set_mac_address\t= lbs_set_mac_address,\n\t.ndo_set_rx_mode\t= lbs_set_multicast_list,\n};\n\n \nstatic int lbs_add_mesh(struct lbs_private *priv)\n{\n\tstruct net_device *mesh_dev = NULL;\n\tstruct wireless_dev *mesh_wdev;\n\tint ret = 0;\n\n\t \n\tmesh_wdev = kzalloc(sizeof(struct wireless_dev), GFP_KERNEL);\n\tif (!mesh_wdev) {\n\t\tlbs_deb_mesh(\"init mshX wireless device failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\tmesh_dev = alloc_netdev(0, \"msh%d\", NET_NAME_UNKNOWN, ether_setup);\n\tif (!mesh_dev) {\n\t\tlbs_deb_mesh(\"init mshX device failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_free_wdev;\n\t}\n\n\tmesh_wdev->iftype = NL80211_IFTYPE_MESH_POINT;\n\tmesh_wdev->wiphy = priv->wdev->wiphy;\n\n\tif (priv->mesh_tlv) {\n\t\tsprintf(mesh_wdev->u.mesh.id, \"mesh\");\n\t\tmesh_wdev->u.mesh.id_up_len = 4;\n\t}\n\n\tmesh_wdev->netdev = mesh_dev;\n\n\tmesh_dev->ml_priv = priv;\n\tmesh_dev->ieee80211_ptr = mesh_wdev;\n\tpriv->mesh_dev = mesh_dev;\n\n\tmesh_dev->netdev_ops = &mesh_netdev_ops;\n\tmesh_dev->ethtool_ops = &lbs_ethtool_ops;\n\teth_hw_addr_inherit(mesh_dev, priv->dev);\n\n\tSET_NETDEV_DEV(priv->mesh_dev, priv->dev->dev.parent);\n\n\tmesh_dev->flags |= IFF_BROADCAST | IFF_MULTICAST;\n\tmesh_dev->sysfs_groups[0] = &lbs_mesh_attr_group;\n\tmesh_dev->sysfs_groups[1] = &boot_opts_group;\n\tmesh_dev->sysfs_groups[2] = &mesh_ie_group;\n\n\t \n\tret = register_netdev(mesh_dev);\n\tif (ret) {\n\t\tpr_err(\"cannot register mshX virtual interface\\n\");\n\t\tgoto err_free_netdev;\n\t}\n\n\t \n\tret = 0;\n\tgoto done;\n\nerr_free_netdev:\n\tfree_netdev(mesh_dev);\n\nerr_free_wdev:\n\tkfree(mesh_wdev);\n\ndone:\n\treturn ret;\n}\n\nvoid lbs_remove_mesh(struct lbs_private *priv)\n{\n\tstruct net_device *mesh_dev;\n\n\tmesh_dev = priv->mesh_dev;\n\tif (!mesh_dev)\n\t\treturn;\n\n\tnetif_stop_queue(mesh_dev);\n\tnetif_carrier_off(mesh_dev);\n\tunregister_netdev(mesh_dev);\n\tpriv->mesh_dev = NULL;\n\tkfree(mesh_dev->ieee80211_ptr);\n\tfree_netdev(mesh_dev);\n}\n\n\n \nstruct net_device *lbs_mesh_set_dev(struct lbs_private *priv,\n\tstruct net_device *dev, struct rxpd *rxpd)\n{\n\tif (priv->mesh_dev) {\n\t\tif (priv->mesh_tlv == TLV_TYPE_OLD_MESH_ID) {\n\t\t\tif (rxpd->rx_control & RxPD_MESH_FRAME)\n\t\t\t\tdev = priv->mesh_dev;\n\t\t} else if (priv->mesh_tlv == TLV_TYPE_MESH_ID) {\n\t\t\tif (rxpd->u.bss.bss_num == MESH_IFACE_ID)\n\t\t\t\tdev = priv->mesh_dev;\n\t\t}\n\t}\n\treturn dev;\n}\n\n\nvoid lbs_mesh_set_txpd(struct lbs_private *priv,\n\tstruct net_device *dev, struct txpd *txpd)\n{\n\tif (dev == priv->mesh_dev) {\n\t\tif (priv->mesh_tlv == TLV_TYPE_OLD_MESH_ID)\n\t\t\ttxpd->tx_control |= cpu_to_le32(TxPD_MESH_FRAME);\n\t\telse if (priv->mesh_tlv == TLV_TYPE_MESH_ID)\n\t\t\ttxpd->u.bss.bss_num = MESH_IFACE_ID;\n\t}\n}\n\n\n \n\nstatic const char mesh_stat_strings[MESH_STATS_NUM][ETH_GSTRING_LEN] = {\n\t\"drop_duplicate_bcast\",\n\t\"drop_ttl_zero\",\n\t\"drop_no_fwd_route\",\n\t\"drop_no_buffers\",\n\t\"fwded_unicast_cnt\",\n\t\"fwded_bcast_cnt\",\n\t\"drop_blind_table\",\n\t\"tx_failed_cnt\"\n};\n\nvoid lbs_mesh_ethtool_get_stats(struct net_device *dev,\n\tstruct ethtool_stats *stats, uint64_t *data)\n{\n\tstruct lbs_private *priv = dev->ml_priv;\n\tstruct cmd_ds_mesh_access mesh_access;\n\tint ret;\n\n\t \n\tret = lbs_mesh_access(priv, CMD_ACT_MESH_GET_STATS, &mesh_access);\n\n\tif (ret) {\n\t\tmemset(data, 0, MESH_STATS_NUM*(sizeof(uint64_t)));\n\t\treturn;\n\t}\n\n\tpriv->mstats.fwd_drop_rbt = le32_to_cpu(mesh_access.data[0]);\n\tpriv->mstats.fwd_drop_ttl = le32_to_cpu(mesh_access.data[1]);\n\tpriv->mstats.fwd_drop_noroute = le32_to_cpu(mesh_access.data[2]);\n\tpriv->mstats.fwd_drop_nobuf = le32_to_cpu(mesh_access.data[3]);\n\tpriv->mstats.fwd_unicast_cnt = le32_to_cpu(mesh_access.data[4]);\n\tpriv->mstats.fwd_bcast_cnt = le32_to_cpu(mesh_access.data[5]);\n\tpriv->mstats.drop_blind = le32_to_cpu(mesh_access.data[6]);\n\tpriv->mstats.tx_failed_cnt = le32_to_cpu(mesh_access.data[7]);\n\n\tdata[0] = priv->mstats.fwd_drop_rbt;\n\tdata[1] = priv->mstats.fwd_drop_ttl;\n\tdata[2] = priv->mstats.fwd_drop_noroute;\n\tdata[3] = priv->mstats.fwd_drop_nobuf;\n\tdata[4] = priv->mstats.fwd_unicast_cnt;\n\tdata[5] = priv->mstats.fwd_bcast_cnt;\n\tdata[6] = priv->mstats.drop_blind;\n\tdata[7] = priv->mstats.tx_failed_cnt;\n}\n\nint lbs_mesh_ethtool_get_sset_count(struct net_device *dev, int sset)\n{\n\tstruct lbs_private *priv = dev->ml_priv;\n\n\tif (sset == ETH_SS_STATS && dev == priv->mesh_dev)\n\t\treturn MESH_STATS_NUM;\n\n\treturn -EOPNOTSUPP;\n}\n\nvoid lbs_mesh_ethtool_get_strings(struct net_device *dev,\n\tuint32_t stringset, uint8_t *s)\n{\n\tswitch (stringset) {\n\tcase ETH_SS_STATS:\n\t\tmemcpy(s, mesh_stat_strings, sizeof(mesh_stat_strings));\n\t\tbreak;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}