{
  "module_name": "cmd.c",
  "hash_id": "73a77bd96be04b5ff5e0586b4894105257135d68c33bb73c724c39715d26df75",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/marvell/libertas/cmd.c",
  "human_readable_source": "\n \n\n#include <linux/hardirq.h>\n#include <linux/kfifo.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/if_arp.h>\n#include <linux/export.h>\n\n#include \"decl.h\"\n#include \"cfg.h\"\n#include \"cmd.h\"\n\n#define CAL_NF(nf)\t\t((s32)(-(s32)(nf)))\n#define CAL_RSSI(snr, nf)\t((s32)((s32)(snr) + CAL_NF(nf)))\n\n \nint lbs_cmd_copyback(struct lbs_private *priv, unsigned long extra,\n\t\t     struct cmd_header *resp)\n{\n\tstruct cmd_header *buf = (void *)extra;\n\tuint16_t copy_len;\n\n\tcopy_len = min(le16_to_cpu(buf->size), le16_to_cpu(resp->size));\n\tmemcpy(buf, resp, copy_len);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(lbs_cmd_copyback);\n\n \nstatic int lbs_cmd_async_callback(struct lbs_private *priv, unsigned long extra,\n\t\t     struct cmd_header *resp)\n{\n\treturn 0;\n}\n\n\n \nstatic u8 is_command_allowed_in_ps(u16 cmd)\n{\n\tswitch (cmd) {\n\tcase CMD_802_11_RSSI:\n\t\treturn 1;\n\tcase CMD_802_11_HOST_SLEEP_CFG:\n\t\treturn 1;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nint lbs_update_hw_spec(struct lbs_private *priv)\n{\n\tstruct cmd_ds_get_hw_spec cmd;\n\tint ret = -1;\n\tu32 i;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.hdr.size = cpu_to_le16(sizeof(cmd));\n\tmemcpy(cmd.permanentaddr, priv->current_addr, ETH_ALEN);\n\tret = lbs_cmd_with_response(priv, CMD_GET_HW_SPEC, &cmd);\n\tif (ret)\n\t\tgoto out;\n\n\tpriv->fwcapinfo = le32_to_cpu(cmd.fwcapinfo);\n\n\t \n\tpriv->fwrelease = le32_to_cpu(cmd.fwrelease);\n\tpriv->fwrelease = (priv->fwrelease << 8) |\n\t\t(priv->fwrelease >> 24 & 0xff);\n\n\t \n\tnetdev_info(priv->dev, \"%pM, fw %u.%u.%up%u, cap 0x%08x\\n\",\n\t\tcmd.permanentaddr,\n\t\tpriv->fwrelease >> 24 & 0xff,\n\t\tpriv->fwrelease >> 16 & 0xff,\n\t\tpriv->fwrelease >>  8 & 0xff,\n\t\tpriv->fwrelease       & 0xff,\n\t\tpriv->fwcapinfo);\n\tlbs_deb_cmd(\"GET_HW_SPEC: hardware interface 0x%x, hardware spec 0x%04x\\n\",\n\t\t    cmd.hwifversion, cmd.version);\n\n\t \n\tif (MRVL_FW_MAJOR_REV(priv->fwrelease) == MRVL_FW_V4)\n\t\tpriv->regioncode = (le16_to_cpu(cmd.regioncode) >> 8) & 0xFF;\n\telse\n\t\tpriv->regioncode = le16_to_cpu(cmd.regioncode) & 0xFF;\n\n\tfor (i = 0; i < MRVDRV_MAX_REGION_CODE; i++) {\n\t\t \n\t\tif (priv->regioncode == lbs_region_code_to_index[i])\n\t\t\tbreak;\n\t}\n\n\t \n\tif (i >= MRVDRV_MAX_REGION_CODE) {\n\t\tpriv->regioncode = 0x10;\n\t\tnetdev_info(priv->dev,\n\t\t\t    \"unidentified region code; using the default (USA)\\n\");\n\t}\n\n\tif (priv->current_addr[0] == 0xff)\n\t\tmemmove(priv->current_addr, cmd.permanentaddr, ETH_ALEN);\n\n\tif (!priv->copied_hwaddr) {\n\t\teth_hw_addr_set(priv->dev, priv->current_addr);\n\t\tif (priv->mesh_dev)\n\t\t\teth_hw_addr_set(priv->mesh_dev, priv->current_addr);\n\t\tpriv->copied_hwaddr = 1;\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic int lbs_ret_host_sleep_cfg(struct lbs_private *priv, unsigned long dummy,\n\t\t\tstruct cmd_header *resp)\n{\n\tif (priv->is_host_sleep_activated) {\n\t\tpriv->is_host_sleep_configured = 0;\n\t\tif (priv->psstate == PS_STATE_FULL_POWER) {\n\t\t\tpriv->is_host_sleep_activated = 0;\n\t\t\twake_up_interruptible(&priv->host_sleep_q);\n\t\t}\n\t} else {\n\t\tpriv->is_host_sleep_configured = 1;\n\t}\n\n\treturn 0;\n}\n\nint lbs_host_sleep_cfg(struct lbs_private *priv, uint32_t criteria,\n\t\tstruct wol_config *p_wol_config)\n{\n\tstruct cmd_ds_host_sleep cmd_config;\n\tint ret;\n\n\t \n\tif (criteria == EHS_REMOVE_WAKEUP && !priv->ehs_remove_supported)\n\t\tcriteria = 0;\n\n\tcmd_config.hdr.size = cpu_to_le16(sizeof(cmd_config));\n\tcmd_config.criteria = cpu_to_le32(criteria);\n\tcmd_config.gpio = priv->wol_gpio;\n\tcmd_config.gap = priv->wol_gap;\n\n\tif (p_wol_config != NULL)\n\t\tmemcpy((uint8_t *)&cmd_config.wol_conf, (uint8_t *)p_wol_config,\n\t\t\t\tsizeof(struct wol_config));\n\telse\n\t\tcmd_config.wol_conf.action = CMD_ACT_ACTION_NONE;\n\n\tret = __lbs_cmd(priv, CMD_802_11_HOST_SLEEP_CFG, &cmd_config.hdr,\n\t\t\tle16_to_cpu(cmd_config.hdr.size),\n\t\t\tlbs_ret_host_sleep_cfg, 0);\n\tif (!ret) {\n\t\tif (p_wol_config)\n\t\t\tmemcpy((uint8_t *) p_wol_config,\n\t\t\t\t\t(uint8_t *)&cmd_config.wol_conf,\n\t\t\t\t\tsizeof(struct wol_config));\n\t} else {\n\t\tnetdev_info(priv->dev, \"HOST_SLEEP_CFG failed %d\\n\", ret);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(lbs_host_sleep_cfg);\n\n \nint lbs_set_ps_mode(struct lbs_private *priv, u16 cmd_action, bool block)\n{\n\tstruct cmd_ds_802_11_ps_mode cmd;\n\tint ret = 0;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.hdr.size = cpu_to_le16(sizeof(cmd));\n\tcmd.action = cpu_to_le16(cmd_action);\n\n\tif (cmd_action == PS_MODE_ACTION_ENTER_PS) {\n\t\tlbs_deb_cmd(\"PS_MODE: action ENTER_PS\\n\");\n\t\tcmd.multipledtim = cpu_to_le16(1);   \n\t} else if (cmd_action == PS_MODE_ACTION_EXIT_PS) {\n\t\tlbs_deb_cmd(\"PS_MODE: action EXIT_PS\\n\");\n\t} else {\n\t\t \n\t\tlbs_deb_cmd(\"PS_MODE: unknown action 0x%X\\n\", cmd_action);\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\n\tif (block)\n\t\tret = lbs_cmd_with_response(priv, CMD_802_11_PS_MODE, &cmd);\n\telse\n\t\tlbs_cmd_async(priv, CMD_802_11_PS_MODE, &cmd.hdr, sizeof (cmd));\n\nout:\n\treturn ret;\n}\n\nint lbs_cmd_802_11_sleep_params(struct lbs_private *priv, uint16_t cmd_action,\n\t\t\t\tstruct sleep_params *sp)\n{\n\tstruct cmd_ds_802_11_sleep_params cmd;\n\tint ret;\n\n\tif (cmd_action == CMD_ACT_GET) {\n\t\tmemset(&cmd, 0, sizeof(cmd));\n\t} else {\n\t\tcmd.error = cpu_to_le16(sp->sp_error);\n\t\tcmd.offset = cpu_to_le16(sp->sp_offset);\n\t\tcmd.stabletime = cpu_to_le16(sp->sp_stabletime);\n\t\tcmd.calcontrol = sp->sp_calcontrol;\n\t\tcmd.externalsleepclk = sp->sp_extsleepclk;\n\t\tcmd.reserved = cpu_to_le16(sp->sp_reserved);\n\t}\n\tcmd.hdr.size = cpu_to_le16(sizeof(cmd));\n\tcmd.action = cpu_to_le16(cmd_action);\n\n\tret = lbs_cmd_with_response(priv, CMD_802_11_SLEEP_PARAMS, &cmd);\n\n\tif (!ret) {\n\t\tlbs_deb_cmd(\"error 0x%x, offset 0x%x, stabletime 0x%x, \"\n\t\t\t    \"calcontrol 0x%x extsleepclk 0x%x\\n\",\n\t\t\t    le16_to_cpu(cmd.error), le16_to_cpu(cmd.offset),\n\t\t\t    le16_to_cpu(cmd.stabletime), cmd.calcontrol,\n\t\t\t    cmd.externalsleepclk);\n\n\t\tsp->sp_error = le16_to_cpu(cmd.error);\n\t\tsp->sp_offset = le16_to_cpu(cmd.offset);\n\t\tsp->sp_stabletime = le16_to_cpu(cmd.stabletime);\n\t\tsp->sp_calcontrol = cmd.calcontrol;\n\t\tsp->sp_extsleepclk = cmd.externalsleepclk;\n\t\tsp->sp_reserved = le16_to_cpu(cmd.reserved);\n\t}\n\n\treturn ret;\n}\n\nstatic int lbs_wait_for_ds_awake(struct lbs_private *priv)\n{\n\tint ret = 0;\n\n\tif (priv->is_deep_sleep) {\n\t\tif (!wait_event_interruptible_timeout(priv->ds_awake_q,\n\t\t\t\t\t!priv->is_deep_sleep, (10 * HZ))) {\n\t\t\tnetdev_err(priv->dev, \"ds_awake_q: timer expired\\n\");\n\t\t\tret = -1;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint lbs_set_deep_sleep(struct lbs_private *priv, int deep_sleep)\n{\n\tint ret =  0;\n\n\tif (deep_sleep) {\n\t\tif (priv->is_deep_sleep != 1) {\n\t\t\tlbs_deb_cmd(\"deep sleep: sleep\\n\");\n\t\t\tBUG_ON(!priv->enter_deep_sleep);\n\t\t\tret = priv->enter_deep_sleep(priv);\n\t\t\tif (!ret) {\n\t\t\t\tnetif_stop_queue(priv->dev);\n\t\t\t\tnetif_carrier_off(priv->dev);\n\t\t\t}\n\t\t} else {\n\t\t\tnetdev_err(priv->dev, \"deep sleep: already enabled\\n\");\n\t\t}\n\t} else {\n\t\tif (priv->is_deep_sleep) {\n\t\t\tlbs_deb_cmd(\"deep sleep: wakeup\\n\");\n\t\t\tBUG_ON(!priv->exit_deep_sleep);\n\t\t\tret = priv->exit_deep_sleep(priv);\n\t\t\tif (!ret) {\n\t\t\t\tret = lbs_wait_for_ds_awake(priv);\n\t\t\t\tif (ret)\n\t\t\t\t\tnetdev_err(priv->dev,\n\t\t\t\t\t\t   \"deep sleep: wakeup failed\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int lbs_ret_host_sleep_activate(struct lbs_private *priv,\n\t\tunsigned long dummy,\n\t\tstruct cmd_header *cmd)\n{\n\tpriv->is_host_sleep_activated = 1;\n\twake_up_interruptible(&priv->host_sleep_q);\n\n\treturn 0;\n}\n\nint lbs_set_host_sleep(struct lbs_private *priv, int host_sleep)\n{\n\tstruct cmd_header cmd;\n\tint ret = 0;\n\tuint32_t criteria = EHS_REMOVE_WAKEUP;\n\n\tif (host_sleep) {\n\t\tif (priv->is_host_sleep_activated != 1) {\n\t\t\tmemset(&cmd, 0, sizeof(cmd));\n\t\t\tret = lbs_host_sleep_cfg(priv, priv->wol_criteria,\n\t\t\t\t\t(struct wol_config *)NULL);\n\t\t\tif (ret) {\n\t\t\t\tnetdev_info(priv->dev,\n\t\t\t\t\t    \"Host sleep configuration failed: %d\\n\",\n\t\t\t\t\t    ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tif (priv->psstate == PS_STATE_FULL_POWER) {\n\t\t\t\tret = __lbs_cmd(priv,\n\t\t\t\t\t\tCMD_802_11_HOST_SLEEP_ACTIVATE,\n\t\t\t\t\t\t&cmd,\n\t\t\t\t\t\tsizeof(cmd),\n\t\t\t\t\t\tlbs_ret_host_sleep_activate, 0);\n\t\t\t\tif (ret)\n\t\t\t\t\tnetdev_info(priv->dev,\n\t\t\t\t\t\t    \"HOST_SLEEP_ACTIVATE failed: %d\\n\",\n\t\t\t\t\t\t    ret);\n\t\t\t}\n\n\t\t\tif (!wait_event_interruptible_timeout(\n\t\t\t\t\t\tpriv->host_sleep_q,\n\t\t\t\t\t\tpriv->is_host_sleep_activated,\n\t\t\t\t\t\t(10 * HZ))) {\n\t\t\t\tnetdev_err(priv->dev,\n\t\t\t\t\t   \"host_sleep_q: timer expired\\n\");\n\t\t\t\tret = -1;\n\t\t\t}\n\t\t} else {\n\t\t\tnetdev_err(priv->dev, \"host sleep: already enabled\\n\");\n\t\t}\n\t} else {\n\t\tif (priv->is_host_sleep_activated)\n\t\t\tret = lbs_host_sleep_cfg(priv, criteria,\n\t\t\t\t\t(struct wol_config *)NULL);\n\t}\n\n\treturn ret;\n}\n\n \nint lbs_set_snmp_mib(struct lbs_private *priv, u32 oid, u16 val)\n{\n\tstruct cmd_ds_802_11_snmp_mib cmd;\n\tint ret;\n\n\tmemset(&cmd, 0, sizeof (cmd));\n\tcmd.hdr.size = cpu_to_le16(sizeof(cmd));\n\tcmd.action = cpu_to_le16(CMD_ACT_SET);\n\tcmd.oid = cpu_to_le16((u16) oid);\n\n\tswitch (oid) {\n\tcase SNMP_MIB_OID_BSS_TYPE:\n\t\tcmd.bufsize = cpu_to_le16(sizeof(u8));\n\t\tcmd.value[0] = val;\n\t\tbreak;\n\tcase SNMP_MIB_OID_11D_ENABLE:\n\tcase SNMP_MIB_OID_FRAG_THRESHOLD:\n\tcase SNMP_MIB_OID_RTS_THRESHOLD:\n\tcase SNMP_MIB_OID_SHORT_RETRY_LIMIT:\n\tcase SNMP_MIB_OID_LONG_RETRY_LIMIT:\n\t\tcmd.bufsize = cpu_to_le16(sizeof(u16));\n\t\t*((__le16 *)(&cmd.value)) = cpu_to_le16(val);\n\t\tbreak;\n\tdefault:\n\t\tlbs_deb_cmd(\"SNMP_CMD: (set) unhandled OID 0x%x\\n\", oid);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlbs_deb_cmd(\"SNMP_CMD: (set) oid 0x%x, oid size 0x%x, value 0x%x\\n\",\n\t\t    le16_to_cpu(cmd.oid), le16_to_cpu(cmd.bufsize), val);\n\n\tret = lbs_cmd_with_response(priv, CMD_802_11_SNMP_MIB, &cmd);\n\nout:\n\treturn ret;\n}\n\n \nint lbs_get_snmp_mib(struct lbs_private *priv, u32 oid, u16 *out_val)\n{\n\tstruct cmd_ds_802_11_snmp_mib cmd;\n\tint ret;\n\n\tmemset(&cmd, 0, sizeof (cmd));\n\tcmd.hdr.size = cpu_to_le16(sizeof(cmd));\n\tcmd.action = cpu_to_le16(CMD_ACT_GET);\n\tcmd.oid = cpu_to_le16(oid);\n\n\tret = lbs_cmd_with_response(priv, CMD_802_11_SNMP_MIB, &cmd);\n\tif (ret)\n\t\tgoto out;\n\n\tswitch (le16_to_cpu(cmd.bufsize)) {\n\tcase sizeof(u8):\n\t\t*out_val = cmd.value[0];\n\t\tbreak;\n\tcase sizeof(u16):\n\t\t*out_val = le16_to_cpu(*((__le16 *)(&cmd.value)));\n\t\tbreak;\n\tdefault:\n\t\tlbs_deb_cmd(\"SNMP_CMD: (get) unhandled OID 0x%x size %d\\n\",\n\t\t            oid, le16_to_cpu(cmd.bufsize));\n\t\tbreak;\n\t}\n\nout:\n\treturn ret;\n}\n\n \nint lbs_get_tx_power(struct lbs_private *priv, s16 *curlevel, s16 *minlevel,\n\t\t     s16 *maxlevel)\n{\n\tstruct cmd_ds_802_11_rf_tx_power cmd;\n\tint ret;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.hdr.size = cpu_to_le16(sizeof(cmd));\n\tcmd.action = cpu_to_le16(CMD_ACT_GET);\n\n\tret = lbs_cmd_with_response(priv, CMD_802_11_RF_TX_POWER, &cmd);\n\tif (ret == 0) {\n\t\t*curlevel = le16_to_cpu(cmd.curlevel);\n\t\tif (minlevel)\n\t\t\t*minlevel = cmd.minlevel;\n\t\tif (maxlevel)\n\t\t\t*maxlevel = cmd.maxlevel;\n\t}\n\n\treturn ret;\n}\n\n \nint lbs_set_tx_power(struct lbs_private *priv, s16 dbm)\n{\n\tstruct cmd_ds_802_11_rf_tx_power cmd;\n\tint ret;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.hdr.size = cpu_to_le16(sizeof(cmd));\n\tcmd.action = cpu_to_le16(CMD_ACT_SET);\n\tcmd.curlevel = cpu_to_le16(dbm);\n\n\tlbs_deb_cmd(\"SET_RF_TX_POWER: %d dBm\\n\", dbm);\n\n\tret = lbs_cmd_with_response(priv, CMD_802_11_RF_TX_POWER, &cmd);\n\n\treturn ret;\n}\n\n \nint lbs_set_monitor_mode(struct lbs_private *priv, int enable)\n{\n\tstruct cmd_ds_802_11_monitor_mode cmd;\n\tint ret;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.hdr.size = cpu_to_le16(sizeof(cmd));\n\tcmd.action = cpu_to_le16(CMD_ACT_SET);\n\tif (enable)\n\t\tcmd.mode = cpu_to_le16(0x1);\n\n\tlbs_deb_cmd(\"SET_MONITOR_MODE: %d\\n\", enable);\n\n\tret = lbs_cmd_with_response(priv, CMD_802_11_MONITOR_MODE, &cmd);\n\tif (ret == 0) {\n\t\tpriv->dev->type = enable ? ARPHRD_IEEE80211_RADIOTAP :\n\t\t\t\t\t\tARPHRD_ETHER;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int lbs_get_channel(struct lbs_private *priv)\n{\n\tstruct cmd_ds_802_11_rf_channel cmd;\n\tint ret = 0;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.hdr.size = cpu_to_le16(sizeof(cmd));\n\tcmd.action = cpu_to_le16(CMD_OPT_802_11_RF_CHANNEL_GET);\n\n\tret = lbs_cmd_with_response(priv, CMD_802_11_RF_CHANNEL, &cmd);\n\tif (ret)\n\t\tgoto out;\n\n\tret = le16_to_cpu(cmd.channel);\n\tlbs_deb_cmd(\"current radio channel is %d\\n\", ret);\n\nout:\n\treturn ret;\n}\n\nint lbs_update_channel(struct lbs_private *priv)\n{\n\tint ret;\n\n\t \n\tret = lbs_get_channel(priv);\n\tif (ret > 0) {\n\t\tpriv->channel = ret;\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\n \nint lbs_set_channel(struct lbs_private *priv, u8 channel)\n{\n\tstruct cmd_ds_802_11_rf_channel cmd;\n#ifdef DEBUG\n\tu8 old_channel = priv->channel;\n#endif\n\tint ret = 0;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.hdr.size = cpu_to_le16(sizeof(cmd));\n\tcmd.action = cpu_to_le16(CMD_OPT_802_11_RF_CHANNEL_SET);\n\tcmd.channel = cpu_to_le16(channel);\n\n\tret = lbs_cmd_with_response(priv, CMD_802_11_RF_CHANNEL, &cmd);\n\tif (ret)\n\t\tgoto out;\n\n\tpriv->channel = (uint8_t) le16_to_cpu(cmd.channel);\n\tlbs_deb_cmd(\"channel switch from %d to %d\\n\", old_channel,\n\t\tpriv->channel);\n\nout:\n\treturn ret;\n}\n\n \nint lbs_get_rssi(struct lbs_private *priv, s8 *rssi, s8 *nf)\n{\n\tstruct cmd_ds_802_11_rssi cmd;\n\tint ret = 0;\n\n\tBUG_ON(rssi == NULL);\n\tBUG_ON(nf == NULL);\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.hdr.size = cpu_to_le16(sizeof(cmd));\n\t \n\tcmd.n_or_snr = cpu_to_le16(8);\n\n\tret = lbs_cmd_with_response(priv, CMD_802_11_RSSI, &cmd);\n\tif (ret == 0) {\n\t\t*nf = CAL_NF(le16_to_cpu(cmd.nf));\n\t\t*rssi = CAL_RSSI(le16_to_cpu(cmd.n_or_snr), le16_to_cpu(cmd.nf));\n\t}\n\n\treturn ret;\n}\n\n \nint lbs_set_11d_domain_info(struct lbs_private *priv)\n{\n\tstruct wiphy *wiphy = priv->wdev->wiphy;\n\tstruct ieee80211_supported_band **bands = wiphy->bands;\n\tstruct cmd_ds_802_11d_domain_info cmd;\n\tstruct mrvl_ie_domain_param_set *domain = &cmd.domain;\n\tstruct ieee80211_country_ie_triplet *t;\n\tenum nl80211_band band;\n\tstruct ieee80211_channel *ch;\n\tu8 num_triplet = 0;\n\tu8 num_parsed_chan = 0;\n\tu8 first_channel = 0, next_chan = 0, max_pwr = 0;\n\tu8 i, flag = 0;\n\tsize_t triplet_size;\n\tint ret = 0;\n\n\tif (!priv->country_code[0])\n\t\tgoto out;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.action = cpu_to_le16(CMD_ACT_SET);\n\n\tlbs_deb_11d(\"Setting country code '%c%c'\\n\",\n\t\t    priv->country_code[0], priv->country_code[1]);\n\n\tdomain->header.type = cpu_to_le16(TLV_TYPE_DOMAIN);\n\n\t \n\tdomain->country_code[0] = priv->country_code[0];\n\tdomain->country_code[1] = priv->country_code[1];\n\tdomain->country_code[2] = ' ';\n\n\t \n\tfor (band = 0;\n\t     (band < NUM_NL80211_BANDS) && (num_triplet < MAX_11D_TRIPLETS);\n\t     band++) {\n\n\t\tif (!bands[band])\n\t\t\tcontinue;\n\n\t\tfor (i = 0;\n\t\t     (i < bands[band]->n_channels) && (num_triplet < MAX_11D_TRIPLETS);\n\t\t     i++) {\n\t\t\tch = &bands[band]->channels[i];\n\t\t\tif (ch->flags & IEEE80211_CHAN_DISABLED)\n\t\t\t\tcontinue;\n\n\t\t\tif (!flag) {\n\t\t\t\tflag = 1;\n\t\t\t\tnext_chan = first_channel = (u32) ch->hw_value;\n\t\t\t\tmax_pwr = ch->max_power;\n\t\t\t\tnum_parsed_chan = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ((ch->hw_value == next_chan + 1) &&\n\t\t\t\t\t(ch->max_power == max_pwr)) {\n\t\t\t\t \n\t\t\t\tnext_chan++;\n\t\t\t\tnum_parsed_chan++;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tlbs_deb_11d(\"11D triplet (%d, %d, %d)\\n\",\n\t\t\t\t\tfirst_channel, num_parsed_chan,\n\t\t\t\t\tmax_pwr);\n\t\t\t\tt = &domain->triplet[num_triplet];\n\t\t\t\tt->chans.first_channel = first_channel;\n\t\t\t\tt->chans.num_channels = num_parsed_chan;\n\t\t\t\tt->chans.max_power = max_pwr;\n\t\t\t\tnum_triplet++;\n\t\t\t\tflag = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (flag) {\n\t\t\t \n\t\t\tlbs_deb_11d(\"11D triplet (%d, %d, %d)\\n\", first_channel,\n\t\t\t\tnum_parsed_chan, max_pwr);\n\t\t\tt = &domain->triplet[num_triplet];\n\t\t\tt->chans.first_channel = first_channel;\n\t\t\tt->chans.num_channels = num_parsed_chan;\n\t\t\tt->chans.max_power = max_pwr;\n\t\t\tnum_triplet++;\n\t\t}\n\t}\n\n\tlbs_deb_11d(\"# triplets %d\\n\", num_triplet);\n\n\t \n\ttriplet_size = num_triplet * sizeof(struct ieee80211_country_ie_triplet);\n\tdomain->header.len = cpu_to_le16(sizeof(domain->country_code) +\n\t\t\t\t\ttriplet_size);\n\n\tlbs_deb_hex(LBS_DEB_11D, \"802.11D domain param set\",\n\t\t\t(u8 *) &cmd.domain.country_code,\n\t\t\tle16_to_cpu(domain->header.len));\n\n\tcmd.hdr.size = cpu_to_le16(sizeof(cmd.hdr) +\n\t\t\t\t   sizeof(cmd.action) +\n\t\t\t\t   sizeof(cmd.domain.header) +\n\t\t\t\t   sizeof(cmd.domain.country_code) +\n\t\t\t\t   triplet_size);\n\n\tret = lbs_cmd_with_response(priv, CMD_802_11D_DOMAIN_INFO, &cmd);\n\nout:\n\treturn ret;\n}\n\n \nint lbs_get_reg(struct lbs_private *priv, u16 reg, u16 offset, u32 *value)\n{\n\tstruct cmd_ds_reg_access cmd;\n\tint ret = 0;\n\n\tBUG_ON(value == NULL);\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.hdr.size = cpu_to_le16(sizeof(cmd));\n\tcmd.action = cpu_to_le16(CMD_ACT_GET);\n\tcmd.offset = cpu_to_le16(offset);\n\n\tif (reg != CMD_MAC_REG_ACCESS &&\n\t    reg != CMD_BBP_REG_ACCESS &&\n\t    reg != CMD_RF_REG_ACCESS) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = lbs_cmd_with_response(priv, reg, &cmd);\n\tif (!ret) {\n\t\tif (reg == CMD_BBP_REG_ACCESS || reg == CMD_RF_REG_ACCESS)\n\t\t\t*value = cmd.value.bbp_rf;\n\t\telse if (reg == CMD_MAC_REG_ACCESS)\n\t\t\t*value = le32_to_cpu(cmd.value.mac);\n\t}\n\nout:\n\treturn ret;\n}\n\n \nint lbs_set_reg(struct lbs_private *priv, u16 reg, u16 offset, u32 value)\n{\n\tstruct cmd_ds_reg_access cmd;\n\tint ret = 0;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.hdr.size = cpu_to_le16(sizeof(cmd));\n\tcmd.action = cpu_to_le16(CMD_ACT_SET);\n\tcmd.offset = cpu_to_le16(offset);\n\n\tif (reg == CMD_BBP_REG_ACCESS || reg == CMD_RF_REG_ACCESS)\n\t\tcmd.value.bbp_rf = (u8) (value & 0xFF);\n\telse if (reg == CMD_MAC_REG_ACCESS)\n\t\tcmd.value.mac = cpu_to_le32(value);\n\telse {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = lbs_cmd_with_response(priv, reg, &cmd);\n\nout:\n\treturn ret;\n}\n\nstatic void lbs_queue_cmd(struct lbs_private *priv,\n\t\t\t  struct cmd_ctrl_node *cmdnode)\n{\n\tunsigned long flags;\n\tint addtail = 1;\n\n\tif (!cmdnode) {\n\t\tlbs_deb_host(\"QUEUE_CMD: cmdnode is NULL\\n\");\n\t\treturn;\n\t}\n\tif (!cmdnode->cmdbuf->size) {\n\t\tlbs_deb_host(\"DNLD_CMD: cmd size is zero\\n\");\n\t\treturn;\n\t}\n\tcmdnode->result = 0;\n\n\t \n\tif (le16_to_cpu(cmdnode->cmdbuf->command) == CMD_802_11_PS_MODE) {\n\t\tstruct cmd_ds_802_11_ps_mode *psm = (void *)cmdnode->cmdbuf;\n\n\t\tif (psm->action == cpu_to_le16(PS_MODE_ACTION_EXIT_PS)) {\n\t\t\tif (priv->psstate != PS_STATE_FULL_POWER)\n\t\t\t\taddtail = 0;\n\t\t}\n\t}\n\n\tif (le16_to_cpu(cmdnode->cmdbuf->command) == CMD_802_11_WAKEUP_CONFIRM)\n\t\taddtail = 0;\n\n\tspin_lock_irqsave(&priv->driver_lock, flags);\n\n\tif (addtail)\n\t\tlist_add_tail(&cmdnode->list, &priv->cmdpendingq);\n\telse\n\t\tlist_add(&cmdnode->list, &priv->cmdpendingq);\n\n\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\n\tlbs_deb_host(\"QUEUE_CMD: inserted command 0x%04x into cmdpendingq\\n\",\n\t\t     le16_to_cpu(cmdnode->cmdbuf->command));\n}\n\nstatic void lbs_submit_command(struct lbs_private *priv,\n\t\t\t       struct cmd_ctrl_node *cmdnode)\n{\n\tunsigned long flags;\n\tstruct cmd_header *cmd;\n\tuint16_t cmdsize;\n\tuint16_t command;\n\tint timeo = 3 * HZ;\n\tint ret;\n\n\tcmd = cmdnode->cmdbuf;\n\n\tspin_lock_irqsave(&priv->driver_lock, flags);\n\tpriv->seqnum++;\n\tcmd->seqnum = cpu_to_le16(priv->seqnum);\n\tpriv->cur_cmd = cmdnode;\n\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\n\tcmdsize = le16_to_cpu(cmd->size);\n\tcommand = le16_to_cpu(cmd->command);\n\n\t \n\tif (command == CMD_802_11_SCAN || command == CMD_802_11_ASSOCIATE)\n\t\ttimeo = 5 * HZ;\n\n\tlbs_deb_cmd(\"DNLD_CMD: command 0x%04x, seq %d, size %d\\n\",\n\t\t     command, le16_to_cpu(cmd->seqnum), cmdsize);\n\tlbs_deb_hex(LBS_DEB_CMD, \"DNLD_CMD\", (void *) cmdnode->cmdbuf, cmdsize);\n\n\tret = priv->hw_host_to_card(priv, MVMS_CMD, (u8 *) cmd, cmdsize);\n\n\tif (ret) {\n\t\tnetdev_info(priv->dev, \"DNLD_CMD: hw_host_to_card failed: %d\\n\",\n\t\t\t    ret);\n\t\t \n\t\tpriv->dnld_sent = DNLD_RES_RECEIVED;\n\t\tlbs_complete_command(priv, cmdnode, ret);\n\t}\n\n\tif (command == CMD_802_11_DEEP_SLEEP) {\n\t\tif (priv->is_auto_deep_sleep_enabled) {\n\t\t\tpriv->wakeup_dev_required = 1;\n\t\t\tpriv->dnld_sent = 0;\n\t\t}\n\t\tpriv->is_deep_sleep = 1;\n\t\tlbs_complete_command(priv, cmdnode, 0);\n\t} else {\n\t\t \n\t\tmod_timer(&priv->command_timer, jiffies + timeo);\n\t}\n}\n\n \nstatic void __lbs_cleanup_and_insert_cmd(struct lbs_private *priv,\n\t\t\t\t\t struct cmd_ctrl_node *cmdnode)\n{\n\tif (!cmdnode)\n\t\treturn;\n\n\tcmdnode->callback = NULL;\n\tcmdnode->callback_arg = 0;\n\n\tmemset(cmdnode->cmdbuf, 0, LBS_CMD_BUFFER_SIZE);\n\n\tlist_add_tail(&cmdnode->list, &priv->cmdfreeq);\n}\n\nstatic void lbs_cleanup_and_insert_cmd(struct lbs_private *priv,\n\tstruct cmd_ctrl_node *ptempcmd)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->driver_lock, flags);\n\t__lbs_cleanup_and_insert_cmd(priv, ptempcmd);\n\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n}\n\nvoid __lbs_complete_command(struct lbs_private *priv, struct cmd_ctrl_node *cmd,\n\t\t\t    int result)\n{\n\t \n\tlist_del_init(&cmd->list);\n\n\tcmd->result = result;\n\tcmd->cmdwaitqwoken = 1;\n\twake_up(&cmd->cmdwait_q);\n\n\tif (!cmd->callback || cmd->callback == lbs_cmd_async_callback)\n\t\t__lbs_cleanup_and_insert_cmd(priv, cmd);\n\tpriv->cur_cmd = NULL;\n\twake_up(&priv->waitq);\n}\n\nvoid lbs_complete_command(struct lbs_private *priv, struct cmd_ctrl_node *cmd,\n\t\t\t  int result)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&priv->driver_lock, flags);\n\t__lbs_complete_command(priv, cmd, result);\n\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n}\n\nint lbs_set_radio(struct lbs_private *priv, u8 preamble, u8 radio_on)\n{\n\tstruct cmd_ds_802_11_radio_control cmd;\n\tint ret = -EINVAL;\n\n\tcmd.hdr.size = cpu_to_le16(sizeof(cmd));\n\tcmd.action = cpu_to_le16(CMD_ACT_SET);\n\tcmd.control = 0;\n\n\t \n\tif (priv->fwrelease < 0x09000000) {\n\t\tswitch (preamble) {\n\t\tcase RADIO_PREAMBLE_SHORT:\n\t\tcase RADIO_PREAMBLE_AUTO:\n\t\tcase RADIO_PREAMBLE_LONG:\n\t\t\tcmd.control = cpu_to_le16(preamble);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (radio_on)\n\t\tcmd.control |= cpu_to_le16(0x1);\n\telse {\n\t\tcmd.control &= cpu_to_le16(~0x1);\n\t\tpriv->txpower_cur = 0;\n\t}\n\n\tlbs_deb_cmd(\"RADIO_CONTROL: radio %s, preamble %d\\n\",\n\t\t    radio_on ? \"ON\" : \"OFF\", preamble);\n\n\tpriv->radio_on = radio_on;\n\n\tret = lbs_cmd_with_response(priv, CMD_802_11_RADIO_CONTROL, &cmd);\n\nout:\n\treturn ret;\n}\n\nvoid lbs_set_mac_control(struct lbs_private *priv)\n{\n\tstruct cmd_ds_mac_control cmd;\n\n\tcmd.hdr.size = cpu_to_le16(sizeof(cmd));\n\tcmd.action = cpu_to_le16(priv->mac_control);\n\tcmd.reserved = 0;\n\n\tlbs_cmd_async(priv, CMD_MAC_CONTROL, &cmd.hdr, sizeof(cmd));\n}\n\nint lbs_set_mac_control_sync(struct lbs_private *priv)\n{\n\tstruct cmd_ds_mac_control cmd;\n\tint ret = 0;\n\n\tcmd.hdr.size = cpu_to_le16(sizeof(cmd));\n\tcmd.action = cpu_to_le16(priv->mac_control);\n\tcmd.reserved = 0;\n\tret = lbs_cmd_with_response(priv, CMD_MAC_CONTROL, &cmd);\n\n\treturn ret;\n}\n\n \nint lbs_allocate_cmd_buffer(struct lbs_private *priv)\n{\n\tint ret = 0;\n\tu32 bufsize;\n\tu32 i;\n\tstruct cmd_ctrl_node *cmdarray;\n\n\t \n\tbufsize = sizeof(struct cmd_ctrl_node) * LBS_NUM_CMD_BUFFERS;\n\tif (!(cmdarray = kzalloc(bufsize, GFP_KERNEL))) {\n\t\tlbs_deb_host(\"ALLOC_CMD_BUF: tempcmd_array is NULL\\n\");\n\t\tret = -1;\n\t\tgoto done;\n\t}\n\tpriv->cmd_array = cmdarray;\n\n\t \n\tfor (i = 0; i < LBS_NUM_CMD_BUFFERS; i++) {\n\t\tcmdarray[i].cmdbuf = kzalloc(LBS_CMD_BUFFER_SIZE, GFP_KERNEL);\n\t\tif (!cmdarray[i].cmdbuf) {\n\t\t\tlbs_deb_host(\"ALLOC_CMD_BUF: ptempvirtualaddr is NULL\\n\");\n\t\t\tret = -1;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tfor (i = 0; i < LBS_NUM_CMD_BUFFERS; i++) {\n\t\tinit_waitqueue_head(&cmdarray[i].cmdwait_q);\n\t\tlbs_cleanup_and_insert_cmd(priv, &cmdarray[i]);\n\t}\n\tret = 0;\n\ndone:\n\treturn ret;\n}\n\n \nint lbs_free_cmd_buffer(struct lbs_private *priv)\n{\n\tstruct cmd_ctrl_node *cmdarray;\n\tunsigned int i;\n\n\t \n\tif (priv->cmd_array == NULL) {\n\t\tlbs_deb_host(\"FREE_CMD_BUF: cmd_array is NULL\\n\");\n\t\tgoto done;\n\t}\n\n\tcmdarray = priv->cmd_array;\n\n\t \n\tfor (i = 0; i < LBS_NUM_CMD_BUFFERS; i++) {\n\t\tif (cmdarray[i].cmdbuf) {\n\t\t\tkfree(cmdarray[i].cmdbuf);\n\t\t\tcmdarray[i].cmdbuf = NULL;\n\t\t}\n\t}\n\n\t \n\tif (priv->cmd_array) {\n\t\tkfree(priv->cmd_array);\n\t\tpriv->cmd_array = NULL;\n\t}\n\ndone:\n\treturn 0;\n}\n\n \nstatic struct cmd_ctrl_node *lbs_get_free_cmd_node(struct lbs_private *priv)\n{\n\tstruct cmd_ctrl_node *tempnode;\n\tunsigned long flags;\n\n\tif (!priv)\n\t\treturn NULL;\n\n\tspin_lock_irqsave(&priv->driver_lock, flags);\n\n\tif (!list_empty(&priv->cmdfreeq)) {\n\t\ttempnode = list_first_entry(&priv->cmdfreeq,\n\t\t\t\t\t    struct cmd_ctrl_node, list);\n\t\tlist_del_init(&tempnode->list);\n\t} else {\n\t\tlbs_deb_host(\"GET_CMD_NODE: cmd_ctrl_node is not available\\n\");\n\t\ttempnode = NULL;\n\t}\n\n\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\n\treturn tempnode;\n}\n\n \nint lbs_execute_next_command(struct lbs_private *priv)\n{\n\tstruct cmd_ctrl_node *cmdnode = NULL;\n\tstruct cmd_header *cmd;\n\tunsigned long flags;\n\tint ret = 0;\n\n\t \n\tspin_lock_irqsave(&priv->driver_lock, flags);\n\n\tif (priv->cur_cmd) {\n\t\tnetdev_alert(priv->dev,\n\t\t\t     \"EXEC_NEXT_CMD: already processing command!\\n\");\n\t\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\t\tret = -1;\n\t\tgoto done;\n\t}\n\n\tif (!list_empty(&priv->cmdpendingq)) {\n\t\tcmdnode = list_first_entry(&priv->cmdpendingq,\n\t\t\t\t\t   struct cmd_ctrl_node, list);\n\t}\n\n\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\n\tif (cmdnode) {\n\t\tcmd = cmdnode->cmdbuf;\n\n\t\tif (is_command_allowed_in_ps(le16_to_cpu(cmd->command))) {\n\t\t\tif ((priv->psstate == PS_STATE_SLEEP) ||\n\t\t\t    (priv->psstate == PS_STATE_PRE_SLEEP)) {\n\t\t\t\tlbs_deb_host(\n\t\t\t\t       \"EXEC_NEXT_CMD: cannot send cmd 0x%04x in psstate %d\\n\",\n\t\t\t\t       le16_to_cpu(cmd->command),\n\t\t\t\t       priv->psstate);\n\t\t\t\tret = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tlbs_deb_host(\"EXEC_NEXT_CMD: OK to send command \"\n\t\t\t\t     \"0x%04x in psstate %d\\n\",\n\t\t\t\t     le16_to_cpu(cmd->command), priv->psstate);\n\t\t} else if (priv->psstate != PS_STATE_FULL_POWER) {\n\t\t\t \n\t\t\tif (cmd->command != cpu_to_le16(CMD_802_11_PS_MODE)) {\n\t\t\t\t \n\t\t\t\tif ((priv->psstate == PS_STATE_SLEEP)\n\t\t\t\t    || (priv->psstate == PS_STATE_PRE_SLEEP)\n\t\t\t\t    ) {\n\t\t\t\t\t \n\t\t\t\t\tpriv->needtowakeup = 1;\n\t\t\t\t} else {\n\t\t\t\t\tlbs_set_ps_mode(priv,\n\t\t\t\t\t\t\tPS_MODE_ACTION_EXIT_PS,\n\t\t\t\t\t\t\tfalse);\n\t\t\t\t}\n\n\t\t\t\tret = 0;\n\t\t\t\tgoto done;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tstruct cmd_ds_802_11_ps_mode *psm = (void *)cmd;\n\n\t\t\t\tlbs_deb_host(\n\t\t\t\t       \"EXEC_NEXT_CMD: PS cmd, action 0x%02x\\n\",\n\t\t\t\t       psm->action);\n\t\t\t\tif (psm->action !=\n\t\t\t\t    cpu_to_le16(PS_MODE_ACTION_EXIT_PS)) {\n\t\t\t\t\tlbs_deb_host(\n\t\t\t\t\t       \"EXEC_NEXT_CMD: ignore ENTER_PS cmd\\n\");\n\t\t\t\t\tlbs_complete_command(priv, cmdnode, 0);\n\n\t\t\t\t\tret = 0;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tif ((priv->psstate == PS_STATE_SLEEP) ||\n\t\t\t\t    (priv->psstate == PS_STATE_PRE_SLEEP)) {\n\t\t\t\t\tlbs_deb_host(\n\t\t\t\t\t       \"EXEC_NEXT_CMD: ignore EXIT_PS cmd in sleep\\n\");\n\t\t\t\t\tlbs_complete_command(priv, cmdnode, 0);\n\t\t\t\t\tpriv->needtowakeup = 1;\n\n\t\t\t\t\tret = 0;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tlbs_deb_host(\n\t\t\t\t       \"EXEC_NEXT_CMD: sending EXIT_PS\\n\");\n\t\t\t}\n\t\t}\n\t\tspin_lock_irqsave(&priv->driver_lock, flags);\n\t\tlist_del_init(&cmdnode->list);\n\t\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\t\tlbs_deb_host(\"EXEC_NEXT_CMD: sending command 0x%04x\\n\",\n\t\t\t    le16_to_cpu(cmd->command));\n\t\tlbs_submit_command(priv, cmdnode);\n\t} else {\n\t\t \n\t\tif ((priv->psmode != LBS802_11POWERMODECAM) &&\n\t\t    (priv->psstate == PS_STATE_FULL_POWER) &&\n\t\t    (priv->connect_status == LBS_CONNECTED)) {\n\t\t\tlbs_deb_host(\n\t\t\t\t\"EXEC_NEXT_CMD: cmdpendingq empty, go back to PS_SLEEP\");\n\t\t\tlbs_set_ps_mode(priv, PS_MODE_ACTION_ENTER_PS,\n\t\t\t\t\tfalse);\n\t\t}\n\t}\n\n\tret = 0;\ndone:\n\treturn ret;\n}\n\nstatic void lbs_send_confirmsleep(struct lbs_private *priv)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tlbs_deb_hex(LBS_DEB_HOST, \"sleep confirm\", (u8 *) &confirm_sleep,\n\t\tsizeof(confirm_sleep));\n\n\tret = priv->hw_host_to_card(priv, MVMS_CMD, (u8 *) &confirm_sleep,\n\t\tsizeof(confirm_sleep));\n\tif (ret) {\n\t\tnetdev_alert(priv->dev, \"confirm_sleep failed\\n\");\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&priv->driver_lock, flags);\n\n\t \n\tpriv->dnld_sent = DNLD_RES_RECEIVED;\n\n\tif (priv->is_host_sleep_configured) {\n\t\tpriv->is_host_sleep_activated = 1;\n\t\twake_up_interruptible(&priv->host_sleep_q);\n\t}\n\n\t \n\tif (!kfifo_len(&priv->event_fifo) && !priv->resp_len[priv->resp_idx])\n\t\tpriv->psstate = PS_STATE_SLEEP;\n\n\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n}\n\n \nvoid lbs_ps_confirm_sleep(struct lbs_private *priv)\n{\n\tunsigned long flags =0;\n\tint allowed = 1;\n\n\tspin_lock_irqsave(&priv->driver_lock, flags);\n\tif (priv->dnld_sent) {\n\t\tallowed = 0;\n\t\tlbs_deb_host(\"dnld_sent was set\\n\");\n\t}\n\n\t \n\tif (priv->cur_cmd) {\n\t\tallowed = 0;\n\t\tlbs_deb_host(\"cur_cmd was set\\n\");\n\t}\n\n\t \n\tif (kfifo_len(&priv->event_fifo) || priv->resp_len[priv->resp_idx]) {\n\t\tallowed = 0;\n\t\tlbs_deb_host(\"pending events or command responses\\n\");\n\t}\n\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\n\tif (allowed) {\n\t\tlbs_deb_host(\"sending lbs_ps_confirm_sleep\\n\");\n\t\tlbs_send_confirmsleep(priv);\n\t} else {\n\t\tlbs_deb_host(\"sleep confirm has been delayed\\n\");\n\t}\n}\n\n\n \nint lbs_set_tpc_cfg(struct lbs_private *priv, int enable, int8_t p0, int8_t p1,\n\t\tint8_t p2, int usesnr)\n{\n\tstruct cmd_ds_802_11_tpc_cfg cmd;\n\tint ret;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.hdr.size = cpu_to_le16(sizeof(cmd));\n\tcmd.action = cpu_to_le16(CMD_ACT_SET);\n\tcmd.enable = !!enable;\n\tcmd.usesnr = !!usesnr;\n\tcmd.P0 = p0;\n\tcmd.P1 = p1;\n\tcmd.P2 = p2;\n\n\tret = lbs_cmd_with_response(priv, CMD_802_11_TPC_CFG, &cmd);\n\n\treturn ret;\n}\n\n \n\nint lbs_set_power_adapt_cfg(struct lbs_private *priv, int enable, int8_t p0,\n\t\tint8_t p1, int8_t p2)\n{\n\tstruct cmd_ds_802_11_pa_cfg cmd;\n\tint ret;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.hdr.size = cpu_to_le16(sizeof(cmd));\n\tcmd.action = cpu_to_le16(CMD_ACT_SET);\n\tcmd.enable = !!enable;\n\tcmd.P0 = p0;\n\tcmd.P1 = p1;\n\tcmd.P2 = p2;\n\n\tret = lbs_cmd_with_response(priv, CMD_802_11_PA_CFG , &cmd);\n\n\treturn ret;\n}\n\n\nstruct cmd_ctrl_node *__lbs_cmd_async(struct lbs_private *priv,\n\tuint16_t command, struct cmd_header *in_cmd, int in_cmd_size,\n\tint (*callback)(struct lbs_private *, unsigned long, struct cmd_header *),\n\tunsigned long callback_arg)\n{\n\tstruct cmd_ctrl_node *cmdnode;\n\n\tif (priv->surpriseremoved) {\n\t\tlbs_deb_host(\"PREP_CMD: card removed\\n\");\n\t\tcmdnode = ERR_PTR(-ENOENT);\n\t\tgoto done;\n\t}\n\n\t \n\tif (!priv->is_auto_deep_sleep_enabled) {\n\t\tif (priv->is_deep_sleep) {\n\t\t\tlbs_deb_cmd(\"command not allowed in deep sleep\\n\");\n\t\t\tcmdnode = ERR_PTR(-EBUSY);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tcmdnode = lbs_get_free_cmd_node(priv);\n\tif (cmdnode == NULL) {\n\t\tlbs_deb_host(\"PREP_CMD: cmdnode is NULL\\n\");\n\n\t\t \n\t\twake_up(&priv->waitq);\n\t\tcmdnode = ERR_PTR(-ENOBUFS);\n\t\tgoto done;\n\t}\n\n\tcmdnode->callback = callback;\n\tcmdnode->callback_arg = callback_arg;\n\n\t \n\tmemcpy(cmdnode->cmdbuf, in_cmd, in_cmd_size);\n\n\t \n\tcmdnode->cmdbuf->command = cpu_to_le16(command);\n\tcmdnode->cmdbuf->size    = cpu_to_le16(in_cmd_size);\n\tcmdnode->cmdbuf->result  = 0;\n\n\tlbs_deb_host(\"PREP_CMD: command 0x%04x\\n\", command);\n\n\tcmdnode->cmdwaitqwoken = 0;\n\tlbs_queue_cmd(priv, cmdnode);\n\twake_up(&priv->waitq);\n\n done:\n\treturn cmdnode;\n}\n\nvoid lbs_cmd_async(struct lbs_private *priv, uint16_t command,\n\tstruct cmd_header *in_cmd, int in_cmd_size)\n{\n\t__lbs_cmd_async(priv, command, in_cmd, in_cmd_size,\n\t\tlbs_cmd_async_callback, 0);\n}\n\nint __lbs_cmd(struct lbs_private *priv, uint16_t command,\n\t      struct cmd_header *in_cmd, int in_cmd_size,\n\t      int (*callback)(struct lbs_private *, unsigned long, struct cmd_header *),\n\t      unsigned long callback_arg)\n{\n\tstruct cmd_ctrl_node *cmdnode;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tcmdnode = __lbs_cmd_async(priv, command, in_cmd, in_cmd_size,\n\t\t\t\t  callback, callback_arg);\n\tif (IS_ERR(cmdnode)) {\n\t\tret = PTR_ERR(cmdnode);\n\t\tgoto done;\n\t}\n\n\tmight_sleep();\n\n\t \n\twait_event(cmdnode->cmdwait_q, cmdnode->cmdwaitqwoken);\n\n\tspin_lock_irqsave(&priv->driver_lock, flags);\n\tret = cmdnode->result;\n\tif (ret)\n\t\tnetdev_info(priv->dev, \"PREP_CMD: command 0x%04x failed: %d\\n\",\n\t\t\t    command, ret);\n\n\t__lbs_cleanup_and_insert_cmd(priv, cmdnode);\n\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\ndone:\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(__lbs_cmd);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}