{
  "module_name": "if_cs.c",
  "hash_id": "af3dd0357d7d964aa4f801d4f4b2f2e5a1f3dcb344662c4dd61ffcbbcd3d2e7e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/marvell/libertas/if_cs.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/firmware.h>\n#include <linux/netdevice.h>\n\n#include <pcmcia/cistpl.h>\n#include <pcmcia/ds.h>\n\n#include <linux/io.h>\n\n#define DRV_NAME \"libertas_cs\"\n\n#include \"decl.h\"\n#include \"defs.h\"\n#include \"dev.h\"\n\n\n \n \n \n\nMODULE_AUTHOR(\"Holger Schurig <hs4233@mail.mn-solutions.de>\");\nMODULE_DESCRIPTION(\"Driver for Marvell 83xx compact flash WLAN cards\");\nMODULE_LICENSE(\"GPL\");\n\n\n\n \n \n \n\nstruct if_cs_card {\n\tstruct pcmcia_device *p_dev;\n\tstruct lbs_private *priv;\n\tvoid __iomem *iobase;\n\tbool align_regs;\n\tu32 model;\n};\n\n\nenum {\n\tMODEL_UNKNOWN = 0x00,\n\tMODEL_8305 = 0x01,\n\tMODEL_8381 = 0x02,\n\tMODEL_8385 = 0x03\n};\n\nstatic const struct lbs_fw_table fw_table[] = {\n\t{ MODEL_8305, \"libertas/cf8305.bin\", NULL },\n\t{ MODEL_8305, \"libertas_cs_helper.fw\", NULL },\n\t{ MODEL_8381, \"libertas/cf8381_helper.bin\", \"libertas/cf8381.bin\" },\n\t{ MODEL_8381, \"libertas_cs_helper.fw\", \"libertas_cs.fw\" },\n\t{ MODEL_8385, \"libertas/cf8385_helper.bin\", \"libertas/cf8385.bin\" },\n\t{ MODEL_8385, \"libertas_cs_helper.fw\", \"libertas_cs.fw\" },\n\t{ 0, NULL, NULL }\n};\nMODULE_FIRMWARE(\"libertas/cf8305.bin\");\nMODULE_FIRMWARE(\"libertas/cf8381_helper.bin\");\nMODULE_FIRMWARE(\"libertas/cf8381.bin\");\nMODULE_FIRMWARE(\"libertas/cf8385_helper.bin\");\nMODULE_FIRMWARE(\"libertas/cf8385.bin\");\nMODULE_FIRMWARE(\"libertas_cs_helper.fw\");\nMODULE_FIRMWARE(\"libertas_cs.fw\");\n\n\n \n \n \n\n \n \n\n#ifdef DEBUG_IO\nstatic int debug_output = 0;\n#else\n \n#define debug_output 0\n#endif\n\nstatic inline unsigned int if_cs_read8(struct if_cs_card *card, uint reg)\n{\n\tunsigned int val = ioread8(card->iobase + reg);\n\tif (debug_output)\n\t\tprintk(KERN_INFO \"inb %08x<%02x\\n\", reg, val);\n\treturn val;\n}\nstatic inline unsigned int if_cs_read16(struct if_cs_card *card, uint reg)\n{\n\tunsigned int val = ioread16(card->iobase + reg);\n\tif (debug_output)\n\t\tprintk(KERN_INFO \"inw %08x<%04x\\n\", reg, val);\n\treturn val;\n}\nstatic inline void if_cs_read16_rep(\n\tstruct if_cs_card *card,\n\tuint reg,\n\tvoid *buf,\n\tunsigned long count)\n{\n\tif (debug_output)\n\t\tprintk(KERN_INFO \"insw %08x<(0x%lx words)\\n\",\n\t\t\treg, count);\n\tioread16_rep(card->iobase + reg, buf, count);\n}\n\nstatic inline void if_cs_write8(struct if_cs_card *card, uint reg, u8 val)\n{\n\tif (debug_output)\n\t\tprintk(KERN_INFO \"outb %08x>%02x\\n\", reg, val);\n\tiowrite8(val, card->iobase + reg);\n}\n\nstatic inline void if_cs_write16(struct if_cs_card *card, uint reg, u16 val)\n{\n\tif (debug_output)\n\t\tprintk(KERN_INFO \"outw %08x>%04x\\n\", reg, val);\n\tiowrite16(val, card->iobase + reg);\n}\n\nstatic inline void if_cs_write16_rep(\n\tstruct if_cs_card *card,\n\tuint reg,\n\tconst void *buf,\n\tunsigned long count)\n{\n\tif (debug_output)\n\t\tprintk(KERN_INFO \"outsw %08x>(0x%lx words)\\n\",\n\t\t\treg, count);\n\tiowrite16_rep(card->iobase + reg, buf, count);\n}\n\n\n \nstatic int if_cs_poll_while_fw_download(struct if_cs_card *card, uint addr, u8 reg)\n{\n\tint i;\n\n\tfor (i = 0; i < 100000; i++) {\n\t\tu8 val = if_cs_read8(card, addr);\n\t\tif (val == reg)\n\t\t\treturn 0;\n\t\tudelay(5);\n\t}\n\treturn -ETIME;\n}\n\n\n\n \n#define IF_CS_BIT_TX\t\t\t0x0001\n#define IF_CS_BIT_RX\t\t\t0x0002\n#define IF_CS_BIT_COMMAND\t\t0x0004\n#define IF_CS_BIT_RESP\t\t\t0x0008\n#define IF_CS_BIT_EVENT\t\t\t0x0010\n#define\tIF_CS_BIT_MASK\t\t\t0x001f\n\n\n\n \n#define IF_CS_HOST_STATUS\t\t0x00000000\n\n \n#define IF_CS_HOST_INT_CAUSE\t\t0x00000002\n\n \n#define IF_CS_HOST_INT_MASK\t\t0x00000004\n\n \n#define IF_CS_WRITE\t\t\t0x00000016\n#define IF_CS_WRITE_LEN\t\t\t0x00000014\n#define IF_CS_READ\t\t\t0x00000010\n#define IF_CS_READ_LEN\t\t\t0x00000024\n\n \n#define IF_CS_CMD\t\t\t0x0000001A\n#define IF_CS_CMD_LEN\t\t\t0x00000018\n#define IF_CS_RESP\t\t\t0x00000012\n#define IF_CS_RESP_LEN\t\t\t0x00000030\n\n \n#define IF_CS_CARD_STATUS\t\t0x00000020\n#define IF_CS_CARD_STATUS_MASK\t\t0x7f00\n\n \n#define IF_CS_CARD_INT_CAUSE\t\t0x00000022\n\n \n#define IF_CS_SQ_READ_LOW\t\t0x00000028\n#define IF_CS_SQ_HELPER_OK\t\t0x10\n\n \n#define IF_CS_SCRATCH\t\t\t0x0000003F\n#define IF_CS_SCRATCH_BOOT_OK\t\t0x00\n#define IF_CS_SCRATCH_HELPER_OK\t\t0x5a\n\n \n#define IF_CS_PRODUCT_ID\t\t0x0000001C\n#define IF_CS_CF8385_B1_REV\t\t0x12\n#define IF_CS_CF8381_B3_REV\t\t0x04\n#define IF_CS_CF8305_B1_REV\t\t0x03\n\n \n#define CF8305_MANFID\t\t0x02db\n#define CF8305_CARDID\t\t0x8103\n#define CF8381_MANFID\t\t0x02db\n#define CF8381_CARDID\t\t0x6064\n#define CF8385_MANFID\t\t0x02df\n#define CF8385_CARDID\t\t0x8103\n\n \nstatic inline u32 get_model(u16 manf_id, u16 card_id)\n{\n\t \n\tif (manf_id == CF8305_MANFID && card_id == CF8305_CARDID)\n\t\treturn MODEL_8305;\n\telse if (manf_id == CF8381_MANFID && card_id == CF8381_CARDID)\n\t\treturn MODEL_8381;\n\telse if (manf_id == CF8385_MANFID && card_id == CF8385_CARDID)\n\t\treturn MODEL_8385;\n\treturn MODEL_UNKNOWN;\n}\n\n \n \n \n\nstatic inline void if_cs_enable_ints(struct if_cs_card *card)\n{\n\tif_cs_write16(card, IF_CS_HOST_INT_MASK, 0);\n}\n\nstatic inline void if_cs_disable_ints(struct if_cs_card *card)\n{\n\tif_cs_write16(card, IF_CS_HOST_INT_MASK, IF_CS_BIT_MASK);\n}\n\n \nstatic int if_cs_send_cmd(struct lbs_private *priv, u8 *buf, u16 nb)\n{\n\tstruct if_cs_card *card = (struct if_cs_card *)priv->card;\n\tint ret = -1;\n\tint loops = 0;\n\n\tif_cs_disable_ints(card);\n\n\t \n\twhile (1) {\n\t\tu16 status = if_cs_read16(card, IF_CS_CARD_STATUS);\n\t\tif (status & IF_CS_BIT_COMMAND)\n\t\t\tbreak;\n\t\tif (++loops > 100) {\n\t\t\tnetdev_err(priv->dev, \"card not ready for commands\\n\");\n\t\t\tgoto done;\n\t\t}\n\t\tmdelay(1);\n\t}\n\n\tif_cs_write16(card, IF_CS_CMD_LEN, nb);\n\n\tif_cs_write16_rep(card, IF_CS_CMD, buf, nb / 2);\n\t \n\tif (nb & 1)\n\t\tif_cs_write8(card, IF_CS_CMD, buf[nb-1]);\n\n\t \n\tif_cs_write16(card, IF_CS_HOST_STATUS, IF_CS_BIT_COMMAND);\n\n\t \n\tif_cs_write16(card, IF_CS_HOST_INT_CAUSE, IF_CS_BIT_COMMAND);\n\tret = 0;\n\ndone:\n\tif_cs_enable_ints(card);\n\treturn ret;\n}\n\n \nstatic void if_cs_send_data(struct lbs_private *priv, u8 *buf, u16 nb)\n{\n\tstruct if_cs_card *card = (struct if_cs_card *)priv->card;\n\tu16 status;\n\n\tif_cs_disable_ints(card);\n\n\tstatus = if_cs_read16(card, IF_CS_CARD_STATUS);\n\tBUG_ON((status & IF_CS_BIT_TX) == 0);\n\n\tif_cs_write16(card, IF_CS_WRITE_LEN, nb);\n\n\t \n\tif_cs_write16_rep(card, IF_CS_WRITE, buf, nb / 2);\n\tif (nb & 1)\n\t\tif_cs_write8(card, IF_CS_WRITE, buf[nb-1]);\n\n\tif_cs_write16(card, IF_CS_HOST_STATUS, IF_CS_BIT_TX);\n\tif_cs_write16(card, IF_CS_HOST_INT_CAUSE, IF_CS_BIT_TX);\n\tif_cs_enable_ints(card);\n}\n\n \nstatic int if_cs_receive_cmdres(struct lbs_private *priv, u8 *data, u32 *len)\n{\n\tunsigned long flags;\n\tint ret = -1;\n\tu16 status;\n\n\t \n\tstatus = if_cs_read16(priv->card, IF_CS_CARD_STATUS);\n\tif ((status & IF_CS_BIT_RESP) == 0) {\n\t\tnetdev_err(priv->dev, \"no cmd response in card\\n\");\n\t\t*len = 0;\n\t\tgoto out;\n\t}\n\n\t*len = if_cs_read16(priv->card, IF_CS_RESP_LEN);\n\tif ((*len == 0) || (*len > LBS_CMD_BUFFER_SIZE)) {\n\t\tnetdev_err(priv->dev,\n\t\t\t   \"card cmd buffer has invalid # of bytes (%d)\\n\",\n\t\t\t   *len);\n\t\tgoto out;\n\t}\n\n\t \n\tif_cs_read16_rep(priv->card, IF_CS_RESP, data, *len/sizeof(u16));\n\tif (*len & 1)\n\t\tdata[*len-1] = if_cs_read8(priv->card, IF_CS_RESP);\n\n\t \n\t*len -= 8;\n\tret = 0;\n\n\t \n\tspin_lock_irqsave(&priv->driver_lock, flags);\n\tpriv->dnld_sent = DNLD_RES_RECEIVED;\n\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\nout:\n\treturn ret;\n}\n\nstatic struct sk_buff *if_cs_receive_data(struct lbs_private *priv)\n{\n\tstruct sk_buff *skb = NULL;\n\tu16 len;\n\tu8 *data;\n\n\tlen = if_cs_read16(priv->card, IF_CS_READ_LEN);\n\tif (len == 0 || len > MRVDRV_ETH_RX_PACKET_BUFFER_SIZE) {\n\t\tnetdev_err(priv->dev,\n\t\t\t   \"card data buffer has invalid # of bytes (%d)\\n\",\n\t\t\t   len);\n\t\tpriv->dev->stats.rx_dropped++;\n\t\tgoto dat_err;\n\t}\n\n\tskb = dev_alloc_skb(MRVDRV_ETH_RX_PACKET_BUFFER_SIZE + 2);\n\tif (!skb)\n\t\tgoto out;\n\tskb_put(skb, len);\n\tskb_reserve(skb, 2); \n\tdata = skb->data;\n\n\t \n\tif_cs_read16_rep(priv->card, IF_CS_READ, data, len/sizeof(u16));\n\tif (len & 1)\n\t\tdata[len-1] = if_cs_read8(priv->card, IF_CS_READ);\n\ndat_err:\n\tif_cs_write16(priv->card, IF_CS_HOST_STATUS, IF_CS_BIT_RX);\n\tif_cs_write16(priv->card, IF_CS_HOST_INT_CAUSE, IF_CS_BIT_RX);\n\nout:\n\treturn skb;\n}\n\nstatic irqreturn_t if_cs_interrupt(int irq, void *data)\n{\n\tstruct if_cs_card *card = data;\n\tstruct lbs_private *priv = card->priv;\n\tu16 cause;\n\n\t \n\tcause = if_cs_read16(card, IF_CS_CARD_INT_CAUSE);\n\tlbs_deb_cs(\"cause 0x%04x\\n\", cause);\n\n\tif (cause == 0) {\n\t\t \n\t\treturn IRQ_NONE;\n\t}\n\n\tif (cause == 0xffff) {\n\t\t \n\t\tcard->priv->surpriseremoved = 1;\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (cause & IF_CS_BIT_RX) {\n\t\tstruct sk_buff *skb;\n\t\tlbs_deb_cs(\"rx packet\\n\");\n\t\tskb = if_cs_receive_data(priv);\n\t\tif (skb)\n\t\t\tlbs_process_rxed_packet(priv, skb);\n\t}\n\n\tif (cause & IF_CS_BIT_TX) {\n\t\tlbs_deb_cs(\"tx done\\n\");\n\t\tlbs_host_to_card_done(priv);\n\t}\n\n\tif (cause & IF_CS_BIT_RESP) {\n\t\tunsigned long flags;\n\t\tu8 i;\n\n\t\tlbs_deb_cs(\"cmd resp\\n\");\n\t\tspin_lock_irqsave(&priv->driver_lock, flags);\n\t\ti = (priv->resp_idx == 0) ? 1 : 0;\n\t\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\n\t\tBUG_ON(priv->resp_len[i]);\n\t\tif_cs_receive_cmdres(priv, priv->resp_buf[i],\n\t\t\t&priv->resp_len[i]);\n\n\t\tspin_lock_irqsave(&priv->driver_lock, flags);\n\t\tlbs_notify_command_response(priv, i);\n\t\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\t}\n\n\tif (cause & IF_CS_BIT_EVENT) {\n\t\tu16 status = if_cs_read16(priv->card, IF_CS_CARD_STATUS);\n\t\tif_cs_write16(priv->card, IF_CS_HOST_INT_CAUSE,\n\t\t\tIF_CS_BIT_EVENT);\n\t\tlbs_queue_event(priv, (status & IF_CS_CARD_STATUS_MASK) >> 8);\n\t}\n\n\t \n\tif_cs_write16(card, IF_CS_CARD_INT_CAUSE, cause & IF_CS_BIT_MASK);\n\n\treturn IRQ_HANDLED;\n}\n\n\n\n\n \n \n \n\n \nstatic int if_cs_prog_helper(struct if_cs_card *card, const struct firmware *fw)\n{\n\tint ret = 0;\n\tint sent = 0;\n\tu8  scratch;\n\n\t \n\tif (card->align_regs)\n\t\tscratch = if_cs_read16(card, IF_CS_SCRATCH) >> 8;\n\telse\n\t\tscratch = if_cs_read8(card, IF_CS_SCRATCH);\n\n\t \n\tif (scratch == IF_CS_SCRATCH_HELPER_OK)\n\t\tgoto done;\n\n\t \n\tif (scratch != IF_CS_SCRATCH_BOOT_OK) {\n\t\tret = -ENODEV;\n\t\tgoto done;\n\t}\n\n\tlbs_deb_cs(\"helper size %td\\n\", fw->size);\n\n\t \n\t \n\n\tfor (;;) {\n\t\t \n\t\tint count = 256;\n\t\tint remain = fw->size - sent;\n\n\t\tif (remain < count)\n\t\t\tcount = remain;\n\n\t\t \n\t\tif_cs_write16(card, IF_CS_CMD_LEN, count);\n\n\t\t \n\t\tif (count)\n\t\t\tif_cs_write16_rep(card, IF_CS_CMD,\n\t\t\t\t&fw->data[sent],\n\t\t\t\tcount >> 1);\n\n\t\t \n\t\tif_cs_write8(card, IF_CS_HOST_STATUS, IF_CS_BIT_COMMAND);\n\n\t\t \n\t\tif_cs_write16(card, IF_CS_HOST_INT_CAUSE, IF_CS_BIT_COMMAND);\n\n\t\t \n\t\tret = if_cs_poll_while_fw_download(card, IF_CS_CARD_STATUS,\n\t\t\tIF_CS_BIT_COMMAND);\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"can't download helper at 0x%x, ret %d\\n\",\n\t\t\t       sent, ret);\n\t\t\tgoto done;\n\t\t}\n\n\t\tif (count == 0)\n\t\t\tbreak;\n\n\t\tsent += count;\n\t}\n\ndone:\n\treturn ret;\n}\n\n\nstatic int if_cs_prog_real(struct if_cs_card *card, const struct firmware *fw)\n{\n\tint ret = 0;\n\tint retry = 0;\n\tint len = 0;\n\tint sent;\n\n\tlbs_deb_cs(\"fw size %td\\n\", fw->size);\n\n\tret = if_cs_poll_while_fw_download(card, IF_CS_SQ_READ_LOW,\n\t\tIF_CS_SQ_HELPER_OK);\n\tif (ret < 0) {\n\t\tpr_err(\"helper firmware doesn't answer\\n\");\n\t\tgoto done;\n\t}\n\n\tfor (sent = 0; sent < fw->size; sent += len) {\n\t\tlen = if_cs_read16(card, IF_CS_SQ_READ_LOW);\n\t\tif (len & 1) {\n\t\t\tretry++;\n\t\t\tpr_info(\"odd, need to retry this firmware block\\n\");\n\t\t} else {\n\t\t\tretry = 0;\n\t\t}\n\n\t\tif (retry > 20) {\n\t\t\tpr_err(\"could not download firmware\\n\");\n\t\t\tret = -ENODEV;\n\t\t\tgoto done;\n\t\t}\n\t\tif (retry) {\n\t\t\tsent -= len;\n\t\t}\n\n\n\t\tif_cs_write16(card, IF_CS_CMD_LEN, len);\n\n\t\tif_cs_write16_rep(card, IF_CS_CMD,\n\t\t\t&fw->data[sent],\n\t\t\t(len+1) >> 1);\n\t\tif_cs_write8(card, IF_CS_HOST_STATUS, IF_CS_BIT_COMMAND);\n\t\tif_cs_write16(card, IF_CS_HOST_INT_CAUSE, IF_CS_BIT_COMMAND);\n\n\t\tret = if_cs_poll_while_fw_download(card, IF_CS_CARD_STATUS,\n\t\t\tIF_CS_BIT_COMMAND);\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"can't download firmware at 0x%x\\n\", sent);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tret = if_cs_poll_while_fw_download(card, IF_CS_SCRATCH, 0x5a);\n\tif (ret < 0)\n\t\tpr_err(\"firmware download failed\\n\");\n\ndone:\n\treturn ret;\n}\n\nstatic void if_cs_prog_firmware(struct lbs_private *priv, int ret,\n\t\t\t\t const struct firmware *helper,\n\t\t\t\t const struct firmware *mainfw)\n{\n\tstruct if_cs_card *card = priv->card;\n\n\tif (ret) {\n\t\tpr_err(\"failed to find firmware (%d)\\n\", ret);\n\t\treturn;\n\t}\n\n\t \n\tret = if_cs_prog_helper(card, helper);\n\tif (ret == 0 && (card->model != MODEL_8305))\n\t\tret = if_cs_prog_real(card, mainfw);\n\tif (ret)\n\t\treturn;\n\n\t \n\tret = request_irq(card->p_dev->irq, if_cs_interrupt,\n\t\tIRQF_SHARED, DRV_NAME, card);\n\tif (ret) {\n\t\tpr_err(\"error in request_irq\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif_cs_write16(card, IF_CS_CARD_INT_CAUSE, IF_CS_BIT_MASK);\n\tif_cs_enable_ints(card);\n\n\t \n\tpriv->fw_ready = 1;\n\tif (lbs_start_card(priv) != 0) {\n\t\tpr_err(\"could not activate card\\n\");\n\t\tfree_irq(card->p_dev->irq, card);\n\t}\n}\n\n\n \n \n \n\n \nstatic int if_cs_host_to_card(struct lbs_private *priv,\n\tu8 type,\n\tu8 *buf,\n\tu16 nb)\n{\n\tint ret = -1;\n\n\tswitch (type) {\n\tcase MVMS_DAT:\n\t\tpriv->dnld_sent = DNLD_DATA_SENT;\n\t\tif_cs_send_data(priv, buf, nb);\n\t\tret = 0;\n\t\tbreak;\n\tcase MVMS_CMD:\n\t\tpriv->dnld_sent = DNLD_CMD_SENT;\n\t\tret = if_cs_send_cmd(priv, buf, nb);\n\t\tbreak;\n\tdefault:\n\t\tnetdev_err(priv->dev, \"%s: unsupported type %d\\n\",\n\t\t\t   __func__, type);\n\t}\n\n\treturn ret;\n}\n\n\nstatic void if_cs_release(struct pcmcia_device *p_dev)\n{\n\tstruct if_cs_card *card = p_dev->priv;\n\n\tfree_irq(p_dev->irq, card);\n\tpcmcia_disable_device(p_dev);\n\tif (card->iobase)\n\t\tioport_unmap(card->iobase);\n}\n\n\nstatic int if_cs_ioprobe(struct pcmcia_device *p_dev, void *priv_data)\n{\n\tp_dev->resource[0]->flags &= ~IO_DATA_PATH_WIDTH;\n\tp_dev->resource[0]->flags |= IO_DATA_PATH_WIDTH_AUTO;\n\n\tif (p_dev->resource[1]->end) {\n\t\tpr_err(\"wrong CIS (check number of IO windows)\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\treturn pcmcia_request_io(p_dev);\n}\n\nstatic int if_cs_probe(struct pcmcia_device *p_dev)\n{\n\tint ret = -ENOMEM;\n\tunsigned int prod_id;\n\tstruct lbs_private *priv;\n\tstruct if_cs_card *card;\n\n\tcard = kzalloc(sizeof(struct if_cs_card), GFP_KERNEL);\n\tif (!card)\n\t\tgoto out;\n\n\tcard->p_dev = p_dev;\n\tp_dev->priv = card;\n\n\tp_dev->config_flags |= CONF_ENABLE_IRQ | CONF_AUTO_SET_IO;\n\n\tif (pcmcia_loop_config(p_dev, if_cs_ioprobe, NULL)) {\n\t\tpr_err(\"error in pcmcia_loop_config\\n\");\n\t\tgoto out1;\n\t}\n\n\t \n\tif (!p_dev->irq)\n\t\tgoto out1;\n\n\t \n\tcard->iobase = ioport_map(p_dev->resource[0]->start,\n\t\t\t\tresource_size(p_dev->resource[0]));\n\tif (!card->iobase) {\n\t\tpr_err(\"error in ioport_map\\n\");\n\t\tret = -EIO;\n\t\tgoto out1;\n\t}\n\n\tret = pcmcia_enable_device(p_dev);\n\tif (ret) {\n\t\tpr_err(\"error in pcmcia_enable_device\\n\");\n\t\tgoto out2;\n\t}\n\n\t \n\tlbs_deb_cs(\"irq %d, io %pR\", p_dev->irq, p_dev->resource[0]);\n\n\t \n\tcard->align_regs = false;\n\n\tcard->model = get_model(p_dev->manf_id, p_dev->card_id);\n\tif (card->model == MODEL_UNKNOWN) {\n\t\tpr_err(\"unsupported manf_id 0x%04x / card_id 0x%04x\\n\",\n\t\t       p_dev->manf_id, p_dev->card_id);\n\t\tret = -ENODEV;\n\t\tgoto out2;\n\t}\n\n\t \n\tprod_id = if_cs_read8(card, IF_CS_PRODUCT_ID);\n\tif (card->model == MODEL_8305) {\n\t\tcard->align_regs = true;\n\t\tif (prod_id < IF_CS_CF8305_B1_REV) {\n\t\t\tpr_err(\"8305 rev B0 and older are not supported\\n\");\n\t\t\tret = -ENODEV;\n\t\t\tgoto out2;\n\t\t}\n\t}\n\n\tif ((card->model == MODEL_8381) && prod_id < IF_CS_CF8381_B3_REV) {\n\t\tpr_err(\"8381 rev B2 and older are not supported\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out2;\n\t}\n\n\tif ((card->model == MODEL_8385) && prod_id < IF_CS_CF8385_B1_REV) {\n\t\tpr_err(\"8385 rev B0 and older are not supported\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out2;\n\t}\n\n\t \n\tpriv = lbs_add_card(card, &p_dev->dev);\n\tif (IS_ERR(priv)) {\n\t\tret = PTR_ERR(priv);\n\t\tgoto out2;\n\t}\n\n\t \n\tcard->priv = priv;\n\tpriv->card = card;\n\tpriv->hw_host_to_card = if_cs_host_to_card;\n\tpriv->enter_deep_sleep = NULL;\n\tpriv->exit_deep_sleep = NULL;\n\tpriv->reset_deep_sleep_wakeup = NULL;\n\n\t \n\tret = lbs_get_firmware_async(priv, &p_dev->dev, card->model, fw_table,\n\t\t\t\t     if_cs_prog_firmware);\n\tif (ret) {\n\t\tpr_err(\"failed to find firmware (%d)\\n\", ret);\n\t\tgoto out3;\n\t}\n\n\tgoto out;\n\nout3:\n\tlbs_remove_card(priv);\nout2:\n\tioport_unmap(card->iobase);\nout1:\n\tpcmcia_disable_device(p_dev);\nout:\n\treturn ret;\n}\n\n\nstatic void if_cs_detach(struct pcmcia_device *p_dev)\n{\n\tstruct if_cs_card *card = p_dev->priv;\n\n\tlbs_stop_card(card->priv);\n\tlbs_remove_card(card->priv);\n\tif_cs_disable_ints(card);\n\tif_cs_release(p_dev);\n\tkfree(card);\n}\n\n\n\n \n \n \n\nstatic const struct pcmcia_device_id if_cs_ids[] = {\n\tPCMCIA_DEVICE_MANF_CARD(CF8305_MANFID, CF8305_CARDID),\n\tPCMCIA_DEVICE_MANF_CARD(CF8381_MANFID, CF8381_CARDID),\n\tPCMCIA_DEVICE_MANF_CARD(CF8385_MANFID, CF8385_CARDID),\n\t \n\tPCMCIA_DEVICE_NULL,\n};\nMODULE_DEVICE_TABLE(pcmcia, if_cs_ids);\n\nstatic struct pcmcia_driver lbs_driver = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= DRV_NAME,\n\t.probe\t\t= if_cs_probe,\n\t.remove\t\t= if_cs_detach,\n\t.id_table       = if_cs_ids,\n};\nmodule_pcmcia_driver(lbs_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}