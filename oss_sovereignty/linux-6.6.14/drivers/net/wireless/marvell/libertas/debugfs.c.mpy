{
  "module_name": "debugfs.c",
  "hash_id": "4d9b5d56162a069661f06e7f65b68c87199b78e54d0f5025a69021a3a8aae35a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/marvell/libertas/debugfs.c",
  "human_readable_source": "\n#include <linux/dcache.h>\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\n#include \"decl.h\"\n#include \"cmd.h\"\n#include \"debugfs.h\"\n\nstatic struct dentry *lbs_dir;\nstatic char *szStates[] = {\n\t\"Connected\",\n\t\"Disconnected\"\n};\n\n#ifdef PROC_DEBUG\nstatic void lbs_debug_init(struct lbs_private *priv);\n#endif\n\nstatic ssize_t write_file_dummy(struct file *file, const char __user *buf,\n                                size_t count, loff_t *ppos)\n{\n        return -EINVAL;\n}\n\nstatic const size_t len = PAGE_SIZE;\n\nstatic ssize_t lbs_dev_info(struct file *file, char __user *userbuf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct lbs_private *priv = file->private_data;\n\tsize_t pos = 0;\n\tunsigned long addr = get_zeroed_page(GFP_KERNEL);\n\tchar *buf = (char *)addr;\n\tssize_t res;\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tpos += snprintf(buf+pos, len-pos, \"state = %s\\n\",\n\t\t\t\tszStates[priv->connect_status]);\n\tpos += snprintf(buf+pos, len-pos, \"region_code = %02x\\n\",\n\t\t\t\t(u32) priv->regioncode);\n\n\tres = simple_read_from_buffer(userbuf, count, ppos, buf, pos);\n\n\tfree_page(addr);\n\treturn res;\n}\n\nstatic ssize_t lbs_sleepparams_write(struct file *file,\n\t\t\t\tconst char __user *user_buf, size_t count,\n\t\t\t\tloff_t *ppos)\n{\n\tstruct lbs_private *priv = file->private_data;\n\tssize_t ret;\n\tstruct sleep_params sp;\n\tint p1, p2, p3, p4, p5, p6;\n\tchar *buf;\n\n\tbuf = memdup_user_nul(user_buf, min(count, len - 1));\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tret = sscanf(buf, \"%d %d %d %d %d %d\", &p1, &p2, &p3, &p4, &p5, &p6);\n\tif (ret != 6) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\tsp.sp_error = p1;\n\tsp.sp_offset = p2;\n\tsp.sp_stabletime = p3;\n\tsp.sp_calcontrol = p4;\n\tsp.sp_extsleepclk = p5;\n\tsp.sp_reserved = p6;\n\n\tret = lbs_cmd_802_11_sleep_params(priv, CMD_ACT_SET, &sp);\n\tif (!ret)\n\t\tret = count;\n\telse if (ret > 0)\n\t\tret = -EINVAL;\n\nout_unlock:\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic ssize_t lbs_sleepparams_read(struct file *file, char __user *userbuf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct lbs_private *priv = file->private_data;\n\tssize_t ret;\n\tsize_t pos = 0;\n\tstruct sleep_params sp;\n\tunsigned long addr = get_zeroed_page(GFP_KERNEL);\n\tchar *buf = (char *)addr;\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = lbs_cmd_802_11_sleep_params(priv, CMD_ACT_GET, &sp);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tpos += snprintf(buf, len, \"%d %d %d %d %d %d\\n\", sp.sp_error,\n\t\t\tsp.sp_offset, sp.sp_stabletime,\n\t\t\tsp.sp_calcontrol, sp.sp_extsleepclk,\n\t\t\tsp.sp_reserved);\n\n\tret = simple_read_from_buffer(userbuf, count, ppos, buf, pos);\n\nout_unlock:\n\tfree_page(addr);\n\treturn ret;\n}\n\nstatic ssize_t lbs_host_sleep_write(struct file *file,\n\t\t\t\tconst char __user *user_buf, size_t count,\n\t\t\t\tloff_t *ppos)\n{\n\tstruct lbs_private *priv = file->private_data;\n\tssize_t ret;\n\tint host_sleep;\n\tchar *buf;\n\n\tbuf = memdup_user_nul(user_buf, min(count, len - 1));\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tret = sscanf(buf, \"%d\", &host_sleep);\n\tif (ret != 1) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tif (host_sleep == 0)\n\t\tret = lbs_set_host_sleep(priv, 0);\n\telse if (host_sleep == 1) {\n\t\tif (priv->wol_criteria == EHS_REMOVE_WAKEUP) {\n\t\t\tnetdev_info(priv->dev,\n\t\t\t\t    \"wake parameters not configured\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_unlock;\n\t\t}\n\t\tret = lbs_set_host_sleep(priv, 1);\n\t} else {\n\t\tnetdev_err(priv->dev, \"invalid option\\n\");\n\t\tret = -EINVAL;\n\t}\n\n\tif (!ret)\n\t\tret = count;\n\nout_unlock:\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic ssize_t lbs_host_sleep_read(struct file *file, char __user *userbuf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct lbs_private *priv = file->private_data;\n\tssize_t ret;\n\tsize_t pos = 0;\n\tunsigned long addr = get_zeroed_page(GFP_KERNEL);\n\tchar *buf = (char *)addr;\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tpos += snprintf(buf, len, \"%d\\n\", priv->is_host_sleep_activated);\n\n\tret = simple_read_from_buffer(userbuf, count, ppos, buf, pos);\n\n\tfree_page(addr);\n\treturn ret;\n}\n\n \nstatic void *lbs_tlv_find(uint16_t tlv_type, const uint8_t *tlv, uint16_t size)\n{\n\tstruct mrvl_ie_header *tlv_h;\n\tuint16_t length;\n\tssize_t pos = 0;\n\n\twhile (pos < size) {\n\t\ttlv_h = (struct mrvl_ie_header *) tlv;\n\t\tif (!tlv_h->len)\n\t\t\treturn NULL;\n\t\tif (tlv_h->type == cpu_to_le16(tlv_type))\n\t\t\treturn tlv_h;\n\t\tlength = le16_to_cpu(tlv_h->len) + sizeof(*tlv_h);\n\t\tpos += length;\n\t\ttlv += length;\n\t}\n\treturn NULL;\n}\n\n\nstatic ssize_t lbs_threshold_read(uint16_t tlv_type, uint16_t event_mask,\n\t\t\t\t  struct file *file, char __user *userbuf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct cmd_ds_802_11_subscribe_event *subscribed;\n\tstruct mrvl_ie_thresholds *got;\n\tstruct lbs_private *priv = file->private_data;\n\tssize_t ret = 0;\n\tsize_t pos = 0;\n\tchar *buf;\n\tu8 value;\n\tu8 freq;\n\tint events = 0;\n\n\tbuf = (char *)get_zeroed_page(GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tsubscribed = kzalloc(sizeof(*subscribed), GFP_KERNEL);\n\tif (!subscribed) {\n\t\tret = -ENOMEM;\n\t\tgoto out_page;\n\t}\n\n\tsubscribed->hdr.size = cpu_to_le16(sizeof(*subscribed));\n\tsubscribed->action = cpu_to_le16(CMD_ACT_GET);\n\n\tret = lbs_cmd_with_response(priv, CMD_802_11_SUBSCRIBE_EVENT, subscribed);\n\tif (ret)\n\t\tgoto out_cmd;\n\n\tgot = lbs_tlv_find(tlv_type, subscribed->tlv, sizeof(subscribed->tlv));\n\tif (got) {\n\t\tvalue = got->value;\n\t\tfreq  = got->freq;\n\t\tevents = le16_to_cpu(subscribed->events);\n\n\t\tpos += snprintf(buf, len, \"%d %d %d\\n\", value, freq,\n\t\t\t\t!!(events & event_mask));\n\t}\n\n\tret = simple_read_from_buffer(userbuf, count, ppos, buf, pos);\n\n out_cmd:\n\tkfree(subscribed);\n\n out_page:\n\tfree_page((unsigned long)buf);\n\treturn ret;\n}\n\n\nstatic ssize_t lbs_threshold_write(uint16_t tlv_type, uint16_t event_mask,\n\t\t\t\t   struct file *file,\n\t\t\t\t   const char __user *userbuf, size_t count,\n\t\t\t\t   loff_t *ppos)\n{\n\tstruct cmd_ds_802_11_subscribe_event *events;\n\tstruct mrvl_ie_thresholds *tlv;\n\tstruct lbs_private *priv = file->private_data;\n\tint value, freq, new_mask;\n\tuint16_t curr_mask;\n\tchar *buf;\n\tint ret;\n\n\tbuf = memdup_user_nul(userbuf, min(count, len - 1));\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tret = sscanf(buf, \"%d %d %d\", &value, &freq, &new_mask);\n\tif (ret != 3) {\n\t\tret = -EINVAL;\n\t\tgoto out_page;\n\t}\n\tevents = kzalloc(sizeof(*events), GFP_KERNEL);\n\tif (!events) {\n\t\tret = -ENOMEM;\n\t\tgoto out_page;\n\t}\n\n\tevents->hdr.size = cpu_to_le16(sizeof(*events));\n\tevents->action = cpu_to_le16(CMD_ACT_GET);\n\n\tret = lbs_cmd_with_response(priv, CMD_802_11_SUBSCRIBE_EVENT, events);\n\tif (ret)\n\t\tgoto out_events;\n\n\tcurr_mask = le16_to_cpu(events->events);\n\n\tif (new_mask)\n\t\tnew_mask = curr_mask | event_mask;\n\telse\n\t\tnew_mask = curr_mask & ~event_mask;\n\n\t \n\n\ttlv = (void *)events->tlv;\n\n\tevents->action = cpu_to_le16(CMD_ACT_SET);\n\tevents->events = cpu_to_le16(new_mask);\n\ttlv->header.type = cpu_to_le16(tlv_type);\n\ttlv->header.len = cpu_to_le16(sizeof(*tlv) - sizeof(tlv->header));\n\ttlv->value = value;\n\tif (tlv_type != TLV_TYPE_BCNMISS)\n\t\ttlv->freq = freq;\n\n\t \n\tevents->hdr.size = cpu_to_le16(sizeof(events->hdr) + 4 + sizeof(*tlv));\n\n\tret = lbs_cmd_with_response(priv, CMD_802_11_SUBSCRIBE_EVENT, events);\n\n\tif (!ret)\n\t\tret = count;\n out_events:\n\tkfree(events);\n out_page:\n\tkfree(buf);\n\treturn ret;\n}\n\n\nstatic ssize_t lbs_lowrssi_read(struct file *file, char __user *userbuf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\treturn lbs_threshold_read(TLV_TYPE_RSSI_LOW, CMD_SUBSCRIBE_RSSI_LOW,\n\t\t\t\t  file, userbuf, count, ppos);\n}\n\n\nstatic ssize_t lbs_lowrssi_write(struct file *file, const char __user *userbuf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\treturn lbs_threshold_write(TLV_TYPE_RSSI_LOW, CMD_SUBSCRIBE_RSSI_LOW,\n\t\t\t\t   file, userbuf, count, ppos);\n}\n\n\nstatic ssize_t lbs_lowsnr_read(struct file *file, char __user *userbuf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\treturn lbs_threshold_read(TLV_TYPE_SNR_LOW, CMD_SUBSCRIBE_SNR_LOW,\n\t\t\t\t  file, userbuf, count, ppos);\n}\n\n\nstatic ssize_t lbs_lowsnr_write(struct file *file, const char __user *userbuf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\treturn lbs_threshold_write(TLV_TYPE_SNR_LOW, CMD_SUBSCRIBE_SNR_LOW,\n\t\t\t\t   file, userbuf, count, ppos);\n}\n\n\nstatic ssize_t lbs_failcount_read(struct file *file, char __user *userbuf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\treturn lbs_threshold_read(TLV_TYPE_FAILCOUNT, CMD_SUBSCRIBE_FAILCOUNT,\n\t\t\t\t  file, userbuf, count, ppos);\n}\n\n\nstatic ssize_t lbs_failcount_write(struct file *file, const char __user *userbuf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\treturn lbs_threshold_write(TLV_TYPE_FAILCOUNT, CMD_SUBSCRIBE_FAILCOUNT,\n\t\t\t\t   file, userbuf, count, ppos);\n}\n\n\nstatic ssize_t lbs_highrssi_read(struct file *file, char __user *userbuf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\treturn lbs_threshold_read(TLV_TYPE_RSSI_HIGH, CMD_SUBSCRIBE_RSSI_HIGH,\n\t\t\t\t  file, userbuf, count, ppos);\n}\n\n\nstatic ssize_t lbs_highrssi_write(struct file *file, const char __user *userbuf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\treturn lbs_threshold_write(TLV_TYPE_RSSI_HIGH, CMD_SUBSCRIBE_RSSI_HIGH,\n\t\t\t\t   file, userbuf, count, ppos);\n}\n\n\nstatic ssize_t lbs_highsnr_read(struct file *file, char __user *userbuf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\treturn lbs_threshold_read(TLV_TYPE_SNR_HIGH, CMD_SUBSCRIBE_SNR_HIGH,\n\t\t\t\t  file, userbuf, count, ppos);\n}\n\n\nstatic ssize_t lbs_highsnr_write(struct file *file, const char __user *userbuf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\treturn lbs_threshold_write(TLV_TYPE_SNR_HIGH, CMD_SUBSCRIBE_SNR_HIGH,\n\t\t\t\t   file, userbuf, count, ppos);\n}\n\nstatic ssize_t lbs_bcnmiss_read(struct file *file, char __user *userbuf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\treturn lbs_threshold_read(TLV_TYPE_BCNMISS, CMD_SUBSCRIBE_BCNMISS,\n\t\t\t\t  file, userbuf, count, ppos);\n}\n\n\nstatic ssize_t lbs_bcnmiss_write(struct file *file, const char __user *userbuf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\treturn lbs_threshold_write(TLV_TYPE_BCNMISS, CMD_SUBSCRIBE_BCNMISS,\n\t\t\t\t   file, userbuf, count, ppos);\n}\n\n\nstatic ssize_t lbs_rdmac_read(struct file *file, char __user *userbuf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct lbs_private *priv = file->private_data;\n\tssize_t pos = 0;\n\tint ret;\n\tunsigned long addr = get_zeroed_page(GFP_KERNEL);\n\tchar *buf = (char *)addr;\n\tu32 val = 0;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = lbs_get_reg(priv, CMD_MAC_REG_ACCESS, priv->mac_offset, &val);\n\tmdelay(10);\n\tif (!ret) {\n\t\tpos = snprintf(buf, len, \"MAC[0x%x] = 0x%08x\\n\",\n\t\t\t\tpriv->mac_offset, val);\n\t\tret = simple_read_from_buffer(userbuf, count, ppos, buf, pos);\n\t}\n\tfree_page(addr);\n\treturn ret;\n}\n\nstatic ssize_t lbs_rdmac_write(struct file *file,\n\t\t\t\t    const char __user *userbuf,\n\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct lbs_private *priv = file->private_data;\n\tchar *buf;\n\n\tbuf = memdup_user_nul(userbuf, min(count, len - 1));\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tpriv->mac_offset = simple_strtoul(buf, NULL, 16);\n\tkfree(buf);\n\treturn count;\n}\n\nstatic ssize_t lbs_wrmac_write(struct file *file,\n\t\t\t\t    const char __user *userbuf,\n\t\t\t\t    size_t count, loff_t *ppos)\n{\n\n\tstruct lbs_private *priv = file->private_data;\n\tssize_t res;\n\tu32 offset, value;\n\tchar *buf;\n\n\tbuf = memdup_user_nul(userbuf, min(count, len - 1));\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tres = sscanf(buf, \"%x %x\", &offset, &value);\n\tif (res != 2) {\n\t\tres = -EFAULT;\n\t\tgoto out_unlock;\n\t}\n\n\tres = lbs_set_reg(priv, CMD_MAC_REG_ACCESS, offset, value);\n\tmdelay(10);\n\n\tif (!res)\n\t\tres = count;\nout_unlock:\n\tkfree(buf);\n\treturn res;\n}\n\nstatic ssize_t lbs_rdbbp_read(struct file *file, char __user *userbuf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct lbs_private *priv = file->private_data;\n\tssize_t pos = 0;\n\tint ret;\n\tunsigned long addr = get_zeroed_page(GFP_KERNEL);\n\tchar *buf = (char *)addr;\n\tu32 val;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = lbs_get_reg(priv, CMD_BBP_REG_ACCESS, priv->bbp_offset, &val);\n\tmdelay(10);\n\tif (!ret) {\n\t\tpos = snprintf(buf, len, \"BBP[0x%x] = 0x%08x\\n\",\n\t\t\t\tpriv->bbp_offset, val);\n\t\tret = simple_read_from_buffer(userbuf, count, ppos, buf, pos);\n\t}\n\tfree_page(addr);\n\n\treturn ret;\n}\n\nstatic ssize_t lbs_rdbbp_write(struct file *file,\n\t\t\t\t    const char __user *userbuf,\n\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct lbs_private *priv = file->private_data;\n\tchar *buf;\n\n\tbuf = memdup_user_nul(userbuf, min(count, len - 1));\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tpriv->bbp_offset = simple_strtoul(buf, NULL, 16);\n\tkfree(buf);\n\n\treturn count;\n}\n\nstatic ssize_t lbs_wrbbp_write(struct file *file,\n\t\t\t\t    const char __user *userbuf,\n\t\t\t\t    size_t count, loff_t *ppos)\n{\n\n\tstruct lbs_private *priv = file->private_data;\n\tssize_t res;\n\tu32 offset, value;\n\tchar *buf;\n\n\tbuf = memdup_user_nul(userbuf, min(count, len - 1));\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tres = sscanf(buf, \"%x %x\", &offset, &value);\n\tif (res != 2) {\n\t\tres = -EFAULT;\n\t\tgoto out_unlock;\n\t}\n\n\tres = lbs_set_reg(priv, CMD_BBP_REG_ACCESS, offset, value);\n\tmdelay(10);\n\n\tif (!res)\n\t\tres = count;\nout_unlock:\n\tkfree(buf);\n\treturn res;\n}\n\nstatic ssize_t lbs_rdrf_read(struct file *file, char __user *userbuf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct lbs_private *priv = file->private_data;\n\tssize_t pos = 0;\n\tint ret;\n\tunsigned long addr = get_zeroed_page(GFP_KERNEL);\n\tchar *buf = (char *)addr;\n\tu32 val;\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = lbs_get_reg(priv, CMD_RF_REG_ACCESS, priv->rf_offset, &val);\n\tmdelay(10);\n\tif (!ret) {\n\t\tpos = snprintf(buf, len, \"RF[0x%x] = 0x%08x\\n\",\n\t\t\t\tpriv->rf_offset, val);\n\t\tret = simple_read_from_buffer(userbuf, count, ppos, buf, pos);\n\t}\n\tfree_page(addr);\n\n\treturn ret;\n}\n\nstatic ssize_t lbs_rdrf_write(struct file *file,\n\t\t\t\t    const char __user *userbuf,\n\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct lbs_private *priv = file->private_data;\n\tchar *buf;\n\n\tbuf = memdup_user_nul(userbuf, min(count, len - 1));\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tpriv->rf_offset = simple_strtoul(buf, NULL, 16);\n\tkfree(buf);\n\treturn count;\n}\n\nstatic ssize_t lbs_wrrf_write(struct file *file,\n\t\t\t\t    const char __user *userbuf,\n\t\t\t\t    size_t count, loff_t *ppos)\n{\n\n\tstruct lbs_private *priv = file->private_data;\n\tssize_t res;\n\tu32 offset, value;\n\tchar *buf;\n\n\tbuf = memdup_user_nul(userbuf, min(count, len - 1));\n\tif (IS_ERR(buf))\n\t\treturn PTR_ERR(buf);\n\n\tres = sscanf(buf, \"%x %x\", &offset, &value);\n\tif (res != 2) {\n\t\tres = -EFAULT;\n\t\tgoto out_unlock;\n\t}\n\n\tres = lbs_set_reg(priv, CMD_RF_REG_ACCESS, offset, value);\n\tmdelay(10);\n\n\tif (!res)\n\t\tres = count;\nout_unlock:\n\tkfree(buf);\n\treturn res;\n}\n\n#define FOPS(fread, fwrite) { \\\n\t.owner = THIS_MODULE, \\\n\t.open = simple_open, \\\n\t.read = (fread), \\\n\t.write = (fwrite), \\\n\t.llseek = generic_file_llseek, \\\n}\n\nstruct lbs_debugfs_files {\n\tconst char *name;\n\tumode_t perm;\n\tstruct file_operations fops;\n};\n\nstatic const struct lbs_debugfs_files debugfs_files[] = {\n\t{ \"info\", 0444, FOPS(lbs_dev_info, write_file_dummy), },\n\t{ \"sleepparams\", 0644, FOPS(lbs_sleepparams_read,\n\t\t\t\tlbs_sleepparams_write), },\n\t{ \"hostsleep\", 0644, FOPS(lbs_host_sleep_read,\n\t\t\t\tlbs_host_sleep_write), },\n};\n\nstatic const struct lbs_debugfs_files debugfs_events_files[] = {\n\t{\"low_rssi\", 0644, FOPS(lbs_lowrssi_read,\n\t\t\t\tlbs_lowrssi_write), },\n\t{\"low_snr\", 0644, FOPS(lbs_lowsnr_read,\n\t\t\t\tlbs_lowsnr_write), },\n\t{\"failure_count\", 0644, FOPS(lbs_failcount_read,\n\t\t\t\tlbs_failcount_write), },\n\t{\"beacon_missed\", 0644, FOPS(lbs_bcnmiss_read,\n\t\t\t\tlbs_bcnmiss_write), },\n\t{\"high_rssi\", 0644, FOPS(lbs_highrssi_read,\n\t\t\t\tlbs_highrssi_write), },\n\t{\"high_snr\", 0644, FOPS(lbs_highsnr_read,\n\t\t\t\tlbs_highsnr_write), },\n};\n\nstatic const struct lbs_debugfs_files debugfs_regs_files[] = {\n\t{\"rdmac\", 0644, FOPS(lbs_rdmac_read, lbs_rdmac_write), },\n\t{\"wrmac\", 0600, FOPS(NULL, lbs_wrmac_write), },\n\t{\"rdbbp\", 0644, FOPS(lbs_rdbbp_read, lbs_rdbbp_write), },\n\t{\"wrbbp\", 0600, FOPS(NULL, lbs_wrbbp_write), },\n\t{\"rdrf\", 0644, FOPS(lbs_rdrf_read, lbs_rdrf_write), },\n\t{\"wrrf\", 0600, FOPS(NULL, lbs_wrrf_write), },\n};\n\nvoid lbs_debugfs_init(void)\n{\n\tif (!lbs_dir)\n\t\tlbs_dir = debugfs_create_dir(\"lbs_wireless\", NULL);\n}\n\nvoid lbs_debugfs_remove(void)\n{\n\tdebugfs_remove(lbs_dir);\n}\n\nvoid lbs_debugfs_init_one(struct lbs_private *priv, struct net_device *dev)\n{\n\tint i;\n\tconst struct lbs_debugfs_files *files;\n\tif (!lbs_dir)\n\t\tgoto exit;\n\n\tpriv->debugfs_dir = debugfs_create_dir(dev->name, lbs_dir);\n\n\tfor (i=0; i<ARRAY_SIZE(debugfs_files); i++) {\n\t\tfiles = &debugfs_files[i];\n\t\tpriv->debugfs_files[i] = debugfs_create_file(files->name,\n\t\t\t\t\t\t\t     files->perm,\n\t\t\t\t\t\t\t     priv->debugfs_dir,\n\t\t\t\t\t\t\t     priv,\n\t\t\t\t\t\t\t     &files->fops);\n\t}\n\n\tpriv->events_dir = debugfs_create_dir(\"subscribed_events\", priv->debugfs_dir);\n\n\tfor (i=0; i<ARRAY_SIZE(debugfs_events_files); i++) {\n\t\tfiles = &debugfs_events_files[i];\n\t\tpriv->debugfs_events_files[i] = debugfs_create_file(files->name,\n\t\t\t\t\t\t\t     files->perm,\n\t\t\t\t\t\t\t     priv->events_dir,\n\t\t\t\t\t\t\t     priv,\n\t\t\t\t\t\t\t     &files->fops);\n\t}\n\n\tpriv->regs_dir = debugfs_create_dir(\"registers\", priv->debugfs_dir);\n\n\tfor (i=0; i<ARRAY_SIZE(debugfs_regs_files); i++) {\n\t\tfiles = &debugfs_regs_files[i];\n\t\tpriv->debugfs_regs_files[i] = debugfs_create_file(files->name,\n\t\t\t\t\t\t\t     files->perm,\n\t\t\t\t\t\t\t     priv->regs_dir,\n\t\t\t\t\t\t\t     priv,\n\t\t\t\t\t\t\t     &files->fops);\n\t}\n\n#ifdef PROC_DEBUG\n\tlbs_debug_init(priv);\n#endif\nexit:\n\treturn;\n}\n\nvoid lbs_debugfs_remove_one(struct lbs_private *priv)\n{\n\tint i;\n\n\tfor(i=0; i<ARRAY_SIZE(debugfs_regs_files); i++)\n\t\tdebugfs_remove(priv->debugfs_regs_files[i]);\n\n\tdebugfs_remove(priv->regs_dir);\n\n\tfor(i=0; i<ARRAY_SIZE(debugfs_events_files); i++)\n\t\tdebugfs_remove(priv->debugfs_events_files[i]);\n\n\tdebugfs_remove(priv->events_dir);\n#ifdef PROC_DEBUG\n\tdebugfs_remove(priv->debugfs_debug);\n#endif\n\tfor(i=0; i<ARRAY_SIZE(debugfs_files); i++)\n\t\tdebugfs_remove(priv->debugfs_files[i]);\n\tdebugfs_remove(priv->debugfs_dir);\n}\n\n\n\n \n\n#ifdef PROC_DEBUG\n\n#define item_size(n)\t(sizeof_field(struct lbs_private, n))\n#define item_addr(n)\t(offsetof(struct lbs_private, n))\n\n\nstruct debug_data {\n\tchar name[32];\n\tu32 size;\n\tsize_t addr;\n};\n\n \nstatic struct debug_data items[] = {\n\t{\"psmode\", item_size(psmode), item_addr(psmode)},\n\t{\"psstate\", item_size(psstate), item_addr(psstate)},\n};\n\nstatic int num_of_items = ARRAY_SIZE(items);\n\n \nstatic ssize_t lbs_debugfs_read(struct file *file, char __user *userbuf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tint val = 0;\n\tsize_t pos = 0;\n\tssize_t res;\n\tchar *p;\n\tint i;\n\tstruct debug_data *d;\n\tunsigned long addr = get_zeroed_page(GFP_KERNEL);\n\tchar *buf = (char *)addr;\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tp = buf;\n\n\td = file->private_data;\n\n\tfor (i = 0; i < num_of_items; i++) {\n\t\tif (d[i].size == 1)\n\t\t\tval = *((u8 *) d[i].addr);\n\t\telse if (d[i].size == 2)\n\t\t\tval = *((u16 *) d[i].addr);\n\t\telse if (d[i].size == 4)\n\t\t\tval = *((u32 *) d[i].addr);\n\t\telse if (d[i].size == 8)\n\t\t\tval = *((u64 *) d[i].addr);\n\n\t\tpos += sprintf(p + pos, \"%s=%d\\n\", d[i].name, val);\n\t}\n\n\tres = simple_read_from_buffer(userbuf, count, ppos, p, pos);\n\n\tfree_page(addr);\n\treturn res;\n}\n\n \nstatic ssize_t lbs_debugfs_write(struct file *f, const char __user *buf,\n\t\t\t    size_t cnt, loff_t *ppos)\n{\n\tint r, i;\n\tchar *pdata;\n\tchar *p;\n\tchar *p0;\n\tchar *p1;\n\tchar *p2;\n\tstruct debug_data *d = f->private_data;\n\n\tif (cnt == 0)\n\t\treturn 0;\n\n\tpdata = memdup_user_nul(buf, cnt);\n\tif (IS_ERR(pdata))\n\t\treturn PTR_ERR(pdata);\n\n\tp0 = pdata;\n\tfor (i = 0; i < num_of_items; i++) {\n\t\tdo {\n\t\t\tp = strstr(p0, d[i].name);\n\t\t\tif (p == NULL)\n\t\t\t\tbreak;\n\t\t\tp1 = strchr(p, '\\n');\n\t\t\tif (p1 == NULL)\n\t\t\t\tbreak;\n\t\t\tp0 = p1++;\n\t\t\tp2 = strchr(p, '=');\n\t\t\tif (!p2)\n\t\t\t\tbreak;\n\t\t\tp2++;\n\t\t\tr = simple_strtoul(p2, NULL, 0);\n\t\t\tif (d[i].size == 1)\n\t\t\t\t*((u8 *) d[i].addr) = (u8) r;\n\t\t\telse if (d[i].size == 2)\n\t\t\t\t*((u16 *) d[i].addr) = (u16) r;\n\t\t\telse if (d[i].size == 4)\n\t\t\t\t*((u32 *) d[i].addr) = (u32) r;\n\t\t\telse if (d[i].size == 8)\n\t\t\t\t*((u64 *) d[i].addr) = (u64) r;\n\t\t\tbreak;\n\t\t} while (1);\n\t}\n\tkfree(pdata);\n\n\treturn (ssize_t)cnt;\n}\n\nstatic const struct file_operations lbs_debug_fops = {\n\t.owner = THIS_MODULE,\n\t.open = simple_open,\n\t.write = lbs_debugfs_write,\n\t.read = lbs_debugfs_read,\n\t.llseek = default_llseek,\n};\n\n \nstatic void lbs_debug_init(struct lbs_private *priv)\n{\n\tint i;\n\n\tif (!priv->debugfs_dir)\n\t\treturn;\n\n\tfor (i = 0; i < num_of_items; i++)\n\t\titems[i].addr += (size_t) priv;\n\n\tpriv->debugfs_debug = debugfs_create_file(\"debug\", 0644,\n\t\t\t\t\t\t  priv->debugfs_dir, &items[0],\n\t\t\t\t\t\t  &lbs_debug_fops);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}