{
  "module_name": "mwl8k.c",
  "hash_id": "e9e582851c14865fd55b06d7c0bae71ea710bc2a34be81c2b498b2a972a71612",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/marvell/mwl8k.c",
  "human_readable_source": " \n\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/etherdevice.h>\n#include <linux/slab.h>\n#include <net/mac80211.h>\n#include <linux/moduleparam.h>\n#include <linux/firmware.h>\n#include <linux/workqueue.h>\n\n#define MWL8K_DESC\t\"Marvell TOPDOG(R) 802.11 Wireless Network Driver\"\n#define MWL8K_NAME\tKBUILD_MODNAME\n#define MWL8K_VERSION\t\"0.13\"\n\n \nstatic bool ap_mode_default;\nmodule_param(ap_mode_default, bool, 0);\nMODULE_PARM_DESC(ap_mode_default,\n\t\t \"Set to 1 to make ap mode the default instead of sta mode\");\n\n \n#define MWL8K_HIU_GEN_PTR\t\t\t0x00000c10\n#define  MWL8K_MODE_STA\t\t\t\t 0x0000005a\n#define  MWL8K_MODE_AP\t\t\t\t 0x000000a5\n#define MWL8K_HIU_INT_CODE\t\t\t0x00000c14\n#define  MWL8K_FWSTA_READY\t\t\t 0xf0f1f2f4\n#define  MWL8K_FWAP_READY\t\t\t 0xf1f2f4a5\n#define  MWL8K_INT_CODE_CMD_FINISHED\t\t 0x00000005\n#define MWL8K_HIU_SCRATCH\t\t\t0x00000c40\n\n \n#define MWL8K_HIU_H2A_INTERRUPT_EVENTS\t\t0x00000c18\n#define MWL8K_HIU_H2A_INTERRUPT_STATUS\t\t0x00000c1c\n#define MWL8K_HIU_H2A_INTERRUPT_MASK\t\t0x00000c20\n#define MWL8K_HIU_H2A_INTERRUPT_CLEAR_SEL\t0x00000c24\n#define MWL8K_HIU_H2A_INTERRUPT_STATUS_MASK\t0x00000c28\n#define  MWL8K_H2A_INT_DUMMY\t\t\t (1 << 20)\n#define  MWL8K_H2A_INT_RESET\t\t\t (1 << 15)\n#define  MWL8K_H2A_INT_DOORBELL\t\t\t (1 << 1)\n#define  MWL8K_H2A_INT_PPA_READY\t\t (1 << 0)\n\n \n#define MWL8K_HIU_A2H_INTERRUPT_EVENTS\t\t0x00000c2c\n#define MWL8K_HIU_A2H_INTERRUPT_STATUS\t\t0x00000c30\n#define MWL8K_HIU_A2H_INTERRUPT_MASK\t\t0x00000c34\n#define MWL8K_HIU_A2H_INTERRUPT_CLEAR_SEL\t0x00000c38\n#define MWL8K_HIU_A2H_INTERRUPT_STATUS_MASK\t0x00000c3c\n#define  MWL8K_A2H_INT_DUMMY\t\t\t (1 << 20)\n#define  MWL8K_A2H_INT_BA_WATCHDOG\t\t (1 << 14)\n#define  MWL8K_A2H_INT_CHNL_SWITCHED\t\t (1 << 11)\n#define  MWL8K_A2H_INT_QUEUE_EMPTY\t\t (1 << 10)\n#define  MWL8K_A2H_INT_RADAR_DETECT\t\t (1 << 7)\n#define  MWL8K_A2H_INT_RADIO_ON\t\t\t (1 << 6)\n#define  MWL8K_A2H_INT_RADIO_OFF\t\t (1 << 5)\n#define  MWL8K_A2H_INT_MAC_EVENT\t\t (1 << 3)\n#define  MWL8K_A2H_INT_OPC_DONE\t\t\t (1 << 2)\n#define  MWL8K_A2H_INT_RX_READY\t\t\t (1 << 1)\n#define  MWL8K_A2H_INT_TX_DONE\t\t\t (1 << 0)\n\n \n\n#define\tMWL8K_HW_TIMER_REGISTER\t\t\t0x0000a600\n#define BBU_RXRDY_CNT_REG\t\t\t0x0000a860\n#define NOK_CCA_CNT_REG\t\t\t\t0x0000a6a0\n#define BBU_AVG_NOISE_VAL\t\t\t0x67\n\n#define MWL8K_A2H_EVENTS\t(MWL8K_A2H_INT_DUMMY | \\\n\t\t\t\t MWL8K_A2H_INT_CHNL_SWITCHED | \\\n\t\t\t\t MWL8K_A2H_INT_QUEUE_EMPTY | \\\n\t\t\t\t MWL8K_A2H_INT_RADAR_DETECT | \\\n\t\t\t\t MWL8K_A2H_INT_RADIO_ON | \\\n\t\t\t\t MWL8K_A2H_INT_RADIO_OFF | \\\n\t\t\t\t MWL8K_A2H_INT_MAC_EVENT | \\\n\t\t\t\t MWL8K_A2H_INT_OPC_DONE | \\\n\t\t\t\t MWL8K_A2H_INT_RX_READY | \\\n\t\t\t\t MWL8K_A2H_INT_TX_DONE | \\\n\t\t\t\t MWL8K_A2H_INT_BA_WATCHDOG)\n\n#define MWL8K_RX_QUEUES\t\t1\n#define MWL8K_TX_WMM_QUEUES\t4\n#define MWL8K_MAX_AMPDU_QUEUES\t8\n#define MWL8K_MAX_TX_QUEUES\t(MWL8K_TX_WMM_QUEUES + MWL8K_MAX_AMPDU_QUEUES)\n#define mwl8k_tx_queues(priv)\t(MWL8K_TX_WMM_QUEUES + (priv)->num_ampdu_queues)\n\n \n#define TOTAL_HW_TX_QUEUES\t8\n\n \n#define MWL8K_NUM_AMPDU_STREAMS\t(TOTAL_HW_TX_QUEUES - 1)\n\n#define MWL8K_NUM_CHANS 18\n\nstruct rxd_ops {\n\tint rxd_size;\n\tvoid (*rxd_init)(void *rxd, dma_addr_t next_dma_addr);\n\tvoid (*rxd_refill)(void *rxd, dma_addr_t addr, int len);\n\tint (*rxd_process)(void *rxd, struct ieee80211_rx_status *status,\n\t\t\t   __le16 *qos, s8 *noise);\n};\n\nstruct mwl8k_device_info {\n\tchar *part_name;\n\tchar *helper_image;\n\tchar *fw_image_sta;\n\tchar *fw_image_ap;\n\tstruct rxd_ops *ap_rxd_ops;\n\tu32 fw_api_ap;\n};\n\nstruct mwl8k_rx_queue {\n\tint rxd_count;\n\n\t \n\tint head;\n\n\t \n\tint tail;\n\n\tvoid *rxd;\n\tdma_addr_t rxd_dma;\n\tstruct {\n\t\tstruct sk_buff *skb;\n\t\tDEFINE_DMA_UNMAP_ADDR(dma);\n\t} *buf;\n};\n\nstruct mwl8k_tx_queue {\n\t \n\tint head;\n\n\t \n\tint tail;\n\n\tunsigned int len;\n\tstruct mwl8k_tx_desc *txd;\n\tdma_addr_t txd_dma;\n\tstruct sk_buff **skb;\n};\n\nenum {\n\tAMPDU_NO_STREAM,\n\tAMPDU_STREAM_NEW,\n\tAMPDU_STREAM_IN_PROGRESS,\n\tAMPDU_STREAM_ACTIVE,\n};\n\nstruct mwl8k_ampdu_stream {\n\tstruct ieee80211_sta *sta;\n\tu8 tid;\n\tu8 state;\n\tu8 idx;\n};\n\nstruct mwl8k_priv {\n\tstruct ieee80211_hw *hw;\n\tstruct pci_dev *pdev;\n\tint irq;\n\n\tstruct mwl8k_device_info *device_info;\n\n\tvoid __iomem *sram;\n\tvoid __iomem *regs;\n\n\t \n\tconst struct firmware *fw_helper;\n\tconst struct firmware *fw_ucode;\n\n\t \n\tbool ap_fw;\n\tstruct rxd_ops *rxd_ops;\n\tstruct ieee80211_supported_band band_24;\n\tstruct ieee80211_channel channels_24[14];\n\tstruct ieee80211_rate rates_24[13];\n\tstruct ieee80211_supported_band band_50;\n\tstruct ieee80211_channel channels_50[9];\n\tstruct ieee80211_rate rates_50[8];\n\tu32 ap_macids_supported;\n\tu32 sta_macids_supported;\n\n\t \n\tu8 num_ampdu_queues;\n\tspinlock_t stream_lock;\n\tstruct mwl8k_ampdu_stream ampdu[MWL8K_MAX_AMPDU_QUEUES];\n\tstruct work_struct watchdog_ba_handle;\n\n\t \n\tstruct mutex fw_mutex;\n\tstruct task_struct *fw_mutex_owner;\n\tstruct task_struct *hw_restart_owner;\n\tint fw_mutex_depth;\n\tstruct completion *hostcmd_wait;\n\n\tatomic_t watchdog_event_pending;\n\n\t \n\tspinlock_t tx_lock;\n\n\t \n\tstruct completion *tx_wait;\n\n\t \n\tu32 macids_used;\n\tstruct list_head vif_list;\n\n\t \n\tu32 *cookie;\n\tdma_addr_t cookie_dma;\n\n\tu16 num_mcaddrs;\n\tu8 hw_rev;\n\tu32 fw_rev;\n\tu32 caps;\n\n\t \n\tint pending_tx_pkts;\n\n\tstruct mwl8k_rx_queue rxq[MWL8K_RX_QUEUES];\n\tstruct mwl8k_tx_queue txq[MWL8K_MAX_TX_QUEUES];\n\tu32 txq_offset[MWL8K_MAX_TX_QUEUES];\n\n\tbool radio_on;\n\tbool radio_short_preamble;\n\tbool sniffer_enabled;\n\tbool wmm_enabled;\n\n\t \n\tbool capture_beacon;\n\tu8 capture_bssid[ETH_ALEN];\n\tstruct sk_buff *beacon_skb;\n\n\t \n\tstruct work_struct finalize_join_worker;\n\n\t \n\tstruct tasklet_struct poll_tx_task;\n\n\t \n\tstruct tasklet_struct poll_rx_task;\n\n\t \n\ts8 noise;\n\n\t \n\tstruct ieee80211_tx_queue_params wmm_params[MWL8K_TX_WMM_QUEUES];\n\n\t \n\tstruct work_struct fw_reload;\n\tbool hw_restart_in_progress;\n\n\t \n\tunsigned fw_state;\n\tchar *fw_pref;\n\tchar *fw_alt;\n\tbool is_8764;\n\tstruct completion firmware_loading_complete;\n\n\t \n\tu32 running_bsses;\n\n\t \n\tbool sw_scan_start;\n\tstruct ieee80211_channel *acs_chan;\n\tunsigned long channel_time;\n\tstruct survey_info survey[MWL8K_NUM_CHANS];\n};\n\n#define MAX_WEP_KEY_LEN         13\n#define NUM_WEP_KEYS            4\n\n \nstruct mwl8k_vif {\n\tstruct list_head list;\n\tstruct ieee80211_vif *vif;\n\n\t \n\tint macid;\n\n\t \n\tu16 seqno;\n\n\t \n\tstruct {\n\t\tu8 enabled;\n\t\tu8 key[sizeof(struct ieee80211_key_conf) + MAX_WEP_KEY_LEN];\n\t} wep_key_conf[NUM_WEP_KEYS];\n\n\t \n\tu8 bssid[ETH_ALEN];\n\n\t \n\tbool is_hw_crypto_enabled;\n};\n#define MWL8K_VIF(_vif) ((struct mwl8k_vif *)&((_vif)->drv_priv))\n#define IEEE80211_KEY_CONF(_u8) ((struct ieee80211_key_conf *)(_u8))\n\nstruct tx_traffic_info {\n\tu32 start_time;\n\tu32 pkts;\n};\n\n#define MWL8K_MAX_TID 8\nstruct mwl8k_sta {\n\t \n\tu8 peer_id;\n\tu8 is_ampdu_allowed;\n\tstruct tx_traffic_info tx_stats[MWL8K_MAX_TID];\n};\n#define MWL8K_STA(_sta) ((struct mwl8k_sta *)&((_sta)->drv_priv))\n\nstatic const struct ieee80211_channel mwl8k_channels_24[] = {\n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2412, .hw_value = 1, },\n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2417, .hw_value = 2, },\n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2422, .hw_value = 3, },\n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2427, .hw_value = 4, },\n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2432, .hw_value = 5, },\n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2437, .hw_value = 6, },\n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2442, .hw_value = 7, },\n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2447, .hw_value = 8, },\n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2452, .hw_value = 9, },\n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2457, .hw_value = 10, },\n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2462, .hw_value = 11, },\n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2467, .hw_value = 12, },\n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2472, .hw_value = 13, },\n\t{ .band = NL80211_BAND_2GHZ, .center_freq = 2484, .hw_value = 14, },\n};\n\nstatic const struct ieee80211_rate mwl8k_rates_24[] = {\n\t{ .bitrate = 10, .hw_value = 2, },\n\t{ .bitrate = 20, .hw_value = 4, },\n\t{ .bitrate = 55, .hw_value = 11, },\n\t{ .bitrate = 110, .hw_value = 22, },\n\t{ .bitrate = 220, .hw_value = 44, },\n\t{ .bitrate = 60, .hw_value = 12, },\n\t{ .bitrate = 90, .hw_value = 18, },\n\t{ .bitrate = 120, .hw_value = 24, },\n\t{ .bitrate = 180, .hw_value = 36, },\n\t{ .bitrate = 240, .hw_value = 48, },\n\t{ .bitrate = 360, .hw_value = 72, },\n\t{ .bitrate = 480, .hw_value = 96, },\n\t{ .bitrate = 540, .hw_value = 108, },\n};\n\nstatic const struct ieee80211_channel mwl8k_channels_50[] = {\n\t{ .band = NL80211_BAND_5GHZ, .center_freq = 5180, .hw_value = 36, },\n\t{ .band = NL80211_BAND_5GHZ, .center_freq = 5200, .hw_value = 40, },\n\t{ .band = NL80211_BAND_5GHZ, .center_freq = 5220, .hw_value = 44, },\n\t{ .band = NL80211_BAND_5GHZ, .center_freq = 5240, .hw_value = 48, },\n\t{ .band = NL80211_BAND_5GHZ, .center_freq = 5745, .hw_value = 149, },\n\t{ .band = NL80211_BAND_5GHZ, .center_freq = 5765, .hw_value = 153, },\n\t{ .band = NL80211_BAND_5GHZ, .center_freq = 5785, .hw_value = 157, },\n\t{ .band = NL80211_BAND_5GHZ, .center_freq = 5805, .hw_value = 161, },\n\t{ .band = NL80211_BAND_5GHZ, .center_freq = 5825, .hw_value = 165, },\n};\n\nstatic const struct ieee80211_rate mwl8k_rates_50[] = {\n\t{ .bitrate = 60, .hw_value = 12, },\n\t{ .bitrate = 90, .hw_value = 18, },\n\t{ .bitrate = 120, .hw_value = 24, },\n\t{ .bitrate = 180, .hw_value = 36, },\n\t{ .bitrate = 240, .hw_value = 48, },\n\t{ .bitrate = 360, .hw_value = 72, },\n\t{ .bitrate = 480, .hw_value = 96, },\n\t{ .bitrate = 540, .hw_value = 108, },\n};\n\n \n#define MWL8K_CMD_GET\t\t\t0x0000\n#define MWL8K_CMD_SET\t\t\t0x0001\n#define MWL8K_CMD_SET_LIST\t\t0x0002\n\n \n#define MWL8K_CMD_CODE_DNLD\t\t0x0001\n#define MWL8K_CMD_GET_HW_SPEC\t\t0x0003\n#define MWL8K_CMD_SET_HW_SPEC\t\t0x0004\n#define MWL8K_CMD_MAC_MULTICAST_ADR\t0x0010\n#define MWL8K_CMD_GET_STAT\t\t0x0014\n#define MWL8K_CMD_BBP_REG_ACCESS\t0x001a\n#define MWL8K_CMD_RADIO_CONTROL\t\t0x001c\n#define MWL8K_CMD_RF_TX_POWER\t\t0x001e\n#define MWL8K_CMD_TX_POWER\t\t0x001f\n#define MWL8K_CMD_RF_ANTENNA\t\t0x0020\n#define MWL8K_CMD_SET_BEACON\t\t0x0100\t\t \n#define MWL8K_CMD_SET_PRE_SCAN\t\t0x0107\n#define MWL8K_CMD_SET_POST_SCAN\t\t0x0108\n#define MWL8K_CMD_SET_RF_CHANNEL\t0x010a\n#define MWL8K_CMD_SET_AID\t\t0x010d\n#define MWL8K_CMD_SET_RATE\t\t0x0110\n#define MWL8K_CMD_SET_FINALIZE_JOIN\t0x0111\n#define MWL8K_CMD_RTS_THRESHOLD\t\t0x0113\n#define MWL8K_CMD_SET_SLOT\t\t0x0114\n#define MWL8K_CMD_SET_EDCA_PARAMS\t0x0115\n#define MWL8K_CMD_SET_WMM_MODE\t\t0x0123\n#define MWL8K_CMD_MIMO_CONFIG\t\t0x0125\n#define MWL8K_CMD_USE_FIXED_RATE\t0x0126\n#define MWL8K_CMD_ENABLE_SNIFFER\t0x0150\n#define MWL8K_CMD_SET_MAC_ADDR\t\t0x0202\t\t \n#define MWL8K_CMD_SET_RATEADAPT_MODE\t0x0203\n#define MWL8K_CMD_GET_WATCHDOG_BITMAP\t0x0205\n#define MWL8K_CMD_DEL_MAC_ADDR\t\t0x0206\t\t \n#define MWL8K_CMD_BSS_START\t\t0x1100\t\t \n#define MWL8K_CMD_SET_NEW_STN\t\t0x1111\t\t \n#define MWL8K_CMD_UPDATE_ENCRYPTION\t0x1122\t\t \n#define MWL8K_CMD_UPDATE_STADB\t\t0x1123\n#define MWL8K_CMD_BASTREAM\t\t0x1125\n\n#define MWL8K_LEGACY_5G_RATE_OFFSET \\\n\t(ARRAY_SIZE(mwl8k_rates_24) - ARRAY_SIZE(mwl8k_rates_50))\n\nstatic const char *mwl8k_cmd_name(__le16 cmd, char *buf, int bufsize)\n{\n\tu16 command = le16_to_cpu(cmd);\n\n#define MWL8K_CMDNAME(x)\tcase MWL8K_CMD_##x: do {\\\n\t\t\t\t\tsnprintf(buf, bufsize, \"%s\", #x);\\\n\t\t\t\t\treturn buf;\\\n\t\t\t\t\t} while (0)\n\tswitch (command & ~0x8000) {\n\t\tMWL8K_CMDNAME(CODE_DNLD);\n\t\tMWL8K_CMDNAME(GET_HW_SPEC);\n\t\tMWL8K_CMDNAME(SET_HW_SPEC);\n\t\tMWL8K_CMDNAME(MAC_MULTICAST_ADR);\n\t\tMWL8K_CMDNAME(GET_STAT);\n\t\tMWL8K_CMDNAME(RADIO_CONTROL);\n\t\tMWL8K_CMDNAME(RF_TX_POWER);\n\t\tMWL8K_CMDNAME(TX_POWER);\n\t\tMWL8K_CMDNAME(RF_ANTENNA);\n\t\tMWL8K_CMDNAME(SET_BEACON);\n\t\tMWL8K_CMDNAME(SET_PRE_SCAN);\n\t\tMWL8K_CMDNAME(SET_POST_SCAN);\n\t\tMWL8K_CMDNAME(SET_RF_CHANNEL);\n\t\tMWL8K_CMDNAME(SET_AID);\n\t\tMWL8K_CMDNAME(SET_RATE);\n\t\tMWL8K_CMDNAME(SET_FINALIZE_JOIN);\n\t\tMWL8K_CMDNAME(RTS_THRESHOLD);\n\t\tMWL8K_CMDNAME(SET_SLOT);\n\t\tMWL8K_CMDNAME(SET_EDCA_PARAMS);\n\t\tMWL8K_CMDNAME(SET_WMM_MODE);\n\t\tMWL8K_CMDNAME(MIMO_CONFIG);\n\t\tMWL8K_CMDNAME(USE_FIXED_RATE);\n\t\tMWL8K_CMDNAME(ENABLE_SNIFFER);\n\t\tMWL8K_CMDNAME(SET_MAC_ADDR);\n\t\tMWL8K_CMDNAME(SET_RATEADAPT_MODE);\n\t\tMWL8K_CMDNAME(BSS_START);\n\t\tMWL8K_CMDNAME(SET_NEW_STN);\n\t\tMWL8K_CMDNAME(UPDATE_ENCRYPTION);\n\t\tMWL8K_CMDNAME(UPDATE_STADB);\n\t\tMWL8K_CMDNAME(BASTREAM);\n\t\tMWL8K_CMDNAME(GET_WATCHDOG_BITMAP);\n\tdefault:\n\t\tsnprintf(buf, bufsize, \"0x%x\", cmd);\n\t}\n#undef MWL8K_CMDNAME\n\n\treturn buf;\n}\n\n \nstatic void mwl8k_hw_reset(struct mwl8k_priv *priv)\n{\n\tiowrite32(MWL8K_H2A_INT_RESET,\n\t\tpriv->regs + MWL8K_HIU_H2A_INTERRUPT_EVENTS);\n\tiowrite32(MWL8K_H2A_INT_RESET,\n\t\tpriv->regs + MWL8K_HIU_H2A_INTERRUPT_EVENTS);\n\tmsleep(20);\n}\n\n \nstatic void mwl8k_release_fw(const struct firmware **fw)\n{\n\tif (*fw == NULL)\n\t\treturn;\n\trelease_firmware(*fw);\n\t*fw = NULL;\n}\n\nstatic void mwl8k_release_firmware(struct mwl8k_priv *priv)\n{\n\tmwl8k_release_fw(&priv->fw_ucode);\n\tmwl8k_release_fw(&priv->fw_helper);\n}\n\n \nstatic void mwl8k_fw_state_machine(const struct firmware *fw, void *context);\nenum {\n\tFW_STATE_INIT = 0,\n\tFW_STATE_LOADING_PREF,\n\tFW_STATE_LOADING_ALT,\n\tFW_STATE_ERROR,\n};\n\n \nstatic int mwl8k_request_fw(struct mwl8k_priv *priv,\n\t\t\t    const char *fname, const struct firmware **fw,\n\t\t\t    bool nowait)\n{\n\t \n\tif (*fw != NULL)\n\t\tmwl8k_release_fw(fw);\n\n\tif (nowait)\n\t\treturn request_firmware_nowait(THIS_MODULE, 1, fname,\n\t\t\t\t\t       &priv->pdev->dev, GFP_KERNEL,\n\t\t\t\t\t       priv, mwl8k_fw_state_machine);\n\telse\n\t\treturn request_firmware(fw, fname, &priv->pdev->dev);\n}\n\nstatic int mwl8k_request_firmware(struct mwl8k_priv *priv, char *fw_image,\n\t\t\t\t  bool nowait)\n{\n\tstruct mwl8k_device_info *di = priv->device_info;\n\tint rc;\n\n\tif (di->helper_image != NULL) {\n\t\tif (nowait)\n\t\t\trc = mwl8k_request_fw(priv, di->helper_image,\n\t\t\t\t\t      &priv->fw_helper, true);\n\t\telse\n\t\t\trc = mwl8k_request_fw(priv, di->helper_image,\n\t\t\t\t\t      &priv->fw_helper, false);\n\t\tif (rc)\n\t\t\tprintk(KERN_ERR \"%s: Error requesting helper fw %s\\n\",\n\t\t\t       pci_name(priv->pdev), di->helper_image);\n\n\t\tif (rc || nowait)\n\t\t\treturn rc;\n\t}\n\n\tif (nowait) {\n\t\t \n\t\tpriv->fw_state = FW_STATE_LOADING_PREF;\n\t\trc = mwl8k_request_fw(priv, fw_image,\n\t\t\t\t      &priv->fw_ucode,\n\t\t\t\t      true);\n\t} else\n\t\trc = mwl8k_request_fw(priv, fw_image,\n\t\t\t\t      &priv->fw_ucode, false);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error requesting firmware file %s\\n\",\n\t\t       pci_name(priv->pdev), fw_image);\n\t\tmwl8k_release_fw(&priv->fw_helper);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstruct mwl8k_cmd_pkt {\n\t__le16\tcode;\n\t__le16\tlength;\n\t__u8\tseq_num;\n\t__u8\tmacid;\n\t__le16\tresult;\n\tchar\tpayload[];\n} __packed;\n\n \nstatic int\nmwl8k_send_fw_load_cmd(struct mwl8k_priv *priv, void *data, int length)\n{\n\tvoid __iomem *regs = priv->regs;\n\tdma_addr_t dma_addr;\n\tint loops;\n\n\tdma_addr = dma_map_single(&priv->pdev->dev, data, length,\n\t\t\t\t  DMA_TO_DEVICE);\n\tif (dma_mapping_error(&priv->pdev->dev, dma_addr))\n\t\treturn -ENOMEM;\n\n\tiowrite32(dma_addr, regs + MWL8K_HIU_GEN_PTR);\n\tiowrite32(0, regs + MWL8K_HIU_INT_CODE);\n\tiowrite32(MWL8K_H2A_INT_DOORBELL,\n\t\tregs + MWL8K_HIU_H2A_INTERRUPT_EVENTS);\n\tiowrite32(MWL8K_H2A_INT_DUMMY,\n\t\tregs + MWL8K_HIU_H2A_INTERRUPT_EVENTS);\n\n\tloops = 1000;\n\tdo {\n\t\tu32 int_code;\n\t\tif (priv->is_8764) {\n\t\t\tint_code = ioread32(regs +\n\t\t\t\t\t    MWL8K_HIU_H2A_INTERRUPT_STATUS);\n\t\t\tif (int_code == 0)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tint_code = ioread32(regs + MWL8K_HIU_INT_CODE);\n\t\t\tif (int_code == MWL8K_INT_CODE_CMD_FINISHED) {\n\t\t\t\tiowrite32(0, regs + MWL8K_HIU_INT_CODE);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcond_resched();\n\t\tudelay(1);\n\t} while (--loops);\n\n\tdma_unmap_single(&priv->pdev->dev, dma_addr, length, DMA_TO_DEVICE);\n\n\treturn loops ? 0 : -ETIMEDOUT;\n}\n\nstatic int mwl8k_load_fw_image(struct mwl8k_priv *priv,\n\t\t\t\tconst u8 *data, size_t length)\n{\n\tstruct mwl8k_cmd_pkt *cmd;\n\tint done;\n\tint rc = 0;\n\n\tcmd = kmalloc(sizeof(*cmd) + 256, GFP_KERNEL);\n\tif (cmd == NULL)\n\t\treturn -ENOMEM;\n\n\tcmd->code = cpu_to_le16(MWL8K_CMD_CODE_DNLD);\n\tcmd->seq_num = 0;\n\tcmd->macid = 0;\n\tcmd->result = 0;\n\n\tdone = 0;\n\twhile (length) {\n\t\tint block_size = length > 256 ? 256 : length;\n\n\t\tmemcpy(cmd->payload, data + done, block_size);\n\t\tcmd->length = cpu_to_le16(block_size);\n\n\t\trc = mwl8k_send_fw_load_cmd(priv, cmd,\n\t\t\t\t\t\tsizeof(*cmd) + block_size);\n\t\tif (rc)\n\t\t\tbreak;\n\n\t\tdone += block_size;\n\t\tlength -= block_size;\n\t}\n\n\tif (!rc) {\n\t\tcmd->length = 0;\n\t\trc = mwl8k_send_fw_load_cmd(priv, cmd, sizeof(*cmd));\n\t}\n\n\tkfree(cmd);\n\n\treturn rc;\n}\n\nstatic int mwl8k_feed_fw_image(struct mwl8k_priv *priv,\n\t\t\t\tconst u8 *data, size_t length)\n{\n\tunsigned char *buffer;\n\tint may_continue, rc = 0;\n\tu32 done, prev_block_size;\n\n\tbuffer = kmalloc(1024, GFP_KERNEL);\n\tif (buffer == NULL)\n\t\treturn -ENOMEM;\n\n\tdone = 0;\n\tprev_block_size = 0;\n\tmay_continue = 1000;\n\twhile (may_continue > 0) {\n\t\tu32 block_size;\n\n\t\tblock_size = ioread32(priv->regs + MWL8K_HIU_SCRATCH);\n\t\tif (block_size & 1) {\n\t\t\tblock_size &= ~1;\n\t\t\tmay_continue--;\n\t\t} else {\n\t\t\tdone += prev_block_size;\n\t\t\tlength -= prev_block_size;\n\t\t}\n\n\t\tif (block_size > 1024 || block_size > length) {\n\t\t\trc = -EOVERFLOW;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (length == 0) {\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (block_size == 0) {\n\t\t\trc = -EPROTO;\n\t\t\tmay_continue--;\n\t\t\tudelay(1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tprev_block_size = block_size;\n\t\tmemcpy(buffer, data + done, block_size);\n\n\t\trc = mwl8k_send_fw_load_cmd(priv, buffer, block_size);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\n\tif (!rc && length != 0)\n\t\trc = -EREMOTEIO;\n\n\tkfree(buffer);\n\n\treturn rc;\n}\n\nstatic int mwl8k_load_firmware(struct ieee80211_hw *hw)\n{\n\tstruct mwl8k_priv *priv = hw->priv;\n\tconst struct firmware *fw = priv->fw_ucode;\n\tint rc;\n\tint loops;\n\n\tif (!memcmp(fw->data, \"\\x01\\x00\\x00\\x00\", 4) && !priv->is_8764) {\n\t\tconst struct firmware *helper = priv->fw_helper;\n\n\t\tif (helper == NULL) {\n\t\t\tprintk(KERN_ERR \"%s: helper image needed but none \"\n\t\t\t       \"given\\n\", pci_name(priv->pdev));\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\trc = mwl8k_load_fw_image(priv, helper->data, helper->size);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"%s: unable to load firmware \"\n\t\t\t       \"helper image\\n\", pci_name(priv->pdev));\n\t\t\treturn rc;\n\t\t}\n\t\tmsleep(20);\n\n\t\trc = mwl8k_feed_fw_image(priv, fw->data, fw->size);\n\t} else {\n\t\tif (priv->is_8764)\n\t\t\trc = mwl8k_feed_fw_image(priv, fw->data, fw->size);\n\t\telse\n\t\t\trc = mwl8k_load_fw_image(priv, fw->data, fw->size);\n\t}\n\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: unable to load firmware image\\n\",\n\t\t       pci_name(priv->pdev));\n\t\treturn rc;\n\t}\n\n\tiowrite32(MWL8K_MODE_STA, priv->regs + MWL8K_HIU_GEN_PTR);\n\n\tloops = 500000;\n\tdo {\n\t\tu32 ready_code;\n\n\t\tready_code = ioread32(priv->regs + MWL8K_HIU_INT_CODE);\n\t\tif (ready_code == MWL8K_FWAP_READY) {\n\t\t\tpriv->ap_fw = true;\n\t\t\tbreak;\n\t\t} else if (ready_code == MWL8K_FWSTA_READY) {\n\t\t\tpriv->ap_fw = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tcond_resched();\n\t\tudelay(1);\n\t} while (--loops);\n\n\treturn loops ? 0 : -ETIMEDOUT;\n}\n\n\n \nstruct mwl8k_dma_data {\n\t__le16 fwlen;\n\tstruct ieee80211_hdr wh;\n\tchar data[];\n} __packed __aligned(2);\n\n \nstatic inline void mwl8k_remove_dma_header(struct sk_buff *skb, __le16 qos)\n{\n\tstruct mwl8k_dma_data *tr;\n\tint hdrlen;\n\n\ttr = (struct mwl8k_dma_data *)skb->data;\n\thdrlen = ieee80211_hdrlen(tr->wh.frame_control);\n\n\tif (hdrlen != sizeof(tr->wh)) {\n\t\tif (ieee80211_is_data_qos(tr->wh.frame_control)) {\n\t\t\tmemmove(tr->data - hdrlen, &tr->wh, hdrlen - 2);\n\t\t\t*((__le16 *)(tr->data - 2)) = qos;\n\t\t} else {\n\t\t\tmemmove(tr->data - hdrlen, &tr->wh, hdrlen);\n\t\t}\n\t}\n\n\tif (hdrlen != sizeof(*tr))\n\t\tskb_pull(skb, sizeof(*tr) - hdrlen);\n}\n\n#define REDUCED_TX_HEADROOM\t8\n\nstatic void\nmwl8k_add_dma_header(struct mwl8k_priv *priv, struct sk_buff *skb,\n\t\t\t\t\t\tint head_pad, int tail_pad)\n{\n\tstruct ieee80211_hdr *wh;\n\tint hdrlen;\n\tint reqd_hdrlen;\n\tstruct mwl8k_dma_data *tr;\n\n\t \n\twh = (struct ieee80211_hdr *)skb->data;\n\n\thdrlen = ieee80211_hdrlen(wh->frame_control);\n\n\t \n\tif (priv->ap_fw && (hdrlen < (sizeof(struct ieee80211_cts)\n\t\t\t\t\t\t+ REDUCED_TX_HEADROOM))) {\n\t\tif (pskb_expand_head(skb, REDUCED_TX_HEADROOM, 0, GFP_ATOMIC)) {\n\n\t\t\twiphy_err(priv->hw->wiphy,\n\t\t\t\t\t\"Failed to reallocate TX buffer\\n\");\n\t\t\treturn;\n\t\t}\n\t\tskb->truesize += REDUCED_TX_HEADROOM;\n\t}\n\n\treqd_hdrlen = sizeof(*tr) + head_pad;\n\n\tif (hdrlen != reqd_hdrlen)\n\t\tskb_push(skb, reqd_hdrlen - hdrlen);\n\n\tif (ieee80211_is_data_qos(wh->frame_control))\n\t\thdrlen -= IEEE80211_QOS_CTL_LEN;\n\n\ttr = (struct mwl8k_dma_data *)skb->data;\n\tif (wh != &tr->wh)\n\t\tmemmove(&tr->wh, wh, hdrlen);\n\tif (hdrlen != sizeof(tr->wh))\n\t\tmemset(((void *)&tr->wh) + hdrlen, 0, sizeof(tr->wh) - hdrlen);\n\n\t \n\ttr->fwlen = cpu_to_le16(skb->len - sizeof(*tr) + tail_pad);\n}\n\nstatic void mwl8k_encapsulate_tx_frame(struct mwl8k_priv *priv,\n\t\tstruct sk_buff *skb)\n{\n\tstruct ieee80211_hdr *wh;\n\tstruct ieee80211_tx_info *tx_info;\n\tstruct ieee80211_key_conf *key_conf;\n\tint data_pad;\n\tint head_pad = 0;\n\n\twh = (struct ieee80211_hdr *)skb->data;\n\n\ttx_info = IEEE80211_SKB_CB(skb);\n\n\tkey_conf = NULL;\n\tif (ieee80211_is_data(wh->frame_control))\n\t\tkey_conf = tx_info->control.hw_key;\n\n\t \n\tdata_pad = 0;\n\tif (key_conf != NULL) {\n\t\thead_pad = key_conf->iv_len;\n\t\tswitch (key_conf->cipher) {\n\t\tcase WLAN_CIPHER_SUITE_WEP40:\n\t\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\t\tdata_pad = 4;\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\t\tdata_pad = 12;\n\t\t\tbreak;\n\t\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\t\tdata_pad = 8;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmwl8k_add_dma_header(priv, skb, head_pad, data_pad);\n}\n\n \nstruct mwl8k_rxd_ap {\n\t__le16 pkt_len;\n\t__u8 sq2;\n\t__u8 rate;\n\t__le32 pkt_phys_addr;\n\t__le32 next_rxd_phys_addr;\n\t__le16 qos_control;\n\t__le16 htsig2;\n\t__le32 hw_rssi_info;\n\t__le32 hw_noise_floor_info;\n\t__u8 noise_floor;\n\t__u8 pad0[3];\n\t__u8 rssi;\n\t__u8 rx_status;\n\t__u8 channel;\n\t__u8 rx_ctrl;\n} __packed;\n\n#define MWL8K_AP_RATE_INFO_MCS_FORMAT\t\t0x80\n#define MWL8K_AP_RATE_INFO_40MHZ\t\t0x40\n#define MWL8K_AP_RATE_INFO_RATEID(x)\t\t((x) & 0x3f)\n\n#define MWL8K_AP_RX_CTRL_OWNED_BY_HOST\t\t0x80\n\n \n#define MWL8K_AP_RXSTAT_DECRYPT_ERR_MASK\t\t0x80\n#define MWL8K_AP_RXSTAT_GENERAL_DECRYPT_ERR\t\t0xFF\n#define MWL8K_AP_RXSTAT_TKIP_DECRYPT_MIC_ERR\t\t0x02\n#define MWL8K_AP_RXSTAT_WEP_DECRYPT_ICV_ERR\t\t0x04\n#define MWL8K_AP_RXSTAT_TKIP_DECRYPT_ICV_ERR\t\t0x08\n\nstatic void mwl8k_rxd_ap_init(void *_rxd, dma_addr_t next_dma_addr)\n{\n\tstruct mwl8k_rxd_ap *rxd = _rxd;\n\n\trxd->next_rxd_phys_addr = cpu_to_le32(next_dma_addr);\n\trxd->rx_ctrl = MWL8K_AP_RX_CTRL_OWNED_BY_HOST;\n}\n\nstatic void mwl8k_rxd_ap_refill(void *_rxd, dma_addr_t addr, int len)\n{\n\tstruct mwl8k_rxd_ap *rxd = _rxd;\n\n\trxd->pkt_len = cpu_to_le16(len);\n\trxd->pkt_phys_addr = cpu_to_le32(addr);\n\twmb();\n\trxd->rx_ctrl = 0;\n}\n\nstatic int\nmwl8k_rxd_ap_process(void *_rxd, struct ieee80211_rx_status *status,\n\t\t     __le16 *qos, s8 *noise)\n{\n\tstruct mwl8k_rxd_ap *rxd = _rxd;\n\n\tif (!(rxd->rx_ctrl & MWL8K_AP_RX_CTRL_OWNED_BY_HOST))\n\t\treturn -1;\n\trmb();\n\n\tmemset(status, 0, sizeof(*status));\n\n\tstatus->signal = -rxd->rssi;\n\t*noise = -rxd->noise_floor;\n\n\tif (rxd->rate & MWL8K_AP_RATE_INFO_MCS_FORMAT) {\n\t\tstatus->encoding = RX_ENC_HT;\n\t\tif (rxd->rate & MWL8K_AP_RATE_INFO_40MHZ)\n\t\t\tstatus->bw = RATE_INFO_BW_40;\n\t\tstatus->rate_idx = MWL8K_AP_RATE_INFO_RATEID(rxd->rate);\n\t} else {\n\t\tint i;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(mwl8k_rates_24); i++) {\n\t\t\tif (mwl8k_rates_24[i].hw_value == rxd->rate) {\n\t\t\t\tstatus->rate_idx = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (rxd->channel > 14) {\n\t\tstatus->band = NL80211_BAND_5GHZ;\n\t\tif (!(status->encoding == RX_ENC_HT) &&\n\t\t    status->rate_idx >= MWL8K_LEGACY_5G_RATE_OFFSET)\n\t\t\tstatus->rate_idx -= MWL8K_LEGACY_5G_RATE_OFFSET;\n\t} else {\n\t\tstatus->band = NL80211_BAND_2GHZ;\n\t}\n\tstatus->freq = ieee80211_channel_to_frequency(rxd->channel,\n\t\t\t\t\t\t      status->band);\n\n\t*qos = rxd->qos_control;\n\n\tif ((rxd->rx_status != MWL8K_AP_RXSTAT_GENERAL_DECRYPT_ERR) &&\n\t    (rxd->rx_status & MWL8K_AP_RXSTAT_DECRYPT_ERR_MASK) &&\n\t    (rxd->rx_status & MWL8K_AP_RXSTAT_TKIP_DECRYPT_MIC_ERR))\n\t\tstatus->flag |= RX_FLAG_MMIC_ERROR;\n\n\treturn le16_to_cpu(rxd->pkt_len);\n}\n\nstatic struct rxd_ops rxd_ap_ops = {\n\t.rxd_size\t= sizeof(struct mwl8k_rxd_ap),\n\t.rxd_init\t= mwl8k_rxd_ap_init,\n\t.rxd_refill\t= mwl8k_rxd_ap_refill,\n\t.rxd_process\t= mwl8k_rxd_ap_process,\n};\n\n \nstruct mwl8k_rxd_sta {\n\t__le16 pkt_len;\n\t__u8 link_quality;\n\t__u8 noise_level;\n\t__le32 pkt_phys_addr;\n\t__le32 next_rxd_phys_addr;\n\t__le16 qos_control;\n\t__le16 rate_info;\n\t__le32 pad0[4];\n\t__u8 rssi;\n\t__u8 channel;\n\t__le16 pad1;\n\t__u8 rx_ctrl;\n\t__u8 rx_status;\n\t__u8 pad2[2];\n} __packed;\n\n#define MWL8K_STA_RATE_INFO_SHORTPRE\t\t0x8000\n#define MWL8K_STA_RATE_INFO_ANTSELECT(x)\t(((x) >> 11) & 0x3)\n#define MWL8K_STA_RATE_INFO_RATEID(x)\t\t(((x) >> 3) & 0x3f)\n#define MWL8K_STA_RATE_INFO_40MHZ\t\t0x0004\n#define MWL8K_STA_RATE_INFO_SHORTGI\t\t0x0002\n#define MWL8K_STA_RATE_INFO_MCS_FORMAT\t\t0x0001\n\n#define MWL8K_STA_RX_CTRL_OWNED_BY_HOST\t\t0x02\n#define MWL8K_STA_RX_CTRL_DECRYPT_ERROR\t\t0x04\n \n#define MWL8K_STA_RX_CTRL_DEC_ERR_TYPE\t\t0x08\n \n#define MWL8K_STA_RX_CTRL_KEY_INDEX\t\t\t0x30\n\nstatic void mwl8k_rxd_sta_init(void *_rxd, dma_addr_t next_dma_addr)\n{\n\tstruct mwl8k_rxd_sta *rxd = _rxd;\n\n\trxd->next_rxd_phys_addr = cpu_to_le32(next_dma_addr);\n\trxd->rx_ctrl = MWL8K_STA_RX_CTRL_OWNED_BY_HOST;\n}\n\nstatic void mwl8k_rxd_sta_refill(void *_rxd, dma_addr_t addr, int len)\n{\n\tstruct mwl8k_rxd_sta *rxd = _rxd;\n\n\trxd->pkt_len = cpu_to_le16(len);\n\trxd->pkt_phys_addr = cpu_to_le32(addr);\n\twmb();\n\trxd->rx_ctrl = 0;\n}\n\nstatic int\nmwl8k_rxd_sta_process(void *_rxd, struct ieee80211_rx_status *status,\n\t\t       __le16 *qos, s8 *noise)\n{\n\tstruct mwl8k_rxd_sta *rxd = _rxd;\n\tu16 rate_info;\n\n\tif (!(rxd->rx_ctrl & MWL8K_STA_RX_CTRL_OWNED_BY_HOST))\n\t\treturn -1;\n\trmb();\n\n\trate_info = le16_to_cpu(rxd->rate_info);\n\n\tmemset(status, 0, sizeof(*status));\n\n\tstatus->signal = -rxd->rssi;\n\t*noise = -rxd->noise_level;\n\tstatus->antenna = MWL8K_STA_RATE_INFO_ANTSELECT(rate_info);\n\tstatus->rate_idx = MWL8K_STA_RATE_INFO_RATEID(rate_info);\n\n\tif (rate_info & MWL8K_STA_RATE_INFO_SHORTPRE)\n\t\tstatus->enc_flags |= RX_ENC_FLAG_SHORTPRE;\n\tif (rate_info & MWL8K_STA_RATE_INFO_40MHZ)\n\t\tstatus->bw = RATE_INFO_BW_40;\n\tif (rate_info & MWL8K_STA_RATE_INFO_SHORTGI)\n\t\tstatus->enc_flags |= RX_ENC_FLAG_SHORT_GI;\n\tif (rate_info & MWL8K_STA_RATE_INFO_MCS_FORMAT)\n\t\tstatus->encoding = RX_ENC_HT;\n\n\tif (rxd->channel > 14) {\n\t\tstatus->band = NL80211_BAND_5GHZ;\n\t\tif (!(status->encoding == RX_ENC_HT) &&\n\t\t    status->rate_idx >= MWL8K_LEGACY_5G_RATE_OFFSET)\n\t\t\tstatus->rate_idx -= MWL8K_LEGACY_5G_RATE_OFFSET;\n\t} else {\n\t\tstatus->band = NL80211_BAND_2GHZ;\n\t}\n\tstatus->freq = ieee80211_channel_to_frequency(rxd->channel,\n\t\t\t\t\t\t      status->band);\n\n\t*qos = rxd->qos_control;\n\tif ((rxd->rx_ctrl & MWL8K_STA_RX_CTRL_DECRYPT_ERROR) &&\n\t    (rxd->rx_ctrl & MWL8K_STA_RX_CTRL_DEC_ERR_TYPE))\n\t\tstatus->flag |= RX_FLAG_MMIC_ERROR;\n\n\treturn le16_to_cpu(rxd->pkt_len);\n}\n\nstatic struct rxd_ops rxd_sta_ops = {\n\t.rxd_size\t= sizeof(struct mwl8k_rxd_sta),\n\t.rxd_init\t= mwl8k_rxd_sta_init,\n\t.rxd_refill\t= mwl8k_rxd_sta_refill,\n\t.rxd_process\t= mwl8k_rxd_sta_process,\n};\n\n\n#define MWL8K_RX_DESCS\t\t256\n#define MWL8K_RX_MAXSZ\t\t3800\n\nstatic int mwl8k_rxq_init(struct ieee80211_hw *hw, int index)\n{\n\tstruct mwl8k_priv *priv = hw->priv;\n\tstruct mwl8k_rx_queue *rxq = priv->rxq + index;\n\tint size;\n\tint i;\n\n\trxq->rxd_count = 0;\n\trxq->head = 0;\n\trxq->tail = 0;\n\n\tsize = MWL8K_RX_DESCS * priv->rxd_ops->rxd_size;\n\n\trxq->rxd = dma_alloc_coherent(&priv->pdev->dev, size, &rxq->rxd_dma,\n\t\t\t\t      GFP_KERNEL);\n\tif (rxq->rxd == NULL) {\n\t\twiphy_err(hw->wiphy, \"failed to alloc RX descriptors\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\trxq->buf = kcalloc(MWL8K_RX_DESCS, sizeof(*rxq->buf), GFP_KERNEL);\n\tif (rxq->buf == NULL) {\n\t\tdma_free_coherent(&priv->pdev->dev, size, rxq->rxd,\n\t\t\t\t  rxq->rxd_dma);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < MWL8K_RX_DESCS; i++) {\n\t\tint desc_size;\n\t\tvoid *rxd;\n\t\tint nexti;\n\t\tdma_addr_t next_dma_addr;\n\n\t\tdesc_size = priv->rxd_ops->rxd_size;\n\t\trxd = rxq->rxd + (i * priv->rxd_ops->rxd_size);\n\n\t\tnexti = i + 1;\n\t\tif (nexti == MWL8K_RX_DESCS)\n\t\t\tnexti = 0;\n\t\tnext_dma_addr = rxq->rxd_dma + (nexti * desc_size);\n\n\t\tpriv->rxd_ops->rxd_init(rxd, next_dma_addr);\n\t}\n\n\treturn 0;\n}\n\nstatic int rxq_refill(struct ieee80211_hw *hw, int index, int limit)\n{\n\tstruct mwl8k_priv *priv = hw->priv;\n\tstruct mwl8k_rx_queue *rxq = priv->rxq + index;\n\tint refilled = 0;\n\n\twhile (rxq->rxd_count < MWL8K_RX_DESCS && limit--) {\n\t\tstruct sk_buff *skb;\n\t\tdma_addr_t addr;\n\t\tint rx;\n\t\tvoid *rxd;\n\n\t\tskb = dev_alloc_skb(MWL8K_RX_MAXSZ);\n\t\tif (skb == NULL)\n\t\t\tbreak;\n\n\t\taddr = dma_map_single(&priv->pdev->dev, skb->data,\n\t\t\t\t      MWL8K_RX_MAXSZ, DMA_FROM_DEVICE);\n\n\t\trxq->rxd_count++;\n\t\trx = rxq->tail++;\n\t\tif (rxq->tail == MWL8K_RX_DESCS)\n\t\t\trxq->tail = 0;\n\t\trxq->buf[rx].skb = skb;\n\t\tdma_unmap_addr_set(&rxq->buf[rx], dma, addr);\n\n\t\trxd = rxq->rxd + (rx * priv->rxd_ops->rxd_size);\n\t\tpriv->rxd_ops->rxd_refill(rxd, addr, MWL8K_RX_MAXSZ);\n\n\t\trefilled++;\n\t}\n\n\treturn refilled;\n}\n\n \nstatic void mwl8k_rxq_deinit(struct ieee80211_hw *hw, int index)\n{\n\tstruct mwl8k_priv *priv = hw->priv;\n\tstruct mwl8k_rx_queue *rxq = priv->rxq + index;\n\tint i;\n\n\tif (rxq->rxd == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < MWL8K_RX_DESCS; i++) {\n\t\tif (rxq->buf[i].skb != NULL) {\n\t\t\tdma_unmap_single(&priv->pdev->dev,\n\t\t\t\t\t dma_unmap_addr(&rxq->buf[i], dma),\n\t\t\t\t\t MWL8K_RX_MAXSZ, DMA_FROM_DEVICE);\n\t\t\tdma_unmap_addr_set(&rxq->buf[i], dma, 0);\n\n\t\t\tkfree_skb(rxq->buf[i].skb);\n\t\t\trxq->buf[i].skb = NULL;\n\t\t}\n\t}\n\n\tkfree(rxq->buf);\n\trxq->buf = NULL;\n\n\tdma_free_coherent(&priv->pdev->dev,\n\t\t\t  MWL8K_RX_DESCS * priv->rxd_ops->rxd_size, rxq->rxd,\n\t\t\t  rxq->rxd_dma);\n\trxq->rxd = NULL;\n}\n\n\n \nstatic inline int\nmwl8k_capture_bssid(struct mwl8k_priv *priv, struct ieee80211_hdr *wh)\n{\n\treturn priv->capture_beacon &&\n\t\tieee80211_is_beacon(wh->frame_control) &&\n\t\tether_addr_equal_64bits(wh->addr3, priv->capture_bssid);\n}\n\nstatic inline void mwl8k_save_beacon(struct ieee80211_hw *hw,\n\t\t\t\t     struct sk_buff *skb)\n{\n\tstruct mwl8k_priv *priv = hw->priv;\n\n\tpriv->capture_beacon = false;\n\teth_zero_addr(priv->capture_bssid);\n\n\t \n\tpriv->beacon_skb = skb_copy(skb, GFP_ATOMIC);\n\tif (priv->beacon_skb != NULL)\n\t\tieee80211_queue_work(hw, &priv->finalize_join_worker);\n}\n\nstatic inline struct mwl8k_vif *mwl8k_find_vif_bss(struct list_head *vif_list,\n\t\t\t\t\t\t   u8 *bssid)\n{\n\tstruct mwl8k_vif *mwl8k_vif;\n\n\tlist_for_each_entry(mwl8k_vif,\n\t\t\t    vif_list, list) {\n\t\tif (memcmp(bssid, mwl8k_vif->bssid,\n\t\t\t   ETH_ALEN) == 0)\n\t\t\treturn mwl8k_vif;\n\t}\n\n\treturn NULL;\n}\n\nstatic int rxq_process(struct ieee80211_hw *hw, int index, int limit)\n{\n\tstruct mwl8k_priv *priv = hw->priv;\n\tstruct mwl8k_vif *mwl8k_vif = NULL;\n\tstruct mwl8k_rx_queue *rxq = priv->rxq + index;\n\tint processed;\n\n\tprocessed = 0;\n\twhile (rxq->rxd_count && limit--) {\n\t\tstruct sk_buff *skb;\n\t\tvoid *rxd;\n\t\tint pkt_len;\n\t\tstruct ieee80211_rx_status status;\n\t\tstruct ieee80211_hdr *wh;\n\t\t__le16 qos;\n\n\t\tskb = rxq->buf[rxq->head].skb;\n\t\tif (skb == NULL)\n\t\t\tbreak;\n\n\t\trxd = rxq->rxd + (rxq->head * priv->rxd_ops->rxd_size);\n\n\t\tpkt_len = priv->rxd_ops->rxd_process(rxd, &status, &qos,\n\t\t\t\t\t\t\t&priv->noise);\n\t\tif (pkt_len < 0)\n\t\t\tbreak;\n\n\t\trxq->buf[rxq->head].skb = NULL;\n\n\t\tdma_unmap_single(&priv->pdev->dev,\n\t\t\t\t dma_unmap_addr(&rxq->buf[rxq->head], dma),\n\t\t\t\t MWL8K_RX_MAXSZ, DMA_FROM_DEVICE);\n\t\tdma_unmap_addr_set(&rxq->buf[rxq->head], dma, 0);\n\n\t\trxq->head++;\n\t\tif (rxq->head == MWL8K_RX_DESCS)\n\t\t\trxq->head = 0;\n\n\t\trxq->rxd_count--;\n\n\t\twh = &((struct mwl8k_dma_data *)skb->data)->wh;\n\n\t\t \n\t\tif (mwl8k_capture_bssid(priv, (void *)skb->data))\n\t\t\tmwl8k_save_beacon(hw, skb);\n\n\t\tif (ieee80211_has_protected(wh->frame_control)) {\n\n\t\t\t \n\t\t\tmwl8k_vif = mwl8k_find_vif_bss(&priv->vif_list,\n\t\t\t\t\t\t\t\twh->addr1);\n\n\t\t\tif (mwl8k_vif != NULL &&\n\t\t\t    mwl8k_vif->is_hw_crypto_enabled) {\n\t\t\t\t \n\t\t\t\tif (status.flag & RX_FLAG_MMIC_ERROR) {\n\t\t\t\t\tstruct mwl8k_dma_data *tr;\n\t\t\t\t\ttr = (struct mwl8k_dma_data *)skb->data;\n\t\t\t\t\tmemset((void *)&(tr->data), 0, 4);\n\t\t\t\t\tpkt_len += 4;\n\t\t\t\t}\n\n\t\t\t\tif (!ieee80211_is_auth(wh->frame_control))\n\t\t\t\t\tstatus.flag |= RX_FLAG_IV_STRIPPED |\n\t\t\t\t\t\t       RX_FLAG_DECRYPTED |\n\t\t\t\t\t\t       RX_FLAG_MMIC_STRIPPED;\n\t\t\t}\n\t\t}\n\n\t\tskb_put(skb, pkt_len);\n\t\tmwl8k_remove_dma_header(skb, qos);\n\t\tmemcpy(IEEE80211_SKB_RXCB(skb), &status, sizeof(status));\n\t\tieee80211_rx_irqsafe(hw, skb);\n\n\t\tprocessed++;\n\t}\n\n\treturn processed;\n}\n\n\n \n\n#define MWL8K_TXD_STATUS_OK\t\t\t0x00000001\n#define MWL8K_TXD_STATUS_OK_RETRY\t\t0x00000002\n#define MWL8K_TXD_STATUS_OK_MORE_RETRY\t\t0x00000004\n#define MWL8K_TXD_STATUS_MULTICAST_TX\t\t0x00000008\n#define MWL8K_TXD_STATUS_FW_OWNED\t\t0x80000000\n\n#define MWL8K_QOS_QLEN_UNSPEC\t\t\t0xff00\n#define MWL8K_QOS_ACK_POLICY_MASK\t\t0x0060\n#define MWL8K_QOS_ACK_POLICY_NORMAL\t\t0x0000\n#define MWL8K_QOS_ACK_POLICY_BLOCKACK\t\t0x0060\n#define MWL8K_QOS_EOSP\t\t\t\t0x0010\n\nstruct mwl8k_tx_desc {\n\t__le32 status;\n\t__u8 data_rate;\n\t__u8 tx_priority;\n\t__le16 qos_control;\n\t__le32 pkt_phys_addr;\n\t__le16 pkt_len;\n\t__u8 dest_MAC_addr[ETH_ALEN];\n\t__le32 next_txd_phys_addr;\n\t__le32 timestamp;\n\t__le16 rate_info;\n\t__u8 peer_id;\n\t__u8 tx_frag_cnt;\n} __packed;\n\n#define MWL8K_TX_DESCS\t\t128\n\nstatic int mwl8k_txq_init(struct ieee80211_hw *hw, int index)\n{\n\tstruct mwl8k_priv *priv = hw->priv;\n\tstruct mwl8k_tx_queue *txq = priv->txq + index;\n\tint size;\n\tint i;\n\n\ttxq->len = 0;\n\ttxq->head = 0;\n\ttxq->tail = 0;\n\n\tsize = MWL8K_TX_DESCS * sizeof(struct mwl8k_tx_desc);\n\n\ttxq->txd = dma_alloc_coherent(&priv->pdev->dev, size, &txq->txd_dma,\n\t\t\t\t      GFP_KERNEL);\n\tif (txq->txd == NULL) {\n\t\twiphy_err(hw->wiphy, \"failed to alloc TX descriptors\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\ttxq->skb = kcalloc(MWL8K_TX_DESCS, sizeof(*txq->skb), GFP_KERNEL);\n\tif (txq->skb == NULL) {\n\t\tdma_free_coherent(&priv->pdev->dev, size, txq->txd,\n\t\t\t\t  txq->txd_dma);\n\t\ttxq->txd = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < MWL8K_TX_DESCS; i++) {\n\t\tstruct mwl8k_tx_desc *tx_desc;\n\t\tint nexti;\n\n\t\ttx_desc = txq->txd + i;\n\t\tnexti = (i + 1) % MWL8K_TX_DESCS;\n\n\t\ttx_desc->status = 0;\n\t\ttx_desc->next_txd_phys_addr =\n\t\t\tcpu_to_le32(txq->txd_dma + nexti * sizeof(*tx_desc));\n\t}\n\n\treturn 0;\n}\n\nstatic inline void mwl8k_tx_start(struct mwl8k_priv *priv)\n{\n\tiowrite32(MWL8K_H2A_INT_PPA_READY,\n\t\tpriv->regs + MWL8K_HIU_H2A_INTERRUPT_EVENTS);\n\tiowrite32(MWL8K_H2A_INT_DUMMY,\n\t\tpriv->regs + MWL8K_HIU_H2A_INTERRUPT_EVENTS);\n\tioread32(priv->regs + MWL8K_HIU_INT_CODE);\n}\n\nstatic void mwl8k_dump_tx_rings(struct ieee80211_hw *hw)\n{\n\tstruct mwl8k_priv *priv = hw->priv;\n\tint i;\n\n\tfor (i = 0; i < mwl8k_tx_queues(priv); i++) {\n\t\tstruct mwl8k_tx_queue *txq = priv->txq + i;\n\t\tint fw_owned = 0;\n\t\tint drv_owned = 0;\n\t\tint unused = 0;\n\t\tint desc;\n\n\t\tfor (desc = 0; desc < MWL8K_TX_DESCS; desc++) {\n\t\t\tstruct mwl8k_tx_desc *tx_desc = txq->txd + desc;\n\t\t\tu32 status;\n\n\t\t\tstatus = le32_to_cpu(tx_desc->status);\n\t\t\tif (status & MWL8K_TXD_STATUS_FW_OWNED)\n\t\t\t\tfw_owned++;\n\t\t\telse\n\t\t\t\tdrv_owned++;\n\n\t\t\tif (tx_desc->pkt_len == 0)\n\t\t\t\tunused++;\n\t\t}\n\n\t\twiphy_err(hw->wiphy,\n\t\t\t  \"txq[%d] len=%d head=%d tail=%d \"\n\t\t\t  \"fw_owned=%d drv_owned=%d unused=%d\\n\",\n\t\t\t  i,\n\t\t\t  txq->len, txq->head, txq->tail,\n\t\t\t  fw_owned, drv_owned, unused);\n\t}\n}\n\n \n#define MWL8K_TX_WAIT_TIMEOUT_MS\t5000\n\nstatic int mwl8k_tx_wait_empty(struct ieee80211_hw *hw)\n{\n\tstruct mwl8k_priv *priv = hw->priv;\n\tDECLARE_COMPLETION_ONSTACK(tx_wait);\n\tint retry;\n\tint rc;\n\n\tmight_sleep();\n\n\t \n\tif (priv->hw_restart_in_progress) {\n\t\tif (priv->hw_restart_owner == current)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn -EBUSY;\n\t}\n\n\tif (atomic_read(&priv->watchdog_event_pending))\n\t\treturn 0;\n\n\t \n\tif (!priv->pending_tx_pkts)\n\t\treturn 0;\n\n\tretry = 1;\n\trc = 0;\n\n\tspin_lock_bh(&priv->tx_lock);\n\tpriv->tx_wait = &tx_wait;\n\twhile (!rc) {\n\t\tint oldcount;\n\t\tunsigned long timeout;\n\n\t\toldcount = priv->pending_tx_pkts;\n\n\t\tspin_unlock_bh(&priv->tx_lock);\n\t\ttimeout = wait_for_completion_timeout(&tx_wait,\n\t\t\t    msecs_to_jiffies(MWL8K_TX_WAIT_TIMEOUT_MS));\n\n\t\tif (atomic_read(&priv->watchdog_event_pending)) {\n\t\t\tspin_lock_bh(&priv->tx_lock);\n\t\t\tpriv->tx_wait = NULL;\n\t\t\tspin_unlock_bh(&priv->tx_lock);\n\t\t\treturn 0;\n\t\t}\n\n\t\tspin_lock_bh(&priv->tx_lock);\n\n\t\tif (timeout || !priv->pending_tx_pkts) {\n\t\t\tWARN_ON(priv->pending_tx_pkts);\n\t\t\tif (retry)\n\t\t\t\twiphy_notice(hw->wiphy, \"tx rings drained\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (retry) {\n\t\t\tmwl8k_tx_start(priv);\n\t\t\tretry = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (priv->pending_tx_pkts < oldcount) {\n\t\t\twiphy_notice(hw->wiphy,\n\t\t\t\t     \"waiting for tx rings to drain (%d -> %d pkts)\\n\",\n\t\t\t\t     oldcount, priv->pending_tx_pkts);\n\t\t\tretry = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tpriv->tx_wait = NULL;\n\n\t\twiphy_err(hw->wiphy, \"tx rings stuck for %d ms\\n\",\n\t\t\t  MWL8K_TX_WAIT_TIMEOUT_MS);\n\t\tmwl8k_dump_tx_rings(hw);\n\t\tpriv->hw_restart_in_progress = true;\n\t\tieee80211_queue_work(hw, &priv->fw_reload);\n\n\t\trc = -ETIMEDOUT;\n\t}\n\tpriv->tx_wait = NULL;\n\tspin_unlock_bh(&priv->tx_lock);\n\n\treturn rc;\n}\n\n#define MWL8K_TXD_SUCCESS(status)\t\t\t\t\\\n\t((status) & (MWL8K_TXD_STATUS_OK |\t\t\t\\\n\t\t     MWL8K_TXD_STATUS_OK_RETRY |\t\t\\\n\t\t     MWL8K_TXD_STATUS_OK_MORE_RETRY))\n\nstatic int mwl8k_tid_queue_mapping(u8 tid)\n{\n\tBUG_ON(tid > 7);\n\n\tswitch (tid) {\n\tcase 0:\n\tcase 3:\n\t\treturn IEEE80211_AC_BE;\n\tcase 1:\n\tcase 2:\n\t\treturn IEEE80211_AC_BK;\n\tcase 4:\n\tcase 5:\n\t\treturn IEEE80211_AC_VI;\n\tcase 6:\n\tcase 7:\n\t\treturn IEEE80211_AC_VO;\n\tdefault:\n\t\treturn -1;\n\t}\n}\n\n \n\n#define RI_FORMAT(a)\t\t  (a & 0x0001)\n#define RI_RATE_ID_MCS(a)\t ((a & 0x01f8) >> 3)\n\nstatic int\nmwl8k_txq_reclaim(struct ieee80211_hw *hw, int index, int limit, int force)\n{\n\tstruct mwl8k_priv *priv = hw->priv;\n\tstruct mwl8k_tx_queue *txq = priv->txq + index;\n\tint processed;\n\n\tprocessed = 0;\n\twhile (txq->len > 0 && limit--) {\n\t\tint tx;\n\t\tstruct mwl8k_tx_desc *tx_desc;\n\t\tunsigned long addr;\n\t\tint size;\n\t\tstruct sk_buff *skb;\n\t\tstruct ieee80211_tx_info *info;\n\t\tu32 status;\n\t\tstruct ieee80211_sta *sta;\n\t\tstruct mwl8k_sta *sta_info = NULL;\n\t\tu16 rate_info;\n\t\tstruct ieee80211_hdr *wh;\n\n\t\ttx = txq->head;\n\t\ttx_desc = txq->txd + tx;\n\n\t\tstatus = le32_to_cpu(tx_desc->status);\n\n\t\tif (status & MWL8K_TXD_STATUS_FW_OWNED) {\n\t\t\tif (!force)\n\t\t\t\tbreak;\n\t\t\ttx_desc->status &=\n\t\t\t\t~cpu_to_le32(MWL8K_TXD_STATUS_FW_OWNED);\n\t\t}\n\n\t\ttxq->head = (tx + 1) % MWL8K_TX_DESCS;\n\t\tBUG_ON(txq->len == 0);\n\t\ttxq->len--;\n\t\tpriv->pending_tx_pkts--;\n\n\t\taddr = le32_to_cpu(tx_desc->pkt_phys_addr);\n\t\tsize = le16_to_cpu(tx_desc->pkt_len);\n\t\tskb = txq->skb[tx];\n\t\ttxq->skb[tx] = NULL;\n\n\t\tBUG_ON(skb == NULL);\n\t\tdma_unmap_single(&priv->pdev->dev, addr, size, DMA_TO_DEVICE);\n\n\t\tmwl8k_remove_dma_header(skb, tx_desc->qos_control);\n\n\t\twh = (struct ieee80211_hdr *) skb->data;\n\n\t\t \n\t\ttx_desc->pkt_phys_addr = 0;\n\t\ttx_desc->pkt_len = 0;\n\n\t\tinfo = IEEE80211_SKB_CB(skb);\n\t\tif (ieee80211_is_data(wh->frame_control)) {\n\t\t\trcu_read_lock();\n\t\t\tsta = ieee80211_find_sta_by_ifaddr(hw, wh->addr1,\n\t\t\t\t\t\t\t   wh->addr2);\n\t\t\tif (sta) {\n\t\t\t\tsta_info = MWL8K_STA(sta);\n\t\t\t\tBUG_ON(sta_info == NULL);\n\t\t\t\trate_info = le16_to_cpu(tx_desc->rate_info);\n\t\t\t\t \n\t\t\t\tif (RI_RATE_ID_MCS(rate_info) < 1 ||\n\t\t\t\t    RI_FORMAT(rate_info) == 0) {\n\t\t\t\t\tsta_info->is_ampdu_allowed = false;\n\t\t\t\t} else {\n\t\t\t\t\tsta_info->is_ampdu_allowed = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\trcu_read_unlock();\n\t\t}\n\n\t\tieee80211_tx_info_clear_status(info);\n\n\t\t \n\t\tinfo->status.rates[0].idx = -1;\n\t\tinfo->status.rates[0].count = 1;\n\n\t\tif (MWL8K_TXD_SUCCESS(status))\n\t\t\tinfo->flags |= IEEE80211_TX_STAT_ACK;\n\n\t\tieee80211_tx_status_irqsafe(hw, skb);\n\n\t\tprocessed++;\n\t}\n\n\treturn processed;\n}\n\n \nstatic void mwl8k_txq_deinit(struct ieee80211_hw *hw, int index)\n{\n\tstruct mwl8k_priv *priv = hw->priv;\n\tstruct mwl8k_tx_queue *txq = priv->txq + index;\n\n\tif (txq->txd == NULL)\n\t\treturn;\n\n\tmwl8k_txq_reclaim(hw, index, INT_MAX, 1);\n\n\tkfree(txq->skb);\n\ttxq->skb = NULL;\n\n\tdma_free_coherent(&priv->pdev->dev,\n\t\t\t  MWL8K_TX_DESCS * sizeof(struct mwl8k_tx_desc),\n\t\t\t  txq->txd, txq->txd_dma);\n\ttxq->txd = NULL;\n}\n\n \nstatic struct mwl8k_ampdu_stream *\nmwl8k_add_stream(struct ieee80211_hw *hw, struct ieee80211_sta *sta, u8 tid)\n{\n\tstruct mwl8k_ampdu_stream *stream;\n\tstruct mwl8k_priv *priv = hw->priv;\n\tint i;\n\n\tfor (i = 0; i < MWL8K_NUM_AMPDU_STREAMS; i++) {\n\t\tstream = &priv->ampdu[i];\n\t\tif (stream->state == AMPDU_NO_STREAM) {\n\t\t\tstream->sta = sta;\n\t\t\tstream->state = AMPDU_STREAM_NEW;\n\t\t\tstream->tid = tid;\n\t\t\tstream->idx = i;\n\t\t\twiphy_debug(hw->wiphy, \"Added a new stream for %pM %d\",\n\t\t\t\t    sta->addr, tid);\n\t\t\treturn stream;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic int\nmwl8k_start_stream(struct ieee80211_hw *hw, struct mwl8k_ampdu_stream *stream)\n{\n\tint ret;\n\n\t \n\tif (stream->state != AMPDU_STREAM_NEW)\n\t\treturn 0;\n\tret = ieee80211_start_tx_ba_session(stream->sta, stream->tid, 0);\n\tif (ret)\n\t\twiphy_debug(hw->wiphy, \"Failed to start stream for %pM %d: \"\n\t\t\t    \"%d\\n\", stream->sta->addr, stream->tid, ret);\n\telse\n\t\twiphy_debug(hw->wiphy, \"Started stream for %pM %d\\n\",\n\t\t\t    stream->sta->addr, stream->tid);\n\treturn ret;\n}\n\nstatic void\nmwl8k_remove_stream(struct ieee80211_hw *hw, struct mwl8k_ampdu_stream *stream)\n{\n\twiphy_debug(hw->wiphy, \"Remove stream for %pM %d\\n\", stream->sta->addr,\n\t\t    stream->tid);\n\tmemset(stream, 0, sizeof(*stream));\n}\n\nstatic struct mwl8k_ampdu_stream *\nmwl8k_lookup_stream(struct ieee80211_hw *hw, u8 *addr, u8 tid)\n{\n\tstruct mwl8k_priv *priv = hw->priv;\n\tint i;\n\n\tfor (i = 0; i < MWL8K_NUM_AMPDU_STREAMS; i++) {\n\t\tstruct mwl8k_ampdu_stream *stream;\n\t\tstream = &priv->ampdu[i];\n\t\tif (stream->state == AMPDU_NO_STREAM)\n\t\t\tcontinue;\n\t\tif (!memcmp(stream->sta->addr, addr, ETH_ALEN) &&\n\t\t    stream->tid == tid)\n\t\t\treturn stream;\n\t}\n\treturn NULL;\n}\n\n#define MWL8K_AMPDU_PACKET_THRESHOLD 64\nstatic inline bool mwl8k_ampdu_allowed(struct ieee80211_sta *sta, u8 tid)\n{\n\tstruct mwl8k_sta *sta_info = MWL8K_STA(sta);\n\tstruct tx_traffic_info *tx_stats;\n\n\tBUG_ON(tid >= MWL8K_MAX_TID);\n\ttx_stats = &sta_info->tx_stats[tid];\n\n\treturn sta_info->is_ampdu_allowed &&\n\t\ttx_stats->pkts > MWL8K_AMPDU_PACKET_THRESHOLD;\n}\n\nstatic inline void mwl8k_tx_count_packet(struct ieee80211_sta *sta, u8 tid)\n{\n\tstruct mwl8k_sta *sta_info = MWL8K_STA(sta);\n\tstruct tx_traffic_info *tx_stats;\n\n\tBUG_ON(tid >= MWL8K_MAX_TID);\n\ttx_stats = &sta_info->tx_stats[tid];\n\n\tif (tx_stats->start_time == 0)\n\t\ttx_stats->start_time = jiffies;\n\n\t \n\tif (time_after(jiffies, (unsigned long)tx_stats->start_time + HZ)) {\n\t\ttx_stats->pkts = 0;\n\t\ttx_stats->start_time = 0;\n\t} else\n\t\ttx_stats->pkts++;\n}\n\n \n#define BA_QUEUE\t\t5\n\nstatic void\nmwl8k_txq_xmit(struct ieee80211_hw *hw,\n\t       int index,\n\t       struct ieee80211_sta *sta,\n\t       struct sk_buff *skb)\n{\n\tstruct mwl8k_priv *priv = hw->priv;\n\tstruct ieee80211_tx_info *tx_info;\n\tstruct mwl8k_vif *mwl8k_vif;\n\tstruct ieee80211_hdr *wh;\n\tstruct mwl8k_tx_queue *txq;\n\tstruct mwl8k_tx_desc *tx;\n\tdma_addr_t dma;\n\tu32 txstatus;\n\tu8 txdatarate;\n\tu16 qos;\n\tint txpriority;\n\tu8 tid = 0;\n\tstruct mwl8k_ampdu_stream *stream = NULL;\n\tbool start_ba_session = false;\n\tbool mgmtframe = false;\n\tstruct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)skb->data;\n\tbool eapol_frame = false;\n\n\twh = (struct ieee80211_hdr *)skb->data;\n\tif (ieee80211_is_data_qos(wh->frame_control))\n\t\tqos = le16_to_cpu(*((__le16 *)ieee80211_get_qos_ctl(wh)));\n\telse\n\t\tqos = 0;\n\n\tif (skb->protocol == cpu_to_be16(ETH_P_PAE))\n\t\teapol_frame = true;\n\n\tif (ieee80211_is_mgmt(wh->frame_control))\n\t\tmgmtframe = true;\n\n\tif (priv->ap_fw)\n\t\tmwl8k_encapsulate_tx_frame(priv, skb);\n\telse\n\t\tmwl8k_add_dma_header(priv, skb, 0, 0);\n\n\twh = &((struct mwl8k_dma_data *)skb->data)->wh;\n\n\ttx_info = IEEE80211_SKB_CB(skb);\n\tmwl8k_vif = MWL8K_VIF(tx_info->control.vif);\n\n\tif (tx_info->flags & IEEE80211_TX_CTL_ASSIGN_SEQ) {\n\t\twh->seq_ctrl &= cpu_to_le16(IEEE80211_SCTL_FRAG);\n\t\twh->seq_ctrl |= cpu_to_le16(mwl8k_vif->seqno);\n\t\tmwl8k_vif->seqno += 0x10;\n\t}\n\n\t \n\ttxstatus = 0;\n\ttxdatarate = 0;\n\tif (ieee80211_is_mgmt(wh->frame_control) ||\n\t    ieee80211_is_ctl(wh->frame_control)) {\n\t\ttxdatarate = 0;\n\t\tqos |= MWL8K_QOS_QLEN_UNSPEC | MWL8K_QOS_EOSP;\n\t} else if (ieee80211_is_data(wh->frame_control)) {\n\t\ttxdatarate = 1;\n\t\tif (is_multicast_ether_addr(wh->addr1))\n\t\t\ttxstatus |= MWL8K_TXD_STATUS_MULTICAST_TX;\n\n\t\tqos &= ~MWL8K_QOS_ACK_POLICY_MASK;\n\t\tif (tx_info->flags & IEEE80211_TX_CTL_AMPDU)\n\t\t\tqos |= MWL8K_QOS_ACK_POLICY_BLOCKACK;\n\t\telse\n\t\t\tqos |= MWL8K_QOS_ACK_POLICY_NORMAL;\n\t}\n\n\t \n\tif (unlikely(ieee80211_is_action(wh->frame_control) &&\n\t    mgmt->u.action.category == WLAN_CATEGORY_BACK &&\n\t    mgmt->u.action.u.addba_req.action_code == WLAN_ACTION_ADDBA_REQ &&\n\t    priv->ap_fw)) {\n\t\tu16 capab = le16_to_cpu(mgmt->u.action.u.addba_req.capab);\n\t\ttid = (capab & IEEE80211_ADDBA_PARAM_TID_MASK) >> 2;\n\t\tindex = mwl8k_tid_queue_mapping(tid);\n\t}\n\n\ttxpriority = index;\n\n\tif (priv->ap_fw && sta && sta->deflink.ht_cap.ht_supported && !eapol_frame &&\n\t    ieee80211_is_data_qos(wh->frame_control)) {\n\t\ttid = qos & 0xf;\n\t\tmwl8k_tx_count_packet(sta, tid);\n\t\tspin_lock(&priv->stream_lock);\n\t\tstream = mwl8k_lookup_stream(hw, sta->addr, tid);\n\t\tif (stream != NULL) {\n\t\t\tif (stream->state == AMPDU_STREAM_ACTIVE) {\n\t\t\t\tWARN_ON(!(qos & MWL8K_QOS_ACK_POLICY_BLOCKACK));\n\t\t\t\ttxpriority = (BA_QUEUE + stream->idx) %\n\t\t\t\t\t     TOTAL_HW_TX_QUEUES;\n\t\t\t\tif (stream->idx <= 1)\n\t\t\t\t\tindex = stream->idx +\n\t\t\t\t\t\tMWL8K_TX_WMM_QUEUES;\n\n\t\t\t} else if (stream->state == AMPDU_STREAM_NEW) {\n\t\t\t\t \n\t\t\t} else {\n\t\t\t\t \n\t\t\t\twiphy_warn(hw->wiphy,\n\t\t\t\t\t   \"Cannot send packet while ADDBA \"\n\t\t\t\t\t   \"dialog is underway.\\n\");\n\t\t\t\tspin_unlock(&priv->stream_lock);\n\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (mwl8k_ampdu_allowed(sta, tid)) {\n\t\t\t\tstream = mwl8k_add_stream(hw, sta, tid);\n\t\t\t\tif (stream != NULL)\n\t\t\t\t\tstart_ba_session = true;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&priv->stream_lock);\n\t} else {\n\t\tqos &= ~MWL8K_QOS_ACK_POLICY_MASK;\n\t\tqos |= MWL8K_QOS_ACK_POLICY_NORMAL;\n\t}\n\n\tdma = dma_map_single(&priv->pdev->dev, skb->data, skb->len,\n\t\t\t     DMA_TO_DEVICE);\n\n\tif (dma_mapping_error(&priv->pdev->dev, dma)) {\n\t\twiphy_debug(hw->wiphy,\n\t\t\t    \"failed to dma map skb, dropping TX frame.\\n\");\n\t\tif (start_ba_session) {\n\t\t\tspin_lock(&priv->stream_lock);\n\t\t\tmwl8k_remove_stream(hw, stream);\n\t\t\tspin_unlock(&priv->stream_lock);\n\t\t}\n\t\tdev_kfree_skb(skb);\n\t\treturn;\n\t}\n\n\tspin_lock_bh(&priv->tx_lock);\n\n\ttxq = priv->txq + index;\n\n\t \n\n\tif (txq->len >= MWL8K_TX_DESCS - 2) {\n\t\tif (!mgmtframe || txq->len == MWL8K_TX_DESCS) {\n\t\t\tif (start_ba_session) {\n\t\t\t\tspin_lock(&priv->stream_lock);\n\t\t\t\tmwl8k_remove_stream(hw, stream);\n\t\t\t\tspin_unlock(&priv->stream_lock);\n\t\t\t}\n\t\t\tmwl8k_tx_start(priv);\n\t\t\tspin_unlock_bh(&priv->tx_lock);\n\t\t\tdma_unmap_single(&priv->pdev->dev, dma, skb->len,\n\t\t\t\t\t DMA_TO_DEVICE);\n\t\t\tdev_kfree_skb(skb);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tBUG_ON(txq->skb[txq->tail] != NULL);\n\ttxq->skb[txq->tail] = skb;\n\n\ttx = txq->txd + txq->tail;\n\ttx->data_rate = txdatarate;\n\ttx->tx_priority = txpriority;\n\ttx->qos_control = cpu_to_le16(qos);\n\ttx->pkt_phys_addr = cpu_to_le32(dma);\n\ttx->pkt_len = cpu_to_le16(skb->len);\n\ttx->rate_info = 0;\n\tif (!priv->ap_fw && sta != NULL)\n\t\ttx->peer_id = MWL8K_STA(sta)->peer_id;\n\telse\n\t\ttx->peer_id = 0;\n\n\tif (priv->ap_fw && ieee80211_is_data(wh->frame_control) && !eapol_frame)\n\t\ttx->timestamp = cpu_to_le32(ioread32(priv->regs +\n\t\t\t\t\t\tMWL8K_HW_TIMER_REGISTER));\n\telse\n\t\ttx->timestamp = 0;\n\n\twmb();\n\ttx->status = cpu_to_le32(MWL8K_TXD_STATUS_FW_OWNED | txstatus);\n\n\ttxq->len++;\n\tpriv->pending_tx_pkts++;\n\n\ttxq->tail++;\n\tif (txq->tail == MWL8K_TX_DESCS)\n\t\ttxq->tail = 0;\n\n\tmwl8k_tx_start(priv);\n\n\tspin_unlock_bh(&priv->tx_lock);\n\n\t \n\tif (start_ba_session) {\n\t\tspin_lock(&priv->stream_lock);\n\t\tif (mwl8k_start_stream(hw, stream))\n\t\t\tmwl8k_remove_stream(hw, stream);\n\t\tspin_unlock(&priv->stream_lock);\n\t}\n}\n\n\n \nstatic int mwl8k_fw_lock(struct ieee80211_hw *hw)\n{\n\tstruct mwl8k_priv *priv = hw->priv;\n\n\tif (priv->fw_mutex_owner != current) {\n\t\tint rc;\n\n\t\tmutex_lock(&priv->fw_mutex);\n\t\tieee80211_stop_queues(hw);\n\n\t\trc = mwl8k_tx_wait_empty(hw);\n\t\tif (rc) {\n\t\t\tif (!priv->hw_restart_in_progress)\n\t\t\t\tieee80211_wake_queues(hw);\n\n\t\t\tmutex_unlock(&priv->fw_mutex);\n\n\t\t\treturn rc;\n\t\t}\n\n\t\tpriv->fw_mutex_owner = current;\n\t}\n\n\tpriv->fw_mutex_depth++;\n\n\treturn 0;\n}\n\nstatic void mwl8k_fw_unlock(struct ieee80211_hw *hw)\n{\n\tstruct mwl8k_priv *priv = hw->priv;\n\n\tif (!--priv->fw_mutex_depth) {\n\t\tif (!priv->hw_restart_in_progress)\n\t\t\tieee80211_wake_queues(hw);\n\n\t\tpriv->fw_mutex_owner = NULL;\n\t\tmutex_unlock(&priv->fw_mutex);\n\t}\n}\n\nstatic void mwl8k_enable_bsses(struct ieee80211_hw *hw, bool enable,\n\t\t\t       u32 bitmap);\n\n \n\n \n#define MWL8K_CMD_TIMEOUT_MS\t10000\n\nstatic int mwl8k_post_cmd(struct ieee80211_hw *hw, struct mwl8k_cmd_pkt *cmd)\n{\n\tDECLARE_COMPLETION_ONSTACK(cmd_wait);\n\tstruct mwl8k_priv *priv = hw->priv;\n\tvoid __iomem *regs = priv->regs;\n\tdma_addr_t dma_addr;\n\tunsigned int dma_size;\n\tint rc;\n\tunsigned long timeout = 0;\n\tu8 buf[32];\n\tu32 bitmap = 0;\n\n\twiphy_dbg(hw->wiphy, \"Posting %s [%d]\\n\",\n\t\t  mwl8k_cmd_name(cmd->code, buf, sizeof(buf)), cmd->macid);\n\n\t \n\n\trc = mwl8k_fw_lock(hw);\n\tif (rc)\n\t\treturn rc;\n\n\tif (priv->ap_fw && priv->running_bsses) {\n\t\tswitch (le16_to_cpu(cmd->code)) {\n\t\tcase MWL8K_CMD_SET_RF_CHANNEL:\n\t\tcase MWL8K_CMD_RADIO_CONTROL:\n\t\tcase MWL8K_CMD_RF_TX_POWER:\n\t\tcase MWL8K_CMD_TX_POWER:\n\t\tcase MWL8K_CMD_RF_ANTENNA:\n\t\tcase MWL8K_CMD_RTS_THRESHOLD:\n\t\tcase MWL8K_CMD_MIMO_CONFIG:\n\t\t\tbitmap = priv->running_bsses;\n\t\t\tmwl8k_enable_bsses(hw, false, bitmap);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcmd->result = (__force __le16) 0xffff;\n\tdma_size = le16_to_cpu(cmd->length);\n\tdma_addr = dma_map_single(&priv->pdev->dev, cmd, dma_size,\n\t\t\t\t  DMA_BIDIRECTIONAL);\n\tif (dma_mapping_error(&priv->pdev->dev, dma_addr)) {\n\t\trc = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\tpriv->hostcmd_wait = &cmd_wait;\n\tiowrite32(dma_addr, regs + MWL8K_HIU_GEN_PTR);\n\tiowrite32(MWL8K_H2A_INT_DOORBELL,\n\t\tregs + MWL8K_HIU_H2A_INTERRUPT_EVENTS);\n\tiowrite32(MWL8K_H2A_INT_DUMMY,\n\t\tregs + MWL8K_HIU_H2A_INTERRUPT_EVENTS);\n\n\ttimeout = wait_for_completion_timeout(&cmd_wait,\n\t\t\t\tmsecs_to_jiffies(MWL8K_CMD_TIMEOUT_MS));\n\n\tpriv->hostcmd_wait = NULL;\n\n\n\tdma_unmap_single(&priv->pdev->dev, dma_addr, dma_size,\n\t\t\t DMA_BIDIRECTIONAL);\n\n\tif (!timeout) {\n\t\twiphy_err(hw->wiphy, \"Command %s timeout after %u ms\\n\",\n\t\t\t  mwl8k_cmd_name(cmd->code, buf, sizeof(buf)),\n\t\t\t  MWL8K_CMD_TIMEOUT_MS);\n\t\trc = -ETIMEDOUT;\n\t} else {\n\t\tint ms;\n\n\t\tms = MWL8K_CMD_TIMEOUT_MS - jiffies_to_msecs(timeout);\n\n\t\trc = cmd->result ? -EINVAL : 0;\n\t\tif (rc)\n\t\t\twiphy_err(hw->wiphy, \"Command %s error 0x%x\\n\",\n\t\t\t\t  mwl8k_cmd_name(cmd->code, buf, sizeof(buf)),\n\t\t\t\t  le16_to_cpu(cmd->result));\n\t\telse if (ms > 2000)\n\t\t\twiphy_notice(hw->wiphy, \"Command %s took %d ms\\n\",\n\t\t\t\t     mwl8k_cmd_name(cmd->code,\n\t\t\t\t\t\t    buf, sizeof(buf)),\n\t\t\t\t     ms);\n\t}\n\nexit:\n\tif (bitmap)\n\t\tmwl8k_enable_bsses(hw, true, bitmap);\n\n\tmwl8k_fw_unlock(hw);\n\n\treturn rc;\n}\n\nstatic int mwl8k_post_pervif_cmd(struct ieee80211_hw *hw,\n\t\t\t\t struct ieee80211_vif *vif,\n\t\t\t\t struct mwl8k_cmd_pkt *cmd)\n{\n\tif (vif != NULL)\n\t\tcmd->macid = MWL8K_VIF(vif)->macid;\n\treturn mwl8k_post_cmd(hw, cmd);\n}\n\n \nstatic void mwl8k_setup_2ghz_band(struct ieee80211_hw *hw)\n{\n\tstruct mwl8k_priv *priv = hw->priv;\n\n\tBUILD_BUG_ON(sizeof(priv->channels_24) != sizeof(mwl8k_channels_24));\n\tmemcpy(priv->channels_24, mwl8k_channels_24, sizeof(mwl8k_channels_24));\n\n\tBUILD_BUG_ON(sizeof(priv->rates_24) != sizeof(mwl8k_rates_24));\n\tmemcpy(priv->rates_24, mwl8k_rates_24, sizeof(mwl8k_rates_24));\n\n\tpriv->band_24.band = NL80211_BAND_2GHZ;\n\tpriv->band_24.channels = priv->channels_24;\n\tpriv->band_24.n_channels = ARRAY_SIZE(mwl8k_channels_24);\n\tpriv->band_24.bitrates = priv->rates_24;\n\tpriv->band_24.n_bitrates = ARRAY_SIZE(mwl8k_rates_24);\n\n\thw->wiphy->bands[NL80211_BAND_2GHZ] = &priv->band_24;\n}\n\nstatic void mwl8k_setup_5ghz_band(struct ieee80211_hw *hw)\n{\n\tstruct mwl8k_priv *priv = hw->priv;\n\n\tBUILD_BUG_ON(sizeof(priv->channels_50) != sizeof(mwl8k_channels_50));\n\tmemcpy(priv->channels_50, mwl8k_channels_50, sizeof(mwl8k_channels_50));\n\n\tBUILD_BUG_ON(sizeof(priv->rates_50) != sizeof(mwl8k_rates_50));\n\tmemcpy(priv->rates_50, mwl8k_rates_50, sizeof(mwl8k_rates_50));\n\n\tpriv->band_50.band = NL80211_BAND_5GHZ;\n\tpriv->band_50.channels = priv->channels_50;\n\tpriv->band_50.n_channels = ARRAY_SIZE(mwl8k_channels_50);\n\tpriv->band_50.bitrates = priv->rates_50;\n\tpriv->band_50.n_bitrates = ARRAY_SIZE(mwl8k_rates_50);\n\n\thw->wiphy->bands[NL80211_BAND_5GHZ] = &priv->band_50;\n}\n\n \nstruct mwl8k_cmd_get_hw_spec_sta {\n\tstruct mwl8k_cmd_pkt header;\n\t__u8 hw_rev;\n\t__u8 host_interface;\n\t__le16 num_mcaddrs;\n\t__u8 perm_addr[ETH_ALEN];\n\t__le16 region_code;\n\t__le32 fw_rev;\n\t__le32 ps_cookie;\n\t__le32 caps;\n\t__u8 mcs_bitmap[16];\n\t__le32 rx_queue_ptr;\n\t__le32 num_tx_queues;\n\t__le32 tx_queue_ptrs[MWL8K_TX_WMM_QUEUES];\n\t__le32 caps2;\n\t__le32 num_tx_desc_per_queue;\n\t__le32 total_rxd;\n} __packed;\n\n#define MWL8K_CAP_MAX_AMSDU\t\t0x20000000\n#define MWL8K_CAP_GREENFIELD\t\t0x08000000\n#define MWL8K_CAP_AMPDU\t\t\t0x04000000\n#define MWL8K_CAP_RX_STBC\t\t0x01000000\n#define MWL8K_CAP_TX_STBC\t\t0x00800000\n#define MWL8K_CAP_SHORTGI_40MHZ\t\t0x00400000\n#define MWL8K_CAP_SHORTGI_20MHZ\t\t0x00200000\n#define MWL8K_CAP_RX_ANTENNA_MASK\t0x000e0000\n#define MWL8K_CAP_TX_ANTENNA_MASK\t0x0001c000\n#define MWL8K_CAP_DELAY_BA\t\t0x00003000\n#define MWL8K_CAP_MIMO\t\t\t0x00000200\n#define MWL8K_CAP_40MHZ\t\t\t0x00000100\n#define MWL8K_CAP_BAND_MASK\t\t0x00000007\n#define MWL8K_CAP_5GHZ\t\t\t0x00000004\n#define MWL8K_CAP_2GHZ4\t\t\t0x00000001\n\nstatic void\nmwl8k_set_ht_caps(struct ieee80211_hw *hw,\n\t\t  struct ieee80211_supported_band *band, u32 cap)\n{\n\tint rx_streams;\n\tint tx_streams;\n\n\tband->ht_cap.ht_supported = 1;\n\n\tif (cap & MWL8K_CAP_MAX_AMSDU)\n\t\tband->ht_cap.cap |= IEEE80211_HT_CAP_MAX_AMSDU;\n\tif (cap & MWL8K_CAP_GREENFIELD)\n\t\tband->ht_cap.cap |= IEEE80211_HT_CAP_GRN_FLD;\n\tif (cap & MWL8K_CAP_AMPDU) {\n\t\tieee80211_hw_set(hw, AMPDU_AGGREGATION);\n\t\tband->ht_cap.ampdu_factor = IEEE80211_HT_MAX_AMPDU_64K;\n\t\tband->ht_cap.ampdu_density = IEEE80211_HT_MPDU_DENSITY_NONE;\n\t}\n\tif (cap & MWL8K_CAP_RX_STBC)\n\t\tband->ht_cap.cap |= IEEE80211_HT_CAP_RX_STBC;\n\tif (cap & MWL8K_CAP_TX_STBC)\n\t\tband->ht_cap.cap |= IEEE80211_HT_CAP_TX_STBC;\n\tif (cap & MWL8K_CAP_SHORTGI_40MHZ)\n\t\tband->ht_cap.cap |= IEEE80211_HT_CAP_SGI_40;\n\tif (cap & MWL8K_CAP_SHORTGI_20MHZ)\n\t\tband->ht_cap.cap |= IEEE80211_HT_CAP_SGI_20;\n\tif (cap & MWL8K_CAP_DELAY_BA)\n\t\tband->ht_cap.cap |= IEEE80211_HT_CAP_DELAY_BA;\n\tif (cap & MWL8K_CAP_40MHZ)\n\t\tband->ht_cap.cap |= IEEE80211_HT_CAP_SUP_WIDTH_20_40;\n\n\trx_streams = hweight32(cap & MWL8K_CAP_RX_ANTENNA_MASK);\n\ttx_streams = hweight32(cap & MWL8K_CAP_TX_ANTENNA_MASK);\n\n\tband->ht_cap.mcs.rx_mask[0] = 0xff;\n\tif (rx_streams >= 2)\n\t\tband->ht_cap.mcs.rx_mask[1] = 0xff;\n\tif (rx_streams >= 3)\n\t\tband->ht_cap.mcs.rx_mask[2] = 0xff;\n\tband->ht_cap.mcs.rx_mask[4] = 0x01;\n\tband->ht_cap.mcs.tx_params = IEEE80211_HT_MCS_TX_DEFINED;\n\n\tif (rx_streams != tx_streams) {\n\t\tband->ht_cap.mcs.tx_params |= IEEE80211_HT_MCS_TX_RX_DIFF;\n\t\tband->ht_cap.mcs.tx_params |= (tx_streams - 1) <<\n\t\t\t\tIEEE80211_HT_MCS_TX_MAX_STREAMS_SHIFT;\n\t}\n}\n\nstatic void\nmwl8k_set_caps(struct ieee80211_hw *hw, u32 caps)\n{\n\tstruct mwl8k_priv *priv = hw->priv;\n\n\tif (priv->caps)\n\t\treturn;\n\n\tif ((caps & MWL8K_CAP_2GHZ4) || !(caps & MWL8K_CAP_BAND_MASK)) {\n\t\tmwl8k_setup_2ghz_band(hw);\n\t\tif (caps & MWL8K_CAP_MIMO)\n\t\t\tmwl8k_set_ht_caps(hw, &priv->band_24, caps);\n\t}\n\n\tif (caps & MWL8K_CAP_5GHZ) {\n\t\tmwl8k_setup_5ghz_band(hw);\n\t\tif (caps & MWL8K_CAP_MIMO)\n\t\t\tmwl8k_set_ht_caps(hw, &priv->band_50, caps);\n\t}\n\n\tpriv->caps = caps;\n}\n\nstatic int mwl8k_cmd_get_hw_spec_sta(struct ieee80211_hw *hw)\n{\n\tstruct mwl8k_priv *priv = hw->priv;\n\tstruct mwl8k_cmd_get_hw_spec_sta *cmd;\n\tint rc;\n\tint i;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (cmd == NULL)\n\t\treturn -ENOMEM;\n\n\tcmd->header.code = cpu_to_le16(MWL8K_CMD_GET_HW_SPEC);\n\tcmd->header.length = cpu_to_le16(sizeof(*cmd));\n\n\tmemset(cmd->perm_addr, 0xff, sizeof(cmd->perm_addr));\n\tcmd->ps_cookie = cpu_to_le32(priv->cookie_dma);\n\tcmd->rx_queue_ptr = cpu_to_le32(priv->rxq[0].rxd_dma);\n\tcmd->num_tx_queues = cpu_to_le32(mwl8k_tx_queues(priv));\n\tfor (i = 0; i < mwl8k_tx_queues(priv); i++)\n\t\tcmd->tx_queue_ptrs[i] = cpu_to_le32(priv->txq[i].txd_dma);\n\tcmd->num_tx_desc_per_queue = cpu_to_le32(MWL8K_TX_DESCS);\n\tcmd->total_rxd = cpu_to_le32(MWL8K_RX_DESCS);\n\n\trc = mwl8k_post_cmd(hw, &cmd->header);\n\n\tif (!rc) {\n\t\tSET_IEEE80211_PERM_ADDR(hw, cmd->perm_addr);\n\t\tpriv->num_mcaddrs = le16_to_cpu(cmd->num_mcaddrs);\n\t\tpriv->fw_rev = le32_to_cpu(cmd->fw_rev);\n\t\tpriv->hw_rev = cmd->hw_rev;\n\t\tmwl8k_set_caps(hw, le32_to_cpu(cmd->caps));\n\t\tpriv->ap_macids_supported = 0x00000000;\n\t\tpriv->sta_macids_supported = 0x00000001;\n\t}\n\n\tkfree(cmd);\n\treturn rc;\n}\n\n \nstruct mwl8k_cmd_get_hw_spec_ap {\n\tstruct mwl8k_cmd_pkt header;\n\t__u8 hw_rev;\n\t__u8 host_interface;\n\t__le16 num_wcb;\n\t__le16 num_mcaddrs;\n\t__u8 perm_addr[ETH_ALEN];\n\t__le16 region_code;\n\t__le16 num_antenna;\n\t__le32 fw_rev;\n\t__le32 wcbbase0;\n\t__le32 rxwrptr;\n\t__le32 rxrdptr;\n\t__le32 ps_cookie;\n\t__le32 wcbbase1;\n\t__le32 wcbbase2;\n\t__le32 wcbbase3;\n\t__le32 fw_api_version;\n\t__le32 caps;\n\t__le32 num_of_ampdu_queues;\n\t__le32 wcbbase_ampdu[MWL8K_MAX_AMPDU_QUEUES];\n} __packed;\n\nstatic int mwl8k_cmd_get_hw_spec_ap(struct ieee80211_hw *hw)\n{\n\tstruct mwl8k_priv *priv = hw->priv;\n\tstruct mwl8k_cmd_get_hw_spec_ap *cmd;\n\tint rc, i;\n\tu32 api_version;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (cmd == NULL)\n\t\treturn -ENOMEM;\n\n\tcmd->header.code = cpu_to_le16(MWL8K_CMD_GET_HW_SPEC);\n\tcmd->header.length = cpu_to_le16(sizeof(*cmd));\n\n\tmemset(cmd->perm_addr, 0xff, sizeof(cmd->perm_addr));\n\tcmd->ps_cookie = cpu_to_le32(priv->cookie_dma);\n\n\trc = mwl8k_post_cmd(hw, &cmd->header);\n\n\tif (!rc) {\n\t\tint off;\n\n\t\tapi_version = le32_to_cpu(cmd->fw_api_version);\n\t\tif (priv->device_info->fw_api_ap != api_version) {\n\t\t\tprintk(KERN_ERR \"%s: Unsupported fw API version for %s.\"\n\t\t\t       \"  Expected %d got %d.\\n\", MWL8K_NAME,\n\t\t\t       priv->device_info->part_name,\n\t\t\t       priv->device_info->fw_api_ap,\n\t\t\t       api_version);\n\t\t\trc = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t\tSET_IEEE80211_PERM_ADDR(hw, cmd->perm_addr);\n\t\tpriv->num_mcaddrs = le16_to_cpu(cmd->num_mcaddrs);\n\t\tpriv->fw_rev = le32_to_cpu(cmd->fw_rev);\n\t\tpriv->hw_rev = cmd->hw_rev;\n\t\tmwl8k_set_caps(hw, le32_to_cpu(cmd->caps));\n\t\tpriv->ap_macids_supported = 0x000000ff;\n\t\tpriv->sta_macids_supported = 0x00000100;\n\t\tpriv->num_ampdu_queues = le32_to_cpu(cmd->num_of_ampdu_queues);\n\t\tif (priv->num_ampdu_queues > MWL8K_MAX_AMPDU_QUEUES) {\n\t\t\twiphy_warn(hw->wiphy, \"fw reported %d ampdu queues\"\n\t\t\t\t   \" but we only support %d.\\n\",\n\t\t\t\t   priv->num_ampdu_queues,\n\t\t\t\t   MWL8K_MAX_AMPDU_QUEUES);\n\t\t\tpriv->num_ampdu_queues = MWL8K_MAX_AMPDU_QUEUES;\n\t\t}\n\t\toff = le32_to_cpu(cmd->rxwrptr) & 0xffff;\n\t\tiowrite32(priv->rxq[0].rxd_dma, priv->sram + off);\n\n\t\toff = le32_to_cpu(cmd->rxrdptr) & 0xffff;\n\t\tiowrite32(priv->rxq[0].rxd_dma, priv->sram + off);\n\n\t\tpriv->txq_offset[0] = le32_to_cpu(cmd->wcbbase0) & 0xffff;\n\t\tpriv->txq_offset[1] = le32_to_cpu(cmd->wcbbase1) & 0xffff;\n\t\tpriv->txq_offset[2] = le32_to_cpu(cmd->wcbbase2) & 0xffff;\n\t\tpriv->txq_offset[3] = le32_to_cpu(cmd->wcbbase3) & 0xffff;\n\n\t\tfor (i = 0; i < priv->num_ampdu_queues; i++)\n\t\t\tpriv->txq_offset[i + MWL8K_TX_WMM_QUEUES] =\n\t\t\t\tle32_to_cpu(cmd->wcbbase_ampdu[i]) & 0xffff;\n\t}\n\ndone:\n\tkfree(cmd);\n\treturn rc;\n}\n\n \nstruct mwl8k_cmd_set_hw_spec {\n\tstruct mwl8k_cmd_pkt header;\n\t__u8 hw_rev;\n\t__u8 host_interface;\n\t__le16 num_mcaddrs;\n\t__u8 perm_addr[ETH_ALEN];\n\t__le16 region_code;\n\t__le32 fw_rev;\n\t__le32 ps_cookie;\n\t__le32 caps;\n\t__le32 rx_queue_ptr;\n\t__le32 num_tx_queues;\n\t__le32 tx_queue_ptrs[MWL8K_MAX_TX_QUEUES];\n\t__le32 flags;\n\t__le32 num_tx_desc_per_queue;\n\t__le32 total_rxd;\n} __packed;\n\n \n#define MWL8K_SET_HW_SPEC_FLAG_ENABLE_LIFE_TIME_EXPIRY\t0x00000400\n#define MWL8K_SET_HW_SPEC_FLAG_GENERATE_CCMP_HDR\t0x00000200\n#define MWL8K_SET_HW_SPEC_FLAG_HOST_DECR_MGMT\t\t0x00000080\n#define MWL8K_SET_HW_SPEC_FLAG_HOSTFORM_PROBERESP\t0x00000020\n#define MWL8K_SET_HW_SPEC_FLAG_HOSTFORM_BEACON\t\t0x00000010\n\nstatic int mwl8k_cmd_set_hw_spec(struct ieee80211_hw *hw)\n{\n\tstruct mwl8k_priv *priv = hw->priv;\n\tstruct mwl8k_cmd_set_hw_spec *cmd;\n\tint rc;\n\tint i;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (cmd == NULL)\n\t\treturn -ENOMEM;\n\n\tcmd->header.code = cpu_to_le16(MWL8K_CMD_SET_HW_SPEC);\n\tcmd->header.length = cpu_to_le16(sizeof(*cmd));\n\n\tcmd->ps_cookie = cpu_to_le32(priv->cookie_dma);\n\tcmd->rx_queue_ptr = cpu_to_le32(priv->rxq[0].rxd_dma);\n\tcmd->num_tx_queues = cpu_to_le32(mwl8k_tx_queues(priv));\n\n\t \n\tfor (i = 0; i < mwl8k_tx_queues(priv); i++) {\n\t\tint j = mwl8k_tx_queues(priv) - 1 - i;\n\t\tcmd->tx_queue_ptrs[i] = cpu_to_le32(priv->txq[j].txd_dma);\n\t}\n\n\tcmd->flags = cpu_to_le32(MWL8K_SET_HW_SPEC_FLAG_HOST_DECR_MGMT |\n\t\t\t\t MWL8K_SET_HW_SPEC_FLAG_HOSTFORM_PROBERESP |\n\t\t\t\t MWL8K_SET_HW_SPEC_FLAG_HOSTFORM_BEACON |\n\t\t\t\t MWL8K_SET_HW_SPEC_FLAG_ENABLE_LIFE_TIME_EXPIRY |\n\t\t\t\t MWL8K_SET_HW_SPEC_FLAG_GENERATE_CCMP_HDR);\n\tcmd->num_tx_desc_per_queue = cpu_to_le32(MWL8K_TX_DESCS);\n\tcmd->total_rxd = cpu_to_le32(MWL8K_RX_DESCS);\n\n\trc = mwl8k_post_cmd(hw, &cmd->header);\n\tkfree(cmd);\n\n\treturn rc;\n}\n\n \nstruct mwl8k_cmd_mac_multicast_adr {\n\tstruct mwl8k_cmd_pkt header;\n\t__le16 action;\n\t__le16 numaddr;\n\t__u8 addr[][ETH_ALEN];\n};\n\n#define MWL8K_ENABLE_RX_DIRECTED\t0x0001\n#define MWL8K_ENABLE_RX_MULTICAST\t0x0002\n#define MWL8K_ENABLE_RX_ALL_MULTICAST\t0x0004\n#define MWL8K_ENABLE_RX_BROADCAST\t0x0008\n\nstatic struct mwl8k_cmd_pkt *\n__mwl8k_cmd_mac_multicast_adr(struct ieee80211_hw *hw, int allmulti,\n\t\t\t      struct netdev_hw_addr_list *mc_list)\n{\n\tstruct mwl8k_priv *priv = hw->priv;\n\tstruct mwl8k_cmd_mac_multicast_adr *cmd;\n\tint size;\n\tint mc_count = 0;\n\n\tif (mc_list)\n\t\tmc_count = netdev_hw_addr_list_count(mc_list);\n\n\tif (allmulti || mc_count > priv->num_mcaddrs) {\n\t\tallmulti = 1;\n\t\tmc_count = 0;\n\t}\n\n\tsize = sizeof(*cmd) + mc_count * ETH_ALEN;\n\n\tcmd = kzalloc(size, GFP_ATOMIC);\n\tif (cmd == NULL)\n\t\treturn NULL;\n\n\tcmd->header.code = cpu_to_le16(MWL8K_CMD_MAC_MULTICAST_ADR);\n\tcmd->header.length = cpu_to_le16(size);\n\tcmd->action = cpu_to_le16(MWL8K_ENABLE_RX_DIRECTED |\n\t\t\t\t  MWL8K_ENABLE_RX_BROADCAST);\n\n\tif (allmulti) {\n\t\tcmd->action |= cpu_to_le16(MWL8K_ENABLE_RX_ALL_MULTICAST);\n\t} else if (mc_count) {\n\t\tstruct netdev_hw_addr *ha;\n\t\tint i = 0;\n\n\t\tcmd->action |= cpu_to_le16(MWL8K_ENABLE_RX_MULTICAST);\n\t\tcmd->numaddr = cpu_to_le16(mc_count);\n\t\tnetdev_hw_addr_list_for_each(ha, mc_list) {\n\t\t\tmemcpy(cmd->addr[i], ha->addr, ETH_ALEN);\n\t\t}\n\t}\n\n\treturn &cmd->header;\n}\n\n \nstruct mwl8k_cmd_get_stat {\n\tstruct mwl8k_cmd_pkt header;\n\t__le32 stats[64];\n} __packed;\n\n#define MWL8K_STAT_ACK_FAILURE\t9\n#define MWL8K_STAT_RTS_FAILURE\t12\n#define MWL8K_STAT_FCS_ERROR\t24\n#define MWL8K_STAT_RTS_SUCCESS\t11\n\nstatic int mwl8k_cmd_get_stat(struct ieee80211_hw *hw,\n\t\t\t      struct ieee80211_low_level_stats *stats)\n{\n\tstruct mwl8k_cmd_get_stat *cmd;\n\tint rc;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (cmd == NULL)\n\t\treturn -ENOMEM;\n\n\tcmd->header.code = cpu_to_le16(MWL8K_CMD_GET_STAT);\n\tcmd->header.length = cpu_to_le16(sizeof(*cmd));\n\n\trc = mwl8k_post_cmd(hw, &cmd->header);\n\tif (!rc) {\n\t\tstats->dot11ACKFailureCount =\n\t\t\tle32_to_cpu(cmd->stats[MWL8K_STAT_ACK_FAILURE]);\n\t\tstats->dot11RTSFailureCount =\n\t\t\tle32_to_cpu(cmd->stats[MWL8K_STAT_RTS_FAILURE]);\n\t\tstats->dot11FCSErrorCount =\n\t\t\tle32_to_cpu(cmd->stats[MWL8K_STAT_FCS_ERROR]);\n\t\tstats->dot11RTSSuccessCount =\n\t\t\tle32_to_cpu(cmd->stats[MWL8K_STAT_RTS_SUCCESS]);\n\t}\n\tkfree(cmd);\n\n\treturn rc;\n}\n\n \nstruct mwl8k_cmd_radio_control {\n\tstruct mwl8k_cmd_pkt header;\n\t__le16 action;\n\t__le16 control;\n\t__le16 radio_on;\n} __packed;\n\nstatic int\nmwl8k_cmd_radio_control(struct ieee80211_hw *hw, bool enable, bool force)\n{\n\tstruct mwl8k_priv *priv = hw->priv;\n\tstruct mwl8k_cmd_radio_control *cmd;\n\tint rc;\n\n\tif (enable == priv->radio_on && !force)\n\t\treturn 0;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (cmd == NULL)\n\t\treturn -ENOMEM;\n\n\tcmd->header.code = cpu_to_le16(MWL8K_CMD_RADIO_CONTROL);\n\tcmd->header.length = cpu_to_le16(sizeof(*cmd));\n\tcmd->action = cpu_to_le16(MWL8K_CMD_SET);\n\tcmd->control = cpu_to_le16(priv->radio_short_preamble ? 3 : 1);\n\tcmd->radio_on = cpu_to_le16(enable ? 0x0001 : 0x0000);\n\n\trc = mwl8k_post_cmd(hw, &cmd->header);\n\tkfree(cmd);\n\n\tif (!rc)\n\t\tpriv->radio_on = enable;\n\n\treturn rc;\n}\n\nstatic int mwl8k_cmd_radio_disable(struct ieee80211_hw *hw)\n{\n\treturn mwl8k_cmd_radio_control(hw, 0, 0);\n}\n\nstatic int mwl8k_cmd_radio_enable(struct ieee80211_hw *hw)\n{\n\treturn mwl8k_cmd_radio_control(hw, 1, 0);\n}\n\nstatic int\nmwl8k_set_radio_preamble(struct ieee80211_hw *hw, bool short_preamble)\n{\n\tstruct mwl8k_priv *priv = hw->priv;\n\n\tpriv->radio_short_preamble = short_preamble;\n\n\treturn mwl8k_cmd_radio_control(hw, 1, 1);\n}\n\n \n#define MWL8K_RF_TX_POWER_LEVEL_TOTAL\t8\n\nstruct mwl8k_cmd_rf_tx_power {\n\tstruct mwl8k_cmd_pkt header;\n\t__le16 action;\n\t__le16 support_level;\n\t__le16 current_level;\n\t__le16 reserved;\n\t__le16 power_level_list[MWL8K_RF_TX_POWER_LEVEL_TOTAL];\n} __packed;\n\nstatic int mwl8k_cmd_rf_tx_power(struct ieee80211_hw *hw, int dBm)\n{\n\tstruct mwl8k_cmd_rf_tx_power *cmd;\n\tint rc;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (cmd == NULL)\n\t\treturn -ENOMEM;\n\n\tcmd->header.code = cpu_to_le16(MWL8K_CMD_RF_TX_POWER);\n\tcmd->header.length = cpu_to_le16(sizeof(*cmd));\n\tcmd->action = cpu_to_le16(MWL8K_CMD_SET);\n\tcmd->support_level = cpu_to_le16(dBm);\n\n\trc = mwl8k_post_cmd(hw, &cmd->header);\n\tkfree(cmd);\n\n\treturn rc;\n}\n\n \n#define MWL8K_TX_POWER_LEVEL_TOTAL      12\n\nstruct mwl8k_cmd_tx_power {\n\tstruct mwl8k_cmd_pkt header;\n\t__le16 action;\n\t__le16 band;\n\t__le16 channel;\n\t__le16 bw;\n\t__le16 sub_ch;\n\t__le16 power_level_list[MWL8K_TX_POWER_LEVEL_TOTAL];\n} __packed;\n\nstatic int mwl8k_cmd_tx_power(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_conf *conf,\n\t\t\t\t     unsigned short pwr)\n{\n\tstruct ieee80211_channel *channel = conf->chandef.chan;\n\tenum nl80211_channel_type channel_type =\n\t\tcfg80211_get_chandef_type(&conf->chandef);\n\tstruct mwl8k_cmd_tx_power *cmd;\n\tint rc;\n\tint i;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (cmd == NULL)\n\t\treturn -ENOMEM;\n\n\tcmd->header.code = cpu_to_le16(MWL8K_CMD_TX_POWER);\n\tcmd->header.length = cpu_to_le16(sizeof(*cmd));\n\tcmd->action = cpu_to_le16(MWL8K_CMD_SET_LIST);\n\n\tif (channel->band == NL80211_BAND_2GHZ)\n\t\tcmd->band = cpu_to_le16(0x1);\n\telse if (channel->band == NL80211_BAND_5GHZ)\n\t\tcmd->band = cpu_to_le16(0x4);\n\n\tcmd->channel = cpu_to_le16(channel->hw_value);\n\n\tif (channel_type == NL80211_CHAN_NO_HT ||\n\t    channel_type == NL80211_CHAN_HT20) {\n\t\tcmd->bw = cpu_to_le16(0x2);\n\t} else {\n\t\tcmd->bw = cpu_to_le16(0x4);\n\t\tif (channel_type == NL80211_CHAN_HT40MINUS)\n\t\t\tcmd->sub_ch = cpu_to_le16(0x3);\n\t\telse if (channel_type == NL80211_CHAN_HT40PLUS)\n\t\t\tcmd->sub_ch = cpu_to_le16(0x1);\n\t}\n\n\tfor (i = 0; i < MWL8K_TX_POWER_LEVEL_TOTAL; i++)\n\t\tcmd->power_level_list[i] = cpu_to_le16(pwr);\n\n\trc = mwl8k_post_cmd(hw, &cmd->header);\n\tkfree(cmd);\n\n\treturn rc;\n}\n\n \nstruct mwl8k_cmd_rf_antenna {\n\tstruct mwl8k_cmd_pkt header;\n\t__le16 antenna;\n\t__le16 mode;\n} __packed;\n\n#define MWL8K_RF_ANTENNA_RX\t\t1\n#define MWL8K_RF_ANTENNA_TX\t\t2\n\nstatic int\nmwl8k_cmd_rf_antenna(struct ieee80211_hw *hw, int antenna, int mask)\n{\n\tstruct mwl8k_cmd_rf_antenna *cmd;\n\tint rc;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (cmd == NULL)\n\t\treturn -ENOMEM;\n\n\tcmd->header.code = cpu_to_le16(MWL8K_CMD_RF_ANTENNA);\n\tcmd->header.length = cpu_to_le16(sizeof(*cmd));\n\tcmd->antenna = cpu_to_le16(antenna);\n\tcmd->mode = cpu_to_le16(mask);\n\n\trc = mwl8k_post_cmd(hw, &cmd->header);\n\tkfree(cmd);\n\n\treturn rc;\n}\n\n \nstruct mwl8k_cmd_set_beacon {\n\tstruct mwl8k_cmd_pkt header;\n\t__le16 beacon_len;\n\t__u8 beacon[];\n};\n\nstatic int mwl8k_cmd_set_beacon(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif, u8 *beacon, int len)\n{\n\tstruct mwl8k_cmd_set_beacon *cmd;\n\tint rc;\n\n\tcmd = kzalloc(sizeof(*cmd) + len, GFP_KERNEL);\n\tif (cmd == NULL)\n\t\treturn -ENOMEM;\n\n\tcmd->header.code = cpu_to_le16(MWL8K_CMD_SET_BEACON);\n\tcmd->header.length = cpu_to_le16(sizeof(*cmd) + len);\n\tcmd->beacon_len = cpu_to_le16(len);\n\tmemcpy(cmd->beacon, beacon, len);\n\n\trc = mwl8k_post_pervif_cmd(hw, vif, &cmd->header);\n\tkfree(cmd);\n\n\treturn rc;\n}\n\n \nstruct mwl8k_cmd_set_pre_scan {\n\tstruct mwl8k_cmd_pkt header;\n} __packed;\n\nstatic int mwl8k_cmd_set_pre_scan(struct ieee80211_hw *hw)\n{\n\tstruct mwl8k_cmd_set_pre_scan *cmd;\n\tint rc;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (cmd == NULL)\n\t\treturn -ENOMEM;\n\n\tcmd->header.code = cpu_to_le16(MWL8K_CMD_SET_PRE_SCAN);\n\tcmd->header.length = cpu_to_le16(sizeof(*cmd));\n\n\trc = mwl8k_post_cmd(hw, &cmd->header);\n\tkfree(cmd);\n\n\treturn rc;\n}\n\n \nstruct mwl8k_cmd_bbp_reg_access {\n\tstruct mwl8k_cmd_pkt header;\n\t__le16 action;\n\t__le16 offset;\n\tu8 value;\n\tu8 rsrv[3];\n} __packed;\n\nstatic int\nmwl8k_cmd_bbp_reg_access(struct ieee80211_hw *hw,\n\t\t\t u16 action,\n\t\t\t u16 offset,\n\t\t\t u8 *value)\n{\n\tstruct mwl8k_cmd_bbp_reg_access *cmd;\n\tint rc;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (cmd == NULL)\n\t\treturn -ENOMEM;\n\n\tcmd->header.code = cpu_to_le16(MWL8K_CMD_BBP_REG_ACCESS);\n\tcmd->header.length = cpu_to_le16(sizeof(*cmd));\n\tcmd->action = cpu_to_le16(action);\n\tcmd->offset = cpu_to_le16(offset);\n\n\trc = mwl8k_post_cmd(hw, &cmd->header);\n\n\tif (!rc)\n\t\t*value = cmd->value;\n\telse\n\t\t*value = 0;\n\n\tkfree(cmd);\n\n\treturn rc;\n}\n\n \nstruct mwl8k_cmd_set_post_scan {\n\tstruct mwl8k_cmd_pkt header;\n\t__le32 isibss;\n\t__u8 bssid[ETH_ALEN];\n} __packed;\n\nstatic int\nmwl8k_cmd_set_post_scan(struct ieee80211_hw *hw, const __u8 *mac)\n{\n\tstruct mwl8k_cmd_set_post_scan *cmd;\n\tint rc;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (cmd == NULL)\n\t\treturn -ENOMEM;\n\n\tcmd->header.code = cpu_to_le16(MWL8K_CMD_SET_POST_SCAN);\n\tcmd->header.length = cpu_to_le16(sizeof(*cmd));\n\tcmd->isibss = 0;\n\tmemcpy(cmd->bssid, mac, ETH_ALEN);\n\n\trc = mwl8k_post_cmd(hw, &cmd->header);\n\tkfree(cmd);\n\n\treturn rc;\n}\n\nstatic int freq_to_idx(struct mwl8k_priv *priv, int freq)\n{\n\tstruct ieee80211_supported_band *sband;\n\tint band, ch, idx = 0;\n\n\tfor (band = NL80211_BAND_2GHZ; band < NUM_NL80211_BANDS; band++) {\n\t\tsband = priv->hw->wiphy->bands[band];\n\t\tif (!sband)\n\t\t\tcontinue;\n\n\t\tfor (ch = 0; ch < sband->n_channels; ch++, idx++)\n\t\t\tif (sband->channels[ch].center_freq == freq)\n\t\t\t\tgoto exit;\n\t}\n\nexit:\n\treturn idx;\n}\n\nstatic void mwl8k_update_survey(struct mwl8k_priv *priv,\n\t\t\t\tstruct ieee80211_channel *channel)\n{\n\tu32 cca_cnt, rx_rdy;\n\ts8 nf = 0, idx;\n\tstruct survey_info *survey;\n\n\tidx = freq_to_idx(priv, priv->acs_chan->center_freq);\n\tif (idx >= MWL8K_NUM_CHANS) {\n\t\twiphy_err(priv->hw->wiphy, \"Failed to update survey\\n\");\n\t\treturn;\n\t}\n\n\tsurvey = &priv->survey[idx];\n\n\tcca_cnt = ioread32(priv->regs + NOK_CCA_CNT_REG);\n\tcca_cnt /= 1000;  \n\tsurvey->time_busy = (u64) cca_cnt;\n\n\trx_rdy = ioread32(priv->regs + BBU_RXRDY_CNT_REG);\n\trx_rdy /= 1000;  \n\tsurvey->time_rx = (u64) rx_rdy;\n\n\tpriv->channel_time = jiffies - priv->channel_time;\n\tsurvey->time = jiffies_to_msecs(priv->channel_time);\n\n\tsurvey->channel = channel;\n\n\tmwl8k_cmd_bbp_reg_access(priv->hw, 0, BBU_AVG_NOISE_VAL, &nf);\n\n\t \n\tsurvey->noise = nf * -1;\n\n\tsurvey->filled = SURVEY_INFO_NOISE_DBM |\n\t\t\t SURVEY_INFO_TIME |\n\t\t\t SURVEY_INFO_TIME_BUSY |\n\t\t\t SURVEY_INFO_TIME_RX;\n}\n\n \nstruct mwl8k_cmd_set_rf_channel {\n\tstruct mwl8k_cmd_pkt header;\n\t__le16 action;\n\t__u8 current_channel;\n\t__le32 channel_flags;\n} __packed;\n\nstatic int mwl8k_cmd_set_rf_channel(struct ieee80211_hw *hw,\n\t\t\t\t    struct ieee80211_conf *conf)\n{\n\tstruct ieee80211_channel *channel = conf->chandef.chan;\n\tenum nl80211_channel_type channel_type =\n\t\tcfg80211_get_chandef_type(&conf->chandef);\n\tstruct mwl8k_cmd_set_rf_channel *cmd;\n\tstruct mwl8k_priv *priv = hw->priv;\n\tint rc;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (cmd == NULL)\n\t\treturn -ENOMEM;\n\n\tcmd->header.code = cpu_to_le16(MWL8K_CMD_SET_RF_CHANNEL);\n\tcmd->header.length = cpu_to_le16(sizeof(*cmd));\n\tcmd->action = cpu_to_le16(MWL8K_CMD_SET);\n\tcmd->current_channel = channel->hw_value;\n\n\tif (channel->band == NL80211_BAND_2GHZ)\n\t\tcmd->channel_flags |= cpu_to_le32(0x00000001);\n\telse if (channel->band == NL80211_BAND_5GHZ)\n\t\tcmd->channel_flags |= cpu_to_le32(0x00000004);\n\n\tif (!priv->sw_scan_start) {\n\t\tif (channel_type == NL80211_CHAN_NO_HT ||\n\t\t    channel_type == NL80211_CHAN_HT20)\n\t\t\tcmd->channel_flags |= cpu_to_le32(0x00000080);\n\t\telse if (channel_type == NL80211_CHAN_HT40MINUS)\n\t\t\tcmd->channel_flags |= cpu_to_le32(0x000001900);\n\t\telse if (channel_type == NL80211_CHAN_HT40PLUS)\n\t\t\tcmd->channel_flags |= cpu_to_le32(0x000000900);\n\t} else {\n\t\tcmd->channel_flags |= cpu_to_le32(0x00000080);\n\t}\n\n\tif (priv->sw_scan_start) {\n\t\t \n\t\tif (priv->channel_time != 0)\n\t\t\tmwl8k_update_survey(priv, priv->acs_chan);\n\n\t\tpriv->channel_time = jiffies;\n\t\tpriv->acs_chan =  channel;\n\t}\n\n\trc = mwl8k_post_cmd(hw, &cmd->header);\n\tkfree(cmd);\n\n\treturn rc;\n}\n\n \n#define MWL8K_FRAME_PROT_DISABLED\t\t\t0x00\n#define MWL8K_FRAME_PROT_11G\t\t\t\t0x07\n#define MWL8K_FRAME_PROT_11N_HT_40MHZ_ONLY\t\t0x02\n#define MWL8K_FRAME_PROT_11N_HT_ALL\t\t\t0x06\n\nstruct mwl8k_cmd_update_set_aid {\n\tstruct\tmwl8k_cmd_pkt header;\n\t__le16\taid;\n\n\t  \n\t__u8\tbssid[ETH_ALEN];\n\t__le16\tprotection_mode;\n\t__u8\tsupp_rates[14];\n} __packed;\n\nstatic void legacy_rate_mask_to_array(u8 *rates, u32 mask)\n{\n\tint i;\n\tint j;\n\n\t \n\tmask &= 0x1fef;\n\n\tfor (i = 0, j = 0; i < 13; i++) {\n\t\tif (mask & (1 << i))\n\t\t\trates[j++] = mwl8k_rates_24[i].hw_value;\n\t}\n}\n\nstatic int\nmwl8k_cmd_set_aid(struct ieee80211_hw *hw,\n\t\t  struct ieee80211_vif *vif, u32 legacy_rate_mask)\n{\n\tstruct mwl8k_cmd_update_set_aid *cmd;\n\tu16 prot_mode;\n\tint rc;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (cmd == NULL)\n\t\treturn -ENOMEM;\n\n\tcmd->header.code = cpu_to_le16(MWL8K_CMD_SET_AID);\n\tcmd->header.length = cpu_to_le16(sizeof(*cmd));\n\tcmd->aid = cpu_to_le16(vif->cfg.aid);\n\tmemcpy(cmd->bssid, vif->bss_conf.bssid, ETH_ALEN);\n\n\tif (vif->bss_conf.use_cts_prot) {\n\t\tprot_mode = MWL8K_FRAME_PROT_11G;\n\t} else {\n\t\tswitch (vif->bss_conf.ht_operation_mode &\n\t\t\tIEEE80211_HT_OP_MODE_PROTECTION) {\n\t\tcase IEEE80211_HT_OP_MODE_PROTECTION_20MHZ:\n\t\t\tprot_mode = MWL8K_FRAME_PROT_11N_HT_40MHZ_ONLY;\n\t\t\tbreak;\n\t\tcase IEEE80211_HT_OP_MODE_PROTECTION_NONHT_MIXED:\n\t\t\tprot_mode = MWL8K_FRAME_PROT_11N_HT_ALL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprot_mode = MWL8K_FRAME_PROT_DISABLED;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcmd->protection_mode = cpu_to_le16(prot_mode);\n\n\tlegacy_rate_mask_to_array(cmd->supp_rates, legacy_rate_mask);\n\n\trc = mwl8k_post_cmd(hw, &cmd->header);\n\tkfree(cmd);\n\n\treturn rc;\n}\n\n \nstruct mwl8k_cmd_set_rate {\n\tstruct\tmwl8k_cmd_pkt header;\n\t__u8\tlegacy_rates[14];\n\n\t \n\t__u8\tmcs_set[16];\n\t__u8\treserved[16];\n} __packed;\n\nstatic int\nmwl8k_cmd_set_rate(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t   u32 legacy_rate_mask, u8 *mcs_rates)\n{\n\tstruct mwl8k_cmd_set_rate *cmd;\n\tint rc;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (cmd == NULL)\n\t\treturn -ENOMEM;\n\n\tcmd->header.code = cpu_to_le16(MWL8K_CMD_SET_RATE);\n\tcmd->header.length = cpu_to_le16(sizeof(*cmd));\n\tlegacy_rate_mask_to_array(cmd->legacy_rates, legacy_rate_mask);\n\tmemcpy(cmd->mcs_set, mcs_rates, 16);\n\n\trc = mwl8k_post_cmd(hw, &cmd->header);\n\tkfree(cmd);\n\n\treturn rc;\n}\n\n \n#define MWL8K_FJ_BEACON_MAXLEN\t128\n\nstruct mwl8k_cmd_finalize_join {\n\tstruct mwl8k_cmd_pkt header;\n\t__le32 sleep_interval;\t \n\t__u8 beacon_data[MWL8K_FJ_BEACON_MAXLEN];\n} __packed;\n\nstatic int mwl8k_cmd_finalize_join(struct ieee80211_hw *hw, void *frame,\n\t\t\t\t   int framelen, int dtim)\n{\n\tstruct mwl8k_cmd_finalize_join *cmd;\n\tstruct ieee80211_mgmt *payload = frame;\n\tint payload_len;\n\tint rc;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (cmd == NULL)\n\t\treturn -ENOMEM;\n\n\tcmd->header.code = cpu_to_le16(MWL8K_CMD_SET_FINALIZE_JOIN);\n\tcmd->header.length = cpu_to_le16(sizeof(*cmd));\n\tcmd->sleep_interval = cpu_to_le32(dtim ? dtim : 1);\n\n\tpayload_len = framelen - ieee80211_hdrlen(payload->frame_control);\n\tif (payload_len < 0)\n\t\tpayload_len = 0;\n\telse if (payload_len > MWL8K_FJ_BEACON_MAXLEN)\n\t\tpayload_len = MWL8K_FJ_BEACON_MAXLEN;\n\n\tmemcpy(cmd->beacon_data, &payload->u.beacon, payload_len);\n\n\trc = mwl8k_post_cmd(hw, &cmd->header);\n\tkfree(cmd);\n\n\treturn rc;\n}\n\n \nstruct mwl8k_cmd_set_rts_threshold {\n\tstruct mwl8k_cmd_pkt header;\n\t__le16 action;\n\t__le16 threshold;\n} __packed;\n\nstatic int\nmwl8k_cmd_set_rts_threshold(struct ieee80211_hw *hw, int rts_thresh)\n{\n\tstruct mwl8k_cmd_set_rts_threshold *cmd;\n\tint rc;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (cmd == NULL)\n\t\treturn -ENOMEM;\n\n\tcmd->header.code = cpu_to_le16(MWL8K_CMD_RTS_THRESHOLD);\n\tcmd->header.length = cpu_to_le16(sizeof(*cmd));\n\tcmd->action = cpu_to_le16(MWL8K_CMD_SET);\n\tcmd->threshold = cpu_to_le16(rts_thresh);\n\n\trc = mwl8k_post_cmd(hw, &cmd->header);\n\tkfree(cmd);\n\n\treturn rc;\n}\n\n \nstruct mwl8k_cmd_set_slot {\n\tstruct mwl8k_cmd_pkt header;\n\t__le16 action;\n\t__u8 short_slot;\n} __packed;\n\nstatic int mwl8k_cmd_set_slot(struct ieee80211_hw *hw, bool short_slot_time)\n{\n\tstruct mwl8k_cmd_set_slot *cmd;\n\tint rc;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (cmd == NULL)\n\t\treturn -ENOMEM;\n\n\tcmd->header.code = cpu_to_le16(MWL8K_CMD_SET_SLOT);\n\tcmd->header.length = cpu_to_le16(sizeof(*cmd));\n\tcmd->action = cpu_to_le16(MWL8K_CMD_SET);\n\tcmd->short_slot = short_slot_time;\n\n\trc = mwl8k_post_cmd(hw, &cmd->header);\n\tkfree(cmd);\n\n\treturn rc;\n}\n\n \nstruct mwl8k_cmd_set_edca_params {\n\tstruct mwl8k_cmd_pkt header;\n\n\t \n\t__le16 action;\n\n\t \n\t__le16 txop;\n\n\tunion {\n\t\tstruct {\n\t\t\t \n\t\t\t__le32 log_cw_max;\n\n\t\t\t \n\t\t\t__le32 log_cw_min;\n\n\t\t\t \n\t\t\t__u8 aifs;\n\n\t\t\t \n\t\t\t__u8 txq;\n\t\t} ap;\n\t\tstruct {\n\t\t\t \n\t\t\t__u8 log_cw_max;\n\n\t\t\t \n\t\t\t__u8 log_cw_min;\n\n\t\t\t \n\t\t\t__u8 aifs;\n\n\t\t\t \n\t\t\t__u8 txq;\n\t\t} sta;\n\t};\n} __packed;\n\n#define MWL8K_SET_EDCA_CW\t0x01\n#define MWL8K_SET_EDCA_TXOP\t0x02\n#define MWL8K_SET_EDCA_AIFS\t0x04\n\n#define MWL8K_SET_EDCA_ALL\t(MWL8K_SET_EDCA_CW | \\\n\t\t\t\t MWL8K_SET_EDCA_TXOP | \\\n\t\t\t\t MWL8K_SET_EDCA_AIFS)\n\nstatic int\nmwl8k_cmd_set_edca_params(struct ieee80211_hw *hw, __u8 qnum,\n\t\t\t  __u16 cw_min, __u16 cw_max,\n\t\t\t  __u8 aifs, __u16 txop)\n{\n\tstruct mwl8k_priv *priv = hw->priv;\n\tstruct mwl8k_cmd_set_edca_params *cmd;\n\tint rc;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (cmd == NULL)\n\t\treturn -ENOMEM;\n\n\tcmd->header.code = cpu_to_le16(MWL8K_CMD_SET_EDCA_PARAMS);\n\tcmd->header.length = cpu_to_le16(sizeof(*cmd));\n\tcmd->action = cpu_to_le16(MWL8K_SET_EDCA_ALL);\n\tcmd->txop = cpu_to_le16(txop);\n\tif (priv->ap_fw) {\n\t\tcmd->ap.log_cw_max = cpu_to_le32(ilog2(cw_max + 1));\n\t\tcmd->ap.log_cw_min = cpu_to_le32(ilog2(cw_min + 1));\n\t\tcmd->ap.aifs = aifs;\n\t\tcmd->ap.txq = qnum;\n\t} else {\n\t\tcmd->sta.log_cw_max = (u8)ilog2(cw_max + 1);\n\t\tcmd->sta.log_cw_min = (u8)ilog2(cw_min + 1);\n\t\tcmd->sta.aifs = aifs;\n\t\tcmd->sta.txq = qnum;\n\t}\n\n\trc = mwl8k_post_cmd(hw, &cmd->header);\n\tkfree(cmd);\n\n\treturn rc;\n}\n\n \nstruct mwl8k_cmd_set_wmm_mode {\n\tstruct mwl8k_cmd_pkt header;\n\t__le16 action;\n} __packed;\n\nstatic int mwl8k_cmd_set_wmm_mode(struct ieee80211_hw *hw, bool enable)\n{\n\tstruct mwl8k_priv *priv = hw->priv;\n\tstruct mwl8k_cmd_set_wmm_mode *cmd;\n\tint rc;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (cmd == NULL)\n\t\treturn -ENOMEM;\n\n\tcmd->header.code = cpu_to_le16(MWL8K_CMD_SET_WMM_MODE);\n\tcmd->header.length = cpu_to_le16(sizeof(*cmd));\n\tcmd->action = cpu_to_le16(!!enable);\n\n\trc = mwl8k_post_cmd(hw, &cmd->header);\n\tkfree(cmd);\n\n\tif (!rc)\n\t\tpriv->wmm_enabled = enable;\n\n\treturn rc;\n}\n\n \nstruct mwl8k_cmd_mimo_config {\n\tstruct mwl8k_cmd_pkt header;\n\t__le32 action;\n\t__u8 rx_antenna_map;\n\t__u8 tx_antenna_map;\n} __packed;\n\nstatic int mwl8k_cmd_mimo_config(struct ieee80211_hw *hw, __u8 rx, __u8 tx)\n{\n\tstruct mwl8k_cmd_mimo_config *cmd;\n\tint rc;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (cmd == NULL)\n\t\treturn -ENOMEM;\n\n\tcmd->header.code = cpu_to_le16(MWL8K_CMD_MIMO_CONFIG);\n\tcmd->header.length = cpu_to_le16(sizeof(*cmd));\n\tcmd->action = cpu_to_le32((u32)MWL8K_CMD_SET);\n\tcmd->rx_antenna_map = rx;\n\tcmd->tx_antenna_map = tx;\n\n\trc = mwl8k_post_cmd(hw, &cmd->header);\n\tkfree(cmd);\n\n\treturn rc;\n}\n\n \nstruct mwl8k_cmd_use_fixed_rate_sta {\n\tstruct mwl8k_cmd_pkt header;\n\t__le32 action;\n\t__le32 allow_rate_drop;\n\t__le32 num_rates;\n\tstruct {\n\t\t__le32 is_ht_rate;\n\t\t__le32 enable_retry;\n\t\t__le32 rate;\n\t\t__le32 retry_count;\n\t} rate_entry[8];\n\t__le32 rate_type;\n\t__le32 reserved1;\n\t__le32 reserved2;\n} __packed;\n\n#define MWL8K_USE_AUTO_RATE\t0x0002\n#define MWL8K_UCAST_RATE\t0\n\nstatic int mwl8k_cmd_use_fixed_rate_sta(struct ieee80211_hw *hw)\n{\n\tstruct mwl8k_cmd_use_fixed_rate_sta *cmd;\n\tint rc;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (cmd == NULL)\n\t\treturn -ENOMEM;\n\n\tcmd->header.code = cpu_to_le16(MWL8K_CMD_USE_FIXED_RATE);\n\tcmd->header.length = cpu_to_le16(sizeof(*cmd));\n\tcmd->action = cpu_to_le32(MWL8K_USE_AUTO_RATE);\n\tcmd->rate_type = cpu_to_le32(MWL8K_UCAST_RATE);\n\n\trc = mwl8k_post_cmd(hw, &cmd->header);\n\tkfree(cmd);\n\n\treturn rc;\n}\n\n \nstruct mwl8k_cmd_use_fixed_rate_ap {\n\tstruct mwl8k_cmd_pkt header;\n\t__le32 action;\n\t__le32 allow_rate_drop;\n\t__le32 num_rates;\n\tstruct mwl8k_rate_entry_ap {\n\t\t__le32 is_ht_rate;\n\t\t__le32 enable_retry;\n\t\t__le32 rate;\n\t\t__le32 retry_count;\n\t} rate_entry[4];\n\tu8 multicast_rate;\n\tu8 multicast_rate_type;\n\tu8 management_rate;\n} __packed;\n\nstatic int\nmwl8k_cmd_use_fixed_rate_ap(struct ieee80211_hw *hw, int mcast, int mgmt)\n{\n\tstruct mwl8k_cmd_use_fixed_rate_ap *cmd;\n\tint rc;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (cmd == NULL)\n\t\treturn -ENOMEM;\n\n\tcmd->header.code = cpu_to_le16(MWL8K_CMD_USE_FIXED_RATE);\n\tcmd->header.length = cpu_to_le16(sizeof(*cmd));\n\tcmd->action = cpu_to_le32(MWL8K_USE_AUTO_RATE);\n\tcmd->multicast_rate = mcast;\n\tcmd->management_rate = mgmt;\n\n\trc = mwl8k_post_cmd(hw, &cmd->header);\n\tkfree(cmd);\n\n\treturn rc;\n}\n\n \nstruct mwl8k_cmd_enable_sniffer {\n\tstruct mwl8k_cmd_pkt header;\n\t__le32 action;\n} __packed;\n\nstatic int mwl8k_cmd_enable_sniffer(struct ieee80211_hw *hw, bool enable)\n{\n\tstruct mwl8k_cmd_enable_sniffer *cmd;\n\tint rc;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (cmd == NULL)\n\t\treturn -ENOMEM;\n\n\tcmd->header.code = cpu_to_le16(MWL8K_CMD_ENABLE_SNIFFER);\n\tcmd->header.length = cpu_to_le16(sizeof(*cmd));\n\tcmd->action = cpu_to_le32(!!enable);\n\n\trc = mwl8k_post_cmd(hw, &cmd->header);\n\tkfree(cmd);\n\n\treturn rc;\n}\n\nstruct mwl8k_cmd_update_mac_addr {\n\tstruct mwl8k_cmd_pkt header;\n\tunion {\n\t\tstruct {\n\t\t\t__le16 mac_type;\n\t\t\t__u8 mac_addr[ETH_ALEN];\n\t\t} mbss;\n\t\t__u8 mac_addr[ETH_ALEN];\n\t};\n} __packed;\n\n#define MWL8K_MAC_TYPE_PRIMARY_CLIENT\t\t0\n#define MWL8K_MAC_TYPE_SECONDARY_CLIENT\t\t1\n#define MWL8K_MAC_TYPE_PRIMARY_AP\t\t2\n#define MWL8K_MAC_TYPE_SECONDARY_AP\t\t3\n\nstatic int mwl8k_cmd_update_mac_addr(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif, u8 *mac, bool set)\n{\n\tstruct mwl8k_priv *priv = hw->priv;\n\tstruct mwl8k_vif *mwl8k_vif = MWL8K_VIF(vif);\n\tstruct mwl8k_cmd_update_mac_addr *cmd;\n\tint mac_type;\n\tint rc;\n\n\tmac_type = MWL8K_MAC_TYPE_PRIMARY_AP;\n\tif (vif != NULL && vif->type == NL80211_IFTYPE_STATION) {\n\t\tif (mwl8k_vif->macid + 1 == ffs(priv->sta_macids_supported))\n\t\t\tif (priv->ap_fw)\n\t\t\t\tmac_type = MWL8K_MAC_TYPE_SECONDARY_CLIENT;\n\t\t\telse\n\t\t\t\tmac_type = MWL8K_MAC_TYPE_PRIMARY_CLIENT;\n\t\telse\n\t\t\tmac_type = MWL8K_MAC_TYPE_SECONDARY_CLIENT;\n\t} else if (vif != NULL && vif->type == NL80211_IFTYPE_AP) {\n\t\tif (mwl8k_vif->macid + 1 == ffs(priv->ap_macids_supported))\n\t\t\tmac_type = MWL8K_MAC_TYPE_PRIMARY_AP;\n\t\telse\n\t\t\tmac_type = MWL8K_MAC_TYPE_SECONDARY_AP;\n\t}\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (cmd == NULL)\n\t\treturn -ENOMEM;\n\n\tif (set)\n\t\tcmd->header.code = cpu_to_le16(MWL8K_CMD_SET_MAC_ADDR);\n\telse\n\t\tcmd->header.code = cpu_to_le16(MWL8K_CMD_DEL_MAC_ADDR);\n\n\tcmd->header.length = cpu_to_le16(sizeof(*cmd));\n\tif (priv->ap_fw) {\n\t\tcmd->mbss.mac_type = cpu_to_le16(mac_type);\n\t\tmemcpy(cmd->mbss.mac_addr, mac, ETH_ALEN);\n\t} else {\n\t\tmemcpy(cmd->mac_addr, mac, ETH_ALEN);\n\t}\n\n\trc = mwl8k_post_pervif_cmd(hw, vif, &cmd->header);\n\tkfree(cmd);\n\n\treturn rc;\n}\n\n \nstatic inline int mwl8k_cmd_set_mac_addr(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif, u8 *mac)\n{\n\treturn mwl8k_cmd_update_mac_addr(hw, vif, mac, true);\n}\n\n \nstatic inline int mwl8k_cmd_del_mac_addr(struct ieee80211_hw *hw,\n\t\t\t\t  struct ieee80211_vif *vif, u8 *mac)\n{\n\treturn mwl8k_cmd_update_mac_addr(hw, vif, mac, false);\n}\n\n \nstruct mwl8k_cmd_set_rate_adapt_mode {\n\tstruct mwl8k_cmd_pkt header;\n\t__le16 action;\n\t__le16 mode;\n} __packed;\n\nstatic int mwl8k_cmd_set_rateadapt_mode(struct ieee80211_hw *hw, __u16 mode)\n{\n\tstruct mwl8k_cmd_set_rate_adapt_mode *cmd;\n\tint rc;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (cmd == NULL)\n\t\treturn -ENOMEM;\n\n\tcmd->header.code = cpu_to_le16(MWL8K_CMD_SET_RATEADAPT_MODE);\n\tcmd->header.length = cpu_to_le16(sizeof(*cmd));\n\tcmd->action = cpu_to_le16(MWL8K_CMD_SET);\n\tcmd->mode = cpu_to_le16(mode);\n\n\trc = mwl8k_post_cmd(hw, &cmd->header);\n\tkfree(cmd);\n\n\treturn rc;\n}\n\n \nstruct mwl8k_cmd_get_watchdog_bitmap {\n\tstruct mwl8k_cmd_pkt header;\n\tu8\tbitmap;\n} __packed;\n\nstatic int mwl8k_cmd_get_watchdog_bitmap(struct ieee80211_hw *hw, u8 *bitmap)\n{\n\tstruct mwl8k_cmd_get_watchdog_bitmap *cmd;\n\tint rc;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (cmd == NULL)\n\t\treturn -ENOMEM;\n\n\tcmd->header.code = cpu_to_le16(MWL8K_CMD_GET_WATCHDOG_BITMAP);\n\tcmd->header.length = cpu_to_le16(sizeof(*cmd));\n\n\trc = mwl8k_post_cmd(hw, &cmd->header);\n\tif (!rc)\n\t\t*bitmap = cmd->bitmap;\n\n\tkfree(cmd);\n\n\treturn rc;\n}\n\n#define MWL8K_WMM_QUEUE_NUMBER\t3\n\nstatic void mwl8k_destroy_ba(struct ieee80211_hw *hw,\n\t\t\t     u8 idx);\n\nstatic void mwl8k_watchdog_ba_events(struct work_struct *work)\n{\n\tint rc;\n\tu8 bitmap = 0, stream_index;\n\tstruct mwl8k_ampdu_stream *streams;\n\tstruct mwl8k_priv *priv =\n\t\tcontainer_of(work, struct mwl8k_priv, watchdog_ba_handle);\n\tstruct ieee80211_hw *hw = priv->hw;\n\tint i;\n\tu32 status = 0;\n\n\tmwl8k_fw_lock(hw);\n\n\trc = mwl8k_cmd_get_watchdog_bitmap(priv->hw, &bitmap);\n\tif (rc)\n\t\tgoto done;\n\n\tspin_lock(&priv->stream_lock);\n\n\t \n\tfor (i = 0; i < TOTAL_HW_TX_QUEUES; i++) {\n\t\tif (bitmap & (1 << i)) {\n\t\t\tstream_index = (i + MWL8K_WMM_QUEUE_NUMBER) %\n\t\t\t\t       TOTAL_HW_TX_QUEUES;\n\t\t\tstreams = &priv->ampdu[stream_index];\n\t\t\tif (streams->state == AMPDU_STREAM_ACTIVE) {\n\t\t\t\tieee80211_stop_tx_ba_session(streams->sta,\n\t\t\t\t\t\t\t     streams->tid);\n\t\t\t\tspin_unlock(&priv->stream_lock);\n\t\t\t\tmwl8k_destroy_ba(hw, stream_index);\n\t\t\t\tspin_lock(&priv->stream_lock);\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_unlock(&priv->stream_lock);\ndone:\n\tatomic_dec(&priv->watchdog_event_pending);\n\tstatus = ioread32(priv->regs + MWL8K_HIU_A2H_INTERRUPT_STATUS_MASK);\n\tiowrite32((status | MWL8K_A2H_INT_BA_WATCHDOG),\n\t\t  priv->regs + MWL8K_HIU_A2H_INTERRUPT_STATUS_MASK);\n\tmwl8k_fw_unlock(hw);\n\treturn;\n}\n\n\n \nstruct mwl8k_cmd_bss_start {\n\tstruct mwl8k_cmd_pkt header;\n\t__le32 enable;\n} __packed;\n\nstatic int mwl8k_cmd_bss_start(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif, int enable)\n{\n\tstruct mwl8k_cmd_bss_start *cmd;\n\tstruct mwl8k_vif *mwl8k_vif = MWL8K_VIF(vif);\n\tstruct mwl8k_priv *priv = hw->priv;\n\tint rc;\n\n\tif (enable && (priv->running_bsses & (1 << mwl8k_vif->macid)))\n\t\treturn 0;\n\n\tif (!enable && !(priv->running_bsses & (1 << mwl8k_vif->macid)))\n\t\treturn 0;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (cmd == NULL)\n\t\treturn -ENOMEM;\n\n\tcmd->header.code = cpu_to_le16(MWL8K_CMD_BSS_START);\n\tcmd->header.length = cpu_to_le16(sizeof(*cmd));\n\tcmd->enable = cpu_to_le32(enable);\n\n\trc = mwl8k_post_pervif_cmd(hw, vif, &cmd->header);\n\tkfree(cmd);\n\n\tif (!rc) {\n\t\tif (enable)\n\t\t\tpriv->running_bsses |= (1 << mwl8k_vif->macid);\n\t\telse\n\t\t\tpriv->running_bsses &= ~(1 << mwl8k_vif->macid);\n\t}\n\treturn rc;\n}\n\nstatic void mwl8k_enable_bsses(struct ieee80211_hw *hw, bool enable, u32 bitmap)\n{\n\tstruct mwl8k_priv *priv = hw->priv;\n\tstruct mwl8k_vif *mwl8k_vif, *tmp_vif;\n\tstruct ieee80211_vif *vif;\n\n\tlist_for_each_entry_safe(mwl8k_vif, tmp_vif, &priv->vif_list, list) {\n\t\tvif = mwl8k_vif->vif;\n\n\t\tif (!(bitmap & (1 << mwl8k_vif->macid)))\n\t\t\tcontinue;\n\n\t\tif (vif->type == NL80211_IFTYPE_AP)\n\t\t\tmwl8k_cmd_bss_start(hw, vif, enable);\n\t}\n}\n \n\n \n#define BASTREAM_FLAG_DIRECTION_UPSTREAM\t0x00\n#define BASTREAM_FLAG_IMMEDIATE_TYPE\t\t0x01\n\nenum ba_stream_action_type {\n\tMWL8K_BA_CREATE,\n\tMWL8K_BA_UPDATE,\n\tMWL8K_BA_DESTROY,\n\tMWL8K_BA_FLUSH,\n\tMWL8K_BA_CHECK,\n};\n\n\nstruct mwl8k_create_ba_stream {\n\t__le32\tflags;\n\t__le32\tidle_thrs;\n\t__le32\tbar_thrs;\n\t__le32\twindow_size;\n\tu8\tpeer_mac_addr[6];\n\tu8\tdialog_token;\n\tu8\ttid;\n\tu8\tqueue_id;\n\tu8\tparam_info;\n\t__le32\tba_context;\n\tu8\treset_seq_no_flag;\n\t__le16\tcurr_seq_no;\n\tu8\tsta_src_mac_addr[6];\n} __packed;\n\nstruct mwl8k_destroy_ba_stream {\n\t__le32\tflags;\n\t__le32\tba_context;\n} __packed;\n\nstruct mwl8k_cmd_bastream {\n\tstruct mwl8k_cmd_pkt\theader;\n\t__le32\taction;\n\tunion {\n\t\tstruct mwl8k_create_ba_stream\tcreate_params;\n\t\tstruct mwl8k_destroy_ba_stream\tdestroy_params;\n\t};\n} __packed;\n\nstatic int\nmwl8k_check_ba(struct ieee80211_hw *hw, struct mwl8k_ampdu_stream *stream,\n\t       struct ieee80211_vif *vif)\n{\n\tstruct mwl8k_cmd_bastream *cmd;\n\tint rc;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (cmd == NULL)\n\t\treturn -ENOMEM;\n\n\tcmd->header.code = cpu_to_le16(MWL8K_CMD_BASTREAM);\n\tcmd->header.length = cpu_to_le16(sizeof(*cmd));\n\n\tcmd->action = cpu_to_le32(MWL8K_BA_CHECK);\n\n\tcmd->create_params.queue_id = stream->idx;\n\tmemcpy(&cmd->create_params.peer_mac_addr[0], stream->sta->addr,\n\t       ETH_ALEN);\n\tcmd->create_params.tid = stream->tid;\n\n\tcmd->create_params.flags =\n\t\tcpu_to_le32(BASTREAM_FLAG_IMMEDIATE_TYPE) |\n\t\tcpu_to_le32(BASTREAM_FLAG_DIRECTION_UPSTREAM);\n\n\trc = mwl8k_post_pervif_cmd(hw, vif, &cmd->header);\n\n\tkfree(cmd);\n\n\treturn rc;\n}\n\nstatic int\nmwl8k_create_ba(struct ieee80211_hw *hw, struct mwl8k_ampdu_stream *stream,\n\t\tu8 buf_size, struct ieee80211_vif *vif)\n{\n\tstruct mwl8k_cmd_bastream *cmd;\n\tint rc;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (cmd == NULL)\n\t\treturn -ENOMEM;\n\n\n\tcmd->header.code = cpu_to_le16(MWL8K_CMD_BASTREAM);\n\tcmd->header.length = cpu_to_le16(sizeof(*cmd));\n\n\tcmd->action = cpu_to_le32(MWL8K_BA_CREATE);\n\n\tcmd->create_params.bar_thrs = cpu_to_le32((u32)buf_size);\n\tcmd->create_params.window_size = cpu_to_le32((u32)buf_size);\n\tcmd->create_params.queue_id = stream->idx;\n\n\tmemcpy(cmd->create_params.peer_mac_addr, stream->sta->addr, ETH_ALEN);\n\tcmd->create_params.tid = stream->tid;\n\tcmd->create_params.curr_seq_no = cpu_to_le16(0);\n\tcmd->create_params.reset_seq_no_flag = 1;\n\n\tcmd->create_params.param_info =\n\t\t(stream->sta->deflink.ht_cap.ampdu_factor &\n\t\t IEEE80211_HT_AMPDU_PARM_FACTOR) |\n\t\t((stream->sta->deflink.ht_cap.ampdu_density << 2) &\n\t\t IEEE80211_HT_AMPDU_PARM_DENSITY);\n\n\tcmd->create_params.flags =\n\t\tcpu_to_le32(BASTREAM_FLAG_IMMEDIATE_TYPE |\n\t\t\t\t\tBASTREAM_FLAG_DIRECTION_UPSTREAM);\n\n\trc = mwl8k_post_pervif_cmd(hw, vif, &cmd->header);\n\n\twiphy_debug(hw->wiphy, \"Created a BA stream for %pM : tid %d\\n\",\n\t\tstream->sta->addr, stream->tid);\n\tkfree(cmd);\n\n\treturn rc;\n}\n\nstatic void mwl8k_destroy_ba(struct ieee80211_hw *hw,\n\t\t\t     u8 idx)\n{\n\tstruct mwl8k_cmd_bastream *cmd;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (cmd == NULL)\n\t\treturn;\n\n\tcmd->header.code = cpu_to_le16(MWL8K_CMD_BASTREAM);\n\tcmd->header.length = cpu_to_le16(sizeof(*cmd));\n\tcmd->action = cpu_to_le32(MWL8K_BA_DESTROY);\n\n\tcmd->destroy_params.ba_context = cpu_to_le32(idx);\n\tmwl8k_post_cmd(hw, &cmd->header);\n\n\twiphy_debug(hw->wiphy, \"Deleted BA stream index %d\\n\", idx);\n\n\tkfree(cmd);\n}\n\n \nstruct mwl8k_cmd_set_new_stn {\n\tstruct mwl8k_cmd_pkt header;\n\t__le16 aid;\n\t__u8 mac_addr[6];\n\t__le16 stn_id;\n\t__le16 action;\n\t__le16 rsvd;\n\t__le32 legacy_rates;\n\t__u8 ht_rates[4];\n\t__le16 cap_info;\n\t__le16 ht_capabilities_info;\n\t__u8 mac_ht_param_info;\n\t__u8 rev;\n\t__u8 control_channel;\n\t__u8 add_channel;\n\t__le16 op_mode;\n\t__le16 stbc;\n\t__u8 add_qos_info;\n\t__u8 is_qos_sta;\n\t__le32 fw_sta_ptr;\n} __packed;\n\n#define MWL8K_STA_ACTION_ADD\t\t0\n#define MWL8K_STA_ACTION_REMOVE\t\t2\n\nstatic int mwl8k_cmd_set_new_stn_add(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif,\n\t\t\t\t     struct ieee80211_sta *sta)\n{\n\tstruct mwl8k_cmd_set_new_stn *cmd;\n\tu32 rates;\n\tint rc;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (cmd == NULL)\n\t\treturn -ENOMEM;\n\n\tcmd->header.code = cpu_to_le16(MWL8K_CMD_SET_NEW_STN);\n\tcmd->header.length = cpu_to_le16(sizeof(*cmd));\n\tcmd->aid = cpu_to_le16(sta->aid);\n\tmemcpy(cmd->mac_addr, sta->addr, ETH_ALEN);\n\tcmd->stn_id = cpu_to_le16(sta->aid);\n\tcmd->action = cpu_to_le16(MWL8K_STA_ACTION_ADD);\n\tif (hw->conf.chandef.chan->band == NL80211_BAND_2GHZ)\n\t\trates = sta->deflink.supp_rates[NL80211_BAND_2GHZ];\n\telse\n\t\trates = sta->deflink.supp_rates[NL80211_BAND_5GHZ] << 5;\n\tcmd->legacy_rates = cpu_to_le32(rates);\n\tif (sta->deflink.ht_cap.ht_supported) {\n\t\tcmd->ht_rates[0] = sta->deflink.ht_cap.mcs.rx_mask[0];\n\t\tcmd->ht_rates[1] = sta->deflink.ht_cap.mcs.rx_mask[1];\n\t\tcmd->ht_rates[2] = sta->deflink.ht_cap.mcs.rx_mask[2];\n\t\tcmd->ht_rates[3] = sta->deflink.ht_cap.mcs.rx_mask[3];\n\t\tcmd->ht_capabilities_info = cpu_to_le16(sta->deflink.ht_cap.cap);\n\t\tcmd->mac_ht_param_info = (sta->deflink.ht_cap.ampdu_factor & 3) |\n\t\t\t((sta->deflink.ht_cap.ampdu_density & 7) << 2);\n\t\tcmd->is_qos_sta = 1;\n\t}\n\n\trc = mwl8k_post_pervif_cmd(hw, vif, &cmd->header);\n\tkfree(cmd);\n\n\treturn rc;\n}\n\nstatic int mwl8k_cmd_set_new_stn_add_self(struct ieee80211_hw *hw,\n\t\t\t\t\t  struct ieee80211_vif *vif)\n{\n\tstruct mwl8k_cmd_set_new_stn *cmd;\n\tint rc;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (cmd == NULL)\n\t\treturn -ENOMEM;\n\n\tcmd->header.code = cpu_to_le16(MWL8K_CMD_SET_NEW_STN);\n\tcmd->header.length = cpu_to_le16(sizeof(*cmd));\n\tmemcpy(cmd->mac_addr, vif->addr, ETH_ALEN);\n\n\trc = mwl8k_post_pervif_cmd(hw, vif, &cmd->header);\n\tkfree(cmd);\n\n\treturn rc;\n}\n\nstatic int mwl8k_cmd_set_new_stn_del(struct ieee80211_hw *hw,\n\t\t\t\t     struct ieee80211_vif *vif, u8 *addr)\n{\n\tstruct mwl8k_cmd_set_new_stn *cmd;\n\tstruct mwl8k_priv *priv = hw->priv;\n\tint rc, i;\n\tu8 idx;\n\n\tspin_lock(&priv->stream_lock);\n\t \n\tfor (i = 0; i < MWL8K_NUM_AMPDU_STREAMS; i++) {\n\t\tstruct mwl8k_ampdu_stream *s;\n\t\ts = &priv->ampdu[i];\n\t\tif (s->state != AMPDU_NO_STREAM) {\n\t\t\tif (memcmp(s->sta->addr, addr, ETH_ALEN) == 0) {\n\t\t\t\tif (s->state == AMPDU_STREAM_ACTIVE) {\n\t\t\t\t\tidx = s->idx;\n\t\t\t\t\tspin_unlock(&priv->stream_lock);\n\t\t\t\t\tmwl8k_destroy_ba(hw, idx);\n\t\t\t\t\tspin_lock(&priv->stream_lock);\n\t\t\t\t} else if (s->state == AMPDU_STREAM_NEW) {\n\t\t\t\t\tmwl8k_remove_stream(hw, s);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_unlock(&priv->stream_lock);\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (cmd == NULL)\n\t\treturn -ENOMEM;\n\n\tcmd->header.code = cpu_to_le16(MWL8K_CMD_SET_NEW_STN);\n\tcmd->header.length = cpu_to_le16(sizeof(*cmd));\n\tmemcpy(cmd->mac_addr, addr, ETH_ALEN);\n\tcmd->action = cpu_to_le16(MWL8K_STA_ACTION_REMOVE);\n\n\trc = mwl8k_post_pervif_cmd(hw, vif, &cmd->header);\n\tkfree(cmd);\n\n\treturn rc;\n}\n\n \n\n#define MAX_ENCR_KEY_LENGTH\t16\n#define MIC_KEY_LENGTH\t\t8\n\nstruct mwl8k_cmd_update_encryption {\n\tstruct mwl8k_cmd_pkt header;\n\n\t__le32 action;\n\t__le32 reserved;\n\t__u8 mac_addr[6];\n\t__u8 encr_type;\n\n} __packed;\n\nstruct mwl8k_cmd_set_key {\n\tstruct mwl8k_cmd_pkt header;\n\n\t__le32 action;\n\t__le32 reserved;\n\t__le16 length;\n\t__le16 key_type_id;\n\t__le32 key_info;\n\t__le32 key_id;\n\t__le16 key_len;\n\tstruct {\n\t\t__u8 key_material[MAX_ENCR_KEY_LENGTH];\n\t\t__u8 tkip_tx_mic_key[MIC_KEY_LENGTH];\n\t\t__u8 tkip_rx_mic_key[MIC_KEY_LENGTH];\n\t} tkip;\n\t__le16 tkip_rsc_low;\n\t__le32 tkip_rsc_high;\n\t__le16 tkip_tsc_low;\n\t__le32 tkip_tsc_high;\n\t__u8 mac_addr[6];\n} __packed;\n\nenum {\n\tMWL8K_ENCR_ENABLE,\n\tMWL8K_ENCR_SET_KEY,\n\tMWL8K_ENCR_REMOVE_KEY,\n\tMWL8K_ENCR_SET_GROUP_KEY,\n};\n\n#define MWL8K_UPDATE_ENCRYPTION_TYPE_WEP\t0\n#define MWL8K_UPDATE_ENCRYPTION_TYPE_DISABLE\t1\n#define MWL8K_UPDATE_ENCRYPTION_TYPE_TKIP\t4\n#define MWL8K_UPDATE_ENCRYPTION_TYPE_MIXED\t7\n#define MWL8K_UPDATE_ENCRYPTION_TYPE_AES\t8\n\nenum {\n\tMWL8K_ALG_WEP,\n\tMWL8K_ALG_TKIP,\n\tMWL8K_ALG_CCMP,\n};\n\n#define MWL8K_KEY_FLAG_TXGROUPKEY\t0x00000004\n#define MWL8K_KEY_FLAG_PAIRWISE\t\t0x00000008\n#define MWL8K_KEY_FLAG_TSC_VALID\t0x00000040\n#define MWL8K_KEY_FLAG_WEP_TXKEY\t0x01000000\n#define MWL8K_KEY_FLAG_MICKEY_VALID\t0x02000000\n\nstatic int mwl8k_cmd_update_encryption_enable(struct ieee80211_hw *hw,\n\t\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t\t      u8 *addr,\n\t\t\t\t\t      u8 encr_type)\n{\n\tstruct mwl8k_cmd_update_encryption *cmd;\n\tint rc;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (cmd == NULL)\n\t\treturn -ENOMEM;\n\n\tcmd->header.code = cpu_to_le16(MWL8K_CMD_UPDATE_ENCRYPTION);\n\tcmd->header.length = cpu_to_le16(sizeof(*cmd));\n\tcmd->action = cpu_to_le32(MWL8K_ENCR_ENABLE);\n\tmemcpy(cmd->mac_addr, addr, ETH_ALEN);\n\tcmd->encr_type = encr_type;\n\n\trc = mwl8k_post_pervif_cmd(hw, vif, &cmd->header);\n\tkfree(cmd);\n\n\treturn rc;\n}\n\nstatic int mwl8k_encryption_set_cmd_info(struct mwl8k_cmd_set_key *cmd,\n\t\t\t\t\t\tu8 *addr,\n\t\t\t\t\t\tstruct ieee80211_key_conf *key)\n{\n\tcmd->header.code = cpu_to_le16(MWL8K_CMD_UPDATE_ENCRYPTION);\n\tcmd->header.length = cpu_to_le16(sizeof(*cmd));\n\tcmd->length = cpu_to_le16(sizeof(*cmd) -\n\t\t\t\toffsetof(struct mwl8k_cmd_set_key, length));\n\tcmd->key_id = cpu_to_le32(key->keyidx);\n\tcmd->key_len = cpu_to_le16(key->keylen);\n\tmemcpy(cmd->mac_addr, addr, ETH_ALEN);\n\n\tswitch (key->cipher) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\tcmd->key_type_id = cpu_to_le16(MWL8K_ALG_WEP);\n\t\tif (key->keyidx == 0)\n\t\t\tcmd->key_info =\tcpu_to_le32(MWL8K_KEY_FLAG_WEP_TXKEY);\n\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\tcmd->key_type_id = cpu_to_le16(MWL8K_ALG_TKIP);\n\t\tcmd->key_info =\t(key->flags & IEEE80211_KEY_FLAG_PAIRWISE)\n\t\t\t? cpu_to_le32(MWL8K_KEY_FLAG_PAIRWISE)\n\t\t\t: cpu_to_le32(MWL8K_KEY_FLAG_TXGROUPKEY);\n\t\tcmd->key_info |= cpu_to_le32(MWL8K_KEY_FLAG_MICKEY_VALID\n\t\t\t\t\t\t| MWL8K_KEY_FLAG_TSC_VALID);\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tcmd->key_type_id = cpu_to_le16(MWL8K_ALG_CCMP);\n\t\tcmd->key_info =\t(key->flags & IEEE80211_KEY_FLAG_PAIRWISE)\n\t\t\t? cpu_to_le32(MWL8K_KEY_FLAG_PAIRWISE)\n\t\t\t: cpu_to_le32(MWL8K_KEY_FLAG_TXGROUPKEY);\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int mwl8k_cmd_encryption_set_key(struct ieee80211_hw *hw,\n\t\t\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\t\t\tu8 *addr,\n\t\t\t\t\t\tstruct ieee80211_key_conf *key)\n{\n\tstruct mwl8k_cmd_set_key *cmd;\n\tint rc;\n\tint keymlen;\n\tu32 action;\n\tu8 idx;\n\tstruct mwl8k_vif *mwl8k_vif = MWL8K_VIF(vif);\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (cmd == NULL)\n\t\treturn -ENOMEM;\n\n\trc = mwl8k_encryption_set_cmd_info(cmd, addr, key);\n\tif (rc < 0)\n\t\tgoto done;\n\n\tidx = key->keyidx;\n\n\tif (key->flags & IEEE80211_KEY_FLAG_PAIRWISE)\n\t\taction = MWL8K_ENCR_SET_KEY;\n\telse\n\t\taction = MWL8K_ENCR_SET_GROUP_KEY;\n\n\tswitch (key->cipher) {\n\tcase WLAN_CIPHER_SUITE_WEP40:\n\tcase WLAN_CIPHER_SUITE_WEP104:\n\t\tif (!mwl8k_vif->wep_key_conf[idx].enabled) {\n\t\t\tmemcpy(mwl8k_vif->wep_key_conf[idx].key, key,\n\t\t\t\t\t\tsizeof(*key) + key->keylen);\n\t\t\tmwl8k_vif->wep_key_conf[idx].enabled = 1;\n\t\t}\n\n\t\tkeymlen = key->keylen;\n\t\taction = MWL8K_ENCR_SET_KEY;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_TKIP:\n\t\tkeymlen = MAX_ENCR_KEY_LENGTH + 2 * MIC_KEY_LENGTH;\n\t\tbreak;\n\tcase WLAN_CIPHER_SUITE_CCMP:\n\t\tkeymlen = key->keylen;\n\t\tbreak;\n\tdefault:\n\t\trc = -ENOTSUPP;\n\t\tgoto done;\n\t}\n\n\tmemcpy(&cmd->tkip, key->key, keymlen);\n\tcmd->action = cpu_to_le32(action);\n\n\trc = mwl8k_post_pervif_cmd(hw, vif, &cmd->header);\ndone:\n\tkfree(cmd);\n\n\treturn rc;\n}\n\nstatic int mwl8k_cmd_encryption_remove_key(struct ieee80211_hw *hw,\n\t\t\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\t\t\tu8 *addr,\n\t\t\t\t\t\tstruct ieee80211_key_conf *key)\n{\n\tstruct mwl8k_cmd_set_key *cmd;\n\tint rc;\n\tstruct mwl8k_vif *mwl8k_vif = MWL8K_VIF(vif);\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (cmd == NULL)\n\t\treturn -ENOMEM;\n\n\trc = mwl8k_encryption_set_cmd_info(cmd, addr, key);\n\tif (rc < 0)\n\t\tgoto done;\n\n\tif (key->cipher == WLAN_CIPHER_SUITE_WEP40 ||\n\t\t\tkey->cipher == WLAN_CIPHER_SUITE_WEP104)\n\t\tmwl8k_vif->wep_key_conf[key->keyidx].enabled = 0;\n\n\tcmd->action = cpu_to_le32(MWL8K_ENCR_REMOVE_KEY);\n\n\trc = mwl8k_post_pervif_cmd(hw, vif, &cmd->header);\ndone:\n\tkfree(cmd);\n\n\treturn rc;\n}\n\nstatic int mwl8k_set_key(struct ieee80211_hw *hw,\n\t\t\t enum set_key_cmd cmd_param,\n\t\t\t struct ieee80211_vif *vif,\n\t\t\t struct ieee80211_sta *sta,\n\t\t\t struct ieee80211_key_conf *key)\n{\n\tint rc = 0;\n\tu8 encr_type;\n\tu8 *addr;\n\tstruct mwl8k_vif *mwl8k_vif = MWL8K_VIF(vif);\n\tstruct mwl8k_priv *priv = hw->priv;\n\n\tif (vif->type == NL80211_IFTYPE_STATION && !priv->ap_fw)\n\t\treturn -EOPNOTSUPP;\n\n\tif (sta == NULL)\n\t\taddr = vif->addr;\n\telse\n\t\taddr = sta->addr;\n\n\tif (cmd_param == SET_KEY) {\n\t\trc = mwl8k_cmd_encryption_set_key(hw, vif, addr, key);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\tif ((key->cipher == WLAN_CIPHER_SUITE_WEP40)\n\t\t\t\t|| (key->cipher == WLAN_CIPHER_SUITE_WEP104))\n\t\t\tencr_type = MWL8K_UPDATE_ENCRYPTION_TYPE_WEP;\n\t\telse\n\t\t\tencr_type = MWL8K_UPDATE_ENCRYPTION_TYPE_MIXED;\n\n\t\trc = mwl8k_cmd_update_encryption_enable(hw, vif, addr,\n\t\t\t\t\t\t\t\tencr_type);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\tmwl8k_vif->is_hw_crypto_enabled = true;\n\n\t} else {\n\t\trc = mwl8k_cmd_encryption_remove_key(hw, vif, addr, key);\n\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\nout:\n\treturn rc;\n}\n\n \nstruct ewc_ht_info {\n\t__le16\tcontrol1;\n\t__le16\tcontrol2;\n\t__le16\tcontrol3;\n} __packed;\n\nstruct peer_capability_info {\n\t \n\t__u8\tpeer_type;\n\n\t \n\t__le16\tbasic_caps;\n\n\t \n\t__u8\tht_support;\n\n\t \n\t__le16\tht_caps;\n\t__u8\textended_ht_caps;\n\tstruct ewc_ht_info\tewc_info;\n\n\t \n\t__u8\tlegacy_rates[12];\n\n\t \n\t__u8\tht_rates[16];\n\t__u8\tpad[16];\n\n\t \n\t__u8\tinterop;\n\t__u8\tpad2;\n\t__u8\tstation_id;\n\t__le16\tamsdu_enabled;\n} __packed;\n\nstruct mwl8k_cmd_update_stadb {\n\tstruct mwl8k_cmd_pkt header;\n\n\t \n\t__le32\taction;\n\n\t \n\t__u8\tpeer_addr[ETH_ALEN];\n\n\t__le32\treserved;\n\n\t \n\tstruct peer_capability_info\tpeer_info;\n} __packed;\n\n#define MWL8K_STA_DB_MODIFY_ENTRY\t1\n#define MWL8K_STA_DB_DEL_ENTRY\t\t2\n\n \n#define MWL8K_PEER_TYPE_ACCESSPOINT\t2\n\nstatic int mwl8k_cmd_update_stadb_add(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_vif *vif,\n\t\t\t\t      struct ieee80211_sta *sta)\n{\n\tstruct mwl8k_cmd_update_stadb *cmd;\n\tstruct peer_capability_info *p;\n\tu32 rates;\n\tint rc;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (cmd == NULL)\n\t\treturn -ENOMEM;\n\n\tcmd->header.code = cpu_to_le16(MWL8K_CMD_UPDATE_STADB);\n\tcmd->header.length = cpu_to_le16(sizeof(*cmd));\n\tcmd->action = cpu_to_le32(MWL8K_STA_DB_MODIFY_ENTRY);\n\tmemcpy(cmd->peer_addr, sta->addr, ETH_ALEN);\n\n\tp = &cmd->peer_info;\n\tp->peer_type = MWL8K_PEER_TYPE_ACCESSPOINT;\n\tp->basic_caps = cpu_to_le16(vif->bss_conf.assoc_capability);\n\tp->ht_support = sta->deflink.ht_cap.ht_supported;\n\tp->ht_caps = cpu_to_le16(sta->deflink.ht_cap.cap);\n\tp->extended_ht_caps = (sta->deflink.ht_cap.ampdu_factor & 3) |\n\t\t((sta->deflink.ht_cap.ampdu_density & 7) << 2);\n\tif (hw->conf.chandef.chan->band == NL80211_BAND_2GHZ)\n\t\trates = sta->deflink.supp_rates[NL80211_BAND_2GHZ];\n\telse\n\t\trates = sta->deflink.supp_rates[NL80211_BAND_5GHZ] << 5;\n\tlegacy_rate_mask_to_array(p->legacy_rates, rates);\n\tmemcpy(p->ht_rates, &sta->deflink.ht_cap.mcs, 16);\n\tp->interop = 1;\n\tp->amsdu_enabled = 0;\n\n\trc = mwl8k_post_cmd(hw, &cmd->header);\n\tif (!rc)\n\t\trc = p->station_id;\n\tkfree(cmd);\n\n\treturn rc;\n}\n\nstatic int mwl8k_cmd_update_stadb_del(struct ieee80211_hw *hw,\n\t\t\t\t      struct ieee80211_vif *vif, u8 *addr)\n{\n\tstruct mwl8k_cmd_update_stadb *cmd;\n\tint rc;\n\n\tcmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\n\tif (cmd == NULL)\n\t\treturn -ENOMEM;\n\n\tcmd->header.code = cpu_to_le16(MWL8K_CMD_UPDATE_STADB);\n\tcmd->header.length = cpu_to_le16(sizeof(*cmd));\n\tcmd->action = cpu_to_le32(MWL8K_STA_DB_DEL_ENTRY);\n\tmemcpy(cmd->peer_addr, addr, ETH_ALEN);\n\n\trc = mwl8k_post_cmd(hw, &cmd->header);\n\tkfree(cmd);\n\n\treturn rc;\n}\n\n\n \nstatic irqreturn_t mwl8k_interrupt(int irq, void *dev_id)\n{\n\tstruct ieee80211_hw *hw = dev_id;\n\tstruct mwl8k_priv *priv = hw->priv;\n\tu32 status;\n\n\tstatus = ioread32(priv->regs + MWL8K_HIU_A2H_INTERRUPT_STATUS);\n\tif (!status)\n\t\treturn IRQ_NONE;\n\n\tif (status & MWL8K_A2H_INT_TX_DONE) {\n\t\tstatus &= ~MWL8K_A2H_INT_TX_DONE;\n\t\ttasklet_schedule(&priv->poll_tx_task);\n\t}\n\n\tif (status & MWL8K_A2H_INT_RX_READY) {\n\t\tstatus &= ~MWL8K_A2H_INT_RX_READY;\n\t\ttasklet_schedule(&priv->poll_rx_task);\n\t}\n\n\tif (status & MWL8K_A2H_INT_BA_WATCHDOG) {\n\t\tiowrite32(~MWL8K_A2H_INT_BA_WATCHDOG,\n\t\t\t  priv->regs + MWL8K_HIU_A2H_INTERRUPT_STATUS_MASK);\n\n\t\tatomic_inc(&priv->watchdog_event_pending);\n\t\tstatus &= ~MWL8K_A2H_INT_BA_WATCHDOG;\n\t\tieee80211_queue_work(hw, &priv->watchdog_ba_handle);\n\t}\n\n\tif (status)\n\t\tiowrite32(~status, priv->regs + MWL8K_HIU_A2H_INTERRUPT_STATUS);\n\n\tif (status & MWL8K_A2H_INT_OPC_DONE) {\n\t\tif (priv->hostcmd_wait != NULL)\n\t\t\tcomplete(priv->hostcmd_wait);\n\t}\n\n\tif (status & MWL8K_A2H_INT_QUEUE_EMPTY) {\n\t\tif (!mutex_is_locked(&priv->fw_mutex) &&\n\t\t    priv->radio_on && priv->pending_tx_pkts)\n\t\t\tmwl8k_tx_start(priv);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void mwl8k_tx_poll(struct tasklet_struct *t)\n{\n\tstruct mwl8k_priv *priv = from_tasklet(priv, t, poll_tx_task);\n\tstruct ieee80211_hw *hw = pci_get_drvdata(priv->pdev);\n\tint limit;\n\tint i;\n\n\tlimit = 32;\n\n\tspin_lock(&priv->tx_lock);\n\n\tfor (i = 0; i < mwl8k_tx_queues(priv); i++)\n\t\tlimit -= mwl8k_txq_reclaim(hw, i, limit, 0);\n\n\tif (!priv->pending_tx_pkts && priv->tx_wait != NULL) {\n\t\tcomplete(priv->tx_wait);\n\t\tpriv->tx_wait = NULL;\n\t}\n\n\tspin_unlock(&priv->tx_lock);\n\n\tif (limit) {\n\t\twritel(~MWL8K_A2H_INT_TX_DONE,\n\t\t       priv->regs + MWL8K_HIU_A2H_INTERRUPT_STATUS);\n\t} else {\n\t\ttasklet_schedule(&priv->poll_tx_task);\n\t}\n}\n\nstatic void mwl8k_rx_poll(struct tasklet_struct *t)\n{\n\tstruct mwl8k_priv *priv = from_tasklet(priv, t, poll_rx_task);\n\tstruct ieee80211_hw *hw = pci_get_drvdata(priv->pdev);\n\tint limit;\n\n\tlimit = 32;\n\tlimit -= rxq_process(hw, 0, limit);\n\tlimit -= rxq_refill(hw, 0, limit);\n\n\tif (limit) {\n\t\twritel(~MWL8K_A2H_INT_RX_READY,\n\t\t       priv->regs + MWL8K_HIU_A2H_INTERRUPT_STATUS);\n\t} else {\n\t\ttasklet_schedule(&priv->poll_rx_task);\n\t}\n}\n\n\n \nstatic void mwl8k_tx(struct ieee80211_hw *hw,\n\t\t     struct ieee80211_tx_control *control,\n\t\t     struct sk_buff *skb)\n{\n\tstruct mwl8k_priv *priv = hw->priv;\n\tint index = skb_get_queue_mapping(skb);\n\n\tif (!priv->radio_on) {\n\t\twiphy_debug(hw->wiphy,\n\t\t\t    \"dropped TX frame since radio disabled\\n\");\n\t\tdev_kfree_skb(skb);\n\t\treturn;\n\t}\n\n\tmwl8k_txq_xmit(hw, index, control->sta, skb);\n}\n\nstatic int mwl8k_start(struct ieee80211_hw *hw)\n{\n\tstruct mwl8k_priv *priv = hw->priv;\n\tint rc;\n\n\trc = request_irq(priv->pdev->irq, mwl8k_interrupt,\n\t\t\t IRQF_SHARED, MWL8K_NAME, hw);\n\tif (rc) {\n\t\tpriv->irq = -1;\n\t\twiphy_err(hw->wiphy, \"failed to register IRQ handler\\n\");\n\t\treturn -EIO;\n\t}\n\tpriv->irq = priv->pdev->irq;\n\n\t \n\ttasklet_enable(&priv->poll_tx_task);\n\ttasklet_enable(&priv->poll_rx_task);\n\n\t \n\tiowrite32(MWL8K_A2H_EVENTS, priv->regs + MWL8K_HIU_A2H_INTERRUPT_MASK);\n\tiowrite32(MWL8K_A2H_EVENTS,\n\t\t  priv->regs + MWL8K_HIU_A2H_INTERRUPT_STATUS_MASK);\n\n\trc = mwl8k_fw_lock(hw);\n\tif (!rc) {\n\t\trc = mwl8k_cmd_radio_enable(hw);\n\n\t\tif (!priv->ap_fw) {\n\t\t\tif (!rc)\n\t\t\t\trc = mwl8k_cmd_enable_sniffer(hw, 0);\n\n\t\t\tif (!rc)\n\t\t\t\trc = mwl8k_cmd_set_pre_scan(hw);\n\n\t\t\tif (!rc)\n\t\t\t\trc = mwl8k_cmd_set_post_scan(hw,\n\t\t\t\t\t\t\"\\x00\\x00\\x00\\x00\\x00\\x00\");\n\t\t}\n\n\t\tif (!rc)\n\t\t\trc = mwl8k_cmd_set_rateadapt_mode(hw, 0);\n\n\t\tif (!rc)\n\t\t\trc = mwl8k_cmd_set_wmm_mode(hw, 0);\n\n\t\tmwl8k_fw_unlock(hw);\n\t}\n\n\tif (rc) {\n\t\tiowrite32(0, priv->regs + MWL8K_HIU_A2H_INTERRUPT_MASK);\n\t\tfree_irq(priv->pdev->irq, hw);\n\t\tpriv->irq = -1;\n\t\ttasklet_disable(&priv->poll_tx_task);\n\t\ttasklet_disable(&priv->poll_rx_task);\n\t} else {\n\t\tieee80211_wake_queues(hw);\n\t}\n\n\treturn rc;\n}\n\nstatic void mwl8k_stop(struct ieee80211_hw *hw)\n{\n\tstruct mwl8k_priv *priv = hw->priv;\n\tint i;\n\n\tif (!priv->hw_restart_in_progress)\n\t\tmwl8k_cmd_radio_disable(hw);\n\n\tieee80211_stop_queues(hw);\n\n\t \n\tiowrite32(0, priv->regs + MWL8K_HIU_A2H_INTERRUPT_MASK);\n\tif (priv->irq != -1) {\n\t\tfree_irq(priv->pdev->irq, hw);\n\t\tpriv->irq = -1;\n\t}\n\n\t \n\tcancel_work_sync(&priv->finalize_join_worker);\n\tcancel_work_sync(&priv->watchdog_ba_handle);\n\tif (priv->beacon_skb != NULL)\n\t\tdev_kfree_skb(priv->beacon_skb);\n\n\t \n\ttasklet_disable(&priv->poll_tx_task);\n\ttasklet_disable(&priv->poll_rx_task);\n\n\t \n\tfor (i = 0; i < mwl8k_tx_queues(priv); i++)\n\t\tmwl8k_txq_reclaim(hw, i, INT_MAX, 1);\n}\n\nstatic int mwl8k_reload_firmware(struct ieee80211_hw *hw, char *fw_image);\n\nstatic int mwl8k_add_interface(struct ieee80211_hw *hw,\n\t\t\t       struct ieee80211_vif *vif)\n{\n\tstruct mwl8k_priv *priv = hw->priv;\n\tstruct mwl8k_vif *mwl8k_vif;\n\tu32 macids_supported;\n\tint macid, rc;\n\tstruct mwl8k_device_info *di;\n\n\t \n\tif (priv->sniffer_enabled) {\n\t\twiphy_info(hw->wiphy,\n\t\t\t   \"unable to create STA interface because sniffer mode is enabled\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdi = priv->device_info;\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_AP:\n\t\tif (!priv->ap_fw && di->fw_image_ap) {\n\t\t\t \n\t\t\tif (!list_empty(&priv->vif_list))\n\t\t\t\treturn -EBUSY;\n\t\t\trc = mwl8k_reload_firmware(hw, di->fw_image_ap);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t\tmacids_supported = priv->ap_macids_supported;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (priv->ap_fw && di->fw_image_sta) {\n\t\t\tif (!list_empty(&priv->vif_list)) {\n\t\t\t\twiphy_warn(hw->wiphy, \"AP interface is running.\\n\"\n\t\t\t\t\t   \"Adding STA interface for WDS\");\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\trc = mwl8k_reload_firmware(hw,\n\t\t\t\t\t\t\t   di->fw_image_sta);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\t\tmacids_supported = priv->sta_macids_supported;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tmacid = ffs(macids_supported & ~priv->macids_used);\n\tif (!macid--)\n\t\treturn -EBUSY;\n\n\t \n\tmwl8k_vif = MWL8K_VIF(vif);\n\tmemset(mwl8k_vif, 0, sizeof(*mwl8k_vif));\n\tmwl8k_vif->vif = vif;\n\tmwl8k_vif->macid = macid;\n\tmwl8k_vif->seqno = 0;\n\tmemcpy(mwl8k_vif->bssid, vif->addr, ETH_ALEN);\n\tmwl8k_vif->is_hw_crypto_enabled = false;\n\n\t \n\tmwl8k_cmd_set_mac_addr(hw, vif, vif->addr);\n\n\tif (vif->type == NL80211_IFTYPE_AP)\n\t\tmwl8k_cmd_set_new_stn_add_self(hw, vif);\n\n\tpriv->macids_used |= 1 << mwl8k_vif->macid;\n\tlist_add_tail(&mwl8k_vif->list, &priv->vif_list);\n\n\treturn 0;\n}\n\nstatic void mwl8k_remove_vif(struct mwl8k_priv *priv, struct mwl8k_vif *vif)\n{\n\t \n\tif (!priv->macids_used)\n\t\treturn;\n\n\tpriv->macids_used &= ~(1 << vif->macid);\n\tlist_del(&vif->list);\n}\n\nstatic void mwl8k_remove_interface(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tstruct mwl8k_priv *priv = hw->priv;\n\tstruct mwl8k_vif *mwl8k_vif = MWL8K_VIF(vif);\n\n\tif (vif->type == NL80211_IFTYPE_AP)\n\t\tmwl8k_cmd_set_new_stn_del(hw, vif, vif->addr);\n\n\tmwl8k_cmd_del_mac_addr(hw, vif, vif->addr);\n\n\tmwl8k_remove_vif(priv, mwl8k_vif);\n}\n\nstatic void mwl8k_hw_restart_work(struct work_struct *work)\n{\n\tstruct mwl8k_priv *priv =\n\t\tcontainer_of(work, struct mwl8k_priv, fw_reload);\n\tstruct ieee80211_hw *hw = priv->hw;\n\tstruct mwl8k_device_info *di;\n\tint rc;\n\n\t \n\tif (priv->hostcmd_wait != NULL) {\n\t\tcomplete(priv->hostcmd_wait);\n\t\tpriv->hostcmd_wait = NULL;\n\t}\n\n\tpriv->hw_restart_owner = current;\n\tdi = priv->device_info;\n\tmwl8k_fw_lock(hw);\n\n\tif (priv->ap_fw)\n\t\trc = mwl8k_reload_firmware(hw, di->fw_image_ap);\n\telse\n\t\trc = mwl8k_reload_firmware(hw, di->fw_image_sta);\n\n\tif (rc)\n\t\tgoto fail;\n\n\tpriv->hw_restart_owner = NULL;\n\tpriv->hw_restart_in_progress = false;\n\n\t \n\tmwl8k_fw_unlock(hw);\n\n\tieee80211_restart_hw(hw);\n\n\twiphy_err(hw->wiphy, \"Firmware restarted successfully\\n\");\n\n\treturn;\nfail:\n\tmwl8k_fw_unlock(hw);\n\n\twiphy_err(hw->wiphy, \"Firmware restart failed\\n\");\n}\n\nstatic int mwl8k_config(struct ieee80211_hw *hw, u32 changed)\n{\n\tstruct ieee80211_conf *conf = &hw->conf;\n\tstruct mwl8k_priv *priv = hw->priv;\n\tint rc;\n\n\trc = mwl8k_fw_lock(hw);\n\tif (rc)\n\t\treturn rc;\n\n\tif (conf->flags & IEEE80211_CONF_IDLE)\n\t\trc = mwl8k_cmd_radio_disable(hw);\n\telse\n\t\trc = mwl8k_cmd_radio_enable(hw);\n\tif (rc)\n\t\tgoto out;\n\n\tif (changed & IEEE80211_CONF_CHANGE_CHANNEL) {\n\t\trc = mwl8k_cmd_set_rf_channel(hw, conf);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\tif (conf->power_level > 18)\n\t\tconf->power_level = 18;\n\n\tif (priv->ap_fw) {\n\n\t\tif (conf->flags & IEEE80211_CONF_CHANGE_POWER) {\n\t\t\trc = mwl8k_cmd_tx_power(hw, conf, conf->power_level);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\n\n\t} else {\n\t\trc = mwl8k_cmd_rf_tx_power(hw, conf->power_level);\n\t\tif (rc)\n\t\t\tgoto out;\n\t\trc = mwl8k_cmd_mimo_config(hw, 0x7, 0x7);\n\t}\n\nout:\n\tmwl8k_fw_unlock(hw);\n\n\treturn rc;\n}\n\nstatic void\nmwl8k_bss_info_changed_sta(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t   struct ieee80211_bss_conf *info, u32 changed)\n{\n\tstruct mwl8k_priv *priv = hw->priv;\n\tu32 ap_legacy_rates = 0;\n\tu8 ap_mcs_rates[16];\n\tint rc;\n\n\tif (mwl8k_fw_lock(hw))\n\t\treturn;\n\n\t \n\tif ((changed & BSS_CHANGED_ASSOC) && !vif->cfg.assoc)\n\t\tpriv->capture_beacon = false;\n\n\t \n\tif (vif->cfg.assoc) {\n\t\tstruct ieee80211_sta *ap;\n\n\t\trcu_read_lock();\n\n\t\tap = ieee80211_find_sta(vif, vif->bss_conf.bssid);\n\t\tif (ap == NULL) {\n\t\t\trcu_read_unlock();\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (hw->conf.chandef.chan->band == NL80211_BAND_2GHZ) {\n\t\t\tap_legacy_rates = ap->deflink.supp_rates[NL80211_BAND_2GHZ];\n\t\t} else {\n\t\t\tap_legacy_rates =\n\t\t\t\tap->deflink.supp_rates[NL80211_BAND_5GHZ] << 5;\n\t\t}\n\t\tmemcpy(ap_mcs_rates, &ap->deflink.ht_cap.mcs, 16);\n\n\t\trcu_read_unlock();\n\n\t\tif (changed & BSS_CHANGED_ASSOC) {\n\t\t\tif (!priv->ap_fw) {\n\t\t\t\trc = mwl8k_cmd_set_rate(hw, vif,\n\t\t\t\t\t\t\tap_legacy_rates,\n\t\t\t\t\t\t\tap_mcs_rates);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\n\t\t\t\trc = mwl8k_cmd_use_fixed_rate_sta(hw);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\t\t\t} else {\n\t\t\t\tint idx;\n\t\t\t\tint rate;\n\n\t\t\t\t \n\t\t\t\tidx = ffs(vif->bss_conf.basic_rates);\n\t\t\t\tif (idx)\n\t\t\t\t\tidx--;\n\n\t\t\t\tif (hw->conf.chandef.chan->band ==\n\t\t\t\t    NL80211_BAND_2GHZ)\n\t\t\t\t\trate = mwl8k_rates_24[idx].hw_value;\n\t\t\t\telse\n\t\t\t\t\trate = mwl8k_rates_50[idx].hw_value;\n\n\t\t\t\tmwl8k_cmd_use_fixed_rate_ap(hw, rate, rate);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (changed & BSS_CHANGED_ERP_PREAMBLE) {\n\t\trc = mwl8k_set_radio_preamble(hw,\n\t\t\t\tvif->bss_conf.use_short_preamble);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\tif ((changed & BSS_CHANGED_ERP_SLOT) && !priv->ap_fw)  {\n\t\trc = mwl8k_cmd_set_slot(hw, vif->bss_conf.use_short_slot);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\tif (vif->cfg.assoc && !priv->ap_fw &&\n\t    (changed & (BSS_CHANGED_ASSOC | BSS_CHANGED_ERP_CTS_PROT |\n\t\t\tBSS_CHANGED_HT))) {\n\t\trc = mwl8k_cmd_set_aid(hw, vif, ap_legacy_rates);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\tif (vif->cfg.assoc &&\n\t    (changed & (BSS_CHANGED_ASSOC | BSS_CHANGED_BEACON_INT))) {\n\t\t \n\t\tmemcpy(priv->capture_bssid, vif->bss_conf.bssid, ETH_ALEN);\n\t\tpriv->capture_beacon = true;\n\t}\n\nout:\n\tmwl8k_fw_unlock(hw);\n}\n\nstatic void\nmwl8k_bss_info_changed_ap(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t\t  struct ieee80211_bss_conf *info, u32 changed)\n{\n\tint rc;\n\n\tif (mwl8k_fw_lock(hw))\n\t\treturn;\n\n\tif (changed & BSS_CHANGED_ERP_PREAMBLE) {\n\t\trc = mwl8k_set_radio_preamble(hw,\n\t\t\t\tvif->bss_conf.use_short_preamble);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\tif (changed & BSS_CHANGED_BASIC_RATES) {\n\t\tint idx;\n\t\tint rate;\n\n\t\t \n\t\tidx = ffs(vif->bss_conf.basic_rates);\n\t\tif (idx)\n\t\t\tidx--;\n\n\t\tif (hw->conf.chandef.chan->band == NL80211_BAND_2GHZ)\n\t\t\trate = mwl8k_rates_24[idx].hw_value;\n\t\telse\n\t\t\trate = mwl8k_rates_50[idx].hw_value;\n\n\t\tmwl8k_cmd_use_fixed_rate_ap(hw, rate, rate);\n\t}\n\n\tif (changed & (BSS_CHANGED_BEACON_INT | BSS_CHANGED_BEACON)) {\n\t\tstruct sk_buff *skb;\n\n\t\tskb = ieee80211_beacon_get(hw, vif, 0);\n\t\tif (skb != NULL) {\n\t\t\tmwl8k_cmd_set_beacon(hw, vif, skb->data, skb->len);\n\t\t\tkfree_skb(skb);\n\t\t}\n\t}\n\n\tif (changed & BSS_CHANGED_BEACON_ENABLED)\n\t\tmwl8k_cmd_bss_start(hw, vif, info->enable_beacon);\n\nout:\n\tmwl8k_fw_unlock(hw);\n}\n\nstatic void\nmwl8k_bss_info_changed(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t       struct ieee80211_bss_conf *info, u64 changed)\n{\n\tif (vif->type == NL80211_IFTYPE_STATION)\n\t\tmwl8k_bss_info_changed_sta(hw, vif, info, changed);\n\tif (vif->type == NL80211_IFTYPE_AP)\n\t\tmwl8k_bss_info_changed_ap(hw, vif, info, changed);\n}\n\nstatic u64 mwl8k_prepare_multicast(struct ieee80211_hw *hw,\n\t\t\t\t   struct netdev_hw_addr_list *mc_list)\n{\n\tstruct mwl8k_cmd_pkt *cmd;\n\n\t \n\tcmd = __mwl8k_cmd_mac_multicast_adr(hw, 0, mc_list);\n\n\treturn (unsigned long)cmd;\n}\n\nstatic int\nmwl8k_configure_filter_sniffer(struct ieee80211_hw *hw,\n\t\t\t       unsigned int changed_flags,\n\t\t\t       unsigned int *total_flags)\n{\n\tstruct mwl8k_priv *priv = hw->priv;\n\n\t \n\tif (!list_empty(&priv->vif_list)) {\n\t\tif (net_ratelimit())\n\t\t\twiphy_info(hw->wiphy,\n\t\t\t\t   \"not enabling sniffer mode because STA interface is active\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!priv->sniffer_enabled) {\n\t\tif (mwl8k_cmd_enable_sniffer(hw, 1))\n\t\t\treturn 0;\n\t\tpriv->sniffer_enabled = true;\n\t}\n\n\t*total_flags &=\tFIF_ALLMULTI |\n\t\t\tFIF_BCN_PRBRESP_PROMISC | FIF_CONTROL |\n\t\t\tFIF_OTHER_BSS;\n\n\treturn 1;\n}\n\nstatic struct mwl8k_vif *mwl8k_first_vif(struct mwl8k_priv *priv)\n{\n\tif (!list_empty(&priv->vif_list))\n\t\treturn list_entry(priv->vif_list.next, struct mwl8k_vif, list);\n\n\treturn NULL;\n}\n\nstatic void mwl8k_configure_filter(struct ieee80211_hw *hw,\n\t\t\t\t   unsigned int changed_flags,\n\t\t\t\t   unsigned int *total_flags,\n\t\t\t\t   u64 multicast)\n{\n\tstruct mwl8k_priv *priv = hw->priv;\n\tstruct mwl8k_cmd_pkt *cmd = (void *)(unsigned long)multicast;\n\n\t \n\tif (priv->ap_fw) {\n\t\t*total_flags &= FIF_ALLMULTI | FIF_BCN_PRBRESP_PROMISC;\n\t\tkfree(cmd);\n\t\treturn;\n\t}\n\n\t \n\tif (*total_flags & (FIF_CONTROL | FIF_OTHER_BSS) &&\n\t    mwl8k_configure_filter_sniffer(hw, changed_flags, total_flags)) {\n\t\tkfree(cmd);\n\t\treturn;\n\t}\n\n\t \n\t*total_flags &= FIF_ALLMULTI | FIF_BCN_PRBRESP_PROMISC;\n\n\tif (mwl8k_fw_lock(hw)) {\n\t\tkfree(cmd);\n\t\treturn;\n\t}\n\n\tif (priv->sniffer_enabled) {\n\t\tmwl8k_cmd_enable_sniffer(hw, 0);\n\t\tpriv->sniffer_enabled = false;\n\t}\n\n\tif (changed_flags & FIF_BCN_PRBRESP_PROMISC) {\n\t\tif (*total_flags & FIF_BCN_PRBRESP_PROMISC) {\n\t\t\t \n\t\t\tmwl8k_cmd_set_pre_scan(hw);\n\t\t} else {\n\t\t\tstruct mwl8k_vif *mwl8k_vif;\n\t\t\tconst u8 *bssid;\n\n\t\t\t \n\t\t\tmwl8k_vif = mwl8k_first_vif(priv);\n\t\t\tif (mwl8k_vif != NULL)\n\t\t\t\tbssid = mwl8k_vif->vif->bss_conf.bssid;\n\t\t\telse\n\t\t\t\tbssid = \"\\x01\\x00\\x00\\x00\\x00\\x00\";\n\n\t\t\tmwl8k_cmd_set_post_scan(hw, bssid);\n\t\t}\n\t}\n\n\t \n\tif (*total_flags & FIF_ALLMULTI) {\n\t\tkfree(cmd);\n\t\tcmd = __mwl8k_cmd_mac_multicast_adr(hw, 1, NULL);\n\t}\n\n\tif (cmd != NULL) {\n\t\tmwl8k_post_cmd(hw, cmd);\n\t\tkfree(cmd);\n\t}\n\n\tmwl8k_fw_unlock(hw);\n}\n\nstatic int mwl8k_set_rts_threshold(struct ieee80211_hw *hw, u32 value)\n{\n\treturn mwl8k_cmd_set_rts_threshold(hw, value);\n}\n\nstatic int mwl8k_sta_remove(struct ieee80211_hw *hw,\n\t\t\t    struct ieee80211_vif *vif,\n\t\t\t    struct ieee80211_sta *sta)\n{\n\tstruct mwl8k_priv *priv = hw->priv;\n\n\tif (priv->ap_fw)\n\t\treturn mwl8k_cmd_set_new_stn_del(hw, vif, sta->addr);\n\telse\n\t\treturn mwl8k_cmd_update_stadb_del(hw, vif, sta->addr);\n}\n\nstatic int mwl8k_sta_add(struct ieee80211_hw *hw,\n\t\t\t struct ieee80211_vif *vif,\n\t\t\t struct ieee80211_sta *sta)\n{\n\tstruct mwl8k_priv *priv = hw->priv;\n\tint ret;\n\tint i;\n\tstruct mwl8k_vif *mwl8k_vif = MWL8K_VIF(vif);\n\tstruct ieee80211_key_conf *key;\n\n\tif (!priv->ap_fw) {\n\t\tret = mwl8k_cmd_update_stadb_add(hw, vif, sta);\n\t\tif (ret >= 0) {\n\t\t\tMWL8K_STA(sta)->peer_id = ret;\n\t\t\tif (sta->deflink.ht_cap.ht_supported)\n\t\t\t\tMWL8K_STA(sta)->is_ampdu_allowed = true;\n\t\t\tret = 0;\n\t\t}\n\n\t} else {\n\t\tret = mwl8k_cmd_set_new_stn_add(hw, vif, sta);\n\t}\n\n\tfor (i = 0; i < NUM_WEP_KEYS; i++) {\n\t\tkey = IEEE80211_KEY_CONF(mwl8k_vif->wep_key_conf[i].key);\n\t\tif (mwl8k_vif->wep_key_conf[i].enabled)\n\t\t\tmwl8k_set_key(hw, SET_KEY, vif, sta, key);\n\t}\n\treturn ret;\n}\n\nstatic int mwl8k_conf_tx(struct ieee80211_hw *hw,\n\t\t\t struct ieee80211_vif *vif,\n\t\t\t unsigned int link_id, u16 queue,\n\t\t\t const struct ieee80211_tx_queue_params *params)\n{\n\tstruct mwl8k_priv *priv = hw->priv;\n\tint rc;\n\n\trc = mwl8k_fw_lock(hw);\n\tif (!rc) {\n\t\tBUG_ON(queue > MWL8K_TX_WMM_QUEUES - 1);\n\t\tmemcpy(&priv->wmm_params[queue], params, sizeof(*params));\n\n\t\tif (!priv->wmm_enabled)\n\t\t\trc = mwl8k_cmd_set_wmm_mode(hw, 1);\n\n\t\tif (!rc) {\n\t\t\tint q = MWL8K_TX_WMM_QUEUES - 1 - queue;\n\t\t\trc = mwl8k_cmd_set_edca_params(hw, q,\n\t\t\t\t\t\t       params->cw_min,\n\t\t\t\t\t\t       params->cw_max,\n\t\t\t\t\t\t       params->aifs,\n\t\t\t\t\t\t       params->txop);\n\t\t}\n\n\t\tmwl8k_fw_unlock(hw);\n\t}\n\n\treturn rc;\n}\n\nstatic int mwl8k_get_stats(struct ieee80211_hw *hw,\n\t\t\t   struct ieee80211_low_level_stats *stats)\n{\n\treturn mwl8k_cmd_get_stat(hw, stats);\n}\n\nstatic int mwl8k_get_survey(struct ieee80211_hw *hw, int idx,\n\t\t\t\tstruct survey_info *survey)\n{\n\tstruct mwl8k_priv *priv = hw->priv;\n\tstruct ieee80211_conf *conf = &hw->conf;\n\tstruct ieee80211_supported_band *sband;\n\n\tif (priv->ap_fw) {\n\t\tsband = hw->wiphy->bands[NL80211_BAND_2GHZ];\n\n\t\tif (sband && idx >= sband->n_channels) {\n\t\t\tidx -= sband->n_channels;\n\t\t\tsband = NULL;\n\t\t}\n\n\t\tif (!sband)\n\t\t\tsband = hw->wiphy->bands[NL80211_BAND_5GHZ];\n\n\t\tif (!sband || idx >= sband->n_channels)\n\t\t\treturn -ENOENT;\n\n\t\tmemcpy(survey, &priv->survey[idx], sizeof(*survey));\n\t\tsurvey->channel = &sband->channels[idx];\n\n\t\treturn 0;\n\t}\n\n\tif (idx != 0)\n\t\treturn -ENOENT;\n\n\tsurvey->channel = conf->chandef.chan;\n\tsurvey->filled = SURVEY_INFO_NOISE_DBM;\n\tsurvey->noise = priv->noise;\n\n\treturn 0;\n}\n\n#define MAX_AMPDU_ATTEMPTS 5\n\nstatic int\nmwl8k_ampdu_action(struct ieee80211_hw *hw, struct ieee80211_vif *vif,\n\t\t   struct ieee80211_ampdu_params *params)\n{\n\tstruct ieee80211_sta *sta = params->sta;\n\tenum ieee80211_ampdu_mlme_action action = params->action;\n\tu16 tid = params->tid;\n\tu16 *ssn = &params->ssn;\n\tu8 buf_size = params->buf_size;\n\tint i, rc = 0;\n\tstruct mwl8k_priv *priv = hw->priv;\n\tstruct mwl8k_ampdu_stream *stream;\n\tu8 *addr = sta->addr, idx;\n\tstruct mwl8k_sta *sta_info = MWL8K_STA(sta);\n\n\tif (!ieee80211_hw_check(hw, AMPDU_AGGREGATION))\n\t\treturn -ENOTSUPP;\n\n\tspin_lock(&priv->stream_lock);\n\tstream = mwl8k_lookup_stream(hw, addr, tid);\n\n\tswitch (action) {\n\tcase IEEE80211_AMPDU_RX_START:\n\tcase IEEE80211_AMPDU_RX_STOP:\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_START:\n\t\t \n\t\t*ssn = 0;\n\t\tif (stream == NULL) {\n\t\t\t \n\t\t\twiphy_warn(hw->wiphy, \"Unexpected call to %s.  \"\n\t\t\t\t   \"Proceeding anyway.\\n\", __func__);\n\t\t\tstream = mwl8k_add_stream(hw, sta, tid);\n\t\t}\n\t\tif (stream == NULL) {\n\t\t\twiphy_debug(hw->wiphy, \"no free AMPDU streams\\n\");\n\t\t\trc = -EBUSY;\n\t\t\tbreak;\n\t\t}\n\t\tstream->state = AMPDU_STREAM_IN_PROGRESS;\n\n\t\t \n\t\tspin_unlock(&priv->stream_lock);\n\t\tfor (i = 0; i < MAX_AMPDU_ATTEMPTS; i++) {\n\n\t\t\t \n\t\t\tif (!sta_info->is_ampdu_allowed) {\n\t\t\t\tspin_lock(&priv->stream_lock);\n\t\t\t\tmwl8k_remove_stream(hw, stream);\n\t\t\t\tspin_unlock(&priv->stream_lock);\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\n\t\t\trc = mwl8k_check_ba(hw, stream, vif);\n\n\t\t\t \n\t\t\tif (!rc || rc == -EBUSY)\n\t\t\t\tbreak;\n\t\t\t \n\n\t\t\tmsleep(1000);\n\t\t}\n\t\tspin_lock(&priv->stream_lock);\n\t\tif (rc) {\n\t\t\twiphy_err(hw->wiphy, \"Stream for tid %d busy after %d\"\n\t\t\t\t\" attempts\\n\", tid, MAX_AMPDU_ATTEMPTS);\n\t\t\tmwl8k_remove_stream(hw, stream);\n\t\t\trc = -EBUSY;\n\t\t\tbreak;\n\t\t}\n\t\trc = IEEE80211_AMPDU_TX_START_IMMEDIATE;\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_STOP_CONT:\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH:\n\tcase IEEE80211_AMPDU_TX_STOP_FLUSH_CONT:\n\t\tif (stream) {\n\t\t\tif (stream->state == AMPDU_STREAM_ACTIVE) {\n\t\t\t\tidx = stream->idx;\n\t\t\t\tspin_unlock(&priv->stream_lock);\n\t\t\t\tmwl8k_destroy_ba(hw, idx);\n\t\t\t\tspin_lock(&priv->stream_lock);\n\t\t\t}\n\t\t\tmwl8k_remove_stream(hw, stream);\n\t\t}\n\t\tieee80211_stop_tx_ba_cb_irqsafe(vif, addr, tid);\n\t\tbreak;\n\tcase IEEE80211_AMPDU_TX_OPERATIONAL:\n\t\tBUG_ON(stream == NULL);\n\t\tBUG_ON(stream->state != AMPDU_STREAM_IN_PROGRESS);\n\t\tspin_unlock(&priv->stream_lock);\n\t\trc = mwl8k_create_ba(hw, stream, buf_size, vif);\n\t\tspin_lock(&priv->stream_lock);\n\t\tif (!rc)\n\t\t\tstream->state = AMPDU_STREAM_ACTIVE;\n\t\telse {\n\t\t\tidx = stream->idx;\n\t\t\tspin_unlock(&priv->stream_lock);\n\t\t\tmwl8k_destroy_ba(hw, idx);\n\t\t\tspin_lock(&priv->stream_lock);\n\t\t\twiphy_debug(hw->wiphy,\n\t\t\t\t\"Failed adding stream for sta %pM tid %d\\n\",\n\t\t\t\taddr, tid);\n\t\t\tmwl8k_remove_stream(hw, stream);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\trc = -ENOTSUPP;\n\t}\n\n\tspin_unlock(&priv->stream_lock);\n\treturn rc;\n}\n\nstatic void mwl8k_sw_scan_start(struct ieee80211_hw *hw,\n\t\t\t\tstruct ieee80211_vif *vif,\n\t\t\t\tconst u8 *mac_addr)\n{\n\tstruct mwl8k_priv *priv = hw->priv;\n\tu8 tmp;\n\n\tif (!priv->ap_fw)\n\t\treturn;\n\n\t \n\tpriv->channel_time = 0;\n\tioread32(priv->regs + BBU_RXRDY_CNT_REG);\n\tioread32(priv->regs + NOK_CCA_CNT_REG);\n\tmwl8k_cmd_bbp_reg_access(priv->hw, 0, BBU_AVG_NOISE_VAL, &tmp);\n\n\tpriv->sw_scan_start = true;\n}\n\nstatic void mwl8k_sw_scan_complete(struct ieee80211_hw *hw,\n\t\t\t\t   struct ieee80211_vif *vif)\n{\n\tstruct mwl8k_priv *priv = hw->priv;\n\tu8 tmp;\n\n\tif (!priv->ap_fw)\n\t\treturn;\n\n\tpriv->sw_scan_start = false;\n\n\t \n\tpriv->channel_time = 0;\n\tioread32(priv->regs + BBU_RXRDY_CNT_REG);\n\tioread32(priv->regs + NOK_CCA_CNT_REG);\n\tmwl8k_cmd_bbp_reg_access(priv->hw, 0, BBU_AVG_NOISE_VAL, &tmp);\n}\n\nstatic const struct ieee80211_ops mwl8k_ops = {\n\t.tx\t\t\t= mwl8k_tx,\n\t.wake_tx_queue\t\t= ieee80211_handle_wake_tx_queue,\n\t.start\t\t\t= mwl8k_start,\n\t.stop\t\t\t= mwl8k_stop,\n\t.add_interface\t\t= mwl8k_add_interface,\n\t.remove_interface\t= mwl8k_remove_interface,\n\t.config\t\t\t= mwl8k_config,\n\t.bss_info_changed\t= mwl8k_bss_info_changed,\n\t.prepare_multicast\t= mwl8k_prepare_multicast,\n\t.configure_filter\t= mwl8k_configure_filter,\n\t.set_key                = mwl8k_set_key,\n\t.set_rts_threshold\t= mwl8k_set_rts_threshold,\n\t.sta_add\t\t= mwl8k_sta_add,\n\t.sta_remove\t\t= mwl8k_sta_remove,\n\t.conf_tx\t\t= mwl8k_conf_tx,\n\t.get_stats\t\t= mwl8k_get_stats,\n\t.get_survey\t\t= mwl8k_get_survey,\n\t.ampdu_action\t\t= mwl8k_ampdu_action,\n\t.sw_scan_start\t\t= mwl8k_sw_scan_start,\n\t.sw_scan_complete\t= mwl8k_sw_scan_complete,\n};\n\nstatic void mwl8k_finalize_join_worker(struct work_struct *work)\n{\n\tstruct mwl8k_priv *priv =\n\t\tcontainer_of(work, struct mwl8k_priv, finalize_join_worker);\n\tstruct sk_buff *skb = priv->beacon_skb;\n\tstruct ieee80211_mgmt *mgmt = (void *)skb->data;\n\tint len = skb->len - offsetof(struct ieee80211_mgmt, u.beacon.variable);\n\tconst u8 *tim = cfg80211_find_ie(WLAN_EID_TIM,\n\t\t\t\t\t mgmt->u.beacon.variable, len);\n\tint dtim_period = 1;\n\n\tif (tim && tim[1] >= 2)\n\t\tdtim_period = tim[3];\n\n\tmwl8k_cmd_finalize_join(priv->hw, skb->data, skb->len, dtim_period);\n\n\tdev_kfree_skb(skb);\n\tpriv->beacon_skb = NULL;\n}\n\nenum {\n\tMWL8363 = 0,\n\tMWL8687,\n\tMWL8366,\n\tMWL8764,\n};\n\n#define MWL8K_8366_AP_FW_API 3\n#define _MWL8K_8366_AP_FW(api) \"mwl8k/fmimage_8366_ap-\" #api \".fw\"\n#define MWL8K_8366_AP_FW(api) _MWL8K_8366_AP_FW(api)\n\n#define MWL8K_8764_AP_FW_API 1\n#define _MWL8K_8764_AP_FW(api) \"mwl8k/fmimage_8764_ap-\" #api \".fw\"\n#define MWL8K_8764_AP_FW(api) _MWL8K_8764_AP_FW(api)\n\nstatic struct mwl8k_device_info mwl8k_info_tbl[] = {\n\t[MWL8363] = {\n\t\t.part_name\t= \"88w8363\",\n\t\t.helper_image\t= \"mwl8k/helper_8363.fw\",\n\t\t.fw_image_sta\t= \"mwl8k/fmimage_8363.fw\",\n\t},\n\t[MWL8687] = {\n\t\t.part_name\t= \"88w8687\",\n\t\t.helper_image\t= \"mwl8k/helper_8687.fw\",\n\t\t.fw_image_sta\t= \"mwl8k/fmimage_8687.fw\",\n\t},\n\t[MWL8366] = {\n\t\t.part_name\t= \"88w8366\",\n\t\t.helper_image\t= \"mwl8k/helper_8366.fw\",\n\t\t.fw_image_sta\t= \"mwl8k/fmimage_8366.fw\",\n\t\t.fw_image_ap\t= MWL8K_8366_AP_FW(MWL8K_8366_AP_FW_API),\n\t\t.fw_api_ap\t= MWL8K_8366_AP_FW_API,\n\t\t.ap_rxd_ops\t= &rxd_ap_ops,\n\t},\n\t[MWL8764] = {\n\t\t.part_name\t= \"88w8764\",\n\t\t.fw_image_ap\t= MWL8K_8764_AP_FW(MWL8K_8764_AP_FW_API),\n\t\t.fw_api_ap\t= MWL8K_8764_AP_FW_API,\n\t\t.ap_rxd_ops\t= &rxd_ap_ops,\n\t},\n};\n\nMODULE_FIRMWARE(\"mwl8k/helper_8363.fw\");\nMODULE_FIRMWARE(\"mwl8k/fmimage_8363.fw\");\nMODULE_FIRMWARE(\"mwl8k/helper_8687.fw\");\nMODULE_FIRMWARE(\"mwl8k/fmimage_8687.fw\");\nMODULE_FIRMWARE(\"mwl8k/helper_8366.fw\");\nMODULE_FIRMWARE(\"mwl8k/fmimage_8366.fw\");\nMODULE_FIRMWARE(MWL8K_8366_AP_FW(MWL8K_8366_AP_FW_API));\n\nstatic const struct pci_device_id mwl8k_pci_id_table[] = {\n\t{ PCI_VDEVICE(MARVELL, 0x2a0a), .driver_data = MWL8363, },\n\t{ PCI_VDEVICE(MARVELL, 0x2a0c), .driver_data = MWL8363, },\n\t{ PCI_VDEVICE(MARVELL, 0x2a24), .driver_data = MWL8363, },\n\t{ PCI_VDEVICE(MARVELL, 0x2a2b), .driver_data = MWL8687, },\n\t{ PCI_VDEVICE(MARVELL, 0x2a30), .driver_data = MWL8687, },\n\t{ PCI_VDEVICE(MARVELL, 0x2a40), .driver_data = MWL8366, },\n\t{ PCI_VDEVICE(MARVELL, 0x2a41), .driver_data = MWL8366, },\n\t{ PCI_VDEVICE(MARVELL, 0x2a42), .driver_data = MWL8366, },\n\t{ PCI_VDEVICE(MARVELL, 0x2a43), .driver_data = MWL8366, },\n\t{ PCI_VDEVICE(MARVELL, 0x2b36), .driver_data = MWL8764, },\n\t{ },\n};\nMODULE_DEVICE_TABLE(pci, mwl8k_pci_id_table);\n\nstatic int mwl8k_request_alt_fw(struct mwl8k_priv *priv)\n{\n\tint rc;\n\tprintk(KERN_ERR \"%s: Error requesting preferred fw %s.\\n\"\n\t       \"Trying alternative firmware %s\\n\", pci_name(priv->pdev),\n\t       priv->fw_pref, priv->fw_alt);\n\trc = mwl8k_request_fw(priv, priv->fw_alt, &priv->fw_ucode, true);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Error requesting alt fw %s\\n\",\n\t\t       pci_name(priv->pdev), priv->fw_alt);\n\t\treturn rc;\n\t}\n\treturn 0;\n}\n\nstatic int mwl8k_firmware_load_success(struct mwl8k_priv *priv);\nstatic void mwl8k_fw_state_machine(const struct firmware *fw, void *context)\n{\n\tstruct mwl8k_priv *priv = context;\n\tstruct mwl8k_device_info *di = priv->device_info;\n\tint rc;\n\n\tswitch (priv->fw_state) {\n\tcase FW_STATE_INIT:\n\t\tif (!fw) {\n\t\t\tprintk(KERN_ERR \"%s: Error requesting helper fw %s\\n\",\n\t\t\t       pci_name(priv->pdev), di->helper_image);\n\t\t\tgoto fail;\n\t\t}\n\t\tpriv->fw_helper = fw;\n\t\trc = mwl8k_request_fw(priv, priv->fw_pref, &priv->fw_ucode,\n\t\t\t\t      true);\n\t\tif (rc && priv->fw_alt) {\n\t\t\trc = mwl8k_request_alt_fw(priv);\n\t\t\tif (rc)\n\t\t\t\tgoto fail;\n\t\t\tpriv->fw_state = FW_STATE_LOADING_ALT;\n\t\t} else if (rc)\n\t\t\tgoto fail;\n\t\telse\n\t\t\tpriv->fw_state = FW_STATE_LOADING_PREF;\n\t\tbreak;\n\n\tcase FW_STATE_LOADING_PREF:\n\t\tif (!fw) {\n\t\t\tif (priv->fw_alt) {\n\t\t\t\trc = mwl8k_request_alt_fw(priv);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto fail;\n\t\t\t\tpriv->fw_state = FW_STATE_LOADING_ALT;\n\t\t\t} else\n\t\t\t\tgoto fail;\n\t\t} else {\n\t\t\tpriv->fw_ucode = fw;\n\t\t\trc = mwl8k_firmware_load_success(priv);\n\t\t\tif (rc)\n\t\t\t\tgoto fail;\n\t\t\telse\n\t\t\t\tcomplete(&priv->firmware_loading_complete);\n\t\t}\n\t\tbreak;\n\n\tcase FW_STATE_LOADING_ALT:\n\t\tif (!fw) {\n\t\t\tprintk(KERN_ERR \"%s: Error requesting alt fw %s\\n\",\n\t\t\t       pci_name(priv->pdev), di->helper_image);\n\t\t\tgoto fail;\n\t\t}\n\t\tpriv->fw_ucode = fw;\n\t\trc = mwl8k_firmware_load_success(priv);\n\t\tif (rc)\n\t\t\tgoto fail;\n\t\telse\n\t\t\tcomplete(&priv->firmware_loading_complete);\n\t\tbreak;\n\n\tdefault:\n\t\tprintk(KERN_ERR \"%s: Unexpected firmware loading state: %d\\n\",\n\t\t       MWL8K_NAME, priv->fw_state);\n\t\tBUG_ON(1);\n\t}\n\n\treturn;\n\nfail:\n\tpriv->fw_state = FW_STATE_ERROR;\n\tcomplete(&priv->firmware_loading_complete);\n\tmwl8k_release_firmware(priv);\n\tdevice_release_driver(&priv->pdev->dev);\n}\n\n#define MAX_RESTART_ATTEMPTS 1\nstatic int mwl8k_init_firmware(struct ieee80211_hw *hw, char *fw_image,\n\t\t\t       bool nowait)\n{\n\tstruct mwl8k_priv *priv = hw->priv;\n\tint rc;\n\tint count = MAX_RESTART_ATTEMPTS;\n\nretry:\n\t \n\tmwl8k_hw_reset(priv);\n\n\t \n\trc = mwl8k_request_firmware(priv, fw_image, nowait);\n\tif (rc) {\n\t\twiphy_err(hw->wiphy, \"Firmware files not found\\n\");\n\t\treturn rc;\n\t}\n\n\tif (nowait)\n\t\treturn rc;\n\n\t \n\trc = mwl8k_load_firmware(hw);\n\tif (rc)\n\t\twiphy_err(hw->wiphy, \"Cannot start firmware\\n\");\n\n\t \n\tmwl8k_release_firmware(priv);\n\n\tif (rc && count) {\n\t\t \n\t\tcount--;\n\t\twiphy_err(hw->wiphy, \"Trying to reload the firmware again\\n\");\n\t\tmsleep(20);\n\t\tgoto retry;\n\t}\n\n\treturn rc;\n}\n\nstatic int mwl8k_init_txqs(struct ieee80211_hw *hw)\n{\n\tstruct mwl8k_priv *priv = hw->priv;\n\tint rc = 0;\n\tint i;\n\n\tfor (i = 0; i < mwl8k_tx_queues(priv); i++) {\n\t\trc = mwl8k_txq_init(hw, i);\n\t\tif (rc)\n\t\t\tbreak;\n\t\tif (priv->ap_fw)\n\t\t\tiowrite32(priv->txq[i].txd_dma,\n\t\t\t\t  priv->sram + priv->txq_offset[i]);\n\t}\n\treturn rc;\n}\n\n \nstatic int mwl8k_probe_hw(struct ieee80211_hw *hw)\n{\n\tstruct mwl8k_priv *priv = hw->priv;\n\tint rc = 0;\n\tint i;\n\n\tif (priv->ap_fw) {\n\t\tpriv->rxd_ops = priv->device_info->ap_rxd_ops;\n\t\tif (priv->rxd_ops == NULL) {\n\t\t\twiphy_err(hw->wiphy,\n\t\t\t\t  \"Driver does not have AP firmware image support for this hardware\\n\");\n\t\t\trc = -ENOENT;\n\t\t\tgoto err_stop_firmware;\n\t\t}\n\t} else {\n\t\tpriv->rxd_ops = &rxd_sta_ops;\n\t}\n\n\tpriv->sniffer_enabled = false;\n\tpriv->wmm_enabled = false;\n\tpriv->pending_tx_pkts = 0;\n\tatomic_set(&priv->watchdog_event_pending, 0);\n\n\trc = mwl8k_rxq_init(hw, 0);\n\tif (rc)\n\t\tgoto err_stop_firmware;\n\trxq_refill(hw, 0, INT_MAX);\n\n\t \n\tpriv->num_ampdu_queues = 0;\n\tif (!priv->ap_fw) {\n\t\trc = mwl8k_init_txqs(hw);\n\t\tif (rc)\n\t\t\tgoto err_free_queues;\n\t}\n\n\tiowrite32(0, priv->regs + MWL8K_HIU_A2H_INTERRUPT_STATUS);\n\tiowrite32(0, priv->regs + MWL8K_HIU_A2H_INTERRUPT_MASK);\n\tiowrite32(MWL8K_A2H_INT_TX_DONE|MWL8K_A2H_INT_RX_READY|\n\t\t  MWL8K_A2H_INT_BA_WATCHDOG,\n\t\t  priv->regs + MWL8K_HIU_A2H_INTERRUPT_CLEAR_SEL);\n\tiowrite32(MWL8K_A2H_INT_OPC_DONE,\n\t\t  priv->regs + MWL8K_HIU_A2H_INTERRUPT_STATUS_MASK);\n\n\trc = request_irq(priv->pdev->irq, mwl8k_interrupt,\n\t\t\t IRQF_SHARED, MWL8K_NAME, hw);\n\tif (rc) {\n\t\twiphy_err(hw->wiphy, \"failed to register IRQ handler\\n\");\n\t\tgoto err_free_queues;\n\t}\n\n\t \n\tif (!priv->hw_restart_in_progress)\n\t\tmemset(priv->ampdu, 0, sizeof(priv->ampdu));\n\n\t \n\tiowrite32(MWL8K_A2H_EVENTS, priv->regs + MWL8K_HIU_A2H_INTERRUPT_MASK);\n\n\t \n\tif (priv->ap_fw) {\n\t\trc = mwl8k_cmd_get_hw_spec_ap(hw);\n\t\tif (!rc)\n\t\t\trc = mwl8k_init_txqs(hw);\n\t\tif (!rc)\n\t\t\trc = mwl8k_cmd_set_hw_spec(hw);\n\t} else {\n\t\trc = mwl8k_cmd_get_hw_spec_sta(hw);\n\t}\n\tif (rc) {\n\t\twiphy_err(hw->wiphy, \"Cannot initialise firmware\\n\");\n\t\tgoto err_free_irq;\n\t}\n\n\t \n\trc = mwl8k_cmd_radio_disable(hw);\n\tif (rc) {\n\t\twiphy_err(hw->wiphy, \"Cannot disable\\n\");\n\t\tgoto err_free_irq;\n\t}\n\n\t \n\trc = mwl8k_cmd_set_mac_addr(hw, NULL, \"\\x00\\x00\\x00\\x00\\x00\\x00\");\n\tif (rc) {\n\t\twiphy_err(hw->wiphy, \"Cannot clear MAC address\\n\");\n\t\tgoto err_free_irq;\n\t}\n\n\t \n\trc = mwl8k_cmd_rf_antenna(hw, MWL8K_RF_ANTENNA_RX, 0x3);\n\tif (rc)\n\t\twiphy_warn(hw->wiphy, \"failed to set # of RX antennas\");\n\trc = mwl8k_cmd_rf_antenna(hw, MWL8K_RF_ANTENNA_TX, 0x7);\n\tif (rc)\n\t\twiphy_warn(hw->wiphy, \"failed to set # of TX antennas\");\n\n\n\t \n\tiowrite32(0, priv->regs + MWL8K_HIU_A2H_INTERRUPT_MASK);\n\tfree_irq(priv->pdev->irq, hw);\n\n\twiphy_info(hw->wiphy, \"%s v%d, %pm, %s firmware %u.%u.%u.%u\\n\",\n\t\t   priv->device_info->part_name,\n\t\t   priv->hw_rev, hw->wiphy->perm_addr,\n\t\t   priv->ap_fw ? \"AP\" : \"STA\",\n\t\t   (priv->fw_rev >> 24) & 0xff, (priv->fw_rev >> 16) & 0xff,\n\t\t   (priv->fw_rev >> 8) & 0xff, priv->fw_rev & 0xff);\n\n\treturn 0;\n\nerr_free_irq:\n\tiowrite32(0, priv->regs + MWL8K_HIU_A2H_INTERRUPT_MASK);\n\tfree_irq(priv->pdev->irq, hw);\n\nerr_free_queues:\n\tfor (i = 0; i < mwl8k_tx_queues(priv); i++)\n\t\tmwl8k_txq_deinit(hw, i);\n\tmwl8k_rxq_deinit(hw, 0);\n\nerr_stop_firmware:\n\tmwl8k_hw_reset(priv);\n\n\treturn rc;\n}\n\n \nstatic int mwl8k_reload_firmware(struct ieee80211_hw *hw, char *fw_image)\n{\n\tint i, rc = 0;\n\tstruct mwl8k_priv *priv = hw->priv;\n\tstruct mwl8k_vif *vif, *tmp_vif;\n\n\tmwl8k_stop(hw);\n\tmwl8k_rxq_deinit(hw, 0);\n\n\t \n\tif (priv->hw_restart_in_progress)\n\t\tlist_for_each_entry_safe(vif, tmp_vif, &priv->vif_list, list)\n\t\t\tmwl8k_remove_vif(priv, vif);\n\n\tfor (i = 0; i < mwl8k_tx_queues(priv); i++)\n\t\tmwl8k_txq_deinit(hw, i);\n\n\trc = mwl8k_init_firmware(hw, fw_image, false);\n\tif (rc)\n\t\tgoto fail;\n\n\trc = mwl8k_probe_hw(hw);\n\tif (rc)\n\t\tgoto fail;\n\n\tif (priv->hw_restart_in_progress)\n\t\treturn rc;\n\n\trc = mwl8k_start(hw);\n\tif (rc)\n\t\tgoto fail;\n\n\trc = mwl8k_config(hw, ~0);\n\tif (rc)\n\t\tgoto fail;\n\n\tfor (i = 0; i < MWL8K_TX_WMM_QUEUES; i++) {\n\t\trc = mwl8k_conf_tx(hw, NULL, 0, i, &priv->wmm_params[i]);\n\t\tif (rc)\n\t\t\tgoto fail;\n\t}\n\n\treturn rc;\n\nfail:\n\tprintk(KERN_WARNING \"mwl8k: Failed to reload firmware image.\\n\");\n\treturn rc;\n}\n\nstatic const struct ieee80211_iface_limit ap_if_limits[] = {\n\t{ .max = 8,\t.types = BIT(NL80211_IFTYPE_AP) },\n\t{ .max = 1,\t.types = BIT(NL80211_IFTYPE_STATION) },\n};\n\nstatic const struct ieee80211_iface_combination ap_if_comb = {\n\t.limits = ap_if_limits,\n\t.n_limits = ARRAY_SIZE(ap_if_limits),\n\t.max_interfaces = 8,\n\t.num_different_channels = 1,\n};\n\n\nstatic int mwl8k_firmware_load_success(struct mwl8k_priv *priv)\n{\n\tstruct ieee80211_hw *hw = priv->hw;\n\tint i, rc;\n\n\trc = mwl8k_load_firmware(hw);\n\tmwl8k_release_firmware(priv);\n\tif (rc) {\n\t\twiphy_err(hw->wiphy, \"Cannot start firmware\\n\");\n\t\treturn rc;\n\t}\n\n\t \n\thw->extra_tx_headroom =\n\t\tsizeof(struct mwl8k_dma_data) - sizeof(struct ieee80211_cts);\n\n\thw->extra_tx_headroom -= priv->ap_fw ? REDUCED_TX_HEADROOM : 0;\n\n\thw->queues = MWL8K_TX_WMM_QUEUES;\n\n\t \n\tieee80211_hw_set(hw, SIGNAL_DBM);\n\tieee80211_hw_set(hw, HAS_RATE_CONTROL);\n\n\t \n\tif (priv->ap_fw)\n\t\tieee80211_hw_set(hw, AP_LINK_PS);\n\n\thw->vif_data_size = sizeof(struct mwl8k_vif);\n\thw->sta_data_size = sizeof(struct mwl8k_sta);\n\n\tpriv->macids_used = 0;\n\tINIT_LIST_HEAD(&priv->vif_list);\n\n\t \n\tpriv->radio_on = false;\n\tpriv->radio_short_preamble = false;\n\n\t \n\tINIT_WORK(&priv->finalize_join_worker, mwl8k_finalize_join_worker);\n\t \n\tINIT_WORK(&priv->watchdog_ba_handle, mwl8k_watchdog_ba_events);\n\t \n\tINIT_WORK(&priv->fw_reload, mwl8k_hw_restart_work);\n\n\t \n\ttasklet_setup(&priv->poll_tx_task, mwl8k_tx_poll);\n\ttasklet_disable(&priv->poll_tx_task);\n\ttasklet_setup(&priv->poll_rx_task, mwl8k_rx_poll);\n\ttasklet_disable(&priv->poll_rx_task);\n\n\t \n\tpriv->cookie = dma_alloc_coherent(&priv->pdev->dev, 4,\n\t\t\t\t\t  &priv->cookie_dma, GFP_KERNEL);\n\tif (priv->cookie == NULL)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&priv->fw_mutex);\n\tpriv->fw_mutex_owner = NULL;\n\tpriv->fw_mutex_depth = 0;\n\tpriv->hostcmd_wait = NULL;\n\n\tspin_lock_init(&priv->tx_lock);\n\n\tspin_lock_init(&priv->stream_lock);\n\n\tpriv->tx_wait = NULL;\n\n\trc = mwl8k_probe_hw(hw);\n\tif (rc)\n\t\tgoto err_free_cookie;\n\n\thw->wiphy->interface_modes = 0;\n\n\tif (priv->ap_macids_supported || priv->device_info->fw_image_ap) {\n\t\thw->wiphy->interface_modes |= BIT(NL80211_IFTYPE_AP);\n\t\thw->wiphy->interface_modes |= BIT(NL80211_IFTYPE_STATION);\n\t\thw->wiphy->iface_combinations = &ap_if_comb;\n\t\thw->wiphy->n_iface_combinations = 1;\n\t}\n\n\tif (priv->sta_macids_supported || priv->device_info->fw_image_sta)\n\t\thw->wiphy->interface_modes |= BIT(NL80211_IFTYPE_STATION);\n\n\twiphy_ext_feature_set(hw->wiphy, NL80211_EXT_FEATURE_CQM_RSSI_LIST);\n\n\trc = ieee80211_register_hw(hw);\n\tif (rc) {\n\t\twiphy_err(hw->wiphy, \"Cannot register device\\n\");\n\t\tgoto err_unprobe_hw;\n\t}\n\n\treturn 0;\n\nerr_unprobe_hw:\n\tfor (i = 0; i < mwl8k_tx_queues(priv); i++)\n\t\tmwl8k_txq_deinit(hw, i);\n\tmwl8k_rxq_deinit(hw, 0);\n\nerr_free_cookie:\n\tif (priv->cookie != NULL)\n\t\tdma_free_coherent(&priv->pdev->dev, 4, priv->cookie,\n\t\t\t\t  priv->cookie_dma);\n\n\treturn rc;\n}\nstatic int mwl8k_probe(struct pci_dev *pdev,\n\t\t\t\t const struct pci_device_id *id)\n{\n\tstatic int printed_version;\n\tstruct ieee80211_hw *hw;\n\tstruct mwl8k_priv *priv;\n\tstruct mwl8k_device_info *di;\n\tint rc;\n\n\tif (!printed_version) {\n\t\tprintk(KERN_INFO \"%s version %s\\n\", MWL8K_DESC, MWL8K_VERSION);\n\t\tprinted_version = 1;\n\t}\n\n\n\trc = pci_enable_device(pdev);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Cannot enable new PCI device\\n\",\n\t\t       MWL8K_NAME);\n\t\treturn rc;\n\t}\n\n\trc = pci_request_regions(pdev, MWL8K_NAME);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"%s: Cannot obtain PCI resources\\n\",\n\t\t       MWL8K_NAME);\n\t\tgoto err_disable_device;\n\t}\n\n\tpci_set_master(pdev);\n\n\n\thw = ieee80211_alloc_hw(sizeof(*priv), &mwl8k_ops);\n\tif (hw == NULL) {\n\t\tprintk(KERN_ERR \"%s: ieee80211 alloc failed\\n\", MWL8K_NAME);\n\t\trc = -ENOMEM;\n\t\tgoto err_free_reg;\n\t}\n\n\tSET_IEEE80211_DEV(hw, &pdev->dev);\n\tpci_set_drvdata(pdev, hw);\n\n\tpriv = hw->priv;\n\tpriv->hw = hw;\n\tpriv->pdev = pdev;\n\tpriv->device_info = &mwl8k_info_tbl[id->driver_data];\n\n\tif (id->driver_data == MWL8764)\n\t\tpriv->is_8764 = true;\n\n\tpriv->sram = pci_iomap(pdev, 0, 0x10000);\n\tif (priv->sram == NULL) {\n\t\twiphy_err(hw->wiphy, \"Cannot map device SRAM\\n\");\n\t\trc = -EIO;\n\t\tgoto err_iounmap;\n\t}\n\n\t \n\tpriv->regs = pci_iomap(pdev, 1, 0x10000);\n\tif (priv->regs == NULL) {\n\t\tpriv->regs = pci_iomap(pdev, 2, 0x10000);\n\t\tif (priv->regs == NULL) {\n\t\t\twiphy_err(hw->wiphy, \"Cannot map device registers\\n\");\n\t\t\trc = -EIO;\n\t\t\tgoto err_iounmap;\n\t\t}\n\t}\n\n\t \n\tinit_completion(&priv->firmware_loading_complete);\n\tdi = priv->device_info;\n\tif (ap_mode_default && di->fw_image_ap) {\n\t\tpriv->fw_pref = di->fw_image_ap;\n\t\tpriv->fw_alt = di->fw_image_sta;\n\t} else if (!ap_mode_default && di->fw_image_sta) {\n\t\tpriv->fw_pref = di->fw_image_sta;\n\t\tpriv->fw_alt = di->fw_image_ap;\n\t} else if (ap_mode_default && !di->fw_image_ap && di->fw_image_sta) {\n\t\tprintk(KERN_WARNING \"AP fw is unavailable.  Using STA fw.\");\n\t\tpriv->fw_pref = di->fw_image_sta;\n\t} else if (!ap_mode_default && !di->fw_image_sta && di->fw_image_ap) {\n\t\tprintk(KERN_WARNING \"STA fw is unavailable.  Using AP fw.\");\n\t\tpriv->fw_pref = di->fw_image_ap;\n\t}\n\trc = mwl8k_init_firmware(hw, priv->fw_pref, true);\n\tif (rc)\n\t\tgoto err_stop_firmware;\n\n\tpriv->hw_restart_in_progress = false;\n\n\tpriv->running_bsses = 0;\n\n\treturn rc;\n\nerr_stop_firmware:\n\tmwl8k_hw_reset(priv);\n\nerr_iounmap:\n\tif (priv->regs != NULL)\n\t\tpci_iounmap(pdev, priv->regs);\n\n\tif (priv->sram != NULL)\n\t\tpci_iounmap(pdev, priv->sram);\n\n\tieee80211_free_hw(hw);\n\nerr_free_reg:\n\tpci_release_regions(pdev);\n\nerr_disable_device:\n\tpci_disable_device(pdev);\n\n\treturn rc;\n}\n\nstatic void mwl8k_remove(struct pci_dev *pdev)\n{\n\tstruct ieee80211_hw *hw = pci_get_drvdata(pdev);\n\tstruct mwl8k_priv *priv;\n\tint i;\n\n\tif (hw == NULL)\n\t\treturn;\n\tpriv = hw->priv;\n\n\twait_for_completion(&priv->firmware_loading_complete);\n\n\tif (priv->fw_state == FW_STATE_ERROR) {\n\t\tmwl8k_hw_reset(priv);\n\t\tgoto unmap;\n\t}\n\n\tieee80211_stop_queues(hw);\n\n\tieee80211_unregister_hw(hw);\n\n\t \n\ttasklet_kill(&priv->poll_tx_task);\n\ttasklet_kill(&priv->poll_rx_task);\n\n\t \n\tmwl8k_hw_reset(priv);\n\n\t \n\tfor (i = 0; i < mwl8k_tx_queues(priv); i++)\n\t\tmwl8k_txq_reclaim(hw, i, INT_MAX, 1);\n\n\tfor (i = 0; i < mwl8k_tx_queues(priv); i++)\n\t\tmwl8k_txq_deinit(hw, i);\n\n\tmwl8k_rxq_deinit(hw, 0);\n\n\tdma_free_coherent(&priv->pdev->dev, 4, priv->cookie, priv->cookie_dma);\n\nunmap:\n\tpci_iounmap(pdev, priv->regs);\n\tpci_iounmap(pdev, priv->sram);\n\tieee80211_free_hw(hw);\n\tpci_release_regions(pdev);\n\tpci_disable_device(pdev);\n}\n\nstatic struct pci_driver mwl8k_driver = {\n\t.name\t\t= MWL8K_NAME,\n\t.id_table\t= mwl8k_pci_id_table,\n\t.probe\t\t= mwl8k_probe,\n\t.remove\t\t= mwl8k_remove,\n};\n\nmodule_pci_driver(mwl8k_driver);\n\nMODULE_DESCRIPTION(MWL8K_DESC);\nMODULE_VERSION(MWL8K_VERSION);\nMODULE_AUTHOR(\"Lennert Buytenhek <buytenh@marvell.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}