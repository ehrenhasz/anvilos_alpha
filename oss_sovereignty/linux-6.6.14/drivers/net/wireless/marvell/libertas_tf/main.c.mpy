{
  "module_name": "main.c",
  "hash_id": "3c0cc3a7f5b6c3aa464253ec815c4900b699ca0382240d26ece4403c0d60cf46",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/marvell/libertas_tf/main.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/hardirq.h>\n#include <linux/slab.h>\n\n#include <linux/etherdevice.h>\n#include <linux/module.h>\n#include \"libertas_tf.h\"\n\n \n#define LBTF_FW_VER_MIN\t\t0x05840300\n#define LBTF_FW_VER_MAX\t\t0x0584ffff\n\n \nunsigned int lbtf_debug;\nEXPORT_SYMBOL_GPL(lbtf_debug);\nmodule_param_named(libertas_tf_debug, lbtf_debug, int, 0644);\n\nstruct workqueue_struct *lbtf_wq;\n\nstatic const struct ieee80211_channel lbtf_channels[] = {\n\t{ .center_freq = 2412, .hw_value = 1 },\n\t{ .center_freq = 2417, .hw_value = 2 },\n\t{ .center_freq = 2422, .hw_value = 3 },\n\t{ .center_freq = 2427, .hw_value = 4 },\n\t{ .center_freq = 2432, .hw_value = 5 },\n\t{ .center_freq = 2437, .hw_value = 6 },\n\t{ .center_freq = 2442, .hw_value = 7 },\n\t{ .center_freq = 2447, .hw_value = 8 },\n\t{ .center_freq = 2452, .hw_value = 9 },\n\t{ .center_freq = 2457, .hw_value = 10 },\n\t{ .center_freq = 2462, .hw_value = 11 },\n\t{ .center_freq = 2467, .hw_value = 12 },\n\t{ .center_freq = 2472, .hw_value = 13 },\n\t{ .center_freq = 2484, .hw_value = 14 },\n};\n\n \nstatic const struct ieee80211_rate lbtf_rates[] = {\n\t{ .bitrate = 10,\n\t  .hw_value = 0, },\n\t{ .bitrate = 20,\n\t  .hw_value = 1,\n\t  .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 55,\n\t  .hw_value = 2,\n\t  .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 110,\n\t  .hw_value = 3,\n\t  .flags = IEEE80211_RATE_SHORT_PREAMBLE },\n\t{ .bitrate = 60,\n\t  .hw_value = 5,\n\t  .flags = 0 },\n\t{ .bitrate = 90,\n\t  .hw_value = 6,\n\t  .flags = 0 },\n\t{ .bitrate = 120,\n\t  .hw_value = 7,\n\t  .flags = 0 },\n\t{ .bitrate = 180,\n\t  .hw_value = 8,\n\t  .flags = 0 },\n\t{ .bitrate = 240,\n\t  .hw_value = 9,\n\t  .flags = 0 },\n\t{ .bitrate = 360,\n\t  .hw_value = 10,\n\t  .flags = 0 },\n\t{ .bitrate = 480,\n\t  .hw_value = 11,\n\t  .flags = 0 },\n\t{ .bitrate = 540,\n\t  .hw_value = 12,\n\t  .flags = 0 },\n};\n\nstatic void lbtf_cmd_work(struct work_struct *work)\n{\n\tstruct lbtf_private *priv = container_of(work, struct lbtf_private,\n\t\t\t\t\t cmd_work);\n\n\tlbtf_deb_enter(LBTF_DEB_CMD);\n\n\tspin_lock_irq(&priv->driver_lock);\n\t \n\tif (priv->cmd_response_rxed) {\n\t\tpriv->cmd_response_rxed = 0;\n\t\tspin_unlock_irq(&priv->driver_lock);\n\t\tlbtf_process_rx_command(priv);\n\t\tspin_lock_irq(&priv->driver_lock);\n\t}\n\n\tif (priv->cmd_timed_out && priv->cur_cmd) {\n\t\tstruct cmd_ctrl_node *cmdnode = priv->cur_cmd;\n\n\t\tif (++priv->nr_retries > 10) {\n\t\t\tlbtf_complete_command(priv, cmdnode,\n\t\t\t\t\t      -ETIMEDOUT);\n\t\t\tpriv->nr_retries = 0;\n\t\t} else {\n\t\t\tpriv->cur_cmd = NULL;\n\n\t\t\t \n\t\t\tlist_add(&cmdnode->list, &priv->cmdpendingq);\n\t\t}\n\t}\n\tpriv->cmd_timed_out = 0;\n\tspin_unlock_irq(&priv->driver_lock);\n\n\t \n\tif (!priv->cur_cmd)\n\t\tlbtf_execute_next_command(priv);\n\n\tlbtf_deb_leave(LBTF_DEB_CMD);\n}\n\n \nstatic void command_timer_fn(struct timer_list *t)\n{\n\tstruct lbtf_private *priv = from_timer(priv, t, command_timer);\n\tunsigned long flags;\n\tlbtf_deb_enter(LBTF_DEB_CMD);\n\n\tspin_lock_irqsave(&priv->driver_lock, flags);\n\n\tif (!priv->cur_cmd) {\n\t\tprintk(KERN_DEBUG \"libertastf: command timer expired; \"\n\t\t\t\t  \"no pending command\\n\");\n\t\tgoto out;\n\t}\n\n\tprintk(KERN_DEBUG \"libertas: command %x timed out\\n\",\n\t\tle16_to_cpu(priv->cur_cmd->cmdbuf->command));\n\n\tpriv->cmd_timed_out = 1;\n\tqueue_work(lbtf_wq, &priv->cmd_work);\nout:\n\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\tlbtf_deb_leave(LBTF_DEB_CMD);\n}\n\nstatic int lbtf_init_adapter(struct lbtf_private *priv)\n{\n\tlbtf_deb_enter(LBTF_DEB_MAIN);\n\teth_broadcast_addr(priv->current_addr);\n\tmutex_init(&priv->lock);\n\n\tpriv->vif = NULL;\n\ttimer_setup(&priv->command_timer, command_timer_fn, 0);\n\n\tINIT_LIST_HEAD(&priv->cmdfreeq);\n\tINIT_LIST_HEAD(&priv->cmdpendingq);\n\n\tspin_lock_init(&priv->driver_lock);\n\n\t \n\tif (lbtf_allocate_cmd_buffer(priv))\n\t\treturn -1;\n\n\tlbtf_deb_leave(LBTF_DEB_MAIN);\n\treturn 0;\n}\n\nstatic void lbtf_free_adapter(struct lbtf_private *priv)\n{\n\tlbtf_deb_enter(LBTF_DEB_MAIN);\n\tlbtf_free_cmd_buffer(priv);\n\tdel_timer(&priv->command_timer);\n\tlbtf_deb_leave(LBTF_DEB_MAIN);\n}\n\nstatic void lbtf_op_tx(struct ieee80211_hw *hw,\n\t\t       struct ieee80211_tx_control *control,\n\t\t       struct sk_buff *skb)\n{\n\tstruct lbtf_private *priv = hw->priv;\n\n\tpriv->skb_to_tx = skb;\n\tqueue_work(lbtf_wq, &priv->tx_work);\n\t \n\tieee80211_stop_queues(priv->hw);\n}\n\nstatic void lbtf_tx_work(struct work_struct *work)\n{\n\tstruct lbtf_private *priv = container_of(work, struct lbtf_private,\n\t\t\t\t\t tx_work);\n\tunsigned int len;\n\tstruct ieee80211_tx_info *info;\n\tstruct txpd *txpd;\n\tstruct sk_buff *skb = NULL;\n\tint err;\n\n\tlbtf_deb_enter(LBTF_DEB_MACOPS | LBTF_DEB_TX);\n\n\tif ((priv->vif->type == NL80211_IFTYPE_AP) &&\n\t    (!skb_queue_empty(&priv->bc_ps_buf)))\n\t\tskb = skb_dequeue(&priv->bc_ps_buf);\n\telse if (priv->skb_to_tx) {\n\t\tskb = priv->skb_to_tx;\n\t\tpriv->skb_to_tx = NULL;\n\t} else {\n\t\tlbtf_deb_leave(LBTF_DEB_MACOPS | LBTF_DEB_TX);\n\t\treturn;\n\t}\n\n\tlen = skb->len;\n\tinfo  = IEEE80211_SKB_CB(skb);\n\ttxpd = skb_push(skb, sizeof(struct txpd));\n\n\tif (priv->surpriseremoved) {\n\t\tdev_kfree_skb_any(skb);\n\t\tlbtf_deb_leave(LBTF_DEB_MACOPS | LBTF_DEB_TX);\n\t\treturn;\n\t}\n\n\tmemset(txpd, 0, sizeof(struct txpd));\n\t \n\ttxpd->tx_control |= cpu_to_le32(MRVL_PER_PACKET_RATE |\n\t\t\t     ieee80211_get_tx_rate(priv->hw, info)->hw_value);\n\n\t \n\tBUILD_BUG_ON(sizeof(txpd->tx_dest_addr) != ETH_ALEN);\n\tmemcpy(&txpd->tx_dest_addr, skb->data + sizeof(struct txpd) + 4,\n\t\tETH_ALEN);\n\ttxpd->tx_packet_length = cpu_to_le16(len);\n\ttxpd->tx_packet_location = cpu_to_le32(sizeof(struct txpd));\n\tlbtf_deb_hex(LBTF_DEB_TX, \"TX Data\", skb->data, min_t(unsigned int, skb->len, 100));\n\tBUG_ON(priv->tx_skb);\n\tspin_lock_irq(&priv->driver_lock);\n\tpriv->tx_skb = skb;\n\terr = priv->ops->hw_host_to_card(priv, MVMS_DAT, skb->data, skb->len);\n\tspin_unlock_irq(&priv->driver_lock);\n\tif (err) {\n\t\tdev_kfree_skb_any(skb);\n\t\tpriv->tx_skb = NULL;\n\t\tpr_err(\"TX error: %d\", err);\n\t}\n\tlbtf_deb_leave(LBTF_DEB_MACOPS | LBTF_DEB_TX);\n}\n\nstatic int lbtf_op_start(struct ieee80211_hw *hw)\n{\n\tstruct lbtf_private *priv = hw->priv;\n\n\tlbtf_deb_enter(LBTF_DEB_MACOPS);\n\n\tpriv->capability = WLAN_CAPABILITY_SHORT_PREAMBLE;\n\tpriv->radioon = RADIO_ON;\n\tpriv->mac_control = CMD_ACT_MAC_RX_ON | CMD_ACT_MAC_TX_ON;\n\tlbtf_set_mac_control(priv);\n\tlbtf_set_radio_control(priv);\n\n\tlbtf_deb_leave(LBTF_DEB_MACOPS);\n\treturn 0;\n}\n\nstatic void lbtf_op_stop(struct ieee80211_hw *hw)\n{\n\tstruct lbtf_private *priv = hw->priv;\n\tunsigned long flags;\n\tstruct sk_buff *skb;\n\n\tstruct cmd_ctrl_node *cmdnode;\n\n\tlbtf_deb_enter(LBTF_DEB_MACOPS);\n\n\t \n\tspin_lock_irqsave(&priv->driver_lock, flags);\n\tlist_for_each_entry(cmdnode, &priv->cmdpendingq, list) {\n\t\tcmdnode->result = -ENOENT;\n\t\tcmdnode->cmdwaitqwoken = 1;\n\t\twake_up_interruptible(&cmdnode->cmdwait_q);\n\t}\n\n\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\tcancel_work_sync(&priv->cmd_work);\n\tcancel_work_sync(&priv->tx_work);\n\twhile ((skb = skb_dequeue(&priv->bc_ps_buf)))\n\t\tdev_kfree_skb_any(skb);\n\tpriv->radioon = RADIO_OFF;\n\tlbtf_set_radio_control(priv);\n\n\tlbtf_deb_leave(LBTF_DEB_MACOPS);\n}\n\nstatic int lbtf_op_add_interface(struct ieee80211_hw *hw,\n\t\t\tstruct ieee80211_vif *vif)\n{\n\tstruct lbtf_private *priv = hw->priv;\n\tlbtf_deb_enter(LBTF_DEB_MACOPS);\n\tif (priv->vif != NULL)\n\t\treturn -EOPNOTSUPP;\n\n\tpriv->vif = vif;\n\tswitch (vif->type) {\n\tcase NL80211_IFTYPE_MESH_POINT:\n\tcase NL80211_IFTYPE_AP:\n\t\tlbtf_set_mode(priv, LBTF_AP_MODE);\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tlbtf_set_mode(priv, LBTF_STA_MODE);\n\t\tbreak;\n\tdefault:\n\t\tpriv->vif = NULL;\n\t\treturn -EOPNOTSUPP;\n\t}\n\tlbtf_set_mac_address(priv, (u8 *) vif->addr);\n\tlbtf_deb_leave(LBTF_DEB_MACOPS);\n\treturn 0;\n}\n\nstatic void lbtf_op_remove_interface(struct ieee80211_hw *hw,\n\t\t\tstruct ieee80211_vif *vif)\n{\n\tstruct lbtf_private *priv = hw->priv;\n\tlbtf_deb_enter(LBTF_DEB_MACOPS);\n\n\tif (priv->vif->type == NL80211_IFTYPE_AP ||\n\t    priv->vif->type == NL80211_IFTYPE_MESH_POINT)\n\t\tlbtf_beacon_ctrl(priv, 0, 0);\n\tlbtf_set_mode(priv, LBTF_PASSIVE_MODE);\n\tlbtf_set_bssid(priv, 0, NULL);\n\tpriv->vif = NULL;\n\tlbtf_deb_leave(LBTF_DEB_MACOPS);\n}\n\nstatic int lbtf_op_config(struct ieee80211_hw *hw, u32 changed)\n{\n\tstruct lbtf_private *priv = hw->priv;\n\tstruct ieee80211_conf *conf = &hw->conf;\n\tlbtf_deb_enter(LBTF_DEB_MACOPS);\n\n\tif (conf->chandef.chan->center_freq != priv->cur_freq) {\n\t\tpriv->cur_freq = conf->chandef.chan->center_freq;\n\t\tlbtf_set_channel(priv, conf->chandef.chan->hw_value);\n\t}\n\tlbtf_deb_leave(LBTF_DEB_MACOPS);\n\treturn 0;\n}\n\nstatic u64 lbtf_op_prepare_multicast(struct ieee80211_hw *hw,\n\t\t\t\t     struct netdev_hw_addr_list *mc_list)\n{\n\tstruct lbtf_private *priv = hw->priv;\n\tint i;\n\tstruct netdev_hw_addr *ha;\n\tint mc_count = netdev_hw_addr_list_count(mc_list);\n\n\tif (!mc_count || mc_count > MRVDRV_MAX_MULTICAST_LIST_SIZE)\n\t\treturn mc_count;\n\n\tpriv->nr_of_multicastmacaddr = mc_count;\n\ti = 0;\n\tnetdev_hw_addr_list_for_each(ha, mc_list)\n\t\tmemcpy(&priv->multicastlist[i++], ha->addr, ETH_ALEN);\n\n\treturn mc_count;\n}\n\n#define SUPPORTED_FIF_FLAGS  FIF_ALLMULTI\nstatic void lbtf_op_configure_filter(struct ieee80211_hw *hw,\n\t\t\tunsigned int changed_flags,\n\t\t\tunsigned int *new_flags,\n\t\t\tu64 multicast)\n{\n\tstruct lbtf_private *priv = hw->priv;\n\tint old_mac_control = priv->mac_control;\n\n\tlbtf_deb_enter(LBTF_DEB_MACOPS);\n\n\tchanged_flags &= SUPPORTED_FIF_FLAGS;\n\t*new_flags &= SUPPORTED_FIF_FLAGS;\n\n\tif (!changed_flags) {\n\t\tlbtf_deb_leave(LBTF_DEB_MACOPS);\n\t\treturn;\n\t}\n\n\tpriv->mac_control &= ~CMD_ACT_MAC_PROMISCUOUS_ENABLE;\n\tif (*new_flags & (FIF_ALLMULTI) ||\n\t    multicast > MRVDRV_MAX_MULTICAST_LIST_SIZE) {\n\t\tpriv->mac_control |= CMD_ACT_MAC_ALL_MULTICAST_ENABLE;\n\t\tpriv->mac_control &= ~CMD_ACT_MAC_MULTICAST_ENABLE;\n\t} else if (multicast) {\n\t\tpriv->mac_control |= CMD_ACT_MAC_MULTICAST_ENABLE;\n\t\tpriv->mac_control &= ~CMD_ACT_MAC_ALL_MULTICAST_ENABLE;\n\t\tlbtf_cmd_set_mac_multicast_addr(priv);\n\t} else {\n\t\tpriv->mac_control &= ~(CMD_ACT_MAC_MULTICAST_ENABLE |\n\t\t\t\t       CMD_ACT_MAC_ALL_MULTICAST_ENABLE);\n\t\tif (priv->nr_of_multicastmacaddr) {\n\t\t\tpriv->nr_of_multicastmacaddr = 0;\n\t\t\tlbtf_cmd_set_mac_multicast_addr(priv);\n\t\t}\n\t}\n\n\n\tif (priv->mac_control != old_mac_control)\n\t\tlbtf_set_mac_control(priv);\n\n\tlbtf_deb_leave(LBTF_DEB_MACOPS);\n}\n\nstatic void lbtf_op_bss_info_changed(struct ieee80211_hw *hw,\n\t\t\tstruct ieee80211_vif *vif,\n\t\t\tstruct ieee80211_bss_conf *bss_conf,\n\t\t\tu64 changes)\n{\n\tstruct lbtf_private *priv = hw->priv;\n\tstruct sk_buff *beacon;\n\tlbtf_deb_enter(LBTF_DEB_MACOPS);\n\n\tif (changes & (BSS_CHANGED_BEACON | BSS_CHANGED_BEACON_INT)) {\n\t\tswitch (priv->vif->type) {\n\t\tcase NL80211_IFTYPE_AP:\n\t\tcase NL80211_IFTYPE_MESH_POINT:\n\t\t\tbeacon = ieee80211_beacon_get(hw, vif, 0);\n\t\t\tif (beacon) {\n\t\t\t\tlbtf_beacon_set(priv, beacon);\n\t\t\t\tkfree_skb(beacon);\n\t\t\t\tlbtf_beacon_ctrl(priv, 1,\n\t\t\t\t\t\t bss_conf->beacon_int);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (changes & BSS_CHANGED_BSSID) {\n\t\tbool activate = !is_zero_ether_addr(bss_conf->bssid);\n\t\tlbtf_set_bssid(priv, activate, bss_conf->bssid);\n\t}\n\n\tif (changes & BSS_CHANGED_ERP_PREAMBLE) {\n\t\tif (bss_conf->use_short_preamble)\n\t\t\tpriv->preamble = CMD_TYPE_SHORT_PREAMBLE;\n\t\telse\n\t\t\tpriv->preamble = CMD_TYPE_LONG_PREAMBLE;\n\t\tlbtf_set_radio_control(priv);\n\t}\n\n\tlbtf_deb_leave(LBTF_DEB_MACOPS);\n}\n\nstatic int lbtf_op_get_survey(struct ieee80211_hw *hw, int idx,\n\t\t\t\tstruct survey_info *survey)\n{\n\tstruct lbtf_private *priv = hw->priv;\n\tstruct ieee80211_conf *conf = &hw->conf;\n\n\tif (idx != 0)\n\t\treturn -ENOENT;\n\n\tsurvey->channel = conf->chandef.chan;\n\tsurvey->filled = SURVEY_INFO_NOISE_DBM;\n\tsurvey->noise = priv->noise;\n\n\treturn 0;\n}\n\nstatic const struct ieee80211_ops lbtf_ops = {\n\t.tx\t\t\t= lbtf_op_tx,\n\t.wake_tx_queue\t\t= ieee80211_handle_wake_tx_queue,\n\t.start\t\t\t= lbtf_op_start,\n\t.stop\t\t\t= lbtf_op_stop,\n\t.add_interface\t\t= lbtf_op_add_interface,\n\t.remove_interface\t= lbtf_op_remove_interface,\n\t.config\t\t\t= lbtf_op_config,\n\t.prepare_multicast\t= lbtf_op_prepare_multicast,\n\t.configure_filter\t= lbtf_op_configure_filter,\n\t.bss_info_changed\t= lbtf_op_bss_info_changed,\n\t.get_survey\t\t= lbtf_op_get_survey,\n};\n\nint lbtf_rx(struct lbtf_private *priv, struct sk_buff *skb)\n{\n\tstruct ieee80211_rx_status stats;\n\tstruct rxpd *prxpd;\n\tint need_padding;\n\tstruct ieee80211_hdr *hdr;\n\n\tlbtf_deb_enter(LBTF_DEB_RX);\n\n\tif (priv->radioon != RADIO_ON) {\n\t\tlbtf_deb_rx(\"rx before we turned on the radio\");\n\t\tgoto done;\n\t}\n\n\tprxpd = (struct rxpd *) skb->data;\n\n\tmemset(&stats, 0, sizeof(stats));\n\tif (!(prxpd->status & cpu_to_le16(MRVDRV_RXPD_STATUS_OK)))\n\t\tstats.flag |= RX_FLAG_FAILED_FCS_CRC;\n\tstats.freq = priv->cur_freq;\n\tstats.band = NL80211_BAND_2GHZ;\n\tstats.signal = prxpd->snr - prxpd->nf;\n\tpriv->noise = prxpd->nf;\n\t \n\tif (prxpd->rx_rate > 4)\n\t\t--prxpd->rx_rate;\n\tstats.rate_idx = prxpd->rx_rate;\n\tskb_pull(skb, sizeof(struct rxpd));\n\n\thdr = (struct ieee80211_hdr *)skb->data;\n\n\tneed_padding = ieee80211_is_data_qos(hdr->frame_control);\n\tneed_padding ^= ieee80211_has_a4(hdr->frame_control);\n\tneed_padding ^= ieee80211_is_data_qos(hdr->frame_control) &&\n\t\t\t(*ieee80211_get_qos_ctl(hdr) &\n\t\t\t IEEE80211_QOS_CTL_A_MSDU_PRESENT);\n\n\tif (need_padding) {\n\t\tmemmove(skb->data + 2, skb->data, skb->len);\n\t\tskb_reserve(skb, 2);\n\t}\n\n\tmemcpy(IEEE80211_SKB_RXCB(skb), &stats, sizeof(stats));\n\n\tlbtf_deb_rx(\"rx data: skb->len-sizeof(RxPd) = %d-%zd = %zd\\n\",\n\t       skb->len, sizeof(struct rxpd), skb->len - sizeof(struct rxpd));\n\tlbtf_deb_hex(LBTF_DEB_RX, \"RX Data\", skb->data,\n\t             min_t(unsigned int, skb->len, 100));\n\n\tieee80211_rx_irqsafe(priv->hw, skb);\n\ndone:\n\tlbtf_deb_leave(LBTF_DEB_RX);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(lbtf_rx);\n\n \nstruct lbtf_private *lbtf_add_card(void *card, struct device *dmdev,\n\t\t\t\t   const struct lbtf_ops *ops)\n{\n\tstruct ieee80211_hw *hw;\n\tstruct lbtf_private *priv = NULL;\n\n\tlbtf_deb_enter(LBTF_DEB_MAIN);\n\n\thw = ieee80211_alloc_hw(sizeof(struct lbtf_private), &lbtf_ops);\n\tif (!hw)\n\t\tgoto done;\n\n\tpriv = hw->priv;\n\tif (lbtf_init_adapter(priv))\n\t\tgoto err_init_adapter;\n\n\tpriv->hw = hw;\n\tpriv->card = card;\n\tpriv->ops = ops;\n\tpriv->tx_skb = NULL;\n\tpriv->radioon = RADIO_OFF;\n\n\thw->queues = 1;\n\tieee80211_hw_set(hw, HOST_BROADCAST_PS_BUFFERING);\n\tieee80211_hw_set(hw, SIGNAL_DBM);\n\thw->extra_tx_headroom = sizeof(struct txpd);\n\tmemcpy(priv->channels, lbtf_channels, sizeof(lbtf_channels));\n\tmemcpy(priv->rates, lbtf_rates, sizeof(lbtf_rates));\n\tpriv->band.n_bitrates = ARRAY_SIZE(lbtf_rates);\n\tpriv->band.bitrates = priv->rates;\n\tpriv->band.n_channels = ARRAY_SIZE(lbtf_channels);\n\tpriv->band.channels = priv->channels;\n\thw->wiphy->bands[NL80211_BAND_2GHZ] = &priv->band;\n\thw->wiphy->interface_modes =\n\t\tBIT(NL80211_IFTYPE_STATION) |\n\t\tBIT(NL80211_IFTYPE_ADHOC);\n\tskb_queue_head_init(&priv->bc_ps_buf);\n\n\twiphy_ext_feature_set(hw->wiphy, NL80211_EXT_FEATURE_CQM_RSSI_LIST);\n\n\tSET_IEEE80211_DEV(hw, dmdev);\n\n\tINIT_WORK(&priv->cmd_work, lbtf_cmd_work);\n\tINIT_WORK(&priv->tx_work, lbtf_tx_work);\n\n\tif (priv->ops->hw_prog_firmware(priv)) {\n\t\tlbtf_deb_usbd(dmdev, \"Error programming the firmware\\n\");\n\t\tpriv->ops->hw_reset_device(priv);\n\t\tgoto err_init_adapter;\n\t}\n\n\teth_broadcast_addr(priv->current_addr);\n\tif (lbtf_update_hw_spec(priv))\n\t\tgoto err_init_adapter;\n\n\tif (priv->fwrelease < LBTF_FW_VER_MIN ||\n\t    priv->fwrelease > LBTF_FW_VER_MAX) {\n\t\tgoto err_init_adapter;\n\t}\n\n\t \n\tlbtf_set_radio_control(priv);\n\n\tif (ieee80211_register_hw(hw))\n\t\tgoto err_init_adapter;\n\n\tdev_info(dmdev, \"libertastf: Marvell WLAN 802.11 thinfirm adapter\\n\");\n\tgoto done;\n\nerr_init_adapter:\n\tlbtf_free_adapter(priv);\n\tieee80211_free_hw(hw);\n\tpriv = NULL;\n\ndone:\n\tlbtf_deb_leave_args(LBTF_DEB_MAIN, \"priv %p\", priv);\n\treturn priv;\n}\nEXPORT_SYMBOL_GPL(lbtf_add_card);\n\n\nint lbtf_remove_card(struct lbtf_private *priv)\n{\n\tstruct ieee80211_hw *hw = priv->hw;\n\n\tlbtf_deb_enter(LBTF_DEB_MAIN);\n\n\tpriv->surpriseremoved = 1;\n\tdel_timer(&priv->command_timer);\n\tlbtf_free_adapter(priv);\n\tpriv->hw = NULL;\n\tieee80211_unregister_hw(hw);\n\tieee80211_free_hw(hw);\n\n\tlbtf_deb_leave(LBTF_DEB_MAIN);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(lbtf_remove_card);\n\nvoid lbtf_send_tx_feedback(struct lbtf_private *priv, u8 retrycnt, u8 fail)\n{\n\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(priv->tx_skb);\n\n\tieee80211_tx_info_clear_status(info);\n\t \n\tif (!(info->flags & IEEE80211_TX_CTL_NO_ACK) && !fail)\n\t\tinfo->flags |= IEEE80211_TX_STAT_ACK;\n\tskb_pull(priv->tx_skb, sizeof(struct txpd));\n\tieee80211_tx_status_irqsafe(priv->hw, priv->tx_skb);\n\tpriv->tx_skb = NULL;\n\tif (!priv->skb_to_tx && skb_queue_empty(&priv->bc_ps_buf))\n\t\tieee80211_wake_queues(priv->hw);\n\telse\n\t\tqueue_work(lbtf_wq, &priv->tx_work);\n}\nEXPORT_SYMBOL_GPL(lbtf_send_tx_feedback);\n\nvoid lbtf_bcn_sent(struct lbtf_private *priv)\n{\n\tstruct sk_buff *skb = NULL;\n\n\tif (priv->vif->type != NL80211_IFTYPE_AP)\n\t\treturn;\n\n\tif (skb_queue_empty(&priv->bc_ps_buf)) {\n\t\tbool tx_buff_bc = false;\n\n\t\twhile ((skb = ieee80211_get_buffered_bc(priv->hw, priv->vif))) {\n\t\t\tskb_queue_tail(&priv->bc_ps_buf, skb);\n\t\t\ttx_buff_bc = true;\n\t\t}\n\t\tif (tx_buff_bc) {\n\t\t\tieee80211_stop_queues(priv->hw);\n\t\t\tqueue_work(lbtf_wq, &priv->tx_work);\n\t\t}\n\t}\n\n\tskb = ieee80211_beacon_get(priv->hw, priv->vif, 0);\n\n\tif (skb) {\n\t\tlbtf_beacon_set(priv, skb);\n\t\tkfree_skb(skb);\n\t}\n}\nEXPORT_SYMBOL_GPL(lbtf_bcn_sent);\n\nstatic int __init lbtf_init_module(void)\n{\n\tlbtf_deb_enter(LBTF_DEB_MAIN);\n\tlbtf_wq = alloc_workqueue(\"libertastf\", WQ_MEM_RECLAIM, 0);\n\tif (lbtf_wq == NULL) {\n\t\tprintk(KERN_ERR \"libertastf: couldn't create workqueue\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tlbtf_deb_leave(LBTF_DEB_MAIN);\n\treturn 0;\n}\n\nstatic void __exit lbtf_exit_module(void)\n{\n\tlbtf_deb_enter(LBTF_DEB_MAIN);\n\tdestroy_workqueue(lbtf_wq);\n\tlbtf_deb_leave(LBTF_DEB_MAIN);\n}\n\nmodule_init(lbtf_init_module);\nmodule_exit(lbtf_exit_module);\n\nMODULE_DESCRIPTION(\"Libertas WLAN Thinfirm Driver Library\");\nMODULE_AUTHOR(\"Cozybit Inc.\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}