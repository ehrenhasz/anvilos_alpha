{
  "module_name": "cmd.c",
  "hash_id": "42f3137929c50c04c44a5128a62a0c34b599a589caaf8ae0670e89be201bce1e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/marvell/libertas_tf/cmd.c",
  "human_readable_source": "\n \n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/hardirq.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n\n#include \"libertas_tf.h\"\n\nstatic const struct channel_range channel_ranges[] = {\n\t{ LBTF_REGDOMAIN_US,\t\t1, 12 },\n\t{ LBTF_REGDOMAIN_CA,\t\t1, 12 },\n\t{ LBTF_REGDOMAIN_EU,\t\t1, 14 },\n\t{ LBTF_REGDOMAIN_JP,\t\t1, 14 },\n\t{ LBTF_REGDOMAIN_SP,\t\t1, 14 },\n\t{ LBTF_REGDOMAIN_FR,\t\t1, 14 },\n};\n\nstatic u16 lbtf_region_code_to_index[MRVDRV_MAX_REGION_CODE] =\n{\n\tLBTF_REGDOMAIN_US, LBTF_REGDOMAIN_CA, LBTF_REGDOMAIN_EU,\n\tLBTF_REGDOMAIN_SP, LBTF_REGDOMAIN_FR, LBTF_REGDOMAIN_JP,\n};\n\nstatic struct cmd_ctrl_node *lbtf_get_cmd_ctrl_node(struct lbtf_private *priv);\n\n\n \nint lbtf_cmd_copyback(struct lbtf_private *priv, unsigned long extra,\n\t\t     struct cmd_header *resp)\n{\n\tstruct cmd_header *buf = (void *)extra;\n\tuint16_t copy_len;\n\n\tcopy_len = min(le16_to_cpu(buf->size), le16_to_cpu(resp->size));\n\tmemcpy(buf, resp, copy_len);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(lbtf_cmd_copyback);\n\n#define CHAN_TO_IDX(chan) ((chan) - 1)\n\nstatic void lbtf_geo_init(struct lbtf_private *priv)\n{\n\tconst struct channel_range *range = channel_ranges;\n\tu8 ch;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(channel_ranges); i++)\n\t\tif (channel_ranges[i].regdomain == priv->regioncode) {\n\t\t\trange = &channel_ranges[i];\n\t\t\tbreak;\n\t\t}\n\n\tfor (ch = range->start; ch < range->end; ch++)\n\t\tpriv->channels[CHAN_TO_IDX(ch)].flags = 0;\n}\n\n \nint lbtf_update_hw_spec(struct lbtf_private *priv)\n{\n\tstruct cmd_ds_get_hw_spec cmd;\n\tint ret = -1;\n\tu32 i;\n\n\tlbtf_deb_enter(LBTF_DEB_CMD);\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.hdr.size = cpu_to_le16(sizeof(cmd));\n\tmemcpy(cmd.permanentaddr, priv->current_addr, ETH_ALEN);\n\tret = lbtf_cmd_with_response(priv, CMD_GET_HW_SPEC, &cmd);\n\tif (ret)\n\t\tgoto out;\n\n\tpriv->fwcapinfo = le32_to_cpu(cmd.fwcapinfo);\n\n\t \n\tpriv->fwrelease = le32_to_cpu(cmd.fwrelease);\n\tpriv->fwrelease = (priv->fwrelease << 8) |\n\t\t(priv->fwrelease >> 24 & 0xff);\n\n\tprintk(KERN_INFO \"libertastf: %pM, fw %u.%u.%up%u, cap 0x%08x\\n\",\n\t\tcmd.permanentaddr,\n\t\tpriv->fwrelease >> 24 & 0xff,\n\t\tpriv->fwrelease >> 16 & 0xff,\n\t\tpriv->fwrelease >>  8 & 0xff,\n\t\tpriv->fwrelease       & 0xff,\n\t\tpriv->fwcapinfo);\n\tlbtf_deb_cmd(\"GET_HW_SPEC: hardware interface 0x%x, hardware spec 0x%04x\\n\",\n\t\t    cmd.hwifversion, cmd.version);\n\n\t \n\tpriv->regioncode = le16_to_cpu(cmd.regioncode) & 0xFF;\n\n\tfor (i = 0; i < MRVDRV_MAX_REGION_CODE; i++) {\n\t\t \n\t\tif (priv->regioncode == lbtf_region_code_to_index[i])\n\t\t\tbreak;\n\t}\n\n\t \n\tif (i >= MRVDRV_MAX_REGION_CODE) {\n\t\tpriv->regioncode = 0x10;\n\t\tpr_info(\"unidentified region code; using the default (USA)\\n\");\n\t}\n\n\tif (priv->current_addr[0] == 0xff)\n\t\tmemmove(priv->current_addr, cmd.permanentaddr, ETH_ALEN);\n\n\tSET_IEEE80211_PERM_ADDR(priv->hw, priv->current_addr);\n\n\tlbtf_geo_init(priv);\nout:\n\tlbtf_deb_leave(LBTF_DEB_CMD);\n\treturn ret;\n}\n\n \nint lbtf_set_channel(struct lbtf_private *priv, u8 channel)\n{\n\tint ret = 0;\n\tstruct cmd_ds_802_11_rf_channel cmd;\n\n\tlbtf_deb_enter(LBTF_DEB_CMD);\n\n\tcmd.hdr.size = cpu_to_le16(sizeof(cmd));\n\tcmd.action = cpu_to_le16(CMD_OPT_802_11_RF_CHANNEL_SET);\n\tcmd.channel = cpu_to_le16(channel);\n\n\tret = lbtf_cmd_with_response(priv, CMD_802_11_RF_CHANNEL, &cmd);\n\tlbtf_deb_leave_args(LBTF_DEB_CMD, \"ret %d\", ret);\n\treturn ret;\n}\n\nint lbtf_beacon_set(struct lbtf_private *priv, struct sk_buff *beacon)\n{\n\tstruct cmd_ds_802_11_beacon_set cmd;\n\tint size;\n\n\tlbtf_deb_enter(LBTF_DEB_CMD);\n\n\tif (beacon->len > MRVL_MAX_BCN_SIZE) {\n\t\tlbtf_deb_leave_args(LBTF_DEB_CMD, \"ret %d\", -1);\n\t\treturn -1;\n\t}\n\tsize =  sizeof(cmd) - sizeof(cmd.beacon) + beacon->len;\n\tcmd.hdr.size = cpu_to_le16(size);\n\tcmd.len = cpu_to_le16(beacon->len);\n\tmemcpy(cmd.beacon, (u8 *) beacon->data, beacon->len);\n\n\tlbtf_cmd_async(priv, CMD_802_11_BEACON_SET, &cmd.hdr, size);\n\n\tlbtf_deb_leave_args(LBTF_DEB_CMD, \"ret %d\", 0);\n\treturn 0;\n}\n\nint lbtf_beacon_ctrl(struct lbtf_private *priv, bool beacon_enable,\n\t\t     int beacon_int)\n{\n\tstruct cmd_ds_802_11_beacon_control cmd;\n\tlbtf_deb_enter(LBTF_DEB_CMD);\n\n\tcmd.hdr.size = cpu_to_le16(sizeof(cmd));\n\tcmd.action = cpu_to_le16(CMD_ACT_SET);\n\tcmd.beacon_enable = cpu_to_le16(beacon_enable);\n\tcmd.beacon_period = cpu_to_le16(beacon_int);\n\n\tlbtf_cmd_async(priv, CMD_802_11_BEACON_CTRL, &cmd.hdr, sizeof(cmd));\n\n\tlbtf_deb_leave(LBTF_DEB_CMD);\n\treturn 0;\n}\n\nstatic void lbtf_queue_cmd(struct lbtf_private *priv,\n\t\t\t  struct cmd_ctrl_node *cmdnode)\n{\n\tunsigned long flags;\n\tlbtf_deb_enter(LBTF_DEB_HOST);\n\n\tif (!cmdnode) {\n\t\tlbtf_deb_host(\"QUEUE_CMD: cmdnode is NULL\\n\");\n\t\tgoto qcmd_done;\n\t}\n\n\tif (!cmdnode->cmdbuf->size) {\n\t\tlbtf_deb_host(\"DNLD_CMD: cmd size is zero\\n\");\n\t\tgoto qcmd_done;\n\t}\n\n\tcmdnode->result = 0;\n\tspin_lock_irqsave(&priv->driver_lock, flags);\n\tlist_add_tail(&cmdnode->list, &priv->cmdpendingq);\n\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\n\tlbtf_deb_host(\"QUEUE_CMD: inserted command 0x%04x into cmdpendingq\\n\",\n\t\t     le16_to_cpu(cmdnode->cmdbuf->command));\n\nqcmd_done:\n\tlbtf_deb_leave(LBTF_DEB_HOST);\n}\n\nstatic void lbtf_submit_command(struct lbtf_private *priv,\n\t\t\t       struct cmd_ctrl_node *cmdnode)\n{\n\tunsigned long flags;\n\tstruct cmd_header *cmd;\n\tuint16_t cmdsize;\n\tuint16_t command;\n\tint timeo = 5 * HZ;\n\tint ret;\n\n\tlbtf_deb_enter(LBTF_DEB_HOST);\n\n\tcmd = cmdnode->cmdbuf;\n\n\tspin_lock_irqsave(&priv->driver_lock, flags);\n\tpriv->cur_cmd = cmdnode;\n\tcmdsize = le16_to_cpu(cmd->size);\n\tcommand = le16_to_cpu(cmd->command);\n\n\tlbtf_deb_cmd(\"DNLD_CMD: command 0x%04x, seq %d, size %d\\n\",\n\t\t     command, le16_to_cpu(cmd->seqnum), cmdsize);\n\tlbtf_deb_hex(LBTF_DEB_CMD, \"DNLD_CMD\", (void *) cmdnode->cmdbuf, cmdsize);\n\n\tret = priv->ops->hw_host_to_card(priv, MVMS_CMD, (u8 *)cmd, cmdsize);\n\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\n\tif (ret) {\n\t\tpr_info(\"DNLD_CMD: hw_host_to_card failed: %d\\n\", ret);\n\t\t \n\t\ttimeo = HZ;\n\t}\n\n\t \n\tmod_timer(&priv->command_timer, jiffies + timeo);\n\n\tlbtf_deb_leave(LBTF_DEB_HOST);\n}\n\n \nstatic void __lbtf_cleanup_and_insert_cmd(struct lbtf_private *priv,\n\t\t\t\t\t struct cmd_ctrl_node *cmdnode)\n{\n\tlbtf_deb_enter(LBTF_DEB_HOST);\n\n\tif (!cmdnode)\n\t\tgoto cl_ins_out;\n\n\tcmdnode->callback = NULL;\n\tcmdnode->callback_arg = 0;\n\n\tmemset(cmdnode->cmdbuf, 0, LBS_CMD_BUFFER_SIZE);\n\n\tlist_add_tail(&cmdnode->list, &priv->cmdfreeq);\n\ncl_ins_out:\n\tlbtf_deb_leave(LBTF_DEB_HOST);\n}\n\nstatic void lbtf_cleanup_and_insert_cmd(struct lbtf_private *priv,\n\tstruct cmd_ctrl_node *ptempcmd)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->driver_lock, flags);\n\t__lbtf_cleanup_and_insert_cmd(priv, ptempcmd);\n\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n}\n\nvoid lbtf_complete_command(struct lbtf_private *priv, struct cmd_ctrl_node *cmd,\n\t\t\t  int result)\n{\n\tcmd->result = result;\n\tcmd->cmdwaitqwoken = 1;\n\twake_up_interruptible(&cmd->cmdwait_q);\n\n\tif (!cmd->callback)\n\t\t__lbtf_cleanup_and_insert_cmd(priv, cmd);\n\tpriv->cur_cmd = NULL;\n}\n\nint lbtf_cmd_set_mac_multicast_addr(struct lbtf_private *priv)\n{\n\tstruct cmd_ds_mac_multicast_addr cmd;\n\n\tlbtf_deb_enter(LBTF_DEB_CMD);\n\n\tcmd.hdr.size = cpu_to_le16(sizeof(cmd));\n\tcmd.action = cpu_to_le16(CMD_ACT_SET);\n\n\tcmd.nr_of_adrs = cpu_to_le16((u16) priv->nr_of_multicastmacaddr);\n\n\tlbtf_deb_cmd(\"MULTICAST_ADR: setting %d addresses\\n\", cmd.nr_of_adrs);\n\n\tmemcpy(cmd.maclist, priv->multicastlist,\n\t       priv->nr_of_multicastmacaddr * ETH_ALEN);\n\n\tlbtf_cmd_async(priv, CMD_MAC_MULTICAST_ADR, &cmd.hdr, sizeof(cmd));\n\n\tlbtf_deb_leave(LBTF_DEB_CMD);\n\treturn 0;\n}\n\nvoid lbtf_set_mode(struct lbtf_private *priv, enum lbtf_mode mode)\n{\n\tstruct cmd_ds_set_mode cmd;\n\tlbtf_deb_enter(LBTF_DEB_WEXT);\n\n\tcmd.hdr.size = cpu_to_le16(sizeof(cmd));\n\tcmd.mode = cpu_to_le16(mode);\n\tlbtf_deb_wext(\"Switching to mode: 0x%x\\n\", mode);\n\tlbtf_cmd_async(priv, CMD_802_11_SET_MODE, &cmd.hdr, sizeof(cmd));\n\n\tlbtf_deb_leave(LBTF_DEB_WEXT);\n}\n\nvoid lbtf_set_bssid(struct lbtf_private *priv, bool activate, const u8 *bssid)\n{\n\tstruct cmd_ds_set_bssid cmd;\n\tlbtf_deb_enter(LBTF_DEB_CMD);\n\n\tcmd.hdr.size = cpu_to_le16(sizeof(cmd));\n\tcmd.activate = activate ? 1 : 0;\n\tif (activate)\n\t\tmemcpy(cmd.bssid, bssid, ETH_ALEN);\n\n\tlbtf_cmd_async(priv, CMD_802_11_SET_BSSID, &cmd.hdr, sizeof(cmd));\n\tlbtf_deb_leave(LBTF_DEB_CMD);\n}\n\nint lbtf_set_mac_address(struct lbtf_private *priv, uint8_t *mac_addr)\n{\n\tstruct cmd_ds_802_11_mac_address cmd;\n\tlbtf_deb_enter(LBTF_DEB_CMD);\n\n\tcmd.hdr.size = cpu_to_le16(sizeof(cmd));\n\tcmd.action = cpu_to_le16(CMD_ACT_SET);\n\n\tmemcpy(cmd.macadd, mac_addr, ETH_ALEN);\n\n\tlbtf_cmd_async(priv, CMD_802_11_MAC_ADDRESS, &cmd.hdr, sizeof(cmd));\n\tlbtf_deb_leave(LBTF_DEB_CMD);\n\treturn 0;\n}\n\nint lbtf_set_radio_control(struct lbtf_private *priv)\n{\n\tint ret = 0;\n\tstruct cmd_ds_802_11_radio_control cmd;\n\n\tlbtf_deb_enter(LBTF_DEB_CMD);\n\n\tcmd.hdr.size = cpu_to_le16(sizeof(cmd));\n\tcmd.action = cpu_to_le16(CMD_ACT_SET);\n\n\tswitch (priv->preamble) {\n\tcase CMD_TYPE_SHORT_PREAMBLE:\n\t\tcmd.control = cpu_to_le16(SET_SHORT_PREAMBLE);\n\t\tbreak;\n\n\tcase CMD_TYPE_LONG_PREAMBLE:\n\t\tcmd.control = cpu_to_le16(SET_LONG_PREAMBLE);\n\t\tbreak;\n\n\tcase CMD_TYPE_AUTO_PREAMBLE:\n\tdefault:\n\t\tcmd.control = cpu_to_le16(SET_AUTO_PREAMBLE);\n\t\tbreak;\n\t}\n\n\tif (priv->radioon)\n\t\tcmd.control |= cpu_to_le16(TURN_ON_RF);\n\telse\n\t\tcmd.control &= cpu_to_le16(~TURN_ON_RF);\n\n\tlbtf_deb_cmd(\"RADIO_SET: radio %d, preamble %d\\n\", priv->radioon,\n\t\t    priv->preamble);\n\n\tret = lbtf_cmd_with_response(priv, CMD_802_11_RADIO_CONTROL, &cmd);\n\n\tlbtf_deb_leave_args(LBTF_DEB_CMD, \"ret %d\", ret);\n\treturn ret;\n}\n\nvoid lbtf_set_mac_control(struct lbtf_private *priv)\n{\n\tstruct cmd_ds_mac_control cmd;\n\tlbtf_deb_enter(LBTF_DEB_CMD);\n\n\tcmd.hdr.size = cpu_to_le16(sizeof(cmd));\n\tcmd.action = cpu_to_le16(priv->mac_control);\n\tcmd.reserved = 0;\n\n\tlbtf_cmd_async(priv, CMD_MAC_CONTROL,\n\t\t&cmd.hdr, sizeof(cmd));\n\n\tlbtf_deb_leave(LBTF_DEB_CMD);\n}\n\n \nint lbtf_allocate_cmd_buffer(struct lbtf_private *priv)\n{\n\tint ret = 0;\n\tu32 bufsize;\n\tu32 i;\n\tstruct cmd_ctrl_node *cmdarray;\n\n\tlbtf_deb_enter(LBTF_DEB_HOST);\n\n\t \n\tbufsize = sizeof(struct cmd_ctrl_node) * LBS_NUM_CMD_BUFFERS;\n\tcmdarray = kzalloc(bufsize, GFP_KERNEL);\n\tif (!cmdarray) {\n\t\tlbtf_deb_host(\"ALLOC_CMD_BUF: tempcmd_array is NULL\\n\");\n\t\tret = -1;\n\t\tgoto done;\n\t}\n\tpriv->cmd_array = cmdarray;\n\n\t \n\tfor (i = 0; i < LBS_NUM_CMD_BUFFERS; i++) {\n\t\tcmdarray[i].cmdbuf = kzalloc(LBS_CMD_BUFFER_SIZE, GFP_KERNEL);\n\t\tif (!cmdarray[i].cmdbuf) {\n\t\t\tlbtf_deb_host(\"ALLOC_CMD_BUF: ptempvirtualaddr is NULL\\n\");\n\t\t\tret = -1;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tfor (i = 0; i < LBS_NUM_CMD_BUFFERS; i++) {\n\t\tinit_waitqueue_head(&cmdarray[i].cmdwait_q);\n\t\tlbtf_cleanup_and_insert_cmd(priv, &cmdarray[i]);\n\t}\n\n\tret = 0;\n\ndone:\n\tlbtf_deb_leave_args(LBTF_DEB_HOST, \"ret %d\", ret);\n\treturn ret;\n}\n\n \nint lbtf_free_cmd_buffer(struct lbtf_private *priv)\n{\n\tstruct cmd_ctrl_node *cmdarray;\n\tunsigned int i;\n\n\tlbtf_deb_enter(LBTF_DEB_HOST);\n\n\t \n\tif (priv->cmd_array == NULL) {\n\t\tlbtf_deb_host(\"FREE_CMD_BUF: cmd_array is NULL\\n\");\n\t\tgoto done;\n\t}\n\n\tcmdarray = priv->cmd_array;\n\n\t \n\tfor (i = 0; i < LBS_NUM_CMD_BUFFERS; i++) {\n\t\tkfree(cmdarray[i].cmdbuf);\n\t\tcmdarray[i].cmdbuf = NULL;\n\t}\n\n\t \n\tkfree(priv->cmd_array);\n\tpriv->cmd_array = NULL;\n\ndone:\n\tlbtf_deb_leave(LBTF_DEB_HOST);\n\treturn 0;\n}\n\n \nstatic struct cmd_ctrl_node *lbtf_get_cmd_ctrl_node(struct lbtf_private *priv)\n{\n\tstruct cmd_ctrl_node *tempnode;\n\tunsigned long flags;\n\n\tlbtf_deb_enter(LBTF_DEB_HOST);\n\n\tif (!priv)\n\t\treturn NULL;\n\n\tspin_lock_irqsave(&priv->driver_lock, flags);\n\n\tif (!list_empty(&priv->cmdfreeq)) {\n\t\ttempnode = list_first_entry(&priv->cmdfreeq,\n\t\t\t\t\t    struct cmd_ctrl_node, list);\n\t\tlist_del(&tempnode->list);\n\t} else {\n\t\tlbtf_deb_host(\"GET_CMD_NODE: cmd_ctrl_node is not available\\n\");\n\t\ttempnode = NULL;\n\t}\n\n\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\n\tlbtf_deb_leave(LBTF_DEB_HOST);\n\treturn tempnode;\n}\n\n \nint lbtf_execute_next_command(struct lbtf_private *priv)\n{\n\tstruct cmd_ctrl_node *cmdnode = NULL;\n\tstruct cmd_header *cmd;\n\tunsigned long flags;\n\tint ret = 0;\n\n\t \n\tlbtf_deb_enter(LBTF_DEB_THREAD);\n\n\tspin_lock_irqsave(&priv->driver_lock, flags);\n\n\tif (priv->cur_cmd) {\n\t\tpr_alert(\"EXEC_NEXT_CMD: already processing command!\\n\");\n\t\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\t\tret = -1;\n\t\tgoto done;\n\t}\n\n\tif (!list_empty(&priv->cmdpendingq)) {\n\t\tcmdnode = list_first_entry(&priv->cmdpendingq,\n\t\t\t\t\t   struct cmd_ctrl_node, list);\n\t}\n\n\tif (cmdnode) {\n\t\tcmd = cmdnode->cmdbuf;\n\n\t\tlist_del(&cmdnode->list);\n\t\tlbtf_deb_host(\"EXEC_NEXT_CMD: sending command 0x%04x\\n\",\n\t\t\t    le16_to_cpu(cmd->command));\n\t\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\t\tlbtf_submit_command(priv, cmdnode);\n\t} else\n\t\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\n\tret = 0;\ndone:\n\tlbtf_deb_leave(LBTF_DEB_THREAD);\n\treturn ret;\n}\n\nstatic struct cmd_ctrl_node *__lbtf_cmd_async(struct lbtf_private *priv,\n\tuint16_t command, struct cmd_header *in_cmd, int in_cmd_size,\n\tint (*callback)(struct lbtf_private *, unsigned long,\n\t\t\tstruct cmd_header *),\n\tunsigned long callback_arg)\n{\n\tstruct cmd_ctrl_node *cmdnode;\n\n\tlbtf_deb_enter(LBTF_DEB_HOST);\n\n\tif (priv->surpriseremoved) {\n\t\tlbtf_deb_host(\"PREP_CMD: card removed\\n\");\n\t\tcmdnode = ERR_PTR(-ENOENT);\n\t\tgoto done;\n\t}\n\n\tcmdnode = lbtf_get_cmd_ctrl_node(priv);\n\tif (cmdnode == NULL) {\n\t\tlbtf_deb_host(\"PREP_CMD: cmdnode is NULL\\n\");\n\n\t\t \n\t\tqueue_work(lbtf_wq, &priv->cmd_work);\n\t\tcmdnode = ERR_PTR(-ENOBUFS);\n\t\tgoto done;\n\t}\n\n\tcmdnode->callback = callback;\n\tcmdnode->callback_arg = callback_arg;\n\n\t \n\tmemcpy(cmdnode->cmdbuf, in_cmd, in_cmd_size);\n\n\t \n\tpriv->seqnum++;\n\tcmdnode->cmdbuf->command = cpu_to_le16(command);\n\tcmdnode->cmdbuf->size    = cpu_to_le16(in_cmd_size);\n\tcmdnode->cmdbuf->seqnum  = cpu_to_le16(priv->seqnum);\n\tcmdnode->cmdbuf->result  = 0;\n\n\tlbtf_deb_host(\"PREP_CMD: command 0x%04x\\n\", command);\n\n\tcmdnode->cmdwaitqwoken = 0;\n\tlbtf_queue_cmd(priv, cmdnode);\n\tqueue_work(lbtf_wq, &priv->cmd_work);\n\n done:\n\tlbtf_deb_leave_args(LBTF_DEB_HOST, \"ret %p\", cmdnode);\n\treturn cmdnode;\n}\n\nvoid lbtf_cmd_async(struct lbtf_private *priv, uint16_t command,\n\tstruct cmd_header *in_cmd, int in_cmd_size)\n{\n\tlbtf_deb_enter(LBTF_DEB_CMD);\n\t__lbtf_cmd_async(priv, command, in_cmd, in_cmd_size, NULL, 0);\n\tlbtf_deb_leave(LBTF_DEB_CMD);\n}\n\nint __lbtf_cmd(struct lbtf_private *priv, uint16_t command,\n\t      struct cmd_header *in_cmd, int in_cmd_size,\n\t      int (*callback)(struct lbtf_private *,\n\t\t\t      unsigned long, struct cmd_header *),\n\t      unsigned long callback_arg)\n{\n\tstruct cmd_ctrl_node *cmdnode;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tlbtf_deb_enter(LBTF_DEB_HOST);\n\n\tcmdnode = __lbtf_cmd_async(priv, command, in_cmd, in_cmd_size,\n\t\t\t\t  callback, callback_arg);\n\tif (IS_ERR(cmdnode)) {\n\t\tret = PTR_ERR(cmdnode);\n\t\tgoto done;\n\t}\n\n\tmight_sleep();\n\tret = wait_event_interruptible(cmdnode->cmdwait_q,\n\t\t\t\t       cmdnode->cmdwaitqwoken);\n\tif (ret) {\n\t\tpr_info(\"PREP_CMD: command 0x%04x interrupted by signal: %d\\n\",\n\t\t\t    command, ret);\n\t\tgoto done;\n\t}\n\n\tspin_lock_irqsave(&priv->driver_lock, flags);\n\tret = cmdnode->result;\n\tif (ret)\n\t\tpr_info(\"PREP_CMD: command 0x%04x failed: %d\\n\",\n\t\t\t    command, ret);\n\n\t__lbtf_cleanup_and_insert_cmd(priv, cmdnode);\n\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\ndone:\n\tlbtf_deb_leave_args(LBTF_DEB_HOST, \"ret %d\", ret);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(__lbtf_cmd);\n\n \nvoid lbtf_cmd_response_rx(struct lbtf_private *priv)\n{\n\tpriv->cmd_response_rxed = 1;\n\tqueue_work(lbtf_wq, &priv->cmd_work);\n}\nEXPORT_SYMBOL_GPL(lbtf_cmd_response_rx);\n\nint lbtf_process_rx_command(struct lbtf_private *priv)\n{\n\tuint16_t respcmd, curcmd;\n\tstruct cmd_header *resp;\n\tint ret = 0;\n\tunsigned long flags;\n\tuint16_t result;\n\n\tlbtf_deb_enter(LBTF_DEB_CMD);\n\n\tmutex_lock(&priv->lock);\n\tspin_lock_irqsave(&priv->driver_lock, flags);\n\n\tif (!priv->cur_cmd) {\n\t\tret = -1;\n\t\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\t\tgoto done;\n\t}\n\n\tresp = (void *)priv->cmd_resp_buff;\n\tcurcmd = le16_to_cpu(priv->cur_cmd->cmdbuf->command);\n\trespcmd = le16_to_cpu(resp->command);\n\tresult = le16_to_cpu(resp->result);\n\n\tlbtf_deb_cmd(\"libertastf: cmd response 0x%04x, seq %d, size %d\\n\",\n\t\t     respcmd, le16_to_cpu(resp->seqnum),\n\t\t     le16_to_cpu(resp->size));\n\n\tif (resp->seqnum != priv->cur_cmd->cmdbuf->seqnum) {\n\t\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\t\tret = -1;\n\t\tgoto done;\n\t}\n\tif (respcmd != CMD_RET(curcmd)) {\n\t\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\t\tret = -1;\n\t\tgoto done;\n\t}\n\n\tif (resp->result == cpu_to_le16(0x0004)) {\n\t\t \n\t\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\t\tret = -1;\n\t\tgoto done;\n\t}\n\n\t \n\tdel_timer(&priv->command_timer);\n\tpriv->cmd_timed_out = 0;\n\tif (priv->nr_retries)\n\t\tpriv->nr_retries = 0;\n\n\t \n\tif ((result != 0 || !(respcmd & 0x8000))) {\n\t\t \n\t\tswitch (respcmd) {\n\t\tcase CMD_RET(CMD_GET_HW_SPEC):\n\t\tcase CMD_RET(CMD_802_11_RESET):\n\t\t\tpr_info(\"libertastf: reset failed\\n\");\n\t\t\tbreak;\n\n\t\t}\n\t\tlbtf_complete_command(priv, priv->cur_cmd, result);\n\t\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\n\t\tret = -1;\n\t\tgoto done;\n\t}\n\n\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\n\tif (priv->cur_cmd && priv->cur_cmd->callback) {\n\t\tret = priv->cur_cmd->callback(priv, priv->cur_cmd->callback_arg,\n\t\t\t\tresp);\n\t}\n\tspin_lock_irqsave(&priv->driver_lock, flags);\n\n\tif (priv->cur_cmd) {\n\t\t \n\t\tlbtf_complete_command(priv, priv->cur_cmd, result);\n\t}\n\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\ndone:\n\tmutex_unlock(&priv->lock);\n\tlbtf_deb_leave_args(LBTF_DEB_CMD, \"ret %d\", ret);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}