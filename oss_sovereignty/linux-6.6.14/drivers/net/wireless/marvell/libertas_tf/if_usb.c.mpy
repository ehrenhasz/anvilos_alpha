{
  "module_name": "if_usb.c",
  "hash_id": "e8bb1ae88ecc50536c4ed678b71f968e4425588ccc6f33c3dee23ff67731c281",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/marvell/libertas_tf/if_usb.c",
  "human_readable_source": "\n \n#define DRV_NAME \"lbtf_usb\"\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include \"libertas_tf.h\"\n#include \"if_usb.h\"\n\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/firmware.h>\n#include <linux/netdevice.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n\n#define INSANEDEBUG\t0\n#define lbtf_deb_usb2(...) do { if (INSANEDEBUG) lbtf_deb_usbd(__VA_ARGS__); } while (0)\n\n#define MESSAGE_HEADER_LEN\t4\n\nstatic char *lbtf_fw_name = \"lbtf_usb.bin\";\nmodule_param_named(fw_name, lbtf_fw_name, charp, 0644);\n\nMODULE_FIRMWARE(\"lbtf_usb.bin\");\n\nstatic const struct usb_device_id if_usb_table[] = {\n\t \n\t{ USB_DEVICE(0x1286, 0x2001) },\n\t{ USB_DEVICE(0x05a3, 0x8388) },\n\t{}\t \n};\n\nMODULE_DEVICE_TABLE(usb, if_usb_table);\n\nstatic void if_usb_receive(struct urb *urb);\nstatic void if_usb_receive_fwload(struct urb *urb);\nstatic int if_usb_prog_firmware(struct lbtf_private *priv);\nstatic int if_usb_host_to_card(struct lbtf_private *priv, uint8_t type,\n\t\t\t       uint8_t *payload, uint16_t nb);\nstatic int usb_tx_block(struct if_usb_card *cardp, uint8_t *payload,\n\t\t\tuint16_t nb, u8 data);\nstatic void if_usb_free(struct if_usb_card *cardp);\nstatic int if_usb_submit_rx_urb(struct if_usb_card *cardp);\nstatic int if_usb_reset_device(struct lbtf_private *priv);\n\n \nstatic void if_usb_write_bulk_callback(struct urb *urb)\n{\n\tif (urb->status != 0) {\n\t\t \n\t\tpr_info(\"URB in failure status: %d\\n\", urb->status);\n\t} else {\n\t\tlbtf_deb_usb2(&urb->dev->dev, \"URB status is successful\\n\");\n\t\tlbtf_deb_usb2(&urb->dev->dev, \"Actual length transmitted %d\\n\",\n\t\t\t     urb->actual_length);\n\t}\n}\n\n \nstatic void if_usb_free(struct if_usb_card *cardp)\n{\n\tlbtf_deb_enter(LBTF_DEB_USB);\n\n\t \n\tusb_kill_urb(cardp->tx_urb);\n\tusb_kill_urb(cardp->rx_urb);\n\tusb_kill_urb(cardp->cmd_urb);\n\n\tusb_free_urb(cardp->tx_urb);\n\tcardp->tx_urb = NULL;\n\n\tusb_free_urb(cardp->rx_urb);\n\tcardp->rx_urb = NULL;\n\n\tusb_free_urb(cardp->cmd_urb);\n\tcardp->cmd_urb = NULL;\n\n\tkfree(cardp->ep_out_buf);\n\tcardp->ep_out_buf = NULL;\n\n\tlbtf_deb_leave(LBTF_DEB_USB);\n}\n\nstatic void if_usb_setup_firmware(struct lbtf_private *priv)\n{\n\tstruct if_usb_card *cardp = priv->card;\n\tstruct cmd_ds_set_boot2_ver b2_cmd;\n\n\tlbtf_deb_enter(LBTF_DEB_USB);\n\n\tif_usb_submit_rx_urb(cardp);\n\tb2_cmd.hdr.size = cpu_to_le16(sizeof(b2_cmd));\n\tb2_cmd.action = 0;\n\tb2_cmd.version = cardp->boot2_version;\n\n\tif (lbtf_cmd_with_response(priv, CMD_SET_BOOT2_VER, &b2_cmd))\n\t\tlbtf_deb_usb(\"Setting boot2 version failed\\n\");\n\n\tlbtf_deb_leave(LBTF_DEB_USB);\n}\n\nstatic void if_usb_fw_timeo(struct timer_list *t)\n{\n\tstruct if_usb_card *cardp = from_timer(cardp, t, fw_timeout);\n\n\tlbtf_deb_enter(LBTF_DEB_USB);\n\tif (!cardp->fwdnldover) {\n\t\t \n\t\tcardp->priv->surpriseremoved = 1;\n\t\tpr_err(\"Download timed out\\n\");\n\t} else {\n\t\tlbtf_deb_usb(\"Download complete, no event. Assuming success\\n\");\n\t}\n\twake_up(&cardp->fw_wq);\n\tlbtf_deb_leave(LBTF_DEB_USB);\n}\n\nstatic const struct lbtf_ops if_usb_ops = {\n\t.hw_host_to_card = if_usb_host_to_card,\n\t.hw_prog_firmware = if_usb_prog_firmware,\n\t.hw_reset_device = if_usb_reset_device,\n};\n\n \nstatic int if_usb_probe(struct usb_interface *intf,\n\t\t\tconst struct usb_device_id *id)\n{\n\tstruct usb_device *udev;\n\tstruct usb_host_interface *iface_desc;\n\tstruct usb_endpoint_descriptor *endpoint;\n\tstruct lbtf_private *priv;\n\tstruct if_usb_card *cardp;\n\tint i;\n\n\tlbtf_deb_enter(LBTF_DEB_USB);\n\tudev = interface_to_usbdev(intf);\n\n\tcardp = kzalloc(sizeof(struct if_usb_card), GFP_KERNEL);\n\tif (!cardp)\n\t\tgoto error;\n\n\ttimer_setup(&cardp->fw_timeout, if_usb_fw_timeo, 0);\n\tinit_waitqueue_head(&cardp->fw_wq);\n\n\tcardp->udev = udev;\n\tiface_desc = intf->cur_altsetting;\n\n\tlbtf_deb_usbd(&udev->dev, \"bcdUSB = 0x%X bDeviceClass = 0x%X\"\n\t\t     \" bDeviceSubClass = 0x%X, bDeviceProtocol = 0x%X\\n\",\n\t\t     le16_to_cpu(udev->descriptor.bcdUSB),\n\t\t     udev->descriptor.bDeviceClass,\n\t\t     udev->descriptor.bDeviceSubClass,\n\t\t     udev->descriptor.bDeviceProtocol);\n\n\tfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\n\t\tendpoint = &iface_desc->endpoint[i].desc;\n\t\tif (usb_endpoint_is_bulk_in(endpoint)) {\n\t\t\tcardp->ep_in_size =\n\t\t\t\tle16_to_cpu(endpoint->wMaxPacketSize);\n\t\t\tcardp->ep_in = usb_endpoint_num(endpoint);\n\n\t\t\tlbtf_deb_usbd(&udev->dev, \"in_endpoint = %d\\n\",\n\t\t\t\tcardp->ep_in);\n\t\t\tlbtf_deb_usbd(&udev->dev, \"Bulk in size is %d\\n\",\n\t\t\t\tcardp->ep_in_size);\n\t\t} else if (usb_endpoint_is_bulk_out(endpoint)) {\n\t\t\tcardp->ep_out_size =\n\t\t\t\tle16_to_cpu(endpoint->wMaxPacketSize);\n\t\t\tcardp->ep_out = usb_endpoint_num(endpoint);\n\n\t\t\tlbtf_deb_usbd(&udev->dev, \"out_endpoint = %d\\n\",\n\t\t\t\tcardp->ep_out);\n\t\t\tlbtf_deb_usbd(&udev->dev, \"Bulk out size is %d\\n\",\n\t\t\t\tcardp->ep_out_size);\n\t\t}\n\t}\n\tif (!cardp->ep_out_size || !cardp->ep_in_size) {\n\t\tlbtf_deb_usbd(&udev->dev, \"Endpoints not found\\n\");\n\t\t \n\t\tgoto dealloc;\n\t}\n\n\tcardp->rx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!cardp->rx_urb)\n\t\tgoto dealloc;\n\n\tcardp->tx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!cardp->tx_urb)\n\t\tgoto dealloc;\n\n\tcardp->cmd_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!cardp->cmd_urb)\n\t\tgoto dealloc;\n\n\tcardp->ep_out_buf = kmalloc(MRVDRV_ETH_TX_PACKET_BUFFER_SIZE,\n\t\t\t\t    GFP_KERNEL);\n\tif (!cardp->ep_out_buf) {\n\t\tlbtf_deb_usbd(&udev->dev, \"Could not allocate buffer\\n\");\n\t\tgoto dealloc;\n\t}\n\n\tcardp->boot2_version = udev->descriptor.bcdDevice;\n\tpriv = lbtf_add_card(cardp, &udev->dev, &if_usb_ops);\n\tif (!priv)\n\t\tgoto dealloc;\n\n\tusb_get_dev(udev);\n\tusb_set_intfdata(intf, cardp);\n\n\treturn 0;\n\ndealloc:\n\tif_usb_free(cardp);\n\tkfree(cardp);\nerror:\nlbtf_deb_leave(LBTF_DEB_MAIN);\n\treturn -ENOMEM;\n}\n\n \nstatic void if_usb_disconnect(struct usb_interface *intf)\n{\n\tstruct if_usb_card *cardp = usb_get_intfdata(intf);\n\tstruct lbtf_private *priv = cardp->priv;\n\n\tlbtf_deb_enter(LBTF_DEB_MAIN);\n\n\tif (priv) {\n\t\tif_usb_reset_device(priv);\n\t\tlbtf_remove_card(priv);\n\t}\n\n\t \n\tif_usb_free(cardp);\n\tkfree(cardp);\n\n\tusb_set_intfdata(intf, NULL);\n\tusb_put_dev(interface_to_usbdev(intf));\n\n\tlbtf_deb_leave(LBTF_DEB_MAIN);\n}\n\n \nstatic int if_usb_send_fw_pkt(struct if_usb_card *cardp)\n{\n\tstruct fwdata *fwdata = cardp->ep_out_buf;\n\tu8 *firmware = (u8 *) cardp->fw->data;\n\n\tlbtf_deb_enter(LBTF_DEB_FW);\n\n\t \n\tif (!cardp->CRC_OK) {\n\t\tcardp->totalbytes = cardp->fwlastblksent;\n\t\tcardp->fwseqnum--;\n\t}\n\n\tlbtf_deb_usb2(&cardp->udev->dev, \"totalbytes = %d\\n\",\n\t\t     cardp->totalbytes);\n\n\t \n\tmemcpy(&fwdata->hdr, &firmware[cardp->totalbytes],\n\t       sizeof(struct fwheader));\n\n\tcardp->fwlastblksent = cardp->totalbytes;\n\tcardp->totalbytes += sizeof(struct fwheader);\n\n\tmemcpy(fwdata->data, &firmware[cardp->totalbytes],\n\t       le32_to_cpu(fwdata->hdr.datalength));\n\n\tlbtf_deb_usb2(&cardp->udev->dev, \"Data length = %d\\n\",\n\t\t     le32_to_cpu(fwdata->hdr.datalength));\n\n\tfwdata->seqnum = cpu_to_le32(++cardp->fwseqnum);\n\tcardp->totalbytes += le32_to_cpu(fwdata->hdr.datalength);\n\n\tusb_tx_block(cardp, cardp->ep_out_buf, sizeof(struct fwdata) +\n\t\t     le32_to_cpu(fwdata->hdr.datalength), 0);\n\n\tif (fwdata->hdr.dnldcmd == cpu_to_le32(FW_HAS_DATA_TO_RECV)) {\n\t\tlbtf_deb_usb2(&cardp->udev->dev, \"There are data to follow\\n\");\n\t\tlbtf_deb_usb2(&cardp->udev->dev,\n\t\t\t\"seqnum = %d totalbytes = %d\\n\",\n\t\t\tcardp->fwseqnum, cardp->totalbytes);\n\t} else if (fwdata->hdr.dnldcmd == cpu_to_le32(FW_HAS_LAST_BLOCK)) {\n\t\tlbtf_deb_usb2(&cardp->udev->dev,\n\t\t\t\"Host has finished FW downloading\\n\");\n\t\tlbtf_deb_usb2(&cardp->udev->dev, \"Downloading FW JUMP BLOCK\\n\");\n\n\t\t \n\t\tcardp->fwfinalblk = 1;\n\t}\n\n\tlbtf_deb_usb2(&cardp->udev->dev, \"Firmware download done; size %d\\n\",\n\t\t     cardp->totalbytes);\n\n\tlbtf_deb_leave(LBTF_DEB_FW);\n\treturn 0;\n}\n\nstatic int if_usb_reset_device(struct lbtf_private *priv)\n{\n\tstruct if_usb_card *cardp = priv->card;\n\tstruct cmd_ds_802_11_reset *cmd = cardp->ep_out_buf + 4;\n\tint ret;\n\n\tlbtf_deb_enter(LBTF_DEB_USB);\n\n\t*(__le32 *)cardp->ep_out_buf = cpu_to_le32(CMD_TYPE_REQUEST);\n\n\tcmd->hdr.command = cpu_to_le16(CMD_802_11_RESET);\n\tcmd->hdr.size = cpu_to_le16(sizeof(struct cmd_ds_802_11_reset));\n\tcmd->hdr.result = cpu_to_le16(0);\n\tcmd->hdr.seqnum = cpu_to_le16(0x5a5a);\n\tcmd->action = cpu_to_le16(CMD_ACT_HALT);\n\tusb_tx_block(cardp, cardp->ep_out_buf,\n\t\t     4 + sizeof(struct cmd_ds_802_11_reset), 0);\n\n\tmsleep(100);\n\tret = usb_reset_device(cardp->udev);\n\tmsleep(100);\n\n\tlbtf_deb_leave_args(LBTF_DEB_USB, \"ret %d\", ret);\n\n\treturn ret;\n}\n\n \nstatic int usb_tx_block(struct if_usb_card *cardp, uint8_t *payload,\n\t\t\tuint16_t nb, u8 data)\n{\n\tint ret = -1;\n\tstruct urb *urb;\n\n\tlbtf_deb_enter(LBTF_DEB_USB);\n\t \n\tif (cardp->priv->surpriseremoved) {\n\t\tlbtf_deb_usbd(&cardp->udev->dev, \"Device removed\\n\");\n\t\tgoto tx_ret;\n\t}\n\n\tif (data)\n\t\turb = cardp->tx_urb;\n\telse\n\t\turb = cardp->cmd_urb;\n\n\tusb_fill_bulk_urb(urb, cardp->udev,\n\t\t\t  usb_sndbulkpipe(cardp->udev,\n\t\t\t\t\t  cardp->ep_out),\n\t\t\t  payload, nb, if_usb_write_bulk_callback, cardp);\n\n\turb->transfer_flags |= URB_ZERO_PACKET;\n\n\tif (usb_submit_urb(urb, GFP_ATOMIC)) {\n\t\tlbtf_deb_usbd(&cardp->udev->dev,\n\t\t\t\"usb_submit_urb failed: %d\\n\", ret);\n\t\tgoto tx_ret;\n\t}\n\n\tlbtf_deb_usb2(&cardp->udev->dev, \"usb_submit_urb success\\n\");\n\n\tret = 0;\n\ntx_ret:\n\tlbtf_deb_leave(LBTF_DEB_USB);\n\treturn ret;\n}\n\nstatic int __if_usb_submit_rx_urb(struct if_usb_card *cardp,\n\t\t\t\t  void (*callbackfn)(struct urb *urb))\n{\n\tstruct sk_buff *skb;\n\tint ret = -1;\n\n\tlbtf_deb_enter(LBTF_DEB_USB);\n\n\tskb = dev_alloc_skb(MRVDRV_ETH_RX_PACKET_BUFFER_SIZE);\n\tif (!skb) {\n\t\tpr_err(\"No free skb\\n\");\n\t\tlbtf_deb_leave(LBTF_DEB_USB);\n\t\treturn -1;\n\t}\n\n\tcardp->rx_skb = skb;\n\n\t \n\tusb_fill_bulk_urb(cardp->rx_urb, cardp->udev,\n\t\t\t  usb_rcvbulkpipe(cardp->udev, cardp->ep_in),\n\t\t\t  skb_tail_pointer(skb),\n\t\t\t  MRVDRV_ETH_RX_PACKET_BUFFER_SIZE, callbackfn, cardp);\n\n\tlbtf_deb_usb2(&cardp->udev->dev, \"Pointer for rx_urb %p\\n\",\n\t\tcardp->rx_urb);\n\tret = usb_submit_urb(cardp->rx_urb, GFP_ATOMIC);\n\tif (ret) {\n\t\tlbtf_deb_usbd(&cardp->udev->dev,\n\t\t\t\"Submit Rx URB failed: %d\\n\", ret);\n\t\tkfree_skb(skb);\n\t\tcardp->rx_skb = NULL;\n\t\tlbtf_deb_leave(LBTF_DEB_USB);\n\t\treturn -1;\n\t} else {\n\t\tlbtf_deb_usb2(&cardp->udev->dev, \"Submit Rx URB success\\n\");\n\t\tlbtf_deb_leave(LBTF_DEB_USB);\n\t\treturn 0;\n\t}\n}\n\nstatic int if_usb_submit_rx_urb_fwload(struct if_usb_card *cardp)\n{\n\treturn __if_usb_submit_rx_urb(cardp, &if_usb_receive_fwload);\n}\n\nstatic int if_usb_submit_rx_urb(struct if_usb_card *cardp)\n{\n\treturn __if_usb_submit_rx_urb(cardp, &if_usb_receive);\n}\n\nstatic void if_usb_receive_fwload(struct urb *urb)\n{\n\tstruct if_usb_card *cardp = urb->context;\n\tstruct sk_buff *skb = cardp->rx_skb;\n\tstruct fwsyncheader *syncfwheader;\n\tstruct bootcmdresp bcmdresp;\n\n\tlbtf_deb_enter(LBTF_DEB_USB);\n\tif (urb->status) {\n\t\tlbtf_deb_usbd(&cardp->udev->dev,\n\t\t\t     \"URB status is failed during fw load\\n\");\n\t\tkfree_skb(skb);\n\t\tlbtf_deb_leave(LBTF_DEB_USB);\n\t\treturn;\n\t}\n\n\tif (cardp->fwdnldover) {\n\t\t__le32 *tmp = (__le32 *)(skb->data);\n\n\t\tif (tmp[0] == cpu_to_le32(CMD_TYPE_INDICATION) &&\n\t\t    tmp[1] == cpu_to_le32(MACREG_INT_CODE_FIRMWARE_READY)) {\n\t\t\t \n\t\t\tpr_info(\"Firmware ready event received\\n\");\n\t\t\twake_up(&cardp->fw_wq);\n\t\t} else {\n\t\t\tlbtf_deb_usb(\"Waiting for confirmation; got %x %x\\n\",\n\t\t\t\t    le32_to_cpu(tmp[0]), le32_to_cpu(tmp[1]));\n\t\t\tif_usb_submit_rx_urb_fwload(cardp);\n\t\t}\n\t\tkfree_skb(skb);\n\t\tlbtf_deb_leave(LBTF_DEB_USB);\n\t\treturn;\n\t}\n\tif (cardp->bootcmdresp <= 0) {\n\t\tmemcpy(&bcmdresp, skb->data, sizeof(bcmdresp));\n\n\t\tif (le16_to_cpu(cardp->udev->descriptor.bcdDevice) < 0x3106) {\n\t\t\tkfree_skb(skb);\n\t\t\tif_usb_submit_rx_urb_fwload(cardp);\n\t\t\tcardp->bootcmdresp = 1;\n\t\t\t \n\t\t\tlbtf_deb_usbd(&cardp->udev->dev,\n\t\t\t\t     \"Received valid boot command response\\n\");\n\t\t\tlbtf_deb_leave(LBTF_DEB_USB);\n\t\t\treturn;\n\t\t}\n\t\tif (bcmdresp.magic != cpu_to_le32(BOOT_CMD_MAGIC_NUMBER)) {\n\t\t\tif (bcmdresp.magic == cpu_to_le32(CMD_TYPE_REQUEST) ||\n\t\t\t    bcmdresp.magic == cpu_to_le32(CMD_TYPE_DATA) ||\n\t\t\t    bcmdresp.magic == cpu_to_le32(CMD_TYPE_INDICATION)) {\n\t\t\t\tif (!cardp->bootcmdresp)\n\t\t\t\t\tpr_info(\"Firmware already seems alive; resetting\\n\");\n\t\t\t\tcardp->bootcmdresp = -1;\n\t\t\t} else {\n\t\t\t\tpr_info(\"boot cmd response wrong magic number (0x%x)\\n\",\n\t\t\t\t\t    le32_to_cpu(bcmdresp.magic));\n\t\t\t}\n\t\t} else if (bcmdresp.cmd != BOOT_CMD_FW_BY_USB) {\n\t\t\tpr_info(\"boot cmd response cmd_tag error (%d)\\n\",\n\t\t\t\tbcmdresp.cmd);\n\t\t} else if (bcmdresp.result != BOOT_CMD_RESP_OK) {\n\t\t\tpr_info(\"boot cmd response result error (%d)\\n\",\n\t\t\t\tbcmdresp.result);\n\t\t} else {\n\t\t\tcardp->bootcmdresp = 1;\n\t\t\tlbtf_deb_usbd(&cardp->udev->dev,\n\t\t\t\t\"Received valid boot command response\\n\");\n\t\t}\n\n\t\tkfree_skb(skb);\n\t\tif_usb_submit_rx_urb_fwload(cardp);\n\t\tlbtf_deb_leave(LBTF_DEB_USB);\n\t\treturn;\n\t}\n\n\tsyncfwheader = kmemdup(skb->data, sizeof(struct fwsyncheader),\n\t\t\t       GFP_ATOMIC);\n\tif (!syncfwheader) {\n\t\tlbtf_deb_usbd(&cardp->udev->dev,\n\t\t\t\"Failure to allocate syncfwheader\\n\");\n\t\tkfree_skb(skb);\n\t\tlbtf_deb_leave(LBTF_DEB_USB);\n\t\treturn;\n\t}\n\n\tif (!syncfwheader->cmd) {\n\t\tlbtf_deb_usb2(&cardp->udev->dev,\n\t\t\t\"FW received Blk with correct CRC\\n\");\n\t\tlbtf_deb_usb2(&cardp->udev->dev,\n\t\t\t\"FW received Blk seqnum = %d\\n\",\n\t\t\tle32_to_cpu(syncfwheader->seqnum));\n\t\tcardp->CRC_OK = 1;\n\t} else {\n\t\tlbtf_deb_usbd(&cardp->udev->dev,\n\t\t\t\"FW received Blk with CRC error\\n\");\n\t\tcardp->CRC_OK = 0;\n\t}\n\n\tkfree_skb(skb);\n\n\t \n\tmod_timer(&cardp->fw_timeout, jiffies + (HZ/5));\n\n\tif (cardp->fwfinalblk) {\n\t\tcardp->fwdnldover = 1;\n\t\tgoto exit;\n\t}\n\n\tif_usb_send_fw_pkt(cardp);\n\n exit:\n\tif_usb_submit_rx_urb_fwload(cardp);\n\n\tkfree(syncfwheader);\n\n\tlbtf_deb_leave(LBTF_DEB_USB);\n}\n\n#define MRVDRV_MIN_PKT_LEN\t30\n\nstatic inline void process_cmdtypedata(int recvlength, struct sk_buff *skb,\n\t\t\t\t       struct if_usb_card *cardp,\n\t\t\t\t       struct lbtf_private *priv)\n{\n\tif (recvlength > MRVDRV_ETH_RX_PACKET_BUFFER_SIZE + MESSAGE_HEADER_LEN\n\t    || recvlength < MRVDRV_MIN_PKT_LEN) {\n\t\tlbtf_deb_usbd(&cardp->udev->dev, \"Packet length is Invalid\\n\");\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tskb_put(skb, recvlength);\n\tskb_pull(skb, MESSAGE_HEADER_LEN);\n\tlbtf_rx(priv, skb);\n}\n\nstatic inline void process_cmdrequest(int recvlength, uint8_t *recvbuff,\n\t\t\t\t      struct sk_buff *skb,\n\t\t\t\t      struct if_usb_card *cardp,\n\t\t\t\t      struct lbtf_private *priv)\n{\n\tunsigned long flags;\n\n\tif (recvlength < MESSAGE_HEADER_LEN ||\n\t    recvlength > LBS_CMD_BUFFER_SIZE) {\n\t\tlbtf_deb_usbd(&cardp->udev->dev,\n\t\t\t     \"The receive buffer is invalid: %d\\n\", recvlength);\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&priv->driver_lock, flags);\n\tmemcpy(priv->cmd_resp_buff, recvbuff + MESSAGE_HEADER_LEN,\n\t       recvlength - MESSAGE_HEADER_LEN);\n\tdev_kfree_skb_irq(skb);\n\tlbtf_cmd_response_rx(priv);\n\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n}\n\n \nstatic void if_usb_receive(struct urb *urb)\n{\n\tstruct if_usb_card *cardp = urb->context;\n\tstruct sk_buff *skb = cardp->rx_skb;\n\tstruct lbtf_private *priv = cardp->priv;\n\tint recvlength = urb->actual_length;\n\tuint8_t *recvbuff = NULL;\n\tuint32_t recvtype = 0;\n\t__le32 *pkt = (__le32 *) skb->data;\n\n\tlbtf_deb_enter(LBTF_DEB_USB);\n\n\tif (recvlength) {\n\t\tif (urb->status) {\n\t\t\tlbtf_deb_usbd(&cardp->udev->dev, \"RX URB failed: %d\\n\",\n\t\t\t\t     urb->status);\n\t\t\tkfree_skb(skb);\n\t\t\tgoto setup_for_next;\n\t\t}\n\n\t\trecvbuff = skb->data;\n\t\trecvtype = le32_to_cpu(pkt[0]);\n\t\tlbtf_deb_usbd(&cardp->udev->dev,\n\t\t\t    \"Recv length = 0x%x, Recv type = 0x%X\\n\",\n\t\t\t    recvlength, recvtype);\n\t} else if (urb->status) {\n\t\tkfree_skb(skb);\n\t\tlbtf_deb_leave(LBTF_DEB_USB);\n\t\treturn;\n\t}\n\n\tswitch (recvtype) {\n\tcase CMD_TYPE_DATA:\n\t\tprocess_cmdtypedata(recvlength, skb, cardp, priv);\n\t\tbreak;\n\n\tcase CMD_TYPE_REQUEST:\n\t\tprocess_cmdrequest(recvlength, recvbuff, skb, cardp, priv);\n\t\tbreak;\n\n\tcase CMD_TYPE_INDICATION:\n\t{\n\t\t \n\t\tu32 event_cause = le32_to_cpu(pkt[1]);\n\t\tlbtf_deb_usbd(&cardp->udev->dev, \"**EVENT** 0x%X\\n\",\n\t\t\tevent_cause);\n\n\t\t \n\t\tif (event_cause & 0xffff0000) {\n\t\t\tu16 tmp;\n\t\t\tu8 retrycnt;\n\t\t\tu8 failure;\n\n\t\t\ttmp = event_cause >> 16;\n\t\t\tretrycnt = tmp & 0x00ff;\n\t\t\tfailure = (tmp & 0xff00) >> 8;\n\t\t\tlbtf_send_tx_feedback(priv, retrycnt, failure);\n\t\t} else if (event_cause == LBTF_EVENT_BCN_SENT)\n\t\t\tlbtf_bcn_sent(priv);\n\t\telse\n\t\t\tlbtf_deb_usbd(&cardp->udev->dev,\n\t\t\t       \"Unsupported notification %d received\\n\",\n\t\t\t       event_cause);\n\t\tkfree_skb(skb);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tlbtf_deb_usbd(&cardp->udev->dev,\n\t\t\t\"libertastf: unknown command type 0x%X\\n\", recvtype);\n\t\tkfree_skb(skb);\n\t\tbreak;\n\t}\n\nsetup_for_next:\n\tif_usb_submit_rx_urb(cardp);\n\tlbtf_deb_leave(LBTF_DEB_USB);\n}\n\n \nstatic int if_usb_host_to_card(struct lbtf_private *priv, uint8_t type,\n\t\t\t       uint8_t *payload, uint16_t nb)\n{\n\tstruct if_usb_card *cardp = priv->card;\n\tu8 data = 0;\n\n\tlbtf_deb_usbd(&cardp->udev->dev, \"*** type = %u\\n\", type);\n\tlbtf_deb_usbd(&cardp->udev->dev, \"size after = %d\\n\", nb);\n\n\tif (type == MVMS_CMD) {\n\t\t*(__le32 *)cardp->ep_out_buf = cpu_to_le32(CMD_TYPE_REQUEST);\n\t} else {\n\t\t*(__le32 *)cardp->ep_out_buf = cpu_to_le32(CMD_TYPE_DATA);\n\t\tdata = 1;\n\t}\n\n\tmemcpy((cardp->ep_out_buf + MESSAGE_HEADER_LEN), payload, nb);\n\n\treturn usb_tx_block(cardp, cardp->ep_out_buf, nb + MESSAGE_HEADER_LEN,\n\t\t\t    data);\n}\n\n \nstatic int if_usb_issue_boot_command(struct if_usb_card *cardp, int ivalue)\n{\n\tstruct bootcmd *bootcmd = cardp->ep_out_buf;\n\n\t \n\tbootcmd->magic = cpu_to_le32(BOOT_CMD_MAGIC_NUMBER);\n\tbootcmd->cmd = ivalue;\n\tmemset(bootcmd->pad, 0, sizeof(bootcmd->pad));\n\n\t \n\tusb_tx_block(cardp, cardp->ep_out_buf, sizeof(*bootcmd), 0);\n\n\treturn 0;\n}\n\n\n \nstatic int check_fwfile_format(const u8 *data, u32 totlen)\n{\n\tu32 bincmd, exit;\n\tu32 blksize, offset, len;\n\tint ret;\n\n\tret = 1;\n\texit = len = 0;\n\n\tdo {\n\t\tstruct fwheader *fwh = (void *) data;\n\n\t\tbincmd = le32_to_cpu(fwh->dnldcmd);\n\t\tblksize = le32_to_cpu(fwh->datalength);\n\t\tswitch (bincmd) {\n\t\tcase FW_HAS_DATA_TO_RECV:\n\t\t\toffset = sizeof(struct fwheader) + blksize;\n\t\t\tdata += offset;\n\t\t\tlen += offset;\n\t\t\tif (len >= totlen)\n\t\t\t\texit = 1;\n\t\t\tbreak;\n\t\tcase FW_HAS_LAST_BLOCK:\n\t\t\texit = 1;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\texit = 1;\n\t\t\tbreak;\n\t\t}\n\t} while (!exit);\n\n\tif (ret)\n\t\tpr_err(\"firmware file format check FAIL\\n\");\n\telse\n\t\tlbtf_deb_fw(\"firmware file format check PASS\\n\");\n\n\treturn ret;\n}\n\n\nstatic int if_usb_prog_firmware(struct lbtf_private *priv)\n{\n\tstruct if_usb_card *cardp = priv->card;\n\tint i = 0;\n\tstatic int reset_count = 10;\n\tint ret = 0;\n\n\tlbtf_deb_enter(LBTF_DEB_USB);\n\n\tcardp->priv = priv;\n\n\tkernel_param_lock(THIS_MODULE);\n\tret = request_firmware(&cardp->fw, lbtf_fw_name, &cardp->udev->dev);\n\tif (ret < 0) {\n\t\tpr_err(\"request_firmware() failed with %#x\\n\", ret);\n\t\tpr_err(\"firmware %s not found\\n\", lbtf_fw_name);\n\t\tkernel_param_unlock(THIS_MODULE);\n\t\tgoto done;\n\t}\n\tkernel_param_unlock(THIS_MODULE);\n\n\tif (check_fwfile_format(cardp->fw->data, cardp->fw->size))\n\t\tgoto release_fw;\n\nrestart:\n\tif (if_usb_submit_rx_urb_fwload(cardp) < 0) {\n\t\tlbtf_deb_usbd(&cardp->udev->dev, \"URB submission is failed\\n\");\n\t\tret = -1;\n\t\tgoto release_fw;\n\t}\n\n\tcardp->bootcmdresp = 0;\n\tdo {\n\t\tint j = 0;\n\t\ti++;\n\t\t \n\t\tif_usb_issue_boot_command(cardp, BOOT_CMD_FW_BY_USB);\n\t\t \n\t\tdo {\n\t\t\tj++;\n\t\t\tmsleep_interruptible(100);\n\t\t} while (cardp->bootcmdresp == 0 && j < 10);\n\t} while (cardp->bootcmdresp == 0 && i < 5);\n\n\tif (cardp->bootcmdresp <= 0) {\n\t\tif (--reset_count >= 0) {\n\t\t\tif_usb_reset_device(priv);\n\t\t\tgoto restart;\n\t\t}\n\t\treturn -1;\n\t}\n\n\ti = 0;\n\n\tcardp->totalbytes = 0;\n\tcardp->fwlastblksent = 0;\n\tcardp->CRC_OK = 1;\n\tcardp->fwdnldover = 0;\n\tcardp->fwseqnum = -1;\n\tcardp->totalbytes = 0;\n\tcardp->fwfinalblk = 0;\n\n\t \n\tif_usb_send_fw_pkt(cardp);\n\n\t \n\twait_event_interruptible(cardp->fw_wq, cardp->priv->surpriseremoved ||\n\t\t\t\t\t       cardp->fwdnldover);\n\n\tdel_timer_sync(&cardp->fw_timeout);\n\tusb_kill_urb(cardp->rx_urb);\n\n\tif (!cardp->fwdnldover) {\n\t\tpr_info(\"failed to load fw, resetting device!\\n\");\n\t\tif (--reset_count >= 0) {\n\t\t\tif_usb_reset_device(priv);\n\t\t\tgoto restart;\n\t\t}\n\n\t\tpr_info(\"FW download failure, time = %d ms\\n\", i * 100);\n\t\tret = -1;\n\t\tgoto release_fw;\n\t}\n\n release_fw:\n\trelease_firmware(cardp->fw);\n\tcardp->fw = NULL;\n\n\tif_usb_setup_firmware(cardp->priv);\n\n done:\n\tlbtf_deb_leave_args(LBTF_DEB_USB, \"ret %d\", ret);\n\treturn ret;\n}\n\n\n#define if_usb_suspend NULL\n#define if_usb_resume NULL\n\nstatic struct usb_driver if_usb_driver = {\n\t.name = DRV_NAME,\n\t.probe = if_usb_probe,\n\t.disconnect = if_usb_disconnect,\n\t.id_table = if_usb_table,\n\t.suspend = if_usb_suspend,\n\t.resume = if_usb_resume,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(if_usb_driver);\n\nMODULE_DESCRIPTION(\"8388 USB WLAN Thinfirm Driver\");\nMODULE_AUTHOR(\"Cozybit Inc.\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}