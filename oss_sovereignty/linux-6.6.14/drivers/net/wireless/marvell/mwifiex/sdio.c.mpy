{
  "module_name": "sdio.c",
  "hash_id": "95aa4c51832e26ed699434362f286d176cd7f5fd1b993789484f3270456fb332",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/marvell/mwifiex/sdio.c",
  "human_readable_source": "\n \n\n#include <linux/firmware.h>\n\n#include \"decl.h\"\n#include \"ioctl.h\"\n#include \"util.h\"\n#include \"fw.h\"\n#include \"main.h\"\n#include \"wmm.h\"\n#include \"11n.h\"\n#include \"sdio.h\"\n\n\n#define SDIO_VERSION\t\"1.0\"\n\nstatic void mwifiex_sdio_work(struct work_struct *work);\n\nstatic struct mwifiex_if_ops sdio_ops;\n\nstatic const struct mwifiex_sdio_card_reg mwifiex_reg_sd87xx = {\n\t.start_rd_port = 1,\n\t.start_wr_port = 1,\n\t.base_0_reg = 0x0040,\n\t.base_1_reg = 0x0041,\n\t.poll_reg = 0x30,\n\t.host_int_enable = UP_LD_HOST_INT_MASK | DN_LD_HOST_INT_MASK,\n\t.host_int_rsr_reg = 0x1,\n\t.host_int_mask_reg = 0x02,\n\t.host_int_status_reg = 0x03,\n\t.status_reg_0 = 0x60,\n\t.status_reg_1 = 0x61,\n\t.sdio_int_mask = 0x3f,\n\t.data_port_mask = 0x0000fffe,\n\t.io_port_0_reg = 0x78,\n\t.io_port_1_reg = 0x79,\n\t.io_port_2_reg = 0x7A,\n\t.max_mp_regs = 64,\n\t.rd_bitmap_l = 0x04,\n\t.rd_bitmap_u = 0x05,\n\t.wr_bitmap_l = 0x06,\n\t.wr_bitmap_u = 0x07,\n\t.rd_len_p0_l = 0x08,\n\t.rd_len_p0_u = 0x09,\n\t.card_misc_cfg_reg = 0x6c,\n\t.func1_dump_reg_start = 0x0,\n\t.func1_dump_reg_end = 0x9,\n\t.func1_scratch_reg = 0x60,\n\t.func1_spec_reg_num = 5,\n\t.func1_spec_reg_table = {0x28, 0x30, 0x34, 0x38, 0x3c},\n};\n\nstatic const struct mwifiex_sdio_card_reg mwifiex_reg_sd8897 = {\n\t.start_rd_port = 0,\n\t.start_wr_port = 0,\n\t.base_0_reg = 0x60,\n\t.base_1_reg = 0x61,\n\t.poll_reg = 0x50,\n\t.host_int_enable = UP_LD_HOST_INT_MASK | DN_LD_HOST_INT_MASK |\n\t\t\tCMD_PORT_UPLD_INT_MASK | CMD_PORT_DNLD_INT_MASK,\n\t.host_int_rsr_reg = 0x1,\n\t.host_int_status_reg = 0x03,\n\t.host_int_mask_reg = 0x02,\n\t.status_reg_0 = 0xc0,\n\t.status_reg_1 = 0xc1,\n\t.sdio_int_mask = 0xff,\n\t.data_port_mask = 0xffffffff,\n\t.io_port_0_reg = 0xD8,\n\t.io_port_1_reg = 0xD9,\n\t.io_port_2_reg = 0xDA,\n\t.max_mp_regs = 184,\n\t.rd_bitmap_l = 0x04,\n\t.rd_bitmap_u = 0x05,\n\t.rd_bitmap_1l = 0x06,\n\t.rd_bitmap_1u = 0x07,\n\t.wr_bitmap_l = 0x08,\n\t.wr_bitmap_u = 0x09,\n\t.wr_bitmap_1l = 0x0a,\n\t.wr_bitmap_1u = 0x0b,\n\t.rd_len_p0_l = 0x0c,\n\t.rd_len_p0_u = 0x0d,\n\t.card_misc_cfg_reg = 0xcc,\n\t.card_cfg_2_1_reg = 0xcd,\n\t.cmd_rd_len_0 = 0xb4,\n\t.cmd_rd_len_1 = 0xb5,\n\t.cmd_rd_len_2 = 0xb6,\n\t.cmd_rd_len_3 = 0xb7,\n\t.cmd_cfg_0 = 0xb8,\n\t.cmd_cfg_1 = 0xb9,\n\t.cmd_cfg_2 = 0xba,\n\t.cmd_cfg_3 = 0xbb,\n\t.fw_dump_host_ready = 0xee,\n\t.fw_dump_ctrl = 0xe2,\n\t.fw_dump_start = 0xe3,\n\t.fw_dump_end = 0xea,\n\t.func1_dump_reg_start = 0x0,\n\t.func1_dump_reg_end = 0xb,\n\t.func1_scratch_reg = 0xc0,\n\t.func1_spec_reg_num = 8,\n\t.func1_spec_reg_table = {0x4C, 0x50, 0x54, 0x55, 0x58,\n\t\t\t\t 0x59, 0x5c, 0x5d},\n};\n\nstatic const struct mwifiex_sdio_card_reg mwifiex_reg_sd8977 = {\n\t.start_rd_port = 0,\n\t.start_wr_port = 0,\n\t.base_0_reg = 0xF8,\n\t.base_1_reg = 0xF9,\n\t.poll_reg = 0x5C,\n\t.host_int_enable = UP_LD_HOST_INT_MASK | DN_LD_HOST_INT_MASK |\n\t\tCMD_PORT_UPLD_INT_MASK | CMD_PORT_DNLD_INT_MASK,\n\t.host_int_rsr_reg = 0x4,\n\t.host_int_status_reg = 0x0C,\n\t.host_int_mask_reg = 0x08,\n\t.status_reg_0 = 0xE8,\n\t.status_reg_1 = 0xE9,\n\t.sdio_int_mask = 0xff,\n\t.data_port_mask = 0xffffffff,\n\t.io_port_0_reg = 0xE4,\n\t.io_port_1_reg = 0xE5,\n\t.io_port_2_reg = 0xE6,\n\t.max_mp_regs = 196,\n\t.rd_bitmap_l = 0x10,\n\t.rd_bitmap_u = 0x11,\n\t.rd_bitmap_1l = 0x12,\n\t.rd_bitmap_1u = 0x13,\n\t.wr_bitmap_l = 0x14,\n\t.wr_bitmap_u = 0x15,\n\t.wr_bitmap_1l = 0x16,\n\t.wr_bitmap_1u = 0x17,\n\t.rd_len_p0_l = 0x18,\n\t.rd_len_p0_u = 0x19,\n\t.card_misc_cfg_reg = 0xd8,\n\t.card_cfg_2_1_reg = 0xd9,\n\t.cmd_rd_len_0 = 0xc0,\n\t.cmd_rd_len_1 = 0xc1,\n\t.cmd_rd_len_2 = 0xc2,\n\t.cmd_rd_len_3 = 0xc3,\n\t.cmd_cfg_0 = 0xc4,\n\t.cmd_cfg_1 = 0xc5,\n\t.cmd_cfg_2 = 0xc6,\n\t.cmd_cfg_3 = 0xc7,\n\t.fw_dump_host_ready = 0xcc,\n\t.fw_dump_ctrl = 0xf0,\n\t.fw_dump_start = 0xf1,\n\t.fw_dump_end = 0xf8,\n\t.func1_dump_reg_start = 0x10,\n\t.func1_dump_reg_end = 0x17,\n\t.func1_scratch_reg = 0xe8,\n\t.func1_spec_reg_num = 13,\n\t.func1_spec_reg_table = {0x08, 0x58, 0x5C, 0x5D,\n\t\t\t\t 0x60, 0x61, 0x62, 0x64,\n\t\t\t\t 0x65, 0x66, 0x68, 0x69,\n\t\t\t\t 0x6a},\n};\n\nstatic const struct mwifiex_sdio_card_reg mwifiex_reg_sd8997 = {\n\t.start_rd_port = 0,\n\t.start_wr_port = 0,\n\t.base_0_reg = 0xF8,\n\t.base_1_reg = 0xF9,\n\t.poll_reg = 0x5C,\n\t.host_int_enable = UP_LD_HOST_INT_MASK | DN_LD_HOST_INT_MASK |\n\t\t\tCMD_PORT_UPLD_INT_MASK | CMD_PORT_DNLD_INT_MASK,\n\t.host_int_rsr_reg = 0x4,\n\t.host_int_status_reg = 0x0C,\n\t.host_int_mask_reg = 0x08,\n\t.host_strap_reg = 0xF4,\n\t.host_strap_mask = 0x01,\n\t.host_strap_value = 0x00,\n\t.status_reg_0 = 0xE8,\n\t.status_reg_1 = 0xE9,\n\t.sdio_int_mask = 0xff,\n\t.data_port_mask = 0xffffffff,\n\t.io_port_0_reg = 0xE4,\n\t.io_port_1_reg = 0xE5,\n\t.io_port_2_reg = 0xE6,\n\t.max_mp_regs = 196,\n\t.rd_bitmap_l = 0x10,\n\t.rd_bitmap_u = 0x11,\n\t.rd_bitmap_1l = 0x12,\n\t.rd_bitmap_1u = 0x13,\n\t.wr_bitmap_l = 0x14,\n\t.wr_bitmap_u = 0x15,\n\t.wr_bitmap_1l = 0x16,\n\t.wr_bitmap_1u = 0x17,\n\t.rd_len_p0_l = 0x18,\n\t.rd_len_p0_u = 0x19,\n\t.card_misc_cfg_reg = 0xd8,\n\t.card_cfg_2_1_reg = 0xd9,\n\t.cmd_rd_len_0 = 0xc0,\n\t.cmd_rd_len_1 = 0xc1,\n\t.cmd_rd_len_2 = 0xc2,\n\t.cmd_rd_len_3 = 0xc3,\n\t.cmd_cfg_0 = 0xc4,\n\t.cmd_cfg_1 = 0xc5,\n\t.cmd_cfg_2 = 0xc6,\n\t.cmd_cfg_3 = 0xc7,\n\t.fw_dump_host_ready = 0xcc,\n\t.fw_dump_ctrl = 0xf0,\n\t.fw_dump_start = 0xf1,\n\t.fw_dump_end = 0xf8,\n\t.func1_dump_reg_start = 0x10,\n\t.func1_dump_reg_end = 0x17,\n\t.func1_scratch_reg = 0xe8,\n\t.func1_spec_reg_num = 13,\n\t.func1_spec_reg_table = {0x08, 0x58, 0x5C, 0x5D,\n\t\t\t\t 0x60, 0x61, 0x62, 0x64,\n\t\t\t\t 0x65, 0x66, 0x68, 0x69,\n\t\t\t\t 0x6a},\n};\n\nstatic const struct mwifiex_sdio_card_reg mwifiex_reg_sd8887 = {\n\t.start_rd_port = 0,\n\t.start_wr_port = 0,\n\t.base_0_reg = 0x6C,\n\t.base_1_reg = 0x6D,\n\t.poll_reg = 0x5C,\n\t.host_int_enable = UP_LD_HOST_INT_MASK | DN_LD_HOST_INT_MASK |\n\t\t\tCMD_PORT_UPLD_INT_MASK | CMD_PORT_DNLD_INT_MASK,\n\t.host_int_rsr_reg = 0x4,\n\t.host_int_status_reg = 0x0C,\n\t.host_int_mask_reg = 0x08,\n\t.status_reg_0 = 0x90,\n\t.status_reg_1 = 0x91,\n\t.sdio_int_mask = 0xff,\n\t.data_port_mask = 0xffffffff,\n\t.io_port_0_reg = 0xE4,\n\t.io_port_1_reg = 0xE5,\n\t.io_port_2_reg = 0xE6,\n\t.max_mp_regs = 196,\n\t.rd_bitmap_l = 0x10,\n\t.rd_bitmap_u = 0x11,\n\t.rd_bitmap_1l = 0x12,\n\t.rd_bitmap_1u = 0x13,\n\t.wr_bitmap_l = 0x14,\n\t.wr_bitmap_u = 0x15,\n\t.wr_bitmap_1l = 0x16,\n\t.wr_bitmap_1u = 0x17,\n\t.rd_len_p0_l = 0x18,\n\t.rd_len_p0_u = 0x19,\n\t.card_misc_cfg_reg = 0xd8,\n\t.card_cfg_2_1_reg = 0xd9,\n\t.cmd_rd_len_0 = 0xc0,\n\t.cmd_rd_len_1 = 0xc1,\n\t.cmd_rd_len_2 = 0xc2,\n\t.cmd_rd_len_3 = 0xc3,\n\t.cmd_cfg_0 = 0xc4,\n\t.cmd_cfg_1 = 0xc5,\n\t.cmd_cfg_2 = 0xc6,\n\t.cmd_cfg_3 = 0xc7,\n\t.func1_dump_reg_start = 0x10,\n\t.func1_dump_reg_end = 0x17,\n\t.func1_scratch_reg = 0x90,\n\t.func1_spec_reg_num = 13,\n\t.func1_spec_reg_table = {0x08, 0x58, 0x5C, 0x5D, 0x60,\n\t\t\t\t 0x61, 0x62, 0x64, 0x65, 0x66,\n\t\t\t\t 0x68, 0x69, 0x6a},\n};\n\nstatic const struct mwifiex_sdio_card_reg mwifiex_reg_sd89xx = {\n\t.start_rd_port = 0,\n\t.start_wr_port = 0,\n\t.base_0_reg = 0xF8,\n\t.base_1_reg = 0xF9,\n\t.poll_reg = 0x5C,\n\t.host_int_enable = UP_LD_HOST_INT_MASK | DN_LD_HOST_INT_MASK |\n\t\t\tCMD_PORT_UPLD_INT_MASK | CMD_PORT_DNLD_INT_MASK,\n\t.host_int_rsr_reg = 0x4,\n\t.host_int_status_reg = 0x0C,\n\t.host_int_mask_reg = 0x08,\n\t.host_strap_reg = 0xF4,\n\t.host_strap_mask = 0x01,\n\t.host_strap_value = 0x00,\n\t.status_reg_0 = 0xE8,\n\t.status_reg_1 = 0xE9,\n\t.sdio_int_mask = 0xff,\n\t.data_port_mask = 0xffffffff,\n\t.io_port_0_reg = 0xE4,\n\t.io_port_1_reg = 0xE5,\n\t.io_port_2_reg = 0xE6,\n\t.max_mp_regs = 196,\n\t.rd_bitmap_l = 0x10,\n\t.rd_bitmap_u = 0x11,\n\t.rd_bitmap_1l = 0x12,\n\t.rd_bitmap_1u = 0x13,\n\t.wr_bitmap_l = 0x14,\n\t.wr_bitmap_u = 0x15,\n\t.wr_bitmap_1l = 0x16,\n\t.wr_bitmap_1u = 0x17,\n\t.rd_len_p0_l = 0x18,\n\t.rd_len_p0_u = 0x19,\n\t.card_misc_cfg_reg = 0xd8,\n\t.card_cfg_2_1_reg = 0xd9,\n\t.cmd_rd_len_0 = 0xc0,\n\t.cmd_rd_len_1 = 0xc1,\n\t.cmd_rd_len_2 = 0xc2,\n\t.cmd_rd_len_3 = 0xc3,\n\t.cmd_cfg_0 = 0xc4,\n\t.cmd_cfg_1 = 0xc5,\n\t.cmd_cfg_2 = 0xc6,\n\t.cmd_cfg_3 = 0xc7,\n\t.fw_dump_host_ready = 0xcc,\n\t.fw_dump_ctrl = 0xf9,\n\t.fw_dump_start = 0xf1,\n\t.fw_dump_end = 0xf8,\n\t.func1_dump_reg_start = 0x10,\n\t.func1_dump_reg_end = 0x17,\n\t.func1_scratch_reg = 0xE8,\n\t.func1_spec_reg_num = 13,\n\t.func1_spec_reg_table = {0x08, 0x58, 0x5C, 0x5D, 0x60,\n\t\t\t\t 0x61, 0x62, 0x64, 0x65, 0x66,\n\t\t\t\t 0x68, 0x69, 0x6a},\n};\n\nstatic const struct mwifiex_sdio_device mwifiex_sdio_sd8786 = {\n\t.firmware = SD8786_DEFAULT_FW_NAME,\n\t.reg = &mwifiex_reg_sd87xx,\n\t.max_ports = 16,\n\t.mp_agg_pkt_limit = 8,\n\t.tx_buf_size = MWIFIEX_TX_DATA_BUF_SIZE_2K,\n\t.mp_tx_agg_buf_size = MWIFIEX_MP_AGGR_BUF_SIZE_16K,\n\t.mp_rx_agg_buf_size = MWIFIEX_MP_AGGR_BUF_SIZE_16K,\n\t.supports_sdio_new_mode = false,\n\t.has_control_mask = true,\n\t.can_dump_fw = false,\n\t.can_auto_tdls = false,\n\t.can_ext_scan = false,\n\t.fw_ready_extra_delay = false,\n};\n\nstatic const struct mwifiex_sdio_device mwifiex_sdio_sd8787 = {\n\t.firmware = SD8787_DEFAULT_FW_NAME,\n\t.reg = &mwifiex_reg_sd87xx,\n\t.max_ports = 16,\n\t.mp_agg_pkt_limit = 8,\n\t.tx_buf_size = MWIFIEX_TX_DATA_BUF_SIZE_2K,\n\t.mp_tx_agg_buf_size = MWIFIEX_MP_AGGR_BUF_SIZE_16K,\n\t.mp_rx_agg_buf_size = MWIFIEX_MP_AGGR_BUF_SIZE_16K,\n\t.supports_sdio_new_mode = false,\n\t.has_control_mask = true,\n\t.can_dump_fw = false,\n\t.can_auto_tdls = false,\n\t.can_ext_scan = true,\n\t.fw_ready_extra_delay = false,\n};\n\nstatic const struct mwifiex_sdio_device mwifiex_sdio_sd8797 = {\n\t.firmware = SD8797_DEFAULT_FW_NAME,\n\t.reg = &mwifiex_reg_sd87xx,\n\t.max_ports = 16,\n\t.mp_agg_pkt_limit = 8,\n\t.tx_buf_size = MWIFIEX_TX_DATA_BUF_SIZE_2K,\n\t.mp_tx_agg_buf_size = MWIFIEX_MP_AGGR_BUF_SIZE_16K,\n\t.mp_rx_agg_buf_size = MWIFIEX_MP_AGGR_BUF_SIZE_16K,\n\t.supports_sdio_new_mode = false,\n\t.has_control_mask = true,\n\t.can_dump_fw = false,\n\t.can_auto_tdls = false,\n\t.can_ext_scan = true,\n\t.fw_ready_extra_delay = false,\n};\n\nstatic const struct mwifiex_sdio_device mwifiex_sdio_sd8897 = {\n\t.firmware = SD8897_DEFAULT_FW_NAME,\n\t.reg = &mwifiex_reg_sd8897,\n\t.max_ports = 32,\n\t.mp_agg_pkt_limit = 16,\n\t.tx_buf_size = MWIFIEX_TX_DATA_BUF_SIZE_4K,\n\t.mp_tx_agg_buf_size = MWIFIEX_MP_AGGR_BUF_SIZE_MAX,\n\t.mp_rx_agg_buf_size = MWIFIEX_MP_AGGR_BUF_SIZE_MAX,\n\t.supports_sdio_new_mode = true,\n\t.has_control_mask = false,\n\t.can_dump_fw = true,\n\t.can_auto_tdls = false,\n\t.can_ext_scan = true,\n\t.fw_ready_extra_delay = false,\n};\n\nstatic const struct mwifiex_sdio_device mwifiex_sdio_sd8977 = {\n\t.firmware = SD8977_DEFAULT_FW_NAME,\n\t.reg = &mwifiex_reg_sd8977,\n\t.max_ports = 32,\n\t.mp_agg_pkt_limit = 16,\n\t.tx_buf_size = MWIFIEX_TX_DATA_BUF_SIZE_4K,\n\t.mp_tx_agg_buf_size = MWIFIEX_MP_AGGR_BUF_SIZE_MAX,\n\t.mp_rx_agg_buf_size = MWIFIEX_MP_AGGR_BUF_SIZE_MAX,\n\t.supports_sdio_new_mode = true,\n\t.has_control_mask = false,\n\t.can_dump_fw = true,\n\t.fw_dump_enh = true,\n\t.can_auto_tdls = false,\n\t.can_ext_scan = true,\n\t.fw_ready_extra_delay = false,\n};\n\nstatic const struct mwifiex_sdio_device mwifiex_sdio_sd8978 = {\n\t.firmware_sdiouart = SD8978_SDIOUART_FW_NAME,\n\t.reg = &mwifiex_reg_sd89xx,\n\t.max_ports = 32,\n\t.mp_agg_pkt_limit = 16,\n\t.tx_buf_size = MWIFIEX_TX_DATA_BUF_SIZE_4K,\n\t.mp_tx_agg_buf_size = MWIFIEX_MP_AGGR_BUF_SIZE_MAX,\n\t.mp_rx_agg_buf_size = MWIFIEX_MP_AGGR_BUF_SIZE_MAX,\n\t.supports_sdio_new_mode = true,\n\t.has_control_mask = false,\n\t.can_dump_fw = true,\n\t.fw_dump_enh = true,\n\t.can_auto_tdls = false,\n\t.can_ext_scan = true,\n\t.fw_ready_extra_delay = true,\n};\n\nstatic const struct mwifiex_sdio_device mwifiex_sdio_sd8997 = {\n\t.firmware = SD8997_DEFAULT_FW_NAME,\n\t.firmware_sdiouart = SD8997_SDIOUART_FW_NAME,\n\t.reg = &mwifiex_reg_sd8997,\n\t.max_ports = 32,\n\t.mp_agg_pkt_limit = 16,\n\t.tx_buf_size = MWIFIEX_TX_DATA_BUF_SIZE_4K,\n\t.mp_tx_agg_buf_size = MWIFIEX_MP_AGGR_BUF_SIZE_MAX,\n\t.mp_rx_agg_buf_size = MWIFIEX_MP_AGGR_BUF_SIZE_MAX,\n\t.supports_sdio_new_mode = true,\n\t.has_control_mask = false,\n\t.can_dump_fw = true,\n\t.fw_dump_enh = true,\n\t.can_auto_tdls = false,\n\t.can_ext_scan = true,\n\t.fw_ready_extra_delay = false,\n};\n\nstatic const struct mwifiex_sdio_device mwifiex_sdio_sd8887 = {\n\t.firmware = SD8887_DEFAULT_FW_NAME,\n\t.reg = &mwifiex_reg_sd8887,\n\t.max_ports = 32,\n\t.mp_agg_pkt_limit = 16,\n\t.tx_buf_size = MWIFIEX_TX_DATA_BUF_SIZE_2K,\n\t.mp_tx_agg_buf_size = MWIFIEX_MP_AGGR_BUF_SIZE_32K,\n\t.mp_rx_agg_buf_size = MWIFIEX_MP_AGGR_BUF_SIZE_32K,\n\t.supports_sdio_new_mode = true,\n\t.has_control_mask = false,\n\t.can_dump_fw = false,\n\t.can_auto_tdls = true,\n\t.can_ext_scan = true,\n\t.fw_ready_extra_delay = false,\n};\n\nstatic const struct mwifiex_sdio_device mwifiex_sdio_sd8987 = {\n\t.firmware = SD8987_DEFAULT_FW_NAME,\n\t.reg = &mwifiex_reg_sd89xx,\n\t.max_ports = 32,\n\t.mp_agg_pkt_limit = 16,\n\t.tx_buf_size = MWIFIEX_TX_DATA_BUF_SIZE_2K,\n\t.mp_tx_agg_buf_size = MWIFIEX_MP_AGGR_BUF_SIZE_MAX,\n\t.mp_rx_agg_buf_size = MWIFIEX_MP_AGGR_BUF_SIZE_MAX,\n\t.supports_sdio_new_mode = true,\n\t.has_control_mask = false,\n\t.can_dump_fw = true,\n\t.fw_dump_enh = true,\n\t.can_auto_tdls = true,\n\t.can_ext_scan = true,\n\t.fw_ready_extra_delay = false,\n};\n\nstatic const struct mwifiex_sdio_device mwifiex_sdio_sd8801 = {\n\t.firmware = SD8801_DEFAULT_FW_NAME,\n\t.reg = &mwifiex_reg_sd87xx,\n\t.max_ports = 16,\n\t.mp_agg_pkt_limit = 8,\n\t.supports_sdio_new_mode = false,\n\t.has_control_mask = true,\n\t.tx_buf_size = MWIFIEX_TX_DATA_BUF_SIZE_2K,\n\t.mp_tx_agg_buf_size = MWIFIEX_MP_AGGR_BUF_SIZE_16K,\n\t.mp_rx_agg_buf_size = MWIFIEX_MP_AGGR_BUF_SIZE_16K,\n\t.can_dump_fw = false,\n\t.can_auto_tdls = false,\n\t.can_ext_scan = true,\n\t.fw_ready_extra_delay = false,\n};\n\nstatic struct memory_type_mapping generic_mem_type_map[] = {\n\t{\"DUMP\", NULL, 0, 0xDD},\n};\n\nstatic struct memory_type_mapping mem_type_mapping_tbl[] = {\n\t{\"ITCM\", NULL, 0, 0xF0},\n\t{\"DTCM\", NULL, 0, 0xF1},\n\t{\"SQRAM\", NULL, 0, 0xF2},\n\t{\"APU\", NULL, 0, 0xF3},\n\t{\"CIU\", NULL, 0, 0xF4},\n\t{\"ICU\", NULL, 0, 0xF5},\n\t{\"MAC\", NULL, 0, 0xF6},\n\t{\"EXT7\", NULL, 0, 0xF7},\n\t{\"EXT8\", NULL, 0, 0xF8},\n\t{\"EXT9\", NULL, 0, 0xF9},\n\t{\"EXT10\", NULL, 0, 0xFA},\n\t{\"EXT11\", NULL, 0, 0xFB},\n\t{\"EXT12\", NULL, 0, 0xFC},\n\t{\"EXT13\", NULL, 0, 0xFD},\n\t{\"EXTLAST\", NULL, 0, 0xFE},\n};\n\nstatic const struct of_device_id mwifiex_sdio_of_match_table[] __maybe_unused = {\n\t{ .compatible = \"marvell,sd8787\" },\n\t{ .compatible = \"marvell,sd8897\" },\n\t{ .compatible = \"marvell,sd8978\" },\n\t{ .compatible = \"marvell,sd8997\" },\n\t{ .compatible = \"nxp,iw416\" },\n\t{ }\n};\n\n \nstatic int mwifiex_sdio_probe_of(struct device *dev)\n{\n\tif (!of_match_node(mwifiex_sdio_of_match_table, dev->of_node)) {\n\t\tdev_err(dev, \"required compatible string missing\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nmwifiex_sdio_probe(struct sdio_func *func, const struct sdio_device_id *id)\n{\n\tint ret;\n\tstruct sdio_mmc_card *card = NULL;\n\n\tpr_debug(\"info: vendor=0x%4.04X device=0x%4.04X class=%d function=%d\\n\",\n\t\t func->vendor, func->device, func->class, func->num);\n\n\tcard = devm_kzalloc(&func->dev, sizeof(*card), GFP_KERNEL);\n\tif (!card)\n\t\treturn -ENOMEM;\n\n\tinit_completion(&card->fw_done);\n\n\tcard->func = func;\n\n\tfunc->card->quirks |= MMC_QUIRK_BLKSZ_FOR_BYTE_MODE;\n\n\tif (id->driver_data) {\n\t\tstruct mwifiex_sdio_device *data = (void *)id->driver_data;\n\n\t\tcard->firmware = data->firmware;\n\t\tcard->firmware_sdiouart = data->firmware_sdiouart;\n\t\tcard->reg = data->reg;\n\t\tcard->max_ports = data->max_ports;\n\t\tcard->mp_agg_pkt_limit = data->mp_agg_pkt_limit;\n\t\tcard->supports_sdio_new_mode = data->supports_sdio_new_mode;\n\t\tcard->has_control_mask = data->has_control_mask;\n\t\tcard->tx_buf_size = data->tx_buf_size;\n\t\tcard->mp_tx_agg_buf_size = data->mp_tx_agg_buf_size;\n\t\tcard->mp_rx_agg_buf_size = data->mp_rx_agg_buf_size;\n\t\tcard->can_dump_fw = data->can_dump_fw;\n\t\tcard->fw_dump_enh = data->fw_dump_enh;\n\t\tcard->can_auto_tdls = data->can_auto_tdls;\n\t\tcard->can_ext_scan = data->can_ext_scan;\n\t\tcard->fw_ready_extra_delay = data->fw_ready_extra_delay;\n\t\tINIT_WORK(&card->work, mwifiex_sdio_work);\n\t}\n\n\tsdio_claim_host(func);\n\tret = sdio_enable_func(func);\n\tsdio_release_host(func);\n\n\tif (ret) {\n\t\tdev_err(&func->dev, \"failed to enable function\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (func->dev.of_node) {\n\t\tret = mwifiex_sdio_probe_of(&func->dev);\n\t\tif (ret)\n\t\t\tgoto err_disable;\n\t}\n\n\tret = mwifiex_add_card(card, &card->fw_done, &sdio_ops,\n\t\t\t       MWIFIEX_SDIO, &func->dev);\n\tif (ret) {\n\t\tdev_err(&func->dev, \"add card failed\\n\");\n\t\tgoto err_disable;\n\t}\n\n\treturn 0;\n\nerr_disable:\n\tsdio_claim_host(func);\n\tsdio_disable_func(func);\n\tsdio_release_host(func);\n\n\treturn ret;\n}\n\n \nstatic int mwifiex_sdio_resume(struct device *dev)\n{\n\tstruct sdio_func *func = dev_to_sdio_func(dev);\n\tstruct sdio_mmc_card *card;\n\tstruct mwifiex_adapter *adapter;\n\n\tcard = sdio_get_drvdata(func);\n\tif (!card || !card->adapter) {\n\t\tdev_err(dev, \"resume: invalid card or adapter\\n\");\n\t\treturn 0;\n\t}\n\n\tadapter = card->adapter;\n\n\tif (!test_bit(MWIFIEX_IS_SUSPENDED, &adapter->work_flags)) {\n\t\tmwifiex_dbg(adapter, WARN,\n\t\t\t    \"device already resumed\\n\");\n\t\treturn 0;\n\t}\n\n\tclear_bit(MWIFIEX_IS_SUSPENDED, &adapter->work_flags);\n\n\t \n\tmwifiex_cancel_hs(mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_STA),\n\t\t\t  MWIFIEX_SYNC_CMD);\n\n\tmwifiex_disable_wake(adapter);\n\n\treturn 0;\n}\n\n \nstatic int\nmwifiex_write_reg_locked(struct sdio_func *func, u32 reg, u8 data)\n{\n\tint ret = -1;\n\n\tsdio_writeb(func, data, reg, &ret);\n\treturn ret;\n}\n\n \nstatic int\nmwifiex_write_reg(struct mwifiex_adapter *adapter, u32 reg, u8 data)\n{\n\tstruct sdio_mmc_card *card = adapter->card;\n\tint ret;\n\n\tsdio_claim_host(card->func);\n\tret = mwifiex_write_reg_locked(card->func, reg, data);\n\tsdio_release_host(card->func);\n\n\treturn ret;\n}\n\n \nstatic int\nmwifiex_read_reg(struct mwifiex_adapter *adapter, u32 reg, u8 *data)\n{\n\tstruct sdio_mmc_card *card = adapter->card;\n\tint ret = -1;\n\tu8 val;\n\n\tsdio_claim_host(card->func);\n\tval = sdio_readb(card->func, reg, &ret);\n\tsdio_release_host(card->func);\n\n\t*data = val;\n\n\treturn ret;\n}\n\n \nstatic int\nmwifiex_write_data_sync(struct mwifiex_adapter *adapter,\n\t\t\tu8 *buffer, u32 pkt_len, u32 port)\n{\n\tstruct sdio_mmc_card *card = adapter->card;\n\tint ret;\n\tu8 blk_mode =\n\t\t(port & MWIFIEX_SDIO_BYTE_MODE_MASK) ? BYTE_MODE : BLOCK_MODE;\n\tu32 blk_size = (blk_mode == BLOCK_MODE) ? MWIFIEX_SDIO_BLOCK_SIZE : 1;\n\tu32 blk_cnt =\n\t\t(blk_mode ==\n\t\t BLOCK_MODE) ? (pkt_len /\n\t\t\t\tMWIFIEX_SDIO_BLOCK_SIZE) : pkt_len;\n\tu32 ioport = (port & MWIFIEX_SDIO_IO_PORT_MASK);\n\n\tif (test_bit(MWIFIEX_IS_SUSPENDED, &adapter->work_flags)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"%s: not allowed while suspended\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\tsdio_claim_host(card->func);\n\n\tret = sdio_writesb(card->func, ioport, buffer, blk_cnt * blk_size);\n\n\tsdio_release_host(card->func);\n\n\treturn ret;\n}\n\n \nstatic int mwifiex_read_data_sync(struct mwifiex_adapter *adapter, u8 *buffer,\n\t\t\t\t  u32 len, u32 port, u8 claim)\n{\n\tstruct sdio_mmc_card *card = adapter->card;\n\tint ret;\n\tu8 blk_mode = (port & MWIFIEX_SDIO_BYTE_MODE_MASK) ? BYTE_MODE\n\t\t       : BLOCK_MODE;\n\tu32 blk_size = (blk_mode == BLOCK_MODE) ? MWIFIEX_SDIO_BLOCK_SIZE : 1;\n\tu32 blk_cnt = (blk_mode == BLOCK_MODE) ? (len / MWIFIEX_SDIO_BLOCK_SIZE)\n\t\t\t: len;\n\tu32 ioport = (port & MWIFIEX_SDIO_IO_PORT_MASK);\n\n\tif (claim)\n\t\tsdio_claim_host(card->func);\n\n\tret = sdio_readsb(card->func, buffer, ioport, blk_cnt * blk_size);\n\n\tif (claim)\n\t\tsdio_release_host(card->func);\n\n\treturn ret;\n}\n\n \nstatic int\nmwifiex_sdio_read_fw_status(struct mwifiex_adapter *adapter, u16 *dat)\n{\n\tstruct sdio_mmc_card *card = adapter->card;\n\tconst struct mwifiex_sdio_card_reg *reg = card->reg;\n\tu8 fws0, fws1;\n\n\tif (mwifiex_read_reg(adapter, reg->status_reg_0, &fws0))\n\t\treturn -1;\n\n\tif (mwifiex_read_reg(adapter, reg->status_reg_1, &fws1))\n\t\treturn -1;\n\n\t*dat = (u16)((fws1 << 8) | fws0);\n\treturn 0;\n}\n\n \nstatic int mwifiex_check_fw_status(struct mwifiex_adapter *adapter,\n\t\t\t\t   u32 poll_num)\n{\n\tstruct sdio_mmc_card *card = adapter->card;\n\tint ret = 0;\n\tu16 firmware_stat = 0;\n\tu32 tries;\n\n\tfor (tries = 0; tries < poll_num; tries++) {\n\t\tret = mwifiex_sdio_read_fw_status(adapter, &firmware_stat);\n\t\tif (ret)\n\t\t\tcontinue;\n\t\tif (firmware_stat == FIRMWARE_READY_SDIO) {\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tmsleep(100);\n\t\tret = -1;\n\t}\n\n\tif (card->fw_ready_extra_delay &&\n\t    firmware_stat == FIRMWARE_READY_SDIO)\n\t\t \n\t\tmsleep(100);\n\n\treturn ret;\n}\n\n \nstatic int mwifiex_check_winner_status(struct mwifiex_adapter *adapter)\n{\n\tint ret = 0;\n\tu8 winner = 0;\n\tstruct sdio_mmc_card *card = adapter->card;\n\n\tif (mwifiex_read_reg(adapter, card->reg->status_reg_0, &winner))\n\t\treturn -1;\n\n\tif (winner)\n\t\tadapter->winner = 0;\n\telse\n\t\tadapter->winner = 1;\n\n\treturn ret;\n}\n\n \nstatic void\nmwifiex_sdio_remove(struct sdio_func *func)\n{\n\tstruct sdio_mmc_card *card;\n\tstruct mwifiex_adapter *adapter;\n\tstruct mwifiex_private *priv;\n\tint ret = 0;\n\tu16 firmware_stat;\n\n\tcard = sdio_get_drvdata(func);\n\tif (!card)\n\t\treturn;\n\n\twait_for_completion(&card->fw_done);\n\n\tadapter = card->adapter;\n\tif (!adapter || !adapter->priv_num)\n\t\treturn;\n\n\tmwifiex_dbg(adapter, INFO, \"info: SDIO func num=%d\\n\", func->num);\n\n\tret = mwifiex_sdio_read_fw_status(adapter, &firmware_stat);\n\tif (!ret && firmware_stat == FIRMWARE_READY_SDIO &&\n\t    !adapter->mfg_mode) {\n\t\tmwifiex_deauthenticate_all(adapter);\n\n\t\tpriv = mwifiex_get_priv(adapter, MWIFIEX_BSS_ROLE_ANY);\n\t\tmwifiex_disable_auto_ds(priv);\n\t\tmwifiex_init_shutdown_fw(priv, MWIFIEX_FUNC_SHUTDOWN);\n\t}\n\n\tmwifiex_remove_card(adapter);\n}\n\n \nstatic int mwifiex_sdio_suspend(struct device *dev)\n{\n\tstruct sdio_func *func = dev_to_sdio_func(dev);\n\tstruct sdio_mmc_card *card;\n\tstruct mwifiex_adapter *adapter;\n\tmmc_pm_flag_t pm_flag = 0;\n\tint ret = 0;\n\n\tpm_flag = sdio_get_host_pm_caps(func);\n\tpr_debug(\"cmd: %s: suspend: PM flag = 0x%x\\n\",\n\t\t sdio_func_id(func), pm_flag);\n\tif (!(pm_flag & MMC_PM_KEEP_POWER)) {\n\t\tdev_err(dev, \"%s: cannot remain alive while host is\"\n\t\t\t\" suspended\\n\", sdio_func_id(func));\n\t\treturn -ENOSYS;\n\t}\n\n\tcard = sdio_get_drvdata(func);\n\tif (!card) {\n\t\tdev_err(dev, \"suspend: invalid card\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\twait_for_completion(&card->fw_done);\n\n\tadapter = card->adapter;\n\tif (!adapter) {\n\t\tdev_err(dev, \"adapter is not valid\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!adapter->is_up)\n\t\treturn -EBUSY;\n\n\tmwifiex_enable_wake(adapter);\n\n\t \n\tif (!mwifiex_enable_hs(adapter)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"cmd: failed to suspend\\n\");\n\t\tclear_bit(MWIFIEX_IS_HS_ENABLING, &adapter->work_flags);\n\t\tmwifiex_disable_wake(adapter);\n\t\treturn -EFAULT;\n\t}\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"cmd: suspend with MMC_PM_KEEP_POWER\\n\");\n\tret = sdio_set_host_pm_flags(func, MMC_PM_KEEP_POWER);\n\n\t \n\tset_bit(MWIFIEX_IS_SUSPENDED, &adapter->work_flags);\n\tclear_bit(MWIFIEX_IS_HS_ENABLING, &adapter->work_flags);\n\n\treturn ret;\n}\n\nstatic void mwifiex_sdio_coredump(struct device *dev)\n{\n\tstruct sdio_func *func = dev_to_sdio_func(dev);\n\tstruct sdio_mmc_card *card;\n\n\tcard = sdio_get_drvdata(func);\n\tif (!test_and_set_bit(MWIFIEX_IFACE_WORK_DEVICE_DUMP,\n\t\t\t      &card->work_flags))\n\t\tschedule_work(&card->work);\n}\n\n \nstatic const struct sdio_device_id mwifiex_ids[] = {\n\t{SDIO_DEVICE(SDIO_VENDOR_ID_MARVELL, SDIO_DEVICE_ID_MARVELL_8786_WLAN),\n\t\t.driver_data = (unsigned long) &mwifiex_sdio_sd8786},\n\t{SDIO_DEVICE(SDIO_VENDOR_ID_MARVELL, SDIO_DEVICE_ID_MARVELL_8787_WLAN),\n\t\t.driver_data = (unsigned long) &mwifiex_sdio_sd8787},\n\t{SDIO_DEVICE(SDIO_VENDOR_ID_MARVELL, SDIO_DEVICE_ID_MARVELL_8797_WLAN),\n\t\t.driver_data = (unsigned long) &mwifiex_sdio_sd8797},\n\t{SDIO_DEVICE(SDIO_VENDOR_ID_MARVELL, SDIO_DEVICE_ID_MARVELL_8897_WLAN),\n\t\t.driver_data = (unsigned long) &mwifiex_sdio_sd8897},\n\t{SDIO_DEVICE(SDIO_VENDOR_ID_MARVELL, SDIO_DEVICE_ID_MARVELL_8887_WLAN),\n\t\t.driver_data = (unsigned long)&mwifiex_sdio_sd8887},\n\t{SDIO_DEVICE(SDIO_VENDOR_ID_MARVELL, SDIO_DEVICE_ID_MARVELL_8801_WLAN),\n\t\t.driver_data = (unsigned long)&mwifiex_sdio_sd8801},\n\t{SDIO_DEVICE(SDIO_VENDOR_ID_MARVELL, SDIO_DEVICE_ID_MARVELL_8977_WLAN),\n\t\t.driver_data = (unsigned long)&mwifiex_sdio_sd8977},\n\t{SDIO_DEVICE(SDIO_VENDOR_ID_MARVELL, SDIO_DEVICE_ID_MARVELL_8978_WLAN),\n\t\t.driver_data = (unsigned long)&mwifiex_sdio_sd8978},\n\t{SDIO_DEVICE(SDIO_VENDOR_ID_MARVELL, SDIO_DEVICE_ID_MARVELL_8987_WLAN),\n\t\t.driver_data = (unsigned long)&mwifiex_sdio_sd8987},\n\t{SDIO_DEVICE(SDIO_VENDOR_ID_MARVELL, SDIO_DEVICE_ID_MARVELL_8997_WLAN),\n\t\t.driver_data = (unsigned long)&mwifiex_sdio_sd8997},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(sdio, mwifiex_ids);\n\nstatic const struct dev_pm_ops mwifiex_sdio_pm_ops = {\n\t.suspend = mwifiex_sdio_suspend,\n\t.resume = mwifiex_sdio_resume,\n};\n\nstatic struct sdio_driver mwifiex_sdio = {\n\t.name = \"mwifiex_sdio\",\n\t.id_table = mwifiex_ids,\n\t.probe = mwifiex_sdio_probe,\n\t.remove = mwifiex_sdio_remove,\n\t.drv = {\n\t\t.owner = THIS_MODULE,\n\t\t.coredump = mwifiex_sdio_coredump,\n\t\t.pm = &mwifiex_sdio_pm_ops,\n\t}\n};\n\n \nstatic int mwifiex_pm_wakeup_card(struct mwifiex_adapter *adapter)\n{\n\tmwifiex_dbg(adapter, EVENT,\n\t\t    \"event: wakeup device...\\n\");\n\n\treturn mwifiex_write_reg(adapter, CONFIGURATION_REG, HOST_POWER_UP);\n}\n\n \nstatic int mwifiex_pm_wakeup_card_complete(struct mwifiex_adapter *adapter)\n{\n\tmwifiex_dbg(adapter, EVENT,\n\t\t    \"cmd: wakeup device completed\\n\");\n\n\treturn mwifiex_write_reg(adapter, CONFIGURATION_REG, 0);\n}\n\nstatic int mwifiex_sdio_dnld_fw(struct mwifiex_adapter *adapter,\n\t\t\tstruct mwifiex_fw_image *fw)\n{\n\tstruct sdio_mmc_card *card = adapter->card;\n\tint ret;\n\n\tsdio_claim_host(card->func);\n\tret = mwifiex_dnld_fw(adapter, fw);\n\tsdio_release_host(card->func);\n\n\treturn ret;\n}\n\n \nstatic int mwifiex_init_sdio_new_mode(struct mwifiex_adapter *adapter)\n{\n\tu8 reg;\n\tstruct sdio_mmc_card *card = adapter->card;\n\n\tadapter->ioport = MEM_PORT;\n\n\t \n\tif (mwifiex_read_reg(adapter, card->reg->card_cfg_2_1_reg, &reg))\n\t\treturn -1;\n\tif (mwifiex_write_reg(adapter, card->reg->card_cfg_2_1_reg,\n\t\t\t      reg | CMD53_NEW_MODE))\n\t\treturn -1;\n\n\t \n\tif (mwifiex_read_reg(adapter, card->reg->cmd_cfg_0, &reg))\n\t\treturn -1;\n\tif (mwifiex_write_reg(adapter, card->reg->cmd_cfg_0,\n\t\t\t      reg | CMD_PORT_RD_LEN_EN))\n\t\treturn -1;\n\n\t \n\tif (mwifiex_read_reg(adapter, card->reg->cmd_cfg_1, &reg))\n\t\treturn -1;\n\tif (mwifiex_write_reg(adapter, card->reg->cmd_cfg_1,\n\t\t\t      reg | CMD_PORT_AUTO_EN))\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_init_sdio_ioport(struct mwifiex_adapter *adapter)\n{\n\tu8 reg;\n\tstruct sdio_mmc_card *card = adapter->card;\n\n\tadapter->ioport = 0;\n\n\tif (card->supports_sdio_new_mode) {\n\t\tif (mwifiex_init_sdio_new_mode(adapter))\n\t\t\treturn -1;\n\t\tgoto cont;\n\t}\n\n\t \n\tif (!mwifiex_read_reg(adapter, card->reg->io_port_0_reg, &reg))\n\t\tadapter->ioport |= (reg & 0xff);\n\telse\n\t\treturn -1;\n\n\tif (!mwifiex_read_reg(adapter, card->reg->io_port_1_reg, &reg))\n\t\tadapter->ioport |= ((reg & 0xff) << 8);\n\telse\n\t\treturn -1;\n\n\tif (!mwifiex_read_reg(adapter, card->reg->io_port_2_reg, &reg))\n\t\tadapter->ioport |= ((reg & 0xff) << 16);\n\telse\n\t\treturn -1;\ncont:\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: SDIO FUNC1 IO port: %#x\\n\", adapter->ioport);\n\n\t \n\tif (mwifiex_read_reg(adapter, card->reg->host_int_rsr_reg, &reg))\n\t\treturn -1;\n\tif (mwifiex_write_reg(adapter, card->reg->host_int_rsr_reg,\n\t\t\t      reg | card->reg->sdio_int_mask))\n\t\treturn -1;\n\n\t \n\tif (mwifiex_read_reg(adapter, card->reg->card_misc_cfg_reg, &reg))\n\t\treturn -1;\n\tif (mwifiex_write_reg(adapter, card->reg->card_misc_cfg_reg,\n\t\t\t      reg | AUTO_RE_ENABLE_INT))\n\t\treturn -1;\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_write_data_to_card(struct mwifiex_adapter *adapter,\n\t\t\t\t      u8 *payload, u32 pkt_len, u32 port)\n{\n\tu32 i = 0;\n\tint ret;\n\n\tdo {\n\t\tret = mwifiex_write_data_sync(adapter, payload, pkt_len, port);\n\t\tif (ret) {\n\t\t\ti++;\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"host_to_card, write iomem\\t\"\n\t\t\t\t    \"(%d) failed: %d\\n\", i, ret);\n\t\t\tif (mwifiex_write_reg(adapter, CONFIGURATION_REG, 0x04))\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"write CFG reg failed\\n\");\n\n\t\t\tret = -1;\n\t\t\tif (i > MAX_WRITE_IOMEM_RETRY)\n\t\t\t\treturn ret;\n\t\t}\n\t} while (ret == -1);\n\n\treturn ret;\n}\n\n \nstatic int mwifiex_get_rd_port(struct mwifiex_adapter *adapter, u8 *port)\n{\n\tstruct sdio_mmc_card *card = adapter->card;\n\tconst struct mwifiex_sdio_card_reg *reg = card->reg;\n\tu32 rd_bitmap = card->mp_rd_bitmap;\n\n\tmwifiex_dbg(adapter, DATA,\n\t\t    \"data: mp_rd_bitmap=0x%08x\\n\", rd_bitmap);\n\n\tif (card->supports_sdio_new_mode) {\n\t\tif (!(rd_bitmap & reg->data_port_mask))\n\t\t\treturn -1;\n\t} else {\n\t\tif (!(rd_bitmap & (CTRL_PORT_MASK | reg->data_port_mask)))\n\t\t\treturn -1;\n\t}\n\n\tif ((card->has_control_mask) &&\n\t    (card->mp_rd_bitmap & CTRL_PORT_MASK)) {\n\t\tcard->mp_rd_bitmap &= (u32) (~CTRL_PORT_MASK);\n\t\t*port = CTRL_PORT;\n\t\tmwifiex_dbg(adapter, DATA,\n\t\t\t    \"data: port=%d mp_rd_bitmap=0x%08x\\n\",\n\t\t\t    *port, card->mp_rd_bitmap);\n\t\treturn 0;\n\t}\n\n\tif (!(card->mp_rd_bitmap & (1 << card->curr_rd_port)))\n\t\treturn -1;\n\n\t \n\tcard->mp_rd_bitmap &= (u32)(~(1 << card->curr_rd_port));\n\t*port = card->curr_rd_port;\n\n\tif (++card->curr_rd_port == card->max_ports)\n\t\tcard->curr_rd_port = reg->start_rd_port;\n\n\tmwifiex_dbg(adapter, DATA,\n\t\t    \"data: port=%d mp_rd_bitmap=0x%08x -> 0x%08x\\n\",\n\t\t    *port, rd_bitmap, card->mp_rd_bitmap);\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_get_wr_port_data(struct mwifiex_adapter *adapter, u32 *port)\n{\n\tstruct sdio_mmc_card *card = adapter->card;\n\tconst struct mwifiex_sdio_card_reg *reg = card->reg;\n\tu32 wr_bitmap = card->mp_wr_bitmap;\n\n\tmwifiex_dbg(adapter, DATA,\n\t\t    \"data: mp_wr_bitmap=0x%08x\\n\", wr_bitmap);\n\n\tif (!(wr_bitmap & card->mp_data_port_mask)) {\n\t\tadapter->data_sent = true;\n\t\treturn -EBUSY;\n\t}\n\n\tif (card->mp_wr_bitmap & (1 << card->curr_wr_port)) {\n\t\tcard->mp_wr_bitmap &= (u32) (~(1 << card->curr_wr_port));\n\t\t*port = card->curr_wr_port;\n\t\tif (++card->curr_wr_port == card->mp_end_port)\n\t\t\tcard->curr_wr_port = reg->start_wr_port;\n\t} else {\n\t\tadapter->data_sent = true;\n\t\treturn -EBUSY;\n\t}\n\n\tif ((card->has_control_mask) && (*port == CTRL_PORT)) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"invalid data port=%d cur port=%d mp_wr_bitmap=0x%08x -> 0x%08x\\n\",\n\t\t\t    *port, card->curr_wr_port, wr_bitmap,\n\t\t\t    card->mp_wr_bitmap);\n\t\treturn -1;\n\t}\n\n\tmwifiex_dbg(adapter, DATA,\n\t\t    \"data: port=%d mp_wr_bitmap=0x%08x -> 0x%08x\\n\",\n\t\t    *port, wr_bitmap, card->mp_wr_bitmap);\n\n\treturn 0;\n}\n\n \nstatic int\nmwifiex_sdio_poll_card_status(struct mwifiex_adapter *adapter, u8 bits)\n{\n\tstruct sdio_mmc_card *card = adapter->card;\n\tu32 tries;\n\tu8 cs;\n\n\tfor (tries = 0; tries < MAX_POLL_TRIES; tries++) {\n\t\tif (mwifiex_read_reg(adapter, card->reg->poll_reg, &cs))\n\t\t\tbreak;\n\t\telse if ((cs & bits) == bits)\n\t\t\treturn 0;\n\n\t\tusleep_range(10, 20);\n\t}\n\n\tmwifiex_dbg(adapter, ERROR,\n\t\t    \"poll card status failed, tries = %d\\n\", tries);\n\n\treturn -1;\n}\n\n \nstatic void mwifiex_sdio_disable_host_int(struct mwifiex_adapter *adapter)\n{\n\tstruct sdio_mmc_card *card = adapter->card;\n\tstruct sdio_func *func = card->func;\n\n\tsdio_claim_host(func);\n\tmwifiex_write_reg_locked(func, card->reg->host_int_mask_reg, 0);\n\tsdio_release_irq(func);\n\tsdio_release_host(func);\n}\n\n \nstatic void mwifiex_interrupt_status(struct mwifiex_adapter *adapter)\n{\n\tstruct sdio_mmc_card *card = adapter->card;\n\tu8 sdio_ireg;\n\tunsigned long flags;\n\n\tif (mwifiex_read_data_sync(adapter, card->mp_regs,\n\t\t\t\t   card->reg->max_mp_regs,\n\t\t\t\t   REG_PORT | MWIFIEX_SDIO_BYTE_MODE_MASK, 0)) {\n\t\tmwifiex_dbg(adapter, ERROR, \"read mp_regs failed\\n\");\n\t\treturn;\n\t}\n\n\tsdio_ireg = card->mp_regs[card->reg->host_int_status_reg];\n\tif (sdio_ireg) {\n\t\t \n\t\tmwifiex_dbg(adapter, INTR,\n\t\t\t    \"int: sdio_ireg = %#x\\n\", sdio_ireg);\n\t\tspin_lock_irqsave(&adapter->int_lock, flags);\n\t\tadapter->int_status |= sdio_ireg;\n\t\tspin_unlock_irqrestore(&adapter->int_lock, flags);\n\t}\n}\n\n \nstatic void\nmwifiex_sdio_interrupt(struct sdio_func *func)\n{\n\tstruct mwifiex_adapter *adapter;\n\tstruct sdio_mmc_card *card;\n\n\tcard = sdio_get_drvdata(func);\n\tif (!card || !card->adapter) {\n\t\tpr_err(\"int: func=%p card=%p adapter=%p\\n\",\n\t\t       func, card, card ? card->adapter : NULL);\n\t\treturn;\n\t}\n\tadapter = card->adapter;\n\n\tif (!adapter->pps_uapsd_mode && adapter->ps_state == PS_STATE_SLEEP)\n\t\tadapter->ps_state = PS_STATE_AWAKE;\n\n\tmwifiex_interrupt_status(adapter);\n\tmwifiex_main_process(adapter);\n}\n\n \nstatic int mwifiex_sdio_enable_host_int(struct mwifiex_adapter *adapter)\n{\n\tstruct sdio_mmc_card *card = adapter->card;\n\tstruct sdio_func *func = card->func;\n\tint ret;\n\n\tsdio_claim_host(func);\n\n\t \n\tret = sdio_claim_irq(func, mwifiex_sdio_interrupt);\n\tif (ret) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"claim irq failed: ret=%d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\t \n\tret = mwifiex_write_reg_locked(func, card->reg->host_int_mask_reg,\n\t\t\t\t       card->reg->host_int_enable);\n\tif (ret) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"enable host interrupt failed\\n\");\n\t\tsdio_release_irq(func);\n\t}\n\nout:\n\tsdio_release_host(func);\n\treturn ret;\n}\n\n \nstatic int mwifiex_sdio_card_to_host(struct mwifiex_adapter *adapter,\n\t\t\t\t     u32 *type, u8 *buffer,\n\t\t\t\t     u32 npayload, u32 ioport)\n{\n\tint ret;\n\tu32 nb;\n\n\tif (!buffer) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"%s: buffer is NULL\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\tret = mwifiex_read_data_sync(adapter, buffer, npayload, ioport, 1);\n\n\tif (ret) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"%s: read iomem failed: %d\\n\", __func__,\n\t\t\tret);\n\t\treturn -1;\n\t}\n\n\tnb = get_unaligned_le16((buffer));\n\tif (nb > npayload) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"%s: invalid packet, nb=%d npayload=%d\\n\",\n\t\t\t    __func__, nb, npayload);\n\t\treturn -1;\n\t}\n\n\t*type = get_unaligned_le16((buffer + 2));\n\n\treturn ret;\n}\n\n \nstatic int mwifiex_prog_fw_w_helper(struct mwifiex_adapter *adapter,\n\t\t\t\t    struct mwifiex_fw_image *fw)\n{\n\tstruct sdio_mmc_card *card = adapter->card;\n\tconst struct mwifiex_sdio_card_reg *reg = card->reg;\n\tint ret;\n\tu8 *firmware = fw->fw_buf;\n\tu32 firmware_len = fw->fw_len;\n\tu32 offset = 0;\n\tu8 base0, base1;\n\tu8 *fwbuf;\n\tu16 len = 0;\n\tu32 txlen, tx_blocks = 0, tries;\n\tu32 i = 0;\n\n\tif (!firmware_len) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"firmware image not found! Terminating download\\n\");\n\t\treturn -1;\n\t}\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: downloading FW image (%d bytes)\\n\",\n\t\t    firmware_len);\n\n\t \n\tfwbuf = kzalloc(MWIFIEX_UPLD_SIZE, GFP_KERNEL);\n\tif (!fwbuf)\n\t\treturn -ENOMEM;\n\n\tsdio_claim_host(card->func);\n\n\t \n\tdo {\n\t\t \n\t\tret = mwifiex_sdio_poll_card_status(adapter, CARD_IO_READY |\n\t\t\t\t\t\t    DN_LD_CARD_RDY);\n\t\tif (ret) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"FW download with helper:\\t\"\n\t\t\t\t    \"poll status timeout @ %d\\n\", offset);\n\t\t\tgoto done;\n\t\t}\n\n\t\t \n\t\tif (offset >= firmware_len)\n\t\t\tbreak;\n\n\t\tfor (tries = 0; tries < MAX_POLL_TRIES; tries++) {\n\t\t\tret = mwifiex_read_reg(adapter, reg->base_0_reg,\n\t\t\t\t\t       &base0);\n\t\t\tif (ret) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"dev BASE0 register read failed:\\t\"\n\t\t\t\t\t    \"base0=%#04X(%d). Terminating dnld\\n\",\n\t\t\t\t\t    base0, base0);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tret = mwifiex_read_reg(adapter, reg->base_1_reg,\n\t\t\t\t\t       &base1);\n\t\t\tif (ret) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"dev BASE1 register read failed:\\t\"\n\t\t\t\t\t    \"base1=%#04X(%d). Terminating dnld\\n\",\n\t\t\t\t\t    base1, base1);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tlen = (u16) (((base1 & 0xff) << 8) | (base0 & 0xff));\n\n\t\t\tif (len)\n\t\t\t\tbreak;\n\n\t\t\tusleep_range(10, 20);\n\t\t}\n\n\t\tif (!len) {\n\t\t\tbreak;\n\t\t} else if (len > MWIFIEX_UPLD_SIZE) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"FW dnld failed @ %d, invalid length %d\\n\",\n\t\t\t\t    offset, len);\n\t\t\tret = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\ttxlen = len;\n\n\t\tif (len & BIT(0)) {\n\t\t\ti++;\n\t\t\tif (i > MAX_WRITE_IOMEM_RETRY) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"FW dnld failed @ %d, over max retry\\n\",\n\t\t\t\t\t    offset);\n\t\t\t\tret = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"CRC indicated by the helper:\\t\"\n\t\t\t\t    \"len = 0x%04X, txlen = %d\\n\", len, txlen);\n\t\t\tlen &= ~BIT(0);\n\t\t\t \n\t\t\ttxlen = 0;\n\t\t} else {\n\t\t\ti = 0;\n\n\t\t\t \n\t\t\tif (firmware_len - offset < txlen)\n\t\t\t\ttxlen = firmware_len - offset;\n\n\t\t\ttx_blocks = (txlen + MWIFIEX_SDIO_BLOCK_SIZE - 1)\n\t\t\t\t    / MWIFIEX_SDIO_BLOCK_SIZE;\n\n\t\t\t \n\t\t\tmemmove(fwbuf, &firmware[offset], txlen);\n\t\t}\n\n\t\tret = mwifiex_write_data_sync(adapter, fwbuf, tx_blocks *\n\t\t\t\t\t      MWIFIEX_SDIO_BLOCK_SIZE,\n\t\t\t\t\t      adapter->ioport);\n\t\tif (ret) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"FW download, write iomem (%d) failed @ %d\\n\",\n\t\t\t\t    i, offset);\n\t\t\tif (mwifiex_write_reg(adapter, CONFIGURATION_REG, 0x04))\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"write CFG reg failed\\n\");\n\n\t\t\tret = -1;\n\t\t\tgoto done;\n\t\t}\n\n\t\toffset += txlen;\n\t} while (true);\n\n\tmwifiex_dbg(adapter, MSG,\n\t\t    \"info: FW download over, size %d bytes\\n\", offset);\n\n\tret = 0;\ndone:\n\tsdio_release_host(card->func);\n\tkfree(fwbuf);\n\treturn ret;\n}\n\n \nstatic void mwifiex_deaggr_sdio_pkt(struct mwifiex_adapter *adapter,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tu32 total_pkt_len, pkt_len;\n\tstruct sk_buff *skb_deaggr;\n\tu16 blk_size;\n\tu8 blk_num;\n\tu8 *data;\n\n\tdata = skb->data;\n\ttotal_pkt_len = skb->len;\n\n\twhile (total_pkt_len >= (SDIO_HEADER_OFFSET + adapter->intf_hdr_len)) {\n\t\tif (total_pkt_len < adapter->sdio_rx_block_size)\n\t\t\tbreak;\n\t\tblk_num = *(data + BLOCK_NUMBER_OFFSET);\n\t\tblk_size = adapter->sdio_rx_block_size * blk_num;\n\t\tif (blk_size > total_pkt_len) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"%s: error in blk_size,\\t\"\n\t\t\t\t    \"blk_num=%d, blk_size=%d, total_pkt_len=%d\\n\",\n\t\t\t\t    __func__, blk_num, blk_size, total_pkt_len);\n\t\t\tbreak;\n\t\t}\n\t\tpkt_len = get_unaligned_le16((data +\n\t\t\t\t\t     SDIO_HEADER_OFFSET));\n\t\tif ((pkt_len + SDIO_HEADER_OFFSET) > blk_size) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"%s: error in pkt_len,\\t\"\n\t\t\t\t    \"pkt_len=%d, blk_size=%d\\n\",\n\t\t\t\t    __func__, pkt_len, blk_size);\n\t\t\tbreak;\n\t\t}\n\n\t\tskb_deaggr = mwifiex_alloc_dma_align_buf(pkt_len, GFP_KERNEL);\n\t\tif (!skb_deaggr)\n\t\t\tbreak;\n\t\tskb_put(skb_deaggr, pkt_len);\n\t\tmemcpy(skb_deaggr->data, data + SDIO_HEADER_OFFSET, pkt_len);\n\t\tskb_pull(skb_deaggr, adapter->intf_hdr_len);\n\n\t\tmwifiex_handle_rx_packet(adapter, skb_deaggr);\n\t\tdata += blk_size;\n\t\ttotal_pkt_len -= blk_size;\n\t}\n}\n\n \nstatic int mwifiex_decode_rx_packet(struct mwifiex_adapter *adapter,\n\t\t\t\t    struct sk_buff *skb, u32 upld_typ)\n{\n\tu8 *cmd_buf;\n\tu16 pkt_len;\n\tstruct mwifiex_rxinfo *rx_info;\n\n\tpkt_len = get_unaligned_le16(skb->data);\n\n\tif (upld_typ != MWIFIEX_TYPE_AGGR_DATA) {\n\t\tskb_trim(skb, pkt_len);\n\t\tskb_pull(skb, adapter->intf_hdr_len);\n\t}\n\n\tswitch (upld_typ) {\n\tcase MWIFIEX_TYPE_AGGR_DATA:\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: --- Rx: Aggr Data packet ---\\n\");\n\t\trx_info = MWIFIEX_SKB_RXCB(skb);\n\t\trx_info->buf_type = MWIFIEX_TYPE_AGGR_DATA;\n\t\tif (adapter->rx_work_enabled) {\n\t\t\tskb_queue_tail(&adapter->rx_data_q, skb);\n\t\t\tatomic_inc(&adapter->rx_pending);\n\t\t\tadapter->data_received = true;\n\t\t} else {\n\t\t\tmwifiex_deaggr_sdio_pkt(adapter, skb);\n\t\t\tdev_kfree_skb_any(skb);\n\t\t}\n\t\tbreak;\n\n\tcase MWIFIEX_TYPE_DATA:\n\t\tmwifiex_dbg(adapter, DATA,\n\t\t\t    \"info: --- Rx: Data packet ---\\n\");\n\t\tif (adapter->rx_work_enabled) {\n\t\t\tskb_queue_tail(&adapter->rx_data_q, skb);\n\t\t\tadapter->data_received = true;\n\t\t\tatomic_inc(&adapter->rx_pending);\n\t\t} else {\n\t\t\tmwifiex_handle_rx_packet(adapter, skb);\n\t\t}\n\t\tbreak;\n\n\tcase MWIFIEX_TYPE_CMD:\n\t\tmwifiex_dbg(adapter, CMD,\n\t\t\t    \"info: --- Rx: Cmd Response ---\\n\");\n\t\t \n\t\tif (!adapter->curr_cmd) {\n\t\t\tcmd_buf = adapter->upld_buf;\n\n\t\t\tif (adapter->ps_state == PS_STATE_SLEEP_CFM)\n\t\t\t\tmwifiex_process_sleep_confirm_resp(adapter,\n\t\t\t\t\t\t\t\t   skb->data,\n\t\t\t\t\t\t\t\t   skb->len);\n\n\t\t\tmemcpy(cmd_buf, skb->data,\n\t\t\t       min_t(u32, MWIFIEX_SIZE_OF_CMD_BUFFER,\n\t\t\t\t     skb->len));\n\n\t\t\tdev_kfree_skb_any(skb);\n\t\t} else {\n\t\t\tadapter->cmd_resp_received = true;\n\t\t\tadapter->curr_cmd->resp_skb = skb;\n\t\t}\n\t\tbreak;\n\n\tcase MWIFIEX_TYPE_EVENT:\n\t\tmwifiex_dbg(adapter, EVENT,\n\t\t\t    \"info: --- Rx: Event ---\\n\");\n\t\tadapter->event_cause = get_unaligned_le32(skb->data);\n\n\t\tif ((skb->len > 0) && (skb->len  < MAX_EVENT_SIZE))\n\t\t\tmemcpy(adapter->event_body,\n\t\t\t       skb->data + MWIFIEX_EVENT_HEADER_LEN,\n\t\t\t       skb->len);\n\n\t\t \n\t\tadapter->event_received = true;\n\t\tadapter->event_skb = skb;\n\n\t\tbreak;\n\n\tdefault:\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"unknown upload type %#x\\n\", upld_typ);\n\t\tdev_kfree_skb_any(skb);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_sdio_card_to_host_mp_aggr(struct mwifiex_adapter *adapter,\n\t\t\t\t\t     u16 rx_len, u8 port)\n{\n\tstruct sdio_mmc_card *card = adapter->card;\n\ts32 f_do_rx_aggr = 0;\n\ts32 f_do_rx_cur = 0;\n\ts32 f_aggr_cur = 0;\n\ts32 f_post_aggr_cur = 0;\n\tstruct sk_buff *skb_deaggr;\n\tstruct sk_buff *skb = NULL;\n\tu32 pkt_len, pkt_type, mport, pind;\n\tu8 *curr_ptr;\n\n\tif ((card->has_control_mask) && (port == CTRL_PORT)) {\n\t\t \n\t\tmwifiex_dbg(adapter, CMD,\n\t\t\t    \"info: %s: no aggregation for cmd\\t\"\n\t\t\t    \"response\\n\", __func__);\n\n\t\tf_do_rx_cur = 1;\n\t\tgoto rx_curr_single;\n\t}\n\n\tif (!card->mpa_rx.enabled) {\n\t\tmwifiex_dbg(adapter, WARN,\n\t\t\t    \"info: %s: rx aggregation disabled\\n\",\n\t\t\t    __func__);\n\n\t\tf_do_rx_cur = 1;\n\t\tgoto rx_curr_single;\n\t}\n\n\tif ((!card->has_control_mask && (card->mp_rd_bitmap &\n\t\t\t\t\t card->reg->data_port_mask)) ||\n\t    (card->has_control_mask && (card->mp_rd_bitmap &\n\t\t\t\t\t(~((u32) CTRL_PORT_MASK))))) {\n\t\t \n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: %s: not last packet\\n\", __func__);\n\n\t\tif (MP_RX_AGGR_IN_PROGRESS(card)) {\n\t\t\tif (MP_RX_AGGR_BUF_HAS_ROOM(card, rx_len)) {\n\t\t\t\tf_aggr_cur = 1;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tf_do_rx_aggr = 1;\n\t\t\t\tf_post_aggr_cur = 1;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tf_aggr_cur = 1;\n\t\t}\n\n\t} else {\n\t\t \n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: %s: last packet\\n\", __func__);\n\n\t\tif (MP_RX_AGGR_IN_PROGRESS(card)) {\n\t\t\tf_do_rx_aggr = 1;\n\t\t\tif (MP_RX_AGGR_BUF_HAS_ROOM(card, rx_len))\n\t\t\t\tf_aggr_cur = 1;\n\t\t\telse\n\t\t\t\t \n\t\t\t\tf_do_rx_cur = 1;\n\t\t} else {\n\t\t\tf_do_rx_cur = 1;\n\t\t}\n\t}\n\n\tif (f_aggr_cur) {\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: current packet aggregation\\n\");\n\t\t \n\t\tmp_rx_aggr_setup(card, rx_len, port);\n\n\t\tif (MP_RX_AGGR_PKT_LIMIT_REACHED(card) ||\n\t\t    mp_rx_aggr_port_limit_reached(card)) {\n\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t    \"info: %s: aggregated packet\\t\"\n\t\t\t\t    \"limit reached\\n\", __func__);\n\t\t\t \n\t\t\tf_do_rx_aggr = 1;\n\t\t}\n\t}\n\n\tif (f_do_rx_aggr) {\n\t\t \n\t\tmwifiex_dbg(adapter, DATA,\n\t\t\t    \"info: do_rx_aggr: num of packets: %d\\n\",\n\t\t\t    card->mpa_rx.pkt_cnt);\n\n\t\tif (card->supports_sdio_new_mode) {\n\t\t\tint i;\n\t\t\tu32 port_count;\n\n\t\t\tfor (i = 0, port_count = 0; i < card->max_ports; i++)\n\t\t\t\tif (card->mpa_rx.ports & BIT(i))\n\t\t\t\t\tport_count++;\n\n\t\t\t \n\t\t\tport_count--;\n\t\t\tmport = (adapter->ioport | SDIO_MPA_ADDR_BASE |\n\t\t\t\t (port_count << 8)) + card->mpa_rx.start_port;\n\t\t} else {\n\t\t\tmport = (adapter->ioport | SDIO_MPA_ADDR_BASE |\n\t\t\t\t (card->mpa_rx.ports << 4)) +\n\t\t\t\t card->mpa_rx.start_port;\n\t\t}\n\n\t\tif (card->mpa_rx.pkt_cnt == 1)\n\t\t\tmport = adapter->ioport + card->mpa_rx.start_port;\n\n\t\tif (mwifiex_read_data_sync(adapter, card->mpa_rx.buf,\n\t\t\t\t\t   card->mpa_rx.buf_len, mport, 1))\n\t\t\tgoto error;\n\n\t\tcurr_ptr = card->mpa_rx.buf;\n\n\t\tfor (pind = 0; pind < card->mpa_rx.pkt_cnt; pind++) {\n\t\t\tu32 *len_arr = card->mpa_rx.len_arr;\n\n\t\t\t \n\t\t\tpkt_len = get_unaligned_le16(&curr_ptr[0]);\n\t\t\tpkt_type = get_unaligned_le16(&curr_ptr[2]);\n\n\t\t\t \n\t\t\tskb_deaggr = mwifiex_alloc_dma_align_buf(len_arr[pind],\n\t\t\t\t\t\t\t\t GFP_KERNEL);\n\t\t\tif (!skb_deaggr) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR, \"skb allocation failure\\t\"\n\t\t\t\t\t    \"drop pkt len=%d type=%d\\n\",\n\t\t\t\t\t    pkt_len, pkt_type);\n\t\t\t\tcurr_ptr += len_arr[pind];\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tskb_put(skb_deaggr, len_arr[pind]);\n\n\t\t\tif ((pkt_type == MWIFIEX_TYPE_DATA ||\n\t\t\t     (pkt_type == MWIFIEX_TYPE_AGGR_DATA &&\n\t\t\t      adapter->sdio_rx_aggr_enable)) &&\n\t\t\t    (pkt_len <= len_arr[pind])) {\n\n\t\t\t\tmemcpy(skb_deaggr->data, curr_ptr, pkt_len);\n\n\t\t\t\tskb_trim(skb_deaggr, pkt_len);\n\n\t\t\t\t \n\t\t\t\tmwifiex_decode_rx_packet(adapter, skb_deaggr,\n\t\t\t\t\t\t\t pkt_type);\n\t\t\t} else {\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"drop wrong aggr pkt:\\t\"\n\t\t\t\t\t    \"sdio_single_port_rx_aggr=%d\\t\"\n\t\t\t\t\t    \"type=%d len=%d max_len=%d\\n\",\n\t\t\t\t\t    adapter->sdio_rx_aggr_enable,\n\t\t\t\t\t    pkt_type, pkt_len, len_arr[pind]);\n\t\t\t\tdev_kfree_skb_any(skb_deaggr);\n\t\t\t}\n\t\t\tcurr_ptr += len_arr[pind];\n\t\t}\n\t\tMP_RX_AGGR_BUF_RESET(card);\n\t}\n\nrx_curr_single:\n\tif (f_do_rx_cur) {\n\t\tmwifiex_dbg(adapter, INFO, \"info: RX: port: %d, rx_len: %d\\n\",\n\t\t\t    port, rx_len);\n\n\t\tskb = mwifiex_alloc_dma_align_buf(rx_len, GFP_KERNEL);\n\t\tif (!skb) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"single skb allocated fail,\\t\"\n\t\t\t\t    \"drop pkt port=%d len=%d\\n\", port, rx_len);\n\t\t\tif (mwifiex_sdio_card_to_host(adapter, &pkt_type,\n\t\t\t\t\t\t      card->mpa_rx.buf, rx_len,\n\t\t\t\t\t\t      adapter->ioport + port))\n\t\t\t\tgoto error;\n\t\t\treturn 0;\n\t\t}\n\n\t\tskb_put(skb, rx_len);\n\n\t\tif (mwifiex_sdio_card_to_host(adapter, &pkt_type,\n\t\t\t\t\t      skb->data, skb->len,\n\t\t\t\t\t      adapter->ioport + port))\n\t\t\tgoto error;\n\t\tif (!adapter->sdio_rx_aggr_enable &&\n\t\t    pkt_type == MWIFIEX_TYPE_AGGR_DATA) {\n\t\t\tmwifiex_dbg(adapter, ERROR, \"drop wrong pkt type %d\\t\"\n\t\t\t\t    \"current SDIO RX Aggr not enabled\\n\",\n\t\t\t\t    pkt_type);\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\treturn 0;\n\t\t}\n\n\t\tmwifiex_decode_rx_packet(adapter, skb, pkt_type);\n\t}\n\tif (f_post_aggr_cur) {\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: current packet aggregation\\n\");\n\t\t \n\t\tmp_rx_aggr_setup(card, rx_len, port);\n\t}\n\n\treturn 0;\nerror:\n\tif (MP_RX_AGGR_IN_PROGRESS(card))\n\t\tMP_RX_AGGR_BUF_RESET(card);\n\n\tif (f_do_rx_cur && skb)\n\t\t \n\t\tdev_kfree_skb_any(skb);\n\n\treturn -1;\n}\n\n \nstatic int mwifiex_process_int_status(struct mwifiex_adapter *adapter)\n{\n\tstruct sdio_mmc_card *card = adapter->card;\n\tconst struct mwifiex_sdio_card_reg *reg = card->reg;\n\tint ret = 0;\n\tu8 sdio_ireg;\n\tstruct sk_buff *skb;\n\tu8 port = CTRL_PORT;\n\tu32 len_reg_l, len_reg_u;\n\tu32 rx_blocks;\n\tu16 rx_len;\n\tunsigned long flags;\n\tu32 bitmap;\n\tu8 cr;\n\n\tspin_lock_irqsave(&adapter->int_lock, flags);\n\tsdio_ireg = adapter->int_status;\n\tadapter->int_status = 0;\n\tspin_unlock_irqrestore(&adapter->int_lock, flags);\n\n\tif (!sdio_ireg)\n\t\treturn ret;\n\n\t \n\tif (sdio_ireg & DN_LD_CMD_PORT_HOST_INT_STATUS && adapter->cmd_sent)\n\t\tadapter->cmd_sent = false;\n\n\t \n\tif (sdio_ireg & UP_LD_CMD_PORT_HOST_INT_STATUS) {\n\t\tu32 pkt_type;\n\n\t\t \n\t\trx_len = card->mp_regs[reg->cmd_rd_len_1] << 8;\n\t\trx_len |= (u16)card->mp_regs[reg->cmd_rd_len_0];\n\t\trx_blocks = DIV_ROUND_UP(rx_len, MWIFIEX_SDIO_BLOCK_SIZE);\n\t\tif (rx_len <= adapter->intf_hdr_len ||\n\t\t    (rx_blocks * MWIFIEX_SDIO_BLOCK_SIZE) >\n\t\t     MWIFIEX_RX_DATA_BUF_SIZE)\n\t\t\treturn -1;\n\t\trx_len = (u16) (rx_blocks * MWIFIEX_SDIO_BLOCK_SIZE);\n\t\tmwifiex_dbg(adapter, INFO, \"info: rx_len = %d\\n\", rx_len);\n\n\t\tskb = mwifiex_alloc_dma_align_buf(rx_len, GFP_KERNEL);\n\t\tif (!skb)\n\t\t\treturn -1;\n\n\t\tskb_put(skb, rx_len);\n\n\t\tif (mwifiex_sdio_card_to_host(adapter, &pkt_type, skb->data,\n\t\t\t\t\t      skb->len, adapter->ioport |\n\t\t\t\t\t\t\tCMD_PORT_SLCT)) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"%s: failed to card_to_host\", __func__);\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\tgoto term_cmd;\n\t\t}\n\n\t\tif ((pkt_type != MWIFIEX_TYPE_CMD) &&\n\t\t    (pkt_type != MWIFIEX_TYPE_EVENT))\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"%s:Received wrong packet on cmd port\",\n\t\t\t\t    __func__);\n\n\t\tmwifiex_decode_rx_packet(adapter, skb, pkt_type);\n\t}\n\n\tif (sdio_ireg & DN_LD_HOST_INT_STATUS) {\n\t\tbitmap = (u32) card->mp_regs[reg->wr_bitmap_l];\n\t\tbitmap |= ((u32) card->mp_regs[reg->wr_bitmap_u]) << 8;\n\t\tif (card->supports_sdio_new_mode) {\n\t\t\tbitmap |=\n\t\t\t\t((u32) card->mp_regs[reg->wr_bitmap_1l]) << 16;\n\t\t\tbitmap |=\n\t\t\t\t((u32) card->mp_regs[reg->wr_bitmap_1u]) << 24;\n\t\t}\n\t\tcard->mp_wr_bitmap = bitmap;\n\n\t\tmwifiex_dbg(adapter, INTR,\n\t\t\t    \"int: DNLD: wr_bitmap=0x%x\\n\",\n\t\t\t    card->mp_wr_bitmap);\n\t\tif (adapter->data_sent &&\n\t\t    (card->mp_wr_bitmap & card->mp_data_port_mask)) {\n\t\t\tmwifiex_dbg(adapter, INTR,\n\t\t\t\t    \"info:  <--- Tx DONE Interrupt --->\\n\");\n\t\t\tadapter->data_sent = false;\n\t\t}\n\t}\n\n\t \n\tif (card->has_control_mask && adapter->cmd_sent) {\n\t\t \n\t\tcard->mp_wr_bitmap |=\n\t\t\t(u32) card->mp_regs[reg->wr_bitmap_l] & CTRL_PORT_MASK;\n\t\tif (card->mp_wr_bitmap & CTRL_PORT_MASK)\n\t\t\tadapter->cmd_sent = false;\n\t}\n\n\tmwifiex_dbg(adapter, INTR, \"info: cmd_sent=%d data_sent=%d\\n\",\n\t\t    adapter->cmd_sent, adapter->data_sent);\n\tif (sdio_ireg & UP_LD_HOST_INT_STATUS) {\n\t\tbitmap = (u32) card->mp_regs[reg->rd_bitmap_l];\n\t\tbitmap |= ((u32) card->mp_regs[reg->rd_bitmap_u]) << 8;\n\t\tif (card->supports_sdio_new_mode) {\n\t\t\tbitmap |=\n\t\t\t\t((u32) card->mp_regs[reg->rd_bitmap_1l]) << 16;\n\t\t\tbitmap |=\n\t\t\t\t((u32) card->mp_regs[reg->rd_bitmap_1u]) << 24;\n\t\t}\n\t\tcard->mp_rd_bitmap = bitmap;\n\t\tmwifiex_dbg(adapter, INTR,\n\t\t\t    \"int: UPLD: rd_bitmap=0x%x\\n\",\n\t\t\t    card->mp_rd_bitmap);\n\n\t\twhile (true) {\n\t\t\tret = mwifiex_get_rd_port(adapter, &port);\n\t\t\tif (ret) {\n\t\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t\t    \"info: no more rd_port available\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlen_reg_l = reg->rd_len_p0_l + (port << 1);\n\t\t\tlen_reg_u = reg->rd_len_p0_u + (port << 1);\n\t\t\trx_len = ((u16) card->mp_regs[len_reg_u]) << 8;\n\t\t\trx_len |= (u16) card->mp_regs[len_reg_l];\n\t\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t\t    \"info: RX: port=%d rx_len=%u\\n\",\n\t\t\t\t    port, rx_len);\n\t\t\trx_blocks =\n\t\t\t\t(rx_len + MWIFIEX_SDIO_BLOCK_SIZE -\n\t\t\t\t 1) / MWIFIEX_SDIO_BLOCK_SIZE;\n\t\t\tif (rx_len <= adapter->intf_hdr_len ||\n\t\t\t    (card->mpa_rx.enabled &&\n\t\t\t     ((rx_blocks * MWIFIEX_SDIO_BLOCK_SIZE) >\n\t\t\t      card->mpa_rx.buf_size))) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"invalid rx_len=%d\\n\",\n\t\t\t\t\t    rx_len);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\trx_len = (u16) (rx_blocks * MWIFIEX_SDIO_BLOCK_SIZE);\n\t\t\tmwifiex_dbg(adapter, INFO, \"info: rx_len = %d\\n\",\n\t\t\t\t    rx_len);\n\n\t\t\tif (mwifiex_sdio_card_to_host_mp_aggr(adapter, rx_len,\n\t\t\t\t\t\t\t      port)) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"card_to_host_mpa failed: int status=%#x\\n\",\n\t\t\t\t\t    sdio_ireg);\n\t\t\t\tgoto term_cmd;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n\nterm_cmd:\n\t \n\tif (mwifiex_read_reg(adapter, CONFIGURATION_REG, &cr))\n\t\tmwifiex_dbg(adapter, ERROR, \"read CFG reg failed\\n\");\n\telse\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: CFG reg val = %d\\n\", cr);\n\n\tif (mwifiex_write_reg(adapter, CONFIGURATION_REG, (cr | 0x04)))\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"write CFG reg failed\\n\");\n\telse\n\t\tmwifiex_dbg(adapter, INFO, \"info: write success\\n\");\n\n\tif (mwifiex_read_reg(adapter, CONFIGURATION_REG, &cr))\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"read CFG reg failed\\n\");\n\telse\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: CFG reg val =%x\\n\", cr);\n\n\treturn -1;\n}\n\n \nstatic int mwifiex_host_to_card_mp_aggr(struct mwifiex_adapter *adapter,\n\t\t\t\t\tu8 *payload, u32 pkt_len, u32 port,\n\t\t\t\t\tu32 next_pkt_len)\n{\n\tstruct sdio_mmc_card *card = adapter->card;\n\tint ret = 0;\n\ts32 f_send_aggr_buf = 0;\n\ts32 f_send_cur_buf = 0;\n\ts32 f_precopy_cur_buf = 0;\n\ts32 f_postcopy_cur_buf = 0;\n\tu32 mport;\n\tint index;\n\n\tif (!card->mpa_tx.enabled ||\n\t    (card->has_control_mask && (port == CTRL_PORT)) ||\n\t    (card->supports_sdio_new_mode && (port == CMD_PORT_SLCT))) {\n\t\tmwifiex_dbg(adapter, WARN,\n\t\t\t    \"info: %s: tx aggregation disabled\\n\",\n\t\t\t    __func__);\n\n\t\tf_send_cur_buf = 1;\n\t\tgoto tx_curr_single;\n\t}\n\n\tif (next_pkt_len) {\n\t\t \n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: %s: more packets in queue.\\n\",\n\t\t\t    __func__);\n\n\t\tif (MP_TX_AGGR_IN_PROGRESS(card)) {\n\t\t\tif (MP_TX_AGGR_BUF_HAS_ROOM(card, pkt_len)) {\n\t\t\t\tf_precopy_cur_buf = 1;\n\n\t\t\t\tif (!(card->mp_wr_bitmap &\n\t\t\t\t      (1 << card->curr_wr_port)) ||\n\t\t\t\t    !MP_TX_AGGR_BUF_HAS_ROOM(\n\t\t\t\t\t    card, pkt_len + next_pkt_len))\n\t\t\t\t\tf_send_aggr_buf = 1;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tf_send_aggr_buf = 1;\n\n\t\t\t\tif (!(card->mp_wr_bitmap &\n\t\t\t\t      (1 << card->curr_wr_port)))\n\t\t\t\t\tf_send_cur_buf = 1;\n\t\t\t\telse\n\t\t\t\t\tf_postcopy_cur_buf = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (MP_TX_AGGR_BUF_HAS_ROOM(card, pkt_len) &&\n\t\t\t    (card->mp_wr_bitmap & (1 << card->curr_wr_port)))\n\t\t\t\tf_precopy_cur_buf = 1;\n\t\t\telse\n\t\t\t\tf_send_cur_buf = 1;\n\t\t}\n\t} else {\n\t\t \n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: %s: Last packet in Tx Queue.\\n\",\n\t\t\t    __func__);\n\n\t\tif (MP_TX_AGGR_IN_PROGRESS(card)) {\n\t\t\t \n\t\t\tf_send_aggr_buf = 1;\n\n\t\t\tif (MP_TX_AGGR_BUF_HAS_ROOM(card, pkt_len))\n\t\t\t\tf_precopy_cur_buf = 1;\n\t\t\telse\n\t\t\t\t \n\t\t\t\tf_send_cur_buf = 1;\n\t\t} else {\n\t\t\tf_send_cur_buf = 1;\n\t\t}\n\t}\n\n\tif (f_precopy_cur_buf) {\n\t\tmwifiex_dbg(adapter, DATA,\n\t\t\t    \"data: %s: precopy current buffer\\n\",\n\t\t\t    __func__);\n\t\tMP_TX_AGGR_BUF_PUT(card, payload, pkt_len, port);\n\n\t\tif (MP_TX_AGGR_PKT_LIMIT_REACHED(card) ||\n\t\t    mp_tx_aggr_port_limit_reached(card))\n\t\t\t \n\t\t\tf_send_aggr_buf = 1;\n\t}\n\n\tif (f_send_aggr_buf) {\n\t\tmwifiex_dbg(adapter, DATA,\n\t\t\t    \"data: %s: send aggr buffer: %d %d\\n\",\n\t\t\t    __func__, card->mpa_tx.start_port,\n\t\t\t    card->mpa_tx.ports);\n\t\tif (card->supports_sdio_new_mode) {\n\t\t\tu32 port_count;\n\t\t\tint i;\n\n\t\t\tfor (i = 0, port_count = 0; i < card->max_ports; i++)\n\t\t\t\tif (card->mpa_tx.ports & BIT(i))\n\t\t\t\t\tport_count++;\n\n\t\t\t \n\t\t\tport_count--;\n\t\t\tmport = (adapter->ioport | SDIO_MPA_ADDR_BASE |\n\t\t\t\t (port_count << 8)) + card->mpa_tx.start_port;\n\t\t} else {\n\t\t\tmport = (adapter->ioport | SDIO_MPA_ADDR_BASE |\n\t\t\t\t (card->mpa_tx.ports << 4)) +\n\t\t\t\t card->mpa_tx.start_port;\n\t\t}\n\n\t\tif (card->mpa_tx.pkt_cnt == 1)\n\t\t\tmport = adapter->ioport + card->mpa_tx.start_port;\n\n\t\tret = mwifiex_write_data_to_card(adapter, card->mpa_tx.buf,\n\t\t\t\t\t\t card->mpa_tx.buf_len, mport);\n\n\t\t \n\t\tindex = adapter->dbg.last_sdio_mp_index;\n\t\tindex = (index + 1) % MWIFIEX_DBG_SDIO_MP_NUM;\n\t\tadapter->dbg.last_sdio_mp_index = index;\n\t\tadapter->dbg.last_mp_wr_ports[index] = mport;\n\t\tadapter->dbg.last_mp_wr_bitmap[index] = card->mp_wr_bitmap;\n\t\tadapter->dbg.last_mp_wr_len[index] = card->mpa_tx.buf_len;\n\t\tadapter->dbg.last_mp_curr_wr_port[index] = card->curr_wr_port;\n\n\t\tMP_TX_AGGR_BUF_RESET(card);\n\t}\n\ntx_curr_single:\n\tif (f_send_cur_buf) {\n\t\tmwifiex_dbg(adapter, DATA,\n\t\t\t    \"data: %s: send current buffer %d\\n\",\n\t\t\t    __func__, port);\n\t\tret = mwifiex_write_data_to_card(adapter, payload, pkt_len,\n\t\t\t\t\t\t adapter->ioport + port);\n\t}\n\n\tif (f_postcopy_cur_buf) {\n\t\tmwifiex_dbg(adapter, DATA,\n\t\t\t    \"data: %s: postcopy current buffer\\n\",\n\t\t\t    __func__);\n\t\tMP_TX_AGGR_BUF_PUT(card, payload, pkt_len, port);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int mwifiex_sdio_host_to_card(struct mwifiex_adapter *adapter,\n\t\t\t\t     u8 type, struct sk_buff *skb,\n\t\t\t\t     struct mwifiex_tx_param *tx_param)\n{\n\tstruct sdio_mmc_card *card = adapter->card;\n\tint ret;\n\tu32 buf_block_len;\n\tu32 blk_size;\n\tu32 port = CTRL_PORT;\n\tu8 *payload = (u8 *)skb->data;\n\tu32 pkt_len = skb->len;\n\n\t \n\tblk_size = MWIFIEX_SDIO_BLOCK_SIZE;\n\tbuf_block_len = (pkt_len + blk_size - 1) / blk_size;\n\tput_unaligned_le16((u16)pkt_len, payload + 0);\n\tput_unaligned_le16((u32)type, payload + 2);\n\n\n\t \n\tif (type == MWIFIEX_TYPE_DATA) {\n\t\tret = mwifiex_get_wr_port_data(adapter, &port);\n\t\tif (ret) {\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"%s: no wr_port available\\n\",\n\t\t\t\t    __func__);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tadapter->cmd_sent = true;\n\t\t \n\n\t\tif (pkt_len <= adapter->intf_hdr_len ||\n\t\t    pkt_len > MWIFIEX_UPLD_SIZE)\n\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t    \"%s: payload=%p, nb=%d\\n\",\n\t\t\t\t    __func__, payload, pkt_len);\n\n\t\tif (card->supports_sdio_new_mode)\n\t\t\tport = CMD_PORT_SLCT;\n\t}\n\n\t \n\tpkt_len = buf_block_len * blk_size;\n\n\tif (tx_param)\n\t\tret = mwifiex_host_to_card_mp_aggr(adapter, payload, pkt_len,\n\t\t\t\t\t\t   port, tx_param->next_pkt_len\n\t\t\t\t\t\t   );\n\telse\n\t\tret = mwifiex_host_to_card_mp_aggr(adapter, payload, pkt_len,\n\t\t\t\t\t\t   port, 0);\n\n\tif (ret) {\n\t\tif (type == MWIFIEX_TYPE_CMD)\n\t\t\tadapter->cmd_sent = false;\n\t\tif (type == MWIFIEX_TYPE_DATA) {\n\t\t\tadapter->data_sent = false;\n\t\t\t \n\t\t\tcard->curr_wr_port = port;\n\t\t\tcard->mp_wr_bitmap |= (u32)(1 << card->curr_wr_port);\n\t\t}\n\t} else {\n\t\tif (type == MWIFIEX_TYPE_DATA) {\n\t\t\tif (!(card->mp_wr_bitmap & (1 << card->curr_wr_port)))\n\t\t\t\tadapter->data_sent = true;\n\t\t\telse\n\t\t\t\tadapter->data_sent = false;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \nstatic int mwifiex_alloc_sdio_mpa_buffers(struct mwifiex_adapter *adapter,\n\t\t\t\t   u32 mpa_tx_buf_size, u32 mpa_rx_buf_size)\n{\n\tstruct sdio_mmc_card *card = adapter->card;\n\tu32 rx_buf_size;\n\tint ret = 0;\n\n\tcard->mpa_tx.buf = kzalloc(mpa_tx_buf_size, GFP_KERNEL);\n\tif (!card->mpa_tx.buf) {\n\t\tret = -1;\n\t\tgoto error;\n\t}\n\n\tcard->mpa_tx.buf_size = mpa_tx_buf_size;\n\n\trx_buf_size = max_t(u32, mpa_rx_buf_size,\n\t\t\t    (u32)SDIO_MAX_AGGR_BUF_SIZE);\n\tcard->mpa_rx.buf = kzalloc(rx_buf_size, GFP_KERNEL);\n\tif (!card->mpa_rx.buf) {\n\t\tret = -1;\n\t\tgoto error;\n\t}\n\n\tcard->mpa_rx.buf_size = rx_buf_size;\n\nerror:\n\tif (ret) {\n\t\tkfree(card->mpa_tx.buf);\n\t\tkfree(card->mpa_rx.buf);\n\t\tcard->mpa_tx.buf_size = 0;\n\t\tcard->mpa_rx.buf_size = 0;\n\t\tcard->mpa_tx.buf = NULL;\n\t\tcard->mpa_rx.buf = NULL;\n\t}\n\n\treturn ret;\n}\n\n \nstatic void\nmwifiex_unregister_dev(struct mwifiex_adapter *adapter)\n{\n\tstruct sdio_mmc_card *card = adapter->card;\n\n\tif (adapter->card) {\n\t\tcard->adapter = NULL;\n\t\tsdio_claim_host(card->func);\n\t\tsdio_disable_func(card->func);\n\t\tsdio_release_host(card->func);\n\t}\n}\n\n \nstatic int mwifiex_register_dev(struct mwifiex_adapter *adapter)\n{\n\tint ret;\n\tstruct sdio_mmc_card *card = adapter->card;\n\tstruct sdio_func *func = card->func;\n\tconst char *firmware = card->firmware;\n\n\t \n\tcard->adapter = adapter;\n\tadapter->tx_buf_size = card->tx_buf_size;\n\n\tsdio_claim_host(func);\n\n\t \n\tret = sdio_set_block_size(card->func, MWIFIEX_SDIO_BLOCK_SIZE);\n\tsdio_release_host(func);\n\tif (ret) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"cannot set SDIO block size\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (card->firmware_sdiouart) {\n\t\tu8 val;\n\n\t\tmwifiex_read_reg(adapter, card->reg->host_strap_reg, &val);\n\t\tif ((val & card->reg->host_strap_mask) == card->reg->host_strap_value)\n\t\t\tfirmware = card->firmware_sdiouart;\n\t}\n\tstrcpy(adapter->fw_name, firmware);\n\n\tif (card->fw_dump_enh) {\n\t\tadapter->mem_type_mapping_tbl = generic_mem_type_map;\n\t\tadapter->num_mem_types = 1;\n\t} else {\n\t\tadapter->mem_type_mapping_tbl = mem_type_mapping_tbl;\n\t\tadapter->num_mem_types = ARRAY_SIZE(mem_type_mapping_tbl);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_init_sdio(struct mwifiex_adapter *adapter)\n{\n\tstruct sdio_mmc_card *card = adapter->card;\n\tconst struct mwifiex_sdio_card_reg *reg = card->reg;\n\tint ret;\n\tu8 sdio_ireg;\n\n\tsdio_set_drvdata(card->func, card);\n\n\t \n\tmwifiex_read_reg(adapter, card->reg->host_int_status_reg, &sdio_ireg);\n\n\t \n\tif (mwifiex_init_sdio_ioport(adapter))\n\t\treturn -EIO;\n\n\t \n\tcard->mp_rd_bitmap = 0;\n\tcard->mp_wr_bitmap = 0;\n\tcard->curr_rd_port = reg->start_rd_port;\n\tcard->curr_wr_port = reg->start_wr_port;\n\n\tcard->mp_data_port_mask = reg->data_port_mask;\n\n\tcard->mpa_tx.buf_len = 0;\n\tcard->mpa_tx.pkt_cnt = 0;\n\tcard->mpa_tx.start_port = 0;\n\n\tcard->mpa_tx.enabled = 1;\n\tcard->mpa_tx.pkt_aggr_limit = card->mp_agg_pkt_limit;\n\n\tcard->mpa_rx.buf_len = 0;\n\tcard->mpa_rx.pkt_cnt = 0;\n\tcard->mpa_rx.start_port = 0;\n\n\tcard->mpa_rx.enabled = 1;\n\tcard->mpa_rx.pkt_aggr_limit = card->mp_agg_pkt_limit;\n\n\t \n\tcard->mp_regs = kzalloc(reg->max_mp_regs, GFP_KERNEL);\n\tif (!card->mp_regs)\n\t\treturn -ENOMEM;\n\n\t \n\tcard->mpa_rx.skb_arr = kcalloc(card->mp_agg_pkt_limit, sizeof(void *),\n\t\t\t\t       GFP_KERNEL);\n\tif (!card->mpa_rx.skb_arr) {\n\t\tkfree(card->mp_regs);\n\t\treturn -ENOMEM;\n\t}\n\n\tcard->mpa_rx.len_arr = kcalloc(card->mp_agg_pkt_limit,\n\t\t\t\t       sizeof(*card->mpa_rx.len_arr),\n\t\t\t\t       GFP_KERNEL);\n\tif (!card->mpa_rx.len_arr) {\n\t\tkfree(card->mp_regs);\n\t\tkfree(card->mpa_rx.skb_arr);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = mwifiex_alloc_sdio_mpa_buffers(adapter,\n\t\t\t\t\t     card->mp_tx_agg_buf_size,\n\t\t\t\t\t     card->mp_rx_agg_buf_size);\n\n\t \n\tif (ret && (card->mp_tx_agg_buf_size == MWIFIEX_MP_AGGR_BUF_SIZE_MAX ||\n\t\t    card->mp_rx_agg_buf_size == MWIFIEX_MP_AGGR_BUF_SIZE_MAX)) {\n\t\t \n\t\tadapter->host_disable_sdio_rx_aggr = true;\n\n\t\tret = mwifiex_alloc_sdio_mpa_buffers\n\t\t\t(adapter, MWIFIEX_MP_AGGR_BUF_SIZE_32K,\n\t\t\t MWIFIEX_MP_AGGR_BUF_SIZE_32K);\n\t\tif (ret) {\n\t\t\t \n\t\t\tcard->mpa_tx.enabled = 0;\n\t\t\tcard->mpa_rx.enabled = 0;\n\t\t}\n\t}\n\n\tadapter->auto_tdls = card->can_auto_tdls;\n\tadapter->ext_scan = card->can_ext_scan;\n\treturn 0;\n}\n\n \nstatic void mwifiex_cleanup_mpa_buf(struct mwifiex_adapter *adapter)\n{\n\tstruct sdio_mmc_card *card = adapter->card;\n\n\tMP_TX_AGGR_BUF_RESET(card);\n\tMP_RX_AGGR_BUF_RESET(card);\n}\n\n \nstatic void mwifiex_cleanup_sdio(struct mwifiex_adapter *adapter)\n{\n\tstruct sdio_mmc_card *card = adapter->card;\n\n\tcancel_work_sync(&card->work);\n\n\tkfree(card->mp_regs);\n\tkfree(card->mpa_rx.skb_arr);\n\tkfree(card->mpa_rx.len_arr);\n\tkfree(card->mpa_tx.buf);\n\tkfree(card->mpa_rx.buf);\n}\n\n \nstatic void\nmwifiex_update_mp_end_port(struct mwifiex_adapter *adapter, u16 port)\n{\n\tstruct sdio_mmc_card *card = adapter->card;\n\tconst struct mwifiex_sdio_card_reg *reg = card->reg;\n\tint i;\n\n\tcard->mp_end_port = port;\n\n\tcard->mp_data_port_mask = reg->data_port_mask;\n\n\tif (reg->start_wr_port) {\n\t\tfor (i = 1; i <= card->max_ports - card->mp_end_port; i++)\n\t\t\tcard->mp_data_port_mask &=\n\t\t\t\t\t~(1 << (card->max_ports - i));\n\t}\n\n\tcard->curr_wr_port = reg->start_wr_port;\n\n\tmwifiex_dbg(adapter, CMD,\n\t\t    \"cmd: mp_end_port %d, data port mask 0x%x\\n\",\n\t\t    port, card->mp_data_port_mask);\n}\n\nstatic void mwifiex_sdio_card_reset_work(struct mwifiex_adapter *adapter)\n{\n\tstruct sdio_mmc_card *card = adapter->card;\n\tstruct sdio_func *func = card->func;\n\tint ret;\n\n\t \n\tmwifiex_shutdown_sw(adapter);\n\tclear_bit(MWIFIEX_IFACE_WORK_DEVICE_DUMP, &card->work_flags);\n\tclear_bit(MWIFIEX_IFACE_WORK_CARD_RESET, &card->work_flags);\n\n\t \n\tsdio_claim_host(func);\n\tret = mmc_hw_reset(func->card);\n\tsdio_release_host(func);\n\n\tswitch (ret) {\n\tcase 1:\n\t\tdev_dbg(&func->dev, \"SDIO HW reset asynchronous\\n\");\n\t\tcomplete_all(adapter->fw_done);\n\t\tbreak;\n\tcase 0:\n\t\tret = mwifiex_reinit_sw(adapter);\n\t\tif (ret)\n\t\t\tdev_err(&func->dev, \"reinit failed: %d\\n\", ret);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&func->dev, \"SDIO HW reset failed: %d\\n\", ret);\n\t\tbreak;\n\t}\n}\n\n \nstatic enum\nrdwr_status mwifiex_sdio_rdwr_firmware(struct mwifiex_adapter *adapter,\n\t\t\t\t       u8 doneflag)\n{\n\tstruct sdio_mmc_card *card = adapter->card;\n\tint ret, tries;\n\tu8 ctrl_data = 0;\n\n\tsdio_writeb(card->func, card->reg->fw_dump_host_ready,\n\t\t    card->reg->fw_dump_ctrl, &ret);\n\tif (ret) {\n\t\tmwifiex_dbg(adapter, ERROR, \"SDIO Write ERR\\n\");\n\t\treturn RDWR_STATUS_FAILURE;\n\t}\n\tfor (tries = 0; tries < MAX_POLL_TRIES; tries++) {\n\t\tctrl_data = sdio_readb(card->func, card->reg->fw_dump_ctrl,\n\t\t\t\t       &ret);\n\t\tif (ret) {\n\t\t\tmwifiex_dbg(adapter, ERROR, \"SDIO read err\\n\");\n\t\t\treturn RDWR_STATUS_FAILURE;\n\t\t}\n\t\tif (ctrl_data == FW_DUMP_DONE)\n\t\t\tbreak;\n\t\tif (doneflag && ctrl_data == doneflag)\n\t\t\treturn RDWR_STATUS_DONE;\n\t\tif (ctrl_data != card->reg->fw_dump_host_ready) {\n\t\t\tmwifiex_dbg(adapter, WARN,\n\t\t\t\t    \"The ctrl reg was changed, re-try again\\n\");\n\t\t\tsdio_writeb(card->func, card->reg->fw_dump_host_ready,\n\t\t\t\t    card->reg->fw_dump_ctrl, &ret);\n\t\t\tif (ret) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR, \"SDIO write err\\n\");\n\t\t\t\treturn RDWR_STATUS_FAILURE;\n\t\t\t}\n\t\t}\n\t\tusleep_range(100, 200);\n\t}\n\tif (ctrl_data == card->reg->fw_dump_host_ready) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"Fail to pull ctrl_data\\n\");\n\t\treturn RDWR_STATUS_FAILURE;\n\t}\n\n\treturn RDWR_STATUS_SUCCESS;\n}\n\n \nstatic void mwifiex_sdio_fw_dump(struct mwifiex_adapter *adapter)\n{\n\tstruct sdio_mmc_card *card = adapter->card;\n\tint ret = 0;\n\tunsigned int reg, reg_start, reg_end;\n\tu8 *dbg_ptr, *end_ptr, dump_num, idx, i, read_reg, doneflag = 0;\n\tenum rdwr_status stat;\n\tu32 memory_size;\n\n\tif (!card->can_dump_fw)\n\t\treturn;\n\n\tfor (idx = 0; idx < ARRAY_SIZE(mem_type_mapping_tbl); idx++) {\n\t\tstruct memory_type_mapping *entry = &mem_type_mapping_tbl[idx];\n\n\t\tif (entry->mem_ptr) {\n\t\t\tvfree(entry->mem_ptr);\n\t\t\tentry->mem_ptr = NULL;\n\t\t}\n\t\tentry->mem_size = 0;\n\t}\n\n\tmwifiex_pm_wakeup_card(adapter);\n\tsdio_claim_host(card->func);\n\n\tmwifiex_dbg(adapter, MSG, \"== mwifiex firmware dump start ==\\n\");\n\n\tstat = mwifiex_sdio_rdwr_firmware(adapter, doneflag);\n\tif (stat == RDWR_STATUS_FAILURE)\n\t\tgoto done;\n\n\treg = card->reg->fw_dump_start;\n\t \n\tdump_num = sdio_readb(card->func, reg, &ret);\n\tif (ret) {\n\t\tmwifiex_dbg(adapter, ERROR, \"SDIO read memory length err\\n\");\n\t\tgoto done;\n\t}\n\n\t \n\tfor (idx = 0; idx < dump_num; idx++) {\n\t\tstruct memory_type_mapping *entry = &mem_type_mapping_tbl[idx];\n\n\t\tstat = mwifiex_sdio_rdwr_firmware(adapter, doneflag);\n\t\tif (stat == RDWR_STATUS_FAILURE)\n\t\t\tgoto done;\n\n\t\tmemory_size = 0;\n\t\treg = card->reg->fw_dump_start;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tread_reg = sdio_readb(card->func, reg, &ret);\n\t\t\tif (ret) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR, \"SDIO read err\\n\");\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tmemory_size |= (read_reg << i*8);\n\t\t\treg++;\n\t\t}\n\n\t\tif (memory_size == 0) {\n\t\t\tmwifiex_dbg(adapter, DUMP, \"Firmware dump Finished!\\n\");\n\t\t\tret = mwifiex_write_reg(adapter,\n\t\t\t\t\t\tcard->reg->fw_dump_ctrl,\n\t\t\t\t\t\tFW_DUMP_READ_DONE);\n\t\t\tif (ret) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR, \"SDIO write err\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tmwifiex_dbg(adapter, DUMP,\n\t\t\t    \"%s_SIZE=0x%x\\n\", entry->mem_name, memory_size);\n\t\tentry->mem_ptr = vmalloc(memory_size + 1);\n\t\tentry->mem_size = memory_size;\n\t\tif (!entry->mem_ptr) {\n\t\t\tmwifiex_dbg(adapter, ERROR, \"Vmalloc %s failed\\n\",\n\t\t\t\t    entry->mem_name);\n\t\t\tgoto done;\n\t\t}\n\t\tdbg_ptr = entry->mem_ptr;\n\t\tend_ptr = dbg_ptr + memory_size;\n\n\t\tdoneflag = entry->done_flag;\n\t\tmwifiex_dbg(adapter, DUMP,\n\t\t\t    \"Start %s output, please wait...\\n\",\n\t\t\t    entry->mem_name);\n\n\t\tdo {\n\t\t\tstat = mwifiex_sdio_rdwr_firmware(adapter, doneflag);\n\t\t\tif (stat == RDWR_STATUS_FAILURE)\n\t\t\t\tgoto done;\n\n\t\t\treg_start = card->reg->fw_dump_start;\n\t\t\treg_end = card->reg->fw_dump_end;\n\t\t\tfor (reg = reg_start; reg <= reg_end; reg++) {\n\t\t\t\t*dbg_ptr = sdio_readb(card->func, reg, &ret);\n\t\t\t\tif (ret) {\n\t\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t\t    \"SDIO read err\\n\");\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tif (dbg_ptr < end_ptr)\n\t\t\t\t\tdbg_ptr++;\n\t\t\t\telse\n\t\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t\t    \"Allocated buf not enough\\n\");\n\t\t\t}\n\n\t\t\tif (stat != RDWR_STATUS_DONE)\n\t\t\t\tcontinue;\n\n\t\t\tmwifiex_dbg(adapter, DUMP, \"%s done: size=0x%tx\\n\",\n\t\t\t\t    entry->mem_name, dbg_ptr - entry->mem_ptr);\n\t\t\tbreak;\n\t\t} while (1);\n\t}\n\tmwifiex_dbg(adapter, MSG, \"== mwifiex firmware dump end ==\\n\");\n\ndone:\n\tsdio_release_host(card->func);\n}\n\nstatic void mwifiex_sdio_generic_fw_dump(struct mwifiex_adapter *adapter)\n{\n\tstruct sdio_mmc_card *card = adapter->card;\n\tstruct memory_type_mapping *entry = &generic_mem_type_map[0];\n\tunsigned int reg, reg_start, reg_end;\n\tu8 start_flag = 0, done_flag = 0;\n\tu8 *dbg_ptr, *end_ptr;\n\tenum rdwr_status stat;\n\tint ret = -1, tries;\n\n\tif (!card->fw_dump_enh)\n\t\treturn;\n\n\tif (entry->mem_ptr) {\n\t\tvfree(entry->mem_ptr);\n\t\tentry->mem_ptr = NULL;\n\t}\n\tentry->mem_size = 0;\n\n\tmwifiex_pm_wakeup_card(adapter);\n\tsdio_claim_host(card->func);\n\n\tmwifiex_dbg(adapter, MSG, \"== mwifiex firmware dump start ==\\n\");\n\n\tstat = mwifiex_sdio_rdwr_firmware(adapter, done_flag);\n\tif (stat == RDWR_STATUS_FAILURE)\n\t\tgoto done;\n\n\treg_start = card->reg->fw_dump_start;\n\treg_end = card->reg->fw_dump_end;\n\tfor (reg = reg_start; reg <= reg_end; reg++) {\n\t\tfor (tries = 0; tries < MAX_POLL_TRIES; tries++) {\n\t\t\tstart_flag = sdio_readb(card->func, reg, &ret);\n\t\t\tif (ret) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"SDIO read err\\n\");\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tif (start_flag == 0)\n\t\t\t\tbreak;\n\t\t\tif (tries == MAX_POLL_TRIES) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"FW not ready to dump\\n\");\n\t\t\t\tret = -1;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\tusleep_range(100, 200);\n\t}\n\n\tentry->mem_ptr = vmalloc(0xf0000 + 1);\n\tif (!entry->mem_ptr) {\n\t\tret = -1;\n\t\tgoto done;\n\t}\n\tdbg_ptr = entry->mem_ptr;\n\tentry->mem_size = 0xf0000;\n\tend_ptr = dbg_ptr + entry->mem_size;\n\n\tdone_flag = entry->done_flag;\n\tmwifiex_dbg(adapter, DUMP,\n\t\t    \"Start %s output, please wait...\\n\", entry->mem_name);\n\n\twhile (true) {\n\t\tstat = mwifiex_sdio_rdwr_firmware(adapter, done_flag);\n\t\tif (stat == RDWR_STATUS_FAILURE)\n\t\t\tgoto done;\n\t\tfor (reg = reg_start; reg <= reg_end; reg++) {\n\t\t\t*dbg_ptr = sdio_readb(card->func, reg, &ret);\n\t\t\tif (ret) {\n\t\t\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t\t\t    \"SDIO read err\\n\");\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tdbg_ptr++;\n\t\t\tif (dbg_ptr >= end_ptr) {\n\t\t\t\tu8 *tmp_ptr;\n\n\t\t\t\ttmp_ptr = vmalloc(entry->mem_size + 0x4000 + 1);\n\t\t\t\tif (!tmp_ptr)\n\t\t\t\t\tgoto done;\n\n\t\t\t\tmemcpy(tmp_ptr, entry->mem_ptr,\n\t\t\t\t       entry->mem_size);\n\t\t\t\tvfree(entry->mem_ptr);\n\t\t\t\tentry->mem_ptr = tmp_ptr;\n\t\t\t\ttmp_ptr = NULL;\n\t\t\t\tdbg_ptr = entry->mem_ptr + entry->mem_size;\n\t\t\t\tentry->mem_size += 0x4000;\n\t\t\t\tend_ptr = entry->mem_ptr + entry->mem_size;\n\t\t\t}\n\t\t}\n\t\tif (stat == RDWR_STATUS_DONE) {\n\t\t\tentry->mem_size = dbg_ptr - entry->mem_ptr;\n\t\t\tmwifiex_dbg(adapter, DUMP, \"dump %s done size=0x%x\\n\",\n\t\t\t\t    entry->mem_name, entry->mem_size);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmwifiex_dbg(adapter, MSG, \"== mwifiex firmware dump end ==\\n\");\n\ndone:\n\tif (ret) {\n\t\tmwifiex_dbg(adapter, ERROR, \"firmware dump failed\\n\");\n\t\tif (entry->mem_ptr) {\n\t\t\tvfree(entry->mem_ptr);\n\t\t\tentry->mem_ptr = NULL;\n\t\t}\n\t\tentry->mem_size = 0;\n\t}\n\tsdio_release_host(card->func);\n}\n\nstatic void mwifiex_sdio_device_dump_work(struct mwifiex_adapter *adapter)\n{\n\tstruct sdio_mmc_card *card = adapter->card;\n\n\tadapter->devdump_data = vzalloc(MWIFIEX_FW_DUMP_SIZE);\n\tif (!adapter->devdump_data) {\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"vzalloc devdump data failure!\\n\");\n\t\treturn;\n\t}\n\n\tmwifiex_drv_info_dump(adapter);\n\tif (card->fw_dump_enh)\n\t\tmwifiex_sdio_generic_fw_dump(adapter);\n\telse\n\t\tmwifiex_sdio_fw_dump(adapter);\n\tmwifiex_prepare_fw_dump_info(adapter);\n\tmwifiex_upload_device_dump(adapter);\n}\n\nstatic void mwifiex_sdio_work(struct work_struct *work)\n{\n\tstruct sdio_mmc_card *card =\n\t\tcontainer_of(work, struct sdio_mmc_card, work);\n\n\tif (test_and_clear_bit(MWIFIEX_IFACE_WORK_DEVICE_DUMP,\n\t\t\t       &card->work_flags))\n\t\tmwifiex_sdio_device_dump_work(card->adapter);\n\tif (test_and_clear_bit(MWIFIEX_IFACE_WORK_CARD_RESET,\n\t\t\t       &card->work_flags))\n\t\tmwifiex_sdio_card_reset_work(card->adapter);\n}\n\n \nstatic void mwifiex_sdio_card_reset(struct mwifiex_adapter *adapter)\n{\n\tstruct sdio_mmc_card *card = adapter->card;\n\n\tif (!test_and_set_bit(MWIFIEX_IFACE_WORK_CARD_RESET, &card->work_flags))\n\t\tschedule_work(&card->work);\n}\n\n \nstatic void mwifiex_sdio_device_dump(struct mwifiex_adapter *adapter)\n{\n\tstruct sdio_mmc_card *card = adapter->card;\n\n\tif (!test_and_set_bit(MWIFIEX_IFACE_WORK_DEVICE_DUMP,\n\t\t\t      &card->work_flags))\n\t\tschedule_work(&card->work);\n}\n\n \nstatic int\nmwifiex_sdio_reg_dump(struct mwifiex_adapter *adapter, char *drv_buf)\n{\n\tchar *p = drv_buf;\n\tstruct sdio_mmc_card *cardp = adapter->card;\n\tint ret = 0;\n\tu8 count, func, data, index = 0, size = 0;\n\tu8 reg, reg_start, reg_end;\n\tchar buf[256], *ptr;\n\n\tif (!p)\n\t\treturn 0;\n\n\tmwifiex_dbg(adapter, MSG, \"SDIO register dump start\\n\");\n\n\tmwifiex_pm_wakeup_card(adapter);\n\n\tsdio_claim_host(cardp->func);\n\n\tfor (count = 0; count < 5; count++) {\n\t\tmemset(buf, 0, sizeof(buf));\n\t\tptr = buf;\n\n\t\tswitch (count) {\n\t\tcase 0:\n\t\t\t \n\t\t\tfunc = count;\n\t\t\treg_start = 0;\n\t\t\treg_end = 9;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\t \n\t\t\tfunc = count;\n\t\t\treg_start = cardp->reg->func1_dump_reg_start;\n\t\t\treg_end = cardp->reg->func1_dump_reg_end;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tindex = 0;\n\t\t\tfunc = 1;\n\t\t\treg_start = cardp->reg->func1_spec_reg_table[index++];\n\t\t\tsize = cardp->reg->func1_spec_reg_num;\n\t\t\treg_end = cardp->reg->func1_spec_reg_table[size-1];\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tif (count == 4)\n\t\t\t\tmdelay(100);\n\t\t\tfunc = 1;\n\t\t\treg_start = cardp->reg->func1_scratch_reg;\n\t\t\treg_end = reg_start + MWIFIEX_SDIO_SCRATCH_SIZE;\n\t\t}\n\n\t\tif (count != 2)\n\t\t\tptr += sprintf(ptr, \"SDIO Func%d (%#x-%#x): \",\n\t\t\t\t       func, reg_start, reg_end);\n\t\telse\n\t\t\tptr += sprintf(ptr, \"SDIO Func%d: \", func);\n\n\t\tfor (reg = reg_start; reg <= reg_end;) {\n\t\t\tif (func == 0)\n\t\t\t\tdata = sdio_f0_readb(cardp->func, reg, &ret);\n\t\t\telse\n\t\t\t\tdata = sdio_readb(cardp->func, reg, &ret);\n\n\t\t\tif (count == 2)\n\t\t\t\tptr += sprintf(ptr, \"(%#x) \", reg);\n\t\t\tif (!ret) {\n\t\t\t\tptr += sprintf(ptr, \"%02x \", data);\n\t\t\t} else {\n\t\t\t\tptr += sprintf(ptr, \"ERR\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (count == 2 && reg < reg_end)\n\t\t\t\treg = cardp->reg->func1_spec_reg_table[index++];\n\t\t\telse\n\t\t\t\treg++;\n\t\t}\n\n\t\tmwifiex_dbg(adapter, MSG, \"%s\\n\", buf);\n\t\tp += sprintf(p, \"%s\\n\", buf);\n\t}\n\n\tsdio_release_host(cardp->func);\n\n\tmwifiex_dbg(adapter, MSG, \"SDIO register dump end\\n\");\n\n\treturn p - drv_buf;\n}\n\n \nstatic void mwifiex_sdio_up_dev(struct mwifiex_adapter *adapter)\n{\n\tstruct sdio_mmc_card *card = adapter->card;\n\tu8 sdio_ireg;\n\n\tsdio_claim_host(card->func);\n\tsdio_enable_func(card->func);\n\tsdio_set_block_size(card->func, MWIFIEX_SDIO_BLOCK_SIZE);\n\tsdio_release_host(card->func);\n\n\t \n\tadapter->tx_buf_size = card->tx_buf_size;\n\n\t \n\tmwifiex_read_reg(adapter, card->reg->host_int_status_reg, &sdio_ireg);\n\n\tif (mwifiex_init_sdio_ioport(adapter))\n\t\tdev_err(&card->func->dev, \"error enabling SDIO port\\n\");\n}\n\nstatic struct mwifiex_if_ops sdio_ops = {\n\t.init_if = mwifiex_init_sdio,\n\t.cleanup_if = mwifiex_cleanup_sdio,\n\t.check_fw_status = mwifiex_check_fw_status,\n\t.check_winner_status = mwifiex_check_winner_status,\n\t.prog_fw = mwifiex_prog_fw_w_helper,\n\t.register_dev = mwifiex_register_dev,\n\t.unregister_dev = mwifiex_unregister_dev,\n\t.enable_int = mwifiex_sdio_enable_host_int,\n\t.disable_int = mwifiex_sdio_disable_host_int,\n\t.process_int_status = mwifiex_process_int_status,\n\t.host_to_card = mwifiex_sdio_host_to_card,\n\t.wakeup = mwifiex_pm_wakeup_card,\n\t.wakeup_complete = mwifiex_pm_wakeup_card_complete,\n\n\t \n\t.update_mp_end_port = mwifiex_update_mp_end_port,\n\t.cleanup_mpa_buf = mwifiex_cleanup_mpa_buf,\n\t.cmdrsp_complete = mwifiex_sdio_cmdrsp_complete,\n\t.event_complete = mwifiex_sdio_event_complete,\n\t.dnld_fw = mwifiex_sdio_dnld_fw,\n\t.card_reset = mwifiex_sdio_card_reset,\n\t.reg_dump = mwifiex_sdio_reg_dump,\n\t.device_dump = mwifiex_sdio_device_dump,\n\t.deaggr_pkt = mwifiex_deaggr_sdio_pkt,\n\t.up_dev = mwifiex_sdio_up_dev,\n};\n\nmodule_driver(mwifiex_sdio, sdio_register_driver, sdio_unregister_driver);\n\nMODULE_AUTHOR(\"Marvell International Ltd.\");\nMODULE_DESCRIPTION(\"Marvell WiFi-Ex SDIO Driver version \" SDIO_VERSION);\nMODULE_VERSION(SDIO_VERSION);\nMODULE_LICENSE(\"GPL v2\");\nMODULE_FIRMWARE(SD8786_DEFAULT_FW_NAME);\nMODULE_FIRMWARE(SD8787_DEFAULT_FW_NAME);\nMODULE_FIRMWARE(SD8797_DEFAULT_FW_NAME);\nMODULE_FIRMWARE(SD8897_DEFAULT_FW_NAME);\nMODULE_FIRMWARE(SD8887_DEFAULT_FW_NAME);\nMODULE_FIRMWARE(SD8977_DEFAULT_FW_NAME);\nMODULE_FIRMWARE(SD8978_SDIOUART_FW_NAME);\nMODULE_FIRMWARE(SD8987_DEFAULT_FW_NAME);\nMODULE_FIRMWARE(SD8997_DEFAULT_FW_NAME);\nMODULE_FIRMWARE(SD8997_SDIOUART_FW_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}