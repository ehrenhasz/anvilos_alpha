{
  "module_name": "wmm.c",
  "hash_id": "f63bbdaa2cf38710e2d3ae59b020d920c3364ad085d32e4d5751b9719caa6c24",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/marvell/mwifiex/wmm.c",
  "human_readable_source": "\n \n\n#include \"decl.h\"\n#include \"ioctl.h\"\n#include \"util.h\"\n#include \"fw.h\"\n#include \"main.h\"\n#include \"wmm.h\"\n#include \"11n.h\"\n\n\n \n#define DRV_PKT_DELAY_TO_FW_MAX   512\n\n\n#define WMM_QUEUED_PACKET_LOWER_LIMIT   180\n\n#define WMM_QUEUED_PACKET_UPPER_LIMIT   200\n\n \n#define IPTOS_OFFSET 5\n\nstatic bool disable_tx_amsdu;\nmodule_param(disable_tx_amsdu, bool, 0644);\n\n \nconst u8 tos_to_tid_inv[] = {\n\t0x02,   \n\t0x00,   \n\t0x01,   \n\t0x03,\n\t0x04,\n\t0x05,\n\t0x06,\n\t0x07\n};\n\n \nstatic const u8 wmm_info_ie[] = { WLAN_EID_VENDOR_SPECIFIC, 0x07,\n\t0x00, 0x50, 0xf2, 0x02,\n\t0x00, 0x01, 0x00\n};\n\nstatic const u8 wmm_aci_to_qidx_map[] = { WMM_AC_BE,\n\tWMM_AC_BK,\n\tWMM_AC_VI,\n\tWMM_AC_VO\n};\n\nstatic u8 tos_to_tid[] = {\n\t \n\t0x01,\t\t\t \n\t0x02,\t\t\t \n\t0x00,\t\t\t \n\t0x03,\t\t\t \n\t0x04,\t\t\t \n\t0x05,\t\t\t \n\t0x06,\t\t\t \n\t0x07\t\t\t \n};\n\nstatic u8 ac_to_tid[4][2] = { {1, 2}, {0, 3}, {4, 5}, {6, 7} };\n\n \nstatic void\nmwifiex_wmm_ac_debug_print(const struct ieee_types_wmm_ac_parameters *ac_param)\n{\n\tconst char *ac_str[] = { \"BK\", \"BE\", \"VI\", \"VO\" };\n\n\tpr_debug(\"info: WMM AC_%s: ACI=%d, ACM=%d, Aifsn=%d, \"\n\t\t \"EcwMin=%d, EcwMax=%d, TxopLimit=%d\\n\",\n\t\t ac_str[wmm_aci_to_qidx_map[(ac_param->aci_aifsn_bitmap\n\t\t\t\t\t     & MWIFIEX_ACI) >> 5]],\n\t\t (ac_param->aci_aifsn_bitmap & MWIFIEX_ACI) >> 5,\n\t\t (ac_param->aci_aifsn_bitmap & MWIFIEX_ACM) >> 4,\n\t\t ac_param->aci_aifsn_bitmap & MWIFIEX_AIFSN,\n\t\t ac_param->ecw_bitmap & MWIFIEX_ECW_MIN,\n\t\t (ac_param->ecw_bitmap & MWIFIEX_ECW_MAX) >> 4,\n\t\t le16_to_cpu(ac_param->tx_op_limit));\n}\n\n \nstatic struct mwifiex_ra_list_tbl *\nmwifiex_wmm_allocate_ralist_node(struct mwifiex_adapter *adapter, const u8 *ra)\n{\n\tstruct mwifiex_ra_list_tbl *ra_list;\n\n\tra_list = kzalloc(sizeof(struct mwifiex_ra_list_tbl), GFP_ATOMIC);\n\tif (!ra_list)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&ra_list->list);\n\tskb_queue_head_init(&ra_list->skb_head);\n\n\tmemcpy(ra_list->ra, ra, ETH_ALEN);\n\n\tra_list->total_pkt_count = 0;\n\n\tmwifiex_dbg(adapter, INFO, \"info: allocated ra_list %p\\n\", ra_list);\n\n\treturn ra_list;\n}\n\n \nstatic u8 mwifiex_get_random_ba_threshold(void)\n{\n\tu64 ns;\n\t \n\tns = ktime_get_ns();\n\tns += (ns >> 32) + (ns >> 16);\n\n\treturn ((u8)ns % BA_SETUP_MAX_PACKET_THRESHOLD) + BA_SETUP_PACKET_OFFSET;\n}\n\n \nvoid mwifiex_ralist_add(struct mwifiex_private *priv, const u8 *ra)\n{\n\tint i;\n\tstruct mwifiex_ra_list_tbl *ra_list;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct mwifiex_sta_node *node;\n\n\n\tfor (i = 0; i < MAX_NUM_TID; ++i) {\n\t\tra_list = mwifiex_wmm_allocate_ralist_node(adapter, ra);\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"info: created ra_list %p\\n\", ra_list);\n\n\t\tif (!ra_list)\n\t\t\tbreak;\n\n\t\tra_list->is_11n_enabled = 0;\n\t\tra_list->tdls_link = false;\n\t\tra_list->ba_status = BA_SETUP_NONE;\n\t\tra_list->amsdu_in_ampdu = false;\n\t\tif (!mwifiex_queuing_ra_based(priv)) {\n\t\t\tif (mwifiex_is_tdls_link_setup\n\t\t\t\t(mwifiex_get_tdls_link_status(priv, ra))) {\n\t\t\t\tra_list->tdls_link = true;\n\t\t\t\tra_list->is_11n_enabled =\n\t\t\t\t\tmwifiex_tdls_peer_11n_enabled(priv, ra);\n\t\t\t} else {\n\t\t\t\tra_list->is_11n_enabled = IS_11N_ENABLED(priv);\n\t\t\t}\n\t\t} else {\n\t\t\tspin_lock_bh(&priv->sta_list_spinlock);\n\t\t\tnode = mwifiex_get_sta_entry(priv, ra);\n\t\t\tif (node)\n\t\t\t\tra_list->tx_paused = node->tx_pause;\n\t\t\tra_list->is_11n_enabled =\n\t\t\t\t      mwifiex_is_sta_11n_enabled(priv, node);\n\t\t\tif (ra_list->is_11n_enabled)\n\t\t\t\tra_list->max_amsdu = node->max_amsdu;\n\t\t\tspin_unlock_bh(&priv->sta_list_spinlock);\n\t\t}\n\n\t\tmwifiex_dbg(adapter, DATA, \"data: ralist %p: is_11n_enabled=%d\\n\",\n\t\t\t    ra_list, ra_list->is_11n_enabled);\n\n\t\tif (ra_list->is_11n_enabled) {\n\t\t\tra_list->ba_pkt_count = 0;\n\t\t\tra_list->ba_packet_thr =\n\t\t\t\t\t      mwifiex_get_random_ba_threshold();\n\t\t}\n\t\tlist_add_tail(&ra_list->list,\n\t\t\t      &priv->wmm.tid_tbl_ptr[i].ra_list);\n\t}\n}\n\n \nstatic void mwifiex_wmm_default_queue_priorities(struct mwifiex_private *priv)\n{\n\t \n\tpriv->wmm.queue_priority[0] = WMM_AC_VO;\n\tpriv->wmm.queue_priority[1] = WMM_AC_VI;\n\tpriv->wmm.queue_priority[2] = WMM_AC_BE;\n\tpriv->wmm.queue_priority[3] = WMM_AC_BK;\n}\n\n \nstatic void\nmwifiex_wmm_queue_priorities_tid(struct mwifiex_private *priv)\n{\n\tstruct mwifiex_wmm_desc *wmm = &priv->wmm;\n\tu8 *queue_priority = wmm->queue_priority;\n\tint i;\n\n\tfor (i = 0; i < 4; ++i) {\n\t\ttos_to_tid[7 - (i * 2)] = ac_to_tid[queue_priority[i]][1];\n\t\ttos_to_tid[6 - (i * 2)] = ac_to_tid[queue_priority[i]][0];\n\t}\n\n\tfor (i = 0; i < MAX_NUM_TID; ++i)\n\t\tpriv->tos_to_tid_inv[tos_to_tid[i]] = (u8)i;\n\n\tatomic_set(&wmm->highest_queued_prio, HIGH_PRIO_TID);\n}\n\n \nvoid\nmwifiex_wmm_setup_queue_priorities(struct mwifiex_private *priv,\n\t\t\t\t   struct ieee_types_wmm_parameter *wmm_ie)\n{\n\tu16 cw_min, avg_back_off, tmp[4];\n\tu32 i, j, num_ac;\n\tu8 ac_idx;\n\n\tif (!wmm_ie || !priv->wmm_enabled) {\n\t\t \n\t\tmwifiex_wmm_default_queue_priorities(priv);\n\t\treturn;\n\t}\n\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: WMM Parameter IE: version=%d,\\t\"\n\t\t    \"qos_info Parameter Set Count=%d, Reserved=%#x\\n\",\n\t\t    wmm_ie->version, wmm_ie->qos_info_bitmap &\n\t\t    IEEE80211_WMM_IE_AP_QOSINFO_PARAM_SET_CNT_MASK,\n\t\t    wmm_ie->reserved);\n\n\tfor (num_ac = 0; num_ac < ARRAY_SIZE(wmm_ie->ac_params); num_ac++) {\n\t\tu8 ecw = wmm_ie->ac_params[num_ac].ecw_bitmap;\n\t\tu8 aci_aifsn = wmm_ie->ac_params[num_ac].aci_aifsn_bitmap;\n\t\tcw_min = (1 << (ecw & MWIFIEX_ECW_MIN)) - 1;\n\t\tavg_back_off = (cw_min >> 1) + (aci_aifsn & MWIFIEX_AIFSN);\n\n\t\tac_idx = wmm_aci_to_qidx_map[(aci_aifsn & MWIFIEX_ACI) >> 5];\n\t\tpriv->wmm.queue_priority[ac_idx] = ac_idx;\n\t\ttmp[ac_idx] = avg_back_off;\n\n\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t    \"info: WMM: CWmax=%d CWmin=%d Avg Back-off=%d\\n\",\n\t\t\t    (1 << ((ecw & MWIFIEX_ECW_MAX) >> 4)) - 1,\n\t\t\t    cw_min, avg_back_off);\n\t\tmwifiex_wmm_ac_debug_print(&wmm_ie->ac_params[num_ac]);\n\t}\n\n\t \n\tfor (i = 0; i < num_ac; i++) {\n\t\tfor (j = 1; j < num_ac - i; j++) {\n\t\t\tif (tmp[j - 1] > tmp[j]) {\n\t\t\t\tswap(tmp[j - 1], tmp[j]);\n\t\t\t\tswap(priv->wmm.queue_priority[j - 1],\n\t\t\t\t     priv->wmm.queue_priority[j]);\n\t\t\t} else if (tmp[j - 1] == tmp[j]) {\n\t\t\t\tif (priv->wmm.queue_priority[j - 1]\n\t\t\t\t    < priv->wmm.queue_priority[j])\n\t\t\t\t\tswap(priv->wmm.queue_priority[j - 1],\n\t\t\t\t\t     priv->wmm.queue_priority[j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tmwifiex_wmm_queue_priorities_tid(priv);\n}\n\n \nstatic enum mwifiex_wmm_ac_e\nmwifiex_wmm_eval_downgrade_ac(struct mwifiex_private *priv,\n\t\t\t      enum mwifiex_wmm_ac_e eval_ac)\n{\n\tint down_ac;\n\tenum mwifiex_wmm_ac_e ret_ac;\n\tstruct mwifiex_wmm_ac_status *ac_status;\n\n\tac_status = &priv->wmm.ac_status[eval_ac];\n\n\tif (!ac_status->disabled)\n\t\t \n\t\treturn eval_ac;\n\n\t \n\tret_ac = WMM_AC_BK;\n\n\t \n\tfor (down_ac = WMM_AC_BK; down_ac < eval_ac; down_ac++) {\n\t\tac_status = &priv->wmm.ac_status[down_ac];\n\n\t\tif (!ac_status->disabled && !ac_status->flow_required)\n\t\t\t \n\t\t\tret_ac = (enum mwifiex_wmm_ac_e) down_ac;\n\t}\n\n\treturn ret_ac;\n}\n\n \nvoid\nmwifiex_wmm_setup_ac_downgrade(struct mwifiex_private *priv)\n{\n\tint ac_val;\n\n\tmwifiex_dbg(priv->adapter, INFO, \"info: WMM: AC Priorities:\\t\"\n\t\t    \"BK(0), BE(1), VI(2), VO(3)\\n\");\n\n\tif (!priv->wmm_enabled) {\n\t\t \n\t\tfor (ac_val = WMM_AC_BK; ac_val <= WMM_AC_VO; ac_val++)\n\t\t\tpriv->wmm.ac_down_graded_vals[ac_val] =\n\t\t\t\t\t\t(enum mwifiex_wmm_ac_e) ac_val;\n\t} else {\n\t\tfor (ac_val = WMM_AC_BK; ac_val <= WMM_AC_VO; ac_val++) {\n\t\t\tpriv->wmm.ac_down_graded_vals[ac_val]\n\t\t\t\t= mwifiex_wmm_eval_downgrade_ac(priv,\n\t\t\t\t\t\t(enum mwifiex_wmm_ac_e) ac_val);\n\t\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t\t    \"info: WMM: AC PRIO %d maps to %d\\n\",\n\t\t\t\t    ac_val,\n\t\t\t\t    priv->wmm.ac_down_graded_vals[ac_val]);\n\t\t}\n\t}\n}\n\n \nstatic enum mwifiex_wmm_ac_e\nmwifiex_wmm_convert_tos_to_ac(struct mwifiex_adapter *adapter, u32 tos)\n{\n\t \n\tstatic const enum mwifiex_wmm_ac_e tos_to_ac[] = {\n\t\tWMM_AC_BE,\n\t\tWMM_AC_BK,\n\t\tWMM_AC_BK,\n\t\tWMM_AC_BE,\n\t\tWMM_AC_VI,\n\t\tWMM_AC_VI,\n\t\tWMM_AC_VO,\n\t\tWMM_AC_VO\n\t};\n\n\tif (tos >= ARRAY_SIZE(tos_to_ac))\n\t\treturn WMM_AC_BE;\n\n\treturn tos_to_ac[tos];\n}\n\n \nu8 mwifiex_wmm_downgrade_tid(struct mwifiex_private *priv, u32 tid)\n{\n\tenum mwifiex_wmm_ac_e ac, ac_down;\n\tu8 new_tid;\n\n\tac = mwifiex_wmm_convert_tos_to_ac(priv->adapter, tid);\n\tac_down = priv->wmm.ac_down_graded_vals[ac];\n\n\t \n\tnew_tid = ac_to_tid[ac_down][tid % 2];\n\n\treturn new_tid;\n}\n\n \nvoid\nmwifiex_wmm_init(struct mwifiex_adapter *adapter)\n{\n\tint i, j;\n\tstruct mwifiex_private *priv;\n\n\tfor (j = 0; j < adapter->priv_num; ++j) {\n\t\tpriv = adapter->priv[j];\n\t\tif (!priv)\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < MAX_NUM_TID; ++i) {\n\t\t\tif (!disable_tx_amsdu &&\n\t\t\t    adapter->tx_buf_size > MWIFIEX_TX_DATA_BUF_SIZE_2K)\n\t\t\t\tpriv->aggr_prio_tbl[i].amsdu =\n\t\t\t\t\t\t\tpriv->tos_to_tid_inv[i];\n\t\t\telse\n\t\t\t\tpriv->aggr_prio_tbl[i].amsdu =\n\t\t\t\t\t\t\tBA_STREAM_NOT_ALLOWED;\n\t\t\tpriv->aggr_prio_tbl[i].ampdu_ap =\n\t\t\t\t\t\t\tpriv->tos_to_tid_inv[i];\n\t\t\tpriv->aggr_prio_tbl[i].ampdu_user =\n\t\t\t\t\t\t\tpriv->tos_to_tid_inv[i];\n\t\t}\n\n\t\tpriv->aggr_prio_tbl[6].amsdu\n\t\t\t\t\t= priv->aggr_prio_tbl[6].ampdu_ap\n\t\t\t\t\t= priv->aggr_prio_tbl[6].ampdu_user\n\t\t\t\t\t= BA_STREAM_NOT_ALLOWED;\n\n\t\tpriv->aggr_prio_tbl[7].amsdu = priv->aggr_prio_tbl[7].ampdu_ap\n\t\t\t\t\t= priv->aggr_prio_tbl[7].ampdu_user\n\t\t\t\t\t= BA_STREAM_NOT_ALLOWED;\n\n\t\tmwifiex_set_ba_params(priv);\n\t\tmwifiex_reset_11n_rx_seq_num(priv);\n\n\t\tpriv->wmm.drv_pkt_delay_max = MWIFIEX_WMM_DRV_DELAY_MAX;\n\t\tatomic_set(&priv->wmm.tx_pkts_queued, 0);\n\t\tatomic_set(&priv->wmm.highest_queued_prio, HIGH_PRIO_TID);\n\t}\n}\n\nint mwifiex_bypass_txlist_empty(struct mwifiex_adapter *adapter)\n{\n\tstruct mwifiex_private *priv;\n\tint i;\n\n\tfor (i = 0; i < adapter->priv_num; i++) {\n\t\tpriv = adapter->priv[i];\n\t\tif (!priv)\n\t\t\tcontinue;\n\t\tif (adapter->if_ops.is_port_ready &&\n\t\t    !adapter->if_ops.is_port_ready(priv))\n\t\t\tcontinue;\n\t\tif (!skb_queue_empty(&priv->bypass_txq))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nint\nmwifiex_wmm_lists_empty(struct mwifiex_adapter *adapter)\n{\n\tint i;\n\tstruct mwifiex_private *priv;\n\n\tfor (i = 0; i < adapter->priv_num; ++i) {\n\t\tpriv = adapter->priv[i];\n\t\tif (!priv)\n\t\t\tcontinue;\n\t\tif (!priv->port_open &&\n\t\t    (priv->bss_mode != NL80211_IFTYPE_ADHOC))\n\t\t\tcontinue;\n\t\tif (adapter->if_ops.is_port_ready &&\n\t\t    !adapter->if_ops.is_port_ready(priv))\n\t\t\tcontinue;\n\t\tif (atomic_read(&priv->wmm.tx_pkts_queued))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic void\nmwifiex_wmm_del_pkts_in_ralist_node(struct mwifiex_private *priv,\n\t\t\t\t    struct mwifiex_ra_list_tbl *ra_list)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct sk_buff *skb, *tmp;\n\n\tskb_queue_walk_safe(&ra_list->skb_head, skb, tmp) {\n\t\tskb_unlink(skb, &ra_list->skb_head);\n\t\tmwifiex_write_data_complete(adapter, skb, 0, -1);\n\t}\n}\n\n \nstatic void\nmwifiex_wmm_del_pkts_in_ralist(struct mwifiex_private *priv,\n\t\t\t       struct list_head *ra_list_head)\n{\n\tstruct mwifiex_ra_list_tbl *ra_list;\n\n\tlist_for_each_entry(ra_list, ra_list_head, list)\n\t\tmwifiex_wmm_del_pkts_in_ralist_node(priv, ra_list);\n}\n\n \nstatic void mwifiex_wmm_cleanup_queues(struct mwifiex_private *priv)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_NUM_TID; i++)\n\t\tmwifiex_wmm_del_pkts_in_ralist(priv, &priv->wmm.tid_tbl_ptr[i].\n\t\t\t\t\t\t\t\t       ra_list);\n\n\tatomic_set(&priv->wmm.tx_pkts_queued, 0);\n\tatomic_set(&priv->wmm.highest_queued_prio, HIGH_PRIO_TID);\n}\n\n \nstatic void mwifiex_wmm_delete_all_ralist(struct mwifiex_private *priv)\n{\n\tstruct mwifiex_ra_list_tbl *ra_list, *tmp_node;\n\tint i;\n\n\tfor (i = 0; i < MAX_NUM_TID; ++i) {\n\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t    \"info: ra_list: freeing buf for tid %d\\n\", i);\n\t\tlist_for_each_entry_safe(ra_list, tmp_node,\n\t\t\t\t\t &priv->wmm.tid_tbl_ptr[i].ra_list,\n\t\t\t\t\t list) {\n\t\t\tlist_del(&ra_list->list);\n\t\t\tkfree(ra_list);\n\t\t}\n\n\t\tINIT_LIST_HEAD(&priv->wmm.tid_tbl_ptr[i].ra_list);\n\t}\n}\n\nstatic int mwifiex_free_ack_frame(int id, void *p, void *data)\n{\n\tpr_warn(\"Have pending ack frames!\\n\");\n\tkfree_skb(p);\n\treturn 0;\n}\n\n \nvoid\nmwifiex_clean_txrx(struct mwifiex_private *priv)\n{\n\tstruct sk_buff *skb, *tmp;\n\n\tmwifiex_11n_cleanup_reorder_tbl(priv);\n\tspin_lock_bh(&priv->wmm.ra_list_spinlock);\n\n\tmwifiex_wmm_cleanup_queues(priv);\n\tmwifiex_11n_delete_all_tx_ba_stream_tbl(priv);\n\n\tif (priv->adapter->if_ops.cleanup_mpa_buf)\n\t\tpriv->adapter->if_ops.cleanup_mpa_buf(priv->adapter);\n\n\tmwifiex_wmm_delete_all_ralist(priv);\n\tmemcpy(tos_to_tid, ac_to_tid, sizeof(tos_to_tid));\n\n\tif (priv->adapter->if_ops.clean_pcie_ring &&\n\t    !test_bit(MWIFIEX_SURPRISE_REMOVED, &priv->adapter->work_flags))\n\t\tpriv->adapter->if_ops.clean_pcie_ring(priv->adapter);\n\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\n\tskb_queue_walk_safe(&priv->tdls_txq, skb, tmp) {\n\t\tskb_unlink(skb, &priv->tdls_txq);\n\t\tmwifiex_write_data_complete(priv->adapter, skb, 0, -1);\n\t}\n\n\tskb_queue_walk_safe(&priv->bypass_txq, skb, tmp) {\n\t\tskb_unlink(skb, &priv->bypass_txq);\n\t\tmwifiex_write_data_complete(priv->adapter, skb, 0, -1);\n\t}\n\tatomic_set(&priv->adapter->bypass_tx_pending, 0);\n\n\tidr_for_each(&priv->ack_status_frames, mwifiex_free_ack_frame, NULL);\n\tidr_destroy(&priv->ack_status_frames);\n}\n\n \nstruct mwifiex_ra_list_tbl *\nmwifiex_wmm_get_ralist_node(struct mwifiex_private *priv, u8 tid,\n\t\t\t    const u8 *ra_addr)\n{\n\tstruct mwifiex_ra_list_tbl *ra_list;\n\n\tlist_for_each_entry(ra_list, &priv->wmm.tid_tbl_ptr[tid].ra_list,\n\t\t\t    list) {\n\t\tif (!memcmp(ra_list->ra, ra_addr, ETH_ALEN))\n\t\t\treturn ra_list;\n\t}\n\n\treturn NULL;\n}\n\nvoid mwifiex_update_ralist_tx_pause(struct mwifiex_private *priv, u8 *mac,\n\t\t\t\t    u8 tx_pause)\n{\n\tstruct mwifiex_ra_list_tbl *ra_list;\n\tu32 pkt_cnt = 0, tx_pkts_queued;\n\tint i;\n\n\tspin_lock_bh(&priv->wmm.ra_list_spinlock);\n\n\tfor (i = 0; i < MAX_NUM_TID; ++i) {\n\t\tra_list = mwifiex_wmm_get_ralist_node(priv, i, mac);\n\t\tif (ra_list && ra_list->tx_paused != tx_pause) {\n\t\t\tpkt_cnt += ra_list->total_pkt_count;\n\t\t\tra_list->tx_paused = tx_pause;\n\t\t\tif (tx_pause)\n\t\t\t\tpriv->wmm.pkts_paused[i] +=\n\t\t\t\t\tra_list->total_pkt_count;\n\t\t\telse\n\t\t\t\tpriv->wmm.pkts_paused[i] -=\n\t\t\t\t\tra_list->total_pkt_count;\n\t\t}\n\t}\n\n\tif (pkt_cnt) {\n\t\ttx_pkts_queued = atomic_read(&priv->wmm.tx_pkts_queued);\n\t\tif (tx_pause)\n\t\t\ttx_pkts_queued -= pkt_cnt;\n\t\telse\n\t\t\ttx_pkts_queued += pkt_cnt;\n\n\t\tatomic_set(&priv->wmm.tx_pkts_queued, tx_pkts_queued);\n\t\tatomic_set(&priv->wmm.highest_queued_prio, HIGH_PRIO_TID);\n\t}\n\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n}\n\n \nvoid mwifiex_update_ralist_tx_pause_in_tdls_cs(struct mwifiex_private *priv,\n\t\t\t\t\t       u8 *mac, u8 tx_pause)\n{\n\tstruct mwifiex_ra_list_tbl *ra_list;\n\tu32 pkt_cnt = 0, tx_pkts_queued;\n\tint i;\n\n\tspin_lock_bh(&priv->wmm.ra_list_spinlock);\n\n\tfor (i = 0; i < MAX_NUM_TID; ++i) {\n\t\tlist_for_each_entry(ra_list, &priv->wmm.tid_tbl_ptr[i].ra_list,\n\t\t\t\t    list) {\n\t\t\tif (!memcmp(ra_list->ra, mac, ETH_ALEN))\n\t\t\t\tcontinue;\n\n\t\t\tif (ra_list->tx_paused != tx_pause) {\n\t\t\t\tpkt_cnt += ra_list->total_pkt_count;\n\t\t\t\tra_list->tx_paused = tx_pause;\n\t\t\t\tif (tx_pause)\n\t\t\t\t\tpriv->wmm.pkts_paused[i] +=\n\t\t\t\t\t\tra_list->total_pkt_count;\n\t\t\t\telse\n\t\t\t\t\tpriv->wmm.pkts_paused[i] -=\n\t\t\t\t\t\tra_list->total_pkt_count;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (pkt_cnt) {\n\t\ttx_pkts_queued = atomic_read(&priv->wmm.tx_pkts_queued);\n\t\tif (tx_pause)\n\t\t\ttx_pkts_queued -= pkt_cnt;\n\t\telse\n\t\t\ttx_pkts_queued += pkt_cnt;\n\n\t\tatomic_set(&priv->wmm.tx_pkts_queued, tx_pkts_queued);\n\t\tatomic_set(&priv->wmm.highest_queued_prio, HIGH_PRIO_TID);\n\t}\n\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n}\n\n \nstruct mwifiex_ra_list_tbl *\nmwifiex_wmm_get_queue_raptr(struct mwifiex_private *priv, u8 tid,\n\t\t\t    const u8 *ra_addr)\n{\n\tstruct mwifiex_ra_list_tbl *ra_list;\n\n\tra_list = mwifiex_wmm_get_ralist_node(priv, tid, ra_addr);\n\tif (ra_list)\n\t\treturn ra_list;\n\tmwifiex_ralist_add(priv, ra_addr);\n\n\treturn mwifiex_wmm_get_ralist_node(priv, tid, ra_addr);\n}\n\n \nvoid\nmwifiex_wmm_del_peer_ra_list(struct mwifiex_private *priv, const u8 *ra_addr)\n{\n\tstruct mwifiex_ra_list_tbl *ra_list;\n\tint i;\n\n\tspin_lock_bh(&priv->wmm.ra_list_spinlock);\n\n\tfor (i = 0; i < MAX_NUM_TID; ++i) {\n\t\tra_list = mwifiex_wmm_get_ralist_node(priv, i, ra_addr);\n\n\t\tif (!ra_list)\n\t\t\tcontinue;\n\t\tmwifiex_wmm_del_pkts_in_ralist_node(priv, ra_list);\n\t\tif (ra_list->tx_paused)\n\t\t\tpriv->wmm.pkts_paused[i] -= ra_list->total_pkt_count;\n\t\telse\n\t\t\tatomic_sub(ra_list->total_pkt_count,\n\t\t\t\t   &priv->wmm.tx_pkts_queued);\n\t\tlist_del(&ra_list->list);\n\t\tkfree(ra_list);\n\t}\n\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n}\n\n \nint\nmwifiex_is_ralist_valid(struct mwifiex_private *priv,\n\t\t\tstruct mwifiex_ra_list_tbl *ra_list, int ptr_index)\n{\n\tstruct mwifiex_ra_list_tbl *rlist;\n\n\tlist_for_each_entry(rlist, &priv->wmm.tid_tbl_ptr[ptr_index].ra_list,\n\t\t\t    list) {\n\t\tif (rlist == ra_list)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nvoid\nmwifiex_wmm_add_buf_bypass_txqueue(struct mwifiex_private *priv,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tskb_queue_tail(&priv->bypass_txq, skb);\n}\n\n \nvoid\nmwifiex_wmm_add_buf_txqueue(struct mwifiex_private *priv,\n\t\t\t    struct sk_buff *skb)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tu32 tid;\n\tstruct mwifiex_ra_list_tbl *ra_list;\n\tu8 ra[ETH_ALEN], tid_down;\n\tstruct list_head list_head;\n\tint tdls_status = TDLS_NOT_SETUP;\n\tstruct ethhdr *eth_hdr = (struct ethhdr *)skb->data;\n\tstruct mwifiex_txinfo *tx_info = MWIFIEX_SKB_TXCB(skb);\n\n\tmemcpy(ra, eth_hdr->h_dest, ETH_ALEN);\n\n\tif (GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_STA &&\n\t    ISSUPP_TDLS_ENABLED(adapter->fw_cap_info)) {\n\t\tif (ntohs(eth_hdr->h_proto) == ETH_P_TDLS)\n\t\t\tmwifiex_dbg(adapter, DATA,\n\t\t\t\t    \"TDLS setup packet for %pM.\\t\"\n\t\t\t\t    \"Don't block\\n\", ra);\n\t\telse if (memcmp(priv->cfg_bssid, ra, ETH_ALEN))\n\t\t\ttdls_status = mwifiex_get_tdls_link_status(priv, ra);\n\t}\n\n\tif (!priv->media_connected && !mwifiex_is_skb_mgmt_frame(skb)) {\n\t\tmwifiex_dbg(adapter, DATA, \"data: drop packet in disconnect\\n\");\n\t\tmwifiex_write_data_complete(adapter, skb, 0, -1);\n\t\treturn;\n\t}\n\n\ttid = skb->priority;\n\n\tspin_lock_bh(&priv->wmm.ra_list_spinlock);\n\n\ttid_down = mwifiex_wmm_downgrade_tid(priv, tid);\n\n\t \n\tif (!mwifiex_queuing_ra_based(priv) &&\n\t    !mwifiex_is_skb_mgmt_frame(skb)) {\n\t\tswitch (tdls_status) {\n\t\tcase TDLS_SETUP_COMPLETE:\n\t\tcase TDLS_CHAN_SWITCHING:\n\t\tcase TDLS_IN_BASE_CHAN:\n\t\tcase TDLS_IN_OFF_CHAN:\n\t\t\tra_list = mwifiex_wmm_get_queue_raptr(priv, tid_down,\n\t\t\t\t\t\t\t      ra);\n\t\t\ttx_info->flags |= MWIFIEX_BUF_FLAG_TDLS_PKT;\n\t\t\tbreak;\n\t\tcase TDLS_SETUP_INPROGRESS:\n\t\t\tskb_queue_tail(&priv->tdls_txq, skb);\n\t\t\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\t\t\treturn;\n\t\tdefault:\n\t\t\tlist_head = priv->wmm.tid_tbl_ptr[tid_down].ra_list;\n\t\t\tra_list = list_first_entry_or_null(&list_head,\n\t\t\t\t\tstruct mwifiex_ra_list_tbl, list);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tmemcpy(ra, skb->data, ETH_ALEN);\n\t\tif (ra[0] & 0x01 || mwifiex_is_skb_mgmt_frame(skb))\n\t\t\teth_broadcast_addr(ra);\n\t\tra_list = mwifiex_wmm_get_queue_raptr(priv, tid_down, ra);\n\t}\n\n\tif (!ra_list) {\n\t\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\t\tmwifiex_write_data_complete(adapter, skb, 0, -1);\n\t\treturn;\n\t}\n\n\tskb_queue_tail(&ra_list->skb_head, skb);\n\n\tra_list->ba_pkt_count++;\n\tra_list->total_pkt_count++;\n\n\tif (atomic_read(&priv->wmm.highest_queued_prio) <\n\t\t\t\t\t\tpriv->tos_to_tid_inv[tid_down])\n\t\tatomic_set(&priv->wmm.highest_queued_prio,\n\t\t\t   priv->tos_to_tid_inv[tid_down]);\n\n\tif (ra_list->tx_paused)\n\t\tpriv->wmm.pkts_paused[tid_down]++;\n\telse\n\t\tatomic_inc(&priv->wmm.tx_pkts_queued);\n\n\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n}\n\n \nint mwifiex_ret_wmm_get_status(struct mwifiex_private *priv,\n\t\t\t       const struct host_cmd_ds_command *resp)\n{\n\tu8 *curr = (u8 *) &resp->params.get_wmm_status;\n\tuint16_t resp_len = le16_to_cpu(resp->size), tlv_len;\n\tint mask = IEEE80211_WMM_IE_AP_QOSINFO_PARAM_SET_CNT_MASK;\n\tbool valid = true;\n\n\tstruct mwifiex_ie_types_data *tlv_hdr;\n\tstruct mwifiex_ie_types_wmm_queue_status *tlv_wmm_qstatus;\n\tstruct ieee_types_wmm_parameter *wmm_param_ie = NULL;\n\tstruct mwifiex_wmm_ac_status *ac_status;\n\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: WMM: WMM_GET_STATUS cmdresp received: %d\\n\",\n\t\t    resp_len);\n\n\twhile ((resp_len >= sizeof(tlv_hdr->header)) && valid) {\n\t\ttlv_hdr = (struct mwifiex_ie_types_data *) curr;\n\t\ttlv_len = le16_to_cpu(tlv_hdr->header.len);\n\n\t\tif (resp_len < tlv_len + sizeof(tlv_hdr->header))\n\t\t\tbreak;\n\n\t\tswitch (le16_to_cpu(tlv_hdr->header.type)) {\n\t\tcase TLV_TYPE_WMMQSTATUS:\n\t\t\ttlv_wmm_qstatus =\n\t\t\t\t(struct mwifiex_ie_types_wmm_queue_status *)\n\t\t\t\ttlv_hdr;\n\t\t\tmwifiex_dbg(priv->adapter, CMD,\n\t\t\t\t    \"info: CMD_RESP: WMM_GET_STATUS:\\t\"\n\t\t\t\t    \"QSTATUS TLV: %d, %d, %d\\n\",\n\t\t\t\t    tlv_wmm_qstatus->queue_index,\n\t\t\t\t    tlv_wmm_qstatus->flow_required,\n\t\t\t\t    tlv_wmm_qstatus->disabled);\n\n\t\t\tac_status = &priv->wmm.ac_status[tlv_wmm_qstatus->\n\t\t\t\t\t\t\t queue_index];\n\t\t\tac_status->disabled = tlv_wmm_qstatus->disabled;\n\t\t\tac_status->flow_required =\n\t\t\t\t\t\ttlv_wmm_qstatus->flow_required;\n\t\t\tac_status->flow_created = tlv_wmm_qstatus->flow_created;\n\t\t\tbreak;\n\n\t\tcase WLAN_EID_VENDOR_SPECIFIC:\n\t\t\t \n\n\t\t\twmm_param_ie =\n\t\t\t\t(struct ieee_types_wmm_parameter *) (curr +\n\t\t\t\t\t\t\t\t    2);\n\t\t\twmm_param_ie->vend_hdr.len = (u8) tlv_len;\n\t\t\twmm_param_ie->vend_hdr.element_id =\n\t\t\t\t\t\tWLAN_EID_VENDOR_SPECIFIC;\n\n\t\t\tmwifiex_dbg(priv->adapter, CMD,\n\t\t\t\t    \"info: CMD_RESP: WMM_GET_STATUS:\\t\"\n\t\t\t\t    \"WMM Parameter Set Count: %d\\n\",\n\t\t\t\t    wmm_param_ie->qos_info_bitmap & mask);\n\n\t\t\tif (wmm_param_ie->vend_hdr.len + 2 >\n\t\t\t\tsizeof(struct ieee_types_wmm_parameter))\n\t\t\t\tbreak;\n\n\t\t\tmemcpy((u8 *) &priv->curr_bss_params.bss_descriptor.\n\t\t\t       wmm_ie, wmm_param_ie,\n\t\t\t       wmm_param_ie->vend_hdr.len + 2);\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tvalid = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tcurr += (tlv_len + sizeof(tlv_hdr->header));\n\t\tresp_len -= (tlv_len + sizeof(tlv_hdr->header));\n\t}\n\n\tmwifiex_wmm_setup_queue_priorities(priv, wmm_param_ie);\n\tmwifiex_wmm_setup_ac_downgrade(priv);\n\n\treturn 0;\n}\n\n \nu32\nmwifiex_wmm_process_association_req(struct mwifiex_private *priv,\n\t\t\t\t    u8 **assoc_buf,\n\t\t\t\t    struct ieee_types_wmm_parameter *wmm_ie,\n\t\t\t\t    struct ieee80211_ht_cap *ht_cap)\n{\n\tstruct mwifiex_ie_types_wmm_param_set *wmm_tlv;\n\tu32 ret_len = 0;\n\n\t \n\tif (!assoc_buf)\n\t\treturn 0;\n\tif (!(*assoc_buf))\n\t\treturn 0;\n\n\tif (!wmm_ie)\n\t\treturn 0;\n\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: WMM: process assoc req: bss->wmm_ie=%#x\\n\",\n\t\t    wmm_ie->vend_hdr.element_id);\n\n\tif ((priv->wmm_required ||\n\t     (ht_cap && (priv->adapter->config_bands & BAND_GN ||\n\t     priv->adapter->config_bands & BAND_AN))) &&\n\t    wmm_ie->vend_hdr.element_id == WLAN_EID_VENDOR_SPECIFIC) {\n\t\twmm_tlv = (struct mwifiex_ie_types_wmm_param_set *) *assoc_buf;\n\t\twmm_tlv->header.type = cpu_to_le16((u16) wmm_info_ie[0]);\n\t\twmm_tlv->header.len = cpu_to_le16((u16) wmm_info_ie[1]);\n\t\tmemcpy(wmm_tlv->wmm_ie, &wmm_info_ie[2],\n\t\t       le16_to_cpu(wmm_tlv->header.len));\n\t\tif (wmm_ie->qos_info_bitmap & IEEE80211_WMM_IE_AP_QOSINFO_UAPSD)\n\t\t\tmemcpy((u8 *) (wmm_tlv->wmm_ie\n\t\t\t\t       + le16_to_cpu(wmm_tlv->header.len)\n\t\t\t\t       - sizeof(priv->wmm_qosinfo)),\n\t\t\t       &priv->wmm_qosinfo, sizeof(priv->wmm_qosinfo));\n\n\t\tret_len = sizeof(wmm_tlv->header)\n\t\t\t  + le16_to_cpu(wmm_tlv->header.len);\n\n\t\t*assoc_buf += ret_len;\n\t}\n\n\treturn ret_len;\n}\n\n \nu8\nmwifiex_wmm_compute_drv_pkt_delay(struct mwifiex_private *priv,\n\t\t\t\t  const struct sk_buff *skb)\n{\n\tu32 queue_delay = ktime_to_ms(net_timedelta(skb->tstamp));\n\tu8 ret_val;\n\n\t \n\tret_val = (u8) (min(queue_delay, priv->wmm.drv_pkt_delay_max) >> 1);\n\n\tmwifiex_dbg(priv->adapter, DATA, \"data: WMM: Pkt Delay: %d ms,\\t\"\n\t\t    \"%d ms sent to FW\\n\", queue_delay, ret_val);\n\n\treturn ret_val;\n}\n\n \nstatic struct mwifiex_ra_list_tbl *\nmwifiex_wmm_get_highest_priolist_ptr(struct mwifiex_adapter *adapter,\n\t\t\t\t     struct mwifiex_private **priv, int *tid)\n{\n\tstruct mwifiex_private *priv_tmp;\n\tstruct mwifiex_ra_list_tbl *ptr;\n\tstruct mwifiex_tid_tbl *tid_ptr;\n\tatomic_t *hqp;\n\tint i, j;\n\n\t \n\tfor (j = adapter->priv_num - 1; j >= 0; --j) {\n\t\t \n\t\tlist_for_each_entry(adapter->bss_prio_tbl[j].bss_prio_cur,\n\t\t\t\t    &adapter->bss_prio_tbl[j].bss_prio_head,\n\t\t\t\t    list) {\n\ntry_again:\n\t\t\tpriv_tmp = adapter->bss_prio_tbl[j].bss_prio_cur->priv;\n\n\t\t\tif (((priv_tmp->bss_mode != NL80211_IFTYPE_ADHOC) &&\n\t\t\t     !priv_tmp->port_open) ||\n\t\t\t    (atomic_read(&priv_tmp->wmm.tx_pkts_queued) == 0))\n\t\t\t\tcontinue;\n\n\t\t\tif (adapter->if_ops.is_port_ready &&\n\t\t\t    !adapter->if_ops.is_port_ready(priv_tmp))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\thqp = &priv_tmp->wmm.highest_queued_prio;\n\t\t\tfor (i = atomic_read(hqp); i >= LOW_PRIO_TID; --i) {\n\n\t\t\t\tspin_lock_bh(&priv_tmp->wmm.ra_list_spinlock);\n\n\t\t\t\ttid_ptr = &(priv_tmp)->wmm.\n\t\t\t\t\ttid_tbl_ptr[tos_to_tid[i]];\n\n\t\t\t\t \n\t\t\t\tlist_for_each_entry(ptr, &tid_ptr->ra_list,\n\t\t\t\t\t\t    list) {\n\n\t\t\t\t\tif (!ptr->tx_paused &&\n\t\t\t\t\t    !skb_queue_empty(&ptr->skb_head))\n\t\t\t\t\t\t \n\t\t\t\t\t\tgoto found;\n\t\t\t\t}\n\n\t\t\t\tspin_unlock_bh(&priv_tmp->wmm.ra_list_spinlock);\n\t\t\t}\n\n\t\t\tif (atomic_read(&priv_tmp->wmm.tx_pkts_queued) != 0) {\n\t\t\t\tatomic_set(&priv_tmp->wmm.highest_queued_prio,\n\t\t\t\t\t   HIGH_PRIO_TID);\n\t\t\t\t \n\t\t\t\tgoto try_again;\n\t\t\t} else\n\t\t\t\tatomic_set(&priv_tmp->wmm.highest_queued_prio,\n\t\t\t\t\t   NO_PKT_PRIO_TID);\n\t\t}\n\t}\n\n\treturn NULL;\n\nfound:\n\t \n\tif (atomic_read(hqp) > i)\n\t\tatomic_set(hqp, i);\n\tspin_unlock_bh(&priv_tmp->wmm.ra_list_spinlock);\n\n\t*priv = priv_tmp;\n\t*tid = tos_to_tid[i];\n\n\treturn ptr;\n}\n\n \nvoid mwifiex_rotate_priolists(struct mwifiex_private *priv,\n\t\t\t\t struct mwifiex_ra_list_tbl *ra,\n\t\t\t\t int tid)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct mwifiex_bss_prio_tbl *tbl = adapter->bss_prio_tbl;\n\tstruct mwifiex_tid_tbl *tid_ptr = &priv->wmm.tid_tbl_ptr[tid];\n\n\tspin_lock_bh(&tbl[priv->bss_priority].bss_prio_lock);\n\t \n\tlist_move(&tbl[priv->bss_priority].bss_prio_head,\n\t\t  &tbl[priv->bss_priority].bss_prio_cur->list);\n\tspin_unlock_bh(&tbl[priv->bss_priority].bss_prio_lock);\n\n\tspin_lock_bh(&priv->wmm.ra_list_spinlock);\n\tif (mwifiex_is_ralist_valid(priv, ra, tid)) {\n\t\tpriv->wmm.packets_out[tid]++;\n\t\t \n\t\tlist_move(&tid_ptr->ra_list, &ra->list);\n\t}\n\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n}\n\n \nstatic int\nmwifiex_is_11n_aggragation_possible(struct mwifiex_private *priv,\n\t\t\t\t    struct mwifiex_ra_list_tbl *ptr,\n\t\t\t\t    int max_buf_size)\n{\n\tint count = 0, total_size = 0;\n\tstruct sk_buff *skb, *tmp;\n\tint max_amsdu_size;\n\n\tif (priv->bss_role == MWIFIEX_BSS_ROLE_UAP && priv->ap_11n_enabled &&\n\t    ptr->is_11n_enabled)\n\t\tmax_amsdu_size = min_t(int, ptr->max_amsdu, max_buf_size);\n\telse\n\t\tmax_amsdu_size = max_buf_size;\n\n\tskb_queue_walk_safe(&ptr->skb_head, skb, tmp) {\n\t\ttotal_size += skb->len;\n\t\tif (total_size >= max_amsdu_size)\n\t\t\tbreak;\n\t\tif (++count >= MIN_NUM_AMSDU)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic void\nmwifiex_send_single_packet(struct mwifiex_private *priv,\n\t\t\t   struct mwifiex_ra_list_tbl *ptr, int ptr_index)\n\t\t\t   __releases(&priv->wmm.ra_list_spinlock)\n{\n\tstruct sk_buff *skb, *skb_next;\n\tstruct mwifiex_tx_param tx_param;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct mwifiex_txinfo *tx_info;\n\n\tif (skb_queue_empty(&ptr->skb_head)) {\n\t\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\t\tmwifiex_dbg(adapter, DATA, \"data: nothing to send\\n\");\n\t\treturn;\n\t}\n\n\tskb = skb_dequeue(&ptr->skb_head);\n\n\ttx_info = MWIFIEX_SKB_TXCB(skb);\n\tmwifiex_dbg(adapter, DATA,\n\t\t    \"data: dequeuing the packet %p %p\\n\", ptr, skb);\n\n\tptr->total_pkt_count--;\n\n\tif (!skb_queue_empty(&ptr->skb_head))\n\t\tskb_next = skb_peek(&ptr->skb_head);\n\telse\n\t\tskb_next = NULL;\n\n\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\n\ttx_param.next_pkt_len = ((skb_next) ? skb_next->len +\n\t\t\t\tsizeof(struct txpd) : 0);\n\n\tif (mwifiex_process_tx(priv, skb, &tx_param) == -EBUSY) {\n\t\t \n\t\tspin_lock_bh(&priv->wmm.ra_list_spinlock);\n\n\t\tif (!mwifiex_is_ralist_valid(priv, ptr, ptr_index)) {\n\t\t\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\t\t\tmwifiex_write_data_complete(adapter, skb, 0, -1);\n\t\t\treturn;\n\t\t}\n\n\t\tskb_queue_tail(&ptr->skb_head, skb);\n\n\t\tptr->total_pkt_count++;\n\t\tptr->ba_pkt_count++;\n\t\ttx_info->flags |= MWIFIEX_BUF_FLAG_REQUEUED_PKT;\n\t\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\t} else {\n\t\tmwifiex_rotate_priolists(priv, ptr, ptr_index);\n\t\tatomic_dec(&priv->wmm.tx_pkts_queued);\n\t}\n}\n\n \nstatic int\nmwifiex_is_ptr_processed(struct mwifiex_private *priv,\n\t\t\t struct mwifiex_ra_list_tbl *ptr)\n{\n\tstruct sk_buff *skb;\n\tstruct mwifiex_txinfo *tx_info;\n\n\tif (skb_queue_empty(&ptr->skb_head))\n\t\treturn false;\n\n\tskb = skb_peek(&ptr->skb_head);\n\n\ttx_info = MWIFIEX_SKB_TXCB(skb);\n\tif (tx_info->flags & MWIFIEX_BUF_FLAG_REQUEUED_PKT)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic void\nmwifiex_send_processed_packet(struct mwifiex_private *priv,\n\t\t\t      struct mwifiex_ra_list_tbl *ptr, int ptr_index)\n\t\t\t\t__releases(&priv->wmm.ra_list_spinlock)\n{\n\tstruct mwifiex_tx_param tx_param;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tint ret = -1;\n\tstruct sk_buff *skb, *skb_next;\n\tstruct mwifiex_txinfo *tx_info;\n\n\tif (skb_queue_empty(&ptr->skb_head)) {\n\t\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\t\treturn;\n\t}\n\n\tskb = skb_dequeue(&ptr->skb_head);\n\n\tif (adapter->data_sent || adapter->tx_lock_flag) {\n\t\tptr->total_pkt_count--;\n\t\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\t\tskb_queue_tail(&adapter->tx_data_q, skb);\n\t\tatomic_dec(&priv->wmm.tx_pkts_queued);\n\t\tatomic_inc(&adapter->tx_queued);\n\t\treturn;\n\t}\n\n\tif (!skb_queue_empty(&ptr->skb_head))\n\t\tskb_next = skb_peek(&ptr->skb_head);\n\telse\n\t\tskb_next = NULL;\n\n\ttx_info = MWIFIEX_SKB_TXCB(skb);\n\n\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\n\ttx_param.next_pkt_len =\n\t\t((skb_next) ? skb_next->len +\n\t\t sizeof(struct txpd) : 0);\n\tif (adapter->iface_type == MWIFIEX_USB) {\n\t\tret = adapter->if_ops.host_to_card(adapter, priv->usb_port,\n\t\t\t\t\t\t   skb, &tx_param);\n\t} else {\n\t\tret = adapter->if_ops.host_to_card(adapter, MWIFIEX_TYPE_DATA,\n\t\t\t\t\t\t   skb, &tx_param);\n\t}\n\n\tswitch (ret) {\n\tcase -EBUSY:\n\t\tmwifiex_dbg(adapter, ERROR, \"data: -EBUSY is returned\\n\");\n\t\tspin_lock_bh(&priv->wmm.ra_list_spinlock);\n\n\t\tif (!mwifiex_is_ralist_valid(priv, ptr, ptr_index)) {\n\t\t\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\t\t\tmwifiex_write_data_complete(adapter, skb, 0, -1);\n\t\t\treturn;\n\t\t}\n\n\t\tskb_queue_tail(&ptr->skb_head, skb);\n\n\t\ttx_info->flags |= MWIFIEX_BUF_FLAG_REQUEUED_PKT;\n\t\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\t\tbreak;\n\tcase -1:\n\t\tmwifiex_dbg(adapter, ERROR, \"host_to_card failed: %#x\\n\", ret);\n\t\tadapter->dbg.num_tx_host_to_card_failure++;\n\t\tmwifiex_write_data_complete(adapter, skb, 0, ret);\n\t\tbreak;\n\tcase -EINPROGRESS:\n\t\tbreak;\n\tcase 0:\n\t\tmwifiex_write_data_complete(adapter, skb, 0, ret);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (ret != -EBUSY) {\n\t\tmwifiex_rotate_priolists(priv, ptr, ptr_index);\n\t\tatomic_dec(&priv->wmm.tx_pkts_queued);\n\t\tspin_lock_bh(&priv->wmm.ra_list_spinlock);\n\t\tptr->total_pkt_count--;\n\t\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\t}\n}\n\n \nstatic int\nmwifiex_dequeue_tx_packet(struct mwifiex_adapter *adapter)\n{\n\tstruct mwifiex_ra_list_tbl *ptr;\n\tstruct mwifiex_private *priv = NULL;\n\tint ptr_index = 0;\n\tu8 ra[ETH_ALEN];\n\tint tid_del = 0, tid = 0;\n\n\tptr = mwifiex_wmm_get_highest_priolist_ptr(adapter, &priv, &ptr_index);\n\tif (!ptr)\n\t\treturn -1;\n\n\ttid = mwifiex_get_tid(ptr);\n\n\tmwifiex_dbg(adapter, DATA, \"data: tid=%d\\n\", tid);\n\n\tspin_lock_bh(&priv->wmm.ra_list_spinlock);\n\tif (!mwifiex_is_ralist_valid(priv, ptr, ptr_index)) {\n\t\tspin_unlock_bh(&priv->wmm.ra_list_spinlock);\n\t\treturn -1;\n\t}\n\n\tif (mwifiex_is_ptr_processed(priv, ptr)) {\n\t\tmwifiex_send_processed_packet(priv, ptr, ptr_index);\n\t\t \n\t\treturn 0;\n\t}\n\n\tif (!ptr->is_11n_enabled ||\n\t\tptr->ba_status ||\n\t\tpriv->wps.session_enable) {\n\t\tif (ptr->is_11n_enabled &&\n\t\t\tptr->ba_status &&\n\t\t\tptr->amsdu_in_ampdu &&\n\t\t\tmwifiex_is_amsdu_allowed(priv, tid) &&\n\t\t\tmwifiex_is_11n_aggragation_possible(priv, ptr,\n\t\t\t\t\t\t\tadapter->tx_buf_size))\n\t\t\tmwifiex_11n_aggregate_pkt(priv, ptr, ptr_index);\n\t\t\t \n\t\telse\n\t\t\tmwifiex_send_single_packet(priv, ptr, ptr_index);\n\t\t\t \n\t} else {\n\t\tif (mwifiex_is_ampdu_allowed(priv, ptr, tid) &&\n\t\t    ptr->ba_pkt_count > ptr->ba_packet_thr) {\n\t\t\tif (mwifiex_space_avail_for_new_ba_stream(adapter)) {\n\t\t\t\tmwifiex_create_ba_tbl(priv, ptr->ra, tid,\n\t\t\t\t\t\t      BA_SETUP_INPROGRESS);\n\t\t\t\tmwifiex_send_addba(priv, tid, ptr->ra);\n\t\t\t} else if (mwifiex_find_stream_to_delete\n\t\t\t\t   (priv, tid, &tid_del, ra)) {\n\t\t\t\tmwifiex_create_ba_tbl(priv, ptr->ra, tid,\n\t\t\t\t\t\t      BA_SETUP_INPROGRESS);\n\t\t\t\tmwifiex_send_delba(priv, tid_del, ra, 1);\n\t\t\t}\n\t\t}\n\t\tif (mwifiex_is_amsdu_allowed(priv, tid) &&\n\t\t    mwifiex_is_11n_aggragation_possible(priv, ptr,\n\t\t\t\t\t\t\tadapter->tx_buf_size))\n\t\t\tmwifiex_11n_aggregate_pkt(priv, ptr, ptr_index);\n\t\t\t \n\t\telse\n\t\t\tmwifiex_send_single_packet(priv, ptr, ptr_index);\n\t\t\t \n\t}\n\treturn 0;\n}\n\nvoid mwifiex_process_bypass_tx(struct mwifiex_adapter *adapter)\n{\n\tstruct mwifiex_tx_param tx_param;\n\tstruct sk_buff *skb;\n\tstruct mwifiex_txinfo *tx_info;\n\tstruct mwifiex_private *priv;\n\tint i;\n\n\tif (adapter->data_sent || adapter->tx_lock_flag)\n\t\treturn;\n\n\tfor (i = 0; i < adapter->priv_num; ++i) {\n\t\tpriv = adapter->priv[i];\n\n\t\tif (!priv)\n\t\t\tcontinue;\n\n\t\tif (adapter->if_ops.is_port_ready &&\n\t\t    !adapter->if_ops.is_port_ready(priv))\n\t\t\tcontinue;\n\n\t\tif (skb_queue_empty(&priv->bypass_txq))\n\t\t\tcontinue;\n\n\t\tskb = skb_dequeue(&priv->bypass_txq);\n\t\ttx_info = MWIFIEX_SKB_TXCB(skb);\n\n\t\t \n\t\ttx_param.next_pkt_len = 0;\n\n\t\tif (mwifiex_process_tx(priv, skb, &tx_param) == -EBUSY) {\n\t\t\tskb_queue_head(&priv->bypass_txq, skb);\n\t\t\ttx_info->flags |= MWIFIEX_BUF_FLAG_REQUEUED_PKT;\n\t\t} else {\n\t\t\tatomic_dec(&adapter->bypass_tx_pending);\n\t\t}\n\t}\n}\n\n \nvoid\nmwifiex_wmm_process_tx(struct mwifiex_adapter *adapter)\n{\n\tdo {\n\t\tif (mwifiex_dequeue_tx_packet(adapter))\n\t\t\tbreak;\n\t\tif (adapter->iface_type != MWIFIEX_SDIO) {\n\t\t\tif (adapter->data_sent ||\n\t\t\t    adapter->tx_lock_flag)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (atomic_read(&adapter->tx_queued) >=\n\t\t\t    MWIFIEX_MAX_PKTS_TXQ)\n\t\t\t\tbreak;\n\t\t}\n\t} while (!mwifiex_wmm_lists_empty(adapter));\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}