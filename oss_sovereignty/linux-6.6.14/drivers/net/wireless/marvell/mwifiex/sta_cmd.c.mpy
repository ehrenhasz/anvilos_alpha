{
  "module_name": "sta_cmd.c",
  "hash_id": "1524e0821660daff698bbdc66a62bd2f0c6b55d0145e90dc2c04f4443723ff1d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/marvell/mwifiex/sta_cmd.c",
  "human_readable_source": "\n \n\n#include \"decl.h\"\n#include \"ioctl.h\"\n#include \"util.h\"\n#include \"fw.h\"\n#include \"main.h\"\n#include \"wmm.h\"\n#include \"11n.h\"\n#include \"11ac.h\"\n\nstatic bool drcs;\nmodule_param(drcs, bool, 0644);\nMODULE_PARM_DESC(drcs, \"multi-channel operation:1, single-channel operation:0\");\n\nstatic bool disable_auto_ds;\nmodule_param(disable_auto_ds, bool, 0);\nMODULE_PARM_DESC(disable_auto_ds,\n\t\t \"deepsleep enabled=0(default), deepsleep disabled=1\");\n \nstatic int\nmwifiex_cmd_802_11_rssi_info(struct mwifiex_private *priv,\n\t\t\t     struct host_cmd_ds_command *cmd, u16 cmd_action)\n{\n\tcmd->command = cpu_to_le16(HostCmd_CMD_RSSI_INFO);\n\tcmd->size = cpu_to_le16(sizeof(struct host_cmd_ds_802_11_rssi_info) +\n\t\t\t\tS_DS_GEN);\n\tcmd->params.rssi_info.action = cpu_to_le16(cmd_action);\n\tcmd->params.rssi_info.ndata = cpu_to_le16(priv->data_avg_factor);\n\tcmd->params.rssi_info.nbcn = cpu_to_le16(priv->bcn_avg_factor);\n\n\t \n\tpriv->data_rssi_last = 0;\n\tpriv->data_nf_last = 0;\n\tpriv->data_rssi_avg = 0;\n\tpriv->data_nf_avg = 0;\n\tpriv->bcn_rssi_last = 0;\n\tpriv->bcn_nf_last = 0;\n\tpriv->bcn_rssi_avg = 0;\n\tpriv->bcn_nf_avg = 0;\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_cmd_mac_control(struct mwifiex_private *priv,\n\t\t\t\t   struct host_cmd_ds_command *cmd,\n\t\t\t\t   u16 cmd_action, u32 *action)\n{\n\tstruct host_cmd_ds_mac_control *mac_ctrl = &cmd->params.mac_ctrl;\n\n\tif (cmd_action != HostCmd_ACT_GEN_SET) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"mac_control: only support set cmd\\n\");\n\t\treturn -1;\n\t}\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_MAC_CONTROL);\n\tcmd->size =\n\t\tcpu_to_le16(sizeof(struct host_cmd_ds_mac_control) + S_DS_GEN);\n\tmac_ctrl->action = cpu_to_le32(*action);\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_cmd_802_11_snmp_mib(struct mwifiex_private *priv,\n\t\t\t\t       struct host_cmd_ds_command *cmd,\n\t\t\t\t       u16 cmd_action, u32 cmd_oid,\n\t\t\t\t       u16 *ul_temp)\n{\n\tstruct host_cmd_ds_802_11_snmp_mib *snmp_mib = &cmd->params.smib;\n\n\tmwifiex_dbg(priv->adapter, CMD,\n\t\t    \"cmd: SNMP_CMD: cmd_oid = 0x%x\\n\", cmd_oid);\n\tcmd->command = cpu_to_le16(HostCmd_CMD_802_11_SNMP_MIB);\n\tcmd->size = cpu_to_le16(sizeof(struct host_cmd_ds_802_11_snmp_mib)\n\t\t\t\t- 1 + S_DS_GEN);\n\n\tsnmp_mib->oid = cpu_to_le16((u16)cmd_oid);\n\tif (cmd_action == HostCmd_ACT_GEN_GET) {\n\t\tsnmp_mib->query_type = cpu_to_le16(HostCmd_ACT_GEN_GET);\n\t\tsnmp_mib->buf_size = cpu_to_le16(MAX_SNMP_BUF_SIZE);\n\t\tle16_unaligned_add_cpu(&cmd->size, MAX_SNMP_BUF_SIZE);\n\t} else if (cmd_action == HostCmd_ACT_GEN_SET) {\n\t\tsnmp_mib->query_type = cpu_to_le16(HostCmd_ACT_GEN_SET);\n\t\tsnmp_mib->buf_size = cpu_to_le16(sizeof(u16));\n\t\tput_unaligned_le16(*ul_temp, snmp_mib->value);\n\t\tle16_unaligned_add_cpu(&cmd->size, sizeof(u16));\n\t}\n\n\tmwifiex_dbg(priv->adapter, CMD,\n\t\t    \"cmd: SNMP_CMD: Action=0x%x, OID=0x%x,\\t\"\n\t\t    \"OIDSize=0x%x, Value=0x%x\\n\",\n\t\t    cmd_action, cmd_oid, le16_to_cpu(snmp_mib->buf_size),\n\t\t    get_unaligned_le16(snmp_mib->value));\n\treturn 0;\n}\n\n \nstatic int\nmwifiex_cmd_802_11_get_log(struct host_cmd_ds_command *cmd)\n{\n\tcmd->command = cpu_to_le16(HostCmd_CMD_802_11_GET_LOG);\n\tcmd->size = cpu_to_le16(sizeof(struct host_cmd_ds_802_11_get_log) +\n\t\t\t\tS_DS_GEN);\n\treturn 0;\n}\n\n \nstatic int mwifiex_cmd_tx_rate_cfg(struct mwifiex_private *priv,\n\t\t\t\t   struct host_cmd_ds_command *cmd,\n\t\t\t\t   u16 cmd_action, u16 *pbitmap_rates)\n{\n\tstruct host_cmd_ds_tx_rate_cfg *rate_cfg = &cmd->params.tx_rate_cfg;\n\tstruct mwifiex_rate_scope *rate_scope;\n\tstruct mwifiex_rate_drop_pattern *rate_drop;\n\tu32 i;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_TX_RATE_CFG);\n\n\trate_cfg->action = cpu_to_le16(cmd_action);\n\trate_cfg->cfg_index = 0;\n\n\trate_scope = (struct mwifiex_rate_scope *) ((u8 *) rate_cfg +\n\t\t      sizeof(struct host_cmd_ds_tx_rate_cfg));\n\trate_scope->type = cpu_to_le16(TLV_TYPE_RATE_SCOPE);\n\trate_scope->length = cpu_to_le16\n\t\t(sizeof(*rate_scope) - sizeof(struct mwifiex_ie_types_header));\n\tif (pbitmap_rates != NULL) {\n\t\trate_scope->hr_dsss_rate_bitmap = cpu_to_le16(pbitmap_rates[0]);\n\t\trate_scope->ofdm_rate_bitmap = cpu_to_le16(pbitmap_rates[1]);\n\t\tfor (i = 0; i < ARRAY_SIZE(rate_scope->ht_mcs_rate_bitmap); i++)\n\t\t\trate_scope->ht_mcs_rate_bitmap[i] =\n\t\t\t\tcpu_to_le16(pbitmap_rates[2 + i]);\n\t\tif (priv->adapter->fw_api_ver == MWIFIEX_FW_V15) {\n\t\t\tfor (i = 0;\n\t\t\t     i < ARRAY_SIZE(rate_scope->vht_mcs_rate_bitmap);\n\t\t\t     i++)\n\t\t\t\trate_scope->vht_mcs_rate_bitmap[i] =\n\t\t\t\t\tcpu_to_le16(pbitmap_rates[10 + i]);\n\t\t}\n\t} else {\n\t\trate_scope->hr_dsss_rate_bitmap =\n\t\t\tcpu_to_le16(priv->bitmap_rates[0]);\n\t\trate_scope->ofdm_rate_bitmap =\n\t\t\tcpu_to_le16(priv->bitmap_rates[1]);\n\t\tfor (i = 0; i < ARRAY_SIZE(rate_scope->ht_mcs_rate_bitmap); i++)\n\t\t\trate_scope->ht_mcs_rate_bitmap[i] =\n\t\t\t\tcpu_to_le16(priv->bitmap_rates[2 + i]);\n\t\tif (priv->adapter->fw_api_ver == MWIFIEX_FW_V15) {\n\t\t\tfor (i = 0;\n\t\t\t     i < ARRAY_SIZE(rate_scope->vht_mcs_rate_bitmap);\n\t\t\t     i++)\n\t\t\t\trate_scope->vht_mcs_rate_bitmap[i] =\n\t\t\t\t\tcpu_to_le16(priv->bitmap_rates[10 + i]);\n\t\t}\n\t}\n\n\trate_drop = (struct mwifiex_rate_drop_pattern *) ((u8 *) rate_scope +\n\t\t\t\t\t     sizeof(struct mwifiex_rate_scope));\n\trate_drop->type = cpu_to_le16(TLV_TYPE_RATE_DROP_CONTROL);\n\trate_drop->length = cpu_to_le16(sizeof(rate_drop->rate_drop_mode));\n\trate_drop->rate_drop_mode = 0;\n\n\tcmd->size =\n\t\tcpu_to_le16(S_DS_GEN + sizeof(struct host_cmd_ds_tx_rate_cfg) +\n\t\t\t    sizeof(struct mwifiex_rate_scope) +\n\t\t\t    sizeof(struct mwifiex_rate_drop_pattern));\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_cmd_tx_power_cfg(struct host_cmd_ds_command *cmd,\n\t\t\t\t    u16 cmd_action,\n\t\t\t\t    struct host_cmd_ds_txpwr_cfg *txp)\n{\n\tstruct mwifiex_types_power_group *pg_tlv;\n\tstruct host_cmd_ds_txpwr_cfg *cmd_txp_cfg = &cmd->params.txp_cfg;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_TXPWR_CFG);\n\tcmd->size =\n\t\tcpu_to_le16(S_DS_GEN + sizeof(struct host_cmd_ds_txpwr_cfg));\n\tswitch (cmd_action) {\n\tcase HostCmd_ACT_GEN_SET:\n\t\tif (txp->mode) {\n\t\t\tpg_tlv = (struct mwifiex_types_power_group\n\t\t\t\t  *) ((unsigned long) txp +\n\t\t\t\t     sizeof(struct host_cmd_ds_txpwr_cfg));\n\t\t\tmemmove(cmd_txp_cfg, txp,\n\t\t\t\tsizeof(struct host_cmd_ds_txpwr_cfg) +\n\t\t\t\tsizeof(struct mwifiex_types_power_group) +\n\t\t\t\tle16_to_cpu(pg_tlv->length));\n\n\t\t\tpg_tlv = (struct mwifiex_types_power_group *) ((u8 *)\n\t\t\t\t  cmd_txp_cfg +\n\t\t\t\t  sizeof(struct host_cmd_ds_txpwr_cfg));\n\t\t\tcmd->size = cpu_to_le16(le16_to_cpu(cmd->size) +\n\t\t\t\t  sizeof(struct mwifiex_types_power_group) +\n\t\t\t\t  le16_to_cpu(pg_tlv->length));\n\t\t} else {\n\t\t\tmemmove(cmd_txp_cfg, txp, sizeof(*txp));\n\t\t}\n\t\tcmd_txp_cfg->action = cpu_to_le16(cmd_action);\n\t\tbreak;\n\tcase HostCmd_ACT_GEN_GET:\n\t\tcmd_txp_cfg->action = cpu_to_le16(cmd_action);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_cmd_rf_tx_power(struct mwifiex_private *priv,\n\t\t\t\t   struct host_cmd_ds_command *cmd,\n\t\t\t\t   u16 cmd_action, void *data_buf)\n{\n\tstruct host_cmd_ds_rf_tx_pwr *txp = &cmd->params.txp;\n\n\tcmd->size = cpu_to_le16(sizeof(struct host_cmd_ds_rf_tx_pwr)\n\t\t\t\t+ S_DS_GEN);\n\tcmd->command = cpu_to_le16(HostCmd_CMD_RF_TX_PWR);\n\ttxp->action = cpu_to_le16(cmd_action);\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_cmd_rf_antenna(struct mwifiex_private *priv,\n\t\t\t\t  struct host_cmd_ds_command *cmd,\n\t\t\t\t  u16 cmd_action,\n\t\t\t\t  struct mwifiex_ds_ant_cfg *ant_cfg)\n{\n\tstruct host_cmd_ds_rf_ant_mimo *ant_mimo = &cmd->params.ant_mimo;\n\tstruct host_cmd_ds_rf_ant_siso *ant_siso = &cmd->params.ant_siso;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_RF_ANTENNA);\n\n\tswitch (cmd_action) {\n\tcase HostCmd_ACT_GEN_SET:\n\t\tif (priv->adapter->hw_dev_mcs_support == HT_STREAM_2X2) {\n\t\t\tcmd->size = cpu_to_le16(sizeof(struct\n\t\t\t\t\t\thost_cmd_ds_rf_ant_mimo)\n\t\t\t\t\t\t+ S_DS_GEN);\n\t\t\tant_mimo->action_tx = cpu_to_le16(HostCmd_ACT_SET_TX);\n\t\t\tant_mimo->tx_ant_mode = cpu_to_le16((u16)ant_cfg->\n\t\t\t\t\t\t\t    tx_ant);\n\t\t\tant_mimo->action_rx = cpu_to_le16(HostCmd_ACT_SET_RX);\n\t\t\tant_mimo->rx_ant_mode = cpu_to_le16((u16)ant_cfg->\n\t\t\t\t\t\t\t    rx_ant);\n\t\t} else {\n\t\t\tcmd->size = cpu_to_le16(sizeof(struct\n\t\t\t\t\t\thost_cmd_ds_rf_ant_siso) +\n\t\t\t\t\t\tS_DS_GEN);\n\t\t\tant_siso->action = cpu_to_le16(HostCmd_ACT_SET_BOTH);\n\t\t\tant_siso->ant_mode = cpu_to_le16((u16)ant_cfg->tx_ant);\n\t\t}\n\t\tbreak;\n\tcase HostCmd_ACT_GEN_GET:\n\t\tif (priv->adapter->hw_dev_mcs_support == HT_STREAM_2X2) {\n\t\t\tcmd->size = cpu_to_le16(sizeof(struct\n\t\t\t\t\t\thost_cmd_ds_rf_ant_mimo) +\n\t\t\t\t\t\tS_DS_GEN);\n\t\t\tant_mimo->action_tx = cpu_to_le16(HostCmd_ACT_GET_TX);\n\t\t\tant_mimo->action_rx = cpu_to_le16(HostCmd_ACT_GET_RX);\n\t\t} else {\n\t\t\tcmd->size = cpu_to_le16(sizeof(struct\n\t\t\t\t\t\thost_cmd_ds_rf_ant_siso) +\n\t\t\t\t\t\tS_DS_GEN);\n\t\t\tant_siso->action = cpu_to_le16(HostCmd_ACT_GET_BOTH);\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n \nstatic int\nmwifiex_cmd_802_11_hs_cfg(struct mwifiex_private *priv,\n\t\t\t  struct host_cmd_ds_command *cmd,\n\t\t\t  u16 cmd_action,\n\t\t\t  struct mwifiex_hs_config_param *hscfg_param)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct host_cmd_ds_802_11_hs_cfg_enh *hs_cfg = &cmd->params.opt_hs_cfg;\n\tu8 *tlv = (u8 *)hs_cfg + sizeof(struct host_cmd_ds_802_11_hs_cfg_enh);\n\tstruct mwifiex_ps_param_in_hs *psparam_tlv = NULL;\n\tbool hs_activate = false;\n\tu16 size;\n\n\tif (!hscfg_param)\n\t\t \n\t\ths_activate = true;\n\tcmd->command = cpu_to_le16(HostCmd_CMD_802_11_HS_CFG_ENH);\n\n\tif (!hs_activate &&\n\t    (hscfg_param->conditions != cpu_to_le32(HS_CFG_CANCEL)) &&\n\t    ((adapter->arp_filter_size > 0) &&\n\t     (adapter->arp_filter_size <= ARP_FILTER_MAX_BUF_SIZE))) {\n\t\tmwifiex_dbg(adapter, CMD,\n\t\t\t    \"cmd: Attach %d bytes ArpFilter to HSCfg cmd\\n\",\n\t\t\t    adapter->arp_filter_size);\n\t\tmemcpy(((u8 *) hs_cfg) +\n\t\t       sizeof(struct host_cmd_ds_802_11_hs_cfg_enh),\n\t\t       adapter->arp_filter, adapter->arp_filter_size);\n\t\tsize = adapter->arp_filter_size +\n\t\t\tsizeof(struct host_cmd_ds_802_11_hs_cfg_enh)\n\t\t\t+ S_DS_GEN;\n\t\ttlv = (u8 *)hs_cfg\n\t\t\t+ sizeof(struct host_cmd_ds_802_11_hs_cfg_enh)\n\t\t\t+ adapter->arp_filter_size;\n\t} else {\n\t\tsize = S_DS_GEN + sizeof(struct host_cmd_ds_802_11_hs_cfg_enh);\n\t}\n\tif (hs_activate) {\n\t\ths_cfg->action = cpu_to_le16(HS_ACTIVATE);\n\t\ths_cfg->params.hs_activate.resp_ctrl = cpu_to_le16(RESP_NEEDED);\n\n\t\tadapter->hs_activated_manually = true;\n\t\tmwifiex_dbg(priv->adapter, CMD,\n\t\t\t    \"cmd: Activating host sleep manually\\n\");\n\t} else {\n\t\ths_cfg->action = cpu_to_le16(HS_CONFIGURE);\n\t\ths_cfg->params.hs_config.conditions = hscfg_param->conditions;\n\t\ths_cfg->params.hs_config.gpio = hscfg_param->gpio;\n\t\ths_cfg->params.hs_config.gap = hscfg_param->gap;\n\n\t\tsize += sizeof(struct mwifiex_ps_param_in_hs);\n\t\tpsparam_tlv = (struct mwifiex_ps_param_in_hs *)tlv;\n\t\tpsparam_tlv->header.type =\n\t\t\tcpu_to_le16(TLV_TYPE_PS_PARAMS_IN_HS);\n\t\tpsparam_tlv->header.len =\n\t\t\tcpu_to_le16(sizeof(struct mwifiex_ps_param_in_hs)\n\t\t\t\t- sizeof(struct mwifiex_ie_types_header));\n\t\tpsparam_tlv->hs_wake_int = cpu_to_le32(HS_DEF_WAKE_INTERVAL);\n\t\tpsparam_tlv->hs_inact_timeout =\n\t\t\tcpu_to_le32(HS_DEF_INACTIVITY_TIMEOUT);\n\n\t\tmwifiex_dbg(adapter, CMD,\n\t\t\t    \"cmd: HS_CFG_CMD: condition:0x%x gpio:0x%x gap:0x%x\\n\",\n\t\t\t    hs_cfg->params.hs_config.conditions,\n\t\t\t    hs_cfg->params.hs_config.gpio,\n\t\t\t    hs_cfg->params.hs_config.gap);\n\t}\n\tcmd->size = cpu_to_le16(size);\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_cmd_802_11_mac_address(struct mwifiex_private *priv,\n\t\t\t\t\t  struct host_cmd_ds_command *cmd,\n\t\t\t\t\t  u16 cmd_action)\n{\n\tcmd->command = cpu_to_le16(HostCmd_CMD_802_11_MAC_ADDRESS);\n\tcmd->size = cpu_to_le16(sizeof(struct host_cmd_ds_802_11_mac_address) +\n\t\t\t\tS_DS_GEN);\n\tcmd->result = 0;\n\n\tcmd->params.mac_addr.action = cpu_to_le16(cmd_action);\n\n\tif (cmd_action == HostCmd_ACT_GEN_SET)\n\t\tmemcpy(cmd->params.mac_addr.mac_addr, priv->curr_addr,\n\t\t       ETH_ALEN);\n\treturn 0;\n}\n\n \nstatic int\nmwifiex_cmd_mac_multicast_adr(struct host_cmd_ds_command *cmd,\n\t\t\t      u16 cmd_action,\n\t\t\t      struct mwifiex_multicast_list *mcast_list)\n{\n\tstruct host_cmd_ds_mac_multicast_adr *mcast_addr = &cmd->params.mc_addr;\n\n\tcmd->size = cpu_to_le16(sizeof(struct host_cmd_ds_mac_multicast_adr) +\n\t\t\t\tS_DS_GEN);\n\tcmd->command = cpu_to_le16(HostCmd_CMD_MAC_MULTICAST_ADR);\n\n\tmcast_addr->action = cpu_to_le16(cmd_action);\n\tmcast_addr->num_of_adrs =\n\t\tcpu_to_le16((u16) mcast_list->num_multicast_addr);\n\tmemcpy(mcast_addr->mac_list, mcast_list->mac_list,\n\t       mcast_list->num_multicast_addr * ETH_ALEN);\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_cmd_802_11_deauthenticate(struct mwifiex_private *priv,\n\t\t\t\t\t     struct host_cmd_ds_command *cmd,\n\t\t\t\t\t     u8 *mac)\n{\n\tstruct host_cmd_ds_802_11_deauthenticate *deauth = &cmd->params.deauth;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_802_11_DEAUTHENTICATE);\n\tcmd->size = cpu_to_le16(sizeof(struct host_cmd_ds_802_11_deauthenticate)\n\t\t\t\t+ S_DS_GEN);\n\n\t \n\tmemcpy(deauth->mac_addr, mac, ETH_ALEN);\n\n\tmwifiex_dbg(priv->adapter, CMD, \"cmd: Deauth: %pM\\n\", deauth->mac_addr);\n\n\tdeauth->reason_code = cpu_to_le16(WLAN_REASON_DEAUTH_LEAVING);\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_cmd_802_11_ad_hoc_stop(struct host_cmd_ds_command *cmd)\n{\n\tcmd->command = cpu_to_le16(HostCmd_CMD_802_11_AD_HOC_STOP);\n\tcmd->size = cpu_to_le16(S_DS_GEN);\n\treturn 0;\n}\n\n \nstatic int\nmwifiex_set_keyparamset_wep(struct mwifiex_private *priv,\n\t\t\t    struct mwifiex_ie_type_key_param_set *key_param_set,\n\t\t\t    u16 *key_param_len)\n{\n\tint cur_key_param_len;\n\tu8 i;\n\n\t \n\tfor (i = 0; i < NUM_WEP_KEYS; i++) {\n\t\tif ((priv->wep_key[i].key_length == WLAN_KEY_LEN_WEP40) ||\n\t\t    (priv->wep_key[i].key_length == WLAN_KEY_LEN_WEP104)) {\n\t\t\tkey_param_set->type =\n\t\t\t\tcpu_to_le16(TLV_TYPE_KEY_MATERIAL);\n \n#define KEYPARAMSET_WEP_FIXED_LEN 8\n\t\t\tkey_param_set->length = cpu_to_le16((u16)\n\t\t\t\t\t(priv->wep_key[i].\n\t\t\t\t\t key_length +\n\t\t\t\t\t KEYPARAMSET_WEP_FIXED_LEN));\n\t\t\tkey_param_set->key_type_id =\n\t\t\t\tcpu_to_le16(KEY_TYPE_ID_WEP);\n\t\t\tkey_param_set->key_info =\n\t\t\t\tcpu_to_le16(KEY_ENABLED | KEY_UNICAST |\n\t\t\t\t\t    KEY_MCAST);\n\t\t\tkey_param_set->key_len =\n\t\t\t\tcpu_to_le16(priv->wep_key[i].key_length);\n\t\t\t \n\t\t\tkey_param_set->key[0] = i;\n\t\t\t \n\t\t\tif (i ==\n\t\t\t    (priv->\n\t\t\t     wep_key_curr_index & HostCmd_WEP_KEY_INDEX_MASK))\n\t\t\t\tkey_param_set->key[1] = 1;\n\t\t\telse\n\t\t\t\tkey_param_set->key[1] = 0;\n\t\t\tmemmove(&key_param_set->key[2],\n\t\t\t\tpriv->wep_key[i].key_material,\n\t\t\t\tpriv->wep_key[i].key_length);\n\n\t\t\tcur_key_param_len = priv->wep_key[i].key_length +\n\t\t\t\tKEYPARAMSET_WEP_FIXED_LEN +\n\t\t\t\tsizeof(struct mwifiex_ie_types_header);\n\t\t\t*key_param_len += (u16) cur_key_param_len;\n\t\t\tkey_param_set =\n\t\t\t\t(struct mwifiex_ie_type_key_param_set *)\n\t\t\t\t\t\t((u8 *)key_param_set +\n\t\t\t\t\t\t cur_key_param_len);\n\t\t} else if (!priv->wep_key[i].key_length) {\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t    \"key%d Length = %d is incorrect\\n\",\n\t\t\t\t    (i + 1), priv->wep_key[i].key_length);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_set_aes_key_v2(struct mwifiex_private *priv,\n\t\t\t\t  struct host_cmd_ds_command *cmd,\n\t\t\t\t  struct mwifiex_ds_encrypt_key *enc_key,\n\t\t\t\t  struct host_cmd_ds_802_11_key_material_v2 *km)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tu16 size, len = KEY_PARAMS_FIXED_LEN;\n\n\tif (enc_key->is_igtk_key) {\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"%s: Set CMAC AES Key\\n\", __func__);\n\t\tif (enc_key->is_rx_seq_valid)\n\t\t\tmemcpy(km->key_param_set.key_params.cmac_aes.ipn,\n\t\t\t       enc_key->pn, enc_key->pn_len);\n\t\tkm->key_param_set.key_info &= cpu_to_le16(~KEY_MCAST);\n\t\tkm->key_param_set.key_info |= cpu_to_le16(KEY_IGTK);\n\t\tkm->key_param_set.key_type = KEY_TYPE_ID_AES_CMAC;\n\t\tkm->key_param_set.key_params.cmac_aes.key_len =\n\t\t\t\t\t  cpu_to_le16(enc_key->key_len);\n\t\tmemcpy(km->key_param_set.key_params.cmac_aes.key,\n\t\t       enc_key->key_material, enc_key->key_len);\n\t\tlen += sizeof(struct mwifiex_cmac_aes_param);\n\t} else if (enc_key->is_igtk_def_key) {\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"%s: Set CMAC default Key index\\n\", __func__);\n\t\tkm->key_param_set.key_type = KEY_TYPE_ID_AES_CMAC_DEF;\n\t\tkm->key_param_set.key_idx = enc_key->key_index & KEY_INDEX_MASK;\n\t} else {\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"%s: Set AES Key\\n\", __func__);\n\t\tif (enc_key->is_rx_seq_valid)\n\t\t\tmemcpy(km->key_param_set.key_params.aes.pn,\n\t\t\t       enc_key->pn, enc_key->pn_len);\n\t\tkm->key_param_set.key_type = KEY_TYPE_ID_AES;\n\t\tkm->key_param_set.key_params.aes.key_len =\n\t\t\t\t\t  cpu_to_le16(enc_key->key_len);\n\t\tmemcpy(km->key_param_set.key_params.aes.key,\n\t\t       enc_key->key_material, enc_key->key_len);\n\t\tlen += sizeof(struct mwifiex_aes_param);\n\t}\n\n\tkm->key_param_set.len = cpu_to_le16(len);\n\tsize = len + sizeof(struct mwifiex_ie_types_header) +\n\t       sizeof(km->action) + S_DS_GEN;\n\tcmd->size = cpu_to_le16(size);\n\n\treturn 0;\n}\n\n \nstatic int\nmwifiex_cmd_802_11_key_material_v2(struct mwifiex_private *priv,\n\t\t\t\t   struct host_cmd_ds_command *cmd,\n\t\t\t\t   u16 cmd_action, u32 cmd_oid,\n\t\t\t\t   struct mwifiex_ds_encrypt_key *enc_key)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tu8 *mac = enc_key->mac_addr;\n\tu16 key_info, len = KEY_PARAMS_FIXED_LEN;\n\tstruct host_cmd_ds_802_11_key_material_v2 *km =\n\t\t\t\t\t\t&cmd->params.key_material_v2;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_802_11_KEY_MATERIAL);\n\tkm->action = cpu_to_le16(cmd_action);\n\n\tif (cmd_action == HostCmd_ACT_GEN_GET) {\n\t\tmwifiex_dbg(adapter, INFO, \"%s: Get key\\n\", __func__);\n\t\tkm->key_param_set.key_idx =\n\t\t\t\t\tenc_key->key_index & KEY_INDEX_MASK;\n\t\tkm->key_param_set.type = cpu_to_le16(TLV_TYPE_KEY_PARAM_V2);\n\t\tkm->key_param_set.len = cpu_to_le16(KEY_PARAMS_FIXED_LEN);\n\t\tmemcpy(km->key_param_set.mac_addr, mac, ETH_ALEN);\n\n\t\tif (enc_key->key_index & MWIFIEX_KEY_INDEX_UNICAST)\n\t\t\tkey_info = KEY_UNICAST;\n\t\telse\n\t\t\tkey_info = KEY_MCAST;\n\n\t\tif (enc_key->is_igtk_key)\n\t\t\tkey_info |= KEY_IGTK;\n\n\t\tkm->key_param_set.key_info = cpu_to_le16(key_info);\n\n\t\tcmd->size = cpu_to_le16(sizeof(struct mwifiex_ie_types_header) +\n\t\t\t\t\tS_DS_GEN + KEY_PARAMS_FIXED_LEN +\n\t\t\t\t\tsizeof(km->action));\n\t\treturn 0;\n\t}\n\n\tmemset(&km->key_param_set, 0,\n\t       sizeof(struct mwifiex_ie_type_key_param_set_v2));\n\n\tif (enc_key->key_disable) {\n\t\tmwifiex_dbg(adapter, INFO, \"%s: Remove key\\n\", __func__);\n\t\tkm->action = cpu_to_le16(HostCmd_ACT_GEN_REMOVE);\n\t\tkm->key_param_set.type = cpu_to_le16(TLV_TYPE_KEY_PARAM_V2);\n\t\tkm->key_param_set.len = cpu_to_le16(KEY_PARAMS_FIXED_LEN);\n\t\tkm->key_param_set.key_idx = enc_key->key_index & KEY_INDEX_MASK;\n\t\tkey_info = KEY_MCAST | KEY_UNICAST;\n\t\tkm->key_param_set.key_info = cpu_to_le16(key_info);\n\t\tmemcpy(km->key_param_set.mac_addr, mac, ETH_ALEN);\n\t\tcmd->size = cpu_to_le16(sizeof(struct mwifiex_ie_types_header) +\n\t\t\t\t\tS_DS_GEN + KEY_PARAMS_FIXED_LEN +\n\t\t\t\t\tsizeof(km->action));\n\t\treturn 0;\n\t}\n\n\tkm->action = cpu_to_le16(HostCmd_ACT_GEN_SET);\n\tkm->key_param_set.key_idx = enc_key->key_index & KEY_INDEX_MASK;\n\tkm->key_param_set.type = cpu_to_le16(TLV_TYPE_KEY_PARAM_V2);\n\tkey_info = KEY_ENABLED;\n\tmemcpy(km->key_param_set.mac_addr, mac, ETH_ALEN);\n\n\tif (enc_key->key_len <= WLAN_KEY_LEN_WEP104) {\n\t\tmwifiex_dbg(adapter, INFO, \"%s: Set WEP Key\\n\", __func__);\n\t\tlen += sizeof(struct mwifiex_wep_param);\n\t\tkm->key_param_set.len = cpu_to_le16(len);\n\t\tkm->key_param_set.key_type = KEY_TYPE_ID_WEP;\n\n\t\tif (GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) {\n\t\t\t\tkey_info |= KEY_MCAST | KEY_UNICAST;\n\t\t} else {\n\t\t\tif (enc_key->is_current_wep_key) {\n\t\t\t\tkey_info |= KEY_MCAST | KEY_UNICAST;\n\t\t\t\tif (km->key_param_set.key_idx ==\n\t\t\t\t    (priv->wep_key_curr_index & KEY_INDEX_MASK))\n\t\t\t\t\tkey_info |= KEY_DEFAULT;\n\t\t\t} else {\n\t\t\t\tif (is_broadcast_ether_addr(mac))\n\t\t\t\t\tkey_info |= KEY_MCAST;\n\t\t\t\telse\n\t\t\t\t\tkey_info |= KEY_UNICAST | KEY_DEFAULT;\n\t\t\t}\n\t\t}\n\t\tkm->key_param_set.key_info = cpu_to_le16(key_info);\n\n\t\tkm->key_param_set.key_params.wep.key_len =\n\t\t\t\t\t\t  cpu_to_le16(enc_key->key_len);\n\t\tmemcpy(km->key_param_set.key_params.wep.key,\n\t\t       enc_key->key_material, enc_key->key_len);\n\n\t\tcmd->size = cpu_to_le16(sizeof(struct mwifiex_ie_types_header) +\n\t\t\t\t\tlen + sizeof(km->action) + S_DS_GEN);\n\t\treturn 0;\n\t}\n\n\tif (is_broadcast_ether_addr(mac))\n\t\tkey_info |= KEY_MCAST | KEY_RX_KEY;\n\telse\n\t\tkey_info |= KEY_UNICAST | KEY_TX_KEY | KEY_RX_KEY;\n\n\tif (enc_key->is_wapi_key) {\n\t\tmwifiex_dbg(adapter, INFO, \"%s: Set WAPI Key\\n\", __func__);\n\t\tkm->key_param_set.key_type = KEY_TYPE_ID_WAPI;\n\t\tmemcpy(km->key_param_set.key_params.wapi.pn, enc_key->pn,\n\t\t       PN_LEN);\n\t\tkm->key_param_set.key_params.wapi.key_len =\n\t\t\t\t\t\tcpu_to_le16(enc_key->key_len);\n\t\tmemcpy(km->key_param_set.key_params.wapi.key,\n\t\t       enc_key->key_material, enc_key->key_len);\n\t\tif (is_broadcast_ether_addr(mac))\n\t\t\tpriv->sec_info.wapi_key_on = true;\n\n\t\tif (!priv->sec_info.wapi_key_on)\n\t\t\tkey_info |= KEY_DEFAULT;\n\t\tkm->key_param_set.key_info = cpu_to_le16(key_info);\n\n\t\tlen += sizeof(struct mwifiex_wapi_param);\n\t\tkm->key_param_set.len = cpu_to_le16(len);\n\t\tcmd->size = cpu_to_le16(sizeof(struct mwifiex_ie_types_header) +\n\t\t\t\t\tlen + sizeof(km->action) + S_DS_GEN);\n\t\treturn 0;\n\t}\n\n\tif (priv->bss_mode == NL80211_IFTYPE_ADHOC) {\n\t\tkey_info |= KEY_DEFAULT;\n\t\t \n\t\tif (!priv->sec_info.wpa2_enabled &&\n\t\t    !is_broadcast_ether_addr(mac))\n\t\t\tkey_info |= KEY_UNICAST;\n\t} else {\n\t\t \n\t\tif (!priv->wpa_is_gtk_set)\n\t\t\tkey_info |= KEY_DEFAULT;\n\t}\n\n\tkm->key_param_set.key_info = cpu_to_le16(key_info);\n\n\tif (enc_key->key_len == WLAN_KEY_LEN_CCMP)\n\t\treturn mwifiex_set_aes_key_v2(priv, cmd, enc_key, km);\n\n\tif (enc_key->key_len == WLAN_KEY_LEN_TKIP) {\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"%s: Set TKIP Key\\n\", __func__);\n\t\tif (enc_key->is_rx_seq_valid)\n\t\t\tmemcpy(km->key_param_set.key_params.tkip.pn,\n\t\t\t       enc_key->pn, enc_key->pn_len);\n\t\tkm->key_param_set.key_type = KEY_TYPE_ID_TKIP;\n\t\tkm->key_param_set.key_params.tkip.key_len =\n\t\t\t\t\t\tcpu_to_le16(enc_key->key_len);\n\t\tmemcpy(km->key_param_set.key_params.tkip.key,\n\t\t       enc_key->key_material, enc_key->key_len);\n\n\t\tlen += sizeof(struct mwifiex_tkip_param);\n\t\tkm->key_param_set.len = cpu_to_le16(len);\n\t\tcmd->size = cpu_to_le16(sizeof(struct mwifiex_ie_types_header) +\n\t\t\t\t\tlen + sizeof(km->action) + S_DS_GEN);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nmwifiex_cmd_802_11_key_material_v1(struct mwifiex_private *priv,\n\t\t\t\t   struct host_cmd_ds_command *cmd,\n\t\t\t\t   u16 cmd_action, u32 cmd_oid,\n\t\t\t\t   struct mwifiex_ds_encrypt_key *enc_key)\n{\n\tstruct host_cmd_ds_802_11_key_material *key_material =\n\t\t&cmd->params.key_material;\n\tstruct host_cmd_tlv_mac_addr *tlv_mac;\n\tu16 key_param_len = 0, cmd_size;\n\tint ret = 0;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_802_11_KEY_MATERIAL);\n\tkey_material->action = cpu_to_le16(cmd_action);\n\n\tif (cmd_action == HostCmd_ACT_GEN_GET) {\n\t\tcmd->size =\n\t\t\tcpu_to_le16(sizeof(key_material->action) + S_DS_GEN);\n\t\treturn ret;\n\t}\n\n\tif (!enc_key) {\n\t\tstruct host_cmd_ds_802_11_key_material_wep *key_material_wep =\n\t\t\t(struct host_cmd_ds_802_11_key_material_wep *)key_material;\n\t\tmemset(key_material_wep->key_param_set, 0,\n\t\t       sizeof(key_material_wep->key_param_set));\n\t\tret = mwifiex_set_keyparamset_wep(priv,\n\t\t\t\t\t\t  &key_material_wep->key_param_set[0],\n\t\t\t\t\t\t  &key_param_len);\n\t\tcmd->size = cpu_to_le16(key_param_len +\n\t\t\t\t    sizeof(key_material_wep->action) + S_DS_GEN);\n\t\treturn ret;\n\t} else\n\t\tmemset(&key_material->key_param_set, 0,\n\t\t       sizeof(struct mwifiex_ie_type_key_param_set));\n\tif (enc_key->is_wapi_key) {\n\t\tstruct mwifiex_ie_type_key_param_set *set;\n\n\t\tmwifiex_dbg(priv->adapter, INFO, \"info: Set WAPI Key\\n\");\n\t\tset = &key_material->key_param_set;\n\t\tset->key_type_id = cpu_to_le16(KEY_TYPE_ID_WAPI);\n\t\tif (cmd_oid == KEY_INFO_ENABLED)\n\t\t\tset->key_info = cpu_to_le16(KEY_ENABLED);\n\t\telse\n\t\t\tset->key_info = cpu_to_le16(!KEY_ENABLED);\n\n\t\tset->key[0] = enc_key->key_index;\n\t\tif (!priv->sec_info.wapi_key_on)\n\t\t\tset->key[1] = 1;\n\t\telse\n\t\t\t \n\t\t\tset->key[1] = 0;\n\n\t\tif (!is_broadcast_ether_addr(enc_key->mac_addr)) {\n\t\t\t \n\t\t\tset->key_info |= cpu_to_le16(KEY_UNICAST);\n\t\t} else {\t \n\t\t\tset->key_info |= cpu_to_le16(KEY_MCAST);\n\t\t\tpriv->sec_info.wapi_key_on = true;\n\t\t}\n\n\t\tset->type = cpu_to_le16(TLV_TYPE_KEY_MATERIAL);\n\t\tset->key_len = cpu_to_le16(WAPI_KEY_LEN);\n\t\tmemcpy(&set->key[2], enc_key->key_material, enc_key->key_len);\n\t\tmemcpy(&set->key[2 + enc_key->key_len], enc_key->pn, PN_LEN);\n\t\tset->length = cpu_to_le16(WAPI_KEY_LEN + KEYPARAMSET_FIXED_LEN);\n\n\t\tkey_param_len = (WAPI_KEY_LEN + KEYPARAMSET_FIXED_LEN) +\n\t\t\t\t sizeof(struct mwifiex_ie_types_header);\n\t\tcmd->size = cpu_to_le16(sizeof(key_material->action)\n\t\t\t\t\t+ S_DS_GEN +  key_param_len);\n\t\treturn ret;\n\t}\n\tif (enc_key->key_len == WLAN_KEY_LEN_CCMP) {\n\t\tif (enc_key->is_igtk_key) {\n\t\t\tmwifiex_dbg(priv->adapter, CMD, \"cmd: CMAC_AES\\n\");\n\t\t\tkey_material->key_param_set.key_type_id =\n\t\t\t\t\tcpu_to_le16(KEY_TYPE_ID_AES_CMAC);\n\t\t\tif (cmd_oid == KEY_INFO_ENABLED)\n\t\t\t\tkey_material->key_param_set.key_info =\n\t\t\t\t\t\tcpu_to_le16(KEY_ENABLED);\n\t\t\telse\n\t\t\t\tkey_material->key_param_set.key_info =\n\t\t\t\t\t\tcpu_to_le16(!KEY_ENABLED);\n\n\t\t\tkey_material->key_param_set.key_info |=\n\t\t\t\t\t\t\tcpu_to_le16(KEY_IGTK);\n\t\t} else {\n\t\t\tmwifiex_dbg(priv->adapter, CMD, \"cmd: WPA_AES\\n\");\n\t\t\tkey_material->key_param_set.key_type_id =\n\t\t\t\t\t\tcpu_to_le16(KEY_TYPE_ID_AES);\n\t\t\tif (cmd_oid == KEY_INFO_ENABLED)\n\t\t\t\tkey_material->key_param_set.key_info =\n\t\t\t\t\t\tcpu_to_le16(KEY_ENABLED);\n\t\t\telse\n\t\t\t\tkey_material->key_param_set.key_info =\n\t\t\t\t\t\tcpu_to_le16(!KEY_ENABLED);\n\n\t\t\tif (enc_key->key_index & MWIFIEX_KEY_INDEX_UNICAST)\n\t\t\t\t \n\t\t\t\tkey_material->key_param_set.key_info |=\n\t\t\t\t\t\tcpu_to_le16(KEY_UNICAST);\n\t\t\telse\t \n\t\t\t\tkey_material->key_param_set.key_info |=\n\t\t\t\t\t\t\tcpu_to_le16(KEY_MCAST);\n\t\t}\n\t} else if (enc_key->key_len == WLAN_KEY_LEN_TKIP) {\n\t\tmwifiex_dbg(priv->adapter, CMD, \"cmd: WPA_TKIP\\n\");\n\t\tkey_material->key_param_set.key_type_id =\n\t\t\t\t\t\tcpu_to_le16(KEY_TYPE_ID_TKIP);\n\t\tkey_material->key_param_set.key_info =\n\t\t\t\t\t\tcpu_to_le16(KEY_ENABLED);\n\n\t\tif (enc_key->key_index & MWIFIEX_KEY_INDEX_UNICAST)\n\t\t\t\t \n\t\t\tkey_material->key_param_set.key_info |=\n\t\t\t\t\t\tcpu_to_le16(KEY_UNICAST);\n\t\telse\t\t \n\t\t\tkey_material->key_param_set.key_info |=\n\t\t\t\t\t\t\tcpu_to_le16(KEY_MCAST);\n\t}\n\n\tif (key_material->key_param_set.key_type_id) {\n\t\tkey_material->key_param_set.type =\n\t\t\t\t\tcpu_to_le16(TLV_TYPE_KEY_MATERIAL);\n\t\tkey_material->key_param_set.key_len =\n\t\t\t\t\tcpu_to_le16((u16) enc_key->key_len);\n\t\tmemcpy(key_material->key_param_set.key, enc_key->key_material,\n\t\t       enc_key->key_len);\n\t\tkey_material->key_param_set.length =\n\t\t\tcpu_to_le16((u16) enc_key->key_len +\n\t\t\t\t    KEYPARAMSET_FIXED_LEN);\n\n\t\tkey_param_len = (u16)(enc_key->key_len + KEYPARAMSET_FIXED_LEN)\n\t\t\t\t+ sizeof(struct mwifiex_ie_types_header);\n\n\t\tif (le16_to_cpu(key_material->key_param_set.key_type_id) ==\n\t\t\t\t\t\t\tKEY_TYPE_ID_AES_CMAC) {\n\t\t\tstruct mwifiex_cmac_param *param =\n\t\t\t\t\t(void *)key_material->key_param_set.key;\n\n\t\t\tmemcpy(param->ipn, enc_key->pn, IGTK_PN_LEN);\n\t\t\tmemcpy(param->key, enc_key->key_material,\n\t\t\t       WLAN_KEY_LEN_AES_CMAC);\n\n\t\t\tkey_param_len = sizeof(struct mwifiex_cmac_param);\n\t\t\tkey_material->key_param_set.key_len =\n\t\t\t\t\t\tcpu_to_le16(key_param_len);\n\t\t\tkey_param_len += KEYPARAMSET_FIXED_LEN;\n\t\t\tkey_material->key_param_set.length =\n\t\t\t\t\t\tcpu_to_le16(key_param_len);\n\t\t\tkey_param_len += sizeof(struct mwifiex_ie_types_header);\n\t\t}\n\n\t\tcmd->size = cpu_to_le16(sizeof(key_material->action) + S_DS_GEN\n\t\t\t\t\t+ key_param_len);\n\n\t\tif (GET_BSS_ROLE(priv) == MWIFIEX_BSS_ROLE_UAP) {\n\t\t\ttlv_mac = (void *)((u8 *)&key_material->key_param_set +\n\t\t\t\t\t   key_param_len);\n\t\t\ttlv_mac->header.type =\n\t\t\t\t\tcpu_to_le16(TLV_TYPE_STA_MAC_ADDR);\n\t\t\ttlv_mac->header.len = cpu_to_le16(ETH_ALEN);\n\t\t\tmemcpy(tlv_mac->mac_addr, enc_key->mac_addr, ETH_ALEN);\n\t\t\tcmd_size = key_param_len + S_DS_GEN +\n\t\t\t\t   sizeof(key_material->action) +\n\t\t\t\t   sizeof(struct host_cmd_tlv_mac_addr);\n\t\t} else {\n\t\t\tcmd_size = key_param_len + S_DS_GEN +\n\t\t\t\t   sizeof(key_material->action);\n\t\t}\n\t\tcmd->size = cpu_to_le16(cmd_size);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int\nmwifiex_cmd_802_11_key_material(struct mwifiex_private *priv,\n\t\t\t\tstruct host_cmd_ds_command *cmd,\n\t\t\t\tu16 cmd_action, u32 cmd_oid,\n\t\t\t\tstruct mwifiex_ds_encrypt_key *enc_key)\n{\n\tif (priv->adapter->key_api_major_ver == KEY_API_VER_MAJOR_V2)\n\t\treturn mwifiex_cmd_802_11_key_material_v2(priv, cmd,\n\t\t\t\t\t\t\t  cmd_action, cmd_oid,\n\t\t\t\t\t\t\t  enc_key);\n\n\telse\n\t\treturn mwifiex_cmd_802_11_key_material_v1(priv, cmd,\n\t\t\t\t\t\t\t  cmd_action, cmd_oid,\n\t\t\t\t\t\t\t  enc_key);\n}\n\n \nstatic int mwifiex_cmd_802_11d_domain_info(struct mwifiex_private *priv,\n\t\t\t\t\t   struct host_cmd_ds_command *cmd,\n\t\t\t\t\t   u16 cmd_action)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct host_cmd_ds_802_11d_domain_info *domain_info =\n\t\t&cmd->params.domain_info;\n\tstruct mwifiex_ietypes_domain_param_set *domain =\n\t\t&domain_info->domain;\n\tu8 no_of_triplet = adapter->domain_reg.no_of_triplet;\n\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: 11D: no_of_triplet=0x%x\\n\", no_of_triplet);\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_802_11D_DOMAIN_INFO);\n\tdomain_info->action = cpu_to_le16(cmd_action);\n\tif (cmd_action == HostCmd_ACT_GEN_GET) {\n\t\tcmd->size = cpu_to_le16(sizeof(domain_info->action) + S_DS_GEN);\n\t\treturn 0;\n\t}\n\n\t \n\tdomain->header.type = cpu_to_le16(WLAN_EID_COUNTRY);\n\tmemcpy(domain->country_code, adapter->domain_reg.country_code,\n\t       sizeof(domain->country_code));\n\n\tdomain->header.len =\n\t\tcpu_to_le16((no_of_triplet *\n\t\t\t     sizeof(struct ieee80211_country_ie_triplet))\n\t\t\t    + sizeof(domain->country_code));\n\n\tif (no_of_triplet) {\n\t\tmemcpy(domain->triplet, adapter->domain_reg.triplet,\n\t\t       no_of_triplet * sizeof(struct\n\t\t\t\t\t      ieee80211_country_ie_triplet));\n\n\t\tcmd->size = cpu_to_le16(sizeof(domain_info->action) +\n\t\t\t\t\tle16_to_cpu(domain->header.len) +\n\t\t\t\t\tsizeof(struct mwifiex_ie_types_header)\n\t\t\t\t\t+ S_DS_GEN);\n\t} else {\n\t\tcmd->size = cpu_to_le16(sizeof(domain_info->action) + S_DS_GEN);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_cmd_ibss_coalescing_status(struct host_cmd_ds_command *cmd,\n\t\t\t\t\t      u16 cmd_action, u16 *enable)\n{\n\tstruct host_cmd_ds_802_11_ibss_status *ibss_coal =\n\t\t&(cmd->params.ibss_coalescing);\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_802_11_IBSS_COALESCING_STATUS);\n\tcmd->size = cpu_to_le16(sizeof(struct host_cmd_ds_802_11_ibss_status) +\n\t\t\t\tS_DS_GEN);\n\tcmd->result = 0;\n\tibss_coal->action = cpu_to_le16(cmd_action);\n\n\tswitch (cmd_action) {\n\tcase HostCmd_ACT_GEN_SET:\n\t\tif (enable)\n\t\t\tibss_coal->enable = cpu_to_le16(*enable);\n\t\telse\n\t\t\tibss_coal->enable = 0;\n\t\tbreak;\n\n\t\t \n\tcase HostCmd_ACT_GEN_GET:\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nmwifiex_cmd_mem_access(struct host_cmd_ds_command *cmd, u16 cmd_action,\n\t\t       void *pdata_buf)\n{\n\tstruct mwifiex_ds_mem_rw *mem_rw = (void *)pdata_buf;\n\tstruct host_cmd_ds_mem_access *mem_access = (void *)&cmd->params.mem;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_MEM_ACCESS);\n\tcmd->size = cpu_to_le16(sizeof(struct host_cmd_ds_mem_access) +\n\t\t\t\tS_DS_GEN);\n\n\tmem_access->action = cpu_to_le16(cmd_action);\n\tmem_access->addr = cpu_to_le32(mem_rw->addr);\n\tmem_access->value = cpu_to_le32(mem_rw->value);\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_cmd_reg_access(struct host_cmd_ds_command *cmd,\n\t\t\t\t  u16 cmd_action, void *data_buf)\n{\n\tstruct mwifiex_ds_reg_rw *reg_rw = data_buf;\n\n\tswitch (le16_to_cpu(cmd->command)) {\n\tcase HostCmd_CMD_MAC_REG_ACCESS:\n\t{\n\t\tstruct host_cmd_ds_mac_reg_access *mac_reg;\n\n\t\tcmd->size = cpu_to_le16(sizeof(*mac_reg) + S_DS_GEN);\n\t\tmac_reg = &cmd->params.mac_reg;\n\t\tmac_reg->action = cpu_to_le16(cmd_action);\n\t\tmac_reg->offset = cpu_to_le16((u16) reg_rw->offset);\n\t\tmac_reg->value = cpu_to_le32(reg_rw->value);\n\t\tbreak;\n\t}\n\tcase HostCmd_CMD_BBP_REG_ACCESS:\n\t{\n\t\tstruct host_cmd_ds_bbp_reg_access *bbp_reg;\n\n\t\tcmd->size = cpu_to_le16(sizeof(*bbp_reg) + S_DS_GEN);\n\t\tbbp_reg = &cmd->params.bbp_reg;\n\t\tbbp_reg->action = cpu_to_le16(cmd_action);\n\t\tbbp_reg->offset = cpu_to_le16((u16) reg_rw->offset);\n\t\tbbp_reg->value = (u8) reg_rw->value;\n\t\tbreak;\n\t}\n\tcase HostCmd_CMD_RF_REG_ACCESS:\n\t{\n\t\tstruct host_cmd_ds_rf_reg_access *rf_reg;\n\n\t\tcmd->size = cpu_to_le16(sizeof(*rf_reg) + S_DS_GEN);\n\t\trf_reg = &cmd->params.rf_reg;\n\t\trf_reg->action = cpu_to_le16(cmd_action);\n\t\trf_reg->offset = cpu_to_le16((u16) reg_rw->offset);\n\t\trf_reg->value = (u8) reg_rw->value;\n\t\tbreak;\n\t}\n\tcase HostCmd_CMD_PMIC_REG_ACCESS:\n\t{\n\t\tstruct host_cmd_ds_pmic_reg_access *pmic_reg;\n\n\t\tcmd->size = cpu_to_le16(sizeof(*pmic_reg) + S_DS_GEN);\n\t\tpmic_reg = &cmd->params.pmic_reg;\n\t\tpmic_reg->action = cpu_to_le16(cmd_action);\n\t\tpmic_reg->offset = cpu_to_le16((u16) reg_rw->offset);\n\t\tpmic_reg->value = (u8) reg_rw->value;\n\t\tbreak;\n\t}\n\tcase HostCmd_CMD_CAU_REG_ACCESS:\n\t{\n\t\tstruct host_cmd_ds_rf_reg_access *cau_reg;\n\n\t\tcmd->size = cpu_to_le16(sizeof(*cau_reg) + S_DS_GEN);\n\t\tcau_reg = &cmd->params.rf_reg;\n\t\tcau_reg->action = cpu_to_le16(cmd_action);\n\t\tcau_reg->offset = cpu_to_le16((u16) reg_rw->offset);\n\t\tcau_reg->value = (u8) reg_rw->value;\n\t\tbreak;\n\t}\n\tcase HostCmd_CMD_802_11_EEPROM_ACCESS:\n\t{\n\t\tstruct mwifiex_ds_read_eeprom *rd_eeprom = data_buf;\n\t\tstruct host_cmd_ds_802_11_eeprom_access *cmd_eeprom =\n\t\t\t&cmd->params.eeprom;\n\n\t\tcmd->size = cpu_to_le16(sizeof(*cmd_eeprom) + S_DS_GEN);\n\t\tcmd_eeprom->action = cpu_to_le16(cmd_action);\n\t\tcmd_eeprom->offset = cpu_to_le16(rd_eeprom->offset);\n\t\tcmd_eeprom->byte_count = cpu_to_le16(rd_eeprom->byte_count);\n\t\tcmd_eeprom->value = 0;\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nmwifiex_cmd_pcie_host_spec(struct mwifiex_private *priv,\n\t\t\t   struct host_cmd_ds_command *cmd, u16 action)\n{\n\tstruct host_cmd_ds_pcie_details *host_spec =\n\t\t\t\t\t&cmd->params.pcie_host_spec;\n\tstruct pcie_service_card *card = priv->adapter->card;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_PCIE_DESC_DETAILS);\n\tcmd->size = cpu_to_le16(sizeof(struct\n\t\t\t\t\thost_cmd_ds_pcie_details) + S_DS_GEN);\n\tcmd->result = 0;\n\n\tmemset(host_spec, 0, sizeof(struct host_cmd_ds_pcie_details));\n\n\tif (action != HostCmd_ACT_GEN_SET)\n\t\treturn 0;\n\n\t \n\thost_spec->txbd_addr_lo = cpu_to_le32((u32)(card->txbd_ring_pbase));\n\thost_spec->txbd_addr_hi =\n\t\t\tcpu_to_le32((u32)(((u64)card->txbd_ring_pbase) >> 32));\n\thost_spec->txbd_count = cpu_to_le32(MWIFIEX_MAX_TXRX_BD);\n\thost_spec->rxbd_addr_lo = cpu_to_le32((u32)(card->rxbd_ring_pbase));\n\thost_spec->rxbd_addr_hi =\n\t\t\tcpu_to_le32((u32)(((u64)card->rxbd_ring_pbase) >> 32));\n\thost_spec->rxbd_count = cpu_to_le32(MWIFIEX_MAX_TXRX_BD);\n\thost_spec->evtbd_addr_lo = cpu_to_le32((u32)(card->evtbd_ring_pbase));\n\thost_spec->evtbd_addr_hi =\n\t\t\tcpu_to_le32((u32)(((u64)card->evtbd_ring_pbase) >> 32));\n\thost_spec->evtbd_count = cpu_to_le32(MWIFIEX_MAX_EVT_BD);\n\tif (card->sleep_cookie_vbase) {\n\t\thost_spec->sleep_cookie_addr_lo =\n\t\t\t\tcpu_to_le32((u32)(card->sleep_cookie_pbase));\n\t\thost_spec->sleep_cookie_addr_hi = cpu_to_le32((u32)(((u64)\n\t\t\t\t\t(card->sleep_cookie_pbase)) >> 32));\n\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t    \"sleep_cook_lo phy addr: 0x%x\\n\",\n\t\t\t    host_spec->sleep_cookie_addr_lo);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int\nmwifiex_cmd_802_11_subsc_evt(struct mwifiex_private *priv,\n\t\t\t     struct host_cmd_ds_command *cmd,\n\t\t\t     struct mwifiex_ds_misc_subsc_evt *subsc_evt_cfg)\n{\n\tstruct host_cmd_ds_802_11_subsc_evt *subsc_evt = &cmd->params.subsc_evt;\n\tstruct mwifiex_ie_types_rssi_threshold *rssi_tlv;\n\tu16 event_bitmap;\n\tu8 *pos;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_802_11_SUBSCRIBE_EVENT);\n\tcmd->size = cpu_to_le16(sizeof(struct host_cmd_ds_802_11_subsc_evt) +\n\t\t\t\tS_DS_GEN);\n\n\tsubsc_evt->action = cpu_to_le16(subsc_evt_cfg->action);\n\tmwifiex_dbg(priv->adapter, CMD,\n\t\t    \"cmd: action: %d\\n\", subsc_evt_cfg->action);\n\n\t \n\tif (subsc_evt_cfg->action == HostCmd_ACT_GEN_GET)\n\t\treturn 0;\n\n\tsubsc_evt->events = cpu_to_le16(subsc_evt_cfg->events);\n\n\tevent_bitmap = subsc_evt_cfg->events;\n\tmwifiex_dbg(priv->adapter, CMD, \"cmd: event bitmap : %16x\\n\",\n\t\t    event_bitmap);\n\n\tif (((subsc_evt_cfg->action == HostCmd_ACT_BITWISE_CLR) ||\n\t     (subsc_evt_cfg->action == HostCmd_ACT_BITWISE_SET)) &&\n\t    (event_bitmap == 0)) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"Error: No event specified\\t\"\n\t\t\t    \"for bitwise action type\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (subsc_evt_cfg->action == HostCmd_ACT_BITWISE_CLR)\n\t\treturn 0;\n\n\tpos = ((u8 *)subsc_evt) +\n\t\t\tsizeof(struct host_cmd_ds_802_11_subsc_evt);\n\n\tif (event_bitmap & BITMASK_BCN_RSSI_LOW) {\n\t\trssi_tlv = (struct mwifiex_ie_types_rssi_threshold *) pos;\n\n\t\trssi_tlv->header.type = cpu_to_le16(TLV_TYPE_RSSI_LOW);\n\t\trssi_tlv->header.len =\n\t\t    cpu_to_le16(sizeof(struct mwifiex_ie_types_rssi_threshold) -\n\t\t\t\tsizeof(struct mwifiex_ie_types_header));\n\t\trssi_tlv->abs_value = subsc_evt_cfg->bcn_l_rssi_cfg.abs_value;\n\t\trssi_tlv->evt_freq = subsc_evt_cfg->bcn_l_rssi_cfg.evt_freq;\n\n\t\tmwifiex_dbg(priv->adapter, EVENT,\n\t\t\t    \"Cfg Beacon Low Rssi event,\\t\"\n\t\t\t    \"RSSI:-%d dBm, Freq:%d\\n\",\n\t\t\t    subsc_evt_cfg->bcn_l_rssi_cfg.abs_value,\n\t\t\t    subsc_evt_cfg->bcn_l_rssi_cfg.evt_freq);\n\n\t\tpos += sizeof(struct mwifiex_ie_types_rssi_threshold);\n\t\tle16_unaligned_add_cpu(&cmd->size,\n\t\t\t\t       sizeof(\n\t\t\t\t       struct mwifiex_ie_types_rssi_threshold));\n\t}\n\n\tif (event_bitmap & BITMASK_BCN_RSSI_HIGH) {\n\t\trssi_tlv = (struct mwifiex_ie_types_rssi_threshold *) pos;\n\n\t\trssi_tlv->header.type = cpu_to_le16(TLV_TYPE_RSSI_HIGH);\n\t\trssi_tlv->header.len =\n\t\t    cpu_to_le16(sizeof(struct mwifiex_ie_types_rssi_threshold) -\n\t\t\t\tsizeof(struct mwifiex_ie_types_header));\n\t\trssi_tlv->abs_value = subsc_evt_cfg->bcn_h_rssi_cfg.abs_value;\n\t\trssi_tlv->evt_freq = subsc_evt_cfg->bcn_h_rssi_cfg.evt_freq;\n\n\t\tmwifiex_dbg(priv->adapter, EVENT,\n\t\t\t    \"Cfg Beacon High Rssi event,\\t\"\n\t\t\t    \"RSSI:-%d dBm, Freq:%d\\n\",\n\t\t\t    subsc_evt_cfg->bcn_h_rssi_cfg.abs_value,\n\t\t\t    subsc_evt_cfg->bcn_h_rssi_cfg.evt_freq);\n\n\t\tpos += sizeof(struct mwifiex_ie_types_rssi_threshold);\n\t\tle16_unaligned_add_cpu(&cmd->size,\n\t\t\t\t       sizeof(\n\t\t\t\t       struct mwifiex_ie_types_rssi_threshold));\n\t}\n\n\treturn 0;\n}\n\nstatic int\nmwifiex_cmd_append_rpn_expression(struct mwifiex_private *priv,\n\t\t\t\t  struct mwifiex_mef_entry *mef_entry,\n\t\t\t\t  u8 **buffer)\n{\n\tstruct mwifiex_mef_filter *filter = mef_entry->filter;\n\tint i, byte_len;\n\tu8 *stack_ptr = *buffer;\n\n\tfor (i = 0; i < MWIFIEX_MEF_MAX_FILTERS; i++) {\n\t\tfilter = &mef_entry->filter[i];\n\t\tif (!filter->filt_type)\n\t\t\tbreak;\n\t\tput_unaligned_le32((u32)filter->repeat, stack_ptr);\n\t\tstack_ptr += 4;\n\t\t*stack_ptr = TYPE_DNUM;\n\t\tstack_ptr += 1;\n\n\t\tbyte_len = filter->byte_seq[MWIFIEX_MEF_MAX_BYTESEQ];\n\t\tmemcpy(stack_ptr, filter->byte_seq, byte_len);\n\t\tstack_ptr += byte_len;\n\t\t*stack_ptr = byte_len;\n\t\tstack_ptr += 1;\n\t\t*stack_ptr = TYPE_BYTESEQ;\n\t\tstack_ptr += 1;\n\t\tput_unaligned_le32((u32)filter->offset, stack_ptr);\n\t\tstack_ptr += 4;\n\t\t*stack_ptr = TYPE_DNUM;\n\t\tstack_ptr += 1;\n\n\t\t*stack_ptr = filter->filt_type;\n\t\tstack_ptr += 1;\n\n\t\tif (filter->filt_action) {\n\t\t\t*stack_ptr = filter->filt_action;\n\t\t\tstack_ptr += 1;\n\t\t}\n\n\t\tif (stack_ptr - *buffer > STACK_NBYTES)\n\t\t\treturn -1;\n\t}\n\n\t*buffer = stack_ptr;\n\treturn 0;\n}\n\nstatic int\nmwifiex_cmd_mef_cfg(struct mwifiex_private *priv,\n\t\t    struct host_cmd_ds_command *cmd,\n\t\t    struct mwifiex_ds_mef_cfg *mef)\n{\n\tstruct host_cmd_ds_mef_cfg *mef_cfg = &cmd->params.mef_cfg;\n\tstruct mwifiex_fw_mef_entry *mef_entry = NULL;\n\tu8 *pos = (u8 *)mef_cfg;\n\tu16 i;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_MEF_CFG);\n\n\tmef_cfg->criteria = cpu_to_le32(mef->criteria);\n\tmef_cfg->num_entries = cpu_to_le16(mef->num_entries);\n\tpos += sizeof(*mef_cfg);\n\n\tfor (i = 0; i < mef->num_entries; i++) {\n\t\tmef_entry = (struct mwifiex_fw_mef_entry *)pos;\n\t\tmef_entry->mode = mef->mef_entry[i].mode;\n\t\tmef_entry->action = mef->mef_entry[i].action;\n\t\tpos += sizeof(*mef_entry);\n\n\t\tif (mwifiex_cmd_append_rpn_expression(priv,\n\t\t\t\t\t\t      &mef->mef_entry[i], &pos))\n\t\t\treturn -1;\n\n\t\tmef_entry->exprsize =\n\t\t\tcpu_to_le16(pos - mef_entry->expr);\n\t}\n\tcmd->size = cpu_to_le16((u16) (pos - (u8 *)mef_cfg) + S_DS_GEN);\n\n\treturn 0;\n}\n\n \nstatic u32 mwifiex_parse_cal_cfg(u8 *src, size_t len, u8 *dst)\n{\n\tu8 *s = src, *d = dst;\n\n\twhile (s - src < len) {\n\t\tif (*s && (isspace(*s) || *s == '\\t')) {\n\t\t\ts++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (isxdigit(*s)) {\n\t\t\t*d++ = simple_strtol(s, NULL, 16);\n\t\t\ts += 2;\n\t\t} else {\n\t\t\ts++;\n\t\t}\n\t}\n\n\treturn d - dst;\n}\n\nint mwifiex_dnld_dt_cfgdata(struct mwifiex_private *priv,\n\t\t\t    struct device_node *node, const char *prefix)\n{\n#ifdef CONFIG_OF\n\tstruct property *prop;\n\tsize_t len = strlen(prefix);\n\tint ret;\n\n\t \n\tfor_each_property_of_node(node, prop) {\n\t\tif (len > strlen(prop->name) ||\n\t\t    strncmp(prop->name, prefix, len))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (prop->value && prop->length > 6 &&\n\t\t    prop->length <= MWIFIEX_SIZE_OF_CMD_BUFFER - S_DS_GEN) {\n\t\t\tret = mwifiex_send_cmd(priv, HostCmd_CMD_CFG_DATA,\n\t\t\t\t\t       HostCmd_ACT_GEN_SET, 0,\n\t\t\t\t\t       prop, true);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n#endif\n\treturn 0;\n}\n\n \nstatic int mwifiex_cmd_cfg_data(struct mwifiex_private *priv,\n\t\t\t\tstruct host_cmd_ds_command *cmd, void *data_buf)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct property *prop = data_buf;\n\tu32 len;\n\tu8 *data = (u8 *)cmd + S_DS_GEN;\n\tint ret;\n\n\tif (prop) {\n\t\tlen = prop->length;\n\t\tret = of_property_read_u8_array(adapter->dt_node, prop->name,\n\t\t\t\t\t\tdata, len);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"download cfg_data from device tree: %s\\n\",\n\t\t\t    prop->name);\n\t} else if (adapter->cal_data->data && adapter->cal_data->size > 0) {\n\t\tlen = mwifiex_parse_cal_cfg((u8 *)adapter->cal_data->data,\n\t\t\t\t\t    adapter->cal_data->size, data);\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"download cfg_data from config file\\n\");\n\t} else {\n\t\treturn -1;\n\t}\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_CFG_DATA);\n\tcmd->size = cpu_to_le16(S_DS_GEN + len);\n\n\treturn 0;\n}\n\nstatic int\nmwifiex_cmd_set_mc_policy(struct mwifiex_private *priv,\n\t\t\t  struct host_cmd_ds_command *cmd,\n\t\t\t  u16 cmd_action, void *data_buf)\n{\n\tstruct host_cmd_ds_multi_chan_policy *mc_pol = &cmd->params.mc_policy;\n\tconst u16 *drcs_info = data_buf;\n\n\tmc_pol->action = cpu_to_le16(cmd_action);\n\tmc_pol->policy = cpu_to_le16(*drcs_info);\n\tcmd->command = cpu_to_le16(HostCmd_CMD_MC_POLICY);\n\tcmd->size = cpu_to_le16(sizeof(struct host_cmd_ds_multi_chan_policy) +\n\t\t\t\tS_DS_GEN);\n\treturn 0;\n}\n\nstatic int mwifiex_cmd_robust_coex(struct mwifiex_private *priv,\n\t\t\t\t   struct host_cmd_ds_command *cmd,\n\t\t\t\t   u16 cmd_action, bool *is_timeshare)\n{\n\tstruct host_cmd_ds_robust_coex *coex = &cmd->params.coex;\n\tstruct mwifiex_ie_types_robust_coex *coex_tlv;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_ROBUST_COEX);\n\tcmd->size = cpu_to_le16(sizeof(*coex) + sizeof(*coex_tlv) + S_DS_GEN);\n\n\tcoex->action = cpu_to_le16(cmd_action);\n\tcoex_tlv = (struct mwifiex_ie_types_robust_coex *)\n\t\t\t\t((u8 *)coex + sizeof(*coex));\n\tcoex_tlv->header.type = cpu_to_le16(TLV_TYPE_ROBUST_COEX);\n\tcoex_tlv->header.len = cpu_to_le16(sizeof(coex_tlv->mode));\n\n\tif (coex->action == HostCmd_ACT_GEN_GET)\n\t\treturn 0;\n\n\tif (*is_timeshare)\n\t\tcoex_tlv->mode = cpu_to_le32(MWIFIEX_COEX_MODE_TIMESHARE);\n\telse\n\t\tcoex_tlv->mode = cpu_to_le32(MWIFIEX_COEX_MODE_SPATIAL);\n\n\treturn 0;\n}\n\nstatic int mwifiex_cmd_gtk_rekey_offload(struct mwifiex_private *priv,\n\t\t\t\t\t struct host_cmd_ds_command *cmd,\n\t\t\t\t\t u16 cmd_action,\n\t\t\t\t\t struct cfg80211_gtk_rekey_data *data)\n{\n\tstruct host_cmd_ds_gtk_rekey_params *rekey = &cmd->params.rekey;\n\tu64 rekey_ctr;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_GTK_REKEY_OFFLOAD_CFG);\n\tcmd->size = cpu_to_le16(sizeof(*rekey) + S_DS_GEN);\n\n\trekey->action = cpu_to_le16(cmd_action);\n\tif (cmd_action == HostCmd_ACT_GEN_SET) {\n\t\tmemcpy(rekey->kek, data->kek, NL80211_KEK_LEN);\n\t\tmemcpy(rekey->kck, data->kck, NL80211_KCK_LEN);\n\t\trekey_ctr = be64_to_cpup((__be64 *)data->replay_ctr);\n\t\trekey->replay_ctr_low = cpu_to_le32((u32)rekey_ctr);\n\t\trekey->replay_ctr_high =\n\t\t\tcpu_to_le32((u32)((u64)rekey_ctr >> 32));\n\t}\n\n\treturn 0;\n}\n\nstatic int mwifiex_cmd_chan_region_cfg(struct mwifiex_private *priv,\n\t\t\t\t       struct host_cmd_ds_command *cmd,\n\t\t\t\t       u16 cmd_action)\n{\n\tstruct host_cmd_ds_chan_region_cfg *reg = &cmd->params.reg_cfg;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_CHAN_REGION_CFG);\n\tcmd->size = cpu_to_le16(sizeof(*reg) + S_DS_GEN);\n\n\tif (cmd_action == HostCmd_ACT_GEN_GET)\n\t\treg->action = cpu_to_le16(cmd_action);\n\n\treturn 0;\n}\n\nstatic int\nmwifiex_cmd_coalesce_cfg(struct mwifiex_private *priv,\n\t\t\t struct host_cmd_ds_command *cmd,\n\t\t\t u16 cmd_action, void *data_buf)\n{\n\tstruct host_cmd_ds_coalesce_cfg *coalesce_cfg =\n\t\t\t\t\t\t&cmd->params.coalesce_cfg;\n\tstruct mwifiex_ds_coalesce_cfg *cfg = data_buf;\n\tstruct coalesce_filt_field_param *param;\n\tu16 cnt, idx, length;\n\tstruct coalesce_receive_filt_rule *rule;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_COALESCE_CFG);\n\tcmd->size = cpu_to_le16(S_DS_GEN);\n\n\tcoalesce_cfg->action = cpu_to_le16(cmd_action);\n\tcoalesce_cfg->num_of_rules = cpu_to_le16(cfg->num_of_rules);\n\trule = (void *)coalesce_cfg->rule_data;\n\n\tfor (cnt = 0; cnt < cfg->num_of_rules; cnt++) {\n\t\trule->header.type = cpu_to_le16(TLV_TYPE_COALESCE_RULE);\n\t\trule->max_coalescing_delay =\n\t\t\tcpu_to_le16(cfg->rule[cnt].max_coalescing_delay);\n\t\trule->pkt_type = cfg->rule[cnt].pkt_type;\n\t\trule->num_of_fields = cfg->rule[cnt].num_of_fields;\n\n\t\tlength = 0;\n\n\t\tparam = rule->params;\n\t\tfor (idx = 0; idx < cfg->rule[cnt].num_of_fields; idx++) {\n\t\t\tparam->operation = cfg->rule[cnt].params[idx].operation;\n\t\t\tparam->operand_len =\n\t\t\t\t\tcfg->rule[cnt].params[idx].operand_len;\n\t\t\tparam->offset =\n\t\t\t\tcpu_to_le16(cfg->rule[cnt].params[idx].offset);\n\t\t\tmemcpy(param->operand_byte_stream,\n\t\t\t       cfg->rule[cnt].params[idx].operand_byte_stream,\n\t\t\t       param->operand_len);\n\n\t\t\tlength += sizeof(struct coalesce_filt_field_param);\n\n\t\t\tparam++;\n\t\t}\n\n\t\t \n\t\trule->header.len = cpu_to_le16(length + sizeof(u16) +\n\t\t\t\t\t       sizeof(u8) + sizeof(u8));\n\n\t\t \n\t\tle16_unaligned_add_cpu(&cmd->size,\n\t\t\t\t       le16_to_cpu(rule->header.len) +\n\t\t\t\t       sizeof(struct mwifiex_ie_types_header));\n\n\t\trule = (void *)((u8 *)rule->params + length);\n\t}\n\n\t \n\tle16_unaligned_add_cpu(&cmd->size, sizeof(u16) + sizeof(u16));\n\n\treturn 0;\n}\n\nstatic int\nmwifiex_cmd_tdls_config(struct mwifiex_private *priv,\n\t\t\tstruct host_cmd_ds_command *cmd,\n\t\t\tu16 cmd_action, void *data_buf)\n{\n\tstruct host_cmd_ds_tdls_config *tdls_config = &cmd->params.tdls_config;\n\tstruct mwifiex_tdls_init_cs_params *config;\n\tstruct mwifiex_tdls_config *init_config;\n\tu16 len;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_TDLS_CONFIG);\n\tcmd->size = cpu_to_le16(S_DS_GEN);\n\ttdls_config->tdls_action = cpu_to_le16(cmd_action);\n\tle16_unaligned_add_cpu(&cmd->size, sizeof(tdls_config->tdls_action));\n\n\tswitch (cmd_action) {\n\tcase ACT_TDLS_CS_ENABLE_CONFIG:\n\t\tinit_config = data_buf;\n\t\tlen = sizeof(*init_config);\n\t\tmemcpy(tdls_config->tdls_data, init_config, len);\n\t\tbreak;\n\tcase ACT_TDLS_CS_INIT:\n\t\tconfig = data_buf;\n\t\tlen = sizeof(*config);\n\t\tmemcpy(tdls_config->tdls_data, config, len);\n\t\tbreak;\n\tcase ACT_TDLS_CS_STOP:\n\t\tlen = sizeof(struct mwifiex_tdls_stop_cs_params);\n\t\tmemcpy(tdls_config->tdls_data, data_buf, len);\n\t\tbreak;\n\tcase ACT_TDLS_CS_PARAMS:\n\t\tlen = sizeof(struct mwifiex_tdls_config_cs_params);\n\t\tmemcpy(tdls_config->tdls_data, data_buf, len);\n\t\tbreak;\n\tdefault:\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"Unknown TDLS configuration\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tle16_unaligned_add_cpu(&cmd->size, len);\n\treturn 0;\n}\n\nstatic int\nmwifiex_cmd_tdls_oper(struct mwifiex_private *priv,\n\t\t      struct host_cmd_ds_command *cmd,\n\t\t      void *data_buf)\n{\n\tstruct host_cmd_ds_tdls_oper *tdls_oper = &cmd->params.tdls_oper;\n\tstruct mwifiex_ds_tdls_oper *oper = data_buf;\n\tstruct host_cmd_tlv_rates *tlv_rates;\n\tstruct mwifiex_ie_types_htcap *ht_capab;\n\tstruct mwifiex_ie_types_qos_info *wmm_qos_info;\n\tstruct mwifiex_ie_types_extcap *extcap;\n\tstruct mwifiex_ie_types_vhtcap *vht_capab;\n\tstruct mwifiex_ie_types_aid *aid;\n\tstruct mwifiex_ie_types_tdls_idle_timeout *timeout;\n\tu8 *pos;\n\tu16 config_len = 0;\n\tstruct station_parameters *params = priv->sta_params;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_TDLS_OPER);\n\tcmd->size = cpu_to_le16(S_DS_GEN);\n\tle16_unaligned_add_cpu(&cmd->size,\n\t\t\t       sizeof(struct host_cmd_ds_tdls_oper));\n\n\ttdls_oper->reason = 0;\n\tmemcpy(tdls_oper->peer_mac, oper->peer_mac, ETH_ALEN);\n\n\tpos = (u8 *)tdls_oper + sizeof(struct host_cmd_ds_tdls_oper);\n\n\tswitch (oper->tdls_action) {\n\tcase MWIFIEX_TDLS_DISABLE_LINK:\n\t\ttdls_oper->tdls_action = cpu_to_le16(ACT_TDLS_DELETE);\n\t\tbreak;\n\tcase MWIFIEX_TDLS_CREATE_LINK:\n\t\ttdls_oper->tdls_action = cpu_to_le16(ACT_TDLS_CREATE);\n\t\tbreak;\n\tcase MWIFIEX_TDLS_CONFIG_LINK:\n\t\ttdls_oper->tdls_action = cpu_to_le16(ACT_TDLS_CONFIG);\n\n\t\tif (!params) {\n\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t    \"TDLS config params not available for %pM\\n\",\n\t\t\t\t    oper->peer_mac);\n\t\t\treturn -ENODATA;\n\t\t}\n\n\t\tput_unaligned_le16(params->capability, pos);\n\t\tconfig_len += sizeof(params->capability);\n\n\t\twmm_qos_info = (void *)(pos + config_len);\n\t\twmm_qos_info->header.type = cpu_to_le16(WLAN_EID_QOS_CAPA);\n\t\twmm_qos_info->header.len =\n\t\t\t\tcpu_to_le16(sizeof(wmm_qos_info->qos_info));\n\t\twmm_qos_info->qos_info = 0;\n\t\tconfig_len += sizeof(struct mwifiex_ie_types_qos_info);\n\n\t\tif (params->link_sta_params.ht_capa) {\n\t\t\tht_capab = (struct mwifiex_ie_types_htcap *)(pos +\n\t\t\t\t\t\t\t\t    config_len);\n\t\t\tht_capab->header.type =\n\t\t\t\t\t    cpu_to_le16(WLAN_EID_HT_CAPABILITY);\n\t\t\tht_capab->header.len =\n\t\t\t\t   cpu_to_le16(sizeof(struct ieee80211_ht_cap));\n\t\t\tmemcpy(&ht_capab->ht_cap, params->link_sta_params.ht_capa,\n\t\t\t       sizeof(struct ieee80211_ht_cap));\n\t\t\tconfig_len += sizeof(struct mwifiex_ie_types_htcap);\n\t\t}\n\n\t\tif (params->link_sta_params.supported_rates &&\n\t\t    params->link_sta_params.supported_rates_len) {\n\t\t\ttlv_rates = (struct host_cmd_tlv_rates *)(pos +\n\t\t\t\t\t\t\t\t  config_len);\n\t\t\ttlv_rates->header.type =\n\t\t\t\t\t       cpu_to_le16(WLAN_EID_SUPP_RATES);\n\t\t\ttlv_rates->header.len =\n\t\t\t\t       cpu_to_le16(params->link_sta_params.supported_rates_len);\n\t\t\tmemcpy(tlv_rates->rates,\n\t\t\t       params->link_sta_params.supported_rates,\n\t\t\t       params->link_sta_params.supported_rates_len);\n\t\t\tconfig_len += sizeof(struct host_cmd_tlv_rates) +\n\t\t\t\t      params->link_sta_params.supported_rates_len;\n\t\t}\n\n\t\tif (params->ext_capab && params->ext_capab_len) {\n\t\t\textcap = (struct mwifiex_ie_types_extcap *)(pos +\n\t\t\t\t\t\t\t\t    config_len);\n\t\t\textcap->header.type =\n\t\t\t\t\t   cpu_to_le16(WLAN_EID_EXT_CAPABILITY);\n\t\t\textcap->header.len = cpu_to_le16(params->ext_capab_len);\n\t\t\tmemcpy(extcap->ext_capab, params->ext_capab,\n\t\t\t       params->ext_capab_len);\n\t\t\tconfig_len += sizeof(struct mwifiex_ie_types_extcap) +\n\t\t\t\t      params->ext_capab_len;\n\t\t}\n\t\tif (params->link_sta_params.vht_capa) {\n\t\t\tvht_capab = (struct mwifiex_ie_types_vhtcap *)(pos +\n\t\t\t\t\t\t\t\t    config_len);\n\t\t\tvht_capab->header.type =\n\t\t\t\t\t   cpu_to_le16(WLAN_EID_VHT_CAPABILITY);\n\t\t\tvht_capab->header.len =\n\t\t\t\t  cpu_to_le16(sizeof(struct ieee80211_vht_cap));\n\t\t\tmemcpy(&vht_capab->vht_cap, params->link_sta_params.vht_capa,\n\t\t\t       sizeof(struct ieee80211_vht_cap));\n\t\t\tconfig_len += sizeof(struct mwifiex_ie_types_vhtcap);\n\t\t}\n\t\tif (params->aid) {\n\t\t\taid = (struct mwifiex_ie_types_aid *)(pos + config_len);\n\t\t\taid->header.type = cpu_to_le16(WLAN_EID_AID);\n\t\t\taid->header.len = cpu_to_le16(sizeof(params->aid));\n\t\t\taid->aid = cpu_to_le16(params->aid);\n\t\t\tconfig_len += sizeof(struct mwifiex_ie_types_aid);\n\t\t}\n\n\t\ttimeout = (void *)(pos + config_len);\n\t\ttimeout->header.type = cpu_to_le16(TLV_TYPE_TDLS_IDLE_TIMEOUT);\n\t\ttimeout->header.len = cpu_to_le16(sizeof(timeout->value));\n\t\ttimeout->value = cpu_to_le16(MWIFIEX_TDLS_IDLE_TIMEOUT_IN_SEC);\n\t\tconfig_len += sizeof(struct mwifiex_ie_types_tdls_idle_timeout);\n\n\t\tbreak;\n\tdefault:\n\t\tmwifiex_dbg(priv->adapter, ERROR, \"Unknown TDLS operation\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tle16_unaligned_add_cpu(&cmd->size, config_len);\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_cmd_sdio_rx_aggr_cfg(struct host_cmd_ds_command *cmd,\n\t\t\t\t\tu16 cmd_action, void *data_buf)\n{\n\tstruct host_cmd_sdio_sp_rx_aggr_cfg *cfg =\n\t\t\t\t\t&cmd->params.sdio_rx_aggr_cfg;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_SDIO_SP_RX_AGGR_CFG);\n\tcmd->size =\n\t\tcpu_to_le16(sizeof(struct host_cmd_sdio_sp_rx_aggr_cfg) +\n\t\t\t    S_DS_GEN);\n\tcfg->action = cmd_action;\n\tif (cmd_action == HostCmd_ACT_GEN_SET)\n\t\tcfg->enable = *(u8 *)data_buf;\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_cmd_get_wakeup_reason(struct mwifiex_private *priv,\n\t\t\t\t\t struct host_cmd_ds_command *cmd)\n{\n\tcmd->command = cpu_to_le16(HostCmd_CMD_HS_WAKEUP_REASON);\n\tcmd->size = cpu_to_le16(sizeof(struct host_cmd_ds_wakeup_reason) +\n\t\t\t\tS_DS_GEN);\n\n\treturn 0;\n}\n\nstatic int mwifiex_cmd_get_chan_info(struct host_cmd_ds_command *cmd,\n\t\t\t\t     u16 cmd_action)\n{\n\tstruct host_cmd_ds_sta_configure *sta_cfg_cmd = &cmd->params.sta_cfg;\n\tstruct host_cmd_tlv_channel_band *tlv_band_channel =\n\t(struct host_cmd_tlv_channel_band *)sta_cfg_cmd->tlv_buffer;\n\n\tcmd->command = cpu_to_le16(HostCmd_CMD_STA_CONFIGURE);\n\tcmd->size = cpu_to_le16(sizeof(*sta_cfg_cmd) +\n\t\t\t\tsizeof(*tlv_band_channel) + S_DS_GEN);\n\tsta_cfg_cmd->action = cpu_to_le16(cmd_action);\n\tmemset(tlv_band_channel, 0, sizeof(*tlv_band_channel));\n\ttlv_band_channel->header.type = cpu_to_le16(TLV_TYPE_CHANNELBANDLIST);\n\ttlv_band_channel->header.len  = cpu_to_le16(sizeof(*tlv_band_channel) -\n\t\t\t\t\tsizeof(struct mwifiex_ie_types_header));\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_is_cmd_supported(struct mwifiex_private *priv, u16 cmd_no)\n{\n\tif (!ISSUPP_ADHOC_ENABLED(priv->adapter->fw_cap_info)) {\n\t\tswitch (cmd_no) {\n\t\tcase HostCmd_CMD_802_11_IBSS_COALESCING_STATUS:\n\t\tcase HostCmd_CMD_802_11_AD_HOC_START:\n\t\tcase HostCmd_CMD_802_11_AD_HOC_JOIN:\n\t\tcase HostCmd_CMD_802_11_AD_HOC_STOP:\n\t\t\treturn -EOPNOTSUPP;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nint mwifiex_sta_prepare_cmd(struct mwifiex_private *priv, uint16_t cmd_no,\n\t\t\t    u16 cmd_action, u32 cmd_oid,\n\t\t\t    void *data_buf, void *cmd_buf)\n{\n\tstruct host_cmd_ds_command *cmd_ptr = cmd_buf;\n\tint ret = 0;\n\n\tif (mwifiex_is_cmd_supported(priv, cmd_no)) {\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"0x%x command not supported by firmware\\n\",\n\t\t\t    cmd_no);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tswitch (cmd_no) {\n\tcase HostCmd_CMD_GET_HW_SPEC:\n\t\tret = mwifiex_cmd_get_hw_spec(priv, cmd_ptr);\n\t\tbreak;\n\tcase HostCmd_CMD_CFG_DATA:\n\t\tret = mwifiex_cmd_cfg_data(priv, cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_MAC_CONTROL:\n\t\tret = mwifiex_cmd_mac_control(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t      data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_MAC_ADDRESS:\n\t\tret = mwifiex_cmd_802_11_mac_address(priv, cmd_ptr,\n\t\t\t\t\t\t     cmd_action);\n\t\tbreak;\n\tcase HostCmd_CMD_MAC_MULTICAST_ADR:\n\t\tret = mwifiex_cmd_mac_multicast_adr(cmd_ptr, cmd_action,\n\t\t\t\t\t\t    data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_TX_RATE_CFG:\n\t\tret = mwifiex_cmd_tx_rate_cfg(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t      data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_TXPWR_CFG:\n\t\tret = mwifiex_cmd_tx_power_cfg(cmd_ptr, cmd_action,\n\t\t\t\t\t       data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_RF_TX_PWR:\n\t\tret = mwifiex_cmd_rf_tx_power(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t      data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_RF_ANTENNA:\n\t\tret = mwifiex_cmd_rf_antenna(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t     data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_PS_MODE_ENH:\n\t\tret = mwifiex_cmd_enh_power_mode(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t\t (uint16_t)cmd_oid, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_HS_CFG_ENH:\n\t\tret = mwifiex_cmd_802_11_hs_cfg(priv, cmd_ptr, cmd_action,\n\t\t\t\t(struct mwifiex_hs_config_param *) data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_SCAN:\n\t\tret = mwifiex_cmd_802_11_scan(cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_BG_SCAN_CONFIG:\n\t\tret = mwifiex_cmd_802_11_bg_scan_config(priv, cmd_ptr,\n\t\t\t\t\t\t\tdata_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_BG_SCAN_QUERY:\n\t\tret = mwifiex_cmd_802_11_bg_scan_query(cmd_ptr);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_ASSOCIATE:\n\t\tret = mwifiex_cmd_802_11_associate(priv, cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_DEAUTHENTICATE:\n\t\tret = mwifiex_cmd_802_11_deauthenticate(priv, cmd_ptr,\n\t\t\t\t\t\t\tdata_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_AD_HOC_START:\n\t\tret = mwifiex_cmd_802_11_ad_hoc_start(priv, cmd_ptr,\n\t\t\t\t\t\t      data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_GET_LOG:\n\t\tret = mwifiex_cmd_802_11_get_log(cmd_ptr);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_AD_HOC_JOIN:\n\t\tret = mwifiex_cmd_802_11_ad_hoc_join(priv, cmd_ptr,\n\t\t\t\t\t\t     data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_AD_HOC_STOP:\n\t\tret = mwifiex_cmd_802_11_ad_hoc_stop(cmd_ptr);\n\t\tbreak;\n\tcase HostCmd_CMD_RSSI_INFO:\n\t\tret = mwifiex_cmd_802_11_rssi_info(priv, cmd_ptr, cmd_action);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_SNMP_MIB:\n\t\tret = mwifiex_cmd_802_11_snmp_mib(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t\t  cmd_oid, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_TX_RATE_QUERY:\n\t\tcmd_ptr->command =\n\t\t\tcpu_to_le16(HostCmd_CMD_802_11_TX_RATE_QUERY);\n\t\tcmd_ptr->size =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_ds_tx_rate_query) +\n\t\t\t\t    S_DS_GEN);\n\t\tpriv->tx_rate = 0;\n\t\tret = 0;\n\t\tbreak;\n\tcase HostCmd_CMD_VERSION_EXT:\n\t\tcmd_ptr->command = cpu_to_le16(cmd_no);\n\t\tcmd_ptr->params.verext.version_str_sel =\n\t\t\t(u8)(get_unaligned((u32 *)data_buf));\n\t\tmemcpy(&cmd_ptr->params, data_buf,\n\t\t       sizeof(struct host_cmd_ds_version_ext));\n\t\tcmd_ptr->size =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_ds_version_ext) +\n\t\t\t\t    S_DS_GEN);\n\t\tret = 0;\n\t\tbreak;\n\tcase HostCmd_CMD_MGMT_FRAME_REG:\n\t\tcmd_ptr->command = cpu_to_le16(cmd_no);\n\t\tcmd_ptr->params.reg_mask.action = cpu_to_le16(cmd_action);\n\t\tcmd_ptr->params.reg_mask.mask = cpu_to_le32(\n\t\t\t\t\t\tget_unaligned((u32 *)data_buf));\n\t\tcmd_ptr->size =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_ds_mgmt_frame_reg) +\n\t\t\t\t    S_DS_GEN);\n\t\tret = 0;\n\t\tbreak;\n\tcase HostCmd_CMD_REMAIN_ON_CHAN:\n\t\tcmd_ptr->command = cpu_to_le16(cmd_no);\n\t\tmemcpy(&cmd_ptr->params, data_buf,\n\t\t       sizeof(struct host_cmd_ds_remain_on_chan));\n\t\tcmd_ptr->size =\n\t\t      cpu_to_le16(sizeof(struct host_cmd_ds_remain_on_chan) +\n\t\t\t\t  S_DS_GEN);\n\t\tbreak;\n\tcase HostCmd_CMD_11AC_CFG:\n\t\tret = mwifiex_cmd_11ac_cfg(priv, cmd_ptr, cmd_action, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_PACKET_AGGR_CTRL:\n\t\tcmd_ptr->command = cpu_to_le16(cmd_no);\n\t\tcmd_ptr->params.pkt_aggr_ctrl.action = cpu_to_le16(cmd_action);\n\t\tcmd_ptr->params.pkt_aggr_ctrl.enable =\n\t\t\t\t\t\tcpu_to_le16(*(u16 *)data_buf);\n\t\tcmd_ptr->size =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_ds_pkt_aggr_ctrl) +\n\t\t\t\t    S_DS_GEN);\n\t\tbreak;\n\tcase HostCmd_CMD_P2P_MODE_CFG:\n\t\tcmd_ptr->command = cpu_to_le16(cmd_no);\n\t\tcmd_ptr->params.mode_cfg.action = cpu_to_le16(cmd_action);\n\t\tcmd_ptr->params.mode_cfg.mode = cpu_to_le16(\n\t\t\t\t\t\tget_unaligned((u16 *)data_buf));\n\t\tcmd_ptr->size =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_ds_p2p_mode_cfg) +\n\t\t\t\t    S_DS_GEN);\n\t\tbreak;\n\tcase HostCmd_CMD_FUNC_INIT:\n\t\tif (priv->adapter->hw_status == MWIFIEX_HW_STATUS_RESET)\n\t\t\tpriv->adapter->hw_status = MWIFIEX_HW_STATUS_READY;\n\t\tcmd_ptr->command = cpu_to_le16(cmd_no);\n\t\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\n\t\tbreak;\n\tcase HostCmd_CMD_FUNC_SHUTDOWN:\n\t\tpriv->adapter->hw_status = MWIFIEX_HW_STATUS_RESET;\n\t\tcmd_ptr->command = cpu_to_le16(cmd_no);\n\t\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\n\t\tbreak;\n\tcase HostCmd_CMD_11N_ADDBA_REQ:\n\t\tret = mwifiex_cmd_11n_addba_req(cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_11N_DELBA:\n\t\tret = mwifiex_cmd_11n_delba(cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_11N_ADDBA_RSP:\n\t\tret = mwifiex_cmd_11n_addba_rsp_gen(priv, cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_KEY_MATERIAL:\n\t\tret = mwifiex_cmd_802_11_key_material(priv, cmd_ptr,\n\t\t\t\t\t\t      cmd_action, cmd_oid,\n\t\t\t\t\t\t      data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11D_DOMAIN_INFO:\n\t\tret = mwifiex_cmd_802_11d_domain_info(priv, cmd_ptr,\n\t\t\t\t\t\t      cmd_action);\n\t\tbreak;\n\tcase HostCmd_CMD_RECONFIGURE_TX_BUFF:\n\t\tret = mwifiex_cmd_recfg_tx_buf(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t       data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_AMSDU_AGGR_CTRL:\n\t\tret = mwifiex_cmd_amsdu_aggr_ctrl(cmd_ptr, cmd_action,\n\t\t\t\t\t\t  data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_11N_CFG:\n\t\tret = mwifiex_cmd_11n_cfg(priv, cmd_ptr, cmd_action, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_WMM_GET_STATUS:\n\t\tmwifiex_dbg(priv->adapter, CMD,\n\t\t\t    \"cmd: WMM: WMM_GET_STATUS cmd sent\\n\");\n\t\tcmd_ptr->command = cpu_to_le16(HostCmd_CMD_WMM_GET_STATUS);\n\t\tcmd_ptr->size =\n\t\t\tcpu_to_le16(sizeof(struct host_cmd_ds_wmm_get_status) +\n\t\t\t\t    S_DS_GEN);\n\t\tret = 0;\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_IBSS_COALESCING_STATUS:\n\t\tret = mwifiex_cmd_ibss_coalescing_status(cmd_ptr, cmd_action,\n\t\t\t\t\t\t\t data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_SCAN_EXT:\n\t\tret = mwifiex_cmd_802_11_scan_ext(priv, cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_MEM_ACCESS:\n\t\tret = mwifiex_cmd_mem_access(cmd_ptr, cmd_action, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_MAC_REG_ACCESS:\n\tcase HostCmd_CMD_BBP_REG_ACCESS:\n\tcase HostCmd_CMD_RF_REG_ACCESS:\n\tcase HostCmd_CMD_PMIC_REG_ACCESS:\n\tcase HostCmd_CMD_CAU_REG_ACCESS:\n\tcase HostCmd_CMD_802_11_EEPROM_ACCESS:\n\t\tret = mwifiex_cmd_reg_access(cmd_ptr, cmd_action, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_SET_BSS_MODE:\n\t\tcmd_ptr->command = cpu_to_le16(cmd_no);\n\t\tif (priv->bss_mode == NL80211_IFTYPE_ADHOC)\n\t\t\tcmd_ptr->params.bss_mode.con_type =\n\t\t\t\tCONNECTION_TYPE_ADHOC;\n\t\telse if (priv->bss_mode == NL80211_IFTYPE_STATION ||\n\t\t\t priv->bss_mode == NL80211_IFTYPE_P2P_CLIENT)\n\t\t\tcmd_ptr->params.bss_mode.con_type =\n\t\t\t\tCONNECTION_TYPE_INFRA;\n\t\telse if (priv->bss_mode == NL80211_IFTYPE_AP ||\n\t\t\t priv->bss_mode == NL80211_IFTYPE_P2P_GO)\n\t\t\tcmd_ptr->params.bss_mode.con_type = CONNECTION_TYPE_AP;\n\t\tcmd_ptr->size = cpu_to_le16(sizeof(struct\n\t\t\t\thost_cmd_ds_set_bss_mode) + S_DS_GEN);\n\t\tret = 0;\n\t\tbreak;\n\tcase HostCmd_CMD_PCIE_DESC_DETAILS:\n\t\tret = mwifiex_cmd_pcie_host_spec(priv, cmd_ptr, cmd_action);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_SUBSCRIBE_EVENT:\n\t\tret = mwifiex_cmd_802_11_subsc_evt(priv, cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_MEF_CFG:\n\t\tret = mwifiex_cmd_mef_cfg(priv, cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_COALESCE_CFG:\n\t\tret = mwifiex_cmd_coalesce_cfg(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t       data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_TDLS_OPER:\n\t\tret = mwifiex_cmd_tdls_oper(priv, cmd_ptr, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_TDLS_CONFIG:\n\t\tret = mwifiex_cmd_tdls_config(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t      data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_CHAN_REPORT_REQUEST:\n\t\tret = mwifiex_cmd_issue_chan_report_request(priv, cmd_ptr,\n\t\t\t\t\t\t\t    data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_SDIO_SP_RX_AGGR_CFG:\n\t\tret = mwifiex_cmd_sdio_rx_aggr_cfg(cmd_ptr, cmd_action,\n\t\t\t\t\t\t   data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_HS_WAKEUP_REASON:\n\t\tret = mwifiex_cmd_get_wakeup_reason(priv, cmd_ptr);\n\t\tbreak;\n\tcase HostCmd_CMD_MC_POLICY:\n\t\tret = mwifiex_cmd_set_mc_policy(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t\tdata_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_ROBUST_COEX:\n\t\tret = mwifiex_cmd_robust_coex(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t      data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_GTK_REKEY_OFFLOAD_CFG:\n\t\tret = mwifiex_cmd_gtk_rekey_offload(priv, cmd_ptr, cmd_action,\n\t\t\t\t\t\t    data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_CHAN_REGION_CFG:\n\t\tret = mwifiex_cmd_chan_region_cfg(priv, cmd_ptr, cmd_action);\n\t\tbreak;\n\tcase HostCmd_CMD_FW_DUMP_EVENT:\n\t\tcmd_ptr->command = cpu_to_le16(cmd_no);\n\t\tcmd_ptr->size = cpu_to_le16(S_DS_GEN);\n\t\tbreak;\n\tcase HostCmd_CMD_STA_CONFIGURE:\n\t\tret = mwifiex_cmd_get_chan_info(cmd_ptr, cmd_action);\n\t\tbreak;\n\tdefault:\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"PREP_CMD: unknown cmd- %#x\\n\", cmd_no);\n\t\tret = -1;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\n \nint mwifiex_sta_init_cmd(struct mwifiex_private *priv, u8 first_sta, bool init)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tint ret;\n\tstruct mwifiex_ds_11n_amsdu_aggr_ctrl amsdu_aggr_ctrl;\n\tstruct mwifiex_ds_auto_ds auto_ds;\n\tenum state_11d_t state_11d;\n\tstruct mwifiex_ds_11n_tx_cfg tx_cfg;\n\tu8 sdio_sp_rx_aggr_enable;\n\tu16 packet_aggr_enable;\n\tint data;\n\n\tif (first_sta) {\n\t\tif (priv->adapter->iface_type == MWIFIEX_PCIE) {\n\t\t\tret = mwifiex_send_cmd(priv,\n\t\t\t\t\t       HostCmd_CMD_PCIE_DESC_DETAILS,\n\t\t\t\t\t       HostCmd_ACT_GEN_SET, 0, NULL,\n\t\t\t\t\t       true);\n\t\t\tif (ret)\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tret = mwifiex_send_cmd(priv, HostCmd_CMD_FUNC_INIT,\n\t\t\t\t       HostCmd_ACT_GEN_SET, 0, NULL, true);\n\t\tif (ret)\n\t\t\treturn -1;\n\n\t\t \n\t\tif (adapter->dt_node) {\n\t\t\tif (of_property_read_u32(adapter->dt_node,\n\t\t\t\t\t\t \"marvell,wakeup-pin\",\n\t\t\t\t\t\t &data) == 0) {\n\t\t\t\tpr_debug(\"Wakeup pin = 0x%x\\n\", data);\n\t\t\t\tadapter->hs_cfg.gpio = data;\n\t\t\t}\n\n\t\t\tmwifiex_dnld_dt_cfgdata(priv, adapter->dt_node,\n\t\t\t\t\t\t\"marvell,caldata\");\n\t\t}\n\n\t\tif (adapter->cal_data)\n\t\t\tmwifiex_send_cmd(priv, HostCmd_CMD_CFG_DATA,\n\t\t\t\t\t HostCmd_ACT_GEN_SET, 0, NULL, true);\n\n\t\t \n\t\tret = mwifiex_send_cmd(priv, HostCmd_CMD_GET_HW_SPEC,\n\t\t\t\t       HostCmd_ACT_GEN_GET, 0, NULL, true);\n\t\tif (ret)\n\t\t\treturn -1;\n\n\t\t \n\t\tif (priv->adapter->iface_type == MWIFIEX_SDIO &&\n\t\t    ISSUPP_SDIO_SPA_ENABLED(priv->adapter->fw_cap_info) &&\n\t\t    !priv->adapter->host_disable_sdio_rx_aggr) {\n\t\t\tsdio_sp_rx_aggr_enable = true;\n\t\t\tret = mwifiex_send_cmd(priv,\n\t\t\t\t\t       HostCmd_CMD_SDIO_SP_RX_AGGR_CFG,\n\t\t\t\t\t       HostCmd_ACT_GEN_SET, 0,\n\t\t\t\t\t       &sdio_sp_rx_aggr_enable,\n\t\t\t\t\t       true);\n\t\t\tif (ret) {\n\t\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t\t    \"error while enabling SP aggregation..disable it\");\n\t\t\t\tadapter->sdio_rx_aggr_enable = false;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tret = mwifiex_send_cmd(priv, HostCmd_CMD_RECONFIGURE_TX_BUFF,\n\t\t\t\t       HostCmd_ACT_GEN_SET, 0,\n\t\t\t\t       &priv->adapter->tx_buf_size, true);\n\t\tif (ret)\n\t\t\treturn -1;\n\n\t\tif (priv->bss_type != MWIFIEX_BSS_TYPE_UAP) {\n\t\t\t \n\t\t\tpriv->adapter->ps_mode = MWIFIEX_802_11_POWER_MODE_PSP;\n\t\t\tret = mwifiex_send_cmd(priv,\n\t\t\t\t\t       HostCmd_CMD_802_11_PS_MODE_ENH,\n\t\t\t\t\t       EN_AUTO_PS, BITMAP_STA_PS, NULL,\n\t\t\t\t\t       true);\n\t\t\tif (ret)\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tif (drcs) {\n\t\t\tadapter->drcs_enabled = true;\n\t\t\tif (ISSUPP_DRCS_ENABLED(adapter->fw_cap_info))\n\t\t\t\tret = mwifiex_send_cmd(priv,\n\t\t\t\t\t\t       HostCmd_CMD_MC_POLICY,\n\t\t\t\t\t\t       HostCmd_ACT_GEN_SET, 0,\n\t\t\t\t\t\t       &adapter->drcs_enabled,\n\t\t\t\t\t\t       true);\n\t\t\tif (ret)\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tmwifiex_send_cmd(priv, HostCmd_CMD_CHAN_REGION_CFG,\n\t\t\t\t HostCmd_ACT_GEN_GET, 0, NULL, true);\n\t}\n\n\t \n\tret = mwifiex_send_cmd(priv, HostCmd_CMD_TX_RATE_CFG,\n\t\t\t       HostCmd_ACT_GEN_GET, 0, NULL, true);\n\tif (ret)\n\t\treturn -1;\n\tpriv->data_rate = 0;\n\n\t \n\tret = mwifiex_send_cmd(priv, HostCmd_CMD_RF_TX_PWR,\n\t\t\t       HostCmd_ACT_GEN_GET, 0, NULL, true);\n\tif (ret)\n\t\treturn -1;\n\n\tmemset(&amsdu_aggr_ctrl, 0, sizeof(amsdu_aggr_ctrl));\n\tamsdu_aggr_ctrl.enable = true;\n\t \n\tret = mwifiex_send_cmd(priv, HostCmd_CMD_AMSDU_AGGR_CTRL,\n\t\t\t       HostCmd_ACT_GEN_SET, 0,\n\t\t\t       &amsdu_aggr_ctrl, true);\n\tif (ret)\n\t\treturn -1;\n\t \n\t \n\tret = mwifiex_send_cmd(priv, HostCmd_CMD_MAC_CONTROL,\n\t\t\t       HostCmd_ACT_GEN_SET, 0,\n\t\t\t       &priv->curr_pkt_filter, true);\n\tif (ret)\n\t\treturn -1;\n\n\tif (!disable_auto_ds && first_sta &&\n\t    priv->bss_type != MWIFIEX_BSS_TYPE_UAP) {\n\t\t \n\t\tauto_ds.auto_ds = DEEP_SLEEP_ON;\n\t\tauto_ds.idle_time = DEEP_SLEEP_IDLE_TIME;\n\t\tret = mwifiex_send_cmd(priv, HostCmd_CMD_802_11_PS_MODE_ENH,\n\t\t\t\t       EN_AUTO_PS, BITMAP_AUTO_DS,\n\t\t\t\t       &auto_ds, true);\n\t\tif (ret)\n\t\t\treturn -1;\n\t}\n\n\tif (priv->bss_type != MWIFIEX_BSS_TYPE_UAP) {\n\t\t \n\t\tstate_11d = ENABLE_11D;\n\t\tret = mwifiex_send_cmd(priv, HostCmd_CMD_802_11_SNMP_MIB,\n\t\t\t\t       HostCmd_ACT_GEN_SET, DOT11D_I,\n\t\t\t\t       &state_11d, true);\n\t\tif (ret)\n\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t    \"11D: failed to enable 11D\\n\");\n\t}\n\n\t \n\tif (aggr_ctrl) {\n\t\tpacket_aggr_enable = true;\n\t\tmwifiex_send_cmd(priv, HostCmd_CMD_PACKET_AGGR_CTRL,\n\t\t\t\t HostCmd_ACT_GEN_SET, 0,\n\t\t\t\t &packet_aggr_enable, true);\n\t}\n\n\t \n\ttx_cfg.tx_htcap = MWIFIEX_FW_DEF_HTTXCFG;\n\tret = mwifiex_send_cmd(priv, HostCmd_CMD_11N_CFG,\n\t\t\t       HostCmd_ACT_GEN_SET, 0, &tx_cfg, true);\n\n\tif (init) {\n\t\t \n\t\tpriv->adapter->last_init_cmd = HostCmd_CMD_11N_CFG;\n\t\tret = -EINPROGRESS;\n\t}\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}