{
  "module_name": "sta_cmdresp.c",
  "hash_id": "0861fff1ec00db803e56c553b521a0fffd20d7135982a6e88263c8f90f6d6abe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/net/wireless/marvell/mwifiex/sta_cmdresp.c",
  "human_readable_source": "\n \n\n#include \"decl.h\"\n#include \"ioctl.h\"\n#include \"util.h\"\n#include \"fw.h\"\n#include \"main.h\"\n#include \"wmm.h\"\n#include \"11n.h\"\n#include \"11ac.h\"\n\n\n \nstatic void\nmwifiex_process_cmdresp_error(struct mwifiex_private *priv,\n\t\t\t      struct host_cmd_ds_command *resp)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct host_cmd_ds_802_11_ps_mode_enh *pm;\n\n\tmwifiex_dbg(adapter, ERROR,\n\t\t    \"CMD_RESP: cmd %#x error, result=%#x\\n\",\n\t\t    resp->command, resp->result);\n\n\tif (adapter->curr_cmd->wait_q_enabled)\n\t\tadapter->cmd_wait_q.status = -1;\n\n\tswitch (le16_to_cpu(resp->command)) {\n\tcase HostCmd_CMD_802_11_PS_MODE_ENH:\n\t\tpm = &resp->params.psmode_enh;\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"PS_MODE_ENH cmd failed: result=0x%x action=0x%X\\n\",\n\t\t\t    resp->result, le16_to_cpu(pm->action));\n\t\t \n\t\tif (le16_to_cpu(pm->action) == EN_AUTO_PS &&\n\t\t    (le16_to_cpu(pm->params.ps_bitmap) & BITMAP_STA_PS) &&\n\t\t    priv->bss_mode == NL80211_IFTYPE_ADHOC)\n\t\t\tadapter->ps_mode = MWIFIEX_802_11_POWER_MODE_CAM;\n\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_SCAN:\n\tcase HostCmd_CMD_802_11_SCAN_EXT:\n\t\tmwifiex_cancel_scan(adapter);\n\t\tbreak;\n\n\tcase HostCmd_CMD_MAC_CONTROL:\n\t\tbreak;\n\n\tcase HostCmd_CMD_SDIO_SP_RX_AGGR_CFG:\n\t\tmwifiex_dbg(adapter, MSG,\n\t\t\t    \"SDIO RX single-port aggregation Not support\\n\");\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\t \n\tmwifiex_recycle_cmd_node(adapter, adapter->curr_cmd);\n\n\tspin_lock_bh(&adapter->mwifiex_cmd_lock);\n\tadapter->curr_cmd = NULL;\n\tspin_unlock_bh(&adapter->mwifiex_cmd_lock);\n}\n\n \nstatic int mwifiex_ret_802_11_rssi_info(struct mwifiex_private *priv,\n\t\t\t\t\tstruct host_cmd_ds_command *resp)\n{\n\tstruct host_cmd_ds_802_11_rssi_info_rsp *rssi_info_rsp =\n\t\t\t\t\t\t&resp->params.rssi_info_rsp;\n\tstruct mwifiex_ds_misc_subsc_evt *subsc_evt =\n\t\t\t\t\t\t&priv->async_subsc_evt_storage;\n\n\tpriv->data_rssi_last = le16_to_cpu(rssi_info_rsp->data_rssi_last);\n\tpriv->data_nf_last = le16_to_cpu(rssi_info_rsp->data_nf_last);\n\n\tpriv->data_rssi_avg = le16_to_cpu(rssi_info_rsp->data_rssi_avg);\n\tpriv->data_nf_avg = le16_to_cpu(rssi_info_rsp->data_nf_avg);\n\n\tpriv->bcn_rssi_last = le16_to_cpu(rssi_info_rsp->bcn_rssi_last);\n\tpriv->bcn_nf_last = le16_to_cpu(rssi_info_rsp->bcn_nf_last);\n\n\tpriv->bcn_rssi_avg = le16_to_cpu(rssi_info_rsp->bcn_rssi_avg);\n\tpriv->bcn_nf_avg = le16_to_cpu(rssi_info_rsp->bcn_nf_avg);\n\n\tif (priv->subsc_evt_rssi_state == EVENT_HANDLED)\n\t\treturn 0;\n\n\tmemset(subsc_evt, 0x00, sizeof(struct mwifiex_ds_misc_subsc_evt));\n\n\t \n\tsubsc_evt->events = BITMASK_BCN_RSSI_LOW | BITMASK_BCN_RSSI_HIGH;\n\tsubsc_evt->action = HostCmd_ACT_BITWISE_SET;\n\tif (priv->subsc_evt_rssi_state == RSSI_LOW_RECVD) {\n\t\tsubsc_evt->bcn_l_rssi_cfg.abs_value = abs(priv->bcn_rssi_avg -\n\t\t\t\tpriv->cqm_rssi_hyst);\n\t\tsubsc_evt->bcn_h_rssi_cfg.abs_value = abs(priv->cqm_rssi_thold);\n\t} else if (priv->subsc_evt_rssi_state == RSSI_HIGH_RECVD) {\n\t\tsubsc_evt->bcn_l_rssi_cfg.abs_value = abs(priv->cqm_rssi_thold);\n\t\tsubsc_evt->bcn_h_rssi_cfg.abs_value = abs(priv->bcn_rssi_avg +\n\t\t\t\tpriv->cqm_rssi_hyst);\n\t}\n\tsubsc_evt->bcn_l_rssi_cfg.evt_freq = 1;\n\tsubsc_evt->bcn_h_rssi_cfg.evt_freq = 1;\n\n\tpriv->subsc_evt_rssi_state = EVENT_HANDLED;\n\n\tmwifiex_send_cmd(priv, HostCmd_CMD_802_11_SUBSCRIBE_EVENT,\n\t\t\t 0, 0, subsc_evt, false);\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_ret_802_11_snmp_mib(struct mwifiex_private *priv,\n\t\t\t\t       struct host_cmd_ds_command *resp,\n\t\t\t\t       u32 *data_buf)\n{\n\tstruct host_cmd_ds_802_11_snmp_mib *smib = &resp->params.smib;\n\tu16 oid = le16_to_cpu(smib->oid);\n\tu16 query_type = le16_to_cpu(smib->query_type);\n\tu32 ul_temp;\n\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: SNMP_RESP: oid value = %#x,\\t\"\n\t\t    \"query_type = %#x, buf size = %#x\\n\",\n\t\t    oid, query_type, le16_to_cpu(smib->buf_size));\n\tif (query_type == HostCmd_ACT_GEN_GET) {\n\t\tul_temp = get_unaligned_le16(smib->value);\n\t\tif (data_buf)\n\t\t\t*data_buf = ul_temp;\n\t\tswitch (oid) {\n\t\tcase FRAG_THRESH_I:\n\t\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t\t    \"info: SNMP_RESP: FragThsd =%u\\n\",\n\t\t\t\t    ul_temp);\n\t\t\tbreak;\n\t\tcase RTS_THRESH_I:\n\t\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t\t    \"info: SNMP_RESP: RTSThsd =%u\\n\",\n\t\t\t\t    ul_temp);\n\t\t\tbreak;\n\t\tcase SHORT_RETRY_LIM_I:\n\t\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t\t    \"info: SNMP_RESP: TxRetryCount=%u\\n\",\n\t\t\t\t    ul_temp);\n\t\t\tbreak;\n\t\tcase DTIM_PERIOD_I:\n\t\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t\t    \"info: SNMP_RESP: DTIM period=%u\\n\",\n\t\t\t\t    ul_temp);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_ret_get_log(struct mwifiex_private *priv,\n\t\t\t       struct host_cmd_ds_command *resp,\n\t\t\t       struct mwifiex_ds_get_stats *stats)\n{\n\tstruct host_cmd_ds_802_11_get_log *get_log =\n\t\t&resp->params.get_log;\n\n\tif (stats) {\n\t\tstats->mcast_tx_frame = le32_to_cpu(get_log->mcast_tx_frame);\n\t\tstats->failed = le32_to_cpu(get_log->failed);\n\t\tstats->retry = le32_to_cpu(get_log->retry);\n\t\tstats->multi_retry = le32_to_cpu(get_log->multi_retry);\n\t\tstats->frame_dup = le32_to_cpu(get_log->frame_dup);\n\t\tstats->rts_success = le32_to_cpu(get_log->rts_success);\n\t\tstats->rts_failure = le32_to_cpu(get_log->rts_failure);\n\t\tstats->ack_failure = le32_to_cpu(get_log->ack_failure);\n\t\tstats->rx_frag = le32_to_cpu(get_log->rx_frag);\n\t\tstats->mcast_rx_frame = le32_to_cpu(get_log->mcast_rx_frame);\n\t\tstats->fcs_error = le32_to_cpu(get_log->fcs_error);\n\t\tstats->tx_frame = le32_to_cpu(get_log->tx_frame);\n\t\tstats->wep_icv_error[0] =\n\t\t\tle32_to_cpu(get_log->wep_icv_err_cnt[0]);\n\t\tstats->wep_icv_error[1] =\n\t\t\tle32_to_cpu(get_log->wep_icv_err_cnt[1]);\n\t\tstats->wep_icv_error[2] =\n\t\t\tle32_to_cpu(get_log->wep_icv_err_cnt[2]);\n\t\tstats->wep_icv_error[3] =\n\t\t\tle32_to_cpu(get_log->wep_icv_err_cnt[3]);\n\t\tstats->bcn_rcv_cnt = le32_to_cpu(get_log->bcn_rcv_cnt);\n\t\tstats->bcn_miss_cnt = le32_to_cpu(get_log->bcn_miss_cnt);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_ret_tx_rate_cfg(struct mwifiex_private *priv,\n\t\t\t\t   struct host_cmd_ds_command *resp)\n{\n\tstruct host_cmd_ds_tx_rate_cfg *rate_cfg = &resp->params.tx_rate_cfg;\n\tstruct mwifiex_rate_scope *rate_scope;\n\tstruct mwifiex_ie_types_header *head;\n\tu16 tlv, tlv_buf_len, tlv_buf_left;\n\tu8 *tlv_buf;\n\tu32 i;\n\n\ttlv_buf = ((u8 *)rate_cfg) + sizeof(struct host_cmd_ds_tx_rate_cfg);\n\ttlv_buf_left = le16_to_cpu(resp->size) - S_DS_GEN - sizeof(*rate_cfg);\n\n\twhile (tlv_buf_left >= sizeof(*head)) {\n\t\thead = (struct mwifiex_ie_types_header *)tlv_buf;\n\t\ttlv = le16_to_cpu(head->type);\n\t\ttlv_buf_len = le16_to_cpu(head->len);\n\n\t\tif (tlv_buf_left < (sizeof(*head) + tlv_buf_len))\n\t\t\tbreak;\n\n\t\tswitch (tlv) {\n\t\tcase TLV_TYPE_RATE_SCOPE:\n\t\t\trate_scope = (struct mwifiex_rate_scope *) tlv_buf;\n\t\t\tpriv->bitmap_rates[0] =\n\t\t\t\tle16_to_cpu(rate_scope->hr_dsss_rate_bitmap);\n\t\t\tpriv->bitmap_rates[1] =\n\t\t\t\tle16_to_cpu(rate_scope->ofdm_rate_bitmap);\n\t\t\tfor (i = 0;\n\t\t\t     i < ARRAY_SIZE(rate_scope->ht_mcs_rate_bitmap);\n\t\t\t     i++)\n\t\t\t\tpriv->bitmap_rates[2 + i] =\n\t\t\t\t\tle16_to_cpu(rate_scope->\n\t\t\t\t\t\t    ht_mcs_rate_bitmap[i]);\n\n\t\t\tif (priv->adapter->fw_api_ver == MWIFIEX_FW_V15) {\n\t\t\t\tfor (i = 0; i < ARRAY_SIZE(rate_scope->\n\t\t\t\t\t\t\t   vht_mcs_rate_bitmap);\n\t\t\t\t     i++)\n\t\t\t\t\tpriv->bitmap_rates[10 + i] =\n\t\t\t\t\t    le16_to_cpu(rate_scope->\n\t\t\t\t\t\t\tvht_mcs_rate_bitmap[i]);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t \n\t\t}\n\n\t\ttlv_buf += (sizeof(*head) + tlv_buf_len);\n\t\ttlv_buf_left -= (sizeof(*head) + tlv_buf_len);\n\t}\n\n\tpriv->is_data_rate_auto = mwifiex_is_rate_auto(priv);\n\n\tif (priv->is_data_rate_auto)\n\t\tpriv->data_rate = 0;\n\telse\n\t\treturn mwifiex_send_cmd(priv, HostCmd_CMD_802_11_TX_RATE_QUERY,\n\t\t\t\t\tHostCmd_ACT_GEN_GET, 0, NULL, false);\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_get_power_level(struct mwifiex_private *priv, void *data_buf)\n{\n\tint length, max_power = -1, min_power = -1;\n\tstruct mwifiex_types_power_group *pg_tlv_hdr;\n\tstruct mwifiex_power_group *pg;\n\n\tif (!data_buf)\n\t\treturn -1;\n\n\tpg_tlv_hdr = (struct mwifiex_types_power_group *)((u8 *)data_buf);\n\tpg = (struct mwifiex_power_group *)\n\t\t((u8 *) pg_tlv_hdr + sizeof(struct mwifiex_types_power_group));\n\tlength = le16_to_cpu(pg_tlv_hdr->length);\n\n\t \n\tif (length < sizeof(struct mwifiex_power_group))\n\t\treturn 0;\n\n\tmax_power = pg->power_max;\n\tmin_power = pg->power_min;\n\tlength -= sizeof(struct mwifiex_power_group);\n\n\twhile (length >= sizeof(struct mwifiex_power_group)) {\n\t\tpg++;\n\t\tif (max_power < pg->power_max)\n\t\t\tmax_power = pg->power_max;\n\n\t\tif (min_power > pg->power_min)\n\t\t\tmin_power = pg->power_min;\n\n\t\tlength -= sizeof(struct mwifiex_power_group);\n\t}\n\tpriv->min_tx_power_level = (u8) min_power;\n\tpriv->max_tx_power_level = (u8) max_power;\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_ret_tx_power_cfg(struct mwifiex_private *priv,\n\t\t\t\t    struct host_cmd_ds_command *resp)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct host_cmd_ds_txpwr_cfg *txp_cfg = &resp->params.txp_cfg;\n\tstruct mwifiex_types_power_group *pg_tlv_hdr;\n\tstruct mwifiex_power_group *pg;\n\tu16 action = le16_to_cpu(txp_cfg->action);\n\tu16 tlv_buf_left;\n\n\tpg_tlv_hdr = (struct mwifiex_types_power_group *)\n\t\t((u8 *)txp_cfg +\n\t\t sizeof(struct host_cmd_ds_txpwr_cfg));\n\n\tpg = (struct mwifiex_power_group *)\n\t\t((u8 *)pg_tlv_hdr +\n\t\t sizeof(struct mwifiex_types_power_group));\n\n\ttlv_buf_left = le16_to_cpu(resp->size) - S_DS_GEN - sizeof(*txp_cfg);\n\tif (tlv_buf_left <\n\t\t\tle16_to_cpu(pg_tlv_hdr->length) + sizeof(*pg_tlv_hdr))\n\t\treturn 0;\n\n\tswitch (action) {\n\tcase HostCmd_ACT_GEN_GET:\n\t\tif (adapter->hw_status == MWIFIEX_HW_STATUS_INITIALIZING)\n\t\t\tmwifiex_get_power_level(priv, pg_tlv_hdr);\n\n\t\tpriv->tx_power_level = (u16) pg->power_min;\n\t\tbreak;\n\n\tcase HostCmd_ACT_GEN_SET:\n\t\tif (!le32_to_cpu(txp_cfg->mode))\n\t\t\tbreak;\n\n\t\tif (pg->power_max == pg->power_min)\n\t\t\tpriv->tx_power_level = (u16) pg->power_min;\n\t\tbreak;\n\tdefault:\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"CMD_RESP: unknown cmd action %d\\n\",\n\t\t\t    action);\n\t\treturn 0;\n\t}\n\tmwifiex_dbg(adapter, INFO,\n\t\t    \"info: Current TxPower Level = %d, Max Power=%d, Min Power=%d\\n\",\n\t\t    priv->tx_power_level, priv->max_tx_power_level,\n\t\t    priv->min_tx_power_level);\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_ret_rf_tx_power(struct mwifiex_private *priv,\n\t\t\t\t   struct host_cmd_ds_command *resp)\n{\n\tstruct host_cmd_ds_rf_tx_pwr *txp = &resp->params.txp;\n\tu16 action = le16_to_cpu(txp->action);\n\n\tpriv->tx_power_level = le16_to_cpu(txp->cur_level);\n\n\tif (action == HostCmd_ACT_GEN_GET) {\n\t\tpriv->max_tx_power_level = txp->max_power;\n\t\tpriv->min_tx_power_level = txp->min_power;\n\t}\n\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"Current TxPower Level=%d, Max Power=%d, Min Power=%d\\n\",\n\t\t    priv->tx_power_level, priv->max_tx_power_level,\n\t\t    priv->min_tx_power_level);\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_ret_rf_antenna(struct mwifiex_private *priv,\n\t\t\t\t  struct host_cmd_ds_command *resp)\n{\n\tstruct host_cmd_ds_rf_ant_mimo *ant_mimo = &resp->params.ant_mimo;\n\tstruct host_cmd_ds_rf_ant_siso *ant_siso = &resp->params.ant_siso;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\n\tif (adapter->hw_dev_mcs_support == HT_STREAM_2X2) {\n\t\tpriv->tx_ant = le16_to_cpu(ant_mimo->tx_ant_mode);\n\t\tpriv->rx_ant = le16_to_cpu(ant_mimo->rx_ant_mode);\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"RF_ANT_RESP: Tx action = 0x%x, Tx Mode = 0x%04x\\t\"\n\t\t\t    \"Rx action = 0x%x, Rx Mode = 0x%04x\\n\",\n\t\t\t    le16_to_cpu(ant_mimo->action_tx),\n\t\t\t    le16_to_cpu(ant_mimo->tx_ant_mode),\n\t\t\t    le16_to_cpu(ant_mimo->action_rx),\n\t\t\t    le16_to_cpu(ant_mimo->rx_ant_mode));\n\t} else {\n\t\tpriv->tx_ant = le16_to_cpu(ant_siso->ant_mode);\n\t\tpriv->rx_ant = le16_to_cpu(ant_siso->ant_mode);\n\t\tmwifiex_dbg(adapter, INFO,\n\t\t\t    \"RF_ANT_RESP: action = 0x%x, Mode = 0x%04x\\n\",\n\t\t\t    le16_to_cpu(ant_siso->action),\n\t\t\t    le16_to_cpu(ant_siso->ant_mode));\n\t}\n\treturn 0;\n}\n\n \nstatic int mwifiex_ret_802_11_mac_address(struct mwifiex_private *priv,\n\t\t\t\t\t  struct host_cmd_ds_command *resp)\n{\n\tstruct host_cmd_ds_802_11_mac_address *cmd_mac_addr =\n\t\t\t\t\t\t\t&resp->params.mac_addr;\n\n\tmemcpy(priv->curr_addr, cmd_mac_addr->mac_addr, ETH_ALEN);\n\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: set mac address: %pM\\n\", priv->curr_addr);\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_ret_mac_multicast_adr(struct mwifiex_private *priv,\n\t\t\t\t\t struct host_cmd_ds_command *resp)\n{\n\treturn 0;\n}\n\n \nstatic int mwifiex_ret_802_11_tx_rate_query(struct mwifiex_private *priv,\n\t\t\t\t\t    struct host_cmd_ds_command *resp)\n{\n\tpriv->tx_rate = resp->params.tx_rate.tx_rate;\n\tpriv->tx_htinfo = resp->params.tx_rate.ht_info;\n\tif (!priv->is_data_rate_auto)\n\t\tpriv->data_rate =\n\t\t\tmwifiex_index_to_data_rate(priv, priv->tx_rate,\n\t\t\t\t\t\t   priv->tx_htinfo);\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_ret_802_11_deauthenticate(struct mwifiex_private *priv,\n\t\t\t\t\t     struct host_cmd_ds_command *resp)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\n\tadapter->dbg.num_cmd_deauth++;\n\tif (!memcmp(resp->params.deauth.mac_addr,\n\t\t    &priv->curr_bss_params.bss_descriptor.mac_address,\n\t\t    sizeof(resp->params.deauth.mac_addr)))\n\t\tmwifiex_reset_connect_state(priv, WLAN_REASON_DEAUTH_LEAVING,\n\t\t\t\t\t    false);\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_ret_802_11_ad_hoc_stop(struct mwifiex_private *priv,\n\t\t\t\t\t  struct host_cmd_ds_command *resp)\n{\n\tmwifiex_reset_connect_state(priv, WLAN_REASON_DEAUTH_LEAVING, false);\n\treturn 0;\n}\n\n \nstatic int mwifiex_ret_802_11_key_material_v1(struct mwifiex_private *priv,\n\t\t\t\t\t      struct host_cmd_ds_command *resp)\n{\n\tstruct host_cmd_ds_802_11_key_material *key =\n\t\t\t\t\t\t&resp->params.key_material;\n\tint len;\n\n\tlen = le16_to_cpu(key->key_param_set.key_len);\n\tif (len > sizeof(key->key_param_set.key))\n\t\treturn -EINVAL;\n\n\tif (le16_to_cpu(key->action) == HostCmd_ACT_GEN_SET) {\n\t\tif ((le16_to_cpu(key->key_param_set.key_info) & KEY_MCAST)) {\n\t\t\tmwifiex_dbg(priv->adapter, INFO,\n\t\t\t\t    \"info: key: GTK is set\\n\");\n\t\t\tpriv->wpa_is_gtk_set = true;\n\t\t\tpriv->scan_block = false;\n\t\t\tpriv->port_open = true;\n\t\t}\n\t}\n\n\tmemset(priv->aes_key.key_param_set.key, 0,\n\t       sizeof(key->key_param_set.key));\n\tpriv->aes_key.key_param_set.key_len = cpu_to_le16(len);\n\tmemcpy(priv->aes_key.key_param_set.key, key->key_param_set.key, len);\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_ret_802_11_key_material_v2(struct mwifiex_private *priv,\n\t\t\t\t\t      struct host_cmd_ds_command *resp)\n{\n\tstruct host_cmd_ds_802_11_key_material_v2 *key_v2;\n\tint len;\n\n\tkey_v2 = &resp->params.key_material_v2;\n\n\tlen = le16_to_cpu(key_v2->key_param_set.key_params.aes.key_len);\n\tif (len > sizeof(key_v2->key_param_set.key_params.aes.key))\n\t\treturn -EINVAL;\n\n\tif (le16_to_cpu(key_v2->action) == HostCmd_ACT_GEN_SET) {\n\t\tif ((le16_to_cpu(key_v2->key_param_set.key_info) & KEY_MCAST)) {\n\t\t\tmwifiex_dbg(priv->adapter, INFO, \"info: key: GTK is set\\n\");\n\t\t\tpriv->wpa_is_gtk_set = true;\n\t\t\tpriv->scan_block = false;\n\t\t\tpriv->port_open = true;\n\t\t}\n\t}\n\n\tif (key_v2->key_param_set.key_type != KEY_TYPE_ID_AES)\n\t\treturn 0;\n\n\tmemset(priv->aes_key_v2.key_param_set.key_params.aes.key, 0,\n\t       sizeof(key_v2->key_param_set.key_params.aes.key));\n\tpriv->aes_key_v2.key_param_set.key_params.aes.key_len =\n\t\t\t\tcpu_to_le16(len);\n\tmemcpy(priv->aes_key_v2.key_param_set.key_params.aes.key,\n\t       key_v2->key_param_set.key_params.aes.key, len);\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_ret_802_11_key_material(struct mwifiex_private *priv,\n\t\t\t\t\t   struct host_cmd_ds_command *resp)\n{\n\tif (priv->adapter->key_api_major_ver == KEY_API_VER_MAJOR_V2)\n\t\treturn mwifiex_ret_802_11_key_material_v2(priv, resp);\n\telse\n\t\treturn mwifiex_ret_802_11_key_material_v1(priv, resp);\n}\n\n \nstatic int mwifiex_ret_802_11d_domain_info(struct mwifiex_private *priv,\n\t\t\t\t\t   struct host_cmd_ds_command *resp)\n{\n\tstruct host_cmd_ds_802_11d_domain_info_rsp *domain_info =\n\t\t&resp->params.domain_info_resp;\n\tstruct mwifiex_ietypes_domain_param_set *domain = &domain_info->domain;\n\tu16 action = le16_to_cpu(domain_info->action);\n\tu8 no_of_triplet;\n\n\tno_of_triplet = (u8) ((le16_to_cpu(domain->header.len)\n\t\t\t\t- IEEE80211_COUNTRY_STRING_LEN)\n\t\t\t      / sizeof(struct ieee80211_country_ie_triplet));\n\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: 11D Domain Info Resp: no_of_triplet=%d\\n\",\n\t\t    no_of_triplet);\n\n\tif (no_of_triplet > MWIFIEX_MAX_TRIPLET_802_11D) {\n\t\tmwifiex_dbg(priv->adapter, FATAL,\n\t\t\t    \"11D: invalid number of triplets %d returned\\n\",\n\t\t\t    no_of_triplet);\n\t\treturn -1;\n\t}\n\n\tswitch (action) {\n\tcase HostCmd_ACT_GEN_SET:   \n\t\tbreak;\n\tcase HostCmd_ACT_GEN_GET:\n\t\tbreak;\n\tdefault:\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"11D: invalid action:%d\\n\", domain_info->action);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_ret_ver_ext(struct mwifiex_private *priv,\n\t\t\t       struct host_cmd_ds_command *resp,\n\t\t\t       struct host_cmd_ds_version_ext *version_ext)\n{\n\tstruct host_cmd_ds_version_ext *ver_ext = &resp->params.verext;\n\n\tif (test_and_clear_bit(MWIFIEX_IS_REQUESTING_FW_VEREXT, &priv->adapter->work_flags)) {\n\t\tif (strncmp(ver_ext->version_str, \"ChipRev:20, BB:9b(10.00), RF:40(21)\",\n\t\t\t    MWIFIEX_VERSION_STR_LENGTH) == 0) {\n\t\t\tstruct mwifiex_ds_auto_ds auto_ds = {\n\t\t\t\t.auto_ds = DEEP_SLEEP_OFF,\n\t\t\t};\n\n\t\t\tmwifiex_dbg(priv->adapter, MSG,\n\t\t\t\t    \"Bad HW revision detected, disabling deep sleep\\n\");\n\n\t\t\tif (mwifiex_send_cmd(priv, HostCmd_CMD_802_11_PS_MODE_ENH,\n\t\t\t\t\t     DIS_AUTO_PS, BITMAP_AUTO_DS, &auto_ds, false)) {\n\t\t\t\tmwifiex_dbg(priv->adapter, MSG,\n\t\t\t\t\t    \"Disabling deep sleep failed.\\n\");\n\t\t\t}\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\tif (version_ext) {\n\t\tversion_ext->version_str_sel = ver_ext->version_str_sel;\n\t\tmemcpy(version_ext->version_str, ver_ext->version_str,\n\t\t       MWIFIEX_VERSION_STR_LENGTH);\n\t\tmemcpy(priv->version_str, ver_ext->version_str,\n\t\t       MWIFIEX_VERSION_STR_LENGTH);\n\n\t\t \n\t\tpriv->version_str[MWIFIEX_VERSION_STR_LENGTH - 1] = '\\0';\n\t}\n\treturn 0;\n}\n\n \nstatic int\nmwifiex_ret_remain_on_chan(struct mwifiex_private *priv,\n\t\t\t   struct host_cmd_ds_command *resp,\n\t\t\t   struct host_cmd_ds_remain_on_chan *roc_cfg)\n{\n\tstruct host_cmd_ds_remain_on_chan *resp_cfg = &resp->params.roc_cfg;\n\n\tif (roc_cfg)\n\t\tmemcpy(roc_cfg, resp_cfg, sizeof(*roc_cfg));\n\n\treturn 0;\n}\n\n \nstatic int\nmwifiex_ret_p2p_mode_cfg(struct mwifiex_private *priv,\n\t\t\t struct host_cmd_ds_command *resp,\n\t\t\t void *data_buf)\n{\n\tstruct host_cmd_ds_p2p_mode_cfg *mode_cfg = &resp->params.mode_cfg;\n\n\tif (data_buf)\n\t\tput_unaligned_le16(le16_to_cpu(mode_cfg->mode), data_buf);\n\n\treturn 0;\n}\n\n \nstatic int\nmwifiex_ret_mem_access(struct mwifiex_private *priv,\n\t\t       struct host_cmd_ds_command *resp, void *pioctl_buf)\n{\n\tstruct host_cmd_ds_mem_access *mem = (void *)&resp->params.mem;\n\n\tpriv->mem_rw.addr = le32_to_cpu(mem->addr);\n\tpriv->mem_rw.value = le32_to_cpu(mem->value);\n\n\treturn 0;\n}\n \nstatic int mwifiex_ret_reg_access(u16 type, struct host_cmd_ds_command *resp,\n\t\t\t\t  void *data_buf)\n{\n\tstruct mwifiex_ds_reg_rw *reg_rw;\n\tstruct mwifiex_ds_read_eeprom *eeprom;\n\tunion reg {\n\t\tstruct host_cmd_ds_mac_reg_access *mac;\n\t\tstruct host_cmd_ds_bbp_reg_access *bbp;\n\t\tstruct host_cmd_ds_rf_reg_access *rf;\n\t\tstruct host_cmd_ds_pmic_reg_access *pmic;\n\t\tstruct host_cmd_ds_802_11_eeprom_access *eeprom;\n\t} r;\n\n\tif (!data_buf)\n\t\treturn 0;\n\n\treg_rw = data_buf;\n\teeprom = data_buf;\n\tswitch (type) {\n\tcase HostCmd_CMD_MAC_REG_ACCESS:\n\t\tr.mac = &resp->params.mac_reg;\n\t\treg_rw->offset = (u32) le16_to_cpu(r.mac->offset);\n\t\treg_rw->value = le32_to_cpu(r.mac->value);\n\t\tbreak;\n\tcase HostCmd_CMD_BBP_REG_ACCESS:\n\t\tr.bbp = &resp->params.bbp_reg;\n\t\treg_rw->offset = (u32) le16_to_cpu(r.bbp->offset);\n\t\treg_rw->value = (u32) r.bbp->value;\n\t\tbreak;\n\n\tcase HostCmd_CMD_RF_REG_ACCESS:\n\t\tr.rf = &resp->params.rf_reg;\n\t\treg_rw->offset = (u32) le16_to_cpu(r.rf->offset);\n\t\treg_rw->value = (u32) r.bbp->value;\n\t\tbreak;\n\tcase HostCmd_CMD_PMIC_REG_ACCESS:\n\t\tr.pmic = &resp->params.pmic_reg;\n\t\treg_rw->offset = (u32) le16_to_cpu(r.pmic->offset);\n\t\treg_rw->value = (u32) r.pmic->value;\n\t\tbreak;\n\tcase HostCmd_CMD_CAU_REG_ACCESS:\n\t\tr.rf = &resp->params.rf_reg;\n\t\treg_rw->offset = (u32) le16_to_cpu(r.rf->offset);\n\t\treg_rw->value = (u32) r.rf->value;\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_EEPROM_ACCESS:\n\t\tr.eeprom = &resp->params.eeprom;\n\t\tpr_debug(\"info: EEPROM read len=%x\\n\",\n\t\t\t\tle16_to_cpu(r.eeprom->byte_count));\n\t\tif (eeprom->byte_count < le16_to_cpu(r.eeprom->byte_count)) {\n\t\t\teeprom->byte_count = 0;\n\t\t\tpr_debug(\"info: EEPROM read length is too big\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\teeprom->offset = le16_to_cpu(r.eeprom->offset);\n\t\teeprom->byte_count = le16_to_cpu(r.eeprom->byte_count);\n\t\tif (eeprom->byte_count > 0)\n\t\t\tmemcpy(&eeprom->value, &r.eeprom->value,\n\t\t\t       min((u16)MAX_EEPROM_DATA, eeprom->byte_count));\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n \nstatic int mwifiex_ret_ibss_coalescing_status(struct mwifiex_private *priv,\n\t\t\t\t\t      struct host_cmd_ds_command *resp)\n{\n\tstruct host_cmd_ds_802_11_ibss_status *ibss_coal_resp =\n\t\t\t\t\t&(resp->params.ibss_coalescing);\n\n\tif (le16_to_cpu(ibss_coal_resp->action) == HostCmd_ACT_GEN_SET)\n\t\treturn 0;\n\n\tmwifiex_dbg(priv->adapter, INFO,\n\t\t    \"info: new BSSID %pM\\n\", ibss_coal_resp->bssid);\n\n\t \n\tif (is_zero_ether_addr(ibss_coal_resp->bssid)) {\n\t\tmwifiex_dbg(priv->adapter, FATAL, \"new BSSID is NULL\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tif (!ether_addr_equal(priv->curr_bss_params.bss_descriptor.mac_address, ibss_coal_resp->bssid)) {\n\t\t \n\t\tmemcpy(priv->curr_bss_params.bss_descriptor.mac_address,\n\t\t       ibss_coal_resp->bssid, ETH_ALEN);\n\n\t\t \n\t\tpriv->curr_bss_params.bss_descriptor.beacon_period\n\t\t\t= le16_to_cpu(ibss_coal_resp->beacon_interval);\n\n\t\t \n\t\tpriv->curr_bss_params.bss_descriptor.erp_flags =\n\t\t\t(u8) le16_to_cpu(ibss_coal_resp->use_g_rate_protect);\n\n\t\tpriv->adhoc_state = ADHOC_COALESCED;\n\t}\n\n\treturn 0;\n}\nstatic int mwifiex_ret_tdls_oper(struct mwifiex_private *priv,\n\t\t\t\t struct host_cmd_ds_command *resp)\n{\n\tstruct host_cmd_ds_tdls_oper *cmd_tdls_oper = &resp->params.tdls_oper;\n\tu16 reason = le16_to_cpu(cmd_tdls_oper->reason);\n\tu16 action = le16_to_cpu(cmd_tdls_oper->tdls_action);\n\tstruct mwifiex_sta_node *node =\n\t\t\t   mwifiex_get_sta_entry(priv, cmd_tdls_oper->peer_mac);\n\n\tswitch (action) {\n\tcase ACT_TDLS_DELETE:\n\t\tif (reason) {\n\t\t\tif (!node || reason == TDLS_ERR_LINK_NONEXISTENT)\n\t\t\t\tmwifiex_dbg(priv->adapter, MSG,\n\t\t\t\t\t    \"TDLS link delete for %pM failed: reason %d\\n\",\n\t\t\t\t\t    cmd_tdls_oper->peer_mac, reason);\n\t\t\telse\n\t\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t\t    \"TDLS link delete for %pM failed: reason %d\\n\",\n\t\t\t\t\t    cmd_tdls_oper->peer_mac, reason);\n\t\t} else {\n\t\t\tmwifiex_dbg(priv->adapter, MSG,\n\t\t\t\t    \"TDLS link delete for %pM successful\\n\",\n\t\t\t\t    cmd_tdls_oper->peer_mac);\n\t\t}\n\t\tbreak;\n\tcase ACT_TDLS_CREATE:\n\t\tif (reason) {\n\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t    \"TDLS link creation for %pM failed: reason %d\",\n\t\t\t\t    cmd_tdls_oper->peer_mac, reason);\n\t\t\tif (node && reason != TDLS_ERR_LINK_EXISTS)\n\t\t\t\tnode->tdls_status = TDLS_SETUP_FAILURE;\n\t\t} else {\n\t\t\tmwifiex_dbg(priv->adapter, MSG,\n\t\t\t\t    \"TDLS link creation for %pM successful\",\n\t\t\t\t    cmd_tdls_oper->peer_mac);\n\t\t}\n\t\tbreak;\n\tcase ACT_TDLS_CONFIG:\n\t\tif (reason) {\n\t\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t\t    \"TDLS link config for %pM failed, reason %d\\n\",\n\t\t\t\t    cmd_tdls_oper->peer_mac, reason);\n\t\t\tif (node)\n\t\t\t\tnode->tdls_status = TDLS_SETUP_FAILURE;\n\t\t} else {\n\t\t\tmwifiex_dbg(priv->adapter, MSG,\n\t\t\t\t    \"TDLS link config for %pM successful\\n\",\n\t\t\t\t    cmd_tdls_oper->peer_mac);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tmwifiex_dbg(priv->adapter, ERROR,\n\t\t\t    \"Unknown TDLS command action response %d\", action);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n \nstatic int mwifiex_ret_subsc_evt(struct mwifiex_private *priv,\n\t\t\t\t struct host_cmd_ds_command *resp)\n{\n\tstruct host_cmd_ds_802_11_subsc_evt *cmd_sub_event =\n\t\t&resp->params.subsc_evt;\n\n\t \n\tmwifiex_dbg(priv->adapter, EVENT,\n\t\t    \"Bitmap of currently subscribed events: %16x\\n\",\n\t\t    le16_to_cpu(cmd_sub_event->events));\n\n\treturn 0;\n}\n\nstatic int mwifiex_ret_uap_sta_list(struct mwifiex_private *priv,\n\t\t\t\t    struct host_cmd_ds_command *resp)\n{\n\tstruct host_cmd_ds_sta_list *sta_list =\n\t\t&resp->params.sta_list;\n\tstruct mwifiex_ie_types_sta_info *sta_info = (void *)&sta_list->tlv;\n\tint i;\n\tstruct mwifiex_sta_node *sta_node;\n\n\tfor (i = 0; i < (le16_to_cpu(sta_list->sta_count)); i++) {\n\t\tsta_node = mwifiex_get_sta_entry(priv, sta_info->mac);\n\t\tif (unlikely(!sta_node))\n\t\t\tcontinue;\n\n\t\tsta_node->stats.rssi = sta_info->rssi;\n\t\tsta_info++;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_ret_cfg_data(struct mwifiex_private *priv,\n\t\t\t\tstruct host_cmd_ds_command *resp)\n{\n\tif (resp->result != HostCmd_RESULT_OK) {\n\t\tmwifiex_dbg(priv->adapter, ERROR, \"Cal data cmd resp failed\\n\");\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mwifiex_ret_sdio_rx_aggr_cfg(struct mwifiex_private *priv,\n\t\t\t\t\tstruct host_cmd_ds_command *resp)\n{\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tstruct host_cmd_sdio_sp_rx_aggr_cfg *cfg =\n\t\t\t\t&resp->params.sdio_rx_aggr_cfg;\n\n\tadapter->sdio_rx_aggr_enable = cfg->enable;\n\tadapter->sdio_rx_block_size = le16_to_cpu(cfg->block_size);\n\n\treturn 0;\n}\n\nstatic int mwifiex_ret_robust_coex(struct mwifiex_private *priv,\n\t\t\t\t   struct host_cmd_ds_command *resp,\n\t\t\t\t   bool *is_timeshare)\n{\n\tstruct host_cmd_ds_robust_coex *coex = &resp->params.coex;\n\tstruct mwifiex_ie_types_robust_coex *coex_tlv;\n\tu16 action = le16_to_cpu(coex->action);\n\tu32 mode;\n\n\tcoex_tlv = (struct mwifiex_ie_types_robust_coex\n\t\t    *)((u8 *)coex + sizeof(struct host_cmd_ds_robust_coex));\n\tif (action == HostCmd_ACT_GEN_GET) {\n\t\tmode = le32_to_cpu(coex_tlv->mode);\n\t\tif (mode == MWIFIEX_COEX_MODE_TIMESHARE)\n\t\t\t*is_timeshare = true;\n\t\telse\n\t\t\t*is_timeshare = false;\n\t}\n\n\treturn 0;\n}\n\nstatic struct ieee80211_regdomain *\nmwifiex_create_custom_regdomain(struct mwifiex_private *priv,\n\t\t\t\tu8 *buf, u16 buf_len)\n{\n\tu16 num_chan = buf_len / 2;\n\tstruct ieee80211_regdomain *regd;\n\tstruct ieee80211_reg_rule *rule;\n\tbool new_rule;\n\tint idx, freq, prev_freq = 0;\n\tu32 bw, prev_bw = 0;\n\tu8 chflags, prev_chflags = 0, valid_rules = 0;\n\n\tif (WARN_ON_ONCE(num_chan > NL80211_MAX_SUPP_REG_RULES))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tregd = kzalloc(struct_size(regd, reg_rules, num_chan), GFP_KERNEL);\n\tif (!regd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (idx = 0; idx < num_chan; idx++) {\n\t\tu8 chan;\n\t\tenum nl80211_band band;\n\n\t\tchan = *buf++;\n\t\tif (!chan) {\n\t\t\tkfree(regd);\n\t\t\treturn NULL;\n\t\t}\n\t\tchflags = *buf++;\n\t\tband = (chan <= 14) ? NL80211_BAND_2GHZ : NL80211_BAND_5GHZ;\n\t\tfreq = ieee80211_channel_to_frequency(chan, band);\n\t\tnew_rule = false;\n\n\t\tif (chflags & MWIFIEX_CHANNEL_DISABLED)\n\t\t\tcontinue;\n\n\t\tif (band == NL80211_BAND_5GHZ) {\n\t\t\tif (!(chflags & MWIFIEX_CHANNEL_NOHT80))\n\t\t\t\tbw = MHZ_TO_KHZ(80);\n\t\t\telse if (!(chflags & MWIFIEX_CHANNEL_NOHT40))\n\t\t\t\tbw = MHZ_TO_KHZ(40);\n\t\t\telse\n\t\t\t\tbw = MHZ_TO_KHZ(20);\n\t\t} else {\n\t\t\tif (!(chflags & MWIFIEX_CHANNEL_NOHT40))\n\t\t\t\tbw = MHZ_TO_KHZ(40);\n\t\t\telse\n\t\t\t\tbw = MHZ_TO_KHZ(20);\n\t\t}\n\n\t\tif (idx == 0 || prev_chflags != chflags || prev_bw != bw ||\n\t\t    freq - prev_freq > 20) {\n\t\t\tvalid_rules++;\n\t\t\tnew_rule = true;\n\t\t}\n\n\t\trule = &regd->reg_rules[valid_rules - 1];\n\n\t\trule->freq_range.end_freq_khz = MHZ_TO_KHZ(freq + 10);\n\n\t\tprev_chflags = chflags;\n\t\tprev_freq = freq;\n\t\tprev_bw = bw;\n\n\t\tif (!new_rule)\n\t\t\tcontinue;\n\n\t\trule->freq_range.start_freq_khz = MHZ_TO_KHZ(freq - 10);\n\t\trule->power_rule.max_eirp = DBM_TO_MBM(19);\n\n\t\tif (chflags & MWIFIEX_CHANNEL_PASSIVE)\n\t\t\trule->flags = NL80211_RRF_NO_IR;\n\n\t\tif (chflags & MWIFIEX_CHANNEL_DFS)\n\t\t\trule->flags = NL80211_RRF_DFS;\n\n\t\trule->freq_range.max_bandwidth_khz = bw;\n\t}\n\n\tregd->n_reg_rules = valid_rules;\n\tregd->alpha2[0] = '9';\n\tregd->alpha2[1] = '9';\n\n\treturn regd;\n}\n\nstatic int mwifiex_ret_chan_region_cfg(struct mwifiex_private *priv,\n\t\t\t\t       struct host_cmd_ds_command *resp)\n{\n\tstruct host_cmd_ds_chan_region_cfg *reg = &resp->params.reg_cfg;\n\tu16 action = le16_to_cpu(reg->action);\n\tu16 tlv, tlv_buf_len, tlv_buf_left;\n\tstruct mwifiex_ie_types_header *head;\n\tstruct ieee80211_regdomain *regd;\n\tu8 *tlv_buf;\n\n\tif (action != HostCmd_ACT_GEN_GET)\n\t\treturn 0;\n\n\ttlv_buf = (u8 *)reg + sizeof(*reg);\n\ttlv_buf_left = le16_to_cpu(resp->size) - S_DS_GEN - sizeof(*reg);\n\n\twhile (tlv_buf_left >= sizeof(*head)) {\n\t\thead = (struct mwifiex_ie_types_header *)tlv_buf;\n\t\ttlv = le16_to_cpu(head->type);\n\t\ttlv_buf_len = le16_to_cpu(head->len);\n\n\t\tif (tlv_buf_left < (sizeof(*head) + tlv_buf_len))\n\t\t\tbreak;\n\n\t\tswitch (tlv) {\n\t\tcase TLV_TYPE_CHAN_ATTR_CFG:\n\t\t\tmwifiex_dbg_dump(priv->adapter, CMD_D, \"CHAN:\",\n\t\t\t\t\t (u8 *)head + sizeof(*head),\n\t\t\t\t\t tlv_buf_len);\n\t\t\tregd = mwifiex_create_custom_regdomain(priv,\n\t\t\t\t(u8 *)head + sizeof(*head), tlv_buf_len);\n\t\t\tif (!IS_ERR(regd))\n\t\t\t\tpriv->adapter->regd = regd;\n\t\t\tbreak;\n\t\t}\n\n\t\ttlv_buf += (sizeof(*head) + tlv_buf_len);\n\t\ttlv_buf_left -= (sizeof(*head) + tlv_buf_len);\n\t}\n\n\treturn 0;\n}\n\nstatic int mwifiex_ret_pkt_aggr_ctrl(struct mwifiex_private *priv,\n\t\t\t\t     struct host_cmd_ds_command *resp)\n{\n\tstruct host_cmd_ds_pkt_aggr_ctrl *pkt_aggr_ctrl =\n\t\t\t\t\t&resp->params.pkt_aggr_ctrl;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\n\tadapter->bus_aggr.enable = le16_to_cpu(pkt_aggr_ctrl->enable);\n\tif (adapter->bus_aggr.enable)\n\t\tadapter->intf_hdr_len = INTF_HEADER_LEN;\n\tadapter->bus_aggr.mode = MWIFIEX_BUS_AGGR_MODE_LEN_V2;\n\tadapter->bus_aggr.tx_aggr_max_size =\n\t\t\t\tle16_to_cpu(pkt_aggr_ctrl->tx_aggr_max_size);\n\tadapter->bus_aggr.tx_aggr_max_num =\n\t\t\t\tle16_to_cpu(pkt_aggr_ctrl->tx_aggr_max_num);\n\tadapter->bus_aggr.tx_aggr_align =\n\t\t\t\tle16_to_cpu(pkt_aggr_ctrl->tx_aggr_align);\n\n\treturn 0;\n}\n\nstatic int mwifiex_ret_get_chan_info(struct mwifiex_private *priv,\n\t\t\t\t     struct host_cmd_ds_command *resp,\n\t\t\t\t     struct mwifiex_channel_band *channel_band)\n{\n\tstruct host_cmd_ds_sta_configure *sta_cfg_cmd = &resp->params.sta_cfg;\n\tstruct host_cmd_tlv_channel_band *tlv_band_channel;\n\n\ttlv_band_channel =\n\t(struct host_cmd_tlv_channel_band *)sta_cfg_cmd->tlv_buffer;\n\tmemcpy(&channel_band->band_config, &tlv_band_channel->band_config,\n\t       sizeof(struct mwifiex_band_config));\n\tchannel_band->channel = tlv_band_channel->channel;\n\n\treturn 0;\n}\n\n \nint mwifiex_process_sta_cmdresp(struct mwifiex_private *priv, u16 cmdresp_no,\n\t\t\t\tstruct host_cmd_ds_command *resp)\n{\n\tint ret = 0;\n\tstruct mwifiex_adapter *adapter = priv->adapter;\n\tvoid *data_buf = adapter->curr_cmd->data_buf;\n\n\t \n\tif (resp->result != HostCmd_RESULT_OK) {\n\t\tmwifiex_process_cmdresp_error(priv, resp);\n\t\treturn -1;\n\t}\n\t \n\tswitch (cmdresp_no) {\n\tcase HostCmd_CMD_GET_HW_SPEC:\n\t\tret = mwifiex_ret_get_hw_spec(priv, resp);\n\t\tbreak;\n\tcase HostCmd_CMD_CFG_DATA:\n\t\tret = mwifiex_ret_cfg_data(priv, resp);\n\t\tbreak;\n\tcase HostCmd_CMD_MAC_CONTROL:\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_MAC_ADDRESS:\n\t\tret = mwifiex_ret_802_11_mac_address(priv, resp);\n\t\tbreak;\n\tcase HostCmd_CMD_MAC_MULTICAST_ADR:\n\t\tret = mwifiex_ret_mac_multicast_adr(priv, resp);\n\t\tbreak;\n\tcase HostCmd_CMD_TX_RATE_CFG:\n\t\tret = mwifiex_ret_tx_rate_cfg(priv, resp);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_SCAN:\n\t\tret = mwifiex_ret_802_11_scan(priv, resp);\n\t\tadapter->curr_cmd->wait_q_enabled = false;\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_SCAN_EXT:\n\t\tret = mwifiex_ret_802_11_scan_ext(priv, resp);\n\t\tadapter->curr_cmd->wait_q_enabled = false;\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_BG_SCAN_QUERY:\n\t\tret = mwifiex_ret_802_11_scan(priv, resp);\n\t\tcfg80211_sched_scan_results(priv->wdev.wiphy, 0);\n\t\tmwifiex_dbg(adapter, CMD,\n\t\t\t    \"info: CMD_RESP: BG_SCAN result is ready!\\n\");\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_BG_SCAN_CONFIG:\n\t\tbreak;\n\tcase HostCmd_CMD_TXPWR_CFG:\n\t\tret = mwifiex_ret_tx_power_cfg(priv, resp);\n\t\tbreak;\n\tcase HostCmd_CMD_RF_TX_PWR:\n\t\tret = mwifiex_ret_rf_tx_power(priv, resp);\n\t\tbreak;\n\tcase HostCmd_CMD_RF_ANTENNA:\n\t\tret = mwifiex_ret_rf_antenna(priv, resp);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_PS_MODE_ENH:\n\t\tret = mwifiex_ret_enh_power_mode(priv, resp, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_HS_CFG_ENH:\n\t\tret = mwifiex_ret_802_11_hs_cfg(priv, resp);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_ASSOCIATE:\n\t\tret = mwifiex_ret_802_11_associate(priv, resp);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_DEAUTHENTICATE:\n\t\tret = mwifiex_ret_802_11_deauthenticate(priv, resp);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_AD_HOC_START:\n\tcase HostCmd_CMD_802_11_AD_HOC_JOIN:\n\t\tret = mwifiex_ret_802_11_ad_hoc(priv, resp);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_AD_HOC_STOP:\n\t\tret = mwifiex_ret_802_11_ad_hoc_stop(priv, resp);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_GET_LOG:\n\t\tret = mwifiex_ret_get_log(priv, resp, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_RSSI_INFO:\n\t\tret = mwifiex_ret_802_11_rssi_info(priv, resp);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_SNMP_MIB:\n\t\tret = mwifiex_ret_802_11_snmp_mib(priv, resp, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_TX_RATE_QUERY:\n\t\tret = mwifiex_ret_802_11_tx_rate_query(priv, resp);\n\t\tbreak;\n\tcase HostCmd_CMD_VERSION_EXT:\n\t\tret = mwifiex_ret_ver_ext(priv, resp, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_REMAIN_ON_CHAN:\n\t\tret = mwifiex_ret_remain_on_chan(priv, resp, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_11AC_CFG:\n\t\tbreak;\n\tcase HostCmd_CMD_PACKET_AGGR_CTRL:\n\t\tret = mwifiex_ret_pkt_aggr_ctrl(priv, resp);\n\t\tbreak;\n\tcase HostCmd_CMD_P2P_MODE_CFG:\n\t\tret = mwifiex_ret_p2p_mode_cfg(priv, resp, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_MGMT_FRAME_REG:\n\tcase HostCmd_CMD_FUNC_INIT:\n\tcase HostCmd_CMD_FUNC_SHUTDOWN:\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_KEY_MATERIAL:\n\t\tret = mwifiex_ret_802_11_key_material(priv, resp);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11D_DOMAIN_INFO:\n\t\tret = mwifiex_ret_802_11d_domain_info(priv, resp);\n\t\tbreak;\n\tcase HostCmd_CMD_11N_ADDBA_REQ:\n\t\tret = mwifiex_ret_11n_addba_req(priv, resp);\n\t\tbreak;\n\tcase HostCmd_CMD_11N_DELBA:\n\t\tret = mwifiex_ret_11n_delba(priv, resp);\n\t\tbreak;\n\tcase HostCmd_CMD_11N_ADDBA_RSP:\n\t\tret = mwifiex_ret_11n_addba_resp(priv, resp);\n\t\tbreak;\n\tcase HostCmd_CMD_RECONFIGURE_TX_BUFF:\n\t\tif (0xffff == (u16)le16_to_cpu(resp->params.tx_buf.buff_size)) {\n\t\t\tif (adapter->iface_type == MWIFIEX_USB &&\n\t\t\t    adapter->usb_mc_setup) {\n\t\t\t\tif (adapter->if_ops.multi_port_resync)\n\t\t\t\t\tadapter->if_ops.\n\t\t\t\t\t\tmulti_port_resync(adapter);\n\t\t\t\tadapter->usb_mc_setup = false;\n\t\t\t\tadapter->tx_lock_flag = false;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tadapter->tx_buf_size = (u16) le16_to_cpu(resp->params.\n\t\t\t\t\t\t\t     tx_buf.buff_size);\n\t\tadapter->tx_buf_size = (adapter->tx_buf_size\n\t\t\t\t\t/ MWIFIEX_SDIO_BLOCK_SIZE)\n\t\t\t\t       * MWIFIEX_SDIO_BLOCK_SIZE;\n\t\tadapter->curr_tx_buf_size = adapter->tx_buf_size;\n\t\tmwifiex_dbg(adapter, CMD, \"cmd: curr_tx_buf_size=%d\\n\",\n\t\t\t    adapter->curr_tx_buf_size);\n\n\t\tif (adapter->if_ops.update_mp_end_port)\n\t\t\tadapter->if_ops.update_mp_end_port(adapter,\n\t\t\t\tle16_to_cpu(resp->params.tx_buf.mp_end_port));\n\t\tbreak;\n\tcase HostCmd_CMD_AMSDU_AGGR_CTRL:\n\t\tbreak;\n\tcase HostCmd_CMD_WMM_GET_STATUS:\n\t\tret = mwifiex_ret_wmm_get_status(priv, resp);\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_IBSS_COALESCING_STATUS:\n\t\tret = mwifiex_ret_ibss_coalescing_status(priv, resp);\n\t\tbreak;\n\tcase HostCmd_CMD_MEM_ACCESS:\n\t\tret = mwifiex_ret_mem_access(priv, resp, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_MAC_REG_ACCESS:\n\tcase HostCmd_CMD_BBP_REG_ACCESS:\n\tcase HostCmd_CMD_RF_REG_ACCESS:\n\tcase HostCmd_CMD_PMIC_REG_ACCESS:\n\tcase HostCmd_CMD_CAU_REG_ACCESS:\n\tcase HostCmd_CMD_802_11_EEPROM_ACCESS:\n\t\tret = mwifiex_ret_reg_access(cmdresp_no, resp, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_SET_BSS_MODE:\n\t\tbreak;\n\tcase HostCmd_CMD_11N_CFG:\n\t\tbreak;\n\tcase HostCmd_CMD_PCIE_DESC_DETAILS:\n\t\tbreak;\n\tcase HostCmd_CMD_802_11_SUBSCRIBE_EVENT:\n\t\tret = mwifiex_ret_subsc_evt(priv, resp);\n\t\tbreak;\n\tcase HostCmd_CMD_UAP_SYS_CONFIG:\n\t\tbreak;\n\tcase HOST_CMD_APCMD_STA_LIST:\n\t\tret = mwifiex_ret_uap_sta_list(priv, resp);\n\t\tbreak;\n\tcase HostCmd_CMD_UAP_BSS_START:\n\t\tadapter->tx_lock_flag = false;\n\t\tadapter->pps_uapsd_mode = false;\n\t\tadapter->delay_null_pkt = false;\n\t\tpriv->bss_started = 1;\n\t\tbreak;\n\tcase HostCmd_CMD_UAP_BSS_STOP:\n\t\tpriv->bss_started = 0;\n\t\tbreak;\n\tcase HostCmd_CMD_UAP_STA_DEAUTH:\n\t\tbreak;\n\tcase HOST_CMD_APCMD_SYS_RESET:\n\t\tbreak;\n\tcase HostCmd_CMD_MEF_CFG:\n\t\tbreak;\n\tcase HostCmd_CMD_COALESCE_CFG:\n\t\tbreak;\n\tcase HostCmd_CMD_TDLS_OPER:\n\t\tret = mwifiex_ret_tdls_oper(priv, resp);\n\t\tbreak;\n\tcase HostCmd_CMD_MC_POLICY:\n\t\tbreak;\n\tcase HostCmd_CMD_CHAN_REPORT_REQUEST:\n\t\tbreak;\n\tcase HostCmd_CMD_SDIO_SP_RX_AGGR_CFG:\n\t\tret = mwifiex_ret_sdio_rx_aggr_cfg(priv, resp);\n\t\tbreak;\n\tcase HostCmd_CMD_HS_WAKEUP_REASON:\n\t\tret = mwifiex_ret_wakeup_reason(priv, resp, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_TDLS_CONFIG:\n\t\tbreak;\n\tcase HostCmd_CMD_ROBUST_COEX:\n\t\tret = mwifiex_ret_robust_coex(priv, resp, data_buf);\n\t\tbreak;\n\tcase HostCmd_CMD_GTK_REKEY_OFFLOAD_CFG:\n\t\tbreak;\n\tcase HostCmd_CMD_CHAN_REGION_CFG:\n\t\tret = mwifiex_ret_chan_region_cfg(priv, resp);\n\t\tbreak;\n\tcase HostCmd_CMD_STA_CONFIGURE:\n\t\tret = mwifiex_ret_get_chan_info(priv, resp, data_buf);\n\t\tbreak;\n\tdefault:\n\t\tmwifiex_dbg(adapter, ERROR,\n\t\t\t    \"CMD_RESP: unknown cmd response %#x\\n\",\n\t\t\t    resp->command);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}